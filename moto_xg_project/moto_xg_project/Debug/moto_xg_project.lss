
moto_xg_project.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00002004  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         00009e60  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .exception    00000200  8000c000  8000c000  0000c400  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       0000125c  8000c200  8000c200  0000c600  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .dalign       00000004  8000d45c  8000d45c  0000d85c  2**0
                  ALLOC
  6 .data         00000a20  00000004  8000d460  0000dc04  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .balign       00000004  00000a24  8000de80  0000e624  2**0
                  ALLOC
  8 .bss          000015b0  00000a28  8000de80  0000e628  2**2
                  ALLOC
  9 .comment      00000030  00000000  00000000  0000e624  2**0
                  CONTENTS, READONLY
 10 .debug_aranges 00001710  00000000  00000000  0000e658  2**3
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_pubnames 000035a4  00000000  00000000  0000fd68  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_info   0002c736  00000000  00000000  0001330c  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_abbrev 000074d9  00000000  00000000  0003fa42  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_line   0000d886  00000000  00000000  00046f1b  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_frame  00003f48  00000000  00000000  000547a4  2**2
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_str    00007e21  00000000  00000000  000586ec  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_loc    0000fbbe  00000000  00000000  0006050d  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .stack        00001000  00017000  00017000  00000400  2**0
                  ALLOC
 19 .debug_ranges 000017d0  00000000  00000000  000700d0  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_trampoline>:

  .global _trampoline
  .type _trampoline, @function
_trampoline:
  // Jump to program start.
  rjmp    program_start
80000000:	e0 8f 10 00 	bral	80002000 <program_start>
	...

80002000 <program_start>:
	   // rjmp    program_start

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002000:	fe cf d0 04 	sub	pc,pc,-12284

Disassembly of section .text:

80002004 <DeviceManagement_brdcst_func>:
80002004:	19 a9       	ld.ub	r9,r12[0x2]
80002006:	30 18       	mov	r8,1
		U8 temp = 0;
		temp  = xcmp->u8[1] << 8;
		temp |= xcmp->u8[2];
		//if (temp == theXNL_Ctrlr.XNL_DeviceLogicalAddress)
		{
			if (xcmp->u8[0] == 0x01)
80002008:	f0 09 18 00 	cp.b	r9,r8
8000200c:	c0 61       	brne	80002018 <DeviceManagement_brdcst_func+0x14>
			{
				bunchofrandomstatusflags |= 0x00000002;
8000200e:	48 68       	lddpc	r8,80002024 <DeviceManagement_brdcst_func+0x20>
80002010:	70 09       	ld.w	r9,r8[0x0]
80002012:	a1 b9       	sbr	r9,0x1
80002014:	91 09       	st.w	r8[0x0],r9
80002016:	5e fc       	retal	r12
			}
			else
			{
				bunchofrandomstatusflags &= 0xFFFFFFFD;
80002018:	48 38       	lddpc	r8,80002024 <DeviceManagement_brdcst_func+0x20>
8000201a:	70 09       	ld.w	r9,r8[0x0]
8000201c:	a1 d9       	cbr	r9,0x1
8000201e:	91 09       	st.w	r8[0x0],r9
80002020:	5e fc       	retal	r12
80002022:	00 00       	add	r0,r0
80002024:	00 00       	add	r0,r0
80002026:	0d 14       	ld.sh	r4,r6++

80002028 <Volume_brdcst_func>:
	//log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
	
	//log("\n\r Audio_Parameter: %x \n\r", ptr->Audio_Parameter);
	
	
}
80002028:	5e fc       	retal	r12

8000202a <AudioRoutingControl_brdcst_func>:
	//
	//log("\n\r Audio-Function: %x \n\r", xcmp->u8[3+j*2-1]);
	
	
	
}
8000202a:	5e fc       	retal	r12

8000202c <vApplicationIdleHook>:
}

void vApplicationIdleHook( void )
{
	/* This hook function does nothing but increment a counter. */
	ulIdleCycleCount++;
8000202c:	48 38       	lddpc	r8,80002038 <vApplicationIdleHook+0xc>
8000202e:	70 09       	ld.w	r9,r8[0x0]
80002030:	2f f9       	sub	r9,-1
80002032:	91 09       	st.w	r8[0x0],r9
	
}
80002034:	5e fc       	retal	r12
80002036:	00 00       	add	r0,r0
80002038:	00 00       	add	r0,r0
8000203a:	0a 40       	or	r0,r5

8000203c <app_init>:
	//0x00,0x39


};
void app_init(void)
{	
8000203c:	d4 01       	pushm	lr
	xcmp_register_app_list(the_app_list);
8000203e:	48 cc       	lddpc	r12,8000206c <app_init+0x30>
80002040:	f0 1f 00 0c 	mcall	80002070 <app_init+0x34>
	
	//将app_payload_rx_proc更改为PCM加密功能
	payload_init( app_payload_rx_proc , app_payload_tx_proc );
80002044:	48 cb       	lddpc	r11,80002074 <app_init+0x38>
80002046:	48 dc       	lddpc	r12,80002078 <app_init+0x3c>
80002048:	f0 1f 00 0d 	mcall	8000207c <app_init+0x40>
	
	static portBASE_TYPE res = 0;
	 res = xTaskCreate(
8000204c:	30 09       	mov	r9,0
8000204e:	1a d9       	st.w	--sp,r9
80002050:	1a d9       	st.w	--sp,r9
80002052:	1a d9       	st.w	--sp,r9
80002054:	30 18       	mov	r8,1
80002056:	e0 6a 01 80 	mov	r10,384
8000205a:	48 ab       	lddpc	r11,80002080 <app_init+0x44>
8000205c:	48 ac       	lddpc	r12,80002084 <app_init+0x48>
8000205e:	f0 1f 00 0b 	mcall	80002088 <app_init+0x4c>
80002062:	48 b8       	lddpc	r8,8000208c <app_init+0x50>
80002064:	91 0c       	st.w	r8[0x0],r12
80002066:	2f dd       	sub	sp,-12
	,  384//1024//800//384
	,  NULL
	,  1
	,  NULL );
	
}
80002068:	d8 02       	popm	pc
8000206a:	00 00       	add	r0,r0
8000206c:	00 00       	add	r0,r0
8000206e:	00 08       	add	r8,r0
80002070:	80 00       	ld.sh	r0,r0[0x0]
80002072:	32 18       	mov	r8,33
80002074:	80 00       	ld.sh	r0,r0[0x0]
80002076:	20 90       	sub	r0,9
80002078:	80 00       	ld.sh	r0,r0[0x0]
8000207a:	20 a4       	sub	r4,10
8000207c:	80 00       	ld.sh	r0,r0[0x0]
8000207e:	31 bc       	mov	r12,27
80002080:	80 00       	ld.sh	r0,r0[0x0]
80002082:	c2 00       	breq	800020c2 <app_payload_rx_proc+0x1e>
80002084:	80 00       	ld.sh	r0,r0[0x0]
80002086:	27 3c       	sub	r12,115
80002088:	80 00       	ld.sh	r0,r0[0x0]
8000208a:	5e f4       	retal	r4
8000208c:	00 00       	add	r0,r0
8000208e:	0a 3c       	cp.w	r12,r5

80002090 <app_payload_tx_proc>:

}


static void app_payload_tx_proc(void  * payload)
{
80002090:	d4 01       	pushm	lr
  log("R");
80002092:	48 3c       	lddpc	r12,8000209c <app_payload_tx_proc+0xc>
80002094:	f0 1f 00 03 	mcall	800020a0 <app_payload_tx_proc+0x10>
  //
  //
  //set_payload_idle(payload);


}
80002098:	d8 02       	popm	pc
8000209a:	00 00       	add	r0,r0
8000209c:	80 00       	ld.sh	r0,r0[0x0]
8000209e:	c2 08       	rjmp	800020de <FD_brdcst_func+0x6>
800020a0:	80 00       	ld.sh	r0,r0[0x0]
800020a2:	62 b8       	ld.w	r8,r1[0x2c]

800020a4 <app_payload_rx_proc>:
}



static void app_payload_rx_proc(void  * payload)
{
800020a4:	d4 01       	pushm	lr
	static  U8 times_counter = 0;
	
	times_counter++;
800020a6:	48 99       	lddpc	r9,800020c8 <app_payload_rx_proc+0x24>
800020a8:	13 88       	ld.ub	r8,r9[0x0]
800020aa:	2f f8       	sub	r8,-1
800020ac:	b2 88       	st.b	r9[0x0],r8
	if (times_counter == 3)
800020ae:	30 39       	mov	r9,3
800020b0:	f2 08 18 00 	cp.b	r8,r9
800020b4:	c0 71       	brne	800020c2 <app_payload_rx_proc+0x1e>
	{
		times_counter = 0 ;
800020b6:	30 09       	mov	r9,0
800020b8:	48 48       	lddpc	r8,800020c8 <app_payload_rx_proc+0x24>
800020ba:	b0 89       	st.b	r8[0x0],r9
		log("\n\r w: \n\r");
800020bc:	48 4c       	lddpc	r12,800020cc <app_payload_rx_proc+0x28>
800020be:	f0 1f 00 05 	mcall	800020d0 <app_payload_rx_proc+0x2c>
	}
	//log("\n\r w: \n\r");
	if (AMBE_tx_flag)//本地发送方的mic录音
800020c2:	48 58       	lddpc	r8,800020d4 <app_payload_rx_proc+0x30>
800020c4:	11 88       	ld.ub	r8,r8[0x0]
	}
	
	//payload_fragment_t * ptr = (payload_fragment_t *)payload;
	//set_payload_idle(payload);

}
800020c6:	d8 02       	popm	pc
800020c8:	00 00       	add	r0,r0
800020ca:	0a 2c       	rsub	r12,r5
800020cc:	80 00       	ld.sh	r0,r0[0x0]
800020ce:	c2 0c       	rcall	8000210e <FD_request_func+0xe>
800020d0:	80 00       	ld.sh	r0,r0[0x0]
800020d2:	62 b8       	ld.w	r8,r1[0x2c]
800020d4:	00 00       	add	r0,r0
800020d6:	0a 29       	rsub	r9,r5

800020d8 <FD_brdcst_func>:
	
	
}

void FD_brdcst_func(xcmp_fragment_t * xcmp)
{
800020d8:	d4 01       	pushm	lr
	
	
	log("\n\r Forward Data Broadcast \n\r");
800020da:	48 3c       	lddpc	r12,800020e4 <FD_brdcst_func+0xc>
800020dc:	f0 1f 00 03 	mcall	800020e8 <FD_brdcst_func+0x10>
	
}
800020e0:	d8 02       	popm	pc
800020e2:	00 00       	add	r0,r0
800020e4:	80 00       	ld.sh	r0,r0[0x0]
800020e6:	c2 18       	rjmp	80002128 <EnOB_reply_func>
800020e8:	80 00       	ld.sh	r0,r0[0x0]
800020ea:	62 b8       	ld.w	r8,r1[0x2c]

800020ec <FD_reply_func>:
	
	
}

void FD_reply_func(xcmp_fragment_t * xcmp)
{
800020ec:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Reply \n\r");
800020ee:	48 3c       	lddpc	r12,800020f8 <FD_reply_func+0xc>
800020f0:	f0 1f 00 03 	mcall	800020fc <FD_reply_func+0x10>
	
	
}
800020f4:	d8 02       	popm	pc
800020f6:	00 00       	add	r0,r0
800020f8:	80 00       	ld.sh	r0,r0[0x0]
800020fa:	c2 38       	rjmp	80002140 <EnOB_reply_func+0x18>
800020fc:	80 00       	ld.sh	r0,r0[0x0]
800020fe:	62 b8       	ld.w	r8,r1[0x2c]

80002100 <FD_request_func>:
}



void FD_request_func(xcmp_fragment_t * xcmp)
{
80002100:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Request \n\r");
80002102:	48 3c       	lddpc	r12,8000210c <FD_request_func+0xc>
80002104:	f0 1f 00 03 	mcall	80002110 <FD_request_func+0x10>
	
	
}
80002108:	d8 02       	popm	pc
8000210a:	00 00       	add	r0,r0
8000210c:	80 00       	ld.sh	r0,r0[0x0]
8000210e:	c2 54       	brge	80002158 <EnOB_reply_func+0x30>
80002110:	80 00       	ld.sh	r0,r0[0x0]
80002112:	62 b8       	ld.w	r8,r1[0x2c]

80002114 <EnOB_brdcst_func>:
	
	
}

void EnOB_brdcst_func(xcmp_fragment_t * xcmp)
{
80002114:	d4 01       	pushm	lr
	
	
	log("\n\r En_OB Broadcast \n\r");
80002116:	48 3c       	lddpc	r12,80002120 <EnOB_brdcst_func+0xc>
80002118:	f0 1f 00 03 	mcall	80002124 <EnOB_brdcst_func+0x10>
}
8000211c:	d8 02       	popm	pc
8000211e:	00 00       	add	r0,r0
80002120:	80 00       	ld.sh	r0,r0[0x0]
80002122:	c2 70       	breq	80002170 <EnOB_reply_func+0x48>
80002124:	80 00       	ld.sh	r0,r0[0x0]
80002126:	62 b8       	ld.w	r8,r1[0x2c]

80002128 <EnOB_reply_func>:
}



void EnOB_reply_func(xcmp_fragment_t * xcmp)
{
80002128:	eb cd 40 80 	pushm	r7,lr
8000212c:	18 97       	mov	r7,r12
		/*point to xcmp payload*/
	//En_OB_Control_reply_t *ptr = (En_OB_Control_reply_t* )xcmp->u8;
	//log("\n\r Xcmp_opcode: %x \n\r", xcmp->xcmp_opcode);
	
	if (xcmp->u8[0]== xcmp_Res_Success)
8000212e:	19 a9       	ld.ub	r9,r12[0x2]
80002130:	30 08       	mov	r8,0
80002132:	f0 09 18 00 	cp.b	r9,r8
80002136:	c1 91       	brne	80002168 <EnOB_reply_func+0x40>
	{
		if (xcmp->u8[1] == EN_OB_Enter)
80002138:	19 b8       	ld.ub	r8,r12[0x3]
8000213a:	30 19       	mov	r9,1
8000213c:	f2 08 18 00 	cp.b	r8,r9
80002140:	c0 61       	brne	8000214c <EnOB_reply_func+0x24>
		{
		
			log("\n\r En_OB_Enter OK \n\r");
80002142:	49 0c       	lddpc	r12,80002180 <EnOB_reply_func+0x58>
80002144:	f0 1f 00 10 	mcall	80002184 <EnOB_reply_func+0x5c>
80002148:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else if (xcmp->u8[1] == EN_OB_Exit )
8000214c:	58 08       	cp.w	r8,0
8000214e:	c0 61       	brne	8000215a <EnOB_reply_func+0x32>
		{
			log("\n\r En_OB_Exit OK \n\r");
80002150:	48 ec       	lddpc	r12,80002188 <EnOB_reply_func+0x60>
80002152:	f0 1f 00 0d 	mcall	80002184 <EnOB_reply_func+0x5c>
80002156:	e3 cd 80 80 	ldm	sp++,r7,pc
		}
		else
		{
			
			log("\n\r En_OB_Control: %x \n\r", xcmp->u8[1]);
8000215a:	1a d8       	st.w	--sp,r8
8000215c:	48 cc       	lddpc	r12,8000218c <EnOB_reply_func+0x64>
8000215e:	f0 1f 00 0a 	mcall	80002184 <EnOB_reply_func+0x5c>
80002162:	2f fd       	sub	sp,-4
80002164:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r En_OB_Control error \n\r");
80002168:	48 ac       	lddpc	r12,80002190 <EnOB_reply_func+0x68>
8000216a:	f0 1f 00 07 	mcall	80002184 <EnOB_reply_func+0x5c>
		log("\n\r En_OB_result: %x \n\r", xcmp->u8[0]);
8000216e:	0f a8       	ld.ub	r8,r7[0x2]
80002170:	1a d8       	st.w	--sp,r8
80002172:	48 9c       	lddpc	r12,80002194 <EnOB_reply_func+0x6c>
80002174:	f0 1f 00 04 	mcall	80002184 <EnOB_reply_func+0x5c>
80002178:	2f fd       	sub	sp,-4
8000217a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000217e:	00 00       	add	r0,r0
80002180:	80 00       	ld.sh	r0,r0[0x0]
80002182:	c2 88       	rjmp	800021d2 <SingleDetection_brdcst_func+0x3a>
80002184:	80 00       	ld.sh	r0,r0[0x0]
80002186:	62 b8       	ld.w	r8,r1[0x2c]
80002188:	80 00       	ld.sh	r0,r0[0x0]
8000218a:	c2 a0       	breq	800021de <SingleDetection_brdcst_func+0x46>
8000218c:	80 00       	ld.sh	r0,r0[0x0]
8000218e:	c2 b4       	brge	800021e4 <ButtonConfig_brdcst_func>
80002190:	80 00       	ld.sh	r0,r0[0x0]
80002192:	c2 cc       	rcall	800021ea <ButtonConfig_brdcst_func+0x6>
80002194:	80 00       	ld.sh	r0,r0[0x0]
80002196:	c2 e8       	rjmp	800021f2 <ButtonConfig_brdcst_func+0xe>

80002198 <SingleDetection_brdcst_func>:
	
}


void SingleDetection_brdcst_func(xcmp_fragment_t * xcmp)
{
80002198:	eb cd 40 80 	pushm	r7,lr
8000219c:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == 0x11)
8000219e:	19 a9       	ld.ub	r9,r12[0x2]
800021a0:	31 18       	mov	r8,17
800021a2:	f0 09 18 00 	cp.b	r9,r8
800021a6:	c0 91       	brne	800021b8 <SingleDetection_brdcst_func+0x20>
	{
		log("\n\r DMR_CSBK OK \n\r");
800021a8:	48 ac       	lddpc	r12,800021d0 <SingleDetection_brdcst_func+0x38>
800021aa:	f0 1f 00 0b 	mcall	800021d4 <SingleDetection_brdcst_func+0x3c>
		get_time_okay = TRUE;
800021ae:	30 19       	mov	r9,1
800021b0:	48 a8       	lddpc	r8,800021d8 <SingleDetection_brdcst_func+0x40>
800021b2:	b0 89       	st.b	r8[0x0],r9
800021b4:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	//if(xcmp->u8[1] == 0x11)
	else
	{
		log("SIGBRCST error\n");
800021b8:	48 9c       	lddpc	r12,800021dc <SingleDetection_brdcst_func+0x44>
800021ba:	f0 1f 00 07 	mcall	800021d4 <SingleDetection_brdcst_func+0x3c>
		log("\Signal_type: %X \n\r", xcmp->u8[0] );
800021be:	0f a8       	ld.ub	r8,r7[0x2]
800021c0:	1a d8       	st.w	--sp,r8
800021c2:	48 8c       	lddpc	r12,800021e0 <SingleDetection_brdcst_func+0x48>
800021c4:	f0 1f 00 04 	mcall	800021d4 <SingleDetection_brdcst_func+0x3c>
800021c8:	2f fd       	sub	sp,-4
800021ca:	e3 cd 80 80 	ldm	sp++,r7,pc
800021ce:	00 00       	add	r0,r0
800021d0:	80 00       	ld.sh	r0,r0[0x0]
800021d2:	c3 00       	breq	80002232 <ButtonConfig_brdcst_func+0x4e>
800021d4:	80 00       	ld.sh	r0,r0[0x0]
800021d6:	62 b8       	ld.w	r8,r1[0x2c]
800021d8:	00 00       	add	r0,r0
800021da:	00 04       	add	r4,r0
800021dc:	80 00       	ld.sh	r0,r0[0x0]
800021de:	c3 14       	brge	80002240 <ButtonConfig_brdcst_func+0x5c>
800021e0:	80 00       	ld.sh	r0,r0[0x0]
800021e2:	c3 24       	brge	80002246 <ButtonConfig_brdcst_func+0x62>

800021e4 <ButtonConfig_brdcst_func>:
	
}


void ButtonConfig_brdcst_func(xcmp_fragment_t * xcmp)
{
800021e4:	d4 31       	pushm	r0-r7,lr
	U8 Num_Button =0;
	U8 i = 0 ;
	/*point to xcmp payload*/
	ButtonConfig_brdcst_t  *ptr = (ButtonConfig_brdcst_t* )xcmp->u8;
800021e6:	f8 c7 ff fe 	sub	r7,r12,-2
	
	Num_Button = ptr->NumOfButtons;
800021ea:	0f 95       	ld.ub	r5,r7[0x1]
	
	log("\n\r ButtonConfig_broadcast  \n\r"  );
800021ec:	4a bc       	lddpc	r12,80002298 <ButtonConfig_brdcst_func+0xb4>
800021ee:	f0 1f 00 2c 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r Function: %X \n\r" , ptr->Function );
800021f2:	0f 88       	ld.ub	r8,r7[0x0]
800021f4:	1a d8       	st.w	--sp,r8
800021f6:	4a bc       	lddpc	r12,800022a0 <ButtonConfig_brdcst_func+0xbc>
800021f8:	f0 1f 00 29 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
800021fc:	1a d5       	st.w	--sp,r5
800021fe:	4a ac       	lddpc	r12,800022a4 <ButtonConfig_brdcst_func+0xc0>
80002200:	f0 1f 00 27 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
80002204:	0f a8       	ld.ub	r8,r7[0x2]
80002206:	1a d8       	st.w	--sp,r8
80002208:	4a 8c       	lddpc	r12,800022a8 <ButtonConfig_brdcst_func+0xc4>
8000220a:	f0 1f 00 25 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
	
	for (i; i<Num_Button; i++)
8000220e:	2f dd       	sub	sp,-12
80002210:	58 05       	cp.w	r5,0
80002212:	c4 10       	breq	80002294 <ButtonConfig_brdcst_func+0xb0>
80002214:	30 06       	mov	r6,0
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
80002216:	4a 64       	lddpc	r4,800022ac <ButtonConfig_brdcst_func+0xc8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
80002218:	4a 63       	lddpc	r3,800022b0 <ButtonConfig_brdcst_func+0xcc>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
8000221a:	4a 72       	lddpc	r2,800022b4 <ButtonConfig_brdcst_func+0xd0>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
8000221c:	4a 71       	lddpc	r1,800022b8 <ButtonConfig_brdcst_func+0xd4>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
8000221e:	4a 80       	lddpc	r0,800022bc <ButtonConfig_brdcst_func+0xd8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
80002220:	0f b9       	ld.ub	r9,r7[0x3]
80002222:	0f c8       	ld.ub	r8,r7[0x4]
80002224:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002228:	1a d8       	st.w	--sp,r8
8000222a:	1a d6       	st.w	--sp,r6
8000222c:	08 9c       	mov	r12,r4
8000222e:	f0 1f 00 1c 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
80002232:	0f d9       	ld.ub	r9,r7[0x5]
80002234:	0f e8       	ld.ub	r8,r7[0x6]
80002236:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000223a:	1a d8       	st.w	--sp,r8
8000223c:	1a d6       	st.w	--sp,r6
8000223e:	06 9c       	mov	r12,r3
80002240:	f0 1f 00 17 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
80002244:	0f f9       	ld.ub	r9,r7[0x7]
80002246:	ef 38 00 08 	ld.ub	r8,r7[8]
8000224a:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000224e:	1a d8       	st.w	--sp,r8
80002250:	1a d6       	st.w	--sp,r6
80002252:	04 9c       	mov	r12,r2
80002254:	f0 1f 00 12 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
80002258:	ef 39 00 09 	ld.ub	r9,r7[9]
8000225c:	ef 38 00 0a 	ld.ub	r8,r7[10]
80002260:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002264:	1a d8       	st.w	--sp,r8
80002266:	1a d6       	st.w	--sp,r6
80002268:	02 9c       	mov	r12,r1
8000226a:	f0 1f 00 0d 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
8000226e:	2f 8d       	sub	sp,-32
80002270:	ef 39 00 0b 	ld.ub	r9,r7[11]
80002274:	ef 38 00 0c 	ld.ub	r8,r7[12]
80002278:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000227c:	1a d8       	st.w	--sp,r8
8000227e:	1a d6       	st.w	--sp,r6
80002280:	00 9c       	mov	r12,r0
80002282:	f0 1f 00 07 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
80002286:	2f f6       	sub	r6,-1
80002288:	2f 67       	sub	r7,-10
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
8000228a:	2f ed       	sub	sp,-8
8000228c:	ec 05 18 00 	cp.b	r5,r6
80002290:	fe 9b ff c8 	brhi	80002220 <ButtonConfig_brdcst_func+0x3c>
80002294:	d8 32       	popm	r0-r7,pc
80002296:	00 00       	add	r0,r0
80002298:	80 00       	ld.sh	r0,r0[0x0]
8000229a:	c3 38       	rjmp	80002300 <ButtonConfig_reply_func+0x40>
8000229c:	80 00       	ld.sh	r0,r0[0x0]
8000229e:	62 b8       	ld.w	r8,r1[0x2c]
800022a0:	80 00       	ld.sh	r0,r0[0x0]
800022a2:	c3 58       	rjmp	8000230c <DataSession_reply_func+0x8>
800022a4:	80 00       	ld.sh	r0,r0[0x0]
800022a6:	c3 6c       	rcall	80002312 <DataSession_reply_func+0xe>
800022a8:	80 00       	ld.sh	r0,r0[0x0]
800022aa:	c3 84       	brge	8000231a <DataSession_reply_func+0x16>
800022ac:	80 00       	ld.sh	r0,r0[0x0]
800022ae:	c3 a4       	brge	80002322 <DataSession_reply_func+0x1e>
800022b0:	80 00       	ld.sh	r0,r0[0x0]
800022b2:	c3 cc       	rcall	8000232a <DataSession_reply_func+0x26>
800022b4:	80 00       	ld.sh	r0,r0[0x0]
800022b6:	c3 f4       	brge	80002334 <DataSession_reply_func+0x30>
800022b8:	80 00       	ld.sh	r0,r0[0x0]
800022ba:	c4 18       	rjmp	8000233c <DataSession_reply_func+0x38>
800022bc:	80 00       	ld.sh	r0,r0[0x0]
800022be:	c4 40       	breq	80002346 <DataSession_reply_func+0x42>

800022c0 <ButtonConfig_reply_func>:
	}
	
}

void ButtonConfig_reply_func(xcmp_fragment_t * xcmp)
{
800022c0:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	ButtonConfig_reply_t *ptr = (ButtonConfig_reply_t* )(xcmp->u8);
800022c4:	f8 c7 ff fe 	sub	r7,r12,-2
	if (ptr->Result == xcmp_Res_Success)
800022c8:	0f 89       	ld.ub	r9,r7[0x0]
800022ca:	30 08       	mov	r8,0
800022cc:	f0 09 18 00 	cp.b	r9,r8
800022d0:	c0 c1       	brne	800022e8 <ButtonConfig_reply_func+0x28>
	{
		log("\n\r Button_Config OK \n\r");
800022d2:	48 9c       	lddpc	r12,800022f4 <ButtonConfig_reply_func+0x34>
800022d4:	f0 1f 00 09 	mcall	800022f8 <ButtonConfig_reply_func+0x38>
		
		log("\n\r Function: %X \n\r" , ptr->Function );
800022d8:	0f 98       	ld.ub	r8,r7[0x1]
800022da:	1a d8       	st.w	--sp,r8
800022dc:	48 8c       	lddpc	r12,800022fc <ButtonConfig_reply_func+0x3c>
800022de:	f0 1f 00 07 	mcall	800022f8 <ButtonConfig_reply_func+0x38>
800022e2:	2f fd       	sub	sp,-4
800022e4:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r Button_Request error \n\r");
800022e8:	48 6c       	lddpc	r12,80002300 <ButtonConfig_reply_func+0x40>
800022ea:	f0 1f 00 04 	mcall	800022f8 <ButtonConfig_reply_func+0x38>
800022ee:	e3 cd 80 80 	ldm	sp++,r7,pc
800022f2:	00 00       	add	r0,r0
800022f4:	80 00       	ld.sh	r0,r0[0x0]
800022f6:	c4 64       	brge	80002382 <CallControl_brdcst_func+0x2>
800022f8:	80 00       	ld.sh	r0,r0[0x0]
800022fa:	62 b8       	ld.w	r8,r1[0x2c]
800022fc:	80 00       	ld.sh	r0,r0[0x0]
800022fe:	c3 58       	rjmp	80002368 <DataSession_reply_func+0x64>
80002300:	80 00       	ld.sh	r0,r0[0x0]
80002302:	c4 7c       	rcall	80002390 <CallControl_brdcst_func+0x10>

80002304 <DataSession_reply_func>:
	
	
}

void DataSession_reply_func(xcmp_fragment_t * xcmp)
{
80002304:	eb cd 40 80 	pushm	r7,lr
80002308:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
8000230a:	19 a9       	ld.ub	r9,r12[0x2]
8000230c:	30 08       	mov	r8,0
8000230e:	f0 09 18 00 	cp.b	r9,r8
80002312:	c1 11       	brne	80002334 <DataSession_reply_func+0x30>
	{
		log("DATArep OK \n");
80002314:	49 3c       	lddpc	r12,80002360 <DataSession_reply_func+0x5c>
80002316:	f0 1f 00 14 	mcall	80002364 <DataSession_reply_func+0x60>
		log("Func: %X \n", xcmp->u8[1]);
8000231a:	0f b8       	ld.ub	r8,r7[0x3]
8000231c:	1a d8       	st.w	--sp,r8
8000231e:	49 3c       	lddpc	r12,80002368 <DataSession_reply_func+0x64>
80002320:	f0 1f 00 11 	mcall	80002364 <DataSession_reply_func+0x60>
		log("ID: %X \n", xcmp->u8[2]);
80002324:	0f c8       	ld.ub	r8,r7[0x4]
80002326:	1a d8       	st.w	--sp,r8
80002328:	49 1c       	lddpc	r12,8000236c <DataSession_reply_func+0x68>
8000232a:	f0 1f 00 0f 	mcall	80002364 <DataSession_reply_func+0x60>
8000232e:	2f ed       	sub	sp,-8
80002330:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	else
	{	
		log("DATArep error \n");
80002334:	48 fc       	lddpc	r12,80002370 <DataSession_reply_func+0x6c>
80002336:	f0 1f 00 0c 	mcall	80002364 <DataSession_reply_func+0x60>
		log("Result:  %X \n", xcmp->u8[0]);
8000233a:	0f a8       	ld.ub	r8,r7[0x2]
8000233c:	1a d8       	st.w	--sp,r8
8000233e:	48 ec       	lddpc	r12,80002374 <DataSession_reply_func+0x70>
80002340:	f0 1f 00 09 	mcall	80002364 <DataSession_reply_func+0x60>
		log("Func:  %X \n", xcmp->u8[1]);
80002344:	0f b8       	ld.ub	r8,r7[0x3]
80002346:	1a d8       	st.w	--sp,r8
80002348:	48 cc       	lddpc	r12,80002378 <DataSession_reply_func+0x74>
8000234a:	f0 1f 00 07 	mcall	80002364 <DataSession_reply_func+0x60>
		log("ID:  %X \n", xcmp->u8[2]);
8000234e:	0f c8       	ld.ub	r8,r7[0x4]
80002350:	1a d8       	st.w	--sp,r8
80002352:	48 bc       	lddpc	r12,8000237c <DataSession_reply_func+0x78>
80002354:	f0 1f 00 04 	mcall	80002364 <DataSession_reply_func+0x60>
80002358:	2f dd       	sub	sp,-12
8000235a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000235e:	00 00       	add	r0,r0
80002360:	80 00       	ld.sh	r0,r0[0x0]
80002362:	c4 98       	rjmp	800023f4 <TransmitControl_brdcst_func+0x30>
80002364:	80 00       	ld.sh	r0,r0[0x0]
80002366:	62 b8       	ld.w	r8,r1[0x2c]
80002368:	80 00       	ld.sh	r0,r0[0x0]
8000236a:	c4 a8       	rjmp	800023fe <TransmitControl_brdcst_func+0x3a>
8000236c:	80 00       	ld.sh	r0,r0[0x0]
8000236e:	c4 b4       	brge	80002404 <TransmitControl_brdcst_func+0x40>
80002370:	80 00       	ld.sh	r0,r0[0x0]
80002372:	c4 c0       	breq	8000240a <TransmitControl_brdcst_func+0x46>
80002374:	80 00       	ld.sh	r0,r0[0x0]
80002376:	c4 d0       	breq	80002410 <TransmitControl_reply_func+0x4>
80002378:	80 00       	ld.sh	r0,r0[0x0]
8000237a:	c4 e0       	breq	80002416 <TransmitControl_reply_func+0xa>
8000237c:	80 00       	ld.sh	r0,r0[0x0]
8000237e:	c4 ec       	rcall	8000241a <TransmitControl_reply_func+0xe>

80002380 <CallControl_brdcst_func>:
	
}


void CallControl_brdcst_func(xcmp_fragment_t * xcmp)
{
80002380:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	CallControl_brdcst_t *ptr = (CallControl_brdcst_t* )xcmp->u8;
80002384:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  CallControl brst \n\r ");
	//log("\n\r  Call_type: %x \n\r ", ptr->Calltype );
	log("\n\r  Call_state: %x \n\r ", ptr->Callstate );
80002388:	0f 98       	ld.ub	r8,r7[0x1]
8000238a:	1a d8       	st.w	--sp,r8
8000238c:	48 bc       	lddpc	r12,800023b8 <CallControl_brdcst_func+0x38>
8000238e:	f0 1f 00 0c 	mcall	800023bc <CallControl_brdcst_func+0x3c>
	if (ptr->Callstate == Call_Ended)//0x03
80002392:	2f fd       	sub	sp,-4
80002394:	0f 99       	ld.ub	r9,r7[0x1]
80002396:	30 38       	mov	r8,3
80002398:	f0 09 18 00 	cp.b	r9,r8
8000239c:	c0 41       	brne	800023a4 <CallControl_brdcst_func+0x24>
	{
		//恢复正常语音路径通道
		//xcmp_audio_route_revert();
		Call_Begin = 0;
8000239e:	30 09       	mov	r9,0
800023a0:	48 88       	lddpc	r8,800023c0 <CallControl_brdcst_func+0x40>
800023a2:	b0 89       	st.b	r8[0x0],r9
		
	}
	
	if (ptr->Callstate == Call_Initiated)//0x04
800023a4:	0f 99       	ld.ub	r9,r7[0x1]
800023a6:	30 48       	mov	r8,4
800023a8:	f0 09 18 00 	cp.b	r9,r8
800023ac:	c0 41       	brne	800023b4 <CallControl_brdcst_func+0x34>
	{
		Call_Begin = 1;
800023ae:	30 19       	mov	r9,1
800023b0:	48 48       	lddpc	r8,800023c0 <CallControl_brdcst_func+0x40>
800023b2:	b0 89       	st.b	r8[0x0],r9
800023b4:	e3 cd 80 80 	ldm	sp++,r7,pc
800023b8:	80 00       	ld.sh	r0,r0[0x0]
800023ba:	c4 f8       	rjmp	80002458 <TransmitControl_reply_func+0x4c>
800023bc:	80 00       	ld.sh	r0,r0[0x0]
800023be:	62 b8       	ld.w	r8,r1[0x2c]
800023c0:	00 00       	add	r0,r0
800023c2:	0a 2b       	rsub	r11,r5

800023c4 <TransmitControl_brdcst_func>:

}


void TransmitControl_brdcst_func(xcmp_fragment_t * xcmp)
{
800023c4:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	TransmitControl_brdcast_t *ptr = (TransmitControl_brdcast_t* )xcmp->u8;
800023c8:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  TransmitControl broadcast \n\r ");
	//log("\n\r  Mode_Of_Operation: %x \n\r ", ptr->Mode_Of_Operation );
	if (ptr->State == 0x00)
800023cc:	0f 99       	ld.ub	r9,r7[0x1]
800023ce:	30 08       	mov	r8,0
800023d0:	f0 09 18 00 	cp.b	r9,r8
800023d4:	c0 71       	brne	800023e2 <TransmitControl_brdcst_func+0x1e>
	{
		log("\n\r  Standby-Receive \n\r ");
800023d6:	48 ac       	lddpc	r12,800023fc <TransmitControl_brdcst_func+0x38>
800023d8:	f0 1f 00 0a 	mcall	80002400 <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 0;
800023dc:	30 09       	mov	r9,0
800023de:	48 a8       	lddpc	r8,80002404 <TransmitControl_brdcst_func+0x40>
800023e0:	b0 89       	st.b	r8[0x0],r9
	}
	if (ptr->State == 0x01)
800023e2:	0f 99       	ld.ub	r9,r7[0x1]
800023e4:	30 18       	mov	r8,1
800023e6:	f0 09 18 00 	cp.b	r9,r8
800023ea:	c0 71       	brne	800023f8 <TransmitControl_brdcst_func+0x34>
	{
		log("\n\r  Transmit \n\r ");
800023ec:	48 7c       	lddpc	r12,80002408 <TransmitControl_brdcst_func+0x44>
800023ee:	f0 1f 00 05 	mcall	80002400 <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 1;
800023f2:	30 19       	mov	r9,1
800023f4:	48 48       	lddpc	r8,80002404 <TransmitControl_brdcst_func+0x40>
800023f6:	b0 89       	st.b	r8[0x0],r9
800023f8:	e3 cd 80 80 	ldm	sp++,r7,pc
800023fc:	80 00       	ld.sh	r0,r0[0x0]
800023fe:	c5 10       	breq	800024a0 <Volume_reply_func+0xc>
80002400:	80 00       	ld.sh	r0,r0[0x0]
80002402:	62 b8       	ld.w	r8,r1[0x2c]
80002404:	00 00       	add	r0,r0
80002406:	0a 2a       	rsub	r10,r5
80002408:	80 00       	ld.sh	r0,r0[0x0]
8000240a:	c5 28       	rjmp	800024ae <Volume_reply_func+0x1a>

8000240c <TransmitControl_reply_func>:




void TransmitControl_reply_func(xcmp_fragment_t * xcmp)
{
8000240c:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	TransmitControl_reply_t *ptr = (TransmitControl_reply_t* )xcmp->u8;
80002410:	f8 c7 ff fe 	sub	r7,r12,-2
	
	if (ptr->Result == xcmp_Res_Success)
80002414:	0f 89       	ld.ub	r9,r7[0x0]
80002416:	30 08       	mov	r8,0
80002418:	f0 09 18 00 	cp.b	r9,r8
8000241c:	c1 61       	brne	80002448 <TransmitControl_reply_func+0x3c>
	{
		
		log("\n\r  TransmitControl OK \n\r ");
8000241e:	48 ec       	lddpc	r12,80002454 <TransmitControl_reply_func+0x48>
80002420:	f0 1f 00 0e 	mcall	80002458 <TransmitControl_reply_func+0x4c>
		log("\n\r Function: %x \n\r", ptr->Function);
80002424:	0f 98       	ld.ub	r8,r7[0x1]
80002426:	1a d8       	st.w	--sp,r8
80002428:	48 dc       	lddpc	r12,8000245c <TransmitControl_reply_func+0x50>
8000242a:	f0 1f 00 0c 	mcall	80002458 <TransmitControl_reply_func+0x4c>
		log("\n\r Mode of Operation: %x \n\r", ptr->Mode_Of_Operation);
8000242e:	0f a8       	ld.ub	r8,r7[0x2]
80002430:	1a d8       	st.w	--sp,r8
80002432:	48 cc       	lddpc	r12,80002460 <TransmitControl_reply_func+0x54>
80002434:	f0 1f 00 09 	mcall	80002458 <TransmitControl_reply_func+0x4c>
		log("\n\r State: %x \n\r", ptr->State);
80002438:	0f b8       	ld.ub	r8,r7[0x3]
8000243a:	1a d8       	st.w	--sp,r8
8000243c:	48 ac       	lddpc	r12,80002464 <TransmitControl_reply_func+0x58>
8000243e:	f0 1f 00 07 	mcall	80002458 <TransmitControl_reply_func+0x4c>
80002442:	2f dd       	sub	sp,-12
80002444:	e3 cd 80 80 	ldm	sp++,r7,pc
		
		//Silent_flag = 1;
	}
	else
	{
		log("TransmitControl error");
80002448:	48 8c       	lddpc	r12,80002468 <TransmitControl_reply_func+0x5c>
8000244a:	f0 1f 00 04 	mcall	80002458 <TransmitControl_reply_func+0x4c>
8000244e:	e3 cd 80 80 	ldm	sp++,r7,pc
80002452:	00 00       	add	r0,r0
80002454:	80 00       	ld.sh	r0,r0[0x0]
80002456:	c5 3c       	rcall	800024fc <spk_brdcst_func+0x4>
80002458:	80 00       	ld.sh	r0,r0[0x0]
8000245a:	62 b8       	ld.w	r8,r1[0x2c]
8000245c:	80 00       	ld.sh	r0,r0[0x0]
8000245e:	c5 58       	rjmp	80002508 <spk_brdcst_func+0x10>
80002460:	80 00       	ld.sh	r0,r0[0x0]
80002462:	c5 6c       	rcall	8000250e <spk_brdcst_func+0x16>
80002464:	80 00       	ld.sh	r0,r0[0x0]
80002466:	c5 88       	rjmp	80002516 <spk_brdcst_func+0x1e>
80002468:	80 00       	ld.sh	r0,r0[0x0]
8000246a:	c5 98       	rjmp	8000251c <spk_brdcst_func+0x24>

8000246c <AudioRoutingControl_reply_func>:
	
}


void AudioRoutingControl_reply_func(xcmp_fragment_t * xcmp)
{
8000246c:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
8000246e:	19 a9       	ld.ub	r9,r12[0x2]
80002470:	30 08       	mov	r8,0
80002472:	f0 09 18 00 	cp.b	r9,r8
80002476:	c0 51       	brne	80002480 <AudioRoutingControl_reply_func+0x14>
	{
		log("AudioRouting OK");
80002478:	48 4c       	lddpc	r12,80002488 <AudioRoutingControl_reply_func+0x1c>
8000247a:	f0 1f 00 05 	mcall	8000248c <AudioRoutingControl_reply_func+0x20>
8000247e:	d8 02       	popm	pc
		//xcmp_IdleTestTone();
		//Speaker_is_unmute = 1;
	}
	else
	{
		log("AudioRouting error");
80002480:	48 4c       	lddpc	r12,80002490 <AudioRoutingControl_reply_func+0x24>
80002482:	f0 1f 00 03 	mcall	8000248c <AudioRoutingControl_reply_func+0x20>
80002486:	d8 02       	popm	pc
80002488:	80 00       	ld.sh	r0,r0[0x0]
8000248a:	c5 b0       	breq	80002540 <spk_reply_func+0x10>
8000248c:	80 00       	ld.sh	r0,r0[0x0]
8000248e:	62 b8       	ld.w	r8,r1[0x2c]
80002490:	80 00       	ld.sh	r0,r0[0x0]
80002492:	c5 c0       	breq	8000254a <spk_reply_func+0x1a>

80002494 <Volume_reply_func>:
	
}


void Volume_reply_func(xcmp_fragment_t * xcmp)
{
80002494:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	VolumeControl_reply_t *ptr = (VolumeControl_reply_t* )xcmp->u8;
80002498:	f8 c7 ff fe 	sub	r7,r12,-2
	
		if (ptr->Result == xcmp_Res_Success)
8000249c:	0f 89       	ld.ub	r9,r7[0x0]
8000249e:	30 08       	mov	r8,0
800024a0:	f0 09 18 00 	cp.b	r9,r8
800024a4:	c1 b1       	brne	800024da <Volume_reply_func+0x46>
		{
			if (ptr->Function == Enable_IntelligentAudio)
800024a6:	0f b8       	ld.ub	r8,r7[0x3]
800024a8:	31 09       	mov	r9,16
800024aa:	f2 08 18 00 	cp.b	r8,r9
800024ae:	c0 f1       	brne	800024cc <Volume_reply_func+0x38>
			{
				log("\n\r Enable_IA OK \n\r");
800024b0:	48 dc       	lddpc	r12,800024e4 <Volume_reply_func+0x50>
800024b2:	f0 1f 00 0e 	mcall	800024e8 <Volume_reply_func+0x54>
				log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
800024b6:	0f 99       	ld.ub	r9,r7[0x1]
800024b8:	0f a8       	ld.ub	r8,r7[0x2]
800024ba:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800024be:	1a d8       	st.w	--sp,r8
800024c0:	48 bc       	lddpc	r12,800024ec <Volume_reply_func+0x58>
800024c2:	f0 1f 00 0a 	mcall	800024e8 <Volume_reply_func+0x54>
800024c6:	2f fd       	sub	sp,-4
800024c8:	e3 cd 80 80 	ldm	sp++,r7,pc
	
			}
			else
			{
				
				log("\n\r VolumeControl: %x \n\r", ptr->Function);
800024cc:	1a d8       	st.w	--sp,r8
800024ce:	48 9c       	lddpc	r12,800024f0 <Volume_reply_func+0x5c>
800024d0:	f0 1f 00 06 	mcall	800024e8 <Volume_reply_func+0x54>
800024d4:	2f fd       	sub	sp,-4
800024d6:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		
		else
		{
			log("\n\r Enable_IA error \n\r");
800024da:	48 7c       	lddpc	r12,800024f4 <Volume_reply_func+0x60>
800024dc:	f0 1f 00 03 	mcall	800024e8 <Volume_reply_func+0x54>
800024e0:	e3 cd 80 80 	ldm	sp++,r7,pc
800024e4:	80 00       	ld.sh	r0,r0[0x0]
800024e6:	c5 d4       	brge	800025a0 <mic_brdcst_func+0x28>
800024e8:	80 00       	ld.sh	r0,r0[0x0]
800024ea:	62 b8       	ld.w	r8,r1[0x2c]
800024ec:	80 00       	ld.sh	r0,r0[0x0]
800024ee:	c5 e8       	rjmp	800025aa <mic_brdcst_func+0x32>
800024f0:	80 00       	ld.sh	r0,r0[0x0]
800024f2:	c6 04       	brge	800025b2 <mic_brdcst_func+0x3a>
800024f4:	80 00       	ld.sh	r0,r0[0x0]
800024f6:	c6 1c       	rcall	800025b8 <mic_brdcst_func+0x40>

800024f8 <spk_brdcst_func>:
		log("spk error");
	}
}

void spk_brdcst_func(xcmp_fragment_t * xcmp)
{
800024f8:	d4 01       	pushm	lr
	if (xcmp->u8[3] == xcmp_Res_Success)//0x0000:mute
800024fa:	19 d9       	ld.ub	r9,r12[0x5]
800024fc:	30 08       	mov	r8,0
800024fe:	f0 09 18 00 	cp.b	r9,r8
80002502:	c0 81       	brne	80002512 <spk_brdcst_func+0x1a>
	{
		Speaker_is_unmute =0;
80002504:	10 99       	mov	r9,r8
80002506:	48 78       	lddpc	r8,80002520 <spk_brdcst_func+0x28>
80002508:	b0 89       	st.b	r8[0x0],r9
		//Silent_flag = 0;
		log("spk_s_close ");
8000250a:	48 7c       	lddpc	r12,80002524 <spk_brdcst_func+0x2c>
8000250c:	f0 1f 00 07 	mcall	80002528 <spk_brdcst_func+0x30>
80002510:	d8 02       	popm	pc
		
	}
	else
	{
		//Silent_flag = 1;
		Speaker_is_unmute = 1;
80002512:	30 19       	mov	r9,1
80002514:	48 38       	lddpc	r8,80002520 <spk_brdcst_func+0x28>
80002516:	b0 89       	st.b	r8[0x0],r9
		log("spk_s_open ");	
80002518:	48 5c       	lddpc	r12,8000252c <spk_brdcst_func+0x34>
8000251a:	f0 1f 00 04 	mcall	80002528 <spk_brdcst_func+0x30>
8000251e:	d8 02       	popm	pc
80002520:	00 00       	add	r0,r0
80002522:	0a 28       	rsub	r8,r5
80002524:	80 00       	ld.sh	r0,r0[0x0]
80002526:	c6 34       	brge	800025ec <mic_reply_func+0x1c>
80002528:	80 00       	ld.sh	r0,r0[0x0]
8000252a:	62 b8       	ld.w	r8,r1[0x2c]
8000252c:	80 00       	ld.sh	r0,r0[0x0]
8000252e:	c6 44       	brge	800025f6 <mic_reply_func+0x26>

80002530 <spk_reply_func>:
			
	
}

void spk_reply_func(xcmp_fragment_t * xcmp)
{
80002530:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
80002532:	19 a9       	ld.ub	r9,r12[0x2]
80002534:	30 08       	mov	r8,0
80002536:	f0 09 18 00 	cp.b	r9,r8
8000253a:	c0 f1       	brne	80002558 <spk_reply_func+0x28>
	{
		
		if(xcmp->u8[4])
8000253c:	19 e9       	ld.ub	r9,r12[0x6]
8000253e:	f0 09 18 00 	cp.b	r9,r8
80002542:	c0 40       	breq	8000254a <spk_reply_func+0x1a>
		{
			Speaker_is_unmute = 1;
80002544:	30 19       	mov	r9,1
80002546:	48 98       	lddpc	r8,80002568 <spk_reply_func+0x38>
80002548:	b0 89       	st.b	r8[0x0],r9
			
			//Silent_flag = 1;
		}
		log("spk OK -st%2x", xcmp->u8[4] );
8000254a:	19 e8       	ld.ub	r8,r12[0x6]
8000254c:	1a d8       	st.w	--sp,r8
8000254e:	48 8c       	lddpc	r12,8000256c <spk_reply_func+0x3c>
80002550:	f0 1f 00 08 	mcall	80002570 <spk_reply_func+0x40>
80002554:	2f fd       	sub	sp,-4
80002556:	d8 02       	popm	pc
		
	}
	else
	{
		Speaker_is_unmute = 0;
80002558:	30 09       	mov	r9,0
8000255a:	48 48       	lddpc	r8,80002568 <spk_reply_func+0x38>
8000255c:	b0 89       	st.b	r8[0x0],r9
		log("spk error");
8000255e:	48 6c       	lddpc	r12,80002574 <spk_reply_func+0x44>
80002560:	f0 1f 00 04 	mcall	80002570 <spk_reply_func+0x40>
80002564:	d8 02       	popm	pc
80002566:	00 00       	add	r0,r0
80002568:	00 00       	add	r0,r0
8000256a:	0a 28       	rsub	r8,r5
8000256c:	80 00       	ld.sh	r0,r0[0x0]
8000256e:	c6 50       	breq	80002638 <mic_reply_func+0x68>
80002570:	80 00       	ld.sh	r0,r0[0x0]
80002572:	62 b8       	ld.w	r8,r1[0x2c]
80002574:	80 00       	ld.sh	r0,r0[0x0]
80002576:	c6 60       	breq	80002642 <mic_reply_func+0x72>

80002578 <mic_brdcst_func>:
	
	
}

void mic_brdcst_func(xcmp_fragment_t * xcmp)
{
80002578:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_brdcast_t *ptr = (MicControl_brdcast_t* )xcmp->u8;
8000257c:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r Mic_brdcst \n\r");		
	//log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
	//log("\n\r Signal_type: %x \n\r " ,  ptr->Signaling_Type);
	if (ptr->Mic_State == 0x00)
80002580:	0f a9       	ld.ub	r9,r7[0x2]
80002582:	30 08       	mov	r8,0
80002584:	f0 09 18 00 	cp.b	r9,r8
80002588:	c0 71       	brne	80002596 <mic_brdcst_func+0x1e>
	{
		log("\n\r Mic_Disabled \n\r");	
8000258a:	48 dc       	lddpc	r12,800025bc <mic_brdcst_func+0x44>
8000258c:	f0 1f 00 0d 	mcall	800025c0 <mic_brdcst_func+0x48>
		Mic_is_Enabled = 0;
80002590:	30 09       	mov	r9,0
80002592:	48 d8       	lddpc	r8,800025c4 <mic_brdcst_func+0x4c>
80002594:	b0 89       	st.b	r8[0x0],r9
	} 
	if(ptr->Mic_State == 0x11)
80002596:	0f a9       	ld.ub	r9,r7[0x2]
80002598:	31 18       	mov	r8,17
8000259a:	f0 09 18 00 	cp.b	r9,r8
8000259e:	c0 d1       	brne	800025b8 <mic_brdcst_func+0x40>
	{
		log("\n\r Mic_Enabled \n\r");
800025a0:	48 ac       	lddpc	r12,800025c8 <mic_brdcst_func+0x50>
800025a2:	f0 1f 00 08 	mcall	800025c0 <mic_brdcst_func+0x48>
		Mic_is_Enabled = 1;
800025a6:	48 89       	lddpc	r9,800025c4 <mic_brdcst_func+0x4c>
800025a8:	30 18       	mov	r8,1
800025aa:	b2 88       	st.b	r9[0x0],r8
		
		if ((Mic_is_Enabled == 1) && (Call_Begin == 1))
800025ac:	13 89       	ld.ub	r9,r9[0x0]
800025ae:	f0 09 18 00 	cp.b	r9,r8
800025b2:	c0 31       	brne	800025b8 <mic_brdcst_func+0x40>
800025b4:	48 68       	lddpc	r8,800025cc <mic_brdcst_func+0x54>
800025b6:	11 88       	ld.ub	r8,r8[0x0]
800025b8:	e3 cd 80 80 	ldm	sp++,r7,pc
800025bc:	80 00       	ld.sh	r0,r0[0x0]
800025be:	c6 6c       	rcall	8000268a <dcm_brdcst_func+0x26>
800025c0:	80 00       	ld.sh	r0,r0[0x0]
800025c2:	62 b8       	ld.w	r8,r1[0x2c]
800025c4:	00 00       	add	r0,r0
800025c6:	0a 35       	cp.w	r5,r5
800025c8:	80 00       	ld.sh	r0,r0[0x0]
800025ca:	c6 80       	breq	8000269a <dcm_brdcst_func+0x36>
800025cc:	00 00       	add	r0,r0
800025ce:	0a 2b       	rsub	r11,r5

800025d0 <mic_reply_func>:
	
	
}

void mic_reply_func(xcmp_fragment_t * xcmp)
{
800025d0:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_reply_t *ptr = (MicControl_reply_t* )xcmp->u8;
800025d4:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Mic_reply \n\r");
800025d8:	49 ac       	lddpc	r12,80002640 <mic_reply_func+0x70>
800025da:	f0 1f 00 1b 	mcall	80002644 <mic_reply_func+0x74>
	if (ptr->Result == 0x00)
800025de:	0f 89       	ld.ub	r9,r7[0x0]
800025e0:	30 08       	mov	r8,0
800025e2:	f0 09 18 00 	cp.b	r9,r8
800025e6:	c2 71       	brne	80002634 <mic_reply_func+0x64>
	{
		
		if (ptr->Function == Mic_Disable)
800025e8:	0f 98       	ld.ub	r8,r7[0x1]
800025ea:	30 29       	mov	r9,2
800025ec:	f2 08 18 00 	cp.b	r8,r9
800025f0:	c1 b1       	brne	80002626 <mic_reply_func+0x56>
		{
		
			log("\n\r Mic_close_ok \n\r " );
800025f2:	49 6c       	lddpc	r12,80002648 <mic_reply_func+0x78>
800025f4:	f0 1f 00 14 	mcall	80002644 <mic_reply_func+0x74>
			log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
800025f8:	0f a8       	ld.ub	r8,r7[0x2]
800025fa:	1a d8       	st.w	--sp,r8
800025fc:	49 4c       	lddpc	r12,8000264c <mic_reply_func+0x7c>
800025fe:	f0 1f 00 12 	mcall	80002644 <mic_reply_func+0x74>
			log("\n\r Signaling_type: %x \n\r " ,  ptr->Signaling_Type);
80002602:	0f b8       	ld.ub	r8,r7[0x3]
80002604:	1a d8       	st.w	--sp,r8
80002606:	49 3c       	lddpc	r12,80002650 <mic_reply_func+0x80>
80002608:	f0 1f 00 0f 	mcall	80002644 <mic_reply_func+0x74>
			log("\n\r Mic_state: %x \n\r " ,  ptr->Mic_State);
8000260c:	0f c8       	ld.ub	r8,r7[0x4]
8000260e:	1a d8       	st.w	--sp,r8
80002610:	49 1c       	lddpc	r12,80002654 <mic_reply_func+0x84>
80002612:	f0 1f 00 0d 	mcall	80002644 <mic_reply_func+0x74>
			log("\n\r Gain_offset: %x \n\r " ,  ptr->Gain_Offset);
80002616:	0f d8       	ld.ub	r8,r7[0x5]
80002618:	1a d8       	st.w	--sp,r8
8000261a:	49 0c       	lddpc	r12,80002658 <mic_reply_func+0x88>
8000261c:	f0 1f 00 0a 	mcall	80002644 <mic_reply_func+0x74>
80002620:	2f cd       	sub	sp,-16
80002622:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else
		{
			log("\n\r Mic_function: %x \n\r ", ptr->Function );
80002626:	1a d8       	st.w	--sp,r8
80002628:	48 dc       	lddpc	r12,8000265c <mic_reply_func+0x8c>
8000262a:	f0 1f 00 07 	mcall	80002644 <mic_reply_func+0x74>
8000262e:	2f fd       	sub	sp,-4
80002630:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else 
	{
		
	
		log("\n\r Mic error \n\r");
80002634:	48 bc       	lddpc	r12,80002660 <mic_reply_func+0x90>
80002636:	f0 1f 00 04 	mcall	80002644 <mic_reply_func+0x74>
8000263a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000263e:	00 00       	add	r0,r0
80002640:	80 00       	ld.sh	r0,r0[0x0]
80002642:	c6 94       	brge	80002714 <ToneControl_reply_func>
80002644:	80 00       	ld.sh	r0,r0[0x0]
80002646:	62 b8       	ld.w	r8,r1[0x2c]
80002648:	80 00       	ld.sh	r0,r0[0x0]
8000264a:	c6 a4       	brge	8000271e <ToneControl_reply_func+0xa>
8000264c:	80 00       	ld.sh	r0,r0[0x0]
8000264e:	c6 b8       	rjmp	80002724 <ToneControl_reply_func+0x10>
80002650:	80 00       	ld.sh	r0,r0[0x0]
80002652:	c6 cc       	rcall	8000272a <ToneControl_reply_func+0x16>
80002654:	80 00       	ld.sh	r0,r0[0x0]
80002656:	c6 e8       	rjmp	80002732 <ToneControl_reply_func+0x1e>
80002658:	80 00       	ld.sh	r0,r0[0x0]
8000265a:	c7 00       	breq	8000273a <ToneControl_reply_func+0x26>
8000265c:	80 00       	ld.sh	r0,r0[0x0]
8000265e:	c7 18       	rjmp	80002740 <app_cfg+0x4>
80002660:	80 00       	ld.sh	r0,r0[0x0]
80002662:	c7 30       	breq	80002748 <app_cfg+0xc>

80002664 <dcm_brdcst_func>:
	}
}


void dcm_brdcst_func(xcmp_fragment_t * xcmp)
{
80002664:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	DeviceControlMode_brdcst_t *ptr = (DeviceControlMode_brdcst_t* )xcmp->u8;
80002668:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Dcm_brdcst \n\r");		
8000266c:	48 bc       	lddpc	r12,80002698 <dcm_brdcst_func+0x34>
8000266e:	f0 1f 00 0c 	mcall	8000269c <dcm_brdcst_func+0x38>
	log("\n\r Function: %x \n\r " ,  ptr->Function);
80002672:	0f 88       	ld.ub	r8,r7[0x0]
80002674:	1a d8       	st.w	--sp,r8
80002676:	48 bc       	lddpc	r12,800026a0 <dcm_brdcst_func+0x3c>
80002678:	f0 1f 00 09 	mcall	8000269c <dcm_brdcst_func+0x38>
	log("\n\r ControlType: %x \n\r " ,  ptr->ControlType);
8000267c:	0f a8       	ld.ub	r8,r7[0x2]
8000267e:	1a d8       	st.w	--sp,r8
80002680:	48 9c       	lddpc	r12,800026a4 <dcm_brdcst_func+0x40>
80002682:	f0 1f 00 07 	mcall	8000269c <dcm_brdcst_func+0x38>
	log("\n\r ControlTypeSize: %x \n\r " ,  ptr->ControlTypeSize);
80002686:	0f 98       	ld.ub	r8,r7[0x1]
80002688:	1a d8       	st.w	--sp,r8
8000268a:	48 8c       	lddpc	r12,800026a8 <dcm_brdcst_func+0x44>
8000268c:	f0 1f 00 04 	mcall	8000269c <dcm_brdcst_func+0x38>
80002690:	2f dd       	sub	sp,-12
	
	
}
80002692:	e3 cd 80 80 	ldm	sp++,r7,pc
80002696:	00 00       	add	r0,r0
80002698:	80 00       	ld.sh	r0,r0[0x0]
8000269a:	c7 40       	breq	80002782 <app_cfg+0x46>
8000269c:	80 00       	ld.sh	r0,r0[0x0]
8000269e:	62 b8       	ld.w	r8,r1[0x2c]
800026a0:	80 00       	ld.sh	r0,r0[0x0]
800026a2:	c7 54       	brge	8000278c <app_cfg+0x50>
800026a4:	80 00       	ld.sh	r0,r0[0x0]
800026a6:	c7 68       	rjmp	80002792 <app_cfg+0x56>
800026a8:	80 00       	ld.sh	r0,r0[0x0]
800026aa:	c7 80       	breq	8000279a <app_cfg+0x5e>

800026ac <dcm_reply_func>:
		log("Tone error");
	}
}

void dcm_reply_func(xcmp_fragment_t * xcmp)
{
800026ac:	eb cd 40 80 	pushm	r7,lr
800026b0:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
800026b2:	19 a9       	ld.ub	r9,r12[0x2]
800026b4:	30 08       	mov	r8,0
800026b6:	f0 09 18 00 	cp.b	r9,r8
800026ba:	c1 b1       	brne	800026f0 <dcm_reply_func+0x44>
	{
		if(xcmp->u8[1] == DCM_ENTER)
800026bc:	19 b8       	ld.ub	r8,r12[0x3]
800026be:	30 19       	mov	r9,1
800026c0:	f2 08 18 00 	cp.b	r8,r9
800026c4:	c0 51       	brne	800026ce <dcm_reply_func+0x22>
		{
			log("\n\r Dcm-Enter OK \n\r");
800026c6:	48 ec       	lddpc	r12,800026fc <dcm_reply_func+0x50>
800026c8:	f0 1f 00 0e 	mcall	80002700 <dcm_reply_func+0x54>
800026cc:	c0 a8       	rjmp	800026e0 <dcm_reply_func+0x34>
			
		}
		else if (xcmp->u8[1] == DCM_EXIT)
800026ce:	58 08       	cp.w	r8,0
800026d0:	c0 51       	brne	800026da <dcm_reply_func+0x2e>
		{
			log("\n\r Dcm-Exit OK \n\r");
800026d2:	48 dc       	lddpc	r12,80002704 <dcm_reply_func+0x58>
800026d4:	f0 1f 00 0b 	mcall	80002700 <dcm_reply_func+0x54>
800026d8:	c0 48       	rjmp	800026e0 <dcm_reply_func+0x34>
		}
		else
		{
			log("\n\r Dcm-Revoke \n\r");
800026da:	48 cc       	lddpc	r12,80002708 <dcm_reply_func+0x5c>
800026dc:	f0 1f 00 09 	mcall	80002700 <dcm_reply_func+0x54>
		}
		
		log("dcm OK-mo%X", xcmp->u8[3]);
800026e0:	0f d8       	ld.ub	r8,r7[0x5]
800026e2:	1a d8       	st.w	--sp,r8
800026e4:	48 ac       	lddpc	r12,8000270c <dcm_reply_func+0x60>
800026e6:	f0 1f 00 07 	mcall	80002700 <dcm_reply_func+0x54>
800026ea:	2f fd       	sub	sp,-4
800026ec:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		log("dcm error");
800026f0:	48 8c       	lddpc	r12,80002710 <dcm_reply_func+0x64>
800026f2:	f0 1f 00 04 	mcall	80002700 <dcm_reply_func+0x54>
800026f6:	e3 cd 80 80 	ldm	sp++,r7,pc
800026fa:	00 00       	add	r0,r0
800026fc:	80 00       	ld.sh	r0,r0[0x0]
800026fe:	c7 9c       	rcall	800027f0 <app_cfg+0xb4>
80002700:	80 00       	ld.sh	r0,r0[0x0]
80002702:	62 b8       	ld.w	r8,r1[0x2c]
80002704:	80 00       	ld.sh	r0,r0[0x0]
80002706:	c7 b0       	breq	800027fc <app_cfg+0xc0>
80002708:	80 00       	ld.sh	r0,r0[0x0]
8000270a:	c7 c4       	brge	80002802 <app_cfg+0xc6>
8000270c:	80 00       	ld.sh	r0,r0[0x0]
8000270e:	c7 d8       	rjmp	80002808 <app_cfg+0xcc>
80002710:	80 00       	ld.sh	r0,r0[0x0]
80002712:	c7 e4       	brge	8000280e <app_cfg+0xd2>

80002714 <ToneControl_reply_func>:
			}
		}
}

void ToneControl_reply_func(xcmp_fragment_t * xcmp)
{
80002714:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
80002716:	19 a9       	ld.ub	r9,r12[0x2]
80002718:	30 08       	mov	r8,0
8000271a:	f0 09 18 00 	cp.b	r9,r8
8000271e:	c0 51       	brne	80002728 <ToneControl_reply_func+0x14>
	{		
		log("Tone OK\n");
80002720:	48 4c       	lddpc	r12,80002730 <ToneControl_reply_func+0x1c>
80002722:	f0 1f 00 05 	mcall	80002734 <ToneControl_reply_func+0x20>
80002726:	d8 02       	popm	pc
		//fl_write("/test.txt", FILE_END, (void *)"send tone ok\r\n", sizeof("send tone ok\r\n") - 1);
	}
	else
	{
		log("Tone error");
80002728:	48 4c       	lddpc	r12,80002738 <ToneControl_reply_func+0x24>
8000272a:	f0 1f 00 03 	mcall	80002734 <ToneControl_reply_func+0x20>
8000272e:	d8 02       	popm	pc
80002730:	80 00       	ld.sh	r0,r0[0x0]
80002732:	c7 f0       	breq	80002830 <app_cfg+0xf4>
80002734:	80 00       	ld.sh	r0,r0[0x0]
80002736:	62 b8       	ld.w	r8,r1[0x2c]
80002738:	80 00       	ld.sh	r0,r0[0x0]
8000273a:	c7 fc       	rcall	80002838 <app_cfg+0xfc>

8000273c <app_cfg>:
extern volatile  xTaskHandle save_handle; 
//extern portTickType water_value;
//extern portTickType tx_water_value;
//extern portTickType log_water_value;
static __app_Thread_(app_cfg)
{
8000273c:	d4 31       	pushm	r0-r7,lr
8000273e:	20 1d       	sub	sp,4
	U8 Burst_ID = 0;
	char card_id[4]={0};
	U16  * data_ptr;
	//static const uint8_t test_data[8] = {0x11, 0x23, 0x33, 0x67, 0x89, 0xAB, 0xCD, 0xEF};
	static	OB_States OB_State = OB_UNCONNECTEDWAITINGSTATUS;
	xLastWakeTime = xTaskGetTickCount();
80002740:	f0 1f 00 39 	mcall	80002824 <app_cfg+0xe8>
80002744:	4b 98       	lddpc	r8,80002828 <app_cfg+0xec>
80002746:	91 0c       	st.w	r8[0x0],r12
		
	for(;;)
	{
		switch(OB_State)
80002748:	4b 97       	lddpc	r7,8000282c <app_cfg+0xf0>
				}
								
			break;
			case OB_CONNECTEDWAITTINGSYNTIME:
			
						if(get_time_okay){
8000274a:	4b a5       	lddpc	r5,80002830 <app_cfg+0xf4>
							log("get time okay!\n");
							//vTaskResume(save_handle);
						}
						else
						{						
							xcmp_data_session_req(0x00, sizeof(Message_Protocol_t), DEST);//request to get system time						
8000274c:	30 92       	mov	r2,9
8000274e:	32 01       	mov	r1,32
80002750:	30 06       	mov	r6,0
			break;
			case OB_CONNECTEDWAITTINGSYNTIME:
			
						if(get_time_okay){
							
							OB_State = OB_WAITINGAPPTASK;
80002752:	30 30       	mov	r0,3
							xcmp_data_session_req(0x00, sizeof(Message_Protocol_t), DEST);//request to get system time						
						}
			break;
			case OB_WAITINGAPPTASK:
			
					if(pdPASS == xQueueReceive(xg_resend_queue, &data_ptr, (2000*2) / portTICK_RATE_MS))
80002754:	4b 84       	lddpc	r4,80002834 <app_cfg+0xf8>
	static	OB_States OB_State = OB_UNCONNECTEDWAITINGSTATUS;
	xLastWakeTime = xTaskGetTickCount();
		
	for(;;)
	{
		switch(OB_State)
80002756:	6e 08       	ld.w	r8,r7[0x0]
80002758:	58 28       	cp.w	r8,2
8000275a:	c3 40       	breq	800027c2 <app_cfg+0x86>
8000275c:	58 38       	cp.w	r8,3
8000275e:	c4 00       	breq	800027de <app_cfg+0xa2>
80002760:	58 08       	cp.w	r8,0
80002762:	c5 a1       	brne	80002816 <app_cfg+0xda>
		{
			case OB_UNCONNECTEDWAITINGSTATUS:
			
				if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
80002764:	4b 58       	lddpc	r8,80002838 <app_cfg+0xfc>
80002766:	70 08       	ld.w	r8,r8[0x0]
80002768:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
8000276c:	58 38       	cp.w	r8,3
8000276e:	c1 21       	brne	80002792 <app_cfg+0x56>
80002770:	4b 38       	lddpc	r8,8000283c <app_cfg+0x100>
80002772:	11 88       	ld.ub	r8,r8[0x0]
80002774:	58 08       	cp.w	r8,0
80002776:	c0 e1       	brne	80002792 <app_cfg+0x56>
				{
					connect_flag=1;
80002778:	30 19       	mov	r9,1
8000277a:	4b 18       	lddpc	r8,8000283c <app_cfg+0x100>
8000277c:	b0 89       	st.b	r8[0x0],r9
					xcmp_IdleTestTone(Tone_Start, Priority_Beep);//set tone to indicate connection success!!!
8000277e:	30 cb       	mov	r11,12
80002780:	30 1c       	mov	r12,1
80002782:	f0 1f 00 30 	mcall	80002840 <app_cfg+0x104>
					OB_State = OB_CONNECTEDWAITTINGSYNTIME;
80002786:	30 28       	mov	r8,2
80002788:	8f 08       	st.w	r7[0x0],r8
					log("connect OB okay!\n");
8000278a:	4a fc       	lddpc	r12,80002844 <app_cfg+0x108>
8000278c:	f0 1f 00 2f 	mcall	80002848 <app_cfg+0x10c>
	{
		switch(OB_State)
		{
			case OB_UNCONNECTEDWAITINGSTATUS:
			
				if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
80002790:	c4 38       	rjmp	80002816 <app_cfg+0xda>
					OB_State = OB_CONNECTEDWAITTINGSYNTIME;
					log("connect OB okay!\n");
				}
				else
				{
					nop();
80002792:	d7 03       	nop
					nop();
80002794:	d7 03       	nop
					nop();
80002796:	d7 03       	nop
					//xcmp_IdleTestTone(Tone_Start, Bad_Key_Chirp);//set tone to indicate connection failure!!!
					log("connecting...\n");
80002798:	4a dc       	lddpc	r12,8000284c <app_cfg+0x110>
8000279a:	f0 1f 00 2c 	mcall	80002848 <app_cfg+0x10c>
					log("Current time is :20%d:%2d:%2d, %2d:%2d:%2d\n",
					Current_time.Year, Current_time.Month, Current_time.Day,
					Current_time.Hour, Current_time.Minute, Current_time.Second);
8000279e:	4a d8       	lddpc	r8,80002850 <app_cfg+0x114>
800027a0:	11 de       	ld.ub	lr,r8[0x5]
800027a2:	11 cc       	ld.ub	r12,r8[0x4]
800027a4:	11 bb       	ld.ub	r11,r8[0x3]
					nop();
					nop();
					//xcmp_IdleTestTone(Tone_Start, Bad_Key_Chirp);//set tone to indicate connection failure!!!
					log("connecting...\n");
					log("Current time is :20%d:%2d:%2d, %2d:%2d:%2d\n",
					Current_time.Year, Current_time.Month, Current_time.Day,
800027a6:	11 aa       	ld.ub	r10,r8[0x2]
800027a8:	11 99       	ld.ub	r9,r8[0x1]
800027aa:	11 88       	ld.ub	r8,r8[0x0]
					nop();
					nop();
					nop();
					//xcmp_IdleTestTone(Tone_Start, Bad_Key_Chirp);//set tone to indicate connection failure!!!
					log("connecting...\n");
					log("Current time is :20%d:%2d:%2d, %2d:%2d:%2d\n",
800027ac:	1a de       	st.w	--sp,lr
800027ae:	1a dc       	st.w	--sp,r12
800027b0:	1a db       	st.w	--sp,r11
800027b2:	1a da       	st.w	--sp,r10
800027b4:	1a d9       	st.w	--sp,r9
800027b6:	1a d8       	st.w	--sp,r8
800027b8:	4a 7c       	lddpc	r12,80002854 <app_cfg+0x118>
800027ba:	f0 1f 00 24 	mcall	80002848 <app_cfg+0x10c>
800027be:	2f ad       	sub	sp,-24
800027c0:	c2 b8       	rjmp	80002816 <app_cfg+0xda>
				}
								
			break;
			case OB_CONNECTEDWAITTINGSYNTIME:
			
						if(get_time_okay){
800027c2:	0b 88       	ld.ub	r8,r5[0x0]
800027c4:	58 08       	cp.w	r8,0
800027c6:	c0 60       	breq	800027d2 <app_cfg+0x96>
							
							OB_State = OB_WAITINGAPPTASK;
800027c8:	8f 00       	st.w	r7[0x0],r0
							log("get time okay!\n");
800027ca:	4a 4c       	lddpc	r12,80002858 <app_cfg+0x11c>
800027cc:	f0 1f 00 1f 	mcall	80002848 <app_cfg+0x10c>
800027d0:	c2 38       	rjmp	80002816 <app_cfg+0xda>
							//vTaskResume(save_handle);
						}
						else
						{						
							xcmp_data_session_req(0x00, sizeof(Message_Protocol_t), DEST);//request to get system time						
800027d2:	04 9a       	mov	r10,r2
800027d4:	02 9b       	mov	r11,r1
800027d6:	0c 9c       	mov	r12,r6
800027d8:	f0 1f 00 21 	mcall	8000285c <app_cfg+0x120>
800027dc:	c1 d8       	rjmp	80002816 <app_cfg+0xda>
						}
			break;
			case OB_WAITINGAPPTASK:
			
					if(pdPASS == xQueueReceive(xg_resend_queue, &data_ptr, (2000*2) / portTICK_RATE_MS))
800027de:	68 0c       	ld.w	r12,r4[0x0]
800027e0:	0c 99       	mov	r9,r6
800027e2:	e0 6a 0f a0 	mov	r10,4000
800027e6:	1a 9b       	mov	r11,sp
800027e8:	f0 1f 00 1e 	mcall	80002860 <app_cfg+0x124>
800027ec:	58 1c       	cp.w	r12,1
800027ee:	c1 01       	brne	8000280e <app_cfg+0xd2>
					{
						if(data_ptr!=NULL){//Resend message
800027f0:	40 0c       	lddsp	r12,sp[0x0]
800027f2:	58 0c       	cp.w	r12,0
800027f4:	c0 d0       	breq	8000280e <app_cfg+0xd2>
							
							//Message_Protocol_t *ptr = (Message_Protocol_t* )data_ptr;
							//xgflash_message_save(data_ptr, sizeof(Message_Protocol_t), TRUE);
							//log("receive data : %d", ptr->data.XG_Time.Second);
							xcmp_data_session_req(data_ptr, sizeof(Message_Protocol_t), DEST);
800027f6:	04 9a       	mov	r10,r2
800027f8:	02 9b       	mov	r11,r1
800027fa:	f0 1f 00 19 	mcall	8000285c <app_cfg+0x120>
							
							//flashc_memset8((void*)0x80038000, 0x02, 5, TRUE);
							
							set_message_store(data_ptr);
800027fe:	49 a8       	lddpc	r8,80002864 <app_cfg+0x128>
80002800:	70 0c       	ld.w	r12,r8[0x0]
80002802:	40 0b       	lddsp	r11,sp[0x0]
80002804:	f0 1f 00 19 	mcall	80002868 <app_cfg+0x12c>
							log("receive okay!\n");
80002808:	49 9c       	lddpc	r12,8000286c <app_cfg+0x130>
8000280a:	f0 1f 00 10 	mcall	80002848 <app_cfg+0x10c>
					//}
					//else
					//{
					//log("no find card...\n");
					//}
					nop();
8000280e:	d7 03       	nop
					//log("Current time is :20%d:%2d:%2d, %2d:%2d:%2d\n",
					//Current_time.Year, Current_time.Month, Current_time.Day,
					//Current_time.Hour, Current_time.Minute, Current_time.Second);
					log("app task run!\n");
80002810:	49 8c       	lddpc	r12,80002870 <app_cfg+0x134>
80002812:	f0 1f 00 0e 	mcall	80002848 <app_cfg+0x10c>
			break;
				
		} //End of switch on OB_State.
		//vTaskDelay(300*2 / portTICK_RATE_MS);//延迟300ms
		//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
		vTaskDelayUntil( &xLastWakeTime, (2000*2) / portTICK_RATE_MS  );//精确的以1000ms为周期执行。
80002816:	e0 6b 0f a0 	mov	r11,4000
8000281a:	48 4c       	lddpc	r12,80002828 <app_cfg+0xec>
8000281c:	f0 1f 00 16 	mcall	80002874 <app_cfg+0x138>
	}
80002820:	c9 bb       	rjmp	80002756 <app_cfg+0x1a>
80002822:	00 00       	add	r0,r0
80002824:	80 00       	ld.sh	r0,r0[0x0]
80002826:	5b e4       	cp.w	r4,-2
80002828:	00 00       	add	r0,r0
8000282a:	0a 38       	cp.w	r8,r5
8000282c:	00 00       	add	r0,r0
8000282e:	0a 30       	cp.w	r0,r5
80002830:	00 00       	add	r0,r0
80002832:	00 04       	add	r4,r0
80002834:	00 00       	add	r0,r0
80002836:	0a 74       	tst	r4,r5
80002838:	00 00       	add	r0,r0
8000283a:	0d 14       	ld.sh	r4,r6++
8000283c:	00 00       	add	r0,r0
8000283e:	0a 34       	cp.w	r4,r5
80002840:	80 00       	ld.sh	r0,r0[0x0]
80002842:	33 38       	mov	r8,51
80002844:	80 00       	ld.sh	r0,r0[0x0]
80002846:	c8 08       	rjmp	80002946 <DataSession_brdcst_func+0x76>
80002848:	80 00       	ld.sh	r0,r0[0x0]
8000284a:	62 b8       	ld.w	r8,r1[0x2c]
8000284c:	80 00       	ld.sh	r0,r0[0x0]
8000284e:	c8 1c       	rcall	80002950 <DataSession_brdcst_func+0x80>
80002850:	00 00       	add	r0,r0
80002852:	0d 18       	ld.sh	r8,r6++
80002854:	80 00       	ld.sh	r0,r0[0x0]
80002856:	c8 2c       	rcall	8000295a <DataSession_brdcst_func+0x8a>
80002858:	80 00       	ld.sh	r0,r0[0x0]
8000285a:	c8 58       	rjmp	80002964 <DataSession_brdcst_func+0x94>
8000285c:	80 00       	ld.sh	r0,r0[0x0]
8000285e:	32 6c       	mov	r12,38
80002860:	80 00       	ld.sh	r0,r0[0x0]
80002862:	54 c4       	stdsp	sp[0x130],r4
80002864:	00 00       	add	r0,r0
80002866:	0a 94       	mov	r4,r5
80002868:	80 00       	ld.sh	r0,r0[0x0]
8000286a:	31 d0       	mov	r0,29
8000286c:	80 00       	ld.sh	r0,r0[0x0]
8000286e:	c8 68       	rjmp	8000297a <DataSession_brdcst_func+0xaa>
80002870:	80 00       	ld.sh	r0,r0[0x0]
80002872:	c8 78       	rjmp	80002980 <DataSession_brdcst_func+0xb0>
80002874:	80 00       	ld.sh	r0,r0[0x0]
80002876:	5d 94       	*unknown*

80002878 <Phyuserinput_brdcst_func>:
	
}


void Phyuserinput_brdcst_func(xcmp_fragment_t * xcmp)
{
80002878:	eb cd 40 80 	pushm	r7,lr
	U8 PUI_State_Min_Value =0;
	U8 PUI_State_Max_Value =0;
	
	PUI_Source = xcmp->u8[0];
	PUI_Type = xcmp ->u8[1];
	PUI_ID = ((xcmp->u8[2]<<8) | xcmp->u8[3]);
8000287c:	19 c7       	ld.ub	r7,r12[0x4]
8000287e:	19 d8       	ld.ub	r8,r12[0x5]
80002880:	f1 e7 10 87 	or	r7,r8,r7<<0x8
80002884:	5c 87       	casts.h	r7
	PUI_State = xcmp->u8[4];
	PUI_State_Min_Value = xcmp->u8[5];
	PUI_State_Max_Value = xcmp->u8[6];
	
	log("PhysicalUserInput_broadcast  \n\r"  );
80002886:	48 dc       	lddpc	r12,800028b8 <Phyuserinput_brdcst_func+0x40>
80002888:	f0 1f 00 0d 	mcall	800028bc <Phyuserinput_brdcst_func+0x44>
	
	if((PUI_ID == 0x0060) && (PUI_State = 0x02) && (connect_flag == 1)){
8000288c:	36 08       	mov	r8,96
8000288e:	f0 07 19 00 	cp.h	r7,r8
80002892:	c1 11       	brne	800028b4 <Phyuserinput_brdcst_func+0x3c>
80002894:	48 b8       	lddpc	r8,800028c0 <Phyuserinput_brdcst_func+0x48>
80002896:	11 89       	ld.ub	r9,r8[0x0]
80002898:	30 18       	mov	r8,1
8000289a:	f0 09 18 00 	cp.b	r9,r8
8000289e:	c0 b1       	brne	800028b4 <Phyuserinput_brdcst_func+0x3c>
		//log("send message\n");
		xcmp_IdleTestTone(Tone_Start, ACK_Received_Tone);//set tone to indicate the scan!!!
800028a0:	31 4b       	mov	r11,20
800028a2:	30 1c       	mov	r12,1
800028a4:	f0 1f 00 08 	mcall	800028c4 <Phyuserinput_brdcst_func+0x4c>
			
		vTaskDelay(400*2 / portTICK_RATE_MS);//延迟400ms
800028a8:	e0 6c 03 20 	mov	r12,800
800028ac:	f0 1f 00 07 	mcall	800028c8 <Phyuserinput_brdcst_func+0x50>
		//delay_ms(200);
		rfid_sendID_message();//send message		
800028b0:	f0 1f 00 07 	mcall	800028cc <Phyuserinput_brdcst_func+0x54>
800028b4:	e3 cd 80 80 	ldm	sp++,r7,pc
800028b8:	80 00       	ld.sh	r0,r0[0x0]
800028ba:	c8 88       	rjmp	800029ca <DeviceInitializationStatus_brdcst_func+0x2>
800028bc:	80 00       	ld.sh	r0,r0[0x0]
800028be:	62 b8       	ld.w	r8,r1[0x2c]
800028c0:	00 00       	add	r0,r0
800028c2:	0a 34       	cp.w	r4,r5
800028c4:	80 00       	ld.sh	r0,r0[0x0]
800028c6:	33 38       	mov	r8,51
800028c8:	80 00       	ld.sh	r0,r0[0x0]
800028ca:	5d 4c       	*unknown*
800028cc:	80 00       	ld.sh	r0,r0[0x0]
800028ce:	3c e0       	mov	r0,-50

800028d0 <DataSession_brdcst_func>:
	}
	
}

void DataSession_brdcst_func(xcmp_fragment_t * xcmp)
{
800028d0:	d4 21       	pushm	r4-r7,lr
800028d2:	20 9d       	sub	sp,36
	U32 card_id =0;
	U8 i = 0;
	xgflash_status_t return_value = XG_ERROR;
	
	/*point to xcmp payload*/
	DataSession_brdcst_t *ptr = (DataSession_brdcst_t* )xcmp->u8;
800028d4:	f8 c6 ff fe 	sub	r6,r12,-2
	
	if (ptr->State == CSBK_DATA_RX_Suc)
800028d8:	0d 88       	ld.ub	r8,r6[0x0]
800028da:	32 49       	mov	r9,36
800028dc:	f2 08 18 00 	cp.b	r8,r9
800028e0:	c2 91       	brne	80002932 <DataSession_brdcst_func+0x62>
	{
		
		log("\n\r CSBK_RX OK \n\r");
800028e2:	4a dc       	lddpc	r12,80002994 <DataSession_brdcst_func+0xc4>
800028e4:	f0 1f 00 2d 	mcall	80002998 <DataSession_brdcst_func+0xc8>
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
800028e8:	0d a5       	ld.ub	r5,r6[0x2]
800028ea:	0d b8       	ld.ub	r8,r6[0x3]
800028ec:	f1 e5 10 85 	or	r5,r8,r5<<0x8
800028f0:	5c 85       	casts.h	r5

		log("\n\r Session_ID: %x \n\r",Session_number );
800028f2:	0d 98       	ld.ub	r8,r6[0x1]
800028f4:	1a d8       	st.w	--sp,r8
800028f6:	4a ac       	lddpc	r12,8000299c <DataSession_brdcst_func+0xcc>
800028f8:	f0 1f 00 28 	mcall	80002998 <DataSession_brdcst_func+0xc8>
		log("\n\r paylaod_length: %d \n\r",data_length );
800028fc:	f1 d5 c0 10 	bfextu	r8,r5,0x0,0x10
80002900:	1a d8       	st.w	--sp,r8
80002902:	4a 8c       	lddpc	r12,800029a0 <DataSession_brdcst_func+0xd0>
80002904:	f0 1f 00 25 	mcall	80002998 <DataSession_brdcst_func+0xc8>
		for(i=0; i<data_length; i++)
80002908:	2f ed       	sub	sp,-8
8000290a:	58 05       	cp.w	r5,0
8000290c:	c4 10       	breq	8000298e <DataSession_brdcst_func+0xbe>
8000290e:	30 07       	mov	r7,0
		{
			
			//log("\n\r payload[%d]: %X \n\r", i, xcmp->u8[4+i]);
			log("\n\r payload[%d]: %X \n\r", i, ptr->DataPayload.DataPayload[i]);
80002910:	4a 54       	lddpc	r4,800029a4 <DataSession_brdcst_func+0xd4>
80002912:	ec 07 00 08 	add	r8,r6,r7
80002916:	11 c8       	ld.ub	r8,r8[0x4]
80002918:	1a d8       	st.w	--sp,r8
8000291a:	1a d7       	st.w	--sp,r7
8000291c:	08 9c       	mov	r12,r4
8000291e:	f0 1f 00 1f 	mcall	80002998 <DataSession_brdcst_func+0xc8>
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);

		log("\n\r Session_ID: %x \n\r",Session_number );
		log("\n\r paylaod_length: %d \n\r",data_length );
		for(i=0; i<data_length; i++)
80002922:	2f f7       	sub	r7,-1
80002924:	5c 57       	castu.b	r7
80002926:	2f ed       	sub	sp,-8
80002928:	ee 05 19 00 	cp.h	r5,r7
8000292c:	fe 9b ff f3 	brhi	80002912 <DataSession_brdcst_func+0x42>
80002930:	c2 f8       	rjmp	8000298e <DataSession_brdcst_func+0xbe>
	else
	{
		//log("\n\r State: 0x %X \n\r", xcmp->u8[0]);
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];				
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
		log("State: %X \n", ptr->State);
80002932:	1a d8       	st.w	--sp,r8
80002934:	49 dc       	lddpc	r12,800029a8 <DataSession_brdcst_func+0xd8>
80002936:	f0 1f 00 19 	mcall	80002998 <DataSession_brdcst_func+0xc8>
		if (ptr->State == DATA_SESSION_TX_Suc)
8000293a:	0d 88       	ld.ub	r8,r6[0x0]
8000293c:	2f fd       	sub	sp,-4
8000293e:	30 39       	mov	r9,3
80002940:	f2 08 18 00 	cp.b	r8,r9
80002944:	c0 51       	brne	8000294e <DataSession_brdcst_func+0x7e>
		{
			log("data transmit success\n");
80002946:	49 ac       	lddpc	r12,800029ac <DataSession_brdcst_func+0xdc>
80002948:	f0 1f 00 14 	mcall	80002998 <DataSession_brdcst_func+0xc8>
8000294c:	c2 18       	rjmp	8000298e <DataSession_brdcst_func+0xbe>
		}
		else if(ptr->State == DATA_SESSION_TX_Fail)
8000294e:	30 49       	mov	r9,4
80002950:	f2 08 18 00 	cp.b	r8,r9
80002954:	c1 d1       	brne	8000298e <DataSession_brdcst_func+0xbe>
		{
			//Message_Protocol_t  *xgmessage = (Message_Protocol_t  *)ptr->DataPayload.DataPayload;
			Message_Protocol_t  xgmessage;
			memcpy(&xgmessage, ptr->DataPayload.DataPayload, sizeof(Message_Protocol_t));
80002956:	32 0a       	mov	r10,32
80002958:	ec cb ff fc 	sub	r11,r6,-4
8000295c:	1a 9c       	mov	r12,sp
8000295e:	f0 1f 00 15 	mcall	800029b0 <DataSession_brdcst_func+0xe0>
			//xgmessage.data.XG_Time.Year, xgmessage.data.XG_Time.Month, xgmessage.data.XG_Time.Day,
			//xgmessage.data.XG_Time.Hour, xgmessage.data.XG_Time.Minute, xgmessage.data.XG_Time.Second);

			//return_value = xgflash_message_save(&xgmessage, sizeof(Message_Protocol_t), TRUE);

			Message_Protocol_t * myptr = get_message_store();	
80002962:	49 58       	lddpc	r8,800029b4 <DataSession_brdcst_func+0xe4>
80002964:	70 0c       	ld.w	r12,r8[0x0]
80002966:	f0 1f 00 15 	mcall	800029b8 <DataSession_brdcst_func+0xe8>
8000296a:	50 8c       	stdsp	sp[0x20],r12
			if(NULL != myptr)
8000296c:	c0 e0       	breq	80002988 <DataSession_brdcst_func+0xb8>
			{
				memcpy(myptr, &xgmessage, sizeof(Message_Protocol_t));			
8000296e:	32 0a       	mov	r10,32
80002970:	1a 9b       	mov	r11,sp
80002972:	f0 1f 00 10 	mcall	800029b0 <DataSession_brdcst_func+0xe0>
				xQueueSend(xg_resend_queue, &myptr, 0);
80002976:	49 28       	lddpc	r8,800029bc <DataSession_brdcst_func+0xec>
80002978:	70 0c       	ld.w	r12,r8[0x0]
8000297a:	30 09       	mov	r9,0
8000297c:	12 9a       	mov	r10,r9
8000297e:	fa cb ff e0 	sub	r11,sp,-32
80002982:	f0 1f 00 10 	mcall	800029c0 <DataSession_brdcst_func+0xf0>
80002986:	c0 48       	rjmp	8000298e <DataSession_brdcst_func+0xbe>
			}
			else
			{
				log("myptr: err\n\r" );
80002988:	48 fc       	lddpc	r12,800029c4 <DataSession_brdcst_func+0xf4>
8000298a:	f0 1f 00 04 	mcall	80002998 <DataSession_brdcst_func+0xc8>
				//
		//}
		
	}
	
}
8000298e:	2f 7d       	sub	sp,-36
80002990:	d8 22       	popm	r4-r7,pc
80002992:	00 00       	add	r0,r0
80002994:	80 00       	ld.sh	r0,r0[0x0]
80002996:	c8 a8       	rjmp	80002aaa <send_flash_command+0xaa>
80002998:	80 00       	ld.sh	r0,r0[0x0]
8000299a:	62 b8       	ld.w	r8,r1[0x2c]
8000299c:	80 00       	ld.sh	r0,r0[0x0]
8000299e:	c8 bc       	rcall	80002ab4 <send_flash_command+0xb4>
800029a0:	80 00       	ld.sh	r0,r0[0x0]
800029a2:	c8 d4       	brge	800028bc <Phyuserinput_brdcst_func+0x44>
800029a4:	80 00       	ld.sh	r0,r0[0x0]
800029a6:	c8 f0       	breq	800028c4 <Phyuserinput_brdcst_func+0x4c>
800029a8:	80 00       	ld.sh	r0,r0[0x0]
800029aa:	c9 08       	rjmp	80002aca <send_flash_command+0xca>
800029ac:	80 00       	ld.sh	r0,r0[0x0]
800029ae:	c9 14       	brge	800028d0 <DataSession_brdcst_func>
800029b0:	80 00       	ld.sh	r0,r0[0x0]
800029b2:	69 da       	ld.w	r10,r4[0x74]
800029b4:	00 00       	add	r0,r0
800029b6:	0a 94       	mov	r4,r5
800029b8:	80 00       	ld.sh	r0,r0[0x0]
800029ba:	31 f0       	mov	r0,31
800029bc:	00 00       	add	r0,r0
800029be:	0a 74       	tst	r4,r5
800029c0:	80 00       	ld.sh	r0,r0[0x0]
800029c2:	56 80       	stdsp	sp[0x1a0],r0
800029c4:	80 00       	ld.sh	r0,r0[0x0]
800029c6:	c9 2c       	rcall	80002aea <send_flash_command+0xea>

800029c8 <DeviceInitializationStatus_brdcst_func>:
extern volatile xQueueHandle xg_resend_queue ;

//app func--list

void DeviceInitializationStatus_brdcst_func(xcmp_fragment_t  * xcmp)
{
800029c8:	d4 01       	pushm	lr
	if (xcmp->u8[4] == 0x01)
800029ca:	19 e8       	ld.ub	r8,r12[0x6]
800029cc:	30 19       	mov	r9,1
800029ce:	f2 08 18 00 	cp.b	r8,r9
800029d2:	c0 61       	brne	800029de <DeviceInitializationStatus_brdcst_func+0x16>
	{
		bunchofrandomstatusflags |= 0x01;  //Need do nothing else.
800029d4:	48 98       	lddpc	r8,800029f8 <DeviceInitializationStatus_brdcst_func+0x30>
800029d6:	70 09       	ld.w	r9,r8[0x0]
800029d8:	a1 a9       	sbr	r9,0x0
800029da:	91 09       	st.w	r8[0x0],r9
800029dc:	d8 02       	popm	pc
	}
	else if(xcmp->u8[4] != 0x02)
800029de:	30 29       	mov	r9,2
800029e0:	f2 08 18 00 	cp.b	r8,r9
800029e4:	c0 80       	breq	800029f4 <DeviceInitializationStatus_brdcst_func+0x2c>
	{
		bunchofrandomstatusflags  &= 0xFFFFFFFC; //Device Init no longer Complete.
800029e6:	48 58       	lddpc	r8,800029f8 <DeviceInitializationStatus_brdcst_func+0x30>
800029e8:	70 09       	ld.w	r9,r8[0x0]
800029ea:	e0 19 ff fc 	andl	r9,0xfffc
800029ee:	91 09       	st.w	r8[0x0],r9
		xcmp_DeviceInitializationStatus_request();
800029f0:	f0 1f 00 03 	mcall	800029fc <DeviceInitializationStatus_brdcst_func+0x34>
800029f4:	d8 02       	popm	pc
800029f6:	00 00       	add	r0,r0
800029f8:	00 00       	add	r0,r0
800029fa:	0d 14       	ld.sh	r4,r6++
800029fc:	80 00       	ld.sh	r0,r0[0x0]
800029fe:	32 f8       	mov	r8,47

80002a00 <send_flash_command>:
* ----------  --------  ----------  --------------------------------------------
* 10-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
U16 send_flash_command(U16 command, U32 address, U8 *data_ptr, U16 length)
{
80002a00:	eb cd 40 fc 	pushm	r2-r7,lr
80002a04:	20 1d       	sub	sp,4
80002a06:	18 97       	mov	r7,r12
80002a08:	14 95       	mov	r5,r10
80002a0a:	12 96       	mov	r6,r9
	U16 status = 1;
80002a0c:	30 18       	mov	r8,1
80002a0e:	ba 18       	st.h	sp[0x2],r8
	U16 i = 0;

    /* in order to call spi_write(U16* data), change 3-bytes address to 3-U16 address */
	U16 addr[3];
	addr[2] = (address & 0x00ff0000) >> 16;
80002a10:	e9 db c2 08 	bfextu	r4,r11,0x10,0x8
	addr[1] = (address & 0x0000ff00) >> 8;
80002a14:	e7 db c1 08 	bfextu	r3,r11,0x8,0x8
	addr[0] = (address & 0x000000ff);
80002a18:	e5 db c0 08 	bfextu	r2,r11,0x0,0x8

	U16 data_u16;

	spi_selectChip(spi, DF_SPI_PCS_1);
80002a1c:	30 1b       	mov	r11,1
80002a1e:	4e 58       	lddpc	r8,80002bb0 <send_flash_command+0x1b0>
80002a20:	70 0c       	ld.w	r12,r8[0x0]
80002a22:	f0 1f 00 65 	mcall	80002bb4 <send_flash_command+0x1b4>

    switch (command)
80002a26:	30 58       	mov	r8,5
80002a28:	f0 07 19 00 	cp.h	r7,r8
80002a2c:	c3 40       	breq	80002a94 <send_flash_command+0x94>
80002a2e:	e0 8b 00 18 	brhi	80002a5e <send_flash_command+0x5e>
80002a32:	30 28       	mov	r8,2
80002a34:	f0 07 19 00 	cp.h	r7,r8
80002a38:	c5 e0       	breq	80002af4 <send_flash_command+0xf4>
80002a3a:	e0 8b 00 08 	brhi	80002a4a <send_flash_command+0x4a>
80002a3e:	30 18       	mov	r8,1
80002a40:	f0 07 19 00 	cp.h	r7,r8
80002a44:	e0 81 00 ad 	brne	80002b9e <send_flash_command+0x19e>
80002a48:	c9 e8       	rjmp	80002b84 <send_flash_command+0x184>
80002a4a:	30 38       	mov	r8,3
80002a4c:	f0 07 19 00 	cp.h	r7,r8
80002a50:	c7 20       	breq	80002b34 <send_flash_command+0x134>
80002a52:	30 48       	mov	r8,4
80002a54:	f0 07 19 00 	cp.h	r7,r8
80002a58:	e0 81 00 a3 	brne	80002b9e <send_flash_command+0x19e>
80002a5c:	c2 c8       	rjmp	80002ab4 <send_flash_command+0xb4>
80002a5e:	35 28       	mov	r8,82
80002a60:	f0 07 19 00 	cp.h	r7,r8
80002a64:	c2 f0       	breq	80002ac2 <send_flash_command+0xc2>
80002a66:	e0 8b 00 0c 	brhi	80002a7e <send_flash_command+0x7e>
80002a6a:	30 68       	mov	r8,6
80002a6c:	f0 07 19 00 	cp.h	r7,r8
80002a70:	c2 20       	breq	80002ab4 <send_flash_command+0xb4>
80002a72:	32 08       	mov	r8,32
80002a74:	f0 07 19 00 	cp.h	r7,r8
80002a78:	e0 81 00 93 	brne	80002b9e <send_flash_command+0x19e>
80002a7c:	c2 38       	rjmp	80002ac2 <send_flash_command+0xc2>
80002a7e:	36 08       	mov	r8,96
80002a80:	f0 07 19 00 	cp.h	r7,r8
80002a84:	c3 20       	breq	80002ae8 <send_flash_command+0xe8>
80002a86:	e0 68 00 d8 	mov	r8,216
80002a8a:	f0 07 19 00 	cp.h	r7,r8
80002a8e:	e0 81 00 88 	brne	80002b9e <send_flash_command+0x19e>
80002a92:	c1 88       	rjmp	80002ac2 <send_flash_command+0xc2>
	{
		case READ_STATUS_REG:
			spi_write_byte(command);
80002a94:	4c 77       	lddpc	r7,80002bb0 <send_flash_command+0x1b0>
80002a96:	30 5b       	mov	r11,5
80002a98:	6e 0c       	ld.w	r12,r7[0x0]
80002a9a:	f0 1f 00 48 	mcall	80002bb8 <send_flash_command+0x1b8>
			spi_write_dummy();
80002a9e:	e0 6b 00 ff 	mov	r11,255
80002aa2:	6e 0c       	ld.w	r12,r7[0x0]
80002aa4:	f0 1f 00 45 	mcall	80002bb8 <send_flash_command+0x1b8>
			spi_read_byte(&status);
80002aa8:	fa cb ff fe 	sub	r11,sp,-2
80002aac:	6e 0c       	ld.w	r12,r7[0x0]
80002aae:	f0 1f 00 44 	mcall	80002bbc <send_flash_command+0x1bc>
			break;
80002ab2:	c7 68       	rjmp	80002b9e <send_flash_command+0x19e>
		case WRITE_ENABLE:
		case WRITE_DISABLE:
			spi_write_byte(command);
80002ab4:	0e 9b       	mov	r11,r7
80002ab6:	5c 7b       	castu.h	r11
80002ab8:	4b e8       	lddpc	r8,80002bb0 <send_flash_command+0x1b0>
80002aba:	70 0c       	ld.w	r12,r8[0x0]
80002abc:	f0 1f 00 3f 	mcall	80002bb8 <send_flash_command+0x1b8>
			break;
80002ac0:	c6 f8       	rjmp	80002b9e <send_flash_command+0x19e>
		case BLOCK_ERASE_4KB:
		case BLOCK_ERASE_32KB:
		case BLOCK_ERASE_64KB:
			spi_write_byte(command);
80002ac2:	4b c6       	lddpc	r6,80002bb0 <send_flash_command+0x1b0>
80002ac4:	0e 9b       	mov	r11,r7
80002ac6:	5c 7b       	castu.h	r11
80002ac8:	6c 0c       	ld.w	r12,r6[0x0]
80002aca:	f0 1f 00 3c 	mcall	80002bb8 <send_flash_command+0x1b8>
			spi_write_byte(addr[2]);
80002ace:	08 9b       	mov	r11,r4
80002ad0:	6c 0c       	ld.w	r12,r6[0x0]
80002ad2:	f0 1f 00 3a 	mcall	80002bb8 <send_flash_command+0x1b8>
			spi_write_byte(addr[1]);
80002ad6:	06 9b       	mov	r11,r3
80002ad8:	6c 0c       	ld.w	r12,r6[0x0]
80002ada:	f0 1f 00 38 	mcall	80002bb8 <send_flash_command+0x1b8>
			spi_write_byte(addr[0]);
80002ade:	04 9b       	mov	r11,r2
80002ae0:	6c 0c       	ld.w	r12,r6[0x0]
80002ae2:	f0 1f 00 36 	mcall	80002bb8 <send_flash_command+0x1b8>
			break;
80002ae6:	c5 c8       	rjmp	80002b9e <send_flash_command+0x19e>
		case CHIP_ERASE:
			spi_write_byte(command);
80002ae8:	36 0b       	mov	r11,96
80002aea:	4b 28       	lddpc	r8,80002bb0 <send_flash_command+0x1b0>
80002aec:	70 0c       	ld.w	r12,r8[0x0]
80002aee:	f0 1f 00 33 	mcall	80002bb8 <send_flash_command+0x1b8>
			break;
80002af2:	c5 68       	rjmp	80002b9e <send_flash_command+0x19e>
		case BYTE_PROGRAM: /* PAGE_PROGRAM use the same value */
			spi_write_byte(command);
80002af4:	4a f7       	lddpc	r7,80002bb0 <send_flash_command+0x1b0>
80002af6:	30 2b       	mov	r11,2
80002af8:	6e 0c       	ld.w	r12,r7[0x0]
80002afa:	f0 1f 00 30 	mcall	80002bb8 <send_flash_command+0x1b8>
			spi_write_byte(addr[2]);
80002afe:	08 9b       	mov	r11,r4
80002b00:	6e 0c       	ld.w	r12,r7[0x0]
80002b02:	f0 1f 00 2e 	mcall	80002bb8 <send_flash_command+0x1b8>
			spi_write_byte(addr[1]);
80002b06:	06 9b       	mov	r11,r3
80002b08:	6e 0c       	ld.w	r12,r7[0x0]
80002b0a:	f0 1f 00 2c 	mcall	80002bb8 <send_flash_command+0x1b8>
			spi_write_byte(addr[0]);
80002b0e:	04 9b       	mov	r11,r2
80002b10:	6e 0c       	ld.w	r12,r7[0x0]
80002b12:	f0 1f 00 2a 	mcall	80002bb8 <send_flash_command+0x1b8>
			for (i = 0; i < length; i++)
80002b16:	58 06       	cp.w	r6,0
80002b18:	c4 30       	breq	80002b9e <send_flash_command+0x19e>
80002b1a:	0a 97       	mov	r7,r5
			{
				data_u16 = (*data_ptr)&0x00ff;//modified by huayi
				data_ptr++;
				spi_write_byte(data_u16);
80002b1c:	4a 54       	lddpc	r4,80002bb0 <send_flash_command+0x1b0>
			spi_write_byte(addr[2]);
			spi_write_byte(addr[1]);
			spi_write_byte(addr[0]);
			for (i = 0; i < length; i++)
			{
				data_u16 = (*data_ptr)&0x00ff;//modified by huayi
80002b1e:	0f 3b       	ld.ub	r11,r7++
80002b20:	ba 0b       	st.h	sp[0x0],r11
				data_ptr++;
				spi_write_byte(data_u16);
80002b22:	68 0c       	ld.w	r12,r4[0x0]
80002b24:	f0 1f 00 25 	mcall	80002bb8 <send_flash_command+0x1b8>
		case BYTE_PROGRAM: /* PAGE_PROGRAM use the same value */
			spi_write_byte(command);
			spi_write_byte(addr[2]);
			spi_write_byte(addr[1]);
			spi_write_byte(addr[0]);
			for (i = 0; i < length; i++)
80002b28:	0e 98       	mov	r8,r7
80002b2a:	0a 18       	sub	r8,r5
80002b2c:	ec 08 19 00 	cp.h	r8,r6
80002b30:	cf 73       	brcs	80002b1e <send_flash_command+0x11e>
80002b32:	c3 68       	rjmp	80002b9e <send_flash_command+0x19e>
				data_ptr++;
				spi_write_byte(data_u16);
			}
			break;
		case READ_ARRAY:
			spi_write_byte(command);
80002b34:	49 f7       	lddpc	r7,80002bb0 <send_flash_command+0x1b0>
80002b36:	30 3b       	mov	r11,3
80002b38:	6e 0c       	ld.w	r12,r7[0x0]
80002b3a:	f0 1f 00 20 	mcall	80002bb8 <send_flash_command+0x1b8>
			spi_write_byte(addr[2]);
80002b3e:	08 9b       	mov	r11,r4
80002b40:	6e 0c       	ld.w	r12,r7[0x0]
80002b42:	f0 1f 00 1e 	mcall	80002bb8 <send_flash_command+0x1b8>
			spi_write_byte(addr[1]);
80002b46:	06 9b       	mov	r11,r3
80002b48:	6e 0c       	ld.w	r12,r7[0x0]
80002b4a:	f0 1f 00 1c 	mcall	80002bb8 <send_flash_command+0x1b8>
			spi_write_byte(addr[0]);
80002b4e:	04 9b       	mov	r11,r2
80002b50:	6e 0c       	ld.w	r12,r7[0x0]
80002b52:	f0 1f 00 1a 	mcall	80002bb8 <send_flash_command+0x1b8>
			for (i = 0; i < length; i++)
80002b56:	58 06       	cp.w	r6,0
80002b58:	c2 30       	breq	80002b9e <send_flash_command+0x19e>
80002b5a:	0a 97       	mov	r7,r5
			{
				spi_write_dummy();
80002b5c:	49 54       	lddpc	r4,80002bb0 <send_flash_command+0x1b0>
80002b5e:	e0 63 00 ff 	mov	r3,255
				spi_read_byte(&data_u16);
80002b62:	1a 92       	mov	r2,sp
			spi_write_byte(addr[2]);
			spi_write_byte(addr[1]);
			spi_write_byte(addr[0]);
			for (i = 0; i < length; i++)
			{
				spi_write_dummy();
80002b64:	06 9b       	mov	r11,r3
80002b66:	68 0c       	ld.w	r12,r4[0x0]
80002b68:	f0 1f 00 14 	mcall	80002bb8 <send_flash_command+0x1b8>
				spi_read_byte(&data_u16);
80002b6c:	1a 9b       	mov	r11,sp
80002b6e:	68 0c       	ld.w	r12,r4[0x0]
80002b70:	f0 1f 00 13 	mcall	80002bbc <send_flash_command+0x1bc>
				*data_ptr = (U8)data_u16;
80002b74:	9a 08       	ld.sh	r8,sp[0x0]
80002b76:	0e c8       	st.b	r7++,r8
		case READ_ARRAY:
			spi_write_byte(command);
			spi_write_byte(addr[2]);
			spi_write_byte(addr[1]);
			spi_write_byte(addr[0]);
			for (i = 0; i < length; i++)
80002b78:	0e 98       	mov	r8,r7
80002b7a:	0a 18       	sub	r8,r5
80002b7c:	ec 08 19 00 	cp.h	r8,r6
80002b80:	cf 23       	brcs	80002b64 <send_flash_command+0x164>
80002b82:	c0 e8       	rjmp	80002b9e <send_flash_command+0x19e>
				*data_ptr = (U8)data_u16;
				data_ptr++;
			}
			break;
		case WRITE_STATUS_REG_BYTE_1:
			spi_write_byte(command);
80002b84:	48 b7       	lddpc	r7,80002bb0 <send_flash_command+0x1b0>
80002b86:	30 1b       	mov	r11,1
80002b88:	6e 0c       	ld.w	r12,r7[0x0]
80002b8a:	f0 1f 00 0c 	mcall	80002bb8 <send_flash_command+0x1b8>
			spi_write_byte(UNPROTECT_ALL_SECTORS);
80002b8e:	30 0b       	mov	r11,0
80002b90:	6e 0c       	ld.w	r12,r7[0x0]
80002b92:	f0 1f 00 0a 	mcall	80002bb8 <send_flash_command+0x1b8>
			spi_write_byte(UNPROTECT_ALL_SECTORS);
80002b96:	30 0b       	mov	r11,0
80002b98:	6e 0c       	ld.w	r12,r7[0x0]
80002b9a:	f0 1f 00 08 	mcall	80002bb8 <send_flash_command+0x1b8>
			break;
		default:
			break;
	}

	spi_unselectChip(spi, DF_SPI_PCS_1);
80002b9e:	30 1b       	mov	r11,1
80002ba0:	48 48       	lddpc	r8,80002bb0 <send_flash_command+0x1b0>
80002ba2:	70 0c       	ld.w	r12,r8[0x0]
80002ba4:	f0 1f 00 07 	mcall	80002bc0 <send_flash_command+0x1c0>

	return status;
}
80002ba8:	9a 1c       	ld.sh	r12,sp[0x2]
80002baa:	2f fd       	sub	sp,-4
80002bac:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80002bb0:	00 00       	add	r0,r0
80002bb2:	1f a0       	ld.ub	r0,pc[0x2]
80002bb4:	80 00       	ld.sh	r0,r0[0x0]
80002bb6:	4d 7c       	lddpc	r12,80002d10 <data_flash_write_block+0x74>
80002bb8:	80 00       	ld.sh	r0,r0[0x0]
80002bba:	4c 16       	lddpc	r6,80002cbc <data_flash_write_block+0x20>
80002bbc:	80 00       	ld.sh	r0,r0[0x0]
80002bbe:	4c 32       	lddpc	r2,80002cc8 <data_flash_write_block+0x2c>
80002bc0:	80 00       	ld.sh	r0,r0[0x0]
80002bc2:	4d 3c       	lddpc	r12,80002d0c <data_flash_write_block+0x70>

80002bc4 <data_flash_read_block>:
* ----------  --------  ----------  --------------------------------------------
* 25-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_read_block(U32 address, U16 length, U8 *data_ptr)
{
80002bc4:	d4 01       	pushm	lr
	/* check input parameter */
	if (data_ptr == NULL || address >= DF_MAX_ADDR || length > 0x1000)
80002bc6:	58 0a       	cp.w	r10,0
80002bc8:	5f 09       	sreq	r9
80002bca:	e0 68 ff fe 	mov	r8,65534
80002bce:	ea 18 00 7f 	orh	r8,0x7f
80002bd2:	10 3c       	cp.w	r12,r8
80002bd4:	5f b8       	srhi	r8
80002bd6:	f3 e8 10 08 	or	r8,r9,r8
80002bda:	c0 e1       	brne	80002bf6 <data_flash_read_block+0x32>
80002bdc:	e0 68 10 00 	mov	r8,4096
80002be0:	f0 0b 19 00 	cp.h	r11,r8
80002be4:	e0 8b 00 09 	brhi	80002bf6 <data_flash_read_block+0x32>
	{
		return DF_INVALID_PARAM;
	}

	send_flash_command(READ_ARRAY, address, data_ptr, length);
80002be8:	f3 db c0 10 	bfextu	r9,r11,0x0,0x10
80002bec:	18 9b       	mov	r11,r12
80002bee:	30 3c       	mov	r12,3
80002bf0:	f0 1f 00 02 	mcall	80002bf8 <data_flash_read_block+0x34>
80002bf4:	d8 0a       	popm	pc,r12=0

	return DF_OK;
80002bf6:	da 0a       	popm	pc,r12=1
80002bf8:	80 00       	ld.sh	r0,r0[0x0]
80002bfa:	2a 00       	sub	r0,-96

80002bfc <data_flash_write_page>:
* ----------  --------  ----------  --------------------------------------------
* 25-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_write_page(U8 *data_ptr, U32 address, U16 length)
{
80002bfc:	eb cd 40 fc 	pushm	r2-r7,lr
80002c00:	18 94       	mov	r4,r12
80002c02:	16 93       	mov	r3,r11
80002c04:	14 92       	mov	r2,r10
	U16 status = 1;
	df_status_t return_code = DF_WRITE_FAIL;
	U16 count = 0; /* to monitor write time consumption */

	/* check input parameter */
	if (data_ptr == NULL || address >= DF_MAX_ADDR || length > DF_PAGE_SIZE)
80002c06:	58 0c       	cp.w	r12,0
80002c08:	5f 09       	sreq	r9
80002c0a:	e0 68 ff fe 	mov	r8,65534
80002c0e:	ea 18 00 7f 	orh	r8,0x7f
80002c12:	10 3b       	cp.w	r11,r8
80002c14:	5f b8       	srhi	r8
80002c16:	f3 e8 10 08 	or	r8,r9,r8
80002c1a:	c3 a1       	brne	80002c8e <data_flash_write_page+0x92>
80002c1c:	e0 68 01 00 	mov	r8,256
80002c20:	f0 0a 19 00 	cp.h	r10,r8
80002c24:	e0 8b 00 35 	brhi	80002c8e <data_flash_write_page+0x92>
	{
		return DF_INVALID_PARAM;
	}

	while(status = send_flash_command(READ_STATUS_REG, 0, NULL, 0) == STATUS_BUSY);
80002c28:	30 06       	mov	r6,0
80002c2a:	30 55       	mov	r5,5
80002c2c:	30 17       	mov	r7,1
80002c2e:	0c 99       	mov	r9,r6
80002c30:	0c 9a       	mov	r10,r6
80002c32:	0c 9b       	mov	r11,r6
80002c34:	0a 9c       	mov	r12,r5
80002c36:	f0 1f 00 19 	mcall	80002c98 <data_flash_write_page+0x9c>
80002c3a:	ee 0c 19 00 	cp.h	r12,r7
80002c3e:	cf 80       	breq	80002c2e <data_flash_write_page+0x32>
	//{
		//return DF_DEVICE_BUSY;
	//}

	/* send WRITE_ENABLE command */
	send_flash_command(WRITE_ENABLE, 0, NULL, 0);
80002c40:	30 09       	mov	r9,0
80002c42:	12 9a       	mov	r10,r9
80002c44:	12 9b       	mov	r11,r9
80002c46:	30 6c       	mov	r12,6
80002c48:	f0 1f 00 14 	mcall	80002c98 <data_flash_write_page+0x9c>

	/* send PAGE_PROGRAM command */
	send_flash_command(PAGE_PROGRAM, address, data_ptr, length);
80002c4c:	f3 d2 c0 10 	bfextu	r9,r2,0x0,0x10
80002c50:	08 9a       	mov	r10,r4
80002c52:	06 9b       	mov	r11,r3
80002c54:	30 2c       	mov	r12,2
80002c56:	f0 1f 00 11 	mcall	80002c98 <data_flash_write_page+0x9c>
	do {
		status = send_flash_command(READ_STATUS_REG, 0, NULL, 0);
80002c5a:	30 06       	mov	r6,0
80002c5c:	30 57       	mov	r7,5
80002c5e:	0c 99       	mov	r9,r6
80002c60:	0c 9a       	mov	r10,r6
80002c62:	0c 9b       	mov	r11,r6
80002c64:	0e 9c       	mov	r12,r7
80002c66:	f0 1f 00 0d 	mcall	80002c98 <data_flash_write_page+0x9c>
		count++;
	} while((status & STATUS_BUSY) != 0);
80002c6a:	5c 7c       	castu.h	r12
80002c6c:	f1 dc c0 01 	bfextu	r8,r12,0x0,0x1
80002c70:	cf 71       	brne	80002c5e <data_flash_write_page+0x62>

	/*  Check Status Register */
	if ((status & STATUS_ERASE_PROG_ERROR) != 0)
80002c72:	18 97       	mov	r7,r12
80002c74:	e2 17 00 20 	andl	r7,0x20,COH
80002c78:	f9 b7 01 06 	movne	r7,6
80002c7c:	f9 b7 00 07 	moveq	r7,7
		/*  Erase Successful.  */
		return_code = DF_WRITE_COMPLETED;
	}

	/* send WRITE_DISABLE command */
	send_flash_command(WRITE_DISABLE, 0, NULL, 0);
80002c80:	30 09       	mov	r9,0
80002c82:	12 9a       	mov	r10,r9
80002c84:	12 9b       	mov	r11,r9
80002c86:	30 4c       	mov	r12,4
80002c88:	f0 1f 00 04 	mcall	80002c98 <data_flash_write_page+0x9c>

	return return_code;
80002c8c:	c0 28       	rjmp	80002c90 <data_flash_write_page+0x94>
80002c8e:	30 17       	mov	r7,1
}
80002c90:	0e 9c       	mov	r12,r7
80002c92:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80002c96:	00 00       	add	r0,r0
80002c98:	80 00       	ld.sh	r0,r0[0x0]
80002c9a:	2a 00       	sub	r0,-96

80002c9c <data_flash_write_block>:
* ----------  --------  ----------  --------------------------------------------
* 25-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_write_block(U8 *data_ptr, U32 address, U16 data_length)
{
80002c9c:	d4 31       	pushm	r0-r7,lr
80002c9e:	18 94       	mov	r4,r12
80002ca0:	ed da b0 10 	bfexts	r6,r10,0x0,0x10
80002ca4:	16 97       	mov	r7,r11
80002ca6:	30 7c       	mov	r12,7
	df_status_t return_code = DF_WRITE_COMPLETED;
	U32 write_addr = address;
	U16 bytes_remained = data_length;

	while (bytes_remained >= 1 && return_code == DF_WRITE_COMPLETED)
80002ca8:	30 03       	mov	r3,0
80002caa:	06 92       	mov	r2,r3
	{
		if ((write_addr & 0xFF) == 0)
		{
			/* address 256 bytes aligned */

			if (bytes_remained <= DF_PAGE_SIZE)
80002cac:	e0 60 01 00 	mov	r0,256
{
	df_status_t return_code = DF_WRITE_COMPLETED;
	U32 write_addr = address;
	U16 bytes_remained = data_length;

	while (bytes_remained >= 1 && return_code == DF_WRITE_COMPLETED)
80002cb0:	c4 98       	rjmp	80002d42 <data_flash_write_block+0xa6>
	{
		if ((write_addr & 0xFF) == 0)
80002cb2:	eb d7 c0 08 	bfextu	r5,r7,0x0,0x8
80002cb6:	c1 b1       	brne	80002cec <data_flash_write_block+0x50>
		{
			/* address 256 bytes aligned */

			if (bytes_remained <= DF_PAGE_SIZE)
80002cb8:	e0 06 19 00 	cp.h	r6,r0
80002cbc:	e0 8b 00 0a 	brhi	80002cd0 <data_flash_write_block+0x34>
			{
				/* bytes remained less than one page */
				return_code = data_flash_write_page(data_ptr, write_addr, bytes_remained);
80002cc0:	f5 d6 c0 10 	bfextu	r10,r6,0x0,0x10
80002cc4:	0e 9b       	mov	r11,r7
80002cc6:	08 9c       	mov	r12,r4
80002cc8:	f0 1f 00 24 	mcall	80002d58 <data_flash_write_block+0xbc>
80002ccc:	30 06       	mov	r6,0
80002cce:	c3 a8       	rjmp	80002d42 <data_flash_write_block+0xa6>
				bytes_remained = 0;	/* end while loop */
			}
			else /* (bytes_remained > DF_PAGE_SIZE) */
			{
				/* bytes remained more than one page */
				return_code = data_flash_write_page(data_ptr, write_addr, DF_PAGE_SIZE);
80002cd0:	e0 6a 01 00 	mov	r10,256
80002cd4:	0e 9b       	mov	r11,r7
80002cd6:	08 9c       	mov	r12,r4
80002cd8:	f0 1f 00 20 	mcall	80002d58 <data_flash_write_block+0xbc>
				bytes_remained -= DF_PAGE_SIZE;
80002cdc:	ec c6 01 00 	sub	r6,r6,256
80002ce0:	5c 86       	casts.h	r6
				data_ptr += DF_PAGE_SIZE;
80002ce2:	e8 c4 ff 00 	sub	r4,r4,-256
				write_addr += DF_PAGE_SIZE;
80002ce6:	ee c7 ff 00 	sub	r7,r7,-256
80002cea:	c2 c8       	rjmp	80002d42 <data_flash_write_block+0xa6>
		}
		else
		{
			/*(write_addr & 0xFF != 0), address not 256 bytes aligned */

			if (BEYOND_PAGE_BOUNDARY(write_addr, bytes_remained) == TRUE)
80002cec:	f3 d6 c0 10 	bfextu	r9,r6,0x0,0x10
80002cf0:	0e 09       	add	r9,r7
80002cf2:	0e 98       	mov	r8,r7
80002cf4:	e4 18 00 7f 	andh	r8,0x7f
80002cf8:	e0 18 ff 00 	andl	r8,0xff00
80002cfc:	f0 c8 ff 00 	sub	r8,r8,-256
80002d00:	10 39       	cp.w	r9,r8
80002d02:	e0 88 00 19 	brls	80002d34 <data_flash_write_block+0x98>
			{
				/* bytes remained exceed current page, only write data within current page */
				return_code = data_flash_write_page(data_ptr, write_addr, BYTES_TO_NEXT_PAGE_BOUNDARY(write_addr));
80002d06:	0e 91       	mov	r1,r7
80002d08:	5c 51       	castu.b	r1
80002d0a:	e0 6a 01 00 	mov	r10,256
80002d0e:	02 1a       	sub	r10,r1
80002d10:	5c 7a       	castu.h	r10
80002d12:	0e 9b       	mov	r11,r7
80002d14:	08 9c       	mov	r12,r4
80002d16:	f0 1f 00 11 	mcall	80002d58 <data_flash_write_block+0xbc>
				bytes_remained -= BYTES_TO_NEXT_PAGE_BOUNDARY(write_addr);
80002d1a:	ec c6 01 00 	sub	r6,r6,256
80002d1e:	02 06       	add	r6,r1
80002d20:	5c 86       	casts.h	r6
				data_ptr += BYTES_TO_NEXT_PAGE_BOUNDARY(write_addr);
80002d22:	e0 68 01 00 	mov	r8,256
80002d26:	f0 05 01 05 	sub	r5,r8,r5
80002d2a:	0a 04       	add	r4,r5
				write_addr += BYTES_TO_NEXT_PAGE_BOUNDARY(write_addr); /* now became 256 bytes aligned */
80002d2c:	e0 17 ff 00 	andl	r7,0xff00
80002d30:	10 07       	add	r7,r8
80002d32:	c0 88       	rjmp	80002d42 <data_flash_write_block+0xa6>
			}
			else
			{
				/* bytes remained not exceed current page */
				return_code = data_flash_write_page(data_ptr, write_addr, bytes_remained);
80002d34:	f5 d6 c0 10 	bfextu	r10,r6,0x0,0x10
80002d38:	0e 9b       	mov	r11,r7
80002d3a:	08 9c       	mov	r12,r4
80002d3c:	f0 1f 00 07 	mcall	80002d58 <data_flash_write_block+0xbc>
80002d40:	30 06       	mov	r6,0
{
	df_status_t return_code = DF_WRITE_COMPLETED;
	U32 write_addr = address;
	U16 bytes_remained = data_length;

	while (bytes_remained >= 1 && return_code == DF_WRITE_COMPLETED)
80002d42:	e6 06 19 00 	cp.h	r6,r3
80002d46:	5f 19       	srne	r9
80002d48:	58 7c       	cp.w	r12,7
80002d4a:	5f 08       	sreq	r8
80002d4c:	f3 e8 00 08 	and	r8,r9,r8
80002d50:	e4 08 18 00 	cp.b	r8,r2
80002d54:	ca f1       	brne	80002cb2 <data_flash_write_block+0x16>
			}
		}
	}	/* end of while */

	return return_code;
}
80002d56:	d8 32       	popm	r0-r7,pc
80002d58:	80 00       	ld.sh	r0,r0[0x0]
80002d5a:	2b fc       	sub	r12,-65

80002d5c <data_flash_erase_block>:
* ----------  --------  ----------  --------------------------------------------
* 25-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_erase_block(U32 address, df_block_size_t block_size)
{
80002d5c:	eb cd 40 f8 	pushm	r3-r7,lr
80002d60:	18 94       	mov	r4,r12
	U16 erase_commond;
	df_status_t return_code = DF_ERASE_FAIL;
	U16 count = 0; /* to monitor erase time consumption */

	/* check input parameter */
	if (address >= DF_MAX_ADDR)
80002d62:	e0 68 ff fe 	mov	r8,65534
80002d66:	ea 18 00 7f 	orh	r8,0x7f
80002d6a:	10 3c       	cp.w	r12,r8
80002d6c:	e0 88 00 04 	brls	80002d74 <data_flash_erase_block+0x18>
80002d70:	30 17       	mov	r7,1
80002d72:	c3 f8       	rjmp	80002df0 <data_flash_erase_block+0x94>
	{
		return DF_INVALID_PARAM;
	}

	/* determine erase command to be issued */
	if (block_size == DF_BLOCK_4KB)
80002d74:	58 1b       	cp.w	r11,1
80002d76:	c0 31       	brne	80002d7c <data_flash_erase_block+0x20>
80002d78:	32 03       	mov	r3,32
80002d7a:	c0 a8       	rjmp	80002d8e <data_flash_erase_block+0x32>
		erase_commond = BLOCK_ERASE_4KB;
	else if (block_size == DF_BLOCK_32KB)
80002d7c:	58 2b       	cp.w	r11,2
80002d7e:	c0 31       	brne	80002d84 <data_flash_erase_block+0x28>
80002d80:	35 23       	mov	r3,82
80002d82:	c0 68       	rjmp	80002d8e <data_flash_erase_block+0x32>
		erase_commond = BLOCK_ERASE_32KB;
	else if(block_size == DF_BLOCK_64KB)
80002d84:	e0 63 00 d8 	mov	r3,216
80002d88:	58 3b       	cp.w	r11,3
80002d8a:	f9 b3 01 60 	movne	r3,96
		erase_commond = BLOCK_ERASE_64KB;
	else/*(block_size == DF_BLOCK_ALL)*/
		erase_commond = CHIP_ERASE;

	while(status = send_flash_command(READ_STATUS_REG, 0, NULL, 0) == STATUS_BUSY);
80002d8e:	30 06       	mov	r6,0
80002d90:	30 55       	mov	r5,5
80002d92:	30 17       	mov	r7,1
80002d94:	0c 99       	mov	r9,r6
80002d96:	0c 9a       	mov	r10,r6
80002d98:	0c 9b       	mov	r11,r6
80002d9a:	0a 9c       	mov	r12,r5
80002d9c:	f0 1f 00 17 	mcall	80002df8 <data_flash_erase_block+0x9c>
80002da0:	ee 0c 19 00 	cp.h	r12,r7
80002da4:	cf 80       	breq	80002d94 <data_flash_erase_block+0x38>
	//{
		//return DF_DEVICE_BUSY;
	//}

	/* send WRITE_ENABLE command */
	send_flash_command(WRITE_ENABLE, 0, NULL, 0);
80002da6:	30 09       	mov	r9,0
80002da8:	12 9a       	mov	r10,r9
80002daa:	12 9b       	mov	r11,r9
80002dac:	30 6c       	mov	r12,6
80002dae:	f0 1f 00 13 	mcall	80002df8 <data_flash_erase_block+0x9c>

	/* send BLOCK_ERASE command */
	send_flash_command(erase_commond, address, NULL, 0);
80002db2:	30 09       	mov	r9,0
80002db4:	12 9a       	mov	r10,r9
80002db6:	08 9b       	mov	r11,r4
80002db8:	06 9c       	mov	r12,r3
80002dba:	f0 1f 00 10 	mcall	80002df8 <data_flash_erase_block+0x9c>
	do {
		status = send_flash_command(READ_STATUS_REG, 0, NULL, 0);
80002dbe:	30 06       	mov	r6,0
80002dc0:	30 57       	mov	r7,5
80002dc2:	0c 99       	mov	r9,r6
80002dc4:	0c 9a       	mov	r10,r6
80002dc6:	0c 9b       	mov	r11,r6
80002dc8:	0e 9c       	mov	r12,r7
80002dca:	f0 1f 00 0c 	mcall	80002df8 <data_flash_erase_block+0x9c>
		count++;
	} while((status & STATUS_BUSY) != 0);
80002dce:	5c 7c       	castu.h	r12
80002dd0:	f1 dc c0 01 	bfextu	r8,r12,0x0,0x1
80002dd4:	cf 71       	brne	80002dc2 <data_flash_erase_block+0x66>

	/*  Check Status Register */
	if ((status & STATUS_ERASE_PROG_ERROR) != 0)
80002dd6:	18 97       	mov	r7,r12
80002dd8:	e2 17 00 20 	andl	r7,0x20,COH
80002ddc:	f9 b7 01 04 	movne	r7,4
80002de0:	f9 b7 00 05 	moveq	r7,5
		/*  Erase Successful.  */
		return_code = DF_ERASE_COMPLETED;
	}

	/* send WRITE_DISABLE command */
	send_flash_command(WRITE_DISABLE, 0, NULL, 0);
80002de4:	30 09       	mov	r9,0
80002de6:	12 9a       	mov	r10,r9
80002de8:	12 9b       	mov	r11,r9
80002dea:	30 4c       	mov	r12,4
80002dec:	f0 1f 00 03 	mcall	80002df8 <data_flash_erase_block+0x9c>

	return return_code;
}
80002df0:	0e 9c       	mov	r12,r7
80002df2:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80002df6:	00 00       	add	r0,r0
80002df8:	80 00       	ld.sh	r0,r0[0x0]
80002dfa:	2a 00       	sub	r0,-96

80002dfc <data_flash_write>:
* ----------  --------  ----------  --------------------------------------------
* 25-Fri-17   Edwards    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_write(U8 *data_ptr, U32 address, U16 data_length)
{
80002dfc:	d4 31       	pushm	r0-r7,lr
80002dfe:	20 3d       	sub	sp,12
80002e00:	50 0c       	stdsp	sp[0x0],r12
80002e02:	16 91       	mov	r1,r11
80002e04:	14 95       	mov	r5,r10
	U16 secremain;
	U16 i;
	df_status_t return_code = DF_OK;

	secpos	=	address/4096;//扇区地址 0~2047 for AT25DF641 
	secoff	=	address%4096;//在扇区内的偏移
80002e06:	f5 db c0 0c 	bfextu	r10,r11,0x0,0xc
80002e0a:	50 1a       	stdsp	sp[0x4],r10
	secremain	=	4096-secoff;//扇区剩余空间大小
80002e0c:	e0 69 10 00 	mov	r9,4096
80002e10:	f2 0a 01 07 	sub	r7,r9,r10
80002e14:	ea 07 19 00 	cp.h	r7,r5
80002e18:	ea 07 17 b0 	movhi	r7,r5
80002e1c:	5c 87       	casts.h	r7
80002e1e:	16 92       	mov	r2,r11
80002e20:	e0 12 f0 00 	andl	r2,0xf000
	if(data_length <= secremain)secremain = data_length;//不大于4096个字节
	while(1)
	{
		data_flash_read_block(secpos*4096, 4096, FLASH_BUF);//读出整个扇区的内容
80002e24:	4a e4       	lddpc	r4,80002edc <data_flash_write+0xe0>
		for(i=0; i<secremain; i++)//校验数据
		{
			if(FLASH_BUF[secoff+i]!=0XFF)break;//需要擦除
80002e26:	3f f6       	mov	r6,-1
* Date        Name      Prob#       Description
* ----------  --------  ----------  --------------------------------------------
* 25-Fri-17   Edwards    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_write(U8 *data_ptr, U32 address, U16 data_length)
80002e28:	e8 c8 ff ff 	sub	r8,r4,-1
80002e2c:	50 28       	stdsp	sp[0x8],r8
			secpos++;//扇区地址增1
			secoff=0;//偏移位置为0

			data_ptr+=secremain;  //指针偏移
			address+=secremain;//写地址偏移
			data_length-=secremain;				//字节数递减
80002e2e:	12 90       	mov	r0,r9
	secoff	=	address%4096;//在扇区内的偏移
	secremain	=	4096-secoff;//扇区剩余空间大小
	if(data_length <= secremain)secremain = data_length;//不大于4096个字节
	while(1)
	{
		data_flash_read_block(secpos*4096, 4096, FLASH_BUF);//读出整个扇区的内容
80002e30:	08 9a       	mov	r10,r4
80002e32:	e0 6b 10 00 	mov	r11,4096
80002e36:	04 9c       	mov	r12,r2
80002e38:	f0 1f 00 2a 	mcall	80002ee0 <data_flash_write+0xe4>
		for(i=0; i<secremain; i++)//校验数据
80002e3c:	58 07       	cp.w	r7,0
80002e3e:	c3 00       	breq	80002e9e <data_flash_write+0xa2>
		{
			if(FLASH_BUF[secoff+i]!=0XFF)break;//需要擦除
80002e40:	40 13       	lddsp	r3,sp[0x4]
80002e42:	5c 73       	castu.h	r3
80002e44:	e8 03 07 08 	ld.ub	r8,r4[r3]
80002e48:	ec 08 18 00 	cp.b	r8,r6
80002e4c:	c1 11       	brne	80002e6e <data_flash_write+0x72>
80002e4e:	e6 c9 ff ff 	sub	r9,r3,-1
80002e52:	08 09       	add	r9,r4
80002e54:	30 08       	mov	r8,0
80002e56:	c0 58       	rjmp	80002e60 <data_flash_write+0x64>
80002e58:	13 3a       	ld.ub	r10,r9++
80002e5a:	ec 0a 18 00 	cp.b	r10,r6
80002e5e:	c0 81       	brne	80002e6e <data_flash_write+0x72>
	secremain	=	4096-secoff;//扇区剩余空间大小
	if(data_length <= secremain)secremain = data_length;//不大于4096个字节
	while(1)
	{
		data_flash_read_block(secpos*4096, 4096, FLASH_BUF);//读出整个扇区的内容
		for(i=0; i<secremain; i++)//校验数据
80002e60:	2f f8       	sub	r8,-1
80002e62:	5c 88       	casts.h	r8
80002e64:	f0 07 19 00 	cp.h	r7,r8
80002e68:	fe 9b ff f8 	brhi	80002e58 <data_flash_write+0x5c>
80002e6c:	c1 98       	rjmp	80002e9e <data_flash_write+0xa2>
		{
			if(FLASH_BUF[secoff+i]!=0XFF)break;//需要擦除
		}
		if(i < secremain)//需要擦除
		{
			return_code = data_flash_erase_block(secpos*4096, DF_BLOCK_4KB);//擦除这个扇区
80002e6e:	30 1b       	mov	r11,1
80002e70:	04 9c       	mov	r12,r2
80002e72:	f0 1f 00 1d 	mcall	80002ee4 <data_flash_write+0xe8>
80002e76:	40 08       	lddsp	r8,sp[0x0]
80002e78:	08 03       	add	r3,r4
* Date        Name      Prob#       Description
* ----------  --------  ----------  --------------------------------------------
* 25-Fri-17   Edwards    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_write(U8 *data_ptr, U32 address, U16 data_length)
80002e7a:	40 2a       	lddsp	r10,sp[0x8]
80002e7c:	40 19       	lddsp	r9,sp[0x4]
80002e7e:	12 0a       	add	r10,r9
80002e80:	0e 99       	mov	r9,r7
80002e82:	20 19       	sub	r9,1
80002e84:	5c 79       	castu.h	r9
80002e86:	12 0a       	add	r10,r9
		if(i < secremain)//需要擦除
		{
			return_code = data_flash_erase_block(secpos*4096, DF_BLOCK_4KB);//擦除这个扇区
			for(i=0; i<secremain; i++)	   //复制
			{
				FLASH_BUF[i+secoff]=data_ptr[i];
80002e88:	11 39       	ld.ub	r9,r8++
80002e8a:	06 c9       	st.b	r3++,r9
			if(FLASH_BUF[secoff+i]!=0XFF)break;//需要擦除
		}
		if(i < secremain)//需要擦除
		{
			return_code = data_flash_erase_block(secpos*4096, DF_BLOCK_4KB);//擦除这个扇区
			for(i=0; i<secremain; i++)	   //复制
80002e8c:	14 33       	cp.w	r3,r10
80002e8e:	cf d1       	brne	80002e88 <data_flash_write+0x8c>
			{
				FLASH_BUF[i+secoff]=data_ptr[i];
			}
			return_code = data_flash_write_block(FLASH_BUF, secpos*4096, 4096);//写入整个扇区
80002e90:	e0 6a 10 00 	mov	r10,4096
80002e94:	04 9b       	mov	r11,r2
80002e96:	08 9c       	mov	r12,r4
80002e98:	f0 1f 00 14 	mcall	80002ee8 <data_flash_write+0xec>
80002e9c:	c0 78       	rjmp	80002eaa <data_flash_write+0xae>

		}
		else 
		{
			return_code = data_flash_write_block(data_ptr, address, secremain);//写已经擦除了的,直接写入扇区剩余区间.
80002e9e:	0e 9a       	mov	r10,r7
80002ea0:	5c 7a       	castu.h	r10
80002ea2:	02 9b       	mov	r11,r1
80002ea4:	40 0c       	lddsp	r12,sp[0x0]
80002ea6:	f0 1f 00 11 	mcall	80002ee8 <data_flash_write+0xec>
80002eaa:	e4 c2 f0 00 	sub	r2,r2,-4096
		}
		if(data_length==secremain)break;//写入结束了
80002eae:	0e 98       	mov	r8,r7
80002eb0:	ee 05 19 00 	cp.h	r5,r7
80002eb4:	c1 20       	breq	80002ed8 <data_flash_write+0xdc>
		else//写入未结束
		{
			secpos++;//扇区地址增1
			secoff=0;//偏移位置为0

			data_ptr+=secremain;  //指针偏移
80002eb6:	5c 78       	castu.h	r8
80002eb8:	40 0a       	lddsp	r10,sp[0x0]
80002eba:	10 0a       	add	r10,r8
80002ebc:	50 0a       	stdsp	sp[0x0],r10
			address+=secremain;//写地址偏移
80002ebe:	10 01       	add	r1,r8
			data_length-=secremain;				//字节数递减
80002ec0:	0e 15       	sub	r5,r7
80002ec2:	5c 85       	casts.h	r5
80002ec4:	e0 05 19 00 	cp.h	r5,r0
80002ec8:	ea 07 17 80 	movls	r7,r5
80002ecc:	e0 07 17 b0 	movhi	r7,r0
80002ed0:	5c 87       	casts.h	r7
80002ed2:	30 09       	mov	r9,0
80002ed4:	50 19       	stdsp	sp[0x4],r9
80002ed6:	ca db       	rjmp	80002e30 <data_flash_write+0x34>
		}
	}
	
	return return_code;
	
}
80002ed8:	2f dd       	sub	sp,-12
80002eda:	d8 32       	popm	r0-r7,pc
80002edc:	00 00       	add	r0,r0
80002ede:	0f a0       	ld.ub	r0,r7[0x2]
80002ee0:	80 00       	ld.sh	r0,r0[0x0]
80002ee2:	2b c4       	sub	r4,-68
80002ee4:	80 00       	ld.sh	r0,r0[0x0]
80002ee6:	2d 5c       	sub	r12,-43
80002ee8:	80 00       	ld.sh	r0,r0[0x0]
80002eea:	2c 9c       	sub	r12,-55

80002eec <W25Q64_SPI_SetSpeed>:




void W25Q64_SPI_SetSpeed(U16 SPI_BaudRatePrescaler)
{
80002eec:	d4 01       	pushm	lr
	spi->csr1 = (spi->csr1 & (U16)0x00FF) |SPI_BaudRatePrescaler;
80002eee:	48 78       	lddpc	r8,80002f08 <W25Q64_SPI_SetSpeed+0x1c>
80002ef0:	70 09       	ld.w	r9,r8[0x0]
80002ef2:	72 da       	ld.w	r10,r9[0x34]
80002ef4:	5c 7c       	castu.h	r12
80002ef6:	f5 da c0 08 	bfextu	r10,r10,0x0,0x8
80002efa:	f9 ea 10 0a 	or	r10,r12,r10
80002efe:	93 da       	st.w	r9[0x34],r10

	spi_enable(spi); /*!< W25Q64_SPI enable */
80002f00:	70 0c       	ld.w	r12,r8[0x0]
80002f02:	f0 1f 00 03 	mcall	80002f0c <W25Q64_SPI_SetSpeed+0x20>
	
	
}
80002f06:	d8 02       	popm	pc
80002f08:	00 00       	add	r0,r0
80002f0a:	1f a0       	ld.ub	r0,pc[0x2]
80002f0c:	80 00       	ld.sh	r0,r0[0x0]
80002f0e:	4c 10       	lddpc	r0,80003010 <data_flash_init+0xf0>

80002f10 <W25Q64_SPI_SetSpeedHi>:
{
	W25Q64_SPI_SetSpeed(0x0200);//baudDiv=4
	
}
void W25Q64_SPI_SetSpeedHi(void)
{
80002f10:	d4 01       	pushm	lr
	
	W25Q64_SPI_SetSpeed(0x0100);//baudDiv=1
80002f12:	e0 6c 01 00 	mov	r12,256
80002f16:	f0 1f 00 02 	mcall	80002f1c <W25Q64_SPI_SetSpeedHi+0xc>
	
}
80002f1a:	d8 02       	popm	pc
80002f1c:	80 00       	ld.sh	r0,r0[0x0]
80002f1e:	2e ec       	sub	r12,-18

80002f20 <data_flash_init>:
* ----------  --------  ----------  --------------------------------------------
* 10-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
void data_flash_init(void)
{
80002f20:	eb cd 40 c0 	pushm	r6-r7,lr
80002f24:	20 5d       	sub	sp,20
		.spck_delay   = 0,
		.trans_delay  = 0,
		.stay_act     = 1,
		.spi_mode     = 1,//0,0 针对不同的存储芯片，注意模式
		.modfdis      = 1
	};
80002f26:	4b a8       	lddpc	r8,8000300c <data_flash_init+0xec>
80002f28:	fa c6 ff fc 	sub	r6,sp,-4
80002f2c:	f0 ea 00 00 	ld.d	r10,r8[0]
80002f30:	ec eb 00 00 	st.d	r6[0],r10
80002f34:	f0 e8 00 08 	ld.d	r8,r8[8]
80002f38:	ec e9 00 08 	st.d	r6[8],r8

	// Assign I/Os to SPI.
	gpio_enable_module(DF_SPI_GPIO_MAP, sizeof(DF_SPI_GPIO_MAP) / sizeof(DF_SPI_GPIO_MAP[0]));
80002f3c:	30 4b       	mov	r11,4
80002f3e:	4b 5c       	lddpc	r12,80003010 <data_flash_init+0xf0>
80002f40:	f0 1f 00 35 	mcall	80003014 <data_flash_init+0xf4>

	spi = &AVR32_SPI;
80002f44:	4b 57       	lddpc	r7,80003018 <data_flash_init+0xf8>
80002f46:	fe 7c 24 00 	mov	r12,-56320
80002f4a:	8f 0c       	st.w	r7[0x0],r12

	// Initialize as master.
	spi_initMaster(spi, &spiOptions);
80002f4c:	0c 9b       	mov	r11,r6
80002f4e:	f0 1f 00 34 	mcall	8000301c <data_flash_init+0xfc>

	// Set selection mode: variable_ps, pcs_decode, delay.
	spi_selectionMode(spi, 0, 0, 0);
80002f52:	30 09       	mov	r9,0
80002f54:	12 9a       	mov	r10,r9
80002f56:	12 9b       	mov	r11,r9
80002f58:	6e 0c       	ld.w	r12,r7[0x0]
80002f5a:	f0 1f 00 32 	mcall	80003020 <data_flash_init+0x100>

	// Enable SPI.
	spi_enable(spi);
80002f5e:	6e 0c       	ld.w	r12,r7[0x0]
80002f60:	f0 1f 00 31 	mcall	80003024 <data_flash_init+0x104>

	// Initialize data flash with SPI clock PBA.
	if (spi_setupChipReg(spi, &spiOptions, 2*12000000) != SPI_OK)
80002f64:	e0 6a 36 00 	mov	r10,13824
80002f68:	ea 1a 01 6e 	orh	r10,0x16e
80002f6c:	0c 9b       	mov	r11,r6
80002f6e:	6e 0c       	ld.w	r12,r7[0x0]
80002f70:	f0 1f 00 2e 	mcall	80003028 <data_flash_init+0x108>
80002f74:	c0 50       	breq	80002f7e <data_flash_init+0x5e>
	{
		data_flash_failure = FATAL_ERROR_DATA_FLASH_SPI_INIT;
80002f76:	30 29       	mov	r9,2
80002f78:	4a d8       	lddpc	r8,8000302c <data_flash_init+0x10c>
80002f7a:	b0 89       	st.b	r8[0x0],r9
		return;
80002f7c:	c4 58       	rjmp	80003006 <data_flash_init+0xe6>
* 10-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
static Bool data_flash_check_device_id(void)
{
	U16 manufacturer_device_id[2] = {0x5A5A, 0x5A5A};
80002f7e:	1a 96       	mov	r6,sp
80002f80:	30 4a       	mov	r10,4
80002f82:	4a cb       	lddpc	r11,80003030 <data_flash_init+0x110>
80002f84:	1a 9c       	mov	r12,sp
80002f86:	f0 1f 00 2c 	mcall	80003034 <data_flash_init+0x114>

	/* DF memory check. */
	/* Select the DF memory to check. */
	spi_selectChip(spi, DF_SPI_PCS_1);
80002f8a:	4a 47       	lddpc	r7,80003018 <data_flash_init+0xf8>
80002f8c:	30 1b       	mov	r11,1
80002f8e:	6e 0c       	ld.w	r12,r7[0x0]
80002f90:	f0 1f 00 2a 	mcall	80003038 <data_flash_init+0x118>

	/* Send the Manufacturer/Device ID Read command. */
	spi_write(spi, READ_M_D_ID);	
80002f94:	e0 6b 00 90 	mov	r11,144
80002f98:	6e 0c       	ld.w	r12,r7[0x0]
80002f9a:	f0 1f 00 29 	mcall	8000303c <data_flash_init+0x11c>
	spi_write_zero();
80002f9e:	30 0b       	mov	r11,0
80002fa0:	6e 0c       	ld.w	r12,r7[0x0]
80002fa2:	f0 1f 00 27 	mcall	8000303c <data_flash_init+0x11c>
	spi_write_zero();
80002fa6:	30 0b       	mov	r11,0
80002fa8:	6e 0c       	ld.w	r12,r7[0x0]
80002faa:	f0 1f 00 25 	mcall	8000303c <data_flash_init+0x11c>
	spi_write_zero();
80002fae:	30 0b       	mov	r11,0
80002fb0:	6e 0c       	ld.w	r12,r7[0x0]
80002fb2:	f0 1f 00 23 	mcall	8000303c <data_flash_init+0x11c>

	/* Send 2 dummy byte to read the status register. */
	
	spi_write_dummy();
80002fb6:	e0 6b 00 ff 	mov	r11,255
80002fba:	6e 0c       	ld.w	r12,r7[0x0]
80002fbc:	f0 1f 00 20 	mcall	8000303c <data_flash_init+0x11c>
	spi_read(spi, &manufacturer_device_id[0]);
80002fc0:	1a 9b       	mov	r11,sp
80002fc2:	6e 0c       	ld.w	r12,r7[0x0]
80002fc4:	f0 1f 00 1f 	mcall	80003040 <data_flash_init+0x120>
	
	spi_write_dummy();
80002fc8:	e0 6b 00 ff 	mov	r11,255
80002fcc:	6e 0c       	ld.w	r12,r7[0x0]
80002fce:	f0 1f 00 1c 	mcall	8000303c <data_flash_init+0x11c>
	spi_read(spi, &manufacturer_device_id[1]);
80002fd2:	fa cb ff fe 	sub	r11,sp,-2
80002fd6:	6e 0c       	ld.w	r12,r7[0x0]
80002fd8:	f0 1f 00 1a 	mcall	80003040 <data_flash_init+0x120>

	/* Unselect the checked DF memory. */
	spi_unselectChip(spi, DF_SPI_PCS_1);
80002fdc:	30 1b       	mov	r11,1
80002fde:	6e 0c       	ld.w	r12,r7[0x0]
80002fe0:	f0 1f 00 19 	mcall	80003044 <data_flash_init+0x124>

	/* Unexpected device ID. */
    if ((manufacturer_device_id[0] != 0xEF) || (manufacturer_device_id[1] != 0x16))
80002fe4:	e0 68 00 ef 	mov	r8,239
80002fe8:	9a 09       	ld.sh	r9,sp[0x0]
80002fea:	f0 09 19 00 	cp.h	r9,r8
80002fee:	c0 61       	brne	80002ffa <data_flash_init+0xda>
80002ff0:	31 68       	mov	r8,22
80002ff2:	9a 19       	ld.sh	r9,sp[0x2]
80002ff4:	f0 09 19 00 	cp.h	r9,r8
80002ff8:	c0 50       	breq	80003002 <data_flash_init+0xe2>
		return;
	}
	 
	if (data_flash_check_device_id() != TRUE)//check W25Q64 ID
	{
		data_flash_failure = FATAL_ERROR_DATA_FLASH_READ_ID;
80002ffa:	30 39       	mov	r9,3
80002ffc:	48 c8       	lddpc	r8,8000302c <data_flash_init+0x10c>
80002ffe:	b0 89       	st.b	r8[0x0],r9
		return;
80003000:	c0 38       	rjmp	80003006 <data_flash_init+0xe6>
	}

	W25Q64_SPI_SetSpeedHi();
80003002:	f0 1f 00 12 	mcall	80003048 <data_flash_init+0x128>
	//send_flash_command(WRITE_ENABLE, 0, NULL, 0);
	//send_flash_command(WRITE_STATUS_REG_BYTE_1, 0, NULL, 0);
	//status = send_flash_command(READ_STATUS_REG, 0, NULL, 0);
	
	return;
}
80003006:	2f bd       	sub	sp,-20
80003008:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000300c:	80 00       	ld.sh	r0,r0[0x0]
8000300e:	c9 5c       	rcall	80003138 <rtc_irq+0x6c>
80003010:	80 00       	ld.sh	r0,r0[0x0]
80003012:	c9 3c       	rcall	80003138 <rtc_irq+0x6c>
80003014:	80 00       	ld.sh	r0,r0[0x0]
80003016:	47 3c       	lddsp	r12,sp[0x1cc]
80003018:	00 00       	add	r0,r0
8000301a:	1f a0       	ld.ub	r0,pc[0x2]
8000301c:	80 00       	ld.sh	r0,r0[0x0]
8000301e:	4b ac       	lddpc	r12,80003104 <rtc_irq+0x38>
80003020:	80 00       	ld.sh	r0,r0[0x0]
80003022:	4b e4       	lddpc	r4,80003118 <rtc_irq+0x4c>
80003024:	80 00       	ld.sh	r0,r0[0x0]
80003026:	4c 10       	lddpc	r0,80003128 <rtc_irq+0x5c>
80003028:	80 00       	ld.sh	r0,r0[0x0]
8000302a:	4c 54       	lddpc	r4,8000313c <rtc_irq+0x70>
8000302c:	00 00       	add	r0,r0
8000302e:	0a 44       	or	r4,r5
80003030:	80 00       	ld.sh	r0,r0[0x0]
80003032:	c9 6c       	rcall	8000315e <rtc_irq+0x92>
80003034:	80 00       	ld.sh	r0,r0[0x0]
80003036:	69 da       	ld.w	r10,r4[0x74]
80003038:	80 00       	ld.sh	r0,r0[0x0]
8000303a:	4d 7c       	lddpc	r12,80003194 <rtc_irq+0xc8>
8000303c:	80 00       	ld.sh	r0,r0[0x0]
8000303e:	4c 16       	lddpc	r6,80003140 <rtc_irq+0x74>
80003040:	80 00       	ld.sh	r0,r0[0x0]
80003042:	4c 32       	lddpc	r2,8000314c <rtc_irq+0x80>
80003044:	80 00       	ld.sh	r0,r0[0x0]
80003046:	4d 3c       	lddpc	r12,80003190 <rtc_irq+0xc4>
80003048:	80 00       	ld.sh	r0,r0[0x0]
8000304a:	2f 10       	sub	r0,-15

8000304c <xg_rtc_init>:
}



void xg_rtc_init(void)
{
8000304c:	d4 01       	pushm	lr
	
	// Disable all interrupts. */
	Disable_global_interrupt();
8000304e:	d3 03       	ssrf	0x10
	  
	// Register the RTC interrupt handler to the interrupt controller.
	INTC_register_interrupt(&rtc_irq, AVR32_RTC_IRQ, AVR32_INTC_INT0);
80003050:	30 0a       	mov	r10,0
80003052:	32 8b       	mov	r11,40
80003054:	49 5c       	lddpc	r12,800030a8 <xg_rtc_init+0x5c>
80003056:	f0 1f 00 16 	mcall	800030ac <xg_rtc_init+0x60>

	// Initialize the RTC
	//if (!rtc_init(&AVR32_RTC, RTC_OSC_RC, RTC_PSEL_RC_1_76HZ))
	if (!rtc_init(&AVR32_RTC, RTC_OSC_32KHZ, RTC_PSEL_32KHZ_1HZ))
8000305a:	30 ea       	mov	r10,14
8000305c:	30 1b       	mov	r11,1
8000305e:	fe 7c 0d 00 	mov	r12,-62208
80003062:	f0 1f 00 14 	mcall	800030b0 <xg_rtc_init+0x64>
80003066:	c0 41       	brne	8000306e <xg_rtc_init+0x22>
	{
		log("Error initializing the RTC\r\n");
80003068:	49 3c       	lddpc	r12,800030b4 <xg_rtc_init+0x68>
8000306a:	f0 1f 00 14 	mcall	800030b8 <xg_rtc_init+0x6c>
	}
	// Set top value to 0 to generate an interrupt every seconds */
	rtc_set_top_value(&AVR32_RTC, 0);
8000306e:	30 0b       	mov	r11,0
80003070:	fe 7c 0d 00 	mov	r12,-62208
80003074:	f0 1f 00 12 	mcall	800030bc <xg_rtc_init+0x70>
	// Enable the interrupts
	rtc_enable_interrupt(&AVR32_RTC);
80003078:	fe 7c 0d 00 	mov	r12,-62208
8000307c:	f0 1f 00 11 	mcall	800030c0 <xg_rtc_init+0x74>
	// Enable the RTC
	rtc_enable(&AVR32_RTC);
80003080:	fe 7c 0d 00 	mov	r12,-62208
80003084:	f0 1f 00 10 	mcall	800030c4 <xg_rtc_init+0x78>

	Current_time.Year		= 16;
80003088:	49 08       	lddpc	r8,800030c8 <xg_rtc_init+0x7c>
8000308a:	31 09       	mov	r9,16
8000308c:	b0 89       	st.b	r8[0x0],r9
	Current_time.Month		= 2;
8000308e:	30 29       	mov	r9,2
80003090:	b0 99       	st.b	r8[0x1],r9
	Current_time.Day		= 29;
80003092:	31 d9       	mov	r9,29
80003094:	b0 a9       	st.b	r8[0x2],r9
	Current_time.Hour		= 23;
80003096:	31 79       	mov	r9,23
80003098:	b0 b9       	st.b	r8[0x3],r9
	Current_time.Minute		= 59;
8000309a:	33 b9       	mov	r9,59
8000309c:	b0 c9       	st.b	r8[0x4],r9
	Current_time.Second		= 40;
8000309e:	32 89       	mov	r9,40
800030a0:	b0 d9       	st.b	r8[0x5],r9
	
	// Enable global interrupts
	Enable_global_interrupt();
800030a2:	d5 03       	csrf	0x10
	  
	//RTC_Test();	

}
800030a4:	d8 02       	popm	pc
800030a6:	00 00       	add	r0,r0
800030a8:	80 00       	ld.sh	r0,r0[0x0]
800030aa:	30 cc       	mov	r12,12
800030ac:	80 00       	ld.sh	r0,r0[0x0]
800030ae:	47 c0       	lddsp	r0,sp[0x1f0]
800030b0:	80 00       	ld.sh	r0,r0[0x0]
800030b2:	4b 0c       	lddpc	r12,80003170 <rtc_irq+0xa4>
800030b4:	80 00       	ld.sh	r0,r0[0x0]
800030b6:	c9 70       	breq	80002fe4 <data_flash_init+0xc4>
800030b8:	80 00       	ld.sh	r0,r0[0x0]
800030ba:	62 b8       	ld.w	r8,r1[0x2c]
800030bc:	80 00       	ld.sh	r0,r0[0x0]
800030be:	4a c8       	lddpc	r8,8000316c <rtc_irq+0xa0>
800030c0:	80 00       	ld.sh	r0,r0[0x0]
800030c2:	4a c0       	lddpc	r0,80003170 <rtc_irq+0xa4>
800030c4:	80 00       	ld.sh	r0,r0[0x0]
800030c6:	4a 9c       	lddpc	r12,80003168 <rtc_irq+0x9c>
800030c8:	00 00       	add	r0,r0
800030ca:	0d 18       	ld.sh	r8,r6++

800030cc <rtc_irq>:
/* RTC Interrupt  */
#pragma handler = AVR32_RTC_IRQ_GROUP, 1
__interrupt
#endif
void rtc_irq(void)
{
800030cc:	d4 01       	pushm	lr
	U8 T,K;
	U32 T16,K16;
	// Increment the minutes counter
	//sec++;
	
	Current_time.Second++;
800030ce:	4b 98       	lddpc	r8,800031b0 <rtc_irq+0xe4>
800030d0:	11 d9       	ld.ub	r9,r8[0x5]
800030d2:	2f f9       	sub	r9,-1
800030d4:	b0 d9       	st.b	r8[0x5],r9
	if(Current_time.Second>=60)
800030d6:	11 d9       	ld.ub	r9,r8[0x5]
800030d8:	33 b8       	mov	r8,59
800030da:	f0 09 18 00 	cp.b	r9,r8
800030de:	e0 88 00 5f 	brls	8000319c <rtc_irq+0xd0>
	{
		Current_time.Second =0;
800030e2:	4b 48       	lddpc	r8,800031b0 <rtc_irq+0xe4>
800030e4:	30 09       	mov	r9,0
800030e6:	b0 d9       	st.b	r8[0x5],r9
		Current_time.Minute++;
800030e8:	11 c9       	ld.ub	r9,r8[0x4]
800030ea:	2f f9       	sub	r9,-1
800030ec:	b0 c9       	st.b	r8[0x4],r9
		if(Current_time.Minute>=60)
800030ee:	11 c9       	ld.ub	r9,r8[0x4]
800030f0:	33 b8       	mov	r8,59
800030f2:	f0 09 18 00 	cp.b	r9,r8
800030f6:	e0 88 00 53 	brls	8000319c <rtc_irq+0xd0>
		{
			Current_time.Minute=0;
800030fa:	4a e8       	lddpc	r8,800031b0 <rtc_irq+0xe4>
800030fc:	30 09       	mov	r9,0
800030fe:	b0 c9       	st.b	r8[0x4],r9
			Current_time.Hour++;
80003100:	11 b9       	ld.ub	r9,r8[0x3]
80003102:	2f f9       	sub	r9,-1
80003104:	b0 b9       	st.b	r8[0x3],r9
			if (Current_time.Hour>=24)
80003106:	11 b9       	ld.ub	r9,r8[0x3]
80003108:	31 78       	mov	r8,23
8000310a:	f0 09 18 00 	cp.b	r9,r8
8000310e:	e0 88 00 47 	brls	8000319c <rtc_irq+0xd0>
			{
				Current_time.Hour=0;
80003112:	4a 88       	lddpc	r8,800031b0 <rtc_irq+0xe4>
80003114:	30 09       	mov	r9,0
80003116:	b0 b9       	st.b	r8[0x3],r9
				K16=(Current_time.Year&0x03)?365:366;				//判断当年是否为闰年,并获取当年的总天数（此算法时间起点为2000年）
80003118:	11 88       	ld.ub	r8,r8[0x0]
8000311a:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
8000311e:	e0 69 01 6e 	mov	r9,366
80003122:	e0 6a 01 6d 	mov	r10,365
80003126:	f4 08 17 10 	movne	r8,r10
8000312a:	f2 08 17 00 	moveq	r8,r9
				K16-=337;											//计算当年二月份天数
				//统计当月天数				
				K=(Current_time.Month==2)?K16:(((Current_time.Month+(Current_time.Month>>3))&0x01)+30);			
8000312e:	4a 19       	lddpc	r9,800031b0 <rtc_irq+0xe4>
80003130:	13 9a       	ld.ub	r10,r9[0x1]
80003132:	30 29       	mov	r9,2
80003134:	f2 0a 18 00 	cp.b	r10,r9
80003138:	c0 b0       	breq	8000314e <rtc_irq+0x82>
8000313a:	49 e8       	lddpc	r8,800031b0 <rtc_irq+0xe4>
8000313c:	11 99       	ld.ub	r9,r8[0x1]
8000313e:	11 9a       	ld.ub	r10,r8[0x1]
80003140:	a3 9a       	lsr	r10,0x3
80003142:	12 0a       	add	r10,r9
80003144:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
80003148:	2e 2a       	sub	r10,-30
8000314a:	5c 5a       	castu.b	r10
8000314c:	c0 58       	rjmp	80003156 <rtc_irq+0x8a>
8000314e:	f0 c8 01 51 	sub	r8,r8,337
80003152:	f5 d8 c0 08 	bfextu	r10,r8,0x0,0x8
				Current_time.Day++;
80003156:	49 78       	lddpc	r8,800031b0 <rtc_irq+0xe4>
80003158:	11 a9       	ld.ub	r9,r8[0x2]
8000315a:	2f f9       	sub	r9,-1
8000315c:	b0 a9       	st.b	r8[0x2],r9
				if(Current_time.Day>K)
8000315e:	11 a8       	ld.ub	r8,r8[0x2]
80003160:	f0 0a 18 00 	cp.b	r10,r8
80003164:	c1 c2       	brcc	8000319c <rtc_irq+0xd0>
				{	
					Current_time.Day = 1;//重置到下月1号
80003166:	49 38       	lddpc	r8,800031b0 <rtc_irq+0xe4>
80003168:	30 19       	mov	r9,1
8000316a:	b0 a9       	st.b	r8[0x2],r9
					Current_time.Month++;
8000316c:	11 99       	ld.ub	r9,r8[0x1]
8000316e:	2f f9       	sub	r9,-1
80003170:	b0 99       	st.b	r8[0x1],r9
					if(Current_time.Month>12)
80003172:	11 99       	ld.ub	r9,r8[0x1]
80003174:	30 c8       	mov	r8,12
80003176:	f0 09 18 00 	cp.b	r9,r8
8000317a:	e0 88 00 11 	brls	8000319c <rtc_irq+0xd0>
					{
						Current_time.Month = 1;//重置到下一年的第一个月
8000317e:	48 d8       	lddpc	r8,800031b0 <rtc_irq+0xe4>
80003180:	30 19       	mov	r9,1
80003182:	b0 99       	st.b	r8[0x1],r9
						Current_time.Year++;
80003184:	11 89       	ld.ub	r9,r8[0x0]
80003186:	2f f9       	sub	r9,-1
80003188:	b0 89       	st.b	r8[0x0],r9
						if (Current_time.Year>150)Current_time.Year=0;//重置年份											
8000318a:	11 89       	ld.ub	r9,r8[0x0]
8000318c:	39 68       	mov	r8,-106
8000318e:	f0 09 18 00 	cp.b	r9,r8
80003192:	e0 88 00 05 	brls	8000319c <rtc_irq+0xd0>
80003196:	30 09       	mov	r9,0
80003198:	48 68       	lddpc	r8,800031b0 <rtc_irq+0xe4>
8000319a:	b0 89       	st.b	r8[0x0],r9
	}
	
	//Time_scale++;

	// clear the interrupt flag
	rtc_clear_interrupt(&AVR32_RTC);
8000319c:	fe 7c 0d 00 	mov	r12,-62208
800031a0:	f0 1f 00 05 	mcall	800031b4 <rtc_irq+0xe8>

	// specify that an interrupt has been raised
	print_sec = 1;
800031a4:	30 19       	mov	r9,1
800031a6:	48 58       	lddpc	r8,800031b8 <rtc_irq+0xec>
800031a8:	91 09       	st.w	r8[0x0],r9
}
800031aa:	d4 02       	popm	lr
800031ac:	d6 03       	rete
800031ae:	00 00       	add	r0,r0
800031b0:	00 00       	add	r0,r0
800031b2:	0d 18       	ld.sh	r8,r6++
800031b4:	80 00       	ld.sh	r0,r0[0x0]
800031b6:	4a ec       	lddpc	r12,8000326c <xcmp_data_session_req>
800031b8:	00 00       	add	r0,r0
800031ba:	04 f4       	st.b	--r2,r4

800031bc <payload_init>:
Calls: xTaskCreate--freertos
Called By:app_init -- app.c
*/
void payload_init(void ( *payload_rx_func)(void * ), void ( *payload_tx_func)(void * ) )
{				
	payload_rx_exec = payload_rx_func;
800031bc:	48 38       	lddpc	r8,800031c8 <payload_init+0xc>
800031be:	91 0c       	st.w	r8[0x0],r12
	payload_tx_exec = payload_tx_func;
800031c0:	48 38       	lddpc	r8,800031cc <payload_init+0x10>
800031c2:	91 0b       	st.w	r8[0x0],r11
	//,  2
	//,  NULL
	//);
	//
	
}
800031c4:	5e fc       	retal	r12
800031c6:	00 00       	add	r0,r0
800031c8:	00 00       	add	r0,r0
800031ca:	0a 48       	or	r8,r5
800031cc:	00 00       	add	r0,r0
800031ce:	0a 4c       	or	r12,r5

800031d0 <set_idle_store>:
	}
}


void set_idle_store(xQueueHandle store, void * ptr)
{
800031d0:	eb cd 40 80 	pushm	r7,lr
800031d4:	20 1d       	sub	sp,4
800031d6:	fa c7 ff fc 	sub	r7,sp,-4
800031da:	0e db       	st.w	--r7,r11
	xQueueSend(store, &ptr, 0);
800031dc:	30 09       	mov	r9,0
800031de:	12 9a       	mov	r10,r9
800031e0:	1a 9b       	mov	r11,sp
800031e2:	f0 1f 00 03 	mcall	800031ec <set_idle_store+0x1c>
}
800031e6:	2f fd       	sub	sp,-4
800031e8:	e3 cd 80 80 	ldm	sp++,r7,pc
800031ec:	80 00       	ld.sh	r0,r0[0x0]
800031ee:	56 80       	stdsp	sp[0x1a0],r0

800031f0 <get_idle_store>:
	}//End of RxMedia Phy Handler.
}
#endif /*end if*/

void * get_idle_store(xQueueHandle store)
{
800031f0:	d4 01       	pushm	lr
800031f2:	20 1d       	sub	sp,4
	void * ptr = NULL;
800031f4:	30 0a       	mov	r10,0
800031f6:	fa cb ff fc 	sub	r11,sp,-4
800031fa:	16 da       	st.w	--r11,r10

	if(pdTRUE == xQueueReceive(store, &ptr, 0))
800031fc:	14 99       	mov	r9,r10
800031fe:	1a 9b       	mov	r11,sp
80003200:	f0 1f 00 05 	mcall	80003214 <get_idle_store+0x24>
80003204:	58 1c       	cp.w	r12,1
80003206:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
8000320a:	fb fc 00 00 	ld.weq	r12,sp[0x0]
	}
	else
	{
		return NULL;
	}
}
8000320e:	2f fd       	sub	sp,-4
80003210:	d8 02       	popm	pc
80003212:	00 00       	add	r0,r0
80003214:	80 00       	ld.sh	r0,r0[0x0]
80003216:	54 c4       	stdsp	sp[0x130],r4

80003218 <xcmp_register_app_list>:
Calls: 
Called By: app_init -- app.c
*/
void xcmp_register_app_list(void * list)
{
	app_list = (app_exec_t *)list;
80003218:	48 28       	lddpc	r8,80003220 <xcmp_register_app_list+0x8>
8000321a:	91 0c       	st.w	r8[0x0],r12
}
8000321c:	5e fc       	retal	r12
8000321e:	00 00       	add	r0,r0
80003220:	00 00       	add	r0,r0
80003222:	1f a4       	ld.ub	r4,pc[0x2]

80003224 <xcmp_tx>:
Calls:   
	xnl_tx -- xnl.c
Called By: ...
*/
static void xcmp_tx( xcmp_fragment_t * xcmp, U8 payload_len)
{
80003224:	eb cd 40 80 	pushm	r7,lr
80003228:	fa cd 01 00 	sub	sp,sp,256
8000322c:	16 97       	mov	r7,r11
	Length :xnl length + checksum
	= checksum + xnl header + xcmp opcode + xcmp payload
	= 0x02 + 0x0C + 0x02 + xcmp payload
	= 0x10 + xcmp payload
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | ( 0x10 + payload_len);
8000322e:	16 98       	mov	r8,r11
80003230:	2f 08       	sub	r8,-16
80003232:	af a8       	sbr	r8,0xe
80003234:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE; 
80003236:	3f f8       	mov	r8,-1
80003238:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG;
8000323a:	30 b9       	mov	r9,11
8000323c:	ba 29       	st.h	sp[0x4],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;	
8000323e:	ba 38       	st.h	sp[0x6],r8
	xnl_frame.xnl_header.destination = DEFAULT_VALUE;
80003240:	ba 48       	st.h	sp[0x8],r8
	xnl_frame.xnl_header.source = DEFAULT_VALUE;	
80003242:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80003244:	ba 68       	st.h	sp[0xc],r8
	
	/*insert xcmp frame data*/
	memcpy(&xnl_frame.xnl_payload.xnl_content_data_msg, xcmp, payload_len + 2);
80003246:	f6 ca ff fe 	sub	r10,r11,-2
8000324a:	18 9b       	mov	r11,r12
8000324c:	fa cc ff f0 	sub	r12,sp,-16
80003250:	f0 1f 00 05 	mcall	80003264 <xcmp_tx+0x40>
	xnl_frame.xnl_header.payload_length = payload_len + 2;	
80003254:	2f e7       	sub	r7,-2
80003256:	ba 77       	st.h	sp[0xe],r7
	
	/* send xnl frame*/	
	xnl_tx(&xnl_frame);
80003258:	1a 9c       	mov	r12,sp
8000325a:	f0 1f 00 04 	mcall	80003268 <xcmp_tx+0x44>
}
8000325e:	2c 0d       	sub	sp,-256
80003260:	e3 cd 80 80 	ldm	sp++,r7,pc
80003264:	80 00       	ld.sh	r0,r0[0x0]
80003266:	69 da       	ld.w	r10,r4[0x74]
80003268:	80 00       	ld.sh	r0,r0[0x0]
8000326a:	33 98       	mov	r8,57

8000326c <xcmp_data_session_req>:
Description: send data-session request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_data_session_req(void *message, U16 length, U8 dest)
{
8000326c:	d4 21       	pushm	r4-r7,lr
8000326e:	fa cd 00 d0 	sub	sp,sp,208
80003272:	18 94       	mov	r4,r12
80003274:	16 97       	mov	r7,r11
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
	
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
	
	if (length > 256)return -1;
80003276:	e0 68 01 00 	mov	r8,256
8000327a:	f0 0b 19 00 	cp.h	r11,r8
8000327e:	e0 8b 00 36 	brhi	800032ea <xcmp_data_session_req+0x7e>
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
	
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
80003282:	fa c5 ff f8 	sub	r5,sp,-8
	//U8 SizeofAddress = Remote_Mototrbo_Address_Size;// 3;//可能会变化
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
80003286:	e0 68 04 1d 	mov	r8,1053
8000328a:	ba 38       	st.h	sp[0x6],r8
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
	
	if (length > 256)return -1;
	
	ptr->Function = Single_Data_Uint;
8000328c:	30 18       	mov	r8,1
8000328e:	aa 88       	st.b	r5[0x0],r8
	
	ptr->DataDefinition.Data_Protocol_Version = TMP_Ver_1_1;//0x20
80003290:	32 08       	mov	r8,32
80003292:	aa 98       	st.b	r5[0x1],r8
	
	ptr->DataDefinition.Dest_Address.Remote_Address_Type = Remote_IPV4_Address;//0x02
80003294:	30 28       	mov	r8,2
80003296:	aa a8       	st.b	r5[0x2],r8
	
	ptr->DataDefinition.Dest_Address.Remote_Address_Size = Remote_IPV4_Address_Size;//0x04
80003298:	30 48       	mov	r8,4
8000329a:	aa b8       	st.b	r5[0x3],r8
	
	unsigned int addr = 0x0C000000 | (dest & 0x00FFFFFF);
8000329c:	ea 1a 0c 00 	orh	r10,0xc00
800032a0:	50 0a       	stdsp	sp[0x0],r10
	memcpy(ptr->DataDefinition.Dest_Address.Remote_Address, &addr, Remote_IPV4_Address_Size);
800032a2:	30 4a       	mov	r10,4
800032a4:	1a 9b       	mov	r11,sp
800032a6:	fa cc ff f4 	sub	r12,sp,-12
800032aa:	f0 1f 00 12 	mcall	800032f0 <xcmp_data_session_req+0x84>
	//ptr->DataDefinition.Dest_Address.Remote_Address[0] = 0x0C;//12
	//ptr->DataDefinition.Dest_Address.Remote_Address[1] = 0x00;//0
	//ptr->DataDefinition.Dest_Address.Remote_Address[2] = 0x00;//0
	//ptr->DataDefinition.Dest_Address.Remote_Address[3] = 0x02;//2
	
	ptr->DataDefinition.Dest_Address.Remote_Port_Com[0] = (Remote_Port >>8) & 0xFF;//4007
800032ae:	30 f8       	mov	r8,15
800032b0:	eb 68 00 08 	st.b	r5[8],r8
	ptr->DataDefinition.Dest_Address.Remote_Port_Com[1] = Remote_Port & 0xFF;//
800032b4:	3a 78       	mov	r8,-89
800032b6:	eb 68 00 09 	st.b	r5[9],r8
	
    
	ptr->DataPayload.Session_ID_Number = Session_ID;//0x00
800032ba:	30 08       	mov	r8,0
800032bc:	eb 68 00 0a 	st.b	r5[10],r8
	
	ptr->DataPayload.DataPayload_Length[0] =(length >> 8) & 0xFF ;//可能会变化
800032c0:	0e 9a       	mov	r10,r7
800032c2:	5c 7a       	castu.h	r10
800032c4:	f4 08 16 08 	lsr	r8,r10,0x8
800032c8:	eb 68 00 0b 	st.b	r5[11],r8
	ptr->DataPayload.DataPayload_Length[1] =length & 0xFF  ;//可能会变化
800032cc:	0e 96       	mov	r6,r7
800032ce:	eb 67 00 0c 	st.b	r5[12],r7
	
	memcpy(&(ptr->DataPayload.DataPayload[0]), message, length);
800032d2:	08 9b       	mov	r11,r4
800032d4:	fa cc ff eb 	sub	r12,sp,-21
800032d8:	f0 1f 00 06 	mcall	800032f0 <xcmp_data_session_req+0x84>
	
	xcmp_tx(&xcmp_farme, sizeof(DataSession_req_t) - (256 - length));
800032dc:	ee cb ff f3 	sub	r11,r7,-13
800032e0:	5c 5b       	castu.b	r11
800032e2:	fa cc ff fa 	sub	r12,sp,-6
800032e6:	f0 1f 00 04 	mcall	800032f4 <xcmp_data_session_req+0x88>
}
800032ea:	2c cd       	sub	sp,-208
800032ec:	d8 22       	popm	r4-r7,pc
800032ee:	00 00       	add	r0,r0
800032f0:	80 00       	ld.sh	r0,r0[0x0]
800032f2:	69 da       	ld.w	r10,r4[0x74]
800032f4:	80 00       	ld.sh	r0,r0[0x0]
800032f6:	32 24       	mov	r4,34

800032f8 <xcmp_DeviceInitializationStatus_request>:
Description: send device initialization status request
Calls: xcmp_tx
Called By:...
*/
void xcmp_DeviceInitializationStatus_request(void)
{
800032f8:	d4 01       	pushm	lr
800032fa:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
		
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_BRDCAST | DEVICE_INITIALIZATION_STATUS;
800032fe:	fe 78 b4 00 	mov	r8,-19456
80003302:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	DeviceInitializationStatus_brdcst_t * ptr 
						 = (DeviceInitializationStatus_brdcst_t *)xcmp_farme.u8;
80003304:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*xcmp version 8.1.0.5*///版本号未正确填写，纠正
	ptr->XCMPVersion[0] = 0x08;
80003308:	30 89       	mov	r9,8
8000330a:	b0 89       	st.b	r8[0x0],r9
	ptr->XCMPVersion[1] = 0x01;
8000330c:	30 19       	mov	r9,1
8000330e:	b0 99       	st.b	r8[0x1],r9
	ptr->XCMPVersion[2] = 0x00;
80003310:	30 09       	mov	r9,0
80003312:	b0 a9       	st.b	r8[0x2],r9
	ptr->XCMPVersion[3] = 0x05;
80003314:	30 5a       	mov	r10,5
80003316:	b0 ba       	st.b	r8[0x3],r10
	/*
	0x00:
	This is the message that the device sends at power up or after a reset. It 
	will give the initial status and capabilities for the device.
	*/
	ptr->DeviceInitType = 0x00;
80003318:	b0 c9       	st.b	r8[0x4],r9
	types of devices may provide a set of services to the radio system, but do 
	not have the ability to be the master.
	
	0x07:OptionBoard,3rd party Option Board-based application.
	*/
	ptr->DeviceStatusInfo.DeviceType = 0x07;
8000331a:	30 7a       	mov	r10,7
8000331c:	b0 da       	st.b	r8[0x5],r10
	
	/*Power Up Success, Device has powered up with no errors*/
	ptr->DeviceStatusInfo.DeviceStatus[0] = 0x00;
8000331e:	b0 e9       	st.b	r8[0x6],r9
	ptr->DeviceStatusInfo.DeviceStatus[1] = 0x00;
80003320:	b0 f9       	st.b	r8[0x7],r9
	
	/*
	This number is the size of the Device Descriptor data structure with a 
	maximum size not exceeding 255 bytes.
	*/
	ptr->DeviceStatusInfo.DeviceDescriptorSize = 0x00;
80003322:	f1 69 00 08 	st.b	r8[8],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme
80003326:	30 9b       	mov	r11,9
80003328:	fa cc ff fe 	sub	r12,sp,-2
8000332c:	f0 1f 00 02 	mcall	80003334 <xcmp_DeviceInitializationStatus_request+0x3c>
		, sizeof(DeviceInitializationStatus_brdcst_t) - MAX_DEVICE_DESC_SIZE);
}
80003330:	2c dd       	sub	sp,-204
80003332:	d8 02       	popm	pc
80003334:	80 00       	ld.sh	r0,r0[0x0]
80003336:	32 24       	mov	r4,34

80003338 <xcmp_IdleTestTone>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_IdleTestTone(U8 type, U16 toneID)
{
80003338:	d4 01       	pushm	lr
8000333a:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | TONE_CONTROL;
8000333e:	e0 68 04 09 	mov	r8,1033
80003342:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	ToneControl_req_t * ptr = (ToneControl_req_t *)xcmp_farme.u8;
80003344:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*Starts the specific tone*/	
	ptr->Function = type;
80003348:	b0 8c       	st.b	r8[0x0],r12
	
	/*This tone shall be sounded when radio landed on a priority channel*/
	//ptr->ToneIdentifier[0] = (Priority_Beep >> 8) & 0xFF;
	//ptr->ToneIdentifier[1] = Priority_Beep & 0xFF;
	
	ptr->ToneIdentifier[0] = (toneID >> 8) & 0xFF;
8000334a:	f3 db c1 08 	bfextu	r9,r11,0x8,0x8
8000334e:	b0 99       	st.b	r8[0x1],r9
	ptr->ToneIdentifier[1] = toneID & 0xFF;	
80003350:	b0 ab       	st.b	r8[0x2],r11
	
	/*
	The alert tone is played according to any rules for alert tones, given the 
	current volume setting. Settings for this field are 8 to 255 (0x08 ?0xFF).
	*/
	ptr->ToneVolumeControl = Current_Volume;
80003352:	30 09       	mov	r9,0
80003354:	b0 b9       	st.b	r8[0x3],r9
	
	/*clear reserved*/
	memset(ptr->Reserved, 0, 8);
80003356:	fb 69 00 08 	st.b	sp[8],r9
8000335a:	fa c8 ff f7 	sub	r8,sp,-9
8000335e:	b0 89       	st.b	r8[0x0],r9
80003360:	fa c8 ff f6 	sub	r8,sp,-10
80003364:	b0 89       	st.b	r8[0x0],r9
80003366:	fa c8 ff f5 	sub	r8,sp,-11
8000336a:	b0 89       	st.b	r8[0x0],r9
8000336c:	fa c8 ff f4 	sub	r8,sp,-12
80003370:	b0 89       	st.b	r8[0x0],r9
80003372:	fa c8 ff f3 	sub	r8,sp,-13
80003376:	b0 89       	st.b	r8[0x0],r9
80003378:	fa c8 ff f2 	sub	r8,sp,-14
8000337c:	b0 89       	st.b	r8[0x0],r9
8000337e:	fa c8 ff f1 	sub	r8,sp,-15
80003382:	b0 89       	st.b	r8[0x0],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(ToneControl_req_t));
80003384:	30 cb       	mov	r11,12
80003386:	fa cc ff fe 	sub	r12,sp,-2
8000338a:	f0 1f 00 03 	mcall	80003394 <xcmp_IdleTestTone+0x5c>
}
8000338e:	2c dd       	sub	sp,-204
80003390:	d8 02       	popm	pc
80003392:	00 00       	add	r0,r0
80003394:	80 00       	ld.sh	r0,r0[0x0]
80003396:	32 24       	mov	r4,34

80003398 <xnl_tx>:
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
{
80003398:	eb cd 40 c0 	pushm	r6-r7,lr
8000339c:	20 1d       	sub	sp,4
8000339e:	18 96       	mov	r6,r12
	message that is sent. The same value should be used for all retries.
	*/
	static U8 flags = 0;
	
	/*If the value is DEFAULT_VALUE, the value will be modified*/
	if(DEFAULT_VALUE == xnl->xnl_header.flags)
800033a0:	98 39       	ld.sh	r9,r12[0x6]
800033a2:	3f f8       	mov	r8,-1
800033a4:	f0 09 19 00 	cp.h	r9,r8
800033a8:	c0 a1       	brne	800033bc <xnl_tx+0x24>
	{
		xnl->xnl_header.flags =  0x0100 | ((++flags) & 0x07);
800033aa:	4a e9       	lddpc	r9,80003460 <xnl_tx+0xc8>
800033ac:	13 88       	ld.ub	r8,r9[0x0]
800033ae:	2f f8       	sub	r8,-1
800033b0:	5c 58       	castu.b	r8
800033b2:	b2 88       	st.b	r9[0x0],r8
800033b4:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
800033b8:	a9 a8       	sbr	r8,0x8
800033ba:	b8 38       	st.h	r12[0x6],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.destination)
800033bc:	8c 49       	ld.sh	r9,r6[0x8]
800033be:	3f f8       	mov	r8,-1
800033c0:	f0 09 19 00 	cp.h	r9,r8
800033c4:	c0 41       	brne	800033cc <xnl_tx+0x34>
	{		
		/*Use actual Master address.*/
		xnl->xnl_header.destination = xnl_information.master_address;
800033c6:	4a 88       	lddpc	r8,80003464 <xnl_tx+0xcc>
800033c8:	90 18       	ld.sh	r8,r8[0x2]
800033ca:	ac 48       	st.h	r6[0x8],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.source)
800033cc:	8c 59       	ld.sh	r9,r6[0xa]
800033ce:	3f f8       	mov	r8,-1
800033d0:	f0 09 19 00 	cp.h	r9,r8
800033d4:	c0 41       	brne	800033dc <xnl_tx+0x44>
	{
		/*Use Temporary address.*/	
		xnl->xnl_header.source = xnl_information.device_address;
800033d6:	4a 48       	lddpc	r8,80003464 <xnl_tx+0xcc>
800033d8:	90 28       	ld.sh	r8,r8[0x4]
800033da:	ac 58       	st.h	r6[0xa],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
800033dc:	8c 69       	ld.sh	r9,r6[0xc]
800033de:	3f f8       	mov	r8,-1
800033e0:	f0 09 19 00 	cp.h	r9,r8
800033e4:	c0 e1       	brne	80003400 <xnl_tx+0x68>
	{		
		xnl->xnl_header.transaction_id = 
		  ((++xnl_information.transaction_id) & 0xFF) 
800033e6:	4a 08       	lddpc	r8,80003464 <xnl_tx+0xcc>
800033e8:	90 49       	ld.sh	r9,r8[0x8]
800033ea:	2f f9       	sub	r9,-1
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
800033ec:	b0 49       	st.h	r8[0x8],r9
		  ((++xnl_information.transaction_id) & 0xFF) 
800033ee:	90 4a       	ld.sh	r10,r8[0x8]
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
800033f0:	90 49       	ld.sh	r9,r8[0x8]
800033f2:	e0 19 ff 00 	andl	r9,0xff00
800033f6:	f1 da c0 08 	bfextu	r8,r10,0x0,0x8
800033fa:	f3 e8 10 08 	or	r8,r9,r8
800033fe:	ac 68       	st.h	r6[0xc],r8
	U16  sumScratch;
	U32  indextohWord;
	S32  hWordswithinFrag;
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
80003400:	0d 98       	ld.ub	r8,r6[0x1]
80003402:	20 28       	sub	r8,2
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
80003404:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
80003408:	10 0c       	add	r12,r8
8000340a:	a1 5c       	asr	r12,0x1
	indextohWord = 2;
	while (hWordswithinFrag > 0)
8000340c:	58 0c       	cp.w	r12,0
8000340e:	e0 89 00 04 	brgt	80003416 <xnl_tx+0x7e>
80003412:	30 09       	mov	r9,0
80003414:	c0 d8       	rjmp	8000342e <xnl_tx+0x96>
80003416:	ec ca ff fc 	sub	r10,r6,-4
Parameters: xnl_fragment_t * 
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
8000341a:	2f ec       	sub	r12,-2
8000341c:	30 09       	mov	r9,0
8000341e:	30 28       	mov	r8,2
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
	{
		sumScratch += *((U16*)xnl + indextohWord);
80003420:	15 1b       	ld.sh	r11,r10++
80003422:	f6 09 00 09 	add	r9,r11,r9
80003426:	5c 89       	casts.h	r9
		indextohWord     += 1;
80003428:	2f f8       	sub	r8,-1
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
8000342a:	18 38       	cp.w	r8,r12
8000342c:	cf a1       	brne	80003420 <xnl_tx+0x88>
		  ((++xnl_information.transaction_id) & 0xFF) 
		| (xnl_information.transaction_id & 0xFF00);
	}
	
	/*count check sum */
	xnl->phy_header.check_sum = check_sum( xnl );
8000342e:	5c 39       	neg	r9
80003430:	ac 19       	st.h	r6[0x2],r9
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
80003432:	48 e8       	lddpc	r8,80003468 <xnl_tx+0xd0>
80003434:	70 0c       	ld.w	r12,r8[0x0]
80003436:	f0 1f 00 0e 	mcall	8000346c <xnl_tx+0xd4>
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
8000343a:	c1 00       	breq	8000345a <xnl_tx+0xc2>
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
8000343c:	fa c7 ff fc 	sub	r7,sp,-4
80003440:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
	{
		memcpy(ptr, xnl, sizeof(xnl_fragment_t));
80003442:	e0 6a 01 00 	mov	r10,256
80003446:	0c 9b       	mov	r11,r6
80003448:	f0 1f 00 0a 	mcall	80003470 <xnl_tx+0xd8>
	
		/*push to queue and send*/
		
		//log("ptr -%8x", ptr);
		
		xQueueSend(xnl_frame_tx, &ptr, 0);
8000344c:	48 a8       	lddpc	r8,80003474 <xnl_tx+0xdc>
8000344e:	70 0c       	ld.w	r12,r8[0x0]
80003450:	30 09       	mov	r9,0
80003452:	12 9a       	mov	r10,r9
80003454:	1a 9b       	mov	r11,sp
80003456:	f0 1f 00 09 	mcall	80003478 <xnl_tx+0xe0>
		//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
		
		//vPortFree(ptr);
	}
}
8000345a:	2f fd       	sub	sp,-4
8000345c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80003460:	00 00       	add	r0,r0
80003462:	0a 54       	eor	r4,r5
80003464:	00 00       	add	r0,r0
80003466:	0a 56       	eor	r6,r5
80003468:	00 00       	add	r0,r0
8000346a:	0a 50       	eor	r0,r5
8000346c:	80 00       	ld.sh	r0,r0[0x0]
8000346e:	31 f0       	mov	r0,31
80003470:	80 00       	ld.sh	r0,r0[0x0]
80003472:	69 da       	ld.w	r10,r4[0x74]
80003474:	00 00       	add	r0,r0
80003476:	0a 60       	and	r0,r5
80003478:	80 00       	ld.sh	r0,r0[0x0]
8000347a:	56 80       	stdsp	sp[0x1a0],r0

8000347c <RC522_SPI_SetSpeed>:
	//SET_SPI_CS;

}

void RC522_SPI_SetSpeed(U16 SPI_BaudRatePrescaler)
{
8000347c:	d4 01       	pushm	lr
	spi->csr0 = (spi->csr0 & (U16)0x00FF) |SPI_BaudRatePrescaler;
8000347e:	48 78       	lddpc	r8,80003498 <RC522_SPI_SetSpeed+0x1c>
80003480:	70 09       	ld.w	r9,r8[0x0]
80003482:	72 ca       	ld.w	r10,r9[0x30]
80003484:	5c 7c       	castu.h	r12
80003486:	f5 da c0 08 	bfextu	r10,r10,0x0,0x8
8000348a:	f9 ea 10 0a 	or	r10,r12,r10
8000348e:	93 ca       	st.w	r9[0x30],r10

	spi_enable(spi); /*!< SD_SPI enable */
80003490:	70 0c       	ld.w	r12,r8[0x0]
80003492:	f0 1f 00 03 	mcall	8000349c <RC522_SPI_SetSpeed+0x20>
		
	
}
80003496:	d8 02       	popm	pc
80003498:	00 00       	add	r0,r0
8000349a:	1f a0       	ld.ub	r0,pc[0x2]
8000349c:	80 00       	ld.sh	r0,r0[0x0]
8000349e:	4c 10       	lddpc	r0,800035a0 <PcdReset+0x54>

800034a0 <RC522_SPI_SetSpeedLow>:
void RC522_SPI_SetSpeedLow(void)
{
800034a0:	d4 01       	pushm	lr
	RC522_SPI_SetSpeed(0x0A00);//baudDiv=4
800034a2:	e0 6c 0a 00 	mov	r12,2560
800034a6:	f0 1f 00 02 	mcall	800034ac <RC522_SPI_SetSpeedLow+0xc>
	
}
800034aa:	d8 02       	popm	pc
800034ac:	80 00       	ld.sh	r0,r0[0x0]
800034ae:	34 7c       	mov	r12,71

800034b0 <RC522_ReadByte>:
	/*!< Return the byte read from the SPI bus */
	return  temp;

}
U8 RC522_ReadByte(void)
{
800034b0:	eb cd 40 c0 	pushm	r6-r7,lr
	//蹇椤昏锋芥ｅ父璇诲
	//spi_selectChip(spi, DF_SPI_PCS_0);
	
	/*!< Send the byte */

	spi_write(spi,  0xFF);
800034b4:	48 76       	lddpc	r6,800034d0 <RC522_ReadByte+0x20>
800034b6:	e0 6b 00 ff 	mov	r11,255
800034ba:	6c 0c       	ld.w	r12,r6[0x0]
800034bc:	f0 1f 00 06 	mcall	800034d4 <RC522_ReadByte+0x24>
	
	/*!< Return the byte read from the SPI bus */

	spi_read(spi, Data);
800034c0:	30 07       	mov	r7,0
800034c2:	0e 9b       	mov	r11,r7
800034c4:	6c 0c       	ld.w	r12,r6[0x0]
800034c6:	f0 1f 00 05 	mcall	800034d8 <RC522_ReadByte+0x28>
	
	//spi_unselectChip(spi, DF_SPI_PCS_0);
	
	return (U8)(*Data);
	
}
800034ca:	0f 9c       	ld.ub	r12,r7[0x1]
800034cc:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800034d0:	00 00       	add	r0,r0
800034d2:	1f a0       	ld.ub	r0,pc[0x2]
800034d4:	80 00       	ld.sh	r0,r0[0x0]
800034d6:	4c 16       	lddpc	r6,800035d8 <ReadRawRC+0xc>
800034d8:	80 00       	ld.sh	r0,r0[0x0]
800034da:	4c 32       	lddpc	r2,800035e4 <ReadRawRC+0x18>

800034dc <RC522_WriteByte>:


U8 rc522_init_failure =0;

U8 RC522_WriteByte(U8 Data)
{
800034dc:	eb cd 40 80 	pushm	r7,lr
800034e0:	20 1d       	sub	sp,4
800034e2:	ba 8c       	st.b	sp[0x0],r12
	U8 temp =0;
	
	//spi_selectChip(spi, DF_SPI_PCS_0);
	
	/*!< Send the byte */
	spi_write(spi,  (U16)Data);
800034e4:	48 77       	lddpc	r7,80003500 <RC522_WriteByte+0x24>
800034e6:	f7 dc c0 08 	bfextu	r11,r12,0x0,0x8
800034ea:	6e 0c       	ld.w	r12,r7[0x0]
800034ec:	f0 1f 00 06 	mcall	80003504 <RC522_WriteByte+0x28>
	
	/*!< Wait to receive a byte*/

	temp = spi_read(spi, (U16*)&Data);
800034f0:	1a 9b       	mov	r11,sp
800034f2:	6e 0c       	ld.w	r12,r7[0x0]
800034f4:	f0 1f 00 05 	mcall	80003508 <RC522_WriteByte+0x2c>
	//spi_unselectChip(spi, DF_SPI_PCS_0);
	
	/*!< Return the byte read from the SPI bus */
	return  temp;

}
800034f8:	5c 5c       	castu.b	r12
800034fa:	2f fd       	sub	sp,-4
800034fc:	e3 cd 80 80 	ldm	sp++,r7,pc
80003500:	00 00       	add	r0,r0
80003502:	1f a0       	ld.ub	r0,pc[0x2]
80003504:	80 00       	ld.sh	r0,r0[0x0]
80003506:	4c 16       	lddpc	r6,80003608 <ReadRawRC+0x3c>
80003508:	80 00       	ld.sh	r0,r0[0x0]
8000350a:	4c 32       	lddpc	r2,80003614 <Wait_Wakeup_RC522>

8000350c <WriteRawRC>:
//    斤RC632瀵瀛
//拌存锛Address[IN]:瀵瀛ㄥ板
//          value[IN]:ョ
/////////////////////////////////////////////////////////////////////
void WriteRawRC(U8   Address, U8   value)
{
8000350c:	eb cd 40 e0 	pushm	r5-r7,lr
80003510:	18 96       	mov	r6,r12
80003512:	16 95       	mov	r5,r11
	U8   ucAddr;

	//CLR_SPI_CS;	
	spi_selectChip(spi, DF_SPI_PCS_0);
80003514:	48 a7       	lddpc	r7,8000353c <WriteRawRC+0x30>
80003516:	30 0b       	mov	r11,0
80003518:	6e 0c       	ld.w	r12,r7[0x0]
8000351a:	f0 1f 00 0a 	mcall	80003540 <WriteRawRC+0x34>
	
	ucAddr = ((Address<<1)&0x7E);
	RC522_WriteByte(ucAddr);
8000351e:	ec 0c 15 01 	lsl	r12,r6,0x1
80003522:	e2 1c 00 7e 	andl	r12,0x7e,COH
80003526:	f0 1f 00 08 	mcall	80003544 <WriteRawRC+0x38>
	RC522_WriteByte(value);
8000352a:	0a 9c       	mov	r12,r5
8000352c:	f0 1f 00 06 	mcall	80003544 <WriteRawRC+0x38>
	
	spi_unselectChip(spi, DF_SPI_PCS_0);
80003530:	30 0b       	mov	r11,0
80003532:	6e 0c       	ld.w	r12,r7[0x0]
80003534:	f0 1f 00 05 	mcall	80003548 <WriteRawRC+0x3c>
	
	//SET_SPI_CS;

}
80003538:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000353c:	00 00       	add	r0,r0
8000353e:	1f a0       	ld.ub	r0,pc[0x2]
80003540:	80 00       	ld.sh	r0,r0[0x0]
80003542:	4d 7c       	lddpc	r12,8000369c <PcdAntennaOn+0x8>
80003544:	80 00       	ld.sh	r0,r0[0x0]
80003546:	34 dc       	mov	r12,77
80003548:	80 00       	ld.sh	r0,r0[0x0]
8000354a:	4d 3c       	lddpc	r12,80003694 <PcdAntennaOn>

8000354c <PcdReset>:
/////////////////////////////////////////////////////////////////////
//    斤澶浣RC522
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdReset(void)
{
8000354c:	d4 01       	pushm	lr

	SET_RC522RST;
8000354e:	31 9c       	mov	r12,25
80003550:	f0 1f 00 1b 	mcall	800035bc <PcdReset+0x70>
	delay_ns(10);
80003554:	30 ac       	mov	r12,10
80003556:	f0 1f 00 1b 	mcall	800035c0 <PcdReset+0x74>

	CLR_RC522RST;
8000355a:	31 9c       	mov	r12,25
8000355c:	f0 1f 00 1a 	mcall	800035c4 <PcdReset+0x78>
	delay_ns(10);
80003560:	30 ac       	mov	r12,10
80003562:	f0 1f 00 18 	mcall	800035c0 <PcdReset+0x74>

	SET_RC522RST;
80003566:	31 9c       	mov	r12,25
80003568:	f0 1f 00 15 	mcall	800035bc <PcdReset+0x70>
	delay_ns(10);
8000356c:	30 ac       	mov	r12,10
8000356e:	f0 1f 00 15 	mcall	800035c0 <PcdReset+0x74>
	WriteRawRC(CommandReg,PCD_RESETPHASE);
80003572:	30 fb       	mov	r11,15
80003574:	30 1c       	mov	r12,1
80003576:	f0 1f 00 15 	mcall	800035c8 <PcdReset+0x7c>
	WriteRawRC(CommandReg,PCD_RESETPHASE);
8000357a:	30 fb       	mov	r11,15
8000357c:	30 1c       	mov	r12,1
8000357e:	f0 1f 00 13 	mcall	800035c8 <PcdReset+0x7c>
	delay_ns(10);
80003582:	30 ac       	mov	r12,10
80003584:	f0 1f 00 0f 	mcall	800035c0 <PcdReset+0x74>
	
	WriteRawRC(ModeReg,0x3D);            //Mifare￠璁锛CRC濮0x6363
80003588:	33 db       	mov	r11,61
8000358a:	31 1c       	mov	r12,17
8000358c:	f0 1f 00 0f 	mcall	800035c8 <PcdReset+0x7c>
	WriteRawRC(TReloadRegL,30);
80003590:	31 eb       	mov	r11,30
80003592:	32 dc       	mov	r12,45
80003594:	f0 1f 00 0d 	mcall	800035c8 <PcdReset+0x7c>
	WriteRawRC(TReloadRegH,0);
80003598:	30 0b       	mov	r11,0
8000359a:	32 cc       	mov	r12,44
8000359c:	f0 1f 00 0b 	mcall	800035c8 <PcdReset+0x7c>
	WriteRawRC(TModeReg,0x8D);
800035a0:	e0 6b 00 8d 	mov	r11,141
800035a4:	32 ac       	mov	r12,42
800035a6:	f0 1f 00 09 	mcall	800035c8 <PcdReset+0x7c>
	WriteRawRC(TPrescalerReg,0x3E);
800035aa:	33 eb       	mov	r11,62
800035ac:	32 bc       	mov	r12,43
800035ae:	f0 1f 00 07 	mcall	800035c8 <PcdReset+0x7c>
	
	WriteRawRC(TxAutoReg,0x40);//蹇椤昏
800035b2:	34 0b       	mov	r11,64
800035b4:	31 5c       	mov	r12,21
800035b6:	f0 1f 00 05 	mcall	800035c8 <PcdReset+0x7c>
	
	return MI_OK;
}
800035ba:	d8 0a       	popm	pc,r12=0
800035bc:	80 00       	ld.sh	r0,r0[0x0]
800035be:	47 84       	lddsp	r4,sp[0x1e0]
800035c0:	80 00       	ld.sh	r0,r0[0x0]
800035c2:	3e 54       	mov	r4,-27
800035c4:	80 00       	ld.sh	r0,r0[0x0]
800035c6:	47 a0       	lddsp	r0,sp[0x1e8]
800035c8:	80 00       	ld.sh	r0,r0[0x0]
800035ca:	35 0c       	mov	r12,80

800035cc <ReadRawRC>:
//    斤璇RC632瀵瀛
//拌存锛Address[IN]:瀵瀛ㄥ板
//杩    锛璇诲虹
/////////////////////////////////////////////////////////////////////
U8 ReadRawRC(U8   Address)
{
800035cc:	eb cd 40 c0 	pushm	r6-r7,lr
800035d0:	18 96       	mov	r6,r12
	U8   ucAddr;
	U8   ucResult=0;
	//CLR_SPI_CS;	
	spi_selectChip(spi, DF_SPI_PCS_0);
800035d2:	48 c7       	lddpc	r7,80003600 <ReadRawRC+0x34>
800035d4:	30 0b       	mov	r11,0
800035d6:	6e 0c       	ld.w	r12,r7[0x0]
800035d8:	f0 1f 00 0b 	mcall	80003604 <ReadRawRC+0x38>
	 
	ucAddr = ((Address<<1)&0x7E)|0x80;
	
	RC522_WriteByte(ucAddr);
800035dc:	a1 76       	lsl	r6,0x1
800035de:	0c 9c       	mov	r12,r6
800035e0:	e2 1c 00 7e 	andl	r12,0x7e,COH
800035e4:	a7 bc       	sbr	r12,0x7
800035e6:	f0 1f 00 09 	mcall	80003608 <ReadRawRC+0x3c>
	ucResult = RC522_ReadByte();
800035ea:	f0 1f 00 09 	mcall	8000360c <ReadRawRC+0x40>
800035ee:	18 96       	mov	r6,r12
	
	spi_unselectChip(spi, DF_SPI_PCS_0);
800035f0:	30 0b       	mov	r11,0
800035f2:	6e 0c       	ld.w	r12,r7[0x0]
800035f4:	f0 1f 00 07 	mcall	80003610 <ReadRawRC+0x44>
	//SET_SPI_CS;
	return ucResult;
}
800035f8:	0c 9c       	mov	r12,r6
800035fa:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800035fe:	00 00       	add	r0,r0
80003600:	00 00       	add	r0,r0
80003602:	1f a0       	ld.ub	r0,pc[0x2]
80003604:	80 00       	ld.sh	r0,r0[0x0]
80003606:	4d 7c       	lddpc	r12,80003760 <rc522_init+0x4>
80003608:	80 00       	ld.sh	r0,r0[0x0]
8000360a:	34 dc       	mov	r12,77
8000360c:	80 00       	ld.sh	r0,r0[0x0]
8000360e:	34 b0       	mov	r0,75
80003610:	80 00       	ld.sh	r0,r0[0x0]
80003612:	4d 3c       	lddpc	r12,8000375c <rc522_init>

80003614 <Wait_Wakeup_RC522>:

/////////////////////////////////////////////////////////////////////
//    斤绛寰RC522
/////////////////////////////////////////////////////////////////////
void Wait_Wakeup_RC522(void)
{
80003614:	d4 01       	pushm	lr
	char   tmp = 0x0;
	char   reg = CommandReg;
	
	do 
	{
		tmp = ReadRawRC(reg);
80003616:	30 1c       	mov	r12,1
80003618:	f0 1f 00 02 	mcall	80003620 <Wait_Wakeup_RC522+0xc>
			
	//tmp = ReadRawRC(reg);
	//if((tmp & 0x10) == 0)
	//WriteRawRC(reg,tmp | PCD_POWERDOWN);  // set bit powerdown
	
}
8000361c:	d8 02       	popm	pc
8000361e:	00 00       	add	r0,r0
80003620:	80 00       	ld.sh	r0,r0[0x0]
80003622:	35 cc       	mov	r12,92

80003624 <Powerdown_RC522>:
/////////////////////////////////////////////////////////////////////
//    斤浣RC522杩ヨ蒋垫ā寮
//
/////////////////////////////////////////////////////////////////////
void Powerdown_RC522(U8 act)
{
80003624:	eb cd 40 80 	pushm	r7,lr
80003628:	18 97       	mov	r7,r12
	char   tmp = 0x0;
	char   reg = CommandReg;
	
	tmp = ReadRawRC(reg);
8000362a:	30 1c       	mov	r12,1
8000362c:	f0 1f 00 0d 	mcall	80003660 <Powerdown_RC522+0x3c>
	if(act == ENTER_POWERDOWN)//1
80003630:	30 18       	mov	r8,1
80003632:	f0 07 18 00 	cp.b	r7,r8
80003636:	c0 91       	brne	80003648 <Powerdown_RC522+0x24>
		WriteRawRC(reg,tmp | PCD_POWERDOWN);  // set bit powerdown
80003638:	18 9b       	mov	r11,r12
8000363a:	a5 ab       	sbr	r11,0x4
8000363c:	5c 5b       	castu.b	r11
8000363e:	30 1c       	mov	r12,1
80003640:	f0 1f 00 09 	mcall	80003664 <Powerdown_RC522+0x40>
80003644:	e3 cd 80 80 	ldm	sp++,r7,pc
	else
	{
		WriteRawRC(reg,tmp | PCD_IDLE);  // wake up rc522
80003648:	18 9b       	mov	r11,r12
8000364a:	30 1c       	mov	r12,1
8000364c:	f0 1f 00 06 	mcall	80003664 <Powerdown_RC522+0x40>
		delay_ns(2);
80003650:	30 2c       	mov	r12,2
80003652:	f0 1f 00 06 	mcall	80003668 <Powerdown_RC522+0x44>
		Wait_Wakeup_RC522();
80003656:	f0 1f 00 06 	mcall	8000366c <Powerdown_RC522+0x48>
8000365a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000365e:	00 00       	add	r0,r0
80003660:	80 00       	ld.sh	r0,r0[0x0]
80003662:	35 cc       	mov	r12,92
80003664:	80 00       	ld.sh	r0,r0[0x0]
80003666:	35 0c       	mov	r12,80
80003668:	80 00       	ld.sh	r0,r0[0x0]
8000366a:	3e 54       	mov	r4,-27
8000366c:	80 00       	ld.sh	r0,r0[0x0]
8000366e:	36 14       	mov	r4,97

80003670 <SetBitMask>:
//    斤缃RC522瀵瀛ㄤ
//拌存锛reg[IN]:瀵瀛ㄥ板
//          mask[IN]:缃浣
/////////////////////////////////////////////////////////////////////
void SetBitMask(U8   reg,U8   mask)
{
80003670:	eb cd 40 c0 	pushm	r6-r7,lr
80003674:	18 97       	mov	r7,r12
80003676:	16 96       	mov	r6,r11
	char   tmp = 0x0;
	tmp = ReadRawRC(reg);
80003678:	f0 1f 00 05 	mcall	8000368c <SetBitMask+0x1c>
	WriteRawRC(reg,tmp | mask);  // set bit mask
8000367c:	f9 e6 10 0b 	or	r11,r12,r6
80003680:	5c 5b       	castu.b	r11
80003682:	0e 9c       	mov	r12,r7
80003684:	f0 1f 00 03 	mcall	80003690 <SetBitMask+0x20>
}
80003688:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000368c:	80 00       	ld.sh	r0,r0[0x0]
8000368e:	35 cc       	mov	r12,92
80003690:	80 00       	ld.sh	r0,r0[0x0]
80003692:	35 0c       	mov	r12,80

80003694 <PcdAntennaOn>:
/////////////////////////////////////////////////////////////////////
//寮澶╃嚎
//姣娆″ㄦ抽澶╅╁灏涔村冲1ms撮
/////////////////////////////////////////////////////////////////////
void PcdAntennaOn(void)
{
80003694:	d4 01       	pushm	lr
	U8   i;
	i = ReadRawRC(TxControlReg);
80003696:	31 4c       	mov	r12,20
80003698:	f0 1f 00 05 	mcall	800036ac <PcdAntennaOn+0x18>
	if (!(i & 0x03))
8000369c:	f9 dc c0 02 	bfextu	r12,r12,0x0,0x2
800036a0:	c0 51       	brne	800036aa <PcdAntennaOn+0x16>
	{
		SetBitMask(TxControlReg, 0x03);
800036a2:	30 3b       	mov	r11,3
800036a4:	31 4c       	mov	r12,20
800036a6:	f0 1f 00 03 	mcall	800036b0 <PcdAntennaOn+0x1c>
800036aa:	d8 02       	popm	pc
800036ac:	80 00       	ld.sh	r0,r0[0x0]
800036ae:	35 cc       	mov	r12,92
800036b0:	80 00       	ld.sh	r0,r0[0x0]
800036b2:	36 70       	mov	r0,103

800036b4 <ClearBitMask>:
//    斤娓RC522瀵瀛ㄤ
//拌存锛reg[IN]:瀵瀛ㄥ板
//         mask[IN]:娓浣
/////////////////////////////////////////////////////////////////////
void ClearBitMask(U8   reg,U8   mask)
{
800036b4:	eb cd 40 c0 	pushm	r6-r7,lr
800036b8:	18 97       	mov	r7,r12
800036ba:	16 96       	mov	r6,r11
	  char   tmp = 0x0;
	  tmp = ReadRawRC(reg);
800036bc:	f0 1f 00 06 	mcall	800036d4 <ClearBitMask+0x20>
	  WriteRawRC(reg, tmp & ~mask);  // clear bit mask
800036c0:	5c d6       	com	r6
800036c2:	f9 e6 00 06 	and	r6,r12,r6
800036c6:	f7 d6 c0 08 	bfextu	r11,r6,0x0,0x8
800036ca:	0e 9c       	mov	r12,r7
800036cc:	f0 1f 00 03 	mcall	800036d8 <ClearBitMask+0x24>
	
}
800036d0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800036d4:	80 00       	ld.sh	r0,r0[0x0]
800036d6:	35 cc       	mov	r12,92
800036d8:	80 00       	ld.sh	r0,r0[0x0]
800036da:	35 0c       	mov	r12,80

800036dc <PcdAntennaOff>:

/////////////////////////////////////////////////////////////////////
//抽澶╃嚎
/////////////////////////////////////////////////////////////////////
void PcdAntennaOff(void)
{
800036dc:	d4 01       	pushm	lr
	ClearBitMask(TxControlReg, 0x03);
800036de:	30 3b       	mov	r11,3
800036e0:	31 4c       	mov	r12,20
800036e2:	f0 1f 00 02 	mcall	800036e8 <PcdAntennaOff+0xc>
}
800036e6:	d8 02       	popm	pc
800036e8:	80 00       	ld.sh	r0,r0[0x0]
800036ea:	36 b4       	mov	r4,107

800036ec <M500PcdConfigISOType>:

//////////////////////////////////////////////////////////////////////
//璁剧疆RC632宸ヤ瑰
//////////////////////////////////////////////////////////////////////
char M500PcdConfigISOType(U8   type)
{
800036ec:	d4 01       	pushm	lr
	if (type == 'A')                     //ISO14443_A
800036ee:	34 18       	mov	r8,65
800036f0:	f0 0c 18 00 	cp.b	r12,r8
800036f4:	c0 20       	breq	800036f8 <M500PcdConfigISOType+0xc>
800036f6:	da 0a       	popm	pc,r12=1
	{
		ClearBitMask(Status2Reg,0x08);
800036f8:	30 8b       	mov	r11,8
800036fa:	16 9c       	mov	r12,r11
800036fc:	f0 1f 00 14 	mcall	8000374c <M500PcdConfigISOType+0x60>
		WriteRawRC(ModeReg,0x3D);//3F
80003700:	33 db       	mov	r11,61
80003702:	31 1c       	mov	r12,17
80003704:	f0 1f 00 13 	mcall	80003750 <M500PcdConfigISOType+0x64>
		WriteRawRC(RxSelReg,0x86);//84
80003708:	e0 6b 00 86 	mov	r11,134
8000370c:	31 7c       	mov	r12,23
8000370e:	f0 1f 00 11 	mcall	80003750 <M500PcdConfigISOType+0x64>
		WriteRawRC(RFCfgReg,0x7F);   //4F
80003712:	37 fb       	mov	r11,127
80003714:	32 6c       	mov	r12,38
80003716:	f0 1f 00 0f 	mcall	80003750 <M500PcdConfigISOType+0x64>
		WriteRawRC(TReloadRegL,30);//tmoLength);// TReloadVal = 'h6a =tmoLength(dec)
8000371a:	31 eb       	mov	r11,30
8000371c:	32 dc       	mov	r12,45
8000371e:	f0 1f 00 0d 	mcall	80003750 <M500PcdConfigISOType+0x64>
		WriteRawRC(TReloadRegH,0);
80003722:	30 0b       	mov	r11,0
80003724:	32 cc       	mov	r12,44
80003726:	f0 1f 00 0b 	mcall	80003750 <M500PcdConfigISOType+0x64>
		WriteRawRC(TModeReg,0x8D);
8000372a:	e0 6b 00 8d 	mov	r11,141
8000372e:	32 ac       	mov	r12,42
80003730:	f0 1f 00 08 	mcall	80003750 <M500PcdConfigISOType+0x64>
		WriteRawRC(TPrescalerReg,0x3E);
80003734:	33 eb       	mov	r11,62
80003736:	32 bc       	mov	r12,43
80003738:	f0 1f 00 06 	mcall	80003750 <M500PcdConfigISOType+0x64>
		delay_ns(1000);
8000373c:	e0 6c 03 e8 	mov	r12,1000
80003740:	f0 1f 00 05 	mcall	80003754 <M500PcdConfigISOType+0x68>
		PcdAntennaOn();
80003744:	f0 1f 00 05 	mcall	80003758 <M500PcdConfigISOType+0x6c>
80003748:	d8 0a       	popm	pc,r12=0
8000374a:	00 00       	add	r0,r0
8000374c:	80 00       	ld.sh	r0,r0[0x0]
8000374e:	36 b4       	mov	r4,107
80003750:	80 00       	ld.sh	r0,r0[0x0]
80003752:	35 0c       	mov	r12,80
80003754:	80 00       	ld.sh	r0,r0[0x0]
80003756:	3e 54       	mov	r4,-27
80003758:	80 00       	ld.sh	r0,r0[0x0]
8000375a:	36 94       	mov	r4,105

8000375c <rc522_init>:


//mfrc522 init

void rc522_init()
{
8000375c:	eb cd 40 80 	pushm	r7,lr
80003760:	20 4d       	sub	sp,16
		.spck_delay   = 0,
		.trans_delay  = 0,
		.stay_act     = 1,
		.spi_mode     = 0,
		.modfdis      = 1
	};
80003762:	49 d8       	lddpc	r8,800037d4 <rc522_init+0x78>
80003764:	1a 97       	mov	r7,sp
80003766:	f0 ea 00 00 	ld.d	r10,r8[0]
8000376a:	fa eb 00 00 	st.d	sp[0],r10
8000376e:	f0 e8 00 08 	ld.d	r8,r8[8]
80003772:	fa e9 00 08 	st.d	sp[8],r8

	// Assign I/Os to SPI.
	gpio_enable_module(RC522_SPI_GPIO_MAP, sizeof(RC522_SPI_GPIO_MAP) / sizeof(RC522_SPI_GPIO_MAP[0]));
80003776:	30 1b       	mov	r11,1
80003778:	49 8c       	lddpc	r12,800037d8 <rc522_init+0x7c>
8000377a:	f0 1f 00 19 	mcall	800037dc <rc522_init+0x80>

	// Configure PA25 as RST pin
	gpio_enable_gpio_pin(AVR32_PIN_PA25);
8000377e:	31 9c       	mov	r12,25
80003780:	f0 1f 00 18 	mcall	800037e0 <rc522_init+0x84>
	gpio_set_gpio_pin(AVR32_PIN_PA25);
80003784:	31 9c       	mov	r12,25
80003786:	f0 1f 00 18 	mcall	800037e4 <rc522_init+0x88>
	
	//gpio_enable_gpio_pin(AVR32_PIN_PA24);

	spi = &AVR32_SPI;
8000378a:	fe 7c 24 00 	mov	r12,-56320
8000378e:	49 78       	lddpc	r8,800037e8 <rc522_init+0x8c>
80003790:	91 0c       	st.w	r8[0x0],r12

	// Enable SPI.
	//spi_enable(spi);

	// Initialize RC522 with SPI clock PBA.
	if (spi_setupChipReg(spi, &spiOptions, 2*12000000) != SPI_OK)
80003792:	e0 6a 36 00 	mov	r10,13824
80003796:	ea 1a 01 6e 	orh	r10,0x16e
8000379a:	1a 9b       	mov	r11,sp
8000379c:	f0 1f 00 14 	mcall	800037ec <rc522_init+0x90>
800037a0:	c0 50       	breq	800037aa <rc522_init+0x4e>
	{
		
		rc522_init_failure = FATAL_ERROR_RC522_SPI_INIT;
800037a2:	30 29       	mov	r9,2
800037a4:	49 38       	lddpc	r8,800037f0 <rc522_init+0x94>
800037a6:	b0 89       	st.b	r8[0x0],r9
800037a8:	c0 38       	rjmp	800037ae <rc522_init+0x52>
		return;
	}
	
	RC522_SPI_SetSpeedLow();
800037aa:	f0 1f 00 13 	mcall	800037f4 <rc522_init+0x98>
void rc522_init()
{
	
	spi_init();
	
	PcdReset();
800037ae:	f0 1f 00 13 	mcall	800037f8 <rc522_init+0x9c>
	
	PcdAntennaOff();
800037b2:	f0 1f 00 13 	mcall	800037fc <rc522_init+0xa0>
	
	delay_ms(2); 
800037b6:	30 2c       	mov	r12,2
800037b8:	f0 1f 00 12 	mcall	80003800 <rc522_init+0xa4>
	
	PcdAntennaOn();
800037bc:	f0 1f 00 12 	mcall	80003804 <rc522_init+0xa8>
	
	M500PcdConfigISOType( 'A' );
800037c0:	34 1c       	mov	r12,65
800037c2:	f0 1f 00 12 	mcall	80003808 <rc522_init+0xac>
	
	Powerdown_RC522(ENTER_POWERDOWN);
800037c6:	30 1c       	mov	r12,1
800037c8:	f0 1f 00 11 	mcall	8000380c <rc522_init+0xb0>
	//Powerdown_RC522(ENTER_POWERDOWN);
	
	//Powerdown_RC522(WAKEUP_RC522);
	

800037cc:	2f cd       	sub	sp,-16
800037ce:	e3 cd 80 80 	ldm	sp++,r7,pc
800037d2:	00 00       	add	r0,r0
800037d4:	80 00       	ld.sh	r0,r0[0x0]
800037d6:	c9 90       	breq	80003708 <M500PcdConfigISOType+0x1c>
800037d8:	80 00       	ld.sh	r0,r0[0x0]
800037da:	c9 a8       	rjmp	8000390e <PcdComMF522+0xfe>
800037dc:	80 00       	ld.sh	r0,r0[0x0]
800037de:	47 3c       	lddsp	r12,sp[0x1cc]
800037e0:	80 00       	ld.sh	r0,r0[0x0]
800037e2:	47 6c       	lddsp	r12,sp[0x1d8]
800037e4:	80 00       	ld.sh	r0,r0[0x0]
800037e6:	47 84       	lddsp	r4,sp[0x1e0]
800037e8:	00 00       	add	r0,r0
800037ea:	1f a0       	ld.ub	r0,pc[0x2]
800037ec:	80 00       	ld.sh	r0,r0[0x0]
800037ee:	4c 54       	lddpc	r4,80003900 <PcdComMF522+0xf0>
800037f0:	00 00       	add	r0,r0
800037f2:	0a 64       	and	r4,r5
800037f4:	80 00       	ld.sh	r0,r0[0x0]
800037f6:	34 a0       	mov	r0,74
800037f8:	80 00       	ld.sh	r0,r0[0x0]
800037fa:	35 4c       	mov	r12,84
800037fc:	80 00       	ld.sh	r0,r0[0x0]
800037fe:	36 dc       	mov	r12,109
80003800:	80 00       	ld.sh	r0,r0[0x0]
80003802:	3e 94       	mov	r4,-23
80003804:	80 00       	ld.sh	r0,r0[0x0]
80003806:	36 94       	mov	r4,105
80003808:	80 00       	ld.sh	r0,r0[0x0]
8000380a:	36 ec       	mov	r12,110
8000380c:	80 00       	ld.sh	r0,r0[0x0]
8000380e:	36 24       	mov	r4,98

80003810 <PcdComMF522>:
char PcdComMF522(U8  Command,
				 U8 *pIn ,
				 U8  InLenByte,
				 U8 *pOut ,
				 U8 *pOutLenBit)
{
80003810:	d4 31       	pushm	r0-r7,lr
80003812:	20 1d       	sub	sp,4
80003814:	18 92       	mov	r2,r12
80003816:	16 95       	mov	r5,r11
80003818:	14 96       	mov	r6,r10
8000381a:	50 09       	stdsp	sp[0x0],r9
8000381c:	10 90       	mov	r0,r8
8000381e:	f8 c8 00 0c 	sub	r8,r12,12
80003822:	5c 58       	castu.b	r8
80003824:	30 29       	mov	r9,2
80003826:	f2 08 18 00 	cp.b	r8,r9
8000382a:	e0 88 00 05 	brls	80003834 <PcdComMF522+0x24>
8000382e:	30 03       	mov	r3,0
80003830:	06 91       	mov	r1,r3
80003832:	c0 78       	rjmp	80003840 <PcdComMF522+0x30>
80003834:	4c f9       	lddpc	r9,80003970 <PcdComMF522+0x160>
80003836:	f2 08 07 01 	ld.ub	r1,r9[r8]
8000383a:	4c f9       	lddpc	r9,80003974 <PcdComMF522+0x164>
8000383c:	f2 08 07 03 	ld.ub	r3,r9[r8]
		break;
		default:
		break;
	}
	
	WriteRawRC(ComIEnReg,irqEn|0x80);
80003840:	02 9b       	mov	r11,r1
80003842:	a7 bb       	sbr	r11,0x7
80003844:	30 2c       	mov	r12,2
80003846:	f0 1f 00 4d 	mcall	80003978 <PcdComMF522+0x168>
	ClearBitMask(ComIrqReg,0x80);	//娓涓浣
8000384a:	e0 6b 00 80 	mov	r11,128
8000384e:	30 4c       	mov	r12,4
80003850:	f0 1f 00 4b 	mcall	8000397c <PcdComMF522+0x16c>
	WriteRawRC(CommandReg,PCD_IDLE);
80003854:	30 0b       	mov	r11,0
80003856:	30 1c       	mov	r12,1
80003858:	f0 1f 00 48 	mcall	80003978 <PcdComMF522+0x168>
	SetBitMask(FIFOLevelReg,0x80);	 	//娓FIFO缂瀛
8000385c:	e0 6b 00 80 	mov	r11,128
80003860:	30 ac       	mov	r12,10
80003862:	f0 1f 00 48 	mcall	80003980 <PcdComMF522+0x170>
	
	for (i=0; i<InLenByte; i++)
80003866:	58 06       	cp.w	r6,0
80003868:	c0 c0       	breq	80003880 <PcdComMF522+0x70>
8000386a:	0a 97       	mov	r7,r5
	{   
		WriteRawRC(FIFODataReg, pIn [i]);
8000386c:	30 94       	mov	r4,9
8000386e:	0f 3b       	ld.ub	r11,r7++
80003870:	08 9c       	mov	r12,r4
80003872:	f0 1f 00 42 	mcall	80003978 <PcdComMF522+0x168>
	WriteRawRC(ComIEnReg,irqEn|0x80);
	ClearBitMask(ComIrqReg,0x80);	//娓涓浣
	WriteRawRC(CommandReg,PCD_IDLE);
	SetBitMask(FIFOLevelReg,0x80);	 	//娓FIFO缂瀛
	
	for (i=0; i<InLenByte; i++)
80003876:	0e 98       	mov	r8,r7
80003878:	0a 18       	sub	r8,r5
8000387a:	ec 08 19 00 	cp.h	r8,r6
8000387e:	cf 83       	brcs	8000386e <PcdComMF522+0x5e>
	{   
		WriteRawRC(FIFODataReg, pIn [i]);
	}
	WriteRawRC(CommandReg, Command);
80003880:	04 9b       	mov	r11,r2
80003882:	30 1c       	mov	r12,1
80003884:	f0 1f 00 3d 	mcall	80003978 <PcdComMF522+0x168>
	
	if (Command == PCD_TRANSCEIVE)
80003888:	30 c8       	mov	r8,12
8000388a:	f0 02 18 00 	cp.b	r2,r8
8000388e:	c0 61       	brne	8000389a <PcdComMF522+0x8a>
	{    
		SetBitMask(BitFramingReg,0x80);  
80003890:	e0 6b 00 80 	mov	r11,128
80003894:	30 dc       	mov	r12,13
80003896:	f0 1f 00 3b 	mcall	80003980 <PcdComMF522+0x170>
	
	//i = 600;//规堕棰璋达浣M1℃澶х寰堕25ms
	i = 2000;
	do
	{
		n = ReadRawRC(ComIrqReg);
8000389a:	30 4c       	mov	r12,4
8000389c:	f0 1f 00 3a 	mcall	80003984 <PcdComMF522+0x174>
800038a0:	18 97       	mov	r7,r12
800038a2:	e0 66 07 cf 	mov	r6,1999
		i--;
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
800038a6:	30 05       	mov	r5,0
	
	//i = 600;//规堕棰璋达浣M1℃澶х寰堕25ms
	i = 2000;
	do
	{
		n = ReadRawRC(ComIrqReg);
800038a8:	30 44       	mov	r4,4
800038aa:	c0 88       	rjmp	800038ba <PcdComMF522+0xaa>
800038ac:	08 9c       	mov	r12,r4
800038ae:	f0 1f 00 36 	mcall	80003984 <PcdComMF522+0x174>
800038b2:	18 97       	mov	r7,r12
		i--;
800038b4:	20 16       	sub	r6,1
800038b6:	5c 86       	casts.h	r6
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
800038b8:	c0 a0       	breq	800038cc <PcdComMF522+0xbc>
800038ba:	f1 d7 c0 01 	bfextu	r8,r7,0x0,0x1
800038be:	c4 c1       	brne	80003956 <PcdComMF522+0x146>
800038c0:	ef e3 00 08 	and	r8,r7,r3
800038c4:	ea 08 18 00 	cp.b	r8,r5
800038c8:	cf 20       	breq	800038ac <PcdComMF522+0x9c>
800038ca:	c4 68       	rjmp	80003956 <PcdComMF522+0x146>
	ClearBitMask(BitFramingReg,0x80);
800038cc:	e0 6b 00 80 	mov	r11,128
800038d0:	30 dc       	mov	r12,13
800038d2:	f0 1f 00 2b 	mcall	8000397c <PcdComMF522+0x16c>
800038d6:	30 27       	mov	r7,2
800038d8:	c3 38       	rjmp	8000393e <PcdComMF522+0x12e>
800038da:	02 67       	and	r7,r1
800038dc:	ef d7 c0 01 	bfextu	r7,r7,0x0,0x1
		if(!(ReadRawRC(ErrorReg)&0x1B))
		{
			status = MI_OK;
			if (n & irqEn & 0x01)
			{   status = MI_NOTAGERR;   }
			if (Command == PCD_TRANSCEIVE)
800038e0:	30 c8       	mov	r8,12
800038e2:	f0 02 18 00 	cp.b	r2,r8
800038e6:	c2 c1       	brne	8000393e <PcdComMF522+0x12e>
			{
				n = ReadRawRC(FIFOLevelReg);
800038e8:	30 ac       	mov	r12,10
800038ea:	f0 1f 00 27 	mcall	80003984 <PcdComMF522+0x174>
800038ee:	18 94       	mov	r4,r12
				lastBits = ReadRawRC(ControlReg) & 0x07;
800038f0:	30 cc       	mov	r12,12
800038f2:	f0 1f 00 25 	mcall	80003984 <PcdComMF522+0x174>
800038f6:	f9 dc c0 03 	bfextu	r12,r12,0x0,0x3
				if (lastBits)
800038fa:	c0 70       	breq	80003908 <PcdComMF522+0xf8>
				{   *pOutLenBit = (n-1)*8 + lastBits;   }
800038fc:	08 98       	mov	r8,r4
800038fe:	20 18       	sub	r8,1
80003900:	f8 08 00 3c 	add	r12,r12,r8<<0x3
80003904:	a0 8c       	st.b	r0[0x0],r12
80003906:	c0 48       	rjmp	8000390e <PcdComMF522+0xfe>
				else
				{   *pOutLenBit = n*8;   }
80003908:	e8 08 15 03 	lsl	r8,r4,0x3
8000390c:	a0 88       	st.b	r0[0x0],r8
				if (n == 0)
8000390e:	58 04       	cp.w	r4,0
80003910:	c0 61       	brne	8000391c <PcdComMF522+0x10c>
80003912:	30 14       	mov	r4,1
80003914:	40 05       	lddsp	r5,sp[0x0]
80003916:	0a 96       	mov	r6,r5
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
				{   pOut [i] = ReadRawRC(FIFODataReg);    }
80003918:	30 93       	mov	r3,9
8000391a:	c0 98       	rjmp	8000392c <PcdComMF522+0x11c>
				{   *pOutLenBit = n*8;   }
				if (n == 0)
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
8000391c:	31 28       	mov	r8,18
8000391e:	f0 04 18 00 	cp.b	r4,r8
80003922:	f9 b4 0b 12 	movhi	r4,18
80003926:	58 04       	cp.w	r4,0
80003928:	cf 61       	brne	80003914 <PcdComMF522+0x104>
8000392a:	c0 a8       	rjmp	8000393e <PcdComMF522+0x12e>
				{   pOut [i] = ReadRawRC(FIFODataReg);    }
8000392c:	06 9c       	mov	r12,r3
8000392e:	f0 1f 00 16 	mcall	80003984 <PcdComMF522+0x174>
80003932:	0c cc       	st.b	r6++,r12
				{   *pOutLenBit = n*8;   }
				if (n == 0)
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
80003934:	ec 05 01 08 	sub	r8,r6,r5
80003938:	e8 08 19 00 	cp.h	r8,r4
8000393c:	cf 83       	brcs	8000392c <PcdComMF522+0x11c>
		{   status = MI_ERR;   }
		
	}
	

	SetBitMask(ControlReg,0x80);           // stop timer now
8000393e:	e0 6b 00 80 	mov	r11,128
80003942:	30 cc       	mov	r12,12
80003944:	f0 1f 00 0f 	mcall	80003980 <PcdComMF522+0x170>
	WriteRawRC(CommandReg,PCD_IDLE);
80003948:	30 0b       	mov	r11,0
8000394a:	30 1c       	mov	r12,1
8000394c:	f0 1f 00 0b 	mcall	80003978 <PcdComMF522+0x168>
	return status;
}
80003950:	0e 9c       	mov	r12,r7
80003952:	2f fd       	sub	sp,-4
80003954:	d8 32       	popm	r0-r7,pc
	{
		n = ReadRawRC(ComIrqReg);
		i--;
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
	ClearBitMask(BitFramingReg,0x80);
80003956:	e0 6b 00 80 	mov	r11,128
8000395a:	30 dc       	mov	r12,13
8000395c:	f0 1f 00 08 	mcall	8000397c <PcdComMF522+0x16c>

	if (i!=0)
	{
		if(!(ReadRawRC(ErrorReg)&0x1B))
80003960:	30 6c       	mov	r12,6
80003962:	f0 1f 00 09 	mcall	80003984 <PcdComMF522+0x174>
80003966:	e2 1c 00 1b 	andl	r12,0x1b,COH
8000396a:	cb 80       	breq	800038da <PcdComMF522+0xca>
8000396c:	30 27       	mov	r7,2
8000396e:	ce 8b       	rjmp	8000393e <PcdComMF522+0x12e>
80003970:	80 00       	ld.sh	r0,r0[0x0]
80003972:	c9 a4       	brge	800038a6 <PcdComMF522+0x96>
80003974:	80 00       	ld.sh	r0,r0[0x0]
80003976:	c9 a0       	breq	800038aa <PcdComMF522+0x9a>
80003978:	80 00       	ld.sh	r0,r0[0x0]
8000397a:	35 0c       	mov	r12,80
8000397c:	80 00       	ld.sh	r0,r0[0x0]
8000397e:	36 b4       	mov	r4,107
80003980:	80 00       	ld.sh	r0,r0[0x0]
80003982:	36 70       	mov	r0,103
80003984:	80 00       	ld.sh	r0,r0[0x0]
80003986:	35 cc       	mov	r12,92

80003988 <PcdAnticoll>:
//    斤插叉
//拌存: pSnr[OUT]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdAnticoll(U8 *pSnr)
{
80003988:	eb cd 40 c0 	pushm	r6-r7,lr
8000398c:	20 5d       	sub	sp,20
8000398e:	18 96       	mov	r6,r12
	U8   i,snr_check=0;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];
	

	ClearBitMask(Status2Reg,0x08);
80003990:	30 8b       	mov	r11,8
80003992:	16 9c       	mov	r12,r11
80003994:	f0 1f 00 1a 	mcall	800039fc <PcdAnticoll+0x74>
	WriteRawRC(BitFramingReg,0x00);
80003998:	30 0b       	mov	r11,0
8000399a:	30 dc       	mov	r12,13
8000399c:	f0 1f 00 19 	mcall	80003a00 <PcdAnticoll+0x78>
	ClearBitMask(CollReg,0x80);
800039a0:	e0 6b 00 80 	mov	r11,128
800039a4:	30 ec       	mov	r12,14
800039a6:	f0 1f 00 16 	mcall	800039fc <PcdAnticoll+0x74>
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
800039aa:	39 38       	mov	r8,-109
800039ac:	ba 88       	st.b	sp[0x0],r8
	ucComMF522Buf[1] = 0x20;
800039ae:	32 08       	mov	r8,32
800039b0:	ba 98       	st.b	sp[0x1],r8

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,2,ucComMF522Buf,&unLen);
800039b2:	1a 9b       	mov	r11,sp
800039b4:	fa c8 ff ed 	sub	r8,sp,-19
800039b8:	1a 99       	mov	r9,sp
800039ba:	30 2a       	mov	r10,2
800039bc:	30 cc       	mov	r12,12
800039be:	f0 1f 00 12 	mcall	80003a04 <PcdAnticoll+0x7c>
800039c2:	18 97       	mov	r7,r12

	if (status == MI_OK)
800039c4:	c1 21       	brne	800039e8 <PcdAnticoll+0x60>
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
800039c6:	1b 89       	ld.ub	r9,sp[0x0]
800039c8:	ac 89       	st.b	r6[0x0],r9
800039ca:	1b 98       	ld.ub	r8,sp[0x1]
800039cc:	ac 98       	st.b	r6[0x1],r8
			snr_check ^= ucComMF522Buf[i];
800039ce:	10 59       	eor	r9,r8

	if (status == MI_OK)
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
800039d0:	1b a8       	ld.ub	r8,sp[0x2]
800039d2:	ac a8       	st.b	r6[0x2],r8
			snr_check ^= ucComMF522Buf[i];
800039d4:	f3 e8 20 08 	eor	r8,r9,r8

	if (status == MI_OK)
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
800039d8:	1b b9       	ld.ub	r9,sp[0x3]
800039da:	ac b9       	st.b	r6[0x3],r9
			snr_check ^= ucComMF522Buf[i];
800039dc:	12 58       	eor	r8,r9
		}
		if (snr_check != ucComMF522Buf[i])
800039de:	1b c9       	ld.ub	r9,sp[0x4]
800039e0:	f0 09 18 00 	cp.b	r9,r8
800039e4:	f9 b7 01 02 	movne	r7,2
		{   status = MI_ERR;    }
	}
	
	SetBitMask(CollReg,0x80);
800039e8:	e0 6b 00 80 	mov	r11,128
800039ec:	30 ec       	mov	r12,14
800039ee:	f0 1f 00 07 	mcall	80003a08 <PcdAnticoll+0x80>
	return status;
}
800039f2:	0e 9c       	mov	r12,r7
800039f4:	2f bd       	sub	sp,-20
800039f6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800039fa:	00 00       	add	r0,r0
800039fc:	80 00       	ld.sh	r0,r0[0x0]
800039fe:	36 b4       	mov	r4,107
80003a00:	80 00       	ld.sh	r0,r0[0x0]
80003a02:	35 0c       	mov	r12,80
80003a04:	80 00       	ld.sh	r0,r0[0x0]
80003a06:	38 10       	mov	r0,-127
80003a08:	80 00       	ld.sh	r0,r0[0x0]
80003a0a:	36 70       	mov	r0,103

80003a0c <PcdRequest>:
//                0x0800 = Mifare_Pro(X)
//                0x4403 = Mifare_DESFire
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdRequest(U8   req_code,U8 *pTagType)
{
80003a0c:	eb cd 40 c0 	pushm	r6-r7,lr
80003a10:	20 5d       	sub	sp,20
80003a12:	18 97       	mov	r7,r12
80003a14:	16 96       	mov	r6,r11
	char   status;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];

	ClearBitMask(Status2Reg,0x08);
80003a16:	30 8b       	mov	r11,8
80003a18:	16 9c       	mov	r12,r11
80003a1a:	f0 1f 00 12 	mcall	80003a60 <PcdRequest+0x54>
	WriteRawRC(BitFramingReg,0x07);
80003a1e:	30 7b       	mov	r11,7
80003a20:	30 dc       	mov	r12,13
80003a22:	f0 1f 00 11 	mcall	80003a64 <PcdRequest+0x58>
	SetBitMask(TxControlReg,0x03);
80003a26:	30 3b       	mov	r11,3
80003a28:	31 4c       	mov	r12,20
80003a2a:	f0 1f 00 10 	mcall	80003a68 <PcdRequest+0x5c>
	
	ucComMF522Buf[0] = req_code;
80003a2e:	ba 87       	st.b	sp[0x0],r7

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,1,ucComMF522Buf,&unLen);
80003a30:	1a 9b       	mov	r11,sp
80003a32:	fa c8 ff ed 	sub	r8,sp,-19
80003a36:	1a 99       	mov	r9,sp
80003a38:	30 1a       	mov	r10,1
80003a3a:	30 cc       	mov	r12,12
80003a3c:	f0 1f 00 0c 	mcall	80003a6c <PcdRequest+0x60>

	if ((status == MI_OK) && (unLen == 0x10))
80003a40:	c0 c1       	brne	80003a58 <PcdRequest+0x4c>
80003a42:	31 08       	mov	r8,16
80003a44:	fb 39 00 13 	ld.ub	r9,sp[19]
80003a48:	f0 09 18 00 	cp.b	r9,r8
80003a4c:	c0 61       	brne	80003a58 <PcdRequest+0x4c>
	{
		*pTagType     = ucComMF522Buf[0];
80003a4e:	1b 88       	ld.ub	r8,sp[0x0]
80003a50:	ac 88       	st.b	r6[0x0],r8
		*(pTagType+1) = ucComMF522Buf[1];
80003a52:	1b 98       	ld.ub	r8,sp[0x1]
80003a54:	ac 98       	st.b	r6[0x1],r8
	
	ucComMF522Buf[0] = req_code;

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,1,ucComMF522Buf,&unLen);

	if ((status == MI_OK) && (unLen == 0x10))
80003a56:	c0 28       	rjmp	80003a5a <PcdRequest+0x4e>
80003a58:	30 2c       	mov	r12,2
	}
	else
	{   status = MI_ERR;   }
	
	return status;
}
80003a5a:	2f bd       	sub	sp,-20
80003a5c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80003a60:	80 00       	ld.sh	r0,r0[0x0]
80003a62:	36 b4       	mov	r4,107
80003a64:	80 00       	ld.sh	r0,r0[0x0]
80003a66:	35 0c       	mov	r12,80
80003a68:	80 00       	ld.sh	r0,r0[0x0]
80003a6a:	36 70       	mov	r0,103
80003a6c:	80 00       	ld.sh	r0,r0[0x0]
80003a6e:	38 10       	mov	r0,-127

80003a70 <CalulateCRC>:

/////////////////////////////////////////////////////////////////////
//MF522璁＄CRC16芥
/////////////////////////////////////////////////////////////////////
void CalulateCRC(U8 *pIn ,U8   len,U8 *pOut )
{
80003a70:	eb cd 40 f8 	pushm	r3-r7,lr
80003a74:	18 95       	mov	r5,r12
80003a76:	16 96       	mov	r6,r11
80003a78:	14 93       	mov	r3,r10
	U8   i,n;
	ClearBitMask(DivIrqReg,0x04);
80003a7a:	30 4b       	mov	r11,4
80003a7c:	30 5c       	mov	r12,5
80003a7e:	f0 1f 00 1c 	mcall	80003aec <CalulateCRC+0x7c>
	WriteRawRC(CommandReg,PCD_IDLE);
80003a82:	30 0b       	mov	r11,0
80003a84:	30 1c       	mov	r12,1
80003a86:	f0 1f 00 1b 	mcall	80003af0 <CalulateCRC+0x80>
	SetBitMask(FIFOLevelReg,0x80);
80003a8a:	e0 6b 00 80 	mov	r11,128
80003a8e:	30 ac       	mov	r12,10
80003a90:	f0 1f 00 19 	mcall	80003af4 <CalulateCRC+0x84>
	for (i=0; i<len; i++)
80003a94:	58 06       	cp.w	r6,0
80003a96:	c0 c0       	breq	80003aae <CalulateCRC+0x3e>
80003a98:	0a 97       	mov	r7,r5
	{   WriteRawRC(FIFODataReg, *(pIn +i));   }
80003a9a:	30 94       	mov	r4,9
80003a9c:	0f 3b       	ld.ub	r11,r7++
80003a9e:	08 9c       	mov	r12,r4
80003aa0:	f0 1f 00 14 	mcall	80003af0 <CalulateCRC+0x80>
{
	U8   i,n;
	ClearBitMask(DivIrqReg,0x04);
	WriteRawRC(CommandReg,PCD_IDLE);
	SetBitMask(FIFOLevelReg,0x80);
	for (i=0; i<len; i++)
80003aa4:	0e 98       	mov	r8,r7
80003aa6:	0a 18       	sub	r8,r5
80003aa8:	ec 08 18 00 	cp.b	r8,r6
80003aac:	cf 83       	brcs	80003a9c <CalulateCRC+0x2c>
	{   WriteRawRC(FIFODataReg, *(pIn +i));   }
	WriteRawRC(CommandReg, PCD_CALCCRC);
80003aae:	30 3b       	mov	r11,3
80003ab0:	30 1c       	mov	r12,1
80003ab2:	f0 1f 00 10 	mcall	80003af0 <CalulateCRC+0x80>
	i = 0xFF;
	do
	{
		n = ReadRawRC(DivIrqReg);
80003ab6:	30 5c       	mov	r12,5
80003ab8:	f0 1f 00 10 	mcall	80003af8 <CalulateCRC+0x88>
80003abc:	e0 67 00 fe 	mov	r7,254
80003ac0:	30 56       	mov	r6,5
80003ac2:	c0 78       	rjmp	80003ad0 <CalulateCRC+0x60>
80003ac4:	0c 9c       	mov	r12,r6
80003ac6:	f0 1f 00 0d 	mcall	80003af8 <CalulateCRC+0x88>
		i--;
80003aca:	20 17       	sub	r7,1
80003acc:	5c 57       	castu.b	r7
	}
	while ((i!=0) && !(n&0x04));
80003ace:	c0 40       	breq	80003ad6 <CalulateCRC+0x66>
80003ad0:	e2 1c 00 04 	andl	r12,0x4,COH
80003ad4:	cf 80       	breq	80003ac4 <CalulateCRC+0x54>
	pOut [0] = ReadRawRC(CRCResultRegL);
80003ad6:	32 2c       	mov	r12,34
80003ad8:	f0 1f 00 08 	mcall	80003af8 <CalulateCRC+0x88>
80003adc:	a6 8c       	st.b	r3[0x0],r12
	pOut [1] = ReadRawRC(CRCResultRegM);
80003ade:	32 1c       	mov	r12,33
80003ae0:	f0 1f 00 06 	mcall	80003af8 <CalulateCRC+0x88>
80003ae4:	a6 9c       	st.b	r3[0x1],r12
}
80003ae6:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80003aea:	00 00       	add	r0,r0
80003aec:	80 00       	ld.sh	r0,r0[0x0]
80003aee:	36 b4       	mov	r4,107
80003af0:	80 00       	ld.sh	r0,r0[0x0]
80003af2:	35 0c       	mov	r12,80
80003af4:	80 00       	ld.sh	r0,r0[0x0]
80003af6:	36 70       	mov	r0,103
80003af8:	80 00       	ld.sh	r0,r0[0x0]
80003afa:	35 cc       	mov	r12,92

80003afc <PcdSelect>:
//    斤瀹＄
//拌存: pSnr[IN]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdSelect(U8 *pSnr)
{
80003afc:	eb cd 40 80 	pushm	r7,lr
80003b00:	20 5d       	sub	sp,20
	char   status;
	U8   i;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
80003b02:	39 38       	mov	r8,-109
80003b04:	ba 88       	st.b	sp[0x0],r8
	ucComMF522Buf[1] = 0x70;
80003b06:	37 08       	mov	r8,112
80003b08:	ba 98       	st.b	sp[0x1],r8
	ucComMF522Buf[6] = 0;
80003b0a:	30 08       	mov	r8,0
80003b0c:	ba e8       	st.b	sp[0x6],r8
80003b0e:	fa c8 ff fe 	sub	r8,sp,-2
/////////////////////////////////////////////////////////////////////
//    斤瀹＄
//拌存: pSnr[IN]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdSelect(U8 *pSnr)
80003b12:	fa cb ff fa 	sub	r11,sp,-6
	ucComMF522Buf[0] = PICC_ANTICOLL1;
	ucComMF522Buf[1] = 0x70;
	ucComMF522Buf[6] = 0;
	for (i=0; i<4; i++)
	{
		ucComMF522Buf[i+2] = *(pSnr+i);
80003b16:	19 89       	ld.ub	r9,r12[0x0]
80003b18:	10 c9       	st.b	r8++,r9
		ucComMF522Buf[6]  ^= *(pSnr+i);
80003b1a:	19 3a       	ld.ub	r10,r12++
80003b1c:	1b e9       	ld.ub	r9,sp[0x6]
80003b1e:	f5 e9 20 09 	eor	r9,r10,r9
80003b22:	ba e9       	st.b	sp[0x6],r9
	U8   ucComMF522Buf[MAXRLEN];
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
	ucComMF522Buf[1] = 0x70;
	ucComMF522Buf[6] = 0;
	for (i=0; i<4; i++)
80003b24:	16 38       	cp.w	r8,r11
80003b26:	cf 81       	brne	80003b16 <PcdSelect+0x1a>
	{
		ucComMF522Buf[i+2] = *(pSnr+i);
		ucComMF522Buf[6]  ^= *(pSnr+i);
	}
	CalulateCRC(ucComMF522Buf,7,&ucComMF522Buf[7]);
80003b28:	1a 97       	mov	r7,sp
80003b2a:	fa ca ff f9 	sub	r10,sp,-7
80003b2e:	30 7b       	mov	r11,7
80003b30:	1a 9c       	mov	r12,sp
80003b32:	f0 1f 00 0d 	mcall	80003b64 <PcdSelect+0x68>
	
	ClearBitMask(Status2Reg,0x08);
80003b36:	30 8b       	mov	r11,8
80003b38:	16 9c       	mov	r12,r11
80003b3a:	f0 1f 00 0c 	mcall	80003b68 <PcdSelect+0x6c>

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,9,ucComMF522Buf,&unLen);
80003b3e:	fa c8 ff ed 	sub	r8,sp,-19
80003b42:	1a 99       	mov	r9,sp
80003b44:	30 9a       	mov	r10,9
80003b46:	1a 9b       	mov	r11,sp
80003b48:	30 cc       	mov	r12,12
80003b4a:	f0 1f 00 09 	mcall	80003b6c <PcdSelect+0x70>
	
	if ((status == MI_OK) && (unLen == 0x18))
80003b4e:	c0 71       	brne	80003b5c <PcdSelect+0x60>
80003b50:	31 88       	mov	r8,24
80003b52:	fb 39 00 13 	ld.ub	r9,sp[19]
80003b56:	f0 09 18 00 	cp.b	r9,r8
80003b5a:	c0 20       	breq	80003b5e <PcdSelect+0x62>
80003b5c:	30 2c       	mov	r12,2
	{   status = MI_OK;  }
	else
	{   status = MI_ERR;    }

	return status;
}
80003b5e:	2f bd       	sub	sp,-20
80003b60:	e3 cd 80 80 	ldm	sp++,r7,pc
80003b64:	80 00       	ld.sh	r0,r0[0x0]
80003b66:	3a 70       	mov	r0,-89
80003b68:	80 00       	ld.sh	r0,r0[0x0]
80003b6a:	36 b4       	mov	r4,107
80003b6c:	80 00       	ld.sh	r0,r0[0x0]
80003b6e:	38 10       	mov	r0,-127

80003b70 <rfid_auto_reader>:
		//
}

//娴绋锛瀵诲->插叉->->″
U8 rfid_auto_reader(void *card_id)
{
80003b70:	eb cd 40 c0 	pushm	r6-r7,lr
80003b74:	18 96       	mov	r6,r12
	U8 status = MI_ERR;
	
	PcdReset();
80003b76:	f0 1f 00 37 	mcall	80003c50 <rfid_auto_reader+0xe0>
//while(1){
	status=PcdRequest(PICC_REQALL,	CT);//瀵诲ぉ绾垮哄ㄩㄧ★杩＄绫诲 2瀛
80003b7a:	4b 7b       	lddpc	r11,80003c54 <rfid_auto_reader+0xe4>
80003b7c:	35 2c       	mov	r12,82
80003b7e:	f0 1f 00 37 	mcall	80003c58 <rfid_auto_reader+0xe8>
80003b82:	18 97       	mov	r7,r12
	if(status!=MI_OK) return status;
80003b84:	c6 31       	brne	80003c4a <rfid_auto_reader+0xda>
	//continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
80003b86:	4b 48       	lddpc	r8,80003c54 <rfid_auto_reader+0xe4>
80003b88:	11 88       	ld.ub	r8,r8[0x0]
80003b8a:	30 49       	mov	r9,4
80003b8c:	f2 08 18 00 	cp.b	r8,r9
80003b90:	c0 b1       	brne	80003ba6 <rfid_auto_reader+0x36>
80003b92:	4b 19       	lddpc	r9,80003c54 <rfid_auto_reader+0xe4>
80003b94:	13 9a       	ld.ub	r10,r9[0x1]
80003b96:	30 09       	mov	r9,0
80003b98:	f2 0a 18 00 	cp.b	r10,r9
80003b9c:	c0 51       	brne	80003ba6 <rfid_auto_reader+0x36>
		log("MFOne-S50\n");
80003b9e:	4b 0c       	lddpc	r12,80003c5c <rfid_auto_reader+0xec>
80003ba0:	f0 1f 00 30 	mcall	80003c60 <rfid_auto_reader+0xf0>
//while(1){
	status=PcdRequest(PICC_REQALL,	CT);//瀵诲ぉ绾垮哄ㄩㄧ★杩＄绫诲 2瀛
	if(status!=MI_OK) return status;
	//continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
80003ba4:	c3 c8       	rjmp	80003c1c <rfid_auto_reader+0xac>
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
80003ba6:	30 29       	mov	r9,2
80003ba8:	f2 08 18 00 	cp.b	r8,r9
80003bac:	c0 b1       	brne	80003bc2 <rfid_auto_reader+0x52>
80003bae:	4a a9       	lddpc	r9,80003c54 <rfid_auto_reader+0xe4>
80003bb0:	13 9a       	ld.ub	r10,r9[0x1]
80003bb2:	30 09       	mov	r9,0
80003bb4:	f2 0a 18 00 	cp.b	r10,r9
80003bb8:	c0 51       	brne	80003bc2 <rfid_auto_reader+0x52>
		log("MFOne-S70\n");
80003bba:	4a bc       	lddpc	r12,80003c64 <rfid_auto_reader+0xf4>
80003bbc:	f0 1f 00 29 	mcall	80003c60 <rfid_auto_reader+0xf0>
	if(status!=MI_OK) return status;
	//continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
80003bc0:	c2 e8       	rjmp	80003c1c <rfid_auto_reader+0xac>
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
80003bc2:	34 49       	mov	r9,68
80003bc4:	f2 08 18 00 	cp.b	r8,r9
80003bc8:	c0 b1       	brne	80003bde <rfid_auto_reader+0x6e>
80003bca:	4a 39       	lddpc	r9,80003c54 <rfid_auto_reader+0xe4>
80003bcc:	13 9a       	ld.ub	r10,r9[0x1]
80003bce:	30 09       	mov	r9,0
80003bd0:	f2 0a 18 00 	cp.b	r10,r9
80003bd4:	c0 51       	brne	80003bde <rfid_auto_reader+0x6e>
		log("MF-UltraLight\n");
80003bd6:	4a 5c       	lddpc	r12,80003c68 <rfid_auto_reader+0xf8>
80003bd8:	f0 1f 00 22 	mcall	80003c60 <rfid_auto_reader+0xf0>
	
	if(CT[0]==0x04&&CT[1]==0x00)
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
80003bdc:	c2 08       	rjmp	80003c1c <rfid_auto_reader+0xac>
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
80003bde:	30 89       	mov	r9,8
80003be0:	f2 08 18 00 	cp.b	r8,r9
80003be4:	c0 b1       	brne	80003bfa <rfid_auto_reader+0x8a>
80003be6:	49 c9       	lddpc	r9,80003c54 <rfid_auto_reader+0xe4>
80003be8:	13 9a       	ld.ub	r10,r9[0x1]
80003bea:	30 09       	mov	r9,0
80003bec:	f2 0a 18 00 	cp.b	r10,r9
80003bf0:	c0 51       	brne	80003bfa <rfid_auto_reader+0x8a>
		log("MF-Pro\n");
80003bf2:	49 fc       	lddpc	r12,80003c6c <rfid_auto_reader+0xfc>
80003bf4:	f0 1f 00 1b 	mcall	80003c60 <rfid_auto_reader+0xf0>
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
80003bf8:	c1 28       	rjmp	80003c1c <rfid_auto_reader+0xac>
		log("MF-Pro\n");
	else if(CT[0]==0x44&&CT[1]==0x03)
80003bfa:	34 49       	mov	r9,68
80003bfc:	f2 08 18 00 	cp.b	r8,r9
80003c00:	c0 b1       	brne	80003c16 <rfid_auto_reader+0xa6>
80003c02:	49 58       	lddpc	r8,80003c54 <rfid_auto_reader+0xe4>
80003c04:	11 99       	ld.ub	r9,r8[0x1]
80003c06:	30 38       	mov	r8,3
80003c08:	f0 09 18 00 	cp.b	r9,r8
80003c0c:	c0 51       	brne	80003c16 <rfid_auto_reader+0xa6>
		log("MF Desire\n");
80003c0e:	49 9c       	lddpc	r12,80003c70 <rfid_auto_reader+0x100>
80003c10:	f0 1f 00 14 	mcall	80003c60 <rfid_auto_reader+0xf0>
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
		log("MF-Pro\n");
	else if(CT[0]==0x44&&CT[1]==0x03)
80003c14:	c0 48       	rjmp	80003c1c <rfid_auto_reader+0xac>
		log("MF Desire\n");
	else
		log("Unknown\n");
80003c16:	49 8c       	lddpc	r12,80003c74 <rfid_auto_reader+0x104>
80003c18:	f0 1f 00 12 	mcall	80003c60 <rfid_auto_reader+0xf0>
		
	status=PcdAnticoll(SN);//插叉锛杩＄搴 4瀛
80003c1c:	49 7c       	lddpc	r12,80003c78 <rfid_auto_reader+0x108>
80003c1e:	f0 1f 00 18 	mcall	80003c7c <rfid_auto_reader+0x10c>
80003c22:	18 97       	mov	r7,r12
	if(status!=MI_OK)
80003c24:	c0 60       	breq	80003c30 <rfid_auto_reader+0xc0>
	{
		xcmp_IdleTestTone(Tone_Start, BT_Disconnecting_Success_Tone);//set tone to noticy failure!!!
80003c26:	37 8b       	mov	r11,120
80003c28:	30 1c       	mov	r12,1
80003c2a:	f0 1f 00 16 	mcall	80003c80 <rfid_auto_reader+0x110>
		return status;
80003c2e:	c0 e8       	rjmp	80003c4a <rfid_auto_reader+0xda>
		//continue;
	}
	
	//memcpy(MLastSelectedSnr,&RevBuffer[2],4);
	status=PcdSelect(SN);//
80003c30:	49 2c       	lddpc	r12,80003c78 <rfid_auto_reader+0x108>
80003c32:	f0 1f 00 15 	mcall	80003c84 <rfid_auto_reader+0x114>
80003c36:	18 97       	mov	r7,r12
	if(status!=MI_OK)return status;
80003c38:	c0 91       	brne	80003c4a <rfid_auto_reader+0xda>
	//continue;
	else{//℃
			
		memcpy(card_id, SN, 4);
80003c3a:	30 4a       	mov	r10,4
80003c3c:	48 fb       	lddpc	r11,80003c78 <rfid_auto_reader+0x108>
80003c3e:	0c 9c       	mov	r12,r6
80003c40:	f0 1f 00 12 	mcall	80003c88 <rfid_auto_reader+0x118>
		log("select okay\n");
80003c44:	49 2c       	lddpc	r12,80003c8c <rfid_auto_reader+0x11c>
80003c46:	f0 1f 00 07 	mcall	80003c60 <rfid_auto_reader+0xf0>
		return status;	
	}
	
//}
	
}
80003c4a:	0e 9c       	mov	r12,r7
80003c4c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80003c50:	80 00       	ld.sh	r0,r0[0x0]
80003c52:	35 4c       	mov	r12,84
80003c54:	00 00       	add	r0,r0
80003c56:	1f b8       	ld.ub	r8,pc[0x3]
80003c58:	80 00       	ld.sh	r0,r0[0x0]
80003c5a:	3a 0c       	mov	r12,-96
80003c5c:	80 00       	ld.sh	r0,r0[0x0]
80003c5e:	c9 b0       	breq	80003b94 <rfid_auto_reader+0x24>
80003c60:	80 00       	ld.sh	r0,r0[0x0]
80003c62:	62 b8       	ld.w	r8,r1[0x2c]
80003c64:	80 00       	ld.sh	r0,r0[0x0]
80003c66:	c9 bc       	rcall	80003d9c <rfid_sendID_message+0xbc>
80003c68:	80 00       	ld.sh	r0,r0[0x0]
80003c6a:	c9 c8       	rjmp	80003da2 <rfid_sendID_message+0xc2>
80003c6c:	80 00       	ld.sh	r0,r0[0x0]
80003c6e:	c9 d8       	rjmp	80003da8 <rfid_sendID_message+0xc8>
80003c70:	80 00       	ld.sh	r0,r0[0x0]
80003c72:	c9 e0       	breq	80003bae <rfid_auto_reader+0x3e>
80003c74:	80 00       	ld.sh	r0,r0[0x0]
80003c76:	c9 ec       	rcall	80003db2 <rfid_sendID_message+0xd2>
80003c78:	00 00       	add	r0,r0
80003c7a:	1f bc       	ld.ub	r12,pc[0x3]
80003c7c:	80 00       	ld.sh	r0,r0[0x0]
80003c7e:	39 88       	mov	r8,-104
80003c80:	80 00       	ld.sh	r0,r0[0x0]
80003c82:	33 38       	mov	r8,51
80003c84:	80 00       	ld.sh	r0,r0[0x0]
80003c86:	3a fc       	mov	r12,-81
80003c88:	80 00       	ld.sh	r0,r0[0x0]
80003c8a:	69 da       	ld.w	r10,r4[0x74]
80003c8c:	80 00       	ld.sh	r0,r0[0x0]
80003c8e:	c9 f8       	rjmp	80003dcc <rfid_sendID_message+0xec>

80003c90 <scan_patrol>:
	return return_err;
	
}

U8 scan_patrol(char* SN)
{
80003c90:	eb cd 40 80 	pushm	r7,lr
80003c94:	18 97       	mov	r7,r12
	U8 return_err = MI_ERR;
	
	PcdReset();
80003c96:	f0 1f 00 0d 	mcall	80003cc8 <scan_patrol+0x38>
	Powerdown_RC522(WAKEUP_RC522);
80003c9a:	30 0c       	mov	r12,0
80003c9c:	f0 1f 00 0c 	mcall	80003ccc <scan_patrol+0x3c>
	return_err = rfid_auto_reader(SN);
80003ca0:	0e 9c       	mov	r12,r7
80003ca2:	f0 1f 00 0c 	mcall	80003cd0 <scan_patrol+0x40>
80003ca6:	18 97       	mov	r7,r12
	Powerdown_RC522(ENTER_POWERDOWN);
80003ca8:	30 1c       	mov	r12,1
80003caa:	f0 1f 00 09 	mcall	80003ccc <scan_patrol+0x3c>
	if(return_err == 0)
80003cae:	58 07       	cp.w	r7,0
80003cb0:	c0 51       	brne	80003cba <scan_patrol+0x2a>
		log("scan_patrol okay!\n");
80003cb2:	48 9c       	lddpc	r12,80003cd4 <scan_patrol+0x44>
80003cb4:	f0 1f 00 09 	mcall	80003cd8 <scan_patrol+0x48>
80003cb8:	c0 48       	rjmp	80003cc0 <scan_patrol+0x30>
	else
		log("scan_patrol err!\n");
80003cba:	48 9c       	lddpc	r12,80003cdc <scan_patrol+0x4c>
80003cbc:	f0 1f 00 07 	mcall	80003cd8 <scan_patrol+0x48>
		
	return return_err;

}
80003cc0:	0e 9c       	mov	r12,r7
80003cc2:	e3 cd 80 80 	ldm	sp++,r7,pc
80003cc6:	00 00       	add	r0,r0
80003cc8:	80 00       	ld.sh	r0,r0[0x0]
80003cca:	35 4c       	mov	r12,84
80003ccc:	80 00       	ld.sh	r0,r0[0x0]
80003cce:	36 24       	mov	r4,98
80003cd0:	80 00       	ld.sh	r0,r0[0x0]
80003cd2:	3b 70       	mov	r0,-73
80003cd4:	80 00       	ld.sh	r0,r0[0x0]
80003cd6:	ca 08       	rjmp	80003e16 <rfid_sendID_message+0x136>
80003cd8:	80 00       	ld.sh	r0,r0[0x0]
80003cda:	62 b8       	ld.w	r8,r1[0x2c]
80003cdc:	80 00       	ld.sh	r0,r0[0x0]
80003cde:	ca 1c       	rcall	80003e20 <rfid_sendID_message+0x140>

80003ce0 <rfid_sendID_message>:
	
}

extern volatile DateTime_t Current_time;
U8 rfid_sendID_message()
{
80003ce0:	eb cd 40 e0 	pushm	r5-r7,lr
80003ce4:	21 cd       	sub	sp,112
	static U8 start_session = 0x80;
	Message_Header_t header;
	Message_Data_t data_buffer;//22bytes
	
	//memset(data_buffer, 0x00, 16);
	memset(SN, 0x00, 10);
80003ce6:	4c ec       	lddpc	r12,80003e1c <rfid_sendID_message+0x13c>
80003ce8:	30 08       	mov	r8,0
80003cea:	30 09       	mov	r9,0
80003cec:	f8 e9 00 00 	st.d	r12[0],r8
80003cf0:	30 0a       	mov	r10,0
80003cf2:	b8 4a       	st.h	r12[0x8],r10
	memset(message, 0x00, 80);
80003cf4:	fa e9 00 20 	st.d	sp[32],r8
80003cf8:	fa e9 00 28 	st.d	sp[40],r8
80003cfc:	fa e9 00 30 	st.d	sp[48],r8
80003d00:	fa e9 00 38 	st.d	sp[56],r8
80003d04:	fa e9 00 40 	st.d	sp[64],r8
80003d08:	fa e9 00 48 	st.d	sp[72],r8
80003d0c:	fa e9 00 50 	st.d	sp[80],r8
80003d10:	fa e9 00 58 	st.d	sp[88],r8
80003d14:	fa e9 00 60 	st.d	sp[96],r8
80003d18:	fa e9 00 68 	st.d	sp[104],r8
	//PcdReset();
	//Powerdown_RC522(WAKEUP_RC522);
	//return_err = rfid_auto_reader(SN);
	//Powerdown_RC522(ENTER_POWERDOWN);
	
	return_err = scan_patrol(SN);
80003d1c:	f0 1f 00 41 	mcall	80003e20 <rfid_sendID_message+0x140>
80003d20:	18 97       	mov	r7,r12
	
	if(return_err == 0){
80003d22:	c7 11       	brne	80003e04 <rfid_sendID_message+0x124>
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
80003d24:	4b e6       	lddpc	r6,80003e1c <rfid_sendID_message+0x13c>
80003d26:	0d b8       	ld.ub	r8,r6[0x3]
80003d28:	1a d8       	st.w	--sp,r8
80003d2a:	0d a8       	ld.ub	r8,r6[0x2]
80003d2c:	1a d8       	st.w	--sp,r8
80003d2e:	0d 98       	ld.ub	r8,r6[0x1]
80003d30:	1a d8       	st.w	--sp,r8
80003d32:	0d 88       	ld.ub	r8,r6[0x0]
80003d34:	1a d8       	st.w	--sp,r8
80003d36:	4b cc       	lddpc	r12,80003e24 <rfid_sendID_message+0x144>
80003d38:	f0 1f 00 3c 	mcall	80003e28 <rfid_sendID_message+0x148>
		xcmp_IdleTestTone(Tone_Start, BT_Connection_Success_Tone);//set tone to indicate scan rfid success!!!		 
80003d3c:	37 7b       	mov	r11,119
80003d3e:	30 1c       	mov	r12,1
80003d40:	f0 1f 00 3b 	mcall	80003e2c <rfid_sendID_message+0x14c>
80003d44:	fa c8 ff f0 	sub	r8,sp,-16
80003d48:	fa c9 ff ee 	sub	r9,sp,-18
//}
	
}

extern volatile DateTime_t Current_time;
U8 rfid_sendID_message()
80003d4c:	ec c5 ff fc 	sub	r5,r6,-4
80003d50:	10 9d       	mov	sp,r8
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, BT_Connection_Success_Tone);//set tone to indicate scan rfid success!!!		 
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″	
		
			 temp = ((SN[i] & 0xF0) >> 4);//瀛楂浣
			 if((temp >= 0) && (temp <= 9))data_buffer.RFID_ID[i*4] = temp+0x30;
80003d52:	30 9e       	mov	lr,9
			 else 
				data_buffer.RFID_ID[i*4] = ((temp - 0x0a)+0x61);
			
			 data_buffer.RFID_ID[i*4+1] = 0x00;
80003d54:	30 0c       	mov	r12,0
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, BT_Connection_Success_Tone);//set tone to indicate scan rfid success!!!		 
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″	
		
			 temp = ((SN[i] & 0xF0) >> 4);//瀛楂浣
80003d56:	0d 8a       	ld.ub	r10,r6[0x0]
80003d58:	f4 0b 16 04 	lsr	r11,r10,0x4
			 if((temp >= 0) && (temp <= 9))data_buffer.RFID_ID[i*4] = temp+0x30;
80003d5c:	fc 0b 18 00 	cp.b	r11,lr
80003d60:	f7 bb 08 d0 	subls	r11,-48
80003d64:	f1 fb 8e 00 	st.bls	r8[0x0],r11
			 else 
				data_buffer.RFID_ID[i*4] = ((temp - 0x0a)+0x61);
80003d68:	f7 bb 0b a9 	subhi	r11,-87
80003d6c:	f1 fb be 00 	st.bhi	r8[0x0],r11
			
			 data_buffer.RFID_ID[i*4+1] = 0x00;
80003d70:	b0 9c       	st.b	r8[0x1],r12
		 
			 temp = (SN[i] & 0x0F);//瀛浣浣
80003d72:	f5 da c0 04 	bfextu	r10,r10,0x0,0x4
			 if((temp >= 0) && (temp <= 9))data_buffer.RFID_ID[i*4+2] = temp+0x30;
80003d76:	fc 0a 18 00 	cp.b	r10,lr
80003d7a:	f7 ba 08 d0 	subls	r10,-48
80003d7e:	f3 fa 8e 00 	st.bls	r9[0x0],r10
			 else
				data_buffer.RFID_ID[i*4+2] = ((temp - 0x0a)+0x61);
80003d82:	f7 ba 0b a9 	subhi	r10,-87
80003d86:	f3 fa be 00 	st.bhi	r9[0x0],r10

			 data_buffer.RFID_ID[i*4+3] = 0x00; 
80003d8a:	b0 bc       	st.b	r8[0x3],r12
80003d8c:	2f f6       	sub	r6,-1
80003d8e:	2f c8       	sub	r8,-4
80003d90:	2f c9       	sub	r9,-4
	
	if(return_err == 0){
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, BT_Connection_Success_Tone);//set tone to indicate scan rfid success!!!		 
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″	
80003d92:	0a 36       	cp.w	r6,r5
80003d94:	ce 11       	brne	80003d56 <rfid_sendID_message+0x76>
				data_buffer.RFID_ID[i*4+2] = ((temp - 0x0a)+0x61);

			 data_buffer.RFID_ID[i*4+3] = 0x00; 
		}
		
		memcpy(&data_buffer.XG_Time.Year, &Current_time.Year, sizeof(DateTime_t))	;
80003d96:	30 6a       	mov	r10,6
80003d98:	4a 6b       	lddpc	r11,80003e30 <rfid_sendID_message+0x150>
80003d9a:	fa cc ff f0 	sub	r12,sp,-16
80003d9e:	f0 1f 00 26 	mcall	80003e34 <rfid_sendID_message+0x154>
	
		header.length = (0x0008 + sizeof(Message_Data_t));
	
		if(start_session > 0x9f)start_session = 0x80;
80003da2:	4a 68       	lddpc	r8,80003e38 <rfid_sendID_message+0x158>
80003da4:	11 89       	ld.ub	r9,r8[0x0]
80003da6:	39 f8       	mov	r8,-97
80003da8:	f0 09 18 00 	cp.b	r9,r8
80003dac:	e0 88 00 05 	brls	80003db6 <rfid_sendID_message+0xd6>
80003db0:	38 09       	mov	r9,-128
80003db2:	4a 28       	lddpc	r8,80003e38 <rfid_sendID_message+0x158>
80003db4:	b0 89       	st.b	r8[0x0],r9
	
		header.session_id = (++start_session);
80003db6:	4a 18       	lddpc	r8,80003e38 <rfid_sendID_message+0x158>
80003db8:	11 86       	ld.ub	r6,r8[0x0]
80003dba:	2f f6       	sub	r6,-1
80003dbc:	b0 86       	st.b	r8[0x0],r6
	
		memcpy(&header.fixed_data[0], unsure_data, sizeof(unsure_data));
80003dbe:	30 5a       	mov	r10,5
80003dc0:	49 fb       	lddpc	r11,80003e3c <rfid_sendID_message+0x15c>
80003dc2:	fa cc ff e5 	sub	r12,sp,-27
80003dc6:	f0 1f 00 1c 	mcall	80003e34 <rfid_sendID_message+0x154>
		header.type = 0xe000;
	
		memcpy(message, &header, sizeof(Message_Header_t));//疯header版
80003dca:	31 e8       	mov	r8,30
80003dcc:	fb 58 00 16 	st.h	sp[22],r8
80003dd0:	fb 66 00 1a 	st.b	sp[26],r6
80003dd4:	fe 78 e0 00 	mov	r8,-8192
80003dd8:	fb 58 00 18 	st.h	sp[24],r8
80003ddc:	fa c6 ff e0 	sub	r6,sp,-32
80003de0:	30 aa       	mov	r10,10
80003de2:	fa cb ff ea 	sub	r11,sp,-22
80003de6:	0c 9c       	mov	r12,r6
80003de8:	f0 1f 00 13 	mcall	80003e34 <rfid_sendID_message+0x154>
		memcpy(&message[sizeof(Message_Header_t)], &data_buffer, sizeof(Message_Data_t));//疯淇″瀹规版
80003dec:	31 6a       	mov	r10,22
80003dee:	1a 9b       	mov	r11,sp
80003df0:	fa cc ff d6 	sub	r12,sp,-42
80003df4:	f0 1f 00 10 	mcall	80003e34 <rfid_sendID_message+0x154>
	
		xcmp_data_session_req(message, (sizeof(Message_Header_t)+sizeof(Message_Data_t)), destination);
80003df8:	30 9a       	mov	r10,9
80003dfa:	32 0b       	mov	r11,32
80003dfc:	0c 9c       	mov	r12,r6
80003dfe:	f0 1f 00 11 	mcall	80003e40 <rfid_sendID_message+0x160>
80003e02:	c0 88       	rjmp	80003e12 <rfid_sendID_message+0x132>
		
	}
	else
	{
		xcmp_IdleTestTone(Tone_Start, BT_Disconnecting_Success_Tone);//set tone to indicate scan rfid failure!!!
80003e04:	37 8b       	mov	r11,120
80003e06:	30 1c       	mov	r12,1
80003e08:	f0 1f 00 09 	mcall	80003e2c <rfid_sendID_message+0x14c>
		log("no card find...\n");
80003e0c:	48 ec       	lddpc	r12,80003e44 <rfid_sendID_message+0x164>
80003e0e:	f0 1f 00 07 	mcall	80003e28 <rfid_sendID_message+0x148>
	}
	
	return return_err;
	
}
80003e12:	0e 9c       	mov	r12,r7
80003e14:	2e 4d       	sub	sp,-112
80003e16:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80003e1a:	00 00       	add	r0,r0
80003e1c:	00 00       	add	r0,r0
80003e1e:	0a 68       	and	r8,r5
80003e20:	80 00       	ld.sh	r0,r0[0x0]
80003e22:	3c 90       	mov	r0,-55
80003e24:	80 00       	ld.sh	r0,r0[0x0]
80003e26:	ca 30       	breq	80003d6c <rfid_sendID_message+0x8c>
80003e28:	80 00       	ld.sh	r0,r0[0x0]
80003e2a:	62 b8       	ld.w	r8,r1[0x2c]
80003e2c:	80 00       	ld.sh	r0,r0[0x0]
80003e2e:	33 38       	mov	r8,51
80003e30:	00 00       	add	r0,r0
80003e32:	0d 18       	ld.sh	r8,r6++
80003e34:	80 00       	ld.sh	r0,r0[0x0]
80003e36:	69 da       	ld.w	r10,r4[0x74]
80003e38:	00 00       	add	r0,r0
80003e3a:	05 00       	ld.w	r0,r2++
80003e3c:	00 00       	add	r0,r0
80003e3e:	04 f8       	st.b	--r2,r8
80003e40:	80 00       	ld.sh	r0,r0[0x0]
80003e42:	32 6c       	mov	r12,38
80003e44:	80 00       	ld.sh	r0,r0[0x0]
80003e46:	ca 4c       	rcall	80003f8e <create_xg_flash_test_task+0x12>

80003e48 <rfid_init>:
U8 RFID[16];			//瀛RFID
U8 unsure_data[5]={0x04, 0x0d, 0x00, 0x0a, 0x00};


void rfid_init()
{
80003e48:	d4 01       	pushm	lr
	char card_id[4]={0};
	//tc_init();//ㄥ跺200msㄥ诲
	
	rc522_init();
80003e4a:	f0 1f 00 02 	mcall	80003e50 <rfid_init+0x8>
	
	//if(rfid_auto_reader(card_id) == 0){
		//log("card_id : 0x%x, 0x%x, 0x%x, 0x%x\n", &card_id[0], &card_id[1], &card_id[2], &card_id[3]);	
	//}
		//
}
80003e4e:	d8 02       	popm	pc
80003e50:	80 00       	ld.sh	r0,r0[0x0]
80003e52:	37 5c       	mov	r12,117

80003e54 <delay_ns>:
}

void delay_ns(U32 ns)
{
	U32 i;
	for(i=0;i<ns;i++)
80003e54:	58 0c       	cp.w	r12,0
80003e56:	5e 0c       	reteq	r12
80003e58:	30 08       	mov	r8,0
	{
		nop();
80003e5a:	d7 03       	nop
		nop();
80003e5c:	d7 03       	nop
		nop();
80003e5e:	d7 03       	nop
}

void delay_ns(U32 ns)
{
	U32 i;
	for(i=0;i<ns;i++)
80003e60:	2f f8       	sub	r8,-1
80003e62:	10 3c       	cp.w	r12,r8
80003e64:	fe 9b ff fb 	brhi	80003e5a <delay_ns+0x6>
80003e68:	5e fc       	retal	r12
80003e6a:	d7 03       	nop

80003e6c <delay_us>:
		nop();
		nop();
	}
}
void delay_us(U32 us)
{
80003e6c:	eb cd 40 e0 	pushm	r5-r7,lr
80003e70:	18 96       	mov	r6,r12
	for(int i =0; i<us; i++){
80003e72:	58 0c       	cp.w	r12,0
80003e74:	c0 b0       	breq	80003e8a <delay_us+0x1e>
80003e76:	30 07       	mov	r7,0
		delay_ns(1000);
80003e78:	e0 65 03 e8 	mov	r5,1000
80003e7c:	0a 9c       	mov	r12,r5
80003e7e:	f0 1f 00 05 	mcall	80003e90 <delay_us+0x24>
		nop();
	}
}
void delay_us(U32 us)
{
	for(int i =0; i<us; i++){
80003e82:	2f f7       	sub	r7,-1
80003e84:	0e 36       	cp.w	r6,r7
80003e86:	fe 9b ff fb 	brhi	80003e7c <delay_us+0x10>
80003e8a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80003e8e:	00 00       	add	r0,r0
80003e90:	80 00       	ld.sh	r0,r0[0x0]
80003e92:	3e 54       	mov	r4,-27

80003e94 <delay_ms>:
		delay_ns(1000);
	}

}
void delay_ms(U32 ms)
{
80003e94:	eb cd 40 e0 	pushm	r5-r7,lr
80003e98:	18 96       	mov	r6,r12
	for(int i =0; i<ms; i++){
80003e9a:	58 0c       	cp.w	r12,0
80003e9c:	c0 b0       	breq	80003eb2 <delay_ms+0x1e>
80003e9e:	30 07       	mov	r7,0
		delay_us(1000);
80003ea0:	e0 65 03 e8 	mov	r5,1000
80003ea4:	0a 9c       	mov	r12,r5
80003ea6:	f0 1f 00 05 	mcall	80003eb8 <delay_ms+0x24>
	}

}
void delay_ms(U32 ms)
{
	for(int i =0; i<ms; i++){
80003eaa:	2f f7       	sub	r7,-1
80003eac:	0e 36       	cp.w	r6,r7
80003eae:	fe 9b ff fb 	brhi	80003ea4 <delay_ms+0x10>
80003eb2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80003eb6:	00 00       	add	r0,r0
80003eb8:	80 00       	ld.sh	r0,r0[0x0]
80003eba:	3e 6c       	mov	r12,-26

80003ebc <local_start_timer>:
//	SSC_TX_DATA_ENABLE		AVR32_TC_A0_0_0_PIN					[32 PortB Pin  0 00000001 Func 0]
//	MAKO_TX					AVR32_SSC_TX_DATA_0_PIN				[42 PortB Pin 10 00000400 Func 0]
//	MAKO_RX					AVR32_SSC_RX_DATA_0_PIN				[39 PortB Pin  7 00000080 Func 0]
//
void local_start_timer(void)
{
80003ebc:	d4 01       	pushm	lr
	{
		{TIMER_TC_CLK_PIN,      TIMER_TC_CLK_FUNCTION     },
		{TIMER_TC_FS_PIN,       TIMER_TC_FS_FUNCTION      },
		{TIMER_EN_CLK_PIN,      TIMER_EN_CLK_FUNCTION     }
	};
	gpio_enable_module(TC_GPIO_MAP, sizeof(TC_GPIO_MAP) / sizeof(TC_GPIO_MAP[0]));
80003ebe:	30 3b       	mov	r11,3
80003ec0:	48 8c       	lddpc	r12,80003ee0 <local_start_timer+0x24>
80003ec2:	f0 1f 00 09 	mcall	80003ee4 <local_start_timer+0x28>

	(&AVR32_TC)->channel[0].cmr =
80003ec6:	fe 78 38 00 	mov	r8,-51200
80003eca:	e0 69 91 0d 	mov	r9,37133
80003ece:	ea 19 00 52 	orh	r9,0x52
80003ed2:	91 19       	st.w	r8[0x4],r9
	1                          << AVR32_TC_CLKI_OFFSET     |
	AVR32_TC_TCCLKS_XC0        << AVR32_TC_TCCLKS_OFFSET;



	(&AVR32_TC)->channel[0].ra = 32;
80003ed4:	32 09       	mov	r9,32
80003ed6:	91 59       	st.w	r8[0x14],r9
	(&AVR32_TC)->channel[0].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
80003ed8:	30 59       	mov	r9,5
80003eda:	91 09       	st.w	r8[0x0],r9
}
80003edc:	d8 02       	popm	pc
80003ede:	00 00       	add	r0,r0
80003ee0:	80 00       	ld.sh	r0,r0[0x0]
80003ee2:	ca 60       	breq	80003e2e <rfid_sendID_message+0x14e>
80003ee4:	80 00       	ld.sh	r0,r0[0x0]
80003ee6:	47 3c       	lddsp	r12,sp[0x1cc]

80003ee8 <local_start_pll0>:
//In the SSC description, Master Clock (MCK) is the bus clock of the peripheral bus to which the
//SSC is connected. [23.6.2]
//Switch to clock Osc0 (crystal)
//start PLL0 and switch main clock to PLL0 output
void local_start_pll0(void)
{
80003ee8:	d4 01       	pushm	lr
	AVR32_HMATRIX.mcfg[AVR32_HMATRIX_MASTER_CPU_INSTRUCTION] = 0x1;
	
***/
	
/*****/
	pm_switch_to_osc0(&AVR32_PM, 12000000, OSC0_STARTUP);
80003eea:	30 3a       	mov	r10,3
80003eec:	e0 6b 1b 00 	mov	r11,6912
80003ef0:	ea 1b 00 b7 	orh	r11,0xb7
80003ef4:	fe 7c 0c 00 	mov	r12,-62464
80003ef8:	f0 1f 00 19 	mcall	80003f5c <local_start_pll0+0x74>

	pm_pll_setup(&AVR32_PM,
80003efc:	31 08       	mov	r8,16
80003efe:	1a d8       	st.w	--sp,r8
80003f00:	30 08       	mov	r8,0
80003f02:	30 19       	mov	r9,1
80003f04:	30 7a       	mov	r10,7
80003f06:	10 9b       	mov	r11,r8
80003f08:	fe 7c 0c 00 	mov	r12,-62464
80003f0c:	f0 1f 00 15 	mcall	80003f60 <local_start_pll0+0x78>
	               0,   // use PLL0
	               7,   // MUL=7 in the formula
	               1,   // DIV=1 in the formula
	               0,   // Sel Osc0/PLL0 or Osc1/PLL1
	               16); // lockcount in main clock for the PLL wait lock
	pm_pll_set_option(&AVR32_PM, 0, //PLL number 0
80003f10:	30 08       	mov	r8,0
80003f12:	30 19       	mov	r9,1
80003f14:	12 9a       	mov	r10,r9
80003f16:	10 9b       	mov	r11,r8
80003f18:	fe 7c 0c 00 	mov	r12,-62464
80003f1c:	f0 1f 00 12 	mcall	80003f64 <local_start_pll0+0x7c>
	                        1, //freq Set to 1 for VCO frequency range 80-180MHz
	                        1, //div2 Divide the PLL output frequency by 2
	                        0);//0 to enable the Wide-Bandith Mode
	pm_pll_enable(&AVR32_PM,0);
80003f20:	30 0b       	mov	r11,0
80003f22:	fe 7c 0c 00 	mov	r12,-62464
80003f26:	f0 1f 00 11 	mcall	80003f68 <local_start_pll0+0x80>


	pm_wait_for_pll0_locked(&AVR32_PM);
80003f2a:	fe 7c 0c 00 	mov	r12,-62464
80003f2e:	f0 1f 00 10 	mcall	80003f6c <local_start_pll0+0x84>


	pm_cksel(&AVR32_PM, 1,  //Bus A clock divisor enable = 1
80003f32:	30 0a       	mov	r10,0
80003f34:	1a da       	st.w	--sp,r10
80003f36:	1a da       	st.w	--sp,r10
80003f38:	14 98       	mov	r8,r10
80003f3a:	14 99       	mov	r9,r10
80003f3c:	30 1b       	mov	r11,1
80003f3e:	fe 7c 0c 00 	mov	r12,-62464
80003f42:	f0 1f 00 0c 	mcall	80003f70 <local_start_pll0+0x88>
	             0,  //B clock divisor enable = 0
	             0,  //Bus B select = 0
	             0,  //HS Bus clock divisor enable = 0
	             0); //HS Bus select = 0
				 
	flashc_set_wait_state(1);
80003f46:	30 1c       	mov	r12,1
80003f48:	f0 1f 00 0b 	mcall	80003f74 <local_start_pll0+0x8c>
	//AVR32_FLASHC.fcr = 0x00000040;

	pm_switch_to_clock(&AVR32_PM, AVR32_PM_MCSEL_PLL0);
80003f4c:	30 2b       	mov	r11,2
80003f4e:	fe 7c 0c 00 	mov	r12,-62464
80003f52:	f0 1f 00 0a 	mcall	80003f78 <local_start_pll0+0x90>
80003f56:	2f dd       	sub	sp,-12
/****/
}
80003f58:	d8 02       	popm	pc
80003f5a:	00 00       	add	r0,r0
80003f5c:	80 00       	ld.sh	r0,r0[0x0]
80003f5e:	4a 44       	lddpc	r4,80003fec <xg_flashc_init+0x1c>
80003f60:	80 00       	ld.sh	r0,r0[0x0]
80003f62:	49 e6       	lddpc	r6,80003fd8 <xg_flashc_init+0x8>
80003f64:	80 00       	ld.sh	r0,r0[0x0]
80003f66:	4a 08       	lddpc	r8,80003fe4 <xg_flashc_init+0x14>
80003f68:	80 00       	ld.sh	r0,r0[0x0]
80003f6a:	4a 22       	lddpc	r2,80003ff0 <xg_flashc_init+0x20>
80003f6c:	80 00       	ld.sh	r0,r0[0x0]
80003f6e:	4a 30       	lddpc	r0,80003ff8 <xg_flashc_init+0x28>
80003f70:	80 00       	ld.sh	r0,r0[0x0]
80003f72:	49 a0       	lddpc	r0,80003fd8 <xg_flashc_init+0x8>
80003f74:	80 00       	ld.sh	r0,r0[0x0]
80003f76:	46 dc       	lddsp	r12,sp[0x1b4]
80003f78:	80 00       	ld.sh	r0,r0[0x0]
80003f7a:	4a 3a       	lddpc	r10,80004004 <xg_flashc_init+0x34>

80003f7c <create_xg_flash_test_task>:
	log("data_ptr == NULL,exit runXGFlashTestREAD\n");
	
}

void create_xg_flash_test_task(void)
{
80003f7c:	eb cd 40 80 	pushm	r7,lr
	
	xTaskCreate(
80003f80:	30 07       	mov	r7,0
80003f82:	1a d7       	st.w	--sp,r7
80003f84:	1a d7       	st.w	--sp,r7
80003f86:	48 d8       	lddpc	r8,80003fb8 <create_xg_flash_test_task+0x3c>
80003f88:	1a d8       	st.w	--sp,r8
80003f8a:	30 58       	mov	r8,5
80003f8c:	0e 99       	mov	r9,r7
80003f8e:	e0 6a 03 20 	mov	r10,800
80003f92:	48 bb       	lddpc	r11,80003fbc <create_xg_flash_test_task+0x40>
80003f94:	48 bc       	lddpc	r12,80003fc0 <create_xg_flash_test_task+0x44>
80003f96:	f0 1f 00 0c 	mcall	80003fc4 <create_xg_flash_test_task+0x48>
	//, NULL);
	,  &save_handle);
	
	//vTaskSuspend(save_handle);
	
	xTaskCreate(
80003f9a:	1a d7       	st.w	--sp,r7
80003f9c:	1a d7       	st.w	--sp,r7
80003f9e:	1a d7       	st.w	--sp,r7
80003fa0:	30 58       	mov	r8,5
80003fa2:	0e 99       	mov	r9,r7
80003fa4:	e0 6a 03 70 	mov	r10,880
80003fa8:	48 8b       	lddpc	r11,80003fc8 <create_xg_flash_test_task+0x4c>
80003faa:	48 9c       	lddpc	r12,80003fcc <create_xg_flash_test_task+0x50>
80003fac:	f0 1f 00 06 	mcall	80003fc4 <create_xg_flash_test_task+0x48>
80003fb0:	2f ad       	sub	sp,-24
	,  880
	,  NULL
	,  tskFLASH_PRIORITY+4
	,  NULL );
	
}
80003fb2:	e3 cd 80 80 	ldm	sp++,r7,pc
80003fb6:	00 00       	add	r0,r0
80003fb8:	00 00       	add	r0,r0
80003fba:	1f c4       	ld.ub	r4,pc[0x4]
80003fbc:	80 00       	ld.sh	r0,r0[0x0]
80003fbe:	ca 78       	rjmp	8000410c <xg_flashc_init+0x13c>
80003fc0:	80 00       	ld.sh	r0,r0[0x0]
80003fc2:	45 08       	lddsp	r8,sp[0x140]
80003fc4:	80 00       	ld.sh	r0,r0[0x0]
80003fc6:	5e f4       	retal	r4
80003fc8:	80 00       	ld.sh	r0,r0[0x0]
80003fca:	ca 80       	breq	80003f1a <local_start_pll0+0x32>
80003fcc:	80 00       	ld.sh	r0,r0[0x0]
80003fce:	45 d0       	lddsp	r0,sp[0x174]

80003fd0 <xg_flashc_init>:


//U16	Current_total_message_count=0;
void xg_flashc_init(void)
{
80003fd0:	d4 31       	pushm	r0-r7,lr
80003fd2:	20 3d       	sub	sp,12
	
	/* Create the mutex semaphore to guard a shared xgflash.*/
	xgflash_mutex = xSemaphoreCreateMutex();
80003fd4:	f0 1f 00 81 	mcall	800041d8 <xg_flashc_init+0x208>
80003fd8:	fe f8 02 04 	ld.w	r8,pc[516]
80003fdc:	91 0c       	st.w	r8[0x0],r12
	if (xgflash_mutex == NULL)
80003fde:	70 08       	ld.w	r8,r8[0x0]
80003fe0:	58 08       	cp.w	r8,0
80003fe2:	c0 41       	brne	80003fea <xg_flashc_init+0x1a>
	{
		log("Create the xgflash_mutex semaphore failure\n");
80003fe4:	4f fc       	lddpc	r12,800041e0 <xg_flashc_init+0x210>
80003fe6:	f0 1f 00 80 	mcall	800041e4 <xg_flashc_init+0x214>
	}
	
	/* Create the binary semaphore to Synchronize other threads.*/
	vSemaphoreCreateBinary(xBinarySemaphore);
80003fea:	30 0b       	mov	r11,0
80003fec:	30 1c       	mov	r12,1
80003fee:	f0 1f 00 7f 	mcall	800041e8 <xg_flashc_init+0x218>
80003ff2:	4f f8       	lddpc	r8,800041ec <xg_flashc_init+0x21c>
80003ff4:	91 0c       	st.w	r8[0x0],r12
80003ff6:	70 08       	ld.w	r8,r8[0x0]
80003ff8:	58 08       	cp.w	r8,0
80003ffa:	c0 80       	breq	8000400a <xg_flashc_init+0x3a>
80003ffc:	4f c8       	lddpc	r8,800041ec <xg_flashc_init+0x21c>
80003ffe:	70 0c       	ld.w	r12,r8[0x0]
80004000:	30 09       	mov	r9,0
80004002:	12 9a       	mov	r10,r9
80004004:	12 9b       	mov	r11,r9
80004006:	f0 1f 00 7b 	mcall	800041f0 <xg_flashc_init+0x220>
	
	
	xg_resend_queue = xQueueCreate(20, sizeof(U32));
8000400a:	30 4b       	mov	r11,4
8000400c:	31 4c       	mov	r12,20
8000400e:	f0 1f 00 77 	mcall	800041e8 <xg_flashc_init+0x218>
80004012:	4f 98       	lddpc	r8,800041f4 <xg_flashc_init+0x224>
80004014:	91 0c       	st.w	r8[0x0],r12
	/*initialize the queue*/
	message_storage_queue = xQueueCreate(20, sizeof(U32));
80004016:	30 4b       	mov	r11,4
80004018:	31 4c       	mov	r12,20
8000401a:	f0 1f 00 74 	mcall	800041e8 <xg_flashc_init+0x218>
8000401e:	4f 78       	lddpc	r8,800041f8 <xg_flashc_init+0x228>
80004020:	91 0c       	st.w	r8[0x0],r12
80004022:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_MESSAGE_STORE; i++ )
	{
		set_message_store(&message_store[i]);//push <message_store> address to the message_storage_queue;
80004024:	10 96       	mov	r6,r8
80004026:	4f 65       	lddpc	r5,800041fc <xg_flashc_init+0x22c>
80004028:	6c 0c       	ld.w	r12,r6[0x0]
8000402a:	ea 07 00 0b 	add	r11,r5,r7
8000402e:	f0 1f 00 75 	mcall	80004200 <xg_flashc_init+0x230>
80004032:	2e 07       	sub	r7,-32
	
	
	xg_resend_queue = xQueueCreate(20, sizeof(U32));
	/*initialize the queue*/
	message_storage_queue = xQueueCreate(20, sizeof(U32));
	for(int i= 0; i < MAX_MESSAGE_STORE; i++ )
80004034:	e0 47 02 80 	cp.w	r7,640
80004038:	cf 81       	brne	80004028 <xg_flashc_init+0x58>
	{
		set_message_store(&message_store[i]);//push <message_store> address to the message_storage_queue;
	}
	
	
	data_flash_init();//interface
8000403a:	f0 1f 00 73 	mcall	80004204 <xg_flashc_init+0x234>
	df_status_t return_code = DF_OK;
	static U32 current_page_number =0;
	unsigned int i = 0;
	unsigned int address =0x00000000;
	static char str[80];
	memset(str, 0x00, sizeof(str));
8000403e:	30 0a       	mov	r10,0
80004040:	30 0b       	mov	r11,0
80004042:	4f 28       	lddpc	r8,80004208 <xg_flashc_init+0x238>
80004044:	b1 2a       	st.d	r8++,r10
80004046:	b1 2a       	st.d	r8++,r10
80004048:	b1 2a       	st.d	r8++,r10
8000404a:	b1 2a       	st.d	r8++,r10
8000404c:	b1 2a       	st.d	r8++,r10
8000404e:	b1 2a       	st.d	r8++,r10
80004050:	b1 2a       	st.d	r8++,r10
80004052:	b1 2a       	st.d	r8++,r10
80004054:	b1 2a       	st.d	r8++,r10
80004056:	f0 eb 00 00 	st.d	r8[0],r10
8000405a:	30 05       	mov	r5,0
	
start:
	
	 //bytes remained less than one page 
	return_code = data_flash_read_block(LABEL_ADDRESS, LABEL_LENGTH, str);
8000405c:	4e b7       	lddpc	r7,80004208 <xg_flashc_init+0x238>
			if(return_code == DF_OK)
			{
				//Calculates the offset address of the current stored message
				if(current_message_index != 0){
					
					memset(str, 0x00, sizeof(str));	
8000405e:	ee c4 ff f8 	sub	r4,r7,-8
80004062:	e8 c3 ff f8 	sub	r3,r4,-8
80004066:	e6 c2 ff f8 	sub	r2,r3,-8
8000406a:	e4 c1 ff f8 	sub	r1,r2,-8
8000406e:	e2 c0 ff f8 	sub	r0,r1,-8
80004072:	e0 ca ff f8 	sub	r10,r0,-8
80004076:	50 0a       	stdsp	sp[0x0],r10
80004078:	2f 8a       	sub	r10,-8
8000407a:	50 1a       	stdsp	sp[0x4],r10
8000407c:	2f 8a       	sub	r10,-8
8000407e:	50 2a       	stdsp	sp[0x8],r10
	memset(str, 0x00, sizeof(str));
	
start:
	
	 //bytes remained less than one page 
	return_code = data_flash_read_block(LABEL_ADDRESS, LABEL_LENGTH, str);
80004080:	0e 9a       	mov	r10,r7
80004082:	30 6b       	mov	r11,6
80004084:	30 0c       	mov	r12,0
80004086:	f0 1f 00 62 	mcall	8000420c <xg_flashc_init+0x23c>
	{
		if(memcmp(XGFlashLabel, str, sizeof(XGFlashLabel)-1) != 0)//compare label
8000408a:	30 6a       	mov	r10,6
8000408c:	0e 9b       	mov	r11,r7
8000408e:	4e 1c       	lddpc	r12,80004210 <xg_flashc_init+0x240>
80004090:	f0 1f 00 61 	mcall	80004214 <xg_flashc_init+0x244>
80004094:	c1 c0       	breq	800040cc <xg_flashc_init+0xfc>
80004096:	c8 58       	rjmp	800041a0 <xg_flashc_init+0x1d0>
					return FALSE;
				}
				address+=65536;//64k*1024=65536bytes
			}
			//set label
			return_code = data_flash_write(XGFlashLabel, LABEL_ADDRESS, LABEL_LENGTH);
80004098:	30 6a       	mov	r10,6
8000409a:	30 0b       	mov	r11,0
8000409c:	4d dc       	lddpc	r12,80004210 <xg_flashc_init+0x240>
8000409e:	f0 1f 00 5f 	mcall	80004218 <xg_flashc_init+0x248>
			
			//set current_voice_index
			memset(str, 0x00, sizeof(str));
800040a2:	4d a7       	lddpc	r7,80004208 <xg_flashc_init+0x238>
800040a4:	35 0a       	mov	r10,80
800040a6:	30 0b       	mov	r11,0
800040a8:	0e 9c       	mov	r12,r7
800040aa:	f0 1f 00 5d 	mcall	8000421c <xg_flashc_init+0x24c>
			return_code = data_flash_write(str, MESSAGE_NUMBERS_ADD, MESSAGE_NUMBERS_LENGTH);
800040ae:	30 2a       	mov	r10,2
800040b0:	30 6b       	mov	r11,6
800040b2:	0e 9c       	mov	r12,r7
800040b4:	f0 1f 00 59 	mcall	80004218 <xg_flashc_init+0x248>
			if(return_code != DF_WRITE_COMPLETED)
800040b8:	58 7c       	cp.w	r12,7
800040ba:	e0 81 00 8a 	brne	800041ce <xg_flashc_init+0x1fe>
			{
				return FALSE;
			}
			current_message_index = 0;
800040be:	30 09       	mov	r9,0
800040c0:	4d 88       	lddpc	r8,80004220 <xg_flashc_init+0x250>
800040c2:	b0 09       	st.h	r8[0x0],r9
			log("\r\n----create xg message info okay!----\r\n");
800040c4:	4d 8c       	lddpc	r12,80004224 <xg_flashc_init+0x254>
800040c6:	f0 1f 00 48 	mcall	800041e4 <xg_flashc_init+0x214>
800040ca:	c7 f8       	rjmp	800041c8 <xg_flashc_init+0x1f8>
		}
		else//success
		{
			log("\nLABEL: %s\n", str);
800040cc:	1a d7       	st.w	--sp,r7
800040ce:	4d 7c       	lddpc	r12,80004228 <xg_flashc_init+0x258>
800040d0:	f0 1f 00 45 	mcall	800041e4 <xg_flashc_init+0x214>
			//Get the current voice index
			return_code = data_flash_read_block(MESSAGE_NUMBERS_ADD, MESSAGE_NUMBERS_LENGTH, &current_message_index);								
800040d4:	4d 3a       	lddpc	r10,80004220 <xg_flashc_init+0x250>
800040d6:	30 2b       	mov	r11,2
800040d8:	30 6c       	mov	r12,6
800040da:	f0 1f 00 4d 	mcall	8000420c <xg_flashc_init+0x23c>
			if(return_code == DF_OK)
800040de:	2f fd       	sub	sp,-4
800040e0:	58 0c       	cp.w	r12,0
800040e2:	c7 61       	brne	800041ce <xg_flashc_init+0x1fe>
			{
				//Calculates the offset address of the current stored message
				if(current_message_index != 0){
800040e4:	4c f8       	lddpc	r8,80004220 <xg_flashc_init+0x250>
800040e6:	90 09       	ld.sh	r9,r8[0x0]
800040e8:	30 08       	mov	r8,0
800040ea:	f0 09 19 00 	cp.h	r9,r8
800040ee:	c6 a0       	breq	800041c2 <xg_flashc_init+0x1f2>
					
					memset(str, 0x00, sizeof(str));	
800040f0:	30 08       	mov	r8,0
800040f2:	30 09       	mov	r9,0
800040f4:	ee e9 00 00 	st.d	r7[0],r8
800040f8:	e8 e9 00 00 	st.d	r4[0],r8
800040fc:	e6 e9 00 00 	st.d	r3[0],r8
80004100:	e4 e9 00 00 	st.d	r2[0],r8
80004104:	e2 e9 00 00 	st.d	r1[0],r8
80004108:	e0 e9 00 00 	st.d	r0[0],r8
8000410c:	40 0a       	lddsp	r10,sp[0x0]
8000410e:	f4 e9 00 00 	st.d	r10[0],r8
80004112:	40 1a       	lddsp	r10,sp[0x4]
80004114:	f4 e9 00 00 	st.d	r10[0],r8
80004118:	40 2a       	lddsp	r10,sp[0x8]
8000411a:	b5 28       	st.d	r10++,r8
8000411c:	f4 e9 00 00 	st.d	r10[0],r8
					address = XG_MESSAGE_INFO_HEADER_START_ADD + ((current_message_index -1)*XG_MESSAGE_INFO_HEADER_LENGTH);
80004120:	4c 08       	lddpc	r8,80004220 <xg_flashc_init+0x250>
80004122:	90 85       	ld.uh	r5,r8[0x0]
80004124:	a3 75       	lsl	r5,0x3
					return_code = data_flash_read_block(address, XG_MESSAGE_INFO_HEADER_LENGTH, (U8 *)str);			
80004126:	0e 9a       	mov	r10,r7
80004128:	30 8b       	mov	r11,8
8000412a:	0a 9c       	mov	r12,r5
8000412c:	f0 1f 00 38 	mcall	8000420c <xg_flashc_init+0x23c>
					if(return_code == DF_OK)
80004130:	c4 91       	brne	800041c2 <xg_flashc_init+0x1f2>
					{
						MessageList_Info_t *ptr = (MessageList_Info_t *)str;
						if(ptr->numb == current_message_index)
80004132:	0f 89       	ld.ub	r9,r7[0x0]
80004134:	0f 98       	ld.ub	r8,r7[0x1]
80004136:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000413a:	4b a9       	lddpc	r9,80004220 <xg_flashc_init+0x250>
8000413c:	92 09       	ld.sh	r9,r9[0x0]
8000413e:	f0 09 19 00 	cp.h	r9,r8
80004142:	c2 c1       	brne	8000419a <xg_flashc_init+0x1ca>
						{
							current_save_message_offset = ptr->address + ptr->offset;
80004144:	0f e9       	ld.ub	r9,r7[0x6]
80004146:	0f f8       	ld.ub	r8,r7[0x7]
80004148:	f1 e9 10 89 	or	r9,r8,r9<<0x8
8000414c:	0f aa       	ld.ub	r10,r7[0x2]
8000414e:	0f b8       	ld.ub	r8,r7[0x3]
80004150:	b1 68       	lsl	r8,0x10
80004152:	f1 ea 11 88 	or	r8,r8,r10<<0x18
80004156:	0f ca       	ld.ub	r10,r7[0x4]
80004158:	f1 ea 10 88 	or	r8,r8,r10<<0x8
8000415c:	0f da       	ld.ub	r10,r7[0x5]
8000415e:	f5 e8 10 08 	or	r8,r10,r8
80004162:	f2 08 00 08 	add	r8,r9,r8
80004166:	4b 26       	lddpc	r6,8000422c <xg_flashc_init+0x25c>
80004168:	8d 08       	st.w	r6[0x0],r8
							log("current_save_message_offset : %X\n", current_save_message_offset);
8000416a:	1a d8       	st.w	--sp,r8
8000416c:	4b 1c       	lddpc	r12,80004230 <xg_flashc_init+0x260>
8000416e:	f0 1f 00 1e 	mcall	800041e4 <xg_flashc_init+0x214>
							if(current_save_message_offset > XG_MESSAGE_DATA_BOUNDARY_ADD){
80004172:	2f fd       	sub	sp,-4
80004174:	6c 08       	ld.w	r8,r6[0x0]
80004176:	e0 69 ff ff 	mov	r9,65535
8000417a:	ea 19 00 7f 	orh	r9,0x7f
8000417e:	12 38       	cp.w	r8,r9
80004180:	e0 88 00 21 	brls	800041c2 <xg_flashc_init+0x1f2>
										
								log("\r\n----message storage is full!!!----\r\n");
80004184:	4a cc       	lddpc	r12,80004234 <xg_flashc_init+0x264>
80004186:	f0 1f 00 18 	mcall	800041e4 <xg_flashc_init+0x214>
								//xgflash erase

								return_code = data_flash_erase_block(0, DF_BLOCK_ALL);
8000418a:	30 4b       	mov	r11,4
8000418c:	30 0c       	mov	r12,0
8000418e:	f0 1f 00 2b 	mcall	80004238 <xg_flashc_init+0x268>
								if(return_code == DF_ERASE_COMPLETED)goto start;
80004192:	58 5c       	cp.w	r12,5
80004194:	fe 90 ff 76 	breq	80004080 <xg_flashc_init+0xb0>
80004198:	c1 b8       	rjmp	800041ce <xg_flashc_init+0x1fe>

							}
						}
						else
						{
							log("\r\n----message storage is err!!!----\r\n");
8000419a:	4a 9c       	lddpc	r12,8000423c <xg_flashc_init+0x26c>
8000419c:	f0 1f 00 12 	mcall	800041e4 <xg_flashc_init+0x214>
		{
			ERASE:
			//erase list
			for(i; i < (XG_MESSAGE_LISTINFO_BOUNDARY_ADD/(64*1024)); i++)//2*64k
			{
				return_code = data_flash_erase_block(address, DF_BLOCK_64KB);
800041a0:	30 3b       	mov	r11,3
800041a2:	0a 9c       	mov	r12,r5
800041a4:	f0 1f 00 25 	mcall	80004238 <xg_flashc_init+0x268>
				if(return_code != DF_ERASE_COMPLETED)
800041a8:	58 5c       	cp.w	r12,5
800041aa:	c1 21       	brne	800041ce <xg_flashc_init+0x1fe>
		{
			ERASE:
			//erase list
			for(i; i < (XG_MESSAGE_LISTINFO_BOUNDARY_ADD/(64*1024)); i++)//2*64k
			{
				return_code = data_flash_erase_block(address, DF_BLOCK_64KB);
800041ac:	30 3b       	mov	r11,3
800041ae:	e0 78 00 00 	mov	r8,65536
800041b2:	ea 08 00 0c 	add	r12,r5,r8
800041b6:	f0 1f 00 21 	mcall	80004238 <xg_flashc_init+0x268>
				if(return_code != DF_ERASE_COMPLETED)
800041ba:	58 5c       	cp.w	r12,5
800041bc:	fe 90 ff 6e 	breq	80004098 <xg_flashc_init+0xc8>
800041c0:	c0 78       	rjmp	800041ce <xg_flashc_init+0x1fe>
							log("\r\n----message storage is err!!!----\r\n");
							goto ERASE;
						}
					}
				}
				log("\r\n----xoxo read message info okay!----\r\n");
800041c2:	4a 0c       	lddpc	r12,80004240 <xg_flashc_init+0x270>
800041c4:	f0 1f 00 08 	mcall	800041e4 <xg_flashc_init+0x214>
			else
				return FALSE;
			
		}
				
		list_init_success_flag = 1;
800041c8:	30 19       	mov	r9,1
800041ca:	49 f8       	lddpc	r8,80004244 <xg_flashc_init+0x274>
800041cc:	b0 89       	st.b	r8[0x0],r9
	
	data_flash_init();//interface
	
	//flashc_lock_all_regions(false);
	xgflash_list_info_init();
	create_xg_flash_test_task();
800041ce:	f0 1f 00 1f 	mcall	80004248 <xg_flashc_init+0x278>

}
800041d2:	2f dd       	sub	sp,-12
800041d4:	d8 32       	popm	r0-r7,pc
800041d6:	00 00       	add	r0,r0
800041d8:	80 00       	ld.sh	r0,r0[0x0]
800041da:	57 80       	stdsp	sp[0x1e0],r0
800041dc:	00 00       	add	r0,r0
800041de:	0a 88       	andn	r8,r5
800041e0:	80 00       	ld.sh	r0,r0[0x0]
800041e2:	ca 88       	rjmp	80004332 <xgflash_get_message_data+0xe6>
800041e4:	80 00       	ld.sh	r0,r0[0x0]
800041e6:	62 b8       	ld.w	r8,r1[0x2c]
800041e8:	80 00       	ld.sh	r0,r0[0x0]
800041ea:	57 d8       	stdsp	sp[0x1f4],r8
800041ec:	00 00       	add	r0,r0
800041ee:	1f c0       	ld.ub	r0,pc[0x4]
800041f0:	80 00       	ld.sh	r0,r0[0x0]
800041f2:	56 80       	stdsp	sp[0x1a0],r0
800041f4:	00 00       	add	r0,r0
800041f6:	0a 74       	tst	r4,r5
800041f8:	00 00       	add	r0,r0
800041fa:	0a 94       	mov	r4,r5
800041fc:	00 00       	add	r0,r0
800041fe:	0d 1e       	ld.sh	lr,r6++
80004200:	80 00       	ld.sh	r0,r0[0x0]
80004202:	31 d0       	mov	r0,29
80004204:	80 00       	ld.sh	r0,r0[0x0]
80004206:	2f 20       	sub	r0,-14
80004208:	00 00       	add	r0,r0
8000420a:	0a a0       	st.w	r5++,r0
8000420c:	80 00       	ld.sh	r0,r0[0x0]
8000420e:	2b c4       	sub	r4,-68
80004210:	00 00       	add	r0,r0
80004212:	05 0c       	ld.w	r12,r2++
80004214:	80 00       	ld.sh	r0,r0[0x0]
80004216:	69 b4       	ld.w	r4,r4[0x6c]
80004218:	80 00       	ld.sh	r0,r0[0x0]
8000421a:	2d fc       	sub	r12,-33
8000421c:	80 00       	ld.sh	r0,r0[0x0]
8000421e:	6b 22       	ld.w	r2,r5[0x48]
80004220:	00 00       	add	r0,r0
80004222:	0a 8c       	andn	r12,r5
80004224:	80 00       	ld.sh	r0,r0[0x0]
80004226:	ca b4       	brge	8000417c <xg_flashc_init+0x1ac>
80004228:	80 00       	ld.sh	r0,r0[0x0]
8000422a:	ca e0       	breq	80004186 <xg_flashc_init+0x1b6>
8000422c:	00 00       	add	r0,r0
8000422e:	05 14       	ld.sh	r4,r2++
80004230:	80 00       	ld.sh	r0,r0[0x0]
80004232:	ca ec       	rcall	8000438e <xgflash_get_message_data+0x142>
80004234:	80 00       	ld.sh	r0,r0[0x0]
80004236:	cb 10       	breq	80004198 <xg_flashc_init+0x1c8>
80004238:	80 00       	ld.sh	r0,r0[0x0]
8000423a:	2d 5c       	sub	r12,-43
8000423c:	80 00       	ld.sh	r0,r0[0x0]
8000423e:	cb 38       	rjmp	800043a4 <xgflash_message_save+0x4>
80004240:	80 00       	ld.sh	r0,r0[0x0]
80004242:	cb 60       	breq	800041ae <xg_flashc_init+0x1de>
80004244:	00 00       	add	r0,r0
80004246:	0a 78       	tst	r8,r5
80004248:	80 00       	ld.sh	r0,r0[0x0]
8000424a:	3f 7c       	mov	r12,-9

8000424c <xgflash_get_message_data>:
	return XG_OK;

}

xgflash_status_t xgflash_get_message_data(U32 message_index, void *buff_ptr, bool erase)
{
8000424c:	d4 31       	pushm	r0-r7,lr
8000424e:	20 2d       	sub	sp,8
80004250:	18 95       	mov	r5,r12
80004252:	16 96       	mov	r6,r11
80004254:	14 91       	mov	r1,r10
	if(!list_init_success_flag)return XG_ERROR;
80004256:	4c b8       	lddpc	r8,80004380 <xgflash_get_message_data+0x134>
80004258:	11 89       	ld.ub	r9,r8[0x0]
8000425a:	30 08       	mov	r8,0
8000425c:	f0 09 18 00 	cp.b	r9,r8
80004260:	c0 31       	brne	80004266 <xgflash_get_message_data+0x1a>
80004262:	3f fc       	mov	r12,-1
80004264:	c8 b8       	rjmp	8000437a <xgflash_get_message_data+0x12e>
	
	xSemaphoreTake(xgflash_mutex, portMAX_DELAY);//lock
80004266:	4c 88       	lddpc	r8,80004384 <xgflash_get_message_data+0x138>
80004268:	70 0c       	ld.w	r12,r8[0x0]
8000426a:	30 09       	mov	r9,0
8000426c:	3f fa       	mov	r10,-1
8000426e:	12 9b       	mov	r11,r9
80004270:	f0 1f 00 46 	mcall	80004388 <xgflash_get_message_data+0x13c>
	/* check input parameter */
	if (message_index > current_message_index)
80004274:	4c 68       	lddpc	r8,8000438c <xgflash_get_message_data+0x140>
80004276:	90 88       	ld.uh	r8,r8[0x0]
80004278:	0a 38       	cp.w	r8,r5
8000427a:	c0 a2       	brcc	8000428e <xgflash_get_message_data+0x42>
	{
		xSemaphoreGive(xgflash_mutex);//unlock
8000427c:	4c 28       	lddpc	r8,80004384 <xgflash_get_message_data+0x138>
8000427e:	70 0c       	ld.w	r12,r8[0x0]
80004280:	30 09       	mov	r9,0
80004282:	12 9a       	mov	r10,r9
80004284:	12 9b       	mov	r11,r9
80004286:	f0 1f 00 43 	mcall	80004390 <xgflash_get_message_data+0x144>
8000428a:	30 1c       	mov	r12,1
		return XG_INVALID_PARAM;
8000428c:	c7 78       	rjmp	8000437a <xgflash_get_message_data+0x12e>
	
	df_status_t return_code = DF_OK;
	U32 info_address =0x00000000;
	U32 data_address =0x00000000;
	char str[XG_MESSAGE_INFO_HEADER_LENGTH];
	memset(str, 0x00, sizeof(str));
8000428e:	fa ca ff f8 	sub	r10,sp,-8
80004292:	30 08       	mov	r8,0
80004294:	30 09       	mov	r9,0
80004296:	b5 29       	st.d	--r10,r8
	
	//find the message storage info by message_index
	info_address = XG_MESSAGE_INFO_HEADER_START_ADD + ((message_index -1)*XG_MESSAGE_INFO_HEADER_LENGTH);
80004298:	ea 00 15 03 	lsl	r0,r5,0x3
	//flashc_memcpy((void *)str, (void *)info_address, XG_MESSAGE_INFO_HEADER_LENGTH,  false);
	return_code = data_flash_read_block(info_address, XG_MESSAGE_INFO_HEADER_LENGTH, (U8 *)str);
8000429c:	1a 9a       	mov	r10,sp
8000429e:	30 8b       	mov	r11,8
800042a0:	00 9c       	mov	r12,r0
800042a2:	f0 1f 00 3d 	mcall	80004394 <xgflash_get_message_data+0x148>
	if (return_code == DF_OK)
800042a6:	c6 21       	brne	8000436a <xgflash_get_message_data+0x11e>
	{
		U16 bytes_remained;
		MessageList_Info_t *ptr = (MessageList_Info_t *)str;
		if(ptr->numb == message_index)
800042a8:	9a 88       	ld.uh	r8,sp[0x0]
800042aa:	0a 38       	cp.w	r8,r5
800042ac:	c5 61       	brne	80004358 <xgflash_get_message_data+0x10c>
		{
			bytes_remained = ptr->offset;
800042ae:	40 18       	lddsp	r8,sp[0x4]
800042b0:	ef d8 b0 10 	bfexts	r7,r8,0x0,0x10
			data_address = ptr->address;
800042b4:	9a 95       	ld.uh	r5,sp[0x2]
800042b6:	b1 88       	lsr	r8,0x10
800042b8:	f1 e5 11 05 	or	r5,r8,r5<<0x10
			
			while (bytes_remained >= 1 && return_code == DF_OK)
800042bc:	30 04       	mov	r4,0
800042be:	08 93       	mov	r3,r4
			{
				if(bytes_remained < DF_DATA_SPACE_SIZE)//< 512bytes
800042c0:	e0 62 01 ff 	mov	r2,511
		if(ptr->numb == message_index)
		{
			bytes_remained = ptr->offset;
			data_address = ptr->address;
			
			while (bytes_remained >= 1 && return_code == DF_OK)
800042c4:	c1 88       	rjmp	800042f4 <xgflash_get_message_data+0xa8>
			{
				if(bytes_remained < DF_DATA_SPACE_SIZE)//< 512bytes
800042c6:	e4 07 19 00 	cp.h	r7,r2
800042ca:	e0 8b 00 0a 	brhi	800042de <xgflash_get_message_data+0x92>
				{
					return_code = data_flash_read_block(data_address, bytes_remained, buff_ptr);
800042ce:	0c 9a       	mov	r10,r6
800042d0:	0e 9b       	mov	r11,r7
800042d2:	5c 7b       	castu.h	r11
800042d4:	0a 9c       	mov	r12,r5
800042d6:	f0 1f 00 30 	mcall	80004394 <xgflash_get_message_data+0x148>
800042da:	30 07       	mov	r7,0
800042dc:	c0 c8       	rjmp	800042f4 <xgflash_get_message_data+0xa8>
					bytes_remained = 0;	/* end while loop */

				}
				else//bytes_remained > DF_DATA_SPACE_SIZE
				{
					return_code = data_flash_read_block(data_address, DF_DATA_SPACE_SIZE, buff_ptr);
800042de:	0c 9a       	mov	r10,r6
800042e0:	e0 6b 02 00 	mov	r11,512
800042e4:	0a 9c       	mov	r12,r5
800042e6:	f0 1f 00 2c 	mcall	80004394 <xgflash_get_message_data+0x148>
					bytes_remained-=DF_DATA_SPACE_SIZE;
800042ea:	ee c7 02 00 	sub	r7,r7,512
800042ee:	5c 87       	casts.h	r7
					data_address+=DF_DATA_SPACE_SIZE;
800042f0:	ea c5 fe 00 	sub	r5,r5,-512
		if(ptr->numb == message_index)
		{
			bytes_remained = ptr->offset;
			data_address = ptr->address;
			
			while (bytes_remained >= 1 && return_code == DF_OK)
800042f4:	e8 07 19 00 	cp.h	r7,r4
800042f8:	5f 19       	srne	r9
800042fa:	58 0c       	cp.w	r12,0
800042fc:	5f 08       	sreq	r8
800042fe:	f3 e8 00 08 	and	r8,r9,r8
80004302:	e6 08 18 00 	cp.b	r8,r3
80004306:	ce 01       	brne	800042c6 <xgflash_get_message_data+0x7a>
						
				}
				//memset(PLAYBACK_BUF, 0x00, DF_DATA_SPACE_SIZE);
			}
			
			if(erase)//erase the message
80004308:	58 01       	cp.w	r1,0
8000430a:	c1 e0       	breq	80004346 <xgflash_get_message_data+0xfa>
			{
				//erase data and reset:current_save_message_offset
				memset(str, 0x00, sizeof(str));
8000430c:	fa c6 ff f8 	sub	r6,sp,-8
80004310:	30 08       	mov	r8,0
80004312:	30 09       	mov	r9,0
80004314:	ad 29       	st.d	--r6,r8
				return_code = data_flash_write((U8 *)str, data_address, bytes_remained);
80004316:	5c 77       	castu.h	r7
80004318:	0e 9a       	mov	r10,r7
8000431a:	0a 9b       	mov	r11,r5
8000431c:	1a 9c       	mov	r12,sp
8000431e:	f0 1f 00 1f 	mcall	80004398 <xgflash_get_message_data+0x14c>
				current_save_message_offset-=bytes_remained;
80004322:	49 f8       	lddpc	r8,8000439c <xgflash_get_message_data+0x150>
80004324:	70 09       	ld.w	r9,r8[0x0]
80004326:	0e 19       	sub	r9,r7
80004328:	91 09       	st.w	r8[0x0],r9
				//erase info and reset:current_message_index
				current_message_index-=1;
8000432a:	49 97       	lddpc	r7,8000438c <xgflash_get_message_data+0x140>
8000432c:	8e 08       	ld.sh	r8,r7[0x0]
8000432e:	20 18       	sub	r8,1
80004330:	ae 08       	st.h	r7[0x0],r8
				return_code = data_flash_write((U8 *)str, info_address, XG_MESSAGE_INFO_HEADER_LENGTH);
80004332:	30 8a       	mov	r10,8
80004334:	00 9b       	mov	r11,r0
80004336:	1a 9c       	mov	r12,sp
80004338:	f0 1f 00 18 	mcall	80004398 <xgflash_get_message_data+0x14c>
				return_code = data_flash_write((U8 *)&current_message_index, MESSAGE_NUMBERS_ADD, XG_MESSAGE_INFO_HEADER_LENGTH);
8000433c:	30 8a       	mov	r10,8
8000433e:	30 6b       	mov	r11,6
80004340:	0e 9c       	mov	r12,r7
80004342:	f0 1f 00 16 	mcall	80004398 <xgflash_get_message_data+0x14c>
			}
		
			xSemaphoreGive(xgflash_mutex);//unlock
80004346:	49 08       	lddpc	r8,80004384 <xgflash_get_message_data+0x138>
80004348:	70 0c       	ld.w	r12,r8[0x0]
8000434a:	30 09       	mov	r9,0
8000434c:	12 9a       	mov	r10,r9
8000434e:	12 9b       	mov	r11,r9
80004350:	f0 1f 00 10 	mcall	80004390 <xgflash_get_message_data+0x144>
80004354:	30 0c       	mov	r12,0
			return XG_OK;
80004356:	c1 28       	rjmp	8000437a <xgflash_get_message_data+0x12e>
		}
		xSemaphoreGive(xgflash_mutex);//unlock
80004358:	48 b8       	lddpc	r8,80004384 <xgflash_get_message_data+0x138>
8000435a:	70 0c       	ld.w	r12,r8[0x0]
8000435c:	30 09       	mov	r9,0
8000435e:	12 9a       	mov	r10,r9
80004360:	12 9b       	mov	r11,r9
80004362:	f0 1f 00 0c 	mcall	80004390 <xgflash_get_message_data+0x144>
80004366:	30 1c       	mov	r12,1
		return XG_INVALID_PARAM;
80004368:	c0 98       	rjmp	8000437a <xgflash_get_message_data+0x12e>
	}
	
	xSemaphoreGive(xgflash_mutex);//unlock
8000436a:	48 78       	lddpc	r8,80004384 <xgflash_get_message_data+0x138>
8000436c:	70 0c       	ld.w	r12,r8[0x0]
8000436e:	30 09       	mov	r9,0
80004370:	12 9a       	mov	r10,r9
80004372:	12 9b       	mov	r11,r9
80004374:	f0 1f 00 07 	mcall	80004390 <xgflash_get_message_data+0x144>
80004378:	30 6c       	mov	r12,6
	return XG_FLASH_ACTION_FAIL;
		
}
8000437a:	2f ed       	sub	sp,-8
8000437c:	d8 32       	popm	r0-r7,pc
8000437e:	00 00       	add	r0,r0
80004380:	00 00       	add	r0,r0
80004382:	0a 78       	tst	r8,r5
80004384:	00 00       	add	r0,r0
80004386:	0a 88       	andn	r8,r5
80004388:	80 00       	ld.sh	r0,r0[0x0]
8000438a:	54 c4       	stdsp	sp[0x130],r4
8000438c:	00 00       	add	r0,r0
8000438e:	0a 8c       	andn	r12,r5
80004390:	80 00       	ld.sh	r0,r0[0x0]
80004392:	56 80       	stdsp	sp[0x1a0],r0
80004394:	80 00       	ld.sh	r0,r0[0x0]
80004396:	2b c4       	sub	r4,-68
80004398:	80 00       	ld.sh	r0,r0[0x0]
8000439a:	2d fc       	sub	r12,-33
8000439c:	00 00       	add	r0,r0
8000439e:	05 14       	ld.sh	r4,r2++

800043a0 <xgflash_message_save>:
	
}

static U32 current_bytes_remained = 0;
xgflash_status_t xgflash_message_save(U8 *data_ptr, U16 data_len, U8 data_end_flag)
{
800043a0:	d4 21       	pushm	r4-r7,lr
800043a2:	20 2d       	sub	sp,8
800043a4:	18 96       	mov	r6,r12
800043a6:	16 97       	mov	r7,r11
800043a8:	14 95       	mov	r5,r10

	if(!list_init_success_flag)return XG_ERROR;
800043aa:	4c d8       	lddpc	r8,800044dc <xgflash_message_save+0x13c>
800043ac:	11 89       	ld.ub	r9,r8[0x0]
800043ae:	30 08       	mov	r8,0
800043b0:	f0 09 18 00 	cp.b	r9,r8
800043b4:	c0 31       	brne	800043ba <xgflash_message_save+0x1a>
800043b6:	3f fc       	mov	r12,-1
800043b8:	c8 f8       	rjmp	800044d6 <xgflash_message_save+0x136>
	U32 address = 0;
	static U32 bytes_remained = 0;
	df_status_t return_code = DF_WRITE_COMPLETED;
		
	current_bytes_remained+=data_len;//accumulate
800043ba:	16 94       	mov	r4,r11
800043bc:	5c 74       	castu.h	r4
800043be:	4c 98       	lddpc	r8,800044e0 <xgflash_message_save+0x140>
800043c0:	70 09       	ld.w	r9,r8[0x0]
800043c2:	e8 09 00 09 	add	r9,r4,r9
800043c6:	91 09       	st.w	r8[0x0],r9
	/* check input parameter */
	if (data_ptr == NULL || data_len > 0x0200)//512bytes
800043c8:	58 0c       	cp.w	r12,0
800043ca:	5f 0a       	sreq	r10
800043cc:	e0 68 02 00 	mov	r8,512
800043d0:	f0 0b 19 00 	cp.h	r11,r8
800043d4:	5f b8       	srhi	r8
800043d6:	f5 e8 10 08 	or	r8,r10,r8
800043da:	e0 81 00 7d 	brne	800044d4 <xgflash_message_save+0x134>
	{
		return XG_INVALID_PARAM;
	}
	if(current_bytes_remained > 0xF000)//data size > 60k,overout
800043de:	e0 49 f0 00 	cp.w	r9,61440
800043e2:	e0 8b 00 79 	brhi	800044d4 <xgflash_message_save+0x134>
	{
		//current_bytes_remained = 0;
		return XG_INVALID_PARAM;
	}
	
	xSemaphoreTake(xgflash_mutex, portMAX_DELAY) ;//lock
800043e6:	4c 08       	lddpc	r8,800044e4 <xgflash_message_save+0x144>
800043e8:	70 0c       	ld.w	r12,r8[0x0]
800043ea:	30 09       	mov	r9,0
800043ec:	3f fa       	mov	r10,-1
800043ee:	12 9b       	mov	r11,r9
800043f0:	f0 1f 00 3e 	mcall	800044e8 <xgflash_message_save+0x148>
	
	//save data
	if(current_save_message_offset > XG_MESSAGE_DATA_BOUNDARY_ADD)//The message data is out of boundary
800043f4:	4b e8       	lddpc	r8,800044ec <xgflash_message_save+0x14c>
800043f6:	70 0b       	ld.w	r11,r8[0x0]
800043f8:	e0 68 ff ff 	mov	r8,65535
800043fc:	ea 18 00 7f 	orh	r8,0x7f
80004400:	10 3b       	cp.w	r11,r8
80004402:	e0 88 00 0e 	brls	8000441e <xgflash_message_save+0x7e>
	{
		log("\r\n----message data is Out of bounds!!!\r\n----");
80004406:	4b bc       	lddpc	r12,800044f0 <xgflash_message_save+0x150>
80004408:	f0 1f 00 3b 	mcall	800044f4 <xgflash_message_save+0x154>
		xSemaphoreGive(xgflash_mutex );//unlock
8000440c:	4b 68       	lddpc	r8,800044e4 <xgflash_message_save+0x144>
8000440e:	70 0c       	ld.w	r12,r8[0x0]
80004410:	30 09       	mov	r9,0
80004412:	12 9a       	mov	r10,r9
80004414:	12 9b       	mov	r11,r9
80004416:	f0 1f 00 39 	mcall	800044f8 <xgflash_message_save+0x158>
8000441a:	30 3c       	mov	r12,3
		return XG_OUT_BOUNDARY;
8000441c:	c5 d8       	rjmp	800044d6 <xgflash_message_save+0x136>
	}
	
	
	return_code = data_flash_write((U8 *)data_ptr, current_save_message_offset, data_len);
8000441e:	0e 9a       	mov	r10,r7
80004420:	5c 7a       	castu.h	r10
80004422:	0c 9c       	mov	r12,r6
80004424:	f0 1f 00 36 	mcall	800044fc <xgflash_message_save+0x15c>
	if(return_code != DF_WRITE_COMPLETED)
80004428:	58 7c       	cp.w	r12,7
8000442a:	c0 a0       	breq	8000443e <xgflash_message_save+0x9e>
	{
		xSemaphoreGive(xgflash_mutex );//unlock
8000442c:	4a e8       	lddpc	r8,800044e4 <xgflash_message_save+0x144>
8000442e:	70 0c       	ld.w	r12,r8[0x0]
80004430:	30 09       	mov	r9,0
80004432:	12 9a       	mov	r10,r9
80004434:	12 9b       	mov	r11,r9
80004436:	f0 1f 00 31 	mcall	800044f8 <xgflash_message_save+0x158>
8000443a:	30 6c       	mov	r12,6
		return XG_FLASH_ACTION_FAIL;
8000443c:	c4 d8       	rjmp	800044d6 <xgflash_message_save+0x136>
	}
	
	current_save_message_offset+=data_len;
8000443e:	4a c8       	lddpc	r8,800044ec <xgflash_message_save+0x14c>
80004440:	70 09       	ld.w	r9,r8[0x0]
80004442:	12 04       	add	r4,r9
80004444:	91 04       	st.w	r8[0x0],r4
	//log("current_save_message_offset : %X\n", current_save_message_offset);
		
	MessageList_Info_t ptr;
		
	if(data_end_flag == TRUE)//save a message-info into list at the end of the resend-event
80004446:	30 18       	mov	r8,1
80004448:	f0 05 18 00 	cp.b	r5,r8
8000444c:	c3 b1       	brne	800044c2 <xgflash_message_save+0x122>
	{
		current_message_index++;
8000444e:	4a d9       	lddpc	r9,80004500 <xgflash_message_save+0x160>
80004450:	92 08       	ld.sh	r8,r9[0x0]
80004452:	2f f8       	sub	r8,-1
80004454:	b2 08       	st.h	r9[0x0],r8
		ptr.numb		= current_message_index;
80004456:	ba 08       	st.h	sp[0x0],r8
		ptr.address		= (current_save_message_offset - current_bytes_remained);
80004458:	4a 29       	lddpc	r9,800044e0 <xgflash_message_save+0x140>
8000445a:	72 09       	ld.w	r9,r9[0x0]
8000445c:	12 14       	sub	r4,r9
8000445e:	40 0a       	lddsp	r10,sp[0x0]
80004460:	e0 1a 00 00 	andl	r10,0x0
80004464:	f5 e4 13 0a 	or	r10,r10,r4>>0x10
80004468:	50 0a       	stdsp	sp[0x0],r10
8000446a:	ba 24       	st.h	sp[0x4],r4
		ptr.offset		= current_bytes_remained;
8000446c:	ba 39       	st.h	sp[0x6],r9
		
		address = XG_MESSAGE_INFO_HEADER_START_ADD + ((current_message_index -1)*XG_MESSAGE_INFO_HEADER_LENGTH);
8000446e:	5c 78       	castu.h	r8
80004470:	f0 0b 15 03 	lsl	r11,r8,0x3
		if(address > XG_MESSAGE_LISTINFO_BOUNDARY_ADD)//The number of messages is out of bounds
80004474:	e2 4b 00 00 	cp.w	r11,131072
80004478:	e0 88 00 0e 	brls	80004494 <xgflash_message_save+0xf4>
		{
			log("\r\n----info list is Out of bounds!!!\r\n----");
8000447c:	4a 2c       	lddpc	r12,80004504 <xgflash_message_save+0x164>
8000447e:	f0 1f 00 1e 	mcall	800044f4 <xgflash_message_save+0x154>
			xSemaphoreGive(xgflash_mutex );//unlock
80004482:	49 98       	lddpc	r8,800044e4 <xgflash_message_save+0x144>
80004484:	70 0c       	ld.w	r12,r8[0x0]
80004486:	30 09       	mov	r9,0
80004488:	12 9a       	mov	r10,r9
8000448a:	12 9b       	mov	r11,r9
8000448c:	f0 1f 00 1b 	mcall	800044f8 <xgflash_message_save+0x158>
80004490:	30 3c       	mov	r12,3
			return XG_OUT_BOUNDARY;
80004492:	c2 28       	rjmp	800044d6 <xgflash_message_save+0x136>
		}
		
		
		//set a message info by current_message_index	
		return_code = data_flash_write((U8 *)&ptr, address, XG_MESSAGE_INFO_HEADER_LENGTH);
80004494:	30 8a       	mov	r10,8
80004496:	1a 9c       	mov	r12,sp
80004498:	f0 1f 00 19 	mcall	800044fc <xgflash_message_save+0x15c>
		//set message numbers
		return_code = data_flash_write(&current_message_index, MESSAGE_NUMBERS_ADD, MESSAGE_NUMBERS_LENGTH);
8000449c:	30 2a       	mov	r10,2
8000449e:	30 6b       	mov	r11,6
800044a0:	49 8c       	lddpc	r12,80004500 <xgflash_message_save+0x160>
800044a2:	f0 1f 00 17 	mcall	800044fc <xgflash_message_save+0x15c>
		if(return_code != DF_WRITE_COMPLETED)
800044a6:	58 7c       	cp.w	r12,7
800044a8:	c0 a0       	breq	800044bc <xgflash_message_save+0x11c>
		{
			xSemaphoreGive(xgflash_mutex );//unlock
800044aa:	48 f8       	lddpc	r8,800044e4 <xgflash_message_save+0x144>
800044ac:	70 0c       	ld.w	r12,r8[0x0]
800044ae:	30 09       	mov	r9,0
800044b0:	12 9a       	mov	r10,r9
800044b2:	12 9b       	mov	r11,r9
800044b4:	f0 1f 00 11 	mcall	800044f8 <xgflash_message_save+0x158>
800044b8:	30 6c       	mov	r12,6
			return XG_FLASH_ACTION_FAIL;
800044ba:	c0 e8       	rjmp	800044d6 <xgflash_message_save+0x136>
		}
		
		current_bytes_remained = 0;//reset 0
800044bc:	30 09       	mov	r9,0
800044be:	48 98       	lddpc	r8,800044e0 <xgflash_message_save+0x140>
800044c0:	91 09       	st.w	r8[0x0],r9
	}
	
	xSemaphoreGive(xgflash_mutex );//unlock
800044c2:	48 98       	lddpc	r8,800044e4 <xgflash_message_save+0x144>
800044c4:	70 0c       	ld.w	r12,r8[0x0]
800044c6:	30 09       	mov	r9,0
800044c8:	12 9a       	mov	r10,r9
800044ca:	12 9b       	mov	r11,r9
800044cc:	f0 1f 00 0b 	mcall	800044f8 <xgflash_message_save+0x158>
800044d0:	30 0c       	mov	r12,0
	return XG_OK;
800044d2:	c0 28       	rjmp	800044d6 <xgflash_message_save+0x136>
800044d4:	30 1c       	mov	r12,1

}
800044d6:	2f ed       	sub	sp,-8
800044d8:	d8 22       	popm	r4-r7,pc
800044da:	00 00       	add	r0,r0
800044dc:	00 00       	add	r0,r0
800044de:	0a 78       	tst	r8,r5
800044e0:	00 00       	add	r0,r0
800044e2:	0a 90       	mov	r0,r5
800044e4:	00 00       	add	r0,r0
800044e6:	0a 88       	andn	r8,r5
800044e8:	80 00       	ld.sh	r0,r0[0x0]
800044ea:	54 c4       	stdsp	sp[0x130],r4
800044ec:	00 00       	add	r0,r0
800044ee:	05 14       	ld.sh	r4,r2++
800044f0:	80 00       	ld.sh	r0,r0[0x0]
800044f2:	cb 8c       	rcall	80004662 <runXGFlashTestREAD+0x92>
800044f4:	80 00       	ld.sh	r0,r0[0x0]
800044f6:	62 b8       	ld.w	r8,r1[0x2c]
800044f8:	80 00       	ld.sh	r0,r0[0x0]
800044fa:	56 80       	stdsp	sp[0x1a0],r0
800044fc:	80 00       	ld.sh	r0,r0[0x0]
800044fe:	2d fc       	sub	r12,-33
80004500:	00 00       	add	r0,r0
80004502:	0a 8c       	andn	r12,r5
80004504:	80 00       	ld.sh	r0,r0[0x0]
80004506:	cb bc       	rcall	8000467c <runXGFlashTestREAD+0xac>

80004508 <runXGFlashTestSAVE>:
	return status;
		
}

void runXGFlashTestSAVE( void *pvParameters )
{
80004508:	d4 31       	pushm	r0-r7,lr
8000450a:	20 8d       	sub	sp,32
	const portTickType xFrequency = 20000;//2s,定时问题已经修正。2s x  2000hz = 4000
	Message_Protocol_t data_ptr;
	static const uint8_t write_data[8] = {0x11, 0x23, 0x33, 0x67, 0x89, 0xAB, 0xCD, 0xEF};
	static  portTickType water_value;
	
	xLastWakeTime = xTaskGetTickCount();
8000450c:	f0 1f 00 16 	mcall	80004564 <runXGFlashTestSAVE+0x5c>
80004510:	49 68       	lddpc	r8,80004568 <runXGFlashTestSAVE+0x60>
80004512:	91 0c       	st.w	r8[0x0],r12
	while(1)
	{
		vTaskDelayUntil( &xLastWakeTime, xFrequency / portTICK_RATE_MS  );//精确的以1000ms为周期执行。
80004514:	10 96       	mov	r6,r8
80004516:	e0 65 4e 20 	mov	r5,20000
		nop();
		nop();
		//water_value = uxTaskGetStackHighWaterMark(NULL);
		//log("water_value: %d\n", water_value);
		//log("XG save okay!\n");
		memset(&data_ptr.data.XG_Time.Minute, 0x01, 1);
8000451a:	30 17       	mov	r7,1
		status = xgflash_message_save(&data_ptr, sizeof(Message_Protocol_t), TRUE);
8000451c:	30 13       	mov	r3,1
8000451e:	32 02       	mov	r2,32
80004520:	49 31       	lddpc	r1,8000456c <runXGFlashTestSAVE+0x64>
			log("XG save okay!\n");
			data_ptr.data.XG_Time.Second+=1;
		}
		else
		{
			log("save message err : %d\n", status);
80004522:	49 40       	lddpc	r0,80004570 <runXGFlashTestSAVE+0x68>
	static  portTickType water_value;
	
	xLastWakeTime = xTaskGetTickCount();
	while(1)
	{
		vTaskDelayUntil( &xLastWakeTime, xFrequency / portTICK_RATE_MS  );//精确的以1000ms为周期执行。
80004524:	0a 9b       	mov	r11,r5
80004526:	0c 9c       	mov	r12,r6
80004528:	f0 1f 00 13 	mcall	80004574 <runXGFlashTestSAVE+0x6c>
		//if (flashc_is_lock_error() || flashc_is_programming_error())
		//{
		//log("XG flashc_memcpy err...\n");
		//}
		//else
		nop();
8000452c:	d7 03       	nop
		nop();
8000452e:	d7 03       	nop
		nop();
80004530:	d7 03       	nop
		//water_value = uxTaskGetStackHighWaterMark(NULL);
		//log("water_value: %d\n", water_value);
		//log("XG save okay!\n");
		memset(&data_ptr.data.XG_Time.Minute, 0x01, 1);
80004532:	fb 67 00 1e 	st.b	sp[30],r7
		status = xgflash_message_save(&data_ptr, sizeof(Message_Protocol_t), TRUE);
80004536:	06 9a       	mov	r10,r3
80004538:	04 9b       	mov	r11,r2
8000453a:	1a 9c       	mov	r12,sp
8000453c:	f0 1f 00 0f 	mcall	80004578 <runXGFlashTestSAVE+0x70>
80004540:	83 0c       	st.w	r1[0x0],r12
		if(status == XG_OK)
80004542:	c0 a1       	brne	80004556 <runXGFlashTestSAVE+0x4e>
		{
			log("XG save okay!\n");
80004544:	48 ec       	lddpc	r12,8000457c <runXGFlashTestSAVE+0x74>
80004546:	f0 1f 00 0f 	mcall	80004580 <runXGFlashTestSAVE+0x78>
			data_ptr.data.XG_Time.Second+=1;
8000454a:	fb 38 00 1f 	ld.ub	r8,sp[31]
8000454e:	2f f8       	sub	r8,-1
80004550:	fb 68 00 1f 	st.b	sp[31],r8
80004554:	ce 8b       	rjmp	80004524 <runXGFlashTestSAVE+0x1c>
		}
		else
		{
			log("save message err : %d\n", status);
80004556:	1a dc       	st.w	--sp,r12
80004558:	00 9c       	mov	r12,r0
8000455a:	f0 1f 00 0a 	mcall	80004580 <runXGFlashTestSAVE+0x78>
8000455e:	2f fd       	sub	sp,-4
80004560:	ce 2b       	rjmp	80004524 <runXGFlashTestSAVE+0x1c>
80004562:	00 00       	add	r0,r0
80004564:	80 00       	ld.sh	r0,r0[0x0]
80004566:	5b e4       	cp.w	r4,-2
80004568:	00 00       	add	r0,r0
8000456a:	0a f0       	st.b	--r5,r0
8000456c:	00 00       	add	r0,r0
8000456e:	05 04       	ld.w	r4,r2++
80004570:	80 00       	ld.sh	r0,r0[0x0]
80004572:	cb f8       	rjmp	800046f0 <gpio_enable_module_pin+0x6>
80004574:	80 00       	ld.sh	r0,r0[0x0]
80004576:	5d 94       	*unknown*
80004578:	80 00       	ld.sh	r0,r0[0x0]
8000457a:	43 a0       	lddsp	r0,sp[0xe8]
8000457c:	80 00       	ld.sh	r0,r0[0x0]
8000457e:	cb e8       	rjmp	800046fa <gpio_enable_module_pin+0x10>
80004580:	80 00       	ld.sh	r0,r0[0x0]
80004582:	62 b8       	ld.w	r8,r1[0x2c]

80004584 <xgflash_get_message_count>:
	}
	return XG_ERROR;
	
}
U16 xgflash_get_message_count(void)
{
80004584:	eb cd 40 c0 	pushm	r6-r7,lr
	if(!list_init_success_flag)return 0xFFFF;
80004588:	48 d8       	lddpc	r8,800045bc <xgflash_get_message_count+0x38>
8000458a:	11 89       	ld.ub	r9,r8[0x0]
8000458c:	30 08       	mov	r8,0
8000458e:	f0 09 18 00 	cp.b	r9,r8
80004592:	c0 31       	brne	80004598 <xgflash_get_message_count+0x14>
80004594:	3f f7       	mov	r7,-1
80004596:	c1 08       	rjmp	800045b6 <xgflash_get_message_count+0x32>
	
	xSemaphoreTake(xgflash_mutex, portMAX_DELAY);
80004598:	48 a6       	lddpc	r6,800045c0 <xgflash_get_message_count+0x3c>
8000459a:	6c 0c       	ld.w	r12,r6[0x0]
8000459c:	30 09       	mov	r9,0
8000459e:	3f fa       	mov	r10,-1
800045a0:	12 9b       	mov	r11,r9
800045a2:	f0 1f 00 09 	mcall	800045c4 <xgflash_get_message_count+0x40>
	U16 return_value = current_message_index;
800045a6:	48 98       	lddpc	r8,800045c8 <xgflash_get_message_count+0x44>
800045a8:	90 07       	ld.sh	r7,r8[0x0]
	xSemaphoreGive(xgflash_mutex );
800045aa:	6c 0c       	ld.w	r12,r6[0x0]
800045ac:	30 09       	mov	r9,0
800045ae:	12 9a       	mov	r10,r9
800045b0:	12 9b       	mov	r11,r9
800045b2:	f0 1f 00 07 	mcall	800045cc <xgflash_get_message_count+0x48>

	return return_value;
	
}
800045b6:	0e 9c       	mov	r12,r7
800045b8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800045bc:	00 00       	add	r0,r0
800045be:	0a 78       	tst	r8,r5
800045c0:	00 00       	add	r0,r0
800045c2:	0a 88       	andn	r8,r5
800045c4:	80 00       	ld.sh	r0,r0[0x0]
800045c6:	54 c4       	stdsp	sp[0x130],r4
800045c8:	00 00       	add	r0,r0
800045ca:	0a 8c       	andn	r12,r5
800045cc:	80 00       	ld.sh	r0,r0[0x0]
800045ce:	56 80       	stdsp	sp[0x1a0],r0

800045d0 <runXGFlashTestREAD>:
		}
	}
	
}
void runXGFlashTestREAD( void *pvParameters )
{
800045d0:	d4 31       	pushm	r0-r7,lr
	Bool firstTest = TRUE;
	static  portTickType xLastWakeTime;
	static xgflash_status_t status = XG_ERROR;
	const portTickType xFrequency = 22000;//2s,定时问题已经修正。1.5s x  2000hz = 3000
	Message_Protocol_t *data_ptr = (Message_Protocol_t *) pvPortMalloc(sizeof(Message_Protocol_t));
800045d2:	32 0c       	mov	r12,32
800045d4:	f0 1f 00 31 	mcall	80004698 <runXGFlashTestREAD+0xc8>
800045d8:	18 94       	mov	r4,r12
	static U16 message_count = 0;
	U8 return_err =0;
	static char SN[10];
	memset(SN, 0x00, 10);
800045da:	4b 18       	lddpc	r8,8000469c <runXGFlashTestREAD+0xcc>
800045dc:	30 0a       	mov	r10,0
800045de:	30 0b       	mov	r11,0
800045e0:	f0 eb 00 00 	st.d	r8[0],r10
800045e4:	30 09       	mov	r9,0
800045e6:	b0 49       	st.h	r8[0x8],r9
	
	xLastWakeTime = xTaskGetTickCount();
800045e8:	f0 1f 00 2e 	mcall	800046a0 <runXGFlashTestREAD+0xd0>
800045ec:	4a e8       	lddpc	r8,800046a4 <runXGFlashTestREAD+0xd4>
800045ee:	91 0c       	st.w	r8[0x0],r12
	
	while(1)
	{
		vTaskDelayUntil( &xLastWakeTime, xFrequency / portTICK_RATE_MS  );//精确的以1000ms为周期执行。
800045f0:	e0 6b 55 f0 	mov	r11,22000
800045f4:	10 9c       	mov	r12,r8
800045f6:	f0 1f 00 2d 	mcall	800046a8 <runXGFlashTestREAD+0xd8>
		if(data_ptr == NULL)break;
800045fa:	58 04       	cp.w	r4,0
800045fc:	c4 10       	breq	8000467e <runXGFlashTestREAD+0xae>
800045fe:	c0 68       	rjmp	8000460a <runXGFlashTestREAD+0x3a>
	
	xLastWakeTime = xTaskGetTickCount();
	
	while(1)
	{
		vTaskDelayUntil( &xLastWakeTime, xFrequency / portTICK_RATE_MS  );//精确的以1000ms为周期执行。
80004600:	0a 9b       	mov	r11,r5
80004602:	0c 9c       	mov	r12,r6
80004604:	f0 1f 00 29 	mcall	800046a8 <runXGFlashTestREAD+0xd8>
80004608:	c0 98       	rjmp	8000461a <runXGFlashTestREAD+0x4a>
		if(data_ptr == NULL)break;
		message_count = xgflash_get_message_count();
8000460a:	4a 97       	lddpc	r7,800046ac <runXGFlashTestREAD+0xdc>
	
	xLastWakeTime = xTaskGetTickCount();
	
	while(1)
	{
		vTaskDelayUntil( &xLastWakeTime, xFrequency / portTICK_RATE_MS  );//精确的以1000ms为周期执行。
8000460c:	4a 66       	lddpc	r6,800046a4 <runXGFlashTestREAD+0xd4>
8000460e:	e0 65 55 f0 	mov	r5,22000
		if(data_ptr == NULL)break;
		message_count = xgflash_get_message_count();
		if(message_count != 0)
		{
			log("message_count : %d\n", message_count);
80004612:	4a 82       	lddpc	r2,800046b0 <runXGFlashTestREAD+0xe0>
			status = xgflash_get_message_data(message_count, data_ptr, true);
80004614:	30 11       	mov	r1,1
80004616:	4a 80       	lddpc	r0,800046b4 <runXGFlashTestREAD+0xe4>
			if(status == XG_OK)
			{
				log("read out data : %d\n", data_ptr->data.XG_Time.Second);
				
				return_err = scan_patrol(SN);
80004618:	4a 13       	lddpc	r3,8000469c <runXGFlashTestREAD+0xcc>
	
	while(1)
	{
		vTaskDelayUntil( &xLastWakeTime, xFrequency / portTICK_RATE_MS  );//精确的以1000ms为周期执行。
		if(data_ptr == NULL)break;
		message_count = xgflash_get_message_count();
8000461a:	f0 1f 00 28 	mcall	800046b8 <runXGFlashTestREAD+0xe8>
8000461e:	5c 8c       	casts.h	r12
80004620:	ae 0c       	st.h	r7[0x0],r12
		if(message_count != 0)
80004622:	c3 50       	breq	8000468c <runXGFlashTestREAD+0xbc>
		{
			log("message_count : %d\n", message_count);
80004624:	5c 7c       	castu.h	r12
80004626:	1a dc       	st.w	--sp,r12
80004628:	04 9c       	mov	r12,r2
8000462a:	f0 1f 00 25 	mcall	800046bc <runXGFlashTestREAD+0xec>
			status = xgflash_get_message_data(message_count, data_ptr, true);
8000462e:	02 9a       	mov	r10,r1
80004630:	08 9b       	mov	r11,r4
80004632:	8e 8c       	ld.uh	r12,r7[0x0]
80004634:	f0 1f 00 23 	mcall	800046c0 <runXGFlashTestREAD+0xf0>
80004638:	81 0c       	st.w	r0[0x0],r12
			if(status == XG_OK)
8000463a:	2f fd       	sub	sp,-4
8000463c:	58 0c       	cp.w	r12,0
8000463e:	c1 a1       	brne	80004672 <runXGFlashTestREAD+0xa2>
			{
				log("read out data : %d\n", data_ptr->data.XG_Time.Second);
80004640:	e9 38 00 1f 	ld.ub	r8,r4[31]
80004644:	1a d8       	st.w	--sp,r8
80004646:	4a 0c       	lddpc	r12,800046c4 <runXGFlashTestREAD+0xf4>
80004648:	f0 1f 00 1d 	mcall	800046bc <runXGFlashTestREAD+0xec>
				
				return_err = scan_patrol(SN);
8000464c:	06 9c       	mov	r12,r3
8000464e:	f0 1f 00 1f 	mcall	800046c8 <runXGFlashTestREAD+0xf8>
				if(return_err == 0){
80004652:	2f fd       	sub	sp,-4
80004654:	58 0c       	cp.w	r12,0
80004656:	cd 51       	brne	80004600 <runXGFlashTestREAD+0x30>
					
					log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
80004658:	07 b8       	ld.ub	r8,r3[0x3]
8000465a:	1a d8       	st.w	--sp,r8
8000465c:	07 a8       	ld.ub	r8,r3[0x2]
8000465e:	1a d8       	st.w	--sp,r8
80004660:	07 98       	ld.ub	r8,r3[0x1]
80004662:	1a d8       	st.w	--sp,r8
80004664:	07 88       	ld.ub	r8,r3[0x0]
80004666:	1a d8       	st.w	--sp,r8
80004668:	49 9c       	lddpc	r12,800046cc <runXGFlashTestREAD+0xfc>
8000466a:	f0 1f 00 15 	mcall	800046bc <runXGFlashTestREAD+0xec>
8000466e:	2f cd       	sub	sp,-16
80004670:	cc 8b       	rjmp	80004600 <runXGFlashTestREAD+0x30>
				}
			}
			else
			{
				log("get message err : %d\n", status);
80004672:	1a dc       	st.w	--sp,r12
80004674:	49 7c       	lddpc	r12,800046d0 <runXGFlashTestREAD+0x100>
80004676:	f0 1f 00 12 	mcall	800046bc <runXGFlashTestREAD+0xec>
8000467a:	2f fd       	sub	sp,-4
8000467c:	cc 2b       	rjmp	80004600 <runXGFlashTestREAD+0x30>
		}
		else
		continue;
		
	}
	vPortFree(data_ptr);
8000467e:	08 9c       	mov	r12,r4
80004680:	f0 1f 00 15 	mcall	800046d4 <runXGFlashTestREAD+0x104>
	log("data_ptr == NULL,exit runXGFlashTestREAD\n");
80004684:	49 5c       	lddpc	r12,800046d8 <runXGFlashTestREAD+0x108>
80004686:	f0 1f 00 0e 	mcall	800046bc <runXGFlashTestREAD+0xec>
	
}
8000468a:	d8 32       	popm	r0-r7,pc
	
	xLastWakeTime = xTaskGetTickCount();
	
	while(1)
	{
		vTaskDelayUntil( &xLastWakeTime, xFrequency / portTICK_RATE_MS  );//精确的以1000ms为周期执行。
8000468c:	0a 9b       	mov	r11,r5
8000468e:	0c 9c       	mov	r12,r6
80004690:	f0 1f 00 06 	mcall	800046a8 <runXGFlashTestREAD+0xd8>
80004694:	cc 3b       	rjmp	8000461a <runXGFlashTestREAD+0x4a>
80004696:	00 00       	add	r0,r0
80004698:	80 00       	ld.sh	r0,r0[0x0]
8000469a:	53 cc       	stdsp	sp[0xf0],r12
8000469c:	00 00       	add	r0,r0
8000469e:	0a 7c       	tst	r12,r5
800046a0:	80 00       	ld.sh	r0,r0[0x0]
800046a2:	5b e4       	cp.w	r4,-2
800046a4:	00 00       	add	r0,r0
800046a6:	0a 98       	mov	r8,r5
800046a8:	80 00       	ld.sh	r0,r0[0x0]
800046aa:	5d 94       	*unknown*
800046ac:	00 00       	add	r0,r0
800046ae:	0a 9c       	mov	r12,r5
800046b0:	80 00       	ld.sh	r0,r0[0x0]
800046b2:	cc 10       	breq	80004634 <runXGFlashTestREAD+0x64>
800046b4:	00 00       	add	r0,r0
800046b6:	05 08       	ld.w	r8,r2++
800046b8:	80 00       	ld.sh	r0,r0[0x0]
800046ba:	45 84       	lddsp	r4,sp[0x160]
800046bc:	80 00       	ld.sh	r0,r0[0x0]
800046be:	62 b8       	ld.w	r8,r1[0x2c]
800046c0:	80 00       	ld.sh	r0,r0[0x0]
800046c2:	42 4c       	lddsp	r12,sp[0x90]
800046c4:	80 00       	ld.sh	r0,r0[0x0]
800046c6:	cc 24       	brge	8000464a <runXGFlashTestREAD+0x7a>
800046c8:	80 00       	ld.sh	r0,r0[0x0]
800046ca:	3c 90       	mov	r0,-55
800046cc:	80 00       	ld.sh	r0,r0[0x0]
800046ce:	ca 30       	breq	80004614 <runXGFlashTestREAD+0x44>
800046d0:	80 00       	ld.sh	r0,r0[0x0]
800046d2:	cc 38       	rjmp	80004858 <INTC_init_interrupts+0x18>
800046d4:	80 00       	ld.sh	r0,r0[0x0]
800046d6:	53 a4       	stdsp	sp[0xe8],r4
800046d8:	80 00       	ld.sh	r0,r0[0x0]
800046da:	cc 50       	breq	80004664 <runXGFlashTestREAD+0x94>

800046dc <flashc_set_wait_state>:
}


void flashc_set_wait_state(unsigned int wait_state)
{
	u_avr32_flashc_fcr_t u_avr32_flashc_fcr = {AVR32_FLASHC.fcr};
800046dc:	fe 68 14 00 	mov	r8,-125952
800046e0:	70 09       	ld.w	r9,r8[0x0]
	u_avr32_flashc_fcr.FCR.fws = wait_state;
800046e2:	f3 dc d0 c1 	bfins	r9,r12,0x6,0x1
	AVR32_FLASHC.fcr = u_avr32_flashc_fcr.fcr;
800046e6:	91 09       	st.w	r8[0x0],r9
}
800046e8:	5e fc       	retal	r12

800046ea <gpio_enable_module_pin>:
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
800046ea:	f8 08 16 05 	lsr	r8,r12,0x5
800046ee:	a9 68       	lsl	r8,0x8
800046f0:	e0 28 f0 00 	sub	r8,61440

	/* Enable the correct function. */
	switch (function) {
800046f4:	58 1b       	cp.w	r11,1
800046f6:	c0 d0       	breq	80004710 <gpio_enable_module_pin+0x26>
800046f8:	c0 63       	brcs	80004704 <gpio_enable_module_pin+0x1a>
800046fa:	58 2b       	cp.w	r11,2
800046fc:	c1 00       	breq	8000471c <gpio_enable_module_pin+0x32>
800046fe:	58 3b       	cp.w	r11,3
80004700:	c1 40       	breq	80004728 <gpio_enable_module_pin+0x3e>
80004702:	5e ff       	retal	1
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80004704:	30 19       	mov	r9,1
80004706:	f2 0c 09 49 	lsl	r9,r9,r12
8000470a:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
8000470c:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
8000470e:	c1 28       	rjmp	80004732 <gpio_enable_module_pin+0x48>

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80004710:	30 19       	mov	r9,1
80004712:	f2 0c 09 49 	lsl	r9,r9,r12
80004716:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80004718:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
8000471a:	c0 c8       	rjmp	80004732 <gpio_enable_module_pin+0x48>

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
8000471c:	30 19       	mov	r9,1
8000471e:	f2 0c 09 49 	lsl	r9,r9,r12
80004722:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80004724:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80004726:	c0 68       	rjmp	80004732 <gpio_enable_module_pin+0x48>

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80004728:	30 19       	mov	r9,1
8000472a:	f2 0c 09 49 	lsl	r9,r9,r12
8000472e:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80004730:	91 99       	st.w	r8[0x24],r9
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
80004732:	30 19       	mov	r9,1
80004734:	f2 0c 09 4c 	lsl	r12,r9,r12
80004738:	91 2c       	st.w	r8[0x8],r12
8000473a:	5e fd       	retal	0

8000473c <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
8000473c:	d4 21       	pushm	r4-r7,lr
8000473e:	18 97       	mov	r7,r12
80004740:	16 94       	mov	r4,r11
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
80004742:	58 0b       	cp.w	r11,0
80004744:	c0 31       	brne	8000474a <gpio_enable_module+0xe>
80004746:	30 05       	mov	r5,0
80004748:	c0 d8       	rjmp	80004762 <gpio_enable_module+0x26>
8000474a:	30 06       	mov	r6,0
8000474c:	0c 95       	mov	r5,r6
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
8000474e:	6e 1b       	ld.w	r11,r7[0x4]
80004750:	6e 0c       	ld.w	r12,r7[0x0]
80004752:	f0 1f 00 06 	mcall	80004768 <gpio_enable_module+0x2c>
80004756:	18 45       	or	r5,r12
		gpiomap++;
80004758:	2f 87       	sub	r7,-8
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
8000475a:	2f f6       	sub	r6,-1
8000475c:	0c 34       	cp.w	r4,r6
8000475e:	fe 9b ff f8 	brhi	8000474e <gpio_enable_module+0x12>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
}
80004762:	0a 9c       	mov	r12,r5
80004764:	d8 22       	popm	r4-r7,pc
80004766:	00 00       	add	r0,r0
80004768:	80 00       	ld.sh	r0,r0[0x0]
8000476a:	46 ea       	lddsp	r10,sp[0x1b8]

8000476c <gpio_enable_gpio_pin>:
 *            AVR32_PWM_3_PIN for PWM channel 3 can also be used to release
 *            module pins for GPIO.
 */
void gpio_enable_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
8000476c:	f8 08 16 05 	lsr	r8,r12,0x5
80004770:	a9 68       	lsl	r8,0x8
80004772:	e0 28 f0 00 	sub	r8,61440
	
	gpio_port->oderc = 1 << (pin & 0x1F);
80004776:	30 19       	mov	r9,1
80004778:	f2 0c 09 4c 	lsl	r12,r9,r12
8000477c:	f1 4c 00 48 	st.w	r8[72],r12
	gpio_port->gpers = 1 << (pin & 0x1F);
80004780:	91 1c       	st.w	r8[0x4],r12
}
80004782:	5e fc       	retal	r12

80004784 <gpio_set_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_set_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80004784:	f8 08 16 05 	lsr	r8,r12,0x5
80004788:	a9 68       	lsl	r8,0x8
8000478a:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 1. */
	gpio_port->ovrs  = 1 << (pin & 0x1F);
8000478e:	30 19       	mov	r9,1
80004790:	f2 0c 09 4c 	lsl	r12,r9,r12
80004794:	f1 4c 00 54 	st.w	r8[84],r12
	/* The GPIO output driver is enabled for that pin. */ 
	gpio_port->oders = 1 << (pin & 0x1F);
80004798:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
8000479c:	91 1c       	st.w	r8[0x4],r12
}
8000479e:	5e fc       	retal	r12

800047a0 <gpio_clr_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_clr_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
800047a0:	f8 08 16 05 	lsr	r8,r12,0x5
800047a4:	a9 68       	lsl	r8,0x8
800047a6:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 0. */
	gpio_port->ovrc  = 1 << (pin & 0x1F);
800047aa:	30 19       	mov	r9,1
800047ac:	f2 0c 09 4c 	lsl	r12,r9,r12
800047b0:	f1 4c 00 58 	st.w	r8[88],r12
	/* The GPIO output driver is enabled for that pin. */
	gpio_port->oders = 1 << (pin & 0x1F);
800047b4:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
800047b8:	91 1c       	st.w	r8[0x4],r12
}
800047ba:	5e fc       	retal	r12

800047bc <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
800047bc:	c0 08       	rjmp	800047bc <_unhandled_interrupt>
800047be:	d7 03       	nop

800047c0 <INTC_register_interrupt>:
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
800047c0:	f6 08 16 05 	lsr	r8,r11,0x5

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
800047c4:	49 99       	lddpc	r9,80004828 <INTC_register_interrupt+0x68>
800047c6:	f2 08 00 39 	add	r9,r9,r8<<0x3
800047ca:	f7 db c0 05 	bfextu	r11,r11,0x0,0x5
800047ce:	72 19       	ld.w	r9,r9[0x4]
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
800047d0:	f2 0b 09 2c 	st.w	r9[r11<<0x2],r12
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
800047d4:	58 0a       	cp.w	r10,0
800047d6:	c0 91       	brne	800047e8 <INTC_register_interrupt+0x28>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
800047d8:	49 59       	lddpc	r9,8000482c <INTC_register_interrupt+0x6c>
800047da:	49 6a       	lddpc	r10,80004830 <INTC_register_interrupt+0x70>
800047dc:	12 1a       	sub	r10,r9
800047de:	fe 79 08 00 	mov	r9,-63488
800047e2:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800047e6:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT1) {
800047e8:	58 1a       	cp.w	r10,1
800047ea:	c0 a1       	brne	800047fe <INTC_register_interrupt+0x3e>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
800047ec:	49 09       	lddpc	r9,8000482c <INTC_register_interrupt+0x6c>
800047ee:	49 2a       	lddpc	r10,80004834 <INTC_register_interrupt+0x74>
800047f0:	12 1a       	sub	r10,r9
800047f2:	bf aa       	sbr	r10,0x1e
800047f4:	fe 79 08 00 	mov	r9,-63488
800047f8:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800047fc:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT2) {
800047fe:	58 2a       	cp.w	r10,2
80004800:	c0 a1       	brne	80004814 <INTC_register_interrupt+0x54>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
80004802:	48 b9       	lddpc	r9,8000482c <INTC_register_interrupt+0x6c>
80004804:	48 da       	lddpc	r10,80004838 <INTC_register_interrupt+0x78>
80004806:	12 1a       	sub	r10,r9
80004808:	bf ba       	sbr	r10,0x1f
8000480a:	fe 79 08 00 	mov	r9,-63488
8000480e:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80004812:	5e fc       	retal	r12
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
80004814:	48 69       	lddpc	r9,8000482c <INTC_register_interrupt+0x6c>
80004816:	48 aa       	lddpc	r10,8000483c <INTC_register_interrupt+0x7c>
80004818:	12 1a       	sub	r10,r9
8000481a:	ea 1a c0 00 	orh	r10,0xc000
8000481e:	fe 79 08 00 	mov	r9,-63488
80004822:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80004826:	5e fc       	retal	r12
80004828:	80 00       	ld.sh	r0,r0[0x0]
8000482a:	cc 7c       	rcall	800049b8 <pm_cksel+0x18>
8000482c:	80 00       	ld.sh	r0,r0[0x0]
8000482e:	c0 00       	breq	8000482e <INTC_register_interrupt+0x6e>
80004830:	80 00       	ld.sh	r0,r0[0x0]
80004832:	c1 04       	brge	80004852 <INTC_init_interrupts+0x12>
80004834:	80 00       	ld.sh	r0,r0[0x0]
80004836:	c1 12       	brcc	80004858 <INTC_init_interrupts+0x18>
80004838:	80 00       	ld.sh	r0,r0[0x0]
8000483a:	c1 20       	breq	8000485e <INTC_init_interrupts+0x1e>
8000483c:	80 00       	ld.sh	r0,r0[0x0]
8000483e:	c1 2e       	rcall	80004462 <xgflash_message_save+0xc2>

80004840 <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
80004840:	d4 21       	pushm	r4-r7,lr
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
80004842:	49 18       	lddpc	r8,80004884 <INTC_init_interrupts+0x44>
80004844:	e3 b8 00 01 	mtsr	0x4,r8
80004848:	49 0e       	lddpc	lr,80004888 <INTC_init_interrupts+0x48>
8000484a:	30 07       	mov	r7,0
8000484c:	0e 94       	mov	r4,r7
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
8000484e:	49 0c       	lddpc	r12,8000488c <INTC_init_interrupts+0x4c>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80004850:	49 05       	lddpc	r5,80004890 <INTC_init_interrupts+0x50>
80004852:	10 15       	sub	r5,r8
80004854:	fe 76 08 00 	mov	r6,-63488
80004858:	c1 08       	rjmp	80004878 <INTC_init_interrupts+0x38>
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
8000485a:	08 98       	mov	r8,r4
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
				._int_line_handler_table[int_req]
8000485c:	7c 1b       	ld.w	r11,lr[0x4]

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
8000485e:	7c 0a       	ld.w	r10,lr[0x0]
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
80004860:	f6 08 09 2c 	st.w	r11[r8<<0x2],r12
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
80004864:	2f f8       	sub	r8,-1

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80004866:	10 3a       	cp.w	r10,r8
80004868:	fe 9b ff fc 	brhi	80004860 <INTC_init_interrupts+0x20>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
8000486c:	ec 07 09 25 	st.w	r6[r7<<0x2],r5
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
80004870:	2f f7       	sub	r7,-1
80004872:	2f 8e       	sub	lr,-8
80004874:	59 37       	cp.w	r7,19
80004876:	c0 50       	breq	80004880 <INTC_init_interrupts+0x40>
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80004878:	7c 08       	ld.w	r8,lr[0x0]
8000487a:	58 08       	cp.w	r8,0
8000487c:	ce f1       	brne	8000485a <INTC_init_interrupts+0x1a>
8000487e:	cf 7b       	rjmp	8000486c <INTC_init_interrupts+0x2c>
80004880:	d8 22       	popm	r4-r7,pc
80004882:	00 00       	add	r0,r0
80004884:	80 00       	ld.sh	r0,r0[0x0]
80004886:	c0 00       	breq	80004886 <INTC_init_interrupts+0x46>
80004888:	80 00       	ld.sh	r0,r0[0x0]
8000488a:	cc 7c       	rcall	80004a18 <pm_pll_set_option+0x10>
8000488c:	80 00       	ld.sh	r0,r0[0x0]
8000488e:	47 bc       	lddsp	r12,sp[0x1ec]
80004890:	80 00       	ld.sh	r0,r0[0x0]
80004892:	c1 04       	brge	800048b2 <_get_interrupt_handler+0x1e>

80004894 <_get_interrupt_handler>:
__int_handler _get_interrupt_handler(uint32_t int_level)
{
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
80004894:	fe 78 08 00 	mov	r8,-63488
80004898:	e0 69 00 83 	mov	r9,131
8000489c:	f2 0c 01 0c 	sub	r12,r9,r12
800048a0:	f0 0c 03 29 	ld.w	r9,r8[r12<<0x2]
	uint32_t int_req = AVR32_INTC.irr[int_grp];
800048a4:	f2 ca ff c0 	sub	r10,r9,-64
800048a8:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
800048ac:	58 08       	cp.w	r8,0
800048ae:	c0 21       	brne	800048b2 <_get_interrupt_handler+0x1e>
800048b0:	5e fd       	retal	0
		? _int_handler_table[int_grp]._int_line_handler_table[32
800048b2:	f0 08 12 00 	clz	r8,r8
800048b6:	48 5a       	lddpc	r10,800048c8 <_get_interrupt_handler+0x34>
800048b8:	f4 09 00 39 	add	r9,r10,r9<<0x3
800048bc:	f0 08 11 1f 	rsub	r8,r8,31
800048c0:	72 19       	ld.w	r9,r9[0x4]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
800048c2:	f2 08 03 2c 	ld.w	r12,r9[r8<<0x2]
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
800048c6:	5e fc       	retal	r12
800048c8:	80 00       	ld.sh	r0,r0[0x0]
800048ca:	cc 7c       	rcall	80004a58 <pm_switch_to_osc0+0x14>

800048cc <pm_set_osc0_mode>:
 * \param mode Oscillator 0 mode (i.e. AVR32_PM_OSCCTRL0_MODE_x).
 */
static void pm_set_osc0_mode(volatile avr32_pm_t *pm, unsigned int mode)
{
  // Read
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
800048cc:	78 a8       	ld.w	r8,r12[0x28]
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.mode = mode;
800048ce:	f1 db d0 03 	bfins	r8,r11,0x0,0x3
  // Write
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
800048d2:	99 a8       	st.w	r12[0x28],r8
}
800048d4:	5e fc       	retal	r12
800048d6:	d7 03       	nop

800048d8 <pm_enable_osc0_crystal>:
  pm_set_osc0_mode(pm, AVR32_PM_OSCCTRL0_MODE_EXT_CLOCK);
}


void pm_enable_osc0_crystal(volatile avr32_pm_t *pm, unsigned int fosc0)
{
800048d8:	d4 01       	pushm	lr
  pm_set_osc0_mode(pm, (fosc0 <  900000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G0 :
800048da:	ec 5b bb 9f 	cp.w	r11,899999
800048de:	e0 8b 00 04 	brhi	800048e6 <pm_enable_osc0_crystal+0xe>
800048e2:	30 4b       	mov	r11,4
800048e4:	c1 38       	rjmp	8000490a <pm_enable_osc0_crystal+0x32>
800048e6:	e0 68 c6 bf 	mov	r8,50879
800048ea:	ea 18 00 2d 	orh	r8,0x2d
800048ee:	10 3b       	cp.w	r11,r8
800048f0:	e0 8b 00 04 	brhi	800048f8 <pm_enable_osc0_crystal+0x20>
800048f4:	30 5b       	mov	r11,5
800048f6:	c0 a8       	rjmp	8000490a <pm_enable_osc0_crystal+0x32>
800048f8:	e0 68 12 00 	mov	r8,4608
800048fc:	ea 18 00 7a 	orh	r8,0x7a
80004900:	10 3b       	cp.w	r11,r8
80004902:	f9 bb 03 06 	movlo	r11,6
80004906:	f9 bb 02 07 	movhs	r11,7
8000490a:	f0 1f 00 02 	mcall	80004910 <pm_enable_osc0_crystal+0x38>
                       (fosc0 < 3000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G1 :
                       (fosc0 < 8000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G2 :
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}
8000490e:	d8 02       	popm	pc
80004910:	80 00       	ld.sh	r0,r0[0x0]
80004912:	48 cc       	lddpc	r12,80004940 <pm_enable_clk0+0x10>

80004914 <pm_enable_clk0_no_wait>:


void pm_enable_clk0_no_wait(volatile avr32_pm_t *pm, unsigned int startup)
{
  // Read register
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
80004914:	78 a8       	ld.w	r8,r12[0x28]
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.startup = startup;
80004916:	f1 db d1 03 	bfins	r8,r11,0x8,0x3
  // Write back
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
8000491a:	99 a8       	st.w	r12[0x28],r8

  pm->mcctrl |= AVR32_PM_MCCTRL_OSC0EN_MASK;
8000491c:	78 08       	ld.w	r8,r12[0x0]
8000491e:	a3 a8       	sbr	r8,0x2
80004920:	99 08       	st.w	r12[0x0],r8
}
80004922:	5e fc       	retal	r12

80004924 <pm_wait_for_clk0_ready>:


void pm_wait_for_clk0_ready(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
80004924:	79 58       	ld.w	r8,r12[0x54]
80004926:	e2 18 00 80 	andl	r8,0x80,COH
8000492a:	cf d0       	breq	80004924 <pm_wait_for_clk0_ready>
}
8000492c:	5e fc       	retal	r12
8000492e:	d7 03       	nop

80004930 <pm_enable_clk0>:
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}


void pm_enable_clk0(volatile avr32_pm_t *pm, unsigned int startup)
{
80004930:	eb cd 40 80 	pushm	r7,lr
80004934:	18 97       	mov	r7,r12
  pm_enable_clk0_no_wait(pm, startup);
80004936:	f0 1f 00 04 	mcall	80004944 <pm_enable_clk0+0x14>
  pm_wait_for_clk0_ready(pm);
8000493a:	0e 9c       	mov	r12,r7
8000493c:	f0 1f 00 03 	mcall	80004948 <pm_enable_clk0+0x18>
}
80004940:	e3 cd 80 80 	ldm	sp++,r7,pc
80004944:	80 00       	ld.sh	r0,r0[0x0]
80004946:	49 14       	lddpc	r4,80004988 <pm_enable_clk32+0x4>
80004948:	80 00       	ld.sh	r0,r0[0x0]
8000494a:	49 24       	lddpc	r4,80004990 <pm_enable_clk32+0xc>

8000494c <pm_set_osc32_mode>:
 * \param mode 32-kHz oscillator mode (i.e. AVR32_PM_OSCCTRL32_MODE_x).
 */
static void pm_set_osc32_mode(volatile avr32_pm_t *pm, unsigned int mode)
{
  // Read
  u_avr32_pm_oscctrl32_t u_avr32_pm_oscctrl32 = {pm->oscctrl32};
8000494c:	78 c8       	ld.w	r8,r12[0x30]
  // Modify
  u_avr32_pm_oscctrl32.OSCCTRL32.mode = mode;
8000494e:	f1 db d1 03 	bfins	r8,r11,0x8,0x3
  // Write
  pm->oscctrl32 = u_avr32_pm_oscctrl32.oscctrl32;
80004952:	99 c8       	st.w	r12[0x30],r8
}
80004954:	5e fc       	retal	r12
80004956:	d7 03       	nop

80004958 <pm_enable_osc32_crystal>:
  pm_set_osc32_mode(pm, AVR32_PM_OSCCTRL32_MODE_EXT_CLOCK);
}


void pm_enable_osc32_crystal(volatile avr32_pm_t *pm)
{
80004958:	d4 01       	pushm	lr
  pm_set_osc32_mode(pm, AVR32_PM_OSCCTRL32_MODE_CRYSTAL);
8000495a:	30 1b       	mov	r11,1
8000495c:	f0 1f 00 02 	mcall	80004964 <pm_enable_osc32_crystal+0xc>
}
80004960:	d8 02       	popm	pc
80004962:	00 00       	add	r0,r0
80004964:	80 00       	ld.sh	r0,r0[0x0]
80004966:	49 4c       	lddpc	r12,800049b4 <pm_cksel+0x14>

80004968 <pm_enable_clk32_no_wait>:


void pm_enable_clk32_no_wait(volatile avr32_pm_t *pm, unsigned int startup)
{
  // Read register
  u_avr32_pm_oscctrl32_t u_avr32_pm_oscctrl32 = {pm->oscctrl32};
80004968:	78 c8       	ld.w	r8,r12[0x30]
  // Modify
  u_avr32_pm_oscctrl32.OSCCTRL32.osc32en = 1;
8000496a:	30 19       	mov	r9,1
8000496c:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
  u_avr32_pm_oscctrl32.OSCCTRL32.startup = startup;
80004970:	f1 db d2 03 	bfins	r8,r11,0x10,0x3
  // Write back
  pm->oscctrl32 = u_avr32_pm_oscctrl32.oscctrl32;
80004974:	99 c8       	st.w	r12[0x30],r8
}
80004976:	5e fc       	retal	r12

80004978 <pm_wait_for_clk32_ready>:


void pm_wait_for_clk32_ready(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_OSC32RDY_MASK));
80004978:	79 58       	ld.w	r8,r12[0x54]
8000497a:	e2 18 02 00 	andl	r8,0x200,COH
8000497e:	cf d0       	breq	80004978 <pm_wait_for_clk32_ready>
}
80004980:	5e fc       	retal	r12
80004982:	d7 03       	nop

80004984 <pm_enable_clk32>:
  pm_set_osc32_mode(pm, AVR32_PM_OSCCTRL32_MODE_CRYSTAL);
}


void pm_enable_clk32(volatile avr32_pm_t *pm, unsigned int startup)
{
80004984:	eb cd 40 80 	pushm	r7,lr
80004988:	18 97       	mov	r7,r12
  pm_enable_clk32_no_wait(pm, startup);
8000498a:	f0 1f 00 04 	mcall	80004998 <pm_enable_clk32+0x14>
  pm_wait_for_clk32_ready(pm);
8000498e:	0e 9c       	mov	r12,r7
80004990:	f0 1f 00 03 	mcall	8000499c <pm_enable_clk32+0x18>
}
80004994:	e3 cd 80 80 	ldm	sp++,r7,pc
80004998:	80 00       	ld.sh	r0,r0[0x0]
8000499a:	49 68       	lddpc	r8,800049f0 <pm_pll_setup+0xa>
8000499c:	80 00       	ld.sh	r0,r0[0x0]
8000499e:	49 78       	lddpc	r8,800049f8 <pm_pll_setup+0x12>

800049a0 <pm_cksel>:
              unsigned int pbasel,
              unsigned int pbbdiv,
              unsigned int pbbsel,
              unsigned int hsbdiv,
              unsigned int hsbsel)
{
800049a0:	eb cd 40 d0 	pushm	r4,r6-r7,lr
800049a4:	fa c4 ff f0 	sub	r4,sp,-16
  u_avr32_pm_cksel_t u_avr32_pm_cksel = {0};
800049a8:	30 0e       	mov	lr,0

  u_avr32_pm_cksel.CKSEL.cpusel = hsbsel;
800049aa:	09 f7       	ld.ub	r7,r4[0x7]
800049ac:	ef d7 c0 03 	bfextu	r7,r7,0x0,0x3
800049b0:	fd d7 d0 03 	bfins	lr,r7,0x0,0x3
  u_avr32_pm_cksel.CKSEL.cpudiv = hsbdiv;
800049b4:	09 b4       	ld.ub	r4,r4[0x3]
800049b6:	08 96       	mov	r6,r4
800049b8:	e9 d4 c0 01 	bfextu	r4,r4,0x0,0x1
800049bc:	fd d4 d0 e1 	bfins	lr,r4,0x7,0x1
  u_avr32_pm_cksel.CKSEL.hsbsel = hsbsel;
800049c0:	fd d7 d1 03 	bfins	lr,r7,0x8,0x3
  u_avr32_pm_cksel.CKSEL.hsbdiv = hsbdiv;
800049c4:	fd d4 d1 e1 	bfins	lr,r4,0xf,0x1
  u_avr32_pm_cksel.CKSEL.pbasel = pbasel;
800049c8:	fd da d2 03 	bfins	lr,r10,0x10,0x3
  u_avr32_pm_cksel.CKSEL.pbadiv = pbadiv;
800049cc:	fd db d2 e1 	bfins	lr,r11,0x17,0x1
  u_avr32_pm_cksel.CKSEL.pbbsel = pbbsel;
800049d0:	fd d8 d3 03 	bfins	lr,r8,0x18,0x3
  u_avr32_pm_cksel.CKSEL.pbbdiv = pbbdiv;
800049d4:	fd d9 d3 e1 	bfins	lr,r9,0x1f,0x1

  pm->cksel = u_avr32_pm_cksel.cksel;
800049d8:	99 1e       	st.w	r12[0x4],lr

  // Wait for ckrdy bit and then clear it
  while (!(pm->poscsr & AVR32_PM_POSCSR_CKRDY_MASK));
800049da:	79 58       	ld.w	r8,r12[0x54]
800049dc:	e2 18 00 20 	andl	r8,0x20,COH
800049e0:	cf d0       	breq	800049da <pm_cksel+0x3a>
}
800049e2:	e3 cd 80 d0 	ldm	sp++,r4,r6-r7,pc

800049e6 <pm_pll_setup>:
                  unsigned int pll,
                  unsigned int mul,
                  unsigned int div,
                  unsigned int osc,
                  unsigned int lockcount)
{
800049e6:	eb cd 40 80 	pushm	r7,lr
800049ea:	40 27       	lddsp	r7,sp[0x8]
  u_avr32_pm_pll_t u_avr32_pm_pll = {0};
800049ec:	30 0e       	mov	lr,0

  u_avr32_pm_pll.PLL.pllosc   = osc;
800049ee:	fd d8 d0 21 	bfins	lr,r8,0x1,0x1
  u_avr32_pm_pll.PLL.plldiv   = div;
800049f2:	fd d9 d1 04 	bfins	lr,r9,0x8,0x4
  u_avr32_pm_pll.PLL.pllmul   = mul;
800049f6:	fd da d2 04 	bfins	lr,r10,0x10,0x4
  u_avr32_pm_pll.PLL.pllcount = lockcount;
800049fa:	fd d7 d3 06 	bfins	lr,r7,0x18,0x6

  pm->pll[pll] = u_avr32_pm_pll.pll;
800049fe:	2f 8b       	sub	r11,-8
80004a00:	f8 0b 09 2e 	st.w	r12[r11<<0x2],lr
}
80004a04:	e3 cd 80 80 	ldm	sp++,r7,pc

80004a08 <pm_pll_set_option>:
void pm_pll_set_option(volatile avr32_pm_t *pm,
                       unsigned int pll,
                       unsigned int pll_freq,
                       unsigned int pll_div2,
                       unsigned int pll_wbwdisable)
{
80004a08:	d4 01       	pushm	lr
  u_avr32_pm_pll_t u_avr32_pm_pll = {pm->pll[pll]};
80004a0a:	2f 8b       	sub	r11,-8
80004a0c:	f8 0b 03 2e 	ld.w	lr,r12[r11<<0x2]
  u_avr32_pm_pll.PLL.pllopt = pll_freq | (pll_div2 << 1) | (pll_wbwdisable << 2);
80004a10:	f5 e9 10 19 	or	r9,r10,r9<<0x1
80004a14:	f3 e8 10 28 	or	r8,r9,r8<<0x2
80004a18:	fd d8 d0 43 	bfins	lr,r8,0x2,0x3
  pm->pll[pll] = u_avr32_pm_pll.pll;
80004a1c:	f8 0b 09 2e 	st.w	r12[r11<<0x2],lr
}
80004a20:	d8 02       	popm	pc

80004a22 <pm_pll_enable>:


void pm_pll_enable(volatile avr32_pm_t *pm,
                  unsigned int pll)
{
  pm->pll[pll] |= AVR32_PM_PLLEN_MASK;
80004a22:	2f 8b       	sub	r11,-8
80004a24:	f8 0b 03 28 	ld.w	r8,r12[r11<<0x2]
80004a28:	a1 a8       	sbr	r8,0x0
80004a2a:	f8 0b 09 28 	st.w	r12[r11<<0x2],r8
}
80004a2e:	5e fc       	retal	r12

80004a30 <pm_wait_for_pll0_locked>:
}


void pm_wait_for_pll0_locked(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_LOCK0_MASK));
80004a30:	79 58       	ld.w	r8,r12[0x54]
80004a32:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80004a36:	cf d0       	breq	80004a30 <pm_wait_for_pll0_locked>
}
80004a38:	5e fc       	retal	r12

80004a3a <pm_switch_to_clock>:


void pm_switch_to_clock(volatile avr32_pm_t *pm, unsigned long clock)
{
  // Read
  u_avr32_pm_mcctrl_t u_avr32_pm_mcctrl = {pm->mcctrl};
80004a3a:	78 08       	ld.w	r8,r12[0x0]
  // Modify
  u_avr32_pm_mcctrl.MCCTRL.mcsel = clock;
80004a3c:	f1 db d0 02 	bfins	r8,r11,0x0,0x2
  // Write back
  pm->mcctrl = u_avr32_pm_mcctrl.mcctrl;
80004a40:	99 08       	st.w	r12[0x0],r8
}
80004a42:	5e fc       	retal	r12

80004a44 <pm_switch_to_osc0>:


void pm_switch_to_osc0(volatile avr32_pm_t *pm, unsigned int fosc0, unsigned int startup)
{
80004a44:	eb cd 40 c0 	pushm	r6-r7,lr
80004a48:	18 97       	mov	r7,r12
80004a4a:	14 96       	mov	r6,r10
  pm_enable_osc0_crystal(pm, fosc0);            // Enable the Osc0 in crystal mode
80004a4c:	f0 1f 00 06 	mcall	80004a64 <pm_switch_to_osc0+0x20>
  pm_enable_clk0(pm, startup);                  // Crystal startup time - This parameter is critical and depends on the characteristics of the crystal
80004a50:	0c 9b       	mov	r11,r6
80004a52:	0e 9c       	mov	r12,r7
80004a54:	f0 1f 00 05 	mcall	80004a68 <pm_switch_to_osc0+0x24>
  pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);  // Then switch main clock to Osc0
80004a58:	30 1b       	mov	r11,1
80004a5a:	0e 9c       	mov	r12,r7
80004a5c:	f0 1f 00 04 	mcall	80004a6c <pm_switch_to_osc0+0x28>
}
80004a60:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004a64:	80 00       	ld.sh	r0,r0[0x0]
80004a66:	48 d8       	lddpc	r8,80004a98 <rtc_set_value+0x20>
80004a68:	80 00       	ld.sh	r0,r0[0x0]
80004a6a:	49 30       	lddpc	r0,80004ab4 <rtc_enable+0x18>
80004a6c:	80 00       	ld.sh	r0,r0[0x0]
80004a6e:	4a 3a       	lddpc	r10,80004af8 <rtc_clear_interrupt+0xc>

80004a70 <rtc_is_busy>:
#include "rtc.h"


int rtc_is_busy(volatile avr32_rtc_t *rtc)
{
  return (rtc->ctrl & AVR32_RTC_CTRL_BUSY_MASK) != 0;
80004a70:	78 0c       	ld.w	r12,r12[0x0]
}
80004a72:	f9 dc c0 81 	bfextu	r12,r12,0x4,0x1
80004a76:	5e fc       	retal	r12

80004a78 <rtc_set_value>:
  return 1;
}


void rtc_set_value(volatile avr32_rtc_t *rtc, unsigned long val)
{
80004a78:	eb cd 40 c0 	pushm	r6-r7,lr
80004a7c:	18 97       	mov	r7,r12
80004a7e:	16 96       	mov	r6,r11
  // Wait until we can write into the VAL register
  while (rtc_is_busy(rtc));
80004a80:	0e 9c       	mov	r12,r7
80004a82:	f0 1f 00 06 	mcall	80004a98 <rtc_set_value+0x20>
80004a86:	cf d1       	brne	80004a80 <rtc_set_value+0x8>
  // Set the new val value
  rtc->val = val;
80004a88:	8f 16       	st.w	r7[0x4],r6
  // Wait until write is done
  while (rtc_is_busy(rtc));
80004a8a:	0e 9c       	mov	r12,r7
80004a8c:	f0 1f 00 03 	mcall	80004a98 <rtc_set_value+0x20>
80004a90:	cf d1       	brne	80004a8a <rtc_set_value+0x12>
}
80004a92:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004a96:	00 00       	add	r0,r0
80004a98:	80 00       	ld.sh	r0,r0[0x0]
80004a9a:	4a 70       	lddpc	r0,80004b34 <rtc_init+0x28>

80004a9c <rtc_enable>:
  while (rtc_is_busy(rtc));
}


void rtc_enable(volatile avr32_rtc_t *rtc)
{
80004a9c:	eb cd 40 80 	pushm	r7,lr
80004aa0:	18 97       	mov	r7,r12
  // Wait until the rtc CTRL register is up-to-date
  while (rtc_is_busy(rtc));
80004aa2:	0e 9c       	mov	r12,r7
80004aa4:	f0 1f 00 06 	mcall	80004abc <rtc_enable+0x20>
80004aa8:	cf d1       	brne	80004aa2 <rtc_enable+0x6>
  // Enable the RTC
  rtc->ctrl |= AVR32_RTC_CTRL_EN_MASK;
80004aaa:	6e 08       	ld.w	r8,r7[0x0]
80004aac:	a1 a8       	sbr	r8,0x0
80004aae:	8f 08       	st.w	r7[0x0],r8
  // Wait until write is done
  while (rtc_is_busy(rtc));
80004ab0:	0e 9c       	mov	r12,r7
80004ab2:	f0 1f 00 03 	mcall	80004abc <rtc_enable+0x20>
80004ab6:	cf d1       	brne	80004ab0 <rtc_enable+0x14>
}
80004ab8:	e3 cd 80 80 	ldm	sp++,r7,pc
80004abc:	80 00       	ld.sh	r0,r0[0x0]
80004abe:	4a 70       	lddpc	r0,80004b58 <rtc_init+0x4c>

80004ac0 <rtc_enable_interrupt>:
}


void rtc_enable_interrupt(volatile avr32_rtc_t *rtc)
{
  rtc->ier = AVR32_RTC_IER_TOPI_MASK;
80004ac0:	30 18       	mov	r8,1
80004ac2:	99 48       	st.w	r12[0x10],r8
}
80004ac4:	5e fc       	retal	r12
80004ac6:	d7 03       	nop

80004ac8 <rtc_set_top_value>:
  if (global_interrupt_enabled) cpu_irq_enable();
}


void rtc_set_top_value(volatile avr32_rtc_t *rtc, unsigned long top)
{
80004ac8:	eb cd 40 c0 	pushm	r6-r7,lr
80004acc:	18 97       	mov	r7,r12
80004ace:	16 96       	mov	r6,r11
  // Wait until we can write into the VAL register
  while (rtc_is_busy(rtc));
80004ad0:	0e 9c       	mov	r12,r7
80004ad2:	f0 1f 00 06 	mcall	80004ae8 <rtc_set_top_value+0x20>
80004ad6:	cf d1       	brne	80004ad0 <rtc_set_top_value+0x8>
  // Set the new val value
  rtc->top = top;
80004ad8:	8f 26       	st.w	r7[0x8],r6
  // Wait until write is done
  while (rtc_is_busy(rtc));
80004ada:	0e 9c       	mov	r12,r7
80004adc:	f0 1f 00 03 	mcall	80004ae8 <rtc_set_top_value+0x20>
80004ae0:	cf d1       	brne	80004ada <rtc_set_top_value+0x12>
}
80004ae2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004ae6:	00 00       	add	r0,r0
80004ae8:	80 00       	ld.sh	r0,r0[0x0]
80004aea:	4a 70       	lddpc	r0,80004b84 <rtc_init+0x78>

80004aec <rtc_clear_interrupt>:
}


void rtc_clear_interrupt(volatile avr32_rtc_t *rtc)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
80004aec:	e1 b8 00 00 	mfsr	r8,0x0

  if (global_interrupt_enabled) cpu_irq_disable();
80004af0:	e6 18 00 01 	andh	r8,0x1,COH
80004af4:	c0 71       	brne	80004b02 <rtc_clear_interrupt+0x16>
80004af6:	d3 03       	ssrf	0x10
  rtc->icr = AVR32_RTC_ICR_TOPI_MASK;
80004af8:	30 18       	mov	r8,1
80004afa:	99 88       	st.w	r12[0x20],r8
  rtc->isr;
80004afc:	78 78       	ld.w	r8,r12[0x1c]
  if (global_interrupt_enabled) cpu_irq_enable();
80004afe:	d5 03       	csrf	0x10
80004b00:	5e fc       	retal	r12
void rtc_clear_interrupt(volatile avr32_rtc_t *rtc)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  if (global_interrupt_enabled) cpu_irq_disable();
  rtc->icr = AVR32_RTC_ICR_TOPI_MASK;
80004b02:	30 18       	mov	r8,1
80004b04:	99 88       	st.w	r12[0x20],r8
  rtc->isr;
80004b06:	78 78       	ld.w	r8,r12[0x1c]
80004b08:	5e fc       	retal	r12
80004b0a:	d7 03       	nop

80004b0c <rtc_init>:
  return (rtc->ctrl & AVR32_RTC_CTRL_BUSY_MASK) != 0;
}


int rtc_init(volatile avr32_rtc_t *rtc, unsigned char osc_type, unsigned char psel)
{
80004b0c:	eb cd 40 e0 	pushm	r5-r7,lr
80004b10:	18 97       	mov	r7,r12
80004b12:	16 96       	mov	r6,r11
80004b14:	14 95       	mov	r5,r10
  // If exit, it means that the configuration has not been set correctly
  if (osc_type > (1 << AVR32_RTC_CTRL_CLK32_SIZE) - 1 ||
80004b16:	30 18       	mov	r8,1
80004b18:	f0 0b 18 00 	cp.b	r11,r8
80004b1c:	5f b9       	srhi	r9
80004b1e:	30 f8       	mov	r8,15
80004b20:	f0 0a 18 00 	cp.b	r10,r8
80004b24:	5f b8       	srhi	r8
80004b26:	f3 e8 10 08 	or	r8,r9,r8
80004b2a:	c0 30       	breq	80004b30 <rtc_init+0x24>
80004b2c:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
      psel > (1 << AVR32_RTC_CTRL_PSEL_SIZE) - 1)
    return 0;

  // If we use the 32-kHz oscillator, we have to enable it first
  if (osc_type == RTC_OSC_32KHZ)
80004b30:	30 18       	mov	r8,1
80004b32:	f0 0b 18 00 	cp.b	r11,r8
80004b36:	c0 a1       	brne	80004b4a <rtc_init+0x3e>
  {
    // Select the 32-kHz oscillator crystal
    pm_enable_osc32_crystal(&AVR32_PM);
80004b38:	fe 7c 0c 00 	mov	r12,-62464
80004b3c:	f0 1f 00 0f 	mcall	80004b78 <rtc_init+0x6c>
    // Enable the 32-kHz clock and wait until the osc32 clock is ready.
    pm_enable_clk32(&AVR32_PM, AVR32_PM_OSCCTRL32_STARTUP_0_RCOSC);
80004b40:	30 0b       	mov	r11,0
80004b42:	fe 7c 0c 00 	mov	r12,-62464
80004b46:	f0 1f 00 0e 	mcall	80004b7c <rtc_init+0x70>
  }

  // Wait until the rtc accepts writes to the CTRL register
  while (rtc_is_busy(rtc));
80004b4a:	0e 9c       	mov	r12,r7
80004b4c:	f0 1f 00 0d 	mcall	80004b80 <rtc_init+0x74>
80004b50:	cf d1       	brne	80004b4a <rtc_init+0x3e>

  // Set the new RTC configuration
  rtc->ctrl = osc_type << AVR32_RTC_CTRL_CLK32_OFFSET |
80004b52:	a3 76       	lsl	r6,0x3
80004b54:	b1 a6       	sbr	r6,0x10
80004b56:	ed e5 10 85 	or	r5,r6,r5<<0x8
80004b5a:	8f 05       	st.w	r7[0x0],r5
              psel << AVR32_RTC_CTRL_PSEL_OFFSET |
              AVR32_RTC_CTRL_CLKEN_MASK;

  // Wait until write is done
  while (rtc_is_busy(rtc));
80004b5c:	0e 9c       	mov	r12,r7
80004b5e:	f0 1f 00 09 	mcall	80004b80 <rtc_init+0x74>
80004b62:	cf d1       	brne	80004b5c <rtc_init+0x50>

  // Set the counter value to 0
  rtc_set_value(rtc, 0x00000000);
80004b64:	30 0b       	mov	r11,0
80004b66:	0e 9c       	mov	r12,r7
80004b68:	f0 1f 00 07 	mcall	80004b84 <rtc_init+0x78>
  // Set the top value to 0xFFFFFFFF
  rtc_set_top_value(rtc, 0xFFFFFFFF);
80004b6c:	3f fb       	mov	r11,-1
80004b6e:	0e 9c       	mov	r12,r7
80004b70:	f0 1f 00 06 	mcall	80004b88 <rtc_init+0x7c>
80004b74:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
80004b78:	80 00       	ld.sh	r0,r0[0x0]
80004b7a:	49 58       	lddpc	r8,80004bcc <spi_initMaster+0x20>
80004b7c:	80 00       	ld.sh	r0,r0[0x0]
80004b7e:	49 84       	lddpc	r4,80004bdc <spi_initMaster+0x30>
80004b80:	80 00       	ld.sh	r0,r0[0x0]
80004b82:	4a 70       	lddpc	r0,80004c1c <spi_write+0x6>
80004b84:	80 00       	ld.sh	r0,r0[0x0]
80004b86:	4a 78       	lddpc	r8,80004c20 <spi_write+0xa>
80004b88:	80 00       	ld.sh	r0,r0[0x0]
80004b8a:	4a c8       	lddpc	r8,80004c38 <spi_read+0x6>

80004b8c <getBaudDiv>:
xSemaphoreHandle xSPIMutex;
#endif

int16_t getBaudDiv(const uint32_t baudrate, uint32_t pb_hz)
{
	uint32_t baudDiv = div_ceil(pb_hz, baudrate);
80004b8c:	f8 c8 00 01 	sub	r8,r12,1
80004b90:	f0 0b 00 0b 	add	r11,r8,r11
80004b94:	f6 0c 0d 0a 	divu	r10,r11,r12
80004b98:	14 9c       	mov	r12,r10

	if (baudDiv <= 0 || baudDiv > 255) {
80004b9a:	f4 c8 00 01 	sub	r8,r10,1
80004b9e:	e0 48 00 fe 	cp.w	r8,254
80004ba2:	e0 88 00 03 	brls	80004ba8 <getBaudDiv+0x1c>
80004ba6:	5e fe       	retal	-1
		return -1;
	}

	return baudDiv;
80004ba8:	5c 8c       	casts.h	r12
}
80004baa:	5e fc       	retal	r12

80004bac <spi_initMaster>:
spi_status_t spi_initMaster(volatile avr32_spi_t *spi,
		const spi_options_t *options)
{
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (options->modfdis > 1) {
80004bac:	f7 39 00 0d 	ld.ub	r9,r11[13]
80004bb0:	30 18       	mov	r8,1
80004bb2:	f0 09 18 00 	cp.b	r9,r8
80004bb6:	e0 88 00 04 	brls	80004bbe <spi_initMaster+0x12>
80004bba:	30 2c       	mov	r12,2
80004bbc:	5e fc       	retal	r12
		return SPI_ERROR_ARGUMENT;
	}

	/* Reset. */
	spi->cr = AVR32_SPI_CR_SWRST_MASK;
80004bbe:	e0 68 00 80 	mov	r8,128
80004bc2:	99 08       	st.w	r12[0x0],r8

	/* Master Mode. */
	u_avr32_spi_mr.mr = spi->mr;
80004bc4:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.mstr = 1;
80004bc6:	30 19       	mov	r9,1
80004bc8:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_mr.MR.modfdis = options->modfdis;
80004bcc:	f7 39 00 0d 	ld.ub	r9,r11[13]
80004bd0:	f1 d9 d0 81 	bfins	r8,r9,0x4,0x1
	u_avr32_spi_mr.MR.llb = 0;
80004bd4:	30 09       	mov	r9,0
80004bd6:	f1 d9 d0 e1 	bfins	r8,r9,0x7,0x1
	u_avr32_spi_mr.MR.pcs = (1 << AVR32_SPI_MR_PCS_SIZE) - 1;
80004bda:	30 fa       	mov	r10,15
80004bdc:	f1 da d2 04 	bfins	r8,r10,0x10,0x4
	spi->mr = u_avr32_spi_mr.mr;
80004be0:	99 18       	st.w	r12[0x4],r8
80004be2:	5e f9       	retal	r9

80004be4 <spi_selectionMode>:

spi_status_t spi_selectionMode(volatile avr32_spi_t *spi,
		uint8_t variable_ps,
		uint8_t pcs_decode,
		uint8_t delay)
{
80004be4:	d4 01       	pushm	lr
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (variable_ps > 1 ||
80004be6:	30 18       	mov	r8,1
80004be8:	f0 0b 18 00 	cp.b	r11,r8
80004bec:	5f be       	srhi	lr
80004bee:	f0 0a 18 00 	cp.b	r10,r8
80004bf2:	5f b8       	srhi	r8
80004bf4:	fd e8 10 08 	or	r8,lr,r8
80004bf8:	c0 30       	breq	80004bfe <spi_selectionMode+0x1a>
80004bfa:	30 2c       	mov	r12,2
80004bfc:	d8 02       	popm	pc
			pcs_decode > 1) {
		return SPI_ERROR_ARGUMENT;
	}

	u_avr32_spi_mr.mr = spi->mr;
80004bfe:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.ps = variable_ps;
80004c00:	f1 db d0 21 	bfins	r8,r11,0x1,0x1
	u_avr32_spi_mr.MR.pcsdec = pcs_decode;
80004c04:	f1 da d0 41 	bfins	r8,r10,0x2,0x1
	u_avr32_spi_mr.MR.dlybcs = delay;
80004c08:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8
	spi->mr = u_avr32_spi_mr.mr;
80004c0c:	99 18       	st.w	r12[0x4],r8
80004c0e:	d8 0a       	popm	pc,r12=0

80004c10 <spi_enable>:
	return SPI_OK;
}

void spi_enable(volatile avr32_spi_t *spi)
{
	spi->cr = AVR32_SPI_CR_SPIEN_MASK;
80004c10:	30 18       	mov	r8,1
80004c12:	99 08       	st.w	r12[0x0],r8
}
80004c14:	5e fc       	retal	r12

80004c16 <spi_write>:
{
	return ((spi->sr & AVR32_SPI_SR_TDRE_MASK) != 0);
}

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
80004c16:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
80004c1a:	c0 58       	rjmp	80004c24 <spi_write+0xe>
		if (!timeout--) {
80004c1c:	58 08       	cp.w	r8,0
80004c1e:	c0 21       	brne	80004c22 <spi_write+0xc>
80004c20:	5e ff       	retal	1
80004c22:	20 18       	sub	r8,1

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
80004c24:	78 49       	ld.w	r9,r12[0x10]
80004c26:	e2 19 00 02 	andl	r9,0x2,COH
80004c2a:	cf 90       	breq	80004c1c <spi_write+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	spi->tdr = data << AVR32_SPI_TDR_TD_OFFSET;
80004c2c:	5c 7b       	castu.h	r11
80004c2e:	99 3b       	st.w	r12[0xc],r11
80004c30:	5e fd       	retal	0

80004c32 <spi_read>:
{
	return ((spi->sr & AVR32_SPI_SR_RDRF_MASK) != 0);
}

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
80004c32:	e0 68 3a 98 	mov	r8,15000
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
80004c36:	c0 58       	rjmp	80004c40 <spi_read+0xe>
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) !=
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) {
		if (!timeout--) {
80004c38:	58 08       	cp.w	r8,0
80004c3a:	c0 21       	brne	80004c3e <spi_read+0xc>
80004c3c:	5e ff       	retal	1
80004c3e:	20 18       	sub	r8,1

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
80004c40:	78 49       	ld.w	r9,r12[0x10]
80004c42:	e2 19 02 01 	andl	r9,0x201,COH
80004c46:	e0 49 02 01 	cp.w	r9,513
80004c4a:	cf 71       	brne	80004c38 <spi_read+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	*data = spi->rdr >> AVR32_SPI_RDR_RD_OFFSET;
80004c4c:	78 28       	ld.w	r8,r12[0x8]
80004c4e:	b6 08       	st.h	r11[0x0],r8
80004c50:	5e fd       	retal	0
80004c52:	d7 03       	nop

80004c54 <spi_setupChipReg>:
}

spi_status_t spi_setupChipReg(volatile avr32_spi_t *spi,
		const spi_options_t *options,
		uint32_t pb_hz)
{
80004c54:	eb cd 40 f8 	pushm	r3-r7,lr
80004c58:	18 95       	mov	r5,r12
80004c5a:	16 97       	mov	r7,r11
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
80004c5c:	f7 36 00 0c 	ld.ub	r6,r11[12]
80004c60:	30 38       	mov	r8,3
80004c62:	f0 06 18 00 	cp.b	r6,r8
80004c66:	e0 8b 00 5e 	brhi	80004d22 <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
80004c6a:	f7 34 00 0b 	ld.ub	r4,r11[11]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
80004c6e:	30 18       	mov	r8,1
80004c70:	f0 04 18 00 	cp.b	r4,r8
80004c74:	e0 8b 00 57 	brhi	80004d22 <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
80004c78:	f7 33 00 08 	ld.ub	r3,r11[8]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
80004c7c:	30 78       	mov	r8,7
80004c7e:	f0 03 18 00 	cp.b	r3,r8
80004c82:	e0 88 00 50 	brls	80004d22 <spi_setupChipReg+0xce>
80004c86:	31 08       	mov	r8,16
80004c88:	f0 03 18 00 	cp.b	r3,r8
80004c8c:	e0 8b 00 4b 	brhi	80004d22 <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
		return SPI_ERROR_ARGUMENT;
	}

	int baudDiv = getBaudDiv(options->baudrate, pb_hz);
80004c90:	14 9b       	mov	r11,r10
80004c92:	6e 1c       	ld.w	r12,r7[0x4]
80004c94:	f0 1f 00 26 	mcall	80004d2c <spi_setupChipReg+0xd8>

	if (baudDiv < 0) {
80004c98:	c4 55       	brlt	80004d22 <spi_setupChipReg+0xce>
		return SPI_ERROR_ARGUMENT;
	}

	/* Will use CSR0 offsets; these are the same for CSR0 to CSR3. */
	u_avr32_spi_csr.csr = 0;
80004c9a:	30 08       	mov	r8,0
	u_avr32_spi_csr.CSR.cpol   = options->spi_mode >> 1;
80004c9c:	ec 09 16 01 	lsr	r9,r6,0x1
80004ca0:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_csr.CSR.ncpha  = (options->spi_mode & 0x1) ^ 0x1;
80004ca4:	ec 16 00 01 	eorl	r6,0x1
80004ca8:	f1 d6 d0 21 	bfins	r8,r6,0x1,0x1
	u_avr32_spi_csr.CSR.csaat  = options->stay_act;
80004cac:	f1 d4 d0 61 	bfins	r8,r4,0x3,0x1
	u_avr32_spi_csr.CSR.bits   = options->bits - 8;
80004cb0:	20 83       	sub	r3,8
80004cb2:	f1 d3 d0 84 	bfins	r8,r3,0x4,0x4
	u_avr32_spi_csr.CSR.scbr   = baudDiv;
80004cb6:	f1 dc d1 08 	bfins	r8,r12,0x8,0x8
	u_avr32_spi_csr.CSR.dlybs  = options->spck_delay;
80004cba:	ef 39 00 09 	ld.ub	r9,r7[9]
80004cbe:	f1 d9 d2 08 	bfins	r8,r9,0x10,0x8
	u_avr32_spi_csr.CSR.dlybct = options->trans_delay;
80004cc2:	ef 39 00 0a 	ld.ub	r9,r7[10]
80004cc6:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8

	switch (options->reg) {
80004cca:	0f 89       	ld.ub	r9,r7[0x0]
80004ccc:	30 1a       	mov	r10,1
80004cce:	f4 09 18 00 	cp.b	r9,r10
80004cd2:	c0 d0       	breq	80004cec <spi_setupChipReg+0x98>
80004cd4:	c0 a3       	brcs	80004ce8 <spi_setupChipReg+0x94>
80004cd6:	30 2a       	mov	r10,2
80004cd8:	f4 09 18 00 	cp.b	r9,r10
80004cdc:	c0 a0       	breq	80004cf0 <spi_setupChipReg+0x9c>
80004cde:	30 3a       	mov	r10,3
80004ce0:	f4 09 18 00 	cp.b	r9,r10
80004ce4:	c1 f1       	brne	80004d22 <spi_setupChipReg+0xce>
80004ce6:	c0 78       	rjmp	80004cf4 <spi_setupChipReg+0xa0>
	case 0:
		spi->csr0 = u_avr32_spi_csr.csr;
80004ce8:	8b c8       	st.w	r5[0x30],r8
		break;
80004cea:	c0 68       	rjmp	80004cf6 <spi_setupChipReg+0xa2>

	case 1:
		spi->csr1 = u_avr32_spi_csr.csr;
80004cec:	8b d8       	st.w	r5[0x34],r8
		break;
80004cee:	c0 48       	rjmp	80004cf6 <spi_setupChipReg+0xa2>

	case 2:
		spi->csr2 = u_avr32_spi_csr.csr;
80004cf0:	8b e8       	st.w	r5[0x38],r8
		break;
80004cf2:	c0 28       	rjmp	80004cf6 <spi_setupChipReg+0xa2>

	case 3:
		spi->csr3 = u_avr32_spi_csr.csr;
80004cf4:	8b f8       	st.w	r5[0x3c],r8
	default:
		return SPI_ERROR_ARGUMENT;
	}

#ifdef FREERTOS_USED
	if (!xSPIMutex) {
80004cf6:	48 f8       	lddpc	r8,80004d30 <spi_setupChipReg+0xdc>
80004cf8:	70 08       	ld.w	r8,r8[0x0]
80004cfa:	58 08       	cp.w	r8,0
80004cfc:	c1 61       	brne	80004d28 <spi_setupChipReg+0xd4>
		/* Create the SPI mutex. */
		vSemaphoreCreateBinary(xSPIMutex);
80004cfe:	30 0b       	mov	r11,0
80004d00:	30 1c       	mov	r12,1
80004d02:	f0 1f 00 0d 	mcall	80004d34 <spi_setupChipReg+0xe0>
80004d06:	48 b8       	lddpc	r8,80004d30 <spi_setupChipReg+0xdc>
80004d08:	91 0c       	st.w	r8[0x0],r12
80004d0a:	58 0c       	cp.w	r12,0
80004d0c:	c0 a0       	breq	80004d20 <spi_setupChipReg+0xcc>
80004d0e:	30 09       	mov	r9,0
80004d10:	12 9a       	mov	r10,r9
80004d12:	12 9b       	mov	r11,r9
80004d14:	f0 1f 00 09 	mcall	80004d38 <spi_setupChipReg+0xe4>
		if (!xSPIMutex) {
80004d18:	48 68       	lddpc	r8,80004d30 <spi_setupChipReg+0xdc>
80004d1a:	70 08       	ld.w	r8,r8[0x0]
80004d1c:	58 08       	cp.w	r8,0
80004d1e:	c0 51       	brne	80004d28 <spi_setupChipReg+0xd4>
80004d20:	c0 08       	rjmp	80004d20 <spi_setupChipReg+0xcc>
80004d22:	30 2c       	mov	r12,2
80004d24:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80004d28:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
80004d2c:	80 00       	ld.sh	r0,r0[0x0]
80004d2e:	4b 8c       	lddpc	r12,80004e0c <usart_set_async_baudrate+0x18>
80004d30:	00 00       	add	r0,r0
80004d32:	1f c8       	ld.ub	r8,pc[0x4]
80004d34:	80 00       	ld.sh	r0,r0[0x0]
80004d36:	57 d8       	stdsp	sp[0x1f4],r8
80004d38:	80 00       	ld.sh	r0,r0[0x0]
80004d3a:	56 80       	stdsp	sp[0x1a0],r0

80004d3c <spi_unselectChip>:

	return SPI_OK;
}

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
80004d3c:	d4 01       	pushm	lr
80004d3e:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
80004d42:	c0 58       	rjmp	80004d4c <spi_unselectChip+0x10>
		if (!timeout--) {
80004d44:	58 08       	cp.w	r8,0
80004d46:	c0 21       	brne	80004d4a <spi_unselectChip+0xe>
80004d48:	da 0a       	popm	pc,r12=1
80004d4a:	20 18       	sub	r8,1

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
80004d4c:	78 49       	ld.w	r9,r12[0x10]
80004d4e:	e2 19 02 00 	andl	r9,0x200,COH
80004d52:	cf 90       	breq	80004d44 <spi_unselectChip+0x8>
			return SPI_ERROR_TIMEOUT;
		}
	}

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
80004d54:	78 18       	ld.w	r8,r12[0x4]
80004d56:	ea 18 00 0f 	orh	r8,0xf
80004d5a:	99 18       	st.w	r12[0x4],r8

	/* Last transfer, so de-assert the current NPCS if CSAAT is set. */
	spi->cr = AVR32_SPI_CR_LASTXFER_MASK;
80004d5c:	fc 18 01 00 	movh	r8,0x100
80004d60:	99 08       	st.w	r12[0x0],r8

#ifdef FREERTOS_USED
	xSemaphoreGive(xSPIMutex);
80004d62:	30 09       	mov	r9,0
80004d64:	12 9a       	mov	r10,r9
80004d66:	12 9b       	mov	r11,r9
80004d68:	48 38       	lddpc	r8,80004d74 <spi_unselectChip+0x38>
80004d6a:	70 0c       	ld.w	r12,r8[0x0]
80004d6c:	f0 1f 00 03 	mcall	80004d78 <spi_unselectChip+0x3c>
80004d70:	d8 0a       	popm	pc,r12=0
80004d72:	00 00       	add	r0,r0
80004d74:	00 00       	add	r0,r0
80004d76:	1f c8       	ld.ub	r8,pc[0x4]
80004d78:	80 00       	ld.sh	r0,r0[0x0]
80004d7a:	56 80       	stdsp	sp[0x1a0],r0

80004d7c <spi_selectChip>:

	return SPI_OK;
}

spi_status_t spi_selectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
80004d7c:	eb cd 40 f8 	pushm	r3-r7,lr
80004d80:	18 94       	mov	r4,r12
80004d82:	16 93       	mov	r3,r11
#ifdef FREERTOS_USED
	while (pdFALSE == xSemaphoreTake(xSPIMutex, 20)) {
80004d84:	49 a6       	lddpc	r6,80004dec <spi_selectChip+0x70>
80004d86:	30 07       	mov	r7,0
80004d88:	31 45       	mov	r5,20
80004d8a:	0e 99       	mov	r9,r7
80004d8c:	0a 9a       	mov	r10,r5
80004d8e:	0e 9b       	mov	r11,r7
80004d90:	6c 0c       	ld.w	r12,r6[0x0]
80004d92:	f0 1f 00 18 	mcall	80004df0 <spi_selectChip+0x74>
80004d96:	cf a0       	breq	80004d8a <spi_selectChip+0xe>
	}
#endif

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
80004d98:	68 18       	ld.w	r8,r4[0x4]
80004d9a:	ea 18 00 0f 	orh	r8,0xf
80004d9e:	89 18       	st.w	r4[0x4],r8

	if (spi->mr & AVR32_SPI_MR_PCSDEC_MASK) {
80004da0:	68 18       	ld.w	r8,r4[0x4]
80004da2:	e2 18 00 04 	andl	r8,0x4,COH
80004da6:	c1 10       	breq	80004dc8 <spi_selectChip+0x4c>
		/* The signal is decoded; allow up to 15 chips. */
		if (chip > 14) {
80004da8:	30 e8       	mov	r8,14
80004daa:	f0 03 18 00 	cp.b	r3,r8
80004dae:	e0 8b 00 1c 	brhi	80004de6 <spi_selectChip+0x6a>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~AVR32_SPI_MR_PCS_MASK |
80004db2:	68 19       	ld.w	r9,r4[0x4]
80004db4:	e6 08 15 10 	lsl	r8,r3,0x10
80004db8:	ea 18 ff f0 	orh	r8,0xfff0
80004dbc:	e8 18 ff ff 	orl	r8,0xffff
80004dc0:	12 68       	and	r8,r9
80004dc2:	89 18       	st.w	r4[0x4],r8
80004dc4:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
				(chip << AVR32_SPI_MR_PCS_OFFSET);
	} else {
		if (chip > 3) {
80004dc8:	30 38       	mov	r8,3
80004dca:	f0 03 18 00 	cp.b	r3,r8
80004dce:	e0 8b 00 0c 	brhi	80004de6 <spi_selectChip+0x6a>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~(1 << (AVR32_SPI_MR_PCS_OFFSET + chip));
80004dd2:	68 19       	ld.w	r9,r4[0x4]
80004dd4:	2f 03       	sub	r3,-16
80004dd6:	30 18       	mov	r8,1
80004dd8:	f0 03 09 48 	lsl	r8,r8,r3
80004ddc:	5c d8       	com	r8
80004dde:	12 68       	and	r8,r9
80004de0:	89 18       	st.w	r4[0x4],r8
80004de2:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
80004de6:	30 2c       	mov	r12,2
	}

	return SPI_OK;
}
80004de8:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80004dec:	00 00       	add	r0,r0
80004dee:	1f c8       	ld.ub	r8,pc[0x4]
80004df0:	80 00       	ld.sh	r0,r0[0x0]
80004df2:	54 c4       	stdsp	sp[0x130],r4

80004df4 <usart_set_async_baudrate>:
 *
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
80004df4:	d4 01       	pushm	lr
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
80004df6:	f6 08 15 04 	lsl	r8,r11,0x4
80004dfa:	14 38       	cp.w	r8,r10
80004dfc:	f9 b8 08 10 	movls	r8,16
80004e00:	f9 b8 0b 08 	movhi	r8,8
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
80004e04:	f0 0b 02 4b 	mul	r11,r8,r11
80004e08:	f6 09 16 01 	lsr	r9,r11,0x1
80004e0c:	f2 0a 00 3a 	add	r10,r9,r10<<0x3
80004e10:	f4 0b 0d 0a 	divu	r10,r10,r11
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
80004e14:	f4 09 16 03 	lsr	r9,r10,0x3
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
80004e18:	f2 cb 00 01 	sub	r11,r9,1
80004e1c:	e0 4b ff fe 	cp.w	r11,65534
80004e20:	e0 88 00 03 	brls	80004e26 <usart_set_async_baudrate+0x32>
80004e24:	da 0a       	popm	pc,r12=1
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
80004e26:	78 1b       	ld.w	r11,r12[0x4]
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
80004e28:	e8 6e 00 00 	mov	lr,524288
80004e2c:	59 08       	cp.w	r8,16
80004e2e:	fc 08 17 10 	movne	r8,lr
80004e32:	f9 b8 00 00 	moveq	r8,0
80004e36:	e4 1b ff f7 	andh	r11,0xfff7
80004e3a:	e0 1b fe cf 	andl	r11,0xfecf
80004e3e:	16 48       	or	r8,r11
80004e40:	99 18       	st.w	r12[0x4],r8
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
80004e42:	f5 da c0 03 	bfextu	r10,r10,0x0,0x3
80004e46:	f3 ea 11 09 	or	r9,r9,r10<<0x10
80004e4a:	99 89       	st.w	r12[0x20],r9
80004e4c:	d8 0a       	popm	pc,r12=0

80004e4e <usart_write_char>:
 *
 * \return \c 1 if the USART Transmit Holding Register is free, otherwise \c 0.
 */
__always_inline static int usart_tx_ready(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_TXRDY_MASK) != 0;
80004e4e:	78 58       	ld.w	r8,r12[0x14]
}


int usart_write_char(volatile avr32_usart_t *usart, int c)
{
  if (usart_tx_ready(usart))
80004e50:	e2 18 00 02 	andl	r8,0x2,COH
80004e54:	c0 31       	brne	80004e5a <usart_write_char+0xc>
80004e56:	30 2c       	mov	r12,2
80004e58:	5e fc       	retal	r12
  {
    usart->thr = (c << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
80004e5a:	f7 db c0 09 	bfextu	r11,r11,0x0,0x9
80004e5e:	99 7b       	st.w	r12[0x1c],r11
80004e60:	5e fd       	retal	0
80004e62:	d7 03       	nop

80004e64 <usart_putchar>:
    return USART_TX_BUSY;
}


int usart_putchar(volatile avr32_usart_t *usart, int c)
{
80004e64:	eb cd 40 e0 	pushm	r5-r7,lr
80004e68:	18 96       	mov	r6,r12
80004e6a:	16 95       	mov	r5,r11
80004e6c:	e0 67 27 0f 	mov	r7,9999
80004e70:	c0 68       	rjmp	80004e7c <usart_putchar+0x18>
  int timeout = USART_DEFAULT_TIMEOUT;

  do
  {
    if (!timeout--) return USART_FAILURE;
80004e72:	58 07       	cp.w	r7,0
80004e74:	c0 31       	brne	80004e7a <usart_putchar+0x16>
80004e76:	e3 cf c0 e0 	ldm	sp++,r5-r7,pc,r12=-1
80004e7a:	20 17       	sub	r7,1
  } while (usart_write_char(usart, c) != USART_SUCCESS);
80004e7c:	0a 9b       	mov	r11,r5
80004e7e:	0c 9c       	mov	r12,r6
80004e80:	f0 1f 00 03 	mcall	80004e8c <usart_putchar+0x28>
80004e84:	cf 71       	brne	80004e72 <usart_putchar+0xe>

  return USART_SUCCESS;
}
80004e86:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80004e8a:	00 00       	add	r0,r0
80004e8c:	80 00       	ld.sh	r0,r0[0x0]
80004e8e:	4e 4e       	lddpc	lr,8000501c <idata_load_loop+0x6>

80004e90 <usart_read_char>:

int usart_read_char(volatile avr32_usart_t *usart, int *c)
{
  // Check for errors: frame, parity and overrun. In RS485 mode, a parity error
  // would mean that an address char has been received.
  if (usart->csr & (AVR32_USART_CSR_OVRE_MASK |
80004e90:	78 58       	ld.w	r8,r12[0x14]
80004e92:	e2 18 00 e0 	andl	r8,0xe0,COH
80004e96:	c0 30       	breq	80004e9c <usart_read_char+0xc>
80004e98:	30 4c       	mov	r12,4
80004e9a:	5e fc       	retal	r12
 *
 * \return \c 1 if the USART Receive Holding Register is full, otherwise \c 0.
 */
__always_inline static int usart_test_hit(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_RXRDY_MASK) != 0;
80004e9c:	78 58       	ld.w	r8,r12[0x14]
                    AVR32_USART_CSR_FRAME_MASK |
                    AVR32_USART_CSR_PARE_MASK))
    return USART_RX_ERROR;

  // No error; if we really did receive a char, read it and return SUCCESS.
  if (usart_test_hit(usart))
80004e9e:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80004ea2:	c0 31       	brne	80004ea8 <usart_read_char+0x18>
80004ea4:	30 3c       	mov	r12,3
80004ea6:	5e fc       	retal	r12
  {
    *c = (usart->rhr & AVR32_USART_RHR_RXCHR_MASK) >> AVR32_USART_RHR_RXCHR_OFFSET;
80004ea8:	78 68       	ld.w	r8,r12[0x18]
80004eaa:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
80004eae:	97 08       	st.w	r11[0x0],r8
80004eb0:	5e fd       	retal	0
80004eb2:	d7 03       	nop

80004eb4 <usart_getchar>:
    return USART_RX_EMPTY;
}


int usart_getchar(volatile avr32_usart_t *usart)
{
80004eb4:	eb cd 40 c0 	pushm	r6-r7,lr
80004eb8:	20 1d       	sub	sp,4
80004eba:	18 96       	mov	r6,r12
  int c, ret;

  while ((ret = usart_read_char(usart, &c)) == USART_RX_EMPTY);
80004ebc:	1a 97       	mov	r7,sp
80004ebe:	1a 9b       	mov	r11,sp
80004ec0:	0c 9c       	mov	r12,r6
80004ec2:	f0 1f 00 07 	mcall	80004edc <usart_getchar+0x28>
80004ec6:	58 3c       	cp.w	r12,3
80004ec8:	cf b0       	breq	80004ebe <usart_getchar+0xa>

  if (ret == USART_RX_ERROR)
80004eca:	58 4c       	cp.w	r12,4
80004ecc:	f9 bc 00 ff 	moveq	r12,-1
    return USART_FAILURE;

  return c;
80004ed0:	fb fc 10 00 	ld.wne	r12,sp[0x0]
}
80004ed4:	2f fd       	sub	sp,-4
80004ed6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004eda:	00 00       	add	r0,r0
80004edc:	80 00       	ld.sh	r0,r0[0x0]
80004ede:	4e 90       	lddpc	r0,80005080 <vListInsert+0xe>

80004ee0 <usart_write_line>:


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
80004ee0:	eb cd 40 c0 	pushm	r6-r7,lr
80004ee4:	18 96       	mov	r6,r12
80004ee6:	16 97       	mov	r7,r11
  while (*string != '\0')
80004ee8:	17 8b       	ld.ub	r11,r11[0x0]
80004eea:	58 0b       	cp.w	r11,0
80004eec:	c0 80       	breq	80004efc <usart_write_line+0x1c>
    usart_putchar(usart, *string++);
80004eee:	2f f7       	sub	r7,-1
80004ef0:	0c 9c       	mov	r12,r6
80004ef2:	f0 1f 00 04 	mcall	80004f00 <usart_write_line+0x20>
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
80004ef6:	0f 8b       	ld.ub	r11,r7[0x0]
80004ef8:	58 0b       	cp.w	r11,0
80004efa:	cf a1       	brne	80004eee <usart_write_line+0xe>
80004efc:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004f00:	80 00       	ld.sh	r0,r0[0x0]
80004f02:	4e 64       	lddpc	r4,80005098 <vListInsert+0x26>

80004f04 <usart_reset>:
//! @{


void usart_reset(volatile avr32_usart_t *usart)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
80004f04:	e1 b8 00 00 	mfsr	r8,0x0

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
80004f08:	e6 18 00 01 	andh	r8,0x1,COH
80004f0c:	c0 71       	brne	80004f1a <usart_reset+0x16>
80004f0e:	d3 03       	ssrf	0x10
  usart->idr = 0xFFFFFFFF;
80004f10:	3f f8       	mov	r8,-1
80004f12:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80004f14:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();
80004f16:	d5 03       	csrf	0x10
80004f18:	c0 48       	rjmp	80004f20 <usart_reset+0x1c>
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
  usart->idr = 0xFFFFFFFF;
80004f1a:	3f f8       	mov	r8,-1
80004f1c:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80004f1e:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();

  // Reset mode and other registers that could cause unpredictable behavior after reset.
  usart->mr = 0;
80004f20:	30 08       	mov	r8,0
80004f22:	99 18       	st.w	r12[0x4],r8
  usart->rtor = 0;
80004f24:	99 98       	st.w	r12[0x24],r8
  usart->ttgr = 0;
80004f26:	99 a8       	st.w	r12[0x28],r8

  // Shutdown TX and RX (will be re-enabled when setup has successfully completed),
  // reset status bits and turn off DTR and RTS.
  usart->cr = AVR32_USART_CR_RSTRX_MASK   |
80004f28:	ea 68 61 0c 	mov	r8,680204
80004f2c:	99 08       	st.w	r12[0x0],r8
#ifndef AVR32_USART_440_H_INCLUDED
// Note: Modem Signal Management DTR-DSR-DCD-RI are not included in USART rev.440.
              AVR32_USART_CR_DTRDIS_MASK  |
#endif
              AVR32_USART_CR_RTSDIS_MASK;
}
80004f2e:	5e fc       	retal	r12

80004f30 <usart_init_rs232>:


int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
{
80004f30:	eb cd 40 e0 	pushm	r5-r7,lr
80004f34:	18 96       	mov	r6,r12
80004f36:	16 97       	mov	r7,r11
80004f38:	14 95       	mov	r5,r10
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);
80004f3a:	f0 1f 00 2f 	mcall	80004ff4 <usart_init_rs232+0xc4>

  // Check input values.
  if (!opt || // Null pointer.
80004f3e:	58 07       	cp.w	r7,0
80004f40:	c5 80       	breq	80004ff0 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
80004f42:	0f c8       	ld.ub	r8,r7[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80004f44:	30 49       	mov	r9,4
80004f46:	f2 08 18 00 	cp.b	r8,r9
80004f4a:	e0 88 00 53 	brls	80004ff0 <usart_init_rs232+0xc0>
80004f4e:	30 99       	mov	r9,9
80004f50:	f2 08 18 00 	cp.b	r8,r9
80004f54:	e0 8b 00 4e 	brhi	80004ff0 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
80004f58:	0f d9       	ld.ub	r9,r7[0x5]
80004f5a:	30 78       	mov	r8,7
80004f5c:	f0 09 18 00 	cp.b	r9,r8
80004f60:	e0 8b 00 48 	brhi	80004ff0 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
80004f64:	8e 39       	ld.sh	r9,r7[0x6]
80004f66:	e0 68 01 01 	mov	r8,257
80004f6a:	f0 09 19 00 	cp.h	r9,r8
80004f6e:	e0 8b 00 41 	brhi	80004ff0 <usart_init_rs232+0xc0>
      opt->channelmode > 3 ||
80004f72:	ef 39 00 08 	ld.ub	r9,r7[8]
80004f76:	30 38       	mov	r8,3
80004f78:	f0 09 18 00 	cp.b	r9,r8
80004f7c:	e0 8b 00 3a 	brhi	80004ff0 <usart_init_rs232+0xc0>
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
80004f80:	0a 9a       	mov	r10,r5
80004f82:	6e 0b       	ld.w	r11,r7[0x0]
80004f84:	0c 9c       	mov	r12,r6
80004f86:	f0 1f 00 1d 	mcall	80004ff8 <usart_init_rs232+0xc8>
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80004f8a:	58 1c       	cp.w	r12,1
80004f8c:	c3 20       	breq	80004ff0 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
    return USART_INVALID_INPUT;

  if (opt->charlength == 9)
80004f8e:	0f c8       	ld.ub	r8,r7[0x4]
80004f90:	30 99       	mov	r9,9
80004f92:	f2 08 18 00 	cp.b	r8,r9
80004f96:	c0 51       	brne	80004fa0 <usart_init_rs232+0x70>
  {
    // Character length set to 9 bits. MODE9 dominates CHRL.
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
80004f98:	6c 18       	ld.w	r8,r6[0x4]
80004f9a:	b1 b8       	sbr	r8,0x11
80004f9c:	8d 18       	st.w	r6[0x4],r8
80004f9e:	c0 68       	rjmp	80004faa <usart_init_rs232+0x7a>
  }
  else
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
80004fa0:	6c 19       	ld.w	r9,r6[0x4]
80004fa2:	20 58       	sub	r8,5
80004fa4:	f3 e8 10 68 	or	r8,r9,r8<<0x6
80004fa8:	8d 18       	st.w	r6[0x4],r8
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
80004faa:	6c 19       	ld.w	r9,r6[0x4]
80004fac:	ef 3a 00 08 	ld.ub	r10,r7[8]
80004fb0:	0f d8       	ld.ub	r8,r7[0x5]
80004fb2:	a9 78       	lsl	r8,0x9
80004fb4:	f1 ea 10 e8 	or	r8,r8,r10<<0xe
80004fb8:	12 48       	or	r8,r9
80004fba:	8d 18       	st.w	r6[0x4],r8
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;

  if (opt->stopbits > USART_2_STOPBITS)
80004fbc:	8e 38       	ld.sh	r8,r7[0x6]
80004fbe:	30 29       	mov	r9,2
80004fc0:	f2 08 19 00 	cp.h	r8,r9
80004fc4:	e0 88 00 09 	brls	80004fd6 <usart_init_rs232+0xa6>
  {
    // Set two stop bits
    usart->mr |= AVR32_USART_MR_NBSTOP_2 << AVR32_USART_MR_NBSTOP_OFFSET;
80004fc8:	6c 18       	ld.w	r8,r6[0x4]
80004fca:	ad b8       	sbr	r8,0xd
80004fcc:	8d 18       	st.w	r6[0x4],r8
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
80004fce:	8e b8       	ld.uh	r8,r7[0x6]
80004fd0:	20 28       	sub	r8,2
80004fd2:	8d a8       	st.w	r6[0x28],r8
80004fd4:	c0 68       	rjmp	80004fe0 <usart_init_rs232+0xb0>
  }
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;
80004fd6:	6c 19       	ld.w	r9,r6[0x4]
80004fd8:	5c 78       	castu.h	r8
80004fda:	f3 e8 10 c8 	or	r8,r9,r8<<0xc
80004fde:	8d 18       	st.w	r6[0x4],r8

  // Set normal mode.
  usart->mr = (usart->mr & ~AVR32_USART_MR_MODE_MASK) |
80004fe0:	6c 18       	ld.w	r8,r6[0x4]
80004fe2:	e0 18 ff f0 	andl	r8,0xfff0
80004fe6:	8d 18       	st.w	r6[0x4],r8
              AVR32_USART_MR_MODE_NORMAL << AVR32_USART_MR_MODE_OFFSET;

  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
80004fe8:	35 08       	mov	r8,80
80004fea:	8d 08       	st.w	r6[0x0],r8
80004fec:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
80004ff0:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
80004ff4:	80 00       	ld.sh	r0,r0[0x0]
80004ff6:	4f 04       	lddpc	r4,800051b4 <xPortStartScheduler+0x44>
80004ff8:	80 00       	ld.sh	r0,r0[0x0]
80004ffa:	4d f4       	lddpc	r4,80005174 <xPortStartScheduler+0x4>

80004ffc <_stext>:

  .global _stext
  .type _stext, @function
_stext:
  // Set initial stack pointer.
  lda.w   sp, _estack
80004ffc:	e0 7d 80 00 	mov	sp,98304

  // Set up EVBA so interrupts can be enabled.
  lda.w   r0, _evba
  mtsr    AVR32_EVBA, r0
80005000:	fe c0 90 00 	sub	r0,pc,-28672

  // Enable the exception processing.
  csrf    AVR32_SR_EM_OFFSET
80005004:	e3 b0 00 01 	mtsr	0x4,r0

  // Load initialized data having a global lifetime from the data LMA.
  lda.w   r0, _data
  lda.w   r1, _edata
80005008:	d5 53       	csrf	0x15
  cp      r0, r1
8000500a:	30 40       	mov	r0,4
  brhs    idata_load_loop_end
8000500c:	e0 61 0a 28 	mov	r1,2600
  lda.w   r2, _data_lma
idata_load_loop:
  ld.d    r4, r2++
80005010:	02 30       	cp.w	r0,r1
  st.d    r0++, r4
80005012:	c0 62       	brcc	8000501e <idata_load_loop_end>
  cp      r0, r1
80005014:	48 92       	lddpc	r2,80005038 <udata_clear_loop_end+0x4>

80005016 <idata_load_loop>:
  brlo    idata_load_loop
80005016:	a5 05       	ld.d	r4,r2++
idata_load_loop_end:

  // Clear uninitialized data having a global lifetime in the blank static storage section.
  lda.w   r0, __bss_start
80005018:	a1 24       	st.d	r0++,r4
  lda.w   r1, _end
8000501a:	02 30       	cp.w	r0,r1
  cp      r0, r1
8000501c:	cf d3       	brcs	80005016 <idata_load_loop>

8000501e <idata_load_loop_end>:
  brhs    udata_clear_loop_end
8000501e:	e0 60 0a 28 	mov	r0,2600
  mov     r2, 0
  mov     r3, 0
80005022:	e0 61 1f d8 	mov	r1,8152
udata_clear_loop:
  st.d    r0++, r2
  cp      r0, r1
80005026:	02 30       	cp.w	r0,r1
  brlo    udata_clear_loop
80005028:	c0 62       	brcc	80005034 <udata_clear_loop_end>
  // Safety: Set the default "return" @ to the exit routine address.
  lda.w   lr, exit
#endif

  // Start the show.
  lda.w   pc, main
8000502a:	30 02       	mov	r2,0
8000502c:	30 03       	mov	r3,0

8000502e <udata_clear_loop>:
8000502e:	a1 22       	st.d	r0++,r2
80005030:	02 30       	cp.w	r0,r1
80005032:	cf e3       	brcs	8000502e <udata_clear_loop>

80005034 <udata_clear_loop_end>:
80005034:	fe cf eb 48 	sub	pc,pc,-5304
80005038:	80 00       	ld.sh	r0,r0[0x0]
8000503a:	d4 60       	acall	0x46

8000503c <vListInitialise>:
void vListInitialise( xList *pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
8000503c:	f8 c8 ff f8 	sub	r8,r12,-8
80005040:	99 18       	st.w	r12[0x4],r8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
80005042:	3f f9       	mov	r9,-1
80005044:	99 29       	st.w	r12[0x8],r9

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
80005046:	99 38       	st.w	r12[0xc],r8
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
80005048:	99 48       	st.w	r12[0x10],r8

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
8000504a:	30 08       	mov	r8,0
8000504c:	99 08       	st.w	r12[0x0],r8
}
8000504e:	5e fc       	retal	r12

80005050 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
80005050:	30 08       	mov	r8,0
80005052:	99 48       	st.w	r12[0x10],r8
}
80005054:	5e fc       	retal	r12

80005056 <vListInsertEnd>:

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
80005056:	78 18       	ld.w	r8,r12[0x4]

	pxNewListItem->pxNext = pxIndex->pxNext;
80005058:	70 19       	ld.w	r9,r8[0x4]
8000505a:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxPrevious = pxList->pxIndex;
8000505c:	78 19       	ld.w	r9,r12[0x4]
8000505e:	97 29       	st.w	r11[0x8],r9
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80005060:	70 19       	ld.w	r9,r8[0x4]
80005062:	93 2b       	st.w	r9[0x8],r11
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
80005064:	91 1b       	st.w	r8[0x4],r11
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
80005066:	99 1b       	st.w	r12[0x4],r11

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80005068:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
8000506a:	78 08       	ld.w	r8,r12[0x0]
8000506c:	2f f8       	sub	r8,-1
8000506e:	99 08       	st.w	r12[0x0],r8
}
80005070:	5e fc       	retal	r12

80005072 <vListInsert>:
{
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
80005072:	76 0a       	ld.w	r10,r11[0x0]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
80005074:	5b fa       	cp.w	r10,-1
80005076:	c0 31       	brne	8000507c <vListInsert+0xa>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
80005078:	78 48       	ld.w	r8,r12[0x10]
8000507a:	c0 c8       	rjmp	80005092 <vListInsert+0x20>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
8000507c:	f8 c8 ff f8 	sub	r8,r12,-8
80005080:	70 19       	ld.w	r9,r8[0x4]
80005082:	72 09       	ld.w	r9,r9[0x0]
80005084:	12 3a       	cp.w	r10,r9
80005086:	c0 63       	brcs	80005092 <vListInsert+0x20>
80005088:	70 18       	ld.w	r8,r8[0x4]
8000508a:	70 19       	ld.w	r9,r8[0x4]
8000508c:	72 09       	ld.w	r9,r9[0x0]
8000508e:	12 3a       	cp.w	r10,r9
80005090:	cf c2       	brcc	80005088 <vListInsert+0x16>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
80005092:	70 19       	ld.w	r9,r8[0x4]
80005094:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80005096:	93 2b       	st.w	r9[0x8],r11
	pxNewListItem->pxPrevious = pxIterator;
80005098:	97 28       	st.w	r11[0x8],r8
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
8000509a:	91 1b       	st.w	r8[0x4],r11

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
8000509c:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
8000509e:	78 08       	ld.w	r8,r12[0x0]
800050a0:	2f f8       	sub	r8,-1
800050a2:	99 08       	st.w	r12[0x0],r8
}
800050a4:	5e fc       	retal	r12

800050a6 <vListRemove>:

void vListRemove( xListItem *pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
800050a6:	78 18       	ld.w	r8,r12[0x4]
800050a8:	78 29       	ld.w	r9,r12[0x8]
800050aa:	91 29       	st.w	r8[0x8],r9
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
800050ac:	78 28       	ld.w	r8,r12[0x8]
800050ae:	78 19       	ld.w	r9,r12[0x4]
800050b0:	91 19       	st.w	r8[0x4],r9

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
800050b2:	78 48       	ld.w	r8,r12[0x10]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
800050b4:	70 19       	ld.w	r9,r8[0x4]
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
800050b6:	18 39       	cp.w	r9,r12
800050b8:	f9 f9 00 02 	ld.weq	r9,r12[0x8]
800050bc:	f1 f9 0a 01 	st.weq	r8[0x4],r9
	}

	pxItemToRemove->pvContainer = NULL;
800050c0:	30 09       	mov	r9,0
800050c2:	99 49       	st.w	r12[0x10],r9
	( pxList->uxNumberOfItems )--;
800050c4:	70 09       	ld.w	r9,r8[0x0]
800050c6:	20 19       	sub	r9,1
800050c8:	91 09       	st.w	r8[0x0],r9
}
800050ca:	5e fc       	retal	r12

800050cc <pxPortInitialiseStack>:
	/* Setup the initial stack of the task.  The stack is set exactly as
	expected by the portRESTORE_CONTEXT() macro. */

	/* When the task starts, it will expect to find the function parameter in R12. */
	pxTopOfStack--;
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x08080808;					/* R8 */
800050cc:	e0 68 08 08 	mov	r8,2056
800050d0:	ea 18 08 08 	orh	r8,0x808
800050d4:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x09090909;					/* R9 */
800050d6:	e0 68 09 09 	mov	r8,2313
800050da:	ea 18 09 09 	orh	r8,0x909
800050de:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0A0A0A0A;					/* R10 */
800050e0:	e0 68 0a 0a 	mov	r8,2570
800050e4:	ea 18 0a 0a 	orh	r8,0xa0a
800050e8:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0B0B0B0B;					/* R11 */
800050ea:	e0 68 0b 0b 	mov	r8,2827
800050ee:	ea 18 0b 0b 	orh	r8,0xb0b
800050f2:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pvParameters;					/* R12 */
800050f4:	18 da       	st.w	--r12,r10
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xDEADBEEF;					/* R14/LR */
800050f6:	e0 68 be ef 	mov	r8,48879
800050fa:	ea 18 de ad 	orh	r8,0xdead
800050fe:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pxCode + portINSTRUCTION_SIZE; /* R15/PC */
80005100:	18 db       	st.w	--r12,r11
	*pxTopOfStack-- = ( portSTACK_TYPE ) portINITIAL_SR;				/* SR */
80005102:	fc 18 00 40 	movh	r8,0x40
80005106:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xFF0000FF;					/* R0 */
80005108:	e0 68 00 ff 	mov	r8,255
8000510c:	ea 18 ff 00 	orh	r8,0xff00
80005110:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x01010101;					/* R1 */
80005112:	e0 68 01 01 	mov	r8,257
80005116:	ea 18 01 01 	orh	r8,0x101
8000511a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x02020202;					/* R2 */
8000511c:	e0 68 02 02 	mov	r8,514
80005120:	ea 18 02 02 	orh	r8,0x202
80005124:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x03030303;					/* R3 */
80005126:	e0 68 03 03 	mov	r8,771
8000512a:	ea 18 03 03 	orh	r8,0x303
8000512e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x04040404;					/* R4 */
80005130:	e0 68 04 04 	mov	r8,1028
80005134:	ea 18 04 04 	orh	r8,0x404
80005138:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x05050505;					/* R5 */
8000513a:	e0 68 05 05 	mov	r8,1285
8000513e:	ea 18 05 05 	orh	r8,0x505
80005142:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x06060606;					/* R6 */
80005144:	e0 68 06 06 	mov	r8,1542
80005148:	ea 18 06 06 	orh	r8,0x606
8000514c:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x07070707;					/* R7 */
8000514e:	e0 68 07 07 	mov	r8,1799
80005152:	ea 18 07 07 	orh	r8,0x707
80005156:	18 d8       	st.w	--r12,r8
	*pxTopOfStack = ( portSTACK_TYPE ) portNO_CRITICAL_NESTING;			/* ulCriticalNesting */
80005158:	30 08       	mov	r8,0
8000515a:	18 d8       	st.w	--r12,r8

	return pxTopOfStack;
}
8000515c:	5e fc       	retal	r12
8000515e:	d7 03       	nop

80005160 <vPortEnterCritical>:
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
__attribute__((__noinline__)) void vPortEnterCritical( void )
{
	/* Disable interrupts */
	portDISABLE_INTERRUPTS();
80005160:	d3 03       	ssrf	0x10

	/* Now interrupts are disabled ulCriticalNesting can be accessed
	 directly.  Increment ulCriticalNesting to keep a count of how many times
	 portENTER_CRITICAL() has been called. */
	ulCriticalNesting++;
80005162:	48 38       	lddpc	r8,8000516c <vPortEnterCritical+0xc>
80005164:	70 09       	ld.w	r9,r8[0x0]
80005166:	2f f9       	sub	r9,-1
80005168:	91 09       	st.w	r8[0x0],r9
}
8000516a:	5e fc       	retal	r12
8000516c:	00 00       	add	r0,r0
8000516e:	05 18       	ld.sh	r8,r2++

80005170 <xPortStartScheduler>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
80005170:	d4 01       	pushm	lr
	};

#endif

	/* Disable all interrupt/exception. */
	portDISABLE_INTERRUPTS();
80005172:	d3 03       	ssrf	0x10
		/* Start the timer/counter. */
		tc_start(tc, configTICK_TC_CHANNEL);
	}
	#else
	{
		INTC_register_interrupt(&vTick, AVR32_CORE_COMPARE_IRQ, AVR32_INTC_INT0);
80005174:	30 0a       	mov	r10,0
80005176:	14 9b       	mov	r11,r10
80005178:	49 2c       	lddpc	r12,800051c0 <xPortStartScheduler+0x50>
8000517a:	f0 1f 00 13 	mcall	800051c4 <xPortStartScheduler+0x54>
/* Schedule the COUNT&COMPARE match interrupt in (configCPU_CLOCK_HZ/configTICK_RATE_HZ)
clock cycles from now. */
#if( configTICK_USE_TC==0 )
	static void prvScheduleFirstTick(void)
	{
		Set_system_register(AVR32_COMPARE, configCPU_CLOCK_HZ/configTICK_RATE_HZ);//cause!!!
8000517e:	e0 68 5d c0 	mov	r8,24000
80005182:	e3 b8 00 43 	mtsr	0x10c,r8
		Set_system_register(AVR32_COUNT, 0);
80005186:	30 08       	mov	r8,0
80005188:	e3 b8 00 42 	mtsr	0x108,r8
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();

	/* Start the first task. */
	portRESTORE_CONTEXT();
8000518c:	e0 68 0c 6c 	mov	r8,3180
80005190:	ea 18 00 00 	orh	r8,0x0
80005194:	70 00       	ld.w	r0,r8[0x0]
80005196:	60 0d       	ld.w	sp,r0[0x0]
80005198:	1b 00       	ld.w	r0,sp++
8000519a:	e0 68 05 18 	mov	r8,1304
8000519e:	ea 18 00 00 	orh	r8,0x0
800051a2:	91 00       	st.w	r8[0x0],r0
800051a4:	e3 cd 00 ff 	ldm	sp++,r0-r7
800051a8:	2f ed       	sub	sp,-8
800051aa:	e3 cd 5f 00 	ldm	sp++,r8-r12,lr
800051ae:	fa f0 ff e0 	ld.w	r0,sp[-32]
800051b2:	e3 b0 00 00 	mtsr	0x0,r0
800051b6:	fa f0 ff dc 	ld.w	r0,sp[-36]
800051ba:	fa ff ff e4 	ld.w	pc,sp[-28]

	/* Should not get here! */
	return 0;
}
800051be:	d8 0a       	popm	pc,r12=0
800051c0:	80 00       	ld.sh	r0,r0[0x0]
800051c2:	52 8c       	stdsp	sp[0xa0],r12
800051c4:	80 00       	ld.sh	r0,r0[0x0]
800051c6:	47 c0       	lddsp	r0,sp[0x1f0]

800051c8 <SCALLYield>:
/*-----------------------------------------------------------*/
__attribute__((__naked__)) void SCALLYield( void );
__attribute__((__naked__)) void SCALLYield( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_SCALL();
800051c8:	20 6d       	sub	sp,24
800051ca:	eb cd 00 ff 	pushm	r0-r7
800051ce:	fa c7 ff c0 	sub	r7,sp,-64
800051d2:	ee f0 ff f8 	ld.w	r0,r7[-8]
800051d6:	ef 40 ff e0 	st.w	r7[-32],r0
800051da:	ee f0 ff fc 	ld.w	r0,r7[-4]
800051de:	ef 40 ff e4 	st.w	r7[-28],r0
800051e2:	eb c7 5f 00 	stm	--r7,r8-r12,lr
800051e6:	e0 68 05 18 	mov	r8,1304
800051ea:	ea 18 00 00 	orh	r8,0x0
800051ee:	70 00       	ld.w	r0,r8[0x0]
800051f0:	1a d0       	st.w	--sp,r0
800051f2:	f0 1f 00 1a 	mcall	80005258 <LABEL_RET_SCALL_263+0x14>
800051f6:	e0 68 0c 6c 	mov	r8,3180
800051fa:	ea 18 00 00 	orh	r8,0x0
800051fe:	70 00       	ld.w	r0,r8[0x0]
80005200:	81 0d       	st.w	r0[0x0],sp
	vTaskSwitchContext();
80005202:	f0 1f 00 17 	mcall	8000525c <LABEL_RET_SCALL_263+0x18>
	portRESTORE_CONTEXT_SCALL();
80005206:	e0 68 0c 6c 	mov	r8,3180
8000520a:	ea 18 00 00 	orh	r8,0x0
8000520e:	70 00       	ld.w	r0,r8[0x0]
80005210:	60 0d       	ld.w	sp,r0[0x0]
80005212:	1b 00       	ld.w	r0,sp++
80005214:	e0 68 05 18 	mov	r8,1304
80005218:	ea 18 00 00 	orh	r8,0x0
8000521c:	91 00       	st.w	r8[0x0],r0
8000521e:	fa c7 ff d8 	sub	r7,sp,-40
80005222:	e3 c7 5f 00 	ldm	r7++,r8-r12,lr
80005226:	ee f0 ff e0 	ld.w	r0,r7[-32]
8000522a:	e0 61 05 18 	mov	r1,1304
8000522e:	ea 11 00 00 	orh	r1,0x0
80005232:	62 02       	ld.w	r2,r1[0x0]
80005234:	58 02       	cp.w	r2,0
80005236:	c0 70       	breq	80005244 <LABEL_RET_SCALL_263>
80005238:	e4 c2 00 01 	sub	r2,r2,1
8000523c:	83 02       	st.w	r1[0x0],r2
8000523e:	58 02       	cp.w	r2,0
80005240:	c0 21       	brne	80005244 <LABEL_RET_SCALL_263>
80005242:	b1 c0       	cbr	r0,0x10

80005244 <LABEL_RET_SCALL_263>:
80005244:	ef 40 ff f8 	st.w	r7[-8],r0
80005248:	ee f0 ff e4 	ld.w	r0,r7[-28]
8000524c:	ef 40 ff fc 	st.w	r7[-4],r0
80005250:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005254:	2f ad       	sub	sp,-24
80005256:	d6 13       	rets
80005258:	80 00       	ld.sh	r0,r0[0x0]
8000525a:	51 60       	stdsp	sp[0x58],r0
8000525c:	80 00       	ld.sh	r0,r0[0x0]
8000525e:	58 5c       	cp.w	r12,5

80005260 <prvClearCcInt>:
		Set_system_register(AVR32_COUNT, 0);
	}

	__attribute__((__noinline__)) static void prvClearCcInt(void)
	{
		Set_system_register(AVR32_COMPARE, Get_system_register(AVR32_COMPARE));
80005260:	e1 b8 00 43 	mfsr	r8,0x10c
80005264:	e3 b8 00 43 	mtsr	0x10c,r8
	}
80005268:	5e fc       	retal	r12
8000526a:	d7 03       	nop

8000526c <vPortExitCritical>:
}
/*-----------------------------------------------------------*/

__attribute__((__noinline__)) void vPortExitCritical( void )
{
	if(ulCriticalNesting > portNO_CRITICAL_NESTING)
8000526c:	48 78       	lddpc	r8,80005288 <vPortExitCritical+0x1c>
8000526e:	70 08       	ld.w	r8,r8[0x0]
80005270:	58 08       	cp.w	r8,0
80005272:	5e 0c       	reteq	r12
	{
		ulCriticalNesting--;
80005274:	48 58       	lddpc	r8,80005288 <vPortExitCritical+0x1c>
80005276:	70 09       	ld.w	r9,r8[0x0]
80005278:	20 19       	sub	r9,1
8000527a:	91 09       	st.w	r8[0x0],r9
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
8000527c:	70 08       	ld.w	r8,r8[0x0]
8000527e:	58 08       	cp.w	r8,0
80005280:	5e 1c       	retne	r12
		{
			/* Enable all interrupt/exception. */
			portENABLE_INTERRUPTS();
80005282:	d5 03       	csrf	0x10
80005284:	5e fc       	retal	r12
80005286:	00 00       	add	r0,r0
80005288:	00 00       	add	r0,r0
8000528a:	05 18       	ld.sh	r8,r2++

8000528c <vTick>:
/* The preemptive scheduler is defined as "naked" as the full context is saved
on entry as part of the context switch. */
__attribute__((__naked__)) static void vTick( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_OS_INT();
8000528c:	eb cd 00 ff 	pushm	r0-r7
80005290:	e0 68 05 18 	mov	r8,1304
80005294:	ea 18 00 00 	orh	r8,0x0
80005298:	70 00       	ld.w	r0,r8[0x0]
8000529a:	1a d0       	st.w	--sp,r0
8000529c:	7a 90       	ld.w	r0,sp[0x24]
8000529e:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
800052a2:	58 10       	cp.w	r0,1
800052a4:	e0 8b 00 08 	brhi	800052b4 <LABEL_INT_SKIP_SAVE_CONTEXT_237>
800052a8:	e0 68 0c 6c 	mov	r8,3180
800052ac:	ea 18 00 00 	orh	r8,0x0
800052b0:	70 00       	ld.w	r0,r8[0x0]
800052b2:	81 0d       	st.w	r0[0x0],sp

800052b4 <LABEL_INT_SKIP_SAVE_CONTEXT_237>:
	#if( configTICK_USE_TC==1 )
		/* Clear the interrupt flag. */
		prvClearTcInt();
	#else
		/* Clear the interrupt flag. */
		prvClearCcInt();
800052b4:	f0 1f 00 12 	mcall	800052fc <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x14>
	#endif

	/* Because FreeRTOS is not supposed to run with nested interrupts, put all OS
	calls in a critical section . */
	portENTER_CRITICAL();
800052b8:	f0 1f 00 12 	mcall	80005300 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
		vTaskIncrementTick();
800052bc:	f0 1f 00 12 	mcall	80005304 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x1c>
	portEXIT_CRITICAL();
800052c0:	f0 1f 00 12 	mcall	80005308 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>

	/* Restore the context of the "elected task". */
	portRESTORE_CONTEXT_OS_INT();
800052c4:	7a 90       	ld.w	r0,sp[0x24]
800052c6:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
800052ca:	58 10       	cp.w	r0,1
800052cc:	e0 8b 00 0e 	brhi	800052e8 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>
800052d0:	f0 1f 00 0c 	mcall	80005300 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
800052d4:	f0 1f 00 0e 	mcall	8000530c <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x24>
800052d8:	f0 1f 00 0c 	mcall	80005308 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>
800052dc:	e0 68 0c 6c 	mov	r8,3180
800052e0:	ea 18 00 00 	orh	r8,0x0
800052e4:	70 00       	ld.w	r0,r8[0x0]
800052e6:	60 0d       	ld.w	sp,r0[0x0]

800052e8 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>:
800052e8:	1b 00       	ld.w	r0,sp++
800052ea:	e0 68 05 18 	mov	r8,1304
800052ee:	ea 18 00 00 	orh	r8,0x0
800052f2:	91 00       	st.w	r8[0x0],r0
800052f4:	e3 cd 00 ff 	ldm	sp++,r0-r7
800052f8:	d6 03       	rete
800052fa:	00 00       	add	r0,r0
800052fc:	80 00       	ld.sh	r0,r0[0x0]
800052fe:	52 60       	stdsp	sp[0x98],r0
80005300:	80 00       	ld.sh	r0,r0[0x0]
80005302:	51 60       	stdsp	sp[0x58],r0
80005304:	80 00       	ld.sh	r0,r0[0x0]
80005306:	5a 60       	cp.w	r0,-26
80005308:	80 00       	ld.sh	r0,r0[0x0]
8000530a:	52 6c       	stdsp	sp[0x98],r12
8000530c:	80 00       	ld.sh	r0,r0[0x0]
8000530e:	58 5c       	cp.w	r12,5

80005310 <__malloc_lock>:
 * safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_lock(struct _reent *ptr);
void __malloc_lock(struct _reent *ptr)
{
80005310:	d4 01       	pushm	lr
	vTaskSuspendAll();
80005312:	f0 1f 00 02 	mcall	80005318 <__malloc_lock+0x8>
}
80005316:	d8 02       	popm	pc
80005318:	80 00       	ld.sh	r0,r0[0x0]
8000531a:	58 4c       	cp.w	r12,4

8000531c <__malloc_unlock>:
 * a safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_unlock(struct _reent *ptr);
void __malloc_unlock(struct _reent *ptr)
{
8000531c:	d4 01       	pushm	lr
	xTaskResumeAll();
8000531e:	f0 1f 00 02 	mcall	80005324 <__malloc_unlock+0x8>
}
80005322:	d8 02       	popm	pc
80005324:	80 00       	ld.sh	r0,r0[0x0]
80005326:	5c 08       	acr	r8

80005328 <_read>:
/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
{
80005328:	d4 21       	pushm	r4-r7,lr
8000532a:	16 95       	mov	r5,r11
8000532c:	14 96       	mov	r6,r10
  int nChars = 0;

  if (file != 0)
8000532e:	58 0c       	cp.w	r12,0
80005330:	c0 30       	breq	80005336 <_read+0xe>
80005332:	3f f7       	mov	r7,-1
80005334:	c1 48       	rjmp	8000535c <_read+0x34>
    return -1;

  for (; len > 0; --len)
80005336:	58 0a       	cp.w	r10,0
80005338:	e0 89 00 04 	brgt	80005340 <_read+0x18>
8000533c:	30 07       	mov	r7,0
8000533e:	c0 f8       	rjmp	8000535c <_read+0x34>
80005340:	30 07       	mov	r7,0
  {
    int c = usart_getchar(stdio_usart_base);
80005342:	48 84       	lddpc	r4,80005360 <_read+0x38>
80005344:	68 0c       	ld.w	r12,r4[0x0]
80005346:	f0 1f 00 08 	mcall	80005364 <_read+0x3c>
    if (c < 0)
8000534a:	c0 95       	brlt	8000535c <_read+0x34>
      break;

    *ptr++ = c;
8000534c:	ea 07 0b 0c 	st.b	r5[r7],r12
    ++nChars;
80005350:	2f f7       	sub	r7,-1

/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
80005352:	ec 07 01 08 	sub	r8,r6,r7
  int nChars = 0;

  if (file != 0)
    return -1;

  for (; len > 0; --len)
80005356:	58 08       	cp.w	r8,0
80005358:	fe 99 ff f6 	brgt	80005344 <_read+0x1c>
    *ptr++ = c;
    ++nChars;
  }

  return nChars;
}
8000535c:	0e 9c       	mov	r12,r7
8000535e:	d8 22       	popm	r4-r7,pc
80005360:	00 00       	add	r0,r0
80005362:	1f cc       	ld.ub	r12,pc[0x4]
80005364:	80 00       	ld.sh	r0,r0[0x0]
80005366:	4e b4       	lddpc	r4,80005510 <xQueueGenericReceive+0x4c>

80005368 <_write>:
 * 1 and 2 is stdout and stderr which goes to usart
 * 3 is framebuffer
 */
int __attribute__((weak))
_write (int file, char * ptr, int len)
{
80005368:	d4 21       	pushm	r4-r7,lr
8000536a:	16 95       	mov	r5,r11
8000536c:	14 96       	mov	r6,r10
  int nChars = 0;

  if ( (file != 1)
8000536e:	20 1c       	sub	r12,1
80005370:	58 2c       	cp.w	r12,2
80005372:	e0 8b 00 12 	brhi	80005396 <_write+0x2e>
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80005376:	58 0a       	cp.w	r10,0
80005378:	c0 31       	brne	8000537e <_write+0x16>
8000537a:	30 07       	mov	r7,0
8000537c:	c0 e8       	rjmp	80005398 <_write+0x30>
8000537e:	30 07       	mov	r7,0
  {
    if (usart_putchar(stdio_usart_base, *ptr++) < 0)
80005380:	48 74       	lddpc	r4,8000539c <_write+0x34>
80005382:	68 0c       	ld.w	r12,r4[0x0]
80005384:	ea 07 07 0b 	ld.ub	r11,r5[r7]
80005388:	f0 1f 00 06 	mcall	800053a0 <_write+0x38>
8000538c:	c0 55       	brlt	80005396 <_write+0x2e>
    {
      return -1;
    }

    ++nChars;
8000538e:	2f f7       	sub	r7,-1

  if ( (file != 1)
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80005390:	0e 36       	cp.w	r6,r7
80005392:	cf 81       	brne	80005382 <_write+0x1a>
80005394:	c0 28       	rjmp	80005398 <_write+0x30>
80005396:	3f f7       	mov	r7,-1

    ++nChars;
  }

  return nChars;
}
80005398:	0e 9c       	mov	r12,r7
8000539a:	d8 22       	popm	r4-r7,pc
8000539c:	00 00       	add	r0,r0
8000539e:	1f cc       	ld.ub	r12,pc[0x4]
800053a0:	80 00       	ld.sh	r0,r0[0x0]
800053a2:	4e 64       	lddpc	r4,80005538 <xQueueGenericReceive+0x74>

800053a4 <vPortFree>:
	return pvReturn;
}
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
800053a4:	eb cd 40 80 	pushm	r7,lr
800053a8:	18 97       	mov	r7,r12
	if( pv )
800053aa:	58 0c       	cp.w	r12,0
800053ac:	c0 80       	breq	800053bc <vPortFree+0x18>
	{
		vTaskSuspendAll();
800053ae:	f0 1f 00 05 	mcall	800053c0 <vPortFree+0x1c>
		{
			free( pv );
800053b2:	0e 9c       	mov	r12,r7
800053b4:	f0 1f 00 04 	mcall	800053c4 <vPortFree+0x20>
		}
		xTaskResumeAll();
800053b8:	f0 1f 00 04 	mcall	800053c8 <vPortFree+0x24>
800053bc:	e3 cd 80 80 	ldm	sp++,r7,pc
800053c0:	80 00       	ld.sh	r0,r0[0x0]
800053c2:	58 4c       	cp.w	r12,4
800053c4:	80 00       	ld.sh	r0,r0[0x0]
800053c6:	65 5c       	ld.w	r12,r2[0x54]
800053c8:	80 00       	ld.sh	r0,r0[0x0]
800053ca:	5c 08       	acr	r8

800053cc <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
800053cc:	eb cd 40 80 	pushm	r7,lr
800053d0:	18 97       	mov	r7,r12
void *pvReturn;

	vTaskSuspendAll();
800053d2:	f0 1f 00 06 	mcall	800053e8 <pvPortMalloc+0x1c>
	{
		pvReturn = malloc( xWantedSize );
800053d6:	0e 9c       	mov	r12,r7
800053d8:	f0 1f 00 05 	mcall	800053ec <pvPortMalloc+0x20>
800053dc:	18 97       	mov	r7,r12
	}
	xTaskResumeAll();
800053de:	f0 1f 00 05 	mcall	800053f0 <pvPortMalloc+0x24>
		}
	}
	#endif

	return pvReturn;
}
800053e2:	0e 9c       	mov	r12,r7
800053e4:	e3 cd 80 80 	ldm	sp++,r7,pc
800053e8:	80 00       	ld.sh	r0,r0[0x0]
800053ea:	58 4c       	cp.w	r12,4
800053ec:	80 00       	ld.sh	r0,r0[0x0]
800053ee:	65 6c       	ld.w	r12,r2[0x58]
800053f0:	80 00       	ld.sh	r0,r0[0x0]
800053f2:	5c 08       	acr	r8

800053f4 <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
800053f4:	d4 01       	pushm	lr
800053f6:	16 98       	mov	r8,r11
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
800053f8:	78 09       	ld.w	r9,r12[0x0]
800053fa:	58 09       	cp.w	r9,0
800053fc:	c1 10       	breq	8000541e <prvCopyDataFromQueue+0x2a>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
800053fe:	78 3a       	ld.w	r10,r12[0xc]
80005400:	79 09       	ld.w	r9,r12[0x40]
80005402:	f4 09 00 09 	add	r9,r10,r9
80005406:	99 39       	st.w	r12[0xc],r9
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
80005408:	78 1a       	ld.w	r10,r12[0x4]
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
8000540a:	14 39       	cp.w	r9,r10
8000540c:	f9 f9 20 00 	ld.wcc	r9,r12[0x0]
80005410:	f9 f9 2a 03 	st.wcc	r12[0xc],r9
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
80005414:	79 0a       	ld.w	r10,r12[0x40]
80005416:	78 3b       	ld.w	r11,r12[0xc]
80005418:	10 9c       	mov	r12,r8
8000541a:	f0 1f 00 02 	mcall	80005420 <prvCopyDataFromQueue+0x2c>
8000541e:	d8 02       	popm	pc
80005420:	80 00       	ld.sh	r0,r0[0x0]
80005422:	69 da       	ld.w	r10,r4[0x74]

80005424 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
80005424:	eb cd 40 c0 	pushm	r6-r7,lr
80005428:	18 97       	mov	r7,r12

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
8000542a:	f0 1f 00 23 	mcall	800054b4 <prvUnlockQueue+0x90>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
8000542e:	6f 28       	ld.w	r8,r7[0x48]
80005430:	58 08       	cp.w	r8,0
80005432:	e0 8a 00 18 	brle	80005462 <prvUnlockQueue+0x3e>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005436:	6e 98       	ld.w	r8,r7[0x24]
80005438:	58 08       	cp.w	r8,0
8000543a:	c1 40       	breq	80005462 <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
8000543c:	ee c6 ff dc 	sub	r6,r7,-36
80005440:	c0 48       	rjmp	80005448 <prvUnlockQueue+0x24>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005442:	6e 98       	ld.w	r8,r7[0x24]
80005444:	58 08       	cp.w	r8,0
80005446:	c0 e0       	breq	80005462 <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80005448:	0c 9c       	mov	r12,r6
8000544a:	f0 1f 00 1c 	mcall	800054b8 <prvUnlockQueue+0x94>
8000544e:	c0 30       	breq	80005454 <prvUnlockQueue+0x30>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
80005450:	f0 1f 00 1b 	mcall	800054bc <prvUnlockQueue+0x98>
				}

				--( pxQueue->xTxLock );
80005454:	6f 28       	ld.w	r8,r7[0x48]
80005456:	20 18       	sub	r8,1
80005458:	ef 48 00 48 	st.w	r7[72],r8
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
8000545c:	58 08       	cp.w	r8,0
8000545e:	fe 99 ff f2 	brgt	80005442 <prvUnlockQueue+0x1e>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
80005462:	3f f8       	mov	r8,-1
80005464:	ef 48 00 48 	st.w	r7[72],r8
	}
	taskEXIT_CRITICAL();
80005468:	f0 1f 00 16 	mcall	800054c0 <prvUnlockQueue+0x9c>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
8000546c:	f0 1f 00 12 	mcall	800054b4 <prvUnlockQueue+0x90>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
80005470:	6f 18       	ld.w	r8,r7[0x44]
80005472:	58 08       	cp.w	r8,0
80005474:	e0 8a 00 18 	brle	800054a4 <prvUnlockQueue+0x80>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80005478:	6e 48       	ld.w	r8,r7[0x10]
8000547a:	58 08       	cp.w	r8,0
8000547c:	c1 40       	breq	800054a4 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
8000547e:	ee c6 ff f0 	sub	r6,r7,-16
80005482:	c0 48       	rjmp	8000548a <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80005484:	6e 48       	ld.w	r8,r7[0x10]
80005486:	58 08       	cp.w	r8,0
80005488:	c0 e0       	breq	800054a4 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
8000548a:	0c 9c       	mov	r12,r6
8000548c:	f0 1f 00 0b 	mcall	800054b8 <prvUnlockQueue+0x94>
80005490:	c0 30       	breq	80005496 <prvUnlockQueue+0x72>
				{
					vTaskMissedYield();
80005492:	f0 1f 00 0b 	mcall	800054bc <prvUnlockQueue+0x98>
				}

				--( pxQueue->xRxLock );
80005496:	6f 18       	ld.w	r8,r7[0x44]
80005498:	20 18       	sub	r8,1
8000549a:	ef 48 00 44 	st.w	r7[68],r8
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
8000549e:	58 08       	cp.w	r8,0
800054a0:	fe 99 ff f2 	brgt	80005484 <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
800054a4:	3f f8       	mov	r8,-1
800054a6:	ef 48 00 44 	st.w	r7[68],r8
	}
	taskEXIT_CRITICAL();
800054aa:	f0 1f 00 06 	mcall	800054c0 <prvUnlockQueue+0x9c>
}
800054ae:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800054b2:	00 00       	add	r0,r0
800054b4:	80 00       	ld.sh	r0,r0[0x0]
800054b6:	51 60       	stdsp	sp[0x58],r0
800054b8:	80 00       	ld.sh	r0,r0[0x0]
800054ba:	59 e4       	cp.w	r4,30
800054bc:	80 00       	ld.sh	r0,r0[0x0]
800054be:	58 f0       	cp.w	r0,15
800054c0:	80 00       	ld.sh	r0,r0[0x0]
800054c2:	52 6c       	stdsp	sp[0x98],r12

800054c4 <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
800054c4:	d4 31       	pushm	r0-r7,lr
800054c6:	20 5d       	sub	sp,20
800054c8:	18 97       	mov	r7,r12
800054ca:	50 0b       	stdsp	sp[0x0],r11
800054cc:	50 2a       	stdsp	sp[0x8],r10
800054ce:	50 19       	stdsp	sp[0x4],r9
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
800054d0:	f8 c2 ff dc 	sub	r2,r12,-36
800054d4:	30 05       	mov	r5,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
800054d6:	fa c4 ff f4 	sub	r4,sp,-12
800054da:	30 10       	mov	r0,1

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
800054dc:	0a 91       	mov	r1,r5

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
800054de:	fa c3 ff f8 	sub	r3,sp,-8
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
800054e2:	f0 1f 00 3e 	mcall	800055d8 <xQueueGenericReceive+0x114>
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
800054e6:	6e e8       	ld.w	r8,r7[0x38]
800054e8:	58 08       	cp.w	r8,0
800054ea:	c2 a0       	breq	8000553e <xQueueGenericReceive+0x7a>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
800054ec:	6e 36       	ld.w	r6,r7[0xc]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
800054ee:	40 0b       	lddsp	r11,sp[0x0]
800054f0:	0e 9c       	mov	r12,r7
800054f2:	f0 1f 00 3b 	mcall	800055dc <xQueueGenericReceive+0x118>

				if( xJustPeeking == pdFALSE )
800054f6:	40 18       	lddsp	r8,sp[0x4]
800054f8:	58 08       	cp.w	r8,0
800054fa:	c1 51       	brne	80005524 <xQueueGenericReceive+0x60>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
800054fc:	6e e8       	ld.w	r8,r7[0x38]
800054fe:	20 18       	sub	r8,1
80005500:	8f e8       	st.w	r7[0x38],r8

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80005502:	6e 08       	ld.w	r8,r7[0x0]
80005504:	58 08       	cp.w	r8,0
80005506:	c0 41       	brne	8000550e <xQueueGenericReceive+0x4a>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
80005508:	f0 1f 00 36 	mcall	800055e0 <xQueueGenericReceive+0x11c>
8000550c:	8f 1c       	st.w	r7[0x4],r12
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
8000550e:	6e 48       	ld.w	r8,r7[0x10]
80005510:	58 08       	cp.w	r8,0
80005512:	c1 20       	breq	80005536 <xQueueGenericReceive+0x72>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
80005514:	ee cc ff f0 	sub	r12,r7,-16
80005518:	f0 1f 00 33 	mcall	800055e4 <xQueueGenericReceive+0x120>
8000551c:	58 1c       	cp.w	r12,1
8000551e:	c0 c1       	brne	80005536 <xQueueGenericReceive+0x72>
						{
							portYIELD_WITHIN_API();
80005520:	d7 33       	scall
80005522:	c0 a8       	rjmp	80005536 <xQueueGenericReceive+0x72>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
80005524:	8f 36       	st.w	r7[0xc],r6

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005526:	6e 98       	ld.w	r8,r7[0x24]
80005528:	58 08       	cp.w	r8,0
8000552a:	c0 60       	breq	80005536 <xQueueGenericReceive+0x72>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
8000552c:	04 9c       	mov	r12,r2
8000552e:	f0 1f 00 2e 	mcall	800055e4 <xQueueGenericReceive+0x120>
80005532:	c0 20       	breq	80005536 <xQueueGenericReceive+0x72>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
80005534:	d7 33       	scall
						}
					}

				}

				taskEXIT_CRITICAL();
80005536:	f0 1f 00 2d 	mcall	800055e8 <xQueueGenericReceive+0x124>
8000553a:	30 1c       	mov	r12,1
				return pdPASS;
8000553c:	c4 c8       	rjmp	800055d4 <xQueueGenericReceive+0x110>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
8000553e:	40 28       	lddsp	r8,sp[0x8]
80005540:	58 08       	cp.w	r8,0
80005542:	c0 51       	brne	8000554c <xQueueGenericReceive+0x88>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80005544:	f0 1f 00 29 	mcall	800055e8 <xQueueGenericReceive+0x124>
80005548:	30 0c       	mov	r12,0
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
8000554a:	c4 58       	rjmp	800055d4 <xQueueGenericReceive+0x110>
				}
				else if( xEntryTimeSet == pdFALSE )
8000554c:	58 05       	cp.w	r5,0
8000554e:	c0 51       	brne	80005558 <xQueueGenericReceive+0x94>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80005550:	08 9c       	mov	r12,r4
80005552:	f0 1f 00 27 	mcall	800055ec <xQueueGenericReceive+0x128>
80005556:	00 95       	mov	r5,r0
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80005558:	f0 1f 00 24 	mcall	800055e8 <xQueueGenericReceive+0x124>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
8000555c:	f0 1f 00 25 	mcall	800055f0 <xQueueGenericReceive+0x12c>
		prvLockQueue( pxQueue );
80005560:	f0 1f 00 1e 	mcall	800055d8 <xQueueGenericReceive+0x114>
80005564:	6f 18       	ld.w	r8,r7[0x44]
80005566:	5b f8       	cp.w	r8,-1
80005568:	ef f1 0a 11 	st.weq	r7[0x44],r1
8000556c:	6f 28       	ld.w	r8,r7[0x48]
8000556e:	5b f8       	cp.w	r8,-1
80005570:	ef f1 0a 12 	st.weq	r7[0x48],r1
80005574:	f0 1f 00 1d 	mcall	800055e8 <xQueueGenericReceive+0x124>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80005578:	06 9b       	mov	r11,r3
8000557a:	08 9c       	mov	r12,r4
8000557c:	f0 1f 00 1e 	mcall	800055f4 <xQueueGenericReceive+0x130>
80005580:	c2 41       	brne	800055c8 <xQueueGenericReceive+0x104>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
80005582:	f0 1f 00 16 	mcall	800055d8 <xQueueGenericReceive+0x114>
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
80005586:	6e e6       	ld.w	r6,r7[0x38]
	taskEXIT_CRITICAL();
80005588:	f0 1f 00 18 	mcall	800055e8 <xQueueGenericReceive+0x124>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) )
8000558c:	58 06       	cp.w	r6,0
8000558e:	c1 71       	brne	800055bc <xQueueGenericReceive+0xf8>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80005590:	6e 08       	ld.w	r8,r7[0x0]
80005592:	58 08       	cp.w	r8,0
80005594:	c0 81       	brne	800055a4 <xQueueGenericReceive+0xe0>
					{
						portENTER_CRITICAL();
80005596:	f0 1f 00 11 	mcall	800055d8 <xQueueGenericReceive+0x114>
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
8000559a:	6e 1c       	ld.w	r12,r7[0x4]
8000559c:	f0 1f 00 17 	mcall	800055f8 <xQueueGenericReceive+0x134>
						}
						portEXIT_CRITICAL();
800055a0:	f0 1f 00 12 	mcall	800055e8 <xQueueGenericReceive+0x124>
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
800055a4:	40 2b       	lddsp	r11,sp[0x8]
800055a6:	04 9c       	mov	r12,r2
800055a8:	f0 1f 00 15 	mcall	800055fc <xQueueGenericReceive+0x138>
				prvUnlockQueue( pxQueue );
800055ac:	0e 9c       	mov	r12,r7
800055ae:	f0 1f 00 15 	mcall	80005600 <xQueueGenericReceive+0x13c>
				if( !xTaskResumeAll() )
800055b2:	f0 1f 00 15 	mcall	80005604 <xQueueGenericReceive+0x140>
800055b6:	c9 61       	brne	800054e2 <xQueueGenericReceive+0x1e>
				{
					portYIELD_WITHIN_API();
800055b8:	d7 33       	scall
800055ba:	c9 4b       	rjmp	800054e2 <xQueueGenericReceive+0x1e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
800055bc:	0e 9c       	mov	r12,r7
800055be:	f0 1f 00 11 	mcall	80005600 <xQueueGenericReceive+0x13c>
				( void ) xTaskResumeAll();
800055c2:	f0 1f 00 11 	mcall	80005604 <xQueueGenericReceive+0x140>
800055c6:	c8 eb       	rjmp	800054e2 <xQueueGenericReceive+0x1e>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
800055c8:	0e 9c       	mov	r12,r7
800055ca:	f0 1f 00 0e 	mcall	80005600 <xQueueGenericReceive+0x13c>
			( void ) xTaskResumeAll();
800055ce:	f0 1f 00 0e 	mcall	80005604 <xQueueGenericReceive+0x140>
800055d2:	30 0c       	mov	r12,0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
800055d4:	2f bd       	sub	sp,-20
800055d6:	d8 32       	popm	r0-r7,pc
800055d8:	80 00       	ld.sh	r0,r0[0x0]
800055da:	51 60       	stdsp	sp[0x58],r0
800055dc:	80 00       	ld.sh	r0,r0[0x0]
800055de:	53 f4       	stdsp	sp[0xfc],r4
800055e0:	80 00       	ld.sh	r0,r0[0x0]
800055e2:	58 fc       	cp.w	r12,15
800055e4:	80 00       	ld.sh	r0,r0[0x0]
800055e6:	59 e4       	cp.w	r4,30
800055e8:	80 00       	ld.sh	r0,r0[0x0]
800055ea:	52 6c       	stdsp	sp[0x98],r12
800055ec:	80 00       	ld.sh	r0,r0[0x0]
800055ee:	58 d8       	cp.w	r8,13
800055f0:	80 00       	ld.sh	r0,r0[0x0]
800055f2:	58 4c       	cp.w	r12,4
800055f4:	80 00       	ld.sh	r0,r0[0x0]
800055f6:	5b 74       	cp.w	r4,-9
800055f8:	80 00       	ld.sh	r0,r0[0x0]
800055fa:	59 60       	cp.w	r0,22
800055fc:	80 00       	ld.sh	r0,r0[0x0]
800055fe:	5e 14       	retne	r4
80005600:	80 00       	ld.sh	r0,r0[0x0]
80005602:	54 24       	stdsp	sp[0x108],r4
80005604:	80 00       	ld.sh	r0,r0[0x0]
80005606:	5c 08       	acr	r8

80005608 <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
80005608:	eb cd 40 80 	pushm	r7,lr
8000560c:	18 97       	mov	r7,r12
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
8000560e:	79 08       	ld.w	r8,r12[0x40]
80005610:	58 08       	cp.w	r8,0
80005612:	c0 a1       	brne	80005626 <prvCopyDataToQueue+0x1e>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80005614:	78 08       	ld.w	r8,r12[0x0]
80005616:	58 08       	cp.w	r8,0
80005618:	c2 b1       	brne	8000566e <prvCopyDataToQueue+0x66>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
8000561a:	78 1c       	ld.w	r12,r12[0x4]
8000561c:	f0 1f 00 17 	mcall	80005678 <prvCopyDataToQueue+0x70>
				pxQueue->pxMutexHolder = NULL;
80005620:	30 08       	mov	r8,0
80005622:	8f 18       	st.w	r7[0x4],r8
80005624:	c2 58       	rjmp	8000566e <prvCopyDataToQueue+0x66>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
80005626:	58 0a       	cp.w	r10,0
80005628:	c1 01       	brne	80005648 <prvCopyDataToQueue+0x40>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
8000562a:	10 9a       	mov	r10,r8
8000562c:	78 2c       	ld.w	r12,r12[0x8]
8000562e:	f0 1f 00 14 	mcall	8000567c <prvCopyDataToQueue+0x74>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
80005632:	6e 29       	ld.w	r9,r7[0x8]
80005634:	6f 08       	ld.w	r8,r7[0x40]
80005636:	f2 08 00 08 	add	r8,r9,r8
8000563a:	8f 28       	st.w	r7[0x8],r8
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
8000563c:	6e 19       	ld.w	r9,r7[0x4]
8000563e:	12 38       	cp.w	r8,r9
80005640:	c1 73       	brcs	8000566e <prvCopyDataToQueue+0x66>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
80005642:	6e 08       	ld.w	r8,r7[0x0]
80005644:	8f 28       	st.w	r7[0x8],r8
80005646:	c1 48       	rjmp	8000566e <prvCopyDataToQueue+0x66>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80005648:	10 9a       	mov	r10,r8
8000564a:	78 3c       	ld.w	r12,r12[0xc]
8000564c:	f0 1f 00 0c 	mcall	8000567c <prvCopyDataToQueue+0x74>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
80005650:	6f 08       	ld.w	r8,r7[0x40]
80005652:	6e 39       	ld.w	r9,r7[0xc]
80005654:	f2 08 01 08 	sub	r8,r9,r8
80005658:	8f 38       	st.w	r7[0xc],r8
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
8000565a:	6e 09       	ld.w	r9,r7[0x0]
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
8000565c:	12 38       	cp.w	r8,r9
8000565e:	ef f8 30 10 	ld.wcs	r8,r7[0x40]
80005662:	ef f9 30 01 	ld.wcs	r9,r7[0x4]
80005666:	f3 d8 e3 19 	subcs	r9,r9,r8
8000566a:	ef f9 3a 03 	st.wcs	r7[0xc],r9
		}
	}

	++( pxQueue->uxMessagesWaiting );
8000566e:	6e e8       	ld.w	r8,r7[0x38]
80005670:	2f f8       	sub	r8,-1
80005672:	8f e8       	st.w	r7[0x38],r8
}
80005674:	e3 cd 80 80 	ldm	sp++,r7,pc
80005678:	80 00       	ld.sh	r0,r0[0x0]
8000567a:	59 08       	cp.w	r8,16
8000567c:	80 00       	ld.sh	r0,r0[0x0]
8000567e:	69 da       	ld.w	r10,r4[0x74]

80005680 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
80005680:	d4 31       	pushm	r0-r7,lr
80005682:	20 5d       	sub	sp,20
80005684:	18 97       	mov	r7,r12
80005686:	50 0b       	stdsp	sp[0x0],r11
80005688:	50 2a       	stdsp	sp[0x8],r10
8000568a:	50 19       	stdsp	sp[0x4],r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
8000568c:	f8 c0 ff f0 	sub	r0,r12,-16
80005690:	30 04       	mov	r4,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80005692:	fa c3 ff f4 	sub	r3,sp,-12

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
80005696:	08 91       	mov	r1,r4

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80005698:	fa c2 ff f8 	sub	r2,sp,-8
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
8000569c:	f0 1f 00 2f 	mcall	80005758 <xQueueGenericSend+0xd8>
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
800056a0:	6e e9       	ld.w	r9,r7[0x38]
800056a2:	6e f8       	ld.w	r8,r7[0x3c]
800056a4:	10 39       	cp.w	r9,r8
800056a6:	c1 42       	brcc	800056ce <xQueueGenericSend+0x4e>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
800056a8:	40 1a       	lddsp	r10,sp[0x4]
800056aa:	40 0b       	lddsp	r11,sp[0x0]
800056ac:	0e 9c       	mov	r12,r7
800056ae:	f0 1f 00 2c 	mcall	8000575c <xQueueGenericSend+0xdc>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
800056b2:	6e 98       	ld.w	r8,r7[0x24]
800056b4:	58 08       	cp.w	r8,0
800056b6:	c0 80       	breq	800056c6 <xQueueGenericSend+0x46>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
800056b8:	ee cc ff dc 	sub	r12,r7,-36
800056bc:	f0 1f 00 29 	mcall	80005760 <xQueueGenericSend+0xe0>
800056c0:	58 1c       	cp.w	r12,1
800056c2:	c0 21       	brne	800056c6 <xQueueGenericSend+0x46>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
800056c4:	d7 33       	scall
					}
				}

				taskEXIT_CRITICAL();
800056c6:	f0 1f 00 28 	mcall	80005764 <xQueueGenericSend+0xe4>
800056ca:	30 1c       	mov	r12,1

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
800056cc:	c4 38       	rjmp	80005752 <xQueueGenericSend+0xd2>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
800056ce:	40 28       	lddsp	r8,sp[0x8]
800056d0:	58 08       	cp.w	r8,0
800056d2:	c0 51       	brne	800056dc <xQueueGenericSend+0x5c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
800056d4:	f0 1f 00 24 	mcall	80005764 <xQueueGenericSend+0xe4>
800056d8:	30 0c       	mov	r12,0

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
800056da:	c3 c8       	rjmp	80005752 <xQueueGenericSend+0xd2>
				}
				else if( xEntryTimeSet == pdFALSE )
800056dc:	58 04       	cp.w	r4,0
800056de:	c0 51       	brne	800056e8 <xQueueGenericSend+0x68>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
800056e0:	06 9c       	mov	r12,r3
800056e2:	f0 1f 00 22 	mcall	80005768 <xQueueGenericSend+0xe8>
800056e6:	30 14       	mov	r4,1
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
800056e8:	f0 1f 00 1f 	mcall	80005764 <xQueueGenericSend+0xe4>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
800056ec:	f0 1f 00 20 	mcall	8000576c <xQueueGenericSend+0xec>
		prvLockQueue( pxQueue );
800056f0:	f0 1f 00 1a 	mcall	80005758 <xQueueGenericSend+0xd8>
800056f4:	6f 18       	ld.w	r8,r7[0x44]
800056f6:	5b f8       	cp.w	r8,-1
800056f8:	ef f1 0a 11 	st.weq	r7[0x44],r1
800056fc:	6f 28       	ld.w	r8,r7[0x48]
800056fe:	5b f8       	cp.w	r8,-1
80005700:	ef f1 0a 12 	st.weq	r7[0x48],r1
80005704:	f0 1f 00 18 	mcall	80005764 <xQueueGenericSend+0xe4>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80005708:	04 9b       	mov	r11,r2
8000570a:	06 9c       	mov	r12,r3
8000570c:	f0 1f 00 19 	mcall	80005770 <xQueueGenericSend+0xf0>
80005710:	c1 b1       	brne	80005746 <xQueueGenericSend+0xc6>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
80005712:	f0 1f 00 12 	mcall	80005758 <xQueueGenericSend+0xd8>
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
80005716:	6e e5       	ld.w	r5,r7[0x38]
80005718:	6e f6       	ld.w	r6,r7[0x3c]
	taskEXIT_CRITICAL();
8000571a:	f0 1f 00 13 	mcall	80005764 <xQueueGenericSend+0xe4>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
8000571e:	0c 35       	cp.w	r5,r6
80005720:	c0 d1       	brne	8000573a <xQueueGenericSend+0xba>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
80005722:	40 2b       	lddsp	r11,sp[0x8]
80005724:	00 9c       	mov	r12,r0
80005726:	f0 1f 00 14 	mcall	80005774 <xQueueGenericSend+0xf4>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
8000572a:	0e 9c       	mov	r12,r7
8000572c:	f0 1f 00 13 	mcall	80005778 <xQueueGenericSend+0xf8>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
80005730:	f0 1f 00 13 	mcall	8000577c <xQueueGenericSend+0xfc>
80005734:	cb 41       	brne	8000569c <xQueueGenericSend+0x1c>
				{
					portYIELD_WITHIN_API();
80005736:	d7 33       	scall
80005738:	cb 2b       	rjmp	8000569c <xQueueGenericSend+0x1c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
8000573a:	0e 9c       	mov	r12,r7
8000573c:	f0 1f 00 0f 	mcall	80005778 <xQueueGenericSend+0xf8>
				( void ) xTaskResumeAll();
80005740:	f0 1f 00 0f 	mcall	8000577c <xQueueGenericSend+0xfc>
80005744:	ca cb       	rjmp	8000569c <xQueueGenericSend+0x1c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
80005746:	0e 9c       	mov	r12,r7
80005748:	f0 1f 00 0c 	mcall	80005778 <xQueueGenericSend+0xf8>
			( void ) xTaskResumeAll();
8000574c:	f0 1f 00 0c 	mcall	8000577c <xQueueGenericSend+0xfc>
80005750:	30 0c       	mov	r12,0
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
80005752:	2f bd       	sub	sp,-20
80005754:	d8 32       	popm	r0-r7,pc
80005756:	00 00       	add	r0,r0
80005758:	80 00       	ld.sh	r0,r0[0x0]
8000575a:	51 60       	stdsp	sp[0x58],r0
8000575c:	80 00       	ld.sh	r0,r0[0x0]
8000575e:	56 08       	stdsp	sp[0x180],r8
80005760:	80 00       	ld.sh	r0,r0[0x0]
80005762:	59 e4       	cp.w	r4,30
80005764:	80 00       	ld.sh	r0,r0[0x0]
80005766:	52 6c       	stdsp	sp[0x98],r12
80005768:	80 00       	ld.sh	r0,r0[0x0]
8000576a:	58 d8       	cp.w	r8,13
8000576c:	80 00       	ld.sh	r0,r0[0x0]
8000576e:	58 4c       	cp.w	r12,4
80005770:	80 00       	ld.sh	r0,r0[0x0]
80005772:	5b 74       	cp.w	r4,-9
80005774:	80 00       	ld.sh	r0,r0[0x0]
80005776:	5e 14       	retne	r4
80005778:	80 00       	ld.sh	r0,r0[0x0]
8000577a:	54 24       	stdsp	sp[0x108],r4
8000577c:	80 00       	ld.sh	r0,r0[0x0]
8000577e:	5c 08       	acr	r8

80005780 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	xQueueHandle xQueueCreateMutex( void )
	{
80005780:	eb cd 40 c0 	pushm	r6-r7,lr
	xQUEUE *pxNewQueue;

		/* Allocate the new queue structure. */
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
80005784:	34 cc       	mov	r12,76
80005786:	f0 1f 00 12 	mcall	800057cc <xQueueCreateMutex+0x4c>
8000578a:	18 97       	mov	r7,r12
		if( pxNewQueue != NULL )
8000578c:	c1 d0       	breq	800057c6 <xQueueCreateMutex+0x46>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
8000578e:	30 06       	mov	r6,0
80005790:	99 16       	st.w	r12[0x4],r6
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
80005792:	99 06       	st.w	r12[0x0],r6

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
80005794:	99 26       	st.w	r12[0x8],r6
			pxNewQueue->pcReadFrom = NULL;
80005796:	99 36       	st.w	r12[0xc],r6

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
80005798:	99 e6       	st.w	r12[0x38],r6
			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
8000579a:	30 18       	mov	r8,1
8000579c:	99 f8       	st.w	r12[0x3c],r8
			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
8000579e:	f9 46 00 40 	st.w	r12[64],r6
			pxNewQueue->xRxLock = queueUNLOCKED;
800057a2:	3f f8       	mov	r8,-1
800057a4:	f9 48 00 44 	st.w	r12[68],r8
			pxNewQueue->xTxLock = queueUNLOCKED;
800057a8:	f9 48 00 48 	st.w	r12[72],r8

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
800057ac:	2f 0c       	sub	r12,-16
800057ae:	f0 1f 00 09 	mcall	800057d0 <xQueueCreateMutex+0x50>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
800057b2:	ee cc ff dc 	sub	r12,r7,-36
800057b6:	f0 1f 00 07 	mcall	800057d0 <xQueueCreateMutex+0x50>

			/* Start with the semaphore in the expected state. */
			xQueueGenericSend( pxNewQueue, NULL, ( portTickType ) 0U, queueSEND_TO_BACK );
800057ba:	0c 99       	mov	r9,r6
800057bc:	0c 9a       	mov	r10,r6
800057be:	0c 9b       	mov	r11,r6
800057c0:	0e 9c       	mov	r12,r7
800057c2:	f0 1f 00 05 	mcall	800057d4 <xQueueCreateMutex+0x54>
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
800057c6:	0e 9c       	mov	r12,r7
800057c8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800057cc:	80 00       	ld.sh	r0,r0[0x0]
800057ce:	53 cc       	stdsp	sp[0xf0],r12
800057d0:	80 00       	ld.sh	r0,r0[0x0]
800057d2:	50 3c       	stdsp	sp[0xc],r12
800057d4:	80 00       	ld.sh	r0,r0[0x0]
800057d6:	56 80       	stdsp	sp[0x1a0],r0

800057d8 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
800057d8:	d4 21       	pushm	r4-r7,lr
800057da:	18 97       	mov	r7,r12
800057dc:	16 96       	mov	r6,r11
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
800057de:	58 0c       	cp.w	r12,0
800057e0:	c2 f0       	breq	8000583e <xQueueCreate+0x66>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
800057e2:	34 cc       	mov	r12,76
800057e4:	f0 1f 00 17 	mcall	80005840 <xQueueCreate+0x68>
800057e8:	18 95       	mov	r5,r12
		if( pxNewQueue != NULL )
800057ea:	c2 a0       	breq	8000583e <xQueueCreate+0x66>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
800057ec:	ec 07 02 44 	mul	r4,r6,r7

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
800057f0:	e8 cc ff ff 	sub	r12,r4,-1
800057f4:	f0 1f 00 13 	mcall	80005840 <xQueueCreate+0x68>
800057f8:	8b 0c       	st.w	r5[0x0],r12
			if( pxNewQueue->pcHead != NULL )
800057fa:	c1 e0       	breq	80005836 <xQueueCreate+0x5e>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
800057fc:	f8 04 00 04 	add	r4,r12,r4
80005800:	8b 14       	st.w	r5[0x4],r4
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
80005802:	30 08       	mov	r8,0
80005804:	8b e8       	st.w	r5[0x38],r8
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
80005806:	8b 2c       	st.w	r5[0x8],r12
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
80005808:	ee c8 00 01 	sub	r8,r7,1
8000580c:	ad 38       	mul	r8,r6
8000580e:	10 0c       	add	r12,r8
80005810:	8b 3c       	st.w	r5[0xc],r12
				pxNewQueue->uxLength = uxQueueLength;
80005812:	8b f7       	st.w	r5[0x3c],r7
				pxNewQueue->uxItemSize = uxItemSize;
80005814:	eb 46 00 40 	st.w	r5[64],r6
				pxNewQueue->xRxLock = queueUNLOCKED;
80005818:	3f f8       	mov	r8,-1
8000581a:	eb 48 00 44 	st.w	r5[68],r8
				pxNewQueue->xTxLock = queueUNLOCKED;
8000581e:	eb 48 00 48 	st.w	r5[72],r8

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
80005822:	ea cc ff f0 	sub	r12,r5,-16
80005826:	f0 1f 00 08 	mcall	80005844 <xQueueCreate+0x6c>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
8000582a:	ea cc ff dc 	sub	r12,r5,-36
8000582e:	f0 1f 00 06 	mcall	80005844 <xQueueCreate+0x6c>
80005832:	0a 9c       	mov	r12,r5
80005834:	d8 22       	popm	r4-r7,pc
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
80005836:	0a 9c       	mov	r12,r5
80005838:	f0 1f 00 04 	mcall	80005848 <xQueueCreate+0x70>
8000583c:	d8 2a       	popm	r4-r7,pc,r12=0
8000583e:	d8 2a       	popm	r4-r7,pc,r12=0
80005840:	80 00       	ld.sh	r0,r0[0x0]
80005842:	53 cc       	stdsp	sp[0xf0],r12
80005844:	80 00       	ld.sh	r0,r0[0x0]
80005846:	50 3c       	stdsp	sp[0xc],r12
80005848:	80 00       	ld.sh	r0,r0[0x0]
8000584a:	53 a4       	stdsp	sp[0xe8],r4

8000584c <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
8000584c:	48 38       	lddpc	r8,80005858 <vTaskSuspendAll+0xc>
8000584e:	70 09       	ld.w	r9,r8[0x0]
80005850:	2f f9       	sub	r9,-1
80005852:	91 09       	st.w	r8[0x0],r9
}
80005854:	5e fc       	retal	r12
80005856:	00 00       	add	r0,r0
80005858:	00 00       	add	r0,r0
8000585a:	0c 9c       	mov	r12,r6

8000585c <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
8000585c:	49 a8       	lddpc	r8,800058c4 <vTaskSwitchContext+0x68>
8000585e:	70 08       	ld.w	r8,r8[0x0]
80005860:	58 08       	cp.w	r8,0
80005862:	c0 b1       	brne	80005878 <vTaskSwitchContext+0x1c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80005864:	49 98       	lddpc	r8,800058c8 <vTaskSwitchContext+0x6c>
80005866:	70 08       	ld.w	r8,r8[0x0]
80005868:	f0 08 00 28 	add	r8,r8,r8<<0x2
8000586c:	49 89       	lddpc	r9,800058cc <vTaskSwitchContext+0x70>
8000586e:	f2 08 03 28 	ld.w	r8,r9[r8<<0x2]
80005872:	58 08       	cp.w	r8,0
80005874:	c0 60       	breq	80005880 <vTaskSwitchContext+0x24>
80005876:	c1 18       	rjmp	80005898 <vTaskSwitchContext+0x3c>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
80005878:	30 19       	mov	r9,1
8000587a:	49 68       	lddpc	r8,800058d0 <vTaskSwitchContext+0x74>
8000587c:	91 09       	st.w	r8[0x0],r9
8000587e:	5e fc       	retal	r12

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
80005880:	49 28       	lddpc	r8,800058c8 <vTaskSwitchContext+0x6c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80005882:	49 3a       	lddpc	r10,800058cc <vTaskSwitchContext+0x70>
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
80005884:	70 09       	ld.w	r9,r8[0x0]
80005886:	20 19       	sub	r9,1
80005888:	91 09       	st.w	r8[0x0],r9

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
8000588a:	70 09       	ld.w	r9,r8[0x0]
8000588c:	f2 09 00 29 	add	r9,r9,r9<<0x2
80005890:	f4 09 03 29 	ld.w	r9,r10[r9<<0x2]
80005894:	58 09       	cp.w	r9,0
80005896:	cf 70       	breq	80005884 <vTaskSwitchContext+0x28>
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
80005898:	48 c8       	lddpc	r8,800058c8 <vTaskSwitchContext+0x6c>
8000589a:	70 08       	ld.w	r8,r8[0x0]
8000589c:	f0 08 00 28 	add	r8,r8,r8<<0x2
800058a0:	48 b9       	lddpc	r9,800058cc <vTaskSwitchContext+0x70>
800058a2:	f2 08 00 28 	add	r8,r9,r8<<0x2
800058a6:	70 19       	ld.w	r9,r8[0x4]
800058a8:	72 19       	ld.w	r9,r9[0x4]
800058aa:	91 19       	st.w	r8[0x4],r9
800058ac:	f0 ca ff f8 	sub	r10,r8,-8
800058b0:	14 39       	cp.w	r9,r10
800058b2:	f3 f9 00 01 	ld.weq	r9,r9[0x4]
800058b6:	f1 f9 0a 01 	st.weq	r8[0x4],r9
800058ba:	70 18       	ld.w	r8,r8[0x4]
800058bc:	70 39       	ld.w	r9,r8[0xc]
800058be:	48 68       	lddpc	r8,800058d4 <vTaskSwitchContext+0x78>
800058c0:	91 09       	st.w	r8[0x0],r9
800058c2:	5e fc       	retal	r12
800058c4:	00 00       	add	r0,r0
800058c6:	0c 9c       	mov	r12,r6
800058c8:	00 00       	add	r0,r0
800058ca:	0c d4       	st.w	--r6,r4
800058cc:	00 00       	add	r0,r0
800058ce:	0b b8       	ld.ub	r8,r5[0x3]
800058d0:	00 00       	add	r0,r0
800058d2:	0c bc       	st.h	r6++,r12
800058d4:	00 00       	add	r0,r0
800058d6:	0c 6c       	and	r12,r6

800058d8 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
800058d8:	48 48       	lddpc	r8,800058e8 <vTaskSetTimeOutState+0x10>
800058da:	70 08       	ld.w	r8,r8[0x0]
800058dc:	99 08       	st.w	r12[0x0],r8
	pxTimeOut->xTimeOnEntering = xTickCount;
800058de:	48 48       	lddpc	r8,800058ec <vTaskSetTimeOutState+0x14>
800058e0:	70 08       	ld.w	r8,r8[0x0]
800058e2:	99 18       	st.w	r12[0x4],r8
}
800058e4:	5e fc       	retal	r12
800058e6:	00 00       	add	r0,r0
800058e8:	00 00       	add	r0,r0
800058ea:	0b b0       	ld.ub	r0,r5[0x3]
800058ec:	00 00       	add	r0,r0
800058ee:	0c 98       	mov	r8,r6

800058f0 <vTaskMissedYield>:
}
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
800058f0:	30 19       	mov	r9,1
800058f2:	48 28       	lddpc	r8,800058f8 <vTaskMissedYield+0x8>
800058f4:	91 09       	st.w	r8[0x0],r9
}
800058f6:	5e fc       	retal	r12
800058f8:	00 00       	add	r0,r0
800058fa:	0c bc       	st.h	r6++,r12

800058fc <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
800058fc:	48 28       	lddpc	r8,80005904 <xTaskGetCurrentTaskHandle+0x8>
800058fe:	70 0c       	ld.w	r12,r8[0x0]

		return xReturn;
	}
80005900:	5e fc       	retal	r12
80005902:	00 00       	add	r0,r0
80005904:	00 00       	add	r0,r0
80005906:	0c 6c       	and	r12,r6

80005908 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
80005908:	eb cd 40 c0 	pushm	r6-r7,lr
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
8000590c:	58 0c       	cp.w	r12,0
8000590e:	c1 f0       	breq	8000594c <vTaskPriorityDisinherit+0x44>

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
80005910:	18 97       	mov	r7,r12

		if( pxMutexHolder != NULL )
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
80005912:	78 b9       	ld.w	r9,r12[0x2c]
80005914:	79 18       	ld.w	r8,r12[0x44]
80005916:	10 39       	cp.w	r9,r8
80005918:	c1 a0       	breq	8000594c <vTaskPriorityDisinherit+0x44>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
8000591a:	f8 c6 ff fc 	sub	r6,r12,-4
8000591e:	0c 9c       	mov	r12,r6
80005920:	f0 1f 00 0c 	mcall	80005950 <vTaskPriorityDisinherit+0x48>

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
80005924:	6f 1c       	ld.w	r12,r7[0x44]
80005926:	8f bc       	st.w	r7[0x2c],r12
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
80005928:	f8 08 11 08 	rsub	r8,r12,8
8000592c:	8f 68       	st.w	r7[0x18],r8
				prvAddTaskToReadyQueue( pxTCB );
8000592e:	48 a8       	lddpc	r8,80005954 <vTaskPriorityDisinherit+0x4c>
80005930:	70 08       	ld.w	r8,r8[0x0]
80005932:	10 3c       	cp.w	r12,r8
80005934:	e0 88 00 04 	brls	8000593c <vTaskPriorityDisinherit+0x34>
80005938:	48 78       	lddpc	r8,80005954 <vTaskPriorityDisinherit+0x4c>
8000593a:	91 0c       	st.w	r8[0x0],r12
8000593c:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80005940:	0c 9b       	mov	r11,r6
80005942:	48 68       	lddpc	r8,80005958 <vTaskPriorityDisinherit+0x50>
80005944:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80005948:	f0 1f 00 05 	mcall	8000595c <vTaskPriorityDisinherit+0x54>
8000594c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005950:	80 00       	ld.sh	r0,r0[0x0]
80005952:	50 a6       	stdsp	sp[0x28],r6
80005954:	00 00       	add	r0,r0
80005956:	0c d4       	st.w	--r6,r4
80005958:	00 00       	add	r0,r0
8000595a:	0b b8       	ld.ub	r8,r5[0x3]
8000595c:	80 00       	ld.sh	r0,r0[0x0]
8000595e:	50 56       	stdsp	sp[0x14],r6

80005960 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
80005960:	eb cd 40 c0 	pushm	r6-r7,lr
80005964:	18 97       	mov	r7,r12
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
80005966:	49 b8       	lddpc	r8,800059d0 <vTaskPriorityInherit+0x70>
80005968:	70 08       	ld.w	r8,r8[0x0]
8000596a:	78 b9       	ld.w	r9,r12[0x2c]
8000596c:	70 b8       	ld.w	r8,r8[0x2c]
8000596e:	10 39       	cp.w	r9,r8
80005970:	c2 d2       	brcc	800059ca <vTaskPriorityInherit+0x6a>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
80005972:	49 88       	lddpc	r8,800059d0 <vTaskPriorityInherit+0x70>
80005974:	70 08       	ld.w	r8,r8[0x0]
80005976:	70 b8       	ld.w	r8,r8[0x2c]
80005978:	f0 08 11 08 	rsub	r8,r8,8
8000597c:	99 68       	st.w	r12[0x18],r8

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
8000597e:	f2 09 00 28 	add	r8,r9,r9<<0x2
80005982:	49 59       	lddpc	r9,800059d4 <vTaskPriorityInherit+0x74>
80005984:	f2 08 00 28 	add	r8,r9,r8<<0x2
80005988:	78 59       	ld.w	r9,r12[0x14]
8000598a:	10 39       	cp.w	r9,r8
8000598c:	c1 b1       	brne	800059c2 <vTaskPriorityInherit+0x62>
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
8000598e:	f8 c6 ff fc 	sub	r6,r12,-4
80005992:	0c 9c       	mov	r12,r6
80005994:	f0 1f 00 11 	mcall	800059d8 <vTaskPriorityInherit+0x78>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
80005998:	48 e8       	lddpc	r8,800059d0 <vTaskPriorityInherit+0x70>
8000599a:	70 08       	ld.w	r8,r8[0x0]
8000599c:	70 bc       	ld.w	r12,r8[0x2c]
8000599e:	8f bc       	st.w	r7[0x2c],r12
				prvAddTaskToReadyQueue( pxTCB );
800059a0:	48 f8       	lddpc	r8,800059dc <vTaskPriorityInherit+0x7c>
800059a2:	70 08       	ld.w	r8,r8[0x0]
800059a4:	10 3c       	cp.w	r12,r8
800059a6:	e0 88 00 04 	brls	800059ae <vTaskPriorityInherit+0x4e>
800059aa:	48 d8       	lddpc	r8,800059dc <vTaskPriorityInherit+0x7c>
800059ac:	91 0c       	st.w	r8[0x0],r12
800059ae:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800059b2:	0c 9b       	mov	r11,r6
800059b4:	48 88       	lddpc	r8,800059d4 <vTaskPriorityInherit+0x74>
800059b6:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800059ba:	f0 1f 00 0a 	mcall	800059e0 <vTaskPriorityInherit+0x80>
800059be:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
800059c2:	48 48       	lddpc	r8,800059d0 <vTaskPriorityInherit+0x70>
800059c4:	70 08       	ld.w	r8,r8[0x0]
800059c6:	70 b8       	ld.w	r8,r8[0x2c]
800059c8:	99 b8       	st.w	r12[0x2c],r8
800059ca:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800059ce:	00 00       	add	r0,r0
800059d0:	00 00       	add	r0,r0
800059d2:	0c 6c       	and	r12,r6
800059d4:	00 00       	add	r0,r0
800059d6:	0b b8       	ld.ub	r8,r5[0x3]
800059d8:	80 00       	ld.sh	r0,r0[0x0]
800059da:	50 a6       	stdsp	sp[0x28],r6
800059dc:	00 00       	add	r0,r0
800059de:	0c d4       	st.w	--r6,r4
800059e0:	80 00       	ld.sh	r0,r0[0x0]
800059e2:	50 56       	stdsp	sp[0x14],r6

800059e4 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
800059e4:	eb cd 40 c0 	pushm	r6-r7,lr
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
800059e8:	78 38       	ld.w	r8,r12[0xc]
800059ea:	70 37       	ld.w	r7,r8[0xc]
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
800059ec:	ee c6 ff e8 	sub	r6,r7,-24
800059f0:	0c 9c       	mov	r12,r6
800059f2:	f0 1f 00 15 	mcall	80005a44 <xTaskRemoveFromEventList+0x60>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
800059f6:	49 58       	lddpc	r8,80005a48 <xTaskRemoveFromEventList+0x64>
800059f8:	70 08       	ld.w	r8,r8[0x0]
800059fa:	58 08       	cp.w	r8,0
800059fc:	c1 71       	brne	80005a2a <xTaskRemoveFromEventList+0x46>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
800059fe:	ee c6 ff fc 	sub	r6,r7,-4
80005a02:	0c 9c       	mov	r12,r6
80005a04:	f0 1f 00 10 	mcall	80005a44 <xTaskRemoveFromEventList+0x60>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
80005a08:	6e bc       	ld.w	r12,r7[0x2c]
80005a0a:	49 18       	lddpc	r8,80005a4c <xTaskRemoveFromEventList+0x68>
80005a0c:	70 08       	ld.w	r8,r8[0x0]
80005a0e:	10 3c       	cp.w	r12,r8
80005a10:	e0 88 00 04 	brls	80005a18 <xTaskRemoveFromEventList+0x34>
80005a14:	48 e8       	lddpc	r8,80005a4c <xTaskRemoveFromEventList+0x68>
80005a16:	91 0c       	st.w	r8[0x0],r12
80005a18:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80005a1c:	0c 9b       	mov	r11,r6
80005a1e:	48 d8       	lddpc	r8,80005a50 <xTaskRemoveFromEventList+0x6c>
80005a20:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80005a24:	f0 1f 00 0c 	mcall	80005a54 <xTaskRemoveFromEventList+0x70>
80005a28:	c0 58       	rjmp	80005a32 <xTaskRemoveFromEventList+0x4e>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
80005a2a:	0c 9b       	mov	r11,r6
80005a2c:	48 bc       	lddpc	r12,80005a58 <xTaskRemoveFromEventList+0x74>
80005a2e:	f0 1f 00 0a 	mcall	80005a54 <xTaskRemoveFromEventList+0x70>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
80005a32:	48 b8       	lddpc	r8,80005a5c <xTaskRemoveFromEventList+0x78>
80005a34:	70 08       	ld.w	r8,r8[0x0]
80005a36:	6e b9       	ld.w	r9,r7[0x2c]
80005a38:	70 b8       	ld.w	r8,r8[0x2c]
80005a3a:	10 39       	cp.w	r9,r8
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
80005a3c:	5f 2c       	srhs	r12
80005a3e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005a42:	00 00       	add	r0,r0
80005a44:	80 00       	ld.sh	r0,r0[0x0]
80005a46:	50 a6       	stdsp	sp[0x28],r6
80005a48:	00 00       	add	r0,r0
80005a4a:	0c 9c       	mov	r12,r6
80005a4c:	00 00       	add	r0,r0
80005a4e:	0c d4       	st.w	--r6,r4
80005a50:	00 00       	add	r0,r0
80005a52:	0b b8       	ld.ub	r8,r5[0x3]
80005a54:	80 00       	ld.sh	r0,r0[0x0]
80005a56:	50 56       	stdsp	sp[0x14],r6
80005a58:	00 00       	add	r0,r0
80005a5a:	0c 70       	tst	r0,r6
80005a5c:	00 00       	add	r0,r0
80005a5e:	0c 6c       	and	r12,r6

80005a60 <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
80005a60:	eb cd 40 fc 	pushm	r2-r7,lr
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80005a64:	4b 98       	lddpc	r8,80005b48 <vTaskIncrementTick+0xe8>
80005a66:	70 08       	ld.w	r8,r8[0x0]
80005a68:	58 08       	cp.w	r8,0
80005a6a:	c6 91       	brne	80005b3c <vTaskIncrementTick+0xdc>
	{
		++xTickCount;
80005a6c:	4b 88       	lddpc	r8,80005b4c <vTaskIncrementTick+0xec>
80005a6e:	70 09       	ld.w	r9,r8[0x0]
80005a70:	2f f9       	sub	r9,-1
80005a72:	91 09       	st.w	r8[0x0],r9
		if( xTickCount == ( portTickType ) 0 )
80005a74:	70 08       	ld.w	r8,r8[0x0]
80005a76:	58 08       	cp.w	r8,0
80005a78:	c1 a1       	brne	80005aac <vTaskIncrementTick+0x4c>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
80005a7a:	4b 68       	lddpc	r8,80005b50 <vTaskIncrementTick+0xf0>
80005a7c:	70 0a       	ld.w	r10,r8[0x0]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
80005a7e:	4b 69       	lddpc	r9,80005b54 <vTaskIncrementTick+0xf4>
80005a80:	72 0b       	ld.w	r11,r9[0x0]
80005a82:	91 0b       	st.w	r8[0x0],r11
			pxOverflowDelayedTaskList = pxTemp;
80005a84:	93 0a       	st.w	r9[0x0],r10
			xNumOfOverflows++;
80005a86:	4b 59       	lddpc	r9,80005b58 <vTaskIncrementTick+0xf8>
80005a88:	72 0a       	ld.w	r10,r9[0x0]
80005a8a:	2f fa       	sub	r10,-1
80005a8c:	93 0a       	st.w	r9[0x0],r10

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
80005a8e:	70 08       	ld.w	r8,r8[0x0]
80005a90:	70 08       	ld.w	r8,r8[0x0]
80005a92:	58 08       	cp.w	r8,0
80005a94:	c0 51       	brne	80005a9e <vTaskIncrementTick+0x3e>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
80005a96:	3f f9       	mov	r9,-1
80005a98:	4b 18       	lddpc	r8,80005b5c <vTaskIncrementTick+0xfc>
80005a9a:	91 09       	st.w	r8[0x0],r9
80005a9c:	c0 88       	rjmp	80005aac <vTaskIncrementTick+0x4c>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
80005a9e:	4a d8       	lddpc	r8,80005b50 <vTaskIncrementTick+0xf0>
80005aa0:	70 08       	ld.w	r8,r8[0x0]
80005aa2:	70 38       	ld.w	r8,r8[0xc]
80005aa4:	70 38       	ld.w	r8,r8[0xc]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
80005aa6:	70 19       	ld.w	r9,r8[0x4]
80005aa8:	4a d8       	lddpc	r8,80005b5c <vTaskIncrementTick+0xfc>
80005aaa:	91 09       	st.w	r8[0x0],r9
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
80005aac:	4a 88       	lddpc	r8,80005b4c <vTaskIncrementTick+0xec>
80005aae:	70 09       	ld.w	r9,r8[0x0]
80005ab0:	4a b8       	lddpc	r8,80005b5c <vTaskIncrementTick+0xfc>
80005ab2:	70 08       	ld.w	r8,r8[0x0]
80005ab4:	10 39       	cp.w	r9,r8
80005ab6:	c4 73       	brcs	80005b44 <vTaskIncrementTick+0xe4>
80005ab8:	4a 68       	lddpc	r8,80005b50 <vTaskIncrementTick+0xf0>
80005aba:	70 08       	ld.w	r8,r8[0x0]
80005abc:	70 08       	ld.w	r8,r8[0x0]
80005abe:	58 08       	cp.w	r8,0
80005ac0:	c0 c0       	breq	80005ad8 <vTaskIncrementTick+0x78>
80005ac2:	4a 48       	lddpc	r8,80005b50 <vTaskIncrementTick+0xf0>
80005ac4:	70 08       	ld.w	r8,r8[0x0]
80005ac6:	70 38       	ld.w	r8,r8[0xc]
80005ac8:	70 37       	ld.w	r7,r8[0xc]
80005aca:	6e 18       	ld.w	r8,r7[0x4]
80005acc:	4a 09       	lddpc	r9,80005b4c <vTaskIncrementTick+0xec>
80005ace:	72 09       	ld.w	r9,r9[0x0]
80005ad0:	12 38       	cp.w	r8,r9
80005ad2:	e0 88 00 14 	brls	80005afa <vTaskIncrementTick+0x9a>
80005ad6:	c0 e8       	rjmp	80005af2 <vTaskIncrementTick+0x92>
80005ad8:	3f f9       	mov	r9,-1
80005ada:	4a 18       	lddpc	r8,80005b5c <vTaskIncrementTick+0xfc>
80005adc:	91 09       	st.w	r8[0x0],r9
80005ade:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80005ae2:	6a 08       	ld.w	r8,r5[0x0]
80005ae4:	70 38       	ld.w	r8,r8[0xc]
80005ae6:	70 37       	ld.w	r7,r8[0xc]
80005ae8:	6e 18       	ld.w	r8,r7[0x4]
80005aea:	64 09       	ld.w	r9,r2[0x0]
80005aec:	12 38       	cp.w	r8,r9
80005aee:	e0 88 00 0a 	brls	80005b02 <vTaskIncrementTick+0xa2>
80005af2:	49 b9       	lddpc	r9,80005b5c <vTaskIncrementTick+0xfc>
80005af4:	93 08       	st.w	r9[0x0],r8
80005af6:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80005afa:	49 a4       	lddpc	r4,80005b60 <vTaskIncrementTick+0x100>
80005afc:	49 a3       	lddpc	r3,80005b64 <vTaskIncrementTick+0x104>
80005afe:	49 55       	lddpc	r5,80005b50 <vTaskIncrementTick+0xf0>
80005b00:	49 32       	lddpc	r2,80005b4c <vTaskIncrementTick+0xec>
80005b02:	ee c6 ff fc 	sub	r6,r7,-4
80005b06:	0c 9c       	mov	r12,r6
80005b08:	f0 1f 00 18 	mcall	80005b68 <vTaskIncrementTick+0x108>
80005b0c:	6e a8       	ld.w	r8,r7[0x28]
80005b0e:	58 08       	cp.w	r8,0
80005b10:	c0 50       	breq	80005b1a <vTaskIncrementTick+0xba>
80005b12:	ee cc ff e8 	sub	r12,r7,-24
80005b16:	f0 1f 00 15 	mcall	80005b68 <vTaskIncrementTick+0x108>
80005b1a:	6e bc       	ld.w	r12,r7[0x2c]
80005b1c:	68 08       	ld.w	r8,r4[0x0]
80005b1e:	10 3c       	cp.w	r12,r8
80005b20:	e9 fc ba 00 	st.whi	r4[0x0],r12
80005b24:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80005b28:	0c 9b       	mov	r11,r6
80005b2a:	e6 0c 00 2c 	add	r12,r3,r12<<0x2
80005b2e:	f0 1f 00 10 	mcall	80005b6c <vTaskIncrementTick+0x10c>
80005b32:	6a 08       	ld.w	r8,r5[0x0]
80005b34:	70 08       	ld.w	r8,r8[0x0]
80005b36:	58 08       	cp.w	r8,0
80005b38:	cd 51       	brne	80005ae2 <vTaskIncrementTick+0x82>
80005b3a:	cc fb       	rjmp	80005ad8 <vTaskIncrementTick+0x78>
	}
	else
	{
		++uxMissedTicks;
80005b3c:	48 d8       	lddpc	r8,80005b70 <vTaskIncrementTick+0x110>
80005b3e:	70 09       	ld.w	r9,r8[0x0]
80005b40:	2f f9       	sub	r9,-1
80005b42:	91 09       	st.w	r8[0x0],r9
80005b44:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80005b48:	00 00       	add	r0,r0
80005b4a:	0c 9c       	mov	r12,r6
80005b4c:	00 00       	add	r0,r0
80005b4e:	0c 98       	mov	r8,r6
80005b50:	00 00       	add	r0,r0
80005b52:	0b a4       	ld.ub	r4,r5[0x2]
80005b54:	00 00       	add	r0,r0
80005b56:	0b b4       	ld.ub	r4,r5[0x3]
80005b58:	00 00       	add	r0,r0
80005b5a:	0b b0       	ld.ub	r0,r5[0x3]
80005b5c:	00 00       	add	r0,r0
80005b5e:	05 1c       	ld.sh	r12,r2++
80005b60:	00 00       	add	r0,r0
80005b62:	0c d4       	st.w	--r6,r4
80005b64:	00 00       	add	r0,r0
80005b66:	0b b8       	ld.ub	r8,r5[0x3]
80005b68:	80 00       	ld.sh	r0,r0[0x0]
80005b6a:	50 a6       	stdsp	sp[0x28],r6
80005b6c:	80 00       	ld.sh	r0,r0[0x0]
80005b6e:	50 56       	stdsp	sp[0x14],r6
80005b70:	00 00       	add	r0,r0
80005b72:	0b 9c       	ld.ub	r12,r5[0x1]

80005b74 <xTaskCheckForTimeOut>:
	pxTimeOut->xTimeOnEntering = xTickCount;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
80005b74:	eb cd 40 c0 	pushm	r6-r7,lr
80005b78:	18 97       	mov	r7,r12
80005b7a:	16 96       	mov	r6,r11
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
80005b7c:	f0 1f 00 15 	mcall	80005bd0 <xTaskCheckForTimeOut+0x5c>
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
80005b80:	6c 08       	ld.w	r8,r6[0x0]
80005b82:	5b f8       	cp.w	r8,-1
80005b84:	c0 31       	brne	80005b8a <xTaskCheckForTimeOut+0x16>
80005b86:	30 07       	mov	r7,0
80005b88:	c1 f8       	rjmp	80005bc6 <xTaskCheckForTimeOut+0x52>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
80005b8a:	49 39       	lddpc	r9,80005bd4 <xTaskCheckForTimeOut+0x60>
80005b8c:	72 09       	ld.w	r9,r9[0x0]
80005b8e:	6e 0a       	ld.w	r10,r7[0x0]
80005b90:	12 3a       	cp.w	r10,r9
80005b92:	c0 70       	breq	80005ba0 <xTaskCheckForTimeOut+0x2c>
80005b94:	49 19       	lddpc	r9,80005bd8 <xTaskCheckForTimeOut+0x64>
80005b96:	72 09       	ld.w	r9,r9[0x0]
80005b98:	6e 1a       	ld.w	r10,r7[0x4]
80005b9a:	12 3a       	cp.w	r10,r9
80005b9c:	e0 88 00 14 	brls	80005bc4 <xTaskCheckForTimeOut+0x50>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
80005ba0:	48 e9       	lddpc	r9,80005bd8 <xTaskCheckForTimeOut+0x64>
80005ba2:	72 0a       	ld.w	r10,r9[0x0]
80005ba4:	6e 19       	ld.w	r9,r7[0x4]
80005ba6:	12 1a       	sub	r10,r9
80005ba8:	14 38       	cp.w	r8,r10
80005baa:	e0 88 00 0d 	brls	80005bc4 <xTaskCheckForTimeOut+0x50>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
80005bae:	48 ba       	lddpc	r10,80005bd8 <xTaskCheckForTimeOut+0x64>
80005bb0:	74 0a       	ld.w	r10,r10[0x0]
80005bb2:	14 19       	sub	r9,r10
80005bb4:	f2 08 00 08 	add	r8,r9,r8
80005bb8:	8d 08       	st.w	r6[0x0],r8
			vTaskSetTimeOutState( pxTimeOut );
80005bba:	0e 9c       	mov	r12,r7
80005bbc:	f0 1f 00 08 	mcall	80005bdc <xTaskCheckForTimeOut+0x68>
80005bc0:	30 07       	mov	r7,0
80005bc2:	c0 28       	rjmp	80005bc6 <xTaskCheckForTimeOut+0x52>
80005bc4:	30 17       	mov	r7,1
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
80005bc6:	f0 1f 00 07 	mcall	80005be0 <xTaskCheckForTimeOut+0x6c>

	return xReturn;
}
80005bca:	0e 9c       	mov	r12,r7
80005bcc:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005bd0:	80 00       	ld.sh	r0,r0[0x0]
80005bd2:	51 60       	stdsp	sp[0x58],r0
80005bd4:	00 00       	add	r0,r0
80005bd6:	0b b0       	ld.ub	r0,r5[0x3]
80005bd8:	00 00       	add	r0,r0
80005bda:	0c 98       	mov	r8,r6
80005bdc:	80 00       	ld.sh	r0,r0[0x0]
80005bde:	58 d8       	cp.w	r8,13
80005be0:	80 00       	ld.sh	r0,r0[0x0]
80005be2:	52 6c       	stdsp	sp[0x98],r12

80005be4 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
80005be4:	eb cd 40 80 	pushm	r7,lr
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
80005be8:	f0 1f 00 05 	mcall	80005bfc <xTaskGetTickCount+0x18>
	{
		xTicks = xTickCount;
80005bec:	48 58       	lddpc	r8,80005c00 <xTaskGetTickCount+0x1c>
80005bee:	70 07       	ld.w	r7,r8[0x0]
	}
	taskEXIT_CRITICAL();
80005bf0:	f0 1f 00 05 	mcall	80005c04 <xTaskGetTickCount+0x20>

	return xTicks;
}
80005bf4:	0e 9c       	mov	r12,r7
80005bf6:	e3 cd 80 80 	ldm	sp++,r7,pc
80005bfa:	00 00       	add	r0,r0
80005bfc:	80 00       	ld.sh	r0,r0[0x0]
80005bfe:	51 60       	stdsp	sp[0x58],r0
80005c00:	00 00       	add	r0,r0
80005c02:	0c 98       	mov	r8,r6
80005c04:	80 00       	ld.sh	r0,r0[0x0]
80005c06:	52 6c       	stdsp	sp[0x98],r12

80005c08 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
80005c08:	eb cd 40 fe 	pushm	r1-r7,lr
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
80005c0c:	f0 1f 00 2c 	mcall	80005cbc <xTaskResumeAll+0xb4>
	{
		--uxSchedulerSuspended;
80005c10:	4a c8       	lddpc	r8,80005cc0 <xTaskResumeAll+0xb8>
80005c12:	70 09       	ld.w	r9,r8[0x0]
80005c14:	20 19       	sub	r9,1
80005c16:	91 09       	st.w	r8[0x0],r9

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80005c18:	70 08       	ld.w	r8,r8[0x0]
80005c1a:	58 08       	cp.w	r8,0
80005c1c:	c4 91       	brne	80005cae <xTaskResumeAll+0xa6>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
80005c1e:	4a a8       	lddpc	r8,80005cc4 <xTaskResumeAll+0xbc>
80005c20:	70 08       	ld.w	r8,r8[0x0]
80005c22:	58 08       	cp.w	r8,0
80005c24:	c4 50       	breq	80005cae <xTaskResumeAll+0xa6>
80005c26:	30 04       	mov	r4,0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80005c28:	4a 85       	lddpc	r5,80005cc8 <xTaskResumeAll+0xc0>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
80005c2a:	4a 93       	lddpc	r3,80005ccc <xTaskResumeAll+0xc4>
80005c2c:	4a 92       	lddpc	r2,80005cd0 <xTaskResumeAll+0xc8>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80005c2e:	4a a1       	lddpc	r1,80005cd4 <xTaskResumeAll+0xcc>
80005c30:	c1 e8       	rjmp	80005c6c <xTaskResumeAll+0x64>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
80005c32:	6a 38       	ld.w	r8,r5[0xc]
80005c34:	70 37       	ld.w	r7,r8[0xc]
					vListRemove( &( pxTCB->xEventListItem ) );
80005c36:	ee cc ff e8 	sub	r12,r7,-24
80005c3a:	f0 1f 00 28 	mcall	80005cd8 <xTaskResumeAll+0xd0>
					vListRemove( &( pxTCB->xGenericListItem ) );
80005c3e:	ee c6 ff fc 	sub	r6,r7,-4
80005c42:	0c 9c       	mov	r12,r6
80005c44:	f0 1f 00 25 	mcall	80005cd8 <xTaskResumeAll+0xd0>
					prvAddTaskToReadyQueue( pxTCB );
80005c48:	6e bc       	ld.w	r12,r7[0x2c]
80005c4a:	66 08       	ld.w	r8,r3[0x0]
80005c4c:	10 3c       	cp.w	r12,r8
80005c4e:	e7 fc ba 00 	st.whi	r3[0x0],r12
80005c52:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80005c56:	0c 9b       	mov	r11,r6
80005c58:	e4 0c 00 2c 	add	r12,r2,r12<<0x2
80005c5c:	f0 1f 00 20 	mcall	80005cdc <xTaskResumeAll+0xd4>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80005c60:	62 08       	ld.w	r8,r1[0x0]
80005c62:	6e b9       	ld.w	r9,r7[0x2c]
80005c64:	70 b8       	ld.w	r8,r8[0x2c]
80005c66:	10 39       	cp.w	r9,r8
80005c68:	f9 b4 02 01 	movhs	r4,1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80005c6c:	6a 08       	ld.w	r8,r5[0x0]
80005c6e:	58 08       	cp.w	r8,0
80005c70:	ce 11       	brne	80005c32 <xTaskResumeAll+0x2a>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80005c72:	49 c8       	lddpc	r8,80005ce0 <xTaskResumeAll+0xd8>
80005c74:	70 08       	ld.w	r8,r8[0x0]
80005c76:	58 08       	cp.w	r8,0
80005c78:	c0 f0       	breq	80005c96 <xTaskResumeAll+0x8e>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80005c7a:	49 a8       	lddpc	r8,80005ce0 <xTaskResumeAll+0xd8>
80005c7c:	70 08       	ld.w	r8,r8[0x0]
80005c7e:	58 08       	cp.w	r8,0
80005c80:	c1 10       	breq	80005ca2 <xTaskResumeAll+0x9a>
					{
						vTaskIncrementTick();
						--uxMissedTicks;
80005c82:	49 87       	lddpc	r7,80005ce0 <xTaskResumeAll+0xd8>
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
80005c84:	f0 1f 00 18 	mcall	80005ce4 <xTaskResumeAll+0xdc>
						--uxMissedTicks;
80005c88:	6e 08       	ld.w	r8,r7[0x0]
80005c8a:	20 18       	sub	r8,1
80005c8c:	8f 08       	st.w	r7[0x0],r8
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80005c8e:	6e 08       	ld.w	r8,r7[0x0]
80005c90:	58 08       	cp.w	r8,0
80005c92:	cf 91       	brne	80005c84 <xTaskResumeAll+0x7c>
80005c94:	c0 78       	rjmp	80005ca2 <xTaskResumeAll+0x9a>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
80005c96:	58 14       	cp.w	r4,1
80005c98:	c0 50       	breq	80005ca2 <xTaskResumeAll+0x9a>
80005c9a:	49 48       	lddpc	r8,80005ce8 <xTaskResumeAll+0xe0>
80005c9c:	70 08       	ld.w	r8,r8[0x0]
80005c9e:	58 18       	cp.w	r8,1
80005ca0:	c0 71       	brne	80005cae <xTaskResumeAll+0xa6>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
80005ca2:	30 09       	mov	r9,0
80005ca4:	49 18       	lddpc	r8,80005ce8 <xTaskResumeAll+0xe0>
80005ca6:	91 09       	st.w	r8[0x0],r9
					portYIELD_WITHIN_API();
80005ca8:	d7 33       	scall
80005caa:	30 17       	mov	r7,1
80005cac:	c0 28       	rjmp	80005cb0 <xTaskResumeAll+0xa8>
80005cae:	30 07       	mov	r7,0
				}
			}
		}
	}
	taskEXIT_CRITICAL();
80005cb0:	f0 1f 00 0f 	mcall	80005cec <xTaskResumeAll+0xe4>

	return xAlreadyYielded;
}
80005cb4:	0e 9c       	mov	r12,r7
80005cb6:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
80005cba:	00 00       	add	r0,r0
80005cbc:	80 00       	ld.sh	r0,r0[0x0]
80005cbe:	51 60       	stdsp	sp[0x58],r0
80005cc0:	00 00       	add	r0,r0
80005cc2:	0c 9c       	mov	r12,r6
80005cc4:	00 00       	add	r0,r0
80005cc6:	0c b8       	st.h	r6++,r8
80005cc8:	00 00       	add	r0,r0
80005cca:	0c 70       	tst	r0,r6
80005ccc:	00 00       	add	r0,r0
80005cce:	0c d4       	st.w	--r6,r4
80005cd0:	00 00       	add	r0,r0
80005cd2:	0b b8       	ld.ub	r8,r5[0x3]
80005cd4:	00 00       	add	r0,r0
80005cd6:	0c 6c       	and	r12,r6
80005cd8:	80 00       	ld.sh	r0,r0[0x0]
80005cda:	50 a6       	stdsp	sp[0x28],r6
80005cdc:	80 00       	ld.sh	r0,r0[0x0]
80005cde:	50 56       	stdsp	sp[0x14],r6
80005ce0:	00 00       	add	r0,r0
80005ce2:	0b 9c       	ld.ub	r12,r5[0x1]
80005ce4:	80 00       	ld.sh	r0,r0[0x0]
80005ce6:	5a 60       	cp.w	r0,-26
80005ce8:	00 00       	add	r0,r0
80005cea:	0c bc       	st.h	r6++,r12
80005cec:	80 00       	ld.sh	r0,r0[0x0]
80005cee:	52 6c       	stdsp	sp[0x98],r12

80005cf0 <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
80005cf0:	eb cd 40 80 	pushm	r7,lr
80005cf4:	18 97       	mov	r7,r12
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
80005cf6:	49 08       	lddpc	r8,80005d34 <prvAddCurrentTaskToDelayedList+0x44>
80005cf8:	70 08       	ld.w	r8,r8[0x0]
80005cfa:	91 1c       	st.w	r8[0x4],r12

	if( xTimeToWake < xTickCount )
80005cfc:	48 f8       	lddpc	r8,80005d38 <prvAddCurrentTaskToDelayedList+0x48>
80005cfe:	70 08       	ld.w	r8,r8[0x0]
80005d00:	10 3c       	cp.w	r12,r8
80005d02:	c0 a2       	brcc	80005d16 <prvAddCurrentTaskToDelayedList+0x26>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80005d04:	48 c8       	lddpc	r8,80005d34 <prvAddCurrentTaskToDelayedList+0x44>
80005d06:	70 0b       	ld.w	r11,r8[0x0]
80005d08:	48 d8       	lddpc	r8,80005d3c <prvAddCurrentTaskToDelayedList+0x4c>
80005d0a:	70 0c       	ld.w	r12,r8[0x0]
80005d0c:	2f cb       	sub	r11,-4
80005d0e:	f0 1f 00 0d 	mcall	80005d40 <prvAddCurrentTaskToDelayedList+0x50>
80005d12:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80005d16:	48 88       	lddpc	r8,80005d34 <prvAddCurrentTaskToDelayedList+0x44>
80005d18:	70 0b       	ld.w	r11,r8[0x0]
80005d1a:	48 b8       	lddpc	r8,80005d44 <prvAddCurrentTaskToDelayedList+0x54>
80005d1c:	70 0c       	ld.w	r12,r8[0x0]
80005d1e:	2f cb       	sub	r11,-4
80005d20:	f0 1f 00 08 	mcall	80005d40 <prvAddCurrentTaskToDelayedList+0x50>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
80005d24:	48 98       	lddpc	r8,80005d48 <prvAddCurrentTaskToDelayedList+0x58>
80005d26:	70 08       	ld.w	r8,r8[0x0]
80005d28:	10 37       	cp.w	r7,r8
80005d2a:	c0 32       	brcc	80005d30 <prvAddCurrentTaskToDelayedList+0x40>
		{
			xNextTaskUnblockTime = xTimeToWake;
80005d2c:	48 78       	lddpc	r8,80005d48 <prvAddCurrentTaskToDelayedList+0x58>
80005d2e:	91 07       	st.w	r8[0x0],r7
80005d30:	e3 cd 80 80 	ldm	sp++,r7,pc
80005d34:	00 00       	add	r0,r0
80005d36:	0c 6c       	and	r12,r6
80005d38:	00 00       	add	r0,r0
80005d3a:	0c 98       	mov	r8,r6
80005d3c:	00 00       	add	r0,r0
80005d3e:	0b b4       	ld.ub	r4,r5[0x3]
80005d40:	80 00       	ld.sh	r0,r0[0x0]
80005d42:	50 72       	stdsp	sp[0x1c],r2
80005d44:	00 00       	add	r0,r0
80005d46:	0b a4       	ld.ub	r4,r5[0x2]
80005d48:	00 00       	add	r0,r0
80005d4a:	05 1c       	ld.sh	r12,r2++

80005d4c <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
80005d4c:	eb cd 40 c0 	pushm	r6-r7,lr
80005d50:	18 97       	mov	r7,r12
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0 )
80005d52:	58 0c       	cp.w	r12,0
80005d54:	c1 10       	breq	80005d76 <vTaskDelay+0x2a>
		{
			vTaskSuspendAll();
80005d56:	f0 1f 00 0a 	mcall	80005d7c <vTaskDelay+0x30>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
80005d5a:	48 a8       	lddpc	r8,80005d80 <vTaskDelay+0x34>
80005d5c:	70 06       	ld.w	r6,r8[0x0]

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80005d5e:	48 a8       	lddpc	r8,80005d84 <vTaskDelay+0x38>
80005d60:	70 0c       	ld.w	r12,r8[0x0]
80005d62:	2f cc       	sub	r12,-4
80005d64:	f0 1f 00 09 	mcall	80005d88 <vTaskDelay+0x3c>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
80005d68:	ee 06 00 0c 	add	r12,r7,r6
80005d6c:	f0 1f 00 08 	mcall	80005d8c <vTaskDelay+0x40>
			}
			xAlreadyYielded = xTaskResumeAll();
80005d70:	f0 1f 00 08 	mcall	80005d90 <vTaskDelay+0x44>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
80005d74:	c0 21       	brne	80005d78 <vTaskDelay+0x2c>
		{
			portYIELD_WITHIN_API();
80005d76:	d7 33       	scall
80005d78:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005d7c:	80 00       	ld.sh	r0,r0[0x0]
80005d7e:	58 4c       	cp.w	r12,4
80005d80:	00 00       	add	r0,r0
80005d82:	0c 98       	mov	r8,r6
80005d84:	00 00       	add	r0,r0
80005d86:	0c 6c       	and	r12,r6
80005d88:	80 00       	ld.sh	r0,r0[0x0]
80005d8a:	50 a6       	stdsp	sp[0x28],r6
80005d8c:	80 00       	ld.sh	r0,r0[0x0]
80005d8e:	5c f0       	rol	r0
80005d90:	80 00       	ld.sh	r0,r0[0x0]
80005d92:	5c 08       	acr	r8

80005d94 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
80005d94:	eb cd 40 c0 	pushm	r6-r7,lr
80005d98:	18 96       	mov	r6,r12
80005d9a:	16 97       	mov	r7,r11
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0 ) );

		vTaskSuspendAll();
80005d9c:	f0 1f 00 18 	mcall	80005dfc <vTaskDelayUntil+0x68>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
80005da0:	6c 08       	ld.w	r8,r6[0x0]
80005da2:	10 07       	add	r7,r8

			if( xTickCount < *pxPreviousWakeTime )
80005da4:	49 79       	lddpc	r9,80005e00 <vTaskDelayUntil+0x6c>
80005da6:	72 09       	ld.w	r9,r9[0x0]
80005da8:	12 38       	cp.w	r8,r9
80005daa:	e0 88 00 0c 	brls	80005dc2 <vTaskDelayUntil+0x2e>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
80005dae:	0e 38       	cp.w	r8,r7
80005db0:	e0 88 00 22 	brls	80005df4 <vTaskDelayUntil+0x60>
80005db4:	49 38       	lddpc	r8,80005e00 <vTaskDelayUntil+0x6c>
80005db6:	70 08       	ld.w	r8,r8[0x0]
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80005db8:	8d 07       	st.w	r6[0x0],r7

			if( xShouldDelay != pdFALSE )
80005dba:	10 37       	cp.w	r7,r8
80005dbc:	e0 88 00 14 	brls	80005de4 <vTaskDelayUntil+0x50>
80005dc0:	c0 a8       	rjmp	80005dd4 <vTaskDelayUntil+0x40>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
80005dc2:	0e 38       	cp.w	r8,r7
80005dc4:	e0 8b 00 16 	brhi	80005df0 <vTaskDelayUntil+0x5c>
80005dc8:	48 e8       	lddpc	r8,80005e00 <vTaskDelayUntil+0x6c>
80005dca:	70 08       	ld.w	r8,r8[0x0]
80005dcc:	10 37       	cp.w	r7,r8
80005dce:	e0 8b 00 11 	brhi	80005df0 <vTaskDelayUntil+0x5c>
80005dd2:	c1 18       	rjmp	80005df4 <vTaskDelayUntil+0x60>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80005dd4:	48 c8       	lddpc	r8,80005e04 <vTaskDelayUntil+0x70>
80005dd6:	70 0c       	ld.w	r12,r8[0x0]
80005dd8:	2f cc       	sub	r12,-4
80005dda:	f0 1f 00 0c 	mcall	80005e08 <vTaskDelayUntil+0x74>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
80005dde:	0e 9c       	mov	r12,r7
80005de0:	f0 1f 00 0b 	mcall	80005e0c <vTaskDelayUntil+0x78>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
80005de4:	f0 1f 00 0b 	mcall	80005e10 <vTaskDelayUntil+0x7c>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
80005de8:	c0 81       	brne	80005df8 <vTaskDelayUntil+0x64>
		{
			portYIELD_WITHIN_API();
80005dea:	d7 33       	scall
80005dec:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80005df0:	8d 07       	st.w	r6[0x0],r7
80005df2:	cf 1b       	rjmp	80005dd4 <vTaskDelayUntil+0x40>
80005df4:	8d 07       	st.w	r6[0x0],r7
80005df6:	cf 7b       	rjmp	80005de4 <vTaskDelayUntil+0x50>
80005df8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005dfc:	80 00       	ld.sh	r0,r0[0x0]
80005dfe:	58 4c       	cp.w	r12,4
80005e00:	00 00       	add	r0,r0
80005e02:	0c 98       	mov	r8,r6
80005e04:	00 00       	add	r0,r0
80005e06:	0c 6c       	and	r12,r6
80005e08:	80 00       	ld.sh	r0,r0[0x0]
80005e0a:	50 a6       	stdsp	sp[0x28],r6
80005e0c:	80 00       	ld.sh	r0,r0[0x0]
80005e0e:	5c f0       	rol	r0
80005e10:	80 00       	ld.sh	r0,r0[0x0]
80005e12:	5c 08       	acr	r8

80005e14 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
80005e14:	eb cd 40 c0 	pushm	r6-r7,lr
80005e18:	16 96       	mov	r6,r11
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
80005e1a:	48 e7       	lddpc	r7,80005e50 <vTaskPlaceOnEventList+0x3c>
80005e1c:	6e 0b       	ld.w	r11,r7[0x0]
80005e1e:	2e 8b       	sub	r11,-24
80005e20:	f0 1f 00 0d 	mcall	80005e54 <vTaskPlaceOnEventList+0x40>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80005e24:	6e 0c       	ld.w	r12,r7[0x0]
80005e26:	2f cc       	sub	r12,-4
80005e28:	f0 1f 00 0c 	mcall	80005e58 <vTaskPlaceOnEventList+0x44>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
80005e2c:	5b f6       	cp.w	r6,-1
80005e2e:	c0 81       	brne	80005e3e <vTaskPlaceOnEventList+0x2a>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80005e30:	6e 0b       	ld.w	r11,r7[0x0]
80005e32:	2f cb       	sub	r11,-4
80005e34:	48 ac       	lddpc	r12,80005e5c <vTaskPlaceOnEventList+0x48>
80005e36:	f0 1f 00 0b 	mcall	80005e60 <vTaskPlaceOnEventList+0x4c>
80005e3a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
80005e3e:	48 a8       	lddpc	r8,80005e64 <vTaskPlaceOnEventList+0x50>
80005e40:	70 0c       	ld.w	r12,r8[0x0]
			prvAddCurrentTaskToDelayedList( xTimeToWake );
80005e42:	ec 0c 00 0c 	add	r12,r6,r12
80005e46:	f0 1f 00 09 	mcall	80005e68 <vTaskPlaceOnEventList+0x54>
80005e4a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005e4e:	00 00       	add	r0,r0
80005e50:	00 00       	add	r0,r0
80005e52:	0c 6c       	and	r12,r6
80005e54:	80 00       	ld.sh	r0,r0[0x0]
80005e56:	50 72       	stdsp	sp[0x1c],r2
80005e58:	80 00       	ld.sh	r0,r0[0x0]
80005e5a:	50 a6       	stdsp	sp[0x28],r6
80005e5c:	00 00       	add	r0,r0
80005e5e:	0c c0       	st.b	r6++,r0
80005e60:	80 00       	ld.sh	r0,r0[0x0]
80005e62:	50 56       	stdsp	sp[0x14],r6
80005e64:	00 00       	add	r0,r0
80005e66:	0c 98       	mov	r8,r6
80005e68:	80 00       	ld.sh	r0,r0[0x0]
80005e6a:	5c f0       	rol	r0

80005e6c <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
80005e6c:	eb cd 40 f8 	pushm	r3-r7,lr
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80005e70:	49 67       	lddpc	r7,80005ec8 <prvIdleTask+0x5c>
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
80005e72:	49 74       	lddpc	r4,80005ecc <prvIdleTask+0x60>

				taskENTER_CRITICAL();
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					--uxCurrentNumberOfTasks;
80005e74:	49 73       	lddpc	r3,80005ed0 <prvIdleTask+0x64>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80005e76:	49 85       	lddpc	r5,80005ed4 <prvIdleTask+0x68>
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80005e78:	6e 08       	ld.w	r8,r7[0x0]
80005e7a:	58 08       	cp.w	r8,0
80005e7c:	c1 e0       	breq	80005eb8 <prvIdleTask+0x4c>
		{
			vTaskSuspendAll();
80005e7e:	f0 1f 00 17 	mcall	80005ed8 <prvIdleTask+0x6c>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
80005e82:	68 06       	ld.w	r6,r4[0x0]
			xTaskResumeAll();
80005e84:	f0 1f 00 16 	mcall	80005edc <prvIdleTask+0x70>

			if( xListIsEmpty == pdFALSE )
80005e88:	58 06       	cp.w	r6,0
80005e8a:	c1 70       	breq	80005eb8 <prvIdleTask+0x4c>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
80005e8c:	f0 1f 00 15 	mcall	80005ee0 <prvIdleTask+0x74>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
80005e90:	68 38       	ld.w	r8,r4[0xc]
80005e92:	70 36       	ld.w	r6,r8[0xc]
					vListRemove( &( pxTCB->xGenericListItem ) );
80005e94:	ec cc ff fc 	sub	r12,r6,-4
80005e98:	f0 1f 00 13 	mcall	80005ee4 <prvIdleTask+0x78>
					--uxCurrentNumberOfTasks;
80005e9c:	66 08       	ld.w	r8,r3[0x0]
80005e9e:	20 18       	sub	r8,1
80005ea0:	87 08       	st.w	r3[0x0],r8
					--uxTasksDeleted;
80005ea2:	6e 08       	ld.w	r8,r7[0x0]
80005ea4:	20 18       	sub	r8,1
80005ea6:	8f 08       	st.w	r7[0x0],r8
				}
				taskEXIT_CRITICAL();
80005ea8:	f0 1f 00 10 	mcall	80005ee8 <prvIdleTask+0x7c>

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
80005eac:	6c cc       	ld.w	r12,r6[0x30]
80005eae:	f0 1f 00 10 	mcall	80005eec <prvIdleTask+0x80>
		vPortFree( pxTCB );
80005eb2:	0c 9c       	mov	r12,r6
80005eb4:	f0 1f 00 0e 	mcall	80005eec <prvIdleTask+0x80>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80005eb8:	6a 08       	ld.w	r8,r5[0x0]
80005eba:	58 18       	cp.w	r8,1
80005ebc:	e0 88 00 03 	brls	80005ec2 <prvIdleTask+0x56>
			{
				taskYIELD();
80005ec0:	d7 33       	scall
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
80005ec2:	f0 1f 00 0c 	mcall	80005ef0 <prvIdleTask+0x84>
		}
		#endif
	}
80005ec6:	cd 9b       	rjmp	80005e78 <prvIdleTask+0xc>
80005ec8:	00 00       	add	r0,r0
80005eca:	0b ac       	ld.ub	r12,r5[0x2]
80005ecc:	00 00       	add	r0,r0
80005ece:	0c 58       	eor	r8,r6
80005ed0:	00 00       	add	r0,r0
80005ed2:	0c b8       	st.h	r6++,r8
80005ed4:	00 00       	add	r0,r0
80005ed6:	0b b8       	ld.ub	r8,r5[0x3]
80005ed8:	80 00       	ld.sh	r0,r0[0x0]
80005eda:	58 4c       	cp.w	r12,4
80005edc:	80 00       	ld.sh	r0,r0[0x0]
80005ede:	5c 08       	acr	r8
80005ee0:	80 00       	ld.sh	r0,r0[0x0]
80005ee2:	51 60       	stdsp	sp[0x58],r0
80005ee4:	80 00       	ld.sh	r0,r0[0x0]
80005ee6:	50 a6       	stdsp	sp[0x28],r6
80005ee8:	80 00       	ld.sh	r0,r0[0x0]
80005eea:	52 6c       	stdsp	sp[0x98],r12
80005eec:	80 00       	ld.sh	r0,r0[0x0]
80005eee:	53 a4       	stdsp	sp[0xe8],r4
80005ef0:	80 00       	ld.sh	r0,r0[0x0]
80005ef2:	20 2c       	sub	r12,2

80005ef4 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
80005ef4:	d4 31       	pushm	r0-r7,lr
80005ef6:	20 1d       	sub	sp,4
80005ef8:	fa c4 ff d8 	sub	r4,sp,-40
80005efc:	50 0c       	stdsp	sp[0x0],r12
80005efe:	16 91       	mov	r1,r11
80005f00:	14 97       	mov	r7,r10
80005f02:	12 90       	mov	r0,r9
80005f04:	10 93       	mov	r3,r8
80005f06:	68 02       	ld.w	r2,r4[0x0]
80005f08:	68 16       	ld.w	r6,r4[0x4]
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
80005f0a:	34 8c       	mov	r12,72
80005f0c:	f0 1f 00 5c 	mcall	8000607c <xTaskGenericCreate+0x188>
80005f10:	18 95       	mov	r5,r12

	if( pxNewTCB != NULL )
80005f12:	c0 31       	brne	80005f18 <xTaskGenericCreate+0x24>
80005f14:	3f fc       	mov	r12,-1
80005f16:	ca f8       	rjmp	80006074 <xTaskGenericCreate+0x180>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80005f18:	58 06       	cp.w	r6,0
80005f1a:	e0 81 00 af 	brne	80006078 <xTaskGenericCreate+0x184>
80005f1e:	0e 9c       	mov	r12,r7
80005f20:	5c 7c       	castu.h	r12
80005f22:	a3 6c       	lsl	r12,0x2
80005f24:	f0 1f 00 56 	mcall	8000607c <xTaskGenericCreate+0x188>
80005f28:	18 96       	mov	r6,r12
80005f2a:	8b cc       	st.w	r5[0x30],r12

		if( pxNewTCB->pxStack == NULL )
80005f2c:	c0 61       	brne	80005f38 <xTaskGenericCreate+0x44>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
80005f2e:	0a 9c       	mov	r12,r5
80005f30:	f0 1f 00 54 	mcall	80006080 <xTaskGenericCreate+0x18c>
80005f34:	3f fc       	mov	r12,-1
80005f36:	c9 f8       	rjmp	80006074 <xTaskGenericCreate+0x180>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
80005f38:	5c 77       	castu.h	r7
80005f3a:	ee 0a 15 02 	lsl	r10,r7,0x2
80005f3e:	e0 6b 00 a5 	mov	r11,165
80005f42:	0c 9c       	mov	r12,r6
80005f44:	f0 1f 00 50 	mcall	80006084 <xTaskGenericCreate+0x190>
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~portBYTE_ALIGNMENT_MASK  ) );
80005f48:	ee c6 00 01 	sub	r6,r7,1
80005f4c:	6a c8       	ld.w	r8,r5[0x30]
80005f4e:	f0 06 00 26 	add	r6,r8,r6<<0x2
80005f52:	e0 16 ff fc 	andl	r6,0xfffc
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
80005f56:	31 0a       	mov	r10,16
80005f58:	02 9b       	mov	r11,r1
80005f5a:	ea cc ff cc 	sub	r12,r5,-52
80005f5e:	f0 1f 00 4b 	mcall	80006088 <xTaskGenericCreate+0x194>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
80005f62:	30 08       	mov	r8,0
80005f64:	eb 68 00 43 	st.b	r5[67],r8
80005f68:	58 73       	cp.w	r3,7
80005f6a:	e6 07 17 80 	movls	r7,r3
80005f6e:	f9 b7 0b 07 	movhi	r7,7
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
80005f72:	8b b7       	st.w	r5[0x2c],r7
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
80005f74:	eb 47 00 44 	st.w	r5[68],r7
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
80005f78:	ea c4 ff fc 	sub	r4,r5,-4
80005f7c:	08 9c       	mov	r12,r4
80005f7e:	f0 1f 00 44 	mcall	8000608c <xTaskGenericCreate+0x198>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
80005f82:	ea cc ff e8 	sub	r12,r5,-24
80005f86:	f0 1f 00 42 	mcall	8000608c <xTaskGenericCreate+0x198>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
80005f8a:	8b 45       	st.w	r5[0x10],r5

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
80005f8c:	ee 07 11 08 	rsub	r7,r7,8
80005f90:	8b 67       	st.w	r5[0x18],r7
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
80005f92:	8b 95       	st.w	r5[0x24],r5
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
80005f94:	00 9a       	mov	r10,r0
80005f96:	40 0b       	lddsp	r11,sp[0x0]
80005f98:	0c 9c       	mov	r12,r6
80005f9a:	f0 1f 00 3e 	mcall	80006090 <xTaskGenericCreate+0x19c>
80005f9e:	8b 0c       	st.w	r5[0x0],r12
		if( ( void * ) pxCreatedTask != NULL )
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
80005fa0:	58 02       	cp.w	r2,0
80005fa2:	e5 f5 1a 00 	st.wne	r2[0x0],r5
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
80005fa6:	f0 1f 00 3c 	mcall	80006094 <xTaskGenericCreate+0x1a0>
		{
			uxCurrentNumberOfTasks++;
80005faa:	4b c8       	lddpc	r8,80006098 <xTaskGenericCreate+0x1a4>
80005fac:	70 09       	ld.w	r9,r8[0x0]
80005fae:	2f f9       	sub	r9,-1
80005fb0:	91 09       	st.w	r8[0x0],r9
			if( pxCurrentTCB == NULL )
80005fb2:	4b b8       	lddpc	r8,8000609c <xTaskGenericCreate+0x1a8>
80005fb4:	70 08       	ld.w	r8,r8[0x0]
80005fb6:	58 08       	cp.w	r8,0
80005fb8:	c2 61       	brne	80006004 <xTaskGenericCreate+0x110>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
80005fba:	4b 98       	lddpc	r8,8000609c <xTaskGenericCreate+0x1a8>
80005fbc:	91 05       	st.w	r8[0x0],r5

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
80005fbe:	4b 78       	lddpc	r8,80006098 <xTaskGenericCreate+0x1a4>
80005fc0:	70 08       	ld.w	r8,r8[0x0]
80005fc2:	58 18       	cp.w	r8,1
80005fc4:	c2 b1       	brne	8000601a <xTaskGenericCreate+0x126>
80005fc6:	4b 77       	lddpc	r7,800060a0 <xTaskGenericCreate+0x1ac>

/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
80005fc8:	ee c6 ff 60 	sub	r6,r7,-160
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
80005fcc:	0e 9c       	mov	r12,r7
80005fce:	f0 1f 00 36 	mcall	800060a4 <xTaskGenericCreate+0x1b0>
80005fd2:	2e c7       	sub	r7,-20

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
80005fd4:	0c 37       	cp.w	r7,r6
80005fd6:	cf b1       	brne	80005fcc <xTaskGenericCreate+0xd8>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
80005fd8:	4b 47       	lddpc	r7,800060a8 <xTaskGenericCreate+0x1b4>
80005fda:	0e 9c       	mov	r12,r7
80005fdc:	f0 1f 00 32 	mcall	800060a4 <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
80005fe0:	4b 36       	lddpc	r6,800060ac <xTaskGenericCreate+0x1b8>
80005fe2:	0c 9c       	mov	r12,r6
80005fe4:	f0 1f 00 30 	mcall	800060a4 <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xPendingReadyList );
80005fe8:	4b 2c       	lddpc	r12,800060b0 <xTaskGenericCreate+0x1bc>
80005fea:	f0 1f 00 2f 	mcall	800060a4 <xTaskGenericCreate+0x1b0>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
80005fee:	4b 2c       	lddpc	r12,800060b4 <xTaskGenericCreate+0x1c0>
80005ff0:	f0 1f 00 2d 	mcall	800060a4 <xTaskGenericCreate+0x1b0>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
80005ff4:	4b 1c       	lddpc	r12,800060b8 <xTaskGenericCreate+0x1c4>
80005ff6:	f0 1f 00 2c 	mcall	800060a4 <xTaskGenericCreate+0x1b0>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
80005ffa:	4b 18       	lddpc	r8,800060bc <xTaskGenericCreate+0x1c8>
80005ffc:	91 07       	st.w	r8[0x0],r7
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
80005ffe:	4b 18       	lddpc	r8,800060c0 <xTaskGenericCreate+0x1cc>
80006000:	91 06       	st.w	r8[0x0],r6
80006002:	c0 c8       	rjmp	8000601a <xTaskGenericCreate+0x126>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
80006004:	4b 08       	lddpc	r8,800060c4 <xTaskGenericCreate+0x1d0>
80006006:	70 08       	ld.w	r8,r8[0x0]
80006008:	58 08       	cp.w	r8,0
8000600a:	c0 81       	brne	8000601a <xTaskGenericCreate+0x126>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
8000600c:	4a 48       	lddpc	r8,8000609c <xTaskGenericCreate+0x1a8>
8000600e:	70 08       	ld.w	r8,r8[0x0]
80006010:	70 b8       	ld.w	r8,r8[0x2c]
80006012:	10 33       	cp.w	r3,r8
80006014:	c0 33       	brcs	8000601a <xTaskGenericCreate+0x126>
					{
						pxCurrentTCB = pxNewTCB;
80006016:	4a 28       	lddpc	r8,8000609c <xTaskGenericCreate+0x1a8>
80006018:	91 05       	st.w	r8[0x0],r5
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
8000601a:	6a b8       	ld.w	r8,r5[0x2c]
8000601c:	4a b9       	lddpc	r9,800060c8 <xTaskGenericCreate+0x1d4>
8000601e:	72 09       	ld.w	r9,r9[0x0]
80006020:	12 38       	cp.w	r8,r9
80006022:	e0 88 00 04 	brls	8000602a <xTaskGenericCreate+0x136>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
80006026:	4a 99       	lddpc	r9,800060c8 <xTaskGenericCreate+0x1d4>
80006028:	93 08       	st.w	r9[0x0],r8
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
8000602a:	4a 98       	lddpc	r8,800060cc <xTaskGenericCreate+0x1d8>
8000602c:	70 09       	ld.w	r9,r8[0x0]
8000602e:	2f f9       	sub	r9,-1
80006030:	91 09       	st.w	r8[0x0],r9

			prvAddTaskToReadyQueue( pxNewTCB );
80006032:	6a b8       	ld.w	r8,r5[0x2c]
80006034:	4a 79       	lddpc	r9,800060d0 <xTaskGenericCreate+0x1dc>
80006036:	72 09       	ld.w	r9,r9[0x0]
80006038:	12 38       	cp.w	r8,r9
8000603a:	e0 88 00 04 	brls	80006042 <xTaskGenericCreate+0x14e>
8000603e:	4a 59       	lddpc	r9,800060d0 <xTaskGenericCreate+0x1dc>
80006040:	93 08       	st.w	r9[0x0],r8
80006042:	6a bc       	ld.w	r12,r5[0x2c]
80006044:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006048:	08 9b       	mov	r11,r4
8000604a:	49 68       	lddpc	r8,800060a0 <xTaskGenericCreate+0x1ac>
8000604c:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80006050:	f0 1f 00 21 	mcall	800060d4 <xTaskGenericCreate+0x1e0>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
80006054:	f0 1f 00 21 	mcall	800060d8 <xTaskGenericCreate+0x1e4>
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
80006058:	49 b8       	lddpc	r8,800060c4 <xTaskGenericCreate+0x1d0>
8000605a:	70 08       	ld.w	r8,r8[0x0]
8000605c:	58 08       	cp.w	r8,0
8000605e:	c0 a0       	breq	80006072 <xTaskGenericCreate+0x17e>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
80006060:	48 f8       	lddpc	r8,8000609c <xTaskGenericCreate+0x1a8>
80006062:	70 08       	ld.w	r8,r8[0x0]
80006064:	70 b8       	ld.w	r8,r8[0x2c]
80006066:	10 33       	cp.w	r3,r8
80006068:	e0 88 00 05 	brls	80006072 <xTaskGenericCreate+0x17e>
			{
				portYIELD_WITHIN_API();
8000606c:	d7 33       	scall
8000606e:	30 1c       	mov	r12,1
80006070:	c0 28       	rjmp	80006074 <xTaskGenericCreate+0x180>
80006072:	30 1c       	mov	r12,1
			}
		}
	}

	return xReturn;
}
80006074:	2f fd       	sub	sp,-4
80006076:	d8 32       	popm	r0-r7,pc
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80006078:	99 c6       	st.w	r12[0x30],r6
8000607a:	c5 fb       	rjmp	80005f38 <xTaskGenericCreate+0x44>
8000607c:	80 00       	ld.sh	r0,r0[0x0]
8000607e:	53 cc       	stdsp	sp[0xf0],r12
80006080:	80 00       	ld.sh	r0,r0[0x0]
80006082:	53 a4       	stdsp	sp[0xe8],r4
80006084:	80 00       	ld.sh	r0,r0[0x0]
80006086:	6b 22       	ld.w	r2,r5[0x48]
80006088:	80 00       	ld.sh	r0,r0[0x0]
8000608a:	6e 4c       	ld.w	r12,r7[0x10]
8000608c:	80 00       	ld.sh	r0,r0[0x0]
8000608e:	50 50       	stdsp	sp[0x14],r0
80006090:	80 00       	ld.sh	r0,r0[0x0]
80006092:	50 cc       	stdsp	sp[0x30],r12
80006094:	80 00       	ld.sh	r0,r0[0x0]
80006096:	51 60       	stdsp	sp[0x58],r0
80006098:	00 00       	add	r0,r0
8000609a:	0c b8       	st.h	r6++,r8
8000609c:	00 00       	add	r0,r0
8000609e:	0c 6c       	and	r12,r6
800060a0:	00 00       	add	r0,r0
800060a2:	0b b8       	ld.ub	r8,r5[0x3]
800060a4:	80 00       	ld.sh	r0,r0[0x0]
800060a6:	50 3c       	stdsp	sp[0xc],r12
800060a8:	00 00       	add	r0,r0
800060aa:	0c 84       	andn	r4,r6
800060ac:	00 00       	add	r0,r0
800060ae:	0c a0       	st.w	r6++,r0
800060b0:	00 00       	add	r0,r0
800060b2:	0c 70       	tst	r0,r6
800060b4:	00 00       	add	r0,r0
800060b6:	0c 58       	eor	r8,r6
800060b8:	00 00       	add	r0,r0
800060ba:	0c c0       	st.b	r6++,r0
800060bc:	00 00       	add	r0,r0
800060be:	0b a4       	ld.ub	r4,r5[0x2]
800060c0:	00 00       	add	r0,r0
800060c2:	0b b4       	ld.ub	r4,r5[0x3]
800060c4:	00 00       	add	r0,r0
800060c6:	0b a8       	ld.ub	r8,r5[0x2]
800060c8:	00 00       	add	r0,r0
800060ca:	0b a0       	ld.ub	r0,r5[0x2]
800060cc:	00 00       	add	r0,r0
800060ce:	0c b4       	st.h	r6++,r4
800060d0:	00 00       	add	r0,r0
800060d2:	0c d4       	st.w	--r6,r4
800060d4:	80 00       	ld.sh	r0,r0[0x0]
800060d6:	50 56       	stdsp	sp[0x14],r6
800060d8:	80 00       	ld.sh	r0,r0[0x0]
800060da:	52 6c       	stdsp	sp[0x98],r12

800060dc <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
800060dc:	d4 01       	pushm	lr
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
800060de:	30 09       	mov	r9,0
800060e0:	1a d9       	st.w	--sp,r9
800060e2:	1a d9       	st.w	--sp,r9
800060e4:	1a d9       	st.w	--sp,r9
800060e6:	12 98       	mov	r8,r9
800060e8:	e0 6a 01 00 	mov	r10,256
800060ec:	48 9b       	lddpc	r11,80006110 <vTaskStartScheduler+0x34>
800060ee:	48 ac       	lddpc	r12,80006114 <vTaskStartScheduler+0x38>
800060f0:	f0 1f 00 0a 	mcall	80006118 <vTaskStartScheduler+0x3c>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
800060f4:	2f dd       	sub	sp,-12
800060f6:	58 1c       	cp.w	r12,1
800060f8:	c0 a1       	brne	8000610c <vTaskStartScheduler+0x30>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
800060fa:	d3 03       	ssrf	0x10

		xSchedulerRunning = pdTRUE;
800060fc:	30 19       	mov	r9,1
800060fe:	48 88       	lddpc	r8,8000611c <vTaskStartScheduler+0x40>
80006100:	91 09       	st.w	r8[0x0],r9
		xTickCount = ( portTickType ) 0;
80006102:	30 09       	mov	r9,0
80006104:	48 78       	lddpc	r8,80006120 <vTaskStartScheduler+0x44>
80006106:	91 09       	st.w	r8[0x0],r9
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
80006108:	f0 1f 00 07 	mcall	80006124 <vTaskStartScheduler+0x48>
8000610c:	d8 02       	popm	pc
8000610e:	00 00       	add	r0,r0
80006110:	80 00       	ld.sh	r0,r0[0x0]
80006112:	cd 14       	brge	800060b4 <xTaskGenericCreate+0x1c0>
80006114:	80 00       	ld.sh	r0,r0[0x0]
80006116:	5e 6c       	retmi	r12
80006118:	80 00       	ld.sh	r0,r0[0x0]
8000611a:	5e f4       	retal	r4
8000611c:	00 00       	add	r0,r0
8000611e:	0b a8       	ld.ub	r8,r5[0x2]
80006120:	00 00       	add	r0,r0
80006122:	0c 98       	mov	r8,r6
80006124:	80 00       	ld.sh	r0,r0[0x0]
80006126:	51 70       	stdsp	sp[0x5c],r0

80006128 <PrintChar>:
	
static void task_log(void * pvParameters);

char *  PrintChar(char c, char * str)
{
	*str++ = c;
80006128:	16 cc       	st.b	r11++,r12
	return str;
}
8000612a:	5e fb       	retal	r11

8000612c <PrintHex>:
	
	return str;
}

char * PrintHex(int i,char len, char * str)
{
8000612c:	eb cd 40 c0 	pushm	r6-r7,lr
80006130:	20 3d       	sub	sp,12
80006132:	18 98       	mov	r8,r12
	char * p = str;
	char s[12];
	memset(s, 0 , 12);
80006134:	30 06       	mov	r6,0
80006136:	30 07       	mov	r7,0
80006138:	fa e7 00 00 	st.d	sp[0],r6
8000613c:	30 0c       	mov	r12,0
8000613e:	50 2c       	stdsp	sp[0x8],r12
	int cnt=0;
	
	if(i)
80006140:	58 08       	cp.w	r8,0
80006142:	c1 30       	breq	80006168 <PrintHex+0x3c>
80006144:	18 99       	mov	r9,r12
	while(i)
	{
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
80006146:	1a 9c       	mov	r12,sp
80006148:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
8000614c:	58 9e       	cp.w	lr,9
8000614e:	e0 8a 00 04 	brle	80006156 <PrintHex+0x2a>
80006152:	2c 9e       	sub	lr,-55
80006154:	c0 48       	rjmp	8000615c <PrintHex+0x30>
80006156:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
8000615a:	2d 0e       	sub	lr,-48
8000615c:	f8 09 0b 0e 	st.b	r12[r9],lr
80006160:	2f f9       	sub	r9,-1
		i = (i >> 4 ) & 0x0FFFFFFF;
80006162:	a5 88       	lsr	r8,0x4
	char s[12];
	memset(s, 0 , 12);
	int cnt=0;
	
	if(i)
	while(i)
80006164:	cf 21       	brne	80006148 <PrintHex+0x1c>
80006166:	c0 48       	rjmp	8000616e <PrintHex+0x42>
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
		i = (i >> 4 ) & 0x0FFFFFFF;
		//i >>= 4
	}
	else
	s[cnt++] = '0';
80006168:	33 08       	mov	r8,48
8000616a:	ba 88       	st.b	sp[0x0],r8
8000616c:	30 19       	mov	r9,1
	
	if(len - cnt > 0 )
8000616e:	f6 09 01 08 	sub	r8,r11,r9
80006172:	58 08       	cp.w	r8,0
80006174:	e0 8a 00 13 	brle	8000619a <PrintHex+0x6e>
	{
		char num = len - cnt;
80006178:	12 1b       	sub	r11,r9
8000617a:	f9 db c0 08 	bfextu	r12,r11,0x0,0x8
		for(int i = 0; i < num; i++)
8000617e:	18 9e       	mov	lr,r12
80006180:	58 0c       	cp.w	r12,0
80006182:	e0 8a 00 0c 	brle	8000619a <PrintHex+0x6e>
80006186:	1a 9b       	mov	r11,sp
80006188:	12 0b       	add	r11,r9
8000618a:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
8000618c:	33 07       	mov	r7,48
8000618e:	16 c7       	st.b	r11++,r7
	s[cnt++] = '0';
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80006190:	2f f8       	sub	r8,-1
80006192:	1c 38       	cp.w	r8,lr
80006194:	cf d5       	brlt	8000618e <PrintHex+0x62>
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
80006196:	f8 09 00 09 	add	r9,r12,r9
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
8000619a:	f2 c8 ff ff 	sub	r8,r9,-1
	s[cnt++] = '0';
	
	while(cnt>0)
8000619e:	f0 cb ff ff 	sub	r11,r8,-1
800061a2:	58 0b       	cp.w	r11,0
800061a4:	e0 8a 00 19 	brle	800061d6 <PrintHex+0xaa>
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
800061a8:	fa cb ff f4 	sub	r11,sp,-12
800061ac:	f6 09 00 09 	add	r9,r11,r9
800061b0:	37 8b       	mov	r11,120
800061b2:	f3 6b ff f4 	st.b	r9[-12],r11
	s[cnt++] = '0';
800061b6:	fa c9 ff f4 	sub	r9,sp,-12
800061ba:	10 09       	add	r9,r8
800061bc:	33 0b       	mov	r11,48
800061be:	f3 6b ff f4 	st.b	r9[-12],r11
800061c2:	fa 08 00 08 	add	r8,sp,r8
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
800061c6:	fa ce 00 01 	sub	lr,sp,1
800061ca:	14 99       	mov	r9,r10
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
	*p++ = s[--cnt];
800061cc:	11 8b       	ld.ub	r11,r8[0x0]
800061ce:	12 cb       	st.b	r9++,r11
800061d0:	20 18       	sub	r8,1
	}
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
800061d2:	1c 38       	cp.w	r8,lr
800061d4:	cf c1       	brne	800061cc <PrintHex+0xa0>
	*p++ = s[--cnt];
		
	return str;
}
800061d6:	14 9c       	mov	r12,r10
800061d8:	2f dd       	sub	sp,-12
800061da:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

800061de <PrintDec>:
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
{
800061de:	d4 21       	pushm	r4-r7,lr
800061e0:	20 3d       	sub	sp,12
800061e2:	18 98       	mov	r8,r12
	char * p = str;
	
	int sign = i>=0 ? 0 : 1;
	char s[10];
	memset(s, 0 , 10);
800061e4:	30 06       	mov	r6,0
800061e6:	30 07       	mov	r7,0
800061e8:	fa e7 00 00 	st.d	sp[0],r6
800061ec:	30 0c       	mov	r12,0
800061ee:	ba 4c       	st.h	sp[0x8],r12
	int cnt=0;
	if(sign)
800061f0:	58 08       	cp.w	r8,0
800061f2:	c0 35       	brlt	800061f8 <PrintDec+0x1a>
800061f4:	14 97       	mov	r7,r10
800061f6:	c0 58       	rjmp	80006200 <PrintDec+0x22>
	{
		*p++ = '-';
800061f8:	14 97       	mov	r7,r10
800061fa:	32 d9       	mov	r9,45
800061fc:	0e c9       	st.b	r7++,r9
		i = -i;
800061fe:	5c 38       	neg	r8
	}
	
	if(i == 0 )s[cnt++] = '0';
80006200:	58 08       	cp.w	r8,0
80006202:	c0 51       	brne	8000620c <PrintDec+0x2e>
80006204:	33 08       	mov	r8,48
80006206:	ba 88       	st.b	sp[0x0],r8
80006208:	30 1e       	mov	lr,1
8000620a:	c2 f8       	rjmp	80006268 <PrintDec+0x8a>
	
	int ten = i%10;
8000620c:	e0 65 66 67 	mov	r5,26215
80006210:	ea 15 66 66 	orh	r5,0x6666
80006214:	f0 05 04 44 	muls.d	r4,r8,r5
80006218:	ea 0c 14 02 	asr	r12,r5,0x2
8000621c:	f0 09 14 1f 	asr	r9,r8,0x1f
80006220:	f8 09 01 09 	sub	r9,r12,r9
80006224:	f2 09 00 29 	add	r9,r9,r9<<0x2
80006228:	f0 09 01 19 	sub	r9,r8,r9<<0x1
8000622c:	30 0e       	mov	lr,0
	while(i)
	{
		s[cnt] = ten+'0';
8000622e:	1a 9c       	mov	r12,sp
		cnt++;
		i /= 10;
80006230:	e0 66 66 67 	mov	r6,26215
80006234:	ea 16 66 66 	orh	r6,0x6666
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
	{
		s[cnt] = ten+'0';
80006238:	2d 09       	sub	r9,-48
8000623a:	f8 0e 0b 09 	st.b	r12[lr],r9
		cnt++;
8000623e:	2f fe       	sub	lr,-1
		i /= 10;
80006240:	f0 06 04 44 	muls.d	r4,r8,r6
80006244:	ea 09 14 02 	asr	r9,r5,0x2
80006248:	bf 58       	asr	r8,0x1f
8000624a:	f2 08 01 08 	sub	r8,r9,r8
		ten = i%10;
8000624e:	f0 06 04 44 	muls.d	r4,r8,r6
80006252:	ea 09 14 02 	asr	r9,r5,0x2
80006256:	f0 05 14 1f 	asr	r5,r8,0x1f
8000625a:	0a 19       	sub	r9,r5
8000625c:	f2 09 00 29 	add	r9,r9,r9<<0x2
80006260:	f0 09 01 19 	sub	r9,r8,r9<<0x1
	}
	
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
80006264:	58 08       	cp.w	r8,0
80006266:	ce 91       	brne	80006238 <PrintDec+0x5a>
		cnt++;
		i /= 10;
		ten = i%10;
	}
	
	if(len - cnt > 0 )
80006268:	f6 0e 01 08 	sub	r8,r11,lr
8000626c:	58 08       	cp.w	r8,0
8000626e:	e0 89 00 06 	brgt	8000627a <PrintDec+0x9c>
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80006272:	58 0e       	cp.w	lr,0
80006274:	e0 89 00 14 	brgt	8000629c <PrintDec+0xbe>
80006278:	c1 d8       	rjmp	800062b2 <PrintDec+0xd4>
		ten = i%10;
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
8000627a:	1c 1b       	sub	r11,lr
8000627c:	5c 5b       	castu.b	r11
		for(int i = 0; i < num; i++)
8000627e:	16 9c       	mov	r12,r11
80006280:	58 0b       	cp.w	r11,0
80006282:	fe 9a ff f8 	brle	80006272 <PrintDec+0x94>
80006286:	1a 99       	mov	r9,sp
80006288:	1c 09       	add	r9,lr
8000628a:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
8000628c:	33 06       	mov	r6,48
8000628e:	12 c6       	st.b	r9++,r6
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80006290:	2f f8       	sub	r8,-1
80006292:	18 38       	cp.w	r8,r12
80006294:	cf d5       	brlt	8000628e <PrintDec+0xb0>
{
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
80006296:	f6 0e 00 0e 	add	lr,r11,lr
8000629a:	ce cb       	rjmp	80006272 <PrintDec+0x94>
8000629c:	fa c8 ff f4 	sub	r8,sp,-12
800062a0:	1c 08       	add	r8,lr
800062a2:	20 d8       	sub	r8,13
800062a4:	fa cb 00 01 	sub	r11,sp,1
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
	*p++ = s[--cnt];
800062a8:	11 89       	ld.ub	r9,r8[0x0]
800062aa:	0e c9       	st.b	r7++,r9
800062ac:	20 18       	sub	r8,1
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
800062ae:	16 38       	cp.w	r8,r11
800062b0:	cf c1       	brne	800062a8 <PrintDec+0xca>
	*p++ = s[--cnt];
	
	return str;
}
800062b2:	14 9c       	mov	r12,r10
800062b4:	2f dd       	sub	sp,-12
800062b6:	d8 22       	popm	r4-r7,pc

800062b8 <log>:
	,  NULL );
	
}

int log(char * content, ...)
{
800062b8:	d4 31       	pushm	r0-r7,lr
800062ba:	fa cd 02 08 	sub	sp,sp,520
800062be:	18 97       	mov	r7,r12
	
	
	char logTmp[MAX_LOG_LINE_SIZE];
	memset(logTmp, '\0', MAX_LOG_LINE_SIZE);	
800062c0:	e0 6a 01 00 	mov	r10,256
800062c4:	30 0b       	mov	r11,0
800062c6:	fa cc fe f8 	sub	r12,sp,-264
800062ca:	f0 1f 00 4e 	mcall	80006400 <log+0x148>
	,  tskLOG_PRIORITY
	,  NULL );
	
}

int log(char * content, ...)
800062ce:	fa c4 fd d4 	sub	r4,sp,-556
800062d2:	30 0a       	mov	r10,0
800062d4:	50 0a       	stdsp	sp[0x0],r10
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
800062d6:	fa c3 ff fc 	sub	r3,sp,-4
800062da:	e0 61 01 00 	mov	r1,256
800062de:	14 90       	mov	r0,r10
			
					if(*str == '%')
800062e0:	32 52       	mov	r2,37
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
800062e2:	fa c6 fe f8 	sub	r6,sp,-264
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
800062e6:	02 9a       	mov	r10,r1
800062e8:	00 9b       	mov	r11,r0
800062ea:	06 9c       	mov	r12,r3
800062ec:	f0 1f 00 45 	mcall	80006400 <log+0x148>
			
					if(*str == '%')
800062f0:	0f 88       	ld.ub	r8,r7[0x0]
800062f2:	e4 08 18 00 	cp.b	r8,r2
800062f6:	c5 71       	brne	800063a4 <log+0xec>
					{
						static char lench = 0;
						lench =*(str + 1);
800062f8:	ee c8 ff ff 	sub	r8,r7,-1
800062fc:	11 89       	ld.ub	r9,r8[0x0]
800062fe:	4c 2a       	lddpc	r10,80006404 <log+0x14c>
80006300:	b4 89       	st.b	r10[0x0],r9
						if((lench >= '0') &&  (lench <= '9'))
80006302:	23 09       	sub	r9,48
80006304:	30 9a       	mov	r10,9
80006306:	f4 09 18 00 	cp.b	r9,r10
8000630a:	ee 08 17 b0 	movhi	r8,r7
						{
							len = *(++str) - '0';
8000630e:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
80006312:	f7 b9 08 30 	subls	r9,48
80006316:	fb f9 8a 00 	st.wls	sp[0x0],r9
						}
						
						str++;
8000631a:	f0 c7 ff ff 	sub	r7,r8,-1
						
						switch(*(str))
8000631e:	0f 88       	ld.ub	r8,r7[0x0]
80006320:	22 58       	sub	r8,37
80006322:	e0 48 00 53 	cp.w	r8,83
80006326:	e0 8b 00 31 	brhi	80006388 <log+0xd0>
8000632a:	4b 89       	lddpc	r9,80006408 <log+0x150>
8000632c:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
						{
							case('i'):
							case('I'):
							case('d'):
							case('D'):
							x = va_arg(arg_ptr,int);
80006330:	e8 c5 ff fc 	sub	r5,r4,-4
							strTmp = PrintDec(x, len, strTmp);
80006334:	06 9a       	mov	r10,r3
80006336:	40 0b       	lddsp	r11,sp[0x0]
80006338:	5c 5b       	castu.b	r11
8000633a:	68 0c       	ld.w	r12,r4[0x0]
8000633c:	f0 1f 00 34 	mcall	8000640c <log+0x154>
							break;
80006340:	c2 98       	rjmp	80006392 <log+0xda>
							
							case('f')://浮点数输出
							case('F'):
							//f = va_arg(arg_ptr,int);
							//strTmp = PrintDec(x, len, strTmp);
							log("I need float.");
80006342:	4b 4c       	lddpc	r12,80006410 <log+0x158>
80006344:	f0 1f 00 34 	mcall	80006414 <log+0x15c>
80006348:	08 95       	mov	r5,r4
8000634a:	06 9c       	mov	r12,r3
							break;
8000634c:	c2 38       	rjmp	80006392 <log+0xda>
							
							
							case('x'):
							case('X'):
							x = va_arg(arg_ptr,int);
8000634e:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintHex(x,len, strTmp);
80006352:	06 9a       	mov	r10,r3
80006354:	40 0b       	lddsp	r11,sp[0x0]
80006356:	5c 5b       	castu.b	r11
80006358:	68 0c       	ld.w	r12,r4[0x0]
8000635a:	f0 1f 00 30 	mcall	80006418 <log+0x160>
8000635e:	06 9c       	mov	r12,r3
							break;
80006360:	c1 98       	rjmp	80006392 <log+0xda>
							
							case('c'):
							case('C'):
							y = va_arg(arg_ptr,int);
80006362:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintChar(y, strTmp);
80006366:	06 9b       	mov	r11,r3
80006368:	09 bc       	ld.ub	r12,r4[0x3]
8000636a:	f0 1f 00 2d 	mcall	8000641c <log+0x164>
8000636e:	06 9c       	mov	r12,r3
							break;
80006370:	c1 18       	rjmp	80006392 <log+0xda>
							
							case('s'):
							case('S'):
							strTmp = va_arg(arg_ptr,char*);
80006372:	e8 c5 ff fc 	sub	r5,r4,-4
80006376:	68 0c       	ld.w	r12,r4[0x0]
							//PrintStr(s);
							break;
80006378:	c0 d8       	rjmp	80006392 <log+0xda>
							
							case('%'):
							PrintChar('%', strTmp);
8000637a:	06 9b       	mov	r11,r3
8000637c:	32 5c       	mov	r12,37
8000637e:	f0 1f 00 28 	mcall	8000641c <log+0x164>
80006382:	08 95       	mov	r5,r4
80006384:	06 9c       	mov	r12,r3
							//PrintChar('%');
							break;
80006386:	c0 68       	rjmp	80006392 <log+0xda>
							
							default:
							log("I need relax.");
80006388:	4a 6c       	lddpc	r12,80006420 <log+0x168>
8000638a:	f0 1f 00 23 	mcall	80006414 <log+0x15c>
8000638e:	08 95       	mov	r5,r4
80006390:	06 9c       	mov	r12,r3
						}
						str++;
80006392:	2f f7       	sub	r7,-1
						
						length = sprintf(logTmp,"%s%s",logTmp,strTmp );
80006394:	1a dc       	st.w	--sp,r12
80006396:	1a d6       	st.w	--sp,r6
80006398:	4a 3b       	lddpc	r11,80006424 <log+0x16c>
8000639a:	0c 9c       	mov	r12,r6
8000639c:	f0 1f 00 23 	mcall	80006428 <log+0x170>
800063a0:	2f ed       	sub	sp,-8
800063a2:	c0 a8       	rjmp	800063b6 <log+0xfe>
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
800063a4:	2f f7       	sub	r7,-1
800063a6:	1a d8       	st.w	--sp,r8
800063a8:	1a d6       	st.w	--sp,r6
800063aa:	4a 1b       	lddpc	r11,8000642c <log+0x174>
800063ac:	0c 9c       	mov	r12,r6
800063ae:	f0 1f 00 1f 	mcall	80006428 <log+0x170>
800063b2:	08 95       	mov	r5,r4
800063b4:	2f ed       	sub	sp,-8
			
			
			
	}while(*str != '\0');
800063b6:	0f 89       	ld.ub	r9,r7[0x0]
800063b8:	30 08       	mov	r8,0
800063ba:	f0 09 18 00 	cp.b	r9,r8
800063be:	c0 30       	breq	800063c4 <log+0x10c>
800063c0:	0a 94       	mov	r4,r5
800063c2:	c9 2b       	rjmp	800062e6 <log+0x2e>
		
		
				
	va_end(arg_ptr);
	//while(1)		
	length = sprintf(logTmp,"%s\r\n",logTmp);
800063c4:	fa c7 fe f8 	sub	r7,sp,-264
800063c8:	1a d7       	st.w	--sp,r7
800063ca:	49 ab       	lddpc	r11,80006430 <log+0x178>
800063cc:	0e 9c       	mov	r12,r7
800063ce:	f0 1f 00 17 	mcall	80006428 <log+0x170>
	
	char * p = pvPortMalloc(length+1);
800063d2:	5c 5c       	castu.b	r12
800063d4:	f8 c6 ff ff 	sub	r6,r12,-1
800063d8:	0c 9c       	mov	r12,r6
800063da:	f0 1f 00 17 	mcall	80006434 <log+0x17c>
800063de:	54 2c       	stdsp	sp[0x108],r12
	memcpy(p, logTmp, length+1);
800063e0:	0c 9a       	mov	r10,r6
800063e2:	0e 9b       	mov	r11,r7
800063e4:	f0 1f 00 15 	mcall	80006438 <log+0x180>
	//
	//usart_write_line(EXAMPLE_USART, logTmp)
	
	xQueueSend( logQueue, &p, 5);
800063e8:	30 09       	mov	r9,0
800063ea:	30 5a       	mov	r10,5
800063ec:	fa cb fe f8 	sub	r11,sp,-264
800063f0:	49 38       	lddpc	r8,8000643c <log+0x184>
800063f2:	70 0c       	ld.w	r12,r8[0x0]
800063f4:	f0 1f 00 13 	mcall	80006440 <log+0x188>
800063f8:	2f fd       	sub	sp,-4
	
	
}
800063fa:	fe 3d fd f8 	sub	sp,-520
800063fe:	d8 32       	popm	r0-r7,pc
80006400:	80 00       	ld.sh	r0,r0[0x0]
80006402:	6b 22       	ld.w	r2,r5[0x48]
80006404:	00 00       	add	r0,r0
80006406:	0c d8       	st.w	--r6,r8
80006408:	80 00       	ld.sh	r0,r0[0x0]
8000640a:	cd 1c       	rcall	800065ac <_malloc_r+0x30>
8000640c:	80 00       	ld.sh	r0,r0[0x0]
8000640e:	61 de       	ld.w	lr,r0[0x74]
80006410:	80 00       	ld.sh	r0,r0[0x0]
80006412:	ce 78       	rjmp	800065e0 <_malloc_r+0x64>
80006414:	80 00       	ld.sh	r0,r0[0x0]
80006416:	62 b8       	ld.w	r8,r1[0x2c]
80006418:	80 00       	ld.sh	r0,r0[0x0]
8000641a:	61 2c       	ld.w	r12,r0[0x48]
8000641c:	80 00       	ld.sh	r0,r0[0x0]
8000641e:	61 28       	ld.w	r8,r0[0x48]
80006420:	80 00       	ld.sh	r0,r0[0x0]
80006422:	ce 88       	rjmp	800065f2 <_malloc_r+0x76>
80006424:	80 00       	ld.sh	r0,r0[0x0]
80006426:	ce 98       	rjmp	800065f8 <_malloc_r+0x7c>
80006428:	80 00       	ld.sh	r0,r0[0x0]
8000642a:	6e 10       	ld.w	r0,r7[0x4]
8000642c:	80 00       	ld.sh	r0,r0[0x0]
8000642e:	ce a0       	breq	80006402 <log+0x14a>
80006430:	80 00       	ld.sh	r0,r0[0x0]
80006432:	ce a8       	rjmp	80006606 <_malloc_r+0x8a>
80006434:	80 00       	ld.sh	r0,r0[0x0]
80006436:	53 cc       	stdsp	sp[0xf0],r12
80006438:	80 00       	ld.sh	r0,r0[0x0]
8000643a:	69 da       	ld.w	r10,r4[0x74]
8000643c:	00 00       	add	r0,r0
8000643e:	1f d0       	ld.ub	r0,pc[0x5]
80006440:	80 00       	ld.sh	r0,r0[0x0]
80006442:	56 80       	stdsp	sp[0x1a0],r0

80006444 <log_init>:
		
	return str;
}

void log_init(void)
{
80006444:	d4 01       	pushm	lr
		.stopbits     = USART_1_STOPBIT,
		.channelmode  = USART_NORMAL_CHMODE
	};

	// Assign GPIO to USART.
	gpio_enable_module(USART_GPIO_MAP,
80006446:	30 2b       	mov	r11,2
80006448:	48 fc       	lddpc	r12,80006484 <log_init+0x40>
8000644a:	f0 1f 00 10 	mcall	80006488 <log_init+0x44>
	sizeof(USART_GPIO_MAP) / sizeof(USART_GPIO_MAP[0]));

	// Initialize USART in RS232 mode.
	usart_init_rs232(EXAMPLE_USART, &USART_OPTIONS, EXAMPLE_TARGET_PBACLK_FREQ_HZ);			
8000644e:	e0 6a 36 00 	mov	r10,13824
80006452:	ea 1a 01 6e 	orh	r10,0x16e
80006456:	48 eb       	lddpc	r11,8000648c <log_init+0x48>
80006458:	fe 7c 18 00 	mov	r12,-59392
8000645c:	f0 1f 00 0d 	mcall	80006490 <log_init+0x4c>
			
	logQueue  = xQueueCreate(50, sizeof(char *));
80006460:	30 4b       	mov	r11,4
80006462:	33 2c       	mov	r12,50
80006464:	f0 1f 00 0c 	mcall	80006494 <log_init+0x50>
80006468:	48 c8       	lddpc	r8,80006498 <log_init+0x54>
8000646a:	91 0c       	st.w	r8[0x0],r12
	
	xTaskCreate(
8000646c:	30 09       	mov	r9,0
8000646e:	1a d9       	st.w	--sp,r9
80006470:	1a d9       	st.w	--sp,r9
80006472:	1a d9       	st.w	--sp,r9
80006474:	30 28       	mov	r8,2
80006476:	36 4a       	mov	r10,100
80006478:	48 9b       	lddpc	r11,8000649c <log_init+0x58>
8000647a:	48 ac       	lddpc	r12,800064a0 <log_init+0x5c>
8000647c:	f0 1f 00 0a 	mcall	800064a4 <log_init+0x60>
80006480:	2f dd       	sub	sp,-12
	,  100//384
	,  NULL
	,  tskLOG_PRIORITY
	,  NULL );
	
}
80006482:	d8 02       	popm	pc
80006484:	80 00       	ld.sh	r0,r0[0x0]
80006486:	ce b4       	brge	8000645c <log_init+0x18>
80006488:	80 00       	ld.sh	r0,r0[0x0]
8000648a:	47 3c       	lddsp	r12,sp[0x1cc]
8000648c:	80 00       	ld.sh	r0,r0[0x0]
8000648e:	ce 6c       	rcall	8000665a <_malloc_r+0xde>
80006490:	80 00       	ld.sh	r0,r0[0x0]
80006492:	4f 30       	lddpc	r0,8000665c <_malloc_r+0xe0>
80006494:	80 00       	ld.sh	r0,r0[0x0]
80006496:	57 d8       	stdsp	sp[0x1f4],r8
80006498:	00 00       	add	r0,r0
8000649a:	1f d0       	ld.ub	r0,pc[0x5]
8000649c:	80 00       	ld.sh	r0,r0[0x0]
8000649e:	ce b0       	breq	80006474 <log_init+0x30>
800064a0:	80 00       	ld.sh	r0,r0[0x0]
800064a2:	64 a8       	ld.w	r8,r2[0x28]
800064a4:	80 00       	ld.sh	r0,r0[0x0]
800064a6:	5e f4       	retal	r4

800064a8 <task_log>:
			////taskYIELD();
		//}
	}
//portTickType log_water_value =0;	
static void task_log(void * pvParameters)
{
800064a8:	eb cd 40 f8 	pushm	r3-r7,lr
800064ac:	20 1d       	sub	sp,4
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		//log_water_value = uxTaskGetStackHighWaterMark(NULL);
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
800064ae:	48 c7       	lddpc	r7,800064dc <task_log+0x34>
800064b0:	30 05       	mov	r5,0
800064b2:	3f f4       	mov	r4,-1
		{
			if( NULL != str)
			{
				usart_write_line(EXAMPLE_USART, str);
800064b4:	fe 73 18 00 	mov	r3,-59392
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		//log_water_value = uxTaskGetStackHighWaterMark(NULL);
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
800064b8:	0a 99       	mov	r9,r5
800064ba:	08 9a       	mov	r10,r4
800064bc:	1a 9b       	mov	r11,sp
800064be:	6e 0c       	ld.w	r12,r7[0x0]
800064c0:	f0 1f 00 08 	mcall	800064e0 <task_log+0x38>
800064c4:	58 1c       	cp.w	r12,1
800064c6:	cf 91       	brne	800064b8 <task_log+0x10>
		{
			if( NULL != str)
800064c8:	40 0b       	lddsp	r11,sp[0x0]
800064ca:	58 0b       	cp.w	r11,0
800064cc:	cf 60       	breq	800064b8 <task_log+0x10>
			{
				usart_write_line(EXAMPLE_USART, str);
800064ce:	06 9c       	mov	r12,r3
800064d0:	f0 1f 00 05 	mcall	800064e4 <task_log+0x3c>
				vPortFree(str);
800064d4:	40 0c       	lddsp	r12,sp[0x0]
800064d6:	f0 1f 00 05 	mcall	800064e8 <task_log+0x40>
800064da:	ce fb       	rjmp	800064b8 <task_log+0x10>
800064dc:	00 00       	add	r0,r0
800064de:	1f d0       	ld.ub	r0,pc[0x5]
800064e0:	80 00       	ld.sh	r0,r0[0x0]
800064e2:	54 c4       	stdsp	sp[0x130],r4
800064e4:	80 00       	ld.sh	r0,r0[0x0]
800064e6:	4e e0       	lddpc	r0,8000669c <_malloc_r+0x120>
800064e8:	80 00       	ld.sh	r0,r0[0x0]
800064ea:	53 a4       	stdsp	sp[0xe8],r4

800064ec <main>:
#include "xgflash.h"
#include "app.h"


int main (void)
{
800064ec:	d4 01       	pushm	lr
	
	//Force SSC_TX_DATA_ENABLE Disabled as soon as possible.
	AVR32_GPIO.port[1].ovrs  =  0x00000001;  //Value will be high.
800064ee:	fe 78 10 00 	mov	r8,-61440
800064f2:	30 19       	mov	r9,1
800064f4:	f1 49 01 54 	st.w	r8[340],r9
	AVR32_GPIO.port[1].oders =  0x00000001;  //Output Driver will be Enabled.
800064f8:	f1 49 01 44 	st.w	r8[324],r9
	AVR32_GPIO.port[1].gpers =  0x00000001;  //Enable as GPIO.
800064fc:	f1 49 01 04 	st.w	r8[260],r9
		
	Disable_global_interrupt();
80006500:	d3 03       	ssrf	0x10
	local_start_pll0();
80006502:	f0 1f 00 0c 	mcall	80006530 <main+0x44>
		
	INTC_init_interrupts();
80006506:	f0 1f 00 0c 	mcall	80006534 <main+0x48>
		
	log_init();
8000650a:	f0 1f 00 0c 	mcall	80006538 <main+0x4c>
	log("----start debug----");
8000650e:	48 cc       	lddpc	r12,8000653c <main+0x50>
80006510:	f0 1f 00 0c 	mcall	80006540 <main+0x54>
	
	xg_flashc_init();
80006514:	f0 1f 00 0c 	mcall	80006544 <main+0x58>
		
	//voc_init();

	//tc_init();
	
	rfid_init();
80006518:	f0 1f 00 0c 	mcall	80006548 <main+0x5c>
		
	app_init();
8000651c:	f0 1f 00 0c 	mcall	8000654c <main+0x60>
	
	xg_rtc_init();
80006520:	f0 1f 00 0c 	mcall	80006550 <main+0x64>
		
	//xcmp_init();

	local_start_timer();
80006524:	f0 1f 00 0c 	mcall	80006554 <main+0x68>
		
	vTaskStartScheduler();
80006528:	f0 1f 00 0c 	mcall	80006558 <main+0x6c>
	return 0;
	
}
8000652c:	d8 0a       	popm	pc,r12=0
8000652e:	00 00       	add	r0,r0
80006530:	80 00       	ld.sh	r0,r0[0x0]
80006532:	3e e8       	mov	r8,-18
80006534:	80 00       	ld.sh	r0,r0[0x0]
80006536:	48 40       	lddpc	r0,80006544 <main+0x58>
80006538:	80 00       	ld.sh	r0,r0[0x0]
8000653a:	64 44       	ld.w	r4,r2[0x10]
8000653c:	80 00       	ld.sh	r0,r0[0x0]
8000653e:	ce c4       	brge	80006516 <main+0x2a>
80006540:	80 00       	ld.sh	r0,r0[0x0]
80006542:	62 b8       	ld.w	r8,r1[0x2c]
80006544:	80 00       	ld.sh	r0,r0[0x0]
80006546:	3f d0       	mov	r0,-3
80006548:	80 00       	ld.sh	r0,r0[0x0]
8000654a:	3e 48       	mov	r8,-28
8000654c:	80 00       	ld.sh	r0,r0[0x0]
8000654e:	20 3c       	sub	r12,3
80006550:	80 00       	ld.sh	r0,r0[0x0]
80006552:	30 4c       	mov	r12,4
80006554:	80 00       	ld.sh	r0,r0[0x0]
80006556:	3e bc       	mov	r12,-21
80006558:	80 00       	ld.sh	r0,r0[0x0]
8000655a:	60 dc       	ld.w	r12,r0[0x34]

8000655c <free>:
8000655c:	d4 01       	pushm	lr
8000655e:	e0 68 0a 20 	mov	r8,2592
80006562:	18 9b       	mov	r11,r12
80006564:	70 0c       	ld.w	r12,r8[0x0]
80006566:	e0 a0 1e 73 	rcall	8000a24c <_free_r>
8000656a:	d8 02       	popm	pc

8000656c <malloc>:
8000656c:	d4 01       	pushm	lr
8000656e:	e0 68 0a 20 	mov	r8,2592
80006572:	18 9b       	mov	r11,r12
80006574:	70 0c       	ld.w	r12,r8[0x0]
80006576:	c0 3c       	rcall	8000657c <_malloc_r>
80006578:	d8 02       	popm	pc
8000657a:	d7 03       	nop

8000657c <_malloc_r>:
8000657c:	d4 31       	pushm	r0-r7,lr
8000657e:	f6 c8 ff f5 	sub	r8,r11,-11
80006582:	18 95       	mov	r5,r12
80006584:	10 97       	mov	r7,r8
80006586:	e0 17 ff f8 	andl	r7,0xfff8
8000658a:	59 68       	cp.w	r8,22
8000658c:	f9 b7 08 10 	movls	r7,16
80006590:	16 37       	cp.w	r7,r11
80006592:	5f 38       	srlo	r8
80006594:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
80006598:	c0 50       	breq	800065a2 <_malloc_r+0x26>
8000659a:	30 c8       	mov	r8,12
8000659c:	99 38       	st.w	r12[0xc],r8
8000659e:	e0 8f 01 fa 	bral	80006992 <_malloc_r+0x416>
800065a2:	fe b0 f6 b7 	rcall	80005310 <__malloc_lock>
800065a6:	e0 47 01 f7 	cp.w	r7,503
800065aa:	e0 8b 00 1d 	brhi	800065e4 <_malloc_r+0x68>
800065ae:	ee 03 16 03 	lsr	r3,r7,0x3
800065b2:	e0 68 05 20 	mov	r8,1312
800065b6:	f0 03 00 38 	add	r8,r8,r3<<0x3
800065ba:	70 36       	ld.w	r6,r8[0xc]
800065bc:	10 36       	cp.w	r6,r8
800065be:	c0 61       	brne	800065ca <_malloc_r+0x4e>
800065c0:	ec c8 ff f8 	sub	r8,r6,-8
800065c4:	70 36       	ld.w	r6,r8[0xc]
800065c6:	10 36       	cp.w	r6,r8
800065c8:	c0 c0       	breq	800065e0 <_malloc_r+0x64>
800065ca:	6c 18       	ld.w	r8,r6[0x4]
800065cc:	e0 18 ff fc 	andl	r8,0xfffc
800065d0:	6c 3a       	ld.w	r10,r6[0xc]
800065d2:	ec 08 00 09 	add	r9,r6,r8
800065d6:	0a 9c       	mov	r12,r5
800065d8:	6c 28       	ld.w	r8,r6[0x8]
800065da:	95 28       	st.w	r10[0x8],r8
800065dc:	91 3a       	st.w	r8[0xc],r10
800065de:	c4 78       	rjmp	8000666c <_malloc_r+0xf0>
800065e0:	2f e3       	sub	r3,-2
800065e2:	c4 d8       	rjmp	8000667c <_malloc_r+0x100>
800065e4:	ee 03 16 09 	lsr	r3,r7,0x9
800065e8:	c0 41       	brne	800065f0 <_malloc_r+0x74>
800065ea:	ee 03 16 03 	lsr	r3,r7,0x3
800065ee:	c2 68       	rjmp	8000663a <_malloc_r+0xbe>
800065f0:	58 43       	cp.w	r3,4
800065f2:	e0 8b 00 06 	brhi	800065fe <_malloc_r+0x82>
800065f6:	ee 03 16 06 	lsr	r3,r7,0x6
800065fa:	2c 83       	sub	r3,-56
800065fc:	c1 f8       	rjmp	8000663a <_malloc_r+0xbe>
800065fe:	59 43       	cp.w	r3,20
80006600:	e0 8b 00 04 	brhi	80006608 <_malloc_r+0x8c>
80006604:	2a 53       	sub	r3,-91
80006606:	c1 a8       	rjmp	8000663a <_malloc_r+0xbe>
80006608:	e0 43 00 54 	cp.w	r3,84
8000660c:	e0 8b 00 06 	brhi	80006618 <_malloc_r+0x9c>
80006610:	ee 03 16 0c 	lsr	r3,r7,0xc
80006614:	29 23       	sub	r3,-110
80006616:	c1 28       	rjmp	8000663a <_malloc_r+0xbe>
80006618:	e0 43 01 54 	cp.w	r3,340
8000661c:	e0 8b 00 06 	brhi	80006628 <_malloc_r+0xac>
80006620:	ee 03 16 0f 	lsr	r3,r7,0xf
80006624:	28 93       	sub	r3,-119
80006626:	c0 a8       	rjmp	8000663a <_malloc_r+0xbe>
80006628:	e0 43 05 54 	cp.w	r3,1364
8000662c:	e0 88 00 04 	brls	80006634 <_malloc_r+0xb8>
80006630:	37 e3       	mov	r3,126
80006632:	c0 48       	rjmp	8000663a <_malloc_r+0xbe>
80006634:	ee 03 16 12 	lsr	r3,r7,0x12
80006638:	28 43       	sub	r3,-124
8000663a:	e0 6a 05 20 	mov	r10,1312
8000663e:	f4 03 00 3a 	add	r10,r10,r3<<0x3
80006642:	74 36       	ld.w	r6,r10[0xc]
80006644:	c1 98       	rjmp	80006676 <_malloc_r+0xfa>
80006646:	6c 19       	ld.w	r9,r6[0x4]
80006648:	e0 19 ff fc 	andl	r9,0xfffc
8000664c:	f2 07 01 0b 	sub	r11,r9,r7
80006650:	58 fb       	cp.w	r11,15
80006652:	e0 8a 00 04 	brle	8000665a <_malloc_r+0xde>
80006656:	20 13       	sub	r3,1
80006658:	c1 18       	rjmp	8000667a <_malloc_r+0xfe>
8000665a:	6c 38       	ld.w	r8,r6[0xc]
8000665c:	58 0b       	cp.w	r11,0
8000665e:	c0 b5       	brlt	80006674 <_malloc_r+0xf8>
80006660:	6c 2a       	ld.w	r10,r6[0x8]
80006662:	ec 09 00 09 	add	r9,r6,r9
80006666:	0a 9c       	mov	r12,r5
80006668:	91 2a       	st.w	r8[0x8],r10
8000666a:	95 38       	st.w	r10[0xc],r8
8000666c:	72 18       	ld.w	r8,r9[0x4]
8000666e:	a1 a8       	sbr	r8,0x0
80006670:	93 18       	st.w	r9[0x4],r8
80006672:	cb c8       	rjmp	800067ea <_malloc_r+0x26e>
80006674:	10 96       	mov	r6,r8
80006676:	14 36       	cp.w	r6,r10
80006678:	ce 71       	brne	80006646 <_malloc_r+0xca>
8000667a:	2f f3       	sub	r3,-1
8000667c:	e0 6a 05 20 	mov	r10,1312
80006680:	f4 cc ff f8 	sub	r12,r10,-8
80006684:	78 26       	ld.w	r6,r12[0x8]
80006686:	18 36       	cp.w	r6,r12
80006688:	c6 c0       	breq	80006760 <_malloc_r+0x1e4>
8000668a:	6c 19       	ld.w	r9,r6[0x4]
8000668c:	e0 19 ff fc 	andl	r9,0xfffc
80006690:	f2 07 01 08 	sub	r8,r9,r7
80006694:	58 f8       	cp.w	r8,15
80006696:	e0 89 00 8f 	brgt	800067b4 <_malloc_r+0x238>
8000669a:	99 3c       	st.w	r12[0xc],r12
8000669c:	99 2c       	st.w	r12[0x8],r12
8000669e:	58 08       	cp.w	r8,0
800066a0:	c0 55       	brlt	800066aa <_malloc_r+0x12e>
800066a2:	ec 09 00 09 	add	r9,r6,r9
800066a6:	0a 9c       	mov	r12,r5
800066a8:	ce 2b       	rjmp	8000666c <_malloc_r+0xf0>
800066aa:	e0 49 01 ff 	cp.w	r9,511
800066ae:	e0 8b 00 13 	brhi	800066d4 <_malloc_r+0x158>
800066b2:	a3 99       	lsr	r9,0x3
800066b4:	f4 09 00 38 	add	r8,r10,r9<<0x3
800066b8:	70 2b       	ld.w	r11,r8[0x8]
800066ba:	8d 38       	st.w	r6[0xc],r8
800066bc:	8d 2b       	st.w	r6[0x8],r11
800066be:	97 36       	st.w	r11[0xc],r6
800066c0:	91 26       	st.w	r8[0x8],r6
800066c2:	a3 49       	asr	r9,0x2
800066c4:	74 18       	ld.w	r8,r10[0x4]
800066c6:	30 1b       	mov	r11,1
800066c8:	f6 09 09 49 	lsl	r9,r11,r9
800066cc:	f1 e9 10 09 	or	r9,r8,r9
800066d0:	95 19       	st.w	r10[0x4],r9
800066d2:	c4 78       	rjmp	80006760 <_malloc_r+0x1e4>
800066d4:	f2 0a 16 09 	lsr	r10,r9,0x9
800066d8:	58 4a       	cp.w	r10,4
800066da:	e0 8b 00 07 	brhi	800066e8 <_malloc_r+0x16c>
800066de:	f2 0a 16 06 	lsr	r10,r9,0x6
800066e2:	2c 8a       	sub	r10,-56
800066e4:	c2 08       	rjmp	80006724 <_malloc_r+0x1a8>
800066e6:	d7 03       	nop
800066e8:	59 4a       	cp.w	r10,20
800066ea:	e0 8b 00 04 	brhi	800066f2 <_malloc_r+0x176>
800066ee:	2a 5a       	sub	r10,-91
800066f0:	c1 a8       	rjmp	80006724 <_malloc_r+0x1a8>
800066f2:	e0 4a 00 54 	cp.w	r10,84
800066f6:	e0 8b 00 06 	brhi	80006702 <_malloc_r+0x186>
800066fa:	f2 0a 16 0c 	lsr	r10,r9,0xc
800066fe:	29 2a       	sub	r10,-110
80006700:	c1 28       	rjmp	80006724 <_malloc_r+0x1a8>
80006702:	e0 4a 01 54 	cp.w	r10,340
80006706:	e0 8b 00 06 	brhi	80006712 <_malloc_r+0x196>
8000670a:	f2 0a 16 0f 	lsr	r10,r9,0xf
8000670e:	28 9a       	sub	r10,-119
80006710:	c0 a8       	rjmp	80006724 <_malloc_r+0x1a8>
80006712:	e0 4a 05 54 	cp.w	r10,1364
80006716:	e0 88 00 04 	brls	8000671e <_malloc_r+0x1a2>
8000671a:	37 ea       	mov	r10,126
8000671c:	c0 48       	rjmp	80006724 <_malloc_r+0x1a8>
8000671e:	f2 0a 16 12 	lsr	r10,r9,0x12
80006722:	28 4a       	sub	r10,-124
80006724:	e0 6b 05 20 	mov	r11,1312
80006728:	f6 0a 00 34 	add	r4,r11,r10<<0x3
8000672c:	68 28       	ld.w	r8,r4[0x8]
8000672e:	08 38       	cp.w	r8,r4
80006730:	c0 e1       	brne	8000674c <_malloc_r+0x1d0>
80006732:	76 19       	ld.w	r9,r11[0x4]
80006734:	a3 4a       	asr	r10,0x2
80006736:	30 1e       	mov	lr,1
80006738:	fc 0a 09 4a 	lsl	r10,lr,r10
8000673c:	f3 ea 10 0a 	or	r10,r9,r10
80006740:	10 99       	mov	r9,r8
80006742:	97 1a       	st.w	r11[0x4],r10
80006744:	c0 a8       	rjmp	80006758 <_malloc_r+0x1dc>
80006746:	70 28       	ld.w	r8,r8[0x8]
80006748:	08 38       	cp.w	r8,r4
8000674a:	c0 60       	breq	80006756 <_malloc_r+0x1da>
8000674c:	70 1a       	ld.w	r10,r8[0x4]
8000674e:	e0 1a ff fc 	andl	r10,0xfffc
80006752:	14 39       	cp.w	r9,r10
80006754:	cf 93       	brcs	80006746 <_malloc_r+0x1ca>
80006756:	70 39       	ld.w	r9,r8[0xc]
80006758:	8d 39       	st.w	r6[0xc],r9
8000675a:	8d 28       	st.w	r6[0x8],r8
8000675c:	91 36       	st.w	r8[0xc],r6
8000675e:	93 26       	st.w	r9[0x8],r6
80006760:	e6 08 14 02 	asr	r8,r3,0x2
80006764:	30 1b       	mov	r11,1
80006766:	e0 64 05 20 	mov	r4,1312
8000676a:	f6 08 09 4b 	lsl	r11,r11,r8
8000676e:	68 18       	ld.w	r8,r4[0x4]
80006770:	10 3b       	cp.w	r11,r8
80006772:	e0 8b 00 6b 	brhi	80006848 <_malloc_r+0x2cc>
80006776:	f7 e8 00 09 	and	r9,r11,r8
8000677a:	c0 b1       	brne	80006790 <_malloc_r+0x214>
8000677c:	e0 13 ff fc 	andl	r3,0xfffc
80006780:	a1 7b       	lsl	r11,0x1
80006782:	2f c3       	sub	r3,-4
80006784:	c0 38       	rjmp	8000678a <_malloc_r+0x20e>
80006786:	2f c3       	sub	r3,-4
80006788:	a1 7b       	lsl	r11,0x1
8000678a:	f7 e8 00 09 	and	r9,r11,r8
8000678e:	cf c0       	breq	80006786 <_malloc_r+0x20a>
80006790:	e8 03 00 3e 	add	lr,r4,r3<<0x3
80006794:	06 92       	mov	r2,r3
80006796:	1c 91       	mov	r1,lr
80006798:	62 36       	ld.w	r6,r1[0xc]
8000679a:	c2 e8       	rjmp	800067f6 <_malloc_r+0x27a>
8000679c:	6c 1a       	ld.w	r10,r6[0x4]
8000679e:	e0 1a ff fc 	andl	r10,0xfffc
800067a2:	f4 07 01 08 	sub	r8,r10,r7
800067a6:	58 f8       	cp.w	r8,15
800067a8:	e0 8a 00 15 	brle	800067d2 <_malloc_r+0x256>
800067ac:	6c 3a       	ld.w	r10,r6[0xc]
800067ae:	6c 29       	ld.w	r9,r6[0x8]
800067b0:	95 29       	st.w	r10[0x8],r9
800067b2:	93 3a       	st.w	r9[0xc],r10
800067b4:	0e 99       	mov	r9,r7
800067b6:	ec 07 00 07 	add	r7,r6,r7
800067ba:	a1 a9       	sbr	r9,0x0
800067bc:	99 37       	st.w	r12[0xc],r7
800067be:	99 27       	st.w	r12[0x8],r7
800067c0:	8d 19       	st.w	r6[0x4],r9
800067c2:	ee 08 09 08 	st.w	r7[r8],r8
800067c6:	8f 2c       	st.w	r7[0x8],r12
800067c8:	8f 3c       	st.w	r7[0xc],r12
800067ca:	a1 a8       	sbr	r8,0x0
800067cc:	0a 9c       	mov	r12,r5
800067ce:	8f 18       	st.w	r7[0x4],r8
800067d0:	c0 d8       	rjmp	800067ea <_malloc_r+0x26e>
800067d2:	6c 39       	ld.w	r9,r6[0xc]
800067d4:	58 08       	cp.w	r8,0
800067d6:	c0 f5       	brlt	800067f4 <_malloc_r+0x278>
800067d8:	ec 0a 00 0a 	add	r10,r6,r10
800067dc:	74 18       	ld.w	r8,r10[0x4]
800067de:	a1 a8       	sbr	r8,0x0
800067e0:	0a 9c       	mov	r12,r5
800067e2:	95 18       	st.w	r10[0x4],r8
800067e4:	6c 28       	ld.w	r8,r6[0x8]
800067e6:	93 28       	st.w	r9[0x8],r8
800067e8:	91 39       	st.w	r8[0xc],r9
800067ea:	fe b0 f5 99 	rcall	8000531c <__malloc_unlock>
800067ee:	ec cc ff f8 	sub	r12,r6,-8
800067f2:	d8 32       	popm	r0-r7,pc
800067f4:	12 96       	mov	r6,r9
800067f6:	02 36       	cp.w	r6,r1
800067f8:	cd 21       	brne	8000679c <_malloc_r+0x220>
800067fa:	2f f2       	sub	r2,-1
800067fc:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
80006800:	c0 30       	breq	80006806 <_malloc_r+0x28a>
80006802:	2f 81       	sub	r1,-8
80006804:	cc ab       	rjmp	80006798 <_malloc_r+0x21c>
80006806:	1c 98       	mov	r8,lr
80006808:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
8000680c:	c0 81       	brne	8000681c <_malloc_r+0x2a0>
8000680e:	68 19       	ld.w	r9,r4[0x4]
80006810:	f6 08 11 ff 	rsub	r8,r11,-1
80006814:	f3 e8 00 08 	and	r8,r9,r8
80006818:	89 18       	st.w	r4[0x4],r8
8000681a:	c0 78       	rjmp	80006828 <_malloc_r+0x2ac>
8000681c:	f0 c9 00 08 	sub	r9,r8,8
80006820:	20 13       	sub	r3,1
80006822:	70 08       	ld.w	r8,r8[0x0]
80006824:	12 38       	cp.w	r8,r9
80006826:	cf 10       	breq	80006808 <_malloc_r+0x28c>
80006828:	a1 7b       	lsl	r11,0x1
8000682a:	68 18       	ld.w	r8,r4[0x4]
8000682c:	10 3b       	cp.w	r11,r8
8000682e:	e0 8b 00 0d 	brhi	80006848 <_malloc_r+0x2cc>
80006832:	58 0b       	cp.w	r11,0
80006834:	c0 a0       	breq	80006848 <_malloc_r+0x2cc>
80006836:	04 93       	mov	r3,r2
80006838:	c0 38       	rjmp	8000683e <_malloc_r+0x2c2>
8000683a:	2f c3       	sub	r3,-4
8000683c:	a1 7b       	lsl	r11,0x1
8000683e:	f7 e8 00 09 	and	r9,r11,r8
80006842:	ca 71       	brne	80006790 <_malloc_r+0x214>
80006844:	cf bb       	rjmp	8000683a <_malloc_r+0x2be>
80006846:	d7 03       	nop
80006848:	68 23       	ld.w	r3,r4[0x8]
8000684a:	66 12       	ld.w	r2,r3[0x4]
8000684c:	e0 12 ff fc 	andl	r2,0xfffc
80006850:	0e 32       	cp.w	r2,r7
80006852:	5f 39       	srlo	r9
80006854:	e4 07 01 08 	sub	r8,r2,r7
80006858:	58 f8       	cp.w	r8,15
8000685a:	5f aa       	srle	r10
8000685c:	f5 e9 10 09 	or	r9,r10,r9
80006860:	e0 80 00 9a 	breq	80006994 <_malloc_r+0x418>
80006864:	e0 68 0c e4 	mov	r8,3300
80006868:	70 01       	ld.w	r1,r8[0x0]
8000686a:	e0 68 09 2c 	mov	r8,2348
8000686e:	2f 01       	sub	r1,-16
80006870:	70 08       	ld.w	r8,r8[0x0]
80006872:	0e 01       	add	r1,r7
80006874:	5b f8       	cp.w	r8,-1
80006876:	c0 40       	breq	8000687e <_malloc_r+0x302>
80006878:	28 11       	sub	r1,-127
8000687a:	e0 11 ff 80 	andl	r1,0xff80
8000687e:	02 9b       	mov	r11,r1
80006880:	0a 9c       	mov	r12,r5
80006882:	e0 a0 02 b7 	rcall	80006df0 <_sbrk_r>
80006886:	18 96       	mov	r6,r12
80006888:	5b fc       	cp.w	r12,-1
8000688a:	c7 50       	breq	80006974 <_malloc_r+0x3f8>
8000688c:	e6 02 00 08 	add	r8,r3,r2
80006890:	10 3c       	cp.w	r12,r8
80006892:	c0 32       	brcc	80006898 <_malloc_r+0x31c>
80006894:	08 33       	cp.w	r3,r4
80006896:	c6 f1       	brne	80006974 <_malloc_r+0x3f8>
80006898:	e0 6a 0c e8 	mov	r10,3304
8000689c:	74 09       	ld.w	r9,r10[0x0]
8000689e:	e2 09 00 09 	add	r9,r1,r9
800068a2:	95 09       	st.w	r10[0x0],r9
800068a4:	10 36       	cp.w	r6,r8
800068a6:	c0 a1       	brne	800068ba <_malloc_r+0x33e>
800068a8:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
800068ac:	c0 71       	brne	800068ba <_malloc_r+0x33e>
800068ae:	e2 02 00 02 	add	r2,r1,r2
800068b2:	68 28       	ld.w	r8,r4[0x8]
800068b4:	a1 a2       	sbr	r2,0x0
800068b6:	91 12       	st.w	r8[0x4],r2
800068b8:	c4 f8       	rjmp	80006956 <_malloc_r+0x3da>
800068ba:	e0 6a 09 2c 	mov	r10,2348
800068be:	74 0b       	ld.w	r11,r10[0x0]
800068c0:	5b fb       	cp.w	r11,-1
800068c2:	c0 31       	brne	800068c8 <_malloc_r+0x34c>
800068c4:	95 06       	st.w	r10[0x0],r6
800068c6:	c0 78       	rjmp	800068d4 <_malloc_r+0x358>
800068c8:	ec 09 00 09 	add	r9,r6,r9
800068cc:	e0 6a 0c e8 	mov	r10,3304
800068d0:	10 19       	sub	r9,r8
800068d2:	95 09       	st.w	r10[0x0],r9
800068d4:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
800068d8:	f0 09 11 08 	rsub	r9,r8,8
800068dc:	58 08       	cp.w	r8,0
800068de:	f2 08 17 10 	movne	r8,r9
800068e2:	ed d8 e1 06 	addne	r6,r6,r8
800068e6:	28 08       	sub	r8,-128
800068e8:	ec 01 00 01 	add	r1,r6,r1
800068ec:	0a 9c       	mov	r12,r5
800068ee:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
800068f2:	f0 01 01 01 	sub	r1,r8,r1
800068f6:	02 9b       	mov	r11,r1
800068f8:	e0 a0 02 7c 	rcall	80006df0 <_sbrk_r>
800068fc:	e0 68 0c e8 	mov	r8,3304
80006900:	5b fc       	cp.w	r12,-1
80006902:	ec 0c 17 00 	moveq	r12,r6
80006906:	f9 b1 00 00 	moveq	r1,0
8000690a:	70 09       	ld.w	r9,r8[0x0]
8000690c:	0c 1c       	sub	r12,r6
8000690e:	89 26       	st.w	r4[0x8],r6
80006910:	02 0c       	add	r12,r1
80006912:	12 01       	add	r1,r9
80006914:	a1 ac       	sbr	r12,0x0
80006916:	91 01       	st.w	r8[0x0],r1
80006918:	8d 1c       	st.w	r6[0x4],r12
8000691a:	08 33       	cp.w	r3,r4
8000691c:	c1 d0       	breq	80006956 <_malloc_r+0x3da>
8000691e:	58 f2       	cp.w	r2,15
80006920:	e0 8b 00 05 	brhi	8000692a <_malloc_r+0x3ae>
80006924:	30 18       	mov	r8,1
80006926:	8d 18       	st.w	r6[0x4],r8
80006928:	c2 68       	rjmp	80006974 <_malloc_r+0x3f8>
8000692a:	30 59       	mov	r9,5
8000692c:	20 c2       	sub	r2,12
8000692e:	e0 12 ff f8 	andl	r2,0xfff8
80006932:	e6 02 00 08 	add	r8,r3,r2
80006936:	91 29       	st.w	r8[0x8],r9
80006938:	91 19       	st.w	r8[0x4],r9
8000693a:	66 18       	ld.w	r8,r3[0x4]
8000693c:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80006940:	e5 e8 10 08 	or	r8,r2,r8
80006944:	87 18       	st.w	r3[0x4],r8
80006946:	58 f2       	cp.w	r2,15
80006948:	e0 88 00 07 	brls	80006956 <_malloc_r+0x3da>
8000694c:	e6 cb ff f8 	sub	r11,r3,-8
80006950:	0a 9c       	mov	r12,r5
80006952:	e0 a0 1c 7d 	rcall	8000a24c <_free_r>
80006956:	e0 69 0c e0 	mov	r9,3296
8000695a:	72 0a       	ld.w	r10,r9[0x0]
8000695c:	e0 68 0c e8 	mov	r8,3304
80006960:	70 08       	ld.w	r8,r8[0x0]
80006962:	14 38       	cp.w	r8,r10
80006964:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80006968:	e0 69 0c dc 	mov	r9,3292
8000696c:	72 0a       	ld.w	r10,r9[0x0]
8000696e:	14 38       	cp.w	r8,r10
80006970:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80006974:	68 28       	ld.w	r8,r4[0x8]
80006976:	70 18       	ld.w	r8,r8[0x4]
80006978:	e0 18 ff fc 	andl	r8,0xfffc
8000697c:	0e 38       	cp.w	r8,r7
8000697e:	5f 39       	srlo	r9
80006980:	0e 18       	sub	r8,r7
80006982:	58 f8       	cp.w	r8,15
80006984:	5f aa       	srle	r10
80006986:	f5 e9 10 09 	or	r9,r10,r9
8000698a:	c0 50       	breq	80006994 <_malloc_r+0x418>
8000698c:	0a 9c       	mov	r12,r5
8000698e:	fe b0 f4 c7 	rcall	8000531c <__malloc_unlock>
80006992:	d8 3a       	popm	r0-r7,pc,r12=0
80006994:	68 26       	ld.w	r6,r4[0x8]
80006996:	a1 a8       	sbr	r8,0x0
80006998:	0e 99       	mov	r9,r7
8000699a:	a1 a9       	sbr	r9,0x0
8000699c:	8d 19       	st.w	r6[0x4],r9
8000699e:	ec 07 00 07 	add	r7,r6,r7
800069a2:	0a 9c       	mov	r12,r5
800069a4:	89 27       	st.w	r4[0x8],r7
800069a6:	8f 18       	st.w	r7[0x4],r8
800069a8:	fe b0 f4 ba 	rcall	8000531c <__malloc_unlock>
800069ac:	ec cc ff f8 	sub	r12,r6,-8
800069b0:	d8 32       	popm	r0-r7,pc
800069b2:	d7 03       	nop

800069b4 <memcmp>:
800069b4:	d4 01       	pushm	lr
800069b6:	30 08       	mov	r8,0
800069b8:	c0 d8       	rjmp	800069d2 <memcmp+0x1e>
800069ba:	f8 08 07 0e 	ld.ub	lr,r12[r8]
800069be:	f6 08 07 09 	ld.ub	r9,r11[r8]
800069c2:	20 1a       	sub	r10,1
800069c4:	2f f8       	sub	r8,-1
800069c6:	f2 0e 18 00 	cp.b	lr,r9
800069ca:	c0 40       	breq	800069d2 <memcmp+0x1e>
800069cc:	fc 09 01 0c 	sub	r12,lr,r9
800069d0:	d8 02       	popm	pc
800069d2:	58 0a       	cp.w	r10,0
800069d4:	cf 31       	brne	800069ba <memcmp+0x6>
800069d6:	14 9c       	mov	r12,r10
800069d8:	d8 02       	popm	pc

800069da <memcpy>:
800069da:	58 8a       	cp.w	r10,8
800069dc:	c2 f5       	brlt	80006a3a <memcpy+0x60>
800069de:	f9 eb 10 09 	or	r9,r12,r11
800069e2:	e2 19 00 03 	andl	r9,0x3,COH
800069e6:	e0 81 00 97 	brne	80006b14 <memcpy+0x13a>
800069ea:	e0 4a 00 20 	cp.w	r10,32
800069ee:	c3 b4       	brge	80006a64 <memcpy+0x8a>
800069f0:	f4 08 14 02 	asr	r8,r10,0x2
800069f4:	f0 09 11 08 	rsub	r9,r8,8
800069f8:	fe 09 00 2f 	add	pc,pc,r9<<0x2
800069fc:	76 69       	ld.w	r9,r11[0x18]
800069fe:	99 69       	st.w	r12[0x18],r9
80006a00:	76 59       	ld.w	r9,r11[0x14]
80006a02:	99 59       	st.w	r12[0x14],r9
80006a04:	76 49       	ld.w	r9,r11[0x10]
80006a06:	99 49       	st.w	r12[0x10],r9
80006a08:	76 39       	ld.w	r9,r11[0xc]
80006a0a:	99 39       	st.w	r12[0xc],r9
80006a0c:	76 29       	ld.w	r9,r11[0x8]
80006a0e:	99 29       	st.w	r12[0x8],r9
80006a10:	76 19       	ld.w	r9,r11[0x4]
80006a12:	99 19       	st.w	r12[0x4],r9
80006a14:	76 09       	ld.w	r9,r11[0x0]
80006a16:	99 09       	st.w	r12[0x0],r9
80006a18:	f6 08 00 2b 	add	r11,r11,r8<<0x2
80006a1c:	f8 08 00 28 	add	r8,r12,r8<<0x2
80006a20:	e0 1a 00 03 	andl	r10,0x3
80006a24:	f4 0a 11 04 	rsub	r10,r10,4
80006a28:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
80006a2c:	17 a9       	ld.ub	r9,r11[0x2]
80006a2e:	b0 a9       	st.b	r8[0x2],r9
80006a30:	17 99       	ld.ub	r9,r11[0x1]
80006a32:	b0 99       	st.b	r8[0x1],r9
80006a34:	17 89       	ld.ub	r9,r11[0x0]
80006a36:	b0 89       	st.b	r8[0x0],r9
80006a38:	5e fc       	retal	r12
80006a3a:	f4 0a 11 09 	rsub	r10,r10,9
80006a3e:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
80006a42:	17 f9       	ld.ub	r9,r11[0x7]
80006a44:	b8 f9       	st.b	r12[0x7],r9
80006a46:	17 e9       	ld.ub	r9,r11[0x6]
80006a48:	b8 e9       	st.b	r12[0x6],r9
80006a4a:	17 d9       	ld.ub	r9,r11[0x5]
80006a4c:	b8 d9       	st.b	r12[0x5],r9
80006a4e:	17 c9       	ld.ub	r9,r11[0x4]
80006a50:	b8 c9       	st.b	r12[0x4],r9
80006a52:	17 b9       	ld.ub	r9,r11[0x3]
80006a54:	b8 b9       	st.b	r12[0x3],r9
80006a56:	17 a9       	ld.ub	r9,r11[0x2]
80006a58:	b8 a9       	st.b	r12[0x2],r9
80006a5a:	17 99       	ld.ub	r9,r11[0x1]
80006a5c:	b8 99       	st.b	r12[0x1],r9
80006a5e:	17 89       	ld.ub	r9,r11[0x0]
80006a60:	b8 89       	st.b	r12[0x0],r9
80006a62:	5e fc       	retal	r12
80006a64:	eb cd 40 c0 	pushm	r6-r7,lr
80006a68:	18 99       	mov	r9,r12
80006a6a:	22 0a       	sub	r10,32
80006a6c:	b7 07       	ld.d	r6,r11++
80006a6e:	b3 26       	st.d	r9++,r6
80006a70:	b7 07       	ld.d	r6,r11++
80006a72:	b3 26       	st.d	r9++,r6
80006a74:	b7 07       	ld.d	r6,r11++
80006a76:	b3 26       	st.d	r9++,r6
80006a78:	b7 07       	ld.d	r6,r11++
80006a7a:	b3 26       	st.d	r9++,r6
80006a7c:	22 0a       	sub	r10,32
80006a7e:	cf 74       	brge	80006a6c <memcpy+0x92>
80006a80:	2f 0a       	sub	r10,-16
80006a82:	c0 65       	brlt	80006a8e <memcpy+0xb4>
80006a84:	b7 07       	ld.d	r6,r11++
80006a86:	b3 26       	st.d	r9++,r6
80006a88:	b7 07       	ld.d	r6,r11++
80006a8a:	b3 26       	st.d	r9++,r6
80006a8c:	21 0a       	sub	r10,16
80006a8e:	5c 3a       	neg	r10
80006a90:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
80006a94:	d7 03       	nop
80006a96:	d7 03       	nop
80006a98:	f7 36 00 0e 	ld.ub	r6,r11[14]
80006a9c:	f3 66 00 0e 	st.b	r9[14],r6
80006aa0:	f7 36 00 0d 	ld.ub	r6,r11[13]
80006aa4:	f3 66 00 0d 	st.b	r9[13],r6
80006aa8:	f7 36 00 0c 	ld.ub	r6,r11[12]
80006aac:	f3 66 00 0c 	st.b	r9[12],r6
80006ab0:	f7 36 00 0b 	ld.ub	r6,r11[11]
80006ab4:	f3 66 00 0b 	st.b	r9[11],r6
80006ab8:	f7 36 00 0a 	ld.ub	r6,r11[10]
80006abc:	f3 66 00 0a 	st.b	r9[10],r6
80006ac0:	f7 36 00 09 	ld.ub	r6,r11[9]
80006ac4:	f3 66 00 09 	st.b	r9[9],r6
80006ac8:	f7 36 00 08 	ld.ub	r6,r11[8]
80006acc:	f3 66 00 08 	st.b	r9[8],r6
80006ad0:	f7 36 00 07 	ld.ub	r6,r11[7]
80006ad4:	f3 66 00 07 	st.b	r9[7],r6
80006ad8:	f7 36 00 06 	ld.ub	r6,r11[6]
80006adc:	f3 66 00 06 	st.b	r9[6],r6
80006ae0:	f7 36 00 05 	ld.ub	r6,r11[5]
80006ae4:	f3 66 00 05 	st.b	r9[5],r6
80006ae8:	f7 36 00 04 	ld.ub	r6,r11[4]
80006aec:	f3 66 00 04 	st.b	r9[4],r6
80006af0:	f7 36 00 03 	ld.ub	r6,r11[3]
80006af4:	f3 66 00 03 	st.b	r9[3],r6
80006af8:	f7 36 00 02 	ld.ub	r6,r11[2]
80006afc:	f3 66 00 02 	st.b	r9[2],r6
80006b00:	f7 36 00 01 	ld.ub	r6,r11[1]
80006b04:	f3 66 00 01 	st.b	r9[1],r6
80006b08:	f7 36 00 00 	ld.ub	r6,r11[0]
80006b0c:	f3 66 00 00 	st.b	r9[0],r6
80006b10:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006b14:	20 1a       	sub	r10,1
80006b16:	f6 0a 07 09 	ld.ub	r9,r11[r10]
80006b1a:	f8 0a 0b 09 	st.b	r12[r10],r9
80006b1e:	cf b1       	brne	80006b14 <memcpy+0x13a>
80006b20:	5e fc       	retal	r12

80006b22 <memset>:
80006b22:	18 98       	mov	r8,r12
80006b24:	c0 38       	rjmp	80006b2a <memset+0x8>
80006b26:	10 cb       	st.b	r8++,r11
80006b28:	20 1a       	sub	r10,1
80006b2a:	58 0a       	cp.w	r10,0
80006b2c:	cf d1       	brne	80006b26 <memset+0x4>
80006b2e:	5e fc       	retal	r12

80006b30 <_realloc_r>:
80006b30:	d4 31       	pushm	r0-r7,lr
80006b32:	20 1d       	sub	sp,4
80006b34:	16 94       	mov	r4,r11
80006b36:	18 92       	mov	r2,r12
80006b38:	14 9b       	mov	r11,r10
80006b3a:	58 04       	cp.w	r4,0
80006b3c:	c0 51       	brne	80006b46 <_realloc_r+0x16>
80006b3e:	fe b0 fd 1f 	rcall	8000657c <_malloc_r>
80006b42:	18 95       	mov	r5,r12
80006b44:	c5 39       	rjmp	80006dea <_realloc_r+0x2ba>
80006b46:	50 0a       	stdsp	sp[0x0],r10
80006b48:	fe b0 f3 e4 	rcall	80005310 <__malloc_lock>
80006b4c:	40 0b       	lddsp	r11,sp[0x0]
80006b4e:	f6 c8 ff f5 	sub	r8,r11,-11
80006b52:	e8 c1 00 08 	sub	r1,r4,8
80006b56:	10 96       	mov	r6,r8
80006b58:	62 1c       	ld.w	r12,r1[0x4]
80006b5a:	e0 16 ff f8 	andl	r6,0xfff8
80006b5e:	59 68       	cp.w	r8,22
80006b60:	f9 b6 08 10 	movls	r6,16
80006b64:	16 36       	cp.w	r6,r11
80006b66:	5f 38       	srlo	r8
80006b68:	f1 e6 13 f8 	or	r8,r8,r6>>0x1f
80006b6c:	c0 50       	breq	80006b76 <_realloc_r+0x46>
80006b6e:	30 c8       	mov	r8,12
80006b70:	30 05       	mov	r5,0
80006b72:	85 38       	st.w	r2[0xc],r8
80006b74:	c3 b9       	rjmp	80006dea <_realloc_r+0x2ba>
80006b76:	18 90       	mov	r0,r12
80006b78:	e0 10 ff fc 	andl	r0,0xfffc
80006b7c:	0c 30       	cp.w	r0,r6
80006b7e:	e0 84 01 0b 	brge	80006d94 <_realloc_r+0x264>
80006b82:	e0 68 05 20 	mov	r8,1312
80006b86:	e2 00 00 09 	add	r9,r1,r0
80006b8a:	70 25       	ld.w	r5,r8[0x8]
80006b8c:	0a 39       	cp.w	r9,r5
80006b8e:	c0 90       	breq	80006ba0 <_realloc_r+0x70>
80006b90:	72 1a       	ld.w	r10,r9[0x4]
80006b92:	a1 ca       	cbr	r10,0x0
80006b94:	f2 0a 00 0a 	add	r10,r9,r10
80006b98:	74 1a       	ld.w	r10,r10[0x4]
80006b9a:	ed ba 00 00 	bld	r10,0x0
80006b9e:	c2 20       	breq	80006be2 <_realloc_r+0xb2>
80006ba0:	72 1a       	ld.w	r10,r9[0x4]
80006ba2:	e0 1a ff fc 	andl	r10,0xfffc
80006ba6:	f4 00 00 03 	add	r3,r10,r0
80006baa:	0a 39       	cp.w	r9,r5
80006bac:	c1 31       	brne	80006bd2 <_realloc_r+0xa2>
80006bae:	ec c7 ff f0 	sub	r7,r6,-16
80006bb2:	0e 33       	cp.w	r3,r7
80006bb4:	c1 95       	brlt	80006be6 <_realloc_r+0xb6>
80006bb6:	e2 06 00 09 	add	r9,r1,r6
80006bba:	0c 13       	sub	r3,r6
80006bbc:	a1 a3       	sbr	r3,0x0
80006bbe:	93 13       	st.w	r9[0x4],r3
80006bc0:	91 29       	st.w	r8[0x8],r9
80006bc2:	04 9c       	mov	r12,r2
80006bc4:	62 18       	ld.w	r8,r1[0x4]
80006bc6:	08 95       	mov	r5,r4
80006bc8:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80006bcc:	10 46       	or	r6,r8
80006bce:	83 16       	st.w	r1[0x4],r6
80006bd0:	c0 b9       	rjmp	80006de6 <_realloc_r+0x2b6>
80006bd2:	0c 33       	cp.w	r3,r6
80006bd4:	c0 95       	brlt	80006be6 <_realloc_r+0xb6>
80006bd6:	72 28       	ld.w	r8,r9[0x8]
80006bd8:	02 97       	mov	r7,r1
80006bda:	72 39       	ld.w	r9,r9[0xc]
80006bdc:	93 28       	st.w	r9[0x8],r8
80006bde:	91 39       	st.w	r8[0xc],r9
80006be0:	cd c8       	rjmp	80006d98 <_realloc_r+0x268>
80006be2:	30 0a       	mov	r10,0
80006be4:	14 99       	mov	r9,r10
80006be6:	ed bc 00 00 	bld	r12,0x0
80006bea:	e0 80 00 95 	breq	80006d14 <_realloc_r+0x1e4>
80006bee:	62 07       	ld.w	r7,r1[0x0]
80006bf0:	e2 07 01 07 	sub	r7,r1,r7
80006bf4:	6e 1c       	ld.w	r12,r7[0x4]
80006bf6:	e0 1c ff fc 	andl	r12,0xfffc
80006bfa:	58 09       	cp.w	r9,0
80006bfc:	c5 60       	breq	80006ca8 <_realloc_r+0x178>
80006bfe:	f8 00 00 03 	add	r3,r12,r0
80006c02:	0a 39       	cp.w	r9,r5
80006c04:	c4 81       	brne	80006c94 <_realloc_r+0x164>
80006c06:	14 03       	add	r3,r10
80006c08:	ec c9 ff f0 	sub	r9,r6,-16
80006c0c:	12 33       	cp.w	r3,r9
80006c0e:	c4 d5       	brlt	80006ca8 <_realloc_r+0x178>
80006c10:	6e 3a       	ld.w	r10,r7[0xc]
80006c12:	6e 29       	ld.w	r9,r7[0x8]
80006c14:	95 29       	st.w	r10[0x8],r9
80006c16:	93 3a       	st.w	r9[0xc],r10
80006c18:	ee c5 ff f8 	sub	r5,r7,-8
80006c1c:	e0 ca 00 04 	sub	r10,r0,4
80006c20:	e0 4a 00 24 	cp.w	r10,36
80006c24:	e0 8b 00 25 	brhi	80006c6e <_realloc_r+0x13e>
80006c28:	0a 99       	mov	r9,r5
80006c2a:	59 3a       	cp.w	r10,19
80006c2c:	e0 88 00 1a 	brls	80006c60 <_realloc_r+0x130>
80006c30:	09 09       	ld.w	r9,r4++
80006c32:	8b 09       	st.w	r5[0x0],r9
80006c34:	09 09       	ld.w	r9,r4++
80006c36:	8f 39       	st.w	r7[0xc],r9
80006c38:	ee c9 ff f0 	sub	r9,r7,-16
80006c3c:	59 ba       	cp.w	r10,27
80006c3e:	e0 88 00 11 	brls	80006c60 <_realloc_r+0x130>
80006c42:	09 0b       	ld.w	r11,r4++
80006c44:	93 0b       	st.w	r9[0x0],r11
80006c46:	09 09       	ld.w	r9,r4++
80006c48:	8f 59       	st.w	r7[0x14],r9
80006c4a:	ee c9 ff e8 	sub	r9,r7,-24
80006c4e:	e0 4a 00 24 	cp.w	r10,36
80006c52:	c0 71       	brne	80006c60 <_realloc_r+0x130>
80006c54:	09 0a       	ld.w	r10,r4++
80006c56:	93 0a       	st.w	r9[0x0],r10
80006c58:	ee c9 ff e0 	sub	r9,r7,-32
80006c5c:	09 0a       	ld.w	r10,r4++
80006c5e:	8f 7a       	st.w	r7[0x1c],r10
80006c60:	09 0a       	ld.w	r10,r4++
80006c62:	12 aa       	st.w	r9++,r10
80006c64:	68 0a       	ld.w	r10,r4[0x0]
80006c66:	93 0a       	st.w	r9[0x0],r10
80006c68:	68 1a       	ld.w	r10,r4[0x4]
80006c6a:	93 1a       	st.w	r9[0x4],r10
80006c6c:	c0 78       	rjmp	80006c7a <_realloc_r+0x14a>
80006c6e:	50 08       	stdsp	sp[0x0],r8
80006c70:	08 9b       	mov	r11,r4
80006c72:	0a 9c       	mov	r12,r5
80006c74:	e0 a0 1d 8f 	rcall	8000a792 <memmove>
80006c78:	40 08       	lddsp	r8,sp[0x0]
80006c7a:	ee 06 00 09 	add	r9,r7,r6
80006c7e:	0c 13       	sub	r3,r6
80006c80:	a1 a3       	sbr	r3,0x0
80006c82:	93 13       	st.w	r9[0x4],r3
80006c84:	91 29       	st.w	r8[0x8],r9
80006c86:	04 9c       	mov	r12,r2
80006c88:	6e 18       	ld.w	r8,r7[0x4]
80006c8a:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80006c8e:	10 46       	or	r6,r8
80006c90:	8f 16       	st.w	r7[0x4],r6
80006c92:	ca a8       	rjmp	80006de6 <_realloc_r+0x2b6>
80006c94:	14 03       	add	r3,r10
80006c96:	0c 33       	cp.w	r3,r6
80006c98:	c0 85       	brlt	80006ca8 <_realloc_r+0x178>
80006c9a:	72 28       	ld.w	r8,r9[0x8]
80006c9c:	72 39       	ld.w	r9,r9[0xc]
80006c9e:	93 28       	st.w	r9[0x8],r8
80006ca0:	91 39       	st.w	r8[0xc],r9
80006ca2:	6e 28       	ld.w	r8,r7[0x8]
80006ca4:	6e 39       	ld.w	r9,r7[0xc]
80006ca6:	c0 78       	rjmp	80006cb4 <_realloc_r+0x184>
80006ca8:	f8 00 00 03 	add	r3,r12,r0
80006cac:	0c 33       	cp.w	r3,r6
80006cae:	c3 35       	brlt	80006d14 <_realloc_r+0x1e4>
80006cb0:	6e 39       	ld.w	r9,r7[0xc]
80006cb2:	6e 28       	ld.w	r8,r7[0x8]
80006cb4:	93 28       	st.w	r9[0x8],r8
80006cb6:	91 39       	st.w	r8[0xc],r9
80006cb8:	e0 ca 00 04 	sub	r10,r0,4
80006cbc:	ee cc ff f8 	sub	r12,r7,-8
80006cc0:	e0 4a 00 24 	cp.w	r10,36
80006cc4:	e0 8b 00 24 	brhi	80006d0c <_realloc_r+0x1dc>
80006cc8:	59 3a       	cp.w	r10,19
80006cca:	e0 88 00 1a 	brls	80006cfe <_realloc_r+0x1ce>
80006cce:	09 08       	ld.w	r8,r4++
80006cd0:	99 08       	st.w	r12[0x0],r8
80006cd2:	09 08       	ld.w	r8,r4++
80006cd4:	8f 38       	st.w	r7[0xc],r8
80006cd6:	ee cc ff f0 	sub	r12,r7,-16
80006cda:	59 ba       	cp.w	r10,27
80006cdc:	e0 88 00 11 	brls	80006cfe <_realloc_r+0x1ce>
80006ce0:	09 08       	ld.w	r8,r4++
80006ce2:	99 08       	st.w	r12[0x0],r8
80006ce4:	09 08       	ld.w	r8,r4++
80006ce6:	8f 58       	st.w	r7[0x14],r8
80006ce8:	ee cc ff e8 	sub	r12,r7,-24
80006cec:	e0 4a 00 24 	cp.w	r10,36
80006cf0:	c0 71       	brne	80006cfe <_realloc_r+0x1ce>
80006cf2:	09 08       	ld.w	r8,r4++
80006cf4:	99 08       	st.w	r12[0x0],r8
80006cf6:	ee cc ff e0 	sub	r12,r7,-32
80006cfa:	09 08       	ld.w	r8,r4++
80006cfc:	8f 78       	st.w	r7[0x1c],r8
80006cfe:	09 08       	ld.w	r8,r4++
80006d00:	18 a8       	st.w	r12++,r8
80006d02:	68 08       	ld.w	r8,r4[0x0]
80006d04:	99 08       	st.w	r12[0x0],r8
80006d06:	68 18       	ld.w	r8,r4[0x4]
80006d08:	99 18       	st.w	r12[0x4],r8
80006d0a:	c4 78       	rjmp	80006d98 <_realloc_r+0x268>
80006d0c:	08 9b       	mov	r11,r4
80006d0e:	e0 a0 1d 42 	rcall	8000a792 <memmove>
80006d12:	c4 38       	rjmp	80006d98 <_realloc_r+0x268>
80006d14:	04 9c       	mov	r12,r2
80006d16:	fe b0 fc 33 	rcall	8000657c <_malloc_r>
80006d1a:	18 95       	mov	r5,r12
80006d1c:	c3 a0       	breq	80006d90 <_realloc_r+0x260>
80006d1e:	62 18       	ld.w	r8,r1[0x4]
80006d20:	f8 c9 00 08 	sub	r9,r12,8
80006d24:	a1 c8       	cbr	r8,0x0
80006d26:	e2 08 00 08 	add	r8,r1,r8
80006d2a:	10 39       	cp.w	r9,r8
80006d2c:	c0 71       	brne	80006d3a <_realloc_r+0x20a>
80006d2e:	72 13       	ld.w	r3,r9[0x4]
80006d30:	02 97       	mov	r7,r1
80006d32:	e0 13 ff fc 	andl	r3,0xfffc
80006d36:	00 03       	add	r3,r0
80006d38:	c3 08       	rjmp	80006d98 <_realloc_r+0x268>
80006d3a:	e0 ca 00 04 	sub	r10,r0,4
80006d3e:	e0 4a 00 24 	cp.w	r10,36
80006d42:	e0 8b 00 20 	brhi	80006d82 <_realloc_r+0x252>
80006d46:	08 99       	mov	r9,r4
80006d48:	18 98       	mov	r8,r12
80006d4a:	59 3a       	cp.w	r10,19
80006d4c:	e0 88 00 14 	brls	80006d74 <_realloc_r+0x244>
80006d50:	13 0b       	ld.w	r11,r9++
80006d52:	10 ab       	st.w	r8++,r11
80006d54:	13 0b       	ld.w	r11,r9++
80006d56:	10 ab       	st.w	r8++,r11
80006d58:	59 ba       	cp.w	r10,27
80006d5a:	e0 88 00 0d 	brls	80006d74 <_realloc_r+0x244>
80006d5e:	13 0b       	ld.w	r11,r9++
80006d60:	10 ab       	st.w	r8++,r11
80006d62:	13 0b       	ld.w	r11,r9++
80006d64:	10 ab       	st.w	r8++,r11
80006d66:	e0 4a 00 24 	cp.w	r10,36
80006d6a:	c0 51       	brne	80006d74 <_realloc_r+0x244>
80006d6c:	13 0a       	ld.w	r10,r9++
80006d6e:	10 aa       	st.w	r8++,r10
80006d70:	13 0a       	ld.w	r10,r9++
80006d72:	10 aa       	st.w	r8++,r10
80006d74:	13 0a       	ld.w	r10,r9++
80006d76:	10 aa       	st.w	r8++,r10
80006d78:	72 0a       	ld.w	r10,r9[0x0]
80006d7a:	91 0a       	st.w	r8[0x0],r10
80006d7c:	72 19       	ld.w	r9,r9[0x4]
80006d7e:	91 19       	st.w	r8[0x4],r9
80006d80:	c0 48       	rjmp	80006d88 <_realloc_r+0x258>
80006d82:	08 9b       	mov	r11,r4
80006d84:	e0 a0 1d 07 	rcall	8000a792 <memmove>
80006d88:	08 9b       	mov	r11,r4
80006d8a:	04 9c       	mov	r12,r2
80006d8c:	e0 a0 1a 60 	rcall	8000a24c <_free_r>
80006d90:	04 9c       	mov	r12,r2
80006d92:	c2 a8       	rjmp	80006de6 <_realloc_r+0x2b6>
80006d94:	00 93       	mov	r3,r0
80006d96:	02 97       	mov	r7,r1
80006d98:	e6 06 01 09 	sub	r9,r3,r6
80006d9c:	6e 18       	ld.w	r8,r7[0x4]
80006d9e:	58 f9       	cp.w	r9,15
80006da0:	e0 88 00 16 	brls	80006dcc <_realloc_r+0x29c>
80006da4:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80006da8:	ed e8 10 08 	or	r8,r6,r8
80006dac:	8f 18       	st.w	r7[0x4],r8
80006dae:	12 98       	mov	r8,r9
80006db0:	a1 a8       	sbr	r8,0x0
80006db2:	ee 06 00 0b 	add	r11,r7,r6
80006db6:	f6 09 00 09 	add	r9,r11,r9
80006dba:	97 18       	st.w	r11[0x4],r8
80006dbc:	72 18       	ld.w	r8,r9[0x4]
80006dbe:	a1 a8       	sbr	r8,0x0
80006dc0:	2f 8b       	sub	r11,-8
80006dc2:	93 18       	st.w	r9[0x4],r8
80006dc4:	04 9c       	mov	r12,r2
80006dc6:	e0 a0 1a 43 	rcall	8000a24c <_free_r>
80006dca:	c0 b8       	rjmp	80006de0 <_realloc_r+0x2b0>
80006dcc:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80006dd0:	e7 e8 10 08 	or	r8,r3,r8
80006dd4:	8f 18       	st.w	r7[0x4],r8
80006dd6:	ee 03 00 03 	add	r3,r7,r3
80006dda:	66 18       	ld.w	r8,r3[0x4]
80006ddc:	a1 a8       	sbr	r8,0x0
80006dde:	87 18       	st.w	r3[0x4],r8
80006de0:	04 9c       	mov	r12,r2
80006de2:	ee c5 ff f8 	sub	r5,r7,-8
80006de6:	fe b0 f2 9b 	rcall	8000531c <__malloc_unlock>
80006dea:	0a 9c       	mov	r12,r5
80006dec:	2f fd       	sub	sp,-4
80006dee:	d8 32       	popm	r0-r7,pc

80006df0 <_sbrk_r>:
80006df0:	d4 21       	pushm	r4-r7,lr
80006df2:	30 08       	mov	r8,0
80006df4:	18 97       	mov	r7,r12
80006df6:	e0 66 1f d4 	mov	r6,8148
80006dfa:	16 9c       	mov	r12,r11
80006dfc:	8d 08       	st.w	r6[0x0],r8
80006dfe:	c8 5c       	rcall	80006f08 <_sbrk>
80006e00:	5b fc       	cp.w	r12,-1
80006e02:	c0 51       	brne	80006e0c <_sbrk_r+0x1c>
80006e04:	6c 08       	ld.w	r8,r6[0x0]
80006e06:	58 08       	cp.w	r8,0
80006e08:	ef f8 1a 03 	st.wne	r7[0xc],r8
80006e0c:	d8 22       	popm	r4-r7,pc
80006e0e:	d7 03       	nop

80006e10 <sprintf>:
80006e10:	d4 01       	pushm	lr
80006e12:	21 7d       	sub	sp,92
80006e14:	e0 68 ff ff 	mov	r8,65535
80006e18:	ea 18 7f ff 	orh	r8,0x7fff
80006e1c:	50 58       	stdsp	sp[0x14],r8
80006e1e:	50 28       	stdsp	sp[0x8],r8
80006e20:	e0 68 02 08 	mov	r8,520
80006e24:	ba 68       	st.h	sp[0xc],r8
80006e26:	3f f8       	mov	r8,-1
80006e28:	ba 78       	st.h	sp[0xe],r8
80006e2a:	e0 68 0a 20 	mov	r8,2592
80006e2e:	50 4c       	stdsp	sp[0x10],r12
80006e30:	16 9a       	mov	r10,r11
80006e32:	50 0c       	stdsp	sp[0x0],r12
80006e34:	fa c9 ff a0 	sub	r9,sp,-96
80006e38:	70 0c       	ld.w	r12,r8[0x0]
80006e3a:	1a 9b       	mov	r11,sp
80006e3c:	e0 a0 02 1a 	rcall	80007270 <_vfprintf_r>
80006e40:	30 09       	mov	r9,0
80006e42:	40 08       	lddsp	r8,sp[0x0]
80006e44:	b0 89       	st.b	r8[0x0],r9
80006e46:	2e 9d       	sub	sp,-92
80006e48:	d8 02       	popm	pc
80006e4a:	d7 03       	nop

80006e4c <strncpy>:
80006e4c:	30 08       	mov	r8,0
80006e4e:	10 3a       	cp.w	r10,r8
80006e50:	5e 0c       	reteq	r12
80006e52:	f6 08 07 09 	ld.ub	r9,r11[r8]
80006e56:	f8 08 0b 09 	st.b	r12[r8],r9
80006e5a:	2f f8       	sub	r8,-1
80006e5c:	58 09       	cp.w	r9,0
80006e5e:	cf 81       	brne	80006e4e <strncpy+0x2>
80006e60:	10 3a       	cp.w	r10,r8
80006e62:	5e 0c       	reteq	r12
80006e64:	f8 08 0b 09 	st.b	r12[r8],r9
80006e68:	2f f8       	sub	r8,-1
80006e6a:	cf bb       	rjmp	80006e60 <strncpy+0x14>

80006e6c <_close>:
80006e6c:	30 28       	mov	r8,2
80006e6e:	d6 73       	breakpoint
80006e70:	3f fc       	mov	r12,-1
80006e72:	35 8b       	mov	r11,88
80006e74:	58 0c       	cp.w	r12,0
80006e76:	5e 4c       	retge	r12
80006e78:	e0 6a 1f d4 	mov	r10,8148
80006e7c:	95 0b       	st.w	r10[0x0],r11
80006e7e:	5e fc       	retal	r12

80006e80 <_lseek>:
80006e80:	30 58       	mov	r8,5
80006e82:	d6 73       	breakpoint
80006e84:	3f fc       	mov	r12,-1
80006e86:	35 8b       	mov	r11,88
80006e88:	58 0c       	cp.w	r12,0
80006e8a:	5e 4c       	retge	r12
80006e8c:	e0 6a 1f d4 	mov	r10,8148
80006e90:	95 0b       	st.w	r10[0x0],r11
80006e92:	5e fc       	retal	r12

80006e94 <isatty>:
80006e94:	30 b8       	mov	r8,11
80006e96:	d6 73       	breakpoint
80006e98:	3f fc       	mov	r12,-1
80006e9a:	35 8b       	mov	r11,88
80006e9c:	58 0c       	cp.w	r12,0
80006e9e:	5e 4c       	retge	r12
80006ea0:	e0 6a 1f d4 	mov	r10,8148
80006ea4:	95 0b       	st.w	r10[0x0],r11
80006ea6:	5e fc       	retal	r12

80006ea8 <_fstat_host>:
80006ea8:	30 98       	mov	r8,9
80006eaa:	d6 73       	breakpoint
80006eac:	3f fc       	mov	r12,-1
80006eae:	35 8b       	mov	r11,88
80006eb0:	58 0c       	cp.w	r12,0
80006eb2:	5e 4c       	retge	r12
80006eb4:	e0 6a 1f d4 	mov	r10,8148
80006eb8:	95 0b       	st.w	r10[0x0],r11
80006eba:	5e fc       	retal	r12

80006ebc <_fstat>:
80006ebc:	d4 21       	pushm	r4-r7,lr
80006ebe:	21 0d       	sub	sp,64
80006ec0:	16 97       	mov	r7,r11
80006ec2:	1a 9b       	mov	r11,sp
80006ec4:	cf 2f       	rcall	80006ea8 <_fstat_host>
80006ec6:	c0 34       	brge	80006ecc <_fstat+0x10>
80006ec8:	3f fc       	mov	r12,-1
80006eca:	c1 c8       	rjmp	80006f02 <_fstat+0x46>
80006ecc:	40 08       	lddsp	r8,sp[0x0]
80006ece:	ae 08       	st.h	r7[0x0],r8
80006ed0:	40 18       	lddsp	r8,sp[0x4]
80006ed2:	ae 18       	st.h	r7[0x2],r8
80006ed4:	40 28       	lddsp	r8,sp[0x8]
80006ed6:	8f 18       	st.w	r7[0x4],r8
80006ed8:	40 38       	lddsp	r8,sp[0xc]
80006eda:	ae 48       	st.h	r7[0x8],r8
80006edc:	40 48       	lddsp	r8,sp[0x10]
80006ede:	ae 58       	st.h	r7[0xa],r8
80006ee0:	40 58       	lddsp	r8,sp[0x14]
80006ee2:	ae 68       	st.h	r7[0xc],r8
80006ee4:	40 68       	lddsp	r8,sp[0x18]
80006ee6:	ae 78       	st.h	r7[0xe],r8
80006ee8:	40 88       	lddsp	r8,sp[0x20]
80006eea:	8f 48       	st.w	r7[0x10],r8
80006eec:	40 a8       	lddsp	r8,sp[0x28]
80006eee:	8f b8       	st.w	r7[0x2c],r8
80006ef0:	40 c8       	lddsp	r8,sp[0x30]
80006ef2:	8f c8       	st.w	r7[0x30],r8
80006ef4:	40 d8       	lddsp	r8,sp[0x34]
80006ef6:	8f 58       	st.w	r7[0x14],r8
80006ef8:	40 e8       	lddsp	r8,sp[0x38]
80006efa:	30 0c       	mov	r12,0
80006efc:	8f 78       	st.w	r7[0x1c],r8
80006efe:	40 f8       	lddsp	r8,sp[0x3c]
80006f00:	8f 98       	st.w	r7[0x24],r8
80006f02:	2f 0d       	sub	sp,-64
80006f04:	d8 22       	popm	r4-r7,pc
80006f06:	d7 03       	nop

80006f08 <_sbrk>:
80006f08:	d4 01       	pushm	lr
80006f0a:	e0 68 0d 10 	mov	r8,3344
80006f0e:	70 09       	ld.w	r9,r8[0x0]
80006f10:	58 09       	cp.w	r9,0
80006f12:	c0 41       	brne	80006f1a <_sbrk+0x12>
80006f14:	e0 69 1f d8 	mov	r9,8152
80006f18:	91 09       	st.w	r8[0x0],r9
80006f1a:	e0 69 0d 10 	mov	r9,3344
80006f1e:	e0 7a 70 00 	mov	r10,94208
80006f22:	72 08       	ld.w	r8,r9[0x0]
80006f24:	f0 0c 00 0c 	add	r12,r8,r12
80006f28:	14 3c       	cp.w	r12,r10
80006f2a:	e0 8b 00 04 	brhi	80006f32 <_sbrk+0x2a>
80006f2e:	93 0c       	st.w	r9[0x0],r12
80006f30:	c0 68       	rjmp	80006f3c <_sbrk+0x34>
80006f32:	e0 a0 18 15 	rcall	80009f5c <__errno>
80006f36:	30 c8       	mov	r8,12
80006f38:	99 08       	st.w	r12[0x0],r8
80006f3a:	3f f8       	mov	r8,-1
80006f3c:	10 9c       	mov	r12,r8
80006f3e:	d8 02       	popm	pc

80006f40 <get_arg>:
80006f40:	d4 31       	pushm	r0-r7,lr
80006f42:	20 8d       	sub	sp,32
80006f44:	fa c4 ff bc 	sub	r4,sp,-68
80006f48:	50 4b       	stdsp	sp[0x10],r11
80006f4a:	68 2e       	ld.w	lr,r4[0x8]
80006f4c:	50 58       	stdsp	sp[0x14],r8
80006f4e:	12 96       	mov	r6,r9
80006f50:	7c 0b       	ld.w	r11,lr[0x0]
80006f52:	70 05       	ld.w	r5,r8[0x0]
80006f54:	50 6e       	stdsp	sp[0x18],lr
80006f56:	58 0b       	cp.w	r11,0
80006f58:	f4 0b 17 00 	moveq	r11,r10
80006f5c:	68 03       	ld.w	r3,r4[0x0]
80006f5e:	68 11       	ld.w	r1,r4[0x4]
80006f60:	40 49       	lddsp	r9,sp[0x10]
80006f62:	30 08       	mov	r8,0
80006f64:	c2 89       	rjmp	800071b4 <get_arg+0x274>
80006f66:	2f fb       	sub	r11,-1
80006f68:	32 5c       	mov	r12,37
80006f6a:	17 8a       	ld.ub	r10,r11[0x0]
80006f6c:	f8 0a 18 00 	cp.b	r10,r12
80006f70:	5f 1e       	srne	lr
80006f72:	f0 0a 18 00 	cp.b	r10,r8
80006f76:	5f 1c       	srne	r12
80006f78:	fd ec 00 0c 	and	r12,lr,r12
80006f7c:	f0 0c 18 00 	cp.b	r12,r8
80006f80:	cf 31       	brne	80006f66 <get_arg+0x26>
80006f82:	58 0a       	cp.w	r10,0
80006f84:	e0 80 01 25 	breq	800071ce <get_arg+0x28e>
80006f88:	30 0c       	mov	r12,0
80006f8a:	3f fa       	mov	r10,-1
80006f8c:	18 90       	mov	r0,r12
80006f8e:	50 3a       	stdsp	sp[0xc],r10
80006f90:	18 94       	mov	r4,r12
80006f92:	18 92       	mov	r2,r12
80006f94:	f8 0c 00 3c 	add	r12,r12,r12<<0x3
80006f98:	16 97       	mov	r7,r11
80006f9a:	50 7c       	stdsp	sp[0x1c],r12
80006f9c:	fe cc 9d f0 	sub	r12,pc,-25104
80006fa0:	0f 3a       	ld.ub	r10,r7++
80006fa2:	f8 0a 07 0e 	ld.ub	lr,r12[r10]
80006fa6:	40 7c       	lddsp	r12,sp[0x1c]
80006fa8:	1c 0c       	add	r12,lr
80006faa:	fe ce 9e c6 	sub	lr,pc,-24890
80006fae:	fc 0c 07 0e 	ld.ub	lr,lr[r12]
80006fb2:	20 1e       	sub	lr,1
80006fb4:	50 0e       	stdsp	sp[0x0],lr
80006fb6:	fe ce 9f 3e 	sub	lr,pc,-24770
80006fba:	fc 0c 07 0c 	ld.ub	r12,lr[r12]
80006fbe:	50 7c       	stdsp	sp[0x1c],r12
80006fc0:	40 0c       	lddsp	r12,sp[0x0]
80006fc2:	58 7c       	cp.w	r12,7
80006fc4:	e0 8b 00 f1 	brhi	800071a6 <get_arg+0x266>
80006fc8:	fe ce a0 f0 	sub	lr,pc,-24336
80006fcc:	fc 0c 03 2f 	ld.w	pc,lr[r12<<0x2]
80006fd0:	36 8b       	mov	r11,104
80006fd2:	f6 0a 18 00 	cp.b	r10,r11
80006fd6:	e0 80 00 e8 	breq	800071a6 <get_arg+0x266>
80006fda:	37 1b       	mov	r11,113
80006fdc:	f6 0a 18 00 	cp.b	r10,r11
80006fe0:	c0 70       	breq	80006fee <get_arg+0xae>
80006fe2:	34 cb       	mov	r11,76
80006fe4:	f6 0a 18 00 	cp.b	r10,r11
80006fe8:	c0 51       	brne	80006ff2 <get_arg+0xb2>
80006fea:	a3 b4       	sbr	r4,0x3
80006fec:	cd d8       	rjmp	800071a6 <get_arg+0x266>
80006fee:	a5 b4       	sbr	r4,0x5
80006ff0:	cd b8       	rjmp	800071a6 <get_arg+0x266>
80006ff2:	08 9a       	mov	r10,r4
80006ff4:	0e 9b       	mov	r11,r7
80006ff6:	a5 aa       	sbr	r10,0x4
80006ff8:	17 3c       	ld.ub	r12,r11++
80006ffa:	a5 b4       	sbr	r4,0x5
80006ffc:	36 ce       	mov	lr,108
80006ffe:	fc 0c 18 00 	cp.b	r12,lr
80007002:	e0 80 00 d3 	breq	800071a8 <get_arg+0x268>
80007006:	14 94       	mov	r4,r10
80007008:	cc f8       	rjmp	800071a6 <get_arg+0x266>
8000700a:	eb d5 c0 05 	bfextu	r5,r5,0x0,0x5
8000700e:	36 7c       	mov	r12,103
80007010:	f8 0a 18 00 	cp.b	r10,r12
80007014:	e0 8b 00 27 	brhi	80007062 <get_arg+0x122>
80007018:	36 5b       	mov	r11,101
8000701a:	f6 0a 18 00 	cp.b	r10,r11
8000701e:	c4 82       	brcc	800070ae <get_arg+0x16e>
80007020:	34 fb       	mov	r11,79
80007022:	f6 0a 18 00 	cp.b	r10,r11
80007026:	c4 80       	breq	800070b6 <get_arg+0x176>
80007028:	e0 8b 00 0c 	brhi	80007040 <get_arg+0x100>
8000702c:	34 5b       	mov	r11,69
8000702e:	f6 0a 18 00 	cp.b	r10,r11
80007032:	c3 e0       	breq	800070ae <get_arg+0x16e>
80007034:	34 7b       	mov	r11,71
80007036:	f6 0a 18 00 	cp.b	r10,r11
8000703a:	c3 a0       	breq	800070ae <get_arg+0x16e>
8000703c:	34 4b       	mov	r11,68
8000703e:	c0 88       	rjmp	8000704e <get_arg+0x10e>
80007040:	35 8b       	mov	r11,88
80007042:	f6 0a 18 00 	cp.b	r10,r11
80007046:	c2 c0       	breq	8000709e <get_arg+0x15e>
80007048:	e0 8b 00 07 	brhi	80007056 <get_arg+0x116>
8000704c:	35 5b       	mov	r11,85
8000704e:	f6 0a 18 00 	cp.b	r10,r11
80007052:	c3 51       	brne	800070bc <get_arg+0x17c>
80007054:	c3 18       	rjmp	800070b6 <get_arg+0x176>
80007056:	36 3b       	mov	r11,99
80007058:	f6 0a 18 00 	cp.b	r10,r11
8000705c:	c2 f0       	breq	800070ba <get_arg+0x17a>
8000705e:	36 4b       	mov	r11,100
80007060:	c0 e8       	rjmp	8000707c <get_arg+0x13c>
80007062:	37 0b       	mov	r11,112
80007064:	f6 0a 18 00 	cp.b	r10,r11
80007068:	c2 50       	breq	800070b2 <get_arg+0x172>
8000706a:	e0 8b 00 0d 	brhi	80007084 <get_arg+0x144>
8000706e:	36 eb       	mov	r11,110
80007070:	f6 0a 18 00 	cp.b	r10,r11
80007074:	c1 f0       	breq	800070b2 <get_arg+0x172>
80007076:	e0 8b 00 14 	brhi	8000709e <get_arg+0x15e>
8000707a:	36 9b       	mov	r11,105
8000707c:	f6 0a 18 00 	cp.b	r10,r11
80007080:	c1 e1       	brne	800070bc <get_arg+0x17c>
80007082:	c0 e8       	rjmp	8000709e <get_arg+0x15e>
80007084:	37 5b       	mov	r11,117
80007086:	f6 0a 18 00 	cp.b	r10,r11
8000708a:	c0 a0       	breq	8000709e <get_arg+0x15e>
8000708c:	37 8b       	mov	r11,120
8000708e:	f6 0a 18 00 	cp.b	r10,r11
80007092:	c0 60       	breq	8000709e <get_arg+0x15e>
80007094:	37 3b       	mov	r11,115
80007096:	f6 0a 18 00 	cp.b	r10,r11
8000709a:	c1 11       	brne	800070bc <get_arg+0x17c>
8000709c:	c0 b8       	rjmp	800070b2 <get_arg+0x172>
8000709e:	ed b4 00 04 	bld	r4,0x4
800070a2:	c0 a0       	breq	800070b6 <get_arg+0x176>
800070a4:	ed b4 00 05 	bld	r4,0x5
800070a8:	c0 91       	brne	800070ba <get_arg+0x17a>
800070aa:	30 20       	mov	r0,2
800070ac:	c0 88       	rjmp	800070bc <get_arg+0x17c>
800070ae:	30 40       	mov	r0,4
800070b0:	c0 68       	rjmp	800070bc <get_arg+0x17c>
800070b2:	30 30       	mov	r0,3
800070b4:	c0 48       	rjmp	800070bc <get_arg+0x17c>
800070b6:	30 10       	mov	r0,1
800070b8:	c0 28       	rjmp	800070bc <get_arg+0x17c>
800070ba:	30 00       	mov	r0,0
800070bc:	40 3b       	lddsp	r11,sp[0xc]
800070be:	5b fb       	cp.w	r11,-1
800070c0:	c0 40       	breq	800070c8 <get_arg+0x188>
800070c2:	e2 0b 09 20 	st.w	r1[r11<<0x2],r0
800070c6:	c7 08       	rjmp	800071a6 <get_arg+0x266>
800070c8:	58 60       	cp.w	r0,6
800070ca:	e0 8b 00 6e 	brhi	800071a6 <get_arg+0x266>
800070ce:	6c 0a       	ld.w	r10,r6[0x0]
800070d0:	ea cc ff ff 	sub	r12,r5,-1
800070d4:	fe ce a1 dc 	sub	lr,pc,-24100
800070d8:	fc 00 03 2f 	ld.w	pc,lr[r0<<0x2]
800070dc:	f4 cb ff f8 	sub	r11,r10,-8
800070e0:	8d 0b       	st.w	r6[0x0],r11
800070e2:	f4 ea 00 00 	ld.d	r10,r10[0]
800070e6:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
800070ea:	c0 f8       	rjmp	80007108 <get_arg+0x1c8>
800070ec:	f4 cb ff fc 	sub	r11,r10,-4
800070f0:	8d 0b       	st.w	r6[0x0],r11
800070f2:	74 0a       	ld.w	r10,r10[0x0]
800070f4:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
800070f8:	c0 88       	rjmp	80007108 <get_arg+0x1c8>
800070fa:	f4 cb ff f8 	sub	r11,r10,-8
800070fe:	8d 0b       	st.w	r6[0x0],r11
80007100:	f4 ea 00 00 	ld.d	r10,r10[0]
80007104:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80007108:	0e 9b       	mov	r11,r7
8000710a:	18 95       	mov	r5,r12
8000710c:	c4 e8       	rjmp	800071a8 <get_arg+0x268>
8000710e:	62 0a       	ld.w	r10,r1[0x0]
80007110:	5b fa       	cp.w	r10,-1
80007112:	c0 b1       	brne	80007128 <get_arg+0x1e8>
80007114:	50 19       	stdsp	sp[0x4],r9
80007116:	50 28       	stdsp	sp[0x8],r8
80007118:	e0 6a 00 80 	mov	r10,128
8000711c:	30 0b       	mov	r11,0
8000711e:	02 9c       	mov	r12,r1
80007120:	fe b0 fd 01 	rcall	80006b22 <memset>
80007124:	40 28       	lddsp	r8,sp[0x8]
80007126:	40 19       	lddsp	r9,sp[0x4]
80007128:	e4 cc 00 01 	sub	r12,r2,1
8000712c:	0e 9b       	mov	r11,r7
8000712e:	50 3c       	stdsp	sp[0xc],r12
80007130:	f2 0c 0c 49 	max	r9,r9,r12
80007134:	c3 a8       	rjmp	800071a8 <get_arg+0x268>
80007136:	62 0a       	ld.w	r10,r1[0x0]
80007138:	5b fa       	cp.w	r10,-1
8000713a:	c0 b1       	brne	80007150 <get_arg+0x210>
8000713c:	50 19       	stdsp	sp[0x4],r9
8000713e:	50 28       	stdsp	sp[0x8],r8
80007140:	e0 6a 00 80 	mov	r10,128
80007144:	30 0b       	mov	r11,0
80007146:	02 9c       	mov	r12,r1
80007148:	fe b0 fc ed 	rcall	80006b22 <memset>
8000714c:	40 28       	lddsp	r8,sp[0x8]
8000714e:	40 19       	lddsp	r9,sp[0x4]
80007150:	20 12       	sub	r2,1
80007152:	30 0a       	mov	r10,0
80007154:	0e 9b       	mov	r11,r7
80007156:	e2 02 09 2a 	st.w	r1[r2<<0x2],r10
8000715a:	f2 02 0c 49 	max	r9,r9,r2
8000715e:	c2 58       	rjmp	800071a8 <get_arg+0x268>
80007160:	16 97       	mov	r7,r11
80007162:	6c 0a       	ld.w	r10,r6[0x0]
80007164:	f4 cb ff fc 	sub	r11,r10,-4
80007168:	8d 0b       	st.w	r6[0x0],r11
8000716a:	74 0a       	ld.w	r10,r10[0x0]
8000716c:	0e 9b       	mov	r11,r7
8000716e:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80007172:	2f f5       	sub	r5,-1
80007174:	c1 a8       	rjmp	800071a8 <get_arg+0x268>
80007176:	f4 c2 00 30 	sub	r2,r10,48
8000717a:	c0 68       	rjmp	80007186 <get_arg+0x246>
8000717c:	e4 02 00 22 	add	r2,r2,r2<<0x2
80007180:	2f f7       	sub	r7,-1
80007182:	f4 02 00 12 	add	r2,r10,r2<<0x1
80007186:	0f 8a       	ld.ub	r10,r7[0x0]
80007188:	58 0a       	cp.w	r10,0
8000718a:	c0 e0       	breq	800071a6 <get_arg+0x266>
8000718c:	23 0a       	sub	r10,48
8000718e:	58 9a       	cp.w	r10,9
80007190:	fe 98 ff f6 	brls	8000717c <get_arg+0x23c>
80007194:	c0 98       	rjmp	800071a6 <get_arg+0x266>
80007196:	2f f7       	sub	r7,-1
80007198:	0f 8a       	ld.ub	r10,r7[0x0]
8000719a:	58 0a       	cp.w	r10,0
8000719c:	c0 50       	breq	800071a6 <get_arg+0x266>
8000719e:	23 0a       	sub	r10,48
800071a0:	58 9a       	cp.w	r10,9
800071a2:	fe 98 ff fa 	brls	80007196 <get_arg+0x256>
800071a6:	0e 9b       	mov	r11,r7
800071a8:	40 7c       	lddsp	r12,sp[0x1c]
800071aa:	30 ba       	mov	r10,11
800071ac:	f4 0c 18 00 	cp.b	r12,r10
800071b0:	fe 91 fe f2 	brne	80006f94 <get_arg+0x54>
800071b4:	40 42       	lddsp	r2,sp[0x10]
800071b6:	17 8c       	ld.ub	r12,r11[0x0]
800071b8:	0a 32       	cp.w	r2,r5
800071ba:	5f 4a       	srge	r10
800071bc:	f0 0c 18 00 	cp.b	r12,r8
800071c0:	5f 1c       	srne	r12
800071c2:	f9 ea 00 0a 	and	r10,r12,r10
800071c6:	f0 0a 18 00 	cp.b	r10,r8
800071ca:	fe 91 fe cf 	brne	80006f68 <get_arg+0x28>
800071ce:	30 08       	mov	r8,0
800071d0:	40 4e       	lddsp	lr,sp[0x10]
800071d2:	17 8a       	ld.ub	r10,r11[0x0]
800071d4:	e2 05 00 21 	add	r1,r1,r5<<0x2
800071d8:	f0 0a 18 00 	cp.b	r10,r8
800071dc:	fc 09 17 10 	movne	r9,lr
800071e0:	e6 05 00 38 	add	r8,r3,r5<<0x3
800071e4:	06 9e       	mov	lr,r3
800071e6:	c2 a8       	rjmp	8000723a <get_arg+0x2fa>
800071e8:	62 0a       	ld.w	r10,r1[0x0]
800071ea:	58 3a       	cp.w	r10,3
800071ec:	c1 e0       	breq	80007228 <get_arg+0x2e8>
800071ee:	e0 89 00 07 	brgt	800071fc <get_arg+0x2bc>
800071f2:	58 1a       	cp.w	r10,1
800071f4:	c1 a0       	breq	80007228 <get_arg+0x2e8>
800071f6:	58 2a       	cp.w	r10,2
800071f8:	c1 81       	brne	80007228 <get_arg+0x2e8>
800071fa:	c0 58       	rjmp	80007204 <get_arg+0x2c4>
800071fc:	58 5a       	cp.w	r10,5
800071fe:	c0 c0       	breq	80007216 <get_arg+0x2d6>
80007200:	c0 b5       	brlt	80007216 <get_arg+0x2d6>
80007202:	c1 38       	rjmp	80007228 <get_arg+0x2e8>
80007204:	6c 0a       	ld.w	r10,r6[0x0]
80007206:	f4 cc ff f8 	sub	r12,r10,-8
8000720a:	8d 0c       	st.w	r6[0x0],r12
8000720c:	f4 e2 00 00 	ld.d	r2,r10[0]
80007210:	f0 e3 00 00 	st.d	r8[0],r2
80007214:	c1 08       	rjmp	80007234 <get_arg+0x2f4>
80007216:	6c 0a       	ld.w	r10,r6[0x0]
80007218:	f4 cc ff f8 	sub	r12,r10,-8
8000721c:	8d 0c       	st.w	r6[0x0],r12
8000721e:	f4 e2 00 00 	ld.d	r2,r10[0]
80007222:	f0 e3 00 00 	st.d	r8[0],r2
80007226:	c0 78       	rjmp	80007234 <get_arg+0x2f4>
80007228:	6c 0a       	ld.w	r10,r6[0x0]
8000722a:	f4 cc ff fc 	sub	r12,r10,-4
8000722e:	8d 0c       	st.w	r6[0x0],r12
80007230:	74 0a       	ld.w	r10,r10[0x0]
80007232:	91 0a       	st.w	r8[0x0],r10
80007234:	2f f5       	sub	r5,-1
80007236:	2f 88       	sub	r8,-8
80007238:	2f c1       	sub	r1,-4
8000723a:	12 35       	cp.w	r5,r9
8000723c:	fe 9a ff d6 	brle	800071e8 <get_arg+0x2a8>
80007240:	1c 93       	mov	r3,lr
80007242:	40 52       	lddsp	r2,sp[0x14]
80007244:	40 6e       	lddsp	lr,sp[0x18]
80007246:	85 05       	st.w	r2[0x0],r5
80007248:	9d 0b       	st.w	lr[0x0],r11
8000724a:	40 4b       	lddsp	r11,sp[0x10]
8000724c:	e6 0b 00 3c 	add	r12,r3,r11<<0x3
80007250:	2f 8d       	sub	sp,-32
80007252:	d8 32       	popm	r0-r7,pc

80007254 <__sprint_r>:
80007254:	d4 21       	pushm	r4-r7,lr
80007256:	14 97       	mov	r7,r10
80007258:	74 28       	ld.w	r8,r10[0x8]
8000725a:	58 08       	cp.w	r8,0
8000725c:	c0 41       	brne	80007264 <__sprint_r+0x10>
8000725e:	95 18       	st.w	r10[0x4],r8
80007260:	10 9c       	mov	r12,r8
80007262:	d8 22       	popm	r4-r7,pc
80007264:	e0 a0 18 ba 	rcall	8000a3d8 <__sfvwrite_r>
80007268:	30 08       	mov	r8,0
8000726a:	8f 18       	st.w	r7[0x4],r8
8000726c:	8f 28       	st.w	r7[0x8],r8
8000726e:	d8 22       	popm	r4-r7,pc

80007270 <_vfprintf_r>:
80007270:	d4 31       	pushm	r0-r7,lr
80007272:	fa cd 06 bc 	sub	sp,sp,1724
80007276:	51 09       	stdsp	sp[0x40],r9
80007278:	16 91       	mov	r1,r11
8000727a:	14 97       	mov	r7,r10
8000727c:	18 95       	mov	r5,r12
8000727e:	e0 a0 1a 1d 	rcall	8000a6b8 <_localeconv_r>
80007282:	78 0c       	ld.w	r12,r12[0x0]
80007284:	50 cc       	stdsp	sp[0x30],r12
80007286:	58 05       	cp.w	r5,0
80007288:	c0 70       	breq	80007296 <_vfprintf_r+0x26>
8000728a:	6a 68       	ld.w	r8,r5[0x18]
8000728c:	58 08       	cp.w	r8,0
8000728e:	c0 41       	brne	80007296 <_vfprintf_r+0x26>
80007290:	0a 9c       	mov	r12,r5
80007292:	e0 a0 17 43 	rcall	8000a118 <__sinit>
80007296:	fe c8 9f da 	sub	r8,pc,-24614
8000729a:	10 31       	cp.w	r1,r8
8000729c:	c0 31       	brne	800072a2 <_vfprintf_r+0x32>
8000729e:	6a 01       	ld.w	r1,r5[0x0]
800072a0:	c0 c8       	rjmp	800072b8 <_vfprintf_r+0x48>
800072a2:	fe c8 9f c6 	sub	r8,pc,-24634
800072a6:	10 31       	cp.w	r1,r8
800072a8:	c0 31       	brne	800072ae <_vfprintf_r+0x3e>
800072aa:	6a 11       	ld.w	r1,r5[0x4]
800072ac:	c0 68       	rjmp	800072b8 <_vfprintf_r+0x48>
800072ae:	fe c8 9f b2 	sub	r8,pc,-24654
800072b2:	10 31       	cp.w	r1,r8
800072b4:	eb f1 00 02 	ld.weq	r1,r5[0x8]
800072b8:	82 68       	ld.sh	r8,r1[0xc]
800072ba:	ed b8 00 03 	bld	r8,0x3
800072be:	c0 41       	brne	800072c6 <_vfprintf_r+0x56>
800072c0:	62 48       	ld.w	r8,r1[0x10]
800072c2:	58 08       	cp.w	r8,0
800072c4:	c0 71       	brne	800072d2 <_vfprintf_r+0x62>
800072c6:	02 9b       	mov	r11,r1
800072c8:	0a 9c       	mov	r12,r5
800072ca:	e0 a0 0f 5d 	rcall	80009184 <__swsetup_r>
800072ce:	e0 81 0f 54 	brne	80009176 <_vfprintf_r+0x1f06>
800072d2:	82 68       	ld.sh	r8,r1[0xc]
800072d4:	10 99       	mov	r9,r8
800072d6:	e2 19 00 1a 	andl	r9,0x1a,COH
800072da:	58 a9       	cp.w	r9,10
800072dc:	c3 c1       	brne	80007354 <_vfprintf_r+0xe4>
800072de:	82 79       	ld.sh	r9,r1[0xe]
800072e0:	30 0a       	mov	r10,0
800072e2:	f4 09 19 00 	cp.h	r9,r10
800072e6:	c3 75       	brlt	80007354 <_vfprintf_r+0xe4>
800072e8:	a1 d8       	cbr	r8,0x1
800072ea:	fb 58 05 d0 	st.h	sp[1488],r8
800072ee:	62 88       	ld.w	r8,r1[0x20]
800072f0:	fb 48 05 e4 	st.w	sp[1508],r8
800072f4:	62 a8       	ld.w	r8,r1[0x28]
800072f6:	fb 48 05 ec 	st.w	sp[1516],r8
800072fa:	fa c8 ff bc 	sub	r8,sp,-68
800072fe:	fb 48 05 d4 	st.w	sp[1492],r8
80007302:	fb 48 05 c4 	st.w	sp[1476],r8
80007306:	e0 68 04 00 	mov	r8,1024
8000730a:	fb 48 05 d8 	st.w	sp[1496],r8
8000730e:	fb 48 05 cc 	st.w	sp[1484],r8
80007312:	30 08       	mov	r8,0
80007314:	fb 59 05 d2 	st.h	sp[1490],r9
80007318:	0e 9a       	mov	r10,r7
8000731a:	41 09       	lddsp	r9,sp[0x40]
8000731c:	fa c7 fa 3c 	sub	r7,sp,-1476
80007320:	fb 48 05 dc 	st.w	sp[1500],r8
80007324:	0a 9c       	mov	r12,r5
80007326:	0e 9b       	mov	r11,r7
80007328:	ca 4f       	rcall	80007270 <_vfprintf_r>
8000732a:	50 bc       	stdsp	sp[0x2c],r12
8000732c:	c0 95       	brlt	8000733e <_vfprintf_r+0xce>
8000732e:	0e 9b       	mov	r11,r7
80007330:	0a 9c       	mov	r12,r5
80007332:	e0 a0 16 1b 	rcall	80009f68 <_fflush_r>
80007336:	40 be       	lddsp	lr,sp[0x2c]
80007338:	f9 be 01 ff 	movne	lr,-1
8000733c:	50 be       	stdsp	sp[0x2c],lr
8000733e:	fb 08 05 d0 	ld.sh	r8,sp[1488]
80007342:	ed b8 00 06 	bld	r8,0x6
80007346:	e0 81 0f 1a 	brne	8000917a <_vfprintf_r+0x1f0a>
8000734a:	82 68       	ld.sh	r8,r1[0xc]
8000734c:	a7 a8       	sbr	r8,0x6
8000734e:	a2 68       	st.h	r1[0xc],r8
80007350:	e0 8f 0f 15 	bral	8000917a <_vfprintf_r+0x1f0a>
80007354:	30 08       	mov	r8,0
80007356:	fb 48 06 b4 	st.w	sp[1716],r8
8000735a:	fb 48 06 90 	st.w	sp[1680],r8
8000735e:	fb 48 06 8c 	st.w	sp[1676],r8
80007362:	fb 48 06 b0 	st.w	sp[1712],r8
80007366:	30 08       	mov	r8,0
80007368:	30 09       	mov	r9,0
8000736a:	50 a7       	stdsp	sp[0x28],r7
8000736c:	50 78       	stdsp	sp[0x1c],r8
8000736e:	fa c3 f9 e0 	sub	r3,sp,-1568
80007372:	3f f8       	mov	r8,-1
80007374:	50 59       	stdsp	sp[0x14],r9
80007376:	fb 43 06 88 	st.w	sp[1672],r3
8000737a:	fb 48 05 44 	st.w	sp[1348],r8
8000737e:	12 9c       	mov	r12,r9
80007380:	50 69       	stdsp	sp[0x18],r9
80007382:	50 d9       	stdsp	sp[0x34],r9
80007384:	50 e9       	stdsp	sp[0x38],r9
80007386:	50 b9       	stdsp	sp[0x2c],r9
80007388:	12 97       	mov	r7,r9
8000738a:	0a 94       	mov	r4,r5
8000738c:	40 a2       	lddsp	r2,sp[0x28]
8000738e:	32 5a       	mov	r10,37
80007390:	30 08       	mov	r8,0
80007392:	c0 28       	rjmp	80007396 <_vfprintf_r+0x126>
80007394:	2f f2       	sub	r2,-1
80007396:	05 89       	ld.ub	r9,r2[0x0]
80007398:	f0 09 18 00 	cp.b	r9,r8
8000739c:	5f 1b       	srne	r11
8000739e:	f4 09 18 00 	cp.b	r9,r10
800073a2:	5f 19       	srne	r9
800073a4:	f3 eb 00 0b 	and	r11,r9,r11
800073a8:	f0 0b 18 00 	cp.b	r11,r8
800073ac:	cf 41       	brne	80007394 <_vfprintf_r+0x124>
800073ae:	40 ab       	lddsp	r11,sp[0x28]
800073b0:	e4 0b 01 06 	sub	r6,r2,r11
800073b4:	c1 e0       	breq	800073f0 <_vfprintf_r+0x180>
800073b6:	fa f8 06 90 	ld.w	r8,sp[1680]
800073ba:	0c 08       	add	r8,r6
800073bc:	87 0b       	st.w	r3[0x0],r11
800073be:	fb 48 06 90 	st.w	sp[1680],r8
800073c2:	87 16       	st.w	r3[0x4],r6
800073c4:	fa f8 06 8c 	ld.w	r8,sp[1676]
800073c8:	2f f8       	sub	r8,-1
800073ca:	fb 48 06 8c 	st.w	sp[1676],r8
800073ce:	58 78       	cp.w	r8,7
800073d0:	e0 89 00 04 	brgt	800073d8 <_vfprintf_r+0x168>
800073d4:	2f 83       	sub	r3,-8
800073d6:	c0 a8       	rjmp	800073ea <_vfprintf_r+0x17a>
800073d8:	fa ca f9 78 	sub	r10,sp,-1672
800073dc:	02 9b       	mov	r11,r1
800073de:	08 9c       	mov	r12,r4
800073e0:	c3 af       	rcall	80007254 <__sprint_r>
800073e2:	e0 81 0e c6 	brne	8000916e <_vfprintf_r+0x1efe>
800073e6:	fa c3 f9 e0 	sub	r3,sp,-1568
800073ea:	40 ba       	lddsp	r10,sp[0x2c]
800073ec:	0c 0a       	add	r10,r6
800073ee:	50 ba       	stdsp	sp[0x2c],r10
800073f0:	05 89       	ld.ub	r9,r2[0x0]
800073f2:	30 08       	mov	r8,0
800073f4:	f0 09 18 00 	cp.b	r9,r8
800073f8:	e0 80 0e aa 	breq	8000914c <_vfprintf_r+0x1edc>
800073fc:	30 09       	mov	r9,0
800073fe:	fb 68 06 bb 	st.b	sp[1723],r8
80007402:	0e 96       	mov	r6,r7
80007404:	e4 c8 ff ff 	sub	r8,r2,-1
80007408:	3f fe       	mov	lr,-1
8000740a:	50 93       	stdsp	sp[0x24],r3
8000740c:	50 41       	stdsp	sp[0x10],r1
8000740e:	0e 93       	mov	r3,r7
80007410:	04 91       	mov	r1,r2
80007412:	50 89       	stdsp	sp[0x20],r9
80007414:	50 a8       	stdsp	sp[0x28],r8
80007416:	50 2e       	stdsp	sp[0x8],lr
80007418:	50 39       	stdsp	sp[0xc],r9
8000741a:	12 95       	mov	r5,r9
8000741c:	12 90       	mov	r0,r9
8000741e:	10 97       	mov	r7,r8
80007420:	08 92       	mov	r2,r4
80007422:	c0 78       	rjmp	80007430 <_vfprintf_r+0x1c0>
80007424:	3f fc       	mov	r12,-1
80007426:	08 97       	mov	r7,r4
80007428:	50 2c       	stdsp	sp[0x8],r12
8000742a:	c0 38       	rjmp	80007430 <_vfprintf_r+0x1c0>
8000742c:	30 0b       	mov	r11,0
8000742e:	50 3b       	stdsp	sp[0xc],r11
80007430:	0f 38       	ld.ub	r8,r7++
80007432:	c0 28       	rjmp	80007436 <_vfprintf_r+0x1c6>
80007434:	12 90       	mov	r0,r9
80007436:	f0 c9 00 20 	sub	r9,r8,32
8000743a:	e0 49 00 58 	cp.w	r9,88
8000743e:	e0 8b 0a 30 	brhi	8000889e <_vfprintf_r+0x162e>
80007442:	fe ca a5 2e 	sub	r10,pc,-23250
80007446:	f4 09 03 2f 	ld.w	pc,r10[r9<<0x2]
8000744a:	50 a7       	stdsp	sp[0x28],r7
8000744c:	50 80       	stdsp	sp[0x20],r0
8000744e:	0c 97       	mov	r7,r6
80007450:	04 94       	mov	r4,r2
80007452:	06 96       	mov	r6,r3
80007454:	02 92       	mov	r2,r1
80007456:	fe c9 a3 06 	sub	r9,pc,-23802
8000745a:	40 93       	lddsp	r3,sp[0x24]
8000745c:	10 90       	mov	r0,r8
8000745e:	40 41       	lddsp	r1,sp[0x10]
80007460:	50 d9       	stdsp	sp[0x34],r9
80007462:	e0 8f 08 8e 	bral	8000857e <_vfprintf_r+0x130e>
80007466:	30 08       	mov	r8,0
80007468:	fb 39 06 bb 	ld.ub	r9,sp[1723]
8000746c:	f0 09 18 00 	cp.b	r9,r8
80007470:	ce 01       	brne	80007430 <_vfprintf_r+0x1c0>
80007472:	32 08       	mov	r8,32
80007474:	c6 e8       	rjmp	80007550 <_vfprintf_r+0x2e0>
80007476:	a1 a5       	sbr	r5,0x0
80007478:	cd cb       	rjmp	80007430 <_vfprintf_r+0x1c0>
8000747a:	0f 89       	ld.ub	r9,r7[0x0]
8000747c:	f2 c8 00 30 	sub	r8,r9,48
80007480:	58 98       	cp.w	r8,9
80007482:	e0 8b 00 1d 	brhi	800074bc <_vfprintf_r+0x24c>
80007486:	ee c8 ff ff 	sub	r8,r7,-1
8000748a:	30 0b       	mov	r11,0
8000748c:	23 09       	sub	r9,48
8000748e:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
80007492:	f2 0b 00 1b 	add	r11,r9,r11<<0x1
80007496:	11 39       	ld.ub	r9,r8++
80007498:	f2 ca 00 30 	sub	r10,r9,48
8000749c:	58 9a       	cp.w	r10,9
8000749e:	fe 98 ff f7 	brls	8000748c <_vfprintf_r+0x21c>
800074a2:	e0 49 00 24 	cp.w	r9,36
800074a6:	cc 31       	brne	8000742c <_vfprintf_r+0x1bc>
800074a8:	e0 4b 00 20 	cp.w	r11,32
800074ac:	e0 89 0e 60 	brgt	8000916c <_vfprintf_r+0x1efc>
800074b0:	20 1b       	sub	r11,1
800074b2:	fa f9 06 b4 	ld.w	r9,sp[1716]
800074b6:	12 3b       	cp.w	r11,r9
800074b8:	c0 95       	brlt	800074ca <_vfprintf_r+0x25a>
800074ba:	c1 08       	rjmp	800074da <_vfprintf_r+0x26a>
800074bc:	fa f9 06 b4 	ld.w	r9,sp[1716]
800074c0:	ec ca ff ff 	sub	r10,r6,-1
800074c4:	12 36       	cp.w	r6,r9
800074c6:	c1 f5       	brlt	80007504 <_vfprintf_r+0x294>
800074c8:	c2 68       	rjmp	80007514 <_vfprintf_r+0x2a4>
800074ca:	fa ce f9 44 	sub	lr,sp,-1724
800074ce:	10 97       	mov	r7,r8
800074d0:	fc 0b 00 3b 	add	r11,lr,r11<<0x3
800074d4:	f6 f0 fd 88 	ld.w	r0,r11[-632]
800074d8:	c3 58       	rjmp	80007542 <_vfprintf_r+0x2d2>
800074da:	10 97       	mov	r7,r8
800074dc:	fa c8 f9 50 	sub	r8,sp,-1712
800074e0:	1a d8       	st.w	--sp,r8
800074e2:	fa c8 fa b8 	sub	r8,sp,-1352
800074e6:	1a d8       	st.w	--sp,r8
800074e8:	fa c8 fb b4 	sub	r8,sp,-1100
800074ec:	02 9a       	mov	r10,r1
800074ee:	1a d8       	st.w	--sp,r8
800074f0:	04 9c       	mov	r12,r2
800074f2:	fa c8 f9 40 	sub	r8,sp,-1728
800074f6:	fa c9 ff b4 	sub	r9,sp,-76
800074fa:	fe b0 fd 23 	rcall	80006f40 <get_arg>
800074fe:	2f dd       	sub	sp,-12
80007500:	78 00       	ld.w	r0,r12[0x0]
80007502:	c2 08       	rjmp	80007542 <_vfprintf_r+0x2d2>
80007504:	fa cc f9 44 	sub	r12,sp,-1724
80007508:	14 96       	mov	r6,r10
8000750a:	f8 03 00 38 	add	r8,r12,r3<<0x3
8000750e:	f0 f0 fd 88 	ld.w	r0,r8[-632]
80007512:	c1 88       	rjmp	80007542 <_vfprintf_r+0x2d2>
80007514:	41 08       	lddsp	r8,sp[0x40]
80007516:	59 f9       	cp.w	r9,31
80007518:	e0 89 00 11 	brgt	8000753a <_vfprintf_r+0x2ca>
8000751c:	f0 cb ff fc 	sub	r11,r8,-4
80007520:	51 0b       	stdsp	sp[0x40],r11
80007522:	70 00       	ld.w	r0,r8[0x0]
80007524:	fa cb f9 44 	sub	r11,sp,-1724
80007528:	f6 09 00 38 	add	r8,r11,r9<<0x3
8000752c:	f1 40 fd 88 	st.w	r8[-632],r0
80007530:	2f f9       	sub	r9,-1
80007532:	14 96       	mov	r6,r10
80007534:	fb 49 06 b4 	st.w	sp[1716],r9
80007538:	c0 58       	rjmp	80007542 <_vfprintf_r+0x2d2>
8000753a:	70 00       	ld.w	r0,r8[0x0]
8000753c:	14 96       	mov	r6,r10
8000753e:	2f c8       	sub	r8,-4
80007540:	51 08       	stdsp	sp[0x40],r8
80007542:	58 00       	cp.w	r0,0
80007544:	fe 94 ff 76 	brge	80007430 <_vfprintf_r+0x1c0>
80007548:	5c 30       	neg	r0
8000754a:	a3 a5       	sbr	r5,0x2
8000754c:	c7 2b       	rjmp	80007430 <_vfprintf_r+0x1c0>
8000754e:	32 b8       	mov	r8,43
80007550:	fb 68 06 bb 	st.b	sp[1723],r8
80007554:	c6 eb       	rjmp	80007430 <_vfprintf_r+0x1c0>
80007556:	0f 38       	ld.ub	r8,r7++
80007558:	e0 48 00 2a 	cp.w	r8,42
8000755c:	c0 30       	breq	80007562 <_vfprintf_r+0x2f2>
8000755e:	30 09       	mov	r9,0
80007560:	c7 98       	rjmp	80007652 <_vfprintf_r+0x3e2>
80007562:	0f 88       	ld.ub	r8,r7[0x0]
80007564:	f0 c9 00 30 	sub	r9,r8,48
80007568:	58 99       	cp.w	r9,9
8000756a:	e0 8b 00 1f 	brhi	800075a8 <_vfprintf_r+0x338>
8000756e:	ee c4 ff ff 	sub	r4,r7,-1
80007572:	30 0b       	mov	r11,0
80007574:	23 08       	sub	r8,48
80007576:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
8000757a:	f0 0b 00 1b 	add	r11,r8,r11<<0x1
8000757e:	09 38       	ld.ub	r8,r4++
80007580:	f0 c9 00 30 	sub	r9,r8,48
80007584:	58 99       	cp.w	r9,9
80007586:	fe 98 ff f7 	brls	80007574 <_vfprintf_r+0x304>
8000758a:	e0 48 00 24 	cp.w	r8,36
8000758e:	fe 91 ff 4f 	brne	8000742c <_vfprintf_r+0x1bc>
80007592:	e0 4b 00 20 	cp.w	r11,32
80007596:	e0 89 0d eb 	brgt	8000916c <_vfprintf_r+0x1efc>
8000759a:	20 1b       	sub	r11,1
8000759c:	fa f8 06 b4 	ld.w	r8,sp[1716]
800075a0:	10 3b       	cp.w	r11,r8
800075a2:	c0 a5       	brlt	800075b6 <_vfprintf_r+0x346>
800075a4:	c1 18       	rjmp	800075c6 <_vfprintf_r+0x356>
800075a6:	d7 03       	nop
800075a8:	fa fa 06 b4 	ld.w	r10,sp[1716]
800075ac:	ec c9 ff ff 	sub	r9,r6,-1
800075b0:	14 36       	cp.w	r6,r10
800075b2:	c1 f5       	brlt	800075f0 <_vfprintf_r+0x380>
800075b4:	c2 88       	rjmp	80007604 <_vfprintf_r+0x394>
800075b6:	fa ca f9 44 	sub	r10,sp,-1724
800075ba:	f4 0b 00 3b 	add	r11,r10,r11<<0x3
800075be:	f6 fb fd 88 	ld.w	r11,r11[-632]
800075c2:	50 2b       	stdsp	sp[0x8],r11
800075c4:	c3 c8       	rjmp	8000763c <_vfprintf_r+0x3cc>
800075c6:	fa c8 f9 50 	sub	r8,sp,-1712
800075ca:	1a d8       	st.w	--sp,r8
800075cc:	fa c8 fa b8 	sub	r8,sp,-1352
800075d0:	1a d8       	st.w	--sp,r8
800075d2:	fa c8 fb b4 	sub	r8,sp,-1100
800075d6:	02 9a       	mov	r10,r1
800075d8:	1a d8       	st.w	--sp,r8
800075da:	04 9c       	mov	r12,r2
800075dc:	fa c8 f9 40 	sub	r8,sp,-1728
800075e0:	fa c9 ff b4 	sub	r9,sp,-76
800075e4:	fe b0 fc ae 	rcall	80006f40 <get_arg>
800075e8:	2f dd       	sub	sp,-12
800075ea:	78 0c       	ld.w	r12,r12[0x0]
800075ec:	50 2c       	stdsp	sp[0x8],r12
800075ee:	c2 78       	rjmp	8000763c <_vfprintf_r+0x3cc>
800075f0:	12 96       	mov	r6,r9
800075f2:	0e 94       	mov	r4,r7
800075f4:	fa c9 f9 44 	sub	r9,sp,-1724
800075f8:	f2 03 00 38 	add	r8,r9,r3<<0x3
800075fc:	f0 f8 fd 88 	ld.w	r8,r8[-632]
80007600:	50 28       	stdsp	sp[0x8],r8
80007602:	c1 d8       	rjmp	8000763c <_vfprintf_r+0x3cc>
80007604:	41 08       	lddsp	r8,sp[0x40]
80007606:	59 fa       	cp.w	r10,31
80007608:	e0 89 00 14 	brgt	80007630 <_vfprintf_r+0x3c0>
8000760c:	f0 cb ff fc 	sub	r11,r8,-4
80007610:	70 08       	ld.w	r8,r8[0x0]
80007612:	51 0b       	stdsp	sp[0x40],r11
80007614:	50 28       	stdsp	sp[0x8],r8
80007616:	fa c6 f9 44 	sub	r6,sp,-1724
8000761a:	40 2e       	lddsp	lr,sp[0x8]
8000761c:	ec 0a 00 38 	add	r8,r6,r10<<0x3
80007620:	f1 4e fd 88 	st.w	r8[-632],lr
80007624:	2f fa       	sub	r10,-1
80007626:	0e 94       	mov	r4,r7
80007628:	fb 4a 06 b4 	st.w	sp[1716],r10
8000762c:	12 96       	mov	r6,r9
8000762e:	c0 78       	rjmp	8000763c <_vfprintf_r+0x3cc>
80007630:	70 0c       	ld.w	r12,r8[0x0]
80007632:	0e 94       	mov	r4,r7
80007634:	2f c8       	sub	r8,-4
80007636:	50 2c       	stdsp	sp[0x8],r12
80007638:	12 96       	mov	r6,r9
8000763a:	51 08       	stdsp	sp[0x40],r8
8000763c:	40 2b       	lddsp	r11,sp[0x8]
8000763e:	58 0b       	cp.w	r11,0
80007640:	fe 95 fe f2 	brlt	80007424 <_vfprintf_r+0x1b4>
80007644:	08 97       	mov	r7,r4
80007646:	cf 5a       	rjmp	80007430 <_vfprintf_r+0x1c0>
80007648:	f2 09 00 29 	add	r9,r9,r9<<0x2
8000764c:	0f 38       	ld.ub	r8,r7++
8000764e:	f4 09 00 19 	add	r9,r10,r9<<0x1
80007652:	f0 ca 00 30 	sub	r10,r8,48
80007656:	58 9a       	cp.w	r10,9
80007658:	fe 98 ff f8 	brls	80007648 <_vfprintf_r+0x3d8>
8000765c:	3f fa       	mov	r10,-1
8000765e:	f2 0a 0c 49 	max	r9,r9,r10
80007662:	50 29       	stdsp	sp[0x8],r9
80007664:	ce 9a       	rjmp	80007436 <_vfprintf_r+0x1c6>
80007666:	a7 b5       	sbr	r5,0x7
80007668:	ce 4a       	rjmp	80007430 <_vfprintf_r+0x1c0>
8000766a:	30 09       	mov	r9,0
8000766c:	23 08       	sub	r8,48
8000766e:	f2 09 00 29 	add	r9,r9,r9<<0x2
80007672:	f0 09 00 19 	add	r9,r8,r9<<0x1
80007676:	0f 38       	ld.ub	r8,r7++
80007678:	f0 ca 00 30 	sub	r10,r8,48
8000767c:	58 9a       	cp.w	r10,9
8000767e:	fe 98 ff f7 	brls	8000766c <_vfprintf_r+0x3fc>
80007682:	e0 48 00 24 	cp.w	r8,36
80007686:	fe 91 fe d7 	brne	80007434 <_vfprintf_r+0x1c4>
8000768a:	e0 49 00 20 	cp.w	r9,32
8000768e:	e0 89 0d 6f 	brgt	8000916c <_vfprintf_r+0x1efc>
80007692:	f2 c3 00 01 	sub	r3,r9,1
80007696:	30 19       	mov	r9,1
80007698:	50 39       	stdsp	sp[0xc],r9
8000769a:	cc ba       	rjmp	80007430 <_vfprintf_r+0x1c0>
8000769c:	a3 b5       	sbr	r5,0x3
8000769e:	cc 9a       	rjmp	80007430 <_vfprintf_r+0x1c0>
800076a0:	a7 a5       	sbr	r5,0x6
800076a2:	cc 7a       	rjmp	80007430 <_vfprintf_r+0x1c0>
800076a4:	0a 98       	mov	r8,r5
800076a6:	a5 b5       	sbr	r5,0x5
800076a8:	a5 a8       	sbr	r8,0x4
800076aa:	0f 89       	ld.ub	r9,r7[0x0]
800076ac:	36 ce       	mov	lr,108
800076ae:	fc 09 18 00 	cp.b	r9,lr
800076b2:	f7 b7 00 ff 	subeq	r7,-1
800076b6:	f0 05 17 10 	movne	r5,r8
800076ba:	cb ba       	rjmp	80007430 <_vfprintf_r+0x1c0>
800076bc:	a5 b5       	sbr	r5,0x5
800076be:	cb 9a       	rjmp	80007430 <_vfprintf_r+0x1c0>
800076c0:	50 a7       	stdsp	sp[0x28],r7
800076c2:	50 80       	stdsp	sp[0x20],r0
800076c4:	0c 97       	mov	r7,r6
800076c6:	10 90       	mov	r0,r8
800076c8:	06 96       	mov	r6,r3
800076ca:	04 94       	mov	r4,r2
800076cc:	40 93       	lddsp	r3,sp[0x24]
800076ce:	02 92       	mov	r2,r1
800076d0:	0e 99       	mov	r9,r7
800076d2:	40 41       	lddsp	r1,sp[0x10]
800076d4:	fa f8 06 b4 	ld.w	r8,sp[1716]
800076d8:	40 3c       	lddsp	r12,sp[0xc]
800076da:	58 0c       	cp.w	r12,0
800076dc:	c1 d0       	breq	80007716 <_vfprintf_r+0x4a6>
800076de:	10 36       	cp.w	r6,r8
800076e0:	c0 64       	brge	800076ec <_vfprintf_r+0x47c>
800076e2:	fa cb f9 44 	sub	r11,sp,-1724
800076e6:	f6 06 00 36 	add	r6,r11,r6<<0x3
800076ea:	c1 d8       	rjmp	80007724 <_vfprintf_r+0x4b4>
800076ec:	fa c8 f9 50 	sub	r8,sp,-1712
800076f0:	1a d8       	st.w	--sp,r8
800076f2:	fa c8 fa b8 	sub	r8,sp,-1352
800076f6:	1a d8       	st.w	--sp,r8
800076f8:	fa c8 fb b4 	sub	r8,sp,-1100
800076fc:	1a d8       	st.w	--sp,r8
800076fe:	fa c8 f9 40 	sub	r8,sp,-1728
80007702:	fa c9 ff b4 	sub	r9,sp,-76
80007706:	04 9a       	mov	r10,r2
80007708:	0c 9b       	mov	r11,r6
8000770a:	08 9c       	mov	r12,r4
8000770c:	fe b0 fc 1a 	rcall	80006f40 <get_arg>
80007710:	2f dd       	sub	sp,-12
80007712:	19 b8       	ld.ub	r8,r12[0x3]
80007714:	c2 28       	rjmp	80007758 <_vfprintf_r+0x4e8>
80007716:	2f f7       	sub	r7,-1
80007718:	10 39       	cp.w	r9,r8
8000771a:	c0 84       	brge	8000772a <_vfprintf_r+0x4ba>
8000771c:	fa ca f9 44 	sub	r10,sp,-1724
80007720:	f4 06 00 36 	add	r6,r10,r6<<0x3
80007724:	ed 38 fd 8b 	ld.ub	r8,r6[-629]
80007728:	c1 88       	rjmp	80007758 <_vfprintf_r+0x4e8>
8000772a:	41 09       	lddsp	r9,sp[0x40]
8000772c:	59 f8       	cp.w	r8,31
8000772e:	e0 89 00 12 	brgt	80007752 <_vfprintf_r+0x4e2>
80007732:	f2 ca ff fc 	sub	r10,r9,-4
80007736:	51 0a       	stdsp	sp[0x40],r10
80007738:	72 09       	ld.w	r9,r9[0x0]
8000773a:	fa c6 f9 44 	sub	r6,sp,-1724
8000773e:	ec 08 00 3a 	add	r10,r6,r8<<0x3
80007742:	2f f8       	sub	r8,-1
80007744:	f5 49 fd 88 	st.w	r10[-632],r9
80007748:	fb 48 06 b4 	st.w	sp[1716],r8
8000774c:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
80007750:	c0 48       	rjmp	80007758 <_vfprintf_r+0x4e8>
80007752:	13 b8       	ld.ub	r8,r9[0x3]
80007754:	2f c9       	sub	r9,-4
80007756:	51 09       	stdsp	sp[0x40],r9
80007758:	fb 68 06 60 	st.b	sp[1632],r8
8000775c:	30 0e       	mov	lr,0
8000775e:	30 08       	mov	r8,0
80007760:	30 12       	mov	r2,1
80007762:	fb 68 06 bb 	st.b	sp[1723],r8
80007766:	50 2e       	stdsp	sp[0x8],lr
80007768:	e0 8f 08 ad 	bral	800088c2 <_vfprintf_r+0x1652>
8000776c:	50 a7       	stdsp	sp[0x28],r7
8000776e:	50 80       	stdsp	sp[0x20],r0
80007770:	0c 97       	mov	r7,r6
80007772:	04 94       	mov	r4,r2
80007774:	06 96       	mov	r6,r3
80007776:	02 92       	mov	r2,r1
80007778:	40 93       	lddsp	r3,sp[0x24]
8000777a:	10 90       	mov	r0,r8
8000777c:	40 41       	lddsp	r1,sp[0x10]
8000777e:	a5 a5       	sbr	r5,0x4
80007780:	c0 a8       	rjmp	80007794 <_vfprintf_r+0x524>
80007782:	50 a7       	stdsp	sp[0x28],r7
80007784:	50 80       	stdsp	sp[0x20],r0
80007786:	0c 97       	mov	r7,r6
80007788:	04 94       	mov	r4,r2
8000778a:	06 96       	mov	r6,r3
8000778c:	02 92       	mov	r2,r1
8000778e:	40 93       	lddsp	r3,sp[0x24]
80007790:	10 90       	mov	r0,r8
80007792:	40 41       	lddsp	r1,sp[0x10]
80007794:	ed b5 00 05 	bld	r5,0x5
80007798:	c5 11       	brne	8000783a <_vfprintf_r+0x5ca>
8000779a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000779e:	40 3c       	lddsp	r12,sp[0xc]
800077a0:	58 0c       	cp.w	r12,0
800077a2:	c1 e0       	breq	800077de <_vfprintf_r+0x56e>
800077a4:	10 36       	cp.w	r6,r8
800077a6:	c0 64       	brge	800077b2 <_vfprintf_r+0x542>
800077a8:	fa cb f9 44 	sub	r11,sp,-1724
800077ac:	f6 06 00 36 	add	r6,r11,r6<<0x3
800077b0:	c2 08       	rjmp	800077f0 <_vfprintf_r+0x580>
800077b2:	fa c8 f9 50 	sub	r8,sp,-1712
800077b6:	1a d8       	st.w	--sp,r8
800077b8:	fa c8 fa b8 	sub	r8,sp,-1352
800077bc:	0c 9b       	mov	r11,r6
800077be:	1a d8       	st.w	--sp,r8
800077c0:	fa c8 fb b4 	sub	r8,sp,-1100
800077c4:	1a d8       	st.w	--sp,r8
800077c6:	fa c9 ff b4 	sub	r9,sp,-76
800077ca:	fa c8 f9 40 	sub	r8,sp,-1728
800077ce:	04 9a       	mov	r10,r2
800077d0:	08 9c       	mov	r12,r4
800077d2:	fe b0 fb b7 	rcall	80006f40 <get_arg>
800077d6:	2f dd       	sub	sp,-12
800077d8:	78 1b       	ld.w	r11,r12[0x4]
800077da:	78 09       	ld.w	r9,r12[0x0]
800077dc:	c2 b8       	rjmp	80007832 <_vfprintf_r+0x5c2>
800077de:	ee ca ff ff 	sub	r10,r7,-1
800077e2:	10 37       	cp.w	r7,r8
800077e4:	c0 b4       	brge	800077fa <_vfprintf_r+0x58a>
800077e6:	fa c9 f9 44 	sub	r9,sp,-1724
800077ea:	14 97       	mov	r7,r10
800077ec:	f2 06 00 36 	add	r6,r9,r6<<0x3
800077f0:	ec fb fd 8c 	ld.w	r11,r6[-628]
800077f4:	ec f9 fd 88 	ld.w	r9,r6[-632]
800077f8:	c1 d8       	rjmp	80007832 <_vfprintf_r+0x5c2>
800077fa:	41 09       	lddsp	r9,sp[0x40]
800077fc:	59 f8       	cp.w	r8,31
800077fe:	e0 89 00 14 	brgt	80007826 <_vfprintf_r+0x5b6>
80007802:	f2 cb ff f8 	sub	r11,r9,-8
80007806:	51 0b       	stdsp	sp[0x40],r11
80007808:	fa c6 f9 44 	sub	r6,sp,-1724
8000780c:	72 1b       	ld.w	r11,r9[0x4]
8000780e:	ec 08 00 3c 	add	r12,r6,r8<<0x3
80007812:	72 09       	ld.w	r9,r9[0x0]
80007814:	f9 4b fd 8c 	st.w	r12[-628],r11
80007818:	f9 49 fd 88 	st.w	r12[-632],r9
8000781c:	2f f8       	sub	r8,-1
8000781e:	14 97       	mov	r7,r10
80007820:	fb 48 06 b4 	st.w	sp[1716],r8
80007824:	c0 78       	rjmp	80007832 <_vfprintf_r+0x5c2>
80007826:	f2 c8 ff f8 	sub	r8,r9,-8
8000782a:	72 1b       	ld.w	r11,r9[0x4]
8000782c:	14 97       	mov	r7,r10
8000782e:	51 08       	stdsp	sp[0x40],r8
80007830:	72 09       	ld.w	r9,r9[0x0]
80007832:	16 98       	mov	r8,r11
80007834:	fa e9 00 00 	st.d	sp[0],r8
80007838:	ca e8       	rjmp	80007994 <_vfprintf_r+0x724>
8000783a:	ed b5 00 04 	bld	r5,0x4
8000783e:	c1 71       	brne	8000786c <_vfprintf_r+0x5fc>
80007840:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007844:	40 3e       	lddsp	lr,sp[0xc]
80007846:	58 0e       	cp.w	lr,0
80007848:	c0 80       	breq	80007858 <_vfprintf_r+0x5e8>
8000784a:	10 36       	cp.w	r6,r8
8000784c:	c6 94       	brge	8000791e <_vfprintf_r+0x6ae>
8000784e:	fa cc f9 44 	sub	r12,sp,-1724
80007852:	f8 06 00 36 	add	r6,r12,r6<<0x3
80007856:	c8 28       	rjmp	8000795a <_vfprintf_r+0x6ea>
80007858:	ee ca ff ff 	sub	r10,r7,-1
8000785c:	10 37       	cp.w	r7,r8
8000785e:	e0 84 00 81 	brge	80007960 <_vfprintf_r+0x6f0>
80007862:	fa cb f9 44 	sub	r11,sp,-1724
80007866:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000786a:	c7 78       	rjmp	80007958 <_vfprintf_r+0x6e8>
8000786c:	ed b5 00 06 	bld	r5,0x6
80007870:	c4 b1       	brne	80007906 <_vfprintf_r+0x696>
80007872:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007876:	40 3c       	lddsp	r12,sp[0xc]
80007878:	58 0c       	cp.w	r12,0
8000787a:	c1 d0       	breq	800078b4 <_vfprintf_r+0x644>
8000787c:	10 36       	cp.w	r6,r8
8000787e:	c0 64       	brge	8000788a <_vfprintf_r+0x61a>
80007880:	fa cb f9 44 	sub	r11,sp,-1724
80007884:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007888:	c1 f8       	rjmp	800078c6 <_vfprintf_r+0x656>
8000788a:	fa c8 f9 50 	sub	r8,sp,-1712
8000788e:	1a d8       	st.w	--sp,r8
80007890:	fa c8 fa b8 	sub	r8,sp,-1352
80007894:	1a d8       	st.w	--sp,r8
80007896:	fa c8 fb b4 	sub	r8,sp,-1100
8000789a:	1a d8       	st.w	--sp,r8
8000789c:	fa c8 f9 40 	sub	r8,sp,-1728
800078a0:	fa c9 ff b4 	sub	r9,sp,-76
800078a4:	04 9a       	mov	r10,r2
800078a6:	0c 9b       	mov	r11,r6
800078a8:	08 9c       	mov	r12,r4
800078aa:	fe b0 fb 4b 	rcall	80006f40 <get_arg>
800078ae:	2f dd       	sub	sp,-12
800078b0:	98 18       	ld.sh	r8,r12[0x2]
800078b2:	c2 68       	rjmp	800078fe <_vfprintf_r+0x68e>
800078b4:	ee ca ff ff 	sub	r10,r7,-1
800078b8:	10 37       	cp.w	r7,r8
800078ba:	c0 94       	brge	800078cc <_vfprintf_r+0x65c>
800078bc:	fa c9 f9 44 	sub	r9,sp,-1724
800078c0:	14 97       	mov	r7,r10
800078c2:	f2 06 00 36 	add	r6,r9,r6<<0x3
800078c6:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
800078ca:	c1 a8       	rjmp	800078fe <_vfprintf_r+0x68e>
800078cc:	41 09       	lddsp	r9,sp[0x40]
800078ce:	59 f8       	cp.w	r8,31
800078d0:	e0 89 00 13 	brgt	800078f6 <_vfprintf_r+0x686>
800078d4:	f2 cb ff fc 	sub	r11,r9,-4
800078d8:	51 0b       	stdsp	sp[0x40],r11
800078da:	72 09       	ld.w	r9,r9[0x0]
800078dc:	fa c6 f9 44 	sub	r6,sp,-1724
800078e0:	ec 08 00 3b 	add	r11,r6,r8<<0x3
800078e4:	2f f8       	sub	r8,-1
800078e6:	f7 49 fd 88 	st.w	r11[-632],r9
800078ea:	fb 48 06 b4 	st.w	sp[1716],r8
800078ee:	14 97       	mov	r7,r10
800078f0:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
800078f4:	c0 58       	rjmp	800078fe <_vfprintf_r+0x68e>
800078f6:	92 18       	ld.sh	r8,r9[0x2]
800078f8:	14 97       	mov	r7,r10
800078fa:	2f c9       	sub	r9,-4
800078fc:	51 09       	stdsp	sp[0x40],r9
800078fe:	50 18       	stdsp	sp[0x4],r8
80007900:	bf 58       	asr	r8,0x1f
80007902:	50 08       	stdsp	sp[0x0],r8
80007904:	c4 88       	rjmp	80007994 <_vfprintf_r+0x724>
80007906:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000790a:	40 3c       	lddsp	r12,sp[0xc]
8000790c:	58 0c       	cp.w	r12,0
8000790e:	c1 d0       	breq	80007948 <_vfprintf_r+0x6d8>
80007910:	10 36       	cp.w	r6,r8
80007912:	c0 64       	brge	8000791e <_vfprintf_r+0x6ae>
80007914:	fa cb f9 44 	sub	r11,sp,-1724
80007918:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000791c:	c1 f8       	rjmp	8000795a <_vfprintf_r+0x6ea>
8000791e:	fa c8 f9 50 	sub	r8,sp,-1712
80007922:	1a d8       	st.w	--sp,r8
80007924:	fa c8 fa b8 	sub	r8,sp,-1352
80007928:	0c 9b       	mov	r11,r6
8000792a:	1a d8       	st.w	--sp,r8
8000792c:	fa c8 fb b4 	sub	r8,sp,-1100
80007930:	04 9a       	mov	r10,r2
80007932:	1a d8       	st.w	--sp,r8
80007934:	08 9c       	mov	r12,r4
80007936:	fa c8 f9 40 	sub	r8,sp,-1728
8000793a:	fa c9 ff b4 	sub	r9,sp,-76
8000793e:	fe b0 fb 01 	rcall	80006f40 <get_arg>
80007942:	2f dd       	sub	sp,-12
80007944:	78 0b       	ld.w	r11,r12[0x0]
80007946:	c2 48       	rjmp	8000798e <_vfprintf_r+0x71e>
80007948:	ee ca ff ff 	sub	r10,r7,-1
8000794c:	10 37       	cp.w	r7,r8
8000794e:	c0 94       	brge	80007960 <_vfprintf_r+0x6f0>
80007950:	fa c9 f9 44 	sub	r9,sp,-1724
80007954:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007958:	14 97       	mov	r7,r10
8000795a:	ec fb fd 88 	ld.w	r11,r6[-632]
8000795e:	c1 88       	rjmp	8000798e <_vfprintf_r+0x71e>
80007960:	41 09       	lddsp	r9,sp[0x40]
80007962:	59 f8       	cp.w	r8,31
80007964:	e0 89 00 11 	brgt	80007986 <_vfprintf_r+0x716>
80007968:	f2 cb ff fc 	sub	r11,r9,-4
8000796c:	51 0b       	stdsp	sp[0x40],r11
8000796e:	fa c6 f9 44 	sub	r6,sp,-1724
80007972:	72 0b       	ld.w	r11,r9[0x0]
80007974:	ec 08 00 39 	add	r9,r6,r8<<0x3
80007978:	f3 4b fd 88 	st.w	r9[-632],r11
8000797c:	2f f8       	sub	r8,-1
8000797e:	14 97       	mov	r7,r10
80007980:	fb 48 06 b4 	st.w	sp[1716],r8
80007984:	c0 58       	rjmp	8000798e <_vfprintf_r+0x71e>
80007986:	72 0b       	ld.w	r11,r9[0x0]
80007988:	14 97       	mov	r7,r10
8000798a:	2f c9       	sub	r9,-4
8000798c:	51 09       	stdsp	sp[0x40],r9
8000798e:	50 1b       	stdsp	sp[0x4],r11
80007990:	bf 5b       	asr	r11,0x1f
80007992:	50 0b       	stdsp	sp[0x0],r11
80007994:	fa ea 00 00 	ld.d	r10,sp[0]
80007998:	58 0a       	cp.w	r10,0
8000799a:	5c 2b       	cpc	r11
8000799c:	c0 e4       	brge	800079b8 <_vfprintf_r+0x748>
8000799e:	30 08       	mov	r8,0
800079a0:	fa ea 00 00 	ld.d	r10,sp[0]
800079a4:	30 09       	mov	r9,0
800079a6:	f0 0a 01 0a 	sub	r10,r8,r10
800079aa:	f2 0b 01 4b 	sbc	r11,r9,r11
800079ae:	32 d8       	mov	r8,45
800079b0:	fa eb 00 00 	st.d	sp[0],r10
800079b4:	fb 68 06 bb 	st.b	sp[1723],r8
800079b8:	30 18       	mov	r8,1
800079ba:	e0 8f 06 fa 	bral	800087ae <_vfprintf_r+0x153e>
800079be:	50 a7       	stdsp	sp[0x28],r7
800079c0:	50 80       	stdsp	sp[0x20],r0
800079c2:	0c 97       	mov	r7,r6
800079c4:	04 94       	mov	r4,r2
800079c6:	06 96       	mov	r6,r3
800079c8:	02 92       	mov	r2,r1
800079ca:	40 93       	lddsp	r3,sp[0x24]
800079cc:	10 90       	mov	r0,r8
800079ce:	40 41       	lddsp	r1,sp[0x10]
800079d0:	0e 99       	mov	r9,r7
800079d2:	ed b5 00 03 	bld	r5,0x3
800079d6:	c4 11       	brne	80007a58 <_vfprintf_r+0x7e8>
800079d8:	fa f8 06 b4 	ld.w	r8,sp[1716]
800079dc:	40 3a       	lddsp	r10,sp[0xc]
800079de:	58 0a       	cp.w	r10,0
800079e0:	c1 90       	breq	80007a12 <_vfprintf_r+0x7a2>
800079e2:	10 36       	cp.w	r6,r8
800079e4:	c6 45       	brlt	80007aac <_vfprintf_r+0x83c>
800079e6:	fa c8 f9 50 	sub	r8,sp,-1712
800079ea:	1a d8       	st.w	--sp,r8
800079ec:	fa c8 fa b8 	sub	r8,sp,-1352
800079f0:	1a d8       	st.w	--sp,r8
800079f2:	fa c8 fb b4 	sub	r8,sp,-1100
800079f6:	0c 9b       	mov	r11,r6
800079f8:	1a d8       	st.w	--sp,r8
800079fa:	04 9a       	mov	r10,r2
800079fc:	fa c8 f9 40 	sub	r8,sp,-1728
80007a00:	fa c9 ff b4 	sub	r9,sp,-76
80007a04:	08 9c       	mov	r12,r4
80007a06:	fe b0 fa 9d 	rcall	80006f40 <get_arg>
80007a0a:	2f dd       	sub	sp,-12
80007a0c:	78 16       	ld.w	r6,r12[0x4]
80007a0e:	50 76       	stdsp	sp[0x1c],r6
80007a10:	c4 88       	rjmp	80007aa0 <_vfprintf_r+0x830>
80007a12:	2f f7       	sub	r7,-1
80007a14:	10 39       	cp.w	r9,r8
80007a16:	c0 c4       	brge	80007a2e <_vfprintf_r+0x7be>
80007a18:	fa ce f9 44 	sub	lr,sp,-1724
80007a1c:	fc 06 00 36 	add	r6,lr,r6<<0x3
80007a20:	ec fc fd 8c 	ld.w	r12,r6[-628]
80007a24:	50 7c       	stdsp	sp[0x1c],r12
80007a26:	ec f6 fd 88 	ld.w	r6,r6[-632]
80007a2a:	50 56       	stdsp	sp[0x14],r6
80007a2c:	c6 68       	rjmp	80007af8 <_vfprintf_r+0x888>
80007a2e:	41 09       	lddsp	r9,sp[0x40]
80007a30:	59 f8       	cp.w	r8,31
80007a32:	e0 89 00 10 	brgt	80007a52 <_vfprintf_r+0x7e2>
80007a36:	f2 ca ff f8 	sub	r10,r9,-8
80007a3a:	72 1b       	ld.w	r11,r9[0x4]
80007a3c:	51 0a       	stdsp	sp[0x40],r10
80007a3e:	72 09       	ld.w	r9,r9[0x0]
80007a40:	fa ca f9 44 	sub	r10,sp,-1724
80007a44:	50 7b       	stdsp	sp[0x1c],r11
80007a46:	50 59       	stdsp	sp[0x14],r9
80007a48:	f4 08 00 39 	add	r9,r10,r8<<0x3
80007a4c:	40 5b       	lddsp	r11,sp[0x14]
80007a4e:	40 7a       	lddsp	r10,sp[0x1c]
80007a50:	c4 78       	rjmp	80007ade <_vfprintf_r+0x86e>
80007a52:	72 18       	ld.w	r8,r9[0x4]
80007a54:	50 78       	stdsp	sp[0x1c],r8
80007a56:	c4 c8       	rjmp	80007aee <_vfprintf_r+0x87e>
80007a58:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007a5c:	40 3e       	lddsp	lr,sp[0xc]
80007a5e:	58 0e       	cp.w	lr,0
80007a60:	c2 30       	breq	80007aa6 <_vfprintf_r+0x836>
80007a62:	10 36       	cp.w	r6,r8
80007a64:	c0 94       	brge	80007a76 <_vfprintf_r+0x806>
80007a66:	fa cc f9 44 	sub	r12,sp,-1724
80007a6a:	f8 06 00 36 	add	r6,r12,r6<<0x3
80007a6e:	ec fb fd 8c 	ld.w	r11,r6[-628]
80007a72:	50 7b       	stdsp	sp[0x1c],r11
80007a74:	cd 9b       	rjmp	80007a26 <_vfprintf_r+0x7b6>
80007a76:	fa c8 f9 50 	sub	r8,sp,-1712
80007a7a:	1a d8       	st.w	--sp,r8
80007a7c:	fa c8 fa b8 	sub	r8,sp,-1352
80007a80:	04 9a       	mov	r10,r2
80007a82:	1a d8       	st.w	--sp,r8
80007a84:	fa c8 fb b4 	sub	r8,sp,-1100
80007a88:	0c 9b       	mov	r11,r6
80007a8a:	1a d8       	st.w	--sp,r8
80007a8c:	08 9c       	mov	r12,r4
80007a8e:	fa c8 f9 40 	sub	r8,sp,-1728
80007a92:	fa c9 ff b4 	sub	r9,sp,-76
80007a96:	fe b0 fa 55 	rcall	80006f40 <get_arg>
80007a9a:	2f dd       	sub	sp,-12
80007a9c:	78 1a       	ld.w	r10,r12[0x4]
80007a9e:	50 7a       	stdsp	sp[0x1c],r10
80007aa0:	78 0c       	ld.w	r12,r12[0x0]
80007aa2:	50 5c       	stdsp	sp[0x14],r12
80007aa4:	c2 a8       	rjmp	80007af8 <_vfprintf_r+0x888>
80007aa6:	2f f7       	sub	r7,-1
80007aa8:	10 39       	cp.w	r9,r8
80007aaa:	c0 94       	brge	80007abc <_vfprintf_r+0x84c>
80007aac:	fa c9 f9 44 	sub	r9,sp,-1724
80007ab0:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007ab4:	ec f8 fd 8c 	ld.w	r8,r6[-628]
80007ab8:	50 78       	stdsp	sp[0x1c],r8
80007aba:	cb 6b       	rjmp	80007a26 <_vfprintf_r+0x7b6>
80007abc:	41 09       	lddsp	r9,sp[0x40]
80007abe:	59 f8       	cp.w	r8,31
80007ac0:	e0 89 00 15 	brgt	80007aea <_vfprintf_r+0x87a>
80007ac4:	f2 ca ff f8 	sub	r10,r9,-8
80007ac8:	72 16       	ld.w	r6,r9[0x4]
80007aca:	72 09       	ld.w	r9,r9[0x0]
80007acc:	51 0a       	stdsp	sp[0x40],r10
80007ace:	50 59       	stdsp	sp[0x14],r9
80007ad0:	fa ce f9 44 	sub	lr,sp,-1724
80007ad4:	50 76       	stdsp	sp[0x1c],r6
80007ad6:	fc 08 00 39 	add	r9,lr,r8<<0x3
80007ada:	40 5b       	lddsp	r11,sp[0x14]
80007adc:	0c 9a       	mov	r10,r6
80007ade:	f2 eb fd 88 	st.d	r9[-632],r10
80007ae2:	2f f8       	sub	r8,-1
80007ae4:	fb 48 06 b4 	st.w	sp[1716],r8
80007ae8:	c0 88       	rjmp	80007af8 <_vfprintf_r+0x888>
80007aea:	72 1c       	ld.w	r12,r9[0x4]
80007aec:	50 7c       	stdsp	sp[0x1c],r12
80007aee:	f2 c8 ff f8 	sub	r8,r9,-8
80007af2:	51 08       	stdsp	sp[0x40],r8
80007af4:	72 09       	ld.w	r9,r9[0x0]
80007af6:	50 59       	stdsp	sp[0x14],r9
80007af8:	40 5b       	lddsp	r11,sp[0x14]
80007afa:	40 7a       	lddsp	r10,sp[0x1c]
80007afc:	e0 a0 19 54 	rcall	8000ada4 <__isinfd>
80007b00:	18 96       	mov	r6,r12
80007b02:	c1 70       	breq	80007b30 <_vfprintf_r+0x8c0>
80007b04:	30 08       	mov	r8,0
80007b06:	30 09       	mov	r9,0
80007b08:	40 5b       	lddsp	r11,sp[0x14]
80007b0a:	40 7a       	lddsp	r10,sp[0x1c]
80007b0c:	e0 a0 1d b4 	rcall	8000b674 <__avr32_f64_cmp_lt>
80007b10:	c0 40       	breq	80007b18 <_vfprintf_r+0x8a8>
80007b12:	32 d8       	mov	r8,45
80007b14:	fb 68 06 bb 	st.b	sp[1723],r8
80007b18:	fe c8 a9 b4 	sub	r8,pc,-22092
80007b1c:	fe c6 a9 b4 	sub	r6,pc,-22092
80007b20:	a7 d5       	cbr	r5,0x7
80007b22:	e0 40 00 47 	cp.w	r0,71
80007b26:	f0 06 17 a0 	movle	r6,r8
80007b2a:	30 32       	mov	r2,3
80007b2c:	e0 8f 06 ce 	bral	800088c8 <_vfprintf_r+0x1658>
80007b30:	40 5b       	lddsp	r11,sp[0x14]
80007b32:	40 7a       	lddsp	r10,sp[0x1c]
80007b34:	e0 a0 19 4d 	rcall	8000adce <__isnand>
80007b38:	c0 e0       	breq	80007b54 <_vfprintf_r+0x8e4>
80007b3a:	50 26       	stdsp	sp[0x8],r6
80007b3c:	fe c8 a9 d0 	sub	r8,pc,-22064
80007b40:	fe c6 a9 d0 	sub	r6,pc,-22064
80007b44:	a7 d5       	cbr	r5,0x7
80007b46:	e0 40 00 47 	cp.w	r0,71
80007b4a:	f0 06 17 a0 	movle	r6,r8
80007b4e:	30 32       	mov	r2,3
80007b50:	e0 8f 06 c2 	bral	800088d4 <_vfprintf_r+0x1664>
80007b54:	40 2a       	lddsp	r10,sp[0x8]
80007b56:	5b fa       	cp.w	r10,-1
80007b58:	c0 41       	brne	80007b60 <_vfprintf_r+0x8f0>
80007b5a:	30 69       	mov	r9,6
80007b5c:	50 29       	stdsp	sp[0x8],r9
80007b5e:	c1 18       	rjmp	80007b80 <_vfprintf_r+0x910>
80007b60:	e0 40 00 47 	cp.w	r0,71
80007b64:	5f 09       	sreq	r9
80007b66:	e0 40 00 67 	cp.w	r0,103
80007b6a:	5f 08       	sreq	r8
80007b6c:	f3 e8 10 08 	or	r8,r9,r8
80007b70:	f8 08 18 00 	cp.b	r8,r12
80007b74:	c0 60       	breq	80007b80 <_vfprintf_r+0x910>
80007b76:	40 28       	lddsp	r8,sp[0x8]
80007b78:	58 08       	cp.w	r8,0
80007b7a:	f9 b8 00 01 	moveq	r8,1
80007b7e:	50 28       	stdsp	sp[0x8],r8
80007b80:	40 78       	lddsp	r8,sp[0x1c]
80007b82:	40 59       	lddsp	r9,sp[0x14]
80007b84:	fa e9 06 94 	st.d	sp[1684],r8
80007b88:	a9 a5       	sbr	r5,0x8
80007b8a:	fa f8 06 94 	ld.w	r8,sp[1684]
80007b8e:	58 08       	cp.w	r8,0
80007b90:	c0 65       	brlt	80007b9c <_vfprintf_r+0x92c>
80007b92:	40 5e       	lddsp	lr,sp[0x14]
80007b94:	30 0c       	mov	r12,0
80007b96:	50 6e       	stdsp	sp[0x18],lr
80007b98:	50 9c       	stdsp	sp[0x24],r12
80007b9a:	c0 78       	rjmp	80007ba8 <_vfprintf_r+0x938>
80007b9c:	40 5b       	lddsp	r11,sp[0x14]
80007b9e:	32 da       	mov	r10,45
80007ba0:	ee 1b 80 00 	eorh	r11,0x8000
80007ba4:	50 9a       	stdsp	sp[0x24],r10
80007ba6:	50 6b       	stdsp	sp[0x18],r11
80007ba8:	e0 40 00 46 	cp.w	r0,70
80007bac:	5f 09       	sreq	r9
80007bae:	e0 40 00 66 	cp.w	r0,102
80007bb2:	5f 08       	sreq	r8
80007bb4:	f3 e8 10 08 	or	r8,r9,r8
80007bb8:	50 48       	stdsp	sp[0x10],r8
80007bba:	c0 40       	breq	80007bc2 <_vfprintf_r+0x952>
80007bbc:	40 22       	lddsp	r2,sp[0x8]
80007bbe:	30 39       	mov	r9,3
80007bc0:	c1 08       	rjmp	80007be0 <_vfprintf_r+0x970>
80007bc2:	e0 40 00 45 	cp.w	r0,69
80007bc6:	5f 09       	sreq	r9
80007bc8:	e0 40 00 65 	cp.w	r0,101
80007bcc:	5f 08       	sreq	r8
80007bce:	40 22       	lddsp	r2,sp[0x8]
80007bd0:	10 49       	or	r9,r8
80007bd2:	2f f2       	sub	r2,-1
80007bd4:	40 46       	lddsp	r6,sp[0x10]
80007bd6:	ec 09 18 00 	cp.b	r9,r6
80007bda:	fb f2 00 02 	ld.weq	r2,sp[0x8]
80007bde:	30 29       	mov	r9,2
80007be0:	fa c8 f9 5c 	sub	r8,sp,-1700
80007be4:	1a d8       	st.w	--sp,r8
80007be6:	fa c8 f9 54 	sub	r8,sp,-1708
80007bea:	1a d8       	st.w	--sp,r8
80007bec:	fa c8 f9 4c 	sub	r8,sp,-1716
80007bf0:	08 9c       	mov	r12,r4
80007bf2:	1a d8       	st.w	--sp,r8
80007bf4:	04 98       	mov	r8,r2
80007bf6:	40 9b       	lddsp	r11,sp[0x24]
80007bf8:	40 aa       	lddsp	r10,sp[0x28]
80007bfa:	e0 a0 0b c3 	rcall	80009380 <_dtoa_r>
80007bfe:	e0 40 00 47 	cp.w	r0,71
80007c02:	5f 19       	srne	r9
80007c04:	e0 40 00 67 	cp.w	r0,103
80007c08:	5f 18       	srne	r8
80007c0a:	18 96       	mov	r6,r12
80007c0c:	2f dd       	sub	sp,-12
80007c0e:	f3 e8 00 08 	and	r8,r9,r8
80007c12:	c0 41       	brne	80007c1a <_vfprintf_r+0x9aa>
80007c14:	ed b5 00 00 	bld	r5,0x0
80007c18:	c3 01       	brne	80007c78 <_vfprintf_r+0xa08>
80007c1a:	ec 02 00 0e 	add	lr,r6,r2
80007c1e:	50 3e       	stdsp	sp[0xc],lr
80007c20:	40 4c       	lddsp	r12,sp[0x10]
80007c22:	58 0c       	cp.w	r12,0
80007c24:	c1 50       	breq	80007c4e <_vfprintf_r+0x9de>
80007c26:	0d 89       	ld.ub	r9,r6[0x0]
80007c28:	33 08       	mov	r8,48
80007c2a:	f0 09 18 00 	cp.b	r9,r8
80007c2e:	c0 b1       	brne	80007c44 <_vfprintf_r+0x9d4>
80007c30:	30 08       	mov	r8,0
80007c32:	30 09       	mov	r9,0
80007c34:	40 6b       	lddsp	r11,sp[0x18]
80007c36:	40 7a       	lddsp	r10,sp[0x1c]
80007c38:	e0 a0 1c d7 	rcall	8000b5e6 <__avr32_f64_cmp_eq>
80007c3c:	fb b2 00 01 	rsubeq	r2,1
80007c40:	fb f2 0b ab 	st.weq	sp[0x6ac],r2
80007c44:	40 3b       	lddsp	r11,sp[0xc]
80007c46:	fa f8 06 ac 	ld.w	r8,sp[1708]
80007c4a:	10 0b       	add	r11,r8
80007c4c:	50 3b       	stdsp	sp[0xc],r11
80007c4e:	40 6b       	lddsp	r11,sp[0x18]
80007c50:	30 08       	mov	r8,0
80007c52:	30 09       	mov	r9,0
80007c54:	40 7a       	lddsp	r10,sp[0x1c]
80007c56:	e0 a0 1c c8 	rcall	8000b5e6 <__avr32_f64_cmp_eq>
80007c5a:	c0 90       	breq	80007c6c <_vfprintf_r+0x9fc>
80007c5c:	40 3a       	lddsp	r10,sp[0xc]
80007c5e:	fb 4a 06 a4 	st.w	sp[1700],r10
80007c62:	c0 58       	rjmp	80007c6c <_vfprintf_r+0x9fc>
80007c64:	10 c9       	st.b	r8++,r9
80007c66:	fb 48 06 a4 	st.w	sp[1700],r8
80007c6a:	c0 28       	rjmp	80007c6e <_vfprintf_r+0x9fe>
80007c6c:	33 09       	mov	r9,48
80007c6e:	fa f8 06 a4 	ld.w	r8,sp[1700]
80007c72:	40 3e       	lddsp	lr,sp[0xc]
80007c74:	1c 38       	cp.w	r8,lr
80007c76:	cf 73       	brcs	80007c64 <_vfprintf_r+0x9f4>
80007c78:	e0 40 00 47 	cp.w	r0,71
80007c7c:	5f 09       	sreq	r9
80007c7e:	e0 40 00 67 	cp.w	r0,103
80007c82:	5f 08       	sreq	r8
80007c84:	f3 e8 10 08 	or	r8,r9,r8
80007c88:	fa f9 06 a4 	ld.w	r9,sp[1700]
80007c8c:	0c 19       	sub	r9,r6
80007c8e:	50 69       	stdsp	sp[0x18],r9
80007c90:	58 08       	cp.w	r8,0
80007c92:	c0 b0       	breq	80007ca8 <_vfprintf_r+0xa38>
80007c94:	fa f8 06 ac 	ld.w	r8,sp[1708]
80007c98:	5b d8       	cp.w	r8,-3
80007c9a:	c0 55       	brlt	80007ca4 <_vfprintf_r+0xa34>
80007c9c:	40 2c       	lddsp	r12,sp[0x8]
80007c9e:	18 38       	cp.w	r8,r12
80007ca0:	e0 8a 00 6a 	brle	80007d74 <_vfprintf_r+0xb04>
80007ca4:	20 20       	sub	r0,2
80007ca6:	c0 58       	rjmp	80007cb0 <_vfprintf_r+0xa40>
80007ca8:	e0 40 00 65 	cp.w	r0,101
80007cac:	e0 89 00 46 	brgt	80007d38 <_vfprintf_r+0xac8>
80007cb0:	fa fb 06 ac 	ld.w	r11,sp[1708]
80007cb4:	fb 60 06 9c 	st.b	sp[1692],r0
80007cb8:	20 1b       	sub	r11,1
80007cba:	fb 4b 06 ac 	st.w	sp[1708],r11
80007cbe:	c0 47       	brpl	80007cc6 <_vfprintf_r+0xa56>
80007cc0:	5c 3b       	neg	r11
80007cc2:	32 d8       	mov	r8,45
80007cc4:	c0 28       	rjmp	80007cc8 <_vfprintf_r+0xa58>
80007cc6:	32 b8       	mov	r8,43
80007cc8:	fb 68 06 9d 	st.b	sp[1693],r8
80007ccc:	58 9b       	cp.w	r11,9
80007cce:	e0 8a 00 1d 	brle	80007d08 <_vfprintf_r+0xa98>
80007cd2:	fa c9 fa 35 	sub	r9,sp,-1483
80007cd6:	30 aa       	mov	r10,10
80007cd8:	12 98       	mov	r8,r9
80007cda:	0e 9c       	mov	r12,r7
80007cdc:	0c 92       	mov	r2,r6
80007cde:	f6 0a 0c 06 	divs	r6,r11,r10
80007ce2:	0e 9b       	mov	r11,r7
80007ce4:	2d 0b       	sub	r11,-48
80007ce6:	10 fb       	st.b	--r8,r11
80007ce8:	0c 9b       	mov	r11,r6
80007cea:	58 96       	cp.w	r6,9
80007cec:	fe 99 ff f9 	brgt	80007cde <_vfprintf_r+0xa6e>
80007cf0:	2d 0b       	sub	r11,-48
80007cf2:	18 97       	mov	r7,r12
80007cf4:	04 96       	mov	r6,r2
80007cf6:	10 fb       	st.b	--r8,r11
80007cf8:	fa ca f9 62 	sub	r10,sp,-1694
80007cfc:	c0 38       	rjmp	80007d02 <_vfprintf_r+0xa92>
80007cfe:	11 3b       	ld.ub	r11,r8++
80007d00:	14 cb       	st.b	r10++,r11
80007d02:	12 38       	cp.w	r8,r9
80007d04:	cf d3       	brcs	80007cfe <_vfprintf_r+0xa8e>
80007d06:	c0 98       	rjmp	80007d18 <_vfprintf_r+0xaa8>
80007d08:	2d 0b       	sub	r11,-48
80007d0a:	33 08       	mov	r8,48
80007d0c:	fb 6b 06 9f 	st.b	sp[1695],r11
80007d10:	fb 68 06 9e 	st.b	sp[1694],r8
80007d14:	fa ca f9 60 	sub	r10,sp,-1696
80007d18:	fa c8 f9 64 	sub	r8,sp,-1692
80007d1c:	f4 08 01 08 	sub	r8,r10,r8
80007d20:	50 e8       	stdsp	sp[0x38],r8
80007d22:	10 92       	mov	r2,r8
80007d24:	40 6b       	lddsp	r11,sp[0x18]
80007d26:	16 02       	add	r2,r11
80007d28:	58 1b       	cp.w	r11,1
80007d2a:	e0 89 00 05 	brgt	80007d34 <_vfprintf_r+0xac4>
80007d2e:	ed b5 00 00 	bld	r5,0x0
80007d32:	c3 51       	brne	80007d9c <_vfprintf_r+0xb2c>
80007d34:	2f f2       	sub	r2,-1
80007d36:	c3 38       	rjmp	80007d9c <_vfprintf_r+0xb2c>
80007d38:	e0 40 00 66 	cp.w	r0,102
80007d3c:	c1 c1       	brne	80007d74 <_vfprintf_r+0xb04>
80007d3e:	fa f2 06 ac 	ld.w	r2,sp[1708]
80007d42:	58 02       	cp.w	r2,0
80007d44:	e0 8a 00 0c 	brle	80007d5c <_vfprintf_r+0xaec>
80007d48:	40 2a       	lddsp	r10,sp[0x8]
80007d4a:	58 0a       	cp.w	r10,0
80007d4c:	c0 41       	brne	80007d54 <_vfprintf_r+0xae4>
80007d4e:	ed b5 00 00 	bld	r5,0x0
80007d52:	c2 51       	brne	80007d9c <_vfprintf_r+0xb2c>
80007d54:	2f f2       	sub	r2,-1
80007d56:	40 29       	lddsp	r9,sp[0x8]
80007d58:	12 02       	add	r2,r9
80007d5a:	c0 b8       	rjmp	80007d70 <_vfprintf_r+0xb00>
80007d5c:	40 28       	lddsp	r8,sp[0x8]
80007d5e:	58 08       	cp.w	r8,0
80007d60:	c0 61       	brne	80007d6c <_vfprintf_r+0xafc>
80007d62:	ed b5 00 00 	bld	r5,0x0
80007d66:	c0 30       	breq	80007d6c <_vfprintf_r+0xafc>
80007d68:	30 12       	mov	r2,1
80007d6a:	c1 98       	rjmp	80007d9c <_vfprintf_r+0xb2c>
80007d6c:	40 22       	lddsp	r2,sp[0x8]
80007d6e:	2f e2       	sub	r2,-2
80007d70:	36 60       	mov	r0,102
80007d72:	c1 58       	rjmp	80007d9c <_vfprintf_r+0xb2c>
80007d74:	fa f2 06 ac 	ld.w	r2,sp[1708]
80007d78:	40 6e       	lddsp	lr,sp[0x18]
80007d7a:	1c 32       	cp.w	r2,lr
80007d7c:	c0 65       	brlt	80007d88 <_vfprintf_r+0xb18>
80007d7e:	ed b5 00 00 	bld	r5,0x0
80007d82:	f7 b2 00 ff 	subeq	r2,-1
80007d86:	c0 a8       	rjmp	80007d9a <_vfprintf_r+0xb2a>
80007d88:	e4 08 11 02 	rsub	r8,r2,2
80007d8c:	40 6c       	lddsp	r12,sp[0x18]
80007d8e:	58 02       	cp.w	r2,0
80007d90:	f0 02 17 a0 	movle	r2,r8
80007d94:	f9 b2 09 01 	movgt	r2,1
80007d98:	18 02       	add	r2,r12
80007d9a:	36 70       	mov	r0,103
80007d9c:	40 9b       	lddsp	r11,sp[0x24]
80007d9e:	58 0b       	cp.w	r11,0
80007da0:	e0 80 05 94 	breq	800088c8 <_vfprintf_r+0x1658>
80007da4:	32 d8       	mov	r8,45
80007da6:	fb 68 06 bb 	st.b	sp[1723],r8
80007daa:	e0 8f 05 93 	bral	800088d0 <_vfprintf_r+0x1660>
80007dae:	50 a7       	stdsp	sp[0x28],r7
80007db0:	04 94       	mov	r4,r2
80007db2:	0c 97       	mov	r7,r6
80007db4:	02 92       	mov	r2,r1
80007db6:	06 96       	mov	r6,r3
80007db8:	40 41       	lddsp	r1,sp[0x10]
80007dba:	40 93       	lddsp	r3,sp[0x24]
80007dbc:	0e 99       	mov	r9,r7
80007dbe:	ed b5 00 05 	bld	r5,0x5
80007dc2:	c4 81       	brne	80007e52 <_vfprintf_r+0xbe2>
80007dc4:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007dc8:	40 3e       	lddsp	lr,sp[0xc]
80007dca:	58 0e       	cp.w	lr,0
80007dcc:	c1 d0       	breq	80007e06 <_vfprintf_r+0xb96>
80007dce:	10 36       	cp.w	r6,r8
80007dd0:	c0 64       	brge	80007ddc <_vfprintf_r+0xb6c>
80007dd2:	fa cc f9 44 	sub	r12,sp,-1724
80007dd6:	f8 06 00 36 	add	r6,r12,r6<<0x3
80007dda:	c1 d8       	rjmp	80007e14 <_vfprintf_r+0xba4>
80007ddc:	fa c8 f9 50 	sub	r8,sp,-1712
80007de0:	1a d8       	st.w	--sp,r8
80007de2:	fa c8 fa b8 	sub	r8,sp,-1352
80007de6:	04 9a       	mov	r10,r2
80007de8:	1a d8       	st.w	--sp,r8
80007dea:	fa c8 fb b4 	sub	r8,sp,-1100
80007dee:	0c 9b       	mov	r11,r6
80007df0:	1a d8       	st.w	--sp,r8
80007df2:	08 9c       	mov	r12,r4
80007df4:	fa c8 f9 40 	sub	r8,sp,-1728
80007df8:	fa c9 ff b4 	sub	r9,sp,-76
80007dfc:	fe b0 f8 a2 	rcall	80006f40 <get_arg>
80007e00:	2f dd       	sub	sp,-12
80007e02:	78 0a       	ld.w	r10,r12[0x0]
80007e04:	c2 08       	rjmp	80007e44 <_vfprintf_r+0xbd4>
80007e06:	2f f7       	sub	r7,-1
80007e08:	10 39       	cp.w	r9,r8
80007e0a:	c0 84       	brge	80007e1a <_vfprintf_r+0xbaa>
80007e0c:	fa cb f9 44 	sub	r11,sp,-1724
80007e10:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007e14:	ec fa fd 88 	ld.w	r10,r6[-632]
80007e18:	c1 68       	rjmp	80007e44 <_vfprintf_r+0xbd4>
80007e1a:	41 09       	lddsp	r9,sp[0x40]
80007e1c:	59 f8       	cp.w	r8,31
80007e1e:	e0 89 00 10 	brgt	80007e3e <_vfprintf_r+0xbce>
80007e22:	f2 ca ff fc 	sub	r10,r9,-4
80007e26:	51 0a       	stdsp	sp[0x40],r10
80007e28:	fa c6 f9 44 	sub	r6,sp,-1724
80007e2c:	72 0a       	ld.w	r10,r9[0x0]
80007e2e:	ec 08 00 39 	add	r9,r6,r8<<0x3
80007e32:	f3 4a fd 88 	st.w	r9[-632],r10
80007e36:	2f f8       	sub	r8,-1
80007e38:	fb 48 06 b4 	st.w	sp[1716],r8
80007e3c:	c0 48       	rjmp	80007e44 <_vfprintf_r+0xbd4>
80007e3e:	72 0a       	ld.w	r10,r9[0x0]
80007e40:	2f c9       	sub	r9,-4
80007e42:	51 09       	stdsp	sp[0x40],r9
80007e44:	40 be       	lddsp	lr,sp[0x2c]
80007e46:	1c 98       	mov	r8,lr
80007e48:	95 1e       	st.w	r10[0x4],lr
80007e4a:	bf 58       	asr	r8,0x1f
80007e4c:	95 08       	st.w	r10[0x0],r8
80007e4e:	fe 9f fa 9f 	bral	8000738c <_vfprintf_r+0x11c>
80007e52:	ed b5 00 04 	bld	r5,0x4
80007e56:	c4 80       	breq	80007ee6 <_vfprintf_r+0xc76>
80007e58:	e2 15 00 40 	andl	r5,0x40,COH
80007e5c:	c4 50       	breq	80007ee6 <_vfprintf_r+0xc76>
80007e5e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007e62:	40 3c       	lddsp	r12,sp[0xc]
80007e64:	58 0c       	cp.w	r12,0
80007e66:	c1 d0       	breq	80007ea0 <_vfprintf_r+0xc30>
80007e68:	10 36       	cp.w	r6,r8
80007e6a:	c0 64       	brge	80007e76 <_vfprintf_r+0xc06>
80007e6c:	fa cb f9 44 	sub	r11,sp,-1724
80007e70:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007e74:	c1 d8       	rjmp	80007eae <_vfprintf_r+0xc3e>
80007e76:	fa c8 f9 50 	sub	r8,sp,-1712
80007e7a:	1a d8       	st.w	--sp,r8
80007e7c:	fa c8 fa b8 	sub	r8,sp,-1352
80007e80:	04 9a       	mov	r10,r2
80007e82:	1a d8       	st.w	--sp,r8
80007e84:	fa c8 fb b4 	sub	r8,sp,-1100
80007e88:	0c 9b       	mov	r11,r6
80007e8a:	1a d8       	st.w	--sp,r8
80007e8c:	08 9c       	mov	r12,r4
80007e8e:	fa c8 f9 40 	sub	r8,sp,-1728
80007e92:	fa c9 ff b4 	sub	r9,sp,-76
80007e96:	fe b0 f8 55 	rcall	80006f40 <get_arg>
80007e9a:	2f dd       	sub	sp,-12
80007e9c:	78 0a       	ld.w	r10,r12[0x0]
80007e9e:	c2 08       	rjmp	80007ede <_vfprintf_r+0xc6e>
80007ea0:	2f f7       	sub	r7,-1
80007ea2:	10 39       	cp.w	r9,r8
80007ea4:	c0 84       	brge	80007eb4 <_vfprintf_r+0xc44>
80007ea6:	fa ca f9 44 	sub	r10,sp,-1724
80007eaa:	f4 06 00 36 	add	r6,r10,r6<<0x3
80007eae:	ec fa fd 88 	ld.w	r10,r6[-632]
80007eb2:	c1 68       	rjmp	80007ede <_vfprintf_r+0xc6e>
80007eb4:	41 09       	lddsp	r9,sp[0x40]
80007eb6:	59 f8       	cp.w	r8,31
80007eb8:	e0 89 00 10 	brgt	80007ed8 <_vfprintf_r+0xc68>
80007ebc:	f2 ca ff fc 	sub	r10,r9,-4
80007ec0:	51 0a       	stdsp	sp[0x40],r10
80007ec2:	fa c6 f9 44 	sub	r6,sp,-1724
80007ec6:	72 0a       	ld.w	r10,r9[0x0]
80007ec8:	ec 08 00 39 	add	r9,r6,r8<<0x3
80007ecc:	f3 4a fd 88 	st.w	r9[-632],r10
80007ed0:	2f f8       	sub	r8,-1
80007ed2:	fb 48 06 b4 	st.w	sp[1716],r8
80007ed6:	c0 48       	rjmp	80007ede <_vfprintf_r+0xc6e>
80007ed8:	72 0a       	ld.w	r10,r9[0x0]
80007eda:	2f c9       	sub	r9,-4
80007edc:	51 09       	stdsp	sp[0x40],r9
80007ede:	40 be       	lddsp	lr,sp[0x2c]
80007ee0:	b4 0e       	st.h	r10[0x0],lr
80007ee2:	fe 9f fa 55 	bral	8000738c <_vfprintf_r+0x11c>
80007ee6:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007eea:	40 3c       	lddsp	r12,sp[0xc]
80007eec:	58 0c       	cp.w	r12,0
80007eee:	c1 d0       	breq	80007f28 <_vfprintf_r+0xcb8>
80007ef0:	10 36       	cp.w	r6,r8
80007ef2:	c0 64       	brge	80007efe <_vfprintf_r+0xc8e>
80007ef4:	fa cb f9 44 	sub	r11,sp,-1724
80007ef8:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007efc:	c1 d8       	rjmp	80007f36 <_vfprintf_r+0xcc6>
80007efe:	fa c8 f9 50 	sub	r8,sp,-1712
80007f02:	1a d8       	st.w	--sp,r8
80007f04:	fa c8 fa b8 	sub	r8,sp,-1352
80007f08:	04 9a       	mov	r10,r2
80007f0a:	1a d8       	st.w	--sp,r8
80007f0c:	fa c8 fb b4 	sub	r8,sp,-1100
80007f10:	0c 9b       	mov	r11,r6
80007f12:	1a d8       	st.w	--sp,r8
80007f14:	08 9c       	mov	r12,r4
80007f16:	fa c8 f9 40 	sub	r8,sp,-1728
80007f1a:	fa c9 ff b4 	sub	r9,sp,-76
80007f1e:	fe b0 f8 11 	rcall	80006f40 <get_arg>
80007f22:	2f dd       	sub	sp,-12
80007f24:	78 0a       	ld.w	r10,r12[0x0]
80007f26:	c2 08       	rjmp	80007f66 <_vfprintf_r+0xcf6>
80007f28:	2f f7       	sub	r7,-1
80007f2a:	10 39       	cp.w	r9,r8
80007f2c:	c0 84       	brge	80007f3c <_vfprintf_r+0xccc>
80007f2e:	fa ca f9 44 	sub	r10,sp,-1724
80007f32:	f4 06 00 36 	add	r6,r10,r6<<0x3
80007f36:	ec fa fd 88 	ld.w	r10,r6[-632]
80007f3a:	c1 68       	rjmp	80007f66 <_vfprintf_r+0xcf6>
80007f3c:	41 09       	lddsp	r9,sp[0x40]
80007f3e:	59 f8       	cp.w	r8,31
80007f40:	e0 89 00 10 	brgt	80007f60 <_vfprintf_r+0xcf0>
80007f44:	f2 ca ff fc 	sub	r10,r9,-4
80007f48:	51 0a       	stdsp	sp[0x40],r10
80007f4a:	fa c6 f9 44 	sub	r6,sp,-1724
80007f4e:	72 0a       	ld.w	r10,r9[0x0]
80007f50:	ec 08 00 39 	add	r9,r6,r8<<0x3
80007f54:	f3 4a fd 88 	st.w	r9[-632],r10
80007f58:	2f f8       	sub	r8,-1
80007f5a:	fb 48 06 b4 	st.w	sp[1716],r8
80007f5e:	c0 48       	rjmp	80007f66 <_vfprintf_r+0xcf6>
80007f60:	72 0a       	ld.w	r10,r9[0x0]
80007f62:	2f c9       	sub	r9,-4
80007f64:	51 09       	stdsp	sp[0x40],r9
80007f66:	40 be       	lddsp	lr,sp[0x2c]
80007f68:	95 0e       	st.w	r10[0x0],lr
80007f6a:	fe 9f fa 11 	bral	8000738c <_vfprintf_r+0x11c>
80007f6e:	50 a7       	stdsp	sp[0x28],r7
80007f70:	50 80       	stdsp	sp[0x20],r0
80007f72:	0c 97       	mov	r7,r6
80007f74:	04 94       	mov	r4,r2
80007f76:	06 96       	mov	r6,r3
80007f78:	02 92       	mov	r2,r1
80007f7a:	40 93       	lddsp	r3,sp[0x24]
80007f7c:	10 90       	mov	r0,r8
80007f7e:	40 41       	lddsp	r1,sp[0x10]
80007f80:	a5 a5       	sbr	r5,0x4
80007f82:	c0 a8       	rjmp	80007f96 <_vfprintf_r+0xd26>
80007f84:	50 a7       	stdsp	sp[0x28],r7
80007f86:	50 80       	stdsp	sp[0x20],r0
80007f88:	0c 97       	mov	r7,r6
80007f8a:	04 94       	mov	r4,r2
80007f8c:	06 96       	mov	r6,r3
80007f8e:	02 92       	mov	r2,r1
80007f90:	40 93       	lddsp	r3,sp[0x24]
80007f92:	10 90       	mov	r0,r8
80007f94:	40 41       	lddsp	r1,sp[0x10]
80007f96:	ed b5 00 05 	bld	r5,0x5
80007f9a:	c5 d1       	brne	80008054 <_vfprintf_r+0xde4>
80007f9c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007fa0:	40 3c       	lddsp	r12,sp[0xc]
80007fa2:	58 0c       	cp.w	r12,0
80007fa4:	c2 60       	breq	80007ff0 <_vfprintf_r+0xd80>
80007fa6:	10 36       	cp.w	r6,r8
80007fa8:	c0 a4       	brge	80007fbc <_vfprintf_r+0xd4c>
80007faa:	fa cb f9 44 	sub	r11,sp,-1724
80007fae:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007fb2:	ec e8 fd 88 	ld.d	r8,r6[-632]
80007fb6:	fa e9 00 00 	st.d	sp[0],r8
80007fba:	c1 88       	rjmp	80007fea <_vfprintf_r+0xd7a>
80007fbc:	fa c8 f9 50 	sub	r8,sp,-1712
80007fc0:	1a d8       	st.w	--sp,r8
80007fc2:	fa c8 fa b8 	sub	r8,sp,-1352
80007fc6:	04 9a       	mov	r10,r2
80007fc8:	1a d8       	st.w	--sp,r8
80007fca:	0c 9b       	mov	r11,r6
80007fcc:	fa c8 fb b4 	sub	r8,sp,-1100
80007fd0:	08 9c       	mov	r12,r4
80007fd2:	1a d8       	st.w	--sp,r8
80007fd4:	fa c8 f9 40 	sub	r8,sp,-1728
80007fd8:	fa c9 ff b4 	sub	r9,sp,-76
80007fdc:	fe b0 f7 b2 	rcall	80006f40 <get_arg>
80007fe0:	2f dd       	sub	sp,-12
80007fe2:	f8 ea 00 00 	ld.d	r10,r12[0]
80007fe6:	fa eb 00 00 	st.d	sp[0],r10
80007fea:	30 08       	mov	r8,0
80007fec:	e0 8f 03 de 	bral	800087a8 <_vfprintf_r+0x1538>
80007ff0:	ee ca ff ff 	sub	r10,r7,-1
80007ff4:	10 37       	cp.w	r7,r8
80007ff6:	c0 b4       	brge	8000800c <_vfprintf_r+0xd9c>
80007ff8:	fa c9 f9 44 	sub	r9,sp,-1724
80007ffc:	14 97       	mov	r7,r10
80007ffe:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008002:	ec ea fd 88 	ld.d	r10,r6[-632]
80008006:	fa eb 00 00 	st.d	sp[0],r10
8000800a:	c1 88       	rjmp	8000803a <_vfprintf_r+0xdca>
8000800c:	41 09       	lddsp	r9,sp[0x40]
8000800e:	59 f8       	cp.w	r8,31
80008010:	e0 89 00 18 	brgt	80008040 <_vfprintf_r+0xdd0>
80008014:	f2 e6 00 00 	ld.d	r6,r9[0]
80008018:	f2 cb ff f8 	sub	r11,r9,-8
8000801c:	fa e7 00 00 	st.d	sp[0],r6
80008020:	51 0b       	stdsp	sp[0x40],r11
80008022:	fa c6 f9 44 	sub	r6,sp,-1724
80008026:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000802a:	fa e6 00 00 	ld.d	r6,sp[0]
8000802e:	f2 e7 fd 88 	st.d	r9[-632],r6
80008032:	2f f8       	sub	r8,-1
80008034:	14 97       	mov	r7,r10
80008036:	fb 48 06 b4 	st.w	sp[1716],r8
8000803a:	40 38       	lddsp	r8,sp[0xc]
8000803c:	e0 8f 03 b6 	bral	800087a8 <_vfprintf_r+0x1538>
80008040:	f2 e6 00 00 	ld.d	r6,r9[0]
80008044:	40 38       	lddsp	r8,sp[0xc]
80008046:	fa e7 00 00 	st.d	sp[0],r6
8000804a:	2f 89       	sub	r9,-8
8000804c:	14 97       	mov	r7,r10
8000804e:	51 09       	stdsp	sp[0x40],r9
80008050:	e0 8f 03 ac 	bral	800087a8 <_vfprintf_r+0x1538>
80008054:	ed b5 00 04 	bld	r5,0x4
80008058:	c1 61       	brne	80008084 <_vfprintf_r+0xe14>
8000805a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000805e:	40 3e       	lddsp	lr,sp[0xc]
80008060:	58 0e       	cp.w	lr,0
80008062:	c0 80       	breq	80008072 <_vfprintf_r+0xe02>
80008064:	10 36       	cp.w	r6,r8
80008066:	c6 74       	brge	80008134 <_vfprintf_r+0xec4>
80008068:	fa cc f9 44 	sub	r12,sp,-1724
8000806c:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008070:	c8 08       	rjmp	80008170 <_vfprintf_r+0xf00>
80008072:	ee ca ff ff 	sub	r10,r7,-1
80008076:	10 37       	cp.w	r7,r8
80008078:	c7 f4       	brge	80008176 <_vfprintf_r+0xf06>
8000807a:	fa cb f9 44 	sub	r11,sp,-1724
8000807e:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008082:	c7 68       	rjmp	8000816e <_vfprintf_r+0xefe>
80008084:	ed b5 00 06 	bld	r5,0x6
80008088:	c4 a1       	brne	8000811c <_vfprintf_r+0xeac>
8000808a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000808e:	40 3c       	lddsp	r12,sp[0xc]
80008090:	58 0c       	cp.w	r12,0
80008092:	c1 d0       	breq	800080cc <_vfprintf_r+0xe5c>
80008094:	10 36       	cp.w	r6,r8
80008096:	c0 64       	brge	800080a2 <_vfprintf_r+0xe32>
80008098:	fa cb f9 44 	sub	r11,sp,-1724
8000809c:	f6 06 00 36 	add	r6,r11,r6<<0x3
800080a0:	c1 f8       	rjmp	800080de <_vfprintf_r+0xe6e>
800080a2:	fa c8 f9 50 	sub	r8,sp,-1712
800080a6:	1a d8       	st.w	--sp,r8
800080a8:	fa c8 fa b8 	sub	r8,sp,-1352
800080ac:	1a d8       	st.w	--sp,r8
800080ae:	fa c8 fb b4 	sub	r8,sp,-1100
800080b2:	1a d8       	st.w	--sp,r8
800080b4:	fa c8 f9 40 	sub	r8,sp,-1728
800080b8:	fa c9 ff b4 	sub	r9,sp,-76
800080bc:	04 9a       	mov	r10,r2
800080be:	0c 9b       	mov	r11,r6
800080c0:	08 9c       	mov	r12,r4
800080c2:	fe b0 f7 3f 	rcall	80006f40 <get_arg>
800080c6:	2f dd       	sub	sp,-12
800080c8:	98 18       	ld.sh	r8,r12[0x2]
800080ca:	c2 68       	rjmp	80008116 <_vfprintf_r+0xea6>
800080cc:	ee ca ff ff 	sub	r10,r7,-1
800080d0:	10 37       	cp.w	r7,r8
800080d2:	c0 94       	brge	800080e4 <_vfprintf_r+0xe74>
800080d4:	fa c9 f9 44 	sub	r9,sp,-1724
800080d8:	14 97       	mov	r7,r10
800080da:	f2 06 00 36 	add	r6,r9,r6<<0x3
800080de:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
800080e2:	c1 a8       	rjmp	80008116 <_vfprintf_r+0xea6>
800080e4:	41 09       	lddsp	r9,sp[0x40]
800080e6:	59 f8       	cp.w	r8,31
800080e8:	e0 89 00 13 	brgt	8000810e <_vfprintf_r+0xe9e>
800080ec:	f2 cb ff fc 	sub	r11,r9,-4
800080f0:	51 0b       	stdsp	sp[0x40],r11
800080f2:	72 09       	ld.w	r9,r9[0x0]
800080f4:	fa c6 f9 44 	sub	r6,sp,-1724
800080f8:	ec 08 00 3b 	add	r11,r6,r8<<0x3
800080fc:	2f f8       	sub	r8,-1
800080fe:	f7 49 fd 88 	st.w	r11[-632],r9
80008102:	fb 48 06 b4 	st.w	sp[1716],r8
80008106:	14 97       	mov	r7,r10
80008108:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
8000810c:	c0 58       	rjmp	80008116 <_vfprintf_r+0xea6>
8000810e:	92 18       	ld.sh	r8,r9[0x2]
80008110:	14 97       	mov	r7,r10
80008112:	2f c9       	sub	r9,-4
80008114:	51 09       	stdsp	sp[0x40],r9
80008116:	5c 78       	castu.h	r8
80008118:	50 18       	stdsp	sp[0x4],r8
8000811a:	c4 68       	rjmp	800081a6 <_vfprintf_r+0xf36>
8000811c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008120:	40 3c       	lddsp	r12,sp[0xc]
80008122:	58 0c       	cp.w	r12,0
80008124:	c1 d0       	breq	8000815e <_vfprintf_r+0xeee>
80008126:	10 36       	cp.w	r6,r8
80008128:	c0 64       	brge	80008134 <_vfprintf_r+0xec4>
8000812a:	fa cb f9 44 	sub	r11,sp,-1724
8000812e:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008132:	c1 f8       	rjmp	80008170 <_vfprintf_r+0xf00>
80008134:	fa c8 f9 50 	sub	r8,sp,-1712
80008138:	1a d8       	st.w	--sp,r8
8000813a:	fa c8 fa b8 	sub	r8,sp,-1352
8000813e:	0c 9b       	mov	r11,r6
80008140:	1a d8       	st.w	--sp,r8
80008142:	fa c8 fb b4 	sub	r8,sp,-1100
80008146:	04 9a       	mov	r10,r2
80008148:	1a d8       	st.w	--sp,r8
8000814a:	08 9c       	mov	r12,r4
8000814c:	fa c8 f9 40 	sub	r8,sp,-1728
80008150:	fa c9 ff b4 	sub	r9,sp,-76
80008154:	fe b0 f6 f6 	rcall	80006f40 <get_arg>
80008158:	2f dd       	sub	sp,-12
8000815a:	78 0b       	ld.w	r11,r12[0x0]
8000815c:	c2 48       	rjmp	800081a4 <_vfprintf_r+0xf34>
8000815e:	ee ca ff ff 	sub	r10,r7,-1
80008162:	10 37       	cp.w	r7,r8
80008164:	c0 94       	brge	80008176 <_vfprintf_r+0xf06>
80008166:	fa c9 f9 44 	sub	r9,sp,-1724
8000816a:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000816e:	14 97       	mov	r7,r10
80008170:	ec fb fd 88 	ld.w	r11,r6[-632]
80008174:	c1 88       	rjmp	800081a4 <_vfprintf_r+0xf34>
80008176:	41 09       	lddsp	r9,sp[0x40]
80008178:	59 f8       	cp.w	r8,31
8000817a:	e0 89 00 11 	brgt	8000819c <_vfprintf_r+0xf2c>
8000817e:	f2 cb ff fc 	sub	r11,r9,-4
80008182:	51 0b       	stdsp	sp[0x40],r11
80008184:	fa c6 f9 44 	sub	r6,sp,-1724
80008188:	72 0b       	ld.w	r11,r9[0x0]
8000818a:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000818e:	f3 4b fd 88 	st.w	r9[-632],r11
80008192:	2f f8       	sub	r8,-1
80008194:	14 97       	mov	r7,r10
80008196:	fb 48 06 b4 	st.w	sp[1716],r8
8000819a:	c0 58       	rjmp	800081a4 <_vfprintf_r+0xf34>
8000819c:	72 0b       	ld.w	r11,r9[0x0]
8000819e:	14 97       	mov	r7,r10
800081a0:	2f c9       	sub	r9,-4
800081a2:	51 09       	stdsp	sp[0x40],r9
800081a4:	50 1b       	stdsp	sp[0x4],r11
800081a6:	30 0e       	mov	lr,0
800081a8:	50 0e       	stdsp	sp[0x0],lr
800081aa:	1c 98       	mov	r8,lr
800081ac:	e0 8f 02 fe 	bral	800087a8 <_vfprintf_r+0x1538>
800081b0:	50 a7       	stdsp	sp[0x28],r7
800081b2:	50 80       	stdsp	sp[0x20],r0
800081b4:	0c 97       	mov	r7,r6
800081b6:	04 94       	mov	r4,r2
800081b8:	06 96       	mov	r6,r3
800081ba:	02 92       	mov	r2,r1
800081bc:	40 93       	lddsp	r3,sp[0x24]
800081be:	40 41       	lddsp	r1,sp[0x10]
800081c0:	0e 99       	mov	r9,r7
800081c2:	fa f8 06 b4 	ld.w	r8,sp[1716]
800081c6:	40 3c       	lddsp	r12,sp[0xc]
800081c8:	58 0c       	cp.w	r12,0
800081ca:	c1 d0       	breq	80008204 <_vfprintf_r+0xf94>
800081cc:	10 36       	cp.w	r6,r8
800081ce:	c0 64       	brge	800081da <_vfprintf_r+0xf6a>
800081d0:	fa cb f9 44 	sub	r11,sp,-1724
800081d4:	f6 06 00 36 	add	r6,r11,r6<<0x3
800081d8:	c1 d8       	rjmp	80008212 <_vfprintf_r+0xfa2>
800081da:	fa c8 f9 50 	sub	r8,sp,-1712
800081de:	1a d8       	st.w	--sp,r8
800081e0:	fa c8 fa b8 	sub	r8,sp,-1352
800081e4:	1a d8       	st.w	--sp,r8
800081e6:	fa c8 fb b4 	sub	r8,sp,-1100
800081ea:	1a d8       	st.w	--sp,r8
800081ec:	fa c9 ff b4 	sub	r9,sp,-76
800081f0:	fa c8 f9 40 	sub	r8,sp,-1728
800081f4:	04 9a       	mov	r10,r2
800081f6:	0c 9b       	mov	r11,r6
800081f8:	08 9c       	mov	r12,r4
800081fa:	fe b0 f6 a3 	rcall	80006f40 <get_arg>
800081fe:	2f dd       	sub	sp,-12
80008200:	78 09       	ld.w	r9,r12[0x0]
80008202:	c2 18       	rjmp	80008244 <_vfprintf_r+0xfd4>
80008204:	2f f7       	sub	r7,-1
80008206:	10 39       	cp.w	r9,r8
80008208:	c0 84       	brge	80008218 <_vfprintf_r+0xfa8>
8000820a:	fa ca f9 44 	sub	r10,sp,-1724
8000820e:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008212:	ec f9 fd 88 	ld.w	r9,r6[-632]
80008216:	c1 78       	rjmp	80008244 <_vfprintf_r+0xfd4>
80008218:	41 09       	lddsp	r9,sp[0x40]
8000821a:	59 f8       	cp.w	r8,31
8000821c:	e0 89 00 10 	brgt	8000823c <_vfprintf_r+0xfcc>
80008220:	f2 ca ff fc 	sub	r10,r9,-4
80008224:	51 0a       	stdsp	sp[0x40],r10
80008226:	fa c6 f9 44 	sub	r6,sp,-1724
8000822a:	72 09       	ld.w	r9,r9[0x0]
8000822c:	ec 08 00 3a 	add	r10,r6,r8<<0x3
80008230:	f5 49 fd 88 	st.w	r10[-632],r9
80008234:	2f f8       	sub	r8,-1
80008236:	fb 48 06 b4 	st.w	sp[1716],r8
8000823a:	c0 58       	rjmp	80008244 <_vfprintf_r+0xfd4>
8000823c:	f2 c8 ff fc 	sub	r8,r9,-4
80008240:	51 08       	stdsp	sp[0x40],r8
80008242:	72 09       	ld.w	r9,r9[0x0]
80008244:	33 08       	mov	r8,48
80008246:	fb 68 06 b8 	st.b	sp[1720],r8
8000824a:	37 88       	mov	r8,120
8000824c:	30 0e       	mov	lr,0
8000824e:	fb 68 06 b9 	st.b	sp[1721],r8
80008252:	fe cc b0 de 	sub	r12,pc,-20258
80008256:	50 19       	stdsp	sp[0x4],r9
80008258:	a1 b5       	sbr	r5,0x1
8000825a:	50 0e       	stdsp	sp[0x0],lr
8000825c:	50 dc       	stdsp	sp[0x34],r12
8000825e:	30 28       	mov	r8,2
80008260:	37 80       	mov	r0,120
80008262:	e0 8f 02 a3 	bral	800087a8 <_vfprintf_r+0x1538>
80008266:	50 a7       	stdsp	sp[0x28],r7
80008268:	50 80       	stdsp	sp[0x20],r0
8000826a:	10 90       	mov	r0,r8
8000826c:	30 08       	mov	r8,0
8000826e:	fb 68 06 bb 	st.b	sp[1723],r8
80008272:	0c 97       	mov	r7,r6
80008274:	04 94       	mov	r4,r2
80008276:	06 96       	mov	r6,r3
80008278:	02 92       	mov	r2,r1
8000827a:	40 93       	lddsp	r3,sp[0x24]
8000827c:	40 41       	lddsp	r1,sp[0x10]
8000827e:	0e 99       	mov	r9,r7
80008280:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008284:	40 3b       	lddsp	r11,sp[0xc]
80008286:	58 0b       	cp.w	r11,0
80008288:	c1 d0       	breq	800082c2 <_vfprintf_r+0x1052>
8000828a:	10 36       	cp.w	r6,r8
8000828c:	c0 64       	brge	80008298 <_vfprintf_r+0x1028>
8000828e:	fa ca f9 44 	sub	r10,sp,-1724
80008292:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008296:	c1 d8       	rjmp	800082d0 <_vfprintf_r+0x1060>
80008298:	fa c8 f9 50 	sub	r8,sp,-1712
8000829c:	1a d8       	st.w	--sp,r8
8000829e:	fa c8 fa b8 	sub	r8,sp,-1352
800082a2:	1a d8       	st.w	--sp,r8
800082a4:	fa c8 fb b4 	sub	r8,sp,-1100
800082a8:	0c 9b       	mov	r11,r6
800082aa:	1a d8       	st.w	--sp,r8
800082ac:	04 9a       	mov	r10,r2
800082ae:	fa c8 f9 40 	sub	r8,sp,-1728
800082b2:	fa c9 ff b4 	sub	r9,sp,-76
800082b6:	08 9c       	mov	r12,r4
800082b8:	fe b0 f6 44 	rcall	80006f40 <get_arg>
800082bc:	2f dd       	sub	sp,-12
800082be:	78 06       	ld.w	r6,r12[0x0]
800082c0:	c2 08       	rjmp	80008300 <_vfprintf_r+0x1090>
800082c2:	2f f7       	sub	r7,-1
800082c4:	10 39       	cp.w	r9,r8
800082c6:	c0 84       	brge	800082d6 <_vfprintf_r+0x1066>
800082c8:	fa c9 f9 44 	sub	r9,sp,-1724
800082cc:	f2 06 00 36 	add	r6,r9,r6<<0x3
800082d0:	ec f6 fd 88 	ld.w	r6,r6[-632]
800082d4:	c1 68       	rjmp	80008300 <_vfprintf_r+0x1090>
800082d6:	41 09       	lddsp	r9,sp[0x40]
800082d8:	59 f8       	cp.w	r8,31
800082da:	e0 89 00 10 	brgt	800082fa <_vfprintf_r+0x108a>
800082de:	f2 ca ff fc 	sub	r10,r9,-4
800082e2:	51 0a       	stdsp	sp[0x40],r10
800082e4:	72 06       	ld.w	r6,r9[0x0]
800082e6:	fa ce f9 44 	sub	lr,sp,-1724
800082ea:	fc 08 00 39 	add	r9,lr,r8<<0x3
800082ee:	f3 46 fd 88 	st.w	r9[-632],r6
800082f2:	2f f8       	sub	r8,-1
800082f4:	fb 48 06 b4 	st.w	sp[1716],r8
800082f8:	c0 48       	rjmp	80008300 <_vfprintf_r+0x1090>
800082fa:	72 06       	ld.w	r6,r9[0x0]
800082fc:	2f c9       	sub	r9,-4
800082fe:	51 09       	stdsp	sp[0x40],r9
80008300:	40 2c       	lddsp	r12,sp[0x8]
80008302:	58 0c       	cp.w	r12,0
80008304:	c1 05       	brlt	80008324 <_vfprintf_r+0x10b4>
80008306:	18 9a       	mov	r10,r12
80008308:	30 0b       	mov	r11,0
8000830a:	0c 9c       	mov	r12,r6
8000830c:	e0 a0 12 38 	rcall	8000a77c <memchr>
80008310:	e0 80 02 df 	breq	800088ce <_vfprintf_r+0x165e>
80008314:	f8 06 01 02 	sub	r2,r12,r6
80008318:	40 2b       	lddsp	r11,sp[0x8]
8000831a:	16 32       	cp.w	r2,r11
8000831c:	e0 89 02 d9 	brgt	800088ce <_vfprintf_r+0x165e>
80008320:	e0 8f 02 d4 	bral	800088c8 <_vfprintf_r+0x1658>
80008324:	30 0a       	mov	r10,0
80008326:	0c 9c       	mov	r12,r6
80008328:	50 2a       	stdsp	sp[0x8],r10
8000832a:	e0 a0 15 99 	rcall	8000ae5c <strlen>
8000832e:	18 92       	mov	r2,r12
80008330:	e0 8f 02 d2 	bral	800088d4 <_vfprintf_r+0x1664>
80008334:	50 a7       	stdsp	sp[0x28],r7
80008336:	50 80       	stdsp	sp[0x20],r0
80008338:	0c 97       	mov	r7,r6
8000833a:	04 94       	mov	r4,r2
8000833c:	06 96       	mov	r6,r3
8000833e:	02 92       	mov	r2,r1
80008340:	40 93       	lddsp	r3,sp[0x24]
80008342:	10 90       	mov	r0,r8
80008344:	40 41       	lddsp	r1,sp[0x10]
80008346:	a5 a5       	sbr	r5,0x4
80008348:	c0 a8       	rjmp	8000835c <_vfprintf_r+0x10ec>
8000834a:	50 a7       	stdsp	sp[0x28],r7
8000834c:	50 80       	stdsp	sp[0x20],r0
8000834e:	0c 97       	mov	r7,r6
80008350:	04 94       	mov	r4,r2
80008352:	06 96       	mov	r6,r3
80008354:	02 92       	mov	r2,r1
80008356:	40 93       	lddsp	r3,sp[0x24]
80008358:	10 90       	mov	r0,r8
8000835a:	40 41       	lddsp	r1,sp[0x10]
8000835c:	ed b5 00 05 	bld	r5,0x5
80008360:	c5 61       	brne	8000840c <_vfprintf_r+0x119c>
80008362:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008366:	40 39       	lddsp	r9,sp[0xc]
80008368:	58 09       	cp.w	r9,0
8000836a:	c2 10       	breq	800083ac <_vfprintf_r+0x113c>
8000836c:	10 36       	cp.w	r6,r8
8000836e:	c0 74       	brge	8000837c <_vfprintf_r+0x110c>
80008370:	fa c8 f9 44 	sub	r8,sp,-1724
80008374:	f0 06 00 36 	add	r6,r8,r6<<0x3
80008378:	c2 38       	rjmp	800083be <_vfprintf_r+0x114e>
8000837a:	d7 03       	nop
8000837c:	fa c8 f9 50 	sub	r8,sp,-1712
80008380:	1a d8       	st.w	--sp,r8
80008382:	fa c8 fa b8 	sub	r8,sp,-1352
80008386:	1a d8       	st.w	--sp,r8
80008388:	fa c8 fb b4 	sub	r8,sp,-1100
8000838c:	1a d8       	st.w	--sp,r8
8000838e:	fa c8 f9 40 	sub	r8,sp,-1728
80008392:	fa c9 ff b4 	sub	r9,sp,-76
80008396:	04 9a       	mov	r10,r2
80008398:	0c 9b       	mov	r11,r6
8000839a:	08 9c       	mov	r12,r4
8000839c:	fe b0 f5 d2 	rcall	80006f40 <get_arg>
800083a0:	2f dd       	sub	sp,-12
800083a2:	f8 e8 00 00 	ld.d	r8,r12[0]
800083a6:	fa e9 00 00 	st.d	sp[0],r8
800083aa:	c2 e8       	rjmp	80008406 <_vfprintf_r+0x1196>
800083ac:	ee ca ff ff 	sub	r10,r7,-1
800083b0:	10 37       	cp.w	r7,r8
800083b2:	c0 b4       	brge	800083c8 <_vfprintf_r+0x1158>
800083b4:	fa c8 f9 44 	sub	r8,sp,-1724
800083b8:	14 97       	mov	r7,r10
800083ba:	f0 06 00 36 	add	r6,r8,r6<<0x3
800083be:	ec ea fd 88 	ld.d	r10,r6[-632]
800083c2:	fa eb 00 00 	st.d	sp[0],r10
800083c6:	c2 08       	rjmp	80008406 <_vfprintf_r+0x1196>
800083c8:	41 09       	lddsp	r9,sp[0x40]
800083ca:	59 f8       	cp.w	r8,31
800083cc:	e0 89 00 16 	brgt	800083f8 <_vfprintf_r+0x1188>
800083d0:	f2 e6 00 00 	ld.d	r6,r9[0]
800083d4:	f2 cb ff f8 	sub	r11,r9,-8
800083d8:	fa e7 00 00 	st.d	sp[0],r6
800083dc:	51 0b       	stdsp	sp[0x40],r11
800083de:	fa c6 f9 44 	sub	r6,sp,-1724
800083e2:	ec 08 00 39 	add	r9,r6,r8<<0x3
800083e6:	fa e6 00 00 	ld.d	r6,sp[0]
800083ea:	f2 e7 fd 88 	st.d	r9[-632],r6
800083ee:	2f f8       	sub	r8,-1
800083f0:	14 97       	mov	r7,r10
800083f2:	fb 48 06 b4 	st.w	sp[1716],r8
800083f6:	c0 88       	rjmp	80008406 <_vfprintf_r+0x1196>
800083f8:	f2 e6 00 00 	ld.d	r6,r9[0]
800083fc:	2f 89       	sub	r9,-8
800083fe:	fa e7 00 00 	st.d	sp[0],r6
80008402:	51 09       	stdsp	sp[0x40],r9
80008404:	14 97       	mov	r7,r10
80008406:	30 18       	mov	r8,1
80008408:	e0 8f 01 d0 	bral	800087a8 <_vfprintf_r+0x1538>
8000840c:	ed b5 00 04 	bld	r5,0x4
80008410:	c1 61       	brne	8000843c <_vfprintf_r+0x11cc>
80008412:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008416:	40 3e       	lddsp	lr,sp[0xc]
80008418:	58 0e       	cp.w	lr,0
8000841a:	c0 80       	breq	8000842a <_vfprintf_r+0x11ba>
8000841c:	10 36       	cp.w	r6,r8
8000841e:	c6 74       	brge	800084ec <_vfprintf_r+0x127c>
80008420:	fa cc f9 44 	sub	r12,sp,-1724
80008424:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008428:	c8 08       	rjmp	80008528 <_vfprintf_r+0x12b8>
8000842a:	ee ca ff ff 	sub	r10,r7,-1
8000842e:	10 37       	cp.w	r7,r8
80008430:	c7 f4       	brge	8000852e <_vfprintf_r+0x12be>
80008432:	fa cb f9 44 	sub	r11,sp,-1724
80008436:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000843a:	c7 68       	rjmp	80008526 <_vfprintf_r+0x12b6>
8000843c:	ed b5 00 06 	bld	r5,0x6
80008440:	c4 a1       	brne	800084d4 <_vfprintf_r+0x1264>
80008442:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008446:	40 3c       	lddsp	r12,sp[0xc]
80008448:	58 0c       	cp.w	r12,0
8000844a:	c1 d0       	breq	80008484 <_vfprintf_r+0x1214>
8000844c:	10 36       	cp.w	r6,r8
8000844e:	c0 64       	brge	8000845a <_vfprintf_r+0x11ea>
80008450:	fa cb f9 44 	sub	r11,sp,-1724
80008454:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008458:	c1 f8       	rjmp	80008496 <_vfprintf_r+0x1226>
8000845a:	fa c8 f9 50 	sub	r8,sp,-1712
8000845e:	1a d8       	st.w	--sp,r8
80008460:	fa c8 fa b8 	sub	r8,sp,-1352
80008464:	1a d8       	st.w	--sp,r8
80008466:	fa c8 fb b4 	sub	r8,sp,-1100
8000846a:	1a d8       	st.w	--sp,r8
8000846c:	fa c8 f9 40 	sub	r8,sp,-1728
80008470:	fa c9 ff b4 	sub	r9,sp,-76
80008474:	04 9a       	mov	r10,r2
80008476:	0c 9b       	mov	r11,r6
80008478:	08 9c       	mov	r12,r4
8000847a:	fe b0 f5 63 	rcall	80006f40 <get_arg>
8000847e:	2f dd       	sub	sp,-12
80008480:	98 18       	ld.sh	r8,r12[0x2]
80008482:	c2 68       	rjmp	800084ce <_vfprintf_r+0x125e>
80008484:	ee ca ff ff 	sub	r10,r7,-1
80008488:	10 37       	cp.w	r7,r8
8000848a:	c0 94       	brge	8000849c <_vfprintf_r+0x122c>
8000848c:	fa c9 f9 44 	sub	r9,sp,-1724
80008490:	14 97       	mov	r7,r10
80008492:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008496:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000849a:	c1 a8       	rjmp	800084ce <_vfprintf_r+0x125e>
8000849c:	41 09       	lddsp	r9,sp[0x40]
8000849e:	59 f8       	cp.w	r8,31
800084a0:	e0 89 00 13 	brgt	800084c6 <_vfprintf_r+0x1256>
800084a4:	f2 cb ff fc 	sub	r11,r9,-4
800084a8:	51 0b       	stdsp	sp[0x40],r11
800084aa:	72 09       	ld.w	r9,r9[0x0]
800084ac:	fa c6 f9 44 	sub	r6,sp,-1724
800084b0:	ec 08 00 3b 	add	r11,r6,r8<<0x3
800084b4:	2f f8       	sub	r8,-1
800084b6:	f7 49 fd 88 	st.w	r11[-632],r9
800084ba:	fb 48 06 b4 	st.w	sp[1716],r8
800084be:	14 97       	mov	r7,r10
800084c0:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
800084c4:	c0 58       	rjmp	800084ce <_vfprintf_r+0x125e>
800084c6:	92 18       	ld.sh	r8,r9[0x2]
800084c8:	14 97       	mov	r7,r10
800084ca:	2f c9       	sub	r9,-4
800084cc:	51 09       	stdsp	sp[0x40],r9
800084ce:	5c 78       	castu.h	r8
800084d0:	50 18       	stdsp	sp[0x4],r8
800084d2:	c4 68       	rjmp	8000855e <_vfprintf_r+0x12ee>
800084d4:	fa f8 06 b4 	ld.w	r8,sp[1716]
800084d8:	40 3c       	lddsp	r12,sp[0xc]
800084da:	58 0c       	cp.w	r12,0
800084dc:	c1 d0       	breq	80008516 <_vfprintf_r+0x12a6>
800084de:	10 36       	cp.w	r6,r8
800084e0:	c0 64       	brge	800084ec <_vfprintf_r+0x127c>
800084e2:	fa cb f9 44 	sub	r11,sp,-1724
800084e6:	f6 06 00 36 	add	r6,r11,r6<<0x3
800084ea:	c1 f8       	rjmp	80008528 <_vfprintf_r+0x12b8>
800084ec:	fa c8 f9 50 	sub	r8,sp,-1712
800084f0:	1a d8       	st.w	--sp,r8
800084f2:	fa c8 fa b8 	sub	r8,sp,-1352
800084f6:	0c 9b       	mov	r11,r6
800084f8:	1a d8       	st.w	--sp,r8
800084fa:	fa c8 fb b4 	sub	r8,sp,-1100
800084fe:	04 9a       	mov	r10,r2
80008500:	1a d8       	st.w	--sp,r8
80008502:	08 9c       	mov	r12,r4
80008504:	fa c8 f9 40 	sub	r8,sp,-1728
80008508:	fa c9 ff b4 	sub	r9,sp,-76
8000850c:	fe b0 f5 1a 	rcall	80006f40 <get_arg>
80008510:	2f dd       	sub	sp,-12
80008512:	78 0b       	ld.w	r11,r12[0x0]
80008514:	c2 48       	rjmp	8000855c <_vfprintf_r+0x12ec>
80008516:	ee ca ff ff 	sub	r10,r7,-1
8000851a:	10 37       	cp.w	r7,r8
8000851c:	c0 94       	brge	8000852e <_vfprintf_r+0x12be>
8000851e:	fa c9 f9 44 	sub	r9,sp,-1724
80008522:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008526:	14 97       	mov	r7,r10
80008528:	ec fb fd 88 	ld.w	r11,r6[-632]
8000852c:	c1 88       	rjmp	8000855c <_vfprintf_r+0x12ec>
8000852e:	41 09       	lddsp	r9,sp[0x40]
80008530:	59 f8       	cp.w	r8,31
80008532:	e0 89 00 11 	brgt	80008554 <_vfprintf_r+0x12e4>
80008536:	f2 cb ff fc 	sub	r11,r9,-4
8000853a:	51 0b       	stdsp	sp[0x40],r11
8000853c:	fa c6 f9 44 	sub	r6,sp,-1724
80008540:	72 0b       	ld.w	r11,r9[0x0]
80008542:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008546:	f3 4b fd 88 	st.w	r9[-632],r11
8000854a:	2f f8       	sub	r8,-1
8000854c:	14 97       	mov	r7,r10
8000854e:	fb 48 06 b4 	st.w	sp[1716],r8
80008552:	c0 58       	rjmp	8000855c <_vfprintf_r+0x12ec>
80008554:	72 0b       	ld.w	r11,r9[0x0]
80008556:	14 97       	mov	r7,r10
80008558:	2f c9       	sub	r9,-4
8000855a:	51 09       	stdsp	sp[0x40],r9
8000855c:	50 1b       	stdsp	sp[0x4],r11
8000855e:	30 0e       	mov	lr,0
80008560:	30 18       	mov	r8,1
80008562:	50 0e       	stdsp	sp[0x0],lr
80008564:	c2 29       	rjmp	800087a8 <_vfprintf_r+0x1538>
80008566:	50 a7       	stdsp	sp[0x28],r7
80008568:	50 80       	stdsp	sp[0x20],r0
8000856a:	0c 97       	mov	r7,r6
8000856c:	04 94       	mov	r4,r2
8000856e:	06 96       	mov	r6,r3
80008570:	02 92       	mov	r2,r1
80008572:	fe cc b3 fe 	sub	r12,pc,-19458
80008576:	40 93       	lddsp	r3,sp[0x24]
80008578:	10 90       	mov	r0,r8
8000857a:	40 41       	lddsp	r1,sp[0x10]
8000857c:	50 dc       	stdsp	sp[0x34],r12
8000857e:	ed b5 00 05 	bld	r5,0x5
80008582:	c5 51       	brne	8000862c <_vfprintf_r+0x13bc>
80008584:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008588:	40 3b       	lddsp	r11,sp[0xc]
8000858a:	58 0b       	cp.w	r11,0
8000858c:	c2 20       	breq	800085d0 <_vfprintf_r+0x1360>
8000858e:	10 36       	cp.w	r6,r8
80008590:	c0 a4       	brge	800085a4 <_vfprintf_r+0x1334>
80008592:	fa ca f9 44 	sub	r10,sp,-1724
80008596:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000859a:	ec e8 fd 88 	ld.d	r8,r6[-632]
8000859e:	fa e9 00 00 	st.d	sp[0],r8
800085a2:	cf 28       	rjmp	80008786 <_vfprintf_r+0x1516>
800085a4:	fa c8 f9 50 	sub	r8,sp,-1712
800085a8:	1a d8       	st.w	--sp,r8
800085aa:	fa c8 fa b8 	sub	r8,sp,-1352
800085ae:	04 9a       	mov	r10,r2
800085b0:	1a d8       	st.w	--sp,r8
800085b2:	0c 9b       	mov	r11,r6
800085b4:	fa c8 fb b4 	sub	r8,sp,-1100
800085b8:	08 9c       	mov	r12,r4
800085ba:	1a d8       	st.w	--sp,r8
800085bc:	fa c8 f9 40 	sub	r8,sp,-1728
800085c0:	fa c9 ff b4 	sub	r9,sp,-76
800085c4:	fe b0 f4 be 	rcall	80006f40 <get_arg>
800085c8:	2f dd       	sub	sp,-12
800085ca:	f8 ea 00 00 	ld.d	r10,r12[0]
800085ce:	c0 c8       	rjmp	800085e6 <_vfprintf_r+0x1376>
800085d0:	ee ca ff ff 	sub	r10,r7,-1
800085d4:	10 37       	cp.w	r7,r8
800085d6:	c0 b4       	brge	800085ec <_vfprintf_r+0x137c>
800085d8:	fa c9 f9 44 	sub	r9,sp,-1724
800085dc:	14 97       	mov	r7,r10
800085de:	f2 06 00 36 	add	r6,r9,r6<<0x3
800085e2:	ec ea fd 88 	ld.d	r10,r6[-632]
800085e6:	fa eb 00 00 	st.d	sp[0],r10
800085ea:	cc e8       	rjmp	80008786 <_vfprintf_r+0x1516>
800085ec:	41 09       	lddsp	r9,sp[0x40]
800085ee:	59 f8       	cp.w	r8,31
800085f0:	e0 89 00 16 	brgt	8000861c <_vfprintf_r+0x13ac>
800085f4:	f2 e6 00 00 	ld.d	r6,r9[0]
800085f8:	f2 cb ff f8 	sub	r11,r9,-8
800085fc:	fa e7 00 00 	st.d	sp[0],r6
80008600:	51 0b       	stdsp	sp[0x40],r11
80008602:	fa c6 f9 44 	sub	r6,sp,-1724
80008606:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000860a:	fa e6 00 00 	ld.d	r6,sp[0]
8000860e:	f2 e7 fd 88 	st.d	r9[-632],r6
80008612:	2f f8       	sub	r8,-1
80008614:	14 97       	mov	r7,r10
80008616:	fb 48 06 b4 	st.w	sp[1716],r8
8000861a:	cb 68       	rjmp	80008786 <_vfprintf_r+0x1516>
8000861c:	f2 e6 00 00 	ld.d	r6,r9[0]
80008620:	2f 89       	sub	r9,-8
80008622:	fa e7 00 00 	st.d	sp[0],r6
80008626:	51 09       	stdsp	sp[0x40],r9
80008628:	14 97       	mov	r7,r10
8000862a:	ca e8       	rjmp	80008786 <_vfprintf_r+0x1516>
8000862c:	ed b5 00 04 	bld	r5,0x4
80008630:	c1 71       	brne	8000865e <_vfprintf_r+0x13ee>
80008632:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008636:	40 3e       	lddsp	lr,sp[0xc]
80008638:	58 0e       	cp.w	lr,0
8000863a:	c0 80       	breq	8000864a <_vfprintf_r+0x13da>
8000863c:	10 36       	cp.w	r6,r8
8000863e:	c6 94       	brge	80008710 <_vfprintf_r+0x14a0>
80008640:	fa cc f9 44 	sub	r12,sp,-1724
80008644:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008648:	c8 28       	rjmp	8000874c <_vfprintf_r+0x14dc>
8000864a:	ee ca ff ff 	sub	r10,r7,-1
8000864e:	10 37       	cp.w	r7,r8
80008650:	e0 84 00 81 	brge	80008752 <_vfprintf_r+0x14e2>
80008654:	fa cb f9 44 	sub	r11,sp,-1724
80008658:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000865c:	c7 78       	rjmp	8000874a <_vfprintf_r+0x14da>
8000865e:	ed b5 00 06 	bld	r5,0x6
80008662:	c4 b1       	brne	800086f8 <_vfprintf_r+0x1488>
80008664:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008668:	40 3c       	lddsp	r12,sp[0xc]
8000866a:	58 0c       	cp.w	r12,0
8000866c:	c1 d0       	breq	800086a6 <_vfprintf_r+0x1436>
8000866e:	10 36       	cp.w	r6,r8
80008670:	c0 64       	brge	8000867c <_vfprintf_r+0x140c>
80008672:	fa cb f9 44 	sub	r11,sp,-1724
80008676:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000867a:	c1 f8       	rjmp	800086b8 <_vfprintf_r+0x1448>
8000867c:	fa c8 f9 50 	sub	r8,sp,-1712
80008680:	1a d8       	st.w	--sp,r8
80008682:	fa c8 fa b8 	sub	r8,sp,-1352
80008686:	1a d8       	st.w	--sp,r8
80008688:	fa c8 fb b4 	sub	r8,sp,-1100
8000868c:	1a d8       	st.w	--sp,r8
8000868e:	fa c8 f9 40 	sub	r8,sp,-1728
80008692:	fa c9 ff b4 	sub	r9,sp,-76
80008696:	04 9a       	mov	r10,r2
80008698:	0c 9b       	mov	r11,r6
8000869a:	08 9c       	mov	r12,r4
8000869c:	fe b0 f4 52 	rcall	80006f40 <get_arg>
800086a0:	2f dd       	sub	sp,-12
800086a2:	98 18       	ld.sh	r8,r12[0x2]
800086a4:	c2 78       	rjmp	800086f2 <_vfprintf_r+0x1482>
800086a6:	ee ca ff ff 	sub	r10,r7,-1
800086aa:	10 37       	cp.w	r7,r8
800086ac:	c0 a4       	brge	800086c0 <_vfprintf_r+0x1450>
800086ae:	fa c9 f9 44 	sub	r9,sp,-1724
800086b2:	14 97       	mov	r7,r10
800086b4:	f2 06 00 36 	add	r6,r9,r6<<0x3
800086b8:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
800086bc:	c1 b8       	rjmp	800086f2 <_vfprintf_r+0x1482>
800086be:	d7 03       	nop
800086c0:	41 09       	lddsp	r9,sp[0x40]
800086c2:	59 f8       	cp.w	r8,31
800086c4:	e0 89 00 13 	brgt	800086ea <_vfprintf_r+0x147a>
800086c8:	f2 cb ff fc 	sub	r11,r9,-4
800086cc:	51 0b       	stdsp	sp[0x40],r11
800086ce:	72 09       	ld.w	r9,r9[0x0]
800086d0:	fa c6 f9 44 	sub	r6,sp,-1724
800086d4:	ec 08 00 3b 	add	r11,r6,r8<<0x3
800086d8:	2f f8       	sub	r8,-1
800086da:	f7 49 fd 88 	st.w	r11[-632],r9
800086de:	fb 48 06 b4 	st.w	sp[1716],r8
800086e2:	14 97       	mov	r7,r10
800086e4:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
800086e8:	c0 58       	rjmp	800086f2 <_vfprintf_r+0x1482>
800086ea:	92 18       	ld.sh	r8,r9[0x2]
800086ec:	14 97       	mov	r7,r10
800086ee:	2f c9       	sub	r9,-4
800086f0:	51 09       	stdsp	sp[0x40],r9
800086f2:	5c 78       	castu.h	r8
800086f4:	50 18       	stdsp	sp[0x4],r8
800086f6:	c4 68       	rjmp	80008782 <_vfprintf_r+0x1512>
800086f8:	fa f8 06 b4 	ld.w	r8,sp[1716]
800086fc:	40 3c       	lddsp	r12,sp[0xc]
800086fe:	58 0c       	cp.w	r12,0
80008700:	c1 d0       	breq	8000873a <_vfprintf_r+0x14ca>
80008702:	10 36       	cp.w	r6,r8
80008704:	c0 64       	brge	80008710 <_vfprintf_r+0x14a0>
80008706:	fa cb f9 44 	sub	r11,sp,-1724
8000870a:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000870e:	c1 f8       	rjmp	8000874c <_vfprintf_r+0x14dc>
80008710:	fa c8 f9 50 	sub	r8,sp,-1712
80008714:	1a d8       	st.w	--sp,r8
80008716:	fa c8 fa b8 	sub	r8,sp,-1352
8000871a:	0c 9b       	mov	r11,r6
8000871c:	1a d8       	st.w	--sp,r8
8000871e:	fa c8 fb b4 	sub	r8,sp,-1100
80008722:	04 9a       	mov	r10,r2
80008724:	1a d8       	st.w	--sp,r8
80008726:	08 9c       	mov	r12,r4
80008728:	fa c8 f9 40 	sub	r8,sp,-1728
8000872c:	fa c9 ff b4 	sub	r9,sp,-76
80008730:	fe b0 f4 08 	rcall	80006f40 <get_arg>
80008734:	2f dd       	sub	sp,-12
80008736:	78 0b       	ld.w	r11,r12[0x0]
80008738:	c2 48       	rjmp	80008780 <_vfprintf_r+0x1510>
8000873a:	ee ca ff ff 	sub	r10,r7,-1
8000873e:	10 37       	cp.w	r7,r8
80008740:	c0 94       	brge	80008752 <_vfprintf_r+0x14e2>
80008742:	fa c9 f9 44 	sub	r9,sp,-1724
80008746:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000874a:	14 97       	mov	r7,r10
8000874c:	ec fb fd 88 	ld.w	r11,r6[-632]
80008750:	c1 88       	rjmp	80008780 <_vfprintf_r+0x1510>
80008752:	41 09       	lddsp	r9,sp[0x40]
80008754:	59 f8       	cp.w	r8,31
80008756:	e0 89 00 11 	brgt	80008778 <_vfprintf_r+0x1508>
8000875a:	f2 cb ff fc 	sub	r11,r9,-4
8000875e:	51 0b       	stdsp	sp[0x40],r11
80008760:	fa c6 f9 44 	sub	r6,sp,-1724
80008764:	72 0b       	ld.w	r11,r9[0x0]
80008766:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000876a:	f3 4b fd 88 	st.w	r9[-632],r11
8000876e:	2f f8       	sub	r8,-1
80008770:	14 97       	mov	r7,r10
80008772:	fb 48 06 b4 	st.w	sp[1716],r8
80008776:	c0 58       	rjmp	80008780 <_vfprintf_r+0x1510>
80008778:	72 0b       	ld.w	r11,r9[0x0]
8000877a:	14 97       	mov	r7,r10
8000877c:	2f c9       	sub	r9,-4
8000877e:	51 09       	stdsp	sp[0x40],r9
80008780:	50 1b       	stdsp	sp[0x4],r11
80008782:	30 0e       	mov	lr,0
80008784:	50 0e       	stdsp	sp[0x0],lr
80008786:	40 08       	lddsp	r8,sp[0x0]
80008788:	40 1c       	lddsp	r12,sp[0x4]
8000878a:	18 48       	or	r8,r12
8000878c:	5f 19       	srne	r9
8000878e:	0a 98       	mov	r8,r5
80008790:	eb e9 00 09 	and	r9,r5,r9
80008794:	a1 b8       	sbr	r8,0x1
80008796:	58 09       	cp.w	r9,0
80008798:	c0 70       	breq	800087a6 <_vfprintf_r+0x1536>
8000879a:	10 95       	mov	r5,r8
8000879c:	fb 60 06 b9 	st.b	sp[1721],r0
800087a0:	33 08       	mov	r8,48
800087a2:	fb 68 06 b8 	st.b	sp[1720],r8
800087a6:	30 28       	mov	r8,2
800087a8:	30 09       	mov	r9,0
800087aa:	fb 69 06 bb 	st.b	sp[1723],r9
800087ae:	0a 99       	mov	r9,r5
800087b0:	a7 d9       	cbr	r9,0x7
800087b2:	40 2b       	lddsp	r11,sp[0x8]
800087b4:	40 16       	lddsp	r6,sp[0x4]
800087b6:	58 0b       	cp.w	r11,0
800087b8:	5f 1a       	srne	r10
800087ba:	f2 05 17 40 	movge	r5,r9
800087be:	fa c2 f9 78 	sub	r2,sp,-1672
800087c2:	40 09       	lddsp	r9,sp[0x0]
800087c4:	0c 49       	or	r9,r6
800087c6:	5f 19       	srne	r9
800087c8:	f5 e9 10 09 	or	r9,r10,r9
800087cc:	c5 c0       	breq	80008884 <_vfprintf_r+0x1614>
800087ce:	30 19       	mov	r9,1
800087d0:	f2 08 18 00 	cp.b	r8,r9
800087d4:	c0 60       	breq	800087e0 <_vfprintf_r+0x1570>
800087d6:	30 29       	mov	r9,2
800087d8:	f2 08 18 00 	cp.b	r8,r9
800087dc:	c0 41       	brne	800087e4 <_vfprintf_r+0x1574>
800087de:	c3 c8       	rjmp	80008856 <_vfprintf_r+0x15e6>
800087e0:	04 96       	mov	r6,r2
800087e2:	c3 08       	rjmp	80008842 <_vfprintf_r+0x15d2>
800087e4:	04 96       	mov	r6,r2
800087e6:	fa e8 00 00 	ld.d	r8,sp[0]
800087ea:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
800087ee:	2d 0a       	sub	r10,-48
800087f0:	0c fa       	st.b	--r6,r10
800087f2:	f0 0b 16 03 	lsr	r11,r8,0x3
800087f6:	f2 0c 16 03 	lsr	r12,r9,0x3
800087fa:	f7 e9 11 db 	or	r11,r11,r9<<0x1d
800087fe:	18 99       	mov	r9,r12
80008800:	16 98       	mov	r8,r11
80008802:	58 08       	cp.w	r8,0
80008804:	5c 29       	cpc	r9
80008806:	cf 21       	brne	800087ea <_vfprintf_r+0x157a>
80008808:	fa e9 00 00 	st.d	sp[0],r8
8000880c:	ed b5 00 00 	bld	r5,0x0
80008810:	c4 51       	brne	8000889a <_vfprintf_r+0x162a>
80008812:	33 09       	mov	r9,48
80008814:	f2 0a 18 00 	cp.b	r10,r9
80008818:	c4 10       	breq	8000889a <_vfprintf_r+0x162a>
8000881a:	0c f9       	st.b	--r6,r9
8000881c:	c3 f8       	rjmp	8000889a <_vfprintf_r+0x162a>
8000881e:	fa ea 00 00 	ld.d	r10,sp[0]
80008822:	30 a8       	mov	r8,10
80008824:	30 09       	mov	r9,0
80008826:	e0 a0 1a 19 	rcall	8000bc58 <__avr32_umod64>
8000882a:	30 a8       	mov	r8,10
8000882c:	2d 0a       	sub	r10,-48
8000882e:	30 09       	mov	r9,0
80008830:	ac 8a       	st.b	r6[0x0],r10
80008832:	fa ea 00 00 	ld.d	r10,sp[0]
80008836:	e0 a0 18 df 	rcall	8000b9f4 <__avr32_udiv64>
8000883a:	16 99       	mov	r9,r11
8000883c:	14 98       	mov	r8,r10
8000883e:	fa e9 00 00 	st.d	sp[0],r8
80008842:	20 16       	sub	r6,1
80008844:	fa ea 00 00 	ld.d	r10,sp[0]
80008848:	58 9a       	cp.w	r10,9
8000884a:	5c 2b       	cpc	r11
8000884c:	fe 9b ff e9 	brhi	8000881e <_vfprintf_r+0x15ae>
80008850:	1b f8       	ld.ub	r8,sp[0x7]
80008852:	2d 08       	sub	r8,-48
80008854:	c2 08       	rjmp	80008894 <_vfprintf_r+0x1624>
80008856:	04 96       	mov	r6,r2
80008858:	fa e8 00 00 	ld.d	r8,sp[0]
8000885c:	f5 d8 c0 04 	bfextu	r10,r8,0x0,0x4
80008860:	40 de       	lddsp	lr,sp[0x34]
80008862:	fc 0a 07 0a 	ld.ub	r10,lr[r10]
80008866:	0c fa       	st.b	--r6,r10
80008868:	f2 0b 16 04 	lsr	r11,r9,0x4
8000886c:	f0 0a 16 04 	lsr	r10,r8,0x4
80008870:	f5 e9 11 ca 	or	r10,r10,r9<<0x1c
80008874:	16 99       	mov	r9,r11
80008876:	14 98       	mov	r8,r10
80008878:	58 08       	cp.w	r8,0
8000887a:	5c 29       	cpc	r9
8000887c:	cf 01       	brne	8000885c <_vfprintf_r+0x15ec>
8000887e:	fa e9 00 00 	st.d	sp[0],r8
80008882:	c0 c8       	rjmp	8000889a <_vfprintf_r+0x162a>
80008884:	58 08       	cp.w	r8,0
80008886:	c0 91       	brne	80008898 <_vfprintf_r+0x1628>
80008888:	ed b5 00 00 	bld	r5,0x0
8000888c:	c0 61       	brne	80008898 <_vfprintf_r+0x1628>
8000888e:	fa c6 f9 79 	sub	r6,sp,-1671
80008892:	33 08       	mov	r8,48
80008894:	ac 88       	st.b	r6[0x0],r8
80008896:	c0 28       	rjmp	8000889a <_vfprintf_r+0x162a>
80008898:	04 96       	mov	r6,r2
8000889a:	0c 12       	sub	r2,r6
8000889c:	c1 c8       	rjmp	800088d4 <_vfprintf_r+0x1664>
8000889e:	50 a7       	stdsp	sp[0x28],r7
800088a0:	50 80       	stdsp	sp[0x20],r0
800088a2:	40 93       	lddsp	r3,sp[0x24]
800088a4:	0c 97       	mov	r7,r6
800088a6:	10 90       	mov	r0,r8
800088a8:	04 94       	mov	r4,r2
800088aa:	40 41       	lddsp	r1,sp[0x10]
800088ac:	58 08       	cp.w	r8,0
800088ae:	e0 80 04 4f 	breq	8000914c <_vfprintf_r+0x1edc>
800088b2:	fb 68 06 60 	st.b	sp[1632],r8
800088b6:	30 0c       	mov	r12,0
800088b8:	30 08       	mov	r8,0
800088ba:	30 12       	mov	r2,1
800088bc:	fb 68 06 bb 	st.b	sp[1723],r8
800088c0:	50 2c       	stdsp	sp[0x8],r12
800088c2:	fa c6 f9 a0 	sub	r6,sp,-1632
800088c6:	c0 78       	rjmp	800088d4 <_vfprintf_r+0x1664>
800088c8:	30 0b       	mov	r11,0
800088ca:	50 2b       	stdsp	sp[0x8],r11
800088cc:	c0 48       	rjmp	800088d4 <_vfprintf_r+0x1664>
800088ce:	40 22       	lddsp	r2,sp[0x8]
800088d0:	30 0a       	mov	r10,0
800088d2:	50 2a       	stdsp	sp[0x8],r10
800088d4:	40 29       	lddsp	r9,sp[0x8]
800088d6:	e4 09 0c 49 	max	r9,r2,r9
800088da:	fb 38 06 bb 	ld.ub	r8,sp[1723]
800088de:	50 39       	stdsp	sp[0xc],r9
800088e0:	0a 9e       	mov	lr,r5
800088e2:	30 09       	mov	r9,0
800088e4:	e2 1e 00 02 	andl	lr,0x2,COH
800088e8:	f2 08 18 00 	cp.b	r8,r9
800088ec:	fb f8 10 03 	ld.wne	r8,sp[0xc]
800088f0:	f7 b8 01 ff 	subne	r8,-1
800088f4:	fb f8 1a 03 	st.wne	sp[0xc],r8
800088f8:	0a 9b       	mov	r11,r5
800088fa:	58 0e       	cp.w	lr,0
800088fc:	fb fc 10 03 	ld.wne	r12,sp[0xc]
80008900:	f7 bc 01 fe 	subne	r12,-2
80008904:	fb fc 1a 03 	st.wne	sp[0xc],r12
80008908:	e2 1b 00 84 	andl	r11,0x84,COH
8000890c:	50 fe       	stdsp	sp[0x3c],lr
8000890e:	50 9b       	stdsp	sp[0x24],r11
80008910:	c4 71       	brne	8000899e <_vfprintf_r+0x172e>
80008912:	40 8a       	lddsp	r10,sp[0x20]
80008914:	40 39       	lddsp	r9,sp[0xc]
80008916:	12 1a       	sub	r10,r9
80008918:	50 4a       	stdsp	sp[0x10],r10
8000891a:	58 0a       	cp.w	r10,0
8000891c:	e0 89 00 20 	brgt	8000895c <_vfprintf_r+0x16ec>
80008920:	c3 f8       	rjmp	8000899e <_vfprintf_r+0x172e>
80008922:	2f 09       	sub	r9,-16
80008924:	2f f8       	sub	r8,-1
80008926:	fe ce b7 9a 	sub	lr,pc,-18534
8000892a:	31 0c       	mov	r12,16
8000892c:	fb 49 06 90 	st.w	sp[1680],r9
80008930:	87 0e       	st.w	r3[0x0],lr
80008932:	87 1c       	st.w	r3[0x4],r12
80008934:	fb 48 06 8c 	st.w	sp[1676],r8
80008938:	58 78       	cp.w	r8,7
8000893a:	e0 89 00 04 	brgt	80008942 <_vfprintf_r+0x16d2>
8000893e:	2f 83       	sub	r3,-8
80008940:	c0 b8       	rjmp	80008956 <_vfprintf_r+0x16e6>
80008942:	fa ca f9 78 	sub	r10,sp,-1672
80008946:	02 9b       	mov	r11,r1
80008948:	08 9c       	mov	r12,r4
8000894a:	fe b0 f4 85 	rcall	80007254 <__sprint_r>
8000894e:	e0 81 04 10 	brne	8000916e <_vfprintf_r+0x1efe>
80008952:	fa c3 f9 e0 	sub	r3,sp,-1568
80008956:	40 4b       	lddsp	r11,sp[0x10]
80008958:	21 0b       	sub	r11,16
8000895a:	50 4b       	stdsp	sp[0x10],r11
8000895c:	fa f9 06 90 	ld.w	r9,sp[1680]
80008960:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008964:	fe ca b7 d8 	sub	r10,pc,-18472
80008968:	40 4e       	lddsp	lr,sp[0x10]
8000896a:	59 0e       	cp.w	lr,16
8000896c:	fe 99 ff db 	brgt	80008922 <_vfprintf_r+0x16b2>
80008970:	1c 09       	add	r9,lr
80008972:	2f f8       	sub	r8,-1
80008974:	87 0a       	st.w	r3[0x0],r10
80008976:	fb 49 06 90 	st.w	sp[1680],r9
8000897a:	87 1e       	st.w	r3[0x4],lr
8000897c:	fb 48 06 8c 	st.w	sp[1676],r8
80008980:	58 78       	cp.w	r8,7
80008982:	e0 89 00 04 	brgt	8000898a <_vfprintf_r+0x171a>
80008986:	2f 83       	sub	r3,-8
80008988:	c0 b8       	rjmp	8000899e <_vfprintf_r+0x172e>
8000898a:	fa ca f9 78 	sub	r10,sp,-1672
8000898e:	02 9b       	mov	r11,r1
80008990:	08 9c       	mov	r12,r4
80008992:	fe b0 f4 61 	rcall	80007254 <__sprint_r>
80008996:	e0 81 03 ec 	brne	8000916e <_vfprintf_r+0x1efe>
8000899a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000899e:	30 09       	mov	r9,0
800089a0:	fb 38 06 bb 	ld.ub	r8,sp[1723]
800089a4:	f2 08 18 00 	cp.b	r8,r9
800089a8:	c1 f0       	breq	800089e6 <_vfprintf_r+0x1776>
800089aa:	fa f8 06 90 	ld.w	r8,sp[1680]
800089ae:	fa c9 f9 45 	sub	r9,sp,-1723
800089b2:	2f f8       	sub	r8,-1
800089b4:	87 09       	st.w	r3[0x0],r9
800089b6:	fb 48 06 90 	st.w	sp[1680],r8
800089ba:	30 19       	mov	r9,1
800089bc:	fa f8 06 8c 	ld.w	r8,sp[1676]
800089c0:	87 19       	st.w	r3[0x4],r9
800089c2:	2f f8       	sub	r8,-1
800089c4:	fb 48 06 8c 	st.w	sp[1676],r8
800089c8:	58 78       	cp.w	r8,7
800089ca:	e0 89 00 04 	brgt	800089d2 <_vfprintf_r+0x1762>
800089ce:	2f 83       	sub	r3,-8
800089d0:	c0 b8       	rjmp	800089e6 <_vfprintf_r+0x1776>
800089d2:	fa ca f9 78 	sub	r10,sp,-1672
800089d6:	02 9b       	mov	r11,r1
800089d8:	08 9c       	mov	r12,r4
800089da:	fe b0 f4 3d 	rcall	80007254 <__sprint_r>
800089de:	e0 81 03 c8 	brne	8000916e <_vfprintf_r+0x1efe>
800089e2:	fa c3 f9 e0 	sub	r3,sp,-1568
800089e6:	40 fc       	lddsp	r12,sp[0x3c]
800089e8:	58 0c       	cp.w	r12,0
800089ea:	c1 f0       	breq	80008a28 <_vfprintf_r+0x17b8>
800089ec:	fa f8 06 90 	ld.w	r8,sp[1680]
800089f0:	fa c9 f9 48 	sub	r9,sp,-1720
800089f4:	2f e8       	sub	r8,-2
800089f6:	87 09       	st.w	r3[0x0],r9
800089f8:	fb 48 06 90 	st.w	sp[1680],r8
800089fc:	30 29       	mov	r9,2
800089fe:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008a02:	87 19       	st.w	r3[0x4],r9
80008a04:	2f f8       	sub	r8,-1
80008a06:	fb 48 06 8c 	st.w	sp[1676],r8
80008a0a:	58 78       	cp.w	r8,7
80008a0c:	e0 89 00 04 	brgt	80008a14 <_vfprintf_r+0x17a4>
80008a10:	2f 83       	sub	r3,-8
80008a12:	c0 b8       	rjmp	80008a28 <_vfprintf_r+0x17b8>
80008a14:	fa ca f9 78 	sub	r10,sp,-1672
80008a18:	02 9b       	mov	r11,r1
80008a1a:	08 9c       	mov	r12,r4
80008a1c:	fe b0 f4 1c 	rcall	80007254 <__sprint_r>
80008a20:	e0 81 03 a7 	brne	8000916e <_vfprintf_r+0x1efe>
80008a24:	fa c3 f9 e0 	sub	r3,sp,-1568
80008a28:	40 9b       	lddsp	r11,sp[0x24]
80008a2a:	e0 4b 00 80 	cp.w	r11,128
80008a2e:	c4 71       	brne	80008abc <_vfprintf_r+0x184c>
80008a30:	40 8a       	lddsp	r10,sp[0x20]
80008a32:	40 39       	lddsp	r9,sp[0xc]
80008a34:	12 1a       	sub	r10,r9
80008a36:	50 4a       	stdsp	sp[0x10],r10
80008a38:	58 0a       	cp.w	r10,0
80008a3a:	e0 89 00 20 	brgt	80008a7a <_vfprintf_r+0x180a>
80008a3e:	c3 f8       	rjmp	80008abc <_vfprintf_r+0x184c>
80008a40:	2f 09       	sub	r9,-16
80008a42:	2f f8       	sub	r8,-1
80008a44:	fe ce b8 a8 	sub	lr,pc,-18264
80008a48:	31 0c       	mov	r12,16
80008a4a:	fb 49 06 90 	st.w	sp[1680],r9
80008a4e:	87 0e       	st.w	r3[0x0],lr
80008a50:	87 1c       	st.w	r3[0x4],r12
80008a52:	fb 48 06 8c 	st.w	sp[1676],r8
80008a56:	58 78       	cp.w	r8,7
80008a58:	e0 89 00 04 	brgt	80008a60 <_vfprintf_r+0x17f0>
80008a5c:	2f 83       	sub	r3,-8
80008a5e:	c0 b8       	rjmp	80008a74 <_vfprintf_r+0x1804>
80008a60:	fa ca f9 78 	sub	r10,sp,-1672
80008a64:	02 9b       	mov	r11,r1
80008a66:	08 9c       	mov	r12,r4
80008a68:	fe b0 f3 f6 	rcall	80007254 <__sprint_r>
80008a6c:	e0 81 03 81 	brne	8000916e <_vfprintf_r+0x1efe>
80008a70:	fa c3 f9 e0 	sub	r3,sp,-1568
80008a74:	40 4b       	lddsp	r11,sp[0x10]
80008a76:	21 0b       	sub	r11,16
80008a78:	50 4b       	stdsp	sp[0x10],r11
80008a7a:	fa f9 06 90 	ld.w	r9,sp[1680]
80008a7e:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008a82:	fe ca b8 e6 	sub	r10,pc,-18202
80008a86:	40 4e       	lddsp	lr,sp[0x10]
80008a88:	59 0e       	cp.w	lr,16
80008a8a:	fe 99 ff db 	brgt	80008a40 <_vfprintf_r+0x17d0>
80008a8e:	1c 09       	add	r9,lr
80008a90:	2f f8       	sub	r8,-1
80008a92:	87 0a       	st.w	r3[0x0],r10
80008a94:	fb 49 06 90 	st.w	sp[1680],r9
80008a98:	87 1e       	st.w	r3[0x4],lr
80008a9a:	fb 48 06 8c 	st.w	sp[1676],r8
80008a9e:	58 78       	cp.w	r8,7
80008aa0:	e0 89 00 04 	brgt	80008aa8 <_vfprintf_r+0x1838>
80008aa4:	2f 83       	sub	r3,-8
80008aa6:	c0 b8       	rjmp	80008abc <_vfprintf_r+0x184c>
80008aa8:	fa ca f9 78 	sub	r10,sp,-1672
80008aac:	02 9b       	mov	r11,r1
80008aae:	08 9c       	mov	r12,r4
80008ab0:	fe b0 f3 d2 	rcall	80007254 <__sprint_r>
80008ab4:	e0 81 03 5d 	brne	8000916e <_vfprintf_r+0x1efe>
80008ab8:	fa c3 f9 e0 	sub	r3,sp,-1568
80008abc:	40 2c       	lddsp	r12,sp[0x8]
80008abe:	04 1c       	sub	r12,r2
80008ac0:	50 2c       	stdsp	sp[0x8],r12
80008ac2:	58 0c       	cp.w	r12,0
80008ac4:	e0 89 00 20 	brgt	80008b04 <_vfprintf_r+0x1894>
80008ac8:	c3 f8       	rjmp	80008b46 <_vfprintf_r+0x18d6>
80008aca:	2f 09       	sub	r9,-16
80008acc:	2f f8       	sub	r8,-1
80008ace:	fe cb b9 32 	sub	r11,pc,-18126
80008ad2:	31 0a       	mov	r10,16
80008ad4:	fb 49 06 90 	st.w	sp[1680],r9
80008ad8:	87 0b       	st.w	r3[0x0],r11
80008ada:	87 1a       	st.w	r3[0x4],r10
80008adc:	fb 48 06 8c 	st.w	sp[1676],r8
80008ae0:	58 78       	cp.w	r8,7
80008ae2:	e0 89 00 04 	brgt	80008aea <_vfprintf_r+0x187a>
80008ae6:	2f 83       	sub	r3,-8
80008ae8:	c0 b8       	rjmp	80008afe <_vfprintf_r+0x188e>
80008aea:	fa ca f9 78 	sub	r10,sp,-1672
80008aee:	02 9b       	mov	r11,r1
80008af0:	08 9c       	mov	r12,r4
80008af2:	fe b0 f3 b1 	rcall	80007254 <__sprint_r>
80008af6:	e0 81 03 3c 	brne	8000916e <_vfprintf_r+0x1efe>
80008afa:	fa c3 f9 e0 	sub	r3,sp,-1568
80008afe:	40 29       	lddsp	r9,sp[0x8]
80008b00:	21 09       	sub	r9,16
80008b02:	50 29       	stdsp	sp[0x8],r9
80008b04:	fa f9 06 90 	ld.w	r9,sp[1680]
80008b08:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008b0c:	fe ca b9 70 	sub	r10,pc,-18064
80008b10:	40 2e       	lddsp	lr,sp[0x8]
80008b12:	59 0e       	cp.w	lr,16
80008b14:	fe 99 ff db 	brgt	80008aca <_vfprintf_r+0x185a>
80008b18:	1c 09       	add	r9,lr
80008b1a:	2f f8       	sub	r8,-1
80008b1c:	87 0a       	st.w	r3[0x0],r10
80008b1e:	fb 49 06 90 	st.w	sp[1680],r9
80008b22:	87 1e       	st.w	r3[0x4],lr
80008b24:	fb 48 06 8c 	st.w	sp[1676],r8
80008b28:	58 78       	cp.w	r8,7
80008b2a:	e0 89 00 04 	brgt	80008b32 <_vfprintf_r+0x18c2>
80008b2e:	2f 83       	sub	r3,-8
80008b30:	c0 b8       	rjmp	80008b46 <_vfprintf_r+0x18d6>
80008b32:	fa ca f9 78 	sub	r10,sp,-1672
80008b36:	02 9b       	mov	r11,r1
80008b38:	08 9c       	mov	r12,r4
80008b3a:	fe b0 f3 8d 	rcall	80007254 <__sprint_r>
80008b3e:	e0 81 03 18 	brne	8000916e <_vfprintf_r+0x1efe>
80008b42:	fa c3 f9 e0 	sub	r3,sp,-1568
80008b46:	ed b5 00 08 	bld	r5,0x8
80008b4a:	c0 b0       	breq	80008b60 <_vfprintf_r+0x18f0>
80008b4c:	fa f8 06 90 	ld.w	r8,sp[1680]
80008b50:	87 12       	st.w	r3[0x4],r2
80008b52:	87 06       	st.w	r3[0x0],r6
80008b54:	f0 02 00 02 	add	r2,r8,r2
80008b58:	fb 42 06 90 	st.w	sp[1680],r2
80008b5c:	e0 8f 01 d4 	bral	80008f04 <_vfprintf_r+0x1c94>
80008b60:	e0 40 00 65 	cp.w	r0,101
80008b64:	e0 8a 01 d6 	brle	80008f10 <_vfprintf_r+0x1ca0>
80008b68:	30 08       	mov	r8,0
80008b6a:	30 09       	mov	r9,0
80008b6c:	40 5b       	lddsp	r11,sp[0x14]
80008b6e:	40 7a       	lddsp	r10,sp[0x1c]
80008b70:	e0 a0 15 3b 	rcall	8000b5e6 <__avr32_f64_cmp_eq>
80008b74:	c7 90       	breq	80008c66 <_vfprintf_r+0x19f6>
80008b76:	fa f8 06 90 	ld.w	r8,sp[1680]
80008b7a:	fe c9 b9 f2 	sub	r9,pc,-17934
80008b7e:	2f f8       	sub	r8,-1
80008b80:	87 09       	st.w	r3[0x0],r9
80008b82:	fb 48 06 90 	st.w	sp[1680],r8
80008b86:	30 19       	mov	r9,1
80008b88:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008b8c:	87 19       	st.w	r3[0x4],r9
80008b8e:	2f f8       	sub	r8,-1
80008b90:	fb 48 06 8c 	st.w	sp[1676],r8
80008b94:	58 78       	cp.w	r8,7
80008b96:	e0 89 00 05 	brgt	80008ba0 <_vfprintf_r+0x1930>
80008b9a:	2f 83       	sub	r3,-8
80008b9c:	c0 c8       	rjmp	80008bb4 <_vfprintf_r+0x1944>
80008b9e:	d7 03       	nop
80008ba0:	fa ca f9 78 	sub	r10,sp,-1672
80008ba4:	02 9b       	mov	r11,r1
80008ba6:	08 9c       	mov	r12,r4
80008ba8:	fe b0 f3 56 	rcall	80007254 <__sprint_r>
80008bac:	e0 81 02 e1 	brne	8000916e <_vfprintf_r+0x1efe>
80008bb0:	fa c3 f9 e0 	sub	r3,sp,-1568
80008bb4:	fa f8 06 ac 	ld.w	r8,sp[1708]
80008bb8:	40 6c       	lddsp	r12,sp[0x18]
80008bba:	18 38       	cp.w	r8,r12
80008bbc:	c0 55       	brlt	80008bc6 <_vfprintf_r+0x1956>
80008bbe:	ed b5 00 00 	bld	r5,0x0
80008bc2:	e0 81 02 6b 	brne	80009098 <_vfprintf_r+0x1e28>
80008bc6:	fa f8 06 90 	ld.w	r8,sp[1680]
80008bca:	2f f8       	sub	r8,-1
80008bcc:	40 cb       	lddsp	r11,sp[0x30]
80008bce:	fb 48 06 90 	st.w	sp[1680],r8
80008bd2:	30 19       	mov	r9,1
80008bd4:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008bd8:	87 0b       	st.w	r3[0x0],r11
80008bda:	2f f8       	sub	r8,-1
80008bdc:	87 19       	st.w	r3[0x4],r9
80008bde:	fb 48 06 8c 	st.w	sp[1676],r8
80008be2:	58 78       	cp.w	r8,7
80008be4:	e0 89 00 04 	brgt	80008bec <_vfprintf_r+0x197c>
80008be8:	2f 83       	sub	r3,-8
80008bea:	c0 b8       	rjmp	80008c00 <_vfprintf_r+0x1990>
80008bec:	fa ca f9 78 	sub	r10,sp,-1672
80008bf0:	02 9b       	mov	r11,r1
80008bf2:	08 9c       	mov	r12,r4
80008bf4:	fe b0 f3 30 	rcall	80007254 <__sprint_r>
80008bf8:	e0 81 02 bb 	brne	8000916e <_vfprintf_r+0x1efe>
80008bfc:	fa c3 f9 e0 	sub	r3,sp,-1568
80008c00:	40 66       	lddsp	r6,sp[0x18]
80008c02:	20 16       	sub	r6,1
80008c04:	58 06       	cp.w	r6,0
80008c06:	e0 89 00 1d 	brgt	80008c40 <_vfprintf_r+0x19d0>
80008c0a:	e0 8f 02 47 	bral	80009098 <_vfprintf_r+0x1e28>
80008c0e:	2f 09       	sub	r9,-16
80008c10:	2f f8       	sub	r8,-1
80008c12:	fb 49 06 90 	st.w	sp[1680],r9
80008c16:	87 02       	st.w	r3[0x0],r2
80008c18:	87 10       	st.w	r3[0x4],r0
80008c1a:	fb 48 06 8c 	st.w	sp[1676],r8
80008c1e:	58 78       	cp.w	r8,7
80008c20:	e0 89 00 04 	brgt	80008c28 <_vfprintf_r+0x19b8>
80008c24:	2f 83       	sub	r3,-8
80008c26:	c0 b8       	rjmp	80008c3c <_vfprintf_r+0x19cc>
80008c28:	fa ca f9 78 	sub	r10,sp,-1672
80008c2c:	02 9b       	mov	r11,r1
80008c2e:	08 9c       	mov	r12,r4
80008c30:	fe b0 f3 12 	rcall	80007254 <__sprint_r>
80008c34:	e0 81 02 9d 	brne	8000916e <_vfprintf_r+0x1efe>
80008c38:	fa c3 f9 e0 	sub	r3,sp,-1568
80008c3c:	21 06       	sub	r6,16
80008c3e:	c0 48       	rjmp	80008c46 <_vfprintf_r+0x19d6>
80008c40:	fe c2 ba a4 	sub	r2,pc,-17756
80008c44:	31 00       	mov	r0,16
80008c46:	fa f9 06 90 	ld.w	r9,sp[1680]
80008c4a:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008c4e:	fe ca ba b2 	sub	r10,pc,-17742
80008c52:	59 06       	cp.w	r6,16
80008c54:	fe 99 ff dd 	brgt	80008c0e <_vfprintf_r+0x199e>
80008c58:	0c 09       	add	r9,r6
80008c5a:	87 0a       	st.w	r3[0x0],r10
80008c5c:	fb 49 06 90 	st.w	sp[1680],r9
80008c60:	2f f8       	sub	r8,-1
80008c62:	87 16       	st.w	r3[0x4],r6
80008c64:	c5 39       	rjmp	80008f0a <_vfprintf_r+0x1c9a>
80008c66:	fa fa 06 ac 	ld.w	r10,sp[1708]
80008c6a:	58 0a       	cp.w	r10,0
80008c6c:	e0 89 00 92 	brgt	80008d90 <_vfprintf_r+0x1b20>
80008c70:	fa f8 06 90 	ld.w	r8,sp[1680]
80008c74:	fe c9 ba ec 	sub	r9,pc,-17684
80008c78:	2f f8       	sub	r8,-1
80008c7a:	87 09       	st.w	r3[0x0],r9
80008c7c:	fb 48 06 90 	st.w	sp[1680],r8
80008c80:	30 19       	mov	r9,1
80008c82:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008c86:	87 19       	st.w	r3[0x4],r9
80008c88:	2f f8       	sub	r8,-1
80008c8a:	fb 48 06 8c 	st.w	sp[1676],r8
80008c8e:	58 78       	cp.w	r8,7
80008c90:	e0 89 00 04 	brgt	80008c98 <_vfprintf_r+0x1a28>
80008c94:	2f 83       	sub	r3,-8
80008c96:	c0 b8       	rjmp	80008cac <_vfprintf_r+0x1a3c>
80008c98:	fa ca f9 78 	sub	r10,sp,-1672
80008c9c:	02 9b       	mov	r11,r1
80008c9e:	08 9c       	mov	r12,r4
80008ca0:	fe b0 f2 da 	rcall	80007254 <__sprint_r>
80008ca4:	e0 81 02 65 	brne	8000916e <_vfprintf_r+0x1efe>
80008ca8:	fa c3 f9 e0 	sub	r3,sp,-1568
80008cac:	fa f8 06 ac 	ld.w	r8,sp[1708]
80008cb0:	58 08       	cp.w	r8,0
80008cb2:	c0 81       	brne	80008cc2 <_vfprintf_r+0x1a52>
80008cb4:	40 6a       	lddsp	r10,sp[0x18]
80008cb6:	58 0a       	cp.w	r10,0
80008cb8:	c0 51       	brne	80008cc2 <_vfprintf_r+0x1a52>
80008cba:	ed b5 00 00 	bld	r5,0x0
80008cbe:	e0 81 01 ed 	brne	80009098 <_vfprintf_r+0x1e28>
80008cc2:	40 c9       	lddsp	r9,sp[0x30]
80008cc4:	fa f8 06 90 	ld.w	r8,sp[1680]
80008cc8:	2f f8       	sub	r8,-1
80008cca:	87 09       	st.w	r3[0x0],r9
80008ccc:	fb 48 06 90 	st.w	sp[1680],r8
80008cd0:	30 19       	mov	r9,1
80008cd2:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008cd6:	87 19       	st.w	r3[0x4],r9
80008cd8:	2f f8       	sub	r8,-1
80008cda:	fb 48 06 8c 	st.w	sp[1676],r8
80008cde:	58 78       	cp.w	r8,7
80008ce0:	e0 89 00 04 	brgt	80008ce8 <_vfprintf_r+0x1a78>
80008ce4:	2f 83       	sub	r3,-8
80008ce6:	c0 b8       	rjmp	80008cfc <_vfprintf_r+0x1a8c>
80008ce8:	fa ca f9 78 	sub	r10,sp,-1672
80008cec:	02 9b       	mov	r11,r1
80008cee:	08 9c       	mov	r12,r4
80008cf0:	fe b0 f2 b2 	rcall	80007254 <__sprint_r>
80008cf4:	e0 81 02 3d 	brne	8000916e <_vfprintf_r+0x1efe>
80008cf8:	fa c3 f9 e0 	sub	r3,sp,-1568
80008cfc:	fa f2 06 ac 	ld.w	r2,sp[1708]
80008d00:	5c 32       	neg	r2
80008d02:	58 02       	cp.w	r2,0
80008d04:	e0 89 00 1d 	brgt	80008d3e <_vfprintf_r+0x1ace>
80008d08:	c3 d8       	rjmp	80008d82 <_vfprintf_r+0x1b12>
80008d0a:	2f 09       	sub	r9,-16
80008d0c:	2f f8       	sub	r8,-1
80008d0e:	31 0e       	mov	lr,16
80008d10:	fb 49 06 90 	st.w	sp[1680],r9
80008d14:	87 00       	st.w	r3[0x0],r0
80008d16:	87 1e       	st.w	r3[0x4],lr
80008d18:	fb 48 06 8c 	st.w	sp[1676],r8
80008d1c:	58 78       	cp.w	r8,7
80008d1e:	e0 89 00 04 	brgt	80008d26 <_vfprintf_r+0x1ab6>
80008d22:	2f 83       	sub	r3,-8
80008d24:	c0 b8       	rjmp	80008d3a <_vfprintf_r+0x1aca>
80008d26:	fa ca f9 78 	sub	r10,sp,-1672
80008d2a:	02 9b       	mov	r11,r1
80008d2c:	08 9c       	mov	r12,r4
80008d2e:	fe b0 f2 93 	rcall	80007254 <__sprint_r>
80008d32:	e0 81 02 1e 	brne	8000916e <_vfprintf_r+0x1efe>
80008d36:	fa c3 f9 e0 	sub	r3,sp,-1568
80008d3a:	21 02       	sub	r2,16
80008d3c:	c0 38       	rjmp	80008d42 <_vfprintf_r+0x1ad2>
80008d3e:	fe c0 bb a2 	sub	r0,pc,-17502
80008d42:	fa f9 06 90 	ld.w	r9,sp[1680]
80008d46:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008d4a:	fe ca bb ae 	sub	r10,pc,-17490
80008d4e:	59 02       	cp.w	r2,16
80008d50:	fe 99 ff dd 	brgt	80008d0a <_vfprintf_r+0x1a9a>
80008d54:	04 09       	add	r9,r2
80008d56:	2f f8       	sub	r8,-1
80008d58:	87 0a       	st.w	r3[0x0],r10
80008d5a:	fb 49 06 90 	st.w	sp[1680],r9
80008d5e:	87 12       	st.w	r3[0x4],r2
80008d60:	fb 48 06 8c 	st.w	sp[1676],r8
80008d64:	58 78       	cp.w	r8,7
80008d66:	e0 89 00 04 	brgt	80008d6e <_vfprintf_r+0x1afe>
80008d6a:	2f 83       	sub	r3,-8
80008d6c:	c0 b8       	rjmp	80008d82 <_vfprintf_r+0x1b12>
80008d6e:	fa ca f9 78 	sub	r10,sp,-1672
80008d72:	02 9b       	mov	r11,r1
80008d74:	08 9c       	mov	r12,r4
80008d76:	fe b0 f2 6f 	rcall	80007254 <__sprint_r>
80008d7a:	e0 81 01 fa 	brne	8000916e <_vfprintf_r+0x1efe>
80008d7e:	fa c3 f9 e0 	sub	r3,sp,-1568
80008d82:	40 6c       	lddsp	r12,sp[0x18]
80008d84:	fa f8 06 90 	ld.w	r8,sp[1680]
80008d88:	87 06       	st.w	r3[0x0],r6
80008d8a:	87 1c       	st.w	r3[0x4],r12
80008d8c:	18 08       	add	r8,r12
80008d8e:	cb 98       	rjmp	80008f00 <_vfprintf_r+0x1c90>
80008d90:	fa f9 06 90 	ld.w	r9,sp[1680]
80008d94:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008d98:	40 6b       	lddsp	r11,sp[0x18]
80008d9a:	16 3a       	cp.w	r10,r11
80008d9c:	c6 f5       	brlt	80008e7a <_vfprintf_r+0x1c0a>
80008d9e:	16 09       	add	r9,r11
80008da0:	2f f8       	sub	r8,-1
80008da2:	87 06       	st.w	r3[0x0],r6
80008da4:	fb 49 06 90 	st.w	sp[1680],r9
80008da8:	87 1b       	st.w	r3[0x4],r11
80008daa:	fb 48 06 8c 	st.w	sp[1676],r8
80008dae:	58 78       	cp.w	r8,7
80008db0:	e0 89 00 04 	brgt	80008db8 <_vfprintf_r+0x1b48>
80008db4:	2f 83       	sub	r3,-8
80008db6:	c0 b8       	rjmp	80008dcc <_vfprintf_r+0x1b5c>
80008db8:	fa ca f9 78 	sub	r10,sp,-1672
80008dbc:	02 9b       	mov	r11,r1
80008dbe:	08 9c       	mov	r12,r4
80008dc0:	fe b0 f2 4a 	rcall	80007254 <__sprint_r>
80008dc4:	e0 81 01 d5 	brne	8000916e <_vfprintf_r+0x1efe>
80008dc8:	fa c3 f9 e0 	sub	r3,sp,-1568
80008dcc:	fa f6 06 ac 	ld.w	r6,sp[1708]
80008dd0:	40 6a       	lddsp	r10,sp[0x18]
80008dd2:	14 16       	sub	r6,r10
80008dd4:	58 06       	cp.w	r6,0
80008dd6:	e0 89 00 1c 	brgt	80008e0e <_vfprintf_r+0x1b9e>
80008dda:	c3 d8       	rjmp	80008e54 <_vfprintf_r+0x1be4>
80008ddc:	2f 09       	sub	r9,-16
80008dde:	2f f8       	sub	r8,-1
80008de0:	fb 49 06 90 	st.w	sp[1680],r9
80008de4:	87 02       	st.w	r3[0x0],r2
80008de6:	87 10       	st.w	r3[0x4],r0
80008de8:	fb 48 06 8c 	st.w	sp[1676],r8
80008dec:	58 78       	cp.w	r8,7
80008dee:	e0 89 00 04 	brgt	80008df6 <_vfprintf_r+0x1b86>
80008df2:	2f 83       	sub	r3,-8
80008df4:	c0 b8       	rjmp	80008e0a <_vfprintf_r+0x1b9a>
80008df6:	fa ca f9 78 	sub	r10,sp,-1672
80008dfa:	02 9b       	mov	r11,r1
80008dfc:	08 9c       	mov	r12,r4
80008dfe:	fe b0 f2 2b 	rcall	80007254 <__sprint_r>
80008e02:	e0 81 01 b6 	brne	8000916e <_vfprintf_r+0x1efe>
80008e06:	fa c3 f9 e0 	sub	r3,sp,-1568
80008e0a:	21 06       	sub	r6,16
80008e0c:	c0 48       	rjmp	80008e14 <_vfprintf_r+0x1ba4>
80008e0e:	fe c2 bc 72 	sub	r2,pc,-17294
80008e12:	31 00       	mov	r0,16
80008e14:	fa f9 06 90 	ld.w	r9,sp[1680]
80008e18:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008e1c:	fe ca bc 80 	sub	r10,pc,-17280
80008e20:	59 06       	cp.w	r6,16
80008e22:	fe 99 ff dd 	brgt	80008ddc <_vfprintf_r+0x1b6c>
80008e26:	0c 09       	add	r9,r6
80008e28:	2f f8       	sub	r8,-1
80008e2a:	87 0a       	st.w	r3[0x0],r10
80008e2c:	fb 49 06 90 	st.w	sp[1680],r9
80008e30:	87 16       	st.w	r3[0x4],r6
80008e32:	fb 48 06 8c 	st.w	sp[1676],r8
80008e36:	58 78       	cp.w	r8,7
80008e38:	e0 89 00 04 	brgt	80008e40 <_vfprintf_r+0x1bd0>
80008e3c:	2f 83       	sub	r3,-8
80008e3e:	c0 b8       	rjmp	80008e54 <_vfprintf_r+0x1be4>
80008e40:	fa ca f9 78 	sub	r10,sp,-1672
80008e44:	02 9b       	mov	r11,r1
80008e46:	08 9c       	mov	r12,r4
80008e48:	fe b0 f2 06 	rcall	80007254 <__sprint_r>
80008e4c:	e0 81 01 91 	brne	8000916e <_vfprintf_r+0x1efe>
80008e50:	fa c3 f9 e0 	sub	r3,sp,-1568
80008e54:	ed b5 00 00 	bld	r5,0x0
80008e58:	e0 81 01 20 	brne	80009098 <_vfprintf_r+0x1e28>
80008e5c:	40 c9       	lddsp	r9,sp[0x30]
80008e5e:	fa f8 06 90 	ld.w	r8,sp[1680]
80008e62:	2f f8       	sub	r8,-1
80008e64:	87 09       	st.w	r3[0x0],r9
80008e66:	fb 48 06 90 	st.w	sp[1680],r8
80008e6a:	30 19       	mov	r9,1
80008e6c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008e70:	87 19       	st.w	r3[0x4],r9
80008e72:	2f f8       	sub	r8,-1
80008e74:	fb 48 06 8c 	st.w	sp[1676],r8
80008e78:	c0 29       	rjmp	8000907c <_vfprintf_r+0x1e0c>
80008e7a:	14 09       	add	r9,r10
80008e7c:	2f f8       	sub	r8,-1
80008e7e:	fb 49 06 90 	st.w	sp[1680],r9
80008e82:	87 06       	st.w	r3[0x0],r6
80008e84:	87 1a       	st.w	r3[0x4],r10
80008e86:	fb 48 06 8c 	st.w	sp[1676],r8
80008e8a:	58 78       	cp.w	r8,7
80008e8c:	e0 89 00 04 	brgt	80008e94 <_vfprintf_r+0x1c24>
80008e90:	2f 83       	sub	r3,-8
80008e92:	c0 b8       	rjmp	80008ea8 <_vfprintf_r+0x1c38>
80008e94:	fa ca f9 78 	sub	r10,sp,-1672
80008e98:	02 9b       	mov	r11,r1
80008e9a:	08 9c       	mov	r12,r4
80008e9c:	fe b0 f1 dc 	rcall	80007254 <__sprint_r>
80008ea0:	e0 81 01 67 	brne	8000916e <_vfprintf_r+0x1efe>
80008ea4:	fa c3 f9 e0 	sub	r3,sp,-1568
80008ea8:	40 c8       	lddsp	r8,sp[0x30]
80008eaa:	87 08       	st.w	r3[0x0],r8
80008eac:	fa f8 06 90 	ld.w	r8,sp[1680]
80008eb0:	2f f8       	sub	r8,-1
80008eb2:	30 19       	mov	r9,1
80008eb4:	fb 48 06 90 	st.w	sp[1680],r8
80008eb8:	87 19       	st.w	r3[0x4],r9
80008eba:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008ebe:	2f f8       	sub	r8,-1
80008ec0:	fb 48 06 8c 	st.w	sp[1676],r8
80008ec4:	fa f2 06 ac 	ld.w	r2,sp[1708]
80008ec8:	58 78       	cp.w	r8,7
80008eca:	e0 89 00 04 	brgt	80008ed2 <_vfprintf_r+0x1c62>
80008ece:	2f 83       	sub	r3,-8
80008ed0:	c0 b8       	rjmp	80008ee6 <_vfprintf_r+0x1c76>
80008ed2:	fa ca f9 78 	sub	r10,sp,-1672
80008ed6:	02 9b       	mov	r11,r1
80008ed8:	08 9c       	mov	r12,r4
80008eda:	fe b0 f1 bd 	rcall	80007254 <__sprint_r>
80008ede:	e0 81 01 48 	brne	8000916e <_vfprintf_r+0x1efe>
80008ee2:	fa c3 f9 e0 	sub	r3,sp,-1568
80008ee6:	04 06       	add	r6,r2
80008ee8:	fa f8 06 ac 	ld.w	r8,sp[1708]
80008eec:	87 06       	st.w	r3[0x0],r6
80008eee:	fa f9 06 90 	ld.w	r9,sp[1680]
80008ef2:	40 66       	lddsp	r6,sp[0x18]
80008ef4:	40 6e       	lddsp	lr,sp[0x18]
80008ef6:	10 16       	sub	r6,r8
80008ef8:	f2 08 01 08 	sub	r8,r9,r8
80008efc:	87 16       	st.w	r3[0x4],r6
80008efe:	1c 08       	add	r8,lr
80008f00:	fb 48 06 90 	st.w	sp[1680],r8
80008f04:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008f08:	2f f8       	sub	r8,-1
80008f0a:	fb 48 06 8c 	st.w	sp[1676],r8
80008f0e:	cb 78       	rjmp	8000907c <_vfprintf_r+0x1e0c>
80008f10:	40 6c       	lddsp	r12,sp[0x18]
80008f12:	58 1c       	cp.w	r12,1
80008f14:	e0 89 00 06 	brgt	80008f20 <_vfprintf_r+0x1cb0>
80008f18:	ed b5 00 00 	bld	r5,0x0
80008f1c:	e0 81 00 85 	brne	80009026 <_vfprintf_r+0x1db6>
80008f20:	fa f8 06 90 	ld.w	r8,sp[1680]
80008f24:	2f f8       	sub	r8,-1
80008f26:	30 19       	mov	r9,1
80008f28:	fb 48 06 90 	st.w	sp[1680],r8
80008f2c:	87 06       	st.w	r3[0x0],r6
80008f2e:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008f32:	87 19       	st.w	r3[0x4],r9
80008f34:	2f f8       	sub	r8,-1
80008f36:	fb 48 06 8c 	st.w	sp[1676],r8
80008f3a:	58 78       	cp.w	r8,7
80008f3c:	e0 89 00 04 	brgt	80008f44 <_vfprintf_r+0x1cd4>
80008f40:	2f 83       	sub	r3,-8
80008f42:	c0 b8       	rjmp	80008f58 <_vfprintf_r+0x1ce8>
80008f44:	fa ca f9 78 	sub	r10,sp,-1672
80008f48:	02 9b       	mov	r11,r1
80008f4a:	08 9c       	mov	r12,r4
80008f4c:	fe b0 f1 84 	rcall	80007254 <__sprint_r>
80008f50:	e0 81 01 0f 	brne	8000916e <_vfprintf_r+0x1efe>
80008f54:	fa c3 f9 e0 	sub	r3,sp,-1568
80008f58:	fa f8 06 90 	ld.w	r8,sp[1680]
80008f5c:	2f f8       	sub	r8,-1
80008f5e:	40 cb       	lddsp	r11,sp[0x30]
80008f60:	fb 48 06 90 	st.w	sp[1680],r8
80008f64:	30 19       	mov	r9,1
80008f66:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008f6a:	87 0b       	st.w	r3[0x0],r11
80008f6c:	2f f8       	sub	r8,-1
80008f6e:	87 19       	st.w	r3[0x4],r9
80008f70:	fb 48 06 8c 	st.w	sp[1676],r8
80008f74:	58 78       	cp.w	r8,7
80008f76:	e0 89 00 05 	brgt	80008f80 <_vfprintf_r+0x1d10>
80008f7a:	2f 83       	sub	r3,-8
80008f7c:	c0 c8       	rjmp	80008f94 <_vfprintf_r+0x1d24>
80008f7e:	d7 03       	nop
80008f80:	fa ca f9 78 	sub	r10,sp,-1672
80008f84:	02 9b       	mov	r11,r1
80008f86:	08 9c       	mov	r12,r4
80008f88:	fe b0 f1 66 	rcall	80007254 <__sprint_r>
80008f8c:	e0 81 00 f1 	brne	8000916e <_vfprintf_r+0x1efe>
80008f90:	fa c3 f9 e0 	sub	r3,sp,-1568
80008f94:	30 08       	mov	r8,0
80008f96:	30 09       	mov	r9,0
80008f98:	40 5b       	lddsp	r11,sp[0x14]
80008f9a:	40 7a       	lddsp	r10,sp[0x1c]
80008f9c:	e0 a0 13 25 	rcall	8000b5e6 <__avr32_f64_cmp_eq>
80008fa0:	40 68       	lddsp	r8,sp[0x18]
80008fa2:	20 18       	sub	r8,1
80008fa4:	58 0c       	cp.w	r12,0
80008fa6:	c0 d1       	brne	80008fc0 <_vfprintf_r+0x1d50>
80008fa8:	2f f6       	sub	r6,-1
80008faa:	87 18       	st.w	r3[0x4],r8
80008fac:	87 06       	st.w	r3[0x0],r6
80008fae:	fa f6 06 90 	ld.w	r6,sp[1680]
80008fb2:	10 06       	add	r6,r8
80008fb4:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008fb8:	fb 46 06 90 	st.w	sp[1680],r6
80008fbc:	2f f8       	sub	r8,-1
80008fbe:	c3 18       	rjmp	80009020 <_vfprintf_r+0x1db0>
80008fc0:	10 96       	mov	r6,r8
80008fc2:	58 08       	cp.w	r8,0
80008fc4:	e0 89 00 1c 	brgt	80008ffc <_vfprintf_r+0x1d8c>
80008fc8:	c4 b8       	rjmp	8000905e <_vfprintf_r+0x1dee>
80008fca:	2f 09       	sub	r9,-16
80008fcc:	2f f8       	sub	r8,-1
80008fce:	fb 49 06 90 	st.w	sp[1680],r9
80008fd2:	87 02       	st.w	r3[0x0],r2
80008fd4:	87 10       	st.w	r3[0x4],r0
80008fd6:	fb 48 06 8c 	st.w	sp[1676],r8
80008fda:	58 78       	cp.w	r8,7
80008fdc:	e0 89 00 04 	brgt	80008fe4 <_vfprintf_r+0x1d74>
80008fe0:	2f 83       	sub	r3,-8
80008fe2:	c0 b8       	rjmp	80008ff8 <_vfprintf_r+0x1d88>
80008fe4:	fa ca f9 78 	sub	r10,sp,-1672
80008fe8:	02 9b       	mov	r11,r1
80008fea:	08 9c       	mov	r12,r4
80008fec:	fe b0 f1 34 	rcall	80007254 <__sprint_r>
80008ff0:	e0 81 00 bf 	brne	8000916e <_vfprintf_r+0x1efe>
80008ff4:	fa c3 f9 e0 	sub	r3,sp,-1568
80008ff8:	21 06       	sub	r6,16
80008ffa:	c0 48       	rjmp	80009002 <_vfprintf_r+0x1d92>
80008ffc:	fe c2 be 60 	sub	r2,pc,-16800
80009000:	31 00       	mov	r0,16
80009002:	fa f9 06 90 	ld.w	r9,sp[1680]
80009006:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000900a:	fe ca be 6e 	sub	r10,pc,-16786
8000900e:	59 06       	cp.w	r6,16
80009010:	fe 99 ff dd 	brgt	80008fca <_vfprintf_r+0x1d5a>
80009014:	0c 09       	add	r9,r6
80009016:	87 0a       	st.w	r3[0x0],r10
80009018:	fb 49 06 90 	st.w	sp[1680],r9
8000901c:	2f f8       	sub	r8,-1
8000901e:	87 16       	st.w	r3[0x4],r6
80009020:	fb 48 06 8c 	st.w	sp[1676],r8
80009024:	c0 e8       	rjmp	80009040 <_vfprintf_r+0x1dd0>
80009026:	fa f8 06 90 	ld.w	r8,sp[1680]
8000902a:	2f f8       	sub	r8,-1
8000902c:	30 19       	mov	r9,1
8000902e:	fb 48 06 90 	st.w	sp[1680],r8
80009032:	87 06       	st.w	r3[0x0],r6
80009034:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009038:	87 19       	st.w	r3[0x4],r9
8000903a:	2f f8       	sub	r8,-1
8000903c:	fb 48 06 8c 	st.w	sp[1676],r8
80009040:	58 78       	cp.w	r8,7
80009042:	e0 89 00 04 	brgt	8000904a <_vfprintf_r+0x1dda>
80009046:	2f 83       	sub	r3,-8
80009048:	c0 b8       	rjmp	8000905e <_vfprintf_r+0x1dee>
8000904a:	fa ca f9 78 	sub	r10,sp,-1672
8000904e:	02 9b       	mov	r11,r1
80009050:	08 9c       	mov	r12,r4
80009052:	fe b0 f1 01 	rcall	80007254 <__sprint_r>
80009056:	e0 81 00 8c 	brne	8000916e <_vfprintf_r+0x1efe>
8000905a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000905e:	40 ea       	lddsp	r10,sp[0x38]
80009060:	fa f8 06 90 	ld.w	r8,sp[1680]
80009064:	14 08       	add	r8,r10
80009066:	fa c9 f9 64 	sub	r9,sp,-1692
8000906a:	fb 48 06 90 	st.w	sp[1680],r8
8000906e:	87 1a       	st.w	r3[0x4],r10
80009070:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009074:	87 09       	st.w	r3[0x0],r9
80009076:	2f f8       	sub	r8,-1
80009078:	fb 48 06 8c 	st.w	sp[1676],r8
8000907c:	58 78       	cp.w	r8,7
8000907e:	e0 89 00 04 	brgt	80009086 <_vfprintf_r+0x1e16>
80009082:	2f 83       	sub	r3,-8
80009084:	c0 a8       	rjmp	80009098 <_vfprintf_r+0x1e28>
80009086:	fa ca f9 78 	sub	r10,sp,-1672
8000908a:	02 9b       	mov	r11,r1
8000908c:	08 9c       	mov	r12,r4
8000908e:	fe b0 f0 e3 	rcall	80007254 <__sprint_r>
80009092:	c6 e1       	brne	8000916e <_vfprintf_r+0x1efe>
80009094:	fa c3 f9 e0 	sub	r3,sp,-1568
80009098:	e2 15 00 04 	andl	r5,0x4,COH
8000909c:	c3 f0       	breq	8000911a <_vfprintf_r+0x1eaa>
8000909e:	40 86       	lddsp	r6,sp[0x20]
800090a0:	40 39       	lddsp	r9,sp[0xc]
800090a2:	12 16       	sub	r6,r9
800090a4:	58 06       	cp.w	r6,0
800090a6:	e0 89 00 1a 	brgt	800090da <_vfprintf_r+0x1e6a>
800090aa:	c3 88       	rjmp	8000911a <_vfprintf_r+0x1eaa>
800090ac:	2f 09       	sub	r9,-16
800090ae:	2f f8       	sub	r8,-1
800090b0:	fb 49 06 90 	st.w	sp[1680],r9
800090b4:	87 05       	st.w	r3[0x0],r5
800090b6:	87 12       	st.w	r3[0x4],r2
800090b8:	fb 48 06 8c 	st.w	sp[1676],r8
800090bc:	58 78       	cp.w	r8,7
800090be:	e0 89 00 04 	brgt	800090c6 <_vfprintf_r+0x1e56>
800090c2:	2f 83       	sub	r3,-8
800090c4:	c0 98       	rjmp	800090d6 <_vfprintf_r+0x1e66>
800090c6:	00 9a       	mov	r10,r0
800090c8:	02 9b       	mov	r11,r1
800090ca:	08 9c       	mov	r12,r4
800090cc:	fe b0 f0 c4 	rcall	80007254 <__sprint_r>
800090d0:	c4 f1       	brne	8000916e <_vfprintf_r+0x1efe>
800090d2:	fa c3 f9 e0 	sub	r3,sp,-1568
800090d6:	21 06       	sub	r6,16
800090d8:	c0 68       	rjmp	800090e4 <_vfprintf_r+0x1e74>
800090da:	fe c5 bf 4e 	sub	r5,pc,-16562
800090de:	31 02       	mov	r2,16
800090e0:	fa c0 f9 78 	sub	r0,sp,-1672
800090e4:	fa f9 06 90 	ld.w	r9,sp[1680]
800090e8:	fa f8 06 8c 	ld.w	r8,sp[1676]
800090ec:	fe ca bf 60 	sub	r10,pc,-16544
800090f0:	59 06       	cp.w	r6,16
800090f2:	fe 99 ff dd 	brgt	800090ac <_vfprintf_r+0x1e3c>
800090f6:	0c 09       	add	r9,r6
800090f8:	2f f8       	sub	r8,-1
800090fa:	87 0a       	st.w	r3[0x0],r10
800090fc:	87 16       	st.w	r3[0x4],r6
800090fe:	fb 49 06 90 	st.w	sp[1680],r9
80009102:	fb 48 06 8c 	st.w	sp[1676],r8
80009106:	58 78       	cp.w	r8,7
80009108:	e0 8a 00 09 	brle	8000911a <_vfprintf_r+0x1eaa>
8000910c:	fa ca f9 78 	sub	r10,sp,-1672
80009110:	02 9b       	mov	r11,r1
80009112:	08 9c       	mov	r12,r4
80009114:	fe b0 f0 a0 	rcall	80007254 <__sprint_r>
80009118:	c2 b1       	brne	8000916e <_vfprintf_r+0x1efe>
8000911a:	40 bc       	lddsp	r12,sp[0x2c]
8000911c:	40 36       	lddsp	r6,sp[0xc]
8000911e:	40 8e       	lddsp	lr,sp[0x20]
80009120:	ec 0e 0c 48 	max	r8,r6,lr
80009124:	10 0c       	add	r12,r8
80009126:	50 bc       	stdsp	sp[0x2c],r12
80009128:	fa f8 06 90 	ld.w	r8,sp[1680]
8000912c:	58 08       	cp.w	r8,0
8000912e:	c0 80       	breq	8000913e <_vfprintf_r+0x1ece>
80009130:	fa ca f9 78 	sub	r10,sp,-1672
80009134:	02 9b       	mov	r11,r1
80009136:	08 9c       	mov	r12,r4
80009138:	fe b0 f0 8e 	rcall	80007254 <__sprint_r>
8000913c:	c1 91       	brne	8000916e <_vfprintf_r+0x1efe>
8000913e:	30 0b       	mov	r11,0
80009140:	fa c3 f9 e0 	sub	r3,sp,-1568
80009144:	fb 4b 06 8c 	st.w	sp[1676],r11
80009148:	fe 9f f1 22 	bral	8000738c <_vfprintf_r+0x11c>
8000914c:	08 95       	mov	r5,r4
8000914e:	fa f8 06 90 	ld.w	r8,sp[1680]
80009152:	58 08       	cp.w	r8,0
80009154:	c0 80       	breq	80009164 <_vfprintf_r+0x1ef4>
80009156:	08 9c       	mov	r12,r4
80009158:	fa ca f9 78 	sub	r10,sp,-1672
8000915c:	02 9b       	mov	r11,r1
8000915e:	fe b0 f0 7b 	rcall	80007254 <__sprint_r>
80009162:	c0 61       	brne	8000916e <_vfprintf_r+0x1efe>
80009164:	30 08       	mov	r8,0
80009166:	fb 48 06 8c 	st.w	sp[1676],r8
8000916a:	c0 28       	rjmp	8000916e <_vfprintf_r+0x1efe>
8000916c:	40 41       	lddsp	r1,sp[0x10]
8000916e:	82 68       	ld.sh	r8,r1[0xc]
80009170:	ed b8 00 06 	bld	r8,0x6
80009174:	c0 31       	brne	8000917a <_vfprintf_r+0x1f0a>
80009176:	3f fa       	mov	r10,-1
80009178:	50 ba       	stdsp	sp[0x2c],r10
8000917a:	40 bc       	lddsp	r12,sp[0x2c]
8000917c:	fe 3d f9 44 	sub	sp,-1724
80009180:	d8 32       	popm	r0-r7,pc
80009182:	d7 03       	nop

80009184 <__swsetup_r>:
80009184:	d4 21       	pushm	r4-r7,lr
80009186:	e0 68 0a 20 	mov	r8,2592
8000918a:	18 96       	mov	r6,r12
8000918c:	16 97       	mov	r7,r11
8000918e:	70 0c       	ld.w	r12,r8[0x0]
80009190:	58 0c       	cp.w	r12,0
80009192:	c0 60       	breq	8000919e <__swsetup_r+0x1a>
80009194:	78 68       	ld.w	r8,r12[0x18]
80009196:	58 08       	cp.w	r8,0
80009198:	c0 31       	brne	8000919e <__swsetup_r+0x1a>
8000919a:	e0 a0 07 bf 	rcall	8000a118 <__sinit>
8000919e:	fe c8 be e2 	sub	r8,pc,-16670
800091a2:	10 37       	cp.w	r7,r8
800091a4:	c0 61       	brne	800091b0 <__swsetup_r+0x2c>
800091a6:	e0 68 0a 20 	mov	r8,2592
800091aa:	70 08       	ld.w	r8,r8[0x0]
800091ac:	70 07       	ld.w	r7,r8[0x0]
800091ae:	c1 28       	rjmp	800091d2 <__swsetup_r+0x4e>
800091b0:	fe c8 be d4 	sub	r8,pc,-16684
800091b4:	10 37       	cp.w	r7,r8
800091b6:	c0 61       	brne	800091c2 <__swsetup_r+0x3e>
800091b8:	e0 68 0a 20 	mov	r8,2592
800091bc:	70 08       	ld.w	r8,r8[0x0]
800091be:	70 17       	ld.w	r7,r8[0x4]
800091c0:	c0 98       	rjmp	800091d2 <__swsetup_r+0x4e>
800091c2:	fe c8 be c6 	sub	r8,pc,-16698
800091c6:	10 37       	cp.w	r7,r8
800091c8:	c0 51       	brne	800091d2 <__swsetup_r+0x4e>
800091ca:	e0 68 0a 20 	mov	r8,2592
800091ce:	70 08       	ld.w	r8,r8[0x0]
800091d0:	70 27       	ld.w	r7,r8[0x8]
800091d2:	8e 68       	ld.sh	r8,r7[0xc]
800091d4:	ed b8 00 03 	bld	r8,0x3
800091d8:	c1 e0       	breq	80009214 <__swsetup_r+0x90>
800091da:	ed b8 00 04 	bld	r8,0x4
800091de:	c3 e1       	brne	8000925a <__swsetup_r+0xd6>
800091e0:	ed b8 00 02 	bld	r8,0x2
800091e4:	c1 51       	brne	8000920e <__swsetup_r+0x8a>
800091e6:	6e db       	ld.w	r11,r7[0x34]
800091e8:	58 0b       	cp.w	r11,0
800091ea:	c0 a0       	breq	800091fe <__swsetup_r+0x7a>
800091ec:	ee c8 ff bc 	sub	r8,r7,-68
800091f0:	10 3b       	cp.w	r11,r8
800091f2:	c0 40       	breq	800091fa <__swsetup_r+0x76>
800091f4:	0c 9c       	mov	r12,r6
800091f6:	e0 a0 08 2b 	rcall	8000a24c <_free_r>
800091fa:	30 08       	mov	r8,0
800091fc:	8f d8       	st.w	r7[0x34],r8
800091fe:	8e 68       	ld.sh	r8,r7[0xc]
80009200:	e0 18 ff db 	andl	r8,0xffdb
80009204:	ae 68       	st.h	r7[0xc],r8
80009206:	30 08       	mov	r8,0
80009208:	8f 18       	st.w	r7[0x4],r8
8000920a:	6e 48       	ld.w	r8,r7[0x10]
8000920c:	8f 08       	st.w	r7[0x0],r8
8000920e:	8e 68       	ld.sh	r8,r7[0xc]
80009210:	a3 b8       	sbr	r8,0x3
80009212:	ae 68       	st.h	r7[0xc],r8
80009214:	6e 48       	ld.w	r8,r7[0x10]
80009216:	58 08       	cp.w	r8,0
80009218:	c0 b1       	brne	8000922e <__swsetup_r+0xaa>
8000921a:	8e 68       	ld.sh	r8,r7[0xc]
8000921c:	e2 18 02 80 	andl	r8,0x280,COH
80009220:	e0 48 02 00 	cp.w	r8,512
80009224:	c0 50       	breq	8000922e <__swsetup_r+0xaa>
80009226:	0c 9c       	mov	r12,r6
80009228:	0e 9b       	mov	r11,r7
8000922a:	e0 a0 0a 4b 	rcall	8000a6c0 <__smakebuf_r>
8000922e:	8e 69       	ld.sh	r9,r7[0xc]
80009230:	f1 d9 c0 01 	bfextu	r8,r9,0x0,0x1
80009234:	c0 70       	breq	80009242 <__swsetup_r+0xbe>
80009236:	30 08       	mov	r8,0
80009238:	8f 28       	st.w	r7[0x8],r8
8000923a:	6e 58       	ld.w	r8,r7[0x14]
8000923c:	5c 38       	neg	r8
8000923e:	8f 68       	st.w	r7[0x18],r8
80009240:	c0 68       	rjmp	8000924c <__swsetup_r+0xc8>
80009242:	ed b9 00 01 	bld	r9,0x1
80009246:	ef f8 10 05 	ld.wne	r8,r7[0x14]
8000924a:	8f 28       	st.w	r7[0x8],r8
8000924c:	6e 48       	ld.w	r8,r7[0x10]
8000924e:	58 08       	cp.w	r8,0
80009250:	c0 61       	brne	8000925c <__swsetup_r+0xd8>
80009252:	8e 68       	ld.sh	r8,r7[0xc]
80009254:	ed b8 00 07 	bld	r8,0x7
80009258:	c0 21       	brne	8000925c <__swsetup_r+0xd8>
8000925a:	dc 2a       	popm	r4-r7,pc,r12=-1
8000925c:	d8 2a       	popm	r4-r7,pc,r12=0
8000925e:	d7 03       	nop

80009260 <quorem>:
80009260:	d4 31       	pushm	r0-r7,lr
80009262:	20 2d       	sub	sp,8
80009264:	18 97       	mov	r7,r12
80009266:	78 48       	ld.w	r8,r12[0x10]
80009268:	76 46       	ld.w	r6,r11[0x10]
8000926a:	0c 38       	cp.w	r8,r6
8000926c:	c0 34       	brge	80009272 <quorem+0x12>
8000926e:	30 0c       	mov	r12,0
80009270:	c8 58       	rjmp	8000937a <quorem+0x11a>
80009272:	ec c2 ff fc 	sub	r2,r6,-4
80009276:	f6 c3 ff ec 	sub	r3,r11,-20
8000927a:	f6 02 03 29 	ld.w	r9,r11[r2<<0x2]
8000927e:	f8 02 03 2c 	ld.w	r12,r12[r2<<0x2]
80009282:	2f f9       	sub	r9,-1
80009284:	20 16       	sub	r6,1
80009286:	f8 09 0d 08 	divu	r8,r12,r9
8000928a:	f6 02 00 22 	add	r2,r11,r2<<0x2
8000928e:	ee c4 ff ec 	sub	r4,r7,-20
80009292:	10 95       	mov	r5,r8
80009294:	58 08       	cp.w	r8,0
80009296:	c4 10       	breq	80009318 <quorem+0xb8>
80009298:	30 09       	mov	r9,0
8000929a:	06 9a       	mov	r10,r3
8000929c:	08 98       	mov	r8,r4
8000929e:	12 91       	mov	r1,r9
800092a0:	50 0b       	stdsp	sp[0x0],r11
800092a2:	70 0e       	ld.w	lr,r8[0x0]
800092a4:	b1 8e       	lsr	lr,0x10
800092a6:	50 1e       	stdsp	sp[0x4],lr
800092a8:	15 0e       	ld.w	lr,r10++
800092aa:	fc 00 16 10 	lsr	r0,lr,0x10
800092ae:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
800092b2:	ea 0e 03 41 	mac	r1,r5,lr
800092b6:	fd d1 c0 10 	bfextu	lr,r1,0x0,0x10
800092ba:	b1 81       	lsr	r1,0x10
800092bc:	40 1b       	lddsp	r11,sp[0x4]
800092be:	ea 00 02 40 	mul	r0,r5,r0
800092c2:	e2 00 00 00 	add	r0,r1,r0
800092c6:	e3 d0 c0 10 	bfextu	r1,r0,0x0,0x10
800092ca:	02 1b       	sub	r11,r1
800092cc:	50 1b       	stdsp	sp[0x4],r11
800092ce:	70 0b       	ld.w	r11,r8[0x0]
800092d0:	e3 db c0 10 	bfextu	r1,r11,0x0,0x10
800092d4:	02 09       	add	r9,r1
800092d6:	f2 0e 01 0e 	sub	lr,r9,lr
800092da:	b0 1e       	st.h	r8[0x2],lr
800092dc:	fc 09 14 10 	asr	r9,lr,0x10
800092e0:	40 1e       	lddsp	lr,sp[0x4]
800092e2:	fc 09 00 09 	add	r9,lr,r9
800092e6:	b0 09       	st.h	r8[0x0],r9
800092e8:	e0 01 16 10 	lsr	r1,r0,0x10
800092ec:	2f c8       	sub	r8,-4
800092ee:	b1 49       	asr	r9,0x10
800092f0:	04 3a       	cp.w	r10,r2
800092f2:	fe 98 ff d8 	brls	800092a2 <quorem+0x42>
800092f6:	40 0b       	lddsp	r11,sp[0x0]
800092f8:	58 0c       	cp.w	r12,0
800092fa:	c0 f1       	brne	80009318 <quorem+0xb8>
800092fc:	ec c8 ff fb 	sub	r8,r6,-5
80009300:	ee 08 00 28 	add	r8,r7,r8<<0x2
80009304:	c0 28       	rjmp	80009308 <quorem+0xa8>
80009306:	20 16       	sub	r6,1
80009308:	20 48       	sub	r8,4
8000930a:	08 38       	cp.w	r8,r4
8000930c:	e0 88 00 05 	brls	80009316 <quorem+0xb6>
80009310:	70 09       	ld.w	r9,r8[0x0]
80009312:	58 09       	cp.w	r9,0
80009314:	cf 90       	breq	80009306 <quorem+0xa6>
80009316:	8f 46       	st.w	r7[0x10],r6
80009318:	0e 9c       	mov	r12,r7
8000931a:	e0 a0 0a d2 	rcall	8000a8be <__mcmp>
8000931e:	c2 d5       	brlt	80009378 <quorem+0x118>
80009320:	2f f5       	sub	r5,-1
80009322:	08 98       	mov	r8,r4
80009324:	30 09       	mov	r9,0
80009326:	07 0b       	ld.w	r11,r3++
80009328:	f6 0a 16 10 	lsr	r10,r11,0x10
8000932c:	70 0c       	ld.w	r12,r8[0x0]
8000932e:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
80009332:	f8 0e 16 10 	lsr	lr,r12,0x10
80009336:	14 1e       	sub	lr,r10
80009338:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000933c:	16 1a       	sub	r10,r11
8000933e:	12 0a       	add	r10,r9
80009340:	b0 1a       	st.h	r8[0x2],r10
80009342:	b1 4a       	asr	r10,0x10
80009344:	fc 0a 00 09 	add	r9,lr,r10
80009348:	b0 09       	st.h	r8[0x0],r9
8000934a:	2f c8       	sub	r8,-4
8000934c:	b1 49       	asr	r9,0x10
8000934e:	04 33       	cp.w	r3,r2
80009350:	fe 98 ff eb 	brls	80009326 <quorem+0xc6>
80009354:	ec c8 ff fb 	sub	r8,r6,-5
80009358:	ee 08 03 29 	ld.w	r9,r7[r8<<0x2]
8000935c:	58 09       	cp.w	r9,0
8000935e:	c0 d1       	brne	80009378 <quorem+0x118>
80009360:	ee 08 00 28 	add	r8,r7,r8<<0x2
80009364:	c0 28       	rjmp	80009368 <quorem+0x108>
80009366:	20 16       	sub	r6,1
80009368:	20 48       	sub	r8,4
8000936a:	08 38       	cp.w	r8,r4
8000936c:	e0 88 00 05 	brls	80009376 <quorem+0x116>
80009370:	70 09       	ld.w	r9,r8[0x0]
80009372:	58 09       	cp.w	r9,0
80009374:	cf 90       	breq	80009366 <quorem+0x106>
80009376:	8f 46       	st.w	r7[0x10],r6
80009378:	0a 9c       	mov	r12,r5
8000937a:	2f ed       	sub	sp,-8
8000937c:	d8 32       	popm	r0-r7,pc
8000937e:	d7 03       	nop

80009380 <_dtoa_r>:
80009380:	d4 31       	pushm	r0-r7,lr
80009382:	21 ad       	sub	sp,104
80009384:	fa c4 ff 74 	sub	r4,sp,-140
80009388:	18 97       	mov	r7,r12
8000938a:	16 95       	mov	r5,r11
8000938c:	68 2c       	ld.w	r12,r4[0x8]
8000938e:	50 c9       	stdsp	sp[0x30],r9
80009390:	68 16       	ld.w	r6,r4[0x4]
80009392:	68 09       	ld.w	r9,r4[0x0]
80009394:	50 e8       	stdsp	sp[0x38],r8
80009396:	14 94       	mov	r4,r10
80009398:	51 2c       	stdsp	sp[0x48],r12
8000939a:	fa e5 00 08 	st.d	sp[8],r4
8000939e:	51 59       	stdsp	sp[0x54],r9
800093a0:	6e 95       	ld.w	r5,r7[0x24]
800093a2:	58 05       	cp.w	r5,0
800093a4:	c0 91       	brne	800093b6 <_dtoa_r+0x36>
800093a6:	31 0c       	mov	r12,16
800093a8:	fe b0 e8 e2 	rcall	8000656c <malloc>
800093ac:	99 35       	st.w	r12[0xc],r5
800093ae:	8f 9c       	st.w	r7[0x24],r12
800093b0:	99 15       	st.w	r12[0x4],r5
800093b2:	99 25       	st.w	r12[0x8],r5
800093b4:	99 05       	st.w	r12[0x0],r5
800093b6:	6e 99       	ld.w	r9,r7[0x24]
800093b8:	72 08       	ld.w	r8,r9[0x0]
800093ba:	58 08       	cp.w	r8,0
800093bc:	c0 f0       	breq	800093da <_dtoa_r+0x5a>
800093be:	72 1a       	ld.w	r10,r9[0x4]
800093c0:	91 1a       	st.w	r8[0x4],r10
800093c2:	30 1a       	mov	r10,1
800093c4:	72 19       	ld.w	r9,r9[0x4]
800093c6:	f4 09 09 49 	lsl	r9,r10,r9
800093ca:	10 9b       	mov	r11,r8
800093cc:	91 29       	st.w	r8[0x8],r9
800093ce:	0e 9c       	mov	r12,r7
800093d0:	e0 a0 0a 90 	rcall	8000a8f0 <_Bfree>
800093d4:	6e 98       	ld.w	r8,r7[0x24]
800093d6:	30 09       	mov	r9,0
800093d8:	91 09       	st.w	r8[0x0],r9
800093da:	40 28       	lddsp	r8,sp[0x8]
800093dc:	10 94       	mov	r4,r8
800093de:	58 08       	cp.w	r8,0
800093e0:	c0 64       	brge	800093ec <_dtoa_r+0x6c>
800093e2:	f1 d8 c0 1f 	bfextu	r8,r8,0x0,0x1f
800093e6:	50 28       	stdsp	sp[0x8],r8
800093e8:	30 18       	mov	r8,1
800093ea:	c0 28       	rjmp	800093ee <_dtoa_r+0x6e>
800093ec:	30 08       	mov	r8,0
800093ee:	8d 08       	st.w	r6[0x0],r8
800093f0:	fc 1c 7f f0 	movh	r12,0x7ff0
800093f4:	40 26       	lddsp	r6,sp[0x8]
800093f6:	0c 98       	mov	r8,r6
800093f8:	e6 18 7f f0 	andh	r8,0x7ff0,COH
800093fc:	18 38       	cp.w	r8,r12
800093fe:	c2 01       	brne	8000943e <_dtoa_r+0xbe>
80009400:	e0 68 27 0f 	mov	r8,9999
80009404:	41 5b       	lddsp	r11,sp[0x54]
80009406:	97 08       	st.w	r11[0x0],r8
80009408:	40 3a       	lddsp	r10,sp[0xc]
8000940a:	58 0a       	cp.w	r10,0
8000940c:	c0 71       	brne	8000941a <_dtoa_r+0x9a>
8000940e:	ed d6 c0 14 	bfextu	r6,r6,0x0,0x14
80009412:	c0 41       	brne	8000941a <_dtoa_r+0x9a>
80009414:	fe cc c1 68 	sub	r12,pc,-16024
80009418:	c0 38       	rjmp	8000941e <_dtoa_r+0x9e>
8000941a:	fe cc c1 62 	sub	r12,pc,-16030
8000941e:	41 29       	lddsp	r9,sp[0x48]
80009420:	58 09       	cp.w	r9,0
80009422:	e0 80 05 9a 	breq	80009f56 <_dtoa_r+0xbd6>
80009426:	f8 c8 ff fd 	sub	r8,r12,-3
8000942a:	f8 c9 ff f8 	sub	r9,r12,-8
8000942e:	11 8b       	ld.ub	r11,r8[0x0]
80009430:	30 0a       	mov	r10,0
80009432:	41 25       	lddsp	r5,sp[0x48]
80009434:	f4 0b 18 00 	cp.b	r11,r10
80009438:	f2 08 17 10 	movne	r8,r9
8000943c:	c1 68       	rjmp	80009468 <_dtoa_r+0xe8>
8000943e:	fa ea 00 08 	ld.d	r10,sp[8]
80009442:	30 08       	mov	r8,0
80009444:	fa eb 00 3c 	st.d	sp[60],r10
80009448:	30 09       	mov	r9,0
8000944a:	e0 a0 10 ce 	rcall	8000b5e6 <__avr32_f64_cmp_eq>
8000944e:	c1 00       	breq	8000946e <_dtoa_r+0xee>
80009450:	30 18       	mov	r8,1
80009452:	41 5a       	lddsp	r10,sp[0x54]
80009454:	95 08       	st.w	r10[0x0],r8
80009456:	fe cc c2 ce 	sub	r12,pc,-15666
8000945a:	41 29       	lddsp	r9,sp[0x48]
8000945c:	f8 08 00 08 	add	r8,r12,r8
80009460:	58 09       	cp.w	r9,0
80009462:	e0 80 05 7a 	breq	80009f56 <_dtoa_r+0xbd6>
80009466:	12 95       	mov	r5,r9
80009468:	8b 08       	st.w	r5[0x0],r8
8000946a:	e0 8f 05 76 	bral	80009f56 <_dtoa_r+0xbd6>
8000946e:	fa c8 ff 9c 	sub	r8,sp,-100
80009472:	fa c9 ff a0 	sub	r9,sp,-96
80009476:	fa ea 00 3c 	ld.d	r10,sp[60]
8000947a:	0e 9c       	mov	r12,r7
8000947c:	eb d6 c2 8b 	bfextu	r5,r6,0x14,0xb
80009480:	e0 a0 0a 8a 	rcall	8000a994 <__d2b>
80009484:	18 93       	mov	r3,r12
80009486:	58 05       	cp.w	r5,0
80009488:	c0 d0       	breq	800094a2 <_dtoa_r+0x122>
8000948a:	fa ea 00 3c 	ld.d	r10,sp[60]
8000948e:	30 04       	mov	r4,0
80009490:	f1 db c0 14 	bfextu	r8,r11,0x0,0x14
80009494:	ea c5 03 ff 	sub	r5,r5,1023
80009498:	10 9b       	mov	r11,r8
8000949a:	51 74       	stdsp	sp[0x5c],r4
8000949c:	ea 1b 3f f0 	orh	r11,0x3ff0
800094a0:	c2 58       	rjmp	800094ea <_dtoa_r+0x16a>
800094a2:	41 88       	lddsp	r8,sp[0x60]
800094a4:	41 9c       	lddsp	r12,sp[0x64]
800094a6:	10 0c       	add	r12,r8
800094a8:	f8 c5 fb ce 	sub	r5,r12,-1074
800094ac:	e0 45 00 20 	cp.w	r5,32
800094b0:	e0 8a 00 0e 	brle	800094cc <_dtoa_r+0x14c>
800094b4:	f8 cc fb ee 	sub	r12,r12,-1042
800094b8:	40 3b       	lddsp	r11,sp[0xc]
800094ba:	ea 08 11 40 	rsub	r8,r5,64
800094be:	f6 0c 0a 4c 	lsr	r12,r11,r12
800094c2:	ec 08 09 46 	lsl	r6,r6,r8
800094c6:	0c 4c       	or	r12,r6
800094c8:	c0 78       	rjmp	800094d6 <_dtoa_r+0x156>
800094ca:	d7 03       	nop
800094cc:	ea 0c 11 20 	rsub	r12,r5,32
800094d0:	40 3a       	lddsp	r10,sp[0xc]
800094d2:	f4 0c 09 4c 	lsl	r12,r10,r12
800094d6:	e0 a0 10 14 	rcall	8000b4fe <__avr32_u32_to_f64>
800094da:	fc 18 fe 10 	movh	r8,0xfe10
800094de:	30 19       	mov	r9,1
800094e0:	ea c5 04 33 	sub	r5,r5,1075
800094e4:	f0 0b 00 0b 	add	r11,r8,r11
800094e8:	51 79       	stdsp	sp[0x5c],r9
800094ea:	30 08       	mov	r8,0
800094ec:	fc 19 3f f8 	movh	r9,0x3ff8
800094f0:	e0 a0 0e 9c 	rcall	8000b228 <__avr32_f64_sub>
800094f4:	e0 68 43 61 	mov	r8,17249
800094f8:	ea 18 63 6f 	orh	r8,0x636f
800094fc:	e0 69 87 a7 	mov	r9,34727
80009500:	ea 19 3f d2 	orh	r9,0x3fd2
80009504:	e0 a0 0d a6 	rcall	8000b050 <__avr32_f64_mul>
80009508:	e0 68 c8 b3 	mov	r8,51379
8000950c:	ea 18 8b 60 	orh	r8,0x8b60
80009510:	e0 69 8a 28 	mov	r9,35368
80009514:	ea 19 3f c6 	orh	r9,0x3fc6
80009518:	e0 a0 0f 56 	rcall	8000b3c4 <__avr32_f64_add>
8000951c:	0a 9c       	mov	r12,r5
8000951e:	14 90       	mov	r0,r10
80009520:	16 91       	mov	r1,r11
80009522:	e0 a0 0f f2 	rcall	8000b506 <__avr32_s32_to_f64>
80009526:	e0 68 79 fb 	mov	r8,31227
8000952a:	ea 18 50 9f 	orh	r8,0x509f
8000952e:	e0 69 44 13 	mov	r9,17427
80009532:	ea 19 3f d3 	orh	r9,0x3fd3
80009536:	e0 a0 0d 8d 	rcall	8000b050 <__avr32_f64_mul>
8000953a:	14 98       	mov	r8,r10
8000953c:	16 99       	mov	r9,r11
8000953e:	00 9a       	mov	r10,r0
80009540:	02 9b       	mov	r11,r1
80009542:	e0 a0 0f 41 	rcall	8000b3c4 <__avr32_f64_add>
80009546:	14 90       	mov	r0,r10
80009548:	16 91       	mov	r1,r11
8000954a:	e0 a0 0f c7 	rcall	8000b4d8 <__avr32_f64_to_s32>
8000954e:	30 08       	mov	r8,0
80009550:	18 96       	mov	r6,r12
80009552:	30 09       	mov	r9,0
80009554:	00 9a       	mov	r10,r0
80009556:	02 9b       	mov	r11,r1
80009558:	e0 a0 10 8e 	rcall	8000b674 <__avr32_f64_cmp_lt>
8000955c:	c0 c0       	breq	80009574 <_dtoa_r+0x1f4>
8000955e:	0c 9c       	mov	r12,r6
80009560:	e0 a0 0f d3 	rcall	8000b506 <__avr32_s32_to_f64>
80009564:	14 98       	mov	r8,r10
80009566:	16 99       	mov	r9,r11
80009568:	00 9a       	mov	r10,r0
8000956a:	02 9b       	mov	r11,r1
8000956c:	e0 a0 10 3d 	rcall	8000b5e6 <__avr32_f64_cmp_eq>
80009570:	f7 b6 00 01 	subeq	r6,1
80009574:	59 66       	cp.w	r6,22
80009576:	e0 88 00 05 	brls	80009580 <_dtoa_r+0x200>
8000957a:	30 18       	mov	r8,1
8000957c:	51 48       	stdsp	sp[0x50],r8
8000957e:	c1 38       	rjmp	800095a4 <_dtoa_r+0x224>
80009580:	fe c8 c2 14 	sub	r8,pc,-15852
80009584:	fa ea 00 3c 	ld.d	r10,sp[60]
80009588:	f0 06 02 38 	ld.d	r8,r8[r6<<0x3]
8000958c:	e0 a0 10 74 	rcall	8000b674 <__avr32_f64_cmp_lt>
80009590:	f9 b4 00 00 	moveq	r4,0
80009594:	fb f4 0a 14 	st.weq	sp[0x50],r4
80009598:	f7 b6 01 01 	subne	r6,1
8000959c:	f9 bc 01 00 	movne	r12,0
800095a0:	fb fc 1a 14 	st.wne	sp[0x50],r12
800095a4:	41 90       	lddsp	r0,sp[0x64]
800095a6:	20 10       	sub	r0,1
800095a8:	0a 10       	sub	r0,r5
800095aa:	c0 46       	brmi	800095b2 <_dtoa_r+0x232>
800095ac:	50 40       	stdsp	sp[0x10],r0
800095ae:	30 00       	mov	r0,0
800095b0:	c0 48       	rjmp	800095b8 <_dtoa_r+0x238>
800095b2:	30 0b       	mov	r11,0
800095b4:	5c 30       	neg	r0
800095b6:	50 4b       	stdsp	sp[0x10],r11
800095b8:	ec 02 11 00 	rsub	r2,r6,0
800095bc:	58 06       	cp.w	r6,0
800095be:	fb fa 40 04 	ld.wge	r10,sp[0x10]
800095c2:	f5 d6 e4 0a 	addge	r10,r10,r6
800095c6:	fb fa 4a 04 	st.wge	sp[0x10],r10
800095ca:	fb f6 4a 11 	st.wge	sp[0x44],r6
800095ce:	f9 b2 04 00 	movge	r2,0
800095d2:	e1 d6 e5 10 	sublt	r0,r0,r6
800095d6:	f9 b9 05 00 	movlt	r9,0
800095da:	fb f9 5a 11 	st.wlt	sp[0x44],r9
800095de:	40 c8       	lddsp	r8,sp[0x30]
800095e0:	58 98       	cp.w	r8,9
800095e2:	e0 8b 00 20 	brhi	80009622 <_dtoa_r+0x2a2>
800095e6:	58 58       	cp.w	r8,5
800095e8:	f9 b4 0a 01 	movle	r4,1
800095ec:	fb f5 90 0c 	ld.wgt	r5,sp[0x30]
800095f0:	f7 b5 09 04 	subgt	r5,4
800095f4:	fb f5 9a 0c 	st.wgt	sp[0x30],r5
800095f8:	f9 b4 09 00 	movgt	r4,0
800095fc:	40 cc       	lddsp	r12,sp[0x30]
800095fe:	58 3c       	cp.w	r12,3
80009600:	c2 d0       	breq	8000965a <_dtoa_r+0x2da>
80009602:	e0 89 00 05 	brgt	8000960c <_dtoa_r+0x28c>
80009606:	58 2c       	cp.w	r12,2
80009608:	c1 01       	brne	80009628 <_dtoa_r+0x2a8>
8000960a:	c1 88       	rjmp	8000963a <_dtoa_r+0x2ba>
8000960c:	40 cb       	lddsp	r11,sp[0x30]
8000960e:	58 4b       	cp.w	r11,4
80009610:	c0 60       	breq	8000961c <_dtoa_r+0x29c>
80009612:	58 5b       	cp.w	r11,5
80009614:	c0 a1       	brne	80009628 <_dtoa_r+0x2a8>
80009616:	30 1a       	mov	r10,1
80009618:	50 da       	stdsp	sp[0x34],r10
8000961a:	c2 28       	rjmp	8000965e <_dtoa_r+0x2de>
8000961c:	30 19       	mov	r9,1
8000961e:	50 d9       	stdsp	sp[0x34],r9
80009620:	c0 f8       	rjmp	8000963e <_dtoa_r+0x2be>
80009622:	30 08       	mov	r8,0
80009624:	30 14       	mov	r4,1
80009626:	50 c8       	stdsp	sp[0x30],r8
80009628:	3f f5       	mov	r5,-1
8000962a:	30 1c       	mov	r12,1
8000962c:	30 0b       	mov	r11,0
8000962e:	50 95       	stdsp	sp[0x24],r5
80009630:	50 dc       	stdsp	sp[0x34],r12
80009632:	0a 91       	mov	r1,r5
80009634:	31 28       	mov	r8,18
80009636:	50 eb       	stdsp	sp[0x38],r11
80009638:	c2 08       	rjmp	80009678 <_dtoa_r+0x2f8>
8000963a:	30 0a       	mov	r10,0
8000963c:	50 da       	stdsp	sp[0x34],r10
8000963e:	40 e9       	lddsp	r9,sp[0x38]
80009640:	58 09       	cp.w	r9,0
80009642:	e0 89 00 07 	brgt	80009650 <_dtoa_r+0x2d0>
80009646:	30 18       	mov	r8,1
80009648:	50 98       	stdsp	sp[0x24],r8
8000964a:	10 91       	mov	r1,r8
8000964c:	50 e8       	stdsp	sp[0x38],r8
8000964e:	c1 58       	rjmp	80009678 <_dtoa_r+0x2f8>
80009650:	40 e5       	lddsp	r5,sp[0x38]
80009652:	50 95       	stdsp	sp[0x24],r5
80009654:	0a 91       	mov	r1,r5
80009656:	0a 98       	mov	r8,r5
80009658:	c1 08       	rjmp	80009678 <_dtoa_r+0x2f8>
8000965a:	30 0c       	mov	r12,0
8000965c:	50 dc       	stdsp	sp[0x34],r12
8000965e:	40 eb       	lddsp	r11,sp[0x38]
80009660:	ec 0b 00 0b 	add	r11,r6,r11
80009664:	50 9b       	stdsp	sp[0x24],r11
80009666:	16 98       	mov	r8,r11
80009668:	2f f8       	sub	r8,-1
8000966a:	58 08       	cp.w	r8,0
8000966c:	e0 89 00 05 	brgt	80009676 <_dtoa_r+0x2f6>
80009670:	10 91       	mov	r1,r8
80009672:	30 18       	mov	r8,1
80009674:	c0 28       	rjmp	80009678 <_dtoa_r+0x2f8>
80009676:	10 91       	mov	r1,r8
80009678:	30 09       	mov	r9,0
8000967a:	6e 9a       	ld.w	r10,r7[0x24]
8000967c:	95 19       	st.w	r10[0x4],r9
8000967e:	30 49       	mov	r9,4
80009680:	c0 68       	rjmp	8000968c <_dtoa_r+0x30c>
80009682:	d7 03       	nop
80009684:	6a 1a       	ld.w	r10,r5[0x4]
80009686:	a1 79       	lsl	r9,0x1
80009688:	2f fa       	sub	r10,-1
8000968a:	8b 1a       	st.w	r5[0x4],r10
8000968c:	6e 95       	ld.w	r5,r7[0x24]
8000968e:	f2 ca ff ec 	sub	r10,r9,-20
80009692:	10 3a       	cp.w	r10,r8
80009694:	fe 98 ff f8 	brls	80009684 <_dtoa_r+0x304>
80009698:	6a 1b       	ld.w	r11,r5[0x4]
8000969a:	0e 9c       	mov	r12,r7
8000969c:	e0 a0 09 44 	rcall	8000a924 <_Balloc>
800096a0:	58 e1       	cp.w	r1,14
800096a2:	5f 88       	srls	r8
800096a4:	8b 0c       	st.w	r5[0x0],r12
800096a6:	f1 e4 00 04 	and	r4,r8,r4
800096aa:	6e 98       	ld.w	r8,r7[0x24]
800096ac:	70 08       	ld.w	r8,r8[0x0]
800096ae:	50 88       	stdsp	sp[0x20],r8
800096b0:	e0 80 01 82 	breq	800099b4 <_dtoa_r+0x634>
800096b4:	58 06       	cp.w	r6,0
800096b6:	e0 8a 00 43 	brle	8000973c <_dtoa_r+0x3bc>
800096ba:	f3 d6 c0 04 	bfextu	r9,r6,0x0,0x4
800096be:	fe c8 c3 52 	sub	r8,pc,-15534
800096c2:	f0 09 02 34 	ld.d	r4,r8[r9<<0x3]
800096c6:	fa e5 00 18 	st.d	sp[24],r4
800096ca:	ec 04 14 04 	asr	r4,r6,0x4
800096ce:	ed b4 00 04 	bld	r4,0x4
800096d2:	c0 30       	breq	800096d8 <_dtoa_r+0x358>
800096d4:	30 25       	mov	r5,2
800096d6:	c1 08       	rjmp	800096f6 <_dtoa_r+0x376>
800096d8:	fe c8 c2 a4 	sub	r8,pc,-15708
800096dc:	f0 e8 00 20 	ld.d	r8,r8[32]
800096e0:	fa ea 00 3c 	ld.d	r10,sp[60]
800096e4:	e9 d4 c0 04 	bfextu	r4,r4,0x0,0x4
800096e8:	e0 a0 0f fa 	rcall	8000b6dc <__avr32_f64_div>
800096ec:	30 35       	mov	r5,3
800096ee:	14 98       	mov	r8,r10
800096f0:	16 99       	mov	r9,r11
800096f2:	fa e9 00 08 	st.d	sp[8],r8
800096f6:	fe cc c2 c2 	sub	r12,pc,-15678
800096fa:	50 a3       	stdsp	sp[0x28],r3
800096fc:	0c 93       	mov	r3,r6
800096fe:	18 96       	mov	r6,r12
80009700:	c0 f8       	rjmp	8000971e <_dtoa_r+0x39e>
80009702:	fa ea 00 18 	ld.d	r10,sp[24]
80009706:	ed b4 00 00 	bld	r4,0x0
8000970a:	c0 81       	brne	8000971a <_dtoa_r+0x39a>
8000970c:	ec e8 00 00 	ld.d	r8,r6[0]
80009710:	2f f5       	sub	r5,-1
80009712:	e0 a0 0c 9f 	rcall	8000b050 <__avr32_f64_mul>
80009716:	fa eb 00 18 	st.d	sp[24],r10
8000971a:	a1 54       	asr	r4,0x1
8000971c:	2f 86       	sub	r6,-8
8000971e:	58 04       	cp.w	r4,0
80009720:	cf 11       	brne	80009702 <_dtoa_r+0x382>
80009722:	fa e8 00 18 	ld.d	r8,sp[24]
80009726:	fa ea 00 08 	ld.d	r10,sp[8]
8000972a:	06 96       	mov	r6,r3
8000972c:	e0 a0 0f d8 	rcall	8000b6dc <__avr32_f64_div>
80009730:	40 a3       	lddsp	r3,sp[0x28]
80009732:	14 98       	mov	r8,r10
80009734:	16 99       	mov	r9,r11
80009736:	fa e9 00 08 	st.d	sp[8],r8
8000973a:	c2 f8       	rjmp	80009798 <_dtoa_r+0x418>
8000973c:	ec 08 11 00 	rsub	r8,r6,0
80009740:	c0 31       	brne	80009746 <_dtoa_r+0x3c6>
80009742:	30 25       	mov	r5,2
80009744:	c2 a8       	rjmp	80009798 <_dtoa_r+0x418>
80009746:	fe cc c3 12 	sub	r12,pc,-15598
8000974a:	f0 04 14 04 	asr	r4,r8,0x4
8000974e:	50 1c       	stdsp	sp[0x4],r12
80009750:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
80009754:	fe c9 c3 e8 	sub	r9,pc,-15384
80009758:	fa ea 00 3c 	ld.d	r10,sp[60]
8000975c:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
80009760:	e0 a0 0c 78 	rcall	8000b050 <__avr32_f64_mul>
80009764:	40 1c       	lddsp	r12,sp[0x4]
80009766:	50 63       	stdsp	sp[0x18],r3
80009768:	30 25       	mov	r5,2
8000976a:	0c 93       	mov	r3,r6
8000976c:	fa eb 00 08 	st.d	sp[8],r10
80009770:	18 96       	mov	r6,r12
80009772:	c0 f8       	rjmp	80009790 <_dtoa_r+0x410>
80009774:	fa ea 00 08 	ld.d	r10,sp[8]
80009778:	ed b4 00 00 	bld	r4,0x0
8000977c:	c0 81       	brne	8000978c <_dtoa_r+0x40c>
8000977e:	ec e8 00 00 	ld.d	r8,r6[0]
80009782:	2f f5       	sub	r5,-1
80009784:	e0 a0 0c 66 	rcall	8000b050 <__avr32_f64_mul>
80009788:	fa eb 00 08 	st.d	sp[8],r10
8000978c:	a1 54       	asr	r4,0x1
8000978e:	2f 86       	sub	r6,-8
80009790:	58 04       	cp.w	r4,0
80009792:	cf 11       	brne	80009774 <_dtoa_r+0x3f4>
80009794:	06 96       	mov	r6,r3
80009796:	40 63       	lddsp	r3,sp[0x18]
80009798:	41 4a       	lddsp	r10,sp[0x50]
8000979a:	58 0a       	cp.w	r10,0
8000979c:	c2 a0       	breq	800097f0 <_dtoa_r+0x470>
8000979e:	fa e8 00 08 	ld.d	r8,sp[8]
800097a2:	58 01       	cp.w	r1,0
800097a4:	5f 94       	srgt	r4
800097a6:	fa e9 00 18 	st.d	sp[24],r8
800097aa:	30 08       	mov	r8,0
800097ac:	fc 19 3f f0 	movh	r9,0x3ff0
800097b0:	fa ea 00 18 	ld.d	r10,sp[24]
800097b4:	e0 a0 0f 60 	rcall	8000b674 <__avr32_f64_cmp_lt>
800097b8:	f9 bc 00 00 	moveq	r12,0
800097bc:	f9 bc 01 01 	movne	r12,1
800097c0:	e9 ec 00 0c 	and	r12,r4,r12
800097c4:	c1 60       	breq	800097f0 <_dtoa_r+0x470>
800097c6:	40 98       	lddsp	r8,sp[0x24]
800097c8:	58 08       	cp.w	r8,0
800097ca:	e0 8a 00 f1 	brle	800099ac <_dtoa_r+0x62c>
800097ce:	30 08       	mov	r8,0
800097d0:	fc 19 40 24 	movh	r9,0x4024
800097d4:	ec c4 00 01 	sub	r4,r6,1
800097d8:	fa ea 00 18 	ld.d	r10,sp[24]
800097dc:	2f f5       	sub	r5,-1
800097de:	50 64       	stdsp	sp[0x18],r4
800097e0:	e0 a0 0c 38 	rcall	8000b050 <__avr32_f64_mul>
800097e4:	40 94       	lddsp	r4,sp[0x24]
800097e6:	14 98       	mov	r8,r10
800097e8:	16 99       	mov	r9,r11
800097ea:	fa e9 00 08 	st.d	sp[8],r8
800097ee:	c0 38       	rjmp	800097f4 <_dtoa_r+0x474>
800097f0:	50 66       	stdsp	sp[0x18],r6
800097f2:	02 94       	mov	r4,r1
800097f4:	0a 9c       	mov	r12,r5
800097f6:	e0 a0 0e 88 	rcall	8000b506 <__avr32_s32_to_f64>
800097fa:	fa e8 00 08 	ld.d	r8,sp[8]
800097fe:	e0 a0 0c 29 	rcall	8000b050 <__avr32_f64_mul>
80009802:	30 08       	mov	r8,0
80009804:	fc 19 40 1c 	movh	r9,0x401c
80009808:	e0 a0 0d de 	rcall	8000b3c4 <__avr32_f64_add>
8000980c:	14 98       	mov	r8,r10
8000980e:	16 99       	mov	r9,r11
80009810:	fa e9 00 28 	st.d	sp[40],r8
80009814:	fc 18 fc c0 	movh	r8,0xfcc0
80009818:	40 a5       	lddsp	r5,sp[0x28]
8000981a:	10 05       	add	r5,r8
8000981c:	50 a5       	stdsp	sp[0x28],r5
8000981e:	58 04       	cp.w	r4,0
80009820:	c2 11       	brne	80009862 <_dtoa_r+0x4e2>
80009822:	fa ea 00 08 	ld.d	r10,sp[8]
80009826:	30 08       	mov	r8,0
80009828:	fc 19 40 14 	movh	r9,0x4014
8000982c:	e0 a0 0c fe 	rcall	8000b228 <__avr32_f64_sub>
80009830:	40 bc       	lddsp	r12,sp[0x2c]
80009832:	fa eb 00 08 	st.d	sp[8],r10
80009836:	14 98       	mov	r8,r10
80009838:	16 99       	mov	r9,r11
8000983a:	18 9a       	mov	r10,r12
8000983c:	0a 9b       	mov	r11,r5
8000983e:	e0 a0 0f 1b 	rcall	8000b674 <__avr32_f64_cmp_lt>
80009842:	e0 81 02 54 	brne	80009cea <_dtoa_r+0x96a>
80009846:	0a 98       	mov	r8,r5
80009848:	40 b9       	lddsp	r9,sp[0x2c]
8000984a:	ee 18 80 00 	eorh	r8,0x8000
8000984e:	fa ea 00 08 	ld.d	r10,sp[8]
80009852:	10 95       	mov	r5,r8
80009854:	12 98       	mov	r8,r9
80009856:	0a 99       	mov	r9,r5
80009858:	e0 a0 0f 0e 	rcall	8000b674 <__avr32_f64_cmp_lt>
8000985c:	e0 81 02 3e 	brne	80009cd8 <_dtoa_r+0x958>
80009860:	ca 68       	rjmp	800099ac <_dtoa_r+0x62c>
80009862:	fe c9 c4 f6 	sub	r9,pc,-15114
80009866:	e8 c8 00 01 	sub	r8,r4,1
8000986a:	40 d5       	lddsp	r5,sp[0x34]
8000986c:	58 05       	cp.w	r5,0
8000986e:	c4 f0       	breq	8000990c <_dtoa_r+0x58c>
80009870:	30 0c       	mov	r12,0
80009872:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
80009876:	51 3c       	stdsp	sp[0x4c],r12
80009878:	30 0a       	mov	r10,0
8000987a:	fc 1b 3f e0 	movh	r11,0x3fe0
8000987e:	e0 a0 0f 2f 	rcall	8000b6dc <__avr32_f64_div>
80009882:	fa e8 00 28 	ld.d	r8,sp[40]
80009886:	40 85       	lddsp	r5,sp[0x20]
80009888:	e0 a0 0c d0 	rcall	8000b228 <__avr32_f64_sub>
8000988c:	fa eb 00 28 	st.d	sp[40],r10
80009890:	fa ea 00 08 	ld.d	r10,sp[8]
80009894:	e0 a0 0e 22 	rcall	8000b4d8 <__avr32_f64_to_s32>
80009898:	51 6c       	stdsp	sp[0x58],r12
8000989a:	e0 a0 0e 36 	rcall	8000b506 <__avr32_s32_to_f64>
8000989e:	14 98       	mov	r8,r10
800098a0:	16 99       	mov	r9,r11
800098a2:	fa ea 00 08 	ld.d	r10,sp[8]
800098a6:	e0 a0 0c c1 	rcall	8000b228 <__avr32_f64_sub>
800098aa:	fa eb 00 08 	st.d	sp[8],r10
800098ae:	41 68       	lddsp	r8,sp[0x58]
800098b0:	2d 08       	sub	r8,-48
800098b2:	0a c8       	st.b	r5++,r8
800098b4:	41 39       	lddsp	r9,sp[0x4c]
800098b6:	2f f9       	sub	r9,-1
800098b8:	51 39       	stdsp	sp[0x4c],r9
800098ba:	fa e8 00 28 	ld.d	r8,sp[40]
800098be:	e0 a0 0e db 	rcall	8000b674 <__avr32_f64_cmp_lt>
800098c2:	e0 81 03 39 	brne	80009f34 <_dtoa_r+0xbb4>
800098c6:	fa e8 00 08 	ld.d	r8,sp[8]
800098ca:	30 0a       	mov	r10,0
800098cc:	fc 1b 3f f0 	movh	r11,0x3ff0
800098d0:	e0 a0 0c ac 	rcall	8000b228 <__avr32_f64_sub>
800098d4:	fa e8 00 28 	ld.d	r8,sp[40]
800098d8:	e0 a0 0e ce 	rcall	8000b674 <__avr32_f64_cmp_lt>
800098dc:	fa ea 00 28 	ld.d	r10,sp[40]
800098e0:	30 08       	mov	r8,0
800098e2:	fc 19 40 24 	movh	r9,0x4024
800098e6:	e0 81 00 da 	brne	80009a9a <_dtoa_r+0x71a>
800098ea:	41 3c       	lddsp	r12,sp[0x4c]
800098ec:	08 3c       	cp.w	r12,r4
800098ee:	c5 f4       	brge	800099ac <_dtoa_r+0x62c>
800098f0:	e0 a0 0b b0 	rcall	8000b050 <__avr32_f64_mul>
800098f4:	30 08       	mov	r8,0
800098f6:	fa eb 00 28 	st.d	sp[40],r10
800098fa:	fc 19 40 24 	movh	r9,0x4024
800098fe:	fa ea 00 08 	ld.d	r10,sp[8]
80009902:	e0 a0 0b a7 	rcall	8000b050 <__avr32_f64_mul>
80009906:	fa eb 00 08 	st.d	sp[8],r10
8000990a:	cc 3b       	rjmp	80009890 <_dtoa_r+0x510>
8000990c:	40 85       	lddsp	r5,sp[0x20]
8000990e:	08 05       	add	r5,r4
80009910:	f2 08 02 3a 	ld.d	r10,r9[r8<<0x3]
80009914:	51 35       	stdsp	sp[0x4c],r5
80009916:	fa e8 00 28 	ld.d	r8,sp[40]
8000991a:	40 85       	lddsp	r5,sp[0x20]
8000991c:	e0 a0 0b 9a 	rcall	8000b050 <__avr32_f64_mul>
80009920:	fa eb 00 28 	st.d	sp[40],r10
80009924:	fa ea 00 08 	ld.d	r10,sp[8]
80009928:	e0 a0 0d d8 	rcall	8000b4d8 <__avr32_f64_to_s32>
8000992c:	51 6c       	stdsp	sp[0x58],r12
8000992e:	e0 a0 0d ec 	rcall	8000b506 <__avr32_s32_to_f64>
80009932:	14 98       	mov	r8,r10
80009934:	16 99       	mov	r9,r11
80009936:	fa ea 00 08 	ld.d	r10,sp[8]
8000993a:	e0 a0 0c 77 	rcall	8000b228 <__avr32_f64_sub>
8000993e:	fa eb 00 08 	st.d	sp[8],r10
80009942:	41 68       	lddsp	r8,sp[0x58]
80009944:	2d 08       	sub	r8,-48
80009946:	0a c8       	st.b	r5++,r8
80009948:	41 3c       	lddsp	r12,sp[0x4c]
8000994a:	18 35       	cp.w	r5,r12
8000994c:	c2 81       	brne	8000999c <_dtoa_r+0x61c>
8000994e:	30 08       	mov	r8,0
80009950:	fc 19 3f e0 	movh	r9,0x3fe0
80009954:	fa ea 00 28 	ld.d	r10,sp[40]
80009958:	e0 a0 0d 36 	rcall	8000b3c4 <__avr32_f64_add>
8000995c:	40 85       	lddsp	r5,sp[0x20]
8000995e:	fa e8 00 08 	ld.d	r8,sp[8]
80009962:	08 05       	add	r5,r4
80009964:	e0 a0 0e 88 	rcall	8000b674 <__avr32_f64_cmp_lt>
80009968:	e0 81 00 99 	brne	80009a9a <_dtoa_r+0x71a>
8000996c:	fa e8 00 28 	ld.d	r8,sp[40]
80009970:	30 0a       	mov	r10,0
80009972:	fc 1b 3f e0 	movh	r11,0x3fe0
80009976:	e0 a0 0c 59 	rcall	8000b228 <__avr32_f64_sub>
8000997a:	14 98       	mov	r8,r10
8000997c:	16 99       	mov	r9,r11
8000997e:	fa ea 00 08 	ld.d	r10,sp[8]
80009982:	e0 a0 0e 79 	rcall	8000b674 <__avr32_f64_cmp_lt>
80009986:	c1 30       	breq	800099ac <_dtoa_r+0x62c>
80009988:	33 09       	mov	r9,48
8000998a:	0a 98       	mov	r8,r5
8000998c:	11 7a       	ld.ub	r10,--r8
8000998e:	f2 0a 18 00 	cp.b	r10,r9
80009992:	e0 81 02 d1 	brne	80009f34 <_dtoa_r+0xbb4>
80009996:	10 95       	mov	r5,r8
80009998:	cf 9b       	rjmp	8000998a <_dtoa_r+0x60a>
8000999a:	d7 03       	nop
8000999c:	30 08       	mov	r8,0
8000999e:	fc 19 40 24 	movh	r9,0x4024
800099a2:	e0 a0 0b 57 	rcall	8000b050 <__avr32_f64_mul>
800099a6:	fa eb 00 08 	st.d	sp[8],r10
800099aa:	cb db       	rjmp	80009924 <_dtoa_r+0x5a4>
800099ac:	fa ea 00 3c 	ld.d	r10,sp[60]
800099b0:	fa eb 00 08 	st.d	sp[8],r10
800099b4:	58 e6       	cp.w	r6,14
800099b6:	5f ab       	srle	r11
800099b8:	41 8a       	lddsp	r10,sp[0x60]
800099ba:	30 08       	mov	r8,0
800099bc:	f4 09 11 ff 	rsub	r9,r10,-1
800099c0:	f7 e9 03 f9 	and	r9,r11,r9>>0x1f
800099c4:	f0 09 18 00 	cp.b	r9,r8
800099c8:	e0 80 00 82 	breq	80009acc <_dtoa_r+0x74c>
800099cc:	40 ea       	lddsp	r10,sp[0x38]
800099ce:	58 01       	cp.w	r1,0
800099d0:	5f a9       	srle	r9
800099d2:	f3 ea 03 f9 	and	r9,r9,r10>>0x1f
800099d6:	fe ca c6 6a 	sub	r10,pc,-14742
800099da:	f4 06 02 34 	ld.d	r4,r10[r6<<0x3]
800099de:	fa e5 00 10 	st.d	sp[16],r4
800099e2:	f0 09 18 00 	cp.b	r9,r8
800099e6:	c1 40       	breq	80009a0e <_dtoa_r+0x68e>
800099e8:	58 01       	cp.w	r1,0
800099ea:	e0 81 01 77 	brne	80009cd8 <_dtoa_r+0x958>
800099ee:	30 08       	mov	r8,0
800099f0:	fc 19 40 14 	movh	r9,0x4014
800099f4:	08 9a       	mov	r10,r4
800099f6:	0a 9b       	mov	r11,r5
800099f8:	e0 a0 0b 2c 	rcall	8000b050 <__avr32_f64_mul>
800099fc:	fa e8 00 08 	ld.d	r8,sp[8]
80009a00:	e0 a0 0e 06 	rcall	8000b60c <__avr32_f64_cmp_ge>
80009a04:	e0 81 01 6a 	brne	80009cd8 <_dtoa_r+0x958>
80009a08:	02 92       	mov	r2,r1
80009a0a:	e0 8f 01 72 	bral	80009cee <_dtoa_r+0x96e>
80009a0e:	40 85       	lddsp	r5,sp[0x20]
80009a10:	30 14       	mov	r4,1
80009a12:	fa e8 00 10 	ld.d	r8,sp[16]
80009a16:	fa ea 00 08 	ld.d	r10,sp[8]
80009a1a:	e0 a0 0e 61 	rcall	8000b6dc <__avr32_f64_div>
80009a1e:	e0 a0 0d 5d 	rcall	8000b4d8 <__avr32_f64_to_s32>
80009a22:	18 92       	mov	r2,r12
80009a24:	e0 a0 0d 71 	rcall	8000b506 <__avr32_s32_to_f64>
80009a28:	fa e8 00 10 	ld.d	r8,sp[16]
80009a2c:	e0 a0 0b 12 	rcall	8000b050 <__avr32_f64_mul>
80009a30:	14 98       	mov	r8,r10
80009a32:	16 99       	mov	r9,r11
80009a34:	fa ea 00 08 	ld.d	r10,sp[8]
80009a38:	e0 a0 0b f8 	rcall	8000b228 <__avr32_f64_sub>
80009a3c:	fa eb 00 08 	st.d	sp[8],r10
80009a40:	e4 c8 ff d0 	sub	r8,r2,-48
80009a44:	0a c8       	st.b	r5++,r8
80009a46:	fc 19 40 24 	movh	r9,0x4024
80009a4a:	30 08       	mov	r8,0
80009a4c:	02 34       	cp.w	r4,r1
80009a4e:	c3 31       	brne	80009ab4 <_dtoa_r+0x734>
80009a50:	fa e8 00 08 	ld.d	r8,sp[8]
80009a54:	e0 a0 0c b8 	rcall	8000b3c4 <__avr32_f64_add>
80009a58:	16 91       	mov	r1,r11
80009a5a:	14 90       	mov	r0,r10
80009a5c:	14 98       	mov	r8,r10
80009a5e:	02 99       	mov	r9,r1
80009a60:	fa ea 00 10 	ld.d	r10,sp[16]
80009a64:	e0 a0 0e 08 	rcall	8000b674 <__avr32_f64_cmp_lt>
80009a68:	c1 a1       	brne	80009a9c <_dtoa_r+0x71c>
80009a6a:	fa e8 00 10 	ld.d	r8,sp[16]
80009a6e:	00 9a       	mov	r10,r0
80009a70:	02 9b       	mov	r11,r1
80009a72:	e0 a0 0d ba 	rcall	8000b5e6 <__avr32_f64_cmp_eq>
80009a76:	e0 80 02 5e 	breq	80009f32 <_dtoa_r+0xbb2>
80009a7a:	e5 d2 c0 01 	bfextu	r2,r2,0x0,0x1
80009a7e:	c0 f1       	brne	80009a9c <_dtoa_r+0x71c>
80009a80:	e0 8f 02 59 	bral	80009f32 <_dtoa_r+0xbb2>
80009a84:	40 8a       	lddsp	r10,sp[0x20]
80009a86:	14 38       	cp.w	r8,r10
80009a88:	c0 30       	breq	80009a8e <_dtoa_r+0x70e>
80009a8a:	10 95       	mov	r5,r8
80009a8c:	c0 98       	rjmp	80009a9e <_dtoa_r+0x71e>
80009a8e:	33 08       	mov	r8,48
80009a90:	40 89       	lddsp	r9,sp[0x20]
80009a92:	2f f6       	sub	r6,-1
80009a94:	b2 88       	st.b	r9[0x0],r8
80009a96:	40 88       	lddsp	r8,sp[0x20]
80009a98:	c0 88       	rjmp	80009aa8 <_dtoa_r+0x728>
80009a9a:	40 66       	lddsp	r6,sp[0x18]
80009a9c:	33 99       	mov	r9,57
80009a9e:	0a 98       	mov	r8,r5
80009aa0:	11 7a       	ld.ub	r10,--r8
80009aa2:	f2 0a 18 00 	cp.b	r10,r9
80009aa6:	ce f0       	breq	80009a84 <_dtoa_r+0x704>
80009aa8:	50 66       	stdsp	sp[0x18],r6
80009aaa:	11 89       	ld.ub	r9,r8[0x0]
80009aac:	2f f9       	sub	r9,-1
80009aae:	b0 89       	st.b	r8[0x0],r9
80009ab0:	e0 8f 02 42 	bral	80009f34 <_dtoa_r+0xbb4>
80009ab4:	e0 a0 0a ce 	rcall	8000b050 <__avr32_f64_mul>
80009ab8:	2f f4       	sub	r4,-1
80009aba:	fa eb 00 08 	st.d	sp[8],r10
80009abe:	30 08       	mov	r8,0
80009ac0:	30 09       	mov	r9,0
80009ac2:	e0 a0 0d 92 	rcall	8000b5e6 <__avr32_f64_cmp_eq>
80009ac6:	ca 60       	breq	80009a12 <_dtoa_r+0x692>
80009ac8:	e0 8f 02 35 	bral	80009f32 <_dtoa_r+0xbb2>
80009acc:	40 d8       	lddsp	r8,sp[0x34]
80009ace:	58 08       	cp.w	r8,0
80009ad0:	c0 51       	brne	80009ada <_dtoa_r+0x75a>
80009ad2:	04 98       	mov	r8,r2
80009ad4:	00 95       	mov	r5,r0
80009ad6:	40 d4       	lddsp	r4,sp[0x34]
80009ad8:	c3 78       	rjmp	80009b46 <_dtoa_r+0x7c6>
80009ada:	40 c5       	lddsp	r5,sp[0x30]
80009adc:	58 15       	cp.w	r5,1
80009ade:	e0 89 00 0f 	brgt	80009afc <_dtoa_r+0x77c>
80009ae2:	41 74       	lddsp	r4,sp[0x5c]
80009ae4:	58 04       	cp.w	r4,0
80009ae6:	c0 40       	breq	80009aee <_dtoa_r+0x76e>
80009ae8:	f4 c9 fb cd 	sub	r9,r10,-1075
80009aec:	c0 48       	rjmp	80009af4 <_dtoa_r+0x774>
80009aee:	41 99       	lddsp	r9,sp[0x64]
80009af0:	f2 09 11 36 	rsub	r9,r9,54
80009af4:	04 98       	mov	r8,r2
80009af6:	00 95       	mov	r5,r0
80009af8:	c1 c8       	rjmp	80009b30 <_dtoa_r+0x7b0>
80009afa:	d7 03       	nop
80009afc:	e2 c8 00 01 	sub	r8,r1,1
80009b00:	58 01       	cp.w	r1,0
80009b02:	e0 05 17 40 	movge	r5,r0
80009b06:	e2 09 17 40 	movge	r9,r1
80009b0a:	e1 d1 e5 15 	sublt	r5,r0,r1
80009b0e:	f9 b9 05 00 	movlt	r9,0
80009b12:	10 32       	cp.w	r2,r8
80009b14:	e5 d8 e4 18 	subge	r8,r2,r8
80009b18:	f1 d2 e5 18 	sublt	r8,r8,r2
80009b1c:	e5 d8 e5 02 	addlt	r2,r2,r8
80009b20:	fb fc 50 11 	ld.wlt	r12,sp[0x44]
80009b24:	f9 d8 e5 0c 	addlt	r12,r12,r8
80009b28:	fb fc 5a 11 	st.wlt	sp[0x44],r12
80009b2c:	f9 b8 05 00 	movlt	r8,0
80009b30:	40 4b       	lddsp	r11,sp[0x10]
80009b32:	12 0b       	add	r11,r9
80009b34:	50 08       	stdsp	sp[0x0],r8
80009b36:	50 4b       	stdsp	sp[0x10],r11
80009b38:	12 00       	add	r0,r9
80009b3a:	30 1b       	mov	r11,1
80009b3c:	0e 9c       	mov	r12,r7
80009b3e:	e0 a0 08 a7 	rcall	8000ac8c <__i2b>
80009b42:	40 08       	lddsp	r8,sp[0x0]
80009b44:	18 94       	mov	r4,r12
80009b46:	40 4a       	lddsp	r10,sp[0x10]
80009b48:	58 05       	cp.w	r5,0
80009b4a:	5f 99       	srgt	r9
80009b4c:	58 0a       	cp.w	r10,0
80009b4e:	5f 9a       	srgt	r10
80009b50:	f5 e9 00 09 	and	r9,r10,r9
80009b54:	c0 80       	breq	80009b64 <_dtoa_r+0x7e4>
80009b56:	40 4c       	lddsp	r12,sp[0x10]
80009b58:	f8 05 0d 49 	min	r9,r12,r5
80009b5c:	12 1c       	sub	r12,r9
80009b5e:	12 10       	sub	r0,r9
80009b60:	50 4c       	stdsp	sp[0x10],r12
80009b62:	12 15       	sub	r5,r9
80009b64:	58 02       	cp.w	r2,0
80009b66:	e0 8a 00 27 	brle	80009bb4 <_dtoa_r+0x834>
80009b6a:	40 db       	lddsp	r11,sp[0x34]
80009b6c:	58 0b       	cp.w	r11,0
80009b6e:	c1 d0       	breq	80009ba8 <_dtoa_r+0x828>
80009b70:	58 08       	cp.w	r8,0
80009b72:	e0 8a 00 17 	brle	80009ba0 <_dtoa_r+0x820>
80009b76:	10 9a       	mov	r10,r8
80009b78:	50 08       	stdsp	sp[0x0],r8
80009b7a:	08 9b       	mov	r11,r4
80009b7c:	0e 9c       	mov	r12,r7
80009b7e:	e0 a0 08 cd 	rcall	8000ad18 <__pow5mult>
80009b82:	06 9a       	mov	r10,r3
80009b84:	18 9b       	mov	r11,r12
80009b86:	18 94       	mov	r4,r12
80009b88:	0e 9c       	mov	r12,r7
80009b8a:	e0 a0 08 01 	rcall	8000ab8c <__multiply>
80009b8e:	18 99       	mov	r9,r12
80009b90:	06 9b       	mov	r11,r3
80009b92:	50 19       	stdsp	sp[0x4],r9
80009b94:	0e 9c       	mov	r12,r7
80009b96:	e0 a0 06 ad 	rcall	8000a8f0 <_Bfree>
80009b9a:	40 19       	lddsp	r9,sp[0x4]
80009b9c:	40 08       	lddsp	r8,sp[0x0]
80009b9e:	12 93       	mov	r3,r9
80009ba0:	e4 08 01 0a 	sub	r10,r2,r8
80009ba4:	c0 80       	breq	80009bb4 <_dtoa_r+0x834>
80009ba6:	c0 28       	rjmp	80009baa <_dtoa_r+0x82a>
80009ba8:	04 9a       	mov	r10,r2
80009baa:	06 9b       	mov	r11,r3
80009bac:	0e 9c       	mov	r12,r7
80009bae:	e0 a0 08 b5 	rcall	8000ad18 <__pow5mult>
80009bb2:	18 93       	mov	r3,r12
80009bb4:	30 1b       	mov	r11,1
80009bb6:	0e 9c       	mov	r12,r7
80009bb8:	e0 a0 08 6a 	rcall	8000ac8c <__i2b>
80009bbc:	41 1a       	lddsp	r10,sp[0x44]
80009bbe:	18 92       	mov	r2,r12
80009bc0:	58 0a       	cp.w	r10,0
80009bc2:	e0 8a 00 07 	brle	80009bd0 <_dtoa_r+0x850>
80009bc6:	18 9b       	mov	r11,r12
80009bc8:	0e 9c       	mov	r12,r7
80009bca:	e0 a0 08 a7 	rcall	8000ad18 <__pow5mult>
80009bce:	18 92       	mov	r2,r12
80009bd0:	40 c9       	lddsp	r9,sp[0x30]
80009bd2:	58 19       	cp.w	r9,1
80009bd4:	e0 89 00 14 	brgt	80009bfc <_dtoa_r+0x87c>
80009bd8:	40 38       	lddsp	r8,sp[0xc]
80009bda:	58 08       	cp.w	r8,0
80009bdc:	c1 01       	brne	80009bfc <_dtoa_r+0x87c>
80009bde:	40 29       	lddsp	r9,sp[0x8]
80009be0:	f1 d9 c0 14 	bfextu	r8,r9,0x0,0x14
80009be4:	c0 c1       	brne	80009bfc <_dtoa_r+0x87c>
80009be6:	12 98       	mov	r8,r9
80009be8:	e6 18 7f f0 	andh	r8,0x7ff0,COH
80009bec:	c0 80       	breq	80009bfc <_dtoa_r+0x87c>
80009bee:	40 4c       	lddsp	r12,sp[0x10]
80009bf0:	30 1b       	mov	r11,1
80009bf2:	2f fc       	sub	r12,-1
80009bf4:	2f f0       	sub	r0,-1
80009bf6:	50 4c       	stdsp	sp[0x10],r12
80009bf8:	50 6b       	stdsp	sp[0x18],r11
80009bfa:	c0 38       	rjmp	80009c00 <_dtoa_r+0x880>
80009bfc:	30 0a       	mov	r10,0
80009bfe:	50 6a       	stdsp	sp[0x18],r10
80009c00:	41 19       	lddsp	r9,sp[0x44]
80009c02:	58 09       	cp.w	r9,0
80009c04:	c0 31       	brne	80009c0a <_dtoa_r+0x88a>
80009c06:	30 1c       	mov	r12,1
80009c08:	c0 98       	rjmp	80009c1a <_dtoa_r+0x89a>
80009c0a:	64 48       	ld.w	r8,r2[0x10]
80009c0c:	2f c8       	sub	r8,-4
80009c0e:	e4 08 03 2c 	ld.w	r12,r2[r8<<0x2]
80009c12:	e0 a0 05 df 	rcall	8000a7d0 <__hi0bits>
80009c16:	f8 0c 11 20 	rsub	r12,r12,32
80009c1a:	40 4b       	lddsp	r11,sp[0x10]
80009c1c:	f8 0b 00 08 	add	r8,r12,r11
80009c20:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80009c24:	c0 c0       	breq	80009c3c <_dtoa_r+0x8bc>
80009c26:	f0 08 11 20 	rsub	r8,r8,32
80009c2a:	58 48       	cp.w	r8,4
80009c2c:	e0 8a 00 06 	brle	80009c38 <_dtoa_r+0x8b8>
80009c30:	20 48       	sub	r8,4
80009c32:	10 0b       	add	r11,r8
80009c34:	50 4b       	stdsp	sp[0x10],r11
80009c36:	c0 78       	rjmp	80009c44 <_dtoa_r+0x8c4>
80009c38:	58 48       	cp.w	r8,4
80009c3a:	c0 70       	breq	80009c48 <_dtoa_r+0x8c8>
80009c3c:	40 4a       	lddsp	r10,sp[0x10]
80009c3e:	2e 48       	sub	r8,-28
80009c40:	10 0a       	add	r10,r8
80009c42:	50 4a       	stdsp	sp[0x10],r10
80009c44:	10 00       	add	r0,r8
80009c46:	10 05       	add	r5,r8
80009c48:	58 00       	cp.w	r0,0
80009c4a:	e0 8a 00 08 	brle	80009c5a <_dtoa_r+0x8da>
80009c4e:	06 9b       	mov	r11,r3
80009c50:	00 9a       	mov	r10,r0
80009c52:	0e 9c       	mov	r12,r7
80009c54:	e0 a0 07 58 	rcall	8000ab04 <__lshift>
80009c58:	18 93       	mov	r3,r12
80009c5a:	40 49       	lddsp	r9,sp[0x10]
80009c5c:	58 09       	cp.w	r9,0
80009c5e:	e0 8a 00 08 	brle	80009c6e <_dtoa_r+0x8ee>
80009c62:	04 9b       	mov	r11,r2
80009c64:	12 9a       	mov	r10,r9
80009c66:	0e 9c       	mov	r12,r7
80009c68:	e0 a0 07 4e 	rcall	8000ab04 <__lshift>
80009c6c:	18 92       	mov	r2,r12
80009c6e:	41 48       	lddsp	r8,sp[0x50]
80009c70:	58 08       	cp.w	r8,0
80009c72:	c1 b0       	breq	80009ca8 <_dtoa_r+0x928>
80009c74:	04 9b       	mov	r11,r2
80009c76:	06 9c       	mov	r12,r3
80009c78:	e0 a0 06 23 	rcall	8000a8be <__mcmp>
80009c7c:	c1 64       	brge	80009ca8 <_dtoa_r+0x928>
80009c7e:	06 9b       	mov	r11,r3
80009c80:	30 09       	mov	r9,0
80009c82:	30 aa       	mov	r10,10
80009c84:	0e 9c       	mov	r12,r7
80009c86:	e0 a0 08 0b 	rcall	8000ac9c <__multadd>
80009c8a:	20 16       	sub	r6,1
80009c8c:	18 93       	mov	r3,r12
80009c8e:	40 dc       	lddsp	r12,sp[0x34]
80009c90:	58 0c       	cp.w	r12,0
80009c92:	c0 31       	brne	80009c98 <_dtoa_r+0x918>
80009c94:	40 91       	lddsp	r1,sp[0x24]
80009c96:	c0 98       	rjmp	80009ca8 <_dtoa_r+0x928>
80009c98:	08 9b       	mov	r11,r4
80009c9a:	40 91       	lddsp	r1,sp[0x24]
80009c9c:	30 09       	mov	r9,0
80009c9e:	30 aa       	mov	r10,10
80009ca0:	0e 9c       	mov	r12,r7
80009ca2:	e0 a0 07 fd 	rcall	8000ac9c <__multadd>
80009ca6:	18 94       	mov	r4,r12
80009ca8:	58 01       	cp.w	r1,0
80009caa:	5f a9       	srle	r9
80009cac:	40 cb       	lddsp	r11,sp[0x30]
80009cae:	58 2b       	cp.w	r11,2
80009cb0:	5f 98       	srgt	r8
80009cb2:	f3 e8 00 08 	and	r8,r9,r8
80009cb6:	c2 50       	breq	80009d00 <_dtoa_r+0x980>
80009cb8:	58 01       	cp.w	r1,0
80009cba:	c1 11       	brne	80009cdc <_dtoa_r+0x95c>
80009cbc:	04 9b       	mov	r11,r2
80009cbe:	02 99       	mov	r9,r1
80009cc0:	30 5a       	mov	r10,5
80009cc2:	0e 9c       	mov	r12,r7
80009cc4:	e0 a0 07 ec 	rcall	8000ac9c <__multadd>
80009cc8:	18 92       	mov	r2,r12
80009cca:	18 9b       	mov	r11,r12
80009ccc:	06 9c       	mov	r12,r3
80009cce:	e0 a0 05 f8 	rcall	8000a8be <__mcmp>
80009cd2:	e0 89 00 0f 	brgt	80009cf0 <_dtoa_r+0x970>
80009cd6:	c0 38       	rjmp	80009cdc <_dtoa_r+0x95c>
80009cd8:	30 02       	mov	r2,0
80009cda:	04 94       	mov	r4,r2
80009cdc:	40 ea       	lddsp	r10,sp[0x38]
80009cde:	30 09       	mov	r9,0
80009ce0:	5c da       	com	r10
80009ce2:	40 85       	lddsp	r5,sp[0x20]
80009ce4:	50 6a       	stdsp	sp[0x18],r10
80009ce6:	50 49       	stdsp	sp[0x10],r9
80009ce8:	c0 f9       	rjmp	80009f06 <_dtoa_r+0xb86>
80009cea:	08 92       	mov	r2,r4
80009cec:	40 66       	lddsp	r6,sp[0x18]
80009cee:	04 94       	mov	r4,r2
80009cf0:	2f f6       	sub	r6,-1
80009cf2:	50 66       	stdsp	sp[0x18],r6
80009cf4:	33 18       	mov	r8,49
80009cf6:	40 85       	lddsp	r5,sp[0x20]
80009cf8:	0a c8       	st.b	r5++,r8
80009cfa:	30 08       	mov	r8,0
80009cfc:	50 48       	stdsp	sp[0x10],r8
80009cfe:	c0 49       	rjmp	80009f06 <_dtoa_r+0xb86>
80009d00:	40 dc       	lddsp	r12,sp[0x34]
80009d02:	58 0c       	cp.w	r12,0
80009d04:	e0 80 00 b5 	breq	80009e6e <_dtoa_r+0xaee>
80009d08:	58 05       	cp.w	r5,0
80009d0a:	e0 8a 00 08 	brle	80009d1a <_dtoa_r+0x99a>
80009d0e:	08 9b       	mov	r11,r4
80009d10:	0a 9a       	mov	r10,r5
80009d12:	0e 9c       	mov	r12,r7
80009d14:	e0 a0 06 f8 	rcall	8000ab04 <__lshift>
80009d18:	18 94       	mov	r4,r12
80009d1a:	40 6b       	lddsp	r11,sp[0x18]
80009d1c:	58 0b       	cp.w	r11,0
80009d1e:	c0 31       	brne	80009d24 <_dtoa_r+0x9a4>
80009d20:	08 9c       	mov	r12,r4
80009d22:	c1 38       	rjmp	80009d48 <_dtoa_r+0x9c8>
80009d24:	68 1b       	ld.w	r11,r4[0x4]
80009d26:	0e 9c       	mov	r12,r7
80009d28:	e0 a0 05 fe 	rcall	8000a924 <_Balloc>
80009d2c:	68 4a       	ld.w	r10,r4[0x10]
80009d2e:	18 95       	mov	r5,r12
80009d30:	e8 cb ff f4 	sub	r11,r4,-12
80009d34:	2f ea       	sub	r10,-2
80009d36:	2f 4c       	sub	r12,-12
80009d38:	a3 6a       	lsl	r10,0x2
80009d3a:	fe b0 e6 50 	rcall	800069da <memcpy>
80009d3e:	0a 9b       	mov	r11,r5
80009d40:	30 1a       	mov	r10,1
80009d42:	0e 9c       	mov	r12,r7
80009d44:	e0 a0 06 e0 	rcall	8000ab04 <__lshift>
80009d48:	50 44       	stdsp	sp[0x10],r4
80009d4a:	40 3a       	lddsp	r10,sp[0xc]
80009d4c:	30 19       	mov	r9,1
80009d4e:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
80009d52:	18 94       	mov	r4,r12
80009d54:	50 da       	stdsp	sp[0x34],r10
80009d56:	40 85       	lddsp	r5,sp[0x20]
80009d58:	50 99       	stdsp	sp[0x24],r9
80009d5a:	50 26       	stdsp	sp[0x8],r6
80009d5c:	50 e1       	stdsp	sp[0x38],r1
80009d5e:	04 9b       	mov	r11,r2
80009d60:	06 9c       	mov	r12,r3
80009d62:	fe b0 fa 7f 	rcall	80009260 <quorem>
80009d66:	40 4b       	lddsp	r11,sp[0x10]
80009d68:	f8 c0 ff d0 	sub	r0,r12,-48
80009d6c:	06 9c       	mov	r12,r3
80009d6e:	e0 a0 05 a8 	rcall	8000a8be <__mcmp>
80009d72:	08 9a       	mov	r10,r4
80009d74:	50 6c       	stdsp	sp[0x18],r12
80009d76:	04 9b       	mov	r11,r2
80009d78:	0e 9c       	mov	r12,r7
80009d7a:	e0 a0 06 5d 	rcall	8000aa34 <__mdiff>
80009d7e:	18 91       	mov	r1,r12
80009d80:	78 38       	ld.w	r8,r12[0xc]
80009d82:	58 08       	cp.w	r8,0
80009d84:	c0 30       	breq	80009d8a <_dtoa_r+0xa0a>
80009d86:	30 16       	mov	r6,1
80009d88:	c0 68       	rjmp	80009d94 <_dtoa_r+0xa14>
80009d8a:	18 9b       	mov	r11,r12
80009d8c:	06 9c       	mov	r12,r3
80009d8e:	e0 a0 05 98 	rcall	8000a8be <__mcmp>
80009d92:	18 96       	mov	r6,r12
80009d94:	0e 9c       	mov	r12,r7
80009d96:	02 9b       	mov	r11,r1
80009d98:	e0 a0 05 ac 	rcall	8000a8f0 <_Bfree>
80009d9c:	40 cc       	lddsp	r12,sp[0x30]
80009d9e:	ed ec 10 08 	or	r8,r6,r12
80009da2:	c0 d1       	brne	80009dbc <_dtoa_r+0xa3c>
80009da4:	40 db       	lddsp	r11,sp[0x34]
80009da6:	58 0b       	cp.w	r11,0
80009da8:	c0 a1       	brne	80009dbc <_dtoa_r+0xa3c>
80009daa:	40 26       	lddsp	r6,sp[0x8]
80009dac:	e0 40 00 39 	cp.w	r0,57
80009db0:	c3 00       	breq	80009e10 <_dtoa_r+0xa90>
80009db2:	40 6a       	lddsp	r10,sp[0x18]
80009db4:	58 0a       	cp.w	r10,0
80009db6:	e0 89 00 24 	brgt	80009dfe <_dtoa_r+0xa7e>
80009dba:	c2 f8       	rjmp	80009e18 <_dtoa_r+0xa98>
80009dbc:	40 69       	lddsp	r9,sp[0x18]
80009dbe:	58 09       	cp.w	r9,0
80009dc0:	c0 85       	brlt	80009dd0 <_dtoa_r+0xa50>
80009dc2:	12 98       	mov	r8,r9
80009dc4:	40 cc       	lddsp	r12,sp[0x30]
80009dc6:	18 48       	or	r8,r12
80009dc8:	c1 d1       	brne	80009e02 <_dtoa_r+0xa82>
80009dca:	40 db       	lddsp	r11,sp[0x34]
80009dcc:	58 0b       	cp.w	r11,0
80009dce:	c1 a1       	brne	80009e02 <_dtoa_r+0xa82>
80009dd0:	0c 99       	mov	r9,r6
80009dd2:	40 26       	lddsp	r6,sp[0x8]
80009dd4:	58 09       	cp.w	r9,0
80009dd6:	e0 8a 00 21 	brle	80009e18 <_dtoa_r+0xa98>
80009dda:	06 9b       	mov	r11,r3
80009ddc:	30 1a       	mov	r10,1
80009dde:	0e 9c       	mov	r12,r7
80009de0:	e0 a0 06 92 	rcall	8000ab04 <__lshift>
80009de4:	04 9b       	mov	r11,r2
80009de6:	18 93       	mov	r3,r12
80009de8:	e0 a0 05 6b 	rcall	8000a8be <__mcmp>
80009dec:	e0 89 00 06 	brgt	80009df8 <_dtoa_r+0xa78>
80009df0:	c1 41       	brne	80009e18 <_dtoa_r+0xa98>
80009df2:	ed b0 00 00 	bld	r0,0x0
80009df6:	c1 11       	brne	80009e18 <_dtoa_r+0xa98>
80009df8:	e0 40 00 39 	cp.w	r0,57
80009dfc:	c0 a0       	breq	80009e10 <_dtoa_r+0xa90>
80009dfe:	2f f0       	sub	r0,-1
80009e00:	c0 c8       	rjmp	80009e18 <_dtoa_r+0xa98>
80009e02:	58 06       	cp.w	r6,0
80009e04:	e0 8a 00 0c 	brle	80009e1c <_dtoa_r+0xa9c>
80009e08:	40 26       	lddsp	r6,sp[0x8]
80009e0a:	e0 40 00 39 	cp.w	r0,57
80009e0e:	c0 41       	brne	80009e16 <_dtoa_r+0xa96>
80009e10:	33 98       	mov	r8,57
80009e12:	0a c8       	st.b	r5++,r8
80009e14:	c6 78       	rjmp	80009ee2 <_dtoa_r+0xb62>
80009e16:	2f f0       	sub	r0,-1
80009e18:	0a c0       	st.b	r5++,r0
80009e1a:	c7 58       	rjmp	80009f04 <_dtoa_r+0xb84>
80009e1c:	0a c0       	st.b	r5++,r0
80009e1e:	40 9a       	lddsp	r10,sp[0x24]
80009e20:	40 e9       	lddsp	r9,sp[0x38]
80009e22:	12 3a       	cp.w	r10,r9
80009e24:	c4 30       	breq	80009eaa <_dtoa_r+0xb2a>
80009e26:	06 9b       	mov	r11,r3
80009e28:	30 09       	mov	r9,0
80009e2a:	30 aa       	mov	r10,10
80009e2c:	0e 9c       	mov	r12,r7
80009e2e:	e0 a0 07 37 	rcall	8000ac9c <__multadd>
80009e32:	40 48       	lddsp	r8,sp[0x10]
80009e34:	18 93       	mov	r3,r12
80009e36:	08 38       	cp.w	r8,r4
80009e38:	c0 91       	brne	80009e4a <_dtoa_r+0xaca>
80009e3a:	10 9b       	mov	r11,r8
80009e3c:	30 09       	mov	r9,0
80009e3e:	30 aa       	mov	r10,10
80009e40:	0e 9c       	mov	r12,r7
80009e42:	e0 a0 07 2d 	rcall	8000ac9c <__multadd>
80009e46:	50 4c       	stdsp	sp[0x10],r12
80009e48:	c0 e8       	rjmp	80009e64 <_dtoa_r+0xae4>
80009e4a:	40 4b       	lddsp	r11,sp[0x10]
80009e4c:	30 09       	mov	r9,0
80009e4e:	30 aa       	mov	r10,10
80009e50:	0e 9c       	mov	r12,r7
80009e52:	e0 a0 07 25 	rcall	8000ac9c <__multadd>
80009e56:	08 9b       	mov	r11,r4
80009e58:	50 4c       	stdsp	sp[0x10],r12
80009e5a:	30 09       	mov	r9,0
80009e5c:	30 aa       	mov	r10,10
80009e5e:	0e 9c       	mov	r12,r7
80009e60:	e0 a0 07 1e 	rcall	8000ac9c <__multadd>
80009e64:	18 94       	mov	r4,r12
80009e66:	40 9c       	lddsp	r12,sp[0x24]
80009e68:	2f fc       	sub	r12,-1
80009e6a:	50 9c       	stdsp	sp[0x24],r12
80009e6c:	c7 9b       	rjmp	80009d5e <_dtoa_r+0x9de>
80009e6e:	30 18       	mov	r8,1
80009e70:	06 90       	mov	r0,r3
80009e72:	40 85       	lddsp	r5,sp[0x20]
80009e74:	08 93       	mov	r3,r4
80009e76:	0c 94       	mov	r4,r6
80009e78:	10 96       	mov	r6,r8
80009e7a:	04 9b       	mov	r11,r2
80009e7c:	00 9c       	mov	r12,r0
80009e7e:	fe b0 f9 f1 	rcall	80009260 <quorem>
80009e82:	2d 0c       	sub	r12,-48
80009e84:	0a cc       	st.b	r5++,r12
80009e86:	02 36       	cp.w	r6,r1
80009e88:	c0 a4       	brge	80009e9c <_dtoa_r+0xb1c>
80009e8a:	00 9b       	mov	r11,r0
80009e8c:	30 09       	mov	r9,0
80009e8e:	30 aa       	mov	r10,10
80009e90:	0e 9c       	mov	r12,r7
80009e92:	2f f6       	sub	r6,-1
80009e94:	e0 a0 07 04 	rcall	8000ac9c <__multadd>
80009e98:	18 90       	mov	r0,r12
80009e9a:	cf 0b       	rjmp	80009e7a <_dtoa_r+0xafa>
80009e9c:	08 96       	mov	r6,r4
80009e9e:	30 0b       	mov	r11,0
80009ea0:	06 94       	mov	r4,r3
80009ea2:	50 4b       	stdsp	sp[0x10],r11
80009ea4:	00 93       	mov	r3,r0
80009ea6:	18 90       	mov	r0,r12
80009ea8:	c0 28       	rjmp	80009eac <_dtoa_r+0xb2c>
80009eaa:	40 26       	lddsp	r6,sp[0x8]
80009eac:	06 9b       	mov	r11,r3
80009eae:	30 1a       	mov	r10,1
80009eb0:	0e 9c       	mov	r12,r7
80009eb2:	e0 a0 06 29 	rcall	8000ab04 <__lshift>
80009eb6:	04 9b       	mov	r11,r2
80009eb8:	18 93       	mov	r3,r12
80009eba:	e0 a0 05 02 	rcall	8000a8be <__mcmp>
80009ebe:	e0 89 00 12 	brgt	80009ee2 <_dtoa_r+0xb62>
80009ec2:	c1 b1       	brne	80009ef8 <_dtoa_r+0xb78>
80009ec4:	e1 d0 c0 01 	bfextu	r0,r0,0x0,0x1
80009ec8:	c0 d1       	brne	80009ee2 <_dtoa_r+0xb62>
80009eca:	c1 78       	rjmp	80009ef8 <_dtoa_r+0xb78>
80009ecc:	40 89       	lddsp	r9,sp[0x20]
80009ece:	12 38       	cp.w	r8,r9
80009ed0:	c0 30       	breq	80009ed6 <_dtoa_r+0xb56>
80009ed2:	10 95       	mov	r5,r8
80009ed4:	c0 88       	rjmp	80009ee4 <_dtoa_r+0xb64>
80009ed6:	2f f6       	sub	r6,-1
80009ed8:	50 66       	stdsp	sp[0x18],r6
80009eda:	33 18       	mov	r8,49
80009edc:	40 8c       	lddsp	r12,sp[0x20]
80009ede:	b8 88       	st.b	r12[0x0],r8
80009ee0:	c1 38       	rjmp	80009f06 <_dtoa_r+0xb86>
80009ee2:	33 9a       	mov	r10,57
80009ee4:	0a 98       	mov	r8,r5
80009ee6:	11 79       	ld.ub	r9,--r8
80009ee8:	f4 09 18 00 	cp.b	r9,r10
80009eec:	cf 00       	breq	80009ecc <_dtoa_r+0xb4c>
80009eee:	2f f9       	sub	r9,-1
80009ef0:	b0 89       	st.b	r8[0x0],r9
80009ef2:	c0 98       	rjmp	80009f04 <_dtoa_r+0xb84>
80009ef4:	10 95       	mov	r5,r8
80009ef6:	c0 28       	rjmp	80009efa <_dtoa_r+0xb7a>
80009ef8:	33 09       	mov	r9,48
80009efa:	0a 98       	mov	r8,r5
80009efc:	11 7a       	ld.ub	r10,--r8
80009efe:	f2 0a 18 00 	cp.b	r10,r9
80009f02:	cf 90       	breq	80009ef4 <_dtoa_r+0xb74>
80009f04:	50 66       	stdsp	sp[0x18],r6
80009f06:	04 9b       	mov	r11,r2
80009f08:	0e 9c       	mov	r12,r7
80009f0a:	e0 a0 04 f3 	rcall	8000a8f0 <_Bfree>
80009f0e:	58 04       	cp.w	r4,0
80009f10:	c1 20       	breq	80009f34 <_dtoa_r+0xbb4>
80009f12:	40 4b       	lddsp	r11,sp[0x10]
80009f14:	08 3b       	cp.w	r11,r4
80009f16:	5f 19       	srne	r9
80009f18:	58 0b       	cp.w	r11,0
80009f1a:	5f 18       	srne	r8
80009f1c:	f3 e8 00 08 	and	r8,r9,r8
80009f20:	c0 40       	breq	80009f28 <_dtoa_r+0xba8>
80009f22:	0e 9c       	mov	r12,r7
80009f24:	e0 a0 04 e6 	rcall	8000a8f0 <_Bfree>
80009f28:	08 9b       	mov	r11,r4
80009f2a:	0e 9c       	mov	r12,r7
80009f2c:	e0 a0 04 e2 	rcall	8000a8f0 <_Bfree>
80009f30:	c0 28       	rjmp	80009f34 <_dtoa_r+0xbb4>
80009f32:	50 66       	stdsp	sp[0x18],r6
80009f34:	0e 9c       	mov	r12,r7
80009f36:	06 9b       	mov	r11,r3
80009f38:	e0 a0 04 dc 	rcall	8000a8f0 <_Bfree>
80009f3c:	30 08       	mov	r8,0
80009f3e:	aa 88       	st.b	r5[0x0],r8
80009f40:	40 68       	lddsp	r8,sp[0x18]
80009f42:	41 5a       	lddsp	r10,sp[0x54]
80009f44:	2f f8       	sub	r8,-1
80009f46:	41 29       	lddsp	r9,sp[0x48]
80009f48:	95 08       	st.w	r10[0x0],r8
80009f4a:	40 8c       	lddsp	r12,sp[0x20]
80009f4c:	58 09       	cp.w	r9,0
80009f4e:	fb f8 10 12 	ld.wne	r8,sp[0x48]
80009f52:	f1 f5 1a 00 	st.wne	r8[0x0],r5
80009f56:	2e 6d       	sub	sp,-104
80009f58:	d8 32       	popm	r0-r7,pc
80009f5a:	d7 03       	nop

80009f5c <__errno>:
80009f5c:	e0 68 0a 20 	mov	r8,2592
80009f60:	70 0c       	ld.w	r12,r8[0x0]
80009f62:	2f 4c       	sub	r12,-12
80009f64:	5e fc       	retal	r12
80009f66:	d7 03       	nop

80009f68 <_fflush_r>:
80009f68:	d4 21       	pushm	r4-r7,lr
80009f6a:	16 97       	mov	r7,r11
80009f6c:	18 96       	mov	r6,r12
80009f6e:	76 48       	ld.w	r8,r11[0x10]
80009f70:	58 08       	cp.w	r8,0
80009f72:	c7 f0       	breq	8000a070 <_fflush_r+0x108>
80009f74:	58 0c       	cp.w	r12,0
80009f76:	c0 50       	breq	80009f80 <_fflush_r+0x18>
80009f78:	78 68       	ld.w	r8,r12[0x18]
80009f7a:	58 08       	cp.w	r8,0
80009f7c:	c0 21       	brne	80009f80 <_fflush_r+0x18>
80009f7e:	cc dc       	rcall	8000a118 <__sinit>
80009f80:	fe c8 cc c4 	sub	r8,pc,-13116
80009f84:	10 37       	cp.w	r7,r8
80009f86:	c0 31       	brne	80009f8c <_fflush_r+0x24>
80009f88:	6c 07       	ld.w	r7,r6[0x0]
80009f8a:	c0 c8       	rjmp	80009fa2 <_fflush_r+0x3a>
80009f8c:	fe c8 cc b0 	sub	r8,pc,-13136
80009f90:	10 37       	cp.w	r7,r8
80009f92:	c0 31       	brne	80009f98 <_fflush_r+0x30>
80009f94:	6c 17       	ld.w	r7,r6[0x4]
80009f96:	c0 68       	rjmp	80009fa2 <_fflush_r+0x3a>
80009f98:	fe c8 cc 9c 	sub	r8,pc,-13156
80009f9c:	10 37       	cp.w	r7,r8
80009f9e:	ed f7 00 02 	ld.weq	r7,r6[0x8]
80009fa2:	8e 6a       	ld.sh	r10,r7[0xc]
80009fa4:	14 98       	mov	r8,r10
80009fa6:	ed ba 00 03 	bld	r10,0x3
80009faa:	c4 20       	breq	8000a02e <_fflush_r+0xc6>
80009fac:	ab ba       	sbr	r10,0xb
80009fae:	ae 6a       	st.h	r7[0xc],r10
80009fb0:	6e 18       	ld.w	r8,r7[0x4]
80009fb2:	58 08       	cp.w	r8,0
80009fb4:	e0 89 00 06 	brgt	80009fc0 <_fflush_r+0x58>
80009fb8:	6f 08       	ld.w	r8,r7[0x40]
80009fba:	58 08       	cp.w	r8,0
80009fbc:	e0 8a 00 5a 	brle	8000a070 <_fflush_r+0x108>
80009fc0:	6e b8       	ld.w	r8,r7[0x2c]
80009fc2:	58 08       	cp.w	r8,0
80009fc4:	c5 60       	breq	8000a070 <_fflush_r+0x108>
80009fc6:	e2 1a 10 00 	andl	r10,0x1000,COH
80009fca:	c0 30       	breq	80009fd0 <_fflush_r+0x68>
80009fcc:	6f 55       	ld.w	r5,r7[0x54]
80009fce:	c0 f8       	rjmp	80009fec <_fflush_r+0x84>
80009fd0:	30 19       	mov	r9,1
80009fd2:	6e 8b       	ld.w	r11,r7[0x20]
80009fd4:	0c 9c       	mov	r12,r6
80009fd6:	5d 18       	icall	r8
80009fd8:	18 95       	mov	r5,r12
80009fda:	5b fc       	cp.w	r12,-1
80009fdc:	c0 81       	brne	80009fec <_fflush_r+0x84>
80009fde:	6c 38       	ld.w	r8,r6[0xc]
80009fe0:	59 d8       	cp.w	r8,29
80009fe2:	c4 70       	breq	8000a070 <_fflush_r+0x108>
80009fe4:	8e 68       	ld.sh	r8,r7[0xc]
80009fe6:	a7 a8       	sbr	r8,0x6
80009fe8:	ae 68       	st.h	r7[0xc],r8
80009fea:	d8 22       	popm	r4-r7,pc
80009fec:	8e 68       	ld.sh	r8,r7[0xc]
80009fee:	ed b8 00 02 	bld	r8,0x2
80009ff2:	c0 91       	brne	8000a004 <_fflush_r+0x9c>
80009ff4:	6e 18       	ld.w	r8,r7[0x4]
80009ff6:	10 15       	sub	r5,r8
80009ff8:	6e d8       	ld.w	r8,r7[0x34]
80009ffa:	58 08       	cp.w	r8,0
80009ffc:	ef f8 10 10 	ld.wne	r8,r7[0x40]
8000a000:	eb d8 e1 15 	subne	r5,r5,r8
8000a004:	6e b8       	ld.w	r8,r7[0x2c]
8000a006:	0c 9c       	mov	r12,r6
8000a008:	30 09       	mov	r9,0
8000a00a:	0a 9a       	mov	r10,r5
8000a00c:	6e 8b       	ld.w	r11,r7[0x20]
8000a00e:	5d 18       	icall	r8
8000a010:	8e 68       	ld.sh	r8,r7[0xc]
8000a012:	0a 3c       	cp.w	r12,r5
8000a014:	c2 61       	brne	8000a060 <_fflush_r+0xf8>
8000a016:	ab d8       	cbr	r8,0xb
8000a018:	30 0c       	mov	r12,0
8000a01a:	6e 49       	ld.w	r9,r7[0x10]
8000a01c:	ae 68       	st.h	r7[0xc],r8
8000a01e:	8f 1c       	st.w	r7[0x4],r12
8000a020:	8f 09       	st.w	r7[0x0],r9
8000a022:	ed b8 00 0c 	bld	r8,0xc
8000a026:	c2 51       	brne	8000a070 <_fflush_r+0x108>
8000a028:	ef 45 00 54 	st.w	r7[84],r5
8000a02c:	d8 22       	popm	r4-r7,pc
8000a02e:	6e 45       	ld.w	r5,r7[0x10]
8000a030:	58 05       	cp.w	r5,0
8000a032:	c1 f0       	breq	8000a070 <_fflush_r+0x108>
8000a034:	6e 04       	ld.w	r4,r7[0x0]
8000a036:	f5 da c0 02 	bfextu	r10,r10,0x0,0x2
8000a03a:	8f 05       	st.w	r7[0x0],r5
8000a03c:	f9 b8 01 00 	movne	r8,0
8000a040:	ef f8 00 05 	ld.weq	r8,r7[0x14]
8000a044:	0a 14       	sub	r4,r5
8000a046:	8f 28       	st.w	r7[0x8],r8
8000a048:	c1 18       	rjmp	8000a06a <_fflush_r+0x102>
8000a04a:	08 99       	mov	r9,r4
8000a04c:	0a 9a       	mov	r10,r5
8000a04e:	6e a8       	ld.w	r8,r7[0x28]
8000a050:	6e 8b       	ld.w	r11,r7[0x20]
8000a052:	0c 9c       	mov	r12,r6
8000a054:	5d 18       	icall	r8
8000a056:	18 14       	sub	r4,r12
8000a058:	58 0c       	cp.w	r12,0
8000a05a:	e0 89 00 07 	brgt	8000a068 <_fflush_r+0x100>
8000a05e:	8e 68       	ld.sh	r8,r7[0xc]
8000a060:	a7 a8       	sbr	r8,0x6
8000a062:	3f fc       	mov	r12,-1
8000a064:	ae 68       	st.h	r7[0xc],r8
8000a066:	d8 22       	popm	r4-r7,pc
8000a068:	18 05       	add	r5,r12
8000a06a:	58 04       	cp.w	r4,0
8000a06c:	fe 99 ff ef 	brgt	8000a04a <_fflush_r+0xe2>
8000a070:	d8 2a       	popm	r4-r7,pc,r12=0
8000a072:	d7 03       	nop

8000a074 <__sfp_lock_acquire>:
8000a074:	5e fc       	retal	r12

8000a076 <__sfp_lock_release>:
8000a076:	5e fc       	retal	r12

8000a078 <_cleanup_r>:
8000a078:	d4 01       	pushm	lr
8000a07a:	fe cb f0 ae 	sub	r11,pc,-3922
8000a07e:	e0 a0 02 f7 	rcall	8000a66c <_fwalk>
8000a082:	d8 02       	popm	pc

8000a084 <__sfmoreglue>:
8000a084:	d4 21       	pushm	r4-r7,lr
8000a086:	16 95       	mov	r5,r11
8000a088:	f6 06 10 5c 	mul	r6,r11,92
8000a08c:	ec cb ff f4 	sub	r11,r6,-12
8000a090:	fe b0 e2 76 	rcall	8000657c <_malloc_r>
8000a094:	18 97       	mov	r7,r12
8000a096:	c0 90       	breq	8000a0a8 <__sfmoreglue+0x24>
8000a098:	99 15       	st.w	r12[0x4],r5
8000a09a:	30 0b       	mov	r11,0
8000a09c:	2f 4c       	sub	r12,-12
8000a09e:	0c 9a       	mov	r10,r6
8000a0a0:	8f 2c       	st.w	r7[0x8],r12
8000a0a2:	8f 0b       	st.w	r7[0x0],r11
8000a0a4:	fe b0 e5 3f 	rcall	80006b22 <memset>
8000a0a8:	0e 9c       	mov	r12,r7
8000a0aa:	d8 22       	popm	r4-r7,pc

8000a0ac <__sfp>:
8000a0ac:	d4 21       	pushm	r4-r7,lr
8000a0ae:	fe c8 cd 8e 	sub	r8,pc,-12914
8000a0b2:	18 96       	mov	r6,r12
8000a0b4:	70 07       	ld.w	r7,r8[0x0]
8000a0b6:	6e 68       	ld.w	r8,r7[0x18]
8000a0b8:	58 08       	cp.w	r8,0
8000a0ba:	c0 31       	brne	8000a0c0 <__sfp+0x14>
8000a0bc:	0e 9c       	mov	r12,r7
8000a0be:	c2 dc       	rcall	8000a118 <__sinit>
8000a0c0:	ee c7 ff 28 	sub	r7,r7,-216
8000a0c4:	30 05       	mov	r5,0
8000a0c6:	6e 2c       	ld.w	r12,r7[0x8]
8000a0c8:	6e 18       	ld.w	r8,r7[0x4]
8000a0ca:	c0 68       	rjmp	8000a0d6 <__sfp+0x2a>
8000a0cc:	98 69       	ld.sh	r9,r12[0xc]
8000a0ce:	ea 09 19 00 	cp.h	r9,r5
8000a0d2:	c1 10       	breq	8000a0f4 <__sfp+0x48>
8000a0d4:	2a 4c       	sub	r12,-92
8000a0d6:	20 18       	sub	r8,1
8000a0d8:	cf a7       	brpl	8000a0cc <__sfp+0x20>
8000a0da:	6e 08       	ld.w	r8,r7[0x0]
8000a0dc:	58 08       	cp.w	r8,0
8000a0de:	c0 61       	brne	8000a0ea <__sfp+0x3e>
8000a0e0:	30 4b       	mov	r11,4
8000a0e2:	0c 9c       	mov	r12,r6
8000a0e4:	cd 0f       	rcall	8000a084 <__sfmoreglue>
8000a0e6:	8f 0c       	st.w	r7[0x0],r12
8000a0e8:	c0 30       	breq	8000a0ee <__sfp+0x42>
8000a0ea:	6e 07       	ld.w	r7,r7[0x0]
8000a0ec:	ce db       	rjmp	8000a0c6 <__sfp+0x1a>
8000a0ee:	30 c8       	mov	r8,12
8000a0f0:	8d 38       	st.w	r6[0xc],r8
8000a0f2:	d8 22       	popm	r4-r7,pc
8000a0f4:	30 08       	mov	r8,0
8000a0f6:	f9 48 00 4c 	st.w	r12[76],r8
8000a0fa:	99 08       	st.w	r12[0x0],r8
8000a0fc:	99 28       	st.w	r12[0x8],r8
8000a0fe:	99 18       	st.w	r12[0x4],r8
8000a100:	99 48       	st.w	r12[0x10],r8
8000a102:	99 58       	st.w	r12[0x14],r8
8000a104:	99 68       	st.w	r12[0x18],r8
8000a106:	99 d8       	st.w	r12[0x34],r8
8000a108:	99 e8       	st.w	r12[0x38],r8
8000a10a:	f9 48 00 48 	st.w	r12[72],r8
8000a10e:	3f f8       	mov	r8,-1
8000a110:	b8 78       	st.h	r12[0xe],r8
8000a112:	30 18       	mov	r8,1
8000a114:	b8 68       	st.h	r12[0xc],r8
8000a116:	d8 22       	popm	r4-r7,pc

8000a118 <__sinit>:
8000a118:	d4 21       	pushm	r4-r7,lr
8000a11a:	18 96       	mov	r6,r12
8000a11c:	78 67       	ld.w	r7,r12[0x18]
8000a11e:	58 07       	cp.w	r7,0
8000a120:	c4 91       	brne	8000a1b2 <__sinit+0x9a>
8000a122:	fe c8 00 aa 	sub	r8,pc,170
8000a126:	30 15       	mov	r5,1
8000a128:	99 a8       	st.w	r12[0x28],r8
8000a12a:	f9 47 00 d8 	st.w	r12[216],r7
8000a12e:	f9 47 00 dc 	st.w	r12[220],r7
8000a132:	f9 47 00 e0 	st.w	r12[224],r7
8000a136:	99 65       	st.w	r12[0x18],r5
8000a138:	cb af       	rcall	8000a0ac <__sfp>
8000a13a:	8d 0c       	st.w	r6[0x0],r12
8000a13c:	0c 9c       	mov	r12,r6
8000a13e:	cb 7f       	rcall	8000a0ac <__sfp>
8000a140:	8d 1c       	st.w	r6[0x4],r12
8000a142:	0c 9c       	mov	r12,r6
8000a144:	cb 4f       	rcall	8000a0ac <__sfp>
8000a146:	6c 09       	ld.w	r9,r6[0x0]
8000a148:	30 48       	mov	r8,4
8000a14a:	93 07       	st.w	r9[0x0],r7
8000a14c:	b2 68       	st.h	r9[0xc],r8
8000a14e:	93 17       	st.w	r9[0x4],r7
8000a150:	93 27       	st.w	r9[0x8],r7
8000a152:	6c 18       	ld.w	r8,r6[0x4]
8000a154:	b2 77       	st.h	r9[0xe],r7
8000a156:	93 47       	st.w	r9[0x10],r7
8000a158:	93 57       	st.w	r9[0x14],r7
8000a15a:	93 67       	st.w	r9[0x18],r7
8000a15c:	93 89       	st.w	r9[0x20],r9
8000a15e:	91 07       	st.w	r8[0x0],r7
8000a160:	91 17       	st.w	r8[0x4],r7
8000a162:	91 27       	st.w	r8[0x8],r7
8000a164:	fe ce f3 24 	sub	lr,pc,-3292
8000a168:	fe cb f3 54 	sub	r11,pc,-3244
8000a16c:	93 9e       	st.w	r9[0x24],lr
8000a16e:	93 ab       	st.w	r9[0x28],r11
8000a170:	fe ca f3 7c 	sub	r10,pc,-3204
8000a174:	fe c4 f3 88 	sub	r4,pc,-3192
8000a178:	93 ba       	st.w	r9[0x2c],r10
8000a17a:	93 c4       	st.w	r9[0x30],r4
8000a17c:	30 99       	mov	r9,9
8000a17e:	b0 69       	st.h	r8[0xc],r9
8000a180:	b0 75       	st.h	r8[0xe],r5
8000a182:	91 c4       	st.w	r8[0x30],r4
8000a184:	91 47       	st.w	r8[0x10],r7
8000a186:	91 57       	st.w	r8[0x14],r7
8000a188:	91 67       	st.w	r8[0x18],r7
8000a18a:	91 88       	st.w	r8[0x20],r8
8000a18c:	91 9e       	st.w	r8[0x24],lr
8000a18e:	91 ab       	st.w	r8[0x28],r11
8000a190:	91 ba       	st.w	r8[0x2c],r10
8000a192:	8d 2c       	st.w	r6[0x8],r12
8000a194:	31 28       	mov	r8,18
8000a196:	99 07       	st.w	r12[0x0],r7
8000a198:	b8 68       	st.h	r12[0xc],r8
8000a19a:	99 17       	st.w	r12[0x4],r7
8000a19c:	99 27       	st.w	r12[0x8],r7
8000a19e:	30 28       	mov	r8,2
8000a1a0:	b8 78       	st.h	r12[0xe],r8
8000a1a2:	99 c4       	st.w	r12[0x30],r4
8000a1a4:	99 67       	st.w	r12[0x18],r7
8000a1a6:	99 9e       	st.w	r12[0x24],lr
8000a1a8:	99 ab       	st.w	r12[0x28],r11
8000a1aa:	99 ba       	st.w	r12[0x2c],r10
8000a1ac:	99 47       	st.w	r12[0x10],r7
8000a1ae:	99 57       	st.w	r12[0x14],r7
8000a1b0:	99 8c       	st.w	r12[0x20],r12
8000a1b2:	d8 22       	popm	r4-r7,pc

8000a1b4 <_malloc_trim_r>:
8000a1b4:	d4 21       	pushm	r4-r7,lr
8000a1b6:	16 95       	mov	r5,r11
8000a1b8:	18 97       	mov	r7,r12
8000a1ba:	fe b0 d8 ab 	rcall	80005310 <__malloc_lock>
8000a1be:	e0 64 05 20 	mov	r4,1312
8000a1c2:	68 28       	ld.w	r8,r4[0x8]
8000a1c4:	70 16       	ld.w	r6,r8[0x4]
8000a1c6:	e0 16 ff fc 	andl	r6,0xfffc
8000a1ca:	ec c8 ff 91 	sub	r8,r6,-111
8000a1ce:	f0 05 01 05 	sub	r5,r8,r5
8000a1d2:	e0 15 ff 80 	andl	r5,0xff80
8000a1d6:	ea c5 00 80 	sub	r5,r5,128
8000a1da:	e0 45 00 7f 	cp.w	r5,127
8000a1de:	e0 8a 00 25 	brle	8000a228 <_malloc_trim_r+0x74>
8000a1e2:	30 0b       	mov	r11,0
8000a1e4:	0e 9c       	mov	r12,r7
8000a1e6:	fe b0 e6 05 	rcall	80006df0 <_sbrk_r>
8000a1ea:	68 28       	ld.w	r8,r4[0x8]
8000a1ec:	0c 08       	add	r8,r6
8000a1ee:	10 3c       	cp.w	r12,r8
8000a1f0:	c1 c1       	brne	8000a228 <_malloc_trim_r+0x74>
8000a1f2:	ea 0b 11 00 	rsub	r11,r5,0
8000a1f6:	0e 9c       	mov	r12,r7
8000a1f8:	fe b0 e5 fc 	rcall	80006df0 <_sbrk_r>
8000a1fc:	5b fc       	cp.w	r12,-1
8000a1fe:	c1 91       	brne	8000a230 <_malloc_trim_r+0x7c>
8000a200:	30 0b       	mov	r11,0
8000a202:	0e 9c       	mov	r12,r7
8000a204:	fe b0 e5 f6 	rcall	80006df0 <_sbrk_r>
8000a208:	68 28       	ld.w	r8,r4[0x8]
8000a20a:	f8 08 01 09 	sub	r9,r12,r8
8000a20e:	58 f9       	cp.w	r9,15
8000a210:	e0 8a 00 0c 	brle	8000a228 <_malloc_trim_r+0x74>
8000a214:	a1 a9       	sbr	r9,0x0
8000a216:	91 19       	st.w	r8[0x4],r9
8000a218:	e0 68 09 2c 	mov	r8,2348
8000a21c:	70 09       	ld.w	r9,r8[0x0]
8000a21e:	e0 68 0c e8 	mov	r8,3304
8000a222:	f8 09 01 09 	sub	r9,r12,r9
8000a226:	91 09       	st.w	r8[0x0],r9
8000a228:	0e 9c       	mov	r12,r7
8000a22a:	fe b0 d8 79 	rcall	8000531c <__malloc_unlock>
8000a22e:	d8 2a       	popm	r4-r7,pc,r12=0
8000a230:	68 28       	ld.w	r8,r4[0x8]
8000a232:	0a 16       	sub	r6,r5
8000a234:	a1 a6       	sbr	r6,0x0
8000a236:	91 16       	st.w	r8[0x4],r6
8000a238:	e0 68 0c e8 	mov	r8,3304
8000a23c:	70 09       	ld.w	r9,r8[0x0]
8000a23e:	0a 19       	sub	r9,r5
8000a240:	0e 9c       	mov	r12,r7
8000a242:	91 09       	st.w	r8[0x0],r9
8000a244:	fe b0 d8 6c 	rcall	8000531c <__malloc_unlock>
8000a248:	da 2a       	popm	r4-r7,pc,r12=1
8000a24a:	d7 03       	nop

8000a24c <_free_r>:
8000a24c:	d4 21       	pushm	r4-r7,lr
8000a24e:	16 96       	mov	r6,r11
8000a250:	18 97       	mov	r7,r12
8000a252:	58 0b       	cp.w	r11,0
8000a254:	e0 80 00 c0 	breq	8000a3d4 <_free_r+0x188>
8000a258:	fe b0 d8 5c 	rcall	80005310 <__malloc_lock>
8000a25c:	20 86       	sub	r6,8
8000a25e:	e0 6a 05 20 	mov	r10,1312
8000a262:	6c 18       	ld.w	r8,r6[0x4]
8000a264:	74 2e       	ld.w	lr,r10[0x8]
8000a266:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
8000a26a:	a1 c8       	cbr	r8,0x0
8000a26c:	ec 08 00 09 	add	r9,r6,r8
8000a270:	72 1b       	ld.w	r11,r9[0x4]
8000a272:	e0 1b ff fc 	andl	r11,0xfffc
8000a276:	1c 39       	cp.w	r9,lr
8000a278:	c1 e1       	brne	8000a2b4 <_free_r+0x68>
8000a27a:	f6 08 00 08 	add	r8,r11,r8
8000a27e:	58 0c       	cp.w	r12,0
8000a280:	c0 81       	brne	8000a290 <_free_r+0x44>
8000a282:	6c 09       	ld.w	r9,r6[0x0]
8000a284:	12 16       	sub	r6,r9
8000a286:	12 08       	add	r8,r9
8000a288:	6c 3b       	ld.w	r11,r6[0xc]
8000a28a:	6c 29       	ld.w	r9,r6[0x8]
8000a28c:	97 29       	st.w	r11[0x8],r9
8000a28e:	93 3b       	st.w	r9[0xc],r11
8000a290:	10 99       	mov	r9,r8
8000a292:	95 26       	st.w	r10[0x8],r6
8000a294:	a1 a9       	sbr	r9,0x0
8000a296:	8d 19       	st.w	r6[0x4],r9
8000a298:	e0 69 09 28 	mov	r9,2344
8000a29c:	72 09       	ld.w	r9,r9[0x0]
8000a29e:	12 38       	cp.w	r8,r9
8000a2a0:	c0 63       	brcs	8000a2ac <_free_r+0x60>
8000a2a2:	e0 68 0c e4 	mov	r8,3300
8000a2a6:	0e 9c       	mov	r12,r7
8000a2a8:	70 0b       	ld.w	r11,r8[0x0]
8000a2aa:	c8 5f       	rcall	8000a1b4 <_malloc_trim_r>
8000a2ac:	0e 9c       	mov	r12,r7
8000a2ae:	fe b0 d8 37 	rcall	8000531c <__malloc_unlock>
8000a2b2:	d8 22       	popm	r4-r7,pc
8000a2b4:	93 1b       	st.w	r9[0x4],r11
8000a2b6:	58 0c       	cp.w	r12,0
8000a2b8:	c0 30       	breq	8000a2be <_free_r+0x72>
8000a2ba:	30 0c       	mov	r12,0
8000a2bc:	c1 08       	rjmp	8000a2dc <_free_r+0x90>
8000a2be:	6c 0e       	ld.w	lr,r6[0x0]
8000a2c0:	f4 c5 ff f8 	sub	r5,r10,-8
8000a2c4:	1c 16       	sub	r6,lr
8000a2c6:	1c 08       	add	r8,lr
8000a2c8:	6c 2e       	ld.w	lr,r6[0x8]
8000a2ca:	0a 3e       	cp.w	lr,r5
8000a2cc:	f9 bc 00 01 	moveq	r12,1
8000a2d0:	ed f5 10 03 	ld.wne	r5,r6[0xc]
8000a2d4:	eb fe 1a 02 	st.wne	r5[0x8],lr
8000a2d8:	fd f5 1a 03 	st.wne	lr[0xc],r5
8000a2dc:	f2 0b 00 0e 	add	lr,r9,r11
8000a2e0:	7c 1e       	ld.w	lr,lr[0x4]
8000a2e2:	ed be 00 00 	bld	lr,0x0
8000a2e6:	c1 40       	breq	8000a30e <_free_r+0xc2>
8000a2e8:	16 08       	add	r8,r11
8000a2ea:	58 0c       	cp.w	r12,0
8000a2ec:	c0 d1       	brne	8000a306 <_free_r+0xba>
8000a2ee:	e0 6e 05 20 	mov	lr,1312
8000a2f2:	72 2b       	ld.w	r11,r9[0x8]
8000a2f4:	2f 8e       	sub	lr,-8
8000a2f6:	1c 3b       	cp.w	r11,lr
8000a2f8:	c0 71       	brne	8000a306 <_free_r+0xba>
8000a2fa:	97 36       	st.w	r11[0xc],r6
8000a2fc:	97 26       	st.w	r11[0x8],r6
8000a2fe:	8d 2b       	st.w	r6[0x8],r11
8000a300:	8d 3b       	st.w	r6[0xc],r11
8000a302:	30 1c       	mov	r12,1
8000a304:	c0 58       	rjmp	8000a30e <_free_r+0xc2>
8000a306:	72 2b       	ld.w	r11,r9[0x8]
8000a308:	72 39       	ld.w	r9,r9[0xc]
8000a30a:	93 2b       	st.w	r9[0x8],r11
8000a30c:	97 39       	st.w	r11[0xc],r9
8000a30e:	10 99       	mov	r9,r8
8000a310:	ec 08 09 08 	st.w	r6[r8],r8
8000a314:	a1 a9       	sbr	r9,0x0
8000a316:	8d 19       	st.w	r6[0x4],r9
8000a318:	58 0c       	cp.w	r12,0
8000a31a:	c5 a1       	brne	8000a3ce <_free_r+0x182>
8000a31c:	e0 48 01 ff 	cp.w	r8,511
8000a320:	e0 8b 00 13 	brhi	8000a346 <_free_r+0xfa>
8000a324:	a3 98       	lsr	r8,0x3
8000a326:	f4 08 00 39 	add	r9,r10,r8<<0x3
8000a32a:	72 2b       	ld.w	r11,r9[0x8]
8000a32c:	8d 39       	st.w	r6[0xc],r9
8000a32e:	8d 2b       	st.w	r6[0x8],r11
8000a330:	97 36       	st.w	r11[0xc],r6
8000a332:	93 26       	st.w	r9[0x8],r6
8000a334:	a3 48       	asr	r8,0x2
8000a336:	74 19       	ld.w	r9,r10[0x4]
8000a338:	30 1b       	mov	r11,1
8000a33a:	f6 08 09 48 	lsl	r8,r11,r8
8000a33e:	f3 e8 10 08 	or	r8,r9,r8
8000a342:	95 18       	st.w	r10[0x4],r8
8000a344:	c4 58       	rjmp	8000a3ce <_free_r+0x182>
8000a346:	f0 0b 16 09 	lsr	r11,r8,0x9
8000a34a:	58 4b       	cp.w	r11,4
8000a34c:	e0 8b 00 06 	brhi	8000a358 <_free_r+0x10c>
8000a350:	f0 0b 16 06 	lsr	r11,r8,0x6
8000a354:	2c 8b       	sub	r11,-56
8000a356:	c2 08       	rjmp	8000a396 <_free_r+0x14a>
8000a358:	59 4b       	cp.w	r11,20
8000a35a:	e0 8b 00 04 	brhi	8000a362 <_free_r+0x116>
8000a35e:	2a 5b       	sub	r11,-91
8000a360:	c1 b8       	rjmp	8000a396 <_free_r+0x14a>
8000a362:	e0 4b 00 54 	cp.w	r11,84
8000a366:	e0 8b 00 06 	brhi	8000a372 <_free_r+0x126>
8000a36a:	f0 0b 16 0c 	lsr	r11,r8,0xc
8000a36e:	29 2b       	sub	r11,-110
8000a370:	c1 38       	rjmp	8000a396 <_free_r+0x14a>
8000a372:	e0 4b 01 54 	cp.w	r11,340
8000a376:	e0 8b 00 06 	brhi	8000a382 <_free_r+0x136>
8000a37a:	f0 0b 16 0f 	lsr	r11,r8,0xf
8000a37e:	28 9b       	sub	r11,-119
8000a380:	c0 b8       	rjmp	8000a396 <_free_r+0x14a>
8000a382:	e0 4b 05 54 	cp.w	r11,1364
8000a386:	e0 88 00 05 	brls	8000a390 <_free_r+0x144>
8000a38a:	37 eb       	mov	r11,126
8000a38c:	c0 58       	rjmp	8000a396 <_free_r+0x14a>
8000a38e:	d7 03       	nop
8000a390:	f0 0b 16 12 	lsr	r11,r8,0x12
8000a394:	28 4b       	sub	r11,-124
8000a396:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
8000a39a:	78 29       	ld.w	r9,r12[0x8]
8000a39c:	18 39       	cp.w	r9,r12
8000a39e:	c0 e1       	brne	8000a3ba <_free_r+0x16e>
8000a3a0:	74 18       	ld.w	r8,r10[0x4]
8000a3a2:	a3 4b       	asr	r11,0x2
8000a3a4:	30 1c       	mov	r12,1
8000a3a6:	f8 0b 09 4b 	lsl	r11,r12,r11
8000a3aa:	f1 eb 10 0b 	or	r11,r8,r11
8000a3ae:	12 98       	mov	r8,r9
8000a3b0:	95 1b       	st.w	r10[0x4],r11
8000a3b2:	c0 a8       	rjmp	8000a3c6 <_free_r+0x17a>
8000a3b4:	72 29       	ld.w	r9,r9[0x8]
8000a3b6:	18 39       	cp.w	r9,r12
8000a3b8:	c0 60       	breq	8000a3c4 <_free_r+0x178>
8000a3ba:	72 1a       	ld.w	r10,r9[0x4]
8000a3bc:	e0 1a ff fc 	andl	r10,0xfffc
8000a3c0:	14 38       	cp.w	r8,r10
8000a3c2:	cf 93       	brcs	8000a3b4 <_free_r+0x168>
8000a3c4:	72 38       	ld.w	r8,r9[0xc]
8000a3c6:	8d 38       	st.w	r6[0xc],r8
8000a3c8:	8d 29       	st.w	r6[0x8],r9
8000a3ca:	93 36       	st.w	r9[0xc],r6
8000a3cc:	91 26       	st.w	r8[0x8],r6
8000a3ce:	0e 9c       	mov	r12,r7
8000a3d0:	fe b0 d7 a6 	rcall	8000531c <__malloc_unlock>
8000a3d4:	d8 22       	popm	r4-r7,pc
8000a3d6:	d7 03       	nop

8000a3d8 <__sfvwrite_r>:
8000a3d8:	d4 31       	pushm	r0-r7,lr
8000a3da:	20 3d       	sub	sp,12
8000a3dc:	14 94       	mov	r4,r10
8000a3de:	18 95       	mov	r5,r12
8000a3e0:	16 97       	mov	r7,r11
8000a3e2:	74 28       	ld.w	r8,r10[0x8]
8000a3e4:	58 08       	cp.w	r8,0
8000a3e6:	e0 80 01 40 	breq	8000a666 <__sfvwrite_r+0x28e>
8000a3ea:	96 68       	ld.sh	r8,r11[0xc]
8000a3ec:	ed b8 00 03 	bld	r8,0x3
8000a3f0:	c0 41       	brne	8000a3f8 <__sfvwrite_r+0x20>
8000a3f2:	76 48       	ld.w	r8,r11[0x10]
8000a3f4:	58 08       	cp.w	r8,0
8000a3f6:	c0 c1       	brne	8000a40e <__sfvwrite_r+0x36>
8000a3f8:	0e 9b       	mov	r11,r7
8000a3fa:	0a 9c       	mov	r12,r5
8000a3fc:	fe b0 f6 c4 	rcall	80009184 <__swsetup_r>
8000a400:	c0 70       	breq	8000a40e <__sfvwrite_r+0x36>
8000a402:	8e 68       	ld.sh	r8,r7[0xc]
8000a404:	a7 a8       	sbr	r8,0x6
8000a406:	ae 68       	st.h	r7[0xc],r8
8000a408:	30 98       	mov	r8,9
8000a40a:	8b 38       	st.w	r5[0xc],r8
8000a40c:	c2 b9       	rjmp	8000a662 <__sfvwrite_r+0x28a>
8000a40e:	8e 63       	ld.sh	r3,r7[0xc]
8000a410:	68 00       	ld.w	r0,r4[0x0]
8000a412:	06 96       	mov	r6,r3
8000a414:	e2 16 00 02 	andl	r6,0x2,COH
8000a418:	c2 10       	breq	8000a45a <__sfvwrite_r+0x82>
8000a41a:	30 03       	mov	r3,0
8000a41c:	e0 62 04 00 	mov	r2,1024
8000a420:	06 96       	mov	r6,r3
8000a422:	c0 48       	rjmp	8000a42a <__sfvwrite_r+0x52>
8000a424:	60 03       	ld.w	r3,r0[0x0]
8000a426:	60 16       	ld.w	r6,r0[0x4]
8000a428:	2f 80       	sub	r0,-8
8000a42a:	58 06       	cp.w	r6,0
8000a42c:	cf c0       	breq	8000a424 <__sfvwrite_r+0x4c>
8000a42e:	e0 46 04 00 	cp.w	r6,1024
8000a432:	ec 09 17 80 	movls	r9,r6
8000a436:	e4 09 17 b0 	movhi	r9,r2
8000a43a:	06 9a       	mov	r10,r3
8000a43c:	6e a8       	ld.w	r8,r7[0x28]
8000a43e:	6e 8b       	ld.w	r11,r7[0x20]
8000a440:	0a 9c       	mov	r12,r5
8000a442:	5d 18       	icall	r8
8000a444:	18 16       	sub	r6,r12
8000a446:	58 0c       	cp.w	r12,0
8000a448:	e0 8a 01 0a 	brle	8000a65c <__sfvwrite_r+0x284>
8000a44c:	68 28       	ld.w	r8,r4[0x8]
8000a44e:	18 18       	sub	r8,r12
8000a450:	89 28       	st.w	r4[0x8],r8
8000a452:	e0 80 01 0a 	breq	8000a666 <__sfvwrite_r+0x28e>
8000a456:	18 03       	add	r3,r12
8000a458:	ce 9b       	rjmp	8000a42a <__sfvwrite_r+0x52>
8000a45a:	e7 d3 c0 01 	bfextu	r3,r3,0x0,0x1
8000a45e:	c0 70       	breq	8000a46c <__sfvwrite_r+0x94>
8000a460:	50 06       	stdsp	sp[0x0],r6
8000a462:	0c 93       	mov	r3,r6
8000a464:	0c 91       	mov	r1,r6
8000a466:	50 15       	stdsp	sp[0x4],r5
8000a468:	08 92       	mov	r2,r4
8000a46a:	c9 c8       	rjmp	8000a5a2 <__sfvwrite_r+0x1ca>
8000a46c:	06 96       	mov	r6,r3
8000a46e:	08 91       	mov	r1,r4
8000a470:	c0 48       	rjmp	8000a478 <__sfvwrite_r+0xa0>
8000a472:	60 03       	ld.w	r3,r0[0x0]
8000a474:	60 16       	ld.w	r6,r0[0x4]
8000a476:	2f 80       	sub	r0,-8
8000a478:	58 06       	cp.w	r6,0
8000a47a:	cf c0       	breq	8000a472 <__sfvwrite_r+0x9a>
8000a47c:	8e 68       	ld.sh	r8,r7[0xc]
8000a47e:	6e 24       	ld.w	r4,r7[0x8]
8000a480:	10 99       	mov	r9,r8
8000a482:	e2 19 02 00 	andl	r9,0x200,COH
8000a486:	c5 50       	breq	8000a530 <__sfvwrite_r+0x158>
8000a488:	08 36       	cp.w	r6,r4
8000a48a:	c4 43       	brcs	8000a512 <__sfvwrite_r+0x13a>
8000a48c:	10 99       	mov	r9,r8
8000a48e:	e2 19 04 80 	andl	r9,0x480,COH
8000a492:	c4 00       	breq	8000a512 <__sfvwrite_r+0x13a>
8000a494:	6e 4b       	ld.w	r11,r7[0x10]
8000a496:	6e 09       	ld.w	r9,r7[0x0]
8000a498:	16 19       	sub	r9,r11
8000a49a:	50 09       	stdsp	sp[0x0],r9
8000a49c:	6e 59       	ld.w	r9,r7[0x14]
8000a49e:	10 9c       	mov	r12,r8
8000a4a0:	f2 09 00 1a 	add	r10,r9,r9<<0x1
8000a4a4:	30 28       	mov	r8,2
8000a4a6:	f4 08 0c 08 	divs	r8,r10,r8
8000a4aa:	fa e9 00 04 	st.d	sp[4],r8
8000a4ae:	10 94       	mov	r4,r8
8000a4b0:	40 09       	lddsp	r9,sp[0x0]
8000a4b2:	e2 1c 04 00 	andl	r12,0x400,COH
8000a4b6:	2f f9       	sub	r9,-1
8000a4b8:	0c 09       	add	r9,r6
8000a4ba:	12 38       	cp.w	r8,r9
8000a4bc:	f2 04 17 30 	movlo	r4,r9
8000a4c0:	58 0c       	cp.w	r12,0
8000a4c2:	c1 10       	breq	8000a4e4 <__sfvwrite_r+0x10c>
8000a4c4:	08 9b       	mov	r11,r4
8000a4c6:	0a 9c       	mov	r12,r5
8000a4c8:	fe b0 e0 5a 	rcall	8000657c <_malloc_r>
8000a4cc:	18 92       	mov	r2,r12
8000a4ce:	c1 40       	breq	8000a4f6 <__sfvwrite_r+0x11e>
8000a4d0:	40 0a       	lddsp	r10,sp[0x0]
8000a4d2:	6e 4b       	ld.w	r11,r7[0x10]
8000a4d4:	fe b0 e2 83 	rcall	800069da <memcpy>
8000a4d8:	8e 68       	ld.sh	r8,r7[0xc]
8000a4da:	e0 18 fb 7f 	andl	r8,0xfb7f
8000a4de:	a7 b8       	sbr	r8,0x7
8000a4e0:	ae 68       	st.h	r7[0xc],r8
8000a4e2:	c0 d8       	rjmp	8000a4fc <__sfvwrite_r+0x124>
8000a4e4:	08 9a       	mov	r10,r4
8000a4e6:	0a 9c       	mov	r12,r5
8000a4e8:	fe b0 e3 24 	rcall	80006b30 <_realloc_r>
8000a4ec:	18 92       	mov	r2,r12
8000a4ee:	c0 71       	brne	8000a4fc <__sfvwrite_r+0x124>
8000a4f0:	6e 4b       	ld.w	r11,r7[0x10]
8000a4f2:	0a 9c       	mov	r12,r5
8000a4f4:	ca ce       	rcall	8000a24c <_free_r>
8000a4f6:	30 c8       	mov	r8,12
8000a4f8:	8b 38       	st.w	r5[0xc],r8
8000a4fa:	cb 18       	rjmp	8000a65c <__sfvwrite_r+0x284>
8000a4fc:	40 0a       	lddsp	r10,sp[0x0]
8000a4fe:	40 09       	lddsp	r9,sp[0x0]
8000a500:	e8 0a 01 0a 	sub	r10,r4,r10
8000a504:	e4 09 00 08 	add	r8,r2,r9
8000a508:	8f 54       	st.w	r7[0x14],r4
8000a50a:	8f 2a       	st.w	r7[0x8],r10
8000a50c:	8f 08       	st.w	r7[0x0],r8
8000a50e:	8f 42       	st.w	r7[0x10],r2
8000a510:	0c 94       	mov	r4,r6
8000a512:	08 36       	cp.w	r6,r4
8000a514:	ec 04 17 30 	movlo	r4,r6
8000a518:	06 9b       	mov	r11,r3
8000a51a:	08 9a       	mov	r10,r4
8000a51c:	6e 0c       	ld.w	r12,r7[0x0]
8000a51e:	c3 ad       	rcall	8000a792 <memmove>
8000a520:	6e 08       	ld.w	r8,r7[0x0]
8000a522:	08 08       	add	r8,r4
8000a524:	8f 08       	st.w	r7[0x0],r8
8000a526:	6e 28       	ld.w	r8,r7[0x8]
8000a528:	08 18       	sub	r8,r4
8000a52a:	0c 94       	mov	r4,r6
8000a52c:	8f 28       	st.w	r7[0x8],r8
8000a52e:	c2 e8       	rjmp	8000a58a <__sfvwrite_r+0x1b2>
8000a530:	08 36       	cp.w	r6,r4
8000a532:	5f ba       	srhi	r10
8000a534:	6e 0c       	ld.w	r12,r7[0x0]
8000a536:	6e 48       	ld.w	r8,r7[0x10]
8000a538:	10 3c       	cp.w	r12,r8
8000a53a:	5f b8       	srhi	r8
8000a53c:	f5 e8 00 08 	and	r8,r10,r8
8000a540:	f2 08 18 00 	cp.b	r8,r9
8000a544:	c0 d0       	breq	8000a55e <__sfvwrite_r+0x186>
8000a546:	06 9b       	mov	r11,r3
8000a548:	08 9a       	mov	r10,r4
8000a54a:	c2 4d       	rcall	8000a792 <memmove>
8000a54c:	6e 08       	ld.w	r8,r7[0x0]
8000a54e:	08 08       	add	r8,r4
8000a550:	0e 9b       	mov	r11,r7
8000a552:	8f 08       	st.w	r7[0x0],r8
8000a554:	0a 9c       	mov	r12,r5
8000a556:	fe b0 fd 09 	rcall	80009f68 <_fflush_r>
8000a55a:	c1 80       	breq	8000a58a <__sfvwrite_r+0x1b2>
8000a55c:	c8 08       	rjmp	8000a65c <__sfvwrite_r+0x284>
8000a55e:	6e 59       	ld.w	r9,r7[0x14]
8000a560:	12 36       	cp.w	r6,r9
8000a562:	c0 a3       	brcs	8000a576 <__sfvwrite_r+0x19e>
8000a564:	6e a8       	ld.w	r8,r7[0x28]
8000a566:	06 9a       	mov	r10,r3
8000a568:	6e 8b       	ld.w	r11,r7[0x20]
8000a56a:	0a 9c       	mov	r12,r5
8000a56c:	5d 18       	icall	r8
8000a56e:	18 94       	mov	r4,r12
8000a570:	e0 89 00 0d 	brgt	8000a58a <__sfvwrite_r+0x1b2>
8000a574:	c7 48       	rjmp	8000a65c <__sfvwrite_r+0x284>
8000a576:	0c 9a       	mov	r10,r6
8000a578:	06 9b       	mov	r11,r3
8000a57a:	c0 cd       	rcall	8000a792 <memmove>
8000a57c:	6e 08       	ld.w	r8,r7[0x0]
8000a57e:	0c 08       	add	r8,r6
8000a580:	0c 94       	mov	r4,r6
8000a582:	8f 08       	st.w	r7[0x0],r8
8000a584:	6e 28       	ld.w	r8,r7[0x8]
8000a586:	0c 18       	sub	r8,r6
8000a588:	8f 28       	st.w	r7[0x8],r8
8000a58a:	62 28       	ld.w	r8,r1[0x8]
8000a58c:	08 18       	sub	r8,r4
8000a58e:	83 28       	st.w	r1[0x8],r8
8000a590:	c6 b0       	breq	8000a666 <__sfvwrite_r+0x28e>
8000a592:	08 16       	sub	r6,r4
8000a594:	08 03       	add	r3,r4
8000a596:	c7 1b       	rjmp	8000a478 <__sfvwrite_r+0xa0>
8000a598:	60 03       	ld.w	r3,r0[0x0]
8000a59a:	60 11       	ld.w	r1,r0[0x4]
8000a59c:	30 08       	mov	r8,0
8000a59e:	2f 80       	sub	r0,-8
8000a5a0:	50 08       	stdsp	sp[0x0],r8
8000a5a2:	58 01       	cp.w	r1,0
8000a5a4:	cf a0       	breq	8000a598 <__sfvwrite_r+0x1c0>
8000a5a6:	40 0a       	lddsp	r10,sp[0x0]
8000a5a8:	58 0a       	cp.w	r10,0
8000a5aa:	c1 41       	brne	8000a5d2 <__sfvwrite_r+0x1fa>
8000a5ac:	e2 c6 ff ff 	sub	r6,r1,-1
8000a5b0:	02 9a       	mov	r10,r1
8000a5b2:	30 ab       	mov	r11,10
8000a5b4:	06 9c       	mov	r12,r3
8000a5b6:	ce 3c       	rcall	8000a77c <memchr>
8000a5b8:	f8 c8 ff ff 	sub	r8,r12,-1
8000a5bc:	58 0c       	cp.w	r12,0
8000a5be:	f1 d3 e1 16 	subne	r6,r8,r3
8000a5c2:	f9 b9 01 01 	movne	r9,1
8000a5c6:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000a5ca:	f9 b8 00 01 	moveq	r8,1
8000a5ce:	fb f8 0a 00 	st.weq	sp[0x0],r8
8000a5d2:	02 36       	cp.w	r6,r1
8000a5d4:	ec 04 17 80 	movls	r4,r6
8000a5d8:	e2 04 17 b0 	movhi	r4,r1
8000a5dc:	6e 59       	ld.w	r9,r7[0x14]
8000a5de:	6e 25       	ld.w	r5,r7[0x8]
8000a5e0:	f2 05 00 05 	add	r5,r9,r5
8000a5e4:	0a 34       	cp.w	r4,r5
8000a5e6:	5f 9a       	srgt	r10
8000a5e8:	6e 0c       	ld.w	r12,r7[0x0]
8000a5ea:	6e 48       	ld.w	r8,r7[0x10]
8000a5ec:	10 3c       	cp.w	r12,r8
8000a5ee:	5f b8       	srhi	r8
8000a5f0:	f5 e8 00 08 	and	r8,r10,r8
8000a5f4:	30 0a       	mov	r10,0
8000a5f6:	f4 08 18 00 	cp.b	r8,r10
8000a5fa:	c0 d0       	breq	8000a614 <__sfvwrite_r+0x23c>
8000a5fc:	06 9b       	mov	r11,r3
8000a5fe:	0a 9a       	mov	r10,r5
8000a600:	cc 9c       	rcall	8000a792 <memmove>
8000a602:	6e 08       	ld.w	r8,r7[0x0]
8000a604:	0a 08       	add	r8,r5
8000a606:	0e 9b       	mov	r11,r7
8000a608:	8f 08       	st.w	r7[0x0],r8
8000a60a:	40 1c       	lddsp	r12,sp[0x4]
8000a60c:	fe b0 fc ae 	rcall	80009f68 <_fflush_r>
8000a610:	c1 70       	breq	8000a63e <__sfvwrite_r+0x266>
8000a612:	c2 58       	rjmp	8000a65c <__sfvwrite_r+0x284>
8000a614:	12 34       	cp.w	r4,r9
8000a616:	c0 a5       	brlt	8000a62a <__sfvwrite_r+0x252>
8000a618:	6e a8       	ld.w	r8,r7[0x28]
8000a61a:	06 9a       	mov	r10,r3
8000a61c:	6e 8b       	ld.w	r11,r7[0x20]
8000a61e:	40 1c       	lddsp	r12,sp[0x4]
8000a620:	5d 18       	icall	r8
8000a622:	18 95       	mov	r5,r12
8000a624:	e0 89 00 0d 	brgt	8000a63e <__sfvwrite_r+0x266>
8000a628:	c1 a8       	rjmp	8000a65c <__sfvwrite_r+0x284>
8000a62a:	08 9a       	mov	r10,r4
8000a62c:	06 9b       	mov	r11,r3
8000a62e:	cb 2c       	rcall	8000a792 <memmove>
8000a630:	6e 08       	ld.w	r8,r7[0x0]
8000a632:	08 08       	add	r8,r4
8000a634:	08 95       	mov	r5,r4
8000a636:	8f 08       	st.w	r7[0x0],r8
8000a638:	6e 28       	ld.w	r8,r7[0x8]
8000a63a:	08 18       	sub	r8,r4
8000a63c:	8f 28       	st.w	r7[0x8],r8
8000a63e:	0a 16       	sub	r6,r5
8000a640:	c0 71       	brne	8000a64e <__sfvwrite_r+0x276>
8000a642:	0e 9b       	mov	r11,r7
8000a644:	40 1c       	lddsp	r12,sp[0x4]
8000a646:	fe b0 fc 91 	rcall	80009f68 <_fflush_r>
8000a64a:	c0 91       	brne	8000a65c <__sfvwrite_r+0x284>
8000a64c:	50 06       	stdsp	sp[0x0],r6
8000a64e:	64 28       	ld.w	r8,r2[0x8]
8000a650:	0a 18       	sub	r8,r5
8000a652:	85 28       	st.w	r2[0x8],r8
8000a654:	c0 90       	breq	8000a666 <__sfvwrite_r+0x28e>
8000a656:	0a 11       	sub	r1,r5
8000a658:	0a 03       	add	r3,r5
8000a65a:	ca 4b       	rjmp	8000a5a2 <__sfvwrite_r+0x1ca>
8000a65c:	8e 68       	ld.sh	r8,r7[0xc]
8000a65e:	a7 a8       	sbr	r8,0x6
8000a660:	ae 68       	st.h	r7[0xc],r8
8000a662:	3f fc       	mov	r12,-1
8000a664:	c0 28       	rjmp	8000a668 <__sfvwrite_r+0x290>
8000a666:	30 0c       	mov	r12,0
8000a668:	2f dd       	sub	sp,-12
8000a66a:	d8 32       	popm	r0-r7,pc

8000a66c <_fwalk>:
8000a66c:	d4 31       	pushm	r0-r7,lr
8000a66e:	30 05       	mov	r5,0
8000a670:	16 91       	mov	r1,r11
8000a672:	f8 c7 ff 28 	sub	r7,r12,-216
8000a676:	0a 92       	mov	r2,r5
8000a678:	fe b0 fc fe 	rcall	8000a074 <__sfp_lock_acquire>
8000a67c:	3f f3       	mov	r3,-1
8000a67e:	c1 68       	rjmp	8000a6aa <_fwalk+0x3e>
8000a680:	6e 26       	ld.w	r6,r7[0x8]
8000a682:	6e 14       	ld.w	r4,r7[0x4]
8000a684:	2f 46       	sub	r6,-12
8000a686:	c0 c8       	rjmp	8000a69e <_fwalk+0x32>
8000a688:	8c 08       	ld.sh	r8,r6[0x0]
8000a68a:	e4 08 19 00 	cp.h	r8,r2
8000a68e:	c0 70       	breq	8000a69c <_fwalk+0x30>
8000a690:	8c 18       	ld.sh	r8,r6[0x2]
8000a692:	e6 08 19 00 	cp.h	r8,r3
8000a696:	c0 30       	breq	8000a69c <_fwalk+0x30>
8000a698:	5d 11       	icall	r1
8000a69a:	18 45       	or	r5,r12
8000a69c:	2a 46       	sub	r6,-92
8000a69e:	20 14       	sub	r4,1
8000a6a0:	ec cc 00 0c 	sub	r12,r6,12
8000a6a4:	58 04       	cp.w	r4,0
8000a6a6:	cf 14       	brge	8000a688 <_fwalk+0x1c>
8000a6a8:	6e 07       	ld.w	r7,r7[0x0]
8000a6aa:	58 07       	cp.w	r7,0
8000a6ac:	ce a1       	brne	8000a680 <_fwalk+0x14>
8000a6ae:	fe b0 fc e4 	rcall	8000a076 <__sfp_lock_release>
8000a6b2:	0a 9c       	mov	r12,r5
8000a6b4:	d8 32       	popm	r0-r7,pc
8000a6b6:	d7 03       	nop

8000a6b8 <_localeconv_r>:
8000a6b8:	fe cc d3 94 	sub	r12,pc,-11372
8000a6bc:	5e fc       	retal	r12
8000a6be:	d7 03       	nop

8000a6c0 <__smakebuf_r>:
8000a6c0:	d4 21       	pushm	r4-r7,lr
8000a6c2:	20 fd       	sub	sp,60
8000a6c4:	96 68       	ld.sh	r8,r11[0xc]
8000a6c6:	16 97       	mov	r7,r11
8000a6c8:	18 96       	mov	r6,r12
8000a6ca:	e2 18 00 02 	andl	r8,0x2,COH
8000a6ce:	c3 d1       	brne	8000a748 <__smakebuf_r+0x88>
8000a6d0:	96 7b       	ld.sh	r11,r11[0xe]
8000a6d2:	f0 0b 19 00 	cp.h	r11,r8
8000a6d6:	c0 55       	brlt	8000a6e0 <__smakebuf_r+0x20>
8000a6d8:	1a 9a       	mov	r10,sp
8000a6da:	e0 a0 04 81 	rcall	8000afdc <_fstat_r>
8000a6de:	c0 f4       	brge	8000a6fc <__smakebuf_r+0x3c>
8000a6e0:	8e 65       	ld.sh	r5,r7[0xc]
8000a6e2:	0a 98       	mov	r8,r5
8000a6e4:	ab b8       	sbr	r8,0xb
8000a6e6:	e2 15 00 80 	andl	r5,0x80,COH
8000a6ea:	ae 68       	st.h	r7[0xc],r8
8000a6ec:	30 04       	mov	r4,0
8000a6ee:	e0 68 04 00 	mov	r8,1024
8000a6f2:	f9 b5 01 40 	movne	r5,64
8000a6f6:	f0 05 17 00 	moveq	r5,r8
8000a6fa:	c1 c8       	rjmp	8000a732 <__smakebuf_r+0x72>
8000a6fc:	40 18       	lddsp	r8,sp[0x4]
8000a6fe:	e2 18 f0 00 	andl	r8,0xf000,COH
8000a702:	e0 48 20 00 	cp.w	r8,8192
8000a706:	5f 04       	sreq	r4
8000a708:	e0 48 80 00 	cp.w	r8,32768
8000a70c:	c0 e1       	brne	8000a728 <__smakebuf_r+0x68>
8000a70e:	6e b9       	ld.w	r9,r7[0x2c]
8000a710:	fe c8 f9 1c 	sub	r8,pc,-1764
8000a714:	10 39       	cp.w	r9,r8
8000a716:	c0 91       	brne	8000a728 <__smakebuf_r+0x68>
8000a718:	8e 68       	ld.sh	r8,r7[0xc]
8000a71a:	e0 65 04 00 	mov	r5,1024
8000a71e:	ab a8       	sbr	r8,0xa
8000a720:	ef 45 00 50 	st.w	r7[80],r5
8000a724:	ae 68       	st.h	r7[0xc],r8
8000a726:	c0 68       	rjmp	8000a732 <__smakebuf_r+0x72>
8000a728:	8e 68       	ld.sh	r8,r7[0xc]
8000a72a:	e0 65 04 00 	mov	r5,1024
8000a72e:	ab b8       	sbr	r8,0xb
8000a730:	ae 68       	st.h	r7[0xc],r8
8000a732:	0a 9b       	mov	r11,r5
8000a734:	0c 9c       	mov	r12,r6
8000a736:	fe b0 df 23 	rcall	8000657c <_malloc_r>
8000a73a:	8e 68       	ld.sh	r8,r7[0xc]
8000a73c:	c0 d1       	brne	8000a756 <__smakebuf_r+0x96>
8000a73e:	ed b8 00 09 	bld	r8,0x9
8000a742:	c1 b0       	breq	8000a778 <__smakebuf_r+0xb8>
8000a744:	a1 b8       	sbr	r8,0x1
8000a746:	ae 68       	st.h	r7[0xc],r8
8000a748:	ee c8 ff b9 	sub	r8,r7,-71
8000a74c:	8f 48       	st.w	r7[0x10],r8
8000a74e:	8f 08       	st.w	r7[0x0],r8
8000a750:	30 18       	mov	r8,1
8000a752:	8f 58       	st.w	r7[0x14],r8
8000a754:	c1 28       	rjmp	8000a778 <__smakebuf_r+0xb8>
8000a756:	a7 b8       	sbr	r8,0x7
8000a758:	8f 4c       	st.w	r7[0x10],r12
8000a75a:	ae 68       	st.h	r7[0xc],r8
8000a75c:	8f 55       	st.w	r7[0x14],r5
8000a75e:	fe c8 06 e6 	sub	r8,pc,1766
8000a762:	8f 0c       	st.w	r7[0x0],r12
8000a764:	8d a8       	st.w	r6[0x28],r8
8000a766:	58 04       	cp.w	r4,0
8000a768:	c0 80       	breq	8000a778 <__smakebuf_r+0xb8>
8000a76a:	8e 7c       	ld.sh	r12,r7[0xe]
8000a76c:	fe b0 e3 94 	rcall	80006e94 <isatty>
8000a770:	c0 40       	breq	8000a778 <__smakebuf_r+0xb8>
8000a772:	8e 68       	ld.sh	r8,r7[0xc]
8000a774:	a1 a8       	sbr	r8,0x0
8000a776:	ae 68       	st.h	r7[0xc],r8
8000a778:	2f 1d       	sub	sp,-60
8000a77a:	d8 22       	popm	r4-r7,pc

8000a77c <memchr>:
8000a77c:	f7 db c0 08 	bfextu	r11,r11,0x0,0x8
8000a780:	c0 68       	rjmp	8000a78c <memchr+0x10>
8000a782:	20 1a       	sub	r10,1
8000a784:	19 88       	ld.ub	r8,r12[0x0]
8000a786:	16 38       	cp.w	r8,r11
8000a788:	5e 0c       	reteq	r12
8000a78a:	2f fc       	sub	r12,-1
8000a78c:	58 0a       	cp.w	r10,0
8000a78e:	cf a1       	brne	8000a782 <memchr+0x6>
8000a790:	5e fa       	retal	r10

8000a792 <memmove>:
8000a792:	d4 01       	pushm	lr
8000a794:	18 3b       	cp.w	r11,r12
8000a796:	c1 92       	brcc	8000a7c8 <memmove+0x36>
8000a798:	f6 0a 00 09 	add	r9,r11,r10
8000a79c:	12 3c       	cp.w	r12,r9
8000a79e:	c1 52       	brcc	8000a7c8 <memmove+0x36>
8000a7a0:	f8 0a 00 0b 	add	r11,r12,r10
8000a7a4:	30 08       	mov	r8,0
8000a7a6:	c0 68       	rjmp	8000a7b2 <memmove+0x20>
8000a7a8:	f2 08 07 0e 	ld.ub	lr,r9[r8]
8000a7ac:	20 1a       	sub	r10,1
8000a7ae:	f6 08 0b 0e 	st.b	r11[r8],lr
8000a7b2:	20 18       	sub	r8,1
8000a7b4:	58 0a       	cp.w	r10,0
8000a7b6:	cf 91       	brne	8000a7a8 <memmove+0x16>
8000a7b8:	d8 02       	popm	pc
8000a7ba:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000a7be:	20 1a       	sub	r10,1
8000a7c0:	f8 08 0b 09 	st.b	r12[r8],r9
8000a7c4:	2f f8       	sub	r8,-1
8000a7c6:	c0 28       	rjmp	8000a7ca <memmove+0x38>
8000a7c8:	30 08       	mov	r8,0
8000a7ca:	58 0a       	cp.w	r10,0
8000a7cc:	cf 71       	brne	8000a7ba <memmove+0x28>
8000a7ce:	d8 02       	popm	pc

8000a7d0 <__hi0bits>:
8000a7d0:	18 98       	mov	r8,r12
8000a7d2:	e0 1c 00 00 	andl	r12,0x0
8000a7d6:	f0 09 15 10 	lsl	r9,r8,0x10
8000a7da:	58 0c       	cp.w	r12,0
8000a7dc:	f2 08 17 00 	moveq	r8,r9
8000a7e0:	f9 bc 00 10 	moveq	r12,16
8000a7e4:	f9 bc 01 00 	movne	r12,0
8000a7e8:	10 9a       	mov	r10,r8
8000a7ea:	f0 09 15 08 	lsl	r9,r8,0x8
8000a7ee:	e6 1a ff 00 	andh	r10,0xff00,COH
8000a7f2:	f7 bc 00 f8 	subeq	r12,-8
8000a7f6:	f2 08 17 00 	moveq	r8,r9
8000a7fa:	10 9a       	mov	r10,r8
8000a7fc:	f0 09 15 04 	lsl	r9,r8,0x4
8000a800:	e6 1a f0 00 	andh	r10,0xf000,COH
8000a804:	f7 bc 00 fc 	subeq	r12,-4
8000a808:	f2 08 17 00 	moveq	r8,r9
8000a80c:	10 9a       	mov	r10,r8
8000a80e:	f0 09 15 02 	lsl	r9,r8,0x2
8000a812:	e6 1a c0 00 	andh	r10,0xc000,COH
8000a816:	f7 bc 00 fe 	subeq	r12,-2
8000a81a:	f2 08 17 00 	moveq	r8,r9
8000a81e:	58 08       	cp.w	r8,0
8000a820:	5e 5c       	retlt	r12
8000a822:	ed b8 00 1e 	bld	r8,0x1e
8000a826:	f9 bc 01 20 	movne	r12,32
8000a82a:	f7 bc 00 ff 	subeq	r12,-1
8000a82e:	5e fc       	retal	r12

8000a830 <__lo0bits>:
8000a830:	18 99       	mov	r9,r12
8000a832:	78 08       	ld.w	r8,r12[0x0]
8000a834:	f9 d8 c0 03 	bfextu	r12,r8,0x0,0x3
8000a838:	c1 50       	breq	8000a862 <__lo0bits+0x32>
8000a83a:	ed b8 00 00 	bld	r8,0x0
8000a83e:	c0 21       	brne	8000a842 <__lo0bits+0x12>
8000a840:	5e fd       	retal	0
8000a842:	10 9b       	mov	r11,r8
8000a844:	f0 0a 16 01 	lsr	r10,r8,0x1
8000a848:	e2 1b 00 02 	andl	r11,0x2,COH
8000a84c:	a3 88       	lsr	r8,0x2
8000a84e:	58 0b       	cp.w	r11,0
8000a850:	f3 fa 1a 00 	st.wne	r9[0x0],r10
8000a854:	f9 bc 01 01 	movne	r12,1
8000a858:	f3 f8 0a 00 	st.weq	r9[0x0],r8
8000a85c:	f9 bc 00 02 	moveq	r12,2
8000a860:	5e fc       	retal	r12
8000a862:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
8000a866:	f0 0b 16 10 	lsr	r11,r8,0x10
8000a86a:	58 0a       	cp.w	r10,0
8000a86c:	f6 08 17 00 	moveq	r8,r11
8000a870:	f9 bc 00 10 	moveq	r12,16
8000a874:	f7 d8 c0 08 	bfextu	r11,r8,0x0,0x8
8000a878:	f0 0a 16 08 	lsr	r10,r8,0x8
8000a87c:	58 0b       	cp.w	r11,0
8000a87e:	f7 bc 00 f8 	subeq	r12,-8
8000a882:	f4 08 17 00 	moveq	r8,r10
8000a886:	f7 d8 c0 04 	bfextu	r11,r8,0x0,0x4
8000a88a:	f0 0a 16 04 	lsr	r10,r8,0x4
8000a88e:	58 0b       	cp.w	r11,0
8000a890:	f7 bc 00 fc 	subeq	r12,-4
8000a894:	f4 08 17 00 	moveq	r8,r10
8000a898:	f7 d8 c0 02 	bfextu	r11,r8,0x0,0x2
8000a89c:	f0 0a 16 02 	lsr	r10,r8,0x2
8000a8a0:	58 0b       	cp.w	r11,0
8000a8a2:	f7 bc 00 fe 	subeq	r12,-2
8000a8a6:	f4 08 17 00 	moveq	r8,r10
8000a8aa:	ed b8 00 00 	bld	r8,0x0
8000a8ae:	c0 60       	breq	8000a8ba <__lo0bits+0x8a>
8000a8b0:	a1 98       	lsr	r8,0x1
8000a8b2:	c0 31       	brne	8000a8b8 <__lo0bits+0x88>
8000a8b4:	32 0c       	mov	r12,32
8000a8b6:	5e fc       	retal	r12
8000a8b8:	2f fc       	sub	r12,-1
8000a8ba:	93 08       	st.w	r9[0x0],r8
8000a8bc:	5e fc       	retal	r12

8000a8be <__mcmp>:
8000a8be:	d4 01       	pushm	lr
8000a8c0:	18 98       	mov	r8,r12
8000a8c2:	76 49       	ld.w	r9,r11[0x10]
8000a8c4:	78 4c       	ld.w	r12,r12[0x10]
8000a8c6:	12 1c       	sub	r12,r9
8000a8c8:	c1 31       	brne	8000a8ee <__mcmp+0x30>
8000a8ca:	2f b9       	sub	r9,-5
8000a8cc:	a3 69       	lsl	r9,0x2
8000a8ce:	12 0b       	add	r11,r9
8000a8d0:	f0 09 00 09 	add	r9,r8,r9
8000a8d4:	2e c8       	sub	r8,-20
8000a8d6:	13 4e       	ld.w	lr,--r9
8000a8d8:	17 4a       	ld.w	r10,--r11
8000a8da:	14 3e       	cp.w	lr,r10
8000a8dc:	c0 60       	breq	8000a8e8 <__mcmp+0x2a>
8000a8de:	f9 bc 03 ff 	movlo	r12,-1
8000a8e2:	f9 bc 02 01 	movhs	r12,1
8000a8e6:	d8 02       	popm	pc
8000a8e8:	10 39       	cp.w	r9,r8
8000a8ea:	fe 9b ff f6 	brhi	8000a8d6 <__mcmp+0x18>
8000a8ee:	d8 02       	popm	pc

8000a8f0 <_Bfree>:
8000a8f0:	d4 21       	pushm	r4-r7,lr
8000a8f2:	18 97       	mov	r7,r12
8000a8f4:	16 95       	mov	r5,r11
8000a8f6:	78 96       	ld.w	r6,r12[0x24]
8000a8f8:	58 06       	cp.w	r6,0
8000a8fa:	c0 91       	brne	8000a90c <_Bfree+0x1c>
8000a8fc:	31 0c       	mov	r12,16
8000a8fe:	fe b0 de 37 	rcall	8000656c <malloc>
8000a902:	99 36       	st.w	r12[0xc],r6
8000a904:	8f 9c       	st.w	r7[0x24],r12
8000a906:	99 16       	st.w	r12[0x4],r6
8000a908:	99 26       	st.w	r12[0x8],r6
8000a90a:	99 06       	st.w	r12[0x0],r6
8000a90c:	58 05       	cp.w	r5,0
8000a90e:	c0 90       	breq	8000a920 <_Bfree+0x30>
8000a910:	6a 19       	ld.w	r9,r5[0x4]
8000a912:	6e 98       	ld.w	r8,r7[0x24]
8000a914:	70 38       	ld.w	r8,r8[0xc]
8000a916:	f0 09 03 2a 	ld.w	r10,r8[r9<<0x2]
8000a91a:	8b 0a       	st.w	r5[0x0],r10
8000a91c:	f0 09 09 25 	st.w	r8[r9<<0x2],r5
8000a920:	d8 22       	popm	r4-r7,pc
8000a922:	d7 03       	nop

8000a924 <_Balloc>:
8000a924:	d4 21       	pushm	r4-r7,lr
8000a926:	18 97       	mov	r7,r12
8000a928:	16 96       	mov	r6,r11
8000a92a:	78 95       	ld.w	r5,r12[0x24]
8000a92c:	58 05       	cp.w	r5,0
8000a92e:	c0 91       	brne	8000a940 <_Balloc+0x1c>
8000a930:	31 0c       	mov	r12,16
8000a932:	fe b0 de 1d 	rcall	8000656c <malloc>
8000a936:	99 35       	st.w	r12[0xc],r5
8000a938:	8f 9c       	st.w	r7[0x24],r12
8000a93a:	99 15       	st.w	r12[0x4],r5
8000a93c:	99 25       	st.w	r12[0x8],r5
8000a93e:	99 05       	st.w	r12[0x0],r5
8000a940:	6e 95       	ld.w	r5,r7[0x24]
8000a942:	6a 38       	ld.w	r8,r5[0xc]
8000a944:	58 08       	cp.w	r8,0
8000a946:	c0 b1       	brne	8000a95c <_Balloc+0x38>
8000a948:	31 0a       	mov	r10,16
8000a94a:	30 4b       	mov	r11,4
8000a94c:	0e 9c       	mov	r12,r7
8000a94e:	e0 a0 02 a7 	rcall	8000ae9c <_calloc_r>
8000a952:	8b 3c       	st.w	r5[0xc],r12
8000a954:	6e 98       	ld.w	r8,r7[0x24]
8000a956:	70 3c       	ld.w	r12,r8[0xc]
8000a958:	58 0c       	cp.w	r12,0
8000a95a:	c1 b0       	breq	8000a990 <_Balloc+0x6c>
8000a95c:	6e 98       	ld.w	r8,r7[0x24]
8000a95e:	70 38       	ld.w	r8,r8[0xc]
8000a960:	f0 06 00 28 	add	r8,r8,r6<<0x2
8000a964:	70 0c       	ld.w	r12,r8[0x0]
8000a966:	58 0c       	cp.w	r12,0
8000a968:	c0 40       	breq	8000a970 <_Balloc+0x4c>
8000a96a:	78 09       	ld.w	r9,r12[0x0]
8000a96c:	91 09       	st.w	r8[0x0],r9
8000a96e:	c0 e8       	rjmp	8000a98a <_Balloc+0x66>
8000a970:	0e 9c       	mov	r12,r7
8000a972:	30 17       	mov	r7,1
8000a974:	0e 9b       	mov	r11,r7
8000a976:	ee 06 09 47 	lsl	r7,r7,r6
8000a97a:	ee ca ff fb 	sub	r10,r7,-5
8000a97e:	a3 6a       	lsl	r10,0x2
8000a980:	e0 a0 02 8e 	rcall	8000ae9c <_calloc_r>
8000a984:	c0 60       	breq	8000a990 <_Balloc+0x6c>
8000a986:	99 16       	st.w	r12[0x4],r6
8000a988:	99 27       	st.w	r12[0x8],r7
8000a98a:	30 08       	mov	r8,0
8000a98c:	99 38       	st.w	r12[0xc],r8
8000a98e:	99 48       	st.w	r12[0x10],r8
8000a990:	d8 22       	popm	r4-r7,pc
8000a992:	d7 03       	nop

8000a994 <__d2b>:
8000a994:	d4 31       	pushm	r0-r7,lr
8000a996:	20 2d       	sub	sp,8
8000a998:	16 93       	mov	r3,r11
8000a99a:	12 96       	mov	r6,r9
8000a99c:	10 95       	mov	r5,r8
8000a99e:	14 92       	mov	r2,r10
8000a9a0:	30 1b       	mov	r11,1
8000a9a2:	cc 1f       	rcall	8000a924 <_Balloc>
8000a9a4:	f3 d3 c0 14 	bfextu	r9,r3,0x0,0x14
8000a9a8:	50 09       	stdsp	sp[0x0],r9
8000a9aa:	f1 d3 c0 1f 	bfextu	r8,r3,0x0,0x1f
8000a9ae:	b5 a9       	sbr	r9,0x14
8000a9b0:	f0 01 16 14 	lsr	r1,r8,0x14
8000a9b4:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000a9b8:	18 94       	mov	r4,r12
8000a9ba:	58 02       	cp.w	r2,0
8000a9bc:	c1 d0       	breq	8000a9f6 <__d2b+0x62>
8000a9be:	fa cc ff f8 	sub	r12,sp,-8
8000a9c2:	18 d2       	st.w	--r12,r2
8000a9c4:	c3 6f       	rcall	8000a830 <__lo0bits>
8000a9c6:	40 18       	lddsp	r8,sp[0x4]
8000a9c8:	c0 d0       	breq	8000a9e2 <__d2b+0x4e>
8000a9ca:	40 09       	lddsp	r9,sp[0x0]
8000a9cc:	f8 0a 11 20 	rsub	r10,r12,32
8000a9d0:	f2 0a 09 4a 	lsl	r10,r9,r10
8000a9d4:	f5 e8 10 08 	or	r8,r10,r8
8000a9d8:	89 58       	st.w	r4[0x14],r8
8000a9da:	f2 0c 0a 49 	lsr	r9,r9,r12
8000a9de:	50 09       	stdsp	sp[0x0],r9
8000a9e0:	c0 28       	rjmp	8000a9e4 <__d2b+0x50>
8000a9e2:	89 58       	st.w	r4[0x14],r8
8000a9e4:	40 08       	lddsp	r8,sp[0x0]
8000a9e6:	58 08       	cp.w	r8,0
8000a9e8:	f9 b3 01 02 	movne	r3,2
8000a9ec:	f9 b3 00 01 	moveq	r3,1
8000a9f0:	89 68       	st.w	r4[0x18],r8
8000a9f2:	89 43       	st.w	r4[0x10],r3
8000a9f4:	c0 88       	rjmp	8000aa04 <__d2b+0x70>
8000a9f6:	1a 9c       	mov	r12,sp
8000a9f8:	c1 cf       	rcall	8000a830 <__lo0bits>
8000a9fa:	30 13       	mov	r3,1
8000a9fc:	40 08       	lddsp	r8,sp[0x0]
8000a9fe:	2e 0c       	sub	r12,-32
8000aa00:	89 43       	st.w	r4[0x10],r3
8000aa02:	89 58       	st.w	r4[0x14],r8
8000aa04:	58 01       	cp.w	r1,0
8000aa06:	c0 90       	breq	8000aa18 <__d2b+0x84>
8000aa08:	e2 c1 04 33 	sub	r1,r1,1075
8000aa0c:	18 01       	add	r1,r12
8000aa0e:	8d 01       	st.w	r6[0x0],r1
8000aa10:	f8 0c 11 35 	rsub	r12,r12,53
8000aa14:	8b 0c       	st.w	r5[0x0],r12
8000aa16:	c0 c8       	rjmp	8000aa2e <__d2b+0x9a>
8000aa18:	e6 c8 ff fc 	sub	r8,r3,-4
8000aa1c:	f8 cc 04 32 	sub	r12,r12,1074
8000aa20:	a5 73       	lsl	r3,0x5
8000aa22:	8d 0c       	st.w	r6[0x0],r12
8000aa24:	e8 08 03 2c 	ld.w	r12,r4[r8<<0x2]
8000aa28:	cd 4e       	rcall	8000a7d0 <__hi0bits>
8000aa2a:	18 13       	sub	r3,r12
8000aa2c:	8b 03       	st.w	r5[0x0],r3
8000aa2e:	08 9c       	mov	r12,r4
8000aa30:	2f ed       	sub	sp,-8
8000aa32:	d8 32       	popm	r0-r7,pc

8000aa34 <__mdiff>:
8000aa34:	d4 31       	pushm	r0-r7,lr
8000aa36:	74 48       	ld.w	r8,r10[0x10]
8000aa38:	76 45       	ld.w	r5,r11[0x10]
8000aa3a:	16 97       	mov	r7,r11
8000aa3c:	14 96       	mov	r6,r10
8000aa3e:	10 15       	sub	r5,r8
8000aa40:	c1 31       	brne	8000aa66 <__mdiff+0x32>
8000aa42:	2f b8       	sub	r8,-5
8000aa44:	ee ce ff ec 	sub	lr,r7,-20
8000aa48:	a3 68       	lsl	r8,0x2
8000aa4a:	f4 08 00 0b 	add	r11,r10,r8
8000aa4e:	ee 08 00 08 	add	r8,r7,r8
8000aa52:	11 4a       	ld.w	r10,--r8
8000aa54:	17 49       	ld.w	r9,--r11
8000aa56:	12 3a       	cp.w	r10,r9
8000aa58:	c0 30       	breq	8000aa5e <__mdiff+0x2a>
8000aa5a:	c0 e2       	brcc	8000aa76 <__mdiff+0x42>
8000aa5c:	c0 78       	rjmp	8000aa6a <__mdiff+0x36>
8000aa5e:	1c 38       	cp.w	r8,lr
8000aa60:	fe 9b ff f9 	brhi	8000aa52 <__mdiff+0x1e>
8000aa64:	c4 98       	rjmp	8000aaf6 <__mdiff+0xc2>
8000aa66:	58 05       	cp.w	r5,0
8000aa68:	c0 64       	brge	8000aa74 <__mdiff+0x40>
8000aa6a:	0e 98       	mov	r8,r7
8000aa6c:	30 15       	mov	r5,1
8000aa6e:	0c 97       	mov	r7,r6
8000aa70:	10 96       	mov	r6,r8
8000aa72:	c0 28       	rjmp	8000aa76 <__mdiff+0x42>
8000aa74:	30 05       	mov	r5,0
8000aa76:	6e 1b       	ld.w	r11,r7[0x4]
8000aa78:	c5 6f       	rcall	8000a924 <_Balloc>
8000aa7a:	6e 49       	ld.w	r9,r7[0x10]
8000aa7c:	6c 44       	ld.w	r4,r6[0x10]
8000aa7e:	99 35       	st.w	r12[0xc],r5
8000aa80:	2f b4       	sub	r4,-5
8000aa82:	f2 c5 ff fb 	sub	r5,r9,-5
8000aa86:	ec 04 00 24 	add	r4,r6,r4<<0x2
8000aa8a:	ee 05 00 25 	add	r5,r7,r5<<0x2
8000aa8e:	2e c6       	sub	r6,-20
8000aa90:	2e c7       	sub	r7,-20
8000aa92:	f8 c8 ff ec 	sub	r8,r12,-20
8000aa96:	30 0a       	mov	r10,0
8000aa98:	0f 0e       	ld.w	lr,r7++
8000aa9a:	0d 0b       	ld.w	r11,r6++
8000aa9c:	fc 02 16 10 	lsr	r2,lr,0x10
8000aaa0:	f6 03 16 10 	lsr	r3,r11,0x10
8000aaa4:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000aaa8:	e4 03 01 03 	sub	r3,r2,r3
8000aaac:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000aab0:	fc 0b 01 0b 	sub	r11,lr,r11
8000aab4:	f6 0a 00 0a 	add	r10,r11,r10
8000aab8:	b0 1a       	st.h	r8[0x2],r10
8000aaba:	b1 4a       	asr	r10,0x10
8000aabc:	e6 0a 00 0a 	add	r10,r3,r10
8000aac0:	b0 0a       	st.h	r8[0x0],r10
8000aac2:	2f c8       	sub	r8,-4
8000aac4:	b1 4a       	asr	r10,0x10
8000aac6:	08 36       	cp.w	r6,r4
8000aac8:	ce 83       	brcs	8000aa98 <__mdiff+0x64>
8000aaca:	c0 d8       	rjmp	8000aae4 <__mdiff+0xb0>
8000aacc:	0f 0b       	ld.w	r11,r7++
8000aace:	f6 0e 16 10 	lsr	lr,r11,0x10
8000aad2:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000aad6:	16 0a       	add	r10,r11
8000aad8:	b0 1a       	st.h	r8[0x2],r10
8000aada:	b1 4a       	asr	r10,0x10
8000aadc:	1c 0a       	add	r10,lr
8000aade:	b0 0a       	st.h	r8[0x0],r10
8000aae0:	2f c8       	sub	r8,-4
8000aae2:	b1 4a       	asr	r10,0x10
8000aae4:	0a 37       	cp.w	r7,r5
8000aae6:	cf 33       	brcs	8000aacc <__mdiff+0x98>
8000aae8:	c0 28       	rjmp	8000aaec <__mdiff+0xb8>
8000aaea:	20 19       	sub	r9,1
8000aaec:	11 4a       	ld.w	r10,--r8
8000aaee:	58 0a       	cp.w	r10,0
8000aaf0:	cf d0       	breq	8000aaea <__mdiff+0xb6>
8000aaf2:	99 49       	st.w	r12[0x10],r9
8000aaf4:	d8 32       	popm	r0-r7,pc
8000aaf6:	30 0b       	mov	r11,0
8000aaf8:	c1 6f       	rcall	8000a924 <_Balloc>
8000aafa:	30 18       	mov	r8,1
8000aafc:	99 48       	st.w	r12[0x10],r8
8000aafe:	30 08       	mov	r8,0
8000ab00:	99 58       	st.w	r12[0x14],r8
8000ab02:	d8 32       	popm	r0-r7,pc

8000ab04 <__lshift>:
8000ab04:	d4 31       	pushm	r0-r7,lr
8000ab06:	16 97       	mov	r7,r11
8000ab08:	76 46       	ld.w	r6,r11[0x10]
8000ab0a:	f4 02 14 05 	asr	r2,r10,0x5
8000ab0e:	2f f6       	sub	r6,-1
8000ab10:	14 93       	mov	r3,r10
8000ab12:	18 94       	mov	r4,r12
8000ab14:	04 06       	add	r6,r2
8000ab16:	76 1b       	ld.w	r11,r11[0x4]
8000ab18:	6e 28       	ld.w	r8,r7[0x8]
8000ab1a:	c0 38       	rjmp	8000ab20 <__lshift+0x1c>
8000ab1c:	2f fb       	sub	r11,-1
8000ab1e:	a1 78       	lsl	r8,0x1
8000ab20:	10 36       	cp.w	r6,r8
8000ab22:	fe 99 ff fd 	brgt	8000ab1c <__lshift+0x18>
8000ab26:	08 9c       	mov	r12,r4
8000ab28:	cf ee       	rcall	8000a924 <_Balloc>
8000ab2a:	30 09       	mov	r9,0
8000ab2c:	18 95       	mov	r5,r12
8000ab2e:	f8 c8 ff ec 	sub	r8,r12,-20
8000ab32:	12 9a       	mov	r10,r9
8000ab34:	c0 38       	rjmp	8000ab3a <__lshift+0x36>
8000ab36:	10 aa       	st.w	r8++,r10
8000ab38:	2f f9       	sub	r9,-1
8000ab3a:	04 39       	cp.w	r9,r2
8000ab3c:	cf d5       	brlt	8000ab36 <__lshift+0x32>
8000ab3e:	6e 4b       	ld.w	r11,r7[0x10]
8000ab40:	e7 d3 c0 05 	bfextu	r3,r3,0x0,0x5
8000ab44:	2f bb       	sub	r11,-5
8000ab46:	ee c9 ff ec 	sub	r9,r7,-20
8000ab4a:	ee 0b 00 2b 	add	r11,r7,r11<<0x2
8000ab4e:	58 03       	cp.w	r3,0
8000ab50:	c1 30       	breq	8000ab76 <__lshift+0x72>
8000ab52:	e6 0c 11 20 	rsub	r12,r3,32
8000ab56:	30 0a       	mov	r10,0
8000ab58:	72 02       	ld.w	r2,r9[0x0]
8000ab5a:	e4 03 09 42 	lsl	r2,r2,r3
8000ab5e:	04 4a       	or	r10,r2
8000ab60:	10 aa       	st.w	r8++,r10
8000ab62:	13 0a       	ld.w	r10,r9++
8000ab64:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000ab68:	16 39       	cp.w	r9,r11
8000ab6a:	cf 73       	brcs	8000ab58 <__lshift+0x54>
8000ab6c:	91 0a       	st.w	r8[0x0],r10
8000ab6e:	58 0a       	cp.w	r10,0
8000ab70:	c0 70       	breq	8000ab7e <__lshift+0x7a>
8000ab72:	2f f6       	sub	r6,-1
8000ab74:	c0 58       	rjmp	8000ab7e <__lshift+0x7a>
8000ab76:	13 0a       	ld.w	r10,r9++
8000ab78:	10 aa       	st.w	r8++,r10
8000ab7a:	16 39       	cp.w	r9,r11
8000ab7c:	cf d3       	brcs	8000ab76 <__lshift+0x72>
8000ab7e:	08 9c       	mov	r12,r4
8000ab80:	20 16       	sub	r6,1
8000ab82:	0e 9b       	mov	r11,r7
8000ab84:	8b 46       	st.w	r5[0x10],r6
8000ab86:	cb 5e       	rcall	8000a8f0 <_Bfree>
8000ab88:	0a 9c       	mov	r12,r5
8000ab8a:	d8 32       	popm	r0-r7,pc

8000ab8c <__multiply>:
8000ab8c:	d4 31       	pushm	r0-r7,lr
8000ab8e:	20 2d       	sub	sp,8
8000ab90:	76 49       	ld.w	r9,r11[0x10]
8000ab92:	74 48       	ld.w	r8,r10[0x10]
8000ab94:	16 96       	mov	r6,r11
8000ab96:	14 95       	mov	r5,r10
8000ab98:	10 39       	cp.w	r9,r8
8000ab9a:	ec 08 17 50 	movlt	r8,r6
8000ab9e:	ea 06 17 50 	movlt	r6,r5
8000aba2:	f0 05 17 50 	movlt	r5,r8
8000aba6:	6c 28       	ld.w	r8,r6[0x8]
8000aba8:	76 43       	ld.w	r3,r11[0x10]
8000abaa:	74 42       	ld.w	r2,r10[0x10]
8000abac:	76 1b       	ld.w	r11,r11[0x4]
8000abae:	e4 03 00 07 	add	r7,r2,r3
8000abb2:	10 37       	cp.w	r7,r8
8000abb4:	f7 bb 09 ff 	subgt	r11,-1
8000abb8:	cb 6e       	rcall	8000a924 <_Balloc>
8000abba:	ee c4 ff fb 	sub	r4,r7,-5
8000abbe:	f8 c9 ff ec 	sub	r9,r12,-20
8000abc2:	f8 04 00 24 	add	r4,r12,r4<<0x2
8000abc6:	30 0a       	mov	r10,0
8000abc8:	12 98       	mov	r8,r9
8000abca:	c0 28       	rjmp	8000abce <__multiply+0x42>
8000abcc:	10 aa       	st.w	r8++,r10
8000abce:	08 38       	cp.w	r8,r4
8000abd0:	cf e3       	brcs	8000abcc <__multiply+0x40>
8000abd2:	2f b3       	sub	r3,-5
8000abd4:	2f b2       	sub	r2,-5
8000abd6:	ec 03 00 23 	add	r3,r6,r3<<0x2
8000abda:	ea 02 00 22 	add	r2,r5,r2<<0x2
8000abde:	ec cb ff ec 	sub	r11,r6,-20
8000abe2:	50 12       	stdsp	sp[0x4],r2
8000abe4:	ea ca ff ec 	sub	r10,r5,-20
8000abe8:	c4 48       	rjmp	8000ac70 <__multiply+0xe4>
8000abea:	94 95       	ld.uh	r5,r10[0x2]
8000abec:	58 05       	cp.w	r5,0
8000abee:	c2 00       	breq	8000ac2e <__multiply+0xa2>
8000abf0:	12 98       	mov	r8,r9
8000abf2:	16 96       	mov	r6,r11
8000abf4:	30 0e       	mov	lr,0
8000abf6:	50 09       	stdsp	sp[0x0],r9
8000abf8:	0d 02       	ld.w	r2,r6++
8000abfa:	e4 00 16 10 	lsr	r0,r2,0x10
8000abfe:	70 01       	ld.w	r1,r8[0x0]
8000ac00:	70 09       	ld.w	r9,r8[0x0]
8000ac02:	b1 81       	lsr	r1,0x10
8000ac04:	e5 d2 c0 10 	bfextu	r2,r2,0x0,0x10
8000ac08:	e0 05 03 41 	mac	r1,r0,r5
8000ac0c:	ab 32       	mul	r2,r5
8000ac0e:	e1 d9 c0 10 	bfextu	r0,r9,0x0,0x10
8000ac12:	00 02       	add	r2,r0
8000ac14:	e4 0e 00 0e 	add	lr,r2,lr
8000ac18:	b0 1e       	st.h	r8[0x2],lr
8000ac1a:	b1 8e       	lsr	lr,0x10
8000ac1c:	1c 01       	add	r1,lr
8000ac1e:	b0 01       	st.h	r8[0x0],r1
8000ac20:	e2 0e 16 10 	lsr	lr,r1,0x10
8000ac24:	2f c8       	sub	r8,-4
8000ac26:	06 36       	cp.w	r6,r3
8000ac28:	ce 83       	brcs	8000abf8 <__multiply+0x6c>
8000ac2a:	40 09       	lddsp	r9,sp[0x0]
8000ac2c:	91 0e       	st.w	r8[0x0],lr
8000ac2e:	94 86       	ld.uh	r6,r10[0x0]
8000ac30:	58 06       	cp.w	r6,0
8000ac32:	c1 d0       	breq	8000ac6c <__multiply+0xe0>
8000ac34:	72 02       	ld.w	r2,r9[0x0]
8000ac36:	12 98       	mov	r8,r9
8000ac38:	16 9e       	mov	lr,r11
8000ac3a:	30 05       	mov	r5,0
8000ac3c:	b0 12       	st.h	r8[0x2],r2
8000ac3e:	1d 01       	ld.w	r1,lr++
8000ac40:	90 82       	ld.uh	r2,r8[0x0]
8000ac42:	e1 d1 c0 10 	bfextu	r0,r1,0x0,0x10
8000ac46:	ad 30       	mul	r0,r6
8000ac48:	e0 02 00 02 	add	r2,r0,r2
8000ac4c:	e4 05 00 05 	add	r5,r2,r5
8000ac50:	b0 05       	st.h	r8[0x0],r5
8000ac52:	b1 85       	lsr	r5,0x10
8000ac54:	b1 81       	lsr	r1,0x10
8000ac56:	2f c8       	sub	r8,-4
8000ac58:	ad 31       	mul	r1,r6
8000ac5a:	90 92       	ld.uh	r2,r8[0x2]
8000ac5c:	e2 02 00 02 	add	r2,r1,r2
8000ac60:	0a 02       	add	r2,r5
8000ac62:	e4 05 16 10 	lsr	r5,r2,0x10
8000ac66:	06 3e       	cp.w	lr,r3
8000ac68:	ce a3       	brcs	8000ac3c <__multiply+0xb0>
8000ac6a:	91 02       	st.w	r8[0x0],r2
8000ac6c:	2f ca       	sub	r10,-4
8000ac6e:	2f c9       	sub	r9,-4
8000ac70:	40 18       	lddsp	r8,sp[0x4]
8000ac72:	10 3a       	cp.w	r10,r8
8000ac74:	cb b3       	brcs	8000abea <__multiply+0x5e>
8000ac76:	c0 28       	rjmp	8000ac7a <__multiply+0xee>
8000ac78:	20 17       	sub	r7,1
8000ac7a:	58 07       	cp.w	r7,0
8000ac7c:	e0 8a 00 05 	brle	8000ac86 <__multiply+0xfa>
8000ac80:	09 48       	ld.w	r8,--r4
8000ac82:	58 08       	cp.w	r8,0
8000ac84:	cf a0       	breq	8000ac78 <__multiply+0xec>
8000ac86:	99 47       	st.w	r12[0x10],r7
8000ac88:	2f ed       	sub	sp,-8
8000ac8a:	d8 32       	popm	r0-r7,pc

8000ac8c <__i2b>:
8000ac8c:	d4 21       	pushm	r4-r7,lr
8000ac8e:	16 97       	mov	r7,r11
8000ac90:	30 1b       	mov	r11,1
8000ac92:	c4 9e       	rcall	8000a924 <_Balloc>
8000ac94:	30 19       	mov	r9,1
8000ac96:	99 57       	st.w	r12[0x14],r7
8000ac98:	99 49       	st.w	r12[0x10],r9
8000ac9a:	d8 22       	popm	r4-r7,pc

8000ac9c <__multadd>:
8000ac9c:	d4 31       	pushm	r0-r7,lr
8000ac9e:	30 08       	mov	r8,0
8000aca0:	12 95       	mov	r5,r9
8000aca2:	16 97       	mov	r7,r11
8000aca4:	18 96       	mov	r6,r12
8000aca6:	76 44       	ld.w	r4,r11[0x10]
8000aca8:	f6 c9 ff ec 	sub	r9,r11,-20
8000acac:	72 0b       	ld.w	r11,r9[0x0]
8000acae:	f6 0c 16 10 	lsr	r12,r11,0x10
8000acb2:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000acb6:	f4 0c 02 4c 	mul	r12,r10,r12
8000acba:	f4 0b 03 45 	mac	r5,r10,r11
8000acbe:	f7 d5 c0 10 	bfextu	r11,r5,0x0,0x10
8000acc2:	b1 85       	lsr	r5,0x10
8000acc4:	18 05       	add	r5,r12
8000acc6:	ea 0c 15 10 	lsl	r12,r5,0x10
8000acca:	f8 0b 00 0b 	add	r11,r12,r11
8000acce:	12 ab       	st.w	r9++,r11
8000acd0:	2f f8       	sub	r8,-1
8000acd2:	b1 85       	lsr	r5,0x10
8000acd4:	08 38       	cp.w	r8,r4
8000acd6:	ce b5       	brlt	8000acac <__multadd+0x10>
8000acd8:	58 05       	cp.w	r5,0
8000acda:	c1 c0       	breq	8000ad12 <__multadd+0x76>
8000acdc:	6e 28       	ld.w	r8,r7[0x8]
8000acde:	10 34       	cp.w	r4,r8
8000ace0:	c1 35       	brlt	8000ad06 <__multadd+0x6a>
8000ace2:	6e 1b       	ld.w	r11,r7[0x4]
8000ace4:	0c 9c       	mov	r12,r6
8000ace6:	2f fb       	sub	r11,-1
8000ace8:	c1 ee       	rcall	8000a924 <_Balloc>
8000acea:	6e 4a       	ld.w	r10,r7[0x10]
8000acec:	ee cb ff f4 	sub	r11,r7,-12
8000acf0:	18 93       	mov	r3,r12
8000acf2:	2f ea       	sub	r10,-2
8000acf4:	2f 4c       	sub	r12,-12
8000acf6:	a3 6a       	lsl	r10,0x2
8000acf8:	fe b0 de 71 	rcall	800069da <memcpy>
8000acfc:	0e 9b       	mov	r11,r7
8000acfe:	0c 9c       	mov	r12,r6
8000ad00:	fe b0 fd f8 	rcall	8000a8f0 <_Bfree>
8000ad04:	06 97       	mov	r7,r3
8000ad06:	e8 c8 ff ff 	sub	r8,r4,-1
8000ad0a:	2f b4       	sub	r4,-5
8000ad0c:	8f 48       	st.w	r7[0x10],r8
8000ad0e:	ee 04 09 25 	st.w	r7[r4<<0x2],r5
8000ad12:	0e 9c       	mov	r12,r7
8000ad14:	d8 32       	popm	r0-r7,pc
8000ad16:	d7 03       	nop

8000ad18 <__pow5mult>:
8000ad18:	d4 31       	pushm	r0-r7,lr
8000ad1a:	14 96       	mov	r6,r10
8000ad1c:	18 97       	mov	r7,r12
8000ad1e:	16 94       	mov	r4,r11
8000ad20:	f1 da c0 02 	bfextu	r8,r10,0x0,0x2
8000ad24:	c0 90       	breq	8000ad36 <__pow5mult+0x1e>
8000ad26:	20 18       	sub	r8,1
8000ad28:	fe c9 d9 c8 	sub	r9,pc,-9784
8000ad2c:	f2 08 03 2a 	ld.w	r10,r9[r8<<0x2]
8000ad30:	30 09       	mov	r9,0
8000ad32:	cb 5f       	rcall	8000ac9c <__multadd>
8000ad34:	18 94       	mov	r4,r12
8000ad36:	a3 46       	asr	r6,0x2
8000ad38:	c3 40       	breq	8000ada0 <__pow5mult+0x88>
8000ad3a:	6e 95       	ld.w	r5,r7[0x24]
8000ad3c:	58 05       	cp.w	r5,0
8000ad3e:	c0 91       	brne	8000ad50 <__pow5mult+0x38>
8000ad40:	31 0c       	mov	r12,16
8000ad42:	fe b0 dc 15 	rcall	8000656c <malloc>
8000ad46:	99 35       	st.w	r12[0xc],r5
8000ad48:	8f 9c       	st.w	r7[0x24],r12
8000ad4a:	99 15       	st.w	r12[0x4],r5
8000ad4c:	99 25       	st.w	r12[0x8],r5
8000ad4e:	99 05       	st.w	r12[0x0],r5
8000ad50:	6e 93       	ld.w	r3,r7[0x24]
8000ad52:	66 25       	ld.w	r5,r3[0x8]
8000ad54:	58 05       	cp.w	r5,0
8000ad56:	c0 c1       	brne	8000ad6e <__pow5mult+0x56>
8000ad58:	e0 6b 02 71 	mov	r11,625
8000ad5c:	0e 9c       	mov	r12,r7
8000ad5e:	c9 7f       	rcall	8000ac8c <__i2b>
8000ad60:	87 2c       	st.w	r3[0x8],r12
8000ad62:	30 08       	mov	r8,0
8000ad64:	18 95       	mov	r5,r12
8000ad66:	99 08       	st.w	r12[0x0],r8
8000ad68:	c0 38       	rjmp	8000ad6e <__pow5mult+0x56>
8000ad6a:	06 9c       	mov	r12,r3
8000ad6c:	18 95       	mov	r5,r12
8000ad6e:	ed b6 00 00 	bld	r6,0x0
8000ad72:	c0 b1       	brne	8000ad88 <__pow5mult+0x70>
8000ad74:	08 9b       	mov	r11,r4
8000ad76:	0a 9a       	mov	r10,r5
8000ad78:	0e 9c       	mov	r12,r7
8000ad7a:	c0 9f       	rcall	8000ab8c <__multiply>
8000ad7c:	08 9b       	mov	r11,r4
8000ad7e:	18 93       	mov	r3,r12
8000ad80:	0e 9c       	mov	r12,r7
8000ad82:	06 94       	mov	r4,r3
8000ad84:	fe b0 fd b6 	rcall	8000a8f0 <_Bfree>
8000ad88:	a1 56       	asr	r6,0x1
8000ad8a:	c0 b0       	breq	8000ada0 <__pow5mult+0x88>
8000ad8c:	6a 03       	ld.w	r3,r5[0x0]
8000ad8e:	58 03       	cp.w	r3,0
8000ad90:	ce d1       	brne	8000ad6a <__pow5mult+0x52>
8000ad92:	0a 9a       	mov	r10,r5
8000ad94:	0a 9b       	mov	r11,r5
8000ad96:	0e 9c       	mov	r12,r7
8000ad98:	cf ae       	rcall	8000ab8c <__multiply>
8000ad9a:	8b 0c       	st.w	r5[0x0],r12
8000ad9c:	99 03       	st.w	r12[0x0],r3
8000ad9e:	ce 7b       	rjmp	8000ad6c <__pow5mult+0x54>
8000ada0:	08 9c       	mov	r12,r4
8000ada2:	d8 32       	popm	r0-r7,pc

8000ada4 <__isinfd>:
8000ada4:	14 98       	mov	r8,r10
8000ada6:	fc 19 7f f0 	movh	r9,0x7ff0
8000adaa:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000adae:	f0 0b 11 00 	rsub	r11,r8,0
8000adb2:	f7 e8 10 08 	or	r8,r11,r8
8000adb6:	f5 e8 13 f8 	or	r8,r10,r8>>0x1f
8000adba:	f2 08 01 08 	sub	r8,r9,r8
8000adbe:	f0 0c 11 00 	rsub	r12,r8,0
8000adc2:	f9 e8 10 08 	or	r8,r12,r8
8000adc6:	f0 0c 14 1f 	asr	r12,r8,0x1f
8000adca:	2f fc       	sub	r12,-1
8000adcc:	5e fc       	retal	r12

8000adce <__isnand>:
8000adce:	14 98       	mov	r8,r10
8000add0:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000add4:	f0 0c 11 00 	rsub	r12,r8,0
8000add8:	10 4c       	or	r12,r8
8000adda:	fc 18 7f f0 	movh	r8,0x7ff0
8000adde:	f5 ec 13 fc 	or	r12,r10,r12>>0x1f
8000ade2:	f0 0c 01 0c 	sub	r12,r8,r12
8000ade6:	bf 9c       	lsr	r12,0x1f
8000ade8:	5e fc       	retal	r12
8000adea:	d7 03       	nop

8000adec <__sclose>:
8000adec:	d4 01       	pushm	lr
8000adee:	96 7b       	ld.sh	r11,r11[0xe]
8000adf0:	c8 2c       	rcall	8000aef4 <_close_r>
8000adf2:	d8 02       	popm	pc

8000adf4 <__sseek>:
8000adf4:	d4 21       	pushm	r4-r7,lr
8000adf6:	16 97       	mov	r7,r11
8000adf8:	96 7b       	ld.sh	r11,r11[0xe]
8000adfa:	c0 3d       	rcall	8000b000 <_lseek_r>
8000adfc:	8e 68       	ld.sh	r8,r7[0xc]
8000adfe:	10 99       	mov	r9,r8
8000ae00:	ad c8       	cbr	r8,0xc
8000ae02:	ad a9       	sbr	r9,0xc
8000ae04:	5b fc       	cp.w	r12,-1
8000ae06:	ef f8 0c 06 	st.heq	r7[0xc],r8
8000ae0a:	ef f9 1c 06 	st.hne	r7[0xc],r9
8000ae0e:	ef fc 1a 15 	st.wne	r7[0x54],r12
8000ae12:	d8 22       	popm	r4-r7,pc

8000ae14 <__swrite>:
8000ae14:	d4 21       	pushm	r4-r7,lr
8000ae16:	96 68       	ld.sh	r8,r11[0xc]
8000ae18:	16 97       	mov	r7,r11
8000ae1a:	14 95       	mov	r5,r10
8000ae1c:	12 94       	mov	r4,r9
8000ae1e:	e2 18 01 00 	andl	r8,0x100,COH
8000ae22:	18 96       	mov	r6,r12
8000ae24:	c0 50       	breq	8000ae2e <__swrite+0x1a>
8000ae26:	30 29       	mov	r9,2
8000ae28:	30 0a       	mov	r10,0
8000ae2a:	96 7b       	ld.sh	r11,r11[0xe]
8000ae2c:	ce ac       	rcall	8000b000 <_lseek_r>
8000ae2e:	8e 68       	ld.sh	r8,r7[0xc]
8000ae30:	ad c8       	cbr	r8,0xc
8000ae32:	08 99       	mov	r9,r4
8000ae34:	0a 9a       	mov	r10,r5
8000ae36:	8e 7b       	ld.sh	r11,r7[0xe]
8000ae38:	0c 9c       	mov	r12,r6
8000ae3a:	ae 68       	st.h	r7[0xc],r8
8000ae3c:	c1 cc       	rcall	8000ae74 <_write_r>
8000ae3e:	d8 22       	popm	r4-r7,pc

8000ae40 <__sread>:
8000ae40:	d4 21       	pushm	r4-r7,lr
8000ae42:	16 97       	mov	r7,r11
8000ae44:	96 7b       	ld.sh	r11,r11[0xe]
8000ae46:	cf 1c       	rcall	8000b028 <_read_r>
8000ae48:	c0 65       	brlt	8000ae54 <__sread+0x14>
8000ae4a:	6f 58       	ld.w	r8,r7[0x54]
8000ae4c:	18 08       	add	r8,r12
8000ae4e:	ef 48 00 54 	st.w	r7[84],r8
8000ae52:	d8 22       	popm	r4-r7,pc
8000ae54:	8e 68       	ld.sh	r8,r7[0xc]
8000ae56:	ad c8       	cbr	r8,0xc
8000ae58:	ae 68       	st.h	r7[0xc],r8
8000ae5a:	d8 22       	popm	r4-r7,pc

8000ae5c <strlen>:
8000ae5c:	30 09       	mov	r9,0
8000ae5e:	18 98       	mov	r8,r12
8000ae60:	c0 28       	rjmp	8000ae64 <strlen+0x8>
8000ae62:	2f f8       	sub	r8,-1
8000ae64:	11 8a       	ld.ub	r10,r8[0x0]
8000ae66:	f2 0a 18 00 	cp.b	r10,r9
8000ae6a:	cf c1       	brne	8000ae62 <strlen+0x6>
8000ae6c:	f0 0c 01 0c 	sub	r12,r8,r12
8000ae70:	5e fc       	retal	r12
8000ae72:	d7 03       	nop

8000ae74 <_write_r>:
8000ae74:	d4 21       	pushm	r4-r7,lr
8000ae76:	16 98       	mov	r8,r11
8000ae78:	18 97       	mov	r7,r12
8000ae7a:	10 9c       	mov	r12,r8
8000ae7c:	30 08       	mov	r8,0
8000ae7e:	14 9b       	mov	r11,r10
8000ae80:	e0 66 1f d4 	mov	r6,8148
8000ae84:	12 9a       	mov	r10,r9
8000ae86:	8d 08       	st.w	r6[0x0],r8
8000ae88:	fe b0 d2 70 	rcall	80005368 <_write>
8000ae8c:	5b fc       	cp.w	r12,-1
8000ae8e:	c0 51       	brne	8000ae98 <_write_r+0x24>
8000ae90:	6c 08       	ld.w	r8,r6[0x0]
8000ae92:	58 08       	cp.w	r8,0
8000ae94:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000ae98:	d8 22       	popm	r4-r7,pc
8000ae9a:	d7 03       	nop

8000ae9c <_calloc_r>:
8000ae9c:	d4 21       	pushm	r4-r7,lr
8000ae9e:	f4 0b 02 4b 	mul	r11,r10,r11
8000aea2:	fe b0 db 6d 	rcall	8000657c <_malloc_r>
8000aea6:	18 97       	mov	r7,r12
8000aea8:	c2 30       	breq	8000aeee <_calloc_r+0x52>
8000aeaa:	f8 fa ff fc 	ld.w	r10,r12[-4]
8000aeae:	e0 1a ff fc 	andl	r10,0xfffc
8000aeb2:	20 4a       	sub	r10,4
8000aeb4:	e0 4a 00 24 	cp.w	r10,36
8000aeb8:	e0 8b 00 18 	brhi	8000aee8 <_calloc_r+0x4c>
8000aebc:	18 98       	mov	r8,r12
8000aebe:	59 3a       	cp.w	r10,19
8000aec0:	e0 88 00 0f 	brls	8000aede <_calloc_r+0x42>
8000aec4:	30 09       	mov	r9,0
8000aec6:	10 a9       	st.w	r8++,r9
8000aec8:	10 a9       	st.w	r8++,r9
8000aeca:	59 ba       	cp.w	r10,27
8000aecc:	e0 88 00 09 	brls	8000aede <_calloc_r+0x42>
8000aed0:	10 a9       	st.w	r8++,r9
8000aed2:	10 a9       	st.w	r8++,r9
8000aed4:	e0 4a 00 24 	cp.w	r10,36
8000aed8:	c0 31       	brne	8000aede <_calloc_r+0x42>
8000aeda:	10 a9       	st.w	r8++,r9
8000aedc:	10 a9       	st.w	r8++,r9
8000aede:	30 09       	mov	r9,0
8000aee0:	10 a9       	st.w	r8++,r9
8000aee2:	91 19       	st.w	r8[0x4],r9
8000aee4:	91 09       	st.w	r8[0x0],r9
8000aee6:	c0 48       	rjmp	8000aeee <_calloc_r+0x52>
8000aee8:	30 0b       	mov	r11,0
8000aeea:	fe b0 de 1c 	rcall	80006b22 <memset>
8000aeee:	0e 9c       	mov	r12,r7
8000aef0:	d8 22       	popm	r4-r7,pc
8000aef2:	d7 03       	nop

8000aef4 <_close_r>:
8000aef4:	d4 21       	pushm	r4-r7,lr
8000aef6:	30 08       	mov	r8,0
8000aef8:	18 97       	mov	r7,r12
8000aefa:	e0 66 1f d4 	mov	r6,8148
8000aefe:	16 9c       	mov	r12,r11
8000af00:	8d 08       	st.w	r6[0x0],r8
8000af02:	fe b0 df b5 	rcall	80006e6c <_close>
8000af06:	5b fc       	cp.w	r12,-1
8000af08:	c0 51       	brne	8000af12 <_close_r+0x1e>
8000af0a:	6c 08       	ld.w	r8,r6[0x0]
8000af0c:	58 08       	cp.w	r8,0
8000af0e:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000af12:	d8 22       	popm	r4-r7,pc

8000af14 <_fclose_r>:
8000af14:	d4 21       	pushm	r4-r7,lr
8000af16:	18 96       	mov	r6,r12
8000af18:	16 97       	mov	r7,r11
8000af1a:	58 0b       	cp.w	r11,0
8000af1c:	c0 31       	brne	8000af22 <_fclose_r+0xe>
8000af1e:	16 95       	mov	r5,r11
8000af20:	c5 38       	rjmp	8000afc6 <_fclose_r+0xb2>
8000af22:	fe b0 f8 a9 	rcall	8000a074 <__sfp_lock_acquire>
8000af26:	58 06       	cp.w	r6,0
8000af28:	c0 70       	breq	8000af36 <_fclose_r+0x22>
8000af2a:	6c 68       	ld.w	r8,r6[0x18]
8000af2c:	58 08       	cp.w	r8,0
8000af2e:	c0 41       	brne	8000af36 <_fclose_r+0x22>
8000af30:	0c 9c       	mov	r12,r6
8000af32:	fe b0 f8 f3 	rcall	8000a118 <__sinit>
8000af36:	fe c8 dc 7a 	sub	r8,pc,-9094
8000af3a:	10 37       	cp.w	r7,r8
8000af3c:	c0 31       	brne	8000af42 <_fclose_r+0x2e>
8000af3e:	6c 07       	ld.w	r7,r6[0x0]
8000af40:	c0 c8       	rjmp	8000af58 <_fclose_r+0x44>
8000af42:	fe c8 dc 66 	sub	r8,pc,-9114
8000af46:	10 37       	cp.w	r7,r8
8000af48:	c0 31       	brne	8000af4e <_fclose_r+0x3a>
8000af4a:	6c 17       	ld.w	r7,r6[0x4]
8000af4c:	c0 68       	rjmp	8000af58 <_fclose_r+0x44>
8000af4e:	fe c8 dc 52 	sub	r8,pc,-9134
8000af52:	10 37       	cp.w	r7,r8
8000af54:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000af58:	8e 69       	ld.sh	r9,r7[0xc]
8000af5a:	30 08       	mov	r8,0
8000af5c:	f0 09 19 00 	cp.h	r9,r8
8000af60:	c0 51       	brne	8000af6a <_fclose_r+0x56>
8000af62:	fe b0 f8 8a 	rcall	8000a076 <__sfp_lock_release>
8000af66:	30 05       	mov	r5,0
8000af68:	c2 f8       	rjmp	8000afc6 <_fclose_r+0xb2>
8000af6a:	0e 9b       	mov	r11,r7
8000af6c:	0c 9c       	mov	r12,r6
8000af6e:	fe b0 f7 fd 	rcall	80009f68 <_fflush_r>
8000af72:	6e c8       	ld.w	r8,r7[0x30]
8000af74:	18 95       	mov	r5,r12
8000af76:	58 08       	cp.w	r8,0
8000af78:	c0 60       	breq	8000af84 <_fclose_r+0x70>
8000af7a:	6e 8b       	ld.w	r11,r7[0x20]
8000af7c:	0c 9c       	mov	r12,r6
8000af7e:	5d 18       	icall	r8
8000af80:	f9 b5 05 ff 	movlt	r5,-1
8000af84:	8e 68       	ld.sh	r8,r7[0xc]
8000af86:	ed b8 00 07 	bld	r8,0x7
8000af8a:	c0 51       	brne	8000af94 <_fclose_r+0x80>
8000af8c:	6e 4b       	ld.w	r11,r7[0x10]
8000af8e:	0c 9c       	mov	r12,r6
8000af90:	fe b0 f9 5e 	rcall	8000a24c <_free_r>
8000af94:	6e db       	ld.w	r11,r7[0x34]
8000af96:	58 0b       	cp.w	r11,0
8000af98:	c0 a0       	breq	8000afac <_fclose_r+0x98>
8000af9a:	ee c8 ff bc 	sub	r8,r7,-68
8000af9e:	10 3b       	cp.w	r11,r8
8000afa0:	c0 40       	breq	8000afa8 <_fclose_r+0x94>
8000afa2:	0c 9c       	mov	r12,r6
8000afa4:	fe b0 f9 54 	rcall	8000a24c <_free_r>
8000afa8:	30 08       	mov	r8,0
8000afaa:	8f d8       	st.w	r7[0x34],r8
8000afac:	6f 2b       	ld.w	r11,r7[0x48]
8000afae:	58 0b       	cp.w	r11,0
8000afb0:	c0 70       	breq	8000afbe <_fclose_r+0xaa>
8000afb2:	0c 9c       	mov	r12,r6
8000afb4:	fe b0 f9 4c 	rcall	8000a24c <_free_r>
8000afb8:	30 08       	mov	r8,0
8000afba:	ef 48 00 48 	st.w	r7[72],r8
8000afbe:	30 08       	mov	r8,0
8000afc0:	ae 68       	st.h	r7[0xc],r8
8000afc2:	fe b0 f8 5a 	rcall	8000a076 <__sfp_lock_release>
8000afc6:	0a 9c       	mov	r12,r5
8000afc8:	d8 22       	popm	r4-r7,pc
8000afca:	d7 03       	nop

8000afcc <fclose>:
8000afcc:	d4 01       	pushm	lr
8000afce:	e0 68 0a 20 	mov	r8,2592
8000afd2:	18 9b       	mov	r11,r12
8000afd4:	70 0c       	ld.w	r12,r8[0x0]
8000afd6:	c9 ff       	rcall	8000af14 <_fclose_r>
8000afd8:	d8 02       	popm	pc
8000afda:	d7 03       	nop

8000afdc <_fstat_r>:
8000afdc:	d4 21       	pushm	r4-r7,lr
8000afde:	16 98       	mov	r8,r11
8000afe0:	18 97       	mov	r7,r12
8000afe2:	10 9c       	mov	r12,r8
8000afe4:	30 08       	mov	r8,0
8000afe6:	e0 66 1f d4 	mov	r6,8148
8000afea:	14 9b       	mov	r11,r10
8000afec:	8d 08       	st.w	r6[0x0],r8
8000afee:	fe b0 df 67 	rcall	80006ebc <_fstat>
8000aff2:	5b fc       	cp.w	r12,-1
8000aff4:	c0 51       	brne	8000affe <_fstat_r+0x22>
8000aff6:	6c 08       	ld.w	r8,r6[0x0]
8000aff8:	58 08       	cp.w	r8,0
8000affa:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000affe:	d8 22       	popm	r4-r7,pc

8000b000 <_lseek_r>:
8000b000:	d4 21       	pushm	r4-r7,lr
8000b002:	16 98       	mov	r8,r11
8000b004:	18 97       	mov	r7,r12
8000b006:	10 9c       	mov	r12,r8
8000b008:	30 08       	mov	r8,0
8000b00a:	14 9b       	mov	r11,r10
8000b00c:	e0 66 1f d4 	mov	r6,8148
8000b010:	12 9a       	mov	r10,r9
8000b012:	8d 08       	st.w	r6[0x0],r8
8000b014:	fe b0 df 36 	rcall	80006e80 <_lseek>
8000b018:	5b fc       	cp.w	r12,-1
8000b01a:	c0 51       	brne	8000b024 <_lseek_r+0x24>
8000b01c:	6c 08       	ld.w	r8,r6[0x0]
8000b01e:	58 08       	cp.w	r8,0
8000b020:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b024:	d8 22       	popm	r4-r7,pc
8000b026:	d7 03       	nop

8000b028 <_read_r>:
8000b028:	d4 21       	pushm	r4-r7,lr
8000b02a:	16 98       	mov	r8,r11
8000b02c:	18 97       	mov	r7,r12
8000b02e:	10 9c       	mov	r12,r8
8000b030:	30 08       	mov	r8,0
8000b032:	14 9b       	mov	r11,r10
8000b034:	e0 66 1f d4 	mov	r6,8148
8000b038:	12 9a       	mov	r10,r9
8000b03a:	8d 08       	st.w	r6[0x0],r8
8000b03c:	fe b0 d1 76 	rcall	80005328 <_read>
8000b040:	5b fc       	cp.w	r12,-1
8000b042:	c0 51       	brne	8000b04c <_read_r+0x24>
8000b044:	6c 08       	ld.w	r8,r6[0x0]
8000b046:	58 08       	cp.w	r8,0
8000b048:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b04c:	d8 22       	popm	r4-r7,pc
8000b04e:	d7 03       	nop

8000b050 <__avr32_f64_mul>:
8000b050:	f5 eb 10 1c 	or	r12,r10,r11<<0x1
8000b054:	e0 80 00 dc 	breq	8000b20c <__avr32_f64_mul_op1_zero>
8000b058:	d4 21       	pushm	r4-r7,lr
8000b05a:	f7 e9 20 0e 	eor	lr,r11,r9
8000b05e:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000b062:	30 15       	mov	r5,1
8000b064:	c4 30       	breq	8000b0ea <__avr32_f64_mul_op1_subnormal>
8000b066:	ab 6b       	lsl	r11,0xa
8000b068:	f7 ea 13 6b 	or	r11,r11,r10>>0x16
8000b06c:	ab 6a       	lsl	r10,0xa
8000b06e:	f7 d5 d3 c2 	bfins	r11,r5,0x1e,0x2
8000b072:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000b076:	c5 c0       	breq	8000b12e <__avr32_f64_mul_op2_subnormal>
8000b078:	a1 78       	lsl	r8,0x1
8000b07a:	5c f9       	rol	r9
8000b07c:	f3 d5 d2 ab 	bfins	r9,r5,0x15,0xb
8000b080:	e0 47 07 ff 	cp.w	r7,2047
8000b084:	c7 70       	breq	8000b172 <__avr32_f64_mul_op_nan_or_inf>
8000b086:	e0 46 07 ff 	cp.w	r6,2047
8000b08a:	c7 40       	breq	8000b172 <__avr32_f64_mul_op_nan_or_inf>
8000b08c:	ee 06 00 0c 	add	r12,r7,r6
8000b090:	e0 2c 03 fe 	sub	r12,1022
8000b094:	f6 08 06 44 	mulu.d	r4,r11,r8
8000b098:	f4 09 07 44 	macu.d	r4,r10,r9
8000b09c:	f4 08 06 46 	mulu.d	r6,r10,r8
8000b0a0:	f6 09 06 4a 	mulu.d	r10,r11,r9
8000b0a4:	08 07       	add	r7,r4
8000b0a6:	f4 05 00 4a 	adc	r10,r10,r5
8000b0aa:	5c 0b       	acr	r11
8000b0ac:	ed bb 00 14 	bld	r11,0x14
8000b0b0:	c0 50       	breq	8000b0ba <__avr32_f64_mul+0x6a>
8000b0b2:	a1 77       	lsl	r7,0x1
8000b0b4:	5c fa       	rol	r10
8000b0b6:	5c fb       	rol	r11
8000b0b8:	20 1c       	sub	r12,1
8000b0ba:	58 0c       	cp.w	r12,0
8000b0bc:	e0 8a 00 6f 	brle	8000b19a <__avr32_f64_mul_res_subnormal>
8000b0c0:	e0 4c 07 ff 	cp.w	r12,2047
8000b0c4:	e0 84 00 9c 	brge	8000b1fc <__avr32_f64_mul_res_inf>
8000b0c8:	f7 dc d2 8b 	bfins	r11,r12,0x14,0xb
8000b0cc:	ed ea 11 f6 	or	r6,r6,r10<<0x1f
8000b0d0:	ef e6 12 17 	or	r7,r7,r6>>0x1
8000b0d4:	ee 17 80 00 	eorh	r7,0x8000
8000b0d8:	f1 b7 04 20 	satu	r7,0x1
8000b0dc:	0e 0a       	add	r10,r7
8000b0de:	5c 0b       	acr	r11
8000b0e0:	ed be 00 1f 	bld	lr,0x1f
8000b0e4:	ef bb 00 1f 	bst	r11,0x1f
8000b0e8:	d8 22       	popm	r4-r7,pc

8000b0ea <__avr32_f64_mul_op1_subnormal>:
8000b0ea:	e4 1b 00 0f 	andh	r11,0xf
8000b0ee:	f4 0c 12 00 	clz	r12,r10
8000b0f2:	f6 06 12 00 	clz	r6,r11
8000b0f6:	f7 bc 03 e1 	sublo	r12,-31
8000b0fa:	f8 06 17 30 	movlo	r6,r12
8000b0fe:	f7 b6 02 01 	subhs	r6,1
8000b102:	e0 46 00 20 	cp.w	r6,32
8000b106:	c0 d4       	brge	8000b120 <__avr32_f64_mul_op1_subnormal+0x36>
8000b108:	ec 0c 11 20 	rsub	r12,r6,32
8000b10c:	f6 06 09 4b 	lsl	r11,r11,r6
8000b110:	f4 0c 0a 4c 	lsr	r12,r10,r12
8000b114:	18 4b       	or	r11,r12
8000b116:	f4 06 09 4a 	lsl	r10,r10,r6
8000b11a:	20 b6       	sub	r6,11
8000b11c:	0c 17       	sub	r7,r6
8000b11e:	ca ab       	rjmp	8000b072 <__avr32_f64_mul+0x22>
8000b120:	f4 06 09 4b 	lsl	r11,r10,r6
8000b124:	c6 40       	breq	8000b1ec <__avr32_f64_mul_res_zero>
8000b126:	30 0a       	mov	r10,0
8000b128:	20 b6       	sub	r6,11
8000b12a:	0c 17       	sub	r7,r6
8000b12c:	ca 3b       	rjmp	8000b072 <__avr32_f64_mul+0x22>

8000b12e <__avr32_f64_mul_op2_subnormal>:
8000b12e:	e4 19 00 0f 	andh	r9,0xf
8000b132:	f0 0c 12 00 	clz	r12,r8
8000b136:	f2 05 12 00 	clz	r5,r9
8000b13a:	f7 bc 03 ea 	sublo	r12,-22
8000b13e:	f8 05 17 30 	movlo	r5,r12
8000b142:	f7 b5 02 0a 	subhs	r5,10
8000b146:	e0 45 00 20 	cp.w	r5,32
8000b14a:	c0 d4       	brge	8000b164 <__avr32_f64_mul_op2_subnormal+0x36>
8000b14c:	ea 0c 11 20 	rsub	r12,r5,32
8000b150:	f2 05 09 49 	lsl	r9,r9,r5
8000b154:	f0 0c 0a 4c 	lsr	r12,r8,r12
8000b158:	18 49       	or	r9,r12
8000b15a:	f0 05 09 48 	lsl	r8,r8,r5
8000b15e:	20 25       	sub	r5,2
8000b160:	0a 16       	sub	r6,r5
8000b162:	c8 fb       	rjmp	8000b080 <__avr32_f64_mul+0x30>
8000b164:	f0 05 09 49 	lsl	r9,r8,r5
8000b168:	c4 20       	breq	8000b1ec <__avr32_f64_mul_res_zero>
8000b16a:	30 08       	mov	r8,0
8000b16c:	20 25       	sub	r5,2
8000b16e:	0a 16       	sub	r6,r5
8000b170:	c8 8b       	rjmp	8000b080 <__avr32_f64_mul+0x30>

8000b172 <__avr32_f64_mul_op_nan_or_inf>:
8000b172:	e4 19 00 0f 	andh	r9,0xf
8000b176:	e4 1b 00 0f 	andh	r11,0xf
8000b17a:	14 4b       	or	r11,r10
8000b17c:	10 49       	or	r9,r8
8000b17e:	e0 47 07 ff 	cp.w	r7,2047
8000b182:	c0 91       	brne	8000b194 <__avr32_f64_mul_op1_not_naninf>
8000b184:	58 0b       	cp.w	r11,0
8000b186:	c3 81       	brne	8000b1f6 <__avr32_f64_mul_res_nan>
8000b188:	e0 46 07 ff 	cp.w	r6,2047
8000b18c:	c3 81       	brne	8000b1fc <__avr32_f64_mul_res_inf>
8000b18e:	58 09       	cp.w	r9,0
8000b190:	c3 60       	breq	8000b1fc <__avr32_f64_mul_res_inf>
8000b192:	c3 28       	rjmp	8000b1f6 <__avr32_f64_mul_res_nan>

8000b194 <__avr32_f64_mul_op1_not_naninf>:
8000b194:	58 09       	cp.w	r9,0
8000b196:	c3 30       	breq	8000b1fc <__avr32_f64_mul_res_inf>
8000b198:	c2 f8       	rjmp	8000b1f6 <__avr32_f64_mul_res_nan>

8000b19a <__avr32_f64_mul_res_subnormal>:
8000b19a:	5c 3c       	neg	r12
8000b19c:	2f fc       	sub	r12,-1
8000b19e:	f1 bc 04 c0 	satu	r12,0x6
8000b1a2:	e0 4c 00 20 	cp.w	r12,32
8000b1a6:	c1 14       	brge	8000b1c8 <__avr32_f64_mul_res_subnormal+0x2e>
8000b1a8:	f8 08 11 20 	rsub	r8,r12,32
8000b1ac:	0e 46       	or	r6,r7
8000b1ae:	ee 0c 0a 47 	lsr	r7,r7,r12
8000b1b2:	f4 08 09 49 	lsl	r9,r10,r8
8000b1b6:	12 47       	or	r7,r9
8000b1b8:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000b1bc:	f6 08 09 49 	lsl	r9,r11,r8
8000b1c0:	12 4a       	or	r10,r9
8000b1c2:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000b1c6:	c8 3b       	rjmp	8000b0cc <__avr32_f64_mul+0x7c>
8000b1c8:	f8 08 11 20 	rsub	r8,r12,32
8000b1cc:	f9 b9 00 00 	moveq	r9,0
8000b1d0:	c0 30       	breq	8000b1d6 <__avr32_f64_mul_res_subnormal+0x3c>
8000b1d2:	f6 08 09 49 	lsl	r9,r11,r8
8000b1d6:	0e 46       	or	r6,r7
8000b1d8:	ed ea 10 16 	or	r6,r6,r10<<0x1
8000b1dc:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000b1e0:	f3 ea 10 07 	or	r7,r9,r10
8000b1e4:	f6 0c 0a 4a 	lsr	r10,r11,r12
8000b1e8:	30 0b       	mov	r11,0
8000b1ea:	c7 1b       	rjmp	8000b0cc <__avr32_f64_mul+0x7c>

8000b1ec <__avr32_f64_mul_res_zero>:
8000b1ec:	1c 9b       	mov	r11,lr
8000b1ee:	e6 1b 80 00 	andh	r11,0x8000,COH
8000b1f2:	30 0a       	mov	r10,0
8000b1f4:	d8 22       	popm	r4-r7,pc

8000b1f6 <__avr32_f64_mul_res_nan>:
8000b1f6:	3f fb       	mov	r11,-1
8000b1f8:	3f fa       	mov	r10,-1
8000b1fa:	d8 22       	popm	r4-r7,pc

8000b1fc <__avr32_f64_mul_res_inf>:
8000b1fc:	f0 6b 00 00 	mov	r11,-1048576
8000b200:	ed be 00 1f 	bld	lr,0x1f
8000b204:	ef bb 00 1f 	bst	r11,0x1f
8000b208:	30 0a       	mov	r10,0
8000b20a:	d8 22       	popm	r4-r7,pc

8000b20c <__avr32_f64_mul_op1_zero>:
8000b20c:	f7 e9 20 0b 	eor	r11,r11,r9
8000b210:	e6 1b 80 00 	andh	r11,0x8000,COH
8000b214:	f9 d9 c2 8b 	bfextu	r12,r9,0x14,0xb
8000b218:	e0 4c 07 ff 	cp.w	r12,2047
8000b21c:	5e 1c       	retne	r12
8000b21e:	3f fa       	mov	r10,-1
8000b220:	3f fb       	mov	r11,-1
8000b222:	5e fc       	retal	r12

8000b224 <__avr32_f64_sub_from_add>:
8000b224:	ee 19 80 00 	eorh	r9,0x8000

8000b228 <__avr32_f64_sub>:
8000b228:	f7 e9 20 0c 	eor	r12,r11,r9
8000b22c:	e0 86 00 ca 	brmi	8000b3c0 <__avr32_f64_add_from_sub>
8000b230:	eb cd 40 e0 	pushm	r5-r7,lr
8000b234:	16 9c       	mov	r12,r11
8000b236:	e6 1c 80 00 	andh	r12,0x8000,COH
8000b23a:	bf db       	cbr	r11,0x1f
8000b23c:	bf d9       	cbr	r9,0x1f
8000b23e:	10 3a       	cp.w	r10,r8
8000b240:	f2 0b 13 00 	cpc	r11,r9
8000b244:	c0 92       	brcc	8000b256 <__avr32_f64_sub+0x2e>
8000b246:	16 97       	mov	r7,r11
8000b248:	12 9b       	mov	r11,r9
8000b24a:	0e 99       	mov	r9,r7
8000b24c:	14 97       	mov	r7,r10
8000b24e:	10 9a       	mov	r10,r8
8000b250:	0e 98       	mov	r8,r7
8000b252:	ee 1c 80 00 	eorh	r12,0x8000
8000b256:	f6 07 16 14 	lsr	r7,r11,0x14
8000b25a:	ab 7b       	lsl	r11,0xb
8000b25c:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000b260:	ab 7a       	lsl	r10,0xb
8000b262:	bf bb       	sbr	r11,0x1f
8000b264:	f2 06 16 14 	lsr	r6,r9,0x14
8000b268:	c4 40       	breq	8000b2f0 <__avr32_f64_sub_opL_subnormal>
8000b26a:	ab 79       	lsl	r9,0xb
8000b26c:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000b270:	ab 78       	lsl	r8,0xb
8000b272:	bf b9       	sbr	r9,0x1f

8000b274 <__avr32_f64_sub_opL_subnormal_done>:
8000b274:	e0 47 07 ff 	cp.w	r7,2047
8000b278:	c4 f0       	breq	8000b316 <__avr32_f64_sub_opH_nan_or_inf>
8000b27a:	0e 26       	rsub	r6,r7
8000b27c:	c1 20       	breq	8000b2a0 <__avr32_f64_sub_shift_done>
8000b27e:	ec 05 11 20 	rsub	r5,r6,32
8000b282:	e0 46 00 20 	cp.w	r6,32
8000b286:	c7 c2       	brcc	8000b37e <__avr32_f64_sub_longshift>
8000b288:	f0 05 09 4e 	lsl	lr,r8,r5
8000b28c:	f2 05 09 45 	lsl	r5,r9,r5
8000b290:	f0 06 0a 48 	lsr	r8,r8,r6
8000b294:	f2 06 0a 49 	lsr	r9,r9,r6
8000b298:	0a 48       	or	r8,r5
8000b29a:	58 0e       	cp.w	lr,0
8000b29c:	5f 1e       	srne	lr
8000b29e:	1c 48       	or	r8,lr

8000b2a0 <__avr32_f64_sub_shift_done>:
8000b2a0:	10 1a       	sub	r10,r8
8000b2a2:	f6 09 01 4b 	sbc	r11,r11,r9
8000b2a6:	f6 06 12 00 	clz	r6,r11
8000b2aa:	c0 e0       	breq	8000b2c6 <__avr32_f64_sub_longnormalize_done>
8000b2ac:	c7 83       	brcs	8000b39c <__avr32_f64_sub_longnormalize>
8000b2ae:	ec 0e 11 20 	rsub	lr,r6,32
8000b2b2:	f6 06 09 4b 	lsl	r11,r11,r6
8000b2b6:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000b2ba:	1c 4b       	or	r11,lr
8000b2bc:	f4 06 09 4a 	lsl	r10,r10,r6
8000b2c0:	0c 17       	sub	r7,r6
8000b2c2:	e0 8a 00 39 	brle	8000b334 <__avr32_f64_sub_subnormal_result>

8000b2c6 <__avr32_f64_sub_longnormalize_done>:
8000b2c6:	f4 09 15 15 	lsl	r9,r10,0x15
8000b2ca:	ab 9a       	lsr	r10,0xb
8000b2cc:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000b2d0:	ab 9b       	lsr	r11,0xb
8000b2d2:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000b2d6:	18 4b       	or	r11,r12

8000b2d8 <__avr32_f64_sub_round>:
8000b2d8:	fc 17 80 00 	movh	r7,0x8000
8000b2dc:	ed ba 00 00 	bld	r10,0x0
8000b2e0:	f7 b7 01 ff 	subne	r7,-1
8000b2e4:	0e 39       	cp.w	r9,r7
8000b2e6:	5f 29       	srhs	r9
8000b2e8:	12 0a       	add	r10,r9
8000b2ea:	5c 0b       	acr	r11
8000b2ec:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b2f0 <__avr32_f64_sub_opL_subnormal>:
8000b2f0:	ab 79       	lsl	r9,0xb
8000b2f2:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000b2f6:	ab 78       	lsl	r8,0xb
8000b2f8:	f3 e8 10 0e 	or	lr,r9,r8
8000b2fc:	f9 b6 01 01 	movne	r6,1
8000b300:	ee 0e 11 00 	rsub	lr,r7,0
8000b304:	f9 b7 00 01 	moveq	r7,1
8000b308:	ef bb 00 1f 	bst	r11,0x1f
8000b30c:	f7 ea 10 0e 	or	lr,r11,r10
8000b310:	f9 b7 00 00 	moveq	r7,0
8000b314:	cb 0b       	rjmp	8000b274 <__avr32_f64_sub_opL_subnormal_done>

8000b316 <__avr32_f64_sub_opH_nan_or_inf>:
8000b316:	bf db       	cbr	r11,0x1f
8000b318:	f7 ea 10 0e 	or	lr,r11,r10
8000b31c:	c0 81       	brne	8000b32c <__avr32_f64_sub_return_nan>
8000b31e:	e0 46 07 ff 	cp.w	r6,2047
8000b322:	c0 50       	breq	8000b32c <__avr32_f64_sub_return_nan>
8000b324:	f9 e7 11 4b 	or	r11,r12,r7<<0x14
8000b328:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b32c <__avr32_f64_sub_return_nan>:
8000b32c:	3f fa       	mov	r10,-1
8000b32e:	3f fb       	mov	r11,-1
8000b330:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b334 <__avr32_f64_sub_subnormal_result>:
8000b334:	5c 37       	neg	r7
8000b336:	2f f7       	sub	r7,-1
8000b338:	f1 b7 04 c0 	satu	r7,0x6
8000b33c:	e0 47 00 20 	cp.w	r7,32
8000b340:	c1 14       	brge	8000b362 <__avr32_f64_sub_subnormal_result+0x2e>
8000b342:	ee 08 11 20 	rsub	r8,r7,32
8000b346:	f4 08 09 49 	lsl	r9,r10,r8
8000b34a:	5f 16       	srne	r6
8000b34c:	f4 07 0a 4a 	lsr	r10,r10,r7
8000b350:	0c 4a       	or	r10,r6
8000b352:	f6 08 09 49 	lsl	r9,r11,r8
8000b356:	f5 e9 10 0a 	or	r10,r10,r9
8000b35a:	f4 07 0a 4b 	lsr	r11,r10,r7
8000b35e:	30 07       	mov	r7,0
8000b360:	cb 3b       	rjmp	8000b2c6 <__avr32_f64_sub_longnormalize_done>
8000b362:	ee 08 11 40 	rsub	r8,r7,64
8000b366:	f6 08 09 49 	lsl	r9,r11,r8
8000b36a:	14 49       	or	r9,r10
8000b36c:	5f 16       	srne	r6
8000b36e:	f6 07 0a 4a 	lsr	r10,r11,r7
8000b372:	0c 4a       	or	r10,r6
8000b374:	30 0b       	mov	r11,0
8000b376:	30 07       	mov	r7,0
8000b378:	ca 7b       	rjmp	8000b2c6 <__avr32_f64_sub_longnormalize_done>
8000b37a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b37e <__avr32_f64_sub_longshift>:
8000b37e:	f1 b6 04 c0 	satu	r6,0x6
8000b382:	f0 0e 17 00 	moveq	lr,r8
8000b386:	c0 40       	breq	8000b38e <__avr32_f64_sub_longshift+0x10>
8000b388:	f2 05 09 4e 	lsl	lr,r9,r5
8000b38c:	10 4e       	or	lr,r8
8000b38e:	f2 06 0a 48 	lsr	r8,r9,r6
8000b392:	30 09       	mov	r9,0
8000b394:	58 0e       	cp.w	lr,0
8000b396:	5f 1e       	srne	lr
8000b398:	1c 48       	or	r8,lr
8000b39a:	c8 3b       	rjmp	8000b2a0 <__avr32_f64_sub_shift_done>

8000b39c <__avr32_f64_sub_longnormalize>:
8000b39c:	f4 06 12 00 	clz	r6,r10
8000b3a0:	f9 b7 03 00 	movlo	r7,0
8000b3a4:	f9 b6 03 00 	movlo	r6,0
8000b3a8:	f9 bc 03 00 	movlo	r12,0
8000b3ac:	f7 b6 02 e0 	subhs	r6,-32
8000b3b0:	f4 06 09 4b 	lsl	r11,r10,r6
8000b3b4:	30 0a       	mov	r10,0
8000b3b6:	0c 17       	sub	r7,r6
8000b3b8:	fe 9a ff be 	brle	8000b334 <__avr32_f64_sub_subnormal_result>
8000b3bc:	c8 5b       	rjmp	8000b2c6 <__avr32_f64_sub_longnormalize_done>
8000b3be:	d7 03       	nop

8000b3c0 <__avr32_f64_add_from_sub>:
8000b3c0:	ee 19 80 00 	eorh	r9,0x8000

8000b3c4 <__avr32_f64_add>:
8000b3c4:	f7 e9 20 0c 	eor	r12,r11,r9
8000b3c8:	fe 96 ff 2e 	brmi	8000b224 <__avr32_f64_sub_from_add>
8000b3cc:	eb cd 40 e0 	pushm	r5-r7,lr
8000b3d0:	16 9c       	mov	r12,r11
8000b3d2:	e6 1c 80 00 	andh	r12,0x8000,COH
8000b3d6:	bf db       	cbr	r11,0x1f
8000b3d8:	bf d9       	cbr	r9,0x1f
8000b3da:	12 3b       	cp.w	r11,r9
8000b3dc:	c0 72       	brcc	8000b3ea <__avr32_f64_add+0x26>
8000b3de:	16 97       	mov	r7,r11
8000b3e0:	12 9b       	mov	r11,r9
8000b3e2:	0e 99       	mov	r9,r7
8000b3e4:	14 97       	mov	r7,r10
8000b3e6:	10 9a       	mov	r10,r8
8000b3e8:	0e 98       	mov	r8,r7
8000b3ea:	30 0e       	mov	lr,0
8000b3ec:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000b3f0:	f7 db c0 14 	bfextu	r11,r11,0x0,0x14
8000b3f4:	b5 ab       	sbr	r11,0x14
8000b3f6:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000b3fa:	c6 20       	breq	8000b4be <__avr32_f64_add_op2_subnormal>
8000b3fc:	f3 d9 c0 14 	bfextu	r9,r9,0x0,0x14
8000b400:	b5 a9       	sbr	r9,0x14
8000b402:	e0 47 07 ff 	cp.w	r7,2047
8000b406:	c2 80       	breq	8000b456 <__avr32_f64_add_opH_nan_or_inf>
8000b408:	0e 26       	rsub	r6,r7
8000b40a:	c1 20       	breq	8000b42e <__avr32_f64_add_shift_done>
8000b40c:	e0 46 00 36 	cp.w	r6,54
8000b410:	c1 52       	brcc	8000b43a <__avr32_f64_add_res_of_done>
8000b412:	ec 05 11 20 	rsub	r5,r6,32
8000b416:	e0 46 00 20 	cp.w	r6,32
8000b41a:	c3 52       	brcc	8000b484 <__avr32_f64_add_longshift>
8000b41c:	f0 05 09 4e 	lsl	lr,r8,r5
8000b420:	f2 05 09 45 	lsl	r5,r9,r5
8000b424:	f0 06 0a 48 	lsr	r8,r8,r6
8000b428:	f2 06 0a 49 	lsr	r9,r9,r6
8000b42c:	0a 48       	or	r8,r5

8000b42e <__avr32_f64_add_shift_done>:
8000b42e:	10 0a       	add	r10,r8
8000b430:	f6 09 00 4b 	adc	r11,r11,r9
8000b434:	ed bb 00 15 	bld	r11,0x15
8000b438:	c3 40       	breq	8000b4a0 <__avr32_f64_add_res_of>

8000b43a <__avr32_f64_add_res_of_done>:
8000b43a:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000b43e:	18 4b       	or	r11,r12

8000b440 <__avr32_f64_add_round>:
8000b440:	f9 da c0 01 	bfextu	r12,r10,0x0,0x1
8000b444:	18 4e       	or	lr,r12
8000b446:	ee 1e 80 00 	eorh	lr,0x8000
8000b44a:	f1 be 04 20 	satu	lr,0x1
8000b44e:	1c 0a       	add	r10,lr
8000b450:	5c 0b       	acr	r11
8000b452:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b456 <__avr32_f64_add_opH_nan_or_inf>:
8000b456:	b5 cb       	cbr	r11,0x14
8000b458:	f7 ea 10 0e 	or	lr,r11,r10
8000b45c:	c1 01       	brne	8000b47c <__avr32_f64_add_return_nan>
8000b45e:	e0 46 07 ff 	cp.w	r6,2047
8000b462:	c0 30       	breq	8000b468 <__avr32_f64_add_opL_nan_or_inf>
8000b464:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b468 <__avr32_f64_add_opL_nan_or_inf>:
8000b468:	b5 c9       	cbr	r9,0x14
8000b46a:	f3 e8 10 0e 	or	lr,r9,r8
8000b46e:	c0 71       	brne	8000b47c <__avr32_f64_add_return_nan>
8000b470:	30 0a       	mov	r10,0
8000b472:	fc 1b 7f f0 	movh	r11,0x7ff0
8000b476:	18 4b       	or	r11,r12
8000b478:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b47c <__avr32_f64_add_return_nan>:
8000b47c:	3f fa       	mov	r10,-1
8000b47e:	3f fb       	mov	r11,-1
8000b480:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b484 <__avr32_f64_add_longshift>:
8000b484:	f1 b6 04 c0 	satu	r6,0x6
8000b488:	f0 0e 17 00 	moveq	lr,r8
8000b48c:	c0 60       	breq	8000b498 <__avr32_f64_add_longshift+0x14>
8000b48e:	f2 05 09 4e 	lsl	lr,r9,r5
8000b492:	58 08       	cp.w	r8,0
8000b494:	5f 18       	srne	r8
8000b496:	10 4e       	or	lr,r8
8000b498:	f2 06 0a 48 	lsr	r8,r9,r6
8000b49c:	30 09       	mov	r9,0
8000b49e:	cc 8b       	rjmp	8000b42e <__avr32_f64_add_shift_done>

8000b4a0 <__avr32_f64_add_res_of>:
8000b4a0:	fd ee 10 1e 	or	lr,lr,lr<<0x1
8000b4a4:	a1 9b       	lsr	r11,0x1
8000b4a6:	5d 0a       	ror	r10
8000b4a8:	5d 0e       	ror	lr
8000b4aa:	2f f7       	sub	r7,-1
8000b4ac:	e0 47 07 ff 	cp.w	r7,2047
8000b4b0:	f9 ba 00 00 	moveq	r10,0
8000b4b4:	f9 bb 00 00 	moveq	r11,0
8000b4b8:	f9 be 00 00 	moveq	lr,0
8000b4bc:	cb fb       	rjmp	8000b43a <__avr32_f64_add_res_of_done>

8000b4be <__avr32_f64_add_op2_subnormal>:
8000b4be:	30 16       	mov	r6,1
8000b4c0:	58 07       	cp.w	r7,0
8000b4c2:	ca 01       	brne	8000b402 <__avr32_f64_add+0x3e>
8000b4c4:	b5 cb       	cbr	r11,0x14
8000b4c6:	10 0a       	add	r10,r8
8000b4c8:	f6 09 00 4b 	adc	r11,r11,r9
8000b4cc:	18 4b       	or	r11,r12
8000b4ce:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000b4d2:	d7 03       	nop

8000b4d4 <__avr32_f64_to_u32>:
8000b4d4:	58 0b       	cp.w	r11,0
8000b4d6:	5e 6d       	retmi	0

8000b4d8 <__avr32_f64_to_s32>:
8000b4d8:	f6 0c 15 01 	lsl	r12,r11,0x1
8000b4dc:	b5 9c       	lsr	r12,0x15
8000b4de:	e0 2c 03 ff 	sub	r12,1023
8000b4e2:	5e 3d       	retlo	0
8000b4e4:	f8 0c 11 1f 	rsub	r12,r12,31
8000b4e8:	16 99       	mov	r9,r11
8000b4ea:	ab 7b       	lsl	r11,0xb
8000b4ec:	bf bb       	sbr	r11,0x1f
8000b4ee:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000b4f2:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000b4f6:	a1 79       	lsl	r9,0x1
8000b4f8:	5e 2b       	reths	r11
8000b4fa:	5c 3b       	neg	r11
8000b4fc:	5e fb       	retal	r11

8000b4fe <__avr32_u32_to_f64>:
8000b4fe:	f8 cb 00 00 	sub	r11,r12,0
8000b502:	30 0c       	mov	r12,0
8000b504:	c0 38       	rjmp	8000b50a <__avr32_s32_to_f64+0x4>

8000b506 <__avr32_s32_to_f64>:
8000b506:	18 9b       	mov	r11,r12
8000b508:	5c 4b       	abs	r11
8000b50a:	30 0a       	mov	r10,0
8000b50c:	5e 0b       	reteq	r11
8000b50e:	d4 01       	pushm	lr
8000b510:	e0 69 04 1e 	mov	r9,1054
8000b514:	f6 08 12 00 	clz	r8,r11
8000b518:	c1 70       	breq	8000b546 <__avr32_s32_to_f64+0x40>
8000b51a:	c0 c3       	brcs	8000b532 <__avr32_s32_to_f64+0x2c>
8000b51c:	f0 0e 11 20 	rsub	lr,r8,32
8000b520:	f6 08 09 4b 	lsl	r11,r11,r8
8000b524:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000b528:	1c 4b       	or	r11,lr
8000b52a:	f4 08 09 4a 	lsl	r10,r10,r8
8000b52e:	10 19       	sub	r9,r8
8000b530:	c0 b8       	rjmp	8000b546 <__avr32_s32_to_f64+0x40>
8000b532:	f4 08 12 00 	clz	r8,r10
8000b536:	f9 b8 03 00 	movlo	r8,0
8000b53a:	f7 b8 02 e0 	subhs	r8,-32
8000b53e:	f4 08 09 4b 	lsl	r11,r10,r8
8000b542:	30 0a       	mov	r10,0
8000b544:	10 19       	sub	r9,r8
8000b546:	58 09       	cp.w	r9,0
8000b548:	e0 89 00 30 	brgt	8000b5a8 <__avr32_s32_to_f64+0xa2>
8000b54c:	5c 39       	neg	r9
8000b54e:	2f f9       	sub	r9,-1
8000b550:	e0 49 00 36 	cp.w	r9,54
8000b554:	c0 43       	brcs	8000b55c <__avr32_s32_to_f64+0x56>
8000b556:	30 0b       	mov	r11,0
8000b558:	30 0a       	mov	r10,0
8000b55a:	c2 68       	rjmp	8000b5a6 <__avr32_s32_to_f64+0xa0>
8000b55c:	2f 69       	sub	r9,-10
8000b55e:	f2 08 11 20 	rsub	r8,r9,32
8000b562:	e0 49 00 20 	cp.w	r9,32
8000b566:	c0 b2       	brcc	8000b57c <__avr32_s32_to_f64+0x76>
8000b568:	f4 08 09 4e 	lsl	lr,r10,r8
8000b56c:	f6 08 09 48 	lsl	r8,r11,r8
8000b570:	f4 09 0a 4a 	lsr	r10,r10,r9
8000b574:	f6 09 0a 4b 	lsr	r11,r11,r9
8000b578:	10 4b       	or	r11,r8
8000b57a:	c0 88       	rjmp	8000b58a <__avr32_s32_to_f64+0x84>
8000b57c:	f6 08 09 4e 	lsl	lr,r11,r8
8000b580:	14 4e       	or	lr,r10
8000b582:	16 9a       	mov	r10,r11
8000b584:	30 0b       	mov	r11,0
8000b586:	f4 09 0a 4a 	lsr	r10,r10,r9
8000b58a:	ed ba 00 00 	bld	r10,0x0
8000b58e:	c0 92       	brcc	8000b5a0 <__avr32_s32_to_f64+0x9a>
8000b590:	1c 7e       	tst	lr,lr
8000b592:	c0 41       	brne	8000b59a <__avr32_s32_to_f64+0x94>
8000b594:	ed ba 00 01 	bld	r10,0x1
8000b598:	c0 42       	brcc	8000b5a0 <__avr32_s32_to_f64+0x9a>
8000b59a:	2f fa       	sub	r10,-1
8000b59c:	f7 bb 02 ff 	subhs	r11,-1
8000b5a0:	5c fc       	rol	r12
8000b5a2:	5d 0b       	ror	r11
8000b5a4:	5d 0a       	ror	r10
8000b5a6:	d8 02       	popm	pc
8000b5a8:	e0 68 03 ff 	mov	r8,1023
8000b5ac:	ed ba 00 0b 	bld	r10,0xb
8000b5b0:	f7 b8 00 ff 	subeq	r8,-1
8000b5b4:	10 0a       	add	r10,r8
8000b5b6:	5c 0b       	acr	r11
8000b5b8:	f7 b9 03 fe 	sublo	r9,-2
8000b5bc:	e0 49 07 ff 	cp.w	r9,2047
8000b5c0:	c0 55       	brlt	8000b5ca <__avr32_s32_to_f64+0xc4>
8000b5c2:	30 0a       	mov	r10,0
8000b5c4:	fc 1b ff e0 	movh	r11,0xffe0
8000b5c8:	c0 c8       	rjmp	8000b5e0 <__floatsidf_return_op1>
8000b5ca:	ed bb 00 1f 	bld	r11,0x1f
8000b5ce:	f7 b9 01 01 	subne	r9,1
8000b5d2:	ab 9a       	lsr	r10,0xb
8000b5d4:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000b5d8:	a1 7b       	lsl	r11,0x1
8000b5da:	ab 9b       	lsr	r11,0xb
8000b5dc:	f7 e9 11 5b 	or	r11,r11,r9<<0x15

8000b5e0 <__floatsidf_return_op1>:
8000b5e0:	a1 7c       	lsl	r12,0x1
8000b5e2:	5d 0b       	ror	r11
8000b5e4:	d8 02       	popm	pc

8000b5e6 <__avr32_f64_cmp_eq>:
8000b5e6:	10 3a       	cp.w	r10,r8
8000b5e8:	f2 0b 13 00 	cpc	r11,r9
8000b5ec:	c0 80       	breq	8000b5fc <__avr32_f64_cmp_eq+0x16>
8000b5ee:	a1 7b       	lsl	r11,0x1
8000b5f0:	a1 79       	lsl	r9,0x1
8000b5f2:	14 4b       	or	r11,r10
8000b5f4:	12 4b       	or	r11,r9
8000b5f6:	10 4b       	or	r11,r8
8000b5f8:	5e 0f       	reteq	1
8000b5fa:	5e fd       	retal	0
8000b5fc:	a1 7b       	lsl	r11,0x1
8000b5fe:	fc 1c ff e0 	movh	r12,0xffe0
8000b602:	58 0a       	cp.w	r10,0
8000b604:	f8 0b 13 00 	cpc	r11,r12
8000b608:	5e 8f       	retls	1
8000b60a:	5e fd       	retal	0

8000b60c <__avr32_f64_cmp_ge>:
8000b60c:	1a de       	st.w	--sp,lr
8000b60e:	1a d7       	st.w	--sp,r7
8000b610:	a1 7b       	lsl	r11,0x1
8000b612:	5f 3c       	srlo	r12
8000b614:	a1 79       	lsl	r9,0x1
8000b616:	5f 37       	srlo	r7
8000b618:	5c fc       	rol	r12
8000b61a:	fc 1e ff e0 	movh	lr,0xffe0
8000b61e:	58 0a       	cp.w	r10,0
8000b620:	fc 0b 13 00 	cpc	r11,lr
8000b624:	e0 8b 00 1d 	brhi	8000b65e <__avr32_f64_cmp_ge+0x52>
8000b628:	58 08       	cp.w	r8,0
8000b62a:	fc 09 13 00 	cpc	r9,lr
8000b62e:	e0 8b 00 18 	brhi	8000b65e <__avr32_f64_cmp_ge+0x52>
8000b632:	58 0b       	cp.w	r11,0
8000b634:	f5 ba 00 00 	subfeq	r10,0
8000b638:	c1 50       	breq	8000b662 <__avr32_f64_cmp_ge+0x56>
8000b63a:	1b 07       	ld.w	r7,sp++
8000b63c:	1b 0e       	ld.w	lr,sp++
8000b63e:	58 3c       	cp.w	r12,3
8000b640:	c0 a0       	breq	8000b654 <__avr32_f64_cmp_ge+0x48>
8000b642:	58 1c       	cp.w	r12,1
8000b644:	c0 33       	brcs	8000b64a <__avr32_f64_cmp_ge+0x3e>
8000b646:	5e 0f       	reteq	1
8000b648:	5e 1d       	retne	0
8000b64a:	10 3a       	cp.w	r10,r8
8000b64c:	f2 0b 13 00 	cpc	r11,r9
8000b650:	5e 2f       	reths	1
8000b652:	5e 3d       	retlo	0
8000b654:	14 38       	cp.w	r8,r10
8000b656:	f6 09 13 00 	cpc	r9,r11
8000b65a:	5e 2f       	reths	1
8000b65c:	5e 3d       	retlo	0
8000b65e:	1b 07       	ld.w	r7,sp++
8000b660:	d8 0a       	popm	pc,r12=0
8000b662:	58 17       	cp.w	r7,1
8000b664:	5f 0c       	sreq	r12
8000b666:	58 09       	cp.w	r9,0
8000b668:	f5 b8 00 00 	subfeq	r8,0
8000b66c:	1b 07       	ld.w	r7,sp++
8000b66e:	1b 0e       	ld.w	lr,sp++
8000b670:	5e 0f       	reteq	1
8000b672:	5e fc       	retal	r12

8000b674 <__avr32_f64_cmp_lt>:
8000b674:	1a de       	st.w	--sp,lr
8000b676:	1a d7       	st.w	--sp,r7
8000b678:	a1 7b       	lsl	r11,0x1
8000b67a:	5f 3c       	srlo	r12
8000b67c:	a1 79       	lsl	r9,0x1
8000b67e:	5f 37       	srlo	r7
8000b680:	5c fc       	rol	r12
8000b682:	fc 1e ff e0 	movh	lr,0xffe0
8000b686:	58 0a       	cp.w	r10,0
8000b688:	fc 0b 13 00 	cpc	r11,lr
8000b68c:	e0 8b 00 1d 	brhi	8000b6c6 <__avr32_f64_cmp_lt+0x52>
8000b690:	58 08       	cp.w	r8,0
8000b692:	fc 09 13 00 	cpc	r9,lr
8000b696:	e0 8b 00 18 	brhi	8000b6c6 <__avr32_f64_cmp_lt+0x52>
8000b69a:	58 0b       	cp.w	r11,0
8000b69c:	f5 ba 00 00 	subfeq	r10,0
8000b6a0:	c1 50       	breq	8000b6ca <__avr32_f64_cmp_lt+0x56>
8000b6a2:	1b 07       	ld.w	r7,sp++
8000b6a4:	1b 0e       	ld.w	lr,sp++
8000b6a6:	58 3c       	cp.w	r12,3
8000b6a8:	c0 a0       	breq	8000b6bc <__avr32_f64_cmp_lt+0x48>
8000b6aa:	58 1c       	cp.w	r12,1
8000b6ac:	c0 33       	brcs	8000b6b2 <__avr32_f64_cmp_lt+0x3e>
8000b6ae:	5e 0d       	reteq	0
8000b6b0:	5e 1f       	retne	1
8000b6b2:	10 3a       	cp.w	r10,r8
8000b6b4:	f2 0b 13 00 	cpc	r11,r9
8000b6b8:	5e 2d       	reths	0
8000b6ba:	5e 3f       	retlo	1
8000b6bc:	14 38       	cp.w	r8,r10
8000b6be:	f6 09 13 00 	cpc	r9,r11
8000b6c2:	5e 2d       	reths	0
8000b6c4:	5e 3f       	retlo	1
8000b6c6:	1b 07       	ld.w	r7,sp++
8000b6c8:	d8 0a       	popm	pc,r12=0
8000b6ca:	58 17       	cp.w	r7,1
8000b6cc:	5f 1c       	srne	r12
8000b6ce:	58 09       	cp.w	r9,0
8000b6d0:	f5 b8 00 00 	subfeq	r8,0
8000b6d4:	1b 07       	ld.w	r7,sp++
8000b6d6:	1b 0e       	ld.w	lr,sp++
8000b6d8:	5e 0d       	reteq	0
8000b6da:	5e fc       	retal	r12

8000b6dc <__avr32_f64_div>:
8000b6dc:	eb cd 40 ff 	pushm	r0-r7,lr
8000b6e0:	f7 e9 20 0e 	eor	lr,r11,r9
8000b6e4:	f6 07 16 14 	lsr	r7,r11,0x14
8000b6e8:	a9 7b       	lsl	r11,0x9
8000b6ea:	f7 ea 13 7b 	or	r11,r11,r10>>0x17
8000b6ee:	a9 7a       	lsl	r10,0x9
8000b6f0:	bd bb       	sbr	r11,0x1d
8000b6f2:	e4 1b 3f ff 	andh	r11,0x3fff
8000b6f6:	ab d7       	cbr	r7,0xb
8000b6f8:	e0 80 00 cc 	breq	8000b890 <__avr32_f64_div_round_subnormal+0x54>
8000b6fc:	e0 47 07 ff 	cp.w	r7,2047
8000b700:	e0 84 00 b5 	brge	8000b86a <__avr32_f64_div_round_subnormal+0x2e>
8000b704:	f2 06 16 14 	lsr	r6,r9,0x14
8000b708:	a9 79       	lsl	r9,0x9
8000b70a:	f3 e8 13 79 	or	r9,r9,r8>>0x17
8000b70e:	a9 78       	lsl	r8,0x9
8000b710:	bd b9       	sbr	r9,0x1d
8000b712:	e4 19 3f ff 	andh	r9,0x3fff
8000b716:	ab d6       	cbr	r6,0xb
8000b718:	e0 80 00 e2 	breq	8000b8dc <__avr32_f64_div_round_subnormal+0xa0>
8000b71c:	e0 46 07 ff 	cp.w	r6,2047
8000b720:	e0 84 00 b2 	brge	8000b884 <__avr32_f64_div_round_subnormal+0x48>
8000b724:	0c 17       	sub	r7,r6
8000b726:	fe 37 fc 01 	sub	r7,-1023
8000b72a:	fc 1c 80 00 	movh	r12,0x8000
8000b72e:	f8 03 16 01 	lsr	r3,r12,0x1
8000b732:	e9 d9 c3 62 	bfextu	r4,r9,0x1b,0x2
8000b736:	5c d4       	com	r4
8000b738:	e7 d4 d3 82 	bfins	r3,r4,0x1c,0x2
8000b73c:	e6 09 06 44 	mulu.d	r4,r3,r9
8000b740:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000b744:	e6 05 06 44 	mulu.d	r4,r3,r5
8000b748:	ea 03 15 02 	lsl	r3,r5,0x2
8000b74c:	e6 09 06 44 	mulu.d	r4,r3,r9
8000b750:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000b754:	e6 05 06 44 	mulu.d	r4,r3,r5
8000b758:	ea 03 15 02 	lsl	r3,r5,0x2
8000b75c:	e6 09 06 44 	mulu.d	r4,r3,r9
8000b760:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000b764:	e6 05 06 44 	mulu.d	r4,r3,r5
8000b768:	ea 03 15 02 	lsl	r3,r5,0x2
8000b76c:	e6 08 06 40 	mulu.d	r0,r3,r8
8000b770:	e4 09 07 40 	macu.d	r0,r2,r9
8000b774:	e6 09 06 44 	mulu.d	r4,r3,r9
8000b778:	02 04       	add	r4,r1
8000b77a:	5c 05       	acr	r5
8000b77c:	a3 65       	lsl	r5,0x2
8000b77e:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000b782:	a3 64       	lsl	r4,0x2
8000b784:	5c 34       	neg	r4
8000b786:	f8 05 01 45 	sbc	r5,r12,r5
8000b78a:	e6 04 06 40 	mulu.d	r0,r3,r4
8000b78e:	e4 05 07 40 	macu.d	r0,r2,r5
8000b792:	e6 05 06 44 	mulu.d	r4,r3,r5
8000b796:	02 04       	add	r4,r1
8000b798:	5c 05       	acr	r5
8000b79a:	ea 03 15 02 	lsl	r3,r5,0x2
8000b79e:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000b7a2:	e8 02 15 02 	lsl	r2,r4,0x2
8000b7a6:	e6 08 06 40 	mulu.d	r0,r3,r8
8000b7aa:	e4 09 07 40 	macu.d	r0,r2,r9
8000b7ae:	e6 09 06 44 	mulu.d	r4,r3,r9
8000b7b2:	02 04       	add	r4,r1
8000b7b4:	5c 05       	acr	r5
8000b7b6:	a3 65       	lsl	r5,0x2
8000b7b8:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000b7bc:	a3 64       	lsl	r4,0x2
8000b7be:	5c 34       	neg	r4
8000b7c0:	f8 05 01 45 	sbc	r5,r12,r5
8000b7c4:	e6 04 06 40 	mulu.d	r0,r3,r4
8000b7c8:	e4 05 07 40 	macu.d	r0,r2,r5
8000b7cc:	e6 05 06 44 	mulu.d	r4,r3,r5
8000b7d0:	02 04       	add	r4,r1
8000b7d2:	5c 05       	acr	r5
8000b7d4:	ea 03 15 02 	lsl	r3,r5,0x2
8000b7d8:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000b7dc:	e8 02 15 02 	lsl	r2,r4,0x2
8000b7e0:	e6 0a 06 40 	mulu.d	r0,r3,r10
8000b7e4:	e4 0b 07 40 	macu.d	r0,r2,r11
8000b7e8:	e6 0b 06 42 	mulu.d	r2,r3,r11
8000b7ec:	02 02       	add	r2,r1
8000b7ee:	5c 03       	acr	r3
8000b7f0:	ed b3 00 1c 	bld	r3,0x1c
8000b7f4:	c0 90       	breq	8000b806 <__avr32_f64_div+0x12a>
8000b7f6:	a1 72       	lsl	r2,0x1
8000b7f8:	5c f3       	rol	r3
8000b7fa:	20 17       	sub	r7,1
8000b7fc:	a3 9a       	lsr	r10,0x3
8000b7fe:	f5 eb 11 da 	or	r10,r10,r11<<0x1d
8000b802:	a3 9b       	lsr	r11,0x3
8000b804:	c0 58       	rjmp	8000b80e <__avr32_f64_div+0x132>
8000b806:	a5 8a       	lsr	r10,0x4
8000b808:	f5 eb 11 ca 	or	r10,r10,r11<<0x1c
8000b80c:	a5 8b       	lsr	r11,0x4
8000b80e:	58 07       	cp.w	r7,0
8000b810:	e0 8a 00 8b 	brle	8000b926 <__avr32_f64_div_res_subnormal>
8000b814:	e0 12 ff 00 	andl	r2,0xff00
8000b818:	e8 12 00 80 	orl	r2,0x80
8000b81c:	e6 08 06 40 	mulu.d	r0,r3,r8
8000b820:	e4 09 07 40 	macu.d	r0,r2,r9
8000b824:	e4 08 06 44 	mulu.d	r4,r2,r8
8000b828:	e6 09 06 48 	mulu.d	r8,r3,r9
8000b82c:	00 05       	add	r5,r0
8000b82e:	f0 01 00 48 	adc	r8,r8,r1
8000b832:	5c 09       	acr	r9
8000b834:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000b838:	58 04       	cp.w	r4,0
8000b83a:	5c 25       	cpc	r5

8000b83c <__avr32_f64_div_round_subnormal>:
8000b83c:	f4 08 13 00 	cpc	r8,r10
8000b840:	f6 09 13 00 	cpc	r9,r11
8000b844:	5f 36       	srlo	r6
8000b846:	f8 06 17 00 	moveq	r6,r12
8000b84a:	e4 0a 16 08 	lsr	r10,r2,0x8
8000b84e:	f5 e3 11 8a 	or	r10,r10,r3<<0x18
8000b852:	e6 0b 16 08 	lsr	r11,r3,0x8
8000b856:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000b85a:	ed be 00 1f 	bld	lr,0x1f
8000b85e:	ef bb 00 1f 	bst	r11,0x1f
8000b862:	0c 0a       	add	r10,r6
8000b864:	5c 0b       	acr	r11
8000b866:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000b86a:	e4 1b 00 0f 	andh	r11,0xf
8000b86e:	14 4b       	or	r11,r10
8000b870:	e0 81 00 a7 	brne	8000b9be <__avr32_f64_div_res_subnormal+0x98>
8000b874:	f2 06 16 14 	lsr	r6,r9,0x14
8000b878:	ab d6       	cbr	r6,0xb
8000b87a:	e0 46 07 ff 	cp.w	r6,2047
8000b87e:	e0 81 00 a4 	brne	8000b9c6 <__avr32_f64_div_res_subnormal+0xa0>
8000b882:	c9 e8       	rjmp	8000b9be <__avr32_f64_div_res_subnormal+0x98>
8000b884:	e4 19 00 0f 	andh	r9,0xf
8000b888:	10 49       	or	r9,r8
8000b88a:	e0 81 00 9a 	brne	8000b9be <__avr32_f64_div_res_subnormal+0x98>
8000b88e:	c9 28       	rjmp	8000b9b2 <__avr32_f64_div_res_subnormal+0x8c>
8000b890:	a3 7b       	lsl	r11,0x3
8000b892:	f7 ea 13 db 	or	r11,r11,r10>>0x1d
8000b896:	a3 7a       	lsl	r10,0x3
8000b898:	f5 eb 10 04 	or	r4,r10,r11
8000b89c:	e0 80 00 a0 	breq	8000b9dc <__avr32_f64_div_op1_zero>
8000b8a0:	f6 04 12 00 	clz	r4,r11
8000b8a4:	c1 70       	breq	8000b8d2 <__avr32_f64_div_round_subnormal+0x96>
8000b8a6:	c0 c3       	brcs	8000b8be <__avr32_f64_div_round_subnormal+0x82>
8000b8a8:	e8 05 11 20 	rsub	r5,r4,32
8000b8ac:	f6 04 09 4b 	lsl	r11,r11,r4
8000b8b0:	f4 05 0a 45 	lsr	r5,r10,r5
8000b8b4:	0a 4b       	or	r11,r5
8000b8b6:	f4 04 09 4a 	lsl	r10,r10,r4
8000b8ba:	08 17       	sub	r7,r4
8000b8bc:	c0 b8       	rjmp	8000b8d2 <__avr32_f64_div_round_subnormal+0x96>
8000b8be:	f4 04 12 00 	clz	r4,r10
8000b8c2:	f9 b4 03 00 	movlo	r4,0
8000b8c6:	f7 b4 02 e0 	subhs	r4,-32
8000b8ca:	f4 04 09 4b 	lsl	r11,r10,r4
8000b8ce:	30 0a       	mov	r10,0
8000b8d0:	08 17       	sub	r7,r4
8000b8d2:	a3 8a       	lsr	r10,0x2
8000b8d4:	f5 eb 11 ea 	or	r10,r10,r11<<0x1e
8000b8d8:	a3 8b       	lsr	r11,0x2
8000b8da:	c1 1b       	rjmp	8000b6fc <__avr32_f64_div+0x20>
8000b8dc:	a3 79       	lsl	r9,0x3
8000b8de:	f3 e8 13 d9 	or	r9,r9,r8>>0x1d
8000b8e2:	a3 78       	lsl	r8,0x3
8000b8e4:	f3 e8 10 04 	or	r4,r9,r8
8000b8e8:	c6 f0       	breq	8000b9c6 <__avr32_f64_div_res_subnormal+0xa0>
8000b8ea:	f2 04 12 00 	clz	r4,r9
8000b8ee:	c1 70       	breq	8000b91c <__avr32_f64_div_round_subnormal+0xe0>
8000b8f0:	c0 c3       	brcs	8000b908 <__avr32_f64_div_round_subnormal+0xcc>
8000b8f2:	e8 05 11 20 	rsub	r5,r4,32
8000b8f6:	f2 04 09 49 	lsl	r9,r9,r4
8000b8fa:	f0 05 0a 45 	lsr	r5,r8,r5
8000b8fe:	0a 49       	or	r9,r5
8000b900:	f0 04 09 48 	lsl	r8,r8,r4
8000b904:	08 16       	sub	r6,r4
8000b906:	c0 b8       	rjmp	8000b91c <__avr32_f64_div_round_subnormal+0xe0>
8000b908:	f0 04 12 00 	clz	r4,r8
8000b90c:	f9 b4 03 00 	movlo	r4,0
8000b910:	f7 b4 02 e0 	subhs	r4,-32
8000b914:	f0 04 09 49 	lsl	r9,r8,r4
8000b918:	30 08       	mov	r8,0
8000b91a:	08 16       	sub	r6,r4
8000b91c:	a3 88       	lsr	r8,0x2
8000b91e:	f1 e9 11 e8 	or	r8,r8,r9<<0x1e
8000b922:	a3 89       	lsr	r9,0x2
8000b924:	cf ca       	rjmp	8000b71c <__avr32_f64_div+0x40>

8000b926 <__avr32_f64_div_res_subnormal>:
8000b926:	5c 37       	neg	r7
8000b928:	2f f7       	sub	r7,-1
8000b92a:	f1 b7 04 c0 	satu	r7,0x6
8000b92e:	e0 47 00 20 	cp.w	r7,32
8000b932:	c1 54       	brge	8000b95c <__avr32_f64_div_res_subnormal+0x36>
8000b934:	ee 06 11 20 	rsub	r6,r7,32
8000b938:	e4 07 0a 42 	lsr	r2,r2,r7
8000b93c:	e6 06 09 4c 	lsl	r12,r3,r6
8000b940:	18 42       	or	r2,r12
8000b942:	e6 07 0a 43 	lsr	r3,r3,r7
8000b946:	f4 06 09 41 	lsl	r1,r10,r6
8000b94a:	f4 07 0a 4a 	lsr	r10,r10,r7
8000b94e:	f6 06 09 4c 	lsl	r12,r11,r6
8000b952:	18 4a       	or	r10,r12
8000b954:	f6 07 0a 4b 	lsr	r11,r11,r7
8000b958:	30 00       	mov	r0,0
8000b95a:	c1 58       	rjmp	8000b984 <__avr32_f64_div_res_subnormal+0x5e>
8000b95c:	ee 06 11 20 	rsub	r6,r7,32
8000b960:	f9 b0 00 00 	moveq	r0,0
8000b964:	f9 bc 00 00 	moveq	r12,0
8000b968:	c0 50       	breq	8000b972 <__avr32_f64_div_res_subnormal+0x4c>
8000b96a:	f4 06 09 40 	lsl	r0,r10,r6
8000b96e:	f6 06 09 4c 	lsl	r12,r11,r6
8000b972:	e6 07 0a 42 	lsr	r2,r3,r7
8000b976:	30 03       	mov	r3,0
8000b978:	f4 07 0a 41 	lsr	r1,r10,r7
8000b97c:	18 41       	or	r1,r12
8000b97e:	f6 07 0a 4a 	lsr	r10,r11,r7
8000b982:	30 0b       	mov	r11,0
8000b984:	e0 12 ff 00 	andl	r2,0xff00
8000b988:	e8 12 00 80 	orl	r2,0x80
8000b98c:	e6 08 06 46 	mulu.d	r6,r3,r8
8000b990:	e4 09 07 46 	macu.d	r6,r2,r9
8000b994:	e4 08 06 44 	mulu.d	r4,r2,r8
8000b998:	e6 09 06 48 	mulu.d	r8,r3,r9
8000b99c:	0c 05       	add	r5,r6
8000b99e:	f0 07 00 48 	adc	r8,r8,r7
8000b9a2:	5c 09       	acr	r9
8000b9a4:	30 07       	mov	r7,0
8000b9a6:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000b9aa:	00 34       	cp.w	r4,r0
8000b9ac:	e2 05 13 00 	cpc	r5,r1
8000b9b0:	c4 6b       	rjmp	8000b83c <__avr32_f64_div_round_subnormal>
8000b9b2:	1c 9b       	mov	r11,lr
8000b9b4:	e6 1b 80 00 	andh	r11,0x8000,COH
8000b9b8:	30 0a       	mov	r10,0
8000b9ba:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000b9be:	3f fb       	mov	r11,-1
8000b9c0:	30 0a       	mov	r10,0
8000b9c2:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000b9c6:	f5 eb 10 04 	or	r4,r10,r11
8000b9ca:	c0 90       	breq	8000b9dc <__avr32_f64_div_op1_zero>
8000b9cc:	1c 9b       	mov	r11,lr
8000b9ce:	e6 1b 80 00 	andh	r11,0x8000,COH
8000b9d2:	ea 1b 7f f0 	orh	r11,0x7ff0
8000b9d6:	30 0a       	mov	r10,0
8000b9d8:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc

8000b9dc <__avr32_f64_div_op1_zero>:
8000b9dc:	f1 e9 10 15 	or	r5,r8,r9<<0x1
8000b9e0:	ce f0       	breq	8000b9be <__avr32_f64_div_res_subnormal+0x98>
8000b9e2:	e9 d9 c2 8b 	bfextu	r4,r9,0x14,0xb
8000b9e6:	e0 44 07 ff 	cp.w	r4,2047
8000b9ea:	ce 41       	brne	8000b9b2 <__avr32_f64_div_res_subnormal+0x8c>
8000b9ec:	f1 e9 10 c5 	or	r5,r8,r9<<0xc
8000b9f0:	ce 10       	breq	8000b9b2 <__avr32_f64_div_res_subnormal+0x8c>
8000b9f2:	ce 6b       	rjmp	8000b9be <__avr32_f64_div_res_subnormal+0x98>

8000b9f4 <__avr32_udiv64>:
8000b9f4:	d4 31       	pushm	r0-r7,lr
8000b9f6:	1a 97       	mov	r7,sp
8000b9f8:	20 3d       	sub	sp,12
8000b9fa:	10 9c       	mov	r12,r8
8000b9fc:	12 9e       	mov	lr,r9
8000b9fe:	14 93       	mov	r3,r10
8000ba00:	58 09       	cp.w	r9,0
8000ba02:	e0 81 00 bd 	brne	8000bb7c <__avr32_udiv64+0x188>
8000ba06:	16 38       	cp.w	r8,r11
8000ba08:	e0 88 00 40 	brls	8000ba88 <__avr32_udiv64+0x94>
8000ba0c:	f0 08 12 00 	clz	r8,r8
8000ba10:	c0 d0       	breq	8000ba2a <__avr32_udiv64+0x36>
8000ba12:	f6 08 09 4b 	lsl	r11,r11,r8
8000ba16:	f0 09 11 20 	rsub	r9,r8,32
8000ba1a:	f8 08 09 4c 	lsl	r12,r12,r8
8000ba1e:	f4 09 0a 49 	lsr	r9,r10,r9
8000ba22:	f4 08 09 43 	lsl	r3,r10,r8
8000ba26:	f3 eb 10 0b 	or	r11,r9,r11
8000ba2a:	f8 0e 16 10 	lsr	lr,r12,0x10
8000ba2e:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000ba32:	f6 0e 0d 00 	divu	r0,r11,lr
8000ba36:	e6 0b 16 10 	lsr	r11,r3,0x10
8000ba3a:	00 99       	mov	r9,r0
8000ba3c:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000ba40:	e0 0a 02 48 	mul	r8,r0,r10
8000ba44:	10 3b       	cp.w	r11,r8
8000ba46:	c0 a2       	brcc	8000ba5a <__avr32_udiv64+0x66>
8000ba48:	20 19       	sub	r9,1
8000ba4a:	18 0b       	add	r11,r12
8000ba4c:	18 3b       	cp.w	r11,r12
8000ba4e:	c0 63       	brcs	8000ba5a <__avr32_udiv64+0x66>
8000ba50:	10 3b       	cp.w	r11,r8
8000ba52:	f7 b9 03 01 	sublo	r9,1
8000ba56:	f7 dc e3 0b 	addcs	r11,r11,r12
8000ba5a:	f6 08 01 01 	sub	r1,r11,r8
8000ba5e:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000ba62:	e2 0e 0d 00 	divu	r0,r1,lr
8000ba66:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000ba6a:	00 98       	mov	r8,r0
8000ba6c:	e0 0a 02 4a 	mul	r10,r0,r10
8000ba70:	14 33       	cp.w	r3,r10
8000ba72:	c0 82       	brcc	8000ba82 <__avr32_udiv64+0x8e>
8000ba74:	20 18       	sub	r8,1
8000ba76:	18 03       	add	r3,r12
8000ba78:	18 33       	cp.w	r3,r12
8000ba7a:	c0 43       	brcs	8000ba82 <__avr32_udiv64+0x8e>
8000ba7c:	14 33       	cp.w	r3,r10
8000ba7e:	f7 b8 03 01 	sublo	r8,1
8000ba82:	f1 e9 11 08 	or	r8,r8,r9<<0x10
8000ba86:	cd f8       	rjmp	8000bc44 <__avr32_udiv64+0x250>
8000ba88:	58 08       	cp.w	r8,0
8000ba8a:	c0 51       	brne	8000ba94 <__avr32_udiv64+0xa0>
8000ba8c:	30 19       	mov	r9,1
8000ba8e:	f2 08 0d 08 	divu	r8,r9,r8
8000ba92:	10 9c       	mov	r12,r8
8000ba94:	f8 06 12 00 	clz	r6,r12
8000ba98:	c0 41       	brne	8000baa0 <__avr32_udiv64+0xac>
8000ba9a:	18 1b       	sub	r11,r12
8000ba9c:	30 19       	mov	r9,1
8000ba9e:	c4 08       	rjmp	8000bb1e <__avr32_udiv64+0x12a>
8000baa0:	ec 01 11 20 	rsub	r1,r6,32
8000baa4:	f4 01 0a 49 	lsr	r9,r10,r1
8000baa8:	f8 06 09 4c 	lsl	r12,r12,r6
8000baac:	f6 06 09 48 	lsl	r8,r11,r6
8000bab0:	f6 01 0a 41 	lsr	r1,r11,r1
8000bab4:	f3 e8 10 08 	or	r8,r9,r8
8000bab8:	f8 03 16 10 	lsr	r3,r12,0x10
8000babc:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000bac0:	e2 03 0d 00 	divu	r0,r1,r3
8000bac4:	f0 0b 16 10 	lsr	r11,r8,0x10
8000bac8:	00 9e       	mov	lr,r0
8000baca:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000bace:	e0 05 02 49 	mul	r9,r0,r5
8000bad2:	12 3b       	cp.w	r11,r9
8000bad4:	c0 a2       	brcc	8000bae8 <__avr32_udiv64+0xf4>
8000bad6:	20 1e       	sub	lr,1
8000bad8:	18 0b       	add	r11,r12
8000bada:	18 3b       	cp.w	r11,r12
8000badc:	c0 63       	brcs	8000bae8 <__avr32_udiv64+0xf4>
8000bade:	12 3b       	cp.w	r11,r9
8000bae0:	f7 be 03 01 	sublo	lr,1
8000bae4:	f7 dc e3 0b 	addcs	r11,r11,r12
8000bae8:	12 1b       	sub	r11,r9
8000baea:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
8000baee:	f6 03 0d 02 	divu	r2,r11,r3
8000baf2:	f1 e3 11 08 	or	r8,r8,r3<<0x10
8000baf6:	04 99       	mov	r9,r2
8000baf8:	e4 05 02 4b 	mul	r11,r2,r5
8000bafc:	16 38       	cp.w	r8,r11
8000bafe:	c0 a2       	brcc	8000bb12 <__avr32_udiv64+0x11e>
8000bb00:	20 19       	sub	r9,1
8000bb02:	18 08       	add	r8,r12
8000bb04:	18 38       	cp.w	r8,r12
8000bb06:	c0 63       	brcs	8000bb12 <__avr32_udiv64+0x11e>
8000bb08:	16 38       	cp.w	r8,r11
8000bb0a:	f7 b9 03 01 	sublo	r9,1
8000bb0e:	f1 dc e3 08 	addcs	r8,r8,r12
8000bb12:	f4 06 09 43 	lsl	r3,r10,r6
8000bb16:	f0 0b 01 0b 	sub	r11,r8,r11
8000bb1a:	f3 ee 11 09 	or	r9,r9,lr<<0x10
8000bb1e:	f8 06 16 10 	lsr	r6,r12,0x10
8000bb22:	fd dc c0 10 	bfextu	lr,r12,0x0,0x10
8000bb26:	f6 06 0d 00 	divu	r0,r11,r6
8000bb2a:	e6 0b 16 10 	lsr	r11,r3,0x10
8000bb2e:	00 9a       	mov	r10,r0
8000bb30:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000bb34:	e0 0e 02 48 	mul	r8,r0,lr
8000bb38:	10 3b       	cp.w	r11,r8
8000bb3a:	c0 a2       	brcc	8000bb4e <__avr32_udiv64+0x15a>
8000bb3c:	20 1a       	sub	r10,1
8000bb3e:	18 0b       	add	r11,r12
8000bb40:	18 3b       	cp.w	r11,r12
8000bb42:	c0 63       	brcs	8000bb4e <__avr32_udiv64+0x15a>
8000bb44:	10 3b       	cp.w	r11,r8
8000bb46:	f7 ba 03 01 	sublo	r10,1
8000bb4a:	f7 dc e3 0b 	addcs	r11,r11,r12
8000bb4e:	f6 08 01 01 	sub	r1,r11,r8
8000bb52:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000bb56:	e2 06 0d 00 	divu	r0,r1,r6
8000bb5a:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000bb5e:	00 98       	mov	r8,r0
8000bb60:	e0 0e 02 4b 	mul	r11,r0,lr
8000bb64:	16 33       	cp.w	r3,r11
8000bb66:	c0 82       	brcc	8000bb76 <__avr32_udiv64+0x182>
8000bb68:	20 18       	sub	r8,1
8000bb6a:	18 03       	add	r3,r12
8000bb6c:	18 33       	cp.w	r3,r12
8000bb6e:	c0 43       	brcs	8000bb76 <__avr32_udiv64+0x182>
8000bb70:	16 33       	cp.w	r3,r11
8000bb72:	f7 b8 03 01 	sublo	r8,1
8000bb76:	f1 ea 11 08 	or	r8,r8,r10<<0x10
8000bb7a:	c6 98       	rjmp	8000bc4c <__avr32_udiv64+0x258>
8000bb7c:	16 39       	cp.w	r9,r11
8000bb7e:	e0 8b 00 65 	brhi	8000bc48 <__avr32_udiv64+0x254>
8000bb82:	f2 09 12 00 	clz	r9,r9
8000bb86:	c0 b1       	brne	8000bb9c <__avr32_udiv64+0x1a8>
8000bb88:	10 3a       	cp.w	r10,r8
8000bb8a:	5f 2a       	srhs	r10
8000bb8c:	1c 3b       	cp.w	r11,lr
8000bb8e:	5f b8       	srhi	r8
8000bb90:	10 4a       	or	r10,r8
8000bb92:	f2 0a 18 00 	cp.b	r10,r9
8000bb96:	c5 90       	breq	8000bc48 <__avr32_udiv64+0x254>
8000bb98:	30 18       	mov	r8,1
8000bb9a:	c5 98       	rjmp	8000bc4c <__avr32_udiv64+0x258>
8000bb9c:	f0 09 09 46 	lsl	r6,r8,r9
8000bba0:	f2 03 11 20 	rsub	r3,r9,32
8000bba4:	fc 09 09 4e 	lsl	lr,lr,r9
8000bba8:	f0 03 0a 48 	lsr	r8,r8,r3
8000bbac:	f6 09 09 4c 	lsl	r12,r11,r9
8000bbb0:	f4 03 0a 42 	lsr	r2,r10,r3
8000bbb4:	ef 46 ff f4 	st.w	r7[-12],r6
8000bbb8:	f6 03 0a 43 	lsr	r3,r11,r3
8000bbbc:	18 42       	or	r2,r12
8000bbbe:	f1 ee 10 0c 	or	r12,r8,lr
8000bbc2:	f8 01 16 10 	lsr	r1,r12,0x10
8000bbc6:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000bbca:	e6 01 0d 04 	divu	r4,r3,r1
8000bbce:	e4 03 16 10 	lsr	r3,r2,0x10
8000bbd2:	08 9e       	mov	lr,r4
8000bbd4:	e7 e5 11 03 	or	r3,r3,r5<<0x10
8000bbd8:	e8 06 02 48 	mul	r8,r4,r6
8000bbdc:	10 33       	cp.w	r3,r8
8000bbde:	c0 a2       	brcc	8000bbf2 <__avr32_udiv64+0x1fe>
8000bbe0:	20 1e       	sub	lr,1
8000bbe2:	18 03       	add	r3,r12
8000bbe4:	18 33       	cp.w	r3,r12
8000bbe6:	c0 63       	brcs	8000bbf2 <__avr32_udiv64+0x1fe>
8000bbe8:	10 33       	cp.w	r3,r8
8000bbea:	f7 be 03 01 	sublo	lr,1
8000bbee:	e7 dc e3 03 	addcs	r3,r3,r12
8000bbf2:	10 13       	sub	r3,r8
8000bbf4:	f7 d2 c0 10 	bfextu	r11,r2,0x0,0x10
8000bbf8:	e6 01 0d 00 	divu	r0,r3,r1
8000bbfc:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000bc00:	00 98       	mov	r8,r0
8000bc02:	e0 06 02 46 	mul	r6,r0,r6
8000bc06:	0c 3b       	cp.w	r11,r6
8000bc08:	c0 a2       	brcc	8000bc1c <__avr32_udiv64+0x228>
8000bc0a:	20 18       	sub	r8,1
8000bc0c:	18 0b       	add	r11,r12
8000bc0e:	18 3b       	cp.w	r11,r12
8000bc10:	c0 63       	brcs	8000bc1c <__avr32_udiv64+0x228>
8000bc12:	0c 3b       	cp.w	r11,r6
8000bc14:	f7 dc e3 0b 	addcs	r11,r11,r12
8000bc18:	f7 b8 03 01 	sublo	r8,1
8000bc1c:	f1 ee 11 08 	or	r8,r8,lr<<0x10
8000bc20:	ee f4 ff f4 	ld.w	r4,r7[-12]
8000bc24:	0c 1b       	sub	r11,r6
8000bc26:	f0 04 06 42 	mulu.d	r2,r8,r4
8000bc2a:	06 95       	mov	r5,r3
8000bc2c:	16 35       	cp.w	r5,r11
8000bc2e:	e0 8b 00 0a 	brhi	8000bc42 <__avr32_udiv64+0x24e>
8000bc32:	5f 0b       	sreq	r11
8000bc34:	f4 09 09 49 	lsl	r9,r10,r9
8000bc38:	12 32       	cp.w	r2,r9
8000bc3a:	5f b9       	srhi	r9
8000bc3c:	f7 e9 00 09 	and	r9,r11,r9
8000bc40:	c0 60       	breq	8000bc4c <__avr32_udiv64+0x258>
8000bc42:	20 18       	sub	r8,1
8000bc44:	30 09       	mov	r9,0
8000bc46:	c0 38       	rjmp	8000bc4c <__avr32_udiv64+0x258>
8000bc48:	30 09       	mov	r9,0
8000bc4a:	12 98       	mov	r8,r9
8000bc4c:	10 9a       	mov	r10,r8
8000bc4e:	12 93       	mov	r3,r9
8000bc50:	10 92       	mov	r2,r8
8000bc52:	12 9b       	mov	r11,r9
8000bc54:	2f dd       	sub	sp,-12
8000bc56:	d8 32       	popm	r0-r7,pc

8000bc58 <__avr32_umod64>:
8000bc58:	d4 31       	pushm	r0-r7,lr
8000bc5a:	1a 97       	mov	r7,sp
8000bc5c:	20 3d       	sub	sp,12
8000bc5e:	10 9c       	mov	r12,r8
8000bc60:	12 95       	mov	r5,r9
8000bc62:	14 9e       	mov	lr,r10
8000bc64:	16 91       	mov	r1,r11
8000bc66:	16 96       	mov	r6,r11
8000bc68:	58 09       	cp.w	r9,0
8000bc6a:	e0 81 00 81 	brne	8000bd6c <__avr32_umod64+0x114>
8000bc6e:	16 38       	cp.w	r8,r11
8000bc70:	e0 88 00 12 	brls	8000bc94 <__avr32_umod64+0x3c>
8000bc74:	f0 08 12 00 	clz	r8,r8
8000bc78:	c4 e0       	breq	8000bd14 <__avr32_umod64+0xbc>
8000bc7a:	f6 08 09 46 	lsl	r6,r11,r8
8000bc7e:	f8 08 09 4c 	lsl	r12,r12,r8
8000bc82:	f0 0b 11 20 	rsub	r11,r8,32
8000bc86:	f4 08 09 4e 	lsl	lr,r10,r8
8000bc8a:	f4 0b 0a 4b 	lsr	r11,r10,r11
8000bc8e:	f7 e6 10 06 	or	r6,r11,r6
8000bc92:	c4 18       	rjmp	8000bd14 <__avr32_umod64+0xbc>
8000bc94:	58 08       	cp.w	r8,0
8000bc96:	c0 51       	brne	8000bca0 <__avr32_umod64+0x48>
8000bc98:	30 19       	mov	r9,1
8000bc9a:	f2 08 0d 08 	divu	r8,r9,r8
8000bc9e:	10 9c       	mov	r12,r8
8000bca0:	f8 08 12 00 	clz	r8,r12
8000bca4:	c0 31       	brne	8000bcaa <__avr32_umod64+0x52>
8000bca6:	18 16       	sub	r6,r12
8000bca8:	c3 68       	rjmp	8000bd14 <__avr32_umod64+0xbc>
8000bcaa:	f0 03 11 20 	rsub	r3,r8,32
8000bcae:	f4 03 0a 4b 	lsr	r11,r10,r3
8000bcb2:	f8 08 09 4c 	lsl	r12,r12,r8
8000bcb6:	ec 08 09 49 	lsl	r9,r6,r8
8000bcba:	ec 03 0a 43 	lsr	r3,r6,r3
8000bcbe:	f7 e9 10 09 	or	r9,r11,r9
8000bcc2:	f8 05 16 10 	lsr	r5,r12,0x10
8000bcc6:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000bcca:	e6 05 0d 02 	divu	r2,r3,r5
8000bcce:	f2 0e 16 10 	lsr	lr,r9,0x10
8000bcd2:	ec 02 02 4b 	mul	r11,r6,r2
8000bcd6:	fd e3 11 0e 	or	lr,lr,r3<<0x10
8000bcda:	16 3e       	cp.w	lr,r11
8000bcdc:	c0 72       	brcc	8000bcea <__avr32_umod64+0x92>
8000bcde:	18 0e       	add	lr,r12
8000bce0:	18 3e       	cp.w	lr,r12
8000bce2:	c0 43       	brcs	8000bcea <__avr32_umod64+0x92>
8000bce4:	16 3e       	cp.w	lr,r11
8000bce6:	fd dc e3 0e 	addcs	lr,lr,r12
8000bcea:	fc 0b 01 03 	sub	r3,lr,r11
8000bcee:	f3 d9 c0 10 	bfextu	r9,r9,0x0,0x10
8000bcf2:	e6 05 0d 02 	divu	r2,r3,r5
8000bcf6:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000bcfa:	a5 36       	mul	r6,r2
8000bcfc:	0c 39       	cp.w	r9,r6
8000bcfe:	c0 72       	brcc	8000bd0c <__avr32_umod64+0xb4>
8000bd00:	18 09       	add	r9,r12
8000bd02:	18 39       	cp.w	r9,r12
8000bd04:	c0 43       	brcs	8000bd0c <__avr32_umod64+0xb4>
8000bd06:	0c 39       	cp.w	r9,r6
8000bd08:	f3 dc e3 09 	addcs	r9,r9,r12
8000bd0c:	f2 06 01 06 	sub	r6,r9,r6
8000bd10:	f4 08 09 4e 	lsl	lr,r10,r8
8000bd14:	f8 0a 16 10 	lsr	r10,r12,0x10
8000bd18:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000bd1c:	ec 0a 0d 02 	divu	r2,r6,r10
8000bd20:	fc 09 16 10 	lsr	r9,lr,0x10
8000bd24:	ea 02 02 4b 	mul	r11,r5,r2
8000bd28:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000bd2c:	16 39       	cp.w	r9,r11
8000bd2e:	c0 72       	brcc	8000bd3c <__avr32_umod64+0xe4>
8000bd30:	18 09       	add	r9,r12
8000bd32:	18 39       	cp.w	r9,r12
8000bd34:	c0 43       	brcs	8000bd3c <__avr32_umod64+0xe4>
8000bd36:	16 39       	cp.w	r9,r11
8000bd38:	f3 dc e3 09 	addcs	r9,r9,r12
8000bd3c:	f2 0b 01 0b 	sub	r11,r9,r11
8000bd40:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000bd44:	f6 0a 0d 0a 	divu	r10,r11,r10
8000bd48:	fd eb 11 0e 	or	lr,lr,r11<<0x10
8000bd4c:	ea 0a 02 4a 	mul	r10,r5,r10
8000bd50:	14 3e       	cp.w	lr,r10
8000bd52:	c0 72       	brcc	8000bd60 <__avr32_umod64+0x108>
8000bd54:	18 0e       	add	lr,r12
8000bd56:	18 3e       	cp.w	lr,r12
8000bd58:	c0 43       	brcs	8000bd60 <__avr32_umod64+0x108>
8000bd5a:	14 3e       	cp.w	lr,r10
8000bd5c:	fd dc e3 0e 	addcs	lr,lr,r12
8000bd60:	fc 0a 01 0a 	sub	r10,lr,r10
8000bd64:	30 0b       	mov	r11,0
8000bd66:	f4 08 0a 4a 	lsr	r10,r10,r8
8000bd6a:	c7 b8       	rjmp	8000be60 <__avr32_umod64+0x208>
8000bd6c:	16 39       	cp.w	r9,r11
8000bd6e:	e0 8b 00 79 	brhi	8000be60 <__avr32_umod64+0x208>
8000bd72:	f2 09 12 00 	clz	r9,r9
8000bd76:	c1 21       	brne	8000bd9a <__avr32_umod64+0x142>
8000bd78:	10 3a       	cp.w	r10,r8
8000bd7a:	5f 2b       	srhs	r11
8000bd7c:	0a 31       	cp.w	r1,r5
8000bd7e:	5f ba       	srhi	r10
8000bd80:	f7 ea 10 0a 	or	r10,r11,r10
8000bd84:	f2 0a 18 00 	cp.b	r10,r9
8000bd88:	c0 60       	breq	8000bd94 <__avr32_umod64+0x13c>
8000bd8a:	fc 08 01 0c 	sub	r12,lr,r8
8000bd8e:	e2 05 01 46 	sbc	r6,r1,r5
8000bd92:	18 9e       	mov	lr,r12
8000bd94:	0c 9b       	mov	r11,r6
8000bd96:	1c 9a       	mov	r10,lr
8000bd98:	c6 48       	rjmp	8000be60 <__avr32_umod64+0x208>
8000bd9a:	ea 09 09 4c 	lsl	r12,r5,r9
8000bd9e:	f2 06 11 20 	rsub	r6,r9,32
8000bda2:	f6 09 09 4b 	lsl	r11,r11,r9
8000bda6:	f0 09 09 42 	lsl	r2,r8,r9
8000bdaa:	ef 46 ff f4 	st.w	r7[-12],r6
8000bdae:	f0 06 0a 48 	lsr	r8,r8,r6
8000bdb2:	18 48       	or	r8,r12
8000bdb4:	e2 06 0a 4c 	lsr	r12,r1,r6
8000bdb8:	f4 09 09 43 	lsl	r3,r10,r9
8000bdbc:	fd d8 c0 10 	bfextu	lr,r8,0x0,0x10
8000bdc0:	f4 06 0a 4a 	lsr	r10,r10,r6
8000bdc4:	16 4a       	or	r10,r11
8000bdc6:	f0 0b 16 10 	lsr	r11,r8,0x10
8000bdca:	f8 0b 0d 04 	divu	r4,r12,r11
8000bdce:	f4 0c 16 10 	lsr	r12,r10,0x10
8000bdd2:	08 91       	mov	r1,r4
8000bdd4:	f9 e5 11 0c 	or	r12,r12,r5<<0x10
8000bdd8:	e8 0e 02 46 	mul	r6,r4,lr
8000bddc:	0c 3c       	cp.w	r12,r6
8000bdde:	c0 a2       	brcc	8000bdf2 <__avr32_umod64+0x19a>
8000bde0:	20 11       	sub	r1,1
8000bde2:	10 0c       	add	r12,r8
8000bde4:	10 3c       	cp.w	r12,r8
8000bde6:	c0 63       	brcs	8000bdf2 <__avr32_umod64+0x19a>
8000bde8:	0c 3c       	cp.w	r12,r6
8000bdea:	f7 b1 03 01 	sublo	r1,1
8000bdee:	f9 d8 e3 0c 	addcs	r12,r12,r8
8000bdf2:	0c 1c       	sub	r12,r6
8000bdf4:	f5 da c0 10 	bfextu	r10,r10,0x0,0x10
8000bdf8:	f8 0b 0d 04 	divu	r4,r12,r11
8000bdfc:	f5 e5 11 0b 	or	r11,r10,r5<<0x10
8000be00:	08 96       	mov	r6,r4
8000be02:	e8 0e 02 4e 	mul	lr,r4,lr
8000be06:	1c 3b       	cp.w	r11,lr
8000be08:	c0 a2       	brcc	8000be1c <__avr32_umod64+0x1c4>
8000be0a:	20 16       	sub	r6,1
8000be0c:	10 0b       	add	r11,r8
8000be0e:	10 3b       	cp.w	r11,r8
8000be10:	c0 63       	brcs	8000be1c <__avr32_umod64+0x1c4>
8000be12:	1c 3b       	cp.w	r11,lr
8000be14:	f7 b6 03 01 	sublo	r6,1
8000be18:	f7 d8 e3 0b 	addcs	r11,r11,r8
8000be1c:	ed e1 11 01 	or	r1,r6,r1<<0x10
8000be20:	1c 1b       	sub	r11,lr
8000be22:	e2 02 06 40 	mulu.d	r0,r1,r2
8000be26:	00 9e       	mov	lr,r0
8000be28:	02 9c       	mov	r12,r1
8000be2a:	16 3c       	cp.w	r12,r11
8000be2c:	e0 8b 00 08 	brhi	8000be3c <__avr32_umod64+0x1e4>
8000be30:	5f 06       	sreq	r6
8000be32:	06 30       	cp.w	r0,r3
8000be34:	5f ba       	srhi	r10
8000be36:	ed ea 00 0a 	and	r10,r6,r10
8000be3a:	c0 60       	breq	8000be46 <__avr32_umod64+0x1ee>
8000be3c:	fc 02 01 04 	sub	r4,lr,r2
8000be40:	f8 08 01 4c 	sbc	r12,r12,r8
8000be44:	08 9e       	mov	lr,r4
8000be46:	e6 0e 01 0a 	sub	r10,r3,lr
8000be4a:	f6 0c 01 4c 	sbc	r12,r11,r12
8000be4e:	ee f1 ff f4 	ld.w	r1,r7[-12]
8000be52:	f8 09 0a 4b 	lsr	r11,r12,r9
8000be56:	f4 09 0a 4a 	lsr	r10,r10,r9
8000be5a:	f8 01 09 4c 	lsl	r12,r12,r1
8000be5e:	18 4a       	or	r10,r12
8000be60:	2f dd       	sub	sp,-12
8000be62:	d8 32       	popm	r0-r7,pc

Disassembly of section .exception:

8000c000 <_evba>:
_evba:

        .org  0x000
        // Unrecoverable Exception.
_handle_Unrecoverable_Exception:
        rjmp $
8000c000:	c0 08       	rjmp	8000c000 <_evba>
	...

8000c004 <_handle_TLB_Multiple_Hit>:

        .org  0x004
        // TLB Multiple Hit: UNUSED IN AVR32UC.
_handle_TLB_Multiple_Hit:
        rjmp $
8000c004:	c0 08       	rjmp	8000c004 <_handle_TLB_Multiple_Hit>
	...

8000c008 <_handle_Bus_Error_Data_Fetch>:

        .org  0x008
        // Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
        rjmp $
8000c008:	c0 08       	rjmp	8000c008 <_handle_Bus_Error_Data_Fetch>
	...

8000c00c <_handle_Bus_Error_Instruction_Fetch>:

        .org  0x00C
         // Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
        rjmp $
8000c00c:	c0 08       	rjmp	8000c00c <_handle_Bus_Error_Instruction_Fetch>
	...

8000c010 <_handle_NMI>:

        .org  0x010
        // NMI.
_handle_NMI:
        rjmp $
8000c010:	c0 08       	rjmp	8000c010 <_handle_NMI>
	...

8000c014 <_handle_Instruction_Address>:

        .org  0x014
        // Instruction Address.
_handle_Instruction_Address:
        rjmp $
8000c014:	c0 08       	rjmp	8000c014 <_handle_Instruction_Address>
	...

8000c018 <_handle_ITLB_Protection>:

        .org  0x018
        // ITLB Protection.
_handle_ITLB_Protection:
        rjmp $
8000c018:	c0 08       	rjmp	8000c018 <_handle_ITLB_Protection>
	...

8000c01c <_handle_Breakpoint>:

        .org  0x01C
        // Breakpoint.
_handle_Breakpoint:
        rjmp $
8000c01c:	c0 08       	rjmp	8000c01c <_handle_Breakpoint>
	...

8000c020 <_handle_Illegal_Opcode>:

        .org  0x020
        // Illegal Opcode.
_handle_Illegal_Opcode:
        rjmp $
8000c020:	c0 08       	rjmp	8000c020 <_handle_Illegal_Opcode>
	...

8000c024 <_handle_Unimplemented_Instruction>:

        .org  0x024
        // Unimplemented Instruction.
_handle_Unimplemented_Instruction:
        rjmp $
8000c024:	c0 08       	rjmp	8000c024 <_handle_Unimplemented_Instruction>
	...

8000c028 <_handle_Privilege_Violation>:

        .org  0x028
        // Privilege Violation.
_handle_Privilege_Violation:
        rjmp $
8000c028:	c0 08       	rjmp	8000c028 <_handle_Privilege_Violation>
	...

8000c02c <_handle_Floating_Point>:

        .org  0x02C
        // Floating-Point: UNUSED IN AVR32UC.
_handle_Floating_Point:
        rjmp $
8000c02c:	c0 08       	rjmp	8000c02c <_handle_Floating_Point>
	...

8000c030 <_handle_Coprocessor_Absent>:

        .org  0x030
        // Coprocessor Absent: UNUSED IN AVR32UC.
_handle_Coprocessor_Absent:
        rjmp $
8000c030:	c0 08       	rjmp	8000c030 <_handle_Coprocessor_Absent>
	...

8000c034 <_handle_Data_Address_Read>:

        .org  0x034
        // Data Address (Read).
_handle_Data_Address_Read:
        rjmp $
8000c034:	c0 08       	rjmp	8000c034 <_handle_Data_Address_Read>
	...

8000c038 <_handle_Data_Address_Write>:

        .org  0x038
        // Data Address (Write).
_handle_Data_Address_Write:
        rjmp $
8000c038:	c0 08       	rjmp	8000c038 <_handle_Data_Address_Write>
	...

8000c03c <_handle_DTLB_Protection_Read>:

        .org  0x03C
        // DTLB Protection (Read).
_handle_DTLB_Protection_Read:
        rjmp $
8000c03c:	c0 08       	rjmp	8000c03c <_handle_DTLB_Protection_Read>
	...

8000c040 <_handle_DTLB_Protection_Write>:

        .org  0x040
        // DTLB Protection (Write).
_handle_DTLB_Protection_Write:
        rjmp $
8000c040:	c0 08       	rjmp	8000c040 <_handle_DTLB_Protection_Write>
	...

8000c044 <_handle_DTLB_Modified>:

        .org  0x044
        // DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
        rjmp $
8000c044:	c0 08       	rjmp	8000c044 <_handle_DTLB_Modified>
	...

8000c050 <_handle_ITLB_Miss>:

        .org  0x050
        // ITLB Miss: UNUSED IN AVR32UC.
_handle_ITLB_Miss:
        rjmp $
8000c050:	c0 08       	rjmp	8000c050 <_handle_ITLB_Miss>
	...

8000c060 <_handle_DTLB_Miss_Read>:

        .org  0x060
        // DTLB Miss (Read): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Read:
        rjmp $
8000c060:	c0 08       	rjmp	8000c060 <_handle_DTLB_Miss_Read>
	...

8000c070 <_handle_DTLB_Miss_Write>:

        .org  0x070
        // DTLB Miss (Write): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Write:
        rjmp $
8000c070:	c0 08       	rjmp	8000c070 <_handle_DTLB_Miss_Write>
	...

8000c100 <_handle_Supervisor_Call>:

        .org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	lda.w   pc, SCALLYield
8000c100:	fe cf 6f 38 	sub	pc,pc,28472

8000c104 <_int0>:
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
	rete
.endr
8000c104:	30 0c       	mov	r12,0
8000c106:	fe b0 c3 c7 	rcall	80004894 <_get_interrupt_handler>
8000c10a:	58 0c       	cp.w	r12,0
8000c10c:	f8 0f 17 10 	movne	pc,r12
8000c110:	d6 03       	rete

8000c112 <_int1>:
8000c112:	30 1c       	mov	r12,1
8000c114:	fe b0 c3 c0 	rcall	80004894 <_get_interrupt_handler>
8000c118:	58 0c       	cp.w	r12,0
8000c11a:	f8 0f 17 10 	movne	pc,r12
8000c11e:	d6 03       	rete

8000c120 <_int2>:
8000c120:	30 2c       	mov	r12,2
8000c122:	fe b0 c3 b9 	rcall	80004894 <_get_interrupt_handler>
8000c126:	58 0c       	cp.w	r12,0
8000c128:	f8 0f 17 10 	movne	pc,r12
8000c12c:	d6 03       	rete

8000c12e <_int3>:
8000c12e:	30 3c       	mov	r12,3
8000c130:	fe b0 c3 b2 	rcall	80004894 <_get_interrupt_handler>
8000c134:	58 0c       	cp.w	r12,0
8000c136:	f8 0f 17 10 	movne	pc,r12
8000c13a:	d6 03       	rete

8000c13c <ipr_val>:
8000c13c:	00 00 01 04 40 00 01 12 80 00 01 20 c0 00 01 2e     ....@...... ....
8000c14c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c15c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c16c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c17c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c18c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c19c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c1ac:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c1bc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c1cc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c1dc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c1ec:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c1fc:	d7 03 d7 03                                         ....
