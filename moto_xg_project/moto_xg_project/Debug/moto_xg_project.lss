
moto_xg_project.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00002004  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         00009e7c  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .exception    00000200  8000c000  8000c000  0000c400  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       00001124  8000c200  8000c200  0000c600  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .dalign       00000004  8000d324  8000d324  0000d724  2**0
                  ALLOC
  6 .data         00000a40  00000004  8000d328  0000d804  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .balign       00000004  00000a44  8000dd68  0000e244  2**0
                  ALLOC
  8 .bss          000036c8  00000a48  8000dd68  0000e248  2**2
                  ALLOC
  9 .comment      00000030  00000000  00000000  0000e244  2**0
                  CONTENTS, READONLY
 10 .debug_aranges 00001050  00000000  00000000  0000e278  2**3
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_pubnames 00002347  00000000  00000000  0000f2c8  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_info   000263c5  00000000  00000000  0001160f  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_abbrev 000062c4  00000000  00000000  000379d4  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_line   00013b34  00000000  00000000  0003dc98  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_frame  00002b1c  00000000  00000000  000517cc  2**2
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_str    000069da  00000000  00000000  000542e8  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_loc    0000c4b5  00000000  00000000  0005acc2  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_macinfo 01296b6a  00000000  00000000  00067177  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .stack        00001000  00017000  00017000  00000400  2**0
                  ALLOC
 20 .debug_ranges 00001148  00000000  00000000  012fdce8  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_trampoline>:

  .global _trampoline
  .type _trampoline, @function
_trampoline:
  // Jump to program start.
  rjmp    program_start
80000000:	e0 8f 10 00 	bral	80002000 <program_start>
	...

80002000 <program_start>:

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002000:	fe cf d1 54 	sub	pc,pc,-11948

Disassembly of section .text:

80002004 <DeviceManagement_brdcst_func>:
80002004:	19 a9       	ld.ub	r9,r12[0x2]
80002006:	30 18       	mov	r8,1
		U8 temp = 0;
		temp  = xcmp->u8[1] << 8;
		temp |= xcmp->u8[2];
		//if (temp == theXNL_Ctrlr.XNL_DeviceLogicalAddress)
		{
			if (xcmp->u8[0] == 0x01)
80002008:	f0 09 18 00 	cp.b	r9,r8
8000200c:	c0 61       	brne	80002018 <DeviceManagement_brdcst_func+0x14>
			{
				bunchofrandomstatusflags |= 0x00000002;
8000200e:	48 68       	lddpc	r8,80002024 <DeviceManagement_brdcst_func+0x20>
80002010:	70 09       	ld.w	r9,r8[0x0]
80002012:	a1 b9       	sbr	r9,0x1
80002014:	91 09       	st.w	r8[0x0],r9
80002016:	5e fc       	retal	r12
			}
			else
			{
				bunchofrandomstatusflags &= 0xFFFFFFFD;
80002018:	48 38       	lddpc	r8,80002024 <DeviceManagement_brdcst_func+0x20>
8000201a:	70 09       	ld.w	r9,r8[0x0]
8000201c:	a1 d9       	cbr	r9,0x1
8000201e:	91 09       	st.w	r8[0x0],r9
80002020:	5e fc       	retal	r12
80002022:	00 00       	add	r0,r0
80002024:	00 00       	add	r0,r0
80002026:	0d 8c       	ld.ub	r12,r6[0x0]

80002028 <Volume_brdcst_func>:
	//log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
	
	//log("\n\r Audio_Parameter: %x \n\r", ptr->Audio_Parameter);
	
	
}
80002028:	5e fc       	retal	r12

8000202a <AudioRoutingControl_brdcst_func>:
	//
	//log("\n\r Audio-Function: %x \n\r", xcmp->u8[3+j*2-1]);
	
	
	
}
8000202a:	5e fc       	retal	r12

8000202c <vApplicationIdleHook>:
}

void vApplicationIdleHook( void )
{
	/* This hook function does nothing but increment a counter. */
	ulIdleCycleCount++;
8000202c:	48 38       	lddpc	r8,80002038 <vApplicationIdleHook+0xc>
8000202e:	70 09       	ld.w	r9,r8[0x0]
80002030:	2f f9       	sub	r9,-1
80002032:	91 09       	st.w	r8[0x0],r9
	
}
80002034:	5e fc       	retal	r12
80002036:	00 00       	add	r0,r0
80002038:	00 00       	add	r0,r0
8000203a:	0a 64       	and	r4,r5

8000203c <app_init>:
	//0x00,0x39


};
void app_init(void)
{	
8000203c:	d4 01       	pushm	lr
	xcmp_register_app_list(the_app_list);
8000203e:	48 cc       	lddpc	r12,8000206c <app_init+0x30>
80002040:	f0 1f 00 0c 	mcall	80002070 <app_init+0x34>
	
	//将app_payload_rx_proc更改为PCM加密功能
	payload_init( app_payload_rx_proc , app_payload_tx_proc );
80002044:	48 cb       	lddpc	r11,80002074 <app_init+0x38>
80002046:	48 dc       	lddpc	r12,80002078 <app_init+0x3c>
80002048:	f0 1f 00 0d 	mcall	8000207c <app_init+0x40>
	
	static portBASE_TYPE res = 0;
	 res = xTaskCreate(
8000204c:	30 09       	mov	r9,0
8000204e:	1a d9       	st.w	--sp,r9
80002050:	1a d9       	st.w	--sp,r9
80002052:	1a d9       	st.w	--sp,r9
80002054:	30 18       	mov	r8,1
80002056:	e0 6a 01 80 	mov	r10,384
8000205a:	48 ab       	lddpc	r11,80002080 <app_init+0x44>
8000205c:	48 ac       	lddpc	r12,80002084 <app_init+0x48>
8000205e:	f0 1f 00 0b 	mcall	80002088 <app_init+0x4c>
80002062:	48 b8       	lddpc	r8,8000208c <app_init+0x50>
80002064:	91 0c       	st.w	r8[0x0],r12
80002066:	2f dd       	sub	sp,-12
	,  384
	,  NULL
	,  1
	,  NULL );
	
}
80002068:	d8 02       	popm	pc
8000206a:	00 00       	add	r0,r0
8000206c:	00 00       	add	r0,r0
8000206e:	00 18       	sub	r8,r0
80002070:	80 00       	ld.sh	r0,r0[0x0]
80002072:	41 24       	lddsp	r4,sp[0x48]
80002074:	80 00       	ld.sh	r0,r0[0x0]
80002076:	21 24       	sub	r4,18
80002078:	80 00       	ld.sh	r0,r0[0x0]
8000207a:	28 cc       	sub	r12,-116
8000207c:	80 00       	ld.sh	r0,r0[0x0]
8000207e:	29 6c       	sub	r12,-106
80002080:	80 00       	ld.sh	r0,r0[0x0]
80002082:	c2 00       	breq	800020c2 <app_cfg+0x32>
80002084:	80 00       	ld.sh	r0,r0[0x0]
80002086:	20 90       	sub	r0,9
80002088:	80 00       	ld.sh	r0,r0[0x0]
8000208a:	5d a4       	*unknown*
8000208c:	00 00       	add	r0,r0
8000208e:	0a 58       	eor	r8,r5

80002090 <app_cfg>:

extern  char AudioData[];
extern U32 tc_tick;

static __app_Thread_(app_cfg)
{
80002090:	d4 31       	pushm	r0-r7,lr
	static  U32 isAudioRouting = 0;
	static  portTickType xLastWakeTime;
	const portTickType xFrequency = 4000;//2s,定时问题已经修正。2s x  2000hz = 4000
	U8 Burst_ID = 0;
	
	 xLastWakeTime = xTaskGetTickCount();
80002092:	f0 1f 00 1d 	mcall	80002104 <app_cfg+0x74>
80002096:	49 d8       	lddpc	r8,80002108 <app_cfg+0x78>
80002098:	91 0c       	st.w	r8[0x0],r12
		
	for(;;)
	{
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003))//确认连接成功了，再发送请求
8000209a:	49 d7       	lddpc	r7,8000210c <app_cfg+0x7c>
		{	
			{
				xcmp_IdleTestTone();						
				if(isAudioRouting == 0)
8000209c:	49 d6       	lddpc	r6,80002110 <app_cfg+0x80>
					
				}
				else
				{
					isAudioRouting++;
					if(isAudioRouting == 5)xcmp_data_session_req(message, 12, 9);
8000209e:	49 e2       	lddpc	r2,80002114 <app_cfg+0x84>
800020a0:	30 91       	mov	r1,9
800020a2:	30 c0       	mov	r0,12
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_exit_enhanced_OB_mode();
					//xcmp_mute_speaker();
					//xcmp_enhanced_OB_mode();
					isAudioRouting = 4;
800020a4:	30 43       	mov	r3,4
					//xcmp_button_config();
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//log("\n\r time: %d \n\r", tc_tick);
					
					isAudioRouting = 2;
800020a6:	30 24       	mov	r4,2
					//xcmp_enter_enhanced_OB_mode();
					//xcmp_unmute_speaker();
					//Speaker_is_unmute = 1;
					//xcmp_function_mic();
					
					isAudioRouting = 1;
800020a8:	30 15       	mov	r5,1
	
	 xLastWakeTime = xTaskGetTickCount();
		
	for(;;)
	{
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003))//确认连接成功了，再发送请求
800020aa:	6e 08       	ld.w	r8,r7[0x0]
800020ac:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
800020b0:	58 38       	cp.w	r8,3
800020b2:	c2 31       	brne	800020f8 <app_cfg+0x68>
		{	
			{
				xcmp_IdleTestTone();						
800020b4:	f0 1f 00 19 	mcall	80002118 <app_cfg+0x88>
				if(isAudioRouting == 0)
800020b8:	6c 08       	ld.w	r8,r6[0x0]
800020ba:	58 08       	cp.w	r8,0
800020bc:	c0 31       	brne	800020c2 <app_cfg+0x32>
					//xcmp_enter_enhanced_OB_mode();
					//xcmp_unmute_speaker();
					//Speaker_is_unmute = 1;
					//xcmp_function_mic();
					
					isAudioRouting = 1;
800020be:	8d 05       	st.w	r6[0x0],r5
800020c0:	c1 c8       	rjmp	800020f8 <app_cfg+0x68>
				}
				else if(isAudioRouting == 1)
800020c2:	58 18       	cp.w	r8,1
800020c4:	c0 31       	brne	800020ca <app_cfg+0x3a>
					//xcmp_button_config();
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//log("\n\r time: %d \n\r", tc_tick);
					
					isAudioRouting = 2;
800020c6:	8d 04       	st.w	r6[0x0],r4
800020c8:	c1 88       	rjmp	800020f8 <app_cfg+0x68>
					//isAudioRouting++;
				}
				else if(isAudioRouting == 2)
800020ca:	58 28       	cp.w	r8,2
800020cc:	c0 91       	brne	800020de <app_cfg+0x4e>
				{				
					xcmp_data_session_req(message, 12, 9);
800020ce:	02 9a       	mov	r10,r1
800020d0:	00 9b       	mov	r11,r0
800020d2:	04 9c       	mov	r12,r2
800020d4:	f0 1f 00 12 	mcall	8000211c <app_cfg+0x8c>
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_mute_speaker();	
					//log("\n\r time: %d \n\r", tc_tick); 
					isAudioRouting = 3;
800020d8:	30 38       	mov	r8,3
800020da:	8d 08       	st.w	r6[0x0],r8
800020dc:	c0 e8       	rjmp	800020f8 <app_cfg+0x68>
					
				}
				else if(isAudioRouting == 3)
800020de:	58 38       	cp.w	r8,3
800020e0:	c0 31       	brne	800020e6 <app_cfg+0x56>
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_exit_enhanced_OB_mode();
					//xcmp_mute_speaker();
					//xcmp_enhanced_OB_mode();
					isAudioRouting = 4;
800020e2:	8d 03       	st.w	r6[0x0],r3
800020e4:	c0 a8       	rjmp	800020f8 <app_cfg+0x68>
					
				}
				else
				{
					isAudioRouting++;
800020e6:	2f f8       	sub	r8,-1
800020e8:	8d 08       	st.w	r6[0x0],r8
					if(isAudioRouting == 5)xcmp_data_session_req(message, 12, 9);
800020ea:	58 58       	cp.w	r8,5
800020ec:	c0 61       	brne	800020f8 <app_cfg+0x68>
800020ee:	02 9a       	mov	r10,r1
800020f0:	00 9b       	mov	r11,r0
800020f2:	04 9c       	mov	r12,r2
800020f4:	f0 1f 00 0a 	mcall	8000211c <app_cfg+0x8c>
			
		}
		//vTaskDelay(300*2 / portTICK_RATE_MS);//延迟300ms
		//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
		
		vTaskDelayUntil( &xLastWakeTime, 2000*2 / portTICK_RATE_MS  );//精确的以1000ms为周期执行。
800020f8:	e0 6b 0f a0 	mov	r11,4000
800020fc:	48 3c       	lddpc	r12,80002108 <app_cfg+0x78>
800020fe:	f0 1f 00 09 	mcall	80002120 <app_cfg+0x90>
	}
80002102:	cd 4b       	rjmp	800020aa <app_cfg+0x1a>
80002104:	80 00       	ld.sh	r0,r0[0x0]
80002106:	5a dc       	cp.w	r12,-19
80002108:	00 00       	add	r0,r0
8000210a:	0a 50       	eor	r0,r5
8000210c:	00 00       	add	r0,r0
8000210e:	0d 8c       	ld.ub	r12,r6[0x0]
80002110:	00 00       	add	r0,r0
80002112:	0a 4c       	or	r12,r5
80002114:	00 00       	add	r0,r0
80002116:	00 04       	add	r4,r0
80002118:	80 00       	ld.sh	r0,r0[0x0]
8000211a:	42 ac       	lddsp	r12,sp[0xa8]
8000211c:	80 00       	ld.sh	r0,r0[0x0]
8000211e:	41 78       	lddsp	r8,sp[0x5c]
80002120:	80 00       	ld.sh	r0,r0[0x0]
80002122:	5c 44       	abs	r4

80002124 <app_payload_tx_proc>:

}


static void app_payload_tx_proc(void  * payload)
{
80002124:	d4 01       	pushm	lr
  log("R");
80002126:	48 3c       	lddpc	r12,80002130 <app_payload_tx_proc+0xc>
80002128:	f0 1f 00 03 	mcall	80002134 <app_payload_tx_proc+0x10>
  //
  //
  //set_payload_idle(payload);


}
8000212c:	d8 02       	popm	pc
8000212e:	00 00       	add	r0,r0
80002130:	80 00       	ld.sh	r0,r0[0x0]
80002132:	c2 08       	rjmp	80002172 <FD_request_func+0x12>
80002134:	80 00       	ld.sh	r0,r0[0x0]
80002136:	61 68       	ld.w	r8,r0[0x58]

80002138 <FD_brdcst_func>:
	
	
}

void FD_brdcst_func(xcmp_fragment_t * xcmp)
{
80002138:	d4 01       	pushm	lr
	
	
	log("\n\r Forward Data Broadcast \n\r");
8000213a:	48 3c       	lddpc	r12,80002144 <FD_brdcst_func+0xc>
8000213c:	f0 1f 00 03 	mcall	80002148 <FD_brdcst_func+0x10>
	
}
80002140:	d8 02       	popm	pc
80002142:	00 00       	add	r0,r0
80002144:	80 00       	ld.sh	r0,r0[0x0]
80002146:	c2 0c       	rcall	80002186 <EnOB_brdcst_func+0x12>
80002148:	80 00       	ld.sh	r0,r0[0x0]
8000214a:	61 68       	ld.w	r8,r0[0x58]

8000214c <FD_reply_func>:
	
	
}

void FD_reply_func(xcmp_fragment_t * xcmp)
{
8000214c:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Reply \n\r");
8000214e:	48 3c       	lddpc	r12,80002158 <FD_reply_func+0xc>
80002150:	f0 1f 00 03 	mcall	8000215c <FD_reply_func+0x10>
	
	
}
80002154:	d8 02       	popm	pc
80002156:	00 00       	add	r0,r0
80002158:	80 00       	ld.sh	r0,r0[0x0]
8000215a:	c2 2c       	rcall	8000219e <EnOB_reply_func+0x16>
8000215c:	80 00       	ld.sh	r0,r0[0x0]
8000215e:	61 68       	ld.w	r8,r0[0x58]

80002160 <FD_request_func>:
}



void FD_request_func(xcmp_fragment_t * xcmp)
{
80002160:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Request \n\r");
80002162:	48 3c       	lddpc	r12,8000216c <FD_request_func+0xc>
80002164:	f0 1f 00 03 	mcall	80002170 <FD_request_func+0x10>
	
	
}
80002168:	d8 02       	popm	pc
8000216a:	00 00       	add	r0,r0
8000216c:	80 00       	ld.sh	r0,r0[0x0]
8000216e:	c2 48       	rjmp	800021b6 <EnOB_reply_func+0x2e>
80002170:	80 00       	ld.sh	r0,r0[0x0]
80002172:	61 68       	ld.w	r8,r0[0x58]

80002174 <EnOB_brdcst_func>:
	
	
}

void EnOB_brdcst_func(xcmp_fragment_t * xcmp)
{
80002174:	d4 01       	pushm	lr
	
	
	log("\n\r En_OB Broadcast \n\r");
80002176:	48 3c       	lddpc	r12,80002180 <EnOB_brdcst_func+0xc>
80002178:	f0 1f 00 03 	mcall	80002184 <EnOB_brdcst_func+0x10>
}
8000217c:	d8 02       	popm	pc
8000217e:	00 00       	add	r0,r0
80002180:	80 00       	ld.sh	r0,r0[0x0]
80002182:	c2 64       	brge	800021ce <EnOB_reply_func+0x46>
80002184:	80 00       	ld.sh	r0,r0[0x0]
80002186:	61 68       	ld.w	r8,r0[0x58]

80002188 <EnOB_reply_func>:
}



void EnOB_reply_func(xcmp_fragment_t * xcmp)
{
80002188:	eb cd 40 80 	pushm	r7,lr
8000218c:	18 97       	mov	r7,r12
		/*point to xcmp payload*/
	//En_OB_Control_reply_t *ptr = (En_OB_Control_reply_t* )xcmp->u8;
	//log("\n\r Xcmp_opcode: %x \n\r", xcmp->xcmp_opcode);
	
	if (xcmp->u8[0]== xcmp_Res_Success)
8000218e:	19 a9       	ld.ub	r9,r12[0x2]
80002190:	30 08       	mov	r8,0
80002192:	f0 09 18 00 	cp.b	r9,r8
80002196:	c1 91       	brne	800021c8 <EnOB_reply_func+0x40>
	{
		if (xcmp->u8[1] == EN_OB_Enter)
80002198:	19 b8       	ld.ub	r8,r12[0x3]
8000219a:	30 19       	mov	r9,1
8000219c:	f2 08 18 00 	cp.b	r8,r9
800021a0:	c0 61       	brne	800021ac <EnOB_reply_func+0x24>
		{
		
			log("\n\r En_OB_Enter OK \n\r");
800021a2:	49 0c       	lddpc	r12,800021e0 <EnOB_reply_func+0x58>
800021a4:	f0 1f 00 10 	mcall	800021e4 <EnOB_reply_func+0x5c>
800021a8:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else if (xcmp->u8[1] == EN_OB_Exit )
800021ac:	58 08       	cp.w	r8,0
800021ae:	c0 61       	brne	800021ba <EnOB_reply_func+0x32>
		{
			log("\n\r En_OB_Exit OK \n\r");
800021b0:	48 ec       	lddpc	r12,800021e8 <EnOB_reply_func+0x60>
800021b2:	f0 1f 00 0d 	mcall	800021e4 <EnOB_reply_func+0x5c>
800021b6:	e3 cd 80 80 	ldm	sp++,r7,pc
		}
		else
		{
			
			log("\n\r En_OB_Control: %x \n\r", xcmp->u8[1]);
800021ba:	1a d8       	st.w	--sp,r8
800021bc:	48 cc       	lddpc	r12,800021ec <EnOB_reply_func+0x64>
800021be:	f0 1f 00 0a 	mcall	800021e4 <EnOB_reply_func+0x5c>
800021c2:	2f fd       	sub	sp,-4
800021c4:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r En_OB_Control error \n\r");
800021c8:	48 ac       	lddpc	r12,800021f0 <EnOB_reply_func+0x68>
800021ca:	f0 1f 00 07 	mcall	800021e4 <EnOB_reply_func+0x5c>
		log("\n\r En_OB_result: %x \n\r", xcmp->u8[0]);
800021ce:	0f a8       	ld.ub	r8,r7[0x2]
800021d0:	1a d8       	st.w	--sp,r8
800021d2:	48 9c       	lddpc	r12,800021f4 <EnOB_reply_func+0x6c>
800021d4:	f0 1f 00 04 	mcall	800021e4 <EnOB_reply_func+0x5c>
800021d8:	2f fd       	sub	sp,-4
800021da:	e3 cd 80 80 	ldm	sp++,r7,pc
800021de:	00 00       	add	r0,r0
800021e0:	80 00       	ld.sh	r0,r0[0x0]
800021e2:	c2 7c       	rcall	80002230 <ButtonConfig_brdcst_func+0x1c>
800021e4:	80 00       	ld.sh	r0,r0[0x0]
800021e6:	61 68       	ld.w	r8,r0[0x58]
800021e8:	80 00       	ld.sh	r0,r0[0x0]
800021ea:	c2 94       	brge	8000223c <ButtonConfig_brdcst_func+0x28>
800021ec:	80 00       	ld.sh	r0,r0[0x0]
800021ee:	c2 a8       	rjmp	80002242 <ButtonConfig_brdcst_func+0x2e>
800021f0:	80 00       	ld.sh	r0,r0[0x0]
800021f2:	c2 c0       	breq	8000224a <ButtonConfig_brdcst_func+0x36>
800021f4:	80 00       	ld.sh	r0,r0[0x0]
800021f6:	c2 dc       	rcall	80002250 <ButtonConfig_brdcst_func+0x3c>

800021f8 <SingleDetection_brdcst_func>:
	
}


void SingleDetection_brdcst_func(xcmp_fragment_t * xcmp)
{
800021f8:	d4 01       	pushm	lr
	if (xcmp->u8[0] == 0x11)
800021fa:	19 a9       	ld.ub	r9,r12[0x2]
800021fc:	31 18       	mov	r8,17
800021fe:	f0 09 18 00 	cp.b	r9,r8
80002202:	c0 41       	brne	8000220a <SingleDetection_brdcst_func+0x12>
	{
		log("\n\r DMR_CSBK OK \n\r");
80002204:	48 2c       	lddpc	r12,8000220c <SingleDetection_brdcst_func+0x14>
80002206:	f0 1f 00 03 	mcall	80002210 <SingleDetection_brdcst_func+0x18>
8000220a:	d8 02       	popm	pc
8000220c:	80 00       	ld.sh	r0,r0[0x0]
8000220e:	c2 f4       	brge	8000226c <ButtonConfig_brdcst_func+0x58>
80002210:	80 00       	ld.sh	r0,r0[0x0]
80002212:	61 68       	ld.w	r8,r0[0x58]

80002214 <ButtonConfig_brdcst_func>:
	
}


void ButtonConfig_brdcst_func(xcmp_fragment_t * xcmp)
{
80002214:	d4 31       	pushm	r0-r7,lr
	U8 Num_Button =0;
	U8 i = 0 ;
	/*point to xcmp payload*/
	ButtonConfig_brdcst_t  *ptr = (ButtonConfig_brdcst_t* )xcmp->u8;
80002216:	f8 c7 ff fe 	sub	r7,r12,-2
	
	Num_Button = ptr->NumOfButtons;
8000221a:	0f 95       	ld.ub	r5,r7[0x1]
	
	log("\n\r ButtonConfig_broadcast  \n\r"  );
8000221c:	4a bc       	lddpc	r12,800022c8 <ButtonConfig_brdcst_func+0xb4>
8000221e:	f0 1f 00 2c 	mcall	800022cc <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r Function: %X \n\r" , ptr->Function );
80002222:	0f 88       	ld.ub	r8,r7[0x0]
80002224:	1a d8       	st.w	--sp,r8
80002226:	4a bc       	lddpc	r12,800022d0 <ButtonConfig_brdcst_func+0xbc>
80002228:	f0 1f 00 29 	mcall	800022cc <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
8000222c:	1a d5       	st.w	--sp,r5
8000222e:	4a ac       	lddpc	r12,800022d4 <ButtonConfig_brdcst_func+0xc0>
80002230:	f0 1f 00 27 	mcall	800022cc <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
80002234:	0f a8       	ld.ub	r8,r7[0x2]
80002236:	1a d8       	st.w	--sp,r8
80002238:	4a 8c       	lddpc	r12,800022d8 <ButtonConfig_brdcst_func+0xc4>
8000223a:	f0 1f 00 25 	mcall	800022cc <ButtonConfig_brdcst_func+0xb8>
	
	for (i; i<Num_Button; i++)
8000223e:	2f dd       	sub	sp,-12
80002240:	58 05       	cp.w	r5,0
80002242:	c4 10       	breq	800022c4 <ButtonConfig_brdcst_func+0xb0>
80002244:	30 06       	mov	r6,0
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
80002246:	4a 64       	lddpc	r4,800022dc <ButtonConfig_brdcst_func+0xc8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
80002248:	4a 63       	lddpc	r3,800022e0 <ButtonConfig_brdcst_func+0xcc>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
8000224a:	4a 72       	lddpc	r2,800022e4 <ButtonConfig_brdcst_func+0xd0>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
8000224c:	4a 71       	lddpc	r1,800022e8 <ButtonConfig_brdcst_func+0xd4>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
8000224e:	4a 80       	lddpc	r0,800022ec <ButtonConfig_brdcst_func+0xd8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
80002250:	0f b9       	ld.ub	r9,r7[0x3]
80002252:	0f c8       	ld.ub	r8,r7[0x4]
80002254:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002258:	1a d8       	st.w	--sp,r8
8000225a:	1a d6       	st.w	--sp,r6
8000225c:	08 9c       	mov	r12,r4
8000225e:	f0 1f 00 1c 	mcall	800022cc <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
80002262:	0f d9       	ld.ub	r9,r7[0x5]
80002264:	0f e8       	ld.ub	r8,r7[0x6]
80002266:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000226a:	1a d8       	st.w	--sp,r8
8000226c:	1a d6       	st.w	--sp,r6
8000226e:	06 9c       	mov	r12,r3
80002270:	f0 1f 00 17 	mcall	800022cc <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
80002274:	0f f9       	ld.ub	r9,r7[0x7]
80002276:	ef 38 00 08 	ld.ub	r8,r7[8]
8000227a:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000227e:	1a d8       	st.w	--sp,r8
80002280:	1a d6       	st.w	--sp,r6
80002282:	04 9c       	mov	r12,r2
80002284:	f0 1f 00 12 	mcall	800022cc <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
80002288:	ef 39 00 09 	ld.ub	r9,r7[9]
8000228c:	ef 38 00 0a 	ld.ub	r8,r7[10]
80002290:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002294:	1a d8       	st.w	--sp,r8
80002296:	1a d6       	st.w	--sp,r6
80002298:	02 9c       	mov	r12,r1
8000229a:	f0 1f 00 0d 	mcall	800022cc <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
8000229e:	2f 8d       	sub	sp,-32
800022a0:	ef 39 00 0b 	ld.ub	r9,r7[11]
800022a4:	ef 38 00 0c 	ld.ub	r8,r7[12]
800022a8:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800022ac:	1a d8       	st.w	--sp,r8
800022ae:	1a d6       	st.w	--sp,r6
800022b0:	00 9c       	mov	r12,r0
800022b2:	f0 1f 00 07 	mcall	800022cc <ButtonConfig_brdcst_func+0xb8>
800022b6:	2f f6       	sub	r6,-1
800022b8:	2f 67       	sub	r7,-10
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
800022ba:	2f ed       	sub	sp,-8
800022bc:	ec 05 18 00 	cp.b	r5,r6
800022c0:	fe 9b ff c8 	brhi	80002250 <ButtonConfig_brdcst_func+0x3c>
800022c4:	d8 32       	popm	r0-r7,pc
800022c6:	00 00       	add	r0,r0
800022c8:	80 00       	ld.sh	r0,r0[0x0]
800022ca:	c3 08       	rjmp	8000232a <Phyuserinput_brdcst_func+0x3a>
800022cc:	80 00       	ld.sh	r0,r0[0x0]
800022ce:	61 68       	ld.w	r8,r0[0x58]
800022d0:	80 00       	ld.sh	r0,r0[0x0]
800022d2:	c3 28       	rjmp	80002336 <Phyuserinput_brdcst_func+0x46>
800022d4:	80 00       	ld.sh	r0,r0[0x0]
800022d6:	c3 3c       	rcall	8000233c <Phyuserinput_brdcst_func+0x4c>
800022d8:	80 00       	ld.sh	r0,r0[0x0]
800022da:	c3 54       	brge	80002344 <Phyuserinput_brdcst_func+0x54>
800022dc:	80 00       	ld.sh	r0,r0[0x0]
800022de:	c3 74       	brge	8000234c <Phyuserinput_brdcst_func+0x5c>
800022e0:	80 00       	ld.sh	r0,r0[0x0]
800022e2:	c3 9c       	rcall	80002354 <Phyuserinput_brdcst_func+0x64>
800022e4:	80 00       	ld.sh	r0,r0[0x0]
800022e6:	c3 c4       	brge	8000235e <Phyuserinput_brdcst_func+0x6e>
800022e8:	80 00       	ld.sh	r0,r0[0x0]
800022ea:	c3 e8       	rjmp	80002366 <Phyuserinput_brdcst_func+0x76>
800022ec:	80 00       	ld.sh	r0,r0[0x0]
800022ee:	c4 10       	breq	80002370 <ButtonConfig_reply_func+0x8>

800022f0 <Phyuserinput_brdcst_func>:
	
}


void Phyuserinput_brdcst_func(xcmp_fragment_t * xcmp)
{
800022f0:	eb cd 40 fc 	pushm	r2-r7,lr
	U16 PUI_ID =0;
	U8 PUI_State =0;
	U8 PUI_State_Min_Value =0;
	U8 PUI_State_Max_Value =0;
	
	PUI_Source = xcmp->u8[0];
800022f4:	19 a6       	ld.ub	r6,r12[0x2]
	PUI_Type = xcmp ->u8[1];
800022f6:	19 b5       	ld.ub	r5,r12[0x3]
	PUI_ID = ((xcmp->u8[2]<<8) | xcmp->u8[3]);
800022f8:	19 c7       	ld.ub	r7,r12[0x4]
800022fa:	19 d8       	ld.ub	r8,r12[0x5]
800022fc:	f1 e7 10 87 	or	r7,r8,r7<<0x8
	PUI_State = xcmp->u8[4];
80002300:	19 e4       	ld.ub	r4,r12[0x6]
	PUI_State_Min_Value = xcmp->u8[5];
80002302:	19 f3       	ld.ub	r3,r12[0x7]
	PUI_State_Max_Value = xcmp->u8[6];
80002304:	f9 32 00 08 	ld.ub	r2,r12[8]
	
	log("\n\r PhysicalUserInput_broadcast  \n\r"  );
80002308:	49 0c       	lddpc	r12,80002348 <Phyuserinput_brdcst_func+0x58>
8000230a:	f0 1f 00 11 	mcall	8000234c <Phyuserinput_brdcst_func+0x5c>
	
	log("\n\r PUI_Source: %X \n\r" , PUI_Source);
8000230e:	1a d6       	st.w	--sp,r6
80002310:	49 0c       	lddpc	r12,80002350 <Phyuserinput_brdcst_func+0x60>
80002312:	f0 1f 00 0f 	mcall	8000234c <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_Type: %X \n\r" , PUI_Type);
80002316:	1a d5       	st.w	--sp,r5
80002318:	48 fc       	lddpc	r12,80002354 <Phyuserinput_brdcst_func+0x64>
8000231a:	f0 1f 00 0d 	mcall	8000234c <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_ID: %X \n\r" , PUI_ID);
8000231e:	5c 77       	castu.h	r7
80002320:	1a d7       	st.w	--sp,r7
80002322:	48 ec       	lddpc	r12,80002358 <Phyuserinput_brdcst_func+0x68>
80002324:	f0 1f 00 0a 	mcall	8000234c <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_State: %X \n\r" , PUI_State);
80002328:	1a d4       	st.w	--sp,r4
8000232a:	48 dc       	lddpc	r12,8000235c <Phyuserinput_brdcst_func+0x6c>
8000232c:	f0 1f 00 08 	mcall	8000234c <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_State_Min_Value: %X \n\r" , PUI_State_Min_Value);
80002330:	1a d3       	st.w	--sp,r3
80002332:	48 cc       	lddpc	r12,80002360 <Phyuserinput_brdcst_func+0x70>
80002334:	f0 1f 00 06 	mcall	8000234c <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_State_Max_Value: %X \n\r" , PUI_State_Max_Value);
80002338:	1a d2       	st.w	--sp,r2
8000233a:	48 bc       	lddpc	r12,80002364 <Phyuserinput_brdcst_func+0x74>
8000233c:	f0 1f 00 04 	mcall	8000234c <Phyuserinput_brdcst_func+0x5c>
80002340:	2f ad       	sub	sp,-24
	
	
	
	
	
}
80002342:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80002346:	00 00       	add	r0,r0
80002348:	80 00       	ld.sh	r0,r0[0x0]
8000234a:	c4 34       	brge	800023d0 <DataSession_brdcst_func+0x24>
8000234c:	80 00       	ld.sh	r0,r0[0x0]
8000234e:	61 68       	ld.w	r8,r0[0x58]
80002350:	80 00       	ld.sh	r0,r0[0x0]
80002352:	c4 58       	rjmp	800023dc <DataSession_brdcst_func+0x30>
80002354:	80 00       	ld.sh	r0,r0[0x0]
80002356:	c4 70       	breq	800023e4 <DataSession_brdcst_func+0x38>
80002358:	80 00       	ld.sh	r0,r0[0x0]
8000235a:	c4 84       	brge	800023ea <DataSession_brdcst_func+0x3e>
8000235c:	80 00       	ld.sh	r0,r0[0x0]
8000235e:	c4 98       	rjmp	800023f0 <DataSession_brdcst_func+0x44>
80002360:	80 00       	ld.sh	r0,r0[0x0]
80002362:	c4 ac       	rcall	800023f6 <DataSession_brdcst_func+0x4a>
80002364:	80 00       	ld.sh	r0,r0[0x0]
80002366:	c4 cc       	rcall	800023fe <DataSession_brdcst_func+0x52>

80002368 <ButtonConfig_reply_func>:
	}
	
}

void ButtonConfig_reply_func(xcmp_fragment_t * xcmp)
{
80002368:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	ButtonConfig_reply_t *ptr = (ButtonConfig_reply_t* )(xcmp->u8);
8000236c:	f8 c7 ff fe 	sub	r7,r12,-2
	if (ptr->Result == xcmp_Res_Success)
80002370:	0f 89       	ld.ub	r9,r7[0x0]
80002372:	30 08       	mov	r8,0
80002374:	f0 09 18 00 	cp.b	r9,r8
80002378:	c0 c1       	brne	80002390 <ButtonConfig_reply_func+0x28>
	{
		log("\n\r Button_Config OK \n\r");
8000237a:	48 9c       	lddpc	r12,8000239c <ButtonConfig_reply_func+0x34>
8000237c:	f0 1f 00 09 	mcall	800023a0 <ButtonConfig_reply_func+0x38>
		
		log("\n\r Function: %X \n\r" , ptr->Function );
80002380:	0f 98       	ld.ub	r8,r7[0x1]
80002382:	1a d8       	st.w	--sp,r8
80002384:	48 8c       	lddpc	r12,800023a4 <ButtonConfig_reply_func+0x3c>
80002386:	f0 1f 00 07 	mcall	800023a0 <ButtonConfig_reply_func+0x38>
8000238a:	2f fd       	sub	sp,-4
8000238c:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r Button_Request error \n\r");
80002390:	48 6c       	lddpc	r12,800023a8 <ButtonConfig_reply_func+0x40>
80002392:	f0 1f 00 04 	mcall	800023a0 <ButtonConfig_reply_func+0x38>
80002396:	e3 cd 80 80 	ldm	sp++,r7,pc
8000239a:	00 00       	add	r0,r0
8000239c:	80 00       	ld.sh	r0,r0[0x0]
8000239e:	c4 ec       	rcall	8000243a <DataSession_brdcst_func+0x8e>
800023a0:	80 00       	ld.sh	r0,r0[0x0]
800023a2:	61 68       	ld.w	r8,r0[0x58]
800023a4:	80 00       	ld.sh	r0,r0[0x0]
800023a6:	c3 28       	rjmp	8000240a <DataSession_brdcst_func+0x5e>
800023a8:	80 00       	ld.sh	r0,r0[0x0]
800023aa:	c5 04       	brge	8000244a <DataSession_brdcst_func+0x9e>

800023ac <DataSession_brdcst_func>:
	}
	
}

void DataSession_brdcst_func(xcmp_fragment_t * xcmp)
{
800023ac:	d4 21       	pushm	r4-r7,lr
	U8 Session_number = 0;
	U16 data_length = 0;
	U8 i = 0;
	/*point to xcmp payload*/
	DataSession_brdcst_t *ptr = (DataSession_brdcst_t* )xcmp->u8;
800023ae:	f8 c6 ff fe 	sub	r6,r12,-2

	if (ptr->State == CSBK_DATA_RX_Suc)
800023b2:	0d 88       	ld.ub	r8,r6[0x0]
800023b4:	32 49       	mov	r9,36
800023b6:	f2 08 18 00 	cp.b	r8,r9
800023ba:	c2 91       	brne	8000240c <DataSession_brdcst_func+0x60>
	{
		
		log("\n\r CSBK_RX OK \n\r");
800023bc:	4a dc       	lddpc	r12,80002470 <DataSession_brdcst_func+0xc4>
800023be:	f0 1f 00 2e 	mcall	80002474 <DataSession_brdcst_func+0xc8>
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
800023c2:	0d a5       	ld.ub	r5,r6[0x2]
800023c4:	0d b8       	ld.ub	r8,r6[0x3]
800023c6:	f1 e5 10 85 	or	r5,r8,r5<<0x8
800023ca:	5c 85       	casts.h	r5

		log("\n\r Session_ID: %x \n\r",Session_number );
800023cc:	0d 98       	ld.ub	r8,r6[0x1]
800023ce:	1a d8       	st.w	--sp,r8
800023d0:	4a ac       	lddpc	r12,80002478 <DataSession_brdcst_func+0xcc>
800023d2:	f0 1f 00 29 	mcall	80002474 <DataSession_brdcst_func+0xc8>
		log("\n\r paylaod_length: %d \n\r",data_length );
800023d6:	f1 d5 c0 10 	bfextu	r8,r5,0x0,0x10
800023da:	1a d8       	st.w	--sp,r8
800023dc:	4a 8c       	lddpc	r12,8000247c <DataSession_brdcst_func+0xd0>
800023de:	f0 1f 00 26 	mcall	80002474 <DataSession_brdcst_func+0xc8>
		for(i=0; i<data_length; i++)
800023e2:	2f ed       	sub	sp,-8
800023e4:	58 05       	cp.w	r5,0
800023e6:	c4 40       	breq	8000246e <DataSession_brdcst_func+0xc2>
800023e8:	30 07       	mov	r7,0
		{
			
			//log("\n\r payload[%d]: %X \n\r", i, xcmp->u8[4+i]);
			log("\n\r payload[%d]: %X \n\r", i, ptr->DataPayload.DataPayload[i]);
800023ea:	4a 64       	lddpc	r4,80002480 <DataSession_brdcst_func+0xd4>
800023ec:	ec 07 00 08 	add	r8,r6,r7
800023f0:	11 c8       	ld.ub	r8,r8[0x4]
800023f2:	1a d8       	st.w	--sp,r8
800023f4:	1a d7       	st.w	--sp,r7
800023f6:	08 9c       	mov	r12,r4
800023f8:	f0 1f 00 1f 	mcall	80002474 <DataSession_brdcst_func+0xc8>
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);

		log("\n\r Session_ID: %x \n\r",Session_number );
		log("\n\r paylaod_length: %d \n\r",data_length );
		for(i=0; i<data_length; i++)
800023fc:	2f f7       	sub	r7,-1
800023fe:	5c 57       	castu.b	r7
80002400:	2f ed       	sub	sp,-8
80002402:	ee 05 19 00 	cp.h	r5,r7
80002406:	fe 9b ff f3 	brhi	800023ec <DataSession_brdcst_func+0x40>
8000240a:	d8 22       	popm	r4-r7,pc
		
	}
	else
	{
		//log("\n\r State: 0x %X \n\r", xcmp->u8[0]);
		log("State: 0x %X \n", ptr->State);
8000240c:	1a d8       	st.w	--sp,r8
8000240e:	49 ec       	lddpc	r12,80002484 <DataSession_brdcst_func+0xd8>
80002410:	f0 1f 00 19 	mcall	80002474 <DataSession_brdcst_func+0xc8>
		if (ptr->State)
80002414:	2f fd       	sub	sp,-4
80002416:	0d 89       	ld.ub	r9,r6[0x0]
80002418:	30 08       	mov	r8,0
8000241a:	f0 09 18 00 	cp.b	r9,r8
8000241e:	c0 40       	breq	80002426 <DataSession_brdcst_func+0x7a>
		{
			log("data transmit success\n");
80002420:	49 ac       	lddpc	r12,80002488 <DataSession_brdcst_func+0xdc>
80002422:	f0 1f 00 15 	mcall	80002474 <DataSession_brdcst_func+0xc8>
		}
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];
			
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
80002426:	0d a5       	ld.ub	r5,r6[0x2]
80002428:	0d b8       	ld.ub	r8,r6[0x3]
8000242a:	f1 e5 10 85 	or	r5,r8,r5<<0x8
8000242e:	5c 85       	casts.h	r5

		log("\n\r Session_ID: %x \n\r",Session_number );
80002430:	0d 98       	ld.ub	r8,r6[0x1]
80002432:	1a d8       	st.w	--sp,r8
80002434:	49 1c       	lddpc	r12,80002478 <DataSession_brdcst_func+0xcc>
80002436:	f0 1f 00 10 	mcall	80002474 <DataSession_brdcst_func+0xc8>
		log("\n\r paylaod_length: %d \n\r",data_length );
8000243a:	f1 d5 c0 10 	bfextu	r8,r5,0x0,0x10
8000243e:	1a d8       	st.w	--sp,r8
80002440:	48 fc       	lddpc	r12,8000247c <DataSession_brdcst_func+0xd0>
80002442:	f0 1f 00 0d 	mcall	80002474 <DataSession_brdcst_func+0xc8>
		for(i=0; i<data_length; i++)
80002446:	2f ed       	sub	sp,-8
80002448:	58 05       	cp.w	r5,0
8000244a:	c1 20       	breq	8000246e <DataSession_brdcst_func+0xc2>
8000244c:	30 07       	mov	r7,0
		{
				
			//log("\n\r payload[%d]: %X \n\r", i, xcmp->u8[4+i]);
			log("\n\r payload[%d]: %X \n\r", i, ptr->DataPayload.DataPayload[i]);
8000244e:	48 d4       	lddpc	r4,80002480 <DataSession_brdcst_func+0xd4>
80002450:	ec 07 00 08 	add	r8,r6,r7
80002454:	11 c8       	ld.ub	r8,r8[0x4]
80002456:	1a d8       	st.w	--sp,r8
80002458:	1a d7       	st.w	--sp,r7
8000245a:	08 9c       	mov	r12,r4
8000245c:	f0 1f 00 06 	mcall	80002474 <DataSession_brdcst_func+0xc8>
			
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);

		log("\n\r Session_ID: %x \n\r",Session_number );
		log("\n\r paylaod_length: %d \n\r",data_length );
		for(i=0; i<data_length; i++)
80002460:	2f f7       	sub	r7,-1
80002462:	5c 57       	castu.b	r7
80002464:	2f ed       	sub	sp,-8
80002466:	ee 05 19 00 	cp.h	r5,r7
8000246a:	fe 9b ff f3 	brhi	80002450 <DataSession_brdcst_func+0xa4>
8000246e:	d8 22       	popm	r4-r7,pc
80002470:	80 00       	ld.sh	r0,r0[0x0]
80002472:	c5 20       	breq	80002516 <CallControl_brdcst_func+0xe>
80002474:	80 00       	ld.sh	r0,r0[0x0]
80002476:	61 68       	ld.w	r8,r0[0x58]
80002478:	80 00       	ld.sh	r0,r0[0x0]
8000247a:	c5 34       	brge	80002520 <CallControl_brdcst_func+0x18>
8000247c:	80 00       	ld.sh	r0,r0[0x0]
8000247e:	c5 4c       	rcall	80002526 <CallControl_brdcst_func+0x1e>
80002480:	80 00       	ld.sh	r0,r0[0x0]
80002482:	c5 68       	rjmp	8000252e <CallControl_brdcst_func+0x26>
80002484:	80 00       	ld.sh	r0,r0[0x0]
80002486:	c5 80       	breq	80002536 <CallControl_brdcst_func+0x2e>
80002488:	80 00       	ld.sh	r0,r0[0x0]
8000248a:	c5 90       	breq	8000253c <CallControl_brdcst_func+0x34>

8000248c <DataSession_reply_func>:
	
	
}

void DataSession_reply_func(xcmp_fragment_t * xcmp)
{
8000248c:	eb cd 40 80 	pushm	r7,lr
80002490:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
80002492:	19 a9       	ld.ub	r9,r12[0x2]
80002494:	30 08       	mov	r8,0
80002496:	f0 09 18 00 	cp.b	r9,r8
8000249a:	c1 11       	brne	800024bc <DataSession_reply_func+0x30>
	{
		log("DATArep OK \n");
8000249c:	49 3c       	lddpc	r12,800024e8 <DataSession_reply_func+0x5c>
8000249e:	f0 1f 00 14 	mcall	800024ec <DataSession_reply_func+0x60>
		log("Func: %X \n", xcmp->u8[1]);
800024a2:	0f b8       	ld.ub	r8,r7[0x3]
800024a4:	1a d8       	st.w	--sp,r8
800024a6:	49 3c       	lddpc	r12,800024f0 <DataSession_reply_func+0x64>
800024a8:	f0 1f 00 11 	mcall	800024ec <DataSession_reply_func+0x60>
		log("ID: %X \n", xcmp->u8[2]);
800024ac:	0f c8       	ld.ub	r8,r7[0x4]
800024ae:	1a d8       	st.w	--sp,r8
800024b0:	49 1c       	lddpc	r12,800024f4 <DataSession_reply_func+0x68>
800024b2:	f0 1f 00 0f 	mcall	800024ec <DataSession_reply_func+0x60>
800024b6:	2f ed       	sub	sp,-8
800024b8:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	else
	{	
		log("DATArep error \n");
800024bc:	48 fc       	lddpc	r12,800024f8 <DataSession_reply_func+0x6c>
800024be:	f0 1f 00 0c 	mcall	800024ec <DataSession_reply_func+0x60>
		log("Result:  %X \n", xcmp->u8[0]);
800024c2:	0f a8       	ld.ub	r8,r7[0x2]
800024c4:	1a d8       	st.w	--sp,r8
800024c6:	48 ec       	lddpc	r12,800024fc <DataSession_reply_func+0x70>
800024c8:	f0 1f 00 09 	mcall	800024ec <DataSession_reply_func+0x60>
		log("Func:  %X \n", xcmp->u8[1]);
800024cc:	0f b8       	ld.ub	r8,r7[0x3]
800024ce:	1a d8       	st.w	--sp,r8
800024d0:	48 cc       	lddpc	r12,80002500 <DataSession_reply_func+0x74>
800024d2:	f0 1f 00 07 	mcall	800024ec <DataSession_reply_func+0x60>
		log("ID:  %X \n", xcmp->u8[2]);
800024d6:	0f c8       	ld.ub	r8,r7[0x4]
800024d8:	1a d8       	st.w	--sp,r8
800024da:	48 bc       	lddpc	r12,80002504 <DataSession_reply_func+0x78>
800024dc:	f0 1f 00 04 	mcall	800024ec <DataSession_reply_func+0x60>
800024e0:	2f dd       	sub	sp,-12
800024e2:	e3 cd 80 80 	ldm	sp++,r7,pc
800024e6:	00 00       	add	r0,r0
800024e8:	80 00       	ld.sh	r0,r0[0x0]
800024ea:	c5 a8       	rjmp	8000259e <TransmitControl_reply_func+0xa>
800024ec:	80 00       	ld.sh	r0,r0[0x0]
800024ee:	61 68       	ld.w	r8,r0[0x58]
800024f0:	80 00       	ld.sh	r0,r0[0x0]
800024f2:	c5 b8       	rjmp	800025a8 <TransmitControl_reply_func+0x14>
800024f4:	80 00       	ld.sh	r0,r0[0x0]
800024f6:	c5 c4       	brge	800025ae <TransmitControl_reply_func+0x1a>
800024f8:	80 00       	ld.sh	r0,r0[0x0]
800024fa:	c5 d0       	breq	800025b4 <TransmitControl_reply_func+0x20>
800024fc:	80 00       	ld.sh	r0,r0[0x0]
800024fe:	c5 e0       	breq	800025ba <TransmitControl_reply_func+0x26>
80002500:	80 00       	ld.sh	r0,r0[0x0]
80002502:	c5 f0       	breq	800025c0 <TransmitControl_reply_func+0x2c>
80002504:	80 00       	ld.sh	r0,r0[0x0]
80002506:	c5 fc       	rcall	800025c4 <TransmitControl_reply_func+0x30>

80002508 <CallControl_brdcst_func>:
	
}


void CallControl_brdcst_func(xcmp_fragment_t * xcmp)
{
80002508:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	CallControl_brdcst_t *ptr = (CallControl_brdcst_t* )xcmp->u8;
8000250c:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  CallControl brst \n\r ");
	//log("\n\r  Call_type: %x \n\r ", ptr->Calltype );
	log("\n\r  Call_state: %x \n\r ", ptr->Callstate );
80002510:	0f 98       	ld.ub	r8,r7[0x1]
80002512:	1a d8       	st.w	--sp,r8
80002514:	48 bc       	lddpc	r12,80002540 <CallControl_brdcst_func+0x38>
80002516:	f0 1f 00 0c 	mcall	80002544 <CallControl_brdcst_func+0x3c>
	if (ptr->Callstate == Call_Ended)//0x03
8000251a:	2f fd       	sub	sp,-4
8000251c:	0f 99       	ld.ub	r9,r7[0x1]
8000251e:	30 38       	mov	r8,3
80002520:	f0 09 18 00 	cp.b	r9,r8
80002524:	c0 41       	brne	8000252c <CallControl_brdcst_func+0x24>
	{
		//恢复正常语音路径通道
		//xcmp_audio_route_revert();
		Call_Begin = 0;
80002526:	30 09       	mov	r9,0
80002528:	48 88       	lddpc	r8,80002548 <CallControl_brdcst_func+0x40>
8000252a:	b0 89       	st.b	r8[0x0],r9
		
	}
	
	if (ptr->Callstate == Call_Initiated)//0x04
8000252c:	0f 99       	ld.ub	r9,r7[0x1]
8000252e:	30 48       	mov	r8,4
80002530:	f0 09 18 00 	cp.b	r9,r8
80002534:	c0 41       	brne	8000253c <CallControl_brdcst_func+0x34>
	{
		Call_Begin = 1;
80002536:	30 19       	mov	r9,1
80002538:	48 48       	lddpc	r8,80002548 <CallControl_brdcst_func+0x40>
8000253a:	b0 89       	st.b	r8[0x0],r9
8000253c:	e3 cd 80 80 	ldm	sp++,r7,pc
80002540:	80 00       	ld.sh	r0,r0[0x0]
80002542:	c6 08       	rjmp	80002602 <AudioRoutingControl_reply_func+0xe>
80002544:	80 00       	ld.sh	r0,r0[0x0]
80002546:	61 68       	ld.w	r8,r0[0x58]
80002548:	00 00       	add	r0,r0
8000254a:	0a 55       	eor	r5,r5

8000254c <TransmitControl_brdcst_func>:

}


void TransmitControl_brdcst_func(xcmp_fragment_t * xcmp)
{
8000254c:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	TransmitControl_brdcast_t *ptr = (TransmitControl_brdcast_t* )xcmp->u8;
80002550:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  TransmitControl broadcast \n\r ");
	//log("\n\r  Mode_Of_Operation: %x \n\r ", ptr->Mode_Of_Operation );
	if (ptr->State == 0x00)
80002554:	0f 99       	ld.ub	r9,r7[0x1]
80002556:	30 08       	mov	r8,0
80002558:	f0 09 18 00 	cp.b	r9,r8
8000255c:	c0 71       	brne	8000256a <TransmitControl_brdcst_func+0x1e>
	{
		log("\n\r  Standby-Receive \n\r ");
8000255e:	48 ac       	lddpc	r12,80002584 <TransmitControl_brdcst_func+0x38>
80002560:	f0 1f 00 0a 	mcall	80002588 <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 0;
80002564:	30 09       	mov	r9,0
80002566:	48 a8       	lddpc	r8,8000258c <TransmitControl_brdcst_func+0x40>
80002568:	b0 89       	st.b	r8[0x0],r9
	}
	if (ptr->State == 0x01)
8000256a:	0f 99       	ld.ub	r9,r7[0x1]
8000256c:	30 18       	mov	r8,1
8000256e:	f0 09 18 00 	cp.b	r9,r8
80002572:	c0 71       	brne	80002580 <TransmitControl_brdcst_func+0x34>
	{
		log("\n\r  Transmit \n\r ");
80002574:	48 7c       	lddpc	r12,80002590 <TransmitControl_brdcst_func+0x44>
80002576:	f0 1f 00 05 	mcall	80002588 <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 1;
8000257a:	30 19       	mov	r9,1
8000257c:	48 48       	lddpc	r8,8000258c <TransmitControl_brdcst_func+0x40>
8000257e:	b0 89       	st.b	r8[0x0],r9
80002580:	e3 cd 80 80 	ldm	sp++,r7,pc
80002584:	80 00       	ld.sh	r0,r0[0x0]
80002586:	c6 20       	breq	8000264a <Volume_reply_func+0x26>
80002588:	80 00       	ld.sh	r0,r0[0x0]
8000258a:	61 68       	ld.w	r8,r0[0x58]
8000258c:	00 00       	add	r0,r0
8000258e:	0a 54       	eor	r4,r5
80002590:	80 00       	ld.sh	r0,r0[0x0]
80002592:	c6 38       	rjmp	80002658 <Volume_reply_func+0x34>

80002594 <TransmitControl_reply_func>:




void TransmitControl_reply_func(xcmp_fragment_t * xcmp)
{
80002594:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	TransmitControl_reply_t *ptr = (TransmitControl_reply_t* )xcmp->u8;
80002598:	f8 c7 ff fe 	sub	r7,r12,-2
	
	if (ptr->Result == xcmp_Res_Success)
8000259c:	0f 89       	ld.ub	r9,r7[0x0]
8000259e:	30 08       	mov	r8,0
800025a0:	f0 09 18 00 	cp.b	r9,r8
800025a4:	c1 61       	brne	800025d0 <TransmitControl_reply_func+0x3c>
	{
		
		log("\n\r  TransmitControl OK \n\r ");
800025a6:	48 ec       	lddpc	r12,800025dc <TransmitControl_reply_func+0x48>
800025a8:	f0 1f 00 0e 	mcall	800025e0 <TransmitControl_reply_func+0x4c>
		log("\n\r Function: %x \n\r", ptr->Function);
800025ac:	0f 98       	ld.ub	r8,r7[0x1]
800025ae:	1a d8       	st.w	--sp,r8
800025b0:	48 dc       	lddpc	r12,800025e4 <TransmitControl_reply_func+0x50>
800025b2:	f0 1f 00 0c 	mcall	800025e0 <TransmitControl_reply_func+0x4c>
		log("\n\r Mode of Operation: %x \n\r", ptr->Mode_Of_Operation);
800025b6:	0f a8       	ld.ub	r8,r7[0x2]
800025b8:	1a d8       	st.w	--sp,r8
800025ba:	48 cc       	lddpc	r12,800025e8 <TransmitControl_reply_func+0x54>
800025bc:	f0 1f 00 09 	mcall	800025e0 <TransmitControl_reply_func+0x4c>
		log("\n\r State: %x \n\r", ptr->State);
800025c0:	0f b8       	ld.ub	r8,r7[0x3]
800025c2:	1a d8       	st.w	--sp,r8
800025c4:	48 ac       	lddpc	r12,800025ec <TransmitControl_reply_func+0x58>
800025c6:	f0 1f 00 07 	mcall	800025e0 <TransmitControl_reply_func+0x4c>
800025ca:	2f dd       	sub	sp,-12
800025cc:	e3 cd 80 80 	ldm	sp++,r7,pc
		
		//Silent_flag = 1;
	}
	else
	{
		log("TransmitControl error");
800025d0:	48 8c       	lddpc	r12,800025f0 <TransmitControl_reply_func+0x5c>
800025d2:	f0 1f 00 04 	mcall	800025e0 <TransmitControl_reply_func+0x4c>
800025d6:	e3 cd 80 80 	ldm	sp++,r7,pc
800025da:	00 00       	add	r0,r0
800025dc:	80 00       	ld.sh	r0,r0[0x0]
800025de:	c6 4c       	rcall	800026a6 <spk_brdcst_func+0x1e>
800025e0:	80 00       	ld.sh	r0,r0[0x0]
800025e2:	61 68       	ld.w	r8,r0[0x58]
800025e4:	80 00       	ld.sh	r0,r0[0x0]
800025e6:	c6 68       	rjmp	800026b2 <spk_brdcst_func+0x2a>
800025e8:	80 00       	ld.sh	r0,r0[0x0]
800025ea:	c6 7c       	rcall	800026b8 <spk_brdcst_func+0x30>
800025ec:	80 00       	ld.sh	r0,r0[0x0]
800025ee:	c6 98       	rjmp	800026c0 <spk_reply_func>
800025f0:	80 00       	ld.sh	r0,r0[0x0]
800025f2:	c6 a8       	rjmp	800026c6 <spk_reply_func+0x6>

800025f4 <AudioRoutingControl_reply_func>:
	
}


void AudioRoutingControl_reply_func(xcmp_fragment_t * xcmp)
{
800025f4:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
800025f6:	19 a9       	ld.ub	r9,r12[0x2]
800025f8:	30 08       	mov	r8,0
800025fa:	f0 09 18 00 	cp.b	r9,r8
800025fe:	c0 71       	brne	8000260c <AudioRoutingControl_reply_func+0x18>
	{
		log("AudioRouting OK");
80002600:	48 5c       	lddpc	r12,80002614 <AudioRoutingControl_reply_func+0x20>
80002602:	f0 1f 00 06 	mcall	80002618 <AudioRoutingControl_reply_func+0x24>
		xcmp_IdleTestTone();//提示通道配置成功
80002606:	f0 1f 00 06 	mcall	8000261c <AudioRoutingControl_reply_func+0x28>
8000260a:	d8 02       	popm	pc
		//xcmp_IdleTestTone();
		//Speaker_is_unmute = 1;
	}
	else
	{
		log("AudioRouting error");
8000260c:	48 5c       	lddpc	r12,80002620 <AudioRoutingControl_reply_func+0x2c>
8000260e:	f0 1f 00 03 	mcall	80002618 <AudioRoutingControl_reply_func+0x24>
80002612:	d8 02       	popm	pc
80002614:	80 00       	ld.sh	r0,r0[0x0]
80002616:	c6 c0       	breq	800026ee <spk_reply_func+0x2e>
80002618:	80 00       	ld.sh	r0,r0[0x0]
8000261a:	61 68       	ld.w	r8,r0[0x58]
8000261c:	80 00       	ld.sh	r0,r0[0x0]
8000261e:	42 ac       	lddsp	r12,sp[0xa8]
80002620:	80 00       	ld.sh	r0,r0[0x0]
80002622:	c6 d0       	breq	800026fc <spk_reply_func+0x3c>

80002624 <Volume_reply_func>:
	
}


void Volume_reply_func(xcmp_fragment_t * xcmp)
{
80002624:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	VolumeControl_reply_t *ptr = (VolumeControl_reply_t* )xcmp->u8;
80002628:	f8 c7 ff fe 	sub	r7,r12,-2
	
		if (ptr->Result == xcmp_Res_Success)
8000262c:	0f 89       	ld.ub	r9,r7[0x0]
8000262e:	30 08       	mov	r8,0
80002630:	f0 09 18 00 	cp.b	r9,r8
80002634:	c1 b1       	brne	8000266a <Volume_reply_func+0x46>
		{
			if (ptr->Function == Enable_IntelligentAudio)
80002636:	0f b8       	ld.ub	r8,r7[0x3]
80002638:	31 09       	mov	r9,16
8000263a:	f2 08 18 00 	cp.b	r8,r9
8000263e:	c0 f1       	brne	8000265c <Volume_reply_func+0x38>
			{
				log("\n\r Enable_IA OK \n\r");
80002640:	48 dc       	lddpc	r12,80002674 <Volume_reply_func+0x50>
80002642:	f0 1f 00 0e 	mcall	80002678 <Volume_reply_func+0x54>
				log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
80002646:	0f 99       	ld.ub	r9,r7[0x1]
80002648:	0f a8       	ld.ub	r8,r7[0x2]
8000264a:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000264e:	1a d8       	st.w	--sp,r8
80002650:	48 bc       	lddpc	r12,8000267c <Volume_reply_func+0x58>
80002652:	f0 1f 00 0a 	mcall	80002678 <Volume_reply_func+0x54>
80002656:	2f fd       	sub	sp,-4
80002658:	e3 cd 80 80 	ldm	sp++,r7,pc
	
			}
			else
			{
				
				log("\n\r VolumeControl: %x \n\r", ptr->Function);
8000265c:	1a d8       	st.w	--sp,r8
8000265e:	48 9c       	lddpc	r12,80002680 <Volume_reply_func+0x5c>
80002660:	f0 1f 00 06 	mcall	80002678 <Volume_reply_func+0x54>
80002664:	2f fd       	sub	sp,-4
80002666:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		
		else
		{
			log("\n\r Enable_IA error \n\r");
8000266a:	48 7c       	lddpc	r12,80002684 <Volume_reply_func+0x60>
8000266c:	f0 1f 00 03 	mcall	80002678 <Volume_reply_func+0x54>
80002670:	e3 cd 80 80 	ldm	sp++,r7,pc
80002674:	80 00       	ld.sh	r0,r0[0x0]
80002676:	c6 e4       	brge	80002752 <mic_brdcst_func+0x4a>
80002678:	80 00       	ld.sh	r0,r0[0x0]
8000267a:	61 68       	ld.w	r8,r0[0x58]
8000267c:	80 00       	ld.sh	r0,r0[0x0]
8000267e:	c6 f8       	rjmp	8000275c <mic_brdcst_func+0x54>
80002680:	80 00       	ld.sh	r0,r0[0x0]
80002682:	c7 14       	brge	80002764 <mic_reply_func+0x4>
80002684:	80 00       	ld.sh	r0,r0[0x0]
80002686:	c7 2c       	rcall	8000276a <mic_reply_func+0xa>

80002688 <spk_brdcst_func>:
		log("spk error");
	}
}

void spk_brdcst_func(xcmp_fragment_t * xcmp)
{
80002688:	d4 01       	pushm	lr
	if (xcmp->u8[3] == xcmp_Res_Success)//0x0000:mute
8000268a:	19 d9       	ld.ub	r9,r12[0x5]
8000268c:	30 08       	mov	r8,0
8000268e:	f0 09 18 00 	cp.b	r9,r8
80002692:	c0 81       	brne	800026a2 <spk_brdcst_func+0x1a>
	{
		Speaker_is_unmute =0;
80002694:	10 99       	mov	r9,r8
80002696:	48 78       	lddpc	r8,800026b0 <spk_brdcst_func+0x28>
80002698:	b0 89       	st.b	r8[0x0],r9
		//Silent_flag = 0;
		log("spk_s_close ");
8000269a:	48 7c       	lddpc	r12,800026b4 <spk_brdcst_func+0x2c>
8000269c:	f0 1f 00 07 	mcall	800026b8 <spk_brdcst_func+0x30>
800026a0:	d8 02       	popm	pc
		
	}
	else
	{
		//Silent_flag = 1;
		Speaker_is_unmute = 1;
800026a2:	30 19       	mov	r9,1
800026a4:	48 38       	lddpc	r8,800026b0 <spk_brdcst_func+0x28>
800026a6:	b0 89       	st.b	r8[0x0],r9
		log("spk_s_open ");	
800026a8:	48 5c       	lddpc	r12,800026bc <spk_brdcst_func+0x34>
800026aa:	f0 1f 00 04 	mcall	800026b8 <spk_brdcst_func+0x30>
800026ae:	d8 02       	popm	pc
800026b0:	00 00       	add	r0,r0
800026b2:	0a 48       	or	r8,r5
800026b4:	80 00       	ld.sh	r0,r0[0x0]
800026b6:	c7 44       	brge	8000279e <mic_reply_func+0x3e>
800026b8:	80 00       	ld.sh	r0,r0[0x0]
800026ba:	61 68       	ld.w	r8,r0[0x58]
800026bc:	80 00       	ld.sh	r0,r0[0x0]
800026be:	c7 54       	brge	800027a8 <mic_reply_func+0x48>

800026c0 <spk_reply_func>:
			
	
}

void spk_reply_func(xcmp_fragment_t * xcmp)
{
800026c0:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
800026c2:	19 a9       	ld.ub	r9,r12[0x2]
800026c4:	30 08       	mov	r8,0
800026c6:	f0 09 18 00 	cp.b	r9,r8
800026ca:	c0 f1       	brne	800026e8 <spk_reply_func+0x28>
	{
		
		if(xcmp->u8[4])
800026cc:	19 e9       	ld.ub	r9,r12[0x6]
800026ce:	f0 09 18 00 	cp.b	r9,r8
800026d2:	c0 40       	breq	800026da <spk_reply_func+0x1a>
		{
			Speaker_is_unmute = 1;
800026d4:	30 19       	mov	r9,1
800026d6:	48 98       	lddpc	r8,800026f8 <spk_reply_func+0x38>
800026d8:	b0 89       	st.b	r8[0x0],r9
			
			//Silent_flag = 1;
		}
		log("spk OK -st%2x", xcmp->u8[4] );
800026da:	19 e8       	ld.ub	r8,r12[0x6]
800026dc:	1a d8       	st.w	--sp,r8
800026de:	48 8c       	lddpc	r12,800026fc <spk_reply_func+0x3c>
800026e0:	f0 1f 00 08 	mcall	80002700 <spk_reply_func+0x40>
800026e4:	2f fd       	sub	sp,-4
800026e6:	d8 02       	popm	pc
		
	}
	else
	{
		Speaker_is_unmute = 0;
800026e8:	30 09       	mov	r9,0
800026ea:	48 48       	lddpc	r8,800026f8 <spk_reply_func+0x38>
800026ec:	b0 89       	st.b	r8[0x0],r9
		log("spk error");
800026ee:	48 6c       	lddpc	r12,80002704 <spk_reply_func+0x44>
800026f0:	f0 1f 00 04 	mcall	80002700 <spk_reply_func+0x40>
800026f4:	d8 02       	popm	pc
800026f6:	00 00       	add	r0,r0
800026f8:	00 00       	add	r0,r0
800026fa:	0a 48       	or	r8,r5
800026fc:	80 00       	ld.sh	r0,r0[0x0]
800026fe:	c7 60       	breq	800027ea <mic_reply_func+0x8a>
80002700:	80 00       	ld.sh	r0,r0[0x0]
80002702:	61 68       	ld.w	r8,r0[0x58]
80002704:	80 00       	ld.sh	r0,r0[0x0]
80002706:	c7 70       	breq	800027f4 <dcm_brdcst_func>

80002708 <mic_brdcst_func>:
	
	
}

void mic_brdcst_func(xcmp_fragment_t * xcmp)
{
80002708:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_brdcast_t *ptr = (MicControl_brdcast_t* )xcmp->u8;
8000270c:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r Mic_brdcst \n\r");		
	//log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
	//log("\n\r Signal_type: %x \n\r " ,  ptr->Signaling_Type);
	if (ptr->Mic_State == 0x00)
80002710:	0f a9       	ld.ub	r9,r7[0x2]
80002712:	30 08       	mov	r8,0
80002714:	f0 09 18 00 	cp.b	r9,r8
80002718:	c0 71       	brne	80002726 <mic_brdcst_func+0x1e>
	{
		log("\n\r Mic_Disabled \n\r");	
8000271a:	48 dc       	lddpc	r12,8000274c <mic_brdcst_func+0x44>
8000271c:	f0 1f 00 0d 	mcall	80002750 <mic_brdcst_func+0x48>
		Mic_is_Enabled = 0;
80002720:	30 09       	mov	r9,0
80002722:	48 d8       	lddpc	r8,80002754 <mic_brdcst_func+0x4c>
80002724:	b0 89       	st.b	r8[0x0],r9
	} 
	if(ptr->Mic_State == 0x11)
80002726:	0f a9       	ld.ub	r9,r7[0x2]
80002728:	31 18       	mov	r8,17
8000272a:	f0 09 18 00 	cp.b	r9,r8
8000272e:	c0 d1       	brne	80002748 <mic_brdcst_func+0x40>
	{
		log("\n\r Mic_Enabled \n\r");
80002730:	48 ac       	lddpc	r12,80002758 <mic_brdcst_func+0x50>
80002732:	f0 1f 00 08 	mcall	80002750 <mic_brdcst_func+0x48>
		Mic_is_Enabled = 1;
80002736:	48 89       	lddpc	r9,80002754 <mic_brdcst_func+0x4c>
80002738:	30 18       	mov	r8,1
8000273a:	b2 88       	st.b	r9[0x0],r8
		
		if ((Mic_is_Enabled == 1) && (Call_Begin == 1))
8000273c:	13 89       	ld.ub	r9,r9[0x0]
8000273e:	f0 09 18 00 	cp.b	r9,r8
80002742:	c0 31       	brne	80002748 <mic_brdcst_func+0x40>
80002744:	48 68       	lddpc	r8,8000275c <mic_brdcst_func+0x54>
80002746:	11 88       	ld.ub	r8,r8[0x0]
80002748:	e3 cd 80 80 	ldm	sp++,r7,pc
8000274c:	80 00       	ld.sh	r0,r0[0x0]
8000274e:	c7 7c       	rcall	8000283c <dcm_reply_func>
80002750:	80 00       	ld.sh	r0,r0[0x0]
80002752:	61 68       	ld.w	r8,r0[0x58]
80002754:	00 00       	add	r0,r0
80002756:	0a 5e       	eor	lr,r5
80002758:	80 00       	ld.sh	r0,r0[0x0]
8000275a:	c7 90       	breq	8000284c <dcm_reply_func+0x10>
8000275c:	00 00       	add	r0,r0
8000275e:	0a 55       	eor	r5,r5

80002760 <mic_reply_func>:
	
	
}

void mic_reply_func(xcmp_fragment_t * xcmp)
{
80002760:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_reply_t *ptr = (MicControl_reply_t* )xcmp->u8;
80002764:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Mic_reply \n\r");
80002768:	49 ac       	lddpc	r12,800027d0 <mic_reply_func+0x70>
8000276a:	f0 1f 00 1b 	mcall	800027d4 <mic_reply_func+0x74>
	if (ptr->Result == 0x00)
8000276e:	0f 89       	ld.ub	r9,r7[0x0]
80002770:	30 08       	mov	r8,0
80002772:	f0 09 18 00 	cp.b	r9,r8
80002776:	c2 71       	brne	800027c4 <mic_reply_func+0x64>
	{
		
		if (ptr->Function == Mic_Disable)
80002778:	0f 98       	ld.ub	r8,r7[0x1]
8000277a:	30 29       	mov	r9,2
8000277c:	f2 08 18 00 	cp.b	r8,r9
80002780:	c1 b1       	brne	800027b6 <mic_reply_func+0x56>
		{
		
			log("\n\r Mic_close_ok \n\r " );
80002782:	49 6c       	lddpc	r12,800027d8 <mic_reply_func+0x78>
80002784:	f0 1f 00 14 	mcall	800027d4 <mic_reply_func+0x74>
			log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
80002788:	0f a8       	ld.ub	r8,r7[0x2]
8000278a:	1a d8       	st.w	--sp,r8
8000278c:	49 4c       	lddpc	r12,800027dc <mic_reply_func+0x7c>
8000278e:	f0 1f 00 12 	mcall	800027d4 <mic_reply_func+0x74>
			log("\n\r Signaling_type: %x \n\r " ,  ptr->Signaling_Type);
80002792:	0f b8       	ld.ub	r8,r7[0x3]
80002794:	1a d8       	st.w	--sp,r8
80002796:	49 3c       	lddpc	r12,800027e0 <mic_reply_func+0x80>
80002798:	f0 1f 00 0f 	mcall	800027d4 <mic_reply_func+0x74>
			log("\n\r Mic_state: %x \n\r " ,  ptr->Mic_State);
8000279c:	0f c8       	ld.ub	r8,r7[0x4]
8000279e:	1a d8       	st.w	--sp,r8
800027a0:	49 1c       	lddpc	r12,800027e4 <mic_reply_func+0x84>
800027a2:	f0 1f 00 0d 	mcall	800027d4 <mic_reply_func+0x74>
			log("\n\r Gain_offset: %x \n\r " ,  ptr->Gain_Offset);
800027a6:	0f d8       	ld.ub	r8,r7[0x5]
800027a8:	1a d8       	st.w	--sp,r8
800027aa:	49 0c       	lddpc	r12,800027e8 <mic_reply_func+0x88>
800027ac:	f0 1f 00 0a 	mcall	800027d4 <mic_reply_func+0x74>
800027b0:	2f cd       	sub	sp,-16
800027b2:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else
		{
			log("\n\r Mic_function: %x \n\r ", ptr->Function );
800027b6:	1a d8       	st.w	--sp,r8
800027b8:	48 dc       	lddpc	r12,800027ec <mic_reply_func+0x8c>
800027ba:	f0 1f 00 07 	mcall	800027d4 <mic_reply_func+0x74>
800027be:	2f fd       	sub	sp,-4
800027c0:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else 
	{
		
	
		log("\n\r Mic error \n\r");
800027c4:	48 bc       	lddpc	r12,800027f0 <mic_reply_func+0x90>
800027c6:	f0 1f 00 04 	mcall	800027d4 <mic_reply_func+0x74>
800027ca:	e3 cd 80 80 	ldm	sp++,r7,pc
800027ce:	00 00       	add	r0,r0
800027d0:	80 00       	ld.sh	r0,r0[0x0]
800027d2:	c7 a4       	brge	800028c6 <ToneControl_reply_func+0x22>
800027d4:	80 00       	ld.sh	r0,r0[0x0]
800027d6:	61 68       	ld.w	r8,r0[0x58]
800027d8:	80 00       	ld.sh	r0,r0[0x0]
800027da:	c7 b4       	brge	800028d0 <app_payload_rx_proc+0x4>
800027dc:	80 00       	ld.sh	r0,r0[0x0]
800027de:	c7 c8       	rjmp	800028d6 <app_payload_rx_proc+0xa>
800027e0:	80 00       	ld.sh	r0,r0[0x0]
800027e2:	c7 dc       	rcall	800028dc <app_payload_rx_proc+0x10>
800027e4:	80 00       	ld.sh	r0,r0[0x0]
800027e6:	c7 f8       	rjmp	800028e4 <app_payload_rx_proc+0x18>
800027e8:	80 00       	ld.sh	r0,r0[0x0]
800027ea:	c8 10       	breq	800026ec <spk_reply_func+0x2c>
800027ec:	80 00       	ld.sh	r0,r0[0x0]
800027ee:	c8 28       	rjmp	800028f2 <app_payload_rx_proc+0x26>
800027f0:	80 00       	ld.sh	r0,r0[0x0]
800027f2:	c8 40       	breq	800026fa <spk_reply_func+0x3a>

800027f4 <dcm_brdcst_func>:
	}
}


void dcm_brdcst_func(xcmp_fragment_t * xcmp)
{
800027f4:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	DeviceControlMode_brdcst_t *ptr = (DeviceControlMode_brdcst_t* )xcmp->u8;
800027f8:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Dcm_brdcst \n\r");		
800027fc:	48 bc       	lddpc	r12,80002828 <dcm_brdcst_func+0x34>
800027fe:	f0 1f 00 0c 	mcall	8000282c <dcm_brdcst_func+0x38>
	log("\n\r Function: %x \n\r " ,  ptr->Function);
80002802:	0f 88       	ld.ub	r8,r7[0x0]
80002804:	1a d8       	st.w	--sp,r8
80002806:	48 bc       	lddpc	r12,80002830 <dcm_brdcst_func+0x3c>
80002808:	f0 1f 00 09 	mcall	8000282c <dcm_brdcst_func+0x38>
	log("\n\r ControlType: %x \n\r " ,  ptr->ControlType);
8000280c:	0f a8       	ld.ub	r8,r7[0x2]
8000280e:	1a d8       	st.w	--sp,r8
80002810:	48 9c       	lddpc	r12,80002834 <dcm_brdcst_func+0x40>
80002812:	f0 1f 00 07 	mcall	8000282c <dcm_brdcst_func+0x38>
	log("\n\r ControlTypeSize: %x \n\r " ,  ptr->ControlTypeSize);
80002816:	0f 98       	ld.ub	r8,r7[0x1]
80002818:	1a d8       	st.w	--sp,r8
8000281a:	48 8c       	lddpc	r12,80002838 <dcm_brdcst_func+0x44>
8000281c:	f0 1f 00 04 	mcall	8000282c <dcm_brdcst_func+0x38>
80002820:	2f dd       	sub	sp,-12
	
	
}
80002822:	e3 cd 80 80 	ldm	sp++,r7,pc
80002826:	00 00       	add	r0,r0
80002828:	80 00       	ld.sh	r0,r0[0x0]
8000282a:	c8 50       	breq	80002734 <mic_brdcst_func+0x2c>
8000282c:	80 00       	ld.sh	r0,r0[0x0]
8000282e:	61 68       	ld.w	r8,r0[0x58]
80002830:	80 00       	ld.sh	r0,r0[0x0]
80002832:	c8 64       	brge	8000273e <mic_brdcst_func+0x36>
80002834:	80 00       	ld.sh	r0,r0[0x0]
80002836:	c8 78       	rjmp	80002944 <DeviceInitializationStatus_brdcst_func+0x2c>
80002838:	80 00       	ld.sh	r0,r0[0x0]
8000283a:	c8 90       	breq	8000274c <mic_brdcst_func+0x44>

8000283c <dcm_reply_func>:
		log("Tone error");
	}
}

void dcm_reply_func(xcmp_fragment_t * xcmp)
{
8000283c:	eb cd 40 80 	pushm	r7,lr
80002840:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
80002842:	19 a9       	ld.ub	r9,r12[0x2]
80002844:	30 08       	mov	r8,0
80002846:	f0 09 18 00 	cp.b	r9,r8
8000284a:	c1 b1       	brne	80002880 <dcm_reply_func+0x44>
	{
		if(xcmp->u8[1] == DCM_ENTER)
8000284c:	19 b8       	ld.ub	r8,r12[0x3]
8000284e:	30 19       	mov	r9,1
80002850:	f2 08 18 00 	cp.b	r8,r9
80002854:	c0 51       	brne	8000285e <dcm_reply_func+0x22>
		{
			log("\n\r Dcm-Enter OK \n\r");
80002856:	48 ec       	lddpc	r12,8000288c <dcm_reply_func+0x50>
80002858:	f0 1f 00 0e 	mcall	80002890 <dcm_reply_func+0x54>
8000285c:	c0 a8       	rjmp	80002870 <dcm_reply_func+0x34>
			
		}
		else if (xcmp->u8[1] == DCM_EXIT)
8000285e:	58 08       	cp.w	r8,0
80002860:	c0 51       	brne	8000286a <dcm_reply_func+0x2e>
		{
			log("\n\r Dcm-Exit OK \n\r");
80002862:	48 dc       	lddpc	r12,80002894 <dcm_reply_func+0x58>
80002864:	f0 1f 00 0b 	mcall	80002890 <dcm_reply_func+0x54>
80002868:	c0 48       	rjmp	80002870 <dcm_reply_func+0x34>
		}
		else
		{
			log("\n\r Dcm-Revoke \n\r");
8000286a:	48 cc       	lddpc	r12,80002898 <dcm_reply_func+0x5c>
8000286c:	f0 1f 00 09 	mcall	80002890 <dcm_reply_func+0x54>
		}
		
		log("dcm OK-mo%X", xcmp->u8[3]);
80002870:	0f d8       	ld.ub	r8,r7[0x5]
80002872:	1a d8       	st.w	--sp,r8
80002874:	48 ac       	lddpc	r12,8000289c <dcm_reply_func+0x60>
80002876:	f0 1f 00 07 	mcall	80002890 <dcm_reply_func+0x54>
8000287a:	2f fd       	sub	sp,-4
8000287c:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		log("dcm error");
80002880:	48 8c       	lddpc	r12,800028a0 <dcm_reply_func+0x64>
80002882:	f0 1f 00 04 	mcall	80002890 <dcm_reply_func+0x54>
80002886:	e3 cd 80 80 	ldm	sp++,r7,pc
8000288a:	00 00       	add	r0,r0
8000288c:	80 00       	ld.sh	r0,r0[0x0]
8000288e:	c8 ac       	rcall	800029a2 <payload_init+0x36>
80002890:	80 00       	ld.sh	r0,r0[0x0]
80002892:	61 68       	ld.w	r8,r0[0x58]
80002894:	80 00       	ld.sh	r0,r0[0x0]
80002896:	c8 c0       	breq	800027ae <mic_reply_func+0x4e>
80002898:	80 00       	ld.sh	r0,r0[0x0]
8000289a:	c8 d4       	brge	800027b4 <mic_reply_func+0x54>
8000289c:	80 00       	ld.sh	r0,r0[0x0]
8000289e:	c8 e8       	rjmp	800029ba <payload_rx_process+0x16>
800028a0:	80 00       	ld.sh	r0,r0[0x0]
800028a2:	c8 f4       	brge	800027c0 <mic_reply_func+0x60>

800028a4 <ToneControl_reply_func>:
			}
		}
}

void ToneControl_reply_func(xcmp_fragment_t * xcmp)
{
800028a4:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
800028a6:	19 a9       	ld.ub	r9,r12[0x2]
800028a8:	30 08       	mov	r8,0
800028aa:	f0 09 18 00 	cp.b	r9,r8
800028ae:	c0 51       	brne	800028b8 <ToneControl_reply_func+0x14>
	{		
		log("Tone OK\n");
800028b0:	48 4c       	lddpc	r12,800028c0 <ToneControl_reply_func+0x1c>
800028b2:	f0 1f 00 05 	mcall	800028c4 <ToneControl_reply_func+0x20>
800028b6:	d8 02       	popm	pc
		//fl_write("/test.txt", FILE_END, (void *)"send tone ok\r\n", sizeof("send tone ok\r\n") - 1);
	}
	else
	{
		log("Tone error");
800028b8:	48 4c       	lddpc	r12,800028c8 <ToneControl_reply_func+0x24>
800028ba:	f0 1f 00 03 	mcall	800028c4 <ToneControl_reply_func+0x20>
800028be:	d8 02       	popm	pc
800028c0:	80 00       	ld.sh	r0,r0[0x0]
800028c2:	c9 00       	breq	800027e2 <mic_reply_func+0x82>
800028c4:	80 00       	ld.sh	r0,r0[0x0]
800028c6:	61 68       	ld.w	r8,r0[0x58]
800028c8:	80 00       	ld.sh	r0,r0[0x0]
800028ca:	c9 0c       	rcall	800029ea <payload_rx_process+0x46>

800028cc <app_payload_rx_proc>:
	}
}


static void app_payload_rx_proc(void  * payload)
{
800028cc:	eb cd 40 80 	pushm	r7,lr
800028d0:	18 97       	mov	r7,r12
	static  U8 times_counter = 0;
	
	times_counter++;
800028d2:	48 c9       	lddpc	r9,80002900 <app_payload_rx_proc+0x34>
800028d4:	13 88       	ld.ub	r8,r9[0x0]
800028d6:	2f f8       	sub	r8,-1
800028d8:	b2 88       	st.b	r9[0x0],r8
	if (times_counter == 3)
800028da:	30 39       	mov	r9,3
800028dc:	f2 08 18 00 	cp.b	r8,r9
800028e0:	c0 71       	brne	800028ee <app_payload_rx_proc+0x22>
	{
		times_counter = 0 ;
800028e2:	30 09       	mov	r9,0
800028e4:	48 78       	lddpc	r8,80002900 <app_payload_rx_proc+0x34>
800028e6:	b0 89       	st.b	r8[0x0],r9
		log("\n\r w: \n\r");
800028e8:	48 7c       	lddpc	r12,80002904 <app_payload_rx_proc+0x38>
800028ea:	f0 1f 00 08 	mcall	80002908 <app_payload_rx_proc+0x3c>
	}
	//log("\n\r w: \n\r");
	if (AMBE_tx_flag)//本地发送方的mic录音
800028ee:	48 88       	lddpc	r8,8000290c <app_payload_rx_proc+0x40>
800028f0:	11 88       	ld.ub	r8,r8[0x0]
	{
		//fl_write("PCMvo.pcm", FILE_END, payload, MAX_PAYLOAD_BUFF_SIZE * 2);
	}
	
	//payload_fragment_t * ptr = (payload_fragment_t *)payload;
	set_payload_idle(payload);
800028f2:	48 88       	lddpc	r8,80002910 <app_payload_rx_proc+0x44>
800028f4:	70 0c       	ld.w	r12,r8[0x0]
800028f6:	0e 9b       	mov	r11,r7
800028f8:	f0 1f 00 07 	mcall	80002914 <app_payload_rx_proc+0x48>

}
800028fc:	e3 cd 80 80 	ldm	sp++,r7,pc
80002900:	00 00       	add	r0,r0
80002902:	0a 5f       	eor	pc,r5
80002904:	80 00       	ld.sh	r0,r0[0x0]
80002906:	c9 18       	rjmp	80002a28 <phy_rx+0x1c>
80002908:	80 00       	ld.sh	r0,r0[0x0]
8000290a:	61 68       	ld.w	r8,r0[0x58]
8000290c:	00 00       	add	r0,r0
8000290e:	0a 61       	and	r1,r5
80002910:	00 00       	add	r0,r0
80002912:	0a b0       	st.h	r5++,r0
80002914:	80 00       	ld.sh	r0,r0[0x0]
80002916:	2a 44       	sub	r4,-92

80002918 <DeviceInitializationStatus_brdcst_func>:
static void app_payload_tx_proc(void  * payload);

//app func--list

void DeviceInitializationStatus_brdcst_func(xcmp_fragment_t  * xcmp)
{
80002918:	d4 01       	pushm	lr
	if (xcmp->u8[4] == 0x01)
8000291a:	19 e8       	ld.ub	r8,r12[0x6]
8000291c:	30 19       	mov	r9,1
8000291e:	f2 08 18 00 	cp.b	r8,r9
80002922:	c0 61       	brne	8000292e <DeviceInitializationStatus_brdcst_func+0x16>
	{
		bunchofrandomstatusflags |= 0x01;  //Need do nothing else.
80002924:	48 98       	lddpc	r8,80002948 <DeviceInitializationStatus_brdcst_func+0x30>
80002926:	70 09       	ld.w	r9,r8[0x0]
80002928:	a1 a9       	sbr	r9,0x0
8000292a:	91 09       	st.w	r8[0x0],r9
8000292c:	d8 02       	popm	pc
	}
	else if(xcmp->u8[4] != 0x02)
8000292e:	30 29       	mov	r9,2
80002930:	f2 08 18 00 	cp.b	r8,r9
80002934:	c0 80       	breq	80002944 <DeviceInitializationStatus_brdcst_func+0x2c>
	{
		bunchofrandomstatusflags  &= 0xFFFFFFFC; //Device Init no longer Complete.
80002936:	48 58       	lddpc	r8,80002948 <DeviceInitializationStatus_brdcst_func+0x30>
80002938:	70 09       	ld.w	r9,r8[0x0]
8000293a:	e0 19 ff fc 	andl	r9,0xfffc
8000293e:	91 09       	st.w	r8[0x0],r9
		xcmp_DeviceInitializationStatus_request();
80002940:	f0 1f 00 03 	mcall	8000294c <DeviceInitializationStatus_brdcst_func+0x34>
80002944:	d8 02       	popm	pc
80002946:	00 00       	add	r0,r0
80002948:	00 00       	add	r0,r0
8000294a:	0d 8c       	ld.ub	r12,r6[0x0]
8000294c:	80 00       	ld.sh	r0,r0[0x0]
8000294e:	42 00       	lddsp	r0,sp[0x80]

80002950 <CalculateBurst>:
Calls:
Called By: phy_payload_rx
*/

volatile RxAMBEBurstType CalculateBurst(U8 vf_sn)
{
80002950:	20 1c       	sub	r12,1
80002952:	5c 5c       	castu.b	r12
80002954:	31 18       	mov	r8,17
80002956:	f0 0c 18 00 	cp.b	r12,r8
8000295a:	e0 88 00 03 	brls	80002960 <CalculateBurst+0x10>
8000295e:	5e fd       	retal	0
80002960:	48 28       	lddpc	r8,80002968 <CalculateBurst+0x18>
80002962:	f0 0c 03 2c 	ld.w	r12,r8[r12<<0x2]
			Burst_ID = 0x00;
			return VOICE_WATING;
		
	}
	
}
80002966:	5e fc       	retal	r12
80002968:	80 00       	ld.sh	r0,r0[0x0]
8000296a:	c9 2c       	rcall	80002a8e <phy_tx+0x2a>

8000296c <payload_init>:
	Create the corresponding task;
Calls: xTaskCreate--freertos
Called By:app_init -- app.c
*/
void payload_init(void ( *payload_rx_func)(void * ), void ( *payload_tx_func)(void * ) )
{				
8000296c:	d4 01       	pushm	lr
	payload_rx_exec = payload_rx_func;
8000296e:	48 98       	lddpc	r8,80002990 <payload_init+0x24>
80002970:	91 0c       	st.w	r8[0x0],r12
	payload_tx_exec = payload_tx_func;
80002972:	48 98       	lddpc	r8,80002994 <payload_init+0x28>
80002974:	91 0b       	st.w	r8[0x0],r11
	
	
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
80002976:	30 09       	mov	r9,0
80002978:	1a d9       	st.w	--sp,r9
8000297a:	1a d9       	st.w	--sp,r9
8000297c:	1a d9       	st.w	--sp,r9
8000297e:	30 28       	mov	r8,2
80002980:	e0 6a 04 00 	mov	r10,1024
80002984:	48 5b       	lddpc	r11,80002998 <payload_init+0x2c>
80002986:	48 6c       	lddpc	r12,8000299c <payload_init+0x30>
80002988:	f0 1f 00 06 	mcall	800029a0 <payload_init+0x34>
8000298c:	2f dd       	sub	sp,-12
	//,  2
	//,  NULL
	//);
	//
	
}
8000298e:	d8 02       	popm	pc
80002990:	00 00       	add	r0,r0
80002992:	0a 68       	and	r8,r5
80002994:	00 00       	add	r0,r0
80002996:	0a 6c       	and	r12,r5
80002998:	80 00       	ld.sh	r0,r0[0x0]
8000299a:	c9 74       	brge	800028c8 <ToneControl_reply_func+0x24>
8000299c:	80 00       	ld.sh	r0,r0[0x0]
8000299e:	29 a4       	sub	r4,-102
800029a0:	80 00       	ld.sh	r0,r0[0x0]
800029a2:	5d a4       	*unknown*

800029a4 <payload_rx_process>:
Description: Receive the payload
Calls:
Called By:task
*/
static void payload_rx_process(void * pvParameters)
{
800029a4:	eb cd 40 f8 	pushm	r3-r7,lr
800029a8:	20 1d       	sub	sp,4
	/*To store the elements in the queue*/
	U16  * payload_ptr;
		
	if(NULL ==   phy_payload_frame_rx)
800029aa:	48 e8       	lddpc	r8,800029e0 <payload_rx_process+0x3c>
800029ac:	70 08       	ld.w	r8,r8[0x0]
800029ae:	58 08       	cp.w	r8,0
800029b0:	c0 71       	brne	800029be <payload_rx_process+0x1a>
	{
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
800029b2:	30 4b       	mov	r11,4
800029b4:	30 5c       	mov	r12,5
800029b6:	f0 1f 00 0c 	mcall	800029e4 <payload_rx_process+0x40>
800029ba:	48 a8       	lddpc	r8,800029e0 <payload_rx_process+0x3c>
800029bc:	91 0c       	st.w	r8[0x0],r12
	}
	
	for(;;)
	{
		if(pdTRUE == xQueueReceive( phy_payload_frame_rx, &payload_ptr,portMAX_DELAY ))
800029be:	48 96       	lddpc	r6,800029e0 <payload_rx_process+0x3c>
800029c0:	30 05       	mov	r5,0
800029c2:	3f f4       	mov	r4,-1
		{			
			payload_rx_exec(payload_ptr);//app_payload_rx_proc();
800029c4:	48 93       	lddpc	r3,800029e8 <payload_rx_process+0x44>
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
	}
	
	for(;;)
	{
		if(pdTRUE == xQueueReceive( phy_payload_frame_rx, &payload_ptr,portMAX_DELAY ))
800029c6:	6c 0c       	ld.w	r12,r6[0x0]
800029c8:	0a 99       	mov	r9,r5
800029ca:	08 9a       	mov	r10,r4
800029cc:	1a 9b       	mov	r11,sp
800029ce:	f0 1f 00 08 	mcall	800029ec <payload_rx_process+0x48>
800029d2:	58 1c       	cp.w	r12,1
800029d4:	cf 91       	brne	800029c6 <payload_rx_process+0x22>
		{			
			payload_rx_exec(payload_ptr);//app_payload_rx_proc();
800029d6:	66 08       	ld.w	r8,r3[0x0]
800029d8:	40 0c       	lddsp	r12,sp[0x0]
800029da:	5d 18       	icall	r8
800029dc:	cf 5b       	rjmp	800029c6 <payload_rx_process+0x22>
800029de:	00 00       	add	r0,r0
800029e0:	00 00       	add	r0,r0
800029e2:	0a 80       	andn	r0,r5
800029e4:	80 00       	ld.sh	r0,r0[0x0]
800029e6:	56 d0       	stdsp	sp[0x1b4],r0
800029e8:	00 00       	add	r0,r0
800029ea:	0a 68       	and	r8,r5
800029ec:	80 00       	ld.sh	r0,r0[0x0]
800029ee:	53 c4       	stdsp	sp[0xf0],r4

800029f0 <set_idle_store_isr>:
{
	xQueueSend(store, &ptr, 0);
}

void set_idle_store_isr(xQueueHandle store, void * ptr)
{
800029f0:	d4 01       	pushm	lr
800029f2:	20 2d       	sub	sp,8
800029f4:	50 0b       	stdsp	sp[0x0],r11
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
800029f6:	30 09       	mov	r9,0
800029f8:	fa ca ff f8 	sub	r10,sp,-8
800029fc:	14 d9       	st.w	--r10,r9
	xQueueSendFromISR(store, &ptr, &xHigherPriorityTaskWoken);
800029fe:	1a 9b       	mov	r11,sp
80002a00:	f0 1f 00 02 	mcall	80002a08 <set_idle_store_isr+0x18>
}
80002a04:	2f ed       	sub	sp,-8
80002a06:	d8 02       	popm	pc
80002a08:	80 00       	ld.sh	r0,r0[0x0]
80002a0a:	55 80       	stdsp	sp[0x160],r0

80002a0c <phy_rx>:
	xQueueSendFromISR -- freertos
Called By: phy_xnl_rx
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
80002a0c:	d4 01       	pushm	lr
80002a0e:	20 2d       	sub	sp,8
80002a10:	50 0c       	stdsp	sp[0x0],r12
	//memcpy(xx, phy_ptr, sizeof(phy_fragment_t));
	//set_phy_idle_isr(&phy_ptr, &xHigherPriorityTaskWoken);
	
	Bool res = FALSE;
	
	if(NULL == phy_ptr)
80002a12:	58 0c       	cp.w	r12,0
80002a14:	c1 10       	breq	80002a36 <phy_rx+0x2a>
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
    /*variables are used to store the push result in interrupt*/
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002a16:	30 08       	mov	r8,0
80002a18:	50 18       	stdsp	sp[0x4],r8
	if(NULL == phy_ptr)
	{
		return;
	}
	
    U16 phy_ctrl = phy_ptr->xnl_fragment.phy_header.phy_control;
80002a1a:	98 88       	ld.uh	r8,r12[0x0]
80002a1c:	e2 18 f0 00 	andl	r8,0xf000,COH
80002a20:	e0 48 40 00 	cp.w	r8,16384
80002a24:	c0 91       	brne	80002a36 <phy_rx+0x2a>

    if (XCMPXNL_DATA == (phy_ctrl & 0xF000))
    {
        /*push the xnl packet to queue*/
        if( pdTRUE == xQueueSendFromISR(
80002a26:	48 68       	lddpc	r8,80002a3c <phy_rx+0x30>
80002a28:	70 0c       	ld.w	r12,r8[0x0]
80002a2a:	30 09       	mov	r9,0
80002a2c:	fa ca ff fc 	sub	r10,sp,-4
80002a30:	1a 9b       	mov	r11,sp
80002a32:	f0 1f 00 04 	mcall	80002a40 <phy_rx+0x34>
		}	

    }
		
 
}
80002a36:	2f ed       	sub	sp,-8
80002a38:	d8 02       	popm	pc
80002a3a:	00 00       	add	r0,r0
80002a3c:	00 00       	add	r0,r0
80002a3e:	0a c4       	st.b	r5++,r4
80002a40:	80 00       	ld.sh	r0,r0[0x0]
80002a42:	55 80       	stdsp	sp[0x160],r0

80002a44 <set_idle_store>:
	}
}


void set_idle_store(xQueueHandle store, void * ptr)
{
80002a44:	eb cd 40 80 	pushm	r7,lr
80002a48:	20 1d       	sub	sp,4
80002a4a:	fa c7 ff fc 	sub	r7,sp,-4
80002a4e:	0e db       	st.w	--r7,r11
	xQueueSend(store, &ptr, 0);
80002a50:	30 09       	mov	r9,0
80002a52:	12 9a       	mov	r10,r9
80002a54:	1a 9b       	mov	r11,sp
80002a56:	f0 1f 00 03 	mcall	80002a60 <set_idle_store+0x1c>
}
80002a5a:	2f fd       	sub	sp,-4
80002a5c:	e3 cd 80 80 	ldm	sp++,r7,pc
80002a60:	80 00       	ld.sh	r0,r0[0x0]
80002a62:	55 d0       	stdsp	sp[0x174],r0

80002a64 <phy_tx>:
Calls:   
	xQueueSend -- freertos
Called By: xnl_tx -- xnl.c
*/
void phy_tx(phy_fragment_t * phy)
{	
80002a64:	d4 01       	pushm	lr
80002a66:	20 1d       	sub	sp,4
80002a68:	50 0c       	stdsp	sp[0x0],r12
	
	//phy_fragment_t * phy_ptr = malloc(sizeof(phy_fragment_t));
	//memcpy(phy_ptr, phy, sizeof(phy_fragment_t));
	//log("\n\r T_xcmp:%4x \n\r", phy->xnl_fragment.xnl_payload.xnl_content_data_msg.xcmp_opcode);
	//log("T_xnl-opcode:%4x", xnl->xnl_header.opcode);//log:R_xnl指令	
	if(XCMPXNL_DATA == (phy_ctrl & 0xF000))
80002a6a:	98 88       	ld.uh	r8,r12[0x0]
80002a6c:	e2 18 f0 00 	andl	r8,0xf000,COH
80002a70:	e0 48 40 00 	cp.w	r8,16384
80002a74:	c0 d1       	brne	80002a8e <phy_tx+0x2a>
	{
		/*push the xnl packet to queue to send */
		if(NULL != phy_xnl_frame_tx)
80002a76:	49 08       	lddpc	r8,80002ab4 <phy_tx+0x50>
80002a78:	70 08       	ld.w	r8,r8[0x0]
80002a7a:	58 08       	cp.w	r8,0
80002a7c:	c1 a0       	breq	80002ab0 <phy_tx+0x4c>
		{
			if( pdTRUE == xQueueSend(phy_xnl_frame_tx, &phy, 0))
80002a7e:	48 e8       	lddpc	r8,80002ab4 <phy_tx+0x50>
80002a80:	70 0c       	ld.w	r12,r8[0x0]
80002a82:	30 09       	mov	r9,0
80002a84:	12 9a       	mov	r10,r9
80002a86:	1a 9b       	mov	r11,sp
80002a88:	f0 1f 00 0c 	mcall	80002ab8 <phy_tx+0x54>
80002a8c:	c1 28       	rjmp	80002ab0 <phy_tx+0x4c>
		}
	}
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE		
	else if((SPEAKER_DATA == (phy_ctrl & 0xF000))
80002a8e:	e0 48 10 00 	cp.w	r8,4096
80002a92:	5f 0a       	sreq	r10
80002a94:	e0 48 20 00 	cp.w	r8,8192
80002a98:	5f 09       	sreq	r9
80002a9a:	f5 e9 10 09 	or	r9,r10,r9
80002a9e:	c0 71       	brne	80002aac <phy_tx+0x48>
80002aa0:	e0 48 50 00 	cp.w	r8,20480
80002aa4:	c0 40       	breq	80002aac <phy_tx+0x48>
80002aa6:	e0 48 60 00 	cp.w	r8,24576
80002aaa:	c0 31       	brne	80002ab0 <phy_tx+0x4c>
	    || (MIC_DATA  == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_RX == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_TX == (phy_ctrl & 0xF000))
	)
	{		
		if(NULL == phy_payload_frame_tx)
80002aac:	48 48       	lddpc	r8,80002abc <phy_tx+0x58>
80002aae:	70 08       	ld.w	r8,r8[0x0]
	
	if(res != TRUE)
	{
		//vPortFree(phy_ptr);
	}
}
80002ab0:	2f fd       	sub	sp,-4
80002ab2:	d8 02       	popm	pc
80002ab4:	00 00       	add	r0,r0
80002ab6:	0a d8       	st.w	--r5,r8
80002ab8:	80 00       	ld.sh	r0,r0[0x0]
80002aba:	55 d0       	stdsp	sp[0x174],r0
80002abc:	00 00       	add	r0,r0
80002abe:	0a b8       	st.h	r5++,r8

80002ac0 <get_idle_store_isr>:
		return NULL;
	}
}

void * get_idle_store_isr(xQueueHandle store)
{
80002ac0:	d4 01       	pushm	lr
80002ac2:	20 2d       	sub	sp,8
	void * ptr = NULL;
80002ac4:	30 08       	mov	r8,0
80002ac6:	50 18       	stdsp	sp[0x4],r8
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002ac8:	50 08       	stdsp	sp[0x0],r8
	
	if(pdTRUE == xQueueReceiveFromISR(store, &ptr, &xHigherPriorityTaskWoken))
80002aca:	1a 9a       	mov	r10,sp
80002acc:	fa cb ff fc 	sub	r11,sp,-4
80002ad0:	f0 1f 00 05 	mcall	80002ae4 <get_idle_store_isr+0x24>
80002ad4:	58 1c       	cp.w	r12,1
80002ad6:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80002ada:	fb fc 00 01 	ld.weq	r12,sp[0x4]
	}
	else
	{
		return NULL;
	}
}
80002ade:	2f ed       	sub	sp,-8
80002ae0:	d8 02       	popm	pc
80002ae2:	00 00       	add	r0,r0
80002ae4:	80 00       	ld.sh	r0,r0[0x0]
80002ae6:	52 d4       	stdsp	sp[0xb4],r4

80002ae8 <phy_tx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_tx_func( void * ssc)
{
80002ae8:	eb cd 40 c0 	pushm	r6-r7,lr
80002aec:	20 1d       	sub	sp,4
80002aee:	18 97       	mov	r7,r12
    if(NULL != phy_xnl_frame_tx)
80002af0:	fe f8 04 70 	ld.w	r8,pc[1136]
80002af4:	70 08       	ld.w	r8,r8[0x0]
80002af6:	58 08       	cp.w	r8,0
80002af8:	c7 40       	breq	80002be0 <phy_tx_func+0xf8>
    {
  	  	/*send ssc data in xnl frame*/
  	  	phy_xnl_tx(&(((ssc_fragment_t * )ssc)->xnl_channel));		
80002afa:	18 96       	mov	r6,r12
Called By:phy_tx_func
*/
static void phy_xnl_tx(xnl_channel_t * xnl_tx_channel)
{
	/*variables are used to store the push result in interrupt*/
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002afc:	30 08       	mov	r8,0
80002afe:	50 08       	stdsp	sp[0x0],r8
	
	static S16 phy_tx_expexted_length = 0;
	static U8 phy_tx_index = 0;
	
	/*his is the code for handling any outgoing XNL Phy message*/
	switch(phy_tx_state)
80002b00:	fe f8 04 64 	ld.w	r8,pc[1124]
80002b04:	70 08       	ld.w	r8,r8[0x0]
80002b06:	58 18       	cp.w	r8,1
80002b08:	c2 90       	breq	80002b5a <phy_tx_func+0x72>
80002b0a:	c0 43       	brcs	80002b12 <phy_tx_func+0x2a>
80002b0c:	58 28       	cp.w	r8,2
80002b0e:	c6 91       	brne	80002be0 <phy_tx_func+0xf8>
80002b10:	c6 18       	rjmp	80002bd2 <phy_tx_func+0xea>
	{
		/*Waiting for the send xnl packet*/
		case WAITING_FOR_PHY_TX:			
			if( pdTRUE == xQueueReceiveFromISR(
80002b12:	fe f8 04 4e 	ld.w	r8,pc[1102]
80002b16:	70 0c       	ld.w	r12,r8[0x0]
80002b18:	1a 9a       	mov	r10,sp
80002b1a:	fe fb 04 4e 	ld.w	r11,pc[1102]
80002b1e:	f0 1f 01 14 	mcall	80002f6c <phy_tx_func+0x484>
80002b22:	58 1c       	cp.w	r12,1
80002b24:	c1 51       	brne	80002b4e <phy_tx_func+0x66>
				  phy_xnl_frame_tx
				, &phy_ptr
				, &xHigherPriorityTaskWoken 
			))
			{								
				phy_tx_expexted_length = 
80002b26:	fe f8 04 42 	ld.w	r8,pc[1090]
80002b2a:	70 08       	ld.w	r8,r8[0x0]
80002b2c:	11 9a       	ld.ub	r10,r8[0x1]
80002b2e:	fe f9 04 42 	ld.w	r9,pc[1090]
80002b32:	b2 0a       	st.h	r9[0x0],r10
				*/
				xnl_tx_channel->dword = 
				                   phy_ptr->xnl_fragment.phy_header.phy_control;
				
				/*Transmit 0xABCD0000 | Type/Length.*/
				xnl_tx_channel->dword |= PHYHEADER32;
80002b34:	90 88       	ld.uh	r8,r8[0x0]
80002b36:	ea 18 ab cd 	orh	r8,0xabcd
80002b3a:	8f 18       	st.w	r7[0x4],r8
				
				phy_tx_index = 1;
80002b3c:	30 19       	mov	r9,1
80002b3e:	fe f8 04 36 	ld.w	r8,pc[1078]
80002b42:	b0 89       	st.b	r8[0x0],r9
				phy_tx_state = WRITE_NEXT_DWORD;	
80002b44:	30 19       	mov	r9,1
80002b46:	fe f8 04 1e 	ld.w	r8,pc[1054]
80002b4a:	91 09       	st.w	r8[0x0],r9
80002b4c:	c4 a8       	rjmp	80002be0 <phy_tx_func+0xf8>
				/*The new transmission has started.*/
			}
			else
			{
				/*Nothing new to transmit, send an idle frame*/
				xnl_tx_channel->dword = XNL_IDLE;
80002b4e:	e0 68 5a 5a 	mov	r8,23130
80002b52:	ea 18 ab cd 	orh	r8,0xabcd
80002b56:	8f 18       	st.w	r7[0x4],r8
80002b58:	c4 48       	rjmp	80002be0 <phy_tx_func+0xf8>
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80002b5a:	fe f9 04 1a 	ld.w	r9,pc[1050]
80002b5e:	13 88       	ld.ub	r8,r9[0x0]
				xnl_tx_channel->dword = XNL_IDLE;
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
80002b60:	fe fa 04 08 	ld.w	r10,pc[1032]
80002b64:	74 0a       	ld.w	r10,r10[0x0]
80002b66:	f4 08 05 1a 	ld.uh	r10,r10[r8<<0x1]
80002b6a:	b1 6a       	lsl	r10,0x10
80002b6c:	99 1a       	st.w	r12[0x4],r10
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80002b6e:	2f f8       	sub	r8,-1
80002b70:	5c 58       	castu.b	r8
80002b72:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
80002b74:	fe fa 03 fc 	ld.w	r10,pc[1020]
80002b78:	94 09       	ld.sh	r9,r10[0x0]
80002b7a:	20 29       	sub	r9,2
80002b7c:	b4 09       	st.h	r10[0x0],r9
			
			/*have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80002b7e:	30 0a       	mov	r10,0
80002b80:	f4 09 19 00 	cp.h	r9,r10
80002b84:	e0 89 00 0b 	brgt	80002b9a <phy_tx_func+0xb2>
			{
				/*Must immediately send 0x00BA in Slot 4.*/
				xnl_tx_channel->dword |= PHYTERMRIGHT;
80002b88:	78 18       	ld.w	r8,r12[0x4]
80002b8a:	e8 18 00 ba 	orl	r8,0xba
80002b8e:	99 18       	st.w	r12[0x4],r8
				
				/*Go back to waiting.*/
				phy_tx_state = WAITING_FOR_PHY_TX;
80002b90:	30 09       	mov	r9,0
80002b92:	fe f8 03 d2 	ld.w	r8,pc[978]
80002b96:	91 09       	st.w	r8[0x0],r9
80002b98:	c2 48       	rjmp	80002be0 <phy_tx_func+0xf8>
				break;
			}

			/*Have not broken. Transmit 2nd hWord.*/
			xnl_tx_channel->dword |=  phy_ptr->fragment_element[phy_tx_index++];
80002b9a:	fe f9 03 ce 	ld.w	r9,pc[974]
80002b9e:	72 09       	ld.w	r9,r9[0x0]
80002ba0:	f2 08 05 19 	ld.uh	r9,r9[r8<<0x1]
80002ba4:	78 1a       	ld.w	r10,r12[0x4]
80002ba6:	f5 e9 10 09 	or	r9,r10,r9
80002baa:	99 19       	st.w	r12[0x4],r9
80002bac:	2f f8       	sub	r8,-1
80002bae:	fe f9 03 c6 	ld.w	r9,pc[966]
80002bb2:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
80002bb4:	fe f9 03 bc 	ld.w	r9,pc[956]
80002bb8:	92 08       	ld.sh	r8,r9[0x0]
80002bba:	20 28       	sub	r8,2
80002bbc:	b2 08       	st.h	r9[0x0],r8
			
			/*Have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80002bbe:	30 09       	mov	r9,0
80002bc0:	f2 08 19 00 	cp.h	r8,r9
80002bc4:	e0 89 00 0e 	brgt	80002be0 <phy_tx_func+0xf8>
			{
				/*Must send 0x00BA0000 next interrupt in Slot 3&4*/
				phy_tx_state = SEND_TAILED;
80002bc8:	30 29       	mov	r9,2
80002bca:	fe f8 03 9a 	ld.w	r8,pc[922]
80002bce:	91 09       	st.w	r8[0x0],r9
80002bd0:	c0 88       	rjmp	80002be0 <phy_tx_func+0xf8>
			}
			break;

		case SEND_TAILED:
			/*send 0x00BA0000*/
			xnl_tx_channel->dword = PHYTERMLEFT;
80002bd2:	fc 18 00 ba 	movh	r8,0xba
80002bd6:	99 18       	st.w	r12[0x4],r8
			
			/*Go back to waiting.*/		
			phy_tx_state = WAITING_FOR_PHY_TX;		
80002bd8:	30 09       	mov	r9,0
80002bda:	fe f8 03 8a 	ld.w	r8,pc[906]
80002bde:	91 09       	st.w	r8[0x0],r9
	
	//static U8 frame_5_end = 0;
	//static U16 pay[256];
	
	//Send-AMBE-data
	if ((AMBE_Media == TRUE))
80002be0:	fe f8 03 98 	ld.w	r8,pc[920]
80002be4:	11 89       	ld.ub	r9,r8[0x0]
80002be6:	30 18       	mov	r8,1
80002be8:	f0 09 18 00 	cp.b	r9,r8
80002bec:	e0 81 01 af 	brne	80002f4a <phy_tx_func+0x462>
	{
		A_index = (A_index >=1456) ? 0 : A_index;
80002bf0:	fe f8 03 8c 	ld.w	r8,pc[908]
80002bf4:	70 08       	ld.w	r8,r8[0x0]
80002bf6:	e0 48 05 b0 	cp.w	r8,1456
80002bfa:	f9 b8 02 00 	movhs	r8,0
80002bfe:	fe f9 03 7e 	ld.w	r9,pc[894]
80002c02:	93 08       	st.w	r9[0x0],r8
	  //AMBE_flag
		switch(AMBEpayload_tx_state)
80002c04:	fe f8 03 7c 	ld.w	r8,pc[892]
80002c08:	70 08       	ld.w	r8,r8[0x0]
80002c0a:	58 68       	cp.w	r8,6
80002c0c:	e0 8b 01 95 	brhi	80002f36 <phy_tx_func+0x44e>
80002c10:	fe f9 03 74 	ld.w	r9,pc[884]
80002c14:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
		{
			case AMBE_IDLE:
		
				if ((m_RxBurstType == VOICE_WATING) || (m_RxBurstType == VOICETERMINATOR)  || (m_RxBurstType == VOICEHEADER))
80002c18:	fe f8 03 70 	ld.w	r8,pc[880]
80002c1c:	70 08       	ld.w	r8,r8[0x0]
80002c1e:	58 08       	cp.w	r8,0
80002c20:	c0 b0       	breq	80002c36 <phy_tx_func+0x14e>
80002c22:	fe f8 03 66 	ld.w	r8,pc[870]
80002c26:	70 08       	ld.w	r8,r8[0x0]
80002c28:	58 a8       	cp.w	r8,10
80002c2a:	c0 60       	breq	80002c36 <phy_tx_func+0x14e>
80002c2c:	fe f8 03 5c 	ld.w	r8,pc[860]
80002c30:	70 08       	ld.w	r8,r8[0x0]
80002c32:	58 18       	cp.w	r8,1
80002c34:	c0 a1       	brne	80002c48 <phy_tx_func+0x160>
				{
							
					payload_tx_channel->dword[0] = PAYLOADIDLE0;
80002c36:	e0 68 5a 5a 	mov	r8,23130
80002c3a:	ea 18 ab cd 	orh	r8,0xabcd
80002c3e:	8f 28       	st.w	r7[0x8],r8
					payload_tx_channel->dword[1] = PAYLOADIDLE1;
80002c40:	30 08       	mov	r8,0
80002c42:	8f 38       	st.w	r7[0xc],r8
80002c44:	e0 8f 01 8a 	bral	80002f58 <phy_tx_func+0x470>
			
				}
				else if((m_RxBurstType == UNSUREDATA))
80002c48:	fe f8 03 40 	ld.w	r8,pc[832]
80002c4c:	70 08       	ld.w	r8,r8[0x0]
80002c4e:	58 38       	cp.w	r8,3
80002c50:	c0 91       	brne	80002c62 <phy_tx_func+0x17a>
				{
					payload_tx_channel->dword[0] = AMBE_HT[0];
80002c52:	fe f8 03 3a 	ld.w	r8,pc[826]
80002c56:	70 09       	ld.w	r9,r8[0x0]
80002c58:	8f 29       	st.w	r7[0x8],r9
					payload_tx_channel->dword[1] = AMBE_HT[1];
80002c5a:	70 18       	ld.w	r8,r8[0x4]
80002c5c:	8f 38       	st.w	r7[0xc],r8
80002c5e:	e0 8f 01 7d 	bral	80002f58 <phy_tx_func+0x470>
				else//加密和解密的激励类型
				{
					
					//Radio Internal Parameter + Vocoder Bits Stream Parameter + soft decision value + 1st 20ms AMBE bits of Voice Burst A 
					//assemble 4 items into 1 Command. Send it to Radio.
					if (m_RxBurstType == RADIOINTERNAL)//解密数据
80002c62:	fe f8 03 26 	ld.w	r8,pc[806]
80002c66:	70 08       	ld.w	r8,r8[0x0]
80002c68:	58 28       	cp.w	r8,2
80002c6a:	c1 31       	brne	80002c90 <phy_tx_func+0x1a8>
					{
						//0xABCDCO32
						payload_tx_channel->dword[0] = DE_OB_PAYLOAD;//50bytes
80002c6c:	e0 68 c0 32 	mov	r8,49202
80002c70:	ea 18 ab cd 	orh	r8,0xabcd
80002c74:	8f 28       	st.w	r7[0x8],r8
						//0x847F
						payload_tx_channel->word[2] = RIP_PAYLOAD;
80002c76:	fe 78 84 7f 	mov	r8,-31617
80002c7a:	ae 68       	st.h	r7[0xc],r8
						//0xxxxx
						payload_tx_channel->word[3] = Radio_Internal_Data[0];
80002c7c:	fe f8 03 14 	ld.w	r8,pc[788]
80002c80:	90 08       	ld.sh	r8,r8[0x0]
80002c82:	ae 78       	st.h	r7[0xe],r8
						
						AMBEpayload_tx_state = AMBE_DE_FIRST;
80002c84:	30 39       	mov	r9,3
80002c86:	fe f8 02 fa 	ld.w	r8,pc[762]
80002c8a:	91 09       	st.w	r8[0x0],r9
80002c8c:	e0 8f 01 66 	bral	80002f58 <phy_tx_func+0x470>
					//assemble 2 items into 1 Command. Send it to Radio.
					else//加密数据
					{
	
						//0xABCDCOOE
						payload_tx_channel->dword[0] = EN_OB_PAYLOAD;//49bits
80002c90:	e0 68 c0 0e 	mov	r8,49166
80002c94:	ea 18 ab cd 	orh	r8,0xabcd
80002c98:	8f 28       	st.w	r7[0x8],r8
						//0x8212
						payload_tx_channel->word[2] = VBSP_data[0];
80002c9a:	fe f8 02 fa 	ld.w	r8,pc[762]
80002c9e:	90 09       	ld.sh	r9,r8[0x0]
80002ca0:	ae 69       	st.h	r7[0xc],r9
						//0xF00x
						payload_tx_channel->word[3] = VBSP_data[1];
80002ca2:	90 18       	ld.sh	r8,r8[0x2]
80002ca4:	ae 78       	st.h	r7[0xe],r8
						
						AMBEpayload_tx_state = AMBE_EN_FIRST;
80002ca6:	30 19       	mov	r9,1
80002ca8:	fe f8 02 d8 	ld.w	r8,pc[728]
80002cac:	91 09       	st.w	r8[0x0],r9
80002cae:	e0 8f 01 55 	bral	80002f58 <phy_tx_func+0x470>
			
			case AMBE_EN_FIRST:
			
			
				//0x88F2
				payload_tx_channel->word[0] = ENCODER_PAYLOAD;//49bits
80002cb2:	fe 78 88 f2 	mov	r8,-30478
80002cb6:	ae 48       	st.h	r7[0x8],r8
				//A_index+=2;
				//
				//AMBEpayload_tx_state = AMBE_EN_LAST;
				
			
				switch (m_RxBurstType)//在发送函数中去做加密处理
80002cb8:	fe f8 02 d0 	ld.w	r8,pc[720]
80002cbc:	70 08       	ld.w	r8,r8[0x0]
80002cbe:	58 48       	cp.w	r8,4
80002cc0:	c0 60       	breq	80002ccc <phy_tx_func+0x1e4>
80002cc2:	c4 53       	brcs	80002d4c <phy_tx_func+0x264>
80002cc4:	58 98       	cp.w	r8,9
80002cc6:	e0 8b 00 43 	brhi	80002d4c <phy_tx_func+0x264>
80002cca:	c2 98       	rjmp	80002d1c <phy_tx_func+0x234>
				{
					case VOICEBURST_A:
							if (VF_SN == 1)
80002ccc:	fe f8 02 cc 	ld.w	r8,pc[716]
80002cd0:	11 89       	ld.ub	r9,r8[0x0]
80002cd2:	30 18       	mov	r8,1
80002cd4:	f0 09 18 00 	cp.b	r9,r8
80002cd8:	c0 a1       	brne	80002cec <phy_tx_func+0x204>
							{	
								
								
								//Place public key
								payload_tx_channel->word[1] = Public_AMBEkey[0];
80002cda:	fe f8 02 c2 	ld.w	r8,pc[706]
80002cde:	90 09       	ld.sh	r9,r8[0x0]
80002ce0:	ae 59       	st.h	r7[0xa],r9
								payload_tx_channel->word[2] = Public_AMBEkey[1];
80002ce2:	90 19       	ld.sh	r9,r8[0x2]
80002ce4:	ae 69       	st.h	r7[0xc],r9
								payload_tx_channel->word[3] = Public_AMBEkey[2];
80002ce6:	90 28       	ld.sh	r8,r8[0x4]
80002ce8:	ae 78       	st.h	r7[0xe],r8
80002cea:	c1 48       	rjmp	80002d12 <phy_tx_func+0x22a>
							{
								
								
						
								//Encrypted AMBE data(XOR)
								payload_tx_channel->word[1] = ((Public_AMBEkey[0]) ^ (AMBEBurst_rawdata[0])) ;
80002cec:	fe f9 02 b4 	ld.w	r9,pc[692]
80002cf0:	92 0b       	ld.sh	r11,r9[0x0]
80002cf2:	fe f8 02 aa 	ld.w	r8,pc[682]
80002cf6:	90 0a       	ld.sh	r10,r8[0x0]
80002cf8:	f7 ea 20 0a 	eor	r10,r11,r10
80002cfc:	ae 5a       	st.h	r7[0xa],r10
								payload_tx_channel->word[2] = ((Public_AMBEkey[1]) ^ (AMBEBurst_rawdata[1])) ;
80002cfe:	92 1b       	ld.sh	r11,r9[0x2]
80002d00:	90 1a       	ld.sh	r10,r8[0x2]
80002d02:	f7 ea 20 0a 	eor	r10,r11,r10
80002d06:	ae 6a       	st.h	r7[0xc],r10
								payload_tx_channel->word[3] = ((Public_AMBEkey[2]) ^ (AMBEBurst_rawdata[2])) ;
80002d08:	92 29       	ld.sh	r9,r9[0x4]
80002d0a:	90 28       	ld.sh	r8,r8[0x4]
80002d0c:	f3 e8 20 08 	eor	r8,r9,r8
80002d10:	ae 78       	st.h	r7[0xe],r8
								//payload_tx_channel->word[3] = AMBEBurst_rawdata[2];
							
						
							}
					
							AMBEpayload_tx_state = AMBE_EN_LAST;
80002d12:	30 29       	mov	r9,2
80002d14:	fe f8 02 6c 	ld.w	r8,pc[620]
80002d18:	91 09       	st.w	r8[0x0],r9
80002d1a:	c1 f9       	rjmp	80002f58 <phy_tx_func+0x470>
							//Encrypted AMBE data(XOR)
						
							//payload_tx_channel->word[1] = AMBEBurst_rawdata[0];
							//payload_tx_channel->word[2] = AMBEBurst_rawdata[1];
							//payload_tx_channel->word[3] = AMBEBurst_rawdata[2];
							payload_tx_channel->word[1] = ((Public_AMBEkey[0]) ^ (AMBEBurst_rawdata[0])) ;
80002d1c:	fe f9 02 84 	ld.w	r9,pc[644]
80002d20:	92 0b       	ld.sh	r11,r9[0x0]
80002d22:	fe f8 02 7a 	ld.w	r8,pc[634]
80002d26:	90 0a       	ld.sh	r10,r8[0x0]
80002d28:	f7 ea 20 0a 	eor	r10,r11,r10
80002d2c:	ae 5a       	st.h	r7[0xa],r10
							payload_tx_channel->word[2] = ((Public_AMBEkey[1]) ^ (AMBEBurst_rawdata[1])) ;
80002d2e:	92 1b       	ld.sh	r11,r9[0x2]
80002d30:	90 1a       	ld.sh	r10,r8[0x2]
80002d32:	f7 ea 20 0a 	eor	r10,r11,r10
80002d36:	ae 6a       	st.h	r7[0xc],r10
							payload_tx_channel->word[3] = ((Public_AMBEkey[2]) ^ (AMBEBurst_rawdata[2])) ;
80002d38:	92 29       	ld.sh	r9,r9[0x4]
80002d3a:	90 28       	ld.sh	r8,r8[0x4]
80002d3c:	f3 e8 20 08 	eor	r8,r9,r8
80002d40:	ae 78       	st.h	r7[0xe],r8
						
							AMBEpayload_tx_state = AMBE_EN_LAST;
80002d42:	30 29       	mov	r9,2
80002d44:	fe f8 02 3c 	ld.w	r8,pc[572]
80002d48:	91 09       	st.w	r8[0x0],r9
80002d4a:	c0 79       	rjmp	80002f58 <phy_tx_func+0x470>
				
						break;
					default://This shouldn't happen, but must check;
					
							payload_tx_channel->dword[0] = PAYLOADIDLE0;
80002d4c:	e0 68 5a 5a 	mov	r8,23130
80002d50:	ea 18 ab cd 	orh	r8,0xabcd
80002d54:	8f 28       	st.w	r7[0x8],r8
							payload_tx_channel->dword[1] = PAYLOADIDLE1;
80002d56:	30 08       	mov	r8,0
80002d58:	8f 38       	st.w	r7[0xc],r8
							
							AMBEpayload_tx_state = AMBE_IDLE;
80002d5a:	fe f9 02 26 	ld.w	r9,pc[550]
80002d5e:	93 08       	st.w	r9[0x0],r8
80002d60:	cf c8       	rjmp	80002f58 <phy_tx_func+0x470>
						  1:VF1 of first Burst A after last Voice Header (49 bits).
						  2:Last 4 bits (bit 45 to bit 48) of every 49 bits AMBE Voice Frame. (72 bits@Super Frame).
					
					*/
					
					payload_tx_channel->word[0] = AMBEBurst_rawdata[3];
80002d62:	fe f8 02 3e 	ld.w	r8,pc[574]
80002d66:	90 38       	ld.sh	r8,r8[0x6]
80002d68:	ae 48       	st.h	r7[0x8],r8
					
					
					//payload_tx_channel->word[0] = ((AMBE_AudioData[A_index]<<8) + 0x00) ;//需要补充Pad_bits位
					//A_index+=1;
					
					payload_tx_channel->word[1]	= 0x00BA ; 
80002d6a:	e0 68 00 ba 	mov	r8,186
80002d6e:	ae 58       	st.h	r7[0xa],r8
					payload_tx_channel->word[2]	= 0x0000 ;
80002d70:	30 08       	mov	r8,0
80002d72:	ae 68       	st.h	r7[0xc],r8
					payload_tx_channel->word[3]	= 0x0000 ;
80002d74:	ae 78       	st.h	r7[0xe],r8
				
					AMBEpayload_tx_state = AMBE_IDLE;
80002d76:	30 09       	mov	r9,0
80002d78:	fe f8 02 08 	ld.w	r8,pc[520]
80002d7c:	91 09       	st.w	r8[0x0],r9
80002d7e:	ce d8       	rjmp	80002f58 <phy_tx_func+0x470>
				break;
				
			case AMBE_DE_FIRST:
				
					//0xxxxx
					payload_tx_channel->word[0] = Radio_Internal_Data[1];
80002d80:	fe f8 02 10 	ld.w	r8,pc[528]
80002d84:	90 18       	ld.sh	r8,r8[0x2]
80002d86:	ae 48       	st.h	r7[0x8],r8
					//0x8212
					payload_tx_channel->word[1] = VBSP_data[0];
80002d88:	fe f8 02 0c 	ld.w	r8,pc[524]
80002d8c:	90 08       	ld.sh	r8,r8[0x0]
80002d8e:	ae 58       	st.h	r7[0xa],r8
					
					if ((m_RxBurstType == VOICEBURST_A) && (VF_SN == 1) )
80002d90:	4f e8       	lddpc	r8,80002f88 <phy_tx_func+0x4a0>
80002d92:	70 08       	ld.w	r8,r8[0x0]
80002d94:	58 48       	cp.w	r8,4
80002d96:	c0 d1       	brne	80002db0 <phy_tx_func+0x2c8>
80002d98:	fe f8 02 00 	ld.w	r8,pc[512]
80002d9c:	11 89       	ld.ub	r9,r8[0x0]
80002d9e:	30 18       	mov	r8,1
80002da0:	f0 09 18 00 	cp.b	r9,r8
80002da4:	c0 61       	brne	80002db0 <phy_tx_func+0x2c8>
					{
						// Vocoder Bits Stream Parameter("E(bit8)" flag = 1)
						//0xF0(8+)x
						payload_tx_channel->word[2] = ((VBSP_data[1]) | (0x0100));
80002da6:	4f c8       	lddpc	r8,80002f94 <phy_tx_func+0x4ac>
80002da8:	90 18       	ld.sh	r8,r8[0x2]
80002daa:	a9 a8       	sbr	r8,0x8
80002dac:	ae 68       	st.h	r7[0xc],r8
80002dae:	c0 48       	rjmp	80002db6 <phy_tx_func+0x2ce>
					}
					else
						//0xF00x
						payload_tx_channel->word[2] = (VBSP_data[1]) ;
80002db0:	4f 98       	lddpc	r8,80002f94 <phy_tx_func+0x4ac>
80002db2:	90 18       	ld.sh	r8,r8[0x2]
80002db4:	ae 68       	st.h	r7[0xc],r8
					
					//0x9A13
					payload_tx_channel->word[3] = SDV_PAYLOAD;
80002db6:	fe 78 9a 13 	mov	r8,-26093
80002dba:	ae 78       	st.h	r7[0xe],r8
		
					AMBEpayload_tx_state = AMBE_DE_SECOND;
80002dbc:	30 49       	mov	r9,4
80002dbe:	4f 18       	lddpc	r8,80002f80 <phy_tx_func+0x498>
80002dc0:	91 09       	st.w	r8[0x0],r9
80002dc2:	cc b8       	rjmp	80002f58 <phy_tx_func+0x470>
				break;
			
			case AMBE_DE_SECOND:
					//Post back soft decision value data

						payload_tx_channel->word[0] = Soft_Decision_Data[Soft_index] ;
80002dc4:	4f 88       	lddpc	r8,80002fa4 <phy_tx_func+0x4bc>
80002dc6:	70 0a       	ld.w	r10,r8[0x0]
80002dc8:	4f 89       	lddpc	r9,80002fa8 <phy_tx_func+0x4c0>
80002dca:	f2 0a 04 1a 	ld.sh	r10,r9[r10<<0x1]
80002dce:	ae 4a       	st.h	r7[0x8],r10
						payload_tx_channel->word[1] = Soft_Decision_Data[Soft_index+1] ;
80002dd0:	70 0a       	ld.w	r10,r8[0x0]
80002dd2:	2f fa       	sub	r10,-1
80002dd4:	f2 0a 04 1a 	ld.sh	r10,r9[r10<<0x1]
80002dd8:	ae 5a       	st.h	r7[0xa],r10
						payload_tx_channel->word[2] = Soft_Decision_Data[Soft_index+2] ;
80002dda:	70 0a       	ld.w	r10,r8[0x0]
80002ddc:	2f ea       	sub	r10,-2
80002dde:	f2 0a 04 1a 	ld.sh	r10,r9[r10<<0x1]
80002de2:	ae 6a       	st.h	r7[0xc],r10
						payload_tx_channel->word[3] = Soft_Decision_Data[Soft_index+3] ;
80002de4:	70 0a       	ld.w	r10,r8[0x0]
80002de6:	2f da       	sub	r10,-3
80002de8:	f2 0a 04 19 	ld.sh	r9,r9[r10<<0x1]
80002dec:	ae 79       	st.h	r7[0xe],r9
						Soft_index +=4;
80002dee:	70 09       	ld.w	r9,r8[0x0]
80002df0:	2f c9       	sub	r9,-4
80002df2:	91 09       	st.w	r8[0x0],r9
						
						if (Soft_index == 12)
80002df4:	58 c9       	cp.w	r9,12
80002df6:	c0 51       	brne	80002e00 <phy_tx_func+0x318>
						{
							AMBEpayload_tx_state = AMBE_DE_THIRD;
80002df8:	30 59       	mov	r9,5
80002dfa:	4e 28       	lddpc	r8,80002f80 <phy_tx_func+0x498>
80002dfc:	91 09       	st.w	r8[0x0],r9
80002dfe:	ca d8       	rjmp	80002f58 <phy_tx_func+0x470>
							//Soft_index = 0 ;
							
						}
						else
						AMBEpayload_tx_state = AMBE_DE_SECOND;
80002e00:	30 49       	mov	r9,4
80002e02:	4e 08       	lddpc	r8,80002f80 <phy_tx_func+0x498>
80002e04:	91 09       	st.w	r8[0x0],r9
80002e06:	ca 98       	rjmp	80002f58 <phy_tx_func+0x470>
				break;	
				
			case AMBE_DE_THIRD:
					
					//0x xxxx
					payload_tx_channel->word[0] = Soft_Decision_Data[Soft_index] ;
80002e08:	4e 78       	lddpc	r8,80002fa4 <phy_tx_func+0x4bc>
80002e0a:	70 0a       	ld.w	r10,r8[0x0]
80002e0c:	4e 79       	lddpc	r9,80002fa8 <phy_tx_func+0x4c0>
80002e0e:	f2 0a 04 19 	ld.sh	r9,r9[r10<<0x1]
80002e12:	ae 49       	st.h	r7[0x8],r9
					Soft_index = 0 ;//索引清零
80002e14:	30 09       	mov	r9,0
80002e16:	91 09       	st.w	r8[0x0],r9
					
					//0x8003 隔离符号？
					payload_tx_channel->word[1] = 0x8003;
80002e18:	fe 78 80 03 	mov	r8,-32765
80002e1c:	ae 58       	st.h	r7[0xa],r8
					//0x88F3
					payload_tx_channel->word[2] = DECODER_PAYLOAD;
80002e1e:	fe 78 88 f3 	mov	r8,-30477
80002e22:	ae 68       	st.h	r7[0xc],r8
				
					switch (m_RxBurstType)//在发送函数中去做解密处理
80002e24:	4d 98       	lddpc	r8,80002f88 <phy_tx_func+0x4a0>
80002e26:	70 08       	ld.w	r8,r8[0x0]
80002e28:	58 48       	cp.w	r8,4
80002e2a:	c0 60       	breq	80002e36 <phy_tx_func+0x34e>
80002e2c:	c2 83       	brcs	80002e7c <phy_tx_func+0x394>
80002e2e:	58 98       	cp.w	r8,9
80002e30:	e0 8b 00 26 	brhi	80002e7c <phy_tx_func+0x394>
80002e34:	c1 98       	rjmp	80002e66 <phy_tx_func+0x37e>
					{
						case VOICEBURST_A:
								if (VF_SN == 1)
80002e36:	4d 98       	lddpc	r8,80002f98 <phy_tx_func+0x4b0>
80002e38:	11 89       	ld.ub	r9,r8[0x0]
80002e3a:	30 18       	mov	r8,1
80002e3c:	f0 09 18 00 	cp.b	r9,r8
80002e40:	c0 81       	brne	80002e50 <phy_tx_func+0x368>
									//if(AMBEBurst_rawdata[0] == Public_AMBEkey[0])//0X1AC3
									{
										
									
										//Pick up public key
										AMBE_DecryptionKey[0] = AMBEBurst_rawdata[0];
80002e42:	4d 88       	lddpc	r8,80002fa0 <phy_tx_func+0x4b8>
80002e44:	90 0a       	ld.sh	r10,r8[0x0]
80002e46:	4d a9       	lddpc	r9,80002fac <phy_tx_func+0x4c4>
80002e48:	b2 0a       	st.h	r9[0x0],r10
									
										//Post back data
										payload_tx_channel->word[3] = AMBEBurst_rawdata[0] ;
80002e4a:	90 08       	ld.sh	r8,r8[0x0]
80002e4c:	ae 78       	st.h	r7[0xe],r8
80002e4e:	c0 88       	rjmp	80002e5e <phy_tx_func+0x376>
								else//VF_SN==2/3
								{	
									//Decrypt AMBE data(XOR) 
									//Recover data

									payload_tx_channel->word[3] = ((AMBE_DecryptionKey[0]) ^ (AMBEBurst_rawdata[0])) ;
80002e50:	4d 78       	lddpc	r8,80002fac <phy_tx_func+0x4c4>
80002e52:	90 08       	ld.sh	r8,r8[0x0]
80002e54:	4d 39       	lddpc	r9,80002fa0 <phy_tx_func+0x4b8>
80002e56:	92 09       	ld.sh	r9,r9[0x0]
80002e58:	f3 e8 20 08 	eor	r8,r9,r8
80002e5c:	ae 78       	st.h	r7[0xe],r8
									
									//payload_tx_channel->word[3] = ((AMBEBurst_rawdata[0])) ;
						
								}
					
								AMBEpayload_tx_state = AMBE_DE_LAST;
80002e5e:	30 69       	mov	r9,6
80002e60:	4c 88       	lddpc	r8,80002f80 <phy_tx_func+0x498>
80002e62:	91 09       	st.w	r8[0x0],r9
80002e64:	c7 a8       	rjmp	80002f58 <phy_tx_func+0x470>
						
								//Encrypted AMBE data(XOR)
						
								//Decrypt AMBE data(XOR)
								//Recover data
								payload_tx_channel->word[3] = ((AMBE_DecryptionKey[0]) ^ (AMBEBurst_rawdata[0])) ;
80002e66:	4d 28       	lddpc	r8,80002fac <phy_tx_func+0x4c4>
80002e68:	90 08       	ld.sh	r8,r8[0x0]
80002e6a:	4c e9       	lddpc	r9,80002fa0 <phy_tx_func+0x4b8>
80002e6c:	92 09       	ld.sh	r9,r9[0x0]
80002e6e:	f3 e8 20 08 	eor	r8,r9,r8
80002e72:	ae 78       	st.h	r7[0xe],r8
								//payload_tx_channel->word[3] = ((AMBEBurst_rawdata[0])) ;
						
								AMBEpayload_tx_state = AMBE_DE_LAST;
80002e74:	30 69       	mov	r9,6
80002e76:	4c 38       	lddpc	r8,80002f80 <phy_tx_func+0x498>
80002e78:	91 09       	st.w	r8[0x0],r9
80002e7a:	c6 f8       	rjmp	80002f58 <phy_tx_func+0x470>
				
							break;
						default://This shouldn't happen, but must check;
					
								payload_tx_channel->dword[0] = PAYLOADIDLE0;
80002e7c:	e0 68 5a 5a 	mov	r8,23130
80002e80:	ea 18 ab cd 	orh	r8,0xabcd
80002e84:	8f 28       	st.w	r7[0x8],r8
								payload_tx_channel->dword[1] = PAYLOADIDLE1;
80002e86:	30 08       	mov	r8,0
80002e88:	8f 38       	st.w	r7[0xc],r8
								AMBEpayload_tx_state = AMBE_IDLE;
80002e8a:	4b e9       	lddpc	r9,80002f80 <phy_tx_func+0x498>
80002e8c:	93 08       	st.w	r9[0x0],r8
80002e8e:	c6 58       	rjmp	80002f58 <phy_tx_func+0x470>
		
					break;
				
			case AMBE_DE_LAST:
				
					switch (m_RxBurstType)//在发送函数中去做解密处理
80002e90:	4b e8       	lddpc	r8,80002f88 <phy_tx_func+0x4a0>
80002e92:	70 08       	ld.w	r8,r8[0x0]
80002e94:	58 48       	cp.w	r8,4
80002e96:	c0 60       	breq	80002ea2 <phy_tx_func+0x3ba>
80002e98:	c4 53       	brcs	80002f22 <phy_tx_func+0x43a>
80002e9a:	58 98       	cp.w	r8,9
80002e9c:	e0 8b 00 43 	brhi	80002f22 <phy_tx_func+0x43a>
80002ea0:	c2 d8       	rjmp	80002efa <phy_tx_func+0x412>
					{
						case VOICEBURST_A:
							if (VF_SN == 1)
80002ea2:	4b e8       	lddpc	r8,80002f98 <phy_tx_func+0x4b0>
80002ea4:	11 89       	ld.ub	r9,r8[0x0]
80002ea6:	30 18       	mov	r8,1
80002ea8:	f0 09 18 00 	cp.b	r9,r8
80002eac:	c1 31       	brne	80002ed2 <phy_tx_func+0x3ea>
								//if(AMBEBurst_rawdata[1] == Public_AMBEkey[1])//0X1840
								{
								
									//Pick up public key
							
									AMBE_DecryptionKey[1] = AMBEBurst_rawdata[1];
80002eae:	4b d8       	lddpc	r8,80002fa0 <phy_tx_func+0x4b8>
80002eb0:	90 1a       	ld.sh	r10,r8[0x2]
80002eb2:	4b f9       	lddpc	r9,80002fac <phy_tx_func+0x4c4>
80002eb4:	b2 1a       	st.h	r9[0x2],r10
									AMBE_DecryptionKey[2] = AMBEBurst_rawdata[2];
80002eb6:	90 2a       	ld.sh	r10,r8[0x4]
80002eb8:	b2 2a       	st.h	r9[0x4],r10
									AMBE_DecryptionKey[3] = AMBEBurst_rawdata[3];
80002eba:	90 3a       	ld.sh	r10,r8[0x6]
80002ebc:	b2 3a       	st.h	r9[0x6],r10
							
									//Post back data
									payload_tx_channel->word[0] = AMBEBurst_rawdata[1] ;
80002ebe:	90 19       	ld.sh	r9,r8[0x2]
80002ec0:	ae 49       	st.h	r7[0x8],r9
									payload_tx_channel->word[1] = AMBEBurst_rawdata[2] ;
80002ec2:	90 29       	ld.sh	r9,r8[0x4]
80002ec4:	ae 59       	st.h	r7[0xa],r9
									payload_tx_channel->word[2] = AMBEBurst_rawdata[3] ;
80002ec6:	90 38       	ld.sh	r8,r8[0x6]
80002ec8:	ae 68       	st.h	r7[0xc],r8
									payload_tx_channel->word[3] = 0x00BA ;
80002eca:	e0 68 00 ba 	mov	r8,186
80002ece:	ae 78       	st.h	r7[0xe],r8
80002ed0:	c1 18       	rjmp	80002ef2 <phy_tx_func+0x40a>
							{
							
								//Decrypt AMBE data(XOR)
								//Recover data

									payload_tx_channel->word[0] = (AMBEBurst_rawdata[1] ^ AMBE_DecryptionKey[1]);
80002ed2:	4b 48       	lddpc	r8,80002fa0 <phy_tx_func+0x4b8>
80002ed4:	90 1a       	ld.sh	r10,r8[0x2]
80002ed6:	4b 69       	lddpc	r9,80002fac <phy_tx_func+0x4c4>
80002ed8:	92 1b       	ld.sh	r11,r9[0x2]
80002eda:	f7 ea 20 0a 	eor	r10,r11,r10
80002ede:	ae 4a       	st.h	r7[0x8],r10
									payload_tx_channel->word[1] = (AMBEBurst_rawdata[2] ^ AMBE_DecryptionKey[2]);
80002ee0:	90 2a       	ld.sh	r10,r8[0x4]
80002ee2:	92 29       	ld.sh	r9,r9[0x4]
80002ee4:	14 59       	eor	r9,r10
80002ee6:	ae 59       	st.h	r7[0xa],r9
									payload_tx_channel->word[2] = (AMBEBurst_rawdata[3]);
80002ee8:	90 38       	ld.sh	r8,r8[0x6]
80002eea:	ae 68       	st.h	r7[0xc],r8
									
									//payload_tx_channel->word[0] = (AMBEBurst_rawdata[1]);
									//payload_tx_channel->word[1] = (AMBEBurst_rawdata[2]);
									//payload_tx_channel->word[2] = (AMBEBurst_rawdata[3]);
									
									payload_tx_channel->word[3] = 0x00BA ;
80002eec:	e0 68 00 ba 	mov	r8,186
80002ef0:	ae 78       	st.h	r7[0xe],r8
							
							
							}
						
							AMBEpayload_tx_state = AMBE_IDLE;
80002ef2:	30 09       	mov	r9,0
80002ef4:	4a 38       	lddpc	r8,80002f80 <phy_tx_func+0x498>
80002ef6:	91 09       	st.w	r8[0x0],r9
80002ef8:	c3 08       	rjmp	80002f58 <phy_tx_func+0x470>
						
							//Encrypted AMBE data(XOR)
						
							//Decrypt AMBE data(XOR)
							//Recover data
							payload_tx_channel->word[0] = (AMBEBurst_rawdata[1] ^ AMBE_DecryptionKey[1]);
80002efa:	4a a8       	lddpc	r8,80002fa0 <phy_tx_func+0x4b8>
80002efc:	90 1a       	ld.sh	r10,r8[0x2]
80002efe:	4a c9       	lddpc	r9,80002fac <phy_tx_func+0x4c4>
80002f00:	92 1b       	ld.sh	r11,r9[0x2]
80002f02:	f7 ea 20 0a 	eor	r10,r11,r10
80002f06:	ae 4a       	st.h	r7[0x8],r10
							payload_tx_channel->word[1] = (AMBEBurst_rawdata[2] ^ AMBE_DecryptionKey[2]);
80002f08:	90 2a       	ld.sh	r10,r8[0x4]
80002f0a:	92 29       	ld.sh	r9,r9[0x4]
80002f0c:	14 59       	eor	r9,r10
80002f0e:	ae 59       	st.h	r7[0xa],r9
							payload_tx_channel->word[2] = (AMBEBurst_rawdata[3]);
80002f10:	90 38       	ld.sh	r8,r8[0x6]
80002f12:	ae 68       	st.h	r7[0xc],r8
							
							//payload_tx_channel->word[0] = (AMBEBurst_rawdata[1]);
							//payload_tx_channel->word[1] = (AMBEBurst_rawdata[2]);
							//payload_tx_channel->word[2] = (AMBEBurst_rawdata[3]);
							
							payload_tx_channel->word[3] = 0x00BA ;
80002f14:	e0 68 00 ba 	mov	r8,186
80002f18:	ae 78       	st.h	r7[0xe],r8
						
							AMBEpayload_tx_state = AMBE_IDLE;
80002f1a:	30 09       	mov	r9,0
80002f1c:	49 98       	lddpc	r8,80002f80 <phy_tx_func+0x498>
80002f1e:	91 09       	st.w	r8[0x0],r9
80002f20:	c1 c8       	rjmp	80002f58 <phy_tx_func+0x470>
						
							break;
						default://This shouldn't happen, but must check;
						
							payload_tx_channel->dword[0] = PAYLOADIDLE0;
80002f22:	e0 68 5a 5a 	mov	r8,23130
80002f26:	ea 18 ab cd 	orh	r8,0xabcd
80002f2a:	8f 28       	st.w	r7[0x8],r8
							payload_tx_channel->dword[1] = PAYLOADIDLE1;
80002f2c:	30 08       	mov	r8,0
80002f2e:	8f 38       	st.w	r7[0xc],r8
							AMBEpayload_tx_state = AMBE_IDLE;
80002f30:	49 49       	lddpc	r9,80002f80 <phy_tx_func+0x498>
80002f32:	93 08       	st.w	r9[0x0],r8
80002f34:	c1 28       	rjmp	80002f58 <phy_tx_func+0x470>

				break;
		
			default:
			
					payload_tx_channel->dword[0] = PAYLOADIDLE0;
80002f36:	e0 68 5a 5a 	mov	r8,23130
80002f3a:	ea 18 ab cd 	orh	r8,0xabcd
80002f3e:	8f 28       	st.w	r7[0x8],r8
					payload_tx_channel->dword[1] = PAYLOADIDLE1;
80002f40:	30 08       	mov	r8,0
80002f42:	8f 38       	st.w	r7[0xc],r8
					
					AMBEpayload_tx_state = AMBE_IDLE;
80002f44:	48 f9       	lddpc	r9,80002f80 <phy_tx_func+0x498>
80002f46:	93 08       	st.w	r9[0x0],r8
80002f48:	c0 88       	rjmp	80002f58 <phy_tx_func+0x470>

	}//end of Send-AMBE-data

	else
	{
		payload_tx_channel->dword[0] = PAYLOADIDLE0;
80002f4a:	e0 68 5a 5a 	mov	r8,23130
80002f4e:	ea 18 ab cd 	orh	r8,0xabcd
80002f52:	8f 28       	st.w	r7[0x8],r8
		payload_tx_channel->dword[1] = PAYLOADIDLE1;
80002f54:	30 08       	mov	r8,0
80002f56:	8f 38       	st.w	r7[0xc],r8
	#else
	/*send idle frame*/	
	((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
	((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
	#endif /*end if*/
}
80002f58:	2f fd       	sub	sp,-4
80002f5a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002f5e:	00 00       	add	r0,r0
80002f60:	00 00       	add	r0,r0
80002f62:	0a d8       	st.w	--r5,r8
80002f64:	00 00       	add	r0,r0
80002f66:	0a 94       	mov	r4,r5
80002f68:	00 00       	add	r0,r0
80002f6a:	0a ec       	st.h	--r5,r12
80002f6c:	80 00       	ld.sh	r0,r0[0x0]
80002f6e:	52 d4       	stdsp	sp[0xb4],r4
80002f70:	00 00       	add	r0,r0
80002f72:	0a be       	st.h	r5++,lr
80002f74:	00 00       	add	r0,r0
80002f76:	0a 74       	tst	r4,r5
80002f78:	00 00       	add	r0,r0
80002f7a:	0a 5c       	eor	r12,r5
80002f7c:	00 00       	add	r0,r0
80002f7e:	0a e8       	st.h	--r5,r8
80002f80:	00 00       	add	r0,r0
80002f82:	0a 84       	andn	r4,r5
80002f84:	80 00       	ld.sh	r0,r0[0x0]
80002f86:	c9 80       	breq	80002eb6 <phy_tx_func+0x3ce>
80002f88:	00 00       	add	r0,r0
80002f8a:	0a dc       	st.w	--r5,r12
80002f8c:	00 00       	add	r0,r0
80002f8e:	0a 9c       	mov	r12,r5
80002f90:	00 00       	add	r0,r0
80002f92:	0d 98       	ld.ub	r8,r6[0x1]
80002f94:	00 00       	add	r0,r0
80002f96:	0e 94       	mov	r4,r7
80002f98:	00 00       	add	r0,r0
80002f9a:	0a 5d       	eor	sp,r5
80002f9c:	80 00       	ld.sh	r0,r0[0x0]
80002f9e:	c9 22       	brcc	80002ec2 <phy_tx_func+0x3da>
80002fa0:	00 00       	add	r0,r0
80002fa2:	0d 90       	ld.ub	r0,r6[0x1]
80002fa4:	00 00       	add	r0,r0
80002fa6:	0a e0       	st.h	--r5,r0
80002fa8:	00 00       	add	r0,r0
80002faa:	0e 98       	mov	r8,r7
80002fac:	00 00       	add	r0,r0
80002fae:	0d 9c       	ld.ub	r12,r6[0x1]

80002fb0 <get_idle_store>:
	}//End of RxMedia Phy Handler.
}
#endif /*end if*/

void * get_idle_store(xQueueHandle store)
{
80002fb0:	d4 01       	pushm	lr
80002fb2:	20 1d       	sub	sp,4
	void * ptr = NULL;
80002fb4:	30 0a       	mov	r10,0
80002fb6:	fa cb ff fc 	sub	r11,sp,-4
80002fba:	16 da       	st.w	--r11,r10

	if(pdTRUE == xQueueReceive(store, &ptr, 0))
80002fbc:	14 99       	mov	r9,r10
80002fbe:	1a 9b       	mov	r11,sp
80002fc0:	f0 1f 00 05 	mcall	80002fd4 <get_idle_store+0x24>
80002fc4:	58 1c       	cp.w	r12,1
80002fc6:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80002fca:	fb fc 00 00 	ld.weq	r12,sp[0x0]
	}
	else
	{
		return NULL;
	}
}
80002fce:	2f fd       	sub	sp,-4
80002fd0:	d8 02       	popm	pc
80002fd2:	00 00       	add	r0,r0
80002fd4:	80 00       	ld.sh	r0,r0[0x0]
80002fd6:	53 c4       	stdsp	sp[0xf0],r4

80002fd8 <phy_init>:
    register_rx_tx_func -- ssc.c
	xQueueCreate -- freertos
Called By: xnl_init -- xnl.c
*/
void phy_init( void )
{
80002fd8:	d4 01       	pushm	lr
    /*register the func to send/receive ssc packet*/
    register_rx_tx_func(phy_rx_func, phy_tx_func);	
80002fda:	48 5b       	lddpc	r11,80002fec <phy_init+0x14>
80002fdc:	48 5c       	lddpc	r12,80002ff0 <phy_init+0x18>
80002fde:	f0 1f 00 06 	mcall	80002ff4 <phy_init+0x1c>
	
	/*initialize the SSC*/
	ssc_init();
80002fe2:	f0 1f 00 06 	mcall	80002ff8 <phy_init+0x20>
	
	/*send device_master_query to connect radio*/
	xnl_send_device_master_query();
80002fe6:	f0 1f 00 06 	mcall	80002ffc <phy_init+0x24>
	
}
80002fea:	d8 02       	popm	pc
80002fec:	80 00       	ld.sh	r0,r0[0x0]
80002fee:	2a e8       	sub	r8,-82
80002ff0:	80 00       	ld.sh	r0,r0[0x0]
80002ff2:	30 60       	mov	r0,6
80002ff4:	80 00       	ld.sh	r0,r0[0x0]
80002ff6:	40 a8       	lddsp	r8,sp[0x28]
80002ff8:	80 00       	ld.sh	r0,r0[0x0]
80002ffa:	40 bc       	lddsp	r12,sp[0x2c]
80002ffc:	80 00       	ld.sh	r0,r0[0x0]
80002ffe:	4a 58       	lddpc	r8,80003090 <phy_rx_func+0x30>

80003000 <payload_rx>:
		//logFromISR("ss");
	}
}

static void payload_rx(void * payload)
{
80003000:	d4 01       	pushm	lr
80003002:	20 2d       	sub	sp,8
80003004:	50 0c       	stdsp	sp[0x0],r12
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80003006:	30 08       	mov	r8,0
80003008:	50 18       	stdsp	sp[0x4],r8
	
	if(NULL == phy_payload_frame_rx)
8000300a:	48 f8       	lddpc	r8,80003044 <payload_rx+0x44>
8000300c:	70 08       	ld.w	r8,r8[0x0]
8000300e:	58 08       	cp.w	r8,0
80003010:	c0 71       	brne	8000301e <payload_rx+0x1e>
	{
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));		
80003012:	30 4b       	mov	r11,4
80003014:	30 5c       	mov	r12,5
80003016:	f0 1f 00 0d 	mcall	80003048 <payload_rx+0x48>
8000301a:	48 b8       	lddpc	r8,80003044 <payload_rx+0x44>
8000301c:	91 0c       	st.w	r8[0x0],r12
	}

	if(errQUEUE_FULL == xQueueSendFromISR(phy_payload_frame_rx, &payload, &xHigherPriorityTaskWoken))
8000301e:	48 a8       	lddpc	r8,80003044 <payload_rx+0x44>
80003020:	70 0c       	ld.w	r12,r8[0x0]
80003022:	30 09       	mov	r9,0
80003024:	fa ca ff fc 	sub	r10,sp,-4
80003028:	1a 9b       	mov	r11,sp
8000302a:	f0 1f 00 09 	mcall	8000304c <payload_rx+0x4c>
8000302e:	c0 91       	brne	80003040 <payload_rx+0x40>
	{
		
		set_payload_idle_isr(payload);
80003030:	48 88       	lddpc	r8,80003050 <payload_rx+0x50>
80003032:	70 0c       	ld.w	r12,r8[0x0]
80003034:	40 0b       	lddsp	r11,sp[0x0]
80003036:	f0 1f 00 08 	mcall	80003054 <payload_rx+0x54>
		logFromISR("mm");
8000303a:	48 8c       	lddpc	r12,80003058 <payload_rx+0x58>
8000303c:	f0 1f 00 08 	mcall	8000305c <payload_rx+0x5c>
	}
	else
	{
		//logFromISR("ss");
	}
}
80003040:	2f ed       	sub	sp,-8
80003042:	d8 02       	popm	pc
80003044:	00 00       	add	r0,r0
80003046:	0a 80       	andn	r0,r5
80003048:	80 00       	ld.sh	r0,r0[0x0]
8000304a:	56 d0       	stdsp	sp[0x1b4],r0
8000304c:	80 00       	ld.sh	r0,r0[0x0]
8000304e:	55 80       	stdsp	sp[0x160],r0
80003050:	00 00       	add	r0,r0
80003052:	0a b0       	st.h	r5++,r0
80003054:	80 00       	ld.sh	r0,r0[0x0]
80003056:	29 f0       	sub	r0,-97
80003058:	80 00       	ld.sh	r0,r0[0x0]
8000305a:	c9 9c       	rcall	8000318c <phy_rx_func+0x12c>
8000305c:	80 00       	ld.sh	r0,r0[0x0]
8000305e:	62 f4       	ld.w	r4,r1[0x3c]

80003060 <phy_rx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_rx_func( void * ssc)
{    
80003060:	eb cd 40 e0 	pushm	r5-r7,lr
80003064:	18 97       	mov	r7,r12
		
	if(NULL != phy_xnl_frame_rx)
80003066:	fe f8 0e 7a 	ld.w	r8,pc[3706]
8000306a:	70 08       	ld.w	r8,r8[0x0]
8000306c:	58 08       	cp.w	r8,0
8000306e:	e0 80 01 08 	breq	8000327e <phy_rx_func+0x21e>
	static U16 phy_check_sum = 0;

	static phy_rx_state_t  phy_rx_state = WAITING_FOR_HEADER;
	static U32 phy_rx_count = 0;

	U32 phy_dword = xnl_rx_channel->dword;	
80003072:	78 16       	ld.w	r6,r12[0x4]

	phy_rx_count++;
80003074:	fe f8 0e 70 	ld.w	r8,pc[3696]
80003078:	70 09       	ld.w	r9,r8[0x0]
8000307a:	2f f9       	sub	r9,-1
8000307c:	91 09       	st.w	r8[0x0],r9
	
	/*This is the code for parsing the incoming physical message.*/
	switch (phy_rx_state)
8000307e:	fe f8 0e 6a 	ld.w	r8,pc[3690]
80003082:	70 08       	ld.w	r8,r8[0x0]
80003084:	58 18       	cp.w	r8,1
80003086:	e0 80 00 85 	breq	80003190 <phy_rx_func+0x130>
8000308a:	c0 73       	brcs	80003098 <phy_rx_func+0x38>
8000308c:	58 28       	cp.w	r8,2
8000308e:	c5 c0       	breq	80003146 <phy_rx_func+0xe6>
80003090:	58 38       	cp.w	r8,3
80003092:	e0 81 00 f6 	brne	8000327e <phy_rx_func+0x21e>
80003096:	cd 58       	rjmp	80003240 <phy_rx_func+0x1e0>

        /*Waiting for something. Most frequent visit.*/		
		case WAITING_FOR_HEADER:
		
			/*Ignore Idles.*/
			if (0xABCD5A5A == phy_dword)
80003098:	e0 6a 5a 5a 	mov	r10,23130
8000309c:	ea 1a ab cd 	orh	r10,0xabcd
800030a0:	14 36       	cp.w	r6,r10
800030a2:	e0 80 00 ee 	breq	8000327e <phy_rx_func+0x21e>
			{
				break;
			}	

			/*Skip until Header.*/		
			if (0xABCD != (phy_dword >> 16))
800030a6:	ec 08 16 10 	lsr	r8,r6,0x10
800030aa:	e0 48 ab cd 	cp.w	r8,43981
800030ae:	e0 81 00 e8 	brne	8000327e <phy_rx_func+0x21e>
			{			
				break;
			}
		
			/*Length excluding CSUM.*/
			phy_rx_expexted_length = (phy_dword & 0x000000FF) - 2;
800030b2:	eb d6 b0 10 	bfexts	r5,r6,0x0,0x10
800030b6:	f1 d5 c0 08 	bfextu	r8,r5,0x0,0x8
800030ba:	20 28       	sub	r8,2
800030bc:	fe f9 0e 30 	ld.w	r9,pc[3632]
800030c0:	b2 08       	st.h	r9[0x0],r8
			
			/*Discard degenerate message.*/
			if (phy_rx_expexted_length <= 0)
800030c2:	30 09       	mov	r9,0
800030c4:	f2 08 19 00 	cp.h	r8,r9
800030c8:	e0 8a 00 db 	brle	8000327e <phy_rx_func+0x21e>
			{
				break;
			}
		
			phy_rx_length = 0;
800030cc:	fe f8 0e 24 	ld.w	r8,pc[3620]
800030d0:	b0 09       	st.h	r8[0x0],r9

			phy_frame_ptr = get_xnl_idle_isr();
800030d2:	fe f8 0e 22 	ld.w	r8,pc[3618]
800030d6:	70 0c       	ld.w	r12,r8[0x0]
800030d8:	f0 1f 03 88 	mcall	80003ef8 <phy_rx_func+0xe98>
800030dc:	fe f8 0e 20 	ld.w	r8,pc[3616]
800030e0:	91 0c       	st.w	r8[0x0],r12
			if(NULL == phy_frame_ptr)
800030e2:	58 0c       	cp.w	r12,0
800030e4:	e0 80 00 cd 	breq	8000327e <phy_rx_func+0x21e>
			{
				break;
			}
					
			phy_frame_ptr->fragment_element[phy_rx_length++] = phy_dword;
800030e8:	fe f8 0e 08 	ld.w	r8,pc[3592]
800030ec:	90 09       	ld.sh	r9,r8[0x0]
800030ee:	f8 09 0a 15 	st.h	r12[r9<<0x1],r5
800030f2:	2f f9       	sub	r9,-1
800030f4:	5c 89       	casts.h	r9
			
			/*time stamp*/
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
800030f6:	fe fa 0e 06 	ld.w	r10,pc[3590]
800030fa:	74 0a       	ld.w	r10,r10[0x0]
800030fc:	fe fb 0d e8 	ld.w	r11,pc[3560]
80003100:	76 0b       	ld.w	r11,r11[0x0]
80003102:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
80003106:	2f f9       	sub	r9,-1
80003108:	b0 09       	st.h	r8[0x0],r9
													(phy_rx_count) & 0x0000FFFF;
			
			/*This switch tests the fragment type, and adjusts receiver state
			accordingly.*/
			/*Check frag type*/
			switch (phy_dword & 0x00000F00)
8000310a:	e2 16 0f 00 	andl	r6,0xf00,COH
8000310e:	e0 46 01 00 	cp.w	r6,256
80003112:	c0 c0       	breq	8000312a <phy_rx_func+0xca>
80003114:	e0 8b 00 05 	brhi	8000311e <phy_rx_func+0xbe>
80003118:	58 06       	cp.w	r6,0
8000311a:	c0 80       	breq	8000312a <phy_rx_func+0xca>
8000311c:	c0 c8       	rjmp	80003134 <phy_rx_func+0xd4>
8000311e:	e0 46 02 00 	cp.w	r6,512
80003122:	c0 40       	breq	8000312a <phy_rx_func+0xca>
80003124:	e0 46 03 00 	cp.w	r6,768
80003128:	c0 61       	brne	80003134 <phy_rx_func+0xd4>
			{
				case SINGLE_FRAGMENT:  //Only Fragment.
				case FIRST_FRAGMENT:   //First of Multi-fragment.
				case MIDDLE_FRAGMENT:  //Continuing Multi-fragment.
				case LAST_FRAGMENT:    //Last Multi-fragment.
					phy_rx_state = WAITING_CHECK_SUM;
8000312a:	30 29       	mov	r9,2
8000312c:	fe f8 0d bc 	ld.w	r8,pc[3516]
80003130:	91 09       	st.w	r8[0x0],r9
80003132:	ca 68       	rjmp	8000327e <phy_rx_func+0x21e>
				break;
				default:
					set_xnl_idle_isr(phy_frame_ptr);			
80003134:	fe f8 0d c0 	ld.w	r8,pc[3520]
80003138:	70 0c       	ld.w	r12,r8[0x0]
8000313a:	fe f8 0d c2 	ld.w	r8,pc[3522]
8000313e:	70 0b       	ld.w	r11,r8[0x0]
80003140:	f0 1f 03 70 	mcall	80003f00 <phy_rx_func+0xea0>
80003144:	c9 d8       	rjmp	8000327e <phy_rx_func+0x21e>
		
			/*Stores CSUM*/
			phy_check_sum  = (phy_dword & 0xFFFF0000) >> 16;
			
			/*sums in first hWord*/
			phy_check_sum += (phy_dword & 0x0000FFFF);		
80003146:	f5 d6 b0 10 	bfexts	r10,r6,0x0,0x10
8000314a:	b1 86       	lsr	r6,0x10
8000314c:	14 06       	add	r6,r10
8000314e:	fe f8 0d b6 	ld.w	r8,pc[3510]
80003152:	b0 06       	st.h	r8[0x0],r6
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
80003154:	fe f8 0d 9c 	ld.w	r8,pc[3484]
80003158:	90 09       	ld.sh	r9,r8[0x0]
8000315a:	fe fb 0d a2 	ld.w	r11,pc[3490]
8000315e:	76 0b       	ld.w	r11,r11[0x0]
80003160:	f6 09 0a 1a 	st.h	r11[r9<<0x1],r10
80003164:	2f f9       	sub	r9,-1
80003166:	b0 09       	st.h	r8[0x0],r9
														 phy_dword & 0x0000FFFF;
					
			phy_rx_expexted_length -= 2;
80003168:	fe f9 0d 84 	ld.w	r9,pc[3460]
8000316c:	92 08       	ld.sh	r8,r9[0x0]
8000316e:	20 28       	sub	r8,2
80003170:	b2 08       	st.h	r9[0x0],r8
			
			/*Normal case for greater than one byte payloads.*/
			if (phy_rx_expexted_length > 0)
80003172:	30 09       	mov	r9,0
80003174:	f2 08 19 00 	cp.h	r8,r9
80003178:	e0 8a 00 07 	brle	80003186 <phy_rx_func+0x126>
			{					  
				phy_rx_state = READING_FRAGMENT;
8000317c:	30 19       	mov	r9,1
8000317e:	fe f8 0d 6a 	ld.w	r8,pc[3434]
80003182:	91 09       	st.w	r8[0x0],r9
80003184:	c7 d8       	rjmp	8000327e <phy_rx_func+0x21e>
	    		Note that all segments must align with a 32-bit boundary and
				beginning of each XCMP/XNL payload frame must start on slot 3
				Thus, segments of odd length must append a 0x0000 at the end
				(slot 4) to ensure alignment. [9.1.3]
				*/
				phy_rx_state = WAITING_LAST_TERM;
80003186:	30 39       	mov	r9,3
80003188:	fe f8 0d 60 	ld.w	r8,pc[3424]
8000318c:	91 09       	st.w	r8[0x0],r9
8000318e:	c7 88       	rjmp	8000327e <phy_rx_func+0x21e>
			}			
		
			break;

		case READING_FRAGMENT:
			phy_check_sum += (phy_dword & 0xFFFF0000) >> 16;
80003190:	ec 0a 14 10 	asr	r10,r6,0x10
80003194:	fe f8 0d 70 	ld.w	r8,pc[3440]
80003198:	90 09       	ld.sh	r9,r8[0x0]
8000319a:	14 09       	add	r9,r10
8000319c:	b0 09       	st.h	r8[0x0],r9
	
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
8000319e:	fe f9 0d 52 	ld.w	r9,pc[3410]
800031a2:	92 08       	ld.sh	r8,r9[0x0]
800031a4:	fe fb 0d 58 	ld.w	r11,pc[3416]
800031a8:	76 0b       	ld.w	r11,r11[0x0]
800031aa:	f6 08 0a 1a 	st.h	r11[r8<<0x1],r10
800031ae:	2f f8       	sub	r8,-1
800031b0:	5c 88       	casts.h	r8
800031b2:	b2 08       	st.h	r9[0x0],r8
												 (phy_dword & 0xFFFF0000) >> 16;
	
			phy_rx_expexted_length -= 2;
800031b4:	fe fa 0d 38 	ld.w	r10,pc[3384]
800031b8:	94 09       	ld.sh	r9,r10[0x0]
800031ba:	20 29       	sub	r9,2
800031bc:	b4 09       	st.h	r10[0x0],r9
			if (phy_rx_expexted_length <= 0)
800031be:	30 0a       	mov	r10,0
800031c0:	f4 09 19 00 	cp.h	r9,r10
800031c4:	e0 89 00 20 	brgt	80003204 <phy_rx_func+0x1a4>
				Terminator should be in 2nd hWord.
				Shaoqun says useful bits not used. The packet will always end
				with $00BA. [9.1.2.8]	
				*/
				
				if ((0x000000BA == (phy_dword  & 0x0000FFFF)) 
800031c8:	ed d6 c0 10 	bfextu	r6,r6,0x0,0x10
800031cc:	e0 46 00 ba 	cp.w	r6,186
800031d0:	c0 d1       	brne	800031ea <phy_rx_func+0x18a>
800031d2:	fe f8 0d 32 	ld.w	r8,pc[3378]
800031d6:	90 09       	ld.sh	r9,r8[0x0]
800031d8:	f4 09 19 00 	cp.h	r9,r10
800031dc:	c0 71       	brne	800031ea <phy_rx_func+0x18a>
					&& (phy_check_sum == 0))
				{
					phy_rx(phy_frame_ptr);
800031de:	fe f8 0d 1e 	ld.w	r8,pc[3358]
800031e2:	70 0c       	ld.w	r12,r8[0x0]
800031e4:	f0 1f 03 49 	mcall	80003f08 <phy_rx_func+0xea8>
800031e8:	c0 98       	rjmp	800031fa <phy_rx_func+0x19a>
				}
				else
				{
					set_xnl_idle_isr(phy_frame_ptr);
800031ea:	fe f8 0d 0a 	ld.w	r8,pc[3338]
800031ee:	70 0c       	ld.w	r12,r8[0x0]
800031f0:	fe f8 0d 0c 	ld.w	r8,pc[3340]
800031f4:	70 0b       	ld.w	r11,r8[0x0]
800031f6:	f0 1f 03 43 	mcall	80003f00 <phy_rx_func+0xea0>
				}

				phy_rx_state = WAITING_FOR_HEADER;
800031fa:	30 09       	mov	r9,0
800031fc:	fe f8 0c ec 	ld.w	r8,pc[3308]
80003200:	91 09       	st.w	r8[0x0],r9
80003202:	c3 e8       	rjmp	8000327e <phy_rx_func+0x21e>
				break;
			}
		
			/*Have not broken. 2nd hWord contains payload.*/
			phy_check_sum += (phy_dword & 0x0000FFFF);
80003204:	5c 86       	casts.h	r6
80003206:	fe f9 0c fe 	ld.w	r9,pc[3326]
8000320a:	92 0a       	ld.sh	r10,r9[0x0]
8000320c:	0c 0a       	add	r10,r6
8000320e:	b2 0a       	st.h	r9[0x0],r10
		
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
80003210:	fe f9 0c ec 	ld.w	r9,pc[3308]
80003214:	72 09       	ld.w	r9,r9[0x0]
80003216:	f2 08 0a 16 	st.h	r9[r8<<0x1],r6
8000321a:	2f f8       	sub	r8,-1
8000321c:	fe f9 0c d4 	ld.w	r9,pc[3284]
80003220:	b2 08       	st.h	r9[0x0],r8
													   (phy_dword & 0x0000FFFF);
		
			phy_rx_expexted_length -= 2;
80003222:	fe f9 0c ca 	ld.w	r9,pc[3274]
80003226:	92 08       	ld.sh	r8,r9[0x0]
80003228:	20 28       	sub	r8,2
8000322a:	b2 08       	st.h	r9[0x0],r8
			if (phy_rx_expexted_length <= 0)
8000322c:	30 09       	mov	r9,0
8000322e:	f2 08 19 00 	cp.h	r8,r9
80003232:	e0 89 00 26 	brgt	8000327e <phy_rx_func+0x21e>
			{
				/*All read in. Next Word should be 0x00BA0000.*/
				phy_rx_state = WAITING_LAST_TERM;
80003236:	30 39       	mov	r9,3
80003238:	fe f8 0c b0 	ld.w	r8,pc[3248]
8000323c:	91 09       	st.w	r8[0x0],r9
8000323e:	c2 08       	rjmp	8000327e <phy_rx_func+0x21e>
			}/*else, next Word contains more payload.*/
			break;

		/*Expecting last terminator 0x00BA0000.*/	
		case WAITING_LAST_TERM:			
			if ((0x00BA0000 == (phy_dword  & 0x00FF0000)) /*Expected found.*/
80003240:	e6 16 00 ff 	andh	r6,0xff,COH
80003244:	fc 19 00 ba 	movh	r9,0xba
80003248:	12 36       	cp.w	r6,r9
8000324a:	c0 e1       	brne	80003266 <phy_rx_func+0x206>
8000324c:	fe f8 0c b8 	ld.w	r8,pc[3256]
80003250:	90 09       	ld.sh	r9,r8[0x0]
80003252:	30 08       	mov	r8,0
80003254:	f0 09 19 00 	cp.h	r9,r8
80003258:	c0 71       	brne	80003266 <phy_rx_func+0x206>
				&& (phy_check_sum == 0))/*Good checksum*/
			{
				phy_rx(phy_frame_ptr);
8000325a:	fe f8 0c a2 	ld.w	r8,pc[3234]
8000325e:	70 0c       	ld.w	r12,r8[0x0]
80003260:	f0 1f 03 2a 	mcall	80003f08 <phy_rx_func+0xea8>
80003264:	c0 98       	rjmp	80003276 <phy_rx_func+0x216>

			}
			else
			{
				set_xnl_idle_isr(phy_frame_ptr);
80003266:	fe f8 0c 8e 	ld.w	r8,pc[3214]
8000326a:	70 0c       	ld.w	r12,r8[0x0]
8000326c:	fe f8 0c 90 	ld.w	r8,pc[3216]
80003270:	70 0b       	ld.w	r11,r8[0x0]
80003272:	f0 1f 03 24 	mcall	80003f00 <phy_rx_func+0xea0>
			}
				
			phy_rx_state = WAITING_FOR_HEADER;
80003276:	30 09       	mov	r9,0
80003278:	fe f8 0c 70 	ld.w	r8,pc[3184]
8000327c:	91 09       	st.w	r8[0x0],r9
	static U8 _flag = 1;//0xABCDC014时，_flag为0；
						//0xABCDC010时，_flag为1；
			
	//payload_ptr_t *AMBE_payload_ptr;		
	
	if(is_first == FALSE)
8000327e:	fe f8 0c 8e 	ld.w	r8,pc[3214]
80003282:	11 89       	ld.ub	r9,r8[0x0]
80003284:	30 08       	mov	r8,0
80003286:	f0 09 18 00 	cp.b	r9,r8
8000328a:	c1 31       	brne	800032b0 <phy_rx_func+0x250>
	{
		payload_ptr = get_payload_idle_isr();
8000328c:	fe f6 0c 84 	ld.w	r6,pc[3204]
80003290:	6c 0c       	ld.w	r12,r6[0x0]
80003292:	f0 1f 03 1a 	mcall	80003ef8 <phy_rx_func+0xe98>
80003296:	fe f8 0c 7e 	ld.w	r8,pc[3198]
8000329a:	91 0c       	st.w	r8[0x0],r12
		AMBE_payload_ptr = get_payload_idle_isr();
8000329c:	6c 0c       	ld.w	r12,r6[0x0]
8000329e:	f0 1f 03 17 	mcall	80003ef8 <phy_rx_func+0xe98>
800032a2:	fe f8 0c 76 	ld.w	r8,pc[3190]
800032a6:	91 0c       	st.w	r8[0x0],r12
		is_first = TRUE;
800032a8:	30 19       	mov	r9,1
800032aa:	fe f8 0c 62 	ld.w	r8,pc[3170]
800032ae:	b0 89       	st.b	r8[0x0],r9
	}	
	
	//This is the RxMedia Phy Handler.
	switch (RxMediaState)
800032b0:	fe f8 0c 6c 	ld.w	r8,pc[3180]
800032b4:	70 08       	ld.w	r8,r8[0x0]
800032b6:	58 28       	cp.w	r8,2
800032b8:	e0 80 01 98 	breq	800035e8 <phy_rx_func+0x588>
800032bc:	e0 8b 00 06 	brhi	800032c8 <phy_rx_func+0x268>
800032c0:	58 08       	cp.w	r8,0
800032c2:	c0 b0       	breq	800032d8 <phy_rx_func+0x278>
800032c4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800032c8:	58 38       	cp.w	r8,3
800032ca:	e0 80 05 c5 	breq	80003e54 <phy_rx_func+0xdf4>
800032ce:	58 48       	cp.w	r8,4
800032d0:	e0 81 06 05 	brne	80003eda <phy_rx_func+0xe7a>
800032d4:	e0 8f 02 4b 	bral	8000376a <phy_rx_func+0x70a>
	{
		case WAITINGABAB:

			
			if (payload_rx_channel->dword[0] == 0xABCD5A5A)//Ignore Idles.
800032d8:	6e 28       	ld.w	r8,r7[0x8]
800032da:	e0 6a 5a 5a 	mov	r10,23130
800032de:	ea 1a ab cd 	orh	r10,0xabcd
800032e2:	14 38       	cp.w	r8,r10
800032e4:	c0 71       	brne	800032f2 <phy_rx_func+0x292>
			{
				m_RxBurstType = VOICE_WATING;
800032e6:	30 09       	mov	r9,0
800032e8:	fe f8 0c 38 	ld.w	r8,pc[3128]
800032ec:	91 09       	st.w	r8[0x0],r9
800032ee:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
				//Upon receiving the idle frame, the m Rx Burst Type into an idle state in order to transmit the synchronization wait
				 break; 
			}
            
			if ((payload_rx_channel->dword[0]  & 0xFFFF0000) != 0xABCD0000)break; //Skip until Header. 
800032f2:	10 99       	mov	r9,r8
800032f4:	e0 19 00 00 	andl	r9,0x0
800032f8:	fc 1a ab cd 	movh	r10,0xabcd
800032fc:	14 39       	cp.w	r9,r10
800032fe:	e0 81 05 ee 	brne	80003eda <phy_rx_func+0xe7a>
			}
			//logFromISR("\n\r P: %X \n\r", payload_rx_channel->word[1]);//测试收到的数据
			
#endif
			
			RxBytesWaiting = payload_rx_channel->dword[0] & 0x000000FF;
80003302:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
80003306:	fe f9 0c 1e 	ld.w	r9,pc[3102]
8000330a:	93 08       	st.w	r9[0x0],r8
			/****Note AMBE stream protocol frame structure and the PCM frame structure is different*****/
					
			if ((payload_rx_channel->dword[0] & 0x0000F000 ) == PAYLOAD_DATA_ENH )//PAYLOAD_DATA_ENH (0x0c))
8000330c:	6e 29       	ld.w	r9,r7[0x8]
8000330e:	e2 19 f0 00 	andl	r9,0xf000,COH
80003312:	e0 49 c0 00 	cp.w	r9,49152
80003316:	e0 81 00 ce 	brne	800034b2 <phy_rx_func+0x452>
			{
				AMBE_Media = 1;	
8000331a:	30 1a       	mov	r10,1
8000331c:	fe f9 0c 0c 	ld.w	r9,pc[3084]
80003320:	b2 8a       	st.b	r9[0x0],r10
				
				if (NULL== AMBE_payload_ptr){
80003322:	fe f9 0b f6 	ld.w	r9,pc[3062]
80003326:	72 09       	ld.w	r9,r9[0x0]
80003328:	58 09       	cp.w	r9,0
8000332a:	c0 71       	brne	80003338 <phy_rx_func+0x2d8>
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//测试是否有这种情况出现
8000332c:	fe fc 0c 00 	ld.w	r12,pc[3072]
80003330:	f0 1f 03 00 	mcall	80003f30 <phy_rx_func+0xed0>
80003334:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
																	
				Item_ID = payload_rx_channel->byte[5];
80003338:	ef 3a 00 0d 	ld.ub	r10,r7[13]
8000333c:	fe f9 0b f8 	ld.w	r9,pc[3064]
80003340:	b2 8a       	st.b	r9[0x0],r10
				
				Item_Length = (payload_rx_channel->byte[4] & 0x7F);//7bits
80003342:	ef 3b 00 0c 	ld.ub	r11,r7[12]
80003346:	f7 db c0 07 	bfextu	r11,r11,0x0,0x7
8000334a:	fe fa 0b ee 	ld.w	r10,pc[3054]
8000334e:	95 0b       	st.w	r10[0x0],r11
								
				switch(Item_ID)
80003350:	13 89       	ld.ub	r9,r9[0x0]
80003352:	37 fa       	mov	r10,127
80003354:	f4 09 18 00 	cp.b	r9,r10
80003358:	c6 d0       	breq	80003432 <phy_rx_func+0x3d2>
8000335a:	e0 8b 00 0c 	brhi	80003372 <phy_rx_func+0x312>
8000335e:	31 2a       	mov	r10,18
80003360:	f4 09 18 00 	cp.b	r9,r10
80003364:	c4 20       	breq	800033e8 <phy_rx_func+0x388>
80003366:	31 3a       	mov	r10,19
80003368:	f4 09 18 00 	cp.b	r9,r10
8000336c:	e0 81 00 83 	brne	80003472 <phy_rx_func+0x412>
80003370:	c5 b8       	rjmp	80003426 <phy_rx_func+0x3c6>
80003372:	2f 09       	sub	r9,-16
80003374:	30 1a       	mov	r10,1
80003376:	f4 09 18 00 	cp.b	r9,r10
8000337a:	e0 8b 00 7c 	brhi	80003472 <phy_rx_func+0x412>
					//The OB know the Call begin and discard the Voice Header
					//The OB know the Call end and discard the Voice  Terminator
					case Raw_Tx_Data_HT://0xF0
					case Raw_Rx_Data_HT://0xF1
					
							if ((payload_rx_channel->byte[6] & 0xF0 )== 0x10)//header
8000337e:	ef 38 00 0e 	ld.ub	r8,r7[14]
80003382:	e2 18 00 f0 	andl	r8,0xf0,COH
80003386:	59 08       	cp.w	r8,16
80003388:	c0 71       	brne	80003396 <phy_rx_func+0x336>
							{
								m_RxBurstType = VOICEHEADER;
8000338a:	30 19       	mov	r9,1
8000338c:	fe f8 0b 94 	ld.w	r8,pc[2964]
80003390:	91 09       	st.w	r8[0x0],r9
80003392:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

							}
							else if ((payload_rx_channel->byte[6] & 0xF0) == 0x20)//Terminator
80003396:	e0 48 00 20 	cp.w	r8,32
8000339a:	c2 11       	brne	800033dc <phy_rx_func+0x37c>
							{
								m_RxBurstType = VOICETERMINATOR;
8000339c:	30 a9       	mov	r9,10
8000339e:	fe f8 0b 82 	ld.w	r8,pc[2946]
800033a2:	91 09       	st.w	r8[0x0],r9
								//AMBE-data and PCM-data is not the same. AMBE is compressed data,
								//if there was a missing portion, a clear voice is difficult to extract the data.
								//It must ensure that all the data received AMBE.
								
								//注意！！！考虑是否需要把剩余的空间置0。
								memset((AMBE_payload_ptr+ (RxAMBE_IsFillingNext8 +1)), 0x00, (512-(RxAMBE_IsFillingNext8 + 1)));
800033a4:	fe f6 0b 98 	ld.w	r6,pc[2968]
800033a8:	6c 08       	ld.w	r8,r6[0x0]
800033aa:	f0 0a 11 ff 	rsub	r10,r8,-1
800033ae:	fe f7 0b 6a 	ld.w	r7,pc[2922]
800033b2:	2f f8       	sub	r8,-1
800033b4:	6e 0c       	ld.w	r12,r7[0x0]
800033b6:	f4 ca fe 00 	sub	r10,r10,-512
800033ba:	30 0b       	mov	r11,0
800033bc:	10 0c       	add	r12,r8
800033be:	f0 1f 02 e1 	mcall	80003f40 <phy_rx_func+0xee0>
								
								RxAMBE_IsFillingNext8 = 0;
800033c2:	30 08       	mov	r8,0
800033c4:	8d 08       	st.w	r6[0x0],r8
								payload_rx(AMBE_payload_ptr);
800033c6:	6e 0c       	ld.w	r12,r7[0x0]
800033c8:	f0 1f 02 df 	mcall	80003f44 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
800033cc:	fe f8 0b 44 	ld.w	r8,pc[2884]
800033d0:	70 0c       	ld.w	r12,r8[0x0]
800033d2:	f0 1f 02 ca 	mcall	80003ef8 <phy_rx_func+0xe98>
800033d6:	8f 0c       	st.w	r7[0x0],r12
800033d8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								//logFromISR("\n\r QQ1 \n\r");
								
							}
							else//error voice
							{
								m_RxBurstType = VOICE_WATING;
800033dc:	30 09       	mov	r9,0
800033de:	fe f8 0b 42 	ld.w	r8,pc[2882]
800033e2:	91 09       	st.w	r8[0x0],r9
800033e4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;//WAITINGABAB.
					
		
					case Vocoder_Bit_Stream_Parameter://0x12
							
							if ((RxBytesWaiting -= 4) <= 0) break;
800033e8:	20 48       	sub	r8,4
800033ea:	fe f9 0b 3a 	ld.w	r9,pc[2874]
800033ee:	93 08       	st.w	r9[0x0],r8
800033f0:	58 08       	cp.w	r8,0
800033f2:	e0 80 05 74 	breq	80003eda <phy_rx_func+0xe7a>
					
							//Vocoder Bits Stream Parameter
							VF_SN = (payload_rx_channel->byte[7] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
800033f6:	ef 3c 00 0f 	ld.ub	r12,r7[15]
800033fa:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
800033fe:	fe f8 0b 4a 	ld.w	r8,pc[2890]
80003402:	b0 8c       	st.b	r8[0x0],r12
							
							VBSP_data[0] = payload_rx_channel->word[2];
80003404:	8e 69       	ld.sh	r9,r7[0xc]
80003406:	fe f8 0b 46 	ld.w	r8,pc[2886]
8000340a:	b0 09       	st.h	r8[0x0],r9
							VBSP_data[1] = payload_rx_channel->word[3];
8000340c:	8e 79       	ld.sh	r9,r7[0xe]
8000340e:	b0 19       	st.h	r8[0x2],r9
							
							m_RxBurstType = CalculateBurst(VF_SN);
80003410:	f0 1f 02 d0 	mcall	80003f50 <phy_rx_func+0xef0>
80003414:	fe f8 0b 0c 	ld.w	r8,pc[2828]
80003418:	91 0c       	st.w	r8[0x0],r12
							
							RxMediaState = READING_AMBE_MEDIA;//Jump
8000341a:	30 49       	mov	r9,4
8000341c:	fe f8 0b 00 	ld.w	r8,pc[2816]
80003420:	91 09       	st.w	r8[0x0],r9
80003422:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							
					//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
					// or discard it to reduce payload size.	
					//This shouldn't happen, but must check.	
					case Soft_Decision_Value://0x13
						m_RxBurstType = VOICE_WATING;
80003426:	30 09       	mov	r9,0
80003428:	fe f8 0a f8 	ld.w	r8,pc[2808]
8000342c:	91 09       	st.w	r8[0x0],r9
8000342e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
					case Radio_Internal_Parameter://0x7F
							
							//logFromISR("\n\r Item_Length:%d\n\r", Item_Length);
							
							if ((RxBytesWaiting -= 4) <= 0) break;
80003432:	20 48       	sub	r8,4
80003434:	fe f9 0a f0 	ld.w	r9,pc[2800]
80003438:	93 08       	st.w	r9[0x0],r8
8000343a:	58 08       	cp.w	r8,0
8000343c:	e0 80 05 4f 	breq	80003eda <phy_rx_func+0xe7a>
							//Radio Internal Parameter
							Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[3];
80003440:	fe f8 0b 14 	ld.w	r8,pc[2836]
80003444:	70 09       	ld.w	r9,r8[0x0]
80003446:	8e 7b       	ld.sh	r11,r7[0xe]
80003448:	fe fa 0b 10 	ld.w	r10,pc[2832]
8000344c:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
							RxData_IsFillingNext16 += 1; 
80003450:	2f f9       	sub	r9,-1
80003452:	91 09       	st.w	r8[0x0],r9
							Item_Length -= 2 ;
80003454:	fe f8 0a e4 	ld.w	r8,pc[2788]
80003458:	70 09       	ld.w	r9,r8[0x0]
8000345a:	20 29       	sub	r9,2
8000345c:	91 09       	st.w	r8[0x0],r9
							//....................................................
							m_RxBurstType = RADIOINTERNAL;
8000345e:	30 29       	mov	r9,2
80003460:	fe f8 0a c0 	ld.w	r8,pc[2752]
80003464:	91 09       	st.w	r8[0x0],r9

							RxMediaState = READING_AMBE_AUX;//Jump
80003466:	30 39       	mov	r9,3
80003468:	fe f8 0a b4 	ld.w	r8,pc[2740]
8000346c:	91 09       	st.w	r8[0x0],r9
8000346e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									
					default://0x03,0x04
						
						//((Item_ID == 0x04) || (Item_ID == 0x03) )//Unknown type data directly back hair
							//break;
							m_RxBurstType = UNSUREDATA;
80003472:	30 3a       	mov	r10,3
80003474:	fe f9 0a ac 	ld.w	r9,pc[2732]
80003478:	93 0a       	st.w	r9[0x0],r10
							AMBE_HT[0] = payload_rx_channel->dword[0];
8000347a:	6e 2a       	ld.w	r10,r7[0x8]
8000347c:	fe f9 0a e0 	ld.w	r9,pc[2784]
80003480:	93 0a       	st.w	r9[0x0],r10
							AMBE_HT[1] = payload_rx_channel->dword[1];
80003482:	6e 3a       	ld.w	r10,r7[0xc]
80003484:	93 1a       	st.w	r9[0x4],r10
							
							if (RxBytesWaiting == 0x00000014)
80003486:	59 48       	cp.w	r8,20
80003488:	c0 61       	brne	80003494 <phy_rx_func+0x434>
							{
								RxBytesWaiting = 0x18;//24 Reassigned
8000348a:	31 89       	mov	r9,24
8000348c:	fe f8 0a 98 	ld.w	r8,pc[2712]
80003490:	91 09       	st.w	r8[0x0],r9
80003492:	c0 a8       	rjmp	800034a6 <phy_rx_func+0x446>
								//_flag =0;
								
							}
							if (RxBytesWaiting == 0x00000010)
80003494:	fe f8 0a 90 	ld.w	r8,pc[2704]
80003498:	70 08       	ld.w	r8,r8[0x0]
8000349a:	59 08       	cp.w	r8,16
8000349c:	c0 51       	brne	800034a6 <phy_rx_func+0x446>
							{
								RxBytesWaiting = 0x10;//16 Reassigned
8000349e:	31 09       	mov	r9,16
800034a0:	fe f8 0a 84 	ld.w	r8,pc[2692]
800034a4:	91 09       	st.w	r8[0x0],r9
								//_flag =1;
							}
					
							RxMediaState = READING_AMBE_MEDIA;//Jump
800034a6:	30 49       	mov	r9,4
800034a8:	fe f8 0a 74 	ld.w	r8,pc[2676]
800034ac:	91 09       	st.w	r8[0x0],r9
800034ae:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
//#if 0
			else//PCM-media-data
			{	
				//logFromISR("\n\r RX:%x \n\r", payload_rx_channel->dword[0]);
				//SPEAKER_DATA or  //MIC_DATA
				if (((payload_rx_channel->dword[0] & 0x0000F000 ) != SPEAKER_DATA ) 
800034b2:	e0 49 10 00 	cp.w	r9,4096
800034b6:	5f 1a       	srne	r10
800034b8:	e0 49 20 00 	cp.w	r9,8192
800034bc:	5f 19       	srne	r9
800034be:	f5 e9 00 09 	and	r9,r10,r9
800034c2:	e0 81 05 0c 	brne	80003eda <phy_rx_func+0xe7a>
					&& ((payload_rx_channel->dword[0] & 0x0000F000 ) != MIC_DATA ))break;
				
				AMBE_tx_flag = 0;
800034c6:	fe fa 0a 9a 	ld.w	r10,pc[2714]
800034ca:	b4 89       	st.b	r10[0x0],r9
				AMBE_rx_flag = 0;
800034cc:	fe fa 0a 98 	ld.w	r10,pc[2712]
800034d0:	b4 89       	st.b	r10[0x0],r9
				
				Item_ID = 0;//To make sure your save PCM data.
800034d2:	fe fa 0a 62 	ld.w	r10,pc[2658]
800034d6:	b4 89       	st.b	r10[0x0],r9
			
				if (NULL== payload_ptr){
800034d8:	fe f9 0a 3c 	ld.w	r9,pc[2620]
800034dc:	72 09       	ld.w	r9,r9[0x0]
800034de:	58 09       	cp.w	r9,0
800034e0:	c0 71       	brne	800034ee <phy_rx_func+0x48e>
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//测试是否有这种情况出现
800034e2:	fe fc 0a 4a 	ld.w	r12,pc[2634]
800034e6:	f0 1f 02 93 	mcall	80003f30 <phy_rx_func+0xed0>
800034ea:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
800034ee:	6e 2a       	ld.w	r10,r7[0x8]
800034f0:	e2 1a 0f 00 	andl	r10,0xf00,COH
800034f4:	58 1a       	cp.w	r10,1
800034f6:	e0 8b 00 4d 	brhi	80003590 <phy_rx_func+0x530>
				
				if ((payload_rx_channel->dword[0]  & 0x00000F00) <= 1){  //Flag type must process Array Descriptor.
				//The first word of the media access payload must be the Array descriptor length. And the
				//unit of the length is in word (16-bit). The length field itself does not count into the length.
				//When there is no array descriptor, the length must be set to zero.[9.1.4.1]
					if ((RxBytesWaiting -= 4) <= 0) break;          //Nothing beyond this Phy buffer. Keep looking for Header
800034fa:	20 48       	sub	r8,4
800034fc:	fe f9 0a 28 	ld.w	r9,pc[2600]
80003500:	93 08       	st.w	r9[0x0],r8
80003502:	58 08       	cp.w	r8,0
80003504:	e0 80 04 eb 	breq	80003eda <phy_rx_func+0xe7a>
					ArrayDiscLength = payload_rx_channel->word[2];
80003508:	8e 68       	ld.sh	r8,r7[0xc]
8000350a:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
8000350e:	fe f9 0a 5a 	ld.w	r9,pc[2650]
80003512:	93 0a       	st.w	r9[0x0],r10
					switch (ArrayDiscLength){
80003514:	30 09       	mov	r9,0
80003516:	f2 08 19 00 	cp.h	r8,r9
8000351a:	c0 70       	breq	80003528 <phy_rx_func+0x4c8>
8000351c:	30 19       	mov	r9,1
8000351e:	f2 08 19 00 	cp.h	r8,r9
80003522:	e0 81 04 dc 	brne	80003eda <phy_rx_func+0xe7a>
80003526:	c2 68       	rjmp	80003572 <phy_rx_func+0x512>
						case 0:          //The usual case. Remaining word in Phy buffer is Audio.
								
							payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
80003528:	fe f8 0a 44 	ld.w	r8,pc[2628]
8000352c:	70 0a       	ld.w	r10,r8[0x0]
8000352e:	fe f9 09 e6 	ld.w	r9,pc[2534]
80003532:	72 09       	ld.w	r9,r9[0x0]
80003534:	8e 7b       	ld.sh	r11,r7[0xe]
80003536:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
							RxMedia_IsFillingNext16 += 1;
8000353a:	70 09       	ld.w	r9,r8[0x0]
8000353c:	2f f9       	sub	r9,-1
8000353e:	91 09       	st.w	r8[0x0],r9
							if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003540:	e0 49 00 ff 	cp.w	r9,255
80003544:	e0 88 00 11 	brls	80003566 <phy_rx_func+0x506>
							{
								RxMedia_IsFillingNext16 = 0;	
80003548:	30 09       	mov	r9,0
8000354a:	91 09       	st.w	r8[0x0],r9
								payload_rx(payload_ptr);	
8000354c:	fe f7 09 c8 	ld.w	r7,pc[2504]
80003550:	6e 0c       	ld.w	r12,r7[0x0]
80003552:	f0 1f 02 7d 	mcall	80003f44 <phy_rx_func+0xee4>
								payload_ptr = get_payload_idle_isr();
80003556:	fe f8 09 ba 	ld.w	r8,pc[2490]
8000355a:	70 0c       	ld.w	r12,r8[0x0]
8000355c:	f0 1f 02 67 	mcall	80003ef8 <phy_rx_func+0xe98>
80003560:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == payload_ptr){
80003562:	e0 80 04 bc 	breq	80003eda <phy_rx_func+0xe7a>
									break;
								}				
							}
							RxMediaState = READINGMEDIA;
80003566:	30 29       	mov	r9,2
80003568:	fe f8 09 b4 	ld.w	r8,pc[2484]
8000356c:	91 09       	st.w	r8[0x0],r9
8000356e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003572:	8e 79       	ld.sh	r9,r7[0xe]
80003574:	30 38       	mov	r8,3
80003576:	f0 09 19 00 	cp.h	r9,r8
8000357a:	c0 51       	brne	80003584 <phy_rx_func+0x524>
				
						case 1: //The next usual case.
								//In general case, add code to process single word Array descriptor.
								if (payload_rx_channel->word[3] == 0x0003)//Stream Terminator
								{
									Terminator_Flag = 1;
8000357c:	30 19       	mov	r9,1
8000357e:	fe f8 09 f2 	ld.w	r8,pc[2546]
80003582:	b0 89       	st.b	r8[0x0],r9
								else
								{
									//Terminator_Flag = 0;
								}
								
								RxMediaState = READINGMEDIA;
80003584:	30 29       	mov	r9,2
80003586:	fe f8 09 96 	ld.w	r8,pc[2454]
8000358a:	91 09       	st.w	r8[0x0],r9
8000358c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
				break;
			}
		
				//Code gets here on Middle or last Fragment. No Array descriptor.
				if (RxBytesWaiting < 2) break;//This shouldn't happen, but must check.
80003590:	58 18       	cp.w	r8,1
80003592:	e0 88 04 a4 	brls	80003eda <phy_rx_func+0xe7a>
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->dword[1] & 0x0000FFFF;
80003596:	fe f8 09 d6 	ld.w	r8,pc[2518]
8000359a:	70 0a       	ld.w	r10,r8[0x0]
8000359c:	6e 3b       	ld.w	r11,r7[0xc]
8000359e:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
800035a2:	70 09       	ld.w	r9,r8[0x0]
800035a4:	2f f9       	sub	r9,-1
800035a6:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800035a8:	e0 49 00 ff 	cp.w	r9,255
800035ac:	e0 88 00 11 	brls	800035ce <phy_rx_func+0x56e>
				{
					RxMedia_IsFillingNext16 = 0;
800035b0:	30 09       	mov	r9,0
800035b2:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
800035b4:	fe f7 09 60 	ld.w	r7,pc[2400]
800035b8:	6e 0c       	ld.w	r12,r7[0x0]
800035ba:	f0 1f 02 63 	mcall	80003f44 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
800035be:	fe f8 09 52 	ld.w	r8,pc[2386]
800035c2:	70 0c       	ld.w	r12,r8[0x0]
800035c4:	f0 1f 02 4d 	mcall	80003ef8 <phy_rx_func+0xe98>
800035c8:	8f 0c       	st.w	r7[0x0],r12
					if(NULL == payload_ptr)
800035ca:	e0 80 04 88 	breq	80003eda <phy_rx_func+0xe7a>
					{
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0) break;  //This shouldn't happen, but must check;
800035ce:	fe f9 09 56 	ld.w	r9,pc[2390]
800035d2:	72 08       	ld.w	r8,r9[0x0]
800035d4:	20 28       	sub	r8,2
800035d6:	93 08       	st.w	r9[0x0],r8
800035d8:	e0 80 04 81 	breq	80003eda <phy_rx_func+0xe7a>
				RxMediaState = READINGMEDIA;
800035dc:	30 29       	mov	r9,2
800035de:	fe f8 09 3e 	ld.w	r8,pc[2366]
800035e2:	91 09       	st.w	r8[0x0],r9
800035e4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
		case READINGMEDIA:
				
			/***PCM-media-data ****/
			{
				
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[0];
800035e8:	fe f8 09 84 	ld.w	r8,pc[2436]
800035ec:	70 0a       	ld.w	r10,r8[0x0]
800035ee:	fe f9 09 26 	ld.w	r9,pc[2342]
800035f2:	72 09       	ld.w	r9,r9[0x0]
800035f4:	8e 4b       	ld.sh	r11,r7[0x8]
800035f6:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;	
800035fa:	70 09       	ld.w	r9,r8[0x0]
800035fc:	2f f9       	sub	r9,-1
800035fe:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003600:	e0 49 00 ff 	cp.w	r9,255
80003604:	e0 88 00 16 	brls	80003630 <phy_rx_func+0x5d0>
				{
					RxMedia_IsFillingNext16 = 0;
80003608:	30 09       	mov	r9,0
8000360a:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
8000360c:	fe f6 09 08 	ld.w	r6,pc[2312]
80003610:	6c 0c       	ld.w	r12,r6[0x0]
80003612:	f0 1f 02 4d 	mcall	80003f44 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
80003616:	fe f8 08 fa 	ld.w	r8,pc[2298]
8000361a:	70 0c       	ld.w	r12,r8[0x0]
8000361c:	f0 1f 02 37 	mcall	80003ef8 <phy_rx_func+0xe98>
80003620:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
80003622:	c0 71       	brne	80003630 <phy_rx_func+0x5d0>
					{
						RxMediaState = WAITINGABAB;
80003624:	30 09       	mov	r9,0
80003626:	fe f8 08 f6 	ld.w	r8,pc[2294]
8000362a:	91 09       	st.w	r8[0x0],r9
8000362c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0)
80003630:	fe f9 08 f4 	ld.w	r9,pc[2292]
80003634:	72 08       	ld.w	r8,r9[0x0]
80003636:	20 28       	sub	r8,2
80003638:	93 08       	st.w	r9[0x0],r8
8000363a:	c0 71       	brne	80003648 <phy_rx_func+0x5e8>
				{
					RxMediaState = WAITINGABAB;
8000363c:	30 09       	mov	r9,0
8000363e:	fe f8 08 de 	ld.w	r8,pc[2270]
80003642:	91 09       	st.w	r8[0x0],r9
80003644:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[1];
80003648:	fe f8 09 24 	ld.w	r8,pc[2340]
8000364c:	70 0a       	ld.w	r10,r8[0x0]
8000364e:	fe f9 08 c6 	ld.w	r9,pc[2246]
80003652:	72 09       	ld.w	r9,r9[0x0]
80003654:	8e 5b       	ld.sh	r11,r7[0xa]
80003656:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
8000365a:	70 09       	ld.w	r9,r8[0x0]
8000365c:	2f f9       	sub	r9,-1
8000365e:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003660:	e0 49 00 ff 	cp.w	r9,255
80003664:	e0 88 00 16 	brls	80003690 <phy_rx_func+0x630>
				{
					RxMedia_IsFillingNext16 = 0;
80003668:	30 09       	mov	r9,0
8000366a:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
8000366c:	fe f6 08 a8 	ld.w	r6,pc[2216]
80003670:	6c 0c       	ld.w	r12,r6[0x0]
80003672:	f0 1f 02 35 	mcall	80003f44 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
80003676:	fe f8 08 9a 	ld.w	r8,pc[2202]
8000367a:	70 0c       	ld.w	r12,r8[0x0]
8000367c:	f0 1f 02 1f 	mcall	80003ef8 <phy_rx_func+0xe98>
80003680:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
80003682:	c0 71       	brne	80003690 <phy_rx_func+0x630>
					{
						RxMediaState = WAITINGABAB;
80003684:	30 09       	mov	r9,0
80003686:	fe f8 08 96 	ld.w	r8,pc[2198]
8000368a:	91 09       	st.w	r8[0x0],r9
8000368c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
80003690:	fe f9 08 94 	ld.w	r9,pc[2196]
80003694:	72 08       	ld.w	r8,r9[0x0]
80003696:	20 28       	sub	r8,2
80003698:	93 08       	st.w	r9[0x0],r8
8000369a:	c0 71       	brne	800036a8 <phy_rx_func+0x648>
					RxMediaState = WAITINGABAB;
8000369c:	30 09       	mov	r9,0
8000369e:	fe f8 08 7e 	ld.w	r8,pc[2174]
800036a2:	91 09       	st.w	r8[0x0],r9
800036a4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}

				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[2];
800036a8:	fe f8 08 c4 	ld.w	r8,pc[2244]
800036ac:	70 0a       	ld.w	r10,r8[0x0]
800036ae:	fe f9 08 66 	ld.w	r9,pc[2150]
800036b2:	72 09       	ld.w	r9,r9[0x0]
800036b4:	8e 6b       	ld.sh	r11,r7[0xc]
800036b6:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
800036ba:	70 09       	ld.w	r9,r8[0x0]
800036bc:	2f f9       	sub	r9,-1
800036be:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800036c0:	e0 49 00 ff 	cp.w	r9,255
800036c4:	e0 88 00 16 	brls	800036f0 <phy_rx_func+0x690>
				{
					RxMedia_IsFillingNext16 = 0;
800036c8:	30 09       	mov	r9,0
800036ca:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
800036cc:	fe f6 08 48 	ld.w	r6,pc[2120]
800036d0:	6c 0c       	ld.w	r12,r6[0x0]
800036d2:	f0 1f 02 1d 	mcall	80003f44 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
800036d6:	fe f8 08 3a 	ld.w	r8,pc[2106]
800036da:	70 0c       	ld.w	r12,r8[0x0]
800036dc:	f0 1f 02 07 	mcall	80003ef8 <phy_rx_func+0xe98>
800036e0:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
800036e2:	c0 71       	brne	800036f0 <phy_rx_func+0x690>
					{
						RxMediaState = WAITINGABAB;
800036e4:	30 09       	mov	r9,0
800036e6:	fe f8 08 36 	ld.w	r8,pc[2102]
800036ea:	91 09       	st.w	r8[0x0],r9
800036ec:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
800036f0:	fe f9 08 34 	ld.w	r9,pc[2100]
800036f4:	72 08       	ld.w	r8,r9[0x0]
800036f6:	20 28       	sub	r8,2
800036f8:	93 08       	st.w	r9[0x0],r8
800036fa:	c0 71       	brne	80003708 <phy_rx_func+0x6a8>
					RxMediaState = WAITINGABAB;
800036fc:	30 09       	mov	r9,0
800036fe:	fe f8 08 1e 	ld.w	r8,pc[2078]
80003702:	91 09       	st.w	r8[0x0],r9
80003704:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
80003708:	fe f8 08 64 	ld.w	r8,pc[2148]
8000370c:	70 0a       	ld.w	r10,r8[0x0]
8000370e:	fe f9 08 06 	ld.w	r9,pc[2054]
80003712:	72 09       	ld.w	r9,r9[0x0]
80003714:	8e 7b       	ld.sh	r11,r7[0xe]
80003716:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
8000371a:	70 09       	ld.w	r9,r8[0x0]
8000371c:	2f f9       	sub	r9,-1
8000371e:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003720:	e0 49 00 ff 	cp.w	r9,255
80003724:	e0 88 00 16 	brls	80003750 <phy_rx_func+0x6f0>
				{
					RxMedia_IsFillingNext16 = 0;
80003728:	30 09       	mov	r9,0
8000372a:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
8000372c:	fe f7 07 e8 	ld.w	r7,pc[2024]
80003730:	6e 0c       	ld.w	r12,r7[0x0]
80003732:	f0 1f 02 05 	mcall	80003f44 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
80003736:	fe f8 07 da 	ld.w	r8,pc[2010]
8000373a:	70 0c       	ld.w	r12,r8[0x0]
8000373c:	f0 1f 01 ef 	mcall	80003ef8 <phy_rx_func+0xe98>
80003740:	8f 0c       	st.w	r7[0x0],r12
					if(NULL == payload_ptr)
80003742:	c0 71       	brne	80003750 <phy_rx_func+0x6f0>
					{
						RxMediaState = WAITINGABAB;
80003744:	30 09       	mov	r9,0
80003746:	fe f8 07 d6 	ld.w	r8,pc[2006]
8000374a:	91 09       	st.w	r8[0x0],r9
8000374c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
80003750:	fe f9 07 d4 	ld.w	r9,pc[2004]
80003754:	72 08       	ld.w	r8,r9[0x0]
80003756:	20 28       	sub	r8,2
80003758:	93 08       	st.w	r9[0x0],r8
8000375a:	e0 81 03 c0 	brne	80003eda <phy_rx_func+0xe7a>
					RxMediaState = WAITINGABAB;
8000375e:	30 09       	mov	r9,0
80003760:	fe f8 07 bc 	ld.w	r8,pc[1980]
80003764:	91 09       	st.w	r8[0x0],r9
80003766:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

		case READING_AMBE_MEDIA:
		
			/****AMBE-media-data ****/
		
					if ((Item_ID == Vocoder_Bit_Stream_Parameter))//PAYLOAD_DATA_ENH (0x0c))
8000376a:	fe f8 07 ca 	ld.w	r8,pc[1994]
8000376e:	11 89       	ld.ub	r9,r8[0x0]
80003770:	31 28       	mov	r8,18
80003772:	f0 09 18 00 	cp.b	r9,r8
80003776:	e0 81 01 4c 	brne	80003a0e <phy_rx_func+0x9ae>
					{
						Item_ID = payload_rx_channel->byte[1];
8000377a:	ef 39 00 09 	ld.ub	r9,r7[9]
8000377e:	fe f8 07 b6 	ld.w	r8,pc[1974]
80003782:	b0 89       	st.b	r8[0x0],r9
						if (Item_ID == Post_Voice_Encoder_Data)//发送方的压缩类型数据
80003784:	11 89       	ld.ub	r9,r8[0x0]
80003786:	3f 28       	mov	r8,-14
80003788:	f0 09 18 00 	cp.b	r9,r8
8000378c:	e0 81 01 3b 	brne	80003a02 <phy_rx_func+0x9a2>
						{
							AMBE_tx_flag = 1;
80003790:	30 19       	mov	r9,1
80003792:	fe f8 07 ce 	ld.w	r8,pc[1998]
80003796:	b0 89       	st.b	r8[0x0],r9
							
							RxBytesWaiting = ((payload_rx_channel->dword[0] & 0x7F000000) >>24);//Test calculations are correct; 8
80003798:	6e 29       	ld.w	r9,r7[0x8]
8000379a:	f3 d9 c3 07 	bfextu	r9,r9,0x18,0x7
8000379e:	fe f8 07 86 	ld.w	r8,pc[1926]
800037a2:	91 09       	st.w	r8[0x0],r9
							
							//For looping back to Radio
							AMBEBurst_rawdata[0] = payload_rx_channel->word[1];
800037a4:	8e 59       	ld.sh	r9,r7[0xa]
800037a6:	fe f8 07 ce 	ld.w	r8,pc[1998]
800037aa:	b0 09       	st.h	r8[0x0],r9
							AMBEBurst_rawdata[1] = payload_rx_channel->word[2];
800037ac:	8e 69       	ld.sh	r9,r7[0xc]
800037ae:	b0 19       	st.h	r8[0x2],r9
							AMBEBurst_rawdata[2] = payload_rx_channel->word[3];
800037b0:	8e 79       	ld.sh	r9,r7[0xe]
800037b2:	b0 29       	st.h	r8[0x4],r9
							
							//To be tested. Also locally stored RAW-AMBER-DATA
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//1
800037b4:	fe f8 07 88 	ld.w	r8,pc[1928]
800037b8:	fe f9 07 60 	ld.w	r9,pc[1888]
800037bc:	72 0a       	ld.w	r10,r9[0x0]
800037be:	70 09       	ld.w	r9,r8[0x0]
800037c0:	ef 3b 00 0a 	ld.ub	r11,r7[10]
800037c4:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
800037c8:	70 09       	ld.w	r9,r8[0x0]
800037ca:	2f f9       	sub	r9,-1
800037cc:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800037ce:	e0 49 01 ff 	cp.w	r9,511
800037d2:	e0 88 00 16 	brls	800037fe <phy_rx_func+0x79e>
							{
								RxAMBE_IsFillingNext8 = 0;
800037d6:	30 09       	mov	r9,0
800037d8:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
800037da:	fe f6 07 3e 	ld.w	r6,pc[1854]
800037de:	6c 0c       	ld.w	r12,r6[0x0]
800037e0:	f0 1f 01 d9 	mcall	80003f44 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
800037e4:	fe f8 07 2c 	ld.w	r8,pc[1836]
800037e8:	70 0c       	ld.w	r12,r8[0x0]
800037ea:	f0 1f 01 c4 	mcall	80003ef8 <phy_rx_func+0xe98>
800037ee:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
800037f0:	c0 71       	brne	800037fe <phy_rx_func+0x79e>
								{
									RxMediaState = WAITINGABAB;
800037f2:	30 09       	mov	r9,0
800037f4:	fe f8 07 28 	ld.w	r8,pc[1832]
800037f8:	91 09       	st.w	r8[0x0],r9
800037fa:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800037fe:	fe f9 07 26 	ld.w	r9,pc[1830]
80003802:	72 08       	ld.w	r8,r9[0x0]
80003804:	20 18       	sub	r8,1
80003806:	93 08       	st.w	r9[0x0],r8
80003808:	c0 71       	brne	80003816 <phy_rx_func+0x7b6>
								RxMediaState = WAITINGABAB;
8000380a:	30 09       	mov	r9,0
8000380c:	fe f8 07 10 	ld.w	r8,pc[1808]
80003810:	91 09       	st.w	r8[0x0],r9
80003812:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}			
							
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//2
80003816:	fe f8 07 26 	ld.w	r8,pc[1830]
8000381a:	fe f9 06 fe 	ld.w	r9,pc[1790]
8000381e:	72 0a       	ld.w	r10,r9[0x0]
80003820:	70 09       	ld.w	r9,r8[0x0]
80003822:	ef 3b 00 0b 	ld.ub	r11,r7[11]
80003826:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
8000382a:	70 09       	ld.w	r9,r8[0x0]
8000382c:	2f f9       	sub	r9,-1
8000382e:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003830:	e0 49 01 ff 	cp.w	r9,511
80003834:	e0 88 00 16 	brls	80003860 <phy_rx_func+0x800>
							{
								RxAMBE_IsFillingNext8 = 0;
80003838:	30 09       	mov	r9,0
8000383a:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
8000383c:	fe f6 06 dc 	ld.w	r6,pc[1756]
80003840:	6c 0c       	ld.w	r12,r6[0x0]
80003842:	f0 1f 01 c1 	mcall	80003f44 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003846:	fe f8 06 ca 	ld.w	r8,pc[1738]
8000384a:	70 0c       	ld.w	r12,r8[0x0]
8000384c:	f0 1f 01 ab 	mcall	80003ef8 <phy_rx_func+0xe98>
80003850:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003852:	c0 71       	brne	80003860 <phy_rx_func+0x800>
								{
									RxMediaState = WAITINGABAB;
80003854:	30 09       	mov	r9,0
80003856:	fe f8 06 c6 	ld.w	r8,pc[1734]
8000385a:	91 09       	st.w	r8[0x0],r9
8000385c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003860:	fe f9 06 c4 	ld.w	r9,pc[1732]
80003864:	72 08       	ld.w	r8,r9[0x0]
80003866:	20 18       	sub	r8,1
80003868:	93 08       	st.w	r9[0x0],r8
8000386a:	c0 71       	brne	80003878 <phy_rx_func+0x818>
								RxMediaState = WAITINGABAB;
8000386c:	30 09       	mov	r9,0
8000386e:	fe f8 06 ae 	ld.w	r8,pc[1710]
80003872:	91 09       	st.w	r8[0x0],r9
80003874:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}		
						
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//3
80003878:	fe f8 06 c4 	ld.w	r8,pc[1732]
8000387c:	fe f9 06 9c 	ld.w	r9,pc[1692]
80003880:	72 0a       	ld.w	r10,r9[0x0]
80003882:	70 09       	ld.w	r9,r8[0x0]
80003884:	ef 3b 00 0c 	ld.ub	r11,r7[12]
80003888:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
8000388c:	70 09       	ld.w	r9,r8[0x0]
8000388e:	2f f9       	sub	r9,-1
80003890:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003892:	e0 49 01 ff 	cp.w	r9,511
80003896:	e0 88 00 16 	brls	800038c2 <phy_rx_func+0x862>
							{
								RxAMBE_IsFillingNext8 = 0;
8000389a:	30 09       	mov	r9,0
8000389c:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
8000389e:	fe f6 06 7a 	ld.w	r6,pc[1658]
800038a2:	6c 0c       	ld.w	r12,r6[0x0]
800038a4:	f0 1f 01 a8 	mcall	80003f44 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
800038a8:	fe f8 06 68 	ld.w	r8,pc[1640]
800038ac:	70 0c       	ld.w	r12,r8[0x0]
800038ae:	f0 1f 01 93 	mcall	80003ef8 <phy_rx_func+0xe98>
800038b2:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
800038b4:	c0 71       	brne	800038c2 <phy_rx_func+0x862>
								{
									RxMediaState = WAITINGABAB;
800038b6:	30 09       	mov	r9,0
800038b8:	fe f8 06 64 	ld.w	r8,pc[1636]
800038bc:	91 09       	st.w	r8[0x0],r9
800038be:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800038c2:	fe f9 06 62 	ld.w	r9,pc[1634]
800038c6:	72 08       	ld.w	r8,r9[0x0]
800038c8:	20 18       	sub	r8,1
800038ca:	93 08       	st.w	r9[0x0],r8
800038cc:	c0 71       	brne	800038da <phy_rx_func+0x87a>
								RxMediaState = WAITINGABAB;
800038ce:	30 09       	mov	r9,0
800038d0:	fe f8 06 4c 	ld.w	r8,pc[1612]
800038d4:	91 09       	st.w	r8[0x0],r9
800038d6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[5];//4
800038da:	fe f8 06 62 	ld.w	r8,pc[1634]
800038de:	fe f9 06 3a 	ld.w	r9,pc[1594]
800038e2:	72 0a       	ld.w	r10,r9[0x0]
800038e4:	70 09       	ld.w	r9,r8[0x0]
800038e6:	ef 3b 00 0d 	ld.ub	r11,r7[13]
800038ea:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
800038ee:	70 09       	ld.w	r9,r8[0x0]
800038f0:	2f f9       	sub	r9,-1
800038f2:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800038f4:	e0 49 01 ff 	cp.w	r9,511
800038f8:	e0 88 00 16 	brls	80003924 <phy_rx_func+0x8c4>
							{
								RxAMBE_IsFillingNext8 = 0;
800038fc:	30 09       	mov	r9,0
800038fe:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003900:	fe f6 06 18 	ld.w	r6,pc[1560]
80003904:	6c 0c       	ld.w	r12,r6[0x0]
80003906:	f0 1f 01 90 	mcall	80003f44 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
8000390a:	fe f8 06 06 	ld.w	r8,pc[1542]
8000390e:	70 0c       	ld.w	r12,r8[0x0]
80003910:	f0 1f 01 7a 	mcall	80003ef8 <phy_rx_func+0xe98>
80003914:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003916:	c0 71       	brne	80003924 <phy_rx_func+0x8c4>
								{
									RxMediaState = WAITINGABAB;
80003918:	30 09       	mov	r9,0
8000391a:	fe f8 06 02 	ld.w	r8,pc[1538]
8000391e:	91 09       	st.w	r8[0x0],r9
80003920:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003924:	fe f9 06 00 	ld.w	r9,pc[1536]
80003928:	72 08       	ld.w	r8,r9[0x0]
8000392a:	20 18       	sub	r8,1
8000392c:	93 08       	st.w	r9[0x0],r8
8000392e:	c0 71       	brne	8000393c <phy_rx_func+0x8dc>
								RxMediaState = WAITINGABAB;
80003930:	30 09       	mov	r9,0
80003932:	fe f8 05 ea 	ld.w	r8,pc[1514]
80003936:	91 09       	st.w	r8[0x0],r9
80003938:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//5
8000393c:	fe f8 06 00 	ld.w	r8,pc[1536]
80003940:	fe f9 05 d8 	ld.w	r9,pc[1496]
80003944:	72 0a       	ld.w	r10,r9[0x0]
80003946:	70 09       	ld.w	r9,r8[0x0]
80003948:	ef 3b 00 0e 	ld.ub	r11,r7[14]
8000394c:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003950:	70 09       	ld.w	r9,r8[0x0]
80003952:	2f f9       	sub	r9,-1
80003954:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003956:	e0 49 01 ff 	cp.w	r9,511
8000395a:	e0 88 00 16 	brls	80003986 <phy_rx_func+0x926>
							{
								RxAMBE_IsFillingNext8 = 0;
8000395e:	30 09       	mov	r9,0
80003960:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003962:	fe f6 05 b6 	ld.w	r6,pc[1462]
80003966:	6c 0c       	ld.w	r12,r6[0x0]
80003968:	f0 1f 01 77 	mcall	80003f44 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
8000396c:	fe f8 05 a4 	ld.w	r8,pc[1444]
80003970:	70 0c       	ld.w	r12,r8[0x0]
80003972:	f0 1f 01 62 	mcall	80003ef8 <phy_rx_func+0xe98>
80003976:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003978:	c0 71       	brne	80003986 <phy_rx_func+0x926>
								{
									RxMediaState = WAITINGABAB;
8000397a:	30 09       	mov	r9,0
8000397c:	fe f8 05 a0 	ld.w	r8,pc[1440]
80003980:	91 09       	st.w	r8[0x0],r9
80003982:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003986:	fe f9 05 9e 	ld.w	r9,pc[1438]
8000398a:	72 08       	ld.w	r8,r9[0x0]
8000398c:	20 18       	sub	r8,1
8000398e:	93 08       	st.w	r9[0x0],r8
80003990:	c0 71       	brne	8000399e <phy_rx_func+0x93e>
								RxMediaState = WAITINGABAB;
80003992:	30 09       	mov	r9,0
80003994:	fe f8 05 88 	ld.w	r8,pc[1416]
80003998:	91 09       	st.w	r8[0x0],r9
8000399a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//6
8000399e:	fe f8 05 9e 	ld.w	r8,pc[1438]
800039a2:	fe f9 05 76 	ld.w	r9,pc[1398]
800039a6:	72 0a       	ld.w	r10,r9[0x0]
800039a8:	70 09       	ld.w	r9,r8[0x0]
800039aa:	ef 3b 00 0f 	ld.ub	r11,r7[15]
800039ae:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
800039b2:	70 09       	ld.w	r9,r8[0x0]
800039b4:	2f f9       	sub	r9,-1
800039b6:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800039b8:	e0 49 01 ff 	cp.w	r9,511
800039bc:	e0 88 00 16 	brls	800039e8 <phy_rx_func+0x988>
							{
								RxAMBE_IsFillingNext8 = 0;
800039c0:	30 09       	mov	r9,0
800039c2:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
800039c4:	fe f7 05 54 	ld.w	r7,pc[1364]
800039c8:	6e 0c       	ld.w	r12,r7[0x0]
800039ca:	f0 1f 01 5f 	mcall	80003f44 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
800039ce:	fe f8 05 42 	ld.w	r8,pc[1346]
800039d2:	70 0c       	ld.w	r12,r8[0x0]
800039d4:	f0 1f 01 49 	mcall	80003ef8 <phy_rx_func+0xe98>
800039d8:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == AMBE_payload_ptr)
800039da:	c0 71       	brne	800039e8 <phy_rx_func+0x988>
								{
									RxMediaState = WAITINGABAB;
800039dc:	30 09       	mov	r9,0
800039de:	fe f8 05 3e 	ld.w	r8,pc[1342]
800039e2:	91 09       	st.w	r8[0x0],r9
800039e4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800039e8:	fe f9 05 3c 	ld.w	r9,pc[1340]
800039ec:	72 08       	ld.w	r8,r9[0x0]
800039ee:	20 18       	sub	r8,1
800039f0:	93 08       	st.w	r9[0x0],r8
800039f2:	e0 81 02 74 	brne	80003eda <phy_rx_func+0xe7a>
								RxMediaState = WAITINGABAB;
800039f6:	30 09       	mov	r9,0
800039f8:	fe f8 05 24 	ld.w	r8,pc[1316]
800039fc:	91 09       	st.w	r8[0x0],r9
800039fe:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							//}
							
						}
						else//error
						{
							RxMediaState = WAITINGABAB;
80003a02:	30 09       	mov	r9,0
80003a04:	fe f8 05 18 	ld.w	r8,pc[1304]
80003a08:	91 09       	st.w	r8[0x0],r9
80003a0a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
					}
					else if (Item_ID == Post_Voice_Encoder_Data)//(bit48~Pad-bits)
80003a0e:	fe f8 05 26 	ld.w	r8,pc[1318]
80003a12:	11 89       	ld.ub	r9,r8[0x0]
80003a14:	3f 28       	mov	r8,-14
80003a16:	f0 09 18 00 	cp.b	r9,r8
80003a1a:	c4 31       	brne	80003aa0 <phy_rx_func+0xa40>
					{
					
						AMBEBurst_rawdata[3] = payload_rx_channel->word[0];//(bit48~Pad-bits)
80003a1c:	8e 49       	ld.sh	r9,r7[0x8]
80003a1e:	fe f8 05 56 	ld.w	r8,pc[1366]
80003a22:	b0 39       	st.h	r8[0x6],r9
						//AMBE_Per_Burst_Flag = 1;
						
						//根据MOTO.bit文件数据分布，建议测试pad-bits的最后一个字节不保存。
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//7
80003a24:	fe f8 05 18 	ld.w	r8,pc[1304]
80003a28:	fe f9 04 f0 	ld.w	r9,pc[1264]
80003a2c:	72 0a       	ld.w	r10,r9[0x0]
80003a2e:	70 09       	ld.w	r9,r8[0x0]
80003a30:	ef 3b 00 08 	ld.ub	r11,r7[8]
80003a34:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003a38:	70 09       	ld.w	r9,r8[0x0]
80003a3a:	2f f9       	sub	r9,-1
80003a3c:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003a3e:	e0 49 01 ff 	cp.w	r9,511
80003a42:	e0 88 00 16 	brls	80003a6e <phy_rx_func+0xa0e>
						{
							RxAMBE_IsFillingNext8 = 0;
80003a46:	30 09       	mov	r9,0
80003a48:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003a4a:	fe f7 04 ce 	ld.w	r7,pc[1230]
80003a4e:	6e 0c       	ld.w	r12,r7[0x0]
80003a50:	f0 1f 01 3d 	mcall	80003f44 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003a54:	fe f8 04 bc 	ld.w	r8,pc[1212]
80003a58:	70 0c       	ld.w	r12,r8[0x0]
80003a5a:	f0 1f 01 28 	mcall	80003ef8 <phy_rx_func+0xe98>
80003a5e:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003a60:	c0 71       	brne	80003a6e <phy_rx_func+0xa0e>
							{
								RxMediaState = WAITINGABAB;
80003a62:	30 09       	mov	r9,0
80003a64:	fe f8 04 b8 	ld.w	r8,pc[1208]
80003a68:	91 09       	st.w	r8[0x0],r9
80003a6a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003a6e:	fe f9 04 b6 	ld.w	r9,pc[1206]
80003a72:	72 08       	ld.w	r8,r9[0x0]
80003a74:	20 18       	sub	r8,1
80003a76:	93 08       	st.w	r9[0x0],r8
80003a78:	c0 71       	brne	80003a86 <phy_rx_func+0xa26>
							RxMediaState = WAITINGABAB;
80003a7a:	30 09       	mov	r9,0
80003a7c:	fe f8 04 a0 	ld.w	r8,pc[1184]
80003a80:	91 09       	st.w	r8[0x0],r9
80003a82:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
						if ((RxBytesWaiting -= 1) <= 0){//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
80003a86:	20 18       	sub	r8,1
80003a88:	fe f9 04 9c 	ld.w	r9,pc[1180]
80003a8c:	93 08       	st.w	r9[0x0],r8
80003a8e:	58 08       	cp.w	r8,0
80003a90:	e0 81 02 25 	brne	80003eda <phy_rx_func+0xe7a>
							RxMediaState = WAITINGABAB;
80003a94:	30 09       	mov	r9,0
80003a96:	fe f8 04 86 	ld.w	r8,pc[1158]
80003a9a:	91 09       	st.w	r8[0x0],r9
80003a9c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
								
					}
					else if (Item_ID == Pre_Voice_Decoder_Data)//bit16~bit63
80003aa0:	fe f8 04 94 	ld.w	r8,pc[1172]
80003aa4:	11 89       	ld.ub	r9,r8[0x0]
80003aa6:	3f 38       	mov	r8,-13
80003aa8:	f0 09 18 00 	cp.b	r9,r8
80003aac:	e0 81 01 0c 	brne	80003cc4 <phy_rx_func+0xc64>
					{
						//接收方的解压类型数据
						//For looping back to Radio
						AMBEBurst_rawdata[1] = payload_rx_channel->word[0];
80003ab0:	8e 49       	ld.sh	r9,r7[0x8]
80003ab2:	fe f8 04 c2 	ld.w	r8,pc[1218]
80003ab6:	b0 19       	st.h	r8[0x2],r9
						AMBEBurst_rawdata[2] = payload_rx_channel->word[1];
80003ab8:	8e 59       	ld.sh	r9,r7[0xa]
80003aba:	b0 29       	st.h	r8[0x4],r9
						AMBEBurst_rawdata[3] = payload_rx_channel->word[2];
80003abc:	8e 69       	ld.sh	r9,r7[0xc]
80003abe:	b0 39       	st.h	r8[0x6],r9
						//if((m_RxBurstType == VOICEBURST_A) && (VF_SN == 1))
						//logFromISR("\n\r Pre_rx:%X\n\r", payload_rx_channel->word[2]);
						
						//To be tested. Also locally stored RAW-AMBER-DATA
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//3
80003ac0:	fe f8 04 7c 	ld.w	r8,pc[1148]
80003ac4:	fe f9 04 54 	ld.w	r9,pc[1108]
80003ac8:	72 0a       	ld.w	r10,r9[0x0]
80003aca:	70 09       	ld.w	r9,r8[0x0]
80003acc:	ef 3b 00 08 	ld.ub	r11,r7[8]
80003ad0:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003ad4:	70 09       	ld.w	r9,r8[0x0]
80003ad6:	2f f9       	sub	r9,-1
80003ad8:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003ada:	e0 49 01 ff 	cp.w	r9,511
80003ade:	e0 88 00 16 	brls	80003b0a <phy_rx_func+0xaaa>
						{
							RxAMBE_IsFillingNext8 = 0;
80003ae2:	30 09       	mov	r9,0
80003ae4:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003ae6:	fe f6 04 32 	ld.w	r6,pc[1074]
80003aea:	6c 0c       	ld.w	r12,r6[0x0]
80003aec:	f0 1f 01 16 	mcall	80003f44 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003af0:	fe f8 04 20 	ld.w	r8,pc[1056]
80003af4:	70 0c       	ld.w	r12,r8[0x0]
80003af6:	f0 1f 01 01 	mcall	80003ef8 <phy_rx_func+0xe98>
80003afa:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003afc:	c0 71       	brne	80003b0a <phy_rx_func+0xaaa>
							{
								RxMediaState = WAITINGABAB;
80003afe:	30 09       	mov	r9,0
80003b00:	fe f8 04 1c 	ld.w	r8,pc[1052]
80003b04:	91 09       	st.w	r8[0x0],r9
80003b06:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003b0a:	fe f9 04 1a 	ld.w	r9,pc[1050]
80003b0e:	72 08       	ld.w	r8,r9[0x0]
80003b10:	20 18       	sub	r8,1
80003b12:	93 08       	st.w	r9[0x0],r8
80003b14:	c0 71       	brne	80003b22 <phy_rx_func+0xac2>
							RxMediaState = WAITINGABAB;
80003b16:	30 09       	mov	r9,0
80003b18:	fe f8 04 04 	ld.w	r8,pc[1028]
80003b1c:	91 09       	st.w	r8[0x0],r9
80003b1e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[1];//4
80003b22:	fe f8 04 1a 	ld.w	r8,pc[1050]
80003b26:	fe f9 03 f2 	ld.w	r9,pc[1010]
80003b2a:	72 0a       	ld.w	r10,r9[0x0]
80003b2c:	70 09       	ld.w	r9,r8[0x0]
80003b2e:	ef 3b 00 09 	ld.ub	r11,r7[9]
80003b32:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003b36:	70 09       	ld.w	r9,r8[0x0]
80003b38:	2f f9       	sub	r9,-1
80003b3a:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003b3c:	e0 49 01 ff 	cp.w	r9,511
80003b40:	e0 88 00 16 	brls	80003b6c <phy_rx_func+0xb0c>
						{
							RxAMBE_IsFillingNext8 = 0;
80003b44:	30 09       	mov	r9,0
80003b46:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003b48:	fe f6 03 d0 	ld.w	r6,pc[976]
80003b4c:	6c 0c       	ld.w	r12,r6[0x0]
80003b4e:	f0 1f 00 fe 	mcall	80003f44 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003b52:	fe f8 03 be 	ld.w	r8,pc[958]
80003b56:	70 0c       	ld.w	r12,r8[0x0]
80003b58:	f0 1f 00 e8 	mcall	80003ef8 <phy_rx_func+0xe98>
80003b5c:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003b5e:	c0 71       	brne	80003b6c <phy_rx_func+0xb0c>
							{
								RxMediaState = WAITINGABAB;
80003b60:	30 09       	mov	r9,0
80003b62:	fe f8 03 ba 	ld.w	r8,pc[954]
80003b66:	91 09       	st.w	r8[0x0],r9
80003b68:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003b6c:	fe f9 03 b8 	ld.w	r9,pc[952]
80003b70:	72 08       	ld.w	r8,r9[0x0]
80003b72:	20 18       	sub	r8,1
80003b74:	93 08       	st.w	r9[0x0],r8
80003b76:	c0 71       	brne	80003b84 <phy_rx_func+0xb24>
							RxMediaState = WAITINGABAB;
80003b78:	30 09       	mov	r9,0
80003b7a:	fe f8 03 a2 	ld.w	r8,pc[930]
80003b7e:	91 09       	st.w	r8[0x0],r9
80003b80:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//5
80003b84:	fe f8 03 b8 	ld.w	r8,pc[952]
80003b88:	fe f9 03 90 	ld.w	r9,pc[912]
80003b8c:	72 0a       	ld.w	r10,r9[0x0]
80003b8e:	70 09       	ld.w	r9,r8[0x0]
80003b90:	ef 3b 00 0a 	ld.ub	r11,r7[10]
80003b94:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003b98:	70 09       	ld.w	r9,r8[0x0]
80003b9a:	2f f9       	sub	r9,-1
80003b9c:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003b9e:	e0 49 01 ff 	cp.w	r9,511
80003ba2:	e0 88 00 16 	brls	80003bce <phy_rx_func+0xb6e>
						{
							RxAMBE_IsFillingNext8 = 0;
80003ba6:	30 09       	mov	r9,0
80003ba8:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003baa:	fe f6 03 6e 	ld.w	r6,pc[878]
80003bae:	6c 0c       	ld.w	r12,r6[0x0]
80003bb0:	f0 1f 00 e5 	mcall	80003f44 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003bb4:	fe f8 03 5c 	ld.w	r8,pc[860]
80003bb8:	70 0c       	ld.w	r12,r8[0x0]
80003bba:	f0 1f 00 d0 	mcall	80003ef8 <phy_rx_func+0xe98>
80003bbe:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003bc0:	c0 71       	brne	80003bce <phy_rx_func+0xb6e>
							{
								RxMediaState = WAITINGABAB;
80003bc2:	30 09       	mov	r9,0
80003bc4:	fe f8 03 58 	ld.w	r8,pc[856]
80003bc8:	91 09       	st.w	r8[0x0],r9
80003bca:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003bce:	fe f9 03 56 	ld.w	r9,pc[854]
80003bd2:	72 08       	ld.w	r8,r9[0x0]
80003bd4:	20 18       	sub	r8,1
80003bd6:	93 08       	st.w	r9[0x0],r8
80003bd8:	c0 71       	brne	80003be6 <phy_rx_func+0xb86>
							RxMediaState = WAITINGABAB;
80003bda:	30 09       	mov	r9,0
80003bdc:	fe f8 03 40 	ld.w	r8,pc[832]
80003be0:	91 09       	st.w	r8[0x0],r9
80003be2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//6
80003be6:	fe f8 03 56 	ld.w	r8,pc[854]
80003bea:	fe f9 03 2e 	ld.w	r9,pc[814]
80003bee:	72 0a       	ld.w	r10,r9[0x0]
80003bf0:	70 09       	ld.w	r9,r8[0x0]
80003bf2:	ef 3b 00 0b 	ld.ub	r11,r7[11]
80003bf6:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003bfa:	70 09       	ld.w	r9,r8[0x0]
80003bfc:	2f f9       	sub	r9,-1
80003bfe:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003c00:	e0 49 01 ff 	cp.w	r9,511
80003c04:	e0 88 00 16 	brls	80003c30 <phy_rx_func+0xbd0>
						{
							RxAMBE_IsFillingNext8 = 0;
80003c08:	30 09       	mov	r9,0
80003c0a:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003c0c:	fe f6 03 0c 	ld.w	r6,pc[780]
80003c10:	6c 0c       	ld.w	r12,r6[0x0]
80003c12:	f0 1f 00 cd 	mcall	80003f44 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003c16:	fe f8 02 fa 	ld.w	r8,pc[762]
80003c1a:	70 0c       	ld.w	r12,r8[0x0]
80003c1c:	f0 1f 00 b7 	mcall	80003ef8 <phy_rx_func+0xe98>
80003c20:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003c22:	c0 71       	brne	80003c30 <phy_rx_func+0xbd0>
							{
								RxMediaState = WAITINGABAB;
80003c24:	30 09       	mov	r9,0
80003c26:	fe f8 02 f6 	ld.w	r8,pc[758]
80003c2a:	91 09       	st.w	r8[0x0],r9
80003c2c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003c30:	fe f9 02 f4 	ld.w	r9,pc[756]
80003c34:	72 08       	ld.w	r8,r9[0x0]
80003c36:	20 18       	sub	r8,1
80003c38:	93 08       	st.w	r9[0x0],r8
80003c3a:	c0 71       	brne	80003c48 <phy_rx_func+0xbe8>
							RxMediaState = WAITINGABAB;
80003c3c:	30 09       	mov	r9,0
80003c3e:	fe f8 02 de 	ld.w	r8,pc[734]
80003c42:	91 09       	st.w	r8[0x0],r9
80003c44:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//7
80003c48:	fe f8 02 f4 	ld.w	r8,pc[756]
80003c4c:	fe f9 02 cc 	ld.w	r9,pc[716]
80003c50:	72 0a       	ld.w	r10,r9[0x0]
80003c52:	70 09       	ld.w	r9,r8[0x0]
80003c54:	ef 3b 00 0c 	ld.ub	r11,r7[12]
80003c58:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003c5c:	70 09       	ld.w	r9,r8[0x0]
80003c5e:	2f f9       	sub	r9,-1
80003c60:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003c62:	e0 49 01 ff 	cp.w	r9,511
80003c66:	e0 88 00 16 	brls	80003c92 <phy_rx_func+0xc32>
						{
							RxAMBE_IsFillingNext8 = 0;
80003c6a:	30 09       	mov	r9,0
80003c6c:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003c6e:	fe f7 02 aa 	ld.w	r7,pc[682]
80003c72:	6e 0c       	ld.w	r12,r7[0x0]
80003c74:	f0 1f 00 b4 	mcall	80003f44 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003c78:	fe f8 02 98 	ld.w	r8,pc[664]
80003c7c:	70 0c       	ld.w	r12,r8[0x0]
80003c7e:	f0 1f 00 9f 	mcall	80003ef8 <phy_rx_func+0xe98>
80003c82:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003c84:	c0 71       	brne	80003c92 <phy_rx_func+0xc32>
							{
								RxMediaState = WAITINGABAB;
80003c86:	30 09       	mov	r9,0
80003c88:	fe f8 02 94 	ld.w	r8,pc[660]
80003c8c:	91 09       	st.w	r8[0x0],r9
80003c8e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003c92:	fe f9 02 92 	ld.w	r9,pc[658]
80003c96:	72 08       	ld.w	r8,r9[0x0]
80003c98:	20 18       	sub	r8,1
80003c9a:	93 08       	st.w	r9[0x0],r8
80003c9c:	c0 71       	brne	80003caa <phy_rx_func+0xc4a>
							RxMediaState = WAITINGABAB;
80003c9e:	30 09       	mov	r9,0
80003ca0:	fe f8 02 7c 	ld.w	r8,pc[636]
80003ca4:	91 09       	st.w	r8[0x0],r9
80003ca6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
						if ((RxBytesWaiting -= 1) <= 0){
80003caa:	20 18       	sub	r8,1
80003cac:	fe f9 02 78 	ld.w	r9,pc[632]
80003cb0:	93 08       	st.w	r9[0x0],r8
80003cb2:	58 08       	cp.w	r8,0
80003cb4:	e0 81 01 13 	brne	80003eda <phy_rx_func+0xe7a>
							
							//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
							//or discard it to reduce payload size.
							
							RxMediaState = WAITINGABAB;
80003cb8:	30 09       	mov	r9,0
80003cba:	fe f8 02 62 	ld.w	r8,pc[610]
80003cbe:	91 09       	st.w	r8[0x0],r9
80003cc0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
					}
					else if ((Item_ID == 0x04)  ||  (Item_ID == 0x03))//Unknown type data directly back hair
80003cc4:	fe f8 02 70 	ld.w	r8,pc[624]
80003cc8:	11 89       	ld.ub	r9,r8[0x0]
80003cca:	30 48       	mov	r8,4
80003ccc:	f0 09 18 00 	cp.b	r9,r8
80003cd0:	c0 80       	breq	80003ce0 <phy_rx_func+0xc80>
80003cd2:	fe f8 02 62 	ld.w	r8,pc[610]
80003cd6:	11 89       	ld.ub	r9,r8[0x0]
80003cd8:	30 38       	mov	r8,3
80003cda:	f0 09 18 00 	cp.b	r9,r8
80003cde:	c1 41       	brne	80003d06 <phy_rx_func+0xca6>
					{
						AMBE_HT[0] = payload_rx_channel->dword[0];
80003ce0:	6e 29       	ld.w	r9,r7[0x8]
80003ce2:	fe f8 02 7a 	ld.w	r8,pc[634]
80003ce6:	91 09       	st.w	r8[0x0],r9
						AMBE_HT[1] = payload_rx_channel->dword[1];				
80003ce8:	6e 39       	ld.w	r9,r7[0xc]
80003cea:	91 19       	st.w	r8[0x4],r9
						
						if ((RxBytesWaiting -= 8) <= 0)//Consider two cases 0xABCDC014 and 0xABCDC010
80003cec:	fe f9 02 38 	ld.w	r9,pc[568]
80003cf0:	72 08       	ld.w	r8,r9[0x0]
80003cf2:	20 88       	sub	r8,8
80003cf4:	93 08       	st.w	r9[0x0],r8
80003cf6:	e0 81 00 f2 	brne	80003eda <phy_rx_func+0xe7a>
						{
					
							RxBytesWaiting = 0;
80003cfa:	93 08       	st.w	r9[0x0],r8
							RxMediaState = WAITINGABAB;
80003cfc:	fe f9 02 20 	ld.w	r9,pc[544]
80003d00:	93 08       	st.w	r9[0x0],r8
80003d02:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
						}
						break;

					}
					else if (Item_ID == Soft_Decision_Value)
80003d06:	fe f8 02 2e 	ld.w	r8,pc[558]
80003d0a:	11 89       	ld.ub	r9,r8[0x0]
80003d0c:	31 38       	mov	r8,19
80003d0e:	f0 09 18 00 	cp.b	r9,r8
80003d12:	e0 81 00 9c 	brne	80003e4a <phy_rx_func+0xdea>
					{							
						if (SDV_Index == 12)
80003d16:	fe f8 02 62 	ld.w	r8,pc[610]
80003d1a:	11 88       	ld.ub	r8,r8[0x0]
80003d1c:	30 c9       	mov	r9,12
80003d1e:	f2 08 18 00 	cp.b	r8,r9
80003d22:	e0 81 00 7b 	brne	80003e18 <phy_rx_func+0xdb8>
						{
							Soft_Decision_Data[SDV_Index]= payload_rx_channel->word[0];
80003d26:	8e 49       	ld.sh	r9,r7[0x8]
80003d28:	fe f8 02 54 	ld.w	r8,pc[596]
80003d2c:	f1 59 00 18 	st.h	r8[24],r9
							
							SDV_Index = 0;
80003d30:	30 09       	mov	r9,0
80003d32:	fe f8 02 46 	ld.w	r8,pc[582]
80003d36:	b0 89       	st.b	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003d38:	ef 39 00 0d 	ld.ub	r9,r7[13]
80003d3c:	3f 38       	mov	r8,-13
80003d3e:	f0 09 18 00 	cp.b	r9,r8
80003d42:	c6 61       	brne	80003e0e <phy_rx_func+0xdae>
							
							SDV_Index = 0;
								
							if (payload_rx_channel->byte[5] == Pre_Voice_Decoder_Data )//0xF3
							{
									Item_ID = Pre_Voice_Decoder_Data;
80003d44:	10 99       	mov	r9,r8
80003d46:	4f c8       	lddpc	r8,80003f34 <phy_rx_func+0xed4>
80003d48:	b0 89       	st.b	r8[0x0],r9
									RxBytesWaiting = (payload_rx_channel->byte[4] & 0x7F);//Test calculations are correct; 8
80003d4a:	ef 39 00 0c 	ld.ub	r9,r7[12]
80003d4e:	f3 d9 c0 07 	bfextu	r9,r9,0x0,0x7
80003d52:	4f 58       	lddpc	r8,80003f24 <phy_rx_func+0xec4>
80003d54:	91 09       	st.w	r8[0x0],r9
									AMBE_rx_flag = 1;//本地作为AMBE数据的解密方
80003d56:	30 19       	mov	r9,1
80003d58:	fe f8 02 0c 	ld.w	r8,pc[524]
80003d5c:	b0 89       	st.b	r8[0x0],r9
		
									AMBEBurst_rawdata[0] = payload_rx_channel->word[3];//用于解密的中间数据变量
80003d5e:	8e 79       	ld.sh	r9,r7[0xe]
80003d60:	fe f8 02 14 	ld.w	r8,pc[532]
80003d64:	b0 09       	st.h	r8[0x0],r9
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//1
80003d66:	4f 68       	lddpc	r8,80003f3c <phy_rx_func+0xedc>
80003d68:	4e c9       	lddpc	r9,80003f18 <phy_rx_func+0xeb8>
80003d6a:	72 0a       	ld.w	r10,r9[0x0]
80003d6c:	70 09       	ld.w	r9,r8[0x0]
80003d6e:	ef 3b 00 0e 	ld.ub	r11,r7[14]
80003d72:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
80003d76:	70 09       	ld.w	r9,r8[0x0]
80003d78:	2f f9       	sub	r9,-1
80003d7a:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003d7c:	e0 49 01 ff 	cp.w	r9,511
80003d80:	e0 88 00 13 	brls	80003da6 <phy_rx_func+0xd46>
									{
										RxAMBE_IsFillingNext8 = 0;
80003d84:	30 09       	mov	r9,0
80003d86:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
80003d88:	4e 46       	lddpc	r6,80003f18 <phy_rx_func+0xeb8>
80003d8a:	6c 0c       	ld.w	r12,r6[0x0]
80003d8c:	f0 1f 00 6e 	mcall	80003f44 <phy_rx_func+0xee4>
										AMBE_payload_ptr = get_payload_idle_isr();
80003d90:	4e 08       	lddpc	r8,80003f10 <phy_rx_func+0xeb0>
80003d92:	70 0c       	ld.w	r12,r8[0x0]
80003d94:	f0 1f 00 59 	mcall	80003ef8 <phy_rx_func+0xe98>
80003d98:	8d 0c       	st.w	r6[0x0],r12
										if(NULL == AMBE_payload_ptr)
80003d9a:	c0 61       	brne	80003da6 <phy_rx_func+0xd46>
										{
											RxMediaState = WAITINGABAB;
80003d9c:	30 09       	mov	r9,0
80003d9e:	4e 08       	lddpc	r8,80003f1c <phy_rx_func+0xebc>
80003da0:	91 09       	st.w	r8[0x0],r9
80003da2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
80003da6:	4e 09       	lddpc	r9,80003f24 <phy_rx_func+0xec4>
80003da8:	72 08       	ld.w	r8,r9[0x0]
80003daa:	20 18       	sub	r8,1
80003dac:	93 08       	st.w	r9[0x0],r8
80003dae:	c0 61       	brne	80003dba <phy_rx_func+0xd5a>
										RxMediaState = WAITINGABAB;
80003db0:	30 09       	mov	r9,0
80003db2:	4d b8       	lddpc	r8,80003f1c <phy_rx_func+0xebc>
80003db4:	91 09       	st.w	r8[0x0],r9
80003db6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//2
80003dba:	4e 18       	lddpc	r8,80003f3c <phy_rx_func+0xedc>
80003dbc:	4d 79       	lddpc	r9,80003f18 <phy_rx_func+0xeb8>
80003dbe:	72 0a       	ld.w	r10,r9[0x0]
80003dc0:	70 09       	ld.w	r9,r8[0x0]
80003dc2:	ef 3b 00 0f 	ld.ub	r11,r7[15]
80003dc6:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
80003dca:	70 09       	ld.w	r9,r8[0x0]
80003dcc:	2f f9       	sub	r9,-1
80003dce:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003dd0:	e0 49 01 ff 	cp.w	r9,511
80003dd4:	e0 88 00 13 	brls	80003dfa <phy_rx_func+0xd9a>
									{
										RxAMBE_IsFillingNext8 = 0;
80003dd8:	30 09       	mov	r9,0
80003dda:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
80003ddc:	4c f7       	lddpc	r7,80003f18 <phy_rx_func+0xeb8>
80003dde:	6e 0c       	ld.w	r12,r7[0x0]
80003de0:	f0 1f 00 59 	mcall	80003f44 <phy_rx_func+0xee4>
										AMBE_payload_ptr = get_payload_idle_isr();
80003de4:	4c b8       	lddpc	r8,80003f10 <phy_rx_func+0xeb0>
80003de6:	70 0c       	ld.w	r12,r8[0x0]
80003de8:	f0 1f 00 44 	mcall	80003ef8 <phy_rx_func+0xe98>
80003dec:	8f 0c       	st.w	r7[0x0],r12
										if(NULL == AMBE_payload_ptr)
80003dee:	c0 61       	brne	80003dfa <phy_rx_func+0xd9a>
										{
											RxMediaState = WAITINGABAB;
80003df0:	30 09       	mov	r9,0
80003df2:	4c b8       	lddpc	r8,80003f1c <phy_rx_func+0xebc>
80003df4:	91 09       	st.w	r8[0x0],r9
80003df6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
80003dfa:	4c b9       	lddpc	r9,80003f24 <phy_rx_func+0xec4>
80003dfc:	72 08       	ld.w	r8,r9[0x0]
80003dfe:	20 18       	sub	r8,1
80003e00:	93 08       	st.w	r9[0x0],r8
80003e02:	c6 c1       	brne	80003eda <phy_rx_func+0xe7a>
										RxMediaState = WAITINGABAB;
80003e04:	30 09       	mov	r9,0
80003e06:	4c 68       	lddpc	r8,80003f1c <phy_rx_func+0xebc>
80003e08:	91 09       	st.w	r8[0x0],r9
80003e0a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
							}
							else
							RxMediaState = WAITINGABAB;
80003e0e:	30 09       	mov	r9,0
80003e10:	4c 38       	lddpc	r8,80003f1c <phy_rx_func+0xebc>
80003e12:	91 09       	st.w	r8[0x0],r9
80003e14:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
						}
						else
						{
									
							Soft_Decision_Data[SDV_Index]	  = payload_rx_channel->word[0];
80003e18:	8e 4a       	ld.sh	r10,r7[0x8]
80003e1a:	4d 99       	lddpc	r9,80003f7c <phy_rx_func+0xf1c>
80003e1c:	f2 08 0a 1a 	st.h	r9[r8<<0x1],r10
							Soft_Decision_Data[SDV_Index+1]	  = payload_rx_channel->word[1];
80003e20:	4d 6a       	lddpc	r10,80003f78 <phy_rx_func+0xf18>
80003e22:	15 88       	ld.ub	r8,r10[0x0]
80003e24:	f0 cb ff ff 	sub	r11,r8,-1
80003e28:	8e 5c       	ld.sh	r12,r7[0xa]
80003e2a:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+2]	  = payload_rx_channel->word[2];
80003e2e:	f0 cb ff fe 	sub	r11,r8,-2
80003e32:	8e 6c       	ld.sh	r12,r7[0xc]
80003e34:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+3]	  = payload_rx_channel->word[3];
80003e38:	f0 cb ff fd 	sub	r11,r8,-3
80003e3c:	8e 7c       	ld.sh	r12,r7[0xe]
80003e3e:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							SDV_Index +=4;
80003e42:	2f c8       	sub	r8,-4
80003e44:	b4 88       	st.b	r10[0x0],r8
80003e46:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					
					else
					{
						
						RxMediaState  = WAITINGABAB;
80003e4a:	30 09       	mov	r9,0
80003e4c:	4b 48       	lddpc	r8,80003f1c <phy_rx_func+0xebc>
80003e4e:	91 09       	st.w	r8[0x0],r9
80003e50:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
		break;//End of READING_AMBE_MEDIA.

        case READING_AMBE_AUX:
			
				Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[0];
80003e54:	4c 08       	lddpc	r8,80003f54 <phy_rx_func+0xef4>
80003e56:	70 09       	ld.w	r9,r8[0x0]
80003e58:	8e 4b       	ld.sh	r11,r7[0x8]
80003e5a:	4c 0a       	lddpc	r10,80003f58 <phy_rx_func+0xef8>
80003e5c:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
				RxData_IsFillingNext16 += 1;
80003e60:	2f f9       	sub	r9,-1
80003e62:	91 09       	st.w	r8[0x0],r9
			
				if ((Item_Length -= 2) <= 0)
80003e64:	4b 58       	lddpc	r8,80003f38 <phy_rx_func+0xed8>
80003e66:	70 09       	ld.w	r9,r8[0x0]
80003e68:	20 29       	sub	r9,2
80003e6a:	91 09       	st.w	r8[0x0],r9
80003e6c:	70 08       	ld.w	r8,r8[0x0]
80003e6e:	58 08       	cp.w	r8,0
80003e70:	c2 f1       	brne	80003ece <phy_rx_func+0xe6e>
				{
					RxData_IsFillingNext16 = 0;
80003e72:	30 09       	mov	r9,0
80003e74:	4b 88       	lddpc	r8,80003f54 <phy_rx_func+0xef4>
80003e76:	91 09       	st.w	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003e78:	8e 59       	ld.sh	r9,r7[0xa]
80003e7a:	fe 78 82 12 	mov	r8,-32238
80003e7e:	f0 09 19 00 	cp.h	r9,r8
80003e82:	c2 11       	brne	80003ec4 <phy_rx_func+0xe64>
					{
						//Item_ID = Vocoder_Bit_Stream_Parameter;
						//Vocoder Bits Stream Parameter
						//Its value ranges from 1 to 18 for one voice superframe contains 6 voice bursts
						// and each burst contains 3 VFs.
						VF_SN = (payload_rx_channel->byte[5] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
80003e84:	ef 3c 00 0d 	ld.ub	r12,r7[13]
80003e88:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
80003e8c:	4a f8       	lddpc	r8,80003f48 <phy_rx_func+0xee8>
80003e8e:	b0 8c       	st.b	r8[0x0],r12
							
						VBSP_data[0] = payload_rx_channel->word[1];
80003e90:	8e 59       	ld.sh	r9,r7[0xa]
80003e92:	4a f8       	lddpc	r8,80003f4c <phy_rx_func+0xeec>
80003e94:	b0 09       	st.h	r8[0x0],r9
						VBSP_data[1] = payload_rx_channel->word[2];
80003e96:	8e 69       	ld.sh	r9,r7[0xc]
80003e98:	b0 19       	st.h	r8[0x2],r9
							
						m_RxBurstType = CalculateBurst(VF_SN);
80003e9a:	f0 1f 00 2e 	mcall	80003f50 <phy_rx_func+0xef0>
80003e9e:	4a 18       	lddpc	r8,80003f20 <phy_rx_func+0xec0>
80003ea0:	91 0c       	st.w	r8[0x0],r12
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003ea2:	ef 39 00 0f 	ld.ub	r9,r7[15]
80003ea6:	31 38       	mov	r8,19
80003ea8:	f0 09 18 00 	cp.b	r9,r8
80003eac:	c0 71       	brne	80003eba <phy_rx_func+0xe5a>
							
						m_RxBurstType = CalculateBurst(VF_SN);
						
						if (payload_rx_channel->byte[7] == Soft_Decision_Value)//0x13
						{
							Item_ID = Soft_Decision_Value;	
80003eae:	10 99       	mov	r9,r8
80003eb0:	4a 18       	lddpc	r8,80003f34 <phy_rx_func+0xed4>
80003eb2:	b0 89       	st.b	r8[0x0],r9
							RxBytesWaiting = ((payload_rx_channel->dword[1] & 0x00007F00) >>24);//Test calculations are correct; 26
80003eb4:	30 09       	mov	r9,0
80003eb6:	49 c8       	lddpc	r8,80003f24 <phy_rx_func+0xec4>
80003eb8:	91 09       	st.w	r8[0x0],r9
						else
						{//error
								RxMediaState = WAITINGABAB;//Jump
						}
							
						RxMediaState = READING_AMBE_MEDIA;//Jump
80003eba:	30 49       	mov	r9,4
80003ebc:	49 88       	lddpc	r8,80003f1c <phy_rx_func+0xebc>
80003ebe:	91 09       	st.w	r8[0x0],r9
80003ec0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					else
					{
						RxMediaState = WAITINGABAB;//Jump
80003ec4:	30 09       	mov	r9,0
80003ec6:	49 68       	lddpc	r8,80003f1c <phy_rx_func+0xebc>
80003ec8:	91 09       	st.w	r8[0x0],r9
80003eca:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}

				}
				else
				{//测试看看是几个字节数据
					logFromISR("\n\r Radio Internal parameter length error \n\r");
80003ece:	4a dc       	lddpc	r12,80003f80 <phy_rx_func+0xf20>
80003ed0:	f0 1f 00 18 	mcall	80003f30 <phy_rx_func+0xed0>
					RxMediaState = WAITINGABAB;//Jump
80003ed4:	30 09       	mov	r9,0
80003ed6:	49 28       	lddpc	r8,80003f1c <phy_rx_func+0xebc>
80003ed8:	91 09       	st.w	r8[0x0],r9
80003eda:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80003ede:	00 00       	add	r0,r0
80003ee0:	00 00       	add	r0,r0
80003ee2:	0a c4       	st.b	r5++,r4
80003ee4:	00 00       	add	r0,r0
80003ee6:	0a d0       	st.w	--r5,r0
80003ee8:	00 00       	add	r0,r0
80003eea:	0a b4       	st.h	r5++,r4
80003eec:	00 00       	add	r0,r0
80003eee:	0a 8c       	andn	r12,r5
80003ef0:	00 00       	add	r0,r0
80003ef2:	0a 7c       	tst	r12,r5
80003ef4:	00 00       	add	r0,r0
80003ef6:	0a a8       	st.w	r5++,r8
80003ef8:	80 00       	ld.sh	r0,r0[0x0]
80003efa:	2a c0       	sub	r0,-84
80003efc:	00 00       	add	r0,r0
80003efe:	0a d4       	st.w	--r5,r4
80003f00:	80 00       	ld.sh	r0,r0[0x0]
80003f02:	29 f0       	sub	r0,-97
80003f04:	00 00       	add	r0,r0
80003f06:	0a bc       	st.h	r5++,r12
80003f08:	80 00       	ld.sh	r0,r0[0x0]
80003f0a:	2a 0c       	sub	r12,-96
80003f0c:	00 00       	add	r0,r0
80003f0e:	0a 99       	mov	r9,r5
80003f10:	00 00       	add	r0,r0
80003f12:	0a b0       	st.h	r5++,r0
80003f14:	00 00       	add	r0,r0
80003f16:	0a c8       	st.b	r5++,r8
80003f18:	00 00       	add	r0,r0
80003f1a:	0a e4       	st.h	--r5,r4
80003f1c:	00 00       	add	r0,r0
80003f1e:	0a a4       	st.w	r5++,r4
80003f20:	00 00       	add	r0,r0
80003f22:	0a dc       	st.w	--r5,r12
80003f24:	00 00       	add	r0,r0
80003f26:	0a 88       	andn	r8,r5
80003f28:	00 00       	add	r0,r0
80003f2a:	0a 5c       	eor	r12,r5
80003f2c:	80 00       	ld.sh	r0,r0[0x0]
80003f2e:	c9 a0       	breq	80003e62 <phy_rx_func+0xe02>
80003f30:	80 00       	ld.sh	r0,r0[0x0]
80003f32:	62 f4       	ld.w	r4,r1[0x3c]
80003f34:	00 00       	add	r0,r0
80003f36:	0a 98       	mov	r8,r5
80003f38:	00 00       	add	r0,r0
80003f3a:	0a 78       	tst	r8,r5
80003f3c:	00 00       	add	r0,r0
80003f3e:	0a 90       	mov	r0,r5
80003f40:	80 00       	ld.sh	r0,r0[0x0]
80003f42:	6b 3c       	ld.w	r12,r5[0x4c]
80003f44:	80 00       	ld.sh	r0,r0[0x0]
80003f46:	30 00       	mov	r0,0
80003f48:	00 00       	add	r0,r0
80003f4a:	0a 5d       	eor	sp,r5
80003f4c:	00 00       	add	r0,r0
80003f4e:	0e 94       	mov	r4,r7
80003f50:	80 00       	ld.sh	r0,r0[0x0]
80003f52:	29 50       	sub	r0,-107
80003f54:	00 00       	add	r0,r0
80003f56:	0a c0       	st.b	r5++,r0
80003f58:	00 00       	add	r0,r0
80003f5a:	0d 98       	ld.ub	r8,r6[0x1]
80003f5c:	00 00       	add	r0,r0
80003f5e:	0a 9c       	mov	r12,r5
80003f60:	00 00       	add	r0,r0
80003f62:	0a 61       	and	r1,r5
80003f64:	00 00       	add	r0,r0
80003f66:	0a 60       	and	r0,r5
80003f68:	00 00       	add	r0,r0
80003f6a:	0a 70       	tst	r0,r5
80003f6c:	00 00       	add	r0,r0
80003f6e:	0a ac       	st.w	r5++,r12
80003f70:	00 00       	add	r0,r0
80003f72:	0a 62       	and	r2,r5
80003f74:	00 00       	add	r0,r0
80003f76:	0d 90       	ld.ub	r0,r6[0x1]
80003f78:	00 00       	add	r0,r0
80003f7a:	0a cc       	st.b	r5++,r12
80003f7c:	00 00       	add	r0,r0
80003f7e:	0e 98       	mov	r8,r7
80003f80:	80 00       	ld.sh	r0,r0[0x0]
80003f82:	c9 b8       	rjmp	800040b8 <register_rx_tx_func+0x10>

80003f84 <pdca_int_handler>:
    void (*phy_rx_exec)(void *)--callback function for receive SSC data 
Called By: interrupt
*/
__attribute__((__interrupt__))
static void pdca_int_handler(void)
{
80003f84:	d4 01       	pushm	lr
    
	//intStartCount = Get_system_register(AVR32_COUNT);
	
	/*Toggle Index*/
    BufferIndex ^= 0x01;
80003f86:	49 88       	lddpc	r8,80003fe4 <pdca_int_handler+0x60>
80003f88:	11 89       	ld.ub	r9,r8[0x0]
80003f8a:	ec 19 00 01 	eorl	r9,0x1
80003f8e:	b0 89       	st.b	r8[0x0],r9
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);
80003f90:	11 89       	ld.ub	r9,r8[0x0]
80003f92:	a5 69       	lsl	r9,0x4
80003f94:	2f c9       	sub	r9,-4
80003f96:	49 5a       	lddpc	r10,80003fe8 <pdca_int_handler+0x64>
80003f98:	14 09       	add	r9,r10
	
	/*Toggle Index*/
    BufferIndex ^= 0x01;
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
80003f9a:	fe 7a 00 40 	mov	r10,-65472
80003f9e:	95 39       	st.w	r10[0xc],r9
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80003fa0:	30 39       	mov	r9,3
80003fa2:	95 49       	st.w	r10[0x10],r9

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);
80003fa4:	11 8a       	ld.ub	r10,r8[0x0]
80003fa6:	a5 6a       	lsl	r10,0x4
80003fa8:	2f ca       	sub	r10,-4
80003faa:	49 18       	lddpc	r8,80003fec <pdca_int_handler+0x68>
80003fac:	10 0a       	add	r10,r8
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
80003fae:	fe 78 00 00 	mov	r8,-65536
80003fb2:	91 3a       	st.w	r8[0xc],r10
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80003fb4:	91 49       	st.w	r8[0x10],r9
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr;
80003fb6:	70 b8       	ld.w	r8,r8[0x2c]
	
	/*receive SSC data*/
    if(phy_rx_exec != NULL)phy_rx_exec((void *)&RxBuffer[BufferIndex]);
80003fb8:	48 e8       	lddpc	r8,80003ff0 <pdca_int_handler+0x6c>
80003fba:	70 08       	ld.w	r8,r8[0x0]
80003fbc:	58 08       	cp.w	r8,0
80003fbe:	c0 70       	breq	80003fcc <pdca_int_handler+0x48>
80003fc0:	48 99       	lddpc	r9,80003fe4 <pdca_int_handler+0x60>
80003fc2:	13 89       	ld.ub	r9,r9[0x0]
80003fc4:	a5 69       	lsl	r9,0x4
80003fc6:	48 ac       	lddpc	r12,80003fec <pdca_int_handler+0x68>
80003fc8:	12 0c       	add	r12,r9
80003fca:	5d 18       	icall	r8

    /*transmit SSC data*/

	if(phy_tx_exec != NULL)phy_tx_exec((void *)&TxBuffer[BufferIndex]);//phy_tx_func, phy_rx_func
80003fcc:	48 a8       	lddpc	r8,80003ff4 <pdca_int_handler+0x70>
80003fce:	70 08       	ld.w	r8,r8[0x0]
80003fd0:	58 08       	cp.w	r8,0
80003fd2:	c0 70       	breq	80003fe0 <pdca_int_handler+0x5c>
80003fd4:	48 49       	lddpc	r9,80003fe4 <pdca_int_handler+0x60>
80003fd6:	13 89       	ld.ub	r9,r9[0x0]
80003fd8:	a5 69       	lsl	r9,0x4
80003fda:	48 4c       	lddpc	r12,80003fe8 <pdca_int_handler+0x64>
80003fdc:	12 0c       	add	r12,r9
80003fde:	5d 18       	icall	r8

	
	//intDuration = Get_system_register(AVR32_COUNT) - intStartCount;
	
	
}/*End of pdca_int_handler.*/
80003fe0:	d4 02       	popm	lr
80003fe2:	d6 03       	rete
80003fe4:	00 00       	add	r0,r0
80003fe6:	40 b8       	lddsp	r8,sp[0x2c]
80003fe8:	00 00       	add	r0,r0
80003fea:	40 e0       	lddsp	r0,sp[0x38]
80003fec:	00 00       	add	r0,r0
80003fee:	40 c0       	lddsp	r0,sp[0x30]
80003ff0:	00 00       	add	r0,r0
80003ff2:	0a f0       	st.b	--r5,r0
80003ff4:	00 00       	add	r0,r0
80003ff6:	0a f4       	st.b	--r5,r4

80003ff8 <local_start_SSC>:
void local_start_SSC(void)
{
    /*Assign GPIO to SSC.
    gpio_enable_module
    gpio_enable_module_pin*/
    AVR32_GPIO.port[1].pmr0c = 0x00000DC0;
80003ff8:	fe 78 10 00 	mov	r8,-61440
80003ffc:	e0 69 0d c0 	mov	r9,3520
80004000:	f1 49 01 18 	st.w	r8[280],r9
    AVR32_GPIO.port[1].pmr1c = 0x00000DC0;
80004004:	f1 49 01 28 	st.w	r8[296],r9
    AVR32_GPIO.port[1].gperc = 0x00000DC0;
80004008:	f1 49 01 08 	st.w	r8[264],r9

    /*Software reset SSC*/
    (&AVR32_SSC)->cr = AVR32_SSC_CR_SWRST_MASK;
8000400c:	fe 78 34 00 	mov	r8,-52224
80004010:	e0 69 80 00 	mov	r9,32768
80004014:	91 09       	st.w	r8[0x0],r9
    (&AVR32_SSC)->cmr 
80004016:	30 09       	mov	r9,0
80004018:	91 19       	st.w	r8[0x4],r9
                     = AVR32_SSC_CMR_DIV_NOT_ACTIVE << AVR32_SSC_CMR_DIV_OFFSET;

    /*For Slave*/
    (&AVR32_SSC)->tcmr =
8000401a:	e0 69 04 21 	mov	r9,1057
8000401e:	ea 19 3f 20 	orh	r9,0x3f20
80004022:	91 69       	st.w	r8[0x18],r9
	    | 32 << AVR32_SSC_TCMR_STTDLY_OFFSET
	    | 63 << AVR32_SSC_TCMR_PERIOD_OFFSET;


    /*For Slave*/
    (&AVR32_SSC)->tfmr = 31 << AVR32_SSC_TFMR_DATLEN_OFFSET 
80004024:	e0 69 02 9f 	mov	r9,671
80004028:	ea 19 01 00 	orh	r9,0x100
8000402c:	91 79       	st.w	r8[0x1c],r9
	    | 0 << AVR32_SSC_TFMR_FSDEN_OFFSET
	    | 1 << AVR32_SSC_TFMR_FSEDGE_OFFSET;

	/*For Slave*/

	(&AVR32_SSC)->rcmr = AVR32_SSC_RCMR_CKS_RK_PIN << AVR32_SSC_RCMR_CKS_OFFSET
8000402e:	e0 6a 04 02 	mov	r10,1026
80004032:	ea 1a 3f 20 	orh	r10,0x3f20
80004036:	91 4a       	st.w	r8[0x10],r10
	    | 0 << AVR32_SSC_RCMR_STOP_OFFSET
	    | 32 << AVR32_SSC_RCMR_STTDLY_OFFSET
	    | 63 << AVR32_SSC_RCMR_PERIOD_OFFSET;

	/*For Slave*/
	(&AVR32_SSC)->rfmr = 31 << AVR32_SSC_RFMR_DATLEN_OFFSET
80004038:	91 59       	st.w	r8[0x14],r9
	    | 1 << AVR32_SSC_RFMR_MSBF_OFFSET
	    | 2 << AVR32_SSC_RFMR_DATNB_OFFSET
	    | 0 << AVR32_SSC_RFMR_FSLEN_OFFSET
	    | AVR32_SSC_RFMR_FSOS_INPUT_ONLY << AVR32_SSC_RFMR_FSOS_OFFSET
	    | 1 << AVR32_SSC_RFMR_FSEDGE_OFFSET;
}/*End of local_start_SSC.*/
8000403a:	5e fc       	retal	r12

8000403c <local_start_PDC>:
Function: local_start_PDC
Description: none
Called By: void ssc_init(void) -- ssc.c
*/
void local_start_PDC(void)
{
8000403c:	d4 01       	pushm	lr
    /*Toggle Index*/	
    BufferIndex = 1;
8000403e:	30 19       	mov	r9,1
80004040:	49 78       	lddpc	r8,8000409c <local_start_PDC+0x60>
80004042:	b0 89       	st.b	r8[0x0],r9
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
80004044:	fe 78 00 00 	mov	r8,-65536
80004048:	30 7b       	mov	r11,7
8000404a:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
8000404c:	70 b9       	ld.w	r9,r8[0x2c]
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
8000404e:	49 59       	lddpc	r9,800040a0 <local_start_PDC+0x64>
80004050:	f2 ca ff fc 	sub	r10,r9,-4
    BufferIndex = 1;
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
80004054:	91 0a       	st.w	r8[0x0],r10
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
80004056:	30 3a       	mov	r10,3
80004058:	91 2a       	st.w	r8[0x8],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
8000405a:	30 1c       	mov	r12,1
8000405c:	91 1c       	st.w	r8[0x4],r12
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
8000405e:	2e c9       	sub	r9,-20
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
80004060:	91 39       	st.w	r8[0xc],r9
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80004062:	91 4a       	st.w	r8[0x10],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80004064:	30 2c       	mov	r12,2
80004066:	91 6c       	st.w	r8[0x18],r12

	TxBuffer[0].xnl_channel.dword = XNL_IDLE;
80004068:	48 f9       	lddpc	r9,800040a4 <local_start_PDC+0x68>
8000406a:	e0 68 5a 5a 	mov	r8,23130
8000406e:	ea 18 ab cd 	orh	r8,0xabcd
80004072:	93 18       	st.w	r9[0x4],r8
	TxBuffer[0].payload_channel.dword[0] = PAYLOADIDLE0;
80004074:	93 28       	st.w	r9[0x8],r8
	TxBuffer[0].payload_channel.dword[1] = PAYLOADIDLE1;
80004076:	30 0e       	mov	lr,0
80004078:	93 3e       	st.w	r9[0xc],lr
	TxBuffer[1].xnl_channel.dword = XNL_IDLE;
8000407a:	93 58       	st.w	r9[0x14],r8
	TxBuffer[1].payload_channel.dword[0] = PAYLOADIDLE0;
8000407c:	93 68       	st.w	r9[0x18],r8
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;
8000407e:	93 7e       	st.w	r9[0x1c],lr

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
80004080:	fe 78 00 40 	mov	r8,-65472
80004084:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
80004086:	70 be       	ld.w	lr,r8[0x2c]
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
80004088:	f2 ce ff fc 	sub	lr,r9,-4
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
8000408c:	91 0e       	st.w	r8[0x0],lr
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
8000408e:	91 2a       	st.w	r8[0x8],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
80004090:	91 1b       	st.w	r8[0x4],r11
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
80004092:	2e c9       	sub	r9,-20
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
80004094:	91 39       	st.w	r8[0xc],r9
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80004096:	91 4a       	st.w	r8[0x10],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80004098:	91 6c       	st.w	r8[0x18],r12
}/*End of local_start_PDC.*/
8000409a:	d8 02       	popm	pc
8000409c:	00 00       	add	r0,r0
8000409e:	40 b8       	lddsp	r8,sp[0x2c]
800040a0:	00 00       	add	r0,r0
800040a2:	40 c0       	lddsp	r0,sp[0x30]
800040a4:	00 00       	add	r0,r0
800040a6:	40 e0       	lddsp	r0,sp[0x38]

800040a8 <register_rx_tx_func>:
Description: register the rx function(callback function)
Called By: phy_init -- physical.c
*/
void register_rx_tx_func(void (*rx_exec)(void *),  void ( *tx_exec)(void *))
{
	 phy_rx_exec = rx_exec;
800040a8:	48 38       	lddpc	r8,800040b4 <register_rx_tx_func+0xc>
800040aa:	91 0c       	st.w	r8[0x0],r12
	 phy_tx_exec = tx_exec;//phy_tx_func, phy_rx_func
800040ac:	48 38       	lddpc	r8,800040b8 <register_rx_tx_func+0x10>
800040ae:	91 0b       	st.w	r8[0x0],r11
	 
}/*End of register_tx_rx_func.*/
800040b0:	5e fc       	retal	r12
800040b2:	00 00       	add	r0,r0
800040b4:	00 00       	add	r0,r0
800040b6:	0a f0       	st.b	--r5,r0
800040b8:	00 00       	add	r0,r0
800040ba:	0a f4       	st.b	--r5,r4

800040bc <ssc_init>:
    local_start_SSC -- ssc.c
    local_start_PDC -- ssc.c
Called By: phy_init -- physical.c
*/
void ssc_init(void)
{		
800040bc:	d4 01       	pushm	lr
    /*Set up PB03 to watch FS.*/
    AVR32_GPIO.port[1].oderc = 0x00000002;
800040be:	fe 78 10 00 	mov	r8,-61440
800040c2:	30 29       	mov	r9,2
800040c4:	f1 49 01 48 	st.w	r8[328],r9
    AVR32_GPIO.port[1].gpers = 0x00000002;
800040c8:	f1 49 01 04 	st.w	r8[260],r9

    /*Waits for radio to start making FSYNC.*/
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
800040cc:	10 99       	mov	r9,r8
800040ce:	f2 f8 01 60 	ld.w	r8,r9[352]
800040d2:	e2 18 00 02 	andl	r8,0x2,COH
800040d6:	cf c0       	breq	800040ce <ssc_init+0x12>
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
800040d8:	fe 79 10 00 	mov	r9,-61440
800040dc:	f2 f8 01 60 	ld.w	r8,r9[352]
800040e0:	e2 18 00 02 	andl	r8,0x2,COH
800040e4:	cf c1       	brne	800040dc <ssc_init+0x20>
				
    INTC_register_interrupt (
800040e6:	30 3a       	mov	r10,3
800040e8:	36 0b       	mov	r11,96
800040ea:	48 bc       	lddpc	r12,80004114 <ssc_init+0x58>
800040ec:	f0 1f 00 0b 	mcall	80004118 <ssc_init+0x5c>
        , AVR32_PDCA_IRQ_0
        , AVR32_INTC_INT3
    );
				
    /*config the SSC*/
    local_start_SSC();
800040f0:	f0 1f 00 0b 	mcall	8000411c <ssc_init+0x60>

    /*config the PDCA*/
    local_start_PDC();
800040f4:	f0 1f 00 0b 	mcall	80004120 <ssc_init+0x64>
		
    /*Start the SSC Physical Layer.*/

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
800040f8:	fe 79 00 00 	mov	r9,-65536
800040fc:	30 18       	mov	r8,1
800040fe:	93 58       	st.w	r9[0x14],r8
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80004100:	fe 7a 00 40 	mov	r10,-65472
80004104:	95 58       	st.w	r10[0x14],r8
    (&AVR32_SSC)->cr = AVR32_SSC_CR_RXEN_MASK | AVR32_SSC_CR_TXEN_MASK;
80004106:	e0 6b 01 01 	mov	r11,257
8000410a:	fe 7a 34 00 	mov	r10,-52224
8000410e:	95 0b       	st.w	r10[0x0],r11
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->ier = 
80004110:	93 88       	st.w	r9[0x20],r8
                                                            AVR32_PDCA_RCZ_MASK;
}/*End of ssc_init.*/
80004112:	d8 02       	popm	pc
80004114:	80 00       	ld.sh	r0,r0[0x0]
80004116:	3f 84       	mov	r4,-8
80004118:	80 00       	ld.sh	r0,r0[0x0]
8000411a:	4b 98       	lddpc	r8,800041fc <xcmp_data_session_req+0x84>
8000411c:	80 00       	ld.sh	r0,r0[0x0]
8000411e:	3f f8       	mov	r8,-1
80004120:	80 00       	ld.sh	r0,r0[0x0]
80004122:	40 3c       	lddsp	r12,sp[0xc]

80004124 <xcmp_register_app_list>:
Calls: 
Called By: app_init -- app.c
*/
void xcmp_register_app_list(void * list)
{
	app_list = (app_exec_t *)list;
80004124:	48 28       	lddpc	r8,8000412c <xcmp_register_app_list+0x8>
80004126:	91 0c       	st.w	r8[0x0],r12
}
80004128:	5e fc       	retal	r12
8000412a:	00 00       	add	r0,r0
8000412c:	00 00       	add	r0,r0
8000412e:	41 00       	lddsp	r0,sp[0x40]

80004130 <xcmp_tx>:
Calls:   
	xnl_tx -- xnl.c
Called By: ...
*/
static void xcmp_tx( xcmp_fragment_t * xcmp, U8 payload_len)
{
80004130:	eb cd 40 80 	pushm	r7,lr
80004134:	fa cd 01 00 	sub	sp,sp,256
80004138:	16 97       	mov	r7,r11
	Length :xnl length + checksum
	= checksum + xnl header + xcmp opcode + xcmp payload
	= 0x02 + 0x0C + 0x02 + xcmp payload
	= 0x10 + xcmp payload
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | ( 0x10 + payload_len);
8000413a:	16 98       	mov	r8,r11
8000413c:	2f 08       	sub	r8,-16
8000413e:	af a8       	sbr	r8,0xe
80004140:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE; 
80004142:	3f f8       	mov	r8,-1
80004144:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG;
80004146:	30 b9       	mov	r9,11
80004148:	ba 29       	st.h	sp[0x4],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;	
8000414a:	ba 38       	st.h	sp[0x6],r8
	xnl_frame.xnl_header.destination = DEFAULT_VALUE;
8000414c:	ba 48       	st.h	sp[0x8],r8
	xnl_frame.xnl_header.source = DEFAULT_VALUE;	
8000414e:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80004150:	ba 68       	st.h	sp[0xc],r8
	
	/*insert xcmp frame data*/
	memcpy(&xnl_frame.xnl_payload.xnl_content_data_msg, xcmp, payload_len + 2);
80004152:	f6 ca ff fe 	sub	r10,r11,-2
80004156:	18 9b       	mov	r11,r12
80004158:	fa cc ff f0 	sub	r12,sp,-16
8000415c:	f0 1f 00 05 	mcall	80004170 <xcmp_tx+0x40>
	xnl_frame.xnl_header.payload_length = payload_len + 2;	
80004160:	2f e7       	sub	r7,-2
80004162:	ba 77       	st.h	sp[0xe],r7
	
	/* send xnl frame*/	
	xnl_tx(&xnl_frame);
80004164:	1a 9c       	mov	r12,sp
80004166:	f0 1f 00 04 	mcall	80004174 <xcmp_tx+0x44>
}
8000416a:	2c 0d       	sub	sp,-256
8000416c:	e3 cd 80 80 	ldm	sp++,r7,pc
80004170:	80 00       	ld.sh	r0,r0[0x0]
80004172:	69 f4       	ld.w	r4,r4[0x7c]
80004174:	80 00       	ld.sh	r0,r0[0x0]
80004176:	47 38       	lddsp	r8,sp[0x1cc]

80004178 <xcmp_data_session_req>:
Description: send data-session request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_data_session_req(void *message, U16 length, U8 dest)
{
80004178:	eb cd 40 e0 	pushm	r5-r7,lr
8000417c:	fa cd 00 d0 	sub	sp,sp,208
80004180:	18 95       	mov	r5,r12
80004182:	16 96       	mov	r6,r11
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
	
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
	
	if (length > 20)return -1;
80004184:	31 48       	mov	r8,20
80004186:	f0 0b 19 00 	cp.h	r11,r8
8000418a:	e0 8b 00 33 	brhi	800041f0 <xcmp_data_session_req+0x78>
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
	
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
8000418e:	fa c7 ff f8 	sub	r7,sp,-8
	//U8 SizeofAddress = Remote_Mototrbo_Address_Size;// 3;//可能会变化
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
80004192:	e0 68 04 1d 	mov	r8,1053
80004196:	ba 38       	st.h	sp[0x6],r8
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
	
	if (length > 20)return -1;
	
	ptr->Function = Single_Data_Uint;
80004198:	30 18       	mov	r8,1
8000419a:	ae 88       	st.b	r7[0x0],r8
	
	ptr->DataDefinition.Data_Protocol_Version = TMP_Ver_1_1;//0x20
8000419c:	32 08       	mov	r8,32
8000419e:	ae 98       	st.b	r7[0x1],r8
	
	ptr->DataDefinition.Dest_Address.Remote_Address_Type = Remote_IPV4_Address;//0x02
800041a0:	30 28       	mov	r8,2
800041a2:	ae a8       	st.b	r7[0x2],r8
	
	ptr->DataDefinition.Dest_Address.Remote_Address_Size = Remote_IPV4_Address_Size;//0x04
800041a4:	30 48       	mov	r8,4
800041a6:	ae b8       	st.b	r7[0x3],r8
	
	unsigned int addr = 0x0C000000 | (dest & 0x00FFFFFF);
800041a8:	ea 1a 0c 00 	orh	r10,0xc00
800041ac:	50 0a       	stdsp	sp[0x0],r10
	memcpy(ptr->DataDefinition.Dest_Address.Remote_Address, &addr, Remote_IPV4_Address_Size);
800041ae:	30 4a       	mov	r10,4
800041b0:	1a 9b       	mov	r11,sp
800041b2:	fa cc ff f4 	sub	r12,sp,-12
800041b6:	f0 1f 00 11 	mcall	800041f8 <xcmp_data_session_req+0x80>
	//ptr->DataDefinition.Dest_Address.Remote_Address[0] = 0x0C;//12
	//ptr->DataDefinition.Dest_Address.Remote_Address[1] = 0x00;//0
	//ptr->DataDefinition.Dest_Address.Remote_Address[2] = 0x00;//0
	//ptr->DataDefinition.Dest_Address.Remote_Address[3] = 0x02;//2
	
	ptr->DataDefinition.Dest_Address.Remote_Port_Com[0] = (Remote_Port >>8) & 0xFF;//4007
800041ba:	30 f8       	mov	r8,15
800041bc:	ef 68 00 08 	st.b	r7[8],r8
	ptr->DataDefinition.Dest_Address.Remote_Port_Com[1] = Remote_Port & 0xFF;//
800041c0:	3a 78       	mov	r8,-89
800041c2:	ef 68 00 09 	st.b	r7[9],r8
	
    
	ptr->DataPayload.Session_ID_Number = Session_ID;//0x00
800041c6:	30 08       	mov	r8,0
800041c8:	ef 68 00 0a 	st.b	r7[10],r8
	
	ptr->DataPayload.DataPayload_Length[0] =(length >> 8) & 0xFF ;//可能会变化
800041cc:	f5 d6 c0 10 	bfextu	r10,r6,0x0,0x10
800041d0:	f4 08 16 08 	lsr	r8,r10,0x8
800041d4:	ef 68 00 0b 	st.b	r7[11],r8
	ptr->DataPayload.DataPayload_Length[1] =length & 0xFF  ;//可能会变化
800041d8:	ef 66 00 0c 	st.b	r7[12],r6
	
	memcpy(&(ptr->DataPayload.DataPayload[0]), message, length);
800041dc:	0a 9b       	mov	r11,r5
800041de:	fa cc ff eb 	sub	r12,sp,-21
800041e2:	f0 1f 00 06 	mcall	800041f8 <xcmp_data_session_req+0x80>
	
	xcmp_tx( &xcmp_farme, sizeof(DataSession_req_t) - 7);
800041e6:	31 ab       	mov	r11,26
800041e8:	fa cc ff fa 	sub	r12,sp,-6
800041ec:	f0 1f 00 04 	mcall	800041fc <xcmp_data_session_req+0x84>
}
800041f0:	2c cd       	sub	sp,-208
800041f2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800041f6:	00 00       	add	r0,r0
800041f8:	80 00       	ld.sh	r0,r0[0x0]
800041fa:	69 f4       	ld.w	r4,r4[0x7c]
800041fc:	80 00       	ld.sh	r0,r0[0x0]
800041fe:	41 30       	lddsp	r0,sp[0x4c]

80004200 <xcmp_DeviceInitializationStatus_request>:
Description: send device initialization status request
Calls: xcmp_tx
Called By:...
*/
void xcmp_DeviceInitializationStatus_request(void)
{
80004200:	d4 01       	pushm	lr
80004202:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
		
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_BRDCAST | DEVICE_INITIALIZATION_STATUS;
80004206:	fe 78 b4 00 	mov	r8,-19456
8000420a:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	DeviceInitializationStatus_brdcst_t * ptr 
						 = (DeviceInitializationStatus_brdcst_t *)xcmp_farme.u8;
8000420c:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*xcmp version 8.1.0.5*///版本号未正确填写，纠正
	ptr->XCMPVersion[0] = 0x08;
80004210:	30 89       	mov	r9,8
80004212:	b0 89       	st.b	r8[0x0],r9
	ptr->XCMPVersion[1] = 0x01;
80004214:	30 19       	mov	r9,1
80004216:	b0 99       	st.b	r8[0x1],r9
	ptr->XCMPVersion[2] = 0x00;
80004218:	30 09       	mov	r9,0
8000421a:	b0 a9       	st.b	r8[0x2],r9
	ptr->XCMPVersion[3] = 0x05;
8000421c:	30 5a       	mov	r10,5
8000421e:	b0 ba       	st.b	r8[0x3],r10
	/*
	0x00:
	This is the message that the device sends at power up or after a reset. It 
	will give the initial status and capabilities for the device.
	*/
	ptr->DeviceInitType = 0x00;
80004220:	b0 c9       	st.b	r8[0x4],r9
	types of devices may provide a set of services to the radio system, but do 
	not have the ability to be the master.
	
	0x07:OptionBoard,3rd party Option Board-based application.
	*/
	ptr->DeviceStatusInfo.DeviceType = 0x07;
80004222:	30 7a       	mov	r10,7
80004224:	b0 da       	st.b	r8[0x5],r10
	
	/*Power Up Success, Device has powered up with no errors*/
	ptr->DeviceStatusInfo.DeviceStatus[0] = 0x00;
80004226:	b0 e9       	st.b	r8[0x6],r9
	ptr->DeviceStatusInfo.DeviceStatus[1] = 0x00;
80004228:	b0 f9       	st.b	r8[0x7],r9
	
	/*
	This number is the size of the Device Descriptor data structure with a 
	maximum size not exceeding 255 bytes.
	*/
	ptr->DeviceStatusInfo.DeviceDescriptorSize = 0x00;
8000422a:	f1 69 00 08 	st.b	r8[8],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme
8000422e:	30 9b       	mov	r11,9
80004230:	fa cc ff fe 	sub	r12,sp,-2
80004234:	f0 1f 00 02 	mcall	8000423c <xcmp_DeviceInitializationStatus_request+0x3c>
		, sizeof(DeviceInitializationStatus_brdcst_t) - MAX_DEVICE_DESC_SIZE);
}
80004238:	2c dd       	sub	sp,-204
8000423a:	d8 02       	popm	pc
8000423c:	80 00       	ld.sh	r0,r0[0x0]
8000423e:	41 30       	lddsp	r0,sp[0x4c]

80004240 <xcmp_opcode_not_supported>:
Description: register the app list
Calls: xcmp_tx
Called By:...
*/
void xcmp_opcode_not_supported( void )
{
80004240:	d4 01       	pushm	lr
80004242:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REPLY;
80004246:	fe 78 80 00 	mov	r8,-32768
8000424a:	ba 18       	st.h	sp[0x2],r8
	
	/*The radio does not support this opcode.*/
	xcmp_farme.u8[0] = xcmp_Res_Opcode_Not_Supported;
8000424c:	30 38       	mov	r8,3
8000424e:	ba c8       	st.b	sp[0x4],r8
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, 1);
80004250:	30 1b       	mov	r11,1
80004252:	fa cc ff fe 	sub	r12,sp,-2
80004256:	f0 1f 00 03 	mcall	80004260 <xcmp_opcode_not_supported+0x20>
}
8000425a:	2c dd       	sub	sp,-204
8000425c:	d8 02       	popm	pc
8000425e:	00 00       	add	r0,r0
80004260:	80 00       	ld.sh	r0,r0[0x0]
80004262:	41 30       	lddsp	r0,sp[0x4c]

80004264 <xcmp_exec_func>:
Description: Perform XCMP corresponding functions
Calls:   
Called By: xcmp_rx_process--task
*/
static void xcmp_exec_func(app_exec_t * exec, xcmp_fragment_t * xcmp)
{
80004264:	d4 01       	pushm	lr
	/*The message types*/
	switch(xcmp->xcmp_opcode & 0xF000)
80004266:	96 88       	ld.uh	r8,r11[0x0]
80004268:	e2 18 f0 00 	andl	r8,0xf000,COH
8000426c:	e0 48 80 00 	cp.w	r8,32768
80004270:	c0 f0       	breq	8000428e <xcmp_exec_func+0x2a>
80004272:	e0 48 b0 00 	cp.w	r8,45056
80004276:	c1 20       	breq	8000429a <xcmp_exec_func+0x36>
80004278:	58 08       	cp.w	r8,0
8000427a:	c1 51       	brne	800042a4 <xcmp_exec_func+0x40>
	{
		case XCMP_REQUEST:
			if(NULL != exec->xcmp_rx_req)
8000427c:	78 08       	ld.w	r8,r12[0x0]
8000427e:	58 08       	cp.w	r8,0
80004280:	c0 40       	breq	80004288 <xcmp_exec_func+0x24>
			{
				exec->xcmp_rx_req(xcmp);
80004282:	16 9c       	mov	r12,r11
80004284:	5d 18       	icall	r8
80004286:	d8 02       	popm	pc
			}
			else 
			{
				/*No function to register the request message*/
				/*send not supported opcode to raido */
				xcmp_opcode_not_supported();
80004288:	f0 1f 00 08 	mcall	800042a8 <xcmp_exec_func+0x44>
8000428c:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_REPLY:		
			if(NULL != exec->xcmp_rx_reply)
8000428e:	78 18       	ld.w	r8,r12[0x4]
80004290:	58 08       	cp.w	r8,0
80004292:	c0 90       	breq	800042a4 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_reply(xcmp);
80004294:	16 9c       	mov	r12,r11
80004296:	5d 18       	icall	r8
80004298:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_BRDCAST:	
			if(NULL != exec->xcmp_rx_brdcst)
8000429a:	78 28       	ld.w	r8,r12[0x8]
8000429c:	58 08       	cp.w	r8,0
8000429e:	c0 30       	breq	800042a4 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_brdcst(xcmp);
800042a0:	16 9c       	mov	r12,r11
800042a2:	5d 18       	icall	r8
800042a4:	d8 02       	popm	pc
800042a6:	00 00       	add	r0,r0
800042a8:	80 00       	ld.sh	r0,r0[0x0]
800042aa:	42 40       	lddsp	r0,sp[0x90]

800042ac <xcmp_IdleTestTone>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_IdleTestTone(void)
{
800042ac:	d4 01       	pushm	lr
800042ae:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | TONE_CONTROL;
800042b2:	e0 68 04 09 	mov	r8,1033
800042b6:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	ToneControl_req_t * ptr = (ToneControl_req_t *)xcmp_farme.u8;
800042b8:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*Starts the specific tone*/	
	ptr->Function = Tone_Start;
800042bc:	30 19       	mov	r9,1
800042be:	b0 89       	st.b	r8[0x0],r9
	
	/*This tone shall be sounded when radio landed on a priority channel*/
	ptr->ToneIdentifier[0] = (Priority_Beep >> 8) & 0xFF;
800042c0:	30 09       	mov	r9,0
800042c2:	b0 99       	st.b	r8[0x1],r9
	ptr->ToneIdentifier[1] = Priority_Beep & 0xFF;
800042c4:	30 ca       	mov	r10,12
800042c6:	b0 aa       	st.b	r8[0x2],r10
	
	/*
	The alert tone is played according to any rules for alert tones, given the 
	current volume setting. Settings for this field are 8 to 255 (0x08 ?0xFF).
	*/
	ptr->ToneVolumeControl = Current_Volume;
800042c8:	b0 b9       	st.b	r8[0x3],r9
	
	/*clear reserved*/
	memset(ptr->Reserved, 0, 8);
800042ca:	fb 69 00 08 	st.b	sp[8],r9
800042ce:	fa c8 ff f7 	sub	r8,sp,-9
800042d2:	b0 89       	st.b	r8[0x0],r9
800042d4:	fa c8 ff f6 	sub	r8,sp,-10
800042d8:	b0 89       	st.b	r8[0x0],r9
800042da:	fa c8 ff f5 	sub	r8,sp,-11
800042de:	b0 89       	st.b	r8[0x0],r9
800042e0:	fa c8 ff f4 	sub	r8,sp,-12
800042e4:	b0 89       	st.b	r8[0x0],r9
800042e6:	fa c8 ff f3 	sub	r8,sp,-13
800042ea:	b0 89       	st.b	r8[0x0],r9
800042ec:	fa c8 ff f2 	sub	r8,sp,-14
800042f0:	b0 89       	st.b	r8[0x0],r9
800042f2:	fa c8 ff f1 	sub	r8,sp,-15
800042f6:	b0 89       	st.b	r8[0x0],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(ToneControl_req_t));
800042f8:	30 cb       	mov	r11,12
800042fa:	fa cc ff fe 	sub	r12,sp,-2
800042fe:	f0 1f 00 03 	mcall	80004308 <xcmp_IdleTestTone+0x5c>
}
80004302:	2c dd       	sub	sp,-204
80004304:	d8 02       	popm	pc
80004306:	00 00       	add	r0,r0
80004308:	80 00       	ld.sh	r0,r0[0x0]
8000430a:	41 30       	lddsp	r0,sp[0x4c]

8000430c <xcmp_init>:
	xQueueCreate -- freertos
	xTaskCreate -- freertos
Called By: main -- main.c
*/
void xcmp_init(void)
{
8000430c:	d4 01       	pushm	lr
	/*register the xcmp function(callback function)*/
	xnl_register_xcmp_func( xcmp_rx );
8000430e:	48 dc       	lddpc	r12,80004340 <xcmp_init+0x34>
80004310:	f0 1f 00 0d 	mcall	80004344 <xcmp_init+0x38>
	
	/*initialize the queue*/
	xcmp_frame_rx = xQueueCreate(20, sizeof(xcmp_fragment_t *));
80004314:	30 4b       	mov	r11,4
80004316:	31 4c       	mov	r12,20
80004318:	f0 1f 00 0c 	mcall	80004348 <xcmp_init+0x3c>
8000431c:	48 c8       	lddpc	r8,8000434c <xcmp_init+0x40>
8000431e:	91 0c       	st.w	r8[0x0],r12
	/*create task*/	
	/*this task is used to execute xcmp message*/
	xTaskCreate(
80004320:	30 09       	mov	r9,0
80004322:	1a d9       	st.w	--sp,r9
80004324:	1a d9       	st.w	--sp,r9
80004326:	1a d9       	st.w	--sp,r9
80004328:	30 38       	mov	r8,3
8000432a:	e0 6a 01 80 	mov	r10,384
8000432e:	48 9b       	lddpc	r11,80004350 <xcmp_init+0x44>
80004330:	48 9c       	lddpc	r12,80004354 <xcmp_init+0x48>
80004332:	f0 1f 00 0a 	mcall	80004358 <xcmp_init+0x4c>
	,  tskXCMP_PRIORITY
	,  NULL
	);
	
	/*initialize the xnl*/
	xnl_init();
80004336:	f0 1f 00 0a 	mcall	8000435c <xcmp_init+0x50>
8000433a:	2f dd       	sub	sp,-12
	
}
8000433c:	d8 02       	popm	pc
8000433e:	00 00       	add	r0,r0
80004340:	80 00       	ld.sh	r0,r0[0x0]
80004342:	44 5c       	lddsp	r12,sp[0x114]
80004344:	80 00       	ld.sh	r0,r0[0x0]
80004346:	44 a8       	lddsp	r8,sp[0x128]
80004348:	80 00       	ld.sh	r0,r0[0x0]
8000434a:	56 d0       	stdsp	sp[0x1b4],r0
8000434c:	00 00       	add	r0,r0
8000434e:	0b 10       	ld.sh	r0,r5++
80004350:	80 00       	ld.sh	r0,r0[0x0]
80004352:	c9 e4       	brge	8000428e <xcmp_exec_func+0x2a>
80004354:	80 00       	ld.sh	r0,r0[0x0]
80004356:	43 60       	lddsp	r0,sp[0xd8]
80004358:	80 00       	ld.sh	r0,r0[0x0]
8000435a:	5d a4       	*unknown*
8000435c:	80 00       	ld.sh	r0,r0[0x0]
8000435e:	44 e0       	lddsp	r0,sp[0x138]

80004360 <xcmp_rx_process>:
Calls: xQueueReceive -- freerots
	xcmp_exec_func
Called By: task
*/
static void xcmp_rx_process(void * pvParameters)
{
80004360:	d4 31       	pushm	r0-r7,lr
80004362:	20 1d       	sub	sp,4
	xcmp_fragment_t xcmp;
	xcmp_fragment_t * ptr;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
80004364:	4b 16       	lddpc	r6,80004428 <xcmp_rx_process+0xc8>
80004366:	30 05       	mov	r5,0
80004368:	31 44       	mov	r4,20
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
8000436a:	4b 13       	lddpc	r3,8000442c <xcmp_rx_process+0xcc>
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
					break;
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
8000436c:	4b 12       	lddpc	r2,80004430 <xcmp_rx_process+0xd0>
						, ptr);
					break;
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
8000436e:	4b 21       	lddpc	r1,80004434 <xcmp_rx_process+0xd4>
					break;
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
80004370:	4b 20       	lddpc	r0,80004438 <xcmp_rx_process+0xd8>
	xcmp_fragment_t xcmp;
	xcmp_fragment_t * ptr;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
80004372:	6c 0c       	ld.w	r12,r6[0x0]
80004374:	0a 99       	mov	r9,r5
80004376:	08 9a       	mov	r10,r4
80004378:	1a 9b       	mov	r11,sp
8000437a:	f0 1f 00 31 	mcall	8000443c <xcmp_rx_process+0xdc>
8000437e:	58 1c       	cp.w	r12,1
80004380:	cf 91       	brne	80004372 <xcmp_rx_process+0x12>
		{									
			if(NULL == ptr)
80004382:	40 0b       	lddsp	r11,sp[0x0]
80004384:	58 0b       	cp.w	r11,0
80004386:	cf 60       	breq	80004372 <xcmp_rx_process+0x12>
				continue;
			}
			
			//log("\n\r R_xcmp : %4x \n\r",ptr->xcmp_opcode);//log:R_xcmp指令	
						
			switch(ptr->xcmp_opcode & 0x0FFF)
80004388:	96 0a       	ld.sh	r10,r11[0x0]
8000438a:	f3 da c0 10 	bfextu	r9,r10,0x0,0x10
8000438e:	f1 d9 c0 0c 	bfextu	r8,r9,0x0,0xc
80004392:	59 c8       	cp.w	r8,28
80004394:	c1 e0       	breq	800043d0 <xcmp_rx_process+0x70>
80004396:	e0 89 00 07 	brgt	800043a4 <xcmp_rx_process+0x44>
8000439a:	58 e8       	cp.w	r8,14
8000439c:	c0 e0       	breq	800043b8 <xcmp_rx_process+0x58>
8000439e:	58 f8       	cp.w	r8,15
800043a0:	c2 41       	brne	800043e8 <xcmp_rx_process+0x88>
800043a2:	c0 f8       	rjmp	800043c0 <xcmp_rx_process+0x60>
800043a4:	e0 48 01 09 	cp.w	r8,265
800043a8:	c1 80       	breq	800043d8 <xcmp_rx_process+0x78>
800043aa:	e0 48 01 0a 	cp.w	r8,266
800043ae:	c1 90       	breq	800043e0 <xcmp_rx_process+0x80>
800043b0:	e0 48 00 2c 	cp.w	r8,44
800043b4:	c1 a1       	brne	800043e8 <xcmp_rx_process+0x88>
800043b6:	c0 98       	rjmp	800043c8 <xcmp_rx_process+0x68>
			{
				case RADIO_STATUS:				
					xcmp_exec_func(&radio_status, ptr);
800043b8:	4a 2c       	lddpc	r12,80004440 <xcmp_rx_process+0xe0>
800043ba:	f0 1f 00 23 	mcall	80004444 <xcmp_rx_process+0xe4>
					break;
800043be:	c2 f8       	rjmp	8000441c <xcmp_rx_process+0xbc>
					
				case VERSION_INFORMATION:
					xcmp_exec_func(&version_information, ptr);
800043c0:	4a 2c       	lddpc	r12,80004448 <xcmp_rx_process+0xe8>
800043c2:	f0 1f 00 21 	mcall	80004444 <xcmp_rx_process+0xe4>
					break;
800043c6:	c2 b8       	rjmp	8000441c <xcmp_rx_process+0xbc>
					
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
800043c8:	4a 1c       	lddpc	r12,8000444c <xcmp_rx_process+0xec>
800043ca:	f0 1f 00 1f 	mcall	80004444 <xcmp_rx_process+0xe4>
					break;
800043ce:	c2 78       	rjmp	8000441c <xcmp_rx_process+0xbc>
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
800043d0:	04 9c       	mov	r12,r2
800043d2:	f0 1f 00 1d 	mcall	80004444 <xcmp_rx_process+0xe4>
						, ptr);
					break;
800043d6:	c2 38       	rjmp	8000441c <xcmp_rx_process+0xbc>
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
800043d8:	02 9c       	mov	r12,r1
800043da:	f0 1f 00 1b 	mcall	80004444 <xcmp_rx_process+0xe4>
					break;
800043de:	c1 f8       	rjmp	8000441c <xcmp_rx_process+0xbc>
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
800043e0:	00 9c       	mov	r12,r0
800043e2:	f0 1f 00 19 	mcall	80004444 <xcmp_rx_process+0xe4>
					break;
800043e6:	c1 b8       	rjmp	8000441c <xcmp_rx_process+0xbc>
					
				default:
				
					/*the xcmp message not in order list*/
					/*over the length of the list*/
					if((0x0400 != (ptr->xcmp_opcode & 0x0400)) 
800043e8:	12 98       	mov	r8,r9
800043ea:	e2 18 04 00 	andl	r8,0x400,COH
800043ee:	c0 70       	breq	800043fc <xcmp_rx_process+0x9c>
800043f0:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
800043f4:	e0 48 00 68 	cp.w	r8,104
800043f8:	e0 8a 00 08 	brle	80004408 <xcmp_rx_process+0xa8>
						|| (MAX_APP_FUNC <= (ptr->xcmp_opcode & 0x00FF))
					)
					{
						/*xcmp request*/
						if( XCMP_REQUEST == (ptr->xcmp_opcode & 0xF000))
800043fc:	e2 19 f0 00 	andl	r9,0xf000,COH
80004400:	c0 e1       	brne	8000441c <xcmp_rx_process+0xbc>
						{
							/*send not supported opcode to raido */
							xcmp_opcode_not_supported();
80004402:	f0 1f 00 14 	mcall	80004450 <xcmp_rx_process+0xf0>
80004406:	c0 b8       	rjmp	8000441c <xcmp_rx_process+0xbc>
						}
					}
					else
					{					
						xcmp_exec_func( &app_list[ptr->xcmp_opcode & 0x00FF]
80004408:	f9 da c0 08 	bfextu	r12,r10,0x0,0x8
8000440c:	f8 0c 00 1c 	add	r12,r12,r12<<0x1
80004410:	49 19       	lddpc	r9,80004454 <xcmp_rx_process+0xf4>
80004412:	72 08       	ld.w	r8,r9[0x0]
80004414:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80004418:	f0 1f 00 0b 	mcall	80004444 <xcmp_rx_process+0xe4>
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
8000441c:	66 0c       	ld.w	r12,r3[0x0]
8000441e:	40 0b       	lddsp	r11,sp[0x0]
80004420:	f0 1f 00 0e 	mcall	80004458 <xcmp_rx_process+0xf8>
80004424:	ca 7b       	rjmp	80004372 <xcmp_rx_process+0x12>
80004426:	00 00       	add	r0,r0
80004428:	00 00       	add	r0,r0
8000442a:	0b 10       	ld.sh	r0,r5++
8000442c:	00 00       	add	r0,r0
8000442e:	0a a8       	st.w	r5++,r8
80004430:	00 00       	add	r0,r0
80004432:	0b 20       	ld.uh	r0,r5++
80004434:	00 00       	add	r0,r0
80004436:	0b 14       	ld.sh	r4,r5++
80004438:	00 00       	add	r0,r0
8000443a:	0b 04       	ld.w	r4,r5++
8000443c:	80 00       	ld.sh	r0,r0[0x0]
8000443e:	53 c4       	stdsp	sp[0xf0],r4
80004440:	00 00       	add	r0,r0
80004442:	0b 38       	ld.ub	r8,r5++
80004444:	80 00       	ld.sh	r0,r0[0x0]
80004446:	42 64       	lddsp	r4,sp[0x98]
80004448:	00 00       	add	r0,r0
8000444a:	0a f8       	st.b	--r5,r8
8000444c:	00 00       	add	r0,r0
8000444e:	0b 2c       	ld.uh	r12,r5++
80004450:	80 00       	ld.sh	r0,r0[0x0]
80004452:	42 40       	lddsp	r0,sp[0x90]
80004454:	00 00       	add	r0,r0
80004456:	41 00       	lddsp	r0,sp[0x40]
80004458:	80 00       	ld.sh	r0,r0[0x0]
8000445a:	2a 44       	sub	r4,-92

8000445c <xcmp_rx>:
Calls:   
	xQueueSend -- xnl.c
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
8000445c:	eb cd 40 90 	pushm	r4,r7,lr
80004460:	20 1d       	sub	sp,4
80004462:	fa c4 ff f0 	sub	r4,sp,-16
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
80004466:	48 c8       	lddpc	r8,80004494 <xcmp_rx+0x38>
80004468:	70 0c       	ld.w	r12,r8[0x0]
8000446a:	f0 1f 00 0c 	mcall	80004498 <xcmp_rx+0x3c>
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
8000446e:	c1 00       	breq	8000448e <xcmp_rx+0x32>
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
80004470:	fa c7 ff fc 	sub	r7,sp,-4
80004474:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
	{
		memcpy(xcmp_ptr, &xcmp, sizeof(xcmp_fragment_t));				
80004476:	e0 6a 00 ca 	mov	r10,202
8000447a:	08 9b       	mov	r11,r4
8000447c:	f0 1f 00 08 	mcall	8000449c <xcmp_rx+0x40>
		xQueueSend(xcmp_frame_rx, &xcmp_ptr, 0);	
80004480:	48 88       	lddpc	r8,800044a0 <xcmp_rx+0x44>
80004482:	70 0c       	ld.w	r12,r8[0x0]
80004484:	30 09       	mov	r9,0
80004486:	12 9a       	mov	r10,r9
80004488:	1a 9b       	mov	r11,sp
8000448a:	f0 1f 00 07 	mcall	800044a4 <xcmp_rx+0x48>
	}	
}
8000448e:	2f fd       	sub	sp,-4
80004490:	e3 cd 80 90 	ldm	sp++,r4,r7,pc
80004494:	00 00       	add	r0,r0
80004496:	0a a8       	st.w	r5++,r8
80004498:	80 00       	ld.sh	r0,r0[0x0]
8000449a:	2f b0       	sub	r0,-5
8000449c:	80 00       	ld.sh	r0,r0[0x0]
8000449e:	69 f4       	ld.w	r4,r4[0x7c]
800044a0:	00 00       	add	r0,r0
800044a2:	0b 10       	ld.sh	r0,r5++
800044a4:	80 00       	ld.sh	r0,r0[0x0]
800044a6:	55 d0       	stdsp	sp[0x174],r0

800044a8 <xnl_register_xcmp_func>:
Function: xnl_register_xcmp_func
Description: register the xcmp function(callback function)
*/
void xnl_register_xcmp_func( void ( *func)(xnl_content_data_msg_t))
{
	 xcmp_exec = func;
800044a8:	48 28       	lddpc	r8,800044b0 <xnl_register_xcmp_func+0x8>
800044aa:	91 0c       	st.w	r8[0x0],r12
}
800044ac:	5e fc       	retal	r12
800044ae:	00 00       	add	r0,r0
800044b0:	00 00       	add	r0,r0
800044b2:	0b 68       	ld.uh	r8,--r5

800044b4 <xnl_get_msg_ack_func>:
Description: process while receive msg ack.
Calls:xSemaphoreGive--freertos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
800044b4:	d4 01       	pushm	lr
	
	DestinationAddress = xnl->xnl_header.destination;
	/*No timeout*/		
	 //One relationship is controlled by a state machine, only the current MSG received the ACK, 
	//then the program will clear the current MSG sending address and out of standby and will jump to the sending state.
	if (DestinationAddress == xnl_information.device_address )
800044b6:	48 88       	lddpc	r8,800044d4 <xnl_get_msg_ack_func+0x20>
800044b8:	90 28       	ld.sh	r8,r8[0x4]
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
	U16 DestinationAddress;
	U16 TransactionID;
	
	DestinationAddress = xnl->xnl_header.destination;
800044ba:	98 49       	ld.sh	r9,r12[0x8]
800044bc:	f0 09 19 00 	cp.h	r9,r8
800044c0:	c0 81       	brne	800044d0 <xnl_get_msg_ack_func+0x1c>
	if (DestinationAddress == xnl_information.device_address )
	{
		//The ack is for me.
		
		TransactionID = xnl->xnl_header.transaction_id;
		xSemaphoreGive(xnl_timeout_semphr);	
800044c2:	48 68       	lddpc	r8,800044d8 <xnl_get_msg_ack_func+0x24>
800044c4:	70 0c       	ld.w	r12,r8[0x0]
800044c6:	30 09       	mov	r9,0
800044c8:	12 9a       	mov	r10,r9
800044ca:	12 9b       	mov	r11,r9
800044cc:	f0 1f 00 04 	mcall	800044dc <xnl_get_msg_ack_func+0x28>
800044d0:	d8 02       	popm	pc
800044d2:	00 00       	add	r0,r0
800044d4:	00 00       	add	r0,r0
800044d6:	0b 48       	ld.w	r8,--r5
800044d8:	00 00       	add	r0,r0
800044da:	0b 44       	ld.w	r4,--r5
800044dc:	80 00       	ld.sh	r0,r0[0x0]
800044de:	55 d0       	stdsp	sp[0x174],r0

800044e0 <xnl_init>:
	xTaskCreate--freertos
	xnl_send_device_master_query
Called By:xcmp_init -- xcmp.c
*/
void xnl_init(void)
{
800044e0:	eb cd 40 e0 	pushm	r5-r7,lr
	
	xnl_information.is_connected = FALSE;
800044e4:	30 09       	mov	r9,0
800044e6:	4b 78       	lddpc	r8,800045c0 <xnl_init+0xe0>
800044e8:	b0 89       	st.b	r8[0x0],r9

	/*initialize the semaphore and queue*/
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
800044ea:	30 0b       	mov	r11,0
800044ec:	30 1c       	mov	r12,1
800044ee:	f0 1f 00 36 	mcall	800045c4 <xnl_init+0xe4>
800044f2:	4b 68       	lddpc	r8,800045c8 <xnl_init+0xe8>
800044f4:	91 0c       	st.w	r8[0x0],r12
800044f6:	70 08       	ld.w	r8,r8[0x0]
800044f8:	58 08       	cp.w	r8,0
800044fa:	c0 80       	breq	8000450a <xnl_init+0x2a>
800044fc:	4b 38       	lddpc	r8,800045c8 <xnl_init+0xe8>
800044fe:	70 0c       	ld.w	r12,r8[0x0]
80004500:	30 09       	mov	r9,0
80004502:	12 9a       	mov	r10,r9
80004504:	12 9b       	mov	r11,r9
80004506:	f0 1f 00 32 	mcall	800045cc <xnl_init+0xec>
	
	xnl_frame_tx = xQueueCreate(20, sizeof(xnl_fragment_t *)); //扩大xnl_frame_tx的队列深度
8000450a:	30 4b       	mov	r11,4
8000450c:	31 4c       	mov	r12,20
8000450e:	f0 1f 00 2e 	mcall	800045c4 <xnl_init+0xe4>
80004512:	4b 08       	lddpc	r8,800045d0 <xnl_init+0xf0>
80004514:	91 0c       	st.w	r8[0x0],r12
		
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
80004516:	30 4b       	mov	r11,4
80004518:	31 ec       	mov	r12,30
8000451a:	f0 1f 00 2b 	mcall	800045c4 <xnl_init+0xe4>
8000451e:	4a e8       	lddpc	r8,800045d4 <xnl_init+0xf4>
80004520:	91 0c       	st.w	r8[0x0],r12
80004522:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_XNL_STORE; i++ )
	{
		set_xnl_idle(&xnl_store[i]);
80004524:	10 96       	mov	r6,r8
80004526:	4a d5       	lddpc	r5,800045d8 <xnl_init+0xf8>
80004528:	6c 0c       	ld.w	r12,r6[0x0]
8000452a:	ea 07 00 0b 	add	r11,r5,r7
8000452e:	f0 1f 00 2c 	mcall	800045dc <xnl_init+0xfc>
80004532:	ee c7 ff 00 	sub	r7,r7,-256
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
	
	xnl_frame_tx = xQueueCreate(20, sizeof(xnl_fragment_t *)); //扩大xnl_frame_tx的队列深度
		
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
	for(int i= 0; i < MAX_XNL_STORE; i++ )
80004536:	e0 47 1e 00 	cp.w	r7,7680
8000453a:	cf 71       	brne	80004528 <xnl_init+0x48>
	{
		set_xnl_idle(&xnl_store[i]);
	}
	
	/*initialize the queue to send/receive xnl packet */
	phy_xnl_frame_tx = xQueueCreate(TX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
8000453c:	30 4b       	mov	r11,4
8000453e:	31 4c       	mov	r12,20
80004540:	f0 1f 00 21 	mcall	800045c4 <xnl_init+0xe4>
80004544:	4a 78       	lddpc	r8,800045e0 <xnl_init+0x100>
80004546:	91 0c       	st.w	r8[0x0],r12
	phy_xnl_frame_rx = xQueueCreate(RX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
80004548:	30 4b       	mov	r11,4
8000454a:	30 ac       	mov	r12,10
8000454c:	f0 1f 00 1e 	mcall	800045c4 <xnl_init+0xe4>
80004550:	4a 58       	lddpc	r8,800045e4 <xnl_init+0x104>
80004552:	91 0c       	st.w	r8[0x0],r12
	
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
80004554:	30 4b       	mov	r11,4
80004556:	30 ac       	mov	r12,10
80004558:	f0 1f 00 1b 	mcall	800045c4 <xnl_init+0xe4>
8000455c:	4a 38       	lddpc	r8,800045e8 <xnl_init+0x108>
8000455e:	91 0c       	st.w	r8[0x0],r12
80004560:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
	{
		set_payload_idle(payload_store[i]);
80004562:	10 96       	mov	r6,r8
80004564:	4a 25       	lddpc	r5,800045ec <xnl_init+0x10c>
80004566:	6c 0c       	ld.w	r12,r6[0x0]
80004568:	ea 07 00 0b 	add	r11,r5,r7
8000456c:	f0 1f 00 1c 	mcall	800045dc <xnl_init+0xfc>
80004570:	ee c7 fe 00 	sub	r7,r7,-512
	
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
80004574:	e0 47 14 00 	cp.w	r7,5120
80004578:	cf 71       	brne	80004566 <xnl_init+0x86>
	
	/*initialize the queue to send/receive payload packet */
	//phy_payload_frame_tx =
	//xQueueCreate(TX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t));
	
	phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
8000457a:	30 4b       	mov	r11,4
8000457c:	30 5c       	mov	r12,5
8000457e:	f0 1f 00 12 	mcall	800045c4 <xnl_init+0xe4>
80004582:	49 c8       	lddpc	r8,800045f0 <xnl_init+0x110>
80004584:	91 0c       	st.w	r8[0x0],r12
	
	#endif /*end if*/
		
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
80004586:	30 07       	mov	r7,0
80004588:	1a d7       	st.w	--sp,r7
8000458a:	1a d7       	st.w	--sp,r7
8000458c:	1a d7       	st.w	--sp,r7
8000458e:	30 38       	mov	r8,3
80004590:	0e 99       	mov	r9,r7
80004592:	e0 6a 02 00 	mov	r10,512
80004596:	49 8b       	lddpc	r11,800045f4 <xnl_init+0x114>
80004598:	49 8c       	lddpc	r12,800045f8 <xnl_init+0x118>
8000459a:	f0 1f 00 19 	mcall	800045fc <xnl_init+0x11c>
	,  tskXNL_PRIORITY //+ 1
	,  NULL
	);
	
	/*this task is used to send xnl message*/
	xTaskCreate(
8000459e:	1a d7       	st.w	--sp,r7
800045a0:	1a d7       	st.w	--sp,r7
800045a2:	1a d7       	st.w	--sp,r7
800045a4:	30 38       	mov	r8,3
800045a6:	0e 99       	mov	r9,r7
800045a8:	e0 6a 03 20 	mov	r10,800
800045ac:	49 5b       	lddpc	r11,80004600 <xnl_init+0x120>
800045ae:	49 6c       	lddpc	r12,80004604 <xnl_init+0x124>
800045b0:	f0 1f 00 13 	mcall	800045fc <xnl_init+0x11c>
	,  tskXNL_PRIORITY//+1
	,  NULL
	);
	
	/*initialize the physical layer*/
	phy_init();
800045b4:	f0 1f 00 15 	mcall	80004608 <xnl_init+0x128>
800045b8:	2f ad       	sub	sp,-24
}
800045ba:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800045be:	00 00       	add	r0,r0
800045c0:	00 00       	add	r0,r0
800045c2:	0b 48       	ld.w	r8,--r5
800045c4:	80 00       	ld.sh	r0,r0[0x0]
800045c6:	56 d0       	stdsp	sp[0x1b4],r0
800045c8:	00 00       	add	r0,r0
800045ca:	0b 44       	ld.w	r4,--r5
800045cc:	80 00       	ld.sh	r0,r0[0x0]
800045ce:	55 d0       	stdsp	sp[0x174],r0
800045d0:	00 00       	add	r0,r0
800045d2:	0b 54       	ld.sh	r4,--r5
800045d4:	00 00       	add	r0,r0
800045d6:	0a a8       	st.w	r5++,r8
800045d8:	00 00       	add	r0,r0
800045da:	22 b2       	sub	r2,43
800045dc:	80 00       	ld.sh	r0,r0[0x0]
800045de:	2a 44       	sub	r4,-92
800045e0:	00 00       	add	r0,r0
800045e2:	0a d8       	st.w	--r5,r8
800045e4:	00 00       	add	r0,r0
800045e6:	0a c4       	st.b	r5++,r4
800045e8:	00 00       	add	r0,r0
800045ea:	0a b0       	st.h	r5++,r0
800045ec:	00 00       	add	r0,r0
800045ee:	0e b2       	st.h	r7++,r2
800045f0:	00 00       	add	r0,r0
800045f2:	0a 80       	andn	r0,r5
800045f4:	80 00       	ld.sh	r0,r0[0x0]
800045f6:	c9 ec       	rcall	80004732 <xnl_tx_process+0xc6>
800045f8:	80 00       	ld.sh	r0,r0[0x0]
800045fa:	46 0c       	lddsp	r12,sp[0x180]
800045fc:	80 00       	ld.sh	r0,r0[0x0]
800045fe:	5d a4       	*unknown*
80004600:	80 00       	ld.sh	r0,r0[0x0]
80004602:	c2 00       	breq	80004642 <xnl_rx_process+0x36>
80004604:	80 00       	ld.sh	r0,r0[0x0]
80004606:	46 6c       	lddsp	r12,sp[0x198]
80004608:	80 00       	ld.sh	r0,r0[0x0]
8000460a:	2f d8       	sub	r8,-3

8000460c <xnl_rx_process>:
Description: Receive the XNL
Calls: 
Called By:task
*/
static void xnl_rx_process(void * pvParameters)
{
8000460c:	eb cd 40 fe 	pushm	r1-r7,lr
80004610:	20 1d       	sub	sp,4
	/*To ptr the elements in the queue*/
	xnl_fragment_t * xnl_ptr;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
80004612:	49 26       	lddpc	r6,80004658 <xnl_rx_process+0x4c>
80004614:	30 05       	mov	r5,0
80004616:	3f f4       	mov	r4,-1
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
80004618:	30 c3       	mov	r3,12
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
8000461a:	49 11       	lddpc	r1,8000465c <xnl_rx_process+0x50>
	if(xnl->xnl_header.opcode > 0x0C)	
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
8000461c:	49 12       	lddpc	r2,80004660 <xnl_rx_process+0x54>
	/*To ptr the elements in the queue*/
	xnl_fragment_t * xnl_ptr;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
8000461e:	6c 0c       	ld.w	r12,r6[0x0]
80004620:	0a 99       	mov	r9,r5
80004622:	08 9a       	mov	r10,r4
80004624:	1a 9b       	mov	r11,sp
80004626:	f0 1f 00 10 	mcall	80004664 <xnl_rx_process+0x58>
8000462a:	58 1c       	cp.w	r12,1
8000462c:	cf 91       	brne	8000461e <xnl_rx_process+0x12>
		, portMAX_DELAY ))
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
8000462e:	40 0c       	lddsp	r12,sp[0x0]
80004630:	58 0c       	cp.w	r12,0
80004632:	cf 60       	breq	8000461e <xnl_rx_process+0x12>
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
80004634:	98 28       	ld.sh	r8,r12[0x4]
80004636:	e6 08 19 00 	cp.h	r8,r3
8000463a:	e0 8b 00 0a 	brhi	8000464e <xnl_rx_process+0x42>
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
8000463e:	5c 78       	castu.h	r8
80004640:	e4 08 03 29 	ld.w	r9,r2[r8<<0x2]
80004644:	58 09       	cp.w	r9,0
80004646:	c0 40       	breq	8000464e <xnl_rx_process+0x42>
	{
		//log("\n\r R_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:R_xnl指令
		/*execute the function in list*/
		xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec(xnl);
80004648:	e4 08 03 28 	ld.w	r8,r2[r8<<0x2]
8000464c:	5d 18       	icall	r8
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
8000464e:	62 0c       	ld.w	r12,r1[0x0]
80004650:	40 0b       	lddsp	r11,sp[0x0]
80004652:	f0 1f 00 06 	mcall	80004668 <xnl_rx_process+0x5c>
80004656:	ce 4b       	rjmp	8000461e <xnl_rx_process+0x12>
80004658:	00 00       	add	r0,r0
8000465a:	0a c4       	st.b	r5++,r4
8000465c:	00 00       	add	r0,r0
8000465e:	0a a8       	st.w	r5++,r8
80004660:	00 00       	add	r0,r0
80004662:	05 04       	ld.w	r4,r2++
80004664:	80 00       	ld.sh	r0,r0[0x0]
80004666:	53 c4       	stdsp	sp[0xf0],r4
80004668:	80 00       	ld.sh	r0,r0[0x0]
8000466a:	2a 44       	sub	r4,-92

8000466c <xnl_tx_process>:
	xSemaphoreTake--freertos 
	phy_tx -- physical.c
Called By: task
*/
static void xnl_tx_process(void * pvParameters)
{
8000466c:	d4 31       	pushm	r0-r7,lr
	static  xnl_fragment_t * ptr;//是否可以修缮为静态变量？请关注
	
	
	for(;;)
	{		
		switch(xnl_tx_state)
8000466e:	4a a6       	lddpc	r6,80004714 <xnl_tx_process+0xa8>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
80004670:	4a a2       	lddpc	r2,80004718 <xnl_tx_process+0xac>
80004672:	4a b4       	lddpc	r4,8000471c <xnl_tx_process+0xb0>
80004674:	30 07       	mov	r7,0
80004676:	3f f1       	mov	r1,-1
					if(NULL == ptr)
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
80004678:	30 00       	mov	r0,0
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;				
8000467a:	4a a5       	lddpc	r5,80004720 <xnl_tx_process+0xb4>
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
8000467c:	4a a3       	lddpc	r3,80004724 <xnl_tx_process+0xb8>
	static  xnl_fragment_t * ptr;//是否可以修缮为静态变量？请关注
	
	
	for(;;)
	{		
		switch(xnl_tx_state)
8000467e:	6c 08       	ld.w	r8,r6[0x0]
80004680:	58 08       	cp.w	r8,0
80004682:	c0 40       	breq	8000468a <xnl_tx_process+0x1e>
80004684:	58 18       	cp.w	r8,1
80004686:	cf d1       	brne	80004680 <xnl_tx_process+0x14>
80004688:	c2 48       	rjmp	800046d0 <xnl_tx_process+0x64>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
8000468a:	64 0c       	ld.w	r12,r2[0x0]
8000468c:	0e 99       	mov	r9,r7
8000468e:	02 9a       	mov	r10,r1
80004690:	08 9b       	mov	r11,r4
80004692:	f0 1f 00 26 	mcall	80004728 <xnl_tx_process+0xbc>
80004696:	58 1c       	cp.w	r12,1
80004698:	cf 31       	brne	8000467e <xnl_tx_process+0x12>
					, portMAX_DELAY ))
				{				
					if(NULL == ptr)
8000469a:	68 0b       	ld.w	r11,r4[0x0]
8000469c:	58 0b       	cp.w	r11,0
8000469e:	cf 00       	breq	8000467e <xnl_tx_process+0x12>
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
800046a0:	96 28       	ld.sh	r8,r11[0x4]
800046a2:	e0 08 19 00 	cp.h	r8,r0
800046a6:	c0 71       	brne	800046b4 <xnl_tx_process+0x48>
					{
						/*invalid XNL opcode*/
						set_xnl_idle(ptr);
800046a8:	4a 18       	lddpc	r8,8000472c <xnl_tx_process+0xc0>
800046aa:	70 08       	ld.w	r8,r8[0x0]
800046ac:	10 9c       	mov	r12,r8
800046ae:	f0 1f 00 21 	mcall	80004730 <xnl_tx_process+0xc4>
						break;
800046b2:	ce 6b       	rjmp	8000467e <xnl_tx_process+0x12>
					}
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
800046b4:	16 9c       	mov	r12,r11
800046b6:	f0 1f 00 20 	mcall	80004734 <xnl_tx_process+0xc8>
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;				
800046ba:	30 18       	mov	r8,1
800046bc:	8b 08       	st.w	r5[0x0],r8
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
800046be:	66 0c       	ld.w	r12,r3[0x0]
800046c0:	0e 99       	mov	r9,r7
800046c2:	0e 9a       	mov	r10,r7
800046c4:	0e 9b       	mov	r11,r7
800046c6:	f0 1f 00 19 	mcall	80004728 <xnl_tx_process+0xbc>
					xnl_tx_state = WAITING_FOR_REPLY;
800046ca:	30 18       	mov	r8,1
800046cc:	8d 08       	st.w	r6[0x0],r8
800046ce:	cd 8b       	rjmp	8000467e <xnl_tx_process+0x12>
				}
				break;
			
			/*wait XNL reply*/			
			case WAITING_FOR_REPLY://直到回答ACK才再发送下一条data/control
				if(pdTRUE == xSemaphoreTake( xnl_timeout_semphr
800046d0:	66 0c       	ld.w	r12,r3[0x0]
800046d2:	0e 99       	mov	r9,r7
800046d4:	36 4a       	mov	r10,100
800046d6:	0e 9b       	mov	r11,r7
800046d8:	f0 1f 00 14 	mcall	80004728 <xnl_tx_process+0xbc>
800046dc:	58 1c       	cp.w	r12,1
800046de:	c0 81       	brne	800046ee <xnl_tx_process+0x82>
					, ( portTickType )50*2/ portTICK_RATE_MS))//按ADK文档中提示500ms一次超时,但是实际情况下程序中启用freertos的任务延时不够精准。因此根据经验需要降低延时等待的时间
				{
					/*No timeout*/
					set_xnl_idle(ptr);			
800046e0:	49 38       	lddpc	r8,8000472c <xnl_tx_process+0xc0>
800046e2:	70 0c       	ld.w	r12,r8[0x0]
800046e4:	68 0b       	ld.w	r11,r4[0x0]
800046e6:	f0 1f 00 13 	mcall	80004730 <xnl_tx_process+0xc4>
					xnl_tx_state = WAITING_FOR_TX;
800046ea:	8d 07       	st.w	r6[0x0],r7
800046ec:	cc 9b       	rjmp	8000467e <xnl_tx_process+0x12>
				}
				else
				{
					/*time out*/
					if(xnl_send_times <= MIN_RESEND_TIMES)
800046ee:	6a 08       	ld.w	r8,r5[0x0]
800046f0:	58 38       	cp.w	r8,3
800046f2:	e0 89 00 09 	brgt	80004704 <xnl_tx_process+0x98>
					{
						/*If times smaller than A supermarket, then resend the 
						instructions*/
						phy_tx((phy_fragment_t *)ptr);
800046f6:	68 0c       	ld.w	r12,r4[0x0]
800046f8:	f0 1f 00 0f 	mcall	80004734 <xnl_tx_process+0xc8>
						xnl_send_times++;
800046fc:	6a 08       	ld.w	r8,r5[0x0]
800046fe:	2f f8       	sub	r8,-1
80004700:	8b 08       	st.w	r5[0x0],r8
80004702:	cb eb       	rjmp	8000467e <xnl_tx_process+0x12>
					}
					else
					{
						//can not send data, disconnected						
						//vPortFree(ptr);	
						set_xnl_idle(ptr);									
80004704:	48 a8       	lddpc	r8,8000472c <xnl_tx_process+0xc0>
80004706:	70 0c       	ld.w	r12,r8[0x0]
80004708:	68 0b       	ld.w	r11,r4[0x0]
8000470a:	f0 1f 00 0a 	mcall	80004730 <xnl_tx_process+0xc4>
						xnl_tx_state = WAITING_FOR_TX;
8000470e:	8d 07       	st.w	r6[0x0],r7
80004710:	cb 7b       	rjmp	8000467e <xnl_tx_process+0x12>
80004712:	00 00       	add	r0,r0
80004714:	00 00       	add	r0,r0
80004716:	0b 64       	ld.uh	r4,--r5
80004718:	00 00       	add	r0,r0
8000471a:	0b 54       	ld.sh	r4,--r5
8000471c:	00 00       	add	r0,r0
8000471e:	0b 5c       	ld.sh	r12,--r5
80004720:	00 00       	add	r0,r0
80004722:	0b 58       	ld.sh	r8,--r5
80004724:	00 00       	add	r0,r0
80004726:	0b 44       	ld.w	r4,--r5
80004728:	80 00       	ld.sh	r0,r0[0x0]
8000472a:	53 c4       	stdsp	sp[0xf0],r4
8000472c:	00 00       	add	r0,r0
8000472e:	0a a8       	st.w	r5++,r8
80004730:	80 00       	ld.sh	r0,r0[0x0]
80004732:	2a 44       	sub	r4,-92
80004734:	80 00       	ld.sh	r0,r0[0x0]
80004736:	2a 64       	sub	r4,-90

80004738 <xnl_tx>:
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
{
80004738:	eb cd 40 c0 	pushm	r6-r7,lr
8000473c:	20 1d       	sub	sp,4
8000473e:	18 96       	mov	r6,r12
	message that is sent. The same value should be used for all retries.
	*/
	static U8 flags = 0;
	
	/*If the value is DEFAULT_VALUE, the value will be modified*/
	if(DEFAULT_VALUE == xnl->xnl_header.flags)
80004740:	98 39       	ld.sh	r9,r12[0x6]
80004742:	3f f8       	mov	r8,-1
80004744:	f0 09 19 00 	cp.h	r9,r8
80004748:	c0 a1       	brne	8000475c <xnl_tx+0x24>
	{
		xnl->xnl_header.flags =  0x0100 | ((++flags) & 0x07);
8000474a:	4a e9       	lddpc	r9,80004800 <xnl_tx+0xc8>
8000474c:	13 88       	ld.ub	r8,r9[0x0]
8000474e:	2f f8       	sub	r8,-1
80004750:	5c 58       	castu.b	r8
80004752:	b2 88       	st.b	r9[0x0],r8
80004754:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
80004758:	a9 a8       	sbr	r8,0x8
8000475a:	b8 38       	st.h	r12[0x6],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.destination)
8000475c:	8c 49       	ld.sh	r9,r6[0x8]
8000475e:	3f f8       	mov	r8,-1
80004760:	f0 09 19 00 	cp.h	r9,r8
80004764:	c0 41       	brne	8000476c <xnl_tx+0x34>
	{		
		/*Use actual Master address.*/
		xnl->xnl_header.destination = xnl_information.master_address;
80004766:	4a 88       	lddpc	r8,80004804 <xnl_tx+0xcc>
80004768:	90 18       	ld.sh	r8,r8[0x2]
8000476a:	ac 48       	st.h	r6[0x8],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.source)
8000476c:	8c 59       	ld.sh	r9,r6[0xa]
8000476e:	3f f8       	mov	r8,-1
80004770:	f0 09 19 00 	cp.h	r9,r8
80004774:	c0 41       	brne	8000477c <xnl_tx+0x44>
	{
		/*Use Temporary address.*/	
		xnl->xnl_header.source = xnl_information.device_address;
80004776:	4a 48       	lddpc	r8,80004804 <xnl_tx+0xcc>
80004778:	90 28       	ld.sh	r8,r8[0x4]
8000477a:	ac 58       	st.h	r6[0xa],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
8000477c:	8c 69       	ld.sh	r9,r6[0xc]
8000477e:	3f f8       	mov	r8,-1
80004780:	f0 09 19 00 	cp.h	r9,r8
80004784:	c0 e1       	brne	800047a0 <xnl_tx+0x68>
	{		
		xnl->xnl_header.transaction_id = 
		  ((++xnl_information.transaction_id) & 0xFF) 
80004786:	4a 08       	lddpc	r8,80004804 <xnl_tx+0xcc>
80004788:	90 49       	ld.sh	r9,r8[0x8]
8000478a:	2f f9       	sub	r9,-1
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
8000478c:	b0 49       	st.h	r8[0x8],r9
		  ((++xnl_information.transaction_id) & 0xFF) 
8000478e:	90 4a       	ld.sh	r10,r8[0x8]
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
80004790:	90 49       	ld.sh	r9,r8[0x8]
80004792:	e0 19 ff 00 	andl	r9,0xff00
80004796:	f1 da c0 08 	bfextu	r8,r10,0x0,0x8
8000479a:	f3 e8 10 08 	or	r8,r9,r8
8000479e:	ac 68       	st.h	r6[0xc],r8
	U16  sumScratch;
	U32  indextohWord;
	S32  hWordswithinFrag;
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
800047a0:	0d 98       	ld.ub	r8,r6[0x1]
800047a2:	20 28       	sub	r8,2
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
800047a4:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
800047a8:	10 0c       	add	r12,r8
800047aa:	a1 5c       	asr	r12,0x1
	indextohWord = 2;
	while (hWordswithinFrag > 0)
800047ac:	58 0c       	cp.w	r12,0
800047ae:	e0 89 00 04 	brgt	800047b6 <xnl_tx+0x7e>
800047b2:	30 09       	mov	r9,0
800047b4:	c0 d8       	rjmp	800047ce <xnl_tx+0x96>
800047b6:	ec ca ff fc 	sub	r10,r6,-4
Parameters: xnl_fragment_t * 
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
800047ba:	2f ec       	sub	r12,-2
800047bc:	30 09       	mov	r9,0
800047be:	30 28       	mov	r8,2
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
	{
		sumScratch += *((U16*)xnl + indextohWord);
800047c0:	15 1b       	ld.sh	r11,r10++
800047c2:	f6 09 00 09 	add	r9,r11,r9
800047c6:	5c 89       	casts.h	r9
		indextohWord     += 1;
800047c8:	2f f8       	sub	r8,-1
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
800047ca:	18 38       	cp.w	r8,r12
800047cc:	cf a1       	brne	800047c0 <xnl_tx+0x88>
		  ((++xnl_information.transaction_id) & 0xFF) 
		| (xnl_information.transaction_id & 0xFF00);
	}
	
	/*count check sum */
	xnl->phy_header.check_sum = check_sum( xnl );
800047ce:	5c 39       	neg	r9
800047d0:	ac 19       	st.h	r6[0x2],r9
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
800047d2:	48 e8       	lddpc	r8,80004808 <xnl_tx+0xd0>
800047d4:	70 0c       	ld.w	r12,r8[0x0]
800047d6:	f0 1f 00 0e 	mcall	8000480c <xnl_tx+0xd4>
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
800047da:	c1 00       	breq	800047fa <xnl_tx+0xc2>
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
800047dc:	fa c7 ff fc 	sub	r7,sp,-4
800047e0:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
	{
		memcpy(ptr, xnl, sizeof(xnl_fragment_t));
800047e2:	e0 6a 01 00 	mov	r10,256
800047e6:	0c 9b       	mov	r11,r6
800047e8:	f0 1f 00 0a 	mcall	80004810 <xnl_tx+0xd8>
	
		/*push to queue and send*/
		
		//log("ptr -%8x", ptr);
		
		xQueueSend(xnl_frame_tx, &ptr, 0);
800047ec:	48 a8       	lddpc	r8,80004814 <xnl_tx+0xdc>
800047ee:	70 0c       	ld.w	r12,r8[0x0]
800047f0:	30 09       	mov	r9,0
800047f2:	12 9a       	mov	r10,r9
800047f4:	1a 9b       	mov	r11,sp
800047f6:	f0 1f 00 09 	mcall	80004818 <xnl_tx+0xe0>
		//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
		
		//vPortFree(ptr);
	}
}
800047fa:	2f fd       	sub	sp,-4
800047fc:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004800:	00 00       	add	r0,r0
80004802:	0b 60       	ld.uh	r0,--r5
80004804:	00 00       	add	r0,r0
80004806:	0b 48       	ld.w	r8,--r5
80004808:	00 00       	add	r0,r0
8000480a:	0a a8       	st.w	r5++,r8
8000480c:	80 00       	ld.sh	r0,r0[0x0]
8000480e:	2f b0       	sub	r0,-5
80004810:	80 00       	ld.sh	r0,r0[0x0]
80004812:	69 f4       	ld.w	r4,r4[0x7c]
80004814:	00 00       	add	r0,r0
80004816:	0b 54       	ld.sh	r4,--r5
80004818:	80 00       	ld.sh	r0,r0[0x0]
8000481a:	55 d0       	stdsp	sp[0x174],r0

8000481c <xnl_data_msg_func>:
Description: process while receive data message.
Calls:xnl_send_msg_ack, xcmp_exec(function in xcmp)
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_data_msg_func(xnl_fragment_t * xnl)
{
8000481c:	eb cd 40 80 	pushm	r7,lr
80004820:	fa cd 01 00 	sub	sp,sp,256
80004824:	18 97       	mov	r7,r12
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80004826:	e0 68 40 0e 	mov	r8,16398
8000482a:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
8000482c:	3f f8       	mov	r8,-1
8000482e:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG_ACK;
80004830:	30 c8       	mov	r8,12
80004832:	ba 28       	st.h	sp[0x4],r8
	
	/*Turn around Flags.*/	
	xnl_frame.xnl_header.flags = hdr->flags;
80004834:	98 38       	ld.sh	r8,r12[0x6]
80004836:	ba 38       	st.h	sp[0x6],r8
	
	/*ACK Destination Address is Source of XNL_Message.*/
	xnl_frame.xnl_header.destination = hdr->source;
80004838:	98 58       	ld.sh	r8,r12[0xa]
8000483a:	ba 48       	st.h	sp[0x8],r8
	
	/*ACK Source Address is my address.*/
	xnl_frame.xnl_header.source = hdr->destination;
8000483c:	98 48       	ld.sh	r8,r12[0x8]
8000483e:	ba 58       	st.h	sp[0xa],r8
	
	/*Turn around Transaction ID.*/
	xnl_frame.xnl_header.transaction_id = hdr->transaction_id;
80004840:	98 68       	ld.sh	r8,r12[0xc]
80004842:	ba 68       	st.h	sp[0xc],r8
	xnl_frame.xnl_header.payload_length = 0;
80004844:	30 08       	mov	r8,0
80004846:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004848:	1a 9c       	mov	r12,sp
8000484a:	f0 1f 00 0a 	mcall	80004870 <xnl_data_msg_func+0x54>
	transmitter, but possibly is waiting in Queue with immediate timeout.
	 */
	xnl_send_msg_ack(&xnl->xnl_header);
	
	/*exec xcmp function*/
	xcmp_exec(xnl->xnl_payload.xnl_content_data_msg);//xcmp_rx
8000484e:	fa cd 00 cc 	sub	sp,sp,204
80004852:	e0 6a 00 ca 	mov	r10,202
80004856:	ee cb ff f0 	sub	r11,r7,-16
8000485a:	1a 9c       	mov	r12,sp
8000485c:	f0 1f 00 06 	mcall	80004874 <xnl_data_msg_func+0x58>
80004860:	48 68       	lddpc	r8,80004878 <xnl_data_msg_func+0x5c>
80004862:	70 08       	ld.w	r8,r8[0x0]
80004864:	5d 18       	icall	r8
80004866:	fa cd ff 34 	sub	sp,sp,-204
}
8000486a:	2c 0d       	sub	sp,-256
8000486c:	e3 cd 80 80 	ldm	sp++,r7,pc
80004870:	80 00       	ld.sh	r0,r0[0x0]
80004872:	47 38       	lddsp	r8,sp[0x1cc]
80004874:	80 00       	ld.sh	r0,r0[0x0]
80004876:	69 f4       	ld.w	r4,r4[0x7c]
80004878:	00 00       	add	r0,r0
8000487a:	0b 68       	ld.uh	r8,--r5

8000487c <xnl_device_auth_reply_func>:
Description: process while receive device auth reply.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_auth_reply_func(xnl_fragment_t * xnl)
{
8000487c:	d4 21       	pushm	r4-r7,lr
8000487e:	fa cd 01 00 	sub	sp,sp,256
80004882:	18 97       	mov	r7,r12
	the receiving device and will be used to authenticate the connection 
	request. 5.4.4
	*/
	//log("R_xnl-opcode:%4x", xnl->xnl_header.opcode);
	
	if(xnl_information.is_connected)
80004884:	4c 28       	lddpc	r8,8000498c <xnl_device_auth_reply_func+0x110>
80004886:	11 88       	ld.ub	r8,r8[0x0]
80004888:	58 08       	cp.w	r8,0
8000488a:	c7 e1       	brne	80004986 <xnl_device_auth_reply_func+0x10a>
	{
		return;		
	}
	
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);
8000488c:	4c 18       	lddpc	r8,80004990 <xnl_device_auth_reply_func+0x114>
8000488e:	70 0c       	ld.w	r12,r8[0x0]
80004890:	30 09       	mov	r9,0
80004892:	12 9a       	mov	r10,r9
80004894:	12 9b       	mov	r11,r9
80004896:	f0 1f 00 40 	mcall	80004994 <xnl_device_auth_reply_func+0x118>

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
8000489a:	ef 09 00 10 	ld.sh	r9,r7[16]
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
8000489e:	4b c8       	lddpc	r8,8000498c <xnl_device_auth_reply_func+0x110>
800048a0:	b0 29       	st.h	r8[0x4],r9
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
	
	/*Get Array of values to be encrypted into an aligned 2X32bits.*/
	v_vector[0] =
800048a2:	ef 39 00 12 	ld.ub	r9,r7[18]
800048a6:	ef 38 00 13 	ld.ub	r8,r7[19]
800048aa:	b1 68       	lsl	r8,0x10
800048ac:	f1 e9 11 89 	or	r9,r8,r9<<0x18
800048b0:	ef 38 00 15 	ld.ub	r8,r7[21]
800048b4:	f3 e8 10 08 	or	r8,r9,r8
800048b8:	ef 39 00 14 	ld.ub	r9,r7[20]
800048bc:	f1 e9 10 89 	or	r9,r8,r9<<0x8
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[2])<<8	  
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[3]);
	
	v_vector[1] =
800048c0:	ef 3a 00 16 	ld.ub	r10,r7[22]
800048c4:	ef 38 00 17 	ld.ub	r8,r7[23]
800048c8:	b1 68       	lsl	r8,0x10
800048ca:	f1 ea 11 8a 	or	r10,r8,r10<<0x18
800048ce:	ef 38 00 19 	ld.ub	r8,r7[25]
800048d2:	f5 e8 10 08 	or	r8,r10,r8
800048d6:	ef 3a 00 18 	ld.ub	r10,r7[24]
800048da:	f1 ea 10 88 	or	r8,r8,r10<<0x8
800048de:	30 0a       	mov	r10,0
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
800048e0:	e0 64 79 b9 	mov	r4,31161
800048e4:	ea 14 9e 37 	orh	r4,0x9e37
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
800048e8:	e0 65 45 07 	mov	r5,17671
800048ec:	ea 15 8a bd 	orh	r5,0x8abd
800048f0:	e0 66 f9 3d 	mov	r6,63805
800048f4:	ea 16 99 68 	orh	r6,0x9968
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
800048f8:	e0 6e b8 cf 	mov	lr,47311
800048fc:	ea 1e 36 83 	orh	lr,0x3683
80004900:	e0 67 aa 1c 	mov	r7,43548
80004904:	ea 17 9c 36 	orh	r7,0x9c36
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
80004908:	08 0a       	add	r10,r4
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
8000490a:	f4 08 00 0c 	add	r12,r10,r8
8000490e:	f0 0b 15 04 	lsl	r11,r8,0x4
80004912:	0a 0b       	add	r11,r5
80004914:	f9 eb 20 0b 	eor	r11,r12,r11
80004918:	f0 0c 16 05 	lsr	r12,r8,0x5
8000491c:	0c 0c       	add	r12,r6
8000491e:	18 5b       	eor	r11,r12
80004920:	16 09       	add	r9,r11
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
80004922:	f2 0c 15 04 	lsl	r12,r9,0x4
80004926:	1c 0c       	add	r12,lr
80004928:	f2 0b 16 05 	lsr	r11,r9,0x5
8000492c:	0e 0b       	add	r11,r7
8000492e:	f9 eb 20 0b 	eor	r11,r12,r11
80004932:	f2 0a 00 0c 	add	r12,r9,r10
80004936:	18 5b       	eor	r11,r12
80004938:	16 08       	add	r8,r11
{
	register U32 y=v[0], z=v[1], sum=0;
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
8000493a:	e0 6b 37 20 	mov	r11,14112
8000493e:	ea 1b c6 ef 	orh	r11,0xc6ef
80004942:	16 3a       	cp.w	r10,r11
80004944:	ce 21       	brne	80004908 <xnl_device_auth_reply_func+0x8c>
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :24 + 2(xnl length(24) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 24 + 2;
80004946:	e0 6a 40 1a 	mov	r10,16410
8000494a:	ba 0a       	st.h	sp[0x0],r10
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
8000494c:	3f fa       	mov	r10,-1
8000494e:	ba 1a       	st.h	sp[0x2],r10
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_CONN_REQUEST;
80004950:	30 6b       	mov	r11,6
80004952:	ba 2b       	st.h	sp[0x4],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
80004954:	ba 3a       	st.h	sp[0x6],r10
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
80004956:	48 eb       	lddpc	r11,8000498c <xnl_device_auth_reply_func+0x110>
80004958:	96 1c       	ld.sh	r12,r11[0x2]
8000495a:	ba 4c       	st.h	sp[0x8],r12
	message here, and all will receive the same DEVICE_CONN_REPLY. Not real 
	sure what's going to happen with multiple conrol heads, etc. One suspects 
	the Rocket Scientists will eventually figure this out, and demand a 
	transaction ID based on Device Type in the XNL_DEVICE_AUTH_KEY_REQUEST.
	*/
	xnl_frame.xnl_header.source = xnl_information.device_address;
8000495c:	96 2b       	ld.sh	r11,r11[0x4]
8000495e:	ba 5b       	st.h	sp[0xa],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80004960:	ba 6a       	st.h	sp[0xc],r10
	
    /*his message contains 12 payload bytes*/	
	xnl_frame.xnl_header.payload_length = 0x000C;
80004962:	30 ca       	mov	r10,12
80004964:	ba 7a       	st.h	sp[0xe],r10
	
	/*No Preferred XNL Address*/
	xnl_frame.xnl_payload.xnl_content_device_conn_req.preferred_xnl_address = 
80004966:	30 0a       	mov	r10,0
80004968:	fb 5a 00 10 	st.h	sp[16],r10
	XCMP/XNL Development Specification Section 4.5.3.2.1.
	Same as in MOTOTRBO?XCMP/XNL Development Specification?
	evice_type--Option Board(0x07)
	authentication_index--Option Board(0x02)
	*/	
	xnl_frame.xnl_payload.xnl_content_device_conn_req.device_type = 0x07;
8000496c:	30 7a       	mov	r10,7
8000496e:	fb 6a 00 12 	st.b	sp[18],r10
	xnl_frame.xnl_payload.xnl_content_device_conn_req.authentication_index =
80004972:	30 2a       	mov	r10,2
80004974:	fb 6a 00 13 	st.b	sp[19],r10
	                                                                       0x02;
		
	//We know encrypted array happens to be aligned to 32-bit boundary.
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
80004978:	fa ca ff ec 	sub	r10,sp,-20
8000497c:	95 09       	st.w	r10[0x0],r9
	                         .encrypted_authentication_value[0])) = w_vector[0];
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
8000497e:	95 18       	st.w	r10[0x4],r8
	                         .encrypted_authentication_value[4])) = w_vector[1];
	
	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004980:	1a 9c       	mov	r12,sp
80004982:	f0 1f 00 06 	mcall	80004998 <xnl_device_auth_reply_func+0x11c>
}
80004986:	2c 0d       	sub	sp,-256
80004988:	d8 22       	popm	r4-r7,pc
8000498a:	00 00       	add	r0,r0
8000498c:	00 00       	add	r0,r0
8000498e:	0b 48       	ld.w	r8,--r5
80004990:	00 00       	add	r0,r0
80004992:	0b 44       	ld.w	r4,--r5
80004994:	80 00       	ld.sh	r0,r0[0x0]
80004996:	55 d0       	stdsp	sp[0x174],r0
80004998:	80 00       	ld.sh	r0,r0[0x0]
8000499a:	47 38       	lddsp	r8,sp[0x1cc]

8000499c <xnl_master_status_brdcst_func>:
Description: process while receive master status boardcast.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_master_status_brdcst_func(xnl_fragment_t * xnl)
{	
8000499c:	eb cd 40 80 	pushm	r7,lr
800049a0:	fa cd 01 00 	sub	sp,sp,256
800049a4:	18 97       	mov	r7,r12
	not an XNL_DATA_MSG has been sent out. This will indicate to a connecting 
	device that it has missed messages. The XNL header will contain the 
	master?XNL address. 5.4.1
	*/
	
	if(xnl_information.is_connected)
800049a6:	49 28       	lddpc	r8,800049ec <xnl_master_status_brdcst_func+0x50>
800049a8:	11 88       	ld.ub	r8,r8[0x0]
800049aa:	58 08       	cp.w	r8,0
800049ac:	c1 c1       	brne	800049e4 <xnl_master_status_brdcst_func+0x48>
	{
		return;	
	}
		
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);	
800049ae:	49 18       	lddpc	r8,800049f0 <xnl_master_status_brdcst_func+0x54>
800049b0:	70 0c       	ld.w	r12,r8[0x0]
800049b2:	30 09       	mov	r9,0
800049b4:	12 9a       	mov	r10,r9
800049b6:	12 9b       	mov	r11,r9
800049b8:	f0 1f 00 0f 	mcall	800049f4 <xnl_master_status_brdcst_func+0x58>

	//log("xnl-ma:%4x", xnl->xnl_header.source);
	/*get the master adderss from this message*/	
	xnl_information.master_address = xnl->xnl_header.source;	
800049bc:	8e 58       	ld.sh	r8,r7[0xa]
800049be:	48 c9       	lddpc	r9,800049ec <xnl_master_status_brdcst_func+0x50>
800049c0:	b2 18       	st.h	r9[0x2],r8
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
800049c2:	e0 68 40 0e 	mov	r8,16398
800049c6:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
800049c8:	3f f8       	mov	r8,-1
800049ca:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_AUTH_KEY_REQUEST;
800049cc:	30 4a       	mov	r10,4
800049ce:	ba 2a       	st.h	sp[0x4],r10
		
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/	
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
800049d0:	ba 38       	st.h	sp[0x6],r8
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
800049d2:	92 19       	ld.sh	r9,r9[0x2]
800049d4:	ba 49       	st.h	sp[0x8],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.source = DEFAULT_VALUE;
800049d6:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
800049d8:	ba 68       	st.h	sp[0xc],r8
		
	xnl_frame.xnl_header.payload_length = 0;
800049da:	30 08       	mov	r8,0
800049dc:	ba 78       	st.h	sp[0xe],r8
	
	/*send XNL message*/	
	xnl_tx(&xnl_frame);
800049de:	1a 9c       	mov	r12,sp
800049e0:	f0 1f 00 06 	mcall	800049f8 <xnl_master_status_brdcst_func+0x5c>
}
800049e4:	2c 0d       	sub	sp,-256
800049e6:	e3 cd 80 80 	ldm	sp++,r7,pc
800049ea:	00 00       	add	r0,r0
800049ec:	00 00       	add	r0,r0
800049ee:	0b 48       	ld.w	r8,--r5
800049f0:	00 00       	add	r0,r0
800049f2:	0b 44       	ld.w	r4,--r5
800049f4:	80 00       	ld.sh	r0,r0[0x0]
800049f6:	55 d0       	stdsp	sp[0x174],r0
800049f8:	80 00       	ld.sh	r0,r0[0x0]
800049fa:	47 38       	lddsp	r8,sp[0x1cc]

800049fc <xnl_device_conn_reply_func>:
Description: process while receive device conn reply.
Calls:xSemaphoreGive--freestos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_conn_reply_func(xnl_fragment_t * xnl)
{
800049fc:	eb cd 40 80 	pushm	r7,lr
80004a00:	18 97       	mov	r7,r12
	transaction ID and an 8-byte encrypted value that the device can use to 
	authenticate the master. XCMP/XNL Development Guide 5.4.6
	*/
	
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);
80004a02:	49 28       	lddpc	r8,80004a48 <xnl_device_conn_reply_func+0x4c>
80004a04:	70 0c       	ld.w	r12,r8[0x0]
80004a06:	30 09       	mov	r9,0
80004a08:	12 9a       	mov	r10,r9
80004a0a:	12 9b       	mov	r11,r9
80004a0c:	f0 1f 00 10 	mcall	80004a4c <xnl_device_conn_reply_func+0x50>

	/*Test result code*/
	if((xnl->xnl_payload.xnl_content_device_conn_reply.result_base & 0x0000FF00)
80004a10:	ef 18 00 10 	ld.uh	r8,r7[16]
80004a14:	10 99       	mov	r9,r8
80004a16:	e2 19 ff 00 	andl	r9,0xff00,COH
80004a1a:	e0 49 01 00 	cp.w	r9,256
80004a1e:	c0 60       	breq	80004a2a <xnl_device_conn_reply_func+0x2e>
		/*
		Rejected. The device must retry the authentication process at this 
		point by sending out a new AUTH_KEY_REQUEST message. XCMP/XNL 
		Development Guide Section 5.2.3
		*/
		xnl_master_status_brdcst_func(xnl);			
80004a20:	0e 9c       	mov	r12,r7
80004a22:	f0 1f 00 0c 	mcall	80004a50 <xnl_device_conn_reply_func+0x54>
80004a26:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/*connection accepted*/		
		/*Record Transaction ID Base*/
		xnl_information.transaction_id =  
80004a2a:	a9 68       	lsl	r8,0x8
80004a2c:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
80004a30:	48 98       	lddpc	r8,80004a54 <xnl_device_conn_reply_func+0x58>
80004a32:	b0 49       	st.h	r8[0x8],r9
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
80004a34:	ef 09 00 14 	ld.sh	r9,r7[20]
		xnl_information.transaction_id =  
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
80004a38:	b0 39       	st.h	r8[0x6],r9
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
80004a3a:	ef 09 00 12 	ld.sh	r9,r7[18]
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
80004a3e:	b0 29       	st.h	r8[0x4],r9
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
		
		/*connect finish*/
		xnl_information.is_connected = TRUE;
80004a40:	30 19       	mov	r9,1
80004a42:	b0 89       	st.b	r8[0x0],r9
80004a44:	e3 cd 80 80 	ldm	sp++,r7,pc
80004a48:	00 00       	add	r0,r0
80004a4a:	0b 44       	ld.w	r4,--r5
80004a4c:	80 00       	ld.sh	r0,r0[0x0]
80004a4e:	55 d0       	stdsp	sp[0x174],r0
80004a50:	80 00       	ld.sh	r0,r0[0x0]
80004a52:	49 9c       	lddpc	r12,80004ab4 <local_start_pll0+0x2c>
80004a54:	00 00       	add	r0,r0
80004a56:	0b 48       	ld.w	r8,--r5

80004a58 <xnl_send_device_master_query>:
Description: send device_master_query to connect radio.
Calls:xnl_tx
Call By:xnl_init
*/
void xnl_send_device_master_query(void)
{
80004a58:	d4 01       	pushm	lr
80004a5a:	fa cd 01 00 	sub	sp,sp,256
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80004a5e:	e0 68 40 0e 	mov	r8,16398
80004a62:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004a64:	3f f8       	mov	r8,-1
80004a66:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_MASTER_QUERY;
80004a68:	30 38       	mov	r8,3
80004a6a:	ba 28       	st.h	sp[0x4],r8
	
	/*The initial value*/
	xnl_frame.xnl_header.flags = 0;
80004a6c:	30 08       	mov	r8,0
80004a6e:	ba 38       	st.h	sp[0x6],r8
	
	/*XNL address of the master device, if known;otherwise 0x0000*/
	xnl_frame.xnl_header.destination = 0;
80004a70:	ba 48       	st.h	sp[0x8],r8
	
	/*XNL address, if assigned; otherwise 0x0000*/
	xnl_frame.xnl_header.source = 0;
80004a72:	ba 58       	st.h	sp[0xa],r8
	
	/*No transaction ID required for this message*/
	xnl_frame.xnl_header.transaction_id = 0;
80004a74:	ba 68       	st.h	sp[0xc],r8
	
	/*This message contains no payload*/
	xnl_frame.xnl_header.payload_length = 0;
80004a76:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004a78:	1a 9c       	mov	r12,sp
80004a7a:	f0 1f 00 03 	mcall	80004a84 <xnl_send_device_master_query+0x2c>
}
80004a7e:	2c 0d       	sub	sp,-256
80004a80:	d8 02       	popm	pc
80004a82:	00 00       	add	r0,r0
80004a84:	80 00       	ld.sh	r0,r0[0x0]
80004a86:	47 38       	lddsp	r8,sp[0x1cc]

80004a88 <local_start_pll0>:
	//pm_switch_to_osc0(pm, 12000000, 3);
	//    pm_enable_osc0_crystal(pm, 12000000);
	//         pm_set_osc0_mode(pm,AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);  0x00000007
	//    pm_enable_clk0(pm, 3);
	//         pm_enable_clk0_no_wait(pm, 3);
	(&AVR32_PM)->oscctrl0 = 0x00000307;
80004a88:	fe 78 0c 00 	mov	r8,-62464
80004a8c:	e0 69 03 07 	mov	r9,775
80004a90:	91 a9       	st.w	r8[0x28],r9
	(&AVR32_PM)->mcctrl   = 0x00000004;
80004a92:	30 49       	mov	r9,4
80004a94:	91 09       	st.w	r8[0x0],r9
	//         pm_wait_for_clk0_ready(pm);
	while (!((&AVR32_PM)->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
80004a96:	71 59       	ld.w	r9,r8[0x54]
80004a98:	e2 19 00 80 	andl	r9,0x80,COH
80004a9c:	cf d0       	breq	80004a96 <local_start_pll0+0xe>
	//    pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);
	(&AVR32_PM)->mcctrl   = 0x00000005;
80004a9e:	fe 78 0c 00 	mov	r8,-62464
80004aa2:	30 59       	mov	r9,5
80004aa4:	91 09       	st.w	r8[0x0],r9
	//pm_pll_set_option(pm, 0, //PLL number 0
	//                        1, //freq Set to 1 for VCO frequency range 80-180MHz
	//                        1, //div2 Divide the PLL output frequency by 2
	//                        0);//0 to enable the Wide-Bandith Mode
	//pm_pll_enable(pm,0);
	(&AVR32_PM)->pll[0] = 0x1007010D;
80004aa6:	e0 69 01 0d 	mov	r9,269
80004aaa:	ea 19 10 07 	orh	r9,0x1007
80004aae:	91 89       	st.w	r8[0x20],r9


	//pm_wait_for_pll0_locked(pm);
	while (!((&AVR32_PM)->poscsr & AVR32_PM_POSCSR_LOCK0_MASK));
80004ab0:	71 59       	ld.w	r9,r8[0x54]
80004ab2:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
80004ab6:	cf d0       	breq	80004ab0 <local_start_pll0+0x28>
	//             0,  //Bus A select = 0 (PBA clock = 48MHz/2 = 24MHz).
	//             0,  //B clock divisor enable = 0
	//             0,  //Bus B select = 0
	//             0,  //HS Bus clock divisor enable = 0
	//             0); //HS Bus select = 0
	(&AVR32_PM)->cksel = 0x00800000;
80004ab8:	fe 78 0c 00 	mov	r8,-62464
80004abc:	fc 19 00 80 	movh	r9,0x80
80004ac0:	91 19       	st.w	r8[0x4],r9

	//flashc_set_wait_state(1);
	AVR32_FLASHC.fcr = 0x00000040;
80004ac2:	34 0a       	mov	r10,64
80004ac4:	fe 69 14 00 	mov	r9,-125952
80004ac8:	93 0a       	st.w	r9[0x0],r10

	//pm_switch_to_clock(pm, AVR32_PM_MCSEL_PLL0);
	(&AVR32_PM)->mcctrl   = 0x00000006;
80004aca:	30 69       	mov	r9,6
80004acc:	91 09       	st.w	r8[0x0],r9


	AVR32_HMATRIX.mcfg[AVR32_HMATRIX_MASTER_CPU_INSTRUCTION] = 0x1;
80004ace:	30 19       	mov	r9,1
80004ad0:	fe 68 10 00 	mov	r8,-126976
80004ad4:	91 19       	st.w	r8[0x4],r9
}
80004ad6:	5e fc       	retal	r12

80004ad8 <local_start_timer>:
//	MAKO_RX					AVR32_SSC_RX_DATA_0_PIN				[39 PortB Pin  7 00000080 Func 0]
//
void local_start_timer(void)
{
	//Route CLK to Timer
	AVR32_GPIO.port[0].pmr0s = 0x00100000;
80004ad8:	fe 78 10 00 	mov	r8,-61440
80004adc:	fc 19 00 10 	movh	r9,0x10
80004ae0:	91 59       	st.w	r8[0x14],r9
	AVR32_GPIO.port[0].pmr1c = 0x00100000;
80004ae2:	91 a9       	st.w	r8[0x28],r9
	AVR32_GPIO.port[0].gperc = 0x00100000;
80004ae4:	91 29       	st.w	r8[0x8],r9
	//Route FS and Tri-State to Timer.
	AVR32_GPIO.port[1].pmr0c = 0x00000003;
80004ae6:	30 39       	mov	r9,3
80004ae8:	f1 49 01 18 	st.w	r8[280],r9
	AVR32_GPIO.port[1].pmr1c = 0x00000003;
80004aec:	f1 49 01 28 	st.w	r8[296],r9
	AVR32_GPIO.port[1].gperc = 0x00000003;
80004af0:	f1 49 01 08 	st.w	r8[264],r9

	(&AVR32_TC)->bmr = 4;
80004af4:	fe 78 38 00 	mov	r8,-51200
80004af8:	30 49       	mov	r9,4
80004afa:	f1 49 00 c4 	st.w	r8[196],r9
	(&AVR32_TC)->channel[0].cmr =
80004afe:	e0 69 91 0d 	mov	r9,37133
80004b02:	ea 19 00 52 	orh	r9,0x52
80004b06:	91 19       	st.w	r8[0x4],r9
	1                          << AVR32_TC_CLKI_OFFSET     |
	AVR32_TC_TCCLKS_XC0        << AVR32_TC_TCCLKS_OFFSET;



	(&AVR32_TC)->channel[0].ra = 32;
80004b08:	32 09       	mov	r9,32
80004b0a:	91 59       	st.w	r8[0x14],r9
	(&AVR32_TC)->channel[0].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
80004b0c:	30 59       	mov	r9,5
80004b0e:	91 09       	st.w	r8[0x0],r9
}
80004b10:	5e fc       	retal	r12

80004b12 <gpio_enable_module_pin>:
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80004b12:	f8 08 16 05 	lsr	r8,r12,0x5
80004b16:	a9 68       	lsl	r8,0x8
80004b18:	e0 28 f0 00 	sub	r8,61440

	/* Enable the correct function. */
	switch (function) {
80004b1c:	58 1b       	cp.w	r11,1
80004b1e:	c0 d0       	breq	80004b38 <gpio_enable_module_pin+0x26>
80004b20:	c0 63       	brcs	80004b2c <gpio_enable_module_pin+0x1a>
80004b22:	58 2b       	cp.w	r11,2
80004b24:	c1 00       	breq	80004b44 <gpio_enable_module_pin+0x32>
80004b26:	58 3b       	cp.w	r11,3
80004b28:	c1 40       	breq	80004b50 <gpio_enable_module_pin+0x3e>
80004b2a:	5e ff       	retal	1
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80004b2c:	30 19       	mov	r9,1
80004b2e:	f2 0c 09 49 	lsl	r9,r9,r12
80004b32:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80004b34:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80004b36:	c1 28       	rjmp	80004b5a <gpio_enable_module_pin+0x48>

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80004b38:	30 19       	mov	r9,1
80004b3a:	f2 0c 09 49 	lsl	r9,r9,r12
80004b3e:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80004b40:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80004b42:	c0 c8       	rjmp	80004b5a <gpio_enable_module_pin+0x48>

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80004b44:	30 19       	mov	r9,1
80004b46:	f2 0c 09 49 	lsl	r9,r9,r12
80004b4a:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80004b4c:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80004b4e:	c0 68       	rjmp	80004b5a <gpio_enable_module_pin+0x48>

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80004b50:	30 19       	mov	r9,1
80004b52:	f2 0c 09 49 	lsl	r9,r9,r12
80004b56:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80004b58:	91 99       	st.w	r8[0x24],r9
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
80004b5a:	30 19       	mov	r9,1
80004b5c:	f2 0c 09 4c 	lsl	r12,r9,r12
80004b60:	91 2c       	st.w	r8[0x8],r12
80004b62:	5e fd       	retal	0

80004b64 <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
80004b64:	d4 21       	pushm	r4-r7,lr
80004b66:	18 97       	mov	r7,r12
80004b68:	16 94       	mov	r4,r11
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
80004b6a:	58 0b       	cp.w	r11,0
80004b6c:	c0 31       	brne	80004b72 <gpio_enable_module+0xe>
80004b6e:	30 05       	mov	r5,0
80004b70:	c0 d8       	rjmp	80004b8a <gpio_enable_module+0x26>
80004b72:	30 06       	mov	r6,0
80004b74:	0c 95       	mov	r5,r6
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
80004b76:	6e 1b       	ld.w	r11,r7[0x4]
80004b78:	6e 0c       	ld.w	r12,r7[0x0]
80004b7a:	f0 1f 00 06 	mcall	80004b90 <gpio_enable_module+0x2c>
80004b7e:	18 45       	or	r5,r12
		gpiomap++;
80004b80:	2f 87       	sub	r7,-8
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
80004b82:	2f f6       	sub	r6,-1
80004b84:	0c 34       	cp.w	r4,r6
80004b86:	fe 9b ff f8 	brhi	80004b76 <gpio_enable_module+0x12>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
}
80004b8a:	0a 9c       	mov	r12,r5
80004b8c:	d8 22       	popm	r4-r7,pc
80004b8e:	00 00       	add	r0,r0
80004b90:	80 00       	ld.sh	r0,r0[0x0]
80004b92:	4b 12       	lddpc	r2,80004c54 <INTC_init_interrupts+0x3c>

80004b94 <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
80004b94:	c0 08       	rjmp	80004b94 <_unhandled_interrupt>
80004b96:	d7 03       	nop

80004b98 <INTC_register_interrupt>:
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
80004b98:	f6 08 16 05 	lsr	r8,r11,0x5

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
80004b9c:	49 99       	lddpc	r9,80004c00 <INTC_register_interrupt+0x68>
80004b9e:	f2 08 00 39 	add	r9,r9,r8<<0x3
80004ba2:	f7 db c0 05 	bfextu	r11,r11,0x0,0x5
80004ba6:	72 19       	ld.w	r9,r9[0x4]
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
80004ba8:	f2 0b 09 2c 	st.w	r9[r11<<0x2],r12
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
80004bac:	58 0a       	cp.w	r10,0
80004bae:	c0 91       	brne	80004bc0 <INTC_register_interrupt+0x28>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80004bb0:	49 59       	lddpc	r9,80004c04 <INTC_register_interrupt+0x6c>
80004bb2:	49 6a       	lddpc	r10,80004c08 <INTC_register_interrupt+0x70>
80004bb4:	12 1a       	sub	r10,r9
80004bb6:	fe 79 08 00 	mov	r9,-63488
80004bba:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80004bbe:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT1) {
80004bc0:	58 1a       	cp.w	r10,1
80004bc2:	c0 a1       	brne	80004bd6 <INTC_register_interrupt+0x3e>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
80004bc4:	49 09       	lddpc	r9,80004c04 <INTC_register_interrupt+0x6c>
80004bc6:	49 2a       	lddpc	r10,80004c0c <INTC_register_interrupt+0x74>
80004bc8:	12 1a       	sub	r10,r9
80004bca:	bf aa       	sbr	r10,0x1e
80004bcc:	fe 79 08 00 	mov	r9,-63488
80004bd0:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80004bd4:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT2) {
80004bd6:	58 2a       	cp.w	r10,2
80004bd8:	c0 a1       	brne	80004bec <INTC_register_interrupt+0x54>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
80004bda:	48 b9       	lddpc	r9,80004c04 <INTC_register_interrupt+0x6c>
80004bdc:	48 da       	lddpc	r10,80004c10 <INTC_register_interrupt+0x78>
80004bde:	12 1a       	sub	r10,r9
80004be0:	bf ba       	sbr	r10,0x1f
80004be2:	fe 79 08 00 	mov	r9,-63488
80004be6:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80004bea:	5e fc       	retal	r12
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
80004bec:	48 69       	lddpc	r9,80004c04 <INTC_register_interrupt+0x6c>
80004bee:	48 aa       	lddpc	r10,80004c14 <INTC_register_interrupt+0x7c>
80004bf0:	12 1a       	sub	r10,r9
80004bf2:	ea 1a c0 00 	orh	r10,0xc000
80004bf6:	fe 79 08 00 	mov	r9,-63488
80004bfa:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80004bfe:	5e fc       	retal	r12
80004c00:	80 00       	ld.sh	r0,r0[0x0]
80004c02:	c9 f4       	brge	80004b40 <gpio_enable_module_pin+0x2e>
80004c04:	80 00       	ld.sh	r0,r0[0x0]
80004c06:	c0 00       	breq	80004c06 <INTC_register_interrupt+0x6e>
80004c08:	80 00       	ld.sh	r0,r0[0x0]
80004c0a:	c1 04       	brge	80004c2a <INTC_init_interrupts+0x12>
80004c0c:	80 00       	ld.sh	r0,r0[0x0]
80004c0e:	c1 12       	brcc	80004c30 <INTC_init_interrupts+0x18>
80004c10:	80 00       	ld.sh	r0,r0[0x0]
80004c12:	c1 20       	breq	80004c36 <INTC_init_interrupts+0x1e>
80004c14:	80 00       	ld.sh	r0,r0[0x0]
80004c16:	c1 2e       	rcall	8000483a <xnl_data_msg_func+0x1e>

80004c18 <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
80004c18:	d4 21       	pushm	r4-r7,lr
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
80004c1a:	49 18       	lddpc	r8,80004c5c <INTC_init_interrupts+0x44>
80004c1c:	e3 b8 00 01 	mtsr	0x4,r8
80004c20:	49 0e       	lddpc	lr,80004c60 <INTC_init_interrupts+0x48>
80004c22:	30 07       	mov	r7,0
80004c24:	0e 94       	mov	r4,r7
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
80004c26:	49 0c       	lddpc	r12,80004c64 <INTC_init_interrupts+0x4c>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80004c28:	49 05       	lddpc	r5,80004c68 <INTC_init_interrupts+0x50>
80004c2a:	10 15       	sub	r5,r8
80004c2c:	fe 76 08 00 	mov	r6,-63488
80004c30:	c1 08       	rjmp	80004c50 <INTC_init_interrupts+0x38>
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
80004c32:	08 98       	mov	r8,r4
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
				._int_line_handler_table[int_req]
80004c34:	7c 1b       	ld.w	r11,lr[0x4]

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80004c36:	7c 0a       	ld.w	r10,lr[0x0]
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
80004c38:	f6 08 09 2c 	st.w	r11[r8<<0x2],r12
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
80004c3c:	2f f8       	sub	r8,-1

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80004c3e:	10 3a       	cp.w	r10,r8
80004c40:	fe 9b ff fc 	brhi	80004c38 <INTC_init_interrupts+0x20>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80004c44:	ec 07 09 25 	st.w	r6[r7<<0x2],r5
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
80004c48:	2f f7       	sub	r7,-1
80004c4a:	2f 8e       	sub	lr,-8
80004c4c:	59 37       	cp.w	r7,19
80004c4e:	c0 50       	breq	80004c58 <INTC_init_interrupts+0x40>
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80004c50:	7c 08       	ld.w	r8,lr[0x0]
80004c52:	58 08       	cp.w	r8,0
80004c54:	ce f1       	brne	80004c32 <INTC_init_interrupts+0x1a>
80004c56:	cf 7b       	rjmp	80004c44 <INTC_init_interrupts+0x2c>
80004c58:	d8 22       	popm	r4-r7,pc
80004c5a:	00 00       	add	r0,r0
80004c5c:	80 00       	ld.sh	r0,r0[0x0]
80004c5e:	c0 00       	breq	80004c5e <INTC_init_interrupts+0x46>
80004c60:	80 00       	ld.sh	r0,r0[0x0]
80004c62:	c9 f4       	brge	80004ba0 <INTC_register_interrupt+0x8>
80004c64:	80 00       	ld.sh	r0,r0[0x0]
80004c66:	4b 94       	lddpc	r4,80004d48 <usart_read_char+0x8>
80004c68:	80 00       	ld.sh	r0,r0[0x0]
80004c6a:	c1 04       	brge	80004c8a <_get_interrupt_handler+0x1e>

80004c6c <_get_interrupt_handler>:
__int_handler _get_interrupt_handler(uint32_t int_level)
{
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
80004c6c:	fe 78 08 00 	mov	r8,-63488
80004c70:	e0 69 00 83 	mov	r9,131
80004c74:	f2 0c 01 0c 	sub	r12,r9,r12
80004c78:	f0 0c 03 29 	ld.w	r9,r8[r12<<0x2]
	uint32_t int_req = AVR32_INTC.irr[int_grp];
80004c7c:	f2 ca ff c0 	sub	r10,r9,-64
80004c80:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
80004c84:	58 08       	cp.w	r8,0
80004c86:	c0 21       	brne	80004c8a <_get_interrupt_handler+0x1e>
80004c88:	5e fd       	retal	0
		? _int_handler_table[int_grp]._int_line_handler_table[32
80004c8a:	f0 08 12 00 	clz	r8,r8
80004c8e:	48 5a       	lddpc	r10,80004ca0 <_get_interrupt_handler+0x34>
80004c90:	f4 09 00 39 	add	r9,r10,r9<<0x3
80004c94:	f0 08 11 1f 	rsub	r8,r8,31
80004c98:	72 19       	ld.w	r9,r9[0x4]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
80004c9a:	f2 08 03 2c 	ld.w	r12,r9[r8<<0x2]
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
80004c9e:	5e fc       	retal	r12
80004ca0:	80 00       	ld.sh	r0,r0[0x0]
80004ca2:	c9 f4       	brge	80004be0 <INTC_register_interrupt+0x48>

80004ca4 <usart_set_async_baudrate>:
 *
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
80004ca4:	d4 01       	pushm	lr
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
80004ca6:	f6 08 15 04 	lsl	r8,r11,0x4
80004caa:	14 38       	cp.w	r8,r10
80004cac:	f9 b8 08 10 	movls	r8,16
80004cb0:	f9 b8 0b 08 	movhi	r8,8
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
80004cb4:	f0 0b 02 4b 	mul	r11,r8,r11
80004cb8:	f6 09 16 01 	lsr	r9,r11,0x1
80004cbc:	f2 0a 00 3a 	add	r10,r9,r10<<0x3
80004cc0:	f4 0b 0d 0a 	divu	r10,r10,r11
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
80004cc4:	f4 09 16 03 	lsr	r9,r10,0x3
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
80004cc8:	f2 cb 00 01 	sub	r11,r9,1
80004ccc:	e0 4b ff fe 	cp.w	r11,65534
80004cd0:	e0 88 00 03 	brls	80004cd6 <usart_set_async_baudrate+0x32>
80004cd4:	da 0a       	popm	pc,r12=1
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
80004cd6:	78 1b       	ld.w	r11,r12[0x4]
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
80004cd8:	e8 6e 00 00 	mov	lr,524288
80004cdc:	59 08       	cp.w	r8,16
80004cde:	fc 08 17 10 	movne	r8,lr
80004ce2:	f9 b8 00 00 	moveq	r8,0
80004ce6:	e4 1b ff f7 	andh	r11,0xfff7
80004cea:	e0 1b fe cf 	andl	r11,0xfecf
80004cee:	16 48       	or	r8,r11
80004cf0:	99 18       	st.w	r12[0x4],r8
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
80004cf2:	f5 da c0 03 	bfextu	r10,r10,0x0,0x3
80004cf6:	f3 ea 11 09 	or	r9,r9,r10<<0x10
80004cfa:	99 89       	st.w	r12[0x20],r9
80004cfc:	d8 0a       	popm	pc,r12=0

80004cfe <usart_write_char>:
 *
 * \return \c 1 if the USART Transmit Holding Register is free, otherwise \c 0.
 */
__always_inline static int usart_tx_ready(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_TXRDY_MASK) != 0;
80004cfe:	78 58       	ld.w	r8,r12[0x14]
}


int usart_write_char(volatile avr32_usart_t *usart, int c)
{
  if (usart_tx_ready(usart))
80004d00:	e2 18 00 02 	andl	r8,0x2,COH
80004d04:	c0 31       	brne	80004d0a <usart_write_char+0xc>
80004d06:	30 2c       	mov	r12,2
80004d08:	5e fc       	retal	r12
  {
    usart->thr = (c << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
80004d0a:	f7 db c0 09 	bfextu	r11,r11,0x0,0x9
80004d0e:	99 7b       	st.w	r12[0x1c],r11
80004d10:	5e fd       	retal	0
80004d12:	d7 03       	nop

80004d14 <usart_putchar>:
    return USART_TX_BUSY;
}


int usart_putchar(volatile avr32_usart_t *usart, int c)
{
80004d14:	eb cd 40 e0 	pushm	r5-r7,lr
80004d18:	18 96       	mov	r6,r12
80004d1a:	16 95       	mov	r5,r11
80004d1c:	e0 67 27 0f 	mov	r7,9999
80004d20:	c0 68       	rjmp	80004d2c <usart_putchar+0x18>
  int timeout = USART_DEFAULT_TIMEOUT;

  do
  {
    if (!timeout--) return USART_FAILURE;
80004d22:	58 07       	cp.w	r7,0
80004d24:	c0 31       	brne	80004d2a <usart_putchar+0x16>
80004d26:	e3 cf c0 e0 	ldm	sp++,r5-r7,pc,r12=-1
80004d2a:	20 17       	sub	r7,1
  } while (usart_write_char(usart, c) != USART_SUCCESS);
80004d2c:	0a 9b       	mov	r11,r5
80004d2e:	0c 9c       	mov	r12,r6
80004d30:	f0 1f 00 03 	mcall	80004d3c <usart_putchar+0x28>
80004d34:	cf 71       	brne	80004d22 <usart_putchar+0xe>

  return USART_SUCCESS;
}
80004d36:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80004d3a:	00 00       	add	r0,r0
80004d3c:	80 00       	ld.sh	r0,r0[0x0]
80004d3e:	4c fe       	lddpc	lr,80004e78 <usart_init_rs232+0x98>

80004d40 <usart_read_char>:

int usart_read_char(volatile avr32_usart_t *usart, int *c)
{
  // Check for errors: frame, parity and overrun. In RS485 mode, a parity error
  // would mean that an address char has been received.
  if (usart->csr & (AVR32_USART_CSR_OVRE_MASK |
80004d40:	78 58       	ld.w	r8,r12[0x14]
80004d42:	e2 18 00 e0 	andl	r8,0xe0,COH
80004d46:	c0 30       	breq	80004d4c <usart_read_char+0xc>
80004d48:	30 4c       	mov	r12,4
80004d4a:	5e fc       	retal	r12
 *
 * \return \c 1 if the USART Receive Holding Register is full, otherwise \c 0.
 */
__always_inline static int usart_test_hit(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_RXRDY_MASK) != 0;
80004d4c:	78 58       	ld.w	r8,r12[0x14]
                    AVR32_USART_CSR_FRAME_MASK |
                    AVR32_USART_CSR_PARE_MASK))
    return USART_RX_ERROR;

  // No error; if we really did receive a char, read it and return SUCCESS.
  if (usart_test_hit(usart))
80004d4e:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80004d52:	c0 31       	brne	80004d58 <usart_read_char+0x18>
80004d54:	30 3c       	mov	r12,3
80004d56:	5e fc       	retal	r12
  {
    *c = (usart->rhr & AVR32_USART_RHR_RXCHR_MASK) >> AVR32_USART_RHR_RXCHR_OFFSET;
80004d58:	78 68       	ld.w	r8,r12[0x18]
80004d5a:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
80004d5e:	97 08       	st.w	r11[0x0],r8
80004d60:	5e fd       	retal	0
80004d62:	d7 03       	nop

80004d64 <usart_getchar>:
    return USART_RX_EMPTY;
}


int usart_getchar(volatile avr32_usart_t *usart)
{
80004d64:	eb cd 40 c0 	pushm	r6-r7,lr
80004d68:	20 1d       	sub	sp,4
80004d6a:	18 96       	mov	r6,r12
  int c, ret;

  while ((ret = usart_read_char(usart, &c)) == USART_RX_EMPTY);
80004d6c:	1a 97       	mov	r7,sp
80004d6e:	1a 9b       	mov	r11,sp
80004d70:	0c 9c       	mov	r12,r6
80004d72:	f0 1f 00 07 	mcall	80004d8c <usart_getchar+0x28>
80004d76:	58 3c       	cp.w	r12,3
80004d78:	cf b0       	breq	80004d6e <usart_getchar+0xa>

  if (ret == USART_RX_ERROR)
80004d7a:	58 4c       	cp.w	r12,4
80004d7c:	f9 bc 00 ff 	moveq	r12,-1
    return USART_FAILURE;

  return c;
80004d80:	fb fc 10 00 	ld.wne	r12,sp[0x0]
}
80004d84:	2f fd       	sub	sp,-4
80004d86:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004d8a:	00 00       	add	r0,r0
80004d8c:	80 00       	ld.sh	r0,r0[0x0]
80004d8e:	4d 40       	lddpc	r0,80004edc <idata_load_loop_end+0xe>

80004d90 <usart_write_line>:


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
80004d90:	eb cd 40 c0 	pushm	r6-r7,lr
80004d94:	18 96       	mov	r6,r12
80004d96:	16 97       	mov	r7,r11
  while (*string != '\0')
80004d98:	17 8b       	ld.ub	r11,r11[0x0]
80004d9a:	58 0b       	cp.w	r11,0
80004d9c:	c0 80       	breq	80004dac <usart_write_line+0x1c>
    usart_putchar(usart, *string++);
80004d9e:	2f f7       	sub	r7,-1
80004da0:	0c 9c       	mov	r12,r6
80004da2:	f0 1f 00 04 	mcall	80004db0 <usart_write_line+0x20>
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
80004da6:	0f 8b       	ld.ub	r11,r7[0x0]
80004da8:	58 0b       	cp.w	r11,0
80004daa:	cf a1       	brne	80004d9e <usart_write_line+0xe>
80004dac:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004db0:	80 00       	ld.sh	r0,r0[0x0]
80004db2:	4d 14       	lddpc	r4,80004ef4 <vListInitialise+0x8>

80004db4 <usart_reset>:
//! @{


void usart_reset(volatile avr32_usart_t *usart)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
80004db4:	e1 b8 00 00 	mfsr	r8,0x0

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
80004db8:	e6 18 00 01 	andh	r8,0x1,COH
80004dbc:	c0 71       	brne	80004dca <usart_reset+0x16>
80004dbe:	d3 03       	ssrf	0x10
  usart->idr = 0xFFFFFFFF;
80004dc0:	3f f8       	mov	r8,-1
80004dc2:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80004dc4:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();
80004dc6:	d5 03       	csrf	0x10
80004dc8:	c0 48       	rjmp	80004dd0 <usart_reset+0x1c>
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
  usart->idr = 0xFFFFFFFF;
80004dca:	3f f8       	mov	r8,-1
80004dcc:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80004dce:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();

  // Reset mode and other registers that could cause unpredictable behavior after reset.
  usart->mr = 0;
80004dd0:	30 08       	mov	r8,0
80004dd2:	99 18       	st.w	r12[0x4],r8
  usart->rtor = 0;
80004dd4:	99 98       	st.w	r12[0x24],r8
  usart->ttgr = 0;
80004dd6:	99 a8       	st.w	r12[0x28],r8

  // Shutdown TX and RX (will be re-enabled when setup has successfully completed),
  // reset status bits and turn off DTR and RTS.
  usart->cr = AVR32_USART_CR_RSTRX_MASK   |
80004dd8:	ea 68 61 0c 	mov	r8,680204
80004ddc:	99 08       	st.w	r12[0x0],r8
#ifndef AVR32_USART_440_H_INCLUDED
// Note: Modem Signal Management DTR-DSR-DCD-RI are not included in USART rev.440.
              AVR32_USART_CR_DTRDIS_MASK  |
#endif
              AVR32_USART_CR_RTSDIS_MASK;
}
80004dde:	5e fc       	retal	r12

80004de0 <usart_init_rs232>:


int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
{
80004de0:	eb cd 40 e0 	pushm	r5-r7,lr
80004de4:	18 96       	mov	r6,r12
80004de6:	16 97       	mov	r7,r11
80004de8:	14 95       	mov	r5,r10
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);
80004dea:	f0 1f 00 2f 	mcall	80004ea4 <usart_init_rs232+0xc4>

  // Check input values.
  if (!opt || // Null pointer.
80004dee:	58 07       	cp.w	r7,0
80004df0:	c5 80       	breq	80004ea0 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
80004df2:	0f c8       	ld.ub	r8,r7[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80004df4:	30 49       	mov	r9,4
80004df6:	f2 08 18 00 	cp.b	r8,r9
80004dfa:	e0 88 00 53 	brls	80004ea0 <usart_init_rs232+0xc0>
80004dfe:	30 99       	mov	r9,9
80004e00:	f2 08 18 00 	cp.b	r8,r9
80004e04:	e0 8b 00 4e 	brhi	80004ea0 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
80004e08:	0f d9       	ld.ub	r9,r7[0x5]
80004e0a:	30 78       	mov	r8,7
80004e0c:	f0 09 18 00 	cp.b	r9,r8
80004e10:	e0 8b 00 48 	brhi	80004ea0 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
80004e14:	8e 39       	ld.sh	r9,r7[0x6]
80004e16:	e0 68 01 01 	mov	r8,257
80004e1a:	f0 09 19 00 	cp.h	r9,r8
80004e1e:	e0 8b 00 41 	brhi	80004ea0 <usart_init_rs232+0xc0>
      opt->channelmode > 3 ||
80004e22:	ef 39 00 08 	ld.ub	r9,r7[8]
80004e26:	30 38       	mov	r8,3
80004e28:	f0 09 18 00 	cp.b	r9,r8
80004e2c:	e0 8b 00 3a 	brhi	80004ea0 <usart_init_rs232+0xc0>
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
80004e30:	0a 9a       	mov	r10,r5
80004e32:	6e 0b       	ld.w	r11,r7[0x0]
80004e34:	0c 9c       	mov	r12,r6
80004e36:	f0 1f 00 1d 	mcall	80004ea8 <usart_init_rs232+0xc8>
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80004e3a:	58 1c       	cp.w	r12,1
80004e3c:	c3 20       	breq	80004ea0 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
    return USART_INVALID_INPUT;

  if (opt->charlength == 9)
80004e3e:	0f c8       	ld.ub	r8,r7[0x4]
80004e40:	30 99       	mov	r9,9
80004e42:	f2 08 18 00 	cp.b	r8,r9
80004e46:	c0 51       	brne	80004e50 <usart_init_rs232+0x70>
  {
    // Character length set to 9 bits. MODE9 dominates CHRL.
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
80004e48:	6c 18       	ld.w	r8,r6[0x4]
80004e4a:	b1 b8       	sbr	r8,0x11
80004e4c:	8d 18       	st.w	r6[0x4],r8
80004e4e:	c0 68       	rjmp	80004e5a <usart_init_rs232+0x7a>
  }
  else
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
80004e50:	6c 19       	ld.w	r9,r6[0x4]
80004e52:	20 58       	sub	r8,5
80004e54:	f3 e8 10 68 	or	r8,r9,r8<<0x6
80004e58:	8d 18       	st.w	r6[0x4],r8
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
80004e5a:	6c 19       	ld.w	r9,r6[0x4]
80004e5c:	ef 3a 00 08 	ld.ub	r10,r7[8]
80004e60:	0f d8       	ld.ub	r8,r7[0x5]
80004e62:	a9 78       	lsl	r8,0x9
80004e64:	f1 ea 10 e8 	or	r8,r8,r10<<0xe
80004e68:	12 48       	or	r8,r9
80004e6a:	8d 18       	st.w	r6[0x4],r8
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;

  if (opt->stopbits > USART_2_STOPBITS)
80004e6c:	8e 38       	ld.sh	r8,r7[0x6]
80004e6e:	30 29       	mov	r9,2
80004e70:	f2 08 19 00 	cp.h	r8,r9
80004e74:	e0 88 00 09 	brls	80004e86 <usart_init_rs232+0xa6>
  {
    // Set two stop bits
    usart->mr |= AVR32_USART_MR_NBSTOP_2 << AVR32_USART_MR_NBSTOP_OFFSET;
80004e78:	6c 18       	ld.w	r8,r6[0x4]
80004e7a:	ad b8       	sbr	r8,0xd
80004e7c:	8d 18       	st.w	r6[0x4],r8
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
80004e7e:	8e b8       	ld.uh	r8,r7[0x6]
80004e80:	20 28       	sub	r8,2
80004e82:	8d a8       	st.w	r6[0x28],r8
80004e84:	c0 68       	rjmp	80004e90 <usart_init_rs232+0xb0>
  }
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;
80004e86:	6c 19       	ld.w	r9,r6[0x4]
80004e88:	5c 78       	castu.h	r8
80004e8a:	f3 e8 10 c8 	or	r8,r9,r8<<0xc
80004e8e:	8d 18       	st.w	r6[0x4],r8

  // Set normal mode.
  usart->mr = (usart->mr & ~AVR32_USART_MR_MODE_MASK) |
80004e90:	6c 18       	ld.w	r8,r6[0x4]
80004e92:	e0 18 ff f0 	andl	r8,0xfff0
80004e96:	8d 18       	st.w	r6[0x4],r8
              AVR32_USART_MR_MODE_NORMAL << AVR32_USART_MR_MODE_OFFSET;

  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
80004e98:	35 08       	mov	r8,80
80004e9a:	8d 08       	st.w	r6[0x0],r8
80004e9c:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
80004ea0:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
80004ea4:	80 00       	ld.sh	r0,r0[0x0]
80004ea6:	4d b4       	lddpc	r4,80005010 <vPortEnterCritical>
80004ea8:	80 00       	ld.sh	r0,r0[0x0]
80004eaa:	4c a4       	lddpc	r4,80004fd0 <pxPortInitialiseStack+0x54>

80004eac <_stext>:

  .global _stext
  .type _stext, @function
_stext:
  // Set initial stack pointer.
  lda.w   sp, _estack
80004eac:	e0 7d 80 00 	mov	sp,98304

  // Set up EVBA so interrupts can be enabled.
  lda.w   r0, _evba
  mtsr    AVR32_EVBA, r0
80004eb0:	fe c0 8e b0 	sub	r0,pc,-29008

  // Enable the exception processing.
  csrf    AVR32_SR_EM_OFFSET
80004eb4:	e3 b0 00 01 	mtsr	0x4,r0

  // Load initialized data having a global lifetime from the data LMA.
  lda.w   r0, _data
  lda.w   r1, _edata
80004eb8:	d5 53       	csrf	0x15
  cp      r0, r1
80004eba:	30 40       	mov	r0,4
  brhs    idata_load_loop_end
80004ebc:	e0 61 0a 48 	mov	r1,2632
  lda.w   r2, _data_lma
idata_load_loop:
  ld.d    r4, r2++
80004ec0:	02 30       	cp.w	r0,r1
  st.d    r0++, r4
80004ec2:	c0 62       	brcc	80004ece <idata_load_loop_end>
  cp      r0, r1
80004ec4:	48 92       	lddpc	r2,80004ee8 <udata_clear_loop_end+0x4>

80004ec6 <idata_load_loop>:
  brlo    idata_load_loop
80004ec6:	a5 05       	ld.d	r4,r2++
idata_load_loop_end:

  // Clear uninitialized data having a global lifetime in the blank static storage section.
  lda.w   r0, __bss_start
80004ec8:	a1 24       	st.d	r0++,r4
  lda.w   r1, _end
80004eca:	02 30       	cp.w	r0,r1
  cp      r0, r1
80004ecc:	cf d3       	brcs	80004ec6 <idata_load_loop>

80004ece <idata_load_loop_end>:
  brhs    udata_clear_loop_end
80004ece:	e0 60 0a 48 	mov	r0,2632
  mov     r2, 0
  mov     r3, 0
80004ed2:	e0 61 41 10 	mov	r1,16656
udata_clear_loop:
  st.d    r0++, r2
  cp      r0, r1
80004ed6:	02 30       	cp.w	r0,r1
  brlo    udata_clear_loop
80004ed8:	c0 62       	brcc	80004ee4 <udata_clear_loop_end>
  // Safety: Set the default "return" @ to the exit routine address.
  lda.w   lr, exit
#endif

  // Start the show.
  lda.w   pc, main
80004eda:	30 02       	mov	r2,0
80004edc:	30 03       	mov	r3,0

80004ede <udata_clear_loop>:
80004ede:	a1 22       	st.d	r0++,r2
80004ee0:	02 30       	cp.w	r0,r1
80004ee2:	cf e3       	brcs	80004ede <udata_clear_loop>

80004ee4 <udata_clear_loop_end>:
80004ee4:	fe cf e9 c4 	sub	pc,pc,-5692
80004ee8:	80 00       	ld.sh	r0,r0[0x0]
80004eea:	d3 28       	*unknown*

80004eec <vListInitialise>:
void vListInitialise( xList *pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
80004eec:	f8 c8 ff f8 	sub	r8,r12,-8
80004ef0:	99 18       	st.w	r12[0x4],r8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
80004ef2:	3f f9       	mov	r9,-1
80004ef4:	99 29       	st.w	r12[0x8],r9

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
80004ef6:	99 38       	st.w	r12[0xc],r8
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
80004ef8:	99 48       	st.w	r12[0x10],r8

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
80004efa:	30 08       	mov	r8,0
80004efc:	99 08       	st.w	r12[0x0],r8
}
80004efe:	5e fc       	retal	r12

80004f00 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
80004f00:	30 08       	mov	r8,0
80004f02:	99 48       	st.w	r12[0x10],r8
}
80004f04:	5e fc       	retal	r12

80004f06 <vListInsertEnd>:

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
80004f06:	78 18       	ld.w	r8,r12[0x4]

	pxNewListItem->pxNext = pxIndex->pxNext;
80004f08:	70 19       	ld.w	r9,r8[0x4]
80004f0a:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxPrevious = pxList->pxIndex;
80004f0c:	78 19       	ld.w	r9,r12[0x4]
80004f0e:	97 29       	st.w	r11[0x8],r9
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80004f10:	70 19       	ld.w	r9,r8[0x4]
80004f12:	93 2b       	st.w	r9[0x8],r11
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
80004f14:	91 1b       	st.w	r8[0x4],r11
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
80004f16:	99 1b       	st.w	r12[0x4],r11

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80004f18:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80004f1a:	78 08       	ld.w	r8,r12[0x0]
80004f1c:	2f f8       	sub	r8,-1
80004f1e:	99 08       	st.w	r12[0x0],r8
}
80004f20:	5e fc       	retal	r12

80004f22 <vListInsert>:
{
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
80004f22:	76 0a       	ld.w	r10,r11[0x0]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
80004f24:	5b fa       	cp.w	r10,-1
80004f26:	c0 31       	brne	80004f2c <vListInsert+0xa>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
80004f28:	78 48       	ld.w	r8,r12[0x10]
80004f2a:	c0 c8       	rjmp	80004f42 <vListInsert+0x20>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
80004f2c:	f8 c8 ff f8 	sub	r8,r12,-8
80004f30:	70 19       	ld.w	r9,r8[0x4]
80004f32:	72 09       	ld.w	r9,r9[0x0]
80004f34:	12 3a       	cp.w	r10,r9
80004f36:	c0 63       	brcs	80004f42 <vListInsert+0x20>
80004f38:	70 18       	ld.w	r8,r8[0x4]
80004f3a:	70 19       	ld.w	r9,r8[0x4]
80004f3c:	72 09       	ld.w	r9,r9[0x0]
80004f3e:	12 3a       	cp.w	r10,r9
80004f40:	cf c2       	brcc	80004f38 <vListInsert+0x16>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
80004f42:	70 19       	ld.w	r9,r8[0x4]
80004f44:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80004f46:	93 2b       	st.w	r9[0x8],r11
	pxNewListItem->pxPrevious = pxIterator;
80004f48:	97 28       	st.w	r11[0x8],r8
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
80004f4a:	91 1b       	st.w	r8[0x4],r11

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80004f4c:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80004f4e:	78 08       	ld.w	r8,r12[0x0]
80004f50:	2f f8       	sub	r8,-1
80004f52:	99 08       	st.w	r12[0x0],r8
}
80004f54:	5e fc       	retal	r12

80004f56 <vListRemove>:

void vListRemove( xListItem *pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
80004f56:	78 18       	ld.w	r8,r12[0x4]
80004f58:	78 29       	ld.w	r9,r12[0x8]
80004f5a:	91 29       	st.w	r8[0x8],r9
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
80004f5c:	78 28       	ld.w	r8,r12[0x8]
80004f5e:	78 19       	ld.w	r9,r12[0x4]
80004f60:	91 19       	st.w	r8[0x4],r9

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
80004f62:	78 48       	ld.w	r8,r12[0x10]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
80004f64:	70 19       	ld.w	r9,r8[0x4]
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
80004f66:	18 39       	cp.w	r9,r12
80004f68:	f9 f9 00 02 	ld.weq	r9,r12[0x8]
80004f6c:	f1 f9 0a 01 	st.weq	r8[0x4],r9
	}

	pxItemToRemove->pvContainer = NULL;
80004f70:	30 09       	mov	r9,0
80004f72:	99 49       	st.w	r12[0x10],r9
	( pxList->uxNumberOfItems )--;
80004f74:	70 09       	ld.w	r9,r8[0x0]
80004f76:	20 19       	sub	r9,1
80004f78:	91 09       	st.w	r8[0x0],r9
}
80004f7a:	5e fc       	retal	r12

80004f7c <pxPortInitialiseStack>:
	/* Setup the initial stack of the task.  The stack is set exactly as
	expected by the portRESTORE_CONTEXT() macro. */

	/* When the task starts, it will expect to find the function parameter in R12. */
	pxTopOfStack--;
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x08080808;					/* R8 */
80004f7c:	e0 68 08 08 	mov	r8,2056
80004f80:	ea 18 08 08 	orh	r8,0x808
80004f84:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x09090909;					/* R9 */
80004f86:	e0 68 09 09 	mov	r8,2313
80004f8a:	ea 18 09 09 	orh	r8,0x909
80004f8e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0A0A0A0A;					/* R10 */
80004f90:	e0 68 0a 0a 	mov	r8,2570
80004f94:	ea 18 0a 0a 	orh	r8,0xa0a
80004f98:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0B0B0B0B;					/* R11 */
80004f9a:	e0 68 0b 0b 	mov	r8,2827
80004f9e:	ea 18 0b 0b 	orh	r8,0xb0b
80004fa2:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pvParameters;					/* R12 */
80004fa4:	18 da       	st.w	--r12,r10
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xDEADBEEF;					/* R14/LR */
80004fa6:	e0 68 be ef 	mov	r8,48879
80004faa:	ea 18 de ad 	orh	r8,0xdead
80004fae:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pxCode + portINSTRUCTION_SIZE; /* R15/PC */
80004fb0:	18 db       	st.w	--r12,r11
	*pxTopOfStack-- = ( portSTACK_TYPE ) portINITIAL_SR;				/* SR */
80004fb2:	fc 18 00 40 	movh	r8,0x40
80004fb6:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xFF0000FF;					/* R0 */
80004fb8:	e0 68 00 ff 	mov	r8,255
80004fbc:	ea 18 ff 00 	orh	r8,0xff00
80004fc0:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x01010101;					/* R1 */
80004fc2:	e0 68 01 01 	mov	r8,257
80004fc6:	ea 18 01 01 	orh	r8,0x101
80004fca:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x02020202;					/* R2 */
80004fcc:	e0 68 02 02 	mov	r8,514
80004fd0:	ea 18 02 02 	orh	r8,0x202
80004fd4:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x03030303;					/* R3 */
80004fd6:	e0 68 03 03 	mov	r8,771
80004fda:	ea 18 03 03 	orh	r8,0x303
80004fde:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x04040404;					/* R4 */
80004fe0:	e0 68 04 04 	mov	r8,1028
80004fe4:	ea 18 04 04 	orh	r8,0x404
80004fe8:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x05050505;					/* R5 */
80004fea:	e0 68 05 05 	mov	r8,1285
80004fee:	ea 18 05 05 	orh	r8,0x505
80004ff2:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x06060606;					/* R6 */
80004ff4:	e0 68 06 06 	mov	r8,1542
80004ff8:	ea 18 06 06 	orh	r8,0x606
80004ffc:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x07070707;					/* R7 */
80004ffe:	e0 68 07 07 	mov	r8,1799
80005002:	ea 18 07 07 	orh	r8,0x707
80005006:	18 d8       	st.w	--r12,r8
	*pxTopOfStack = ( portSTACK_TYPE ) portNO_CRITICAL_NESTING;			/* ulCriticalNesting */
80005008:	30 08       	mov	r8,0
8000500a:	18 d8       	st.w	--r12,r8

	return pxTopOfStack;
}
8000500c:	5e fc       	retal	r12
8000500e:	d7 03       	nop

80005010 <vPortEnterCritical>:
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
__attribute__((__noinline__)) void vPortEnterCritical( void )
{
	/* Disable interrupts */
	portDISABLE_INTERRUPTS();
80005010:	d3 03       	ssrf	0x10

	/* Now interrupts are disabled ulCriticalNesting can be accessed
	 directly.  Increment ulCriticalNesting to keep a count of how many times
	 portENTER_CRITICAL() has been called. */
	ulCriticalNesting++;
80005012:	48 38       	lddpc	r8,8000501c <vPortEnterCritical+0xc>
80005014:	70 09       	ld.w	r9,r8[0x0]
80005016:	2f f9       	sub	r9,-1
80005018:	91 09       	st.w	r8[0x0],r9
}
8000501a:	5e fc       	retal	r12
8000501c:	00 00       	add	r0,r0
8000501e:	05 38       	ld.ub	r8,r2++

80005020 <xPortStartScheduler>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
80005020:	d4 01       	pushm	lr
	};

#endif

	/* Disable all interrupt/exception. */
	portDISABLE_INTERRUPTS();
80005022:	d3 03       	ssrf	0x10
		/* Start the timer/counter. */
		tc_start(tc, configTICK_TC_CHANNEL);
	}
	#else
	{
		INTC_register_interrupt(&vTick, AVR32_CORE_COMPARE_IRQ, AVR32_INTC_INT0);
80005024:	30 0a       	mov	r10,0
80005026:	14 9b       	mov	r11,r10
80005028:	49 2c       	lddpc	r12,80005070 <xPortStartScheduler+0x50>
8000502a:	f0 1f 00 13 	mcall	80005074 <xPortStartScheduler+0x54>
/* Schedule the COUNT&COMPARE match interrupt in (configCPU_CLOCK_HZ/configTICK_RATE_HZ)
clock cycles from now. */
#if( configTICK_USE_TC==0 )
	static void prvScheduleFirstTick(void)
	{
		Set_system_register(AVR32_COMPARE, configCPU_CLOCK_HZ/configTICK_RATE_HZ);//cause!!!
8000502e:	e0 68 5d c0 	mov	r8,24000
80005032:	e3 b8 00 43 	mtsr	0x10c,r8
		Set_system_register(AVR32_COUNT, 0);
80005036:	30 08       	mov	r8,0
80005038:	e3 b8 00 42 	mtsr	0x108,r8
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();

	/* Start the first task. */
	portRESTORE_CONTEXT();
8000503c:	e0 68 0c e4 	mov	r8,3300
80005040:	ea 18 00 00 	orh	r8,0x0
80005044:	70 00       	ld.w	r0,r8[0x0]
80005046:	60 0d       	ld.w	sp,r0[0x0]
80005048:	1b 00       	ld.w	r0,sp++
8000504a:	e0 68 05 38 	mov	r8,1336
8000504e:	ea 18 00 00 	orh	r8,0x0
80005052:	91 00       	st.w	r8[0x0],r0
80005054:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005058:	2f ed       	sub	sp,-8
8000505a:	e3 cd 5f 00 	ldm	sp++,r8-r12,lr
8000505e:	fa f0 ff e0 	ld.w	r0,sp[-32]
80005062:	e3 b0 00 00 	mtsr	0x0,r0
80005066:	fa f0 ff dc 	ld.w	r0,sp[-36]
8000506a:	fa ff ff e4 	ld.w	pc,sp[-28]

	/* Should not get here! */
	return 0;
}
8000506e:	d8 0a       	popm	pc,r12=0
80005070:	80 00       	ld.sh	r0,r0[0x0]
80005072:	51 3c       	stdsp	sp[0x4c],r12
80005074:	80 00       	ld.sh	r0,r0[0x0]
80005076:	4b 98       	lddpc	r8,80005158 <vTick+0x1c>

80005078 <SCALLYield>:
/*-----------------------------------------------------------*/
__attribute__((__naked__)) void SCALLYield( void );
__attribute__((__naked__)) void SCALLYield( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_SCALL();
80005078:	20 6d       	sub	sp,24
8000507a:	eb cd 00 ff 	pushm	r0-r7
8000507e:	fa c7 ff c0 	sub	r7,sp,-64
80005082:	ee f0 ff f8 	ld.w	r0,r7[-8]
80005086:	ef 40 ff e0 	st.w	r7[-32],r0
8000508a:	ee f0 ff fc 	ld.w	r0,r7[-4]
8000508e:	ef 40 ff e4 	st.w	r7[-28],r0
80005092:	eb c7 5f 00 	stm	--r7,r8-r12,lr
80005096:	e0 68 05 38 	mov	r8,1336
8000509a:	ea 18 00 00 	orh	r8,0x0
8000509e:	70 00       	ld.w	r0,r8[0x0]
800050a0:	1a d0       	st.w	--sp,r0
800050a2:	f0 1f 00 1a 	mcall	80005108 <LABEL_RET_SCALL_263+0x14>
800050a6:	e0 68 0c e4 	mov	r8,3300
800050aa:	ea 18 00 00 	orh	r8,0x0
800050ae:	70 00       	ld.w	r0,r8[0x0]
800050b0:	81 0d       	st.w	r0[0x0],sp
	vTaskSwitchContext();
800050b2:	f0 1f 00 17 	mcall	8000510c <LABEL_RET_SCALL_263+0x18>
	portRESTORE_CONTEXT_SCALL();
800050b6:	e0 68 0c e4 	mov	r8,3300
800050ba:	ea 18 00 00 	orh	r8,0x0
800050be:	70 00       	ld.w	r0,r8[0x0]
800050c0:	60 0d       	ld.w	sp,r0[0x0]
800050c2:	1b 00       	ld.w	r0,sp++
800050c4:	e0 68 05 38 	mov	r8,1336
800050c8:	ea 18 00 00 	orh	r8,0x0
800050cc:	91 00       	st.w	r8[0x0],r0
800050ce:	fa c7 ff d8 	sub	r7,sp,-40
800050d2:	e3 c7 5f 00 	ldm	r7++,r8-r12,lr
800050d6:	ee f0 ff e0 	ld.w	r0,r7[-32]
800050da:	e0 61 05 38 	mov	r1,1336
800050de:	ea 11 00 00 	orh	r1,0x0
800050e2:	62 02       	ld.w	r2,r1[0x0]
800050e4:	58 02       	cp.w	r2,0
800050e6:	c0 70       	breq	800050f4 <LABEL_RET_SCALL_263>
800050e8:	e4 c2 00 01 	sub	r2,r2,1
800050ec:	83 02       	st.w	r1[0x0],r2
800050ee:	58 02       	cp.w	r2,0
800050f0:	c0 21       	brne	800050f4 <LABEL_RET_SCALL_263>
800050f2:	b1 c0       	cbr	r0,0x10

800050f4 <LABEL_RET_SCALL_263>:
800050f4:	ef 40 ff f8 	st.w	r7[-8],r0
800050f8:	ee f0 ff e4 	ld.w	r0,r7[-28]
800050fc:	ef 40 ff fc 	st.w	r7[-4],r0
80005100:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005104:	2f ad       	sub	sp,-24
80005106:	d6 13       	rets
80005108:	80 00       	ld.sh	r0,r0[0x0]
8000510a:	50 10       	stdsp	sp[0x4],r0
8000510c:	80 00       	ld.sh	r0,r0[0x0]
8000510e:	57 54       	stdsp	sp[0x1d4],r4

80005110 <prvClearCcInt>:
		Set_system_register(AVR32_COUNT, 0);
	}

	__attribute__((__noinline__)) static void prvClearCcInt(void)
	{
		Set_system_register(AVR32_COMPARE, Get_system_register(AVR32_COMPARE));
80005110:	e1 b8 00 43 	mfsr	r8,0x10c
80005114:	e3 b8 00 43 	mtsr	0x10c,r8
	}
80005118:	5e fc       	retal	r12
8000511a:	d7 03       	nop

8000511c <vPortExitCritical>:
}
/*-----------------------------------------------------------*/

__attribute__((__noinline__)) void vPortExitCritical( void )
{
	if(ulCriticalNesting > portNO_CRITICAL_NESTING)
8000511c:	48 78       	lddpc	r8,80005138 <vPortExitCritical+0x1c>
8000511e:	70 08       	ld.w	r8,r8[0x0]
80005120:	58 08       	cp.w	r8,0
80005122:	5e 0c       	reteq	r12
	{
		ulCriticalNesting--;
80005124:	48 58       	lddpc	r8,80005138 <vPortExitCritical+0x1c>
80005126:	70 09       	ld.w	r9,r8[0x0]
80005128:	20 19       	sub	r9,1
8000512a:	91 09       	st.w	r8[0x0],r9
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
8000512c:	70 08       	ld.w	r8,r8[0x0]
8000512e:	58 08       	cp.w	r8,0
80005130:	5e 1c       	retne	r12
		{
			/* Enable all interrupt/exception. */
			portENABLE_INTERRUPTS();
80005132:	d5 03       	csrf	0x10
80005134:	5e fc       	retal	r12
80005136:	00 00       	add	r0,r0
80005138:	00 00       	add	r0,r0
8000513a:	05 38       	ld.ub	r8,r2++

8000513c <vTick>:
/* The preemptive scheduler is defined as "naked" as the full context is saved
on entry as part of the context switch. */
__attribute__((__naked__)) static void vTick( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_OS_INT();
8000513c:	eb cd 00 ff 	pushm	r0-r7
80005140:	e0 68 05 38 	mov	r8,1336
80005144:	ea 18 00 00 	orh	r8,0x0
80005148:	70 00       	ld.w	r0,r8[0x0]
8000514a:	1a d0       	st.w	--sp,r0
8000514c:	7a 90       	ld.w	r0,sp[0x24]
8000514e:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80005152:	58 10       	cp.w	r0,1
80005154:	e0 8b 00 08 	brhi	80005164 <LABEL_INT_SKIP_SAVE_CONTEXT_237>
80005158:	e0 68 0c e4 	mov	r8,3300
8000515c:	ea 18 00 00 	orh	r8,0x0
80005160:	70 00       	ld.w	r0,r8[0x0]
80005162:	81 0d       	st.w	r0[0x0],sp

80005164 <LABEL_INT_SKIP_SAVE_CONTEXT_237>:
	#if( configTICK_USE_TC==1 )
		/* Clear the interrupt flag. */
		prvClearTcInt();
	#else
		/* Clear the interrupt flag. */
		prvClearCcInt();
80005164:	f0 1f 00 12 	mcall	800051ac <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x14>
	#endif

	/* Because FreeRTOS is not supposed to run with nested interrupts, put all OS
	calls in a critical section . */
	portENTER_CRITICAL();
80005168:	f0 1f 00 12 	mcall	800051b0 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
		vTaskIncrementTick();
8000516c:	f0 1f 00 12 	mcall	800051b4 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x1c>
	portEXIT_CRITICAL();
80005170:	f0 1f 00 12 	mcall	800051b8 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>

	/* Restore the context of the "elected task". */
	portRESTORE_CONTEXT_OS_INT();
80005174:	7a 90       	ld.w	r0,sp[0x24]
80005176:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
8000517a:	58 10       	cp.w	r0,1
8000517c:	e0 8b 00 0e 	brhi	80005198 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>
80005180:	f0 1f 00 0c 	mcall	800051b0 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
80005184:	f0 1f 00 0e 	mcall	800051bc <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x24>
80005188:	f0 1f 00 0c 	mcall	800051b8 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>
8000518c:	e0 68 0c e4 	mov	r8,3300
80005190:	ea 18 00 00 	orh	r8,0x0
80005194:	70 00       	ld.w	r0,r8[0x0]
80005196:	60 0d       	ld.w	sp,r0[0x0]

80005198 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>:
80005198:	1b 00       	ld.w	r0,sp++
8000519a:	e0 68 05 38 	mov	r8,1336
8000519e:	ea 18 00 00 	orh	r8,0x0
800051a2:	91 00       	st.w	r8[0x0],r0
800051a4:	e3 cd 00 ff 	ldm	sp++,r0-r7
800051a8:	d6 03       	rete
800051aa:	00 00       	add	r0,r0
800051ac:	80 00       	ld.sh	r0,r0[0x0]
800051ae:	51 10       	stdsp	sp[0x44],r0
800051b0:	80 00       	ld.sh	r0,r0[0x0]
800051b2:	50 10       	stdsp	sp[0x4],r0
800051b4:	80 00       	ld.sh	r0,r0[0x0]
800051b6:	59 58       	cp.w	r8,21
800051b8:	80 00       	ld.sh	r0,r0[0x0]
800051ba:	51 1c       	stdsp	sp[0x44],r12
800051bc:	80 00       	ld.sh	r0,r0[0x0]
800051be:	57 54       	stdsp	sp[0x1d4],r4

800051c0 <__malloc_lock>:
 * safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_lock(struct _reent *ptr);
void __malloc_lock(struct _reent *ptr)
{
800051c0:	d4 01       	pushm	lr
	vTaskSuspendAll();
800051c2:	f0 1f 00 02 	mcall	800051c8 <__malloc_lock+0x8>
}
800051c6:	d8 02       	popm	pc
800051c8:	80 00       	ld.sh	r0,r0[0x0]
800051ca:	57 44       	stdsp	sp[0x1d0],r4

800051cc <__malloc_unlock>:
 * a safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_unlock(struct _reent *ptr);
void __malloc_unlock(struct _reent *ptr)
{
800051cc:	d4 01       	pushm	lr
	xTaskResumeAll();
800051ce:	f0 1f 00 02 	mcall	800051d4 <__malloc_unlock+0x8>
}
800051d2:	d8 02       	popm	pc
800051d4:	80 00       	ld.sh	r0,r0[0x0]
800051d6:	5b 00       	cp.w	r0,-16

800051d8 <_read>:
/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
{
800051d8:	d4 21       	pushm	r4-r7,lr
800051da:	16 95       	mov	r5,r11
800051dc:	14 96       	mov	r6,r10
  int nChars = 0;

  if (file != 0)
800051de:	58 0c       	cp.w	r12,0
800051e0:	c0 30       	breq	800051e6 <_read+0xe>
800051e2:	3f f7       	mov	r7,-1
800051e4:	c1 48       	rjmp	8000520c <_read+0x34>
    return -1;

  for (; len > 0; --len)
800051e6:	58 0a       	cp.w	r10,0
800051e8:	e0 89 00 04 	brgt	800051f0 <_read+0x18>
800051ec:	30 07       	mov	r7,0
800051ee:	c0 f8       	rjmp	8000520c <_read+0x34>
800051f0:	30 07       	mov	r7,0
  {
    int c = usart_getchar(stdio_usart_base);
800051f2:	48 84       	lddpc	r4,80005210 <_read+0x38>
800051f4:	68 0c       	ld.w	r12,r4[0x0]
800051f6:	f0 1f 00 08 	mcall	80005214 <_read+0x3c>
    if (c < 0)
800051fa:	c0 95       	brlt	8000520c <_read+0x34>
      break;

    *ptr++ = c;
800051fc:	ea 07 0b 0c 	st.b	r5[r7],r12
    ++nChars;
80005200:	2f f7       	sub	r7,-1

/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
80005202:	ec 07 01 08 	sub	r8,r6,r7
  int nChars = 0;

  if (file != 0)
    return -1;

  for (; len > 0; --len)
80005206:	58 08       	cp.w	r8,0
80005208:	fe 99 ff f6 	brgt	800051f4 <_read+0x1c>
    *ptr++ = c;
    ++nChars;
  }

  return nChars;
}
8000520c:	0e 9c       	mov	r12,r7
8000520e:	d8 22       	popm	r4-r7,pc
80005210:	00 00       	add	r0,r0
80005212:	41 04       	lddsp	r4,sp[0x40]
80005214:	80 00       	ld.sh	r0,r0[0x0]
80005216:	4d 64       	lddpc	r4,8000536c <prvUnlockQueue+0x48>

80005218 <_write>:
 * 1 and 2 is stdout and stderr which goes to usart
 * 3 is framebuffer
 */
int __attribute__((weak))
_write (int file, char * ptr, int len)
{
80005218:	d4 21       	pushm	r4-r7,lr
8000521a:	16 95       	mov	r5,r11
8000521c:	14 96       	mov	r6,r10
  int nChars = 0;

  if ( (file != 1)
8000521e:	20 1c       	sub	r12,1
80005220:	58 2c       	cp.w	r12,2
80005222:	e0 8b 00 12 	brhi	80005246 <_write+0x2e>
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80005226:	58 0a       	cp.w	r10,0
80005228:	c0 31       	brne	8000522e <_write+0x16>
8000522a:	30 07       	mov	r7,0
8000522c:	c0 e8       	rjmp	80005248 <_write+0x30>
8000522e:	30 07       	mov	r7,0
  {
    if (usart_putchar(stdio_usart_base, *ptr++) < 0)
80005230:	48 74       	lddpc	r4,8000524c <_write+0x34>
80005232:	68 0c       	ld.w	r12,r4[0x0]
80005234:	ea 07 07 0b 	ld.ub	r11,r5[r7]
80005238:	f0 1f 00 06 	mcall	80005250 <_write+0x38>
8000523c:	c0 55       	brlt	80005246 <_write+0x2e>
    {
      return -1;
    }

    ++nChars;
8000523e:	2f f7       	sub	r7,-1

  if ( (file != 1)
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80005240:	0e 36       	cp.w	r6,r7
80005242:	cf 81       	brne	80005232 <_write+0x1a>
80005244:	c0 28       	rjmp	80005248 <_write+0x30>
80005246:	3f f7       	mov	r7,-1

    ++nChars;
  }

  return nChars;
}
80005248:	0e 9c       	mov	r12,r7
8000524a:	d8 22       	popm	r4-r7,pc
8000524c:	00 00       	add	r0,r0
8000524e:	41 04       	lddsp	r4,sp[0x40]
80005250:	80 00       	ld.sh	r0,r0[0x0]
80005252:	4d 14       	lddpc	r4,80005394 <prvUnlockQueue+0x70>

80005254 <vPortFree>:
	return pvReturn;
}
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
80005254:	eb cd 40 80 	pushm	r7,lr
80005258:	18 97       	mov	r7,r12
	if( pv )
8000525a:	58 0c       	cp.w	r12,0
8000525c:	c0 80       	breq	8000526c <vPortFree+0x18>
	{
		vTaskSuspendAll();
8000525e:	f0 1f 00 05 	mcall	80005270 <vPortFree+0x1c>
		{
			free( pv );
80005262:	0e 9c       	mov	r12,r7
80005264:	f0 1f 00 04 	mcall	80005274 <vPortFree+0x20>
		}
		xTaskResumeAll();
80005268:	f0 1f 00 04 	mcall	80005278 <vPortFree+0x24>
8000526c:	e3 cd 80 80 	ldm	sp++,r7,pc
80005270:	80 00       	ld.sh	r0,r0[0x0]
80005272:	57 44       	stdsp	sp[0x1d0],r4
80005274:	80 00       	ld.sh	r0,r0[0x0]
80005276:	65 9c       	ld.w	r12,r2[0x64]
80005278:	80 00       	ld.sh	r0,r0[0x0]
8000527a:	5b 00       	cp.w	r0,-16

8000527c <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
8000527c:	eb cd 40 80 	pushm	r7,lr
80005280:	18 97       	mov	r7,r12
void *pvReturn;

	vTaskSuspendAll();
80005282:	f0 1f 00 06 	mcall	80005298 <pvPortMalloc+0x1c>
	{
		pvReturn = malloc( xWantedSize );
80005286:	0e 9c       	mov	r12,r7
80005288:	f0 1f 00 05 	mcall	8000529c <pvPortMalloc+0x20>
8000528c:	18 97       	mov	r7,r12
	}
	xTaskResumeAll();
8000528e:	f0 1f 00 05 	mcall	800052a0 <pvPortMalloc+0x24>
		}
	}
	#endif

	return pvReturn;
}
80005292:	0e 9c       	mov	r12,r7
80005294:	e3 cd 80 80 	ldm	sp++,r7,pc
80005298:	80 00       	ld.sh	r0,r0[0x0]
8000529a:	57 44       	stdsp	sp[0x1d0],r4
8000529c:	80 00       	ld.sh	r0,r0[0x0]
8000529e:	65 ac       	ld.w	r12,r2[0x68]
800052a0:	80 00       	ld.sh	r0,r0[0x0]
800052a2:	5b 00       	cp.w	r0,-16

800052a4 <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
800052a4:	d4 01       	pushm	lr
800052a6:	16 98       	mov	r8,r11
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
800052a8:	78 09       	ld.w	r9,r12[0x0]
800052aa:	58 09       	cp.w	r9,0
800052ac:	c1 10       	breq	800052ce <prvCopyDataFromQueue+0x2a>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
800052ae:	78 3a       	ld.w	r10,r12[0xc]
800052b0:	79 09       	ld.w	r9,r12[0x40]
800052b2:	f4 09 00 09 	add	r9,r10,r9
800052b6:	99 39       	st.w	r12[0xc],r9
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
800052b8:	78 1a       	ld.w	r10,r12[0x4]
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
800052ba:	14 39       	cp.w	r9,r10
800052bc:	f9 f9 20 00 	ld.wcc	r9,r12[0x0]
800052c0:	f9 f9 2a 03 	st.wcc	r12[0xc],r9
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
800052c4:	79 0a       	ld.w	r10,r12[0x40]
800052c6:	78 3b       	ld.w	r11,r12[0xc]
800052c8:	10 9c       	mov	r12,r8
800052ca:	f0 1f 00 02 	mcall	800052d0 <prvCopyDataFromQueue+0x2c>
800052ce:	d8 02       	popm	pc
800052d0:	80 00       	ld.sh	r0,r0[0x0]
800052d2:	69 f4       	ld.w	r4,r4[0x7c]

800052d4 <xQueueReceiveFromISR>:
	}
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
800052d4:	eb cd 40 c0 	pushm	r6-r7,lr
800052d8:	18 97       	mov	r7,r12
800052da:	14 96       	mov	r6,r10
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
800052dc:	78 e8       	ld.w	r8,r12[0x38]
800052de:	58 08       	cp.w	r8,0
800052e0:	c0 31       	brne	800052e6 <xQueueReceiveFromISR+0x12>
800052e2:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
800052e6:	f0 1f 00 0e 	mcall	8000531c <xQueueReceiveFromISR+0x48>
			--( pxQueue->uxMessagesWaiting );
800052ea:	6e e8       	ld.w	r8,r7[0x38]
800052ec:	20 18       	sub	r8,1
800052ee:	8f e8       	st.w	r7[0x38],r8

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
800052f0:	6f 18       	ld.w	r8,r7[0x44]
800052f2:	5b f8       	cp.w	r8,-1
800052f4:	c0 d1       	brne	8000530e <xQueueReceiveFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
800052f6:	6e 48       	ld.w	r8,r7[0x10]
800052f8:	58 08       	cp.w	r8,0
800052fa:	c0 f0       	breq	80005318 <xQueueReceiveFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
800052fc:	ee cc ff f0 	sub	r12,r7,-16
80005300:	f0 1f 00 08 	mcall	80005320 <xQueueReceiveFromISR+0x4c>
80005304:	c0 a0       	breq	80005318 <xQueueReceiveFromISR+0x44>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
80005306:	30 1c       	mov	r12,1
80005308:	8d 0c       	st.w	r6[0x0],r12
8000530a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
8000530e:	2f f8       	sub	r8,-1
80005310:	ef 48 00 44 	st.w	r7[68],r8
80005314:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80005318:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
8000531c:	80 00       	ld.sh	r0,r0[0x0]
8000531e:	52 a4       	stdsp	sp[0xa8],r4
80005320:	80 00       	ld.sh	r0,r0[0x0]
80005322:	58 dc       	cp.w	r12,13

80005324 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
80005324:	eb cd 40 c0 	pushm	r6-r7,lr
80005328:	18 97       	mov	r7,r12

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
8000532a:	f0 1f 00 23 	mcall	800053b4 <prvUnlockQueue+0x90>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
8000532e:	6f 28       	ld.w	r8,r7[0x48]
80005330:	58 08       	cp.w	r8,0
80005332:	e0 8a 00 18 	brle	80005362 <prvUnlockQueue+0x3e>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005336:	6e 98       	ld.w	r8,r7[0x24]
80005338:	58 08       	cp.w	r8,0
8000533a:	c1 40       	breq	80005362 <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
8000533c:	ee c6 ff dc 	sub	r6,r7,-36
80005340:	c0 48       	rjmp	80005348 <prvUnlockQueue+0x24>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005342:	6e 98       	ld.w	r8,r7[0x24]
80005344:	58 08       	cp.w	r8,0
80005346:	c0 e0       	breq	80005362 <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80005348:	0c 9c       	mov	r12,r6
8000534a:	f0 1f 00 1c 	mcall	800053b8 <prvUnlockQueue+0x94>
8000534e:	c0 30       	breq	80005354 <prvUnlockQueue+0x30>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
80005350:	f0 1f 00 1b 	mcall	800053bc <prvUnlockQueue+0x98>
				}

				--( pxQueue->xTxLock );
80005354:	6f 28       	ld.w	r8,r7[0x48]
80005356:	20 18       	sub	r8,1
80005358:	ef 48 00 48 	st.w	r7[72],r8
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
8000535c:	58 08       	cp.w	r8,0
8000535e:	fe 99 ff f2 	brgt	80005342 <prvUnlockQueue+0x1e>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
80005362:	3f f8       	mov	r8,-1
80005364:	ef 48 00 48 	st.w	r7[72],r8
	}
	taskEXIT_CRITICAL();
80005368:	f0 1f 00 16 	mcall	800053c0 <prvUnlockQueue+0x9c>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
8000536c:	f0 1f 00 12 	mcall	800053b4 <prvUnlockQueue+0x90>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
80005370:	6f 18       	ld.w	r8,r7[0x44]
80005372:	58 08       	cp.w	r8,0
80005374:	e0 8a 00 18 	brle	800053a4 <prvUnlockQueue+0x80>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80005378:	6e 48       	ld.w	r8,r7[0x10]
8000537a:	58 08       	cp.w	r8,0
8000537c:	c1 40       	breq	800053a4 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
8000537e:	ee c6 ff f0 	sub	r6,r7,-16
80005382:	c0 48       	rjmp	8000538a <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80005384:	6e 48       	ld.w	r8,r7[0x10]
80005386:	58 08       	cp.w	r8,0
80005388:	c0 e0       	breq	800053a4 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
8000538a:	0c 9c       	mov	r12,r6
8000538c:	f0 1f 00 0b 	mcall	800053b8 <prvUnlockQueue+0x94>
80005390:	c0 30       	breq	80005396 <prvUnlockQueue+0x72>
				{
					vTaskMissedYield();
80005392:	f0 1f 00 0b 	mcall	800053bc <prvUnlockQueue+0x98>
				}

				--( pxQueue->xRxLock );
80005396:	6f 18       	ld.w	r8,r7[0x44]
80005398:	20 18       	sub	r8,1
8000539a:	ef 48 00 44 	st.w	r7[68],r8
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
8000539e:	58 08       	cp.w	r8,0
800053a0:	fe 99 ff f2 	brgt	80005384 <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
800053a4:	3f f8       	mov	r8,-1
800053a6:	ef 48 00 44 	st.w	r7[68],r8
	}
	taskEXIT_CRITICAL();
800053aa:	f0 1f 00 06 	mcall	800053c0 <prvUnlockQueue+0x9c>
}
800053ae:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800053b2:	00 00       	add	r0,r0
800053b4:	80 00       	ld.sh	r0,r0[0x0]
800053b6:	50 10       	stdsp	sp[0x4],r0
800053b8:	80 00       	ld.sh	r0,r0[0x0]
800053ba:	58 dc       	cp.w	r12,13
800053bc:	80 00       	ld.sh	r0,r0[0x0]
800053be:	57 e8       	stdsp	sp[0x1f8],r8
800053c0:	80 00       	ld.sh	r0,r0[0x0]
800053c2:	51 1c       	stdsp	sp[0x44],r12

800053c4 <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
800053c4:	d4 31       	pushm	r0-r7,lr
800053c6:	20 5d       	sub	sp,20
800053c8:	18 97       	mov	r7,r12
800053ca:	50 0b       	stdsp	sp[0x0],r11
800053cc:	50 2a       	stdsp	sp[0x8],r10
800053ce:	50 19       	stdsp	sp[0x4],r9
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
800053d0:	f8 c2 ff dc 	sub	r2,r12,-36
800053d4:	30 05       	mov	r5,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
800053d6:	fa c4 ff f4 	sub	r4,sp,-12
800053da:	30 10       	mov	r0,1

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
800053dc:	0a 91       	mov	r1,r5

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
800053de:	fa c3 ff f8 	sub	r3,sp,-8
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
800053e2:	f0 1f 00 3e 	mcall	800054d8 <xQueueGenericReceive+0x114>
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
800053e6:	6e e8       	ld.w	r8,r7[0x38]
800053e8:	58 08       	cp.w	r8,0
800053ea:	c2 a0       	breq	8000543e <xQueueGenericReceive+0x7a>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
800053ec:	6e 36       	ld.w	r6,r7[0xc]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
800053ee:	40 0b       	lddsp	r11,sp[0x0]
800053f0:	0e 9c       	mov	r12,r7
800053f2:	f0 1f 00 3b 	mcall	800054dc <xQueueGenericReceive+0x118>

				if( xJustPeeking == pdFALSE )
800053f6:	40 18       	lddsp	r8,sp[0x4]
800053f8:	58 08       	cp.w	r8,0
800053fa:	c1 51       	brne	80005424 <xQueueGenericReceive+0x60>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
800053fc:	6e e8       	ld.w	r8,r7[0x38]
800053fe:	20 18       	sub	r8,1
80005400:	8f e8       	st.w	r7[0x38],r8

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80005402:	6e 08       	ld.w	r8,r7[0x0]
80005404:	58 08       	cp.w	r8,0
80005406:	c0 41       	brne	8000540e <xQueueGenericReceive+0x4a>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
80005408:	f0 1f 00 36 	mcall	800054e0 <xQueueGenericReceive+0x11c>
8000540c:	8f 1c       	st.w	r7[0x4],r12
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
8000540e:	6e 48       	ld.w	r8,r7[0x10]
80005410:	58 08       	cp.w	r8,0
80005412:	c1 20       	breq	80005436 <xQueueGenericReceive+0x72>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
80005414:	ee cc ff f0 	sub	r12,r7,-16
80005418:	f0 1f 00 33 	mcall	800054e4 <xQueueGenericReceive+0x120>
8000541c:	58 1c       	cp.w	r12,1
8000541e:	c0 c1       	brne	80005436 <xQueueGenericReceive+0x72>
						{
							portYIELD_WITHIN_API();
80005420:	d7 33       	scall
80005422:	c0 a8       	rjmp	80005436 <xQueueGenericReceive+0x72>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
80005424:	8f 36       	st.w	r7[0xc],r6

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005426:	6e 98       	ld.w	r8,r7[0x24]
80005428:	58 08       	cp.w	r8,0
8000542a:	c0 60       	breq	80005436 <xQueueGenericReceive+0x72>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
8000542c:	04 9c       	mov	r12,r2
8000542e:	f0 1f 00 2e 	mcall	800054e4 <xQueueGenericReceive+0x120>
80005432:	c0 20       	breq	80005436 <xQueueGenericReceive+0x72>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
80005434:	d7 33       	scall
						}
					}

				}

				taskEXIT_CRITICAL();
80005436:	f0 1f 00 2d 	mcall	800054e8 <xQueueGenericReceive+0x124>
8000543a:	30 1c       	mov	r12,1
				return pdPASS;
8000543c:	c4 c8       	rjmp	800054d4 <xQueueGenericReceive+0x110>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
8000543e:	40 28       	lddsp	r8,sp[0x8]
80005440:	58 08       	cp.w	r8,0
80005442:	c0 51       	brne	8000544c <xQueueGenericReceive+0x88>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80005444:	f0 1f 00 29 	mcall	800054e8 <xQueueGenericReceive+0x124>
80005448:	30 0c       	mov	r12,0
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
8000544a:	c4 58       	rjmp	800054d4 <xQueueGenericReceive+0x110>
				}
				else if( xEntryTimeSet == pdFALSE )
8000544c:	58 05       	cp.w	r5,0
8000544e:	c0 51       	brne	80005458 <xQueueGenericReceive+0x94>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80005450:	08 9c       	mov	r12,r4
80005452:	f0 1f 00 27 	mcall	800054ec <xQueueGenericReceive+0x128>
80005456:	00 95       	mov	r5,r0
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80005458:	f0 1f 00 24 	mcall	800054e8 <xQueueGenericReceive+0x124>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
8000545c:	f0 1f 00 25 	mcall	800054f0 <xQueueGenericReceive+0x12c>
		prvLockQueue( pxQueue );
80005460:	f0 1f 00 1e 	mcall	800054d8 <xQueueGenericReceive+0x114>
80005464:	6f 18       	ld.w	r8,r7[0x44]
80005466:	5b f8       	cp.w	r8,-1
80005468:	ef f1 0a 11 	st.weq	r7[0x44],r1
8000546c:	6f 28       	ld.w	r8,r7[0x48]
8000546e:	5b f8       	cp.w	r8,-1
80005470:	ef f1 0a 12 	st.weq	r7[0x48],r1
80005474:	f0 1f 00 1d 	mcall	800054e8 <xQueueGenericReceive+0x124>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80005478:	06 9b       	mov	r11,r3
8000547a:	08 9c       	mov	r12,r4
8000547c:	f0 1f 00 1e 	mcall	800054f4 <xQueueGenericReceive+0x130>
80005480:	c2 41       	brne	800054c8 <xQueueGenericReceive+0x104>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
80005482:	f0 1f 00 16 	mcall	800054d8 <xQueueGenericReceive+0x114>
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
80005486:	6e e6       	ld.w	r6,r7[0x38]
	taskEXIT_CRITICAL();
80005488:	f0 1f 00 18 	mcall	800054e8 <xQueueGenericReceive+0x124>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) )
8000548c:	58 06       	cp.w	r6,0
8000548e:	c1 71       	brne	800054bc <xQueueGenericReceive+0xf8>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80005490:	6e 08       	ld.w	r8,r7[0x0]
80005492:	58 08       	cp.w	r8,0
80005494:	c0 81       	brne	800054a4 <xQueueGenericReceive+0xe0>
					{
						portENTER_CRITICAL();
80005496:	f0 1f 00 11 	mcall	800054d8 <xQueueGenericReceive+0x114>
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
8000549a:	6e 1c       	ld.w	r12,r7[0x4]
8000549c:	f0 1f 00 17 	mcall	800054f8 <xQueueGenericReceive+0x134>
						}
						portEXIT_CRITICAL();
800054a0:	f0 1f 00 12 	mcall	800054e8 <xQueueGenericReceive+0x124>
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
800054a4:	40 2b       	lddsp	r11,sp[0x8]
800054a6:	04 9c       	mov	r12,r2
800054a8:	f0 1f 00 15 	mcall	800054fc <xQueueGenericReceive+0x138>
				prvUnlockQueue( pxQueue );
800054ac:	0e 9c       	mov	r12,r7
800054ae:	f0 1f 00 15 	mcall	80005500 <xQueueGenericReceive+0x13c>
				if( !xTaskResumeAll() )
800054b2:	f0 1f 00 15 	mcall	80005504 <xQueueGenericReceive+0x140>
800054b6:	c9 61       	brne	800053e2 <xQueueGenericReceive+0x1e>
				{
					portYIELD_WITHIN_API();
800054b8:	d7 33       	scall
800054ba:	c9 4b       	rjmp	800053e2 <xQueueGenericReceive+0x1e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
800054bc:	0e 9c       	mov	r12,r7
800054be:	f0 1f 00 11 	mcall	80005500 <xQueueGenericReceive+0x13c>
				( void ) xTaskResumeAll();
800054c2:	f0 1f 00 11 	mcall	80005504 <xQueueGenericReceive+0x140>
800054c6:	c8 eb       	rjmp	800053e2 <xQueueGenericReceive+0x1e>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
800054c8:	0e 9c       	mov	r12,r7
800054ca:	f0 1f 00 0e 	mcall	80005500 <xQueueGenericReceive+0x13c>
			( void ) xTaskResumeAll();
800054ce:	f0 1f 00 0e 	mcall	80005504 <xQueueGenericReceive+0x140>
800054d2:	30 0c       	mov	r12,0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
800054d4:	2f bd       	sub	sp,-20
800054d6:	d8 32       	popm	r0-r7,pc
800054d8:	80 00       	ld.sh	r0,r0[0x0]
800054da:	50 10       	stdsp	sp[0x4],r0
800054dc:	80 00       	ld.sh	r0,r0[0x0]
800054de:	52 a4       	stdsp	sp[0xa8],r4
800054e0:	80 00       	ld.sh	r0,r0[0x0]
800054e2:	57 f4       	stdsp	sp[0x1fc],r4
800054e4:	80 00       	ld.sh	r0,r0[0x0]
800054e6:	58 dc       	cp.w	r12,13
800054e8:	80 00       	ld.sh	r0,r0[0x0]
800054ea:	51 1c       	stdsp	sp[0x44],r12
800054ec:	80 00       	ld.sh	r0,r0[0x0]
800054ee:	57 d0       	stdsp	sp[0x1f4],r0
800054f0:	80 00       	ld.sh	r0,r0[0x0]
800054f2:	57 44       	stdsp	sp[0x1d0],r4
800054f4:	80 00       	ld.sh	r0,r0[0x0]
800054f6:	5a 6c       	cp.w	r12,-26
800054f8:	80 00       	ld.sh	r0,r0[0x0]
800054fa:	58 58       	cp.w	r8,5
800054fc:	80 00       	ld.sh	r0,r0[0x0]
800054fe:	5c c4       	swap.bh	r4
80005500:	80 00       	ld.sh	r0,r0[0x0]
80005502:	53 24       	stdsp	sp[0xc8],r4
80005504:	80 00       	ld.sh	r0,r0[0x0]
80005506:	5b 00       	cp.w	r0,-16

80005508 <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
80005508:	eb cd 40 80 	pushm	r7,lr
8000550c:	18 97       	mov	r7,r12
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
8000550e:	79 08       	ld.w	r8,r12[0x40]
80005510:	58 08       	cp.w	r8,0
80005512:	c0 a1       	brne	80005526 <prvCopyDataToQueue+0x1e>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80005514:	78 08       	ld.w	r8,r12[0x0]
80005516:	58 08       	cp.w	r8,0
80005518:	c2 b1       	brne	8000556e <prvCopyDataToQueue+0x66>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
8000551a:	78 1c       	ld.w	r12,r12[0x4]
8000551c:	f0 1f 00 17 	mcall	80005578 <prvCopyDataToQueue+0x70>
				pxQueue->pxMutexHolder = NULL;
80005520:	30 08       	mov	r8,0
80005522:	8f 18       	st.w	r7[0x4],r8
80005524:	c2 58       	rjmp	8000556e <prvCopyDataToQueue+0x66>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
80005526:	58 0a       	cp.w	r10,0
80005528:	c1 01       	brne	80005548 <prvCopyDataToQueue+0x40>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
8000552a:	10 9a       	mov	r10,r8
8000552c:	78 2c       	ld.w	r12,r12[0x8]
8000552e:	f0 1f 00 14 	mcall	8000557c <prvCopyDataToQueue+0x74>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
80005532:	6e 29       	ld.w	r9,r7[0x8]
80005534:	6f 08       	ld.w	r8,r7[0x40]
80005536:	f2 08 00 08 	add	r8,r9,r8
8000553a:	8f 28       	st.w	r7[0x8],r8
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
8000553c:	6e 19       	ld.w	r9,r7[0x4]
8000553e:	12 38       	cp.w	r8,r9
80005540:	c1 73       	brcs	8000556e <prvCopyDataToQueue+0x66>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
80005542:	6e 08       	ld.w	r8,r7[0x0]
80005544:	8f 28       	st.w	r7[0x8],r8
80005546:	c1 48       	rjmp	8000556e <prvCopyDataToQueue+0x66>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80005548:	10 9a       	mov	r10,r8
8000554a:	78 3c       	ld.w	r12,r12[0xc]
8000554c:	f0 1f 00 0c 	mcall	8000557c <prvCopyDataToQueue+0x74>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
80005550:	6f 08       	ld.w	r8,r7[0x40]
80005552:	6e 39       	ld.w	r9,r7[0xc]
80005554:	f2 08 01 08 	sub	r8,r9,r8
80005558:	8f 38       	st.w	r7[0xc],r8
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
8000555a:	6e 09       	ld.w	r9,r7[0x0]
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
8000555c:	12 38       	cp.w	r8,r9
8000555e:	ef f8 30 10 	ld.wcs	r8,r7[0x40]
80005562:	ef f9 30 01 	ld.wcs	r9,r7[0x4]
80005566:	f3 d8 e3 19 	subcs	r9,r9,r8
8000556a:	ef f9 3a 03 	st.wcs	r7[0xc],r9
		}
	}

	++( pxQueue->uxMessagesWaiting );
8000556e:	6e e8       	ld.w	r8,r7[0x38]
80005570:	2f f8       	sub	r8,-1
80005572:	8f e8       	st.w	r7[0x38],r8
}
80005574:	e3 cd 80 80 	ldm	sp++,r7,pc
80005578:	80 00       	ld.sh	r0,r0[0x0]
8000557a:	58 00       	cp.w	r0,0
8000557c:	80 00       	ld.sh	r0,r0[0x0]
8000557e:	69 f4       	ld.w	r4,r4[0x7c]

80005580 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
80005580:	eb cd 40 c0 	pushm	r6-r7,lr
80005584:	18 97       	mov	r7,r12
80005586:	14 96       	mov	r6,r10
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
80005588:	78 ec       	ld.w	r12,r12[0x38]
8000558a:	6e f8       	ld.w	r8,r7[0x3c]
8000558c:	10 3c       	cp.w	r12,r8
8000558e:	c0 33       	brcs	80005594 <xQueueGenericSendFromISR+0x14>
80005590:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80005594:	12 9a       	mov	r10,r9
80005596:	0e 9c       	mov	r12,r7
80005598:	f0 1f 00 0c 	mcall	800055c8 <xQueueGenericSendFromISR+0x48>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
8000559c:	6f 28       	ld.w	r8,r7[0x48]
8000559e:	5b f8       	cp.w	r8,-1
800055a0:	c0 d1       	brne	800055ba <xQueueGenericSendFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
800055a2:	6e 98       	ld.w	r8,r7[0x24]
800055a4:	58 08       	cp.w	r8,0
800055a6:	c0 f0       	breq	800055c4 <xQueueGenericSendFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
800055a8:	ee cc ff dc 	sub	r12,r7,-36
800055ac:	f0 1f 00 08 	mcall	800055cc <xQueueGenericSendFromISR+0x4c>
800055b0:	c0 a0       	breq	800055c4 <xQueueGenericSendFromISR+0x44>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
800055b2:	30 1c       	mov	r12,1
800055b4:	8d 0c       	st.w	r6[0x0],r12
800055b6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
800055ba:	2f f8       	sub	r8,-1
800055bc:	ef 48 00 48 	st.w	r7[72],r8
800055c0:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
800055c4:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
800055c8:	80 00       	ld.sh	r0,r0[0x0]
800055ca:	55 08       	stdsp	sp[0x140],r8
800055cc:	80 00       	ld.sh	r0,r0[0x0]
800055ce:	58 dc       	cp.w	r12,13

800055d0 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
800055d0:	d4 31       	pushm	r0-r7,lr
800055d2:	20 5d       	sub	sp,20
800055d4:	18 97       	mov	r7,r12
800055d6:	50 0b       	stdsp	sp[0x0],r11
800055d8:	50 2a       	stdsp	sp[0x8],r10
800055da:	50 19       	stdsp	sp[0x4],r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
800055dc:	f8 c0 ff f0 	sub	r0,r12,-16
800055e0:	30 04       	mov	r4,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
800055e2:	fa c3 ff f4 	sub	r3,sp,-12

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
800055e6:	08 91       	mov	r1,r4

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
800055e8:	fa c2 ff f8 	sub	r2,sp,-8
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
800055ec:	f0 1f 00 2f 	mcall	800056a8 <xQueueGenericSend+0xd8>
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
800055f0:	6e e9       	ld.w	r9,r7[0x38]
800055f2:	6e f8       	ld.w	r8,r7[0x3c]
800055f4:	10 39       	cp.w	r9,r8
800055f6:	c1 42       	brcc	8000561e <xQueueGenericSend+0x4e>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
800055f8:	40 1a       	lddsp	r10,sp[0x4]
800055fa:	40 0b       	lddsp	r11,sp[0x0]
800055fc:	0e 9c       	mov	r12,r7
800055fe:	f0 1f 00 2c 	mcall	800056ac <xQueueGenericSend+0xdc>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005602:	6e 98       	ld.w	r8,r7[0x24]
80005604:	58 08       	cp.w	r8,0
80005606:	c0 80       	breq	80005616 <xQueueGenericSend+0x46>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
80005608:	ee cc ff dc 	sub	r12,r7,-36
8000560c:	f0 1f 00 29 	mcall	800056b0 <xQueueGenericSend+0xe0>
80005610:	58 1c       	cp.w	r12,1
80005612:	c0 21       	brne	80005616 <xQueueGenericSend+0x46>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
80005614:	d7 33       	scall
					}
				}

				taskEXIT_CRITICAL();
80005616:	f0 1f 00 28 	mcall	800056b4 <xQueueGenericSend+0xe4>
8000561a:	30 1c       	mov	r12,1

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
8000561c:	c4 38       	rjmp	800056a2 <xQueueGenericSend+0xd2>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
8000561e:	40 28       	lddsp	r8,sp[0x8]
80005620:	58 08       	cp.w	r8,0
80005622:	c0 51       	brne	8000562c <xQueueGenericSend+0x5c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80005624:	f0 1f 00 24 	mcall	800056b4 <xQueueGenericSend+0xe4>
80005628:	30 0c       	mov	r12,0

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
8000562a:	c3 c8       	rjmp	800056a2 <xQueueGenericSend+0xd2>
				}
				else if( xEntryTimeSet == pdFALSE )
8000562c:	58 04       	cp.w	r4,0
8000562e:	c0 51       	brne	80005638 <xQueueGenericSend+0x68>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80005630:	06 9c       	mov	r12,r3
80005632:	f0 1f 00 22 	mcall	800056b8 <xQueueGenericSend+0xe8>
80005636:	30 14       	mov	r4,1
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80005638:	f0 1f 00 1f 	mcall	800056b4 <xQueueGenericSend+0xe4>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
8000563c:	f0 1f 00 20 	mcall	800056bc <xQueueGenericSend+0xec>
		prvLockQueue( pxQueue );
80005640:	f0 1f 00 1a 	mcall	800056a8 <xQueueGenericSend+0xd8>
80005644:	6f 18       	ld.w	r8,r7[0x44]
80005646:	5b f8       	cp.w	r8,-1
80005648:	ef f1 0a 11 	st.weq	r7[0x44],r1
8000564c:	6f 28       	ld.w	r8,r7[0x48]
8000564e:	5b f8       	cp.w	r8,-1
80005650:	ef f1 0a 12 	st.weq	r7[0x48],r1
80005654:	f0 1f 00 18 	mcall	800056b4 <xQueueGenericSend+0xe4>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80005658:	04 9b       	mov	r11,r2
8000565a:	06 9c       	mov	r12,r3
8000565c:	f0 1f 00 19 	mcall	800056c0 <xQueueGenericSend+0xf0>
80005660:	c1 b1       	brne	80005696 <xQueueGenericSend+0xc6>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
80005662:	f0 1f 00 12 	mcall	800056a8 <xQueueGenericSend+0xd8>
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
80005666:	6e e5       	ld.w	r5,r7[0x38]
80005668:	6e f6       	ld.w	r6,r7[0x3c]
	taskEXIT_CRITICAL();
8000566a:	f0 1f 00 13 	mcall	800056b4 <xQueueGenericSend+0xe4>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
8000566e:	0c 35       	cp.w	r5,r6
80005670:	c0 d1       	brne	8000568a <xQueueGenericSend+0xba>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
80005672:	40 2b       	lddsp	r11,sp[0x8]
80005674:	00 9c       	mov	r12,r0
80005676:	f0 1f 00 14 	mcall	800056c4 <xQueueGenericSend+0xf4>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
8000567a:	0e 9c       	mov	r12,r7
8000567c:	f0 1f 00 13 	mcall	800056c8 <xQueueGenericSend+0xf8>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
80005680:	f0 1f 00 13 	mcall	800056cc <xQueueGenericSend+0xfc>
80005684:	cb 41       	brne	800055ec <xQueueGenericSend+0x1c>
				{
					portYIELD_WITHIN_API();
80005686:	d7 33       	scall
80005688:	cb 2b       	rjmp	800055ec <xQueueGenericSend+0x1c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
8000568a:	0e 9c       	mov	r12,r7
8000568c:	f0 1f 00 0f 	mcall	800056c8 <xQueueGenericSend+0xf8>
				( void ) xTaskResumeAll();
80005690:	f0 1f 00 0f 	mcall	800056cc <xQueueGenericSend+0xfc>
80005694:	ca cb       	rjmp	800055ec <xQueueGenericSend+0x1c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
80005696:	0e 9c       	mov	r12,r7
80005698:	f0 1f 00 0c 	mcall	800056c8 <xQueueGenericSend+0xf8>
			( void ) xTaskResumeAll();
8000569c:	f0 1f 00 0c 	mcall	800056cc <xQueueGenericSend+0xfc>
800056a0:	30 0c       	mov	r12,0
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
800056a2:	2f bd       	sub	sp,-20
800056a4:	d8 32       	popm	r0-r7,pc
800056a6:	00 00       	add	r0,r0
800056a8:	80 00       	ld.sh	r0,r0[0x0]
800056aa:	50 10       	stdsp	sp[0x4],r0
800056ac:	80 00       	ld.sh	r0,r0[0x0]
800056ae:	55 08       	stdsp	sp[0x140],r8
800056b0:	80 00       	ld.sh	r0,r0[0x0]
800056b2:	58 dc       	cp.w	r12,13
800056b4:	80 00       	ld.sh	r0,r0[0x0]
800056b6:	51 1c       	stdsp	sp[0x44],r12
800056b8:	80 00       	ld.sh	r0,r0[0x0]
800056ba:	57 d0       	stdsp	sp[0x1f4],r0
800056bc:	80 00       	ld.sh	r0,r0[0x0]
800056be:	57 44       	stdsp	sp[0x1d0],r4
800056c0:	80 00       	ld.sh	r0,r0[0x0]
800056c2:	5a 6c       	cp.w	r12,-26
800056c4:	80 00       	ld.sh	r0,r0[0x0]
800056c6:	5c c4       	swap.bh	r4
800056c8:	80 00       	ld.sh	r0,r0[0x0]
800056ca:	53 24       	stdsp	sp[0xc8],r4
800056cc:	80 00       	ld.sh	r0,r0[0x0]
800056ce:	5b 00       	cp.w	r0,-16

800056d0 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
800056d0:	d4 21       	pushm	r4-r7,lr
800056d2:	18 97       	mov	r7,r12
800056d4:	16 96       	mov	r6,r11
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
800056d6:	58 0c       	cp.w	r12,0
800056d8:	c2 f0       	breq	80005736 <xQueueCreate+0x66>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
800056da:	34 cc       	mov	r12,76
800056dc:	f0 1f 00 17 	mcall	80005738 <xQueueCreate+0x68>
800056e0:	18 95       	mov	r5,r12
		if( pxNewQueue != NULL )
800056e2:	c2 a0       	breq	80005736 <xQueueCreate+0x66>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
800056e4:	ec 07 02 44 	mul	r4,r6,r7

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
800056e8:	e8 cc ff ff 	sub	r12,r4,-1
800056ec:	f0 1f 00 13 	mcall	80005738 <xQueueCreate+0x68>
800056f0:	8b 0c       	st.w	r5[0x0],r12
			if( pxNewQueue->pcHead != NULL )
800056f2:	c1 e0       	breq	8000572e <xQueueCreate+0x5e>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
800056f4:	f8 04 00 04 	add	r4,r12,r4
800056f8:	8b 14       	st.w	r5[0x4],r4
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
800056fa:	30 08       	mov	r8,0
800056fc:	8b e8       	st.w	r5[0x38],r8
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
800056fe:	8b 2c       	st.w	r5[0x8],r12
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
80005700:	ee c8 00 01 	sub	r8,r7,1
80005704:	ad 38       	mul	r8,r6
80005706:	10 0c       	add	r12,r8
80005708:	8b 3c       	st.w	r5[0xc],r12
				pxNewQueue->uxLength = uxQueueLength;
8000570a:	8b f7       	st.w	r5[0x3c],r7
				pxNewQueue->uxItemSize = uxItemSize;
8000570c:	eb 46 00 40 	st.w	r5[64],r6
				pxNewQueue->xRxLock = queueUNLOCKED;
80005710:	3f f8       	mov	r8,-1
80005712:	eb 48 00 44 	st.w	r5[68],r8
				pxNewQueue->xTxLock = queueUNLOCKED;
80005716:	eb 48 00 48 	st.w	r5[72],r8

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
8000571a:	ea cc ff f0 	sub	r12,r5,-16
8000571e:	f0 1f 00 08 	mcall	8000573c <xQueueCreate+0x6c>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
80005722:	ea cc ff dc 	sub	r12,r5,-36
80005726:	f0 1f 00 06 	mcall	8000573c <xQueueCreate+0x6c>
8000572a:	0a 9c       	mov	r12,r5
8000572c:	d8 22       	popm	r4-r7,pc
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
8000572e:	0a 9c       	mov	r12,r5
80005730:	f0 1f 00 04 	mcall	80005740 <xQueueCreate+0x70>
80005734:	d8 2a       	popm	r4-r7,pc,r12=0
80005736:	d8 2a       	popm	r4-r7,pc,r12=0
80005738:	80 00       	ld.sh	r0,r0[0x0]
8000573a:	52 7c       	stdsp	sp[0x9c],r12
8000573c:	80 00       	ld.sh	r0,r0[0x0]
8000573e:	4e ec       	lddpc	r12,800058f4 <xTaskRemoveFromEventList+0x18>
80005740:	80 00       	ld.sh	r0,r0[0x0]
80005742:	52 54       	stdsp	sp[0x94],r4

80005744 <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
80005744:	48 38       	lddpc	r8,80005750 <vTaskSuspendAll+0xc>
80005746:	70 09       	ld.w	r9,r8[0x0]
80005748:	2f f9       	sub	r9,-1
8000574a:	91 09       	st.w	r8[0x0],r9
}
8000574c:	5e fc       	retal	r12
8000574e:	00 00       	add	r0,r0
80005750:	00 00       	add	r0,r0
80005752:	0d 14       	ld.sh	r4,r6++

80005754 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
80005754:	49 a8       	lddpc	r8,800057bc <vTaskSwitchContext+0x68>
80005756:	70 08       	ld.w	r8,r8[0x0]
80005758:	58 08       	cp.w	r8,0
8000575a:	c0 b1       	brne	80005770 <vTaskSwitchContext+0x1c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
8000575c:	49 98       	lddpc	r8,800057c0 <vTaskSwitchContext+0x6c>
8000575e:	70 08       	ld.w	r8,r8[0x0]
80005760:	f0 08 00 28 	add	r8,r8,r8<<0x2
80005764:	49 89       	lddpc	r9,800057c4 <vTaskSwitchContext+0x70>
80005766:	f2 08 03 28 	ld.w	r8,r9[r8<<0x2]
8000576a:	58 08       	cp.w	r8,0
8000576c:	c0 60       	breq	80005778 <vTaskSwitchContext+0x24>
8000576e:	c1 18       	rjmp	80005790 <vTaskSwitchContext+0x3c>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
80005770:	30 19       	mov	r9,1
80005772:	49 68       	lddpc	r8,800057c8 <vTaskSwitchContext+0x74>
80005774:	91 09       	st.w	r8[0x0],r9
80005776:	5e fc       	retal	r12

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
80005778:	49 28       	lddpc	r8,800057c0 <vTaskSwitchContext+0x6c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
8000577a:	49 3a       	lddpc	r10,800057c4 <vTaskSwitchContext+0x70>
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
8000577c:	70 09       	ld.w	r9,r8[0x0]
8000577e:	20 19       	sub	r9,1
80005780:	91 09       	st.w	r8[0x0],r9

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80005782:	70 09       	ld.w	r9,r8[0x0]
80005784:	f2 09 00 29 	add	r9,r9,r9<<0x2
80005788:	f4 09 03 29 	ld.w	r9,r10[r9<<0x2]
8000578c:	58 09       	cp.w	r9,0
8000578e:	cf 70       	breq	8000577c <vTaskSwitchContext+0x28>
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
80005790:	48 c8       	lddpc	r8,800057c0 <vTaskSwitchContext+0x6c>
80005792:	70 08       	ld.w	r8,r8[0x0]
80005794:	f0 08 00 28 	add	r8,r8,r8<<0x2
80005798:	48 b9       	lddpc	r9,800057c4 <vTaskSwitchContext+0x70>
8000579a:	f2 08 00 28 	add	r8,r9,r8<<0x2
8000579e:	70 19       	ld.w	r9,r8[0x4]
800057a0:	72 19       	ld.w	r9,r9[0x4]
800057a2:	91 19       	st.w	r8[0x4],r9
800057a4:	f0 ca ff f8 	sub	r10,r8,-8
800057a8:	14 39       	cp.w	r9,r10
800057aa:	f3 f9 00 01 	ld.weq	r9,r9[0x4]
800057ae:	f1 f9 0a 01 	st.weq	r8[0x4],r9
800057b2:	70 18       	ld.w	r8,r8[0x4]
800057b4:	70 39       	ld.w	r9,r8[0xc]
800057b6:	48 68       	lddpc	r8,800057cc <vTaskSwitchContext+0x78>
800057b8:	91 09       	st.w	r8[0x0],r9
800057ba:	5e fc       	retal	r12
800057bc:	00 00       	add	r0,r0
800057be:	0d 14       	ld.sh	r4,r6++
800057c0:	00 00       	add	r0,r0
800057c2:	0d 4c       	ld.w	r12,--r6
800057c4:	00 00       	add	r0,r0
800057c6:	0c 30       	cp.w	r0,r6
800057c8:	00 00       	add	r0,r0
800057ca:	0d 34       	ld.ub	r4,r6++
800057cc:	00 00       	add	r0,r0
800057ce:	0c e4       	st.h	--r6,r4

800057d0 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
800057d0:	48 48       	lddpc	r8,800057e0 <vTaskSetTimeOutState+0x10>
800057d2:	70 08       	ld.w	r8,r8[0x0]
800057d4:	99 08       	st.w	r12[0x0],r8
	pxTimeOut->xTimeOnEntering = xTickCount;
800057d6:	48 48       	lddpc	r8,800057e4 <vTaskSetTimeOutState+0x14>
800057d8:	70 08       	ld.w	r8,r8[0x0]
800057da:	99 18       	st.w	r12[0x4],r8
}
800057dc:	5e fc       	retal	r12
800057de:	00 00       	add	r0,r0
800057e0:	00 00       	add	r0,r0
800057e2:	0c 28       	rsub	r8,r6
800057e4:	00 00       	add	r0,r0
800057e6:	0d 10       	ld.sh	r0,r6++

800057e8 <vTaskMissedYield>:
}
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
800057e8:	30 19       	mov	r9,1
800057ea:	48 28       	lddpc	r8,800057f0 <vTaskMissedYield+0x8>
800057ec:	91 09       	st.w	r8[0x0],r9
}
800057ee:	5e fc       	retal	r12
800057f0:	00 00       	add	r0,r0
800057f2:	0d 34       	ld.ub	r4,r6++

800057f4 <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
800057f4:	48 28       	lddpc	r8,800057fc <xTaskGetCurrentTaskHandle+0x8>
800057f6:	70 0c       	ld.w	r12,r8[0x0]

		return xReturn;
	}
800057f8:	5e fc       	retal	r12
800057fa:	00 00       	add	r0,r0
800057fc:	00 00       	add	r0,r0
800057fe:	0c e4       	st.h	--r6,r4

80005800 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
80005800:	eb cd 40 c0 	pushm	r6-r7,lr
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
80005804:	58 0c       	cp.w	r12,0
80005806:	c1 f0       	breq	80005844 <vTaskPriorityDisinherit+0x44>

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
80005808:	18 97       	mov	r7,r12

		if( pxMutexHolder != NULL )
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
8000580a:	78 b9       	ld.w	r9,r12[0x2c]
8000580c:	79 18       	ld.w	r8,r12[0x44]
8000580e:	10 39       	cp.w	r9,r8
80005810:	c1 a0       	breq	80005844 <vTaskPriorityDisinherit+0x44>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
80005812:	f8 c6 ff fc 	sub	r6,r12,-4
80005816:	0c 9c       	mov	r12,r6
80005818:	f0 1f 00 0c 	mcall	80005848 <vTaskPriorityDisinherit+0x48>

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
8000581c:	6f 1c       	ld.w	r12,r7[0x44]
8000581e:	8f bc       	st.w	r7[0x2c],r12
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
80005820:	f8 08 11 08 	rsub	r8,r12,8
80005824:	8f 68       	st.w	r7[0x18],r8
				prvAddTaskToReadyQueue( pxTCB );
80005826:	48 a8       	lddpc	r8,8000584c <vTaskPriorityDisinherit+0x4c>
80005828:	70 08       	ld.w	r8,r8[0x0]
8000582a:	10 3c       	cp.w	r12,r8
8000582c:	e0 88 00 04 	brls	80005834 <vTaskPriorityDisinherit+0x34>
80005830:	48 78       	lddpc	r8,8000584c <vTaskPriorityDisinherit+0x4c>
80005832:	91 0c       	st.w	r8[0x0],r12
80005834:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80005838:	0c 9b       	mov	r11,r6
8000583a:	48 68       	lddpc	r8,80005850 <vTaskPriorityDisinherit+0x50>
8000583c:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80005840:	f0 1f 00 05 	mcall	80005854 <vTaskPriorityDisinherit+0x54>
80005844:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005848:	80 00       	ld.sh	r0,r0[0x0]
8000584a:	4f 56       	lddpc	r6,80005a1c <vTaskIncrementTick+0xc4>
8000584c:	00 00       	add	r0,r0
8000584e:	0d 4c       	ld.w	r12,--r6
80005850:	00 00       	add	r0,r0
80005852:	0c 30       	cp.w	r0,r6
80005854:	80 00       	ld.sh	r0,r0[0x0]
80005856:	4f 06       	lddpc	r6,80005a14 <vTaskIncrementTick+0xbc>

80005858 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
80005858:	eb cd 40 c0 	pushm	r6-r7,lr
8000585c:	18 97       	mov	r7,r12
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
8000585e:	49 b8       	lddpc	r8,800058c8 <vTaskPriorityInherit+0x70>
80005860:	70 08       	ld.w	r8,r8[0x0]
80005862:	78 b9       	ld.w	r9,r12[0x2c]
80005864:	70 b8       	ld.w	r8,r8[0x2c]
80005866:	10 39       	cp.w	r9,r8
80005868:	c2 d2       	brcc	800058c2 <vTaskPriorityInherit+0x6a>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
8000586a:	49 88       	lddpc	r8,800058c8 <vTaskPriorityInherit+0x70>
8000586c:	70 08       	ld.w	r8,r8[0x0]
8000586e:	70 b8       	ld.w	r8,r8[0x2c]
80005870:	f0 08 11 08 	rsub	r8,r8,8
80005874:	99 68       	st.w	r12[0x18],r8

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
80005876:	f2 09 00 28 	add	r8,r9,r9<<0x2
8000587a:	49 59       	lddpc	r9,800058cc <vTaskPriorityInherit+0x74>
8000587c:	f2 08 00 28 	add	r8,r9,r8<<0x2
80005880:	78 59       	ld.w	r9,r12[0x14]
80005882:	10 39       	cp.w	r9,r8
80005884:	c1 b1       	brne	800058ba <vTaskPriorityInherit+0x62>
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
80005886:	f8 c6 ff fc 	sub	r6,r12,-4
8000588a:	0c 9c       	mov	r12,r6
8000588c:	f0 1f 00 11 	mcall	800058d0 <vTaskPriorityInherit+0x78>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
80005890:	48 e8       	lddpc	r8,800058c8 <vTaskPriorityInherit+0x70>
80005892:	70 08       	ld.w	r8,r8[0x0]
80005894:	70 bc       	ld.w	r12,r8[0x2c]
80005896:	8f bc       	st.w	r7[0x2c],r12
				prvAddTaskToReadyQueue( pxTCB );
80005898:	48 f8       	lddpc	r8,800058d4 <vTaskPriorityInherit+0x7c>
8000589a:	70 08       	ld.w	r8,r8[0x0]
8000589c:	10 3c       	cp.w	r12,r8
8000589e:	e0 88 00 04 	brls	800058a6 <vTaskPriorityInherit+0x4e>
800058a2:	48 d8       	lddpc	r8,800058d4 <vTaskPriorityInherit+0x7c>
800058a4:	91 0c       	st.w	r8[0x0],r12
800058a6:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800058aa:	0c 9b       	mov	r11,r6
800058ac:	48 88       	lddpc	r8,800058cc <vTaskPriorityInherit+0x74>
800058ae:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800058b2:	f0 1f 00 0a 	mcall	800058d8 <vTaskPriorityInherit+0x80>
800058b6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
800058ba:	48 48       	lddpc	r8,800058c8 <vTaskPriorityInherit+0x70>
800058bc:	70 08       	ld.w	r8,r8[0x0]
800058be:	70 b8       	ld.w	r8,r8[0x2c]
800058c0:	99 b8       	st.w	r12[0x2c],r8
800058c2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800058c6:	00 00       	add	r0,r0
800058c8:	00 00       	add	r0,r0
800058ca:	0c e4       	st.h	--r6,r4
800058cc:	00 00       	add	r0,r0
800058ce:	0c 30       	cp.w	r0,r6
800058d0:	80 00       	ld.sh	r0,r0[0x0]
800058d2:	4f 56       	lddpc	r6,80005aa4 <xTaskCheckForTimeOut+0x38>
800058d4:	00 00       	add	r0,r0
800058d6:	0d 4c       	ld.w	r12,--r6
800058d8:	80 00       	ld.sh	r0,r0[0x0]
800058da:	4f 06       	lddpc	r6,80005a98 <xTaskCheckForTimeOut+0x2c>

800058dc <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
800058dc:	eb cd 40 c0 	pushm	r6-r7,lr
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
800058e0:	78 38       	ld.w	r8,r12[0xc]
800058e2:	70 37       	ld.w	r7,r8[0xc]
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
800058e4:	ee c6 ff e8 	sub	r6,r7,-24
800058e8:	0c 9c       	mov	r12,r6
800058ea:	f0 1f 00 15 	mcall	8000593c <xTaskRemoveFromEventList+0x60>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
800058ee:	49 58       	lddpc	r8,80005940 <xTaskRemoveFromEventList+0x64>
800058f0:	70 08       	ld.w	r8,r8[0x0]
800058f2:	58 08       	cp.w	r8,0
800058f4:	c1 71       	brne	80005922 <xTaskRemoveFromEventList+0x46>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
800058f6:	ee c6 ff fc 	sub	r6,r7,-4
800058fa:	0c 9c       	mov	r12,r6
800058fc:	f0 1f 00 10 	mcall	8000593c <xTaskRemoveFromEventList+0x60>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
80005900:	6e bc       	ld.w	r12,r7[0x2c]
80005902:	49 18       	lddpc	r8,80005944 <xTaskRemoveFromEventList+0x68>
80005904:	70 08       	ld.w	r8,r8[0x0]
80005906:	10 3c       	cp.w	r12,r8
80005908:	e0 88 00 04 	brls	80005910 <xTaskRemoveFromEventList+0x34>
8000590c:	48 e8       	lddpc	r8,80005944 <xTaskRemoveFromEventList+0x68>
8000590e:	91 0c       	st.w	r8[0x0],r12
80005910:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80005914:	0c 9b       	mov	r11,r6
80005916:	48 d8       	lddpc	r8,80005948 <xTaskRemoveFromEventList+0x6c>
80005918:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
8000591c:	f0 1f 00 0c 	mcall	8000594c <xTaskRemoveFromEventList+0x70>
80005920:	c0 58       	rjmp	8000592a <xTaskRemoveFromEventList+0x4e>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
80005922:	0c 9b       	mov	r11,r6
80005924:	48 bc       	lddpc	r12,80005950 <xTaskRemoveFromEventList+0x74>
80005926:	f0 1f 00 0a 	mcall	8000594c <xTaskRemoveFromEventList+0x70>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
8000592a:	48 b8       	lddpc	r8,80005954 <xTaskRemoveFromEventList+0x78>
8000592c:	70 08       	ld.w	r8,r8[0x0]
8000592e:	6e b9       	ld.w	r9,r7[0x2c]
80005930:	70 b8       	ld.w	r8,r8[0x2c]
80005932:	10 39       	cp.w	r9,r8
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
80005934:	5f 2c       	srhs	r12
80005936:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000593a:	00 00       	add	r0,r0
8000593c:	80 00       	ld.sh	r0,r0[0x0]
8000593e:	4f 56       	lddpc	r6,80005b10 <xTaskResumeAll+0x10>
80005940:	00 00       	add	r0,r0
80005942:	0d 14       	ld.sh	r4,r6++
80005944:	00 00       	add	r0,r0
80005946:	0d 4c       	ld.w	r12,--r6
80005948:	00 00       	add	r0,r0
8000594a:	0c 30       	cp.w	r0,r6
8000594c:	80 00       	ld.sh	r0,r0[0x0]
8000594e:	4f 06       	lddpc	r6,80005b0c <xTaskResumeAll+0xc>
80005950:	00 00       	add	r0,r0
80005952:	0c e8       	st.h	--r6,r8
80005954:	00 00       	add	r0,r0
80005956:	0c e4       	st.h	--r6,r4

80005958 <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
80005958:	eb cd 40 fc 	pushm	r2-r7,lr
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
8000595c:	4b 98       	lddpc	r8,80005a40 <vTaskIncrementTick+0xe8>
8000595e:	70 08       	ld.w	r8,r8[0x0]
80005960:	58 08       	cp.w	r8,0
80005962:	c6 91       	brne	80005a34 <vTaskIncrementTick+0xdc>
	{
		++xTickCount;
80005964:	4b 88       	lddpc	r8,80005a44 <vTaskIncrementTick+0xec>
80005966:	70 09       	ld.w	r9,r8[0x0]
80005968:	2f f9       	sub	r9,-1
8000596a:	91 09       	st.w	r8[0x0],r9
		if( xTickCount == ( portTickType ) 0 )
8000596c:	70 08       	ld.w	r8,r8[0x0]
8000596e:	58 08       	cp.w	r8,0
80005970:	c1 a1       	brne	800059a4 <vTaskIncrementTick+0x4c>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
80005972:	4b 68       	lddpc	r8,80005a48 <vTaskIncrementTick+0xf0>
80005974:	70 0a       	ld.w	r10,r8[0x0]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
80005976:	4b 69       	lddpc	r9,80005a4c <vTaskIncrementTick+0xf4>
80005978:	72 0b       	ld.w	r11,r9[0x0]
8000597a:	91 0b       	st.w	r8[0x0],r11
			pxOverflowDelayedTaskList = pxTemp;
8000597c:	93 0a       	st.w	r9[0x0],r10
			xNumOfOverflows++;
8000597e:	4b 59       	lddpc	r9,80005a50 <vTaskIncrementTick+0xf8>
80005980:	72 0a       	ld.w	r10,r9[0x0]
80005982:	2f fa       	sub	r10,-1
80005984:	93 0a       	st.w	r9[0x0],r10

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
80005986:	70 08       	ld.w	r8,r8[0x0]
80005988:	70 08       	ld.w	r8,r8[0x0]
8000598a:	58 08       	cp.w	r8,0
8000598c:	c0 51       	brne	80005996 <vTaskIncrementTick+0x3e>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
8000598e:	3f f9       	mov	r9,-1
80005990:	4b 18       	lddpc	r8,80005a54 <vTaskIncrementTick+0xfc>
80005992:	91 09       	st.w	r8[0x0],r9
80005994:	c0 88       	rjmp	800059a4 <vTaskIncrementTick+0x4c>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
80005996:	4a d8       	lddpc	r8,80005a48 <vTaskIncrementTick+0xf0>
80005998:	70 08       	ld.w	r8,r8[0x0]
8000599a:	70 38       	ld.w	r8,r8[0xc]
8000599c:	70 38       	ld.w	r8,r8[0xc]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
8000599e:	70 19       	ld.w	r9,r8[0x4]
800059a0:	4a d8       	lddpc	r8,80005a54 <vTaskIncrementTick+0xfc>
800059a2:	91 09       	st.w	r8[0x0],r9
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
800059a4:	4a 88       	lddpc	r8,80005a44 <vTaskIncrementTick+0xec>
800059a6:	70 09       	ld.w	r9,r8[0x0]
800059a8:	4a b8       	lddpc	r8,80005a54 <vTaskIncrementTick+0xfc>
800059aa:	70 08       	ld.w	r8,r8[0x0]
800059ac:	10 39       	cp.w	r9,r8
800059ae:	c4 73       	brcs	80005a3c <vTaskIncrementTick+0xe4>
800059b0:	4a 68       	lddpc	r8,80005a48 <vTaskIncrementTick+0xf0>
800059b2:	70 08       	ld.w	r8,r8[0x0]
800059b4:	70 08       	ld.w	r8,r8[0x0]
800059b6:	58 08       	cp.w	r8,0
800059b8:	c0 c0       	breq	800059d0 <vTaskIncrementTick+0x78>
800059ba:	4a 48       	lddpc	r8,80005a48 <vTaskIncrementTick+0xf0>
800059bc:	70 08       	ld.w	r8,r8[0x0]
800059be:	70 38       	ld.w	r8,r8[0xc]
800059c0:	70 37       	ld.w	r7,r8[0xc]
800059c2:	6e 18       	ld.w	r8,r7[0x4]
800059c4:	4a 09       	lddpc	r9,80005a44 <vTaskIncrementTick+0xec>
800059c6:	72 09       	ld.w	r9,r9[0x0]
800059c8:	12 38       	cp.w	r8,r9
800059ca:	e0 88 00 14 	brls	800059f2 <vTaskIncrementTick+0x9a>
800059ce:	c0 e8       	rjmp	800059ea <vTaskIncrementTick+0x92>
800059d0:	3f f9       	mov	r9,-1
800059d2:	4a 18       	lddpc	r8,80005a54 <vTaskIncrementTick+0xfc>
800059d4:	91 09       	st.w	r8[0x0],r9
800059d6:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
800059da:	6a 08       	ld.w	r8,r5[0x0]
800059dc:	70 38       	ld.w	r8,r8[0xc]
800059de:	70 37       	ld.w	r7,r8[0xc]
800059e0:	6e 18       	ld.w	r8,r7[0x4]
800059e2:	64 09       	ld.w	r9,r2[0x0]
800059e4:	12 38       	cp.w	r8,r9
800059e6:	e0 88 00 0a 	brls	800059fa <vTaskIncrementTick+0xa2>
800059ea:	49 b9       	lddpc	r9,80005a54 <vTaskIncrementTick+0xfc>
800059ec:	93 08       	st.w	r9[0x0],r8
800059ee:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
800059f2:	49 a4       	lddpc	r4,80005a58 <vTaskIncrementTick+0x100>
800059f4:	49 a3       	lddpc	r3,80005a5c <vTaskIncrementTick+0x104>
800059f6:	49 55       	lddpc	r5,80005a48 <vTaskIncrementTick+0xf0>
800059f8:	49 32       	lddpc	r2,80005a44 <vTaskIncrementTick+0xec>
800059fa:	ee c6 ff fc 	sub	r6,r7,-4
800059fe:	0c 9c       	mov	r12,r6
80005a00:	f0 1f 00 18 	mcall	80005a60 <vTaskIncrementTick+0x108>
80005a04:	6e a8       	ld.w	r8,r7[0x28]
80005a06:	58 08       	cp.w	r8,0
80005a08:	c0 50       	breq	80005a12 <vTaskIncrementTick+0xba>
80005a0a:	ee cc ff e8 	sub	r12,r7,-24
80005a0e:	f0 1f 00 15 	mcall	80005a60 <vTaskIncrementTick+0x108>
80005a12:	6e bc       	ld.w	r12,r7[0x2c]
80005a14:	68 08       	ld.w	r8,r4[0x0]
80005a16:	10 3c       	cp.w	r12,r8
80005a18:	e9 fc ba 00 	st.whi	r4[0x0],r12
80005a1c:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80005a20:	0c 9b       	mov	r11,r6
80005a22:	e6 0c 00 2c 	add	r12,r3,r12<<0x2
80005a26:	f0 1f 00 10 	mcall	80005a64 <vTaskIncrementTick+0x10c>
80005a2a:	6a 08       	ld.w	r8,r5[0x0]
80005a2c:	70 08       	ld.w	r8,r8[0x0]
80005a2e:	58 08       	cp.w	r8,0
80005a30:	cd 51       	brne	800059da <vTaskIncrementTick+0x82>
80005a32:	cc fb       	rjmp	800059d0 <vTaskIncrementTick+0x78>
	}
	else
	{
		++uxMissedTicks;
80005a34:	48 d8       	lddpc	r8,80005a68 <vTaskIncrementTick+0x110>
80005a36:	70 09       	ld.w	r9,r8[0x0]
80005a38:	2f f9       	sub	r9,-1
80005a3a:	91 09       	st.w	r8[0x0],r9
80005a3c:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80005a40:	00 00       	add	r0,r0
80005a42:	0d 14       	ld.sh	r4,r6++
80005a44:	00 00       	add	r0,r0
80005a46:	0d 10       	ld.sh	r0,r6++
80005a48:	00 00       	add	r0,r0
80005a4a:	0c 1c       	sub	r12,r6
80005a4c:	00 00       	add	r0,r0
80005a4e:	0c 2c       	rsub	r12,r6
80005a50:	00 00       	add	r0,r0
80005a52:	0c 28       	rsub	r8,r6
80005a54:	00 00       	add	r0,r0
80005a56:	05 3c       	ld.ub	r12,r2++
80005a58:	00 00       	add	r0,r0
80005a5a:	0d 4c       	ld.w	r12,--r6
80005a5c:	00 00       	add	r0,r0
80005a5e:	0c 30       	cp.w	r0,r6
80005a60:	80 00       	ld.sh	r0,r0[0x0]
80005a62:	4f 56       	lddpc	r6,80005c34 <prvAddCurrentTaskToDelayedList+0x4c>
80005a64:	80 00       	ld.sh	r0,r0[0x0]
80005a66:	4f 06       	lddpc	r6,80005c24 <prvAddCurrentTaskToDelayedList+0x3c>
80005a68:	00 00       	add	r0,r0
80005a6a:	0c 14       	sub	r4,r6

80005a6c <xTaskCheckForTimeOut>:
	pxTimeOut->xTimeOnEntering = xTickCount;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
80005a6c:	eb cd 40 c0 	pushm	r6-r7,lr
80005a70:	18 97       	mov	r7,r12
80005a72:	16 96       	mov	r6,r11
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
80005a74:	f0 1f 00 15 	mcall	80005ac8 <xTaskCheckForTimeOut+0x5c>
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
80005a78:	6c 08       	ld.w	r8,r6[0x0]
80005a7a:	5b f8       	cp.w	r8,-1
80005a7c:	c0 31       	brne	80005a82 <xTaskCheckForTimeOut+0x16>
80005a7e:	30 07       	mov	r7,0
80005a80:	c1 f8       	rjmp	80005abe <xTaskCheckForTimeOut+0x52>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
80005a82:	49 39       	lddpc	r9,80005acc <xTaskCheckForTimeOut+0x60>
80005a84:	72 09       	ld.w	r9,r9[0x0]
80005a86:	6e 0a       	ld.w	r10,r7[0x0]
80005a88:	12 3a       	cp.w	r10,r9
80005a8a:	c0 70       	breq	80005a98 <xTaskCheckForTimeOut+0x2c>
80005a8c:	49 19       	lddpc	r9,80005ad0 <xTaskCheckForTimeOut+0x64>
80005a8e:	72 09       	ld.w	r9,r9[0x0]
80005a90:	6e 1a       	ld.w	r10,r7[0x4]
80005a92:	12 3a       	cp.w	r10,r9
80005a94:	e0 88 00 14 	brls	80005abc <xTaskCheckForTimeOut+0x50>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
80005a98:	48 e9       	lddpc	r9,80005ad0 <xTaskCheckForTimeOut+0x64>
80005a9a:	72 0a       	ld.w	r10,r9[0x0]
80005a9c:	6e 19       	ld.w	r9,r7[0x4]
80005a9e:	12 1a       	sub	r10,r9
80005aa0:	14 38       	cp.w	r8,r10
80005aa2:	e0 88 00 0d 	brls	80005abc <xTaskCheckForTimeOut+0x50>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
80005aa6:	48 ba       	lddpc	r10,80005ad0 <xTaskCheckForTimeOut+0x64>
80005aa8:	74 0a       	ld.w	r10,r10[0x0]
80005aaa:	14 19       	sub	r9,r10
80005aac:	f2 08 00 08 	add	r8,r9,r8
80005ab0:	8d 08       	st.w	r6[0x0],r8
			vTaskSetTimeOutState( pxTimeOut );
80005ab2:	0e 9c       	mov	r12,r7
80005ab4:	f0 1f 00 08 	mcall	80005ad4 <xTaskCheckForTimeOut+0x68>
80005ab8:	30 07       	mov	r7,0
80005aba:	c0 28       	rjmp	80005abe <xTaskCheckForTimeOut+0x52>
80005abc:	30 17       	mov	r7,1
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
80005abe:	f0 1f 00 07 	mcall	80005ad8 <xTaskCheckForTimeOut+0x6c>

	return xReturn;
}
80005ac2:	0e 9c       	mov	r12,r7
80005ac4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005ac8:	80 00       	ld.sh	r0,r0[0x0]
80005aca:	50 10       	stdsp	sp[0x4],r0
80005acc:	00 00       	add	r0,r0
80005ace:	0c 28       	rsub	r8,r6
80005ad0:	00 00       	add	r0,r0
80005ad2:	0d 10       	ld.sh	r0,r6++
80005ad4:	80 00       	ld.sh	r0,r0[0x0]
80005ad6:	57 d0       	stdsp	sp[0x1f4],r0
80005ad8:	80 00       	ld.sh	r0,r0[0x0]
80005ada:	51 1c       	stdsp	sp[0x44],r12

80005adc <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
80005adc:	eb cd 40 80 	pushm	r7,lr
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
80005ae0:	f0 1f 00 05 	mcall	80005af4 <xTaskGetTickCount+0x18>
	{
		xTicks = xTickCount;
80005ae4:	48 58       	lddpc	r8,80005af8 <xTaskGetTickCount+0x1c>
80005ae6:	70 07       	ld.w	r7,r8[0x0]
	}
	taskEXIT_CRITICAL();
80005ae8:	f0 1f 00 05 	mcall	80005afc <xTaskGetTickCount+0x20>

	return xTicks;
}
80005aec:	0e 9c       	mov	r12,r7
80005aee:	e3 cd 80 80 	ldm	sp++,r7,pc
80005af2:	00 00       	add	r0,r0
80005af4:	80 00       	ld.sh	r0,r0[0x0]
80005af6:	50 10       	stdsp	sp[0x4],r0
80005af8:	00 00       	add	r0,r0
80005afa:	0d 10       	ld.sh	r0,r6++
80005afc:	80 00       	ld.sh	r0,r0[0x0]
80005afe:	51 1c       	stdsp	sp[0x44],r12

80005b00 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
80005b00:	eb cd 40 fe 	pushm	r1-r7,lr
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
80005b04:	f0 1f 00 2c 	mcall	80005bb4 <xTaskResumeAll+0xb4>
	{
		--uxSchedulerSuspended;
80005b08:	4a c8       	lddpc	r8,80005bb8 <xTaskResumeAll+0xb8>
80005b0a:	70 09       	ld.w	r9,r8[0x0]
80005b0c:	20 19       	sub	r9,1
80005b0e:	91 09       	st.w	r8[0x0],r9

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80005b10:	70 08       	ld.w	r8,r8[0x0]
80005b12:	58 08       	cp.w	r8,0
80005b14:	c4 91       	brne	80005ba6 <xTaskResumeAll+0xa6>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
80005b16:	4a a8       	lddpc	r8,80005bbc <xTaskResumeAll+0xbc>
80005b18:	70 08       	ld.w	r8,r8[0x0]
80005b1a:	58 08       	cp.w	r8,0
80005b1c:	c4 50       	breq	80005ba6 <xTaskResumeAll+0xa6>
80005b1e:	30 04       	mov	r4,0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80005b20:	4a 85       	lddpc	r5,80005bc0 <xTaskResumeAll+0xc0>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
80005b22:	4a 93       	lddpc	r3,80005bc4 <xTaskResumeAll+0xc4>
80005b24:	4a 92       	lddpc	r2,80005bc8 <xTaskResumeAll+0xc8>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80005b26:	4a a1       	lddpc	r1,80005bcc <xTaskResumeAll+0xcc>
80005b28:	c1 e8       	rjmp	80005b64 <xTaskResumeAll+0x64>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
80005b2a:	6a 38       	ld.w	r8,r5[0xc]
80005b2c:	70 37       	ld.w	r7,r8[0xc]
					vListRemove( &( pxTCB->xEventListItem ) );
80005b2e:	ee cc ff e8 	sub	r12,r7,-24
80005b32:	f0 1f 00 28 	mcall	80005bd0 <xTaskResumeAll+0xd0>
					vListRemove( &( pxTCB->xGenericListItem ) );
80005b36:	ee c6 ff fc 	sub	r6,r7,-4
80005b3a:	0c 9c       	mov	r12,r6
80005b3c:	f0 1f 00 25 	mcall	80005bd0 <xTaskResumeAll+0xd0>
					prvAddTaskToReadyQueue( pxTCB );
80005b40:	6e bc       	ld.w	r12,r7[0x2c]
80005b42:	66 08       	ld.w	r8,r3[0x0]
80005b44:	10 3c       	cp.w	r12,r8
80005b46:	e7 fc ba 00 	st.whi	r3[0x0],r12
80005b4a:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80005b4e:	0c 9b       	mov	r11,r6
80005b50:	e4 0c 00 2c 	add	r12,r2,r12<<0x2
80005b54:	f0 1f 00 20 	mcall	80005bd4 <xTaskResumeAll+0xd4>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80005b58:	62 08       	ld.w	r8,r1[0x0]
80005b5a:	6e b9       	ld.w	r9,r7[0x2c]
80005b5c:	70 b8       	ld.w	r8,r8[0x2c]
80005b5e:	10 39       	cp.w	r9,r8
80005b60:	f9 b4 02 01 	movhs	r4,1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80005b64:	6a 08       	ld.w	r8,r5[0x0]
80005b66:	58 08       	cp.w	r8,0
80005b68:	ce 11       	brne	80005b2a <xTaskResumeAll+0x2a>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80005b6a:	49 c8       	lddpc	r8,80005bd8 <xTaskResumeAll+0xd8>
80005b6c:	70 08       	ld.w	r8,r8[0x0]
80005b6e:	58 08       	cp.w	r8,0
80005b70:	c0 f0       	breq	80005b8e <xTaskResumeAll+0x8e>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80005b72:	49 a8       	lddpc	r8,80005bd8 <xTaskResumeAll+0xd8>
80005b74:	70 08       	ld.w	r8,r8[0x0]
80005b76:	58 08       	cp.w	r8,0
80005b78:	c1 10       	breq	80005b9a <xTaskResumeAll+0x9a>
					{
						vTaskIncrementTick();
						--uxMissedTicks;
80005b7a:	49 87       	lddpc	r7,80005bd8 <xTaskResumeAll+0xd8>
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
80005b7c:	f0 1f 00 18 	mcall	80005bdc <xTaskResumeAll+0xdc>
						--uxMissedTicks;
80005b80:	6e 08       	ld.w	r8,r7[0x0]
80005b82:	20 18       	sub	r8,1
80005b84:	8f 08       	st.w	r7[0x0],r8
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80005b86:	6e 08       	ld.w	r8,r7[0x0]
80005b88:	58 08       	cp.w	r8,0
80005b8a:	cf 91       	brne	80005b7c <xTaskResumeAll+0x7c>
80005b8c:	c0 78       	rjmp	80005b9a <xTaskResumeAll+0x9a>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
80005b8e:	58 14       	cp.w	r4,1
80005b90:	c0 50       	breq	80005b9a <xTaskResumeAll+0x9a>
80005b92:	49 48       	lddpc	r8,80005be0 <xTaskResumeAll+0xe0>
80005b94:	70 08       	ld.w	r8,r8[0x0]
80005b96:	58 18       	cp.w	r8,1
80005b98:	c0 71       	brne	80005ba6 <xTaskResumeAll+0xa6>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
80005b9a:	30 09       	mov	r9,0
80005b9c:	49 18       	lddpc	r8,80005be0 <xTaskResumeAll+0xe0>
80005b9e:	91 09       	st.w	r8[0x0],r9
					portYIELD_WITHIN_API();
80005ba0:	d7 33       	scall
80005ba2:	30 17       	mov	r7,1
80005ba4:	c0 28       	rjmp	80005ba8 <xTaskResumeAll+0xa8>
80005ba6:	30 07       	mov	r7,0
				}
			}
		}
	}
	taskEXIT_CRITICAL();
80005ba8:	f0 1f 00 0f 	mcall	80005be4 <xTaskResumeAll+0xe4>

	return xAlreadyYielded;
}
80005bac:	0e 9c       	mov	r12,r7
80005bae:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
80005bb2:	00 00       	add	r0,r0
80005bb4:	80 00       	ld.sh	r0,r0[0x0]
80005bb6:	50 10       	stdsp	sp[0x4],r0
80005bb8:	00 00       	add	r0,r0
80005bba:	0d 14       	ld.sh	r4,r6++
80005bbc:	00 00       	add	r0,r0
80005bbe:	0d 30       	ld.ub	r0,r6++
80005bc0:	00 00       	add	r0,r0
80005bc2:	0c e8       	st.h	--r6,r8
80005bc4:	00 00       	add	r0,r0
80005bc6:	0d 4c       	ld.w	r12,--r6
80005bc8:	00 00       	add	r0,r0
80005bca:	0c 30       	cp.w	r0,r6
80005bcc:	00 00       	add	r0,r0
80005bce:	0c e4       	st.h	--r6,r4
80005bd0:	80 00       	ld.sh	r0,r0[0x0]
80005bd2:	4f 56       	lddpc	r6,80005da4 <xTaskGenericCreate>
80005bd4:	80 00       	ld.sh	r0,r0[0x0]
80005bd6:	4f 06       	lddpc	r6,80005d94 <prvIdleTask+0x78>
80005bd8:	00 00       	add	r0,r0
80005bda:	0c 14       	sub	r4,r6
80005bdc:	80 00       	ld.sh	r0,r0[0x0]
80005bde:	59 58       	cp.w	r8,21
80005be0:	00 00       	add	r0,r0
80005be2:	0d 34       	ld.ub	r4,r6++
80005be4:	80 00       	ld.sh	r0,r0[0x0]
80005be6:	51 1c       	stdsp	sp[0x44],r12

80005be8 <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
80005be8:	eb cd 40 80 	pushm	r7,lr
80005bec:	18 97       	mov	r7,r12
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
80005bee:	49 08       	lddpc	r8,80005c2c <prvAddCurrentTaskToDelayedList+0x44>
80005bf0:	70 08       	ld.w	r8,r8[0x0]
80005bf2:	91 1c       	st.w	r8[0x4],r12

	if( xTimeToWake < xTickCount )
80005bf4:	48 f8       	lddpc	r8,80005c30 <prvAddCurrentTaskToDelayedList+0x48>
80005bf6:	70 08       	ld.w	r8,r8[0x0]
80005bf8:	10 3c       	cp.w	r12,r8
80005bfa:	c0 a2       	brcc	80005c0e <prvAddCurrentTaskToDelayedList+0x26>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80005bfc:	48 c8       	lddpc	r8,80005c2c <prvAddCurrentTaskToDelayedList+0x44>
80005bfe:	70 0b       	ld.w	r11,r8[0x0]
80005c00:	48 d8       	lddpc	r8,80005c34 <prvAddCurrentTaskToDelayedList+0x4c>
80005c02:	70 0c       	ld.w	r12,r8[0x0]
80005c04:	2f cb       	sub	r11,-4
80005c06:	f0 1f 00 0d 	mcall	80005c38 <prvAddCurrentTaskToDelayedList+0x50>
80005c0a:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80005c0e:	48 88       	lddpc	r8,80005c2c <prvAddCurrentTaskToDelayedList+0x44>
80005c10:	70 0b       	ld.w	r11,r8[0x0]
80005c12:	48 b8       	lddpc	r8,80005c3c <prvAddCurrentTaskToDelayedList+0x54>
80005c14:	70 0c       	ld.w	r12,r8[0x0]
80005c16:	2f cb       	sub	r11,-4
80005c18:	f0 1f 00 08 	mcall	80005c38 <prvAddCurrentTaskToDelayedList+0x50>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
80005c1c:	48 98       	lddpc	r8,80005c40 <prvAddCurrentTaskToDelayedList+0x58>
80005c1e:	70 08       	ld.w	r8,r8[0x0]
80005c20:	10 37       	cp.w	r7,r8
80005c22:	c0 32       	brcc	80005c28 <prvAddCurrentTaskToDelayedList+0x40>
		{
			xNextTaskUnblockTime = xTimeToWake;
80005c24:	48 78       	lddpc	r8,80005c40 <prvAddCurrentTaskToDelayedList+0x58>
80005c26:	91 07       	st.w	r8[0x0],r7
80005c28:	e3 cd 80 80 	ldm	sp++,r7,pc
80005c2c:	00 00       	add	r0,r0
80005c2e:	0c e4       	st.h	--r6,r4
80005c30:	00 00       	add	r0,r0
80005c32:	0d 10       	ld.sh	r0,r6++
80005c34:	00 00       	add	r0,r0
80005c36:	0c 2c       	rsub	r12,r6
80005c38:	80 00       	ld.sh	r0,r0[0x0]
80005c3a:	4f 22       	lddpc	r2,80005e00 <xTaskGenericCreate+0x5c>
80005c3c:	00 00       	add	r0,r0
80005c3e:	0c 1c       	sub	r12,r6
80005c40:	00 00       	add	r0,r0
80005c42:	05 3c       	ld.ub	r12,r2++

80005c44 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
80005c44:	eb cd 40 c0 	pushm	r6-r7,lr
80005c48:	18 96       	mov	r6,r12
80005c4a:	16 97       	mov	r7,r11
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0 ) );

		vTaskSuspendAll();
80005c4c:	f0 1f 00 18 	mcall	80005cac <vTaskDelayUntil+0x68>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
80005c50:	6c 08       	ld.w	r8,r6[0x0]
80005c52:	10 07       	add	r7,r8

			if( xTickCount < *pxPreviousWakeTime )
80005c54:	49 79       	lddpc	r9,80005cb0 <vTaskDelayUntil+0x6c>
80005c56:	72 09       	ld.w	r9,r9[0x0]
80005c58:	12 38       	cp.w	r8,r9
80005c5a:	e0 88 00 0c 	brls	80005c72 <vTaskDelayUntil+0x2e>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
80005c5e:	0e 38       	cp.w	r8,r7
80005c60:	e0 88 00 22 	brls	80005ca4 <vTaskDelayUntil+0x60>
80005c64:	49 38       	lddpc	r8,80005cb0 <vTaskDelayUntil+0x6c>
80005c66:	70 08       	ld.w	r8,r8[0x0]
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80005c68:	8d 07       	st.w	r6[0x0],r7

			if( xShouldDelay != pdFALSE )
80005c6a:	10 37       	cp.w	r7,r8
80005c6c:	e0 88 00 14 	brls	80005c94 <vTaskDelayUntil+0x50>
80005c70:	c0 a8       	rjmp	80005c84 <vTaskDelayUntil+0x40>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
80005c72:	0e 38       	cp.w	r8,r7
80005c74:	e0 8b 00 16 	brhi	80005ca0 <vTaskDelayUntil+0x5c>
80005c78:	48 e8       	lddpc	r8,80005cb0 <vTaskDelayUntil+0x6c>
80005c7a:	70 08       	ld.w	r8,r8[0x0]
80005c7c:	10 37       	cp.w	r7,r8
80005c7e:	e0 8b 00 11 	brhi	80005ca0 <vTaskDelayUntil+0x5c>
80005c82:	c1 18       	rjmp	80005ca4 <vTaskDelayUntil+0x60>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80005c84:	48 c8       	lddpc	r8,80005cb4 <vTaskDelayUntil+0x70>
80005c86:	70 0c       	ld.w	r12,r8[0x0]
80005c88:	2f cc       	sub	r12,-4
80005c8a:	f0 1f 00 0c 	mcall	80005cb8 <vTaskDelayUntil+0x74>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
80005c8e:	0e 9c       	mov	r12,r7
80005c90:	f0 1f 00 0b 	mcall	80005cbc <vTaskDelayUntil+0x78>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
80005c94:	f0 1f 00 0b 	mcall	80005cc0 <vTaskDelayUntil+0x7c>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
80005c98:	c0 81       	brne	80005ca8 <vTaskDelayUntil+0x64>
		{
			portYIELD_WITHIN_API();
80005c9a:	d7 33       	scall
80005c9c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80005ca0:	8d 07       	st.w	r6[0x0],r7
80005ca2:	cf 1b       	rjmp	80005c84 <vTaskDelayUntil+0x40>
80005ca4:	8d 07       	st.w	r6[0x0],r7
80005ca6:	cf 7b       	rjmp	80005c94 <vTaskDelayUntil+0x50>
80005ca8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005cac:	80 00       	ld.sh	r0,r0[0x0]
80005cae:	57 44       	stdsp	sp[0x1d0],r4
80005cb0:	00 00       	add	r0,r0
80005cb2:	0d 10       	ld.sh	r0,r6++
80005cb4:	00 00       	add	r0,r0
80005cb6:	0c e4       	st.h	--r6,r4
80005cb8:	80 00       	ld.sh	r0,r0[0x0]
80005cba:	4f 56       	lddpc	r6,80005e8c <xTaskGenericCreate+0xe8>
80005cbc:	80 00       	ld.sh	r0,r0[0x0]
80005cbe:	5b e8       	cp.w	r8,-2
80005cc0:	80 00       	ld.sh	r0,r0[0x0]
80005cc2:	5b 00       	cp.w	r0,-16

80005cc4 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
80005cc4:	eb cd 40 c0 	pushm	r6-r7,lr
80005cc8:	16 96       	mov	r6,r11
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
80005cca:	48 e7       	lddpc	r7,80005d00 <vTaskPlaceOnEventList+0x3c>
80005ccc:	6e 0b       	ld.w	r11,r7[0x0]
80005cce:	2e 8b       	sub	r11,-24
80005cd0:	f0 1f 00 0d 	mcall	80005d04 <vTaskPlaceOnEventList+0x40>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80005cd4:	6e 0c       	ld.w	r12,r7[0x0]
80005cd6:	2f cc       	sub	r12,-4
80005cd8:	f0 1f 00 0c 	mcall	80005d08 <vTaskPlaceOnEventList+0x44>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
80005cdc:	5b f6       	cp.w	r6,-1
80005cde:	c0 81       	brne	80005cee <vTaskPlaceOnEventList+0x2a>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80005ce0:	6e 0b       	ld.w	r11,r7[0x0]
80005ce2:	2f cb       	sub	r11,-4
80005ce4:	48 ac       	lddpc	r12,80005d0c <vTaskPlaceOnEventList+0x48>
80005ce6:	f0 1f 00 0b 	mcall	80005d10 <vTaskPlaceOnEventList+0x4c>
80005cea:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
80005cee:	48 a8       	lddpc	r8,80005d14 <vTaskPlaceOnEventList+0x50>
80005cf0:	70 0c       	ld.w	r12,r8[0x0]
			prvAddCurrentTaskToDelayedList( xTimeToWake );
80005cf2:	ec 0c 00 0c 	add	r12,r6,r12
80005cf6:	f0 1f 00 09 	mcall	80005d18 <vTaskPlaceOnEventList+0x54>
80005cfa:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005cfe:	00 00       	add	r0,r0
80005d00:	00 00       	add	r0,r0
80005d02:	0c e4       	st.h	--r6,r4
80005d04:	80 00       	ld.sh	r0,r0[0x0]
80005d06:	4f 22       	lddpc	r2,80005ecc <xTaskGenericCreate+0x128>
80005d08:	80 00       	ld.sh	r0,r0[0x0]
80005d0a:	4f 56       	lddpc	r6,80005edc <xTaskGenericCreate+0x138>
80005d0c:	00 00       	add	r0,r0
80005d0e:	0d 38       	ld.ub	r8,r6++
80005d10:	80 00       	ld.sh	r0,r0[0x0]
80005d12:	4f 06       	lddpc	r6,80005ed0 <xTaskGenericCreate+0x12c>
80005d14:	00 00       	add	r0,r0
80005d16:	0d 10       	ld.sh	r0,r6++
80005d18:	80 00       	ld.sh	r0,r0[0x0]
80005d1a:	5b e8       	cp.w	r8,-2

80005d1c <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
80005d1c:	eb cd 40 f8 	pushm	r3-r7,lr
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80005d20:	49 67       	lddpc	r7,80005d78 <prvIdleTask+0x5c>
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
80005d22:	49 74       	lddpc	r4,80005d7c <prvIdleTask+0x60>

				taskENTER_CRITICAL();
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					--uxCurrentNumberOfTasks;
80005d24:	49 73       	lddpc	r3,80005d80 <prvIdleTask+0x64>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80005d26:	49 85       	lddpc	r5,80005d84 <prvIdleTask+0x68>
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80005d28:	6e 08       	ld.w	r8,r7[0x0]
80005d2a:	58 08       	cp.w	r8,0
80005d2c:	c1 e0       	breq	80005d68 <prvIdleTask+0x4c>
		{
			vTaskSuspendAll();
80005d2e:	f0 1f 00 17 	mcall	80005d88 <prvIdleTask+0x6c>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
80005d32:	68 06       	ld.w	r6,r4[0x0]
			xTaskResumeAll();
80005d34:	f0 1f 00 16 	mcall	80005d8c <prvIdleTask+0x70>

			if( xListIsEmpty == pdFALSE )
80005d38:	58 06       	cp.w	r6,0
80005d3a:	c1 70       	breq	80005d68 <prvIdleTask+0x4c>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
80005d3c:	f0 1f 00 15 	mcall	80005d90 <prvIdleTask+0x74>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
80005d40:	68 38       	ld.w	r8,r4[0xc]
80005d42:	70 36       	ld.w	r6,r8[0xc]
					vListRemove( &( pxTCB->xGenericListItem ) );
80005d44:	ec cc ff fc 	sub	r12,r6,-4
80005d48:	f0 1f 00 13 	mcall	80005d94 <prvIdleTask+0x78>
					--uxCurrentNumberOfTasks;
80005d4c:	66 08       	ld.w	r8,r3[0x0]
80005d4e:	20 18       	sub	r8,1
80005d50:	87 08       	st.w	r3[0x0],r8
					--uxTasksDeleted;
80005d52:	6e 08       	ld.w	r8,r7[0x0]
80005d54:	20 18       	sub	r8,1
80005d56:	8f 08       	st.w	r7[0x0],r8
				}
				taskEXIT_CRITICAL();
80005d58:	f0 1f 00 10 	mcall	80005d98 <prvIdleTask+0x7c>

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
80005d5c:	6c cc       	ld.w	r12,r6[0x30]
80005d5e:	f0 1f 00 10 	mcall	80005d9c <prvIdleTask+0x80>
		vPortFree( pxTCB );
80005d62:	0c 9c       	mov	r12,r6
80005d64:	f0 1f 00 0e 	mcall	80005d9c <prvIdleTask+0x80>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80005d68:	6a 08       	ld.w	r8,r5[0x0]
80005d6a:	58 18       	cp.w	r8,1
80005d6c:	e0 88 00 03 	brls	80005d72 <prvIdleTask+0x56>
			{
				taskYIELD();
80005d70:	d7 33       	scall
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
80005d72:	f0 1f 00 0c 	mcall	80005da0 <prvIdleTask+0x84>
		}
		#endif
	}
80005d76:	cd 9b       	rjmp	80005d28 <prvIdleTask+0xc>
80005d78:	00 00       	add	r0,r0
80005d7a:	0c 24       	rsub	r4,r6
80005d7c:	00 00       	add	r0,r0
80005d7e:	0c d0       	st.w	--r6,r0
80005d80:	00 00       	add	r0,r0
80005d82:	0d 30       	ld.ub	r0,r6++
80005d84:	00 00       	add	r0,r0
80005d86:	0c 30       	cp.w	r0,r6
80005d88:	80 00       	ld.sh	r0,r0[0x0]
80005d8a:	57 44       	stdsp	sp[0x1d0],r4
80005d8c:	80 00       	ld.sh	r0,r0[0x0]
80005d8e:	5b 00       	cp.w	r0,-16
80005d90:	80 00       	ld.sh	r0,r0[0x0]
80005d92:	50 10       	stdsp	sp[0x4],r0
80005d94:	80 00       	ld.sh	r0,r0[0x0]
80005d96:	4f 56       	lddpc	r6,80005f68 <xTaskGenericCreate+0x1c4>
80005d98:	80 00       	ld.sh	r0,r0[0x0]
80005d9a:	51 1c       	stdsp	sp[0x44],r12
80005d9c:	80 00       	ld.sh	r0,r0[0x0]
80005d9e:	52 54       	stdsp	sp[0x94],r4
80005da0:	80 00       	ld.sh	r0,r0[0x0]
80005da2:	20 2c       	sub	r12,2

80005da4 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
80005da4:	d4 31       	pushm	r0-r7,lr
80005da6:	20 1d       	sub	sp,4
80005da8:	fa c4 ff d8 	sub	r4,sp,-40
80005dac:	50 0c       	stdsp	sp[0x0],r12
80005dae:	16 91       	mov	r1,r11
80005db0:	14 97       	mov	r7,r10
80005db2:	12 90       	mov	r0,r9
80005db4:	10 93       	mov	r3,r8
80005db6:	68 02       	ld.w	r2,r4[0x0]
80005db8:	68 16       	ld.w	r6,r4[0x4]
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
80005dba:	34 8c       	mov	r12,72
80005dbc:	f0 1f 00 5c 	mcall	80005f2c <xTaskGenericCreate+0x188>
80005dc0:	18 95       	mov	r5,r12

	if( pxNewTCB != NULL )
80005dc2:	c0 31       	brne	80005dc8 <xTaskGenericCreate+0x24>
80005dc4:	3f fc       	mov	r12,-1
80005dc6:	ca f8       	rjmp	80005f24 <xTaskGenericCreate+0x180>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80005dc8:	58 06       	cp.w	r6,0
80005dca:	e0 81 00 af 	brne	80005f28 <xTaskGenericCreate+0x184>
80005dce:	0e 9c       	mov	r12,r7
80005dd0:	5c 7c       	castu.h	r12
80005dd2:	a3 6c       	lsl	r12,0x2
80005dd4:	f0 1f 00 56 	mcall	80005f2c <xTaskGenericCreate+0x188>
80005dd8:	18 96       	mov	r6,r12
80005dda:	8b cc       	st.w	r5[0x30],r12

		if( pxNewTCB->pxStack == NULL )
80005ddc:	c0 61       	brne	80005de8 <xTaskGenericCreate+0x44>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
80005dde:	0a 9c       	mov	r12,r5
80005de0:	f0 1f 00 54 	mcall	80005f30 <xTaskGenericCreate+0x18c>
80005de4:	3f fc       	mov	r12,-1
80005de6:	c9 f8       	rjmp	80005f24 <xTaskGenericCreate+0x180>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
80005de8:	5c 77       	castu.h	r7
80005dea:	ee 0a 15 02 	lsl	r10,r7,0x2
80005dee:	e0 6b 00 a5 	mov	r11,165
80005df2:	0c 9c       	mov	r12,r6
80005df4:	f0 1f 00 50 	mcall	80005f34 <xTaskGenericCreate+0x190>
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~portBYTE_ALIGNMENT_MASK  ) );
80005df8:	ee c6 00 01 	sub	r6,r7,1
80005dfc:	6a c8       	ld.w	r8,r5[0x30]
80005dfe:	f0 06 00 26 	add	r6,r8,r6<<0x2
80005e02:	e0 16 ff fc 	andl	r6,0xfffc
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
80005e06:	31 0a       	mov	r10,16
80005e08:	02 9b       	mov	r11,r1
80005e0a:	ea cc ff cc 	sub	r12,r5,-52
80005e0e:	f0 1f 00 4b 	mcall	80005f38 <xTaskGenericCreate+0x194>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
80005e12:	30 08       	mov	r8,0
80005e14:	eb 68 00 43 	st.b	r5[67],r8
80005e18:	58 73       	cp.w	r3,7
80005e1a:	e6 07 17 80 	movls	r7,r3
80005e1e:	f9 b7 0b 07 	movhi	r7,7
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
80005e22:	8b b7       	st.w	r5[0x2c],r7
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
80005e24:	eb 47 00 44 	st.w	r5[68],r7
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
80005e28:	ea c4 ff fc 	sub	r4,r5,-4
80005e2c:	08 9c       	mov	r12,r4
80005e2e:	f0 1f 00 44 	mcall	80005f3c <xTaskGenericCreate+0x198>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
80005e32:	ea cc ff e8 	sub	r12,r5,-24
80005e36:	f0 1f 00 42 	mcall	80005f3c <xTaskGenericCreate+0x198>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
80005e3a:	8b 45       	st.w	r5[0x10],r5

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
80005e3c:	ee 07 11 08 	rsub	r7,r7,8
80005e40:	8b 67       	st.w	r5[0x18],r7
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
80005e42:	8b 95       	st.w	r5[0x24],r5
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
80005e44:	00 9a       	mov	r10,r0
80005e46:	40 0b       	lddsp	r11,sp[0x0]
80005e48:	0c 9c       	mov	r12,r6
80005e4a:	f0 1f 00 3e 	mcall	80005f40 <xTaskGenericCreate+0x19c>
80005e4e:	8b 0c       	st.w	r5[0x0],r12
		if( ( void * ) pxCreatedTask != NULL )
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
80005e50:	58 02       	cp.w	r2,0
80005e52:	e5 f5 1a 00 	st.wne	r2[0x0],r5
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
80005e56:	f0 1f 00 3c 	mcall	80005f44 <xTaskGenericCreate+0x1a0>
		{
			uxCurrentNumberOfTasks++;
80005e5a:	4b c8       	lddpc	r8,80005f48 <xTaskGenericCreate+0x1a4>
80005e5c:	70 09       	ld.w	r9,r8[0x0]
80005e5e:	2f f9       	sub	r9,-1
80005e60:	91 09       	st.w	r8[0x0],r9
			if( pxCurrentTCB == NULL )
80005e62:	4b b8       	lddpc	r8,80005f4c <xTaskGenericCreate+0x1a8>
80005e64:	70 08       	ld.w	r8,r8[0x0]
80005e66:	58 08       	cp.w	r8,0
80005e68:	c2 61       	brne	80005eb4 <xTaskGenericCreate+0x110>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
80005e6a:	4b 98       	lddpc	r8,80005f4c <xTaskGenericCreate+0x1a8>
80005e6c:	91 05       	st.w	r8[0x0],r5

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
80005e6e:	4b 78       	lddpc	r8,80005f48 <xTaskGenericCreate+0x1a4>
80005e70:	70 08       	ld.w	r8,r8[0x0]
80005e72:	58 18       	cp.w	r8,1
80005e74:	c2 b1       	brne	80005eca <xTaskGenericCreate+0x126>
80005e76:	4b 77       	lddpc	r7,80005f50 <xTaskGenericCreate+0x1ac>

/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
80005e78:	ee c6 ff 60 	sub	r6,r7,-160
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
80005e7c:	0e 9c       	mov	r12,r7
80005e7e:	f0 1f 00 36 	mcall	80005f54 <xTaskGenericCreate+0x1b0>
80005e82:	2e c7       	sub	r7,-20

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
80005e84:	0c 37       	cp.w	r7,r6
80005e86:	cf b1       	brne	80005e7c <xTaskGenericCreate+0xd8>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
80005e88:	4b 47       	lddpc	r7,80005f58 <xTaskGenericCreate+0x1b4>
80005e8a:	0e 9c       	mov	r12,r7
80005e8c:	f0 1f 00 32 	mcall	80005f54 <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
80005e90:	4b 36       	lddpc	r6,80005f5c <xTaskGenericCreate+0x1b8>
80005e92:	0c 9c       	mov	r12,r6
80005e94:	f0 1f 00 30 	mcall	80005f54 <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xPendingReadyList );
80005e98:	4b 2c       	lddpc	r12,80005f60 <xTaskGenericCreate+0x1bc>
80005e9a:	f0 1f 00 2f 	mcall	80005f54 <xTaskGenericCreate+0x1b0>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
80005e9e:	4b 2c       	lddpc	r12,80005f64 <xTaskGenericCreate+0x1c0>
80005ea0:	f0 1f 00 2d 	mcall	80005f54 <xTaskGenericCreate+0x1b0>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
80005ea4:	4b 1c       	lddpc	r12,80005f68 <xTaskGenericCreate+0x1c4>
80005ea6:	f0 1f 00 2c 	mcall	80005f54 <xTaskGenericCreate+0x1b0>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
80005eaa:	4b 18       	lddpc	r8,80005f6c <xTaskGenericCreate+0x1c8>
80005eac:	91 07       	st.w	r8[0x0],r7
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
80005eae:	4b 18       	lddpc	r8,80005f70 <xTaskGenericCreate+0x1cc>
80005eb0:	91 06       	st.w	r8[0x0],r6
80005eb2:	c0 c8       	rjmp	80005eca <xTaskGenericCreate+0x126>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
80005eb4:	4b 08       	lddpc	r8,80005f74 <xTaskGenericCreate+0x1d0>
80005eb6:	70 08       	ld.w	r8,r8[0x0]
80005eb8:	58 08       	cp.w	r8,0
80005eba:	c0 81       	brne	80005eca <xTaskGenericCreate+0x126>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
80005ebc:	4a 48       	lddpc	r8,80005f4c <xTaskGenericCreate+0x1a8>
80005ebe:	70 08       	ld.w	r8,r8[0x0]
80005ec0:	70 b8       	ld.w	r8,r8[0x2c]
80005ec2:	10 33       	cp.w	r3,r8
80005ec4:	c0 33       	brcs	80005eca <xTaskGenericCreate+0x126>
					{
						pxCurrentTCB = pxNewTCB;
80005ec6:	4a 28       	lddpc	r8,80005f4c <xTaskGenericCreate+0x1a8>
80005ec8:	91 05       	st.w	r8[0x0],r5
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
80005eca:	6a b8       	ld.w	r8,r5[0x2c]
80005ecc:	4a b9       	lddpc	r9,80005f78 <xTaskGenericCreate+0x1d4>
80005ece:	72 09       	ld.w	r9,r9[0x0]
80005ed0:	12 38       	cp.w	r8,r9
80005ed2:	e0 88 00 04 	brls	80005eda <xTaskGenericCreate+0x136>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
80005ed6:	4a 99       	lddpc	r9,80005f78 <xTaskGenericCreate+0x1d4>
80005ed8:	93 08       	st.w	r9[0x0],r8
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
80005eda:	4a 98       	lddpc	r8,80005f7c <xTaskGenericCreate+0x1d8>
80005edc:	70 09       	ld.w	r9,r8[0x0]
80005ede:	2f f9       	sub	r9,-1
80005ee0:	91 09       	st.w	r8[0x0],r9

			prvAddTaskToReadyQueue( pxNewTCB );
80005ee2:	6a b8       	ld.w	r8,r5[0x2c]
80005ee4:	4a 79       	lddpc	r9,80005f80 <xTaskGenericCreate+0x1dc>
80005ee6:	72 09       	ld.w	r9,r9[0x0]
80005ee8:	12 38       	cp.w	r8,r9
80005eea:	e0 88 00 04 	brls	80005ef2 <xTaskGenericCreate+0x14e>
80005eee:	4a 59       	lddpc	r9,80005f80 <xTaskGenericCreate+0x1dc>
80005ef0:	93 08       	st.w	r9[0x0],r8
80005ef2:	6a bc       	ld.w	r12,r5[0x2c]
80005ef4:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80005ef8:	08 9b       	mov	r11,r4
80005efa:	49 68       	lddpc	r8,80005f50 <xTaskGenericCreate+0x1ac>
80005efc:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80005f00:	f0 1f 00 21 	mcall	80005f84 <xTaskGenericCreate+0x1e0>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
80005f04:	f0 1f 00 21 	mcall	80005f88 <xTaskGenericCreate+0x1e4>
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
80005f08:	49 b8       	lddpc	r8,80005f74 <xTaskGenericCreate+0x1d0>
80005f0a:	70 08       	ld.w	r8,r8[0x0]
80005f0c:	58 08       	cp.w	r8,0
80005f0e:	c0 a0       	breq	80005f22 <xTaskGenericCreate+0x17e>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
80005f10:	48 f8       	lddpc	r8,80005f4c <xTaskGenericCreate+0x1a8>
80005f12:	70 08       	ld.w	r8,r8[0x0]
80005f14:	70 b8       	ld.w	r8,r8[0x2c]
80005f16:	10 33       	cp.w	r3,r8
80005f18:	e0 88 00 05 	brls	80005f22 <xTaskGenericCreate+0x17e>
			{
				portYIELD_WITHIN_API();
80005f1c:	d7 33       	scall
80005f1e:	30 1c       	mov	r12,1
80005f20:	c0 28       	rjmp	80005f24 <xTaskGenericCreate+0x180>
80005f22:	30 1c       	mov	r12,1
			}
		}
	}

	return xReturn;
}
80005f24:	2f fd       	sub	sp,-4
80005f26:	d8 32       	popm	r0-r7,pc
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80005f28:	99 c6       	st.w	r12[0x30],r6
80005f2a:	c5 fb       	rjmp	80005de8 <xTaskGenericCreate+0x44>
80005f2c:	80 00       	ld.sh	r0,r0[0x0]
80005f2e:	52 7c       	stdsp	sp[0x9c],r12
80005f30:	80 00       	ld.sh	r0,r0[0x0]
80005f32:	52 54       	stdsp	sp[0x94],r4
80005f34:	80 00       	ld.sh	r0,r0[0x0]
80005f36:	6b 3c       	ld.w	r12,r5[0x4c]
80005f38:	80 00       	ld.sh	r0,r0[0x0]
80005f3a:	6e 68       	ld.w	r8,r7[0x18]
80005f3c:	80 00       	ld.sh	r0,r0[0x0]
80005f3e:	4f 00       	lddpc	r0,800060fc <PrintDec+0x6e>
80005f40:	80 00       	ld.sh	r0,r0[0x0]
80005f42:	4f 7c       	lddpc	r12,8000611c <PrintDec+0x8e>
80005f44:	80 00       	ld.sh	r0,r0[0x0]
80005f46:	50 10       	stdsp	sp[0x4],r0
80005f48:	00 00       	add	r0,r0
80005f4a:	0d 30       	ld.ub	r0,r6++
80005f4c:	00 00       	add	r0,r0
80005f4e:	0c e4       	st.h	--r6,r4
80005f50:	00 00       	add	r0,r0
80005f52:	0c 30       	cp.w	r0,r6
80005f54:	80 00       	ld.sh	r0,r0[0x0]
80005f56:	4e ec       	lddpc	r12,8000610c <PrintDec+0x7e>
80005f58:	00 00       	add	r0,r0
80005f5a:	0c fc       	st.b	--r6,r12
80005f5c:	00 00       	add	r0,r0
80005f5e:	0d 18       	ld.sh	r8,r6++
80005f60:	00 00       	add	r0,r0
80005f62:	0c e8       	st.h	--r6,r8
80005f64:	00 00       	add	r0,r0
80005f66:	0c d0       	st.w	--r6,r0
80005f68:	00 00       	add	r0,r0
80005f6a:	0d 38       	ld.ub	r8,r6++
80005f6c:	00 00       	add	r0,r0
80005f6e:	0c 1c       	sub	r12,r6
80005f70:	00 00       	add	r0,r0
80005f72:	0c 2c       	rsub	r12,r6
80005f74:	00 00       	add	r0,r0
80005f76:	0c 20       	rsub	r0,r6
80005f78:	00 00       	add	r0,r0
80005f7a:	0c 18       	sub	r8,r6
80005f7c:	00 00       	add	r0,r0
80005f7e:	0d 2c       	ld.uh	r12,r6++
80005f80:	00 00       	add	r0,r0
80005f82:	0d 4c       	ld.w	r12,--r6
80005f84:	80 00       	ld.sh	r0,r0[0x0]
80005f86:	4f 06       	lddpc	r6,80006144 <PrintDec+0xb6>
80005f88:	80 00       	ld.sh	r0,r0[0x0]
80005f8a:	51 1c       	stdsp	sp[0x44],r12

80005f8c <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
80005f8c:	d4 01       	pushm	lr
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
80005f8e:	30 09       	mov	r9,0
80005f90:	1a d9       	st.w	--sp,r9
80005f92:	1a d9       	st.w	--sp,r9
80005f94:	1a d9       	st.w	--sp,r9
80005f96:	12 98       	mov	r8,r9
80005f98:	e0 6a 01 00 	mov	r10,256
80005f9c:	48 9b       	lddpc	r11,80005fc0 <vTaskStartScheduler+0x34>
80005f9e:	48 ac       	lddpc	r12,80005fc4 <vTaskStartScheduler+0x38>
80005fa0:	f0 1f 00 0a 	mcall	80005fc8 <vTaskStartScheduler+0x3c>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
80005fa4:	2f dd       	sub	sp,-12
80005fa6:	58 1c       	cp.w	r12,1
80005fa8:	c0 a1       	brne	80005fbc <vTaskStartScheduler+0x30>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
80005faa:	d3 03       	ssrf	0x10

		xSchedulerRunning = pdTRUE;
80005fac:	30 19       	mov	r9,1
80005fae:	48 88       	lddpc	r8,80005fcc <vTaskStartScheduler+0x40>
80005fb0:	91 09       	st.w	r8[0x0],r9
		xTickCount = ( portTickType ) 0;
80005fb2:	30 09       	mov	r9,0
80005fb4:	48 78       	lddpc	r8,80005fd0 <vTaskStartScheduler+0x44>
80005fb6:	91 09       	st.w	r8[0x0],r9
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
80005fb8:	f0 1f 00 07 	mcall	80005fd4 <vTaskStartScheduler+0x48>
80005fbc:	d8 02       	popm	pc
80005fbe:	00 00       	add	r0,r0
80005fc0:	80 00       	ld.sh	r0,r0[0x0]
80005fc2:	ca 8c       	rcall	80006112 <PrintDec+0x84>
80005fc4:	80 00       	ld.sh	r0,r0[0x0]
80005fc6:	5d 1c       	icall	r12
80005fc8:	80 00       	ld.sh	r0,r0[0x0]
80005fca:	5d a4       	*unknown*
80005fcc:	00 00       	add	r0,r0
80005fce:	0c 20       	rsub	r0,r6
80005fd0:	00 00       	add	r0,r0
80005fd2:	0d 10       	ld.sh	r0,r6++
80005fd4:	80 00       	ld.sh	r0,r0[0x0]
80005fd6:	50 20       	stdsp	sp[0x8],r0

80005fd8 <PrintChar>:
	
static void task_log(void * pvParameters);

char *  PrintChar(char c, char * str)
{
	*str++ = c;
80005fd8:	16 cc       	st.b	r11++,r12
	return str;
}
80005fda:	5e fb       	retal	r11

80005fdc <PrintHex>:
	
	return str;
}

char * PrintHex(int i,char len, char * str)
{
80005fdc:	eb cd 40 c0 	pushm	r6-r7,lr
80005fe0:	20 3d       	sub	sp,12
80005fe2:	18 98       	mov	r8,r12
	char * p = str;
	char s[12];
	memset(s, 0 , 12);
80005fe4:	30 06       	mov	r6,0
80005fe6:	30 07       	mov	r7,0
80005fe8:	fa e7 00 00 	st.d	sp[0],r6
80005fec:	30 0c       	mov	r12,0
80005fee:	50 2c       	stdsp	sp[0x8],r12
	int cnt=0;
	
	if(i)
80005ff0:	58 08       	cp.w	r8,0
80005ff2:	c1 30       	breq	80006018 <PrintHex+0x3c>
80005ff4:	18 99       	mov	r9,r12
	while(i)
	{
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
80005ff6:	1a 9c       	mov	r12,sp
80005ff8:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80005ffc:	58 9e       	cp.w	lr,9
80005ffe:	e0 8a 00 04 	brle	80006006 <PrintHex+0x2a>
80006002:	2c 9e       	sub	lr,-55
80006004:	c0 48       	rjmp	8000600c <PrintHex+0x30>
80006006:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
8000600a:	2d 0e       	sub	lr,-48
8000600c:	f8 09 0b 0e 	st.b	r12[r9],lr
80006010:	2f f9       	sub	r9,-1
		i = (i >> 4 ) & 0x0FFFFFFF;
80006012:	a5 88       	lsr	r8,0x4
	char s[12];
	memset(s, 0 , 12);
	int cnt=0;
	
	if(i)
	while(i)
80006014:	cf 21       	brne	80005ff8 <PrintHex+0x1c>
80006016:	c0 48       	rjmp	8000601e <PrintHex+0x42>
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
		i = (i >> 4 ) & 0x0FFFFFFF;
		//i >>= 4
	}
	else
	s[cnt++] = '0';
80006018:	33 08       	mov	r8,48
8000601a:	ba 88       	st.b	sp[0x0],r8
8000601c:	30 19       	mov	r9,1
	
	if(len - cnt > 0 )
8000601e:	f6 09 01 08 	sub	r8,r11,r9
80006022:	58 08       	cp.w	r8,0
80006024:	e0 8a 00 13 	brle	8000604a <PrintHex+0x6e>
	{
		char num = len - cnt;
80006028:	12 1b       	sub	r11,r9
8000602a:	f9 db c0 08 	bfextu	r12,r11,0x0,0x8
		for(int i = 0; i < num; i++)
8000602e:	18 9e       	mov	lr,r12
80006030:	58 0c       	cp.w	r12,0
80006032:	e0 8a 00 0c 	brle	8000604a <PrintHex+0x6e>
80006036:	1a 9b       	mov	r11,sp
80006038:	12 0b       	add	r11,r9
8000603a:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
8000603c:	33 07       	mov	r7,48
8000603e:	16 c7       	st.b	r11++,r7
	s[cnt++] = '0';
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80006040:	2f f8       	sub	r8,-1
80006042:	1c 38       	cp.w	r8,lr
80006044:	cf d5       	brlt	8000603e <PrintHex+0x62>
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
80006046:	f8 09 00 09 	add	r9,r12,r9
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
8000604a:	f2 c8 ff ff 	sub	r8,r9,-1
	s[cnt++] = '0';
	
	while(cnt>0)
8000604e:	f0 cb ff ff 	sub	r11,r8,-1
80006052:	58 0b       	cp.w	r11,0
80006054:	e0 8a 00 19 	brle	80006086 <PrintHex+0xaa>
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80006058:	fa cb ff f4 	sub	r11,sp,-12
8000605c:	f6 09 00 09 	add	r9,r11,r9
80006060:	37 8b       	mov	r11,120
80006062:	f3 6b ff f4 	st.b	r9[-12],r11
	s[cnt++] = '0';
80006066:	fa c9 ff f4 	sub	r9,sp,-12
8000606a:	10 09       	add	r9,r8
8000606c:	33 0b       	mov	r11,48
8000606e:	f3 6b ff f4 	st.b	r9[-12],r11
80006072:	fa 08 00 08 	add	r8,sp,r8
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
80006076:	fa ce 00 01 	sub	lr,sp,1
8000607a:	14 99       	mov	r9,r10
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
	*p++ = s[--cnt];
8000607c:	11 8b       	ld.ub	r11,r8[0x0]
8000607e:	12 cb       	st.b	r9++,r11
80006080:	20 18       	sub	r8,1
	}
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
80006082:	1c 38       	cp.w	r8,lr
80006084:	cf c1       	brne	8000607c <PrintHex+0xa0>
	*p++ = s[--cnt];
		
	return str;
}
80006086:	14 9c       	mov	r12,r10
80006088:	2f dd       	sub	sp,-12
8000608a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

8000608e <PrintDec>:
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
{
8000608e:	d4 21       	pushm	r4-r7,lr
80006090:	20 3d       	sub	sp,12
80006092:	18 98       	mov	r8,r12
	char * p = str;
	
	int sign = i>=0 ? 0 : 1;
	char s[10];
	memset(s, 0 , 10);
80006094:	30 06       	mov	r6,0
80006096:	30 07       	mov	r7,0
80006098:	fa e7 00 00 	st.d	sp[0],r6
8000609c:	30 0c       	mov	r12,0
8000609e:	ba 4c       	st.h	sp[0x8],r12
	int cnt=0;
	if(sign)
800060a0:	58 08       	cp.w	r8,0
800060a2:	c0 35       	brlt	800060a8 <PrintDec+0x1a>
800060a4:	14 97       	mov	r7,r10
800060a6:	c0 58       	rjmp	800060b0 <PrintDec+0x22>
	{
		*p++ = '-';
800060a8:	14 97       	mov	r7,r10
800060aa:	32 d9       	mov	r9,45
800060ac:	0e c9       	st.b	r7++,r9
		i = -i;
800060ae:	5c 38       	neg	r8
	}
	
	if(i == 0 )s[cnt++] = '0';
800060b0:	58 08       	cp.w	r8,0
800060b2:	c0 51       	brne	800060bc <PrintDec+0x2e>
800060b4:	33 08       	mov	r8,48
800060b6:	ba 88       	st.b	sp[0x0],r8
800060b8:	30 1e       	mov	lr,1
800060ba:	c2 f8       	rjmp	80006118 <PrintDec+0x8a>
	
	int ten = i%10;
800060bc:	e0 65 66 67 	mov	r5,26215
800060c0:	ea 15 66 66 	orh	r5,0x6666
800060c4:	f0 05 04 44 	muls.d	r4,r8,r5
800060c8:	ea 0c 14 02 	asr	r12,r5,0x2
800060cc:	f0 09 14 1f 	asr	r9,r8,0x1f
800060d0:	f8 09 01 09 	sub	r9,r12,r9
800060d4:	f2 09 00 29 	add	r9,r9,r9<<0x2
800060d8:	f0 09 01 19 	sub	r9,r8,r9<<0x1
800060dc:	30 0e       	mov	lr,0
	while(i)
	{
		s[cnt] = ten+'0';
800060de:	1a 9c       	mov	r12,sp
		cnt++;
		i /= 10;
800060e0:	e0 66 66 67 	mov	r6,26215
800060e4:	ea 16 66 66 	orh	r6,0x6666
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
	{
		s[cnt] = ten+'0';
800060e8:	2d 09       	sub	r9,-48
800060ea:	f8 0e 0b 09 	st.b	r12[lr],r9
		cnt++;
800060ee:	2f fe       	sub	lr,-1
		i /= 10;
800060f0:	f0 06 04 44 	muls.d	r4,r8,r6
800060f4:	ea 09 14 02 	asr	r9,r5,0x2
800060f8:	bf 58       	asr	r8,0x1f
800060fa:	f2 08 01 08 	sub	r8,r9,r8
		ten = i%10;
800060fe:	f0 06 04 44 	muls.d	r4,r8,r6
80006102:	ea 09 14 02 	asr	r9,r5,0x2
80006106:	f0 05 14 1f 	asr	r5,r8,0x1f
8000610a:	0a 19       	sub	r9,r5
8000610c:	f2 09 00 29 	add	r9,r9,r9<<0x2
80006110:	f0 09 01 19 	sub	r9,r8,r9<<0x1
	}
	
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
80006114:	58 08       	cp.w	r8,0
80006116:	ce 91       	brne	800060e8 <PrintDec+0x5a>
		cnt++;
		i /= 10;
		ten = i%10;
	}
	
	if(len - cnt > 0 )
80006118:	f6 0e 01 08 	sub	r8,r11,lr
8000611c:	58 08       	cp.w	r8,0
8000611e:	e0 89 00 06 	brgt	8000612a <PrintDec+0x9c>
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80006122:	58 0e       	cp.w	lr,0
80006124:	e0 89 00 14 	brgt	8000614c <PrintDec+0xbe>
80006128:	c1 d8       	rjmp	80006162 <PrintDec+0xd4>
		ten = i%10;
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
8000612a:	1c 1b       	sub	r11,lr
8000612c:	5c 5b       	castu.b	r11
		for(int i = 0; i < num; i++)
8000612e:	16 9c       	mov	r12,r11
80006130:	58 0b       	cp.w	r11,0
80006132:	fe 9a ff f8 	brle	80006122 <PrintDec+0x94>
80006136:	1a 99       	mov	r9,sp
80006138:	1c 09       	add	r9,lr
8000613a:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
8000613c:	33 06       	mov	r6,48
8000613e:	12 c6       	st.b	r9++,r6
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80006140:	2f f8       	sub	r8,-1
80006142:	18 38       	cp.w	r8,r12
80006144:	cf d5       	brlt	8000613e <PrintDec+0xb0>
{
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
80006146:	f6 0e 00 0e 	add	lr,r11,lr
8000614a:	ce cb       	rjmp	80006122 <PrintDec+0x94>
8000614c:	fa c8 ff f4 	sub	r8,sp,-12
80006150:	1c 08       	add	r8,lr
80006152:	20 d8       	sub	r8,13
80006154:	fa cb 00 01 	sub	r11,sp,1
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
	*p++ = s[--cnt];
80006158:	11 89       	ld.ub	r9,r8[0x0]
8000615a:	0e c9       	st.b	r7++,r9
8000615c:	20 18       	sub	r8,1
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
8000615e:	16 38       	cp.w	r8,r11
80006160:	cf c1       	brne	80006158 <PrintDec+0xca>
	*p++ = s[--cnt];
	
	return str;
}
80006162:	14 9c       	mov	r12,r10
80006164:	2f dd       	sub	sp,-12
80006166:	d8 22       	popm	r4-r7,pc

80006168 <log>:
	,  NULL );
	
}

int log(char * content, ...)
{
80006168:	d4 31       	pushm	r0-r7,lr
8000616a:	fa cd 02 08 	sub	sp,sp,520
8000616e:	18 97       	mov	r7,r12
	
	
	char logTmp[MAX_LOG_LINE_SIZE];
	memset(logTmp, '\0', MAX_LOG_LINE_SIZE);	
80006170:	e0 6a 01 00 	mov	r10,256
80006174:	30 0b       	mov	r11,0
80006176:	fa cc fe f8 	sub	r12,sp,-264
8000617a:	f0 1f 00 4e 	mcall	800062b0 <log+0x148>
	,  tskLOG_PRIORITY
	,  NULL );
	
}

int log(char * content, ...)
8000617e:	fa c4 fd d4 	sub	r4,sp,-556
80006182:	30 0a       	mov	r10,0
80006184:	50 0a       	stdsp	sp[0x0],r10
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80006186:	fa c3 ff fc 	sub	r3,sp,-4
8000618a:	e0 61 01 00 	mov	r1,256
8000618e:	14 90       	mov	r0,r10
			
					if(*str == '%')
80006190:	32 52       	mov	r2,37
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
80006192:	fa c6 fe f8 	sub	r6,sp,-264
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80006196:	02 9a       	mov	r10,r1
80006198:	00 9b       	mov	r11,r0
8000619a:	06 9c       	mov	r12,r3
8000619c:	f0 1f 00 45 	mcall	800062b0 <log+0x148>
			
					if(*str == '%')
800061a0:	0f 88       	ld.ub	r8,r7[0x0]
800061a2:	e4 08 18 00 	cp.b	r8,r2
800061a6:	c5 71       	brne	80006254 <log+0xec>
					{
						static char lench = 0;
						lench =*(str + 1);
800061a8:	ee c8 ff ff 	sub	r8,r7,-1
800061ac:	11 89       	ld.ub	r9,r8[0x0]
800061ae:	4c 2a       	lddpc	r10,800062b4 <log+0x14c>
800061b0:	b4 89       	st.b	r10[0x0],r9
						if((lench >= '0') &&  (lench <= '9'))
800061b2:	23 09       	sub	r9,48
800061b4:	30 9a       	mov	r10,9
800061b6:	f4 09 18 00 	cp.b	r9,r10
800061ba:	ee 08 17 b0 	movhi	r8,r7
						{
							len = *(++str) - '0';
800061be:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
800061c2:	f7 b9 08 30 	subls	r9,48
800061c6:	fb f9 8a 00 	st.wls	sp[0x0],r9
						}
						
						str++;
800061ca:	f0 c7 ff ff 	sub	r7,r8,-1
						
						switch(*(str))
800061ce:	0f 88       	ld.ub	r8,r7[0x0]
800061d0:	22 58       	sub	r8,37
800061d2:	e0 48 00 53 	cp.w	r8,83
800061d6:	e0 8b 00 31 	brhi	80006238 <log+0xd0>
800061da:	4b 89       	lddpc	r9,800062b8 <log+0x150>
800061dc:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
						{
							case('i'):
							case('I'):
							case('d'):
							case('D'):
							x = va_arg(arg_ptr,int);
800061e0:	e8 c5 ff fc 	sub	r5,r4,-4
							strTmp = PrintDec(x, len, strTmp);
800061e4:	06 9a       	mov	r10,r3
800061e6:	40 0b       	lddsp	r11,sp[0x0]
800061e8:	5c 5b       	castu.b	r11
800061ea:	68 0c       	ld.w	r12,r4[0x0]
800061ec:	f0 1f 00 34 	mcall	800062bc <log+0x154>
							break;
800061f0:	c2 98       	rjmp	80006242 <log+0xda>
							
							case('f')://浮点数输出
							case('F'):
							//f = va_arg(arg_ptr,int);
							//strTmp = PrintDec(x, len, strTmp);
							log("I need float.");
800061f2:	4b 4c       	lddpc	r12,800062c0 <log+0x158>
800061f4:	f0 1f 00 34 	mcall	800062c4 <log+0x15c>
800061f8:	08 95       	mov	r5,r4
800061fa:	06 9c       	mov	r12,r3
							break;
800061fc:	c2 38       	rjmp	80006242 <log+0xda>
							
							
							case('x'):
							case('X'):
							x = va_arg(arg_ptr,int);
800061fe:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintHex(x,len, strTmp);
80006202:	06 9a       	mov	r10,r3
80006204:	40 0b       	lddsp	r11,sp[0x0]
80006206:	5c 5b       	castu.b	r11
80006208:	68 0c       	ld.w	r12,r4[0x0]
8000620a:	f0 1f 00 30 	mcall	800062c8 <log+0x160>
8000620e:	06 9c       	mov	r12,r3
							break;
80006210:	c1 98       	rjmp	80006242 <log+0xda>
							
							case('c'):
							case('C'):
							y = va_arg(arg_ptr,int);
80006212:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintChar(y, strTmp);
80006216:	06 9b       	mov	r11,r3
80006218:	09 bc       	ld.ub	r12,r4[0x3]
8000621a:	f0 1f 00 2d 	mcall	800062cc <log+0x164>
8000621e:	06 9c       	mov	r12,r3
							break;
80006220:	c1 18       	rjmp	80006242 <log+0xda>
							
							case('s'):
							case('S'):
							strTmp = va_arg(arg_ptr,char*);
80006222:	e8 c5 ff fc 	sub	r5,r4,-4
80006226:	68 0c       	ld.w	r12,r4[0x0]
							//PrintStr(s);
							break;
80006228:	c0 d8       	rjmp	80006242 <log+0xda>
							
							case('%'):
							PrintChar('%', strTmp);
8000622a:	06 9b       	mov	r11,r3
8000622c:	32 5c       	mov	r12,37
8000622e:	f0 1f 00 28 	mcall	800062cc <log+0x164>
80006232:	08 95       	mov	r5,r4
80006234:	06 9c       	mov	r12,r3
							//PrintChar('%');
							break;
80006236:	c0 68       	rjmp	80006242 <log+0xda>
							
							default:
							log("I need relax.");
80006238:	4a 6c       	lddpc	r12,800062d0 <log+0x168>
8000623a:	f0 1f 00 23 	mcall	800062c4 <log+0x15c>
8000623e:	08 95       	mov	r5,r4
80006240:	06 9c       	mov	r12,r3
						}
						str++;
80006242:	2f f7       	sub	r7,-1
						
						length = sprintf(logTmp,"%s%s",logTmp,strTmp );
80006244:	1a dc       	st.w	--sp,r12
80006246:	1a d6       	st.w	--sp,r6
80006248:	4a 3b       	lddpc	r11,800062d4 <log+0x16c>
8000624a:	0c 9c       	mov	r12,r6
8000624c:	f0 1f 00 23 	mcall	800062d8 <log+0x170>
80006250:	2f ed       	sub	sp,-8
80006252:	c0 a8       	rjmp	80006266 <log+0xfe>
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
80006254:	2f f7       	sub	r7,-1
80006256:	1a d8       	st.w	--sp,r8
80006258:	1a d6       	st.w	--sp,r6
8000625a:	4a 1b       	lddpc	r11,800062dc <log+0x174>
8000625c:	0c 9c       	mov	r12,r6
8000625e:	f0 1f 00 1f 	mcall	800062d8 <log+0x170>
80006262:	08 95       	mov	r5,r4
80006264:	2f ed       	sub	sp,-8
			
			
			
	}while(*str != '\0');
80006266:	0f 89       	ld.ub	r9,r7[0x0]
80006268:	30 08       	mov	r8,0
8000626a:	f0 09 18 00 	cp.b	r9,r8
8000626e:	c0 30       	breq	80006274 <log+0x10c>
80006270:	0a 94       	mov	r4,r5
80006272:	c9 2b       	rjmp	80006196 <log+0x2e>
		
		
				
	va_end(arg_ptr);
	//while(1)		
	length = sprintf(logTmp,"%s\r\n",logTmp);
80006274:	fa c7 fe f8 	sub	r7,sp,-264
80006278:	1a d7       	st.w	--sp,r7
8000627a:	49 ab       	lddpc	r11,800062e0 <log+0x178>
8000627c:	0e 9c       	mov	r12,r7
8000627e:	f0 1f 00 17 	mcall	800062d8 <log+0x170>
	
	char * p = pvPortMalloc(length+1);
80006282:	5c 5c       	castu.b	r12
80006284:	f8 c6 ff ff 	sub	r6,r12,-1
80006288:	0c 9c       	mov	r12,r6
8000628a:	f0 1f 00 17 	mcall	800062e4 <log+0x17c>
8000628e:	54 2c       	stdsp	sp[0x108],r12
	memcpy(p, logTmp, length+1);
80006290:	0c 9a       	mov	r10,r6
80006292:	0e 9b       	mov	r11,r7
80006294:	f0 1f 00 15 	mcall	800062e8 <log+0x180>
	//
	//usart_write_line(EXAMPLE_USART, logTmp)
	
	xQueueSend( logQueue, &p, 5);
80006298:	30 09       	mov	r9,0
8000629a:	30 5a       	mov	r10,5
8000629c:	fa cb fe f8 	sub	r11,sp,-264
800062a0:	49 38       	lddpc	r8,800062ec <log+0x184>
800062a2:	70 0c       	ld.w	r12,r8[0x0]
800062a4:	f0 1f 00 13 	mcall	800062f0 <log+0x188>
800062a8:	2f fd       	sub	sp,-4
	
	
}
800062aa:	fe 3d fd f8 	sub	sp,-520
800062ae:	d8 32       	popm	r0-r7,pc
800062b0:	80 00       	ld.sh	r0,r0[0x0]
800062b2:	6b 3c       	ld.w	r12,r5[0x4c]
800062b4:	00 00       	add	r0,r0
800062b6:	0d 50       	ld.sh	r0,--r6
800062b8:	80 00       	ld.sh	r0,r0[0x0]
800062ba:	ca 94       	brge	8000620c <log+0xa4>
800062bc:	80 00       	ld.sh	r0,r0[0x0]
800062be:	60 8e       	ld.w	lr,r0[0x20]
800062c0:	80 00       	ld.sh	r0,r0[0x0]
800062c2:	cd 40       	breq	8000626a <log+0x102>
800062c4:	80 00       	ld.sh	r0,r0[0x0]
800062c6:	61 68       	ld.w	r8,r0[0x58]
800062c8:	80 00       	ld.sh	r0,r0[0x0]
800062ca:	5f dc       	srvc	r12
800062cc:	80 00       	ld.sh	r0,r0[0x0]
800062ce:	5f d8       	srvc	r8
800062d0:	80 00       	ld.sh	r0,r0[0x0]
800062d2:	cd 50       	breq	8000627c <log+0x114>
800062d4:	80 00       	ld.sh	r0,r0[0x0]
800062d6:	cd 60       	breq	80006282 <log+0x11a>
800062d8:	80 00       	ld.sh	r0,r0[0x0]
800062da:	6e 2c       	ld.w	r12,r7[0x8]
800062dc:	80 00       	ld.sh	r0,r0[0x0]
800062de:	cd 68       	rjmp	8000648a <log_init+0x16>
800062e0:	80 00       	ld.sh	r0,r0[0x0]
800062e2:	cd 70       	breq	80006290 <log+0x128>
800062e4:	80 00       	ld.sh	r0,r0[0x0]
800062e6:	52 7c       	stdsp	sp[0x9c],r12
800062e8:	80 00       	ld.sh	r0,r0[0x0]
800062ea:	69 f4       	ld.w	r4,r4[0x7c]
800062ec:	00 00       	add	r0,r0
800062ee:	41 08       	lddsp	r8,sp[0x40]
800062f0:	80 00       	ld.sh	r0,r0[0x0]
800062f2:	55 d0       	stdsp	sp[0x174],r0

800062f4 <logFromISR>:
	
	
int logFromISR(char * content, ...)
	{
800062f4:	d4 31       	pushm	r0-r7,lr
800062f6:	fa cd 02 0c 	sub	sp,sp,524
800062fa:	18 97       	mov	r7,r12
		
		
		char logTmp[MAX_LOG_LINE_SIZE];
		memset(logTmp, '\0', MAX_LOG_LINE_SIZE);
800062fc:	e0 6a 01 00 	mov	r10,256
80006300:	30 0b       	mov	r11,0
80006302:	fa cc fe f4 	sub	r12,sp,-268
80006306:	f0 1f 00 4c 	mcall	80006434 <logFromISR+0x140>
	
	
}
	
	
int logFromISR(char * content, ...)
8000630a:	fa c4 fd d0 	sub	r4,sp,-560
8000630e:	30 0a       	mov	r10,0
80006310:	50 0a       	stdsp	sp[0x0],r10
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80006312:	fa c3 ff fc 	sub	r3,sp,-4
80006316:	e0 61 01 00 	mov	r1,256
8000631a:	14 90       	mov	r0,r10
			
			if(*str == '%')
8000631c:	32 52       	mov	r2,37
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
8000631e:	fa c6 fe f4 	sub	r6,sp,-268
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80006322:	02 9a       	mov	r10,r1
80006324:	00 9b       	mov	r11,r0
80006326:	06 9c       	mov	r12,r3
80006328:	f0 1f 00 43 	mcall	80006434 <logFromISR+0x140>
			
			if(*str == '%')
8000632c:	0f 88       	ld.ub	r8,r7[0x0]
8000632e:	e4 08 18 00 	cp.b	r8,r2
80006332:	c5 11       	brne	800063d4 <logFromISR+0xe0>
			{
				static char lench = 0;
				lench =*(str + 1);
80006334:	ee c8 ff ff 	sub	r8,r7,-1
80006338:	11 89       	ld.ub	r9,r8[0x0]
8000633a:	4c 0a       	lddpc	r10,80006438 <logFromISR+0x144>
8000633c:	b4 89       	st.b	r10[0x0],r9
				if((lench >= '0') &&  (lench <= '9'))
8000633e:	23 09       	sub	r9,48
80006340:	30 9a       	mov	r10,9
80006342:	f4 09 18 00 	cp.b	r9,r10
80006346:	ee 08 17 b0 	movhi	r8,r7
				{
					len = *(++str) - '0';
8000634a:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
8000634e:	f7 b9 08 30 	subls	r9,48
80006352:	fb f9 8a 00 	st.wls	sp[0x0],r9
				}
				
				str++;
80006356:	f0 c7 ff ff 	sub	r7,r8,-1
				
				switch(*(str))
8000635a:	0f 88       	ld.ub	r8,r7[0x0]
8000635c:	22 58       	sub	r8,37
8000635e:	e0 48 00 53 	cp.w	r8,83
80006362:	e0 8b 00 2b 	brhi	800063b8 <logFromISR+0xc4>
80006366:	4b 69       	lddpc	r9,8000643c <logFromISR+0x148>
80006368:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
				{
					case('d'):
					case('D'):
					x = va_arg(arg_ptr,int);
8000636c:	e8 c5 ff fc 	sub	r5,r4,-4
					strTmp = PrintDec(x, len, strTmp);
80006370:	06 9a       	mov	r10,r3
80006372:	40 0b       	lddsp	r11,sp[0x0]
80006374:	5c 5b       	castu.b	r11
80006376:	68 0c       	ld.w	r12,r4[0x0]
80006378:	f0 1f 00 32 	mcall	80006440 <logFromISR+0x14c>
					break;
8000637c:	c2 38       	rjmp	800063c2 <logFromISR+0xce>
					case('x'):
					case('X'):
					x = va_arg(arg_ptr,int);
8000637e:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintHex(x,len, strTmp);
80006382:	06 9a       	mov	r10,r3
80006384:	40 0b       	lddsp	r11,sp[0x0]
80006386:	5c 5b       	castu.b	r11
80006388:	68 0c       	ld.w	r12,r4[0x0]
8000638a:	f0 1f 00 2f 	mcall	80006444 <logFromISR+0x150>
8000638e:	06 9c       	mov	r12,r3
					break;
80006390:	c1 98       	rjmp	800063c2 <logFromISR+0xce>
					case('c'):
					case('C'):
					y = va_arg(arg_ptr,int);
80006392:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintChar(y, strTmp);
80006396:	06 9b       	mov	r11,r3
80006398:	09 bc       	ld.ub	r12,r4[0x3]
8000639a:	f0 1f 00 2c 	mcall	80006448 <logFromISR+0x154>
8000639e:	06 9c       	mov	r12,r3
					break;
800063a0:	c1 18       	rjmp	800063c2 <logFromISR+0xce>
					case('s'):
					case('S'):
					strTmp = va_arg(arg_ptr,char*);
800063a2:	e8 c5 ff fc 	sub	r5,r4,-4
800063a6:	68 0c       	ld.w	r12,r4[0x0]
					//PrintStr(s);
					break;
800063a8:	c0 d8       	rjmp	800063c2 <logFromISR+0xce>
					case('%'):
					PrintChar('%', strTmp);
800063aa:	06 9b       	mov	r11,r3
800063ac:	32 5c       	mov	r12,37
800063ae:	f0 1f 00 27 	mcall	80006448 <logFromISR+0x154>
800063b2:	08 95       	mov	r5,r4
800063b4:	06 9c       	mov	r12,r3
					//PrintChar('%');
					break;
800063b6:	c0 68       	rjmp	800063c2 <logFromISR+0xce>
					default:
					log("I need relax.");
800063b8:	4a 5c       	lddpc	r12,8000644c <logFromISR+0x158>
800063ba:	f0 1f 00 26 	mcall	80006450 <logFromISR+0x15c>
800063be:	08 95       	mov	r5,r4
800063c0:	06 9c       	mov	r12,r3
				}
				str++;
800063c2:	2f f7       	sub	r7,-1
				
				length = sprintf(logTmp,"%s%s",logTmp,strTmp );
800063c4:	1a dc       	st.w	--sp,r12
800063c6:	1a d6       	st.w	--sp,r6
800063c8:	4a 3b       	lddpc	r11,80006454 <logFromISR+0x160>
800063ca:	0c 9c       	mov	r12,r6
800063cc:	f0 1f 00 23 	mcall	80006458 <logFromISR+0x164>
800063d0:	2f ed       	sub	sp,-8
800063d2:	c0 a8       	rjmp	800063e6 <logFromISR+0xf2>
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
800063d4:	2f f7       	sub	r7,-1
800063d6:	1a d8       	st.w	--sp,r8
800063d8:	1a d6       	st.w	--sp,r6
800063da:	4a 1b       	lddpc	r11,8000645c <logFromISR+0x168>
800063dc:	0c 9c       	mov	r12,r6
800063de:	f0 1f 00 1f 	mcall	80006458 <logFromISR+0x164>
800063e2:	08 95       	mov	r5,r4
800063e4:	2f ed       	sub	sp,-8
			
			
			
		}while(*str != '\0');
800063e6:	0f 89       	ld.ub	r9,r7[0x0]
800063e8:	30 08       	mov	r8,0
800063ea:	f0 09 18 00 	cp.b	r9,r8
800063ee:	c0 30       	breq	800063f4 <logFromISR+0x100>
800063f0:	0a 94       	mov	r4,r5
800063f2:	c9 8b       	rjmp	80006322 <logFromISR+0x2e>
		
		
		
		va_end(arg_ptr);
		//while(1)
		length = sprintf(logTmp,"%s\r\n",logTmp);
800063f4:	fa c7 fe f4 	sub	r7,sp,-268
800063f8:	1a d7       	st.w	--sp,r7
800063fa:	49 ab       	lddpc	r11,80006460 <logFromISR+0x16c>
800063fc:	0e 9c       	mov	r12,r7
800063fe:	f0 1f 00 17 	mcall	80006458 <logFromISR+0x164>
		
		char * p = pvPortMalloc(length+1);
80006402:	5c 5c       	castu.b	r12
80006404:	f8 c6 ff ff 	sub	r6,r12,-1
80006408:	0c 9c       	mov	r12,r6
8000640a:	f0 1f 00 17 	mcall	80006464 <logFromISR+0x170>
8000640e:	54 3c       	stdsp	sp[0x10c],r12
		memcpy(p, logTmp, length+1);
80006410:	0c 9a       	mov	r10,r6
80006412:	0e 9b       	mov	r11,r7
80006414:	f0 1f 00 15 	mcall	80006468 <logFromISR+0x174>
		//
		portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80006418:	30 09       	mov	r9,0
8000641a:	54 29       	stdsp	sp[0x108],r9
		
		//usart_write_line(EXAMPLE_USART, p);
		//vPortFree(p);
		xQueueSendFromISR( logQueue, &p, &xHigherPriorityTaskWoken );
8000641c:	fa ca fe f8 	sub	r10,sp,-264
80006420:	fa cb fe f4 	sub	r11,sp,-268
80006424:	49 28       	lddpc	r8,8000646c <logFromISR+0x178>
80006426:	70 0c       	ld.w	r12,r8[0x0]
80006428:	f0 1f 00 12 	mcall	80006470 <logFromISR+0x17c>
8000642c:	2f fd       	sub	sp,-4
		
		//if (xHigherPriorityTaskWoken == pdTRUE)
		//{
			////taskYIELD();
		//}
	}
8000642e:	fe 3d fd f4 	sub	sp,-524
80006432:	d8 32       	popm	r0-r7,pc
80006434:	80 00       	ld.sh	r0,r0[0x0]
80006436:	6b 3c       	ld.w	r12,r5[0x4c]
80006438:	00 00       	add	r0,r0
8000643a:	0d 51       	ld.sh	r1,--r6
8000643c:	80 00       	ld.sh	r0,r0[0x0]
8000643e:	cb e4       	brge	800063ba <logFromISR+0xc6>
80006440:	80 00       	ld.sh	r0,r0[0x0]
80006442:	60 8e       	ld.w	lr,r0[0x20]
80006444:	80 00       	ld.sh	r0,r0[0x0]
80006446:	5f dc       	srvc	r12
80006448:	80 00       	ld.sh	r0,r0[0x0]
8000644a:	5f d8       	srvc	r8
8000644c:	80 00       	ld.sh	r0,r0[0x0]
8000644e:	cd 50       	breq	800063f8 <logFromISR+0x104>
80006450:	80 00       	ld.sh	r0,r0[0x0]
80006452:	61 68       	ld.w	r8,r0[0x58]
80006454:	80 00       	ld.sh	r0,r0[0x0]
80006456:	cd 60       	breq	80006402 <logFromISR+0x10e>
80006458:	80 00       	ld.sh	r0,r0[0x0]
8000645a:	6e 2c       	ld.w	r12,r7[0x8]
8000645c:	80 00       	ld.sh	r0,r0[0x0]
8000645e:	cd 68       	rjmp	8000660a <_malloc_r+0x4e>
80006460:	80 00       	ld.sh	r0,r0[0x0]
80006462:	cd 70       	breq	80006410 <logFromISR+0x11c>
80006464:	80 00       	ld.sh	r0,r0[0x0]
80006466:	52 7c       	stdsp	sp[0x9c],r12
80006468:	80 00       	ld.sh	r0,r0[0x0]
8000646a:	69 f4       	ld.w	r4,r4[0x7c]
8000646c:	00 00       	add	r0,r0
8000646e:	41 08       	lddsp	r8,sp[0x40]
80006470:	80 00       	ld.sh	r0,r0[0x0]
80006472:	55 80       	stdsp	sp[0x160],r0

80006474 <log_init>:
		
	return str;
}

void log_init(void)
{
80006474:	d4 01       	pushm	lr
		.stopbits     = USART_1_STOPBIT,
		.channelmode  = USART_NORMAL_CHMODE
	};

	// Assign GPIO to USART.
	gpio_enable_module(USART_GPIO_MAP,
80006476:	30 2b       	mov	r11,2
80006478:	49 0c       	lddpc	r12,800064b8 <log_init+0x44>
8000647a:	f0 1f 00 11 	mcall	800064bc <log_init+0x48>
	sizeof(USART_GPIO_MAP) / sizeof(USART_GPIO_MAP[0]));

	// Initialize USART in RS232 mode.
	usart_init_rs232(EXAMPLE_USART, &USART_OPTIONS, EXAMPLE_TARGET_PBACLK_FREQ_HZ);			
8000647e:	e0 6a 36 00 	mov	r10,13824
80006482:	ea 1a 01 6e 	orh	r10,0x16e
80006486:	48 fb       	lddpc	r11,800064c0 <log_init+0x4c>
80006488:	fe 7c 18 00 	mov	r12,-59392
8000648c:	f0 1f 00 0e 	mcall	800064c4 <log_init+0x50>
			
	logQueue  = xQueueCreate(50, sizeof(char *));
80006490:	30 4b       	mov	r11,4
80006492:	33 2c       	mov	r12,50
80006494:	f0 1f 00 0d 	mcall	800064c8 <log_init+0x54>
80006498:	48 d8       	lddpc	r8,800064cc <log_init+0x58>
8000649a:	91 0c       	st.w	r8[0x0],r12
	
	xTaskCreate(
8000649c:	30 09       	mov	r9,0
8000649e:	1a d9       	st.w	--sp,r9
800064a0:	1a d9       	st.w	--sp,r9
800064a2:	1a d9       	st.w	--sp,r9
800064a4:	30 28       	mov	r8,2
800064a6:	e0 6a 01 80 	mov	r10,384
800064aa:	48 ab       	lddpc	r11,800064d0 <log_init+0x5c>
800064ac:	48 ac       	lddpc	r12,800064d4 <log_init+0x60>
800064ae:	f0 1f 00 0b 	mcall	800064d8 <log_init+0x64>
800064b2:	2f dd       	sub	sp,-12
	,  384
	,  NULL
	,  tskLOG_PRIORITY
	,  NULL );
	
}
800064b4:	d8 02       	popm	pc
800064b6:	00 00       	add	r0,r0
800064b8:	80 00       	ld.sh	r0,r0[0x0]
800064ba:	cd 7c       	rcall	80006668 <_malloc_r+0xac>
800064bc:	80 00       	ld.sh	r0,r0[0x0]
800064be:	4b 64       	lddpc	r4,80006594 <main+0x74>
800064c0:	80 00       	ld.sh	r0,r0[0x0]
800064c2:	cd 34       	brge	80006468 <logFromISR+0x174>
800064c4:	80 00       	ld.sh	r0,r0[0x0]
800064c6:	4d e0       	lddpc	r0,8000663c <_malloc_r+0x80>
800064c8:	80 00       	ld.sh	r0,r0[0x0]
800064ca:	56 d0       	stdsp	sp[0x1b4],r0
800064cc:	00 00       	add	r0,r0
800064ce:	41 08       	lddsp	r8,sp[0x40]
800064d0:	80 00       	ld.sh	r0,r0[0x0]
800064d2:	cd 78       	rjmp	80006680 <_malloc_r+0xc4>
800064d4:	80 00       	ld.sh	r0,r0[0x0]
800064d6:	64 dc       	ld.w	r12,r2[0x34]
800064d8:	80 00       	ld.sh	r0,r0[0x0]
800064da:	5d a4       	*unknown*

800064dc <task_log>:
			////taskYIELD();
		//}
	}
	
static void task_log(void * pvParameters)
{
800064dc:	eb cd 40 f8 	pushm	r3-r7,lr
800064e0:	20 1d       	sub	sp,4
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
800064e2:	48 c7       	lddpc	r7,80006510 <task_log+0x34>
800064e4:	30 05       	mov	r5,0
800064e6:	3f f4       	mov	r4,-1
		{
			if( NULL != str)
			{
				usart_write_line(EXAMPLE_USART, str);
800064e8:	fe 73 18 00 	mov	r3,-59392
{
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
800064ec:	0a 99       	mov	r9,r5
800064ee:	08 9a       	mov	r10,r4
800064f0:	1a 9b       	mov	r11,sp
800064f2:	6e 0c       	ld.w	r12,r7[0x0]
800064f4:	f0 1f 00 08 	mcall	80006514 <task_log+0x38>
800064f8:	58 1c       	cp.w	r12,1
800064fa:	cf 91       	brne	800064ec <task_log+0x10>
		{
			if( NULL != str)
800064fc:	40 0b       	lddsp	r11,sp[0x0]
800064fe:	58 0b       	cp.w	r11,0
80006500:	cf 60       	breq	800064ec <task_log+0x10>
			{
				usart_write_line(EXAMPLE_USART, str);
80006502:	06 9c       	mov	r12,r3
80006504:	f0 1f 00 05 	mcall	80006518 <task_log+0x3c>
				vPortFree(str);
80006508:	40 0c       	lddsp	r12,sp[0x0]
8000650a:	f0 1f 00 05 	mcall	8000651c <task_log+0x40>
8000650e:	ce fb       	rjmp	800064ec <task_log+0x10>
80006510:	00 00       	add	r0,r0
80006512:	41 08       	lddsp	r8,sp[0x40]
80006514:	80 00       	ld.sh	r0,r0[0x0]
80006516:	53 c4       	stdsp	sp[0xf0],r4
80006518:	80 00       	ld.sh	r0,r0[0x0]
8000651a:	4d 90       	lddpc	r0,8000667c <_malloc_r+0xc0>
8000651c:	80 00       	ld.sh	r0,r0[0x0]
8000651e:	52 54       	stdsp	sp[0x94],r4

80006520 <main>:
#include "voice.h"
#include "app.h"


int main (void)
{
80006520:	d4 01       	pushm	lr
	
	//Force SSC_TX_DATA_ENABLE Disabled as soon as possible.
	AVR32_GPIO.port[1].ovrs  =  0x00000001;  //Value will be high.
80006522:	fe 78 10 00 	mov	r8,-61440
80006526:	30 19       	mov	r9,1
80006528:	f1 49 01 54 	st.w	r8[340],r9
	AVR32_GPIO.port[1].oders =  0x00000001;  //Output Driver will be Enabled.
8000652c:	f1 49 01 44 	st.w	r8[324],r9
	AVR32_GPIO.port[1].gpers =  0x00000001;  //Enable as GPIO.
80006530:	f1 49 01 04 	st.w	r8[260],r9
		
	Disable_global_interrupt();
80006534:	d3 03       	ssrf	0x10
	local_start_pll0();
80006536:	f0 1f 00 11 	mcall	80006578 <main+0x58>
		
	INTC_init_interrupts();
8000653a:	f0 1f 00 11 	mcall	8000657c <main+0x5c>
		
	log_init();
8000653e:	f0 1f 00 11 	mcall	80006580 <main+0x60>
	log("----start debug----");
80006542:	49 1c       	lddpc	r12,80006584 <main+0x64>
80006544:	f0 1f 00 11 	mcall	80006588 <main+0x68>
		
	//voc_init();

	//tc_init();
		
	app_init();
80006548:	f0 1f 00 11 	mcall	8000658c <main+0x6c>
		
	xcmp_init();
8000654c:	f0 1f 00 11 	mcall	80006590 <main+0x70>
		
	while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
80006550:	fe 79 10 00 	mov	r9,-61440
80006554:	f2 f8 01 60 	ld.w	r8,r9[352]
80006558:	e2 18 00 02 	andl	r8,0x2,COH
8000655c:	cf c0       	breq	80006554 <main+0x34>
	while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
8000655e:	fe 79 10 00 	mov	r9,-61440
80006562:	f2 f8 01 60 	ld.w	r8,r9[352]
80006566:	e2 18 00 02 	andl	r8,0x2,COH
8000656a:	cf c1       	brne	80006562 <main+0x42>
	local_start_timer();
8000656c:	f0 1f 00 0a 	mcall	80006594 <main+0x74>
		
	Enable_global_interrupt();
80006570:	d5 03       	csrf	0x10
		
	vTaskStartScheduler();
80006572:	f0 1f 00 0a 	mcall	80006598 <main+0x78>
	return 0;
	
}
80006576:	d8 0a       	popm	pc,r12=0
80006578:	80 00       	ld.sh	r0,r0[0x0]
8000657a:	4a 88       	lddpc	r8,80006618 <_malloc_r+0x5c>
8000657c:	80 00       	ld.sh	r0,r0[0x0]
8000657e:	4c 18       	lddpc	r8,80006680 <_malloc_r+0xc4>
80006580:	80 00       	ld.sh	r0,r0[0x0]
80006582:	64 74       	ld.w	r4,r2[0x1c]
80006584:	80 00       	ld.sh	r0,r0[0x0]
80006586:	cd 8c       	rcall	80006736 <_malloc_r+0x17a>
80006588:	80 00       	ld.sh	r0,r0[0x0]
8000658a:	61 68       	ld.w	r8,r0[0x58]
8000658c:	80 00       	ld.sh	r0,r0[0x0]
8000658e:	20 3c       	sub	r12,3
80006590:	80 00       	ld.sh	r0,r0[0x0]
80006592:	43 0c       	lddsp	r12,sp[0xc0]
80006594:	80 00       	ld.sh	r0,r0[0x0]
80006596:	4a d8       	lddpc	r8,80006648 <_malloc_r+0x8c>
80006598:	80 00       	ld.sh	r0,r0[0x0]
8000659a:	5f 8c       	srls	r12

8000659c <free>:
8000659c:	d4 01       	pushm	lr
8000659e:	e0 68 0a 40 	mov	r8,2624
800065a2:	18 9b       	mov	r11,r12
800065a4:	70 0c       	ld.w	r12,r8[0x0]
800065a6:	e0 a0 1e 61 	rcall	8000a268 <_free_r>
800065aa:	d8 02       	popm	pc

800065ac <malloc>:
800065ac:	d4 01       	pushm	lr
800065ae:	e0 68 0a 40 	mov	r8,2624
800065b2:	18 9b       	mov	r11,r12
800065b4:	70 0c       	ld.w	r12,r8[0x0]
800065b6:	c0 3c       	rcall	800065bc <_malloc_r>
800065b8:	d8 02       	popm	pc
800065ba:	d7 03       	nop

800065bc <_malloc_r>:
800065bc:	d4 31       	pushm	r0-r7,lr
800065be:	f6 c8 ff f5 	sub	r8,r11,-11
800065c2:	18 95       	mov	r5,r12
800065c4:	10 97       	mov	r7,r8
800065c6:	e0 17 ff f8 	andl	r7,0xfff8
800065ca:	59 68       	cp.w	r8,22
800065cc:	f9 b7 08 10 	movls	r7,16
800065d0:	16 37       	cp.w	r7,r11
800065d2:	5f 38       	srlo	r8
800065d4:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
800065d8:	c0 50       	breq	800065e2 <_malloc_r+0x26>
800065da:	30 c8       	mov	r8,12
800065dc:	99 38       	st.w	r12[0xc],r8
800065de:	e0 8f 01 fa 	bral	800069d2 <_malloc_r+0x416>
800065e2:	fe b0 f5 ef 	rcall	800051c0 <__malloc_lock>
800065e6:	e0 47 01 f7 	cp.w	r7,503
800065ea:	e0 8b 00 1d 	brhi	80006624 <_malloc_r+0x68>
800065ee:	ee 03 16 03 	lsr	r3,r7,0x3
800065f2:	e0 68 05 40 	mov	r8,1344
800065f6:	f0 03 00 38 	add	r8,r8,r3<<0x3
800065fa:	70 36       	ld.w	r6,r8[0xc]
800065fc:	10 36       	cp.w	r6,r8
800065fe:	c0 61       	brne	8000660a <_malloc_r+0x4e>
80006600:	ec c8 ff f8 	sub	r8,r6,-8
80006604:	70 36       	ld.w	r6,r8[0xc]
80006606:	10 36       	cp.w	r6,r8
80006608:	c0 c0       	breq	80006620 <_malloc_r+0x64>
8000660a:	6c 18       	ld.w	r8,r6[0x4]
8000660c:	e0 18 ff fc 	andl	r8,0xfffc
80006610:	6c 3a       	ld.w	r10,r6[0xc]
80006612:	ec 08 00 09 	add	r9,r6,r8
80006616:	0a 9c       	mov	r12,r5
80006618:	6c 28       	ld.w	r8,r6[0x8]
8000661a:	95 28       	st.w	r10[0x8],r8
8000661c:	91 3a       	st.w	r8[0xc],r10
8000661e:	c4 78       	rjmp	800066ac <_malloc_r+0xf0>
80006620:	2f e3       	sub	r3,-2
80006622:	c4 d8       	rjmp	800066bc <_malloc_r+0x100>
80006624:	ee 03 16 09 	lsr	r3,r7,0x9
80006628:	c0 41       	brne	80006630 <_malloc_r+0x74>
8000662a:	ee 03 16 03 	lsr	r3,r7,0x3
8000662e:	c2 68       	rjmp	8000667a <_malloc_r+0xbe>
80006630:	58 43       	cp.w	r3,4
80006632:	e0 8b 00 06 	brhi	8000663e <_malloc_r+0x82>
80006636:	ee 03 16 06 	lsr	r3,r7,0x6
8000663a:	2c 83       	sub	r3,-56
8000663c:	c1 f8       	rjmp	8000667a <_malloc_r+0xbe>
8000663e:	59 43       	cp.w	r3,20
80006640:	e0 8b 00 04 	brhi	80006648 <_malloc_r+0x8c>
80006644:	2a 53       	sub	r3,-91
80006646:	c1 a8       	rjmp	8000667a <_malloc_r+0xbe>
80006648:	e0 43 00 54 	cp.w	r3,84
8000664c:	e0 8b 00 06 	brhi	80006658 <_malloc_r+0x9c>
80006650:	ee 03 16 0c 	lsr	r3,r7,0xc
80006654:	29 23       	sub	r3,-110
80006656:	c1 28       	rjmp	8000667a <_malloc_r+0xbe>
80006658:	e0 43 01 54 	cp.w	r3,340
8000665c:	e0 8b 00 06 	brhi	80006668 <_malloc_r+0xac>
80006660:	ee 03 16 0f 	lsr	r3,r7,0xf
80006664:	28 93       	sub	r3,-119
80006666:	c0 a8       	rjmp	8000667a <_malloc_r+0xbe>
80006668:	e0 43 05 54 	cp.w	r3,1364
8000666c:	e0 88 00 04 	brls	80006674 <_malloc_r+0xb8>
80006670:	37 e3       	mov	r3,126
80006672:	c0 48       	rjmp	8000667a <_malloc_r+0xbe>
80006674:	ee 03 16 12 	lsr	r3,r7,0x12
80006678:	28 43       	sub	r3,-124
8000667a:	e0 6a 05 40 	mov	r10,1344
8000667e:	f4 03 00 3a 	add	r10,r10,r3<<0x3
80006682:	74 36       	ld.w	r6,r10[0xc]
80006684:	c1 98       	rjmp	800066b6 <_malloc_r+0xfa>
80006686:	6c 19       	ld.w	r9,r6[0x4]
80006688:	e0 19 ff fc 	andl	r9,0xfffc
8000668c:	f2 07 01 0b 	sub	r11,r9,r7
80006690:	58 fb       	cp.w	r11,15
80006692:	e0 8a 00 04 	brle	8000669a <_malloc_r+0xde>
80006696:	20 13       	sub	r3,1
80006698:	c1 18       	rjmp	800066ba <_malloc_r+0xfe>
8000669a:	6c 38       	ld.w	r8,r6[0xc]
8000669c:	58 0b       	cp.w	r11,0
8000669e:	c0 b5       	brlt	800066b4 <_malloc_r+0xf8>
800066a0:	6c 2a       	ld.w	r10,r6[0x8]
800066a2:	ec 09 00 09 	add	r9,r6,r9
800066a6:	0a 9c       	mov	r12,r5
800066a8:	91 2a       	st.w	r8[0x8],r10
800066aa:	95 38       	st.w	r10[0xc],r8
800066ac:	72 18       	ld.w	r8,r9[0x4]
800066ae:	a1 a8       	sbr	r8,0x0
800066b0:	93 18       	st.w	r9[0x4],r8
800066b2:	cb c8       	rjmp	8000682a <_malloc_r+0x26e>
800066b4:	10 96       	mov	r6,r8
800066b6:	14 36       	cp.w	r6,r10
800066b8:	ce 71       	brne	80006686 <_malloc_r+0xca>
800066ba:	2f f3       	sub	r3,-1
800066bc:	e0 6a 05 40 	mov	r10,1344
800066c0:	f4 cc ff f8 	sub	r12,r10,-8
800066c4:	78 26       	ld.w	r6,r12[0x8]
800066c6:	18 36       	cp.w	r6,r12
800066c8:	c6 c0       	breq	800067a0 <_malloc_r+0x1e4>
800066ca:	6c 19       	ld.w	r9,r6[0x4]
800066cc:	e0 19 ff fc 	andl	r9,0xfffc
800066d0:	f2 07 01 08 	sub	r8,r9,r7
800066d4:	58 f8       	cp.w	r8,15
800066d6:	e0 89 00 8f 	brgt	800067f4 <_malloc_r+0x238>
800066da:	99 3c       	st.w	r12[0xc],r12
800066dc:	99 2c       	st.w	r12[0x8],r12
800066de:	58 08       	cp.w	r8,0
800066e0:	c0 55       	brlt	800066ea <_malloc_r+0x12e>
800066e2:	ec 09 00 09 	add	r9,r6,r9
800066e6:	0a 9c       	mov	r12,r5
800066e8:	ce 2b       	rjmp	800066ac <_malloc_r+0xf0>
800066ea:	e0 49 01 ff 	cp.w	r9,511
800066ee:	e0 8b 00 13 	brhi	80006714 <_malloc_r+0x158>
800066f2:	a3 99       	lsr	r9,0x3
800066f4:	f4 09 00 38 	add	r8,r10,r9<<0x3
800066f8:	70 2b       	ld.w	r11,r8[0x8]
800066fa:	8d 38       	st.w	r6[0xc],r8
800066fc:	8d 2b       	st.w	r6[0x8],r11
800066fe:	97 36       	st.w	r11[0xc],r6
80006700:	91 26       	st.w	r8[0x8],r6
80006702:	a3 49       	asr	r9,0x2
80006704:	74 18       	ld.w	r8,r10[0x4]
80006706:	30 1b       	mov	r11,1
80006708:	f6 09 09 49 	lsl	r9,r11,r9
8000670c:	f1 e9 10 09 	or	r9,r8,r9
80006710:	95 19       	st.w	r10[0x4],r9
80006712:	c4 78       	rjmp	800067a0 <_malloc_r+0x1e4>
80006714:	f2 0a 16 09 	lsr	r10,r9,0x9
80006718:	58 4a       	cp.w	r10,4
8000671a:	e0 8b 00 07 	brhi	80006728 <_malloc_r+0x16c>
8000671e:	f2 0a 16 06 	lsr	r10,r9,0x6
80006722:	2c 8a       	sub	r10,-56
80006724:	c2 08       	rjmp	80006764 <_malloc_r+0x1a8>
80006726:	d7 03       	nop
80006728:	59 4a       	cp.w	r10,20
8000672a:	e0 8b 00 04 	brhi	80006732 <_malloc_r+0x176>
8000672e:	2a 5a       	sub	r10,-91
80006730:	c1 a8       	rjmp	80006764 <_malloc_r+0x1a8>
80006732:	e0 4a 00 54 	cp.w	r10,84
80006736:	e0 8b 00 06 	brhi	80006742 <_malloc_r+0x186>
8000673a:	f2 0a 16 0c 	lsr	r10,r9,0xc
8000673e:	29 2a       	sub	r10,-110
80006740:	c1 28       	rjmp	80006764 <_malloc_r+0x1a8>
80006742:	e0 4a 01 54 	cp.w	r10,340
80006746:	e0 8b 00 06 	brhi	80006752 <_malloc_r+0x196>
8000674a:	f2 0a 16 0f 	lsr	r10,r9,0xf
8000674e:	28 9a       	sub	r10,-119
80006750:	c0 a8       	rjmp	80006764 <_malloc_r+0x1a8>
80006752:	e0 4a 05 54 	cp.w	r10,1364
80006756:	e0 88 00 04 	brls	8000675e <_malloc_r+0x1a2>
8000675a:	37 ea       	mov	r10,126
8000675c:	c0 48       	rjmp	80006764 <_malloc_r+0x1a8>
8000675e:	f2 0a 16 12 	lsr	r10,r9,0x12
80006762:	28 4a       	sub	r10,-124
80006764:	e0 6b 05 40 	mov	r11,1344
80006768:	f6 0a 00 34 	add	r4,r11,r10<<0x3
8000676c:	68 28       	ld.w	r8,r4[0x8]
8000676e:	08 38       	cp.w	r8,r4
80006770:	c0 e1       	brne	8000678c <_malloc_r+0x1d0>
80006772:	76 19       	ld.w	r9,r11[0x4]
80006774:	a3 4a       	asr	r10,0x2
80006776:	30 1e       	mov	lr,1
80006778:	fc 0a 09 4a 	lsl	r10,lr,r10
8000677c:	f3 ea 10 0a 	or	r10,r9,r10
80006780:	10 99       	mov	r9,r8
80006782:	97 1a       	st.w	r11[0x4],r10
80006784:	c0 a8       	rjmp	80006798 <_malloc_r+0x1dc>
80006786:	70 28       	ld.w	r8,r8[0x8]
80006788:	08 38       	cp.w	r8,r4
8000678a:	c0 60       	breq	80006796 <_malloc_r+0x1da>
8000678c:	70 1a       	ld.w	r10,r8[0x4]
8000678e:	e0 1a ff fc 	andl	r10,0xfffc
80006792:	14 39       	cp.w	r9,r10
80006794:	cf 93       	brcs	80006786 <_malloc_r+0x1ca>
80006796:	70 39       	ld.w	r9,r8[0xc]
80006798:	8d 39       	st.w	r6[0xc],r9
8000679a:	8d 28       	st.w	r6[0x8],r8
8000679c:	91 36       	st.w	r8[0xc],r6
8000679e:	93 26       	st.w	r9[0x8],r6
800067a0:	e6 08 14 02 	asr	r8,r3,0x2
800067a4:	30 1b       	mov	r11,1
800067a6:	e0 64 05 40 	mov	r4,1344
800067aa:	f6 08 09 4b 	lsl	r11,r11,r8
800067ae:	68 18       	ld.w	r8,r4[0x4]
800067b0:	10 3b       	cp.w	r11,r8
800067b2:	e0 8b 00 6b 	brhi	80006888 <_malloc_r+0x2cc>
800067b6:	f7 e8 00 09 	and	r9,r11,r8
800067ba:	c0 b1       	brne	800067d0 <_malloc_r+0x214>
800067bc:	e0 13 ff fc 	andl	r3,0xfffc
800067c0:	a1 7b       	lsl	r11,0x1
800067c2:	2f c3       	sub	r3,-4
800067c4:	c0 38       	rjmp	800067ca <_malloc_r+0x20e>
800067c6:	2f c3       	sub	r3,-4
800067c8:	a1 7b       	lsl	r11,0x1
800067ca:	f7 e8 00 09 	and	r9,r11,r8
800067ce:	cf c0       	breq	800067c6 <_malloc_r+0x20a>
800067d0:	e8 03 00 3e 	add	lr,r4,r3<<0x3
800067d4:	06 92       	mov	r2,r3
800067d6:	1c 91       	mov	r1,lr
800067d8:	62 36       	ld.w	r6,r1[0xc]
800067da:	c2 e8       	rjmp	80006836 <_malloc_r+0x27a>
800067dc:	6c 1a       	ld.w	r10,r6[0x4]
800067de:	e0 1a ff fc 	andl	r10,0xfffc
800067e2:	f4 07 01 08 	sub	r8,r10,r7
800067e6:	58 f8       	cp.w	r8,15
800067e8:	e0 8a 00 15 	brle	80006812 <_malloc_r+0x256>
800067ec:	6c 3a       	ld.w	r10,r6[0xc]
800067ee:	6c 29       	ld.w	r9,r6[0x8]
800067f0:	95 29       	st.w	r10[0x8],r9
800067f2:	93 3a       	st.w	r9[0xc],r10
800067f4:	0e 99       	mov	r9,r7
800067f6:	ec 07 00 07 	add	r7,r6,r7
800067fa:	a1 a9       	sbr	r9,0x0
800067fc:	99 37       	st.w	r12[0xc],r7
800067fe:	99 27       	st.w	r12[0x8],r7
80006800:	8d 19       	st.w	r6[0x4],r9
80006802:	ee 08 09 08 	st.w	r7[r8],r8
80006806:	8f 2c       	st.w	r7[0x8],r12
80006808:	8f 3c       	st.w	r7[0xc],r12
8000680a:	a1 a8       	sbr	r8,0x0
8000680c:	0a 9c       	mov	r12,r5
8000680e:	8f 18       	st.w	r7[0x4],r8
80006810:	c0 d8       	rjmp	8000682a <_malloc_r+0x26e>
80006812:	6c 39       	ld.w	r9,r6[0xc]
80006814:	58 08       	cp.w	r8,0
80006816:	c0 f5       	brlt	80006834 <_malloc_r+0x278>
80006818:	ec 0a 00 0a 	add	r10,r6,r10
8000681c:	74 18       	ld.w	r8,r10[0x4]
8000681e:	a1 a8       	sbr	r8,0x0
80006820:	0a 9c       	mov	r12,r5
80006822:	95 18       	st.w	r10[0x4],r8
80006824:	6c 28       	ld.w	r8,r6[0x8]
80006826:	93 28       	st.w	r9[0x8],r8
80006828:	91 39       	st.w	r8[0xc],r9
8000682a:	fe b0 f4 d1 	rcall	800051cc <__malloc_unlock>
8000682e:	ec cc ff f8 	sub	r12,r6,-8
80006832:	d8 32       	popm	r0-r7,pc
80006834:	12 96       	mov	r6,r9
80006836:	02 36       	cp.w	r6,r1
80006838:	cd 21       	brne	800067dc <_malloc_r+0x220>
8000683a:	2f f2       	sub	r2,-1
8000683c:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
80006840:	c0 30       	breq	80006846 <_malloc_r+0x28a>
80006842:	2f 81       	sub	r1,-8
80006844:	cc ab       	rjmp	800067d8 <_malloc_r+0x21c>
80006846:	1c 98       	mov	r8,lr
80006848:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
8000684c:	c0 81       	brne	8000685c <_malloc_r+0x2a0>
8000684e:	68 19       	ld.w	r9,r4[0x4]
80006850:	f6 08 11 ff 	rsub	r8,r11,-1
80006854:	f3 e8 00 08 	and	r8,r9,r8
80006858:	89 18       	st.w	r4[0x4],r8
8000685a:	c0 78       	rjmp	80006868 <_malloc_r+0x2ac>
8000685c:	f0 c9 00 08 	sub	r9,r8,8
80006860:	20 13       	sub	r3,1
80006862:	70 08       	ld.w	r8,r8[0x0]
80006864:	12 38       	cp.w	r8,r9
80006866:	cf 10       	breq	80006848 <_malloc_r+0x28c>
80006868:	a1 7b       	lsl	r11,0x1
8000686a:	68 18       	ld.w	r8,r4[0x4]
8000686c:	10 3b       	cp.w	r11,r8
8000686e:	e0 8b 00 0d 	brhi	80006888 <_malloc_r+0x2cc>
80006872:	58 0b       	cp.w	r11,0
80006874:	c0 a0       	breq	80006888 <_malloc_r+0x2cc>
80006876:	04 93       	mov	r3,r2
80006878:	c0 38       	rjmp	8000687e <_malloc_r+0x2c2>
8000687a:	2f c3       	sub	r3,-4
8000687c:	a1 7b       	lsl	r11,0x1
8000687e:	f7 e8 00 09 	and	r9,r11,r8
80006882:	ca 71       	brne	800067d0 <_malloc_r+0x214>
80006884:	cf bb       	rjmp	8000687a <_malloc_r+0x2be>
80006886:	d7 03       	nop
80006888:	68 23       	ld.w	r3,r4[0x8]
8000688a:	66 12       	ld.w	r2,r3[0x4]
8000688c:	e0 12 ff fc 	andl	r2,0xfffc
80006890:	0e 32       	cp.w	r2,r7
80006892:	5f 39       	srlo	r9
80006894:	e4 07 01 08 	sub	r8,r2,r7
80006898:	58 f8       	cp.w	r8,15
8000689a:	5f aa       	srle	r10
8000689c:	f5 e9 10 09 	or	r9,r10,r9
800068a0:	e0 80 00 9a 	breq	800069d4 <_malloc_r+0x418>
800068a4:	e0 68 0d 5c 	mov	r8,3420
800068a8:	70 01       	ld.w	r1,r8[0x0]
800068aa:	e0 68 09 4c 	mov	r8,2380
800068ae:	2f 01       	sub	r1,-16
800068b0:	70 08       	ld.w	r8,r8[0x0]
800068b2:	0e 01       	add	r1,r7
800068b4:	5b f8       	cp.w	r8,-1
800068b6:	c0 40       	breq	800068be <_malloc_r+0x302>
800068b8:	28 11       	sub	r1,-127
800068ba:	e0 11 ff 80 	andl	r1,0xff80
800068be:	02 9b       	mov	r11,r1
800068c0:	0a 9c       	mov	r12,r5
800068c2:	e0 a0 02 a5 	rcall	80006e0c <_sbrk_r>
800068c6:	18 96       	mov	r6,r12
800068c8:	5b fc       	cp.w	r12,-1
800068ca:	c7 50       	breq	800069b4 <_malloc_r+0x3f8>
800068cc:	e6 02 00 08 	add	r8,r3,r2
800068d0:	10 3c       	cp.w	r12,r8
800068d2:	c0 32       	brcc	800068d8 <_malloc_r+0x31c>
800068d4:	08 33       	cp.w	r3,r4
800068d6:	c6 f1       	brne	800069b4 <_malloc_r+0x3f8>
800068d8:	e0 6a 0d 60 	mov	r10,3424
800068dc:	74 09       	ld.w	r9,r10[0x0]
800068de:	e2 09 00 09 	add	r9,r1,r9
800068e2:	95 09       	st.w	r10[0x0],r9
800068e4:	10 36       	cp.w	r6,r8
800068e6:	c0 a1       	brne	800068fa <_malloc_r+0x33e>
800068e8:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
800068ec:	c0 71       	brne	800068fa <_malloc_r+0x33e>
800068ee:	e2 02 00 02 	add	r2,r1,r2
800068f2:	68 28       	ld.w	r8,r4[0x8]
800068f4:	a1 a2       	sbr	r2,0x0
800068f6:	91 12       	st.w	r8[0x4],r2
800068f8:	c4 f8       	rjmp	80006996 <_malloc_r+0x3da>
800068fa:	e0 6a 09 4c 	mov	r10,2380
800068fe:	74 0b       	ld.w	r11,r10[0x0]
80006900:	5b fb       	cp.w	r11,-1
80006902:	c0 31       	brne	80006908 <_malloc_r+0x34c>
80006904:	95 06       	st.w	r10[0x0],r6
80006906:	c0 78       	rjmp	80006914 <_malloc_r+0x358>
80006908:	ec 09 00 09 	add	r9,r6,r9
8000690c:	e0 6a 0d 60 	mov	r10,3424
80006910:	10 19       	sub	r9,r8
80006912:	95 09       	st.w	r10[0x0],r9
80006914:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
80006918:	f0 09 11 08 	rsub	r9,r8,8
8000691c:	58 08       	cp.w	r8,0
8000691e:	f2 08 17 10 	movne	r8,r9
80006922:	ed d8 e1 06 	addne	r6,r6,r8
80006926:	28 08       	sub	r8,-128
80006928:	ec 01 00 01 	add	r1,r6,r1
8000692c:	0a 9c       	mov	r12,r5
8000692e:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
80006932:	f0 01 01 01 	sub	r1,r8,r1
80006936:	02 9b       	mov	r11,r1
80006938:	e0 a0 02 6a 	rcall	80006e0c <_sbrk_r>
8000693c:	e0 68 0d 60 	mov	r8,3424
80006940:	5b fc       	cp.w	r12,-1
80006942:	ec 0c 17 00 	moveq	r12,r6
80006946:	f9 b1 00 00 	moveq	r1,0
8000694a:	70 09       	ld.w	r9,r8[0x0]
8000694c:	0c 1c       	sub	r12,r6
8000694e:	89 26       	st.w	r4[0x8],r6
80006950:	02 0c       	add	r12,r1
80006952:	12 01       	add	r1,r9
80006954:	a1 ac       	sbr	r12,0x0
80006956:	91 01       	st.w	r8[0x0],r1
80006958:	8d 1c       	st.w	r6[0x4],r12
8000695a:	08 33       	cp.w	r3,r4
8000695c:	c1 d0       	breq	80006996 <_malloc_r+0x3da>
8000695e:	58 f2       	cp.w	r2,15
80006960:	e0 8b 00 05 	brhi	8000696a <_malloc_r+0x3ae>
80006964:	30 18       	mov	r8,1
80006966:	8d 18       	st.w	r6[0x4],r8
80006968:	c2 68       	rjmp	800069b4 <_malloc_r+0x3f8>
8000696a:	30 59       	mov	r9,5
8000696c:	20 c2       	sub	r2,12
8000696e:	e0 12 ff f8 	andl	r2,0xfff8
80006972:	e6 02 00 08 	add	r8,r3,r2
80006976:	91 29       	st.w	r8[0x8],r9
80006978:	91 19       	st.w	r8[0x4],r9
8000697a:	66 18       	ld.w	r8,r3[0x4]
8000697c:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80006980:	e5 e8 10 08 	or	r8,r2,r8
80006984:	87 18       	st.w	r3[0x4],r8
80006986:	58 f2       	cp.w	r2,15
80006988:	e0 88 00 07 	brls	80006996 <_malloc_r+0x3da>
8000698c:	e6 cb ff f8 	sub	r11,r3,-8
80006990:	0a 9c       	mov	r12,r5
80006992:	e0 a0 1c 6b 	rcall	8000a268 <_free_r>
80006996:	e0 69 0d 58 	mov	r9,3416
8000699a:	72 0a       	ld.w	r10,r9[0x0]
8000699c:	e0 68 0d 60 	mov	r8,3424
800069a0:	70 08       	ld.w	r8,r8[0x0]
800069a2:	14 38       	cp.w	r8,r10
800069a4:	f3 f8 ba 00 	st.whi	r9[0x0],r8
800069a8:	e0 69 0d 54 	mov	r9,3412
800069ac:	72 0a       	ld.w	r10,r9[0x0]
800069ae:	14 38       	cp.w	r8,r10
800069b0:	f3 f8 ba 00 	st.whi	r9[0x0],r8
800069b4:	68 28       	ld.w	r8,r4[0x8]
800069b6:	70 18       	ld.w	r8,r8[0x4]
800069b8:	e0 18 ff fc 	andl	r8,0xfffc
800069bc:	0e 38       	cp.w	r8,r7
800069be:	5f 39       	srlo	r9
800069c0:	0e 18       	sub	r8,r7
800069c2:	58 f8       	cp.w	r8,15
800069c4:	5f aa       	srle	r10
800069c6:	f5 e9 10 09 	or	r9,r10,r9
800069ca:	c0 50       	breq	800069d4 <_malloc_r+0x418>
800069cc:	0a 9c       	mov	r12,r5
800069ce:	fe b0 f3 ff 	rcall	800051cc <__malloc_unlock>
800069d2:	d8 3a       	popm	r0-r7,pc,r12=0
800069d4:	68 26       	ld.w	r6,r4[0x8]
800069d6:	a1 a8       	sbr	r8,0x0
800069d8:	0e 99       	mov	r9,r7
800069da:	a1 a9       	sbr	r9,0x0
800069dc:	8d 19       	st.w	r6[0x4],r9
800069de:	ec 07 00 07 	add	r7,r6,r7
800069e2:	0a 9c       	mov	r12,r5
800069e4:	89 27       	st.w	r4[0x8],r7
800069e6:	8f 18       	st.w	r7[0x4],r8
800069e8:	fe b0 f3 f2 	rcall	800051cc <__malloc_unlock>
800069ec:	ec cc ff f8 	sub	r12,r6,-8
800069f0:	d8 32       	popm	r0-r7,pc
800069f2:	d7 03       	nop

800069f4 <memcpy>:
800069f4:	58 8a       	cp.w	r10,8
800069f6:	c2 f5       	brlt	80006a54 <memcpy+0x60>
800069f8:	f9 eb 10 09 	or	r9,r12,r11
800069fc:	e2 19 00 03 	andl	r9,0x3,COH
80006a00:	e0 81 00 97 	brne	80006b2e <memcpy+0x13a>
80006a04:	e0 4a 00 20 	cp.w	r10,32
80006a08:	c3 b4       	brge	80006a7e <memcpy+0x8a>
80006a0a:	f4 08 14 02 	asr	r8,r10,0x2
80006a0e:	f0 09 11 08 	rsub	r9,r8,8
80006a12:	fe 09 00 2f 	add	pc,pc,r9<<0x2
80006a16:	76 69       	ld.w	r9,r11[0x18]
80006a18:	99 69       	st.w	r12[0x18],r9
80006a1a:	76 59       	ld.w	r9,r11[0x14]
80006a1c:	99 59       	st.w	r12[0x14],r9
80006a1e:	76 49       	ld.w	r9,r11[0x10]
80006a20:	99 49       	st.w	r12[0x10],r9
80006a22:	76 39       	ld.w	r9,r11[0xc]
80006a24:	99 39       	st.w	r12[0xc],r9
80006a26:	76 29       	ld.w	r9,r11[0x8]
80006a28:	99 29       	st.w	r12[0x8],r9
80006a2a:	76 19       	ld.w	r9,r11[0x4]
80006a2c:	99 19       	st.w	r12[0x4],r9
80006a2e:	76 09       	ld.w	r9,r11[0x0]
80006a30:	99 09       	st.w	r12[0x0],r9
80006a32:	f6 08 00 2b 	add	r11,r11,r8<<0x2
80006a36:	f8 08 00 28 	add	r8,r12,r8<<0x2
80006a3a:	e0 1a 00 03 	andl	r10,0x3
80006a3e:	f4 0a 11 04 	rsub	r10,r10,4
80006a42:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
80006a46:	17 a9       	ld.ub	r9,r11[0x2]
80006a48:	b0 a9       	st.b	r8[0x2],r9
80006a4a:	17 99       	ld.ub	r9,r11[0x1]
80006a4c:	b0 99       	st.b	r8[0x1],r9
80006a4e:	17 89       	ld.ub	r9,r11[0x0]
80006a50:	b0 89       	st.b	r8[0x0],r9
80006a52:	5e fc       	retal	r12
80006a54:	f4 0a 11 09 	rsub	r10,r10,9
80006a58:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
80006a5c:	17 f9       	ld.ub	r9,r11[0x7]
80006a5e:	b8 f9       	st.b	r12[0x7],r9
80006a60:	17 e9       	ld.ub	r9,r11[0x6]
80006a62:	b8 e9       	st.b	r12[0x6],r9
80006a64:	17 d9       	ld.ub	r9,r11[0x5]
80006a66:	b8 d9       	st.b	r12[0x5],r9
80006a68:	17 c9       	ld.ub	r9,r11[0x4]
80006a6a:	b8 c9       	st.b	r12[0x4],r9
80006a6c:	17 b9       	ld.ub	r9,r11[0x3]
80006a6e:	b8 b9       	st.b	r12[0x3],r9
80006a70:	17 a9       	ld.ub	r9,r11[0x2]
80006a72:	b8 a9       	st.b	r12[0x2],r9
80006a74:	17 99       	ld.ub	r9,r11[0x1]
80006a76:	b8 99       	st.b	r12[0x1],r9
80006a78:	17 89       	ld.ub	r9,r11[0x0]
80006a7a:	b8 89       	st.b	r12[0x0],r9
80006a7c:	5e fc       	retal	r12
80006a7e:	eb cd 40 c0 	pushm	r6-r7,lr
80006a82:	18 99       	mov	r9,r12
80006a84:	22 0a       	sub	r10,32
80006a86:	b7 07       	ld.d	r6,r11++
80006a88:	b3 26       	st.d	r9++,r6
80006a8a:	b7 07       	ld.d	r6,r11++
80006a8c:	b3 26       	st.d	r9++,r6
80006a8e:	b7 07       	ld.d	r6,r11++
80006a90:	b3 26       	st.d	r9++,r6
80006a92:	b7 07       	ld.d	r6,r11++
80006a94:	b3 26       	st.d	r9++,r6
80006a96:	22 0a       	sub	r10,32
80006a98:	cf 74       	brge	80006a86 <memcpy+0x92>
80006a9a:	2f 0a       	sub	r10,-16
80006a9c:	c0 65       	brlt	80006aa8 <memcpy+0xb4>
80006a9e:	b7 07       	ld.d	r6,r11++
80006aa0:	b3 26       	st.d	r9++,r6
80006aa2:	b7 07       	ld.d	r6,r11++
80006aa4:	b3 26       	st.d	r9++,r6
80006aa6:	21 0a       	sub	r10,16
80006aa8:	5c 3a       	neg	r10
80006aaa:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
80006aae:	d7 03       	nop
80006ab0:	d7 03       	nop
80006ab2:	f7 36 00 0e 	ld.ub	r6,r11[14]
80006ab6:	f3 66 00 0e 	st.b	r9[14],r6
80006aba:	f7 36 00 0d 	ld.ub	r6,r11[13]
80006abe:	f3 66 00 0d 	st.b	r9[13],r6
80006ac2:	f7 36 00 0c 	ld.ub	r6,r11[12]
80006ac6:	f3 66 00 0c 	st.b	r9[12],r6
80006aca:	f7 36 00 0b 	ld.ub	r6,r11[11]
80006ace:	f3 66 00 0b 	st.b	r9[11],r6
80006ad2:	f7 36 00 0a 	ld.ub	r6,r11[10]
80006ad6:	f3 66 00 0a 	st.b	r9[10],r6
80006ada:	f7 36 00 09 	ld.ub	r6,r11[9]
80006ade:	f3 66 00 09 	st.b	r9[9],r6
80006ae2:	f7 36 00 08 	ld.ub	r6,r11[8]
80006ae6:	f3 66 00 08 	st.b	r9[8],r6
80006aea:	f7 36 00 07 	ld.ub	r6,r11[7]
80006aee:	f3 66 00 07 	st.b	r9[7],r6
80006af2:	f7 36 00 06 	ld.ub	r6,r11[6]
80006af6:	f3 66 00 06 	st.b	r9[6],r6
80006afa:	f7 36 00 05 	ld.ub	r6,r11[5]
80006afe:	f3 66 00 05 	st.b	r9[5],r6
80006b02:	f7 36 00 04 	ld.ub	r6,r11[4]
80006b06:	f3 66 00 04 	st.b	r9[4],r6
80006b0a:	f7 36 00 03 	ld.ub	r6,r11[3]
80006b0e:	f3 66 00 03 	st.b	r9[3],r6
80006b12:	f7 36 00 02 	ld.ub	r6,r11[2]
80006b16:	f3 66 00 02 	st.b	r9[2],r6
80006b1a:	f7 36 00 01 	ld.ub	r6,r11[1]
80006b1e:	f3 66 00 01 	st.b	r9[1],r6
80006b22:	f7 36 00 00 	ld.ub	r6,r11[0]
80006b26:	f3 66 00 00 	st.b	r9[0],r6
80006b2a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006b2e:	20 1a       	sub	r10,1
80006b30:	f6 0a 07 09 	ld.ub	r9,r11[r10]
80006b34:	f8 0a 0b 09 	st.b	r12[r10],r9
80006b38:	cf b1       	brne	80006b2e <memcpy+0x13a>
80006b3a:	5e fc       	retal	r12

80006b3c <memset>:
80006b3c:	18 98       	mov	r8,r12
80006b3e:	c0 38       	rjmp	80006b44 <memset+0x8>
80006b40:	10 cb       	st.b	r8++,r11
80006b42:	20 1a       	sub	r10,1
80006b44:	58 0a       	cp.w	r10,0
80006b46:	cf d1       	brne	80006b40 <memset+0x4>
80006b48:	5e fc       	retal	r12
80006b4a:	d7 03       	nop

80006b4c <_realloc_r>:
80006b4c:	d4 31       	pushm	r0-r7,lr
80006b4e:	20 1d       	sub	sp,4
80006b50:	16 94       	mov	r4,r11
80006b52:	18 92       	mov	r2,r12
80006b54:	14 9b       	mov	r11,r10
80006b56:	58 04       	cp.w	r4,0
80006b58:	c0 51       	brne	80006b62 <_realloc_r+0x16>
80006b5a:	fe b0 fd 31 	rcall	800065bc <_malloc_r>
80006b5e:	18 95       	mov	r5,r12
80006b60:	c5 39       	rjmp	80006e06 <_realloc_r+0x2ba>
80006b62:	50 0a       	stdsp	sp[0x0],r10
80006b64:	fe b0 f3 2e 	rcall	800051c0 <__malloc_lock>
80006b68:	40 0b       	lddsp	r11,sp[0x0]
80006b6a:	f6 c8 ff f5 	sub	r8,r11,-11
80006b6e:	e8 c1 00 08 	sub	r1,r4,8
80006b72:	10 96       	mov	r6,r8
80006b74:	62 1c       	ld.w	r12,r1[0x4]
80006b76:	e0 16 ff f8 	andl	r6,0xfff8
80006b7a:	59 68       	cp.w	r8,22
80006b7c:	f9 b6 08 10 	movls	r6,16
80006b80:	16 36       	cp.w	r6,r11
80006b82:	5f 38       	srlo	r8
80006b84:	f1 e6 13 f8 	or	r8,r8,r6>>0x1f
80006b88:	c0 50       	breq	80006b92 <_realloc_r+0x46>
80006b8a:	30 c8       	mov	r8,12
80006b8c:	30 05       	mov	r5,0
80006b8e:	85 38       	st.w	r2[0xc],r8
80006b90:	c3 b9       	rjmp	80006e06 <_realloc_r+0x2ba>
80006b92:	18 90       	mov	r0,r12
80006b94:	e0 10 ff fc 	andl	r0,0xfffc
80006b98:	0c 30       	cp.w	r0,r6
80006b9a:	e0 84 01 0b 	brge	80006db0 <_realloc_r+0x264>
80006b9e:	e0 68 05 40 	mov	r8,1344
80006ba2:	e2 00 00 09 	add	r9,r1,r0
80006ba6:	70 25       	ld.w	r5,r8[0x8]
80006ba8:	0a 39       	cp.w	r9,r5
80006baa:	c0 90       	breq	80006bbc <_realloc_r+0x70>
80006bac:	72 1a       	ld.w	r10,r9[0x4]
80006bae:	a1 ca       	cbr	r10,0x0
80006bb0:	f2 0a 00 0a 	add	r10,r9,r10
80006bb4:	74 1a       	ld.w	r10,r10[0x4]
80006bb6:	ed ba 00 00 	bld	r10,0x0
80006bba:	c2 20       	breq	80006bfe <_realloc_r+0xb2>
80006bbc:	72 1a       	ld.w	r10,r9[0x4]
80006bbe:	e0 1a ff fc 	andl	r10,0xfffc
80006bc2:	f4 00 00 03 	add	r3,r10,r0
80006bc6:	0a 39       	cp.w	r9,r5
80006bc8:	c1 31       	brne	80006bee <_realloc_r+0xa2>
80006bca:	ec c7 ff f0 	sub	r7,r6,-16
80006bce:	0e 33       	cp.w	r3,r7
80006bd0:	c1 95       	brlt	80006c02 <_realloc_r+0xb6>
80006bd2:	e2 06 00 09 	add	r9,r1,r6
80006bd6:	0c 13       	sub	r3,r6
80006bd8:	a1 a3       	sbr	r3,0x0
80006bda:	93 13       	st.w	r9[0x4],r3
80006bdc:	91 29       	st.w	r8[0x8],r9
80006bde:	04 9c       	mov	r12,r2
80006be0:	62 18       	ld.w	r8,r1[0x4]
80006be2:	08 95       	mov	r5,r4
80006be4:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80006be8:	10 46       	or	r6,r8
80006bea:	83 16       	st.w	r1[0x4],r6
80006bec:	c0 b9       	rjmp	80006e02 <_realloc_r+0x2b6>
80006bee:	0c 33       	cp.w	r3,r6
80006bf0:	c0 95       	brlt	80006c02 <_realloc_r+0xb6>
80006bf2:	72 28       	ld.w	r8,r9[0x8]
80006bf4:	02 97       	mov	r7,r1
80006bf6:	72 39       	ld.w	r9,r9[0xc]
80006bf8:	93 28       	st.w	r9[0x8],r8
80006bfa:	91 39       	st.w	r8[0xc],r9
80006bfc:	cd c8       	rjmp	80006db4 <_realloc_r+0x268>
80006bfe:	30 0a       	mov	r10,0
80006c00:	14 99       	mov	r9,r10
80006c02:	ed bc 00 00 	bld	r12,0x0
80006c06:	e0 80 00 95 	breq	80006d30 <_realloc_r+0x1e4>
80006c0a:	62 07       	ld.w	r7,r1[0x0]
80006c0c:	e2 07 01 07 	sub	r7,r1,r7
80006c10:	6e 1c       	ld.w	r12,r7[0x4]
80006c12:	e0 1c ff fc 	andl	r12,0xfffc
80006c16:	58 09       	cp.w	r9,0
80006c18:	c5 60       	breq	80006cc4 <_realloc_r+0x178>
80006c1a:	f8 00 00 03 	add	r3,r12,r0
80006c1e:	0a 39       	cp.w	r9,r5
80006c20:	c4 81       	brne	80006cb0 <_realloc_r+0x164>
80006c22:	14 03       	add	r3,r10
80006c24:	ec c9 ff f0 	sub	r9,r6,-16
80006c28:	12 33       	cp.w	r3,r9
80006c2a:	c4 d5       	brlt	80006cc4 <_realloc_r+0x178>
80006c2c:	6e 3a       	ld.w	r10,r7[0xc]
80006c2e:	6e 29       	ld.w	r9,r7[0x8]
80006c30:	95 29       	st.w	r10[0x8],r9
80006c32:	93 3a       	st.w	r9[0xc],r10
80006c34:	ee c5 ff f8 	sub	r5,r7,-8
80006c38:	e0 ca 00 04 	sub	r10,r0,4
80006c3c:	e0 4a 00 24 	cp.w	r10,36
80006c40:	e0 8b 00 25 	brhi	80006c8a <_realloc_r+0x13e>
80006c44:	0a 99       	mov	r9,r5
80006c46:	59 3a       	cp.w	r10,19
80006c48:	e0 88 00 1a 	brls	80006c7c <_realloc_r+0x130>
80006c4c:	09 09       	ld.w	r9,r4++
80006c4e:	8b 09       	st.w	r5[0x0],r9
80006c50:	09 09       	ld.w	r9,r4++
80006c52:	8f 39       	st.w	r7[0xc],r9
80006c54:	ee c9 ff f0 	sub	r9,r7,-16
80006c58:	59 ba       	cp.w	r10,27
80006c5a:	e0 88 00 11 	brls	80006c7c <_realloc_r+0x130>
80006c5e:	09 0b       	ld.w	r11,r4++
80006c60:	93 0b       	st.w	r9[0x0],r11
80006c62:	09 09       	ld.w	r9,r4++
80006c64:	8f 59       	st.w	r7[0x14],r9
80006c66:	ee c9 ff e8 	sub	r9,r7,-24
80006c6a:	e0 4a 00 24 	cp.w	r10,36
80006c6e:	c0 71       	brne	80006c7c <_realloc_r+0x130>
80006c70:	09 0a       	ld.w	r10,r4++
80006c72:	93 0a       	st.w	r9[0x0],r10
80006c74:	ee c9 ff e0 	sub	r9,r7,-32
80006c78:	09 0a       	ld.w	r10,r4++
80006c7a:	8f 7a       	st.w	r7[0x1c],r10
80006c7c:	09 0a       	ld.w	r10,r4++
80006c7e:	12 aa       	st.w	r9++,r10
80006c80:	68 0a       	ld.w	r10,r4[0x0]
80006c82:	93 0a       	st.w	r9[0x0],r10
80006c84:	68 1a       	ld.w	r10,r4[0x4]
80006c86:	93 1a       	st.w	r9[0x4],r10
80006c88:	c0 78       	rjmp	80006c96 <_realloc_r+0x14a>
80006c8a:	50 08       	stdsp	sp[0x0],r8
80006c8c:	08 9b       	mov	r11,r4
80006c8e:	0a 9c       	mov	r12,r5
80006c90:	e0 a0 1d 8f 	rcall	8000a7ae <memmove>
80006c94:	40 08       	lddsp	r8,sp[0x0]
80006c96:	ee 06 00 09 	add	r9,r7,r6
80006c9a:	0c 13       	sub	r3,r6
80006c9c:	a1 a3       	sbr	r3,0x0
80006c9e:	93 13       	st.w	r9[0x4],r3
80006ca0:	91 29       	st.w	r8[0x8],r9
80006ca2:	04 9c       	mov	r12,r2
80006ca4:	6e 18       	ld.w	r8,r7[0x4]
80006ca6:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80006caa:	10 46       	or	r6,r8
80006cac:	8f 16       	st.w	r7[0x4],r6
80006cae:	ca a8       	rjmp	80006e02 <_realloc_r+0x2b6>
80006cb0:	14 03       	add	r3,r10
80006cb2:	0c 33       	cp.w	r3,r6
80006cb4:	c0 85       	brlt	80006cc4 <_realloc_r+0x178>
80006cb6:	72 28       	ld.w	r8,r9[0x8]
80006cb8:	72 39       	ld.w	r9,r9[0xc]
80006cba:	93 28       	st.w	r9[0x8],r8
80006cbc:	91 39       	st.w	r8[0xc],r9
80006cbe:	6e 28       	ld.w	r8,r7[0x8]
80006cc0:	6e 39       	ld.w	r9,r7[0xc]
80006cc2:	c0 78       	rjmp	80006cd0 <_realloc_r+0x184>
80006cc4:	f8 00 00 03 	add	r3,r12,r0
80006cc8:	0c 33       	cp.w	r3,r6
80006cca:	c3 35       	brlt	80006d30 <_realloc_r+0x1e4>
80006ccc:	6e 39       	ld.w	r9,r7[0xc]
80006cce:	6e 28       	ld.w	r8,r7[0x8]
80006cd0:	93 28       	st.w	r9[0x8],r8
80006cd2:	91 39       	st.w	r8[0xc],r9
80006cd4:	e0 ca 00 04 	sub	r10,r0,4
80006cd8:	ee cc ff f8 	sub	r12,r7,-8
80006cdc:	e0 4a 00 24 	cp.w	r10,36
80006ce0:	e0 8b 00 24 	brhi	80006d28 <_realloc_r+0x1dc>
80006ce4:	59 3a       	cp.w	r10,19
80006ce6:	e0 88 00 1a 	brls	80006d1a <_realloc_r+0x1ce>
80006cea:	09 08       	ld.w	r8,r4++
80006cec:	99 08       	st.w	r12[0x0],r8
80006cee:	09 08       	ld.w	r8,r4++
80006cf0:	8f 38       	st.w	r7[0xc],r8
80006cf2:	ee cc ff f0 	sub	r12,r7,-16
80006cf6:	59 ba       	cp.w	r10,27
80006cf8:	e0 88 00 11 	brls	80006d1a <_realloc_r+0x1ce>
80006cfc:	09 08       	ld.w	r8,r4++
80006cfe:	99 08       	st.w	r12[0x0],r8
80006d00:	09 08       	ld.w	r8,r4++
80006d02:	8f 58       	st.w	r7[0x14],r8
80006d04:	ee cc ff e8 	sub	r12,r7,-24
80006d08:	e0 4a 00 24 	cp.w	r10,36
80006d0c:	c0 71       	brne	80006d1a <_realloc_r+0x1ce>
80006d0e:	09 08       	ld.w	r8,r4++
80006d10:	99 08       	st.w	r12[0x0],r8
80006d12:	ee cc ff e0 	sub	r12,r7,-32
80006d16:	09 08       	ld.w	r8,r4++
80006d18:	8f 78       	st.w	r7[0x1c],r8
80006d1a:	09 08       	ld.w	r8,r4++
80006d1c:	18 a8       	st.w	r12++,r8
80006d1e:	68 08       	ld.w	r8,r4[0x0]
80006d20:	99 08       	st.w	r12[0x0],r8
80006d22:	68 18       	ld.w	r8,r4[0x4]
80006d24:	99 18       	st.w	r12[0x4],r8
80006d26:	c4 78       	rjmp	80006db4 <_realloc_r+0x268>
80006d28:	08 9b       	mov	r11,r4
80006d2a:	e0 a0 1d 42 	rcall	8000a7ae <memmove>
80006d2e:	c4 38       	rjmp	80006db4 <_realloc_r+0x268>
80006d30:	04 9c       	mov	r12,r2
80006d32:	fe b0 fc 45 	rcall	800065bc <_malloc_r>
80006d36:	18 95       	mov	r5,r12
80006d38:	c3 a0       	breq	80006dac <_realloc_r+0x260>
80006d3a:	62 18       	ld.w	r8,r1[0x4]
80006d3c:	f8 c9 00 08 	sub	r9,r12,8
80006d40:	a1 c8       	cbr	r8,0x0
80006d42:	e2 08 00 08 	add	r8,r1,r8
80006d46:	10 39       	cp.w	r9,r8
80006d48:	c0 71       	brne	80006d56 <_realloc_r+0x20a>
80006d4a:	72 13       	ld.w	r3,r9[0x4]
80006d4c:	02 97       	mov	r7,r1
80006d4e:	e0 13 ff fc 	andl	r3,0xfffc
80006d52:	00 03       	add	r3,r0
80006d54:	c3 08       	rjmp	80006db4 <_realloc_r+0x268>
80006d56:	e0 ca 00 04 	sub	r10,r0,4
80006d5a:	e0 4a 00 24 	cp.w	r10,36
80006d5e:	e0 8b 00 20 	brhi	80006d9e <_realloc_r+0x252>
80006d62:	08 99       	mov	r9,r4
80006d64:	18 98       	mov	r8,r12
80006d66:	59 3a       	cp.w	r10,19
80006d68:	e0 88 00 14 	brls	80006d90 <_realloc_r+0x244>
80006d6c:	13 0b       	ld.w	r11,r9++
80006d6e:	10 ab       	st.w	r8++,r11
80006d70:	13 0b       	ld.w	r11,r9++
80006d72:	10 ab       	st.w	r8++,r11
80006d74:	59 ba       	cp.w	r10,27
80006d76:	e0 88 00 0d 	brls	80006d90 <_realloc_r+0x244>
80006d7a:	13 0b       	ld.w	r11,r9++
80006d7c:	10 ab       	st.w	r8++,r11
80006d7e:	13 0b       	ld.w	r11,r9++
80006d80:	10 ab       	st.w	r8++,r11
80006d82:	e0 4a 00 24 	cp.w	r10,36
80006d86:	c0 51       	brne	80006d90 <_realloc_r+0x244>
80006d88:	13 0a       	ld.w	r10,r9++
80006d8a:	10 aa       	st.w	r8++,r10
80006d8c:	13 0a       	ld.w	r10,r9++
80006d8e:	10 aa       	st.w	r8++,r10
80006d90:	13 0a       	ld.w	r10,r9++
80006d92:	10 aa       	st.w	r8++,r10
80006d94:	72 0a       	ld.w	r10,r9[0x0]
80006d96:	91 0a       	st.w	r8[0x0],r10
80006d98:	72 19       	ld.w	r9,r9[0x4]
80006d9a:	91 19       	st.w	r8[0x4],r9
80006d9c:	c0 48       	rjmp	80006da4 <_realloc_r+0x258>
80006d9e:	08 9b       	mov	r11,r4
80006da0:	e0 a0 1d 07 	rcall	8000a7ae <memmove>
80006da4:	08 9b       	mov	r11,r4
80006da6:	04 9c       	mov	r12,r2
80006da8:	e0 a0 1a 60 	rcall	8000a268 <_free_r>
80006dac:	04 9c       	mov	r12,r2
80006dae:	c2 a8       	rjmp	80006e02 <_realloc_r+0x2b6>
80006db0:	00 93       	mov	r3,r0
80006db2:	02 97       	mov	r7,r1
80006db4:	e6 06 01 09 	sub	r9,r3,r6
80006db8:	6e 18       	ld.w	r8,r7[0x4]
80006dba:	58 f9       	cp.w	r9,15
80006dbc:	e0 88 00 16 	brls	80006de8 <_realloc_r+0x29c>
80006dc0:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80006dc4:	ed e8 10 08 	or	r8,r6,r8
80006dc8:	8f 18       	st.w	r7[0x4],r8
80006dca:	12 98       	mov	r8,r9
80006dcc:	a1 a8       	sbr	r8,0x0
80006dce:	ee 06 00 0b 	add	r11,r7,r6
80006dd2:	f6 09 00 09 	add	r9,r11,r9
80006dd6:	97 18       	st.w	r11[0x4],r8
80006dd8:	72 18       	ld.w	r8,r9[0x4]
80006dda:	a1 a8       	sbr	r8,0x0
80006ddc:	2f 8b       	sub	r11,-8
80006dde:	93 18       	st.w	r9[0x4],r8
80006de0:	04 9c       	mov	r12,r2
80006de2:	e0 a0 1a 43 	rcall	8000a268 <_free_r>
80006de6:	c0 b8       	rjmp	80006dfc <_realloc_r+0x2b0>
80006de8:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80006dec:	e7 e8 10 08 	or	r8,r3,r8
80006df0:	8f 18       	st.w	r7[0x4],r8
80006df2:	ee 03 00 03 	add	r3,r7,r3
80006df6:	66 18       	ld.w	r8,r3[0x4]
80006df8:	a1 a8       	sbr	r8,0x0
80006dfa:	87 18       	st.w	r3[0x4],r8
80006dfc:	04 9c       	mov	r12,r2
80006dfe:	ee c5 ff f8 	sub	r5,r7,-8
80006e02:	fe b0 f1 e5 	rcall	800051cc <__malloc_unlock>
80006e06:	0a 9c       	mov	r12,r5
80006e08:	2f fd       	sub	sp,-4
80006e0a:	d8 32       	popm	r0-r7,pc

80006e0c <_sbrk_r>:
80006e0c:	d4 21       	pushm	r4-r7,lr
80006e0e:	30 08       	mov	r8,0
80006e10:	18 97       	mov	r7,r12
80006e12:	e0 66 41 0c 	mov	r6,16652
80006e16:	16 9c       	mov	r12,r11
80006e18:	8d 08       	st.w	r6[0x0],r8
80006e1a:	c8 5c       	rcall	80006f24 <_sbrk>
80006e1c:	5b fc       	cp.w	r12,-1
80006e1e:	c0 51       	brne	80006e28 <_sbrk_r+0x1c>
80006e20:	6c 08       	ld.w	r8,r6[0x0]
80006e22:	58 08       	cp.w	r8,0
80006e24:	ef f8 1a 03 	st.wne	r7[0xc],r8
80006e28:	d8 22       	popm	r4-r7,pc
80006e2a:	d7 03       	nop

80006e2c <sprintf>:
80006e2c:	d4 01       	pushm	lr
80006e2e:	21 7d       	sub	sp,92
80006e30:	e0 68 ff ff 	mov	r8,65535
80006e34:	ea 18 7f ff 	orh	r8,0x7fff
80006e38:	50 58       	stdsp	sp[0x14],r8
80006e3a:	50 28       	stdsp	sp[0x8],r8
80006e3c:	e0 68 02 08 	mov	r8,520
80006e40:	ba 68       	st.h	sp[0xc],r8
80006e42:	3f f8       	mov	r8,-1
80006e44:	ba 78       	st.h	sp[0xe],r8
80006e46:	e0 68 0a 40 	mov	r8,2624
80006e4a:	50 4c       	stdsp	sp[0x10],r12
80006e4c:	16 9a       	mov	r10,r11
80006e4e:	50 0c       	stdsp	sp[0x0],r12
80006e50:	fa c9 ff a0 	sub	r9,sp,-96
80006e54:	70 0c       	ld.w	r12,r8[0x0]
80006e56:	1a 9b       	mov	r11,sp
80006e58:	e0 a0 02 1a 	rcall	8000728c <_vfprintf_r>
80006e5c:	30 09       	mov	r9,0
80006e5e:	40 08       	lddsp	r8,sp[0x0]
80006e60:	b0 89       	st.b	r8[0x0],r9
80006e62:	2e 9d       	sub	sp,-92
80006e64:	d8 02       	popm	pc
80006e66:	d7 03       	nop

80006e68 <strncpy>:
80006e68:	30 08       	mov	r8,0
80006e6a:	10 3a       	cp.w	r10,r8
80006e6c:	5e 0c       	reteq	r12
80006e6e:	f6 08 07 09 	ld.ub	r9,r11[r8]
80006e72:	f8 08 0b 09 	st.b	r12[r8],r9
80006e76:	2f f8       	sub	r8,-1
80006e78:	58 09       	cp.w	r9,0
80006e7a:	cf 81       	brne	80006e6a <strncpy+0x2>
80006e7c:	10 3a       	cp.w	r10,r8
80006e7e:	5e 0c       	reteq	r12
80006e80:	f8 08 0b 09 	st.b	r12[r8],r9
80006e84:	2f f8       	sub	r8,-1
80006e86:	cf bb       	rjmp	80006e7c <strncpy+0x14>

80006e88 <_close>:
80006e88:	30 28       	mov	r8,2
80006e8a:	d6 73       	breakpoint
80006e8c:	3f fc       	mov	r12,-1
80006e8e:	35 8b       	mov	r11,88
80006e90:	58 0c       	cp.w	r12,0
80006e92:	5e 4c       	retge	r12
80006e94:	e0 6a 41 0c 	mov	r10,16652
80006e98:	95 0b       	st.w	r10[0x0],r11
80006e9a:	5e fc       	retal	r12

80006e9c <_lseek>:
80006e9c:	30 58       	mov	r8,5
80006e9e:	d6 73       	breakpoint
80006ea0:	3f fc       	mov	r12,-1
80006ea2:	35 8b       	mov	r11,88
80006ea4:	58 0c       	cp.w	r12,0
80006ea6:	5e 4c       	retge	r12
80006ea8:	e0 6a 41 0c 	mov	r10,16652
80006eac:	95 0b       	st.w	r10[0x0],r11
80006eae:	5e fc       	retal	r12

80006eb0 <isatty>:
80006eb0:	30 b8       	mov	r8,11
80006eb2:	d6 73       	breakpoint
80006eb4:	3f fc       	mov	r12,-1
80006eb6:	35 8b       	mov	r11,88
80006eb8:	58 0c       	cp.w	r12,0
80006eba:	5e 4c       	retge	r12
80006ebc:	e0 6a 41 0c 	mov	r10,16652
80006ec0:	95 0b       	st.w	r10[0x0],r11
80006ec2:	5e fc       	retal	r12

80006ec4 <_fstat_host>:
80006ec4:	30 98       	mov	r8,9
80006ec6:	d6 73       	breakpoint
80006ec8:	3f fc       	mov	r12,-1
80006eca:	35 8b       	mov	r11,88
80006ecc:	58 0c       	cp.w	r12,0
80006ece:	5e 4c       	retge	r12
80006ed0:	e0 6a 41 0c 	mov	r10,16652
80006ed4:	95 0b       	st.w	r10[0x0],r11
80006ed6:	5e fc       	retal	r12

80006ed8 <_fstat>:
80006ed8:	d4 21       	pushm	r4-r7,lr
80006eda:	21 0d       	sub	sp,64
80006edc:	16 97       	mov	r7,r11
80006ede:	1a 9b       	mov	r11,sp
80006ee0:	cf 2f       	rcall	80006ec4 <_fstat_host>
80006ee2:	c0 34       	brge	80006ee8 <_fstat+0x10>
80006ee4:	3f fc       	mov	r12,-1
80006ee6:	c1 c8       	rjmp	80006f1e <_fstat+0x46>
80006ee8:	40 08       	lddsp	r8,sp[0x0]
80006eea:	ae 08       	st.h	r7[0x0],r8
80006eec:	40 18       	lddsp	r8,sp[0x4]
80006eee:	ae 18       	st.h	r7[0x2],r8
80006ef0:	40 28       	lddsp	r8,sp[0x8]
80006ef2:	8f 18       	st.w	r7[0x4],r8
80006ef4:	40 38       	lddsp	r8,sp[0xc]
80006ef6:	ae 48       	st.h	r7[0x8],r8
80006ef8:	40 48       	lddsp	r8,sp[0x10]
80006efa:	ae 58       	st.h	r7[0xa],r8
80006efc:	40 58       	lddsp	r8,sp[0x14]
80006efe:	ae 68       	st.h	r7[0xc],r8
80006f00:	40 68       	lddsp	r8,sp[0x18]
80006f02:	ae 78       	st.h	r7[0xe],r8
80006f04:	40 88       	lddsp	r8,sp[0x20]
80006f06:	8f 48       	st.w	r7[0x10],r8
80006f08:	40 a8       	lddsp	r8,sp[0x28]
80006f0a:	8f b8       	st.w	r7[0x2c],r8
80006f0c:	40 c8       	lddsp	r8,sp[0x30]
80006f0e:	8f c8       	st.w	r7[0x30],r8
80006f10:	40 d8       	lddsp	r8,sp[0x34]
80006f12:	8f 58       	st.w	r7[0x14],r8
80006f14:	40 e8       	lddsp	r8,sp[0x38]
80006f16:	30 0c       	mov	r12,0
80006f18:	8f 78       	st.w	r7[0x1c],r8
80006f1a:	40 f8       	lddsp	r8,sp[0x3c]
80006f1c:	8f 98       	st.w	r7[0x24],r8
80006f1e:	2f 0d       	sub	sp,-64
80006f20:	d8 22       	popm	r4-r7,pc
80006f22:	d7 03       	nop

80006f24 <_sbrk>:
80006f24:	d4 01       	pushm	lr
80006f26:	e0 68 0d 88 	mov	r8,3464
80006f2a:	70 09       	ld.w	r9,r8[0x0]
80006f2c:	58 09       	cp.w	r9,0
80006f2e:	c0 41       	brne	80006f36 <_sbrk+0x12>
80006f30:	e0 69 41 10 	mov	r9,16656
80006f34:	91 09       	st.w	r8[0x0],r9
80006f36:	e0 69 0d 88 	mov	r9,3464
80006f3a:	e0 7a 70 00 	mov	r10,94208
80006f3e:	72 08       	ld.w	r8,r9[0x0]
80006f40:	f0 0c 00 0c 	add	r12,r8,r12
80006f44:	14 3c       	cp.w	r12,r10
80006f46:	e0 8b 00 04 	brhi	80006f4e <_sbrk+0x2a>
80006f4a:	93 0c       	st.w	r9[0x0],r12
80006f4c:	c0 68       	rjmp	80006f58 <_sbrk+0x34>
80006f4e:	e0 a0 18 15 	rcall	80009f78 <__errno>
80006f52:	30 c8       	mov	r8,12
80006f54:	99 08       	st.w	r12[0x0],r8
80006f56:	3f f8       	mov	r8,-1
80006f58:	10 9c       	mov	r12,r8
80006f5a:	d8 02       	popm	pc

80006f5c <get_arg>:
80006f5c:	d4 31       	pushm	r0-r7,lr
80006f5e:	20 8d       	sub	sp,32
80006f60:	fa c4 ff bc 	sub	r4,sp,-68
80006f64:	50 4b       	stdsp	sp[0x10],r11
80006f66:	68 2e       	ld.w	lr,r4[0x8]
80006f68:	50 58       	stdsp	sp[0x14],r8
80006f6a:	12 96       	mov	r6,r9
80006f6c:	7c 0b       	ld.w	r11,lr[0x0]
80006f6e:	70 05       	ld.w	r5,r8[0x0]
80006f70:	50 6e       	stdsp	sp[0x18],lr
80006f72:	58 0b       	cp.w	r11,0
80006f74:	f4 0b 17 00 	moveq	r11,r10
80006f78:	68 03       	ld.w	r3,r4[0x0]
80006f7a:	68 11       	ld.w	r1,r4[0x4]
80006f7c:	40 49       	lddsp	r9,sp[0x10]
80006f7e:	30 08       	mov	r8,0
80006f80:	c2 89       	rjmp	800071d0 <get_arg+0x274>
80006f82:	2f fb       	sub	r11,-1
80006f84:	32 5c       	mov	r12,37
80006f86:	17 8a       	ld.ub	r10,r11[0x0]
80006f88:	f8 0a 18 00 	cp.b	r10,r12
80006f8c:	5f 1e       	srne	lr
80006f8e:	f0 0a 18 00 	cp.b	r10,r8
80006f92:	5f 1c       	srne	r12
80006f94:	fd ec 00 0c 	and	r12,lr,r12
80006f98:	f0 0c 18 00 	cp.b	r12,r8
80006f9c:	cf 31       	brne	80006f82 <get_arg+0x26>
80006f9e:	58 0a       	cp.w	r10,0
80006fa0:	e0 80 01 25 	breq	800071ea <get_arg+0x28e>
80006fa4:	30 0c       	mov	r12,0
80006fa6:	3f fa       	mov	r10,-1
80006fa8:	18 90       	mov	r0,r12
80006faa:	50 3a       	stdsp	sp[0xc],r10
80006fac:	18 94       	mov	r4,r12
80006fae:	18 92       	mov	r2,r12
80006fb0:	f8 0c 00 3c 	add	r12,r12,r12<<0x3
80006fb4:	16 97       	mov	r7,r11
80006fb6:	50 7c       	stdsp	sp[0x1c],r12
80006fb8:	fe cc 9f 44 	sub	r12,pc,-24764
80006fbc:	0f 3a       	ld.ub	r10,r7++
80006fbe:	f8 0a 07 0e 	ld.ub	lr,r12[r10]
80006fc2:	40 7c       	lddsp	r12,sp[0x1c]
80006fc4:	1c 0c       	add	r12,lr
80006fc6:	fe ce a0 1a 	sub	lr,pc,-24550
80006fca:	fc 0c 07 0e 	ld.ub	lr,lr[r12]
80006fce:	20 1e       	sub	lr,1
80006fd0:	50 0e       	stdsp	sp[0x0],lr
80006fd2:	fe ce a0 92 	sub	lr,pc,-24430
80006fd6:	fc 0c 07 0c 	ld.ub	r12,lr[r12]
80006fda:	50 7c       	stdsp	sp[0x1c],r12
80006fdc:	40 0c       	lddsp	r12,sp[0x0]
80006fde:	58 7c       	cp.w	r12,7
80006fe0:	e0 8b 00 f1 	brhi	800071c2 <get_arg+0x266>
80006fe4:	fe ce a2 44 	sub	lr,pc,-23996
80006fe8:	fc 0c 03 2f 	ld.w	pc,lr[r12<<0x2]
80006fec:	36 8b       	mov	r11,104
80006fee:	f6 0a 18 00 	cp.b	r10,r11
80006ff2:	e0 80 00 e8 	breq	800071c2 <get_arg+0x266>
80006ff6:	37 1b       	mov	r11,113
80006ff8:	f6 0a 18 00 	cp.b	r10,r11
80006ffc:	c0 70       	breq	8000700a <get_arg+0xae>
80006ffe:	34 cb       	mov	r11,76
80007000:	f6 0a 18 00 	cp.b	r10,r11
80007004:	c0 51       	brne	8000700e <get_arg+0xb2>
80007006:	a3 b4       	sbr	r4,0x3
80007008:	cd d8       	rjmp	800071c2 <get_arg+0x266>
8000700a:	a5 b4       	sbr	r4,0x5
8000700c:	cd b8       	rjmp	800071c2 <get_arg+0x266>
8000700e:	08 9a       	mov	r10,r4
80007010:	0e 9b       	mov	r11,r7
80007012:	a5 aa       	sbr	r10,0x4
80007014:	17 3c       	ld.ub	r12,r11++
80007016:	a5 b4       	sbr	r4,0x5
80007018:	36 ce       	mov	lr,108
8000701a:	fc 0c 18 00 	cp.b	r12,lr
8000701e:	e0 80 00 d3 	breq	800071c4 <get_arg+0x268>
80007022:	14 94       	mov	r4,r10
80007024:	cc f8       	rjmp	800071c2 <get_arg+0x266>
80007026:	eb d5 c0 05 	bfextu	r5,r5,0x0,0x5
8000702a:	36 7c       	mov	r12,103
8000702c:	f8 0a 18 00 	cp.b	r10,r12
80007030:	e0 8b 00 27 	brhi	8000707e <get_arg+0x122>
80007034:	36 5b       	mov	r11,101
80007036:	f6 0a 18 00 	cp.b	r10,r11
8000703a:	c4 82       	brcc	800070ca <get_arg+0x16e>
8000703c:	34 fb       	mov	r11,79
8000703e:	f6 0a 18 00 	cp.b	r10,r11
80007042:	c4 80       	breq	800070d2 <get_arg+0x176>
80007044:	e0 8b 00 0c 	brhi	8000705c <get_arg+0x100>
80007048:	34 5b       	mov	r11,69
8000704a:	f6 0a 18 00 	cp.b	r10,r11
8000704e:	c3 e0       	breq	800070ca <get_arg+0x16e>
80007050:	34 7b       	mov	r11,71
80007052:	f6 0a 18 00 	cp.b	r10,r11
80007056:	c3 a0       	breq	800070ca <get_arg+0x16e>
80007058:	34 4b       	mov	r11,68
8000705a:	c0 88       	rjmp	8000706a <get_arg+0x10e>
8000705c:	35 8b       	mov	r11,88
8000705e:	f6 0a 18 00 	cp.b	r10,r11
80007062:	c2 c0       	breq	800070ba <get_arg+0x15e>
80007064:	e0 8b 00 07 	brhi	80007072 <get_arg+0x116>
80007068:	35 5b       	mov	r11,85
8000706a:	f6 0a 18 00 	cp.b	r10,r11
8000706e:	c3 51       	brne	800070d8 <get_arg+0x17c>
80007070:	c3 18       	rjmp	800070d2 <get_arg+0x176>
80007072:	36 3b       	mov	r11,99
80007074:	f6 0a 18 00 	cp.b	r10,r11
80007078:	c2 f0       	breq	800070d6 <get_arg+0x17a>
8000707a:	36 4b       	mov	r11,100
8000707c:	c0 e8       	rjmp	80007098 <get_arg+0x13c>
8000707e:	37 0b       	mov	r11,112
80007080:	f6 0a 18 00 	cp.b	r10,r11
80007084:	c2 50       	breq	800070ce <get_arg+0x172>
80007086:	e0 8b 00 0d 	brhi	800070a0 <get_arg+0x144>
8000708a:	36 eb       	mov	r11,110
8000708c:	f6 0a 18 00 	cp.b	r10,r11
80007090:	c1 f0       	breq	800070ce <get_arg+0x172>
80007092:	e0 8b 00 14 	brhi	800070ba <get_arg+0x15e>
80007096:	36 9b       	mov	r11,105
80007098:	f6 0a 18 00 	cp.b	r10,r11
8000709c:	c1 e1       	brne	800070d8 <get_arg+0x17c>
8000709e:	c0 e8       	rjmp	800070ba <get_arg+0x15e>
800070a0:	37 5b       	mov	r11,117
800070a2:	f6 0a 18 00 	cp.b	r10,r11
800070a6:	c0 a0       	breq	800070ba <get_arg+0x15e>
800070a8:	37 8b       	mov	r11,120
800070aa:	f6 0a 18 00 	cp.b	r10,r11
800070ae:	c0 60       	breq	800070ba <get_arg+0x15e>
800070b0:	37 3b       	mov	r11,115
800070b2:	f6 0a 18 00 	cp.b	r10,r11
800070b6:	c1 11       	brne	800070d8 <get_arg+0x17c>
800070b8:	c0 b8       	rjmp	800070ce <get_arg+0x172>
800070ba:	ed b4 00 04 	bld	r4,0x4
800070be:	c0 a0       	breq	800070d2 <get_arg+0x176>
800070c0:	ed b4 00 05 	bld	r4,0x5
800070c4:	c0 91       	brne	800070d6 <get_arg+0x17a>
800070c6:	30 20       	mov	r0,2
800070c8:	c0 88       	rjmp	800070d8 <get_arg+0x17c>
800070ca:	30 40       	mov	r0,4
800070cc:	c0 68       	rjmp	800070d8 <get_arg+0x17c>
800070ce:	30 30       	mov	r0,3
800070d0:	c0 48       	rjmp	800070d8 <get_arg+0x17c>
800070d2:	30 10       	mov	r0,1
800070d4:	c0 28       	rjmp	800070d8 <get_arg+0x17c>
800070d6:	30 00       	mov	r0,0
800070d8:	40 3b       	lddsp	r11,sp[0xc]
800070da:	5b fb       	cp.w	r11,-1
800070dc:	c0 40       	breq	800070e4 <get_arg+0x188>
800070de:	e2 0b 09 20 	st.w	r1[r11<<0x2],r0
800070e2:	c7 08       	rjmp	800071c2 <get_arg+0x266>
800070e4:	58 60       	cp.w	r0,6
800070e6:	e0 8b 00 6e 	brhi	800071c2 <get_arg+0x266>
800070ea:	6c 0a       	ld.w	r10,r6[0x0]
800070ec:	ea cc ff ff 	sub	r12,r5,-1
800070f0:	fe ce a3 30 	sub	lr,pc,-23760
800070f4:	fc 00 03 2f 	ld.w	pc,lr[r0<<0x2]
800070f8:	f4 cb ff f8 	sub	r11,r10,-8
800070fc:	8d 0b       	st.w	r6[0x0],r11
800070fe:	f4 ea 00 00 	ld.d	r10,r10[0]
80007102:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80007106:	c0 f8       	rjmp	80007124 <get_arg+0x1c8>
80007108:	f4 cb ff fc 	sub	r11,r10,-4
8000710c:	8d 0b       	st.w	r6[0x0],r11
8000710e:	74 0a       	ld.w	r10,r10[0x0]
80007110:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80007114:	c0 88       	rjmp	80007124 <get_arg+0x1c8>
80007116:	f4 cb ff f8 	sub	r11,r10,-8
8000711a:	8d 0b       	st.w	r6[0x0],r11
8000711c:	f4 ea 00 00 	ld.d	r10,r10[0]
80007120:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80007124:	0e 9b       	mov	r11,r7
80007126:	18 95       	mov	r5,r12
80007128:	c4 e8       	rjmp	800071c4 <get_arg+0x268>
8000712a:	62 0a       	ld.w	r10,r1[0x0]
8000712c:	5b fa       	cp.w	r10,-1
8000712e:	c0 b1       	brne	80007144 <get_arg+0x1e8>
80007130:	50 19       	stdsp	sp[0x4],r9
80007132:	50 28       	stdsp	sp[0x8],r8
80007134:	e0 6a 00 80 	mov	r10,128
80007138:	30 0b       	mov	r11,0
8000713a:	02 9c       	mov	r12,r1
8000713c:	fe b0 fd 00 	rcall	80006b3c <memset>
80007140:	40 28       	lddsp	r8,sp[0x8]
80007142:	40 19       	lddsp	r9,sp[0x4]
80007144:	e4 cc 00 01 	sub	r12,r2,1
80007148:	0e 9b       	mov	r11,r7
8000714a:	50 3c       	stdsp	sp[0xc],r12
8000714c:	f2 0c 0c 49 	max	r9,r9,r12
80007150:	c3 a8       	rjmp	800071c4 <get_arg+0x268>
80007152:	62 0a       	ld.w	r10,r1[0x0]
80007154:	5b fa       	cp.w	r10,-1
80007156:	c0 b1       	brne	8000716c <get_arg+0x210>
80007158:	50 19       	stdsp	sp[0x4],r9
8000715a:	50 28       	stdsp	sp[0x8],r8
8000715c:	e0 6a 00 80 	mov	r10,128
80007160:	30 0b       	mov	r11,0
80007162:	02 9c       	mov	r12,r1
80007164:	fe b0 fc ec 	rcall	80006b3c <memset>
80007168:	40 28       	lddsp	r8,sp[0x8]
8000716a:	40 19       	lddsp	r9,sp[0x4]
8000716c:	20 12       	sub	r2,1
8000716e:	30 0a       	mov	r10,0
80007170:	0e 9b       	mov	r11,r7
80007172:	e2 02 09 2a 	st.w	r1[r2<<0x2],r10
80007176:	f2 02 0c 49 	max	r9,r9,r2
8000717a:	c2 58       	rjmp	800071c4 <get_arg+0x268>
8000717c:	16 97       	mov	r7,r11
8000717e:	6c 0a       	ld.w	r10,r6[0x0]
80007180:	f4 cb ff fc 	sub	r11,r10,-4
80007184:	8d 0b       	st.w	r6[0x0],r11
80007186:	74 0a       	ld.w	r10,r10[0x0]
80007188:	0e 9b       	mov	r11,r7
8000718a:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
8000718e:	2f f5       	sub	r5,-1
80007190:	c1 a8       	rjmp	800071c4 <get_arg+0x268>
80007192:	f4 c2 00 30 	sub	r2,r10,48
80007196:	c0 68       	rjmp	800071a2 <get_arg+0x246>
80007198:	e4 02 00 22 	add	r2,r2,r2<<0x2
8000719c:	2f f7       	sub	r7,-1
8000719e:	f4 02 00 12 	add	r2,r10,r2<<0x1
800071a2:	0f 8a       	ld.ub	r10,r7[0x0]
800071a4:	58 0a       	cp.w	r10,0
800071a6:	c0 e0       	breq	800071c2 <get_arg+0x266>
800071a8:	23 0a       	sub	r10,48
800071aa:	58 9a       	cp.w	r10,9
800071ac:	fe 98 ff f6 	brls	80007198 <get_arg+0x23c>
800071b0:	c0 98       	rjmp	800071c2 <get_arg+0x266>
800071b2:	2f f7       	sub	r7,-1
800071b4:	0f 8a       	ld.ub	r10,r7[0x0]
800071b6:	58 0a       	cp.w	r10,0
800071b8:	c0 50       	breq	800071c2 <get_arg+0x266>
800071ba:	23 0a       	sub	r10,48
800071bc:	58 9a       	cp.w	r10,9
800071be:	fe 98 ff fa 	brls	800071b2 <get_arg+0x256>
800071c2:	0e 9b       	mov	r11,r7
800071c4:	40 7c       	lddsp	r12,sp[0x1c]
800071c6:	30 ba       	mov	r10,11
800071c8:	f4 0c 18 00 	cp.b	r12,r10
800071cc:	fe 91 fe f2 	brne	80006fb0 <get_arg+0x54>
800071d0:	40 42       	lddsp	r2,sp[0x10]
800071d2:	17 8c       	ld.ub	r12,r11[0x0]
800071d4:	0a 32       	cp.w	r2,r5
800071d6:	5f 4a       	srge	r10
800071d8:	f0 0c 18 00 	cp.b	r12,r8
800071dc:	5f 1c       	srne	r12
800071de:	f9 ea 00 0a 	and	r10,r12,r10
800071e2:	f0 0a 18 00 	cp.b	r10,r8
800071e6:	fe 91 fe cf 	brne	80006f84 <get_arg+0x28>
800071ea:	30 08       	mov	r8,0
800071ec:	40 4e       	lddsp	lr,sp[0x10]
800071ee:	17 8a       	ld.ub	r10,r11[0x0]
800071f0:	e2 05 00 21 	add	r1,r1,r5<<0x2
800071f4:	f0 0a 18 00 	cp.b	r10,r8
800071f8:	fc 09 17 10 	movne	r9,lr
800071fc:	e6 05 00 38 	add	r8,r3,r5<<0x3
80007200:	06 9e       	mov	lr,r3
80007202:	c2 a8       	rjmp	80007256 <get_arg+0x2fa>
80007204:	62 0a       	ld.w	r10,r1[0x0]
80007206:	58 3a       	cp.w	r10,3
80007208:	c1 e0       	breq	80007244 <get_arg+0x2e8>
8000720a:	e0 89 00 07 	brgt	80007218 <get_arg+0x2bc>
8000720e:	58 1a       	cp.w	r10,1
80007210:	c1 a0       	breq	80007244 <get_arg+0x2e8>
80007212:	58 2a       	cp.w	r10,2
80007214:	c1 81       	brne	80007244 <get_arg+0x2e8>
80007216:	c0 58       	rjmp	80007220 <get_arg+0x2c4>
80007218:	58 5a       	cp.w	r10,5
8000721a:	c0 c0       	breq	80007232 <get_arg+0x2d6>
8000721c:	c0 b5       	brlt	80007232 <get_arg+0x2d6>
8000721e:	c1 38       	rjmp	80007244 <get_arg+0x2e8>
80007220:	6c 0a       	ld.w	r10,r6[0x0]
80007222:	f4 cc ff f8 	sub	r12,r10,-8
80007226:	8d 0c       	st.w	r6[0x0],r12
80007228:	f4 e2 00 00 	ld.d	r2,r10[0]
8000722c:	f0 e3 00 00 	st.d	r8[0],r2
80007230:	c1 08       	rjmp	80007250 <get_arg+0x2f4>
80007232:	6c 0a       	ld.w	r10,r6[0x0]
80007234:	f4 cc ff f8 	sub	r12,r10,-8
80007238:	8d 0c       	st.w	r6[0x0],r12
8000723a:	f4 e2 00 00 	ld.d	r2,r10[0]
8000723e:	f0 e3 00 00 	st.d	r8[0],r2
80007242:	c0 78       	rjmp	80007250 <get_arg+0x2f4>
80007244:	6c 0a       	ld.w	r10,r6[0x0]
80007246:	f4 cc ff fc 	sub	r12,r10,-4
8000724a:	8d 0c       	st.w	r6[0x0],r12
8000724c:	74 0a       	ld.w	r10,r10[0x0]
8000724e:	91 0a       	st.w	r8[0x0],r10
80007250:	2f f5       	sub	r5,-1
80007252:	2f 88       	sub	r8,-8
80007254:	2f c1       	sub	r1,-4
80007256:	12 35       	cp.w	r5,r9
80007258:	fe 9a ff d6 	brle	80007204 <get_arg+0x2a8>
8000725c:	1c 93       	mov	r3,lr
8000725e:	40 52       	lddsp	r2,sp[0x14]
80007260:	40 6e       	lddsp	lr,sp[0x18]
80007262:	85 05       	st.w	r2[0x0],r5
80007264:	9d 0b       	st.w	lr[0x0],r11
80007266:	40 4b       	lddsp	r11,sp[0x10]
80007268:	e6 0b 00 3c 	add	r12,r3,r11<<0x3
8000726c:	2f 8d       	sub	sp,-32
8000726e:	d8 32       	popm	r0-r7,pc

80007270 <__sprint_r>:
80007270:	d4 21       	pushm	r4-r7,lr
80007272:	14 97       	mov	r7,r10
80007274:	74 28       	ld.w	r8,r10[0x8]
80007276:	58 08       	cp.w	r8,0
80007278:	c0 41       	brne	80007280 <__sprint_r+0x10>
8000727a:	95 18       	st.w	r10[0x4],r8
8000727c:	10 9c       	mov	r12,r8
8000727e:	d8 22       	popm	r4-r7,pc
80007280:	e0 a0 18 ba 	rcall	8000a3f4 <__sfvwrite_r>
80007284:	30 08       	mov	r8,0
80007286:	8f 18       	st.w	r7[0x4],r8
80007288:	8f 28       	st.w	r7[0x8],r8
8000728a:	d8 22       	popm	r4-r7,pc

8000728c <_vfprintf_r>:
8000728c:	d4 31       	pushm	r0-r7,lr
8000728e:	fa cd 06 bc 	sub	sp,sp,1724
80007292:	51 09       	stdsp	sp[0x40],r9
80007294:	16 91       	mov	r1,r11
80007296:	14 97       	mov	r7,r10
80007298:	18 95       	mov	r5,r12
8000729a:	e0 a0 1a 1d 	rcall	8000a6d4 <_localeconv_r>
8000729e:	78 0c       	ld.w	r12,r12[0x0]
800072a0:	50 cc       	stdsp	sp[0x30],r12
800072a2:	58 05       	cp.w	r5,0
800072a4:	c0 70       	breq	800072b2 <_vfprintf_r+0x26>
800072a6:	6a 68       	ld.w	r8,r5[0x18]
800072a8:	58 08       	cp.w	r8,0
800072aa:	c0 41       	brne	800072b2 <_vfprintf_r+0x26>
800072ac:	0a 9c       	mov	r12,r5
800072ae:	e0 a0 17 43 	rcall	8000a134 <__sinit>
800072b2:	fe c8 a1 2e 	sub	r8,pc,-24274
800072b6:	10 31       	cp.w	r1,r8
800072b8:	c0 31       	brne	800072be <_vfprintf_r+0x32>
800072ba:	6a 01       	ld.w	r1,r5[0x0]
800072bc:	c0 c8       	rjmp	800072d4 <_vfprintf_r+0x48>
800072be:	fe c8 a1 1a 	sub	r8,pc,-24294
800072c2:	10 31       	cp.w	r1,r8
800072c4:	c0 31       	brne	800072ca <_vfprintf_r+0x3e>
800072c6:	6a 11       	ld.w	r1,r5[0x4]
800072c8:	c0 68       	rjmp	800072d4 <_vfprintf_r+0x48>
800072ca:	fe c8 a1 06 	sub	r8,pc,-24314
800072ce:	10 31       	cp.w	r1,r8
800072d0:	eb f1 00 02 	ld.weq	r1,r5[0x8]
800072d4:	82 68       	ld.sh	r8,r1[0xc]
800072d6:	ed b8 00 03 	bld	r8,0x3
800072da:	c0 41       	brne	800072e2 <_vfprintf_r+0x56>
800072dc:	62 48       	ld.w	r8,r1[0x10]
800072de:	58 08       	cp.w	r8,0
800072e0:	c0 71       	brne	800072ee <_vfprintf_r+0x62>
800072e2:	02 9b       	mov	r11,r1
800072e4:	0a 9c       	mov	r12,r5
800072e6:	e0 a0 0f 5d 	rcall	800091a0 <__swsetup_r>
800072ea:	e0 81 0f 54 	brne	80009192 <_vfprintf_r+0x1f06>
800072ee:	82 68       	ld.sh	r8,r1[0xc]
800072f0:	10 99       	mov	r9,r8
800072f2:	e2 19 00 1a 	andl	r9,0x1a,COH
800072f6:	58 a9       	cp.w	r9,10
800072f8:	c3 c1       	brne	80007370 <_vfprintf_r+0xe4>
800072fa:	82 79       	ld.sh	r9,r1[0xe]
800072fc:	30 0a       	mov	r10,0
800072fe:	f4 09 19 00 	cp.h	r9,r10
80007302:	c3 75       	brlt	80007370 <_vfprintf_r+0xe4>
80007304:	a1 d8       	cbr	r8,0x1
80007306:	fb 58 05 d0 	st.h	sp[1488],r8
8000730a:	62 88       	ld.w	r8,r1[0x20]
8000730c:	fb 48 05 e4 	st.w	sp[1508],r8
80007310:	62 a8       	ld.w	r8,r1[0x28]
80007312:	fb 48 05 ec 	st.w	sp[1516],r8
80007316:	fa c8 ff bc 	sub	r8,sp,-68
8000731a:	fb 48 05 d4 	st.w	sp[1492],r8
8000731e:	fb 48 05 c4 	st.w	sp[1476],r8
80007322:	e0 68 04 00 	mov	r8,1024
80007326:	fb 48 05 d8 	st.w	sp[1496],r8
8000732a:	fb 48 05 cc 	st.w	sp[1484],r8
8000732e:	30 08       	mov	r8,0
80007330:	fb 59 05 d2 	st.h	sp[1490],r9
80007334:	0e 9a       	mov	r10,r7
80007336:	41 09       	lddsp	r9,sp[0x40]
80007338:	fa c7 fa 3c 	sub	r7,sp,-1476
8000733c:	fb 48 05 dc 	st.w	sp[1500],r8
80007340:	0a 9c       	mov	r12,r5
80007342:	0e 9b       	mov	r11,r7
80007344:	ca 4f       	rcall	8000728c <_vfprintf_r>
80007346:	50 bc       	stdsp	sp[0x2c],r12
80007348:	c0 95       	brlt	8000735a <_vfprintf_r+0xce>
8000734a:	0e 9b       	mov	r11,r7
8000734c:	0a 9c       	mov	r12,r5
8000734e:	e0 a0 16 1b 	rcall	80009f84 <_fflush_r>
80007352:	40 be       	lddsp	lr,sp[0x2c]
80007354:	f9 be 01 ff 	movne	lr,-1
80007358:	50 be       	stdsp	sp[0x2c],lr
8000735a:	fb 08 05 d0 	ld.sh	r8,sp[1488]
8000735e:	ed b8 00 06 	bld	r8,0x6
80007362:	e0 81 0f 1a 	brne	80009196 <_vfprintf_r+0x1f0a>
80007366:	82 68       	ld.sh	r8,r1[0xc]
80007368:	a7 a8       	sbr	r8,0x6
8000736a:	a2 68       	st.h	r1[0xc],r8
8000736c:	e0 8f 0f 15 	bral	80009196 <_vfprintf_r+0x1f0a>
80007370:	30 08       	mov	r8,0
80007372:	fb 48 06 b4 	st.w	sp[1716],r8
80007376:	fb 48 06 90 	st.w	sp[1680],r8
8000737a:	fb 48 06 8c 	st.w	sp[1676],r8
8000737e:	fb 48 06 b0 	st.w	sp[1712],r8
80007382:	30 08       	mov	r8,0
80007384:	30 09       	mov	r9,0
80007386:	50 a7       	stdsp	sp[0x28],r7
80007388:	50 78       	stdsp	sp[0x1c],r8
8000738a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000738e:	3f f8       	mov	r8,-1
80007390:	50 59       	stdsp	sp[0x14],r9
80007392:	fb 43 06 88 	st.w	sp[1672],r3
80007396:	fb 48 05 44 	st.w	sp[1348],r8
8000739a:	12 9c       	mov	r12,r9
8000739c:	50 69       	stdsp	sp[0x18],r9
8000739e:	50 d9       	stdsp	sp[0x34],r9
800073a0:	50 e9       	stdsp	sp[0x38],r9
800073a2:	50 b9       	stdsp	sp[0x2c],r9
800073a4:	12 97       	mov	r7,r9
800073a6:	0a 94       	mov	r4,r5
800073a8:	40 a2       	lddsp	r2,sp[0x28]
800073aa:	32 5a       	mov	r10,37
800073ac:	30 08       	mov	r8,0
800073ae:	c0 28       	rjmp	800073b2 <_vfprintf_r+0x126>
800073b0:	2f f2       	sub	r2,-1
800073b2:	05 89       	ld.ub	r9,r2[0x0]
800073b4:	f0 09 18 00 	cp.b	r9,r8
800073b8:	5f 1b       	srne	r11
800073ba:	f4 09 18 00 	cp.b	r9,r10
800073be:	5f 19       	srne	r9
800073c0:	f3 eb 00 0b 	and	r11,r9,r11
800073c4:	f0 0b 18 00 	cp.b	r11,r8
800073c8:	cf 41       	brne	800073b0 <_vfprintf_r+0x124>
800073ca:	40 ab       	lddsp	r11,sp[0x28]
800073cc:	e4 0b 01 06 	sub	r6,r2,r11
800073d0:	c1 e0       	breq	8000740c <_vfprintf_r+0x180>
800073d2:	fa f8 06 90 	ld.w	r8,sp[1680]
800073d6:	0c 08       	add	r8,r6
800073d8:	87 0b       	st.w	r3[0x0],r11
800073da:	fb 48 06 90 	st.w	sp[1680],r8
800073de:	87 16       	st.w	r3[0x4],r6
800073e0:	fa f8 06 8c 	ld.w	r8,sp[1676]
800073e4:	2f f8       	sub	r8,-1
800073e6:	fb 48 06 8c 	st.w	sp[1676],r8
800073ea:	58 78       	cp.w	r8,7
800073ec:	e0 89 00 04 	brgt	800073f4 <_vfprintf_r+0x168>
800073f0:	2f 83       	sub	r3,-8
800073f2:	c0 a8       	rjmp	80007406 <_vfprintf_r+0x17a>
800073f4:	fa ca f9 78 	sub	r10,sp,-1672
800073f8:	02 9b       	mov	r11,r1
800073fa:	08 9c       	mov	r12,r4
800073fc:	c3 af       	rcall	80007270 <__sprint_r>
800073fe:	e0 81 0e c6 	brne	8000918a <_vfprintf_r+0x1efe>
80007402:	fa c3 f9 e0 	sub	r3,sp,-1568
80007406:	40 ba       	lddsp	r10,sp[0x2c]
80007408:	0c 0a       	add	r10,r6
8000740a:	50 ba       	stdsp	sp[0x2c],r10
8000740c:	05 89       	ld.ub	r9,r2[0x0]
8000740e:	30 08       	mov	r8,0
80007410:	f0 09 18 00 	cp.b	r9,r8
80007414:	e0 80 0e aa 	breq	80009168 <_vfprintf_r+0x1edc>
80007418:	30 09       	mov	r9,0
8000741a:	fb 68 06 bb 	st.b	sp[1723],r8
8000741e:	0e 96       	mov	r6,r7
80007420:	e4 c8 ff ff 	sub	r8,r2,-1
80007424:	3f fe       	mov	lr,-1
80007426:	50 93       	stdsp	sp[0x24],r3
80007428:	50 41       	stdsp	sp[0x10],r1
8000742a:	0e 93       	mov	r3,r7
8000742c:	04 91       	mov	r1,r2
8000742e:	50 89       	stdsp	sp[0x20],r9
80007430:	50 a8       	stdsp	sp[0x28],r8
80007432:	50 2e       	stdsp	sp[0x8],lr
80007434:	50 39       	stdsp	sp[0xc],r9
80007436:	12 95       	mov	r5,r9
80007438:	12 90       	mov	r0,r9
8000743a:	10 97       	mov	r7,r8
8000743c:	08 92       	mov	r2,r4
8000743e:	c0 78       	rjmp	8000744c <_vfprintf_r+0x1c0>
80007440:	3f fc       	mov	r12,-1
80007442:	08 97       	mov	r7,r4
80007444:	50 2c       	stdsp	sp[0x8],r12
80007446:	c0 38       	rjmp	8000744c <_vfprintf_r+0x1c0>
80007448:	30 0b       	mov	r11,0
8000744a:	50 3b       	stdsp	sp[0xc],r11
8000744c:	0f 38       	ld.ub	r8,r7++
8000744e:	c0 28       	rjmp	80007452 <_vfprintf_r+0x1c6>
80007450:	12 90       	mov	r0,r9
80007452:	f0 c9 00 20 	sub	r9,r8,32
80007456:	e0 49 00 58 	cp.w	r9,88
8000745a:	e0 8b 0a 30 	brhi	800088ba <_vfprintf_r+0x162e>
8000745e:	fe ca a6 82 	sub	r10,pc,-22910
80007462:	f4 09 03 2f 	ld.w	pc,r10[r9<<0x2]
80007466:	50 a7       	stdsp	sp[0x28],r7
80007468:	50 80       	stdsp	sp[0x20],r0
8000746a:	0c 97       	mov	r7,r6
8000746c:	04 94       	mov	r4,r2
8000746e:	06 96       	mov	r6,r3
80007470:	02 92       	mov	r2,r1
80007472:	fe c9 a4 5a 	sub	r9,pc,-23462
80007476:	40 93       	lddsp	r3,sp[0x24]
80007478:	10 90       	mov	r0,r8
8000747a:	40 41       	lddsp	r1,sp[0x10]
8000747c:	50 d9       	stdsp	sp[0x34],r9
8000747e:	e0 8f 08 8e 	bral	8000859a <_vfprintf_r+0x130e>
80007482:	30 08       	mov	r8,0
80007484:	fb 39 06 bb 	ld.ub	r9,sp[1723]
80007488:	f0 09 18 00 	cp.b	r9,r8
8000748c:	ce 01       	brne	8000744c <_vfprintf_r+0x1c0>
8000748e:	32 08       	mov	r8,32
80007490:	c6 e8       	rjmp	8000756c <_vfprintf_r+0x2e0>
80007492:	a1 a5       	sbr	r5,0x0
80007494:	cd cb       	rjmp	8000744c <_vfprintf_r+0x1c0>
80007496:	0f 89       	ld.ub	r9,r7[0x0]
80007498:	f2 c8 00 30 	sub	r8,r9,48
8000749c:	58 98       	cp.w	r8,9
8000749e:	e0 8b 00 1d 	brhi	800074d8 <_vfprintf_r+0x24c>
800074a2:	ee c8 ff ff 	sub	r8,r7,-1
800074a6:	30 0b       	mov	r11,0
800074a8:	23 09       	sub	r9,48
800074aa:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
800074ae:	f2 0b 00 1b 	add	r11,r9,r11<<0x1
800074b2:	11 39       	ld.ub	r9,r8++
800074b4:	f2 ca 00 30 	sub	r10,r9,48
800074b8:	58 9a       	cp.w	r10,9
800074ba:	fe 98 ff f7 	brls	800074a8 <_vfprintf_r+0x21c>
800074be:	e0 49 00 24 	cp.w	r9,36
800074c2:	cc 31       	brne	80007448 <_vfprintf_r+0x1bc>
800074c4:	e0 4b 00 20 	cp.w	r11,32
800074c8:	e0 89 0e 60 	brgt	80009188 <_vfprintf_r+0x1efc>
800074cc:	20 1b       	sub	r11,1
800074ce:	fa f9 06 b4 	ld.w	r9,sp[1716]
800074d2:	12 3b       	cp.w	r11,r9
800074d4:	c0 95       	brlt	800074e6 <_vfprintf_r+0x25a>
800074d6:	c1 08       	rjmp	800074f6 <_vfprintf_r+0x26a>
800074d8:	fa f9 06 b4 	ld.w	r9,sp[1716]
800074dc:	ec ca ff ff 	sub	r10,r6,-1
800074e0:	12 36       	cp.w	r6,r9
800074e2:	c1 f5       	brlt	80007520 <_vfprintf_r+0x294>
800074e4:	c2 68       	rjmp	80007530 <_vfprintf_r+0x2a4>
800074e6:	fa ce f9 44 	sub	lr,sp,-1724
800074ea:	10 97       	mov	r7,r8
800074ec:	fc 0b 00 3b 	add	r11,lr,r11<<0x3
800074f0:	f6 f0 fd 88 	ld.w	r0,r11[-632]
800074f4:	c3 58       	rjmp	8000755e <_vfprintf_r+0x2d2>
800074f6:	10 97       	mov	r7,r8
800074f8:	fa c8 f9 50 	sub	r8,sp,-1712
800074fc:	1a d8       	st.w	--sp,r8
800074fe:	fa c8 fa b8 	sub	r8,sp,-1352
80007502:	1a d8       	st.w	--sp,r8
80007504:	fa c8 fb b4 	sub	r8,sp,-1100
80007508:	02 9a       	mov	r10,r1
8000750a:	1a d8       	st.w	--sp,r8
8000750c:	04 9c       	mov	r12,r2
8000750e:	fa c8 f9 40 	sub	r8,sp,-1728
80007512:	fa c9 ff b4 	sub	r9,sp,-76
80007516:	fe b0 fd 23 	rcall	80006f5c <get_arg>
8000751a:	2f dd       	sub	sp,-12
8000751c:	78 00       	ld.w	r0,r12[0x0]
8000751e:	c2 08       	rjmp	8000755e <_vfprintf_r+0x2d2>
80007520:	fa cc f9 44 	sub	r12,sp,-1724
80007524:	14 96       	mov	r6,r10
80007526:	f8 03 00 38 	add	r8,r12,r3<<0x3
8000752a:	f0 f0 fd 88 	ld.w	r0,r8[-632]
8000752e:	c1 88       	rjmp	8000755e <_vfprintf_r+0x2d2>
80007530:	41 08       	lddsp	r8,sp[0x40]
80007532:	59 f9       	cp.w	r9,31
80007534:	e0 89 00 11 	brgt	80007556 <_vfprintf_r+0x2ca>
80007538:	f0 cb ff fc 	sub	r11,r8,-4
8000753c:	51 0b       	stdsp	sp[0x40],r11
8000753e:	70 00       	ld.w	r0,r8[0x0]
80007540:	fa cb f9 44 	sub	r11,sp,-1724
80007544:	f6 09 00 38 	add	r8,r11,r9<<0x3
80007548:	f1 40 fd 88 	st.w	r8[-632],r0
8000754c:	2f f9       	sub	r9,-1
8000754e:	14 96       	mov	r6,r10
80007550:	fb 49 06 b4 	st.w	sp[1716],r9
80007554:	c0 58       	rjmp	8000755e <_vfprintf_r+0x2d2>
80007556:	70 00       	ld.w	r0,r8[0x0]
80007558:	14 96       	mov	r6,r10
8000755a:	2f c8       	sub	r8,-4
8000755c:	51 08       	stdsp	sp[0x40],r8
8000755e:	58 00       	cp.w	r0,0
80007560:	fe 94 ff 76 	brge	8000744c <_vfprintf_r+0x1c0>
80007564:	5c 30       	neg	r0
80007566:	a3 a5       	sbr	r5,0x2
80007568:	c7 2b       	rjmp	8000744c <_vfprintf_r+0x1c0>
8000756a:	32 b8       	mov	r8,43
8000756c:	fb 68 06 bb 	st.b	sp[1723],r8
80007570:	c6 eb       	rjmp	8000744c <_vfprintf_r+0x1c0>
80007572:	0f 38       	ld.ub	r8,r7++
80007574:	e0 48 00 2a 	cp.w	r8,42
80007578:	c0 30       	breq	8000757e <_vfprintf_r+0x2f2>
8000757a:	30 09       	mov	r9,0
8000757c:	c7 98       	rjmp	8000766e <_vfprintf_r+0x3e2>
8000757e:	0f 88       	ld.ub	r8,r7[0x0]
80007580:	f0 c9 00 30 	sub	r9,r8,48
80007584:	58 99       	cp.w	r9,9
80007586:	e0 8b 00 1f 	brhi	800075c4 <_vfprintf_r+0x338>
8000758a:	ee c4 ff ff 	sub	r4,r7,-1
8000758e:	30 0b       	mov	r11,0
80007590:	23 08       	sub	r8,48
80007592:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
80007596:	f0 0b 00 1b 	add	r11,r8,r11<<0x1
8000759a:	09 38       	ld.ub	r8,r4++
8000759c:	f0 c9 00 30 	sub	r9,r8,48
800075a0:	58 99       	cp.w	r9,9
800075a2:	fe 98 ff f7 	brls	80007590 <_vfprintf_r+0x304>
800075a6:	e0 48 00 24 	cp.w	r8,36
800075aa:	fe 91 ff 4f 	brne	80007448 <_vfprintf_r+0x1bc>
800075ae:	e0 4b 00 20 	cp.w	r11,32
800075b2:	e0 89 0d eb 	brgt	80009188 <_vfprintf_r+0x1efc>
800075b6:	20 1b       	sub	r11,1
800075b8:	fa f8 06 b4 	ld.w	r8,sp[1716]
800075bc:	10 3b       	cp.w	r11,r8
800075be:	c0 a5       	brlt	800075d2 <_vfprintf_r+0x346>
800075c0:	c1 18       	rjmp	800075e2 <_vfprintf_r+0x356>
800075c2:	d7 03       	nop
800075c4:	fa fa 06 b4 	ld.w	r10,sp[1716]
800075c8:	ec c9 ff ff 	sub	r9,r6,-1
800075cc:	14 36       	cp.w	r6,r10
800075ce:	c1 f5       	brlt	8000760c <_vfprintf_r+0x380>
800075d0:	c2 88       	rjmp	80007620 <_vfprintf_r+0x394>
800075d2:	fa ca f9 44 	sub	r10,sp,-1724
800075d6:	f4 0b 00 3b 	add	r11,r10,r11<<0x3
800075da:	f6 fb fd 88 	ld.w	r11,r11[-632]
800075de:	50 2b       	stdsp	sp[0x8],r11
800075e0:	c3 c8       	rjmp	80007658 <_vfprintf_r+0x3cc>
800075e2:	fa c8 f9 50 	sub	r8,sp,-1712
800075e6:	1a d8       	st.w	--sp,r8
800075e8:	fa c8 fa b8 	sub	r8,sp,-1352
800075ec:	1a d8       	st.w	--sp,r8
800075ee:	fa c8 fb b4 	sub	r8,sp,-1100
800075f2:	02 9a       	mov	r10,r1
800075f4:	1a d8       	st.w	--sp,r8
800075f6:	04 9c       	mov	r12,r2
800075f8:	fa c8 f9 40 	sub	r8,sp,-1728
800075fc:	fa c9 ff b4 	sub	r9,sp,-76
80007600:	fe b0 fc ae 	rcall	80006f5c <get_arg>
80007604:	2f dd       	sub	sp,-12
80007606:	78 0c       	ld.w	r12,r12[0x0]
80007608:	50 2c       	stdsp	sp[0x8],r12
8000760a:	c2 78       	rjmp	80007658 <_vfprintf_r+0x3cc>
8000760c:	12 96       	mov	r6,r9
8000760e:	0e 94       	mov	r4,r7
80007610:	fa c9 f9 44 	sub	r9,sp,-1724
80007614:	f2 03 00 38 	add	r8,r9,r3<<0x3
80007618:	f0 f8 fd 88 	ld.w	r8,r8[-632]
8000761c:	50 28       	stdsp	sp[0x8],r8
8000761e:	c1 d8       	rjmp	80007658 <_vfprintf_r+0x3cc>
80007620:	41 08       	lddsp	r8,sp[0x40]
80007622:	59 fa       	cp.w	r10,31
80007624:	e0 89 00 14 	brgt	8000764c <_vfprintf_r+0x3c0>
80007628:	f0 cb ff fc 	sub	r11,r8,-4
8000762c:	70 08       	ld.w	r8,r8[0x0]
8000762e:	51 0b       	stdsp	sp[0x40],r11
80007630:	50 28       	stdsp	sp[0x8],r8
80007632:	fa c6 f9 44 	sub	r6,sp,-1724
80007636:	40 2e       	lddsp	lr,sp[0x8]
80007638:	ec 0a 00 38 	add	r8,r6,r10<<0x3
8000763c:	f1 4e fd 88 	st.w	r8[-632],lr
80007640:	2f fa       	sub	r10,-1
80007642:	0e 94       	mov	r4,r7
80007644:	fb 4a 06 b4 	st.w	sp[1716],r10
80007648:	12 96       	mov	r6,r9
8000764a:	c0 78       	rjmp	80007658 <_vfprintf_r+0x3cc>
8000764c:	70 0c       	ld.w	r12,r8[0x0]
8000764e:	0e 94       	mov	r4,r7
80007650:	2f c8       	sub	r8,-4
80007652:	50 2c       	stdsp	sp[0x8],r12
80007654:	12 96       	mov	r6,r9
80007656:	51 08       	stdsp	sp[0x40],r8
80007658:	40 2b       	lddsp	r11,sp[0x8]
8000765a:	58 0b       	cp.w	r11,0
8000765c:	fe 95 fe f2 	brlt	80007440 <_vfprintf_r+0x1b4>
80007660:	08 97       	mov	r7,r4
80007662:	cf 5a       	rjmp	8000744c <_vfprintf_r+0x1c0>
80007664:	f2 09 00 29 	add	r9,r9,r9<<0x2
80007668:	0f 38       	ld.ub	r8,r7++
8000766a:	f4 09 00 19 	add	r9,r10,r9<<0x1
8000766e:	f0 ca 00 30 	sub	r10,r8,48
80007672:	58 9a       	cp.w	r10,9
80007674:	fe 98 ff f8 	brls	80007664 <_vfprintf_r+0x3d8>
80007678:	3f fa       	mov	r10,-1
8000767a:	f2 0a 0c 49 	max	r9,r9,r10
8000767e:	50 29       	stdsp	sp[0x8],r9
80007680:	ce 9a       	rjmp	80007452 <_vfprintf_r+0x1c6>
80007682:	a7 b5       	sbr	r5,0x7
80007684:	ce 4a       	rjmp	8000744c <_vfprintf_r+0x1c0>
80007686:	30 09       	mov	r9,0
80007688:	23 08       	sub	r8,48
8000768a:	f2 09 00 29 	add	r9,r9,r9<<0x2
8000768e:	f0 09 00 19 	add	r9,r8,r9<<0x1
80007692:	0f 38       	ld.ub	r8,r7++
80007694:	f0 ca 00 30 	sub	r10,r8,48
80007698:	58 9a       	cp.w	r10,9
8000769a:	fe 98 ff f7 	brls	80007688 <_vfprintf_r+0x3fc>
8000769e:	e0 48 00 24 	cp.w	r8,36
800076a2:	fe 91 fe d7 	brne	80007450 <_vfprintf_r+0x1c4>
800076a6:	e0 49 00 20 	cp.w	r9,32
800076aa:	e0 89 0d 6f 	brgt	80009188 <_vfprintf_r+0x1efc>
800076ae:	f2 c3 00 01 	sub	r3,r9,1
800076b2:	30 19       	mov	r9,1
800076b4:	50 39       	stdsp	sp[0xc],r9
800076b6:	cc ba       	rjmp	8000744c <_vfprintf_r+0x1c0>
800076b8:	a3 b5       	sbr	r5,0x3
800076ba:	cc 9a       	rjmp	8000744c <_vfprintf_r+0x1c0>
800076bc:	a7 a5       	sbr	r5,0x6
800076be:	cc 7a       	rjmp	8000744c <_vfprintf_r+0x1c0>
800076c0:	0a 98       	mov	r8,r5
800076c2:	a5 b5       	sbr	r5,0x5
800076c4:	a5 a8       	sbr	r8,0x4
800076c6:	0f 89       	ld.ub	r9,r7[0x0]
800076c8:	36 ce       	mov	lr,108
800076ca:	fc 09 18 00 	cp.b	r9,lr
800076ce:	f7 b7 00 ff 	subeq	r7,-1
800076d2:	f0 05 17 10 	movne	r5,r8
800076d6:	cb ba       	rjmp	8000744c <_vfprintf_r+0x1c0>
800076d8:	a5 b5       	sbr	r5,0x5
800076da:	cb 9a       	rjmp	8000744c <_vfprintf_r+0x1c0>
800076dc:	50 a7       	stdsp	sp[0x28],r7
800076de:	50 80       	stdsp	sp[0x20],r0
800076e0:	0c 97       	mov	r7,r6
800076e2:	10 90       	mov	r0,r8
800076e4:	06 96       	mov	r6,r3
800076e6:	04 94       	mov	r4,r2
800076e8:	40 93       	lddsp	r3,sp[0x24]
800076ea:	02 92       	mov	r2,r1
800076ec:	0e 99       	mov	r9,r7
800076ee:	40 41       	lddsp	r1,sp[0x10]
800076f0:	fa f8 06 b4 	ld.w	r8,sp[1716]
800076f4:	40 3c       	lddsp	r12,sp[0xc]
800076f6:	58 0c       	cp.w	r12,0
800076f8:	c1 d0       	breq	80007732 <_vfprintf_r+0x4a6>
800076fa:	10 36       	cp.w	r6,r8
800076fc:	c0 64       	brge	80007708 <_vfprintf_r+0x47c>
800076fe:	fa cb f9 44 	sub	r11,sp,-1724
80007702:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007706:	c1 d8       	rjmp	80007740 <_vfprintf_r+0x4b4>
80007708:	fa c8 f9 50 	sub	r8,sp,-1712
8000770c:	1a d8       	st.w	--sp,r8
8000770e:	fa c8 fa b8 	sub	r8,sp,-1352
80007712:	1a d8       	st.w	--sp,r8
80007714:	fa c8 fb b4 	sub	r8,sp,-1100
80007718:	1a d8       	st.w	--sp,r8
8000771a:	fa c8 f9 40 	sub	r8,sp,-1728
8000771e:	fa c9 ff b4 	sub	r9,sp,-76
80007722:	04 9a       	mov	r10,r2
80007724:	0c 9b       	mov	r11,r6
80007726:	08 9c       	mov	r12,r4
80007728:	fe b0 fc 1a 	rcall	80006f5c <get_arg>
8000772c:	2f dd       	sub	sp,-12
8000772e:	19 b8       	ld.ub	r8,r12[0x3]
80007730:	c2 28       	rjmp	80007774 <_vfprintf_r+0x4e8>
80007732:	2f f7       	sub	r7,-1
80007734:	10 39       	cp.w	r9,r8
80007736:	c0 84       	brge	80007746 <_vfprintf_r+0x4ba>
80007738:	fa ca f9 44 	sub	r10,sp,-1724
8000773c:	f4 06 00 36 	add	r6,r10,r6<<0x3
80007740:	ed 38 fd 8b 	ld.ub	r8,r6[-629]
80007744:	c1 88       	rjmp	80007774 <_vfprintf_r+0x4e8>
80007746:	41 09       	lddsp	r9,sp[0x40]
80007748:	59 f8       	cp.w	r8,31
8000774a:	e0 89 00 12 	brgt	8000776e <_vfprintf_r+0x4e2>
8000774e:	f2 ca ff fc 	sub	r10,r9,-4
80007752:	51 0a       	stdsp	sp[0x40],r10
80007754:	72 09       	ld.w	r9,r9[0x0]
80007756:	fa c6 f9 44 	sub	r6,sp,-1724
8000775a:	ec 08 00 3a 	add	r10,r6,r8<<0x3
8000775e:	2f f8       	sub	r8,-1
80007760:	f5 49 fd 88 	st.w	r10[-632],r9
80007764:	fb 48 06 b4 	st.w	sp[1716],r8
80007768:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
8000776c:	c0 48       	rjmp	80007774 <_vfprintf_r+0x4e8>
8000776e:	13 b8       	ld.ub	r8,r9[0x3]
80007770:	2f c9       	sub	r9,-4
80007772:	51 09       	stdsp	sp[0x40],r9
80007774:	fb 68 06 60 	st.b	sp[1632],r8
80007778:	30 0e       	mov	lr,0
8000777a:	30 08       	mov	r8,0
8000777c:	30 12       	mov	r2,1
8000777e:	fb 68 06 bb 	st.b	sp[1723],r8
80007782:	50 2e       	stdsp	sp[0x8],lr
80007784:	e0 8f 08 ad 	bral	800088de <_vfprintf_r+0x1652>
80007788:	50 a7       	stdsp	sp[0x28],r7
8000778a:	50 80       	stdsp	sp[0x20],r0
8000778c:	0c 97       	mov	r7,r6
8000778e:	04 94       	mov	r4,r2
80007790:	06 96       	mov	r6,r3
80007792:	02 92       	mov	r2,r1
80007794:	40 93       	lddsp	r3,sp[0x24]
80007796:	10 90       	mov	r0,r8
80007798:	40 41       	lddsp	r1,sp[0x10]
8000779a:	a5 a5       	sbr	r5,0x4
8000779c:	c0 a8       	rjmp	800077b0 <_vfprintf_r+0x524>
8000779e:	50 a7       	stdsp	sp[0x28],r7
800077a0:	50 80       	stdsp	sp[0x20],r0
800077a2:	0c 97       	mov	r7,r6
800077a4:	04 94       	mov	r4,r2
800077a6:	06 96       	mov	r6,r3
800077a8:	02 92       	mov	r2,r1
800077aa:	40 93       	lddsp	r3,sp[0x24]
800077ac:	10 90       	mov	r0,r8
800077ae:	40 41       	lddsp	r1,sp[0x10]
800077b0:	ed b5 00 05 	bld	r5,0x5
800077b4:	c5 11       	brne	80007856 <_vfprintf_r+0x5ca>
800077b6:	fa f8 06 b4 	ld.w	r8,sp[1716]
800077ba:	40 3c       	lddsp	r12,sp[0xc]
800077bc:	58 0c       	cp.w	r12,0
800077be:	c1 e0       	breq	800077fa <_vfprintf_r+0x56e>
800077c0:	10 36       	cp.w	r6,r8
800077c2:	c0 64       	brge	800077ce <_vfprintf_r+0x542>
800077c4:	fa cb f9 44 	sub	r11,sp,-1724
800077c8:	f6 06 00 36 	add	r6,r11,r6<<0x3
800077cc:	c2 08       	rjmp	8000780c <_vfprintf_r+0x580>
800077ce:	fa c8 f9 50 	sub	r8,sp,-1712
800077d2:	1a d8       	st.w	--sp,r8
800077d4:	fa c8 fa b8 	sub	r8,sp,-1352
800077d8:	0c 9b       	mov	r11,r6
800077da:	1a d8       	st.w	--sp,r8
800077dc:	fa c8 fb b4 	sub	r8,sp,-1100
800077e0:	1a d8       	st.w	--sp,r8
800077e2:	fa c9 ff b4 	sub	r9,sp,-76
800077e6:	fa c8 f9 40 	sub	r8,sp,-1728
800077ea:	04 9a       	mov	r10,r2
800077ec:	08 9c       	mov	r12,r4
800077ee:	fe b0 fb b7 	rcall	80006f5c <get_arg>
800077f2:	2f dd       	sub	sp,-12
800077f4:	78 1b       	ld.w	r11,r12[0x4]
800077f6:	78 09       	ld.w	r9,r12[0x0]
800077f8:	c2 b8       	rjmp	8000784e <_vfprintf_r+0x5c2>
800077fa:	ee ca ff ff 	sub	r10,r7,-1
800077fe:	10 37       	cp.w	r7,r8
80007800:	c0 b4       	brge	80007816 <_vfprintf_r+0x58a>
80007802:	fa c9 f9 44 	sub	r9,sp,-1724
80007806:	14 97       	mov	r7,r10
80007808:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000780c:	ec fb fd 8c 	ld.w	r11,r6[-628]
80007810:	ec f9 fd 88 	ld.w	r9,r6[-632]
80007814:	c1 d8       	rjmp	8000784e <_vfprintf_r+0x5c2>
80007816:	41 09       	lddsp	r9,sp[0x40]
80007818:	59 f8       	cp.w	r8,31
8000781a:	e0 89 00 14 	brgt	80007842 <_vfprintf_r+0x5b6>
8000781e:	f2 cb ff f8 	sub	r11,r9,-8
80007822:	51 0b       	stdsp	sp[0x40],r11
80007824:	fa c6 f9 44 	sub	r6,sp,-1724
80007828:	72 1b       	ld.w	r11,r9[0x4]
8000782a:	ec 08 00 3c 	add	r12,r6,r8<<0x3
8000782e:	72 09       	ld.w	r9,r9[0x0]
80007830:	f9 4b fd 8c 	st.w	r12[-628],r11
80007834:	f9 49 fd 88 	st.w	r12[-632],r9
80007838:	2f f8       	sub	r8,-1
8000783a:	14 97       	mov	r7,r10
8000783c:	fb 48 06 b4 	st.w	sp[1716],r8
80007840:	c0 78       	rjmp	8000784e <_vfprintf_r+0x5c2>
80007842:	f2 c8 ff f8 	sub	r8,r9,-8
80007846:	72 1b       	ld.w	r11,r9[0x4]
80007848:	14 97       	mov	r7,r10
8000784a:	51 08       	stdsp	sp[0x40],r8
8000784c:	72 09       	ld.w	r9,r9[0x0]
8000784e:	16 98       	mov	r8,r11
80007850:	fa e9 00 00 	st.d	sp[0],r8
80007854:	ca e8       	rjmp	800079b0 <_vfprintf_r+0x724>
80007856:	ed b5 00 04 	bld	r5,0x4
8000785a:	c1 71       	brne	80007888 <_vfprintf_r+0x5fc>
8000785c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007860:	40 3e       	lddsp	lr,sp[0xc]
80007862:	58 0e       	cp.w	lr,0
80007864:	c0 80       	breq	80007874 <_vfprintf_r+0x5e8>
80007866:	10 36       	cp.w	r6,r8
80007868:	c6 94       	brge	8000793a <_vfprintf_r+0x6ae>
8000786a:	fa cc f9 44 	sub	r12,sp,-1724
8000786e:	f8 06 00 36 	add	r6,r12,r6<<0x3
80007872:	c8 28       	rjmp	80007976 <_vfprintf_r+0x6ea>
80007874:	ee ca ff ff 	sub	r10,r7,-1
80007878:	10 37       	cp.w	r7,r8
8000787a:	e0 84 00 81 	brge	8000797c <_vfprintf_r+0x6f0>
8000787e:	fa cb f9 44 	sub	r11,sp,-1724
80007882:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007886:	c7 78       	rjmp	80007974 <_vfprintf_r+0x6e8>
80007888:	ed b5 00 06 	bld	r5,0x6
8000788c:	c4 b1       	brne	80007922 <_vfprintf_r+0x696>
8000788e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007892:	40 3c       	lddsp	r12,sp[0xc]
80007894:	58 0c       	cp.w	r12,0
80007896:	c1 d0       	breq	800078d0 <_vfprintf_r+0x644>
80007898:	10 36       	cp.w	r6,r8
8000789a:	c0 64       	brge	800078a6 <_vfprintf_r+0x61a>
8000789c:	fa cb f9 44 	sub	r11,sp,-1724
800078a0:	f6 06 00 36 	add	r6,r11,r6<<0x3
800078a4:	c1 f8       	rjmp	800078e2 <_vfprintf_r+0x656>
800078a6:	fa c8 f9 50 	sub	r8,sp,-1712
800078aa:	1a d8       	st.w	--sp,r8
800078ac:	fa c8 fa b8 	sub	r8,sp,-1352
800078b0:	1a d8       	st.w	--sp,r8
800078b2:	fa c8 fb b4 	sub	r8,sp,-1100
800078b6:	1a d8       	st.w	--sp,r8
800078b8:	fa c8 f9 40 	sub	r8,sp,-1728
800078bc:	fa c9 ff b4 	sub	r9,sp,-76
800078c0:	04 9a       	mov	r10,r2
800078c2:	0c 9b       	mov	r11,r6
800078c4:	08 9c       	mov	r12,r4
800078c6:	fe b0 fb 4b 	rcall	80006f5c <get_arg>
800078ca:	2f dd       	sub	sp,-12
800078cc:	98 18       	ld.sh	r8,r12[0x2]
800078ce:	c2 68       	rjmp	8000791a <_vfprintf_r+0x68e>
800078d0:	ee ca ff ff 	sub	r10,r7,-1
800078d4:	10 37       	cp.w	r7,r8
800078d6:	c0 94       	brge	800078e8 <_vfprintf_r+0x65c>
800078d8:	fa c9 f9 44 	sub	r9,sp,-1724
800078dc:	14 97       	mov	r7,r10
800078de:	f2 06 00 36 	add	r6,r9,r6<<0x3
800078e2:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
800078e6:	c1 a8       	rjmp	8000791a <_vfprintf_r+0x68e>
800078e8:	41 09       	lddsp	r9,sp[0x40]
800078ea:	59 f8       	cp.w	r8,31
800078ec:	e0 89 00 13 	brgt	80007912 <_vfprintf_r+0x686>
800078f0:	f2 cb ff fc 	sub	r11,r9,-4
800078f4:	51 0b       	stdsp	sp[0x40],r11
800078f6:	72 09       	ld.w	r9,r9[0x0]
800078f8:	fa c6 f9 44 	sub	r6,sp,-1724
800078fc:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80007900:	2f f8       	sub	r8,-1
80007902:	f7 49 fd 88 	st.w	r11[-632],r9
80007906:	fb 48 06 b4 	st.w	sp[1716],r8
8000790a:	14 97       	mov	r7,r10
8000790c:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80007910:	c0 58       	rjmp	8000791a <_vfprintf_r+0x68e>
80007912:	92 18       	ld.sh	r8,r9[0x2]
80007914:	14 97       	mov	r7,r10
80007916:	2f c9       	sub	r9,-4
80007918:	51 09       	stdsp	sp[0x40],r9
8000791a:	50 18       	stdsp	sp[0x4],r8
8000791c:	bf 58       	asr	r8,0x1f
8000791e:	50 08       	stdsp	sp[0x0],r8
80007920:	c4 88       	rjmp	800079b0 <_vfprintf_r+0x724>
80007922:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007926:	40 3c       	lddsp	r12,sp[0xc]
80007928:	58 0c       	cp.w	r12,0
8000792a:	c1 d0       	breq	80007964 <_vfprintf_r+0x6d8>
8000792c:	10 36       	cp.w	r6,r8
8000792e:	c0 64       	brge	8000793a <_vfprintf_r+0x6ae>
80007930:	fa cb f9 44 	sub	r11,sp,-1724
80007934:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007938:	c1 f8       	rjmp	80007976 <_vfprintf_r+0x6ea>
8000793a:	fa c8 f9 50 	sub	r8,sp,-1712
8000793e:	1a d8       	st.w	--sp,r8
80007940:	fa c8 fa b8 	sub	r8,sp,-1352
80007944:	0c 9b       	mov	r11,r6
80007946:	1a d8       	st.w	--sp,r8
80007948:	fa c8 fb b4 	sub	r8,sp,-1100
8000794c:	04 9a       	mov	r10,r2
8000794e:	1a d8       	st.w	--sp,r8
80007950:	08 9c       	mov	r12,r4
80007952:	fa c8 f9 40 	sub	r8,sp,-1728
80007956:	fa c9 ff b4 	sub	r9,sp,-76
8000795a:	fe b0 fb 01 	rcall	80006f5c <get_arg>
8000795e:	2f dd       	sub	sp,-12
80007960:	78 0b       	ld.w	r11,r12[0x0]
80007962:	c2 48       	rjmp	800079aa <_vfprintf_r+0x71e>
80007964:	ee ca ff ff 	sub	r10,r7,-1
80007968:	10 37       	cp.w	r7,r8
8000796a:	c0 94       	brge	8000797c <_vfprintf_r+0x6f0>
8000796c:	fa c9 f9 44 	sub	r9,sp,-1724
80007970:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007974:	14 97       	mov	r7,r10
80007976:	ec fb fd 88 	ld.w	r11,r6[-632]
8000797a:	c1 88       	rjmp	800079aa <_vfprintf_r+0x71e>
8000797c:	41 09       	lddsp	r9,sp[0x40]
8000797e:	59 f8       	cp.w	r8,31
80007980:	e0 89 00 11 	brgt	800079a2 <_vfprintf_r+0x716>
80007984:	f2 cb ff fc 	sub	r11,r9,-4
80007988:	51 0b       	stdsp	sp[0x40],r11
8000798a:	fa c6 f9 44 	sub	r6,sp,-1724
8000798e:	72 0b       	ld.w	r11,r9[0x0]
80007990:	ec 08 00 39 	add	r9,r6,r8<<0x3
80007994:	f3 4b fd 88 	st.w	r9[-632],r11
80007998:	2f f8       	sub	r8,-1
8000799a:	14 97       	mov	r7,r10
8000799c:	fb 48 06 b4 	st.w	sp[1716],r8
800079a0:	c0 58       	rjmp	800079aa <_vfprintf_r+0x71e>
800079a2:	72 0b       	ld.w	r11,r9[0x0]
800079a4:	14 97       	mov	r7,r10
800079a6:	2f c9       	sub	r9,-4
800079a8:	51 09       	stdsp	sp[0x40],r9
800079aa:	50 1b       	stdsp	sp[0x4],r11
800079ac:	bf 5b       	asr	r11,0x1f
800079ae:	50 0b       	stdsp	sp[0x0],r11
800079b0:	fa ea 00 00 	ld.d	r10,sp[0]
800079b4:	58 0a       	cp.w	r10,0
800079b6:	5c 2b       	cpc	r11
800079b8:	c0 e4       	brge	800079d4 <_vfprintf_r+0x748>
800079ba:	30 08       	mov	r8,0
800079bc:	fa ea 00 00 	ld.d	r10,sp[0]
800079c0:	30 09       	mov	r9,0
800079c2:	f0 0a 01 0a 	sub	r10,r8,r10
800079c6:	f2 0b 01 4b 	sbc	r11,r9,r11
800079ca:	32 d8       	mov	r8,45
800079cc:	fa eb 00 00 	st.d	sp[0],r10
800079d0:	fb 68 06 bb 	st.b	sp[1723],r8
800079d4:	30 18       	mov	r8,1
800079d6:	e0 8f 06 fa 	bral	800087ca <_vfprintf_r+0x153e>
800079da:	50 a7       	stdsp	sp[0x28],r7
800079dc:	50 80       	stdsp	sp[0x20],r0
800079de:	0c 97       	mov	r7,r6
800079e0:	04 94       	mov	r4,r2
800079e2:	06 96       	mov	r6,r3
800079e4:	02 92       	mov	r2,r1
800079e6:	40 93       	lddsp	r3,sp[0x24]
800079e8:	10 90       	mov	r0,r8
800079ea:	40 41       	lddsp	r1,sp[0x10]
800079ec:	0e 99       	mov	r9,r7
800079ee:	ed b5 00 03 	bld	r5,0x3
800079f2:	c4 11       	brne	80007a74 <_vfprintf_r+0x7e8>
800079f4:	fa f8 06 b4 	ld.w	r8,sp[1716]
800079f8:	40 3a       	lddsp	r10,sp[0xc]
800079fa:	58 0a       	cp.w	r10,0
800079fc:	c1 90       	breq	80007a2e <_vfprintf_r+0x7a2>
800079fe:	10 36       	cp.w	r6,r8
80007a00:	c6 45       	brlt	80007ac8 <_vfprintf_r+0x83c>
80007a02:	fa c8 f9 50 	sub	r8,sp,-1712
80007a06:	1a d8       	st.w	--sp,r8
80007a08:	fa c8 fa b8 	sub	r8,sp,-1352
80007a0c:	1a d8       	st.w	--sp,r8
80007a0e:	fa c8 fb b4 	sub	r8,sp,-1100
80007a12:	0c 9b       	mov	r11,r6
80007a14:	1a d8       	st.w	--sp,r8
80007a16:	04 9a       	mov	r10,r2
80007a18:	fa c8 f9 40 	sub	r8,sp,-1728
80007a1c:	fa c9 ff b4 	sub	r9,sp,-76
80007a20:	08 9c       	mov	r12,r4
80007a22:	fe b0 fa 9d 	rcall	80006f5c <get_arg>
80007a26:	2f dd       	sub	sp,-12
80007a28:	78 16       	ld.w	r6,r12[0x4]
80007a2a:	50 76       	stdsp	sp[0x1c],r6
80007a2c:	c4 88       	rjmp	80007abc <_vfprintf_r+0x830>
80007a2e:	2f f7       	sub	r7,-1
80007a30:	10 39       	cp.w	r9,r8
80007a32:	c0 c4       	brge	80007a4a <_vfprintf_r+0x7be>
80007a34:	fa ce f9 44 	sub	lr,sp,-1724
80007a38:	fc 06 00 36 	add	r6,lr,r6<<0x3
80007a3c:	ec fc fd 8c 	ld.w	r12,r6[-628]
80007a40:	50 7c       	stdsp	sp[0x1c],r12
80007a42:	ec f6 fd 88 	ld.w	r6,r6[-632]
80007a46:	50 56       	stdsp	sp[0x14],r6
80007a48:	c6 68       	rjmp	80007b14 <_vfprintf_r+0x888>
80007a4a:	41 09       	lddsp	r9,sp[0x40]
80007a4c:	59 f8       	cp.w	r8,31
80007a4e:	e0 89 00 10 	brgt	80007a6e <_vfprintf_r+0x7e2>
80007a52:	f2 ca ff f8 	sub	r10,r9,-8
80007a56:	72 1b       	ld.w	r11,r9[0x4]
80007a58:	51 0a       	stdsp	sp[0x40],r10
80007a5a:	72 09       	ld.w	r9,r9[0x0]
80007a5c:	fa ca f9 44 	sub	r10,sp,-1724
80007a60:	50 7b       	stdsp	sp[0x1c],r11
80007a62:	50 59       	stdsp	sp[0x14],r9
80007a64:	f4 08 00 39 	add	r9,r10,r8<<0x3
80007a68:	40 5b       	lddsp	r11,sp[0x14]
80007a6a:	40 7a       	lddsp	r10,sp[0x1c]
80007a6c:	c4 78       	rjmp	80007afa <_vfprintf_r+0x86e>
80007a6e:	72 18       	ld.w	r8,r9[0x4]
80007a70:	50 78       	stdsp	sp[0x1c],r8
80007a72:	c4 c8       	rjmp	80007b0a <_vfprintf_r+0x87e>
80007a74:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007a78:	40 3e       	lddsp	lr,sp[0xc]
80007a7a:	58 0e       	cp.w	lr,0
80007a7c:	c2 30       	breq	80007ac2 <_vfprintf_r+0x836>
80007a7e:	10 36       	cp.w	r6,r8
80007a80:	c0 94       	brge	80007a92 <_vfprintf_r+0x806>
80007a82:	fa cc f9 44 	sub	r12,sp,-1724
80007a86:	f8 06 00 36 	add	r6,r12,r6<<0x3
80007a8a:	ec fb fd 8c 	ld.w	r11,r6[-628]
80007a8e:	50 7b       	stdsp	sp[0x1c],r11
80007a90:	cd 9b       	rjmp	80007a42 <_vfprintf_r+0x7b6>
80007a92:	fa c8 f9 50 	sub	r8,sp,-1712
80007a96:	1a d8       	st.w	--sp,r8
80007a98:	fa c8 fa b8 	sub	r8,sp,-1352
80007a9c:	04 9a       	mov	r10,r2
80007a9e:	1a d8       	st.w	--sp,r8
80007aa0:	fa c8 fb b4 	sub	r8,sp,-1100
80007aa4:	0c 9b       	mov	r11,r6
80007aa6:	1a d8       	st.w	--sp,r8
80007aa8:	08 9c       	mov	r12,r4
80007aaa:	fa c8 f9 40 	sub	r8,sp,-1728
80007aae:	fa c9 ff b4 	sub	r9,sp,-76
80007ab2:	fe b0 fa 55 	rcall	80006f5c <get_arg>
80007ab6:	2f dd       	sub	sp,-12
80007ab8:	78 1a       	ld.w	r10,r12[0x4]
80007aba:	50 7a       	stdsp	sp[0x1c],r10
80007abc:	78 0c       	ld.w	r12,r12[0x0]
80007abe:	50 5c       	stdsp	sp[0x14],r12
80007ac0:	c2 a8       	rjmp	80007b14 <_vfprintf_r+0x888>
80007ac2:	2f f7       	sub	r7,-1
80007ac4:	10 39       	cp.w	r9,r8
80007ac6:	c0 94       	brge	80007ad8 <_vfprintf_r+0x84c>
80007ac8:	fa c9 f9 44 	sub	r9,sp,-1724
80007acc:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007ad0:	ec f8 fd 8c 	ld.w	r8,r6[-628]
80007ad4:	50 78       	stdsp	sp[0x1c],r8
80007ad6:	cb 6b       	rjmp	80007a42 <_vfprintf_r+0x7b6>
80007ad8:	41 09       	lddsp	r9,sp[0x40]
80007ada:	59 f8       	cp.w	r8,31
80007adc:	e0 89 00 15 	brgt	80007b06 <_vfprintf_r+0x87a>
80007ae0:	f2 ca ff f8 	sub	r10,r9,-8
80007ae4:	72 16       	ld.w	r6,r9[0x4]
80007ae6:	72 09       	ld.w	r9,r9[0x0]
80007ae8:	51 0a       	stdsp	sp[0x40],r10
80007aea:	50 59       	stdsp	sp[0x14],r9
80007aec:	fa ce f9 44 	sub	lr,sp,-1724
80007af0:	50 76       	stdsp	sp[0x1c],r6
80007af2:	fc 08 00 39 	add	r9,lr,r8<<0x3
80007af6:	40 5b       	lddsp	r11,sp[0x14]
80007af8:	0c 9a       	mov	r10,r6
80007afa:	f2 eb fd 88 	st.d	r9[-632],r10
80007afe:	2f f8       	sub	r8,-1
80007b00:	fb 48 06 b4 	st.w	sp[1716],r8
80007b04:	c0 88       	rjmp	80007b14 <_vfprintf_r+0x888>
80007b06:	72 1c       	ld.w	r12,r9[0x4]
80007b08:	50 7c       	stdsp	sp[0x1c],r12
80007b0a:	f2 c8 ff f8 	sub	r8,r9,-8
80007b0e:	51 08       	stdsp	sp[0x40],r8
80007b10:	72 09       	ld.w	r9,r9[0x0]
80007b12:	50 59       	stdsp	sp[0x14],r9
80007b14:	40 5b       	lddsp	r11,sp[0x14]
80007b16:	40 7a       	lddsp	r10,sp[0x1c]
80007b18:	e0 a0 19 54 	rcall	8000adc0 <__isinfd>
80007b1c:	18 96       	mov	r6,r12
80007b1e:	c1 70       	breq	80007b4c <_vfprintf_r+0x8c0>
80007b20:	30 08       	mov	r8,0
80007b22:	30 09       	mov	r9,0
80007b24:	40 5b       	lddsp	r11,sp[0x14]
80007b26:	40 7a       	lddsp	r10,sp[0x1c]
80007b28:	e0 a0 1d b4 	rcall	8000b690 <__avr32_f64_cmp_lt>
80007b2c:	c0 40       	breq	80007b34 <_vfprintf_r+0x8a8>
80007b2e:	32 d8       	mov	r8,45
80007b30:	fb 68 06 bb 	st.b	sp[1723],r8
80007b34:	fe c8 ab 08 	sub	r8,pc,-21752
80007b38:	fe c6 ab 08 	sub	r6,pc,-21752
80007b3c:	a7 d5       	cbr	r5,0x7
80007b3e:	e0 40 00 47 	cp.w	r0,71
80007b42:	f0 06 17 a0 	movle	r6,r8
80007b46:	30 32       	mov	r2,3
80007b48:	e0 8f 06 ce 	bral	800088e4 <_vfprintf_r+0x1658>
80007b4c:	40 5b       	lddsp	r11,sp[0x14]
80007b4e:	40 7a       	lddsp	r10,sp[0x1c]
80007b50:	e0 a0 19 4d 	rcall	8000adea <__isnand>
80007b54:	c0 e0       	breq	80007b70 <_vfprintf_r+0x8e4>
80007b56:	50 26       	stdsp	sp[0x8],r6
80007b58:	fe c8 ab 24 	sub	r8,pc,-21724
80007b5c:	fe c6 ab 24 	sub	r6,pc,-21724
80007b60:	a7 d5       	cbr	r5,0x7
80007b62:	e0 40 00 47 	cp.w	r0,71
80007b66:	f0 06 17 a0 	movle	r6,r8
80007b6a:	30 32       	mov	r2,3
80007b6c:	e0 8f 06 c2 	bral	800088f0 <_vfprintf_r+0x1664>
80007b70:	40 2a       	lddsp	r10,sp[0x8]
80007b72:	5b fa       	cp.w	r10,-1
80007b74:	c0 41       	brne	80007b7c <_vfprintf_r+0x8f0>
80007b76:	30 69       	mov	r9,6
80007b78:	50 29       	stdsp	sp[0x8],r9
80007b7a:	c1 18       	rjmp	80007b9c <_vfprintf_r+0x910>
80007b7c:	e0 40 00 47 	cp.w	r0,71
80007b80:	5f 09       	sreq	r9
80007b82:	e0 40 00 67 	cp.w	r0,103
80007b86:	5f 08       	sreq	r8
80007b88:	f3 e8 10 08 	or	r8,r9,r8
80007b8c:	f8 08 18 00 	cp.b	r8,r12
80007b90:	c0 60       	breq	80007b9c <_vfprintf_r+0x910>
80007b92:	40 28       	lddsp	r8,sp[0x8]
80007b94:	58 08       	cp.w	r8,0
80007b96:	f9 b8 00 01 	moveq	r8,1
80007b9a:	50 28       	stdsp	sp[0x8],r8
80007b9c:	40 78       	lddsp	r8,sp[0x1c]
80007b9e:	40 59       	lddsp	r9,sp[0x14]
80007ba0:	fa e9 06 94 	st.d	sp[1684],r8
80007ba4:	a9 a5       	sbr	r5,0x8
80007ba6:	fa f8 06 94 	ld.w	r8,sp[1684]
80007baa:	58 08       	cp.w	r8,0
80007bac:	c0 65       	brlt	80007bb8 <_vfprintf_r+0x92c>
80007bae:	40 5e       	lddsp	lr,sp[0x14]
80007bb0:	30 0c       	mov	r12,0
80007bb2:	50 6e       	stdsp	sp[0x18],lr
80007bb4:	50 9c       	stdsp	sp[0x24],r12
80007bb6:	c0 78       	rjmp	80007bc4 <_vfprintf_r+0x938>
80007bb8:	40 5b       	lddsp	r11,sp[0x14]
80007bba:	32 da       	mov	r10,45
80007bbc:	ee 1b 80 00 	eorh	r11,0x8000
80007bc0:	50 9a       	stdsp	sp[0x24],r10
80007bc2:	50 6b       	stdsp	sp[0x18],r11
80007bc4:	e0 40 00 46 	cp.w	r0,70
80007bc8:	5f 09       	sreq	r9
80007bca:	e0 40 00 66 	cp.w	r0,102
80007bce:	5f 08       	sreq	r8
80007bd0:	f3 e8 10 08 	or	r8,r9,r8
80007bd4:	50 48       	stdsp	sp[0x10],r8
80007bd6:	c0 40       	breq	80007bde <_vfprintf_r+0x952>
80007bd8:	40 22       	lddsp	r2,sp[0x8]
80007bda:	30 39       	mov	r9,3
80007bdc:	c1 08       	rjmp	80007bfc <_vfprintf_r+0x970>
80007bde:	e0 40 00 45 	cp.w	r0,69
80007be2:	5f 09       	sreq	r9
80007be4:	e0 40 00 65 	cp.w	r0,101
80007be8:	5f 08       	sreq	r8
80007bea:	40 22       	lddsp	r2,sp[0x8]
80007bec:	10 49       	or	r9,r8
80007bee:	2f f2       	sub	r2,-1
80007bf0:	40 46       	lddsp	r6,sp[0x10]
80007bf2:	ec 09 18 00 	cp.b	r9,r6
80007bf6:	fb f2 00 02 	ld.weq	r2,sp[0x8]
80007bfa:	30 29       	mov	r9,2
80007bfc:	fa c8 f9 5c 	sub	r8,sp,-1700
80007c00:	1a d8       	st.w	--sp,r8
80007c02:	fa c8 f9 54 	sub	r8,sp,-1708
80007c06:	1a d8       	st.w	--sp,r8
80007c08:	fa c8 f9 4c 	sub	r8,sp,-1716
80007c0c:	08 9c       	mov	r12,r4
80007c0e:	1a d8       	st.w	--sp,r8
80007c10:	04 98       	mov	r8,r2
80007c12:	40 9b       	lddsp	r11,sp[0x24]
80007c14:	40 aa       	lddsp	r10,sp[0x28]
80007c16:	e0 a0 0b c3 	rcall	8000939c <_dtoa_r>
80007c1a:	e0 40 00 47 	cp.w	r0,71
80007c1e:	5f 19       	srne	r9
80007c20:	e0 40 00 67 	cp.w	r0,103
80007c24:	5f 18       	srne	r8
80007c26:	18 96       	mov	r6,r12
80007c28:	2f dd       	sub	sp,-12
80007c2a:	f3 e8 00 08 	and	r8,r9,r8
80007c2e:	c0 41       	brne	80007c36 <_vfprintf_r+0x9aa>
80007c30:	ed b5 00 00 	bld	r5,0x0
80007c34:	c3 01       	brne	80007c94 <_vfprintf_r+0xa08>
80007c36:	ec 02 00 0e 	add	lr,r6,r2
80007c3a:	50 3e       	stdsp	sp[0xc],lr
80007c3c:	40 4c       	lddsp	r12,sp[0x10]
80007c3e:	58 0c       	cp.w	r12,0
80007c40:	c1 50       	breq	80007c6a <_vfprintf_r+0x9de>
80007c42:	0d 89       	ld.ub	r9,r6[0x0]
80007c44:	33 08       	mov	r8,48
80007c46:	f0 09 18 00 	cp.b	r9,r8
80007c4a:	c0 b1       	brne	80007c60 <_vfprintf_r+0x9d4>
80007c4c:	30 08       	mov	r8,0
80007c4e:	30 09       	mov	r9,0
80007c50:	40 6b       	lddsp	r11,sp[0x18]
80007c52:	40 7a       	lddsp	r10,sp[0x1c]
80007c54:	e0 a0 1c d7 	rcall	8000b602 <__avr32_f64_cmp_eq>
80007c58:	fb b2 00 01 	rsubeq	r2,1
80007c5c:	fb f2 0b ab 	st.weq	sp[0x6ac],r2
80007c60:	40 3b       	lddsp	r11,sp[0xc]
80007c62:	fa f8 06 ac 	ld.w	r8,sp[1708]
80007c66:	10 0b       	add	r11,r8
80007c68:	50 3b       	stdsp	sp[0xc],r11
80007c6a:	40 6b       	lddsp	r11,sp[0x18]
80007c6c:	30 08       	mov	r8,0
80007c6e:	30 09       	mov	r9,0
80007c70:	40 7a       	lddsp	r10,sp[0x1c]
80007c72:	e0 a0 1c c8 	rcall	8000b602 <__avr32_f64_cmp_eq>
80007c76:	c0 90       	breq	80007c88 <_vfprintf_r+0x9fc>
80007c78:	40 3a       	lddsp	r10,sp[0xc]
80007c7a:	fb 4a 06 a4 	st.w	sp[1700],r10
80007c7e:	c0 58       	rjmp	80007c88 <_vfprintf_r+0x9fc>
80007c80:	10 c9       	st.b	r8++,r9
80007c82:	fb 48 06 a4 	st.w	sp[1700],r8
80007c86:	c0 28       	rjmp	80007c8a <_vfprintf_r+0x9fe>
80007c88:	33 09       	mov	r9,48
80007c8a:	fa f8 06 a4 	ld.w	r8,sp[1700]
80007c8e:	40 3e       	lddsp	lr,sp[0xc]
80007c90:	1c 38       	cp.w	r8,lr
80007c92:	cf 73       	brcs	80007c80 <_vfprintf_r+0x9f4>
80007c94:	e0 40 00 47 	cp.w	r0,71
80007c98:	5f 09       	sreq	r9
80007c9a:	e0 40 00 67 	cp.w	r0,103
80007c9e:	5f 08       	sreq	r8
80007ca0:	f3 e8 10 08 	or	r8,r9,r8
80007ca4:	fa f9 06 a4 	ld.w	r9,sp[1700]
80007ca8:	0c 19       	sub	r9,r6
80007caa:	50 69       	stdsp	sp[0x18],r9
80007cac:	58 08       	cp.w	r8,0
80007cae:	c0 b0       	breq	80007cc4 <_vfprintf_r+0xa38>
80007cb0:	fa f8 06 ac 	ld.w	r8,sp[1708]
80007cb4:	5b d8       	cp.w	r8,-3
80007cb6:	c0 55       	brlt	80007cc0 <_vfprintf_r+0xa34>
80007cb8:	40 2c       	lddsp	r12,sp[0x8]
80007cba:	18 38       	cp.w	r8,r12
80007cbc:	e0 8a 00 6a 	brle	80007d90 <_vfprintf_r+0xb04>
80007cc0:	20 20       	sub	r0,2
80007cc2:	c0 58       	rjmp	80007ccc <_vfprintf_r+0xa40>
80007cc4:	e0 40 00 65 	cp.w	r0,101
80007cc8:	e0 89 00 46 	brgt	80007d54 <_vfprintf_r+0xac8>
80007ccc:	fa fb 06 ac 	ld.w	r11,sp[1708]
80007cd0:	fb 60 06 9c 	st.b	sp[1692],r0
80007cd4:	20 1b       	sub	r11,1
80007cd6:	fb 4b 06 ac 	st.w	sp[1708],r11
80007cda:	c0 47       	brpl	80007ce2 <_vfprintf_r+0xa56>
80007cdc:	5c 3b       	neg	r11
80007cde:	32 d8       	mov	r8,45
80007ce0:	c0 28       	rjmp	80007ce4 <_vfprintf_r+0xa58>
80007ce2:	32 b8       	mov	r8,43
80007ce4:	fb 68 06 9d 	st.b	sp[1693],r8
80007ce8:	58 9b       	cp.w	r11,9
80007cea:	e0 8a 00 1d 	brle	80007d24 <_vfprintf_r+0xa98>
80007cee:	fa c9 fa 35 	sub	r9,sp,-1483
80007cf2:	30 aa       	mov	r10,10
80007cf4:	12 98       	mov	r8,r9
80007cf6:	0e 9c       	mov	r12,r7
80007cf8:	0c 92       	mov	r2,r6
80007cfa:	f6 0a 0c 06 	divs	r6,r11,r10
80007cfe:	0e 9b       	mov	r11,r7
80007d00:	2d 0b       	sub	r11,-48
80007d02:	10 fb       	st.b	--r8,r11
80007d04:	0c 9b       	mov	r11,r6
80007d06:	58 96       	cp.w	r6,9
80007d08:	fe 99 ff f9 	brgt	80007cfa <_vfprintf_r+0xa6e>
80007d0c:	2d 0b       	sub	r11,-48
80007d0e:	18 97       	mov	r7,r12
80007d10:	04 96       	mov	r6,r2
80007d12:	10 fb       	st.b	--r8,r11
80007d14:	fa ca f9 62 	sub	r10,sp,-1694
80007d18:	c0 38       	rjmp	80007d1e <_vfprintf_r+0xa92>
80007d1a:	11 3b       	ld.ub	r11,r8++
80007d1c:	14 cb       	st.b	r10++,r11
80007d1e:	12 38       	cp.w	r8,r9
80007d20:	cf d3       	brcs	80007d1a <_vfprintf_r+0xa8e>
80007d22:	c0 98       	rjmp	80007d34 <_vfprintf_r+0xaa8>
80007d24:	2d 0b       	sub	r11,-48
80007d26:	33 08       	mov	r8,48
80007d28:	fb 6b 06 9f 	st.b	sp[1695],r11
80007d2c:	fb 68 06 9e 	st.b	sp[1694],r8
80007d30:	fa ca f9 60 	sub	r10,sp,-1696
80007d34:	fa c8 f9 64 	sub	r8,sp,-1692
80007d38:	f4 08 01 08 	sub	r8,r10,r8
80007d3c:	50 e8       	stdsp	sp[0x38],r8
80007d3e:	10 92       	mov	r2,r8
80007d40:	40 6b       	lddsp	r11,sp[0x18]
80007d42:	16 02       	add	r2,r11
80007d44:	58 1b       	cp.w	r11,1
80007d46:	e0 89 00 05 	brgt	80007d50 <_vfprintf_r+0xac4>
80007d4a:	ed b5 00 00 	bld	r5,0x0
80007d4e:	c3 51       	brne	80007db8 <_vfprintf_r+0xb2c>
80007d50:	2f f2       	sub	r2,-1
80007d52:	c3 38       	rjmp	80007db8 <_vfprintf_r+0xb2c>
80007d54:	e0 40 00 66 	cp.w	r0,102
80007d58:	c1 c1       	brne	80007d90 <_vfprintf_r+0xb04>
80007d5a:	fa f2 06 ac 	ld.w	r2,sp[1708]
80007d5e:	58 02       	cp.w	r2,0
80007d60:	e0 8a 00 0c 	brle	80007d78 <_vfprintf_r+0xaec>
80007d64:	40 2a       	lddsp	r10,sp[0x8]
80007d66:	58 0a       	cp.w	r10,0
80007d68:	c0 41       	brne	80007d70 <_vfprintf_r+0xae4>
80007d6a:	ed b5 00 00 	bld	r5,0x0
80007d6e:	c2 51       	brne	80007db8 <_vfprintf_r+0xb2c>
80007d70:	2f f2       	sub	r2,-1
80007d72:	40 29       	lddsp	r9,sp[0x8]
80007d74:	12 02       	add	r2,r9
80007d76:	c0 b8       	rjmp	80007d8c <_vfprintf_r+0xb00>
80007d78:	40 28       	lddsp	r8,sp[0x8]
80007d7a:	58 08       	cp.w	r8,0
80007d7c:	c0 61       	brne	80007d88 <_vfprintf_r+0xafc>
80007d7e:	ed b5 00 00 	bld	r5,0x0
80007d82:	c0 30       	breq	80007d88 <_vfprintf_r+0xafc>
80007d84:	30 12       	mov	r2,1
80007d86:	c1 98       	rjmp	80007db8 <_vfprintf_r+0xb2c>
80007d88:	40 22       	lddsp	r2,sp[0x8]
80007d8a:	2f e2       	sub	r2,-2
80007d8c:	36 60       	mov	r0,102
80007d8e:	c1 58       	rjmp	80007db8 <_vfprintf_r+0xb2c>
80007d90:	fa f2 06 ac 	ld.w	r2,sp[1708]
80007d94:	40 6e       	lddsp	lr,sp[0x18]
80007d96:	1c 32       	cp.w	r2,lr
80007d98:	c0 65       	brlt	80007da4 <_vfprintf_r+0xb18>
80007d9a:	ed b5 00 00 	bld	r5,0x0
80007d9e:	f7 b2 00 ff 	subeq	r2,-1
80007da2:	c0 a8       	rjmp	80007db6 <_vfprintf_r+0xb2a>
80007da4:	e4 08 11 02 	rsub	r8,r2,2
80007da8:	40 6c       	lddsp	r12,sp[0x18]
80007daa:	58 02       	cp.w	r2,0
80007dac:	f0 02 17 a0 	movle	r2,r8
80007db0:	f9 b2 09 01 	movgt	r2,1
80007db4:	18 02       	add	r2,r12
80007db6:	36 70       	mov	r0,103
80007db8:	40 9b       	lddsp	r11,sp[0x24]
80007dba:	58 0b       	cp.w	r11,0
80007dbc:	e0 80 05 94 	breq	800088e4 <_vfprintf_r+0x1658>
80007dc0:	32 d8       	mov	r8,45
80007dc2:	fb 68 06 bb 	st.b	sp[1723],r8
80007dc6:	e0 8f 05 93 	bral	800088ec <_vfprintf_r+0x1660>
80007dca:	50 a7       	stdsp	sp[0x28],r7
80007dcc:	04 94       	mov	r4,r2
80007dce:	0c 97       	mov	r7,r6
80007dd0:	02 92       	mov	r2,r1
80007dd2:	06 96       	mov	r6,r3
80007dd4:	40 41       	lddsp	r1,sp[0x10]
80007dd6:	40 93       	lddsp	r3,sp[0x24]
80007dd8:	0e 99       	mov	r9,r7
80007dda:	ed b5 00 05 	bld	r5,0x5
80007dde:	c4 81       	brne	80007e6e <_vfprintf_r+0xbe2>
80007de0:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007de4:	40 3e       	lddsp	lr,sp[0xc]
80007de6:	58 0e       	cp.w	lr,0
80007de8:	c1 d0       	breq	80007e22 <_vfprintf_r+0xb96>
80007dea:	10 36       	cp.w	r6,r8
80007dec:	c0 64       	brge	80007df8 <_vfprintf_r+0xb6c>
80007dee:	fa cc f9 44 	sub	r12,sp,-1724
80007df2:	f8 06 00 36 	add	r6,r12,r6<<0x3
80007df6:	c1 d8       	rjmp	80007e30 <_vfprintf_r+0xba4>
80007df8:	fa c8 f9 50 	sub	r8,sp,-1712
80007dfc:	1a d8       	st.w	--sp,r8
80007dfe:	fa c8 fa b8 	sub	r8,sp,-1352
80007e02:	04 9a       	mov	r10,r2
80007e04:	1a d8       	st.w	--sp,r8
80007e06:	fa c8 fb b4 	sub	r8,sp,-1100
80007e0a:	0c 9b       	mov	r11,r6
80007e0c:	1a d8       	st.w	--sp,r8
80007e0e:	08 9c       	mov	r12,r4
80007e10:	fa c8 f9 40 	sub	r8,sp,-1728
80007e14:	fa c9 ff b4 	sub	r9,sp,-76
80007e18:	fe b0 f8 a2 	rcall	80006f5c <get_arg>
80007e1c:	2f dd       	sub	sp,-12
80007e1e:	78 0a       	ld.w	r10,r12[0x0]
80007e20:	c2 08       	rjmp	80007e60 <_vfprintf_r+0xbd4>
80007e22:	2f f7       	sub	r7,-1
80007e24:	10 39       	cp.w	r9,r8
80007e26:	c0 84       	brge	80007e36 <_vfprintf_r+0xbaa>
80007e28:	fa cb f9 44 	sub	r11,sp,-1724
80007e2c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007e30:	ec fa fd 88 	ld.w	r10,r6[-632]
80007e34:	c1 68       	rjmp	80007e60 <_vfprintf_r+0xbd4>
80007e36:	41 09       	lddsp	r9,sp[0x40]
80007e38:	59 f8       	cp.w	r8,31
80007e3a:	e0 89 00 10 	brgt	80007e5a <_vfprintf_r+0xbce>
80007e3e:	f2 ca ff fc 	sub	r10,r9,-4
80007e42:	51 0a       	stdsp	sp[0x40],r10
80007e44:	fa c6 f9 44 	sub	r6,sp,-1724
80007e48:	72 0a       	ld.w	r10,r9[0x0]
80007e4a:	ec 08 00 39 	add	r9,r6,r8<<0x3
80007e4e:	f3 4a fd 88 	st.w	r9[-632],r10
80007e52:	2f f8       	sub	r8,-1
80007e54:	fb 48 06 b4 	st.w	sp[1716],r8
80007e58:	c0 48       	rjmp	80007e60 <_vfprintf_r+0xbd4>
80007e5a:	72 0a       	ld.w	r10,r9[0x0]
80007e5c:	2f c9       	sub	r9,-4
80007e5e:	51 09       	stdsp	sp[0x40],r9
80007e60:	40 be       	lddsp	lr,sp[0x2c]
80007e62:	1c 98       	mov	r8,lr
80007e64:	95 1e       	st.w	r10[0x4],lr
80007e66:	bf 58       	asr	r8,0x1f
80007e68:	95 08       	st.w	r10[0x0],r8
80007e6a:	fe 9f fa 9f 	bral	800073a8 <_vfprintf_r+0x11c>
80007e6e:	ed b5 00 04 	bld	r5,0x4
80007e72:	c4 80       	breq	80007f02 <_vfprintf_r+0xc76>
80007e74:	e2 15 00 40 	andl	r5,0x40,COH
80007e78:	c4 50       	breq	80007f02 <_vfprintf_r+0xc76>
80007e7a:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007e7e:	40 3c       	lddsp	r12,sp[0xc]
80007e80:	58 0c       	cp.w	r12,0
80007e82:	c1 d0       	breq	80007ebc <_vfprintf_r+0xc30>
80007e84:	10 36       	cp.w	r6,r8
80007e86:	c0 64       	brge	80007e92 <_vfprintf_r+0xc06>
80007e88:	fa cb f9 44 	sub	r11,sp,-1724
80007e8c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007e90:	c1 d8       	rjmp	80007eca <_vfprintf_r+0xc3e>
80007e92:	fa c8 f9 50 	sub	r8,sp,-1712
80007e96:	1a d8       	st.w	--sp,r8
80007e98:	fa c8 fa b8 	sub	r8,sp,-1352
80007e9c:	04 9a       	mov	r10,r2
80007e9e:	1a d8       	st.w	--sp,r8
80007ea0:	fa c8 fb b4 	sub	r8,sp,-1100
80007ea4:	0c 9b       	mov	r11,r6
80007ea6:	1a d8       	st.w	--sp,r8
80007ea8:	08 9c       	mov	r12,r4
80007eaa:	fa c8 f9 40 	sub	r8,sp,-1728
80007eae:	fa c9 ff b4 	sub	r9,sp,-76
80007eb2:	fe b0 f8 55 	rcall	80006f5c <get_arg>
80007eb6:	2f dd       	sub	sp,-12
80007eb8:	78 0a       	ld.w	r10,r12[0x0]
80007eba:	c2 08       	rjmp	80007efa <_vfprintf_r+0xc6e>
80007ebc:	2f f7       	sub	r7,-1
80007ebe:	10 39       	cp.w	r9,r8
80007ec0:	c0 84       	brge	80007ed0 <_vfprintf_r+0xc44>
80007ec2:	fa ca f9 44 	sub	r10,sp,-1724
80007ec6:	f4 06 00 36 	add	r6,r10,r6<<0x3
80007eca:	ec fa fd 88 	ld.w	r10,r6[-632]
80007ece:	c1 68       	rjmp	80007efa <_vfprintf_r+0xc6e>
80007ed0:	41 09       	lddsp	r9,sp[0x40]
80007ed2:	59 f8       	cp.w	r8,31
80007ed4:	e0 89 00 10 	brgt	80007ef4 <_vfprintf_r+0xc68>
80007ed8:	f2 ca ff fc 	sub	r10,r9,-4
80007edc:	51 0a       	stdsp	sp[0x40],r10
80007ede:	fa c6 f9 44 	sub	r6,sp,-1724
80007ee2:	72 0a       	ld.w	r10,r9[0x0]
80007ee4:	ec 08 00 39 	add	r9,r6,r8<<0x3
80007ee8:	f3 4a fd 88 	st.w	r9[-632],r10
80007eec:	2f f8       	sub	r8,-1
80007eee:	fb 48 06 b4 	st.w	sp[1716],r8
80007ef2:	c0 48       	rjmp	80007efa <_vfprintf_r+0xc6e>
80007ef4:	72 0a       	ld.w	r10,r9[0x0]
80007ef6:	2f c9       	sub	r9,-4
80007ef8:	51 09       	stdsp	sp[0x40],r9
80007efa:	40 be       	lddsp	lr,sp[0x2c]
80007efc:	b4 0e       	st.h	r10[0x0],lr
80007efe:	fe 9f fa 55 	bral	800073a8 <_vfprintf_r+0x11c>
80007f02:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007f06:	40 3c       	lddsp	r12,sp[0xc]
80007f08:	58 0c       	cp.w	r12,0
80007f0a:	c1 d0       	breq	80007f44 <_vfprintf_r+0xcb8>
80007f0c:	10 36       	cp.w	r6,r8
80007f0e:	c0 64       	brge	80007f1a <_vfprintf_r+0xc8e>
80007f10:	fa cb f9 44 	sub	r11,sp,-1724
80007f14:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007f18:	c1 d8       	rjmp	80007f52 <_vfprintf_r+0xcc6>
80007f1a:	fa c8 f9 50 	sub	r8,sp,-1712
80007f1e:	1a d8       	st.w	--sp,r8
80007f20:	fa c8 fa b8 	sub	r8,sp,-1352
80007f24:	04 9a       	mov	r10,r2
80007f26:	1a d8       	st.w	--sp,r8
80007f28:	fa c8 fb b4 	sub	r8,sp,-1100
80007f2c:	0c 9b       	mov	r11,r6
80007f2e:	1a d8       	st.w	--sp,r8
80007f30:	08 9c       	mov	r12,r4
80007f32:	fa c8 f9 40 	sub	r8,sp,-1728
80007f36:	fa c9 ff b4 	sub	r9,sp,-76
80007f3a:	fe b0 f8 11 	rcall	80006f5c <get_arg>
80007f3e:	2f dd       	sub	sp,-12
80007f40:	78 0a       	ld.w	r10,r12[0x0]
80007f42:	c2 08       	rjmp	80007f82 <_vfprintf_r+0xcf6>
80007f44:	2f f7       	sub	r7,-1
80007f46:	10 39       	cp.w	r9,r8
80007f48:	c0 84       	brge	80007f58 <_vfprintf_r+0xccc>
80007f4a:	fa ca f9 44 	sub	r10,sp,-1724
80007f4e:	f4 06 00 36 	add	r6,r10,r6<<0x3
80007f52:	ec fa fd 88 	ld.w	r10,r6[-632]
80007f56:	c1 68       	rjmp	80007f82 <_vfprintf_r+0xcf6>
80007f58:	41 09       	lddsp	r9,sp[0x40]
80007f5a:	59 f8       	cp.w	r8,31
80007f5c:	e0 89 00 10 	brgt	80007f7c <_vfprintf_r+0xcf0>
80007f60:	f2 ca ff fc 	sub	r10,r9,-4
80007f64:	51 0a       	stdsp	sp[0x40],r10
80007f66:	fa c6 f9 44 	sub	r6,sp,-1724
80007f6a:	72 0a       	ld.w	r10,r9[0x0]
80007f6c:	ec 08 00 39 	add	r9,r6,r8<<0x3
80007f70:	f3 4a fd 88 	st.w	r9[-632],r10
80007f74:	2f f8       	sub	r8,-1
80007f76:	fb 48 06 b4 	st.w	sp[1716],r8
80007f7a:	c0 48       	rjmp	80007f82 <_vfprintf_r+0xcf6>
80007f7c:	72 0a       	ld.w	r10,r9[0x0]
80007f7e:	2f c9       	sub	r9,-4
80007f80:	51 09       	stdsp	sp[0x40],r9
80007f82:	40 be       	lddsp	lr,sp[0x2c]
80007f84:	95 0e       	st.w	r10[0x0],lr
80007f86:	fe 9f fa 11 	bral	800073a8 <_vfprintf_r+0x11c>
80007f8a:	50 a7       	stdsp	sp[0x28],r7
80007f8c:	50 80       	stdsp	sp[0x20],r0
80007f8e:	0c 97       	mov	r7,r6
80007f90:	04 94       	mov	r4,r2
80007f92:	06 96       	mov	r6,r3
80007f94:	02 92       	mov	r2,r1
80007f96:	40 93       	lddsp	r3,sp[0x24]
80007f98:	10 90       	mov	r0,r8
80007f9a:	40 41       	lddsp	r1,sp[0x10]
80007f9c:	a5 a5       	sbr	r5,0x4
80007f9e:	c0 a8       	rjmp	80007fb2 <_vfprintf_r+0xd26>
80007fa0:	50 a7       	stdsp	sp[0x28],r7
80007fa2:	50 80       	stdsp	sp[0x20],r0
80007fa4:	0c 97       	mov	r7,r6
80007fa6:	04 94       	mov	r4,r2
80007fa8:	06 96       	mov	r6,r3
80007faa:	02 92       	mov	r2,r1
80007fac:	40 93       	lddsp	r3,sp[0x24]
80007fae:	10 90       	mov	r0,r8
80007fb0:	40 41       	lddsp	r1,sp[0x10]
80007fb2:	ed b5 00 05 	bld	r5,0x5
80007fb6:	c5 d1       	brne	80008070 <_vfprintf_r+0xde4>
80007fb8:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007fbc:	40 3c       	lddsp	r12,sp[0xc]
80007fbe:	58 0c       	cp.w	r12,0
80007fc0:	c2 60       	breq	8000800c <_vfprintf_r+0xd80>
80007fc2:	10 36       	cp.w	r6,r8
80007fc4:	c0 a4       	brge	80007fd8 <_vfprintf_r+0xd4c>
80007fc6:	fa cb f9 44 	sub	r11,sp,-1724
80007fca:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007fce:	ec e8 fd 88 	ld.d	r8,r6[-632]
80007fd2:	fa e9 00 00 	st.d	sp[0],r8
80007fd6:	c1 88       	rjmp	80008006 <_vfprintf_r+0xd7a>
80007fd8:	fa c8 f9 50 	sub	r8,sp,-1712
80007fdc:	1a d8       	st.w	--sp,r8
80007fde:	fa c8 fa b8 	sub	r8,sp,-1352
80007fe2:	04 9a       	mov	r10,r2
80007fe4:	1a d8       	st.w	--sp,r8
80007fe6:	0c 9b       	mov	r11,r6
80007fe8:	fa c8 fb b4 	sub	r8,sp,-1100
80007fec:	08 9c       	mov	r12,r4
80007fee:	1a d8       	st.w	--sp,r8
80007ff0:	fa c8 f9 40 	sub	r8,sp,-1728
80007ff4:	fa c9 ff b4 	sub	r9,sp,-76
80007ff8:	fe b0 f7 b2 	rcall	80006f5c <get_arg>
80007ffc:	2f dd       	sub	sp,-12
80007ffe:	f8 ea 00 00 	ld.d	r10,r12[0]
80008002:	fa eb 00 00 	st.d	sp[0],r10
80008006:	30 08       	mov	r8,0
80008008:	e0 8f 03 de 	bral	800087c4 <_vfprintf_r+0x1538>
8000800c:	ee ca ff ff 	sub	r10,r7,-1
80008010:	10 37       	cp.w	r7,r8
80008012:	c0 b4       	brge	80008028 <_vfprintf_r+0xd9c>
80008014:	fa c9 f9 44 	sub	r9,sp,-1724
80008018:	14 97       	mov	r7,r10
8000801a:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000801e:	ec ea fd 88 	ld.d	r10,r6[-632]
80008022:	fa eb 00 00 	st.d	sp[0],r10
80008026:	c1 88       	rjmp	80008056 <_vfprintf_r+0xdca>
80008028:	41 09       	lddsp	r9,sp[0x40]
8000802a:	59 f8       	cp.w	r8,31
8000802c:	e0 89 00 18 	brgt	8000805c <_vfprintf_r+0xdd0>
80008030:	f2 e6 00 00 	ld.d	r6,r9[0]
80008034:	f2 cb ff f8 	sub	r11,r9,-8
80008038:	fa e7 00 00 	st.d	sp[0],r6
8000803c:	51 0b       	stdsp	sp[0x40],r11
8000803e:	fa c6 f9 44 	sub	r6,sp,-1724
80008042:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008046:	fa e6 00 00 	ld.d	r6,sp[0]
8000804a:	f2 e7 fd 88 	st.d	r9[-632],r6
8000804e:	2f f8       	sub	r8,-1
80008050:	14 97       	mov	r7,r10
80008052:	fb 48 06 b4 	st.w	sp[1716],r8
80008056:	40 38       	lddsp	r8,sp[0xc]
80008058:	e0 8f 03 b6 	bral	800087c4 <_vfprintf_r+0x1538>
8000805c:	f2 e6 00 00 	ld.d	r6,r9[0]
80008060:	40 38       	lddsp	r8,sp[0xc]
80008062:	fa e7 00 00 	st.d	sp[0],r6
80008066:	2f 89       	sub	r9,-8
80008068:	14 97       	mov	r7,r10
8000806a:	51 09       	stdsp	sp[0x40],r9
8000806c:	e0 8f 03 ac 	bral	800087c4 <_vfprintf_r+0x1538>
80008070:	ed b5 00 04 	bld	r5,0x4
80008074:	c1 61       	brne	800080a0 <_vfprintf_r+0xe14>
80008076:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000807a:	40 3e       	lddsp	lr,sp[0xc]
8000807c:	58 0e       	cp.w	lr,0
8000807e:	c0 80       	breq	8000808e <_vfprintf_r+0xe02>
80008080:	10 36       	cp.w	r6,r8
80008082:	c6 74       	brge	80008150 <_vfprintf_r+0xec4>
80008084:	fa cc f9 44 	sub	r12,sp,-1724
80008088:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000808c:	c8 08       	rjmp	8000818c <_vfprintf_r+0xf00>
8000808e:	ee ca ff ff 	sub	r10,r7,-1
80008092:	10 37       	cp.w	r7,r8
80008094:	c7 f4       	brge	80008192 <_vfprintf_r+0xf06>
80008096:	fa cb f9 44 	sub	r11,sp,-1724
8000809a:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000809e:	c7 68       	rjmp	8000818a <_vfprintf_r+0xefe>
800080a0:	ed b5 00 06 	bld	r5,0x6
800080a4:	c4 a1       	brne	80008138 <_vfprintf_r+0xeac>
800080a6:	fa f8 06 b4 	ld.w	r8,sp[1716]
800080aa:	40 3c       	lddsp	r12,sp[0xc]
800080ac:	58 0c       	cp.w	r12,0
800080ae:	c1 d0       	breq	800080e8 <_vfprintf_r+0xe5c>
800080b0:	10 36       	cp.w	r6,r8
800080b2:	c0 64       	brge	800080be <_vfprintf_r+0xe32>
800080b4:	fa cb f9 44 	sub	r11,sp,-1724
800080b8:	f6 06 00 36 	add	r6,r11,r6<<0x3
800080bc:	c1 f8       	rjmp	800080fa <_vfprintf_r+0xe6e>
800080be:	fa c8 f9 50 	sub	r8,sp,-1712
800080c2:	1a d8       	st.w	--sp,r8
800080c4:	fa c8 fa b8 	sub	r8,sp,-1352
800080c8:	1a d8       	st.w	--sp,r8
800080ca:	fa c8 fb b4 	sub	r8,sp,-1100
800080ce:	1a d8       	st.w	--sp,r8
800080d0:	fa c8 f9 40 	sub	r8,sp,-1728
800080d4:	fa c9 ff b4 	sub	r9,sp,-76
800080d8:	04 9a       	mov	r10,r2
800080da:	0c 9b       	mov	r11,r6
800080dc:	08 9c       	mov	r12,r4
800080de:	fe b0 f7 3f 	rcall	80006f5c <get_arg>
800080e2:	2f dd       	sub	sp,-12
800080e4:	98 18       	ld.sh	r8,r12[0x2]
800080e6:	c2 68       	rjmp	80008132 <_vfprintf_r+0xea6>
800080e8:	ee ca ff ff 	sub	r10,r7,-1
800080ec:	10 37       	cp.w	r7,r8
800080ee:	c0 94       	brge	80008100 <_vfprintf_r+0xe74>
800080f0:	fa c9 f9 44 	sub	r9,sp,-1724
800080f4:	14 97       	mov	r7,r10
800080f6:	f2 06 00 36 	add	r6,r9,r6<<0x3
800080fa:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
800080fe:	c1 a8       	rjmp	80008132 <_vfprintf_r+0xea6>
80008100:	41 09       	lddsp	r9,sp[0x40]
80008102:	59 f8       	cp.w	r8,31
80008104:	e0 89 00 13 	brgt	8000812a <_vfprintf_r+0xe9e>
80008108:	f2 cb ff fc 	sub	r11,r9,-4
8000810c:	51 0b       	stdsp	sp[0x40],r11
8000810e:	72 09       	ld.w	r9,r9[0x0]
80008110:	fa c6 f9 44 	sub	r6,sp,-1724
80008114:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80008118:	2f f8       	sub	r8,-1
8000811a:	f7 49 fd 88 	st.w	r11[-632],r9
8000811e:	fb 48 06 b4 	st.w	sp[1716],r8
80008122:	14 97       	mov	r7,r10
80008124:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80008128:	c0 58       	rjmp	80008132 <_vfprintf_r+0xea6>
8000812a:	92 18       	ld.sh	r8,r9[0x2]
8000812c:	14 97       	mov	r7,r10
8000812e:	2f c9       	sub	r9,-4
80008130:	51 09       	stdsp	sp[0x40],r9
80008132:	5c 78       	castu.h	r8
80008134:	50 18       	stdsp	sp[0x4],r8
80008136:	c4 68       	rjmp	800081c2 <_vfprintf_r+0xf36>
80008138:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000813c:	40 3c       	lddsp	r12,sp[0xc]
8000813e:	58 0c       	cp.w	r12,0
80008140:	c1 d0       	breq	8000817a <_vfprintf_r+0xeee>
80008142:	10 36       	cp.w	r6,r8
80008144:	c0 64       	brge	80008150 <_vfprintf_r+0xec4>
80008146:	fa cb f9 44 	sub	r11,sp,-1724
8000814a:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000814e:	c1 f8       	rjmp	8000818c <_vfprintf_r+0xf00>
80008150:	fa c8 f9 50 	sub	r8,sp,-1712
80008154:	1a d8       	st.w	--sp,r8
80008156:	fa c8 fa b8 	sub	r8,sp,-1352
8000815a:	0c 9b       	mov	r11,r6
8000815c:	1a d8       	st.w	--sp,r8
8000815e:	fa c8 fb b4 	sub	r8,sp,-1100
80008162:	04 9a       	mov	r10,r2
80008164:	1a d8       	st.w	--sp,r8
80008166:	08 9c       	mov	r12,r4
80008168:	fa c8 f9 40 	sub	r8,sp,-1728
8000816c:	fa c9 ff b4 	sub	r9,sp,-76
80008170:	fe b0 f6 f6 	rcall	80006f5c <get_arg>
80008174:	2f dd       	sub	sp,-12
80008176:	78 0b       	ld.w	r11,r12[0x0]
80008178:	c2 48       	rjmp	800081c0 <_vfprintf_r+0xf34>
8000817a:	ee ca ff ff 	sub	r10,r7,-1
8000817e:	10 37       	cp.w	r7,r8
80008180:	c0 94       	brge	80008192 <_vfprintf_r+0xf06>
80008182:	fa c9 f9 44 	sub	r9,sp,-1724
80008186:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000818a:	14 97       	mov	r7,r10
8000818c:	ec fb fd 88 	ld.w	r11,r6[-632]
80008190:	c1 88       	rjmp	800081c0 <_vfprintf_r+0xf34>
80008192:	41 09       	lddsp	r9,sp[0x40]
80008194:	59 f8       	cp.w	r8,31
80008196:	e0 89 00 11 	brgt	800081b8 <_vfprintf_r+0xf2c>
8000819a:	f2 cb ff fc 	sub	r11,r9,-4
8000819e:	51 0b       	stdsp	sp[0x40],r11
800081a0:	fa c6 f9 44 	sub	r6,sp,-1724
800081a4:	72 0b       	ld.w	r11,r9[0x0]
800081a6:	ec 08 00 39 	add	r9,r6,r8<<0x3
800081aa:	f3 4b fd 88 	st.w	r9[-632],r11
800081ae:	2f f8       	sub	r8,-1
800081b0:	14 97       	mov	r7,r10
800081b2:	fb 48 06 b4 	st.w	sp[1716],r8
800081b6:	c0 58       	rjmp	800081c0 <_vfprintf_r+0xf34>
800081b8:	72 0b       	ld.w	r11,r9[0x0]
800081ba:	14 97       	mov	r7,r10
800081bc:	2f c9       	sub	r9,-4
800081be:	51 09       	stdsp	sp[0x40],r9
800081c0:	50 1b       	stdsp	sp[0x4],r11
800081c2:	30 0e       	mov	lr,0
800081c4:	50 0e       	stdsp	sp[0x0],lr
800081c6:	1c 98       	mov	r8,lr
800081c8:	e0 8f 02 fe 	bral	800087c4 <_vfprintf_r+0x1538>
800081cc:	50 a7       	stdsp	sp[0x28],r7
800081ce:	50 80       	stdsp	sp[0x20],r0
800081d0:	0c 97       	mov	r7,r6
800081d2:	04 94       	mov	r4,r2
800081d4:	06 96       	mov	r6,r3
800081d6:	02 92       	mov	r2,r1
800081d8:	40 93       	lddsp	r3,sp[0x24]
800081da:	40 41       	lddsp	r1,sp[0x10]
800081dc:	0e 99       	mov	r9,r7
800081de:	fa f8 06 b4 	ld.w	r8,sp[1716]
800081e2:	40 3c       	lddsp	r12,sp[0xc]
800081e4:	58 0c       	cp.w	r12,0
800081e6:	c1 d0       	breq	80008220 <_vfprintf_r+0xf94>
800081e8:	10 36       	cp.w	r6,r8
800081ea:	c0 64       	brge	800081f6 <_vfprintf_r+0xf6a>
800081ec:	fa cb f9 44 	sub	r11,sp,-1724
800081f0:	f6 06 00 36 	add	r6,r11,r6<<0x3
800081f4:	c1 d8       	rjmp	8000822e <_vfprintf_r+0xfa2>
800081f6:	fa c8 f9 50 	sub	r8,sp,-1712
800081fa:	1a d8       	st.w	--sp,r8
800081fc:	fa c8 fa b8 	sub	r8,sp,-1352
80008200:	1a d8       	st.w	--sp,r8
80008202:	fa c8 fb b4 	sub	r8,sp,-1100
80008206:	1a d8       	st.w	--sp,r8
80008208:	fa c9 ff b4 	sub	r9,sp,-76
8000820c:	fa c8 f9 40 	sub	r8,sp,-1728
80008210:	04 9a       	mov	r10,r2
80008212:	0c 9b       	mov	r11,r6
80008214:	08 9c       	mov	r12,r4
80008216:	fe b0 f6 a3 	rcall	80006f5c <get_arg>
8000821a:	2f dd       	sub	sp,-12
8000821c:	78 09       	ld.w	r9,r12[0x0]
8000821e:	c2 18       	rjmp	80008260 <_vfprintf_r+0xfd4>
80008220:	2f f7       	sub	r7,-1
80008222:	10 39       	cp.w	r9,r8
80008224:	c0 84       	brge	80008234 <_vfprintf_r+0xfa8>
80008226:	fa ca f9 44 	sub	r10,sp,-1724
8000822a:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000822e:	ec f9 fd 88 	ld.w	r9,r6[-632]
80008232:	c1 78       	rjmp	80008260 <_vfprintf_r+0xfd4>
80008234:	41 09       	lddsp	r9,sp[0x40]
80008236:	59 f8       	cp.w	r8,31
80008238:	e0 89 00 10 	brgt	80008258 <_vfprintf_r+0xfcc>
8000823c:	f2 ca ff fc 	sub	r10,r9,-4
80008240:	51 0a       	stdsp	sp[0x40],r10
80008242:	fa c6 f9 44 	sub	r6,sp,-1724
80008246:	72 09       	ld.w	r9,r9[0x0]
80008248:	ec 08 00 3a 	add	r10,r6,r8<<0x3
8000824c:	f5 49 fd 88 	st.w	r10[-632],r9
80008250:	2f f8       	sub	r8,-1
80008252:	fb 48 06 b4 	st.w	sp[1716],r8
80008256:	c0 58       	rjmp	80008260 <_vfprintf_r+0xfd4>
80008258:	f2 c8 ff fc 	sub	r8,r9,-4
8000825c:	51 08       	stdsp	sp[0x40],r8
8000825e:	72 09       	ld.w	r9,r9[0x0]
80008260:	33 08       	mov	r8,48
80008262:	fb 68 06 b8 	st.b	sp[1720],r8
80008266:	37 88       	mov	r8,120
80008268:	30 0e       	mov	lr,0
8000826a:	fb 68 06 b9 	st.b	sp[1721],r8
8000826e:	fe cc b2 32 	sub	r12,pc,-19918
80008272:	50 19       	stdsp	sp[0x4],r9
80008274:	a1 b5       	sbr	r5,0x1
80008276:	50 0e       	stdsp	sp[0x0],lr
80008278:	50 dc       	stdsp	sp[0x34],r12
8000827a:	30 28       	mov	r8,2
8000827c:	37 80       	mov	r0,120
8000827e:	e0 8f 02 a3 	bral	800087c4 <_vfprintf_r+0x1538>
80008282:	50 a7       	stdsp	sp[0x28],r7
80008284:	50 80       	stdsp	sp[0x20],r0
80008286:	10 90       	mov	r0,r8
80008288:	30 08       	mov	r8,0
8000828a:	fb 68 06 bb 	st.b	sp[1723],r8
8000828e:	0c 97       	mov	r7,r6
80008290:	04 94       	mov	r4,r2
80008292:	06 96       	mov	r6,r3
80008294:	02 92       	mov	r2,r1
80008296:	40 93       	lddsp	r3,sp[0x24]
80008298:	40 41       	lddsp	r1,sp[0x10]
8000829a:	0e 99       	mov	r9,r7
8000829c:	fa f8 06 b4 	ld.w	r8,sp[1716]
800082a0:	40 3b       	lddsp	r11,sp[0xc]
800082a2:	58 0b       	cp.w	r11,0
800082a4:	c1 d0       	breq	800082de <_vfprintf_r+0x1052>
800082a6:	10 36       	cp.w	r6,r8
800082a8:	c0 64       	brge	800082b4 <_vfprintf_r+0x1028>
800082aa:	fa ca f9 44 	sub	r10,sp,-1724
800082ae:	f4 06 00 36 	add	r6,r10,r6<<0x3
800082b2:	c1 d8       	rjmp	800082ec <_vfprintf_r+0x1060>
800082b4:	fa c8 f9 50 	sub	r8,sp,-1712
800082b8:	1a d8       	st.w	--sp,r8
800082ba:	fa c8 fa b8 	sub	r8,sp,-1352
800082be:	1a d8       	st.w	--sp,r8
800082c0:	fa c8 fb b4 	sub	r8,sp,-1100
800082c4:	0c 9b       	mov	r11,r6
800082c6:	1a d8       	st.w	--sp,r8
800082c8:	04 9a       	mov	r10,r2
800082ca:	fa c8 f9 40 	sub	r8,sp,-1728
800082ce:	fa c9 ff b4 	sub	r9,sp,-76
800082d2:	08 9c       	mov	r12,r4
800082d4:	fe b0 f6 44 	rcall	80006f5c <get_arg>
800082d8:	2f dd       	sub	sp,-12
800082da:	78 06       	ld.w	r6,r12[0x0]
800082dc:	c2 08       	rjmp	8000831c <_vfprintf_r+0x1090>
800082de:	2f f7       	sub	r7,-1
800082e0:	10 39       	cp.w	r9,r8
800082e2:	c0 84       	brge	800082f2 <_vfprintf_r+0x1066>
800082e4:	fa c9 f9 44 	sub	r9,sp,-1724
800082e8:	f2 06 00 36 	add	r6,r9,r6<<0x3
800082ec:	ec f6 fd 88 	ld.w	r6,r6[-632]
800082f0:	c1 68       	rjmp	8000831c <_vfprintf_r+0x1090>
800082f2:	41 09       	lddsp	r9,sp[0x40]
800082f4:	59 f8       	cp.w	r8,31
800082f6:	e0 89 00 10 	brgt	80008316 <_vfprintf_r+0x108a>
800082fa:	f2 ca ff fc 	sub	r10,r9,-4
800082fe:	51 0a       	stdsp	sp[0x40],r10
80008300:	72 06       	ld.w	r6,r9[0x0]
80008302:	fa ce f9 44 	sub	lr,sp,-1724
80008306:	fc 08 00 39 	add	r9,lr,r8<<0x3
8000830a:	f3 46 fd 88 	st.w	r9[-632],r6
8000830e:	2f f8       	sub	r8,-1
80008310:	fb 48 06 b4 	st.w	sp[1716],r8
80008314:	c0 48       	rjmp	8000831c <_vfprintf_r+0x1090>
80008316:	72 06       	ld.w	r6,r9[0x0]
80008318:	2f c9       	sub	r9,-4
8000831a:	51 09       	stdsp	sp[0x40],r9
8000831c:	40 2c       	lddsp	r12,sp[0x8]
8000831e:	58 0c       	cp.w	r12,0
80008320:	c1 05       	brlt	80008340 <_vfprintf_r+0x10b4>
80008322:	18 9a       	mov	r10,r12
80008324:	30 0b       	mov	r11,0
80008326:	0c 9c       	mov	r12,r6
80008328:	e0 a0 12 38 	rcall	8000a798 <memchr>
8000832c:	e0 80 02 df 	breq	800088ea <_vfprintf_r+0x165e>
80008330:	f8 06 01 02 	sub	r2,r12,r6
80008334:	40 2b       	lddsp	r11,sp[0x8]
80008336:	16 32       	cp.w	r2,r11
80008338:	e0 89 02 d9 	brgt	800088ea <_vfprintf_r+0x165e>
8000833c:	e0 8f 02 d4 	bral	800088e4 <_vfprintf_r+0x1658>
80008340:	30 0a       	mov	r10,0
80008342:	0c 9c       	mov	r12,r6
80008344:	50 2a       	stdsp	sp[0x8],r10
80008346:	e0 a0 15 99 	rcall	8000ae78 <strlen>
8000834a:	18 92       	mov	r2,r12
8000834c:	e0 8f 02 d2 	bral	800088f0 <_vfprintf_r+0x1664>
80008350:	50 a7       	stdsp	sp[0x28],r7
80008352:	50 80       	stdsp	sp[0x20],r0
80008354:	0c 97       	mov	r7,r6
80008356:	04 94       	mov	r4,r2
80008358:	06 96       	mov	r6,r3
8000835a:	02 92       	mov	r2,r1
8000835c:	40 93       	lddsp	r3,sp[0x24]
8000835e:	10 90       	mov	r0,r8
80008360:	40 41       	lddsp	r1,sp[0x10]
80008362:	a5 a5       	sbr	r5,0x4
80008364:	c0 a8       	rjmp	80008378 <_vfprintf_r+0x10ec>
80008366:	50 a7       	stdsp	sp[0x28],r7
80008368:	50 80       	stdsp	sp[0x20],r0
8000836a:	0c 97       	mov	r7,r6
8000836c:	04 94       	mov	r4,r2
8000836e:	06 96       	mov	r6,r3
80008370:	02 92       	mov	r2,r1
80008372:	40 93       	lddsp	r3,sp[0x24]
80008374:	10 90       	mov	r0,r8
80008376:	40 41       	lddsp	r1,sp[0x10]
80008378:	ed b5 00 05 	bld	r5,0x5
8000837c:	c5 61       	brne	80008428 <_vfprintf_r+0x119c>
8000837e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008382:	40 39       	lddsp	r9,sp[0xc]
80008384:	58 09       	cp.w	r9,0
80008386:	c2 10       	breq	800083c8 <_vfprintf_r+0x113c>
80008388:	10 36       	cp.w	r6,r8
8000838a:	c0 74       	brge	80008398 <_vfprintf_r+0x110c>
8000838c:	fa c8 f9 44 	sub	r8,sp,-1724
80008390:	f0 06 00 36 	add	r6,r8,r6<<0x3
80008394:	c2 38       	rjmp	800083da <_vfprintf_r+0x114e>
80008396:	d7 03       	nop
80008398:	fa c8 f9 50 	sub	r8,sp,-1712
8000839c:	1a d8       	st.w	--sp,r8
8000839e:	fa c8 fa b8 	sub	r8,sp,-1352
800083a2:	1a d8       	st.w	--sp,r8
800083a4:	fa c8 fb b4 	sub	r8,sp,-1100
800083a8:	1a d8       	st.w	--sp,r8
800083aa:	fa c8 f9 40 	sub	r8,sp,-1728
800083ae:	fa c9 ff b4 	sub	r9,sp,-76
800083b2:	04 9a       	mov	r10,r2
800083b4:	0c 9b       	mov	r11,r6
800083b6:	08 9c       	mov	r12,r4
800083b8:	fe b0 f5 d2 	rcall	80006f5c <get_arg>
800083bc:	2f dd       	sub	sp,-12
800083be:	f8 e8 00 00 	ld.d	r8,r12[0]
800083c2:	fa e9 00 00 	st.d	sp[0],r8
800083c6:	c2 e8       	rjmp	80008422 <_vfprintf_r+0x1196>
800083c8:	ee ca ff ff 	sub	r10,r7,-1
800083cc:	10 37       	cp.w	r7,r8
800083ce:	c0 b4       	brge	800083e4 <_vfprintf_r+0x1158>
800083d0:	fa c8 f9 44 	sub	r8,sp,-1724
800083d4:	14 97       	mov	r7,r10
800083d6:	f0 06 00 36 	add	r6,r8,r6<<0x3
800083da:	ec ea fd 88 	ld.d	r10,r6[-632]
800083de:	fa eb 00 00 	st.d	sp[0],r10
800083e2:	c2 08       	rjmp	80008422 <_vfprintf_r+0x1196>
800083e4:	41 09       	lddsp	r9,sp[0x40]
800083e6:	59 f8       	cp.w	r8,31
800083e8:	e0 89 00 16 	brgt	80008414 <_vfprintf_r+0x1188>
800083ec:	f2 e6 00 00 	ld.d	r6,r9[0]
800083f0:	f2 cb ff f8 	sub	r11,r9,-8
800083f4:	fa e7 00 00 	st.d	sp[0],r6
800083f8:	51 0b       	stdsp	sp[0x40],r11
800083fa:	fa c6 f9 44 	sub	r6,sp,-1724
800083fe:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008402:	fa e6 00 00 	ld.d	r6,sp[0]
80008406:	f2 e7 fd 88 	st.d	r9[-632],r6
8000840a:	2f f8       	sub	r8,-1
8000840c:	14 97       	mov	r7,r10
8000840e:	fb 48 06 b4 	st.w	sp[1716],r8
80008412:	c0 88       	rjmp	80008422 <_vfprintf_r+0x1196>
80008414:	f2 e6 00 00 	ld.d	r6,r9[0]
80008418:	2f 89       	sub	r9,-8
8000841a:	fa e7 00 00 	st.d	sp[0],r6
8000841e:	51 09       	stdsp	sp[0x40],r9
80008420:	14 97       	mov	r7,r10
80008422:	30 18       	mov	r8,1
80008424:	e0 8f 01 d0 	bral	800087c4 <_vfprintf_r+0x1538>
80008428:	ed b5 00 04 	bld	r5,0x4
8000842c:	c1 61       	brne	80008458 <_vfprintf_r+0x11cc>
8000842e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008432:	40 3e       	lddsp	lr,sp[0xc]
80008434:	58 0e       	cp.w	lr,0
80008436:	c0 80       	breq	80008446 <_vfprintf_r+0x11ba>
80008438:	10 36       	cp.w	r6,r8
8000843a:	c6 74       	brge	80008508 <_vfprintf_r+0x127c>
8000843c:	fa cc f9 44 	sub	r12,sp,-1724
80008440:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008444:	c8 08       	rjmp	80008544 <_vfprintf_r+0x12b8>
80008446:	ee ca ff ff 	sub	r10,r7,-1
8000844a:	10 37       	cp.w	r7,r8
8000844c:	c7 f4       	brge	8000854a <_vfprintf_r+0x12be>
8000844e:	fa cb f9 44 	sub	r11,sp,-1724
80008452:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008456:	c7 68       	rjmp	80008542 <_vfprintf_r+0x12b6>
80008458:	ed b5 00 06 	bld	r5,0x6
8000845c:	c4 a1       	brne	800084f0 <_vfprintf_r+0x1264>
8000845e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008462:	40 3c       	lddsp	r12,sp[0xc]
80008464:	58 0c       	cp.w	r12,0
80008466:	c1 d0       	breq	800084a0 <_vfprintf_r+0x1214>
80008468:	10 36       	cp.w	r6,r8
8000846a:	c0 64       	brge	80008476 <_vfprintf_r+0x11ea>
8000846c:	fa cb f9 44 	sub	r11,sp,-1724
80008470:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008474:	c1 f8       	rjmp	800084b2 <_vfprintf_r+0x1226>
80008476:	fa c8 f9 50 	sub	r8,sp,-1712
8000847a:	1a d8       	st.w	--sp,r8
8000847c:	fa c8 fa b8 	sub	r8,sp,-1352
80008480:	1a d8       	st.w	--sp,r8
80008482:	fa c8 fb b4 	sub	r8,sp,-1100
80008486:	1a d8       	st.w	--sp,r8
80008488:	fa c8 f9 40 	sub	r8,sp,-1728
8000848c:	fa c9 ff b4 	sub	r9,sp,-76
80008490:	04 9a       	mov	r10,r2
80008492:	0c 9b       	mov	r11,r6
80008494:	08 9c       	mov	r12,r4
80008496:	fe b0 f5 63 	rcall	80006f5c <get_arg>
8000849a:	2f dd       	sub	sp,-12
8000849c:	98 18       	ld.sh	r8,r12[0x2]
8000849e:	c2 68       	rjmp	800084ea <_vfprintf_r+0x125e>
800084a0:	ee ca ff ff 	sub	r10,r7,-1
800084a4:	10 37       	cp.w	r7,r8
800084a6:	c0 94       	brge	800084b8 <_vfprintf_r+0x122c>
800084a8:	fa c9 f9 44 	sub	r9,sp,-1724
800084ac:	14 97       	mov	r7,r10
800084ae:	f2 06 00 36 	add	r6,r9,r6<<0x3
800084b2:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
800084b6:	c1 a8       	rjmp	800084ea <_vfprintf_r+0x125e>
800084b8:	41 09       	lddsp	r9,sp[0x40]
800084ba:	59 f8       	cp.w	r8,31
800084bc:	e0 89 00 13 	brgt	800084e2 <_vfprintf_r+0x1256>
800084c0:	f2 cb ff fc 	sub	r11,r9,-4
800084c4:	51 0b       	stdsp	sp[0x40],r11
800084c6:	72 09       	ld.w	r9,r9[0x0]
800084c8:	fa c6 f9 44 	sub	r6,sp,-1724
800084cc:	ec 08 00 3b 	add	r11,r6,r8<<0x3
800084d0:	2f f8       	sub	r8,-1
800084d2:	f7 49 fd 88 	st.w	r11[-632],r9
800084d6:	fb 48 06 b4 	st.w	sp[1716],r8
800084da:	14 97       	mov	r7,r10
800084dc:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
800084e0:	c0 58       	rjmp	800084ea <_vfprintf_r+0x125e>
800084e2:	92 18       	ld.sh	r8,r9[0x2]
800084e4:	14 97       	mov	r7,r10
800084e6:	2f c9       	sub	r9,-4
800084e8:	51 09       	stdsp	sp[0x40],r9
800084ea:	5c 78       	castu.h	r8
800084ec:	50 18       	stdsp	sp[0x4],r8
800084ee:	c4 68       	rjmp	8000857a <_vfprintf_r+0x12ee>
800084f0:	fa f8 06 b4 	ld.w	r8,sp[1716]
800084f4:	40 3c       	lddsp	r12,sp[0xc]
800084f6:	58 0c       	cp.w	r12,0
800084f8:	c1 d0       	breq	80008532 <_vfprintf_r+0x12a6>
800084fa:	10 36       	cp.w	r6,r8
800084fc:	c0 64       	brge	80008508 <_vfprintf_r+0x127c>
800084fe:	fa cb f9 44 	sub	r11,sp,-1724
80008502:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008506:	c1 f8       	rjmp	80008544 <_vfprintf_r+0x12b8>
80008508:	fa c8 f9 50 	sub	r8,sp,-1712
8000850c:	1a d8       	st.w	--sp,r8
8000850e:	fa c8 fa b8 	sub	r8,sp,-1352
80008512:	0c 9b       	mov	r11,r6
80008514:	1a d8       	st.w	--sp,r8
80008516:	fa c8 fb b4 	sub	r8,sp,-1100
8000851a:	04 9a       	mov	r10,r2
8000851c:	1a d8       	st.w	--sp,r8
8000851e:	08 9c       	mov	r12,r4
80008520:	fa c8 f9 40 	sub	r8,sp,-1728
80008524:	fa c9 ff b4 	sub	r9,sp,-76
80008528:	fe b0 f5 1a 	rcall	80006f5c <get_arg>
8000852c:	2f dd       	sub	sp,-12
8000852e:	78 0b       	ld.w	r11,r12[0x0]
80008530:	c2 48       	rjmp	80008578 <_vfprintf_r+0x12ec>
80008532:	ee ca ff ff 	sub	r10,r7,-1
80008536:	10 37       	cp.w	r7,r8
80008538:	c0 94       	brge	8000854a <_vfprintf_r+0x12be>
8000853a:	fa c9 f9 44 	sub	r9,sp,-1724
8000853e:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008542:	14 97       	mov	r7,r10
80008544:	ec fb fd 88 	ld.w	r11,r6[-632]
80008548:	c1 88       	rjmp	80008578 <_vfprintf_r+0x12ec>
8000854a:	41 09       	lddsp	r9,sp[0x40]
8000854c:	59 f8       	cp.w	r8,31
8000854e:	e0 89 00 11 	brgt	80008570 <_vfprintf_r+0x12e4>
80008552:	f2 cb ff fc 	sub	r11,r9,-4
80008556:	51 0b       	stdsp	sp[0x40],r11
80008558:	fa c6 f9 44 	sub	r6,sp,-1724
8000855c:	72 0b       	ld.w	r11,r9[0x0]
8000855e:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008562:	f3 4b fd 88 	st.w	r9[-632],r11
80008566:	2f f8       	sub	r8,-1
80008568:	14 97       	mov	r7,r10
8000856a:	fb 48 06 b4 	st.w	sp[1716],r8
8000856e:	c0 58       	rjmp	80008578 <_vfprintf_r+0x12ec>
80008570:	72 0b       	ld.w	r11,r9[0x0]
80008572:	14 97       	mov	r7,r10
80008574:	2f c9       	sub	r9,-4
80008576:	51 09       	stdsp	sp[0x40],r9
80008578:	50 1b       	stdsp	sp[0x4],r11
8000857a:	30 0e       	mov	lr,0
8000857c:	30 18       	mov	r8,1
8000857e:	50 0e       	stdsp	sp[0x0],lr
80008580:	c2 29       	rjmp	800087c4 <_vfprintf_r+0x1538>
80008582:	50 a7       	stdsp	sp[0x28],r7
80008584:	50 80       	stdsp	sp[0x20],r0
80008586:	0c 97       	mov	r7,r6
80008588:	04 94       	mov	r4,r2
8000858a:	06 96       	mov	r6,r3
8000858c:	02 92       	mov	r2,r1
8000858e:	fe cc b5 52 	sub	r12,pc,-19118
80008592:	40 93       	lddsp	r3,sp[0x24]
80008594:	10 90       	mov	r0,r8
80008596:	40 41       	lddsp	r1,sp[0x10]
80008598:	50 dc       	stdsp	sp[0x34],r12
8000859a:	ed b5 00 05 	bld	r5,0x5
8000859e:	c5 51       	brne	80008648 <_vfprintf_r+0x13bc>
800085a0:	fa f8 06 b4 	ld.w	r8,sp[1716]
800085a4:	40 3b       	lddsp	r11,sp[0xc]
800085a6:	58 0b       	cp.w	r11,0
800085a8:	c2 20       	breq	800085ec <_vfprintf_r+0x1360>
800085aa:	10 36       	cp.w	r6,r8
800085ac:	c0 a4       	brge	800085c0 <_vfprintf_r+0x1334>
800085ae:	fa ca f9 44 	sub	r10,sp,-1724
800085b2:	f4 06 00 36 	add	r6,r10,r6<<0x3
800085b6:	ec e8 fd 88 	ld.d	r8,r6[-632]
800085ba:	fa e9 00 00 	st.d	sp[0],r8
800085be:	cf 28       	rjmp	800087a2 <_vfprintf_r+0x1516>
800085c0:	fa c8 f9 50 	sub	r8,sp,-1712
800085c4:	1a d8       	st.w	--sp,r8
800085c6:	fa c8 fa b8 	sub	r8,sp,-1352
800085ca:	04 9a       	mov	r10,r2
800085cc:	1a d8       	st.w	--sp,r8
800085ce:	0c 9b       	mov	r11,r6
800085d0:	fa c8 fb b4 	sub	r8,sp,-1100
800085d4:	08 9c       	mov	r12,r4
800085d6:	1a d8       	st.w	--sp,r8
800085d8:	fa c8 f9 40 	sub	r8,sp,-1728
800085dc:	fa c9 ff b4 	sub	r9,sp,-76
800085e0:	fe b0 f4 be 	rcall	80006f5c <get_arg>
800085e4:	2f dd       	sub	sp,-12
800085e6:	f8 ea 00 00 	ld.d	r10,r12[0]
800085ea:	c0 c8       	rjmp	80008602 <_vfprintf_r+0x1376>
800085ec:	ee ca ff ff 	sub	r10,r7,-1
800085f0:	10 37       	cp.w	r7,r8
800085f2:	c0 b4       	brge	80008608 <_vfprintf_r+0x137c>
800085f4:	fa c9 f9 44 	sub	r9,sp,-1724
800085f8:	14 97       	mov	r7,r10
800085fa:	f2 06 00 36 	add	r6,r9,r6<<0x3
800085fe:	ec ea fd 88 	ld.d	r10,r6[-632]
80008602:	fa eb 00 00 	st.d	sp[0],r10
80008606:	cc e8       	rjmp	800087a2 <_vfprintf_r+0x1516>
80008608:	41 09       	lddsp	r9,sp[0x40]
8000860a:	59 f8       	cp.w	r8,31
8000860c:	e0 89 00 16 	brgt	80008638 <_vfprintf_r+0x13ac>
80008610:	f2 e6 00 00 	ld.d	r6,r9[0]
80008614:	f2 cb ff f8 	sub	r11,r9,-8
80008618:	fa e7 00 00 	st.d	sp[0],r6
8000861c:	51 0b       	stdsp	sp[0x40],r11
8000861e:	fa c6 f9 44 	sub	r6,sp,-1724
80008622:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008626:	fa e6 00 00 	ld.d	r6,sp[0]
8000862a:	f2 e7 fd 88 	st.d	r9[-632],r6
8000862e:	2f f8       	sub	r8,-1
80008630:	14 97       	mov	r7,r10
80008632:	fb 48 06 b4 	st.w	sp[1716],r8
80008636:	cb 68       	rjmp	800087a2 <_vfprintf_r+0x1516>
80008638:	f2 e6 00 00 	ld.d	r6,r9[0]
8000863c:	2f 89       	sub	r9,-8
8000863e:	fa e7 00 00 	st.d	sp[0],r6
80008642:	51 09       	stdsp	sp[0x40],r9
80008644:	14 97       	mov	r7,r10
80008646:	ca e8       	rjmp	800087a2 <_vfprintf_r+0x1516>
80008648:	ed b5 00 04 	bld	r5,0x4
8000864c:	c1 71       	brne	8000867a <_vfprintf_r+0x13ee>
8000864e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008652:	40 3e       	lddsp	lr,sp[0xc]
80008654:	58 0e       	cp.w	lr,0
80008656:	c0 80       	breq	80008666 <_vfprintf_r+0x13da>
80008658:	10 36       	cp.w	r6,r8
8000865a:	c6 94       	brge	8000872c <_vfprintf_r+0x14a0>
8000865c:	fa cc f9 44 	sub	r12,sp,-1724
80008660:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008664:	c8 28       	rjmp	80008768 <_vfprintf_r+0x14dc>
80008666:	ee ca ff ff 	sub	r10,r7,-1
8000866a:	10 37       	cp.w	r7,r8
8000866c:	e0 84 00 81 	brge	8000876e <_vfprintf_r+0x14e2>
80008670:	fa cb f9 44 	sub	r11,sp,-1724
80008674:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008678:	c7 78       	rjmp	80008766 <_vfprintf_r+0x14da>
8000867a:	ed b5 00 06 	bld	r5,0x6
8000867e:	c4 b1       	brne	80008714 <_vfprintf_r+0x1488>
80008680:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008684:	40 3c       	lddsp	r12,sp[0xc]
80008686:	58 0c       	cp.w	r12,0
80008688:	c1 d0       	breq	800086c2 <_vfprintf_r+0x1436>
8000868a:	10 36       	cp.w	r6,r8
8000868c:	c0 64       	brge	80008698 <_vfprintf_r+0x140c>
8000868e:	fa cb f9 44 	sub	r11,sp,-1724
80008692:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008696:	c1 f8       	rjmp	800086d4 <_vfprintf_r+0x1448>
80008698:	fa c8 f9 50 	sub	r8,sp,-1712
8000869c:	1a d8       	st.w	--sp,r8
8000869e:	fa c8 fa b8 	sub	r8,sp,-1352
800086a2:	1a d8       	st.w	--sp,r8
800086a4:	fa c8 fb b4 	sub	r8,sp,-1100
800086a8:	1a d8       	st.w	--sp,r8
800086aa:	fa c8 f9 40 	sub	r8,sp,-1728
800086ae:	fa c9 ff b4 	sub	r9,sp,-76
800086b2:	04 9a       	mov	r10,r2
800086b4:	0c 9b       	mov	r11,r6
800086b6:	08 9c       	mov	r12,r4
800086b8:	fe b0 f4 52 	rcall	80006f5c <get_arg>
800086bc:	2f dd       	sub	sp,-12
800086be:	98 18       	ld.sh	r8,r12[0x2]
800086c0:	c2 78       	rjmp	8000870e <_vfprintf_r+0x1482>
800086c2:	ee ca ff ff 	sub	r10,r7,-1
800086c6:	10 37       	cp.w	r7,r8
800086c8:	c0 a4       	brge	800086dc <_vfprintf_r+0x1450>
800086ca:	fa c9 f9 44 	sub	r9,sp,-1724
800086ce:	14 97       	mov	r7,r10
800086d0:	f2 06 00 36 	add	r6,r9,r6<<0x3
800086d4:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
800086d8:	c1 b8       	rjmp	8000870e <_vfprintf_r+0x1482>
800086da:	d7 03       	nop
800086dc:	41 09       	lddsp	r9,sp[0x40]
800086de:	59 f8       	cp.w	r8,31
800086e0:	e0 89 00 13 	brgt	80008706 <_vfprintf_r+0x147a>
800086e4:	f2 cb ff fc 	sub	r11,r9,-4
800086e8:	51 0b       	stdsp	sp[0x40],r11
800086ea:	72 09       	ld.w	r9,r9[0x0]
800086ec:	fa c6 f9 44 	sub	r6,sp,-1724
800086f0:	ec 08 00 3b 	add	r11,r6,r8<<0x3
800086f4:	2f f8       	sub	r8,-1
800086f6:	f7 49 fd 88 	st.w	r11[-632],r9
800086fa:	fb 48 06 b4 	st.w	sp[1716],r8
800086fe:	14 97       	mov	r7,r10
80008700:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80008704:	c0 58       	rjmp	8000870e <_vfprintf_r+0x1482>
80008706:	92 18       	ld.sh	r8,r9[0x2]
80008708:	14 97       	mov	r7,r10
8000870a:	2f c9       	sub	r9,-4
8000870c:	51 09       	stdsp	sp[0x40],r9
8000870e:	5c 78       	castu.h	r8
80008710:	50 18       	stdsp	sp[0x4],r8
80008712:	c4 68       	rjmp	8000879e <_vfprintf_r+0x1512>
80008714:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008718:	40 3c       	lddsp	r12,sp[0xc]
8000871a:	58 0c       	cp.w	r12,0
8000871c:	c1 d0       	breq	80008756 <_vfprintf_r+0x14ca>
8000871e:	10 36       	cp.w	r6,r8
80008720:	c0 64       	brge	8000872c <_vfprintf_r+0x14a0>
80008722:	fa cb f9 44 	sub	r11,sp,-1724
80008726:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000872a:	c1 f8       	rjmp	80008768 <_vfprintf_r+0x14dc>
8000872c:	fa c8 f9 50 	sub	r8,sp,-1712
80008730:	1a d8       	st.w	--sp,r8
80008732:	fa c8 fa b8 	sub	r8,sp,-1352
80008736:	0c 9b       	mov	r11,r6
80008738:	1a d8       	st.w	--sp,r8
8000873a:	fa c8 fb b4 	sub	r8,sp,-1100
8000873e:	04 9a       	mov	r10,r2
80008740:	1a d8       	st.w	--sp,r8
80008742:	08 9c       	mov	r12,r4
80008744:	fa c8 f9 40 	sub	r8,sp,-1728
80008748:	fa c9 ff b4 	sub	r9,sp,-76
8000874c:	fe b0 f4 08 	rcall	80006f5c <get_arg>
80008750:	2f dd       	sub	sp,-12
80008752:	78 0b       	ld.w	r11,r12[0x0]
80008754:	c2 48       	rjmp	8000879c <_vfprintf_r+0x1510>
80008756:	ee ca ff ff 	sub	r10,r7,-1
8000875a:	10 37       	cp.w	r7,r8
8000875c:	c0 94       	brge	8000876e <_vfprintf_r+0x14e2>
8000875e:	fa c9 f9 44 	sub	r9,sp,-1724
80008762:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008766:	14 97       	mov	r7,r10
80008768:	ec fb fd 88 	ld.w	r11,r6[-632]
8000876c:	c1 88       	rjmp	8000879c <_vfprintf_r+0x1510>
8000876e:	41 09       	lddsp	r9,sp[0x40]
80008770:	59 f8       	cp.w	r8,31
80008772:	e0 89 00 11 	brgt	80008794 <_vfprintf_r+0x1508>
80008776:	f2 cb ff fc 	sub	r11,r9,-4
8000877a:	51 0b       	stdsp	sp[0x40],r11
8000877c:	fa c6 f9 44 	sub	r6,sp,-1724
80008780:	72 0b       	ld.w	r11,r9[0x0]
80008782:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008786:	f3 4b fd 88 	st.w	r9[-632],r11
8000878a:	2f f8       	sub	r8,-1
8000878c:	14 97       	mov	r7,r10
8000878e:	fb 48 06 b4 	st.w	sp[1716],r8
80008792:	c0 58       	rjmp	8000879c <_vfprintf_r+0x1510>
80008794:	72 0b       	ld.w	r11,r9[0x0]
80008796:	14 97       	mov	r7,r10
80008798:	2f c9       	sub	r9,-4
8000879a:	51 09       	stdsp	sp[0x40],r9
8000879c:	50 1b       	stdsp	sp[0x4],r11
8000879e:	30 0e       	mov	lr,0
800087a0:	50 0e       	stdsp	sp[0x0],lr
800087a2:	40 08       	lddsp	r8,sp[0x0]
800087a4:	40 1c       	lddsp	r12,sp[0x4]
800087a6:	18 48       	or	r8,r12
800087a8:	5f 19       	srne	r9
800087aa:	0a 98       	mov	r8,r5
800087ac:	eb e9 00 09 	and	r9,r5,r9
800087b0:	a1 b8       	sbr	r8,0x1
800087b2:	58 09       	cp.w	r9,0
800087b4:	c0 70       	breq	800087c2 <_vfprintf_r+0x1536>
800087b6:	10 95       	mov	r5,r8
800087b8:	fb 60 06 b9 	st.b	sp[1721],r0
800087bc:	33 08       	mov	r8,48
800087be:	fb 68 06 b8 	st.b	sp[1720],r8
800087c2:	30 28       	mov	r8,2
800087c4:	30 09       	mov	r9,0
800087c6:	fb 69 06 bb 	st.b	sp[1723],r9
800087ca:	0a 99       	mov	r9,r5
800087cc:	a7 d9       	cbr	r9,0x7
800087ce:	40 2b       	lddsp	r11,sp[0x8]
800087d0:	40 16       	lddsp	r6,sp[0x4]
800087d2:	58 0b       	cp.w	r11,0
800087d4:	5f 1a       	srne	r10
800087d6:	f2 05 17 40 	movge	r5,r9
800087da:	fa c2 f9 78 	sub	r2,sp,-1672
800087de:	40 09       	lddsp	r9,sp[0x0]
800087e0:	0c 49       	or	r9,r6
800087e2:	5f 19       	srne	r9
800087e4:	f5 e9 10 09 	or	r9,r10,r9
800087e8:	c5 c0       	breq	800088a0 <_vfprintf_r+0x1614>
800087ea:	30 19       	mov	r9,1
800087ec:	f2 08 18 00 	cp.b	r8,r9
800087f0:	c0 60       	breq	800087fc <_vfprintf_r+0x1570>
800087f2:	30 29       	mov	r9,2
800087f4:	f2 08 18 00 	cp.b	r8,r9
800087f8:	c0 41       	brne	80008800 <_vfprintf_r+0x1574>
800087fa:	c3 c8       	rjmp	80008872 <_vfprintf_r+0x15e6>
800087fc:	04 96       	mov	r6,r2
800087fe:	c3 08       	rjmp	8000885e <_vfprintf_r+0x15d2>
80008800:	04 96       	mov	r6,r2
80008802:	fa e8 00 00 	ld.d	r8,sp[0]
80008806:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
8000880a:	2d 0a       	sub	r10,-48
8000880c:	0c fa       	st.b	--r6,r10
8000880e:	f0 0b 16 03 	lsr	r11,r8,0x3
80008812:	f2 0c 16 03 	lsr	r12,r9,0x3
80008816:	f7 e9 11 db 	or	r11,r11,r9<<0x1d
8000881a:	18 99       	mov	r9,r12
8000881c:	16 98       	mov	r8,r11
8000881e:	58 08       	cp.w	r8,0
80008820:	5c 29       	cpc	r9
80008822:	cf 21       	brne	80008806 <_vfprintf_r+0x157a>
80008824:	fa e9 00 00 	st.d	sp[0],r8
80008828:	ed b5 00 00 	bld	r5,0x0
8000882c:	c4 51       	brne	800088b6 <_vfprintf_r+0x162a>
8000882e:	33 09       	mov	r9,48
80008830:	f2 0a 18 00 	cp.b	r10,r9
80008834:	c4 10       	breq	800088b6 <_vfprintf_r+0x162a>
80008836:	0c f9       	st.b	--r6,r9
80008838:	c3 f8       	rjmp	800088b6 <_vfprintf_r+0x162a>
8000883a:	fa ea 00 00 	ld.d	r10,sp[0]
8000883e:	30 a8       	mov	r8,10
80008840:	30 09       	mov	r9,0
80008842:	e0 a0 1a 19 	rcall	8000bc74 <__avr32_umod64>
80008846:	30 a8       	mov	r8,10
80008848:	2d 0a       	sub	r10,-48
8000884a:	30 09       	mov	r9,0
8000884c:	ac 8a       	st.b	r6[0x0],r10
8000884e:	fa ea 00 00 	ld.d	r10,sp[0]
80008852:	e0 a0 18 df 	rcall	8000ba10 <__avr32_udiv64>
80008856:	16 99       	mov	r9,r11
80008858:	14 98       	mov	r8,r10
8000885a:	fa e9 00 00 	st.d	sp[0],r8
8000885e:	20 16       	sub	r6,1
80008860:	fa ea 00 00 	ld.d	r10,sp[0]
80008864:	58 9a       	cp.w	r10,9
80008866:	5c 2b       	cpc	r11
80008868:	fe 9b ff e9 	brhi	8000883a <_vfprintf_r+0x15ae>
8000886c:	1b f8       	ld.ub	r8,sp[0x7]
8000886e:	2d 08       	sub	r8,-48
80008870:	c2 08       	rjmp	800088b0 <_vfprintf_r+0x1624>
80008872:	04 96       	mov	r6,r2
80008874:	fa e8 00 00 	ld.d	r8,sp[0]
80008878:	f5 d8 c0 04 	bfextu	r10,r8,0x0,0x4
8000887c:	40 de       	lddsp	lr,sp[0x34]
8000887e:	fc 0a 07 0a 	ld.ub	r10,lr[r10]
80008882:	0c fa       	st.b	--r6,r10
80008884:	f2 0b 16 04 	lsr	r11,r9,0x4
80008888:	f0 0a 16 04 	lsr	r10,r8,0x4
8000888c:	f5 e9 11 ca 	or	r10,r10,r9<<0x1c
80008890:	16 99       	mov	r9,r11
80008892:	14 98       	mov	r8,r10
80008894:	58 08       	cp.w	r8,0
80008896:	5c 29       	cpc	r9
80008898:	cf 01       	brne	80008878 <_vfprintf_r+0x15ec>
8000889a:	fa e9 00 00 	st.d	sp[0],r8
8000889e:	c0 c8       	rjmp	800088b6 <_vfprintf_r+0x162a>
800088a0:	58 08       	cp.w	r8,0
800088a2:	c0 91       	brne	800088b4 <_vfprintf_r+0x1628>
800088a4:	ed b5 00 00 	bld	r5,0x0
800088a8:	c0 61       	brne	800088b4 <_vfprintf_r+0x1628>
800088aa:	fa c6 f9 79 	sub	r6,sp,-1671
800088ae:	33 08       	mov	r8,48
800088b0:	ac 88       	st.b	r6[0x0],r8
800088b2:	c0 28       	rjmp	800088b6 <_vfprintf_r+0x162a>
800088b4:	04 96       	mov	r6,r2
800088b6:	0c 12       	sub	r2,r6
800088b8:	c1 c8       	rjmp	800088f0 <_vfprintf_r+0x1664>
800088ba:	50 a7       	stdsp	sp[0x28],r7
800088bc:	50 80       	stdsp	sp[0x20],r0
800088be:	40 93       	lddsp	r3,sp[0x24]
800088c0:	0c 97       	mov	r7,r6
800088c2:	10 90       	mov	r0,r8
800088c4:	04 94       	mov	r4,r2
800088c6:	40 41       	lddsp	r1,sp[0x10]
800088c8:	58 08       	cp.w	r8,0
800088ca:	e0 80 04 4f 	breq	80009168 <_vfprintf_r+0x1edc>
800088ce:	fb 68 06 60 	st.b	sp[1632],r8
800088d2:	30 0c       	mov	r12,0
800088d4:	30 08       	mov	r8,0
800088d6:	30 12       	mov	r2,1
800088d8:	fb 68 06 bb 	st.b	sp[1723],r8
800088dc:	50 2c       	stdsp	sp[0x8],r12
800088de:	fa c6 f9 a0 	sub	r6,sp,-1632
800088e2:	c0 78       	rjmp	800088f0 <_vfprintf_r+0x1664>
800088e4:	30 0b       	mov	r11,0
800088e6:	50 2b       	stdsp	sp[0x8],r11
800088e8:	c0 48       	rjmp	800088f0 <_vfprintf_r+0x1664>
800088ea:	40 22       	lddsp	r2,sp[0x8]
800088ec:	30 0a       	mov	r10,0
800088ee:	50 2a       	stdsp	sp[0x8],r10
800088f0:	40 29       	lddsp	r9,sp[0x8]
800088f2:	e4 09 0c 49 	max	r9,r2,r9
800088f6:	fb 38 06 bb 	ld.ub	r8,sp[1723]
800088fa:	50 39       	stdsp	sp[0xc],r9
800088fc:	0a 9e       	mov	lr,r5
800088fe:	30 09       	mov	r9,0
80008900:	e2 1e 00 02 	andl	lr,0x2,COH
80008904:	f2 08 18 00 	cp.b	r8,r9
80008908:	fb f8 10 03 	ld.wne	r8,sp[0xc]
8000890c:	f7 b8 01 ff 	subne	r8,-1
80008910:	fb f8 1a 03 	st.wne	sp[0xc],r8
80008914:	0a 9b       	mov	r11,r5
80008916:	58 0e       	cp.w	lr,0
80008918:	fb fc 10 03 	ld.wne	r12,sp[0xc]
8000891c:	f7 bc 01 fe 	subne	r12,-2
80008920:	fb fc 1a 03 	st.wne	sp[0xc],r12
80008924:	e2 1b 00 84 	andl	r11,0x84,COH
80008928:	50 fe       	stdsp	sp[0x3c],lr
8000892a:	50 9b       	stdsp	sp[0x24],r11
8000892c:	c4 71       	brne	800089ba <_vfprintf_r+0x172e>
8000892e:	40 8a       	lddsp	r10,sp[0x20]
80008930:	40 39       	lddsp	r9,sp[0xc]
80008932:	12 1a       	sub	r10,r9
80008934:	50 4a       	stdsp	sp[0x10],r10
80008936:	58 0a       	cp.w	r10,0
80008938:	e0 89 00 20 	brgt	80008978 <_vfprintf_r+0x16ec>
8000893c:	c3 f8       	rjmp	800089ba <_vfprintf_r+0x172e>
8000893e:	2f 09       	sub	r9,-16
80008940:	2f f8       	sub	r8,-1
80008942:	fe ce b8 ee 	sub	lr,pc,-18194
80008946:	31 0c       	mov	r12,16
80008948:	fb 49 06 90 	st.w	sp[1680],r9
8000894c:	87 0e       	st.w	r3[0x0],lr
8000894e:	87 1c       	st.w	r3[0x4],r12
80008950:	fb 48 06 8c 	st.w	sp[1676],r8
80008954:	58 78       	cp.w	r8,7
80008956:	e0 89 00 04 	brgt	8000895e <_vfprintf_r+0x16d2>
8000895a:	2f 83       	sub	r3,-8
8000895c:	c0 b8       	rjmp	80008972 <_vfprintf_r+0x16e6>
8000895e:	fa ca f9 78 	sub	r10,sp,-1672
80008962:	02 9b       	mov	r11,r1
80008964:	08 9c       	mov	r12,r4
80008966:	fe b0 f4 85 	rcall	80007270 <__sprint_r>
8000896a:	e0 81 04 10 	brne	8000918a <_vfprintf_r+0x1efe>
8000896e:	fa c3 f9 e0 	sub	r3,sp,-1568
80008972:	40 4b       	lddsp	r11,sp[0x10]
80008974:	21 0b       	sub	r11,16
80008976:	50 4b       	stdsp	sp[0x10],r11
80008978:	fa f9 06 90 	ld.w	r9,sp[1680]
8000897c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008980:	fe ca b9 2c 	sub	r10,pc,-18132
80008984:	40 4e       	lddsp	lr,sp[0x10]
80008986:	59 0e       	cp.w	lr,16
80008988:	fe 99 ff db 	brgt	8000893e <_vfprintf_r+0x16b2>
8000898c:	1c 09       	add	r9,lr
8000898e:	2f f8       	sub	r8,-1
80008990:	87 0a       	st.w	r3[0x0],r10
80008992:	fb 49 06 90 	st.w	sp[1680],r9
80008996:	87 1e       	st.w	r3[0x4],lr
80008998:	fb 48 06 8c 	st.w	sp[1676],r8
8000899c:	58 78       	cp.w	r8,7
8000899e:	e0 89 00 04 	brgt	800089a6 <_vfprintf_r+0x171a>
800089a2:	2f 83       	sub	r3,-8
800089a4:	c0 b8       	rjmp	800089ba <_vfprintf_r+0x172e>
800089a6:	fa ca f9 78 	sub	r10,sp,-1672
800089aa:	02 9b       	mov	r11,r1
800089ac:	08 9c       	mov	r12,r4
800089ae:	fe b0 f4 61 	rcall	80007270 <__sprint_r>
800089b2:	e0 81 03 ec 	brne	8000918a <_vfprintf_r+0x1efe>
800089b6:	fa c3 f9 e0 	sub	r3,sp,-1568
800089ba:	30 09       	mov	r9,0
800089bc:	fb 38 06 bb 	ld.ub	r8,sp[1723]
800089c0:	f2 08 18 00 	cp.b	r8,r9
800089c4:	c1 f0       	breq	80008a02 <_vfprintf_r+0x1776>
800089c6:	fa f8 06 90 	ld.w	r8,sp[1680]
800089ca:	fa c9 f9 45 	sub	r9,sp,-1723
800089ce:	2f f8       	sub	r8,-1
800089d0:	87 09       	st.w	r3[0x0],r9
800089d2:	fb 48 06 90 	st.w	sp[1680],r8
800089d6:	30 19       	mov	r9,1
800089d8:	fa f8 06 8c 	ld.w	r8,sp[1676]
800089dc:	87 19       	st.w	r3[0x4],r9
800089de:	2f f8       	sub	r8,-1
800089e0:	fb 48 06 8c 	st.w	sp[1676],r8
800089e4:	58 78       	cp.w	r8,7
800089e6:	e0 89 00 04 	brgt	800089ee <_vfprintf_r+0x1762>
800089ea:	2f 83       	sub	r3,-8
800089ec:	c0 b8       	rjmp	80008a02 <_vfprintf_r+0x1776>
800089ee:	fa ca f9 78 	sub	r10,sp,-1672
800089f2:	02 9b       	mov	r11,r1
800089f4:	08 9c       	mov	r12,r4
800089f6:	fe b0 f4 3d 	rcall	80007270 <__sprint_r>
800089fa:	e0 81 03 c8 	brne	8000918a <_vfprintf_r+0x1efe>
800089fe:	fa c3 f9 e0 	sub	r3,sp,-1568
80008a02:	40 fc       	lddsp	r12,sp[0x3c]
80008a04:	58 0c       	cp.w	r12,0
80008a06:	c1 f0       	breq	80008a44 <_vfprintf_r+0x17b8>
80008a08:	fa f8 06 90 	ld.w	r8,sp[1680]
80008a0c:	fa c9 f9 48 	sub	r9,sp,-1720
80008a10:	2f e8       	sub	r8,-2
80008a12:	87 09       	st.w	r3[0x0],r9
80008a14:	fb 48 06 90 	st.w	sp[1680],r8
80008a18:	30 29       	mov	r9,2
80008a1a:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008a1e:	87 19       	st.w	r3[0x4],r9
80008a20:	2f f8       	sub	r8,-1
80008a22:	fb 48 06 8c 	st.w	sp[1676],r8
80008a26:	58 78       	cp.w	r8,7
80008a28:	e0 89 00 04 	brgt	80008a30 <_vfprintf_r+0x17a4>
80008a2c:	2f 83       	sub	r3,-8
80008a2e:	c0 b8       	rjmp	80008a44 <_vfprintf_r+0x17b8>
80008a30:	fa ca f9 78 	sub	r10,sp,-1672
80008a34:	02 9b       	mov	r11,r1
80008a36:	08 9c       	mov	r12,r4
80008a38:	fe b0 f4 1c 	rcall	80007270 <__sprint_r>
80008a3c:	e0 81 03 a7 	brne	8000918a <_vfprintf_r+0x1efe>
80008a40:	fa c3 f9 e0 	sub	r3,sp,-1568
80008a44:	40 9b       	lddsp	r11,sp[0x24]
80008a46:	e0 4b 00 80 	cp.w	r11,128
80008a4a:	c4 71       	brne	80008ad8 <_vfprintf_r+0x184c>
80008a4c:	40 8a       	lddsp	r10,sp[0x20]
80008a4e:	40 39       	lddsp	r9,sp[0xc]
80008a50:	12 1a       	sub	r10,r9
80008a52:	50 4a       	stdsp	sp[0x10],r10
80008a54:	58 0a       	cp.w	r10,0
80008a56:	e0 89 00 20 	brgt	80008a96 <_vfprintf_r+0x180a>
80008a5a:	c3 f8       	rjmp	80008ad8 <_vfprintf_r+0x184c>
80008a5c:	2f 09       	sub	r9,-16
80008a5e:	2f f8       	sub	r8,-1
80008a60:	fe ce b9 fc 	sub	lr,pc,-17924
80008a64:	31 0c       	mov	r12,16
80008a66:	fb 49 06 90 	st.w	sp[1680],r9
80008a6a:	87 0e       	st.w	r3[0x0],lr
80008a6c:	87 1c       	st.w	r3[0x4],r12
80008a6e:	fb 48 06 8c 	st.w	sp[1676],r8
80008a72:	58 78       	cp.w	r8,7
80008a74:	e0 89 00 04 	brgt	80008a7c <_vfprintf_r+0x17f0>
80008a78:	2f 83       	sub	r3,-8
80008a7a:	c0 b8       	rjmp	80008a90 <_vfprintf_r+0x1804>
80008a7c:	fa ca f9 78 	sub	r10,sp,-1672
80008a80:	02 9b       	mov	r11,r1
80008a82:	08 9c       	mov	r12,r4
80008a84:	fe b0 f3 f6 	rcall	80007270 <__sprint_r>
80008a88:	e0 81 03 81 	brne	8000918a <_vfprintf_r+0x1efe>
80008a8c:	fa c3 f9 e0 	sub	r3,sp,-1568
80008a90:	40 4b       	lddsp	r11,sp[0x10]
80008a92:	21 0b       	sub	r11,16
80008a94:	50 4b       	stdsp	sp[0x10],r11
80008a96:	fa f9 06 90 	ld.w	r9,sp[1680]
80008a9a:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008a9e:	fe ca ba 3a 	sub	r10,pc,-17862
80008aa2:	40 4e       	lddsp	lr,sp[0x10]
80008aa4:	59 0e       	cp.w	lr,16
80008aa6:	fe 99 ff db 	brgt	80008a5c <_vfprintf_r+0x17d0>
80008aaa:	1c 09       	add	r9,lr
80008aac:	2f f8       	sub	r8,-1
80008aae:	87 0a       	st.w	r3[0x0],r10
80008ab0:	fb 49 06 90 	st.w	sp[1680],r9
80008ab4:	87 1e       	st.w	r3[0x4],lr
80008ab6:	fb 48 06 8c 	st.w	sp[1676],r8
80008aba:	58 78       	cp.w	r8,7
80008abc:	e0 89 00 04 	brgt	80008ac4 <_vfprintf_r+0x1838>
80008ac0:	2f 83       	sub	r3,-8
80008ac2:	c0 b8       	rjmp	80008ad8 <_vfprintf_r+0x184c>
80008ac4:	fa ca f9 78 	sub	r10,sp,-1672
80008ac8:	02 9b       	mov	r11,r1
80008aca:	08 9c       	mov	r12,r4
80008acc:	fe b0 f3 d2 	rcall	80007270 <__sprint_r>
80008ad0:	e0 81 03 5d 	brne	8000918a <_vfprintf_r+0x1efe>
80008ad4:	fa c3 f9 e0 	sub	r3,sp,-1568
80008ad8:	40 2c       	lddsp	r12,sp[0x8]
80008ada:	04 1c       	sub	r12,r2
80008adc:	50 2c       	stdsp	sp[0x8],r12
80008ade:	58 0c       	cp.w	r12,0
80008ae0:	e0 89 00 20 	brgt	80008b20 <_vfprintf_r+0x1894>
80008ae4:	c3 f8       	rjmp	80008b62 <_vfprintf_r+0x18d6>
80008ae6:	2f 09       	sub	r9,-16
80008ae8:	2f f8       	sub	r8,-1
80008aea:	fe cb ba 86 	sub	r11,pc,-17786
80008aee:	31 0a       	mov	r10,16
80008af0:	fb 49 06 90 	st.w	sp[1680],r9
80008af4:	87 0b       	st.w	r3[0x0],r11
80008af6:	87 1a       	st.w	r3[0x4],r10
80008af8:	fb 48 06 8c 	st.w	sp[1676],r8
80008afc:	58 78       	cp.w	r8,7
80008afe:	e0 89 00 04 	brgt	80008b06 <_vfprintf_r+0x187a>
80008b02:	2f 83       	sub	r3,-8
80008b04:	c0 b8       	rjmp	80008b1a <_vfprintf_r+0x188e>
80008b06:	fa ca f9 78 	sub	r10,sp,-1672
80008b0a:	02 9b       	mov	r11,r1
80008b0c:	08 9c       	mov	r12,r4
80008b0e:	fe b0 f3 b1 	rcall	80007270 <__sprint_r>
80008b12:	e0 81 03 3c 	brne	8000918a <_vfprintf_r+0x1efe>
80008b16:	fa c3 f9 e0 	sub	r3,sp,-1568
80008b1a:	40 29       	lddsp	r9,sp[0x8]
80008b1c:	21 09       	sub	r9,16
80008b1e:	50 29       	stdsp	sp[0x8],r9
80008b20:	fa f9 06 90 	ld.w	r9,sp[1680]
80008b24:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008b28:	fe ca ba c4 	sub	r10,pc,-17724
80008b2c:	40 2e       	lddsp	lr,sp[0x8]
80008b2e:	59 0e       	cp.w	lr,16
80008b30:	fe 99 ff db 	brgt	80008ae6 <_vfprintf_r+0x185a>
80008b34:	1c 09       	add	r9,lr
80008b36:	2f f8       	sub	r8,-1
80008b38:	87 0a       	st.w	r3[0x0],r10
80008b3a:	fb 49 06 90 	st.w	sp[1680],r9
80008b3e:	87 1e       	st.w	r3[0x4],lr
80008b40:	fb 48 06 8c 	st.w	sp[1676],r8
80008b44:	58 78       	cp.w	r8,7
80008b46:	e0 89 00 04 	brgt	80008b4e <_vfprintf_r+0x18c2>
80008b4a:	2f 83       	sub	r3,-8
80008b4c:	c0 b8       	rjmp	80008b62 <_vfprintf_r+0x18d6>
80008b4e:	fa ca f9 78 	sub	r10,sp,-1672
80008b52:	02 9b       	mov	r11,r1
80008b54:	08 9c       	mov	r12,r4
80008b56:	fe b0 f3 8d 	rcall	80007270 <__sprint_r>
80008b5a:	e0 81 03 18 	brne	8000918a <_vfprintf_r+0x1efe>
80008b5e:	fa c3 f9 e0 	sub	r3,sp,-1568
80008b62:	ed b5 00 08 	bld	r5,0x8
80008b66:	c0 b0       	breq	80008b7c <_vfprintf_r+0x18f0>
80008b68:	fa f8 06 90 	ld.w	r8,sp[1680]
80008b6c:	87 12       	st.w	r3[0x4],r2
80008b6e:	87 06       	st.w	r3[0x0],r6
80008b70:	f0 02 00 02 	add	r2,r8,r2
80008b74:	fb 42 06 90 	st.w	sp[1680],r2
80008b78:	e0 8f 01 d4 	bral	80008f20 <_vfprintf_r+0x1c94>
80008b7c:	e0 40 00 65 	cp.w	r0,101
80008b80:	e0 8a 01 d6 	brle	80008f2c <_vfprintf_r+0x1ca0>
80008b84:	30 08       	mov	r8,0
80008b86:	30 09       	mov	r9,0
80008b88:	40 5b       	lddsp	r11,sp[0x14]
80008b8a:	40 7a       	lddsp	r10,sp[0x1c]
80008b8c:	e0 a0 15 3b 	rcall	8000b602 <__avr32_f64_cmp_eq>
80008b90:	c7 90       	breq	80008c82 <_vfprintf_r+0x19f6>
80008b92:	fa f8 06 90 	ld.w	r8,sp[1680]
80008b96:	fe c9 bb 46 	sub	r9,pc,-17594
80008b9a:	2f f8       	sub	r8,-1
80008b9c:	87 09       	st.w	r3[0x0],r9
80008b9e:	fb 48 06 90 	st.w	sp[1680],r8
80008ba2:	30 19       	mov	r9,1
80008ba4:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008ba8:	87 19       	st.w	r3[0x4],r9
80008baa:	2f f8       	sub	r8,-1
80008bac:	fb 48 06 8c 	st.w	sp[1676],r8
80008bb0:	58 78       	cp.w	r8,7
80008bb2:	e0 89 00 05 	brgt	80008bbc <_vfprintf_r+0x1930>
80008bb6:	2f 83       	sub	r3,-8
80008bb8:	c0 c8       	rjmp	80008bd0 <_vfprintf_r+0x1944>
80008bba:	d7 03       	nop
80008bbc:	fa ca f9 78 	sub	r10,sp,-1672
80008bc0:	02 9b       	mov	r11,r1
80008bc2:	08 9c       	mov	r12,r4
80008bc4:	fe b0 f3 56 	rcall	80007270 <__sprint_r>
80008bc8:	e0 81 02 e1 	brne	8000918a <_vfprintf_r+0x1efe>
80008bcc:	fa c3 f9 e0 	sub	r3,sp,-1568
80008bd0:	fa f8 06 ac 	ld.w	r8,sp[1708]
80008bd4:	40 6c       	lddsp	r12,sp[0x18]
80008bd6:	18 38       	cp.w	r8,r12
80008bd8:	c0 55       	brlt	80008be2 <_vfprintf_r+0x1956>
80008bda:	ed b5 00 00 	bld	r5,0x0
80008bde:	e0 81 02 6b 	brne	800090b4 <_vfprintf_r+0x1e28>
80008be2:	fa f8 06 90 	ld.w	r8,sp[1680]
80008be6:	2f f8       	sub	r8,-1
80008be8:	40 cb       	lddsp	r11,sp[0x30]
80008bea:	fb 48 06 90 	st.w	sp[1680],r8
80008bee:	30 19       	mov	r9,1
80008bf0:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008bf4:	87 0b       	st.w	r3[0x0],r11
80008bf6:	2f f8       	sub	r8,-1
80008bf8:	87 19       	st.w	r3[0x4],r9
80008bfa:	fb 48 06 8c 	st.w	sp[1676],r8
80008bfe:	58 78       	cp.w	r8,7
80008c00:	e0 89 00 04 	brgt	80008c08 <_vfprintf_r+0x197c>
80008c04:	2f 83       	sub	r3,-8
80008c06:	c0 b8       	rjmp	80008c1c <_vfprintf_r+0x1990>
80008c08:	fa ca f9 78 	sub	r10,sp,-1672
80008c0c:	02 9b       	mov	r11,r1
80008c0e:	08 9c       	mov	r12,r4
80008c10:	fe b0 f3 30 	rcall	80007270 <__sprint_r>
80008c14:	e0 81 02 bb 	brne	8000918a <_vfprintf_r+0x1efe>
80008c18:	fa c3 f9 e0 	sub	r3,sp,-1568
80008c1c:	40 66       	lddsp	r6,sp[0x18]
80008c1e:	20 16       	sub	r6,1
80008c20:	58 06       	cp.w	r6,0
80008c22:	e0 89 00 1d 	brgt	80008c5c <_vfprintf_r+0x19d0>
80008c26:	e0 8f 02 47 	bral	800090b4 <_vfprintf_r+0x1e28>
80008c2a:	2f 09       	sub	r9,-16
80008c2c:	2f f8       	sub	r8,-1
80008c2e:	fb 49 06 90 	st.w	sp[1680],r9
80008c32:	87 02       	st.w	r3[0x0],r2
80008c34:	87 10       	st.w	r3[0x4],r0
80008c36:	fb 48 06 8c 	st.w	sp[1676],r8
80008c3a:	58 78       	cp.w	r8,7
80008c3c:	e0 89 00 04 	brgt	80008c44 <_vfprintf_r+0x19b8>
80008c40:	2f 83       	sub	r3,-8
80008c42:	c0 b8       	rjmp	80008c58 <_vfprintf_r+0x19cc>
80008c44:	fa ca f9 78 	sub	r10,sp,-1672
80008c48:	02 9b       	mov	r11,r1
80008c4a:	08 9c       	mov	r12,r4
80008c4c:	fe b0 f3 12 	rcall	80007270 <__sprint_r>
80008c50:	e0 81 02 9d 	brne	8000918a <_vfprintf_r+0x1efe>
80008c54:	fa c3 f9 e0 	sub	r3,sp,-1568
80008c58:	21 06       	sub	r6,16
80008c5a:	c0 48       	rjmp	80008c62 <_vfprintf_r+0x19d6>
80008c5c:	fe c2 bb f8 	sub	r2,pc,-17416
80008c60:	31 00       	mov	r0,16
80008c62:	fa f9 06 90 	ld.w	r9,sp[1680]
80008c66:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008c6a:	fe ca bc 06 	sub	r10,pc,-17402
80008c6e:	59 06       	cp.w	r6,16
80008c70:	fe 99 ff dd 	brgt	80008c2a <_vfprintf_r+0x199e>
80008c74:	0c 09       	add	r9,r6
80008c76:	87 0a       	st.w	r3[0x0],r10
80008c78:	fb 49 06 90 	st.w	sp[1680],r9
80008c7c:	2f f8       	sub	r8,-1
80008c7e:	87 16       	st.w	r3[0x4],r6
80008c80:	c5 39       	rjmp	80008f26 <_vfprintf_r+0x1c9a>
80008c82:	fa fa 06 ac 	ld.w	r10,sp[1708]
80008c86:	58 0a       	cp.w	r10,0
80008c88:	e0 89 00 92 	brgt	80008dac <_vfprintf_r+0x1b20>
80008c8c:	fa f8 06 90 	ld.w	r8,sp[1680]
80008c90:	fe c9 bc 40 	sub	r9,pc,-17344
80008c94:	2f f8       	sub	r8,-1
80008c96:	87 09       	st.w	r3[0x0],r9
80008c98:	fb 48 06 90 	st.w	sp[1680],r8
80008c9c:	30 19       	mov	r9,1
80008c9e:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008ca2:	87 19       	st.w	r3[0x4],r9
80008ca4:	2f f8       	sub	r8,-1
80008ca6:	fb 48 06 8c 	st.w	sp[1676],r8
80008caa:	58 78       	cp.w	r8,7
80008cac:	e0 89 00 04 	brgt	80008cb4 <_vfprintf_r+0x1a28>
80008cb0:	2f 83       	sub	r3,-8
80008cb2:	c0 b8       	rjmp	80008cc8 <_vfprintf_r+0x1a3c>
80008cb4:	fa ca f9 78 	sub	r10,sp,-1672
80008cb8:	02 9b       	mov	r11,r1
80008cba:	08 9c       	mov	r12,r4
80008cbc:	fe b0 f2 da 	rcall	80007270 <__sprint_r>
80008cc0:	e0 81 02 65 	brne	8000918a <_vfprintf_r+0x1efe>
80008cc4:	fa c3 f9 e0 	sub	r3,sp,-1568
80008cc8:	fa f8 06 ac 	ld.w	r8,sp[1708]
80008ccc:	58 08       	cp.w	r8,0
80008cce:	c0 81       	brne	80008cde <_vfprintf_r+0x1a52>
80008cd0:	40 6a       	lddsp	r10,sp[0x18]
80008cd2:	58 0a       	cp.w	r10,0
80008cd4:	c0 51       	brne	80008cde <_vfprintf_r+0x1a52>
80008cd6:	ed b5 00 00 	bld	r5,0x0
80008cda:	e0 81 01 ed 	brne	800090b4 <_vfprintf_r+0x1e28>
80008cde:	40 c9       	lddsp	r9,sp[0x30]
80008ce0:	fa f8 06 90 	ld.w	r8,sp[1680]
80008ce4:	2f f8       	sub	r8,-1
80008ce6:	87 09       	st.w	r3[0x0],r9
80008ce8:	fb 48 06 90 	st.w	sp[1680],r8
80008cec:	30 19       	mov	r9,1
80008cee:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008cf2:	87 19       	st.w	r3[0x4],r9
80008cf4:	2f f8       	sub	r8,-1
80008cf6:	fb 48 06 8c 	st.w	sp[1676],r8
80008cfa:	58 78       	cp.w	r8,7
80008cfc:	e0 89 00 04 	brgt	80008d04 <_vfprintf_r+0x1a78>
80008d00:	2f 83       	sub	r3,-8
80008d02:	c0 b8       	rjmp	80008d18 <_vfprintf_r+0x1a8c>
80008d04:	fa ca f9 78 	sub	r10,sp,-1672
80008d08:	02 9b       	mov	r11,r1
80008d0a:	08 9c       	mov	r12,r4
80008d0c:	fe b0 f2 b2 	rcall	80007270 <__sprint_r>
80008d10:	e0 81 02 3d 	brne	8000918a <_vfprintf_r+0x1efe>
80008d14:	fa c3 f9 e0 	sub	r3,sp,-1568
80008d18:	fa f2 06 ac 	ld.w	r2,sp[1708]
80008d1c:	5c 32       	neg	r2
80008d1e:	58 02       	cp.w	r2,0
80008d20:	e0 89 00 1d 	brgt	80008d5a <_vfprintf_r+0x1ace>
80008d24:	c3 d8       	rjmp	80008d9e <_vfprintf_r+0x1b12>
80008d26:	2f 09       	sub	r9,-16
80008d28:	2f f8       	sub	r8,-1
80008d2a:	31 0e       	mov	lr,16
80008d2c:	fb 49 06 90 	st.w	sp[1680],r9
80008d30:	87 00       	st.w	r3[0x0],r0
80008d32:	87 1e       	st.w	r3[0x4],lr
80008d34:	fb 48 06 8c 	st.w	sp[1676],r8
80008d38:	58 78       	cp.w	r8,7
80008d3a:	e0 89 00 04 	brgt	80008d42 <_vfprintf_r+0x1ab6>
80008d3e:	2f 83       	sub	r3,-8
80008d40:	c0 b8       	rjmp	80008d56 <_vfprintf_r+0x1aca>
80008d42:	fa ca f9 78 	sub	r10,sp,-1672
80008d46:	02 9b       	mov	r11,r1
80008d48:	08 9c       	mov	r12,r4
80008d4a:	fe b0 f2 93 	rcall	80007270 <__sprint_r>
80008d4e:	e0 81 02 1e 	brne	8000918a <_vfprintf_r+0x1efe>
80008d52:	fa c3 f9 e0 	sub	r3,sp,-1568
80008d56:	21 02       	sub	r2,16
80008d58:	c0 38       	rjmp	80008d5e <_vfprintf_r+0x1ad2>
80008d5a:	fe c0 bc f6 	sub	r0,pc,-17162
80008d5e:	fa f9 06 90 	ld.w	r9,sp[1680]
80008d62:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008d66:	fe ca bd 02 	sub	r10,pc,-17150
80008d6a:	59 02       	cp.w	r2,16
80008d6c:	fe 99 ff dd 	brgt	80008d26 <_vfprintf_r+0x1a9a>
80008d70:	04 09       	add	r9,r2
80008d72:	2f f8       	sub	r8,-1
80008d74:	87 0a       	st.w	r3[0x0],r10
80008d76:	fb 49 06 90 	st.w	sp[1680],r9
80008d7a:	87 12       	st.w	r3[0x4],r2
80008d7c:	fb 48 06 8c 	st.w	sp[1676],r8
80008d80:	58 78       	cp.w	r8,7
80008d82:	e0 89 00 04 	brgt	80008d8a <_vfprintf_r+0x1afe>
80008d86:	2f 83       	sub	r3,-8
80008d88:	c0 b8       	rjmp	80008d9e <_vfprintf_r+0x1b12>
80008d8a:	fa ca f9 78 	sub	r10,sp,-1672
80008d8e:	02 9b       	mov	r11,r1
80008d90:	08 9c       	mov	r12,r4
80008d92:	fe b0 f2 6f 	rcall	80007270 <__sprint_r>
80008d96:	e0 81 01 fa 	brne	8000918a <_vfprintf_r+0x1efe>
80008d9a:	fa c3 f9 e0 	sub	r3,sp,-1568
80008d9e:	40 6c       	lddsp	r12,sp[0x18]
80008da0:	fa f8 06 90 	ld.w	r8,sp[1680]
80008da4:	87 06       	st.w	r3[0x0],r6
80008da6:	87 1c       	st.w	r3[0x4],r12
80008da8:	18 08       	add	r8,r12
80008daa:	cb 98       	rjmp	80008f1c <_vfprintf_r+0x1c90>
80008dac:	fa f9 06 90 	ld.w	r9,sp[1680]
80008db0:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008db4:	40 6b       	lddsp	r11,sp[0x18]
80008db6:	16 3a       	cp.w	r10,r11
80008db8:	c6 f5       	brlt	80008e96 <_vfprintf_r+0x1c0a>
80008dba:	16 09       	add	r9,r11
80008dbc:	2f f8       	sub	r8,-1
80008dbe:	87 06       	st.w	r3[0x0],r6
80008dc0:	fb 49 06 90 	st.w	sp[1680],r9
80008dc4:	87 1b       	st.w	r3[0x4],r11
80008dc6:	fb 48 06 8c 	st.w	sp[1676],r8
80008dca:	58 78       	cp.w	r8,7
80008dcc:	e0 89 00 04 	brgt	80008dd4 <_vfprintf_r+0x1b48>
80008dd0:	2f 83       	sub	r3,-8
80008dd2:	c0 b8       	rjmp	80008de8 <_vfprintf_r+0x1b5c>
80008dd4:	fa ca f9 78 	sub	r10,sp,-1672
80008dd8:	02 9b       	mov	r11,r1
80008dda:	08 9c       	mov	r12,r4
80008ddc:	fe b0 f2 4a 	rcall	80007270 <__sprint_r>
80008de0:	e0 81 01 d5 	brne	8000918a <_vfprintf_r+0x1efe>
80008de4:	fa c3 f9 e0 	sub	r3,sp,-1568
80008de8:	fa f6 06 ac 	ld.w	r6,sp[1708]
80008dec:	40 6a       	lddsp	r10,sp[0x18]
80008dee:	14 16       	sub	r6,r10
80008df0:	58 06       	cp.w	r6,0
80008df2:	e0 89 00 1c 	brgt	80008e2a <_vfprintf_r+0x1b9e>
80008df6:	c3 d8       	rjmp	80008e70 <_vfprintf_r+0x1be4>
80008df8:	2f 09       	sub	r9,-16
80008dfa:	2f f8       	sub	r8,-1
80008dfc:	fb 49 06 90 	st.w	sp[1680],r9
80008e00:	87 02       	st.w	r3[0x0],r2
80008e02:	87 10       	st.w	r3[0x4],r0
80008e04:	fb 48 06 8c 	st.w	sp[1676],r8
80008e08:	58 78       	cp.w	r8,7
80008e0a:	e0 89 00 04 	brgt	80008e12 <_vfprintf_r+0x1b86>
80008e0e:	2f 83       	sub	r3,-8
80008e10:	c0 b8       	rjmp	80008e26 <_vfprintf_r+0x1b9a>
80008e12:	fa ca f9 78 	sub	r10,sp,-1672
80008e16:	02 9b       	mov	r11,r1
80008e18:	08 9c       	mov	r12,r4
80008e1a:	fe b0 f2 2b 	rcall	80007270 <__sprint_r>
80008e1e:	e0 81 01 b6 	brne	8000918a <_vfprintf_r+0x1efe>
80008e22:	fa c3 f9 e0 	sub	r3,sp,-1568
80008e26:	21 06       	sub	r6,16
80008e28:	c0 48       	rjmp	80008e30 <_vfprintf_r+0x1ba4>
80008e2a:	fe c2 bd c6 	sub	r2,pc,-16954
80008e2e:	31 00       	mov	r0,16
80008e30:	fa f9 06 90 	ld.w	r9,sp[1680]
80008e34:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008e38:	fe ca bd d4 	sub	r10,pc,-16940
80008e3c:	59 06       	cp.w	r6,16
80008e3e:	fe 99 ff dd 	brgt	80008df8 <_vfprintf_r+0x1b6c>
80008e42:	0c 09       	add	r9,r6
80008e44:	2f f8       	sub	r8,-1
80008e46:	87 0a       	st.w	r3[0x0],r10
80008e48:	fb 49 06 90 	st.w	sp[1680],r9
80008e4c:	87 16       	st.w	r3[0x4],r6
80008e4e:	fb 48 06 8c 	st.w	sp[1676],r8
80008e52:	58 78       	cp.w	r8,7
80008e54:	e0 89 00 04 	brgt	80008e5c <_vfprintf_r+0x1bd0>
80008e58:	2f 83       	sub	r3,-8
80008e5a:	c0 b8       	rjmp	80008e70 <_vfprintf_r+0x1be4>
80008e5c:	fa ca f9 78 	sub	r10,sp,-1672
80008e60:	02 9b       	mov	r11,r1
80008e62:	08 9c       	mov	r12,r4
80008e64:	fe b0 f2 06 	rcall	80007270 <__sprint_r>
80008e68:	e0 81 01 91 	brne	8000918a <_vfprintf_r+0x1efe>
80008e6c:	fa c3 f9 e0 	sub	r3,sp,-1568
80008e70:	ed b5 00 00 	bld	r5,0x0
80008e74:	e0 81 01 20 	brne	800090b4 <_vfprintf_r+0x1e28>
80008e78:	40 c9       	lddsp	r9,sp[0x30]
80008e7a:	fa f8 06 90 	ld.w	r8,sp[1680]
80008e7e:	2f f8       	sub	r8,-1
80008e80:	87 09       	st.w	r3[0x0],r9
80008e82:	fb 48 06 90 	st.w	sp[1680],r8
80008e86:	30 19       	mov	r9,1
80008e88:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008e8c:	87 19       	st.w	r3[0x4],r9
80008e8e:	2f f8       	sub	r8,-1
80008e90:	fb 48 06 8c 	st.w	sp[1676],r8
80008e94:	c0 29       	rjmp	80009098 <_vfprintf_r+0x1e0c>
80008e96:	14 09       	add	r9,r10
80008e98:	2f f8       	sub	r8,-1
80008e9a:	fb 49 06 90 	st.w	sp[1680],r9
80008e9e:	87 06       	st.w	r3[0x0],r6
80008ea0:	87 1a       	st.w	r3[0x4],r10
80008ea2:	fb 48 06 8c 	st.w	sp[1676],r8
80008ea6:	58 78       	cp.w	r8,7
80008ea8:	e0 89 00 04 	brgt	80008eb0 <_vfprintf_r+0x1c24>
80008eac:	2f 83       	sub	r3,-8
80008eae:	c0 b8       	rjmp	80008ec4 <_vfprintf_r+0x1c38>
80008eb0:	fa ca f9 78 	sub	r10,sp,-1672
80008eb4:	02 9b       	mov	r11,r1
80008eb6:	08 9c       	mov	r12,r4
80008eb8:	fe b0 f1 dc 	rcall	80007270 <__sprint_r>
80008ebc:	e0 81 01 67 	brne	8000918a <_vfprintf_r+0x1efe>
80008ec0:	fa c3 f9 e0 	sub	r3,sp,-1568
80008ec4:	40 c8       	lddsp	r8,sp[0x30]
80008ec6:	87 08       	st.w	r3[0x0],r8
80008ec8:	fa f8 06 90 	ld.w	r8,sp[1680]
80008ecc:	2f f8       	sub	r8,-1
80008ece:	30 19       	mov	r9,1
80008ed0:	fb 48 06 90 	st.w	sp[1680],r8
80008ed4:	87 19       	st.w	r3[0x4],r9
80008ed6:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008eda:	2f f8       	sub	r8,-1
80008edc:	fb 48 06 8c 	st.w	sp[1676],r8
80008ee0:	fa f2 06 ac 	ld.w	r2,sp[1708]
80008ee4:	58 78       	cp.w	r8,7
80008ee6:	e0 89 00 04 	brgt	80008eee <_vfprintf_r+0x1c62>
80008eea:	2f 83       	sub	r3,-8
80008eec:	c0 b8       	rjmp	80008f02 <_vfprintf_r+0x1c76>
80008eee:	fa ca f9 78 	sub	r10,sp,-1672
80008ef2:	02 9b       	mov	r11,r1
80008ef4:	08 9c       	mov	r12,r4
80008ef6:	fe b0 f1 bd 	rcall	80007270 <__sprint_r>
80008efa:	e0 81 01 48 	brne	8000918a <_vfprintf_r+0x1efe>
80008efe:	fa c3 f9 e0 	sub	r3,sp,-1568
80008f02:	04 06       	add	r6,r2
80008f04:	fa f8 06 ac 	ld.w	r8,sp[1708]
80008f08:	87 06       	st.w	r3[0x0],r6
80008f0a:	fa f9 06 90 	ld.w	r9,sp[1680]
80008f0e:	40 66       	lddsp	r6,sp[0x18]
80008f10:	40 6e       	lddsp	lr,sp[0x18]
80008f12:	10 16       	sub	r6,r8
80008f14:	f2 08 01 08 	sub	r8,r9,r8
80008f18:	87 16       	st.w	r3[0x4],r6
80008f1a:	1c 08       	add	r8,lr
80008f1c:	fb 48 06 90 	st.w	sp[1680],r8
80008f20:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008f24:	2f f8       	sub	r8,-1
80008f26:	fb 48 06 8c 	st.w	sp[1676],r8
80008f2a:	cb 78       	rjmp	80009098 <_vfprintf_r+0x1e0c>
80008f2c:	40 6c       	lddsp	r12,sp[0x18]
80008f2e:	58 1c       	cp.w	r12,1
80008f30:	e0 89 00 06 	brgt	80008f3c <_vfprintf_r+0x1cb0>
80008f34:	ed b5 00 00 	bld	r5,0x0
80008f38:	e0 81 00 85 	brne	80009042 <_vfprintf_r+0x1db6>
80008f3c:	fa f8 06 90 	ld.w	r8,sp[1680]
80008f40:	2f f8       	sub	r8,-1
80008f42:	30 19       	mov	r9,1
80008f44:	fb 48 06 90 	st.w	sp[1680],r8
80008f48:	87 06       	st.w	r3[0x0],r6
80008f4a:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008f4e:	87 19       	st.w	r3[0x4],r9
80008f50:	2f f8       	sub	r8,-1
80008f52:	fb 48 06 8c 	st.w	sp[1676],r8
80008f56:	58 78       	cp.w	r8,7
80008f58:	e0 89 00 04 	brgt	80008f60 <_vfprintf_r+0x1cd4>
80008f5c:	2f 83       	sub	r3,-8
80008f5e:	c0 b8       	rjmp	80008f74 <_vfprintf_r+0x1ce8>
80008f60:	fa ca f9 78 	sub	r10,sp,-1672
80008f64:	02 9b       	mov	r11,r1
80008f66:	08 9c       	mov	r12,r4
80008f68:	fe b0 f1 84 	rcall	80007270 <__sprint_r>
80008f6c:	e0 81 01 0f 	brne	8000918a <_vfprintf_r+0x1efe>
80008f70:	fa c3 f9 e0 	sub	r3,sp,-1568
80008f74:	fa f8 06 90 	ld.w	r8,sp[1680]
80008f78:	2f f8       	sub	r8,-1
80008f7a:	40 cb       	lddsp	r11,sp[0x30]
80008f7c:	fb 48 06 90 	st.w	sp[1680],r8
80008f80:	30 19       	mov	r9,1
80008f82:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008f86:	87 0b       	st.w	r3[0x0],r11
80008f88:	2f f8       	sub	r8,-1
80008f8a:	87 19       	st.w	r3[0x4],r9
80008f8c:	fb 48 06 8c 	st.w	sp[1676],r8
80008f90:	58 78       	cp.w	r8,7
80008f92:	e0 89 00 05 	brgt	80008f9c <_vfprintf_r+0x1d10>
80008f96:	2f 83       	sub	r3,-8
80008f98:	c0 c8       	rjmp	80008fb0 <_vfprintf_r+0x1d24>
80008f9a:	d7 03       	nop
80008f9c:	fa ca f9 78 	sub	r10,sp,-1672
80008fa0:	02 9b       	mov	r11,r1
80008fa2:	08 9c       	mov	r12,r4
80008fa4:	fe b0 f1 66 	rcall	80007270 <__sprint_r>
80008fa8:	e0 81 00 f1 	brne	8000918a <_vfprintf_r+0x1efe>
80008fac:	fa c3 f9 e0 	sub	r3,sp,-1568
80008fb0:	30 08       	mov	r8,0
80008fb2:	30 09       	mov	r9,0
80008fb4:	40 5b       	lddsp	r11,sp[0x14]
80008fb6:	40 7a       	lddsp	r10,sp[0x1c]
80008fb8:	e0 a0 13 25 	rcall	8000b602 <__avr32_f64_cmp_eq>
80008fbc:	40 68       	lddsp	r8,sp[0x18]
80008fbe:	20 18       	sub	r8,1
80008fc0:	58 0c       	cp.w	r12,0
80008fc2:	c0 d1       	brne	80008fdc <_vfprintf_r+0x1d50>
80008fc4:	2f f6       	sub	r6,-1
80008fc6:	87 18       	st.w	r3[0x4],r8
80008fc8:	87 06       	st.w	r3[0x0],r6
80008fca:	fa f6 06 90 	ld.w	r6,sp[1680]
80008fce:	10 06       	add	r6,r8
80008fd0:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008fd4:	fb 46 06 90 	st.w	sp[1680],r6
80008fd8:	2f f8       	sub	r8,-1
80008fda:	c3 18       	rjmp	8000903c <_vfprintf_r+0x1db0>
80008fdc:	10 96       	mov	r6,r8
80008fde:	58 08       	cp.w	r8,0
80008fe0:	e0 89 00 1c 	brgt	80009018 <_vfprintf_r+0x1d8c>
80008fe4:	c4 b8       	rjmp	8000907a <_vfprintf_r+0x1dee>
80008fe6:	2f 09       	sub	r9,-16
80008fe8:	2f f8       	sub	r8,-1
80008fea:	fb 49 06 90 	st.w	sp[1680],r9
80008fee:	87 02       	st.w	r3[0x0],r2
80008ff0:	87 10       	st.w	r3[0x4],r0
80008ff2:	fb 48 06 8c 	st.w	sp[1676],r8
80008ff6:	58 78       	cp.w	r8,7
80008ff8:	e0 89 00 04 	brgt	80009000 <_vfprintf_r+0x1d74>
80008ffc:	2f 83       	sub	r3,-8
80008ffe:	c0 b8       	rjmp	80009014 <_vfprintf_r+0x1d88>
80009000:	fa ca f9 78 	sub	r10,sp,-1672
80009004:	02 9b       	mov	r11,r1
80009006:	08 9c       	mov	r12,r4
80009008:	fe b0 f1 34 	rcall	80007270 <__sprint_r>
8000900c:	e0 81 00 bf 	brne	8000918a <_vfprintf_r+0x1efe>
80009010:	fa c3 f9 e0 	sub	r3,sp,-1568
80009014:	21 06       	sub	r6,16
80009016:	c0 48       	rjmp	8000901e <_vfprintf_r+0x1d92>
80009018:	fe c2 bf b4 	sub	r2,pc,-16460
8000901c:	31 00       	mov	r0,16
8000901e:	fa f9 06 90 	ld.w	r9,sp[1680]
80009022:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009026:	fe ca bf c2 	sub	r10,pc,-16446
8000902a:	59 06       	cp.w	r6,16
8000902c:	fe 99 ff dd 	brgt	80008fe6 <_vfprintf_r+0x1d5a>
80009030:	0c 09       	add	r9,r6
80009032:	87 0a       	st.w	r3[0x0],r10
80009034:	fb 49 06 90 	st.w	sp[1680],r9
80009038:	2f f8       	sub	r8,-1
8000903a:	87 16       	st.w	r3[0x4],r6
8000903c:	fb 48 06 8c 	st.w	sp[1676],r8
80009040:	c0 e8       	rjmp	8000905c <_vfprintf_r+0x1dd0>
80009042:	fa f8 06 90 	ld.w	r8,sp[1680]
80009046:	2f f8       	sub	r8,-1
80009048:	30 19       	mov	r9,1
8000904a:	fb 48 06 90 	st.w	sp[1680],r8
8000904e:	87 06       	st.w	r3[0x0],r6
80009050:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009054:	87 19       	st.w	r3[0x4],r9
80009056:	2f f8       	sub	r8,-1
80009058:	fb 48 06 8c 	st.w	sp[1676],r8
8000905c:	58 78       	cp.w	r8,7
8000905e:	e0 89 00 04 	brgt	80009066 <_vfprintf_r+0x1dda>
80009062:	2f 83       	sub	r3,-8
80009064:	c0 b8       	rjmp	8000907a <_vfprintf_r+0x1dee>
80009066:	fa ca f9 78 	sub	r10,sp,-1672
8000906a:	02 9b       	mov	r11,r1
8000906c:	08 9c       	mov	r12,r4
8000906e:	fe b0 f1 01 	rcall	80007270 <__sprint_r>
80009072:	e0 81 00 8c 	brne	8000918a <_vfprintf_r+0x1efe>
80009076:	fa c3 f9 e0 	sub	r3,sp,-1568
8000907a:	40 ea       	lddsp	r10,sp[0x38]
8000907c:	fa f8 06 90 	ld.w	r8,sp[1680]
80009080:	14 08       	add	r8,r10
80009082:	fa c9 f9 64 	sub	r9,sp,-1692
80009086:	fb 48 06 90 	st.w	sp[1680],r8
8000908a:	87 1a       	st.w	r3[0x4],r10
8000908c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009090:	87 09       	st.w	r3[0x0],r9
80009092:	2f f8       	sub	r8,-1
80009094:	fb 48 06 8c 	st.w	sp[1676],r8
80009098:	58 78       	cp.w	r8,7
8000909a:	e0 89 00 04 	brgt	800090a2 <_vfprintf_r+0x1e16>
8000909e:	2f 83       	sub	r3,-8
800090a0:	c0 a8       	rjmp	800090b4 <_vfprintf_r+0x1e28>
800090a2:	fa ca f9 78 	sub	r10,sp,-1672
800090a6:	02 9b       	mov	r11,r1
800090a8:	08 9c       	mov	r12,r4
800090aa:	fe b0 f0 e3 	rcall	80007270 <__sprint_r>
800090ae:	c6 e1       	brne	8000918a <_vfprintf_r+0x1efe>
800090b0:	fa c3 f9 e0 	sub	r3,sp,-1568
800090b4:	e2 15 00 04 	andl	r5,0x4,COH
800090b8:	c3 f0       	breq	80009136 <_vfprintf_r+0x1eaa>
800090ba:	40 86       	lddsp	r6,sp[0x20]
800090bc:	40 39       	lddsp	r9,sp[0xc]
800090be:	12 16       	sub	r6,r9
800090c0:	58 06       	cp.w	r6,0
800090c2:	e0 89 00 1a 	brgt	800090f6 <_vfprintf_r+0x1e6a>
800090c6:	c3 88       	rjmp	80009136 <_vfprintf_r+0x1eaa>
800090c8:	2f 09       	sub	r9,-16
800090ca:	2f f8       	sub	r8,-1
800090cc:	fb 49 06 90 	st.w	sp[1680],r9
800090d0:	87 05       	st.w	r3[0x0],r5
800090d2:	87 12       	st.w	r3[0x4],r2
800090d4:	fb 48 06 8c 	st.w	sp[1676],r8
800090d8:	58 78       	cp.w	r8,7
800090da:	e0 89 00 04 	brgt	800090e2 <_vfprintf_r+0x1e56>
800090de:	2f 83       	sub	r3,-8
800090e0:	c0 98       	rjmp	800090f2 <_vfprintf_r+0x1e66>
800090e2:	00 9a       	mov	r10,r0
800090e4:	02 9b       	mov	r11,r1
800090e6:	08 9c       	mov	r12,r4
800090e8:	fe b0 f0 c4 	rcall	80007270 <__sprint_r>
800090ec:	c4 f1       	brne	8000918a <_vfprintf_r+0x1efe>
800090ee:	fa c3 f9 e0 	sub	r3,sp,-1568
800090f2:	21 06       	sub	r6,16
800090f4:	c0 68       	rjmp	80009100 <_vfprintf_r+0x1e74>
800090f6:	fe c5 c0 a2 	sub	r5,pc,-16222
800090fa:	31 02       	mov	r2,16
800090fc:	fa c0 f9 78 	sub	r0,sp,-1672
80009100:	fa f9 06 90 	ld.w	r9,sp[1680]
80009104:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009108:	fe ca c0 b4 	sub	r10,pc,-16204
8000910c:	59 06       	cp.w	r6,16
8000910e:	fe 99 ff dd 	brgt	800090c8 <_vfprintf_r+0x1e3c>
80009112:	0c 09       	add	r9,r6
80009114:	2f f8       	sub	r8,-1
80009116:	87 0a       	st.w	r3[0x0],r10
80009118:	87 16       	st.w	r3[0x4],r6
8000911a:	fb 49 06 90 	st.w	sp[1680],r9
8000911e:	fb 48 06 8c 	st.w	sp[1676],r8
80009122:	58 78       	cp.w	r8,7
80009124:	e0 8a 00 09 	brle	80009136 <_vfprintf_r+0x1eaa>
80009128:	fa ca f9 78 	sub	r10,sp,-1672
8000912c:	02 9b       	mov	r11,r1
8000912e:	08 9c       	mov	r12,r4
80009130:	fe b0 f0 a0 	rcall	80007270 <__sprint_r>
80009134:	c2 b1       	brne	8000918a <_vfprintf_r+0x1efe>
80009136:	40 bc       	lddsp	r12,sp[0x2c]
80009138:	40 36       	lddsp	r6,sp[0xc]
8000913a:	40 8e       	lddsp	lr,sp[0x20]
8000913c:	ec 0e 0c 48 	max	r8,r6,lr
80009140:	10 0c       	add	r12,r8
80009142:	50 bc       	stdsp	sp[0x2c],r12
80009144:	fa f8 06 90 	ld.w	r8,sp[1680]
80009148:	58 08       	cp.w	r8,0
8000914a:	c0 80       	breq	8000915a <_vfprintf_r+0x1ece>
8000914c:	fa ca f9 78 	sub	r10,sp,-1672
80009150:	02 9b       	mov	r11,r1
80009152:	08 9c       	mov	r12,r4
80009154:	fe b0 f0 8e 	rcall	80007270 <__sprint_r>
80009158:	c1 91       	brne	8000918a <_vfprintf_r+0x1efe>
8000915a:	30 0b       	mov	r11,0
8000915c:	fa c3 f9 e0 	sub	r3,sp,-1568
80009160:	fb 4b 06 8c 	st.w	sp[1676],r11
80009164:	fe 9f f1 22 	bral	800073a8 <_vfprintf_r+0x11c>
80009168:	08 95       	mov	r5,r4
8000916a:	fa f8 06 90 	ld.w	r8,sp[1680]
8000916e:	58 08       	cp.w	r8,0
80009170:	c0 80       	breq	80009180 <_vfprintf_r+0x1ef4>
80009172:	08 9c       	mov	r12,r4
80009174:	fa ca f9 78 	sub	r10,sp,-1672
80009178:	02 9b       	mov	r11,r1
8000917a:	fe b0 f0 7b 	rcall	80007270 <__sprint_r>
8000917e:	c0 61       	brne	8000918a <_vfprintf_r+0x1efe>
80009180:	30 08       	mov	r8,0
80009182:	fb 48 06 8c 	st.w	sp[1676],r8
80009186:	c0 28       	rjmp	8000918a <_vfprintf_r+0x1efe>
80009188:	40 41       	lddsp	r1,sp[0x10]
8000918a:	82 68       	ld.sh	r8,r1[0xc]
8000918c:	ed b8 00 06 	bld	r8,0x6
80009190:	c0 31       	brne	80009196 <_vfprintf_r+0x1f0a>
80009192:	3f fa       	mov	r10,-1
80009194:	50 ba       	stdsp	sp[0x2c],r10
80009196:	40 bc       	lddsp	r12,sp[0x2c]
80009198:	fe 3d f9 44 	sub	sp,-1724
8000919c:	d8 32       	popm	r0-r7,pc
8000919e:	d7 03       	nop

800091a0 <__swsetup_r>:
800091a0:	d4 21       	pushm	r4-r7,lr
800091a2:	e0 68 0a 40 	mov	r8,2624
800091a6:	18 96       	mov	r6,r12
800091a8:	16 97       	mov	r7,r11
800091aa:	70 0c       	ld.w	r12,r8[0x0]
800091ac:	58 0c       	cp.w	r12,0
800091ae:	c0 60       	breq	800091ba <__swsetup_r+0x1a>
800091b0:	78 68       	ld.w	r8,r12[0x18]
800091b2:	58 08       	cp.w	r8,0
800091b4:	c0 31       	brne	800091ba <__swsetup_r+0x1a>
800091b6:	e0 a0 07 bf 	rcall	8000a134 <__sinit>
800091ba:	fe c8 c0 36 	sub	r8,pc,-16330
800091be:	10 37       	cp.w	r7,r8
800091c0:	c0 61       	brne	800091cc <__swsetup_r+0x2c>
800091c2:	e0 68 0a 40 	mov	r8,2624
800091c6:	70 08       	ld.w	r8,r8[0x0]
800091c8:	70 07       	ld.w	r7,r8[0x0]
800091ca:	c1 28       	rjmp	800091ee <__swsetup_r+0x4e>
800091cc:	fe c8 c0 28 	sub	r8,pc,-16344
800091d0:	10 37       	cp.w	r7,r8
800091d2:	c0 61       	brne	800091de <__swsetup_r+0x3e>
800091d4:	e0 68 0a 40 	mov	r8,2624
800091d8:	70 08       	ld.w	r8,r8[0x0]
800091da:	70 17       	ld.w	r7,r8[0x4]
800091dc:	c0 98       	rjmp	800091ee <__swsetup_r+0x4e>
800091de:	fe c8 c0 1a 	sub	r8,pc,-16358
800091e2:	10 37       	cp.w	r7,r8
800091e4:	c0 51       	brne	800091ee <__swsetup_r+0x4e>
800091e6:	e0 68 0a 40 	mov	r8,2624
800091ea:	70 08       	ld.w	r8,r8[0x0]
800091ec:	70 27       	ld.w	r7,r8[0x8]
800091ee:	8e 68       	ld.sh	r8,r7[0xc]
800091f0:	ed b8 00 03 	bld	r8,0x3
800091f4:	c1 e0       	breq	80009230 <__swsetup_r+0x90>
800091f6:	ed b8 00 04 	bld	r8,0x4
800091fa:	c3 e1       	brne	80009276 <__swsetup_r+0xd6>
800091fc:	ed b8 00 02 	bld	r8,0x2
80009200:	c1 51       	brne	8000922a <__swsetup_r+0x8a>
80009202:	6e db       	ld.w	r11,r7[0x34]
80009204:	58 0b       	cp.w	r11,0
80009206:	c0 a0       	breq	8000921a <__swsetup_r+0x7a>
80009208:	ee c8 ff bc 	sub	r8,r7,-68
8000920c:	10 3b       	cp.w	r11,r8
8000920e:	c0 40       	breq	80009216 <__swsetup_r+0x76>
80009210:	0c 9c       	mov	r12,r6
80009212:	e0 a0 08 2b 	rcall	8000a268 <_free_r>
80009216:	30 08       	mov	r8,0
80009218:	8f d8       	st.w	r7[0x34],r8
8000921a:	8e 68       	ld.sh	r8,r7[0xc]
8000921c:	e0 18 ff db 	andl	r8,0xffdb
80009220:	ae 68       	st.h	r7[0xc],r8
80009222:	30 08       	mov	r8,0
80009224:	8f 18       	st.w	r7[0x4],r8
80009226:	6e 48       	ld.w	r8,r7[0x10]
80009228:	8f 08       	st.w	r7[0x0],r8
8000922a:	8e 68       	ld.sh	r8,r7[0xc]
8000922c:	a3 b8       	sbr	r8,0x3
8000922e:	ae 68       	st.h	r7[0xc],r8
80009230:	6e 48       	ld.w	r8,r7[0x10]
80009232:	58 08       	cp.w	r8,0
80009234:	c0 b1       	brne	8000924a <__swsetup_r+0xaa>
80009236:	8e 68       	ld.sh	r8,r7[0xc]
80009238:	e2 18 02 80 	andl	r8,0x280,COH
8000923c:	e0 48 02 00 	cp.w	r8,512
80009240:	c0 50       	breq	8000924a <__swsetup_r+0xaa>
80009242:	0c 9c       	mov	r12,r6
80009244:	0e 9b       	mov	r11,r7
80009246:	e0 a0 0a 4b 	rcall	8000a6dc <__smakebuf_r>
8000924a:	8e 69       	ld.sh	r9,r7[0xc]
8000924c:	f1 d9 c0 01 	bfextu	r8,r9,0x0,0x1
80009250:	c0 70       	breq	8000925e <__swsetup_r+0xbe>
80009252:	30 08       	mov	r8,0
80009254:	8f 28       	st.w	r7[0x8],r8
80009256:	6e 58       	ld.w	r8,r7[0x14]
80009258:	5c 38       	neg	r8
8000925a:	8f 68       	st.w	r7[0x18],r8
8000925c:	c0 68       	rjmp	80009268 <__swsetup_r+0xc8>
8000925e:	ed b9 00 01 	bld	r9,0x1
80009262:	ef f8 10 05 	ld.wne	r8,r7[0x14]
80009266:	8f 28       	st.w	r7[0x8],r8
80009268:	6e 48       	ld.w	r8,r7[0x10]
8000926a:	58 08       	cp.w	r8,0
8000926c:	c0 61       	brne	80009278 <__swsetup_r+0xd8>
8000926e:	8e 68       	ld.sh	r8,r7[0xc]
80009270:	ed b8 00 07 	bld	r8,0x7
80009274:	c0 21       	brne	80009278 <__swsetup_r+0xd8>
80009276:	dc 2a       	popm	r4-r7,pc,r12=-1
80009278:	d8 2a       	popm	r4-r7,pc,r12=0
8000927a:	d7 03       	nop

8000927c <quorem>:
8000927c:	d4 31       	pushm	r0-r7,lr
8000927e:	20 2d       	sub	sp,8
80009280:	18 97       	mov	r7,r12
80009282:	78 48       	ld.w	r8,r12[0x10]
80009284:	76 46       	ld.w	r6,r11[0x10]
80009286:	0c 38       	cp.w	r8,r6
80009288:	c0 34       	brge	8000928e <quorem+0x12>
8000928a:	30 0c       	mov	r12,0
8000928c:	c8 58       	rjmp	80009396 <quorem+0x11a>
8000928e:	ec c2 ff fc 	sub	r2,r6,-4
80009292:	f6 c3 ff ec 	sub	r3,r11,-20
80009296:	f6 02 03 29 	ld.w	r9,r11[r2<<0x2]
8000929a:	f8 02 03 2c 	ld.w	r12,r12[r2<<0x2]
8000929e:	2f f9       	sub	r9,-1
800092a0:	20 16       	sub	r6,1
800092a2:	f8 09 0d 08 	divu	r8,r12,r9
800092a6:	f6 02 00 22 	add	r2,r11,r2<<0x2
800092aa:	ee c4 ff ec 	sub	r4,r7,-20
800092ae:	10 95       	mov	r5,r8
800092b0:	58 08       	cp.w	r8,0
800092b2:	c4 10       	breq	80009334 <quorem+0xb8>
800092b4:	30 09       	mov	r9,0
800092b6:	06 9a       	mov	r10,r3
800092b8:	08 98       	mov	r8,r4
800092ba:	12 91       	mov	r1,r9
800092bc:	50 0b       	stdsp	sp[0x0],r11
800092be:	70 0e       	ld.w	lr,r8[0x0]
800092c0:	b1 8e       	lsr	lr,0x10
800092c2:	50 1e       	stdsp	sp[0x4],lr
800092c4:	15 0e       	ld.w	lr,r10++
800092c6:	fc 00 16 10 	lsr	r0,lr,0x10
800092ca:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
800092ce:	ea 0e 03 41 	mac	r1,r5,lr
800092d2:	fd d1 c0 10 	bfextu	lr,r1,0x0,0x10
800092d6:	b1 81       	lsr	r1,0x10
800092d8:	40 1b       	lddsp	r11,sp[0x4]
800092da:	ea 00 02 40 	mul	r0,r5,r0
800092de:	e2 00 00 00 	add	r0,r1,r0
800092e2:	e3 d0 c0 10 	bfextu	r1,r0,0x0,0x10
800092e6:	02 1b       	sub	r11,r1
800092e8:	50 1b       	stdsp	sp[0x4],r11
800092ea:	70 0b       	ld.w	r11,r8[0x0]
800092ec:	e3 db c0 10 	bfextu	r1,r11,0x0,0x10
800092f0:	02 09       	add	r9,r1
800092f2:	f2 0e 01 0e 	sub	lr,r9,lr
800092f6:	b0 1e       	st.h	r8[0x2],lr
800092f8:	fc 09 14 10 	asr	r9,lr,0x10
800092fc:	40 1e       	lddsp	lr,sp[0x4]
800092fe:	fc 09 00 09 	add	r9,lr,r9
80009302:	b0 09       	st.h	r8[0x0],r9
80009304:	e0 01 16 10 	lsr	r1,r0,0x10
80009308:	2f c8       	sub	r8,-4
8000930a:	b1 49       	asr	r9,0x10
8000930c:	04 3a       	cp.w	r10,r2
8000930e:	fe 98 ff d8 	brls	800092be <quorem+0x42>
80009312:	40 0b       	lddsp	r11,sp[0x0]
80009314:	58 0c       	cp.w	r12,0
80009316:	c0 f1       	brne	80009334 <quorem+0xb8>
80009318:	ec c8 ff fb 	sub	r8,r6,-5
8000931c:	ee 08 00 28 	add	r8,r7,r8<<0x2
80009320:	c0 28       	rjmp	80009324 <quorem+0xa8>
80009322:	20 16       	sub	r6,1
80009324:	20 48       	sub	r8,4
80009326:	08 38       	cp.w	r8,r4
80009328:	e0 88 00 05 	brls	80009332 <quorem+0xb6>
8000932c:	70 09       	ld.w	r9,r8[0x0]
8000932e:	58 09       	cp.w	r9,0
80009330:	cf 90       	breq	80009322 <quorem+0xa6>
80009332:	8f 46       	st.w	r7[0x10],r6
80009334:	0e 9c       	mov	r12,r7
80009336:	e0 a0 0a d2 	rcall	8000a8da <__mcmp>
8000933a:	c2 d5       	brlt	80009394 <quorem+0x118>
8000933c:	2f f5       	sub	r5,-1
8000933e:	08 98       	mov	r8,r4
80009340:	30 09       	mov	r9,0
80009342:	07 0b       	ld.w	r11,r3++
80009344:	f6 0a 16 10 	lsr	r10,r11,0x10
80009348:	70 0c       	ld.w	r12,r8[0x0]
8000934a:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000934e:	f8 0e 16 10 	lsr	lr,r12,0x10
80009352:	14 1e       	sub	lr,r10
80009354:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
80009358:	16 1a       	sub	r10,r11
8000935a:	12 0a       	add	r10,r9
8000935c:	b0 1a       	st.h	r8[0x2],r10
8000935e:	b1 4a       	asr	r10,0x10
80009360:	fc 0a 00 09 	add	r9,lr,r10
80009364:	b0 09       	st.h	r8[0x0],r9
80009366:	2f c8       	sub	r8,-4
80009368:	b1 49       	asr	r9,0x10
8000936a:	04 33       	cp.w	r3,r2
8000936c:	fe 98 ff eb 	brls	80009342 <quorem+0xc6>
80009370:	ec c8 ff fb 	sub	r8,r6,-5
80009374:	ee 08 03 29 	ld.w	r9,r7[r8<<0x2]
80009378:	58 09       	cp.w	r9,0
8000937a:	c0 d1       	brne	80009394 <quorem+0x118>
8000937c:	ee 08 00 28 	add	r8,r7,r8<<0x2
80009380:	c0 28       	rjmp	80009384 <quorem+0x108>
80009382:	20 16       	sub	r6,1
80009384:	20 48       	sub	r8,4
80009386:	08 38       	cp.w	r8,r4
80009388:	e0 88 00 05 	brls	80009392 <quorem+0x116>
8000938c:	70 09       	ld.w	r9,r8[0x0]
8000938e:	58 09       	cp.w	r9,0
80009390:	cf 90       	breq	80009382 <quorem+0x106>
80009392:	8f 46       	st.w	r7[0x10],r6
80009394:	0a 9c       	mov	r12,r5
80009396:	2f ed       	sub	sp,-8
80009398:	d8 32       	popm	r0-r7,pc
8000939a:	d7 03       	nop

8000939c <_dtoa_r>:
8000939c:	d4 31       	pushm	r0-r7,lr
8000939e:	21 ad       	sub	sp,104
800093a0:	fa c4 ff 74 	sub	r4,sp,-140
800093a4:	18 97       	mov	r7,r12
800093a6:	16 95       	mov	r5,r11
800093a8:	68 2c       	ld.w	r12,r4[0x8]
800093aa:	50 c9       	stdsp	sp[0x30],r9
800093ac:	68 16       	ld.w	r6,r4[0x4]
800093ae:	68 09       	ld.w	r9,r4[0x0]
800093b0:	50 e8       	stdsp	sp[0x38],r8
800093b2:	14 94       	mov	r4,r10
800093b4:	51 2c       	stdsp	sp[0x48],r12
800093b6:	fa e5 00 08 	st.d	sp[8],r4
800093ba:	51 59       	stdsp	sp[0x54],r9
800093bc:	6e 95       	ld.w	r5,r7[0x24]
800093be:	58 05       	cp.w	r5,0
800093c0:	c0 91       	brne	800093d2 <_dtoa_r+0x36>
800093c2:	31 0c       	mov	r12,16
800093c4:	fe b0 e8 f4 	rcall	800065ac <malloc>
800093c8:	99 35       	st.w	r12[0xc],r5
800093ca:	8f 9c       	st.w	r7[0x24],r12
800093cc:	99 15       	st.w	r12[0x4],r5
800093ce:	99 25       	st.w	r12[0x8],r5
800093d0:	99 05       	st.w	r12[0x0],r5
800093d2:	6e 99       	ld.w	r9,r7[0x24]
800093d4:	72 08       	ld.w	r8,r9[0x0]
800093d6:	58 08       	cp.w	r8,0
800093d8:	c0 f0       	breq	800093f6 <_dtoa_r+0x5a>
800093da:	72 1a       	ld.w	r10,r9[0x4]
800093dc:	91 1a       	st.w	r8[0x4],r10
800093de:	30 1a       	mov	r10,1
800093e0:	72 19       	ld.w	r9,r9[0x4]
800093e2:	f4 09 09 49 	lsl	r9,r10,r9
800093e6:	10 9b       	mov	r11,r8
800093e8:	91 29       	st.w	r8[0x8],r9
800093ea:	0e 9c       	mov	r12,r7
800093ec:	e0 a0 0a 90 	rcall	8000a90c <_Bfree>
800093f0:	6e 98       	ld.w	r8,r7[0x24]
800093f2:	30 09       	mov	r9,0
800093f4:	91 09       	st.w	r8[0x0],r9
800093f6:	40 28       	lddsp	r8,sp[0x8]
800093f8:	10 94       	mov	r4,r8
800093fa:	58 08       	cp.w	r8,0
800093fc:	c0 64       	brge	80009408 <_dtoa_r+0x6c>
800093fe:	f1 d8 c0 1f 	bfextu	r8,r8,0x0,0x1f
80009402:	50 28       	stdsp	sp[0x8],r8
80009404:	30 18       	mov	r8,1
80009406:	c0 28       	rjmp	8000940a <_dtoa_r+0x6e>
80009408:	30 08       	mov	r8,0
8000940a:	8d 08       	st.w	r6[0x0],r8
8000940c:	fc 1c 7f f0 	movh	r12,0x7ff0
80009410:	40 26       	lddsp	r6,sp[0x8]
80009412:	0c 98       	mov	r8,r6
80009414:	e6 18 7f f0 	andh	r8,0x7ff0,COH
80009418:	18 38       	cp.w	r8,r12
8000941a:	c2 01       	brne	8000945a <_dtoa_r+0xbe>
8000941c:	e0 68 27 0f 	mov	r8,9999
80009420:	41 5b       	lddsp	r11,sp[0x54]
80009422:	97 08       	st.w	r11[0x0],r8
80009424:	40 3a       	lddsp	r10,sp[0xc]
80009426:	58 0a       	cp.w	r10,0
80009428:	c0 71       	brne	80009436 <_dtoa_r+0x9a>
8000942a:	ed d6 c0 14 	bfextu	r6,r6,0x0,0x14
8000942e:	c0 41       	brne	80009436 <_dtoa_r+0x9a>
80009430:	fe cc c2 bc 	sub	r12,pc,-15684
80009434:	c0 38       	rjmp	8000943a <_dtoa_r+0x9e>
80009436:	fe cc c2 b6 	sub	r12,pc,-15690
8000943a:	41 29       	lddsp	r9,sp[0x48]
8000943c:	58 09       	cp.w	r9,0
8000943e:	e0 80 05 9a 	breq	80009f72 <_dtoa_r+0xbd6>
80009442:	f8 c8 ff fd 	sub	r8,r12,-3
80009446:	f8 c9 ff f8 	sub	r9,r12,-8
8000944a:	11 8b       	ld.ub	r11,r8[0x0]
8000944c:	30 0a       	mov	r10,0
8000944e:	41 25       	lddsp	r5,sp[0x48]
80009450:	f4 0b 18 00 	cp.b	r11,r10
80009454:	f2 08 17 10 	movne	r8,r9
80009458:	c1 68       	rjmp	80009484 <_dtoa_r+0xe8>
8000945a:	fa ea 00 08 	ld.d	r10,sp[8]
8000945e:	30 08       	mov	r8,0
80009460:	fa eb 00 3c 	st.d	sp[60],r10
80009464:	30 09       	mov	r9,0
80009466:	e0 a0 10 ce 	rcall	8000b602 <__avr32_f64_cmp_eq>
8000946a:	c1 00       	breq	8000948a <_dtoa_r+0xee>
8000946c:	30 18       	mov	r8,1
8000946e:	41 5a       	lddsp	r10,sp[0x54]
80009470:	95 08       	st.w	r10[0x0],r8
80009472:	fe cc c4 22 	sub	r12,pc,-15326
80009476:	41 29       	lddsp	r9,sp[0x48]
80009478:	f8 08 00 08 	add	r8,r12,r8
8000947c:	58 09       	cp.w	r9,0
8000947e:	e0 80 05 7a 	breq	80009f72 <_dtoa_r+0xbd6>
80009482:	12 95       	mov	r5,r9
80009484:	8b 08       	st.w	r5[0x0],r8
80009486:	e0 8f 05 76 	bral	80009f72 <_dtoa_r+0xbd6>
8000948a:	fa c8 ff 9c 	sub	r8,sp,-100
8000948e:	fa c9 ff a0 	sub	r9,sp,-96
80009492:	fa ea 00 3c 	ld.d	r10,sp[60]
80009496:	0e 9c       	mov	r12,r7
80009498:	eb d6 c2 8b 	bfextu	r5,r6,0x14,0xb
8000949c:	e0 a0 0a 8a 	rcall	8000a9b0 <__d2b>
800094a0:	18 93       	mov	r3,r12
800094a2:	58 05       	cp.w	r5,0
800094a4:	c0 d0       	breq	800094be <_dtoa_r+0x122>
800094a6:	fa ea 00 3c 	ld.d	r10,sp[60]
800094aa:	30 04       	mov	r4,0
800094ac:	f1 db c0 14 	bfextu	r8,r11,0x0,0x14
800094b0:	ea c5 03 ff 	sub	r5,r5,1023
800094b4:	10 9b       	mov	r11,r8
800094b6:	51 74       	stdsp	sp[0x5c],r4
800094b8:	ea 1b 3f f0 	orh	r11,0x3ff0
800094bc:	c2 58       	rjmp	80009506 <_dtoa_r+0x16a>
800094be:	41 88       	lddsp	r8,sp[0x60]
800094c0:	41 9c       	lddsp	r12,sp[0x64]
800094c2:	10 0c       	add	r12,r8
800094c4:	f8 c5 fb ce 	sub	r5,r12,-1074
800094c8:	e0 45 00 20 	cp.w	r5,32
800094cc:	e0 8a 00 0e 	brle	800094e8 <_dtoa_r+0x14c>
800094d0:	f8 cc fb ee 	sub	r12,r12,-1042
800094d4:	40 3b       	lddsp	r11,sp[0xc]
800094d6:	ea 08 11 40 	rsub	r8,r5,64
800094da:	f6 0c 0a 4c 	lsr	r12,r11,r12
800094de:	ec 08 09 46 	lsl	r6,r6,r8
800094e2:	0c 4c       	or	r12,r6
800094e4:	c0 78       	rjmp	800094f2 <_dtoa_r+0x156>
800094e6:	d7 03       	nop
800094e8:	ea 0c 11 20 	rsub	r12,r5,32
800094ec:	40 3a       	lddsp	r10,sp[0xc]
800094ee:	f4 0c 09 4c 	lsl	r12,r10,r12
800094f2:	e0 a0 10 14 	rcall	8000b51a <__avr32_u32_to_f64>
800094f6:	fc 18 fe 10 	movh	r8,0xfe10
800094fa:	30 19       	mov	r9,1
800094fc:	ea c5 04 33 	sub	r5,r5,1075
80009500:	f0 0b 00 0b 	add	r11,r8,r11
80009504:	51 79       	stdsp	sp[0x5c],r9
80009506:	30 08       	mov	r8,0
80009508:	fc 19 3f f8 	movh	r9,0x3ff8
8000950c:	e0 a0 0e 9c 	rcall	8000b244 <__avr32_f64_sub>
80009510:	e0 68 43 61 	mov	r8,17249
80009514:	ea 18 63 6f 	orh	r8,0x636f
80009518:	e0 69 87 a7 	mov	r9,34727
8000951c:	ea 19 3f d2 	orh	r9,0x3fd2
80009520:	e0 a0 0d a6 	rcall	8000b06c <__avr32_f64_mul>
80009524:	e0 68 c8 b3 	mov	r8,51379
80009528:	ea 18 8b 60 	orh	r8,0x8b60
8000952c:	e0 69 8a 28 	mov	r9,35368
80009530:	ea 19 3f c6 	orh	r9,0x3fc6
80009534:	e0 a0 0f 56 	rcall	8000b3e0 <__avr32_f64_add>
80009538:	0a 9c       	mov	r12,r5
8000953a:	14 90       	mov	r0,r10
8000953c:	16 91       	mov	r1,r11
8000953e:	e0 a0 0f f2 	rcall	8000b522 <__avr32_s32_to_f64>
80009542:	e0 68 79 fb 	mov	r8,31227
80009546:	ea 18 50 9f 	orh	r8,0x509f
8000954a:	e0 69 44 13 	mov	r9,17427
8000954e:	ea 19 3f d3 	orh	r9,0x3fd3
80009552:	e0 a0 0d 8d 	rcall	8000b06c <__avr32_f64_mul>
80009556:	14 98       	mov	r8,r10
80009558:	16 99       	mov	r9,r11
8000955a:	00 9a       	mov	r10,r0
8000955c:	02 9b       	mov	r11,r1
8000955e:	e0 a0 0f 41 	rcall	8000b3e0 <__avr32_f64_add>
80009562:	14 90       	mov	r0,r10
80009564:	16 91       	mov	r1,r11
80009566:	e0 a0 0f c7 	rcall	8000b4f4 <__avr32_f64_to_s32>
8000956a:	30 08       	mov	r8,0
8000956c:	18 96       	mov	r6,r12
8000956e:	30 09       	mov	r9,0
80009570:	00 9a       	mov	r10,r0
80009572:	02 9b       	mov	r11,r1
80009574:	e0 a0 10 8e 	rcall	8000b690 <__avr32_f64_cmp_lt>
80009578:	c0 c0       	breq	80009590 <_dtoa_r+0x1f4>
8000957a:	0c 9c       	mov	r12,r6
8000957c:	e0 a0 0f d3 	rcall	8000b522 <__avr32_s32_to_f64>
80009580:	14 98       	mov	r8,r10
80009582:	16 99       	mov	r9,r11
80009584:	00 9a       	mov	r10,r0
80009586:	02 9b       	mov	r11,r1
80009588:	e0 a0 10 3d 	rcall	8000b602 <__avr32_f64_cmp_eq>
8000958c:	f7 b6 00 01 	subeq	r6,1
80009590:	59 66       	cp.w	r6,22
80009592:	e0 88 00 05 	brls	8000959c <_dtoa_r+0x200>
80009596:	30 18       	mov	r8,1
80009598:	51 48       	stdsp	sp[0x50],r8
8000959a:	c1 38       	rjmp	800095c0 <_dtoa_r+0x224>
8000959c:	fe c8 c3 68 	sub	r8,pc,-15512
800095a0:	fa ea 00 3c 	ld.d	r10,sp[60]
800095a4:	f0 06 02 38 	ld.d	r8,r8[r6<<0x3]
800095a8:	e0 a0 10 74 	rcall	8000b690 <__avr32_f64_cmp_lt>
800095ac:	f9 b4 00 00 	moveq	r4,0
800095b0:	fb f4 0a 14 	st.weq	sp[0x50],r4
800095b4:	f7 b6 01 01 	subne	r6,1
800095b8:	f9 bc 01 00 	movne	r12,0
800095bc:	fb fc 1a 14 	st.wne	sp[0x50],r12
800095c0:	41 90       	lddsp	r0,sp[0x64]
800095c2:	20 10       	sub	r0,1
800095c4:	0a 10       	sub	r0,r5
800095c6:	c0 46       	brmi	800095ce <_dtoa_r+0x232>
800095c8:	50 40       	stdsp	sp[0x10],r0
800095ca:	30 00       	mov	r0,0
800095cc:	c0 48       	rjmp	800095d4 <_dtoa_r+0x238>
800095ce:	30 0b       	mov	r11,0
800095d0:	5c 30       	neg	r0
800095d2:	50 4b       	stdsp	sp[0x10],r11
800095d4:	ec 02 11 00 	rsub	r2,r6,0
800095d8:	58 06       	cp.w	r6,0
800095da:	fb fa 40 04 	ld.wge	r10,sp[0x10]
800095de:	f5 d6 e4 0a 	addge	r10,r10,r6
800095e2:	fb fa 4a 04 	st.wge	sp[0x10],r10
800095e6:	fb f6 4a 11 	st.wge	sp[0x44],r6
800095ea:	f9 b2 04 00 	movge	r2,0
800095ee:	e1 d6 e5 10 	sublt	r0,r0,r6
800095f2:	f9 b9 05 00 	movlt	r9,0
800095f6:	fb f9 5a 11 	st.wlt	sp[0x44],r9
800095fa:	40 c8       	lddsp	r8,sp[0x30]
800095fc:	58 98       	cp.w	r8,9
800095fe:	e0 8b 00 20 	brhi	8000963e <_dtoa_r+0x2a2>
80009602:	58 58       	cp.w	r8,5
80009604:	f9 b4 0a 01 	movle	r4,1
80009608:	fb f5 90 0c 	ld.wgt	r5,sp[0x30]
8000960c:	f7 b5 09 04 	subgt	r5,4
80009610:	fb f5 9a 0c 	st.wgt	sp[0x30],r5
80009614:	f9 b4 09 00 	movgt	r4,0
80009618:	40 cc       	lddsp	r12,sp[0x30]
8000961a:	58 3c       	cp.w	r12,3
8000961c:	c2 d0       	breq	80009676 <_dtoa_r+0x2da>
8000961e:	e0 89 00 05 	brgt	80009628 <_dtoa_r+0x28c>
80009622:	58 2c       	cp.w	r12,2
80009624:	c1 01       	brne	80009644 <_dtoa_r+0x2a8>
80009626:	c1 88       	rjmp	80009656 <_dtoa_r+0x2ba>
80009628:	40 cb       	lddsp	r11,sp[0x30]
8000962a:	58 4b       	cp.w	r11,4
8000962c:	c0 60       	breq	80009638 <_dtoa_r+0x29c>
8000962e:	58 5b       	cp.w	r11,5
80009630:	c0 a1       	brne	80009644 <_dtoa_r+0x2a8>
80009632:	30 1a       	mov	r10,1
80009634:	50 da       	stdsp	sp[0x34],r10
80009636:	c2 28       	rjmp	8000967a <_dtoa_r+0x2de>
80009638:	30 19       	mov	r9,1
8000963a:	50 d9       	stdsp	sp[0x34],r9
8000963c:	c0 f8       	rjmp	8000965a <_dtoa_r+0x2be>
8000963e:	30 08       	mov	r8,0
80009640:	30 14       	mov	r4,1
80009642:	50 c8       	stdsp	sp[0x30],r8
80009644:	3f f5       	mov	r5,-1
80009646:	30 1c       	mov	r12,1
80009648:	30 0b       	mov	r11,0
8000964a:	50 95       	stdsp	sp[0x24],r5
8000964c:	50 dc       	stdsp	sp[0x34],r12
8000964e:	0a 91       	mov	r1,r5
80009650:	31 28       	mov	r8,18
80009652:	50 eb       	stdsp	sp[0x38],r11
80009654:	c2 08       	rjmp	80009694 <_dtoa_r+0x2f8>
80009656:	30 0a       	mov	r10,0
80009658:	50 da       	stdsp	sp[0x34],r10
8000965a:	40 e9       	lddsp	r9,sp[0x38]
8000965c:	58 09       	cp.w	r9,0
8000965e:	e0 89 00 07 	brgt	8000966c <_dtoa_r+0x2d0>
80009662:	30 18       	mov	r8,1
80009664:	50 98       	stdsp	sp[0x24],r8
80009666:	10 91       	mov	r1,r8
80009668:	50 e8       	stdsp	sp[0x38],r8
8000966a:	c1 58       	rjmp	80009694 <_dtoa_r+0x2f8>
8000966c:	40 e5       	lddsp	r5,sp[0x38]
8000966e:	50 95       	stdsp	sp[0x24],r5
80009670:	0a 91       	mov	r1,r5
80009672:	0a 98       	mov	r8,r5
80009674:	c1 08       	rjmp	80009694 <_dtoa_r+0x2f8>
80009676:	30 0c       	mov	r12,0
80009678:	50 dc       	stdsp	sp[0x34],r12
8000967a:	40 eb       	lddsp	r11,sp[0x38]
8000967c:	ec 0b 00 0b 	add	r11,r6,r11
80009680:	50 9b       	stdsp	sp[0x24],r11
80009682:	16 98       	mov	r8,r11
80009684:	2f f8       	sub	r8,-1
80009686:	58 08       	cp.w	r8,0
80009688:	e0 89 00 05 	brgt	80009692 <_dtoa_r+0x2f6>
8000968c:	10 91       	mov	r1,r8
8000968e:	30 18       	mov	r8,1
80009690:	c0 28       	rjmp	80009694 <_dtoa_r+0x2f8>
80009692:	10 91       	mov	r1,r8
80009694:	30 09       	mov	r9,0
80009696:	6e 9a       	ld.w	r10,r7[0x24]
80009698:	95 19       	st.w	r10[0x4],r9
8000969a:	30 49       	mov	r9,4
8000969c:	c0 68       	rjmp	800096a8 <_dtoa_r+0x30c>
8000969e:	d7 03       	nop
800096a0:	6a 1a       	ld.w	r10,r5[0x4]
800096a2:	a1 79       	lsl	r9,0x1
800096a4:	2f fa       	sub	r10,-1
800096a6:	8b 1a       	st.w	r5[0x4],r10
800096a8:	6e 95       	ld.w	r5,r7[0x24]
800096aa:	f2 ca ff ec 	sub	r10,r9,-20
800096ae:	10 3a       	cp.w	r10,r8
800096b0:	fe 98 ff f8 	brls	800096a0 <_dtoa_r+0x304>
800096b4:	6a 1b       	ld.w	r11,r5[0x4]
800096b6:	0e 9c       	mov	r12,r7
800096b8:	e0 a0 09 44 	rcall	8000a940 <_Balloc>
800096bc:	58 e1       	cp.w	r1,14
800096be:	5f 88       	srls	r8
800096c0:	8b 0c       	st.w	r5[0x0],r12
800096c2:	f1 e4 00 04 	and	r4,r8,r4
800096c6:	6e 98       	ld.w	r8,r7[0x24]
800096c8:	70 08       	ld.w	r8,r8[0x0]
800096ca:	50 88       	stdsp	sp[0x20],r8
800096cc:	e0 80 01 82 	breq	800099d0 <_dtoa_r+0x634>
800096d0:	58 06       	cp.w	r6,0
800096d2:	e0 8a 00 43 	brle	80009758 <_dtoa_r+0x3bc>
800096d6:	f3 d6 c0 04 	bfextu	r9,r6,0x0,0x4
800096da:	fe c8 c4 a6 	sub	r8,pc,-15194
800096de:	f0 09 02 34 	ld.d	r4,r8[r9<<0x3]
800096e2:	fa e5 00 18 	st.d	sp[24],r4
800096e6:	ec 04 14 04 	asr	r4,r6,0x4
800096ea:	ed b4 00 04 	bld	r4,0x4
800096ee:	c0 30       	breq	800096f4 <_dtoa_r+0x358>
800096f0:	30 25       	mov	r5,2
800096f2:	c1 08       	rjmp	80009712 <_dtoa_r+0x376>
800096f4:	fe c8 c3 f8 	sub	r8,pc,-15368
800096f8:	f0 e8 00 20 	ld.d	r8,r8[32]
800096fc:	fa ea 00 3c 	ld.d	r10,sp[60]
80009700:	e9 d4 c0 04 	bfextu	r4,r4,0x0,0x4
80009704:	e0 a0 0f fa 	rcall	8000b6f8 <__avr32_f64_div>
80009708:	30 35       	mov	r5,3
8000970a:	14 98       	mov	r8,r10
8000970c:	16 99       	mov	r9,r11
8000970e:	fa e9 00 08 	st.d	sp[8],r8
80009712:	fe cc c4 16 	sub	r12,pc,-15338
80009716:	50 a3       	stdsp	sp[0x28],r3
80009718:	0c 93       	mov	r3,r6
8000971a:	18 96       	mov	r6,r12
8000971c:	c0 f8       	rjmp	8000973a <_dtoa_r+0x39e>
8000971e:	fa ea 00 18 	ld.d	r10,sp[24]
80009722:	ed b4 00 00 	bld	r4,0x0
80009726:	c0 81       	brne	80009736 <_dtoa_r+0x39a>
80009728:	ec e8 00 00 	ld.d	r8,r6[0]
8000972c:	2f f5       	sub	r5,-1
8000972e:	e0 a0 0c 9f 	rcall	8000b06c <__avr32_f64_mul>
80009732:	fa eb 00 18 	st.d	sp[24],r10
80009736:	a1 54       	asr	r4,0x1
80009738:	2f 86       	sub	r6,-8
8000973a:	58 04       	cp.w	r4,0
8000973c:	cf 11       	brne	8000971e <_dtoa_r+0x382>
8000973e:	fa e8 00 18 	ld.d	r8,sp[24]
80009742:	fa ea 00 08 	ld.d	r10,sp[8]
80009746:	06 96       	mov	r6,r3
80009748:	e0 a0 0f d8 	rcall	8000b6f8 <__avr32_f64_div>
8000974c:	40 a3       	lddsp	r3,sp[0x28]
8000974e:	14 98       	mov	r8,r10
80009750:	16 99       	mov	r9,r11
80009752:	fa e9 00 08 	st.d	sp[8],r8
80009756:	c2 f8       	rjmp	800097b4 <_dtoa_r+0x418>
80009758:	ec 08 11 00 	rsub	r8,r6,0
8000975c:	c0 31       	brne	80009762 <_dtoa_r+0x3c6>
8000975e:	30 25       	mov	r5,2
80009760:	c2 a8       	rjmp	800097b4 <_dtoa_r+0x418>
80009762:	fe cc c4 66 	sub	r12,pc,-15258
80009766:	f0 04 14 04 	asr	r4,r8,0x4
8000976a:	50 1c       	stdsp	sp[0x4],r12
8000976c:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
80009770:	fe c9 c5 3c 	sub	r9,pc,-15044
80009774:	fa ea 00 3c 	ld.d	r10,sp[60]
80009778:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000977c:	e0 a0 0c 78 	rcall	8000b06c <__avr32_f64_mul>
80009780:	40 1c       	lddsp	r12,sp[0x4]
80009782:	50 63       	stdsp	sp[0x18],r3
80009784:	30 25       	mov	r5,2
80009786:	0c 93       	mov	r3,r6
80009788:	fa eb 00 08 	st.d	sp[8],r10
8000978c:	18 96       	mov	r6,r12
8000978e:	c0 f8       	rjmp	800097ac <_dtoa_r+0x410>
80009790:	fa ea 00 08 	ld.d	r10,sp[8]
80009794:	ed b4 00 00 	bld	r4,0x0
80009798:	c0 81       	brne	800097a8 <_dtoa_r+0x40c>
8000979a:	ec e8 00 00 	ld.d	r8,r6[0]
8000979e:	2f f5       	sub	r5,-1
800097a0:	e0 a0 0c 66 	rcall	8000b06c <__avr32_f64_mul>
800097a4:	fa eb 00 08 	st.d	sp[8],r10
800097a8:	a1 54       	asr	r4,0x1
800097aa:	2f 86       	sub	r6,-8
800097ac:	58 04       	cp.w	r4,0
800097ae:	cf 11       	brne	80009790 <_dtoa_r+0x3f4>
800097b0:	06 96       	mov	r6,r3
800097b2:	40 63       	lddsp	r3,sp[0x18]
800097b4:	41 4a       	lddsp	r10,sp[0x50]
800097b6:	58 0a       	cp.w	r10,0
800097b8:	c2 a0       	breq	8000980c <_dtoa_r+0x470>
800097ba:	fa e8 00 08 	ld.d	r8,sp[8]
800097be:	58 01       	cp.w	r1,0
800097c0:	5f 94       	srgt	r4
800097c2:	fa e9 00 18 	st.d	sp[24],r8
800097c6:	30 08       	mov	r8,0
800097c8:	fc 19 3f f0 	movh	r9,0x3ff0
800097cc:	fa ea 00 18 	ld.d	r10,sp[24]
800097d0:	e0 a0 0f 60 	rcall	8000b690 <__avr32_f64_cmp_lt>
800097d4:	f9 bc 00 00 	moveq	r12,0
800097d8:	f9 bc 01 01 	movne	r12,1
800097dc:	e9 ec 00 0c 	and	r12,r4,r12
800097e0:	c1 60       	breq	8000980c <_dtoa_r+0x470>
800097e2:	40 98       	lddsp	r8,sp[0x24]
800097e4:	58 08       	cp.w	r8,0
800097e6:	e0 8a 00 f1 	brle	800099c8 <_dtoa_r+0x62c>
800097ea:	30 08       	mov	r8,0
800097ec:	fc 19 40 24 	movh	r9,0x4024
800097f0:	ec c4 00 01 	sub	r4,r6,1
800097f4:	fa ea 00 18 	ld.d	r10,sp[24]
800097f8:	2f f5       	sub	r5,-1
800097fa:	50 64       	stdsp	sp[0x18],r4
800097fc:	e0 a0 0c 38 	rcall	8000b06c <__avr32_f64_mul>
80009800:	40 94       	lddsp	r4,sp[0x24]
80009802:	14 98       	mov	r8,r10
80009804:	16 99       	mov	r9,r11
80009806:	fa e9 00 08 	st.d	sp[8],r8
8000980a:	c0 38       	rjmp	80009810 <_dtoa_r+0x474>
8000980c:	50 66       	stdsp	sp[0x18],r6
8000980e:	02 94       	mov	r4,r1
80009810:	0a 9c       	mov	r12,r5
80009812:	e0 a0 0e 88 	rcall	8000b522 <__avr32_s32_to_f64>
80009816:	fa e8 00 08 	ld.d	r8,sp[8]
8000981a:	e0 a0 0c 29 	rcall	8000b06c <__avr32_f64_mul>
8000981e:	30 08       	mov	r8,0
80009820:	fc 19 40 1c 	movh	r9,0x401c
80009824:	e0 a0 0d de 	rcall	8000b3e0 <__avr32_f64_add>
80009828:	14 98       	mov	r8,r10
8000982a:	16 99       	mov	r9,r11
8000982c:	fa e9 00 28 	st.d	sp[40],r8
80009830:	fc 18 fc c0 	movh	r8,0xfcc0
80009834:	40 a5       	lddsp	r5,sp[0x28]
80009836:	10 05       	add	r5,r8
80009838:	50 a5       	stdsp	sp[0x28],r5
8000983a:	58 04       	cp.w	r4,0
8000983c:	c2 11       	brne	8000987e <_dtoa_r+0x4e2>
8000983e:	fa ea 00 08 	ld.d	r10,sp[8]
80009842:	30 08       	mov	r8,0
80009844:	fc 19 40 14 	movh	r9,0x4014
80009848:	e0 a0 0c fe 	rcall	8000b244 <__avr32_f64_sub>
8000984c:	40 bc       	lddsp	r12,sp[0x2c]
8000984e:	fa eb 00 08 	st.d	sp[8],r10
80009852:	14 98       	mov	r8,r10
80009854:	16 99       	mov	r9,r11
80009856:	18 9a       	mov	r10,r12
80009858:	0a 9b       	mov	r11,r5
8000985a:	e0 a0 0f 1b 	rcall	8000b690 <__avr32_f64_cmp_lt>
8000985e:	e0 81 02 54 	brne	80009d06 <_dtoa_r+0x96a>
80009862:	0a 98       	mov	r8,r5
80009864:	40 b9       	lddsp	r9,sp[0x2c]
80009866:	ee 18 80 00 	eorh	r8,0x8000
8000986a:	fa ea 00 08 	ld.d	r10,sp[8]
8000986e:	10 95       	mov	r5,r8
80009870:	12 98       	mov	r8,r9
80009872:	0a 99       	mov	r9,r5
80009874:	e0 a0 0f 0e 	rcall	8000b690 <__avr32_f64_cmp_lt>
80009878:	e0 81 02 3e 	brne	80009cf4 <_dtoa_r+0x958>
8000987c:	ca 68       	rjmp	800099c8 <_dtoa_r+0x62c>
8000987e:	fe c9 c6 4a 	sub	r9,pc,-14774
80009882:	e8 c8 00 01 	sub	r8,r4,1
80009886:	40 d5       	lddsp	r5,sp[0x34]
80009888:	58 05       	cp.w	r5,0
8000988a:	c4 f0       	breq	80009928 <_dtoa_r+0x58c>
8000988c:	30 0c       	mov	r12,0
8000988e:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
80009892:	51 3c       	stdsp	sp[0x4c],r12
80009894:	30 0a       	mov	r10,0
80009896:	fc 1b 3f e0 	movh	r11,0x3fe0
8000989a:	e0 a0 0f 2f 	rcall	8000b6f8 <__avr32_f64_div>
8000989e:	fa e8 00 28 	ld.d	r8,sp[40]
800098a2:	40 85       	lddsp	r5,sp[0x20]
800098a4:	e0 a0 0c d0 	rcall	8000b244 <__avr32_f64_sub>
800098a8:	fa eb 00 28 	st.d	sp[40],r10
800098ac:	fa ea 00 08 	ld.d	r10,sp[8]
800098b0:	e0 a0 0e 22 	rcall	8000b4f4 <__avr32_f64_to_s32>
800098b4:	51 6c       	stdsp	sp[0x58],r12
800098b6:	e0 a0 0e 36 	rcall	8000b522 <__avr32_s32_to_f64>
800098ba:	14 98       	mov	r8,r10
800098bc:	16 99       	mov	r9,r11
800098be:	fa ea 00 08 	ld.d	r10,sp[8]
800098c2:	e0 a0 0c c1 	rcall	8000b244 <__avr32_f64_sub>
800098c6:	fa eb 00 08 	st.d	sp[8],r10
800098ca:	41 68       	lddsp	r8,sp[0x58]
800098cc:	2d 08       	sub	r8,-48
800098ce:	0a c8       	st.b	r5++,r8
800098d0:	41 39       	lddsp	r9,sp[0x4c]
800098d2:	2f f9       	sub	r9,-1
800098d4:	51 39       	stdsp	sp[0x4c],r9
800098d6:	fa e8 00 28 	ld.d	r8,sp[40]
800098da:	e0 a0 0e db 	rcall	8000b690 <__avr32_f64_cmp_lt>
800098de:	e0 81 03 39 	brne	80009f50 <_dtoa_r+0xbb4>
800098e2:	fa e8 00 08 	ld.d	r8,sp[8]
800098e6:	30 0a       	mov	r10,0
800098e8:	fc 1b 3f f0 	movh	r11,0x3ff0
800098ec:	e0 a0 0c ac 	rcall	8000b244 <__avr32_f64_sub>
800098f0:	fa e8 00 28 	ld.d	r8,sp[40]
800098f4:	e0 a0 0e ce 	rcall	8000b690 <__avr32_f64_cmp_lt>
800098f8:	fa ea 00 28 	ld.d	r10,sp[40]
800098fc:	30 08       	mov	r8,0
800098fe:	fc 19 40 24 	movh	r9,0x4024
80009902:	e0 81 00 da 	brne	80009ab6 <_dtoa_r+0x71a>
80009906:	41 3c       	lddsp	r12,sp[0x4c]
80009908:	08 3c       	cp.w	r12,r4
8000990a:	c5 f4       	brge	800099c8 <_dtoa_r+0x62c>
8000990c:	e0 a0 0b b0 	rcall	8000b06c <__avr32_f64_mul>
80009910:	30 08       	mov	r8,0
80009912:	fa eb 00 28 	st.d	sp[40],r10
80009916:	fc 19 40 24 	movh	r9,0x4024
8000991a:	fa ea 00 08 	ld.d	r10,sp[8]
8000991e:	e0 a0 0b a7 	rcall	8000b06c <__avr32_f64_mul>
80009922:	fa eb 00 08 	st.d	sp[8],r10
80009926:	cc 3b       	rjmp	800098ac <_dtoa_r+0x510>
80009928:	40 85       	lddsp	r5,sp[0x20]
8000992a:	08 05       	add	r5,r4
8000992c:	f2 08 02 3a 	ld.d	r10,r9[r8<<0x3]
80009930:	51 35       	stdsp	sp[0x4c],r5
80009932:	fa e8 00 28 	ld.d	r8,sp[40]
80009936:	40 85       	lddsp	r5,sp[0x20]
80009938:	e0 a0 0b 9a 	rcall	8000b06c <__avr32_f64_mul>
8000993c:	fa eb 00 28 	st.d	sp[40],r10
80009940:	fa ea 00 08 	ld.d	r10,sp[8]
80009944:	e0 a0 0d d8 	rcall	8000b4f4 <__avr32_f64_to_s32>
80009948:	51 6c       	stdsp	sp[0x58],r12
8000994a:	e0 a0 0d ec 	rcall	8000b522 <__avr32_s32_to_f64>
8000994e:	14 98       	mov	r8,r10
80009950:	16 99       	mov	r9,r11
80009952:	fa ea 00 08 	ld.d	r10,sp[8]
80009956:	e0 a0 0c 77 	rcall	8000b244 <__avr32_f64_sub>
8000995a:	fa eb 00 08 	st.d	sp[8],r10
8000995e:	41 68       	lddsp	r8,sp[0x58]
80009960:	2d 08       	sub	r8,-48
80009962:	0a c8       	st.b	r5++,r8
80009964:	41 3c       	lddsp	r12,sp[0x4c]
80009966:	18 35       	cp.w	r5,r12
80009968:	c2 81       	brne	800099b8 <_dtoa_r+0x61c>
8000996a:	30 08       	mov	r8,0
8000996c:	fc 19 3f e0 	movh	r9,0x3fe0
80009970:	fa ea 00 28 	ld.d	r10,sp[40]
80009974:	e0 a0 0d 36 	rcall	8000b3e0 <__avr32_f64_add>
80009978:	40 85       	lddsp	r5,sp[0x20]
8000997a:	fa e8 00 08 	ld.d	r8,sp[8]
8000997e:	08 05       	add	r5,r4
80009980:	e0 a0 0e 88 	rcall	8000b690 <__avr32_f64_cmp_lt>
80009984:	e0 81 00 99 	brne	80009ab6 <_dtoa_r+0x71a>
80009988:	fa e8 00 28 	ld.d	r8,sp[40]
8000998c:	30 0a       	mov	r10,0
8000998e:	fc 1b 3f e0 	movh	r11,0x3fe0
80009992:	e0 a0 0c 59 	rcall	8000b244 <__avr32_f64_sub>
80009996:	14 98       	mov	r8,r10
80009998:	16 99       	mov	r9,r11
8000999a:	fa ea 00 08 	ld.d	r10,sp[8]
8000999e:	e0 a0 0e 79 	rcall	8000b690 <__avr32_f64_cmp_lt>
800099a2:	c1 30       	breq	800099c8 <_dtoa_r+0x62c>
800099a4:	33 09       	mov	r9,48
800099a6:	0a 98       	mov	r8,r5
800099a8:	11 7a       	ld.ub	r10,--r8
800099aa:	f2 0a 18 00 	cp.b	r10,r9
800099ae:	e0 81 02 d1 	brne	80009f50 <_dtoa_r+0xbb4>
800099b2:	10 95       	mov	r5,r8
800099b4:	cf 9b       	rjmp	800099a6 <_dtoa_r+0x60a>
800099b6:	d7 03       	nop
800099b8:	30 08       	mov	r8,0
800099ba:	fc 19 40 24 	movh	r9,0x4024
800099be:	e0 a0 0b 57 	rcall	8000b06c <__avr32_f64_mul>
800099c2:	fa eb 00 08 	st.d	sp[8],r10
800099c6:	cb db       	rjmp	80009940 <_dtoa_r+0x5a4>
800099c8:	fa ea 00 3c 	ld.d	r10,sp[60]
800099cc:	fa eb 00 08 	st.d	sp[8],r10
800099d0:	58 e6       	cp.w	r6,14
800099d2:	5f ab       	srle	r11
800099d4:	41 8a       	lddsp	r10,sp[0x60]
800099d6:	30 08       	mov	r8,0
800099d8:	f4 09 11 ff 	rsub	r9,r10,-1
800099dc:	f7 e9 03 f9 	and	r9,r11,r9>>0x1f
800099e0:	f0 09 18 00 	cp.b	r9,r8
800099e4:	e0 80 00 82 	breq	80009ae8 <_dtoa_r+0x74c>
800099e8:	40 ea       	lddsp	r10,sp[0x38]
800099ea:	58 01       	cp.w	r1,0
800099ec:	5f a9       	srle	r9
800099ee:	f3 ea 03 f9 	and	r9,r9,r10>>0x1f
800099f2:	fe ca c7 be 	sub	r10,pc,-14402
800099f6:	f4 06 02 34 	ld.d	r4,r10[r6<<0x3]
800099fa:	fa e5 00 10 	st.d	sp[16],r4
800099fe:	f0 09 18 00 	cp.b	r9,r8
80009a02:	c1 40       	breq	80009a2a <_dtoa_r+0x68e>
80009a04:	58 01       	cp.w	r1,0
80009a06:	e0 81 01 77 	brne	80009cf4 <_dtoa_r+0x958>
80009a0a:	30 08       	mov	r8,0
80009a0c:	fc 19 40 14 	movh	r9,0x4014
80009a10:	08 9a       	mov	r10,r4
80009a12:	0a 9b       	mov	r11,r5
80009a14:	e0 a0 0b 2c 	rcall	8000b06c <__avr32_f64_mul>
80009a18:	fa e8 00 08 	ld.d	r8,sp[8]
80009a1c:	e0 a0 0e 06 	rcall	8000b628 <__avr32_f64_cmp_ge>
80009a20:	e0 81 01 6a 	brne	80009cf4 <_dtoa_r+0x958>
80009a24:	02 92       	mov	r2,r1
80009a26:	e0 8f 01 72 	bral	80009d0a <_dtoa_r+0x96e>
80009a2a:	40 85       	lddsp	r5,sp[0x20]
80009a2c:	30 14       	mov	r4,1
80009a2e:	fa e8 00 10 	ld.d	r8,sp[16]
80009a32:	fa ea 00 08 	ld.d	r10,sp[8]
80009a36:	e0 a0 0e 61 	rcall	8000b6f8 <__avr32_f64_div>
80009a3a:	e0 a0 0d 5d 	rcall	8000b4f4 <__avr32_f64_to_s32>
80009a3e:	18 92       	mov	r2,r12
80009a40:	e0 a0 0d 71 	rcall	8000b522 <__avr32_s32_to_f64>
80009a44:	fa e8 00 10 	ld.d	r8,sp[16]
80009a48:	e0 a0 0b 12 	rcall	8000b06c <__avr32_f64_mul>
80009a4c:	14 98       	mov	r8,r10
80009a4e:	16 99       	mov	r9,r11
80009a50:	fa ea 00 08 	ld.d	r10,sp[8]
80009a54:	e0 a0 0b f8 	rcall	8000b244 <__avr32_f64_sub>
80009a58:	fa eb 00 08 	st.d	sp[8],r10
80009a5c:	e4 c8 ff d0 	sub	r8,r2,-48
80009a60:	0a c8       	st.b	r5++,r8
80009a62:	fc 19 40 24 	movh	r9,0x4024
80009a66:	30 08       	mov	r8,0
80009a68:	02 34       	cp.w	r4,r1
80009a6a:	c3 31       	brne	80009ad0 <_dtoa_r+0x734>
80009a6c:	fa e8 00 08 	ld.d	r8,sp[8]
80009a70:	e0 a0 0c b8 	rcall	8000b3e0 <__avr32_f64_add>
80009a74:	16 91       	mov	r1,r11
80009a76:	14 90       	mov	r0,r10
80009a78:	14 98       	mov	r8,r10
80009a7a:	02 99       	mov	r9,r1
80009a7c:	fa ea 00 10 	ld.d	r10,sp[16]
80009a80:	e0 a0 0e 08 	rcall	8000b690 <__avr32_f64_cmp_lt>
80009a84:	c1 a1       	brne	80009ab8 <_dtoa_r+0x71c>
80009a86:	fa e8 00 10 	ld.d	r8,sp[16]
80009a8a:	00 9a       	mov	r10,r0
80009a8c:	02 9b       	mov	r11,r1
80009a8e:	e0 a0 0d ba 	rcall	8000b602 <__avr32_f64_cmp_eq>
80009a92:	e0 80 02 5e 	breq	80009f4e <_dtoa_r+0xbb2>
80009a96:	e5 d2 c0 01 	bfextu	r2,r2,0x0,0x1
80009a9a:	c0 f1       	brne	80009ab8 <_dtoa_r+0x71c>
80009a9c:	e0 8f 02 59 	bral	80009f4e <_dtoa_r+0xbb2>
80009aa0:	40 8a       	lddsp	r10,sp[0x20]
80009aa2:	14 38       	cp.w	r8,r10
80009aa4:	c0 30       	breq	80009aaa <_dtoa_r+0x70e>
80009aa6:	10 95       	mov	r5,r8
80009aa8:	c0 98       	rjmp	80009aba <_dtoa_r+0x71e>
80009aaa:	33 08       	mov	r8,48
80009aac:	40 89       	lddsp	r9,sp[0x20]
80009aae:	2f f6       	sub	r6,-1
80009ab0:	b2 88       	st.b	r9[0x0],r8
80009ab2:	40 88       	lddsp	r8,sp[0x20]
80009ab4:	c0 88       	rjmp	80009ac4 <_dtoa_r+0x728>
80009ab6:	40 66       	lddsp	r6,sp[0x18]
80009ab8:	33 99       	mov	r9,57
80009aba:	0a 98       	mov	r8,r5
80009abc:	11 7a       	ld.ub	r10,--r8
80009abe:	f2 0a 18 00 	cp.b	r10,r9
80009ac2:	ce f0       	breq	80009aa0 <_dtoa_r+0x704>
80009ac4:	50 66       	stdsp	sp[0x18],r6
80009ac6:	11 89       	ld.ub	r9,r8[0x0]
80009ac8:	2f f9       	sub	r9,-1
80009aca:	b0 89       	st.b	r8[0x0],r9
80009acc:	e0 8f 02 42 	bral	80009f50 <_dtoa_r+0xbb4>
80009ad0:	e0 a0 0a ce 	rcall	8000b06c <__avr32_f64_mul>
80009ad4:	2f f4       	sub	r4,-1
80009ad6:	fa eb 00 08 	st.d	sp[8],r10
80009ada:	30 08       	mov	r8,0
80009adc:	30 09       	mov	r9,0
80009ade:	e0 a0 0d 92 	rcall	8000b602 <__avr32_f64_cmp_eq>
80009ae2:	ca 60       	breq	80009a2e <_dtoa_r+0x692>
80009ae4:	e0 8f 02 35 	bral	80009f4e <_dtoa_r+0xbb2>
80009ae8:	40 d8       	lddsp	r8,sp[0x34]
80009aea:	58 08       	cp.w	r8,0
80009aec:	c0 51       	brne	80009af6 <_dtoa_r+0x75a>
80009aee:	04 98       	mov	r8,r2
80009af0:	00 95       	mov	r5,r0
80009af2:	40 d4       	lddsp	r4,sp[0x34]
80009af4:	c3 78       	rjmp	80009b62 <_dtoa_r+0x7c6>
80009af6:	40 c5       	lddsp	r5,sp[0x30]
80009af8:	58 15       	cp.w	r5,1
80009afa:	e0 89 00 0f 	brgt	80009b18 <_dtoa_r+0x77c>
80009afe:	41 74       	lddsp	r4,sp[0x5c]
80009b00:	58 04       	cp.w	r4,0
80009b02:	c0 40       	breq	80009b0a <_dtoa_r+0x76e>
80009b04:	f4 c9 fb cd 	sub	r9,r10,-1075
80009b08:	c0 48       	rjmp	80009b10 <_dtoa_r+0x774>
80009b0a:	41 99       	lddsp	r9,sp[0x64]
80009b0c:	f2 09 11 36 	rsub	r9,r9,54
80009b10:	04 98       	mov	r8,r2
80009b12:	00 95       	mov	r5,r0
80009b14:	c1 c8       	rjmp	80009b4c <_dtoa_r+0x7b0>
80009b16:	d7 03       	nop
80009b18:	e2 c8 00 01 	sub	r8,r1,1
80009b1c:	58 01       	cp.w	r1,0
80009b1e:	e0 05 17 40 	movge	r5,r0
80009b22:	e2 09 17 40 	movge	r9,r1
80009b26:	e1 d1 e5 15 	sublt	r5,r0,r1
80009b2a:	f9 b9 05 00 	movlt	r9,0
80009b2e:	10 32       	cp.w	r2,r8
80009b30:	e5 d8 e4 18 	subge	r8,r2,r8
80009b34:	f1 d2 e5 18 	sublt	r8,r8,r2
80009b38:	e5 d8 e5 02 	addlt	r2,r2,r8
80009b3c:	fb fc 50 11 	ld.wlt	r12,sp[0x44]
80009b40:	f9 d8 e5 0c 	addlt	r12,r12,r8
80009b44:	fb fc 5a 11 	st.wlt	sp[0x44],r12
80009b48:	f9 b8 05 00 	movlt	r8,0
80009b4c:	40 4b       	lddsp	r11,sp[0x10]
80009b4e:	12 0b       	add	r11,r9
80009b50:	50 08       	stdsp	sp[0x0],r8
80009b52:	50 4b       	stdsp	sp[0x10],r11
80009b54:	12 00       	add	r0,r9
80009b56:	30 1b       	mov	r11,1
80009b58:	0e 9c       	mov	r12,r7
80009b5a:	e0 a0 08 a7 	rcall	8000aca8 <__i2b>
80009b5e:	40 08       	lddsp	r8,sp[0x0]
80009b60:	18 94       	mov	r4,r12
80009b62:	40 4a       	lddsp	r10,sp[0x10]
80009b64:	58 05       	cp.w	r5,0
80009b66:	5f 99       	srgt	r9
80009b68:	58 0a       	cp.w	r10,0
80009b6a:	5f 9a       	srgt	r10
80009b6c:	f5 e9 00 09 	and	r9,r10,r9
80009b70:	c0 80       	breq	80009b80 <_dtoa_r+0x7e4>
80009b72:	40 4c       	lddsp	r12,sp[0x10]
80009b74:	f8 05 0d 49 	min	r9,r12,r5
80009b78:	12 1c       	sub	r12,r9
80009b7a:	12 10       	sub	r0,r9
80009b7c:	50 4c       	stdsp	sp[0x10],r12
80009b7e:	12 15       	sub	r5,r9
80009b80:	58 02       	cp.w	r2,0
80009b82:	e0 8a 00 27 	brle	80009bd0 <_dtoa_r+0x834>
80009b86:	40 db       	lddsp	r11,sp[0x34]
80009b88:	58 0b       	cp.w	r11,0
80009b8a:	c1 d0       	breq	80009bc4 <_dtoa_r+0x828>
80009b8c:	58 08       	cp.w	r8,0
80009b8e:	e0 8a 00 17 	brle	80009bbc <_dtoa_r+0x820>
80009b92:	10 9a       	mov	r10,r8
80009b94:	50 08       	stdsp	sp[0x0],r8
80009b96:	08 9b       	mov	r11,r4
80009b98:	0e 9c       	mov	r12,r7
80009b9a:	e0 a0 08 cd 	rcall	8000ad34 <__pow5mult>
80009b9e:	06 9a       	mov	r10,r3
80009ba0:	18 9b       	mov	r11,r12
80009ba2:	18 94       	mov	r4,r12
80009ba4:	0e 9c       	mov	r12,r7
80009ba6:	e0 a0 08 01 	rcall	8000aba8 <__multiply>
80009baa:	18 99       	mov	r9,r12
80009bac:	06 9b       	mov	r11,r3
80009bae:	50 19       	stdsp	sp[0x4],r9
80009bb0:	0e 9c       	mov	r12,r7
80009bb2:	e0 a0 06 ad 	rcall	8000a90c <_Bfree>
80009bb6:	40 19       	lddsp	r9,sp[0x4]
80009bb8:	40 08       	lddsp	r8,sp[0x0]
80009bba:	12 93       	mov	r3,r9
80009bbc:	e4 08 01 0a 	sub	r10,r2,r8
80009bc0:	c0 80       	breq	80009bd0 <_dtoa_r+0x834>
80009bc2:	c0 28       	rjmp	80009bc6 <_dtoa_r+0x82a>
80009bc4:	04 9a       	mov	r10,r2
80009bc6:	06 9b       	mov	r11,r3
80009bc8:	0e 9c       	mov	r12,r7
80009bca:	e0 a0 08 b5 	rcall	8000ad34 <__pow5mult>
80009bce:	18 93       	mov	r3,r12
80009bd0:	30 1b       	mov	r11,1
80009bd2:	0e 9c       	mov	r12,r7
80009bd4:	e0 a0 08 6a 	rcall	8000aca8 <__i2b>
80009bd8:	41 1a       	lddsp	r10,sp[0x44]
80009bda:	18 92       	mov	r2,r12
80009bdc:	58 0a       	cp.w	r10,0
80009bde:	e0 8a 00 07 	brle	80009bec <_dtoa_r+0x850>
80009be2:	18 9b       	mov	r11,r12
80009be4:	0e 9c       	mov	r12,r7
80009be6:	e0 a0 08 a7 	rcall	8000ad34 <__pow5mult>
80009bea:	18 92       	mov	r2,r12
80009bec:	40 c9       	lddsp	r9,sp[0x30]
80009bee:	58 19       	cp.w	r9,1
80009bf0:	e0 89 00 14 	brgt	80009c18 <_dtoa_r+0x87c>
80009bf4:	40 38       	lddsp	r8,sp[0xc]
80009bf6:	58 08       	cp.w	r8,0
80009bf8:	c1 01       	brne	80009c18 <_dtoa_r+0x87c>
80009bfa:	40 29       	lddsp	r9,sp[0x8]
80009bfc:	f1 d9 c0 14 	bfextu	r8,r9,0x0,0x14
80009c00:	c0 c1       	brne	80009c18 <_dtoa_r+0x87c>
80009c02:	12 98       	mov	r8,r9
80009c04:	e6 18 7f f0 	andh	r8,0x7ff0,COH
80009c08:	c0 80       	breq	80009c18 <_dtoa_r+0x87c>
80009c0a:	40 4c       	lddsp	r12,sp[0x10]
80009c0c:	30 1b       	mov	r11,1
80009c0e:	2f fc       	sub	r12,-1
80009c10:	2f f0       	sub	r0,-1
80009c12:	50 4c       	stdsp	sp[0x10],r12
80009c14:	50 6b       	stdsp	sp[0x18],r11
80009c16:	c0 38       	rjmp	80009c1c <_dtoa_r+0x880>
80009c18:	30 0a       	mov	r10,0
80009c1a:	50 6a       	stdsp	sp[0x18],r10
80009c1c:	41 19       	lddsp	r9,sp[0x44]
80009c1e:	58 09       	cp.w	r9,0
80009c20:	c0 31       	brne	80009c26 <_dtoa_r+0x88a>
80009c22:	30 1c       	mov	r12,1
80009c24:	c0 98       	rjmp	80009c36 <_dtoa_r+0x89a>
80009c26:	64 48       	ld.w	r8,r2[0x10]
80009c28:	2f c8       	sub	r8,-4
80009c2a:	e4 08 03 2c 	ld.w	r12,r2[r8<<0x2]
80009c2e:	e0 a0 05 df 	rcall	8000a7ec <__hi0bits>
80009c32:	f8 0c 11 20 	rsub	r12,r12,32
80009c36:	40 4b       	lddsp	r11,sp[0x10]
80009c38:	f8 0b 00 08 	add	r8,r12,r11
80009c3c:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80009c40:	c0 c0       	breq	80009c58 <_dtoa_r+0x8bc>
80009c42:	f0 08 11 20 	rsub	r8,r8,32
80009c46:	58 48       	cp.w	r8,4
80009c48:	e0 8a 00 06 	brle	80009c54 <_dtoa_r+0x8b8>
80009c4c:	20 48       	sub	r8,4
80009c4e:	10 0b       	add	r11,r8
80009c50:	50 4b       	stdsp	sp[0x10],r11
80009c52:	c0 78       	rjmp	80009c60 <_dtoa_r+0x8c4>
80009c54:	58 48       	cp.w	r8,4
80009c56:	c0 70       	breq	80009c64 <_dtoa_r+0x8c8>
80009c58:	40 4a       	lddsp	r10,sp[0x10]
80009c5a:	2e 48       	sub	r8,-28
80009c5c:	10 0a       	add	r10,r8
80009c5e:	50 4a       	stdsp	sp[0x10],r10
80009c60:	10 00       	add	r0,r8
80009c62:	10 05       	add	r5,r8
80009c64:	58 00       	cp.w	r0,0
80009c66:	e0 8a 00 08 	brle	80009c76 <_dtoa_r+0x8da>
80009c6a:	06 9b       	mov	r11,r3
80009c6c:	00 9a       	mov	r10,r0
80009c6e:	0e 9c       	mov	r12,r7
80009c70:	e0 a0 07 58 	rcall	8000ab20 <__lshift>
80009c74:	18 93       	mov	r3,r12
80009c76:	40 49       	lddsp	r9,sp[0x10]
80009c78:	58 09       	cp.w	r9,0
80009c7a:	e0 8a 00 08 	brle	80009c8a <_dtoa_r+0x8ee>
80009c7e:	04 9b       	mov	r11,r2
80009c80:	12 9a       	mov	r10,r9
80009c82:	0e 9c       	mov	r12,r7
80009c84:	e0 a0 07 4e 	rcall	8000ab20 <__lshift>
80009c88:	18 92       	mov	r2,r12
80009c8a:	41 48       	lddsp	r8,sp[0x50]
80009c8c:	58 08       	cp.w	r8,0
80009c8e:	c1 b0       	breq	80009cc4 <_dtoa_r+0x928>
80009c90:	04 9b       	mov	r11,r2
80009c92:	06 9c       	mov	r12,r3
80009c94:	e0 a0 06 23 	rcall	8000a8da <__mcmp>
80009c98:	c1 64       	brge	80009cc4 <_dtoa_r+0x928>
80009c9a:	06 9b       	mov	r11,r3
80009c9c:	30 09       	mov	r9,0
80009c9e:	30 aa       	mov	r10,10
80009ca0:	0e 9c       	mov	r12,r7
80009ca2:	e0 a0 08 0b 	rcall	8000acb8 <__multadd>
80009ca6:	20 16       	sub	r6,1
80009ca8:	18 93       	mov	r3,r12
80009caa:	40 dc       	lddsp	r12,sp[0x34]
80009cac:	58 0c       	cp.w	r12,0
80009cae:	c0 31       	brne	80009cb4 <_dtoa_r+0x918>
80009cb0:	40 91       	lddsp	r1,sp[0x24]
80009cb2:	c0 98       	rjmp	80009cc4 <_dtoa_r+0x928>
80009cb4:	08 9b       	mov	r11,r4
80009cb6:	40 91       	lddsp	r1,sp[0x24]
80009cb8:	30 09       	mov	r9,0
80009cba:	30 aa       	mov	r10,10
80009cbc:	0e 9c       	mov	r12,r7
80009cbe:	e0 a0 07 fd 	rcall	8000acb8 <__multadd>
80009cc2:	18 94       	mov	r4,r12
80009cc4:	58 01       	cp.w	r1,0
80009cc6:	5f a9       	srle	r9
80009cc8:	40 cb       	lddsp	r11,sp[0x30]
80009cca:	58 2b       	cp.w	r11,2
80009ccc:	5f 98       	srgt	r8
80009cce:	f3 e8 00 08 	and	r8,r9,r8
80009cd2:	c2 50       	breq	80009d1c <_dtoa_r+0x980>
80009cd4:	58 01       	cp.w	r1,0
80009cd6:	c1 11       	brne	80009cf8 <_dtoa_r+0x95c>
80009cd8:	04 9b       	mov	r11,r2
80009cda:	02 99       	mov	r9,r1
80009cdc:	30 5a       	mov	r10,5
80009cde:	0e 9c       	mov	r12,r7
80009ce0:	e0 a0 07 ec 	rcall	8000acb8 <__multadd>
80009ce4:	18 92       	mov	r2,r12
80009ce6:	18 9b       	mov	r11,r12
80009ce8:	06 9c       	mov	r12,r3
80009cea:	e0 a0 05 f8 	rcall	8000a8da <__mcmp>
80009cee:	e0 89 00 0f 	brgt	80009d0c <_dtoa_r+0x970>
80009cf2:	c0 38       	rjmp	80009cf8 <_dtoa_r+0x95c>
80009cf4:	30 02       	mov	r2,0
80009cf6:	04 94       	mov	r4,r2
80009cf8:	40 ea       	lddsp	r10,sp[0x38]
80009cfa:	30 09       	mov	r9,0
80009cfc:	5c da       	com	r10
80009cfe:	40 85       	lddsp	r5,sp[0x20]
80009d00:	50 6a       	stdsp	sp[0x18],r10
80009d02:	50 49       	stdsp	sp[0x10],r9
80009d04:	c0 f9       	rjmp	80009f22 <_dtoa_r+0xb86>
80009d06:	08 92       	mov	r2,r4
80009d08:	40 66       	lddsp	r6,sp[0x18]
80009d0a:	04 94       	mov	r4,r2
80009d0c:	2f f6       	sub	r6,-1
80009d0e:	50 66       	stdsp	sp[0x18],r6
80009d10:	33 18       	mov	r8,49
80009d12:	40 85       	lddsp	r5,sp[0x20]
80009d14:	0a c8       	st.b	r5++,r8
80009d16:	30 08       	mov	r8,0
80009d18:	50 48       	stdsp	sp[0x10],r8
80009d1a:	c0 49       	rjmp	80009f22 <_dtoa_r+0xb86>
80009d1c:	40 dc       	lddsp	r12,sp[0x34]
80009d1e:	58 0c       	cp.w	r12,0
80009d20:	e0 80 00 b5 	breq	80009e8a <_dtoa_r+0xaee>
80009d24:	58 05       	cp.w	r5,0
80009d26:	e0 8a 00 08 	brle	80009d36 <_dtoa_r+0x99a>
80009d2a:	08 9b       	mov	r11,r4
80009d2c:	0a 9a       	mov	r10,r5
80009d2e:	0e 9c       	mov	r12,r7
80009d30:	e0 a0 06 f8 	rcall	8000ab20 <__lshift>
80009d34:	18 94       	mov	r4,r12
80009d36:	40 6b       	lddsp	r11,sp[0x18]
80009d38:	58 0b       	cp.w	r11,0
80009d3a:	c0 31       	brne	80009d40 <_dtoa_r+0x9a4>
80009d3c:	08 9c       	mov	r12,r4
80009d3e:	c1 38       	rjmp	80009d64 <_dtoa_r+0x9c8>
80009d40:	68 1b       	ld.w	r11,r4[0x4]
80009d42:	0e 9c       	mov	r12,r7
80009d44:	e0 a0 05 fe 	rcall	8000a940 <_Balloc>
80009d48:	68 4a       	ld.w	r10,r4[0x10]
80009d4a:	18 95       	mov	r5,r12
80009d4c:	e8 cb ff f4 	sub	r11,r4,-12
80009d50:	2f ea       	sub	r10,-2
80009d52:	2f 4c       	sub	r12,-12
80009d54:	a3 6a       	lsl	r10,0x2
80009d56:	fe b0 e6 4f 	rcall	800069f4 <memcpy>
80009d5a:	0a 9b       	mov	r11,r5
80009d5c:	30 1a       	mov	r10,1
80009d5e:	0e 9c       	mov	r12,r7
80009d60:	e0 a0 06 e0 	rcall	8000ab20 <__lshift>
80009d64:	50 44       	stdsp	sp[0x10],r4
80009d66:	40 3a       	lddsp	r10,sp[0xc]
80009d68:	30 19       	mov	r9,1
80009d6a:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
80009d6e:	18 94       	mov	r4,r12
80009d70:	50 da       	stdsp	sp[0x34],r10
80009d72:	40 85       	lddsp	r5,sp[0x20]
80009d74:	50 99       	stdsp	sp[0x24],r9
80009d76:	50 26       	stdsp	sp[0x8],r6
80009d78:	50 e1       	stdsp	sp[0x38],r1
80009d7a:	04 9b       	mov	r11,r2
80009d7c:	06 9c       	mov	r12,r3
80009d7e:	fe b0 fa 7f 	rcall	8000927c <quorem>
80009d82:	40 4b       	lddsp	r11,sp[0x10]
80009d84:	f8 c0 ff d0 	sub	r0,r12,-48
80009d88:	06 9c       	mov	r12,r3
80009d8a:	e0 a0 05 a8 	rcall	8000a8da <__mcmp>
80009d8e:	08 9a       	mov	r10,r4
80009d90:	50 6c       	stdsp	sp[0x18],r12
80009d92:	04 9b       	mov	r11,r2
80009d94:	0e 9c       	mov	r12,r7
80009d96:	e0 a0 06 5d 	rcall	8000aa50 <__mdiff>
80009d9a:	18 91       	mov	r1,r12
80009d9c:	78 38       	ld.w	r8,r12[0xc]
80009d9e:	58 08       	cp.w	r8,0
80009da0:	c0 30       	breq	80009da6 <_dtoa_r+0xa0a>
80009da2:	30 16       	mov	r6,1
80009da4:	c0 68       	rjmp	80009db0 <_dtoa_r+0xa14>
80009da6:	18 9b       	mov	r11,r12
80009da8:	06 9c       	mov	r12,r3
80009daa:	e0 a0 05 98 	rcall	8000a8da <__mcmp>
80009dae:	18 96       	mov	r6,r12
80009db0:	0e 9c       	mov	r12,r7
80009db2:	02 9b       	mov	r11,r1
80009db4:	e0 a0 05 ac 	rcall	8000a90c <_Bfree>
80009db8:	40 cc       	lddsp	r12,sp[0x30]
80009dba:	ed ec 10 08 	or	r8,r6,r12
80009dbe:	c0 d1       	brne	80009dd8 <_dtoa_r+0xa3c>
80009dc0:	40 db       	lddsp	r11,sp[0x34]
80009dc2:	58 0b       	cp.w	r11,0
80009dc4:	c0 a1       	brne	80009dd8 <_dtoa_r+0xa3c>
80009dc6:	40 26       	lddsp	r6,sp[0x8]
80009dc8:	e0 40 00 39 	cp.w	r0,57
80009dcc:	c3 00       	breq	80009e2c <_dtoa_r+0xa90>
80009dce:	40 6a       	lddsp	r10,sp[0x18]
80009dd0:	58 0a       	cp.w	r10,0
80009dd2:	e0 89 00 24 	brgt	80009e1a <_dtoa_r+0xa7e>
80009dd6:	c2 f8       	rjmp	80009e34 <_dtoa_r+0xa98>
80009dd8:	40 69       	lddsp	r9,sp[0x18]
80009dda:	58 09       	cp.w	r9,0
80009ddc:	c0 85       	brlt	80009dec <_dtoa_r+0xa50>
80009dde:	12 98       	mov	r8,r9
80009de0:	40 cc       	lddsp	r12,sp[0x30]
80009de2:	18 48       	or	r8,r12
80009de4:	c1 d1       	brne	80009e1e <_dtoa_r+0xa82>
80009de6:	40 db       	lddsp	r11,sp[0x34]
80009de8:	58 0b       	cp.w	r11,0
80009dea:	c1 a1       	brne	80009e1e <_dtoa_r+0xa82>
80009dec:	0c 99       	mov	r9,r6
80009dee:	40 26       	lddsp	r6,sp[0x8]
80009df0:	58 09       	cp.w	r9,0
80009df2:	e0 8a 00 21 	brle	80009e34 <_dtoa_r+0xa98>
80009df6:	06 9b       	mov	r11,r3
80009df8:	30 1a       	mov	r10,1
80009dfa:	0e 9c       	mov	r12,r7
80009dfc:	e0 a0 06 92 	rcall	8000ab20 <__lshift>
80009e00:	04 9b       	mov	r11,r2
80009e02:	18 93       	mov	r3,r12
80009e04:	e0 a0 05 6b 	rcall	8000a8da <__mcmp>
80009e08:	e0 89 00 06 	brgt	80009e14 <_dtoa_r+0xa78>
80009e0c:	c1 41       	brne	80009e34 <_dtoa_r+0xa98>
80009e0e:	ed b0 00 00 	bld	r0,0x0
80009e12:	c1 11       	brne	80009e34 <_dtoa_r+0xa98>
80009e14:	e0 40 00 39 	cp.w	r0,57
80009e18:	c0 a0       	breq	80009e2c <_dtoa_r+0xa90>
80009e1a:	2f f0       	sub	r0,-1
80009e1c:	c0 c8       	rjmp	80009e34 <_dtoa_r+0xa98>
80009e1e:	58 06       	cp.w	r6,0
80009e20:	e0 8a 00 0c 	brle	80009e38 <_dtoa_r+0xa9c>
80009e24:	40 26       	lddsp	r6,sp[0x8]
80009e26:	e0 40 00 39 	cp.w	r0,57
80009e2a:	c0 41       	brne	80009e32 <_dtoa_r+0xa96>
80009e2c:	33 98       	mov	r8,57
80009e2e:	0a c8       	st.b	r5++,r8
80009e30:	c6 78       	rjmp	80009efe <_dtoa_r+0xb62>
80009e32:	2f f0       	sub	r0,-1
80009e34:	0a c0       	st.b	r5++,r0
80009e36:	c7 58       	rjmp	80009f20 <_dtoa_r+0xb84>
80009e38:	0a c0       	st.b	r5++,r0
80009e3a:	40 9a       	lddsp	r10,sp[0x24]
80009e3c:	40 e9       	lddsp	r9,sp[0x38]
80009e3e:	12 3a       	cp.w	r10,r9
80009e40:	c4 30       	breq	80009ec6 <_dtoa_r+0xb2a>
80009e42:	06 9b       	mov	r11,r3
80009e44:	30 09       	mov	r9,0
80009e46:	30 aa       	mov	r10,10
80009e48:	0e 9c       	mov	r12,r7
80009e4a:	e0 a0 07 37 	rcall	8000acb8 <__multadd>
80009e4e:	40 48       	lddsp	r8,sp[0x10]
80009e50:	18 93       	mov	r3,r12
80009e52:	08 38       	cp.w	r8,r4
80009e54:	c0 91       	brne	80009e66 <_dtoa_r+0xaca>
80009e56:	10 9b       	mov	r11,r8
80009e58:	30 09       	mov	r9,0
80009e5a:	30 aa       	mov	r10,10
80009e5c:	0e 9c       	mov	r12,r7
80009e5e:	e0 a0 07 2d 	rcall	8000acb8 <__multadd>
80009e62:	50 4c       	stdsp	sp[0x10],r12
80009e64:	c0 e8       	rjmp	80009e80 <_dtoa_r+0xae4>
80009e66:	40 4b       	lddsp	r11,sp[0x10]
80009e68:	30 09       	mov	r9,0
80009e6a:	30 aa       	mov	r10,10
80009e6c:	0e 9c       	mov	r12,r7
80009e6e:	e0 a0 07 25 	rcall	8000acb8 <__multadd>
80009e72:	08 9b       	mov	r11,r4
80009e74:	50 4c       	stdsp	sp[0x10],r12
80009e76:	30 09       	mov	r9,0
80009e78:	30 aa       	mov	r10,10
80009e7a:	0e 9c       	mov	r12,r7
80009e7c:	e0 a0 07 1e 	rcall	8000acb8 <__multadd>
80009e80:	18 94       	mov	r4,r12
80009e82:	40 9c       	lddsp	r12,sp[0x24]
80009e84:	2f fc       	sub	r12,-1
80009e86:	50 9c       	stdsp	sp[0x24],r12
80009e88:	c7 9b       	rjmp	80009d7a <_dtoa_r+0x9de>
80009e8a:	30 18       	mov	r8,1
80009e8c:	06 90       	mov	r0,r3
80009e8e:	40 85       	lddsp	r5,sp[0x20]
80009e90:	08 93       	mov	r3,r4
80009e92:	0c 94       	mov	r4,r6
80009e94:	10 96       	mov	r6,r8
80009e96:	04 9b       	mov	r11,r2
80009e98:	00 9c       	mov	r12,r0
80009e9a:	fe b0 f9 f1 	rcall	8000927c <quorem>
80009e9e:	2d 0c       	sub	r12,-48
80009ea0:	0a cc       	st.b	r5++,r12
80009ea2:	02 36       	cp.w	r6,r1
80009ea4:	c0 a4       	brge	80009eb8 <_dtoa_r+0xb1c>
80009ea6:	00 9b       	mov	r11,r0
80009ea8:	30 09       	mov	r9,0
80009eaa:	30 aa       	mov	r10,10
80009eac:	0e 9c       	mov	r12,r7
80009eae:	2f f6       	sub	r6,-1
80009eb0:	e0 a0 07 04 	rcall	8000acb8 <__multadd>
80009eb4:	18 90       	mov	r0,r12
80009eb6:	cf 0b       	rjmp	80009e96 <_dtoa_r+0xafa>
80009eb8:	08 96       	mov	r6,r4
80009eba:	30 0b       	mov	r11,0
80009ebc:	06 94       	mov	r4,r3
80009ebe:	50 4b       	stdsp	sp[0x10],r11
80009ec0:	00 93       	mov	r3,r0
80009ec2:	18 90       	mov	r0,r12
80009ec4:	c0 28       	rjmp	80009ec8 <_dtoa_r+0xb2c>
80009ec6:	40 26       	lddsp	r6,sp[0x8]
80009ec8:	06 9b       	mov	r11,r3
80009eca:	30 1a       	mov	r10,1
80009ecc:	0e 9c       	mov	r12,r7
80009ece:	e0 a0 06 29 	rcall	8000ab20 <__lshift>
80009ed2:	04 9b       	mov	r11,r2
80009ed4:	18 93       	mov	r3,r12
80009ed6:	e0 a0 05 02 	rcall	8000a8da <__mcmp>
80009eda:	e0 89 00 12 	brgt	80009efe <_dtoa_r+0xb62>
80009ede:	c1 b1       	brne	80009f14 <_dtoa_r+0xb78>
80009ee0:	e1 d0 c0 01 	bfextu	r0,r0,0x0,0x1
80009ee4:	c0 d1       	brne	80009efe <_dtoa_r+0xb62>
80009ee6:	c1 78       	rjmp	80009f14 <_dtoa_r+0xb78>
80009ee8:	40 89       	lddsp	r9,sp[0x20]
80009eea:	12 38       	cp.w	r8,r9
80009eec:	c0 30       	breq	80009ef2 <_dtoa_r+0xb56>
80009eee:	10 95       	mov	r5,r8
80009ef0:	c0 88       	rjmp	80009f00 <_dtoa_r+0xb64>
80009ef2:	2f f6       	sub	r6,-1
80009ef4:	50 66       	stdsp	sp[0x18],r6
80009ef6:	33 18       	mov	r8,49
80009ef8:	40 8c       	lddsp	r12,sp[0x20]
80009efa:	b8 88       	st.b	r12[0x0],r8
80009efc:	c1 38       	rjmp	80009f22 <_dtoa_r+0xb86>
80009efe:	33 9a       	mov	r10,57
80009f00:	0a 98       	mov	r8,r5
80009f02:	11 79       	ld.ub	r9,--r8
80009f04:	f4 09 18 00 	cp.b	r9,r10
80009f08:	cf 00       	breq	80009ee8 <_dtoa_r+0xb4c>
80009f0a:	2f f9       	sub	r9,-1
80009f0c:	b0 89       	st.b	r8[0x0],r9
80009f0e:	c0 98       	rjmp	80009f20 <_dtoa_r+0xb84>
80009f10:	10 95       	mov	r5,r8
80009f12:	c0 28       	rjmp	80009f16 <_dtoa_r+0xb7a>
80009f14:	33 09       	mov	r9,48
80009f16:	0a 98       	mov	r8,r5
80009f18:	11 7a       	ld.ub	r10,--r8
80009f1a:	f2 0a 18 00 	cp.b	r10,r9
80009f1e:	cf 90       	breq	80009f10 <_dtoa_r+0xb74>
80009f20:	50 66       	stdsp	sp[0x18],r6
80009f22:	04 9b       	mov	r11,r2
80009f24:	0e 9c       	mov	r12,r7
80009f26:	e0 a0 04 f3 	rcall	8000a90c <_Bfree>
80009f2a:	58 04       	cp.w	r4,0
80009f2c:	c1 20       	breq	80009f50 <_dtoa_r+0xbb4>
80009f2e:	40 4b       	lddsp	r11,sp[0x10]
80009f30:	08 3b       	cp.w	r11,r4
80009f32:	5f 19       	srne	r9
80009f34:	58 0b       	cp.w	r11,0
80009f36:	5f 18       	srne	r8
80009f38:	f3 e8 00 08 	and	r8,r9,r8
80009f3c:	c0 40       	breq	80009f44 <_dtoa_r+0xba8>
80009f3e:	0e 9c       	mov	r12,r7
80009f40:	e0 a0 04 e6 	rcall	8000a90c <_Bfree>
80009f44:	08 9b       	mov	r11,r4
80009f46:	0e 9c       	mov	r12,r7
80009f48:	e0 a0 04 e2 	rcall	8000a90c <_Bfree>
80009f4c:	c0 28       	rjmp	80009f50 <_dtoa_r+0xbb4>
80009f4e:	50 66       	stdsp	sp[0x18],r6
80009f50:	0e 9c       	mov	r12,r7
80009f52:	06 9b       	mov	r11,r3
80009f54:	e0 a0 04 dc 	rcall	8000a90c <_Bfree>
80009f58:	30 08       	mov	r8,0
80009f5a:	aa 88       	st.b	r5[0x0],r8
80009f5c:	40 68       	lddsp	r8,sp[0x18]
80009f5e:	41 5a       	lddsp	r10,sp[0x54]
80009f60:	2f f8       	sub	r8,-1
80009f62:	41 29       	lddsp	r9,sp[0x48]
80009f64:	95 08       	st.w	r10[0x0],r8
80009f66:	40 8c       	lddsp	r12,sp[0x20]
80009f68:	58 09       	cp.w	r9,0
80009f6a:	fb f8 10 12 	ld.wne	r8,sp[0x48]
80009f6e:	f1 f5 1a 00 	st.wne	r8[0x0],r5
80009f72:	2e 6d       	sub	sp,-104
80009f74:	d8 32       	popm	r0-r7,pc
80009f76:	d7 03       	nop

80009f78 <__errno>:
80009f78:	e0 68 0a 40 	mov	r8,2624
80009f7c:	70 0c       	ld.w	r12,r8[0x0]
80009f7e:	2f 4c       	sub	r12,-12
80009f80:	5e fc       	retal	r12
80009f82:	d7 03       	nop

80009f84 <_fflush_r>:
80009f84:	d4 21       	pushm	r4-r7,lr
80009f86:	16 97       	mov	r7,r11
80009f88:	18 96       	mov	r6,r12
80009f8a:	76 48       	ld.w	r8,r11[0x10]
80009f8c:	58 08       	cp.w	r8,0
80009f8e:	c7 f0       	breq	8000a08c <_fflush_r+0x108>
80009f90:	58 0c       	cp.w	r12,0
80009f92:	c0 50       	breq	80009f9c <_fflush_r+0x18>
80009f94:	78 68       	ld.w	r8,r12[0x18]
80009f96:	58 08       	cp.w	r8,0
80009f98:	c0 21       	brne	80009f9c <_fflush_r+0x18>
80009f9a:	cc dc       	rcall	8000a134 <__sinit>
80009f9c:	fe c8 ce 18 	sub	r8,pc,-12776
80009fa0:	10 37       	cp.w	r7,r8
80009fa2:	c0 31       	brne	80009fa8 <_fflush_r+0x24>
80009fa4:	6c 07       	ld.w	r7,r6[0x0]
80009fa6:	c0 c8       	rjmp	80009fbe <_fflush_r+0x3a>
80009fa8:	fe c8 ce 04 	sub	r8,pc,-12796
80009fac:	10 37       	cp.w	r7,r8
80009fae:	c0 31       	brne	80009fb4 <_fflush_r+0x30>
80009fb0:	6c 17       	ld.w	r7,r6[0x4]
80009fb2:	c0 68       	rjmp	80009fbe <_fflush_r+0x3a>
80009fb4:	fe c8 cd f0 	sub	r8,pc,-12816
80009fb8:	10 37       	cp.w	r7,r8
80009fba:	ed f7 00 02 	ld.weq	r7,r6[0x8]
80009fbe:	8e 6a       	ld.sh	r10,r7[0xc]
80009fc0:	14 98       	mov	r8,r10
80009fc2:	ed ba 00 03 	bld	r10,0x3
80009fc6:	c4 20       	breq	8000a04a <_fflush_r+0xc6>
80009fc8:	ab ba       	sbr	r10,0xb
80009fca:	ae 6a       	st.h	r7[0xc],r10
80009fcc:	6e 18       	ld.w	r8,r7[0x4]
80009fce:	58 08       	cp.w	r8,0
80009fd0:	e0 89 00 06 	brgt	80009fdc <_fflush_r+0x58>
80009fd4:	6f 08       	ld.w	r8,r7[0x40]
80009fd6:	58 08       	cp.w	r8,0
80009fd8:	e0 8a 00 5a 	brle	8000a08c <_fflush_r+0x108>
80009fdc:	6e b8       	ld.w	r8,r7[0x2c]
80009fde:	58 08       	cp.w	r8,0
80009fe0:	c5 60       	breq	8000a08c <_fflush_r+0x108>
80009fe2:	e2 1a 10 00 	andl	r10,0x1000,COH
80009fe6:	c0 30       	breq	80009fec <_fflush_r+0x68>
80009fe8:	6f 55       	ld.w	r5,r7[0x54]
80009fea:	c0 f8       	rjmp	8000a008 <_fflush_r+0x84>
80009fec:	30 19       	mov	r9,1
80009fee:	6e 8b       	ld.w	r11,r7[0x20]
80009ff0:	0c 9c       	mov	r12,r6
80009ff2:	5d 18       	icall	r8
80009ff4:	18 95       	mov	r5,r12
80009ff6:	5b fc       	cp.w	r12,-1
80009ff8:	c0 81       	brne	8000a008 <_fflush_r+0x84>
80009ffa:	6c 38       	ld.w	r8,r6[0xc]
80009ffc:	59 d8       	cp.w	r8,29
80009ffe:	c4 70       	breq	8000a08c <_fflush_r+0x108>
8000a000:	8e 68       	ld.sh	r8,r7[0xc]
8000a002:	a7 a8       	sbr	r8,0x6
8000a004:	ae 68       	st.h	r7[0xc],r8
8000a006:	d8 22       	popm	r4-r7,pc
8000a008:	8e 68       	ld.sh	r8,r7[0xc]
8000a00a:	ed b8 00 02 	bld	r8,0x2
8000a00e:	c0 91       	brne	8000a020 <_fflush_r+0x9c>
8000a010:	6e 18       	ld.w	r8,r7[0x4]
8000a012:	10 15       	sub	r5,r8
8000a014:	6e d8       	ld.w	r8,r7[0x34]
8000a016:	58 08       	cp.w	r8,0
8000a018:	ef f8 10 10 	ld.wne	r8,r7[0x40]
8000a01c:	eb d8 e1 15 	subne	r5,r5,r8
8000a020:	6e b8       	ld.w	r8,r7[0x2c]
8000a022:	0c 9c       	mov	r12,r6
8000a024:	30 09       	mov	r9,0
8000a026:	0a 9a       	mov	r10,r5
8000a028:	6e 8b       	ld.w	r11,r7[0x20]
8000a02a:	5d 18       	icall	r8
8000a02c:	8e 68       	ld.sh	r8,r7[0xc]
8000a02e:	0a 3c       	cp.w	r12,r5
8000a030:	c2 61       	brne	8000a07c <_fflush_r+0xf8>
8000a032:	ab d8       	cbr	r8,0xb
8000a034:	30 0c       	mov	r12,0
8000a036:	6e 49       	ld.w	r9,r7[0x10]
8000a038:	ae 68       	st.h	r7[0xc],r8
8000a03a:	8f 1c       	st.w	r7[0x4],r12
8000a03c:	8f 09       	st.w	r7[0x0],r9
8000a03e:	ed b8 00 0c 	bld	r8,0xc
8000a042:	c2 51       	brne	8000a08c <_fflush_r+0x108>
8000a044:	ef 45 00 54 	st.w	r7[84],r5
8000a048:	d8 22       	popm	r4-r7,pc
8000a04a:	6e 45       	ld.w	r5,r7[0x10]
8000a04c:	58 05       	cp.w	r5,0
8000a04e:	c1 f0       	breq	8000a08c <_fflush_r+0x108>
8000a050:	6e 04       	ld.w	r4,r7[0x0]
8000a052:	f5 da c0 02 	bfextu	r10,r10,0x0,0x2
8000a056:	8f 05       	st.w	r7[0x0],r5
8000a058:	f9 b8 01 00 	movne	r8,0
8000a05c:	ef f8 00 05 	ld.weq	r8,r7[0x14]
8000a060:	0a 14       	sub	r4,r5
8000a062:	8f 28       	st.w	r7[0x8],r8
8000a064:	c1 18       	rjmp	8000a086 <_fflush_r+0x102>
8000a066:	08 99       	mov	r9,r4
8000a068:	0a 9a       	mov	r10,r5
8000a06a:	6e a8       	ld.w	r8,r7[0x28]
8000a06c:	6e 8b       	ld.w	r11,r7[0x20]
8000a06e:	0c 9c       	mov	r12,r6
8000a070:	5d 18       	icall	r8
8000a072:	18 14       	sub	r4,r12
8000a074:	58 0c       	cp.w	r12,0
8000a076:	e0 89 00 07 	brgt	8000a084 <_fflush_r+0x100>
8000a07a:	8e 68       	ld.sh	r8,r7[0xc]
8000a07c:	a7 a8       	sbr	r8,0x6
8000a07e:	3f fc       	mov	r12,-1
8000a080:	ae 68       	st.h	r7[0xc],r8
8000a082:	d8 22       	popm	r4-r7,pc
8000a084:	18 05       	add	r5,r12
8000a086:	58 04       	cp.w	r4,0
8000a088:	fe 99 ff ef 	brgt	8000a066 <_fflush_r+0xe2>
8000a08c:	d8 2a       	popm	r4-r7,pc,r12=0
8000a08e:	d7 03       	nop

8000a090 <__sfp_lock_acquire>:
8000a090:	5e fc       	retal	r12

8000a092 <__sfp_lock_release>:
8000a092:	5e fc       	retal	r12

8000a094 <_cleanup_r>:
8000a094:	d4 01       	pushm	lr
8000a096:	fe cb f0 ae 	sub	r11,pc,-3922
8000a09a:	e0 a0 02 f7 	rcall	8000a688 <_fwalk>
8000a09e:	d8 02       	popm	pc

8000a0a0 <__sfmoreglue>:
8000a0a0:	d4 21       	pushm	r4-r7,lr
8000a0a2:	16 95       	mov	r5,r11
8000a0a4:	f6 06 10 5c 	mul	r6,r11,92
8000a0a8:	ec cb ff f4 	sub	r11,r6,-12
8000a0ac:	fe b0 e2 88 	rcall	800065bc <_malloc_r>
8000a0b0:	18 97       	mov	r7,r12
8000a0b2:	c0 90       	breq	8000a0c4 <__sfmoreglue+0x24>
8000a0b4:	99 15       	st.w	r12[0x4],r5
8000a0b6:	30 0b       	mov	r11,0
8000a0b8:	2f 4c       	sub	r12,-12
8000a0ba:	0c 9a       	mov	r10,r6
8000a0bc:	8f 2c       	st.w	r7[0x8],r12
8000a0be:	8f 0b       	st.w	r7[0x0],r11
8000a0c0:	fe b0 e5 3e 	rcall	80006b3c <memset>
8000a0c4:	0e 9c       	mov	r12,r7
8000a0c6:	d8 22       	popm	r4-r7,pc

8000a0c8 <__sfp>:
8000a0c8:	d4 21       	pushm	r4-r7,lr
8000a0ca:	fe c8 ce e2 	sub	r8,pc,-12574
8000a0ce:	18 96       	mov	r6,r12
8000a0d0:	70 07       	ld.w	r7,r8[0x0]
8000a0d2:	6e 68       	ld.w	r8,r7[0x18]
8000a0d4:	58 08       	cp.w	r8,0
8000a0d6:	c0 31       	brne	8000a0dc <__sfp+0x14>
8000a0d8:	0e 9c       	mov	r12,r7
8000a0da:	c2 dc       	rcall	8000a134 <__sinit>
8000a0dc:	ee c7 ff 28 	sub	r7,r7,-216
8000a0e0:	30 05       	mov	r5,0
8000a0e2:	6e 2c       	ld.w	r12,r7[0x8]
8000a0e4:	6e 18       	ld.w	r8,r7[0x4]
8000a0e6:	c0 68       	rjmp	8000a0f2 <__sfp+0x2a>
8000a0e8:	98 69       	ld.sh	r9,r12[0xc]
8000a0ea:	ea 09 19 00 	cp.h	r9,r5
8000a0ee:	c1 10       	breq	8000a110 <__sfp+0x48>
8000a0f0:	2a 4c       	sub	r12,-92
8000a0f2:	20 18       	sub	r8,1
8000a0f4:	cf a7       	brpl	8000a0e8 <__sfp+0x20>
8000a0f6:	6e 08       	ld.w	r8,r7[0x0]
8000a0f8:	58 08       	cp.w	r8,0
8000a0fa:	c0 61       	brne	8000a106 <__sfp+0x3e>
8000a0fc:	30 4b       	mov	r11,4
8000a0fe:	0c 9c       	mov	r12,r6
8000a100:	cd 0f       	rcall	8000a0a0 <__sfmoreglue>
8000a102:	8f 0c       	st.w	r7[0x0],r12
8000a104:	c0 30       	breq	8000a10a <__sfp+0x42>
8000a106:	6e 07       	ld.w	r7,r7[0x0]
8000a108:	ce db       	rjmp	8000a0e2 <__sfp+0x1a>
8000a10a:	30 c8       	mov	r8,12
8000a10c:	8d 38       	st.w	r6[0xc],r8
8000a10e:	d8 22       	popm	r4-r7,pc
8000a110:	30 08       	mov	r8,0
8000a112:	f9 48 00 4c 	st.w	r12[76],r8
8000a116:	99 08       	st.w	r12[0x0],r8
8000a118:	99 28       	st.w	r12[0x8],r8
8000a11a:	99 18       	st.w	r12[0x4],r8
8000a11c:	99 48       	st.w	r12[0x10],r8
8000a11e:	99 58       	st.w	r12[0x14],r8
8000a120:	99 68       	st.w	r12[0x18],r8
8000a122:	99 d8       	st.w	r12[0x34],r8
8000a124:	99 e8       	st.w	r12[0x38],r8
8000a126:	f9 48 00 48 	st.w	r12[72],r8
8000a12a:	3f f8       	mov	r8,-1
8000a12c:	b8 78       	st.h	r12[0xe],r8
8000a12e:	30 18       	mov	r8,1
8000a130:	b8 68       	st.h	r12[0xc],r8
8000a132:	d8 22       	popm	r4-r7,pc

8000a134 <__sinit>:
8000a134:	d4 21       	pushm	r4-r7,lr
8000a136:	18 96       	mov	r6,r12
8000a138:	78 67       	ld.w	r7,r12[0x18]
8000a13a:	58 07       	cp.w	r7,0
8000a13c:	c4 91       	brne	8000a1ce <__sinit+0x9a>
8000a13e:	fe c8 00 aa 	sub	r8,pc,170
8000a142:	30 15       	mov	r5,1
8000a144:	99 a8       	st.w	r12[0x28],r8
8000a146:	f9 47 00 d8 	st.w	r12[216],r7
8000a14a:	f9 47 00 dc 	st.w	r12[220],r7
8000a14e:	f9 47 00 e0 	st.w	r12[224],r7
8000a152:	99 65       	st.w	r12[0x18],r5
8000a154:	cb af       	rcall	8000a0c8 <__sfp>
8000a156:	8d 0c       	st.w	r6[0x0],r12
8000a158:	0c 9c       	mov	r12,r6
8000a15a:	cb 7f       	rcall	8000a0c8 <__sfp>
8000a15c:	8d 1c       	st.w	r6[0x4],r12
8000a15e:	0c 9c       	mov	r12,r6
8000a160:	cb 4f       	rcall	8000a0c8 <__sfp>
8000a162:	6c 09       	ld.w	r9,r6[0x0]
8000a164:	30 48       	mov	r8,4
8000a166:	93 07       	st.w	r9[0x0],r7
8000a168:	b2 68       	st.h	r9[0xc],r8
8000a16a:	93 17       	st.w	r9[0x4],r7
8000a16c:	93 27       	st.w	r9[0x8],r7
8000a16e:	6c 18       	ld.w	r8,r6[0x4]
8000a170:	b2 77       	st.h	r9[0xe],r7
8000a172:	93 47       	st.w	r9[0x10],r7
8000a174:	93 57       	st.w	r9[0x14],r7
8000a176:	93 67       	st.w	r9[0x18],r7
8000a178:	93 89       	st.w	r9[0x20],r9
8000a17a:	91 07       	st.w	r8[0x0],r7
8000a17c:	91 17       	st.w	r8[0x4],r7
8000a17e:	91 27       	st.w	r8[0x8],r7
8000a180:	fe ce f3 24 	sub	lr,pc,-3292
8000a184:	fe cb f3 54 	sub	r11,pc,-3244
8000a188:	93 9e       	st.w	r9[0x24],lr
8000a18a:	93 ab       	st.w	r9[0x28],r11
8000a18c:	fe ca f3 7c 	sub	r10,pc,-3204
8000a190:	fe c4 f3 88 	sub	r4,pc,-3192
8000a194:	93 ba       	st.w	r9[0x2c],r10
8000a196:	93 c4       	st.w	r9[0x30],r4
8000a198:	30 99       	mov	r9,9
8000a19a:	b0 69       	st.h	r8[0xc],r9
8000a19c:	b0 75       	st.h	r8[0xe],r5
8000a19e:	91 c4       	st.w	r8[0x30],r4
8000a1a0:	91 47       	st.w	r8[0x10],r7
8000a1a2:	91 57       	st.w	r8[0x14],r7
8000a1a4:	91 67       	st.w	r8[0x18],r7
8000a1a6:	91 88       	st.w	r8[0x20],r8
8000a1a8:	91 9e       	st.w	r8[0x24],lr
8000a1aa:	91 ab       	st.w	r8[0x28],r11
8000a1ac:	91 ba       	st.w	r8[0x2c],r10
8000a1ae:	8d 2c       	st.w	r6[0x8],r12
8000a1b0:	31 28       	mov	r8,18
8000a1b2:	99 07       	st.w	r12[0x0],r7
8000a1b4:	b8 68       	st.h	r12[0xc],r8
8000a1b6:	99 17       	st.w	r12[0x4],r7
8000a1b8:	99 27       	st.w	r12[0x8],r7
8000a1ba:	30 28       	mov	r8,2
8000a1bc:	b8 78       	st.h	r12[0xe],r8
8000a1be:	99 c4       	st.w	r12[0x30],r4
8000a1c0:	99 67       	st.w	r12[0x18],r7
8000a1c2:	99 9e       	st.w	r12[0x24],lr
8000a1c4:	99 ab       	st.w	r12[0x28],r11
8000a1c6:	99 ba       	st.w	r12[0x2c],r10
8000a1c8:	99 47       	st.w	r12[0x10],r7
8000a1ca:	99 57       	st.w	r12[0x14],r7
8000a1cc:	99 8c       	st.w	r12[0x20],r12
8000a1ce:	d8 22       	popm	r4-r7,pc

8000a1d0 <_malloc_trim_r>:
8000a1d0:	d4 21       	pushm	r4-r7,lr
8000a1d2:	16 95       	mov	r5,r11
8000a1d4:	18 97       	mov	r7,r12
8000a1d6:	fe b0 d7 f5 	rcall	800051c0 <__malloc_lock>
8000a1da:	e0 64 05 40 	mov	r4,1344
8000a1de:	68 28       	ld.w	r8,r4[0x8]
8000a1e0:	70 16       	ld.w	r6,r8[0x4]
8000a1e2:	e0 16 ff fc 	andl	r6,0xfffc
8000a1e6:	ec c8 ff 91 	sub	r8,r6,-111
8000a1ea:	f0 05 01 05 	sub	r5,r8,r5
8000a1ee:	e0 15 ff 80 	andl	r5,0xff80
8000a1f2:	ea c5 00 80 	sub	r5,r5,128
8000a1f6:	e0 45 00 7f 	cp.w	r5,127
8000a1fa:	e0 8a 00 25 	brle	8000a244 <_malloc_trim_r+0x74>
8000a1fe:	30 0b       	mov	r11,0
8000a200:	0e 9c       	mov	r12,r7
8000a202:	fe b0 e6 05 	rcall	80006e0c <_sbrk_r>
8000a206:	68 28       	ld.w	r8,r4[0x8]
8000a208:	0c 08       	add	r8,r6
8000a20a:	10 3c       	cp.w	r12,r8
8000a20c:	c1 c1       	brne	8000a244 <_malloc_trim_r+0x74>
8000a20e:	ea 0b 11 00 	rsub	r11,r5,0
8000a212:	0e 9c       	mov	r12,r7
8000a214:	fe b0 e5 fc 	rcall	80006e0c <_sbrk_r>
8000a218:	5b fc       	cp.w	r12,-1
8000a21a:	c1 91       	brne	8000a24c <_malloc_trim_r+0x7c>
8000a21c:	30 0b       	mov	r11,0
8000a21e:	0e 9c       	mov	r12,r7
8000a220:	fe b0 e5 f6 	rcall	80006e0c <_sbrk_r>
8000a224:	68 28       	ld.w	r8,r4[0x8]
8000a226:	f8 08 01 09 	sub	r9,r12,r8
8000a22a:	58 f9       	cp.w	r9,15
8000a22c:	e0 8a 00 0c 	brle	8000a244 <_malloc_trim_r+0x74>
8000a230:	a1 a9       	sbr	r9,0x0
8000a232:	91 19       	st.w	r8[0x4],r9
8000a234:	e0 68 09 4c 	mov	r8,2380
8000a238:	70 09       	ld.w	r9,r8[0x0]
8000a23a:	e0 68 0d 60 	mov	r8,3424
8000a23e:	f8 09 01 09 	sub	r9,r12,r9
8000a242:	91 09       	st.w	r8[0x0],r9
8000a244:	0e 9c       	mov	r12,r7
8000a246:	fe b0 d7 c3 	rcall	800051cc <__malloc_unlock>
8000a24a:	d8 2a       	popm	r4-r7,pc,r12=0
8000a24c:	68 28       	ld.w	r8,r4[0x8]
8000a24e:	0a 16       	sub	r6,r5
8000a250:	a1 a6       	sbr	r6,0x0
8000a252:	91 16       	st.w	r8[0x4],r6
8000a254:	e0 68 0d 60 	mov	r8,3424
8000a258:	70 09       	ld.w	r9,r8[0x0]
8000a25a:	0a 19       	sub	r9,r5
8000a25c:	0e 9c       	mov	r12,r7
8000a25e:	91 09       	st.w	r8[0x0],r9
8000a260:	fe b0 d7 b6 	rcall	800051cc <__malloc_unlock>
8000a264:	da 2a       	popm	r4-r7,pc,r12=1
8000a266:	d7 03       	nop

8000a268 <_free_r>:
8000a268:	d4 21       	pushm	r4-r7,lr
8000a26a:	16 96       	mov	r6,r11
8000a26c:	18 97       	mov	r7,r12
8000a26e:	58 0b       	cp.w	r11,0
8000a270:	e0 80 00 c0 	breq	8000a3f0 <_free_r+0x188>
8000a274:	fe b0 d7 a6 	rcall	800051c0 <__malloc_lock>
8000a278:	20 86       	sub	r6,8
8000a27a:	e0 6a 05 40 	mov	r10,1344
8000a27e:	6c 18       	ld.w	r8,r6[0x4]
8000a280:	74 2e       	ld.w	lr,r10[0x8]
8000a282:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
8000a286:	a1 c8       	cbr	r8,0x0
8000a288:	ec 08 00 09 	add	r9,r6,r8
8000a28c:	72 1b       	ld.w	r11,r9[0x4]
8000a28e:	e0 1b ff fc 	andl	r11,0xfffc
8000a292:	1c 39       	cp.w	r9,lr
8000a294:	c1 e1       	brne	8000a2d0 <_free_r+0x68>
8000a296:	f6 08 00 08 	add	r8,r11,r8
8000a29a:	58 0c       	cp.w	r12,0
8000a29c:	c0 81       	brne	8000a2ac <_free_r+0x44>
8000a29e:	6c 09       	ld.w	r9,r6[0x0]
8000a2a0:	12 16       	sub	r6,r9
8000a2a2:	12 08       	add	r8,r9
8000a2a4:	6c 3b       	ld.w	r11,r6[0xc]
8000a2a6:	6c 29       	ld.w	r9,r6[0x8]
8000a2a8:	97 29       	st.w	r11[0x8],r9
8000a2aa:	93 3b       	st.w	r9[0xc],r11
8000a2ac:	10 99       	mov	r9,r8
8000a2ae:	95 26       	st.w	r10[0x8],r6
8000a2b0:	a1 a9       	sbr	r9,0x0
8000a2b2:	8d 19       	st.w	r6[0x4],r9
8000a2b4:	e0 69 09 48 	mov	r9,2376
8000a2b8:	72 09       	ld.w	r9,r9[0x0]
8000a2ba:	12 38       	cp.w	r8,r9
8000a2bc:	c0 63       	brcs	8000a2c8 <_free_r+0x60>
8000a2be:	e0 68 0d 5c 	mov	r8,3420
8000a2c2:	0e 9c       	mov	r12,r7
8000a2c4:	70 0b       	ld.w	r11,r8[0x0]
8000a2c6:	c8 5f       	rcall	8000a1d0 <_malloc_trim_r>
8000a2c8:	0e 9c       	mov	r12,r7
8000a2ca:	fe b0 d7 81 	rcall	800051cc <__malloc_unlock>
8000a2ce:	d8 22       	popm	r4-r7,pc
8000a2d0:	93 1b       	st.w	r9[0x4],r11
8000a2d2:	58 0c       	cp.w	r12,0
8000a2d4:	c0 30       	breq	8000a2da <_free_r+0x72>
8000a2d6:	30 0c       	mov	r12,0
8000a2d8:	c1 08       	rjmp	8000a2f8 <_free_r+0x90>
8000a2da:	6c 0e       	ld.w	lr,r6[0x0]
8000a2dc:	f4 c5 ff f8 	sub	r5,r10,-8
8000a2e0:	1c 16       	sub	r6,lr
8000a2e2:	1c 08       	add	r8,lr
8000a2e4:	6c 2e       	ld.w	lr,r6[0x8]
8000a2e6:	0a 3e       	cp.w	lr,r5
8000a2e8:	f9 bc 00 01 	moveq	r12,1
8000a2ec:	ed f5 10 03 	ld.wne	r5,r6[0xc]
8000a2f0:	eb fe 1a 02 	st.wne	r5[0x8],lr
8000a2f4:	fd f5 1a 03 	st.wne	lr[0xc],r5
8000a2f8:	f2 0b 00 0e 	add	lr,r9,r11
8000a2fc:	7c 1e       	ld.w	lr,lr[0x4]
8000a2fe:	ed be 00 00 	bld	lr,0x0
8000a302:	c1 40       	breq	8000a32a <_free_r+0xc2>
8000a304:	16 08       	add	r8,r11
8000a306:	58 0c       	cp.w	r12,0
8000a308:	c0 d1       	brne	8000a322 <_free_r+0xba>
8000a30a:	e0 6e 05 40 	mov	lr,1344
8000a30e:	72 2b       	ld.w	r11,r9[0x8]
8000a310:	2f 8e       	sub	lr,-8
8000a312:	1c 3b       	cp.w	r11,lr
8000a314:	c0 71       	brne	8000a322 <_free_r+0xba>
8000a316:	97 36       	st.w	r11[0xc],r6
8000a318:	97 26       	st.w	r11[0x8],r6
8000a31a:	8d 2b       	st.w	r6[0x8],r11
8000a31c:	8d 3b       	st.w	r6[0xc],r11
8000a31e:	30 1c       	mov	r12,1
8000a320:	c0 58       	rjmp	8000a32a <_free_r+0xc2>
8000a322:	72 2b       	ld.w	r11,r9[0x8]
8000a324:	72 39       	ld.w	r9,r9[0xc]
8000a326:	93 2b       	st.w	r9[0x8],r11
8000a328:	97 39       	st.w	r11[0xc],r9
8000a32a:	10 99       	mov	r9,r8
8000a32c:	ec 08 09 08 	st.w	r6[r8],r8
8000a330:	a1 a9       	sbr	r9,0x0
8000a332:	8d 19       	st.w	r6[0x4],r9
8000a334:	58 0c       	cp.w	r12,0
8000a336:	c5 a1       	brne	8000a3ea <_free_r+0x182>
8000a338:	e0 48 01 ff 	cp.w	r8,511
8000a33c:	e0 8b 00 13 	brhi	8000a362 <_free_r+0xfa>
8000a340:	a3 98       	lsr	r8,0x3
8000a342:	f4 08 00 39 	add	r9,r10,r8<<0x3
8000a346:	72 2b       	ld.w	r11,r9[0x8]
8000a348:	8d 39       	st.w	r6[0xc],r9
8000a34a:	8d 2b       	st.w	r6[0x8],r11
8000a34c:	97 36       	st.w	r11[0xc],r6
8000a34e:	93 26       	st.w	r9[0x8],r6
8000a350:	a3 48       	asr	r8,0x2
8000a352:	74 19       	ld.w	r9,r10[0x4]
8000a354:	30 1b       	mov	r11,1
8000a356:	f6 08 09 48 	lsl	r8,r11,r8
8000a35a:	f3 e8 10 08 	or	r8,r9,r8
8000a35e:	95 18       	st.w	r10[0x4],r8
8000a360:	c4 58       	rjmp	8000a3ea <_free_r+0x182>
8000a362:	f0 0b 16 09 	lsr	r11,r8,0x9
8000a366:	58 4b       	cp.w	r11,4
8000a368:	e0 8b 00 06 	brhi	8000a374 <_free_r+0x10c>
8000a36c:	f0 0b 16 06 	lsr	r11,r8,0x6
8000a370:	2c 8b       	sub	r11,-56
8000a372:	c2 08       	rjmp	8000a3b2 <_free_r+0x14a>
8000a374:	59 4b       	cp.w	r11,20
8000a376:	e0 8b 00 04 	brhi	8000a37e <_free_r+0x116>
8000a37a:	2a 5b       	sub	r11,-91
8000a37c:	c1 b8       	rjmp	8000a3b2 <_free_r+0x14a>
8000a37e:	e0 4b 00 54 	cp.w	r11,84
8000a382:	e0 8b 00 06 	brhi	8000a38e <_free_r+0x126>
8000a386:	f0 0b 16 0c 	lsr	r11,r8,0xc
8000a38a:	29 2b       	sub	r11,-110
8000a38c:	c1 38       	rjmp	8000a3b2 <_free_r+0x14a>
8000a38e:	e0 4b 01 54 	cp.w	r11,340
8000a392:	e0 8b 00 06 	brhi	8000a39e <_free_r+0x136>
8000a396:	f0 0b 16 0f 	lsr	r11,r8,0xf
8000a39a:	28 9b       	sub	r11,-119
8000a39c:	c0 b8       	rjmp	8000a3b2 <_free_r+0x14a>
8000a39e:	e0 4b 05 54 	cp.w	r11,1364
8000a3a2:	e0 88 00 05 	brls	8000a3ac <_free_r+0x144>
8000a3a6:	37 eb       	mov	r11,126
8000a3a8:	c0 58       	rjmp	8000a3b2 <_free_r+0x14a>
8000a3aa:	d7 03       	nop
8000a3ac:	f0 0b 16 12 	lsr	r11,r8,0x12
8000a3b0:	28 4b       	sub	r11,-124
8000a3b2:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
8000a3b6:	78 29       	ld.w	r9,r12[0x8]
8000a3b8:	18 39       	cp.w	r9,r12
8000a3ba:	c0 e1       	brne	8000a3d6 <_free_r+0x16e>
8000a3bc:	74 18       	ld.w	r8,r10[0x4]
8000a3be:	a3 4b       	asr	r11,0x2
8000a3c0:	30 1c       	mov	r12,1
8000a3c2:	f8 0b 09 4b 	lsl	r11,r12,r11
8000a3c6:	f1 eb 10 0b 	or	r11,r8,r11
8000a3ca:	12 98       	mov	r8,r9
8000a3cc:	95 1b       	st.w	r10[0x4],r11
8000a3ce:	c0 a8       	rjmp	8000a3e2 <_free_r+0x17a>
8000a3d0:	72 29       	ld.w	r9,r9[0x8]
8000a3d2:	18 39       	cp.w	r9,r12
8000a3d4:	c0 60       	breq	8000a3e0 <_free_r+0x178>
8000a3d6:	72 1a       	ld.w	r10,r9[0x4]
8000a3d8:	e0 1a ff fc 	andl	r10,0xfffc
8000a3dc:	14 38       	cp.w	r8,r10
8000a3de:	cf 93       	brcs	8000a3d0 <_free_r+0x168>
8000a3e0:	72 38       	ld.w	r8,r9[0xc]
8000a3e2:	8d 38       	st.w	r6[0xc],r8
8000a3e4:	8d 29       	st.w	r6[0x8],r9
8000a3e6:	93 36       	st.w	r9[0xc],r6
8000a3e8:	91 26       	st.w	r8[0x8],r6
8000a3ea:	0e 9c       	mov	r12,r7
8000a3ec:	fe b0 d6 f0 	rcall	800051cc <__malloc_unlock>
8000a3f0:	d8 22       	popm	r4-r7,pc
8000a3f2:	d7 03       	nop

8000a3f4 <__sfvwrite_r>:
8000a3f4:	d4 31       	pushm	r0-r7,lr
8000a3f6:	20 3d       	sub	sp,12
8000a3f8:	14 94       	mov	r4,r10
8000a3fa:	18 95       	mov	r5,r12
8000a3fc:	16 97       	mov	r7,r11
8000a3fe:	74 28       	ld.w	r8,r10[0x8]
8000a400:	58 08       	cp.w	r8,0
8000a402:	e0 80 01 40 	breq	8000a682 <__sfvwrite_r+0x28e>
8000a406:	96 68       	ld.sh	r8,r11[0xc]
8000a408:	ed b8 00 03 	bld	r8,0x3
8000a40c:	c0 41       	brne	8000a414 <__sfvwrite_r+0x20>
8000a40e:	76 48       	ld.w	r8,r11[0x10]
8000a410:	58 08       	cp.w	r8,0
8000a412:	c0 c1       	brne	8000a42a <__sfvwrite_r+0x36>
8000a414:	0e 9b       	mov	r11,r7
8000a416:	0a 9c       	mov	r12,r5
8000a418:	fe b0 f6 c4 	rcall	800091a0 <__swsetup_r>
8000a41c:	c0 70       	breq	8000a42a <__sfvwrite_r+0x36>
8000a41e:	8e 68       	ld.sh	r8,r7[0xc]
8000a420:	a7 a8       	sbr	r8,0x6
8000a422:	ae 68       	st.h	r7[0xc],r8
8000a424:	30 98       	mov	r8,9
8000a426:	8b 38       	st.w	r5[0xc],r8
8000a428:	c2 b9       	rjmp	8000a67e <__sfvwrite_r+0x28a>
8000a42a:	8e 63       	ld.sh	r3,r7[0xc]
8000a42c:	68 00       	ld.w	r0,r4[0x0]
8000a42e:	06 96       	mov	r6,r3
8000a430:	e2 16 00 02 	andl	r6,0x2,COH
8000a434:	c2 10       	breq	8000a476 <__sfvwrite_r+0x82>
8000a436:	30 03       	mov	r3,0
8000a438:	e0 62 04 00 	mov	r2,1024
8000a43c:	06 96       	mov	r6,r3
8000a43e:	c0 48       	rjmp	8000a446 <__sfvwrite_r+0x52>
8000a440:	60 03       	ld.w	r3,r0[0x0]
8000a442:	60 16       	ld.w	r6,r0[0x4]
8000a444:	2f 80       	sub	r0,-8
8000a446:	58 06       	cp.w	r6,0
8000a448:	cf c0       	breq	8000a440 <__sfvwrite_r+0x4c>
8000a44a:	e0 46 04 00 	cp.w	r6,1024
8000a44e:	ec 09 17 80 	movls	r9,r6
8000a452:	e4 09 17 b0 	movhi	r9,r2
8000a456:	06 9a       	mov	r10,r3
8000a458:	6e a8       	ld.w	r8,r7[0x28]
8000a45a:	6e 8b       	ld.w	r11,r7[0x20]
8000a45c:	0a 9c       	mov	r12,r5
8000a45e:	5d 18       	icall	r8
8000a460:	18 16       	sub	r6,r12
8000a462:	58 0c       	cp.w	r12,0
8000a464:	e0 8a 01 0a 	brle	8000a678 <__sfvwrite_r+0x284>
8000a468:	68 28       	ld.w	r8,r4[0x8]
8000a46a:	18 18       	sub	r8,r12
8000a46c:	89 28       	st.w	r4[0x8],r8
8000a46e:	e0 80 01 0a 	breq	8000a682 <__sfvwrite_r+0x28e>
8000a472:	18 03       	add	r3,r12
8000a474:	ce 9b       	rjmp	8000a446 <__sfvwrite_r+0x52>
8000a476:	e7 d3 c0 01 	bfextu	r3,r3,0x0,0x1
8000a47a:	c0 70       	breq	8000a488 <__sfvwrite_r+0x94>
8000a47c:	50 06       	stdsp	sp[0x0],r6
8000a47e:	0c 93       	mov	r3,r6
8000a480:	0c 91       	mov	r1,r6
8000a482:	50 15       	stdsp	sp[0x4],r5
8000a484:	08 92       	mov	r2,r4
8000a486:	c9 c8       	rjmp	8000a5be <__sfvwrite_r+0x1ca>
8000a488:	06 96       	mov	r6,r3
8000a48a:	08 91       	mov	r1,r4
8000a48c:	c0 48       	rjmp	8000a494 <__sfvwrite_r+0xa0>
8000a48e:	60 03       	ld.w	r3,r0[0x0]
8000a490:	60 16       	ld.w	r6,r0[0x4]
8000a492:	2f 80       	sub	r0,-8
8000a494:	58 06       	cp.w	r6,0
8000a496:	cf c0       	breq	8000a48e <__sfvwrite_r+0x9a>
8000a498:	8e 68       	ld.sh	r8,r7[0xc]
8000a49a:	6e 24       	ld.w	r4,r7[0x8]
8000a49c:	10 99       	mov	r9,r8
8000a49e:	e2 19 02 00 	andl	r9,0x200,COH
8000a4a2:	c5 50       	breq	8000a54c <__sfvwrite_r+0x158>
8000a4a4:	08 36       	cp.w	r6,r4
8000a4a6:	c4 43       	brcs	8000a52e <__sfvwrite_r+0x13a>
8000a4a8:	10 99       	mov	r9,r8
8000a4aa:	e2 19 04 80 	andl	r9,0x480,COH
8000a4ae:	c4 00       	breq	8000a52e <__sfvwrite_r+0x13a>
8000a4b0:	6e 4b       	ld.w	r11,r7[0x10]
8000a4b2:	6e 09       	ld.w	r9,r7[0x0]
8000a4b4:	16 19       	sub	r9,r11
8000a4b6:	50 09       	stdsp	sp[0x0],r9
8000a4b8:	6e 59       	ld.w	r9,r7[0x14]
8000a4ba:	10 9c       	mov	r12,r8
8000a4bc:	f2 09 00 1a 	add	r10,r9,r9<<0x1
8000a4c0:	30 28       	mov	r8,2
8000a4c2:	f4 08 0c 08 	divs	r8,r10,r8
8000a4c6:	fa e9 00 04 	st.d	sp[4],r8
8000a4ca:	10 94       	mov	r4,r8
8000a4cc:	40 09       	lddsp	r9,sp[0x0]
8000a4ce:	e2 1c 04 00 	andl	r12,0x400,COH
8000a4d2:	2f f9       	sub	r9,-1
8000a4d4:	0c 09       	add	r9,r6
8000a4d6:	12 38       	cp.w	r8,r9
8000a4d8:	f2 04 17 30 	movlo	r4,r9
8000a4dc:	58 0c       	cp.w	r12,0
8000a4de:	c1 10       	breq	8000a500 <__sfvwrite_r+0x10c>
8000a4e0:	08 9b       	mov	r11,r4
8000a4e2:	0a 9c       	mov	r12,r5
8000a4e4:	fe b0 e0 6c 	rcall	800065bc <_malloc_r>
8000a4e8:	18 92       	mov	r2,r12
8000a4ea:	c1 40       	breq	8000a512 <__sfvwrite_r+0x11e>
8000a4ec:	40 0a       	lddsp	r10,sp[0x0]
8000a4ee:	6e 4b       	ld.w	r11,r7[0x10]
8000a4f0:	fe b0 e2 82 	rcall	800069f4 <memcpy>
8000a4f4:	8e 68       	ld.sh	r8,r7[0xc]
8000a4f6:	e0 18 fb 7f 	andl	r8,0xfb7f
8000a4fa:	a7 b8       	sbr	r8,0x7
8000a4fc:	ae 68       	st.h	r7[0xc],r8
8000a4fe:	c0 d8       	rjmp	8000a518 <__sfvwrite_r+0x124>
8000a500:	08 9a       	mov	r10,r4
8000a502:	0a 9c       	mov	r12,r5
8000a504:	fe b0 e3 24 	rcall	80006b4c <_realloc_r>
8000a508:	18 92       	mov	r2,r12
8000a50a:	c0 71       	brne	8000a518 <__sfvwrite_r+0x124>
8000a50c:	6e 4b       	ld.w	r11,r7[0x10]
8000a50e:	0a 9c       	mov	r12,r5
8000a510:	ca ce       	rcall	8000a268 <_free_r>
8000a512:	30 c8       	mov	r8,12
8000a514:	8b 38       	st.w	r5[0xc],r8
8000a516:	cb 18       	rjmp	8000a678 <__sfvwrite_r+0x284>
8000a518:	40 0a       	lddsp	r10,sp[0x0]
8000a51a:	40 09       	lddsp	r9,sp[0x0]
8000a51c:	e8 0a 01 0a 	sub	r10,r4,r10
8000a520:	e4 09 00 08 	add	r8,r2,r9
8000a524:	8f 54       	st.w	r7[0x14],r4
8000a526:	8f 2a       	st.w	r7[0x8],r10
8000a528:	8f 08       	st.w	r7[0x0],r8
8000a52a:	8f 42       	st.w	r7[0x10],r2
8000a52c:	0c 94       	mov	r4,r6
8000a52e:	08 36       	cp.w	r6,r4
8000a530:	ec 04 17 30 	movlo	r4,r6
8000a534:	06 9b       	mov	r11,r3
8000a536:	08 9a       	mov	r10,r4
8000a538:	6e 0c       	ld.w	r12,r7[0x0]
8000a53a:	c3 ad       	rcall	8000a7ae <memmove>
8000a53c:	6e 08       	ld.w	r8,r7[0x0]
8000a53e:	08 08       	add	r8,r4
8000a540:	8f 08       	st.w	r7[0x0],r8
8000a542:	6e 28       	ld.w	r8,r7[0x8]
8000a544:	08 18       	sub	r8,r4
8000a546:	0c 94       	mov	r4,r6
8000a548:	8f 28       	st.w	r7[0x8],r8
8000a54a:	c2 e8       	rjmp	8000a5a6 <__sfvwrite_r+0x1b2>
8000a54c:	08 36       	cp.w	r6,r4
8000a54e:	5f ba       	srhi	r10
8000a550:	6e 0c       	ld.w	r12,r7[0x0]
8000a552:	6e 48       	ld.w	r8,r7[0x10]
8000a554:	10 3c       	cp.w	r12,r8
8000a556:	5f b8       	srhi	r8
8000a558:	f5 e8 00 08 	and	r8,r10,r8
8000a55c:	f2 08 18 00 	cp.b	r8,r9
8000a560:	c0 d0       	breq	8000a57a <__sfvwrite_r+0x186>
8000a562:	06 9b       	mov	r11,r3
8000a564:	08 9a       	mov	r10,r4
8000a566:	c2 4d       	rcall	8000a7ae <memmove>
8000a568:	6e 08       	ld.w	r8,r7[0x0]
8000a56a:	08 08       	add	r8,r4
8000a56c:	0e 9b       	mov	r11,r7
8000a56e:	8f 08       	st.w	r7[0x0],r8
8000a570:	0a 9c       	mov	r12,r5
8000a572:	fe b0 fd 09 	rcall	80009f84 <_fflush_r>
8000a576:	c1 80       	breq	8000a5a6 <__sfvwrite_r+0x1b2>
8000a578:	c8 08       	rjmp	8000a678 <__sfvwrite_r+0x284>
8000a57a:	6e 59       	ld.w	r9,r7[0x14]
8000a57c:	12 36       	cp.w	r6,r9
8000a57e:	c0 a3       	brcs	8000a592 <__sfvwrite_r+0x19e>
8000a580:	6e a8       	ld.w	r8,r7[0x28]
8000a582:	06 9a       	mov	r10,r3
8000a584:	6e 8b       	ld.w	r11,r7[0x20]
8000a586:	0a 9c       	mov	r12,r5
8000a588:	5d 18       	icall	r8
8000a58a:	18 94       	mov	r4,r12
8000a58c:	e0 89 00 0d 	brgt	8000a5a6 <__sfvwrite_r+0x1b2>
8000a590:	c7 48       	rjmp	8000a678 <__sfvwrite_r+0x284>
8000a592:	0c 9a       	mov	r10,r6
8000a594:	06 9b       	mov	r11,r3
8000a596:	c0 cd       	rcall	8000a7ae <memmove>
8000a598:	6e 08       	ld.w	r8,r7[0x0]
8000a59a:	0c 08       	add	r8,r6
8000a59c:	0c 94       	mov	r4,r6
8000a59e:	8f 08       	st.w	r7[0x0],r8
8000a5a0:	6e 28       	ld.w	r8,r7[0x8]
8000a5a2:	0c 18       	sub	r8,r6
8000a5a4:	8f 28       	st.w	r7[0x8],r8
8000a5a6:	62 28       	ld.w	r8,r1[0x8]
8000a5a8:	08 18       	sub	r8,r4
8000a5aa:	83 28       	st.w	r1[0x8],r8
8000a5ac:	c6 b0       	breq	8000a682 <__sfvwrite_r+0x28e>
8000a5ae:	08 16       	sub	r6,r4
8000a5b0:	08 03       	add	r3,r4
8000a5b2:	c7 1b       	rjmp	8000a494 <__sfvwrite_r+0xa0>
8000a5b4:	60 03       	ld.w	r3,r0[0x0]
8000a5b6:	60 11       	ld.w	r1,r0[0x4]
8000a5b8:	30 08       	mov	r8,0
8000a5ba:	2f 80       	sub	r0,-8
8000a5bc:	50 08       	stdsp	sp[0x0],r8
8000a5be:	58 01       	cp.w	r1,0
8000a5c0:	cf a0       	breq	8000a5b4 <__sfvwrite_r+0x1c0>
8000a5c2:	40 0a       	lddsp	r10,sp[0x0]
8000a5c4:	58 0a       	cp.w	r10,0
8000a5c6:	c1 41       	brne	8000a5ee <__sfvwrite_r+0x1fa>
8000a5c8:	e2 c6 ff ff 	sub	r6,r1,-1
8000a5cc:	02 9a       	mov	r10,r1
8000a5ce:	30 ab       	mov	r11,10
8000a5d0:	06 9c       	mov	r12,r3
8000a5d2:	ce 3c       	rcall	8000a798 <memchr>
8000a5d4:	f8 c8 ff ff 	sub	r8,r12,-1
8000a5d8:	58 0c       	cp.w	r12,0
8000a5da:	f1 d3 e1 16 	subne	r6,r8,r3
8000a5de:	f9 b9 01 01 	movne	r9,1
8000a5e2:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000a5e6:	f9 b8 00 01 	moveq	r8,1
8000a5ea:	fb f8 0a 00 	st.weq	sp[0x0],r8
8000a5ee:	02 36       	cp.w	r6,r1
8000a5f0:	ec 04 17 80 	movls	r4,r6
8000a5f4:	e2 04 17 b0 	movhi	r4,r1
8000a5f8:	6e 59       	ld.w	r9,r7[0x14]
8000a5fa:	6e 25       	ld.w	r5,r7[0x8]
8000a5fc:	f2 05 00 05 	add	r5,r9,r5
8000a600:	0a 34       	cp.w	r4,r5
8000a602:	5f 9a       	srgt	r10
8000a604:	6e 0c       	ld.w	r12,r7[0x0]
8000a606:	6e 48       	ld.w	r8,r7[0x10]
8000a608:	10 3c       	cp.w	r12,r8
8000a60a:	5f b8       	srhi	r8
8000a60c:	f5 e8 00 08 	and	r8,r10,r8
8000a610:	30 0a       	mov	r10,0
8000a612:	f4 08 18 00 	cp.b	r8,r10
8000a616:	c0 d0       	breq	8000a630 <__sfvwrite_r+0x23c>
8000a618:	06 9b       	mov	r11,r3
8000a61a:	0a 9a       	mov	r10,r5
8000a61c:	cc 9c       	rcall	8000a7ae <memmove>
8000a61e:	6e 08       	ld.w	r8,r7[0x0]
8000a620:	0a 08       	add	r8,r5
8000a622:	0e 9b       	mov	r11,r7
8000a624:	8f 08       	st.w	r7[0x0],r8
8000a626:	40 1c       	lddsp	r12,sp[0x4]
8000a628:	fe b0 fc ae 	rcall	80009f84 <_fflush_r>
8000a62c:	c1 70       	breq	8000a65a <__sfvwrite_r+0x266>
8000a62e:	c2 58       	rjmp	8000a678 <__sfvwrite_r+0x284>
8000a630:	12 34       	cp.w	r4,r9
8000a632:	c0 a5       	brlt	8000a646 <__sfvwrite_r+0x252>
8000a634:	6e a8       	ld.w	r8,r7[0x28]
8000a636:	06 9a       	mov	r10,r3
8000a638:	6e 8b       	ld.w	r11,r7[0x20]
8000a63a:	40 1c       	lddsp	r12,sp[0x4]
8000a63c:	5d 18       	icall	r8
8000a63e:	18 95       	mov	r5,r12
8000a640:	e0 89 00 0d 	brgt	8000a65a <__sfvwrite_r+0x266>
8000a644:	c1 a8       	rjmp	8000a678 <__sfvwrite_r+0x284>
8000a646:	08 9a       	mov	r10,r4
8000a648:	06 9b       	mov	r11,r3
8000a64a:	cb 2c       	rcall	8000a7ae <memmove>
8000a64c:	6e 08       	ld.w	r8,r7[0x0]
8000a64e:	08 08       	add	r8,r4
8000a650:	08 95       	mov	r5,r4
8000a652:	8f 08       	st.w	r7[0x0],r8
8000a654:	6e 28       	ld.w	r8,r7[0x8]
8000a656:	08 18       	sub	r8,r4
8000a658:	8f 28       	st.w	r7[0x8],r8
8000a65a:	0a 16       	sub	r6,r5
8000a65c:	c0 71       	brne	8000a66a <__sfvwrite_r+0x276>
8000a65e:	0e 9b       	mov	r11,r7
8000a660:	40 1c       	lddsp	r12,sp[0x4]
8000a662:	fe b0 fc 91 	rcall	80009f84 <_fflush_r>
8000a666:	c0 91       	brne	8000a678 <__sfvwrite_r+0x284>
8000a668:	50 06       	stdsp	sp[0x0],r6
8000a66a:	64 28       	ld.w	r8,r2[0x8]
8000a66c:	0a 18       	sub	r8,r5
8000a66e:	85 28       	st.w	r2[0x8],r8
8000a670:	c0 90       	breq	8000a682 <__sfvwrite_r+0x28e>
8000a672:	0a 11       	sub	r1,r5
8000a674:	0a 03       	add	r3,r5
8000a676:	ca 4b       	rjmp	8000a5be <__sfvwrite_r+0x1ca>
8000a678:	8e 68       	ld.sh	r8,r7[0xc]
8000a67a:	a7 a8       	sbr	r8,0x6
8000a67c:	ae 68       	st.h	r7[0xc],r8
8000a67e:	3f fc       	mov	r12,-1
8000a680:	c0 28       	rjmp	8000a684 <__sfvwrite_r+0x290>
8000a682:	30 0c       	mov	r12,0
8000a684:	2f dd       	sub	sp,-12
8000a686:	d8 32       	popm	r0-r7,pc

8000a688 <_fwalk>:
8000a688:	d4 31       	pushm	r0-r7,lr
8000a68a:	30 05       	mov	r5,0
8000a68c:	16 91       	mov	r1,r11
8000a68e:	f8 c7 ff 28 	sub	r7,r12,-216
8000a692:	0a 92       	mov	r2,r5
8000a694:	fe b0 fc fe 	rcall	8000a090 <__sfp_lock_acquire>
8000a698:	3f f3       	mov	r3,-1
8000a69a:	c1 68       	rjmp	8000a6c6 <_fwalk+0x3e>
8000a69c:	6e 26       	ld.w	r6,r7[0x8]
8000a69e:	6e 14       	ld.w	r4,r7[0x4]
8000a6a0:	2f 46       	sub	r6,-12
8000a6a2:	c0 c8       	rjmp	8000a6ba <_fwalk+0x32>
8000a6a4:	8c 08       	ld.sh	r8,r6[0x0]
8000a6a6:	e4 08 19 00 	cp.h	r8,r2
8000a6aa:	c0 70       	breq	8000a6b8 <_fwalk+0x30>
8000a6ac:	8c 18       	ld.sh	r8,r6[0x2]
8000a6ae:	e6 08 19 00 	cp.h	r8,r3
8000a6b2:	c0 30       	breq	8000a6b8 <_fwalk+0x30>
8000a6b4:	5d 11       	icall	r1
8000a6b6:	18 45       	or	r5,r12
8000a6b8:	2a 46       	sub	r6,-92
8000a6ba:	20 14       	sub	r4,1
8000a6bc:	ec cc 00 0c 	sub	r12,r6,12
8000a6c0:	58 04       	cp.w	r4,0
8000a6c2:	cf 14       	brge	8000a6a4 <_fwalk+0x1c>
8000a6c4:	6e 07       	ld.w	r7,r7[0x0]
8000a6c6:	58 07       	cp.w	r7,0
8000a6c8:	ce a1       	brne	8000a69c <_fwalk+0x14>
8000a6ca:	fe b0 fc e4 	rcall	8000a092 <__sfp_lock_release>
8000a6ce:	0a 9c       	mov	r12,r5
8000a6d0:	d8 32       	popm	r0-r7,pc
8000a6d2:	d7 03       	nop

8000a6d4 <_localeconv_r>:
8000a6d4:	fe cc d4 e8 	sub	r12,pc,-11032
8000a6d8:	5e fc       	retal	r12
8000a6da:	d7 03       	nop

8000a6dc <__smakebuf_r>:
8000a6dc:	d4 21       	pushm	r4-r7,lr
8000a6de:	20 fd       	sub	sp,60
8000a6e0:	96 68       	ld.sh	r8,r11[0xc]
8000a6e2:	16 97       	mov	r7,r11
8000a6e4:	18 96       	mov	r6,r12
8000a6e6:	e2 18 00 02 	andl	r8,0x2,COH
8000a6ea:	c3 d1       	brne	8000a764 <__smakebuf_r+0x88>
8000a6ec:	96 7b       	ld.sh	r11,r11[0xe]
8000a6ee:	f0 0b 19 00 	cp.h	r11,r8
8000a6f2:	c0 55       	brlt	8000a6fc <__smakebuf_r+0x20>
8000a6f4:	1a 9a       	mov	r10,sp
8000a6f6:	e0 a0 04 81 	rcall	8000aff8 <_fstat_r>
8000a6fa:	c0 f4       	brge	8000a718 <__smakebuf_r+0x3c>
8000a6fc:	8e 65       	ld.sh	r5,r7[0xc]
8000a6fe:	0a 98       	mov	r8,r5
8000a700:	ab b8       	sbr	r8,0xb
8000a702:	e2 15 00 80 	andl	r5,0x80,COH
8000a706:	ae 68       	st.h	r7[0xc],r8
8000a708:	30 04       	mov	r4,0
8000a70a:	e0 68 04 00 	mov	r8,1024
8000a70e:	f9 b5 01 40 	movne	r5,64
8000a712:	f0 05 17 00 	moveq	r5,r8
8000a716:	c1 c8       	rjmp	8000a74e <__smakebuf_r+0x72>
8000a718:	40 18       	lddsp	r8,sp[0x4]
8000a71a:	e2 18 f0 00 	andl	r8,0xf000,COH
8000a71e:	e0 48 20 00 	cp.w	r8,8192
8000a722:	5f 04       	sreq	r4
8000a724:	e0 48 80 00 	cp.w	r8,32768
8000a728:	c0 e1       	brne	8000a744 <__smakebuf_r+0x68>
8000a72a:	6e b9       	ld.w	r9,r7[0x2c]
8000a72c:	fe c8 f9 1c 	sub	r8,pc,-1764
8000a730:	10 39       	cp.w	r9,r8
8000a732:	c0 91       	brne	8000a744 <__smakebuf_r+0x68>
8000a734:	8e 68       	ld.sh	r8,r7[0xc]
8000a736:	e0 65 04 00 	mov	r5,1024
8000a73a:	ab a8       	sbr	r8,0xa
8000a73c:	ef 45 00 50 	st.w	r7[80],r5
8000a740:	ae 68       	st.h	r7[0xc],r8
8000a742:	c0 68       	rjmp	8000a74e <__smakebuf_r+0x72>
8000a744:	8e 68       	ld.sh	r8,r7[0xc]
8000a746:	e0 65 04 00 	mov	r5,1024
8000a74a:	ab b8       	sbr	r8,0xb
8000a74c:	ae 68       	st.h	r7[0xc],r8
8000a74e:	0a 9b       	mov	r11,r5
8000a750:	0c 9c       	mov	r12,r6
8000a752:	fe b0 df 35 	rcall	800065bc <_malloc_r>
8000a756:	8e 68       	ld.sh	r8,r7[0xc]
8000a758:	c0 d1       	brne	8000a772 <__smakebuf_r+0x96>
8000a75a:	ed b8 00 09 	bld	r8,0x9
8000a75e:	c1 b0       	breq	8000a794 <__smakebuf_r+0xb8>
8000a760:	a1 b8       	sbr	r8,0x1
8000a762:	ae 68       	st.h	r7[0xc],r8
8000a764:	ee c8 ff b9 	sub	r8,r7,-71
8000a768:	8f 48       	st.w	r7[0x10],r8
8000a76a:	8f 08       	st.w	r7[0x0],r8
8000a76c:	30 18       	mov	r8,1
8000a76e:	8f 58       	st.w	r7[0x14],r8
8000a770:	c1 28       	rjmp	8000a794 <__smakebuf_r+0xb8>
8000a772:	a7 b8       	sbr	r8,0x7
8000a774:	8f 4c       	st.w	r7[0x10],r12
8000a776:	ae 68       	st.h	r7[0xc],r8
8000a778:	8f 55       	st.w	r7[0x14],r5
8000a77a:	fe c8 06 e6 	sub	r8,pc,1766
8000a77e:	8f 0c       	st.w	r7[0x0],r12
8000a780:	8d a8       	st.w	r6[0x28],r8
8000a782:	58 04       	cp.w	r4,0
8000a784:	c0 80       	breq	8000a794 <__smakebuf_r+0xb8>
8000a786:	8e 7c       	ld.sh	r12,r7[0xe]
8000a788:	fe b0 e3 94 	rcall	80006eb0 <isatty>
8000a78c:	c0 40       	breq	8000a794 <__smakebuf_r+0xb8>
8000a78e:	8e 68       	ld.sh	r8,r7[0xc]
8000a790:	a1 a8       	sbr	r8,0x0
8000a792:	ae 68       	st.h	r7[0xc],r8
8000a794:	2f 1d       	sub	sp,-60
8000a796:	d8 22       	popm	r4-r7,pc

8000a798 <memchr>:
8000a798:	f7 db c0 08 	bfextu	r11,r11,0x0,0x8
8000a79c:	c0 68       	rjmp	8000a7a8 <memchr+0x10>
8000a79e:	20 1a       	sub	r10,1
8000a7a0:	19 88       	ld.ub	r8,r12[0x0]
8000a7a2:	16 38       	cp.w	r8,r11
8000a7a4:	5e 0c       	reteq	r12
8000a7a6:	2f fc       	sub	r12,-1
8000a7a8:	58 0a       	cp.w	r10,0
8000a7aa:	cf a1       	brne	8000a79e <memchr+0x6>
8000a7ac:	5e fa       	retal	r10

8000a7ae <memmove>:
8000a7ae:	d4 01       	pushm	lr
8000a7b0:	18 3b       	cp.w	r11,r12
8000a7b2:	c1 92       	brcc	8000a7e4 <memmove+0x36>
8000a7b4:	f6 0a 00 09 	add	r9,r11,r10
8000a7b8:	12 3c       	cp.w	r12,r9
8000a7ba:	c1 52       	brcc	8000a7e4 <memmove+0x36>
8000a7bc:	f8 0a 00 0b 	add	r11,r12,r10
8000a7c0:	30 08       	mov	r8,0
8000a7c2:	c0 68       	rjmp	8000a7ce <memmove+0x20>
8000a7c4:	f2 08 07 0e 	ld.ub	lr,r9[r8]
8000a7c8:	20 1a       	sub	r10,1
8000a7ca:	f6 08 0b 0e 	st.b	r11[r8],lr
8000a7ce:	20 18       	sub	r8,1
8000a7d0:	58 0a       	cp.w	r10,0
8000a7d2:	cf 91       	brne	8000a7c4 <memmove+0x16>
8000a7d4:	d8 02       	popm	pc
8000a7d6:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000a7da:	20 1a       	sub	r10,1
8000a7dc:	f8 08 0b 09 	st.b	r12[r8],r9
8000a7e0:	2f f8       	sub	r8,-1
8000a7e2:	c0 28       	rjmp	8000a7e6 <memmove+0x38>
8000a7e4:	30 08       	mov	r8,0
8000a7e6:	58 0a       	cp.w	r10,0
8000a7e8:	cf 71       	brne	8000a7d6 <memmove+0x28>
8000a7ea:	d8 02       	popm	pc

8000a7ec <__hi0bits>:
8000a7ec:	18 98       	mov	r8,r12
8000a7ee:	e0 1c 00 00 	andl	r12,0x0
8000a7f2:	f0 09 15 10 	lsl	r9,r8,0x10
8000a7f6:	58 0c       	cp.w	r12,0
8000a7f8:	f2 08 17 00 	moveq	r8,r9
8000a7fc:	f9 bc 00 10 	moveq	r12,16
8000a800:	f9 bc 01 00 	movne	r12,0
8000a804:	10 9a       	mov	r10,r8
8000a806:	f0 09 15 08 	lsl	r9,r8,0x8
8000a80a:	e6 1a ff 00 	andh	r10,0xff00,COH
8000a80e:	f7 bc 00 f8 	subeq	r12,-8
8000a812:	f2 08 17 00 	moveq	r8,r9
8000a816:	10 9a       	mov	r10,r8
8000a818:	f0 09 15 04 	lsl	r9,r8,0x4
8000a81c:	e6 1a f0 00 	andh	r10,0xf000,COH
8000a820:	f7 bc 00 fc 	subeq	r12,-4
8000a824:	f2 08 17 00 	moveq	r8,r9
8000a828:	10 9a       	mov	r10,r8
8000a82a:	f0 09 15 02 	lsl	r9,r8,0x2
8000a82e:	e6 1a c0 00 	andh	r10,0xc000,COH
8000a832:	f7 bc 00 fe 	subeq	r12,-2
8000a836:	f2 08 17 00 	moveq	r8,r9
8000a83a:	58 08       	cp.w	r8,0
8000a83c:	5e 5c       	retlt	r12
8000a83e:	ed b8 00 1e 	bld	r8,0x1e
8000a842:	f9 bc 01 20 	movne	r12,32
8000a846:	f7 bc 00 ff 	subeq	r12,-1
8000a84a:	5e fc       	retal	r12

8000a84c <__lo0bits>:
8000a84c:	18 99       	mov	r9,r12
8000a84e:	78 08       	ld.w	r8,r12[0x0]
8000a850:	f9 d8 c0 03 	bfextu	r12,r8,0x0,0x3
8000a854:	c1 50       	breq	8000a87e <__lo0bits+0x32>
8000a856:	ed b8 00 00 	bld	r8,0x0
8000a85a:	c0 21       	brne	8000a85e <__lo0bits+0x12>
8000a85c:	5e fd       	retal	0
8000a85e:	10 9b       	mov	r11,r8
8000a860:	f0 0a 16 01 	lsr	r10,r8,0x1
8000a864:	e2 1b 00 02 	andl	r11,0x2,COH
8000a868:	a3 88       	lsr	r8,0x2
8000a86a:	58 0b       	cp.w	r11,0
8000a86c:	f3 fa 1a 00 	st.wne	r9[0x0],r10
8000a870:	f9 bc 01 01 	movne	r12,1
8000a874:	f3 f8 0a 00 	st.weq	r9[0x0],r8
8000a878:	f9 bc 00 02 	moveq	r12,2
8000a87c:	5e fc       	retal	r12
8000a87e:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
8000a882:	f0 0b 16 10 	lsr	r11,r8,0x10
8000a886:	58 0a       	cp.w	r10,0
8000a888:	f6 08 17 00 	moveq	r8,r11
8000a88c:	f9 bc 00 10 	moveq	r12,16
8000a890:	f7 d8 c0 08 	bfextu	r11,r8,0x0,0x8
8000a894:	f0 0a 16 08 	lsr	r10,r8,0x8
8000a898:	58 0b       	cp.w	r11,0
8000a89a:	f7 bc 00 f8 	subeq	r12,-8
8000a89e:	f4 08 17 00 	moveq	r8,r10
8000a8a2:	f7 d8 c0 04 	bfextu	r11,r8,0x0,0x4
8000a8a6:	f0 0a 16 04 	lsr	r10,r8,0x4
8000a8aa:	58 0b       	cp.w	r11,0
8000a8ac:	f7 bc 00 fc 	subeq	r12,-4
8000a8b0:	f4 08 17 00 	moveq	r8,r10
8000a8b4:	f7 d8 c0 02 	bfextu	r11,r8,0x0,0x2
8000a8b8:	f0 0a 16 02 	lsr	r10,r8,0x2
8000a8bc:	58 0b       	cp.w	r11,0
8000a8be:	f7 bc 00 fe 	subeq	r12,-2
8000a8c2:	f4 08 17 00 	moveq	r8,r10
8000a8c6:	ed b8 00 00 	bld	r8,0x0
8000a8ca:	c0 60       	breq	8000a8d6 <__lo0bits+0x8a>
8000a8cc:	a1 98       	lsr	r8,0x1
8000a8ce:	c0 31       	brne	8000a8d4 <__lo0bits+0x88>
8000a8d0:	32 0c       	mov	r12,32
8000a8d2:	5e fc       	retal	r12
8000a8d4:	2f fc       	sub	r12,-1
8000a8d6:	93 08       	st.w	r9[0x0],r8
8000a8d8:	5e fc       	retal	r12

8000a8da <__mcmp>:
8000a8da:	d4 01       	pushm	lr
8000a8dc:	18 98       	mov	r8,r12
8000a8de:	76 49       	ld.w	r9,r11[0x10]
8000a8e0:	78 4c       	ld.w	r12,r12[0x10]
8000a8e2:	12 1c       	sub	r12,r9
8000a8e4:	c1 31       	brne	8000a90a <__mcmp+0x30>
8000a8e6:	2f b9       	sub	r9,-5
8000a8e8:	a3 69       	lsl	r9,0x2
8000a8ea:	12 0b       	add	r11,r9
8000a8ec:	f0 09 00 09 	add	r9,r8,r9
8000a8f0:	2e c8       	sub	r8,-20
8000a8f2:	13 4e       	ld.w	lr,--r9
8000a8f4:	17 4a       	ld.w	r10,--r11
8000a8f6:	14 3e       	cp.w	lr,r10
8000a8f8:	c0 60       	breq	8000a904 <__mcmp+0x2a>
8000a8fa:	f9 bc 03 ff 	movlo	r12,-1
8000a8fe:	f9 bc 02 01 	movhs	r12,1
8000a902:	d8 02       	popm	pc
8000a904:	10 39       	cp.w	r9,r8
8000a906:	fe 9b ff f6 	brhi	8000a8f2 <__mcmp+0x18>
8000a90a:	d8 02       	popm	pc

8000a90c <_Bfree>:
8000a90c:	d4 21       	pushm	r4-r7,lr
8000a90e:	18 97       	mov	r7,r12
8000a910:	16 95       	mov	r5,r11
8000a912:	78 96       	ld.w	r6,r12[0x24]
8000a914:	58 06       	cp.w	r6,0
8000a916:	c0 91       	brne	8000a928 <_Bfree+0x1c>
8000a918:	31 0c       	mov	r12,16
8000a91a:	fe b0 de 49 	rcall	800065ac <malloc>
8000a91e:	99 36       	st.w	r12[0xc],r6
8000a920:	8f 9c       	st.w	r7[0x24],r12
8000a922:	99 16       	st.w	r12[0x4],r6
8000a924:	99 26       	st.w	r12[0x8],r6
8000a926:	99 06       	st.w	r12[0x0],r6
8000a928:	58 05       	cp.w	r5,0
8000a92a:	c0 90       	breq	8000a93c <_Bfree+0x30>
8000a92c:	6a 19       	ld.w	r9,r5[0x4]
8000a92e:	6e 98       	ld.w	r8,r7[0x24]
8000a930:	70 38       	ld.w	r8,r8[0xc]
8000a932:	f0 09 03 2a 	ld.w	r10,r8[r9<<0x2]
8000a936:	8b 0a       	st.w	r5[0x0],r10
8000a938:	f0 09 09 25 	st.w	r8[r9<<0x2],r5
8000a93c:	d8 22       	popm	r4-r7,pc
8000a93e:	d7 03       	nop

8000a940 <_Balloc>:
8000a940:	d4 21       	pushm	r4-r7,lr
8000a942:	18 97       	mov	r7,r12
8000a944:	16 96       	mov	r6,r11
8000a946:	78 95       	ld.w	r5,r12[0x24]
8000a948:	58 05       	cp.w	r5,0
8000a94a:	c0 91       	brne	8000a95c <_Balloc+0x1c>
8000a94c:	31 0c       	mov	r12,16
8000a94e:	fe b0 de 2f 	rcall	800065ac <malloc>
8000a952:	99 35       	st.w	r12[0xc],r5
8000a954:	8f 9c       	st.w	r7[0x24],r12
8000a956:	99 15       	st.w	r12[0x4],r5
8000a958:	99 25       	st.w	r12[0x8],r5
8000a95a:	99 05       	st.w	r12[0x0],r5
8000a95c:	6e 95       	ld.w	r5,r7[0x24]
8000a95e:	6a 38       	ld.w	r8,r5[0xc]
8000a960:	58 08       	cp.w	r8,0
8000a962:	c0 b1       	brne	8000a978 <_Balloc+0x38>
8000a964:	31 0a       	mov	r10,16
8000a966:	30 4b       	mov	r11,4
8000a968:	0e 9c       	mov	r12,r7
8000a96a:	e0 a0 02 a7 	rcall	8000aeb8 <_calloc_r>
8000a96e:	8b 3c       	st.w	r5[0xc],r12
8000a970:	6e 98       	ld.w	r8,r7[0x24]
8000a972:	70 3c       	ld.w	r12,r8[0xc]
8000a974:	58 0c       	cp.w	r12,0
8000a976:	c1 b0       	breq	8000a9ac <_Balloc+0x6c>
8000a978:	6e 98       	ld.w	r8,r7[0x24]
8000a97a:	70 38       	ld.w	r8,r8[0xc]
8000a97c:	f0 06 00 28 	add	r8,r8,r6<<0x2
8000a980:	70 0c       	ld.w	r12,r8[0x0]
8000a982:	58 0c       	cp.w	r12,0
8000a984:	c0 40       	breq	8000a98c <_Balloc+0x4c>
8000a986:	78 09       	ld.w	r9,r12[0x0]
8000a988:	91 09       	st.w	r8[0x0],r9
8000a98a:	c0 e8       	rjmp	8000a9a6 <_Balloc+0x66>
8000a98c:	0e 9c       	mov	r12,r7
8000a98e:	30 17       	mov	r7,1
8000a990:	0e 9b       	mov	r11,r7
8000a992:	ee 06 09 47 	lsl	r7,r7,r6
8000a996:	ee ca ff fb 	sub	r10,r7,-5
8000a99a:	a3 6a       	lsl	r10,0x2
8000a99c:	e0 a0 02 8e 	rcall	8000aeb8 <_calloc_r>
8000a9a0:	c0 60       	breq	8000a9ac <_Balloc+0x6c>
8000a9a2:	99 16       	st.w	r12[0x4],r6
8000a9a4:	99 27       	st.w	r12[0x8],r7
8000a9a6:	30 08       	mov	r8,0
8000a9a8:	99 38       	st.w	r12[0xc],r8
8000a9aa:	99 48       	st.w	r12[0x10],r8
8000a9ac:	d8 22       	popm	r4-r7,pc
8000a9ae:	d7 03       	nop

8000a9b0 <__d2b>:
8000a9b0:	d4 31       	pushm	r0-r7,lr
8000a9b2:	20 2d       	sub	sp,8
8000a9b4:	16 93       	mov	r3,r11
8000a9b6:	12 96       	mov	r6,r9
8000a9b8:	10 95       	mov	r5,r8
8000a9ba:	14 92       	mov	r2,r10
8000a9bc:	30 1b       	mov	r11,1
8000a9be:	cc 1f       	rcall	8000a940 <_Balloc>
8000a9c0:	f3 d3 c0 14 	bfextu	r9,r3,0x0,0x14
8000a9c4:	50 09       	stdsp	sp[0x0],r9
8000a9c6:	f1 d3 c0 1f 	bfextu	r8,r3,0x0,0x1f
8000a9ca:	b5 a9       	sbr	r9,0x14
8000a9cc:	f0 01 16 14 	lsr	r1,r8,0x14
8000a9d0:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000a9d4:	18 94       	mov	r4,r12
8000a9d6:	58 02       	cp.w	r2,0
8000a9d8:	c1 d0       	breq	8000aa12 <__d2b+0x62>
8000a9da:	fa cc ff f8 	sub	r12,sp,-8
8000a9de:	18 d2       	st.w	--r12,r2
8000a9e0:	c3 6f       	rcall	8000a84c <__lo0bits>
8000a9e2:	40 18       	lddsp	r8,sp[0x4]
8000a9e4:	c0 d0       	breq	8000a9fe <__d2b+0x4e>
8000a9e6:	40 09       	lddsp	r9,sp[0x0]
8000a9e8:	f8 0a 11 20 	rsub	r10,r12,32
8000a9ec:	f2 0a 09 4a 	lsl	r10,r9,r10
8000a9f0:	f5 e8 10 08 	or	r8,r10,r8
8000a9f4:	89 58       	st.w	r4[0x14],r8
8000a9f6:	f2 0c 0a 49 	lsr	r9,r9,r12
8000a9fa:	50 09       	stdsp	sp[0x0],r9
8000a9fc:	c0 28       	rjmp	8000aa00 <__d2b+0x50>
8000a9fe:	89 58       	st.w	r4[0x14],r8
8000aa00:	40 08       	lddsp	r8,sp[0x0]
8000aa02:	58 08       	cp.w	r8,0
8000aa04:	f9 b3 01 02 	movne	r3,2
8000aa08:	f9 b3 00 01 	moveq	r3,1
8000aa0c:	89 68       	st.w	r4[0x18],r8
8000aa0e:	89 43       	st.w	r4[0x10],r3
8000aa10:	c0 88       	rjmp	8000aa20 <__d2b+0x70>
8000aa12:	1a 9c       	mov	r12,sp
8000aa14:	c1 cf       	rcall	8000a84c <__lo0bits>
8000aa16:	30 13       	mov	r3,1
8000aa18:	40 08       	lddsp	r8,sp[0x0]
8000aa1a:	2e 0c       	sub	r12,-32
8000aa1c:	89 43       	st.w	r4[0x10],r3
8000aa1e:	89 58       	st.w	r4[0x14],r8
8000aa20:	58 01       	cp.w	r1,0
8000aa22:	c0 90       	breq	8000aa34 <__d2b+0x84>
8000aa24:	e2 c1 04 33 	sub	r1,r1,1075
8000aa28:	18 01       	add	r1,r12
8000aa2a:	8d 01       	st.w	r6[0x0],r1
8000aa2c:	f8 0c 11 35 	rsub	r12,r12,53
8000aa30:	8b 0c       	st.w	r5[0x0],r12
8000aa32:	c0 c8       	rjmp	8000aa4a <__d2b+0x9a>
8000aa34:	e6 c8 ff fc 	sub	r8,r3,-4
8000aa38:	f8 cc 04 32 	sub	r12,r12,1074
8000aa3c:	a5 73       	lsl	r3,0x5
8000aa3e:	8d 0c       	st.w	r6[0x0],r12
8000aa40:	e8 08 03 2c 	ld.w	r12,r4[r8<<0x2]
8000aa44:	cd 4e       	rcall	8000a7ec <__hi0bits>
8000aa46:	18 13       	sub	r3,r12
8000aa48:	8b 03       	st.w	r5[0x0],r3
8000aa4a:	08 9c       	mov	r12,r4
8000aa4c:	2f ed       	sub	sp,-8
8000aa4e:	d8 32       	popm	r0-r7,pc

8000aa50 <__mdiff>:
8000aa50:	d4 31       	pushm	r0-r7,lr
8000aa52:	74 48       	ld.w	r8,r10[0x10]
8000aa54:	76 45       	ld.w	r5,r11[0x10]
8000aa56:	16 97       	mov	r7,r11
8000aa58:	14 96       	mov	r6,r10
8000aa5a:	10 15       	sub	r5,r8
8000aa5c:	c1 31       	brne	8000aa82 <__mdiff+0x32>
8000aa5e:	2f b8       	sub	r8,-5
8000aa60:	ee ce ff ec 	sub	lr,r7,-20
8000aa64:	a3 68       	lsl	r8,0x2
8000aa66:	f4 08 00 0b 	add	r11,r10,r8
8000aa6a:	ee 08 00 08 	add	r8,r7,r8
8000aa6e:	11 4a       	ld.w	r10,--r8
8000aa70:	17 49       	ld.w	r9,--r11
8000aa72:	12 3a       	cp.w	r10,r9
8000aa74:	c0 30       	breq	8000aa7a <__mdiff+0x2a>
8000aa76:	c0 e2       	brcc	8000aa92 <__mdiff+0x42>
8000aa78:	c0 78       	rjmp	8000aa86 <__mdiff+0x36>
8000aa7a:	1c 38       	cp.w	r8,lr
8000aa7c:	fe 9b ff f9 	brhi	8000aa6e <__mdiff+0x1e>
8000aa80:	c4 98       	rjmp	8000ab12 <__mdiff+0xc2>
8000aa82:	58 05       	cp.w	r5,0
8000aa84:	c0 64       	brge	8000aa90 <__mdiff+0x40>
8000aa86:	0e 98       	mov	r8,r7
8000aa88:	30 15       	mov	r5,1
8000aa8a:	0c 97       	mov	r7,r6
8000aa8c:	10 96       	mov	r6,r8
8000aa8e:	c0 28       	rjmp	8000aa92 <__mdiff+0x42>
8000aa90:	30 05       	mov	r5,0
8000aa92:	6e 1b       	ld.w	r11,r7[0x4]
8000aa94:	c5 6f       	rcall	8000a940 <_Balloc>
8000aa96:	6e 49       	ld.w	r9,r7[0x10]
8000aa98:	6c 44       	ld.w	r4,r6[0x10]
8000aa9a:	99 35       	st.w	r12[0xc],r5
8000aa9c:	2f b4       	sub	r4,-5
8000aa9e:	f2 c5 ff fb 	sub	r5,r9,-5
8000aaa2:	ec 04 00 24 	add	r4,r6,r4<<0x2
8000aaa6:	ee 05 00 25 	add	r5,r7,r5<<0x2
8000aaaa:	2e c6       	sub	r6,-20
8000aaac:	2e c7       	sub	r7,-20
8000aaae:	f8 c8 ff ec 	sub	r8,r12,-20
8000aab2:	30 0a       	mov	r10,0
8000aab4:	0f 0e       	ld.w	lr,r7++
8000aab6:	0d 0b       	ld.w	r11,r6++
8000aab8:	fc 02 16 10 	lsr	r2,lr,0x10
8000aabc:	f6 03 16 10 	lsr	r3,r11,0x10
8000aac0:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000aac4:	e4 03 01 03 	sub	r3,r2,r3
8000aac8:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000aacc:	fc 0b 01 0b 	sub	r11,lr,r11
8000aad0:	f6 0a 00 0a 	add	r10,r11,r10
8000aad4:	b0 1a       	st.h	r8[0x2],r10
8000aad6:	b1 4a       	asr	r10,0x10
8000aad8:	e6 0a 00 0a 	add	r10,r3,r10
8000aadc:	b0 0a       	st.h	r8[0x0],r10
8000aade:	2f c8       	sub	r8,-4
8000aae0:	b1 4a       	asr	r10,0x10
8000aae2:	08 36       	cp.w	r6,r4
8000aae4:	ce 83       	brcs	8000aab4 <__mdiff+0x64>
8000aae6:	c0 d8       	rjmp	8000ab00 <__mdiff+0xb0>
8000aae8:	0f 0b       	ld.w	r11,r7++
8000aaea:	f6 0e 16 10 	lsr	lr,r11,0x10
8000aaee:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000aaf2:	16 0a       	add	r10,r11
8000aaf4:	b0 1a       	st.h	r8[0x2],r10
8000aaf6:	b1 4a       	asr	r10,0x10
8000aaf8:	1c 0a       	add	r10,lr
8000aafa:	b0 0a       	st.h	r8[0x0],r10
8000aafc:	2f c8       	sub	r8,-4
8000aafe:	b1 4a       	asr	r10,0x10
8000ab00:	0a 37       	cp.w	r7,r5
8000ab02:	cf 33       	brcs	8000aae8 <__mdiff+0x98>
8000ab04:	c0 28       	rjmp	8000ab08 <__mdiff+0xb8>
8000ab06:	20 19       	sub	r9,1
8000ab08:	11 4a       	ld.w	r10,--r8
8000ab0a:	58 0a       	cp.w	r10,0
8000ab0c:	cf d0       	breq	8000ab06 <__mdiff+0xb6>
8000ab0e:	99 49       	st.w	r12[0x10],r9
8000ab10:	d8 32       	popm	r0-r7,pc
8000ab12:	30 0b       	mov	r11,0
8000ab14:	c1 6f       	rcall	8000a940 <_Balloc>
8000ab16:	30 18       	mov	r8,1
8000ab18:	99 48       	st.w	r12[0x10],r8
8000ab1a:	30 08       	mov	r8,0
8000ab1c:	99 58       	st.w	r12[0x14],r8
8000ab1e:	d8 32       	popm	r0-r7,pc

8000ab20 <__lshift>:
8000ab20:	d4 31       	pushm	r0-r7,lr
8000ab22:	16 97       	mov	r7,r11
8000ab24:	76 46       	ld.w	r6,r11[0x10]
8000ab26:	f4 02 14 05 	asr	r2,r10,0x5
8000ab2a:	2f f6       	sub	r6,-1
8000ab2c:	14 93       	mov	r3,r10
8000ab2e:	18 94       	mov	r4,r12
8000ab30:	04 06       	add	r6,r2
8000ab32:	76 1b       	ld.w	r11,r11[0x4]
8000ab34:	6e 28       	ld.w	r8,r7[0x8]
8000ab36:	c0 38       	rjmp	8000ab3c <__lshift+0x1c>
8000ab38:	2f fb       	sub	r11,-1
8000ab3a:	a1 78       	lsl	r8,0x1
8000ab3c:	10 36       	cp.w	r6,r8
8000ab3e:	fe 99 ff fd 	brgt	8000ab38 <__lshift+0x18>
8000ab42:	08 9c       	mov	r12,r4
8000ab44:	cf ee       	rcall	8000a940 <_Balloc>
8000ab46:	30 09       	mov	r9,0
8000ab48:	18 95       	mov	r5,r12
8000ab4a:	f8 c8 ff ec 	sub	r8,r12,-20
8000ab4e:	12 9a       	mov	r10,r9
8000ab50:	c0 38       	rjmp	8000ab56 <__lshift+0x36>
8000ab52:	10 aa       	st.w	r8++,r10
8000ab54:	2f f9       	sub	r9,-1
8000ab56:	04 39       	cp.w	r9,r2
8000ab58:	cf d5       	brlt	8000ab52 <__lshift+0x32>
8000ab5a:	6e 4b       	ld.w	r11,r7[0x10]
8000ab5c:	e7 d3 c0 05 	bfextu	r3,r3,0x0,0x5
8000ab60:	2f bb       	sub	r11,-5
8000ab62:	ee c9 ff ec 	sub	r9,r7,-20
8000ab66:	ee 0b 00 2b 	add	r11,r7,r11<<0x2
8000ab6a:	58 03       	cp.w	r3,0
8000ab6c:	c1 30       	breq	8000ab92 <__lshift+0x72>
8000ab6e:	e6 0c 11 20 	rsub	r12,r3,32
8000ab72:	30 0a       	mov	r10,0
8000ab74:	72 02       	ld.w	r2,r9[0x0]
8000ab76:	e4 03 09 42 	lsl	r2,r2,r3
8000ab7a:	04 4a       	or	r10,r2
8000ab7c:	10 aa       	st.w	r8++,r10
8000ab7e:	13 0a       	ld.w	r10,r9++
8000ab80:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000ab84:	16 39       	cp.w	r9,r11
8000ab86:	cf 73       	brcs	8000ab74 <__lshift+0x54>
8000ab88:	91 0a       	st.w	r8[0x0],r10
8000ab8a:	58 0a       	cp.w	r10,0
8000ab8c:	c0 70       	breq	8000ab9a <__lshift+0x7a>
8000ab8e:	2f f6       	sub	r6,-1
8000ab90:	c0 58       	rjmp	8000ab9a <__lshift+0x7a>
8000ab92:	13 0a       	ld.w	r10,r9++
8000ab94:	10 aa       	st.w	r8++,r10
8000ab96:	16 39       	cp.w	r9,r11
8000ab98:	cf d3       	brcs	8000ab92 <__lshift+0x72>
8000ab9a:	08 9c       	mov	r12,r4
8000ab9c:	20 16       	sub	r6,1
8000ab9e:	0e 9b       	mov	r11,r7
8000aba0:	8b 46       	st.w	r5[0x10],r6
8000aba2:	cb 5e       	rcall	8000a90c <_Bfree>
8000aba4:	0a 9c       	mov	r12,r5
8000aba6:	d8 32       	popm	r0-r7,pc

8000aba8 <__multiply>:
8000aba8:	d4 31       	pushm	r0-r7,lr
8000abaa:	20 2d       	sub	sp,8
8000abac:	76 49       	ld.w	r9,r11[0x10]
8000abae:	74 48       	ld.w	r8,r10[0x10]
8000abb0:	16 96       	mov	r6,r11
8000abb2:	14 95       	mov	r5,r10
8000abb4:	10 39       	cp.w	r9,r8
8000abb6:	ec 08 17 50 	movlt	r8,r6
8000abba:	ea 06 17 50 	movlt	r6,r5
8000abbe:	f0 05 17 50 	movlt	r5,r8
8000abc2:	6c 28       	ld.w	r8,r6[0x8]
8000abc4:	76 43       	ld.w	r3,r11[0x10]
8000abc6:	74 42       	ld.w	r2,r10[0x10]
8000abc8:	76 1b       	ld.w	r11,r11[0x4]
8000abca:	e4 03 00 07 	add	r7,r2,r3
8000abce:	10 37       	cp.w	r7,r8
8000abd0:	f7 bb 09 ff 	subgt	r11,-1
8000abd4:	cb 6e       	rcall	8000a940 <_Balloc>
8000abd6:	ee c4 ff fb 	sub	r4,r7,-5
8000abda:	f8 c9 ff ec 	sub	r9,r12,-20
8000abde:	f8 04 00 24 	add	r4,r12,r4<<0x2
8000abe2:	30 0a       	mov	r10,0
8000abe4:	12 98       	mov	r8,r9
8000abe6:	c0 28       	rjmp	8000abea <__multiply+0x42>
8000abe8:	10 aa       	st.w	r8++,r10
8000abea:	08 38       	cp.w	r8,r4
8000abec:	cf e3       	brcs	8000abe8 <__multiply+0x40>
8000abee:	2f b3       	sub	r3,-5
8000abf0:	2f b2       	sub	r2,-5
8000abf2:	ec 03 00 23 	add	r3,r6,r3<<0x2
8000abf6:	ea 02 00 22 	add	r2,r5,r2<<0x2
8000abfa:	ec cb ff ec 	sub	r11,r6,-20
8000abfe:	50 12       	stdsp	sp[0x4],r2
8000ac00:	ea ca ff ec 	sub	r10,r5,-20
8000ac04:	c4 48       	rjmp	8000ac8c <__multiply+0xe4>
8000ac06:	94 95       	ld.uh	r5,r10[0x2]
8000ac08:	58 05       	cp.w	r5,0
8000ac0a:	c2 00       	breq	8000ac4a <__multiply+0xa2>
8000ac0c:	12 98       	mov	r8,r9
8000ac0e:	16 96       	mov	r6,r11
8000ac10:	30 0e       	mov	lr,0
8000ac12:	50 09       	stdsp	sp[0x0],r9
8000ac14:	0d 02       	ld.w	r2,r6++
8000ac16:	e4 00 16 10 	lsr	r0,r2,0x10
8000ac1a:	70 01       	ld.w	r1,r8[0x0]
8000ac1c:	70 09       	ld.w	r9,r8[0x0]
8000ac1e:	b1 81       	lsr	r1,0x10
8000ac20:	e5 d2 c0 10 	bfextu	r2,r2,0x0,0x10
8000ac24:	e0 05 03 41 	mac	r1,r0,r5
8000ac28:	ab 32       	mul	r2,r5
8000ac2a:	e1 d9 c0 10 	bfextu	r0,r9,0x0,0x10
8000ac2e:	00 02       	add	r2,r0
8000ac30:	e4 0e 00 0e 	add	lr,r2,lr
8000ac34:	b0 1e       	st.h	r8[0x2],lr
8000ac36:	b1 8e       	lsr	lr,0x10
8000ac38:	1c 01       	add	r1,lr
8000ac3a:	b0 01       	st.h	r8[0x0],r1
8000ac3c:	e2 0e 16 10 	lsr	lr,r1,0x10
8000ac40:	2f c8       	sub	r8,-4
8000ac42:	06 36       	cp.w	r6,r3
8000ac44:	ce 83       	brcs	8000ac14 <__multiply+0x6c>
8000ac46:	40 09       	lddsp	r9,sp[0x0]
8000ac48:	91 0e       	st.w	r8[0x0],lr
8000ac4a:	94 86       	ld.uh	r6,r10[0x0]
8000ac4c:	58 06       	cp.w	r6,0
8000ac4e:	c1 d0       	breq	8000ac88 <__multiply+0xe0>
8000ac50:	72 02       	ld.w	r2,r9[0x0]
8000ac52:	12 98       	mov	r8,r9
8000ac54:	16 9e       	mov	lr,r11
8000ac56:	30 05       	mov	r5,0
8000ac58:	b0 12       	st.h	r8[0x2],r2
8000ac5a:	1d 01       	ld.w	r1,lr++
8000ac5c:	90 82       	ld.uh	r2,r8[0x0]
8000ac5e:	e1 d1 c0 10 	bfextu	r0,r1,0x0,0x10
8000ac62:	ad 30       	mul	r0,r6
8000ac64:	e0 02 00 02 	add	r2,r0,r2
8000ac68:	e4 05 00 05 	add	r5,r2,r5
8000ac6c:	b0 05       	st.h	r8[0x0],r5
8000ac6e:	b1 85       	lsr	r5,0x10
8000ac70:	b1 81       	lsr	r1,0x10
8000ac72:	2f c8       	sub	r8,-4
8000ac74:	ad 31       	mul	r1,r6
8000ac76:	90 92       	ld.uh	r2,r8[0x2]
8000ac78:	e2 02 00 02 	add	r2,r1,r2
8000ac7c:	0a 02       	add	r2,r5
8000ac7e:	e4 05 16 10 	lsr	r5,r2,0x10
8000ac82:	06 3e       	cp.w	lr,r3
8000ac84:	ce a3       	brcs	8000ac58 <__multiply+0xb0>
8000ac86:	91 02       	st.w	r8[0x0],r2
8000ac88:	2f ca       	sub	r10,-4
8000ac8a:	2f c9       	sub	r9,-4
8000ac8c:	40 18       	lddsp	r8,sp[0x4]
8000ac8e:	10 3a       	cp.w	r10,r8
8000ac90:	cb b3       	brcs	8000ac06 <__multiply+0x5e>
8000ac92:	c0 28       	rjmp	8000ac96 <__multiply+0xee>
8000ac94:	20 17       	sub	r7,1
8000ac96:	58 07       	cp.w	r7,0
8000ac98:	e0 8a 00 05 	brle	8000aca2 <__multiply+0xfa>
8000ac9c:	09 48       	ld.w	r8,--r4
8000ac9e:	58 08       	cp.w	r8,0
8000aca0:	cf a0       	breq	8000ac94 <__multiply+0xec>
8000aca2:	99 47       	st.w	r12[0x10],r7
8000aca4:	2f ed       	sub	sp,-8
8000aca6:	d8 32       	popm	r0-r7,pc

8000aca8 <__i2b>:
8000aca8:	d4 21       	pushm	r4-r7,lr
8000acaa:	16 97       	mov	r7,r11
8000acac:	30 1b       	mov	r11,1
8000acae:	c4 9e       	rcall	8000a940 <_Balloc>
8000acb0:	30 19       	mov	r9,1
8000acb2:	99 57       	st.w	r12[0x14],r7
8000acb4:	99 49       	st.w	r12[0x10],r9
8000acb6:	d8 22       	popm	r4-r7,pc

8000acb8 <__multadd>:
8000acb8:	d4 31       	pushm	r0-r7,lr
8000acba:	30 08       	mov	r8,0
8000acbc:	12 95       	mov	r5,r9
8000acbe:	16 97       	mov	r7,r11
8000acc0:	18 96       	mov	r6,r12
8000acc2:	76 44       	ld.w	r4,r11[0x10]
8000acc4:	f6 c9 ff ec 	sub	r9,r11,-20
8000acc8:	72 0b       	ld.w	r11,r9[0x0]
8000acca:	f6 0c 16 10 	lsr	r12,r11,0x10
8000acce:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000acd2:	f4 0c 02 4c 	mul	r12,r10,r12
8000acd6:	f4 0b 03 45 	mac	r5,r10,r11
8000acda:	f7 d5 c0 10 	bfextu	r11,r5,0x0,0x10
8000acde:	b1 85       	lsr	r5,0x10
8000ace0:	18 05       	add	r5,r12
8000ace2:	ea 0c 15 10 	lsl	r12,r5,0x10
8000ace6:	f8 0b 00 0b 	add	r11,r12,r11
8000acea:	12 ab       	st.w	r9++,r11
8000acec:	2f f8       	sub	r8,-1
8000acee:	b1 85       	lsr	r5,0x10
8000acf0:	08 38       	cp.w	r8,r4
8000acf2:	ce b5       	brlt	8000acc8 <__multadd+0x10>
8000acf4:	58 05       	cp.w	r5,0
8000acf6:	c1 c0       	breq	8000ad2e <__multadd+0x76>
8000acf8:	6e 28       	ld.w	r8,r7[0x8]
8000acfa:	10 34       	cp.w	r4,r8
8000acfc:	c1 35       	brlt	8000ad22 <__multadd+0x6a>
8000acfe:	6e 1b       	ld.w	r11,r7[0x4]
8000ad00:	0c 9c       	mov	r12,r6
8000ad02:	2f fb       	sub	r11,-1
8000ad04:	c1 ee       	rcall	8000a940 <_Balloc>
8000ad06:	6e 4a       	ld.w	r10,r7[0x10]
8000ad08:	ee cb ff f4 	sub	r11,r7,-12
8000ad0c:	18 93       	mov	r3,r12
8000ad0e:	2f ea       	sub	r10,-2
8000ad10:	2f 4c       	sub	r12,-12
8000ad12:	a3 6a       	lsl	r10,0x2
8000ad14:	fe b0 de 70 	rcall	800069f4 <memcpy>
8000ad18:	0e 9b       	mov	r11,r7
8000ad1a:	0c 9c       	mov	r12,r6
8000ad1c:	fe b0 fd f8 	rcall	8000a90c <_Bfree>
8000ad20:	06 97       	mov	r7,r3
8000ad22:	e8 c8 ff ff 	sub	r8,r4,-1
8000ad26:	2f b4       	sub	r4,-5
8000ad28:	8f 48       	st.w	r7[0x10],r8
8000ad2a:	ee 04 09 25 	st.w	r7[r4<<0x2],r5
8000ad2e:	0e 9c       	mov	r12,r7
8000ad30:	d8 32       	popm	r0-r7,pc
8000ad32:	d7 03       	nop

8000ad34 <__pow5mult>:
8000ad34:	d4 31       	pushm	r0-r7,lr
8000ad36:	14 96       	mov	r6,r10
8000ad38:	18 97       	mov	r7,r12
8000ad3a:	16 94       	mov	r4,r11
8000ad3c:	f1 da c0 02 	bfextu	r8,r10,0x0,0x2
8000ad40:	c0 90       	breq	8000ad52 <__pow5mult+0x1e>
8000ad42:	20 18       	sub	r8,1
8000ad44:	fe c9 db 1c 	sub	r9,pc,-9444
8000ad48:	f2 08 03 2a 	ld.w	r10,r9[r8<<0x2]
8000ad4c:	30 09       	mov	r9,0
8000ad4e:	cb 5f       	rcall	8000acb8 <__multadd>
8000ad50:	18 94       	mov	r4,r12
8000ad52:	a3 46       	asr	r6,0x2
8000ad54:	c3 40       	breq	8000adbc <__pow5mult+0x88>
8000ad56:	6e 95       	ld.w	r5,r7[0x24]
8000ad58:	58 05       	cp.w	r5,0
8000ad5a:	c0 91       	brne	8000ad6c <__pow5mult+0x38>
8000ad5c:	31 0c       	mov	r12,16
8000ad5e:	fe b0 dc 27 	rcall	800065ac <malloc>
8000ad62:	99 35       	st.w	r12[0xc],r5
8000ad64:	8f 9c       	st.w	r7[0x24],r12
8000ad66:	99 15       	st.w	r12[0x4],r5
8000ad68:	99 25       	st.w	r12[0x8],r5
8000ad6a:	99 05       	st.w	r12[0x0],r5
8000ad6c:	6e 93       	ld.w	r3,r7[0x24]
8000ad6e:	66 25       	ld.w	r5,r3[0x8]
8000ad70:	58 05       	cp.w	r5,0
8000ad72:	c0 c1       	brne	8000ad8a <__pow5mult+0x56>
8000ad74:	e0 6b 02 71 	mov	r11,625
8000ad78:	0e 9c       	mov	r12,r7
8000ad7a:	c9 7f       	rcall	8000aca8 <__i2b>
8000ad7c:	87 2c       	st.w	r3[0x8],r12
8000ad7e:	30 08       	mov	r8,0
8000ad80:	18 95       	mov	r5,r12
8000ad82:	99 08       	st.w	r12[0x0],r8
8000ad84:	c0 38       	rjmp	8000ad8a <__pow5mult+0x56>
8000ad86:	06 9c       	mov	r12,r3
8000ad88:	18 95       	mov	r5,r12
8000ad8a:	ed b6 00 00 	bld	r6,0x0
8000ad8e:	c0 b1       	brne	8000ada4 <__pow5mult+0x70>
8000ad90:	08 9b       	mov	r11,r4
8000ad92:	0a 9a       	mov	r10,r5
8000ad94:	0e 9c       	mov	r12,r7
8000ad96:	c0 9f       	rcall	8000aba8 <__multiply>
8000ad98:	08 9b       	mov	r11,r4
8000ad9a:	18 93       	mov	r3,r12
8000ad9c:	0e 9c       	mov	r12,r7
8000ad9e:	06 94       	mov	r4,r3
8000ada0:	fe b0 fd b6 	rcall	8000a90c <_Bfree>
8000ada4:	a1 56       	asr	r6,0x1
8000ada6:	c0 b0       	breq	8000adbc <__pow5mult+0x88>
8000ada8:	6a 03       	ld.w	r3,r5[0x0]
8000adaa:	58 03       	cp.w	r3,0
8000adac:	ce d1       	brne	8000ad86 <__pow5mult+0x52>
8000adae:	0a 9a       	mov	r10,r5
8000adb0:	0a 9b       	mov	r11,r5
8000adb2:	0e 9c       	mov	r12,r7
8000adb4:	cf ae       	rcall	8000aba8 <__multiply>
8000adb6:	8b 0c       	st.w	r5[0x0],r12
8000adb8:	99 03       	st.w	r12[0x0],r3
8000adba:	ce 7b       	rjmp	8000ad88 <__pow5mult+0x54>
8000adbc:	08 9c       	mov	r12,r4
8000adbe:	d8 32       	popm	r0-r7,pc

8000adc0 <__isinfd>:
8000adc0:	14 98       	mov	r8,r10
8000adc2:	fc 19 7f f0 	movh	r9,0x7ff0
8000adc6:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000adca:	f0 0b 11 00 	rsub	r11,r8,0
8000adce:	f7 e8 10 08 	or	r8,r11,r8
8000add2:	f5 e8 13 f8 	or	r8,r10,r8>>0x1f
8000add6:	f2 08 01 08 	sub	r8,r9,r8
8000adda:	f0 0c 11 00 	rsub	r12,r8,0
8000adde:	f9 e8 10 08 	or	r8,r12,r8
8000ade2:	f0 0c 14 1f 	asr	r12,r8,0x1f
8000ade6:	2f fc       	sub	r12,-1
8000ade8:	5e fc       	retal	r12

8000adea <__isnand>:
8000adea:	14 98       	mov	r8,r10
8000adec:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000adf0:	f0 0c 11 00 	rsub	r12,r8,0
8000adf4:	10 4c       	or	r12,r8
8000adf6:	fc 18 7f f0 	movh	r8,0x7ff0
8000adfa:	f5 ec 13 fc 	or	r12,r10,r12>>0x1f
8000adfe:	f0 0c 01 0c 	sub	r12,r8,r12
8000ae02:	bf 9c       	lsr	r12,0x1f
8000ae04:	5e fc       	retal	r12
8000ae06:	d7 03       	nop

8000ae08 <__sclose>:
8000ae08:	d4 01       	pushm	lr
8000ae0a:	96 7b       	ld.sh	r11,r11[0xe]
8000ae0c:	c8 2c       	rcall	8000af10 <_close_r>
8000ae0e:	d8 02       	popm	pc

8000ae10 <__sseek>:
8000ae10:	d4 21       	pushm	r4-r7,lr
8000ae12:	16 97       	mov	r7,r11
8000ae14:	96 7b       	ld.sh	r11,r11[0xe]
8000ae16:	c0 3d       	rcall	8000b01c <_lseek_r>
8000ae18:	8e 68       	ld.sh	r8,r7[0xc]
8000ae1a:	10 99       	mov	r9,r8
8000ae1c:	ad c8       	cbr	r8,0xc
8000ae1e:	ad a9       	sbr	r9,0xc
8000ae20:	5b fc       	cp.w	r12,-1
8000ae22:	ef f8 0c 06 	st.heq	r7[0xc],r8
8000ae26:	ef f9 1c 06 	st.hne	r7[0xc],r9
8000ae2a:	ef fc 1a 15 	st.wne	r7[0x54],r12
8000ae2e:	d8 22       	popm	r4-r7,pc

8000ae30 <__swrite>:
8000ae30:	d4 21       	pushm	r4-r7,lr
8000ae32:	96 68       	ld.sh	r8,r11[0xc]
8000ae34:	16 97       	mov	r7,r11
8000ae36:	14 95       	mov	r5,r10
8000ae38:	12 94       	mov	r4,r9
8000ae3a:	e2 18 01 00 	andl	r8,0x100,COH
8000ae3e:	18 96       	mov	r6,r12
8000ae40:	c0 50       	breq	8000ae4a <__swrite+0x1a>
8000ae42:	30 29       	mov	r9,2
8000ae44:	30 0a       	mov	r10,0
8000ae46:	96 7b       	ld.sh	r11,r11[0xe]
8000ae48:	ce ac       	rcall	8000b01c <_lseek_r>
8000ae4a:	8e 68       	ld.sh	r8,r7[0xc]
8000ae4c:	ad c8       	cbr	r8,0xc
8000ae4e:	08 99       	mov	r9,r4
8000ae50:	0a 9a       	mov	r10,r5
8000ae52:	8e 7b       	ld.sh	r11,r7[0xe]
8000ae54:	0c 9c       	mov	r12,r6
8000ae56:	ae 68       	st.h	r7[0xc],r8
8000ae58:	c1 cc       	rcall	8000ae90 <_write_r>
8000ae5a:	d8 22       	popm	r4-r7,pc

8000ae5c <__sread>:
8000ae5c:	d4 21       	pushm	r4-r7,lr
8000ae5e:	16 97       	mov	r7,r11
8000ae60:	96 7b       	ld.sh	r11,r11[0xe]
8000ae62:	cf 1c       	rcall	8000b044 <_read_r>
8000ae64:	c0 65       	brlt	8000ae70 <__sread+0x14>
8000ae66:	6f 58       	ld.w	r8,r7[0x54]
8000ae68:	18 08       	add	r8,r12
8000ae6a:	ef 48 00 54 	st.w	r7[84],r8
8000ae6e:	d8 22       	popm	r4-r7,pc
8000ae70:	8e 68       	ld.sh	r8,r7[0xc]
8000ae72:	ad c8       	cbr	r8,0xc
8000ae74:	ae 68       	st.h	r7[0xc],r8
8000ae76:	d8 22       	popm	r4-r7,pc

8000ae78 <strlen>:
8000ae78:	30 09       	mov	r9,0
8000ae7a:	18 98       	mov	r8,r12
8000ae7c:	c0 28       	rjmp	8000ae80 <strlen+0x8>
8000ae7e:	2f f8       	sub	r8,-1
8000ae80:	11 8a       	ld.ub	r10,r8[0x0]
8000ae82:	f2 0a 18 00 	cp.b	r10,r9
8000ae86:	cf c1       	brne	8000ae7e <strlen+0x6>
8000ae88:	f0 0c 01 0c 	sub	r12,r8,r12
8000ae8c:	5e fc       	retal	r12
8000ae8e:	d7 03       	nop

8000ae90 <_write_r>:
8000ae90:	d4 21       	pushm	r4-r7,lr
8000ae92:	16 98       	mov	r8,r11
8000ae94:	18 97       	mov	r7,r12
8000ae96:	10 9c       	mov	r12,r8
8000ae98:	30 08       	mov	r8,0
8000ae9a:	14 9b       	mov	r11,r10
8000ae9c:	e0 66 41 0c 	mov	r6,16652
8000aea0:	12 9a       	mov	r10,r9
8000aea2:	8d 08       	st.w	r6[0x0],r8
8000aea4:	fe b0 d1 ba 	rcall	80005218 <_write>
8000aea8:	5b fc       	cp.w	r12,-1
8000aeaa:	c0 51       	brne	8000aeb4 <_write_r+0x24>
8000aeac:	6c 08       	ld.w	r8,r6[0x0]
8000aeae:	58 08       	cp.w	r8,0
8000aeb0:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000aeb4:	d8 22       	popm	r4-r7,pc
8000aeb6:	d7 03       	nop

8000aeb8 <_calloc_r>:
8000aeb8:	d4 21       	pushm	r4-r7,lr
8000aeba:	f4 0b 02 4b 	mul	r11,r10,r11
8000aebe:	fe b0 db 7f 	rcall	800065bc <_malloc_r>
8000aec2:	18 97       	mov	r7,r12
8000aec4:	c2 30       	breq	8000af0a <_calloc_r+0x52>
8000aec6:	f8 fa ff fc 	ld.w	r10,r12[-4]
8000aeca:	e0 1a ff fc 	andl	r10,0xfffc
8000aece:	20 4a       	sub	r10,4
8000aed0:	e0 4a 00 24 	cp.w	r10,36
8000aed4:	e0 8b 00 18 	brhi	8000af04 <_calloc_r+0x4c>
8000aed8:	18 98       	mov	r8,r12
8000aeda:	59 3a       	cp.w	r10,19
8000aedc:	e0 88 00 0f 	brls	8000aefa <_calloc_r+0x42>
8000aee0:	30 09       	mov	r9,0
8000aee2:	10 a9       	st.w	r8++,r9
8000aee4:	10 a9       	st.w	r8++,r9
8000aee6:	59 ba       	cp.w	r10,27
8000aee8:	e0 88 00 09 	brls	8000aefa <_calloc_r+0x42>
8000aeec:	10 a9       	st.w	r8++,r9
8000aeee:	10 a9       	st.w	r8++,r9
8000aef0:	e0 4a 00 24 	cp.w	r10,36
8000aef4:	c0 31       	brne	8000aefa <_calloc_r+0x42>
8000aef6:	10 a9       	st.w	r8++,r9
8000aef8:	10 a9       	st.w	r8++,r9
8000aefa:	30 09       	mov	r9,0
8000aefc:	10 a9       	st.w	r8++,r9
8000aefe:	91 19       	st.w	r8[0x4],r9
8000af00:	91 09       	st.w	r8[0x0],r9
8000af02:	c0 48       	rjmp	8000af0a <_calloc_r+0x52>
8000af04:	30 0b       	mov	r11,0
8000af06:	fe b0 de 1b 	rcall	80006b3c <memset>
8000af0a:	0e 9c       	mov	r12,r7
8000af0c:	d8 22       	popm	r4-r7,pc
8000af0e:	d7 03       	nop

8000af10 <_close_r>:
8000af10:	d4 21       	pushm	r4-r7,lr
8000af12:	30 08       	mov	r8,0
8000af14:	18 97       	mov	r7,r12
8000af16:	e0 66 41 0c 	mov	r6,16652
8000af1a:	16 9c       	mov	r12,r11
8000af1c:	8d 08       	st.w	r6[0x0],r8
8000af1e:	fe b0 df b5 	rcall	80006e88 <_close>
8000af22:	5b fc       	cp.w	r12,-1
8000af24:	c0 51       	brne	8000af2e <_close_r+0x1e>
8000af26:	6c 08       	ld.w	r8,r6[0x0]
8000af28:	58 08       	cp.w	r8,0
8000af2a:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000af2e:	d8 22       	popm	r4-r7,pc

8000af30 <_fclose_r>:
8000af30:	d4 21       	pushm	r4-r7,lr
8000af32:	18 96       	mov	r6,r12
8000af34:	16 97       	mov	r7,r11
8000af36:	58 0b       	cp.w	r11,0
8000af38:	c0 31       	brne	8000af3e <_fclose_r+0xe>
8000af3a:	16 95       	mov	r5,r11
8000af3c:	c5 38       	rjmp	8000afe2 <_fclose_r+0xb2>
8000af3e:	fe b0 f8 a9 	rcall	8000a090 <__sfp_lock_acquire>
8000af42:	58 06       	cp.w	r6,0
8000af44:	c0 70       	breq	8000af52 <_fclose_r+0x22>
8000af46:	6c 68       	ld.w	r8,r6[0x18]
8000af48:	58 08       	cp.w	r8,0
8000af4a:	c0 41       	brne	8000af52 <_fclose_r+0x22>
8000af4c:	0c 9c       	mov	r12,r6
8000af4e:	fe b0 f8 f3 	rcall	8000a134 <__sinit>
8000af52:	fe c8 dd ce 	sub	r8,pc,-8754
8000af56:	10 37       	cp.w	r7,r8
8000af58:	c0 31       	brne	8000af5e <_fclose_r+0x2e>
8000af5a:	6c 07       	ld.w	r7,r6[0x0]
8000af5c:	c0 c8       	rjmp	8000af74 <_fclose_r+0x44>
8000af5e:	fe c8 dd ba 	sub	r8,pc,-8774
8000af62:	10 37       	cp.w	r7,r8
8000af64:	c0 31       	brne	8000af6a <_fclose_r+0x3a>
8000af66:	6c 17       	ld.w	r7,r6[0x4]
8000af68:	c0 68       	rjmp	8000af74 <_fclose_r+0x44>
8000af6a:	fe c8 dd a6 	sub	r8,pc,-8794
8000af6e:	10 37       	cp.w	r7,r8
8000af70:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000af74:	8e 69       	ld.sh	r9,r7[0xc]
8000af76:	30 08       	mov	r8,0
8000af78:	f0 09 19 00 	cp.h	r9,r8
8000af7c:	c0 51       	brne	8000af86 <_fclose_r+0x56>
8000af7e:	fe b0 f8 8a 	rcall	8000a092 <__sfp_lock_release>
8000af82:	30 05       	mov	r5,0
8000af84:	c2 f8       	rjmp	8000afe2 <_fclose_r+0xb2>
8000af86:	0e 9b       	mov	r11,r7
8000af88:	0c 9c       	mov	r12,r6
8000af8a:	fe b0 f7 fd 	rcall	80009f84 <_fflush_r>
8000af8e:	6e c8       	ld.w	r8,r7[0x30]
8000af90:	18 95       	mov	r5,r12
8000af92:	58 08       	cp.w	r8,0
8000af94:	c0 60       	breq	8000afa0 <_fclose_r+0x70>
8000af96:	6e 8b       	ld.w	r11,r7[0x20]
8000af98:	0c 9c       	mov	r12,r6
8000af9a:	5d 18       	icall	r8
8000af9c:	f9 b5 05 ff 	movlt	r5,-1
8000afa0:	8e 68       	ld.sh	r8,r7[0xc]
8000afa2:	ed b8 00 07 	bld	r8,0x7
8000afa6:	c0 51       	brne	8000afb0 <_fclose_r+0x80>
8000afa8:	6e 4b       	ld.w	r11,r7[0x10]
8000afaa:	0c 9c       	mov	r12,r6
8000afac:	fe b0 f9 5e 	rcall	8000a268 <_free_r>
8000afb0:	6e db       	ld.w	r11,r7[0x34]
8000afb2:	58 0b       	cp.w	r11,0
8000afb4:	c0 a0       	breq	8000afc8 <_fclose_r+0x98>
8000afb6:	ee c8 ff bc 	sub	r8,r7,-68
8000afba:	10 3b       	cp.w	r11,r8
8000afbc:	c0 40       	breq	8000afc4 <_fclose_r+0x94>
8000afbe:	0c 9c       	mov	r12,r6
8000afc0:	fe b0 f9 54 	rcall	8000a268 <_free_r>
8000afc4:	30 08       	mov	r8,0
8000afc6:	8f d8       	st.w	r7[0x34],r8
8000afc8:	6f 2b       	ld.w	r11,r7[0x48]
8000afca:	58 0b       	cp.w	r11,0
8000afcc:	c0 70       	breq	8000afda <_fclose_r+0xaa>
8000afce:	0c 9c       	mov	r12,r6
8000afd0:	fe b0 f9 4c 	rcall	8000a268 <_free_r>
8000afd4:	30 08       	mov	r8,0
8000afd6:	ef 48 00 48 	st.w	r7[72],r8
8000afda:	30 08       	mov	r8,0
8000afdc:	ae 68       	st.h	r7[0xc],r8
8000afde:	fe b0 f8 5a 	rcall	8000a092 <__sfp_lock_release>
8000afe2:	0a 9c       	mov	r12,r5
8000afe4:	d8 22       	popm	r4-r7,pc
8000afe6:	d7 03       	nop

8000afe8 <fclose>:
8000afe8:	d4 01       	pushm	lr
8000afea:	e0 68 0a 40 	mov	r8,2624
8000afee:	18 9b       	mov	r11,r12
8000aff0:	70 0c       	ld.w	r12,r8[0x0]
8000aff2:	c9 ff       	rcall	8000af30 <_fclose_r>
8000aff4:	d8 02       	popm	pc
8000aff6:	d7 03       	nop

8000aff8 <_fstat_r>:
8000aff8:	d4 21       	pushm	r4-r7,lr
8000affa:	16 98       	mov	r8,r11
8000affc:	18 97       	mov	r7,r12
8000affe:	10 9c       	mov	r12,r8
8000b000:	30 08       	mov	r8,0
8000b002:	e0 66 41 0c 	mov	r6,16652
8000b006:	14 9b       	mov	r11,r10
8000b008:	8d 08       	st.w	r6[0x0],r8
8000b00a:	fe b0 df 67 	rcall	80006ed8 <_fstat>
8000b00e:	5b fc       	cp.w	r12,-1
8000b010:	c0 51       	brne	8000b01a <_fstat_r+0x22>
8000b012:	6c 08       	ld.w	r8,r6[0x0]
8000b014:	58 08       	cp.w	r8,0
8000b016:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b01a:	d8 22       	popm	r4-r7,pc

8000b01c <_lseek_r>:
8000b01c:	d4 21       	pushm	r4-r7,lr
8000b01e:	16 98       	mov	r8,r11
8000b020:	18 97       	mov	r7,r12
8000b022:	10 9c       	mov	r12,r8
8000b024:	30 08       	mov	r8,0
8000b026:	14 9b       	mov	r11,r10
8000b028:	e0 66 41 0c 	mov	r6,16652
8000b02c:	12 9a       	mov	r10,r9
8000b02e:	8d 08       	st.w	r6[0x0],r8
8000b030:	fe b0 df 36 	rcall	80006e9c <_lseek>
8000b034:	5b fc       	cp.w	r12,-1
8000b036:	c0 51       	brne	8000b040 <_lseek_r+0x24>
8000b038:	6c 08       	ld.w	r8,r6[0x0]
8000b03a:	58 08       	cp.w	r8,0
8000b03c:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b040:	d8 22       	popm	r4-r7,pc
8000b042:	d7 03       	nop

8000b044 <_read_r>:
8000b044:	d4 21       	pushm	r4-r7,lr
8000b046:	16 98       	mov	r8,r11
8000b048:	18 97       	mov	r7,r12
8000b04a:	10 9c       	mov	r12,r8
8000b04c:	30 08       	mov	r8,0
8000b04e:	14 9b       	mov	r11,r10
8000b050:	e0 66 41 0c 	mov	r6,16652
8000b054:	12 9a       	mov	r10,r9
8000b056:	8d 08       	st.w	r6[0x0],r8
8000b058:	fe b0 d0 c0 	rcall	800051d8 <_read>
8000b05c:	5b fc       	cp.w	r12,-1
8000b05e:	c0 51       	brne	8000b068 <_read_r+0x24>
8000b060:	6c 08       	ld.w	r8,r6[0x0]
8000b062:	58 08       	cp.w	r8,0
8000b064:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b068:	d8 22       	popm	r4-r7,pc
8000b06a:	d7 03       	nop

8000b06c <__avr32_f64_mul>:
8000b06c:	f5 eb 10 1c 	or	r12,r10,r11<<0x1
8000b070:	e0 80 00 dc 	breq	8000b228 <__avr32_f64_mul_op1_zero>
8000b074:	d4 21       	pushm	r4-r7,lr
8000b076:	f7 e9 20 0e 	eor	lr,r11,r9
8000b07a:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000b07e:	30 15       	mov	r5,1
8000b080:	c4 30       	breq	8000b106 <__avr32_f64_mul_op1_subnormal>
8000b082:	ab 6b       	lsl	r11,0xa
8000b084:	f7 ea 13 6b 	or	r11,r11,r10>>0x16
8000b088:	ab 6a       	lsl	r10,0xa
8000b08a:	f7 d5 d3 c2 	bfins	r11,r5,0x1e,0x2
8000b08e:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000b092:	c5 c0       	breq	8000b14a <__avr32_f64_mul_op2_subnormal>
8000b094:	a1 78       	lsl	r8,0x1
8000b096:	5c f9       	rol	r9
8000b098:	f3 d5 d2 ab 	bfins	r9,r5,0x15,0xb
8000b09c:	e0 47 07 ff 	cp.w	r7,2047
8000b0a0:	c7 70       	breq	8000b18e <__avr32_f64_mul_op_nan_or_inf>
8000b0a2:	e0 46 07 ff 	cp.w	r6,2047
8000b0a6:	c7 40       	breq	8000b18e <__avr32_f64_mul_op_nan_or_inf>
8000b0a8:	ee 06 00 0c 	add	r12,r7,r6
8000b0ac:	e0 2c 03 fe 	sub	r12,1022
8000b0b0:	f6 08 06 44 	mulu.d	r4,r11,r8
8000b0b4:	f4 09 07 44 	macu.d	r4,r10,r9
8000b0b8:	f4 08 06 46 	mulu.d	r6,r10,r8
8000b0bc:	f6 09 06 4a 	mulu.d	r10,r11,r9
8000b0c0:	08 07       	add	r7,r4
8000b0c2:	f4 05 00 4a 	adc	r10,r10,r5
8000b0c6:	5c 0b       	acr	r11
8000b0c8:	ed bb 00 14 	bld	r11,0x14
8000b0cc:	c0 50       	breq	8000b0d6 <__avr32_f64_mul+0x6a>
8000b0ce:	a1 77       	lsl	r7,0x1
8000b0d0:	5c fa       	rol	r10
8000b0d2:	5c fb       	rol	r11
8000b0d4:	20 1c       	sub	r12,1
8000b0d6:	58 0c       	cp.w	r12,0
8000b0d8:	e0 8a 00 6f 	brle	8000b1b6 <__avr32_f64_mul_res_subnormal>
8000b0dc:	e0 4c 07 ff 	cp.w	r12,2047
8000b0e0:	e0 84 00 9c 	brge	8000b218 <__avr32_f64_mul_res_inf>
8000b0e4:	f7 dc d2 8b 	bfins	r11,r12,0x14,0xb
8000b0e8:	ed ea 11 f6 	or	r6,r6,r10<<0x1f
8000b0ec:	ef e6 12 17 	or	r7,r7,r6>>0x1
8000b0f0:	ee 17 80 00 	eorh	r7,0x8000
8000b0f4:	f1 b7 04 20 	satu	r7,0x1
8000b0f8:	0e 0a       	add	r10,r7
8000b0fa:	5c 0b       	acr	r11
8000b0fc:	ed be 00 1f 	bld	lr,0x1f
8000b100:	ef bb 00 1f 	bst	r11,0x1f
8000b104:	d8 22       	popm	r4-r7,pc

8000b106 <__avr32_f64_mul_op1_subnormal>:
8000b106:	e4 1b 00 0f 	andh	r11,0xf
8000b10a:	f4 0c 12 00 	clz	r12,r10
8000b10e:	f6 06 12 00 	clz	r6,r11
8000b112:	f7 bc 03 e1 	sublo	r12,-31
8000b116:	f8 06 17 30 	movlo	r6,r12
8000b11a:	f7 b6 02 01 	subhs	r6,1
8000b11e:	e0 46 00 20 	cp.w	r6,32
8000b122:	c0 d4       	brge	8000b13c <__avr32_f64_mul_op1_subnormal+0x36>
8000b124:	ec 0c 11 20 	rsub	r12,r6,32
8000b128:	f6 06 09 4b 	lsl	r11,r11,r6
8000b12c:	f4 0c 0a 4c 	lsr	r12,r10,r12
8000b130:	18 4b       	or	r11,r12
8000b132:	f4 06 09 4a 	lsl	r10,r10,r6
8000b136:	20 b6       	sub	r6,11
8000b138:	0c 17       	sub	r7,r6
8000b13a:	ca ab       	rjmp	8000b08e <__avr32_f64_mul+0x22>
8000b13c:	f4 06 09 4b 	lsl	r11,r10,r6
8000b140:	c6 40       	breq	8000b208 <__avr32_f64_mul_res_zero>
8000b142:	30 0a       	mov	r10,0
8000b144:	20 b6       	sub	r6,11
8000b146:	0c 17       	sub	r7,r6
8000b148:	ca 3b       	rjmp	8000b08e <__avr32_f64_mul+0x22>

8000b14a <__avr32_f64_mul_op2_subnormal>:
8000b14a:	e4 19 00 0f 	andh	r9,0xf
8000b14e:	f0 0c 12 00 	clz	r12,r8
8000b152:	f2 05 12 00 	clz	r5,r9
8000b156:	f7 bc 03 ea 	sublo	r12,-22
8000b15a:	f8 05 17 30 	movlo	r5,r12
8000b15e:	f7 b5 02 0a 	subhs	r5,10
8000b162:	e0 45 00 20 	cp.w	r5,32
8000b166:	c0 d4       	brge	8000b180 <__avr32_f64_mul_op2_subnormal+0x36>
8000b168:	ea 0c 11 20 	rsub	r12,r5,32
8000b16c:	f2 05 09 49 	lsl	r9,r9,r5
8000b170:	f0 0c 0a 4c 	lsr	r12,r8,r12
8000b174:	18 49       	or	r9,r12
8000b176:	f0 05 09 48 	lsl	r8,r8,r5
8000b17a:	20 25       	sub	r5,2
8000b17c:	0a 16       	sub	r6,r5
8000b17e:	c8 fb       	rjmp	8000b09c <__avr32_f64_mul+0x30>
8000b180:	f0 05 09 49 	lsl	r9,r8,r5
8000b184:	c4 20       	breq	8000b208 <__avr32_f64_mul_res_zero>
8000b186:	30 08       	mov	r8,0
8000b188:	20 25       	sub	r5,2
8000b18a:	0a 16       	sub	r6,r5
8000b18c:	c8 8b       	rjmp	8000b09c <__avr32_f64_mul+0x30>

8000b18e <__avr32_f64_mul_op_nan_or_inf>:
8000b18e:	e4 19 00 0f 	andh	r9,0xf
8000b192:	e4 1b 00 0f 	andh	r11,0xf
8000b196:	14 4b       	or	r11,r10
8000b198:	10 49       	or	r9,r8
8000b19a:	e0 47 07 ff 	cp.w	r7,2047
8000b19e:	c0 91       	brne	8000b1b0 <__avr32_f64_mul_op1_not_naninf>
8000b1a0:	58 0b       	cp.w	r11,0
8000b1a2:	c3 81       	brne	8000b212 <__avr32_f64_mul_res_nan>
8000b1a4:	e0 46 07 ff 	cp.w	r6,2047
8000b1a8:	c3 81       	brne	8000b218 <__avr32_f64_mul_res_inf>
8000b1aa:	58 09       	cp.w	r9,0
8000b1ac:	c3 60       	breq	8000b218 <__avr32_f64_mul_res_inf>
8000b1ae:	c3 28       	rjmp	8000b212 <__avr32_f64_mul_res_nan>

8000b1b0 <__avr32_f64_mul_op1_not_naninf>:
8000b1b0:	58 09       	cp.w	r9,0
8000b1b2:	c3 30       	breq	8000b218 <__avr32_f64_mul_res_inf>
8000b1b4:	c2 f8       	rjmp	8000b212 <__avr32_f64_mul_res_nan>

8000b1b6 <__avr32_f64_mul_res_subnormal>:
8000b1b6:	5c 3c       	neg	r12
8000b1b8:	2f fc       	sub	r12,-1
8000b1ba:	f1 bc 04 c0 	satu	r12,0x6
8000b1be:	e0 4c 00 20 	cp.w	r12,32
8000b1c2:	c1 14       	brge	8000b1e4 <__avr32_f64_mul_res_subnormal+0x2e>
8000b1c4:	f8 08 11 20 	rsub	r8,r12,32
8000b1c8:	0e 46       	or	r6,r7
8000b1ca:	ee 0c 0a 47 	lsr	r7,r7,r12
8000b1ce:	f4 08 09 49 	lsl	r9,r10,r8
8000b1d2:	12 47       	or	r7,r9
8000b1d4:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000b1d8:	f6 08 09 49 	lsl	r9,r11,r8
8000b1dc:	12 4a       	or	r10,r9
8000b1de:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000b1e2:	c8 3b       	rjmp	8000b0e8 <__avr32_f64_mul+0x7c>
8000b1e4:	f8 08 11 20 	rsub	r8,r12,32
8000b1e8:	f9 b9 00 00 	moveq	r9,0
8000b1ec:	c0 30       	breq	8000b1f2 <__avr32_f64_mul_res_subnormal+0x3c>
8000b1ee:	f6 08 09 49 	lsl	r9,r11,r8
8000b1f2:	0e 46       	or	r6,r7
8000b1f4:	ed ea 10 16 	or	r6,r6,r10<<0x1
8000b1f8:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000b1fc:	f3 ea 10 07 	or	r7,r9,r10
8000b200:	f6 0c 0a 4a 	lsr	r10,r11,r12
8000b204:	30 0b       	mov	r11,0
8000b206:	c7 1b       	rjmp	8000b0e8 <__avr32_f64_mul+0x7c>

8000b208 <__avr32_f64_mul_res_zero>:
8000b208:	1c 9b       	mov	r11,lr
8000b20a:	e6 1b 80 00 	andh	r11,0x8000,COH
8000b20e:	30 0a       	mov	r10,0
8000b210:	d8 22       	popm	r4-r7,pc

8000b212 <__avr32_f64_mul_res_nan>:
8000b212:	3f fb       	mov	r11,-1
8000b214:	3f fa       	mov	r10,-1
8000b216:	d8 22       	popm	r4-r7,pc

8000b218 <__avr32_f64_mul_res_inf>:
8000b218:	f0 6b 00 00 	mov	r11,-1048576
8000b21c:	ed be 00 1f 	bld	lr,0x1f
8000b220:	ef bb 00 1f 	bst	r11,0x1f
8000b224:	30 0a       	mov	r10,0
8000b226:	d8 22       	popm	r4-r7,pc

8000b228 <__avr32_f64_mul_op1_zero>:
8000b228:	f7 e9 20 0b 	eor	r11,r11,r9
8000b22c:	e6 1b 80 00 	andh	r11,0x8000,COH
8000b230:	f9 d9 c2 8b 	bfextu	r12,r9,0x14,0xb
8000b234:	e0 4c 07 ff 	cp.w	r12,2047
8000b238:	5e 1c       	retne	r12
8000b23a:	3f fa       	mov	r10,-1
8000b23c:	3f fb       	mov	r11,-1
8000b23e:	5e fc       	retal	r12

8000b240 <__avr32_f64_sub_from_add>:
8000b240:	ee 19 80 00 	eorh	r9,0x8000

8000b244 <__avr32_f64_sub>:
8000b244:	f7 e9 20 0c 	eor	r12,r11,r9
8000b248:	e0 86 00 ca 	brmi	8000b3dc <__avr32_f64_add_from_sub>
8000b24c:	eb cd 40 e0 	pushm	r5-r7,lr
8000b250:	16 9c       	mov	r12,r11
8000b252:	e6 1c 80 00 	andh	r12,0x8000,COH
8000b256:	bf db       	cbr	r11,0x1f
8000b258:	bf d9       	cbr	r9,0x1f
8000b25a:	10 3a       	cp.w	r10,r8
8000b25c:	f2 0b 13 00 	cpc	r11,r9
8000b260:	c0 92       	brcc	8000b272 <__avr32_f64_sub+0x2e>
8000b262:	16 97       	mov	r7,r11
8000b264:	12 9b       	mov	r11,r9
8000b266:	0e 99       	mov	r9,r7
8000b268:	14 97       	mov	r7,r10
8000b26a:	10 9a       	mov	r10,r8
8000b26c:	0e 98       	mov	r8,r7
8000b26e:	ee 1c 80 00 	eorh	r12,0x8000
8000b272:	f6 07 16 14 	lsr	r7,r11,0x14
8000b276:	ab 7b       	lsl	r11,0xb
8000b278:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000b27c:	ab 7a       	lsl	r10,0xb
8000b27e:	bf bb       	sbr	r11,0x1f
8000b280:	f2 06 16 14 	lsr	r6,r9,0x14
8000b284:	c4 40       	breq	8000b30c <__avr32_f64_sub_opL_subnormal>
8000b286:	ab 79       	lsl	r9,0xb
8000b288:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000b28c:	ab 78       	lsl	r8,0xb
8000b28e:	bf b9       	sbr	r9,0x1f

8000b290 <__avr32_f64_sub_opL_subnormal_done>:
8000b290:	e0 47 07 ff 	cp.w	r7,2047
8000b294:	c4 f0       	breq	8000b332 <__avr32_f64_sub_opH_nan_or_inf>
8000b296:	0e 26       	rsub	r6,r7
8000b298:	c1 20       	breq	8000b2bc <__avr32_f64_sub_shift_done>
8000b29a:	ec 05 11 20 	rsub	r5,r6,32
8000b29e:	e0 46 00 20 	cp.w	r6,32
8000b2a2:	c7 c2       	brcc	8000b39a <__avr32_f64_sub_longshift>
8000b2a4:	f0 05 09 4e 	lsl	lr,r8,r5
8000b2a8:	f2 05 09 45 	lsl	r5,r9,r5
8000b2ac:	f0 06 0a 48 	lsr	r8,r8,r6
8000b2b0:	f2 06 0a 49 	lsr	r9,r9,r6
8000b2b4:	0a 48       	or	r8,r5
8000b2b6:	58 0e       	cp.w	lr,0
8000b2b8:	5f 1e       	srne	lr
8000b2ba:	1c 48       	or	r8,lr

8000b2bc <__avr32_f64_sub_shift_done>:
8000b2bc:	10 1a       	sub	r10,r8
8000b2be:	f6 09 01 4b 	sbc	r11,r11,r9
8000b2c2:	f6 06 12 00 	clz	r6,r11
8000b2c6:	c0 e0       	breq	8000b2e2 <__avr32_f64_sub_longnormalize_done>
8000b2c8:	c7 83       	brcs	8000b3b8 <__avr32_f64_sub_longnormalize>
8000b2ca:	ec 0e 11 20 	rsub	lr,r6,32
8000b2ce:	f6 06 09 4b 	lsl	r11,r11,r6
8000b2d2:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000b2d6:	1c 4b       	or	r11,lr
8000b2d8:	f4 06 09 4a 	lsl	r10,r10,r6
8000b2dc:	0c 17       	sub	r7,r6
8000b2de:	e0 8a 00 39 	brle	8000b350 <__avr32_f64_sub_subnormal_result>

8000b2e2 <__avr32_f64_sub_longnormalize_done>:
8000b2e2:	f4 09 15 15 	lsl	r9,r10,0x15
8000b2e6:	ab 9a       	lsr	r10,0xb
8000b2e8:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000b2ec:	ab 9b       	lsr	r11,0xb
8000b2ee:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000b2f2:	18 4b       	or	r11,r12

8000b2f4 <__avr32_f64_sub_round>:
8000b2f4:	fc 17 80 00 	movh	r7,0x8000
8000b2f8:	ed ba 00 00 	bld	r10,0x0
8000b2fc:	f7 b7 01 ff 	subne	r7,-1
8000b300:	0e 39       	cp.w	r9,r7
8000b302:	5f 29       	srhs	r9
8000b304:	12 0a       	add	r10,r9
8000b306:	5c 0b       	acr	r11
8000b308:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b30c <__avr32_f64_sub_opL_subnormal>:
8000b30c:	ab 79       	lsl	r9,0xb
8000b30e:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000b312:	ab 78       	lsl	r8,0xb
8000b314:	f3 e8 10 0e 	or	lr,r9,r8
8000b318:	f9 b6 01 01 	movne	r6,1
8000b31c:	ee 0e 11 00 	rsub	lr,r7,0
8000b320:	f9 b7 00 01 	moveq	r7,1
8000b324:	ef bb 00 1f 	bst	r11,0x1f
8000b328:	f7 ea 10 0e 	or	lr,r11,r10
8000b32c:	f9 b7 00 00 	moveq	r7,0
8000b330:	cb 0b       	rjmp	8000b290 <__avr32_f64_sub_opL_subnormal_done>

8000b332 <__avr32_f64_sub_opH_nan_or_inf>:
8000b332:	bf db       	cbr	r11,0x1f
8000b334:	f7 ea 10 0e 	or	lr,r11,r10
8000b338:	c0 81       	brne	8000b348 <__avr32_f64_sub_return_nan>
8000b33a:	e0 46 07 ff 	cp.w	r6,2047
8000b33e:	c0 50       	breq	8000b348 <__avr32_f64_sub_return_nan>
8000b340:	f9 e7 11 4b 	or	r11,r12,r7<<0x14
8000b344:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b348 <__avr32_f64_sub_return_nan>:
8000b348:	3f fa       	mov	r10,-1
8000b34a:	3f fb       	mov	r11,-1
8000b34c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b350 <__avr32_f64_sub_subnormal_result>:
8000b350:	5c 37       	neg	r7
8000b352:	2f f7       	sub	r7,-1
8000b354:	f1 b7 04 c0 	satu	r7,0x6
8000b358:	e0 47 00 20 	cp.w	r7,32
8000b35c:	c1 14       	brge	8000b37e <__avr32_f64_sub_subnormal_result+0x2e>
8000b35e:	ee 08 11 20 	rsub	r8,r7,32
8000b362:	f4 08 09 49 	lsl	r9,r10,r8
8000b366:	5f 16       	srne	r6
8000b368:	f4 07 0a 4a 	lsr	r10,r10,r7
8000b36c:	0c 4a       	or	r10,r6
8000b36e:	f6 08 09 49 	lsl	r9,r11,r8
8000b372:	f5 e9 10 0a 	or	r10,r10,r9
8000b376:	f4 07 0a 4b 	lsr	r11,r10,r7
8000b37a:	30 07       	mov	r7,0
8000b37c:	cb 3b       	rjmp	8000b2e2 <__avr32_f64_sub_longnormalize_done>
8000b37e:	ee 08 11 40 	rsub	r8,r7,64
8000b382:	f6 08 09 49 	lsl	r9,r11,r8
8000b386:	14 49       	or	r9,r10
8000b388:	5f 16       	srne	r6
8000b38a:	f6 07 0a 4a 	lsr	r10,r11,r7
8000b38e:	0c 4a       	or	r10,r6
8000b390:	30 0b       	mov	r11,0
8000b392:	30 07       	mov	r7,0
8000b394:	ca 7b       	rjmp	8000b2e2 <__avr32_f64_sub_longnormalize_done>
8000b396:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b39a <__avr32_f64_sub_longshift>:
8000b39a:	f1 b6 04 c0 	satu	r6,0x6
8000b39e:	f0 0e 17 00 	moveq	lr,r8
8000b3a2:	c0 40       	breq	8000b3aa <__avr32_f64_sub_longshift+0x10>
8000b3a4:	f2 05 09 4e 	lsl	lr,r9,r5
8000b3a8:	10 4e       	or	lr,r8
8000b3aa:	f2 06 0a 48 	lsr	r8,r9,r6
8000b3ae:	30 09       	mov	r9,0
8000b3b0:	58 0e       	cp.w	lr,0
8000b3b2:	5f 1e       	srne	lr
8000b3b4:	1c 48       	or	r8,lr
8000b3b6:	c8 3b       	rjmp	8000b2bc <__avr32_f64_sub_shift_done>

8000b3b8 <__avr32_f64_sub_longnormalize>:
8000b3b8:	f4 06 12 00 	clz	r6,r10
8000b3bc:	f9 b7 03 00 	movlo	r7,0
8000b3c0:	f9 b6 03 00 	movlo	r6,0
8000b3c4:	f9 bc 03 00 	movlo	r12,0
8000b3c8:	f7 b6 02 e0 	subhs	r6,-32
8000b3cc:	f4 06 09 4b 	lsl	r11,r10,r6
8000b3d0:	30 0a       	mov	r10,0
8000b3d2:	0c 17       	sub	r7,r6
8000b3d4:	fe 9a ff be 	brle	8000b350 <__avr32_f64_sub_subnormal_result>
8000b3d8:	c8 5b       	rjmp	8000b2e2 <__avr32_f64_sub_longnormalize_done>
8000b3da:	d7 03       	nop

8000b3dc <__avr32_f64_add_from_sub>:
8000b3dc:	ee 19 80 00 	eorh	r9,0x8000

8000b3e0 <__avr32_f64_add>:
8000b3e0:	f7 e9 20 0c 	eor	r12,r11,r9
8000b3e4:	fe 96 ff 2e 	brmi	8000b240 <__avr32_f64_sub_from_add>
8000b3e8:	eb cd 40 e0 	pushm	r5-r7,lr
8000b3ec:	16 9c       	mov	r12,r11
8000b3ee:	e6 1c 80 00 	andh	r12,0x8000,COH
8000b3f2:	bf db       	cbr	r11,0x1f
8000b3f4:	bf d9       	cbr	r9,0x1f
8000b3f6:	12 3b       	cp.w	r11,r9
8000b3f8:	c0 72       	brcc	8000b406 <__avr32_f64_add+0x26>
8000b3fa:	16 97       	mov	r7,r11
8000b3fc:	12 9b       	mov	r11,r9
8000b3fe:	0e 99       	mov	r9,r7
8000b400:	14 97       	mov	r7,r10
8000b402:	10 9a       	mov	r10,r8
8000b404:	0e 98       	mov	r8,r7
8000b406:	30 0e       	mov	lr,0
8000b408:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000b40c:	f7 db c0 14 	bfextu	r11,r11,0x0,0x14
8000b410:	b5 ab       	sbr	r11,0x14
8000b412:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000b416:	c6 20       	breq	8000b4da <__avr32_f64_add_op2_subnormal>
8000b418:	f3 d9 c0 14 	bfextu	r9,r9,0x0,0x14
8000b41c:	b5 a9       	sbr	r9,0x14
8000b41e:	e0 47 07 ff 	cp.w	r7,2047
8000b422:	c2 80       	breq	8000b472 <__avr32_f64_add_opH_nan_or_inf>
8000b424:	0e 26       	rsub	r6,r7
8000b426:	c1 20       	breq	8000b44a <__avr32_f64_add_shift_done>
8000b428:	e0 46 00 36 	cp.w	r6,54
8000b42c:	c1 52       	brcc	8000b456 <__avr32_f64_add_res_of_done>
8000b42e:	ec 05 11 20 	rsub	r5,r6,32
8000b432:	e0 46 00 20 	cp.w	r6,32
8000b436:	c3 52       	brcc	8000b4a0 <__avr32_f64_add_longshift>
8000b438:	f0 05 09 4e 	lsl	lr,r8,r5
8000b43c:	f2 05 09 45 	lsl	r5,r9,r5
8000b440:	f0 06 0a 48 	lsr	r8,r8,r6
8000b444:	f2 06 0a 49 	lsr	r9,r9,r6
8000b448:	0a 48       	or	r8,r5

8000b44a <__avr32_f64_add_shift_done>:
8000b44a:	10 0a       	add	r10,r8
8000b44c:	f6 09 00 4b 	adc	r11,r11,r9
8000b450:	ed bb 00 15 	bld	r11,0x15
8000b454:	c3 40       	breq	8000b4bc <__avr32_f64_add_res_of>

8000b456 <__avr32_f64_add_res_of_done>:
8000b456:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000b45a:	18 4b       	or	r11,r12

8000b45c <__avr32_f64_add_round>:
8000b45c:	f9 da c0 01 	bfextu	r12,r10,0x0,0x1
8000b460:	18 4e       	or	lr,r12
8000b462:	ee 1e 80 00 	eorh	lr,0x8000
8000b466:	f1 be 04 20 	satu	lr,0x1
8000b46a:	1c 0a       	add	r10,lr
8000b46c:	5c 0b       	acr	r11
8000b46e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b472 <__avr32_f64_add_opH_nan_or_inf>:
8000b472:	b5 cb       	cbr	r11,0x14
8000b474:	f7 ea 10 0e 	or	lr,r11,r10
8000b478:	c1 01       	brne	8000b498 <__avr32_f64_add_return_nan>
8000b47a:	e0 46 07 ff 	cp.w	r6,2047
8000b47e:	c0 30       	breq	8000b484 <__avr32_f64_add_opL_nan_or_inf>
8000b480:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b484 <__avr32_f64_add_opL_nan_or_inf>:
8000b484:	b5 c9       	cbr	r9,0x14
8000b486:	f3 e8 10 0e 	or	lr,r9,r8
8000b48a:	c0 71       	brne	8000b498 <__avr32_f64_add_return_nan>
8000b48c:	30 0a       	mov	r10,0
8000b48e:	fc 1b 7f f0 	movh	r11,0x7ff0
8000b492:	18 4b       	or	r11,r12
8000b494:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b498 <__avr32_f64_add_return_nan>:
8000b498:	3f fa       	mov	r10,-1
8000b49a:	3f fb       	mov	r11,-1
8000b49c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b4a0 <__avr32_f64_add_longshift>:
8000b4a0:	f1 b6 04 c0 	satu	r6,0x6
8000b4a4:	f0 0e 17 00 	moveq	lr,r8
8000b4a8:	c0 60       	breq	8000b4b4 <__avr32_f64_add_longshift+0x14>
8000b4aa:	f2 05 09 4e 	lsl	lr,r9,r5
8000b4ae:	58 08       	cp.w	r8,0
8000b4b0:	5f 18       	srne	r8
8000b4b2:	10 4e       	or	lr,r8
8000b4b4:	f2 06 0a 48 	lsr	r8,r9,r6
8000b4b8:	30 09       	mov	r9,0
8000b4ba:	cc 8b       	rjmp	8000b44a <__avr32_f64_add_shift_done>

8000b4bc <__avr32_f64_add_res_of>:
8000b4bc:	fd ee 10 1e 	or	lr,lr,lr<<0x1
8000b4c0:	a1 9b       	lsr	r11,0x1
8000b4c2:	5d 0a       	ror	r10
8000b4c4:	5d 0e       	ror	lr
8000b4c6:	2f f7       	sub	r7,-1
8000b4c8:	e0 47 07 ff 	cp.w	r7,2047
8000b4cc:	f9 ba 00 00 	moveq	r10,0
8000b4d0:	f9 bb 00 00 	moveq	r11,0
8000b4d4:	f9 be 00 00 	moveq	lr,0
8000b4d8:	cb fb       	rjmp	8000b456 <__avr32_f64_add_res_of_done>

8000b4da <__avr32_f64_add_op2_subnormal>:
8000b4da:	30 16       	mov	r6,1
8000b4dc:	58 07       	cp.w	r7,0
8000b4de:	ca 01       	brne	8000b41e <__avr32_f64_add+0x3e>
8000b4e0:	b5 cb       	cbr	r11,0x14
8000b4e2:	10 0a       	add	r10,r8
8000b4e4:	f6 09 00 4b 	adc	r11,r11,r9
8000b4e8:	18 4b       	or	r11,r12
8000b4ea:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000b4ee:	d7 03       	nop

8000b4f0 <__avr32_f64_to_u32>:
8000b4f0:	58 0b       	cp.w	r11,0
8000b4f2:	5e 6d       	retmi	0

8000b4f4 <__avr32_f64_to_s32>:
8000b4f4:	f6 0c 15 01 	lsl	r12,r11,0x1
8000b4f8:	b5 9c       	lsr	r12,0x15
8000b4fa:	e0 2c 03 ff 	sub	r12,1023
8000b4fe:	5e 3d       	retlo	0
8000b500:	f8 0c 11 1f 	rsub	r12,r12,31
8000b504:	16 99       	mov	r9,r11
8000b506:	ab 7b       	lsl	r11,0xb
8000b508:	bf bb       	sbr	r11,0x1f
8000b50a:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000b50e:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000b512:	a1 79       	lsl	r9,0x1
8000b514:	5e 2b       	reths	r11
8000b516:	5c 3b       	neg	r11
8000b518:	5e fb       	retal	r11

8000b51a <__avr32_u32_to_f64>:
8000b51a:	f8 cb 00 00 	sub	r11,r12,0
8000b51e:	30 0c       	mov	r12,0
8000b520:	c0 38       	rjmp	8000b526 <__avr32_s32_to_f64+0x4>

8000b522 <__avr32_s32_to_f64>:
8000b522:	18 9b       	mov	r11,r12
8000b524:	5c 4b       	abs	r11
8000b526:	30 0a       	mov	r10,0
8000b528:	5e 0b       	reteq	r11
8000b52a:	d4 01       	pushm	lr
8000b52c:	e0 69 04 1e 	mov	r9,1054
8000b530:	f6 08 12 00 	clz	r8,r11
8000b534:	c1 70       	breq	8000b562 <__avr32_s32_to_f64+0x40>
8000b536:	c0 c3       	brcs	8000b54e <__avr32_s32_to_f64+0x2c>
8000b538:	f0 0e 11 20 	rsub	lr,r8,32
8000b53c:	f6 08 09 4b 	lsl	r11,r11,r8
8000b540:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000b544:	1c 4b       	or	r11,lr
8000b546:	f4 08 09 4a 	lsl	r10,r10,r8
8000b54a:	10 19       	sub	r9,r8
8000b54c:	c0 b8       	rjmp	8000b562 <__avr32_s32_to_f64+0x40>
8000b54e:	f4 08 12 00 	clz	r8,r10
8000b552:	f9 b8 03 00 	movlo	r8,0
8000b556:	f7 b8 02 e0 	subhs	r8,-32
8000b55a:	f4 08 09 4b 	lsl	r11,r10,r8
8000b55e:	30 0a       	mov	r10,0
8000b560:	10 19       	sub	r9,r8
8000b562:	58 09       	cp.w	r9,0
8000b564:	e0 89 00 30 	brgt	8000b5c4 <__avr32_s32_to_f64+0xa2>
8000b568:	5c 39       	neg	r9
8000b56a:	2f f9       	sub	r9,-1
8000b56c:	e0 49 00 36 	cp.w	r9,54
8000b570:	c0 43       	brcs	8000b578 <__avr32_s32_to_f64+0x56>
8000b572:	30 0b       	mov	r11,0
8000b574:	30 0a       	mov	r10,0
8000b576:	c2 68       	rjmp	8000b5c2 <__avr32_s32_to_f64+0xa0>
8000b578:	2f 69       	sub	r9,-10
8000b57a:	f2 08 11 20 	rsub	r8,r9,32
8000b57e:	e0 49 00 20 	cp.w	r9,32
8000b582:	c0 b2       	brcc	8000b598 <__avr32_s32_to_f64+0x76>
8000b584:	f4 08 09 4e 	lsl	lr,r10,r8
8000b588:	f6 08 09 48 	lsl	r8,r11,r8
8000b58c:	f4 09 0a 4a 	lsr	r10,r10,r9
8000b590:	f6 09 0a 4b 	lsr	r11,r11,r9
8000b594:	10 4b       	or	r11,r8
8000b596:	c0 88       	rjmp	8000b5a6 <__avr32_s32_to_f64+0x84>
8000b598:	f6 08 09 4e 	lsl	lr,r11,r8
8000b59c:	14 4e       	or	lr,r10
8000b59e:	16 9a       	mov	r10,r11
8000b5a0:	30 0b       	mov	r11,0
8000b5a2:	f4 09 0a 4a 	lsr	r10,r10,r9
8000b5a6:	ed ba 00 00 	bld	r10,0x0
8000b5aa:	c0 92       	brcc	8000b5bc <__avr32_s32_to_f64+0x9a>
8000b5ac:	1c 7e       	tst	lr,lr
8000b5ae:	c0 41       	brne	8000b5b6 <__avr32_s32_to_f64+0x94>
8000b5b0:	ed ba 00 01 	bld	r10,0x1
8000b5b4:	c0 42       	brcc	8000b5bc <__avr32_s32_to_f64+0x9a>
8000b5b6:	2f fa       	sub	r10,-1
8000b5b8:	f7 bb 02 ff 	subhs	r11,-1
8000b5bc:	5c fc       	rol	r12
8000b5be:	5d 0b       	ror	r11
8000b5c0:	5d 0a       	ror	r10
8000b5c2:	d8 02       	popm	pc
8000b5c4:	e0 68 03 ff 	mov	r8,1023
8000b5c8:	ed ba 00 0b 	bld	r10,0xb
8000b5cc:	f7 b8 00 ff 	subeq	r8,-1
8000b5d0:	10 0a       	add	r10,r8
8000b5d2:	5c 0b       	acr	r11
8000b5d4:	f7 b9 03 fe 	sublo	r9,-2
8000b5d8:	e0 49 07 ff 	cp.w	r9,2047
8000b5dc:	c0 55       	brlt	8000b5e6 <__avr32_s32_to_f64+0xc4>
8000b5de:	30 0a       	mov	r10,0
8000b5e0:	fc 1b ff e0 	movh	r11,0xffe0
8000b5e4:	c0 c8       	rjmp	8000b5fc <__floatsidf_return_op1>
8000b5e6:	ed bb 00 1f 	bld	r11,0x1f
8000b5ea:	f7 b9 01 01 	subne	r9,1
8000b5ee:	ab 9a       	lsr	r10,0xb
8000b5f0:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000b5f4:	a1 7b       	lsl	r11,0x1
8000b5f6:	ab 9b       	lsr	r11,0xb
8000b5f8:	f7 e9 11 5b 	or	r11,r11,r9<<0x15

8000b5fc <__floatsidf_return_op1>:
8000b5fc:	a1 7c       	lsl	r12,0x1
8000b5fe:	5d 0b       	ror	r11
8000b600:	d8 02       	popm	pc

8000b602 <__avr32_f64_cmp_eq>:
8000b602:	10 3a       	cp.w	r10,r8
8000b604:	f2 0b 13 00 	cpc	r11,r9
8000b608:	c0 80       	breq	8000b618 <__avr32_f64_cmp_eq+0x16>
8000b60a:	a1 7b       	lsl	r11,0x1
8000b60c:	a1 79       	lsl	r9,0x1
8000b60e:	14 4b       	or	r11,r10
8000b610:	12 4b       	or	r11,r9
8000b612:	10 4b       	or	r11,r8
8000b614:	5e 0f       	reteq	1
8000b616:	5e fd       	retal	0
8000b618:	a1 7b       	lsl	r11,0x1
8000b61a:	fc 1c ff e0 	movh	r12,0xffe0
8000b61e:	58 0a       	cp.w	r10,0
8000b620:	f8 0b 13 00 	cpc	r11,r12
8000b624:	5e 8f       	retls	1
8000b626:	5e fd       	retal	0

8000b628 <__avr32_f64_cmp_ge>:
8000b628:	1a de       	st.w	--sp,lr
8000b62a:	1a d7       	st.w	--sp,r7
8000b62c:	a1 7b       	lsl	r11,0x1
8000b62e:	5f 3c       	srlo	r12
8000b630:	a1 79       	lsl	r9,0x1
8000b632:	5f 37       	srlo	r7
8000b634:	5c fc       	rol	r12
8000b636:	fc 1e ff e0 	movh	lr,0xffe0
8000b63a:	58 0a       	cp.w	r10,0
8000b63c:	fc 0b 13 00 	cpc	r11,lr
8000b640:	e0 8b 00 1d 	brhi	8000b67a <__avr32_f64_cmp_ge+0x52>
8000b644:	58 08       	cp.w	r8,0
8000b646:	fc 09 13 00 	cpc	r9,lr
8000b64a:	e0 8b 00 18 	brhi	8000b67a <__avr32_f64_cmp_ge+0x52>
8000b64e:	58 0b       	cp.w	r11,0
8000b650:	f5 ba 00 00 	subfeq	r10,0
8000b654:	c1 50       	breq	8000b67e <__avr32_f64_cmp_ge+0x56>
8000b656:	1b 07       	ld.w	r7,sp++
8000b658:	1b 0e       	ld.w	lr,sp++
8000b65a:	58 3c       	cp.w	r12,3
8000b65c:	c0 a0       	breq	8000b670 <__avr32_f64_cmp_ge+0x48>
8000b65e:	58 1c       	cp.w	r12,1
8000b660:	c0 33       	brcs	8000b666 <__avr32_f64_cmp_ge+0x3e>
8000b662:	5e 0f       	reteq	1
8000b664:	5e 1d       	retne	0
8000b666:	10 3a       	cp.w	r10,r8
8000b668:	f2 0b 13 00 	cpc	r11,r9
8000b66c:	5e 2f       	reths	1
8000b66e:	5e 3d       	retlo	0
8000b670:	14 38       	cp.w	r8,r10
8000b672:	f6 09 13 00 	cpc	r9,r11
8000b676:	5e 2f       	reths	1
8000b678:	5e 3d       	retlo	0
8000b67a:	1b 07       	ld.w	r7,sp++
8000b67c:	d8 0a       	popm	pc,r12=0
8000b67e:	58 17       	cp.w	r7,1
8000b680:	5f 0c       	sreq	r12
8000b682:	58 09       	cp.w	r9,0
8000b684:	f5 b8 00 00 	subfeq	r8,0
8000b688:	1b 07       	ld.w	r7,sp++
8000b68a:	1b 0e       	ld.w	lr,sp++
8000b68c:	5e 0f       	reteq	1
8000b68e:	5e fc       	retal	r12

8000b690 <__avr32_f64_cmp_lt>:
8000b690:	1a de       	st.w	--sp,lr
8000b692:	1a d7       	st.w	--sp,r7
8000b694:	a1 7b       	lsl	r11,0x1
8000b696:	5f 3c       	srlo	r12
8000b698:	a1 79       	lsl	r9,0x1
8000b69a:	5f 37       	srlo	r7
8000b69c:	5c fc       	rol	r12
8000b69e:	fc 1e ff e0 	movh	lr,0xffe0
8000b6a2:	58 0a       	cp.w	r10,0
8000b6a4:	fc 0b 13 00 	cpc	r11,lr
8000b6a8:	e0 8b 00 1d 	brhi	8000b6e2 <__avr32_f64_cmp_lt+0x52>
8000b6ac:	58 08       	cp.w	r8,0
8000b6ae:	fc 09 13 00 	cpc	r9,lr
8000b6b2:	e0 8b 00 18 	brhi	8000b6e2 <__avr32_f64_cmp_lt+0x52>
8000b6b6:	58 0b       	cp.w	r11,0
8000b6b8:	f5 ba 00 00 	subfeq	r10,0
8000b6bc:	c1 50       	breq	8000b6e6 <__avr32_f64_cmp_lt+0x56>
8000b6be:	1b 07       	ld.w	r7,sp++
8000b6c0:	1b 0e       	ld.w	lr,sp++
8000b6c2:	58 3c       	cp.w	r12,3
8000b6c4:	c0 a0       	breq	8000b6d8 <__avr32_f64_cmp_lt+0x48>
8000b6c6:	58 1c       	cp.w	r12,1
8000b6c8:	c0 33       	brcs	8000b6ce <__avr32_f64_cmp_lt+0x3e>
8000b6ca:	5e 0d       	reteq	0
8000b6cc:	5e 1f       	retne	1
8000b6ce:	10 3a       	cp.w	r10,r8
8000b6d0:	f2 0b 13 00 	cpc	r11,r9
8000b6d4:	5e 2d       	reths	0
8000b6d6:	5e 3f       	retlo	1
8000b6d8:	14 38       	cp.w	r8,r10
8000b6da:	f6 09 13 00 	cpc	r9,r11
8000b6de:	5e 2d       	reths	0
8000b6e0:	5e 3f       	retlo	1
8000b6e2:	1b 07       	ld.w	r7,sp++
8000b6e4:	d8 0a       	popm	pc,r12=0
8000b6e6:	58 17       	cp.w	r7,1
8000b6e8:	5f 1c       	srne	r12
8000b6ea:	58 09       	cp.w	r9,0
8000b6ec:	f5 b8 00 00 	subfeq	r8,0
8000b6f0:	1b 07       	ld.w	r7,sp++
8000b6f2:	1b 0e       	ld.w	lr,sp++
8000b6f4:	5e 0d       	reteq	0
8000b6f6:	5e fc       	retal	r12

8000b6f8 <__avr32_f64_div>:
8000b6f8:	eb cd 40 ff 	pushm	r0-r7,lr
8000b6fc:	f7 e9 20 0e 	eor	lr,r11,r9
8000b700:	f6 07 16 14 	lsr	r7,r11,0x14
8000b704:	a9 7b       	lsl	r11,0x9
8000b706:	f7 ea 13 7b 	or	r11,r11,r10>>0x17
8000b70a:	a9 7a       	lsl	r10,0x9
8000b70c:	bd bb       	sbr	r11,0x1d
8000b70e:	e4 1b 3f ff 	andh	r11,0x3fff
8000b712:	ab d7       	cbr	r7,0xb
8000b714:	e0 80 00 cc 	breq	8000b8ac <__avr32_f64_div_round_subnormal+0x54>
8000b718:	e0 47 07 ff 	cp.w	r7,2047
8000b71c:	e0 84 00 b5 	brge	8000b886 <__avr32_f64_div_round_subnormal+0x2e>
8000b720:	f2 06 16 14 	lsr	r6,r9,0x14
8000b724:	a9 79       	lsl	r9,0x9
8000b726:	f3 e8 13 79 	or	r9,r9,r8>>0x17
8000b72a:	a9 78       	lsl	r8,0x9
8000b72c:	bd b9       	sbr	r9,0x1d
8000b72e:	e4 19 3f ff 	andh	r9,0x3fff
8000b732:	ab d6       	cbr	r6,0xb
8000b734:	e0 80 00 e2 	breq	8000b8f8 <__avr32_f64_div_round_subnormal+0xa0>
8000b738:	e0 46 07 ff 	cp.w	r6,2047
8000b73c:	e0 84 00 b2 	brge	8000b8a0 <__avr32_f64_div_round_subnormal+0x48>
8000b740:	0c 17       	sub	r7,r6
8000b742:	fe 37 fc 01 	sub	r7,-1023
8000b746:	fc 1c 80 00 	movh	r12,0x8000
8000b74a:	f8 03 16 01 	lsr	r3,r12,0x1
8000b74e:	e9 d9 c3 62 	bfextu	r4,r9,0x1b,0x2
8000b752:	5c d4       	com	r4
8000b754:	e7 d4 d3 82 	bfins	r3,r4,0x1c,0x2
8000b758:	e6 09 06 44 	mulu.d	r4,r3,r9
8000b75c:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000b760:	e6 05 06 44 	mulu.d	r4,r3,r5
8000b764:	ea 03 15 02 	lsl	r3,r5,0x2
8000b768:	e6 09 06 44 	mulu.d	r4,r3,r9
8000b76c:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000b770:	e6 05 06 44 	mulu.d	r4,r3,r5
8000b774:	ea 03 15 02 	lsl	r3,r5,0x2
8000b778:	e6 09 06 44 	mulu.d	r4,r3,r9
8000b77c:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000b780:	e6 05 06 44 	mulu.d	r4,r3,r5
8000b784:	ea 03 15 02 	lsl	r3,r5,0x2
8000b788:	e6 08 06 40 	mulu.d	r0,r3,r8
8000b78c:	e4 09 07 40 	macu.d	r0,r2,r9
8000b790:	e6 09 06 44 	mulu.d	r4,r3,r9
8000b794:	02 04       	add	r4,r1
8000b796:	5c 05       	acr	r5
8000b798:	a3 65       	lsl	r5,0x2
8000b79a:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000b79e:	a3 64       	lsl	r4,0x2
8000b7a0:	5c 34       	neg	r4
8000b7a2:	f8 05 01 45 	sbc	r5,r12,r5
8000b7a6:	e6 04 06 40 	mulu.d	r0,r3,r4
8000b7aa:	e4 05 07 40 	macu.d	r0,r2,r5
8000b7ae:	e6 05 06 44 	mulu.d	r4,r3,r5
8000b7b2:	02 04       	add	r4,r1
8000b7b4:	5c 05       	acr	r5
8000b7b6:	ea 03 15 02 	lsl	r3,r5,0x2
8000b7ba:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000b7be:	e8 02 15 02 	lsl	r2,r4,0x2
8000b7c2:	e6 08 06 40 	mulu.d	r0,r3,r8
8000b7c6:	e4 09 07 40 	macu.d	r0,r2,r9
8000b7ca:	e6 09 06 44 	mulu.d	r4,r3,r9
8000b7ce:	02 04       	add	r4,r1
8000b7d0:	5c 05       	acr	r5
8000b7d2:	a3 65       	lsl	r5,0x2
8000b7d4:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000b7d8:	a3 64       	lsl	r4,0x2
8000b7da:	5c 34       	neg	r4
8000b7dc:	f8 05 01 45 	sbc	r5,r12,r5
8000b7e0:	e6 04 06 40 	mulu.d	r0,r3,r4
8000b7e4:	e4 05 07 40 	macu.d	r0,r2,r5
8000b7e8:	e6 05 06 44 	mulu.d	r4,r3,r5
8000b7ec:	02 04       	add	r4,r1
8000b7ee:	5c 05       	acr	r5
8000b7f0:	ea 03 15 02 	lsl	r3,r5,0x2
8000b7f4:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000b7f8:	e8 02 15 02 	lsl	r2,r4,0x2
8000b7fc:	e6 0a 06 40 	mulu.d	r0,r3,r10
8000b800:	e4 0b 07 40 	macu.d	r0,r2,r11
8000b804:	e6 0b 06 42 	mulu.d	r2,r3,r11
8000b808:	02 02       	add	r2,r1
8000b80a:	5c 03       	acr	r3
8000b80c:	ed b3 00 1c 	bld	r3,0x1c
8000b810:	c0 90       	breq	8000b822 <__avr32_f64_div+0x12a>
8000b812:	a1 72       	lsl	r2,0x1
8000b814:	5c f3       	rol	r3
8000b816:	20 17       	sub	r7,1
8000b818:	a3 9a       	lsr	r10,0x3
8000b81a:	f5 eb 11 da 	or	r10,r10,r11<<0x1d
8000b81e:	a3 9b       	lsr	r11,0x3
8000b820:	c0 58       	rjmp	8000b82a <__avr32_f64_div+0x132>
8000b822:	a5 8a       	lsr	r10,0x4
8000b824:	f5 eb 11 ca 	or	r10,r10,r11<<0x1c
8000b828:	a5 8b       	lsr	r11,0x4
8000b82a:	58 07       	cp.w	r7,0
8000b82c:	e0 8a 00 8b 	brle	8000b942 <__avr32_f64_div_res_subnormal>
8000b830:	e0 12 ff 00 	andl	r2,0xff00
8000b834:	e8 12 00 80 	orl	r2,0x80
8000b838:	e6 08 06 40 	mulu.d	r0,r3,r8
8000b83c:	e4 09 07 40 	macu.d	r0,r2,r9
8000b840:	e4 08 06 44 	mulu.d	r4,r2,r8
8000b844:	e6 09 06 48 	mulu.d	r8,r3,r9
8000b848:	00 05       	add	r5,r0
8000b84a:	f0 01 00 48 	adc	r8,r8,r1
8000b84e:	5c 09       	acr	r9
8000b850:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000b854:	58 04       	cp.w	r4,0
8000b856:	5c 25       	cpc	r5

8000b858 <__avr32_f64_div_round_subnormal>:
8000b858:	f4 08 13 00 	cpc	r8,r10
8000b85c:	f6 09 13 00 	cpc	r9,r11
8000b860:	5f 36       	srlo	r6
8000b862:	f8 06 17 00 	moveq	r6,r12
8000b866:	e4 0a 16 08 	lsr	r10,r2,0x8
8000b86a:	f5 e3 11 8a 	or	r10,r10,r3<<0x18
8000b86e:	e6 0b 16 08 	lsr	r11,r3,0x8
8000b872:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000b876:	ed be 00 1f 	bld	lr,0x1f
8000b87a:	ef bb 00 1f 	bst	r11,0x1f
8000b87e:	0c 0a       	add	r10,r6
8000b880:	5c 0b       	acr	r11
8000b882:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000b886:	e4 1b 00 0f 	andh	r11,0xf
8000b88a:	14 4b       	or	r11,r10
8000b88c:	e0 81 00 a7 	brne	8000b9da <__avr32_f64_div_res_subnormal+0x98>
8000b890:	f2 06 16 14 	lsr	r6,r9,0x14
8000b894:	ab d6       	cbr	r6,0xb
8000b896:	e0 46 07 ff 	cp.w	r6,2047
8000b89a:	e0 81 00 a4 	brne	8000b9e2 <__avr32_f64_div_res_subnormal+0xa0>
8000b89e:	c9 e8       	rjmp	8000b9da <__avr32_f64_div_res_subnormal+0x98>
8000b8a0:	e4 19 00 0f 	andh	r9,0xf
8000b8a4:	10 49       	or	r9,r8
8000b8a6:	e0 81 00 9a 	brne	8000b9da <__avr32_f64_div_res_subnormal+0x98>
8000b8aa:	c9 28       	rjmp	8000b9ce <__avr32_f64_div_res_subnormal+0x8c>
8000b8ac:	a3 7b       	lsl	r11,0x3
8000b8ae:	f7 ea 13 db 	or	r11,r11,r10>>0x1d
8000b8b2:	a3 7a       	lsl	r10,0x3
8000b8b4:	f5 eb 10 04 	or	r4,r10,r11
8000b8b8:	e0 80 00 a0 	breq	8000b9f8 <__avr32_f64_div_op1_zero>
8000b8bc:	f6 04 12 00 	clz	r4,r11
8000b8c0:	c1 70       	breq	8000b8ee <__avr32_f64_div_round_subnormal+0x96>
8000b8c2:	c0 c3       	brcs	8000b8da <__avr32_f64_div_round_subnormal+0x82>
8000b8c4:	e8 05 11 20 	rsub	r5,r4,32
8000b8c8:	f6 04 09 4b 	lsl	r11,r11,r4
8000b8cc:	f4 05 0a 45 	lsr	r5,r10,r5
8000b8d0:	0a 4b       	or	r11,r5
8000b8d2:	f4 04 09 4a 	lsl	r10,r10,r4
8000b8d6:	08 17       	sub	r7,r4
8000b8d8:	c0 b8       	rjmp	8000b8ee <__avr32_f64_div_round_subnormal+0x96>
8000b8da:	f4 04 12 00 	clz	r4,r10
8000b8de:	f9 b4 03 00 	movlo	r4,0
8000b8e2:	f7 b4 02 e0 	subhs	r4,-32
8000b8e6:	f4 04 09 4b 	lsl	r11,r10,r4
8000b8ea:	30 0a       	mov	r10,0
8000b8ec:	08 17       	sub	r7,r4
8000b8ee:	a3 8a       	lsr	r10,0x2
8000b8f0:	f5 eb 11 ea 	or	r10,r10,r11<<0x1e
8000b8f4:	a3 8b       	lsr	r11,0x2
8000b8f6:	c1 1b       	rjmp	8000b718 <__avr32_f64_div+0x20>
8000b8f8:	a3 79       	lsl	r9,0x3
8000b8fa:	f3 e8 13 d9 	or	r9,r9,r8>>0x1d
8000b8fe:	a3 78       	lsl	r8,0x3
8000b900:	f3 e8 10 04 	or	r4,r9,r8
8000b904:	c6 f0       	breq	8000b9e2 <__avr32_f64_div_res_subnormal+0xa0>
8000b906:	f2 04 12 00 	clz	r4,r9
8000b90a:	c1 70       	breq	8000b938 <__avr32_f64_div_round_subnormal+0xe0>
8000b90c:	c0 c3       	brcs	8000b924 <__avr32_f64_div_round_subnormal+0xcc>
8000b90e:	e8 05 11 20 	rsub	r5,r4,32
8000b912:	f2 04 09 49 	lsl	r9,r9,r4
8000b916:	f0 05 0a 45 	lsr	r5,r8,r5
8000b91a:	0a 49       	or	r9,r5
8000b91c:	f0 04 09 48 	lsl	r8,r8,r4
8000b920:	08 16       	sub	r6,r4
8000b922:	c0 b8       	rjmp	8000b938 <__avr32_f64_div_round_subnormal+0xe0>
8000b924:	f0 04 12 00 	clz	r4,r8
8000b928:	f9 b4 03 00 	movlo	r4,0
8000b92c:	f7 b4 02 e0 	subhs	r4,-32
8000b930:	f0 04 09 49 	lsl	r9,r8,r4
8000b934:	30 08       	mov	r8,0
8000b936:	08 16       	sub	r6,r4
8000b938:	a3 88       	lsr	r8,0x2
8000b93a:	f1 e9 11 e8 	or	r8,r8,r9<<0x1e
8000b93e:	a3 89       	lsr	r9,0x2
8000b940:	cf ca       	rjmp	8000b738 <__avr32_f64_div+0x40>

8000b942 <__avr32_f64_div_res_subnormal>:
8000b942:	5c 37       	neg	r7
8000b944:	2f f7       	sub	r7,-1
8000b946:	f1 b7 04 c0 	satu	r7,0x6
8000b94a:	e0 47 00 20 	cp.w	r7,32
8000b94e:	c1 54       	brge	8000b978 <__avr32_f64_div_res_subnormal+0x36>
8000b950:	ee 06 11 20 	rsub	r6,r7,32
8000b954:	e4 07 0a 42 	lsr	r2,r2,r7
8000b958:	e6 06 09 4c 	lsl	r12,r3,r6
8000b95c:	18 42       	or	r2,r12
8000b95e:	e6 07 0a 43 	lsr	r3,r3,r7
8000b962:	f4 06 09 41 	lsl	r1,r10,r6
8000b966:	f4 07 0a 4a 	lsr	r10,r10,r7
8000b96a:	f6 06 09 4c 	lsl	r12,r11,r6
8000b96e:	18 4a       	or	r10,r12
8000b970:	f6 07 0a 4b 	lsr	r11,r11,r7
8000b974:	30 00       	mov	r0,0
8000b976:	c1 58       	rjmp	8000b9a0 <__avr32_f64_div_res_subnormal+0x5e>
8000b978:	ee 06 11 20 	rsub	r6,r7,32
8000b97c:	f9 b0 00 00 	moveq	r0,0
8000b980:	f9 bc 00 00 	moveq	r12,0
8000b984:	c0 50       	breq	8000b98e <__avr32_f64_div_res_subnormal+0x4c>
8000b986:	f4 06 09 40 	lsl	r0,r10,r6
8000b98a:	f6 06 09 4c 	lsl	r12,r11,r6
8000b98e:	e6 07 0a 42 	lsr	r2,r3,r7
8000b992:	30 03       	mov	r3,0
8000b994:	f4 07 0a 41 	lsr	r1,r10,r7
8000b998:	18 41       	or	r1,r12
8000b99a:	f6 07 0a 4a 	lsr	r10,r11,r7
8000b99e:	30 0b       	mov	r11,0
8000b9a0:	e0 12 ff 00 	andl	r2,0xff00
8000b9a4:	e8 12 00 80 	orl	r2,0x80
8000b9a8:	e6 08 06 46 	mulu.d	r6,r3,r8
8000b9ac:	e4 09 07 46 	macu.d	r6,r2,r9
8000b9b0:	e4 08 06 44 	mulu.d	r4,r2,r8
8000b9b4:	e6 09 06 48 	mulu.d	r8,r3,r9
8000b9b8:	0c 05       	add	r5,r6
8000b9ba:	f0 07 00 48 	adc	r8,r8,r7
8000b9be:	5c 09       	acr	r9
8000b9c0:	30 07       	mov	r7,0
8000b9c2:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000b9c6:	00 34       	cp.w	r4,r0
8000b9c8:	e2 05 13 00 	cpc	r5,r1
8000b9cc:	c4 6b       	rjmp	8000b858 <__avr32_f64_div_round_subnormal>
8000b9ce:	1c 9b       	mov	r11,lr
8000b9d0:	e6 1b 80 00 	andh	r11,0x8000,COH
8000b9d4:	30 0a       	mov	r10,0
8000b9d6:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000b9da:	3f fb       	mov	r11,-1
8000b9dc:	30 0a       	mov	r10,0
8000b9de:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000b9e2:	f5 eb 10 04 	or	r4,r10,r11
8000b9e6:	c0 90       	breq	8000b9f8 <__avr32_f64_div_op1_zero>
8000b9e8:	1c 9b       	mov	r11,lr
8000b9ea:	e6 1b 80 00 	andh	r11,0x8000,COH
8000b9ee:	ea 1b 7f f0 	orh	r11,0x7ff0
8000b9f2:	30 0a       	mov	r10,0
8000b9f4:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc

8000b9f8 <__avr32_f64_div_op1_zero>:
8000b9f8:	f1 e9 10 15 	or	r5,r8,r9<<0x1
8000b9fc:	ce f0       	breq	8000b9da <__avr32_f64_div_res_subnormal+0x98>
8000b9fe:	e9 d9 c2 8b 	bfextu	r4,r9,0x14,0xb
8000ba02:	e0 44 07 ff 	cp.w	r4,2047
8000ba06:	ce 41       	brne	8000b9ce <__avr32_f64_div_res_subnormal+0x8c>
8000ba08:	f1 e9 10 c5 	or	r5,r8,r9<<0xc
8000ba0c:	ce 10       	breq	8000b9ce <__avr32_f64_div_res_subnormal+0x8c>
8000ba0e:	ce 6b       	rjmp	8000b9da <__avr32_f64_div_res_subnormal+0x98>

8000ba10 <__avr32_udiv64>:
8000ba10:	d4 31       	pushm	r0-r7,lr
8000ba12:	1a 97       	mov	r7,sp
8000ba14:	20 3d       	sub	sp,12
8000ba16:	10 9c       	mov	r12,r8
8000ba18:	12 9e       	mov	lr,r9
8000ba1a:	14 93       	mov	r3,r10
8000ba1c:	58 09       	cp.w	r9,0
8000ba1e:	e0 81 00 bd 	brne	8000bb98 <__avr32_udiv64+0x188>
8000ba22:	16 38       	cp.w	r8,r11
8000ba24:	e0 88 00 40 	brls	8000baa4 <__avr32_udiv64+0x94>
8000ba28:	f0 08 12 00 	clz	r8,r8
8000ba2c:	c0 d0       	breq	8000ba46 <__avr32_udiv64+0x36>
8000ba2e:	f6 08 09 4b 	lsl	r11,r11,r8
8000ba32:	f0 09 11 20 	rsub	r9,r8,32
8000ba36:	f8 08 09 4c 	lsl	r12,r12,r8
8000ba3a:	f4 09 0a 49 	lsr	r9,r10,r9
8000ba3e:	f4 08 09 43 	lsl	r3,r10,r8
8000ba42:	f3 eb 10 0b 	or	r11,r9,r11
8000ba46:	f8 0e 16 10 	lsr	lr,r12,0x10
8000ba4a:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000ba4e:	f6 0e 0d 00 	divu	r0,r11,lr
8000ba52:	e6 0b 16 10 	lsr	r11,r3,0x10
8000ba56:	00 99       	mov	r9,r0
8000ba58:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000ba5c:	e0 0a 02 48 	mul	r8,r0,r10
8000ba60:	10 3b       	cp.w	r11,r8
8000ba62:	c0 a2       	brcc	8000ba76 <__avr32_udiv64+0x66>
8000ba64:	20 19       	sub	r9,1
8000ba66:	18 0b       	add	r11,r12
8000ba68:	18 3b       	cp.w	r11,r12
8000ba6a:	c0 63       	brcs	8000ba76 <__avr32_udiv64+0x66>
8000ba6c:	10 3b       	cp.w	r11,r8
8000ba6e:	f7 b9 03 01 	sublo	r9,1
8000ba72:	f7 dc e3 0b 	addcs	r11,r11,r12
8000ba76:	f6 08 01 01 	sub	r1,r11,r8
8000ba7a:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000ba7e:	e2 0e 0d 00 	divu	r0,r1,lr
8000ba82:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000ba86:	00 98       	mov	r8,r0
8000ba88:	e0 0a 02 4a 	mul	r10,r0,r10
8000ba8c:	14 33       	cp.w	r3,r10
8000ba8e:	c0 82       	brcc	8000ba9e <__avr32_udiv64+0x8e>
8000ba90:	20 18       	sub	r8,1
8000ba92:	18 03       	add	r3,r12
8000ba94:	18 33       	cp.w	r3,r12
8000ba96:	c0 43       	brcs	8000ba9e <__avr32_udiv64+0x8e>
8000ba98:	14 33       	cp.w	r3,r10
8000ba9a:	f7 b8 03 01 	sublo	r8,1
8000ba9e:	f1 e9 11 08 	or	r8,r8,r9<<0x10
8000baa2:	cd f8       	rjmp	8000bc60 <__avr32_udiv64+0x250>
8000baa4:	58 08       	cp.w	r8,0
8000baa6:	c0 51       	brne	8000bab0 <__avr32_udiv64+0xa0>
8000baa8:	30 19       	mov	r9,1
8000baaa:	f2 08 0d 08 	divu	r8,r9,r8
8000baae:	10 9c       	mov	r12,r8
8000bab0:	f8 06 12 00 	clz	r6,r12
8000bab4:	c0 41       	brne	8000babc <__avr32_udiv64+0xac>
8000bab6:	18 1b       	sub	r11,r12
8000bab8:	30 19       	mov	r9,1
8000baba:	c4 08       	rjmp	8000bb3a <__avr32_udiv64+0x12a>
8000babc:	ec 01 11 20 	rsub	r1,r6,32
8000bac0:	f4 01 0a 49 	lsr	r9,r10,r1
8000bac4:	f8 06 09 4c 	lsl	r12,r12,r6
8000bac8:	f6 06 09 48 	lsl	r8,r11,r6
8000bacc:	f6 01 0a 41 	lsr	r1,r11,r1
8000bad0:	f3 e8 10 08 	or	r8,r9,r8
8000bad4:	f8 03 16 10 	lsr	r3,r12,0x10
8000bad8:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000badc:	e2 03 0d 00 	divu	r0,r1,r3
8000bae0:	f0 0b 16 10 	lsr	r11,r8,0x10
8000bae4:	00 9e       	mov	lr,r0
8000bae6:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000baea:	e0 05 02 49 	mul	r9,r0,r5
8000baee:	12 3b       	cp.w	r11,r9
8000baf0:	c0 a2       	brcc	8000bb04 <__avr32_udiv64+0xf4>
8000baf2:	20 1e       	sub	lr,1
8000baf4:	18 0b       	add	r11,r12
8000baf6:	18 3b       	cp.w	r11,r12
8000baf8:	c0 63       	brcs	8000bb04 <__avr32_udiv64+0xf4>
8000bafa:	12 3b       	cp.w	r11,r9
8000bafc:	f7 be 03 01 	sublo	lr,1
8000bb00:	f7 dc e3 0b 	addcs	r11,r11,r12
8000bb04:	12 1b       	sub	r11,r9
8000bb06:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
8000bb0a:	f6 03 0d 02 	divu	r2,r11,r3
8000bb0e:	f1 e3 11 08 	or	r8,r8,r3<<0x10
8000bb12:	04 99       	mov	r9,r2
8000bb14:	e4 05 02 4b 	mul	r11,r2,r5
8000bb18:	16 38       	cp.w	r8,r11
8000bb1a:	c0 a2       	brcc	8000bb2e <__avr32_udiv64+0x11e>
8000bb1c:	20 19       	sub	r9,1
8000bb1e:	18 08       	add	r8,r12
8000bb20:	18 38       	cp.w	r8,r12
8000bb22:	c0 63       	brcs	8000bb2e <__avr32_udiv64+0x11e>
8000bb24:	16 38       	cp.w	r8,r11
8000bb26:	f7 b9 03 01 	sublo	r9,1
8000bb2a:	f1 dc e3 08 	addcs	r8,r8,r12
8000bb2e:	f4 06 09 43 	lsl	r3,r10,r6
8000bb32:	f0 0b 01 0b 	sub	r11,r8,r11
8000bb36:	f3 ee 11 09 	or	r9,r9,lr<<0x10
8000bb3a:	f8 06 16 10 	lsr	r6,r12,0x10
8000bb3e:	fd dc c0 10 	bfextu	lr,r12,0x0,0x10
8000bb42:	f6 06 0d 00 	divu	r0,r11,r6
8000bb46:	e6 0b 16 10 	lsr	r11,r3,0x10
8000bb4a:	00 9a       	mov	r10,r0
8000bb4c:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000bb50:	e0 0e 02 48 	mul	r8,r0,lr
8000bb54:	10 3b       	cp.w	r11,r8
8000bb56:	c0 a2       	brcc	8000bb6a <__avr32_udiv64+0x15a>
8000bb58:	20 1a       	sub	r10,1
8000bb5a:	18 0b       	add	r11,r12
8000bb5c:	18 3b       	cp.w	r11,r12
8000bb5e:	c0 63       	brcs	8000bb6a <__avr32_udiv64+0x15a>
8000bb60:	10 3b       	cp.w	r11,r8
8000bb62:	f7 ba 03 01 	sublo	r10,1
8000bb66:	f7 dc e3 0b 	addcs	r11,r11,r12
8000bb6a:	f6 08 01 01 	sub	r1,r11,r8
8000bb6e:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000bb72:	e2 06 0d 00 	divu	r0,r1,r6
8000bb76:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000bb7a:	00 98       	mov	r8,r0
8000bb7c:	e0 0e 02 4b 	mul	r11,r0,lr
8000bb80:	16 33       	cp.w	r3,r11
8000bb82:	c0 82       	brcc	8000bb92 <__avr32_udiv64+0x182>
8000bb84:	20 18       	sub	r8,1
8000bb86:	18 03       	add	r3,r12
8000bb88:	18 33       	cp.w	r3,r12
8000bb8a:	c0 43       	brcs	8000bb92 <__avr32_udiv64+0x182>
8000bb8c:	16 33       	cp.w	r3,r11
8000bb8e:	f7 b8 03 01 	sublo	r8,1
8000bb92:	f1 ea 11 08 	or	r8,r8,r10<<0x10
8000bb96:	c6 98       	rjmp	8000bc68 <__avr32_udiv64+0x258>
8000bb98:	16 39       	cp.w	r9,r11
8000bb9a:	e0 8b 00 65 	brhi	8000bc64 <__avr32_udiv64+0x254>
8000bb9e:	f2 09 12 00 	clz	r9,r9
8000bba2:	c0 b1       	brne	8000bbb8 <__avr32_udiv64+0x1a8>
8000bba4:	10 3a       	cp.w	r10,r8
8000bba6:	5f 2a       	srhs	r10
8000bba8:	1c 3b       	cp.w	r11,lr
8000bbaa:	5f b8       	srhi	r8
8000bbac:	10 4a       	or	r10,r8
8000bbae:	f2 0a 18 00 	cp.b	r10,r9
8000bbb2:	c5 90       	breq	8000bc64 <__avr32_udiv64+0x254>
8000bbb4:	30 18       	mov	r8,1
8000bbb6:	c5 98       	rjmp	8000bc68 <__avr32_udiv64+0x258>
8000bbb8:	f0 09 09 46 	lsl	r6,r8,r9
8000bbbc:	f2 03 11 20 	rsub	r3,r9,32
8000bbc0:	fc 09 09 4e 	lsl	lr,lr,r9
8000bbc4:	f0 03 0a 48 	lsr	r8,r8,r3
8000bbc8:	f6 09 09 4c 	lsl	r12,r11,r9
8000bbcc:	f4 03 0a 42 	lsr	r2,r10,r3
8000bbd0:	ef 46 ff f4 	st.w	r7[-12],r6
8000bbd4:	f6 03 0a 43 	lsr	r3,r11,r3
8000bbd8:	18 42       	or	r2,r12
8000bbda:	f1 ee 10 0c 	or	r12,r8,lr
8000bbde:	f8 01 16 10 	lsr	r1,r12,0x10
8000bbe2:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000bbe6:	e6 01 0d 04 	divu	r4,r3,r1
8000bbea:	e4 03 16 10 	lsr	r3,r2,0x10
8000bbee:	08 9e       	mov	lr,r4
8000bbf0:	e7 e5 11 03 	or	r3,r3,r5<<0x10
8000bbf4:	e8 06 02 48 	mul	r8,r4,r6
8000bbf8:	10 33       	cp.w	r3,r8
8000bbfa:	c0 a2       	brcc	8000bc0e <__avr32_udiv64+0x1fe>
8000bbfc:	20 1e       	sub	lr,1
8000bbfe:	18 03       	add	r3,r12
8000bc00:	18 33       	cp.w	r3,r12
8000bc02:	c0 63       	brcs	8000bc0e <__avr32_udiv64+0x1fe>
8000bc04:	10 33       	cp.w	r3,r8
8000bc06:	f7 be 03 01 	sublo	lr,1
8000bc0a:	e7 dc e3 03 	addcs	r3,r3,r12
8000bc0e:	10 13       	sub	r3,r8
8000bc10:	f7 d2 c0 10 	bfextu	r11,r2,0x0,0x10
8000bc14:	e6 01 0d 00 	divu	r0,r3,r1
8000bc18:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000bc1c:	00 98       	mov	r8,r0
8000bc1e:	e0 06 02 46 	mul	r6,r0,r6
8000bc22:	0c 3b       	cp.w	r11,r6
8000bc24:	c0 a2       	brcc	8000bc38 <__avr32_udiv64+0x228>
8000bc26:	20 18       	sub	r8,1
8000bc28:	18 0b       	add	r11,r12
8000bc2a:	18 3b       	cp.w	r11,r12
8000bc2c:	c0 63       	brcs	8000bc38 <__avr32_udiv64+0x228>
8000bc2e:	0c 3b       	cp.w	r11,r6
8000bc30:	f7 dc e3 0b 	addcs	r11,r11,r12
8000bc34:	f7 b8 03 01 	sublo	r8,1
8000bc38:	f1 ee 11 08 	or	r8,r8,lr<<0x10
8000bc3c:	ee f4 ff f4 	ld.w	r4,r7[-12]
8000bc40:	0c 1b       	sub	r11,r6
8000bc42:	f0 04 06 42 	mulu.d	r2,r8,r4
8000bc46:	06 95       	mov	r5,r3
8000bc48:	16 35       	cp.w	r5,r11
8000bc4a:	e0 8b 00 0a 	brhi	8000bc5e <__avr32_udiv64+0x24e>
8000bc4e:	5f 0b       	sreq	r11
8000bc50:	f4 09 09 49 	lsl	r9,r10,r9
8000bc54:	12 32       	cp.w	r2,r9
8000bc56:	5f b9       	srhi	r9
8000bc58:	f7 e9 00 09 	and	r9,r11,r9
8000bc5c:	c0 60       	breq	8000bc68 <__avr32_udiv64+0x258>
8000bc5e:	20 18       	sub	r8,1
8000bc60:	30 09       	mov	r9,0
8000bc62:	c0 38       	rjmp	8000bc68 <__avr32_udiv64+0x258>
8000bc64:	30 09       	mov	r9,0
8000bc66:	12 98       	mov	r8,r9
8000bc68:	10 9a       	mov	r10,r8
8000bc6a:	12 93       	mov	r3,r9
8000bc6c:	10 92       	mov	r2,r8
8000bc6e:	12 9b       	mov	r11,r9
8000bc70:	2f dd       	sub	sp,-12
8000bc72:	d8 32       	popm	r0-r7,pc

8000bc74 <__avr32_umod64>:
8000bc74:	d4 31       	pushm	r0-r7,lr
8000bc76:	1a 97       	mov	r7,sp
8000bc78:	20 3d       	sub	sp,12
8000bc7a:	10 9c       	mov	r12,r8
8000bc7c:	12 95       	mov	r5,r9
8000bc7e:	14 9e       	mov	lr,r10
8000bc80:	16 91       	mov	r1,r11
8000bc82:	16 96       	mov	r6,r11
8000bc84:	58 09       	cp.w	r9,0
8000bc86:	e0 81 00 81 	brne	8000bd88 <__avr32_umod64+0x114>
8000bc8a:	16 38       	cp.w	r8,r11
8000bc8c:	e0 88 00 12 	brls	8000bcb0 <__avr32_umod64+0x3c>
8000bc90:	f0 08 12 00 	clz	r8,r8
8000bc94:	c4 e0       	breq	8000bd30 <__avr32_umod64+0xbc>
8000bc96:	f6 08 09 46 	lsl	r6,r11,r8
8000bc9a:	f8 08 09 4c 	lsl	r12,r12,r8
8000bc9e:	f0 0b 11 20 	rsub	r11,r8,32
8000bca2:	f4 08 09 4e 	lsl	lr,r10,r8
8000bca6:	f4 0b 0a 4b 	lsr	r11,r10,r11
8000bcaa:	f7 e6 10 06 	or	r6,r11,r6
8000bcae:	c4 18       	rjmp	8000bd30 <__avr32_umod64+0xbc>
8000bcb0:	58 08       	cp.w	r8,0
8000bcb2:	c0 51       	brne	8000bcbc <__avr32_umod64+0x48>
8000bcb4:	30 19       	mov	r9,1
8000bcb6:	f2 08 0d 08 	divu	r8,r9,r8
8000bcba:	10 9c       	mov	r12,r8
8000bcbc:	f8 08 12 00 	clz	r8,r12
8000bcc0:	c0 31       	brne	8000bcc6 <__avr32_umod64+0x52>
8000bcc2:	18 16       	sub	r6,r12
8000bcc4:	c3 68       	rjmp	8000bd30 <__avr32_umod64+0xbc>
8000bcc6:	f0 03 11 20 	rsub	r3,r8,32
8000bcca:	f4 03 0a 4b 	lsr	r11,r10,r3
8000bcce:	f8 08 09 4c 	lsl	r12,r12,r8
8000bcd2:	ec 08 09 49 	lsl	r9,r6,r8
8000bcd6:	ec 03 0a 43 	lsr	r3,r6,r3
8000bcda:	f7 e9 10 09 	or	r9,r11,r9
8000bcde:	f8 05 16 10 	lsr	r5,r12,0x10
8000bce2:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000bce6:	e6 05 0d 02 	divu	r2,r3,r5
8000bcea:	f2 0e 16 10 	lsr	lr,r9,0x10
8000bcee:	ec 02 02 4b 	mul	r11,r6,r2
8000bcf2:	fd e3 11 0e 	or	lr,lr,r3<<0x10
8000bcf6:	16 3e       	cp.w	lr,r11
8000bcf8:	c0 72       	brcc	8000bd06 <__avr32_umod64+0x92>
8000bcfa:	18 0e       	add	lr,r12
8000bcfc:	18 3e       	cp.w	lr,r12
8000bcfe:	c0 43       	brcs	8000bd06 <__avr32_umod64+0x92>
8000bd00:	16 3e       	cp.w	lr,r11
8000bd02:	fd dc e3 0e 	addcs	lr,lr,r12
8000bd06:	fc 0b 01 03 	sub	r3,lr,r11
8000bd0a:	f3 d9 c0 10 	bfextu	r9,r9,0x0,0x10
8000bd0e:	e6 05 0d 02 	divu	r2,r3,r5
8000bd12:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000bd16:	a5 36       	mul	r6,r2
8000bd18:	0c 39       	cp.w	r9,r6
8000bd1a:	c0 72       	brcc	8000bd28 <__avr32_umod64+0xb4>
8000bd1c:	18 09       	add	r9,r12
8000bd1e:	18 39       	cp.w	r9,r12
8000bd20:	c0 43       	brcs	8000bd28 <__avr32_umod64+0xb4>
8000bd22:	0c 39       	cp.w	r9,r6
8000bd24:	f3 dc e3 09 	addcs	r9,r9,r12
8000bd28:	f2 06 01 06 	sub	r6,r9,r6
8000bd2c:	f4 08 09 4e 	lsl	lr,r10,r8
8000bd30:	f8 0a 16 10 	lsr	r10,r12,0x10
8000bd34:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000bd38:	ec 0a 0d 02 	divu	r2,r6,r10
8000bd3c:	fc 09 16 10 	lsr	r9,lr,0x10
8000bd40:	ea 02 02 4b 	mul	r11,r5,r2
8000bd44:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000bd48:	16 39       	cp.w	r9,r11
8000bd4a:	c0 72       	brcc	8000bd58 <__avr32_umod64+0xe4>
8000bd4c:	18 09       	add	r9,r12
8000bd4e:	18 39       	cp.w	r9,r12
8000bd50:	c0 43       	brcs	8000bd58 <__avr32_umod64+0xe4>
8000bd52:	16 39       	cp.w	r9,r11
8000bd54:	f3 dc e3 09 	addcs	r9,r9,r12
8000bd58:	f2 0b 01 0b 	sub	r11,r9,r11
8000bd5c:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000bd60:	f6 0a 0d 0a 	divu	r10,r11,r10
8000bd64:	fd eb 11 0e 	or	lr,lr,r11<<0x10
8000bd68:	ea 0a 02 4a 	mul	r10,r5,r10
8000bd6c:	14 3e       	cp.w	lr,r10
8000bd6e:	c0 72       	brcc	8000bd7c <__avr32_umod64+0x108>
8000bd70:	18 0e       	add	lr,r12
8000bd72:	18 3e       	cp.w	lr,r12
8000bd74:	c0 43       	brcs	8000bd7c <__avr32_umod64+0x108>
8000bd76:	14 3e       	cp.w	lr,r10
8000bd78:	fd dc e3 0e 	addcs	lr,lr,r12
8000bd7c:	fc 0a 01 0a 	sub	r10,lr,r10
8000bd80:	30 0b       	mov	r11,0
8000bd82:	f4 08 0a 4a 	lsr	r10,r10,r8
8000bd86:	c7 b8       	rjmp	8000be7c <__avr32_umod64+0x208>
8000bd88:	16 39       	cp.w	r9,r11
8000bd8a:	e0 8b 00 79 	brhi	8000be7c <__avr32_umod64+0x208>
8000bd8e:	f2 09 12 00 	clz	r9,r9
8000bd92:	c1 21       	brne	8000bdb6 <__avr32_umod64+0x142>
8000bd94:	10 3a       	cp.w	r10,r8
8000bd96:	5f 2b       	srhs	r11
8000bd98:	0a 31       	cp.w	r1,r5
8000bd9a:	5f ba       	srhi	r10
8000bd9c:	f7 ea 10 0a 	or	r10,r11,r10
8000bda0:	f2 0a 18 00 	cp.b	r10,r9
8000bda4:	c0 60       	breq	8000bdb0 <__avr32_umod64+0x13c>
8000bda6:	fc 08 01 0c 	sub	r12,lr,r8
8000bdaa:	e2 05 01 46 	sbc	r6,r1,r5
8000bdae:	18 9e       	mov	lr,r12
8000bdb0:	0c 9b       	mov	r11,r6
8000bdb2:	1c 9a       	mov	r10,lr
8000bdb4:	c6 48       	rjmp	8000be7c <__avr32_umod64+0x208>
8000bdb6:	ea 09 09 4c 	lsl	r12,r5,r9
8000bdba:	f2 06 11 20 	rsub	r6,r9,32
8000bdbe:	f6 09 09 4b 	lsl	r11,r11,r9
8000bdc2:	f0 09 09 42 	lsl	r2,r8,r9
8000bdc6:	ef 46 ff f4 	st.w	r7[-12],r6
8000bdca:	f0 06 0a 48 	lsr	r8,r8,r6
8000bdce:	18 48       	or	r8,r12
8000bdd0:	e2 06 0a 4c 	lsr	r12,r1,r6
8000bdd4:	f4 09 09 43 	lsl	r3,r10,r9
8000bdd8:	fd d8 c0 10 	bfextu	lr,r8,0x0,0x10
8000bddc:	f4 06 0a 4a 	lsr	r10,r10,r6
8000bde0:	16 4a       	or	r10,r11
8000bde2:	f0 0b 16 10 	lsr	r11,r8,0x10
8000bde6:	f8 0b 0d 04 	divu	r4,r12,r11
8000bdea:	f4 0c 16 10 	lsr	r12,r10,0x10
8000bdee:	08 91       	mov	r1,r4
8000bdf0:	f9 e5 11 0c 	or	r12,r12,r5<<0x10
8000bdf4:	e8 0e 02 46 	mul	r6,r4,lr
8000bdf8:	0c 3c       	cp.w	r12,r6
8000bdfa:	c0 a2       	brcc	8000be0e <__avr32_umod64+0x19a>
8000bdfc:	20 11       	sub	r1,1
8000bdfe:	10 0c       	add	r12,r8
8000be00:	10 3c       	cp.w	r12,r8
8000be02:	c0 63       	brcs	8000be0e <__avr32_umod64+0x19a>
8000be04:	0c 3c       	cp.w	r12,r6
8000be06:	f7 b1 03 01 	sublo	r1,1
8000be0a:	f9 d8 e3 0c 	addcs	r12,r12,r8
8000be0e:	0c 1c       	sub	r12,r6
8000be10:	f5 da c0 10 	bfextu	r10,r10,0x0,0x10
8000be14:	f8 0b 0d 04 	divu	r4,r12,r11
8000be18:	f5 e5 11 0b 	or	r11,r10,r5<<0x10
8000be1c:	08 96       	mov	r6,r4
8000be1e:	e8 0e 02 4e 	mul	lr,r4,lr
8000be22:	1c 3b       	cp.w	r11,lr
8000be24:	c0 a2       	brcc	8000be38 <__avr32_umod64+0x1c4>
8000be26:	20 16       	sub	r6,1
8000be28:	10 0b       	add	r11,r8
8000be2a:	10 3b       	cp.w	r11,r8
8000be2c:	c0 63       	brcs	8000be38 <__avr32_umod64+0x1c4>
8000be2e:	1c 3b       	cp.w	r11,lr
8000be30:	f7 b6 03 01 	sublo	r6,1
8000be34:	f7 d8 e3 0b 	addcs	r11,r11,r8
8000be38:	ed e1 11 01 	or	r1,r6,r1<<0x10
8000be3c:	1c 1b       	sub	r11,lr
8000be3e:	e2 02 06 40 	mulu.d	r0,r1,r2
8000be42:	00 9e       	mov	lr,r0
8000be44:	02 9c       	mov	r12,r1
8000be46:	16 3c       	cp.w	r12,r11
8000be48:	e0 8b 00 08 	brhi	8000be58 <__avr32_umod64+0x1e4>
8000be4c:	5f 06       	sreq	r6
8000be4e:	06 30       	cp.w	r0,r3
8000be50:	5f ba       	srhi	r10
8000be52:	ed ea 00 0a 	and	r10,r6,r10
8000be56:	c0 60       	breq	8000be62 <__avr32_umod64+0x1ee>
8000be58:	fc 02 01 04 	sub	r4,lr,r2
8000be5c:	f8 08 01 4c 	sbc	r12,r12,r8
8000be60:	08 9e       	mov	lr,r4
8000be62:	e6 0e 01 0a 	sub	r10,r3,lr
8000be66:	f6 0c 01 4c 	sbc	r12,r11,r12
8000be6a:	ee f1 ff f4 	ld.w	r1,r7[-12]
8000be6e:	f8 09 0a 4b 	lsr	r11,r12,r9
8000be72:	f4 09 0a 4a 	lsr	r10,r10,r9
8000be76:	f8 01 09 4c 	lsl	r12,r12,r1
8000be7a:	18 4a       	or	r10,r12
8000be7c:	2f dd       	sub	sp,-12
8000be7e:	d8 32       	popm	r0-r7,pc

Disassembly of section .exception:

8000c000 <_evba>:
_evba:

        .org  0x000
        // Unrecoverable Exception.
_handle_Unrecoverable_Exception:
        rjmp $
8000c000:	c0 08       	rjmp	8000c000 <_evba>
	...

8000c004 <_handle_TLB_Multiple_Hit>:

        .org  0x004
        // TLB Multiple Hit: UNUSED IN AVR32UC.
_handle_TLB_Multiple_Hit:
        rjmp $
8000c004:	c0 08       	rjmp	8000c004 <_handle_TLB_Multiple_Hit>
	...

8000c008 <_handle_Bus_Error_Data_Fetch>:

        .org  0x008
        // Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
        rjmp $
8000c008:	c0 08       	rjmp	8000c008 <_handle_Bus_Error_Data_Fetch>
	...

8000c00c <_handle_Bus_Error_Instruction_Fetch>:

        .org  0x00C
         // Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
        rjmp $
8000c00c:	c0 08       	rjmp	8000c00c <_handle_Bus_Error_Instruction_Fetch>
	...

8000c010 <_handle_NMI>:

        .org  0x010
        // NMI.
_handle_NMI:
        rjmp $
8000c010:	c0 08       	rjmp	8000c010 <_handle_NMI>
	...

8000c014 <_handle_Instruction_Address>:

        .org  0x014
        // Instruction Address.
_handle_Instruction_Address:
        rjmp $
8000c014:	c0 08       	rjmp	8000c014 <_handle_Instruction_Address>
	...

8000c018 <_handle_ITLB_Protection>:

        .org  0x018
        // ITLB Protection.
_handle_ITLB_Protection:
        rjmp $
8000c018:	c0 08       	rjmp	8000c018 <_handle_ITLB_Protection>
	...

8000c01c <_handle_Breakpoint>:

        .org  0x01C
        // Breakpoint.
_handle_Breakpoint:
        rjmp $
8000c01c:	c0 08       	rjmp	8000c01c <_handle_Breakpoint>
	...

8000c020 <_handle_Illegal_Opcode>:

        .org  0x020
        // Illegal Opcode.
_handle_Illegal_Opcode:
        rjmp $
8000c020:	c0 08       	rjmp	8000c020 <_handle_Illegal_Opcode>
	...

8000c024 <_handle_Unimplemented_Instruction>:

        .org  0x024
        // Unimplemented Instruction.
_handle_Unimplemented_Instruction:
        rjmp $
8000c024:	c0 08       	rjmp	8000c024 <_handle_Unimplemented_Instruction>
	...

8000c028 <_handle_Privilege_Violation>:

        .org  0x028
        // Privilege Violation.
_handle_Privilege_Violation:
        rjmp $
8000c028:	c0 08       	rjmp	8000c028 <_handle_Privilege_Violation>
	...

8000c02c <_handle_Floating_Point>:

        .org  0x02C
        // Floating-Point: UNUSED IN AVR32UC.
_handle_Floating_Point:
        rjmp $
8000c02c:	c0 08       	rjmp	8000c02c <_handle_Floating_Point>
	...

8000c030 <_handle_Coprocessor_Absent>:

        .org  0x030
        // Coprocessor Absent: UNUSED IN AVR32UC.
_handle_Coprocessor_Absent:
        rjmp $
8000c030:	c0 08       	rjmp	8000c030 <_handle_Coprocessor_Absent>
	...

8000c034 <_handle_Data_Address_Read>:

        .org  0x034
        // Data Address (Read).
_handle_Data_Address_Read:
        rjmp $
8000c034:	c0 08       	rjmp	8000c034 <_handle_Data_Address_Read>
	...

8000c038 <_handle_Data_Address_Write>:

        .org  0x038
        // Data Address (Write).
_handle_Data_Address_Write:
        rjmp $
8000c038:	c0 08       	rjmp	8000c038 <_handle_Data_Address_Write>
	...

8000c03c <_handle_DTLB_Protection_Read>:

        .org  0x03C
        // DTLB Protection (Read).
_handle_DTLB_Protection_Read:
        rjmp $
8000c03c:	c0 08       	rjmp	8000c03c <_handle_DTLB_Protection_Read>
	...

8000c040 <_handle_DTLB_Protection_Write>:

        .org  0x040
        // DTLB Protection (Write).
_handle_DTLB_Protection_Write:
        rjmp $
8000c040:	c0 08       	rjmp	8000c040 <_handle_DTLB_Protection_Write>
	...

8000c044 <_handle_DTLB_Modified>:

        .org  0x044
        // DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
        rjmp $
8000c044:	c0 08       	rjmp	8000c044 <_handle_DTLB_Modified>
	...

8000c050 <_handle_ITLB_Miss>:

        .org  0x050
        // ITLB Miss: UNUSED IN AVR32UC.
_handle_ITLB_Miss:
        rjmp $
8000c050:	c0 08       	rjmp	8000c050 <_handle_ITLB_Miss>
	...

8000c060 <_handle_DTLB_Miss_Read>:

        .org  0x060
        // DTLB Miss (Read): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Read:
        rjmp $
8000c060:	c0 08       	rjmp	8000c060 <_handle_DTLB_Miss_Read>
	...

8000c070 <_handle_DTLB_Miss_Write>:

        .org  0x070
        // DTLB Miss (Write): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Write:
        rjmp $
8000c070:	c0 08       	rjmp	8000c070 <_handle_DTLB_Miss_Write>
	...

8000c100 <_handle_Supervisor_Call>:

        .org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	lda.w   pc, SCALLYield
8000c100:	fe cf 70 88 	sub	pc,pc,28808

8000c104 <_int0>:
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
	rete
.endr
8000c104:	30 0c       	mov	r12,0
8000c106:	fe b0 c5 b3 	rcall	80004c6c <_get_interrupt_handler>
8000c10a:	58 0c       	cp.w	r12,0
8000c10c:	f8 0f 17 10 	movne	pc,r12
8000c110:	d6 03       	rete

8000c112 <_int1>:
8000c112:	30 1c       	mov	r12,1
8000c114:	fe b0 c5 ac 	rcall	80004c6c <_get_interrupt_handler>
8000c118:	58 0c       	cp.w	r12,0
8000c11a:	f8 0f 17 10 	movne	pc,r12
8000c11e:	d6 03       	rete

8000c120 <_int2>:
8000c120:	30 2c       	mov	r12,2
8000c122:	fe b0 c5 a5 	rcall	80004c6c <_get_interrupt_handler>
8000c126:	58 0c       	cp.w	r12,0
8000c128:	f8 0f 17 10 	movne	pc,r12
8000c12c:	d6 03       	rete

8000c12e <_int3>:
8000c12e:	30 3c       	mov	r12,3
8000c130:	fe b0 c5 9e 	rcall	80004c6c <_get_interrupt_handler>
8000c134:	58 0c       	cp.w	r12,0
8000c136:	f8 0f 17 10 	movne	pc,r12
8000c13a:	d6 03       	rete

8000c13c <ipr_val>:
8000c13c:	00 00 01 04 40 00 01 12 80 00 01 20 c0 00 01 2e     ....@...... ....
8000c14c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c15c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c16c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c17c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c18c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c19c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c1ac:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c1bc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c1cc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c1dc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c1ec:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c1fc:	d7 03 d7 03                                         ....
