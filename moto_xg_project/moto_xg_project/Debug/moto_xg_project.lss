
moto_xg_project.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00002004  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         0000ac70  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .exception    00000200  8000ce00  8000ce00  0000d200  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       000012b8  8000d000  8000d000  0000d400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .data         00000a3c  00000004  8000e2b8  0000e804  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .bss          00005b60  00000a40  8000ecf4  0000f240  2**2
                  ALLOC
  7 .comment      00000030  00000000  00000000  0000f240  2**0
                  CONTENTS, READONLY
  8 .debug_aranges 00001688  00000000  00000000  0000f270  2**3
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_pubnames 00003641  00000000  00000000  000108f8  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_info   0002c489  00000000  00000000  00013f39  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_abbrev 00007283  00000000  00000000  000403c2  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   0000d446  00000000  00000000  00047645  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_frame  00003d10  00000000  00000000  00054a8c  2**2
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    00007fb6  00000000  00000000  0005879c  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_loc    0000f385  00000000  00000000  00060752  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .stack        00001000  00017000  00017000  00000400  2**0
                  ALLOC
 17 .debug_ranges 00001750  00000000  00000000  0006fad8  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_trampoline>:

  .global _trampoline
  .type _trampoline, @function
_trampoline:
  // Jump to program start.
  rjmp    program_start
80000000:	e0 8f 10 00 	bral	80002000 <program_start>
	...

80002000 <program_start>:
	   // rjmp    program_start

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002000:	fe cf c3 f0 	sub	pc,pc,-15376

Disassembly of section .text:

80002004 <DeviceManagement_brdcst_func>:
80002004:	19 a9       	ld.ub	r9,r12[0x2]
80002006:	30 18       	mov	r8,1
		U8 temp = 0;
		temp  = xcmp->u8[1] << 8;
		temp |= xcmp->u8[2];
		//if (temp == theXNL_Ctrlr.XNL_DeviceLogicalAddress)
		{
			if (xcmp->u8[0] == 0x01)
80002008:	f0 09 18 00 	cp.b	r9,r8
8000200c:	c0 61       	brne	80002018 <DeviceManagement_brdcst_func+0x14>
			{
				bunchofrandomstatusflags |= 0x00000002;
8000200e:	48 68       	lddpc	r8,80002024 <DeviceManagement_brdcst_func+0x20>
80002010:	70 09       	ld.w	r9,r8[0x0]
80002012:	a1 b9       	sbr	r9,0x1
80002014:	91 09       	st.w	r8[0x0],r9
80002016:	5e fc       	retal	r12
			}
			else
			{
				bunchofrandomstatusflags &= 0xFFFFFFFD;
80002018:	48 38       	lddpc	r8,80002024 <DeviceManagement_brdcst_func+0x20>
8000201a:	70 09       	ld.w	r9,r8[0x0]
8000201c:	a1 d9       	cbr	r9,0x1
8000201e:	91 09       	st.w	r8[0x0],r9
80002020:	5e fc       	retal	r12
80002022:	00 00       	add	r0,r0
80002024:	00 00       	add	r0,r0
80002026:	0d a0       	ld.ub	r0,r6[0x2]

80002028 <Volume_brdcst_func>:
	//log("Attenuator_Number: %x \n",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
	
	//log("Audio_Parameter: %x \n", ptr->Audio_Parameter);
	
	
}
80002028:	5e fc       	retal	r12

8000202a <AudioRoutingControl_brdcst_func>:
	//
	//log("\n\r Audio-Function: %x \n\r", xcmp->u8[3+j*2-1]);
	
	
	
}
8000202a:	5e fc       	retal	r12

8000202c <vApplicationIdleHook>:
}

void vApplicationIdleHook( void )
{
	/* This hook function does nothing but increment a counter. */
	ulIdleCycleCount++;
8000202c:	48 38       	lddpc	r8,80002038 <vApplicationIdleHook+0xc>
8000202e:	70 09       	ld.w	r9,r8[0x0]
80002030:	2f f9       	sub	r9,-1
80002032:	91 09       	st.w	r8[0x0],r9
	
}
80002034:	5e fc       	retal	r12
80002036:	00 00       	add	r0,r0
80002038:	00 00       	add	r0,r0
8000203a:	0a 68       	and	r8,r5

8000203c <app_payload_tx_proc>:

}


static void app_payload_tx_proc(void  * payload)
{
8000203c:	d4 01       	pushm	lr
  log("R");
8000203e:	48 3c       	lddpc	r12,80002048 <app_payload_tx_proc+0xc>
80002040:	f0 1f 00 03 	mcall	8000204c <app_payload_tx_proc+0x10>
  //
  //
  //set_payload_idle(payload);


}
80002044:	d8 02       	popm	pc
80002046:	00 00       	add	r0,r0
80002048:	80 00       	ld.sh	r0,r0[0x0]
8000204a:	d0 00       	acall	0x0
8000204c:	80 00       	ld.sh	r0,r0[0x0]
8000204e:	6f 6c       	ld.w	r12,r7[0x58]

80002050 <app_payload_rx_proc>:
	}
}


static void app_payload_rx_proc(void  * payload)
{
80002050:	d4 01       	pushm	lr
	static  U8 times_counter = 0;
	
	times_counter++;
80002052:	48 99       	lddpc	r9,80002074 <app_payload_rx_proc+0x24>
80002054:	13 88       	ld.ub	r8,r9[0x0]
80002056:	2f f8       	sub	r8,-1
80002058:	b2 88       	st.b	r9[0x0],r8
	if (times_counter == 3)
8000205a:	30 39       	mov	r9,3
8000205c:	f2 08 18 00 	cp.b	r8,r9
80002060:	c0 71       	brne	8000206e <app_payload_rx_proc+0x1e>
	{
		times_counter = 0 ;
80002062:	30 09       	mov	r9,0
80002064:	48 48       	lddpc	r8,80002074 <app_payload_rx_proc+0x24>
80002066:	b0 89       	st.b	r8[0x0],r9
		log("\n\r w: \n\r");
80002068:	48 4c       	lddpc	r12,80002078 <app_payload_rx_proc+0x28>
8000206a:	f0 1f 00 05 	mcall	8000207c <app_payload_rx_proc+0x2c>
	}
	//log("\n\r w: \n\r");
	if (AMBE_tx_flag)//本地发送方的mic录音
8000206e:	48 58       	lddpc	r8,80002080 <app_payload_rx_proc+0x30>
80002070:	11 88       	ld.ub	r8,r8[0x0]
	}
	
	//payload_fragment_t * ptr = (payload_fragment_t *)payload;
	//set_payload_idle(payload);

}
80002072:	d8 02       	popm	pc
80002074:	00 00       	add	r0,r0
80002076:	0a 43       	or	r3,r5
80002078:	80 00       	ld.sh	r0,r0[0x0]
8000207a:	d0 04       	*unknown*
8000207c:	80 00       	ld.sh	r0,r0[0x0]
8000207e:	6f 6c       	ld.w	r12,r7[0x58]
80002080:	00 00       	add	r0,r0
80002082:	0a 48       	or	r8,r5

80002084 <FD_brdcst_func>:
	
	
}

void FD_brdcst_func(xcmp_fragment_t * xcmp)
{
80002084:	d4 01       	pushm	lr
	
	
	log("\n\r Forward Data Broadcast \n\r");
80002086:	48 3c       	lddpc	r12,80002090 <FD_brdcst_func+0xc>
80002088:	f0 1f 00 03 	mcall	80002094 <FD_brdcst_func+0x10>
	
}
8000208c:	d8 02       	popm	pc
8000208e:	00 00       	add	r0,r0
80002090:	80 00       	ld.sh	r0,r0[0x0]
80002092:	d0 10       	acall	0x1
80002094:	80 00       	ld.sh	r0,r0[0x0]
80002096:	6f 6c       	ld.w	r12,r7[0x58]

80002098 <FD_reply_func>:
	
	
}

void FD_reply_func(xcmp_fragment_t * xcmp)
{
80002098:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Reply \n\r");
8000209a:	48 3c       	lddpc	r12,800020a4 <FD_reply_func+0xc>
8000209c:	f0 1f 00 03 	mcall	800020a8 <FD_reply_func+0x10>
	
	
}
800020a0:	d8 02       	popm	pc
800020a2:	00 00       	add	r0,r0
800020a4:	80 00       	ld.sh	r0,r0[0x0]
800020a6:	d0 30       	acall	0x3
800020a8:	80 00       	ld.sh	r0,r0[0x0]
800020aa:	6f 6c       	ld.w	r12,r7[0x58]

800020ac <FD_request_func>:
}



void FD_request_func(xcmp_fragment_t * xcmp)
{
800020ac:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Request \n\r");
800020ae:	48 3c       	lddpc	r12,800020b8 <FD_request_func+0xc>
800020b0:	f0 1f 00 03 	mcall	800020bc <FD_request_func+0x10>
	
	
}
800020b4:	d8 02       	popm	pc
800020b6:	00 00       	add	r0,r0
800020b8:	80 00       	ld.sh	r0,r0[0x0]
800020ba:	d0 4c       	*unknown*
800020bc:	80 00       	ld.sh	r0,r0[0x0]
800020be:	6f 6c       	ld.w	r12,r7[0x58]

800020c0 <EnOB_brdcst_func>:
	
	
}

void EnOB_brdcst_func(xcmp_fragment_t * xcmp)
{
800020c0:	d4 01       	pushm	lr
	
	
	log("\n\r En_OB Broadcast \n\r");
800020c2:	48 3c       	lddpc	r12,800020cc <EnOB_brdcst_func+0xc>
800020c4:	f0 1f 00 03 	mcall	800020d0 <EnOB_brdcst_func+0x10>
}
800020c8:	d8 02       	popm	pc
800020ca:	00 00       	add	r0,r0
800020cc:	80 00       	ld.sh	r0,r0[0x0]
800020ce:	d0 68       	*unknown*
800020d0:	80 00       	ld.sh	r0,r0[0x0]
800020d2:	6f 6c       	ld.w	r12,r7[0x58]

800020d4 <EnOB_reply_func>:
}



void EnOB_reply_func(xcmp_fragment_t * xcmp)
{
800020d4:	eb cd 40 80 	pushm	r7,lr
800020d8:	18 97       	mov	r7,r12
		/*point to xcmp payload*/
	//En_OB_Control_reply_t *ptr = (En_OB_Control_reply_t* )xcmp->u8;
	//log("\n\r Xcmp_opcode: %x \n\r", xcmp->xcmp_opcode);
	
	if (xcmp->u8[0]== xcmp_Res_Success)
800020da:	19 a9       	ld.ub	r9,r12[0x2]
800020dc:	30 08       	mov	r8,0
800020de:	f0 09 18 00 	cp.b	r9,r8
800020e2:	c1 91       	brne	80002114 <EnOB_reply_func+0x40>
	{
		if (xcmp->u8[1] == EN_OB_Enter)
800020e4:	19 b8       	ld.ub	r8,r12[0x3]
800020e6:	30 19       	mov	r9,1
800020e8:	f2 08 18 00 	cp.b	r8,r9
800020ec:	c0 61       	brne	800020f8 <EnOB_reply_func+0x24>
		{
		
			log("\n\r En_OB_Enter OK \n\r");
800020ee:	49 0c       	lddpc	r12,8000212c <EnOB_reply_func+0x58>
800020f0:	f0 1f 00 10 	mcall	80002130 <EnOB_reply_func+0x5c>
800020f4:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else if (xcmp->u8[1] == EN_OB_Exit )
800020f8:	58 08       	cp.w	r8,0
800020fa:	c0 61       	brne	80002106 <EnOB_reply_func+0x32>
		{
			log("\n\r En_OB_Exit OK \n\r");
800020fc:	48 ec       	lddpc	r12,80002134 <EnOB_reply_func+0x60>
800020fe:	f0 1f 00 0d 	mcall	80002130 <EnOB_reply_func+0x5c>
80002102:	e3 cd 80 80 	ldm	sp++,r7,pc
		}
		else
		{
			
			log("\n\r En_OB_Control: %x \n\r", xcmp->u8[1]);
80002106:	1a d8       	st.w	--sp,r8
80002108:	48 cc       	lddpc	r12,80002138 <EnOB_reply_func+0x64>
8000210a:	f0 1f 00 0a 	mcall	80002130 <EnOB_reply_func+0x5c>
8000210e:	2f fd       	sub	sp,-4
80002110:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r En_OB_Control error \n\r");
80002114:	48 ac       	lddpc	r12,8000213c <EnOB_reply_func+0x68>
80002116:	f0 1f 00 07 	mcall	80002130 <EnOB_reply_func+0x5c>
		log("\n\r En_OB_result: %x \n\r", xcmp->u8[0]);
8000211a:	0f a8       	ld.ub	r8,r7[0x2]
8000211c:	1a d8       	st.w	--sp,r8
8000211e:	48 9c       	lddpc	r12,80002140 <EnOB_reply_func+0x6c>
80002120:	f0 1f 00 04 	mcall	80002130 <EnOB_reply_func+0x5c>
80002124:	2f fd       	sub	sp,-4
80002126:	e3 cd 80 80 	ldm	sp++,r7,pc
8000212a:	00 00       	add	r0,r0
8000212c:	80 00       	ld.sh	r0,r0[0x0]
8000212e:	d0 80       	acall	0x8
80002130:	80 00       	ld.sh	r0,r0[0x0]
80002132:	6f 6c       	ld.w	r12,r7[0x58]
80002134:	80 00       	ld.sh	r0,r0[0x0]
80002136:	d0 98       	*unknown*
80002138:	80 00       	ld.sh	r0,r0[0x0]
8000213a:	d0 ac       	*unknown*
8000213c:	80 00       	ld.sh	r0,r0[0x0]
8000213e:	d0 c4       	*unknown*
80002140:	80 00       	ld.sh	r0,r0[0x0]
80002142:	d0 e0       	acall	0xe

80002144 <SingleDetection_brdcst_func>:
	
}


void SingleDetection_brdcst_func(xcmp_fragment_t * xcmp)
{
80002144:	eb cd 40 80 	pushm	r7,lr
80002148:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == 0x11)
8000214a:	19 a9       	ld.ub	r9,r12[0x2]
8000214c:	31 18       	mov	r8,17
8000214e:	f0 09 18 00 	cp.b	r9,r8
80002152:	c0 91       	brne	80002164 <SingleDetection_brdcst_func+0x20>
	{
		log("\n\r DMR_CSBK OK \n\r");
80002154:	48 ac       	lddpc	r12,8000217c <SingleDetection_brdcst_func+0x38>
80002156:	f0 1f 00 0b 	mcall	80002180 <SingleDetection_brdcst_func+0x3c>
		get_time_okay = TRUE;
8000215a:	30 19       	mov	r9,1
8000215c:	48 a8       	lddpc	r8,80002184 <SingleDetection_brdcst_func+0x40>
8000215e:	b0 89       	st.b	r8[0x0],r9
80002160:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	//if(xcmp->u8[1] == 0x11)
	else
	{
		log("SIGBRCST error\n");
80002164:	48 9c       	lddpc	r12,80002188 <SingleDetection_brdcst_func+0x44>
80002166:	f0 1f 00 07 	mcall	80002180 <SingleDetection_brdcst_func+0x3c>
		log("\Signal_type: %X \n\r", xcmp->u8[0] );
8000216a:	0f a8       	ld.ub	r8,r7[0x2]
8000216c:	1a d8       	st.w	--sp,r8
8000216e:	48 8c       	lddpc	r12,8000218c <SingleDetection_brdcst_func+0x48>
80002170:	f0 1f 00 04 	mcall	80002180 <SingleDetection_brdcst_func+0x3c>
80002174:	2f fd       	sub	sp,-4
80002176:	e3 cd 80 80 	ldm	sp++,r7,pc
8000217a:	00 00       	add	r0,r0
8000217c:	80 00       	ld.sh	r0,r0[0x0]
8000217e:	d0 f8       	*unknown*
80002180:	80 00       	ld.sh	r0,r0[0x0]
80002182:	6f 6c       	ld.w	r12,r7[0x58]
80002184:	00 00       	add	r0,r0
80002186:	00 04       	add	r4,r0
80002188:	80 00       	ld.sh	r0,r0[0x0]
8000218a:	d1 0c       	*unknown*
8000218c:	80 00       	ld.sh	r0,r0[0x0]
8000218e:	d1 1c       	*unknown*

80002190 <ButtonConfig_brdcst_func>:
	
}


void ButtonConfig_brdcst_func(xcmp_fragment_t * xcmp)
{
80002190:	d4 31       	pushm	r0-r7,lr
	U8 Num_Button =0;
	U8 i = 0 ;
	/*point to xcmp payload*/
	ButtonConfig_brdcst_t  *ptr = (ButtonConfig_brdcst_t* )xcmp->u8;
80002192:	f8 c7 ff fe 	sub	r7,r12,-2
	
	Num_Button = ptr->NumOfButtons;
80002196:	0f 95       	ld.ub	r5,r7[0x1]
	
	log("\n\r ButtonConfig_broadcast  \n\r"  );
80002198:	4a bc       	lddpc	r12,80002244 <ButtonConfig_brdcst_func+0xb4>
8000219a:	f0 1f 00 2c 	mcall	80002248 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r Function: %X \n\r" , ptr->Function );
8000219e:	0f 88       	ld.ub	r8,r7[0x0]
800021a0:	1a d8       	st.w	--sp,r8
800021a2:	4a bc       	lddpc	r12,8000224c <ButtonConfig_brdcst_func+0xbc>
800021a4:	f0 1f 00 29 	mcall	80002248 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
800021a8:	1a d5       	st.w	--sp,r5
800021aa:	4a ac       	lddpc	r12,80002250 <ButtonConfig_brdcst_func+0xc0>
800021ac:	f0 1f 00 27 	mcall	80002248 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
800021b0:	0f a8       	ld.ub	r8,r7[0x2]
800021b2:	1a d8       	st.w	--sp,r8
800021b4:	4a 8c       	lddpc	r12,80002254 <ButtonConfig_brdcst_func+0xc4>
800021b6:	f0 1f 00 25 	mcall	80002248 <ButtonConfig_brdcst_func+0xb8>
	
	for (i; i<Num_Button; i++)
800021ba:	2f dd       	sub	sp,-12
800021bc:	58 05       	cp.w	r5,0
800021be:	c4 10       	breq	80002240 <ButtonConfig_brdcst_func+0xb0>
800021c0:	30 06       	mov	r6,0
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
800021c2:	4a 64       	lddpc	r4,80002258 <ButtonConfig_brdcst_func+0xc8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
800021c4:	4a 63       	lddpc	r3,8000225c <ButtonConfig_brdcst_func+0xcc>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
800021c6:	4a 72       	lddpc	r2,80002260 <ButtonConfig_brdcst_func+0xd0>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
800021c8:	4a 71       	lddpc	r1,80002264 <ButtonConfig_brdcst_func+0xd4>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
800021ca:	4a 80       	lddpc	r0,80002268 <ButtonConfig_brdcst_func+0xd8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
800021cc:	0f b9       	ld.ub	r9,r7[0x3]
800021ce:	0f c8       	ld.ub	r8,r7[0x4]
800021d0:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800021d4:	1a d8       	st.w	--sp,r8
800021d6:	1a d6       	st.w	--sp,r6
800021d8:	08 9c       	mov	r12,r4
800021da:	f0 1f 00 1c 	mcall	80002248 <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
800021de:	0f d9       	ld.ub	r9,r7[0x5]
800021e0:	0f e8       	ld.ub	r8,r7[0x6]
800021e2:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800021e6:	1a d8       	st.w	--sp,r8
800021e8:	1a d6       	st.w	--sp,r6
800021ea:	06 9c       	mov	r12,r3
800021ec:	f0 1f 00 17 	mcall	80002248 <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
800021f0:	0f f9       	ld.ub	r9,r7[0x7]
800021f2:	ef 38 00 08 	ld.ub	r8,r7[8]
800021f6:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800021fa:	1a d8       	st.w	--sp,r8
800021fc:	1a d6       	st.w	--sp,r6
800021fe:	04 9c       	mov	r12,r2
80002200:	f0 1f 00 12 	mcall	80002248 <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
80002204:	ef 39 00 09 	ld.ub	r9,r7[9]
80002208:	ef 38 00 0a 	ld.ub	r8,r7[10]
8000220c:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002210:	1a d8       	st.w	--sp,r8
80002212:	1a d6       	st.w	--sp,r6
80002214:	02 9c       	mov	r12,r1
80002216:	f0 1f 00 0d 	mcall	80002248 <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
8000221a:	2f 8d       	sub	sp,-32
8000221c:	ef 39 00 0b 	ld.ub	r9,r7[11]
80002220:	ef 38 00 0c 	ld.ub	r8,r7[12]
80002224:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002228:	1a d8       	st.w	--sp,r8
8000222a:	1a d6       	st.w	--sp,r6
8000222c:	00 9c       	mov	r12,r0
8000222e:	f0 1f 00 07 	mcall	80002248 <ButtonConfig_brdcst_func+0xb8>
80002232:	2f f6       	sub	r6,-1
80002234:	2f 67       	sub	r7,-10
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
80002236:	2f ed       	sub	sp,-8
80002238:	ec 05 18 00 	cp.b	r5,r6
8000223c:	fe 9b ff c8 	brhi	800021cc <ButtonConfig_brdcst_func+0x3c>
80002240:	d8 32       	popm	r0-r7,pc
80002242:	00 00       	add	r0,r0
80002244:	80 00       	ld.sh	r0,r0[0x0]
80002246:	d1 30       	acall	0x13
80002248:	80 00       	ld.sh	r0,r0[0x0]
8000224a:	6f 6c       	ld.w	r12,r7[0x58]
8000224c:	80 00       	ld.sh	r0,r0[0x0]
8000224e:	d1 50       	acall	0x15
80002250:	80 00       	ld.sh	r0,r0[0x0]
80002252:	d1 64       	*unknown*
80002254:	80 00       	ld.sh	r0,r0[0x0]
80002256:	d1 7c       	*unknown*
80002258:	80 00       	ld.sh	r0,r0[0x0]
8000225a:	d1 9c       	*unknown*
8000225c:	80 00       	ld.sh	r0,r0[0x0]
8000225e:	d1 c4       	*unknown*
80002260:	80 00       	ld.sh	r0,r0[0x0]
80002262:	d1 ec       	*unknown*
80002264:	80 00       	ld.sh	r0,r0[0x0]
80002266:	d2 10       	acall	0x21
80002268:	80 00       	ld.sh	r0,r0[0x0]
8000226a:	d2 38       	*unknown*

8000226c <ButtonConfig_reply_func>:
	}
	
}

void ButtonConfig_reply_func(xcmp_fragment_t * xcmp)
{
8000226c:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	ButtonConfig_reply_t *ptr = (ButtonConfig_reply_t* )(xcmp->u8);
80002270:	f8 c7 ff fe 	sub	r7,r12,-2
	if (ptr->Result == xcmp_Res_Success)
80002274:	0f 89       	ld.ub	r9,r7[0x0]
80002276:	30 08       	mov	r8,0
80002278:	f0 09 18 00 	cp.b	r9,r8
8000227c:	c0 c1       	brne	80002294 <ButtonConfig_reply_func+0x28>
	{
		log("\n\r Button_Config OK \n\r");
8000227e:	48 9c       	lddpc	r12,800022a0 <ButtonConfig_reply_func+0x34>
80002280:	f0 1f 00 09 	mcall	800022a4 <ButtonConfig_reply_func+0x38>
		
		log("\n\r Function: %X \n\r" , ptr->Function );
80002284:	0f 98       	ld.ub	r8,r7[0x1]
80002286:	1a d8       	st.w	--sp,r8
80002288:	48 8c       	lddpc	r12,800022a8 <ButtonConfig_reply_func+0x3c>
8000228a:	f0 1f 00 07 	mcall	800022a4 <ButtonConfig_reply_func+0x38>
8000228e:	2f fd       	sub	sp,-4
80002290:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r Button_Request error \n\r");
80002294:	48 6c       	lddpc	r12,800022ac <ButtonConfig_reply_func+0x40>
80002296:	f0 1f 00 04 	mcall	800022a4 <ButtonConfig_reply_func+0x38>
8000229a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000229e:	00 00       	add	r0,r0
800022a0:	80 00       	ld.sh	r0,r0[0x0]
800022a2:	d2 5c       	*unknown*
800022a4:	80 00       	ld.sh	r0,r0[0x0]
800022a6:	6f 6c       	ld.w	r12,r7[0x58]
800022a8:	80 00       	ld.sh	r0,r0[0x0]
800022aa:	d1 50       	acall	0x15
800022ac:	80 00       	ld.sh	r0,r0[0x0]
800022ae:	d2 74       	*unknown*

800022b0 <BatteryLevel_brdcst_func>:
	
}


void BatteryLevel_brdcst_func(xcmp_fragment_t * xcmp)
{
800022b0:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	BatteryLevel_brdcast_t *ptr = (BatteryLevel_brdcast_t* )(xcmp->u8);
800022b4:	f8 c7 ff fe 	sub	r7,r12,-2
	if(ptr->State == Battery_Okay)
800022b8:	0f 89       	ld.ub	r9,r7[0x0]
800022ba:	30 08       	mov	r8,0
800022bc:	f0 09 18 00 	cp.b	r9,r8
800022c0:	c0 51       	brne	800022ca <BatteryLevel_brdcst_func+0x1a>
		log("\n Battery Okay\n");
800022c2:	48 7c       	lddpc	r12,800022dc <BatteryLevel_brdcst_func+0x2c>
800022c4:	f0 1f 00 07 	mcall	800022e0 <BatteryLevel_brdcst_func+0x30>
800022c8:	c0 48       	rjmp	800022d0 <BatteryLevel_brdcst_func+0x20>
	else
		log("\n Battery Low !!!\n");
800022ca:	48 7c       	lddpc	r12,800022e4 <BatteryLevel_brdcst_func+0x34>
800022cc:	f0 1f 00 05 	mcall	800022e0 <BatteryLevel_brdcst_func+0x30>
		
	//log("\n Battery charge: %X \n" , ptr->Charge);
	//log("\n Battery voltage: %X \n" , ptr->Voltage);
	
	Battery_Flag = ptr->State;
800022d0:	0f 89       	ld.ub	r9,r7[0x0]
800022d2:	48 68       	lddpc	r8,800022e8 <BatteryLevel_brdcst_func+0x38>
800022d4:	b0 89       	st.b	r8[0x0],r9

}
800022d6:	e3 cd 80 80 	ldm	sp++,r7,pc
800022da:	00 00       	add	r0,r0
800022dc:	80 00       	ld.sh	r0,r0[0x0]
800022de:	d2 90       	acall	0x29
800022e0:	80 00       	ld.sh	r0,r0[0x0]
800022e2:	6f 6c       	ld.w	r12,r7[0x58]
800022e4:	80 00       	ld.sh	r0,r0[0x0]
800022e6:	d2 a0       	acall	0x2a
800022e8:	00 00       	add	r0,r0
800022ea:	0a 41       	or	r1,r5

800022ec <ShutDown_brdcst_func>:
		log("ID:  %X \n", xcmp->u8[2]);
	}
	
}
void ShutDown_brdcst_func(xcmp_fragment_t * xcmp)
{
800022ec:	d4 01       	pushm	lr
	if (xcmp->u8[0] == Shut_Down_Device)
800022ee:	19 a8       	ld.ub	r8,r12[0x2]
800022f0:	30 19       	mov	r9,1
800022f2:	f2 08 18 00 	cp.b	r8,r9
800022f6:	c0 51       	brne	80002300 <ShutDown_brdcst_func+0x14>
	{
		log("Shut_Down_Device \n");
800022f8:	48 6c       	lddpc	r12,80002310 <ShutDown_brdcst_func+0x24>
800022fa:	f0 1f 00 07 	mcall	80002314 <ShutDown_brdcst_func+0x28>
800022fe:	d8 02       	popm	pc
		
	}
	else if(xcmp->u8[0] == Reset_Device)
80002300:	30 29       	mov	r9,2
80002302:	f2 08 18 00 	cp.b	r8,r9
80002306:	c0 41       	brne	8000230e <ShutDown_brdcst_func+0x22>
	{
		log("Reset_Device \n");
80002308:	48 4c       	lddpc	r12,80002318 <ShutDown_brdcst_func+0x2c>
8000230a:	f0 1f 00 03 	mcall	80002314 <ShutDown_brdcst_func+0x28>
8000230e:	d8 02       	popm	pc
80002310:	80 00       	ld.sh	r0,r0[0x0]
80002312:	d2 b4       	*unknown*
80002314:	80 00       	ld.sh	r0,r0[0x0]
80002316:	6f 6c       	ld.w	r12,r7[0x58]
80002318:	80 00       	ld.sh	r0,r0[0x0]
8000231a:	d2 c8       	*unknown*

8000231c <DataSession_reply_func>:
	
	
}

void DataSession_reply_func(xcmp_fragment_t * xcmp)
{
8000231c:	eb cd 40 80 	pushm	r7,lr
80002320:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
80002322:	19 a9       	ld.ub	r9,r12[0x2]
80002324:	30 08       	mov	r8,0
80002326:	f0 09 18 00 	cp.b	r9,r8
8000232a:	c0 61       	brne	80002336 <DataSession_reply_func+0x1a>
	{
		log("DATArep OK \n");
8000232c:	48 dc       	lddpc	r12,80002360 <DataSession_reply_func+0x44>
8000232e:	f0 1f 00 0e 	mcall	80002364 <DataSession_reply_func+0x48>
80002332:	e3 cd 80 80 	ldm	sp++,r7,pc
		//log("ID: %X \n", xcmp->u8[2]);
		
	}
	else
	{	
		log("DATArep error \n");
80002336:	48 dc       	lddpc	r12,80002368 <DataSession_reply_func+0x4c>
80002338:	f0 1f 00 0b 	mcall	80002364 <DataSession_reply_func+0x48>
		log("Result:  %X \n", xcmp->u8[0]);
8000233c:	0f a8       	ld.ub	r8,r7[0x2]
8000233e:	1a d8       	st.w	--sp,r8
80002340:	48 bc       	lddpc	r12,8000236c <DataSession_reply_func+0x50>
80002342:	f0 1f 00 09 	mcall	80002364 <DataSession_reply_func+0x48>
		log("Func:  %X \n", xcmp->u8[1]);
80002346:	0f b8       	ld.ub	r8,r7[0x3]
80002348:	1a d8       	st.w	--sp,r8
8000234a:	48 ac       	lddpc	r12,80002370 <DataSession_reply_func+0x54>
8000234c:	f0 1f 00 06 	mcall	80002364 <DataSession_reply_func+0x48>
		log("ID:  %X \n", xcmp->u8[2]);
80002350:	0f c8       	ld.ub	r8,r7[0x4]
80002352:	1a d8       	st.w	--sp,r8
80002354:	48 8c       	lddpc	r12,80002374 <DataSession_reply_func+0x58>
80002356:	f0 1f 00 04 	mcall	80002364 <DataSession_reply_func+0x48>
8000235a:	2f dd       	sub	sp,-12
8000235c:	e3 cd 80 80 	ldm	sp++,r7,pc
80002360:	80 00       	ld.sh	r0,r0[0x0]
80002362:	d2 d8       	*unknown*
80002364:	80 00       	ld.sh	r0,r0[0x0]
80002366:	6f 6c       	ld.w	r12,r7[0x58]
80002368:	80 00       	ld.sh	r0,r0[0x0]
8000236a:	d2 e8       	*unknown*
8000236c:	80 00       	ld.sh	r0,r0[0x0]
8000236e:	d2 f8       	*unknown*
80002370:	80 00       	ld.sh	r0,r0[0x0]
80002372:	d3 08       	*unknown*
80002374:	80 00       	ld.sh	r0,r0[0x0]
80002376:	d3 14       	*unknown*

80002378 <CallControl_brdcst_func>:
	
}


void CallControl_brdcst_func(xcmp_fragment_t * xcmp)
{
80002378:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	CallControl_brdcst_t *ptr = (CallControl_brdcst_t* )xcmp->u8;
8000237c:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  CallControl brst \n\r ");
	//log("\n\r  Call_type: %x \n\r ", ptr->Calltype );
	log("\n\r  Call_state: %x \n\r ", ptr->Callstate );
80002380:	0f 98       	ld.ub	r8,r7[0x1]
80002382:	1a d8       	st.w	--sp,r8
80002384:	48 bc       	lddpc	r12,800023b0 <CallControl_brdcst_func+0x38>
80002386:	f0 1f 00 0c 	mcall	800023b4 <CallControl_brdcst_func+0x3c>
	if (ptr->Callstate == Call_Ended)//0x03
8000238a:	2f fd       	sub	sp,-4
8000238c:	0f 99       	ld.ub	r9,r7[0x1]
8000238e:	30 38       	mov	r8,3
80002390:	f0 09 18 00 	cp.b	r9,r8
80002394:	c0 41       	brne	8000239c <CallControl_brdcst_func+0x24>
	{
		//恢复正常语音路径通道
		//xcmp_audio_route_revert();
		Call_Begin = 0;
80002396:	30 09       	mov	r9,0
80002398:	48 88       	lddpc	r8,800023b8 <CallControl_brdcst_func+0x40>
8000239a:	b0 89       	st.b	r8[0x0],r9
		
	}
	
	if (ptr->Callstate == Call_Initiated)//0x04
8000239c:	0f 99       	ld.ub	r9,r7[0x1]
8000239e:	30 48       	mov	r8,4
800023a0:	f0 09 18 00 	cp.b	r9,r8
800023a4:	c0 41       	brne	800023ac <CallControl_brdcst_func+0x34>
	{
		Call_Begin = 1;
800023a6:	30 19       	mov	r9,1
800023a8:	48 48       	lddpc	r8,800023b8 <CallControl_brdcst_func+0x40>
800023aa:	b0 89       	st.b	r8[0x0],r9
800023ac:	e3 cd 80 80 	ldm	sp++,r7,pc
800023b0:	80 00       	ld.sh	r0,r0[0x0]
800023b2:	d3 20       	acall	0x32
800023b4:	80 00       	ld.sh	r0,r0[0x0]
800023b6:	6f 6c       	ld.w	r12,r7[0x58]
800023b8:	00 00       	add	r0,r0
800023ba:	0a 4a       	or	r10,r5

800023bc <TransmitControl_brdcst_func>:

}


void TransmitControl_brdcst_func(xcmp_fragment_t * xcmp)
{
800023bc:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	TransmitControl_brdcast_t *ptr = (TransmitControl_brdcast_t* )xcmp->u8;
800023c0:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  TransmitControl broadcast \n\r ");
	//log("\n\r  Mode_Of_Operation: %x \n\r ", ptr->Mode_Of_Operation );
	if (ptr->State == 0x00)
800023c4:	0f 99       	ld.ub	r9,r7[0x1]
800023c6:	30 08       	mov	r8,0
800023c8:	f0 09 18 00 	cp.b	r9,r8
800023cc:	c0 71       	brne	800023da <TransmitControl_brdcst_func+0x1e>
	{
		log("\n\r  Standby-Receive \n\r ");
800023ce:	48 ac       	lddpc	r12,800023f4 <TransmitControl_brdcst_func+0x38>
800023d0:	f0 1f 00 0a 	mcall	800023f8 <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 0;
800023d4:	30 09       	mov	r9,0
800023d6:	48 a8       	lddpc	r8,800023fc <TransmitControl_brdcst_func+0x40>
800023d8:	b0 89       	st.b	r8[0x0],r9
	}
	if (ptr->State == 0x01)
800023da:	0f 99       	ld.ub	r9,r7[0x1]
800023dc:	30 18       	mov	r8,1
800023de:	f0 09 18 00 	cp.b	r9,r8
800023e2:	c0 71       	brne	800023f0 <TransmitControl_brdcst_func+0x34>
	{
		log("\n\r  Transmit \n\r ");
800023e4:	48 7c       	lddpc	r12,80002400 <TransmitControl_brdcst_func+0x44>
800023e6:	f0 1f 00 05 	mcall	800023f8 <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 1;
800023ea:	30 19       	mov	r9,1
800023ec:	48 48       	lddpc	r8,800023fc <TransmitControl_brdcst_func+0x40>
800023ee:	b0 89       	st.b	r8[0x0],r9
800023f0:	e3 cd 80 80 	ldm	sp++,r7,pc
800023f4:	80 00       	ld.sh	r0,r0[0x0]
800023f6:	d3 38       	*unknown*
800023f8:	80 00       	ld.sh	r0,r0[0x0]
800023fa:	6f 6c       	ld.w	r12,r7[0x58]
800023fc:	00 00       	add	r0,r0
800023fe:	0a 49       	or	r9,r5
80002400:	80 00       	ld.sh	r0,r0[0x0]
80002402:	d3 50       	acall	0x35

80002404 <TransmitControl_reply_func>:




void TransmitControl_reply_func(xcmp_fragment_t * xcmp)
{
80002404:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	TransmitControl_reply_t *ptr = (TransmitControl_reply_t* )xcmp->u8;
80002408:	f8 c7 ff fe 	sub	r7,r12,-2
	
	if (ptr->Result == xcmp_Res_Success)
8000240c:	0f 89       	ld.ub	r9,r7[0x0]
8000240e:	30 08       	mov	r8,0
80002410:	f0 09 18 00 	cp.b	r9,r8
80002414:	c1 61       	brne	80002440 <TransmitControl_reply_func+0x3c>
	{
		
		log("\n\r  TransmitControl OK \n\r ");
80002416:	48 ec       	lddpc	r12,8000244c <TransmitControl_reply_func+0x48>
80002418:	f0 1f 00 0e 	mcall	80002450 <TransmitControl_reply_func+0x4c>
		log("\n\r Function: %x \n\r", ptr->Function);
8000241c:	0f 98       	ld.ub	r8,r7[0x1]
8000241e:	1a d8       	st.w	--sp,r8
80002420:	48 dc       	lddpc	r12,80002454 <TransmitControl_reply_func+0x50>
80002422:	f0 1f 00 0c 	mcall	80002450 <TransmitControl_reply_func+0x4c>
		log("\n\r Mode of Operation: %x \n\r", ptr->Mode_Of_Operation);
80002426:	0f a8       	ld.ub	r8,r7[0x2]
80002428:	1a d8       	st.w	--sp,r8
8000242a:	48 cc       	lddpc	r12,80002458 <TransmitControl_reply_func+0x54>
8000242c:	f0 1f 00 09 	mcall	80002450 <TransmitControl_reply_func+0x4c>
		log("\n\r State: %x \n\r", ptr->State);
80002430:	0f b8       	ld.ub	r8,r7[0x3]
80002432:	1a d8       	st.w	--sp,r8
80002434:	48 ac       	lddpc	r12,8000245c <TransmitControl_reply_func+0x58>
80002436:	f0 1f 00 07 	mcall	80002450 <TransmitControl_reply_func+0x4c>
8000243a:	2f dd       	sub	sp,-12
8000243c:	e3 cd 80 80 	ldm	sp++,r7,pc
		
		//Silent_flag = 1;
	}
	else
	{
		log("TransmitControl error");
80002440:	48 8c       	lddpc	r12,80002460 <TransmitControl_reply_func+0x5c>
80002442:	f0 1f 00 04 	mcall	80002450 <TransmitControl_reply_func+0x4c>
80002446:	e3 cd 80 80 	ldm	sp++,r7,pc
8000244a:	00 00       	add	r0,r0
8000244c:	80 00       	ld.sh	r0,r0[0x0]
8000244e:	d3 64       	*unknown*
80002450:	80 00       	ld.sh	r0,r0[0x0]
80002452:	6f 6c       	ld.w	r12,r7[0x58]
80002454:	80 00       	ld.sh	r0,r0[0x0]
80002456:	d3 80       	acall	0x38
80002458:	80 00       	ld.sh	r0,r0[0x0]
8000245a:	d3 94       	*unknown*
8000245c:	80 00       	ld.sh	r0,r0[0x0]
8000245e:	d3 b0       	acall	0x3b
80002460:	80 00       	ld.sh	r0,r0[0x0]
80002462:	d3 c0       	acall	0x3c

80002464 <AudioRoutingControl_reply_func>:
	
}


void AudioRoutingControl_reply_func(xcmp_fragment_t * xcmp)
{
80002464:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
80002466:	19 a9       	ld.ub	r9,r12[0x2]
80002468:	30 08       	mov	r8,0
8000246a:	f0 09 18 00 	cp.b	r9,r8
8000246e:	c0 51       	brne	80002478 <AudioRoutingControl_reply_func+0x14>
	{
		log("AudioRouting OK");
80002470:	48 4c       	lddpc	r12,80002480 <AudioRoutingControl_reply_func+0x1c>
80002472:	f0 1f 00 05 	mcall	80002484 <AudioRoutingControl_reply_func+0x20>
80002476:	d8 02       	popm	pc
		//xcmp_IdleTestTone();
		//Speaker_is_unmute = 1;
	}
	else
	{
		log("AudioRouting error");
80002478:	48 4c       	lddpc	r12,80002488 <AudioRoutingControl_reply_func+0x24>
8000247a:	f0 1f 00 03 	mcall	80002484 <AudioRoutingControl_reply_func+0x20>
8000247e:	d8 02       	popm	pc
80002480:	80 00       	ld.sh	r0,r0[0x0]
80002482:	d3 d8       	*unknown*
80002484:	80 00       	ld.sh	r0,r0[0x0]
80002486:	6f 6c       	ld.w	r12,r7[0x58]
80002488:	80 00       	ld.sh	r0,r0[0x0]
8000248a:	d3 e8       	*unknown*

8000248c <Volume_reply_func>:
	
}


void Volume_reply_func(xcmp_fragment_t * xcmp)
{
8000248c:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	VolumeControl_reply_t *ptr = (VolumeControl_reply_t* )xcmp->u8;
80002490:	f8 c7 ff fe 	sub	r7,r12,-2
	
		if (ptr->Result == xcmp_Res_Success)
80002494:	0f 89       	ld.ub	r9,r7[0x0]
80002496:	30 08       	mov	r8,0
80002498:	f0 09 18 00 	cp.b	r9,r8
8000249c:	c1 b1       	brne	800024d2 <Volume_reply_func+0x46>
		{
			if (ptr->Function == Enable_IntelligentAudio)
8000249e:	0f b8       	ld.ub	r8,r7[0x3]
800024a0:	31 09       	mov	r9,16
800024a2:	f2 08 18 00 	cp.b	r8,r9
800024a6:	c0 f1       	brne	800024c4 <Volume_reply_func+0x38>
			{
				log("\n\r Enable_IA OK \n\r");
800024a8:	48 dc       	lddpc	r12,800024dc <Volume_reply_func+0x50>
800024aa:	f0 1f 00 0e 	mcall	800024e0 <Volume_reply_func+0x54>
				log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
800024ae:	0f 99       	ld.ub	r9,r7[0x1]
800024b0:	0f a8       	ld.ub	r8,r7[0x2]
800024b2:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800024b6:	1a d8       	st.w	--sp,r8
800024b8:	48 bc       	lddpc	r12,800024e4 <Volume_reply_func+0x58>
800024ba:	f0 1f 00 0a 	mcall	800024e0 <Volume_reply_func+0x54>
800024be:	2f fd       	sub	sp,-4
800024c0:	e3 cd 80 80 	ldm	sp++,r7,pc
	
			}
			else
			{
				
				log("\n\r VolumeControl: %x \n\r", ptr->Function);
800024c4:	1a d8       	st.w	--sp,r8
800024c6:	48 9c       	lddpc	r12,800024e8 <Volume_reply_func+0x5c>
800024c8:	f0 1f 00 06 	mcall	800024e0 <Volume_reply_func+0x54>
800024cc:	2f fd       	sub	sp,-4
800024ce:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		
		else
		{
			log("\n\r Enable_IA error \n\r");
800024d2:	48 7c       	lddpc	r12,800024ec <Volume_reply_func+0x60>
800024d4:	f0 1f 00 03 	mcall	800024e0 <Volume_reply_func+0x54>
800024d8:	e3 cd 80 80 	ldm	sp++,r7,pc
800024dc:	80 00       	ld.sh	r0,r0[0x0]
800024de:	d3 fc       	*unknown*
800024e0:	80 00       	ld.sh	r0,r0[0x0]
800024e2:	6f 6c       	ld.w	r12,r7[0x58]
800024e4:	80 00       	ld.sh	r0,r0[0x0]
800024e6:	d4 10       	acall	0x41
800024e8:	80 00       	ld.sh	r0,r0[0x0]
800024ea:	d4 2c       	*unknown*
800024ec:	80 00       	ld.sh	r0,r0[0x0]
800024ee:	d4 44       	*unknown*

800024f0 <spk_brdcst_func>:
		log("spk error");
	}
}

void spk_brdcst_func(xcmp_fragment_t * xcmp)
{
800024f0:	d4 01       	pushm	lr
	if (xcmp->u8[3] == xcmp_Res_Success)//0x0000:mute
800024f2:	19 d9       	ld.ub	r9,r12[0x5]
800024f4:	30 08       	mov	r8,0
800024f6:	f0 09 18 00 	cp.b	r9,r8
800024fa:	c0 81       	brne	8000250a <spk_brdcst_func+0x1a>
	{
		Speaker_is_unmute =0;
800024fc:	10 99       	mov	r9,r8
800024fe:	48 78       	lddpc	r8,80002518 <spk_brdcst_func+0x28>
80002500:	b0 89       	st.b	r8[0x0],r9
		//Silent_flag = 0;
		log("spk_s_close ");
80002502:	48 7c       	lddpc	r12,8000251c <spk_brdcst_func+0x2c>
80002504:	f0 1f 00 07 	mcall	80002520 <spk_brdcst_func+0x30>
80002508:	d8 02       	popm	pc
		
	}
	else
	{
		//Silent_flag = 1;
		Speaker_is_unmute = 1;
8000250a:	30 19       	mov	r9,1
8000250c:	48 38       	lddpc	r8,80002518 <spk_brdcst_func+0x28>
8000250e:	b0 89       	st.b	r8[0x0],r9
		log("spk_s_open ");	
80002510:	48 5c       	lddpc	r12,80002524 <spk_brdcst_func+0x34>
80002512:	f0 1f 00 04 	mcall	80002520 <spk_brdcst_func+0x30>
80002516:	d8 02       	popm	pc
80002518:	00 00       	add	r0,r0
8000251a:	0a 40       	or	r0,r5
8000251c:	80 00       	ld.sh	r0,r0[0x0]
8000251e:	d4 5c       	*unknown*
80002520:	80 00       	ld.sh	r0,r0[0x0]
80002522:	6f 6c       	ld.w	r12,r7[0x58]
80002524:	80 00       	ld.sh	r0,r0[0x0]
80002526:	d4 6c       	*unknown*

80002528 <spk_reply_func>:
			
	
}

void spk_reply_func(xcmp_fragment_t * xcmp)
{
80002528:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
8000252a:	19 a9       	ld.ub	r9,r12[0x2]
8000252c:	30 08       	mov	r8,0
8000252e:	f0 09 18 00 	cp.b	r9,r8
80002532:	c0 f1       	brne	80002550 <spk_reply_func+0x28>
	{
		
		if(xcmp->u8[4])
80002534:	19 e9       	ld.ub	r9,r12[0x6]
80002536:	f0 09 18 00 	cp.b	r9,r8
8000253a:	c0 40       	breq	80002542 <spk_reply_func+0x1a>
		{
			Speaker_is_unmute = 1;
8000253c:	30 19       	mov	r9,1
8000253e:	48 98       	lddpc	r8,80002560 <spk_reply_func+0x38>
80002540:	b0 89       	st.b	r8[0x0],r9
			
			//Silent_flag = 1;
		}
		log("spk OK -st%2x", xcmp->u8[4] );
80002542:	19 e8       	ld.ub	r8,r12[0x6]
80002544:	1a d8       	st.w	--sp,r8
80002546:	48 8c       	lddpc	r12,80002564 <spk_reply_func+0x3c>
80002548:	f0 1f 00 08 	mcall	80002568 <spk_reply_func+0x40>
8000254c:	2f fd       	sub	sp,-4
8000254e:	d8 02       	popm	pc
		
	}
	else
	{
		Speaker_is_unmute = 0;
80002550:	30 09       	mov	r9,0
80002552:	48 48       	lddpc	r8,80002560 <spk_reply_func+0x38>
80002554:	b0 89       	st.b	r8[0x0],r9
		log("spk error");
80002556:	48 6c       	lddpc	r12,8000256c <spk_reply_func+0x44>
80002558:	f0 1f 00 04 	mcall	80002568 <spk_reply_func+0x40>
8000255c:	d8 02       	popm	pc
8000255e:	00 00       	add	r0,r0
80002560:	00 00       	add	r0,r0
80002562:	0a 40       	or	r0,r5
80002564:	80 00       	ld.sh	r0,r0[0x0]
80002566:	d4 78       	*unknown*
80002568:	80 00       	ld.sh	r0,r0[0x0]
8000256a:	6f 6c       	ld.w	r12,r7[0x58]
8000256c:	80 00       	ld.sh	r0,r0[0x0]
8000256e:	d4 88       	*unknown*

80002570 <mic_brdcst_func>:
	
	
}

void mic_brdcst_func(xcmp_fragment_t * xcmp)
{
80002570:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_brdcast_t *ptr = (MicControl_brdcast_t* )xcmp->u8;
80002574:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r Mic_brdcst \n\r");		
	//log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
	//log("\n\r Signal_type: %x \n\r " ,  ptr->Signaling_Type);
	if (ptr->Mic_State == 0x00)
80002578:	0f a9       	ld.ub	r9,r7[0x2]
8000257a:	30 08       	mov	r8,0
8000257c:	f0 09 18 00 	cp.b	r9,r8
80002580:	c0 71       	brne	8000258e <mic_brdcst_func+0x1e>
	{
		log("\n\r Mic_Disabled \n\r");	
80002582:	48 dc       	lddpc	r12,800025b4 <mic_brdcst_func+0x44>
80002584:	f0 1f 00 0d 	mcall	800025b8 <mic_brdcst_func+0x48>
		Mic_is_Enabled = 0;
80002588:	30 09       	mov	r9,0
8000258a:	48 d8       	lddpc	r8,800025bc <mic_brdcst_func+0x4c>
8000258c:	b0 89       	st.b	r8[0x0],r9
	} 
	if(ptr->Mic_State == 0x11)
8000258e:	0f a9       	ld.ub	r9,r7[0x2]
80002590:	31 18       	mov	r8,17
80002592:	f0 09 18 00 	cp.b	r9,r8
80002596:	c0 d1       	brne	800025b0 <mic_brdcst_func+0x40>
	{
		log("\n\r Mic_Enabled \n\r");
80002598:	48 ac       	lddpc	r12,800025c0 <mic_brdcst_func+0x50>
8000259a:	f0 1f 00 08 	mcall	800025b8 <mic_brdcst_func+0x48>
		Mic_is_Enabled = 1;
8000259e:	48 89       	lddpc	r9,800025bc <mic_brdcst_func+0x4c>
800025a0:	30 18       	mov	r8,1
800025a2:	b2 88       	st.b	r9[0x0],r8
		
		if ((Mic_is_Enabled == 1) && (Call_Begin == 1))
800025a4:	13 89       	ld.ub	r9,r9[0x0]
800025a6:	f0 09 18 00 	cp.b	r9,r8
800025aa:	c0 31       	brne	800025b0 <mic_brdcst_func+0x40>
800025ac:	48 68       	lddpc	r8,800025c4 <mic_brdcst_func+0x54>
800025ae:	11 88       	ld.ub	r8,r8[0x0]
800025b0:	e3 cd 80 80 	ldm	sp++,r7,pc
800025b4:	80 00       	ld.sh	r0,r0[0x0]
800025b6:	d4 94       	*unknown*
800025b8:	80 00       	ld.sh	r0,r0[0x0]
800025ba:	6f 6c       	ld.w	r12,r7[0x58]
800025bc:	00 00       	add	r0,r0
800025be:	0a 5c       	eor	r12,r5
800025c0:	80 00       	ld.sh	r0,r0[0x0]
800025c2:	d4 a8       	*unknown*
800025c4:	00 00       	add	r0,r0
800025c6:	0a 4a       	or	r10,r5

800025c8 <mic_reply_func>:
	
	
}

void mic_reply_func(xcmp_fragment_t * xcmp)
{
800025c8:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_reply_t *ptr = (MicControl_reply_t* )xcmp->u8;
800025cc:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Mic_reply \n\r");
800025d0:	49 ac       	lddpc	r12,80002638 <mic_reply_func+0x70>
800025d2:	f0 1f 00 1b 	mcall	8000263c <mic_reply_func+0x74>
	if (ptr->Result == 0x00)
800025d6:	0f 89       	ld.ub	r9,r7[0x0]
800025d8:	30 08       	mov	r8,0
800025da:	f0 09 18 00 	cp.b	r9,r8
800025de:	c2 71       	brne	8000262c <mic_reply_func+0x64>
	{
		
		if (ptr->Function == Mic_Disable)
800025e0:	0f 98       	ld.ub	r8,r7[0x1]
800025e2:	30 29       	mov	r9,2
800025e4:	f2 08 18 00 	cp.b	r8,r9
800025e8:	c1 b1       	brne	8000261e <mic_reply_func+0x56>
		{
		
			log("\n\r Mic_close_ok \n\r " );
800025ea:	49 6c       	lddpc	r12,80002640 <mic_reply_func+0x78>
800025ec:	f0 1f 00 14 	mcall	8000263c <mic_reply_func+0x74>
			log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
800025f0:	0f a8       	ld.ub	r8,r7[0x2]
800025f2:	1a d8       	st.w	--sp,r8
800025f4:	49 4c       	lddpc	r12,80002644 <mic_reply_func+0x7c>
800025f6:	f0 1f 00 12 	mcall	8000263c <mic_reply_func+0x74>
			log("\n\r Signaling_type: %x \n\r " ,  ptr->Signaling_Type);
800025fa:	0f b8       	ld.ub	r8,r7[0x3]
800025fc:	1a d8       	st.w	--sp,r8
800025fe:	49 3c       	lddpc	r12,80002648 <mic_reply_func+0x80>
80002600:	f0 1f 00 0f 	mcall	8000263c <mic_reply_func+0x74>
			log("\n\r Mic_state: %x \n\r " ,  ptr->Mic_State);
80002604:	0f c8       	ld.ub	r8,r7[0x4]
80002606:	1a d8       	st.w	--sp,r8
80002608:	49 1c       	lddpc	r12,8000264c <mic_reply_func+0x84>
8000260a:	f0 1f 00 0d 	mcall	8000263c <mic_reply_func+0x74>
			log("\n\r Gain_offset: %x \n\r " ,  ptr->Gain_Offset);
8000260e:	0f d8       	ld.ub	r8,r7[0x5]
80002610:	1a d8       	st.w	--sp,r8
80002612:	49 0c       	lddpc	r12,80002650 <mic_reply_func+0x88>
80002614:	f0 1f 00 0a 	mcall	8000263c <mic_reply_func+0x74>
80002618:	2f cd       	sub	sp,-16
8000261a:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else
		{
			log("\n\r Mic_function: %x \n\r ", ptr->Function );
8000261e:	1a d8       	st.w	--sp,r8
80002620:	48 dc       	lddpc	r12,80002654 <mic_reply_func+0x8c>
80002622:	f0 1f 00 07 	mcall	8000263c <mic_reply_func+0x74>
80002626:	2f fd       	sub	sp,-4
80002628:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else 
	{
		
	
		log("\n\r Mic error \n\r");
8000262c:	48 bc       	lddpc	r12,80002658 <mic_reply_func+0x90>
8000262e:	f0 1f 00 04 	mcall	8000263c <mic_reply_func+0x74>
80002632:	e3 cd 80 80 	ldm	sp++,r7,pc
80002636:	00 00       	add	r0,r0
80002638:	80 00       	ld.sh	r0,r0[0x0]
8000263a:	d4 bc       	*unknown*
8000263c:	80 00       	ld.sh	r0,r0[0x0]
8000263e:	6f 6c       	ld.w	r12,r7[0x58]
80002640:	80 00       	ld.sh	r0,r0[0x0]
80002642:	d4 cc       	*unknown*
80002644:	80 00       	ld.sh	r0,r0[0x0]
80002646:	d4 e0       	acall	0x4e
80002648:	80 00       	ld.sh	r0,r0[0x0]
8000264a:	d4 f4       	*unknown*
8000264c:	80 00       	ld.sh	r0,r0[0x0]
8000264e:	d5 10       	acall	0x51
80002650:	80 00       	ld.sh	r0,r0[0x0]
80002652:	d5 28       	*unknown*
80002654:	80 00       	ld.sh	r0,r0[0x0]
80002656:	d5 40       	acall	0x54
80002658:	80 00       	ld.sh	r0,r0[0x0]
8000265a:	d5 58       	*unknown*

8000265c <dcm_brdcst_func>:
	}
}


void dcm_brdcst_func(xcmp_fragment_t * xcmp)
{
8000265c:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	DeviceControlMode_brdcst_t *ptr = (DeviceControlMode_brdcst_t* )xcmp->u8;
80002660:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Dcm_brdcst \n\r");		
80002664:	48 bc       	lddpc	r12,80002690 <dcm_brdcst_func+0x34>
80002666:	f0 1f 00 0c 	mcall	80002694 <dcm_brdcst_func+0x38>
	log("\n\r Function: %x \n\r " ,  ptr->Function);
8000266a:	0f 88       	ld.ub	r8,r7[0x0]
8000266c:	1a d8       	st.w	--sp,r8
8000266e:	48 bc       	lddpc	r12,80002698 <dcm_brdcst_func+0x3c>
80002670:	f0 1f 00 09 	mcall	80002694 <dcm_brdcst_func+0x38>
	log("\n\r ControlType: %x \n\r " ,  ptr->ControlType);
80002674:	0f a8       	ld.ub	r8,r7[0x2]
80002676:	1a d8       	st.w	--sp,r8
80002678:	48 9c       	lddpc	r12,8000269c <dcm_brdcst_func+0x40>
8000267a:	f0 1f 00 07 	mcall	80002694 <dcm_brdcst_func+0x38>
	log("\n\r ControlTypeSize: %x \n\r " ,  ptr->ControlTypeSize);
8000267e:	0f 98       	ld.ub	r8,r7[0x1]
80002680:	1a d8       	st.w	--sp,r8
80002682:	48 8c       	lddpc	r12,800026a0 <dcm_brdcst_func+0x44>
80002684:	f0 1f 00 04 	mcall	80002694 <dcm_brdcst_func+0x38>
80002688:	2f dd       	sub	sp,-12
	
	
}
8000268a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000268e:	00 00       	add	r0,r0
80002690:	80 00       	ld.sh	r0,r0[0x0]
80002692:	d5 68       	*unknown*
80002694:	80 00       	ld.sh	r0,r0[0x0]
80002696:	6f 6c       	ld.w	r12,r7[0x58]
80002698:	80 00       	ld.sh	r0,r0[0x0]
8000269a:	d5 7c       	*unknown*
8000269c:	80 00       	ld.sh	r0,r0[0x0]
8000269e:	d5 90       	acall	0x59
800026a0:	80 00       	ld.sh	r0,r0[0x0]
800026a2:	d5 a8       	*unknown*

800026a4 <dcm_reply_func>:
		log("Tone error");
	}
}

void dcm_reply_func(xcmp_fragment_t * xcmp)
{
800026a4:	eb cd 40 80 	pushm	r7,lr
800026a8:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
800026aa:	19 a9       	ld.ub	r9,r12[0x2]
800026ac:	30 08       	mov	r8,0
800026ae:	f0 09 18 00 	cp.b	r9,r8
800026b2:	c1 b1       	brne	800026e8 <dcm_reply_func+0x44>
	{
		if(xcmp->u8[1] == DCM_ENTER)
800026b4:	19 b8       	ld.ub	r8,r12[0x3]
800026b6:	30 19       	mov	r9,1
800026b8:	f2 08 18 00 	cp.b	r8,r9
800026bc:	c0 51       	brne	800026c6 <dcm_reply_func+0x22>
		{
			log("\n\r Dcm-Enter OK \n\r");
800026be:	48 ec       	lddpc	r12,800026f4 <dcm_reply_func+0x50>
800026c0:	f0 1f 00 0e 	mcall	800026f8 <dcm_reply_func+0x54>
800026c4:	c0 a8       	rjmp	800026d8 <dcm_reply_func+0x34>
			
		}
		else if (xcmp->u8[1] == DCM_EXIT)
800026c6:	58 08       	cp.w	r8,0
800026c8:	c0 51       	brne	800026d2 <dcm_reply_func+0x2e>
		{
			log("\n\r Dcm-Exit OK \n\r");
800026ca:	48 dc       	lddpc	r12,800026fc <dcm_reply_func+0x58>
800026cc:	f0 1f 00 0b 	mcall	800026f8 <dcm_reply_func+0x54>
800026d0:	c0 48       	rjmp	800026d8 <dcm_reply_func+0x34>
		}
		else
		{
			log("\n\r Dcm-Revoke \n\r");
800026d2:	48 cc       	lddpc	r12,80002700 <dcm_reply_func+0x5c>
800026d4:	f0 1f 00 09 	mcall	800026f8 <dcm_reply_func+0x54>
		}
		
		log("dcm OK-mo%X", xcmp->u8[3]);
800026d8:	0f d8       	ld.ub	r8,r7[0x5]
800026da:	1a d8       	st.w	--sp,r8
800026dc:	48 ac       	lddpc	r12,80002704 <dcm_reply_func+0x60>
800026de:	f0 1f 00 07 	mcall	800026f8 <dcm_reply_func+0x54>
800026e2:	2f fd       	sub	sp,-4
800026e4:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		log("dcm error");
800026e8:	48 8c       	lddpc	r12,80002708 <dcm_reply_func+0x64>
800026ea:	f0 1f 00 04 	mcall	800026f8 <dcm_reply_func+0x54>
800026ee:	e3 cd 80 80 	ldm	sp++,r7,pc
800026f2:	00 00       	add	r0,r0
800026f4:	80 00       	ld.sh	r0,r0[0x0]
800026f6:	d5 c4       	*unknown*
800026f8:	80 00       	ld.sh	r0,r0[0x0]
800026fa:	6f 6c       	ld.w	r12,r7[0x58]
800026fc:	80 00       	ld.sh	r0,r0[0x0]
800026fe:	d5 d8       	*unknown*
80002700:	80 00       	ld.sh	r0,r0[0x0]
80002702:	d5 ec       	*unknown*
80002704:	80 00       	ld.sh	r0,r0[0x0]
80002706:	d6 00       	acall	0x60
80002708:	80 00       	ld.sh	r0,r0[0x0]
8000270a:	d6 0c       	*unknown*

8000270c <ToneControl_reply_func>:
			}
		}
}

void ToneControl_reply_func(xcmp_fragment_t * xcmp)
{
8000270c:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
8000270e:	19 a9       	ld.ub	r9,r12[0x2]
80002710:	30 08       	mov	r8,0
80002712:	f0 09 18 00 	cp.b	r9,r8
80002716:	c0 51       	brne	80002720 <ToneControl_reply_func+0x14>
	{		
		log("Tone OK\n");
80002718:	48 4c       	lddpc	r12,80002728 <ToneControl_reply_func+0x1c>
8000271a:	f0 1f 00 05 	mcall	8000272c <ToneControl_reply_func+0x20>
8000271e:	d8 02       	popm	pc
		//fl_write("/test.txt", FILE_END, (void *)"send tone ok\r\n", sizeof("send tone ok\r\n") - 1);
	}
	else
	{
		log("Tone error");
80002720:	48 4c       	lddpc	r12,80002730 <ToneControl_reply_func+0x24>
80002722:	f0 1f 00 03 	mcall	8000272c <ToneControl_reply_func+0x20>
80002726:	d8 02       	popm	pc
80002728:	80 00       	ld.sh	r0,r0[0x0]
8000272a:	d6 18       	*unknown*
8000272c:	80 00       	ld.sh	r0,r0[0x0]
8000272e:	6f 6c       	ld.w	r12,r7[0x58]
80002730:	80 00       	ld.sh	r0,r0[0x0]
80002732:	d6 24       	*unknown*

80002734 <app_init>:
	//0x00,0x39


};
void app_init(void)
{	
80002734:	d4 01       	pushm	lr
	xcmp_register_app_list(the_app_list);
80002736:	49 1c       	lddpc	r12,80002778 <app_init+0x44>
80002738:	f0 1f 00 11 	mcall	8000277c <app_init+0x48>
	
	//将app_payload_rx_proc更改为PCM加密功能
	payload_init( app_payload_rx_proc , app_payload_tx_proc );
8000273c:	49 1b       	lddpc	r11,80002780 <app_init+0x4c>
8000273e:	49 2c       	lddpc	r12,80002784 <app_init+0x50>
80002740:	f0 1f 00 12 	mcall	80002788 <app_init+0x54>
	
	/* Create the mutex semaphore to guard a shared global_count.*/
	count_mutex = xSemaphoreCreateMutex();
80002744:	f0 1f 00 12 	mcall	8000278c <app_init+0x58>
80002748:	49 28       	lddpc	r8,80002790 <app_init+0x5c>
8000274a:	91 0c       	st.w	r8[0x0],r12
	if (count_mutex == NULL)
8000274c:	70 08       	ld.w	r8,r8[0x0]
8000274e:	58 08       	cp.w	r8,0
80002750:	c0 41       	brne	80002758 <app_init+0x24>
	{
		log("Create the count_mutex semaphore failure\n");
80002752:	49 1c       	lddpc	r12,80002794 <app_init+0x60>
80002754:	f0 1f 00 11 	mcall	80002798 <app_init+0x64>
	}
	
	
	static portBASE_TYPE res = 0;
	 res = xTaskCreate(
80002758:	30 09       	mov	r9,0
8000275a:	1a d9       	st.w	--sp,r9
8000275c:	1a d9       	st.w	--sp,r9
8000275e:	1a d9       	st.w	--sp,r9
80002760:	30 18       	mov	r8,1
80002762:	e0 6a 03 20 	mov	r10,800
80002766:	48 eb       	lddpc	r11,8000279c <app_init+0x68>
80002768:	48 ec       	lddpc	r12,800027a0 <app_init+0x6c>
8000276a:	f0 1f 00 0f 	mcall	800027a4 <app_init+0x70>
8000276e:	48 f8       	lddpc	r8,800027a8 <app_init+0x74>
80002770:	91 0c       	st.w	r8[0x0],r12
80002772:	2f dd       	sub	sp,-12
	,  800//1024//800//384
	,  NULL
	,  1
	,  NULL );
		
}
80002774:	d8 02       	popm	pc
80002776:	00 00       	add	r0,r0
80002778:	00 00       	add	r0,r0
8000277a:	00 08       	add	r8,r0
8000277c:	80 00       	ld.sh	r0,r0[0x0]
8000277e:	3e b8       	mov	r8,-21
80002780:	80 00       	ld.sh	r0,r0[0x0]
80002782:	20 3c       	sub	r12,3
80002784:	80 00       	ld.sh	r0,r0[0x0]
80002786:	20 50       	sub	r0,5
80002788:	80 00       	ld.sh	r0,r0[0x0]
8000278a:	2b 60       	sub	r0,-74
8000278c:	80 00       	ld.sh	r0,r0[0x0]
8000278e:	64 34       	ld.w	r4,r2[0xc]
80002790:	00 00       	add	r0,r0
80002792:	0a 60       	and	r0,r5
80002794:	80 00       	ld.sh	r0,r0[0x0]
80002796:	d6 30       	acall	0x63
80002798:	80 00       	ld.sh	r0,r0[0x0]
8000279a:	6f 6c       	ld.w	r12,r7[0x58]
8000279c:	80 00       	ld.sh	r0,r0[0x0]
8000279e:	d6 5c       	*unknown*
800027a0:	80 00       	ld.sh	r0,r0[0x0]
800027a2:	27 ac       	sub	r12,122
800027a4:	80 00       	ld.sh	r0,r0[0x0]
800027a6:	6b a8       	ld.w	r8,r5[0x68]
800027a8:	00 00       	add	r0,r0
800027aa:	0a 58       	eor	r8,r5

800027ac <app_cfg>:
extern volatile  xTaskHandle save_handle; 
//extern portTickType water_value;
//extern portTickType tx_water_value;
//extern portTickType log_water_value;
static __app_Thread_(app_cfg)
{
800027ac:	d4 31       	pushm	r0-r7,lr
800027ae:	20 1d       	sub	sp,4
	static  portTickType xLastWakeTime;
	const portTickType xFrequency = 4000;//2s,定时问题已经修正。2s x  2000hz = 4000
	U8 Burst_ID = 0;
	char card_id[4]={0};
	U16  * data_ptr;
	Message_Protocol_t *m_buff = (Message_Protocol_t *) pvPortMalloc(sizeof(Message_Protocol_t));
800027b0:	31 ac       	mov	r12,26
800027b2:	f0 1f 00 46 	mcall	800028c8 <app_cfg+0x11c>
	static	OB_States OB_State = OB_UNCONNECTEDWAITINGSTATUS;
	static xgflash_status_t status = XG_ERROR;
	xLastWakeTime = xTaskGetTickCount();
800027b6:	f0 1f 00 46 	mcall	800028cc <app_cfg+0x120>
800027ba:	4c 68       	lddpc	r8,800028d0 <app_cfg+0x124>
800027bc:	91 0c       	st.w	r8[0x0],r12
	
	/* 'Give' the semaphore to unblock the task. */
	 if( xBinarySemaphore != NULL ){
800027be:	4c 68       	lddpc	r8,800028d4 <app_cfg+0x128>
800027c0:	70 08       	ld.w	r8,r8[0x0]
800027c2:	58 08       	cp.w	r8,0
800027c4:	c0 80       	breq	800027d4 <app_cfg+0x28>
		xSemaphoreGive(xBinarySemaphore);
800027c6:	4c 48       	lddpc	r8,800028d4 <app_cfg+0x128>
800027c8:	70 0c       	ld.w	r12,r8[0x0]
800027ca:	30 09       	mov	r9,0
800027cc:	12 9a       	mov	r10,r9
800027ce:	12 9b       	mov	r11,r9
800027d0:	f0 1f 00 42 	mcall	800028d8 <app_cfg+0x12c>
	 }
		
	for(;;)
	{
		switch(OB_State)
800027d4:	4c 26       	lddpc	r6,800028dc <app_cfg+0x130>
						
					
					//if (xSemaphoreTake(xBinarySemaphore, (1000*2) / portTICK_RATE_MS) == pdPASS)
					{
					
						if(pdPASS == xQueueReceive(xg_resend_queue, &data_ptr, (2000*2) / portTICK_RATE_MS))
800027d6:	4c 31       	lddpc	r1,800028e0 <app_cfg+0x134>
800027d8:	30 05       	mov	r5,0
800027da:	e0 67 0f a0 	mov	r7,4000
								{
									nop();
									nop();
									nop();
									log("wait message Ack\n");	
								} while (xSemaphoreTake(xBinarySemaphore, (5000*2) / portTICK_RATE_MS) == pdFALSE);
800027de:	4b e3       	lddpc	r3,800028d4 <app_cfg+0x128>
								do 
								{
									nop();
									nop();
									nop();
									log("wait message Ack\n");	
800027e0:	4c 12       	lddpc	r2,800028e4 <app_cfg+0x138>
		xSemaphoreGive(xBinarySemaphore);
	 }
		
	for(;;)
	{
		switch(OB_State)
800027e2:	6c 08       	ld.w	r8,r6[0x0]
800027e4:	58 08       	cp.w	r8,0
800027e6:	c0 40       	breq	800027ee <app_cfg+0x42>
800027e8:	58 38       	cp.w	r8,3
800027ea:	c6 a1       	brne	800028be <app_cfg+0x112>
800027ec:	c2 38       	rjmp	80002832 <app_cfg+0x86>
		{
			case OB_UNCONNECTEDWAITINGSTATUS:
			
				if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
800027ee:	4b f8       	lddpc	r8,800028e8 <app_cfg+0x13c>
800027f0:	70 08       	ld.w	r8,r8[0x0]
800027f2:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
800027f6:	58 38       	cp.w	r8,3
800027f8:	c1 61       	brne	80002824 <app_cfg+0x78>
800027fa:	4b d8       	lddpc	r8,800028ec <app_cfg+0x140>
800027fc:	11 88       	ld.ub	r8,r8[0x0]
800027fe:	58 08       	cp.w	r8,0
80002800:	c1 21       	brne	80002824 <app_cfg+0x78>
				{
					connect_flag=1;
80002802:	30 19       	mov	r9,1
80002804:	4b a8       	lddpc	r8,800028ec <app_cfg+0x140>
80002806:	b0 89       	st.b	r8[0x0],r9
					xcmp_IdleTestTone(Tone_Start, Priority_Beep);//set tone to indicate connection success!!!
80002808:	30 cb       	mov	r11,12
8000280a:	30 1c       	mov	r12,1
8000280c:	f0 1f 00 39 	mcall	800028f0 <app_cfg+0x144>
					xcmp_IdleTestTone(Tone_Start, Priority_Beep);//set tone to indicate connection success!!!
80002810:	30 cb       	mov	r11,12
80002812:	30 1c       	mov	r12,1
80002814:	f0 1f 00 37 	mcall	800028f0 <app_cfg+0x144>
					OB_State = OB_WAITINGAPPTASK;
80002818:	30 38       	mov	r8,3
8000281a:	8d 08       	st.w	r6[0x0],r8
					log("connect OB okay!\n");
8000281c:	4b 6c       	lddpc	r12,800028f4 <app_cfg+0x148>
8000281e:	f0 1f 00 37 	mcall	800028f8 <app_cfg+0x14c>
	{
		switch(OB_State)
		{
			case OB_UNCONNECTEDWAITINGSTATUS:
			
				if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
80002822:	c4 e8       	rjmp	800028be <app_cfg+0x112>
					OB_State = OB_WAITINGAPPTASK;
					log("connect OB okay!\n");
				}
				else
				{
					nop();
80002824:	d7 03       	nop
					nop();
80002826:	d7 03       	nop
					nop();
80002828:	d7 03       	nop
					log("connecting...\n");
8000282a:	4b 5c       	lddpc	r12,800028fc <app_cfg+0x150>
8000282c:	f0 1f 00 33 	mcall	800028f8 <app_cfg+0x14c>
80002830:	c4 78       	rjmp	800028be <app_cfg+0x112>
						
					
					//if (xSemaphoreTake(xBinarySemaphore, (1000*2) / portTICK_RATE_MS) == pdPASS)
					{
					
						if(pdPASS == xQueueReceive(xg_resend_queue, &data_ptr, (2000*2) / portTICK_RATE_MS))
80002832:	62 0c       	ld.w	r12,r1[0x0]
80002834:	0a 99       	mov	r9,r5
80002836:	0e 9a       	mov	r10,r7
80002838:	1a 9b       	mov	r11,sp
8000283a:	f0 1f 00 32 	mcall	80002900 <app_cfg+0x154>
8000283e:	58 1c       	cp.w	r12,1
80002840:	c3 b1       	brne	800028b6 <app_cfg+0x10a>
						{
							if(data_ptr!=NULL){//resend message
80002842:	40 08       	lddsp	r8,sp[0x0]
80002844:	58 08       	cp.w	r8,0
80002846:	c3 80       	breq	800028b6 <app_cfg+0x10a>
							
								log("receive Okay!\n");	
80002848:	4a fc       	lddpc	r12,80002904 <app_cfg+0x158>
8000284a:	f0 1f 00 2c 	mcall	800028f8 <app_cfg+0x14c>
								xSemaphoreTake(count_mutex, portMAX_DELAY);
8000284e:	4a f8       	lddpc	r8,80002908 <app_cfg+0x15c>
80002850:	70 0c       	ld.w	r12,r8[0x0]
80002852:	0a 99       	mov	r9,r5
80002854:	3f fa       	mov	r10,-1
80002856:	0a 9b       	mov	r11,r5
80002858:	f0 1f 00 2a 	mcall	80002900 <app_cfg+0x154>
								global_count--;
8000285c:	4a c4       	lddpc	r4,8000290c <app_cfg+0x160>
8000285e:	68 08       	ld.w	r8,r4[0x0]
80002860:	20 18       	sub	r8,1
80002862:	89 08       	st.w	r4[0x0],r8
								xSemaphoreGive(count_mutex);
80002864:	4a 98       	lddpc	r8,80002908 <app_cfg+0x15c>
80002866:	70 0c       	ld.w	r12,r8[0x0]
80002868:	0a 99       	mov	r9,r5
8000286a:	0a 9a       	mov	r10,r5
8000286c:	0a 9b       	mov	r11,r5
8000286e:	f0 1f 00 1b 	mcall	800028d8 <app_cfg+0x12c>
								log("global_count:%d\n", global_count);	
80002872:	68 08       	ld.w	r8,r4[0x0]
80002874:	1a d8       	st.w	--sp,r8
80002876:	4a 7c       	lddpc	r12,80002910 <app_cfg+0x164>
80002878:	f0 1f 00 20 	mcall	800028f8 <app_cfg+0x14c>
8000287c:	2f fd       	sub	sp,-4
								{
									nop();
									nop();
									nop();
									log("wait message Ack\n");	
								} while (xSemaphoreTake(xBinarySemaphore, (5000*2) / portTICK_RATE_MS) == pdFALSE);
8000287e:	e0 64 27 10 	mov	r4,10000
								global_count--;
								xSemaphoreGive(count_mutex);
								log("global_count:%d\n", global_count);	
								do 
								{
									nop();
80002882:	d7 03       	nop
									nop();
80002884:	d7 03       	nop
									nop();
80002886:	d7 03       	nop
									log("wait message Ack\n");	
80002888:	04 9c       	mov	r12,r2
8000288a:	f0 1f 00 1c 	mcall	800028f8 <app_cfg+0x14c>
								} while (xSemaphoreTake(xBinarySemaphore, (5000*2) / portTICK_RATE_MS) == pdFALSE);
8000288e:	66 0c       	ld.w	r12,r3[0x0]
80002890:	0a 99       	mov	r9,r5
80002892:	08 9a       	mov	r10,r4
80002894:	0a 9b       	mov	r11,r5
80002896:	f0 1f 00 1b 	mcall	80002900 <app_cfg+0x154>
8000289a:	cf 40       	breq	80002882 <app_cfg+0xd6>
												
								xcmp_data_session_req(data_ptr, sizeof(Message_Protocol_t), DEST);								
8000289c:	36 4a       	mov	r10,100
8000289e:	31 ab       	mov	r11,26
800028a0:	40 0c       	lddsp	r12,sp[0x0]
800028a2:	f0 1f 00 1d 	mcall	80002914 <app_cfg+0x168>
								set_message_store(data_ptr);
800028a6:	49 d8       	lddpc	r8,80002918 <app_cfg+0x16c>
800028a8:	70 0c       	ld.w	r12,r8[0x0]
800028aa:	40 0b       	lddsp	r11,sp[0x0]
800028ac:	f0 1f 00 1c 	mcall	8000291c <app_cfg+0x170>
								log("send message\n");
800028b0:	49 cc       	lddpc	r12,80002920 <app_cfg+0x174>
800028b2:	f0 1f 00 12 	mcall	800028f8 <app_cfg+0x14c>
							}
						
						}
					}
										
					nop();
800028b6:	d7 03       	nop
					log("app task run!\n");
800028b8:	49 bc       	lddpc	r12,80002924 <app_cfg+0x178>
800028ba:	f0 1f 00 10 	mcall	800028f8 <app_cfg+0x14c>
			break;
			default:
			break;
				
		} //End of switch on OB_State.
		vTaskDelayUntil( &xLastWakeTime, (2000*2) / portTICK_RATE_MS  );//精确的以1000ms为周期执行。
800028be:	0e 9b       	mov	r11,r7
800028c0:	48 4c       	lddpc	r12,800028d0 <app_cfg+0x124>
800028c2:	f0 1f 00 1a 	mcall	80002928 <app_cfg+0x17c>
	}
800028c6:	c8 eb       	rjmp	800027e2 <app_cfg+0x36>
800028c8:	80 00       	ld.sh	r0,r0[0x0]
800028ca:	5f e0       	srqs	r0
800028cc:	80 00       	ld.sh	r0,r0[0x0]
800028ce:	68 98       	ld.w	r8,r4[0x24]
800028d0:	00 00       	add	r0,r0
800028d2:	0a 54       	eor	r4,r5
800028d4:	00 00       	add	r0,r0
800028d6:	0b 7c       	ld.ub	r12,--r5
800028d8:	80 00       	ld.sh	r0,r0[0x0]
800028da:	63 34       	ld.w	r4,r1[0x4c]
800028dc:	00 00       	add	r0,r0
800028de:	0a 44       	or	r4,r5
800028e0:	00 00       	add	r0,r0
800028e2:	0b 74       	ld.ub	r4,--r5
800028e4:	80 00       	ld.sh	r0,r0[0x0]
800028e6:	d6 ac       	*unknown*
800028e8:	00 00       	add	r0,r0
800028ea:	0d a0       	ld.ub	r0,r6[0x2]
800028ec:	00 00       	add	r0,r0
800028ee:	0a 42       	or	r2,r5
800028f0:	80 00       	ld.sh	r0,r0[0x0]
800028f2:	40 44       	lddsp	r4,sp[0x10]
800028f4:	80 00       	ld.sh	r0,r0[0x0]
800028f6:	d6 64       	*unknown*
800028f8:	80 00       	ld.sh	r0,r0[0x0]
800028fa:	6f 6c       	ld.w	r12,r7[0x58]
800028fc:	80 00       	ld.sh	r0,r0[0x0]
800028fe:	d6 78       	*unknown*
80002900:	80 00       	ld.sh	r0,r0[0x0]
80002902:	61 28       	ld.w	r8,r0[0x48]
80002904:	80 00       	ld.sh	r0,r0[0x0]
80002906:	d6 88       	*unknown*
80002908:	00 00       	add	r0,r0
8000290a:	0a 60       	and	r0,r5
8000290c:	00 00       	add	r0,r0
8000290e:	0a 50       	eor	r0,r5
80002910:	80 00       	ld.sh	r0,r0[0x0]
80002912:	d6 98       	*unknown*
80002914:	80 00       	ld.sh	r0,r0[0x0]
80002916:	3f 0c       	mov	r12,-16
80002918:	00 00       	add	r0,r0
8000291a:	0b 78       	ld.ub	r8,--r5
8000291c:	80 00       	ld.sh	r0,r0[0x0]
8000291e:	2b e0       	sub	r0,-66
80002920:	80 00       	ld.sh	r0,r0[0x0]
80002922:	d6 c0       	acall	0x6c
80002924:	80 00       	ld.sh	r0,r0[0x0]
80002926:	d6 d0       	acall	0x6d
80002928:	80 00       	ld.sh	r0,r0[0x0]
8000292a:	6a 48       	ld.w	r8,r5[0x10]

8000292c <Phyuserinput_brdcst_func>:
	
}


void Phyuserinput_brdcst_func(xcmp_fragment_t * xcmp)
{
8000292c:	eb cd 40 80 	pushm	r7,lr
	U8 PUI_State_Min_Value =0;
	U8 PUI_State_Max_Value =0;
	
	PUI_Source = xcmp->u8[0];
	PUI_Type = xcmp ->u8[1];
	PUI_ID = ((xcmp->u8[2]<<8) | xcmp->u8[3]);
80002930:	19 c7       	ld.ub	r7,r12[0x4]
80002932:	19 d8       	ld.ub	r8,r12[0x5]
80002934:	f1 e7 10 87 	or	r7,r8,r7<<0x8
80002938:	5c 87       	casts.h	r7
	PUI_State = xcmp->u8[4];
	PUI_State_Min_Value = xcmp->u8[5];
	PUI_State_Max_Value = xcmp->u8[6];
	
	log("PhysicalUserInput_broadcast  \n\r"  );
8000293a:	48 dc       	lddpc	r12,8000296c <Phyuserinput_brdcst_func+0x40>
8000293c:	f0 1f 00 0d 	mcall	80002970 <Phyuserinput_brdcst_func+0x44>
	
	if((PUI_ID == 0x0060) && (PUI_State = 0x02) && (connect_flag == 1)){
80002940:	36 08       	mov	r8,96
80002942:	f0 07 19 00 	cp.h	r7,r8
80002946:	c1 11       	brne	80002968 <Phyuserinput_brdcst_func+0x3c>
80002948:	48 b8       	lddpc	r8,80002974 <Phyuserinput_brdcst_func+0x48>
8000294a:	11 89       	ld.ub	r9,r8[0x0]
8000294c:	30 18       	mov	r8,1
8000294e:	f0 09 18 00 	cp.b	r9,r8
80002952:	c0 b1       	brne	80002968 <Phyuserinput_brdcst_func+0x3c>
		//log("send message\n");
		xcmp_IdleTestTone(Tone_Start, Ring_Style_Tone_9);//set tone to indicate the scan!!!
80002954:	34 5b       	mov	r11,69
80002956:	30 1c       	mov	r12,1
80002958:	f0 1f 00 08 	mcall	80002978 <Phyuserinput_brdcst_func+0x4c>
			
		vTaskDelay(1000*2 / portTICK_RATE_MS);//延迟1000ms
8000295c:	e0 6c 07 d0 	mov	r12,2000
80002960:	f0 1f 00 07 	mcall	8000297c <Phyuserinput_brdcst_func+0x50>
		//delay_ms(200);
		//rfid_sendID_message();//send message	
		scan_rfid_save_message();//scan and save message	
80002964:	f0 1f 00 07 	mcall	80002980 <Phyuserinput_brdcst_func+0x54>
80002968:	e3 cd 80 80 	ldm	sp++,r7,pc
8000296c:	80 00       	ld.sh	r0,r0[0x0]
8000296e:	d6 e0       	acall	0x6e
80002970:	80 00       	ld.sh	r0,r0[0x0]
80002972:	6f 6c       	ld.w	r12,r7[0x58]
80002974:	00 00       	add	r0,r0
80002976:	0a 42       	or	r2,r5
80002978:	80 00       	ld.sh	r0,r0[0x0]
8000297a:	40 44       	lddsp	r4,sp[0x10]
8000297c:	80 00       	ld.sh	r0,r0[0x0]
8000297e:	6a 00       	ld.w	r0,r5[0x0]
80002980:	80 00       	ld.sh	r0,r0[0x0]
80002982:	50 a8       	stdsp	sp[0x28],r8

80002984 <DataSession_brdcst_func>:
	Battery_Flag = ptr->State;

}

void DataSession_brdcst_func(xcmp_fragment_t * xcmp)
{
80002984:	d4 21       	pushm	r4-r7,lr
80002986:	20 8d       	sub	sp,32
	U32 card_id =0;
	U8 i = 0;
	xgflash_status_t return_value = XG_ERROR;
	
	/*point to xcmp payload*/
	DataSession_brdcst_t *ptr = (DataSession_brdcst_t* )xcmp->u8;
80002988:	f8 c6 ff fe 	sub	r6,r12,-2
	
	if (ptr->State == CSBK_DATA_RX_Suc)
8000298c:	0d 88       	ld.ub	r8,r6[0x0]
8000298e:	32 49       	mov	r9,36
80002990:	f2 08 18 00 	cp.b	r8,r9
80002994:	c2 a1       	brne	800029e8 <DataSession_brdcst_func+0x64>
	{
		
		log("\n\r CSBK_RX OK \n\r");
80002996:	4c ac       	lddpc	r12,80002abc <DataSession_brdcst_func+0x138>
80002998:	f0 1f 00 4a 	mcall	80002ac0 <DataSession_brdcst_func+0x13c>
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
8000299c:	0d a5       	ld.ub	r5,r6[0x2]
8000299e:	0d b8       	ld.ub	r8,r6[0x3]
800029a0:	f1 e5 10 85 	or	r5,r8,r5<<0x8
800029a4:	5c 85       	casts.h	r5

		log("\n\r Session_ID: %x \n\r",Session_number );
800029a6:	0d 98       	ld.ub	r8,r6[0x1]
800029a8:	1a d8       	st.w	--sp,r8
800029aa:	4c 7c       	lddpc	r12,80002ac4 <DataSession_brdcst_func+0x140>
800029ac:	f0 1f 00 45 	mcall	80002ac0 <DataSession_brdcst_func+0x13c>
		log("\n\r paylaod_length: %d \n\r",data_length );
800029b0:	f1 d5 c0 10 	bfextu	r8,r5,0x0,0x10
800029b4:	1a d8       	st.w	--sp,r8
800029b6:	4c 5c       	lddpc	r12,80002ac8 <DataSession_brdcst_func+0x144>
800029b8:	f0 1f 00 42 	mcall	80002ac0 <DataSession_brdcst_func+0x13c>
		for(i=0; i<data_length; i++)
800029bc:	2f ed       	sub	sp,-8
800029be:	58 05       	cp.w	r5,0
800029c0:	e0 80 00 7b 	breq	80002ab6 <DataSession_brdcst_func+0x132>
800029c4:	30 07       	mov	r7,0
		{
			
			//log("\n\r payload[%d]: %X \n\r", i, xcmp->u8[4+i]);
			log("\n\r payload[%d]: %X \n\r", i, ptr->DataPayload.DataPayload[i]);
800029c6:	4c 24       	lddpc	r4,80002acc <DataSession_brdcst_func+0x148>
800029c8:	ec 07 00 08 	add	r8,r6,r7
800029cc:	11 c8       	ld.ub	r8,r8[0x4]
800029ce:	1a d8       	st.w	--sp,r8
800029d0:	1a d7       	st.w	--sp,r7
800029d2:	08 9c       	mov	r12,r4
800029d4:	f0 1f 00 3b 	mcall	80002ac0 <DataSession_brdcst_func+0x13c>
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);

		log("\n\r Session_ID: %x \n\r",Session_number );
		log("\n\r paylaod_length: %d \n\r",data_length );
		for(i=0; i<data_length; i++)
800029d8:	2f f7       	sub	r7,-1
800029da:	5c 57       	castu.b	r7
800029dc:	2f ed       	sub	sp,-8
800029de:	ee 05 19 00 	cp.h	r5,r7
800029e2:	fe 9b ff f3 	brhi	800029c8 <DataSession_brdcst_func+0x44>
800029e6:	c6 88       	rjmp	80002ab6 <DataSession_brdcst_func+0x132>
	else
	{
		//log("\n\r State: 0x %X \n\r", xcmp->u8[0]);
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];				
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
		log("State: %X \n", ptr->State);
800029e8:	1a d8       	st.w	--sp,r8
800029ea:	4b ac       	lddpc	r12,80002ad0 <DataSession_brdcst_func+0x14c>
800029ec:	f0 1f 00 35 	mcall	80002ac0 <DataSession_brdcst_func+0x13c>
		if (ptr->State == DATA_SESSION_TX_Suc)
800029f0:	0d 88       	ld.ub	r8,r6[0x0]
800029f2:	2f fd       	sub	sp,-4
800029f4:	30 39       	mov	r9,3
800029f6:	f2 08 18 00 	cp.b	r8,r9
800029fa:	c0 d1       	brne	80002a14 <DataSession_brdcst_func+0x90>
		{
			log("data transmit success\n");
800029fc:	4b 6c       	lddpc	r12,80002ad4 <DataSession_brdcst_func+0x150>
800029fe:	f0 1f 00 31 	mcall	80002ac0 <DataSession_brdcst_func+0x13c>
			vTaskDelay(1000*2 / portTICK_RATE_MS);//延迟1000ms
80002a02:	e0 6c 07 d0 	mov	r12,2000
80002a06:	f0 1f 00 35 	mcall	80002ad8 <DataSession_brdcst_func+0x154>
			xcmp_IdleTestTone(Tone_Start, BT_Connection_Success_Tone);//set tone to indicate connection success!!!
80002a0a:	37 7b       	mov	r11,119
80002a0c:	30 1c       	mov	r12,1
80002a0e:	f0 1f 00 34 	mcall	80002adc <DataSession_brdcst_func+0x158>
80002a12:	c4 b8       	rjmp	80002aa8 <DataSession_brdcst_func+0x124>
		}
		else if(ptr->State == DATA_SESSION_TX_Fail)
80002a14:	30 49       	mov	r9,4
80002a16:	f2 08 18 00 	cp.b	r8,r9
80002a1a:	c4 71       	brne	80002aa8 <DataSession_brdcst_func+0x124>
		{
			Message_Protocol_t  xgmessage;
			memcpy(&xgmessage, ptr->DataPayload.DataPayload, sizeof(Message_Protocol_t));
80002a1c:	31 aa       	mov	r10,26
80002a1e:	ec cb ff fc 	sub	r11,r6,-4
80002a22:	fa cc ff fe 	sub	r12,sp,-2
80002a26:	f0 1f 00 2f 	mcall	80002ae0 <DataSession_brdcst_func+0x15c>

			Message_Protocol_t * myptr = get_message_store();	
80002a2a:	4a f8       	lddpc	r8,80002ae4 <DataSession_brdcst_func+0x160>
80002a2c:	70 0c       	ld.w	r12,r8[0x0]
80002a2e:	f0 1f 00 2f 	mcall	80002ae8 <DataSession_brdcst_func+0x164>
80002a32:	50 7c       	stdsp	sp[0x1c],r12
			if(NULL != myptr)
80002a34:	c3 20       	breq	80002a98 <DataSession_brdcst_func+0x114>
			{
				memcpy(myptr, &xgmessage, sizeof(Message_Protocol_t));			
80002a36:	31 aa       	mov	r10,26
80002a38:	fa cb ff fe 	sub	r11,sp,-2
80002a3c:	f0 1f 00 29 	mcall	80002ae0 <DataSession_brdcst_func+0x15c>
				//xQueueSend(xg_resend_queue, &myptr, 0);			
				if (xQueueSend(xg_resend_queue, &myptr, 0) != pdPASS)
80002a40:	4a b8       	lddpc	r8,80002aec <DataSession_brdcst_func+0x168>
80002a42:	70 0c       	ld.w	r12,r8[0x0]
80002a44:	30 09       	mov	r9,0
80002a46:	12 9a       	mov	r10,r9
80002a48:	fa cb ff e4 	sub	r11,sp,-28
80002a4c:	f0 1f 00 29 	mcall	80002af0 <DataSession_brdcst_func+0x16c>
80002a50:	58 1c       	cp.w	r12,1
80002a52:	c1 10       	breq	80002a74 <DataSession_brdcst_func+0xf0>
				{
					log("xg_resend_queue: full\n" );
80002a54:	4a 8c       	lddpc	r12,80002af4 <DataSession_brdcst_func+0x170>
80002a56:	f0 1f 00 1b 	mcall	80002ac0 <DataSession_brdcst_func+0x13c>
					xcmp_IdleTestTone(Tone_Start, Dispatch_Busy);//set tone to indicate queue full!!!
80002a5a:	32 3b       	mov	r11,35
80002a5c:	30 1c       	mov	r12,1
80002a5e:	f0 1f 00 20 	mcall	80002adc <DataSession_brdcst_func+0x158>
					vTaskDelay(3000*2 / portTICK_RATE_MS);//延迟3000ms
80002a62:	e0 6c 17 70 	mov	r12,6000
80002a66:	f0 1f 00 1d 	mcall	80002ad8 <DataSession_brdcst_func+0x154>
					xcmp_IdleTestTone(Tone_Stop, Dispatch_Busy);//set tone to indicate queue full!!!
80002a6a:	32 3b       	mov	r11,35
80002a6c:	30 0c       	mov	r12,0
80002a6e:	f0 1f 00 1c 	mcall	80002adc <DataSession_brdcst_func+0x158>
80002a72:	c1 68       	rjmp	80002a9e <DataSession_brdcst_func+0x11a>
				}
				else{
					
					xSemaphoreTake(count_mutex, portMAX_DELAY);
80002a74:	4a 17       	lddpc	r7,80002af8 <DataSession_brdcst_func+0x174>
80002a76:	6e 0c       	ld.w	r12,r7[0x0]
80002a78:	30 09       	mov	r9,0
80002a7a:	3f fa       	mov	r10,-1
80002a7c:	12 9b       	mov	r11,r9
80002a7e:	f0 1f 00 20 	mcall	80002afc <DataSession_brdcst_func+0x178>
					global_count++;
80002a82:	4a 08       	lddpc	r8,80002b00 <DataSession_brdcst_func+0x17c>
80002a84:	70 09       	ld.w	r9,r8[0x0]
80002a86:	2f f9       	sub	r9,-1
80002a88:	91 09       	st.w	r8[0x0],r9
					xSemaphoreGive(count_mutex);
80002a8a:	6e 0c       	ld.w	r12,r7[0x0]
80002a8c:	30 09       	mov	r9,0
80002a8e:	12 9a       	mov	r10,r9
80002a90:	12 9b       	mov	r11,r9
80002a92:	f0 1f 00 18 	mcall	80002af0 <DataSession_brdcst_func+0x16c>
80002a96:	c0 48       	rjmp	80002a9e <DataSession_brdcst_func+0x11a>
				}
			}
			else
			{
				log("myptr: err\n\r" );
80002a98:	49 bc       	lddpc	r12,80002b04 <DataSession_brdcst_func+0x180>
80002a9a:	f0 1f 00 0a 	mcall	80002ac0 <DataSession_brdcst_func+0x13c>
			}
			xcmp_IdleTestTone(Tone_Start, MANDOWN_DISABLE_TONE);//set tone to indicate send-failure!!!
80002a9e:	e0 6b 00 b7 	mov	r11,183
80002aa2:	30 1c       	mov	r12,1
80002aa4:	f0 1f 00 0e 	mcall	80002adc <DataSession_brdcst_func+0x158>
		}
		
		/* 'Give' the semaphore to unblock the task. */
		xSemaphoreGive(xBinarySemaphore);
80002aa8:	49 88       	lddpc	r8,80002b08 <DataSession_brdcst_func+0x184>
80002aaa:	70 0c       	ld.w	r12,r8[0x0]
80002aac:	30 09       	mov	r9,0
80002aae:	12 9a       	mov	r10,r9
80002ab0:	12 9b       	mov	r11,r9
80002ab2:	f0 1f 00 10 	mcall	80002af0 <DataSession_brdcst_func+0x16c>
				//
		//}
		
	}
	
}
80002ab6:	2f 8d       	sub	sp,-32
80002ab8:	d8 22       	popm	r4-r7,pc
80002aba:	00 00       	add	r0,r0
80002abc:	80 00       	ld.sh	r0,r0[0x0]
80002abe:	d7 00       	acall	0x70
80002ac0:	80 00       	ld.sh	r0,r0[0x0]
80002ac2:	6f 6c       	ld.w	r12,r7[0x58]
80002ac4:	80 00       	ld.sh	r0,r0[0x0]
80002ac6:	d7 14       	*unknown*
80002ac8:	80 00       	ld.sh	r0,r0[0x0]
80002aca:	d7 2c       	*unknown*
80002acc:	80 00       	ld.sh	r0,r0[0x0]
80002ace:	d7 48       	*unknown*
80002ad0:	80 00       	ld.sh	r0,r0[0x0]
80002ad2:	d7 60       	acall	0x76
80002ad4:	80 00       	ld.sh	r0,r0[0x0]
80002ad6:	d7 6c       	*unknown*
80002ad8:	80 00       	ld.sh	r0,r0[0x0]
80002ada:	6a 00       	ld.w	r0,r5[0x0]
80002adc:	80 00       	ld.sh	r0,r0[0x0]
80002ade:	40 44       	lddsp	r4,sp[0x10]
80002ae0:	80 00       	ld.sh	r0,r0[0x0]
80002ae2:	77 e8       	ld.w	r8,r11[0x78]
80002ae4:	00 00       	add	r0,r0
80002ae6:	0b 78       	ld.ub	r8,--r5
80002ae8:	80 00       	ld.sh	r0,r0[0x0]
80002aea:	2d 8c       	sub	r12,-40
80002aec:	00 00       	add	r0,r0
80002aee:	0b 74       	ld.ub	r4,--r5
80002af0:	80 00       	ld.sh	r0,r0[0x0]
80002af2:	63 34       	ld.w	r4,r1[0x4c]
80002af4:	80 00       	ld.sh	r0,r0[0x0]
80002af6:	d7 84       	*unknown*
80002af8:	00 00       	add	r0,r0
80002afa:	0a 60       	and	r0,r5
80002afc:	80 00       	ld.sh	r0,r0[0x0]
80002afe:	61 28       	ld.w	r8,r0[0x48]
80002b00:	00 00       	add	r0,r0
80002b02:	0a 50       	eor	r0,r5
80002b04:	80 00       	ld.sh	r0,r0[0x0]
80002b06:	d7 9c       	*unknown*
80002b08:	00 00       	add	r0,r0
80002b0a:	0b 7c       	ld.ub	r12,--r5

80002b0c <DeviceInitializationStatus_brdcst_func>:
volatile U32 global_count =0;

//app func--list

void DeviceInitializationStatus_brdcst_func(xcmp_fragment_t  * xcmp)
{
80002b0c:	d4 01       	pushm	lr
	if (xcmp->u8[4] == 0x01)
80002b0e:	19 e8       	ld.ub	r8,r12[0x6]
80002b10:	30 19       	mov	r9,1
80002b12:	f2 08 18 00 	cp.b	r8,r9
80002b16:	c0 61       	brne	80002b22 <DeviceInitializationStatus_brdcst_func+0x16>
	{
		bunchofrandomstatusflags |= 0x01;  //Need do nothing else.
80002b18:	48 98       	lddpc	r8,80002b3c <DeviceInitializationStatus_brdcst_func+0x30>
80002b1a:	70 09       	ld.w	r9,r8[0x0]
80002b1c:	a1 a9       	sbr	r9,0x0
80002b1e:	91 09       	st.w	r8[0x0],r9
80002b20:	d8 02       	popm	pc
	}
	else if(xcmp->u8[4] != 0x02)
80002b22:	30 29       	mov	r9,2
80002b24:	f2 08 18 00 	cp.b	r8,r9
80002b28:	c0 80       	breq	80002b38 <DeviceInitializationStatus_brdcst_func+0x2c>
	{
		bunchofrandomstatusflags  &= 0xFFFFFFFC; //Device Init no longer Complete.
80002b2a:	48 58       	lddpc	r8,80002b3c <DeviceInitializationStatus_brdcst_func+0x30>
80002b2c:	70 09       	ld.w	r9,r8[0x0]
80002b2e:	e0 19 ff fc 	andl	r9,0xfffc
80002b32:	91 09       	st.w	r8[0x0],r9
		xcmp_DeviceInitializationStatus_request();
80002b34:	f0 1f 00 03 	mcall	80002b40 <DeviceInitializationStatus_brdcst_func+0x34>
80002b38:	d8 02       	popm	pc
80002b3a:	00 00       	add	r0,r0
80002b3c:	00 00       	add	r0,r0
80002b3e:	0d a0       	ld.ub	r0,r6[0x2]
80002b40:	80 00       	ld.sh	r0,r0[0x0]
80002b42:	3f 98       	mov	r8,-7

80002b44 <CalculateBurst>:
Calls:
Called By: phy_payload_rx
*/

volatile RxAMBEBurstType CalculateBurst(U8 vf_sn)
{
80002b44:	20 1c       	sub	r12,1
80002b46:	5c 5c       	castu.b	r12
80002b48:	31 18       	mov	r8,17
80002b4a:	f0 0c 18 00 	cp.b	r12,r8
80002b4e:	e0 88 00 03 	brls	80002b54 <CalculateBurst+0x10>
80002b52:	5e fd       	retal	0
80002b54:	48 28       	lddpc	r8,80002b5c <CalculateBurst+0x18>
80002b56:	f0 0c 03 2c 	ld.w	r12,r8[r12<<0x2]
			Burst_ID = 0x00;
			return VOICE_WATING;
		
	}
	
}
80002b5a:	5e fc       	retal	r12
80002b5c:	80 00       	ld.sh	r0,r0[0x0]
80002b5e:	d7 ac       	*unknown*

80002b60 <payload_init>:
Calls: xTaskCreate--freertos
Called By:app_init -- app.c
*/
void payload_init(void ( *payload_rx_func)(void * ), void ( *payload_tx_func)(void * ) )
{				
	payload_rx_exec = payload_rx_func;
80002b60:	48 38       	lddpc	r8,80002b6c <payload_init+0xc>
80002b62:	91 0c       	st.w	r8[0x0],r12
	payload_tx_exec = payload_tx_func;
80002b64:	48 38       	lddpc	r8,80002b70 <payload_init+0x10>
80002b66:	91 0b       	st.w	r8[0x0],r11
	//,  2
	//,  NULL
	//);
	//
	
}
80002b68:	5e fc       	retal	r12
80002b6a:	00 00       	add	r0,r0
80002b6c:	00 00       	add	r0,r0
80002b6e:	0a 6c       	and	r12,r5
80002b70:	00 00       	add	r0,r0
80002b72:	0a 70       	tst	r0,r5

80002b74 <set_idle_store_isr>:
{
	xQueueSend(store, &ptr, 0);
}

void set_idle_store_isr(xQueueHandle store, void * ptr)
{
80002b74:	d4 01       	pushm	lr
80002b76:	20 2d       	sub	sp,8
80002b78:	50 0b       	stdsp	sp[0x0],r11
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002b7a:	30 09       	mov	r9,0
80002b7c:	fa ca ff f8 	sub	r10,sp,-8
80002b80:	14 d9       	st.w	--r10,r9
	xQueueSendFromISR(store, &ptr, &xHigherPriorityTaskWoken);
80002b82:	1a 9b       	mov	r11,sp
80002b84:	f0 1f 00 02 	mcall	80002b8c <set_idle_store_isr+0x18>
}
80002b88:	2f ed       	sub	sp,-8
80002b8a:	d8 02       	popm	pc
80002b8c:	80 00       	ld.sh	r0,r0[0x0]
80002b8e:	62 e4       	ld.w	r4,r1[0x38]

80002b90 <payload_rx>:
		//logFromISR("ss");
	}
}

static void payload_rx(void * payload)
{
80002b90:	d4 01       	pushm	lr
    set_payload_idle_isr(payload);
80002b92:	48 48       	lddpc	r8,80002ba0 <payload_rx+0x10>
80002b94:	70 08       	ld.w	r8,r8[0x0]
80002b96:	18 9b       	mov	r11,r12
80002b98:	10 9c       	mov	r12,r8
80002b9a:	f0 1f 00 03 	mcall	80002ba4 <payload_rx+0x14>
	else
	{
		//logFromISR("ss");
	}
	#endif
}
80002b9e:	d8 02       	popm	pc
80002ba0:	00 00       	add	r0,r0
80002ba2:	0a a8       	st.w	r5++,r8
80002ba4:	80 00       	ld.sh	r0,r0[0x0]
80002ba6:	2b 74       	sub	r4,-73

80002ba8 <phy_rx>:
	xQueueSendFromISR -- freertos
Called By: phy_xnl_rx
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
80002ba8:	d4 01       	pushm	lr
80002baa:	20 2d       	sub	sp,8
80002bac:	50 0c       	stdsp	sp[0x0],r12
	//memcpy(xx, phy_ptr, sizeof(phy_fragment_t));
	//set_phy_idle_isr(&phy_ptr, &xHigherPriorityTaskWoken);
	
	Bool res = FALSE;
	
	if(NULL == phy_ptr)
80002bae:	58 0c       	cp.w	r12,0
80002bb0:	c1 10       	breq	80002bd2 <phy_rx+0x2a>
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
    /*variables are used to store the push result in interrupt*/
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002bb2:	30 08       	mov	r8,0
80002bb4:	50 18       	stdsp	sp[0x4],r8
	if(NULL == phy_ptr)
	{
		return;
	}
	
    U16 phy_ctrl = phy_ptr->xnl_fragment.phy_header.phy_control;
80002bb6:	98 88       	ld.uh	r8,r12[0x0]
80002bb8:	e2 18 f0 00 	andl	r8,0xf000,COH
80002bbc:	e0 48 40 00 	cp.w	r8,16384
80002bc0:	c0 91       	brne	80002bd2 <phy_rx+0x2a>

    if (XCMPXNL_DATA == (phy_ctrl & 0xF000))
    {
        /*push the xnl packet to queue*/
        if( pdTRUE == xQueueSendFromISR(
80002bc2:	48 68       	lddpc	r8,80002bd8 <phy_rx+0x30>
80002bc4:	70 0c       	ld.w	r12,r8[0x0]
80002bc6:	30 09       	mov	r9,0
80002bc8:	fa ca ff fc 	sub	r10,sp,-4
80002bcc:	1a 9b       	mov	r11,sp
80002bce:	f0 1f 00 04 	mcall	80002bdc <phy_rx+0x34>
		}	

    }
		
 
}
80002bd2:	2f ed       	sub	sp,-8
80002bd4:	d8 02       	popm	pc
80002bd6:	00 00       	add	r0,r0
80002bd8:	00 00       	add	r0,r0
80002bda:	0a b4       	st.h	r5++,r4
80002bdc:	80 00       	ld.sh	r0,r0[0x0]
80002bde:	62 e4       	ld.w	r4,r1[0x38]

80002be0 <set_idle_store>:
	}
}


void set_idle_store(xQueueHandle store, void * ptr)
{
80002be0:	eb cd 40 80 	pushm	r7,lr
80002be4:	20 1d       	sub	sp,4
80002be6:	fa c7 ff fc 	sub	r7,sp,-4
80002bea:	0e db       	st.w	--r7,r11
	xQueueSend(store, &ptr, 0);
80002bec:	30 09       	mov	r9,0
80002bee:	12 9a       	mov	r10,r9
80002bf0:	1a 9b       	mov	r11,sp
80002bf2:	f0 1f 00 03 	mcall	80002bfc <set_idle_store+0x1c>
}
80002bf6:	2f fd       	sub	sp,-4
80002bf8:	e3 cd 80 80 	ldm	sp++,r7,pc
80002bfc:	80 00       	ld.sh	r0,r0[0x0]
80002bfe:	63 34       	ld.w	r4,r1[0x4c]

80002c00 <phy_tx>:
Calls:   
	xQueueSend -- freertos
Called By: xnl_tx -- xnl.c
*/
void phy_tx(phy_fragment_t * phy)
{	
80002c00:	d4 01       	pushm	lr
80002c02:	20 1d       	sub	sp,4
80002c04:	50 0c       	stdsp	sp[0x0],r12
	
	//phy_fragment_t * phy_ptr = malloc(sizeof(phy_fragment_t));
	//memcpy(phy_ptr, phy, sizeof(phy_fragment_t));
	//log("\n\r T_xcmp:%4x \n\r", phy->xnl_fragment.xnl_payload.xnl_content_data_msg.xcmp_opcode);
	//log("T_xnl-opcode:%4x", xnl->xnl_header.opcode);//log:R_xnl指令	
	if(XCMPXNL_DATA == (phy_ctrl & 0xF000))
80002c06:	98 88       	ld.uh	r8,r12[0x0]
80002c08:	e2 18 f0 00 	andl	r8,0xf000,COH
80002c0c:	e0 48 40 00 	cp.w	r8,16384
80002c10:	c0 d1       	brne	80002c2a <phy_tx+0x2a>
	{
		/*push the xnl packet to queue to send */
		if(NULL != phy_xnl_frame_tx)
80002c12:	49 08       	lddpc	r8,80002c50 <phy_tx+0x50>
80002c14:	70 08       	ld.w	r8,r8[0x0]
80002c16:	58 08       	cp.w	r8,0
80002c18:	c1 a0       	breq	80002c4c <phy_tx+0x4c>
		{
			if( pdTRUE == xQueueSend(phy_xnl_frame_tx, &phy, 0))
80002c1a:	48 e8       	lddpc	r8,80002c50 <phy_tx+0x50>
80002c1c:	70 0c       	ld.w	r12,r8[0x0]
80002c1e:	30 09       	mov	r9,0
80002c20:	12 9a       	mov	r10,r9
80002c22:	1a 9b       	mov	r11,sp
80002c24:	f0 1f 00 0c 	mcall	80002c54 <phy_tx+0x54>
80002c28:	c1 28       	rjmp	80002c4c <phy_tx+0x4c>
		}
	}
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE		
	else if((SPEAKER_DATA == (phy_ctrl & 0xF000))
80002c2a:	e0 48 10 00 	cp.w	r8,4096
80002c2e:	5f 0a       	sreq	r10
80002c30:	e0 48 20 00 	cp.w	r8,8192
80002c34:	5f 09       	sreq	r9
80002c36:	f5 e9 10 09 	or	r9,r10,r9
80002c3a:	c0 71       	brne	80002c48 <phy_tx+0x48>
80002c3c:	e0 48 50 00 	cp.w	r8,20480
80002c40:	c0 40       	breq	80002c48 <phy_tx+0x48>
80002c42:	e0 48 60 00 	cp.w	r8,24576
80002c46:	c0 31       	brne	80002c4c <phy_tx+0x4c>
	    || (MIC_DATA  == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_RX == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_TX == (phy_ctrl & 0xF000))
	)
	{		
		if(NULL == phy_payload_frame_tx)
80002c48:	48 48       	lddpc	r8,80002c58 <phy_tx+0x58>
80002c4a:	70 08       	ld.w	r8,r8[0x0]
	
	if(res != TRUE)
	{
		//vPortFree(phy_ptr);
	}
}
80002c4c:	2f fd       	sub	sp,-4
80002c4e:	d8 02       	popm	pc
80002c50:	00 00       	add	r0,r0
80002c52:	0a d4       	st.w	--r5,r4
80002c54:	80 00       	ld.sh	r0,r0[0x0]
80002c56:	63 34       	ld.w	r4,r1[0x4c]
80002c58:	00 00       	add	r0,r0
80002c5a:	0a c8       	st.b	r5++,r8

80002c5c <get_idle_store_isr>:
		return NULL;
	}
}

void * get_idle_store_isr(xQueueHandle store)
{
80002c5c:	d4 01       	pushm	lr
80002c5e:	20 2d       	sub	sp,8
	void * ptr = NULL;
80002c60:	30 08       	mov	r8,0
80002c62:	50 18       	stdsp	sp[0x4],r8
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002c64:	50 08       	stdsp	sp[0x0],r8
	
	if(pdTRUE == xQueueReceiveFromISR(store, &ptr, &xHigherPriorityTaskWoken))
80002c66:	1a 9a       	mov	r10,sp
80002c68:	fa cb ff fc 	sub	r11,sp,-4
80002c6c:	f0 1f 00 05 	mcall	80002c80 <get_idle_store_isr+0x24>
80002c70:	58 1c       	cp.w	r12,1
80002c72:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80002c76:	fb fc 00 01 	ld.weq	r12,sp[0x4]
	}
	else
	{
		return NULL;
	}
}
80002c7a:	2f ed       	sub	sp,-8
80002c7c:	d8 02       	popm	pc
80002c7e:	00 00       	add	r0,r0
80002c80:	80 00       	ld.sh	r0,r0[0x0]
80002c82:	60 38       	ld.w	r8,r0[0xc]

80002c84 <phy_tx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_tx_func( void * ssc)
{
80002c84:	eb cd 40 c0 	pushm	r6-r7,lr
80002c88:	20 1d       	sub	sp,4
80002c8a:	18 97       	mov	r7,r12
    if(NULL != phy_xnl_frame_tx)
80002c8c:	4b a8       	lddpc	r8,80002d74 <phy_tx_func+0xf0>
80002c8e:	70 08       	ld.w	r8,r8[0x0]
80002c90:	58 08       	cp.w	r8,0
80002c92:	c6 60       	breq	80002d5e <phy_tx_func+0xda>
    {
  	  	/*send ssc data in xnl frame*/
  	  	phy_xnl_tx(&(((ssc_fragment_t * )ssc)->xnl_channel));		
80002c94:	18 96       	mov	r6,r12
Called By:phy_tx_func
*/
static void phy_xnl_tx(xnl_channel_t * xnl_tx_channel)
{
	/*variables are used to store the push result in interrupt*/
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002c96:	30 08       	mov	r8,0
80002c98:	50 08       	stdsp	sp[0x0],r8
	
	static S16 phy_tx_expexted_length = 0;
	static U8 phy_tx_index = 0;
	
	/*his is the code for handling any outgoing XNL Phy message*/
	switch(phy_tx_state)
80002c9a:	4b 88       	lddpc	r8,80002d78 <phy_tx_func+0xf4>
80002c9c:	70 08       	ld.w	r8,r8[0x0]
80002c9e:	58 18       	cp.w	r8,1
80002ca0:	c2 60       	breq	80002cec <phy_tx_func+0x68>
80002ca2:	c0 43       	brcs	80002caa <phy_tx_func+0x26>
80002ca4:	58 28       	cp.w	r8,2
80002ca6:	c5 c1       	brne	80002d5e <phy_tx_func+0xda>
80002ca8:	c5 58       	rjmp	80002d52 <phy_tx_func+0xce>
	{
		/*Waiting for the send xnl packet*/
		case WAITING_FOR_PHY_TX:			
			if( pdTRUE == xQueueReceiveFromISR(
80002caa:	4b 38       	lddpc	r8,80002d74 <phy_tx_func+0xf0>
80002cac:	70 0c       	ld.w	r12,r8[0x0]
80002cae:	1a 9a       	mov	r10,sp
80002cb0:	4b 3b       	lddpc	r11,80002d7c <phy_tx_func+0xf8>
80002cb2:	f0 1f 00 34 	mcall	80002d80 <phy_tx_func+0xfc>
80002cb6:	58 1c       	cp.w	r12,1
80002cb8:	c1 41       	brne	80002ce0 <phy_tx_func+0x5c>
				  phy_xnl_frame_tx
				, &phy_ptr
				, &xHigherPriorityTaskWoken 
			))
			{								
				phy_tx_expexted_length = 
80002cba:	4b 18       	lddpc	r8,80002d7c <phy_tx_func+0xf8>
80002cbc:	70 08       	ld.w	r8,r8[0x0]
80002cbe:	90 08       	ld.sh	r8,r8[0x0]
80002cc0:	10 9a       	mov	r10,r8
80002cc2:	f5 da c0 08 	bfextu	r10,r10,0x0,0x8
80002cc6:	4b 09       	lddpc	r9,80002d84 <phy_tx_func+0x100>
80002cc8:	b2 0a       	st.h	r9[0x0],r10
				*/
				xnl_tx_channel->dword = 
				                   phy_ptr->xnl_fragment.phy_header.phy_control;
				
				/*Transmit 0xABCD0000 | Type/Length.*/
				xnl_tx_channel->dword |= PHYHEADER32;
80002cca:	5c 78       	castu.h	r8
80002ccc:	ea 18 ab cd 	orh	r8,0xabcd
80002cd0:	8f 18       	st.w	r7[0x4],r8
				
				phy_tx_index = 1;
80002cd2:	30 19       	mov	r9,1
80002cd4:	4a d8       	lddpc	r8,80002d88 <phy_tx_func+0x104>
80002cd6:	b0 89       	st.b	r8[0x0],r9
				phy_tx_state = WRITE_NEXT_DWORD;	
80002cd8:	30 19       	mov	r9,1
80002cda:	4a 88       	lddpc	r8,80002d78 <phy_tx_func+0xf4>
80002cdc:	91 09       	st.w	r8[0x0],r9
80002cde:	c4 08       	rjmp	80002d5e <phy_tx_func+0xda>
				/*The new transmission has started.*/
			}
			else
			{
				/*Nothing new to transmit, send an idle frame*/
				xnl_tx_channel->dword = XNL_IDLE;
80002ce0:	e0 68 5a 5a 	mov	r8,23130
80002ce4:	ea 18 ab cd 	orh	r8,0xabcd
80002ce8:	8f 18       	st.w	r7[0x4],r8
80002cea:	c3 a8       	rjmp	80002d5e <phy_tx_func+0xda>
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80002cec:	4a 7a       	lddpc	r10,80002d88 <phy_tx_func+0x104>
80002cee:	15 88       	ld.ub	r8,r10[0x0]
				xnl_tx_channel->dword = XNL_IDLE;
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
80002cf0:	4a 39       	lddpc	r9,80002d7c <phy_tx_func+0xf8>
80002cf2:	72 09       	ld.w	r9,r9[0x0]
80002cf4:	f2 08 05 19 	ld.uh	r9,r9[r8<<0x1]
80002cf8:	b1 69       	lsl	r9,0x10
80002cfa:	99 19       	st.w	r12[0x4],r9
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80002cfc:	2f f8       	sub	r8,-1
80002cfe:	5c 58       	castu.b	r8
80002d00:	b4 88       	st.b	r10[0x0],r8

			phy_tx_expexted_length -= 2;
80002d02:	4a 1b       	lddpc	r11,80002d84 <phy_tx_func+0x100>
80002d04:	96 0c       	ld.sh	r12,r11[0x0]
80002d06:	20 2c       	sub	r12,2
80002d08:	5c 8c       	casts.h	r12
80002d0a:	f5 dc b0 10 	bfexts	r10,r12,0x0,0x10
80002d0e:	b6 0a       	st.h	r11[0x0],r10
			
			/*have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80002d10:	30 0b       	mov	r11,0
80002d12:	f6 0a 19 00 	cp.h	r10,r11
80002d16:	e0 89 00 09 	brgt	80002d28 <phy_tx_func+0xa4>
			{
				/*Must immediately send 0x00BA in Slot 4.*/
				xnl_tx_channel->dword |= PHYTERMRIGHT;
80002d1a:	e8 19 00 ba 	orl	r9,0xba
80002d1e:	8f 19       	st.w	r7[0x4],r9
				
				/*Go back to waiting.*/
				phy_tx_state = WAITING_FOR_PHY_TX;
80002d20:	30 09       	mov	r9,0
80002d22:	49 68       	lddpc	r8,80002d78 <phy_tx_func+0xf4>
80002d24:	91 09       	st.w	r8[0x0],r9
80002d26:	c1 c8       	rjmp	80002d5e <phy_tx_func+0xda>
				break;
			}

			/*Have not broken. Transmit 2nd hWord.*/
			xnl_tx_channel->dword |=  phy_ptr->fragment_element[phy_tx_index++];
80002d28:	49 5a       	lddpc	r10,80002d7c <phy_tx_func+0xf8>
80002d2a:	74 0a       	ld.w	r10,r10[0x0]
80002d2c:	f4 08 05 1a 	ld.uh	r10,r10[r8<<0x1]
80002d30:	14 49       	or	r9,r10
80002d32:	8f 19       	st.w	r7[0x4],r9
80002d34:	2f f8       	sub	r8,-1
80002d36:	49 59       	lddpc	r9,80002d88 <phy_tx_func+0x104>
80002d38:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
80002d3a:	20 2c       	sub	r12,2
80002d3c:	49 28       	lddpc	r8,80002d84 <phy_tx_func+0x100>
80002d3e:	b0 0c       	st.h	r8[0x0],r12
			
			/*Have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80002d40:	30 08       	mov	r8,0
80002d42:	f0 0c 19 00 	cp.h	r12,r8
80002d46:	e0 89 00 0c 	brgt	80002d5e <phy_tx_func+0xda>
			{
				/*Must send 0x00BA0000 next interrupt in Slot 3&4*/
				phy_tx_state = SEND_TAILED;
80002d4a:	30 29       	mov	r9,2
80002d4c:	48 b8       	lddpc	r8,80002d78 <phy_tx_func+0xf4>
80002d4e:	91 09       	st.w	r8[0x0],r9
80002d50:	c0 78       	rjmp	80002d5e <phy_tx_func+0xda>
			}
			break;

		case SEND_TAILED:
			/*send 0x00BA0000*/
			xnl_tx_channel->dword = PHYTERMLEFT;
80002d52:	fc 18 00 ba 	movh	r8,0xba
80002d56:	99 18       	st.w	r12[0x4],r8
			
			/*Go back to waiting.*/		
			phy_tx_state = WAITING_FOR_PHY_TX;		
80002d58:	30 09       	mov	r9,0
80002d5a:	48 88       	lddpc	r8,80002d78 <phy_tx_func+0xf4>
80002d5c:	91 09       	st.w	r8[0x0],r9
	//#else
	///*send idle frame*/	
	//((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
	//((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
	//#endif /*end if*/
	((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
80002d5e:	e0 68 5a 5a 	mov	r8,23130
80002d62:	ea 18 ab cd 	orh	r8,0xabcd
80002d66:	8f 28       	st.w	r7[0x8],r8
	((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
80002d68:	30 08       	mov	r8,0
80002d6a:	8f 38       	st.w	r7[0xc],r8
}
80002d6c:	2f fd       	sub	sp,-4
80002d6e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002d72:	00 00       	add	r0,r0
80002d74:	00 00       	add	r0,r0
80002d76:	0a d4       	st.w	--r5,r4
80002d78:	00 00       	add	r0,r0
80002d7a:	0a 94       	mov	r4,r5
80002d7c:	00 00       	add	r0,r0
80002d7e:	0a a0       	st.w	r5++,r0
80002d80:	80 00       	ld.sh	r0,r0[0x0]
80002d82:	60 38       	ld.w	r8,r0[0xc]
80002d84:	00 00       	add	r0,r0
80002d86:	0a bc       	st.h	r5++,r12
80002d88:	00 00       	add	r0,r0
80002d8a:	0a 74       	tst	r4,r5

80002d8c <get_idle_store>:
	}//End of RxMedia Phy Handler.
}
#endif /*end if*/

void * get_idle_store(xQueueHandle store)
{
80002d8c:	d4 01       	pushm	lr
80002d8e:	20 1d       	sub	sp,4
	void * ptr = NULL;
80002d90:	30 0a       	mov	r10,0
80002d92:	fa cb ff fc 	sub	r11,sp,-4
80002d96:	16 da       	st.w	--r11,r10

	if(pdTRUE == xQueueReceive(store, &ptr, 0))
80002d98:	14 99       	mov	r9,r10
80002d9a:	1a 9b       	mov	r11,sp
80002d9c:	f0 1f 00 05 	mcall	80002db0 <get_idle_store+0x24>
80002da0:	58 1c       	cp.w	r12,1
80002da2:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80002da6:	fb fc 00 00 	ld.weq	r12,sp[0x0]
	}
	else
	{
		return NULL;
	}
}
80002daa:	2f fd       	sub	sp,-4
80002dac:	d8 02       	popm	pc
80002dae:	00 00       	add	r0,r0
80002db0:	80 00       	ld.sh	r0,r0[0x0]
80002db2:	61 28       	ld.w	r8,r0[0x48]

80002db4 <phy_init>:
    register_rx_tx_func -- ssc.c
	xQueueCreate -- freertos
Called By: xnl_init -- xnl.c
*/
void phy_init( void )
{
80002db4:	d4 01       	pushm	lr
    /*register the func to send/receive ssc packet*/
    register_rx_tx_func(phy_rx_func, phy_tx_func);	
80002db6:	48 5b       	lddpc	r11,80002dc8 <phy_init+0x14>
80002db8:	48 5c       	lddpc	r12,80002dcc <phy_init+0x18>
80002dba:	f0 1f 00 06 	mcall	80002dd0 <phy_init+0x1c>
	
	/*initialize the SSC*/
	ssc_init();
80002dbe:	f0 1f 00 06 	mcall	80002dd4 <phy_init+0x20>
	
	/*send device_master_query to connect radio*/
	xnl_send_device_master_query();
80002dc2:	f0 1f 00 06 	mcall	80002dd8 <phy_init+0x24>
	
}
80002dc6:	d8 02       	popm	pc
80002dc8:	80 00       	ld.sh	r0,r0[0x0]
80002dca:	2c 84       	sub	r4,-56
80002dcc:	80 00       	ld.sh	r0,r0[0x0]
80002dce:	2d dc       	sub	r12,-35
80002dd0:	80 00       	ld.sh	r0,r0[0x0]
80002dd2:	3e 30       	mov	r0,-29
80002dd4:	80 00       	ld.sh	r0,r0[0x0]
80002dd6:	3e 44       	mov	r4,-28
80002dd8:	80 00       	ld.sh	r0,r0[0x0]
80002dda:	47 f0       	lddsp	r0,sp[0x1fc]

80002ddc <phy_rx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_rx_func( void * ssc)
{    
80002ddc:	eb cd 40 e0 	pushm	r5-r7,lr
80002de0:	18 97       	mov	r7,r12
		
	if(NULL != phy_xnl_frame_rx)
80002de2:	fe f8 0e 7a 	ld.w	r8,pc[3706]
80002de6:	70 08       	ld.w	r8,r8[0x0]
80002de8:	58 08       	cp.w	r8,0
80002dea:	e0 80 01 08 	breq	80002ffa <phy_rx_func+0x21e>
	static U16 phy_check_sum = 0;

	static phy_rx_state_t  phy_rx_state = WAITING_FOR_HEADER;
	static U32 phy_rx_count = 0;

	U32 phy_dword = xnl_rx_channel->dword;	
80002dee:	78 16       	ld.w	r6,r12[0x4]

	phy_rx_count++;
80002df0:	fe f8 0e 70 	ld.w	r8,pc[3696]
80002df4:	70 09       	ld.w	r9,r8[0x0]
80002df6:	2f f9       	sub	r9,-1
80002df8:	91 09       	st.w	r8[0x0],r9
	
	/*This is the code for parsing the incoming physical message.*/
	switch (phy_rx_state)
80002dfa:	fe f8 0e 6a 	ld.w	r8,pc[3690]
80002dfe:	70 08       	ld.w	r8,r8[0x0]
80002e00:	58 18       	cp.w	r8,1
80002e02:	e0 80 00 85 	breq	80002f0c <phy_rx_func+0x130>
80002e06:	c0 73       	brcs	80002e14 <phy_rx_func+0x38>
80002e08:	58 28       	cp.w	r8,2
80002e0a:	c5 c0       	breq	80002ec2 <phy_rx_func+0xe6>
80002e0c:	58 38       	cp.w	r8,3
80002e0e:	e0 81 00 f6 	brne	80002ffa <phy_rx_func+0x21e>
80002e12:	cd 58       	rjmp	80002fbc <phy_rx_func+0x1e0>

        /*Waiting for something. Most frequent visit.*/		
		case WAITING_FOR_HEADER:
		
			/*Ignore Idles.*/
			if (0xABCD5A5A == phy_dword)
80002e14:	e0 6a 5a 5a 	mov	r10,23130
80002e18:	ea 1a ab cd 	orh	r10,0xabcd
80002e1c:	14 36       	cp.w	r6,r10
80002e1e:	e0 80 00 ee 	breq	80002ffa <phy_rx_func+0x21e>
			{
				break;
			}	

			/*Skip until Header.*/		
			if (0xABCD != (phy_dword >> 16))
80002e22:	ec 08 16 10 	lsr	r8,r6,0x10
80002e26:	e0 48 ab cd 	cp.w	r8,43981
80002e2a:	e0 81 00 e8 	brne	80002ffa <phy_rx_func+0x21e>
			{			
				break;
			}
		
			/*Length excluding CSUM.*/
			phy_rx_expexted_length = (phy_dword & 0x000000FF) - 2;
80002e2e:	eb d6 b0 10 	bfexts	r5,r6,0x0,0x10
80002e32:	f1 d5 c0 08 	bfextu	r8,r5,0x0,0x8
80002e36:	20 28       	sub	r8,2
80002e38:	fe f9 0e 30 	ld.w	r9,pc[3632]
80002e3c:	b2 08       	st.h	r9[0x0],r8
			
			/*Discard degenerate message.*/
			if (phy_rx_expexted_length <= 0)
80002e3e:	30 09       	mov	r9,0
80002e40:	f2 08 19 00 	cp.h	r8,r9
80002e44:	e0 8a 00 db 	brle	80002ffa <phy_rx_func+0x21e>
			{
				break;
			}
		
			phy_rx_length = 0;
80002e48:	fe f8 0e 24 	ld.w	r8,pc[3620]
80002e4c:	b0 09       	st.h	r8[0x0],r9

			phy_frame_ptr = get_xnl_idle_isr();
80002e4e:	fe f8 0e 22 	ld.w	r8,pc[3618]
80002e52:	70 0c       	ld.w	r12,r8[0x0]
80002e54:	f0 1f 03 88 	mcall	80003c74 <phy_rx_func+0xe98>
80002e58:	fe f8 0e 20 	ld.w	r8,pc[3616]
80002e5c:	91 0c       	st.w	r8[0x0],r12
			if(NULL == phy_frame_ptr)
80002e5e:	58 0c       	cp.w	r12,0
80002e60:	e0 80 00 cd 	breq	80002ffa <phy_rx_func+0x21e>
			{
				break;
			}
					
			phy_frame_ptr->fragment_element[phy_rx_length++] = phy_dword;
80002e64:	fe f8 0e 08 	ld.w	r8,pc[3592]
80002e68:	90 09       	ld.sh	r9,r8[0x0]
80002e6a:	f8 09 0a 15 	st.h	r12[r9<<0x1],r5
80002e6e:	2f f9       	sub	r9,-1
80002e70:	5c 89       	casts.h	r9
			
			/*time stamp*/
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
80002e72:	fe fa 0e 06 	ld.w	r10,pc[3590]
80002e76:	74 0a       	ld.w	r10,r10[0x0]
80002e78:	fe fb 0d e8 	ld.w	r11,pc[3560]
80002e7c:	76 0b       	ld.w	r11,r11[0x0]
80002e7e:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
80002e82:	2f f9       	sub	r9,-1
80002e84:	b0 09       	st.h	r8[0x0],r9
													(phy_rx_count) & 0x0000FFFF;
			
			/*This switch tests the fragment type, and adjusts receiver state
			accordingly.*/
			/*Check frag type*/
			switch (phy_dword & 0x00000F00)
80002e86:	e2 16 0f 00 	andl	r6,0xf00,COH
80002e8a:	e0 46 01 00 	cp.w	r6,256
80002e8e:	c0 c0       	breq	80002ea6 <phy_rx_func+0xca>
80002e90:	e0 8b 00 05 	brhi	80002e9a <phy_rx_func+0xbe>
80002e94:	58 06       	cp.w	r6,0
80002e96:	c0 80       	breq	80002ea6 <phy_rx_func+0xca>
80002e98:	c0 c8       	rjmp	80002eb0 <phy_rx_func+0xd4>
80002e9a:	e0 46 02 00 	cp.w	r6,512
80002e9e:	c0 40       	breq	80002ea6 <phy_rx_func+0xca>
80002ea0:	e0 46 03 00 	cp.w	r6,768
80002ea4:	c0 61       	brne	80002eb0 <phy_rx_func+0xd4>
			{
				case SINGLE_FRAGMENT:  //Only Fragment.
				case FIRST_FRAGMENT:   //First of Multi-fragment.
				case MIDDLE_FRAGMENT:  //Continuing Multi-fragment.
				case LAST_FRAGMENT:    //Last Multi-fragment.
					phy_rx_state = WAITING_CHECK_SUM;
80002ea6:	30 29       	mov	r9,2
80002ea8:	fe f8 0d bc 	ld.w	r8,pc[3516]
80002eac:	91 09       	st.w	r8[0x0],r9
80002eae:	ca 68       	rjmp	80002ffa <phy_rx_func+0x21e>
				break;
				default:
					set_xnl_idle_isr(phy_frame_ptr);			
80002eb0:	fe f8 0d c0 	ld.w	r8,pc[3520]
80002eb4:	70 0c       	ld.w	r12,r8[0x0]
80002eb6:	fe f8 0d c2 	ld.w	r8,pc[3522]
80002eba:	70 0b       	ld.w	r11,r8[0x0]
80002ebc:	f0 1f 03 70 	mcall	80003c7c <phy_rx_func+0xea0>
80002ec0:	c9 d8       	rjmp	80002ffa <phy_rx_func+0x21e>
		
			/*Stores CSUM*/
			phy_check_sum  = (phy_dword & 0xFFFF0000) >> 16;
			
			/*sums in first hWord*/
			phy_check_sum += (phy_dword & 0x0000FFFF);		
80002ec2:	f5 d6 b0 10 	bfexts	r10,r6,0x0,0x10
80002ec6:	b1 86       	lsr	r6,0x10
80002ec8:	14 06       	add	r6,r10
80002eca:	fe f8 0d b6 	ld.w	r8,pc[3510]
80002ece:	b0 06       	st.h	r8[0x0],r6
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
80002ed0:	fe f8 0d 9c 	ld.w	r8,pc[3484]
80002ed4:	90 09       	ld.sh	r9,r8[0x0]
80002ed6:	fe fb 0d a2 	ld.w	r11,pc[3490]
80002eda:	76 0b       	ld.w	r11,r11[0x0]
80002edc:	f6 09 0a 1a 	st.h	r11[r9<<0x1],r10
80002ee0:	2f f9       	sub	r9,-1
80002ee2:	b0 09       	st.h	r8[0x0],r9
														 phy_dword & 0x0000FFFF;
					
			phy_rx_expexted_length -= 2;
80002ee4:	fe f9 0d 84 	ld.w	r9,pc[3460]
80002ee8:	92 08       	ld.sh	r8,r9[0x0]
80002eea:	20 28       	sub	r8,2
80002eec:	b2 08       	st.h	r9[0x0],r8
			
			/*Normal case for greater than one byte payloads.*/
			if (phy_rx_expexted_length > 0)
80002eee:	30 09       	mov	r9,0
80002ef0:	f2 08 19 00 	cp.h	r8,r9
80002ef4:	e0 8a 00 07 	brle	80002f02 <phy_rx_func+0x126>
			{					  
				phy_rx_state = READING_FRAGMENT;
80002ef8:	30 19       	mov	r9,1
80002efa:	fe f8 0d 6a 	ld.w	r8,pc[3434]
80002efe:	91 09       	st.w	r8[0x0],r9
80002f00:	c7 d8       	rjmp	80002ffa <phy_rx_func+0x21e>
	    		Note that all segments must align with a 32-bit boundary and
				beginning of each XCMP/XNL payload frame must start on slot 3
				Thus, segments of odd length must append a 0x0000 at the end
				(slot 4) to ensure alignment. [9.1.3]
				*/
				phy_rx_state = WAITING_LAST_TERM;
80002f02:	30 39       	mov	r9,3
80002f04:	fe f8 0d 60 	ld.w	r8,pc[3424]
80002f08:	91 09       	st.w	r8[0x0],r9
80002f0a:	c7 88       	rjmp	80002ffa <phy_rx_func+0x21e>
			}			
		
			break;

		case READING_FRAGMENT:
			phy_check_sum += (phy_dword & 0xFFFF0000) >> 16;
80002f0c:	ec 0a 14 10 	asr	r10,r6,0x10
80002f10:	fe f8 0d 70 	ld.w	r8,pc[3440]
80002f14:	90 09       	ld.sh	r9,r8[0x0]
80002f16:	14 09       	add	r9,r10
80002f18:	b0 09       	st.h	r8[0x0],r9
	
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
80002f1a:	fe f9 0d 52 	ld.w	r9,pc[3410]
80002f1e:	92 08       	ld.sh	r8,r9[0x0]
80002f20:	fe fb 0d 58 	ld.w	r11,pc[3416]
80002f24:	76 0b       	ld.w	r11,r11[0x0]
80002f26:	f6 08 0a 1a 	st.h	r11[r8<<0x1],r10
80002f2a:	2f f8       	sub	r8,-1
80002f2c:	5c 88       	casts.h	r8
80002f2e:	b2 08       	st.h	r9[0x0],r8
												 (phy_dword & 0xFFFF0000) >> 16;
	
			phy_rx_expexted_length -= 2;
80002f30:	fe fa 0d 38 	ld.w	r10,pc[3384]
80002f34:	94 09       	ld.sh	r9,r10[0x0]
80002f36:	20 29       	sub	r9,2
80002f38:	b4 09       	st.h	r10[0x0],r9
			if (phy_rx_expexted_length <= 0)
80002f3a:	30 0a       	mov	r10,0
80002f3c:	f4 09 19 00 	cp.h	r9,r10
80002f40:	e0 89 00 20 	brgt	80002f80 <phy_rx_func+0x1a4>
				Terminator should be in 2nd hWord.
				Shaoqun says useful bits not used. The packet will always end
				with $00BA. [9.1.2.8]	
				*/
				
				if ((0x000000BA == (phy_dword  & 0x0000FFFF)) 
80002f44:	ed d6 c0 10 	bfextu	r6,r6,0x0,0x10
80002f48:	e0 46 00 ba 	cp.w	r6,186
80002f4c:	c0 d1       	brne	80002f66 <phy_rx_func+0x18a>
80002f4e:	fe f8 0d 32 	ld.w	r8,pc[3378]
80002f52:	90 09       	ld.sh	r9,r8[0x0]
80002f54:	f4 09 19 00 	cp.h	r9,r10
80002f58:	c0 71       	brne	80002f66 <phy_rx_func+0x18a>
					&& (phy_check_sum == 0))
				{
					phy_rx(phy_frame_ptr);
80002f5a:	fe f8 0d 1e 	ld.w	r8,pc[3358]
80002f5e:	70 0c       	ld.w	r12,r8[0x0]
80002f60:	f0 1f 03 49 	mcall	80003c84 <phy_rx_func+0xea8>
80002f64:	c0 98       	rjmp	80002f76 <phy_rx_func+0x19a>
				}
				else
				{
					set_xnl_idle_isr(phy_frame_ptr);
80002f66:	fe f8 0d 0a 	ld.w	r8,pc[3338]
80002f6a:	70 0c       	ld.w	r12,r8[0x0]
80002f6c:	fe f8 0d 0c 	ld.w	r8,pc[3340]
80002f70:	70 0b       	ld.w	r11,r8[0x0]
80002f72:	f0 1f 03 43 	mcall	80003c7c <phy_rx_func+0xea0>
				}

				phy_rx_state = WAITING_FOR_HEADER;
80002f76:	30 09       	mov	r9,0
80002f78:	fe f8 0c ec 	ld.w	r8,pc[3308]
80002f7c:	91 09       	st.w	r8[0x0],r9
80002f7e:	c3 e8       	rjmp	80002ffa <phy_rx_func+0x21e>
				break;
			}
		
			/*Have not broken. 2nd hWord contains payload.*/
			phy_check_sum += (phy_dword & 0x0000FFFF);
80002f80:	5c 86       	casts.h	r6
80002f82:	fe f9 0c fe 	ld.w	r9,pc[3326]
80002f86:	92 0a       	ld.sh	r10,r9[0x0]
80002f88:	0c 0a       	add	r10,r6
80002f8a:	b2 0a       	st.h	r9[0x0],r10
		
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
80002f8c:	fe f9 0c ec 	ld.w	r9,pc[3308]
80002f90:	72 09       	ld.w	r9,r9[0x0]
80002f92:	f2 08 0a 16 	st.h	r9[r8<<0x1],r6
80002f96:	2f f8       	sub	r8,-1
80002f98:	fe f9 0c d4 	ld.w	r9,pc[3284]
80002f9c:	b2 08       	st.h	r9[0x0],r8
													   (phy_dword & 0x0000FFFF);
		
			phy_rx_expexted_length -= 2;
80002f9e:	fe f9 0c ca 	ld.w	r9,pc[3274]
80002fa2:	92 08       	ld.sh	r8,r9[0x0]
80002fa4:	20 28       	sub	r8,2
80002fa6:	b2 08       	st.h	r9[0x0],r8
			if (phy_rx_expexted_length <= 0)
80002fa8:	30 09       	mov	r9,0
80002faa:	f2 08 19 00 	cp.h	r8,r9
80002fae:	e0 89 00 26 	brgt	80002ffa <phy_rx_func+0x21e>
			{
				/*All read in. Next Word should be 0x00BA0000.*/
				phy_rx_state = WAITING_LAST_TERM;
80002fb2:	30 39       	mov	r9,3
80002fb4:	fe f8 0c b0 	ld.w	r8,pc[3248]
80002fb8:	91 09       	st.w	r8[0x0],r9
80002fba:	c2 08       	rjmp	80002ffa <phy_rx_func+0x21e>
			}/*else, next Word contains more payload.*/
			break;

		/*Expecting last terminator 0x00BA0000.*/	
		case WAITING_LAST_TERM:			
			if ((0x00BA0000 == (phy_dword  & 0x00FF0000)) /*Expected found.*/
80002fbc:	e6 16 00 ff 	andh	r6,0xff,COH
80002fc0:	fc 19 00 ba 	movh	r9,0xba
80002fc4:	12 36       	cp.w	r6,r9
80002fc6:	c0 e1       	brne	80002fe2 <phy_rx_func+0x206>
80002fc8:	fe f8 0c b8 	ld.w	r8,pc[3256]
80002fcc:	90 09       	ld.sh	r9,r8[0x0]
80002fce:	30 08       	mov	r8,0
80002fd0:	f0 09 19 00 	cp.h	r9,r8
80002fd4:	c0 71       	brne	80002fe2 <phy_rx_func+0x206>
				&& (phy_check_sum == 0))/*Good checksum*/
			{
				phy_rx(phy_frame_ptr);
80002fd6:	fe f8 0c a2 	ld.w	r8,pc[3234]
80002fda:	70 0c       	ld.w	r12,r8[0x0]
80002fdc:	f0 1f 03 2a 	mcall	80003c84 <phy_rx_func+0xea8>
80002fe0:	c0 98       	rjmp	80002ff2 <phy_rx_func+0x216>

			}
			else
			{
				set_xnl_idle_isr(phy_frame_ptr);
80002fe2:	fe f8 0c 8e 	ld.w	r8,pc[3214]
80002fe6:	70 0c       	ld.w	r12,r8[0x0]
80002fe8:	fe f8 0c 90 	ld.w	r8,pc[3216]
80002fec:	70 0b       	ld.w	r11,r8[0x0]
80002fee:	f0 1f 03 24 	mcall	80003c7c <phy_rx_func+0xea0>
			}
				
			phy_rx_state = WAITING_FOR_HEADER;
80002ff2:	30 09       	mov	r9,0
80002ff4:	fe f8 0c 70 	ld.w	r8,pc[3184]
80002ff8:	91 09       	st.w	r8[0x0],r9
	static U8 _flag = 1;//0xABCDC014时，_flag为0；
						//0xABCDC010时，_flag为1；
			
	//payload_ptr_t *AMBE_payload_ptr;		
	
	if(is_first == FALSE)
80002ffa:	fe f8 0c 8e 	ld.w	r8,pc[3214]
80002ffe:	11 89       	ld.ub	r9,r8[0x0]
80003000:	30 08       	mov	r8,0
80003002:	f0 09 18 00 	cp.b	r9,r8
80003006:	c1 31       	brne	8000302c <phy_rx_func+0x250>
	{
		payload_ptr = get_payload_idle_isr();
80003008:	fe f6 0c 84 	ld.w	r6,pc[3204]
8000300c:	6c 0c       	ld.w	r12,r6[0x0]
8000300e:	f0 1f 03 1a 	mcall	80003c74 <phy_rx_func+0xe98>
80003012:	fe f8 0c 7e 	ld.w	r8,pc[3198]
80003016:	91 0c       	st.w	r8[0x0],r12
		AMBE_payload_ptr = get_payload_idle_isr();
80003018:	6c 0c       	ld.w	r12,r6[0x0]
8000301a:	f0 1f 03 17 	mcall	80003c74 <phy_rx_func+0xe98>
8000301e:	fe f8 0c 76 	ld.w	r8,pc[3190]
80003022:	91 0c       	st.w	r8[0x0],r12
		is_first = TRUE;
80003024:	30 19       	mov	r9,1
80003026:	fe f8 0c 62 	ld.w	r8,pc[3170]
8000302a:	b0 89       	st.b	r8[0x0],r9
	}	
	
	//This is the RxMedia Phy Handler.
	switch (RxMediaState)
8000302c:	fe f8 0c 6c 	ld.w	r8,pc[3180]
80003030:	70 08       	ld.w	r8,r8[0x0]
80003032:	58 28       	cp.w	r8,2
80003034:	e0 80 01 98 	breq	80003364 <phy_rx_func+0x588>
80003038:	e0 8b 00 06 	brhi	80003044 <phy_rx_func+0x268>
8000303c:	58 08       	cp.w	r8,0
8000303e:	c0 b0       	breq	80003054 <phy_rx_func+0x278>
80003040:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80003044:	58 38       	cp.w	r8,3
80003046:	e0 80 05 c5 	breq	80003bd0 <phy_rx_func+0xdf4>
8000304a:	58 48       	cp.w	r8,4
8000304c:	e0 81 06 05 	brne	80003c56 <phy_rx_func+0xe7a>
80003050:	e0 8f 02 4b 	bral	800034e6 <phy_rx_func+0x70a>
	{
		case WAITINGABAB:

			
			if (payload_rx_channel->dword[0] == 0xABCD5A5A)//Ignore Idles.
80003054:	6e 28       	ld.w	r8,r7[0x8]
80003056:	e0 6a 5a 5a 	mov	r10,23130
8000305a:	ea 1a ab cd 	orh	r10,0xabcd
8000305e:	14 38       	cp.w	r8,r10
80003060:	c0 71       	brne	8000306e <phy_rx_func+0x292>
			{
				m_RxBurstType = VOICE_WATING;
80003062:	30 09       	mov	r9,0
80003064:	fe f8 0c 38 	ld.w	r8,pc[3128]
80003068:	91 09       	st.w	r8[0x0],r9
8000306a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
				//Upon receiving the idle frame, the m Rx Burst Type into an idle state in order to transmit the synchronization wait
				 break; 
			}
            
			if ((payload_rx_channel->dword[0]  & 0xFFFF0000) != 0xABCD0000)break; //Skip until Header. 
8000306e:	10 99       	mov	r9,r8
80003070:	e0 19 00 00 	andl	r9,0x0
80003074:	fc 1a ab cd 	movh	r10,0xabcd
80003078:	14 39       	cp.w	r9,r10
8000307a:	e0 81 05 ee 	brne	80003c56 <phy_rx_func+0xe7a>
			}
			//logFromISR("\n\r P: %X \n\r", payload_rx_channel->word[1]);//测试收到的数据
			
#endif
			
			RxBytesWaiting = payload_rx_channel->dword[0] & 0x000000FF;
8000307e:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
80003082:	fe f9 0c 1e 	ld.w	r9,pc[3102]
80003086:	93 08       	st.w	r9[0x0],r8
			/****Note AMBE stream protocol frame structure and the PCM frame structure is different*****/
					
			if ((payload_rx_channel->dword[0] & 0x0000F000 ) == PAYLOAD_DATA_ENH )//PAYLOAD_DATA_ENH (0x0c))
80003088:	6e 29       	ld.w	r9,r7[0x8]
8000308a:	e2 19 f0 00 	andl	r9,0xf000,COH
8000308e:	e0 49 c0 00 	cp.w	r9,49152
80003092:	e0 81 00 ce 	brne	8000322e <phy_rx_func+0x452>
			{
				AMBE_Media = 1;	
80003096:	30 1a       	mov	r10,1
80003098:	fe f9 0c 0c 	ld.w	r9,pc[3084]
8000309c:	b2 8a       	st.b	r9[0x0],r10
				
				if (NULL== AMBE_payload_ptr){
8000309e:	fe f9 0b f6 	ld.w	r9,pc[3062]
800030a2:	72 09       	ld.w	r9,r9[0x0]
800030a4:	58 09       	cp.w	r9,0
800030a6:	c0 71       	brne	800030b4 <phy_rx_func+0x2d8>
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//测试是否有这种情况出现
800030a8:	fe fc 0c 00 	ld.w	r12,pc[3072]
800030ac:	f0 1f 03 00 	mcall	80003cac <phy_rx_func+0xed0>
800030b0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
																	
				Item_ID = payload_rx_channel->byte[5];
800030b4:	ef 3a 00 0d 	ld.ub	r10,r7[13]
800030b8:	fe f9 0b f8 	ld.w	r9,pc[3064]
800030bc:	b2 8a       	st.b	r9[0x0],r10
				
				Item_Length = (payload_rx_channel->byte[4] & 0x7F);//7bits
800030be:	ef 3b 00 0c 	ld.ub	r11,r7[12]
800030c2:	f7 db c0 07 	bfextu	r11,r11,0x0,0x7
800030c6:	fe fa 0b ee 	ld.w	r10,pc[3054]
800030ca:	95 0b       	st.w	r10[0x0],r11
								
				switch(Item_ID)
800030cc:	13 89       	ld.ub	r9,r9[0x0]
800030ce:	37 fa       	mov	r10,127
800030d0:	f4 09 18 00 	cp.b	r9,r10
800030d4:	c6 d0       	breq	800031ae <phy_rx_func+0x3d2>
800030d6:	e0 8b 00 0c 	brhi	800030ee <phy_rx_func+0x312>
800030da:	31 2a       	mov	r10,18
800030dc:	f4 09 18 00 	cp.b	r9,r10
800030e0:	c4 20       	breq	80003164 <phy_rx_func+0x388>
800030e2:	31 3a       	mov	r10,19
800030e4:	f4 09 18 00 	cp.b	r9,r10
800030e8:	e0 81 00 83 	brne	800031ee <phy_rx_func+0x412>
800030ec:	c5 b8       	rjmp	800031a2 <phy_rx_func+0x3c6>
800030ee:	2f 09       	sub	r9,-16
800030f0:	30 1a       	mov	r10,1
800030f2:	f4 09 18 00 	cp.b	r9,r10
800030f6:	e0 8b 00 7c 	brhi	800031ee <phy_rx_func+0x412>
					//The OB know the Call begin and discard the Voice Header
					//The OB know the Call end and discard the Voice  Terminator
					case Raw_Tx_Data_HT://0xF0
					case Raw_Rx_Data_HT://0xF1
					
							if ((payload_rx_channel->byte[6] & 0xF0 )== 0x10)//header
800030fa:	ef 38 00 0e 	ld.ub	r8,r7[14]
800030fe:	e2 18 00 f0 	andl	r8,0xf0,COH
80003102:	59 08       	cp.w	r8,16
80003104:	c0 71       	brne	80003112 <phy_rx_func+0x336>
							{
								m_RxBurstType = VOICEHEADER;
80003106:	30 19       	mov	r9,1
80003108:	fe f8 0b 94 	ld.w	r8,pc[2964]
8000310c:	91 09       	st.w	r8[0x0],r9
8000310e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

							}
							else if ((payload_rx_channel->byte[6] & 0xF0) == 0x20)//Terminator
80003112:	e0 48 00 20 	cp.w	r8,32
80003116:	c2 11       	brne	80003158 <phy_rx_func+0x37c>
							{
								m_RxBurstType = VOICETERMINATOR;
80003118:	30 a9       	mov	r9,10
8000311a:	fe f8 0b 82 	ld.w	r8,pc[2946]
8000311e:	91 09       	st.w	r8[0x0],r9
								//AMBE-data and PCM-data is not the same. AMBE is compressed data,
								//if there was a missing portion, a clear voice is difficult to extract the data.
								//It must ensure that all the data received AMBE.
								
								//注意！！！考虑是否需要把剩余的空间置0。
								memset((AMBE_payload_ptr+ (RxAMBE_IsFillingNext8 +1)), 0x00, (512-(RxAMBE_IsFillingNext8 + 1)));
80003120:	fe f6 0b 98 	ld.w	r6,pc[2968]
80003124:	6c 08       	ld.w	r8,r6[0x0]
80003126:	f0 0a 11 ff 	rsub	r10,r8,-1
8000312a:	fe f7 0b 6a 	ld.w	r7,pc[2922]
8000312e:	2f f8       	sub	r8,-1
80003130:	6e 0c       	ld.w	r12,r7[0x0]
80003132:	f4 ca fe 00 	sub	r10,r10,-512
80003136:	30 0b       	mov	r11,0
80003138:	10 0c       	add	r12,r8
8000313a:	f0 1f 02 e1 	mcall	80003cbc <phy_rx_func+0xee0>
								
								RxAMBE_IsFillingNext8 = 0;
8000313e:	30 08       	mov	r8,0
80003140:	8d 08       	st.w	r6[0x0],r8
								payload_rx(AMBE_payload_ptr);
80003142:	6e 0c       	ld.w	r12,r7[0x0]
80003144:	f0 1f 02 df 	mcall	80003cc0 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003148:	fe f8 0b 44 	ld.w	r8,pc[2884]
8000314c:	70 0c       	ld.w	r12,r8[0x0]
8000314e:	f0 1f 02 ca 	mcall	80003c74 <phy_rx_func+0xe98>
80003152:	8f 0c       	st.w	r7[0x0],r12
80003154:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								//logFromISR("\n\r QQ1 \n\r");
								
							}
							else//error voice
							{
								m_RxBurstType = VOICE_WATING;
80003158:	30 09       	mov	r9,0
8000315a:	fe f8 0b 42 	ld.w	r8,pc[2882]
8000315e:	91 09       	st.w	r8[0x0],r9
80003160:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;//WAITINGABAB.
					
		
					case Vocoder_Bit_Stream_Parameter://0x12
							
							if ((RxBytesWaiting -= 4) <= 0) break;
80003164:	20 48       	sub	r8,4
80003166:	fe f9 0b 3a 	ld.w	r9,pc[2874]
8000316a:	93 08       	st.w	r9[0x0],r8
8000316c:	58 08       	cp.w	r8,0
8000316e:	e0 80 05 74 	breq	80003c56 <phy_rx_func+0xe7a>
					
							//Vocoder Bits Stream Parameter
							VF_SN = (payload_rx_channel->byte[7] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
80003172:	ef 3c 00 0f 	ld.ub	r12,r7[15]
80003176:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
8000317a:	fe f8 0b 4a 	ld.w	r8,pc[2890]
8000317e:	b0 8c       	st.b	r8[0x0],r12
							
							VBSP_data[0] = payload_rx_channel->word[2];
80003180:	8e 69       	ld.sh	r9,r7[0xc]
80003182:	fe f8 0b 46 	ld.w	r8,pc[2886]
80003186:	b0 09       	st.h	r8[0x0],r9
							VBSP_data[1] = payload_rx_channel->word[3];
80003188:	8e 79       	ld.sh	r9,r7[0xe]
8000318a:	b0 19       	st.h	r8[0x2],r9
							
							m_RxBurstType = CalculateBurst(VF_SN);
8000318c:	f0 1f 02 d0 	mcall	80003ccc <phy_rx_func+0xef0>
80003190:	fe f8 0b 0c 	ld.w	r8,pc[2828]
80003194:	91 0c       	st.w	r8[0x0],r12
							
							RxMediaState = READING_AMBE_MEDIA;//Jump
80003196:	30 49       	mov	r9,4
80003198:	fe f8 0b 00 	ld.w	r8,pc[2816]
8000319c:	91 09       	st.w	r8[0x0],r9
8000319e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							
					//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
					// or discard it to reduce payload size.	
					//This shouldn't happen, but must check.	
					case Soft_Decision_Value://0x13
						m_RxBurstType = VOICE_WATING;
800031a2:	30 09       	mov	r9,0
800031a4:	fe f8 0a f8 	ld.w	r8,pc[2808]
800031a8:	91 09       	st.w	r8[0x0],r9
800031aa:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
					case Radio_Internal_Parameter://0x7F
							
							//logFromISR("\n\r Item_Length:%d\n\r", Item_Length);
							
							if ((RxBytesWaiting -= 4) <= 0) break;
800031ae:	20 48       	sub	r8,4
800031b0:	fe f9 0a f0 	ld.w	r9,pc[2800]
800031b4:	93 08       	st.w	r9[0x0],r8
800031b6:	58 08       	cp.w	r8,0
800031b8:	e0 80 05 4f 	breq	80003c56 <phy_rx_func+0xe7a>
							//Radio Internal Parameter
							Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[3];
800031bc:	fe f8 0b 14 	ld.w	r8,pc[2836]
800031c0:	70 09       	ld.w	r9,r8[0x0]
800031c2:	8e 7b       	ld.sh	r11,r7[0xe]
800031c4:	fe fa 0b 10 	ld.w	r10,pc[2832]
800031c8:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
							RxData_IsFillingNext16 += 1; 
800031cc:	2f f9       	sub	r9,-1
800031ce:	91 09       	st.w	r8[0x0],r9
							Item_Length -= 2 ;
800031d0:	fe f8 0a e4 	ld.w	r8,pc[2788]
800031d4:	70 09       	ld.w	r9,r8[0x0]
800031d6:	20 29       	sub	r9,2
800031d8:	91 09       	st.w	r8[0x0],r9
							//....................................................
							m_RxBurstType = RADIOINTERNAL;
800031da:	30 29       	mov	r9,2
800031dc:	fe f8 0a c0 	ld.w	r8,pc[2752]
800031e0:	91 09       	st.w	r8[0x0],r9

							RxMediaState = READING_AMBE_AUX;//Jump
800031e2:	30 39       	mov	r9,3
800031e4:	fe f8 0a b4 	ld.w	r8,pc[2740]
800031e8:	91 09       	st.w	r8[0x0],r9
800031ea:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									
					default://0x03,0x04
						
						//((Item_ID == 0x04) || (Item_ID == 0x03) )//Unknown type data directly back hair
							//break;
							m_RxBurstType = UNSUREDATA;
800031ee:	30 3a       	mov	r10,3
800031f0:	fe f9 0a ac 	ld.w	r9,pc[2732]
800031f4:	93 0a       	st.w	r9[0x0],r10
							AMBE_HT[0] = payload_rx_channel->dword[0];
800031f6:	6e 2a       	ld.w	r10,r7[0x8]
800031f8:	fe f9 0a e0 	ld.w	r9,pc[2784]
800031fc:	93 0a       	st.w	r9[0x0],r10
							AMBE_HT[1] = payload_rx_channel->dword[1];
800031fe:	6e 3a       	ld.w	r10,r7[0xc]
80003200:	93 1a       	st.w	r9[0x4],r10
							
							if (RxBytesWaiting == 0x00000014)
80003202:	59 48       	cp.w	r8,20
80003204:	c0 61       	brne	80003210 <phy_rx_func+0x434>
							{
								RxBytesWaiting = 0x18;//24 Reassigned
80003206:	31 89       	mov	r9,24
80003208:	fe f8 0a 98 	ld.w	r8,pc[2712]
8000320c:	91 09       	st.w	r8[0x0],r9
8000320e:	c0 a8       	rjmp	80003222 <phy_rx_func+0x446>
								//_flag =0;
								
							}
							if (RxBytesWaiting == 0x00000010)
80003210:	fe f8 0a 90 	ld.w	r8,pc[2704]
80003214:	70 08       	ld.w	r8,r8[0x0]
80003216:	59 08       	cp.w	r8,16
80003218:	c0 51       	brne	80003222 <phy_rx_func+0x446>
							{
								RxBytesWaiting = 0x10;//16 Reassigned
8000321a:	31 09       	mov	r9,16
8000321c:	fe f8 0a 84 	ld.w	r8,pc[2692]
80003220:	91 09       	st.w	r8[0x0],r9
								//_flag =1;
							}
					
							RxMediaState = READING_AMBE_MEDIA;//Jump
80003222:	30 49       	mov	r9,4
80003224:	fe f8 0a 74 	ld.w	r8,pc[2676]
80003228:	91 09       	st.w	r8[0x0],r9
8000322a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
//#if 0
			else//PCM-media-data
			{	
				//logFromISR("\n\r RX:%x \n\r", payload_rx_channel->dword[0]);
				//SPEAKER_DATA or  //MIC_DATA
				if (((payload_rx_channel->dword[0] & 0x0000F000 ) != SPEAKER_DATA ) 
8000322e:	e0 49 10 00 	cp.w	r9,4096
80003232:	5f 1a       	srne	r10
80003234:	e0 49 20 00 	cp.w	r9,8192
80003238:	5f 19       	srne	r9
8000323a:	f5 e9 00 09 	and	r9,r10,r9
8000323e:	e0 81 05 0c 	brne	80003c56 <phy_rx_func+0xe7a>
					&& ((payload_rx_channel->dword[0] & 0x0000F000 ) != MIC_DATA ))break;
				
				AMBE_tx_flag = 0;
80003242:	fe fa 0a 9a 	ld.w	r10,pc[2714]
80003246:	b4 89       	st.b	r10[0x0],r9
				AMBE_rx_flag = 0;
80003248:	fe fa 0a 98 	ld.w	r10,pc[2712]
8000324c:	b4 89       	st.b	r10[0x0],r9
				
				Item_ID = 0;//To make sure your save PCM data.
8000324e:	fe fa 0a 62 	ld.w	r10,pc[2658]
80003252:	b4 89       	st.b	r10[0x0],r9
			
				if (NULL== payload_ptr){
80003254:	fe f9 0a 3c 	ld.w	r9,pc[2620]
80003258:	72 09       	ld.w	r9,r9[0x0]
8000325a:	58 09       	cp.w	r9,0
8000325c:	c0 71       	brne	8000326a <phy_rx_func+0x48e>
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//测试是否有这种情况出现
8000325e:	fe fc 0a 4a 	ld.w	r12,pc[2634]
80003262:	f0 1f 02 93 	mcall	80003cac <phy_rx_func+0xed0>
80003266:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
8000326a:	6e 2a       	ld.w	r10,r7[0x8]
8000326c:	e2 1a 0f 00 	andl	r10,0xf00,COH
80003270:	58 1a       	cp.w	r10,1
80003272:	e0 8b 00 4d 	brhi	8000330c <phy_rx_func+0x530>
				
				if ((payload_rx_channel->dword[0]  & 0x00000F00) <= 1){  //Flag type must process Array Descriptor.
				//The first word of the media access payload must be the Array descriptor length. And the
				//unit of the length is in word (16-bit). The length field itself does not count into the length.
				//When there is no array descriptor, the length must be set to zero.[9.1.4.1]
					if ((RxBytesWaiting -= 4) <= 0) break;          //Nothing beyond this Phy buffer. Keep looking for Header
80003276:	20 48       	sub	r8,4
80003278:	fe f9 0a 28 	ld.w	r9,pc[2600]
8000327c:	93 08       	st.w	r9[0x0],r8
8000327e:	58 08       	cp.w	r8,0
80003280:	e0 80 04 eb 	breq	80003c56 <phy_rx_func+0xe7a>
					ArrayDiscLength = payload_rx_channel->word[2];
80003284:	8e 68       	ld.sh	r8,r7[0xc]
80003286:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
8000328a:	fe f9 0a 5a 	ld.w	r9,pc[2650]
8000328e:	93 0a       	st.w	r9[0x0],r10
					switch (ArrayDiscLength){
80003290:	30 09       	mov	r9,0
80003292:	f2 08 19 00 	cp.h	r8,r9
80003296:	c0 70       	breq	800032a4 <phy_rx_func+0x4c8>
80003298:	30 19       	mov	r9,1
8000329a:	f2 08 19 00 	cp.h	r8,r9
8000329e:	e0 81 04 dc 	brne	80003c56 <phy_rx_func+0xe7a>
800032a2:	c2 68       	rjmp	800032ee <phy_rx_func+0x512>
						case 0:          //The usual case. Remaining word in Phy buffer is Audio.
								
							payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
800032a4:	fe f8 0a 44 	ld.w	r8,pc[2628]
800032a8:	70 0a       	ld.w	r10,r8[0x0]
800032aa:	fe f9 09 e6 	ld.w	r9,pc[2534]
800032ae:	72 09       	ld.w	r9,r9[0x0]
800032b0:	8e 7b       	ld.sh	r11,r7[0xe]
800032b2:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
							RxMedia_IsFillingNext16 += 1;
800032b6:	70 09       	ld.w	r9,r8[0x0]
800032b8:	2f f9       	sub	r9,-1
800032ba:	91 09       	st.w	r8[0x0],r9
							if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800032bc:	e0 49 00 ff 	cp.w	r9,255
800032c0:	e0 88 00 11 	brls	800032e2 <phy_rx_func+0x506>
							{
								RxMedia_IsFillingNext16 = 0;	
800032c4:	30 09       	mov	r9,0
800032c6:	91 09       	st.w	r8[0x0],r9
								payload_rx(payload_ptr);	
800032c8:	fe f7 09 c8 	ld.w	r7,pc[2504]
800032cc:	6e 0c       	ld.w	r12,r7[0x0]
800032ce:	f0 1f 02 7d 	mcall	80003cc0 <phy_rx_func+0xee4>
								payload_ptr = get_payload_idle_isr();
800032d2:	fe f8 09 ba 	ld.w	r8,pc[2490]
800032d6:	70 0c       	ld.w	r12,r8[0x0]
800032d8:	f0 1f 02 67 	mcall	80003c74 <phy_rx_func+0xe98>
800032dc:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == payload_ptr){
800032de:	e0 80 04 bc 	breq	80003c56 <phy_rx_func+0xe7a>
									break;
								}				
							}
							RxMediaState = READINGMEDIA;
800032e2:	30 29       	mov	r9,2
800032e4:	fe f8 09 b4 	ld.w	r8,pc[2484]
800032e8:	91 09       	st.w	r8[0x0],r9
800032ea:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
800032ee:	8e 79       	ld.sh	r9,r7[0xe]
800032f0:	30 38       	mov	r8,3
800032f2:	f0 09 19 00 	cp.h	r9,r8
800032f6:	c0 51       	brne	80003300 <phy_rx_func+0x524>
				
						case 1: //The next usual case.
								//In general case, add code to process single word Array descriptor.
								if (payload_rx_channel->word[3] == 0x0003)//Stream Terminator
								{
									Terminator_Flag = 1;
800032f8:	30 19       	mov	r9,1
800032fa:	fe f8 09 f2 	ld.w	r8,pc[2546]
800032fe:	b0 89       	st.b	r8[0x0],r9
								else
								{
									//Terminator_Flag = 0;
								}
								
								RxMediaState = READINGMEDIA;
80003300:	30 29       	mov	r9,2
80003302:	fe f8 09 96 	ld.w	r8,pc[2454]
80003306:	91 09       	st.w	r8[0x0],r9
80003308:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
				break;
			}
		
				//Code gets here on Middle or last Fragment. No Array descriptor.
				if (RxBytesWaiting < 2) break;//This shouldn't happen, but must check.
8000330c:	58 18       	cp.w	r8,1
8000330e:	e0 88 04 a4 	brls	80003c56 <phy_rx_func+0xe7a>
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->dword[1] & 0x0000FFFF;
80003312:	fe f8 09 d6 	ld.w	r8,pc[2518]
80003316:	70 0a       	ld.w	r10,r8[0x0]
80003318:	6e 3b       	ld.w	r11,r7[0xc]
8000331a:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
8000331e:	70 09       	ld.w	r9,r8[0x0]
80003320:	2f f9       	sub	r9,-1
80003322:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003324:	e0 49 00 ff 	cp.w	r9,255
80003328:	e0 88 00 11 	brls	8000334a <phy_rx_func+0x56e>
				{
					RxMedia_IsFillingNext16 = 0;
8000332c:	30 09       	mov	r9,0
8000332e:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003330:	fe f7 09 60 	ld.w	r7,pc[2400]
80003334:	6e 0c       	ld.w	r12,r7[0x0]
80003336:	f0 1f 02 63 	mcall	80003cc0 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
8000333a:	fe f8 09 52 	ld.w	r8,pc[2386]
8000333e:	70 0c       	ld.w	r12,r8[0x0]
80003340:	f0 1f 02 4d 	mcall	80003c74 <phy_rx_func+0xe98>
80003344:	8f 0c       	st.w	r7[0x0],r12
					if(NULL == payload_ptr)
80003346:	e0 80 04 88 	breq	80003c56 <phy_rx_func+0xe7a>
					{
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0) break;  //This shouldn't happen, but must check;
8000334a:	fe f9 09 56 	ld.w	r9,pc[2390]
8000334e:	72 08       	ld.w	r8,r9[0x0]
80003350:	20 28       	sub	r8,2
80003352:	93 08       	st.w	r9[0x0],r8
80003354:	e0 80 04 81 	breq	80003c56 <phy_rx_func+0xe7a>
				RxMediaState = READINGMEDIA;
80003358:	30 29       	mov	r9,2
8000335a:	fe f8 09 3e 	ld.w	r8,pc[2366]
8000335e:	91 09       	st.w	r8[0x0],r9
80003360:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
		case READINGMEDIA:
				
			/***PCM-media-data ****/
			{
				
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[0];
80003364:	fe f8 09 84 	ld.w	r8,pc[2436]
80003368:	70 0a       	ld.w	r10,r8[0x0]
8000336a:	fe f9 09 26 	ld.w	r9,pc[2342]
8000336e:	72 09       	ld.w	r9,r9[0x0]
80003370:	8e 4b       	ld.sh	r11,r7[0x8]
80003372:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;	
80003376:	70 09       	ld.w	r9,r8[0x0]
80003378:	2f f9       	sub	r9,-1
8000337a:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
8000337c:	e0 49 00 ff 	cp.w	r9,255
80003380:	e0 88 00 16 	brls	800033ac <phy_rx_func+0x5d0>
				{
					RxMedia_IsFillingNext16 = 0;
80003384:	30 09       	mov	r9,0
80003386:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003388:	fe f6 09 08 	ld.w	r6,pc[2312]
8000338c:	6c 0c       	ld.w	r12,r6[0x0]
8000338e:	f0 1f 02 4d 	mcall	80003cc0 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
80003392:	fe f8 08 fa 	ld.w	r8,pc[2298]
80003396:	70 0c       	ld.w	r12,r8[0x0]
80003398:	f0 1f 02 37 	mcall	80003c74 <phy_rx_func+0xe98>
8000339c:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
8000339e:	c0 71       	brne	800033ac <phy_rx_func+0x5d0>
					{
						RxMediaState = WAITINGABAB;
800033a0:	30 09       	mov	r9,0
800033a2:	fe f8 08 f6 	ld.w	r8,pc[2294]
800033a6:	91 09       	st.w	r8[0x0],r9
800033a8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0)
800033ac:	fe f9 08 f4 	ld.w	r9,pc[2292]
800033b0:	72 08       	ld.w	r8,r9[0x0]
800033b2:	20 28       	sub	r8,2
800033b4:	93 08       	st.w	r9[0x0],r8
800033b6:	c0 71       	brne	800033c4 <phy_rx_func+0x5e8>
				{
					RxMediaState = WAITINGABAB;
800033b8:	30 09       	mov	r9,0
800033ba:	fe f8 08 de 	ld.w	r8,pc[2270]
800033be:	91 09       	st.w	r8[0x0],r9
800033c0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[1];
800033c4:	fe f8 09 24 	ld.w	r8,pc[2340]
800033c8:	70 0a       	ld.w	r10,r8[0x0]
800033ca:	fe f9 08 c6 	ld.w	r9,pc[2246]
800033ce:	72 09       	ld.w	r9,r9[0x0]
800033d0:	8e 5b       	ld.sh	r11,r7[0xa]
800033d2:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
800033d6:	70 09       	ld.w	r9,r8[0x0]
800033d8:	2f f9       	sub	r9,-1
800033da:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800033dc:	e0 49 00 ff 	cp.w	r9,255
800033e0:	e0 88 00 16 	brls	8000340c <phy_rx_func+0x630>
				{
					RxMedia_IsFillingNext16 = 0;
800033e4:	30 09       	mov	r9,0
800033e6:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
800033e8:	fe f6 08 a8 	ld.w	r6,pc[2216]
800033ec:	6c 0c       	ld.w	r12,r6[0x0]
800033ee:	f0 1f 02 35 	mcall	80003cc0 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
800033f2:	fe f8 08 9a 	ld.w	r8,pc[2202]
800033f6:	70 0c       	ld.w	r12,r8[0x0]
800033f8:	f0 1f 02 1f 	mcall	80003c74 <phy_rx_func+0xe98>
800033fc:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
800033fe:	c0 71       	brne	8000340c <phy_rx_func+0x630>
					{
						RxMediaState = WAITINGABAB;
80003400:	30 09       	mov	r9,0
80003402:	fe f8 08 96 	ld.w	r8,pc[2198]
80003406:	91 09       	st.w	r8[0x0],r9
80003408:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
8000340c:	fe f9 08 94 	ld.w	r9,pc[2196]
80003410:	72 08       	ld.w	r8,r9[0x0]
80003412:	20 28       	sub	r8,2
80003414:	93 08       	st.w	r9[0x0],r8
80003416:	c0 71       	brne	80003424 <phy_rx_func+0x648>
					RxMediaState = WAITINGABAB;
80003418:	30 09       	mov	r9,0
8000341a:	fe f8 08 7e 	ld.w	r8,pc[2174]
8000341e:	91 09       	st.w	r8[0x0],r9
80003420:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}

				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[2];
80003424:	fe f8 08 c4 	ld.w	r8,pc[2244]
80003428:	70 0a       	ld.w	r10,r8[0x0]
8000342a:	fe f9 08 66 	ld.w	r9,pc[2150]
8000342e:	72 09       	ld.w	r9,r9[0x0]
80003430:	8e 6b       	ld.sh	r11,r7[0xc]
80003432:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80003436:	70 09       	ld.w	r9,r8[0x0]
80003438:	2f f9       	sub	r9,-1
8000343a:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
8000343c:	e0 49 00 ff 	cp.w	r9,255
80003440:	e0 88 00 16 	brls	8000346c <phy_rx_func+0x690>
				{
					RxMedia_IsFillingNext16 = 0;
80003444:	30 09       	mov	r9,0
80003446:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003448:	fe f6 08 48 	ld.w	r6,pc[2120]
8000344c:	6c 0c       	ld.w	r12,r6[0x0]
8000344e:	f0 1f 02 1d 	mcall	80003cc0 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
80003452:	fe f8 08 3a 	ld.w	r8,pc[2106]
80003456:	70 0c       	ld.w	r12,r8[0x0]
80003458:	f0 1f 02 07 	mcall	80003c74 <phy_rx_func+0xe98>
8000345c:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
8000345e:	c0 71       	brne	8000346c <phy_rx_func+0x690>
					{
						RxMediaState = WAITINGABAB;
80003460:	30 09       	mov	r9,0
80003462:	fe f8 08 36 	ld.w	r8,pc[2102]
80003466:	91 09       	st.w	r8[0x0],r9
80003468:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
8000346c:	fe f9 08 34 	ld.w	r9,pc[2100]
80003470:	72 08       	ld.w	r8,r9[0x0]
80003472:	20 28       	sub	r8,2
80003474:	93 08       	st.w	r9[0x0],r8
80003476:	c0 71       	brne	80003484 <phy_rx_func+0x6a8>
					RxMediaState = WAITINGABAB;
80003478:	30 09       	mov	r9,0
8000347a:	fe f8 08 1e 	ld.w	r8,pc[2078]
8000347e:	91 09       	st.w	r8[0x0],r9
80003480:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
80003484:	fe f8 08 64 	ld.w	r8,pc[2148]
80003488:	70 0a       	ld.w	r10,r8[0x0]
8000348a:	fe f9 08 06 	ld.w	r9,pc[2054]
8000348e:	72 09       	ld.w	r9,r9[0x0]
80003490:	8e 7b       	ld.sh	r11,r7[0xe]
80003492:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80003496:	70 09       	ld.w	r9,r8[0x0]
80003498:	2f f9       	sub	r9,-1
8000349a:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
8000349c:	e0 49 00 ff 	cp.w	r9,255
800034a0:	e0 88 00 16 	brls	800034cc <phy_rx_func+0x6f0>
				{
					RxMedia_IsFillingNext16 = 0;
800034a4:	30 09       	mov	r9,0
800034a6:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
800034a8:	fe f7 07 e8 	ld.w	r7,pc[2024]
800034ac:	6e 0c       	ld.w	r12,r7[0x0]
800034ae:	f0 1f 02 05 	mcall	80003cc0 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
800034b2:	fe f8 07 da 	ld.w	r8,pc[2010]
800034b6:	70 0c       	ld.w	r12,r8[0x0]
800034b8:	f0 1f 01 ef 	mcall	80003c74 <phy_rx_func+0xe98>
800034bc:	8f 0c       	st.w	r7[0x0],r12
					if(NULL == payload_ptr)
800034be:	c0 71       	brne	800034cc <phy_rx_func+0x6f0>
					{
						RxMediaState = WAITINGABAB;
800034c0:	30 09       	mov	r9,0
800034c2:	fe f8 07 d6 	ld.w	r8,pc[2006]
800034c6:	91 09       	st.w	r8[0x0],r9
800034c8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
800034cc:	fe f9 07 d4 	ld.w	r9,pc[2004]
800034d0:	72 08       	ld.w	r8,r9[0x0]
800034d2:	20 28       	sub	r8,2
800034d4:	93 08       	st.w	r9[0x0],r8
800034d6:	e0 81 03 c0 	brne	80003c56 <phy_rx_func+0xe7a>
					RxMediaState = WAITINGABAB;
800034da:	30 09       	mov	r9,0
800034dc:	fe f8 07 bc 	ld.w	r8,pc[1980]
800034e0:	91 09       	st.w	r8[0x0],r9
800034e2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

		case READING_AMBE_MEDIA:
		
			/****AMBE-media-data ****/
		
					if ((Item_ID == Vocoder_Bit_Stream_Parameter))//PAYLOAD_DATA_ENH (0x0c))
800034e6:	fe f8 07 ca 	ld.w	r8,pc[1994]
800034ea:	11 89       	ld.ub	r9,r8[0x0]
800034ec:	31 28       	mov	r8,18
800034ee:	f0 09 18 00 	cp.b	r9,r8
800034f2:	e0 81 01 4c 	brne	8000378a <phy_rx_func+0x9ae>
					{
						Item_ID = payload_rx_channel->byte[1];
800034f6:	ef 39 00 09 	ld.ub	r9,r7[9]
800034fa:	fe f8 07 b6 	ld.w	r8,pc[1974]
800034fe:	b0 89       	st.b	r8[0x0],r9
						if (Item_ID == Post_Voice_Encoder_Data)//发送方的压缩类型数据
80003500:	11 89       	ld.ub	r9,r8[0x0]
80003502:	3f 28       	mov	r8,-14
80003504:	f0 09 18 00 	cp.b	r9,r8
80003508:	e0 81 01 3b 	brne	8000377e <phy_rx_func+0x9a2>
						{
							AMBE_tx_flag = 1;
8000350c:	30 19       	mov	r9,1
8000350e:	fe f8 07 ce 	ld.w	r8,pc[1998]
80003512:	b0 89       	st.b	r8[0x0],r9
							
							RxBytesWaiting = ((payload_rx_channel->dword[0] & 0x7F000000) >>24);//Test calculations are correct; 8
80003514:	6e 29       	ld.w	r9,r7[0x8]
80003516:	f3 d9 c3 07 	bfextu	r9,r9,0x18,0x7
8000351a:	fe f8 07 86 	ld.w	r8,pc[1926]
8000351e:	91 09       	st.w	r8[0x0],r9
							
							//For looping back to Radio
							AMBEBurst_rawdata[0] = payload_rx_channel->word[1];
80003520:	8e 59       	ld.sh	r9,r7[0xa]
80003522:	fe f8 07 ce 	ld.w	r8,pc[1998]
80003526:	b0 09       	st.h	r8[0x0],r9
							AMBEBurst_rawdata[1] = payload_rx_channel->word[2];
80003528:	8e 69       	ld.sh	r9,r7[0xc]
8000352a:	b0 19       	st.h	r8[0x2],r9
							AMBEBurst_rawdata[2] = payload_rx_channel->word[3];
8000352c:	8e 79       	ld.sh	r9,r7[0xe]
8000352e:	b0 29       	st.h	r8[0x4],r9
							
							//To be tested. Also locally stored RAW-AMBER-DATA
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//1
80003530:	fe f8 07 88 	ld.w	r8,pc[1928]
80003534:	fe f9 07 60 	ld.w	r9,pc[1888]
80003538:	72 0a       	ld.w	r10,r9[0x0]
8000353a:	70 09       	ld.w	r9,r8[0x0]
8000353c:	ef 3b 00 0a 	ld.ub	r11,r7[10]
80003540:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003544:	70 09       	ld.w	r9,r8[0x0]
80003546:	2f f9       	sub	r9,-1
80003548:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000354a:	e0 49 01 ff 	cp.w	r9,511
8000354e:	e0 88 00 16 	brls	8000357a <phy_rx_func+0x79e>
							{
								RxAMBE_IsFillingNext8 = 0;
80003552:	30 09       	mov	r9,0
80003554:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003556:	fe f6 07 3e 	ld.w	r6,pc[1854]
8000355a:	6c 0c       	ld.w	r12,r6[0x0]
8000355c:	f0 1f 01 d9 	mcall	80003cc0 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003560:	fe f8 07 2c 	ld.w	r8,pc[1836]
80003564:	70 0c       	ld.w	r12,r8[0x0]
80003566:	f0 1f 01 c4 	mcall	80003c74 <phy_rx_func+0xe98>
8000356a:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
8000356c:	c0 71       	brne	8000357a <phy_rx_func+0x79e>
								{
									RxMediaState = WAITINGABAB;
8000356e:	30 09       	mov	r9,0
80003570:	fe f8 07 28 	ld.w	r8,pc[1832]
80003574:	91 09       	st.w	r8[0x0],r9
80003576:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
8000357a:	fe f9 07 26 	ld.w	r9,pc[1830]
8000357e:	72 08       	ld.w	r8,r9[0x0]
80003580:	20 18       	sub	r8,1
80003582:	93 08       	st.w	r9[0x0],r8
80003584:	c0 71       	brne	80003592 <phy_rx_func+0x7b6>
								RxMediaState = WAITINGABAB;
80003586:	30 09       	mov	r9,0
80003588:	fe f8 07 10 	ld.w	r8,pc[1808]
8000358c:	91 09       	st.w	r8[0x0],r9
8000358e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}			
							
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//2
80003592:	fe f8 07 26 	ld.w	r8,pc[1830]
80003596:	fe f9 06 fe 	ld.w	r9,pc[1790]
8000359a:	72 0a       	ld.w	r10,r9[0x0]
8000359c:	70 09       	ld.w	r9,r8[0x0]
8000359e:	ef 3b 00 0b 	ld.ub	r11,r7[11]
800035a2:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
800035a6:	70 09       	ld.w	r9,r8[0x0]
800035a8:	2f f9       	sub	r9,-1
800035aa:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800035ac:	e0 49 01 ff 	cp.w	r9,511
800035b0:	e0 88 00 16 	brls	800035dc <phy_rx_func+0x800>
							{
								RxAMBE_IsFillingNext8 = 0;
800035b4:	30 09       	mov	r9,0
800035b6:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
800035b8:	fe f6 06 dc 	ld.w	r6,pc[1756]
800035bc:	6c 0c       	ld.w	r12,r6[0x0]
800035be:	f0 1f 01 c1 	mcall	80003cc0 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
800035c2:	fe f8 06 ca 	ld.w	r8,pc[1738]
800035c6:	70 0c       	ld.w	r12,r8[0x0]
800035c8:	f0 1f 01 ab 	mcall	80003c74 <phy_rx_func+0xe98>
800035cc:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
800035ce:	c0 71       	brne	800035dc <phy_rx_func+0x800>
								{
									RxMediaState = WAITINGABAB;
800035d0:	30 09       	mov	r9,0
800035d2:	fe f8 06 c6 	ld.w	r8,pc[1734]
800035d6:	91 09       	st.w	r8[0x0],r9
800035d8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800035dc:	fe f9 06 c4 	ld.w	r9,pc[1732]
800035e0:	72 08       	ld.w	r8,r9[0x0]
800035e2:	20 18       	sub	r8,1
800035e4:	93 08       	st.w	r9[0x0],r8
800035e6:	c0 71       	brne	800035f4 <phy_rx_func+0x818>
								RxMediaState = WAITINGABAB;
800035e8:	30 09       	mov	r9,0
800035ea:	fe f8 06 ae 	ld.w	r8,pc[1710]
800035ee:	91 09       	st.w	r8[0x0],r9
800035f0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}		
						
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//3
800035f4:	fe f8 06 c4 	ld.w	r8,pc[1732]
800035f8:	fe f9 06 9c 	ld.w	r9,pc[1692]
800035fc:	72 0a       	ld.w	r10,r9[0x0]
800035fe:	70 09       	ld.w	r9,r8[0x0]
80003600:	ef 3b 00 0c 	ld.ub	r11,r7[12]
80003604:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003608:	70 09       	ld.w	r9,r8[0x0]
8000360a:	2f f9       	sub	r9,-1
8000360c:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000360e:	e0 49 01 ff 	cp.w	r9,511
80003612:	e0 88 00 16 	brls	8000363e <phy_rx_func+0x862>
							{
								RxAMBE_IsFillingNext8 = 0;
80003616:	30 09       	mov	r9,0
80003618:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
8000361a:	fe f6 06 7a 	ld.w	r6,pc[1658]
8000361e:	6c 0c       	ld.w	r12,r6[0x0]
80003620:	f0 1f 01 a8 	mcall	80003cc0 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003624:	fe f8 06 68 	ld.w	r8,pc[1640]
80003628:	70 0c       	ld.w	r12,r8[0x0]
8000362a:	f0 1f 01 93 	mcall	80003c74 <phy_rx_func+0xe98>
8000362e:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003630:	c0 71       	brne	8000363e <phy_rx_func+0x862>
								{
									RxMediaState = WAITINGABAB;
80003632:	30 09       	mov	r9,0
80003634:	fe f8 06 64 	ld.w	r8,pc[1636]
80003638:	91 09       	st.w	r8[0x0],r9
8000363a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
8000363e:	fe f9 06 62 	ld.w	r9,pc[1634]
80003642:	72 08       	ld.w	r8,r9[0x0]
80003644:	20 18       	sub	r8,1
80003646:	93 08       	st.w	r9[0x0],r8
80003648:	c0 71       	brne	80003656 <phy_rx_func+0x87a>
								RxMediaState = WAITINGABAB;
8000364a:	30 09       	mov	r9,0
8000364c:	fe f8 06 4c 	ld.w	r8,pc[1612]
80003650:	91 09       	st.w	r8[0x0],r9
80003652:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[5];//4
80003656:	fe f8 06 62 	ld.w	r8,pc[1634]
8000365a:	fe f9 06 3a 	ld.w	r9,pc[1594]
8000365e:	72 0a       	ld.w	r10,r9[0x0]
80003660:	70 09       	ld.w	r9,r8[0x0]
80003662:	ef 3b 00 0d 	ld.ub	r11,r7[13]
80003666:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
8000366a:	70 09       	ld.w	r9,r8[0x0]
8000366c:	2f f9       	sub	r9,-1
8000366e:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003670:	e0 49 01 ff 	cp.w	r9,511
80003674:	e0 88 00 16 	brls	800036a0 <phy_rx_func+0x8c4>
							{
								RxAMBE_IsFillingNext8 = 0;
80003678:	30 09       	mov	r9,0
8000367a:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
8000367c:	fe f6 06 18 	ld.w	r6,pc[1560]
80003680:	6c 0c       	ld.w	r12,r6[0x0]
80003682:	f0 1f 01 90 	mcall	80003cc0 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003686:	fe f8 06 06 	ld.w	r8,pc[1542]
8000368a:	70 0c       	ld.w	r12,r8[0x0]
8000368c:	f0 1f 01 7a 	mcall	80003c74 <phy_rx_func+0xe98>
80003690:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003692:	c0 71       	brne	800036a0 <phy_rx_func+0x8c4>
								{
									RxMediaState = WAITINGABAB;
80003694:	30 09       	mov	r9,0
80003696:	fe f8 06 02 	ld.w	r8,pc[1538]
8000369a:	91 09       	st.w	r8[0x0],r9
8000369c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800036a0:	fe f9 06 00 	ld.w	r9,pc[1536]
800036a4:	72 08       	ld.w	r8,r9[0x0]
800036a6:	20 18       	sub	r8,1
800036a8:	93 08       	st.w	r9[0x0],r8
800036aa:	c0 71       	brne	800036b8 <phy_rx_func+0x8dc>
								RxMediaState = WAITINGABAB;
800036ac:	30 09       	mov	r9,0
800036ae:	fe f8 05 ea 	ld.w	r8,pc[1514]
800036b2:	91 09       	st.w	r8[0x0],r9
800036b4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//5
800036b8:	fe f8 06 00 	ld.w	r8,pc[1536]
800036bc:	fe f9 05 d8 	ld.w	r9,pc[1496]
800036c0:	72 0a       	ld.w	r10,r9[0x0]
800036c2:	70 09       	ld.w	r9,r8[0x0]
800036c4:	ef 3b 00 0e 	ld.ub	r11,r7[14]
800036c8:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
800036cc:	70 09       	ld.w	r9,r8[0x0]
800036ce:	2f f9       	sub	r9,-1
800036d0:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800036d2:	e0 49 01 ff 	cp.w	r9,511
800036d6:	e0 88 00 16 	brls	80003702 <phy_rx_func+0x926>
							{
								RxAMBE_IsFillingNext8 = 0;
800036da:	30 09       	mov	r9,0
800036dc:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
800036de:	fe f6 05 b6 	ld.w	r6,pc[1462]
800036e2:	6c 0c       	ld.w	r12,r6[0x0]
800036e4:	f0 1f 01 77 	mcall	80003cc0 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
800036e8:	fe f8 05 a4 	ld.w	r8,pc[1444]
800036ec:	70 0c       	ld.w	r12,r8[0x0]
800036ee:	f0 1f 01 62 	mcall	80003c74 <phy_rx_func+0xe98>
800036f2:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
800036f4:	c0 71       	brne	80003702 <phy_rx_func+0x926>
								{
									RxMediaState = WAITINGABAB;
800036f6:	30 09       	mov	r9,0
800036f8:	fe f8 05 a0 	ld.w	r8,pc[1440]
800036fc:	91 09       	st.w	r8[0x0],r9
800036fe:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003702:	fe f9 05 9e 	ld.w	r9,pc[1438]
80003706:	72 08       	ld.w	r8,r9[0x0]
80003708:	20 18       	sub	r8,1
8000370a:	93 08       	st.w	r9[0x0],r8
8000370c:	c0 71       	brne	8000371a <phy_rx_func+0x93e>
								RxMediaState = WAITINGABAB;
8000370e:	30 09       	mov	r9,0
80003710:	fe f8 05 88 	ld.w	r8,pc[1416]
80003714:	91 09       	st.w	r8[0x0],r9
80003716:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//6
8000371a:	fe f8 05 9e 	ld.w	r8,pc[1438]
8000371e:	fe f9 05 76 	ld.w	r9,pc[1398]
80003722:	72 0a       	ld.w	r10,r9[0x0]
80003724:	70 09       	ld.w	r9,r8[0x0]
80003726:	ef 3b 00 0f 	ld.ub	r11,r7[15]
8000372a:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
8000372e:	70 09       	ld.w	r9,r8[0x0]
80003730:	2f f9       	sub	r9,-1
80003732:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003734:	e0 49 01 ff 	cp.w	r9,511
80003738:	e0 88 00 16 	brls	80003764 <phy_rx_func+0x988>
							{
								RxAMBE_IsFillingNext8 = 0;
8000373c:	30 09       	mov	r9,0
8000373e:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003740:	fe f7 05 54 	ld.w	r7,pc[1364]
80003744:	6e 0c       	ld.w	r12,r7[0x0]
80003746:	f0 1f 01 5f 	mcall	80003cc0 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
8000374a:	fe f8 05 42 	ld.w	r8,pc[1346]
8000374e:	70 0c       	ld.w	r12,r8[0x0]
80003750:	f0 1f 01 49 	mcall	80003c74 <phy_rx_func+0xe98>
80003754:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003756:	c0 71       	brne	80003764 <phy_rx_func+0x988>
								{
									RxMediaState = WAITINGABAB;
80003758:	30 09       	mov	r9,0
8000375a:	fe f8 05 3e 	ld.w	r8,pc[1342]
8000375e:	91 09       	st.w	r8[0x0],r9
80003760:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003764:	fe f9 05 3c 	ld.w	r9,pc[1340]
80003768:	72 08       	ld.w	r8,r9[0x0]
8000376a:	20 18       	sub	r8,1
8000376c:	93 08       	st.w	r9[0x0],r8
8000376e:	e0 81 02 74 	brne	80003c56 <phy_rx_func+0xe7a>
								RxMediaState = WAITINGABAB;
80003772:	30 09       	mov	r9,0
80003774:	fe f8 05 24 	ld.w	r8,pc[1316]
80003778:	91 09       	st.w	r8[0x0],r9
8000377a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							//}
							
						}
						else//error
						{
							RxMediaState = WAITINGABAB;
8000377e:	30 09       	mov	r9,0
80003780:	fe f8 05 18 	ld.w	r8,pc[1304]
80003784:	91 09       	st.w	r8[0x0],r9
80003786:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
					}
					else if (Item_ID == Post_Voice_Encoder_Data)//(bit48~Pad-bits)
8000378a:	fe f8 05 26 	ld.w	r8,pc[1318]
8000378e:	11 89       	ld.ub	r9,r8[0x0]
80003790:	3f 28       	mov	r8,-14
80003792:	f0 09 18 00 	cp.b	r9,r8
80003796:	c4 31       	brne	8000381c <phy_rx_func+0xa40>
					{
					
						AMBEBurst_rawdata[3] = payload_rx_channel->word[0];//(bit48~Pad-bits)
80003798:	8e 49       	ld.sh	r9,r7[0x8]
8000379a:	fe f8 05 56 	ld.w	r8,pc[1366]
8000379e:	b0 39       	st.h	r8[0x6],r9
						//AMBE_Per_Burst_Flag = 1;
						
						//根据MOTO.bit文件数据分布，建议测试pad-bits的最后一个字节不保存。
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//7
800037a0:	fe f8 05 18 	ld.w	r8,pc[1304]
800037a4:	fe f9 04 f0 	ld.w	r9,pc[1264]
800037a8:	72 0a       	ld.w	r10,r9[0x0]
800037aa:	70 09       	ld.w	r9,r8[0x0]
800037ac:	ef 3b 00 08 	ld.ub	r11,r7[8]
800037b0:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
800037b4:	70 09       	ld.w	r9,r8[0x0]
800037b6:	2f f9       	sub	r9,-1
800037b8:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800037ba:	e0 49 01 ff 	cp.w	r9,511
800037be:	e0 88 00 16 	brls	800037ea <phy_rx_func+0xa0e>
						{
							RxAMBE_IsFillingNext8 = 0;
800037c2:	30 09       	mov	r9,0
800037c4:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
800037c6:	fe f7 04 ce 	ld.w	r7,pc[1230]
800037ca:	6e 0c       	ld.w	r12,r7[0x0]
800037cc:	f0 1f 01 3d 	mcall	80003cc0 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
800037d0:	fe f8 04 bc 	ld.w	r8,pc[1212]
800037d4:	70 0c       	ld.w	r12,r8[0x0]
800037d6:	f0 1f 01 28 	mcall	80003c74 <phy_rx_func+0xe98>
800037da:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
800037dc:	c0 71       	brne	800037ea <phy_rx_func+0xa0e>
							{
								RxMediaState = WAITINGABAB;
800037de:	30 09       	mov	r9,0
800037e0:	fe f8 04 b8 	ld.w	r8,pc[1208]
800037e4:	91 09       	st.w	r8[0x0],r9
800037e6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
800037ea:	fe f9 04 b6 	ld.w	r9,pc[1206]
800037ee:	72 08       	ld.w	r8,r9[0x0]
800037f0:	20 18       	sub	r8,1
800037f2:	93 08       	st.w	r9[0x0],r8
800037f4:	c0 71       	brne	80003802 <phy_rx_func+0xa26>
							RxMediaState = WAITINGABAB;
800037f6:	30 09       	mov	r9,0
800037f8:	fe f8 04 a0 	ld.w	r8,pc[1184]
800037fc:	91 09       	st.w	r8[0x0],r9
800037fe:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
						if ((RxBytesWaiting -= 1) <= 0){//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
80003802:	20 18       	sub	r8,1
80003804:	fe f9 04 9c 	ld.w	r9,pc[1180]
80003808:	93 08       	st.w	r9[0x0],r8
8000380a:	58 08       	cp.w	r8,0
8000380c:	e0 81 02 25 	brne	80003c56 <phy_rx_func+0xe7a>
							RxMediaState = WAITINGABAB;
80003810:	30 09       	mov	r9,0
80003812:	fe f8 04 86 	ld.w	r8,pc[1158]
80003816:	91 09       	st.w	r8[0x0],r9
80003818:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
								
					}
					else if (Item_ID == Pre_Voice_Decoder_Data)//bit16~bit63
8000381c:	fe f8 04 94 	ld.w	r8,pc[1172]
80003820:	11 89       	ld.ub	r9,r8[0x0]
80003822:	3f 38       	mov	r8,-13
80003824:	f0 09 18 00 	cp.b	r9,r8
80003828:	e0 81 01 0c 	brne	80003a40 <phy_rx_func+0xc64>
					{
						//接收方的解压类型数据
						//For looping back to Radio
						AMBEBurst_rawdata[1] = payload_rx_channel->word[0];
8000382c:	8e 49       	ld.sh	r9,r7[0x8]
8000382e:	fe f8 04 c2 	ld.w	r8,pc[1218]
80003832:	b0 19       	st.h	r8[0x2],r9
						AMBEBurst_rawdata[2] = payload_rx_channel->word[1];
80003834:	8e 59       	ld.sh	r9,r7[0xa]
80003836:	b0 29       	st.h	r8[0x4],r9
						AMBEBurst_rawdata[3] = payload_rx_channel->word[2];
80003838:	8e 69       	ld.sh	r9,r7[0xc]
8000383a:	b0 39       	st.h	r8[0x6],r9
						//if((m_RxBurstType == VOICEBURST_A) && (VF_SN == 1))
						//logFromISR("\n\r Pre_rx:%X\n\r", payload_rx_channel->word[2]);
						
						//To be tested. Also locally stored RAW-AMBER-DATA
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//3
8000383c:	fe f8 04 7c 	ld.w	r8,pc[1148]
80003840:	fe f9 04 54 	ld.w	r9,pc[1108]
80003844:	72 0a       	ld.w	r10,r9[0x0]
80003846:	70 09       	ld.w	r9,r8[0x0]
80003848:	ef 3b 00 08 	ld.ub	r11,r7[8]
8000384c:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003850:	70 09       	ld.w	r9,r8[0x0]
80003852:	2f f9       	sub	r9,-1
80003854:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003856:	e0 49 01 ff 	cp.w	r9,511
8000385a:	e0 88 00 16 	brls	80003886 <phy_rx_func+0xaaa>
						{
							RxAMBE_IsFillingNext8 = 0;
8000385e:	30 09       	mov	r9,0
80003860:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003862:	fe f6 04 32 	ld.w	r6,pc[1074]
80003866:	6c 0c       	ld.w	r12,r6[0x0]
80003868:	f0 1f 01 16 	mcall	80003cc0 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
8000386c:	fe f8 04 20 	ld.w	r8,pc[1056]
80003870:	70 0c       	ld.w	r12,r8[0x0]
80003872:	f0 1f 01 01 	mcall	80003c74 <phy_rx_func+0xe98>
80003876:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003878:	c0 71       	brne	80003886 <phy_rx_func+0xaaa>
							{
								RxMediaState = WAITINGABAB;
8000387a:	30 09       	mov	r9,0
8000387c:	fe f8 04 1c 	ld.w	r8,pc[1052]
80003880:	91 09       	st.w	r8[0x0],r9
80003882:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003886:	fe f9 04 1a 	ld.w	r9,pc[1050]
8000388a:	72 08       	ld.w	r8,r9[0x0]
8000388c:	20 18       	sub	r8,1
8000388e:	93 08       	st.w	r9[0x0],r8
80003890:	c0 71       	brne	8000389e <phy_rx_func+0xac2>
							RxMediaState = WAITINGABAB;
80003892:	30 09       	mov	r9,0
80003894:	fe f8 04 04 	ld.w	r8,pc[1028]
80003898:	91 09       	st.w	r8[0x0],r9
8000389a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[1];//4
8000389e:	fe f8 04 1a 	ld.w	r8,pc[1050]
800038a2:	fe f9 03 f2 	ld.w	r9,pc[1010]
800038a6:	72 0a       	ld.w	r10,r9[0x0]
800038a8:	70 09       	ld.w	r9,r8[0x0]
800038aa:	ef 3b 00 09 	ld.ub	r11,r7[9]
800038ae:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
800038b2:	70 09       	ld.w	r9,r8[0x0]
800038b4:	2f f9       	sub	r9,-1
800038b6:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800038b8:	e0 49 01 ff 	cp.w	r9,511
800038bc:	e0 88 00 16 	brls	800038e8 <phy_rx_func+0xb0c>
						{
							RxAMBE_IsFillingNext8 = 0;
800038c0:	30 09       	mov	r9,0
800038c2:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
800038c4:	fe f6 03 d0 	ld.w	r6,pc[976]
800038c8:	6c 0c       	ld.w	r12,r6[0x0]
800038ca:	f0 1f 00 fe 	mcall	80003cc0 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
800038ce:	fe f8 03 be 	ld.w	r8,pc[958]
800038d2:	70 0c       	ld.w	r12,r8[0x0]
800038d4:	f0 1f 00 e8 	mcall	80003c74 <phy_rx_func+0xe98>
800038d8:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
800038da:	c0 71       	brne	800038e8 <phy_rx_func+0xb0c>
							{
								RxMediaState = WAITINGABAB;
800038dc:	30 09       	mov	r9,0
800038de:	fe f8 03 ba 	ld.w	r8,pc[954]
800038e2:	91 09       	st.w	r8[0x0],r9
800038e4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
800038e8:	fe f9 03 b8 	ld.w	r9,pc[952]
800038ec:	72 08       	ld.w	r8,r9[0x0]
800038ee:	20 18       	sub	r8,1
800038f0:	93 08       	st.w	r9[0x0],r8
800038f2:	c0 71       	brne	80003900 <phy_rx_func+0xb24>
							RxMediaState = WAITINGABAB;
800038f4:	30 09       	mov	r9,0
800038f6:	fe f8 03 a2 	ld.w	r8,pc[930]
800038fa:	91 09       	st.w	r8[0x0],r9
800038fc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//5
80003900:	fe f8 03 b8 	ld.w	r8,pc[952]
80003904:	fe f9 03 90 	ld.w	r9,pc[912]
80003908:	72 0a       	ld.w	r10,r9[0x0]
8000390a:	70 09       	ld.w	r9,r8[0x0]
8000390c:	ef 3b 00 0a 	ld.ub	r11,r7[10]
80003910:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003914:	70 09       	ld.w	r9,r8[0x0]
80003916:	2f f9       	sub	r9,-1
80003918:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000391a:	e0 49 01 ff 	cp.w	r9,511
8000391e:	e0 88 00 16 	brls	8000394a <phy_rx_func+0xb6e>
						{
							RxAMBE_IsFillingNext8 = 0;
80003922:	30 09       	mov	r9,0
80003924:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003926:	fe f6 03 6e 	ld.w	r6,pc[878]
8000392a:	6c 0c       	ld.w	r12,r6[0x0]
8000392c:	f0 1f 00 e5 	mcall	80003cc0 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003930:	fe f8 03 5c 	ld.w	r8,pc[860]
80003934:	70 0c       	ld.w	r12,r8[0x0]
80003936:	f0 1f 00 d0 	mcall	80003c74 <phy_rx_func+0xe98>
8000393a:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
8000393c:	c0 71       	brne	8000394a <phy_rx_func+0xb6e>
							{
								RxMediaState = WAITINGABAB;
8000393e:	30 09       	mov	r9,0
80003940:	fe f8 03 58 	ld.w	r8,pc[856]
80003944:	91 09       	st.w	r8[0x0],r9
80003946:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
8000394a:	fe f9 03 56 	ld.w	r9,pc[854]
8000394e:	72 08       	ld.w	r8,r9[0x0]
80003950:	20 18       	sub	r8,1
80003952:	93 08       	st.w	r9[0x0],r8
80003954:	c0 71       	brne	80003962 <phy_rx_func+0xb86>
							RxMediaState = WAITINGABAB;
80003956:	30 09       	mov	r9,0
80003958:	fe f8 03 40 	ld.w	r8,pc[832]
8000395c:	91 09       	st.w	r8[0x0],r9
8000395e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//6
80003962:	fe f8 03 56 	ld.w	r8,pc[854]
80003966:	fe f9 03 2e 	ld.w	r9,pc[814]
8000396a:	72 0a       	ld.w	r10,r9[0x0]
8000396c:	70 09       	ld.w	r9,r8[0x0]
8000396e:	ef 3b 00 0b 	ld.ub	r11,r7[11]
80003972:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003976:	70 09       	ld.w	r9,r8[0x0]
80003978:	2f f9       	sub	r9,-1
8000397a:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000397c:	e0 49 01 ff 	cp.w	r9,511
80003980:	e0 88 00 16 	brls	800039ac <phy_rx_func+0xbd0>
						{
							RxAMBE_IsFillingNext8 = 0;
80003984:	30 09       	mov	r9,0
80003986:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003988:	fe f6 03 0c 	ld.w	r6,pc[780]
8000398c:	6c 0c       	ld.w	r12,r6[0x0]
8000398e:	f0 1f 00 cd 	mcall	80003cc0 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003992:	fe f8 02 fa 	ld.w	r8,pc[762]
80003996:	70 0c       	ld.w	r12,r8[0x0]
80003998:	f0 1f 00 b7 	mcall	80003c74 <phy_rx_func+0xe98>
8000399c:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
8000399e:	c0 71       	brne	800039ac <phy_rx_func+0xbd0>
							{
								RxMediaState = WAITINGABAB;
800039a0:	30 09       	mov	r9,0
800039a2:	fe f8 02 f6 	ld.w	r8,pc[758]
800039a6:	91 09       	st.w	r8[0x0],r9
800039a8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
800039ac:	fe f9 02 f4 	ld.w	r9,pc[756]
800039b0:	72 08       	ld.w	r8,r9[0x0]
800039b2:	20 18       	sub	r8,1
800039b4:	93 08       	st.w	r9[0x0],r8
800039b6:	c0 71       	brne	800039c4 <phy_rx_func+0xbe8>
							RxMediaState = WAITINGABAB;
800039b8:	30 09       	mov	r9,0
800039ba:	fe f8 02 de 	ld.w	r8,pc[734]
800039be:	91 09       	st.w	r8[0x0],r9
800039c0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//7
800039c4:	fe f8 02 f4 	ld.w	r8,pc[756]
800039c8:	fe f9 02 cc 	ld.w	r9,pc[716]
800039cc:	72 0a       	ld.w	r10,r9[0x0]
800039ce:	70 09       	ld.w	r9,r8[0x0]
800039d0:	ef 3b 00 0c 	ld.ub	r11,r7[12]
800039d4:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
800039d8:	70 09       	ld.w	r9,r8[0x0]
800039da:	2f f9       	sub	r9,-1
800039dc:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800039de:	e0 49 01 ff 	cp.w	r9,511
800039e2:	e0 88 00 16 	brls	80003a0e <phy_rx_func+0xc32>
						{
							RxAMBE_IsFillingNext8 = 0;
800039e6:	30 09       	mov	r9,0
800039e8:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
800039ea:	fe f7 02 aa 	ld.w	r7,pc[682]
800039ee:	6e 0c       	ld.w	r12,r7[0x0]
800039f0:	f0 1f 00 b4 	mcall	80003cc0 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
800039f4:	fe f8 02 98 	ld.w	r8,pc[664]
800039f8:	70 0c       	ld.w	r12,r8[0x0]
800039fa:	f0 1f 00 9f 	mcall	80003c74 <phy_rx_func+0xe98>
800039fe:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003a00:	c0 71       	brne	80003a0e <phy_rx_func+0xc32>
							{
								RxMediaState = WAITINGABAB;
80003a02:	30 09       	mov	r9,0
80003a04:	fe f8 02 94 	ld.w	r8,pc[660]
80003a08:	91 09       	st.w	r8[0x0],r9
80003a0a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003a0e:	fe f9 02 92 	ld.w	r9,pc[658]
80003a12:	72 08       	ld.w	r8,r9[0x0]
80003a14:	20 18       	sub	r8,1
80003a16:	93 08       	st.w	r9[0x0],r8
80003a18:	c0 71       	brne	80003a26 <phy_rx_func+0xc4a>
							RxMediaState = WAITINGABAB;
80003a1a:	30 09       	mov	r9,0
80003a1c:	fe f8 02 7c 	ld.w	r8,pc[636]
80003a20:	91 09       	st.w	r8[0x0],r9
80003a22:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
						if ((RxBytesWaiting -= 1) <= 0){
80003a26:	20 18       	sub	r8,1
80003a28:	fe f9 02 78 	ld.w	r9,pc[632]
80003a2c:	93 08       	st.w	r9[0x0],r8
80003a2e:	58 08       	cp.w	r8,0
80003a30:	e0 81 01 13 	brne	80003c56 <phy_rx_func+0xe7a>
							
							//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
							//or discard it to reduce payload size.
							
							RxMediaState = WAITINGABAB;
80003a34:	30 09       	mov	r9,0
80003a36:	fe f8 02 62 	ld.w	r8,pc[610]
80003a3a:	91 09       	st.w	r8[0x0],r9
80003a3c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
					}
					else if ((Item_ID == 0x04)  ||  (Item_ID == 0x03))//Unknown type data directly back hair
80003a40:	fe f8 02 70 	ld.w	r8,pc[624]
80003a44:	11 89       	ld.ub	r9,r8[0x0]
80003a46:	30 48       	mov	r8,4
80003a48:	f0 09 18 00 	cp.b	r9,r8
80003a4c:	c0 80       	breq	80003a5c <phy_rx_func+0xc80>
80003a4e:	fe f8 02 62 	ld.w	r8,pc[610]
80003a52:	11 89       	ld.ub	r9,r8[0x0]
80003a54:	30 38       	mov	r8,3
80003a56:	f0 09 18 00 	cp.b	r9,r8
80003a5a:	c1 41       	brne	80003a82 <phy_rx_func+0xca6>
					{
						AMBE_HT[0] = payload_rx_channel->dword[0];
80003a5c:	6e 29       	ld.w	r9,r7[0x8]
80003a5e:	fe f8 02 7a 	ld.w	r8,pc[634]
80003a62:	91 09       	st.w	r8[0x0],r9
						AMBE_HT[1] = payload_rx_channel->dword[1];				
80003a64:	6e 39       	ld.w	r9,r7[0xc]
80003a66:	91 19       	st.w	r8[0x4],r9
						
						if ((RxBytesWaiting -= 8) <= 0)//Consider two cases 0xABCDC014 and 0xABCDC010
80003a68:	fe f9 02 38 	ld.w	r9,pc[568]
80003a6c:	72 08       	ld.w	r8,r9[0x0]
80003a6e:	20 88       	sub	r8,8
80003a70:	93 08       	st.w	r9[0x0],r8
80003a72:	e0 81 00 f2 	brne	80003c56 <phy_rx_func+0xe7a>
						{
					
							RxBytesWaiting = 0;
80003a76:	93 08       	st.w	r9[0x0],r8
							RxMediaState = WAITINGABAB;
80003a78:	fe f9 02 20 	ld.w	r9,pc[544]
80003a7c:	93 08       	st.w	r9[0x0],r8
80003a7e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
						}
						break;

					}
					else if (Item_ID == Soft_Decision_Value)
80003a82:	fe f8 02 2e 	ld.w	r8,pc[558]
80003a86:	11 89       	ld.ub	r9,r8[0x0]
80003a88:	31 38       	mov	r8,19
80003a8a:	f0 09 18 00 	cp.b	r9,r8
80003a8e:	e0 81 00 9c 	brne	80003bc6 <phy_rx_func+0xdea>
					{							
						if (SDV_Index == 12)
80003a92:	fe f8 02 62 	ld.w	r8,pc[610]
80003a96:	11 88       	ld.ub	r8,r8[0x0]
80003a98:	30 c9       	mov	r9,12
80003a9a:	f2 08 18 00 	cp.b	r8,r9
80003a9e:	e0 81 00 7b 	brne	80003b94 <phy_rx_func+0xdb8>
						{
							Soft_Decision_Data[SDV_Index]= payload_rx_channel->word[0];
80003aa2:	8e 49       	ld.sh	r9,r7[0x8]
80003aa4:	fe f8 02 54 	ld.w	r8,pc[596]
80003aa8:	f1 59 00 18 	st.h	r8[24],r9
							
							SDV_Index = 0;
80003aac:	30 09       	mov	r9,0
80003aae:	fe f8 02 46 	ld.w	r8,pc[582]
80003ab2:	b0 89       	st.b	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003ab4:	ef 39 00 0d 	ld.ub	r9,r7[13]
80003ab8:	3f 38       	mov	r8,-13
80003aba:	f0 09 18 00 	cp.b	r9,r8
80003abe:	c6 61       	brne	80003b8a <phy_rx_func+0xdae>
							
							SDV_Index = 0;
								
							if (payload_rx_channel->byte[5] == Pre_Voice_Decoder_Data )//0xF3
							{
									Item_ID = Pre_Voice_Decoder_Data;
80003ac0:	10 99       	mov	r9,r8
80003ac2:	4f c8       	lddpc	r8,80003cb0 <phy_rx_func+0xed4>
80003ac4:	b0 89       	st.b	r8[0x0],r9
									RxBytesWaiting = (payload_rx_channel->byte[4] & 0x7F);//Test calculations are correct; 8
80003ac6:	ef 39 00 0c 	ld.ub	r9,r7[12]
80003aca:	f3 d9 c0 07 	bfextu	r9,r9,0x0,0x7
80003ace:	4f 58       	lddpc	r8,80003ca0 <phy_rx_func+0xec4>
80003ad0:	91 09       	st.w	r8[0x0],r9
									AMBE_rx_flag = 1;//本地作为AMBE数据的解密方
80003ad2:	30 19       	mov	r9,1
80003ad4:	fe f8 02 0c 	ld.w	r8,pc[524]
80003ad8:	b0 89       	st.b	r8[0x0],r9
		
									AMBEBurst_rawdata[0] = payload_rx_channel->word[3];//用于解密的中间数据变量
80003ada:	8e 79       	ld.sh	r9,r7[0xe]
80003adc:	fe f8 02 14 	ld.w	r8,pc[532]
80003ae0:	b0 09       	st.h	r8[0x0],r9
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//1
80003ae2:	4f 68       	lddpc	r8,80003cb8 <phy_rx_func+0xedc>
80003ae4:	4e c9       	lddpc	r9,80003c94 <phy_rx_func+0xeb8>
80003ae6:	72 0a       	ld.w	r10,r9[0x0]
80003ae8:	70 09       	ld.w	r9,r8[0x0]
80003aea:	ef 3b 00 0e 	ld.ub	r11,r7[14]
80003aee:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
80003af2:	70 09       	ld.w	r9,r8[0x0]
80003af4:	2f f9       	sub	r9,-1
80003af6:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003af8:	e0 49 01 ff 	cp.w	r9,511
80003afc:	e0 88 00 13 	brls	80003b22 <phy_rx_func+0xd46>
									{
										RxAMBE_IsFillingNext8 = 0;
80003b00:	30 09       	mov	r9,0
80003b02:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
80003b04:	4e 46       	lddpc	r6,80003c94 <phy_rx_func+0xeb8>
80003b06:	6c 0c       	ld.w	r12,r6[0x0]
80003b08:	f0 1f 00 6e 	mcall	80003cc0 <phy_rx_func+0xee4>
										AMBE_payload_ptr = get_payload_idle_isr();
80003b0c:	4e 08       	lddpc	r8,80003c8c <phy_rx_func+0xeb0>
80003b0e:	70 0c       	ld.w	r12,r8[0x0]
80003b10:	f0 1f 00 59 	mcall	80003c74 <phy_rx_func+0xe98>
80003b14:	8d 0c       	st.w	r6[0x0],r12
										if(NULL == AMBE_payload_ptr)
80003b16:	c0 61       	brne	80003b22 <phy_rx_func+0xd46>
										{
											RxMediaState = WAITINGABAB;
80003b18:	30 09       	mov	r9,0
80003b1a:	4e 08       	lddpc	r8,80003c98 <phy_rx_func+0xebc>
80003b1c:	91 09       	st.w	r8[0x0],r9
80003b1e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
80003b22:	4e 09       	lddpc	r9,80003ca0 <phy_rx_func+0xec4>
80003b24:	72 08       	ld.w	r8,r9[0x0]
80003b26:	20 18       	sub	r8,1
80003b28:	93 08       	st.w	r9[0x0],r8
80003b2a:	c0 61       	brne	80003b36 <phy_rx_func+0xd5a>
										RxMediaState = WAITINGABAB;
80003b2c:	30 09       	mov	r9,0
80003b2e:	4d b8       	lddpc	r8,80003c98 <phy_rx_func+0xebc>
80003b30:	91 09       	st.w	r8[0x0],r9
80003b32:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//2
80003b36:	4e 18       	lddpc	r8,80003cb8 <phy_rx_func+0xedc>
80003b38:	4d 79       	lddpc	r9,80003c94 <phy_rx_func+0xeb8>
80003b3a:	72 0a       	ld.w	r10,r9[0x0]
80003b3c:	70 09       	ld.w	r9,r8[0x0]
80003b3e:	ef 3b 00 0f 	ld.ub	r11,r7[15]
80003b42:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
80003b46:	70 09       	ld.w	r9,r8[0x0]
80003b48:	2f f9       	sub	r9,-1
80003b4a:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003b4c:	e0 49 01 ff 	cp.w	r9,511
80003b50:	e0 88 00 13 	brls	80003b76 <phy_rx_func+0xd9a>
									{
										RxAMBE_IsFillingNext8 = 0;
80003b54:	30 09       	mov	r9,0
80003b56:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
80003b58:	4c f7       	lddpc	r7,80003c94 <phy_rx_func+0xeb8>
80003b5a:	6e 0c       	ld.w	r12,r7[0x0]
80003b5c:	f0 1f 00 59 	mcall	80003cc0 <phy_rx_func+0xee4>
										AMBE_payload_ptr = get_payload_idle_isr();
80003b60:	4c b8       	lddpc	r8,80003c8c <phy_rx_func+0xeb0>
80003b62:	70 0c       	ld.w	r12,r8[0x0]
80003b64:	f0 1f 00 44 	mcall	80003c74 <phy_rx_func+0xe98>
80003b68:	8f 0c       	st.w	r7[0x0],r12
										if(NULL == AMBE_payload_ptr)
80003b6a:	c0 61       	brne	80003b76 <phy_rx_func+0xd9a>
										{
											RxMediaState = WAITINGABAB;
80003b6c:	30 09       	mov	r9,0
80003b6e:	4c b8       	lddpc	r8,80003c98 <phy_rx_func+0xebc>
80003b70:	91 09       	st.w	r8[0x0],r9
80003b72:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
80003b76:	4c b9       	lddpc	r9,80003ca0 <phy_rx_func+0xec4>
80003b78:	72 08       	ld.w	r8,r9[0x0]
80003b7a:	20 18       	sub	r8,1
80003b7c:	93 08       	st.w	r9[0x0],r8
80003b7e:	c6 c1       	brne	80003c56 <phy_rx_func+0xe7a>
										RxMediaState = WAITINGABAB;
80003b80:	30 09       	mov	r9,0
80003b82:	4c 68       	lddpc	r8,80003c98 <phy_rx_func+0xebc>
80003b84:	91 09       	st.w	r8[0x0],r9
80003b86:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
							}
							else
							RxMediaState = WAITINGABAB;
80003b8a:	30 09       	mov	r9,0
80003b8c:	4c 38       	lddpc	r8,80003c98 <phy_rx_func+0xebc>
80003b8e:	91 09       	st.w	r8[0x0],r9
80003b90:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
						}
						else
						{
									
							Soft_Decision_Data[SDV_Index]	  = payload_rx_channel->word[0];
80003b94:	8e 4a       	ld.sh	r10,r7[0x8]
80003b96:	4d 99       	lddpc	r9,80003cf8 <phy_rx_func+0xf1c>
80003b98:	f2 08 0a 1a 	st.h	r9[r8<<0x1],r10
							Soft_Decision_Data[SDV_Index+1]	  = payload_rx_channel->word[1];
80003b9c:	4d 6a       	lddpc	r10,80003cf4 <phy_rx_func+0xf18>
80003b9e:	15 88       	ld.ub	r8,r10[0x0]
80003ba0:	f0 cb ff ff 	sub	r11,r8,-1
80003ba4:	8e 5c       	ld.sh	r12,r7[0xa]
80003ba6:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+2]	  = payload_rx_channel->word[2];
80003baa:	f0 cb ff fe 	sub	r11,r8,-2
80003bae:	8e 6c       	ld.sh	r12,r7[0xc]
80003bb0:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+3]	  = payload_rx_channel->word[3];
80003bb4:	f0 cb ff fd 	sub	r11,r8,-3
80003bb8:	8e 7c       	ld.sh	r12,r7[0xe]
80003bba:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							SDV_Index +=4;
80003bbe:	2f c8       	sub	r8,-4
80003bc0:	b4 88       	st.b	r10[0x0],r8
80003bc2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					
					else
					{
						
						RxMediaState  = WAITINGABAB;
80003bc6:	30 09       	mov	r9,0
80003bc8:	4b 48       	lddpc	r8,80003c98 <phy_rx_func+0xebc>
80003bca:	91 09       	st.w	r8[0x0],r9
80003bcc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
		break;//End of READING_AMBE_MEDIA.

        case READING_AMBE_AUX:
			
				Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[0];
80003bd0:	4c 08       	lddpc	r8,80003cd0 <phy_rx_func+0xef4>
80003bd2:	70 09       	ld.w	r9,r8[0x0]
80003bd4:	8e 4b       	ld.sh	r11,r7[0x8]
80003bd6:	4c 0a       	lddpc	r10,80003cd4 <phy_rx_func+0xef8>
80003bd8:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
				RxData_IsFillingNext16 += 1;
80003bdc:	2f f9       	sub	r9,-1
80003bde:	91 09       	st.w	r8[0x0],r9
			
				if ((Item_Length -= 2) <= 0)
80003be0:	4b 58       	lddpc	r8,80003cb4 <phy_rx_func+0xed8>
80003be2:	70 09       	ld.w	r9,r8[0x0]
80003be4:	20 29       	sub	r9,2
80003be6:	91 09       	st.w	r8[0x0],r9
80003be8:	70 08       	ld.w	r8,r8[0x0]
80003bea:	58 08       	cp.w	r8,0
80003bec:	c2 f1       	brne	80003c4a <phy_rx_func+0xe6e>
				{
					RxData_IsFillingNext16 = 0;
80003bee:	30 09       	mov	r9,0
80003bf0:	4b 88       	lddpc	r8,80003cd0 <phy_rx_func+0xef4>
80003bf2:	91 09       	st.w	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003bf4:	8e 59       	ld.sh	r9,r7[0xa]
80003bf6:	fe 78 82 12 	mov	r8,-32238
80003bfa:	f0 09 19 00 	cp.h	r9,r8
80003bfe:	c2 11       	brne	80003c40 <phy_rx_func+0xe64>
					{
						//Item_ID = Vocoder_Bit_Stream_Parameter;
						//Vocoder Bits Stream Parameter
						//Its value ranges from 1 to 18 for one voice superframe contains 6 voice bursts
						// and each burst contains 3 VFs.
						VF_SN = (payload_rx_channel->byte[5] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
80003c00:	ef 3c 00 0d 	ld.ub	r12,r7[13]
80003c04:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
80003c08:	4a f8       	lddpc	r8,80003cc4 <phy_rx_func+0xee8>
80003c0a:	b0 8c       	st.b	r8[0x0],r12
							
						VBSP_data[0] = payload_rx_channel->word[1];
80003c0c:	8e 59       	ld.sh	r9,r7[0xa]
80003c0e:	4a f8       	lddpc	r8,80003cc8 <phy_rx_func+0xeec>
80003c10:	b0 09       	st.h	r8[0x0],r9
						VBSP_data[1] = payload_rx_channel->word[2];
80003c12:	8e 69       	ld.sh	r9,r7[0xc]
80003c14:	b0 19       	st.h	r8[0x2],r9
							
						m_RxBurstType = CalculateBurst(VF_SN);
80003c16:	f0 1f 00 2e 	mcall	80003ccc <phy_rx_func+0xef0>
80003c1a:	4a 18       	lddpc	r8,80003c9c <phy_rx_func+0xec0>
80003c1c:	91 0c       	st.w	r8[0x0],r12
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003c1e:	ef 39 00 0f 	ld.ub	r9,r7[15]
80003c22:	31 38       	mov	r8,19
80003c24:	f0 09 18 00 	cp.b	r9,r8
80003c28:	c0 71       	brne	80003c36 <phy_rx_func+0xe5a>
							
						m_RxBurstType = CalculateBurst(VF_SN);
						
						if (payload_rx_channel->byte[7] == Soft_Decision_Value)//0x13
						{
							Item_ID = Soft_Decision_Value;	
80003c2a:	10 99       	mov	r9,r8
80003c2c:	4a 18       	lddpc	r8,80003cb0 <phy_rx_func+0xed4>
80003c2e:	b0 89       	st.b	r8[0x0],r9
							RxBytesWaiting = ((payload_rx_channel->dword[1] & 0x00007F00) >>24);//Test calculations are correct; 26
80003c30:	30 09       	mov	r9,0
80003c32:	49 c8       	lddpc	r8,80003ca0 <phy_rx_func+0xec4>
80003c34:	91 09       	st.w	r8[0x0],r9
						else
						{//error
								RxMediaState = WAITINGABAB;//Jump
						}
							
						RxMediaState = READING_AMBE_MEDIA;//Jump
80003c36:	30 49       	mov	r9,4
80003c38:	49 88       	lddpc	r8,80003c98 <phy_rx_func+0xebc>
80003c3a:	91 09       	st.w	r8[0x0],r9
80003c3c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					else
					{
						RxMediaState = WAITINGABAB;//Jump
80003c40:	30 09       	mov	r9,0
80003c42:	49 68       	lddpc	r8,80003c98 <phy_rx_func+0xebc>
80003c44:	91 09       	st.w	r8[0x0],r9
80003c46:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}

				}
				else
				{//测试看看是几个字节数据
					logFromISR("\n\r Radio Internal parameter length error \n\r");
80003c4a:	4a dc       	lddpc	r12,80003cfc <phy_rx_func+0xf20>
80003c4c:	f0 1f 00 18 	mcall	80003cac <phy_rx_func+0xed0>
					RxMediaState = WAITINGABAB;//Jump
80003c50:	30 09       	mov	r9,0
80003c52:	49 28       	lddpc	r8,80003c98 <phy_rx_func+0xebc>
80003c54:	91 09       	st.w	r8[0x0],r9
80003c56:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80003c5a:	00 00       	add	r0,r0
80003c5c:	00 00       	add	r0,r0
80003c5e:	0a b4       	st.h	r5++,r4
80003c60:	00 00       	add	r0,r0
80003c62:	0a cc       	st.b	r5++,r12
80003c64:	00 00       	add	r0,r0
80003c66:	0a ac       	st.w	r5++,r12
80003c68:	00 00       	add	r0,r0
80003c6a:	0a 8e       	andn	lr,r5
80003c6c:	00 00       	add	r0,r0
80003c6e:	0a 7c       	tst	r12,r5
80003c70:	00 00       	add	r0,r0
80003c72:	0a a4       	st.w	r5++,r4
80003c74:	80 00       	ld.sh	r0,r0[0x0]
80003c76:	2c 5c       	sub	r12,-59
80003c78:	00 00       	add	r0,r0
80003c7a:	0a 9c       	mov	r12,r5
80003c7c:	80 00       	ld.sh	r0,r0[0x0]
80003c7e:	2b 74       	sub	r4,-73
80003c80:	00 00       	add	r0,r0
80003c82:	0a b0       	st.h	r5++,r0
80003c84:	80 00       	ld.sh	r0,r0[0x0]
80003c86:	2b a8       	sub	r8,-70
80003c88:	00 00       	add	r0,r0
80003c8a:	0a 8d       	andn	sp,r5
80003c8c:	00 00       	add	r0,r0
80003c8e:	0a a8       	st.w	r5++,r8
80003c90:	00 00       	add	r0,r0
80003c92:	0a b8       	st.h	r5++,r8
80003c94:	00 00       	add	r0,r0
80003c96:	0a 90       	mov	r0,r5
80003c98:	00 00       	add	r0,r0
80003c9a:	0a d8       	st.w	--r5,r8
80003c9c:	00 00       	add	r0,r0
80003c9e:	0a c0       	st.b	r5++,r0
80003ca0:	00 00       	add	r0,r0
80003ca2:	0a 78       	tst	r8,r5
80003ca4:	00 00       	add	r0,r0
80003ca6:	0a 4c       	or	r12,r5
80003ca8:	80 00       	ld.sh	r0,r0[0x0]
80003caa:	d7 f4       	*unknown*
80003cac:	80 00       	ld.sh	r0,r0[0x0]
80003cae:	70 f8       	ld.w	r8,r8[0x3c]
80003cb0:	00 00       	add	r0,r0
80003cb2:	0a 8c       	andn	r12,r5
80003cb4:	00 00       	add	r0,r0
80003cb6:	0a e4       	st.h	--r5,r4
80003cb8:	00 00       	add	r0,r0
80003cba:	0a c4       	st.b	r5++,r4
80003cbc:	80 00       	ld.sh	r0,r0[0x0]
80003cbe:	79 30       	ld.w	r0,r12[0x4c]
80003cc0:	80 00       	ld.sh	r0,r0[0x0]
80003cc2:	2b 90       	sub	r0,-71
80003cc4:	00 00       	add	r0,r0
80003cc6:	0a 5d       	eor	sp,r5
80003cc8:	00 00       	add	r0,r0
80003cca:	1e b4       	st.h	pc++,r4
80003ccc:	80 00       	ld.sh	r0,r0[0x0]
80003cce:	2b 44       	sub	r4,-76
80003cd0:	00 00       	add	r0,r0
80003cd2:	0a 80       	andn	r0,r5
80003cd4:	00 00       	add	r0,r0
80003cd6:	1d b8       	ld.ub	r8,lr[0x3]
80003cd8:	00 00       	add	r0,r0
80003cda:	0a 84       	andn	r4,r5
80003cdc:	00 00       	add	r0,r0
80003cde:	0a 48       	or	r8,r5
80003ce0:	00 00       	add	r0,r0
80003ce2:	0a 4b       	or	r11,r5
80003ce4:	00 00       	add	r0,r0
80003ce6:	0a dc       	st.w	--r5,r12
80003ce8:	00 00       	add	r0,r0
80003cea:	0a 98       	mov	r8,r5
80003cec:	00 00       	add	r0,r0
80003cee:	0a 64       	and	r4,r5
80003cf0:	00 00       	add	r0,r0
80003cf2:	1d b0       	ld.ub	r0,lr[0x3]
80003cf4:	00 00       	add	r0,r0
80003cf6:	0a d0       	st.w	--r5,r0
80003cf8:	00 00       	add	r0,r0
80003cfa:	1e b8       	st.h	pc++,r8
80003cfc:	80 00       	ld.sh	r0,r0[0x0]
80003cfe:	d8 0c       	*unknown*

80003d00 <pdca_int_handler>:
    void (*phy_rx_exec)(void *)--callback function for receive SSC data 
Called By: interrupt
*/
__attribute__((__interrupt__))
static void pdca_int_handler(void)
{
80003d00:	d4 01       	pushm	lr
	//xHigherPriorityTaskWoken = pdFALSE;
	
	static U32 count=0;
	//intStartCount = Get_system_register(AVR32_COUNT);
	
	count++;
80003d02:	49 a8       	lddpc	r8,80003d68 <pdca_int_handler+0x68>
80003d04:	70 09       	ld.w	r9,r8[0x0]
80003d06:	2f f9       	sub	r9,-1
80003d08:	91 09       	st.w	r8[0x0],r9
	/*Toggle Index*/
    BufferIndex ^= 0x01;
80003d0a:	49 98       	lddpc	r8,80003d6c <pdca_int_handler+0x6c>
80003d0c:	11 89       	ld.ub	r9,r8[0x0]
80003d0e:	ec 19 00 01 	eorl	r9,0x1
80003d12:	b0 89       	st.b	r8[0x0],r9
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);
80003d14:	11 89       	ld.ub	r9,r8[0x0]
80003d16:	a5 69       	lsl	r9,0x4
80003d18:	2f c9       	sub	r9,-4
80003d1a:	49 6a       	lddpc	r10,80003d70 <pdca_int_handler+0x70>
80003d1c:	14 09       	add	r9,r10
	count++;
	/*Toggle Index*/
    BufferIndex ^= 0x01;
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
80003d1e:	fe 7a 00 40 	mov	r10,-65472
80003d22:	95 39       	st.w	r10[0xc],r9
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80003d24:	30 39       	mov	r9,3
80003d26:	95 49       	st.w	r10[0x10],r9

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);
80003d28:	11 8a       	ld.ub	r10,r8[0x0]
80003d2a:	a5 6a       	lsl	r10,0x4
80003d2c:	2f ca       	sub	r10,-4
80003d2e:	49 28       	lddpc	r8,80003d74 <pdca_int_handler+0x74>
80003d30:	10 0a       	add	r10,r8
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
80003d32:	fe 78 00 00 	mov	r8,-65536
80003d36:	91 3a       	st.w	r8[0xc],r10
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80003d38:	91 49       	st.w	r8[0x10],r9
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr;
80003d3a:	70 b8       	ld.w	r8,r8[0x2c]
	
	/*receive SSC data*/
    if(phy_rx_exec != NULL)phy_rx_exec((void *)&RxBuffer[BufferIndex]);
80003d3c:	48 f8       	lddpc	r8,80003d78 <pdca_int_handler+0x78>
80003d3e:	70 08       	ld.w	r8,r8[0x0]
80003d40:	58 08       	cp.w	r8,0
80003d42:	c0 70       	breq	80003d50 <pdca_int_handler+0x50>
80003d44:	48 a9       	lddpc	r9,80003d6c <pdca_int_handler+0x6c>
80003d46:	13 89       	ld.ub	r9,r9[0x0]
80003d48:	a5 69       	lsl	r9,0x4
80003d4a:	48 bc       	lddpc	r12,80003d74 <pdca_int_handler+0x74>
80003d4c:	12 0c       	add	r12,r9
80003d4e:	5d 18       	icall	r8

    /*transmit SSC data*/

	if(phy_tx_exec != NULL)phy_tx_exec((void *)&TxBuffer[BufferIndex]);//phy_tx_func, phy_rx_func
80003d50:	48 b8       	lddpc	r8,80003d7c <pdca_int_handler+0x7c>
80003d52:	70 08       	ld.w	r8,r8[0x0]
80003d54:	58 08       	cp.w	r8,0
80003d56:	c0 70       	breq	80003d64 <pdca_int_handler+0x64>
80003d58:	48 59       	lddpc	r9,80003d6c <pdca_int_handler+0x6c>
80003d5a:	13 89       	ld.ub	r9,r9[0x0]
80003d5c:	a5 69       	lsl	r9,0x4
80003d5e:	48 5c       	lddpc	r12,80003d70 <pdca_int_handler+0x70>
80003d60:	12 0c       	add	r12,r9
80003d62:	5d 18       	icall	r8

	
	//intDuration = Get_system_register(AVR32_COUNT) - intStartCount;
	
	
}/*End of pdca_int_handler.*/
80003d64:	d4 02       	popm	lr
80003d66:	d6 03       	rete
80003d68:	00 00       	add	r0,r0
80003d6a:	0a ec       	st.h	--r5,r12
80003d6c:	00 00       	add	r0,r0
80003d6e:	50 d8       	stdsp	sp[0x34],r8
80003d70:	00 00       	add	r0,r0
80003d72:	51 00       	stdsp	sp[0x40],r0
80003d74:	00 00       	add	r0,r0
80003d76:	50 e0       	stdsp	sp[0x38],r0
80003d78:	00 00       	add	r0,r0
80003d7a:	0a e8       	st.h	--r5,r8
80003d7c:	00 00       	add	r0,r0
80003d7e:	0a f0       	st.b	--r5,r0

80003d80 <local_start_SSC>:
void local_start_SSC(void)
{
    /*Assign GPIO to SSC.
    gpio_enable_module
    gpio_enable_module_pin*/
    AVR32_GPIO.port[1].pmr0c = 0x00000DC0;
80003d80:	fe 78 10 00 	mov	r8,-61440
80003d84:	e0 69 0d c0 	mov	r9,3520
80003d88:	f1 49 01 18 	st.w	r8[280],r9
    AVR32_GPIO.port[1].pmr1c = 0x00000DC0;
80003d8c:	f1 49 01 28 	st.w	r8[296],r9
    AVR32_GPIO.port[1].gperc = 0x00000DC0;
80003d90:	f1 49 01 08 	st.w	r8[264],r9

    /*Software reset SSC*/
    (&AVR32_SSC)->cr = AVR32_SSC_CR_SWRST_MASK;
80003d94:	fe 78 34 00 	mov	r8,-52224
80003d98:	e0 69 80 00 	mov	r9,32768
80003d9c:	91 09       	st.w	r8[0x0],r9
    (&AVR32_SSC)->cmr 
80003d9e:	30 09       	mov	r9,0
80003da0:	91 19       	st.w	r8[0x4],r9
                     = AVR32_SSC_CMR_DIV_NOT_ACTIVE << AVR32_SSC_CMR_DIV_OFFSET;

    /*For Slave*/
    (&AVR32_SSC)->tcmr =
80003da2:	e0 69 04 21 	mov	r9,1057
80003da6:	ea 19 3f 20 	orh	r9,0x3f20
80003daa:	91 69       	st.w	r8[0x18],r9
	      32								<< AVR32_SSC_TCMR_STTDLY_OFFSET	|
	      63								<< AVR32_SSC_TCMR_PERIOD_OFFSET;


    /*For Slave*/
    (&AVR32_SSC)->tfmr = 
80003dac:	e0 69 02 9f 	mov	r9,671
80003db0:	ea 19 01 00 	orh	r9,0x100
80003db4:	91 79       	st.w	r8[0x1c],r9
	     0									<< AVR32_SSC_TFMR_FSDEN_OFFSET	|
	     1									<< AVR32_SSC_TFMR_FSEDGE_OFFSET;

	/*For Slave*/

	(&AVR32_SSC)->rcmr = 
80003db6:	e0 6a 04 02 	mov	r10,1026
80003dba:	ea 1a 3f 20 	orh	r10,0x3f20
80003dbe:	91 4a       	st.w	r8[0x10],r10
	     0									<< AVR32_SSC_RCMR_STOP_OFFSET	|
	     32									<< AVR32_SSC_RCMR_STTDLY_OFFSET	|
	     63									<< AVR32_SSC_RCMR_PERIOD_OFFSET;

	/*For Slave*/
	(&AVR32_SSC)->rfmr = 
80003dc0:	91 59       	st.w	r8[0x14],r9
	    1									<< AVR32_SSC_RFMR_MSBF_OFFSET	|
	    2									<< AVR32_SSC_RFMR_DATNB_OFFSET	|
	    0									<< AVR32_SSC_RFMR_FSLEN_OFFSET	|
	    AVR32_SSC_RFMR_FSOS_INPUT_ONLY		<< AVR32_SSC_RFMR_FSOS_OFFSET	|
	    1									<< AVR32_SSC_RFMR_FSEDGE_OFFSET;
}/*End of local_start_SSC.*/
80003dc2:	5e fc       	retal	r12

80003dc4 <local_start_PDC>:
Function: local_start_PDC
Description: none
Called By: void ssc_init(void) -- ssc.c
*/
void local_start_PDC(void)
{
80003dc4:	d4 01       	pushm	lr
    /*Toggle Index*/	
    BufferIndex = 1;
80003dc6:	30 19       	mov	r9,1
80003dc8:	49 78       	lddpc	r8,80003e24 <local_start_PDC+0x60>
80003dca:	b0 89       	st.b	r8[0x0],r9
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
80003dcc:	fe 78 00 00 	mov	r8,-65536
80003dd0:	30 7b       	mov	r11,7
80003dd2:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
80003dd4:	70 b9       	ld.w	r9,r8[0x2c]
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
80003dd6:	49 59       	lddpc	r9,80003e28 <local_start_PDC+0x64>
80003dd8:	f2 ca ff fc 	sub	r10,r9,-4
    BufferIndex = 1;
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
80003ddc:	91 0a       	st.w	r8[0x0],r10
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
80003dde:	30 3a       	mov	r10,3
80003de0:	91 2a       	st.w	r8[0x8],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
80003de2:	30 1c       	mov	r12,1
80003de4:	91 1c       	st.w	r8[0x4],r12
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
80003de6:	2e c9       	sub	r9,-20
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
80003de8:	91 39       	st.w	r8[0xc],r9
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80003dea:	91 4a       	st.w	r8[0x10],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80003dec:	30 2c       	mov	r12,2
80003dee:	91 6c       	st.w	r8[0x18],r12

	TxBuffer[0].xnl_channel.dword = XNL_IDLE;
80003df0:	48 f9       	lddpc	r9,80003e2c <local_start_PDC+0x68>
80003df2:	e0 68 5a 5a 	mov	r8,23130
80003df6:	ea 18 ab cd 	orh	r8,0xabcd
80003dfa:	93 18       	st.w	r9[0x4],r8
	TxBuffer[0].payload_channel.dword[0] = PAYLOADIDLE0;
80003dfc:	93 28       	st.w	r9[0x8],r8
	TxBuffer[0].payload_channel.dword[1] = PAYLOADIDLE1;
80003dfe:	30 0e       	mov	lr,0
80003e00:	93 3e       	st.w	r9[0xc],lr
	TxBuffer[1].xnl_channel.dword = XNL_IDLE;
80003e02:	93 58       	st.w	r9[0x14],r8
	TxBuffer[1].payload_channel.dword[0] = PAYLOADIDLE0;
80003e04:	93 68       	st.w	r9[0x18],r8
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;
80003e06:	93 7e       	st.w	r9[0x1c],lr

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
80003e08:	fe 78 00 40 	mov	r8,-65472
80003e0c:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
80003e0e:	70 be       	ld.w	lr,r8[0x2c]
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
80003e10:	f2 ce ff fc 	sub	lr,r9,-4
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
80003e14:	91 0e       	st.w	r8[0x0],lr
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
80003e16:	91 2a       	st.w	r8[0x8],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
80003e18:	91 1b       	st.w	r8[0x4],r11
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
80003e1a:	2e c9       	sub	r9,-20
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
80003e1c:	91 39       	st.w	r8[0xc],r9
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80003e1e:	91 4a       	st.w	r8[0x10],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80003e20:	91 6c       	st.w	r8[0x18],r12
}/*End of local_start_PDC.*/
80003e22:	d8 02       	popm	pc
80003e24:	00 00       	add	r0,r0
80003e26:	50 d8       	stdsp	sp[0x34],r8
80003e28:	00 00       	add	r0,r0
80003e2a:	50 e0       	stdsp	sp[0x38],r0
80003e2c:	00 00       	add	r0,r0
80003e2e:	51 00       	stdsp	sp[0x40],r0

80003e30 <register_rx_tx_func>:
Description: register the rx function(callback function)
Called By: phy_init -- physical.c
*/
void register_rx_tx_func(void (*rx_exec)(void *),  void ( *tx_exec)(void *))
{
	 phy_rx_exec = rx_exec;
80003e30:	48 38       	lddpc	r8,80003e3c <register_rx_tx_func+0xc>
80003e32:	91 0c       	st.w	r8[0x0],r12
	 phy_tx_exec = tx_exec;//phy_tx_func, phy_rx_func
80003e34:	48 38       	lddpc	r8,80003e40 <register_rx_tx_func+0x10>
80003e36:	91 0b       	st.w	r8[0x0],r11
	 
}/*End of register_tx_rx_func.*/
80003e38:	5e fc       	retal	r12
80003e3a:	00 00       	add	r0,r0
80003e3c:	00 00       	add	r0,r0
80003e3e:	0a e8       	st.h	--r5,r8
80003e40:	00 00       	add	r0,r0
80003e42:	0a f0       	st.b	--r5,r0

80003e44 <ssc_init>:
    local_start_SSC -- ssc.c
    local_start_PDC -- ssc.c
Called By: phy_init -- physical.c
*/
void ssc_init(void)
{		
80003e44:	d4 01       	pushm	lr
    /*Set up PB01 to watch FS.*/
    AVR32_GPIO.port[1].oderc = 0x00000002;
80003e46:	fe 78 10 00 	mov	r8,-61440
80003e4a:	30 29       	mov	r9,2
80003e4c:	f1 49 01 48 	st.w	r8[328],r9
    AVR32_GPIO.port[1].gpers = 0x00000002;
80003e50:	f1 49 01 04 	st.w	r8[260],r9
	
	Disable_global_interrupt();
80003e54:	d3 03       	ssrf	0x10
	
	INTC_register_interrupt (
80003e56:	30 3a       	mov	r10,3
80003e58:	36 0b       	mov	r11,96
80003e5a:	49 4c       	lddpc	r12,80003ea8 <ssc_init+0x64>
80003e5c:	f0 1f 00 14 	mcall	80003eac <ssc_init+0x68>
	&pdca_int_handler
	, AVR32_PDCA_IRQ_0 //PDCA_CHANNEL_SSCRX_EXAMPLE = 0
	, AVR32_INTC_INT3 //highest priority.
	);
	
	Enable_global_interrupt();
80003e60:	d5 03       	csrf	0x10
	
    /*Waits for radio to start making FSYNC.*/
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
80003e62:	fe 79 10 00 	mov	r9,-61440
80003e66:	f2 f8 01 60 	ld.w	r8,r9[352]
80003e6a:	e2 18 00 02 	andl	r8,0x2,COH
80003e6e:	cf c0       	breq	80003e66 <ssc_init+0x22>
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
80003e70:	fe 79 10 00 	mov	r9,-61440
80003e74:	f2 f8 01 60 	ld.w	r8,r9[352]
80003e78:	e2 18 00 02 	andl	r8,0x2,COH
80003e7c:	cf c1       	brne	80003e74 <ssc_init+0x30>
			
	Disable_global_interrupt(); // resume to before
80003e7e:	d3 03       	ssrf	0x10
				
    /*config the SSC*/
    local_start_SSC();
80003e80:	f0 1f 00 0c 	mcall	80003eb0 <ssc_init+0x6c>

    /*config the PDCA*/
    local_start_PDC();
80003e84:	f0 1f 00 0c 	mcall	80003eb4 <ssc_init+0x70>
		
    /*Start the SSC Physical Layer.*/

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80003e88:	fe 79 00 00 	mov	r9,-65536
80003e8c:	30 18       	mov	r8,1
80003e8e:	93 58       	st.w	r9[0x14],r8
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80003e90:	fe 7a 00 40 	mov	r10,-65472
80003e94:	95 58       	st.w	r10[0x14],r8
    (&AVR32_SSC)->cr = AVR32_SSC_CR_RXEN_MASK | AVR32_SSC_CR_TXEN_MASK;
80003e96:	e0 6b 01 01 	mov	r11,257
80003e9a:	fe 7a 34 00 	mov	r10,-52224
80003e9e:	95 0b       	st.w	r10[0x0],r11
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->ier = AVR32_PDCA_RCZ_MASK;
80003ea0:	93 88       	st.w	r9[0x20],r8
															
	Enable_global_interrupt();
80003ea2:	d5 03       	csrf	0x10
															
}/*End of ssc_init.*/
80003ea4:	d8 02       	popm	pc
80003ea6:	00 00       	add	r0,r0
80003ea8:	80 00       	ld.sh	r0,r0[0x0]
80003eaa:	3d 00       	mov	r0,-48
80003eac:	80 00       	ld.sh	r0,r0[0x0]
80003eae:	55 44       	stdsp	sp[0x150],r4
80003eb0:	80 00       	ld.sh	r0,r0[0x0]
80003eb2:	3d 80       	mov	r0,-40
80003eb4:	80 00       	ld.sh	r0,r0[0x0]
80003eb6:	3d c4       	mov	r4,-36

80003eb8 <xcmp_register_app_list>:
Calls: 
Called By: app_init -- app.c
*/
void xcmp_register_app_list(void * list)
{
	app_list = (app_exec_t *)list;
80003eb8:	48 28       	lddpc	r8,80003ec0 <xcmp_register_app_list+0x8>
80003eba:	91 0c       	st.w	r8[0x0],r12
}
80003ebc:	5e fc       	retal	r12
80003ebe:	00 00       	add	r0,r0
80003ec0:	00 00       	add	r0,r0
80003ec2:	51 20       	stdsp	sp[0x48],r0

80003ec4 <xcmp_tx>:
Calls:   
	xnl_tx -- xnl.c
Called By: ...
*/
static void xcmp_tx( xcmp_fragment_t * xcmp, U8 payload_len)
{
80003ec4:	eb cd 40 80 	pushm	r7,lr
80003ec8:	fa cd 01 00 	sub	sp,sp,256
80003ecc:	16 97       	mov	r7,r11
	Length :xnl length + checksum
	= checksum + xnl header + xcmp opcode + xcmp payload
	= 0x02 + 0x0C + 0x02 + xcmp payload
	= 0x10 + xcmp payload
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | ( 0x10 + payload_len);
80003ece:	16 98       	mov	r8,r11
80003ed0:	2f 08       	sub	r8,-16
80003ed2:	af a8       	sbr	r8,0xe
80003ed4:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE; 
80003ed6:	3f f8       	mov	r8,-1
80003ed8:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG;
80003eda:	30 b9       	mov	r9,11
80003edc:	ba 29       	st.h	sp[0x4],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;	
80003ede:	ba 38       	st.h	sp[0x6],r8
	xnl_frame.xnl_header.destination = DEFAULT_VALUE;
80003ee0:	ba 48       	st.h	sp[0x8],r8
	xnl_frame.xnl_header.source = DEFAULT_VALUE;	
80003ee2:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80003ee4:	ba 68       	st.h	sp[0xc],r8
	
	/*insert xcmp frame data*/
	memcpy(&xnl_frame.xnl_payload.xnl_content_data_msg, xcmp, payload_len + 2);
80003ee6:	f6 ca ff fe 	sub	r10,r11,-2
80003eea:	18 9b       	mov	r11,r12
80003eec:	fa cc ff f0 	sub	r12,sp,-16
80003ef0:	f0 1f 00 05 	mcall	80003f04 <xcmp_tx+0x40>
	xnl_frame.xnl_header.payload_length = payload_len + 2;	
80003ef4:	2f e7       	sub	r7,-2
80003ef6:	ba 77       	st.h	sp[0xe],r7
	
	/* send xnl frame*/	
	xnl_tx(&xnl_frame);
80003ef8:	1a 9c       	mov	r12,sp
80003efa:	f0 1f 00 04 	mcall	80003f08 <xcmp_tx+0x44>
}
80003efe:	2c 0d       	sub	sp,-256
80003f00:	e3 cd 80 80 	ldm	sp++,r7,pc
80003f04:	80 00       	ld.sh	r0,r0[0x0]
80003f06:	77 e8       	ld.w	r8,r11[0x78]
80003f08:	80 00       	ld.sh	r0,r0[0x0]
80003f0a:	44 d0       	lddsp	r0,sp[0x134]

80003f0c <xcmp_data_session_req>:
Description: send data-session request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_data_session_req(void *message, U16 length, U8 dest)
{
80003f0c:	d4 21       	pushm	r4-r7,lr
80003f0e:	fa cd 00 d0 	sub	sp,sp,208
80003f12:	18 94       	mov	r4,r12
80003f14:	16 97       	mov	r7,r11
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
	
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
	
	if (length > 256)return -1;
80003f16:	e0 68 01 00 	mov	r8,256
80003f1a:	f0 0b 19 00 	cp.h	r11,r8
80003f1e:	e0 8b 00 36 	brhi	80003f8a <xcmp_data_session_req+0x7e>
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
	
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
80003f22:	fa c5 ff f8 	sub	r5,sp,-8
	//U8 SizeofAddress = Remote_Mototrbo_Address_Size;// 3;//可能会变化
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
80003f26:	e0 68 04 1d 	mov	r8,1053
80003f2a:	ba 38       	st.h	sp[0x6],r8
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
	
	if (length > 256)return -1;
	
	ptr->Function = Single_Data_Uint;
80003f2c:	30 18       	mov	r8,1
80003f2e:	aa 88       	st.b	r5[0x0],r8
	
	ptr->DataDefinition.Data_Protocol_Version = TMP_Ver_1_1;//0x20
80003f30:	32 08       	mov	r8,32
80003f32:	aa 98       	st.b	r5[0x1],r8
	
	ptr->DataDefinition.Dest_Address.Remote_Address_Type = Remote_IPV4_Address;//0x02
80003f34:	30 28       	mov	r8,2
80003f36:	aa a8       	st.b	r5[0x2],r8
	
	ptr->DataDefinition.Dest_Address.Remote_Address_Size = Remote_IPV4_Address_Size;//0x04
80003f38:	30 48       	mov	r8,4
80003f3a:	aa b8       	st.b	r5[0x3],r8
	
	unsigned int addr = 0x0C000000 | (dest & 0x00FFFFFF);
80003f3c:	ea 1a 0c 00 	orh	r10,0xc00
80003f40:	50 0a       	stdsp	sp[0x0],r10
	memcpy(ptr->DataDefinition.Dest_Address.Remote_Address, &addr, Remote_IPV4_Address_Size);
80003f42:	30 4a       	mov	r10,4
80003f44:	1a 9b       	mov	r11,sp
80003f46:	fa cc ff f4 	sub	r12,sp,-12
80003f4a:	f0 1f 00 12 	mcall	80003f90 <xcmp_data_session_req+0x84>
	//ptr->DataDefinition.Dest_Address.Remote_Address[0] = 0x0C;//12
	//ptr->DataDefinition.Dest_Address.Remote_Address[1] = 0x00;//0
	//ptr->DataDefinition.Dest_Address.Remote_Address[2] = 0x00;//0
	//ptr->DataDefinition.Dest_Address.Remote_Address[3] = 0x02;//2
	
	ptr->DataDefinition.Dest_Address.Remote_Port_Com[0] = (Remote_Port >>8) & 0xFF;//4007
80003f4e:	30 f8       	mov	r8,15
80003f50:	eb 68 00 08 	st.b	r5[8],r8
	ptr->DataDefinition.Dest_Address.Remote_Port_Com[1] = Remote_Port & 0xFF;//
80003f54:	3a 78       	mov	r8,-89
80003f56:	eb 68 00 09 	st.b	r5[9],r8
	
    
	ptr->DataPayload.Session_ID_Number = Session_ID;//0x00
80003f5a:	30 08       	mov	r8,0
80003f5c:	eb 68 00 0a 	st.b	r5[10],r8
	
	ptr->DataPayload.DataPayload_Length[0] =(length >> 8) & 0xFF ;//可能会变化
80003f60:	0e 9a       	mov	r10,r7
80003f62:	5c 7a       	castu.h	r10
80003f64:	f4 08 16 08 	lsr	r8,r10,0x8
80003f68:	eb 68 00 0b 	st.b	r5[11],r8
	ptr->DataPayload.DataPayload_Length[1] =length & 0xFF  ;//可能会变化
80003f6c:	0e 96       	mov	r6,r7
80003f6e:	eb 67 00 0c 	st.b	r5[12],r7
	
	memcpy(&(ptr->DataPayload.DataPayload[0]), message, length);
80003f72:	08 9b       	mov	r11,r4
80003f74:	fa cc ff eb 	sub	r12,sp,-21
80003f78:	f0 1f 00 06 	mcall	80003f90 <xcmp_data_session_req+0x84>
	
	xcmp_tx(&xcmp_farme, sizeof(DataSession_req_t) - (256 - length));
80003f7c:	ee cb ff f3 	sub	r11,r7,-13
80003f80:	5c 5b       	castu.b	r11
80003f82:	fa cc ff fa 	sub	r12,sp,-6
80003f86:	f0 1f 00 04 	mcall	80003f94 <xcmp_data_session_req+0x88>
}
80003f8a:	2c cd       	sub	sp,-208
80003f8c:	d8 22       	popm	r4-r7,pc
80003f8e:	00 00       	add	r0,r0
80003f90:	80 00       	ld.sh	r0,r0[0x0]
80003f92:	77 e8       	ld.w	r8,r11[0x78]
80003f94:	80 00       	ld.sh	r0,r0[0x0]
80003f96:	3e c4       	mov	r4,-20

80003f98 <xcmp_DeviceInitializationStatus_request>:
Description: send device initialization status request
Calls: xcmp_tx
Called By:...
*/
void xcmp_DeviceInitializationStatus_request(void)
{
80003f98:	d4 01       	pushm	lr
80003f9a:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
		
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_BRDCAST | DEVICE_INITIALIZATION_STATUS;
80003f9e:	fe 78 b4 00 	mov	r8,-19456
80003fa2:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	DeviceInitializationStatus_brdcst_t * ptr 
						 = (DeviceInitializationStatus_brdcst_t *)xcmp_farme.u8;
80003fa4:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*xcmp version 8.1.0.5*///版本号未正确填写，纠正
	ptr->XCMPVersion[0] = 0x08;
80003fa8:	30 89       	mov	r9,8
80003faa:	b0 89       	st.b	r8[0x0],r9
	ptr->XCMPVersion[1] = 0x01;
80003fac:	30 19       	mov	r9,1
80003fae:	b0 99       	st.b	r8[0x1],r9
	ptr->XCMPVersion[2] = 0x00;
80003fb0:	30 09       	mov	r9,0
80003fb2:	b0 a9       	st.b	r8[0x2],r9
	ptr->XCMPVersion[3] = 0x05;
80003fb4:	30 5a       	mov	r10,5
80003fb6:	b0 ba       	st.b	r8[0x3],r10
	/*
	0x00:
	This is the message that the device sends at power up or after a reset. It 
	will give the initial status and capabilities for the device.
	*/
	ptr->DeviceInitType = 0x00;
80003fb8:	b0 c9       	st.b	r8[0x4],r9
	types of devices may provide a set of services to the radio system, but do 
	not have the ability to be the master.
	
	0x07:OptionBoard,3rd party Option Board-based application.
	*/
	ptr->DeviceStatusInfo.DeviceType = 0x07;
80003fba:	30 7a       	mov	r10,7
80003fbc:	b0 da       	st.b	r8[0x5],r10
	
	/*Power Up Success, Device has powered up with no errors*/
	ptr->DeviceStatusInfo.DeviceStatus[0] = 0x00;
80003fbe:	b0 e9       	st.b	r8[0x6],r9
	ptr->DeviceStatusInfo.DeviceStatus[1] = 0x00;
80003fc0:	b0 f9       	st.b	r8[0x7],r9
	
	/*
	This number is the size of the Device Descriptor data structure with a 
	maximum size not exceeding 255 bytes.
	*/
	ptr->DeviceStatusInfo.DeviceDescriptorSize = 0x00;
80003fc2:	f1 69 00 08 	st.b	r8[8],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme
80003fc6:	30 9b       	mov	r11,9
80003fc8:	fa cc ff fe 	sub	r12,sp,-2
80003fcc:	f0 1f 00 02 	mcall	80003fd4 <xcmp_DeviceInitializationStatus_request+0x3c>
		, sizeof(DeviceInitializationStatus_brdcst_t) - MAX_DEVICE_DESC_SIZE);
}
80003fd0:	2c dd       	sub	sp,-204
80003fd2:	d8 02       	popm	pc
80003fd4:	80 00       	ld.sh	r0,r0[0x0]
80003fd6:	3e c4       	mov	r4,-20

80003fd8 <xcmp_opcode_not_supported>:
Description: register the app list
Calls: xcmp_tx
Called By:...
*/
void xcmp_opcode_not_supported( void )
{
80003fd8:	d4 01       	pushm	lr
80003fda:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REPLY;
80003fde:	fe 78 80 00 	mov	r8,-32768
80003fe2:	ba 18       	st.h	sp[0x2],r8
	
	/*The radio does not support this opcode.*/
	xcmp_farme.u8[0] = xcmp_Res_Opcode_Not_Supported;
80003fe4:	30 38       	mov	r8,3
80003fe6:	ba c8       	st.b	sp[0x4],r8
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, 1);
80003fe8:	30 1b       	mov	r11,1
80003fea:	fa cc ff fe 	sub	r12,sp,-2
80003fee:	f0 1f 00 03 	mcall	80003ff8 <xcmp_opcode_not_supported+0x20>
}
80003ff2:	2c dd       	sub	sp,-204
80003ff4:	d8 02       	popm	pc
80003ff6:	00 00       	add	r0,r0
80003ff8:	80 00       	ld.sh	r0,r0[0x0]
80003ffa:	3e c4       	mov	r4,-20

80003ffc <xcmp_exec_func>:
Description: Perform XCMP corresponding functions
Calls:   
Called By: xcmp_rx_process--task
*/
static void xcmp_exec_func(app_exec_t * exec, xcmp_fragment_t * xcmp)
{
80003ffc:	d4 01       	pushm	lr
	/*The message types*/
	switch(xcmp->xcmp_opcode & 0xF000)
80003ffe:	96 88       	ld.uh	r8,r11[0x0]
80004000:	e2 18 f0 00 	andl	r8,0xf000,COH
80004004:	e0 48 80 00 	cp.w	r8,32768
80004008:	c0 f0       	breq	80004026 <xcmp_exec_func+0x2a>
8000400a:	e0 48 b0 00 	cp.w	r8,45056
8000400e:	c1 20       	breq	80004032 <xcmp_exec_func+0x36>
80004010:	58 08       	cp.w	r8,0
80004012:	c1 51       	brne	8000403c <xcmp_exec_func+0x40>
	{
		case XCMP_REQUEST:
			if(NULL != exec->xcmp_rx_req)
80004014:	78 08       	ld.w	r8,r12[0x0]
80004016:	58 08       	cp.w	r8,0
80004018:	c0 40       	breq	80004020 <xcmp_exec_func+0x24>
			{
				exec->xcmp_rx_req(xcmp);
8000401a:	16 9c       	mov	r12,r11
8000401c:	5d 18       	icall	r8
8000401e:	d8 02       	popm	pc
			}
			else 
			{
				/*No function to register the request message*/
				/*send not supported opcode to raido */
				xcmp_opcode_not_supported();
80004020:	f0 1f 00 08 	mcall	80004040 <xcmp_exec_func+0x44>
80004024:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_REPLY:		
			if(NULL != exec->xcmp_rx_reply)
80004026:	78 18       	ld.w	r8,r12[0x4]
80004028:	58 08       	cp.w	r8,0
8000402a:	c0 90       	breq	8000403c <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_reply(xcmp);
8000402c:	16 9c       	mov	r12,r11
8000402e:	5d 18       	icall	r8
80004030:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_BRDCAST:	
			if(NULL != exec->xcmp_rx_brdcst)
80004032:	78 28       	ld.w	r8,r12[0x8]
80004034:	58 08       	cp.w	r8,0
80004036:	c0 30       	breq	8000403c <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_brdcst(xcmp);
80004038:	16 9c       	mov	r12,r11
8000403a:	5d 18       	icall	r8
8000403c:	d8 02       	popm	pc
8000403e:	00 00       	add	r0,r0
80004040:	80 00       	ld.sh	r0,r0[0x0]
80004042:	3f d8       	mov	r8,-3

80004044 <xcmp_IdleTestTone>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_IdleTestTone(U8 type, U16 toneID)
{
80004044:	d4 01       	pushm	lr
80004046:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | TONE_CONTROL;
8000404a:	e0 68 04 09 	mov	r8,1033
8000404e:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	ToneControl_req_t * ptr = (ToneControl_req_t *)xcmp_farme.u8;
80004050:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*Starts the specific tone*/	
	ptr->Function = type;
80004054:	b0 8c       	st.b	r8[0x0],r12
	
	/*This tone shall be sounded when radio landed on a priority channel*/
	//ptr->ToneIdentifier[0] = (Priority_Beep >> 8) & 0xFF;
	//ptr->ToneIdentifier[1] = Priority_Beep & 0xFF;
	
	ptr->ToneIdentifier[0] = (toneID >> 8) & 0xFF;
80004056:	f3 db c1 08 	bfextu	r9,r11,0x8,0x8
8000405a:	b0 99       	st.b	r8[0x1],r9
	ptr->ToneIdentifier[1] = toneID & 0xFF;	
8000405c:	b0 ab       	st.b	r8[0x2],r11
	
	/*
	The alert tone is played according to any rules for alert tones, given the 
	current volume setting. Settings for this field are 8 to 255 (0x08 ?0xFF).
	*/
	ptr->ToneVolumeControl = Current_Volume;
8000405e:	30 09       	mov	r9,0
80004060:	b0 b9       	st.b	r8[0x3],r9
	
	/*clear reserved*/
	memset(ptr->Reserved, 0, 8);
80004062:	fb 69 00 08 	st.b	sp[8],r9
80004066:	fa c8 ff f7 	sub	r8,sp,-9
8000406a:	b0 89       	st.b	r8[0x0],r9
8000406c:	fa c8 ff f6 	sub	r8,sp,-10
80004070:	b0 89       	st.b	r8[0x0],r9
80004072:	fa c8 ff f5 	sub	r8,sp,-11
80004076:	b0 89       	st.b	r8[0x0],r9
80004078:	fa c8 ff f4 	sub	r8,sp,-12
8000407c:	b0 89       	st.b	r8[0x0],r9
8000407e:	fa c8 ff f3 	sub	r8,sp,-13
80004082:	b0 89       	st.b	r8[0x0],r9
80004084:	fa c8 ff f2 	sub	r8,sp,-14
80004088:	b0 89       	st.b	r8[0x0],r9
8000408a:	fa c8 ff f1 	sub	r8,sp,-15
8000408e:	b0 89       	st.b	r8[0x0],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(ToneControl_req_t));
80004090:	30 cb       	mov	r11,12
80004092:	fa cc ff fe 	sub	r12,sp,-2
80004096:	f0 1f 00 03 	mcall	800040a0 <xcmp_IdleTestTone+0x5c>
}
8000409a:	2c dd       	sub	sp,-204
8000409c:	d8 02       	popm	pc
8000409e:	00 00       	add	r0,r0
800040a0:	80 00       	ld.sh	r0,r0[0x0]
800040a2:	3e c4       	mov	r4,-20

800040a4 <xcmp_init>:
	xQueueCreate -- freertos
	xTaskCreate -- freertos
Called By: main -- main.c
*/
void xcmp_init(void)
{
800040a4:	d4 01       	pushm	lr
	/*register the xcmp function(callback function)*/
	xnl_register_xcmp_func( xcmp_rx );
800040a6:	48 dc       	lddpc	r12,800040d8 <xcmp_init+0x34>
800040a8:	f0 1f 00 0d 	mcall	800040dc <xcmp_init+0x38>
	
	/*initialize the queue*/
	xcmp_frame_rx = xQueueCreate(20, sizeof(xcmp_fragment_t *));
800040ac:	30 4b       	mov	r11,4
800040ae:	31 4c       	mov	r12,20
800040b0:	f0 1f 00 0c 	mcall	800040e0 <xcmp_init+0x3c>
800040b4:	48 c8       	lddpc	r8,800040e4 <xcmp_init+0x40>
800040b6:	91 0c       	st.w	r8[0x0],r12
	/*create task*/	
	/*this task is used to execute xcmp message*/
	xTaskCreate(
800040b8:	30 09       	mov	r9,0
800040ba:	1a d9       	st.w	--sp,r9
800040bc:	1a d9       	st.w	--sp,r9
800040be:	1a d9       	st.w	--sp,r9
800040c0:	30 38       	mov	r8,3
800040c2:	e0 6a 04 00 	mov	r10,1024
800040c6:	48 9b       	lddpc	r11,800040e8 <xcmp_init+0x44>
800040c8:	48 9c       	lddpc	r12,800040ec <xcmp_init+0x48>
800040ca:	f0 1f 00 0a 	mcall	800040f0 <xcmp_init+0x4c>
	,  tskXCMP_PRIORITY
	,  NULL
	);
	
	/*initialize the xnl*/
	xnl_init();
800040ce:	f0 1f 00 0a 	mcall	800040f4 <xcmp_init+0x50>
800040d2:	2f dd       	sub	sp,-12
	
}
800040d4:	d8 02       	popm	pc
800040d6:	00 00       	add	r0,r0
800040d8:	80 00       	ld.sh	r0,r0[0x0]
800040da:	41 f4       	lddsp	r4,sp[0x7c]
800040dc:	80 00       	ld.sh	r0,r0[0x0]
800040de:	42 40       	lddsp	r0,sp[0x90]
800040e0:	80 00       	ld.sh	r0,r0[0x0]
800040e2:	64 8c       	ld.w	r12,r2[0x20]
800040e4:	00 00       	add	r0,r0
800040e6:	0b 0c       	ld.w	r12,r5++
800040e8:	80 00       	ld.sh	r0,r0[0x0]
800040ea:	d8 38       	*unknown*
800040ec:	80 00       	ld.sh	r0,r0[0x0]
800040ee:	40 f8       	lddsp	r8,sp[0x3c]
800040f0:	80 00       	ld.sh	r0,r0[0x0]
800040f2:	6b a8       	ld.w	r8,r5[0x68]
800040f4:	80 00       	ld.sh	r0,r0[0x0]
800040f6:	42 78       	lddsp	r8,sp[0x9c]

800040f8 <xcmp_rx_process>:
Calls: xQueueReceive -- freerots
	xcmp_exec_func
Called By: task
*/
static void xcmp_rx_process(void * pvParameters)
{
800040f8:	d4 31       	pushm	r0-r7,lr
800040fa:	20 1d       	sub	sp,4
	xcmp_fragment_t * ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
800040fc:	4b 16       	lddpc	r6,800041c0 <xcmp_rx_process+0xc8>
800040fe:	30 05       	mov	r5,0
80004100:	31 44       	mov	r4,20
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
80004102:	4b 13       	lddpc	r3,800041c4 <xcmp_rx_process+0xcc>
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
					break;
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
80004104:	4b 12       	lddpc	r2,800041c8 <xcmp_rx_process+0xd0>
						, ptr);
					break;
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
80004106:	4b 21       	lddpc	r1,800041cc <xcmp_rx_process+0xd4>
					break;
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
80004108:	4b 20       	lddpc	r0,800041d0 <xcmp_rx_process+0xd8>
	xcmp_fragment_t * ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
8000410a:	6c 0c       	ld.w	r12,r6[0x0]
8000410c:	0a 99       	mov	r9,r5
8000410e:	08 9a       	mov	r10,r4
80004110:	1a 9b       	mov	r11,sp
80004112:	f0 1f 00 31 	mcall	800041d4 <xcmp_rx_process+0xdc>
80004116:	58 1c       	cp.w	r12,1
80004118:	cf 91       	brne	8000410a <xcmp_rx_process+0x12>
		{									
			if(NULL == ptr)
8000411a:	40 0b       	lddsp	r11,sp[0x0]
8000411c:	58 0b       	cp.w	r11,0
8000411e:	cf 60       	breq	8000410a <xcmp_rx_process+0x12>
			
			//log("\n\r R_xcmp : %4x \n\r",ptr->xcmp_opcode);//log:R_xcmp指令	
			//static  portTickType water_value;
			//water_value = uxTaskGetStackHighWaterMark(NULL);
			//log("water_value: %d\n", water_value);			
			switch(ptr->xcmp_opcode & 0x0FFF)
80004120:	96 0a       	ld.sh	r10,r11[0x0]
80004122:	f3 da c0 10 	bfextu	r9,r10,0x0,0x10
80004126:	f1 d9 c0 0c 	bfextu	r8,r9,0x0,0xc
8000412a:	59 c8       	cp.w	r8,28
8000412c:	c1 e0       	breq	80004168 <xcmp_rx_process+0x70>
8000412e:	e0 89 00 07 	brgt	8000413c <xcmp_rx_process+0x44>
80004132:	58 e8       	cp.w	r8,14
80004134:	c0 e0       	breq	80004150 <xcmp_rx_process+0x58>
80004136:	58 f8       	cp.w	r8,15
80004138:	c2 41       	brne	80004180 <xcmp_rx_process+0x88>
8000413a:	c0 f8       	rjmp	80004158 <xcmp_rx_process+0x60>
8000413c:	e0 48 01 09 	cp.w	r8,265
80004140:	c1 80       	breq	80004170 <xcmp_rx_process+0x78>
80004142:	e0 48 01 0a 	cp.w	r8,266
80004146:	c1 90       	breq	80004178 <xcmp_rx_process+0x80>
80004148:	e0 48 00 2c 	cp.w	r8,44
8000414c:	c1 a1       	brne	80004180 <xcmp_rx_process+0x88>
8000414e:	c0 98       	rjmp	80004160 <xcmp_rx_process+0x68>
			{
				case RADIO_STATUS:				
					xcmp_exec_func(&radio_status, ptr);
80004150:	4a 2c       	lddpc	r12,800041d8 <xcmp_rx_process+0xe0>
80004152:	f0 1f 00 23 	mcall	800041dc <xcmp_rx_process+0xe4>
					break;
80004156:	c2 f8       	rjmp	800041b4 <xcmp_rx_process+0xbc>
					
				case VERSION_INFORMATION:
					xcmp_exec_func(&version_information, ptr);
80004158:	4a 2c       	lddpc	r12,800041e0 <xcmp_rx_process+0xe8>
8000415a:	f0 1f 00 21 	mcall	800041dc <xcmp_rx_process+0xe4>
					break;
8000415e:	c2 b8       	rjmp	800041b4 <xcmp_rx_process+0xbc>
					
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
80004160:	4a 1c       	lddpc	r12,800041e4 <xcmp_rx_process+0xec>
80004162:	f0 1f 00 1f 	mcall	800041dc <xcmp_rx_process+0xe4>
					break;
80004166:	c2 78       	rjmp	800041b4 <xcmp_rx_process+0xbc>
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
80004168:	04 9c       	mov	r12,r2
8000416a:	f0 1f 00 1d 	mcall	800041dc <xcmp_rx_process+0xe4>
						, ptr);
					break;
8000416e:	c2 38       	rjmp	800041b4 <xcmp_rx_process+0xbc>
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
80004170:	02 9c       	mov	r12,r1
80004172:	f0 1f 00 1b 	mcall	800041dc <xcmp_rx_process+0xe4>
					break;
80004176:	c1 f8       	rjmp	800041b4 <xcmp_rx_process+0xbc>
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
80004178:	00 9c       	mov	r12,r0
8000417a:	f0 1f 00 19 	mcall	800041dc <xcmp_rx_process+0xe4>
					break;
8000417e:	c1 b8       	rjmp	800041b4 <xcmp_rx_process+0xbc>
					
				default:
				
					/*the xcmp message not in order list*/
					/*over the length of the list*/
					if((0x0400 != (ptr->xcmp_opcode & 0x0400)) 
80004180:	12 98       	mov	r8,r9
80004182:	e2 18 04 00 	andl	r8,0x400,COH
80004186:	c0 70       	breq	80004194 <xcmp_rx_process+0x9c>
80004188:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
8000418c:	e0 48 00 68 	cp.w	r8,104
80004190:	e0 8a 00 08 	brle	800041a0 <xcmp_rx_process+0xa8>
						|| (MAX_APP_FUNC <= (ptr->xcmp_opcode & 0x00FF))
					)
					{
						/*xcmp request*/
						if( XCMP_REQUEST == (ptr->xcmp_opcode & 0xF000))
80004194:	e2 19 f0 00 	andl	r9,0xf000,COH
80004198:	c0 e1       	brne	800041b4 <xcmp_rx_process+0xbc>
						{
							/*send not supported opcode to raido */
							xcmp_opcode_not_supported();
8000419a:	f0 1f 00 14 	mcall	800041e8 <xcmp_rx_process+0xf0>
8000419e:	c0 b8       	rjmp	800041b4 <xcmp_rx_process+0xbc>
						}
					}
					else
					{					
						xcmp_exec_func( &app_list[ptr->xcmp_opcode & 0x00FF]
800041a0:	f9 da c0 08 	bfextu	r12,r10,0x0,0x8
800041a4:	f8 0c 00 1c 	add	r12,r12,r12<<0x1
800041a8:	49 19       	lddpc	r9,800041ec <xcmp_rx_process+0xf4>
800041aa:	72 08       	ld.w	r8,r9[0x0]
800041ac:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800041b0:	f0 1f 00 0b 	mcall	800041dc <xcmp_rx_process+0xe4>
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
800041b4:	66 0c       	ld.w	r12,r3[0x0]
800041b6:	40 0b       	lddsp	r11,sp[0x0]
800041b8:	f0 1f 00 0e 	mcall	800041f0 <xcmp_rx_process+0xf8>
800041bc:	ca 7b       	rjmp	8000410a <xcmp_rx_process+0x12>
800041be:	00 00       	add	r0,r0
800041c0:	00 00       	add	r0,r0
800041c2:	0b 0c       	ld.w	r12,r5++
800041c4:	00 00       	add	r0,r0
800041c6:	0a a4       	st.w	r5++,r4
800041c8:	00 00       	add	r0,r0
800041ca:	0b 1c       	ld.sh	r12,r5++
800041cc:	00 00       	add	r0,r0
800041ce:	0b 10       	ld.sh	r0,r5++
800041d0:	00 00       	add	r0,r0
800041d2:	0b 00       	ld.w	r0,r5++
800041d4:	80 00       	ld.sh	r0,r0[0x0]
800041d6:	61 28       	ld.w	r8,r0[0x48]
800041d8:	00 00       	add	r0,r0
800041da:	0b 34       	ld.ub	r4,r5++
800041dc:	80 00       	ld.sh	r0,r0[0x0]
800041de:	3f fc       	mov	r12,-1
800041e0:	00 00       	add	r0,r0
800041e2:	0a f4       	st.b	--r5,r4
800041e4:	00 00       	add	r0,r0
800041e6:	0b 28       	ld.uh	r8,r5++
800041e8:	80 00       	ld.sh	r0,r0[0x0]
800041ea:	3f d8       	mov	r8,-3
800041ec:	00 00       	add	r0,r0
800041ee:	51 20       	stdsp	sp[0x48],r0
800041f0:	80 00       	ld.sh	r0,r0[0x0]
800041f2:	2b e0       	sub	r0,-66

800041f4 <xcmp_rx>:
Calls:   
	xQueueSend -- xnl.c
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
800041f4:	eb cd 40 90 	pushm	r4,r7,lr
800041f8:	20 1d       	sub	sp,4
800041fa:	fa c4 ff f0 	sub	r4,sp,-16
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
800041fe:	48 c8       	lddpc	r8,8000422c <xcmp_rx+0x38>
80004200:	70 0c       	ld.w	r12,r8[0x0]
80004202:	f0 1f 00 0c 	mcall	80004230 <xcmp_rx+0x3c>
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
80004206:	c1 00       	breq	80004226 <xcmp_rx+0x32>
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
80004208:	fa c7 ff fc 	sub	r7,sp,-4
8000420c:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
	{
		memcpy(xcmp_ptr, &xcmp, sizeof(xcmp_fragment_t));				
8000420e:	e0 6a 00 ca 	mov	r10,202
80004212:	08 9b       	mov	r11,r4
80004214:	f0 1f 00 08 	mcall	80004234 <xcmp_rx+0x40>
		xQueueSend(xcmp_frame_rx, &xcmp_ptr, 0);	
80004218:	48 88       	lddpc	r8,80004238 <xcmp_rx+0x44>
8000421a:	70 0c       	ld.w	r12,r8[0x0]
8000421c:	30 09       	mov	r9,0
8000421e:	12 9a       	mov	r10,r9
80004220:	1a 9b       	mov	r11,sp
80004222:	f0 1f 00 07 	mcall	8000423c <xcmp_rx+0x48>
	}	
}
80004226:	2f fd       	sub	sp,-4
80004228:	e3 cd 80 90 	ldm	sp++,r4,r7,pc
8000422c:	00 00       	add	r0,r0
8000422e:	0a a4       	st.w	r5++,r4
80004230:	80 00       	ld.sh	r0,r0[0x0]
80004232:	2d 8c       	sub	r12,-40
80004234:	80 00       	ld.sh	r0,r0[0x0]
80004236:	77 e8       	ld.w	r8,r11[0x78]
80004238:	00 00       	add	r0,r0
8000423a:	0b 0c       	ld.w	r12,r5++
8000423c:	80 00       	ld.sh	r0,r0[0x0]
8000423e:	63 34       	ld.w	r4,r1[0x4c]

80004240 <xnl_register_xcmp_func>:
Function: xnl_register_xcmp_func
Description: register the xcmp function(callback function)
*/
void xnl_register_xcmp_func( void ( *func)(xnl_content_data_msg_t))
{
	 xcmp_exec = func;
80004240:	48 28       	lddpc	r8,80004248 <xnl_register_xcmp_func+0x8>
80004242:	91 0c       	st.w	r8[0x0],r12
}
80004244:	5e fc       	retal	r12
80004246:	00 00       	add	r0,r0
80004248:	00 00       	add	r0,r0
8000424a:	0b 60       	ld.uh	r0,--r5

8000424c <xnl_get_msg_ack_func>:
Description: process while receive msg ack.
Calls:xSemaphoreGive--freertos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
8000424c:	d4 01       	pushm	lr
	
	DestinationAddress = xnl->xnl_header.destination;
	/*No timeout*/		
	 //One relationship is controlled by a state machine, only the current MSG received the ACK, 
	//then the program will clear the current MSG sending address and out of standby and will jump to the sending state.
	if (DestinationAddress == xnl_information.device_address )
8000424e:	48 88       	lddpc	r8,8000426c <xnl_get_msg_ack_func+0x20>
80004250:	90 28       	ld.sh	r8,r8[0x4]
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
	U16 DestinationAddress;
	U16 TransactionID;
	
	DestinationAddress = xnl->xnl_header.destination;
80004252:	98 49       	ld.sh	r9,r12[0x8]
80004254:	f0 09 19 00 	cp.h	r9,r8
80004258:	c0 81       	brne	80004268 <xnl_get_msg_ack_func+0x1c>
	if (DestinationAddress == xnl_information.device_address )
	{
		//The ack is for me.
		
		TransactionID = xnl->xnl_header.transaction_id;
		xSemaphoreGive(xnl_timeout_semphr);	
8000425a:	48 68       	lddpc	r8,80004270 <xnl_get_msg_ack_func+0x24>
8000425c:	70 0c       	ld.w	r12,r8[0x0]
8000425e:	30 09       	mov	r9,0
80004260:	12 9a       	mov	r10,r9
80004262:	12 9b       	mov	r11,r9
80004264:	f0 1f 00 04 	mcall	80004274 <xnl_get_msg_ack_func+0x28>
80004268:	d8 02       	popm	pc
8000426a:	00 00       	add	r0,r0
8000426c:	00 00       	add	r0,r0
8000426e:	0b 46       	ld.w	r6,--r5
80004270:	00 00       	add	r0,r0
80004272:	0b 40       	ld.w	r0,--r5
80004274:	80 00       	ld.sh	r0,r0[0x0]
80004276:	63 34       	ld.w	r4,r1[0x4c]

80004278 <xnl_init>:
	xTaskCreate--freertos
	xnl_send_device_master_query
Called By:xcmp_init -- xcmp.c
*/
void xnl_init(void)
{
80004278:	eb cd 40 e0 	pushm	r5-r7,lr
	
	xnl_information.is_connected = FALSE;
8000427c:	30 09       	mov	r9,0
8000427e:	4b 78       	lddpc	r8,80004358 <xnl_init+0xe0>
80004280:	b0 89       	st.b	r8[0x0],r9

	/*initialize the semaphore and queue*/
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
80004282:	30 0b       	mov	r11,0
80004284:	30 1c       	mov	r12,1
80004286:	f0 1f 00 36 	mcall	8000435c <xnl_init+0xe4>
8000428a:	4b 68       	lddpc	r8,80004360 <xnl_init+0xe8>
8000428c:	91 0c       	st.w	r8[0x0],r12
8000428e:	70 08       	ld.w	r8,r8[0x0]
80004290:	58 08       	cp.w	r8,0
80004292:	c0 80       	breq	800042a2 <xnl_init+0x2a>
80004294:	4b 38       	lddpc	r8,80004360 <xnl_init+0xe8>
80004296:	70 0c       	ld.w	r12,r8[0x0]
80004298:	30 09       	mov	r9,0
8000429a:	12 9a       	mov	r10,r9
8000429c:	12 9b       	mov	r11,r9
8000429e:	f0 1f 00 32 	mcall	80004364 <xnl_init+0xec>
	
	xnl_frame_tx = xQueueCreate(20, sizeof(xnl_fragment_t *)); //扩大xnl_frame_tx的队列深度
800042a2:	30 4b       	mov	r11,4
800042a4:	31 4c       	mov	r12,20
800042a6:	f0 1f 00 2e 	mcall	8000435c <xnl_init+0xe4>
800042aa:	4b 08       	lddpc	r8,80004368 <xnl_init+0xf0>
800042ac:	91 0c       	st.w	r8[0x0],r12
		
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
800042ae:	30 4b       	mov	r11,4
800042b0:	31 ec       	mov	r12,30
800042b2:	f0 1f 00 2b 	mcall	8000435c <xnl_init+0xe4>
800042b6:	4a e8       	lddpc	r8,8000436c <xnl_init+0xf4>
800042b8:	91 0c       	st.w	r8[0x0],r12
800042ba:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_XNL_STORE; i++ )
	{
		set_xnl_idle(&xnl_store[i]);
800042bc:	10 96       	mov	r6,r8
800042be:	4a d5       	lddpc	r5,80004370 <xnl_init+0xf8>
800042c0:	6c 0c       	ld.w	r12,r6[0x0]
800042c2:	ea 07 00 0b 	add	r11,r5,r7
800042c6:	f0 1f 00 2c 	mcall	80004374 <xnl_init+0xfc>
800042ca:	ee c7 ff 00 	sub	r7,r7,-256
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
	
	xnl_frame_tx = xQueueCreate(20, sizeof(xnl_fragment_t *)); //扩大xnl_frame_tx的队列深度
		
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
	for(int i= 0; i < MAX_XNL_STORE; i++ )
800042ce:	e0 47 1e 00 	cp.w	r7,7680
800042d2:	cf 71       	brne	800042c0 <xnl_init+0x48>
	{
		set_xnl_idle(&xnl_store[i]);
	}
	
	/*initialize the queue to send/receive xnl packet */
	phy_xnl_frame_tx = xQueueCreate(TX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
800042d4:	30 4b       	mov	r11,4
800042d6:	31 4c       	mov	r12,20
800042d8:	f0 1f 00 21 	mcall	8000435c <xnl_init+0xe4>
800042dc:	4a 78       	lddpc	r8,80004378 <xnl_init+0x100>
800042de:	91 0c       	st.w	r8[0x0],r12
	phy_xnl_frame_rx = xQueueCreate(RX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
800042e0:	30 4b       	mov	r11,4
800042e2:	30 ac       	mov	r12,10
800042e4:	f0 1f 00 1e 	mcall	8000435c <xnl_init+0xe4>
800042e8:	4a 58       	lddpc	r8,8000437c <xnl_init+0x104>
800042ea:	91 0c       	st.w	r8[0x0],r12
	
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
800042ec:	30 4b       	mov	r11,4
800042ee:	30 ac       	mov	r12,10
800042f0:	f0 1f 00 1b 	mcall	8000435c <xnl_init+0xe4>
800042f4:	4a 38       	lddpc	r8,80004380 <xnl_init+0x108>
800042f6:	91 0c       	st.w	r8[0x0],r12
800042f8:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
	{
		set_payload_idle(payload_store[i]);
800042fa:	10 96       	mov	r6,r8
800042fc:	4a 25       	lddpc	r5,80004384 <xnl_init+0x10c>
800042fe:	6c 0c       	ld.w	r12,r6[0x0]
80004300:	ea 07 00 0b 	add	r11,r5,r7
80004304:	f0 1f 00 1c 	mcall	80004374 <xnl_init+0xfc>
80004308:	ee c7 fe 00 	sub	r7,r7,-512
	
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
8000430c:	e0 47 14 00 	cp.w	r7,5120
80004310:	cf 71       	brne	800042fe <xnl_init+0x86>
	
	/*initialize the queue to send/receive payload packet */
	//phy_payload_frame_tx =
	//xQueueCreate(TX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t));
	
	phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
80004312:	30 4b       	mov	r11,4
80004314:	30 5c       	mov	r12,5
80004316:	f0 1f 00 12 	mcall	8000435c <xnl_init+0xe4>
8000431a:	49 c8       	lddpc	r8,80004388 <xnl_init+0x110>
8000431c:	91 0c       	st.w	r8[0x0],r12
	
	#endif /*end if*/
		
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
8000431e:	30 07       	mov	r7,0
80004320:	1a d7       	st.w	--sp,r7
80004322:	1a d7       	st.w	--sp,r7
80004324:	1a d7       	st.w	--sp,r7
80004326:	30 38       	mov	r8,3
80004328:	0e 99       	mov	r9,r7
8000432a:	e0 6a 00 dc 	mov	r10,220
8000432e:	49 8b       	lddpc	r11,8000438c <xnl_init+0x114>
80004330:	49 8c       	lddpc	r12,80004390 <xnl_init+0x118>
80004332:	f0 1f 00 19 	mcall	80004394 <xnl_init+0x11c>
	,  tskXNL_PRIORITY //+ 1
	,  NULL
	);
	
	/*this task is used to send xnl message*/
	xTaskCreate(
80004336:	1a d7       	st.w	--sp,r7
80004338:	1a d7       	st.w	--sp,r7
8000433a:	1a d7       	st.w	--sp,r7
8000433c:	30 38       	mov	r8,3
8000433e:	0e 99       	mov	r9,r7
80004340:	e0 6a 00 82 	mov	r10,130
80004344:	49 5b       	lddpc	r11,80004398 <xnl_init+0x120>
80004346:	49 6c       	lddpc	r12,8000439c <xnl_init+0x124>
80004348:	f0 1f 00 13 	mcall	80004394 <xnl_init+0x11c>
	,  tskXNL_PRIORITY//+1
	,  NULL
	);
	
	/*initialize the physical layer*/
	phy_init();
8000434c:	f0 1f 00 15 	mcall	800043a0 <xnl_init+0x128>
80004350:	2f ad       	sub	sp,-24
}
80004352:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80004356:	00 00       	add	r0,r0
80004358:	00 00       	add	r0,r0
8000435a:	0b 46       	ld.w	r6,--r5
8000435c:	80 00       	ld.sh	r0,r0[0x0]
8000435e:	64 8c       	ld.w	r12,r2[0x20]
80004360:	00 00       	add	r0,r0
80004362:	0b 40       	ld.w	r0,--r5
80004364:	80 00       	ld.sh	r0,r0[0x0]
80004366:	63 34       	ld.w	r4,r1[0x4c]
80004368:	00 00       	add	r0,r0
8000436a:	0b 54       	ld.sh	r4,--r5
8000436c:	00 00       	add	r0,r0
8000436e:	0a a4       	st.w	r5++,r4
80004370:	00 00       	add	r0,r0
80004372:	32 d2       	mov	r2,45
80004374:	80 00       	ld.sh	r0,r0[0x0]
80004376:	2b e0       	sub	r0,-66
80004378:	00 00       	add	r0,r0
8000437a:	0a d4       	st.w	--r5,r4
8000437c:	00 00       	add	r0,r0
8000437e:	0a b4       	st.h	r5++,r4
80004380:	00 00       	add	r0,r0
80004382:	0a a8       	st.w	r5++,r8
80004384:	00 00       	add	r0,r0
80004386:	1e d2       	st.w	--pc,r2
80004388:	00 00       	add	r0,r0
8000438a:	0a e0       	st.h	--r5,r0
8000438c:	80 00       	ld.sh	r0,r0[0x0]
8000438e:	d8 40       	acall	0x84
80004390:	80 00       	ld.sh	r0,r0[0x0]
80004392:	43 a4       	lddsp	r4,sp[0xe8]
80004394:	80 00       	ld.sh	r0,r0[0x0]
80004396:	6b a8       	ld.w	r8,r5[0x68]
80004398:	80 00       	ld.sh	r0,r0[0x0]
8000439a:	d8 48       	*unknown*
8000439c:	80 00       	ld.sh	r0,r0[0x0]
8000439e:	44 04       	lddsp	r4,sp[0x100]
800043a0:	80 00       	ld.sh	r0,r0[0x0]
800043a2:	2d b4       	sub	r4,-37

800043a4 <xnl_rx_process>:
Calls: 
Called By:task
*/
//portTickType water_value =0;
static void xnl_rx_process(void * pvParameters)
{
800043a4:	eb cd 40 fe 	pushm	r1-r7,lr
800043a8:	20 1d       	sub	sp,4
	xnl_fragment_t * xnl_ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
800043aa:	49 26       	lddpc	r6,800043f0 <xnl_rx_process+0x4c>
800043ac:	30 05       	mov	r5,0
800043ae:	3f f4       	mov	r4,-1
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
800043b0:	30 c3       	mov	r3,12
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
800043b2:	49 11       	lddpc	r1,800043f4 <xnl_rx_process+0x50>
	if(xnl->xnl_header.opcode > 0x0C)	
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
800043b4:	49 12       	lddpc	r2,800043f8 <xnl_rx_process+0x54>
	xnl_fragment_t * xnl_ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
800043b6:	6c 0c       	ld.w	r12,r6[0x0]
800043b8:	0a 99       	mov	r9,r5
800043ba:	08 9a       	mov	r10,r4
800043bc:	1a 9b       	mov	r11,sp
800043be:	f0 1f 00 10 	mcall	800043fc <xnl_rx_process+0x58>
800043c2:	58 1c       	cp.w	r12,1
800043c4:	cf 91       	brne	800043b6 <xnl_rx_process+0x12>
		, portMAX_DELAY ))
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
800043c6:	40 0c       	lddsp	r12,sp[0x0]
800043c8:	58 0c       	cp.w	r12,0
800043ca:	cf 60       	breq	800043b6 <xnl_rx_process+0x12>
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
800043cc:	98 28       	ld.sh	r8,r12[0x4]
800043ce:	e6 08 19 00 	cp.h	r8,r3
800043d2:	e0 8b 00 0a 	brhi	800043e6 <xnl_rx_process+0x42>
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
800043d6:	5c 78       	castu.h	r8
800043d8:	e4 08 03 29 	ld.w	r9,r2[r8<<0x2]
800043dc:	58 09       	cp.w	r9,0
800043de:	c0 40       	breq	800043e6 <xnl_rx_process+0x42>
	{
		//log("\n\r R_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:R_xnl指令
		/*execute the function in list*/
		xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec(xnl);
800043e0:	e4 08 03 28 	ld.w	r8,r2[r8<<0x2]
800043e4:	5d 18       	icall	r8
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
800043e6:	62 0c       	ld.w	r12,r1[0x0]
800043e8:	40 0b       	lddsp	r11,sp[0x0]
800043ea:	f0 1f 00 06 	mcall	80004400 <xnl_rx_process+0x5c>
800043ee:	ce 4b       	rjmp	800043b6 <xnl_rx_process+0x12>
800043f0:	00 00       	add	r0,r0
800043f2:	0a b4       	st.h	r5++,r4
800043f4:	00 00       	add	r0,r0
800043f6:	0a a4       	st.w	r5++,r4
800043f8:	00 00       	add	r0,r0
800043fa:	04 f4       	st.b	--r2,r4
800043fc:	80 00       	ld.sh	r0,r0[0x0]
800043fe:	61 28       	ld.w	r8,r0[0x48]
80004400:	80 00       	ld.sh	r0,r0[0x0]
80004402:	2b e0       	sub	r0,-66

80004404 <xnl_tx_process>:
	phy_tx -- physical.c
Called By: task
*/
//portTickType tx_water_value =0;
static void xnl_tx_process(void * pvParameters)
{
80004404:	d4 31       	pushm	r0-r7,lr
	
	
	for(;;)
	{		
		//tx_water_value = uxTaskGetStackHighWaterMark(NULL);
		switch(xnl_tx_state)
80004406:	4a a6       	lddpc	r6,800044ac <xnl_tx_process+0xa8>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
80004408:	4a a2       	lddpc	r2,800044b0 <xnl_tx_process+0xac>
8000440a:	4a b4       	lddpc	r4,800044b4 <xnl_tx_process+0xb0>
8000440c:	30 07       	mov	r7,0
8000440e:	3f f1       	mov	r1,-1
					if(NULL == ptr)
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
80004410:	30 00       	mov	r0,0
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;				
80004412:	4a a5       	lddpc	r5,800044b8 <xnl_tx_process+0xb4>
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
80004414:	4a a3       	lddpc	r3,800044bc <xnl_tx_process+0xb8>
	
	
	for(;;)
	{		
		//tx_water_value = uxTaskGetStackHighWaterMark(NULL);
		switch(xnl_tx_state)
80004416:	6c 08       	ld.w	r8,r6[0x0]
80004418:	58 08       	cp.w	r8,0
8000441a:	c0 40       	breq	80004422 <xnl_tx_process+0x1e>
8000441c:	58 18       	cp.w	r8,1
8000441e:	cf d1       	brne	80004418 <xnl_tx_process+0x14>
80004420:	c2 48       	rjmp	80004468 <xnl_tx_process+0x64>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
80004422:	64 0c       	ld.w	r12,r2[0x0]
80004424:	0e 99       	mov	r9,r7
80004426:	02 9a       	mov	r10,r1
80004428:	08 9b       	mov	r11,r4
8000442a:	f0 1f 00 26 	mcall	800044c0 <xnl_tx_process+0xbc>
8000442e:	58 1c       	cp.w	r12,1
80004430:	cf 31       	brne	80004416 <xnl_tx_process+0x12>
					, portMAX_DELAY ))
				{				
					if(NULL == ptr)
80004432:	68 0b       	ld.w	r11,r4[0x0]
80004434:	58 0b       	cp.w	r11,0
80004436:	cf 00       	breq	80004416 <xnl_tx_process+0x12>
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
80004438:	96 28       	ld.sh	r8,r11[0x4]
8000443a:	e0 08 19 00 	cp.h	r8,r0
8000443e:	c0 71       	brne	8000444c <xnl_tx_process+0x48>
					{
						/*invalid XNL opcode*/
						set_xnl_idle(ptr);
80004440:	4a 18       	lddpc	r8,800044c4 <xnl_tx_process+0xc0>
80004442:	70 08       	ld.w	r8,r8[0x0]
80004444:	10 9c       	mov	r12,r8
80004446:	f0 1f 00 21 	mcall	800044c8 <xnl_tx_process+0xc4>
						break;
8000444a:	ce 6b       	rjmp	80004416 <xnl_tx_process+0x12>
					}
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
8000444c:	16 9c       	mov	r12,r11
8000444e:	f0 1f 00 20 	mcall	800044cc <xnl_tx_process+0xc8>
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;				
80004452:	30 18       	mov	r8,1
80004454:	8b 08       	st.w	r5[0x0],r8
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
80004456:	66 0c       	ld.w	r12,r3[0x0]
80004458:	0e 99       	mov	r9,r7
8000445a:	0e 9a       	mov	r10,r7
8000445c:	0e 9b       	mov	r11,r7
8000445e:	f0 1f 00 19 	mcall	800044c0 <xnl_tx_process+0xbc>
					xnl_tx_state = WAITING_FOR_REPLY;
80004462:	30 18       	mov	r8,1
80004464:	8d 08       	st.w	r6[0x0],r8
80004466:	cd 8b       	rjmp	80004416 <xnl_tx_process+0x12>
				}
				break;
			
			/*wait XNL reply*/			
			case WAITING_FOR_REPLY://直到回答ACK才再发送下一条data/control
				if(pdTRUE == xSemaphoreTake( xnl_timeout_semphr
80004468:	66 0c       	ld.w	r12,r3[0x0]
8000446a:	0e 99       	mov	r9,r7
8000446c:	36 4a       	mov	r10,100
8000446e:	0e 9b       	mov	r11,r7
80004470:	f0 1f 00 14 	mcall	800044c0 <xnl_tx_process+0xbc>
80004474:	58 1c       	cp.w	r12,1
80004476:	c0 81       	brne	80004486 <xnl_tx_process+0x82>
					, ( portTickType )50*2/ portTICK_RATE_MS))//按ADK文档中提示500ms一次超时,但是实际情况下程序中启用freertos的任务延时不够精准。因此根据经验需要降低延时等待的时间
				{
					/*No timeout*/
					set_xnl_idle(ptr);			
80004478:	49 38       	lddpc	r8,800044c4 <xnl_tx_process+0xc0>
8000447a:	70 0c       	ld.w	r12,r8[0x0]
8000447c:	68 0b       	ld.w	r11,r4[0x0]
8000447e:	f0 1f 00 13 	mcall	800044c8 <xnl_tx_process+0xc4>
					xnl_tx_state = WAITING_FOR_TX;
80004482:	8d 07       	st.w	r6[0x0],r7
80004484:	cc 9b       	rjmp	80004416 <xnl_tx_process+0x12>
				}
				else
				{
					/*time out*/
					if(xnl_send_times <= MIN_RESEND_TIMES)
80004486:	6a 08       	ld.w	r8,r5[0x0]
80004488:	58 38       	cp.w	r8,3
8000448a:	e0 89 00 09 	brgt	8000449c <xnl_tx_process+0x98>
					{
						/*If times smaller than A supermarket, then resend the 
						instructions*/
						phy_tx((phy_fragment_t *)ptr);
8000448e:	68 0c       	ld.w	r12,r4[0x0]
80004490:	f0 1f 00 0f 	mcall	800044cc <xnl_tx_process+0xc8>
						xnl_send_times++;
80004494:	6a 08       	ld.w	r8,r5[0x0]
80004496:	2f f8       	sub	r8,-1
80004498:	8b 08       	st.w	r5[0x0],r8
8000449a:	cb eb       	rjmp	80004416 <xnl_tx_process+0x12>
					}
					else
					{
						//can not send data, disconnected						
						//vPortFree(ptr);	
						set_xnl_idle(ptr);									
8000449c:	48 a8       	lddpc	r8,800044c4 <xnl_tx_process+0xc0>
8000449e:	70 0c       	ld.w	r12,r8[0x0]
800044a0:	68 0b       	ld.w	r11,r4[0x0]
800044a2:	f0 1f 00 0a 	mcall	800044c8 <xnl_tx_process+0xc4>
						xnl_tx_state = WAITING_FOR_TX;
800044a6:	8d 07       	st.w	r6[0x0],r7
800044a8:	cb 7b       	rjmp	80004416 <xnl_tx_process+0x12>
800044aa:	00 00       	add	r0,r0
800044ac:	00 00       	add	r0,r0
800044ae:	0b 50       	ld.sh	r0,--r5
800044b0:	00 00       	add	r0,r0
800044b2:	0b 54       	ld.sh	r4,--r5
800044b4:	00 00       	add	r0,r0
800044b6:	0b 5c       	ld.sh	r12,--r5
800044b8:	00 00       	add	r0,r0
800044ba:	0b 58       	ld.sh	r8,--r5
800044bc:	00 00       	add	r0,r0
800044be:	0b 40       	ld.w	r0,--r5
800044c0:	80 00       	ld.sh	r0,r0[0x0]
800044c2:	61 28       	ld.w	r8,r0[0x48]
800044c4:	00 00       	add	r0,r0
800044c6:	0a a4       	st.w	r5++,r4
800044c8:	80 00       	ld.sh	r0,r0[0x0]
800044ca:	2b e0       	sub	r0,-66
800044cc:	80 00       	ld.sh	r0,r0[0x0]
800044ce:	2c 00       	sub	r0,-64

800044d0 <xnl_tx>:
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
{
800044d0:	eb cd 40 c0 	pushm	r6-r7,lr
800044d4:	20 1d       	sub	sp,4
800044d6:	18 96       	mov	r6,r12
	message that is sent. The same value should be used for all retries.
	*/
	static U8 flags = 0;
	
	/*If the value is DEFAULT_VALUE, the value will be modified*/
	if(DEFAULT_VALUE == xnl->xnl_header.flags)
800044d8:	98 39       	ld.sh	r9,r12[0x6]
800044da:	3f f8       	mov	r8,-1
800044dc:	f0 09 19 00 	cp.h	r9,r8
800044e0:	c0 a1       	brne	800044f4 <xnl_tx+0x24>
	{
		xnl->xnl_header.flags =  0x0100 | ((++flags) & 0x07);
800044e2:	4a e9       	lddpc	r9,80004598 <xnl_tx+0xc8>
800044e4:	13 88       	ld.ub	r8,r9[0x0]
800044e6:	2f f8       	sub	r8,-1
800044e8:	5c 58       	castu.b	r8
800044ea:	b2 88       	st.b	r9[0x0],r8
800044ec:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
800044f0:	a9 a8       	sbr	r8,0x8
800044f2:	b8 38       	st.h	r12[0x6],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.destination)
800044f4:	8c 49       	ld.sh	r9,r6[0x8]
800044f6:	3f f8       	mov	r8,-1
800044f8:	f0 09 19 00 	cp.h	r9,r8
800044fc:	c0 41       	brne	80004504 <xnl_tx+0x34>
	{		
		/*Use actual Master address.*/
		xnl->xnl_header.destination = xnl_information.master_address;
800044fe:	4a 88       	lddpc	r8,8000459c <xnl_tx+0xcc>
80004500:	90 18       	ld.sh	r8,r8[0x2]
80004502:	ac 48       	st.h	r6[0x8],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.source)
80004504:	8c 59       	ld.sh	r9,r6[0xa]
80004506:	3f f8       	mov	r8,-1
80004508:	f0 09 19 00 	cp.h	r9,r8
8000450c:	c0 41       	brne	80004514 <xnl_tx+0x44>
	{
		/*Use Temporary address.*/	
		xnl->xnl_header.source = xnl_information.device_address;
8000450e:	4a 48       	lddpc	r8,8000459c <xnl_tx+0xcc>
80004510:	90 28       	ld.sh	r8,r8[0x4]
80004512:	ac 58       	st.h	r6[0xa],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
80004514:	8c 69       	ld.sh	r9,r6[0xc]
80004516:	3f f8       	mov	r8,-1
80004518:	f0 09 19 00 	cp.h	r9,r8
8000451c:	c0 e1       	brne	80004538 <xnl_tx+0x68>
	{		
		xnl->xnl_header.transaction_id = 
		  ((++xnl_information.transaction_id) & 0xFF) 
8000451e:	4a 08       	lddpc	r8,8000459c <xnl_tx+0xcc>
80004520:	90 49       	ld.sh	r9,r8[0x8]
80004522:	2f f9       	sub	r9,-1
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
80004524:	b0 49       	st.h	r8[0x8],r9
		  ((++xnl_information.transaction_id) & 0xFF) 
80004526:	90 4a       	ld.sh	r10,r8[0x8]
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
80004528:	90 49       	ld.sh	r9,r8[0x8]
8000452a:	e0 19 ff 00 	andl	r9,0xff00
8000452e:	f1 da c0 08 	bfextu	r8,r10,0x0,0x8
80004532:	f3 e8 10 08 	or	r8,r9,r8
80004536:	ac 68       	st.h	r6[0xc],r8
	U16  sumScratch;
	U32  indextohWord;
	S32  hWordswithinFrag;
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
80004538:	0d 98       	ld.ub	r8,r6[0x1]
8000453a:	20 28       	sub	r8,2
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
8000453c:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
80004540:	10 0c       	add	r12,r8
80004542:	a1 5c       	asr	r12,0x1
	indextohWord = 2;
	while (hWordswithinFrag > 0)
80004544:	58 0c       	cp.w	r12,0
80004546:	e0 89 00 04 	brgt	8000454e <xnl_tx+0x7e>
8000454a:	30 09       	mov	r9,0
8000454c:	c0 d8       	rjmp	80004566 <xnl_tx+0x96>
8000454e:	ec ca ff fc 	sub	r10,r6,-4
Parameters: xnl_fragment_t * 
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
80004552:	2f ec       	sub	r12,-2
80004554:	30 09       	mov	r9,0
80004556:	30 28       	mov	r8,2
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
	{
		sumScratch += *((U16*)xnl + indextohWord);
80004558:	15 1b       	ld.sh	r11,r10++
8000455a:	f6 09 00 09 	add	r9,r11,r9
8000455e:	5c 89       	casts.h	r9
		indextohWord     += 1;
80004560:	2f f8       	sub	r8,-1
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
80004562:	18 38       	cp.w	r8,r12
80004564:	cf a1       	brne	80004558 <xnl_tx+0x88>
		  ((++xnl_information.transaction_id) & 0xFF) 
		| (xnl_information.transaction_id & 0xFF00);
	}
	
	/*count check sum */
	xnl->phy_header.check_sum = check_sum( xnl );
80004566:	5c 39       	neg	r9
80004568:	ac 19       	st.h	r6[0x2],r9
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
8000456a:	48 e8       	lddpc	r8,800045a0 <xnl_tx+0xd0>
8000456c:	70 0c       	ld.w	r12,r8[0x0]
8000456e:	f0 1f 00 0e 	mcall	800045a4 <xnl_tx+0xd4>
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
80004572:	c1 00       	breq	80004592 <xnl_tx+0xc2>
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
80004574:	fa c7 ff fc 	sub	r7,sp,-4
80004578:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
	{
		memcpy(ptr, xnl, sizeof(xnl_fragment_t));
8000457a:	e0 6a 01 00 	mov	r10,256
8000457e:	0c 9b       	mov	r11,r6
80004580:	f0 1f 00 0a 	mcall	800045a8 <xnl_tx+0xd8>
	
		/*push to queue and send*/
		
		//log("ptr -%8x", ptr);
		
		xQueueSend(xnl_frame_tx, &ptr, 0);
80004584:	48 a8       	lddpc	r8,800045ac <xnl_tx+0xdc>
80004586:	70 0c       	ld.w	r12,r8[0x0]
80004588:	30 09       	mov	r9,0
8000458a:	12 9a       	mov	r10,r9
8000458c:	1a 9b       	mov	r11,sp
8000458e:	f0 1f 00 09 	mcall	800045b0 <xnl_tx+0xe0>
		//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
		
		//vPortFree(ptr);
	}
}
80004592:	2f fd       	sub	sp,-4
80004594:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004598:	00 00       	add	r0,r0
8000459a:	0b 44       	ld.w	r4,--r5
8000459c:	00 00       	add	r0,r0
8000459e:	0b 46       	ld.w	r6,--r5
800045a0:	00 00       	add	r0,r0
800045a2:	0a a4       	st.w	r5++,r4
800045a4:	80 00       	ld.sh	r0,r0[0x0]
800045a6:	2d 8c       	sub	r12,-40
800045a8:	80 00       	ld.sh	r0,r0[0x0]
800045aa:	77 e8       	ld.w	r8,r11[0x78]
800045ac:	00 00       	add	r0,r0
800045ae:	0b 54       	ld.sh	r4,--r5
800045b0:	80 00       	ld.sh	r0,r0[0x0]
800045b2:	63 34       	ld.w	r4,r1[0x4c]

800045b4 <xnl_data_msg_func>:
Description: process while receive data message.
Calls:xnl_send_msg_ack, xcmp_exec(function in xcmp)
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_data_msg_func(xnl_fragment_t * xnl)
{
800045b4:	eb cd 40 80 	pushm	r7,lr
800045b8:	fa cd 01 00 	sub	sp,sp,256
800045bc:	18 97       	mov	r7,r12
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
800045be:	e0 68 40 0e 	mov	r8,16398
800045c2:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
800045c4:	3f f8       	mov	r8,-1
800045c6:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG_ACK;
800045c8:	30 c8       	mov	r8,12
800045ca:	ba 28       	st.h	sp[0x4],r8
	
	/*Turn around Flags.*/	
	xnl_frame.xnl_header.flags = hdr->flags;
800045cc:	98 38       	ld.sh	r8,r12[0x6]
800045ce:	ba 38       	st.h	sp[0x6],r8
	
	/*ACK Destination Address is Source of XNL_Message.*/
	xnl_frame.xnl_header.destination = hdr->source;
800045d0:	98 58       	ld.sh	r8,r12[0xa]
800045d2:	ba 48       	st.h	sp[0x8],r8
	
	/*ACK Source Address is my address.*/
	xnl_frame.xnl_header.source = hdr->destination;
800045d4:	98 48       	ld.sh	r8,r12[0x8]
800045d6:	ba 58       	st.h	sp[0xa],r8
	
	/*Turn around Transaction ID.*/
	xnl_frame.xnl_header.transaction_id = hdr->transaction_id;
800045d8:	98 68       	ld.sh	r8,r12[0xc]
800045da:	ba 68       	st.h	sp[0xc],r8
	xnl_frame.xnl_header.payload_length = 0;
800045dc:	30 08       	mov	r8,0
800045de:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
800045e0:	1a 9c       	mov	r12,sp
800045e2:	f0 1f 00 0a 	mcall	80004608 <xnl_data_msg_func+0x54>
	transmitter, but possibly is waiting in Queue with immediate timeout.
	 */
	xnl_send_msg_ack(&xnl->xnl_header);
	
	/*exec xcmp function*/
	xcmp_exec(xnl->xnl_payload.xnl_content_data_msg);//xcmp_rx
800045e6:	fa cd 00 cc 	sub	sp,sp,204
800045ea:	e0 6a 00 ca 	mov	r10,202
800045ee:	ee cb ff f0 	sub	r11,r7,-16
800045f2:	1a 9c       	mov	r12,sp
800045f4:	f0 1f 00 06 	mcall	8000460c <xnl_data_msg_func+0x58>
800045f8:	48 68       	lddpc	r8,80004610 <xnl_data_msg_func+0x5c>
800045fa:	70 08       	ld.w	r8,r8[0x0]
800045fc:	5d 18       	icall	r8
800045fe:	fa cd ff 34 	sub	sp,sp,-204
}
80004602:	2c 0d       	sub	sp,-256
80004604:	e3 cd 80 80 	ldm	sp++,r7,pc
80004608:	80 00       	ld.sh	r0,r0[0x0]
8000460a:	44 d0       	lddsp	r0,sp[0x134]
8000460c:	80 00       	ld.sh	r0,r0[0x0]
8000460e:	77 e8       	ld.w	r8,r11[0x78]
80004610:	00 00       	add	r0,r0
80004612:	0b 60       	ld.uh	r0,--r5

80004614 <xnl_device_auth_reply_func>:
Description: process while receive device auth reply.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_auth_reply_func(xnl_fragment_t * xnl)
{
80004614:	d4 21       	pushm	r4-r7,lr
80004616:	fa cd 01 00 	sub	sp,sp,256
8000461a:	18 97       	mov	r7,r12
	the receiving device and will be used to authenticate the connection 
	request. 5.4.4
	*/
	//log("R_xnl-opcode:%4x", xnl->xnl_header.opcode);
	
	if(xnl_information.is_connected)
8000461c:	4c 28       	lddpc	r8,80004724 <xnl_device_auth_reply_func+0x110>
8000461e:	11 88       	ld.ub	r8,r8[0x0]
80004620:	58 08       	cp.w	r8,0
80004622:	e0 81 00 7f 	brne	80004720 <xnl_device_auth_reply_func+0x10c>
	{
		return;		
	}
	
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);
80004626:	4c 18       	lddpc	r8,80004728 <xnl_device_auth_reply_func+0x114>
80004628:	70 0c       	ld.w	r12,r8[0x0]
8000462a:	30 09       	mov	r9,0
8000462c:	12 9a       	mov	r10,r9
8000462e:	12 9b       	mov	r11,r9
80004630:	f0 1f 00 3f 	mcall	8000472c <xnl_device_auth_reply_func+0x118>

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
80004634:	ef 09 00 10 	ld.sh	r9,r7[16]
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
80004638:	4b b8       	lddpc	r8,80004724 <xnl_device_auth_reply_func+0x110>
8000463a:	b0 29       	st.h	r8[0x4],r9
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
	
	/*Get Array of values to be encrypted into an aligned 2X32bits.*/
	v_vector[0] =
8000463c:	ef 39 00 12 	ld.ub	r9,r7[18]
80004640:	ef 38 00 13 	ld.ub	r8,r7[19]
80004644:	b1 68       	lsl	r8,0x10
80004646:	f1 e9 11 89 	or	r9,r8,r9<<0x18
8000464a:	ef 38 00 15 	ld.ub	r8,r7[21]
8000464e:	f3 e8 10 08 	or	r8,r9,r8
80004652:	ef 39 00 14 	ld.ub	r9,r7[20]
80004656:	f1 e9 10 89 	or	r9,r8,r9<<0x8
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[2])<<8	  
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[3]);
	
	v_vector[1] =
8000465a:	ef 3a 00 16 	ld.ub	r10,r7[22]
8000465e:	ef 38 00 17 	ld.ub	r8,r7[23]
80004662:	b1 68       	lsl	r8,0x10
80004664:	f1 ea 11 8a 	or	r10,r8,r10<<0x18
80004668:	ef 38 00 19 	ld.ub	r8,r7[25]
8000466c:	f5 e8 10 08 	or	r8,r10,r8
80004670:	ef 3a 00 18 	ld.ub	r10,r7[24]
80004674:	f1 ea 10 88 	or	r8,r8,r10<<0x8
80004678:	30 0a       	mov	r10,0
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
8000467a:	e0 64 79 b9 	mov	r4,31161
8000467e:	ea 14 9e 37 	orh	r4,0x9e37
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
80004682:	e0 65 45 07 	mov	r5,17671
80004686:	ea 15 8a bd 	orh	r5,0x8abd
8000468a:	e0 66 f9 3d 	mov	r6,63805
8000468e:	ea 16 99 68 	orh	r6,0x9968
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
80004692:	e0 6e b8 cf 	mov	lr,47311
80004696:	ea 1e 36 83 	orh	lr,0x3683
8000469a:	e0 67 aa 1c 	mov	r7,43548
8000469e:	ea 17 9c 36 	orh	r7,0x9c36
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
800046a2:	08 0a       	add	r10,r4
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
800046a4:	f4 08 00 0c 	add	r12,r10,r8
800046a8:	f0 0b 15 04 	lsl	r11,r8,0x4
800046ac:	0a 0b       	add	r11,r5
800046ae:	f9 eb 20 0b 	eor	r11,r12,r11
800046b2:	f0 0c 16 05 	lsr	r12,r8,0x5
800046b6:	0c 0c       	add	r12,r6
800046b8:	18 5b       	eor	r11,r12
800046ba:	16 09       	add	r9,r11
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
800046bc:	f2 0c 15 04 	lsl	r12,r9,0x4
800046c0:	1c 0c       	add	r12,lr
800046c2:	f2 0b 16 05 	lsr	r11,r9,0x5
800046c6:	0e 0b       	add	r11,r7
800046c8:	f9 eb 20 0b 	eor	r11,r12,r11
800046cc:	f2 0a 00 0c 	add	r12,r9,r10
800046d0:	18 5b       	eor	r11,r12
800046d2:	16 08       	add	r8,r11
{
	register U32 y=v[0], z=v[1], sum=0;
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
800046d4:	e0 6b 37 20 	mov	r11,14112
800046d8:	ea 1b c6 ef 	orh	r11,0xc6ef
800046dc:	16 3a       	cp.w	r10,r11
800046de:	ce 21       	brne	800046a2 <xnl_device_auth_reply_func+0x8e>
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :24 + 2(xnl length(24) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 24 + 2;
800046e0:	e0 6a 40 1a 	mov	r10,16410
800046e4:	ba 0a       	st.h	sp[0x0],r10
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
800046e6:	3f fa       	mov	r10,-1
800046e8:	ba 1a       	st.h	sp[0x2],r10
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_CONN_REQUEST;
800046ea:	30 6b       	mov	r11,6
800046ec:	ba 2b       	st.h	sp[0x4],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
800046ee:	ba 3a       	st.h	sp[0x6],r10
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
800046f0:	48 db       	lddpc	r11,80004724 <xnl_device_auth_reply_func+0x110>
800046f2:	96 1c       	ld.sh	r12,r11[0x2]
800046f4:	ba 4c       	st.h	sp[0x8],r12
	message here, and all will receive the same DEVICE_CONN_REPLY. Not real 
	sure what's going to happen with multiple conrol heads, etc. One suspects 
	the Rocket Scientists will eventually figure this out, and demand a 
	transaction ID based on Device Type in the XNL_DEVICE_AUTH_KEY_REQUEST.
	*/
	xnl_frame.xnl_header.source = xnl_information.device_address;
800046f6:	96 2b       	ld.sh	r11,r11[0x4]
800046f8:	ba 5b       	st.h	sp[0xa],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
800046fa:	ba 6a       	st.h	sp[0xc],r10
	
    /*his message contains 12 payload bytes*/	
	xnl_frame.xnl_header.payload_length = 0x000C;
800046fc:	30 ca       	mov	r10,12
800046fe:	ba 7a       	st.h	sp[0xe],r10
	
	/*No Preferred XNL Address*/
	xnl_frame.xnl_payload.xnl_content_device_conn_req.preferred_xnl_address = 
80004700:	30 0a       	mov	r10,0
80004702:	fb 5a 00 10 	st.h	sp[16],r10
	XCMP/XNL Development Specification Section 4.5.3.2.1.
	Same as in MOTOTRBO?XCMP/XNL Development Specification?
	evice_type--Option Board(0x07)
	authentication_index--Option Board(0x02)
	*/	
	xnl_frame.xnl_payload.xnl_content_device_conn_req.device_type = 0x07;
80004706:	30 7a       	mov	r10,7
80004708:	fb 6a 00 12 	st.b	sp[18],r10
	xnl_frame.xnl_payload.xnl_content_device_conn_req.authentication_index =
8000470c:	30 2a       	mov	r10,2
8000470e:	fb 6a 00 13 	st.b	sp[19],r10
	                                                                       0x02;
		
	//We know encrypted array happens to be aligned to 32-bit boundary.
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
80004712:	fa ca ff ec 	sub	r10,sp,-20
80004716:	95 09       	st.w	r10[0x0],r9
	                         .encrypted_authentication_value[0])) = w_vector[0];
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
80004718:	95 18       	st.w	r10[0x4],r8
	                         .encrypted_authentication_value[4])) = w_vector[1];
	
	/*send XNL message*/
	xnl_tx(&xnl_frame);
8000471a:	1a 9c       	mov	r12,sp
8000471c:	f0 1f 00 05 	mcall	80004730 <xnl_device_auth_reply_func+0x11c>
}
80004720:	2c 0d       	sub	sp,-256
80004722:	d8 22       	popm	r4-r7,pc
80004724:	00 00       	add	r0,r0
80004726:	0b 46       	ld.w	r6,--r5
80004728:	00 00       	add	r0,r0
8000472a:	0b 40       	ld.w	r0,--r5
8000472c:	80 00       	ld.sh	r0,r0[0x0]
8000472e:	63 34       	ld.w	r4,r1[0x4c]
80004730:	80 00       	ld.sh	r0,r0[0x0]
80004732:	44 d0       	lddsp	r0,sp[0x134]

80004734 <xnl_master_status_brdcst_func>:
Description: process while receive master status boardcast.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_master_status_brdcst_func(xnl_fragment_t * xnl)
{	
80004734:	eb cd 40 80 	pushm	r7,lr
80004738:	fa cd 01 00 	sub	sp,sp,256
8000473c:	18 97       	mov	r7,r12
	not an XNL_DATA_MSG has been sent out. This will indicate to a connecting 
	device that it has missed messages. The XNL header will contain the 
	master?XNL address. 5.4.1
	*/
	
	if(xnl_information.is_connected)
8000473e:	49 28       	lddpc	r8,80004784 <xnl_master_status_brdcst_func+0x50>
80004740:	11 88       	ld.ub	r8,r8[0x0]
80004742:	58 08       	cp.w	r8,0
80004744:	c1 c1       	brne	8000477c <xnl_master_status_brdcst_func+0x48>
	{
		return;	
	}
		
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);	
80004746:	49 18       	lddpc	r8,80004788 <xnl_master_status_brdcst_func+0x54>
80004748:	70 0c       	ld.w	r12,r8[0x0]
8000474a:	30 09       	mov	r9,0
8000474c:	12 9a       	mov	r10,r9
8000474e:	12 9b       	mov	r11,r9
80004750:	f0 1f 00 0f 	mcall	8000478c <xnl_master_status_brdcst_func+0x58>

	//log("xnl-ma:%4x", xnl->xnl_header.source);
	/*get the master adderss from this message*/	
	xnl_information.master_address = xnl->xnl_header.source;	
80004754:	8e 58       	ld.sh	r8,r7[0xa]
80004756:	48 c9       	lddpc	r9,80004784 <xnl_master_status_brdcst_func+0x50>
80004758:	b2 18       	st.h	r9[0x2],r8
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
8000475a:	e0 68 40 0e 	mov	r8,16398
8000475e:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004760:	3f f8       	mov	r8,-1
80004762:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_AUTH_KEY_REQUEST;
80004764:	30 4a       	mov	r10,4
80004766:	ba 2a       	st.h	sp[0x4],r10
		
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/	
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
80004768:	ba 38       	st.h	sp[0x6],r8
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
8000476a:	92 19       	ld.sh	r9,r9[0x2]
8000476c:	ba 49       	st.h	sp[0x8],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.source = DEFAULT_VALUE;
8000476e:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80004770:	ba 68       	st.h	sp[0xc],r8
		
	xnl_frame.xnl_header.payload_length = 0;
80004772:	30 08       	mov	r8,0
80004774:	ba 78       	st.h	sp[0xe],r8
	
	/*send XNL message*/	
	xnl_tx(&xnl_frame);
80004776:	1a 9c       	mov	r12,sp
80004778:	f0 1f 00 06 	mcall	80004790 <xnl_master_status_brdcst_func+0x5c>
}
8000477c:	2c 0d       	sub	sp,-256
8000477e:	e3 cd 80 80 	ldm	sp++,r7,pc
80004782:	00 00       	add	r0,r0
80004784:	00 00       	add	r0,r0
80004786:	0b 46       	ld.w	r6,--r5
80004788:	00 00       	add	r0,r0
8000478a:	0b 40       	ld.w	r0,--r5
8000478c:	80 00       	ld.sh	r0,r0[0x0]
8000478e:	63 34       	ld.w	r4,r1[0x4c]
80004790:	80 00       	ld.sh	r0,r0[0x0]
80004792:	44 d0       	lddsp	r0,sp[0x134]

80004794 <xnl_device_conn_reply_func>:
Description: process while receive device conn reply.
Calls:xSemaphoreGive--freestos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_conn_reply_func(xnl_fragment_t * xnl)
{
80004794:	eb cd 40 80 	pushm	r7,lr
80004798:	18 97       	mov	r7,r12
	transaction ID and an 8-byte encrypted value that the device can use to 
	authenticate the master. XCMP/XNL Development Guide 5.4.6
	*/
	
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);
8000479a:	49 28       	lddpc	r8,800047e0 <xnl_device_conn_reply_func+0x4c>
8000479c:	70 0c       	ld.w	r12,r8[0x0]
8000479e:	30 09       	mov	r9,0
800047a0:	12 9a       	mov	r10,r9
800047a2:	12 9b       	mov	r11,r9
800047a4:	f0 1f 00 10 	mcall	800047e4 <xnl_device_conn_reply_func+0x50>

	/*Test result code*/
	if((xnl->xnl_payload.xnl_content_device_conn_reply.result_base & 0x0000FF00)
800047a8:	ef 18 00 10 	ld.uh	r8,r7[16]
800047ac:	10 99       	mov	r9,r8
800047ae:	e2 19 ff 00 	andl	r9,0xff00,COH
800047b2:	e0 49 01 00 	cp.w	r9,256
800047b6:	c0 60       	breq	800047c2 <xnl_device_conn_reply_func+0x2e>
		/*
		Rejected. The device must retry the authentication process at this 
		point by sending out a new AUTH_KEY_REQUEST message. XCMP/XNL 
		Development Guide Section 5.2.3
		*/
		xnl_master_status_brdcst_func(xnl);			
800047b8:	0e 9c       	mov	r12,r7
800047ba:	f0 1f 00 0c 	mcall	800047e8 <xnl_device_conn_reply_func+0x54>
800047be:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/*connection accepted*/		
		/*Record Transaction ID Base*/
		xnl_information.transaction_id =  
800047c2:	a9 68       	lsl	r8,0x8
800047c4:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
800047c8:	48 98       	lddpc	r8,800047ec <xnl_device_conn_reply_func+0x58>
800047ca:	b0 49       	st.h	r8[0x8],r9
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
800047cc:	ef 09 00 14 	ld.sh	r9,r7[20]
		xnl_information.transaction_id =  
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
800047d0:	b0 39       	st.h	r8[0x6],r9
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
800047d2:	ef 09 00 12 	ld.sh	r9,r7[18]
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
800047d6:	b0 29       	st.h	r8[0x4],r9
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
		
		/*connect finish*/
		xnl_information.is_connected = TRUE;
800047d8:	30 19       	mov	r9,1
800047da:	b0 89       	st.b	r8[0x0],r9
800047dc:	e3 cd 80 80 	ldm	sp++,r7,pc
800047e0:	00 00       	add	r0,r0
800047e2:	0b 40       	ld.w	r0,--r5
800047e4:	80 00       	ld.sh	r0,r0[0x0]
800047e6:	63 34       	ld.w	r4,r1[0x4c]
800047e8:	80 00       	ld.sh	r0,r0[0x0]
800047ea:	47 34       	lddsp	r4,sp[0x1cc]
800047ec:	00 00       	add	r0,r0
800047ee:	0b 46       	ld.w	r6,--r5

800047f0 <xnl_send_device_master_query>:
Description: send device_master_query to connect radio.
Calls:xnl_tx
Call By:xnl_init
*/
void xnl_send_device_master_query(void)
{
800047f0:	d4 01       	pushm	lr
800047f2:	fa cd 01 00 	sub	sp,sp,256
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
800047f6:	e0 68 40 0e 	mov	r8,16398
800047fa:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
800047fc:	3f f8       	mov	r8,-1
800047fe:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_MASTER_QUERY;
80004800:	30 38       	mov	r8,3
80004802:	ba 28       	st.h	sp[0x4],r8
	
	/*The initial value*/
	xnl_frame.xnl_header.flags = 0;
80004804:	30 08       	mov	r8,0
80004806:	ba 38       	st.h	sp[0x6],r8
	
	/*XNL address of the master device, if known;otherwise 0x0000*/
	xnl_frame.xnl_header.destination = 0;
80004808:	ba 48       	st.h	sp[0x8],r8
	
	/*XNL address, if assigned; otherwise 0x0000*/
	xnl_frame.xnl_header.source = 0;
8000480a:	ba 58       	st.h	sp[0xa],r8
	
	/*No transaction ID required for this message*/
	xnl_frame.xnl_header.transaction_id = 0;
8000480c:	ba 68       	st.h	sp[0xc],r8
	
	/*This message contains no payload*/
	xnl_frame.xnl_header.payload_length = 0;
8000480e:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004810:	1a 9c       	mov	r12,sp
80004812:	f0 1f 00 03 	mcall	8000481c <xnl_send_device_master_query+0x2c>
}
80004816:	2c 0d       	sub	sp,-256
80004818:	d8 02       	popm	pc
8000481a:	00 00       	add	r0,r0
8000481c:	80 00       	ld.sh	r0,r0[0x0]
8000481e:	44 d0       	lddsp	r0,sp[0x134]

80004820 <RC522_SPI_SetSpeed>:
	//SET_SPI_CS;

}

void RC522_SPI_SetSpeed(U16 SPI_BaudRatePrescaler)
{
80004820:	d4 01       	pushm	lr
	spi->csr0 = (spi->csr0 & (U16)0x00FF) |SPI_BaudRatePrescaler;
80004822:	48 78       	lddpc	r8,8000483c <RC522_SPI_SetSpeed+0x1c>
80004824:	70 09       	ld.w	r9,r8[0x0]
80004826:	72 ca       	ld.w	r10,r9[0x30]
80004828:	5c 7c       	castu.h	r12
8000482a:	f5 da c0 08 	bfextu	r10,r10,0x0,0x8
8000482e:	f9 ea 10 0a 	or	r10,r12,r10
80004832:	93 ca       	st.w	r9[0x30],r10

	spi_enable(spi); /*!< SD_SPI enable */
80004834:	70 0c       	ld.w	r12,r8[0x0]
80004836:	f0 1f 00 03 	mcall	80004840 <RC522_SPI_SetSpeed+0x20>
		
	
}
8000483a:	d8 02       	popm	pc
8000483c:	00 00       	add	r0,r0
8000483e:	1d ac       	ld.ub	r12,lr[0x2]
80004840:	80 00       	ld.sh	r0,r0[0x0]
80004842:	58 24       	cp.w	r4,2

80004844 <RC522_SPI_SetSpeedLow>:
void RC522_SPI_SetSpeedLow(void)
{
80004844:	d4 01       	pushm	lr
	RC522_SPI_SetSpeed(0x0A00);//baudDiv=4
80004846:	e0 6c 0a 00 	mov	r12,2560
8000484a:	f0 1f 00 02 	mcall	80004850 <RC522_SPI_SetSpeedLow+0xc>
	
}
8000484e:	d8 02       	popm	pc
80004850:	80 00       	ld.sh	r0,r0[0x0]
80004852:	48 20       	lddpc	r0,80004858 <RC522_ReadByte+0x4>

80004854 <RC522_ReadByte>:
	/*!< Return the byte read from the SPI bus */
	return  temp;

}
U8 RC522_ReadByte(void)
{
80004854:	eb cd 40 c0 	pushm	r6-r7,lr
	//蹇椤昏锋芥ｅ父璇诲
	//spi_selectChip(spi, DF_SPI_PCS_0);
	
	/*!< Send the byte */

	spi_write(spi,  0xFF);
80004858:	48 76       	lddpc	r6,80004874 <RC522_ReadByte+0x20>
8000485a:	e0 6b 00 ff 	mov	r11,255
8000485e:	6c 0c       	ld.w	r12,r6[0x0]
80004860:	f0 1f 00 06 	mcall	80004878 <RC522_ReadByte+0x24>
	
	/*!< Return the byte read from the SPI bus */

	spi_read(spi, Data);
80004864:	30 07       	mov	r7,0
80004866:	0e 9b       	mov	r11,r7
80004868:	6c 0c       	ld.w	r12,r6[0x0]
8000486a:	f0 1f 00 05 	mcall	8000487c <RC522_ReadByte+0x28>
	
	//spi_unselectChip(spi, DF_SPI_PCS_0);
	
	return (U8)(*Data);
	
}
8000486e:	0f 9c       	ld.ub	r12,r7[0x1]
80004870:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004874:	00 00       	add	r0,r0
80004876:	1d ac       	ld.ub	r12,lr[0x2]
80004878:	80 00       	ld.sh	r0,r0[0x0]
8000487a:	58 2a       	cp.w	r10,2
8000487c:	80 00       	ld.sh	r0,r0[0x0]
8000487e:	58 46       	cp.w	r6,4

80004880 <RC522_WriteByte>:


U8 rc522_init_failure =0;

U8 RC522_WriteByte(U8 Data)
{
80004880:	eb cd 40 80 	pushm	r7,lr
80004884:	20 1d       	sub	sp,4
80004886:	ba 8c       	st.b	sp[0x0],r12
	U8 temp =0;
	
	//spi_selectChip(spi, DF_SPI_PCS_0);
	
	/*!< Send the byte */
	spi_write(spi,  (U16)Data);
80004888:	48 77       	lddpc	r7,800048a4 <RC522_WriteByte+0x24>
8000488a:	f7 dc c0 08 	bfextu	r11,r12,0x0,0x8
8000488e:	6e 0c       	ld.w	r12,r7[0x0]
80004890:	f0 1f 00 06 	mcall	800048a8 <RC522_WriteByte+0x28>
	
	/*!< Wait to receive a byte*/

	temp = spi_read(spi, (U16*)&Data);
80004894:	1a 9b       	mov	r11,sp
80004896:	6e 0c       	ld.w	r12,r7[0x0]
80004898:	f0 1f 00 05 	mcall	800048ac <RC522_WriteByte+0x2c>
	//spi_unselectChip(spi, DF_SPI_PCS_0);
	
	/*!< Return the byte read from the SPI bus */
	return  temp;

}
8000489c:	5c 5c       	castu.b	r12
8000489e:	2f fd       	sub	sp,-4
800048a0:	e3 cd 80 80 	ldm	sp++,r7,pc
800048a4:	00 00       	add	r0,r0
800048a6:	1d ac       	ld.ub	r12,lr[0x2]
800048a8:	80 00       	ld.sh	r0,r0[0x0]
800048aa:	58 2a       	cp.w	r10,2
800048ac:	80 00       	ld.sh	r0,r0[0x0]
800048ae:	58 46       	cp.w	r6,4

800048b0 <WriteRawRC>:
//    斤RC632瀵瀛
//拌存锛Address[IN]:瀵瀛ㄥ板
//          value[IN]:ョ
/////////////////////////////////////////////////////////////////////
void WriteRawRC(U8   Address, U8   value)
{
800048b0:	eb cd 40 e0 	pushm	r5-r7,lr
800048b4:	18 96       	mov	r6,r12
800048b6:	16 95       	mov	r5,r11
	U8   ucAddr;

	//CLR_SPI_CS;	
	spi_selectChip(spi, DF_SPI_PCS_0);
800048b8:	48 a7       	lddpc	r7,800048e0 <WriteRawRC+0x30>
800048ba:	30 0b       	mov	r11,0
800048bc:	6e 0c       	ld.w	r12,r7[0x0]
800048be:	f0 1f 00 0a 	mcall	800048e4 <WriteRawRC+0x34>
	
	ucAddr = ((Address<<1)&0x7E);
	RC522_WriteByte(ucAddr);
800048c2:	ec 0c 15 01 	lsl	r12,r6,0x1
800048c6:	e2 1c 00 7e 	andl	r12,0x7e,COH
800048ca:	f0 1f 00 08 	mcall	800048e8 <WriteRawRC+0x38>
	RC522_WriteByte(value);
800048ce:	0a 9c       	mov	r12,r5
800048d0:	f0 1f 00 06 	mcall	800048e8 <WriteRawRC+0x38>
	
	spi_unselectChip(spi, DF_SPI_PCS_0);
800048d4:	30 0b       	mov	r11,0
800048d6:	6e 0c       	ld.w	r12,r7[0x0]
800048d8:	f0 1f 00 05 	mcall	800048ec <WriteRawRC+0x3c>
	
	//SET_SPI_CS;

}
800048dc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800048e0:	00 00       	add	r0,r0
800048e2:	1d ac       	ld.ub	r12,lr[0x2]
800048e4:	80 00       	ld.sh	r0,r0[0x0]
800048e6:	59 90       	cp.w	r0,25
800048e8:	80 00       	ld.sh	r0,r0[0x0]
800048ea:	48 80       	lddpc	r0,80004908 <PcdReset+0x18>
800048ec:	80 00       	ld.sh	r0,r0[0x0]
800048ee:	59 50       	cp.w	r0,21

800048f0 <PcdReset>:
/////////////////////////////////////////////////////////////////////
//    斤澶浣RC522
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdReset(void)
{
800048f0:	d4 01       	pushm	lr

	SET_RC522RST;
800048f2:	31 9c       	mov	r12,25
800048f4:	f0 1f 00 1b 	mcall	80004960 <PcdReset+0x70>
	delay_ns(10);
800048f8:	30 ac       	mov	r12,10
800048fa:	f0 1f 00 1b 	mcall	80004964 <PcdReset+0x74>

	CLR_RC522RST;
800048fe:	31 9c       	mov	r12,25
80004900:	f0 1f 00 1a 	mcall	80004968 <PcdReset+0x78>
	delay_ns(10);
80004904:	30 ac       	mov	r12,10
80004906:	f0 1f 00 18 	mcall	80004964 <PcdReset+0x74>

	SET_RC522RST;
8000490a:	31 9c       	mov	r12,25
8000490c:	f0 1f 00 15 	mcall	80004960 <PcdReset+0x70>
	delay_ns(10);
80004910:	30 ac       	mov	r12,10
80004912:	f0 1f 00 15 	mcall	80004964 <PcdReset+0x74>
	WriteRawRC(CommandReg,PCD_RESETPHASE);
80004916:	30 fb       	mov	r11,15
80004918:	30 1c       	mov	r12,1
8000491a:	f0 1f 00 15 	mcall	8000496c <PcdReset+0x7c>
	WriteRawRC(CommandReg,PCD_RESETPHASE);
8000491e:	30 fb       	mov	r11,15
80004920:	30 1c       	mov	r12,1
80004922:	f0 1f 00 13 	mcall	8000496c <PcdReset+0x7c>
	delay_ns(10);
80004926:	30 ac       	mov	r12,10
80004928:	f0 1f 00 0f 	mcall	80004964 <PcdReset+0x74>
	
	WriteRawRC(ModeReg,0x3D);            //Mifare￠璁锛CRC濮0x6363
8000492c:	33 db       	mov	r11,61
8000492e:	31 1c       	mov	r12,17
80004930:	f0 1f 00 0f 	mcall	8000496c <PcdReset+0x7c>
	WriteRawRC(TReloadRegL,30);
80004934:	31 eb       	mov	r11,30
80004936:	32 dc       	mov	r12,45
80004938:	f0 1f 00 0d 	mcall	8000496c <PcdReset+0x7c>
	WriteRawRC(TReloadRegH,0);
8000493c:	30 0b       	mov	r11,0
8000493e:	32 cc       	mov	r12,44
80004940:	f0 1f 00 0b 	mcall	8000496c <PcdReset+0x7c>
	WriteRawRC(TModeReg,0x8D);
80004944:	e0 6b 00 8d 	mov	r11,141
80004948:	32 ac       	mov	r12,42
8000494a:	f0 1f 00 09 	mcall	8000496c <PcdReset+0x7c>
	WriteRawRC(TPrescalerReg,0x3E);
8000494e:	33 eb       	mov	r11,62
80004950:	32 bc       	mov	r12,43
80004952:	f0 1f 00 07 	mcall	8000496c <PcdReset+0x7c>
	
	WriteRawRC(TxAutoReg,0x40);//蹇椤昏
80004956:	34 0b       	mov	r11,64
80004958:	31 5c       	mov	r12,21
8000495a:	f0 1f 00 05 	mcall	8000496c <PcdReset+0x7c>
	
	return MI_OK;
}
8000495e:	d8 0a       	popm	pc,r12=0
80004960:	80 00       	ld.sh	r0,r0[0x0]
80004962:	55 08       	stdsp	sp[0x140],r8
80004964:	80 00       	ld.sh	r0,r0[0x0]
80004966:	52 ac       	stdsp	sp[0xa8],r12
80004968:	80 00       	ld.sh	r0,r0[0x0]
8000496a:	55 24       	stdsp	sp[0x148],r4
8000496c:	80 00       	ld.sh	r0,r0[0x0]
8000496e:	48 b0       	lddpc	r0,80004998 <ReadRawRC+0x28>

80004970 <ReadRawRC>:
//    斤璇RC632瀵瀛
//拌存锛Address[IN]:瀵瀛ㄥ板
//杩    锛璇诲虹
/////////////////////////////////////////////////////////////////////
U8 ReadRawRC(U8   Address)
{
80004970:	eb cd 40 c0 	pushm	r6-r7,lr
80004974:	18 96       	mov	r6,r12
	U8   ucAddr;
	U8   ucResult=0;
	//CLR_SPI_CS;	
	spi_selectChip(spi, DF_SPI_PCS_0);
80004976:	48 c7       	lddpc	r7,800049a4 <ReadRawRC+0x34>
80004978:	30 0b       	mov	r11,0
8000497a:	6e 0c       	ld.w	r12,r7[0x0]
8000497c:	f0 1f 00 0b 	mcall	800049a8 <ReadRawRC+0x38>
	 
	ucAddr = ((Address<<1)&0x7E)|0x80;
	
	RC522_WriteByte(ucAddr);
80004980:	a1 76       	lsl	r6,0x1
80004982:	0c 9c       	mov	r12,r6
80004984:	e2 1c 00 7e 	andl	r12,0x7e,COH
80004988:	a7 bc       	sbr	r12,0x7
8000498a:	f0 1f 00 09 	mcall	800049ac <ReadRawRC+0x3c>
	ucResult = RC522_ReadByte();
8000498e:	f0 1f 00 09 	mcall	800049b0 <ReadRawRC+0x40>
80004992:	18 96       	mov	r6,r12
	
	spi_unselectChip(spi, DF_SPI_PCS_0);
80004994:	30 0b       	mov	r11,0
80004996:	6e 0c       	ld.w	r12,r7[0x0]
80004998:	f0 1f 00 07 	mcall	800049b4 <ReadRawRC+0x44>
	//SET_SPI_CS;
	return ucResult;
}
8000499c:	0c 9c       	mov	r12,r6
8000499e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800049a2:	00 00       	add	r0,r0
800049a4:	00 00       	add	r0,r0
800049a6:	1d ac       	ld.ub	r12,lr[0x2]
800049a8:	80 00       	ld.sh	r0,r0[0x0]
800049aa:	59 90       	cp.w	r0,25
800049ac:	80 00       	ld.sh	r0,r0[0x0]
800049ae:	48 80       	lddpc	r0,800049cc <Powerdown_RC522+0x4>
800049b0:	80 00       	ld.sh	r0,r0[0x0]
800049b2:	48 54       	lddpc	r4,800049c4 <Wait_Wakeup_RC522+0xc>
800049b4:	80 00       	ld.sh	r0,r0[0x0]
800049b6:	59 50       	cp.w	r0,21

800049b8 <Wait_Wakeup_RC522>:

/////////////////////////////////////////////////////////////////////
//    斤绛寰RC522
/////////////////////////////////////////////////////////////////////
void Wait_Wakeup_RC522(void)
{
800049b8:	d4 01       	pushm	lr
	char   tmp = 0x0;
	char   reg = CommandReg;
	
	do 
	{
		tmp = ReadRawRC(reg);
800049ba:	30 1c       	mov	r12,1
800049bc:	f0 1f 00 02 	mcall	800049c4 <Wait_Wakeup_RC522+0xc>
			
	//tmp = ReadRawRC(reg);
	//if((tmp & 0x10) == 0)
	//WriteRawRC(reg,tmp | PCD_POWERDOWN);  // set bit powerdown
	
}
800049c0:	d8 02       	popm	pc
800049c2:	00 00       	add	r0,r0
800049c4:	80 00       	ld.sh	r0,r0[0x0]
800049c6:	49 70       	lddpc	r0,80004a20 <SetBitMask+0xc>

800049c8 <Powerdown_RC522>:
/////////////////////////////////////////////////////////////////////
//    斤浣RC522杩ヨ蒋垫ā寮
//
/////////////////////////////////////////////////////////////////////
void Powerdown_RC522(U8 act)
{
800049c8:	eb cd 40 80 	pushm	r7,lr
800049cc:	18 97       	mov	r7,r12
	char   tmp = 0x0;
	char   reg = CommandReg;
	
	tmp = ReadRawRC(reg);
800049ce:	30 1c       	mov	r12,1
800049d0:	f0 1f 00 0d 	mcall	80004a04 <Powerdown_RC522+0x3c>
	if(act == ENTER_POWERDOWN)//1
800049d4:	30 18       	mov	r8,1
800049d6:	f0 07 18 00 	cp.b	r7,r8
800049da:	c0 91       	brne	800049ec <Powerdown_RC522+0x24>
		WriteRawRC(reg,tmp | PCD_POWERDOWN);  // set bit powerdown
800049dc:	18 9b       	mov	r11,r12
800049de:	a5 ab       	sbr	r11,0x4
800049e0:	5c 5b       	castu.b	r11
800049e2:	30 1c       	mov	r12,1
800049e4:	f0 1f 00 09 	mcall	80004a08 <Powerdown_RC522+0x40>
800049e8:	e3 cd 80 80 	ldm	sp++,r7,pc
	else
	{
		WriteRawRC(reg,tmp | PCD_IDLE);  // wake up rc522
800049ec:	18 9b       	mov	r11,r12
800049ee:	30 1c       	mov	r12,1
800049f0:	f0 1f 00 06 	mcall	80004a08 <Powerdown_RC522+0x40>
		delay_ns(2);
800049f4:	30 2c       	mov	r12,2
800049f6:	f0 1f 00 06 	mcall	80004a0c <Powerdown_RC522+0x44>
		Wait_Wakeup_RC522();
800049fa:	f0 1f 00 06 	mcall	80004a10 <Powerdown_RC522+0x48>
800049fe:	e3 cd 80 80 	ldm	sp++,r7,pc
80004a02:	00 00       	add	r0,r0
80004a04:	80 00       	ld.sh	r0,r0[0x0]
80004a06:	49 70       	lddpc	r0,80004a60 <ClearBitMask+0x8>
80004a08:	80 00       	ld.sh	r0,r0[0x0]
80004a0a:	48 b0       	lddpc	r0,80004a34 <SetBitMask+0x20>
80004a0c:	80 00       	ld.sh	r0,r0[0x0]
80004a0e:	52 ac       	stdsp	sp[0xa8],r12
80004a10:	80 00       	ld.sh	r0,r0[0x0]
80004a12:	49 b8       	lddpc	r8,80004a7c <ClearBitMask+0x24>

80004a14 <SetBitMask>:
//    斤缃RC522瀵瀛ㄤ
//拌存锛reg[IN]:瀵瀛ㄥ板
//          mask[IN]:缃浣
/////////////////////////////////////////////////////////////////////
void SetBitMask(U8   reg,U8   mask)
{
80004a14:	eb cd 40 c0 	pushm	r6-r7,lr
80004a18:	18 97       	mov	r7,r12
80004a1a:	16 96       	mov	r6,r11
	char   tmp = 0x0;
	tmp = ReadRawRC(reg);
80004a1c:	f0 1f 00 05 	mcall	80004a30 <SetBitMask+0x1c>
	WriteRawRC(reg,tmp | mask);  // set bit mask
80004a20:	f9 e6 10 0b 	or	r11,r12,r6
80004a24:	5c 5b       	castu.b	r11
80004a26:	0e 9c       	mov	r12,r7
80004a28:	f0 1f 00 03 	mcall	80004a34 <SetBitMask+0x20>
}
80004a2c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004a30:	80 00       	ld.sh	r0,r0[0x0]
80004a32:	49 70       	lddpc	r0,80004a8c <PcdAntennaOff+0xc>
80004a34:	80 00       	ld.sh	r0,r0[0x0]
80004a36:	48 b0       	lddpc	r0,80004a60 <ClearBitMask+0x8>

80004a38 <PcdAntennaOn>:
/////////////////////////////////////////////////////////////////////
//寮澶╃嚎
//姣娆″ㄦ抽澶╅╁灏涔村冲1ms撮
/////////////////////////////////////////////////////////////////////
void PcdAntennaOn(void)
{
80004a38:	d4 01       	pushm	lr
	U8   i;
	i = ReadRawRC(TxControlReg);
80004a3a:	31 4c       	mov	r12,20
80004a3c:	f0 1f 00 05 	mcall	80004a50 <PcdAntennaOn+0x18>
	if (!(i & 0x03))
80004a40:	f9 dc c0 02 	bfextu	r12,r12,0x0,0x2
80004a44:	c0 51       	brne	80004a4e <PcdAntennaOn+0x16>
	{
		SetBitMask(TxControlReg, 0x03);
80004a46:	30 3b       	mov	r11,3
80004a48:	31 4c       	mov	r12,20
80004a4a:	f0 1f 00 03 	mcall	80004a54 <PcdAntennaOn+0x1c>
80004a4e:	d8 02       	popm	pc
80004a50:	80 00       	ld.sh	r0,r0[0x0]
80004a52:	49 70       	lddpc	r0,80004aac <M500PcdConfigISOType+0x1c>
80004a54:	80 00       	ld.sh	r0,r0[0x0]
80004a56:	4a 14       	lddpc	r4,80004ad8 <M500PcdConfigISOType+0x48>

80004a58 <ClearBitMask>:
//    斤娓RC522瀵瀛ㄤ
//拌存锛reg[IN]:瀵瀛ㄥ板
//         mask[IN]:娓浣
/////////////////////////////////////////////////////////////////////
void ClearBitMask(U8   reg,U8   mask)
{
80004a58:	eb cd 40 c0 	pushm	r6-r7,lr
80004a5c:	18 97       	mov	r7,r12
80004a5e:	16 96       	mov	r6,r11
	  char   tmp = 0x0;
	  tmp = ReadRawRC(reg);
80004a60:	f0 1f 00 06 	mcall	80004a78 <ClearBitMask+0x20>
	  WriteRawRC(reg, tmp & ~mask);  // clear bit mask
80004a64:	5c d6       	com	r6
80004a66:	f9 e6 00 06 	and	r6,r12,r6
80004a6a:	f7 d6 c0 08 	bfextu	r11,r6,0x0,0x8
80004a6e:	0e 9c       	mov	r12,r7
80004a70:	f0 1f 00 03 	mcall	80004a7c <ClearBitMask+0x24>
	
}
80004a74:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004a78:	80 00       	ld.sh	r0,r0[0x0]
80004a7a:	49 70       	lddpc	r0,80004ad4 <M500PcdConfigISOType+0x44>
80004a7c:	80 00       	ld.sh	r0,r0[0x0]
80004a7e:	48 b0       	lddpc	r0,80004aa8 <M500PcdConfigISOType+0x18>

80004a80 <PcdAntennaOff>:

/////////////////////////////////////////////////////////////////////
//抽澶╃嚎
/////////////////////////////////////////////////////////////////////
void PcdAntennaOff(void)
{
80004a80:	d4 01       	pushm	lr
	ClearBitMask(TxControlReg, 0x03);
80004a82:	30 3b       	mov	r11,3
80004a84:	31 4c       	mov	r12,20
80004a86:	f0 1f 00 02 	mcall	80004a8c <PcdAntennaOff+0xc>
}
80004a8a:	d8 02       	popm	pc
80004a8c:	80 00       	ld.sh	r0,r0[0x0]
80004a8e:	4a 58       	lddpc	r8,80004b20 <rc522_init+0x20>

80004a90 <M500PcdConfigISOType>:

//////////////////////////////////////////////////////////////////////
//璁剧疆RC632宸ヤ瑰
//////////////////////////////////////////////////////////////////////
char M500PcdConfigISOType(U8   type)
{
80004a90:	d4 01       	pushm	lr
	if (type == 'A')                     //ISO14443_A
80004a92:	34 18       	mov	r8,65
80004a94:	f0 0c 18 00 	cp.b	r12,r8
80004a98:	c0 20       	breq	80004a9c <M500PcdConfigISOType+0xc>
80004a9a:	da 0a       	popm	pc,r12=1
	{
		ClearBitMask(Status2Reg,0x08);
80004a9c:	30 8b       	mov	r11,8
80004a9e:	16 9c       	mov	r12,r11
80004aa0:	f0 1f 00 14 	mcall	80004af0 <M500PcdConfigISOType+0x60>
		WriteRawRC(ModeReg,0x3D);//3F
80004aa4:	33 db       	mov	r11,61
80004aa6:	31 1c       	mov	r12,17
80004aa8:	f0 1f 00 13 	mcall	80004af4 <M500PcdConfigISOType+0x64>
		WriteRawRC(RxSelReg,0x86);//84
80004aac:	e0 6b 00 86 	mov	r11,134
80004ab0:	31 7c       	mov	r12,23
80004ab2:	f0 1f 00 11 	mcall	80004af4 <M500PcdConfigISOType+0x64>
		WriteRawRC(RFCfgReg,0x7F);   //4F
80004ab6:	37 fb       	mov	r11,127
80004ab8:	32 6c       	mov	r12,38
80004aba:	f0 1f 00 0f 	mcall	80004af4 <M500PcdConfigISOType+0x64>
		WriteRawRC(TReloadRegL,30);//tmoLength);// TReloadVal = 'h6a =tmoLength(dec)
80004abe:	31 eb       	mov	r11,30
80004ac0:	32 dc       	mov	r12,45
80004ac2:	f0 1f 00 0d 	mcall	80004af4 <M500PcdConfigISOType+0x64>
		WriteRawRC(TReloadRegH,0);
80004ac6:	30 0b       	mov	r11,0
80004ac8:	32 cc       	mov	r12,44
80004aca:	f0 1f 00 0b 	mcall	80004af4 <M500PcdConfigISOType+0x64>
		WriteRawRC(TModeReg,0x8D);
80004ace:	e0 6b 00 8d 	mov	r11,141
80004ad2:	32 ac       	mov	r12,42
80004ad4:	f0 1f 00 08 	mcall	80004af4 <M500PcdConfigISOType+0x64>
		WriteRawRC(TPrescalerReg,0x3E);
80004ad8:	33 eb       	mov	r11,62
80004ada:	32 bc       	mov	r12,43
80004adc:	f0 1f 00 06 	mcall	80004af4 <M500PcdConfigISOType+0x64>
		delay_ns(1000);
80004ae0:	e0 6c 03 e8 	mov	r12,1000
80004ae4:	f0 1f 00 05 	mcall	80004af8 <M500PcdConfigISOType+0x68>
		PcdAntennaOn();
80004ae8:	f0 1f 00 05 	mcall	80004afc <M500PcdConfigISOType+0x6c>
80004aec:	d8 0a       	popm	pc,r12=0
80004aee:	00 00       	add	r0,r0
80004af0:	80 00       	ld.sh	r0,r0[0x0]
80004af2:	4a 58       	lddpc	r8,80004b84 <rc522_init+0x84>
80004af4:	80 00       	ld.sh	r0,r0[0x0]
80004af6:	48 b0       	lddpc	r0,80004b20 <rc522_init+0x20>
80004af8:	80 00       	ld.sh	r0,r0[0x0]
80004afa:	52 ac       	stdsp	sp[0xa8],r12
80004afc:	80 00       	ld.sh	r0,r0[0x0]
80004afe:	4a 38       	lddpc	r8,80004b88 <rc522_init+0x88>

80004b00 <rc522_init>:


//mfrc522 init

void rc522_init()
{
80004b00:	eb cd 40 c0 	pushm	r6-r7,lr
80004b04:	20 4d       	sub	sp,16
		.spck_delay   = 0,
		.trans_delay  = 0,
		.stay_act     = 1,
		.spi_mode     = 0,
		.modfdis      = 1
	};
80004b06:	4a 38       	lddpc	r8,80004b90 <rc522_init+0x90>
80004b08:	1a 96       	mov	r6,sp
80004b0a:	f0 ea 00 00 	ld.d	r10,r8[0]
80004b0e:	fa eb 00 00 	st.d	sp[0],r10
80004b12:	f0 e8 00 08 	ld.d	r8,r8[8]
80004b16:	fa e9 00 08 	st.d	sp[8],r8

	// Assign I/Os to SPI.
	gpio_enable_module(RC522_SPI_GPIO_MAP, sizeof(RC522_SPI_GPIO_MAP) / sizeof(RC522_SPI_GPIO_MAP[0]));
80004b1a:	30 4b       	mov	r11,4
80004b1c:	49 ec       	lddpc	r12,80004b94 <rc522_init+0x94>
80004b1e:	f0 1f 00 1f 	mcall	80004b98 <rc522_init+0x98>

	// Configure PA25 as RST pin
	gpio_enable_gpio_pin(AVR32_PIN_PA25);
80004b22:	31 9c       	mov	r12,25
80004b24:	f0 1f 00 1e 	mcall	80004b9c <rc522_init+0x9c>
	gpio_set_gpio_pin(AVR32_PIN_PA25);
80004b28:	31 9c       	mov	r12,25
80004b2a:	f0 1f 00 1e 	mcall	80004ba0 <rc522_init+0xa0>

	spi = &AVR32_SPI;
80004b2e:	49 e7       	lddpc	r7,80004ba4 <rc522_init+0xa4>
80004b30:	fe 7c 24 00 	mov	r12,-56320
80004b34:	8f 0c       	st.w	r7[0x0],r12

	// Initialize as master.
	spi_initMaster(spi, &spiOptions);
80004b36:	1a 9b       	mov	r11,sp
80004b38:	f0 1f 00 1c 	mcall	80004ba8 <rc522_init+0xa8>

	// Set selection mode: variable_ps, pcs_decode, delay.
	spi_selectionMode(spi, 0, 0, 0);
80004b3c:	30 09       	mov	r9,0
80004b3e:	12 9a       	mov	r10,r9
80004b40:	12 9b       	mov	r11,r9
80004b42:	6e 0c       	ld.w	r12,r7[0x0]
80004b44:	f0 1f 00 1a 	mcall	80004bac <rc522_init+0xac>

	// Enable SPI.
	spi_enable(spi);
80004b48:	6e 0c       	ld.w	r12,r7[0x0]
80004b4a:	f0 1f 00 1a 	mcall	80004bb0 <rc522_init+0xb0>

	// Initialize RC522 with SPI clock PBA.
	if (spi_setupChipReg(spi, &spiOptions, 2*12000000) != SPI_OK)
80004b4e:	e0 6a 36 00 	mov	r10,13824
80004b52:	ea 1a 01 6e 	orh	r10,0x16e
80004b56:	1a 9b       	mov	r11,sp
80004b58:	6e 0c       	ld.w	r12,r7[0x0]
80004b5a:	f0 1f 00 17 	mcall	80004bb4 <rc522_init+0xb4>
80004b5e:	c0 50       	breq	80004b68 <rc522_init+0x68>
	{
		
		rc522_init_failure = FATAL_ERROR_RC522_SPI_INIT;
80004b60:	30 29       	mov	r9,2
80004b62:	49 68       	lddpc	r8,80004bb8 <rc522_init+0xb8>
80004b64:	b0 89       	st.b	r8[0x0],r9
80004b66:	c0 38       	rjmp	80004b6c <rc522_init+0x6c>
		return;
	}
	
	RC522_SPI_SetSpeedLow();
80004b68:	f0 1f 00 15 	mcall	80004bbc <rc522_init+0xbc>
void rc522_init()
{
	
	spi_init();
	
	PcdReset();
80004b6c:	f0 1f 00 15 	mcall	80004bc0 <rc522_init+0xc0>
	
	PcdAntennaOff();
80004b70:	f0 1f 00 15 	mcall	80004bc4 <rc522_init+0xc4>
	
	delay_ms(2); 
80004b74:	30 2c       	mov	r12,2
80004b76:	f0 1f 00 15 	mcall	80004bc8 <rc522_init+0xc8>
	
	PcdAntennaOn();
80004b7a:	f0 1f 00 15 	mcall	80004bcc <rc522_init+0xcc>
	
	M500PcdConfigISOType( 'A' );
80004b7e:	34 1c       	mov	r12,65
80004b80:	f0 1f 00 14 	mcall	80004bd0 <rc522_init+0xd0>
	
	Powerdown_RC522(ENTER_POWERDOWN);
80004b84:	30 1c       	mov	r12,1
80004b86:	f0 1f 00 14 	mcall	80004bd4 <rc522_init+0xd4>
	//Powerdown_RC522(ENTER_POWERDOWN);
	
	//Powerdown_RC522(WAKEUP_RC522);
	

80004b8a:	2f cd       	sub	sp,-16
80004b8c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004b90:	80 00       	ld.sh	r0,r0[0x0]
80004b92:	d8 58       	*unknown*
80004b94:	80 00       	ld.sh	r0,r0[0x0]
80004b96:	d8 68       	*unknown*
80004b98:	80 00       	ld.sh	r0,r0[0x0]
80004b9a:	54 c0       	stdsp	sp[0x130],r0
80004b9c:	80 00       	ld.sh	r0,r0[0x0]
80004b9e:	54 f0       	stdsp	sp[0x13c],r0
80004ba0:	80 00       	ld.sh	r0,r0[0x0]
80004ba2:	55 08       	stdsp	sp[0x140],r8
80004ba4:	00 00       	add	r0,r0
80004ba6:	1d ac       	ld.ub	r12,lr[0x2]
80004ba8:	80 00       	ld.sh	r0,r0[0x0]
80004baa:	57 c0       	stdsp	sp[0x1f0],r0
80004bac:	80 00       	ld.sh	r0,r0[0x0]
80004bae:	57 f8       	stdsp	sp[0x1fc],r8
80004bb0:	80 00       	ld.sh	r0,r0[0x0]
80004bb2:	58 24       	cp.w	r4,2
80004bb4:	80 00       	ld.sh	r0,r0[0x0]
80004bb6:	58 68       	cp.w	r8,6
80004bb8:	00 00       	add	r0,r0
80004bba:	0b 64       	ld.uh	r4,--r5
80004bbc:	80 00       	ld.sh	r0,r0[0x0]
80004bbe:	48 44       	lddpc	r4,80004bcc <rc522_init+0xcc>
80004bc0:	80 00       	ld.sh	r0,r0[0x0]
80004bc2:	48 f0       	lddpc	r0,80004bfc <PcdComMF522+0x24>
80004bc4:	80 00       	ld.sh	r0,r0[0x0]
80004bc6:	4a 80       	lddpc	r0,80004c64 <PcdComMF522+0x8c>
80004bc8:	80 00       	ld.sh	r0,r0[0x0]
80004bca:	52 ec       	stdsp	sp[0xb8],r12
80004bcc:	80 00       	ld.sh	r0,r0[0x0]
80004bce:	4a 38       	lddpc	r8,80004c58 <PcdComMF522+0x80>
80004bd0:	80 00       	ld.sh	r0,r0[0x0]
80004bd2:	4a 90       	lddpc	r0,80004c74 <PcdComMF522+0x9c>
80004bd4:	80 00       	ld.sh	r0,r0[0x0]
80004bd6:	49 c8       	lddpc	r8,80004c44 <PcdComMF522+0x6c>

80004bd8 <PcdComMF522>:
char PcdComMF522(U8  Command,
				 U8 *pIn ,
				 U8  InLenByte,
				 U8 *pOut ,
				 U8 *pOutLenBit)
{
80004bd8:	d4 31       	pushm	r0-r7,lr
80004bda:	20 1d       	sub	sp,4
80004bdc:	18 92       	mov	r2,r12
80004bde:	16 95       	mov	r5,r11
80004be0:	14 96       	mov	r6,r10
80004be2:	50 09       	stdsp	sp[0x0],r9
80004be4:	10 90       	mov	r0,r8
80004be6:	f8 c8 00 0c 	sub	r8,r12,12
80004bea:	5c 58       	castu.b	r8
80004bec:	30 29       	mov	r9,2
80004bee:	f2 08 18 00 	cp.b	r8,r9
80004bf2:	e0 88 00 05 	brls	80004bfc <PcdComMF522+0x24>
80004bf6:	30 03       	mov	r3,0
80004bf8:	06 91       	mov	r1,r3
80004bfa:	c0 78       	rjmp	80004c08 <PcdComMF522+0x30>
80004bfc:	4c f9       	lddpc	r9,80004d38 <PcdComMF522+0x160>
80004bfe:	f2 08 07 01 	ld.ub	r1,r9[r8]
80004c02:	4c f9       	lddpc	r9,80004d3c <PcdComMF522+0x164>
80004c04:	f2 08 07 03 	ld.ub	r3,r9[r8]
		break;
		default:
		break;
	}
	
	WriteRawRC(ComIEnReg,irqEn|0x80);
80004c08:	02 9b       	mov	r11,r1
80004c0a:	a7 bb       	sbr	r11,0x7
80004c0c:	30 2c       	mov	r12,2
80004c0e:	f0 1f 00 4d 	mcall	80004d40 <PcdComMF522+0x168>
	ClearBitMask(ComIrqReg,0x80);	//娓涓浣
80004c12:	e0 6b 00 80 	mov	r11,128
80004c16:	30 4c       	mov	r12,4
80004c18:	f0 1f 00 4b 	mcall	80004d44 <PcdComMF522+0x16c>
	WriteRawRC(CommandReg,PCD_IDLE);
80004c1c:	30 0b       	mov	r11,0
80004c1e:	30 1c       	mov	r12,1
80004c20:	f0 1f 00 48 	mcall	80004d40 <PcdComMF522+0x168>
	SetBitMask(FIFOLevelReg,0x80);	 	//娓FIFO缂瀛
80004c24:	e0 6b 00 80 	mov	r11,128
80004c28:	30 ac       	mov	r12,10
80004c2a:	f0 1f 00 48 	mcall	80004d48 <PcdComMF522+0x170>
	
	for (i=0; i<InLenByte; i++)
80004c2e:	58 06       	cp.w	r6,0
80004c30:	c0 c0       	breq	80004c48 <PcdComMF522+0x70>
80004c32:	0a 97       	mov	r7,r5
	{   
		WriteRawRC(FIFODataReg, pIn [i]);
80004c34:	30 94       	mov	r4,9
80004c36:	0f 3b       	ld.ub	r11,r7++
80004c38:	08 9c       	mov	r12,r4
80004c3a:	f0 1f 00 42 	mcall	80004d40 <PcdComMF522+0x168>
	WriteRawRC(ComIEnReg,irqEn|0x80);
	ClearBitMask(ComIrqReg,0x80);	//娓涓浣
	WriteRawRC(CommandReg,PCD_IDLE);
	SetBitMask(FIFOLevelReg,0x80);	 	//娓FIFO缂瀛
	
	for (i=0; i<InLenByte; i++)
80004c3e:	0e 98       	mov	r8,r7
80004c40:	0a 18       	sub	r8,r5
80004c42:	ec 08 19 00 	cp.h	r8,r6
80004c46:	cf 83       	brcs	80004c36 <PcdComMF522+0x5e>
	{   
		WriteRawRC(FIFODataReg, pIn [i]);
	}
	WriteRawRC(CommandReg, Command);
80004c48:	04 9b       	mov	r11,r2
80004c4a:	30 1c       	mov	r12,1
80004c4c:	f0 1f 00 3d 	mcall	80004d40 <PcdComMF522+0x168>
	
	if (Command == PCD_TRANSCEIVE)
80004c50:	30 c8       	mov	r8,12
80004c52:	f0 02 18 00 	cp.b	r2,r8
80004c56:	c0 61       	brne	80004c62 <PcdComMF522+0x8a>
	{    
		SetBitMask(BitFramingReg,0x80);  
80004c58:	e0 6b 00 80 	mov	r11,128
80004c5c:	30 dc       	mov	r12,13
80004c5e:	f0 1f 00 3b 	mcall	80004d48 <PcdComMF522+0x170>
	
	//i = 600;//规堕棰璋达浣M1℃澶х寰堕25ms
	i = 2000;
	do
	{
		n = ReadRawRC(ComIrqReg);
80004c62:	30 4c       	mov	r12,4
80004c64:	f0 1f 00 3a 	mcall	80004d4c <PcdComMF522+0x174>
80004c68:	18 97       	mov	r7,r12
80004c6a:	e0 66 07 cf 	mov	r6,1999
		i--;
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
80004c6e:	30 05       	mov	r5,0
	
	//i = 600;//规堕棰璋达浣M1℃澶х寰堕25ms
	i = 2000;
	do
	{
		n = ReadRawRC(ComIrqReg);
80004c70:	30 44       	mov	r4,4
80004c72:	c0 88       	rjmp	80004c82 <PcdComMF522+0xaa>
80004c74:	08 9c       	mov	r12,r4
80004c76:	f0 1f 00 36 	mcall	80004d4c <PcdComMF522+0x174>
80004c7a:	18 97       	mov	r7,r12
		i--;
80004c7c:	20 16       	sub	r6,1
80004c7e:	5c 86       	casts.h	r6
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
80004c80:	c0 a0       	breq	80004c94 <PcdComMF522+0xbc>
80004c82:	f1 d7 c0 01 	bfextu	r8,r7,0x0,0x1
80004c86:	c4 c1       	brne	80004d1e <PcdComMF522+0x146>
80004c88:	ef e3 00 08 	and	r8,r7,r3
80004c8c:	ea 08 18 00 	cp.b	r8,r5
80004c90:	cf 20       	breq	80004c74 <PcdComMF522+0x9c>
80004c92:	c4 68       	rjmp	80004d1e <PcdComMF522+0x146>
	ClearBitMask(BitFramingReg,0x80);
80004c94:	e0 6b 00 80 	mov	r11,128
80004c98:	30 dc       	mov	r12,13
80004c9a:	f0 1f 00 2b 	mcall	80004d44 <PcdComMF522+0x16c>
80004c9e:	30 27       	mov	r7,2
80004ca0:	c3 38       	rjmp	80004d06 <PcdComMF522+0x12e>
80004ca2:	02 67       	and	r7,r1
80004ca4:	ef d7 c0 01 	bfextu	r7,r7,0x0,0x1
		if(!(ReadRawRC(ErrorReg)&0x1B))
		{
			status = MI_OK;
			if (n & irqEn & 0x01)
			{   status = MI_NOTAGERR;   }
			if (Command == PCD_TRANSCEIVE)
80004ca8:	30 c8       	mov	r8,12
80004caa:	f0 02 18 00 	cp.b	r2,r8
80004cae:	c2 c1       	brne	80004d06 <PcdComMF522+0x12e>
			{
				n = ReadRawRC(FIFOLevelReg);
80004cb0:	30 ac       	mov	r12,10
80004cb2:	f0 1f 00 27 	mcall	80004d4c <PcdComMF522+0x174>
80004cb6:	18 94       	mov	r4,r12
				lastBits = ReadRawRC(ControlReg) & 0x07;
80004cb8:	30 cc       	mov	r12,12
80004cba:	f0 1f 00 25 	mcall	80004d4c <PcdComMF522+0x174>
80004cbe:	f9 dc c0 03 	bfextu	r12,r12,0x0,0x3
				if (lastBits)
80004cc2:	c0 70       	breq	80004cd0 <PcdComMF522+0xf8>
				{   *pOutLenBit = (n-1)*8 + lastBits;   }
80004cc4:	08 98       	mov	r8,r4
80004cc6:	20 18       	sub	r8,1
80004cc8:	f8 08 00 3c 	add	r12,r12,r8<<0x3
80004ccc:	a0 8c       	st.b	r0[0x0],r12
80004cce:	c0 48       	rjmp	80004cd6 <PcdComMF522+0xfe>
				else
				{   *pOutLenBit = n*8;   }
80004cd0:	e8 08 15 03 	lsl	r8,r4,0x3
80004cd4:	a0 88       	st.b	r0[0x0],r8
				if (n == 0)
80004cd6:	58 04       	cp.w	r4,0
80004cd8:	c0 61       	brne	80004ce4 <PcdComMF522+0x10c>
80004cda:	30 14       	mov	r4,1
80004cdc:	40 05       	lddsp	r5,sp[0x0]
80004cde:	0a 96       	mov	r6,r5
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
				{   pOut [i] = ReadRawRC(FIFODataReg);    }
80004ce0:	30 93       	mov	r3,9
80004ce2:	c0 98       	rjmp	80004cf4 <PcdComMF522+0x11c>
				{   *pOutLenBit = n*8;   }
				if (n == 0)
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
80004ce4:	31 28       	mov	r8,18
80004ce6:	f0 04 18 00 	cp.b	r4,r8
80004cea:	f9 b4 0b 12 	movhi	r4,18
80004cee:	58 04       	cp.w	r4,0
80004cf0:	cf 61       	brne	80004cdc <PcdComMF522+0x104>
80004cf2:	c0 a8       	rjmp	80004d06 <PcdComMF522+0x12e>
				{   pOut [i] = ReadRawRC(FIFODataReg);    }
80004cf4:	06 9c       	mov	r12,r3
80004cf6:	f0 1f 00 16 	mcall	80004d4c <PcdComMF522+0x174>
80004cfa:	0c cc       	st.b	r6++,r12
				{   *pOutLenBit = n*8;   }
				if (n == 0)
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
80004cfc:	ec 05 01 08 	sub	r8,r6,r5
80004d00:	e8 08 19 00 	cp.h	r8,r4
80004d04:	cf 83       	brcs	80004cf4 <PcdComMF522+0x11c>
		{   status = MI_ERR;   }
		
	}
	

	SetBitMask(ControlReg,0x80);           // stop timer now
80004d06:	e0 6b 00 80 	mov	r11,128
80004d0a:	30 cc       	mov	r12,12
80004d0c:	f0 1f 00 0f 	mcall	80004d48 <PcdComMF522+0x170>
	WriteRawRC(CommandReg,PCD_IDLE);
80004d10:	30 0b       	mov	r11,0
80004d12:	30 1c       	mov	r12,1
80004d14:	f0 1f 00 0b 	mcall	80004d40 <PcdComMF522+0x168>
	return status;
}
80004d18:	0e 9c       	mov	r12,r7
80004d1a:	2f fd       	sub	sp,-4
80004d1c:	d8 32       	popm	r0-r7,pc
	{
		n = ReadRawRC(ComIrqReg);
		i--;
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
	ClearBitMask(BitFramingReg,0x80);
80004d1e:	e0 6b 00 80 	mov	r11,128
80004d22:	30 dc       	mov	r12,13
80004d24:	f0 1f 00 08 	mcall	80004d44 <PcdComMF522+0x16c>

	if (i!=0)
	{
		if(!(ReadRawRC(ErrorReg)&0x1B))
80004d28:	30 6c       	mov	r12,6
80004d2a:	f0 1f 00 09 	mcall	80004d4c <PcdComMF522+0x174>
80004d2e:	e2 1c 00 1b 	andl	r12,0x1b,COH
80004d32:	cb 80       	breq	80004ca2 <PcdComMF522+0xca>
80004d34:	30 27       	mov	r7,2
80004d36:	ce 8b       	rjmp	80004d06 <PcdComMF522+0x12e>
80004d38:	80 00       	ld.sh	r0,r0[0x0]
80004d3a:	d8 50       	acall	0x85
80004d3c:	80 00       	ld.sh	r0,r0[0x0]
80004d3e:	d8 54       	*unknown*
80004d40:	80 00       	ld.sh	r0,r0[0x0]
80004d42:	48 b0       	lddpc	r0,80004d6c <PcdAnticoll+0x1c>
80004d44:	80 00       	ld.sh	r0,r0[0x0]
80004d46:	4a 58       	lddpc	r8,80004dd8 <PcdRequest+0x4>
80004d48:	80 00       	ld.sh	r0,r0[0x0]
80004d4a:	4a 14       	lddpc	r4,80004dcc <PcdAnticoll+0x7c>
80004d4c:	80 00       	ld.sh	r0,r0[0x0]
80004d4e:	49 70       	lddpc	r0,80004da8 <PcdAnticoll+0x58>

80004d50 <PcdAnticoll>:
//    斤插叉
//拌存: pSnr[OUT]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdAnticoll(U8 *pSnr)
{
80004d50:	eb cd 40 c0 	pushm	r6-r7,lr
80004d54:	20 5d       	sub	sp,20
80004d56:	18 96       	mov	r6,r12
	U8   i,snr_check=0;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];
	

	ClearBitMask(Status2Reg,0x08);
80004d58:	30 8b       	mov	r11,8
80004d5a:	16 9c       	mov	r12,r11
80004d5c:	f0 1f 00 1a 	mcall	80004dc4 <PcdAnticoll+0x74>
	WriteRawRC(BitFramingReg,0x00);
80004d60:	30 0b       	mov	r11,0
80004d62:	30 dc       	mov	r12,13
80004d64:	f0 1f 00 19 	mcall	80004dc8 <PcdAnticoll+0x78>
	ClearBitMask(CollReg,0x80);
80004d68:	e0 6b 00 80 	mov	r11,128
80004d6c:	30 ec       	mov	r12,14
80004d6e:	f0 1f 00 16 	mcall	80004dc4 <PcdAnticoll+0x74>
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
80004d72:	39 38       	mov	r8,-109
80004d74:	ba 88       	st.b	sp[0x0],r8
	ucComMF522Buf[1] = 0x20;
80004d76:	32 08       	mov	r8,32
80004d78:	ba 98       	st.b	sp[0x1],r8

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,2,ucComMF522Buf,&unLen);
80004d7a:	1a 9b       	mov	r11,sp
80004d7c:	fa c8 ff ed 	sub	r8,sp,-19
80004d80:	1a 99       	mov	r9,sp
80004d82:	30 2a       	mov	r10,2
80004d84:	30 cc       	mov	r12,12
80004d86:	f0 1f 00 12 	mcall	80004dcc <PcdAnticoll+0x7c>
80004d8a:	18 97       	mov	r7,r12

	if (status == MI_OK)
80004d8c:	c1 21       	brne	80004db0 <PcdAnticoll+0x60>
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
80004d8e:	1b 89       	ld.ub	r9,sp[0x0]
80004d90:	ac 89       	st.b	r6[0x0],r9
80004d92:	1b 98       	ld.ub	r8,sp[0x1]
80004d94:	ac 98       	st.b	r6[0x1],r8
			snr_check ^= ucComMF522Buf[i];
80004d96:	10 59       	eor	r9,r8

	if (status == MI_OK)
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
80004d98:	1b a8       	ld.ub	r8,sp[0x2]
80004d9a:	ac a8       	st.b	r6[0x2],r8
			snr_check ^= ucComMF522Buf[i];
80004d9c:	f3 e8 20 08 	eor	r8,r9,r8

	if (status == MI_OK)
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
80004da0:	1b b9       	ld.ub	r9,sp[0x3]
80004da2:	ac b9       	st.b	r6[0x3],r9
			snr_check ^= ucComMF522Buf[i];
80004da4:	12 58       	eor	r8,r9
		}
		if (snr_check != ucComMF522Buf[i])
80004da6:	1b c9       	ld.ub	r9,sp[0x4]
80004da8:	f0 09 18 00 	cp.b	r9,r8
80004dac:	f9 b7 01 02 	movne	r7,2
		{   status = MI_ERR;    }
	}
	
	SetBitMask(CollReg,0x80);
80004db0:	e0 6b 00 80 	mov	r11,128
80004db4:	30 ec       	mov	r12,14
80004db6:	f0 1f 00 07 	mcall	80004dd0 <PcdAnticoll+0x80>
	return status;
}
80004dba:	0e 9c       	mov	r12,r7
80004dbc:	2f bd       	sub	sp,-20
80004dbe:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004dc2:	00 00       	add	r0,r0
80004dc4:	80 00       	ld.sh	r0,r0[0x0]
80004dc6:	4a 58       	lddpc	r8,80004e58 <CalulateCRC+0x20>
80004dc8:	80 00       	ld.sh	r0,r0[0x0]
80004dca:	48 b0       	lddpc	r0,80004df4 <PcdRequest+0x20>
80004dcc:	80 00       	ld.sh	r0,r0[0x0]
80004dce:	4b d8       	lddpc	r8,80004ec0 <CalulateCRC+0x88>
80004dd0:	80 00       	ld.sh	r0,r0[0x0]
80004dd2:	4a 14       	lddpc	r4,80004e54 <CalulateCRC+0x1c>

80004dd4 <PcdRequest>:
//                0x0800 = Mifare_Pro(X)
//                0x4403 = Mifare_DESFire
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdRequest(U8   req_code,U8 *pTagType)
{
80004dd4:	eb cd 40 c0 	pushm	r6-r7,lr
80004dd8:	20 5d       	sub	sp,20
80004dda:	18 97       	mov	r7,r12
80004ddc:	16 96       	mov	r6,r11
	char   status;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];

	ClearBitMask(Status2Reg,0x08);
80004dde:	30 8b       	mov	r11,8
80004de0:	16 9c       	mov	r12,r11
80004de2:	f0 1f 00 12 	mcall	80004e28 <PcdRequest+0x54>
	WriteRawRC(BitFramingReg,0x07);
80004de6:	30 7b       	mov	r11,7
80004de8:	30 dc       	mov	r12,13
80004dea:	f0 1f 00 11 	mcall	80004e2c <PcdRequest+0x58>
	SetBitMask(TxControlReg,0x03);
80004dee:	30 3b       	mov	r11,3
80004df0:	31 4c       	mov	r12,20
80004df2:	f0 1f 00 10 	mcall	80004e30 <PcdRequest+0x5c>
	
	ucComMF522Buf[0] = req_code;
80004df6:	ba 87       	st.b	sp[0x0],r7

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,1,ucComMF522Buf,&unLen);
80004df8:	1a 9b       	mov	r11,sp
80004dfa:	fa c8 ff ed 	sub	r8,sp,-19
80004dfe:	1a 99       	mov	r9,sp
80004e00:	30 1a       	mov	r10,1
80004e02:	30 cc       	mov	r12,12
80004e04:	f0 1f 00 0c 	mcall	80004e34 <PcdRequest+0x60>

	if ((status == MI_OK) && (unLen == 0x10))
80004e08:	c0 c1       	brne	80004e20 <PcdRequest+0x4c>
80004e0a:	31 08       	mov	r8,16
80004e0c:	fb 39 00 13 	ld.ub	r9,sp[19]
80004e10:	f0 09 18 00 	cp.b	r9,r8
80004e14:	c0 61       	brne	80004e20 <PcdRequest+0x4c>
	{
		*pTagType     = ucComMF522Buf[0];
80004e16:	1b 88       	ld.ub	r8,sp[0x0]
80004e18:	ac 88       	st.b	r6[0x0],r8
		*(pTagType+1) = ucComMF522Buf[1];
80004e1a:	1b 98       	ld.ub	r8,sp[0x1]
80004e1c:	ac 98       	st.b	r6[0x1],r8
	
	ucComMF522Buf[0] = req_code;

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,1,ucComMF522Buf,&unLen);

	if ((status == MI_OK) && (unLen == 0x10))
80004e1e:	c0 28       	rjmp	80004e22 <PcdRequest+0x4e>
80004e20:	30 2c       	mov	r12,2
	}
	else
	{   status = MI_ERR;   }
	
	return status;
}
80004e22:	2f bd       	sub	sp,-20
80004e24:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004e28:	80 00       	ld.sh	r0,r0[0x0]
80004e2a:	4a 58       	lddpc	r8,80004ebc <CalulateCRC+0x84>
80004e2c:	80 00       	ld.sh	r0,r0[0x0]
80004e2e:	48 b0       	lddpc	r0,80004e58 <CalulateCRC+0x20>
80004e30:	80 00       	ld.sh	r0,r0[0x0]
80004e32:	4a 14       	lddpc	r4,80004eb4 <CalulateCRC+0x7c>
80004e34:	80 00       	ld.sh	r0,r0[0x0]
80004e36:	4b d8       	lddpc	r8,80004f28 <PcdSelect+0x64>

80004e38 <CalulateCRC>:

/////////////////////////////////////////////////////////////////////
//MF522璁＄CRC16芥
/////////////////////////////////////////////////////////////////////
void CalulateCRC(U8 *pIn ,U8   len,U8 *pOut )
{
80004e38:	eb cd 40 f8 	pushm	r3-r7,lr
80004e3c:	18 95       	mov	r5,r12
80004e3e:	16 96       	mov	r6,r11
80004e40:	14 93       	mov	r3,r10
	U8   i,n;
	ClearBitMask(DivIrqReg,0x04);
80004e42:	30 4b       	mov	r11,4
80004e44:	30 5c       	mov	r12,5
80004e46:	f0 1f 00 1c 	mcall	80004eb4 <CalulateCRC+0x7c>
	WriteRawRC(CommandReg,PCD_IDLE);
80004e4a:	30 0b       	mov	r11,0
80004e4c:	30 1c       	mov	r12,1
80004e4e:	f0 1f 00 1b 	mcall	80004eb8 <CalulateCRC+0x80>
	SetBitMask(FIFOLevelReg,0x80);
80004e52:	e0 6b 00 80 	mov	r11,128
80004e56:	30 ac       	mov	r12,10
80004e58:	f0 1f 00 19 	mcall	80004ebc <CalulateCRC+0x84>
	for (i=0; i<len; i++)
80004e5c:	58 06       	cp.w	r6,0
80004e5e:	c0 c0       	breq	80004e76 <CalulateCRC+0x3e>
80004e60:	0a 97       	mov	r7,r5
	{   WriteRawRC(FIFODataReg, *(pIn +i));   }
80004e62:	30 94       	mov	r4,9
80004e64:	0f 3b       	ld.ub	r11,r7++
80004e66:	08 9c       	mov	r12,r4
80004e68:	f0 1f 00 14 	mcall	80004eb8 <CalulateCRC+0x80>
{
	U8   i,n;
	ClearBitMask(DivIrqReg,0x04);
	WriteRawRC(CommandReg,PCD_IDLE);
	SetBitMask(FIFOLevelReg,0x80);
	for (i=0; i<len; i++)
80004e6c:	0e 98       	mov	r8,r7
80004e6e:	0a 18       	sub	r8,r5
80004e70:	ec 08 18 00 	cp.b	r8,r6
80004e74:	cf 83       	brcs	80004e64 <CalulateCRC+0x2c>
	{   WriteRawRC(FIFODataReg, *(pIn +i));   }
	WriteRawRC(CommandReg, PCD_CALCCRC);
80004e76:	30 3b       	mov	r11,3
80004e78:	30 1c       	mov	r12,1
80004e7a:	f0 1f 00 10 	mcall	80004eb8 <CalulateCRC+0x80>
	i = 0xFF;
	do
	{
		n = ReadRawRC(DivIrqReg);
80004e7e:	30 5c       	mov	r12,5
80004e80:	f0 1f 00 10 	mcall	80004ec0 <CalulateCRC+0x88>
80004e84:	e0 67 00 fe 	mov	r7,254
80004e88:	30 56       	mov	r6,5
80004e8a:	c0 78       	rjmp	80004e98 <CalulateCRC+0x60>
80004e8c:	0c 9c       	mov	r12,r6
80004e8e:	f0 1f 00 0d 	mcall	80004ec0 <CalulateCRC+0x88>
		i--;
80004e92:	20 17       	sub	r7,1
80004e94:	5c 57       	castu.b	r7
	}
	while ((i!=0) && !(n&0x04));
80004e96:	c0 40       	breq	80004e9e <CalulateCRC+0x66>
80004e98:	e2 1c 00 04 	andl	r12,0x4,COH
80004e9c:	cf 80       	breq	80004e8c <CalulateCRC+0x54>
	pOut [0] = ReadRawRC(CRCResultRegL);
80004e9e:	32 2c       	mov	r12,34
80004ea0:	f0 1f 00 08 	mcall	80004ec0 <CalulateCRC+0x88>
80004ea4:	a6 8c       	st.b	r3[0x0],r12
	pOut [1] = ReadRawRC(CRCResultRegM);
80004ea6:	32 1c       	mov	r12,33
80004ea8:	f0 1f 00 06 	mcall	80004ec0 <CalulateCRC+0x88>
80004eac:	a6 9c       	st.b	r3[0x1],r12
}
80004eae:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80004eb2:	00 00       	add	r0,r0
80004eb4:	80 00       	ld.sh	r0,r0[0x0]
80004eb6:	4a 58       	lddpc	r8,80004f48 <rfid_auto_reader+0x10>
80004eb8:	80 00       	ld.sh	r0,r0[0x0]
80004eba:	48 b0       	lddpc	r0,80004ee4 <PcdSelect+0x20>
80004ebc:	80 00       	ld.sh	r0,r0[0x0]
80004ebe:	4a 14       	lddpc	r4,80004f40 <rfid_auto_reader+0x8>
80004ec0:	80 00       	ld.sh	r0,r0[0x0]
80004ec2:	49 70       	lddpc	r0,80004f1c <PcdSelect+0x58>

80004ec4 <PcdSelect>:
//    斤瀹＄
//拌存: pSnr[IN]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdSelect(U8 *pSnr)
{
80004ec4:	eb cd 40 80 	pushm	r7,lr
80004ec8:	20 5d       	sub	sp,20
	char   status;
	U8   i;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
80004eca:	39 38       	mov	r8,-109
80004ecc:	ba 88       	st.b	sp[0x0],r8
	ucComMF522Buf[1] = 0x70;
80004ece:	37 08       	mov	r8,112
80004ed0:	ba 98       	st.b	sp[0x1],r8
	ucComMF522Buf[6] = 0;
80004ed2:	30 08       	mov	r8,0
80004ed4:	ba e8       	st.b	sp[0x6],r8
80004ed6:	fa c8 ff fe 	sub	r8,sp,-2
/////////////////////////////////////////////////////////////////////
//    斤瀹＄
//拌存: pSnr[IN]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdSelect(U8 *pSnr)
80004eda:	fa cb ff fa 	sub	r11,sp,-6
	ucComMF522Buf[0] = PICC_ANTICOLL1;
	ucComMF522Buf[1] = 0x70;
	ucComMF522Buf[6] = 0;
	for (i=0; i<4; i++)
	{
		ucComMF522Buf[i+2] = *(pSnr+i);
80004ede:	19 89       	ld.ub	r9,r12[0x0]
80004ee0:	10 c9       	st.b	r8++,r9
		ucComMF522Buf[6]  ^= *(pSnr+i);
80004ee2:	19 3a       	ld.ub	r10,r12++
80004ee4:	1b e9       	ld.ub	r9,sp[0x6]
80004ee6:	f5 e9 20 09 	eor	r9,r10,r9
80004eea:	ba e9       	st.b	sp[0x6],r9
	U8   ucComMF522Buf[MAXRLEN];
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
	ucComMF522Buf[1] = 0x70;
	ucComMF522Buf[6] = 0;
	for (i=0; i<4; i++)
80004eec:	16 38       	cp.w	r8,r11
80004eee:	cf 81       	brne	80004ede <PcdSelect+0x1a>
	{
		ucComMF522Buf[i+2] = *(pSnr+i);
		ucComMF522Buf[6]  ^= *(pSnr+i);
	}
	CalulateCRC(ucComMF522Buf,7,&ucComMF522Buf[7]);
80004ef0:	1a 97       	mov	r7,sp
80004ef2:	fa ca ff f9 	sub	r10,sp,-7
80004ef6:	30 7b       	mov	r11,7
80004ef8:	1a 9c       	mov	r12,sp
80004efa:	f0 1f 00 0d 	mcall	80004f2c <PcdSelect+0x68>
	
	ClearBitMask(Status2Reg,0x08);
80004efe:	30 8b       	mov	r11,8
80004f00:	16 9c       	mov	r12,r11
80004f02:	f0 1f 00 0c 	mcall	80004f30 <PcdSelect+0x6c>

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,9,ucComMF522Buf,&unLen);
80004f06:	fa c8 ff ed 	sub	r8,sp,-19
80004f0a:	1a 99       	mov	r9,sp
80004f0c:	30 9a       	mov	r10,9
80004f0e:	1a 9b       	mov	r11,sp
80004f10:	30 cc       	mov	r12,12
80004f12:	f0 1f 00 09 	mcall	80004f34 <PcdSelect+0x70>
	
	if ((status == MI_OK) && (unLen == 0x18))
80004f16:	c0 71       	brne	80004f24 <PcdSelect+0x60>
80004f18:	31 88       	mov	r8,24
80004f1a:	fb 39 00 13 	ld.ub	r9,sp[19]
80004f1e:	f0 09 18 00 	cp.b	r9,r8
80004f22:	c0 20       	breq	80004f26 <PcdSelect+0x62>
80004f24:	30 2c       	mov	r12,2
	{   status = MI_OK;  }
	else
	{   status = MI_ERR;    }

	return status;
}
80004f26:	2f bd       	sub	sp,-20
80004f28:	e3 cd 80 80 	ldm	sp++,r7,pc
80004f2c:	80 00       	ld.sh	r0,r0[0x0]
80004f2e:	4e 38       	lddpc	r8,800050b8 <scan_rfid_save_message+0x10>
80004f30:	80 00       	ld.sh	r0,r0[0x0]
80004f32:	4a 58       	lddpc	r8,80004fc4 <rfid_auto_reader+0x8c>
80004f34:	80 00       	ld.sh	r0,r0[0x0]
80004f36:	4b d8       	lddpc	r8,80005028 <rfid_auto_reader+0xf0>

80004f38 <rfid_auto_reader>:
		//
}

//娴绋锛瀵诲->插叉->->″
U8 rfid_auto_reader(void *card_id)
{
80004f38:	eb cd 40 c0 	pushm	r6-r7,lr
80004f3c:	18 96       	mov	r6,r12
	U8 status = MI_ERR;
	
	PcdReset();
80004f3e:	f0 1f 00 37 	mcall	80005018 <rfid_auto_reader+0xe0>
//while(1){
	status=PcdRequest(PICC_REQALL,	CT);//瀵诲ぉ绾垮哄ㄩㄧ★杩＄绫诲 2瀛
80004f42:	4b 7b       	lddpc	r11,8000501c <rfid_auto_reader+0xe4>
80004f44:	35 2c       	mov	r12,82
80004f46:	f0 1f 00 37 	mcall	80005020 <rfid_auto_reader+0xe8>
80004f4a:	18 97       	mov	r7,r12
	if(status!=MI_OK) return status;
80004f4c:	c6 31       	brne	80005012 <rfid_auto_reader+0xda>
	//continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
80004f4e:	4b 48       	lddpc	r8,8000501c <rfid_auto_reader+0xe4>
80004f50:	11 88       	ld.ub	r8,r8[0x0]
80004f52:	30 49       	mov	r9,4
80004f54:	f2 08 18 00 	cp.b	r8,r9
80004f58:	c0 b1       	brne	80004f6e <rfid_auto_reader+0x36>
80004f5a:	4b 19       	lddpc	r9,8000501c <rfid_auto_reader+0xe4>
80004f5c:	13 9a       	ld.ub	r10,r9[0x1]
80004f5e:	30 09       	mov	r9,0
80004f60:	f2 0a 18 00 	cp.b	r10,r9
80004f64:	c0 51       	brne	80004f6e <rfid_auto_reader+0x36>
		log("MFOne-S50\n");
80004f66:	4b 0c       	lddpc	r12,80005024 <rfid_auto_reader+0xec>
80004f68:	f0 1f 00 30 	mcall	80005028 <rfid_auto_reader+0xf0>
//while(1){
	status=PcdRequest(PICC_REQALL,	CT);//瀵诲ぉ绾垮哄ㄩㄧ★杩＄绫诲 2瀛
	if(status!=MI_OK) return status;
	//continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
80004f6c:	c3 c8       	rjmp	80004fe4 <rfid_auto_reader+0xac>
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
80004f6e:	30 29       	mov	r9,2
80004f70:	f2 08 18 00 	cp.b	r8,r9
80004f74:	c0 b1       	brne	80004f8a <rfid_auto_reader+0x52>
80004f76:	4a a9       	lddpc	r9,8000501c <rfid_auto_reader+0xe4>
80004f78:	13 9a       	ld.ub	r10,r9[0x1]
80004f7a:	30 09       	mov	r9,0
80004f7c:	f2 0a 18 00 	cp.b	r10,r9
80004f80:	c0 51       	brne	80004f8a <rfid_auto_reader+0x52>
		log("MFOne-S70\n");
80004f82:	4a bc       	lddpc	r12,8000502c <rfid_auto_reader+0xf4>
80004f84:	f0 1f 00 29 	mcall	80005028 <rfid_auto_reader+0xf0>
	if(status!=MI_OK) return status;
	//continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
80004f88:	c2 e8       	rjmp	80004fe4 <rfid_auto_reader+0xac>
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
80004f8a:	34 49       	mov	r9,68
80004f8c:	f2 08 18 00 	cp.b	r8,r9
80004f90:	c0 b1       	brne	80004fa6 <rfid_auto_reader+0x6e>
80004f92:	4a 39       	lddpc	r9,8000501c <rfid_auto_reader+0xe4>
80004f94:	13 9a       	ld.ub	r10,r9[0x1]
80004f96:	30 09       	mov	r9,0
80004f98:	f2 0a 18 00 	cp.b	r10,r9
80004f9c:	c0 51       	brne	80004fa6 <rfid_auto_reader+0x6e>
		log("MF-UltraLight\n");
80004f9e:	4a 5c       	lddpc	r12,80005030 <rfid_auto_reader+0xf8>
80004fa0:	f0 1f 00 22 	mcall	80005028 <rfid_auto_reader+0xf0>
	
	if(CT[0]==0x04&&CT[1]==0x00)
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
80004fa4:	c2 08       	rjmp	80004fe4 <rfid_auto_reader+0xac>
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
80004fa6:	30 89       	mov	r9,8
80004fa8:	f2 08 18 00 	cp.b	r8,r9
80004fac:	c0 b1       	brne	80004fc2 <rfid_auto_reader+0x8a>
80004fae:	49 c9       	lddpc	r9,8000501c <rfid_auto_reader+0xe4>
80004fb0:	13 9a       	ld.ub	r10,r9[0x1]
80004fb2:	30 09       	mov	r9,0
80004fb4:	f2 0a 18 00 	cp.b	r10,r9
80004fb8:	c0 51       	brne	80004fc2 <rfid_auto_reader+0x8a>
		log("MF-Pro\n");
80004fba:	49 fc       	lddpc	r12,80005034 <rfid_auto_reader+0xfc>
80004fbc:	f0 1f 00 1b 	mcall	80005028 <rfid_auto_reader+0xf0>
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
80004fc0:	c1 28       	rjmp	80004fe4 <rfid_auto_reader+0xac>
		log("MF-Pro\n");
	else if(CT[0]==0x44&&CT[1]==0x03)
80004fc2:	34 49       	mov	r9,68
80004fc4:	f2 08 18 00 	cp.b	r8,r9
80004fc8:	c0 b1       	brne	80004fde <rfid_auto_reader+0xa6>
80004fca:	49 58       	lddpc	r8,8000501c <rfid_auto_reader+0xe4>
80004fcc:	11 99       	ld.ub	r9,r8[0x1]
80004fce:	30 38       	mov	r8,3
80004fd0:	f0 09 18 00 	cp.b	r9,r8
80004fd4:	c0 51       	brne	80004fde <rfid_auto_reader+0xa6>
		log("MF Desire\n");
80004fd6:	49 9c       	lddpc	r12,80005038 <rfid_auto_reader+0x100>
80004fd8:	f0 1f 00 14 	mcall	80005028 <rfid_auto_reader+0xf0>
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
		log("MF-Pro\n");
	else if(CT[0]==0x44&&CT[1]==0x03)
80004fdc:	c0 48       	rjmp	80004fe4 <rfid_auto_reader+0xac>
		log("MF Desire\n");
	else
		log("Unknown\n");
80004fde:	49 8c       	lddpc	r12,8000503c <rfid_auto_reader+0x104>
80004fe0:	f0 1f 00 12 	mcall	80005028 <rfid_auto_reader+0xf0>
		
	status=PcdAnticoll(SN);//插叉锛杩＄搴 4瀛
80004fe4:	49 7c       	lddpc	r12,80005040 <rfid_auto_reader+0x108>
80004fe6:	f0 1f 00 18 	mcall	80005044 <rfid_auto_reader+0x10c>
80004fea:	18 97       	mov	r7,r12
	if(status!=MI_OK)
80004fec:	c0 60       	breq	80004ff8 <rfid_auto_reader+0xc0>
	{
		xcmp_IdleTestTone(Tone_Start, Low_Battery_3);//set tone to noticy failure!!!
80004fee:	34 fb       	mov	r11,79
80004ff0:	30 1c       	mov	r12,1
80004ff2:	f0 1f 00 16 	mcall	80005048 <rfid_auto_reader+0x110>
		return status;
80004ff6:	c0 e8       	rjmp	80005012 <rfid_auto_reader+0xda>
		//continue;
	}
	
	//memcpy(MLastSelectedSnr,&RevBuffer[2],4);
	status=PcdSelect(SN);//
80004ff8:	49 2c       	lddpc	r12,80005040 <rfid_auto_reader+0x108>
80004ffa:	f0 1f 00 15 	mcall	8000504c <rfid_auto_reader+0x114>
80004ffe:	18 97       	mov	r7,r12
	if(status!=MI_OK)return status;
80005000:	c0 91       	brne	80005012 <rfid_auto_reader+0xda>
	//continue;
	else{//℃
			
		memcpy(card_id, SN, 4);
80005002:	30 4a       	mov	r10,4
80005004:	48 fb       	lddpc	r11,80005040 <rfid_auto_reader+0x108>
80005006:	0c 9c       	mov	r12,r6
80005008:	f0 1f 00 12 	mcall	80005050 <rfid_auto_reader+0x118>
		log("select okay\n");
8000500c:	49 2c       	lddpc	r12,80005054 <rfid_auto_reader+0x11c>
8000500e:	f0 1f 00 07 	mcall	80005028 <rfid_auto_reader+0xf0>
		return status;	
	}
	
//}
	
}
80005012:	0e 9c       	mov	r12,r7
80005014:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005018:	80 00       	ld.sh	r0,r0[0x0]
8000501a:	48 f0       	lddpc	r0,80005054 <rfid_auto_reader+0x11c>
8000501c:	00 00       	add	r0,r0
8000501e:	51 34       	stdsp	sp[0x4c],r4
80005020:	80 00       	ld.sh	r0,r0[0x0]
80005022:	4d d4       	lddpc	r4,80005194 <scan_rfid_save_message+0xec>
80005024:	80 00       	ld.sh	r0,r0[0x0]
80005026:	d8 88       	*unknown*
80005028:	80 00       	ld.sh	r0,r0[0x0]
8000502a:	6f 6c       	ld.w	r12,r7[0x58]
8000502c:	80 00       	ld.sh	r0,r0[0x0]
8000502e:	d8 94       	*unknown*
80005030:	80 00       	ld.sh	r0,r0[0x0]
80005032:	d8 a0       	acall	0x8a
80005034:	80 00       	ld.sh	r0,r0[0x0]
80005036:	d8 b0       	acall	0x8b
80005038:	80 00       	ld.sh	r0,r0[0x0]
8000503a:	d8 b8       	*unknown*
8000503c:	80 00       	ld.sh	r0,r0[0x0]
8000503e:	d8 c4       	*unknown*
80005040:	00 00       	add	r0,r0
80005042:	51 38       	stdsp	sp[0x4c],r8
80005044:	80 00       	ld.sh	r0,r0[0x0]
80005046:	4d 50       	lddpc	r0,80005198 <scan_rfid_save_message+0xf0>
80005048:	80 00       	ld.sh	r0,r0[0x0]
8000504a:	40 44       	lddsp	r4,sp[0x10]
8000504c:	80 00       	ld.sh	r0,r0[0x0]
8000504e:	4e c4       	lddpc	r4,800051fc <scan_rfid_save_message+0x154>
80005050:	80 00       	ld.sh	r0,r0[0x0]
80005052:	77 e8       	ld.w	r8,r11[0x78]
80005054:	80 00       	ld.sh	r0,r0[0x0]
80005056:	d8 d0       	acall	0x8d

80005058 <scan_patrol>:
	return return_err;
	
}

U8 scan_patrol(char* SN)
{
80005058:	eb cd 40 80 	pushm	r7,lr
8000505c:	18 97       	mov	r7,r12
	U8 return_err = MI_ERR;
	
	PcdReset();
8000505e:	f0 1f 00 0d 	mcall	80005090 <scan_patrol+0x38>
	Powerdown_RC522(WAKEUP_RC522);
80005062:	30 0c       	mov	r12,0
80005064:	f0 1f 00 0c 	mcall	80005094 <scan_patrol+0x3c>
	return_err = rfid_auto_reader(SN);
80005068:	0e 9c       	mov	r12,r7
8000506a:	f0 1f 00 0c 	mcall	80005098 <scan_patrol+0x40>
8000506e:	18 97       	mov	r7,r12
	Powerdown_RC522(ENTER_POWERDOWN);
80005070:	30 1c       	mov	r12,1
80005072:	f0 1f 00 09 	mcall	80005094 <scan_patrol+0x3c>
	if(return_err == 0)
80005076:	58 07       	cp.w	r7,0
80005078:	c0 51       	brne	80005082 <scan_patrol+0x2a>
		log("scan_patrol okay!\n");
8000507a:	48 9c       	lddpc	r12,8000509c <scan_patrol+0x44>
8000507c:	f0 1f 00 09 	mcall	800050a0 <scan_patrol+0x48>
80005080:	c0 48       	rjmp	80005088 <scan_patrol+0x30>
	else
		log("scan_patrol err!\n");
80005082:	48 9c       	lddpc	r12,800050a4 <scan_patrol+0x4c>
80005084:	f0 1f 00 07 	mcall	800050a0 <scan_patrol+0x48>
		
	return return_err;

}
80005088:	0e 9c       	mov	r12,r7
8000508a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000508e:	00 00       	add	r0,r0
80005090:	80 00       	ld.sh	r0,r0[0x0]
80005092:	48 f0       	lddpc	r0,800050cc <scan_rfid_save_message+0x24>
80005094:	80 00       	ld.sh	r0,r0[0x0]
80005096:	49 c8       	lddpc	r8,80005104 <scan_rfid_save_message+0x5c>
80005098:	80 00       	ld.sh	r0,r0[0x0]
8000509a:	4f 38       	lddpc	r8,80005264 <scan_rfid_save_message+0x1bc>
8000509c:	80 00       	ld.sh	r0,r0[0x0]
8000509e:	d8 e0       	acall	0x8e
800050a0:	80 00       	ld.sh	r0,r0[0x0]
800050a2:	6f 6c       	ld.w	r12,r7[0x58]
800050a4:	80 00       	ld.sh	r0,r0[0x0]
800050a6:	d8 f4       	*unknown*

800050a8 <scan_rfid_save_message>:
U8 scan_rfid_save_message()
{
800050a8:	eb cd 40 e0 	pushm	r5-r7,lr
800050ac:	fa cd 00 8c 	sub	sp,sp,140
	U8 destination = DEST;
	static U8 start_session = 0x80;
	Message_Header_t header;
	Message_Data_t data_buffer;//22bytes
	
	memset(SN, 0x00, 10);
800050b0:	4e 9c       	lddpc	r12,80005254 <scan_rfid_save_message+0x1ac>
800050b2:	30 08       	mov	r8,0
800050b4:	30 09       	mov	r9,0
800050b6:	f8 e9 00 00 	st.d	r12[0],r8
800050ba:	30 0a       	mov	r10,0
800050bc:	b8 4a       	st.h	r12[0x8],r10
	memset(message, 0x00, 80);
800050be:	fa e9 00 3c 	st.d	sp[60],r8
800050c2:	fa e9 00 44 	st.d	sp[68],r8
800050c6:	fa e9 00 4c 	st.d	sp[76],r8
800050ca:	fa e9 00 54 	st.d	sp[84],r8
800050ce:	fa e9 00 5c 	st.d	sp[92],r8
800050d2:	fa e9 00 64 	st.d	sp[100],r8
800050d6:	fa e9 00 6c 	st.d	sp[108],r8
800050da:	fa e9 00 74 	st.d	sp[116],r8
800050de:	fa e9 00 7c 	st.d	sp[124],r8
800050e2:	fa e9 00 84 	st.d	sp[132],r8
	
	return_err = scan_patrol(SN);
800050e6:	f0 1f 00 5d 	mcall	80005258 <scan_rfid_save_message+0x1b0>
800050ea:	18 97       	mov	r7,r12
	
	if(return_err == 0){
800050ec:	e0 81 00 a8 	brne	8000523c <scan_rfid_save_message+0x194>
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
800050f0:	4d 96       	lddpc	r6,80005254 <scan_rfid_save_message+0x1ac>
800050f2:	0d b8       	ld.ub	r8,r6[0x3]
800050f4:	1a d8       	st.w	--sp,r8
800050f6:	0d a8       	ld.ub	r8,r6[0x2]
800050f8:	1a d8       	st.w	--sp,r8
800050fa:	0d 98       	ld.ub	r8,r6[0x1]
800050fc:	1a d8       	st.w	--sp,r8
800050fe:	0d 88       	ld.ub	r8,r6[0x0]
80005100:	1a d8       	st.w	--sp,r8
80005102:	4d 7c       	lddpc	r12,8000525c <scan_rfid_save_message+0x1b4>
80005104:	f0 1f 00 57 	mcall	80005260 <scan_rfid_save_message+0x1b8>
		xcmp_IdleTestTone(Tone_Start, Ring_Style_Tone_8);//set tone to indicate scan rfid success!!!
80005108:	34 4b       	mov	r11,68
8000510a:	30 1c       	mov	r12,1
8000510c:	f0 1f 00 56 	mcall	80005264 <scan_rfid_save_message+0x1bc>
80005110:	fa c8 ff ce 	sub	r8,sp,-50
80005114:	fa c9 ff cc 	sub	r9,sp,-52
		log("scan_patrol err!\n");
		
	return return_err;

}
U8 scan_rfid_save_message()
80005118:	ec c5 ff fc 	sub	r5,r6,-4
8000511c:	2f cd       	sub	sp,-16
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, Ring_Style_Tone_8);//set tone to indicate scan rfid success!!!
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″
			
			temp = ((SN[i] & 0xF0) >> 4);//瀛楂浣
			if((temp >= 0) && (temp <= 9))data_buffer.RFID_ID[i*4] = temp+0x30;
8000511e:	30 9e       	mov	lr,9
			else
			data_buffer.RFID_ID[i*4] = ((temp - 0x0a)+0x61);
			
			data_buffer.RFID_ID[i*4+1] = 0x00;
80005120:	30 0c       	mov	r12,0
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, Ring_Style_Tone_8);//set tone to indicate scan rfid success!!!
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″
			
			temp = ((SN[i] & 0xF0) >> 4);//瀛楂浣
80005122:	0d 8a       	ld.ub	r10,r6[0x0]
80005124:	f4 0b 16 04 	lsr	r11,r10,0x4
			if((temp >= 0) && (temp <= 9))data_buffer.RFID_ID[i*4] = temp+0x30;
80005128:	fc 0b 18 00 	cp.b	r11,lr
8000512c:	f7 bb 08 d0 	subls	r11,-48
80005130:	f1 fb 8e 00 	st.bls	r8[0x0],r11
			else
			data_buffer.RFID_ID[i*4] = ((temp - 0x0a)+0x61);
80005134:	f7 bb 0b a9 	subhi	r11,-87
80005138:	f1 fb be 00 	st.bhi	r8[0x0],r11
			
			data_buffer.RFID_ID[i*4+1] = 0x00;
8000513c:	b0 9c       	st.b	r8[0x1],r12
			
			temp = (SN[i] & 0x0F);//瀛浣浣
8000513e:	f5 da c0 04 	bfextu	r10,r10,0x0,0x4
			if((temp >= 0) && (temp <= 9))data_buffer.RFID_ID[i*4+2] = temp+0x30;
80005142:	fc 0a 18 00 	cp.b	r10,lr
80005146:	f7 ba 08 d0 	subls	r10,-48
8000514a:	f3 fa 8e 00 	st.bls	r9[0x0],r10
			else
			data_buffer.RFID_ID[i*4+2] = ((temp - 0x0a)+0x61);
8000514e:	f7 ba 0b a9 	subhi	r10,-87
80005152:	f3 fa be 00 	st.bhi	r9[0x0],r10

			data_buffer.RFID_ID[i*4+3] = 0x00;
80005156:	b0 bc       	st.b	r8[0x3],r12
80005158:	2f f6       	sub	r6,-1
8000515a:	2f c8       	sub	r8,-4
8000515c:	2f c9       	sub	r9,-4
	
	if(return_err == 0){
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, Ring_Style_Tone_8);//set tone to indicate scan rfid success!!!
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″
8000515e:	0a 36       	cp.w	r6,r5
80005160:	ce 11       	brne	80005122 <scan_rfid_save_message+0x7a>
		
		//memcpy(&data_buffer.XG_Time.Year, &Current_time.Year, sizeof(DateTime_t))	;
		
		header.length = (0x0008 + sizeof(Message_Data_t));
		
		if(start_session > 0x9f)start_session = 0x80;
80005162:	4c 28       	lddpc	r8,80005268 <scan_rfid_save_message+0x1c0>
80005164:	11 89       	ld.ub	r9,r8[0x0]
80005166:	39 f8       	mov	r8,-97
80005168:	f0 09 18 00 	cp.b	r9,r8
8000516c:	e0 88 00 05 	brls	80005176 <scan_rfid_save_message+0xce>
80005170:	38 09       	mov	r9,-128
80005172:	4b e8       	lddpc	r8,80005268 <scan_rfid_save_message+0x1c0>
80005174:	b0 89       	st.b	r8[0x0],r9
		
		header.session_id = (++start_session);
80005176:	4b d8       	lddpc	r8,80005268 <scan_rfid_save_message+0x1c0>
80005178:	11 86       	ld.ub	r6,r8[0x0]
8000517a:	2f f6       	sub	r6,-1
8000517c:	b0 86       	st.b	r8[0x0],r6
		
		memcpy(&header.fixed_data[0], unsure_data, sizeof(unsure_data));
8000517e:	30 5a       	mov	r10,5
80005180:	4b bb       	lddpc	r11,8000526c <scan_rfid_save_message+0x1c4>
80005182:	fa cc ff c9 	sub	r12,sp,-55
80005186:	f0 1f 00 3b 	mcall	80005270 <scan_rfid_save_message+0x1c8>
		header.type = 0xe000;
		
		memcpy(message, &header, sizeof(Message_Header_t));//疯header版
8000518a:	31 88       	mov	r8,24
8000518c:	fb 58 00 32 	st.h	sp[50],r8
80005190:	fb 66 00 36 	st.b	sp[54],r6
80005194:	fe 78 e0 00 	mov	r8,-8192
80005198:	fb 58 00 34 	st.h	sp[52],r8
8000519c:	fa c6 ff c4 	sub	r6,sp,-60
800051a0:	30 aa       	mov	r10,10
800051a2:	fa cb ff ce 	sub	r11,sp,-50
800051a6:	0c 9c       	mov	r12,r6
800051a8:	f0 1f 00 32 	mcall	80005270 <scan_rfid_save_message+0x1c8>
		memcpy(&message[sizeof(Message_Header_t)], &data_buffer, sizeof(Message_Data_t));//疯淇″瀹规版
800051ac:	31 0a       	mov	r10,16
800051ae:	fa cb ff de 	sub	r11,sp,-34
800051b2:	fa cc ff ba 	sub	r12,sp,-70
800051b6:	f0 1f 00 2f 	mcall	80005270 <scan_rfid_save_message+0x1c8>
		
		//xcmp_data_session_req(message, (sizeof(Message_Header_t)+sizeof(Message_Data_t)), destination);
		Message_Protocol_t  xgmessage;
		memcpy(&xgmessage, message, sizeof(Message_Protocol_t));
800051ba:	31 aa       	mov	r10,26
800051bc:	0c 9b       	mov	r11,r6
800051be:	fa cc ff fe 	sub	r12,sp,-2
800051c2:	f0 1f 00 2c 	mcall	80005270 <scan_rfid_save_message+0x1c8>

		Message_Protocol_t * myptr = get_message_store();
800051c6:	4a c8       	lddpc	r8,80005274 <scan_rfid_save_message+0x1cc>
800051c8:	70 0c       	ld.w	r12,r8[0x0]
800051ca:	f0 1f 00 2c 	mcall	80005278 <scan_rfid_save_message+0x1d0>
800051ce:	50 7c       	stdsp	sp[0x1c],r12
		if(NULL != myptr)
800051d0:	c3 20       	breq	80005234 <scan_rfid_save_message+0x18c>
		{
			memcpy(myptr, &xgmessage, sizeof(Message_Protocol_t));
800051d2:	31 aa       	mov	r10,26
800051d4:	fa cb ff fe 	sub	r11,sp,-2
800051d8:	f0 1f 00 26 	mcall	80005270 <scan_rfid_save_message+0x1c8>
			if (xQueueSend(xg_resend_queue, &myptr, 0) != pdPASS)
800051dc:	4a 88       	lddpc	r8,8000527c <scan_rfid_save_message+0x1d4>
800051de:	70 0c       	ld.w	r12,r8[0x0]
800051e0:	30 09       	mov	r9,0
800051e2:	12 9a       	mov	r10,r9
800051e4:	fa cb ff e4 	sub	r11,sp,-28
800051e8:	f0 1f 00 26 	mcall	80005280 <scan_rfid_save_message+0x1d8>
800051ec:	58 1c       	cp.w	r12,1
800051ee:	c1 10       	breq	80005210 <scan_rfid_save_message+0x168>
			{
				log("xg_resend_queue: full\n" );
800051f0:	4a 5c       	lddpc	r12,80005284 <scan_rfid_save_message+0x1dc>
800051f2:	f0 1f 00 1c 	mcall	80005260 <scan_rfid_save_message+0x1b8>
				xcmp_IdleTestTone(Tone_Start, Dispatch_Busy);//set tone to indicate queue full!!!
800051f6:	32 3b       	mov	r11,35
800051f8:	30 1c       	mov	r12,1
800051fa:	f0 1f 00 1b 	mcall	80005264 <scan_rfid_save_message+0x1bc>
				vTaskDelay(3000*2 / portTICK_RATE_MS);//寤惰3000ms
800051fe:	e0 6c 17 70 	mov	r12,6000
80005202:	f0 1f 00 22 	mcall	80005288 <scan_rfid_save_message+0x1e0>
				xcmp_IdleTestTone(Tone_Stop, Dispatch_Busy);//set tone to indicate queue full!!!
80005206:	32 3b       	mov	r11,35
80005208:	30 0c       	mov	r12,0
8000520a:	f0 1f 00 17 	mcall	80005264 <scan_rfid_save_message+0x1bc>
8000520e:	c1 e8       	rjmp	8000524a <scan_rfid_save_message+0x1a2>
			}
			else{
				
				xSemaphoreTake(count_mutex, portMAX_DELAY);
80005210:	49 f6       	lddpc	r6,8000528c <scan_rfid_save_message+0x1e4>
80005212:	6c 0c       	ld.w	r12,r6[0x0]
80005214:	30 09       	mov	r9,0
80005216:	3f fa       	mov	r10,-1
80005218:	12 9b       	mov	r11,r9
8000521a:	f0 1f 00 1e 	mcall	80005290 <scan_rfid_save_message+0x1e8>
				global_count++;
8000521e:	49 e8       	lddpc	r8,80005294 <scan_rfid_save_message+0x1ec>
80005220:	70 09       	ld.w	r9,r8[0x0]
80005222:	2f f9       	sub	r9,-1
80005224:	91 09       	st.w	r8[0x0],r9
				xSemaphoreGive(count_mutex);
80005226:	6c 0c       	ld.w	r12,r6[0x0]
80005228:	30 09       	mov	r9,0
8000522a:	12 9a       	mov	r10,r9
8000522c:	12 9b       	mov	r11,r9
8000522e:	f0 1f 00 15 	mcall	80005280 <scan_rfid_save_message+0x1d8>
80005232:	c0 c8       	rjmp	8000524a <scan_rfid_save_message+0x1a2>
			}

		}
		else
		{
			log("myptr: err\n\r" );
80005234:	49 9c       	lddpc	r12,80005298 <scan_rfid_save_message+0x1f0>
80005236:	f0 1f 00 0b 	mcall	80005260 <scan_rfid_save_message+0x1b8>
8000523a:	c0 88       	rjmp	8000524a <scan_rfid_save_message+0x1a2>
		}
		
	}
	else
	{
		xcmp_IdleTestTone(Tone_Start, Low_Battery_3);//set tone to indicate scan rfid failure!!!
8000523c:	34 fb       	mov	r11,79
8000523e:	30 1c       	mov	r12,1
80005240:	f0 1f 00 09 	mcall	80005264 <scan_rfid_save_message+0x1bc>
		log("no card find...\n");
80005244:	49 6c       	lddpc	r12,8000529c <scan_rfid_save_message+0x1f4>
80005246:	f0 1f 00 07 	mcall	80005260 <scan_rfid_save_message+0x1b8>
	}
	
	return return_err;
	
}
8000524a:	0e 9c       	mov	r12,r7
8000524c:	2d dd       	sub	sp,-140
8000524e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80005252:	00 00       	add	r0,r0
80005254:	00 00       	add	r0,r0
80005256:	0b 68       	ld.uh	r8,--r5
80005258:	80 00       	ld.sh	r0,r0[0x0]
8000525a:	50 58       	stdsp	sp[0x14],r8
8000525c:	80 00       	ld.sh	r0,r0[0x0]
8000525e:	d9 08       	*unknown*
80005260:	80 00       	ld.sh	r0,r0[0x0]
80005262:	6f 6c       	ld.w	r12,r7[0x58]
80005264:	80 00       	ld.sh	r0,r0[0x0]
80005266:	40 44       	lddsp	r4,sp[0x10]
80005268:	00 00       	add	r0,r0
8000526a:	05 30       	ld.ub	r0,r2++
8000526c:	00 00       	add	r0,r0
8000526e:	05 28       	ld.uh	r8,r2++
80005270:	80 00       	ld.sh	r0,r0[0x0]
80005272:	77 e8       	ld.w	r8,r11[0x78]
80005274:	00 00       	add	r0,r0
80005276:	0b 78       	ld.ub	r8,--r5
80005278:	80 00       	ld.sh	r0,r0[0x0]
8000527a:	2d 8c       	sub	r12,-40
8000527c:	00 00       	add	r0,r0
8000527e:	0b 74       	ld.ub	r4,--r5
80005280:	80 00       	ld.sh	r0,r0[0x0]
80005282:	63 34       	ld.w	r4,r1[0x4c]
80005284:	80 00       	ld.sh	r0,r0[0x0]
80005286:	d7 84       	*unknown*
80005288:	80 00       	ld.sh	r0,r0[0x0]
8000528a:	6a 00       	ld.w	r0,r5[0x0]
8000528c:	00 00       	add	r0,r0
8000528e:	0a 60       	and	r0,r5
80005290:	80 00       	ld.sh	r0,r0[0x0]
80005292:	61 28       	ld.w	r8,r0[0x48]
80005294:	00 00       	add	r0,r0
80005296:	0a 50       	eor	r0,r5
80005298:	80 00       	ld.sh	r0,r0[0x0]
8000529a:	d7 9c       	*unknown*
8000529c:	80 00       	ld.sh	r0,r0[0x0]
8000529e:	d9 24       	*unknown*

800052a0 <rfid_init>:
extern volatile U32 global_count;
extern volatile xSemaphoreHandle count_mutex;


void rfid_init()
{
800052a0:	d4 01       	pushm	lr
	char card_id[4]={0};
	//tc_init();//ㄥ跺200msㄥ诲
	
	rc522_init();
800052a2:	f0 1f 00 02 	mcall	800052a8 <rfid_init+0x8>
	
	//if(rfid_auto_reader(card_id) == 0){
		//log("card_id : 0x%x, 0x%x, 0x%x, 0x%x\n", &card_id[0], &card_id[1], &card_id[2], &card_id[3]);	
	//}
		//
}
800052a6:	d8 02       	popm	pc
800052a8:	80 00       	ld.sh	r0,r0[0x0]
800052aa:	4b 00       	lddpc	r0,80005368 <local_start_pll0+0x28>

800052ac <delay_ns>:
}

void delay_ns(U32 ns)
{
	U32 i;
	for(i=0;i<ns;i++)
800052ac:	58 0c       	cp.w	r12,0
800052ae:	5e 0c       	reteq	r12
800052b0:	30 08       	mov	r8,0
	{
		nop();
800052b2:	d7 03       	nop
		nop();
800052b4:	d7 03       	nop
		nop();
800052b6:	d7 03       	nop
}

void delay_ns(U32 ns)
{
	U32 i;
	for(i=0;i<ns;i++)
800052b8:	2f f8       	sub	r8,-1
800052ba:	10 3c       	cp.w	r12,r8
800052bc:	fe 9b ff fb 	brhi	800052b2 <delay_ns+0x6>
800052c0:	5e fc       	retal	r12
800052c2:	d7 03       	nop

800052c4 <delay_us>:
		nop();
		nop();
	}
}
void delay_us(U32 us)
{
800052c4:	eb cd 40 e0 	pushm	r5-r7,lr
800052c8:	18 96       	mov	r6,r12
	for(int i =0; i<us; i++){
800052ca:	58 0c       	cp.w	r12,0
800052cc:	c0 b0       	breq	800052e2 <delay_us+0x1e>
800052ce:	30 07       	mov	r7,0
		delay_ns(1000);
800052d0:	e0 65 03 e8 	mov	r5,1000
800052d4:	0a 9c       	mov	r12,r5
800052d6:	f0 1f 00 05 	mcall	800052e8 <delay_us+0x24>
		nop();
	}
}
void delay_us(U32 us)
{
	for(int i =0; i<us; i++){
800052da:	2f f7       	sub	r7,-1
800052dc:	0e 36       	cp.w	r6,r7
800052de:	fe 9b ff fb 	brhi	800052d4 <delay_us+0x10>
800052e2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800052e6:	00 00       	add	r0,r0
800052e8:	80 00       	ld.sh	r0,r0[0x0]
800052ea:	52 ac       	stdsp	sp[0xa8],r12

800052ec <delay_ms>:
		delay_ns(1000);
	}

}
void delay_ms(U32 ms)
{
800052ec:	eb cd 40 e0 	pushm	r5-r7,lr
800052f0:	18 96       	mov	r6,r12
	for(int i =0; i<ms; i++){
800052f2:	58 0c       	cp.w	r12,0
800052f4:	c0 b0       	breq	8000530a <delay_ms+0x1e>
800052f6:	30 07       	mov	r7,0
		delay_us(1000);
800052f8:	e0 65 03 e8 	mov	r5,1000
800052fc:	0a 9c       	mov	r12,r5
800052fe:	f0 1f 00 05 	mcall	80005310 <delay_ms+0x24>
	}

}
void delay_ms(U32 ms)
{
	for(int i =0; i<ms; i++){
80005302:	2f f7       	sub	r7,-1
80005304:	0e 36       	cp.w	r6,r7
80005306:	fe 9b ff fb 	brhi	800052fc <delay_ms+0x10>
8000530a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000530e:	00 00       	add	r0,r0
80005310:	80 00       	ld.sh	r0,r0[0x0]
80005312:	52 c4       	stdsp	sp[0xb0],r4

80005314 <local_start_timer>:
//	SSC_TX_DATA_ENABLE		AVR32_TC_A0_0_0_PIN					[32 PortB Pin  0 00000001 Func 0]
//	MAKO_TX					AVR32_SSC_TX_DATA_0_PIN				[42 PortB Pin 10 00000400 Func 0]
//	MAKO_RX					AVR32_SSC_RX_DATA_0_PIN				[39 PortB Pin  7 00000080 Func 0]
//
void local_start_timer(void)
{
80005314:	d4 01       	pushm	lr
	{
		{TIMER_TC_CLK_PIN,      TIMER_TC_CLK_FUNCTION     },
		{TIMER_TC_FS_PIN,       TIMER_TC_FS_FUNCTION      },
		{TIMER_EN_CLK_PIN,      TIMER_EN_CLK_FUNCTION     }
	};
	gpio_enable_module(TC_GPIO_MAP, sizeof(TC_GPIO_MAP) / sizeof(TC_GPIO_MAP[0]));
80005316:	30 3b       	mov	r11,3
80005318:	48 8c       	lddpc	r12,80005338 <local_start_timer+0x24>
8000531a:	f0 1f 00 09 	mcall	8000533c <local_start_timer+0x28>

	(&AVR32_TC)->channel[0].cmr =
8000531e:	fe 78 38 00 	mov	r8,-51200
80005322:	e0 69 91 0d 	mov	r9,37133
80005326:	ea 19 00 52 	orh	r9,0x52
8000532a:	91 19       	st.w	r8[0x4],r9
	1                          << AVR32_TC_CLKI_OFFSET     |
	AVR32_TC_TCCLKS_XC0        << AVR32_TC_TCCLKS_OFFSET;



	(&AVR32_TC)->channel[0].ra = 32;
8000532c:	32 09       	mov	r9,32
8000532e:	91 59       	st.w	r8[0x14],r9
	(&AVR32_TC)->channel[0].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
80005330:	30 59       	mov	r9,5
80005332:	91 09       	st.w	r8[0x0],r9
}
80005334:	d8 02       	popm	pc
80005336:	00 00       	add	r0,r0
80005338:	80 00       	ld.sh	r0,r0[0x0]
8000533a:	d9 38       	*unknown*
8000533c:	80 00       	ld.sh	r0,r0[0x0]
8000533e:	54 c0       	stdsp	sp[0x130],r0

80005340 <local_start_pll0>:
//In the SSC description, Master Clock (MCK) is the bus clock of the peripheral bus to which the
//SSC is connected. [23.6.2]
//Switch to clock Osc0 (crystal)
//start PLL0 and switch main clock to PLL0 output
void local_start_pll0(void)
{
80005340:	d4 01       	pushm	lr
	AVR32_HMATRIX.mcfg[AVR32_HMATRIX_MASTER_CPU_INSTRUCTION] = 0x1;
	
***/
	
/*****/
	pm_switch_to_osc0(&AVR32_PM, 12000000, OSC0_STARTUP);
80005342:	30 3a       	mov	r10,3
80005344:	e0 6b 1b 00 	mov	r11,6912
80005348:	ea 1b 00 b7 	orh	r11,0xb7
8000534c:	fe 7c 0c 00 	mov	r12,-62464
80005350:	f0 1f 00 19 	mcall	800053b4 <local_start_pll0+0x74>

	pm_pll_setup(&AVR32_PM,
80005354:	31 08       	mov	r8,16
80005356:	1a d8       	st.w	--sp,r8
80005358:	30 08       	mov	r8,0
8000535a:	30 19       	mov	r9,1
8000535c:	30 7a       	mov	r10,7
8000535e:	10 9b       	mov	r11,r8
80005360:	fe 7c 0c 00 	mov	r12,-62464
80005364:	f0 1f 00 15 	mcall	800053b8 <local_start_pll0+0x78>
	               0,   // use PLL0
	               7,   // MUL=7 in the formula
	               1,   // DIV=1 in the formula
	               0,   // Sel Osc0/PLL0 or Osc1/PLL1
	               16); // lockcount in main clock for the PLL wait lock
	pm_pll_set_option(&AVR32_PM, 0, //PLL number 0
80005368:	30 08       	mov	r8,0
8000536a:	30 19       	mov	r9,1
8000536c:	12 9a       	mov	r10,r9
8000536e:	10 9b       	mov	r11,r8
80005370:	fe 7c 0c 00 	mov	r12,-62464
80005374:	f0 1f 00 12 	mcall	800053bc <local_start_pll0+0x7c>
	                        1, //freq Set to 1 for VCO frequency range 80-180MHz
	                        1, //div2 Divide the PLL output frequency by 2
	                        0);//0 to enable the Wide-Bandith Mode
	pm_pll_enable(&AVR32_PM,0);
80005378:	30 0b       	mov	r11,0
8000537a:	fe 7c 0c 00 	mov	r12,-62464
8000537e:	f0 1f 00 11 	mcall	800053c0 <local_start_pll0+0x80>


	pm_wait_for_pll0_locked(&AVR32_PM);
80005382:	fe 7c 0c 00 	mov	r12,-62464
80005386:	f0 1f 00 10 	mcall	800053c4 <local_start_pll0+0x84>


	pm_cksel(&AVR32_PM, 1,  //Bus A clock divisor enable = 1
8000538a:	30 0a       	mov	r10,0
8000538c:	1a da       	st.w	--sp,r10
8000538e:	1a da       	st.w	--sp,r10
80005390:	14 98       	mov	r8,r10
80005392:	14 99       	mov	r9,r10
80005394:	30 1b       	mov	r11,1
80005396:	fe 7c 0c 00 	mov	r12,-62464
8000539a:	f0 1f 00 0c 	mcall	800053c8 <local_start_pll0+0x88>
	             0,  //B clock divisor enable = 0
	             0,  //Bus B select = 0
	             0,  //HS Bus clock divisor enable = 0
	             0); //HS Bus select = 0
				 
	flashc_set_wait_state(1);
8000539e:	30 1c       	mov	r12,1
800053a0:	f0 1f 00 0b 	mcall	800053cc <local_start_pll0+0x8c>
	//AVR32_FLASHC.fcr = 0x00000040;

	pm_switch_to_clock(&AVR32_PM, AVR32_PM_MCSEL_PLL0);
800053a4:	30 2b       	mov	r11,2
800053a6:	fe 7c 0c 00 	mov	r12,-62464
800053aa:	f0 1f 00 0a 	mcall	800053d0 <local_start_pll0+0x90>
800053ae:	2f dd       	sub	sp,-12
/****/
}
800053b0:	d8 02       	popm	pc
800053b2:	00 00       	add	r0,r0
800053b4:	80 00       	ld.sh	r0,r0[0x0]
800053b6:	57 74       	stdsp	sp[0x1dc],r4
800053b8:	80 00       	ld.sh	r0,r0[0x0]
800053ba:	57 16       	stdsp	sp[0x1c4],r6
800053bc:	80 00       	ld.sh	r0,r0[0x0]
800053be:	57 38       	stdsp	sp[0x1cc],r8
800053c0:	80 00       	ld.sh	r0,r0[0x0]
800053c2:	57 52       	stdsp	sp[0x1d4],r2
800053c4:	80 00       	ld.sh	r0,r0[0x0]
800053c6:	57 60       	stdsp	sp[0x1d8],r0
800053c8:	80 00       	ld.sh	r0,r0[0x0]
800053ca:	56 d0       	stdsp	sp[0x1b4],r0
800053cc:	80 00       	ld.sh	r0,r0[0x0]
800053ce:	54 60       	stdsp	sp[0x118],r0
800053d0:	80 00       	ld.sh	r0,r0[0x0]
800053d2:	57 6a       	stdsp	sp[0x1d8],r10

800053d4 <xg_flashc_init>:
}


//U16	Current_total_message_count=0;
void xg_flashc_init(void)
{
800053d4:	eb cd 40 e0 	pushm	r5-r7,lr
	//{
		//log("Create the xgflash_mutex semaphore failure\n");
	//}
	//
	/* Create the binary semaphore to Synchronize other threads.*/
	vSemaphoreCreateBinary(xBinarySemaphore);
800053d8:	30 0b       	mov	r11,0
800053da:	30 1c       	mov	r12,1
800053dc:	f0 1f 00 18 	mcall	8000543c <xg_flashc_init+0x68>
800053e0:	49 88       	lddpc	r8,80005440 <xg_flashc_init+0x6c>
800053e2:	91 0c       	st.w	r8[0x0],r12
800053e4:	70 08       	ld.w	r8,r8[0x0]
800053e6:	58 08       	cp.w	r8,0
800053e8:	c0 80       	breq	800053f8 <xg_flashc_init+0x24>
800053ea:	49 68       	lddpc	r8,80005440 <xg_flashc_init+0x6c>
800053ec:	70 0c       	ld.w	r12,r8[0x0]
800053ee:	30 09       	mov	r9,0
800053f0:	12 9a       	mov	r10,r9
800053f2:	12 9b       	mov	r11,r9
800053f4:	f0 1f 00 14 	mcall	80005444 <xg_flashc_init+0x70>
	if (xBinarySemaphore == NULL)
800053f8:	49 28       	lddpc	r8,80005440 <xg_flashc_init+0x6c>
800053fa:	70 08       	ld.w	r8,r8[0x0]
800053fc:	58 08       	cp.w	r8,0
800053fe:	c0 41       	brne	80005406 <xg_flashc_init+0x32>
	{
		log("Create the xBinarySemaphore failure\n");
80005400:	49 2c       	lddpc	r12,80005448 <xg_flashc_init+0x74>
80005402:	f0 1f 00 13 	mcall	8000544c <xg_flashc_init+0x78>
	//if (SendM_CountingSemaphore == NULL)
	//{
		//log("Create the SendM_Counting semaphore failure\n");
	//}
	//
	xg_resend_queue = xQueueCreate(100, sizeof(U32));
80005406:	30 4b       	mov	r11,4
80005408:	36 4c       	mov	r12,100
8000540a:	f0 1f 00 0d 	mcall	8000543c <xg_flashc_init+0x68>
8000540e:	49 18       	lddpc	r8,80005450 <xg_flashc_init+0x7c>
80005410:	91 0c       	st.w	r8[0x0],r12
	/*initialize the queue*/
	message_storage_queue = xQueueCreate(MAX_MESSAGE_STORE, sizeof(U32));
80005412:	30 4b       	mov	r11,4
80005414:	e0 6c 00 c8 	mov	r12,200
80005418:	f0 1f 00 09 	mcall	8000543c <xg_flashc_init+0x68>
8000541c:	48 e8       	lddpc	r8,80005454 <xg_flashc_init+0x80>
8000541e:	91 0c       	st.w	r8[0x0],r12
80005420:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_MESSAGE_STORE; i++ )
	{
		set_message_store(&message_store[i]);//push <message_store> address to the message_storage_queue;
80005422:	10 96       	mov	r6,r8
80005424:	48 d5       	lddpc	r5,80005458 <xg_flashc_init+0x84>
80005426:	6c 0c       	ld.w	r12,r6[0x0]
80005428:	ea 07 00 0b 	add	r11,r5,r7
8000542c:	f0 1f 00 0c 	mcall	8000545c <xg_flashc_init+0x88>
80005430:	2e 67       	sub	r7,-26
	//}
	//
	xg_resend_queue = xQueueCreate(100, sizeof(U32));
	/*initialize the queue*/
	message_storage_queue = xQueueCreate(MAX_MESSAGE_STORE, sizeof(U32));
	for(int i= 0; i < MAX_MESSAGE_STORE; i++ )
80005432:	e0 47 14 50 	cp.w	r7,5200
80005436:	cf 81       	brne	80005426 <xg_flashc_init+0x52>
	//flashc_lock_all_regions(false);
	//xgflash_list_info_init();
	
	
	//create_xg_flash_test_task();
}
80005438:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000543c:	80 00       	ld.sh	r0,r0[0x0]
8000543e:	64 8c       	ld.w	r12,r2[0x20]
80005440:	00 00       	add	r0,r0
80005442:	0b 7c       	ld.ub	r12,--r5
80005444:	80 00       	ld.sh	r0,r0[0x0]
80005446:	63 34       	ld.w	r4,r1[0x4c]
80005448:	80 00       	ld.sh	r0,r0[0x0]
8000544a:	d9 50       	acall	0x95
8000544c:	80 00       	ld.sh	r0,r0[0x0]
8000544e:	6f 6c       	ld.w	r12,r7[0x58]
80005450:	00 00       	add	r0,r0
80005452:	0b 74       	ld.ub	r4,--r5
80005454:	00 00       	add	r0,r0
80005456:	0b 78       	ld.ub	r8,--r5
80005458:	00 00       	add	r0,r0
8000545a:	51 3c       	stdsp	sp[0x4c],r12
8000545c:	80 00       	ld.sh	r0,r0[0x0]
8000545e:	2b e0       	sub	r0,-66

80005460 <flashc_set_wait_state>:
}


void flashc_set_wait_state(unsigned int wait_state)
{
	u_avr32_flashc_fcr_t u_avr32_flashc_fcr = {AVR32_FLASHC.fcr};
80005460:	fe 68 14 00 	mov	r8,-125952
80005464:	70 09       	ld.w	r9,r8[0x0]
	u_avr32_flashc_fcr.FCR.fws = wait_state;
80005466:	f3 dc d0 c1 	bfins	r9,r12,0x6,0x1
	AVR32_FLASHC.fcr = u_avr32_flashc_fcr.fcr;
8000546a:	91 09       	st.w	r8[0x0],r9
}
8000546c:	5e fc       	retal	r12

8000546e <gpio_enable_module_pin>:
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
8000546e:	f8 08 16 05 	lsr	r8,r12,0x5
80005472:	a9 68       	lsl	r8,0x8
80005474:	e0 28 f0 00 	sub	r8,61440

	/* Enable the correct function. */
	switch (function) {
80005478:	58 1b       	cp.w	r11,1
8000547a:	c0 d0       	breq	80005494 <gpio_enable_module_pin+0x26>
8000547c:	c0 63       	brcs	80005488 <gpio_enable_module_pin+0x1a>
8000547e:	58 2b       	cp.w	r11,2
80005480:	c1 00       	breq	800054a0 <gpio_enable_module_pin+0x32>
80005482:	58 3b       	cp.w	r11,3
80005484:	c1 40       	breq	800054ac <gpio_enable_module_pin+0x3e>
80005486:	5e ff       	retal	1
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80005488:	30 19       	mov	r9,1
8000548a:	f2 0c 09 49 	lsl	r9,r9,r12
8000548e:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80005490:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80005492:	c1 28       	rjmp	800054b6 <gpio_enable_module_pin+0x48>

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80005494:	30 19       	mov	r9,1
80005496:	f2 0c 09 49 	lsl	r9,r9,r12
8000549a:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
8000549c:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
8000549e:	c0 c8       	rjmp	800054b6 <gpio_enable_module_pin+0x48>

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
800054a0:	30 19       	mov	r9,1
800054a2:	f2 0c 09 49 	lsl	r9,r9,r12
800054a6:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
800054a8:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
800054aa:	c0 68       	rjmp	800054b6 <gpio_enable_module_pin+0x48>

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
800054ac:	30 19       	mov	r9,1
800054ae:	f2 0c 09 49 	lsl	r9,r9,r12
800054b2:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
800054b4:	91 99       	st.w	r8[0x24],r9
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
800054b6:	30 19       	mov	r9,1
800054b8:	f2 0c 09 4c 	lsl	r12,r9,r12
800054bc:	91 2c       	st.w	r8[0x8],r12
800054be:	5e fd       	retal	0

800054c0 <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
800054c0:	d4 21       	pushm	r4-r7,lr
800054c2:	18 97       	mov	r7,r12
800054c4:	16 94       	mov	r4,r11
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
800054c6:	58 0b       	cp.w	r11,0
800054c8:	c0 31       	brne	800054ce <gpio_enable_module+0xe>
800054ca:	30 05       	mov	r5,0
800054cc:	c0 d8       	rjmp	800054e6 <gpio_enable_module+0x26>
800054ce:	30 06       	mov	r6,0
800054d0:	0c 95       	mov	r5,r6
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
800054d2:	6e 1b       	ld.w	r11,r7[0x4]
800054d4:	6e 0c       	ld.w	r12,r7[0x0]
800054d6:	f0 1f 00 06 	mcall	800054ec <gpio_enable_module+0x2c>
800054da:	18 45       	or	r5,r12
		gpiomap++;
800054dc:	2f 87       	sub	r7,-8
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
800054de:	2f f6       	sub	r6,-1
800054e0:	0c 34       	cp.w	r4,r6
800054e2:	fe 9b ff f8 	brhi	800054d2 <gpio_enable_module+0x12>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
}
800054e6:	0a 9c       	mov	r12,r5
800054e8:	d8 22       	popm	r4-r7,pc
800054ea:	00 00       	add	r0,r0
800054ec:	80 00       	ld.sh	r0,r0[0x0]
800054ee:	54 6e       	stdsp	sp[0x118],lr

800054f0 <gpio_enable_gpio_pin>:
 *            AVR32_PWM_3_PIN for PWM channel 3 can also be used to release
 *            module pins for GPIO.
 */
void gpio_enable_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
800054f0:	f8 08 16 05 	lsr	r8,r12,0x5
800054f4:	a9 68       	lsl	r8,0x8
800054f6:	e0 28 f0 00 	sub	r8,61440
	
	gpio_port->oderc = 1 << (pin & 0x1F);
800054fa:	30 19       	mov	r9,1
800054fc:	f2 0c 09 4c 	lsl	r12,r9,r12
80005500:	f1 4c 00 48 	st.w	r8[72],r12
	gpio_port->gpers = 1 << (pin & 0x1F);
80005504:	91 1c       	st.w	r8[0x4],r12
}
80005506:	5e fc       	retal	r12

80005508 <gpio_set_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_set_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80005508:	f8 08 16 05 	lsr	r8,r12,0x5
8000550c:	a9 68       	lsl	r8,0x8
8000550e:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 1. */
	gpio_port->ovrs  = 1 << (pin & 0x1F);
80005512:	30 19       	mov	r9,1
80005514:	f2 0c 09 4c 	lsl	r12,r9,r12
80005518:	f1 4c 00 54 	st.w	r8[84],r12
	/* The GPIO output driver is enabled for that pin. */ 
	gpio_port->oders = 1 << (pin & 0x1F);
8000551c:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
80005520:	91 1c       	st.w	r8[0x4],r12
}
80005522:	5e fc       	retal	r12

80005524 <gpio_clr_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_clr_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80005524:	f8 08 16 05 	lsr	r8,r12,0x5
80005528:	a9 68       	lsl	r8,0x8
8000552a:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 0. */
	gpio_port->ovrc  = 1 << (pin & 0x1F);
8000552e:	30 19       	mov	r9,1
80005530:	f2 0c 09 4c 	lsl	r12,r9,r12
80005534:	f1 4c 00 58 	st.w	r8[88],r12
	/* The GPIO output driver is enabled for that pin. */
	gpio_port->oders = 1 << (pin & 0x1F);
80005538:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
8000553c:	91 1c       	st.w	r8[0x4],r12
}
8000553e:	5e fc       	retal	r12

80005540 <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
80005540:	c0 08       	rjmp	80005540 <_unhandled_interrupt>
80005542:	d7 03       	nop

80005544 <INTC_register_interrupt>:
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
80005544:	f6 08 16 05 	lsr	r8,r11,0x5

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
80005548:	49 99       	lddpc	r9,800055ac <INTC_register_interrupt+0x68>
8000554a:	f2 08 00 39 	add	r9,r9,r8<<0x3
8000554e:	f7 db c0 05 	bfextu	r11,r11,0x0,0x5
80005552:	72 19       	ld.w	r9,r9[0x4]
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
80005554:	f2 0b 09 2c 	st.w	r9[r11<<0x2],r12
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
80005558:	58 0a       	cp.w	r10,0
8000555a:	c0 91       	brne	8000556c <INTC_register_interrupt+0x28>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
8000555c:	49 59       	lddpc	r9,800055b0 <INTC_register_interrupt+0x6c>
8000555e:	49 6a       	lddpc	r10,800055b4 <INTC_register_interrupt+0x70>
80005560:	12 1a       	sub	r10,r9
80005562:	fe 79 08 00 	mov	r9,-63488
80005566:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
8000556a:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT1) {
8000556c:	58 1a       	cp.w	r10,1
8000556e:	c0 a1       	brne	80005582 <INTC_register_interrupt+0x3e>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
80005570:	49 09       	lddpc	r9,800055b0 <INTC_register_interrupt+0x6c>
80005572:	49 2a       	lddpc	r10,800055b8 <INTC_register_interrupt+0x74>
80005574:	12 1a       	sub	r10,r9
80005576:	bf aa       	sbr	r10,0x1e
80005578:	fe 79 08 00 	mov	r9,-63488
8000557c:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80005580:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT2) {
80005582:	58 2a       	cp.w	r10,2
80005584:	c0 a1       	brne	80005598 <INTC_register_interrupt+0x54>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
80005586:	48 b9       	lddpc	r9,800055b0 <INTC_register_interrupt+0x6c>
80005588:	48 da       	lddpc	r10,800055bc <INTC_register_interrupt+0x78>
8000558a:	12 1a       	sub	r10,r9
8000558c:	bf ba       	sbr	r10,0x1f
8000558e:	fe 79 08 00 	mov	r9,-63488
80005592:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80005596:	5e fc       	retal	r12
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
80005598:	48 69       	lddpc	r9,800055b0 <INTC_register_interrupt+0x6c>
8000559a:	48 aa       	lddpc	r10,800055c0 <INTC_register_interrupt+0x7c>
8000559c:	12 1a       	sub	r10,r9
8000559e:	ea 1a c0 00 	orh	r10,0xc000
800055a2:	fe 79 08 00 	mov	r9,-63488
800055a6:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800055aa:	5e fc       	retal	r12
800055ac:	80 00       	ld.sh	r0,r0[0x0]
800055ae:	d9 88       	*unknown*
800055b0:	80 00       	ld.sh	r0,r0[0x0]
800055b2:	ce 00       	breq	80005572 <INTC_register_interrupt+0x2e>
800055b4:	80 00       	ld.sh	r0,r0[0x0]
800055b6:	cf 04       	brge	80005596 <INTC_register_interrupt+0x52>
800055b8:	80 00       	ld.sh	r0,r0[0x0]
800055ba:	cf 12       	brcc	8000559c <INTC_register_interrupt+0x58>
800055bc:	80 00       	ld.sh	r0,r0[0x0]
800055be:	cf 20       	breq	800055a2 <INTC_register_interrupt+0x5e>
800055c0:	80 00       	ld.sh	r0,r0[0x0]
800055c2:	cf 2e       	rcall	800053a6 <local_start_pll0+0x66>

800055c4 <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
800055c4:	d4 21       	pushm	r4-r7,lr
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
800055c6:	49 18       	lddpc	r8,80005608 <INTC_init_interrupts+0x44>
800055c8:	e3 b8 00 01 	mtsr	0x4,r8
800055cc:	49 0e       	lddpc	lr,8000560c <INTC_init_interrupts+0x48>
800055ce:	30 07       	mov	r7,0
800055d0:	0e 94       	mov	r4,r7
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
800055d2:	49 0c       	lddpc	r12,80005610 <INTC_init_interrupts+0x4c>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
800055d4:	49 05       	lddpc	r5,80005614 <INTC_init_interrupts+0x50>
800055d6:	10 15       	sub	r5,r8
800055d8:	fe 76 08 00 	mov	r6,-63488
800055dc:	c1 08       	rjmp	800055fc <INTC_init_interrupts+0x38>
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
800055de:	08 98       	mov	r8,r4
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
				._int_line_handler_table[int_req]
800055e0:	7c 1b       	ld.w	r11,lr[0x4]

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
800055e2:	7c 0a       	ld.w	r10,lr[0x0]
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
800055e4:	f6 08 09 2c 	st.w	r11[r8<<0x2],r12
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
800055e8:	2f f8       	sub	r8,-1

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
800055ea:	10 3a       	cp.w	r10,r8
800055ec:	fe 9b ff fc 	brhi	800055e4 <INTC_init_interrupts+0x20>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
800055f0:	ec 07 09 25 	st.w	r6[r7<<0x2],r5
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
800055f4:	2f f7       	sub	r7,-1
800055f6:	2f 8e       	sub	lr,-8
800055f8:	59 37       	cp.w	r7,19
800055fa:	c0 50       	breq	80005604 <INTC_init_interrupts+0x40>
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
800055fc:	7c 08       	ld.w	r8,lr[0x0]
800055fe:	58 08       	cp.w	r8,0
80005600:	ce f1       	brne	800055de <INTC_init_interrupts+0x1a>
80005602:	cf 7b       	rjmp	800055f0 <INTC_init_interrupts+0x2c>
80005604:	d8 22       	popm	r4-r7,pc
80005606:	00 00       	add	r0,r0
80005608:	80 00       	ld.sh	r0,r0[0x0]
8000560a:	ce 00       	breq	800055ca <INTC_init_interrupts+0x6>
8000560c:	80 00       	ld.sh	r0,r0[0x0]
8000560e:	d9 88       	*unknown*
80005610:	80 00       	ld.sh	r0,r0[0x0]
80005612:	55 40       	stdsp	sp[0x150],r0
80005614:	80 00       	ld.sh	r0,r0[0x0]
80005616:	cf 04       	brge	800055f6 <INTC_init_interrupts+0x32>

80005618 <_get_interrupt_handler>:
__int_handler _get_interrupt_handler(uint32_t int_level)
{
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
80005618:	fe 78 08 00 	mov	r8,-63488
8000561c:	e0 69 00 83 	mov	r9,131
80005620:	f2 0c 01 0c 	sub	r12,r9,r12
80005624:	f0 0c 03 29 	ld.w	r9,r8[r12<<0x2]
	uint32_t int_req = AVR32_INTC.irr[int_grp];
80005628:	f2 ca ff c0 	sub	r10,r9,-64
8000562c:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
80005630:	58 08       	cp.w	r8,0
80005632:	c0 21       	brne	80005636 <_get_interrupt_handler+0x1e>
80005634:	5e fd       	retal	0
		? _int_handler_table[int_grp]._int_line_handler_table[32
80005636:	f0 08 12 00 	clz	r8,r8
8000563a:	48 5a       	lddpc	r10,8000564c <_get_interrupt_handler+0x34>
8000563c:	f4 09 00 39 	add	r9,r10,r9<<0x3
80005640:	f0 08 11 1f 	rsub	r8,r8,31
80005644:	72 19       	ld.w	r9,r9[0x4]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
80005646:	f2 08 03 2c 	ld.w	r12,r9[r8<<0x2]
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
8000564a:	5e fc       	retal	r12
8000564c:	80 00       	ld.sh	r0,r0[0x0]
8000564e:	d9 88       	*unknown*

80005650 <pm_set_osc0_mode>:
 * \param mode Oscillator 0 mode (i.e. AVR32_PM_OSCCTRL0_MODE_x).
 */
static void pm_set_osc0_mode(volatile avr32_pm_t *pm, unsigned int mode)
{
  // Read
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
80005650:	78 a8       	ld.w	r8,r12[0x28]
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.mode = mode;
80005652:	f1 db d0 03 	bfins	r8,r11,0x0,0x3
  // Write
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
80005656:	99 a8       	st.w	r12[0x28],r8
}
80005658:	5e fc       	retal	r12
8000565a:	d7 03       	nop

8000565c <pm_enable_osc0_crystal>:
  pm_set_osc0_mode(pm, AVR32_PM_OSCCTRL0_MODE_EXT_CLOCK);
}


void pm_enable_osc0_crystal(volatile avr32_pm_t *pm, unsigned int fosc0)
{
8000565c:	d4 01       	pushm	lr
  pm_set_osc0_mode(pm, (fosc0 <  900000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G0 :
8000565e:	ec 5b bb 9f 	cp.w	r11,899999
80005662:	e0 8b 00 04 	brhi	8000566a <pm_enable_osc0_crystal+0xe>
80005666:	30 4b       	mov	r11,4
80005668:	c1 38       	rjmp	8000568e <pm_enable_osc0_crystal+0x32>
8000566a:	e0 68 c6 bf 	mov	r8,50879
8000566e:	ea 18 00 2d 	orh	r8,0x2d
80005672:	10 3b       	cp.w	r11,r8
80005674:	e0 8b 00 04 	brhi	8000567c <pm_enable_osc0_crystal+0x20>
80005678:	30 5b       	mov	r11,5
8000567a:	c0 a8       	rjmp	8000568e <pm_enable_osc0_crystal+0x32>
8000567c:	e0 68 12 00 	mov	r8,4608
80005680:	ea 18 00 7a 	orh	r8,0x7a
80005684:	10 3b       	cp.w	r11,r8
80005686:	f9 bb 03 06 	movlo	r11,6
8000568a:	f9 bb 02 07 	movhs	r11,7
8000568e:	f0 1f 00 02 	mcall	80005694 <pm_enable_osc0_crystal+0x38>
                       (fosc0 < 3000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G1 :
                       (fosc0 < 8000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G2 :
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}
80005692:	d8 02       	popm	pc
80005694:	80 00       	ld.sh	r0,r0[0x0]
80005696:	56 50       	stdsp	sp[0x194],r0

80005698 <pm_enable_clk0_no_wait>:


void pm_enable_clk0_no_wait(volatile avr32_pm_t *pm, unsigned int startup)
{
  // Read register
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
80005698:	78 a8       	ld.w	r8,r12[0x28]
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.startup = startup;
8000569a:	f1 db d1 03 	bfins	r8,r11,0x8,0x3
  // Write back
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
8000569e:	99 a8       	st.w	r12[0x28],r8

  pm->mcctrl |= AVR32_PM_MCCTRL_OSC0EN_MASK;
800056a0:	78 08       	ld.w	r8,r12[0x0]
800056a2:	a3 a8       	sbr	r8,0x2
800056a4:	99 08       	st.w	r12[0x0],r8
}
800056a6:	5e fc       	retal	r12

800056a8 <pm_wait_for_clk0_ready>:


void pm_wait_for_clk0_ready(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
800056a8:	79 58       	ld.w	r8,r12[0x54]
800056aa:	e2 18 00 80 	andl	r8,0x80,COH
800056ae:	cf d0       	breq	800056a8 <pm_wait_for_clk0_ready>
}
800056b0:	5e fc       	retal	r12
800056b2:	d7 03       	nop

800056b4 <pm_enable_clk0>:
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}


void pm_enable_clk0(volatile avr32_pm_t *pm, unsigned int startup)
{
800056b4:	eb cd 40 80 	pushm	r7,lr
800056b8:	18 97       	mov	r7,r12
  pm_enable_clk0_no_wait(pm, startup);
800056ba:	f0 1f 00 04 	mcall	800056c8 <pm_enable_clk0+0x14>
  pm_wait_for_clk0_ready(pm);
800056be:	0e 9c       	mov	r12,r7
800056c0:	f0 1f 00 03 	mcall	800056cc <pm_enable_clk0+0x18>
}
800056c4:	e3 cd 80 80 	ldm	sp++,r7,pc
800056c8:	80 00       	ld.sh	r0,r0[0x0]
800056ca:	56 98       	stdsp	sp[0x1a4],r8
800056cc:	80 00       	ld.sh	r0,r0[0x0]
800056ce:	56 a8       	stdsp	sp[0x1a8],r8

800056d0 <pm_cksel>:
              unsigned int pbasel,
              unsigned int pbbdiv,
              unsigned int pbbsel,
              unsigned int hsbdiv,
              unsigned int hsbsel)
{
800056d0:	eb cd 40 d0 	pushm	r4,r6-r7,lr
800056d4:	fa c4 ff f0 	sub	r4,sp,-16
  u_avr32_pm_cksel_t u_avr32_pm_cksel = {0};
800056d8:	30 0e       	mov	lr,0

  u_avr32_pm_cksel.CKSEL.cpusel = hsbsel;
800056da:	09 f7       	ld.ub	r7,r4[0x7]
800056dc:	ef d7 c0 03 	bfextu	r7,r7,0x0,0x3
800056e0:	fd d7 d0 03 	bfins	lr,r7,0x0,0x3
  u_avr32_pm_cksel.CKSEL.cpudiv = hsbdiv;
800056e4:	09 b4       	ld.ub	r4,r4[0x3]
800056e6:	08 96       	mov	r6,r4
800056e8:	e9 d4 c0 01 	bfextu	r4,r4,0x0,0x1
800056ec:	fd d4 d0 e1 	bfins	lr,r4,0x7,0x1
  u_avr32_pm_cksel.CKSEL.hsbsel = hsbsel;
800056f0:	fd d7 d1 03 	bfins	lr,r7,0x8,0x3
  u_avr32_pm_cksel.CKSEL.hsbdiv = hsbdiv;
800056f4:	fd d4 d1 e1 	bfins	lr,r4,0xf,0x1
  u_avr32_pm_cksel.CKSEL.pbasel = pbasel;
800056f8:	fd da d2 03 	bfins	lr,r10,0x10,0x3
  u_avr32_pm_cksel.CKSEL.pbadiv = pbadiv;
800056fc:	fd db d2 e1 	bfins	lr,r11,0x17,0x1
  u_avr32_pm_cksel.CKSEL.pbbsel = pbbsel;
80005700:	fd d8 d3 03 	bfins	lr,r8,0x18,0x3
  u_avr32_pm_cksel.CKSEL.pbbdiv = pbbdiv;
80005704:	fd d9 d3 e1 	bfins	lr,r9,0x1f,0x1

  pm->cksel = u_avr32_pm_cksel.cksel;
80005708:	99 1e       	st.w	r12[0x4],lr

  // Wait for ckrdy bit and then clear it
  while (!(pm->poscsr & AVR32_PM_POSCSR_CKRDY_MASK));
8000570a:	79 58       	ld.w	r8,r12[0x54]
8000570c:	e2 18 00 20 	andl	r8,0x20,COH
80005710:	cf d0       	breq	8000570a <pm_cksel+0x3a>
}
80005712:	e3 cd 80 d0 	ldm	sp++,r4,r6-r7,pc

80005716 <pm_pll_setup>:
                  unsigned int pll,
                  unsigned int mul,
                  unsigned int div,
                  unsigned int osc,
                  unsigned int lockcount)
{
80005716:	eb cd 40 80 	pushm	r7,lr
8000571a:	40 27       	lddsp	r7,sp[0x8]
  u_avr32_pm_pll_t u_avr32_pm_pll = {0};
8000571c:	30 0e       	mov	lr,0

  u_avr32_pm_pll.PLL.pllosc   = osc;
8000571e:	fd d8 d0 21 	bfins	lr,r8,0x1,0x1
  u_avr32_pm_pll.PLL.plldiv   = div;
80005722:	fd d9 d1 04 	bfins	lr,r9,0x8,0x4
  u_avr32_pm_pll.PLL.pllmul   = mul;
80005726:	fd da d2 04 	bfins	lr,r10,0x10,0x4
  u_avr32_pm_pll.PLL.pllcount = lockcount;
8000572a:	fd d7 d3 06 	bfins	lr,r7,0x18,0x6

  pm->pll[pll] = u_avr32_pm_pll.pll;
8000572e:	2f 8b       	sub	r11,-8
80005730:	f8 0b 09 2e 	st.w	r12[r11<<0x2],lr
}
80005734:	e3 cd 80 80 	ldm	sp++,r7,pc

80005738 <pm_pll_set_option>:
void pm_pll_set_option(volatile avr32_pm_t *pm,
                       unsigned int pll,
                       unsigned int pll_freq,
                       unsigned int pll_div2,
                       unsigned int pll_wbwdisable)
{
80005738:	d4 01       	pushm	lr
  u_avr32_pm_pll_t u_avr32_pm_pll = {pm->pll[pll]};
8000573a:	2f 8b       	sub	r11,-8
8000573c:	f8 0b 03 2e 	ld.w	lr,r12[r11<<0x2]
  u_avr32_pm_pll.PLL.pllopt = pll_freq | (pll_div2 << 1) | (pll_wbwdisable << 2);
80005740:	f5 e9 10 19 	or	r9,r10,r9<<0x1
80005744:	f3 e8 10 28 	or	r8,r9,r8<<0x2
80005748:	fd d8 d0 43 	bfins	lr,r8,0x2,0x3
  pm->pll[pll] = u_avr32_pm_pll.pll;
8000574c:	f8 0b 09 2e 	st.w	r12[r11<<0x2],lr
}
80005750:	d8 02       	popm	pc

80005752 <pm_pll_enable>:


void pm_pll_enable(volatile avr32_pm_t *pm,
                  unsigned int pll)
{
  pm->pll[pll] |= AVR32_PM_PLLEN_MASK;
80005752:	2f 8b       	sub	r11,-8
80005754:	f8 0b 03 28 	ld.w	r8,r12[r11<<0x2]
80005758:	a1 a8       	sbr	r8,0x0
8000575a:	f8 0b 09 28 	st.w	r12[r11<<0x2],r8
}
8000575e:	5e fc       	retal	r12

80005760 <pm_wait_for_pll0_locked>:
}


void pm_wait_for_pll0_locked(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_LOCK0_MASK));
80005760:	79 58       	ld.w	r8,r12[0x54]
80005762:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80005766:	cf d0       	breq	80005760 <pm_wait_for_pll0_locked>
}
80005768:	5e fc       	retal	r12

8000576a <pm_switch_to_clock>:


void pm_switch_to_clock(volatile avr32_pm_t *pm, unsigned long clock)
{
  // Read
  u_avr32_pm_mcctrl_t u_avr32_pm_mcctrl = {pm->mcctrl};
8000576a:	78 08       	ld.w	r8,r12[0x0]
  // Modify
  u_avr32_pm_mcctrl.MCCTRL.mcsel = clock;
8000576c:	f1 db d0 02 	bfins	r8,r11,0x0,0x2
  // Write back
  pm->mcctrl = u_avr32_pm_mcctrl.mcctrl;
80005770:	99 08       	st.w	r12[0x0],r8
}
80005772:	5e fc       	retal	r12

80005774 <pm_switch_to_osc0>:


void pm_switch_to_osc0(volatile avr32_pm_t *pm, unsigned int fosc0, unsigned int startup)
{
80005774:	eb cd 40 c0 	pushm	r6-r7,lr
80005778:	18 97       	mov	r7,r12
8000577a:	14 96       	mov	r6,r10
  pm_enable_osc0_crystal(pm, fosc0);            // Enable the Osc0 in crystal mode
8000577c:	f0 1f 00 06 	mcall	80005794 <pm_switch_to_osc0+0x20>
  pm_enable_clk0(pm, startup);                  // Crystal startup time - This parameter is critical and depends on the characteristics of the crystal
80005780:	0c 9b       	mov	r11,r6
80005782:	0e 9c       	mov	r12,r7
80005784:	f0 1f 00 05 	mcall	80005798 <pm_switch_to_osc0+0x24>
  pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);  // Then switch main clock to Osc0
80005788:	30 1b       	mov	r11,1
8000578a:	0e 9c       	mov	r12,r7
8000578c:	f0 1f 00 04 	mcall	8000579c <pm_switch_to_osc0+0x28>
}
80005790:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005794:	80 00       	ld.sh	r0,r0[0x0]
80005796:	56 5c       	stdsp	sp[0x194],r12
80005798:	80 00       	ld.sh	r0,r0[0x0]
8000579a:	56 b4       	stdsp	sp[0x1ac],r4
8000579c:	80 00       	ld.sh	r0,r0[0x0]
8000579e:	57 6a       	stdsp	sp[0x1d8],r10

800057a0 <getBaudDiv>:
xSemaphoreHandle xSPIMutex;
#endif

int16_t getBaudDiv(const uint32_t baudrate, uint32_t pb_hz)
{
	uint32_t baudDiv = div_ceil(pb_hz, baudrate);
800057a0:	f8 c8 00 01 	sub	r8,r12,1
800057a4:	f0 0b 00 0b 	add	r11,r8,r11
800057a8:	f6 0c 0d 0a 	divu	r10,r11,r12
800057ac:	14 9c       	mov	r12,r10

	if (baudDiv <= 0 || baudDiv > 255) {
800057ae:	f4 c8 00 01 	sub	r8,r10,1
800057b2:	e0 48 00 fe 	cp.w	r8,254
800057b6:	e0 88 00 03 	brls	800057bc <getBaudDiv+0x1c>
800057ba:	5e fe       	retal	-1
		return -1;
	}

	return baudDiv;
800057bc:	5c 8c       	casts.h	r12
}
800057be:	5e fc       	retal	r12

800057c0 <spi_initMaster>:
spi_status_t spi_initMaster(volatile avr32_spi_t *spi,
		const spi_options_t *options)
{
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (options->modfdis > 1) {
800057c0:	f7 39 00 0d 	ld.ub	r9,r11[13]
800057c4:	30 18       	mov	r8,1
800057c6:	f0 09 18 00 	cp.b	r9,r8
800057ca:	e0 88 00 04 	brls	800057d2 <spi_initMaster+0x12>
800057ce:	30 2c       	mov	r12,2
800057d0:	5e fc       	retal	r12
		return SPI_ERROR_ARGUMENT;
	}

	/* Reset. */
	spi->cr = AVR32_SPI_CR_SWRST_MASK;
800057d2:	e0 68 00 80 	mov	r8,128
800057d6:	99 08       	st.w	r12[0x0],r8

	/* Master Mode. */
	u_avr32_spi_mr.mr = spi->mr;
800057d8:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.mstr = 1;
800057da:	30 19       	mov	r9,1
800057dc:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_mr.MR.modfdis = options->modfdis;
800057e0:	f7 39 00 0d 	ld.ub	r9,r11[13]
800057e4:	f1 d9 d0 81 	bfins	r8,r9,0x4,0x1
	u_avr32_spi_mr.MR.llb = 0;
800057e8:	30 09       	mov	r9,0
800057ea:	f1 d9 d0 e1 	bfins	r8,r9,0x7,0x1
	u_avr32_spi_mr.MR.pcs = (1 << AVR32_SPI_MR_PCS_SIZE) - 1;
800057ee:	30 fa       	mov	r10,15
800057f0:	f1 da d2 04 	bfins	r8,r10,0x10,0x4
	spi->mr = u_avr32_spi_mr.mr;
800057f4:	99 18       	st.w	r12[0x4],r8
800057f6:	5e f9       	retal	r9

800057f8 <spi_selectionMode>:

spi_status_t spi_selectionMode(volatile avr32_spi_t *spi,
		uint8_t variable_ps,
		uint8_t pcs_decode,
		uint8_t delay)
{
800057f8:	d4 01       	pushm	lr
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (variable_ps > 1 ||
800057fa:	30 18       	mov	r8,1
800057fc:	f0 0b 18 00 	cp.b	r11,r8
80005800:	5f be       	srhi	lr
80005802:	f0 0a 18 00 	cp.b	r10,r8
80005806:	5f b8       	srhi	r8
80005808:	fd e8 10 08 	or	r8,lr,r8
8000580c:	c0 30       	breq	80005812 <spi_selectionMode+0x1a>
8000580e:	30 2c       	mov	r12,2
80005810:	d8 02       	popm	pc
			pcs_decode > 1) {
		return SPI_ERROR_ARGUMENT;
	}

	u_avr32_spi_mr.mr = spi->mr;
80005812:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.ps = variable_ps;
80005814:	f1 db d0 21 	bfins	r8,r11,0x1,0x1
	u_avr32_spi_mr.MR.pcsdec = pcs_decode;
80005818:	f1 da d0 41 	bfins	r8,r10,0x2,0x1
	u_avr32_spi_mr.MR.dlybcs = delay;
8000581c:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8
	spi->mr = u_avr32_spi_mr.mr;
80005820:	99 18       	st.w	r12[0x4],r8
80005822:	d8 0a       	popm	pc,r12=0

80005824 <spi_enable>:
	return SPI_OK;
}

void spi_enable(volatile avr32_spi_t *spi)
{
	spi->cr = AVR32_SPI_CR_SPIEN_MASK;
80005824:	30 18       	mov	r8,1
80005826:	99 08       	st.w	r12[0x0],r8
}
80005828:	5e fc       	retal	r12

8000582a <spi_write>:
{
	return ((spi->sr & AVR32_SPI_SR_TDRE_MASK) != 0);
}

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
8000582a:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
8000582e:	c0 58       	rjmp	80005838 <spi_write+0xe>
		if (!timeout--) {
80005830:	58 08       	cp.w	r8,0
80005832:	c0 21       	brne	80005836 <spi_write+0xc>
80005834:	5e ff       	retal	1
80005836:	20 18       	sub	r8,1

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
80005838:	78 49       	ld.w	r9,r12[0x10]
8000583a:	e2 19 00 02 	andl	r9,0x2,COH
8000583e:	cf 90       	breq	80005830 <spi_write+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	spi->tdr = data << AVR32_SPI_TDR_TD_OFFSET;
80005840:	5c 7b       	castu.h	r11
80005842:	99 3b       	st.w	r12[0xc],r11
80005844:	5e fd       	retal	0

80005846 <spi_read>:
{
	return ((spi->sr & AVR32_SPI_SR_RDRF_MASK) != 0);
}

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
80005846:	e0 68 3a 98 	mov	r8,15000
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
8000584a:	c0 58       	rjmp	80005854 <spi_read+0xe>
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) !=
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) {
		if (!timeout--) {
8000584c:	58 08       	cp.w	r8,0
8000584e:	c0 21       	brne	80005852 <spi_read+0xc>
80005850:	5e ff       	retal	1
80005852:	20 18       	sub	r8,1

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
80005854:	78 49       	ld.w	r9,r12[0x10]
80005856:	e2 19 02 01 	andl	r9,0x201,COH
8000585a:	e0 49 02 01 	cp.w	r9,513
8000585e:	cf 71       	brne	8000584c <spi_read+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	*data = spi->rdr >> AVR32_SPI_RDR_RD_OFFSET;
80005860:	78 28       	ld.w	r8,r12[0x8]
80005862:	b6 08       	st.h	r11[0x0],r8
80005864:	5e fd       	retal	0
80005866:	d7 03       	nop

80005868 <spi_setupChipReg>:
}

spi_status_t spi_setupChipReg(volatile avr32_spi_t *spi,
		const spi_options_t *options,
		uint32_t pb_hz)
{
80005868:	eb cd 40 f8 	pushm	r3-r7,lr
8000586c:	18 95       	mov	r5,r12
8000586e:	16 97       	mov	r7,r11
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
80005870:	f7 36 00 0c 	ld.ub	r6,r11[12]
80005874:	30 38       	mov	r8,3
80005876:	f0 06 18 00 	cp.b	r6,r8
8000587a:	e0 8b 00 5e 	brhi	80005936 <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
8000587e:	f7 34 00 0b 	ld.ub	r4,r11[11]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
80005882:	30 18       	mov	r8,1
80005884:	f0 04 18 00 	cp.b	r4,r8
80005888:	e0 8b 00 57 	brhi	80005936 <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
8000588c:	f7 33 00 08 	ld.ub	r3,r11[8]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
80005890:	30 78       	mov	r8,7
80005892:	f0 03 18 00 	cp.b	r3,r8
80005896:	e0 88 00 50 	brls	80005936 <spi_setupChipReg+0xce>
8000589a:	31 08       	mov	r8,16
8000589c:	f0 03 18 00 	cp.b	r3,r8
800058a0:	e0 8b 00 4b 	brhi	80005936 <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
		return SPI_ERROR_ARGUMENT;
	}

	int baudDiv = getBaudDiv(options->baudrate, pb_hz);
800058a4:	14 9b       	mov	r11,r10
800058a6:	6e 1c       	ld.w	r12,r7[0x4]
800058a8:	f0 1f 00 26 	mcall	80005940 <spi_setupChipReg+0xd8>

	if (baudDiv < 0) {
800058ac:	c4 55       	brlt	80005936 <spi_setupChipReg+0xce>
		return SPI_ERROR_ARGUMENT;
	}

	/* Will use CSR0 offsets; these are the same for CSR0 to CSR3. */
	u_avr32_spi_csr.csr = 0;
800058ae:	30 08       	mov	r8,0
	u_avr32_spi_csr.CSR.cpol   = options->spi_mode >> 1;
800058b0:	ec 09 16 01 	lsr	r9,r6,0x1
800058b4:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_csr.CSR.ncpha  = (options->spi_mode & 0x1) ^ 0x1;
800058b8:	ec 16 00 01 	eorl	r6,0x1
800058bc:	f1 d6 d0 21 	bfins	r8,r6,0x1,0x1
	u_avr32_spi_csr.CSR.csaat  = options->stay_act;
800058c0:	f1 d4 d0 61 	bfins	r8,r4,0x3,0x1
	u_avr32_spi_csr.CSR.bits   = options->bits - 8;
800058c4:	20 83       	sub	r3,8
800058c6:	f1 d3 d0 84 	bfins	r8,r3,0x4,0x4
	u_avr32_spi_csr.CSR.scbr   = baudDiv;
800058ca:	f1 dc d1 08 	bfins	r8,r12,0x8,0x8
	u_avr32_spi_csr.CSR.dlybs  = options->spck_delay;
800058ce:	ef 39 00 09 	ld.ub	r9,r7[9]
800058d2:	f1 d9 d2 08 	bfins	r8,r9,0x10,0x8
	u_avr32_spi_csr.CSR.dlybct = options->trans_delay;
800058d6:	ef 39 00 0a 	ld.ub	r9,r7[10]
800058da:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8

	switch (options->reg) {
800058de:	0f 89       	ld.ub	r9,r7[0x0]
800058e0:	30 1a       	mov	r10,1
800058e2:	f4 09 18 00 	cp.b	r9,r10
800058e6:	c0 d0       	breq	80005900 <spi_setupChipReg+0x98>
800058e8:	c0 a3       	brcs	800058fc <spi_setupChipReg+0x94>
800058ea:	30 2a       	mov	r10,2
800058ec:	f4 09 18 00 	cp.b	r9,r10
800058f0:	c0 a0       	breq	80005904 <spi_setupChipReg+0x9c>
800058f2:	30 3a       	mov	r10,3
800058f4:	f4 09 18 00 	cp.b	r9,r10
800058f8:	c1 f1       	brne	80005936 <spi_setupChipReg+0xce>
800058fa:	c0 78       	rjmp	80005908 <spi_setupChipReg+0xa0>
	case 0:
		spi->csr0 = u_avr32_spi_csr.csr;
800058fc:	8b c8       	st.w	r5[0x30],r8
		break;
800058fe:	c0 68       	rjmp	8000590a <spi_setupChipReg+0xa2>

	case 1:
		spi->csr1 = u_avr32_spi_csr.csr;
80005900:	8b d8       	st.w	r5[0x34],r8
		break;
80005902:	c0 48       	rjmp	8000590a <spi_setupChipReg+0xa2>

	case 2:
		spi->csr2 = u_avr32_spi_csr.csr;
80005904:	8b e8       	st.w	r5[0x38],r8
		break;
80005906:	c0 28       	rjmp	8000590a <spi_setupChipReg+0xa2>

	case 3:
		spi->csr3 = u_avr32_spi_csr.csr;
80005908:	8b f8       	st.w	r5[0x3c],r8
	default:
		return SPI_ERROR_ARGUMENT;
	}

#ifdef FREERTOS_USED
	if (!xSPIMutex) {
8000590a:	48 f8       	lddpc	r8,80005944 <spi_setupChipReg+0xdc>
8000590c:	70 08       	ld.w	r8,r8[0x0]
8000590e:	58 08       	cp.w	r8,0
80005910:	c1 61       	brne	8000593c <spi_setupChipReg+0xd4>
		/* Create the SPI mutex. */
		vSemaphoreCreateBinary(xSPIMutex);
80005912:	30 0b       	mov	r11,0
80005914:	30 1c       	mov	r12,1
80005916:	f0 1f 00 0d 	mcall	80005948 <spi_setupChipReg+0xe0>
8000591a:	48 b8       	lddpc	r8,80005944 <spi_setupChipReg+0xdc>
8000591c:	91 0c       	st.w	r8[0x0],r12
8000591e:	58 0c       	cp.w	r12,0
80005920:	c0 a0       	breq	80005934 <spi_setupChipReg+0xcc>
80005922:	30 09       	mov	r9,0
80005924:	12 9a       	mov	r10,r9
80005926:	12 9b       	mov	r11,r9
80005928:	f0 1f 00 09 	mcall	8000594c <spi_setupChipReg+0xe4>
		if (!xSPIMutex) {
8000592c:	48 68       	lddpc	r8,80005944 <spi_setupChipReg+0xdc>
8000592e:	70 08       	ld.w	r8,r8[0x0]
80005930:	58 08       	cp.w	r8,0
80005932:	c0 51       	brne	8000593c <spi_setupChipReg+0xd4>
80005934:	c0 08       	rjmp	80005934 <spi_setupChipReg+0xcc>
80005936:	30 2c       	mov	r12,2
80005938:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
8000593c:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
80005940:	80 00       	ld.sh	r0,r0[0x0]
80005942:	57 a0       	stdsp	sp[0x1e8],r0
80005944:	00 00       	add	r0,r0
80005946:	65 90       	ld.w	r0,r2[0x64]
80005948:	80 00       	ld.sh	r0,r0[0x0]
8000594a:	64 8c       	ld.w	r12,r2[0x20]
8000594c:	80 00       	ld.sh	r0,r0[0x0]
8000594e:	63 34       	ld.w	r4,r1[0x4c]

80005950 <spi_unselectChip>:

	return SPI_OK;
}

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
80005950:	d4 01       	pushm	lr
80005952:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
80005956:	c0 58       	rjmp	80005960 <spi_unselectChip+0x10>
		if (!timeout--) {
80005958:	58 08       	cp.w	r8,0
8000595a:	c0 21       	brne	8000595e <spi_unselectChip+0xe>
8000595c:	da 0a       	popm	pc,r12=1
8000595e:	20 18       	sub	r8,1

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
80005960:	78 49       	ld.w	r9,r12[0x10]
80005962:	e2 19 02 00 	andl	r9,0x200,COH
80005966:	cf 90       	breq	80005958 <spi_unselectChip+0x8>
			return SPI_ERROR_TIMEOUT;
		}
	}

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
80005968:	78 18       	ld.w	r8,r12[0x4]
8000596a:	ea 18 00 0f 	orh	r8,0xf
8000596e:	99 18       	st.w	r12[0x4],r8

	/* Last transfer, so de-assert the current NPCS if CSAAT is set. */
	spi->cr = AVR32_SPI_CR_LASTXFER_MASK;
80005970:	fc 18 01 00 	movh	r8,0x100
80005974:	99 08       	st.w	r12[0x0],r8

#ifdef FREERTOS_USED
	xSemaphoreGive(xSPIMutex);
80005976:	30 09       	mov	r9,0
80005978:	12 9a       	mov	r10,r9
8000597a:	12 9b       	mov	r11,r9
8000597c:	48 38       	lddpc	r8,80005988 <spi_unselectChip+0x38>
8000597e:	70 0c       	ld.w	r12,r8[0x0]
80005980:	f0 1f 00 03 	mcall	8000598c <spi_unselectChip+0x3c>
80005984:	d8 0a       	popm	pc,r12=0
80005986:	00 00       	add	r0,r0
80005988:	00 00       	add	r0,r0
8000598a:	65 90       	ld.w	r0,r2[0x64]
8000598c:	80 00       	ld.sh	r0,r0[0x0]
8000598e:	63 34       	ld.w	r4,r1[0x4c]

80005990 <spi_selectChip>:

	return SPI_OK;
}

spi_status_t spi_selectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
80005990:	eb cd 40 f8 	pushm	r3-r7,lr
80005994:	18 94       	mov	r4,r12
80005996:	16 93       	mov	r3,r11
#ifdef FREERTOS_USED
	while (pdFALSE == xSemaphoreTake(xSPIMutex, 20)) {
80005998:	49 a6       	lddpc	r6,80005a00 <spi_selectChip+0x70>
8000599a:	30 07       	mov	r7,0
8000599c:	31 45       	mov	r5,20
8000599e:	0e 99       	mov	r9,r7
800059a0:	0a 9a       	mov	r10,r5
800059a2:	0e 9b       	mov	r11,r7
800059a4:	6c 0c       	ld.w	r12,r6[0x0]
800059a6:	f0 1f 00 18 	mcall	80005a04 <spi_selectChip+0x74>
800059aa:	cf a0       	breq	8000599e <spi_selectChip+0xe>
	}
#endif

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
800059ac:	68 18       	ld.w	r8,r4[0x4]
800059ae:	ea 18 00 0f 	orh	r8,0xf
800059b2:	89 18       	st.w	r4[0x4],r8

	if (spi->mr & AVR32_SPI_MR_PCSDEC_MASK) {
800059b4:	68 18       	ld.w	r8,r4[0x4]
800059b6:	e2 18 00 04 	andl	r8,0x4,COH
800059ba:	c1 10       	breq	800059dc <spi_selectChip+0x4c>
		/* The signal is decoded; allow up to 15 chips. */
		if (chip > 14) {
800059bc:	30 e8       	mov	r8,14
800059be:	f0 03 18 00 	cp.b	r3,r8
800059c2:	e0 8b 00 1c 	brhi	800059fa <spi_selectChip+0x6a>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~AVR32_SPI_MR_PCS_MASK |
800059c6:	68 19       	ld.w	r9,r4[0x4]
800059c8:	e6 08 15 10 	lsl	r8,r3,0x10
800059cc:	ea 18 ff f0 	orh	r8,0xfff0
800059d0:	e8 18 ff ff 	orl	r8,0xffff
800059d4:	12 68       	and	r8,r9
800059d6:	89 18       	st.w	r4[0x4],r8
800059d8:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
				(chip << AVR32_SPI_MR_PCS_OFFSET);
	} else {
		if (chip > 3) {
800059dc:	30 38       	mov	r8,3
800059de:	f0 03 18 00 	cp.b	r3,r8
800059e2:	e0 8b 00 0c 	brhi	800059fa <spi_selectChip+0x6a>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~(1 << (AVR32_SPI_MR_PCS_OFFSET + chip));
800059e6:	68 19       	ld.w	r9,r4[0x4]
800059e8:	2f 03       	sub	r3,-16
800059ea:	30 18       	mov	r8,1
800059ec:	f0 03 09 48 	lsl	r8,r8,r3
800059f0:	5c d8       	com	r8
800059f2:	12 68       	and	r8,r9
800059f4:	89 18       	st.w	r4[0x4],r8
800059f6:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
800059fa:	30 2c       	mov	r12,2
	}

	return SPI_OK;
}
800059fc:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80005a00:	00 00       	add	r0,r0
80005a02:	65 90       	ld.w	r0,r2[0x64]
80005a04:	80 00       	ld.sh	r0,r0[0x0]
80005a06:	61 28       	ld.w	r8,r0[0x48]

80005a08 <usart_set_async_baudrate>:
 *
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
80005a08:	d4 01       	pushm	lr
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
80005a0a:	f6 08 15 04 	lsl	r8,r11,0x4
80005a0e:	14 38       	cp.w	r8,r10
80005a10:	f9 b8 08 10 	movls	r8,16
80005a14:	f9 b8 0b 08 	movhi	r8,8
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
80005a18:	f0 0b 02 4b 	mul	r11,r8,r11
80005a1c:	f6 09 16 01 	lsr	r9,r11,0x1
80005a20:	f2 0a 00 3a 	add	r10,r9,r10<<0x3
80005a24:	f4 0b 0d 0a 	divu	r10,r10,r11
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
80005a28:	f4 09 16 03 	lsr	r9,r10,0x3
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
80005a2c:	f2 cb 00 01 	sub	r11,r9,1
80005a30:	e0 4b ff fe 	cp.w	r11,65534
80005a34:	e0 88 00 03 	brls	80005a3a <usart_set_async_baudrate+0x32>
80005a38:	da 0a       	popm	pc,r12=1
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
80005a3a:	78 1b       	ld.w	r11,r12[0x4]
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
80005a3c:	e8 6e 00 00 	mov	lr,524288
80005a40:	59 08       	cp.w	r8,16
80005a42:	fc 08 17 10 	movne	r8,lr
80005a46:	f9 b8 00 00 	moveq	r8,0
80005a4a:	e4 1b ff f7 	andh	r11,0xfff7
80005a4e:	e0 1b fe cf 	andl	r11,0xfecf
80005a52:	16 48       	or	r8,r11
80005a54:	99 18       	st.w	r12[0x4],r8
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
80005a56:	f5 da c0 03 	bfextu	r10,r10,0x0,0x3
80005a5a:	f3 ea 11 09 	or	r9,r9,r10<<0x10
80005a5e:	99 89       	st.w	r12[0x20],r9
80005a60:	d8 0a       	popm	pc,r12=0

80005a62 <usart_write_char>:
 *
 * \return \c 1 if the USART Transmit Holding Register is free, otherwise \c 0.
 */
__always_inline static int usart_tx_ready(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_TXRDY_MASK) != 0;
80005a62:	78 58       	ld.w	r8,r12[0x14]
}


int usart_write_char(volatile avr32_usart_t *usart, int c)
{
  if (usart_tx_ready(usart))
80005a64:	e2 18 00 02 	andl	r8,0x2,COH
80005a68:	c0 31       	brne	80005a6e <usart_write_char+0xc>
80005a6a:	30 2c       	mov	r12,2
80005a6c:	5e fc       	retal	r12
  {
    usart->thr = (c << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
80005a6e:	f7 db c0 09 	bfextu	r11,r11,0x0,0x9
80005a72:	99 7b       	st.w	r12[0x1c],r11
80005a74:	5e fd       	retal	0
80005a76:	d7 03       	nop

80005a78 <usart_putchar>:
    return USART_TX_BUSY;
}


int usart_putchar(volatile avr32_usart_t *usart, int c)
{
80005a78:	eb cd 40 e0 	pushm	r5-r7,lr
80005a7c:	18 96       	mov	r6,r12
80005a7e:	16 95       	mov	r5,r11
80005a80:	e0 67 27 0f 	mov	r7,9999
80005a84:	c0 68       	rjmp	80005a90 <usart_putchar+0x18>
  int timeout = USART_DEFAULT_TIMEOUT;

  do
  {
    if (!timeout--) return USART_FAILURE;
80005a86:	58 07       	cp.w	r7,0
80005a88:	c0 31       	brne	80005a8e <usart_putchar+0x16>
80005a8a:	e3 cf c0 e0 	ldm	sp++,r5-r7,pc,r12=-1
80005a8e:	20 17       	sub	r7,1
  } while (usart_write_char(usart, c) != USART_SUCCESS);
80005a90:	0a 9b       	mov	r11,r5
80005a92:	0c 9c       	mov	r12,r6
80005a94:	f0 1f 00 03 	mcall	80005aa0 <usart_putchar+0x28>
80005a98:	cf 71       	brne	80005a86 <usart_putchar+0xe>

  return USART_SUCCESS;
}
80005a9a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80005a9e:	00 00       	add	r0,r0
80005aa0:	80 00       	ld.sh	r0,r0[0x0]
80005aa2:	5a 62       	cp.w	r2,-26

80005aa4 <usart_read_char>:

int usart_read_char(volatile avr32_usart_t *usart, int *c)
{
  // Check for errors: frame, parity and overrun. In RS485 mode, a parity error
  // would mean that an address char has been received.
  if (usart->csr & (AVR32_USART_CSR_OVRE_MASK |
80005aa4:	78 58       	ld.w	r8,r12[0x14]
80005aa6:	e2 18 00 e0 	andl	r8,0xe0,COH
80005aaa:	c0 30       	breq	80005ab0 <usart_read_char+0xc>
80005aac:	30 4c       	mov	r12,4
80005aae:	5e fc       	retal	r12
 *
 * \return \c 1 if the USART Receive Holding Register is full, otherwise \c 0.
 */
__always_inline static int usart_test_hit(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_RXRDY_MASK) != 0;
80005ab0:	78 58       	ld.w	r8,r12[0x14]
                    AVR32_USART_CSR_FRAME_MASK |
                    AVR32_USART_CSR_PARE_MASK))
    return USART_RX_ERROR;

  // No error; if we really did receive a char, read it and return SUCCESS.
  if (usart_test_hit(usart))
80005ab2:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80005ab6:	c0 31       	brne	80005abc <usart_read_char+0x18>
80005ab8:	30 3c       	mov	r12,3
80005aba:	5e fc       	retal	r12
  {
    *c = (usart->rhr & AVR32_USART_RHR_RXCHR_MASK) >> AVR32_USART_RHR_RXCHR_OFFSET;
80005abc:	78 68       	ld.w	r8,r12[0x18]
80005abe:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
80005ac2:	97 08       	st.w	r11[0x0],r8
80005ac4:	5e fd       	retal	0
80005ac6:	d7 03       	nop

80005ac8 <usart_getchar>:
    return USART_RX_EMPTY;
}


int usart_getchar(volatile avr32_usart_t *usart)
{
80005ac8:	eb cd 40 c0 	pushm	r6-r7,lr
80005acc:	20 1d       	sub	sp,4
80005ace:	18 96       	mov	r6,r12
  int c, ret;

  while ((ret = usart_read_char(usart, &c)) == USART_RX_EMPTY);
80005ad0:	1a 97       	mov	r7,sp
80005ad2:	1a 9b       	mov	r11,sp
80005ad4:	0c 9c       	mov	r12,r6
80005ad6:	f0 1f 00 07 	mcall	80005af0 <usart_getchar+0x28>
80005ada:	58 3c       	cp.w	r12,3
80005adc:	cf b0       	breq	80005ad2 <usart_getchar+0xa>

  if (ret == USART_RX_ERROR)
80005ade:	58 4c       	cp.w	r12,4
80005ae0:	f9 bc 00 ff 	moveq	r12,-1
    return USART_FAILURE;

  return c;
80005ae4:	fb fc 10 00 	ld.wne	r12,sp[0x0]
}
80005ae8:	2f fd       	sub	sp,-4
80005aea:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005aee:	00 00       	add	r0,r0
80005af0:	80 00       	ld.sh	r0,r0[0x0]
80005af2:	5a a4       	cp.w	r4,-22

80005af4 <usart_write_line>:


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
80005af4:	eb cd 40 c0 	pushm	r6-r7,lr
80005af8:	18 96       	mov	r6,r12
80005afa:	16 97       	mov	r7,r11
  while (*string != '\0')
80005afc:	17 8b       	ld.ub	r11,r11[0x0]
80005afe:	58 0b       	cp.w	r11,0
80005b00:	c0 80       	breq	80005b10 <usart_write_line+0x1c>
    usart_putchar(usart, *string++);
80005b02:	2f f7       	sub	r7,-1
80005b04:	0c 9c       	mov	r12,r6
80005b06:	f0 1f 00 04 	mcall	80005b14 <usart_write_line+0x20>
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
80005b0a:	0f 8b       	ld.ub	r11,r7[0x0]
80005b0c:	58 0b       	cp.w	r11,0
80005b0e:	cf a1       	brne	80005b02 <usart_write_line+0xe>
80005b10:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005b14:	80 00       	ld.sh	r0,r0[0x0]
80005b16:	5a 78       	cp.w	r8,-25

80005b18 <usart_reset>:
//! @{


void usart_reset(volatile avr32_usart_t *usart)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
80005b18:	e1 b8 00 00 	mfsr	r8,0x0

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
80005b1c:	e6 18 00 01 	andh	r8,0x1,COH
80005b20:	c0 71       	brne	80005b2e <usart_reset+0x16>
80005b22:	d3 03       	ssrf	0x10
  usart->idr = 0xFFFFFFFF;
80005b24:	3f f8       	mov	r8,-1
80005b26:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80005b28:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();
80005b2a:	d5 03       	csrf	0x10
80005b2c:	c0 48       	rjmp	80005b34 <usart_reset+0x1c>
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
  usart->idr = 0xFFFFFFFF;
80005b2e:	3f f8       	mov	r8,-1
80005b30:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80005b32:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();

  // Reset mode and other registers that could cause unpredictable behavior after reset.
  usart->mr = 0;
80005b34:	30 08       	mov	r8,0
80005b36:	99 18       	st.w	r12[0x4],r8
  usart->rtor = 0;
80005b38:	99 98       	st.w	r12[0x24],r8
  usart->ttgr = 0;
80005b3a:	99 a8       	st.w	r12[0x28],r8

  // Shutdown TX and RX (will be re-enabled when setup has successfully completed),
  // reset status bits and turn off DTR and RTS.
  usart->cr = AVR32_USART_CR_RSTRX_MASK   |
80005b3c:	ea 68 61 0c 	mov	r8,680204
80005b40:	99 08       	st.w	r12[0x0],r8
#ifndef AVR32_USART_440_H_INCLUDED
// Note: Modem Signal Management DTR-DSR-DCD-RI are not included in USART rev.440.
              AVR32_USART_CR_DTRDIS_MASK  |
#endif
              AVR32_USART_CR_RTSDIS_MASK;
}
80005b42:	5e fc       	retal	r12

80005b44 <usart_init_rs232>:


int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
{
80005b44:	eb cd 40 e0 	pushm	r5-r7,lr
80005b48:	18 96       	mov	r6,r12
80005b4a:	16 97       	mov	r7,r11
80005b4c:	14 95       	mov	r5,r10
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);
80005b4e:	f0 1f 00 2f 	mcall	80005c08 <usart_init_rs232+0xc4>

  // Check input values.
  if (!opt || // Null pointer.
80005b52:	58 07       	cp.w	r7,0
80005b54:	c5 80       	breq	80005c04 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
80005b56:	0f c8       	ld.ub	r8,r7[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80005b58:	30 49       	mov	r9,4
80005b5a:	f2 08 18 00 	cp.b	r8,r9
80005b5e:	e0 88 00 53 	brls	80005c04 <usart_init_rs232+0xc0>
80005b62:	30 99       	mov	r9,9
80005b64:	f2 08 18 00 	cp.b	r8,r9
80005b68:	e0 8b 00 4e 	brhi	80005c04 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
80005b6c:	0f d9       	ld.ub	r9,r7[0x5]
80005b6e:	30 78       	mov	r8,7
80005b70:	f0 09 18 00 	cp.b	r9,r8
80005b74:	e0 8b 00 48 	brhi	80005c04 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
80005b78:	8e 39       	ld.sh	r9,r7[0x6]
80005b7a:	e0 68 01 01 	mov	r8,257
80005b7e:	f0 09 19 00 	cp.h	r9,r8
80005b82:	e0 8b 00 41 	brhi	80005c04 <usart_init_rs232+0xc0>
      opt->channelmode > 3 ||
80005b86:	ef 39 00 08 	ld.ub	r9,r7[8]
80005b8a:	30 38       	mov	r8,3
80005b8c:	f0 09 18 00 	cp.b	r9,r8
80005b90:	e0 8b 00 3a 	brhi	80005c04 <usart_init_rs232+0xc0>
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
80005b94:	0a 9a       	mov	r10,r5
80005b96:	6e 0b       	ld.w	r11,r7[0x0]
80005b98:	0c 9c       	mov	r12,r6
80005b9a:	f0 1f 00 1d 	mcall	80005c0c <usart_init_rs232+0xc8>
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80005b9e:	58 1c       	cp.w	r12,1
80005ba0:	c3 20       	breq	80005c04 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
    return USART_INVALID_INPUT;

  if (opt->charlength == 9)
80005ba2:	0f c8       	ld.ub	r8,r7[0x4]
80005ba4:	30 99       	mov	r9,9
80005ba6:	f2 08 18 00 	cp.b	r8,r9
80005baa:	c0 51       	brne	80005bb4 <usart_init_rs232+0x70>
  {
    // Character length set to 9 bits. MODE9 dominates CHRL.
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
80005bac:	6c 18       	ld.w	r8,r6[0x4]
80005bae:	b1 b8       	sbr	r8,0x11
80005bb0:	8d 18       	st.w	r6[0x4],r8
80005bb2:	c0 68       	rjmp	80005bbe <usart_init_rs232+0x7a>
  }
  else
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
80005bb4:	6c 19       	ld.w	r9,r6[0x4]
80005bb6:	20 58       	sub	r8,5
80005bb8:	f3 e8 10 68 	or	r8,r9,r8<<0x6
80005bbc:	8d 18       	st.w	r6[0x4],r8
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
80005bbe:	6c 19       	ld.w	r9,r6[0x4]
80005bc0:	ef 3a 00 08 	ld.ub	r10,r7[8]
80005bc4:	0f d8       	ld.ub	r8,r7[0x5]
80005bc6:	a9 78       	lsl	r8,0x9
80005bc8:	f1 ea 10 e8 	or	r8,r8,r10<<0xe
80005bcc:	12 48       	or	r8,r9
80005bce:	8d 18       	st.w	r6[0x4],r8
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;

  if (opt->stopbits > USART_2_STOPBITS)
80005bd0:	8e 38       	ld.sh	r8,r7[0x6]
80005bd2:	30 29       	mov	r9,2
80005bd4:	f2 08 19 00 	cp.h	r8,r9
80005bd8:	e0 88 00 09 	brls	80005bea <usart_init_rs232+0xa6>
  {
    // Set two stop bits
    usart->mr |= AVR32_USART_MR_NBSTOP_2 << AVR32_USART_MR_NBSTOP_OFFSET;
80005bdc:	6c 18       	ld.w	r8,r6[0x4]
80005bde:	ad b8       	sbr	r8,0xd
80005be0:	8d 18       	st.w	r6[0x4],r8
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
80005be2:	8e b8       	ld.uh	r8,r7[0x6]
80005be4:	20 28       	sub	r8,2
80005be6:	8d a8       	st.w	r6[0x28],r8
80005be8:	c0 68       	rjmp	80005bf4 <usart_init_rs232+0xb0>
  }
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;
80005bea:	6c 19       	ld.w	r9,r6[0x4]
80005bec:	5c 78       	castu.h	r8
80005bee:	f3 e8 10 c8 	or	r8,r9,r8<<0xc
80005bf2:	8d 18       	st.w	r6[0x4],r8

  // Set normal mode.
  usart->mr = (usart->mr & ~AVR32_USART_MR_MODE_MASK) |
80005bf4:	6c 18       	ld.w	r8,r6[0x4]
80005bf6:	e0 18 ff f0 	andl	r8,0xfff0
80005bfa:	8d 18       	st.w	r6[0x4],r8
              AVR32_USART_MR_MODE_NORMAL << AVR32_USART_MR_MODE_OFFSET;

  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
80005bfc:	35 08       	mov	r8,80
80005bfe:	8d 08       	st.w	r6[0x0],r8
80005c00:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
80005c04:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
80005c08:	80 00       	ld.sh	r0,r0[0x0]
80005c0a:	5b 18       	cp.w	r8,-15
80005c0c:	80 00       	ld.sh	r0,r0[0x0]
80005c0e:	5a 08       	cp.w	r8,-32

80005c10 <_stext>:

  .global _stext
  .type _stext, @function
_stext:
  // Set initial stack pointer.
  lda.w   sp, _estack
80005c10:	e0 7d 80 00 	mov	sp,98304

  // Set up EVBA so interrupts can be enabled.
  lda.w   r0, _evba
  mtsr    AVR32_EVBA, r0
80005c14:	fe c0 8e 14 	sub	r0,pc,-29164

  // Enable the exception processing.
  csrf    AVR32_SR_EM_OFFSET
80005c18:	e3 b0 00 01 	mtsr	0x4,r0

  // Load initialized data having a global lifetime from the data LMA.
  lda.w   r0, _data
  lda.w   r1, _edata
80005c1c:	d5 53       	csrf	0x15
  cp      r0, r1
80005c1e:	30 40       	mov	r0,4
  brhs    idata_load_loop_end
80005c20:	e0 61 0a 40 	mov	r1,2624
  lda.w   r2, _data_lma
idata_load_loop:
  ld.d    r4, r2++
80005c24:	02 30       	cp.w	r0,r1
  st.d    r0++, r4
80005c26:	c0 62       	brcc	80005c32 <idata_load_loop_end>
  cp      r0, r1
80005c28:	48 92       	lddpc	r2,80005c4c <udata_clear_loop_end+0x4>

80005c2a <idata_load_loop>:
  brlo    idata_load_loop
80005c2a:	a5 05       	ld.d	r4,r2++
idata_load_loop_end:

  // Clear uninitialized data having a global lifetime in the blank static storage section.
  lda.w   r0, __bss_start
80005c2c:	a1 24       	st.d	r0++,r4
  lda.w   r1, _end
80005c2e:	02 30       	cp.w	r0,r1
  cp      r0, r1
80005c30:	cf d3       	brcs	80005c2a <idata_load_loop>

80005c32 <idata_load_loop_end>:
  brhs    udata_clear_loop_end
80005c32:	e0 60 0a 40 	mov	r0,2624
  mov     r2, 0
  mov     r3, 0
80005c36:	e0 61 65 a0 	mov	r1,26016
udata_clear_loop:
  st.d    r0++, r2
  cp      r0, r1
80005c3a:	02 30       	cp.w	r0,r1
  brlo    udata_clear_loop
80005c3c:	c0 62       	brcc	80005c48 <udata_clear_loop_end>
  // Safety: Set the default "return" @ to the exit routine address.
  lda.w   lr, exit
#endif

  // Start the show.
  lda.w   pc, main
80005c3e:	30 02       	mov	r2,0
80005c40:	30 03       	mov	r3,0

80005c42 <udata_clear_loop>:
80005c42:	a1 22       	st.d	r0++,r2
80005c44:	02 30       	cp.w	r0,r1
80005c46:	cf e3       	brcs	80005c42 <udata_clear_loop>

80005c48 <udata_clear_loop_end>:
80005c48:	fe cf e9 28 	sub	pc,pc,-5848
80005c4c:	80 00       	ld.sh	r0,r0[0x0]
80005c4e:	e2 b8       	*unknown*

80005c50 <vListInitialise>:
void vListInitialise( xList *pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
80005c50:	f8 c8 ff f8 	sub	r8,r12,-8
80005c54:	99 18       	st.w	r12[0x4],r8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
80005c56:	3f f9       	mov	r9,-1
80005c58:	99 29       	st.w	r12[0x8],r9

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
80005c5a:	99 38       	st.w	r12[0xc],r8
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
80005c5c:	99 48       	st.w	r12[0x10],r8

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
80005c5e:	30 08       	mov	r8,0
80005c60:	99 08       	st.w	r12[0x0],r8
}
80005c62:	5e fc       	retal	r12

80005c64 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
80005c64:	30 08       	mov	r8,0
80005c66:	99 48       	st.w	r12[0x10],r8
}
80005c68:	5e fc       	retal	r12

80005c6a <vListInsertEnd>:

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
80005c6a:	78 18       	ld.w	r8,r12[0x4]

	pxNewListItem->pxNext = pxIndex->pxNext;
80005c6c:	70 19       	ld.w	r9,r8[0x4]
80005c6e:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxPrevious = pxList->pxIndex;
80005c70:	78 19       	ld.w	r9,r12[0x4]
80005c72:	97 29       	st.w	r11[0x8],r9
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80005c74:	70 19       	ld.w	r9,r8[0x4]
80005c76:	93 2b       	st.w	r9[0x8],r11
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
80005c78:	91 1b       	st.w	r8[0x4],r11
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
80005c7a:	99 1b       	st.w	r12[0x4],r11

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80005c7c:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80005c7e:	78 08       	ld.w	r8,r12[0x0]
80005c80:	2f f8       	sub	r8,-1
80005c82:	99 08       	st.w	r12[0x0],r8
}
80005c84:	5e fc       	retal	r12

80005c86 <vListInsert>:
{
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
80005c86:	76 0a       	ld.w	r10,r11[0x0]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
80005c88:	5b fa       	cp.w	r10,-1
80005c8a:	c0 31       	brne	80005c90 <vListInsert+0xa>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
80005c8c:	78 48       	ld.w	r8,r12[0x10]
80005c8e:	c0 c8       	rjmp	80005ca6 <vListInsert+0x20>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
80005c90:	f8 c8 ff f8 	sub	r8,r12,-8
80005c94:	70 19       	ld.w	r9,r8[0x4]
80005c96:	72 09       	ld.w	r9,r9[0x0]
80005c98:	12 3a       	cp.w	r10,r9
80005c9a:	c0 63       	brcs	80005ca6 <vListInsert+0x20>
80005c9c:	70 18       	ld.w	r8,r8[0x4]
80005c9e:	70 19       	ld.w	r9,r8[0x4]
80005ca0:	72 09       	ld.w	r9,r9[0x0]
80005ca2:	12 3a       	cp.w	r10,r9
80005ca4:	cf c2       	brcc	80005c9c <vListInsert+0x16>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
80005ca6:	70 19       	ld.w	r9,r8[0x4]
80005ca8:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80005caa:	93 2b       	st.w	r9[0x8],r11
	pxNewListItem->pxPrevious = pxIterator;
80005cac:	97 28       	st.w	r11[0x8],r8
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
80005cae:	91 1b       	st.w	r8[0x4],r11

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80005cb0:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80005cb2:	78 08       	ld.w	r8,r12[0x0]
80005cb4:	2f f8       	sub	r8,-1
80005cb6:	99 08       	st.w	r12[0x0],r8
}
80005cb8:	5e fc       	retal	r12

80005cba <vListRemove>:

void vListRemove( xListItem *pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
80005cba:	78 18       	ld.w	r8,r12[0x4]
80005cbc:	78 29       	ld.w	r9,r12[0x8]
80005cbe:	91 29       	st.w	r8[0x8],r9
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
80005cc0:	78 28       	ld.w	r8,r12[0x8]
80005cc2:	78 19       	ld.w	r9,r12[0x4]
80005cc4:	91 19       	st.w	r8[0x4],r9

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
80005cc6:	78 48       	ld.w	r8,r12[0x10]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
80005cc8:	70 19       	ld.w	r9,r8[0x4]
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
80005cca:	18 39       	cp.w	r9,r12
80005ccc:	f9 f9 00 02 	ld.weq	r9,r12[0x8]
80005cd0:	f1 f9 0a 01 	st.weq	r8[0x4],r9
	}

	pxItemToRemove->pvContainer = NULL;
80005cd4:	30 09       	mov	r9,0
80005cd6:	99 49       	st.w	r12[0x10],r9
	( pxList->uxNumberOfItems )--;
80005cd8:	70 09       	ld.w	r9,r8[0x0]
80005cda:	20 19       	sub	r9,1
80005cdc:	91 09       	st.w	r8[0x0],r9
}
80005cde:	5e fc       	retal	r12

80005ce0 <pxPortInitialiseStack>:
	/* Setup the initial stack of the task.  The stack is set exactly as
	expected by the portRESTORE_CONTEXT() macro. */

	/* When the task starts, it will expect to find the function parameter in R12. */
	pxTopOfStack--;
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x08080808;					/* R8 */
80005ce0:	e0 68 08 08 	mov	r8,2056
80005ce4:	ea 18 08 08 	orh	r8,0x808
80005ce8:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x09090909;					/* R9 */
80005cea:	e0 68 09 09 	mov	r8,2313
80005cee:	ea 18 09 09 	orh	r8,0x909
80005cf2:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0A0A0A0A;					/* R10 */
80005cf4:	e0 68 0a 0a 	mov	r8,2570
80005cf8:	ea 18 0a 0a 	orh	r8,0xa0a
80005cfc:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0B0B0B0B;					/* R11 */
80005cfe:	e0 68 0b 0b 	mov	r8,2827
80005d02:	ea 18 0b 0b 	orh	r8,0xb0b
80005d06:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pvParameters;					/* R12 */
80005d08:	18 da       	st.w	--r12,r10
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xDEADBEEF;					/* R14/LR */
80005d0a:	e0 68 be ef 	mov	r8,48879
80005d0e:	ea 18 de ad 	orh	r8,0xdead
80005d12:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pxCode + portINSTRUCTION_SIZE; /* R15/PC */
80005d14:	18 db       	st.w	--r12,r11
	*pxTopOfStack-- = ( portSTACK_TYPE ) portINITIAL_SR;				/* SR */
80005d16:	fc 18 00 40 	movh	r8,0x40
80005d1a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xFF0000FF;					/* R0 */
80005d1c:	e0 68 00 ff 	mov	r8,255
80005d20:	ea 18 ff 00 	orh	r8,0xff00
80005d24:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x01010101;					/* R1 */
80005d26:	e0 68 01 01 	mov	r8,257
80005d2a:	ea 18 01 01 	orh	r8,0x101
80005d2e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x02020202;					/* R2 */
80005d30:	e0 68 02 02 	mov	r8,514
80005d34:	ea 18 02 02 	orh	r8,0x202
80005d38:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x03030303;					/* R3 */
80005d3a:	e0 68 03 03 	mov	r8,771
80005d3e:	ea 18 03 03 	orh	r8,0x303
80005d42:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x04040404;					/* R4 */
80005d44:	e0 68 04 04 	mov	r8,1028
80005d48:	ea 18 04 04 	orh	r8,0x404
80005d4c:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x05050505;					/* R5 */
80005d4e:	e0 68 05 05 	mov	r8,1285
80005d52:	ea 18 05 05 	orh	r8,0x505
80005d56:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x06060606;					/* R6 */
80005d58:	e0 68 06 06 	mov	r8,1542
80005d5c:	ea 18 06 06 	orh	r8,0x606
80005d60:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x07070707;					/* R7 */
80005d62:	e0 68 07 07 	mov	r8,1799
80005d66:	ea 18 07 07 	orh	r8,0x707
80005d6a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack = ( portSTACK_TYPE ) portNO_CRITICAL_NESTING;			/* ulCriticalNesting */
80005d6c:	30 08       	mov	r8,0
80005d6e:	18 d8       	st.w	--r12,r8

	return pxTopOfStack;
}
80005d70:	5e fc       	retal	r12
80005d72:	d7 03       	nop

80005d74 <vPortEnterCritical>:
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
__attribute__((__noinline__)) void vPortEnterCritical( void )
{
	/* Disable interrupts */
	portDISABLE_INTERRUPTS();
80005d74:	d3 03       	ssrf	0x10

	/* Now interrupts are disabled ulCriticalNesting can be accessed
	 directly.  Increment ulCriticalNesting to keep a count of how many times
	 portENTER_CRITICAL() has been called. */
	ulCriticalNesting++;
80005d76:	48 38       	lddpc	r8,80005d80 <vPortEnterCritical+0xc>
80005d78:	70 09       	ld.w	r9,r8[0x0]
80005d7a:	2f f9       	sub	r9,-1
80005d7c:	91 09       	st.w	r8[0x0],r9
}
80005d7e:	5e fc       	retal	r12
80005d80:	00 00       	add	r0,r0
80005d82:	05 34       	ld.ub	r4,r2++

80005d84 <xPortStartScheduler>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
80005d84:	d4 01       	pushm	lr
	};

#endif

	/* Disable all interrupt/exception. */
	portDISABLE_INTERRUPTS();
80005d86:	d3 03       	ssrf	0x10
		/* Start the timer/counter. */
		tc_start(tc, configTICK_TC_CHANNEL);
	}
	#else
	{
		INTC_register_interrupt(&vTick, AVR32_CORE_COMPARE_IRQ, AVR32_INTC_INT0);
80005d88:	30 0a       	mov	r10,0
80005d8a:	14 9b       	mov	r11,r10
80005d8c:	49 2c       	lddpc	r12,80005dd4 <xPortStartScheduler+0x50>
80005d8e:	f0 1f 00 13 	mcall	80005dd8 <xPortStartScheduler+0x54>
/* Schedule the COUNT&COMPARE match interrupt in (configCPU_CLOCK_HZ/configTICK_RATE_HZ)
clock cycles from now. */
#if( configTICK_USE_TC==0 )
	static void prvScheduleFirstTick(void)
	{
		Set_system_register(AVR32_COMPARE, configCPU_CLOCK_HZ/configTICK_RATE_HZ);//cause!!!
80005d92:	e0 68 5d c0 	mov	r8,24000
80005d96:	e3 b8 00 43 	mtsr	0x10c,r8
		Set_system_register(AVR32_COUNT, 0);
80005d9a:	30 08       	mov	r8,0
80005d9c:	e3 b8 00 42 	mtsr	0x108,r8
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();

	/* Start the first task. */
	portRESTORE_CONTEXT();
80005da0:	e0 68 0c f8 	mov	r8,3320
80005da4:	ea 18 00 00 	orh	r8,0x0
80005da8:	70 00       	ld.w	r0,r8[0x0]
80005daa:	60 0d       	ld.w	sp,r0[0x0]
80005dac:	1b 00       	ld.w	r0,sp++
80005dae:	e0 68 05 34 	mov	r8,1332
80005db2:	ea 18 00 00 	orh	r8,0x0
80005db6:	91 00       	st.w	r8[0x0],r0
80005db8:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005dbc:	2f ed       	sub	sp,-8
80005dbe:	e3 cd 5f 00 	ldm	sp++,r8-r12,lr
80005dc2:	fa f0 ff e0 	ld.w	r0,sp[-32]
80005dc6:	e3 b0 00 00 	mtsr	0x0,r0
80005dca:	fa f0 ff dc 	ld.w	r0,sp[-36]
80005dce:	fa ff ff e4 	ld.w	pc,sp[-28]

	/* Should not get here! */
	return 0;
}
80005dd2:	d8 0a       	popm	pc,r12=0
80005dd4:	80 00       	ld.sh	r0,r0[0x0]
80005dd6:	5e a0       	retle	r0
80005dd8:	80 00       	ld.sh	r0,r0[0x0]
80005dda:	55 44       	stdsp	sp[0x150],r4

80005ddc <SCALLYield>:
/*-----------------------------------------------------------*/
__attribute__((__naked__)) void SCALLYield( void );
__attribute__((__naked__)) void SCALLYield( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_SCALL();
80005ddc:	20 6d       	sub	sp,24
80005dde:	eb cd 00 ff 	pushm	r0-r7
80005de2:	fa c7 ff c0 	sub	r7,sp,-64
80005de6:	ee f0 ff f8 	ld.w	r0,r7[-8]
80005dea:	ef 40 ff e0 	st.w	r7[-32],r0
80005dee:	ee f0 ff fc 	ld.w	r0,r7[-4]
80005df2:	ef 40 ff e4 	st.w	r7[-28],r0
80005df6:	eb c7 5f 00 	stm	--r7,r8-r12,lr
80005dfa:	e0 68 05 34 	mov	r8,1332
80005dfe:	ea 18 00 00 	orh	r8,0x0
80005e02:	70 00       	ld.w	r0,r8[0x0]
80005e04:	1a d0       	st.w	--sp,r0
80005e06:	f0 1f 00 1a 	mcall	80005e6c <LABEL_RET_SCALL_263+0x14>
80005e0a:	e0 68 0c f8 	mov	r8,3320
80005e0e:	ea 18 00 00 	orh	r8,0x0
80005e12:	70 00       	ld.w	r0,r8[0x0]
80005e14:	81 0d       	st.w	r0[0x0],sp
	vTaskSwitchContext();
80005e16:	f0 1f 00 17 	mcall	80005e70 <LABEL_RET_SCALL_263+0x18>
	portRESTORE_CONTEXT_SCALL();
80005e1a:	e0 68 0c f8 	mov	r8,3320
80005e1e:	ea 18 00 00 	orh	r8,0x0
80005e22:	70 00       	ld.w	r0,r8[0x0]
80005e24:	60 0d       	ld.w	sp,r0[0x0]
80005e26:	1b 00       	ld.w	r0,sp++
80005e28:	e0 68 05 34 	mov	r8,1332
80005e2c:	ea 18 00 00 	orh	r8,0x0
80005e30:	91 00       	st.w	r8[0x0],r0
80005e32:	fa c7 ff d8 	sub	r7,sp,-40
80005e36:	e3 c7 5f 00 	ldm	r7++,r8-r12,lr
80005e3a:	ee f0 ff e0 	ld.w	r0,r7[-32]
80005e3e:	e0 61 05 34 	mov	r1,1332
80005e42:	ea 11 00 00 	orh	r1,0x0
80005e46:	62 02       	ld.w	r2,r1[0x0]
80005e48:	58 02       	cp.w	r2,0
80005e4a:	c0 70       	breq	80005e58 <LABEL_RET_SCALL_263>
80005e4c:	e4 c2 00 01 	sub	r2,r2,1
80005e50:	83 02       	st.w	r1[0x0],r2
80005e52:	58 02       	cp.w	r2,0
80005e54:	c0 21       	brne	80005e58 <LABEL_RET_SCALL_263>
80005e56:	b1 c0       	cbr	r0,0x10

80005e58 <LABEL_RET_SCALL_263>:
80005e58:	ef 40 ff f8 	st.w	r7[-8],r0
80005e5c:	ee f0 ff e4 	ld.w	r0,r7[-28]
80005e60:	ef 40 ff fc 	st.w	r7[-4],r0
80005e64:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005e68:	2f ad       	sub	sp,-24
80005e6a:	d6 13       	rets
80005e6c:	80 00       	ld.sh	r0,r0[0x0]
80005e6e:	5d 74       	*unknown*
80005e70:	80 00       	ld.sh	r0,r0[0x0]
80005e72:	65 10       	ld.w	r0,r2[0x44]

80005e74 <prvClearCcInt>:
		Set_system_register(AVR32_COUNT, 0);
	}

	__attribute__((__noinline__)) static void prvClearCcInt(void)
	{
		Set_system_register(AVR32_COMPARE, Get_system_register(AVR32_COMPARE));
80005e74:	e1 b8 00 43 	mfsr	r8,0x10c
80005e78:	e3 b8 00 43 	mtsr	0x10c,r8
	}
80005e7c:	5e fc       	retal	r12
80005e7e:	d7 03       	nop

80005e80 <vPortExitCritical>:
}
/*-----------------------------------------------------------*/

__attribute__((__noinline__)) void vPortExitCritical( void )
{
	if(ulCriticalNesting > portNO_CRITICAL_NESTING)
80005e80:	48 78       	lddpc	r8,80005e9c <vPortExitCritical+0x1c>
80005e82:	70 08       	ld.w	r8,r8[0x0]
80005e84:	58 08       	cp.w	r8,0
80005e86:	5e 0c       	reteq	r12
	{
		ulCriticalNesting--;
80005e88:	48 58       	lddpc	r8,80005e9c <vPortExitCritical+0x1c>
80005e8a:	70 09       	ld.w	r9,r8[0x0]
80005e8c:	20 19       	sub	r9,1
80005e8e:	91 09       	st.w	r8[0x0],r9
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
80005e90:	70 08       	ld.w	r8,r8[0x0]
80005e92:	58 08       	cp.w	r8,0
80005e94:	5e 1c       	retne	r12
		{
			/* Enable all interrupt/exception. */
			portENABLE_INTERRUPTS();
80005e96:	d5 03       	csrf	0x10
80005e98:	5e fc       	retal	r12
80005e9a:	00 00       	add	r0,r0
80005e9c:	00 00       	add	r0,r0
80005e9e:	05 34       	ld.ub	r4,r2++

80005ea0 <vTick>:
/* The preemptive scheduler is defined as "naked" as the full context is saved
on entry as part of the context switch. */
__attribute__((__naked__)) static void vTick( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_OS_INT();
80005ea0:	eb cd 00 ff 	pushm	r0-r7
80005ea4:	e0 68 05 34 	mov	r8,1332
80005ea8:	ea 18 00 00 	orh	r8,0x0
80005eac:	70 00       	ld.w	r0,r8[0x0]
80005eae:	1a d0       	st.w	--sp,r0
80005eb0:	7a 90       	ld.w	r0,sp[0x24]
80005eb2:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80005eb6:	58 10       	cp.w	r0,1
80005eb8:	e0 8b 00 08 	brhi	80005ec8 <LABEL_INT_SKIP_SAVE_CONTEXT_237>
80005ebc:	e0 68 0c f8 	mov	r8,3320
80005ec0:	ea 18 00 00 	orh	r8,0x0
80005ec4:	70 00       	ld.w	r0,r8[0x0]
80005ec6:	81 0d       	st.w	r0[0x0],sp

80005ec8 <LABEL_INT_SKIP_SAVE_CONTEXT_237>:
	#if( configTICK_USE_TC==1 )
		/* Clear the interrupt flag. */
		prvClearTcInt();
	#else
		/* Clear the interrupt flag. */
		prvClearCcInt();
80005ec8:	f0 1f 00 12 	mcall	80005f10 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x14>
	#endif

	/* Because FreeRTOS is not supposed to run with nested interrupts, put all OS
	calls in a critical section . */
	portENTER_CRITICAL();
80005ecc:	f0 1f 00 12 	mcall	80005f14 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
		vTaskIncrementTick();
80005ed0:	f0 1f 00 12 	mcall	80005f18 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x1c>
	portEXIT_CRITICAL();
80005ed4:	f0 1f 00 12 	mcall	80005f1c <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>

	/* Restore the context of the "elected task". */
	portRESTORE_CONTEXT_OS_INT();
80005ed8:	7a 90       	ld.w	r0,sp[0x24]
80005eda:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80005ede:	58 10       	cp.w	r0,1
80005ee0:	e0 8b 00 0e 	brhi	80005efc <LABEL_INT_SKIP_RESTORE_CONTEXT_254>
80005ee4:	f0 1f 00 0c 	mcall	80005f14 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
80005ee8:	f0 1f 00 0e 	mcall	80005f20 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x24>
80005eec:	f0 1f 00 0c 	mcall	80005f1c <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>
80005ef0:	e0 68 0c f8 	mov	r8,3320
80005ef4:	ea 18 00 00 	orh	r8,0x0
80005ef8:	70 00       	ld.w	r0,r8[0x0]
80005efa:	60 0d       	ld.w	sp,r0[0x0]

80005efc <LABEL_INT_SKIP_RESTORE_CONTEXT_254>:
80005efc:	1b 00       	ld.w	r0,sp++
80005efe:	e0 68 05 34 	mov	r8,1332
80005f02:	ea 18 00 00 	orh	r8,0x0
80005f06:	91 00       	st.w	r8[0x0],r0
80005f08:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005f0c:	d6 03       	rete
80005f0e:	00 00       	add	r0,r0
80005f10:	80 00       	ld.sh	r0,r0[0x0]
80005f12:	5e 74       	retpl	r4
80005f14:	80 00       	ld.sh	r0,r0[0x0]
80005f16:	5d 74       	*unknown*
80005f18:	80 00       	ld.sh	r0,r0[0x0]
80005f1a:	67 14       	ld.w	r4,r3[0x44]
80005f1c:	80 00       	ld.sh	r0,r0[0x0]
80005f1e:	5e 80       	retls	r0
80005f20:	80 00       	ld.sh	r0,r0[0x0]
80005f22:	65 10       	ld.w	r0,r2[0x44]

80005f24 <__malloc_lock>:
 * safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_lock(struct _reent *ptr);
void __malloc_lock(struct _reent *ptr)
{
80005f24:	d4 01       	pushm	lr
	vTaskSuspendAll();
80005f26:	f0 1f 00 02 	mcall	80005f2c <__malloc_lock+0x8>
}
80005f2a:	d8 02       	popm	pc
80005f2c:	80 00       	ld.sh	r0,r0[0x0]
80005f2e:	65 00       	ld.w	r0,r2[0x40]

80005f30 <__malloc_unlock>:
 * a safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_unlock(struct _reent *ptr);
void __malloc_unlock(struct _reent *ptr)
{
80005f30:	d4 01       	pushm	lr
	xTaskResumeAll();
80005f32:	f0 1f 00 02 	mcall	80005f38 <__malloc_unlock+0x8>
}
80005f36:	d8 02       	popm	pc
80005f38:	80 00       	ld.sh	r0,r0[0x0]
80005f3a:	68 bc       	ld.w	r12,r4[0x2c]

80005f3c <_read>:
/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
{
80005f3c:	d4 21       	pushm	r4-r7,lr
80005f3e:	16 95       	mov	r5,r11
80005f40:	14 96       	mov	r6,r10
  int nChars = 0;

  if (file != 0)
80005f42:	58 0c       	cp.w	r12,0
80005f44:	c0 30       	breq	80005f4a <_read+0xe>
80005f46:	3f f7       	mov	r7,-1
80005f48:	c1 48       	rjmp	80005f70 <_read+0x34>
    return -1;

  for (; len > 0; --len)
80005f4a:	58 0a       	cp.w	r10,0
80005f4c:	e0 89 00 04 	brgt	80005f54 <_read+0x18>
80005f50:	30 07       	mov	r7,0
80005f52:	c0 f8       	rjmp	80005f70 <_read+0x34>
80005f54:	30 07       	mov	r7,0
  {
    int c = usart_getchar(stdio_usart_base);
80005f56:	48 84       	lddpc	r4,80005f74 <_read+0x38>
80005f58:	68 0c       	ld.w	r12,r4[0x0]
80005f5a:	f0 1f 00 08 	mcall	80005f78 <_read+0x3c>
    if (c < 0)
80005f5e:	c0 95       	brlt	80005f70 <_read+0x34>
      break;

    *ptr++ = c;
80005f60:	ea 07 0b 0c 	st.b	r5[r7],r12
    ++nChars;
80005f64:	2f f7       	sub	r7,-1

/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
80005f66:	ec 07 01 08 	sub	r8,r6,r7
  int nChars = 0;

  if (file != 0)
    return -1;

  for (; len > 0; --len)
80005f6a:	58 08       	cp.w	r8,0
80005f6c:	fe 99 ff f6 	brgt	80005f58 <_read+0x1c>
    *ptr++ = c;
    ++nChars;
  }

  return nChars;
}
80005f70:	0e 9c       	mov	r12,r7
80005f72:	d8 22       	popm	r4-r7,pc
80005f74:	00 00       	add	r0,r0
80005f76:	65 94       	ld.w	r4,r2[0x64]
80005f78:	80 00       	ld.sh	r0,r0[0x0]
80005f7a:	5a c8       	cp.w	r8,-20

80005f7c <_write>:
 * 1 and 2 is stdout and stderr which goes to usart
 * 3 is framebuffer
 */
int __attribute__((weak))
_write (int file, char * ptr, int len)
{
80005f7c:	d4 21       	pushm	r4-r7,lr
80005f7e:	16 95       	mov	r5,r11
80005f80:	14 96       	mov	r6,r10
  int nChars = 0;

  if ( (file != 1)
80005f82:	20 1c       	sub	r12,1
80005f84:	58 2c       	cp.w	r12,2
80005f86:	e0 8b 00 12 	brhi	80005faa <_write+0x2e>
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80005f8a:	58 0a       	cp.w	r10,0
80005f8c:	c0 31       	brne	80005f92 <_write+0x16>
80005f8e:	30 07       	mov	r7,0
80005f90:	c0 e8       	rjmp	80005fac <_write+0x30>
80005f92:	30 07       	mov	r7,0
  {
    if (usart_putchar(stdio_usart_base, *ptr++) < 0)
80005f94:	48 74       	lddpc	r4,80005fb0 <_write+0x34>
80005f96:	68 0c       	ld.w	r12,r4[0x0]
80005f98:	ea 07 07 0b 	ld.ub	r11,r5[r7]
80005f9c:	f0 1f 00 06 	mcall	80005fb4 <_write+0x38>
80005fa0:	c0 55       	brlt	80005faa <_write+0x2e>
    {
      return -1;
    }

    ++nChars;
80005fa2:	2f f7       	sub	r7,-1

  if ( (file != 1)
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80005fa4:	0e 36       	cp.w	r6,r7
80005fa6:	cf 81       	brne	80005f96 <_write+0x1a>
80005fa8:	c0 28       	rjmp	80005fac <_write+0x30>
80005faa:	3f f7       	mov	r7,-1

    ++nChars;
  }

  return nChars;
}
80005fac:	0e 9c       	mov	r12,r7
80005fae:	d8 22       	popm	r4-r7,pc
80005fb0:	00 00       	add	r0,r0
80005fb2:	65 94       	ld.w	r4,r2[0x64]
80005fb4:	80 00       	ld.sh	r0,r0[0x0]
80005fb6:	5a 78       	cp.w	r8,-25

80005fb8 <vPortFree>:
	return pvReturn;
}
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
80005fb8:	eb cd 40 80 	pushm	r7,lr
80005fbc:	18 97       	mov	r7,r12
	if( pv )
80005fbe:	58 0c       	cp.w	r12,0
80005fc0:	c0 80       	breq	80005fd0 <vPortFree+0x18>
	{
		vTaskSuspendAll();
80005fc2:	f0 1f 00 05 	mcall	80005fd4 <vPortFree+0x1c>
		{
			free( pv );
80005fc6:	0e 9c       	mov	r12,r7
80005fc8:	f0 1f 00 04 	mcall	80005fd8 <vPortFree+0x20>
		}
		xTaskResumeAll();
80005fcc:	f0 1f 00 04 	mcall	80005fdc <vPortFree+0x24>
80005fd0:	e3 cd 80 80 	ldm	sp++,r7,pc
80005fd4:	80 00       	ld.sh	r0,r0[0x0]
80005fd6:	65 00       	ld.w	r0,r2[0x40]
80005fd8:	80 00       	ld.sh	r0,r0[0x0]
80005fda:	73 90       	ld.w	r0,r9[0x64]
80005fdc:	80 00       	ld.sh	r0,r0[0x0]
80005fde:	68 bc       	ld.w	r12,r4[0x2c]

80005fe0 <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
80005fe0:	eb cd 40 80 	pushm	r7,lr
80005fe4:	18 97       	mov	r7,r12
void *pvReturn;

	vTaskSuspendAll();
80005fe6:	f0 1f 00 06 	mcall	80005ffc <pvPortMalloc+0x1c>
	{
		pvReturn = malloc( xWantedSize );
80005fea:	0e 9c       	mov	r12,r7
80005fec:	f0 1f 00 05 	mcall	80006000 <pvPortMalloc+0x20>
80005ff0:	18 97       	mov	r7,r12
	}
	xTaskResumeAll();
80005ff2:	f0 1f 00 05 	mcall	80006004 <pvPortMalloc+0x24>
		}
	}
	#endif

	return pvReturn;
}
80005ff6:	0e 9c       	mov	r12,r7
80005ff8:	e3 cd 80 80 	ldm	sp++,r7,pc
80005ffc:	80 00       	ld.sh	r0,r0[0x0]
80005ffe:	65 00       	ld.w	r0,r2[0x40]
80006000:	80 00       	ld.sh	r0,r0[0x0]
80006002:	73 a0       	ld.w	r0,r9[0x68]
80006004:	80 00       	ld.sh	r0,r0[0x0]
80006006:	68 bc       	ld.w	r12,r4[0x2c]

80006008 <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
80006008:	d4 01       	pushm	lr
8000600a:	16 98       	mov	r8,r11
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
8000600c:	78 09       	ld.w	r9,r12[0x0]
8000600e:	58 09       	cp.w	r9,0
80006010:	c1 10       	breq	80006032 <prvCopyDataFromQueue+0x2a>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
80006012:	78 3a       	ld.w	r10,r12[0xc]
80006014:	79 09       	ld.w	r9,r12[0x40]
80006016:	f4 09 00 09 	add	r9,r10,r9
8000601a:	99 39       	st.w	r12[0xc],r9
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
8000601c:	78 1a       	ld.w	r10,r12[0x4]
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
8000601e:	14 39       	cp.w	r9,r10
80006020:	f9 f9 20 00 	ld.wcc	r9,r12[0x0]
80006024:	f9 f9 2a 03 	st.wcc	r12[0xc],r9
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
80006028:	79 0a       	ld.w	r10,r12[0x40]
8000602a:	78 3b       	ld.w	r11,r12[0xc]
8000602c:	10 9c       	mov	r12,r8
8000602e:	f0 1f 00 02 	mcall	80006034 <prvCopyDataFromQueue+0x2c>
80006032:	d8 02       	popm	pc
80006034:	80 00       	ld.sh	r0,r0[0x0]
80006036:	77 e8       	ld.w	r8,r11[0x78]

80006038 <xQueueReceiveFromISR>:
	}
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
80006038:	eb cd 40 c0 	pushm	r6-r7,lr
8000603c:	18 97       	mov	r7,r12
8000603e:	14 96       	mov	r6,r10
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80006040:	78 e8       	ld.w	r8,r12[0x38]
80006042:	58 08       	cp.w	r8,0
80006044:	c0 31       	brne	8000604a <xQueueReceiveFromISR+0x12>
80006046:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
8000604a:	f0 1f 00 0e 	mcall	80006080 <xQueueReceiveFromISR+0x48>
			--( pxQueue->uxMessagesWaiting );
8000604e:	6e e8       	ld.w	r8,r7[0x38]
80006050:	20 18       	sub	r8,1
80006052:	8f e8       	st.w	r7[0x38],r8

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
80006054:	6f 18       	ld.w	r8,r7[0x44]
80006056:	5b f8       	cp.w	r8,-1
80006058:	c0 d1       	brne	80006072 <xQueueReceiveFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
8000605a:	6e 48       	ld.w	r8,r7[0x10]
8000605c:	58 08       	cp.w	r8,0
8000605e:	c0 f0       	breq	8000607c <xQueueReceiveFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80006060:	ee cc ff f0 	sub	r12,r7,-16
80006064:	f0 1f 00 08 	mcall	80006084 <xQueueReceiveFromISR+0x4c>
80006068:	c0 a0       	breq	8000607c <xQueueReceiveFromISR+0x44>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
8000606a:	30 1c       	mov	r12,1
8000606c:	8d 0c       	st.w	r6[0x0],r12
8000606e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
80006072:	2f f8       	sub	r8,-1
80006074:	ef 48 00 44 	st.w	r7[68],r8
80006078:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
8000607c:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80006080:	80 00       	ld.sh	r0,r0[0x0]
80006082:	60 08       	ld.w	r8,r0[0x0]
80006084:	80 00       	ld.sh	r0,r0[0x0]
80006086:	66 98       	ld.w	r8,r3[0x24]

80006088 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
80006088:	eb cd 40 c0 	pushm	r6-r7,lr
8000608c:	18 97       	mov	r7,r12

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
8000608e:	f0 1f 00 23 	mcall	80006118 <prvUnlockQueue+0x90>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80006092:	6f 28       	ld.w	r8,r7[0x48]
80006094:	58 08       	cp.w	r8,0
80006096:	e0 8a 00 18 	brle	800060c6 <prvUnlockQueue+0x3e>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
8000609a:	6e 98       	ld.w	r8,r7[0x24]
8000609c:	58 08       	cp.w	r8,0
8000609e:	c1 40       	breq	800060c6 <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
800060a0:	ee c6 ff dc 	sub	r6,r7,-36
800060a4:	c0 48       	rjmp	800060ac <prvUnlockQueue+0x24>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
800060a6:	6e 98       	ld.w	r8,r7[0x24]
800060a8:	58 08       	cp.w	r8,0
800060aa:	c0 e0       	breq	800060c6 <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
800060ac:	0c 9c       	mov	r12,r6
800060ae:	f0 1f 00 1c 	mcall	8000611c <prvUnlockQueue+0x94>
800060b2:	c0 30       	breq	800060b8 <prvUnlockQueue+0x30>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
800060b4:	f0 1f 00 1b 	mcall	80006120 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xTxLock );
800060b8:	6f 28       	ld.w	r8,r7[0x48]
800060ba:	20 18       	sub	r8,1
800060bc:	ef 48 00 48 	st.w	r7[72],r8
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
800060c0:	58 08       	cp.w	r8,0
800060c2:	fe 99 ff f2 	brgt	800060a6 <prvUnlockQueue+0x1e>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
800060c6:	3f f8       	mov	r8,-1
800060c8:	ef 48 00 48 	st.w	r7[72],r8
	}
	taskEXIT_CRITICAL();
800060cc:	f0 1f 00 16 	mcall	80006124 <prvUnlockQueue+0x9c>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
800060d0:	f0 1f 00 12 	mcall	80006118 <prvUnlockQueue+0x90>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
800060d4:	6f 18       	ld.w	r8,r7[0x44]
800060d6:	58 08       	cp.w	r8,0
800060d8:	e0 8a 00 18 	brle	80006108 <prvUnlockQueue+0x80>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
800060dc:	6e 48       	ld.w	r8,r7[0x10]
800060de:	58 08       	cp.w	r8,0
800060e0:	c1 40       	breq	80006108 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
800060e2:	ee c6 ff f0 	sub	r6,r7,-16
800060e6:	c0 48       	rjmp	800060ee <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
800060e8:	6e 48       	ld.w	r8,r7[0x10]
800060ea:	58 08       	cp.w	r8,0
800060ec:	c0 e0       	breq	80006108 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
800060ee:	0c 9c       	mov	r12,r6
800060f0:	f0 1f 00 0b 	mcall	8000611c <prvUnlockQueue+0x94>
800060f4:	c0 30       	breq	800060fa <prvUnlockQueue+0x72>
				{
					vTaskMissedYield();
800060f6:	f0 1f 00 0b 	mcall	80006120 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xRxLock );
800060fa:	6f 18       	ld.w	r8,r7[0x44]
800060fc:	20 18       	sub	r8,1
800060fe:	ef 48 00 44 	st.w	r7[68],r8
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
80006102:	58 08       	cp.w	r8,0
80006104:	fe 99 ff f2 	brgt	800060e8 <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
80006108:	3f f8       	mov	r8,-1
8000610a:	ef 48 00 44 	st.w	r7[68],r8
	}
	taskEXIT_CRITICAL();
8000610e:	f0 1f 00 06 	mcall	80006124 <prvUnlockQueue+0x9c>
}
80006112:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006116:	00 00       	add	r0,r0
80006118:	80 00       	ld.sh	r0,r0[0x0]
8000611a:	5d 74       	*unknown*
8000611c:	80 00       	ld.sh	r0,r0[0x0]
8000611e:	66 98       	ld.w	r8,r3[0x24]
80006120:	80 00       	ld.sh	r0,r0[0x0]
80006122:	65 a4       	ld.w	r4,r2[0x68]
80006124:	80 00       	ld.sh	r0,r0[0x0]
80006126:	5e 80       	retls	r0

80006128 <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
80006128:	d4 31       	pushm	r0-r7,lr
8000612a:	20 5d       	sub	sp,20
8000612c:	18 97       	mov	r7,r12
8000612e:	50 0b       	stdsp	sp[0x0],r11
80006130:	50 2a       	stdsp	sp[0x8],r10
80006132:	50 19       	stdsp	sp[0x4],r9
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80006134:	f8 c2 ff dc 	sub	r2,r12,-36
80006138:	30 05       	mov	r5,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
8000613a:	fa c4 ff f4 	sub	r4,sp,-12
8000613e:	30 10       	mov	r0,1

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
80006140:	0a 91       	mov	r1,r5

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80006142:	fa c3 ff f8 	sub	r3,sp,-8
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
80006146:	f0 1f 00 3e 	mcall	8000623c <xQueueGenericReceive+0x114>
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
8000614a:	6e e8       	ld.w	r8,r7[0x38]
8000614c:	58 08       	cp.w	r8,0
8000614e:	c2 a0       	breq	800061a2 <xQueueGenericReceive+0x7a>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
80006150:	6e 36       	ld.w	r6,r7[0xc]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
80006152:	40 0b       	lddsp	r11,sp[0x0]
80006154:	0e 9c       	mov	r12,r7
80006156:	f0 1f 00 3b 	mcall	80006240 <xQueueGenericReceive+0x118>

				if( xJustPeeking == pdFALSE )
8000615a:	40 18       	lddsp	r8,sp[0x4]
8000615c:	58 08       	cp.w	r8,0
8000615e:	c1 51       	brne	80006188 <xQueueGenericReceive+0x60>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
80006160:	6e e8       	ld.w	r8,r7[0x38]
80006162:	20 18       	sub	r8,1
80006164:	8f e8       	st.w	r7[0x38],r8

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80006166:	6e 08       	ld.w	r8,r7[0x0]
80006168:	58 08       	cp.w	r8,0
8000616a:	c0 41       	brne	80006172 <xQueueGenericReceive+0x4a>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
8000616c:	f0 1f 00 36 	mcall	80006244 <xQueueGenericReceive+0x11c>
80006170:	8f 1c       	st.w	r7[0x4],r12
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80006172:	6e 48       	ld.w	r8,r7[0x10]
80006174:	58 08       	cp.w	r8,0
80006176:	c1 20       	breq	8000619a <xQueueGenericReceive+0x72>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
80006178:	ee cc ff f0 	sub	r12,r7,-16
8000617c:	f0 1f 00 33 	mcall	80006248 <xQueueGenericReceive+0x120>
80006180:	58 1c       	cp.w	r12,1
80006182:	c0 c1       	brne	8000619a <xQueueGenericReceive+0x72>
						{
							portYIELD_WITHIN_API();
80006184:	d7 33       	scall
80006186:	c0 a8       	rjmp	8000619a <xQueueGenericReceive+0x72>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
80006188:	8f 36       	st.w	r7[0xc],r6

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
8000618a:	6e 98       	ld.w	r8,r7[0x24]
8000618c:	58 08       	cp.w	r8,0
8000618e:	c0 60       	breq	8000619a <xQueueGenericReceive+0x72>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80006190:	04 9c       	mov	r12,r2
80006192:	f0 1f 00 2e 	mcall	80006248 <xQueueGenericReceive+0x120>
80006196:	c0 20       	breq	8000619a <xQueueGenericReceive+0x72>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
80006198:	d7 33       	scall
						}
					}

				}

				taskEXIT_CRITICAL();
8000619a:	f0 1f 00 2d 	mcall	8000624c <xQueueGenericReceive+0x124>
8000619e:	30 1c       	mov	r12,1
				return pdPASS;
800061a0:	c4 c8       	rjmp	80006238 <xQueueGenericReceive+0x110>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
800061a2:	40 28       	lddsp	r8,sp[0x8]
800061a4:	58 08       	cp.w	r8,0
800061a6:	c0 51       	brne	800061b0 <xQueueGenericReceive+0x88>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
800061a8:	f0 1f 00 29 	mcall	8000624c <xQueueGenericReceive+0x124>
800061ac:	30 0c       	mov	r12,0
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
800061ae:	c4 58       	rjmp	80006238 <xQueueGenericReceive+0x110>
				}
				else if( xEntryTimeSet == pdFALSE )
800061b0:	58 05       	cp.w	r5,0
800061b2:	c0 51       	brne	800061bc <xQueueGenericReceive+0x94>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
800061b4:	08 9c       	mov	r12,r4
800061b6:	f0 1f 00 27 	mcall	80006250 <xQueueGenericReceive+0x128>
800061ba:	00 95       	mov	r5,r0
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
800061bc:	f0 1f 00 24 	mcall	8000624c <xQueueGenericReceive+0x124>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
800061c0:	f0 1f 00 25 	mcall	80006254 <xQueueGenericReceive+0x12c>
		prvLockQueue( pxQueue );
800061c4:	f0 1f 00 1e 	mcall	8000623c <xQueueGenericReceive+0x114>
800061c8:	6f 18       	ld.w	r8,r7[0x44]
800061ca:	5b f8       	cp.w	r8,-1
800061cc:	ef f1 0a 11 	st.weq	r7[0x44],r1
800061d0:	6f 28       	ld.w	r8,r7[0x48]
800061d2:	5b f8       	cp.w	r8,-1
800061d4:	ef f1 0a 12 	st.weq	r7[0x48],r1
800061d8:	f0 1f 00 1d 	mcall	8000624c <xQueueGenericReceive+0x124>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
800061dc:	06 9b       	mov	r11,r3
800061de:	08 9c       	mov	r12,r4
800061e0:	f0 1f 00 1e 	mcall	80006258 <xQueueGenericReceive+0x130>
800061e4:	c2 41       	brne	8000622c <xQueueGenericReceive+0x104>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
800061e6:	f0 1f 00 16 	mcall	8000623c <xQueueGenericReceive+0x114>
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
800061ea:	6e e6       	ld.w	r6,r7[0x38]
	taskEXIT_CRITICAL();
800061ec:	f0 1f 00 18 	mcall	8000624c <xQueueGenericReceive+0x124>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) )
800061f0:	58 06       	cp.w	r6,0
800061f2:	c1 71       	brne	80006220 <xQueueGenericReceive+0xf8>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
800061f4:	6e 08       	ld.w	r8,r7[0x0]
800061f6:	58 08       	cp.w	r8,0
800061f8:	c0 81       	brne	80006208 <xQueueGenericReceive+0xe0>
					{
						portENTER_CRITICAL();
800061fa:	f0 1f 00 11 	mcall	8000623c <xQueueGenericReceive+0x114>
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
800061fe:	6e 1c       	ld.w	r12,r7[0x4]
80006200:	f0 1f 00 17 	mcall	8000625c <xQueueGenericReceive+0x134>
						}
						portEXIT_CRITICAL();
80006204:	f0 1f 00 12 	mcall	8000624c <xQueueGenericReceive+0x124>
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80006208:	40 2b       	lddsp	r11,sp[0x8]
8000620a:	04 9c       	mov	r12,r2
8000620c:	f0 1f 00 15 	mcall	80006260 <xQueueGenericReceive+0x138>
				prvUnlockQueue( pxQueue );
80006210:	0e 9c       	mov	r12,r7
80006212:	f0 1f 00 15 	mcall	80006264 <xQueueGenericReceive+0x13c>
				if( !xTaskResumeAll() )
80006216:	f0 1f 00 15 	mcall	80006268 <xQueueGenericReceive+0x140>
8000621a:	c9 61       	brne	80006146 <xQueueGenericReceive+0x1e>
				{
					portYIELD_WITHIN_API();
8000621c:	d7 33       	scall
8000621e:	c9 4b       	rjmp	80006146 <xQueueGenericReceive+0x1e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
80006220:	0e 9c       	mov	r12,r7
80006222:	f0 1f 00 11 	mcall	80006264 <xQueueGenericReceive+0x13c>
				( void ) xTaskResumeAll();
80006226:	f0 1f 00 11 	mcall	80006268 <xQueueGenericReceive+0x140>
8000622a:	c8 eb       	rjmp	80006146 <xQueueGenericReceive+0x1e>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
8000622c:	0e 9c       	mov	r12,r7
8000622e:	f0 1f 00 0e 	mcall	80006264 <xQueueGenericReceive+0x13c>
			( void ) xTaskResumeAll();
80006232:	f0 1f 00 0e 	mcall	80006268 <xQueueGenericReceive+0x140>
80006236:	30 0c       	mov	r12,0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
80006238:	2f bd       	sub	sp,-20
8000623a:	d8 32       	popm	r0-r7,pc
8000623c:	80 00       	ld.sh	r0,r0[0x0]
8000623e:	5d 74       	*unknown*
80006240:	80 00       	ld.sh	r0,r0[0x0]
80006242:	60 08       	ld.w	r8,r0[0x0]
80006244:	80 00       	ld.sh	r0,r0[0x0]
80006246:	65 b0       	ld.w	r0,r2[0x6c]
80006248:	80 00       	ld.sh	r0,r0[0x0]
8000624a:	66 98       	ld.w	r8,r3[0x24]
8000624c:	80 00       	ld.sh	r0,r0[0x0]
8000624e:	5e 80       	retls	r0
80006250:	80 00       	ld.sh	r0,r0[0x0]
80006252:	65 8c       	ld.w	r12,r2[0x60]
80006254:	80 00       	ld.sh	r0,r0[0x0]
80006256:	65 00       	ld.w	r0,r2[0x40]
80006258:	80 00       	ld.sh	r0,r0[0x0]
8000625a:	68 28       	ld.w	r8,r4[0x8]
8000625c:	80 00       	ld.sh	r0,r0[0x0]
8000625e:	66 14       	ld.w	r4,r3[0x4]
80006260:	80 00       	ld.sh	r0,r0[0x0]
80006262:	6a c8       	ld.w	r8,r5[0x30]
80006264:	80 00       	ld.sh	r0,r0[0x0]
80006266:	60 88       	ld.w	r8,r0[0x20]
80006268:	80 00       	ld.sh	r0,r0[0x0]
8000626a:	68 bc       	ld.w	r12,r4[0x2c]

8000626c <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
8000626c:	eb cd 40 80 	pushm	r7,lr
80006270:	18 97       	mov	r7,r12
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
80006272:	79 08       	ld.w	r8,r12[0x40]
80006274:	58 08       	cp.w	r8,0
80006276:	c0 a1       	brne	8000628a <prvCopyDataToQueue+0x1e>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80006278:	78 08       	ld.w	r8,r12[0x0]
8000627a:	58 08       	cp.w	r8,0
8000627c:	c2 b1       	brne	800062d2 <prvCopyDataToQueue+0x66>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
8000627e:	78 1c       	ld.w	r12,r12[0x4]
80006280:	f0 1f 00 17 	mcall	800062dc <prvCopyDataToQueue+0x70>
				pxQueue->pxMutexHolder = NULL;
80006284:	30 08       	mov	r8,0
80006286:	8f 18       	st.w	r7[0x4],r8
80006288:	c2 58       	rjmp	800062d2 <prvCopyDataToQueue+0x66>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
8000628a:	58 0a       	cp.w	r10,0
8000628c:	c1 01       	brne	800062ac <prvCopyDataToQueue+0x40>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
8000628e:	10 9a       	mov	r10,r8
80006290:	78 2c       	ld.w	r12,r12[0x8]
80006292:	f0 1f 00 14 	mcall	800062e0 <prvCopyDataToQueue+0x74>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
80006296:	6e 29       	ld.w	r9,r7[0x8]
80006298:	6f 08       	ld.w	r8,r7[0x40]
8000629a:	f2 08 00 08 	add	r8,r9,r8
8000629e:	8f 28       	st.w	r7[0x8],r8
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
800062a0:	6e 19       	ld.w	r9,r7[0x4]
800062a2:	12 38       	cp.w	r8,r9
800062a4:	c1 73       	brcs	800062d2 <prvCopyDataToQueue+0x66>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
800062a6:	6e 08       	ld.w	r8,r7[0x0]
800062a8:	8f 28       	st.w	r7[0x8],r8
800062aa:	c1 48       	rjmp	800062d2 <prvCopyDataToQueue+0x66>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
800062ac:	10 9a       	mov	r10,r8
800062ae:	78 3c       	ld.w	r12,r12[0xc]
800062b0:	f0 1f 00 0c 	mcall	800062e0 <prvCopyDataToQueue+0x74>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
800062b4:	6f 08       	ld.w	r8,r7[0x40]
800062b6:	6e 39       	ld.w	r9,r7[0xc]
800062b8:	f2 08 01 08 	sub	r8,r9,r8
800062bc:	8f 38       	st.w	r7[0xc],r8
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
800062be:	6e 09       	ld.w	r9,r7[0x0]
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
800062c0:	12 38       	cp.w	r8,r9
800062c2:	ef f8 30 10 	ld.wcs	r8,r7[0x40]
800062c6:	ef f9 30 01 	ld.wcs	r9,r7[0x4]
800062ca:	f3 d8 e3 19 	subcs	r9,r9,r8
800062ce:	ef f9 3a 03 	st.wcs	r7[0xc],r9
		}
	}

	++( pxQueue->uxMessagesWaiting );
800062d2:	6e e8       	ld.w	r8,r7[0x38]
800062d4:	2f f8       	sub	r8,-1
800062d6:	8f e8       	st.w	r7[0x38],r8
}
800062d8:	e3 cd 80 80 	ldm	sp++,r7,pc
800062dc:	80 00       	ld.sh	r0,r0[0x0]
800062de:	65 bc       	ld.w	r12,r2[0x6c]
800062e0:	80 00       	ld.sh	r0,r0[0x0]
800062e2:	77 e8       	ld.w	r8,r11[0x78]

800062e4 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
800062e4:	eb cd 40 c0 	pushm	r6-r7,lr
800062e8:	18 97       	mov	r7,r12
800062ea:	14 96       	mov	r6,r10
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
800062ec:	78 ec       	ld.w	r12,r12[0x38]
800062ee:	6e f8       	ld.w	r8,r7[0x3c]
800062f0:	10 3c       	cp.w	r12,r8
800062f2:	c0 33       	brcs	800062f8 <xQueueGenericSendFromISR+0x14>
800062f4:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
800062f8:	12 9a       	mov	r10,r9
800062fa:	0e 9c       	mov	r12,r7
800062fc:	f0 1f 00 0c 	mcall	8000632c <xQueueGenericSendFromISR+0x48>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
80006300:	6f 28       	ld.w	r8,r7[0x48]
80006302:	5b f8       	cp.w	r8,-1
80006304:	c0 d1       	brne	8000631e <xQueueGenericSendFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80006306:	6e 98       	ld.w	r8,r7[0x24]
80006308:	58 08       	cp.w	r8,0
8000630a:	c0 f0       	breq	80006328 <xQueueGenericSendFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
8000630c:	ee cc ff dc 	sub	r12,r7,-36
80006310:	f0 1f 00 08 	mcall	80006330 <xQueueGenericSendFromISR+0x4c>
80006314:	c0 a0       	breq	80006328 <xQueueGenericSendFromISR+0x44>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
80006316:	30 1c       	mov	r12,1
80006318:	8d 0c       	st.w	r6[0x0],r12
8000631a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
8000631e:	2f f8       	sub	r8,-1
80006320:	ef 48 00 48 	st.w	r7[72],r8
80006324:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80006328:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
8000632c:	80 00       	ld.sh	r0,r0[0x0]
8000632e:	62 6c       	ld.w	r12,r1[0x18]
80006330:	80 00       	ld.sh	r0,r0[0x0]
80006332:	66 98       	ld.w	r8,r3[0x24]

80006334 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
80006334:	d4 31       	pushm	r0-r7,lr
80006336:	20 5d       	sub	sp,20
80006338:	18 97       	mov	r7,r12
8000633a:	50 0b       	stdsp	sp[0x0],r11
8000633c:	50 2a       	stdsp	sp[0x8],r10
8000633e:	50 19       	stdsp	sp[0x4],r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
80006340:	f8 c0 ff f0 	sub	r0,r12,-16
80006344:	30 04       	mov	r4,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80006346:	fa c3 ff f4 	sub	r3,sp,-12

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
8000634a:	08 91       	mov	r1,r4

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
8000634c:	fa c2 ff f8 	sub	r2,sp,-8
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
80006350:	f0 1f 00 2f 	mcall	8000640c <xQueueGenericSend+0xd8>
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
80006354:	6e e9       	ld.w	r9,r7[0x38]
80006356:	6e f8       	ld.w	r8,r7[0x3c]
80006358:	10 39       	cp.w	r9,r8
8000635a:	c1 42       	brcc	80006382 <xQueueGenericSend+0x4e>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
8000635c:	40 1a       	lddsp	r10,sp[0x4]
8000635e:	40 0b       	lddsp	r11,sp[0x0]
80006360:	0e 9c       	mov	r12,r7
80006362:	f0 1f 00 2c 	mcall	80006410 <xQueueGenericSend+0xdc>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80006366:	6e 98       	ld.w	r8,r7[0x24]
80006368:	58 08       	cp.w	r8,0
8000636a:	c0 80       	breq	8000637a <xQueueGenericSend+0x46>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
8000636c:	ee cc ff dc 	sub	r12,r7,-36
80006370:	f0 1f 00 29 	mcall	80006414 <xQueueGenericSend+0xe0>
80006374:	58 1c       	cp.w	r12,1
80006376:	c0 21       	brne	8000637a <xQueueGenericSend+0x46>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
80006378:	d7 33       	scall
					}
				}

				taskEXIT_CRITICAL();
8000637a:	f0 1f 00 28 	mcall	80006418 <xQueueGenericSend+0xe4>
8000637e:	30 1c       	mov	r12,1

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
80006380:	c4 38       	rjmp	80006406 <xQueueGenericSend+0xd2>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
80006382:	40 28       	lddsp	r8,sp[0x8]
80006384:	58 08       	cp.w	r8,0
80006386:	c0 51       	brne	80006390 <xQueueGenericSend+0x5c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80006388:	f0 1f 00 24 	mcall	80006418 <xQueueGenericSend+0xe4>
8000638c:	30 0c       	mov	r12,0

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
8000638e:	c3 c8       	rjmp	80006406 <xQueueGenericSend+0xd2>
				}
				else if( xEntryTimeSet == pdFALSE )
80006390:	58 04       	cp.w	r4,0
80006392:	c0 51       	brne	8000639c <xQueueGenericSend+0x68>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80006394:	06 9c       	mov	r12,r3
80006396:	f0 1f 00 22 	mcall	8000641c <xQueueGenericSend+0xe8>
8000639a:	30 14       	mov	r4,1
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
8000639c:	f0 1f 00 1f 	mcall	80006418 <xQueueGenericSend+0xe4>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
800063a0:	f0 1f 00 20 	mcall	80006420 <xQueueGenericSend+0xec>
		prvLockQueue( pxQueue );
800063a4:	f0 1f 00 1a 	mcall	8000640c <xQueueGenericSend+0xd8>
800063a8:	6f 18       	ld.w	r8,r7[0x44]
800063aa:	5b f8       	cp.w	r8,-1
800063ac:	ef f1 0a 11 	st.weq	r7[0x44],r1
800063b0:	6f 28       	ld.w	r8,r7[0x48]
800063b2:	5b f8       	cp.w	r8,-1
800063b4:	ef f1 0a 12 	st.weq	r7[0x48],r1
800063b8:	f0 1f 00 18 	mcall	80006418 <xQueueGenericSend+0xe4>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
800063bc:	04 9b       	mov	r11,r2
800063be:	06 9c       	mov	r12,r3
800063c0:	f0 1f 00 19 	mcall	80006424 <xQueueGenericSend+0xf0>
800063c4:	c1 b1       	brne	800063fa <xQueueGenericSend+0xc6>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
800063c6:	f0 1f 00 12 	mcall	8000640c <xQueueGenericSend+0xd8>
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
800063ca:	6e e5       	ld.w	r5,r7[0x38]
800063cc:	6e f6       	ld.w	r6,r7[0x3c]
	taskEXIT_CRITICAL();
800063ce:	f0 1f 00 13 	mcall	80006418 <xQueueGenericSend+0xe4>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
800063d2:	0c 35       	cp.w	r5,r6
800063d4:	c0 d1       	brne	800063ee <xQueueGenericSend+0xba>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
800063d6:	40 2b       	lddsp	r11,sp[0x8]
800063d8:	00 9c       	mov	r12,r0
800063da:	f0 1f 00 14 	mcall	80006428 <xQueueGenericSend+0xf4>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
800063de:	0e 9c       	mov	r12,r7
800063e0:	f0 1f 00 13 	mcall	8000642c <xQueueGenericSend+0xf8>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
800063e4:	f0 1f 00 13 	mcall	80006430 <xQueueGenericSend+0xfc>
800063e8:	cb 41       	brne	80006350 <xQueueGenericSend+0x1c>
				{
					portYIELD_WITHIN_API();
800063ea:	d7 33       	scall
800063ec:	cb 2b       	rjmp	80006350 <xQueueGenericSend+0x1c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
800063ee:	0e 9c       	mov	r12,r7
800063f0:	f0 1f 00 0f 	mcall	8000642c <xQueueGenericSend+0xf8>
				( void ) xTaskResumeAll();
800063f4:	f0 1f 00 0f 	mcall	80006430 <xQueueGenericSend+0xfc>
800063f8:	ca cb       	rjmp	80006350 <xQueueGenericSend+0x1c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
800063fa:	0e 9c       	mov	r12,r7
800063fc:	f0 1f 00 0c 	mcall	8000642c <xQueueGenericSend+0xf8>
			( void ) xTaskResumeAll();
80006400:	f0 1f 00 0c 	mcall	80006430 <xQueueGenericSend+0xfc>
80006404:	30 0c       	mov	r12,0
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
80006406:	2f bd       	sub	sp,-20
80006408:	d8 32       	popm	r0-r7,pc
8000640a:	00 00       	add	r0,r0
8000640c:	80 00       	ld.sh	r0,r0[0x0]
8000640e:	5d 74       	*unknown*
80006410:	80 00       	ld.sh	r0,r0[0x0]
80006412:	62 6c       	ld.w	r12,r1[0x18]
80006414:	80 00       	ld.sh	r0,r0[0x0]
80006416:	66 98       	ld.w	r8,r3[0x24]
80006418:	80 00       	ld.sh	r0,r0[0x0]
8000641a:	5e 80       	retls	r0
8000641c:	80 00       	ld.sh	r0,r0[0x0]
8000641e:	65 8c       	ld.w	r12,r2[0x60]
80006420:	80 00       	ld.sh	r0,r0[0x0]
80006422:	65 00       	ld.w	r0,r2[0x40]
80006424:	80 00       	ld.sh	r0,r0[0x0]
80006426:	68 28       	ld.w	r8,r4[0x8]
80006428:	80 00       	ld.sh	r0,r0[0x0]
8000642a:	6a c8       	ld.w	r8,r5[0x30]
8000642c:	80 00       	ld.sh	r0,r0[0x0]
8000642e:	60 88       	ld.w	r8,r0[0x20]
80006430:	80 00       	ld.sh	r0,r0[0x0]
80006432:	68 bc       	ld.w	r12,r4[0x2c]

80006434 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	xQueueHandle xQueueCreateMutex( void )
	{
80006434:	eb cd 40 c0 	pushm	r6-r7,lr
	xQUEUE *pxNewQueue;

		/* Allocate the new queue structure. */
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
80006438:	34 cc       	mov	r12,76
8000643a:	f0 1f 00 12 	mcall	80006480 <xQueueCreateMutex+0x4c>
8000643e:	18 97       	mov	r7,r12
		if( pxNewQueue != NULL )
80006440:	c1 d0       	breq	8000647a <xQueueCreateMutex+0x46>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
80006442:	30 06       	mov	r6,0
80006444:	99 16       	st.w	r12[0x4],r6
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
80006446:	99 06       	st.w	r12[0x0],r6

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
80006448:	99 26       	st.w	r12[0x8],r6
			pxNewQueue->pcReadFrom = NULL;
8000644a:	99 36       	st.w	r12[0xc],r6

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
8000644c:	99 e6       	st.w	r12[0x38],r6
			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
8000644e:	30 18       	mov	r8,1
80006450:	99 f8       	st.w	r12[0x3c],r8
			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
80006452:	f9 46 00 40 	st.w	r12[64],r6
			pxNewQueue->xRxLock = queueUNLOCKED;
80006456:	3f f8       	mov	r8,-1
80006458:	f9 48 00 44 	st.w	r12[68],r8
			pxNewQueue->xTxLock = queueUNLOCKED;
8000645c:	f9 48 00 48 	st.w	r12[72],r8

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
80006460:	2f 0c       	sub	r12,-16
80006462:	f0 1f 00 09 	mcall	80006484 <xQueueCreateMutex+0x50>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
80006466:	ee cc ff dc 	sub	r12,r7,-36
8000646a:	f0 1f 00 07 	mcall	80006484 <xQueueCreateMutex+0x50>

			/* Start with the semaphore in the expected state. */
			xQueueGenericSend( pxNewQueue, NULL, ( portTickType ) 0U, queueSEND_TO_BACK );
8000646e:	0c 99       	mov	r9,r6
80006470:	0c 9a       	mov	r10,r6
80006472:	0c 9b       	mov	r11,r6
80006474:	0e 9c       	mov	r12,r7
80006476:	f0 1f 00 05 	mcall	80006488 <xQueueCreateMutex+0x54>
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
8000647a:	0e 9c       	mov	r12,r7
8000647c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006480:	80 00       	ld.sh	r0,r0[0x0]
80006482:	5f e0       	srqs	r0
80006484:	80 00       	ld.sh	r0,r0[0x0]
80006486:	5c 50       	castu.b	r0
80006488:	80 00       	ld.sh	r0,r0[0x0]
8000648a:	63 34       	ld.w	r4,r1[0x4c]

8000648c <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
8000648c:	d4 21       	pushm	r4-r7,lr
8000648e:	18 97       	mov	r7,r12
80006490:	16 96       	mov	r6,r11
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
80006492:	58 0c       	cp.w	r12,0
80006494:	c2 f0       	breq	800064f2 <xQueueCreate+0x66>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
80006496:	34 cc       	mov	r12,76
80006498:	f0 1f 00 17 	mcall	800064f4 <xQueueCreate+0x68>
8000649c:	18 95       	mov	r5,r12
		if( pxNewQueue != NULL )
8000649e:	c2 a0       	breq	800064f2 <xQueueCreate+0x66>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
800064a0:	ec 07 02 44 	mul	r4,r6,r7

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
800064a4:	e8 cc ff ff 	sub	r12,r4,-1
800064a8:	f0 1f 00 13 	mcall	800064f4 <xQueueCreate+0x68>
800064ac:	8b 0c       	st.w	r5[0x0],r12
			if( pxNewQueue->pcHead != NULL )
800064ae:	c1 e0       	breq	800064ea <xQueueCreate+0x5e>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
800064b0:	f8 04 00 04 	add	r4,r12,r4
800064b4:	8b 14       	st.w	r5[0x4],r4
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
800064b6:	30 08       	mov	r8,0
800064b8:	8b e8       	st.w	r5[0x38],r8
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
800064ba:	8b 2c       	st.w	r5[0x8],r12
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
800064bc:	ee c8 00 01 	sub	r8,r7,1
800064c0:	ad 38       	mul	r8,r6
800064c2:	10 0c       	add	r12,r8
800064c4:	8b 3c       	st.w	r5[0xc],r12
				pxNewQueue->uxLength = uxQueueLength;
800064c6:	8b f7       	st.w	r5[0x3c],r7
				pxNewQueue->uxItemSize = uxItemSize;
800064c8:	eb 46 00 40 	st.w	r5[64],r6
				pxNewQueue->xRxLock = queueUNLOCKED;
800064cc:	3f f8       	mov	r8,-1
800064ce:	eb 48 00 44 	st.w	r5[68],r8
				pxNewQueue->xTxLock = queueUNLOCKED;
800064d2:	eb 48 00 48 	st.w	r5[72],r8

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
800064d6:	ea cc ff f0 	sub	r12,r5,-16
800064da:	f0 1f 00 08 	mcall	800064f8 <xQueueCreate+0x6c>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
800064de:	ea cc ff dc 	sub	r12,r5,-36
800064e2:	f0 1f 00 06 	mcall	800064f8 <xQueueCreate+0x6c>
800064e6:	0a 9c       	mov	r12,r5
800064e8:	d8 22       	popm	r4-r7,pc
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
800064ea:	0a 9c       	mov	r12,r5
800064ec:	f0 1f 00 04 	mcall	800064fc <xQueueCreate+0x70>
800064f0:	d8 2a       	popm	r4-r7,pc,r12=0
800064f2:	d8 2a       	popm	r4-r7,pc,r12=0
800064f4:	80 00       	ld.sh	r0,r0[0x0]
800064f6:	5f e0       	srqs	r0
800064f8:	80 00       	ld.sh	r0,r0[0x0]
800064fa:	5c 50       	castu.b	r0
800064fc:	80 00       	ld.sh	r0,r0[0x0]
800064fe:	5f b8       	srhi	r8

80006500 <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
80006500:	48 38       	lddpc	r8,8000650c <vTaskSuspendAll+0xc>
80006502:	70 09       	ld.w	r9,r8[0x0]
80006504:	2f f9       	sub	r9,-1
80006506:	91 09       	st.w	r8[0x0],r9
}
80006508:	5e fc       	retal	r12
8000650a:	00 00       	add	r0,r0
8000650c:	00 00       	add	r0,r0
8000650e:	0d 28       	ld.uh	r8,r6++

80006510 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
80006510:	49 a8       	lddpc	r8,80006578 <vTaskSwitchContext+0x68>
80006512:	70 08       	ld.w	r8,r8[0x0]
80006514:	58 08       	cp.w	r8,0
80006516:	c0 b1       	brne	8000652c <vTaskSwitchContext+0x1c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80006518:	49 98       	lddpc	r8,8000657c <vTaskSwitchContext+0x6c>
8000651a:	70 08       	ld.w	r8,r8[0x0]
8000651c:	f0 08 00 28 	add	r8,r8,r8<<0x2
80006520:	49 89       	lddpc	r9,80006580 <vTaskSwitchContext+0x70>
80006522:	f2 08 03 28 	ld.w	r8,r9[r8<<0x2]
80006526:	58 08       	cp.w	r8,0
80006528:	c0 60       	breq	80006534 <vTaskSwitchContext+0x24>
8000652a:	c1 18       	rjmp	8000654c <vTaskSwitchContext+0x3c>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
8000652c:	30 19       	mov	r9,1
8000652e:	49 68       	lddpc	r8,80006584 <vTaskSwitchContext+0x74>
80006530:	91 09       	st.w	r8[0x0],r9
80006532:	5e fc       	retal	r12

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
80006534:	49 28       	lddpc	r8,8000657c <vTaskSwitchContext+0x6c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80006536:	49 3a       	lddpc	r10,80006580 <vTaskSwitchContext+0x70>
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
80006538:	70 09       	ld.w	r9,r8[0x0]
8000653a:	20 19       	sub	r9,1
8000653c:	91 09       	st.w	r8[0x0],r9

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
8000653e:	70 09       	ld.w	r9,r8[0x0]
80006540:	f2 09 00 29 	add	r9,r9,r9<<0x2
80006544:	f4 09 03 29 	ld.w	r9,r10[r9<<0x2]
80006548:	58 09       	cp.w	r9,0
8000654a:	cf 70       	breq	80006538 <vTaskSwitchContext+0x28>
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
8000654c:	48 c8       	lddpc	r8,8000657c <vTaskSwitchContext+0x6c>
8000654e:	70 08       	ld.w	r8,r8[0x0]
80006550:	f0 08 00 28 	add	r8,r8,r8<<0x2
80006554:	48 b9       	lddpc	r9,80006580 <vTaskSwitchContext+0x70>
80006556:	f2 08 00 28 	add	r8,r9,r8<<0x2
8000655a:	70 19       	ld.w	r9,r8[0x4]
8000655c:	72 19       	ld.w	r9,r9[0x4]
8000655e:	91 19       	st.w	r8[0x4],r9
80006560:	f0 ca ff f8 	sub	r10,r8,-8
80006564:	14 39       	cp.w	r9,r10
80006566:	f3 f9 00 01 	ld.weq	r9,r9[0x4]
8000656a:	f1 f9 0a 01 	st.weq	r8[0x4],r9
8000656e:	70 18       	ld.w	r8,r8[0x4]
80006570:	70 39       	ld.w	r9,r8[0xc]
80006572:	48 68       	lddpc	r8,80006588 <vTaskSwitchContext+0x78>
80006574:	91 09       	st.w	r8[0x0],r9
80006576:	5e fc       	retal	r12
80006578:	00 00       	add	r0,r0
8000657a:	0d 28       	ld.uh	r8,r6++
8000657c:	00 00       	add	r0,r0
8000657e:	0d 60       	ld.uh	r0,--r6
80006580:	00 00       	add	r0,r0
80006582:	0c 44       	or	r4,r6
80006584:	00 00       	add	r0,r0
80006586:	0d 48       	ld.w	r8,--r6
80006588:	00 00       	add	r0,r0
8000658a:	0c f8       	st.b	--r6,r8

8000658c <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
8000658c:	48 48       	lddpc	r8,8000659c <vTaskSetTimeOutState+0x10>
8000658e:	70 08       	ld.w	r8,r8[0x0]
80006590:	99 08       	st.w	r12[0x0],r8
	pxTimeOut->xTimeOnEntering = xTickCount;
80006592:	48 48       	lddpc	r8,800065a0 <vTaskSetTimeOutState+0x14>
80006594:	70 08       	ld.w	r8,r8[0x0]
80006596:	99 18       	st.w	r12[0x4],r8
}
80006598:	5e fc       	retal	r12
8000659a:	00 00       	add	r0,r0
8000659c:	00 00       	add	r0,r0
8000659e:	0c 3c       	cp.w	r12,r6
800065a0:	00 00       	add	r0,r0
800065a2:	0d 24       	ld.uh	r4,r6++

800065a4 <vTaskMissedYield>:
}
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
800065a4:	30 19       	mov	r9,1
800065a6:	48 28       	lddpc	r8,800065ac <vTaskMissedYield+0x8>
800065a8:	91 09       	st.w	r8[0x0],r9
}
800065aa:	5e fc       	retal	r12
800065ac:	00 00       	add	r0,r0
800065ae:	0d 48       	ld.w	r8,--r6

800065b0 <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
800065b0:	48 28       	lddpc	r8,800065b8 <xTaskGetCurrentTaskHandle+0x8>
800065b2:	70 0c       	ld.w	r12,r8[0x0]

		return xReturn;
	}
800065b4:	5e fc       	retal	r12
800065b6:	00 00       	add	r0,r0
800065b8:	00 00       	add	r0,r0
800065ba:	0c f8       	st.b	--r6,r8

800065bc <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
800065bc:	eb cd 40 c0 	pushm	r6-r7,lr
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
800065c0:	58 0c       	cp.w	r12,0
800065c2:	c1 f0       	breq	80006600 <vTaskPriorityDisinherit+0x44>

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
800065c4:	18 97       	mov	r7,r12

		if( pxMutexHolder != NULL )
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
800065c6:	78 b9       	ld.w	r9,r12[0x2c]
800065c8:	79 18       	ld.w	r8,r12[0x44]
800065ca:	10 39       	cp.w	r9,r8
800065cc:	c1 a0       	breq	80006600 <vTaskPriorityDisinherit+0x44>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
800065ce:	f8 c6 ff fc 	sub	r6,r12,-4
800065d2:	0c 9c       	mov	r12,r6
800065d4:	f0 1f 00 0c 	mcall	80006604 <vTaskPriorityDisinherit+0x48>

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
800065d8:	6f 1c       	ld.w	r12,r7[0x44]
800065da:	8f bc       	st.w	r7[0x2c],r12
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
800065dc:	f8 08 11 08 	rsub	r8,r12,8
800065e0:	8f 68       	st.w	r7[0x18],r8
				prvAddTaskToReadyQueue( pxTCB );
800065e2:	48 a8       	lddpc	r8,80006608 <vTaskPriorityDisinherit+0x4c>
800065e4:	70 08       	ld.w	r8,r8[0x0]
800065e6:	10 3c       	cp.w	r12,r8
800065e8:	e0 88 00 04 	brls	800065f0 <vTaskPriorityDisinherit+0x34>
800065ec:	48 78       	lddpc	r8,80006608 <vTaskPriorityDisinherit+0x4c>
800065ee:	91 0c       	st.w	r8[0x0],r12
800065f0:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800065f4:	0c 9b       	mov	r11,r6
800065f6:	48 68       	lddpc	r8,8000660c <vTaskPriorityDisinherit+0x50>
800065f8:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800065fc:	f0 1f 00 05 	mcall	80006610 <vTaskPriorityDisinherit+0x54>
80006600:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006604:	80 00       	ld.sh	r0,r0[0x0]
80006606:	5c ba       	swap.b	r10
80006608:	00 00       	add	r0,r0
8000660a:	0d 60       	ld.uh	r0,--r6
8000660c:	00 00       	add	r0,r0
8000660e:	0c 44       	or	r4,r6
80006610:	80 00       	ld.sh	r0,r0[0x0]
80006612:	5c 6a       	casts.b	r10

80006614 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
80006614:	eb cd 40 c0 	pushm	r6-r7,lr
80006618:	18 97       	mov	r7,r12
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
8000661a:	49 b8       	lddpc	r8,80006684 <vTaskPriorityInherit+0x70>
8000661c:	70 08       	ld.w	r8,r8[0x0]
8000661e:	78 b9       	ld.w	r9,r12[0x2c]
80006620:	70 b8       	ld.w	r8,r8[0x2c]
80006622:	10 39       	cp.w	r9,r8
80006624:	c2 d2       	brcc	8000667e <vTaskPriorityInherit+0x6a>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
80006626:	49 88       	lddpc	r8,80006684 <vTaskPriorityInherit+0x70>
80006628:	70 08       	ld.w	r8,r8[0x0]
8000662a:	70 b8       	ld.w	r8,r8[0x2c]
8000662c:	f0 08 11 08 	rsub	r8,r8,8
80006630:	99 68       	st.w	r12[0x18],r8

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
80006632:	f2 09 00 28 	add	r8,r9,r9<<0x2
80006636:	49 59       	lddpc	r9,80006688 <vTaskPriorityInherit+0x74>
80006638:	f2 08 00 28 	add	r8,r9,r8<<0x2
8000663c:	78 59       	ld.w	r9,r12[0x14]
8000663e:	10 39       	cp.w	r9,r8
80006640:	c1 b1       	brne	80006676 <vTaskPriorityInherit+0x62>
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
80006642:	f8 c6 ff fc 	sub	r6,r12,-4
80006646:	0c 9c       	mov	r12,r6
80006648:	f0 1f 00 11 	mcall	8000668c <vTaskPriorityInherit+0x78>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
8000664c:	48 e8       	lddpc	r8,80006684 <vTaskPriorityInherit+0x70>
8000664e:	70 08       	ld.w	r8,r8[0x0]
80006650:	70 bc       	ld.w	r12,r8[0x2c]
80006652:	8f bc       	st.w	r7[0x2c],r12
				prvAddTaskToReadyQueue( pxTCB );
80006654:	48 f8       	lddpc	r8,80006690 <vTaskPriorityInherit+0x7c>
80006656:	70 08       	ld.w	r8,r8[0x0]
80006658:	10 3c       	cp.w	r12,r8
8000665a:	e0 88 00 04 	brls	80006662 <vTaskPriorityInherit+0x4e>
8000665e:	48 d8       	lddpc	r8,80006690 <vTaskPriorityInherit+0x7c>
80006660:	91 0c       	st.w	r8[0x0],r12
80006662:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006666:	0c 9b       	mov	r11,r6
80006668:	48 88       	lddpc	r8,80006688 <vTaskPriorityInherit+0x74>
8000666a:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
8000666e:	f0 1f 00 0a 	mcall	80006694 <vTaskPriorityInherit+0x80>
80006672:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
80006676:	48 48       	lddpc	r8,80006684 <vTaskPriorityInherit+0x70>
80006678:	70 08       	ld.w	r8,r8[0x0]
8000667a:	70 b8       	ld.w	r8,r8[0x2c]
8000667c:	99 b8       	st.w	r12[0x2c],r8
8000667e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006682:	00 00       	add	r0,r0
80006684:	00 00       	add	r0,r0
80006686:	0c f8       	st.b	--r6,r8
80006688:	00 00       	add	r0,r0
8000668a:	0c 44       	or	r4,r6
8000668c:	80 00       	ld.sh	r0,r0[0x0]
8000668e:	5c ba       	swap.b	r10
80006690:	00 00       	add	r0,r0
80006692:	0d 60       	ld.uh	r0,--r6
80006694:	80 00       	ld.sh	r0,r0[0x0]
80006696:	5c 6a       	casts.b	r10

80006698 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
80006698:	eb cd 40 c0 	pushm	r6-r7,lr
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
8000669c:	78 38       	ld.w	r8,r12[0xc]
8000669e:	70 37       	ld.w	r7,r8[0xc]
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
800066a0:	ee c6 ff e8 	sub	r6,r7,-24
800066a4:	0c 9c       	mov	r12,r6
800066a6:	f0 1f 00 15 	mcall	800066f8 <xTaskRemoveFromEventList+0x60>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
800066aa:	49 58       	lddpc	r8,800066fc <xTaskRemoveFromEventList+0x64>
800066ac:	70 08       	ld.w	r8,r8[0x0]
800066ae:	58 08       	cp.w	r8,0
800066b0:	c1 71       	brne	800066de <xTaskRemoveFromEventList+0x46>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
800066b2:	ee c6 ff fc 	sub	r6,r7,-4
800066b6:	0c 9c       	mov	r12,r6
800066b8:	f0 1f 00 10 	mcall	800066f8 <xTaskRemoveFromEventList+0x60>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
800066bc:	6e bc       	ld.w	r12,r7[0x2c]
800066be:	49 18       	lddpc	r8,80006700 <xTaskRemoveFromEventList+0x68>
800066c0:	70 08       	ld.w	r8,r8[0x0]
800066c2:	10 3c       	cp.w	r12,r8
800066c4:	e0 88 00 04 	brls	800066cc <xTaskRemoveFromEventList+0x34>
800066c8:	48 e8       	lddpc	r8,80006700 <xTaskRemoveFromEventList+0x68>
800066ca:	91 0c       	st.w	r8[0x0],r12
800066cc:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800066d0:	0c 9b       	mov	r11,r6
800066d2:	48 d8       	lddpc	r8,80006704 <xTaskRemoveFromEventList+0x6c>
800066d4:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800066d8:	f0 1f 00 0c 	mcall	80006708 <xTaskRemoveFromEventList+0x70>
800066dc:	c0 58       	rjmp	800066e6 <xTaskRemoveFromEventList+0x4e>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
800066de:	0c 9b       	mov	r11,r6
800066e0:	48 bc       	lddpc	r12,8000670c <xTaskRemoveFromEventList+0x74>
800066e2:	f0 1f 00 0a 	mcall	80006708 <xTaskRemoveFromEventList+0x70>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
800066e6:	48 b8       	lddpc	r8,80006710 <xTaskRemoveFromEventList+0x78>
800066e8:	70 08       	ld.w	r8,r8[0x0]
800066ea:	6e b9       	ld.w	r9,r7[0x2c]
800066ec:	70 b8       	ld.w	r8,r8[0x2c]
800066ee:	10 39       	cp.w	r9,r8
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
800066f0:	5f 2c       	srhs	r12
800066f2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800066f6:	00 00       	add	r0,r0
800066f8:	80 00       	ld.sh	r0,r0[0x0]
800066fa:	5c ba       	swap.b	r10
800066fc:	00 00       	add	r0,r0
800066fe:	0d 28       	ld.uh	r8,r6++
80006700:	00 00       	add	r0,r0
80006702:	0d 60       	ld.uh	r0,--r6
80006704:	00 00       	add	r0,r0
80006706:	0c 44       	or	r4,r6
80006708:	80 00       	ld.sh	r0,r0[0x0]
8000670a:	5c 6a       	casts.b	r10
8000670c:	00 00       	add	r0,r0
8000670e:	0c fc       	st.b	--r6,r12
80006710:	00 00       	add	r0,r0
80006712:	0c f8       	st.b	--r6,r8

80006714 <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
80006714:	eb cd 40 fc 	pushm	r2-r7,lr
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80006718:	4b 98       	lddpc	r8,800067fc <vTaskIncrementTick+0xe8>
8000671a:	70 08       	ld.w	r8,r8[0x0]
8000671c:	58 08       	cp.w	r8,0
8000671e:	c6 91       	brne	800067f0 <vTaskIncrementTick+0xdc>
	{
		++xTickCount;
80006720:	4b 88       	lddpc	r8,80006800 <vTaskIncrementTick+0xec>
80006722:	70 09       	ld.w	r9,r8[0x0]
80006724:	2f f9       	sub	r9,-1
80006726:	91 09       	st.w	r8[0x0],r9
		if( xTickCount == ( portTickType ) 0 )
80006728:	70 08       	ld.w	r8,r8[0x0]
8000672a:	58 08       	cp.w	r8,0
8000672c:	c1 a1       	brne	80006760 <vTaskIncrementTick+0x4c>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
8000672e:	4b 68       	lddpc	r8,80006804 <vTaskIncrementTick+0xf0>
80006730:	70 0a       	ld.w	r10,r8[0x0]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
80006732:	4b 69       	lddpc	r9,80006808 <vTaskIncrementTick+0xf4>
80006734:	72 0b       	ld.w	r11,r9[0x0]
80006736:	91 0b       	st.w	r8[0x0],r11
			pxOverflowDelayedTaskList = pxTemp;
80006738:	93 0a       	st.w	r9[0x0],r10
			xNumOfOverflows++;
8000673a:	4b 59       	lddpc	r9,8000680c <vTaskIncrementTick+0xf8>
8000673c:	72 0a       	ld.w	r10,r9[0x0]
8000673e:	2f fa       	sub	r10,-1
80006740:	93 0a       	st.w	r9[0x0],r10

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
80006742:	70 08       	ld.w	r8,r8[0x0]
80006744:	70 08       	ld.w	r8,r8[0x0]
80006746:	58 08       	cp.w	r8,0
80006748:	c0 51       	brne	80006752 <vTaskIncrementTick+0x3e>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
8000674a:	3f f9       	mov	r9,-1
8000674c:	4b 18       	lddpc	r8,80006810 <vTaskIncrementTick+0xfc>
8000674e:	91 09       	st.w	r8[0x0],r9
80006750:	c0 88       	rjmp	80006760 <vTaskIncrementTick+0x4c>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
80006752:	4a d8       	lddpc	r8,80006804 <vTaskIncrementTick+0xf0>
80006754:	70 08       	ld.w	r8,r8[0x0]
80006756:	70 38       	ld.w	r8,r8[0xc]
80006758:	70 38       	ld.w	r8,r8[0xc]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
8000675a:	70 19       	ld.w	r9,r8[0x4]
8000675c:	4a d8       	lddpc	r8,80006810 <vTaskIncrementTick+0xfc>
8000675e:	91 09       	st.w	r8[0x0],r9
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
80006760:	4a 88       	lddpc	r8,80006800 <vTaskIncrementTick+0xec>
80006762:	70 09       	ld.w	r9,r8[0x0]
80006764:	4a b8       	lddpc	r8,80006810 <vTaskIncrementTick+0xfc>
80006766:	70 08       	ld.w	r8,r8[0x0]
80006768:	10 39       	cp.w	r9,r8
8000676a:	c4 73       	brcs	800067f8 <vTaskIncrementTick+0xe4>
8000676c:	4a 68       	lddpc	r8,80006804 <vTaskIncrementTick+0xf0>
8000676e:	70 08       	ld.w	r8,r8[0x0]
80006770:	70 08       	ld.w	r8,r8[0x0]
80006772:	58 08       	cp.w	r8,0
80006774:	c0 c0       	breq	8000678c <vTaskIncrementTick+0x78>
80006776:	4a 48       	lddpc	r8,80006804 <vTaskIncrementTick+0xf0>
80006778:	70 08       	ld.w	r8,r8[0x0]
8000677a:	70 38       	ld.w	r8,r8[0xc]
8000677c:	70 37       	ld.w	r7,r8[0xc]
8000677e:	6e 18       	ld.w	r8,r7[0x4]
80006780:	4a 09       	lddpc	r9,80006800 <vTaskIncrementTick+0xec>
80006782:	72 09       	ld.w	r9,r9[0x0]
80006784:	12 38       	cp.w	r8,r9
80006786:	e0 88 00 14 	brls	800067ae <vTaskIncrementTick+0x9a>
8000678a:	c0 e8       	rjmp	800067a6 <vTaskIncrementTick+0x92>
8000678c:	3f f9       	mov	r9,-1
8000678e:	4a 18       	lddpc	r8,80006810 <vTaskIncrementTick+0xfc>
80006790:	91 09       	st.w	r8[0x0],r9
80006792:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80006796:	6a 08       	ld.w	r8,r5[0x0]
80006798:	70 38       	ld.w	r8,r8[0xc]
8000679a:	70 37       	ld.w	r7,r8[0xc]
8000679c:	6e 18       	ld.w	r8,r7[0x4]
8000679e:	64 09       	ld.w	r9,r2[0x0]
800067a0:	12 38       	cp.w	r8,r9
800067a2:	e0 88 00 0a 	brls	800067b6 <vTaskIncrementTick+0xa2>
800067a6:	49 b9       	lddpc	r9,80006810 <vTaskIncrementTick+0xfc>
800067a8:	93 08       	st.w	r9[0x0],r8
800067aa:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
800067ae:	49 a4       	lddpc	r4,80006814 <vTaskIncrementTick+0x100>
800067b0:	49 a3       	lddpc	r3,80006818 <vTaskIncrementTick+0x104>
800067b2:	49 55       	lddpc	r5,80006804 <vTaskIncrementTick+0xf0>
800067b4:	49 32       	lddpc	r2,80006800 <vTaskIncrementTick+0xec>
800067b6:	ee c6 ff fc 	sub	r6,r7,-4
800067ba:	0c 9c       	mov	r12,r6
800067bc:	f0 1f 00 18 	mcall	8000681c <vTaskIncrementTick+0x108>
800067c0:	6e a8       	ld.w	r8,r7[0x28]
800067c2:	58 08       	cp.w	r8,0
800067c4:	c0 50       	breq	800067ce <vTaskIncrementTick+0xba>
800067c6:	ee cc ff e8 	sub	r12,r7,-24
800067ca:	f0 1f 00 15 	mcall	8000681c <vTaskIncrementTick+0x108>
800067ce:	6e bc       	ld.w	r12,r7[0x2c]
800067d0:	68 08       	ld.w	r8,r4[0x0]
800067d2:	10 3c       	cp.w	r12,r8
800067d4:	e9 fc ba 00 	st.whi	r4[0x0],r12
800067d8:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800067dc:	0c 9b       	mov	r11,r6
800067de:	e6 0c 00 2c 	add	r12,r3,r12<<0x2
800067e2:	f0 1f 00 10 	mcall	80006820 <vTaskIncrementTick+0x10c>
800067e6:	6a 08       	ld.w	r8,r5[0x0]
800067e8:	70 08       	ld.w	r8,r8[0x0]
800067ea:	58 08       	cp.w	r8,0
800067ec:	cd 51       	brne	80006796 <vTaskIncrementTick+0x82>
800067ee:	cc fb       	rjmp	8000678c <vTaskIncrementTick+0x78>
	}
	else
	{
		++uxMissedTicks;
800067f0:	48 d8       	lddpc	r8,80006824 <vTaskIncrementTick+0x110>
800067f2:	70 09       	ld.w	r9,r8[0x0]
800067f4:	2f f9       	sub	r9,-1
800067f6:	91 09       	st.w	r8[0x0],r9
800067f8:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
800067fc:	00 00       	add	r0,r0
800067fe:	0d 28       	ld.uh	r8,r6++
80006800:	00 00       	add	r0,r0
80006802:	0d 24       	ld.uh	r4,r6++
80006804:	00 00       	add	r0,r0
80006806:	0c 30       	cp.w	r0,r6
80006808:	00 00       	add	r0,r0
8000680a:	0c 40       	or	r0,r6
8000680c:	00 00       	add	r0,r0
8000680e:	0c 3c       	cp.w	r12,r6
80006810:	00 00       	add	r0,r0
80006812:	05 38       	ld.ub	r8,r2++
80006814:	00 00       	add	r0,r0
80006816:	0d 60       	ld.uh	r0,--r6
80006818:	00 00       	add	r0,r0
8000681a:	0c 44       	or	r4,r6
8000681c:	80 00       	ld.sh	r0,r0[0x0]
8000681e:	5c ba       	swap.b	r10
80006820:	80 00       	ld.sh	r0,r0[0x0]
80006822:	5c 6a       	casts.b	r10
80006824:	00 00       	add	r0,r0
80006826:	0c 28       	rsub	r8,r6

80006828 <xTaskCheckForTimeOut>:
	pxTimeOut->xTimeOnEntering = xTickCount;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
80006828:	eb cd 40 c0 	pushm	r6-r7,lr
8000682c:	18 97       	mov	r7,r12
8000682e:	16 96       	mov	r6,r11
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
80006830:	f0 1f 00 15 	mcall	80006884 <xTaskCheckForTimeOut+0x5c>
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
80006834:	6c 08       	ld.w	r8,r6[0x0]
80006836:	5b f8       	cp.w	r8,-1
80006838:	c0 31       	brne	8000683e <xTaskCheckForTimeOut+0x16>
8000683a:	30 07       	mov	r7,0
8000683c:	c1 f8       	rjmp	8000687a <xTaskCheckForTimeOut+0x52>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
8000683e:	49 39       	lddpc	r9,80006888 <xTaskCheckForTimeOut+0x60>
80006840:	72 09       	ld.w	r9,r9[0x0]
80006842:	6e 0a       	ld.w	r10,r7[0x0]
80006844:	12 3a       	cp.w	r10,r9
80006846:	c0 70       	breq	80006854 <xTaskCheckForTimeOut+0x2c>
80006848:	49 19       	lddpc	r9,8000688c <xTaskCheckForTimeOut+0x64>
8000684a:	72 09       	ld.w	r9,r9[0x0]
8000684c:	6e 1a       	ld.w	r10,r7[0x4]
8000684e:	12 3a       	cp.w	r10,r9
80006850:	e0 88 00 14 	brls	80006878 <xTaskCheckForTimeOut+0x50>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
80006854:	48 e9       	lddpc	r9,8000688c <xTaskCheckForTimeOut+0x64>
80006856:	72 0a       	ld.w	r10,r9[0x0]
80006858:	6e 19       	ld.w	r9,r7[0x4]
8000685a:	12 1a       	sub	r10,r9
8000685c:	14 38       	cp.w	r8,r10
8000685e:	e0 88 00 0d 	brls	80006878 <xTaskCheckForTimeOut+0x50>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
80006862:	48 ba       	lddpc	r10,8000688c <xTaskCheckForTimeOut+0x64>
80006864:	74 0a       	ld.w	r10,r10[0x0]
80006866:	14 19       	sub	r9,r10
80006868:	f2 08 00 08 	add	r8,r9,r8
8000686c:	8d 08       	st.w	r6[0x0],r8
			vTaskSetTimeOutState( pxTimeOut );
8000686e:	0e 9c       	mov	r12,r7
80006870:	f0 1f 00 08 	mcall	80006890 <xTaskCheckForTimeOut+0x68>
80006874:	30 07       	mov	r7,0
80006876:	c0 28       	rjmp	8000687a <xTaskCheckForTimeOut+0x52>
80006878:	30 17       	mov	r7,1
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
8000687a:	f0 1f 00 07 	mcall	80006894 <xTaskCheckForTimeOut+0x6c>

	return xReturn;
}
8000687e:	0e 9c       	mov	r12,r7
80006880:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006884:	80 00       	ld.sh	r0,r0[0x0]
80006886:	5d 74       	*unknown*
80006888:	00 00       	add	r0,r0
8000688a:	0c 3c       	cp.w	r12,r6
8000688c:	00 00       	add	r0,r0
8000688e:	0d 24       	ld.uh	r4,r6++
80006890:	80 00       	ld.sh	r0,r0[0x0]
80006892:	65 8c       	ld.w	r12,r2[0x60]
80006894:	80 00       	ld.sh	r0,r0[0x0]
80006896:	5e 80       	retls	r0

80006898 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
80006898:	eb cd 40 80 	pushm	r7,lr
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
8000689c:	f0 1f 00 05 	mcall	800068b0 <xTaskGetTickCount+0x18>
	{
		xTicks = xTickCount;
800068a0:	48 58       	lddpc	r8,800068b4 <xTaskGetTickCount+0x1c>
800068a2:	70 07       	ld.w	r7,r8[0x0]
	}
	taskEXIT_CRITICAL();
800068a4:	f0 1f 00 05 	mcall	800068b8 <xTaskGetTickCount+0x20>

	return xTicks;
}
800068a8:	0e 9c       	mov	r12,r7
800068aa:	e3 cd 80 80 	ldm	sp++,r7,pc
800068ae:	00 00       	add	r0,r0
800068b0:	80 00       	ld.sh	r0,r0[0x0]
800068b2:	5d 74       	*unknown*
800068b4:	00 00       	add	r0,r0
800068b6:	0d 24       	ld.uh	r4,r6++
800068b8:	80 00       	ld.sh	r0,r0[0x0]
800068ba:	5e 80       	retls	r0

800068bc <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
800068bc:	eb cd 40 fe 	pushm	r1-r7,lr
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
800068c0:	f0 1f 00 2c 	mcall	80006970 <xTaskResumeAll+0xb4>
	{
		--uxSchedulerSuspended;
800068c4:	4a c8       	lddpc	r8,80006974 <xTaskResumeAll+0xb8>
800068c6:	70 09       	ld.w	r9,r8[0x0]
800068c8:	20 19       	sub	r9,1
800068ca:	91 09       	st.w	r8[0x0],r9

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
800068cc:	70 08       	ld.w	r8,r8[0x0]
800068ce:	58 08       	cp.w	r8,0
800068d0:	c4 91       	brne	80006962 <xTaskResumeAll+0xa6>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
800068d2:	4a a8       	lddpc	r8,80006978 <xTaskResumeAll+0xbc>
800068d4:	70 08       	ld.w	r8,r8[0x0]
800068d6:	58 08       	cp.w	r8,0
800068d8:	c4 50       	breq	80006962 <xTaskResumeAll+0xa6>
800068da:	30 04       	mov	r4,0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
800068dc:	4a 85       	lddpc	r5,8000697c <xTaskResumeAll+0xc0>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
800068de:	4a 93       	lddpc	r3,80006980 <xTaskResumeAll+0xc4>
800068e0:	4a 92       	lddpc	r2,80006984 <xTaskResumeAll+0xc8>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
800068e2:	4a a1       	lddpc	r1,80006988 <xTaskResumeAll+0xcc>
800068e4:	c1 e8       	rjmp	80006920 <xTaskResumeAll+0x64>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
800068e6:	6a 38       	ld.w	r8,r5[0xc]
800068e8:	70 37       	ld.w	r7,r8[0xc]
					vListRemove( &( pxTCB->xEventListItem ) );
800068ea:	ee cc ff e8 	sub	r12,r7,-24
800068ee:	f0 1f 00 28 	mcall	8000698c <xTaskResumeAll+0xd0>
					vListRemove( &( pxTCB->xGenericListItem ) );
800068f2:	ee c6 ff fc 	sub	r6,r7,-4
800068f6:	0c 9c       	mov	r12,r6
800068f8:	f0 1f 00 25 	mcall	8000698c <xTaskResumeAll+0xd0>
					prvAddTaskToReadyQueue( pxTCB );
800068fc:	6e bc       	ld.w	r12,r7[0x2c]
800068fe:	66 08       	ld.w	r8,r3[0x0]
80006900:	10 3c       	cp.w	r12,r8
80006902:	e7 fc ba 00 	st.whi	r3[0x0],r12
80006906:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
8000690a:	0c 9b       	mov	r11,r6
8000690c:	e4 0c 00 2c 	add	r12,r2,r12<<0x2
80006910:	f0 1f 00 20 	mcall	80006990 <xTaskResumeAll+0xd4>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80006914:	62 08       	ld.w	r8,r1[0x0]
80006916:	6e b9       	ld.w	r9,r7[0x2c]
80006918:	70 b8       	ld.w	r8,r8[0x2c]
8000691a:	10 39       	cp.w	r9,r8
8000691c:	f9 b4 02 01 	movhs	r4,1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80006920:	6a 08       	ld.w	r8,r5[0x0]
80006922:	58 08       	cp.w	r8,0
80006924:	ce 11       	brne	800068e6 <xTaskResumeAll+0x2a>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80006926:	49 c8       	lddpc	r8,80006994 <xTaskResumeAll+0xd8>
80006928:	70 08       	ld.w	r8,r8[0x0]
8000692a:	58 08       	cp.w	r8,0
8000692c:	c0 f0       	breq	8000694a <xTaskResumeAll+0x8e>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
8000692e:	49 a8       	lddpc	r8,80006994 <xTaskResumeAll+0xd8>
80006930:	70 08       	ld.w	r8,r8[0x0]
80006932:	58 08       	cp.w	r8,0
80006934:	c1 10       	breq	80006956 <xTaskResumeAll+0x9a>
					{
						vTaskIncrementTick();
						--uxMissedTicks;
80006936:	49 87       	lddpc	r7,80006994 <xTaskResumeAll+0xd8>
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
80006938:	f0 1f 00 18 	mcall	80006998 <xTaskResumeAll+0xdc>
						--uxMissedTicks;
8000693c:	6e 08       	ld.w	r8,r7[0x0]
8000693e:	20 18       	sub	r8,1
80006940:	8f 08       	st.w	r7[0x0],r8
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80006942:	6e 08       	ld.w	r8,r7[0x0]
80006944:	58 08       	cp.w	r8,0
80006946:	cf 91       	brne	80006938 <xTaskResumeAll+0x7c>
80006948:	c0 78       	rjmp	80006956 <xTaskResumeAll+0x9a>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
8000694a:	58 14       	cp.w	r4,1
8000694c:	c0 50       	breq	80006956 <xTaskResumeAll+0x9a>
8000694e:	49 48       	lddpc	r8,8000699c <xTaskResumeAll+0xe0>
80006950:	70 08       	ld.w	r8,r8[0x0]
80006952:	58 18       	cp.w	r8,1
80006954:	c0 71       	brne	80006962 <xTaskResumeAll+0xa6>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
80006956:	30 09       	mov	r9,0
80006958:	49 18       	lddpc	r8,8000699c <xTaskResumeAll+0xe0>
8000695a:	91 09       	st.w	r8[0x0],r9
					portYIELD_WITHIN_API();
8000695c:	d7 33       	scall
8000695e:	30 17       	mov	r7,1
80006960:	c0 28       	rjmp	80006964 <xTaskResumeAll+0xa8>
80006962:	30 07       	mov	r7,0
				}
			}
		}
	}
	taskEXIT_CRITICAL();
80006964:	f0 1f 00 0f 	mcall	800069a0 <xTaskResumeAll+0xe4>

	return xAlreadyYielded;
}
80006968:	0e 9c       	mov	r12,r7
8000696a:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
8000696e:	00 00       	add	r0,r0
80006970:	80 00       	ld.sh	r0,r0[0x0]
80006972:	5d 74       	*unknown*
80006974:	00 00       	add	r0,r0
80006976:	0d 28       	ld.uh	r8,r6++
80006978:	00 00       	add	r0,r0
8000697a:	0d 44       	ld.w	r4,--r6
8000697c:	00 00       	add	r0,r0
8000697e:	0c fc       	st.b	--r6,r12
80006980:	00 00       	add	r0,r0
80006982:	0d 60       	ld.uh	r0,--r6
80006984:	00 00       	add	r0,r0
80006986:	0c 44       	or	r4,r6
80006988:	00 00       	add	r0,r0
8000698a:	0c f8       	st.b	--r6,r8
8000698c:	80 00       	ld.sh	r0,r0[0x0]
8000698e:	5c ba       	swap.b	r10
80006990:	80 00       	ld.sh	r0,r0[0x0]
80006992:	5c 6a       	casts.b	r10
80006994:	00 00       	add	r0,r0
80006996:	0c 28       	rsub	r8,r6
80006998:	80 00       	ld.sh	r0,r0[0x0]
8000699a:	67 14       	ld.w	r4,r3[0x44]
8000699c:	00 00       	add	r0,r0
8000699e:	0d 48       	ld.w	r8,--r6
800069a0:	80 00       	ld.sh	r0,r0[0x0]
800069a2:	5e 80       	retls	r0

800069a4 <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
800069a4:	eb cd 40 80 	pushm	r7,lr
800069a8:	18 97       	mov	r7,r12
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
800069aa:	49 08       	lddpc	r8,800069e8 <prvAddCurrentTaskToDelayedList+0x44>
800069ac:	70 08       	ld.w	r8,r8[0x0]
800069ae:	91 1c       	st.w	r8[0x4],r12

	if( xTimeToWake < xTickCount )
800069b0:	48 f8       	lddpc	r8,800069ec <prvAddCurrentTaskToDelayedList+0x48>
800069b2:	70 08       	ld.w	r8,r8[0x0]
800069b4:	10 3c       	cp.w	r12,r8
800069b6:	c0 a2       	brcc	800069ca <prvAddCurrentTaskToDelayedList+0x26>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800069b8:	48 c8       	lddpc	r8,800069e8 <prvAddCurrentTaskToDelayedList+0x44>
800069ba:	70 0b       	ld.w	r11,r8[0x0]
800069bc:	48 d8       	lddpc	r8,800069f0 <prvAddCurrentTaskToDelayedList+0x4c>
800069be:	70 0c       	ld.w	r12,r8[0x0]
800069c0:	2f cb       	sub	r11,-4
800069c2:	f0 1f 00 0d 	mcall	800069f4 <prvAddCurrentTaskToDelayedList+0x50>
800069c6:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800069ca:	48 88       	lddpc	r8,800069e8 <prvAddCurrentTaskToDelayedList+0x44>
800069cc:	70 0b       	ld.w	r11,r8[0x0]
800069ce:	48 b8       	lddpc	r8,800069f8 <prvAddCurrentTaskToDelayedList+0x54>
800069d0:	70 0c       	ld.w	r12,r8[0x0]
800069d2:	2f cb       	sub	r11,-4
800069d4:	f0 1f 00 08 	mcall	800069f4 <prvAddCurrentTaskToDelayedList+0x50>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
800069d8:	48 98       	lddpc	r8,800069fc <prvAddCurrentTaskToDelayedList+0x58>
800069da:	70 08       	ld.w	r8,r8[0x0]
800069dc:	10 37       	cp.w	r7,r8
800069de:	c0 32       	brcc	800069e4 <prvAddCurrentTaskToDelayedList+0x40>
		{
			xNextTaskUnblockTime = xTimeToWake;
800069e0:	48 78       	lddpc	r8,800069fc <prvAddCurrentTaskToDelayedList+0x58>
800069e2:	91 07       	st.w	r8[0x0],r7
800069e4:	e3 cd 80 80 	ldm	sp++,r7,pc
800069e8:	00 00       	add	r0,r0
800069ea:	0c f8       	st.b	--r6,r8
800069ec:	00 00       	add	r0,r0
800069ee:	0d 24       	ld.uh	r4,r6++
800069f0:	00 00       	add	r0,r0
800069f2:	0c 40       	or	r0,r6
800069f4:	80 00       	ld.sh	r0,r0[0x0]
800069f6:	5c 86       	casts.h	r6
800069f8:	00 00       	add	r0,r0
800069fa:	0c 30       	cp.w	r0,r6
800069fc:	00 00       	add	r0,r0
800069fe:	05 38       	ld.ub	r8,r2++

80006a00 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
80006a00:	eb cd 40 c0 	pushm	r6-r7,lr
80006a04:	18 97       	mov	r7,r12
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0 )
80006a06:	58 0c       	cp.w	r12,0
80006a08:	c1 10       	breq	80006a2a <vTaskDelay+0x2a>
		{
			vTaskSuspendAll();
80006a0a:	f0 1f 00 0a 	mcall	80006a30 <vTaskDelay+0x30>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
80006a0e:	48 a8       	lddpc	r8,80006a34 <vTaskDelay+0x34>
80006a10:	70 06       	ld.w	r6,r8[0x0]

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006a12:	48 a8       	lddpc	r8,80006a38 <vTaskDelay+0x38>
80006a14:	70 0c       	ld.w	r12,r8[0x0]
80006a16:	2f cc       	sub	r12,-4
80006a18:	f0 1f 00 09 	mcall	80006a3c <vTaskDelay+0x3c>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
80006a1c:	ee 06 00 0c 	add	r12,r7,r6
80006a20:	f0 1f 00 08 	mcall	80006a40 <vTaskDelay+0x40>
			}
			xAlreadyYielded = xTaskResumeAll();
80006a24:	f0 1f 00 08 	mcall	80006a44 <vTaskDelay+0x44>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
80006a28:	c0 21       	brne	80006a2c <vTaskDelay+0x2c>
		{
			portYIELD_WITHIN_API();
80006a2a:	d7 33       	scall
80006a2c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006a30:	80 00       	ld.sh	r0,r0[0x0]
80006a32:	65 00       	ld.w	r0,r2[0x40]
80006a34:	00 00       	add	r0,r0
80006a36:	0d 24       	ld.uh	r4,r6++
80006a38:	00 00       	add	r0,r0
80006a3a:	0c f8       	st.b	--r6,r8
80006a3c:	80 00       	ld.sh	r0,r0[0x0]
80006a3e:	5c ba       	swap.b	r10
80006a40:	80 00       	ld.sh	r0,r0[0x0]
80006a42:	69 a4       	ld.w	r4,r4[0x68]
80006a44:	80 00       	ld.sh	r0,r0[0x0]
80006a46:	68 bc       	ld.w	r12,r4[0x2c]

80006a48 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
80006a48:	eb cd 40 c0 	pushm	r6-r7,lr
80006a4c:	18 96       	mov	r6,r12
80006a4e:	16 97       	mov	r7,r11
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0 ) );

		vTaskSuspendAll();
80006a50:	f0 1f 00 18 	mcall	80006ab0 <vTaskDelayUntil+0x68>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
80006a54:	6c 08       	ld.w	r8,r6[0x0]
80006a56:	10 07       	add	r7,r8

			if( xTickCount < *pxPreviousWakeTime )
80006a58:	49 79       	lddpc	r9,80006ab4 <vTaskDelayUntil+0x6c>
80006a5a:	72 09       	ld.w	r9,r9[0x0]
80006a5c:	12 38       	cp.w	r8,r9
80006a5e:	e0 88 00 0c 	brls	80006a76 <vTaskDelayUntil+0x2e>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
80006a62:	0e 38       	cp.w	r8,r7
80006a64:	e0 88 00 22 	brls	80006aa8 <vTaskDelayUntil+0x60>
80006a68:	49 38       	lddpc	r8,80006ab4 <vTaskDelayUntil+0x6c>
80006a6a:	70 08       	ld.w	r8,r8[0x0]
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80006a6c:	8d 07       	st.w	r6[0x0],r7

			if( xShouldDelay != pdFALSE )
80006a6e:	10 37       	cp.w	r7,r8
80006a70:	e0 88 00 14 	brls	80006a98 <vTaskDelayUntil+0x50>
80006a74:	c0 a8       	rjmp	80006a88 <vTaskDelayUntil+0x40>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
80006a76:	0e 38       	cp.w	r8,r7
80006a78:	e0 8b 00 16 	brhi	80006aa4 <vTaskDelayUntil+0x5c>
80006a7c:	48 e8       	lddpc	r8,80006ab4 <vTaskDelayUntil+0x6c>
80006a7e:	70 08       	ld.w	r8,r8[0x0]
80006a80:	10 37       	cp.w	r7,r8
80006a82:	e0 8b 00 11 	brhi	80006aa4 <vTaskDelayUntil+0x5c>
80006a86:	c1 18       	rjmp	80006aa8 <vTaskDelayUntil+0x60>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006a88:	48 c8       	lddpc	r8,80006ab8 <vTaskDelayUntil+0x70>
80006a8a:	70 0c       	ld.w	r12,r8[0x0]
80006a8c:	2f cc       	sub	r12,-4
80006a8e:	f0 1f 00 0c 	mcall	80006abc <vTaskDelayUntil+0x74>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
80006a92:	0e 9c       	mov	r12,r7
80006a94:	f0 1f 00 0b 	mcall	80006ac0 <vTaskDelayUntil+0x78>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
80006a98:	f0 1f 00 0b 	mcall	80006ac4 <vTaskDelayUntil+0x7c>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
80006a9c:	c0 81       	brne	80006aac <vTaskDelayUntil+0x64>
		{
			portYIELD_WITHIN_API();
80006a9e:	d7 33       	scall
80006aa0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80006aa4:	8d 07       	st.w	r6[0x0],r7
80006aa6:	cf 1b       	rjmp	80006a88 <vTaskDelayUntil+0x40>
80006aa8:	8d 07       	st.w	r6[0x0],r7
80006aaa:	cf 7b       	rjmp	80006a98 <vTaskDelayUntil+0x50>
80006aac:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006ab0:	80 00       	ld.sh	r0,r0[0x0]
80006ab2:	65 00       	ld.w	r0,r2[0x40]
80006ab4:	00 00       	add	r0,r0
80006ab6:	0d 24       	ld.uh	r4,r6++
80006ab8:	00 00       	add	r0,r0
80006aba:	0c f8       	st.b	--r6,r8
80006abc:	80 00       	ld.sh	r0,r0[0x0]
80006abe:	5c ba       	swap.b	r10
80006ac0:	80 00       	ld.sh	r0,r0[0x0]
80006ac2:	69 a4       	ld.w	r4,r4[0x68]
80006ac4:	80 00       	ld.sh	r0,r0[0x0]
80006ac6:	68 bc       	ld.w	r12,r4[0x2c]

80006ac8 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
80006ac8:	eb cd 40 c0 	pushm	r6-r7,lr
80006acc:	16 96       	mov	r6,r11
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
80006ace:	48 e7       	lddpc	r7,80006b04 <vTaskPlaceOnEventList+0x3c>
80006ad0:	6e 0b       	ld.w	r11,r7[0x0]
80006ad2:	2e 8b       	sub	r11,-24
80006ad4:	f0 1f 00 0d 	mcall	80006b08 <vTaskPlaceOnEventList+0x40>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006ad8:	6e 0c       	ld.w	r12,r7[0x0]
80006ada:	2f cc       	sub	r12,-4
80006adc:	f0 1f 00 0c 	mcall	80006b0c <vTaskPlaceOnEventList+0x44>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
80006ae0:	5b f6       	cp.w	r6,-1
80006ae2:	c0 81       	brne	80006af2 <vTaskPlaceOnEventList+0x2a>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006ae4:	6e 0b       	ld.w	r11,r7[0x0]
80006ae6:	2f cb       	sub	r11,-4
80006ae8:	48 ac       	lddpc	r12,80006b10 <vTaskPlaceOnEventList+0x48>
80006aea:	f0 1f 00 0b 	mcall	80006b14 <vTaskPlaceOnEventList+0x4c>
80006aee:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
80006af2:	48 a8       	lddpc	r8,80006b18 <vTaskPlaceOnEventList+0x50>
80006af4:	70 0c       	ld.w	r12,r8[0x0]
			prvAddCurrentTaskToDelayedList( xTimeToWake );
80006af6:	ec 0c 00 0c 	add	r12,r6,r12
80006afa:	f0 1f 00 09 	mcall	80006b1c <vTaskPlaceOnEventList+0x54>
80006afe:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006b02:	00 00       	add	r0,r0
80006b04:	00 00       	add	r0,r0
80006b06:	0c f8       	st.b	--r6,r8
80006b08:	80 00       	ld.sh	r0,r0[0x0]
80006b0a:	5c 86       	casts.h	r6
80006b0c:	80 00       	ld.sh	r0,r0[0x0]
80006b0e:	5c ba       	swap.b	r10
80006b10:	00 00       	add	r0,r0
80006b12:	0d 4c       	ld.w	r12,--r6
80006b14:	80 00       	ld.sh	r0,r0[0x0]
80006b16:	5c 6a       	casts.b	r10
80006b18:	00 00       	add	r0,r0
80006b1a:	0d 24       	ld.uh	r4,r6++
80006b1c:	80 00       	ld.sh	r0,r0[0x0]
80006b1e:	69 a4       	ld.w	r4,r4[0x68]

80006b20 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
80006b20:	eb cd 40 f8 	pushm	r3-r7,lr
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80006b24:	49 67       	lddpc	r7,80006b7c <prvIdleTask+0x5c>
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
80006b26:	49 74       	lddpc	r4,80006b80 <prvIdleTask+0x60>

				taskENTER_CRITICAL();
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					--uxCurrentNumberOfTasks;
80006b28:	49 73       	lddpc	r3,80006b84 <prvIdleTask+0x64>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80006b2a:	49 85       	lddpc	r5,80006b88 <prvIdleTask+0x68>
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80006b2c:	6e 08       	ld.w	r8,r7[0x0]
80006b2e:	58 08       	cp.w	r8,0
80006b30:	c1 e0       	breq	80006b6c <prvIdleTask+0x4c>
		{
			vTaskSuspendAll();
80006b32:	f0 1f 00 17 	mcall	80006b8c <prvIdleTask+0x6c>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
80006b36:	68 06       	ld.w	r6,r4[0x0]
			xTaskResumeAll();
80006b38:	f0 1f 00 16 	mcall	80006b90 <prvIdleTask+0x70>

			if( xListIsEmpty == pdFALSE )
80006b3c:	58 06       	cp.w	r6,0
80006b3e:	c1 70       	breq	80006b6c <prvIdleTask+0x4c>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
80006b40:	f0 1f 00 15 	mcall	80006b94 <prvIdleTask+0x74>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
80006b44:	68 38       	ld.w	r8,r4[0xc]
80006b46:	70 36       	ld.w	r6,r8[0xc]
					vListRemove( &( pxTCB->xGenericListItem ) );
80006b48:	ec cc ff fc 	sub	r12,r6,-4
80006b4c:	f0 1f 00 13 	mcall	80006b98 <prvIdleTask+0x78>
					--uxCurrentNumberOfTasks;
80006b50:	66 08       	ld.w	r8,r3[0x0]
80006b52:	20 18       	sub	r8,1
80006b54:	87 08       	st.w	r3[0x0],r8
					--uxTasksDeleted;
80006b56:	6e 08       	ld.w	r8,r7[0x0]
80006b58:	20 18       	sub	r8,1
80006b5a:	8f 08       	st.w	r7[0x0],r8
				}
				taskEXIT_CRITICAL();
80006b5c:	f0 1f 00 10 	mcall	80006b9c <prvIdleTask+0x7c>

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
80006b60:	6c cc       	ld.w	r12,r6[0x30]
80006b62:	f0 1f 00 10 	mcall	80006ba0 <prvIdleTask+0x80>
		vPortFree( pxTCB );
80006b66:	0c 9c       	mov	r12,r6
80006b68:	f0 1f 00 0e 	mcall	80006ba0 <prvIdleTask+0x80>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80006b6c:	6a 08       	ld.w	r8,r5[0x0]
80006b6e:	58 18       	cp.w	r8,1
80006b70:	e0 88 00 03 	brls	80006b76 <prvIdleTask+0x56>
			{
				taskYIELD();
80006b74:	d7 33       	scall
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
80006b76:	f0 1f 00 0c 	mcall	80006ba4 <prvIdleTask+0x84>
		}
		#endif
	}
80006b7a:	cd 9b       	rjmp	80006b2c <prvIdleTask+0xc>
80006b7c:	00 00       	add	r0,r0
80006b7e:	0c 38       	cp.w	r8,r6
80006b80:	00 00       	add	r0,r0
80006b82:	0c e4       	st.h	--r6,r4
80006b84:	00 00       	add	r0,r0
80006b86:	0d 44       	ld.w	r4,--r6
80006b88:	00 00       	add	r0,r0
80006b8a:	0c 44       	or	r4,r6
80006b8c:	80 00       	ld.sh	r0,r0[0x0]
80006b8e:	65 00       	ld.w	r0,r2[0x40]
80006b90:	80 00       	ld.sh	r0,r0[0x0]
80006b92:	68 bc       	ld.w	r12,r4[0x2c]
80006b94:	80 00       	ld.sh	r0,r0[0x0]
80006b96:	5d 74       	*unknown*
80006b98:	80 00       	ld.sh	r0,r0[0x0]
80006b9a:	5c ba       	swap.b	r10
80006b9c:	80 00       	ld.sh	r0,r0[0x0]
80006b9e:	5e 80       	retls	r0
80006ba0:	80 00       	ld.sh	r0,r0[0x0]
80006ba2:	5f b8       	srhi	r8
80006ba4:	80 00       	ld.sh	r0,r0[0x0]
80006ba6:	20 2c       	sub	r12,2

80006ba8 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
80006ba8:	d4 31       	pushm	r0-r7,lr
80006baa:	20 1d       	sub	sp,4
80006bac:	fa c4 ff d8 	sub	r4,sp,-40
80006bb0:	50 0c       	stdsp	sp[0x0],r12
80006bb2:	16 91       	mov	r1,r11
80006bb4:	14 97       	mov	r7,r10
80006bb6:	12 90       	mov	r0,r9
80006bb8:	10 93       	mov	r3,r8
80006bba:	68 02       	ld.w	r2,r4[0x0]
80006bbc:	68 16       	ld.w	r6,r4[0x4]
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
80006bbe:	34 8c       	mov	r12,72
80006bc0:	f0 1f 00 5c 	mcall	80006d30 <xTaskGenericCreate+0x188>
80006bc4:	18 95       	mov	r5,r12

	if( pxNewTCB != NULL )
80006bc6:	c0 31       	brne	80006bcc <xTaskGenericCreate+0x24>
80006bc8:	3f fc       	mov	r12,-1
80006bca:	ca f8       	rjmp	80006d28 <xTaskGenericCreate+0x180>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80006bcc:	58 06       	cp.w	r6,0
80006bce:	e0 81 00 af 	brne	80006d2c <xTaskGenericCreate+0x184>
80006bd2:	0e 9c       	mov	r12,r7
80006bd4:	5c 7c       	castu.h	r12
80006bd6:	a3 6c       	lsl	r12,0x2
80006bd8:	f0 1f 00 56 	mcall	80006d30 <xTaskGenericCreate+0x188>
80006bdc:	18 96       	mov	r6,r12
80006bde:	8b cc       	st.w	r5[0x30],r12

		if( pxNewTCB->pxStack == NULL )
80006be0:	c0 61       	brne	80006bec <xTaskGenericCreate+0x44>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
80006be2:	0a 9c       	mov	r12,r5
80006be4:	f0 1f 00 54 	mcall	80006d34 <xTaskGenericCreate+0x18c>
80006be8:	3f fc       	mov	r12,-1
80006bea:	c9 f8       	rjmp	80006d28 <xTaskGenericCreate+0x180>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
80006bec:	5c 77       	castu.h	r7
80006bee:	ee 0a 15 02 	lsl	r10,r7,0x2
80006bf2:	e0 6b 00 a5 	mov	r11,165
80006bf6:	0c 9c       	mov	r12,r6
80006bf8:	f0 1f 00 50 	mcall	80006d38 <xTaskGenericCreate+0x190>
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~portBYTE_ALIGNMENT_MASK  ) );
80006bfc:	ee c6 00 01 	sub	r6,r7,1
80006c00:	6a c8       	ld.w	r8,r5[0x30]
80006c02:	f0 06 00 26 	add	r6,r8,r6<<0x2
80006c06:	e0 16 ff fc 	andl	r6,0xfffc
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
80006c0a:	31 0a       	mov	r10,16
80006c0c:	02 9b       	mov	r11,r1
80006c0e:	ea cc ff cc 	sub	r12,r5,-52
80006c12:	f0 1f 00 4b 	mcall	80006d3c <xTaskGenericCreate+0x194>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
80006c16:	30 08       	mov	r8,0
80006c18:	eb 68 00 43 	st.b	r5[67],r8
80006c1c:	58 73       	cp.w	r3,7
80006c1e:	e6 07 17 80 	movls	r7,r3
80006c22:	f9 b7 0b 07 	movhi	r7,7
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
80006c26:	8b b7       	st.w	r5[0x2c],r7
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
80006c28:	eb 47 00 44 	st.w	r5[68],r7
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
80006c2c:	ea c4 ff fc 	sub	r4,r5,-4
80006c30:	08 9c       	mov	r12,r4
80006c32:	f0 1f 00 44 	mcall	80006d40 <xTaskGenericCreate+0x198>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
80006c36:	ea cc ff e8 	sub	r12,r5,-24
80006c3a:	f0 1f 00 42 	mcall	80006d40 <xTaskGenericCreate+0x198>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
80006c3e:	8b 45       	st.w	r5[0x10],r5

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
80006c40:	ee 07 11 08 	rsub	r7,r7,8
80006c44:	8b 67       	st.w	r5[0x18],r7
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
80006c46:	8b 95       	st.w	r5[0x24],r5
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
80006c48:	00 9a       	mov	r10,r0
80006c4a:	40 0b       	lddsp	r11,sp[0x0]
80006c4c:	0c 9c       	mov	r12,r6
80006c4e:	f0 1f 00 3e 	mcall	80006d44 <xTaskGenericCreate+0x19c>
80006c52:	8b 0c       	st.w	r5[0x0],r12
		if( ( void * ) pxCreatedTask != NULL )
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
80006c54:	58 02       	cp.w	r2,0
80006c56:	e5 f5 1a 00 	st.wne	r2[0x0],r5
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
80006c5a:	f0 1f 00 3c 	mcall	80006d48 <xTaskGenericCreate+0x1a0>
		{
			uxCurrentNumberOfTasks++;
80006c5e:	4b c8       	lddpc	r8,80006d4c <xTaskGenericCreate+0x1a4>
80006c60:	70 09       	ld.w	r9,r8[0x0]
80006c62:	2f f9       	sub	r9,-1
80006c64:	91 09       	st.w	r8[0x0],r9
			if( pxCurrentTCB == NULL )
80006c66:	4b b8       	lddpc	r8,80006d50 <xTaskGenericCreate+0x1a8>
80006c68:	70 08       	ld.w	r8,r8[0x0]
80006c6a:	58 08       	cp.w	r8,0
80006c6c:	c2 61       	brne	80006cb8 <xTaskGenericCreate+0x110>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
80006c6e:	4b 98       	lddpc	r8,80006d50 <xTaskGenericCreate+0x1a8>
80006c70:	91 05       	st.w	r8[0x0],r5

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
80006c72:	4b 78       	lddpc	r8,80006d4c <xTaskGenericCreate+0x1a4>
80006c74:	70 08       	ld.w	r8,r8[0x0]
80006c76:	58 18       	cp.w	r8,1
80006c78:	c2 b1       	brne	80006cce <xTaskGenericCreate+0x126>
80006c7a:	4b 77       	lddpc	r7,80006d54 <xTaskGenericCreate+0x1ac>

/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
80006c7c:	ee c6 ff 60 	sub	r6,r7,-160
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
80006c80:	0e 9c       	mov	r12,r7
80006c82:	f0 1f 00 36 	mcall	80006d58 <xTaskGenericCreate+0x1b0>
80006c86:	2e c7       	sub	r7,-20

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
80006c88:	0c 37       	cp.w	r7,r6
80006c8a:	cf b1       	brne	80006c80 <xTaskGenericCreate+0xd8>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
80006c8c:	4b 47       	lddpc	r7,80006d5c <xTaskGenericCreate+0x1b4>
80006c8e:	0e 9c       	mov	r12,r7
80006c90:	f0 1f 00 32 	mcall	80006d58 <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
80006c94:	4b 36       	lddpc	r6,80006d60 <xTaskGenericCreate+0x1b8>
80006c96:	0c 9c       	mov	r12,r6
80006c98:	f0 1f 00 30 	mcall	80006d58 <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xPendingReadyList );
80006c9c:	4b 2c       	lddpc	r12,80006d64 <xTaskGenericCreate+0x1bc>
80006c9e:	f0 1f 00 2f 	mcall	80006d58 <xTaskGenericCreate+0x1b0>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
80006ca2:	4b 2c       	lddpc	r12,80006d68 <xTaskGenericCreate+0x1c0>
80006ca4:	f0 1f 00 2d 	mcall	80006d58 <xTaskGenericCreate+0x1b0>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
80006ca8:	4b 1c       	lddpc	r12,80006d6c <xTaskGenericCreate+0x1c4>
80006caa:	f0 1f 00 2c 	mcall	80006d58 <xTaskGenericCreate+0x1b0>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
80006cae:	4b 18       	lddpc	r8,80006d70 <xTaskGenericCreate+0x1c8>
80006cb0:	91 07       	st.w	r8[0x0],r7
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
80006cb2:	4b 18       	lddpc	r8,80006d74 <xTaskGenericCreate+0x1cc>
80006cb4:	91 06       	st.w	r8[0x0],r6
80006cb6:	c0 c8       	rjmp	80006cce <xTaskGenericCreate+0x126>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
80006cb8:	4b 08       	lddpc	r8,80006d78 <xTaskGenericCreate+0x1d0>
80006cba:	70 08       	ld.w	r8,r8[0x0]
80006cbc:	58 08       	cp.w	r8,0
80006cbe:	c0 81       	brne	80006cce <xTaskGenericCreate+0x126>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
80006cc0:	4a 48       	lddpc	r8,80006d50 <xTaskGenericCreate+0x1a8>
80006cc2:	70 08       	ld.w	r8,r8[0x0]
80006cc4:	70 b8       	ld.w	r8,r8[0x2c]
80006cc6:	10 33       	cp.w	r3,r8
80006cc8:	c0 33       	brcs	80006cce <xTaskGenericCreate+0x126>
					{
						pxCurrentTCB = pxNewTCB;
80006cca:	4a 28       	lddpc	r8,80006d50 <xTaskGenericCreate+0x1a8>
80006ccc:	91 05       	st.w	r8[0x0],r5
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
80006cce:	6a b8       	ld.w	r8,r5[0x2c]
80006cd0:	4a b9       	lddpc	r9,80006d7c <xTaskGenericCreate+0x1d4>
80006cd2:	72 09       	ld.w	r9,r9[0x0]
80006cd4:	12 38       	cp.w	r8,r9
80006cd6:	e0 88 00 04 	brls	80006cde <xTaskGenericCreate+0x136>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
80006cda:	4a 99       	lddpc	r9,80006d7c <xTaskGenericCreate+0x1d4>
80006cdc:	93 08       	st.w	r9[0x0],r8
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
80006cde:	4a 98       	lddpc	r8,80006d80 <xTaskGenericCreate+0x1d8>
80006ce0:	70 09       	ld.w	r9,r8[0x0]
80006ce2:	2f f9       	sub	r9,-1
80006ce4:	91 09       	st.w	r8[0x0],r9

			prvAddTaskToReadyQueue( pxNewTCB );
80006ce6:	6a b8       	ld.w	r8,r5[0x2c]
80006ce8:	4a 79       	lddpc	r9,80006d84 <xTaskGenericCreate+0x1dc>
80006cea:	72 09       	ld.w	r9,r9[0x0]
80006cec:	12 38       	cp.w	r8,r9
80006cee:	e0 88 00 04 	brls	80006cf6 <xTaskGenericCreate+0x14e>
80006cf2:	4a 59       	lddpc	r9,80006d84 <xTaskGenericCreate+0x1dc>
80006cf4:	93 08       	st.w	r9[0x0],r8
80006cf6:	6a bc       	ld.w	r12,r5[0x2c]
80006cf8:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006cfc:	08 9b       	mov	r11,r4
80006cfe:	49 68       	lddpc	r8,80006d54 <xTaskGenericCreate+0x1ac>
80006d00:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80006d04:	f0 1f 00 21 	mcall	80006d88 <xTaskGenericCreate+0x1e0>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
80006d08:	f0 1f 00 21 	mcall	80006d8c <xTaskGenericCreate+0x1e4>
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
80006d0c:	49 b8       	lddpc	r8,80006d78 <xTaskGenericCreate+0x1d0>
80006d0e:	70 08       	ld.w	r8,r8[0x0]
80006d10:	58 08       	cp.w	r8,0
80006d12:	c0 a0       	breq	80006d26 <xTaskGenericCreate+0x17e>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
80006d14:	48 f8       	lddpc	r8,80006d50 <xTaskGenericCreate+0x1a8>
80006d16:	70 08       	ld.w	r8,r8[0x0]
80006d18:	70 b8       	ld.w	r8,r8[0x2c]
80006d1a:	10 33       	cp.w	r3,r8
80006d1c:	e0 88 00 05 	brls	80006d26 <xTaskGenericCreate+0x17e>
			{
				portYIELD_WITHIN_API();
80006d20:	d7 33       	scall
80006d22:	30 1c       	mov	r12,1
80006d24:	c0 28       	rjmp	80006d28 <xTaskGenericCreate+0x180>
80006d26:	30 1c       	mov	r12,1
			}
		}
	}

	return xReturn;
}
80006d28:	2f fd       	sub	sp,-4
80006d2a:	d8 32       	popm	r0-r7,pc
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80006d2c:	99 c6       	st.w	r12[0x30],r6
80006d2e:	c5 fb       	rjmp	80006bec <xTaskGenericCreate+0x44>
80006d30:	80 00       	ld.sh	r0,r0[0x0]
80006d32:	5f e0       	srqs	r0
80006d34:	80 00       	ld.sh	r0,r0[0x0]
80006d36:	5f b8       	srhi	r8
80006d38:	80 00       	ld.sh	r0,r0[0x0]
80006d3a:	79 30       	ld.w	r0,r12[0x4c]
80006d3c:	80 00       	ld.sh	r0,r0[0x0]
80006d3e:	7c 5c       	ld.w	r12,lr[0x14]
80006d40:	80 00       	ld.sh	r0,r0[0x0]
80006d42:	5c 64       	casts.b	r4
80006d44:	80 00       	ld.sh	r0,r0[0x0]
80006d46:	5c e0       	tnbz	r0
80006d48:	80 00       	ld.sh	r0,r0[0x0]
80006d4a:	5d 74       	*unknown*
80006d4c:	00 00       	add	r0,r0
80006d4e:	0d 44       	ld.w	r4,--r6
80006d50:	00 00       	add	r0,r0
80006d52:	0c f8       	st.b	--r6,r8
80006d54:	00 00       	add	r0,r0
80006d56:	0c 44       	or	r4,r6
80006d58:	80 00       	ld.sh	r0,r0[0x0]
80006d5a:	5c 50       	castu.b	r0
80006d5c:	00 00       	add	r0,r0
80006d5e:	0d 10       	ld.sh	r0,r6++
80006d60:	00 00       	add	r0,r0
80006d62:	0d 2c       	ld.uh	r12,r6++
80006d64:	00 00       	add	r0,r0
80006d66:	0c fc       	st.b	--r6,r12
80006d68:	00 00       	add	r0,r0
80006d6a:	0c e4       	st.h	--r6,r4
80006d6c:	00 00       	add	r0,r0
80006d6e:	0d 4c       	ld.w	r12,--r6
80006d70:	00 00       	add	r0,r0
80006d72:	0c 30       	cp.w	r0,r6
80006d74:	00 00       	add	r0,r0
80006d76:	0c 40       	or	r0,r6
80006d78:	00 00       	add	r0,r0
80006d7a:	0c 34       	cp.w	r4,r6
80006d7c:	00 00       	add	r0,r0
80006d7e:	0c 2c       	rsub	r12,r6
80006d80:	00 00       	add	r0,r0
80006d82:	0d 40       	ld.w	r0,--r6
80006d84:	00 00       	add	r0,r0
80006d86:	0d 60       	ld.uh	r0,--r6
80006d88:	80 00       	ld.sh	r0,r0[0x0]
80006d8a:	5c 6a       	casts.b	r10
80006d8c:	80 00       	ld.sh	r0,r0[0x0]
80006d8e:	5e 80       	retls	r0

80006d90 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
80006d90:	d4 01       	pushm	lr
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
80006d92:	30 09       	mov	r9,0
80006d94:	1a d9       	st.w	--sp,r9
80006d96:	1a d9       	st.w	--sp,r9
80006d98:	1a d9       	st.w	--sp,r9
80006d9a:	12 98       	mov	r8,r9
80006d9c:	e0 6a 01 00 	mov	r10,256
80006da0:	48 9b       	lddpc	r11,80006dc4 <vTaskStartScheduler+0x34>
80006da2:	48 ac       	lddpc	r12,80006dc8 <vTaskStartScheduler+0x38>
80006da4:	f0 1f 00 0a 	mcall	80006dcc <vTaskStartScheduler+0x3c>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
80006da8:	2f dd       	sub	sp,-12
80006daa:	58 1c       	cp.w	r12,1
80006dac:	c0 a1       	brne	80006dc0 <vTaskStartScheduler+0x30>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
80006dae:	d3 03       	ssrf	0x10

		xSchedulerRunning = pdTRUE;
80006db0:	30 19       	mov	r9,1
80006db2:	48 88       	lddpc	r8,80006dd0 <vTaskStartScheduler+0x40>
80006db4:	91 09       	st.w	r8[0x0],r9
		xTickCount = ( portTickType ) 0;
80006db6:	30 09       	mov	r9,0
80006db8:	48 78       	lddpc	r8,80006dd4 <vTaskStartScheduler+0x44>
80006dba:	91 09       	st.w	r8[0x0],r9
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
80006dbc:	f0 1f 00 07 	mcall	80006dd8 <vTaskStartScheduler+0x48>
80006dc0:	d8 02       	popm	pc
80006dc2:	00 00       	add	r0,r0
80006dc4:	80 00       	ld.sh	r0,r0[0x0]
80006dc6:	da 20       	acall	0xa2
80006dc8:	80 00       	ld.sh	r0,r0[0x0]
80006dca:	6b 20       	ld.w	r0,r5[0x48]
80006dcc:	80 00       	ld.sh	r0,r0[0x0]
80006dce:	6b a8       	ld.w	r8,r5[0x68]
80006dd0:	00 00       	add	r0,r0
80006dd2:	0c 34       	cp.w	r4,r6
80006dd4:	00 00       	add	r0,r0
80006dd6:	0d 24       	ld.uh	r4,r6++
80006dd8:	80 00       	ld.sh	r0,r0[0x0]
80006dda:	5d 84       	*unknown*

80006ddc <PrintChar>:
	
static void task_log(void * pvParameters);

char *  PrintChar(char c, char * str)
{
	*str++ = c;
80006ddc:	16 cc       	st.b	r11++,r12
	return str;
}
80006dde:	5e fb       	retal	r11

80006de0 <PrintHex>:
	
	return str;
}

char * PrintHex(int i,char len, char * str)
{
80006de0:	eb cd 40 c0 	pushm	r6-r7,lr
80006de4:	20 3d       	sub	sp,12
80006de6:	18 98       	mov	r8,r12
	char * p = str;
	char s[12];
	memset(s, 0 , 12);
80006de8:	30 06       	mov	r6,0
80006dea:	30 07       	mov	r7,0
80006dec:	fa e7 00 00 	st.d	sp[0],r6
80006df0:	30 0c       	mov	r12,0
80006df2:	50 2c       	stdsp	sp[0x8],r12
	int cnt=0;
	
	if(i)
80006df4:	58 08       	cp.w	r8,0
80006df6:	c1 30       	breq	80006e1c <PrintHex+0x3c>
80006df8:	18 99       	mov	r9,r12
	while(i)
	{
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
80006dfa:	1a 9c       	mov	r12,sp
80006dfc:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80006e00:	58 9e       	cp.w	lr,9
80006e02:	e0 8a 00 04 	brle	80006e0a <PrintHex+0x2a>
80006e06:	2c 9e       	sub	lr,-55
80006e08:	c0 48       	rjmp	80006e10 <PrintHex+0x30>
80006e0a:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80006e0e:	2d 0e       	sub	lr,-48
80006e10:	f8 09 0b 0e 	st.b	r12[r9],lr
80006e14:	2f f9       	sub	r9,-1
		i = (i >> 4 ) & 0x0FFFFFFF;
80006e16:	a5 88       	lsr	r8,0x4
	char s[12];
	memset(s, 0 , 12);
	int cnt=0;
	
	if(i)
	while(i)
80006e18:	cf 21       	brne	80006dfc <PrintHex+0x1c>
80006e1a:	c0 48       	rjmp	80006e22 <PrintHex+0x42>
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
		i = (i >> 4 ) & 0x0FFFFFFF;
		//i >>= 4
	}
	else
	s[cnt++] = '0';
80006e1c:	33 08       	mov	r8,48
80006e1e:	ba 88       	st.b	sp[0x0],r8
80006e20:	30 19       	mov	r9,1
	
	if(len - cnt > 0 )
80006e22:	f6 09 01 08 	sub	r8,r11,r9
80006e26:	58 08       	cp.w	r8,0
80006e28:	e0 8a 00 13 	brle	80006e4e <PrintHex+0x6e>
	{
		char num = len - cnt;
80006e2c:	12 1b       	sub	r11,r9
80006e2e:	f9 db c0 08 	bfextu	r12,r11,0x0,0x8
		for(int i = 0; i < num; i++)
80006e32:	18 9e       	mov	lr,r12
80006e34:	58 0c       	cp.w	r12,0
80006e36:	e0 8a 00 0c 	brle	80006e4e <PrintHex+0x6e>
80006e3a:	1a 9b       	mov	r11,sp
80006e3c:	12 0b       	add	r11,r9
80006e3e:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80006e40:	33 07       	mov	r7,48
80006e42:	16 c7       	st.b	r11++,r7
	s[cnt++] = '0';
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80006e44:	2f f8       	sub	r8,-1
80006e46:	1c 38       	cp.w	r8,lr
80006e48:	cf d5       	brlt	80006e42 <PrintHex+0x62>
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
80006e4a:	f8 09 00 09 	add	r9,r12,r9
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80006e4e:	f2 c8 ff ff 	sub	r8,r9,-1
	s[cnt++] = '0';
	
	while(cnt>0)
80006e52:	f0 cb ff ff 	sub	r11,r8,-1
80006e56:	58 0b       	cp.w	r11,0
80006e58:	e0 8a 00 19 	brle	80006e8a <PrintHex+0xaa>
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80006e5c:	fa cb ff f4 	sub	r11,sp,-12
80006e60:	f6 09 00 09 	add	r9,r11,r9
80006e64:	37 8b       	mov	r11,120
80006e66:	f3 6b ff f4 	st.b	r9[-12],r11
	s[cnt++] = '0';
80006e6a:	fa c9 ff f4 	sub	r9,sp,-12
80006e6e:	10 09       	add	r9,r8
80006e70:	33 0b       	mov	r11,48
80006e72:	f3 6b ff f4 	st.b	r9[-12],r11
80006e76:	fa 08 00 08 	add	r8,sp,r8
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
80006e7a:	fa ce 00 01 	sub	lr,sp,1
80006e7e:	14 99       	mov	r9,r10
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
	*p++ = s[--cnt];
80006e80:	11 8b       	ld.ub	r11,r8[0x0]
80006e82:	12 cb       	st.b	r9++,r11
80006e84:	20 18       	sub	r8,1
	}
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
80006e86:	1c 38       	cp.w	r8,lr
80006e88:	cf c1       	brne	80006e80 <PrintHex+0xa0>
	*p++ = s[--cnt];
		
	return str;
}
80006e8a:	14 9c       	mov	r12,r10
80006e8c:	2f dd       	sub	sp,-12
80006e8e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

80006e92 <PrintDec>:
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
{
80006e92:	d4 21       	pushm	r4-r7,lr
80006e94:	20 3d       	sub	sp,12
80006e96:	18 98       	mov	r8,r12
	char * p = str;
	
	int sign = i>=0 ? 0 : 1;
	char s[10];
	memset(s, 0 , 10);
80006e98:	30 06       	mov	r6,0
80006e9a:	30 07       	mov	r7,0
80006e9c:	fa e7 00 00 	st.d	sp[0],r6
80006ea0:	30 0c       	mov	r12,0
80006ea2:	ba 4c       	st.h	sp[0x8],r12
	int cnt=0;
	if(sign)
80006ea4:	58 08       	cp.w	r8,0
80006ea6:	c0 35       	brlt	80006eac <PrintDec+0x1a>
80006ea8:	14 97       	mov	r7,r10
80006eaa:	c0 58       	rjmp	80006eb4 <PrintDec+0x22>
	{
		*p++ = '-';
80006eac:	14 97       	mov	r7,r10
80006eae:	32 d9       	mov	r9,45
80006eb0:	0e c9       	st.b	r7++,r9
		i = -i;
80006eb2:	5c 38       	neg	r8
	}
	
	if(i == 0 )s[cnt++] = '0';
80006eb4:	58 08       	cp.w	r8,0
80006eb6:	c0 51       	brne	80006ec0 <PrintDec+0x2e>
80006eb8:	33 08       	mov	r8,48
80006eba:	ba 88       	st.b	sp[0x0],r8
80006ebc:	30 1e       	mov	lr,1
80006ebe:	c2 f8       	rjmp	80006f1c <PrintDec+0x8a>
	
	int ten = i%10;
80006ec0:	e0 65 66 67 	mov	r5,26215
80006ec4:	ea 15 66 66 	orh	r5,0x6666
80006ec8:	f0 05 04 44 	muls.d	r4,r8,r5
80006ecc:	ea 0c 14 02 	asr	r12,r5,0x2
80006ed0:	f0 09 14 1f 	asr	r9,r8,0x1f
80006ed4:	f8 09 01 09 	sub	r9,r12,r9
80006ed8:	f2 09 00 29 	add	r9,r9,r9<<0x2
80006edc:	f0 09 01 19 	sub	r9,r8,r9<<0x1
80006ee0:	30 0e       	mov	lr,0
	while(i)
	{
		s[cnt] = ten+'0';
80006ee2:	1a 9c       	mov	r12,sp
		cnt++;
		i /= 10;
80006ee4:	e0 66 66 67 	mov	r6,26215
80006ee8:	ea 16 66 66 	orh	r6,0x6666
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
	{
		s[cnt] = ten+'0';
80006eec:	2d 09       	sub	r9,-48
80006eee:	f8 0e 0b 09 	st.b	r12[lr],r9
		cnt++;
80006ef2:	2f fe       	sub	lr,-1
		i /= 10;
80006ef4:	f0 06 04 44 	muls.d	r4,r8,r6
80006ef8:	ea 09 14 02 	asr	r9,r5,0x2
80006efc:	bf 58       	asr	r8,0x1f
80006efe:	f2 08 01 08 	sub	r8,r9,r8
		ten = i%10;
80006f02:	f0 06 04 44 	muls.d	r4,r8,r6
80006f06:	ea 09 14 02 	asr	r9,r5,0x2
80006f0a:	f0 05 14 1f 	asr	r5,r8,0x1f
80006f0e:	0a 19       	sub	r9,r5
80006f10:	f2 09 00 29 	add	r9,r9,r9<<0x2
80006f14:	f0 09 01 19 	sub	r9,r8,r9<<0x1
	}
	
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
80006f18:	58 08       	cp.w	r8,0
80006f1a:	ce 91       	brne	80006eec <PrintDec+0x5a>
		cnt++;
		i /= 10;
		ten = i%10;
	}
	
	if(len - cnt > 0 )
80006f1c:	f6 0e 01 08 	sub	r8,r11,lr
80006f20:	58 08       	cp.w	r8,0
80006f22:	e0 89 00 06 	brgt	80006f2e <PrintDec+0x9c>
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80006f26:	58 0e       	cp.w	lr,0
80006f28:	e0 89 00 14 	brgt	80006f50 <PrintDec+0xbe>
80006f2c:	c1 d8       	rjmp	80006f66 <PrintDec+0xd4>
		ten = i%10;
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
80006f2e:	1c 1b       	sub	r11,lr
80006f30:	5c 5b       	castu.b	r11
		for(int i = 0; i < num; i++)
80006f32:	16 9c       	mov	r12,r11
80006f34:	58 0b       	cp.w	r11,0
80006f36:	fe 9a ff f8 	brle	80006f26 <PrintDec+0x94>
80006f3a:	1a 99       	mov	r9,sp
80006f3c:	1c 09       	add	r9,lr
80006f3e:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80006f40:	33 06       	mov	r6,48
80006f42:	12 c6       	st.b	r9++,r6
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80006f44:	2f f8       	sub	r8,-1
80006f46:	18 38       	cp.w	r8,r12
80006f48:	cf d5       	brlt	80006f42 <PrintDec+0xb0>
{
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
80006f4a:	f6 0e 00 0e 	add	lr,r11,lr
80006f4e:	ce cb       	rjmp	80006f26 <PrintDec+0x94>
80006f50:	fa c8 ff f4 	sub	r8,sp,-12
80006f54:	1c 08       	add	r8,lr
80006f56:	20 d8       	sub	r8,13
80006f58:	fa cb 00 01 	sub	r11,sp,1
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
	*p++ = s[--cnt];
80006f5c:	11 89       	ld.ub	r9,r8[0x0]
80006f5e:	0e c9       	st.b	r7++,r9
80006f60:	20 18       	sub	r8,1
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80006f62:	16 38       	cp.w	r8,r11
80006f64:	cf c1       	brne	80006f5c <PrintDec+0xca>
	*p++ = s[--cnt];
	
	return str;
}
80006f66:	14 9c       	mov	r12,r10
80006f68:	2f dd       	sub	sp,-12
80006f6a:	d8 22       	popm	r4-r7,pc

80006f6c <log>:
	,  NULL );
	
}

int log(char * content, ...)
{
80006f6c:	d4 31       	pushm	r0-r7,lr
80006f6e:	fa cd 02 08 	sub	sp,sp,520
80006f72:	18 97       	mov	r7,r12
	
	
	char logTmp[MAX_LOG_LINE_SIZE];
	memset(logTmp, '\0', MAX_LOG_LINE_SIZE);	
80006f74:	e0 6a 01 00 	mov	r10,256
80006f78:	30 0b       	mov	r11,0
80006f7a:	fa cc fe f8 	sub	r12,sp,-264
80006f7e:	f0 1f 00 4e 	mcall	800070b4 <log+0x148>
	,  tskLOG_PRIORITY
	,  NULL );
	
}

int log(char * content, ...)
80006f82:	fa c4 fd d4 	sub	r4,sp,-556
80006f86:	30 0a       	mov	r10,0
80006f88:	50 0a       	stdsp	sp[0x0],r10
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80006f8a:	fa c3 ff fc 	sub	r3,sp,-4
80006f8e:	e0 61 01 00 	mov	r1,256
80006f92:	14 90       	mov	r0,r10
			
					if(*str == '%')
80006f94:	32 52       	mov	r2,37
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
80006f96:	fa c6 fe f8 	sub	r6,sp,-264
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80006f9a:	02 9a       	mov	r10,r1
80006f9c:	00 9b       	mov	r11,r0
80006f9e:	06 9c       	mov	r12,r3
80006fa0:	f0 1f 00 45 	mcall	800070b4 <log+0x148>
			
					if(*str == '%')
80006fa4:	0f 88       	ld.ub	r8,r7[0x0]
80006fa6:	e4 08 18 00 	cp.b	r8,r2
80006faa:	c5 71       	brne	80007058 <log+0xec>
					{
						static char lench = 0;
						lench =*(str + 1);
80006fac:	ee c8 ff ff 	sub	r8,r7,-1
80006fb0:	11 89       	ld.ub	r9,r8[0x0]
80006fb2:	4c 2a       	lddpc	r10,800070b8 <log+0x14c>
80006fb4:	b4 89       	st.b	r10[0x0],r9
						if((lench >= '0') &&  (lench <= '9'))
80006fb6:	23 09       	sub	r9,48
80006fb8:	30 9a       	mov	r10,9
80006fba:	f4 09 18 00 	cp.b	r9,r10
80006fbe:	ee 08 17 b0 	movhi	r8,r7
						{
							len = *(++str) - '0';
80006fc2:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
80006fc6:	f7 b9 08 30 	subls	r9,48
80006fca:	fb f9 8a 00 	st.wls	sp[0x0],r9
						}
						
						str++;
80006fce:	f0 c7 ff ff 	sub	r7,r8,-1
						
						switch(*(str))
80006fd2:	0f 88       	ld.ub	r8,r7[0x0]
80006fd4:	22 58       	sub	r8,37
80006fd6:	e0 48 00 53 	cp.w	r8,83
80006fda:	e0 8b 00 31 	brhi	8000703c <log+0xd0>
80006fde:	4b 89       	lddpc	r9,800070bc <log+0x150>
80006fe0:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
						{
							case('i'):
							case('I'):
							case('d'):
							case('D'):
							x = va_arg(arg_ptr,int);
80006fe4:	e8 c5 ff fc 	sub	r5,r4,-4
							strTmp = PrintDec(x, len, strTmp);
80006fe8:	06 9a       	mov	r10,r3
80006fea:	40 0b       	lddsp	r11,sp[0x0]
80006fec:	5c 5b       	castu.b	r11
80006fee:	68 0c       	ld.w	r12,r4[0x0]
80006ff0:	f0 1f 00 34 	mcall	800070c0 <log+0x154>
							break;
80006ff4:	c2 98       	rjmp	80007046 <log+0xda>
							
							case('f')://浮点数输出
							case('F'):
							//f = va_arg(arg_ptr,int);
							//strTmp = PrintDec(x, len, strTmp);
							log("I need float.");
80006ff6:	4b 4c       	lddpc	r12,800070c4 <log+0x158>
80006ff8:	f0 1f 00 34 	mcall	800070c8 <log+0x15c>
80006ffc:	08 95       	mov	r5,r4
80006ffe:	06 9c       	mov	r12,r3
							break;
80007000:	c2 38       	rjmp	80007046 <log+0xda>
							
							
							case('x'):
							case('X'):
							x = va_arg(arg_ptr,int);
80007002:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintHex(x,len, strTmp);
80007006:	06 9a       	mov	r10,r3
80007008:	40 0b       	lddsp	r11,sp[0x0]
8000700a:	5c 5b       	castu.b	r11
8000700c:	68 0c       	ld.w	r12,r4[0x0]
8000700e:	f0 1f 00 30 	mcall	800070cc <log+0x160>
80007012:	06 9c       	mov	r12,r3
							break;
80007014:	c1 98       	rjmp	80007046 <log+0xda>
							
							case('c'):
							case('C'):
							y = va_arg(arg_ptr,int);
80007016:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintChar(y, strTmp);
8000701a:	06 9b       	mov	r11,r3
8000701c:	09 bc       	ld.ub	r12,r4[0x3]
8000701e:	f0 1f 00 2d 	mcall	800070d0 <log+0x164>
80007022:	06 9c       	mov	r12,r3
							break;
80007024:	c1 18       	rjmp	80007046 <log+0xda>
							
							case('s'):
							case('S'):
							strTmp = va_arg(arg_ptr,char*);
80007026:	e8 c5 ff fc 	sub	r5,r4,-4
8000702a:	68 0c       	ld.w	r12,r4[0x0]
							//PrintStr(s);
							break;
8000702c:	c0 d8       	rjmp	80007046 <log+0xda>
							
							case('%'):
							PrintChar('%', strTmp);
8000702e:	06 9b       	mov	r11,r3
80007030:	32 5c       	mov	r12,37
80007032:	f0 1f 00 28 	mcall	800070d0 <log+0x164>
80007036:	08 95       	mov	r5,r4
80007038:	06 9c       	mov	r12,r3
							//PrintChar('%');
							break;
8000703a:	c0 68       	rjmp	80007046 <log+0xda>
							
							default:
							log("I need relax.");
8000703c:	4a 6c       	lddpc	r12,800070d4 <log+0x168>
8000703e:	f0 1f 00 23 	mcall	800070c8 <log+0x15c>
80007042:	08 95       	mov	r5,r4
80007044:	06 9c       	mov	r12,r3
						}
						str++;
80007046:	2f f7       	sub	r7,-1
						
						length = sprintf(logTmp,"%s%s",logTmp,strTmp );
80007048:	1a dc       	st.w	--sp,r12
8000704a:	1a d6       	st.w	--sp,r6
8000704c:	4a 3b       	lddpc	r11,800070d8 <log+0x16c>
8000704e:	0c 9c       	mov	r12,r6
80007050:	f0 1f 00 23 	mcall	800070dc <log+0x170>
80007054:	2f ed       	sub	sp,-8
80007056:	c0 a8       	rjmp	8000706a <log+0xfe>
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
80007058:	2f f7       	sub	r7,-1
8000705a:	1a d8       	st.w	--sp,r8
8000705c:	1a d6       	st.w	--sp,r6
8000705e:	4a 1b       	lddpc	r11,800070e0 <log+0x174>
80007060:	0c 9c       	mov	r12,r6
80007062:	f0 1f 00 1f 	mcall	800070dc <log+0x170>
80007066:	08 95       	mov	r5,r4
80007068:	2f ed       	sub	sp,-8
			
			
			
	}while(*str != '\0');
8000706a:	0f 89       	ld.ub	r9,r7[0x0]
8000706c:	30 08       	mov	r8,0
8000706e:	f0 09 18 00 	cp.b	r9,r8
80007072:	c0 30       	breq	80007078 <log+0x10c>
80007074:	0a 94       	mov	r4,r5
80007076:	c9 2b       	rjmp	80006f9a <log+0x2e>
		
		
				
	va_end(arg_ptr);
	//while(1)		
	length = sprintf(logTmp,"%s\r\n",logTmp);
80007078:	fa c7 fe f8 	sub	r7,sp,-264
8000707c:	1a d7       	st.w	--sp,r7
8000707e:	49 ab       	lddpc	r11,800070e4 <log+0x178>
80007080:	0e 9c       	mov	r12,r7
80007082:	f0 1f 00 17 	mcall	800070dc <log+0x170>
	
	char * p = pvPortMalloc(length+1);
80007086:	5c 5c       	castu.b	r12
80007088:	f8 c6 ff ff 	sub	r6,r12,-1
8000708c:	0c 9c       	mov	r12,r6
8000708e:	f0 1f 00 17 	mcall	800070e8 <log+0x17c>
80007092:	54 2c       	stdsp	sp[0x108],r12
	memcpy(p, logTmp, length+1);
80007094:	0c 9a       	mov	r10,r6
80007096:	0e 9b       	mov	r11,r7
80007098:	f0 1f 00 15 	mcall	800070ec <log+0x180>
	//
	//usart_write_line(EXAMPLE_USART, logTmp)
	
	xQueueSend( logQueue, &p, 5);
8000709c:	30 09       	mov	r9,0
8000709e:	30 5a       	mov	r10,5
800070a0:	fa cb fe f8 	sub	r11,sp,-264
800070a4:	49 38       	lddpc	r8,800070f0 <log+0x184>
800070a6:	70 0c       	ld.w	r12,r8[0x0]
800070a8:	f0 1f 00 13 	mcall	800070f4 <log+0x188>
800070ac:	2f fd       	sub	sp,-4
	
	
}
800070ae:	fe 3d fd f8 	sub	sp,-520
800070b2:	d8 32       	popm	r0-r7,pc
800070b4:	80 00       	ld.sh	r0,r0[0x0]
800070b6:	79 30       	ld.w	r0,r12[0x4c]
800070b8:	00 00       	add	r0,r0
800070ba:	0d 64       	ld.uh	r4,--r6
800070bc:	80 00       	ld.sh	r0,r0[0x0]
800070be:	da 28       	*unknown*
800070c0:	80 00       	ld.sh	r0,r0[0x0]
800070c2:	6e 92       	ld.w	r2,r7[0x24]
800070c4:	80 00       	ld.sh	r0,r0[0x0]
800070c6:	dc d4       	*unknown*
800070c8:	80 00       	ld.sh	r0,r0[0x0]
800070ca:	6f 6c       	ld.w	r12,r7[0x58]
800070cc:	80 00       	ld.sh	r0,r0[0x0]
800070ce:	6d e0       	ld.w	r0,r6[0x78]
800070d0:	80 00       	ld.sh	r0,r0[0x0]
800070d2:	6d dc       	ld.w	r12,r6[0x74]
800070d4:	80 00       	ld.sh	r0,r0[0x0]
800070d6:	dc e4       	*unknown*
800070d8:	80 00       	ld.sh	r0,r0[0x0]
800070da:	dc f4       	*unknown*
800070dc:	80 00       	ld.sh	r0,r0[0x0]
800070de:	7c 20       	ld.w	r0,lr[0x8]
800070e0:	80 00       	ld.sh	r0,r0[0x0]
800070e2:	dc fc       	*unknown*
800070e4:	80 00       	ld.sh	r0,r0[0x0]
800070e6:	dd 04       	*unknown*
800070e8:	80 00       	ld.sh	r0,r0[0x0]
800070ea:	5f e0       	srqs	r0
800070ec:	80 00       	ld.sh	r0,r0[0x0]
800070ee:	77 e8       	ld.w	r8,r11[0x78]
800070f0:	00 00       	add	r0,r0
800070f2:	65 98       	ld.w	r8,r2[0x64]
800070f4:	80 00       	ld.sh	r0,r0[0x0]
800070f6:	63 34       	ld.w	r4,r1[0x4c]

800070f8 <logFromISR>:
	
	
int logFromISR(char * content, ...)
	{
800070f8:	d4 31       	pushm	r0-r7,lr
800070fa:	fa cd 02 0c 	sub	sp,sp,524
800070fe:	18 97       	mov	r7,r12
		
		
		char logTmp[MAX_LOG_LINE_SIZE];
		memset(logTmp, '\0', MAX_LOG_LINE_SIZE);
80007100:	e0 6a 01 00 	mov	r10,256
80007104:	30 0b       	mov	r11,0
80007106:	fa cc fe f4 	sub	r12,sp,-268
8000710a:	f0 1f 00 4c 	mcall	80007238 <logFromISR+0x140>
	
	
}
	
	
int logFromISR(char * content, ...)
8000710e:	fa c4 fd d0 	sub	r4,sp,-560
80007112:	30 0a       	mov	r10,0
80007114:	50 0a       	stdsp	sp[0x0],r10
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80007116:	fa c3 ff fc 	sub	r3,sp,-4
8000711a:	e0 61 01 00 	mov	r1,256
8000711e:	14 90       	mov	r0,r10
			
			if(*str == '%')
80007120:	32 52       	mov	r2,37
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
80007122:	fa c6 fe f4 	sub	r6,sp,-268
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80007126:	02 9a       	mov	r10,r1
80007128:	00 9b       	mov	r11,r0
8000712a:	06 9c       	mov	r12,r3
8000712c:	f0 1f 00 43 	mcall	80007238 <logFromISR+0x140>
			
			if(*str == '%')
80007130:	0f 88       	ld.ub	r8,r7[0x0]
80007132:	e4 08 18 00 	cp.b	r8,r2
80007136:	c5 11       	brne	800071d8 <logFromISR+0xe0>
			{
				static char lench = 0;
				lench =*(str + 1);
80007138:	ee c8 ff ff 	sub	r8,r7,-1
8000713c:	11 89       	ld.ub	r9,r8[0x0]
8000713e:	4c 0a       	lddpc	r10,8000723c <logFromISR+0x144>
80007140:	b4 89       	st.b	r10[0x0],r9
				if((lench >= '0') &&  (lench <= '9'))
80007142:	23 09       	sub	r9,48
80007144:	30 9a       	mov	r10,9
80007146:	f4 09 18 00 	cp.b	r9,r10
8000714a:	ee 08 17 b0 	movhi	r8,r7
				{
					len = *(++str) - '0';
8000714e:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
80007152:	f7 b9 08 30 	subls	r9,48
80007156:	fb f9 8a 00 	st.wls	sp[0x0],r9
				}
				
				str++;
8000715a:	f0 c7 ff ff 	sub	r7,r8,-1
				
				switch(*(str))
8000715e:	0f 88       	ld.ub	r8,r7[0x0]
80007160:	22 58       	sub	r8,37
80007162:	e0 48 00 53 	cp.w	r8,83
80007166:	e0 8b 00 2b 	brhi	800071bc <logFromISR+0xc4>
8000716a:	4b 69       	lddpc	r9,80007240 <logFromISR+0x148>
8000716c:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
				{
					case('d'):
					case('D'):
					x = va_arg(arg_ptr,int);
80007170:	e8 c5 ff fc 	sub	r5,r4,-4
					strTmp = PrintDec(x, len, strTmp);
80007174:	06 9a       	mov	r10,r3
80007176:	40 0b       	lddsp	r11,sp[0x0]
80007178:	5c 5b       	castu.b	r11
8000717a:	68 0c       	ld.w	r12,r4[0x0]
8000717c:	f0 1f 00 32 	mcall	80007244 <logFromISR+0x14c>
					break;
80007180:	c2 38       	rjmp	800071c6 <logFromISR+0xce>
					case('x'):
					case('X'):
					x = va_arg(arg_ptr,int);
80007182:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintHex(x,len, strTmp);
80007186:	06 9a       	mov	r10,r3
80007188:	40 0b       	lddsp	r11,sp[0x0]
8000718a:	5c 5b       	castu.b	r11
8000718c:	68 0c       	ld.w	r12,r4[0x0]
8000718e:	f0 1f 00 2f 	mcall	80007248 <logFromISR+0x150>
80007192:	06 9c       	mov	r12,r3
					break;
80007194:	c1 98       	rjmp	800071c6 <logFromISR+0xce>
					case('c'):
					case('C'):
					y = va_arg(arg_ptr,int);
80007196:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintChar(y, strTmp);
8000719a:	06 9b       	mov	r11,r3
8000719c:	09 bc       	ld.ub	r12,r4[0x3]
8000719e:	f0 1f 00 2c 	mcall	8000724c <logFromISR+0x154>
800071a2:	06 9c       	mov	r12,r3
					break;
800071a4:	c1 18       	rjmp	800071c6 <logFromISR+0xce>
					case('s'):
					case('S'):
					strTmp = va_arg(arg_ptr,char*);
800071a6:	e8 c5 ff fc 	sub	r5,r4,-4
800071aa:	68 0c       	ld.w	r12,r4[0x0]
					//PrintStr(s);
					break;
800071ac:	c0 d8       	rjmp	800071c6 <logFromISR+0xce>
					case('%'):
					PrintChar('%', strTmp);
800071ae:	06 9b       	mov	r11,r3
800071b0:	32 5c       	mov	r12,37
800071b2:	f0 1f 00 27 	mcall	8000724c <logFromISR+0x154>
800071b6:	08 95       	mov	r5,r4
800071b8:	06 9c       	mov	r12,r3
					//PrintChar('%');
					break;
800071ba:	c0 68       	rjmp	800071c6 <logFromISR+0xce>
					default:
					log("I need relax.");
800071bc:	4a 5c       	lddpc	r12,80007250 <logFromISR+0x158>
800071be:	f0 1f 00 26 	mcall	80007254 <logFromISR+0x15c>
800071c2:	08 95       	mov	r5,r4
800071c4:	06 9c       	mov	r12,r3
				}
				str++;
800071c6:	2f f7       	sub	r7,-1
				
				length = sprintf(logTmp,"%s%s",logTmp,strTmp );
800071c8:	1a dc       	st.w	--sp,r12
800071ca:	1a d6       	st.w	--sp,r6
800071cc:	4a 3b       	lddpc	r11,80007258 <logFromISR+0x160>
800071ce:	0c 9c       	mov	r12,r6
800071d0:	f0 1f 00 23 	mcall	8000725c <logFromISR+0x164>
800071d4:	2f ed       	sub	sp,-8
800071d6:	c0 a8       	rjmp	800071ea <logFromISR+0xf2>
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
800071d8:	2f f7       	sub	r7,-1
800071da:	1a d8       	st.w	--sp,r8
800071dc:	1a d6       	st.w	--sp,r6
800071de:	4a 1b       	lddpc	r11,80007260 <logFromISR+0x168>
800071e0:	0c 9c       	mov	r12,r6
800071e2:	f0 1f 00 1f 	mcall	8000725c <logFromISR+0x164>
800071e6:	08 95       	mov	r5,r4
800071e8:	2f ed       	sub	sp,-8
			
			
			
		}while(*str != '\0');
800071ea:	0f 89       	ld.ub	r9,r7[0x0]
800071ec:	30 08       	mov	r8,0
800071ee:	f0 09 18 00 	cp.b	r9,r8
800071f2:	c0 30       	breq	800071f8 <logFromISR+0x100>
800071f4:	0a 94       	mov	r4,r5
800071f6:	c9 8b       	rjmp	80007126 <logFromISR+0x2e>
		
		
		
		va_end(arg_ptr);
		//while(1)
		length = sprintf(logTmp,"%s\r\n",logTmp);
800071f8:	fa c7 fe f4 	sub	r7,sp,-268
800071fc:	1a d7       	st.w	--sp,r7
800071fe:	49 ab       	lddpc	r11,80007264 <logFromISR+0x16c>
80007200:	0e 9c       	mov	r12,r7
80007202:	f0 1f 00 17 	mcall	8000725c <logFromISR+0x164>
		
		char * p = pvPortMalloc(length+1);
80007206:	5c 5c       	castu.b	r12
80007208:	f8 c6 ff ff 	sub	r6,r12,-1
8000720c:	0c 9c       	mov	r12,r6
8000720e:	f0 1f 00 17 	mcall	80007268 <logFromISR+0x170>
80007212:	54 3c       	stdsp	sp[0x10c],r12
		memcpy(p, logTmp, length+1);
80007214:	0c 9a       	mov	r10,r6
80007216:	0e 9b       	mov	r11,r7
80007218:	f0 1f 00 15 	mcall	8000726c <logFromISR+0x174>
		//
		portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
8000721c:	30 09       	mov	r9,0
8000721e:	54 29       	stdsp	sp[0x108],r9
		
		//usart_write_line(EXAMPLE_USART, p);
		//vPortFree(p);
		xQueueSendFromISR( logQueue, &p, &xHigherPriorityTaskWoken );
80007220:	fa ca fe f8 	sub	r10,sp,-264
80007224:	fa cb fe f4 	sub	r11,sp,-268
80007228:	49 28       	lddpc	r8,80007270 <logFromISR+0x178>
8000722a:	70 0c       	ld.w	r12,r8[0x0]
8000722c:	f0 1f 00 12 	mcall	80007274 <logFromISR+0x17c>
80007230:	2f fd       	sub	sp,-4
		
		//if (xHigherPriorityTaskWoken == pdTRUE)
		//{
			////taskYIELD();
		//}
	}
80007232:	fe 3d fd f4 	sub	sp,-524
80007236:	d8 32       	popm	r0-r7,pc
80007238:	80 00       	ld.sh	r0,r0[0x0]
8000723a:	79 30       	ld.w	r0,r12[0x4c]
8000723c:	00 00       	add	r0,r0
8000723e:	0d 65       	ld.uh	r5,--r6
80007240:	80 00       	ld.sh	r0,r0[0x0]
80007242:	db 78       	*unknown*
80007244:	80 00       	ld.sh	r0,r0[0x0]
80007246:	6e 92       	ld.w	r2,r7[0x24]
80007248:	80 00       	ld.sh	r0,r0[0x0]
8000724a:	6d e0       	ld.w	r0,r6[0x78]
8000724c:	80 00       	ld.sh	r0,r0[0x0]
8000724e:	6d dc       	ld.w	r12,r6[0x74]
80007250:	80 00       	ld.sh	r0,r0[0x0]
80007252:	dc e4       	*unknown*
80007254:	80 00       	ld.sh	r0,r0[0x0]
80007256:	6f 6c       	ld.w	r12,r7[0x58]
80007258:	80 00       	ld.sh	r0,r0[0x0]
8000725a:	dc f4       	*unknown*
8000725c:	80 00       	ld.sh	r0,r0[0x0]
8000725e:	7c 20       	ld.w	r0,lr[0x8]
80007260:	80 00       	ld.sh	r0,r0[0x0]
80007262:	dc fc       	*unknown*
80007264:	80 00       	ld.sh	r0,r0[0x0]
80007266:	dd 04       	*unknown*
80007268:	80 00       	ld.sh	r0,r0[0x0]
8000726a:	5f e0       	srqs	r0
8000726c:	80 00       	ld.sh	r0,r0[0x0]
8000726e:	77 e8       	ld.w	r8,r11[0x78]
80007270:	00 00       	add	r0,r0
80007272:	65 98       	ld.w	r8,r2[0x64]
80007274:	80 00       	ld.sh	r0,r0[0x0]
80007276:	62 e4       	ld.w	r4,r1[0x38]

80007278 <log_init>:
		
	return str;
}

void log_init(void)
{
80007278:	d4 01       	pushm	lr
		.stopbits     = USART_1_STOPBIT,
		.channelmode  = USART_NORMAL_CHMODE
	};

	// Assign GPIO to USART.
	gpio_enable_module(USART_GPIO_MAP,
8000727a:	30 2b       	mov	r11,2
8000727c:	48 fc       	lddpc	r12,800072b8 <log_init+0x40>
8000727e:	f0 1f 00 10 	mcall	800072bc <log_init+0x44>
	sizeof(USART_GPIO_MAP) / sizeof(USART_GPIO_MAP[0]));

	// Initialize USART in RS232 mode.
	usart_init_rs232(EXAMPLE_USART, &USART_OPTIONS, EXAMPLE_TARGET_PBACLK_FREQ_HZ);			
80007282:	e0 6a 36 00 	mov	r10,13824
80007286:	ea 1a 01 6e 	orh	r10,0x16e
8000728a:	48 eb       	lddpc	r11,800072c0 <log_init+0x48>
8000728c:	fe 7c 18 00 	mov	r12,-59392
80007290:	f0 1f 00 0d 	mcall	800072c4 <log_init+0x4c>
			
	logQueue  = xQueueCreate(50, sizeof(char *));
80007294:	30 4b       	mov	r11,4
80007296:	33 2c       	mov	r12,50
80007298:	f0 1f 00 0c 	mcall	800072c8 <log_init+0x50>
8000729c:	48 c8       	lddpc	r8,800072cc <log_init+0x54>
8000729e:	91 0c       	st.w	r8[0x0],r12
	
	xTaskCreate(
800072a0:	30 09       	mov	r9,0
800072a2:	1a d9       	st.w	--sp,r9
800072a4:	1a d9       	st.w	--sp,r9
800072a6:	1a d9       	st.w	--sp,r9
800072a8:	30 28       	mov	r8,2
800072aa:	36 4a       	mov	r10,100
800072ac:	48 9b       	lddpc	r11,800072d0 <log_init+0x58>
800072ae:	48 ac       	lddpc	r12,800072d4 <log_init+0x5c>
800072b0:	f0 1f 00 0a 	mcall	800072d8 <log_init+0x60>
800072b4:	2f dd       	sub	sp,-12
	,  100//384
	,  NULL
	,  tskLOG_PRIORITY
	,  NULL );
	
}
800072b6:	d8 02       	popm	pc
800072b8:	80 00       	ld.sh	r0,r0[0x0]
800072ba:	dd 10       	acall	0xd1
800072bc:	80 00       	ld.sh	r0,r0[0x0]
800072be:	54 c0       	stdsp	sp[0x130],r0
800072c0:	80 00       	ld.sh	r0,r0[0x0]
800072c2:	dc c8       	*unknown*
800072c4:	80 00       	ld.sh	r0,r0[0x0]
800072c6:	5b 44       	cp.w	r4,-12
800072c8:	80 00       	ld.sh	r0,r0[0x0]
800072ca:	64 8c       	ld.w	r12,r2[0x20]
800072cc:	00 00       	add	r0,r0
800072ce:	65 98       	ld.w	r8,r2[0x64]
800072d0:	80 00       	ld.sh	r0,r0[0x0]
800072d2:	dd 0c       	*unknown*
800072d4:	80 00       	ld.sh	r0,r0[0x0]
800072d6:	72 dc       	ld.w	r12,r9[0x34]
800072d8:	80 00       	ld.sh	r0,r0[0x0]
800072da:	6b a8       	ld.w	r8,r5[0x68]

800072dc <task_log>:
			////taskYIELD();
		//}
	}
//portTickType log_water_value =0;	
static void task_log(void * pvParameters)
{
800072dc:	eb cd 40 f8 	pushm	r3-r7,lr
800072e0:	20 1d       	sub	sp,4
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		//log_water_value = uxTaskGetStackHighWaterMark(NULL);
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
800072e2:	48 c7       	lddpc	r7,80007310 <task_log+0x34>
800072e4:	30 05       	mov	r5,0
800072e6:	3f f4       	mov	r4,-1
		{
			if( NULL != str)
			{
				usart_write_line(EXAMPLE_USART, str);
800072e8:	fe 73 18 00 	mov	r3,-59392
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		//log_water_value = uxTaskGetStackHighWaterMark(NULL);
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
800072ec:	0a 99       	mov	r9,r5
800072ee:	08 9a       	mov	r10,r4
800072f0:	1a 9b       	mov	r11,sp
800072f2:	6e 0c       	ld.w	r12,r7[0x0]
800072f4:	f0 1f 00 08 	mcall	80007314 <task_log+0x38>
800072f8:	58 1c       	cp.w	r12,1
800072fa:	cf 91       	brne	800072ec <task_log+0x10>
		{
			if( NULL != str)
800072fc:	40 0b       	lddsp	r11,sp[0x0]
800072fe:	58 0b       	cp.w	r11,0
80007300:	cf 60       	breq	800072ec <task_log+0x10>
			{
				usart_write_line(EXAMPLE_USART, str);
80007302:	06 9c       	mov	r12,r3
80007304:	f0 1f 00 05 	mcall	80007318 <task_log+0x3c>
				vPortFree(str);
80007308:	40 0c       	lddsp	r12,sp[0x0]
8000730a:	f0 1f 00 05 	mcall	8000731c <task_log+0x40>
8000730e:	ce fb       	rjmp	800072ec <task_log+0x10>
80007310:	00 00       	add	r0,r0
80007312:	65 98       	ld.w	r8,r2[0x64]
80007314:	80 00       	ld.sh	r0,r0[0x0]
80007316:	61 28       	ld.w	r8,r0[0x48]
80007318:	80 00       	ld.sh	r0,r0[0x0]
8000731a:	5a f4       	cp.w	r4,-17
8000731c:	80 00       	ld.sh	r0,r0[0x0]
8000731e:	5f b8       	srhi	r8

80007320 <main>:
#include "xgflash.h"
#include "app.h"


int main (void)
{
80007320:	d4 01       	pushm	lr
	
	//Force SSC_TX_DATA_ENABLE Disabled as soon as possible.
	AVR32_GPIO.port[1].ovrs  =  0x00000001;  //Value will be high.
80007322:	fe 78 10 00 	mov	r8,-61440
80007326:	30 19       	mov	r9,1
80007328:	f1 49 01 54 	st.w	r8[340],r9
	AVR32_GPIO.port[1].oders =  0x00000001;  //Output Driver will be Enabled.
8000732c:	f1 49 01 44 	st.w	r8[324],r9
	AVR32_GPIO.port[1].gpers =  0x00000001;  //Enable as GPIO.
80007330:	f1 49 01 04 	st.w	r8[260],r9
		
	Disable_global_interrupt();
80007334:	d3 03       	ssrf	0x10
	local_start_pll0();
80007336:	f0 1f 00 0c 	mcall	80007364 <main+0x44>
		
	INTC_init_interrupts();
8000733a:	f0 1f 00 0c 	mcall	80007368 <main+0x48>
		
	log_init();
8000733e:	f0 1f 00 0c 	mcall	8000736c <main+0x4c>
	log("----start debug----");
80007342:	48 cc       	lddpc	r12,80007370 <main+0x50>
80007344:	f0 1f 00 0c 	mcall	80007374 <main+0x54>
	
	xg_flashc_init();
80007348:	f0 1f 00 0c 	mcall	80007378 <main+0x58>
		
	//voc_init();

	//tc_init();
	
	rfid_init();
8000734c:	f0 1f 00 0c 	mcall	8000737c <main+0x5c>
		
	app_init();
80007350:	f0 1f 00 0c 	mcall	80007380 <main+0x60>
	
	//xg_rtc_init();
		
	xcmp_init();
80007354:	f0 1f 00 0c 	mcall	80007384 <main+0x64>

	local_start_timer();
80007358:	f0 1f 00 0c 	mcall	80007388 <main+0x68>
		
	vTaskStartScheduler();
8000735c:	f0 1f 00 0c 	mcall	8000738c <main+0x6c>
	return 0;
	
}
80007360:	d8 0a       	popm	pc,r12=0
80007362:	00 00       	add	r0,r0
80007364:	80 00       	ld.sh	r0,r0[0x0]
80007366:	53 40       	stdsp	sp[0xd0],r0
80007368:	80 00       	ld.sh	r0,r0[0x0]
8000736a:	55 c4       	stdsp	sp[0x170],r4
8000736c:	80 00       	ld.sh	r0,r0[0x0]
8000736e:	72 78       	ld.w	r8,r9[0x1c]
80007370:	80 00       	ld.sh	r0,r0[0x0]
80007372:	dd 20       	acall	0xd2
80007374:	80 00       	ld.sh	r0,r0[0x0]
80007376:	6f 6c       	ld.w	r12,r7[0x58]
80007378:	80 00       	ld.sh	r0,r0[0x0]
8000737a:	53 d4       	stdsp	sp[0xf4],r4
8000737c:	80 00       	ld.sh	r0,r0[0x0]
8000737e:	52 a0       	stdsp	sp[0xa8],r0
80007380:	80 00       	ld.sh	r0,r0[0x0]
80007382:	27 34       	sub	r4,115
80007384:	80 00       	ld.sh	r0,r0[0x0]
80007386:	40 a4       	lddsp	r4,sp[0x28]
80007388:	80 00       	ld.sh	r0,r0[0x0]
8000738a:	53 14       	stdsp	sp[0xc4],r4
8000738c:	80 00       	ld.sh	r0,r0[0x0]
8000738e:	6d 90       	ld.w	r0,r6[0x64]

80007390 <free>:
80007390:	d4 01       	pushm	lr
80007392:	e0 68 0a 3c 	mov	r8,2620
80007396:	18 9b       	mov	r11,r12
80007398:	70 0c       	ld.w	r12,r8[0x0]
8000739a:	e0 a0 1e 61 	rcall	8000b05c <_free_r>
8000739e:	d8 02       	popm	pc

800073a0 <malloc>:
800073a0:	d4 01       	pushm	lr
800073a2:	e0 68 0a 3c 	mov	r8,2620
800073a6:	18 9b       	mov	r11,r12
800073a8:	70 0c       	ld.w	r12,r8[0x0]
800073aa:	c0 3c       	rcall	800073b0 <_malloc_r>
800073ac:	d8 02       	popm	pc
800073ae:	d7 03       	nop

800073b0 <_malloc_r>:
800073b0:	d4 31       	pushm	r0-r7,lr
800073b2:	f6 c8 ff f5 	sub	r8,r11,-11
800073b6:	18 95       	mov	r5,r12
800073b8:	10 97       	mov	r7,r8
800073ba:	e0 17 ff f8 	andl	r7,0xfff8
800073be:	59 68       	cp.w	r8,22
800073c0:	f9 b7 08 10 	movls	r7,16
800073c4:	16 37       	cp.w	r7,r11
800073c6:	5f 38       	srlo	r8
800073c8:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
800073cc:	c0 50       	breq	800073d6 <_malloc_r+0x26>
800073ce:	30 c8       	mov	r8,12
800073d0:	99 38       	st.w	r12[0xc],r8
800073d2:	e0 8f 01 fa 	bral	800077c6 <_malloc_r+0x416>
800073d6:	fe b0 f5 a7 	rcall	80005f24 <__malloc_lock>
800073da:	e0 47 01 f7 	cp.w	r7,503
800073de:	e0 8b 00 1d 	brhi	80007418 <_malloc_r+0x68>
800073e2:	ee 03 16 03 	lsr	r3,r7,0x3
800073e6:	e0 68 05 3c 	mov	r8,1340
800073ea:	f0 03 00 38 	add	r8,r8,r3<<0x3
800073ee:	70 36       	ld.w	r6,r8[0xc]
800073f0:	10 36       	cp.w	r6,r8
800073f2:	c0 61       	brne	800073fe <_malloc_r+0x4e>
800073f4:	ec c8 ff f8 	sub	r8,r6,-8
800073f8:	70 36       	ld.w	r6,r8[0xc]
800073fa:	10 36       	cp.w	r6,r8
800073fc:	c0 c0       	breq	80007414 <_malloc_r+0x64>
800073fe:	6c 18       	ld.w	r8,r6[0x4]
80007400:	e0 18 ff fc 	andl	r8,0xfffc
80007404:	6c 3a       	ld.w	r10,r6[0xc]
80007406:	ec 08 00 09 	add	r9,r6,r8
8000740a:	0a 9c       	mov	r12,r5
8000740c:	6c 28       	ld.w	r8,r6[0x8]
8000740e:	95 28       	st.w	r10[0x8],r8
80007410:	91 3a       	st.w	r8[0xc],r10
80007412:	c4 78       	rjmp	800074a0 <_malloc_r+0xf0>
80007414:	2f e3       	sub	r3,-2
80007416:	c4 d8       	rjmp	800074b0 <_malloc_r+0x100>
80007418:	ee 03 16 09 	lsr	r3,r7,0x9
8000741c:	c0 41       	brne	80007424 <_malloc_r+0x74>
8000741e:	ee 03 16 03 	lsr	r3,r7,0x3
80007422:	c2 68       	rjmp	8000746e <_malloc_r+0xbe>
80007424:	58 43       	cp.w	r3,4
80007426:	e0 8b 00 06 	brhi	80007432 <_malloc_r+0x82>
8000742a:	ee 03 16 06 	lsr	r3,r7,0x6
8000742e:	2c 83       	sub	r3,-56
80007430:	c1 f8       	rjmp	8000746e <_malloc_r+0xbe>
80007432:	59 43       	cp.w	r3,20
80007434:	e0 8b 00 04 	brhi	8000743c <_malloc_r+0x8c>
80007438:	2a 53       	sub	r3,-91
8000743a:	c1 a8       	rjmp	8000746e <_malloc_r+0xbe>
8000743c:	e0 43 00 54 	cp.w	r3,84
80007440:	e0 8b 00 06 	brhi	8000744c <_malloc_r+0x9c>
80007444:	ee 03 16 0c 	lsr	r3,r7,0xc
80007448:	29 23       	sub	r3,-110
8000744a:	c1 28       	rjmp	8000746e <_malloc_r+0xbe>
8000744c:	e0 43 01 54 	cp.w	r3,340
80007450:	e0 8b 00 06 	brhi	8000745c <_malloc_r+0xac>
80007454:	ee 03 16 0f 	lsr	r3,r7,0xf
80007458:	28 93       	sub	r3,-119
8000745a:	c0 a8       	rjmp	8000746e <_malloc_r+0xbe>
8000745c:	e0 43 05 54 	cp.w	r3,1364
80007460:	e0 88 00 04 	brls	80007468 <_malloc_r+0xb8>
80007464:	37 e3       	mov	r3,126
80007466:	c0 48       	rjmp	8000746e <_malloc_r+0xbe>
80007468:	ee 03 16 12 	lsr	r3,r7,0x12
8000746c:	28 43       	sub	r3,-124
8000746e:	e0 6a 05 3c 	mov	r10,1340
80007472:	f4 03 00 3a 	add	r10,r10,r3<<0x3
80007476:	74 36       	ld.w	r6,r10[0xc]
80007478:	c1 98       	rjmp	800074aa <_malloc_r+0xfa>
8000747a:	6c 19       	ld.w	r9,r6[0x4]
8000747c:	e0 19 ff fc 	andl	r9,0xfffc
80007480:	f2 07 01 0b 	sub	r11,r9,r7
80007484:	58 fb       	cp.w	r11,15
80007486:	e0 8a 00 04 	brle	8000748e <_malloc_r+0xde>
8000748a:	20 13       	sub	r3,1
8000748c:	c1 18       	rjmp	800074ae <_malloc_r+0xfe>
8000748e:	6c 38       	ld.w	r8,r6[0xc]
80007490:	58 0b       	cp.w	r11,0
80007492:	c0 b5       	brlt	800074a8 <_malloc_r+0xf8>
80007494:	6c 2a       	ld.w	r10,r6[0x8]
80007496:	ec 09 00 09 	add	r9,r6,r9
8000749a:	0a 9c       	mov	r12,r5
8000749c:	91 2a       	st.w	r8[0x8],r10
8000749e:	95 38       	st.w	r10[0xc],r8
800074a0:	72 18       	ld.w	r8,r9[0x4]
800074a2:	a1 a8       	sbr	r8,0x0
800074a4:	93 18       	st.w	r9[0x4],r8
800074a6:	cb c8       	rjmp	8000761e <_malloc_r+0x26e>
800074a8:	10 96       	mov	r6,r8
800074aa:	14 36       	cp.w	r6,r10
800074ac:	ce 71       	brne	8000747a <_malloc_r+0xca>
800074ae:	2f f3       	sub	r3,-1
800074b0:	e0 6a 05 3c 	mov	r10,1340
800074b4:	f4 cc ff f8 	sub	r12,r10,-8
800074b8:	78 26       	ld.w	r6,r12[0x8]
800074ba:	18 36       	cp.w	r6,r12
800074bc:	c6 c0       	breq	80007594 <_malloc_r+0x1e4>
800074be:	6c 19       	ld.w	r9,r6[0x4]
800074c0:	e0 19 ff fc 	andl	r9,0xfffc
800074c4:	f2 07 01 08 	sub	r8,r9,r7
800074c8:	58 f8       	cp.w	r8,15
800074ca:	e0 89 00 8f 	brgt	800075e8 <_malloc_r+0x238>
800074ce:	99 3c       	st.w	r12[0xc],r12
800074d0:	99 2c       	st.w	r12[0x8],r12
800074d2:	58 08       	cp.w	r8,0
800074d4:	c0 55       	brlt	800074de <_malloc_r+0x12e>
800074d6:	ec 09 00 09 	add	r9,r6,r9
800074da:	0a 9c       	mov	r12,r5
800074dc:	ce 2b       	rjmp	800074a0 <_malloc_r+0xf0>
800074de:	e0 49 01 ff 	cp.w	r9,511
800074e2:	e0 8b 00 13 	brhi	80007508 <_malloc_r+0x158>
800074e6:	a3 99       	lsr	r9,0x3
800074e8:	f4 09 00 38 	add	r8,r10,r9<<0x3
800074ec:	70 2b       	ld.w	r11,r8[0x8]
800074ee:	8d 38       	st.w	r6[0xc],r8
800074f0:	8d 2b       	st.w	r6[0x8],r11
800074f2:	97 36       	st.w	r11[0xc],r6
800074f4:	91 26       	st.w	r8[0x8],r6
800074f6:	a3 49       	asr	r9,0x2
800074f8:	74 18       	ld.w	r8,r10[0x4]
800074fa:	30 1b       	mov	r11,1
800074fc:	f6 09 09 49 	lsl	r9,r11,r9
80007500:	f1 e9 10 09 	or	r9,r8,r9
80007504:	95 19       	st.w	r10[0x4],r9
80007506:	c4 78       	rjmp	80007594 <_malloc_r+0x1e4>
80007508:	f2 0a 16 09 	lsr	r10,r9,0x9
8000750c:	58 4a       	cp.w	r10,4
8000750e:	e0 8b 00 07 	brhi	8000751c <_malloc_r+0x16c>
80007512:	f2 0a 16 06 	lsr	r10,r9,0x6
80007516:	2c 8a       	sub	r10,-56
80007518:	c2 08       	rjmp	80007558 <_malloc_r+0x1a8>
8000751a:	d7 03       	nop
8000751c:	59 4a       	cp.w	r10,20
8000751e:	e0 8b 00 04 	brhi	80007526 <_malloc_r+0x176>
80007522:	2a 5a       	sub	r10,-91
80007524:	c1 a8       	rjmp	80007558 <_malloc_r+0x1a8>
80007526:	e0 4a 00 54 	cp.w	r10,84
8000752a:	e0 8b 00 06 	brhi	80007536 <_malloc_r+0x186>
8000752e:	f2 0a 16 0c 	lsr	r10,r9,0xc
80007532:	29 2a       	sub	r10,-110
80007534:	c1 28       	rjmp	80007558 <_malloc_r+0x1a8>
80007536:	e0 4a 01 54 	cp.w	r10,340
8000753a:	e0 8b 00 06 	brhi	80007546 <_malloc_r+0x196>
8000753e:	f2 0a 16 0f 	lsr	r10,r9,0xf
80007542:	28 9a       	sub	r10,-119
80007544:	c0 a8       	rjmp	80007558 <_malloc_r+0x1a8>
80007546:	e0 4a 05 54 	cp.w	r10,1364
8000754a:	e0 88 00 04 	brls	80007552 <_malloc_r+0x1a2>
8000754e:	37 ea       	mov	r10,126
80007550:	c0 48       	rjmp	80007558 <_malloc_r+0x1a8>
80007552:	f2 0a 16 12 	lsr	r10,r9,0x12
80007556:	28 4a       	sub	r10,-124
80007558:	e0 6b 05 3c 	mov	r11,1340
8000755c:	f6 0a 00 34 	add	r4,r11,r10<<0x3
80007560:	68 28       	ld.w	r8,r4[0x8]
80007562:	08 38       	cp.w	r8,r4
80007564:	c0 e1       	brne	80007580 <_malloc_r+0x1d0>
80007566:	76 19       	ld.w	r9,r11[0x4]
80007568:	a3 4a       	asr	r10,0x2
8000756a:	30 1e       	mov	lr,1
8000756c:	fc 0a 09 4a 	lsl	r10,lr,r10
80007570:	f3 ea 10 0a 	or	r10,r9,r10
80007574:	10 99       	mov	r9,r8
80007576:	97 1a       	st.w	r11[0x4],r10
80007578:	c0 a8       	rjmp	8000758c <_malloc_r+0x1dc>
8000757a:	70 28       	ld.w	r8,r8[0x8]
8000757c:	08 38       	cp.w	r8,r4
8000757e:	c0 60       	breq	8000758a <_malloc_r+0x1da>
80007580:	70 1a       	ld.w	r10,r8[0x4]
80007582:	e0 1a ff fc 	andl	r10,0xfffc
80007586:	14 39       	cp.w	r9,r10
80007588:	cf 93       	brcs	8000757a <_malloc_r+0x1ca>
8000758a:	70 39       	ld.w	r9,r8[0xc]
8000758c:	8d 39       	st.w	r6[0xc],r9
8000758e:	8d 28       	st.w	r6[0x8],r8
80007590:	91 36       	st.w	r8[0xc],r6
80007592:	93 26       	st.w	r9[0x8],r6
80007594:	e6 08 14 02 	asr	r8,r3,0x2
80007598:	30 1b       	mov	r11,1
8000759a:	e0 64 05 3c 	mov	r4,1340
8000759e:	f6 08 09 4b 	lsl	r11,r11,r8
800075a2:	68 18       	ld.w	r8,r4[0x4]
800075a4:	10 3b       	cp.w	r11,r8
800075a6:	e0 8b 00 6b 	brhi	8000767c <_malloc_r+0x2cc>
800075aa:	f7 e8 00 09 	and	r9,r11,r8
800075ae:	c0 b1       	brne	800075c4 <_malloc_r+0x214>
800075b0:	e0 13 ff fc 	andl	r3,0xfffc
800075b4:	a1 7b       	lsl	r11,0x1
800075b6:	2f c3       	sub	r3,-4
800075b8:	c0 38       	rjmp	800075be <_malloc_r+0x20e>
800075ba:	2f c3       	sub	r3,-4
800075bc:	a1 7b       	lsl	r11,0x1
800075be:	f7 e8 00 09 	and	r9,r11,r8
800075c2:	cf c0       	breq	800075ba <_malloc_r+0x20a>
800075c4:	e8 03 00 3e 	add	lr,r4,r3<<0x3
800075c8:	06 92       	mov	r2,r3
800075ca:	1c 91       	mov	r1,lr
800075cc:	62 36       	ld.w	r6,r1[0xc]
800075ce:	c2 e8       	rjmp	8000762a <_malloc_r+0x27a>
800075d0:	6c 1a       	ld.w	r10,r6[0x4]
800075d2:	e0 1a ff fc 	andl	r10,0xfffc
800075d6:	f4 07 01 08 	sub	r8,r10,r7
800075da:	58 f8       	cp.w	r8,15
800075dc:	e0 8a 00 15 	brle	80007606 <_malloc_r+0x256>
800075e0:	6c 3a       	ld.w	r10,r6[0xc]
800075e2:	6c 29       	ld.w	r9,r6[0x8]
800075e4:	95 29       	st.w	r10[0x8],r9
800075e6:	93 3a       	st.w	r9[0xc],r10
800075e8:	0e 99       	mov	r9,r7
800075ea:	ec 07 00 07 	add	r7,r6,r7
800075ee:	a1 a9       	sbr	r9,0x0
800075f0:	99 37       	st.w	r12[0xc],r7
800075f2:	99 27       	st.w	r12[0x8],r7
800075f4:	8d 19       	st.w	r6[0x4],r9
800075f6:	ee 08 09 08 	st.w	r7[r8],r8
800075fa:	8f 2c       	st.w	r7[0x8],r12
800075fc:	8f 3c       	st.w	r7[0xc],r12
800075fe:	a1 a8       	sbr	r8,0x0
80007600:	0a 9c       	mov	r12,r5
80007602:	8f 18       	st.w	r7[0x4],r8
80007604:	c0 d8       	rjmp	8000761e <_malloc_r+0x26e>
80007606:	6c 39       	ld.w	r9,r6[0xc]
80007608:	58 08       	cp.w	r8,0
8000760a:	c0 f5       	brlt	80007628 <_malloc_r+0x278>
8000760c:	ec 0a 00 0a 	add	r10,r6,r10
80007610:	74 18       	ld.w	r8,r10[0x4]
80007612:	a1 a8       	sbr	r8,0x0
80007614:	0a 9c       	mov	r12,r5
80007616:	95 18       	st.w	r10[0x4],r8
80007618:	6c 28       	ld.w	r8,r6[0x8]
8000761a:	93 28       	st.w	r9[0x8],r8
8000761c:	91 39       	st.w	r8[0xc],r9
8000761e:	fe b0 f4 89 	rcall	80005f30 <__malloc_unlock>
80007622:	ec cc ff f8 	sub	r12,r6,-8
80007626:	d8 32       	popm	r0-r7,pc
80007628:	12 96       	mov	r6,r9
8000762a:	02 36       	cp.w	r6,r1
8000762c:	cd 21       	brne	800075d0 <_malloc_r+0x220>
8000762e:	2f f2       	sub	r2,-1
80007630:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
80007634:	c0 30       	breq	8000763a <_malloc_r+0x28a>
80007636:	2f 81       	sub	r1,-8
80007638:	cc ab       	rjmp	800075cc <_malloc_r+0x21c>
8000763a:	1c 98       	mov	r8,lr
8000763c:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
80007640:	c0 81       	brne	80007650 <_malloc_r+0x2a0>
80007642:	68 19       	ld.w	r9,r4[0x4]
80007644:	f6 08 11 ff 	rsub	r8,r11,-1
80007648:	f3 e8 00 08 	and	r8,r9,r8
8000764c:	89 18       	st.w	r4[0x4],r8
8000764e:	c0 78       	rjmp	8000765c <_malloc_r+0x2ac>
80007650:	f0 c9 00 08 	sub	r9,r8,8
80007654:	20 13       	sub	r3,1
80007656:	70 08       	ld.w	r8,r8[0x0]
80007658:	12 38       	cp.w	r8,r9
8000765a:	cf 10       	breq	8000763c <_malloc_r+0x28c>
8000765c:	a1 7b       	lsl	r11,0x1
8000765e:	68 18       	ld.w	r8,r4[0x4]
80007660:	10 3b       	cp.w	r11,r8
80007662:	e0 8b 00 0d 	brhi	8000767c <_malloc_r+0x2cc>
80007666:	58 0b       	cp.w	r11,0
80007668:	c0 a0       	breq	8000767c <_malloc_r+0x2cc>
8000766a:	04 93       	mov	r3,r2
8000766c:	c0 38       	rjmp	80007672 <_malloc_r+0x2c2>
8000766e:	2f c3       	sub	r3,-4
80007670:	a1 7b       	lsl	r11,0x1
80007672:	f7 e8 00 09 	and	r9,r11,r8
80007676:	ca 71       	brne	800075c4 <_malloc_r+0x214>
80007678:	cf bb       	rjmp	8000766e <_malloc_r+0x2be>
8000767a:	d7 03       	nop
8000767c:	68 23       	ld.w	r3,r4[0x8]
8000767e:	66 12       	ld.w	r2,r3[0x4]
80007680:	e0 12 ff fc 	andl	r2,0xfffc
80007684:	0e 32       	cp.w	r2,r7
80007686:	5f 39       	srlo	r9
80007688:	e4 07 01 08 	sub	r8,r2,r7
8000768c:	58 f8       	cp.w	r8,15
8000768e:	5f aa       	srle	r10
80007690:	f5 e9 10 09 	or	r9,r10,r9
80007694:	e0 80 00 9a 	breq	800077c8 <_malloc_r+0x418>
80007698:	e0 68 0d 70 	mov	r8,3440
8000769c:	70 01       	ld.w	r1,r8[0x0]
8000769e:	e0 68 09 48 	mov	r8,2376
800076a2:	2f 01       	sub	r1,-16
800076a4:	70 08       	ld.w	r8,r8[0x0]
800076a6:	0e 01       	add	r1,r7
800076a8:	5b f8       	cp.w	r8,-1
800076aa:	c0 40       	breq	800076b2 <_malloc_r+0x302>
800076ac:	28 11       	sub	r1,-127
800076ae:	e0 11 ff 80 	andl	r1,0xff80
800076b2:	02 9b       	mov	r11,r1
800076b4:	0a 9c       	mov	r12,r5
800076b6:	e0 a0 02 a5 	rcall	80007c00 <_sbrk_r>
800076ba:	18 96       	mov	r6,r12
800076bc:	5b fc       	cp.w	r12,-1
800076be:	c7 50       	breq	800077a8 <_malloc_r+0x3f8>
800076c0:	e6 02 00 08 	add	r8,r3,r2
800076c4:	10 3c       	cp.w	r12,r8
800076c6:	c0 32       	brcc	800076cc <_malloc_r+0x31c>
800076c8:	08 33       	cp.w	r3,r4
800076ca:	c6 f1       	brne	800077a8 <_malloc_r+0x3f8>
800076cc:	e0 6a 0d 74 	mov	r10,3444
800076d0:	74 09       	ld.w	r9,r10[0x0]
800076d2:	e2 09 00 09 	add	r9,r1,r9
800076d6:	95 09       	st.w	r10[0x0],r9
800076d8:	10 36       	cp.w	r6,r8
800076da:	c0 a1       	brne	800076ee <_malloc_r+0x33e>
800076dc:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
800076e0:	c0 71       	brne	800076ee <_malloc_r+0x33e>
800076e2:	e2 02 00 02 	add	r2,r1,r2
800076e6:	68 28       	ld.w	r8,r4[0x8]
800076e8:	a1 a2       	sbr	r2,0x0
800076ea:	91 12       	st.w	r8[0x4],r2
800076ec:	c4 f8       	rjmp	8000778a <_malloc_r+0x3da>
800076ee:	e0 6a 09 48 	mov	r10,2376
800076f2:	74 0b       	ld.w	r11,r10[0x0]
800076f4:	5b fb       	cp.w	r11,-1
800076f6:	c0 31       	brne	800076fc <_malloc_r+0x34c>
800076f8:	95 06       	st.w	r10[0x0],r6
800076fa:	c0 78       	rjmp	80007708 <_malloc_r+0x358>
800076fc:	ec 09 00 09 	add	r9,r6,r9
80007700:	e0 6a 0d 74 	mov	r10,3444
80007704:	10 19       	sub	r9,r8
80007706:	95 09       	st.w	r10[0x0],r9
80007708:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
8000770c:	f0 09 11 08 	rsub	r9,r8,8
80007710:	58 08       	cp.w	r8,0
80007712:	f2 08 17 10 	movne	r8,r9
80007716:	ed d8 e1 06 	addne	r6,r6,r8
8000771a:	28 08       	sub	r8,-128
8000771c:	ec 01 00 01 	add	r1,r6,r1
80007720:	0a 9c       	mov	r12,r5
80007722:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
80007726:	f0 01 01 01 	sub	r1,r8,r1
8000772a:	02 9b       	mov	r11,r1
8000772c:	e0 a0 02 6a 	rcall	80007c00 <_sbrk_r>
80007730:	e0 68 0d 74 	mov	r8,3444
80007734:	5b fc       	cp.w	r12,-1
80007736:	ec 0c 17 00 	moveq	r12,r6
8000773a:	f9 b1 00 00 	moveq	r1,0
8000773e:	70 09       	ld.w	r9,r8[0x0]
80007740:	0c 1c       	sub	r12,r6
80007742:	89 26       	st.w	r4[0x8],r6
80007744:	02 0c       	add	r12,r1
80007746:	12 01       	add	r1,r9
80007748:	a1 ac       	sbr	r12,0x0
8000774a:	91 01       	st.w	r8[0x0],r1
8000774c:	8d 1c       	st.w	r6[0x4],r12
8000774e:	08 33       	cp.w	r3,r4
80007750:	c1 d0       	breq	8000778a <_malloc_r+0x3da>
80007752:	58 f2       	cp.w	r2,15
80007754:	e0 8b 00 05 	brhi	8000775e <_malloc_r+0x3ae>
80007758:	30 18       	mov	r8,1
8000775a:	8d 18       	st.w	r6[0x4],r8
8000775c:	c2 68       	rjmp	800077a8 <_malloc_r+0x3f8>
8000775e:	30 59       	mov	r9,5
80007760:	20 c2       	sub	r2,12
80007762:	e0 12 ff f8 	andl	r2,0xfff8
80007766:	e6 02 00 08 	add	r8,r3,r2
8000776a:	91 29       	st.w	r8[0x8],r9
8000776c:	91 19       	st.w	r8[0x4],r9
8000776e:	66 18       	ld.w	r8,r3[0x4]
80007770:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007774:	e5 e8 10 08 	or	r8,r2,r8
80007778:	87 18       	st.w	r3[0x4],r8
8000777a:	58 f2       	cp.w	r2,15
8000777c:	e0 88 00 07 	brls	8000778a <_malloc_r+0x3da>
80007780:	e6 cb ff f8 	sub	r11,r3,-8
80007784:	0a 9c       	mov	r12,r5
80007786:	e0 a0 1c 6b 	rcall	8000b05c <_free_r>
8000778a:	e0 69 0d 6c 	mov	r9,3436
8000778e:	72 0a       	ld.w	r10,r9[0x0]
80007790:	e0 68 0d 74 	mov	r8,3444
80007794:	70 08       	ld.w	r8,r8[0x0]
80007796:	14 38       	cp.w	r8,r10
80007798:	f3 f8 ba 00 	st.whi	r9[0x0],r8
8000779c:	e0 69 0d 68 	mov	r9,3432
800077a0:	72 0a       	ld.w	r10,r9[0x0]
800077a2:	14 38       	cp.w	r8,r10
800077a4:	f3 f8 ba 00 	st.whi	r9[0x0],r8
800077a8:	68 28       	ld.w	r8,r4[0x8]
800077aa:	70 18       	ld.w	r8,r8[0x4]
800077ac:	e0 18 ff fc 	andl	r8,0xfffc
800077b0:	0e 38       	cp.w	r8,r7
800077b2:	5f 39       	srlo	r9
800077b4:	0e 18       	sub	r8,r7
800077b6:	58 f8       	cp.w	r8,15
800077b8:	5f aa       	srle	r10
800077ba:	f5 e9 10 09 	or	r9,r10,r9
800077be:	c0 50       	breq	800077c8 <_malloc_r+0x418>
800077c0:	0a 9c       	mov	r12,r5
800077c2:	fe b0 f3 b7 	rcall	80005f30 <__malloc_unlock>
800077c6:	d8 3a       	popm	r0-r7,pc,r12=0
800077c8:	68 26       	ld.w	r6,r4[0x8]
800077ca:	a1 a8       	sbr	r8,0x0
800077cc:	0e 99       	mov	r9,r7
800077ce:	a1 a9       	sbr	r9,0x0
800077d0:	8d 19       	st.w	r6[0x4],r9
800077d2:	ec 07 00 07 	add	r7,r6,r7
800077d6:	0a 9c       	mov	r12,r5
800077d8:	89 27       	st.w	r4[0x8],r7
800077da:	8f 18       	st.w	r7[0x4],r8
800077dc:	fe b0 f3 aa 	rcall	80005f30 <__malloc_unlock>
800077e0:	ec cc ff f8 	sub	r12,r6,-8
800077e4:	d8 32       	popm	r0-r7,pc
800077e6:	d7 03       	nop

800077e8 <memcpy>:
800077e8:	58 8a       	cp.w	r10,8
800077ea:	c2 f5       	brlt	80007848 <memcpy+0x60>
800077ec:	f9 eb 10 09 	or	r9,r12,r11
800077f0:	e2 19 00 03 	andl	r9,0x3,COH
800077f4:	e0 81 00 97 	brne	80007922 <memcpy+0x13a>
800077f8:	e0 4a 00 20 	cp.w	r10,32
800077fc:	c3 b4       	brge	80007872 <memcpy+0x8a>
800077fe:	f4 08 14 02 	asr	r8,r10,0x2
80007802:	f0 09 11 08 	rsub	r9,r8,8
80007806:	fe 09 00 2f 	add	pc,pc,r9<<0x2
8000780a:	76 69       	ld.w	r9,r11[0x18]
8000780c:	99 69       	st.w	r12[0x18],r9
8000780e:	76 59       	ld.w	r9,r11[0x14]
80007810:	99 59       	st.w	r12[0x14],r9
80007812:	76 49       	ld.w	r9,r11[0x10]
80007814:	99 49       	st.w	r12[0x10],r9
80007816:	76 39       	ld.w	r9,r11[0xc]
80007818:	99 39       	st.w	r12[0xc],r9
8000781a:	76 29       	ld.w	r9,r11[0x8]
8000781c:	99 29       	st.w	r12[0x8],r9
8000781e:	76 19       	ld.w	r9,r11[0x4]
80007820:	99 19       	st.w	r12[0x4],r9
80007822:	76 09       	ld.w	r9,r11[0x0]
80007824:	99 09       	st.w	r12[0x0],r9
80007826:	f6 08 00 2b 	add	r11,r11,r8<<0x2
8000782a:	f8 08 00 28 	add	r8,r12,r8<<0x2
8000782e:	e0 1a 00 03 	andl	r10,0x3
80007832:	f4 0a 11 04 	rsub	r10,r10,4
80007836:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
8000783a:	17 a9       	ld.ub	r9,r11[0x2]
8000783c:	b0 a9       	st.b	r8[0x2],r9
8000783e:	17 99       	ld.ub	r9,r11[0x1]
80007840:	b0 99       	st.b	r8[0x1],r9
80007842:	17 89       	ld.ub	r9,r11[0x0]
80007844:	b0 89       	st.b	r8[0x0],r9
80007846:	5e fc       	retal	r12
80007848:	f4 0a 11 09 	rsub	r10,r10,9
8000784c:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
80007850:	17 f9       	ld.ub	r9,r11[0x7]
80007852:	b8 f9       	st.b	r12[0x7],r9
80007854:	17 e9       	ld.ub	r9,r11[0x6]
80007856:	b8 e9       	st.b	r12[0x6],r9
80007858:	17 d9       	ld.ub	r9,r11[0x5]
8000785a:	b8 d9       	st.b	r12[0x5],r9
8000785c:	17 c9       	ld.ub	r9,r11[0x4]
8000785e:	b8 c9       	st.b	r12[0x4],r9
80007860:	17 b9       	ld.ub	r9,r11[0x3]
80007862:	b8 b9       	st.b	r12[0x3],r9
80007864:	17 a9       	ld.ub	r9,r11[0x2]
80007866:	b8 a9       	st.b	r12[0x2],r9
80007868:	17 99       	ld.ub	r9,r11[0x1]
8000786a:	b8 99       	st.b	r12[0x1],r9
8000786c:	17 89       	ld.ub	r9,r11[0x0]
8000786e:	b8 89       	st.b	r12[0x0],r9
80007870:	5e fc       	retal	r12
80007872:	eb cd 40 c0 	pushm	r6-r7,lr
80007876:	18 99       	mov	r9,r12
80007878:	22 0a       	sub	r10,32
8000787a:	b7 07       	ld.d	r6,r11++
8000787c:	b3 26       	st.d	r9++,r6
8000787e:	b7 07       	ld.d	r6,r11++
80007880:	b3 26       	st.d	r9++,r6
80007882:	b7 07       	ld.d	r6,r11++
80007884:	b3 26       	st.d	r9++,r6
80007886:	b7 07       	ld.d	r6,r11++
80007888:	b3 26       	st.d	r9++,r6
8000788a:	22 0a       	sub	r10,32
8000788c:	cf 74       	brge	8000787a <memcpy+0x92>
8000788e:	2f 0a       	sub	r10,-16
80007890:	c0 65       	brlt	8000789c <memcpy+0xb4>
80007892:	b7 07       	ld.d	r6,r11++
80007894:	b3 26       	st.d	r9++,r6
80007896:	b7 07       	ld.d	r6,r11++
80007898:	b3 26       	st.d	r9++,r6
8000789a:	21 0a       	sub	r10,16
8000789c:	5c 3a       	neg	r10
8000789e:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
800078a2:	d7 03       	nop
800078a4:	d7 03       	nop
800078a6:	f7 36 00 0e 	ld.ub	r6,r11[14]
800078aa:	f3 66 00 0e 	st.b	r9[14],r6
800078ae:	f7 36 00 0d 	ld.ub	r6,r11[13]
800078b2:	f3 66 00 0d 	st.b	r9[13],r6
800078b6:	f7 36 00 0c 	ld.ub	r6,r11[12]
800078ba:	f3 66 00 0c 	st.b	r9[12],r6
800078be:	f7 36 00 0b 	ld.ub	r6,r11[11]
800078c2:	f3 66 00 0b 	st.b	r9[11],r6
800078c6:	f7 36 00 0a 	ld.ub	r6,r11[10]
800078ca:	f3 66 00 0a 	st.b	r9[10],r6
800078ce:	f7 36 00 09 	ld.ub	r6,r11[9]
800078d2:	f3 66 00 09 	st.b	r9[9],r6
800078d6:	f7 36 00 08 	ld.ub	r6,r11[8]
800078da:	f3 66 00 08 	st.b	r9[8],r6
800078de:	f7 36 00 07 	ld.ub	r6,r11[7]
800078e2:	f3 66 00 07 	st.b	r9[7],r6
800078e6:	f7 36 00 06 	ld.ub	r6,r11[6]
800078ea:	f3 66 00 06 	st.b	r9[6],r6
800078ee:	f7 36 00 05 	ld.ub	r6,r11[5]
800078f2:	f3 66 00 05 	st.b	r9[5],r6
800078f6:	f7 36 00 04 	ld.ub	r6,r11[4]
800078fa:	f3 66 00 04 	st.b	r9[4],r6
800078fe:	f7 36 00 03 	ld.ub	r6,r11[3]
80007902:	f3 66 00 03 	st.b	r9[3],r6
80007906:	f7 36 00 02 	ld.ub	r6,r11[2]
8000790a:	f3 66 00 02 	st.b	r9[2],r6
8000790e:	f7 36 00 01 	ld.ub	r6,r11[1]
80007912:	f3 66 00 01 	st.b	r9[1],r6
80007916:	f7 36 00 00 	ld.ub	r6,r11[0]
8000791a:	f3 66 00 00 	st.b	r9[0],r6
8000791e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80007922:	20 1a       	sub	r10,1
80007924:	f6 0a 07 09 	ld.ub	r9,r11[r10]
80007928:	f8 0a 0b 09 	st.b	r12[r10],r9
8000792c:	cf b1       	brne	80007922 <memcpy+0x13a>
8000792e:	5e fc       	retal	r12

80007930 <memset>:
80007930:	18 98       	mov	r8,r12
80007932:	c0 38       	rjmp	80007938 <memset+0x8>
80007934:	10 cb       	st.b	r8++,r11
80007936:	20 1a       	sub	r10,1
80007938:	58 0a       	cp.w	r10,0
8000793a:	cf d1       	brne	80007934 <memset+0x4>
8000793c:	5e fc       	retal	r12
8000793e:	d7 03       	nop

80007940 <_realloc_r>:
80007940:	d4 31       	pushm	r0-r7,lr
80007942:	20 1d       	sub	sp,4
80007944:	16 94       	mov	r4,r11
80007946:	18 92       	mov	r2,r12
80007948:	14 9b       	mov	r11,r10
8000794a:	58 04       	cp.w	r4,0
8000794c:	c0 51       	brne	80007956 <_realloc_r+0x16>
8000794e:	fe b0 fd 31 	rcall	800073b0 <_malloc_r>
80007952:	18 95       	mov	r5,r12
80007954:	c5 39       	rjmp	80007bfa <_realloc_r+0x2ba>
80007956:	50 0a       	stdsp	sp[0x0],r10
80007958:	fe b0 f2 e6 	rcall	80005f24 <__malloc_lock>
8000795c:	40 0b       	lddsp	r11,sp[0x0]
8000795e:	f6 c8 ff f5 	sub	r8,r11,-11
80007962:	e8 c1 00 08 	sub	r1,r4,8
80007966:	10 96       	mov	r6,r8
80007968:	62 1c       	ld.w	r12,r1[0x4]
8000796a:	e0 16 ff f8 	andl	r6,0xfff8
8000796e:	59 68       	cp.w	r8,22
80007970:	f9 b6 08 10 	movls	r6,16
80007974:	16 36       	cp.w	r6,r11
80007976:	5f 38       	srlo	r8
80007978:	f1 e6 13 f8 	or	r8,r8,r6>>0x1f
8000797c:	c0 50       	breq	80007986 <_realloc_r+0x46>
8000797e:	30 c8       	mov	r8,12
80007980:	30 05       	mov	r5,0
80007982:	85 38       	st.w	r2[0xc],r8
80007984:	c3 b9       	rjmp	80007bfa <_realloc_r+0x2ba>
80007986:	18 90       	mov	r0,r12
80007988:	e0 10 ff fc 	andl	r0,0xfffc
8000798c:	0c 30       	cp.w	r0,r6
8000798e:	e0 84 01 0b 	brge	80007ba4 <_realloc_r+0x264>
80007992:	e0 68 05 3c 	mov	r8,1340
80007996:	e2 00 00 09 	add	r9,r1,r0
8000799a:	70 25       	ld.w	r5,r8[0x8]
8000799c:	0a 39       	cp.w	r9,r5
8000799e:	c0 90       	breq	800079b0 <_realloc_r+0x70>
800079a0:	72 1a       	ld.w	r10,r9[0x4]
800079a2:	a1 ca       	cbr	r10,0x0
800079a4:	f2 0a 00 0a 	add	r10,r9,r10
800079a8:	74 1a       	ld.w	r10,r10[0x4]
800079aa:	ed ba 00 00 	bld	r10,0x0
800079ae:	c2 20       	breq	800079f2 <_realloc_r+0xb2>
800079b0:	72 1a       	ld.w	r10,r9[0x4]
800079b2:	e0 1a ff fc 	andl	r10,0xfffc
800079b6:	f4 00 00 03 	add	r3,r10,r0
800079ba:	0a 39       	cp.w	r9,r5
800079bc:	c1 31       	brne	800079e2 <_realloc_r+0xa2>
800079be:	ec c7 ff f0 	sub	r7,r6,-16
800079c2:	0e 33       	cp.w	r3,r7
800079c4:	c1 95       	brlt	800079f6 <_realloc_r+0xb6>
800079c6:	e2 06 00 09 	add	r9,r1,r6
800079ca:	0c 13       	sub	r3,r6
800079cc:	a1 a3       	sbr	r3,0x0
800079ce:	93 13       	st.w	r9[0x4],r3
800079d0:	91 29       	st.w	r8[0x8],r9
800079d2:	04 9c       	mov	r12,r2
800079d4:	62 18       	ld.w	r8,r1[0x4]
800079d6:	08 95       	mov	r5,r4
800079d8:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800079dc:	10 46       	or	r6,r8
800079de:	83 16       	st.w	r1[0x4],r6
800079e0:	c0 b9       	rjmp	80007bf6 <_realloc_r+0x2b6>
800079e2:	0c 33       	cp.w	r3,r6
800079e4:	c0 95       	brlt	800079f6 <_realloc_r+0xb6>
800079e6:	72 28       	ld.w	r8,r9[0x8]
800079e8:	02 97       	mov	r7,r1
800079ea:	72 39       	ld.w	r9,r9[0xc]
800079ec:	93 28       	st.w	r9[0x8],r8
800079ee:	91 39       	st.w	r8[0xc],r9
800079f0:	cd c8       	rjmp	80007ba8 <_realloc_r+0x268>
800079f2:	30 0a       	mov	r10,0
800079f4:	14 99       	mov	r9,r10
800079f6:	ed bc 00 00 	bld	r12,0x0
800079fa:	e0 80 00 95 	breq	80007b24 <_realloc_r+0x1e4>
800079fe:	62 07       	ld.w	r7,r1[0x0]
80007a00:	e2 07 01 07 	sub	r7,r1,r7
80007a04:	6e 1c       	ld.w	r12,r7[0x4]
80007a06:	e0 1c ff fc 	andl	r12,0xfffc
80007a0a:	58 09       	cp.w	r9,0
80007a0c:	c5 60       	breq	80007ab8 <_realloc_r+0x178>
80007a0e:	f8 00 00 03 	add	r3,r12,r0
80007a12:	0a 39       	cp.w	r9,r5
80007a14:	c4 81       	brne	80007aa4 <_realloc_r+0x164>
80007a16:	14 03       	add	r3,r10
80007a18:	ec c9 ff f0 	sub	r9,r6,-16
80007a1c:	12 33       	cp.w	r3,r9
80007a1e:	c4 d5       	brlt	80007ab8 <_realloc_r+0x178>
80007a20:	6e 3a       	ld.w	r10,r7[0xc]
80007a22:	6e 29       	ld.w	r9,r7[0x8]
80007a24:	95 29       	st.w	r10[0x8],r9
80007a26:	93 3a       	st.w	r9[0xc],r10
80007a28:	ee c5 ff f8 	sub	r5,r7,-8
80007a2c:	e0 ca 00 04 	sub	r10,r0,4
80007a30:	e0 4a 00 24 	cp.w	r10,36
80007a34:	e0 8b 00 25 	brhi	80007a7e <_realloc_r+0x13e>
80007a38:	0a 99       	mov	r9,r5
80007a3a:	59 3a       	cp.w	r10,19
80007a3c:	e0 88 00 1a 	brls	80007a70 <_realloc_r+0x130>
80007a40:	09 09       	ld.w	r9,r4++
80007a42:	8b 09       	st.w	r5[0x0],r9
80007a44:	09 09       	ld.w	r9,r4++
80007a46:	8f 39       	st.w	r7[0xc],r9
80007a48:	ee c9 ff f0 	sub	r9,r7,-16
80007a4c:	59 ba       	cp.w	r10,27
80007a4e:	e0 88 00 11 	brls	80007a70 <_realloc_r+0x130>
80007a52:	09 0b       	ld.w	r11,r4++
80007a54:	93 0b       	st.w	r9[0x0],r11
80007a56:	09 09       	ld.w	r9,r4++
80007a58:	8f 59       	st.w	r7[0x14],r9
80007a5a:	ee c9 ff e8 	sub	r9,r7,-24
80007a5e:	e0 4a 00 24 	cp.w	r10,36
80007a62:	c0 71       	brne	80007a70 <_realloc_r+0x130>
80007a64:	09 0a       	ld.w	r10,r4++
80007a66:	93 0a       	st.w	r9[0x0],r10
80007a68:	ee c9 ff e0 	sub	r9,r7,-32
80007a6c:	09 0a       	ld.w	r10,r4++
80007a6e:	8f 7a       	st.w	r7[0x1c],r10
80007a70:	09 0a       	ld.w	r10,r4++
80007a72:	12 aa       	st.w	r9++,r10
80007a74:	68 0a       	ld.w	r10,r4[0x0]
80007a76:	93 0a       	st.w	r9[0x0],r10
80007a78:	68 1a       	ld.w	r10,r4[0x4]
80007a7a:	93 1a       	st.w	r9[0x4],r10
80007a7c:	c0 78       	rjmp	80007a8a <_realloc_r+0x14a>
80007a7e:	50 08       	stdsp	sp[0x0],r8
80007a80:	08 9b       	mov	r11,r4
80007a82:	0a 9c       	mov	r12,r5
80007a84:	e0 a0 1d 8f 	rcall	8000b5a2 <memmove>
80007a88:	40 08       	lddsp	r8,sp[0x0]
80007a8a:	ee 06 00 09 	add	r9,r7,r6
80007a8e:	0c 13       	sub	r3,r6
80007a90:	a1 a3       	sbr	r3,0x0
80007a92:	93 13       	st.w	r9[0x4],r3
80007a94:	91 29       	st.w	r8[0x8],r9
80007a96:	04 9c       	mov	r12,r2
80007a98:	6e 18       	ld.w	r8,r7[0x4]
80007a9a:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007a9e:	10 46       	or	r6,r8
80007aa0:	8f 16       	st.w	r7[0x4],r6
80007aa2:	ca a8       	rjmp	80007bf6 <_realloc_r+0x2b6>
80007aa4:	14 03       	add	r3,r10
80007aa6:	0c 33       	cp.w	r3,r6
80007aa8:	c0 85       	brlt	80007ab8 <_realloc_r+0x178>
80007aaa:	72 28       	ld.w	r8,r9[0x8]
80007aac:	72 39       	ld.w	r9,r9[0xc]
80007aae:	93 28       	st.w	r9[0x8],r8
80007ab0:	91 39       	st.w	r8[0xc],r9
80007ab2:	6e 28       	ld.w	r8,r7[0x8]
80007ab4:	6e 39       	ld.w	r9,r7[0xc]
80007ab6:	c0 78       	rjmp	80007ac4 <_realloc_r+0x184>
80007ab8:	f8 00 00 03 	add	r3,r12,r0
80007abc:	0c 33       	cp.w	r3,r6
80007abe:	c3 35       	brlt	80007b24 <_realloc_r+0x1e4>
80007ac0:	6e 39       	ld.w	r9,r7[0xc]
80007ac2:	6e 28       	ld.w	r8,r7[0x8]
80007ac4:	93 28       	st.w	r9[0x8],r8
80007ac6:	91 39       	st.w	r8[0xc],r9
80007ac8:	e0 ca 00 04 	sub	r10,r0,4
80007acc:	ee cc ff f8 	sub	r12,r7,-8
80007ad0:	e0 4a 00 24 	cp.w	r10,36
80007ad4:	e0 8b 00 24 	brhi	80007b1c <_realloc_r+0x1dc>
80007ad8:	59 3a       	cp.w	r10,19
80007ada:	e0 88 00 1a 	brls	80007b0e <_realloc_r+0x1ce>
80007ade:	09 08       	ld.w	r8,r4++
80007ae0:	99 08       	st.w	r12[0x0],r8
80007ae2:	09 08       	ld.w	r8,r4++
80007ae4:	8f 38       	st.w	r7[0xc],r8
80007ae6:	ee cc ff f0 	sub	r12,r7,-16
80007aea:	59 ba       	cp.w	r10,27
80007aec:	e0 88 00 11 	brls	80007b0e <_realloc_r+0x1ce>
80007af0:	09 08       	ld.w	r8,r4++
80007af2:	99 08       	st.w	r12[0x0],r8
80007af4:	09 08       	ld.w	r8,r4++
80007af6:	8f 58       	st.w	r7[0x14],r8
80007af8:	ee cc ff e8 	sub	r12,r7,-24
80007afc:	e0 4a 00 24 	cp.w	r10,36
80007b00:	c0 71       	brne	80007b0e <_realloc_r+0x1ce>
80007b02:	09 08       	ld.w	r8,r4++
80007b04:	99 08       	st.w	r12[0x0],r8
80007b06:	ee cc ff e0 	sub	r12,r7,-32
80007b0a:	09 08       	ld.w	r8,r4++
80007b0c:	8f 78       	st.w	r7[0x1c],r8
80007b0e:	09 08       	ld.w	r8,r4++
80007b10:	18 a8       	st.w	r12++,r8
80007b12:	68 08       	ld.w	r8,r4[0x0]
80007b14:	99 08       	st.w	r12[0x0],r8
80007b16:	68 18       	ld.w	r8,r4[0x4]
80007b18:	99 18       	st.w	r12[0x4],r8
80007b1a:	c4 78       	rjmp	80007ba8 <_realloc_r+0x268>
80007b1c:	08 9b       	mov	r11,r4
80007b1e:	e0 a0 1d 42 	rcall	8000b5a2 <memmove>
80007b22:	c4 38       	rjmp	80007ba8 <_realloc_r+0x268>
80007b24:	04 9c       	mov	r12,r2
80007b26:	fe b0 fc 45 	rcall	800073b0 <_malloc_r>
80007b2a:	18 95       	mov	r5,r12
80007b2c:	c3 a0       	breq	80007ba0 <_realloc_r+0x260>
80007b2e:	62 18       	ld.w	r8,r1[0x4]
80007b30:	f8 c9 00 08 	sub	r9,r12,8
80007b34:	a1 c8       	cbr	r8,0x0
80007b36:	e2 08 00 08 	add	r8,r1,r8
80007b3a:	10 39       	cp.w	r9,r8
80007b3c:	c0 71       	brne	80007b4a <_realloc_r+0x20a>
80007b3e:	72 13       	ld.w	r3,r9[0x4]
80007b40:	02 97       	mov	r7,r1
80007b42:	e0 13 ff fc 	andl	r3,0xfffc
80007b46:	00 03       	add	r3,r0
80007b48:	c3 08       	rjmp	80007ba8 <_realloc_r+0x268>
80007b4a:	e0 ca 00 04 	sub	r10,r0,4
80007b4e:	e0 4a 00 24 	cp.w	r10,36
80007b52:	e0 8b 00 20 	brhi	80007b92 <_realloc_r+0x252>
80007b56:	08 99       	mov	r9,r4
80007b58:	18 98       	mov	r8,r12
80007b5a:	59 3a       	cp.w	r10,19
80007b5c:	e0 88 00 14 	brls	80007b84 <_realloc_r+0x244>
80007b60:	13 0b       	ld.w	r11,r9++
80007b62:	10 ab       	st.w	r8++,r11
80007b64:	13 0b       	ld.w	r11,r9++
80007b66:	10 ab       	st.w	r8++,r11
80007b68:	59 ba       	cp.w	r10,27
80007b6a:	e0 88 00 0d 	brls	80007b84 <_realloc_r+0x244>
80007b6e:	13 0b       	ld.w	r11,r9++
80007b70:	10 ab       	st.w	r8++,r11
80007b72:	13 0b       	ld.w	r11,r9++
80007b74:	10 ab       	st.w	r8++,r11
80007b76:	e0 4a 00 24 	cp.w	r10,36
80007b7a:	c0 51       	brne	80007b84 <_realloc_r+0x244>
80007b7c:	13 0a       	ld.w	r10,r9++
80007b7e:	10 aa       	st.w	r8++,r10
80007b80:	13 0a       	ld.w	r10,r9++
80007b82:	10 aa       	st.w	r8++,r10
80007b84:	13 0a       	ld.w	r10,r9++
80007b86:	10 aa       	st.w	r8++,r10
80007b88:	72 0a       	ld.w	r10,r9[0x0]
80007b8a:	91 0a       	st.w	r8[0x0],r10
80007b8c:	72 19       	ld.w	r9,r9[0x4]
80007b8e:	91 19       	st.w	r8[0x4],r9
80007b90:	c0 48       	rjmp	80007b98 <_realloc_r+0x258>
80007b92:	08 9b       	mov	r11,r4
80007b94:	e0 a0 1d 07 	rcall	8000b5a2 <memmove>
80007b98:	08 9b       	mov	r11,r4
80007b9a:	04 9c       	mov	r12,r2
80007b9c:	e0 a0 1a 60 	rcall	8000b05c <_free_r>
80007ba0:	04 9c       	mov	r12,r2
80007ba2:	c2 a8       	rjmp	80007bf6 <_realloc_r+0x2b6>
80007ba4:	00 93       	mov	r3,r0
80007ba6:	02 97       	mov	r7,r1
80007ba8:	e6 06 01 09 	sub	r9,r3,r6
80007bac:	6e 18       	ld.w	r8,r7[0x4]
80007bae:	58 f9       	cp.w	r9,15
80007bb0:	e0 88 00 16 	brls	80007bdc <_realloc_r+0x29c>
80007bb4:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007bb8:	ed e8 10 08 	or	r8,r6,r8
80007bbc:	8f 18       	st.w	r7[0x4],r8
80007bbe:	12 98       	mov	r8,r9
80007bc0:	a1 a8       	sbr	r8,0x0
80007bc2:	ee 06 00 0b 	add	r11,r7,r6
80007bc6:	f6 09 00 09 	add	r9,r11,r9
80007bca:	97 18       	st.w	r11[0x4],r8
80007bcc:	72 18       	ld.w	r8,r9[0x4]
80007bce:	a1 a8       	sbr	r8,0x0
80007bd0:	2f 8b       	sub	r11,-8
80007bd2:	93 18       	st.w	r9[0x4],r8
80007bd4:	04 9c       	mov	r12,r2
80007bd6:	e0 a0 1a 43 	rcall	8000b05c <_free_r>
80007bda:	c0 b8       	rjmp	80007bf0 <_realloc_r+0x2b0>
80007bdc:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007be0:	e7 e8 10 08 	or	r8,r3,r8
80007be4:	8f 18       	st.w	r7[0x4],r8
80007be6:	ee 03 00 03 	add	r3,r7,r3
80007bea:	66 18       	ld.w	r8,r3[0x4]
80007bec:	a1 a8       	sbr	r8,0x0
80007bee:	87 18       	st.w	r3[0x4],r8
80007bf0:	04 9c       	mov	r12,r2
80007bf2:	ee c5 ff f8 	sub	r5,r7,-8
80007bf6:	fe b0 f1 9d 	rcall	80005f30 <__malloc_unlock>
80007bfa:	0a 9c       	mov	r12,r5
80007bfc:	2f fd       	sub	sp,-4
80007bfe:	d8 32       	popm	r0-r7,pc

80007c00 <_sbrk_r>:
80007c00:	d4 21       	pushm	r4-r7,lr
80007c02:	30 08       	mov	r8,0
80007c04:	18 97       	mov	r7,r12
80007c06:	e0 66 65 9c 	mov	r6,26012
80007c0a:	16 9c       	mov	r12,r11
80007c0c:	8d 08       	st.w	r6[0x0],r8
80007c0e:	c8 5c       	rcall	80007d18 <_sbrk>
80007c10:	5b fc       	cp.w	r12,-1
80007c12:	c0 51       	brne	80007c1c <_sbrk_r+0x1c>
80007c14:	6c 08       	ld.w	r8,r6[0x0]
80007c16:	58 08       	cp.w	r8,0
80007c18:	ef f8 1a 03 	st.wne	r7[0xc],r8
80007c1c:	d8 22       	popm	r4-r7,pc
80007c1e:	d7 03       	nop

80007c20 <sprintf>:
80007c20:	d4 01       	pushm	lr
80007c22:	21 7d       	sub	sp,92
80007c24:	e0 68 ff ff 	mov	r8,65535
80007c28:	ea 18 7f ff 	orh	r8,0x7fff
80007c2c:	50 58       	stdsp	sp[0x14],r8
80007c2e:	50 28       	stdsp	sp[0x8],r8
80007c30:	e0 68 02 08 	mov	r8,520
80007c34:	ba 68       	st.h	sp[0xc],r8
80007c36:	3f f8       	mov	r8,-1
80007c38:	ba 78       	st.h	sp[0xe],r8
80007c3a:	e0 68 0a 3c 	mov	r8,2620
80007c3e:	50 4c       	stdsp	sp[0x10],r12
80007c40:	16 9a       	mov	r10,r11
80007c42:	50 0c       	stdsp	sp[0x0],r12
80007c44:	fa c9 ff a0 	sub	r9,sp,-96
80007c48:	70 0c       	ld.w	r12,r8[0x0]
80007c4a:	1a 9b       	mov	r11,sp
80007c4c:	e0 a0 02 1a 	rcall	80008080 <_vfprintf_r>
80007c50:	30 09       	mov	r9,0
80007c52:	40 08       	lddsp	r8,sp[0x0]
80007c54:	b0 89       	st.b	r8[0x0],r9
80007c56:	2e 9d       	sub	sp,-92
80007c58:	d8 02       	popm	pc
80007c5a:	d7 03       	nop

80007c5c <strncpy>:
80007c5c:	30 08       	mov	r8,0
80007c5e:	10 3a       	cp.w	r10,r8
80007c60:	5e 0c       	reteq	r12
80007c62:	f6 08 07 09 	ld.ub	r9,r11[r8]
80007c66:	f8 08 0b 09 	st.b	r12[r8],r9
80007c6a:	2f f8       	sub	r8,-1
80007c6c:	58 09       	cp.w	r9,0
80007c6e:	cf 81       	brne	80007c5e <strncpy+0x2>
80007c70:	10 3a       	cp.w	r10,r8
80007c72:	5e 0c       	reteq	r12
80007c74:	f8 08 0b 09 	st.b	r12[r8],r9
80007c78:	2f f8       	sub	r8,-1
80007c7a:	cf bb       	rjmp	80007c70 <strncpy+0x14>

80007c7c <_close>:
80007c7c:	30 28       	mov	r8,2
80007c7e:	d6 73       	breakpoint
80007c80:	3f fc       	mov	r12,-1
80007c82:	35 8b       	mov	r11,88
80007c84:	58 0c       	cp.w	r12,0
80007c86:	5e 4c       	retge	r12
80007c88:	e0 6a 65 9c 	mov	r10,26012
80007c8c:	95 0b       	st.w	r10[0x0],r11
80007c8e:	5e fc       	retal	r12

80007c90 <_lseek>:
80007c90:	30 58       	mov	r8,5
80007c92:	d6 73       	breakpoint
80007c94:	3f fc       	mov	r12,-1
80007c96:	35 8b       	mov	r11,88
80007c98:	58 0c       	cp.w	r12,0
80007c9a:	5e 4c       	retge	r12
80007c9c:	e0 6a 65 9c 	mov	r10,26012
80007ca0:	95 0b       	st.w	r10[0x0],r11
80007ca2:	5e fc       	retal	r12

80007ca4 <isatty>:
80007ca4:	30 b8       	mov	r8,11
80007ca6:	d6 73       	breakpoint
80007ca8:	3f fc       	mov	r12,-1
80007caa:	35 8b       	mov	r11,88
80007cac:	58 0c       	cp.w	r12,0
80007cae:	5e 4c       	retge	r12
80007cb0:	e0 6a 65 9c 	mov	r10,26012
80007cb4:	95 0b       	st.w	r10[0x0],r11
80007cb6:	5e fc       	retal	r12

80007cb8 <_fstat_host>:
80007cb8:	30 98       	mov	r8,9
80007cba:	d6 73       	breakpoint
80007cbc:	3f fc       	mov	r12,-1
80007cbe:	35 8b       	mov	r11,88
80007cc0:	58 0c       	cp.w	r12,0
80007cc2:	5e 4c       	retge	r12
80007cc4:	e0 6a 65 9c 	mov	r10,26012
80007cc8:	95 0b       	st.w	r10[0x0],r11
80007cca:	5e fc       	retal	r12

80007ccc <_fstat>:
80007ccc:	d4 21       	pushm	r4-r7,lr
80007cce:	21 0d       	sub	sp,64
80007cd0:	16 97       	mov	r7,r11
80007cd2:	1a 9b       	mov	r11,sp
80007cd4:	cf 2f       	rcall	80007cb8 <_fstat_host>
80007cd6:	c0 34       	brge	80007cdc <_fstat+0x10>
80007cd8:	3f fc       	mov	r12,-1
80007cda:	c1 c8       	rjmp	80007d12 <_fstat+0x46>
80007cdc:	40 08       	lddsp	r8,sp[0x0]
80007cde:	ae 08       	st.h	r7[0x0],r8
80007ce0:	40 18       	lddsp	r8,sp[0x4]
80007ce2:	ae 18       	st.h	r7[0x2],r8
80007ce4:	40 28       	lddsp	r8,sp[0x8]
80007ce6:	8f 18       	st.w	r7[0x4],r8
80007ce8:	40 38       	lddsp	r8,sp[0xc]
80007cea:	ae 48       	st.h	r7[0x8],r8
80007cec:	40 48       	lddsp	r8,sp[0x10]
80007cee:	ae 58       	st.h	r7[0xa],r8
80007cf0:	40 58       	lddsp	r8,sp[0x14]
80007cf2:	ae 68       	st.h	r7[0xc],r8
80007cf4:	40 68       	lddsp	r8,sp[0x18]
80007cf6:	ae 78       	st.h	r7[0xe],r8
80007cf8:	40 88       	lddsp	r8,sp[0x20]
80007cfa:	8f 48       	st.w	r7[0x10],r8
80007cfc:	40 a8       	lddsp	r8,sp[0x28]
80007cfe:	8f b8       	st.w	r7[0x2c],r8
80007d00:	40 c8       	lddsp	r8,sp[0x30]
80007d02:	8f c8       	st.w	r7[0x30],r8
80007d04:	40 d8       	lddsp	r8,sp[0x34]
80007d06:	8f 58       	st.w	r7[0x14],r8
80007d08:	40 e8       	lddsp	r8,sp[0x38]
80007d0a:	30 0c       	mov	r12,0
80007d0c:	8f 78       	st.w	r7[0x1c],r8
80007d0e:	40 f8       	lddsp	r8,sp[0x3c]
80007d10:	8f 98       	st.w	r7[0x24],r8
80007d12:	2f 0d       	sub	sp,-64
80007d14:	d8 22       	popm	r4-r7,pc
80007d16:	d7 03       	nop

80007d18 <_sbrk>:
80007d18:	d4 01       	pushm	lr
80007d1a:	e0 68 0d 9c 	mov	r8,3484
80007d1e:	70 09       	ld.w	r9,r8[0x0]
80007d20:	58 09       	cp.w	r9,0
80007d22:	c0 41       	brne	80007d2a <_sbrk+0x12>
80007d24:	e0 69 65 a0 	mov	r9,26016
80007d28:	91 09       	st.w	r8[0x0],r9
80007d2a:	e0 69 0d 9c 	mov	r9,3484
80007d2e:	e0 7a 70 00 	mov	r10,94208
80007d32:	72 08       	ld.w	r8,r9[0x0]
80007d34:	f0 0c 00 0c 	add	r12,r8,r12
80007d38:	14 3c       	cp.w	r12,r10
80007d3a:	e0 8b 00 04 	brhi	80007d42 <_sbrk+0x2a>
80007d3e:	93 0c       	st.w	r9[0x0],r12
80007d40:	c0 68       	rjmp	80007d4c <_sbrk+0x34>
80007d42:	e0 a0 18 15 	rcall	8000ad6c <__errno>
80007d46:	30 c8       	mov	r8,12
80007d48:	99 08       	st.w	r12[0x0],r8
80007d4a:	3f f8       	mov	r8,-1
80007d4c:	10 9c       	mov	r12,r8
80007d4e:	d8 02       	popm	pc

80007d50 <get_arg>:
80007d50:	d4 31       	pushm	r0-r7,lr
80007d52:	20 8d       	sub	sp,32
80007d54:	fa c4 ff bc 	sub	r4,sp,-68
80007d58:	50 4b       	stdsp	sp[0x10],r11
80007d5a:	68 2e       	ld.w	lr,r4[0x8]
80007d5c:	50 58       	stdsp	sp[0x14],r8
80007d5e:	12 96       	mov	r6,r9
80007d60:	7c 0b       	ld.w	r11,lr[0x0]
80007d62:	70 05       	ld.w	r5,r8[0x0]
80007d64:	50 6e       	stdsp	sp[0x18],lr
80007d66:	58 0b       	cp.w	r11,0
80007d68:	f4 0b 17 00 	moveq	r11,r10
80007d6c:	68 03       	ld.w	r3,r4[0x0]
80007d6e:	68 11       	ld.w	r1,r4[0x4]
80007d70:	40 49       	lddsp	r9,sp[0x10]
80007d72:	30 08       	mov	r8,0
80007d74:	c2 89       	rjmp	80007fc4 <get_arg+0x274>
80007d76:	2f fb       	sub	r11,-1
80007d78:	32 5c       	mov	r12,37
80007d7a:	17 8a       	ld.ub	r10,r11[0x0]
80007d7c:	f8 0a 18 00 	cp.b	r10,r12
80007d80:	5f 1e       	srne	lr
80007d82:	f0 0a 18 00 	cp.b	r10,r8
80007d86:	5f 1c       	srne	r12
80007d88:	fd ec 00 0c 	and	r12,lr,r12
80007d8c:	f0 0c 18 00 	cp.b	r12,r8
80007d90:	cf 31       	brne	80007d76 <get_arg+0x26>
80007d92:	58 0a       	cp.w	r10,0
80007d94:	e0 80 01 25 	breq	80007fde <get_arg+0x28e>
80007d98:	30 0c       	mov	r12,0
80007d9a:	3f fa       	mov	r10,-1
80007d9c:	18 90       	mov	r0,r12
80007d9e:	50 3a       	stdsp	sp[0xc],r10
80007da0:	18 94       	mov	r4,r12
80007da2:	18 92       	mov	r2,r12
80007da4:	f8 0c 00 3c 	add	r12,r12,r12<<0x3
80007da8:	16 97       	mov	r7,r11
80007daa:	50 7c       	stdsp	sp[0x1c],r12
80007dac:	fe cc 9d a4 	sub	r12,pc,-25180
80007db0:	0f 3a       	ld.ub	r10,r7++
80007db2:	f8 0a 07 0e 	ld.ub	lr,r12[r10]
80007db6:	40 7c       	lddsp	r12,sp[0x1c]
80007db8:	1c 0c       	add	r12,lr
80007dba:	fe ce 9e 7a 	sub	lr,pc,-24966
80007dbe:	fc 0c 07 0e 	ld.ub	lr,lr[r12]
80007dc2:	20 1e       	sub	lr,1
80007dc4:	50 0e       	stdsp	sp[0x0],lr
80007dc6:	fe ce 9e f2 	sub	lr,pc,-24846
80007dca:	fc 0c 07 0c 	ld.ub	r12,lr[r12]
80007dce:	50 7c       	stdsp	sp[0x1c],r12
80007dd0:	40 0c       	lddsp	r12,sp[0x0]
80007dd2:	58 7c       	cp.w	r12,7
80007dd4:	e0 8b 00 f1 	brhi	80007fb6 <get_arg+0x266>
80007dd8:	fe ce a0 a4 	sub	lr,pc,-24412
80007ddc:	fc 0c 03 2f 	ld.w	pc,lr[r12<<0x2]
80007de0:	36 8b       	mov	r11,104
80007de2:	f6 0a 18 00 	cp.b	r10,r11
80007de6:	e0 80 00 e8 	breq	80007fb6 <get_arg+0x266>
80007dea:	37 1b       	mov	r11,113
80007dec:	f6 0a 18 00 	cp.b	r10,r11
80007df0:	c0 70       	breq	80007dfe <get_arg+0xae>
80007df2:	34 cb       	mov	r11,76
80007df4:	f6 0a 18 00 	cp.b	r10,r11
80007df8:	c0 51       	brne	80007e02 <get_arg+0xb2>
80007dfa:	a3 b4       	sbr	r4,0x3
80007dfc:	cd d8       	rjmp	80007fb6 <get_arg+0x266>
80007dfe:	a5 b4       	sbr	r4,0x5
80007e00:	cd b8       	rjmp	80007fb6 <get_arg+0x266>
80007e02:	08 9a       	mov	r10,r4
80007e04:	0e 9b       	mov	r11,r7
80007e06:	a5 aa       	sbr	r10,0x4
80007e08:	17 3c       	ld.ub	r12,r11++
80007e0a:	a5 b4       	sbr	r4,0x5
80007e0c:	36 ce       	mov	lr,108
80007e0e:	fc 0c 18 00 	cp.b	r12,lr
80007e12:	e0 80 00 d3 	breq	80007fb8 <get_arg+0x268>
80007e16:	14 94       	mov	r4,r10
80007e18:	cc f8       	rjmp	80007fb6 <get_arg+0x266>
80007e1a:	eb d5 c0 05 	bfextu	r5,r5,0x0,0x5
80007e1e:	36 7c       	mov	r12,103
80007e20:	f8 0a 18 00 	cp.b	r10,r12
80007e24:	e0 8b 00 27 	brhi	80007e72 <get_arg+0x122>
80007e28:	36 5b       	mov	r11,101
80007e2a:	f6 0a 18 00 	cp.b	r10,r11
80007e2e:	c4 82       	brcc	80007ebe <get_arg+0x16e>
80007e30:	34 fb       	mov	r11,79
80007e32:	f6 0a 18 00 	cp.b	r10,r11
80007e36:	c4 80       	breq	80007ec6 <get_arg+0x176>
80007e38:	e0 8b 00 0c 	brhi	80007e50 <get_arg+0x100>
80007e3c:	34 5b       	mov	r11,69
80007e3e:	f6 0a 18 00 	cp.b	r10,r11
80007e42:	c3 e0       	breq	80007ebe <get_arg+0x16e>
80007e44:	34 7b       	mov	r11,71
80007e46:	f6 0a 18 00 	cp.b	r10,r11
80007e4a:	c3 a0       	breq	80007ebe <get_arg+0x16e>
80007e4c:	34 4b       	mov	r11,68
80007e4e:	c0 88       	rjmp	80007e5e <get_arg+0x10e>
80007e50:	35 8b       	mov	r11,88
80007e52:	f6 0a 18 00 	cp.b	r10,r11
80007e56:	c2 c0       	breq	80007eae <get_arg+0x15e>
80007e58:	e0 8b 00 07 	brhi	80007e66 <get_arg+0x116>
80007e5c:	35 5b       	mov	r11,85
80007e5e:	f6 0a 18 00 	cp.b	r10,r11
80007e62:	c3 51       	brne	80007ecc <get_arg+0x17c>
80007e64:	c3 18       	rjmp	80007ec6 <get_arg+0x176>
80007e66:	36 3b       	mov	r11,99
80007e68:	f6 0a 18 00 	cp.b	r10,r11
80007e6c:	c2 f0       	breq	80007eca <get_arg+0x17a>
80007e6e:	36 4b       	mov	r11,100
80007e70:	c0 e8       	rjmp	80007e8c <get_arg+0x13c>
80007e72:	37 0b       	mov	r11,112
80007e74:	f6 0a 18 00 	cp.b	r10,r11
80007e78:	c2 50       	breq	80007ec2 <get_arg+0x172>
80007e7a:	e0 8b 00 0d 	brhi	80007e94 <get_arg+0x144>
80007e7e:	36 eb       	mov	r11,110
80007e80:	f6 0a 18 00 	cp.b	r10,r11
80007e84:	c1 f0       	breq	80007ec2 <get_arg+0x172>
80007e86:	e0 8b 00 14 	brhi	80007eae <get_arg+0x15e>
80007e8a:	36 9b       	mov	r11,105
80007e8c:	f6 0a 18 00 	cp.b	r10,r11
80007e90:	c1 e1       	brne	80007ecc <get_arg+0x17c>
80007e92:	c0 e8       	rjmp	80007eae <get_arg+0x15e>
80007e94:	37 5b       	mov	r11,117
80007e96:	f6 0a 18 00 	cp.b	r10,r11
80007e9a:	c0 a0       	breq	80007eae <get_arg+0x15e>
80007e9c:	37 8b       	mov	r11,120
80007e9e:	f6 0a 18 00 	cp.b	r10,r11
80007ea2:	c0 60       	breq	80007eae <get_arg+0x15e>
80007ea4:	37 3b       	mov	r11,115
80007ea6:	f6 0a 18 00 	cp.b	r10,r11
80007eaa:	c1 11       	brne	80007ecc <get_arg+0x17c>
80007eac:	c0 b8       	rjmp	80007ec2 <get_arg+0x172>
80007eae:	ed b4 00 04 	bld	r4,0x4
80007eb2:	c0 a0       	breq	80007ec6 <get_arg+0x176>
80007eb4:	ed b4 00 05 	bld	r4,0x5
80007eb8:	c0 91       	brne	80007eca <get_arg+0x17a>
80007eba:	30 20       	mov	r0,2
80007ebc:	c0 88       	rjmp	80007ecc <get_arg+0x17c>
80007ebe:	30 40       	mov	r0,4
80007ec0:	c0 68       	rjmp	80007ecc <get_arg+0x17c>
80007ec2:	30 30       	mov	r0,3
80007ec4:	c0 48       	rjmp	80007ecc <get_arg+0x17c>
80007ec6:	30 10       	mov	r0,1
80007ec8:	c0 28       	rjmp	80007ecc <get_arg+0x17c>
80007eca:	30 00       	mov	r0,0
80007ecc:	40 3b       	lddsp	r11,sp[0xc]
80007ece:	5b fb       	cp.w	r11,-1
80007ed0:	c0 40       	breq	80007ed8 <get_arg+0x188>
80007ed2:	e2 0b 09 20 	st.w	r1[r11<<0x2],r0
80007ed6:	c7 08       	rjmp	80007fb6 <get_arg+0x266>
80007ed8:	58 60       	cp.w	r0,6
80007eda:	e0 8b 00 6e 	brhi	80007fb6 <get_arg+0x266>
80007ede:	6c 0a       	ld.w	r10,r6[0x0]
80007ee0:	ea cc ff ff 	sub	r12,r5,-1
80007ee4:	fe ce a1 90 	sub	lr,pc,-24176
80007ee8:	fc 00 03 2f 	ld.w	pc,lr[r0<<0x2]
80007eec:	f4 cb ff f8 	sub	r11,r10,-8
80007ef0:	8d 0b       	st.w	r6[0x0],r11
80007ef2:	f4 ea 00 00 	ld.d	r10,r10[0]
80007ef6:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80007efa:	c0 f8       	rjmp	80007f18 <get_arg+0x1c8>
80007efc:	f4 cb ff fc 	sub	r11,r10,-4
80007f00:	8d 0b       	st.w	r6[0x0],r11
80007f02:	74 0a       	ld.w	r10,r10[0x0]
80007f04:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80007f08:	c0 88       	rjmp	80007f18 <get_arg+0x1c8>
80007f0a:	f4 cb ff f8 	sub	r11,r10,-8
80007f0e:	8d 0b       	st.w	r6[0x0],r11
80007f10:	f4 ea 00 00 	ld.d	r10,r10[0]
80007f14:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80007f18:	0e 9b       	mov	r11,r7
80007f1a:	18 95       	mov	r5,r12
80007f1c:	c4 e8       	rjmp	80007fb8 <get_arg+0x268>
80007f1e:	62 0a       	ld.w	r10,r1[0x0]
80007f20:	5b fa       	cp.w	r10,-1
80007f22:	c0 b1       	brne	80007f38 <get_arg+0x1e8>
80007f24:	50 19       	stdsp	sp[0x4],r9
80007f26:	50 28       	stdsp	sp[0x8],r8
80007f28:	e0 6a 00 80 	mov	r10,128
80007f2c:	30 0b       	mov	r11,0
80007f2e:	02 9c       	mov	r12,r1
80007f30:	fe b0 fd 00 	rcall	80007930 <memset>
80007f34:	40 28       	lddsp	r8,sp[0x8]
80007f36:	40 19       	lddsp	r9,sp[0x4]
80007f38:	e4 cc 00 01 	sub	r12,r2,1
80007f3c:	0e 9b       	mov	r11,r7
80007f3e:	50 3c       	stdsp	sp[0xc],r12
80007f40:	f2 0c 0c 49 	max	r9,r9,r12
80007f44:	c3 a8       	rjmp	80007fb8 <get_arg+0x268>
80007f46:	62 0a       	ld.w	r10,r1[0x0]
80007f48:	5b fa       	cp.w	r10,-1
80007f4a:	c0 b1       	brne	80007f60 <get_arg+0x210>
80007f4c:	50 19       	stdsp	sp[0x4],r9
80007f4e:	50 28       	stdsp	sp[0x8],r8
80007f50:	e0 6a 00 80 	mov	r10,128
80007f54:	30 0b       	mov	r11,0
80007f56:	02 9c       	mov	r12,r1
80007f58:	fe b0 fc ec 	rcall	80007930 <memset>
80007f5c:	40 28       	lddsp	r8,sp[0x8]
80007f5e:	40 19       	lddsp	r9,sp[0x4]
80007f60:	20 12       	sub	r2,1
80007f62:	30 0a       	mov	r10,0
80007f64:	0e 9b       	mov	r11,r7
80007f66:	e2 02 09 2a 	st.w	r1[r2<<0x2],r10
80007f6a:	f2 02 0c 49 	max	r9,r9,r2
80007f6e:	c2 58       	rjmp	80007fb8 <get_arg+0x268>
80007f70:	16 97       	mov	r7,r11
80007f72:	6c 0a       	ld.w	r10,r6[0x0]
80007f74:	f4 cb ff fc 	sub	r11,r10,-4
80007f78:	8d 0b       	st.w	r6[0x0],r11
80007f7a:	74 0a       	ld.w	r10,r10[0x0]
80007f7c:	0e 9b       	mov	r11,r7
80007f7e:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80007f82:	2f f5       	sub	r5,-1
80007f84:	c1 a8       	rjmp	80007fb8 <get_arg+0x268>
80007f86:	f4 c2 00 30 	sub	r2,r10,48
80007f8a:	c0 68       	rjmp	80007f96 <get_arg+0x246>
80007f8c:	e4 02 00 22 	add	r2,r2,r2<<0x2
80007f90:	2f f7       	sub	r7,-1
80007f92:	f4 02 00 12 	add	r2,r10,r2<<0x1
80007f96:	0f 8a       	ld.ub	r10,r7[0x0]
80007f98:	58 0a       	cp.w	r10,0
80007f9a:	c0 e0       	breq	80007fb6 <get_arg+0x266>
80007f9c:	23 0a       	sub	r10,48
80007f9e:	58 9a       	cp.w	r10,9
80007fa0:	fe 98 ff f6 	brls	80007f8c <get_arg+0x23c>
80007fa4:	c0 98       	rjmp	80007fb6 <get_arg+0x266>
80007fa6:	2f f7       	sub	r7,-1
80007fa8:	0f 8a       	ld.ub	r10,r7[0x0]
80007faa:	58 0a       	cp.w	r10,0
80007fac:	c0 50       	breq	80007fb6 <get_arg+0x266>
80007fae:	23 0a       	sub	r10,48
80007fb0:	58 9a       	cp.w	r10,9
80007fb2:	fe 98 ff fa 	brls	80007fa6 <get_arg+0x256>
80007fb6:	0e 9b       	mov	r11,r7
80007fb8:	40 7c       	lddsp	r12,sp[0x1c]
80007fba:	30 ba       	mov	r10,11
80007fbc:	f4 0c 18 00 	cp.b	r12,r10
80007fc0:	fe 91 fe f2 	brne	80007da4 <get_arg+0x54>
80007fc4:	40 42       	lddsp	r2,sp[0x10]
80007fc6:	17 8c       	ld.ub	r12,r11[0x0]
80007fc8:	0a 32       	cp.w	r2,r5
80007fca:	5f 4a       	srge	r10
80007fcc:	f0 0c 18 00 	cp.b	r12,r8
80007fd0:	5f 1c       	srne	r12
80007fd2:	f9 ea 00 0a 	and	r10,r12,r10
80007fd6:	f0 0a 18 00 	cp.b	r10,r8
80007fda:	fe 91 fe cf 	brne	80007d78 <get_arg+0x28>
80007fde:	30 08       	mov	r8,0
80007fe0:	40 4e       	lddsp	lr,sp[0x10]
80007fe2:	17 8a       	ld.ub	r10,r11[0x0]
80007fe4:	e2 05 00 21 	add	r1,r1,r5<<0x2
80007fe8:	f0 0a 18 00 	cp.b	r10,r8
80007fec:	fc 09 17 10 	movne	r9,lr
80007ff0:	e6 05 00 38 	add	r8,r3,r5<<0x3
80007ff4:	06 9e       	mov	lr,r3
80007ff6:	c2 a8       	rjmp	8000804a <get_arg+0x2fa>
80007ff8:	62 0a       	ld.w	r10,r1[0x0]
80007ffa:	58 3a       	cp.w	r10,3
80007ffc:	c1 e0       	breq	80008038 <get_arg+0x2e8>
80007ffe:	e0 89 00 07 	brgt	8000800c <get_arg+0x2bc>
80008002:	58 1a       	cp.w	r10,1
80008004:	c1 a0       	breq	80008038 <get_arg+0x2e8>
80008006:	58 2a       	cp.w	r10,2
80008008:	c1 81       	brne	80008038 <get_arg+0x2e8>
8000800a:	c0 58       	rjmp	80008014 <get_arg+0x2c4>
8000800c:	58 5a       	cp.w	r10,5
8000800e:	c0 c0       	breq	80008026 <get_arg+0x2d6>
80008010:	c0 b5       	brlt	80008026 <get_arg+0x2d6>
80008012:	c1 38       	rjmp	80008038 <get_arg+0x2e8>
80008014:	6c 0a       	ld.w	r10,r6[0x0]
80008016:	f4 cc ff f8 	sub	r12,r10,-8
8000801a:	8d 0c       	st.w	r6[0x0],r12
8000801c:	f4 e2 00 00 	ld.d	r2,r10[0]
80008020:	f0 e3 00 00 	st.d	r8[0],r2
80008024:	c1 08       	rjmp	80008044 <get_arg+0x2f4>
80008026:	6c 0a       	ld.w	r10,r6[0x0]
80008028:	f4 cc ff f8 	sub	r12,r10,-8
8000802c:	8d 0c       	st.w	r6[0x0],r12
8000802e:	f4 e2 00 00 	ld.d	r2,r10[0]
80008032:	f0 e3 00 00 	st.d	r8[0],r2
80008036:	c0 78       	rjmp	80008044 <get_arg+0x2f4>
80008038:	6c 0a       	ld.w	r10,r6[0x0]
8000803a:	f4 cc ff fc 	sub	r12,r10,-4
8000803e:	8d 0c       	st.w	r6[0x0],r12
80008040:	74 0a       	ld.w	r10,r10[0x0]
80008042:	91 0a       	st.w	r8[0x0],r10
80008044:	2f f5       	sub	r5,-1
80008046:	2f 88       	sub	r8,-8
80008048:	2f c1       	sub	r1,-4
8000804a:	12 35       	cp.w	r5,r9
8000804c:	fe 9a ff d6 	brle	80007ff8 <get_arg+0x2a8>
80008050:	1c 93       	mov	r3,lr
80008052:	40 52       	lddsp	r2,sp[0x14]
80008054:	40 6e       	lddsp	lr,sp[0x18]
80008056:	85 05       	st.w	r2[0x0],r5
80008058:	9d 0b       	st.w	lr[0x0],r11
8000805a:	40 4b       	lddsp	r11,sp[0x10]
8000805c:	e6 0b 00 3c 	add	r12,r3,r11<<0x3
80008060:	2f 8d       	sub	sp,-32
80008062:	d8 32       	popm	r0-r7,pc

80008064 <__sprint_r>:
80008064:	d4 21       	pushm	r4-r7,lr
80008066:	14 97       	mov	r7,r10
80008068:	74 28       	ld.w	r8,r10[0x8]
8000806a:	58 08       	cp.w	r8,0
8000806c:	c0 41       	brne	80008074 <__sprint_r+0x10>
8000806e:	95 18       	st.w	r10[0x4],r8
80008070:	10 9c       	mov	r12,r8
80008072:	d8 22       	popm	r4-r7,pc
80008074:	e0 a0 18 ba 	rcall	8000b1e8 <__sfvwrite_r>
80008078:	30 08       	mov	r8,0
8000807a:	8f 18       	st.w	r7[0x4],r8
8000807c:	8f 28       	st.w	r7[0x8],r8
8000807e:	d8 22       	popm	r4-r7,pc

80008080 <_vfprintf_r>:
80008080:	d4 31       	pushm	r0-r7,lr
80008082:	fa cd 06 bc 	sub	sp,sp,1724
80008086:	51 09       	stdsp	sp[0x40],r9
80008088:	16 91       	mov	r1,r11
8000808a:	14 97       	mov	r7,r10
8000808c:	18 95       	mov	r5,r12
8000808e:	e0 a0 1a 1d 	rcall	8000b4c8 <_localeconv_r>
80008092:	78 0c       	ld.w	r12,r12[0x0]
80008094:	50 cc       	stdsp	sp[0x30],r12
80008096:	58 05       	cp.w	r5,0
80008098:	c0 70       	breq	800080a6 <_vfprintf_r+0x26>
8000809a:	6a 68       	ld.w	r8,r5[0x18]
8000809c:	58 08       	cp.w	r8,0
8000809e:	c0 41       	brne	800080a6 <_vfprintf_r+0x26>
800080a0:	0a 9c       	mov	r12,r5
800080a2:	e0 a0 17 43 	rcall	8000af28 <__sinit>
800080a6:	fe c8 9f 8e 	sub	r8,pc,-24690
800080aa:	10 31       	cp.w	r1,r8
800080ac:	c0 31       	brne	800080b2 <_vfprintf_r+0x32>
800080ae:	6a 01       	ld.w	r1,r5[0x0]
800080b0:	c0 c8       	rjmp	800080c8 <_vfprintf_r+0x48>
800080b2:	fe c8 9f 7a 	sub	r8,pc,-24710
800080b6:	10 31       	cp.w	r1,r8
800080b8:	c0 31       	brne	800080be <_vfprintf_r+0x3e>
800080ba:	6a 11       	ld.w	r1,r5[0x4]
800080bc:	c0 68       	rjmp	800080c8 <_vfprintf_r+0x48>
800080be:	fe c8 9f 66 	sub	r8,pc,-24730
800080c2:	10 31       	cp.w	r1,r8
800080c4:	eb f1 00 02 	ld.weq	r1,r5[0x8]
800080c8:	82 68       	ld.sh	r8,r1[0xc]
800080ca:	ed b8 00 03 	bld	r8,0x3
800080ce:	c0 41       	brne	800080d6 <_vfprintf_r+0x56>
800080d0:	62 48       	ld.w	r8,r1[0x10]
800080d2:	58 08       	cp.w	r8,0
800080d4:	c0 71       	brne	800080e2 <_vfprintf_r+0x62>
800080d6:	02 9b       	mov	r11,r1
800080d8:	0a 9c       	mov	r12,r5
800080da:	e0 a0 0f 5d 	rcall	80009f94 <__swsetup_r>
800080de:	e0 81 0f 54 	brne	80009f86 <_vfprintf_r+0x1f06>
800080e2:	82 68       	ld.sh	r8,r1[0xc]
800080e4:	10 99       	mov	r9,r8
800080e6:	e2 19 00 1a 	andl	r9,0x1a,COH
800080ea:	58 a9       	cp.w	r9,10
800080ec:	c3 c1       	brne	80008164 <_vfprintf_r+0xe4>
800080ee:	82 79       	ld.sh	r9,r1[0xe]
800080f0:	30 0a       	mov	r10,0
800080f2:	f4 09 19 00 	cp.h	r9,r10
800080f6:	c3 75       	brlt	80008164 <_vfprintf_r+0xe4>
800080f8:	a1 d8       	cbr	r8,0x1
800080fa:	fb 58 05 d0 	st.h	sp[1488],r8
800080fe:	62 88       	ld.w	r8,r1[0x20]
80008100:	fb 48 05 e4 	st.w	sp[1508],r8
80008104:	62 a8       	ld.w	r8,r1[0x28]
80008106:	fb 48 05 ec 	st.w	sp[1516],r8
8000810a:	fa c8 ff bc 	sub	r8,sp,-68
8000810e:	fb 48 05 d4 	st.w	sp[1492],r8
80008112:	fb 48 05 c4 	st.w	sp[1476],r8
80008116:	e0 68 04 00 	mov	r8,1024
8000811a:	fb 48 05 d8 	st.w	sp[1496],r8
8000811e:	fb 48 05 cc 	st.w	sp[1484],r8
80008122:	30 08       	mov	r8,0
80008124:	fb 59 05 d2 	st.h	sp[1490],r9
80008128:	0e 9a       	mov	r10,r7
8000812a:	41 09       	lddsp	r9,sp[0x40]
8000812c:	fa c7 fa 3c 	sub	r7,sp,-1476
80008130:	fb 48 05 dc 	st.w	sp[1500],r8
80008134:	0a 9c       	mov	r12,r5
80008136:	0e 9b       	mov	r11,r7
80008138:	ca 4f       	rcall	80008080 <_vfprintf_r>
8000813a:	50 bc       	stdsp	sp[0x2c],r12
8000813c:	c0 95       	brlt	8000814e <_vfprintf_r+0xce>
8000813e:	0e 9b       	mov	r11,r7
80008140:	0a 9c       	mov	r12,r5
80008142:	e0 a0 16 1b 	rcall	8000ad78 <_fflush_r>
80008146:	40 be       	lddsp	lr,sp[0x2c]
80008148:	f9 be 01 ff 	movne	lr,-1
8000814c:	50 be       	stdsp	sp[0x2c],lr
8000814e:	fb 08 05 d0 	ld.sh	r8,sp[1488]
80008152:	ed b8 00 06 	bld	r8,0x6
80008156:	e0 81 0f 1a 	brne	80009f8a <_vfprintf_r+0x1f0a>
8000815a:	82 68       	ld.sh	r8,r1[0xc]
8000815c:	a7 a8       	sbr	r8,0x6
8000815e:	a2 68       	st.h	r1[0xc],r8
80008160:	e0 8f 0f 15 	bral	80009f8a <_vfprintf_r+0x1f0a>
80008164:	30 08       	mov	r8,0
80008166:	fb 48 06 b4 	st.w	sp[1716],r8
8000816a:	fb 48 06 90 	st.w	sp[1680],r8
8000816e:	fb 48 06 8c 	st.w	sp[1676],r8
80008172:	fb 48 06 b0 	st.w	sp[1712],r8
80008176:	30 08       	mov	r8,0
80008178:	30 09       	mov	r9,0
8000817a:	50 a7       	stdsp	sp[0x28],r7
8000817c:	50 78       	stdsp	sp[0x1c],r8
8000817e:	fa c3 f9 e0 	sub	r3,sp,-1568
80008182:	3f f8       	mov	r8,-1
80008184:	50 59       	stdsp	sp[0x14],r9
80008186:	fb 43 06 88 	st.w	sp[1672],r3
8000818a:	fb 48 05 44 	st.w	sp[1348],r8
8000818e:	12 9c       	mov	r12,r9
80008190:	50 69       	stdsp	sp[0x18],r9
80008192:	50 d9       	stdsp	sp[0x34],r9
80008194:	50 e9       	stdsp	sp[0x38],r9
80008196:	50 b9       	stdsp	sp[0x2c],r9
80008198:	12 97       	mov	r7,r9
8000819a:	0a 94       	mov	r4,r5
8000819c:	40 a2       	lddsp	r2,sp[0x28]
8000819e:	32 5a       	mov	r10,37
800081a0:	30 08       	mov	r8,0
800081a2:	c0 28       	rjmp	800081a6 <_vfprintf_r+0x126>
800081a4:	2f f2       	sub	r2,-1
800081a6:	05 89       	ld.ub	r9,r2[0x0]
800081a8:	f0 09 18 00 	cp.b	r9,r8
800081ac:	5f 1b       	srne	r11
800081ae:	f4 09 18 00 	cp.b	r9,r10
800081b2:	5f 19       	srne	r9
800081b4:	f3 eb 00 0b 	and	r11,r9,r11
800081b8:	f0 0b 18 00 	cp.b	r11,r8
800081bc:	cf 41       	brne	800081a4 <_vfprintf_r+0x124>
800081be:	40 ab       	lddsp	r11,sp[0x28]
800081c0:	e4 0b 01 06 	sub	r6,r2,r11
800081c4:	c1 e0       	breq	80008200 <_vfprintf_r+0x180>
800081c6:	fa f8 06 90 	ld.w	r8,sp[1680]
800081ca:	0c 08       	add	r8,r6
800081cc:	87 0b       	st.w	r3[0x0],r11
800081ce:	fb 48 06 90 	st.w	sp[1680],r8
800081d2:	87 16       	st.w	r3[0x4],r6
800081d4:	fa f8 06 8c 	ld.w	r8,sp[1676]
800081d8:	2f f8       	sub	r8,-1
800081da:	fb 48 06 8c 	st.w	sp[1676],r8
800081de:	58 78       	cp.w	r8,7
800081e0:	e0 89 00 04 	brgt	800081e8 <_vfprintf_r+0x168>
800081e4:	2f 83       	sub	r3,-8
800081e6:	c0 a8       	rjmp	800081fa <_vfprintf_r+0x17a>
800081e8:	fa ca f9 78 	sub	r10,sp,-1672
800081ec:	02 9b       	mov	r11,r1
800081ee:	08 9c       	mov	r12,r4
800081f0:	c3 af       	rcall	80008064 <__sprint_r>
800081f2:	e0 81 0e c6 	brne	80009f7e <_vfprintf_r+0x1efe>
800081f6:	fa c3 f9 e0 	sub	r3,sp,-1568
800081fa:	40 ba       	lddsp	r10,sp[0x2c]
800081fc:	0c 0a       	add	r10,r6
800081fe:	50 ba       	stdsp	sp[0x2c],r10
80008200:	05 89       	ld.ub	r9,r2[0x0]
80008202:	30 08       	mov	r8,0
80008204:	f0 09 18 00 	cp.b	r9,r8
80008208:	e0 80 0e aa 	breq	80009f5c <_vfprintf_r+0x1edc>
8000820c:	30 09       	mov	r9,0
8000820e:	fb 68 06 bb 	st.b	sp[1723],r8
80008212:	0e 96       	mov	r6,r7
80008214:	e4 c8 ff ff 	sub	r8,r2,-1
80008218:	3f fe       	mov	lr,-1
8000821a:	50 93       	stdsp	sp[0x24],r3
8000821c:	50 41       	stdsp	sp[0x10],r1
8000821e:	0e 93       	mov	r3,r7
80008220:	04 91       	mov	r1,r2
80008222:	50 89       	stdsp	sp[0x20],r9
80008224:	50 a8       	stdsp	sp[0x28],r8
80008226:	50 2e       	stdsp	sp[0x8],lr
80008228:	50 39       	stdsp	sp[0xc],r9
8000822a:	12 95       	mov	r5,r9
8000822c:	12 90       	mov	r0,r9
8000822e:	10 97       	mov	r7,r8
80008230:	08 92       	mov	r2,r4
80008232:	c0 78       	rjmp	80008240 <_vfprintf_r+0x1c0>
80008234:	3f fc       	mov	r12,-1
80008236:	08 97       	mov	r7,r4
80008238:	50 2c       	stdsp	sp[0x8],r12
8000823a:	c0 38       	rjmp	80008240 <_vfprintf_r+0x1c0>
8000823c:	30 0b       	mov	r11,0
8000823e:	50 3b       	stdsp	sp[0xc],r11
80008240:	0f 38       	ld.ub	r8,r7++
80008242:	c0 28       	rjmp	80008246 <_vfprintf_r+0x1c6>
80008244:	12 90       	mov	r0,r9
80008246:	f0 c9 00 20 	sub	r9,r8,32
8000824a:	e0 49 00 58 	cp.w	r9,88
8000824e:	e0 8b 0a 30 	brhi	800096ae <_vfprintf_r+0x162e>
80008252:	fe ca a4 e2 	sub	r10,pc,-23326
80008256:	f4 09 03 2f 	ld.w	pc,r10[r9<<0x2]
8000825a:	50 a7       	stdsp	sp[0x28],r7
8000825c:	50 80       	stdsp	sp[0x20],r0
8000825e:	0c 97       	mov	r7,r6
80008260:	04 94       	mov	r4,r2
80008262:	06 96       	mov	r6,r3
80008264:	02 92       	mov	r2,r1
80008266:	fe c9 a2 ba 	sub	r9,pc,-23878
8000826a:	40 93       	lddsp	r3,sp[0x24]
8000826c:	10 90       	mov	r0,r8
8000826e:	40 41       	lddsp	r1,sp[0x10]
80008270:	50 d9       	stdsp	sp[0x34],r9
80008272:	e0 8f 08 8e 	bral	8000938e <_vfprintf_r+0x130e>
80008276:	30 08       	mov	r8,0
80008278:	fb 39 06 bb 	ld.ub	r9,sp[1723]
8000827c:	f0 09 18 00 	cp.b	r9,r8
80008280:	ce 01       	brne	80008240 <_vfprintf_r+0x1c0>
80008282:	32 08       	mov	r8,32
80008284:	c6 e8       	rjmp	80008360 <_vfprintf_r+0x2e0>
80008286:	a1 a5       	sbr	r5,0x0
80008288:	cd cb       	rjmp	80008240 <_vfprintf_r+0x1c0>
8000828a:	0f 89       	ld.ub	r9,r7[0x0]
8000828c:	f2 c8 00 30 	sub	r8,r9,48
80008290:	58 98       	cp.w	r8,9
80008292:	e0 8b 00 1d 	brhi	800082cc <_vfprintf_r+0x24c>
80008296:	ee c8 ff ff 	sub	r8,r7,-1
8000829a:	30 0b       	mov	r11,0
8000829c:	23 09       	sub	r9,48
8000829e:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
800082a2:	f2 0b 00 1b 	add	r11,r9,r11<<0x1
800082a6:	11 39       	ld.ub	r9,r8++
800082a8:	f2 ca 00 30 	sub	r10,r9,48
800082ac:	58 9a       	cp.w	r10,9
800082ae:	fe 98 ff f7 	brls	8000829c <_vfprintf_r+0x21c>
800082b2:	e0 49 00 24 	cp.w	r9,36
800082b6:	cc 31       	brne	8000823c <_vfprintf_r+0x1bc>
800082b8:	e0 4b 00 20 	cp.w	r11,32
800082bc:	e0 89 0e 60 	brgt	80009f7c <_vfprintf_r+0x1efc>
800082c0:	20 1b       	sub	r11,1
800082c2:	fa f9 06 b4 	ld.w	r9,sp[1716]
800082c6:	12 3b       	cp.w	r11,r9
800082c8:	c0 95       	brlt	800082da <_vfprintf_r+0x25a>
800082ca:	c1 08       	rjmp	800082ea <_vfprintf_r+0x26a>
800082cc:	fa f9 06 b4 	ld.w	r9,sp[1716]
800082d0:	ec ca ff ff 	sub	r10,r6,-1
800082d4:	12 36       	cp.w	r6,r9
800082d6:	c1 f5       	brlt	80008314 <_vfprintf_r+0x294>
800082d8:	c2 68       	rjmp	80008324 <_vfprintf_r+0x2a4>
800082da:	fa ce f9 44 	sub	lr,sp,-1724
800082de:	10 97       	mov	r7,r8
800082e0:	fc 0b 00 3b 	add	r11,lr,r11<<0x3
800082e4:	f6 f0 fd 88 	ld.w	r0,r11[-632]
800082e8:	c3 58       	rjmp	80008352 <_vfprintf_r+0x2d2>
800082ea:	10 97       	mov	r7,r8
800082ec:	fa c8 f9 50 	sub	r8,sp,-1712
800082f0:	1a d8       	st.w	--sp,r8
800082f2:	fa c8 fa b8 	sub	r8,sp,-1352
800082f6:	1a d8       	st.w	--sp,r8
800082f8:	fa c8 fb b4 	sub	r8,sp,-1100
800082fc:	02 9a       	mov	r10,r1
800082fe:	1a d8       	st.w	--sp,r8
80008300:	04 9c       	mov	r12,r2
80008302:	fa c8 f9 40 	sub	r8,sp,-1728
80008306:	fa c9 ff b4 	sub	r9,sp,-76
8000830a:	fe b0 fd 23 	rcall	80007d50 <get_arg>
8000830e:	2f dd       	sub	sp,-12
80008310:	78 00       	ld.w	r0,r12[0x0]
80008312:	c2 08       	rjmp	80008352 <_vfprintf_r+0x2d2>
80008314:	fa cc f9 44 	sub	r12,sp,-1724
80008318:	14 96       	mov	r6,r10
8000831a:	f8 03 00 38 	add	r8,r12,r3<<0x3
8000831e:	f0 f0 fd 88 	ld.w	r0,r8[-632]
80008322:	c1 88       	rjmp	80008352 <_vfprintf_r+0x2d2>
80008324:	41 08       	lddsp	r8,sp[0x40]
80008326:	59 f9       	cp.w	r9,31
80008328:	e0 89 00 11 	brgt	8000834a <_vfprintf_r+0x2ca>
8000832c:	f0 cb ff fc 	sub	r11,r8,-4
80008330:	51 0b       	stdsp	sp[0x40],r11
80008332:	70 00       	ld.w	r0,r8[0x0]
80008334:	fa cb f9 44 	sub	r11,sp,-1724
80008338:	f6 09 00 38 	add	r8,r11,r9<<0x3
8000833c:	f1 40 fd 88 	st.w	r8[-632],r0
80008340:	2f f9       	sub	r9,-1
80008342:	14 96       	mov	r6,r10
80008344:	fb 49 06 b4 	st.w	sp[1716],r9
80008348:	c0 58       	rjmp	80008352 <_vfprintf_r+0x2d2>
8000834a:	70 00       	ld.w	r0,r8[0x0]
8000834c:	14 96       	mov	r6,r10
8000834e:	2f c8       	sub	r8,-4
80008350:	51 08       	stdsp	sp[0x40],r8
80008352:	58 00       	cp.w	r0,0
80008354:	fe 94 ff 76 	brge	80008240 <_vfprintf_r+0x1c0>
80008358:	5c 30       	neg	r0
8000835a:	a3 a5       	sbr	r5,0x2
8000835c:	c7 2b       	rjmp	80008240 <_vfprintf_r+0x1c0>
8000835e:	32 b8       	mov	r8,43
80008360:	fb 68 06 bb 	st.b	sp[1723],r8
80008364:	c6 eb       	rjmp	80008240 <_vfprintf_r+0x1c0>
80008366:	0f 38       	ld.ub	r8,r7++
80008368:	e0 48 00 2a 	cp.w	r8,42
8000836c:	c0 30       	breq	80008372 <_vfprintf_r+0x2f2>
8000836e:	30 09       	mov	r9,0
80008370:	c7 98       	rjmp	80008462 <_vfprintf_r+0x3e2>
80008372:	0f 88       	ld.ub	r8,r7[0x0]
80008374:	f0 c9 00 30 	sub	r9,r8,48
80008378:	58 99       	cp.w	r9,9
8000837a:	e0 8b 00 1f 	brhi	800083b8 <_vfprintf_r+0x338>
8000837e:	ee c4 ff ff 	sub	r4,r7,-1
80008382:	30 0b       	mov	r11,0
80008384:	23 08       	sub	r8,48
80008386:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
8000838a:	f0 0b 00 1b 	add	r11,r8,r11<<0x1
8000838e:	09 38       	ld.ub	r8,r4++
80008390:	f0 c9 00 30 	sub	r9,r8,48
80008394:	58 99       	cp.w	r9,9
80008396:	fe 98 ff f7 	brls	80008384 <_vfprintf_r+0x304>
8000839a:	e0 48 00 24 	cp.w	r8,36
8000839e:	fe 91 ff 4f 	brne	8000823c <_vfprintf_r+0x1bc>
800083a2:	e0 4b 00 20 	cp.w	r11,32
800083a6:	e0 89 0d eb 	brgt	80009f7c <_vfprintf_r+0x1efc>
800083aa:	20 1b       	sub	r11,1
800083ac:	fa f8 06 b4 	ld.w	r8,sp[1716]
800083b0:	10 3b       	cp.w	r11,r8
800083b2:	c0 a5       	brlt	800083c6 <_vfprintf_r+0x346>
800083b4:	c1 18       	rjmp	800083d6 <_vfprintf_r+0x356>
800083b6:	d7 03       	nop
800083b8:	fa fa 06 b4 	ld.w	r10,sp[1716]
800083bc:	ec c9 ff ff 	sub	r9,r6,-1
800083c0:	14 36       	cp.w	r6,r10
800083c2:	c1 f5       	brlt	80008400 <_vfprintf_r+0x380>
800083c4:	c2 88       	rjmp	80008414 <_vfprintf_r+0x394>
800083c6:	fa ca f9 44 	sub	r10,sp,-1724
800083ca:	f4 0b 00 3b 	add	r11,r10,r11<<0x3
800083ce:	f6 fb fd 88 	ld.w	r11,r11[-632]
800083d2:	50 2b       	stdsp	sp[0x8],r11
800083d4:	c3 c8       	rjmp	8000844c <_vfprintf_r+0x3cc>
800083d6:	fa c8 f9 50 	sub	r8,sp,-1712
800083da:	1a d8       	st.w	--sp,r8
800083dc:	fa c8 fa b8 	sub	r8,sp,-1352
800083e0:	1a d8       	st.w	--sp,r8
800083e2:	fa c8 fb b4 	sub	r8,sp,-1100
800083e6:	02 9a       	mov	r10,r1
800083e8:	1a d8       	st.w	--sp,r8
800083ea:	04 9c       	mov	r12,r2
800083ec:	fa c8 f9 40 	sub	r8,sp,-1728
800083f0:	fa c9 ff b4 	sub	r9,sp,-76
800083f4:	fe b0 fc ae 	rcall	80007d50 <get_arg>
800083f8:	2f dd       	sub	sp,-12
800083fa:	78 0c       	ld.w	r12,r12[0x0]
800083fc:	50 2c       	stdsp	sp[0x8],r12
800083fe:	c2 78       	rjmp	8000844c <_vfprintf_r+0x3cc>
80008400:	12 96       	mov	r6,r9
80008402:	0e 94       	mov	r4,r7
80008404:	fa c9 f9 44 	sub	r9,sp,-1724
80008408:	f2 03 00 38 	add	r8,r9,r3<<0x3
8000840c:	f0 f8 fd 88 	ld.w	r8,r8[-632]
80008410:	50 28       	stdsp	sp[0x8],r8
80008412:	c1 d8       	rjmp	8000844c <_vfprintf_r+0x3cc>
80008414:	41 08       	lddsp	r8,sp[0x40]
80008416:	59 fa       	cp.w	r10,31
80008418:	e0 89 00 14 	brgt	80008440 <_vfprintf_r+0x3c0>
8000841c:	f0 cb ff fc 	sub	r11,r8,-4
80008420:	70 08       	ld.w	r8,r8[0x0]
80008422:	51 0b       	stdsp	sp[0x40],r11
80008424:	50 28       	stdsp	sp[0x8],r8
80008426:	fa c6 f9 44 	sub	r6,sp,-1724
8000842a:	40 2e       	lddsp	lr,sp[0x8]
8000842c:	ec 0a 00 38 	add	r8,r6,r10<<0x3
80008430:	f1 4e fd 88 	st.w	r8[-632],lr
80008434:	2f fa       	sub	r10,-1
80008436:	0e 94       	mov	r4,r7
80008438:	fb 4a 06 b4 	st.w	sp[1716],r10
8000843c:	12 96       	mov	r6,r9
8000843e:	c0 78       	rjmp	8000844c <_vfprintf_r+0x3cc>
80008440:	70 0c       	ld.w	r12,r8[0x0]
80008442:	0e 94       	mov	r4,r7
80008444:	2f c8       	sub	r8,-4
80008446:	50 2c       	stdsp	sp[0x8],r12
80008448:	12 96       	mov	r6,r9
8000844a:	51 08       	stdsp	sp[0x40],r8
8000844c:	40 2b       	lddsp	r11,sp[0x8]
8000844e:	58 0b       	cp.w	r11,0
80008450:	fe 95 fe f2 	brlt	80008234 <_vfprintf_r+0x1b4>
80008454:	08 97       	mov	r7,r4
80008456:	cf 5a       	rjmp	80008240 <_vfprintf_r+0x1c0>
80008458:	f2 09 00 29 	add	r9,r9,r9<<0x2
8000845c:	0f 38       	ld.ub	r8,r7++
8000845e:	f4 09 00 19 	add	r9,r10,r9<<0x1
80008462:	f0 ca 00 30 	sub	r10,r8,48
80008466:	58 9a       	cp.w	r10,9
80008468:	fe 98 ff f8 	brls	80008458 <_vfprintf_r+0x3d8>
8000846c:	3f fa       	mov	r10,-1
8000846e:	f2 0a 0c 49 	max	r9,r9,r10
80008472:	50 29       	stdsp	sp[0x8],r9
80008474:	ce 9a       	rjmp	80008246 <_vfprintf_r+0x1c6>
80008476:	a7 b5       	sbr	r5,0x7
80008478:	ce 4a       	rjmp	80008240 <_vfprintf_r+0x1c0>
8000847a:	30 09       	mov	r9,0
8000847c:	23 08       	sub	r8,48
8000847e:	f2 09 00 29 	add	r9,r9,r9<<0x2
80008482:	f0 09 00 19 	add	r9,r8,r9<<0x1
80008486:	0f 38       	ld.ub	r8,r7++
80008488:	f0 ca 00 30 	sub	r10,r8,48
8000848c:	58 9a       	cp.w	r10,9
8000848e:	fe 98 ff f7 	brls	8000847c <_vfprintf_r+0x3fc>
80008492:	e0 48 00 24 	cp.w	r8,36
80008496:	fe 91 fe d7 	brne	80008244 <_vfprintf_r+0x1c4>
8000849a:	e0 49 00 20 	cp.w	r9,32
8000849e:	e0 89 0d 6f 	brgt	80009f7c <_vfprintf_r+0x1efc>
800084a2:	f2 c3 00 01 	sub	r3,r9,1
800084a6:	30 19       	mov	r9,1
800084a8:	50 39       	stdsp	sp[0xc],r9
800084aa:	cc ba       	rjmp	80008240 <_vfprintf_r+0x1c0>
800084ac:	a3 b5       	sbr	r5,0x3
800084ae:	cc 9a       	rjmp	80008240 <_vfprintf_r+0x1c0>
800084b0:	a7 a5       	sbr	r5,0x6
800084b2:	cc 7a       	rjmp	80008240 <_vfprintf_r+0x1c0>
800084b4:	0a 98       	mov	r8,r5
800084b6:	a5 b5       	sbr	r5,0x5
800084b8:	a5 a8       	sbr	r8,0x4
800084ba:	0f 89       	ld.ub	r9,r7[0x0]
800084bc:	36 ce       	mov	lr,108
800084be:	fc 09 18 00 	cp.b	r9,lr
800084c2:	f7 b7 00 ff 	subeq	r7,-1
800084c6:	f0 05 17 10 	movne	r5,r8
800084ca:	cb ba       	rjmp	80008240 <_vfprintf_r+0x1c0>
800084cc:	a5 b5       	sbr	r5,0x5
800084ce:	cb 9a       	rjmp	80008240 <_vfprintf_r+0x1c0>
800084d0:	50 a7       	stdsp	sp[0x28],r7
800084d2:	50 80       	stdsp	sp[0x20],r0
800084d4:	0c 97       	mov	r7,r6
800084d6:	10 90       	mov	r0,r8
800084d8:	06 96       	mov	r6,r3
800084da:	04 94       	mov	r4,r2
800084dc:	40 93       	lddsp	r3,sp[0x24]
800084de:	02 92       	mov	r2,r1
800084e0:	0e 99       	mov	r9,r7
800084e2:	40 41       	lddsp	r1,sp[0x10]
800084e4:	fa f8 06 b4 	ld.w	r8,sp[1716]
800084e8:	40 3c       	lddsp	r12,sp[0xc]
800084ea:	58 0c       	cp.w	r12,0
800084ec:	c1 d0       	breq	80008526 <_vfprintf_r+0x4a6>
800084ee:	10 36       	cp.w	r6,r8
800084f0:	c0 64       	brge	800084fc <_vfprintf_r+0x47c>
800084f2:	fa cb f9 44 	sub	r11,sp,-1724
800084f6:	f6 06 00 36 	add	r6,r11,r6<<0x3
800084fa:	c1 d8       	rjmp	80008534 <_vfprintf_r+0x4b4>
800084fc:	fa c8 f9 50 	sub	r8,sp,-1712
80008500:	1a d8       	st.w	--sp,r8
80008502:	fa c8 fa b8 	sub	r8,sp,-1352
80008506:	1a d8       	st.w	--sp,r8
80008508:	fa c8 fb b4 	sub	r8,sp,-1100
8000850c:	1a d8       	st.w	--sp,r8
8000850e:	fa c8 f9 40 	sub	r8,sp,-1728
80008512:	fa c9 ff b4 	sub	r9,sp,-76
80008516:	04 9a       	mov	r10,r2
80008518:	0c 9b       	mov	r11,r6
8000851a:	08 9c       	mov	r12,r4
8000851c:	fe b0 fc 1a 	rcall	80007d50 <get_arg>
80008520:	2f dd       	sub	sp,-12
80008522:	19 b8       	ld.ub	r8,r12[0x3]
80008524:	c2 28       	rjmp	80008568 <_vfprintf_r+0x4e8>
80008526:	2f f7       	sub	r7,-1
80008528:	10 39       	cp.w	r9,r8
8000852a:	c0 84       	brge	8000853a <_vfprintf_r+0x4ba>
8000852c:	fa ca f9 44 	sub	r10,sp,-1724
80008530:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008534:	ed 38 fd 8b 	ld.ub	r8,r6[-629]
80008538:	c1 88       	rjmp	80008568 <_vfprintf_r+0x4e8>
8000853a:	41 09       	lddsp	r9,sp[0x40]
8000853c:	59 f8       	cp.w	r8,31
8000853e:	e0 89 00 12 	brgt	80008562 <_vfprintf_r+0x4e2>
80008542:	f2 ca ff fc 	sub	r10,r9,-4
80008546:	51 0a       	stdsp	sp[0x40],r10
80008548:	72 09       	ld.w	r9,r9[0x0]
8000854a:	fa c6 f9 44 	sub	r6,sp,-1724
8000854e:	ec 08 00 3a 	add	r10,r6,r8<<0x3
80008552:	2f f8       	sub	r8,-1
80008554:	f5 49 fd 88 	st.w	r10[-632],r9
80008558:	fb 48 06 b4 	st.w	sp[1716],r8
8000855c:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
80008560:	c0 48       	rjmp	80008568 <_vfprintf_r+0x4e8>
80008562:	13 b8       	ld.ub	r8,r9[0x3]
80008564:	2f c9       	sub	r9,-4
80008566:	51 09       	stdsp	sp[0x40],r9
80008568:	fb 68 06 60 	st.b	sp[1632],r8
8000856c:	30 0e       	mov	lr,0
8000856e:	30 08       	mov	r8,0
80008570:	30 12       	mov	r2,1
80008572:	fb 68 06 bb 	st.b	sp[1723],r8
80008576:	50 2e       	stdsp	sp[0x8],lr
80008578:	e0 8f 08 ad 	bral	800096d2 <_vfprintf_r+0x1652>
8000857c:	50 a7       	stdsp	sp[0x28],r7
8000857e:	50 80       	stdsp	sp[0x20],r0
80008580:	0c 97       	mov	r7,r6
80008582:	04 94       	mov	r4,r2
80008584:	06 96       	mov	r6,r3
80008586:	02 92       	mov	r2,r1
80008588:	40 93       	lddsp	r3,sp[0x24]
8000858a:	10 90       	mov	r0,r8
8000858c:	40 41       	lddsp	r1,sp[0x10]
8000858e:	a5 a5       	sbr	r5,0x4
80008590:	c0 a8       	rjmp	800085a4 <_vfprintf_r+0x524>
80008592:	50 a7       	stdsp	sp[0x28],r7
80008594:	50 80       	stdsp	sp[0x20],r0
80008596:	0c 97       	mov	r7,r6
80008598:	04 94       	mov	r4,r2
8000859a:	06 96       	mov	r6,r3
8000859c:	02 92       	mov	r2,r1
8000859e:	40 93       	lddsp	r3,sp[0x24]
800085a0:	10 90       	mov	r0,r8
800085a2:	40 41       	lddsp	r1,sp[0x10]
800085a4:	ed b5 00 05 	bld	r5,0x5
800085a8:	c5 11       	brne	8000864a <_vfprintf_r+0x5ca>
800085aa:	fa f8 06 b4 	ld.w	r8,sp[1716]
800085ae:	40 3c       	lddsp	r12,sp[0xc]
800085b0:	58 0c       	cp.w	r12,0
800085b2:	c1 e0       	breq	800085ee <_vfprintf_r+0x56e>
800085b4:	10 36       	cp.w	r6,r8
800085b6:	c0 64       	brge	800085c2 <_vfprintf_r+0x542>
800085b8:	fa cb f9 44 	sub	r11,sp,-1724
800085bc:	f6 06 00 36 	add	r6,r11,r6<<0x3
800085c0:	c2 08       	rjmp	80008600 <_vfprintf_r+0x580>
800085c2:	fa c8 f9 50 	sub	r8,sp,-1712
800085c6:	1a d8       	st.w	--sp,r8
800085c8:	fa c8 fa b8 	sub	r8,sp,-1352
800085cc:	0c 9b       	mov	r11,r6
800085ce:	1a d8       	st.w	--sp,r8
800085d0:	fa c8 fb b4 	sub	r8,sp,-1100
800085d4:	1a d8       	st.w	--sp,r8
800085d6:	fa c9 ff b4 	sub	r9,sp,-76
800085da:	fa c8 f9 40 	sub	r8,sp,-1728
800085de:	04 9a       	mov	r10,r2
800085e0:	08 9c       	mov	r12,r4
800085e2:	fe b0 fb b7 	rcall	80007d50 <get_arg>
800085e6:	2f dd       	sub	sp,-12
800085e8:	78 1b       	ld.w	r11,r12[0x4]
800085ea:	78 09       	ld.w	r9,r12[0x0]
800085ec:	c2 b8       	rjmp	80008642 <_vfprintf_r+0x5c2>
800085ee:	ee ca ff ff 	sub	r10,r7,-1
800085f2:	10 37       	cp.w	r7,r8
800085f4:	c0 b4       	brge	8000860a <_vfprintf_r+0x58a>
800085f6:	fa c9 f9 44 	sub	r9,sp,-1724
800085fa:	14 97       	mov	r7,r10
800085fc:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008600:	ec fb fd 8c 	ld.w	r11,r6[-628]
80008604:	ec f9 fd 88 	ld.w	r9,r6[-632]
80008608:	c1 d8       	rjmp	80008642 <_vfprintf_r+0x5c2>
8000860a:	41 09       	lddsp	r9,sp[0x40]
8000860c:	59 f8       	cp.w	r8,31
8000860e:	e0 89 00 14 	brgt	80008636 <_vfprintf_r+0x5b6>
80008612:	f2 cb ff f8 	sub	r11,r9,-8
80008616:	51 0b       	stdsp	sp[0x40],r11
80008618:	fa c6 f9 44 	sub	r6,sp,-1724
8000861c:	72 1b       	ld.w	r11,r9[0x4]
8000861e:	ec 08 00 3c 	add	r12,r6,r8<<0x3
80008622:	72 09       	ld.w	r9,r9[0x0]
80008624:	f9 4b fd 8c 	st.w	r12[-628],r11
80008628:	f9 49 fd 88 	st.w	r12[-632],r9
8000862c:	2f f8       	sub	r8,-1
8000862e:	14 97       	mov	r7,r10
80008630:	fb 48 06 b4 	st.w	sp[1716],r8
80008634:	c0 78       	rjmp	80008642 <_vfprintf_r+0x5c2>
80008636:	f2 c8 ff f8 	sub	r8,r9,-8
8000863a:	72 1b       	ld.w	r11,r9[0x4]
8000863c:	14 97       	mov	r7,r10
8000863e:	51 08       	stdsp	sp[0x40],r8
80008640:	72 09       	ld.w	r9,r9[0x0]
80008642:	16 98       	mov	r8,r11
80008644:	fa e9 00 00 	st.d	sp[0],r8
80008648:	ca e8       	rjmp	800087a4 <_vfprintf_r+0x724>
8000864a:	ed b5 00 04 	bld	r5,0x4
8000864e:	c1 71       	brne	8000867c <_vfprintf_r+0x5fc>
80008650:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008654:	40 3e       	lddsp	lr,sp[0xc]
80008656:	58 0e       	cp.w	lr,0
80008658:	c0 80       	breq	80008668 <_vfprintf_r+0x5e8>
8000865a:	10 36       	cp.w	r6,r8
8000865c:	c6 94       	brge	8000872e <_vfprintf_r+0x6ae>
8000865e:	fa cc f9 44 	sub	r12,sp,-1724
80008662:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008666:	c8 28       	rjmp	8000876a <_vfprintf_r+0x6ea>
80008668:	ee ca ff ff 	sub	r10,r7,-1
8000866c:	10 37       	cp.w	r7,r8
8000866e:	e0 84 00 81 	brge	80008770 <_vfprintf_r+0x6f0>
80008672:	fa cb f9 44 	sub	r11,sp,-1724
80008676:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000867a:	c7 78       	rjmp	80008768 <_vfprintf_r+0x6e8>
8000867c:	ed b5 00 06 	bld	r5,0x6
80008680:	c4 b1       	brne	80008716 <_vfprintf_r+0x696>
80008682:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008686:	40 3c       	lddsp	r12,sp[0xc]
80008688:	58 0c       	cp.w	r12,0
8000868a:	c1 d0       	breq	800086c4 <_vfprintf_r+0x644>
8000868c:	10 36       	cp.w	r6,r8
8000868e:	c0 64       	brge	8000869a <_vfprintf_r+0x61a>
80008690:	fa cb f9 44 	sub	r11,sp,-1724
80008694:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008698:	c1 f8       	rjmp	800086d6 <_vfprintf_r+0x656>
8000869a:	fa c8 f9 50 	sub	r8,sp,-1712
8000869e:	1a d8       	st.w	--sp,r8
800086a0:	fa c8 fa b8 	sub	r8,sp,-1352
800086a4:	1a d8       	st.w	--sp,r8
800086a6:	fa c8 fb b4 	sub	r8,sp,-1100
800086aa:	1a d8       	st.w	--sp,r8
800086ac:	fa c8 f9 40 	sub	r8,sp,-1728
800086b0:	fa c9 ff b4 	sub	r9,sp,-76
800086b4:	04 9a       	mov	r10,r2
800086b6:	0c 9b       	mov	r11,r6
800086b8:	08 9c       	mov	r12,r4
800086ba:	fe b0 fb 4b 	rcall	80007d50 <get_arg>
800086be:	2f dd       	sub	sp,-12
800086c0:	98 18       	ld.sh	r8,r12[0x2]
800086c2:	c2 68       	rjmp	8000870e <_vfprintf_r+0x68e>
800086c4:	ee ca ff ff 	sub	r10,r7,-1
800086c8:	10 37       	cp.w	r7,r8
800086ca:	c0 94       	brge	800086dc <_vfprintf_r+0x65c>
800086cc:	fa c9 f9 44 	sub	r9,sp,-1724
800086d0:	14 97       	mov	r7,r10
800086d2:	f2 06 00 36 	add	r6,r9,r6<<0x3
800086d6:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
800086da:	c1 a8       	rjmp	8000870e <_vfprintf_r+0x68e>
800086dc:	41 09       	lddsp	r9,sp[0x40]
800086de:	59 f8       	cp.w	r8,31
800086e0:	e0 89 00 13 	brgt	80008706 <_vfprintf_r+0x686>
800086e4:	f2 cb ff fc 	sub	r11,r9,-4
800086e8:	51 0b       	stdsp	sp[0x40],r11
800086ea:	72 09       	ld.w	r9,r9[0x0]
800086ec:	fa c6 f9 44 	sub	r6,sp,-1724
800086f0:	ec 08 00 3b 	add	r11,r6,r8<<0x3
800086f4:	2f f8       	sub	r8,-1
800086f6:	f7 49 fd 88 	st.w	r11[-632],r9
800086fa:	fb 48 06 b4 	st.w	sp[1716],r8
800086fe:	14 97       	mov	r7,r10
80008700:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80008704:	c0 58       	rjmp	8000870e <_vfprintf_r+0x68e>
80008706:	92 18       	ld.sh	r8,r9[0x2]
80008708:	14 97       	mov	r7,r10
8000870a:	2f c9       	sub	r9,-4
8000870c:	51 09       	stdsp	sp[0x40],r9
8000870e:	50 18       	stdsp	sp[0x4],r8
80008710:	bf 58       	asr	r8,0x1f
80008712:	50 08       	stdsp	sp[0x0],r8
80008714:	c4 88       	rjmp	800087a4 <_vfprintf_r+0x724>
80008716:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000871a:	40 3c       	lddsp	r12,sp[0xc]
8000871c:	58 0c       	cp.w	r12,0
8000871e:	c1 d0       	breq	80008758 <_vfprintf_r+0x6d8>
80008720:	10 36       	cp.w	r6,r8
80008722:	c0 64       	brge	8000872e <_vfprintf_r+0x6ae>
80008724:	fa cb f9 44 	sub	r11,sp,-1724
80008728:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000872c:	c1 f8       	rjmp	8000876a <_vfprintf_r+0x6ea>
8000872e:	fa c8 f9 50 	sub	r8,sp,-1712
80008732:	1a d8       	st.w	--sp,r8
80008734:	fa c8 fa b8 	sub	r8,sp,-1352
80008738:	0c 9b       	mov	r11,r6
8000873a:	1a d8       	st.w	--sp,r8
8000873c:	fa c8 fb b4 	sub	r8,sp,-1100
80008740:	04 9a       	mov	r10,r2
80008742:	1a d8       	st.w	--sp,r8
80008744:	08 9c       	mov	r12,r4
80008746:	fa c8 f9 40 	sub	r8,sp,-1728
8000874a:	fa c9 ff b4 	sub	r9,sp,-76
8000874e:	fe b0 fb 01 	rcall	80007d50 <get_arg>
80008752:	2f dd       	sub	sp,-12
80008754:	78 0b       	ld.w	r11,r12[0x0]
80008756:	c2 48       	rjmp	8000879e <_vfprintf_r+0x71e>
80008758:	ee ca ff ff 	sub	r10,r7,-1
8000875c:	10 37       	cp.w	r7,r8
8000875e:	c0 94       	brge	80008770 <_vfprintf_r+0x6f0>
80008760:	fa c9 f9 44 	sub	r9,sp,-1724
80008764:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008768:	14 97       	mov	r7,r10
8000876a:	ec fb fd 88 	ld.w	r11,r6[-632]
8000876e:	c1 88       	rjmp	8000879e <_vfprintf_r+0x71e>
80008770:	41 09       	lddsp	r9,sp[0x40]
80008772:	59 f8       	cp.w	r8,31
80008774:	e0 89 00 11 	brgt	80008796 <_vfprintf_r+0x716>
80008778:	f2 cb ff fc 	sub	r11,r9,-4
8000877c:	51 0b       	stdsp	sp[0x40],r11
8000877e:	fa c6 f9 44 	sub	r6,sp,-1724
80008782:	72 0b       	ld.w	r11,r9[0x0]
80008784:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008788:	f3 4b fd 88 	st.w	r9[-632],r11
8000878c:	2f f8       	sub	r8,-1
8000878e:	14 97       	mov	r7,r10
80008790:	fb 48 06 b4 	st.w	sp[1716],r8
80008794:	c0 58       	rjmp	8000879e <_vfprintf_r+0x71e>
80008796:	72 0b       	ld.w	r11,r9[0x0]
80008798:	14 97       	mov	r7,r10
8000879a:	2f c9       	sub	r9,-4
8000879c:	51 09       	stdsp	sp[0x40],r9
8000879e:	50 1b       	stdsp	sp[0x4],r11
800087a0:	bf 5b       	asr	r11,0x1f
800087a2:	50 0b       	stdsp	sp[0x0],r11
800087a4:	fa ea 00 00 	ld.d	r10,sp[0]
800087a8:	58 0a       	cp.w	r10,0
800087aa:	5c 2b       	cpc	r11
800087ac:	c0 e4       	brge	800087c8 <_vfprintf_r+0x748>
800087ae:	30 08       	mov	r8,0
800087b0:	fa ea 00 00 	ld.d	r10,sp[0]
800087b4:	30 09       	mov	r9,0
800087b6:	f0 0a 01 0a 	sub	r10,r8,r10
800087ba:	f2 0b 01 4b 	sbc	r11,r9,r11
800087be:	32 d8       	mov	r8,45
800087c0:	fa eb 00 00 	st.d	sp[0],r10
800087c4:	fb 68 06 bb 	st.b	sp[1723],r8
800087c8:	30 18       	mov	r8,1
800087ca:	e0 8f 06 fa 	bral	800095be <_vfprintf_r+0x153e>
800087ce:	50 a7       	stdsp	sp[0x28],r7
800087d0:	50 80       	stdsp	sp[0x20],r0
800087d2:	0c 97       	mov	r7,r6
800087d4:	04 94       	mov	r4,r2
800087d6:	06 96       	mov	r6,r3
800087d8:	02 92       	mov	r2,r1
800087da:	40 93       	lddsp	r3,sp[0x24]
800087dc:	10 90       	mov	r0,r8
800087de:	40 41       	lddsp	r1,sp[0x10]
800087e0:	0e 99       	mov	r9,r7
800087e2:	ed b5 00 03 	bld	r5,0x3
800087e6:	c4 11       	brne	80008868 <_vfprintf_r+0x7e8>
800087e8:	fa f8 06 b4 	ld.w	r8,sp[1716]
800087ec:	40 3a       	lddsp	r10,sp[0xc]
800087ee:	58 0a       	cp.w	r10,0
800087f0:	c1 90       	breq	80008822 <_vfprintf_r+0x7a2>
800087f2:	10 36       	cp.w	r6,r8
800087f4:	c6 45       	brlt	800088bc <_vfprintf_r+0x83c>
800087f6:	fa c8 f9 50 	sub	r8,sp,-1712
800087fa:	1a d8       	st.w	--sp,r8
800087fc:	fa c8 fa b8 	sub	r8,sp,-1352
80008800:	1a d8       	st.w	--sp,r8
80008802:	fa c8 fb b4 	sub	r8,sp,-1100
80008806:	0c 9b       	mov	r11,r6
80008808:	1a d8       	st.w	--sp,r8
8000880a:	04 9a       	mov	r10,r2
8000880c:	fa c8 f9 40 	sub	r8,sp,-1728
80008810:	fa c9 ff b4 	sub	r9,sp,-76
80008814:	08 9c       	mov	r12,r4
80008816:	fe b0 fa 9d 	rcall	80007d50 <get_arg>
8000881a:	2f dd       	sub	sp,-12
8000881c:	78 16       	ld.w	r6,r12[0x4]
8000881e:	50 76       	stdsp	sp[0x1c],r6
80008820:	c4 88       	rjmp	800088b0 <_vfprintf_r+0x830>
80008822:	2f f7       	sub	r7,-1
80008824:	10 39       	cp.w	r9,r8
80008826:	c0 c4       	brge	8000883e <_vfprintf_r+0x7be>
80008828:	fa ce f9 44 	sub	lr,sp,-1724
8000882c:	fc 06 00 36 	add	r6,lr,r6<<0x3
80008830:	ec fc fd 8c 	ld.w	r12,r6[-628]
80008834:	50 7c       	stdsp	sp[0x1c],r12
80008836:	ec f6 fd 88 	ld.w	r6,r6[-632]
8000883a:	50 56       	stdsp	sp[0x14],r6
8000883c:	c6 68       	rjmp	80008908 <_vfprintf_r+0x888>
8000883e:	41 09       	lddsp	r9,sp[0x40]
80008840:	59 f8       	cp.w	r8,31
80008842:	e0 89 00 10 	brgt	80008862 <_vfprintf_r+0x7e2>
80008846:	f2 ca ff f8 	sub	r10,r9,-8
8000884a:	72 1b       	ld.w	r11,r9[0x4]
8000884c:	51 0a       	stdsp	sp[0x40],r10
8000884e:	72 09       	ld.w	r9,r9[0x0]
80008850:	fa ca f9 44 	sub	r10,sp,-1724
80008854:	50 7b       	stdsp	sp[0x1c],r11
80008856:	50 59       	stdsp	sp[0x14],r9
80008858:	f4 08 00 39 	add	r9,r10,r8<<0x3
8000885c:	40 5b       	lddsp	r11,sp[0x14]
8000885e:	40 7a       	lddsp	r10,sp[0x1c]
80008860:	c4 78       	rjmp	800088ee <_vfprintf_r+0x86e>
80008862:	72 18       	ld.w	r8,r9[0x4]
80008864:	50 78       	stdsp	sp[0x1c],r8
80008866:	c4 c8       	rjmp	800088fe <_vfprintf_r+0x87e>
80008868:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000886c:	40 3e       	lddsp	lr,sp[0xc]
8000886e:	58 0e       	cp.w	lr,0
80008870:	c2 30       	breq	800088b6 <_vfprintf_r+0x836>
80008872:	10 36       	cp.w	r6,r8
80008874:	c0 94       	brge	80008886 <_vfprintf_r+0x806>
80008876:	fa cc f9 44 	sub	r12,sp,-1724
8000887a:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000887e:	ec fb fd 8c 	ld.w	r11,r6[-628]
80008882:	50 7b       	stdsp	sp[0x1c],r11
80008884:	cd 9b       	rjmp	80008836 <_vfprintf_r+0x7b6>
80008886:	fa c8 f9 50 	sub	r8,sp,-1712
8000888a:	1a d8       	st.w	--sp,r8
8000888c:	fa c8 fa b8 	sub	r8,sp,-1352
80008890:	04 9a       	mov	r10,r2
80008892:	1a d8       	st.w	--sp,r8
80008894:	fa c8 fb b4 	sub	r8,sp,-1100
80008898:	0c 9b       	mov	r11,r6
8000889a:	1a d8       	st.w	--sp,r8
8000889c:	08 9c       	mov	r12,r4
8000889e:	fa c8 f9 40 	sub	r8,sp,-1728
800088a2:	fa c9 ff b4 	sub	r9,sp,-76
800088a6:	fe b0 fa 55 	rcall	80007d50 <get_arg>
800088aa:	2f dd       	sub	sp,-12
800088ac:	78 1a       	ld.w	r10,r12[0x4]
800088ae:	50 7a       	stdsp	sp[0x1c],r10
800088b0:	78 0c       	ld.w	r12,r12[0x0]
800088b2:	50 5c       	stdsp	sp[0x14],r12
800088b4:	c2 a8       	rjmp	80008908 <_vfprintf_r+0x888>
800088b6:	2f f7       	sub	r7,-1
800088b8:	10 39       	cp.w	r9,r8
800088ba:	c0 94       	brge	800088cc <_vfprintf_r+0x84c>
800088bc:	fa c9 f9 44 	sub	r9,sp,-1724
800088c0:	f2 06 00 36 	add	r6,r9,r6<<0x3
800088c4:	ec f8 fd 8c 	ld.w	r8,r6[-628]
800088c8:	50 78       	stdsp	sp[0x1c],r8
800088ca:	cb 6b       	rjmp	80008836 <_vfprintf_r+0x7b6>
800088cc:	41 09       	lddsp	r9,sp[0x40]
800088ce:	59 f8       	cp.w	r8,31
800088d0:	e0 89 00 15 	brgt	800088fa <_vfprintf_r+0x87a>
800088d4:	f2 ca ff f8 	sub	r10,r9,-8
800088d8:	72 16       	ld.w	r6,r9[0x4]
800088da:	72 09       	ld.w	r9,r9[0x0]
800088dc:	51 0a       	stdsp	sp[0x40],r10
800088de:	50 59       	stdsp	sp[0x14],r9
800088e0:	fa ce f9 44 	sub	lr,sp,-1724
800088e4:	50 76       	stdsp	sp[0x1c],r6
800088e6:	fc 08 00 39 	add	r9,lr,r8<<0x3
800088ea:	40 5b       	lddsp	r11,sp[0x14]
800088ec:	0c 9a       	mov	r10,r6
800088ee:	f2 eb fd 88 	st.d	r9[-632],r10
800088f2:	2f f8       	sub	r8,-1
800088f4:	fb 48 06 b4 	st.w	sp[1716],r8
800088f8:	c0 88       	rjmp	80008908 <_vfprintf_r+0x888>
800088fa:	72 1c       	ld.w	r12,r9[0x4]
800088fc:	50 7c       	stdsp	sp[0x1c],r12
800088fe:	f2 c8 ff f8 	sub	r8,r9,-8
80008902:	51 08       	stdsp	sp[0x40],r8
80008904:	72 09       	ld.w	r9,r9[0x0]
80008906:	50 59       	stdsp	sp[0x14],r9
80008908:	40 5b       	lddsp	r11,sp[0x14]
8000890a:	40 7a       	lddsp	r10,sp[0x1c]
8000890c:	e0 a0 19 54 	rcall	8000bbb4 <__isinfd>
80008910:	18 96       	mov	r6,r12
80008912:	c1 70       	breq	80008940 <_vfprintf_r+0x8c0>
80008914:	30 08       	mov	r8,0
80008916:	30 09       	mov	r9,0
80008918:	40 5b       	lddsp	r11,sp[0x14]
8000891a:	40 7a       	lddsp	r10,sp[0x1c]
8000891c:	e0 a0 1d b4 	rcall	8000c484 <__avr32_f64_cmp_lt>
80008920:	c0 40       	breq	80008928 <_vfprintf_r+0x8a8>
80008922:	32 d8       	mov	r8,45
80008924:	fb 68 06 bb 	st.b	sp[1723],r8
80008928:	fe c8 a9 68 	sub	r8,pc,-22168
8000892c:	fe c6 a9 68 	sub	r6,pc,-22168
80008930:	a7 d5       	cbr	r5,0x7
80008932:	e0 40 00 47 	cp.w	r0,71
80008936:	f0 06 17 a0 	movle	r6,r8
8000893a:	30 32       	mov	r2,3
8000893c:	e0 8f 06 ce 	bral	800096d8 <_vfprintf_r+0x1658>
80008940:	40 5b       	lddsp	r11,sp[0x14]
80008942:	40 7a       	lddsp	r10,sp[0x1c]
80008944:	e0 a0 19 4d 	rcall	8000bbde <__isnand>
80008948:	c0 e0       	breq	80008964 <_vfprintf_r+0x8e4>
8000894a:	50 26       	stdsp	sp[0x8],r6
8000894c:	fe c8 a9 84 	sub	r8,pc,-22140
80008950:	fe c6 a9 84 	sub	r6,pc,-22140
80008954:	a7 d5       	cbr	r5,0x7
80008956:	e0 40 00 47 	cp.w	r0,71
8000895a:	f0 06 17 a0 	movle	r6,r8
8000895e:	30 32       	mov	r2,3
80008960:	e0 8f 06 c2 	bral	800096e4 <_vfprintf_r+0x1664>
80008964:	40 2a       	lddsp	r10,sp[0x8]
80008966:	5b fa       	cp.w	r10,-1
80008968:	c0 41       	brne	80008970 <_vfprintf_r+0x8f0>
8000896a:	30 69       	mov	r9,6
8000896c:	50 29       	stdsp	sp[0x8],r9
8000896e:	c1 18       	rjmp	80008990 <_vfprintf_r+0x910>
80008970:	e0 40 00 47 	cp.w	r0,71
80008974:	5f 09       	sreq	r9
80008976:	e0 40 00 67 	cp.w	r0,103
8000897a:	5f 08       	sreq	r8
8000897c:	f3 e8 10 08 	or	r8,r9,r8
80008980:	f8 08 18 00 	cp.b	r8,r12
80008984:	c0 60       	breq	80008990 <_vfprintf_r+0x910>
80008986:	40 28       	lddsp	r8,sp[0x8]
80008988:	58 08       	cp.w	r8,0
8000898a:	f9 b8 00 01 	moveq	r8,1
8000898e:	50 28       	stdsp	sp[0x8],r8
80008990:	40 78       	lddsp	r8,sp[0x1c]
80008992:	40 59       	lddsp	r9,sp[0x14]
80008994:	fa e9 06 94 	st.d	sp[1684],r8
80008998:	a9 a5       	sbr	r5,0x8
8000899a:	fa f8 06 94 	ld.w	r8,sp[1684]
8000899e:	58 08       	cp.w	r8,0
800089a0:	c0 65       	brlt	800089ac <_vfprintf_r+0x92c>
800089a2:	40 5e       	lddsp	lr,sp[0x14]
800089a4:	30 0c       	mov	r12,0
800089a6:	50 6e       	stdsp	sp[0x18],lr
800089a8:	50 9c       	stdsp	sp[0x24],r12
800089aa:	c0 78       	rjmp	800089b8 <_vfprintf_r+0x938>
800089ac:	40 5b       	lddsp	r11,sp[0x14]
800089ae:	32 da       	mov	r10,45
800089b0:	ee 1b 80 00 	eorh	r11,0x8000
800089b4:	50 9a       	stdsp	sp[0x24],r10
800089b6:	50 6b       	stdsp	sp[0x18],r11
800089b8:	e0 40 00 46 	cp.w	r0,70
800089bc:	5f 09       	sreq	r9
800089be:	e0 40 00 66 	cp.w	r0,102
800089c2:	5f 08       	sreq	r8
800089c4:	f3 e8 10 08 	or	r8,r9,r8
800089c8:	50 48       	stdsp	sp[0x10],r8
800089ca:	c0 40       	breq	800089d2 <_vfprintf_r+0x952>
800089cc:	40 22       	lddsp	r2,sp[0x8]
800089ce:	30 39       	mov	r9,3
800089d0:	c1 08       	rjmp	800089f0 <_vfprintf_r+0x970>
800089d2:	e0 40 00 45 	cp.w	r0,69
800089d6:	5f 09       	sreq	r9
800089d8:	e0 40 00 65 	cp.w	r0,101
800089dc:	5f 08       	sreq	r8
800089de:	40 22       	lddsp	r2,sp[0x8]
800089e0:	10 49       	or	r9,r8
800089e2:	2f f2       	sub	r2,-1
800089e4:	40 46       	lddsp	r6,sp[0x10]
800089e6:	ec 09 18 00 	cp.b	r9,r6
800089ea:	fb f2 00 02 	ld.weq	r2,sp[0x8]
800089ee:	30 29       	mov	r9,2
800089f0:	fa c8 f9 5c 	sub	r8,sp,-1700
800089f4:	1a d8       	st.w	--sp,r8
800089f6:	fa c8 f9 54 	sub	r8,sp,-1708
800089fa:	1a d8       	st.w	--sp,r8
800089fc:	fa c8 f9 4c 	sub	r8,sp,-1716
80008a00:	08 9c       	mov	r12,r4
80008a02:	1a d8       	st.w	--sp,r8
80008a04:	04 98       	mov	r8,r2
80008a06:	40 9b       	lddsp	r11,sp[0x24]
80008a08:	40 aa       	lddsp	r10,sp[0x28]
80008a0a:	e0 a0 0b c3 	rcall	8000a190 <_dtoa_r>
80008a0e:	e0 40 00 47 	cp.w	r0,71
80008a12:	5f 19       	srne	r9
80008a14:	e0 40 00 67 	cp.w	r0,103
80008a18:	5f 18       	srne	r8
80008a1a:	18 96       	mov	r6,r12
80008a1c:	2f dd       	sub	sp,-12
80008a1e:	f3 e8 00 08 	and	r8,r9,r8
80008a22:	c0 41       	brne	80008a2a <_vfprintf_r+0x9aa>
80008a24:	ed b5 00 00 	bld	r5,0x0
80008a28:	c3 01       	brne	80008a88 <_vfprintf_r+0xa08>
80008a2a:	ec 02 00 0e 	add	lr,r6,r2
80008a2e:	50 3e       	stdsp	sp[0xc],lr
80008a30:	40 4c       	lddsp	r12,sp[0x10]
80008a32:	58 0c       	cp.w	r12,0
80008a34:	c1 50       	breq	80008a5e <_vfprintf_r+0x9de>
80008a36:	0d 89       	ld.ub	r9,r6[0x0]
80008a38:	33 08       	mov	r8,48
80008a3a:	f0 09 18 00 	cp.b	r9,r8
80008a3e:	c0 b1       	brne	80008a54 <_vfprintf_r+0x9d4>
80008a40:	30 08       	mov	r8,0
80008a42:	30 09       	mov	r9,0
80008a44:	40 6b       	lddsp	r11,sp[0x18]
80008a46:	40 7a       	lddsp	r10,sp[0x1c]
80008a48:	e0 a0 1c d7 	rcall	8000c3f6 <__avr32_f64_cmp_eq>
80008a4c:	fb b2 00 01 	rsubeq	r2,1
80008a50:	fb f2 0b ab 	st.weq	sp[0x6ac],r2
80008a54:	40 3b       	lddsp	r11,sp[0xc]
80008a56:	fa f8 06 ac 	ld.w	r8,sp[1708]
80008a5a:	10 0b       	add	r11,r8
80008a5c:	50 3b       	stdsp	sp[0xc],r11
80008a5e:	40 6b       	lddsp	r11,sp[0x18]
80008a60:	30 08       	mov	r8,0
80008a62:	30 09       	mov	r9,0
80008a64:	40 7a       	lddsp	r10,sp[0x1c]
80008a66:	e0 a0 1c c8 	rcall	8000c3f6 <__avr32_f64_cmp_eq>
80008a6a:	c0 90       	breq	80008a7c <_vfprintf_r+0x9fc>
80008a6c:	40 3a       	lddsp	r10,sp[0xc]
80008a6e:	fb 4a 06 a4 	st.w	sp[1700],r10
80008a72:	c0 58       	rjmp	80008a7c <_vfprintf_r+0x9fc>
80008a74:	10 c9       	st.b	r8++,r9
80008a76:	fb 48 06 a4 	st.w	sp[1700],r8
80008a7a:	c0 28       	rjmp	80008a7e <_vfprintf_r+0x9fe>
80008a7c:	33 09       	mov	r9,48
80008a7e:	fa f8 06 a4 	ld.w	r8,sp[1700]
80008a82:	40 3e       	lddsp	lr,sp[0xc]
80008a84:	1c 38       	cp.w	r8,lr
80008a86:	cf 73       	brcs	80008a74 <_vfprintf_r+0x9f4>
80008a88:	e0 40 00 47 	cp.w	r0,71
80008a8c:	5f 09       	sreq	r9
80008a8e:	e0 40 00 67 	cp.w	r0,103
80008a92:	5f 08       	sreq	r8
80008a94:	f3 e8 10 08 	or	r8,r9,r8
80008a98:	fa f9 06 a4 	ld.w	r9,sp[1700]
80008a9c:	0c 19       	sub	r9,r6
80008a9e:	50 69       	stdsp	sp[0x18],r9
80008aa0:	58 08       	cp.w	r8,0
80008aa2:	c0 b0       	breq	80008ab8 <_vfprintf_r+0xa38>
80008aa4:	fa f8 06 ac 	ld.w	r8,sp[1708]
80008aa8:	5b d8       	cp.w	r8,-3
80008aaa:	c0 55       	brlt	80008ab4 <_vfprintf_r+0xa34>
80008aac:	40 2c       	lddsp	r12,sp[0x8]
80008aae:	18 38       	cp.w	r8,r12
80008ab0:	e0 8a 00 6a 	brle	80008b84 <_vfprintf_r+0xb04>
80008ab4:	20 20       	sub	r0,2
80008ab6:	c0 58       	rjmp	80008ac0 <_vfprintf_r+0xa40>
80008ab8:	e0 40 00 65 	cp.w	r0,101
80008abc:	e0 89 00 46 	brgt	80008b48 <_vfprintf_r+0xac8>
80008ac0:	fa fb 06 ac 	ld.w	r11,sp[1708]
80008ac4:	fb 60 06 9c 	st.b	sp[1692],r0
80008ac8:	20 1b       	sub	r11,1
80008aca:	fb 4b 06 ac 	st.w	sp[1708],r11
80008ace:	c0 47       	brpl	80008ad6 <_vfprintf_r+0xa56>
80008ad0:	5c 3b       	neg	r11
80008ad2:	32 d8       	mov	r8,45
80008ad4:	c0 28       	rjmp	80008ad8 <_vfprintf_r+0xa58>
80008ad6:	32 b8       	mov	r8,43
80008ad8:	fb 68 06 9d 	st.b	sp[1693],r8
80008adc:	58 9b       	cp.w	r11,9
80008ade:	e0 8a 00 1d 	brle	80008b18 <_vfprintf_r+0xa98>
80008ae2:	fa c9 fa 35 	sub	r9,sp,-1483
80008ae6:	30 aa       	mov	r10,10
80008ae8:	12 98       	mov	r8,r9
80008aea:	0e 9c       	mov	r12,r7
80008aec:	0c 92       	mov	r2,r6
80008aee:	f6 0a 0c 06 	divs	r6,r11,r10
80008af2:	0e 9b       	mov	r11,r7
80008af4:	2d 0b       	sub	r11,-48
80008af6:	10 fb       	st.b	--r8,r11
80008af8:	0c 9b       	mov	r11,r6
80008afa:	58 96       	cp.w	r6,9
80008afc:	fe 99 ff f9 	brgt	80008aee <_vfprintf_r+0xa6e>
80008b00:	2d 0b       	sub	r11,-48
80008b02:	18 97       	mov	r7,r12
80008b04:	04 96       	mov	r6,r2
80008b06:	10 fb       	st.b	--r8,r11
80008b08:	fa ca f9 62 	sub	r10,sp,-1694
80008b0c:	c0 38       	rjmp	80008b12 <_vfprintf_r+0xa92>
80008b0e:	11 3b       	ld.ub	r11,r8++
80008b10:	14 cb       	st.b	r10++,r11
80008b12:	12 38       	cp.w	r8,r9
80008b14:	cf d3       	brcs	80008b0e <_vfprintf_r+0xa8e>
80008b16:	c0 98       	rjmp	80008b28 <_vfprintf_r+0xaa8>
80008b18:	2d 0b       	sub	r11,-48
80008b1a:	33 08       	mov	r8,48
80008b1c:	fb 6b 06 9f 	st.b	sp[1695],r11
80008b20:	fb 68 06 9e 	st.b	sp[1694],r8
80008b24:	fa ca f9 60 	sub	r10,sp,-1696
80008b28:	fa c8 f9 64 	sub	r8,sp,-1692
80008b2c:	f4 08 01 08 	sub	r8,r10,r8
80008b30:	50 e8       	stdsp	sp[0x38],r8
80008b32:	10 92       	mov	r2,r8
80008b34:	40 6b       	lddsp	r11,sp[0x18]
80008b36:	16 02       	add	r2,r11
80008b38:	58 1b       	cp.w	r11,1
80008b3a:	e0 89 00 05 	brgt	80008b44 <_vfprintf_r+0xac4>
80008b3e:	ed b5 00 00 	bld	r5,0x0
80008b42:	c3 51       	brne	80008bac <_vfprintf_r+0xb2c>
80008b44:	2f f2       	sub	r2,-1
80008b46:	c3 38       	rjmp	80008bac <_vfprintf_r+0xb2c>
80008b48:	e0 40 00 66 	cp.w	r0,102
80008b4c:	c1 c1       	brne	80008b84 <_vfprintf_r+0xb04>
80008b4e:	fa f2 06 ac 	ld.w	r2,sp[1708]
80008b52:	58 02       	cp.w	r2,0
80008b54:	e0 8a 00 0c 	brle	80008b6c <_vfprintf_r+0xaec>
80008b58:	40 2a       	lddsp	r10,sp[0x8]
80008b5a:	58 0a       	cp.w	r10,0
80008b5c:	c0 41       	brne	80008b64 <_vfprintf_r+0xae4>
80008b5e:	ed b5 00 00 	bld	r5,0x0
80008b62:	c2 51       	brne	80008bac <_vfprintf_r+0xb2c>
80008b64:	2f f2       	sub	r2,-1
80008b66:	40 29       	lddsp	r9,sp[0x8]
80008b68:	12 02       	add	r2,r9
80008b6a:	c0 b8       	rjmp	80008b80 <_vfprintf_r+0xb00>
80008b6c:	40 28       	lddsp	r8,sp[0x8]
80008b6e:	58 08       	cp.w	r8,0
80008b70:	c0 61       	brne	80008b7c <_vfprintf_r+0xafc>
80008b72:	ed b5 00 00 	bld	r5,0x0
80008b76:	c0 30       	breq	80008b7c <_vfprintf_r+0xafc>
80008b78:	30 12       	mov	r2,1
80008b7a:	c1 98       	rjmp	80008bac <_vfprintf_r+0xb2c>
80008b7c:	40 22       	lddsp	r2,sp[0x8]
80008b7e:	2f e2       	sub	r2,-2
80008b80:	36 60       	mov	r0,102
80008b82:	c1 58       	rjmp	80008bac <_vfprintf_r+0xb2c>
80008b84:	fa f2 06 ac 	ld.w	r2,sp[1708]
80008b88:	40 6e       	lddsp	lr,sp[0x18]
80008b8a:	1c 32       	cp.w	r2,lr
80008b8c:	c0 65       	brlt	80008b98 <_vfprintf_r+0xb18>
80008b8e:	ed b5 00 00 	bld	r5,0x0
80008b92:	f7 b2 00 ff 	subeq	r2,-1
80008b96:	c0 a8       	rjmp	80008baa <_vfprintf_r+0xb2a>
80008b98:	e4 08 11 02 	rsub	r8,r2,2
80008b9c:	40 6c       	lddsp	r12,sp[0x18]
80008b9e:	58 02       	cp.w	r2,0
80008ba0:	f0 02 17 a0 	movle	r2,r8
80008ba4:	f9 b2 09 01 	movgt	r2,1
80008ba8:	18 02       	add	r2,r12
80008baa:	36 70       	mov	r0,103
80008bac:	40 9b       	lddsp	r11,sp[0x24]
80008bae:	58 0b       	cp.w	r11,0
80008bb0:	e0 80 05 94 	breq	800096d8 <_vfprintf_r+0x1658>
80008bb4:	32 d8       	mov	r8,45
80008bb6:	fb 68 06 bb 	st.b	sp[1723],r8
80008bba:	e0 8f 05 93 	bral	800096e0 <_vfprintf_r+0x1660>
80008bbe:	50 a7       	stdsp	sp[0x28],r7
80008bc0:	04 94       	mov	r4,r2
80008bc2:	0c 97       	mov	r7,r6
80008bc4:	02 92       	mov	r2,r1
80008bc6:	06 96       	mov	r6,r3
80008bc8:	40 41       	lddsp	r1,sp[0x10]
80008bca:	40 93       	lddsp	r3,sp[0x24]
80008bcc:	0e 99       	mov	r9,r7
80008bce:	ed b5 00 05 	bld	r5,0x5
80008bd2:	c4 81       	brne	80008c62 <_vfprintf_r+0xbe2>
80008bd4:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008bd8:	40 3e       	lddsp	lr,sp[0xc]
80008bda:	58 0e       	cp.w	lr,0
80008bdc:	c1 d0       	breq	80008c16 <_vfprintf_r+0xb96>
80008bde:	10 36       	cp.w	r6,r8
80008be0:	c0 64       	brge	80008bec <_vfprintf_r+0xb6c>
80008be2:	fa cc f9 44 	sub	r12,sp,-1724
80008be6:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008bea:	c1 d8       	rjmp	80008c24 <_vfprintf_r+0xba4>
80008bec:	fa c8 f9 50 	sub	r8,sp,-1712
80008bf0:	1a d8       	st.w	--sp,r8
80008bf2:	fa c8 fa b8 	sub	r8,sp,-1352
80008bf6:	04 9a       	mov	r10,r2
80008bf8:	1a d8       	st.w	--sp,r8
80008bfa:	fa c8 fb b4 	sub	r8,sp,-1100
80008bfe:	0c 9b       	mov	r11,r6
80008c00:	1a d8       	st.w	--sp,r8
80008c02:	08 9c       	mov	r12,r4
80008c04:	fa c8 f9 40 	sub	r8,sp,-1728
80008c08:	fa c9 ff b4 	sub	r9,sp,-76
80008c0c:	fe b0 f8 a2 	rcall	80007d50 <get_arg>
80008c10:	2f dd       	sub	sp,-12
80008c12:	78 0a       	ld.w	r10,r12[0x0]
80008c14:	c2 08       	rjmp	80008c54 <_vfprintf_r+0xbd4>
80008c16:	2f f7       	sub	r7,-1
80008c18:	10 39       	cp.w	r9,r8
80008c1a:	c0 84       	brge	80008c2a <_vfprintf_r+0xbaa>
80008c1c:	fa cb f9 44 	sub	r11,sp,-1724
80008c20:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008c24:	ec fa fd 88 	ld.w	r10,r6[-632]
80008c28:	c1 68       	rjmp	80008c54 <_vfprintf_r+0xbd4>
80008c2a:	41 09       	lddsp	r9,sp[0x40]
80008c2c:	59 f8       	cp.w	r8,31
80008c2e:	e0 89 00 10 	brgt	80008c4e <_vfprintf_r+0xbce>
80008c32:	f2 ca ff fc 	sub	r10,r9,-4
80008c36:	51 0a       	stdsp	sp[0x40],r10
80008c38:	fa c6 f9 44 	sub	r6,sp,-1724
80008c3c:	72 0a       	ld.w	r10,r9[0x0]
80008c3e:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008c42:	f3 4a fd 88 	st.w	r9[-632],r10
80008c46:	2f f8       	sub	r8,-1
80008c48:	fb 48 06 b4 	st.w	sp[1716],r8
80008c4c:	c0 48       	rjmp	80008c54 <_vfprintf_r+0xbd4>
80008c4e:	72 0a       	ld.w	r10,r9[0x0]
80008c50:	2f c9       	sub	r9,-4
80008c52:	51 09       	stdsp	sp[0x40],r9
80008c54:	40 be       	lddsp	lr,sp[0x2c]
80008c56:	1c 98       	mov	r8,lr
80008c58:	95 1e       	st.w	r10[0x4],lr
80008c5a:	bf 58       	asr	r8,0x1f
80008c5c:	95 08       	st.w	r10[0x0],r8
80008c5e:	fe 9f fa 9f 	bral	8000819c <_vfprintf_r+0x11c>
80008c62:	ed b5 00 04 	bld	r5,0x4
80008c66:	c4 80       	breq	80008cf6 <_vfprintf_r+0xc76>
80008c68:	e2 15 00 40 	andl	r5,0x40,COH
80008c6c:	c4 50       	breq	80008cf6 <_vfprintf_r+0xc76>
80008c6e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008c72:	40 3c       	lddsp	r12,sp[0xc]
80008c74:	58 0c       	cp.w	r12,0
80008c76:	c1 d0       	breq	80008cb0 <_vfprintf_r+0xc30>
80008c78:	10 36       	cp.w	r6,r8
80008c7a:	c0 64       	brge	80008c86 <_vfprintf_r+0xc06>
80008c7c:	fa cb f9 44 	sub	r11,sp,-1724
80008c80:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008c84:	c1 d8       	rjmp	80008cbe <_vfprintf_r+0xc3e>
80008c86:	fa c8 f9 50 	sub	r8,sp,-1712
80008c8a:	1a d8       	st.w	--sp,r8
80008c8c:	fa c8 fa b8 	sub	r8,sp,-1352
80008c90:	04 9a       	mov	r10,r2
80008c92:	1a d8       	st.w	--sp,r8
80008c94:	fa c8 fb b4 	sub	r8,sp,-1100
80008c98:	0c 9b       	mov	r11,r6
80008c9a:	1a d8       	st.w	--sp,r8
80008c9c:	08 9c       	mov	r12,r4
80008c9e:	fa c8 f9 40 	sub	r8,sp,-1728
80008ca2:	fa c9 ff b4 	sub	r9,sp,-76
80008ca6:	fe b0 f8 55 	rcall	80007d50 <get_arg>
80008caa:	2f dd       	sub	sp,-12
80008cac:	78 0a       	ld.w	r10,r12[0x0]
80008cae:	c2 08       	rjmp	80008cee <_vfprintf_r+0xc6e>
80008cb0:	2f f7       	sub	r7,-1
80008cb2:	10 39       	cp.w	r9,r8
80008cb4:	c0 84       	brge	80008cc4 <_vfprintf_r+0xc44>
80008cb6:	fa ca f9 44 	sub	r10,sp,-1724
80008cba:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008cbe:	ec fa fd 88 	ld.w	r10,r6[-632]
80008cc2:	c1 68       	rjmp	80008cee <_vfprintf_r+0xc6e>
80008cc4:	41 09       	lddsp	r9,sp[0x40]
80008cc6:	59 f8       	cp.w	r8,31
80008cc8:	e0 89 00 10 	brgt	80008ce8 <_vfprintf_r+0xc68>
80008ccc:	f2 ca ff fc 	sub	r10,r9,-4
80008cd0:	51 0a       	stdsp	sp[0x40],r10
80008cd2:	fa c6 f9 44 	sub	r6,sp,-1724
80008cd6:	72 0a       	ld.w	r10,r9[0x0]
80008cd8:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008cdc:	f3 4a fd 88 	st.w	r9[-632],r10
80008ce0:	2f f8       	sub	r8,-1
80008ce2:	fb 48 06 b4 	st.w	sp[1716],r8
80008ce6:	c0 48       	rjmp	80008cee <_vfprintf_r+0xc6e>
80008ce8:	72 0a       	ld.w	r10,r9[0x0]
80008cea:	2f c9       	sub	r9,-4
80008cec:	51 09       	stdsp	sp[0x40],r9
80008cee:	40 be       	lddsp	lr,sp[0x2c]
80008cf0:	b4 0e       	st.h	r10[0x0],lr
80008cf2:	fe 9f fa 55 	bral	8000819c <_vfprintf_r+0x11c>
80008cf6:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008cfa:	40 3c       	lddsp	r12,sp[0xc]
80008cfc:	58 0c       	cp.w	r12,0
80008cfe:	c1 d0       	breq	80008d38 <_vfprintf_r+0xcb8>
80008d00:	10 36       	cp.w	r6,r8
80008d02:	c0 64       	brge	80008d0e <_vfprintf_r+0xc8e>
80008d04:	fa cb f9 44 	sub	r11,sp,-1724
80008d08:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008d0c:	c1 d8       	rjmp	80008d46 <_vfprintf_r+0xcc6>
80008d0e:	fa c8 f9 50 	sub	r8,sp,-1712
80008d12:	1a d8       	st.w	--sp,r8
80008d14:	fa c8 fa b8 	sub	r8,sp,-1352
80008d18:	04 9a       	mov	r10,r2
80008d1a:	1a d8       	st.w	--sp,r8
80008d1c:	fa c8 fb b4 	sub	r8,sp,-1100
80008d20:	0c 9b       	mov	r11,r6
80008d22:	1a d8       	st.w	--sp,r8
80008d24:	08 9c       	mov	r12,r4
80008d26:	fa c8 f9 40 	sub	r8,sp,-1728
80008d2a:	fa c9 ff b4 	sub	r9,sp,-76
80008d2e:	fe b0 f8 11 	rcall	80007d50 <get_arg>
80008d32:	2f dd       	sub	sp,-12
80008d34:	78 0a       	ld.w	r10,r12[0x0]
80008d36:	c2 08       	rjmp	80008d76 <_vfprintf_r+0xcf6>
80008d38:	2f f7       	sub	r7,-1
80008d3a:	10 39       	cp.w	r9,r8
80008d3c:	c0 84       	brge	80008d4c <_vfprintf_r+0xccc>
80008d3e:	fa ca f9 44 	sub	r10,sp,-1724
80008d42:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008d46:	ec fa fd 88 	ld.w	r10,r6[-632]
80008d4a:	c1 68       	rjmp	80008d76 <_vfprintf_r+0xcf6>
80008d4c:	41 09       	lddsp	r9,sp[0x40]
80008d4e:	59 f8       	cp.w	r8,31
80008d50:	e0 89 00 10 	brgt	80008d70 <_vfprintf_r+0xcf0>
80008d54:	f2 ca ff fc 	sub	r10,r9,-4
80008d58:	51 0a       	stdsp	sp[0x40],r10
80008d5a:	fa c6 f9 44 	sub	r6,sp,-1724
80008d5e:	72 0a       	ld.w	r10,r9[0x0]
80008d60:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008d64:	f3 4a fd 88 	st.w	r9[-632],r10
80008d68:	2f f8       	sub	r8,-1
80008d6a:	fb 48 06 b4 	st.w	sp[1716],r8
80008d6e:	c0 48       	rjmp	80008d76 <_vfprintf_r+0xcf6>
80008d70:	72 0a       	ld.w	r10,r9[0x0]
80008d72:	2f c9       	sub	r9,-4
80008d74:	51 09       	stdsp	sp[0x40],r9
80008d76:	40 be       	lddsp	lr,sp[0x2c]
80008d78:	95 0e       	st.w	r10[0x0],lr
80008d7a:	fe 9f fa 11 	bral	8000819c <_vfprintf_r+0x11c>
80008d7e:	50 a7       	stdsp	sp[0x28],r7
80008d80:	50 80       	stdsp	sp[0x20],r0
80008d82:	0c 97       	mov	r7,r6
80008d84:	04 94       	mov	r4,r2
80008d86:	06 96       	mov	r6,r3
80008d88:	02 92       	mov	r2,r1
80008d8a:	40 93       	lddsp	r3,sp[0x24]
80008d8c:	10 90       	mov	r0,r8
80008d8e:	40 41       	lddsp	r1,sp[0x10]
80008d90:	a5 a5       	sbr	r5,0x4
80008d92:	c0 a8       	rjmp	80008da6 <_vfprintf_r+0xd26>
80008d94:	50 a7       	stdsp	sp[0x28],r7
80008d96:	50 80       	stdsp	sp[0x20],r0
80008d98:	0c 97       	mov	r7,r6
80008d9a:	04 94       	mov	r4,r2
80008d9c:	06 96       	mov	r6,r3
80008d9e:	02 92       	mov	r2,r1
80008da0:	40 93       	lddsp	r3,sp[0x24]
80008da2:	10 90       	mov	r0,r8
80008da4:	40 41       	lddsp	r1,sp[0x10]
80008da6:	ed b5 00 05 	bld	r5,0x5
80008daa:	c5 d1       	brne	80008e64 <_vfprintf_r+0xde4>
80008dac:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008db0:	40 3c       	lddsp	r12,sp[0xc]
80008db2:	58 0c       	cp.w	r12,0
80008db4:	c2 60       	breq	80008e00 <_vfprintf_r+0xd80>
80008db6:	10 36       	cp.w	r6,r8
80008db8:	c0 a4       	brge	80008dcc <_vfprintf_r+0xd4c>
80008dba:	fa cb f9 44 	sub	r11,sp,-1724
80008dbe:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008dc2:	ec e8 fd 88 	ld.d	r8,r6[-632]
80008dc6:	fa e9 00 00 	st.d	sp[0],r8
80008dca:	c1 88       	rjmp	80008dfa <_vfprintf_r+0xd7a>
80008dcc:	fa c8 f9 50 	sub	r8,sp,-1712
80008dd0:	1a d8       	st.w	--sp,r8
80008dd2:	fa c8 fa b8 	sub	r8,sp,-1352
80008dd6:	04 9a       	mov	r10,r2
80008dd8:	1a d8       	st.w	--sp,r8
80008dda:	0c 9b       	mov	r11,r6
80008ddc:	fa c8 fb b4 	sub	r8,sp,-1100
80008de0:	08 9c       	mov	r12,r4
80008de2:	1a d8       	st.w	--sp,r8
80008de4:	fa c8 f9 40 	sub	r8,sp,-1728
80008de8:	fa c9 ff b4 	sub	r9,sp,-76
80008dec:	fe b0 f7 b2 	rcall	80007d50 <get_arg>
80008df0:	2f dd       	sub	sp,-12
80008df2:	f8 ea 00 00 	ld.d	r10,r12[0]
80008df6:	fa eb 00 00 	st.d	sp[0],r10
80008dfa:	30 08       	mov	r8,0
80008dfc:	e0 8f 03 de 	bral	800095b8 <_vfprintf_r+0x1538>
80008e00:	ee ca ff ff 	sub	r10,r7,-1
80008e04:	10 37       	cp.w	r7,r8
80008e06:	c0 b4       	brge	80008e1c <_vfprintf_r+0xd9c>
80008e08:	fa c9 f9 44 	sub	r9,sp,-1724
80008e0c:	14 97       	mov	r7,r10
80008e0e:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008e12:	ec ea fd 88 	ld.d	r10,r6[-632]
80008e16:	fa eb 00 00 	st.d	sp[0],r10
80008e1a:	c1 88       	rjmp	80008e4a <_vfprintf_r+0xdca>
80008e1c:	41 09       	lddsp	r9,sp[0x40]
80008e1e:	59 f8       	cp.w	r8,31
80008e20:	e0 89 00 18 	brgt	80008e50 <_vfprintf_r+0xdd0>
80008e24:	f2 e6 00 00 	ld.d	r6,r9[0]
80008e28:	f2 cb ff f8 	sub	r11,r9,-8
80008e2c:	fa e7 00 00 	st.d	sp[0],r6
80008e30:	51 0b       	stdsp	sp[0x40],r11
80008e32:	fa c6 f9 44 	sub	r6,sp,-1724
80008e36:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008e3a:	fa e6 00 00 	ld.d	r6,sp[0]
80008e3e:	f2 e7 fd 88 	st.d	r9[-632],r6
80008e42:	2f f8       	sub	r8,-1
80008e44:	14 97       	mov	r7,r10
80008e46:	fb 48 06 b4 	st.w	sp[1716],r8
80008e4a:	40 38       	lddsp	r8,sp[0xc]
80008e4c:	e0 8f 03 b6 	bral	800095b8 <_vfprintf_r+0x1538>
80008e50:	f2 e6 00 00 	ld.d	r6,r9[0]
80008e54:	40 38       	lddsp	r8,sp[0xc]
80008e56:	fa e7 00 00 	st.d	sp[0],r6
80008e5a:	2f 89       	sub	r9,-8
80008e5c:	14 97       	mov	r7,r10
80008e5e:	51 09       	stdsp	sp[0x40],r9
80008e60:	e0 8f 03 ac 	bral	800095b8 <_vfprintf_r+0x1538>
80008e64:	ed b5 00 04 	bld	r5,0x4
80008e68:	c1 61       	brne	80008e94 <_vfprintf_r+0xe14>
80008e6a:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008e6e:	40 3e       	lddsp	lr,sp[0xc]
80008e70:	58 0e       	cp.w	lr,0
80008e72:	c0 80       	breq	80008e82 <_vfprintf_r+0xe02>
80008e74:	10 36       	cp.w	r6,r8
80008e76:	c6 74       	brge	80008f44 <_vfprintf_r+0xec4>
80008e78:	fa cc f9 44 	sub	r12,sp,-1724
80008e7c:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008e80:	c8 08       	rjmp	80008f80 <_vfprintf_r+0xf00>
80008e82:	ee ca ff ff 	sub	r10,r7,-1
80008e86:	10 37       	cp.w	r7,r8
80008e88:	c7 f4       	brge	80008f86 <_vfprintf_r+0xf06>
80008e8a:	fa cb f9 44 	sub	r11,sp,-1724
80008e8e:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008e92:	c7 68       	rjmp	80008f7e <_vfprintf_r+0xefe>
80008e94:	ed b5 00 06 	bld	r5,0x6
80008e98:	c4 a1       	brne	80008f2c <_vfprintf_r+0xeac>
80008e9a:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008e9e:	40 3c       	lddsp	r12,sp[0xc]
80008ea0:	58 0c       	cp.w	r12,0
80008ea2:	c1 d0       	breq	80008edc <_vfprintf_r+0xe5c>
80008ea4:	10 36       	cp.w	r6,r8
80008ea6:	c0 64       	brge	80008eb2 <_vfprintf_r+0xe32>
80008ea8:	fa cb f9 44 	sub	r11,sp,-1724
80008eac:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008eb0:	c1 f8       	rjmp	80008eee <_vfprintf_r+0xe6e>
80008eb2:	fa c8 f9 50 	sub	r8,sp,-1712
80008eb6:	1a d8       	st.w	--sp,r8
80008eb8:	fa c8 fa b8 	sub	r8,sp,-1352
80008ebc:	1a d8       	st.w	--sp,r8
80008ebe:	fa c8 fb b4 	sub	r8,sp,-1100
80008ec2:	1a d8       	st.w	--sp,r8
80008ec4:	fa c8 f9 40 	sub	r8,sp,-1728
80008ec8:	fa c9 ff b4 	sub	r9,sp,-76
80008ecc:	04 9a       	mov	r10,r2
80008ece:	0c 9b       	mov	r11,r6
80008ed0:	08 9c       	mov	r12,r4
80008ed2:	fe b0 f7 3f 	rcall	80007d50 <get_arg>
80008ed6:	2f dd       	sub	sp,-12
80008ed8:	98 18       	ld.sh	r8,r12[0x2]
80008eda:	c2 68       	rjmp	80008f26 <_vfprintf_r+0xea6>
80008edc:	ee ca ff ff 	sub	r10,r7,-1
80008ee0:	10 37       	cp.w	r7,r8
80008ee2:	c0 94       	brge	80008ef4 <_vfprintf_r+0xe74>
80008ee4:	fa c9 f9 44 	sub	r9,sp,-1724
80008ee8:	14 97       	mov	r7,r10
80008eea:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008eee:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80008ef2:	c1 a8       	rjmp	80008f26 <_vfprintf_r+0xea6>
80008ef4:	41 09       	lddsp	r9,sp[0x40]
80008ef6:	59 f8       	cp.w	r8,31
80008ef8:	e0 89 00 13 	brgt	80008f1e <_vfprintf_r+0xe9e>
80008efc:	f2 cb ff fc 	sub	r11,r9,-4
80008f00:	51 0b       	stdsp	sp[0x40],r11
80008f02:	72 09       	ld.w	r9,r9[0x0]
80008f04:	fa c6 f9 44 	sub	r6,sp,-1724
80008f08:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80008f0c:	2f f8       	sub	r8,-1
80008f0e:	f7 49 fd 88 	st.w	r11[-632],r9
80008f12:	fb 48 06 b4 	st.w	sp[1716],r8
80008f16:	14 97       	mov	r7,r10
80008f18:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80008f1c:	c0 58       	rjmp	80008f26 <_vfprintf_r+0xea6>
80008f1e:	92 18       	ld.sh	r8,r9[0x2]
80008f20:	14 97       	mov	r7,r10
80008f22:	2f c9       	sub	r9,-4
80008f24:	51 09       	stdsp	sp[0x40],r9
80008f26:	5c 78       	castu.h	r8
80008f28:	50 18       	stdsp	sp[0x4],r8
80008f2a:	c4 68       	rjmp	80008fb6 <_vfprintf_r+0xf36>
80008f2c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008f30:	40 3c       	lddsp	r12,sp[0xc]
80008f32:	58 0c       	cp.w	r12,0
80008f34:	c1 d0       	breq	80008f6e <_vfprintf_r+0xeee>
80008f36:	10 36       	cp.w	r6,r8
80008f38:	c0 64       	brge	80008f44 <_vfprintf_r+0xec4>
80008f3a:	fa cb f9 44 	sub	r11,sp,-1724
80008f3e:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008f42:	c1 f8       	rjmp	80008f80 <_vfprintf_r+0xf00>
80008f44:	fa c8 f9 50 	sub	r8,sp,-1712
80008f48:	1a d8       	st.w	--sp,r8
80008f4a:	fa c8 fa b8 	sub	r8,sp,-1352
80008f4e:	0c 9b       	mov	r11,r6
80008f50:	1a d8       	st.w	--sp,r8
80008f52:	fa c8 fb b4 	sub	r8,sp,-1100
80008f56:	04 9a       	mov	r10,r2
80008f58:	1a d8       	st.w	--sp,r8
80008f5a:	08 9c       	mov	r12,r4
80008f5c:	fa c8 f9 40 	sub	r8,sp,-1728
80008f60:	fa c9 ff b4 	sub	r9,sp,-76
80008f64:	fe b0 f6 f6 	rcall	80007d50 <get_arg>
80008f68:	2f dd       	sub	sp,-12
80008f6a:	78 0b       	ld.w	r11,r12[0x0]
80008f6c:	c2 48       	rjmp	80008fb4 <_vfprintf_r+0xf34>
80008f6e:	ee ca ff ff 	sub	r10,r7,-1
80008f72:	10 37       	cp.w	r7,r8
80008f74:	c0 94       	brge	80008f86 <_vfprintf_r+0xf06>
80008f76:	fa c9 f9 44 	sub	r9,sp,-1724
80008f7a:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008f7e:	14 97       	mov	r7,r10
80008f80:	ec fb fd 88 	ld.w	r11,r6[-632]
80008f84:	c1 88       	rjmp	80008fb4 <_vfprintf_r+0xf34>
80008f86:	41 09       	lddsp	r9,sp[0x40]
80008f88:	59 f8       	cp.w	r8,31
80008f8a:	e0 89 00 11 	brgt	80008fac <_vfprintf_r+0xf2c>
80008f8e:	f2 cb ff fc 	sub	r11,r9,-4
80008f92:	51 0b       	stdsp	sp[0x40],r11
80008f94:	fa c6 f9 44 	sub	r6,sp,-1724
80008f98:	72 0b       	ld.w	r11,r9[0x0]
80008f9a:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008f9e:	f3 4b fd 88 	st.w	r9[-632],r11
80008fa2:	2f f8       	sub	r8,-1
80008fa4:	14 97       	mov	r7,r10
80008fa6:	fb 48 06 b4 	st.w	sp[1716],r8
80008faa:	c0 58       	rjmp	80008fb4 <_vfprintf_r+0xf34>
80008fac:	72 0b       	ld.w	r11,r9[0x0]
80008fae:	14 97       	mov	r7,r10
80008fb0:	2f c9       	sub	r9,-4
80008fb2:	51 09       	stdsp	sp[0x40],r9
80008fb4:	50 1b       	stdsp	sp[0x4],r11
80008fb6:	30 0e       	mov	lr,0
80008fb8:	50 0e       	stdsp	sp[0x0],lr
80008fba:	1c 98       	mov	r8,lr
80008fbc:	e0 8f 02 fe 	bral	800095b8 <_vfprintf_r+0x1538>
80008fc0:	50 a7       	stdsp	sp[0x28],r7
80008fc2:	50 80       	stdsp	sp[0x20],r0
80008fc4:	0c 97       	mov	r7,r6
80008fc6:	04 94       	mov	r4,r2
80008fc8:	06 96       	mov	r6,r3
80008fca:	02 92       	mov	r2,r1
80008fcc:	40 93       	lddsp	r3,sp[0x24]
80008fce:	40 41       	lddsp	r1,sp[0x10]
80008fd0:	0e 99       	mov	r9,r7
80008fd2:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008fd6:	40 3c       	lddsp	r12,sp[0xc]
80008fd8:	58 0c       	cp.w	r12,0
80008fda:	c1 d0       	breq	80009014 <_vfprintf_r+0xf94>
80008fdc:	10 36       	cp.w	r6,r8
80008fde:	c0 64       	brge	80008fea <_vfprintf_r+0xf6a>
80008fe0:	fa cb f9 44 	sub	r11,sp,-1724
80008fe4:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008fe8:	c1 d8       	rjmp	80009022 <_vfprintf_r+0xfa2>
80008fea:	fa c8 f9 50 	sub	r8,sp,-1712
80008fee:	1a d8       	st.w	--sp,r8
80008ff0:	fa c8 fa b8 	sub	r8,sp,-1352
80008ff4:	1a d8       	st.w	--sp,r8
80008ff6:	fa c8 fb b4 	sub	r8,sp,-1100
80008ffa:	1a d8       	st.w	--sp,r8
80008ffc:	fa c9 ff b4 	sub	r9,sp,-76
80009000:	fa c8 f9 40 	sub	r8,sp,-1728
80009004:	04 9a       	mov	r10,r2
80009006:	0c 9b       	mov	r11,r6
80009008:	08 9c       	mov	r12,r4
8000900a:	fe b0 f6 a3 	rcall	80007d50 <get_arg>
8000900e:	2f dd       	sub	sp,-12
80009010:	78 09       	ld.w	r9,r12[0x0]
80009012:	c2 18       	rjmp	80009054 <_vfprintf_r+0xfd4>
80009014:	2f f7       	sub	r7,-1
80009016:	10 39       	cp.w	r9,r8
80009018:	c0 84       	brge	80009028 <_vfprintf_r+0xfa8>
8000901a:	fa ca f9 44 	sub	r10,sp,-1724
8000901e:	f4 06 00 36 	add	r6,r10,r6<<0x3
80009022:	ec f9 fd 88 	ld.w	r9,r6[-632]
80009026:	c1 78       	rjmp	80009054 <_vfprintf_r+0xfd4>
80009028:	41 09       	lddsp	r9,sp[0x40]
8000902a:	59 f8       	cp.w	r8,31
8000902c:	e0 89 00 10 	brgt	8000904c <_vfprintf_r+0xfcc>
80009030:	f2 ca ff fc 	sub	r10,r9,-4
80009034:	51 0a       	stdsp	sp[0x40],r10
80009036:	fa c6 f9 44 	sub	r6,sp,-1724
8000903a:	72 09       	ld.w	r9,r9[0x0]
8000903c:	ec 08 00 3a 	add	r10,r6,r8<<0x3
80009040:	f5 49 fd 88 	st.w	r10[-632],r9
80009044:	2f f8       	sub	r8,-1
80009046:	fb 48 06 b4 	st.w	sp[1716],r8
8000904a:	c0 58       	rjmp	80009054 <_vfprintf_r+0xfd4>
8000904c:	f2 c8 ff fc 	sub	r8,r9,-4
80009050:	51 08       	stdsp	sp[0x40],r8
80009052:	72 09       	ld.w	r9,r9[0x0]
80009054:	33 08       	mov	r8,48
80009056:	fb 68 06 b8 	st.b	sp[1720],r8
8000905a:	37 88       	mov	r8,120
8000905c:	30 0e       	mov	lr,0
8000905e:	fb 68 06 b9 	st.b	sp[1721],r8
80009062:	fe cc b0 92 	sub	r12,pc,-20334
80009066:	50 19       	stdsp	sp[0x4],r9
80009068:	a1 b5       	sbr	r5,0x1
8000906a:	50 0e       	stdsp	sp[0x0],lr
8000906c:	50 dc       	stdsp	sp[0x34],r12
8000906e:	30 28       	mov	r8,2
80009070:	37 80       	mov	r0,120
80009072:	e0 8f 02 a3 	bral	800095b8 <_vfprintf_r+0x1538>
80009076:	50 a7       	stdsp	sp[0x28],r7
80009078:	50 80       	stdsp	sp[0x20],r0
8000907a:	10 90       	mov	r0,r8
8000907c:	30 08       	mov	r8,0
8000907e:	fb 68 06 bb 	st.b	sp[1723],r8
80009082:	0c 97       	mov	r7,r6
80009084:	04 94       	mov	r4,r2
80009086:	06 96       	mov	r6,r3
80009088:	02 92       	mov	r2,r1
8000908a:	40 93       	lddsp	r3,sp[0x24]
8000908c:	40 41       	lddsp	r1,sp[0x10]
8000908e:	0e 99       	mov	r9,r7
80009090:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009094:	40 3b       	lddsp	r11,sp[0xc]
80009096:	58 0b       	cp.w	r11,0
80009098:	c1 d0       	breq	800090d2 <_vfprintf_r+0x1052>
8000909a:	10 36       	cp.w	r6,r8
8000909c:	c0 64       	brge	800090a8 <_vfprintf_r+0x1028>
8000909e:	fa ca f9 44 	sub	r10,sp,-1724
800090a2:	f4 06 00 36 	add	r6,r10,r6<<0x3
800090a6:	c1 d8       	rjmp	800090e0 <_vfprintf_r+0x1060>
800090a8:	fa c8 f9 50 	sub	r8,sp,-1712
800090ac:	1a d8       	st.w	--sp,r8
800090ae:	fa c8 fa b8 	sub	r8,sp,-1352
800090b2:	1a d8       	st.w	--sp,r8
800090b4:	fa c8 fb b4 	sub	r8,sp,-1100
800090b8:	0c 9b       	mov	r11,r6
800090ba:	1a d8       	st.w	--sp,r8
800090bc:	04 9a       	mov	r10,r2
800090be:	fa c8 f9 40 	sub	r8,sp,-1728
800090c2:	fa c9 ff b4 	sub	r9,sp,-76
800090c6:	08 9c       	mov	r12,r4
800090c8:	fe b0 f6 44 	rcall	80007d50 <get_arg>
800090cc:	2f dd       	sub	sp,-12
800090ce:	78 06       	ld.w	r6,r12[0x0]
800090d0:	c2 08       	rjmp	80009110 <_vfprintf_r+0x1090>
800090d2:	2f f7       	sub	r7,-1
800090d4:	10 39       	cp.w	r9,r8
800090d6:	c0 84       	brge	800090e6 <_vfprintf_r+0x1066>
800090d8:	fa c9 f9 44 	sub	r9,sp,-1724
800090dc:	f2 06 00 36 	add	r6,r9,r6<<0x3
800090e0:	ec f6 fd 88 	ld.w	r6,r6[-632]
800090e4:	c1 68       	rjmp	80009110 <_vfprintf_r+0x1090>
800090e6:	41 09       	lddsp	r9,sp[0x40]
800090e8:	59 f8       	cp.w	r8,31
800090ea:	e0 89 00 10 	brgt	8000910a <_vfprintf_r+0x108a>
800090ee:	f2 ca ff fc 	sub	r10,r9,-4
800090f2:	51 0a       	stdsp	sp[0x40],r10
800090f4:	72 06       	ld.w	r6,r9[0x0]
800090f6:	fa ce f9 44 	sub	lr,sp,-1724
800090fa:	fc 08 00 39 	add	r9,lr,r8<<0x3
800090fe:	f3 46 fd 88 	st.w	r9[-632],r6
80009102:	2f f8       	sub	r8,-1
80009104:	fb 48 06 b4 	st.w	sp[1716],r8
80009108:	c0 48       	rjmp	80009110 <_vfprintf_r+0x1090>
8000910a:	72 06       	ld.w	r6,r9[0x0]
8000910c:	2f c9       	sub	r9,-4
8000910e:	51 09       	stdsp	sp[0x40],r9
80009110:	40 2c       	lddsp	r12,sp[0x8]
80009112:	58 0c       	cp.w	r12,0
80009114:	c1 05       	brlt	80009134 <_vfprintf_r+0x10b4>
80009116:	18 9a       	mov	r10,r12
80009118:	30 0b       	mov	r11,0
8000911a:	0c 9c       	mov	r12,r6
8000911c:	e0 a0 12 38 	rcall	8000b58c <memchr>
80009120:	e0 80 02 df 	breq	800096de <_vfprintf_r+0x165e>
80009124:	f8 06 01 02 	sub	r2,r12,r6
80009128:	40 2b       	lddsp	r11,sp[0x8]
8000912a:	16 32       	cp.w	r2,r11
8000912c:	e0 89 02 d9 	brgt	800096de <_vfprintf_r+0x165e>
80009130:	e0 8f 02 d4 	bral	800096d8 <_vfprintf_r+0x1658>
80009134:	30 0a       	mov	r10,0
80009136:	0c 9c       	mov	r12,r6
80009138:	50 2a       	stdsp	sp[0x8],r10
8000913a:	e0 a0 15 99 	rcall	8000bc6c <strlen>
8000913e:	18 92       	mov	r2,r12
80009140:	e0 8f 02 d2 	bral	800096e4 <_vfprintf_r+0x1664>
80009144:	50 a7       	stdsp	sp[0x28],r7
80009146:	50 80       	stdsp	sp[0x20],r0
80009148:	0c 97       	mov	r7,r6
8000914a:	04 94       	mov	r4,r2
8000914c:	06 96       	mov	r6,r3
8000914e:	02 92       	mov	r2,r1
80009150:	40 93       	lddsp	r3,sp[0x24]
80009152:	10 90       	mov	r0,r8
80009154:	40 41       	lddsp	r1,sp[0x10]
80009156:	a5 a5       	sbr	r5,0x4
80009158:	c0 a8       	rjmp	8000916c <_vfprintf_r+0x10ec>
8000915a:	50 a7       	stdsp	sp[0x28],r7
8000915c:	50 80       	stdsp	sp[0x20],r0
8000915e:	0c 97       	mov	r7,r6
80009160:	04 94       	mov	r4,r2
80009162:	06 96       	mov	r6,r3
80009164:	02 92       	mov	r2,r1
80009166:	40 93       	lddsp	r3,sp[0x24]
80009168:	10 90       	mov	r0,r8
8000916a:	40 41       	lddsp	r1,sp[0x10]
8000916c:	ed b5 00 05 	bld	r5,0x5
80009170:	c5 61       	brne	8000921c <_vfprintf_r+0x119c>
80009172:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009176:	40 39       	lddsp	r9,sp[0xc]
80009178:	58 09       	cp.w	r9,0
8000917a:	c2 10       	breq	800091bc <_vfprintf_r+0x113c>
8000917c:	10 36       	cp.w	r6,r8
8000917e:	c0 74       	brge	8000918c <_vfprintf_r+0x110c>
80009180:	fa c8 f9 44 	sub	r8,sp,-1724
80009184:	f0 06 00 36 	add	r6,r8,r6<<0x3
80009188:	c2 38       	rjmp	800091ce <_vfprintf_r+0x114e>
8000918a:	d7 03       	nop
8000918c:	fa c8 f9 50 	sub	r8,sp,-1712
80009190:	1a d8       	st.w	--sp,r8
80009192:	fa c8 fa b8 	sub	r8,sp,-1352
80009196:	1a d8       	st.w	--sp,r8
80009198:	fa c8 fb b4 	sub	r8,sp,-1100
8000919c:	1a d8       	st.w	--sp,r8
8000919e:	fa c8 f9 40 	sub	r8,sp,-1728
800091a2:	fa c9 ff b4 	sub	r9,sp,-76
800091a6:	04 9a       	mov	r10,r2
800091a8:	0c 9b       	mov	r11,r6
800091aa:	08 9c       	mov	r12,r4
800091ac:	fe b0 f5 d2 	rcall	80007d50 <get_arg>
800091b0:	2f dd       	sub	sp,-12
800091b2:	f8 e8 00 00 	ld.d	r8,r12[0]
800091b6:	fa e9 00 00 	st.d	sp[0],r8
800091ba:	c2 e8       	rjmp	80009216 <_vfprintf_r+0x1196>
800091bc:	ee ca ff ff 	sub	r10,r7,-1
800091c0:	10 37       	cp.w	r7,r8
800091c2:	c0 b4       	brge	800091d8 <_vfprintf_r+0x1158>
800091c4:	fa c8 f9 44 	sub	r8,sp,-1724
800091c8:	14 97       	mov	r7,r10
800091ca:	f0 06 00 36 	add	r6,r8,r6<<0x3
800091ce:	ec ea fd 88 	ld.d	r10,r6[-632]
800091d2:	fa eb 00 00 	st.d	sp[0],r10
800091d6:	c2 08       	rjmp	80009216 <_vfprintf_r+0x1196>
800091d8:	41 09       	lddsp	r9,sp[0x40]
800091da:	59 f8       	cp.w	r8,31
800091dc:	e0 89 00 16 	brgt	80009208 <_vfprintf_r+0x1188>
800091e0:	f2 e6 00 00 	ld.d	r6,r9[0]
800091e4:	f2 cb ff f8 	sub	r11,r9,-8
800091e8:	fa e7 00 00 	st.d	sp[0],r6
800091ec:	51 0b       	stdsp	sp[0x40],r11
800091ee:	fa c6 f9 44 	sub	r6,sp,-1724
800091f2:	ec 08 00 39 	add	r9,r6,r8<<0x3
800091f6:	fa e6 00 00 	ld.d	r6,sp[0]
800091fa:	f2 e7 fd 88 	st.d	r9[-632],r6
800091fe:	2f f8       	sub	r8,-1
80009200:	14 97       	mov	r7,r10
80009202:	fb 48 06 b4 	st.w	sp[1716],r8
80009206:	c0 88       	rjmp	80009216 <_vfprintf_r+0x1196>
80009208:	f2 e6 00 00 	ld.d	r6,r9[0]
8000920c:	2f 89       	sub	r9,-8
8000920e:	fa e7 00 00 	st.d	sp[0],r6
80009212:	51 09       	stdsp	sp[0x40],r9
80009214:	14 97       	mov	r7,r10
80009216:	30 18       	mov	r8,1
80009218:	e0 8f 01 d0 	bral	800095b8 <_vfprintf_r+0x1538>
8000921c:	ed b5 00 04 	bld	r5,0x4
80009220:	c1 61       	brne	8000924c <_vfprintf_r+0x11cc>
80009222:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009226:	40 3e       	lddsp	lr,sp[0xc]
80009228:	58 0e       	cp.w	lr,0
8000922a:	c0 80       	breq	8000923a <_vfprintf_r+0x11ba>
8000922c:	10 36       	cp.w	r6,r8
8000922e:	c6 74       	brge	800092fc <_vfprintf_r+0x127c>
80009230:	fa cc f9 44 	sub	r12,sp,-1724
80009234:	f8 06 00 36 	add	r6,r12,r6<<0x3
80009238:	c8 08       	rjmp	80009338 <_vfprintf_r+0x12b8>
8000923a:	ee ca ff ff 	sub	r10,r7,-1
8000923e:	10 37       	cp.w	r7,r8
80009240:	c7 f4       	brge	8000933e <_vfprintf_r+0x12be>
80009242:	fa cb f9 44 	sub	r11,sp,-1724
80009246:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000924a:	c7 68       	rjmp	80009336 <_vfprintf_r+0x12b6>
8000924c:	ed b5 00 06 	bld	r5,0x6
80009250:	c4 a1       	brne	800092e4 <_vfprintf_r+0x1264>
80009252:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009256:	40 3c       	lddsp	r12,sp[0xc]
80009258:	58 0c       	cp.w	r12,0
8000925a:	c1 d0       	breq	80009294 <_vfprintf_r+0x1214>
8000925c:	10 36       	cp.w	r6,r8
8000925e:	c0 64       	brge	8000926a <_vfprintf_r+0x11ea>
80009260:	fa cb f9 44 	sub	r11,sp,-1724
80009264:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009268:	c1 f8       	rjmp	800092a6 <_vfprintf_r+0x1226>
8000926a:	fa c8 f9 50 	sub	r8,sp,-1712
8000926e:	1a d8       	st.w	--sp,r8
80009270:	fa c8 fa b8 	sub	r8,sp,-1352
80009274:	1a d8       	st.w	--sp,r8
80009276:	fa c8 fb b4 	sub	r8,sp,-1100
8000927a:	1a d8       	st.w	--sp,r8
8000927c:	fa c8 f9 40 	sub	r8,sp,-1728
80009280:	fa c9 ff b4 	sub	r9,sp,-76
80009284:	04 9a       	mov	r10,r2
80009286:	0c 9b       	mov	r11,r6
80009288:	08 9c       	mov	r12,r4
8000928a:	fe b0 f5 63 	rcall	80007d50 <get_arg>
8000928e:	2f dd       	sub	sp,-12
80009290:	98 18       	ld.sh	r8,r12[0x2]
80009292:	c2 68       	rjmp	800092de <_vfprintf_r+0x125e>
80009294:	ee ca ff ff 	sub	r10,r7,-1
80009298:	10 37       	cp.w	r7,r8
8000929a:	c0 94       	brge	800092ac <_vfprintf_r+0x122c>
8000929c:	fa c9 f9 44 	sub	r9,sp,-1724
800092a0:	14 97       	mov	r7,r10
800092a2:	f2 06 00 36 	add	r6,r9,r6<<0x3
800092a6:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
800092aa:	c1 a8       	rjmp	800092de <_vfprintf_r+0x125e>
800092ac:	41 09       	lddsp	r9,sp[0x40]
800092ae:	59 f8       	cp.w	r8,31
800092b0:	e0 89 00 13 	brgt	800092d6 <_vfprintf_r+0x1256>
800092b4:	f2 cb ff fc 	sub	r11,r9,-4
800092b8:	51 0b       	stdsp	sp[0x40],r11
800092ba:	72 09       	ld.w	r9,r9[0x0]
800092bc:	fa c6 f9 44 	sub	r6,sp,-1724
800092c0:	ec 08 00 3b 	add	r11,r6,r8<<0x3
800092c4:	2f f8       	sub	r8,-1
800092c6:	f7 49 fd 88 	st.w	r11[-632],r9
800092ca:	fb 48 06 b4 	st.w	sp[1716],r8
800092ce:	14 97       	mov	r7,r10
800092d0:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
800092d4:	c0 58       	rjmp	800092de <_vfprintf_r+0x125e>
800092d6:	92 18       	ld.sh	r8,r9[0x2]
800092d8:	14 97       	mov	r7,r10
800092da:	2f c9       	sub	r9,-4
800092dc:	51 09       	stdsp	sp[0x40],r9
800092de:	5c 78       	castu.h	r8
800092e0:	50 18       	stdsp	sp[0x4],r8
800092e2:	c4 68       	rjmp	8000936e <_vfprintf_r+0x12ee>
800092e4:	fa f8 06 b4 	ld.w	r8,sp[1716]
800092e8:	40 3c       	lddsp	r12,sp[0xc]
800092ea:	58 0c       	cp.w	r12,0
800092ec:	c1 d0       	breq	80009326 <_vfprintf_r+0x12a6>
800092ee:	10 36       	cp.w	r6,r8
800092f0:	c0 64       	brge	800092fc <_vfprintf_r+0x127c>
800092f2:	fa cb f9 44 	sub	r11,sp,-1724
800092f6:	f6 06 00 36 	add	r6,r11,r6<<0x3
800092fa:	c1 f8       	rjmp	80009338 <_vfprintf_r+0x12b8>
800092fc:	fa c8 f9 50 	sub	r8,sp,-1712
80009300:	1a d8       	st.w	--sp,r8
80009302:	fa c8 fa b8 	sub	r8,sp,-1352
80009306:	0c 9b       	mov	r11,r6
80009308:	1a d8       	st.w	--sp,r8
8000930a:	fa c8 fb b4 	sub	r8,sp,-1100
8000930e:	04 9a       	mov	r10,r2
80009310:	1a d8       	st.w	--sp,r8
80009312:	08 9c       	mov	r12,r4
80009314:	fa c8 f9 40 	sub	r8,sp,-1728
80009318:	fa c9 ff b4 	sub	r9,sp,-76
8000931c:	fe b0 f5 1a 	rcall	80007d50 <get_arg>
80009320:	2f dd       	sub	sp,-12
80009322:	78 0b       	ld.w	r11,r12[0x0]
80009324:	c2 48       	rjmp	8000936c <_vfprintf_r+0x12ec>
80009326:	ee ca ff ff 	sub	r10,r7,-1
8000932a:	10 37       	cp.w	r7,r8
8000932c:	c0 94       	brge	8000933e <_vfprintf_r+0x12be>
8000932e:	fa c9 f9 44 	sub	r9,sp,-1724
80009332:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009336:	14 97       	mov	r7,r10
80009338:	ec fb fd 88 	ld.w	r11,r6[-632]
8000933c:	c1 88       	rjmp	8000936c <_vfprintf_r+0x12ec>
8000933e:	41 09       	lddsp	r9,sp[0x40]
80009340:	59 f8       	cp.w	r8,31
80009342:	e0 89 00 11 	brgt	80009364 <_vfprintf_r+0x12e4>
80009346:	f2 cb ff fc 	sub	r11,r9,-4
8000934a:	51 0b       	stdsp	sp[0x40],r11
8000934c:	fa c6 f9 44 	sub	r6,sp,-1724
80009350:	72 0b       	ld.w	r11,r9[0x0]
80009352:	ec 08 00 39 	add	r9,r6,r8<<0x3
80009356:	f3 4b fd 88 	st.w	r9[-632],r11
8000935a:	2f f8       	sub	r8,-1
8000935c:	14 97       	mov	r7,r10
8000935e:	fb 48 06 b4 	st.w	sp[1716],r8
80009362:	c0 58       	rjmp	8000936c <_vfprintf_r+0x12ec>
80009364:	72 0b       	ld.w	r11,r9[0x0]
80009366:	14 97       	mov	r7,r10
80009368:	2f c9       	sub	r9,-4
8000936a:	51 09       	stdsp	sp[0x40],r9
8000936c:	50 1b       	stdsp	sp[0x4],r11
8000936e:	30 0e       	mov	lr,0
80009370:	30 18       	mov	r8,1
80009372:	50 0e       	stdsp	sp[0x0],lr
80009374:	c2 29       	rjmp	800095b8 <_vfprintf_r+0x1538>
80009376:	50 a7       	stdsp	sp[0x28],r7
80009378:	50 80       	stdsp	sp[0x20],r0
8000937a:	0c 97       	mov	r7,r6
8000937c:	04 94       	mov	r4,r2
8000937e:	06 96       	mov	r6,r3
80009380:	02 92       	mov	r2,r1
80009382:	fe cc b3 b2 	sub	r12,pc,-19534
80009386:	40 93       	lddsp	r3,sp[0x24]
80009388:	10 90       	mov	r0,r8
8000938a:	40 41       	lddsp	r1,sp[0x10]
8000938c:	50 dc       	stdsp	sp[0x34],r12
8000938e:	ed b5 00 05 	bld	r5,0x5
80009392:	c5 51       	brne	8000943c <_vfprintf_r+0x13bc>
80009394:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009398:	40 3b       	lddsp	r11,sp[0xc]
8000939a:	58 0b       	cp.w	r11,0
8000939c:	c2 20       	breq	800093e0 <_vfprintf_r+0x1360>
8000939e:	10 36       	cp.w	r6,r8
800093a0:	c0 a4       	brge	800093b4 <_vfprintf_r+0x1334>
800093a2:	fa ca f9 44 	sub	r10,sp,-1724
800093a6:	f4 06 00 36 	add	r6,r10,r6<<0x3
800093aa:	ec e8 fd 88 	ld.d	r8,r6[-632]
800093ae:	fa e9 00 00 	st.d	sp[0],r8
800093b2:	cf 28       	rjmp	80009596 <_vfprintf_r+0x1516>
800093b4:	fa c8 f9 50 	sub	r8,sp,-1712
800093b8:	1a d8       	st.w	--sp,r8
800093ba:	fa c8 fa b8 	sub	r8,sp,-1352
800093be:	04 9a       	mov	r10,r2
800093c0:	1a d8       	st.w	--sp,r8
800093c2:	0c 9b       	mov	r11,r6
800093c4:	fa c8 fb b4 	sub	r8,sp,-1100
800093c8:	08 9c       	mov	r12,r4
800093ca:	1a d8       	st.w	--sp,r8
800093cc:	fa c8 f9 40 	sub	r8,sp,-1728
800093d0:	fa c9 ff b4 	sub	r9,sp,-76
800093d4:	fe b0 f4 be 	rcall	80007d50 <get_arg>
800093d8:	2f dd       	sub	sp,-12
800093da:	f8 ea 00 00 	ld.d	r10,r12[0]
800093de:	c0 c8       	rjmp	800093f6 <_vfprintf_r+0x1376>
800093e0:	ee ca ff ff 	sub	r10,r7,-1
800093e4:	10 37       	cp.w	r7,r8
800093e6:	c0 b4       	brge	800093fc <_vfprintf_r+0x137c>
800093e8:	fa c9 f9 44 	sub	r9,sp,-1724
800093ec:	14 97       	mov	r7,r10
800093ee:	f2 06 00 36 	add	r6,r9,r6<<0x3
800093f2:	ec ea fd 88 	ld.d	r10,r6[-632]
800093f6:	fa eb 00 00 	st.d	sp[0],r10
800093fa:	cc e8       	rjmp	80009596 <_vfprintf_r+0x1516>
800093fc:	41 09       	lddsp	r9,sp[0x40]
800093fe:	59 f8       	cp.w	r8,31
80009400:	e0 89 00 16 	brgt	8000942c <_vfprintf_r+0x13ac>
80009404:	f2 e6 00 00 	ld.d	r6,r9[0]
80009408:	f2 cb ff f8 	sub	r11,r9,-8
8000940c:	fa e7 00 00 	st.d	sp[0],r6
80009410:	51 0b       	stdsp	sp[0x40],r11
80009412:	fa c6 f9 44 	sub	r6,sp,-1724
80009416:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000941a:	fa e6 00 00 	ld.d	r6,sp[0]
8000941e:	f2 e7 fd 88 	st.d	r9[-632],r6
80009422:	2f f8       	sub	r8,-1
80009424:	14 97       	mov	r7,r10
80009426:	fb 48 06 b4 	st.w	sp[1716],r8
8000942a:	cb 68       	rjmp	80009596 <_vfprintf_r+0x1516>
8000942c:	f2 e6 00 00 	ld.d	r6,r9[0]
80009430:	2f 89       	sub	r9,-8
80009432:	fa e7 00 00 	st.d	sp[0],r6
80009436:	51 09       	stdsp	sp[0x40],r9
80009438:	14 97       	mov	r7,r10
8000943a:	ca e8       	rjmp	80009596 <_vfprintf_r+0x1516>
8000943c:	ed b5 00 04 	bld	r5,0x4
80009440:	c1 71       	brne	8000946e <_vfprintf_r+0x13ee>
80009442:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009446:	40 3e       	lddsp	lr,sp[0xc]
80009448:	58 0e       	cp.w	lr,0
8000944a:	c0 80       	breq	8000945a <_vfprintf_r+0x13da>
8000944c:	10 36       	cp.w	r6,r8
8000944e:	c6 94       	brge	80009520 <_vfprintf_r+0x14a0>
80009450:	fa cc f9 44 	sub	r12,sp,-1724
80009454:	f8 06 00 36 	add	r6,r12,r6<<0x3
80009458:	c8 28       	rjmp	8000955c <_vfprintf_r+0x14dc>
8000945a:	ee ca ff ff 	sub	r10,r7,-1
8000945e:	10 37       	cp.w	r7,r8
80009460:	e0 84 00 81 	brge	80009562 <_vfprintf_r+0x14e2>
80009464:	fa cb f9 44 	sub	r11,sp,-1724
80009468:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000946c:	c7 78       	rjmp	8000955a <_vfprintf_r+0x14da>
8000946e:	ed b5 00 06 	bld	r5,0x6
80009472:	c4 b1       	brne	80009508 <_vfprintf_r+0x1488>
80009474:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009478:	40 3c       	lddsp	r12,sp[0xc]
8000947a:	58 0c       	cp.w	r12,0
8000947c:	c1 d0       	breq	800094b6 <_vfprintf_r+0x1436>
8000947e:	10 36       	cp.w	r6,r8
80009480:	c0 64       	brge	8000948c <_vfprintf_r+0x140c>
80009482:	fa cb f9 44 	sub	r11,sp,-1724
80009486:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000948a:	c1 f8       	rjmp	800094c8 <_vfprintf_r+0x1448>
8000948c:	fa c8 f9 50 	sub	r8,sp,-1712
80009490:	1a d8       	st.w	--sp,r8
80009492:	fa c8 fa b8 	sub	r8,sp,-1352
80009496:	1a d8       	st.w	--sp,r8
80009498:	fa c8 fb b4 	sub	r8,sp,-1100
8000949c:	1a d8       	st.w	--sp,r8
8000949e:	fa c8 f9 40 	sub	r8,sp,-1728
800094a2:	fa c9 ff b4 	sub	r9,sp,-76
800094a6:	04 9a       	mov	r10,r2
800094a8:	0c 9b       	mov	r11,r6
800094aa:	08 9c       	mov	r12,r4
800094ac:	fe b0 f4 52 	rcall	80007d50 <get_arg>
800094b0:	2f dd       	sub	sp,-12
800094b2:	98 18       	ld.sh	r8,r12[0x2]
800094b4:	c2 78       	rjmp	80009502 <_vfprintf_r+0x1482>
800094b6:	ee ca ff ff 	sub	r10,r7,-1
800094ba:	10 37       	cp.w	r7,r8
800094bc:	c0 a4       	brge	800094d0 <_vfprintf_r+0x1450>
800094be:	fa c9 f9 44 	sub	r9,sp,-1724
800094c2:	14 97       	mov	r7,r10
800094c4:	f2 06 00 36 	add	r6,r9,r6<<0x3
800094c8:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
800094cc:	c1 b8       	rjmp	80009502 <_vfprintf_r+0x1482>
800094ce:	d7 03       	nop
800094d0:	41 09       	lddsp	r9,sp[0x40]
800094d2:	59 f8       	cp.w	r8,31
800094d4:	e0 89 00 13 	brgt	800094fa <_vfprintf_r+0x147a>
800094d8:	f2 cb ff fc 	sub	r11,r9,-4
800094dc:	51 0b       	stdsp	sp[0x40],r11
800094de:	72 09       	ld.w	r9,r9[0x0]
800094e0:	fa c6 f9 44 	sub	r6,sp,-1724
800094e4:	ec 08 00 3b 	add	r11,r6,r8<<0x3
800094e8:	2f f8       	sub	r8,-1
800094ea:	f7 49 fd 88 	st.w	r11[-632],r9
800094ee:	fb 48 06 b4 	st.w	sp[1716],r8
800094f2:	14 97       	mov	r7,r10
800094f4:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
800094f8:	c0 58       	rjmp	80009502 <_vfprintf_r+0x1482>
800094fa:	92 18       	ld.sh	r8,r9[0x2]
800094fc:	14 97       	mov	r7,r10
800094fe:	2f c9       	sub	r9,-4
80009500:	51 09       	stdsp	sp[0x40],r9
80009502:	5c 78       	castu.h	r8
80009504:	50 18       	stdsp	sp[0x4],r8
80009506:	c4 68       	rjmp	80009592 <_vfprintf_r+0x1512>
80009508:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000950c:	40 3c       	lddsp	r12,sp[0xc]
8000950e:	58 0c       	cp.w	r12,0
80009510:	c1 d0       	breq	8000954a <_vfprintf_r+0x14ca>
80009512:	10 36       	cp.w	r6,r8
80009514:	c0 64       	brge	80009520 <_vfprintf_r+0x14a0>
80009516:	fa cb f9 44 	sub	r11,sp,-1724
8000951a:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000951e:	c1 f8       	rjmp	8000955c <_vfprintf_r+0x14dc>
80009520:	fa c8 f9 50 	sub	r8,sp,-1712
80009524:	1a d8       	st.w	--sp,r8
80009526:	fa c8 fa b8 	sub	r8,sp,-1352
8000952a:	0c 9b       	mov	r11,r6
8000952c:	1a d8       	st.w	--sp,r8
8000952e:	fa c8 fb b4 	sub	r8,sp,-1100
80009532:	04 9a       	mov	r10,r2
80009534:	1a d8       	st.w	--sp,r8
80009536:	08 9c       	mov	r12,r4
80009538:	fa c8 f9 40 	sub	r8,sp,-1728
8000953c:	fa c9 ff b4 	sub	r9,sp,-76
80009540:	fe b0 f4 08 	rcall	80007d50 <get_arg>
80009544:	2f dd       	sub	sp,-12
80009546:	78 0b       	ld.w	r11,r12[0x0]
80009548:	c2 48       	rjmp	80009590 <_vfprintf_r+0x1510>
8000954a:	ee ca ff ff 	sub	r10,r7,-1
8000954e:	10 37       	cp.w	r7,r8
80009550:	c0 94       	brge	80009562 <_vfprintf_r+0x14e2>
80009552:	fa c9 f9 44 	sub	r9,sp,-1724
80009556:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000955a:	14 97       	mov	r7,r10
8000955c:	ec fb fd 88 	ld.w	r11,r6[-632]
80009560:	c1 88       	rjmp	80009590 <_vfprintf_r+0x1510>
80009562:	41 09       	lddsp	r9,sp[0x40]
80009564:	59 f8       	cp.w	r8,31
80009566:	e0 89 00 11 	brgt	80009588 <_vfprintf_r+0x1508>
8000956a:	f2 cb ff fc 	sub	r11,r9,-4
8000956e:	51 0b       	stdsp	sp[0x40],r11
80009570:	fa c6 f9 44 	sub	r6,sp,-1724
80009574:	72 0b       	ld.w	r11,r9[0x0]
80009576:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000957a:	f3 4b fd 88 	st.w	r9[-632],r11
8000957e:	2f f8       	sub	r8,-1
80009580:	14 97       	mov	r7,r10
80009582:	fb 48 06 b4 	st.w	sp[1716],r8
80009586:	c0 58       	rjmp	80009590 <_vfprintf_r+0x1510>
80009588:	72 0b       	ld.w	r11,r9[0x0]
8000958a:	14 97       	mov	r7,r10
8000958c:	2f c9       	sub	r9,-4
8000958e:	51 09       	stdsp	sp[0x40],r9
80009590:	50 1b       	stdsp	sp[0x4],r11
80009592:	30 0e       	mov	lr,0
80009594:	50 0e       	stdsp	sp[0x0],lr
80009596:	40 08       	lddsp	r8,sp[0x0]
80009598:	40 1c       	lddsp	r12,sp[0x4]
8000959a:	18 48       	or	r8,r12
8000959c:	5f 19       	srne	r9
8000959e:	0a 98       	mov	r8,r5
800095a0:	eb e9 00 09 	and	r9,r5,r9
800095a4:	a1 b8       	sbr	r8,0x1
800095a6:	58 09       	cp.w	r9,0
800095a8:	c0 70       	breq	800095b6 <_vfprintf_r+0x1536>
800095aa:	10 95       	mov	r5,r8
800095ac:	fb 60 06 b9 	st.b	sp[1721],r0
800095b0:	33 08       	mov	r8,48
800095b2:	fb 68 06 b8 	st.b	sp[1720],r8
800095b6:	30 28       	mov	r8,2
800095b8:	30 09       	mov	r9,0
800095ba:	fb 69 06 bb 	st.b	sp[1723],r9
800095be:	0a 99       	mov	r9,r5
800095c0:	a7 d9       	cbr	r9,0x7
800095c2:	40 2b       	lddsp	r11,sp[0x8]
800095c4:	40 16       	lddsp	r6,sp[0x4]
800095c6:	58 0b       	cp.w	r11,0
800095c8:	5f 1a       	srne	r10
800095ca:	f2 05 17 40 	movge	r5,r9
800095ce:	fa c2 f9 78 	sub	r2,sp,-1672
800095d2:	40 09       	lddsp	r9,sp[0x0]
800095d4:	0c 49       	or	r9,r6
800095d6:	5f 19       	srne	r9
800095d8:	f5 e9 10 09 	or	r9,r10,r9
800095dc:	c5 c0       	breq	80009694 <_vfprintf_r+0x1614>
800095de:	30 19       	mov	r9,1
800095e0:	f2 08 18 00 	cp.b	r8,r9
800095e4:	c0 60       	breq	800095f0 <_vfprintf_r+0x1570>
800095e6:	30 29       	mov	r9,2
800095e8:	f2 08 18 00 	cp.b	r8,r9
800095ec:	c0 41       	brne	800095f4 <_vfprintf_r+0x1574>
800095ee:	c3 c8       	rjmp	80009666 <_vfprintf_r+0x15e6>
800095f0:	04 96       	mov	r6,r2
800095f2:	c3 08       	rjmp	80009652 <_vfprintf_r+0x15d2>
800095f4:	04 96       	mov	r6,r2
800095f6:	fa e8 00 00 	ld.d	r8,sp[0]
800095fa:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
800095fe:	2d 0a       	sub	r10,-48
80009600:	0c fa       	st.b	--r6,r10
80009602:	f0 0b 16 03 	lsr	r11,r8,0x3
80009606:	f2 0c 16 03 	lsr	r12,r9,0x3
8000960a:	f7 e9 11 db 	or	r11,r11,r9<<0x1d
8000960e:	18 99       	mov	r9,r12
80009610:	16 98       	mov	r8,r11
80009612:	58 08       	cp.w	r8,0
80009614:	5c 29       	cpc	r9
80009616:	cf 21       	brne	800095fa <_vfprintf_r+0x157a>
80009618:	fa e9 00 00 	st.d	sp[0],r8
8000961c:	ed b5 00 00 	bld	r5,0x0
80009620:	c4 51       	brne	800096aa <_vfprintf_r+0x162a>
80009622:	33 09       	mov	r9,48
80009624:	f2 0a 18 00 	cp.b	r10,r9
80009628:	c4 10       	breq	800096aa <_vfprintf_r+0x162a>
8000962a:	0c f9       	st.b	--r6,r9
8000962c:	c3 f8       	rjmp	800096aa <_vfprintf_r+0x162a>
8000962e:	fa ea 00 00 	ld.d	r10,sp[0]
80009632:	30 a8       	mov	r8,10
80009634:	30 09       	mov	r9,0
80009636:	e0 a0 1a 19 	rcall	8000ca68 <__avr32_umod64>
8000963a:	30 a8       	mov	r8,10
8000963c:	2d 0a       	sub	r10,-48
8000963e:	30 09       	mov	r9,0
80009640:	ac 8a       	st.b	r6[0x0],r10
80009642:	fa ea 00 00 	ld.d	r10,sp[0]
80009646:	e0 a0 18 df 	rcall	8000c804 <__avr32_udiv64>
8000964a:	16 99       	mov	r9,r11
8000964c:	14 98       	mov	r8,r10
8000964e:	fa e9 00 00 	st.d	sp[0],r8
80009652:	20 16       	sub	r6,1
80009654:	fa ea 00 00 	ld.d	r10,sp[0]
80009658:	58 9a       	cp.w	r10,9
8000965a:	5c 2b       	cpc	r11
8000965c:	fe 9b ff e9 	brhi	8000962e <_vfprintf_r+0x15ae>
80009660:	1b f8       	ld.ub	r8,sp[0x7]
80009662:	2d 08       	sub	r8,-48
80009664:	c2 08       	rjmp	800096a4 <_vfprintf_r+0x1624>
80009666:	04 96       	mov	r6,r2
80009668:	fa e8 00 00 	ld.d	r8,sp[0]
8000966c:	f5 d8 c0 04 	bfextu	r10,r8,0x0,0x4
80009670:	40 de       	lddsp	lr,sp[0x34]
80009672:	fc 0a 07 0a 	ld.ub	r10,lr[r10]
80009676:	0c fa       	st.b	--r6,r10
80009678:	f2 0b 16 04 	lsr	r11,r9,0x4
8000967c:	f0 0a 16 04 	lsr	r10,r8,0x4
80009680:	f5 e9 11 ca 	or	r10,r10,r9<<0x1c
80009684:	16 99       	mov	r9,r11
80009686:	14 98       	mov	r8,r10
80009688:	58 08       	cp.w	r8,0
8000968a:	5c 29       	cpc	r9
8000968c:	cf 01       	brne	8000966c <_vfprintf_r+0x15ec>
8000968e:	fa e9 00 00 	st.d	sp[0],r8
80009692:	c0 c8       	rjmp	800096aa <_vfprintf_r+0x162a>
80009694:	58 08       	cp.w	r8,0
80009696:	c0 91       	brne	800096a8 <_vfprintf_r+0x1628>
80009698:	ed b5 00 00 	bld	r5,0x0
8000969c:	c0 61       	brne	800096a8 <_vfprintf_r+0x1628>
8000969e:	fa c6 f9 79 	sub	r6,sp,-1671
800096a2:	33 08       	mov	r8,48
800096a4:	ac 88       	st.b	r6[0x0],r8
800096a6:	c0 28       	rjmp	800096aa <_vfprintf_r+0x162a>
800096a8:	04 96       	mov	r6,r2
800096aa:	0c 12       	sub	r2,r6
800096ac:	c1 c8       	rjmp	800096e4 <_vfprintf_r+0x1664>
800096ae:	50 a7       	stdsp	sp[0x28],r7
800096b0:	50 80       	stdsp	sp[0x20],r0
800096b2:	40 93       	lddsp	r3,sp[0x24]
800096b4:	0c 97       	mov	r7,r6
800096b6:	10 90       	mov	r0,r8
800096b8:	04 94       	mov	r4,r2
800096ba:	40 41       	lddsp	r1,sp[0x10]
800096bc:	58 08       	cp.w	r8,0
800096be:	e0 80 04 4f 	breq	80009f5c <_vfprintf_r+0x1edc>
800096c2:	fb 68 06 60 	st.b	sp[1632],r8
800096c6:	30 0c       	mov	r12,0
800096c8:	30 08       	mov	r8,0
800096ca:	30 12       	mov	r2,1
800096cc:	fb 68 06 bb 	st.b	sp[1723],r8
800096d0:	50 2c       	stdsp	sp[0x8],r12
800096d2:	fa c6 f9 a0 	sub	r6,sp,-1632
800096d6:	c0 78       	rjmp	800096e4 <_vfprintf_r+0x1664>
800096d8:	30 0b       	mov	r11,0
800096da:	50 2b       	stdsp	sp[0x8],r11
800096dc:	c0 48       	rjmp	800096e4 <_vfprintf_r+0x1664>
800096de:	40 22       	lddsp	r2,sp[0x8]
800096e0:	30 0a       	mov	r10,0
800096e2:	50 2a       	stdsp	sp[0x8],r10
800096e4:	40 29       	lddsp	r9,sp[0x8]
800096e6:	e4 09 0c 49 	max	r9,r2,r9
800096ea:	fb 38 06 bb 	ld.ub	r8,sp[1723]
800096ee:	50 39       	stdsp	sp[0xc],r9
800096f0:	0a 9e       	mov	lr,r5
800096f2:	30 09       	mov	r9,0
800096f4:	e2 1e 00 02 	andl	lr,0x2,COH
800096f8:	f2 08 18 00 	cp.b	r8,r9
800096fc:	fb f8 10 03 	ld.wne	r8,sp[0xc]
80009700:	f7 b8 01 ff 	subne	r8,-1
80009704:	fb f8 1a 03 	st.wne	sp[0xc],r8
80009708:	0a 9b       	mov	r11,r5
8000970a:	58 0e       	cp.w	lr,0
8000970c:	fb fc 10 03 	ld.wne	r12,sp[0xc]
80009710:	f7 bc 01 fe 	subne	r12,-2
80009714:	fb fc 1a 03 	st.wne	sp[0xc],r12
80009718:	e2 1b 00 84 	andl	r11,0x84,COH
8000971c:	50 fe       	stdsp	sp[0x3c],lr
8000971e:	50 9b       	stdsp	sp[0x24],r11
80009720:	c4 71       	brne	800097ae <_vfprintf_r+0x172e>
80009722:	40 8a       	lddsp	r10,sp[0x20]
80009724:	40 39       	lddsp	r9,sp[0xc]
80009726:	12 1a       	sub	r10,r9
80009728:	50 4a       	stdsp	sp[0x10],r10
8000972a:	58 0a       	cp.w	r10,0
8000972c:	e0 89 00 20 	brgt	8000976c <_vfprintf_r+0x16ec>
80009730:	c3 f8       	rjmp	800097ae <_vfprintf_r+0x172e>
80009732:	2f 09       	sub	r9,-16
80009734:	2f f8       	sub	r8,-1
80009736:	fe ce b7 4e 	sub	lr,pc,-18610
8000973a:	31 0c       	mov	r12,16
8000973c:	fb 49 06 90 	st.w	sp[1680],r9
80009740:	87 0e       	st.w	r3[0x0],lr
80009742:	87 1c       	st.w	r3[0x4],r12
80009744:	fb 48 06 8c 	st.w	sp[1676],r8
80009748:	58 78       	cp.w	r8,7
8000974a:	e0 89 00 04 	brgt	80009752 <_vfprintf_r+0x16d2>
8000974e:	2f 83       	sub	r3,-8
80009750:	c0 b8       	rjmp	80009766 <_vfprintf_r+0x16e6>
80009752:	fa ca f9 78 	sub	r10,sp,-1672
80009756:	02 9b       	mov	r11,r1
80009758:	08 9c       	mov	r12,r4
8000975a:	fe b0 f4 85 	rcall	80008064 <__sprint_r>
8000975e:	e0 81 04 10 	brne	80009f7e <_vfprintf_r+0x1efe>
80009762:	fa c3 f9 e0 	sub	r3,sp,-1568
80009766:	40 4b       	lddsp	r11,sp[0x10]
80009768:	21 0b       	sub	r11,16
8000976a:	50 4b       	stdsp	sp[0x10],r11
8000976c:	fa f9 06 90 	ld.w	r9,sp[1680]
80009770:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009774:	fe ca b7 8c 	sub	r10,pc,-18548
80009778:	40 4e       	lddsp	lr,sp[0x10]
8000977a:	59 0e       	cp.w	lr,16
8000977c:	fe 99 ff db 	brgt	80009732 <_vfprintf_r+0x16b2>
80009780:	1c 09       	add	r9,lr
80009782:	2f f8       	sub	r8,-1
80009784:	87 0a       	st.w	r3[0x0],r10
80009786:	fb 49 06 90 	st.w	sp[1680],r9
8000978a:	87 1e       	st.w	r3[0x4],lr
8000978c:	fb 48 06 8c 	st.w	sp[1676],r8
80009790:	58 78       	cp.w	r8,7
80009792:	e0 89 00 04 	brgt	8000979a <_vfprintf_r+0x171a>
80009796:	2f 83       	sub	r3,-8
80009798:	c0 b8       	rjmp	800097ae <_vfprintf_r+0x172e>
8000979a:	fa ca f9 78 	sub	r10,sp,-1672
8000979e:	02 9b       	mov	r11,r1
800097a0:	08 9c       	mov	r12,r4
800097a2:	fe b0 f4 61 	rcall	80008064 <__sprint_r>
800097a6:	e0 81 03 ec 	brne	80009f7e <_vfprintf_r+0x1efe>
800097aa:	fa c3 f9 e0 	sub	r3,sp,-1568
800097ae:	30 09       	mov	r9,0
800097b0:	fb 38 06 bb 	ld.ub	r8,sp[1723]
800097b4:	f2 08 18 00 	cp.b	r8,r9
800097b8:	c1 f0       	breq	800097f6 <_vfprintf_r+0x1776>
800097ba:	fa f8 06 90 	ld.w	r8,sp[1680]
800097be:	fa c9 f9 45 	sub	r9,sp,-1723
800097c2:	2f f8       	sub	r8,-1
800097c4:	87 09       	st.w	r3[0x0],r9
800097c6:	fb 48 06 90 	st.w	sp[1680],r8
800097ca:	30 19       	mov	r9,1
800097cc:	fa f8 06 8c 	ld.w	r8,sp[1676]
800097d0:	87 19       	st.w	r3[0x4],r9
800097d2:	2f f8       	sub	r8,-1
800097d4:	fb 48 06 8c 	st.w	sp[1676],r8
800097d8:	58 78       	cp.w	r8,7
800097da:	e0 89 00 04 	brgt	800097e2 <_vfprintf_r+0x1762>
800097de:	2f 83       	sub	r3,-8
800097e0:	c0 b8       	rjmp	800097f6 <_vfprintf_r+0x1776>
800097e2:	fa ca f9 78 	sub	r10,sp,-1672
800097e6:	02 9b       	mov	r11,r1
800097e8:	08 9c       	mov	r12,r4
800097ea:	fe b0 f4 3d 	rcall	80008064 <__sprint_r>
800097ee:	e0 81 03 c8 	brne	80009f7e <_vfprintf_r+0x1efe>
800097f2:	fa c3 f9 e0 	sub	r3,sp,-1568
800097f6:	40 fc       	lddsp	r12,sp[0x3c]
800097f8:	58 0c       	cp.w	r12,0
800097fa:	c1 f0       	breq	80009838 <_vfprintf_r+0x17b8>
800097fc:	fa f8 06 90 	ld.w	r8,sp[1680]
80009800:	fa c9 f9 48 	sub	r9,sp,-1720
80009804:	2f e8       	sub	r8,-2
80009806:	87 09       	st.w	r3[0x0],r9
80009808:	fb 48 06 90 	st.w	sp[1680],r8
8000980c:	30 29       	mov	r9,2
8000980e:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009812:	87 19       	st.w	r3[0x4],r9
80009814:	2f f8       	sub	r8,-1
80009816:	fb 48 06 8c 	st.w	sp[1676],r8
8000981a:	58 78       	cp.w	r8,7
8000981c:	e0 89 00 04 	brgt	80009824 <_vfprintf_r+0x17a4>
80009820:	2f 83       	sub	r3,-8
80009822:	c0 b8       	rjmp	80009838 <_vfprintf_r+0x17b8>
80009824:	fa ca f9 78 	sub	r10,sp,-1672
80009828:	02 9b       	mov	r11,r1
8000982a:	08 9c       	mov	r12,r4
8000982c:	fe b0 f4 1c 	rcall	80008064 <__sprint_r>
80009830:	e0 81 03 a7 	brne	80009f7e <_vfprintf_r+0x1efe>
80009834:	fa c3 f9 e0 	sub	r3,sp,-1568
80009838:	40 9b       	lddsp	r11,sp[0x24]
8000983a:	e0 4b 00 80 	cp.w	r11,128
8000983e:	c4 71       	brne	800098cc <_vfprintf_r+0x184c>
80009840:	40 8a       	lddsp	r10,sp[0x20]
80009842:	40 39       	lddsp	r9,sp[0xc]
80009844:	12 1a       	sub	r10,r9
80009846:	50 4a       	stdsp	sp[0x10],r10
80009848:	58 0a       	cp.w	r10,0
8000984a:	e0 89 00 20 	brgt	8000988a <_vfprintf_r+0x180a>
8000984e:	c3 f8       	rjmp	800098cc <_vfprintf_r+0x184c>
80009850:	2f 09       	sub	r9,-16
80009852:	2f f8       	sub	r8,-1
80009854:	fe ce b8 5c 	sub	lr,pc,-18340
80009858:	31 0c       	mov	r12,16
8000985a:	fb 49 06 90 	st.w	sp[1680],r9
8000985e:	87 0e       	st.w	r3[0x0],lr
80009860:	87 1c       	st.w	r3[0x4],r12
80009862:	fb 48 06 8c 	st.w	sp[1676],r8
80009866:	58 78       	cp.w	r8,7
80009868:	e0 89 00 04 	brgt	80009870 <_vfprintf_r+0x17f0>
8000986c:	2f 83       	sub	r3,-8
8000986e:	c0 b8       	rjmp	80009884 <_vfprintf_r+0x1804>
80009870:	fa ca f9 78 	sub	r10,sp,-1672
80009874:	02 9b       	mov	r11,r1
80009876:	08 9c       	mov	r12,r4
80009878:	fe b0 f3 f6 	rcall	80008064 <__sprint_r>
8000987c:	e0 81 03 81 	brne	80009f7e <_vfprintf_r+0x1efe>
80009880:	fa c3 f9 e0 	sub	r3,sp,-1568
80009884:	40 4b       	lddsp	r11,sp[0x10]
80009886:	21 0b       	sub	r11,16
80009888:	50 4b       	stdsp	sp[0x10],r11
8000988a:	fa f9 06 90 	ld.w	r9,sp[1680]
8000988e:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009892:	fe ca b8 9a 	sub	r10,pc,-18278
80009896:	40 4e       	lddsp	lr,sp[0x10]
80009898:	59 0e       	cp.w	lr,16
8000989a:	fe 99 ff db 	brgt	80009850 <_vfprintf_r+0x17d0>
8000989e:	1c 09       	add	r9,lr
800098a0:	2f f8       	sub	r8,-1
800098a2:	87 0a       	st.w	r3[0x0],r10
800098a4:	fb 49 06 90 	st.w	sp[1680],r9
800098a8:	87 1e       	st.w	r3[0x4],lr
800098aa:	fb 48 06 8c 	st.w	sp[1676],r8
800098ae:	58 78       	cp.w	r8,7
800098b0:	e0 89 00 04 	brgt	800098b8 <_vfprintf_r+0x1838>
800098b4:	2f 83       	sub	r3,-8
800098b6:	c0 b8       	rjmp	800098cc <_vfprintf_r+0x184c>
800098b8:	fa ca f9 78 	sub	r10,sp,-1672
800098bc:	02 9b       	mov	r11,r1
800098be:	08 9c       	mov	r12,r4
800098c0:	fe b0 f3 d2 	rcall	80008064 <__sprint_r>
800098c4:	e0 81 03 5d 	brne	80009f7e <_vfprintf_r+0x1efe>
800098c8:	fa c3 f9 e0 	sub	r3,sp,-1568
800098cc:	40 2c       	lddsp	r12,sp[0x8]
800098ce:	04 1c       	sub	r12,r2
800098d0:	50 2c       	stdsp	sp[0x8],r12
800098d2:	58 0c       	cp.w	r12,0
800098d4:	e0 89 00 20 	brgt	80009914 <_vfprintf_r+0x1894>
800098d8:	c3 f8       	rjmp	80009956 <_vfprintf_r+0x18d6>
800098da:	2f 09       	sub	r9,-16
800098dc:	2f f8       	sub	r8,-1
800098de:	fe cb b8 e6 	sub	r11,pc,-18202
800098e2:	31 0a       	mov	r10,16
800098e4:	fb 49 06 90 	st.w	sp[1680],r9
800098e8:	87 0b       	st.w	r3[0x0],r11
800098ea:	87 1a       	st.w	r3[0x4],r10
800098ec:	fb 48 06 8c 	st.w	sp[1676],r8
800098f0:	58 78       	cp.w	r8,7
800098f2:	e0 89 00 04 	brgt	800098fa <_vfprintf_r+0x187a>
800098f6:	2f 83       	sub	r3,-8
800098f8:	c0 b8       	rjmp	8000990e <_vfprintf_r+0x188e>
800098fa:	fa ca f9 78 	sub	r10,sp,-1672
800098fe:	02 9b       	mov	r11,r1
80009900:	08 9c       	mov	r12,r4
80009902:	fe b0 f3 b1 	rcall	80008064 <__sprint_r>
80009906:	e0 81 03 3c 	brne	80009f7e <_vfprintf_r+0x1efe>
8000990a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000990e:	40 29       	lddsp	r9,sp[0x8]
80009910:	21 09       	sub	r9,16
80009912:	50 29       	stdsp	sp[0x8],r9
80009914:	fa f9 06 90 	ld.w	r9,sp[1680]
80009918:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000991c:	fe ca b9 24 	sub	r10,pc,-18140
80009920:	40 2e       	lddsp	lr,sp[0x8]
80009922:	59 0e       	cp.w	lr,16
80009924:	fe 99 ff db 	brgt	800098da <_vfprintf_r+0x185a>
80009928:	1c 09       	add	r9,lr
8000992a:	2f f8       	sub	r8,-1
8000992c:	87 0a       	st.w	r3[0x0],r10
8000992e:	fb 49 06 90 	st.w	sp[1680],r9
80009932:	87 1e       	st.w	r3[0x4],lr
80009934:	fb 48 06 8c 	st.w	sp[1676],r8
80009938:	58 78       	cp.w	r8,7
8000993a:	e0 89 00 04 	brgt	80009942 <_vfprintf_r+0x18c2>
8000993e:	2f 83       	sub	r3,-8
80009940:	c0 b8       	rjmp	80009956 <_vfprintf_r+0x18d6>
80009942:	fa ca f9 78 	sub	r10,sp,-1672
80009946:	02 9b       	mov	r11,r1
80009948:	08 9c       	mov	r12,r4
8000994a:	fe b0 f3 8d 	rcall	80008064 <__sprint_r>
8000994e:	e0 81 03 18 	brne	80009f7e <_vfprintf_r+0x1efe>
80009952:	fa c3 f9 e0 	sub	r3,sp,-1568
80009956:	ed b5 00 08 	bld	r5,0x8
8000995a:	c0 b0       	breq	80009970 <_vfprintf_r+0x18f0>
8000995c:	fa f8 06 90 	ld.w	r8,sp[1680]
80009960:	87 12       	st.w	r3[0x4],r2
80009962:	87 06       	st.w	r3[0x0],r6
80009964:	f0 02 00 02 	add	r2,r8,r2
80009968:	fb 42 06 90 	st.w	sp[1680],r2
8000996c:	e0 8f 01 d4 	bral	80009d14 <_vfprintf_r+0x1c94>
80009970:	e0 40 00 65 	cp.w	r0,101
80009974:	e0 8a 01 d6 	brle	80009d20 <_vfprintf_r+0x1ca0>
80009978:	30 08       	mov	r8,0
8000997a:	30 09       	mov	r9,0
8000997c:	40 5b       	lddsp	r11,sp[0x14]
8000997e:	40 7a       	lddsp	r10,sp[0x1c]
80009980:	e0 a0 15 3b 	rcall	8000c3f6 <__avr32_f64_cmp_eq>
80009984:	c7 90       	breq	80009a76 <_vfprintf_r+0x19f6>
80009986:	fa f8 06 90 	ld.w	r8,sp[1680]
8000998a:	fe c9 b9 a6 	sub	r9,pc,-18010
8000998e:	2f f8       	sub	r8,-1
80009990:	87 09       	st.w	r3[0x0],r9
80009992:	fb 48 06 90 	st.w	sp[1680],r8
80009996:	30 19       	mov	r9,1
80009998:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000999c:	87 19       	st.w	r3[0x4],r9
8000999e:	2f f8       	sub	r8,-1
800099a0:	fb 48 06 8c 	st.w	sp[1676],r8
800099a4:	58 78       	cp.w	r8,7
800099a6:	e0 89 00 05 	brgt	800099b0 <_vfprintf_r+0x1930>
800099aa:	2f 83       	sub	r3,-8
800099ac:	c0 c8       	rjmp	800099c4 <_vfprintf_r+0x1944>
800099ae:	d7 03       	nop
800099b0:	fa ca f9 78 	sub	r10,sp,-1672
800099b4:	02 9b       	mov	r11,r1
800099b6:	08 9c       	mov	r12,r4
800099b8:	fe b0 f3 56 	rcall	80008064 <__sprint_r>
800099bc:	e0 81 02 e1 	brne	80009f7e <_vfprintf_r+0x1efe>
800099c0:	fa c3 f9 e0 	sub	r3,sp,-1568
800099c4:	fa f8 06 ac 	ld.w	r8,sp[1708]
800099c8:	40 6c       	lddsp	r12,sp[0x18]
800099ca:	18 38       	cp.w	r8,r12
800099cc:	c0 55       	brlt	800099d6 <_vfprintf_r+0x1956>
800099ce:	ed b5 00 00 	bld	r5,0x0
800099d2:	e0 81 02 6b 	brne	80009ea8 <_vfprintf_r+0x1e28>
800099d6:	fa f8 06 90 	ld.w	r8,sp[1680]
800099da:	2f f8       	sub	r8,-1
800099dc:	40 cb       	lddsp	r11,sp[0x30]
800099de:	fb 48 06 90 	st.w	sp[1680],r8
800099e2:	30 19       	mov	r9,1
800099e4:	fa f8 06 8c 	ld.w	r8,sp[1676]
800099e8:	87 0b       	st.w	r3[0x0],r11
800099ea:	2f f8       	sub	r8,-1
800099ec:	87 19       	st.w	r3[0x4],r9
800099ee:	fb 48 06 8c 	st.w	sp[1676],r8
800099f2:	58 78       	cp.w	r8,7
800099f4:	e0 89 00 04 	brgt	800099fc <_vfprintf_r+0x197c>
800099f8:	2f 83       	sub	r3,-8
800099fa:	c0 b8       	rjmp	80009a10 <_vfprintf_r+0x1990>
800099fc:	fa ca f9 78 	sub	r10,sp,-1672
80009a00:	02 9b       	mov	r11,r1
80009a02:	08 9c       	mov	r12,r4
80009a04:	fe b0 f3 30 	rcall	80008064 <__sprint_r>
80009a08:	e0 81 02 bb 	brne	80009f7e <_vfprintf_r+0x1efe>
80009a0c:	fa c3 f9 e0 	sub	r3,sp,-1568
80009a10:	40 66       	lddsp	r6,sp[0x18]
80009a12:	20 16       	sub	r6,1
80009a14:	58 06       	cp.w	r6,0
80009a16:	e0 89 00 1d 	brgt	80009a50 <_vfprintf_r+0x19d0>
80009a1a:	e0 8f 02 47 	bral	80009ea8 <_vfprintf_r+0x1e28>
80009a1e:	2f 09       	sub	r9,-16
80009a20:	2f f8       	sub	r8,-1
80009a22:	fb 49 06 90 	st.w	sp[1680],r9
80009a26:	87 02       	st.w	r3[0x0],r2
80009a28:	87 10       	st.w	r3[0x4],r0
80009a2a:	fb 48 06 8c 	st.w	sp[1676],r8
80009a2e:	58 78       	cp.w	r8,7
80009a30:	e0 89 00 04 	brgt	80009a38 <_vfprintf_r+0x19b8>
80009a34:	2f 83       	sub	r3,-8
80009a36:	c0 b8       	rjmp	80009a4c <_vfprintf_r+0x19cc>
80009a38:	fa ca f9 78 	sub	r10,sp,-1672
80009a3c:	02 9b       	mov	r11,r1
80009a3e:	08 9c       	mov	r12,r4
80009a40:	fe b0 f3 12 	rcall	80008064 <__sprint_r>
80009a44:	e0 81 02 9d 	brne	80009f7e <_vfprintf_r+0x1efe>
80009a48:	fa c3 f9 e0 	sub	r3,sp,-1568
80009a4c:	21 06       	sub	r6,16
80009a4e:	c0 48       	rjmp	80009a56 <_vfprintf_r+0x19d6>
80009a50:	fe c2 ba 58 	sub	r2,pc,-17832
80009a54:	31 00       	mov	r0,16
80009a56:	fa f9 06 90 	ld.w	r9,sp[1680]
80009a5a:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009a5e:	fe ca ba 66 	sub	r10,pc,-17818
80009a62:	59 06       	cp.w	r6,16
80009a64:	fe 99 ff dd 	brgt	80009a1e <_vfprintf_r+0x199e>
80009a68:	0c 09       	add	r9,r6
80009a6a:	87 0a       	st.w	r3[0x0],r10
80009a6c:	fb 49 06 90 	st.w	sp[1680],r9
80009a70:	2f f8       	sub	r8,-1
80009a72:	87 16       	st.w	r3[0x4],r6
80009a74:	c5 39       	rjmp	80009d1a <_vfprintf_r+0x1c9a>
80009a76:	fa fa 06 ac 	ld.w	r10,sp[1708]
80009a7a:	58 0a       	cp.w	r10,0
80009a7c:	e0 89 00 92 	brgt	80009ba0 <_vfprintf_r+0x1b20>
80009a80:	fa f8 06 90 	ld.w	r8,sp[1680]
80009a84:	fe c9 ba a0 	sub	r9,pc,-17760
80009a88:	2f f8       	sub	r8,-1
80009a8a:	87 09       	st.w	r3[0x0],r9
80009a8c:	fb 48 06 90 	st.w	sp[1680],r8
80009a90:	30 19       	mov	r9,1
80009a92:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009a96:	87 19       	st.w	r3[0x4],r9
80009a98:	2f f8       	sub	r8,-1
80009a9a:	fb 48 06 8c 	st.w	sp[1676],r8
80009a9e:	58 78       	cp.w	r8,7
80009aa0:	e0 89 00 04 	brgt	80009aa8 <_vfprintf_r+0x1a28>
80009aa4:	2f 83       	sub	r3,-8
80009aa6:	c0 b8       	rjmp	80009abc <_vfprintf_r+0x1a3c>
80009aa8:	fa ca f9 78 	sub	r10,sp,-1672
80009aac:	02 9b       	mov	r11,r1
80009aae:	08 9c       	mov	r12,r4
80009ab0:	fe b0 f2 da 	rcall	80008064 <__sprint_r>
80009ab4:	e0 81 02 65 	brne	80009f7e <_vfprintf_r+0x1efe>
80009ab8:	fa c3 f9 e0 	sub	r3,sp,-1568
80009abc:	fa f8 06 ac 	ld.w	r8,sp[1708]
80009ac0:	58 08       	cp.w	r8,0
80009ac2:	c0 81       	brne	80009ad2 <_vfprintf_r+0x1a52>
80009ac4:	40 6a       	lddsp	r10,sp[0x18]
80009ac6:	58 0a       	cp.w	r10,0
80009ac8:	c0 51       	brne	80009ad2 <_vfprintf_r+0x1a52>
80009aca:	ed b5 00 00 	bld	r5,0x0
80009ace:	e0 81 01 ed 	brne	80009ea8 <_vfprintf_r+0x1e28>
80009ad2:	40 c9       	lddsp	r9,sp[0x30]
80009ad4:	fa f8 06 90 	ld.w	r8,sp[1680]
80009ad8:	2f f8       	sub	r8,-1
80009ada:	87 09       	st.w	r3[0x0],r9
80009adc:	fb 48 06 90 	st.w	sp[1680],r8
80009ae0:	30 19       	mov	r9,1
80009ae2:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009ae6:	87 19       	st.w	r3[0x4],r9
80009ae8:	2f f8       	sub	r8,-1
80009aea:	fb 48 06 8c 	st.w	sp[1676],r8
80009aee:	58 78       	cp.w	r8,7
80009af0:	e0 89 00 04 	brgt	80009af8 <_vfprintf_r+0x1a78>
80009af4:	2f 83       	sub	r3,-8
80009af6:	c0 b8       	rjmp	80009b0c <_vfprintf_r+0x1a8c>
80009af8:	fa ca f9 78 	sub	r10,sp,-1672
80009afc:	02 9b       	mov	r11,r1
80009afe:	08 9c       	mov	r12,r4
80009b00:	fe b0 f2 b2 	rcall	80008064 <__sprint_r>
80009b04:	e0 81 02 3d 	brne	80009f7e <_vfprintf_r+0x1efe>
80009b08:	fa c3 f9 e0 	sub	r3,sp,-1568
80009b0c:	fa f2 06 ac 	ld.w	r2,sp[1708]
80009b10:	5c 32       	neg	r2
80009b12:	58 02       	cp.w	r2,0
80009b14:	e0 89 00 1d 	brgt	80009b4e <_vfprintf_r+0x1ace>
80009b18:	c3 d8       	rjmp	80009b92 <_vfprintf_r+0x1b12>
80009b1a:	2f 09       	sub	r9,-16
80009b1c:	2f f8       	sub	r8,-1
80009b1e:	31 0e       	mov	lr,16
80009b20:	fb 49 06 90 	st.w	sp[1680],r9
80009b24:	87 00       	st.w	r3[0x0],r0
80009b26:	87 1e       	st.w	r3[0x4],lr
80009b28:	fb 48 06 8c 	st.w	sp[1676],r8
80009b2c:	58 78       	cp.w	r8,7
80009b2e:	e0 89 00 04 	brgt	80009b36 <_vfprintf_r+0x1ab6>
80009b32:	2f 83       	sub	r3,-8
80009b34:	c0 b8       	rjmp	80009b4a <_vfprintf_r+0x1aca>
80009b36:	fa ca f9 78 	sub	r10,sp,-1672
80009b3a:	02 9b       	mov	r11,r1
80009b3c:	08 9c       	mov	r12,r4
80009b3e:	fe b0 f2 93 	rcall	80008064 <__sprint_r>
80009b42:	e0 81 02 1e 	brne	80009f7e <_vfprintf_r+0x1efe>
80009b46:	fa c3 f9 e0 	sub	r3,sp,-1568
80009b4a:	21 02       	sub	r2,16
80009b4c:	c0 38       	rjmp	80009b52 <_vfprintf_r+0x1ad2>
80009b4e:	fe c0 bb 56 	sub	r0,pc,-17578
80009b52:	fa f9 06 90 	ld.w	r9,sp[1680]
80009b56:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009b5a:	fe ca bb 62 	sub	r10,pc,-17566
80009b5e:	59 02       	cp.w	r2,16
80009b60:	fe 99 ff dd 	brgt	80009b1a <_vfprintf_r+0x1a9a>
80009b64:	04 09       	add	r9,r2
80009b66:	2f f8       	sub	r8,-1
80009b68:	87 0a       	st.w	r3[0x0],r10
80009b6a:	fb 49 06 90 	st.w	sp[1680],r9
80009b6e:	87 12       	st.w	r3[0x4],r2
80009b70:	fb 48 06 8c 	st.w	sp[1676],r8
80009b74:	58 78       	cp.w	r8,7
80009b76:	e0 89 00 04 	brgt	80009b7e <_vfprintf_r+0x1afe>
80009b7a:	2f 83       	sub	r3,-8
80009b7c:	c0 b8       	rjmp	80009b92 <_vfprintf_r+0x1b12>
80009b7e:	fa ca f9 78 	sub	r10,sp,-1672
80009b82:	02 9b       	mov	r11,r1
80009b84:	08 9c       	mov	r12,r4
80009b86:	fe b0 f2 6f 	rcall	80008064 <__sprint_r>
80009b8a:	e0 81 01 fa 	brne	80009f7e <_vfprintf_r+0x1efe>
80009b8e:	fa c3 f9 e0 	sub	r3,sp,-1568
80009b92:	40 6c       	lddsp	r12,sp[0x18]
80009b94:	fa f8 06 90 	ld.w	r8,sp[1680]
80009b98:	87 06       	st.w	r3[0x0],r6
80009b9a:	87 1c       	st.w	r3[0x4],r12
80009b9c:	18 08       	add	r8,r12
80009b9e:	cb 98       	rjmp	80009d10 <_vfprintf_r+0x1c90>
80009ba0:	fa f9 06 90 	ld.w	r9,sp[1680]
80009ba4:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009ba8:	40 6b       	lddsp	r11,sp[0x18]
80009baa:	16 3a       	cp.w	r10,r11
80009bac:	c6 f5       	brlt	80009c8a <_vfprintf_r+0x1c0a>
80009bae:	16 09       	add	r9,r11
80009bb0:	2f f8       	sub	r8,-1
80009bb2:	87 06       	st.w	r3[0x0],r6
80009bb4:	fb 49 06 90 	st.w	sp[1680],r9
80009bb8:	87 1b       	st.w	r3[0x4],r11
80009bba:	fb 48 06 8c 	st.w	sp[1676],r8
80009bbe:	58 78       	cp.w	r8,7
80009bc0:	e0 89 00 04 	brgt	80009bc8 <_vfprintf_r+0x1b48>
80009bc4:	2f 83       	sub	r3,-8
80009bc6:	c0 b8       	rjmp	80009bdc <_vfprintf_r+0x1b5c>
80009bc8:	fa ca f9 78 	sub	r10,sp,-1672
80009bcc:	02 9b       	mov	r11,r1
80009bce:	08 9c       	mov	r12,r4
80009bd0:	fe b0 f2 4a 	rcall	80008064 <__sprint_r>
80009bd4:	e0 81 01 d5 	brne	80009f7e <_vfprintf_r+0x1efe>
80009bd8:	fa c3 f9 e0 	sub	r3,sp,-1568
80009bdc:	fa f6 06 ac 	ld.w	r6,sp[1708]
80009be0:	40 6a       	lddsp	r10,sp[0x18]
80009be2:	14 16       	sub	r6,r10
80009be4:	58 06       	cp.w	r6,0
80009be6:	e0 89 00 1c 	brgt	80009c1e <_vfprintf_r+0x1b9e>
80009bea:	c3 d8       	rjmp	80009c64 <_vfprintf_r+0x1be4>
80009bec:	2f 09       	sub	r9,-16
80009bee:	2f f8       	sub	r8,-1
80009bf0:	fb 49 06 90 	st.w	sp[1680],r9
80009bf4:	87 02       	st.w	r3[0x0],r2
80009bf6:	87 10       	st.w	r3[0x4],r0
80009bf8:	fb 48 06 8c 	st.w	sp[1676],r8
80009bfc:	58 78       	cp.w	r8,7
80009bfe:	e0 89 00 04 	brgt	80009c06 <_vfprintf_r+0x1b86>
80009c02:	2f 83       	sub	r3,-8
80009c04:	c0 b8       	rjmp	80009c1a <_vfprintf_r+0x1b9a>
80009c06:	fa ca f9 78 	sub	r10,sp,-1672
80009c0a:	02 9b       	mov	r11,r1
80009c0c:	08 9c       	mov	r12,r4
80009c0e:	fe b0 f2 2b 	rcall	80008064 <__sprint_r>
80009c12:	e0 81 01 b6 	brne	80009f7e <_vfprintf_r+0x1efe>
80009c16:	fa c3 f9 e0 	sub	r3,sp,-1568
80009c1a:	21 06       	sub	r6,16
80009c1c:	c0 48       	rjmp	80009c24 <_vfprintf_r+0x1ba4>
80009c1e:	fe c2 bc 26 	sub	r2,pc,-17370
80009c22:	31 00       	mov	r0,16
80009c24:	fa f9 06 90 	ld.w	r9,sp[1680]
80009c28:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009c2c:	fe ca bc 34 	sub	r10,pc,-17356
80009c30:	59 06       	cp.w	r6,16
80009c32:	fe 99 ff dd 	brgt	80009bec <_vfprintf_r+0x1b6c>
80009c36:	0c 09       	add	r9,r6
80009c38:	2f f8       	sub	r8,-1
80009c3a:	87 0a       	st.w	r3[0x0],r10
80009c3c:	fb 49 06 90 	st.w	sp[1680],r9
80009c40:	87 16       	st.w	r3[0x4],r6
80009c42:	fb 48 06 8c 	st.w	sp[1676],r8
80009c46:	58 78       	cp.w	r8,7
80009c48:	e0 89 00 04 	brgt	80009c50 <_vfprintf_r+0x1bd0>
80009c4c:	2f 83       	sub	r3,-8
80009c4e:	c0 b8       	rjmp	80009c64 <_vfprintf_r+0x1be4>
80009c50:	fa ca f9 78 	sub	r10,sp,-1672
80009c54:	02 9b       	mov	r11,r1
80009c56:	08 9c       	mov	r12,r4
80009c58:	fe b0 f2 06 	rcall	80008064 <__sprint_r>
80009c5c:	e0 81 01 91 	brne	80009f7e <_vfprintf_r+0x1efe>
80009c60:	fa c3 f9 e0 	sub	r3,sp,-1568
80009c64:	ed b5 00 00 	bld	r5,0x0
80009c68:	e0 81 01 20 	brne	80009ea8 <_vfprintf_r+0x1e28>
80009c6c:	40 c9       	lddsp	r9,sp[0x30]
80009c6e:	fa f8 06 90 	ld.w	r8,sp[1680]
80009c72:	2f f8       	sub	r8,-1
80009c74:	87 09       	st.w	r3[0x0],r9
80009c76:	fb 48 06 90 	st.w	sp[1680],r8
80009c7a:	30 19       	mov	r9,1
80009c7c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009c80:	87 19       	st.w	r3[0x4],r9
80009c82:	2f f8       	sub	r8,-1
80009c84:	fb 48 06 8c 	st.w	sp[1676],r8
80009c88:	c0 29       	rjmp	80009e8c <_vfprintf_r+0x1e0c>
80009c8a:	14 09       	add	r9,r10
80009c8c:	2f f8       	sub	r8,-1
80009c8e:	fb 49 06 90 	st.w	sp[1680],r9
80009c92:	87 06       	st.w	r3[0x0],r6
80009c94:	87 1a       	st.w	r3[0x4],r10
80009c96:	fb 48 06 8c 	st.w	sp[1676],r8
80009c9a:	58 78       	cp.w	r8,7
80009c9c:	e0 89 00 04 	brgt	80009ca4 <_vfprintf_r+0x1c24>
80009ca0:	2f 83       	sub	r3,-8
80009ca2:	c0 b8       	rjmp	80009cb8 <_vfprintf_r+0x1c38>
80009ca4:	fa ca f9 78 	sub	r10,sp,-1672
80009ca8:	02 9b       	mov	r11,r1
80009caa:	08 9c       	mov	r12,r4
80009cac:	fe b0 f1 dc 	rcall	80008064 <__sprint_r>
80009cb0:	e0 81 01 67 	brne	80009f7e <_vfprintf_r+0x1efe>
80009cb4:	fa c3 f9 e0 	sub	r3,sp,-1568
80009cb8:	40 c8       	lddsp	r8,sp[0x30]
80009cba:	87 08       	st.w	r3[0x0],r8
80009cbc:	fa f8 06 90 	ld.w	r8,sp[1680]
80009cc0:	2f f8       	sub	r8,-1
80009cc2:	30 19       	mov	r9,1
80009cc4:	fb 48 06 90 	st.w	sp[1680],r8
80009cc8:	87 19       	st.w	r3[0x4],r9
80009cca:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009cce:	2f f8       	sub	r8,-1
80009cd0:	fb 48 06 8c 	st.w	sp[1676],r8
80009cd4:	fa f2 06 ac 	ld.w	r2,sp[1708]
80009cd8:	58 78       	cp.w	r8,7
80009cda:	e0 89 00 04 	brgt	80009ce2 <_vfprintf_r+0x1c62>
80009cde:	2f 83       	sub	r3,-8
80009ce0:	c0 b8       	rjmp	80009cf6 <_vfprintf_r+0x1c76>
80009ce2:	fa ca f9 78 	sub	r10,sp,-1672
80009ce6:	02 9b       	mov	r11,r1
80009ce8:	08 9c       	mov	r12,r4
80009cea:	fe b0 f1 bd 	rcall	80008064 <__sprint_r>
80009cee:	e0 81 01 48 	brne	80009f7e <_vfprintf_r+0x1efe>
80009cf2:	fa c3 f9 e0 	sub	r3,sp,-1568
80009cf6:	04 06       	add	r6,r2
80009cf8:	fa f8 06 ac 	ld.w	r8,sp[1708]
80009cfc:	87 06       	st.w	r3[0x0],r6
80009cfe:	fa f9 06 90 	ld.w	r9,sp[1680]
80009d02:	40 66       	lddsp	r6,sp[0x18]
80009d04:	40 6e       	lddsp	lr,sp[0x18]
80009d06:	10 16       	sub	r6,r8
80009d08:	f2 08 01 08 	sub	r8,r9,r8
80009d0c:	87 16       	st.w	r3[0x4],r6
80009d0e:	1c 08       	add	r8,lr
80009d10:	fb 48 06 90 	st.w	sp[1680],r8
80009d14:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009d18:	2f f8       	sub	r8,-1
80009d1a:	fb 48 06 8c 	st.w	sp[1676],r8
80009d1e:	cb 78       	rjmp	80009e8c <_vfprintf_r+0x1e0c>
80009d20:	40 6c       	lddsp	r12,sp[0x18]
80009d22:	58 1c       	cp.w	r12,1
80009d24:	e0 89 00 06 	brgt	80009d30 <_vfprintf_r+0x1cb0>
80009d28:	ed b5 00 00 	bld	r5,0x0
80009d2c:	e0 81 00 85 	brne	80009e36 <_vfprintf_r+0x1db6>
80009d30:	fa f8 06 90 	ld.w	r8,sp[1680]
80009d34:	2f f8       	sub	r8,-1
80009d36:	30 19       	mov	r9,1
80009d38:	fb 48 06 90 	st.w	sp[1680],r8
80009d3c:	87 06       	st.w	r3[0x0],r6
80009d3e:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009d42:	87 19       	st.w	r3[0x4],r9
80009d44:	2f f8       	sub	r8,-1
80009d46:	fb 48 06 8c 	st.w	sp[1676],r8
80009d4a:	58 78       	cp.w	r8,7
80009d4c:	e0 89 00 04 	brgt	80009d54 <_vfprintf_r+0x1cd4>
80009d50:	2f 83       	sub	r3,-8
80009d52:	c0 b8       	rjmp	80009d68 <_vfprintf_r+0x1ce8>
80009d54:	fa ca f9 78 	sub	r10,sp,-1672
80009d58:	02 9b       	mov	r11,r1
80009d5a:	08 9c       	mov	r12,r4
80009d5c:	fe b0 f1 84 	rcall	80008064 <__sprint_r>
80009d60:	e0 81 01 0f 	brne	80009f7e <_vfprintf_r+0x1efe>
80009d64:	fa c3 f9 e0 	sub	r3,sp,-1568
80009d68:	fa f8 06 90 	ld.w	r8,sp[1680]
80009d6c:	2f f8       	sub	r8,-1
80009d6e:	40 cb       	lddsp	r11,sp[0x30]
80009d70:	fb 48 06 90 	st.w	sp[1680],r8
80009d74:	30 19       	mov	r9,1
80009d76:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009d7a:	87 0b       	st.w	r3[0x0],r11
80009d7c:	2f f8       	sub	r8,-1
80009d7e:	87 19       	st.w	r3[0x4],r9
80009d80:	fb 48 06 8c 	st.w	sp[1676],r8
80009d84:	58 78       	cp.w	r8,7
80009d86:	e0 89 00 05 	brgt	80009d90 <_vfprintf_r+0x1d10>
80009d8a:	2f 83       	sub	r3,-8
80009d8c:	c0 c8       	rjmp	80009da4 <_vfprintf_r+0x1d24>
80009d8e:	d7 03       	nop
80009d90:	fa ca f9 78 	sub	r10,sp,-1672
80009d94:	02 9b       	mov	r11,r1
80009d96:	08 9c       	mov	r12,r4
80009d98:	fe b0 f1 66 	rcall	80008064 <__sprint_r>
80009d9c:	e0 81 00 f1 	brne	80009f7e <_vfprintf_r+0x1efe>
80009da0:	fa c3 f9 e0 	sub	r3,sp,-1568
80009da4:	30 08       	mov	r8,0
80009da6:	30 09       	mov	r9,0
80009da8:	40 5b       	lddsp	r11,sp[0x14]
80009daa:	40 7a       	lddsp	r10,sp[0x1c]
80009dac:	e0 a0 13 25 	rcall	8000c3f6 <__avr32_f64_cmp_eq>
80009db0:	40 68       	lddsp	r8,sp[0x18]
80009db2:	20 18       	sub	r8,1
80009db4:	58 0c       	cp.w	r12,0
80009db6:	c0 d1       	brne	80009dd0 <_vfprintf_r+0x1d50>
80009db8:	2f f6       	sub	r6,-1
80009dba:	87 18       	st.w	r3[0x4],r8
80009dbc:	87 06       	st.w	r3[0x0],r6
80009dbe:	fa f6 06 90 	ld.w	r6,sp[1680]
80009dc2:	10 06       	add	r6,r8
80009dc4:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009dc8:	fb 46 06 90 	st.w	sp[1680],r6
80009dcc:	2f f8       	sub	r8,-1
80009dce:	c3 18       	rjmp	80009e30 <_vfprintf_r+0x1db0>
80009dd0:	10 96       	mov	r6,r8
80009dd2:	58 08       	cp.w	r8,0
80009dd4:	e0 89 00 1c 	brgt	80009e0c <_vfprintf_r+0x1d8c>
80009dd8:	c4 b8       	rjmp	80009e6e <_vfprintf_r+0x1dee>
80009dda:	2f 09       	sub	r9,-16
80009ddc:	2f f8       	sub	r8,-1
80009dde:	fb 49 06 90 	st.w	sp[1680],r9
80009de2:	87 02       	st.w	r3[0x0],r2
80009de4:	87 10       	st.w	r3[0x4],r0
80009de6:	fb 48 06 8c 	st.w	sp[1676],r8
80009dea:	58 78       	cp.w	r8,7
80009dec:	e0 89 00 04 	brgt	80009df4 <_vfprintf_r+0x1d74>
80009df0:	2f 83       	sub	r3,-8
80009df2:	c0 b8       	rjmp	80009e08 <_vfprintf_r+0x1d88>
80009df4:	fa ca f9 78 	sub	r10,sp,-1672
80009df8:	02 9b       	mov	r11,r1
80009dfa:	08 9c       	mov	r12,r4
80009dfc:	fe b0 f1 34 	rcall	80008064 <__sprint_r>
80009e00:	e0 81 00 bf 	brne	80009f7e <_vfprintf_r+0x1efe>
80009e04:	fa c3 f9 e0 	sub	r3,sp,-1568
80009e08:	21 06       	sub	r6,16
80009e0a:	c0 48       	rjmp	80009e12 <_vfprintf_r+0x1d92>
80009e0c:	fe c2 be 14 	sub	r2,pc,-16876
80009e10:	31 00       	mov	r0,16
80009e12:	fa f9 06 90 	ld.w	r9,sp[1680]
80009e16:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009e1a:	fe ca be 22 	sub	r10,pc,-16862
80009e1e:	59 06       	cp.w	r6,16
80009e20:	fe 99 ff dd 	brgt	80009dda <_vfprintf_r+0x1d5a>
80009e24:	0c 09       	add	r9,r6
80009e26:	87 0a       	st.w	r3[0x0],r10
80009e28:	fb 49 06 90 	st.w	sp[1680],r9
80009e2c:	2f f8       	sub	r8,-1
80009e2e:	87 16       	st.w	r3[0x4],r6
80009e30:	fb 48 06 8c 	st.w	sp[1676],r8
80009e34:	c0 e8       	rjmp	80009e50 <_vfprintf_r+0x1dd0>
80009e36:	fa f8 06 90 	ld.w	r8,sp[1680]
80009e3a:	2f f8       	sub	r8,-1
80009e3c:	30 19       	mov	r9,1
80009e3e:	fb 48 06 90 	st.w	sp[1680],r8
80009e42:	87 06       	st.w	r3[0x0],r6
80009e44:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009e48:	87 19       	st.w	r3[0x4],r9
80009e4a:	2f f8       	sub	r8,-1
80009e4c:	fb 48 06 8c 	st.w	sp[1676],r8
80009e50:	58 78       	cp.w	r8,7
80009e52:	e0 89 00 04 	brgt	80009e5a <_vfprintf_r+0x1dda>
80009e56:	2f 83       	sub	r3,-8
80009e58:	c0 b8       	rjmp	80009e6e <_vfprintf_r+0x1dee>
80009e5a:	fa ca f9 78 	sub	r10,sp,-1672
80009e5e:	02 9b       	mov	r11,r1
80009e60:	08 9c       	mov	r12,r4
80009e62:	fe b0 f1 01 	rcall	80008064 <__sprint_r>
80009e66:	e0 81 00 8c 	brne	80009f7e <_vfprintf_r+0x1efe>
80009e6a:	fa c3 f9 e0 	sub	r3,sp,-1568
80009e6e:	40 ea       	lddsp	r10,sp[0x38]
80009e70:	fa f8 06 90 	ld.w	r8,sp[1680]
80009e74:	14 08       	add	r8,r10
80009e76:	fa c9 f9 64 	sub	r9,sp,-1692
80009e7a:	fb 48 06 90 	st.w	sp[1680],r8
80009e7e:	87 1a       	st.w	r3[0x4],r10
80009e80:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009e84:	87 09       	st.w	r3[0x0],r9
80009e86:	2f f8       	sub	r8,-1
80009e88:	fb 48 06 8c 	st.w	sp[1676],r8
80009e8c:	58 78       	cp.w	r8,7
80009e8e:	e0 89 00 04 	brgt	80009e96 <_vfprintf_r+0x1e16>
80009e92:	2f 83       	sub	r3,-8
80009e94:	c0 a8       	rjmp	80009ea8 <_vfprintf_r+0x1e28>
80009e96:	fa ca f9 78 	sub	r10,sp,-1672
80009e9a:	02 9b       	mov	r11,r1
80009e9c:	08 9c       	mov	r12,r4
80009e9e:	fe b0 f0 e3 	rcall	80008064 <__sprint_r>
80009ea2:	c6 e1       	brne	80009f7e <_vfprintf_r+0x1efe>
80009ea4:	fa c3 f9 e0 	sub	r3,sp,-1568
80009ea8:	e2 15 00 04 	andl	r5,0x4,COH
80009eac:	c3 f0       	breq	80009f2a <_vfprintf_r+0x1eaa>
80009eae:	40 86       	lddsp	r6,sp[0x20]
80009eb0:	40 39       	lddsp	r9,sp[0xc]
80009eb2:	12 16       	sub	r6,r9
80009eb4:	58 06       	cp.w	r6,0
80009eb6:	e0 89 00 1a 	brgt	80009eea <_vfprintf_r+0x1e6a>
80009eba:	c3 88       	rjmp	80009f2a <_vfprintf_r+0x1eaa>
80009ebc:	2f 09       	sub	r9,-16
80009ebe:	2f f8       	sub	r8,-1
80009ec0:	fb 49 06 90 	st.w	sp[1680],r9
80009ec4:	87 05       	st.w	r3[0x0],r5
80009ec6:	87 12       	st.w	r3[0x4],r2
80009ec8:	fb 48 06 8c 	st.w	sp[1676],r8
80009ecc:	58 78       	cp.w	r8,7
80009ece:	e0 89 00 04 	brgt	80009ed6 <_vfprintf_r+0x1e56>
80009ed2:	2f 83       	sub	r3,-8
80009ed4:	c0 98       	rjmp	80009ee6 <_vfprintf_r+0x1e66>
80009ed6:	00 9a       	mov	r10,r0
80009ed8:	02 9b       	mov	r11,r1
80009eda:	08 9c       	mov	r12,r4
80009edc:	fe b0 f0 c4 	rcall	80008064 <__sprint_r>
80009ee0:	c4 f1       	brne	80009f7e <_vfprintf_r+0x1efe>
80009ee2:	fa c3 f9 e0 	sub	r3,sp,-1568
80009ee6:	21 06       	sub	r6,16
80009ee8:	c0 68       	rjmp	80009ef4 <_vfprintf_r+0x1e74>
80009eea:	fe c5 bf 02 	sub	r5,pc,-16638
80009eee:	31 02       	mov	r2,16
80009ef0:	fa c0 f9 78 	sub	r0,sp,-1672
80009ef4:	fa f9 06 90 	ld.w	r9,sp[1680]
80009ef8:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009efc:	fe ca bf 14 	sub	r10,pc,-16620
80009f00:	59 06       	cp.w	r6,16
80009f02:	fe 99 ff dd 	brgt	80009ebc <_vfprintf_r+0x1e3c>
80009f06:	0c 09       	add	r9,r6
80009f08:	2f f8       	sub	r8,-1
80009f0a:	87 0a       	st.w	r3[0x0],r10
80009f0c:	87 16       	st.w	r3[0x4],r6
80009f0e:	fb 49 06 90 	st.w	sp[1680],r9
80009f12:	fb 48 06 8c 	st.w	sp[1676],r8
80009f16:	58 78       	cp.w	r8,7
80009f18:	e0 8a 00 09 	brle	80009f2a <_vfprintf_r+0x1eaa>
80009f1c:	fa ca f9 78 	sub	r10,sp,-1672
80009f20:	02 9b       	mov	r11,r1
80009f22:	08 9c       	mov	r12,r4
80009f24:	fe b0 f0 a0 	rcall	80008064 <__sprint_r>
80009f28:	c2 b1       	brne	80009f7e <_vfprintf_r+0x1efe>
80009f2a:	40 bc       	lddsp	r12,sp[0x2c]
80009f2c:	40 36       	lddsp	r6,sp[0xc]
80009f2e:	40 8e       	lddsp	lr,sp[0x20]
80009f30:	ec 0e 0c 48 	max	r8,r6,lr
80009f34:	10 0c       	add	r12,r8
80009f36:	50 bc       	stdsp	sp[0x2c],r12
80009f38:	fa f8 06 90 	ld.w	r8,sp[1680]
80009f3c:	58 08       	cp.w	r8,0
80009f3e:	c0 80       	breq	80009f4e <_vfprintf_r+0x1ece>
80009f40:	fa ca f9 78 	sub	r10,sp,-1672
80009f44:	02 9b       	mov	r11,r1
80009f46:	08 9c       	mov	r12,r4
80009f48:	fe b0 f0 8e 	rcall	80008064 <__sprint_r>
80009f4c:	c1 91       	brne	80009f7e <_vfprintf_r+0x1efe>
80009f4e:	30 0b       	mov	r11,0
80009f50:	fa c3 f9 e0 	sub	r3,sp,-1568
80009f54:	fb 4b 06 8c 	st.w	sp[1676],r11
80009f58:	fe 9f f1 22 	bral	8000819c <_vfprintf_r+0x11c>
80009f5c:	08 95       	mov	r5,r4
80009f5e:	fa f8 06 90 	ld.w	r8,sp[1680]
80009f62:	58 08       	cp.w	r8,0
80009f64:	c0 80       	breq	80009f74 <_vfprintf_r+0x1ef4>
80009f66:	08 9c       	mov	r12,r4
80009f68:	fa ca f9 78 	sub	r10,sp,-1672
80009f6c:	02 9b       	mov	r11,r1
80009f6e:	fe b0 f0 7b 	rcall	80008064 <__sprint_r>
80009f72:	c0 61       	brne	80009f7e <_vfprintf_r+0x1efe>
80009f74:	30 08       	mov	r8,0
80009f76:	fb 48 06 8c 	st.w	sp[1676],r8
80009f7a:	c0 28       	rjmp	80009f7e <_vfprintf_r+0x1efe>
80009f7c:	40 41       	lddsp	r1,sp[0x10]
80009f7e:	82 68       	ld.sh	r8,r1[0xc]
80009f80:	ed b8 00 06 	bld	r8,0x6
80009f84:	c0 31       	brne	80009f8a <_vfprintf_r+0x1f0a>
80009f86:	3f fa       	mov	r10,-1
80009f88:	50 ba       	stdsp	sp[0x2c],r10
80009f8a:	40 bc       	lddsp	r12,sp[0x2c]
80009f8c:	fe 3d f9 44 	sub	sp,-1724
80009f90:	d8 32       	popm	r0-r7,pc
80009f92:	d7 03       	nop

80009f94 <__swsetup_r>:
80009f94:	d4 21       	pushm	r4-r7,lr
80009f96:	e0 68 0a 3c 	mov	r8,2620
80009f9a:	18 96       	mov	r6,r12
80009f9c:	16 97       	mov	r7,r11
80009f9e:	70 0c       	ld.w	r12,r8[0x0]
80009fa0:	58 0c       	cp.w	r12,0
80009fa2:	c0 60       	breq	80009fae <__swsetup_r+0x1a>
80009fa4:	78 68       	ld.w	r8,r12[0x18]
80009fa6:	58 08       	cp.w	r8,0
80009fa8:	c0 31       	brne	80009fae <__swsetup_r+0x1a>
80009faa:	e0 a0 07 bf 	rcall	8000af28 <__sinit>
80009fae:	fe c8 be 96 	sub	r8,pc,-16746
80009fb2:	10 37       	cp.w	r7,r8
80009fb4:	c0 61       	brne	80009fc0 <__swsetup_r+0x2c>
80009fb6:	e0 68 0a 3c 	mov	r8,2620
80009fba:	70 08       	ld.w	r8,r8[0x0]
80009fbc:	70 07       	ld.w	r7,r8[0x0]
80009fbe:	c1 28       	rjmp	80009fe2 <__swsetup_r+0x4e>
80009fc0:	fe c8 be 88 	sub	r8,pc,-16760
80009fc4:	10 37       	cp.w	r7,r8
80009fc6:	c0 61       	brne	80009fd2 <__swsetup_r+0x3e>
80009fc8:	e0 68 0a 3c 	mov	r8,2620
80009fcc:	70 08       	ld.w	r8,r8[0x0]
80009fce:	70 17       	ld.w	r7,r8[0x4]
80009fd0:	c0 98       	rjmp	80009fe2 <__swsetup_r+0x4e>
80009fd2:	fe c8 be 7a 	sub	r8,pc,-16774
80009fd6:	10 37       	cp.w	r7,r8
80009fd8:	c0 51       	brne	80009fe2 <__swsetup_r+0x4e>
80009fda:	e0 68 0a 3c 	mov	r8,2620
80009fde:	70 08       	ld.w	r8,r8[0x0]
80009fe0:	70 27       	ld.w	r7,r8[0x8]
80009fe2:	8e 68       	ld.sh	r8,r7[0xc]
80009fe4:	ed b8 00 03 	bld	r8,0x3
80009fe8:	c1 e0       	breq	8000a024 <__swsetup_r+0x90>
80009fea:	ed b8 00 04 	bld	r8,0x4
80009fee:	c3 e1       	brne	8000a06a <__swsetup_r+0xd6>
80009ff0:	ed b8 00 02 	bld	r8,0x2
80009ff4:	c1 51       	brne	8000a01e <__swsetup_r+0x8a>
80009ff6:	6e db       	ld.w	r11,r7[0x34]
80009ff8:	58 0b       	cp.w	r11,0
80009ffa:	c0 a0       	breq	8000a00e <__swsetup_r+0x7a>
80009ffc:	ee c8 ff bc 	sub	r8,r7,-68
8000a000:	10 3b       	cp.w	r11,r8
8000a002:	c0 40       	breq	8000a00a <__swsetup_r+0x76>
8000a004:	0c 9c       	mov	r12,r6
8000a006:	e0 a0 08 2b 	rcall	8000b05c <_free_r>
8000a00a:	30 08       	mov	r8,0
8000a00c:	8f d8       	st.w	r7[0x34],r8
8000a00e:	8e 68       	ld.sh	r8,r7[0xc]
8000a010:	e0 18 ff db 	andl	r8,0xffdb
8000a014:	ae 68       	st.h	r7[0xc],r8
8000a016:	30 08       	mov	r8,0
8000a018:	8f 18       	st.w	r7[0x4],r8
8000a01a:	6e 48       	ld.w	r8,r7[0x10]
8000a01c:	8f 08       	st.w	r7[0x0],r8
8000a01e:	8e 68       	ld.sh	r8,r7[0xc]
8000a020:	a3 b8       	sbr	r8,0x3
8000a022:	ae 68       	st.h	r7[0xc],r8
8000a024:	6e 48       	ld.w	r8,r7[0x10]
8000a026:	58 08       	cp.w	r8,0
8000a028:	c0 b1       	brne	8000a03e <__swsetup_r+0xaa>
8000a02a:	8e 68       	ld.sh	r8,r7[0xc]
8000a02c:	e2 18 02 80 	andl	r8,0x280,COH
8000a030:	e0 48 02 00 	cp.w	r8,512
8000a034:	c0 50       	breq	8000a03e <__swsetup_r+0xaa>
8000a036:	0c 9c       	mov	r12,r6
8000a038:	0e 9b       	mov	r11,r7
8000a03a:	e0 a0 0a 4b 	rcall	8000b4d0 <__smakebuf_r>
8000a03e:	8e 69       	ld.sh	r9,r7[0xc]
8000a040:	f1 d9 c0 01 	bfextu	r8,r9,0x0,0x1
8000a044:	c0 70       	breq	8000a052 <__swsetup_r+0xbe>
8000a046:	30 08       	mov	r8,0
8000a048:	8f 28       	st.w	r7[0x8],r8
8000a04a:	6e 58       	ld.w	r8,r7[0x14]
8000a04c:	5c 38       	neg	r8
8000a04e:	8f 68       	st.w	r7[0x18],r8
8000a050:	c0 68       	rjmp	8000a05c <__swsetup_r+0xc8>
8000a052:	ed b9 00 01 	bld	r9,0x1
8000a056:	ef f8 10 05 	ld.wne	r8,r7[0x14]
8000a05a:	8f 28       	st.w	r7[0x8],r8
8000a05c:	6e 48       	ld.w	r8,r7[0x10]
8000a05e:	58 08       	cp.w	r8,0
8000a060:	c0 61       	brne	8000a06c <__swsetup_r+0xd8>
8000a062:	8e 68       	ld.sh	r8,r7[0xc]
8000a064:	ed b8 00 07 	bld	r8,0x7
8000a068:	c0 21       	brne	8000a06c <__swsetup_r+0xd8>
8000a06a:	dc 2a       	popm	r4-r7,pc,r12=-1
8000a06c:	d8 2a       	popm	r4-r7,pc,r12=0
8000a06e:	d7 03       	nop

8000a070 <quorem>:
8000a070:	d4 31       	pushm	r0-r7,lr
8000a072:	20 2d       	sub	sp,8
8000a074:	18 97       	mov	r7,r12
8000a076:	78 48       	ld.w	r8,r12[0x10]
8000a078:	76 46       	ld.w	r6,r11[0x10]
8000a07a:	0c 38       	cp.w	r8,r6
8000a07c:	c0 34       	brge	8000a082 <quorem+0x12>
8000a07e:	30 0c       	mov	r12,0
8000a080:	c8 58       	rjmp	8000a18a <quorem+0x11a>
8000a082:	ec c2 ff fc 	sub	r2,r6,-4
8000a086:	f6 c3 ff ec 	sub	r3,r11,-20
8000a08a:	f6 02 03 29 	ld.w	r9,r11[r2<<0x2]
8000a08e:	f8 02 03 2c 	ld.w	r12,r12[r2<<0x2]
8000a092:	2f f9       	sub	r9,-1
8000a094:	20 16       	sub	r6,1
8000a096:	f8 09 0d 08 	divu	r8,r12,r9
8000a09a:	f6 02 00 22 	add	r2,r11,r2<<0x2
8000a09e:	ee c4 ff ec 	sub	r4,r7,-20
8000a0a2:	10 95       	mov	r5,r8
8000a0a4:	58 08       	cp.w	r8,0
8000a0a6:	c4 10       	breq	8000a128 <quorem+0xb8>
8000a0a8:	30 09       	mov	r9,0
8000a0aa:	06 9a       	mov	r10,r3
8000a0ac:	08 98       	mov	r8,r4
8000a0ae:	12 91       	mov	r1,r9
8000a0b0:	50 0b       	stdsp	sp[0x0],r11
8000a0b2:	70 0e       	ld.w	lr,r8[0x0]
8000a0b4:	b1 8e       	lsr	lr,0x10
8000a0b6:	50 1e       	stdsp	sp[0x4],lr
8000a0b8:	15 0e       	ld.w	lr,r10++
8000a0ba:	fc 00 16 10 	lsr	r0,lr,0x10
8000a0be:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000a0c2:	ea 0e 03 41 	mac	r1,r5,lr
8000a0c6:	fd d1 c0 10 	bfextu	lr,r1,0x0,0x10
8000a0ca:	b1 81       	lsr	r1,0x10
8000a0cc:	40 1b       	lddsp	r11,sp[0x4]
8000a0ce:	ea 00 02 40 	mul	r0,r5,r0
8000a0d2:	e2 00 00 00 	add	r0,r1,r0
8000a0d6:	e3 d0 c0 10 	bfextu	r1,r0,0x0,0x10
8000a0da:	02 1b       	sub	r11,r1
8000a0dc:	50 1b       	stdsp	sp[0x4],r11
8000a0de:	70 0b       	ld.w	r11,r8[0x0]
8000a0e0:	e3 db c0 10 	bfextu	r1,r11,0x0,0x10
8000a0e4:	02 09       	add	r9,r1
8000a0e6:	f2 0e 01 0e 	sub	lr,r9,lr
8000a0ea:	b0 1e       	st.h	r8[0x2],lr
8000a0ec:	fc 09 14 10 	asr	r9,lr,0x10
8000a0f0:	40 1e       	lddsp	lr,sp[0x4]
8000a0f2:	fc 09 00 09 	add	r9,lr,r9
8000a0f6:	b0 09       	st.h	r8[0x0],r9
8000a0f8:	e0 01 16 10 	lsr	r1,r0,0x10
8000a0fc:	2f c8       	sub	r8,-4
8000a0fe:	b1 49       	asr	r9,0x10
8000a100:	04 3a       	cp.w	r10,r2
8000a102:	fe 98 ff d8 	brls	8000a0b2 <quorem+0x42>
8000a106:	40 0b       	lddsp	r11,sp[0x0]
8000a108:	58 0c       	cp.w	r12,0
8000a10a:	c0 f1       	brne	8000a128 <quorem+0xb8>
8000a10c:	ec c8 ff fb 	sub	r8,r6,-5
8000a110:	ee 08 00 28 	add	r8,r7,r8<<0x2
8000a114:	c0 28       	rjmp	8000a118 <quorem+0xa8>
8000a116:	20 16       	sub	r6,1
8000a118:	20 48       	sub	r8,4
8000a11a:	08 38       	cp.w	r8,r4
8000a11c:	e0 88 00 05 	brls	8000a126 <quorem+0xb6>
8000a120:	70 09       	ld.w	r9,r8[0x0]
8000a122:	58 09       	cp.w	r9,0
8000a124:	cf 90       	breq	8000a116 <quorem+0xa6>
8000a126:	8f 46       	st.w	r7[0x10],r6
8000a128:	0e 9c       	mov	r12,r7
8000a12a:	e0 a0 0a d2 	rcall	8000b6ce <__mcmp>
8000a12e:	c2 d5       	brlt	8000a188 <quorem+0x118>
8000a130:	2f f5       	sub	r5,-1
8000a132:	08 98       	mov	r8,r4
8000a134:	30 09       	mov	r9,0
8000a136:	07 0b       	ld.w	r11,r3++
8000a138:	f6 0a 16 10 	lsr	r10,r11,0x10
8000a13c:	70 0c       	ld.w	r12,r8[0x0]
8000a13e:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000a142:	f8 0e 16 10 	lsr	lr,r12,0x10
8000a146:	14 1e       	sub	lr,r10
8000a148:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000a14c:	16 1a       	sub	r10,r11
8000a14e:	12 0a       	add	r10,r9
8000a150:	b0 1a       	st.h	r8[0x2],r10
8000a152:	b1 4a       	asr	r10,0x10
8000a154:	fc 0a 00 09 	add	r9,lr,r10
8000a158:	b0 09       	st.h	r8[0x0],r9
8000a15a:	2f c8       	sub	r8,-4
8000a15c:	b1 49       	asr	r9,0x10
8000a15e:	04 33       	cp.w	r3,r2
8000a160:	fe 98 ff eb 	brls	8000a136 <quorem+0xc6>
8000a164:	ec c8 ff fb 	sub	r8,r6,-5
8000a168:	ee 08 03 29 	ld.w	r9,r7[r8<<0x2]
8000a16c:	58 09       	cp.w	r9,0
8000a16e:	c0 d1       	brne	8000a188 <quorem+0x118>
8000a170:	ee 08 00 28 	add	r8,r7,r8<<0x2
8000a174:	c0 28       	rjmp	8000a178 <quorem+0x108>
8000a176:	20 16       	sub	r6,1
8000a178:	20 48       	sub	r8,4
8000a17a:	08 38       	cp.w	r8,r4
8000a17c:	e0 88 00 05 	brls	8000a186 <quorem+0x116>
8000a180:	70 09       	ld.w	r9,r8[0x0]
8000a182:	58 09       	cp.w	r9,0
8000a184:	cf 90       	breq	8000a176 <quorem+0x106>
8000a186:	8f 46       	st.w	r7[0x10],r6
8000a188:	0a 9c       	mov	r12,r5
8000a18a:	2f ed       	sub	sp,-8
8000a18c:	d8 32       	popm	r0-r7,pc
8000a18e:	d7 03       	nop

8000a190 <_dtoa_r>:
8000a190:	d4 31       	pushm	r0-r7,lr
8000a192:	21 ad       	sub	sp,104
8000a194:	fa c4 ff 74 	sub	r4,sp,-140
8000a198:	18 97       	mov	r7,r12
8000a19a:	16 95       	mov	r5,r11
8000a19c:	68 2c       	ld.w	r12,r4[0x8]
8000a19e:	50 c9       	stdsp	sp[0x30],r9
8000a1a0:	68 16       	ld.w	r6,r4[0x4]
8000a1a2:	68 09       	ld.w	r9,r4[0x0]
8000a1a4:	50 e8       	stdsp	sp[0x38],r8
8000a1a6:	14 94       	mov	r4,r10
8000a1a8:	51 2c       	stdsp	sp[0x48],r12
8000a1aa:	fa e5 00 08 	st.d	sp[8],r4
8000a1ae:	51 59       	stdsp	sp[0x54],r9
8000a1b0:	6e 95       	ld.w	r5,r7[0x24]
8000a1b2:	58 05       	cp.w	r5,0
8000a1b4:	c0 91       	brne	8000a1c6 <_dtoa_r+0x36>
8000a1b6:	31 0c       	mov	r12,16
8000a1b8:	fe b0 e8 f4 	rcall	800073a0 <malloc>
8000a1bc:	99 35       	st.w	r12[0xc],r5
8000a1be:	8f 9c       	st.w	r7[0x24],r12
8000a1c0:	99 15       	st.w	r12[0x4],r5
8000a1c2:	99 25       	st.w	r12[0x8],r5
8000a1c4:	99 05       	st.w	r12[0x0],r5
8000a1c6:	6e 99       	ld.w	r9,r7[0x24]
8000a1c8:	72 08       	ld.w	r8,r9[0x0]
8000a1ca:	58 08       	cp.w	r8,0
8000a1cc:	c0 f0       	breq	8000a1ea <_dtoa_r+0x5a>
8000a1ce:	72 1a       	ld.w	r10,r9[0x4]
8000a1d0:	91 1a       	st.w	r8[0x4],r10
8000a1d2:	30 1a       	mov	r10,1
8000a1d4:	72 19       	ld.w	r9,r9[0x4]
8000a1d6:	f4 09 09 49 	lsl	r9,r10,r9
8000a1da:	10 9b       	mov	r11,r8
8000a1dc:	91 29       	st.w	r8[0x8],r9
8000a1de:	0e 9c       	mov	r12,r7
8000a1e0:	e0 a0 0a 90 	rcall	8000b700 <_Bfree>
8000a1e4:	6e 98       	ld.w	r8,r7[0x24]
8000a1e6:	30 09       	mov	r9,0
8000a1e8:	91 09       	st.w	r8[0x0],r9
8000a1ea:	40 28       	lddsp	r8,sp[0x8]
8000a1ec:	10 94       	mov	r4,r8
8000a1ee:	58 08       	cp.w	r8,0
8000a1f0:	c0 64       	brge	8000a1fc <_dtoa_r+0x6c>
8000a1f2:	f1 d8 c0 1f 	bfextu	r8,r8,0x0,0x1f
8000a1f6:	50 28       	stdsp	sp[0x8],r8
8000a1f8:	30 18       	mov	r8,1
8000a1fa:	c0 28       	rjmp	8000a1fe <_dtoa_r+0x6e>
8000a1fc:	30 08       	mov	r8,0
8000a1fe:	8d 08       	st.w	r6[0x0],r8
8000a200:	fc 1c 7f f0 	movh	r12,0x7ff0
8000a204:	40 26       	lddsp	r6,sp[0x8]
8000a206:	0c 98       	mov	r8,r6
8000a208:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000a20c:	18 38       	cp.w	r8,r12
8000a20e:	c2 01       	brne	8000a24e <_dtoa_r+0xbe>
8000a210:	e0 68 27 0f 	mov	r8,9999
8000a214:	41 5b       	lddsp	r11,sp[0x54]
8000a216:	97 08       	st.w	r11[0x0],r8
8000a218:	40 3a       	lddsp	r10,sp[0xc]
8000a21a:	58 0a       	cp.w	r10,0
8000a21c:	c0 71       	brne	8000a22a <_dtoa_r+0x9a>
8000a21e:	ed d6 c0 14 	bfextu	r6,r6,0x0,0x14
8000a222:	c0 41       	brne	8000a22a <_dtoa_r+0x9a>
8000a224:	fe cc c1 1c 	sub	r12,pc,-16100
8000a228:	c0 38       	rjmp	8000a22e <_dtoa_r+0x9e>
8000a22a:	fe cc c1 16 	sub	r12,pc,-16106
8000a22e:	41 29       	lddsp	r9,sp[0x48]
8000a230:	58 09       	cp.w	r9,0
8000a232:	e0 80 05 9a 	breq	8000ad66 <_dtoa_r+0xbd6>
8000a236:	f8 c8 ff fd 	sub	r8,r12,-3
8000a23a:	f8 c9 ff f8 	sub	r9,r12,-8
8000a23e:	11 8b       	ld.ub	r11,r8[0x0]
8000a240:	30 0a       	mov	r10,0
8000a242:	41 25       	lddsp	r5,sp[0x48]
8000a244:	f4 0b 18 00 	cp.b	r11,r10
8000a248:	f2 08 17 10 	movne	r8,r9
8000a24c:	c1 68       	rjmp	8000a278 <_dtoa_r+0xe8>
8000a24e:	fa ea 00 08 	ld.d	r10,sp[8]
8000a252:	30 08       	mov	r8,0
8000a254:	fa eb 00 3c 	st.d	sp[60],r10
8000a258:	30 09       	mov	r9,0
8000a25a:	e0 a0 10 ce 	rcall	8000c3f6 <__avr32_f64_cmp_eq>
8000a25e:	c1 00       	breq	8000a27e <_dtoa_r+0xee>
8000a260:	30 18       	mov	r8,1
8000a262:	41 5a       	lddsp	r10,sp[0x54]
8000a264:	95 08       	st.w	r10[0x0],r8
8000a266:	fe cc c2 82 	sub	r12,pc,-15742
8000a26a:	41 29       	lddsp	r9,sp[0x48]
8000a26c:	f8 08 00 08 	add	r8,r12,r8
8000a270:	58 09       	cp.w	r9,0
8000a272:	e0 80 05 7a 	breq	8000ad66 <_dtoa_r+0xbd6>
8000a276:	12 95       	mov	r5,r9
8000a278:	8b 08       	st.w	r5[0x0],r8
8000a27a:	e0 8f 05 76 	bral	8000ad66 <_dtoa_r+0xbd6>
8000a27e:	fa c8 ff 9c 	sub	r8,sp,-100
8000a282:	fa c9 ff a0 	sub	r9,sp,-96
8000a286:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a28a:	0e 9c       	mov	r12,r7
8000a28c:	eb d6 c2 8b 	bfextu	r5,r6,0x14,0xb
8000a290:	e0 a0 0a 8a 	rcall	8000b7a4 <__d2b>
8000a294:	18 93       	mov	r3,r12
8000a296:	58 05       	cp.w	r5,0
8000a298:	c0 d0       	breq	8000a2b2 <_dtoa_r+0x122>
8000a29a:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a29e:	30 04       	mov	r4,0
8000a2a0:	f1 db c0 14 	bfextu	r8,r11,0x0,0x14
8000a2a4:	ea c5 03 ff 	sub	r5,r5,1023
8000a2a8:	10 9b       	mov	r11,r8
8000a2aa:	51 74       	stdsp	sp[0x5c],r4
8000a2ac:	ea 1b 3f f0 	orh	r11,0x3ff0
8000a2b0:	c2 58       	rjmp	8000a2fa <_dtoa_r+0x16a>
8000a2b2:	41 88       	lddsp	r8,sp[0x60]
8000a2b4:	41 9c       	lddsp	r12,sp[0x64]
8000a2b6:	10 0c       	add	r12,r8
8000a2b8:	f8 c5 fb ce 	sub	r5,r12,-1074
8000a2bc:	e0 45 00 20 	cp.w	r5,32
8000a2c0:	e0 8a 00 0e 	brle	8000a2dc <_dtoa_r+0x14c>
8000a2c4:	f8 cc fb ee 	sub	r12,r12,-1042
8000a2c8:	40 3b       	lddsp	r11,sp[0xc]
8000a2ca:	ea 08 11 40 	rsub	r8,r5,64
8000a2ce:	f6 0c 0a 4c 	lsr	r12,r11,r12
8000a2d2:	ec 08 09 46 	lsl	r6,r6,r8
8000a2d6:	0c 4c       	or	r12,r6
8000a2d8:	c0 78       	rjmp	8000a2e6 <_dtoa_r+0x156>
8000a2da:	d7 03       	nop
8000a2dc:	ea 0c 11 20 	rsub	r12,r5,32
8000a2e0:	40 3a       	lddsp	r10,sp[0xc]
8000a2e2:	f4 0c 09 4c 	lsl	r12,r10,r12
8000a2e6:	e0 a0 10 14 	rcall	8000c30e <__avr32_u32_to_f64>
8000a2ea:	fc 18 fe 10 	movh	r8,0xfe10
8000a2ee:	30 19       	mov	r9,1
8000a2f0:	ea c5 04 33 	sub	r5,r5,1075
8000a2f4:	f0 0b 00 0b 	add	r11,r8,r11
8000a2f8:	51 79       	stdsp	sp[0x5c],r9
8000a2fa:	30 08       	mov	r8,0
8000a2fc:	fc 19 3f f8 	movh	r9,0x3ff8
8000a300:	e0 a0 0e 9c 	rcall	8000c038 <__avr32_f64_sub>
8000a304:	e0 68 43 61 	mov	r8,17249
8000a308:	ea 18 63 6f 	orh	r8,0x636f
8000a30c:	e0 69 87 a7 	mov	r9,34727
8000a310:	ea 19 3f d2 	orh	r9,0x3fd2
8000a314:	e0 a0 0d a6 	rcall	8000be60 <__avr32_f64_mul>
8000a318:	e0 68 c8 b3 	mov	r8,51379
8000a31c:	ea 18 8b 60 	orh	r8,0x8b60
8000a320:	e0 69 8a 28 	mov	r9,35368
8000a324:	ea 19 3f c6 	orh	r9,0x3fc6
8000a328:	e0 a0 0f 56 	rcall	8000c1d4 <__avr32_f64_add>
8000a32c:	0a 9c       	mov	r12,r5
8000a32e:	14 90       	mov	r0,r10
8000a330:	16 91       	mov	r1,r11
8000a332:	e0 a0 0f f2 	rcall	8000c316 <__avr32_s32_to_f64>
8000a336:	e0 68 79 fb 	mov	r8,31227
8000a33a:	ea 18 50 9f 	orh	r8,0x509f
8000a33e:	e0 69 44 13 	mov	r9,17427
8000a342:	ea 19 3f d3 	orh	r9,0x3fd3
8000a346:	e0 a0 0d 8d 	rcall	8000be60 <__avr32_f64_mul>
8000a34a:	14 98       	mov	r8,r10
8000a34c:	16 99       	mov	r9,r11
8000a34e:	00 9a       	mov	r10,r0
8000a350:	02 9b       	mov	r11,r1
8000a352:	e0 a0 0f 41 	rcall	8000c1d4 <__avr32_f64_add>
8000a356:	14 90       	mov	r0,r10
8000a358:	16 91       	mov	r1,r11
8000a35a:	e0 a0 0f c7 	rcall	8000c2e8 <__avr32_f64_to_s32>
8000a35e:	30 08       	mov	r8,0
8000a360:	18 96       	mov	r6,r12
8000a362:	30 09       	mov	r9,0
8000a364:	00 9a       	mov	r10,r0
8000a366:	02 9b       	mov	r11,r1
8000a368:	e0 a0 10 8e 	rcall	8000c484 <__avr32_f64_cmp_lt>
8000a36c:	c0 c0       	breq	8000a384 <_dtoa_r+0x1f4>
8000a36e:	0c 9c       	mov	r12,r6
8000a370:	e0 a0 0f d3 	rcall	8000c316 <__avr32_s32_to_f64>
8000a374:	14 98       	mov	r8,r10
8000a376:	16 99       	mov	r9,r11
8000a378:	00 9a       	mov	r10,r0
8000a37a:	02 9b       	mov	r11,r1
8000a37c:	e0 a0 10 3d 	rcall	8000c3f6 <__avr32_f64_cmp_eq>
8000a380:	f7 b6 00 01 	subeq	r6,1
8000a384:	59 66       	cp.w	r6,22
8000a386:	e0 88 00 05 	brls	8000a390 <_dtoa_r+0x200>
8000a38a:	30 18       	mov	r8,1
8000a38c:	51 48       	stdsp	sp[0x50],r8
8000a38e:	c1 38       	rjmp	8000a3b4 <_dtoa_r+0x224>
8000a390:	fe c8 c1 c8 	sub	r8,pc,-15928
8000a394:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a398:	f0 06 02 38 	ld.d	r8,r8[r6<<0x3]
8000a39c:	e0 a0 10 74 	rcall	8000c484 <__avr32_f64_cmp_lt>
8000a3a0:	f9 b4 00 00 	moveq	r4,0
8000a3a4:	fb f4 0a 14 	st.weq	sp[0x50],r4
8000a3a8:	f7 b6 01 01 	subne	r6,1
8000a3ac:	f9 bc 01 00 	movne	r12,0
8000a3b0:	fb fc 1a 14 	st.wne	sp[0x50],r12
8000a3b4:	41 90       	lddsp	r0,sp[0x64]
8000a3b6:	20 10       	sub	r0,1
8000a3b8:	0a 10       	sub	r0,r5
8000a3ba:	c0 46       	brmi	8000a3c2 <_dtoa_r+0x232>
8000a3bc:	50 40       	stdsp	sp[0x10],r0
8000a3be:	30 00       	mov	r0,0
8000a3c0:	c0 48       	rjmp	8000a3c8 <_dtoa_r+0x238>
8000a3c2:	30 0b       	mov	r11,0
8000a3c4:	5c 30       	neg	r0
8000a3c6:	50 4b       	stdsp	sp[0x10],r11
8000a3c8:	ec 02 11 00 	rsub	r2,r6,0
8000a3cc:	58 06       	cp.w	r6,0
8000a3ce:	fb fa 40 04 	ld.wge	r10,sp[0x10]
8000a3d2:	f5 d6 e4 0a 	addge	r10,r10,r6
8000a3d6:	fb fa 4a 04 	st.wge	sp[0x10],r10
8000a3da:	fb f6 4a 11 	st.wge	sp[0x44],r6
8000a3de:	f9 b2 04 00 	movge	r2,0
8000a3e2:	e1 d6 e5 10 	sublt	r0,r0,r6
8000a3e6:	f9 b9 05 00 	movlt	r9,0
8000a3ea:	fb f9 5a 11 	st.wlt	sp[0x44],r9
8000a3ee:	40 c8       	lddsp	r8,sp[0x30]
8000a3f0:	58 98       	cp.w	r8,9
8000a3f2:	e0 8b 00 20 	brhi	8000a432 <_dtoa_r+0x2a2>
8000a3f6:	58 58       	cp.w	r8,5
8000a3f8:	f9 b4 0a 01 	movle	r4,1
8000a3fc:	fb f5 90 0c 	ld.wgt	r5,sp[0x30]
8000a400:	f7 b5 09 04 	subgt	r5,4
8000a404:	fb f5 9a 0c 	st.wgt	sp[0x30],r5
8000a408:	f9 b4 09 00 	movgt	r4,0
8000a40c:	40 cc       	lddsp	r12,sp[0x30]
8000a40e:	58 3c       	cp.w	r12,3
8000a410:	c2 d0       	breq	8000a46a <_dtoa_r+0x2da>
8000a412:	e0 89 00 05 	brgt	8000a41c <_dtoa_r+0x28c>
8000a416:	58 2c       	cp.w	r12,2
8000a418:	c1 01       	brne	8000a438 <_dtoa_r+0x2a8>
8000a41a:	c1 88       	rjmp	8000a44a <_dtoa_r+0x2ba>
8000a41c:	40 cb       	lddsp	r11,sp[0x30]
8000a41e:	58 4b       	cp.w	r11,4
8000a420:	c0 60       	breq	8000a42c <_dtoa_r+0x29c>
8000a422:	58 5b       	cp.w	r11,5
8000a424:	c0 a1       	brne	8000a438 <_dtoa_r+0x2a8>
8000a426:	30 1a       	mov	r10,1
8000a428:	50 da       	stdsp	sp[0x34],r10
8000a42a:	c2 28       	rjmp	8000a46e <_dtoa_r+0x2de>
8000a42c:	30 19       	mov	r9,1
8000a42e:	50 d9       	stdsp	sp[0x34],r9
8000a430:	c0 f8       	rjmp	8000a44e <_dtoa_r+0x2be>
8000a432:	30 08       	mov	r8,0
8000a434:	30 14       	mov	r4,1
8000a436:	50 c8       	stdsp	sp[0x30],r8
8000a438:	3f f5       	mov	r5,-1
8000a43a:	30 1c       	mov	r12,1
8000a43c:	30 0b       	mov	r11,0
8000a43e:	50 95       	stdsp	sp[0x24],r5
8000a440:	50 dc       	stdsp	sp[0x34],r12
8000a442:	0a 91       	mov	r1,r5
8000a444:	31 28       	mov	r8,18
8000a446:	50 eb       	stdsp	sp[0x38],r11
8000a448:	c2 08       	rjmp	8000a488 <_dtoa_r+0x2f8>
8000a44a:	30 0a       	mov	r10,0
8000a44c:	50 da       	stdsp	sp[0x34],r10
8000a44e:	40 e9       	lddsp	r9,sp[0x38]
8000a450:	58 09       	cp.w	r9,0
8000a452:	e0 89 00 07 	brgt	8000a460 <_dtoa_r+0x2d0>
8000a456:	30 18       	mov	r8,1
8000a458:	50 98       	stdsp	sp[0x24],r8
8000a45a:	10 91       	mov	r1,r8
8000a45c:	50 e8       	stdsp	sp[0x38],r8
8000a45e:	c1 58       	rjmp	8000a488 <_dtoa_r+0x2f8>
8000a460:	40 e5       	lddsp	r5,sp[0x38]
8000a462:	50 95       	stdsp	sp[0x24],r5
8000a464:	0a 91       	mov	r1,r5
8000a466:	0a 98       	mov	r8,r5
8000a468:	c1 08       	rjmp	8000a488 <_dtoa_r+0x2f8>
8000a46a:	30 0c       	mov	r12,0
8000a46c:	50 dc       	stdsp	sp[0x34],r12
8000a46e:	40 eb       	lddsp	r11,sp[0x38]
8000a470:	ec 0b 00 0b 	add	r11,r6,r11
8000a474:	50 9b       	stdsp	sp[0x24],r11
8000a476:	16 98       	mov	r8,r11
8000a478:	2f f8       	sub	r8,-1
8000a47a:	58 08       	cp.w	r8,0
8000a47c:	e0 89 00 05 	brgt	8000a486 <_dtoa_r+0x2f6>
8000a480:	10 91       	mov	r1,r8
8000a482:	30 18       	mov	r8,1
8000a484:	c0 28       	rjmp	8000a488 <_dtoa_r+0x2f8>
8000a486:	10 91       	mov	r1,r8
8000a488:	30 09       	mov	r9,0
8000a48a:	6e 9a       	ld.w	r10,r7[0x24]
8000a48c:	95 19       	st.w	r10[0x4],r9
8000a48e:	30 49       	mov	r9,4
8000a490:	c0 68       	rjmp	8000a49c <_dtoa_r+0x30c>
8000a492:	d7 03       	nop
8000a494:	6a 1a       	ld.w	r10,r5[0x4]
8000a496:	a1 79       	lsl	r9,0x1
8000a498:	2f fa       	sub	r10,-1
8000a49a:	8b 1a       	st.w	r5[0x4],r10
8000a49c:	6e 95       	ld.w	r5,r7[0x24]
8000a49e:	f2 ca ff ec 	sub	r10,r9,-20
8000a4a2:	10 3a       	cp.w	r10,r8
8000a4a4:	fe 98 ff f8 	brls	8000a494 <_dtoa_r+0x304>
8000a4a8:	6a 1b       	ld.w	r11,r5[0x4]
8000a4aa:	0e 9c       	mov	r12,r7
8000a4ac:	e0 a0 09 44 	rcall	8000b734 <_Balloc>
8000a4b0:	58 e1       	cp.w	r1,14
8000a4b2:	5f 88       	srls	r8
8000a4b4:	8b 0c       	st.w	r5[0x0],r12
8000a4b6:	f1 e4 00 04 	and	r4,r8,r4
8000a4ba:	6e 98       	ld.w	r8,r7[0x24]
8000a4bc:	70 08       	ld.w	r8,r8[0x0]
8000a4be:	50 88       	stdsp	sp[0x20],r8
8000a4c0:	e0 80 01 82 	breq	8000a7c4 <_dtoa_r+0x634>
8000a4c4:	58 06       	cp.w	r6,0
8000a4c6:	e0 8a 00 43 	brle	8000a54c <_dtoa_r+0x3bc>
8000a4ca:	f3 d6 c0 04 	bfextu	r9,r6,0x0,0x4
8000a4ce:	fe c8 c3 06 	sub	r8,pc,-15610
8000a4d2:	f0 09 02 34 	ld.d	r4,r8[r9<<0x3]
8000a4d6:	fa e5 00 18 	st.d	sp[24],r4
8000a4da:	ec 04 14 04 	asr	r4,r6,0x4
8000a4de:	ed b4 00 04 	bld	r4,0x4
8000a4e2:	c0 30       	breq	8000a4e8 <_dtoa_r+0x358>
8000a4e4:	30 25       	mov	r5,2
8000a4e6:	c1 08       	rjmp	8000a506 <_dtoa_r+0x376>
8000a4e8:	fe c8 c2 58 	sub	r8,pc,-15784
8000a4ec:	f0 e8 00 20 	ld.d	r8,r8[32]
8000a4f0:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a4f4:	e9 d4 c0 04 	bfextu	r4,r4,0x0,0x4
8000a4f8:	e0 a0 0f fa 	rcall	8000c4ec <__avr32_f64_div>
8000a4fc:	30 35       	mov	r5,3
8000a4fe:	14 98       	mov	r8,r10
8000a500:	16 99       	mov	r9,r11
8000a502:	fa e9 00 08 	st.d	sp[8],r8
8000a506:	fe cc c2 76 	sub	r12,pc,-15754
8000a50a:	50 a3       	stdsp	sp[0x28],r3
8000a50c:	0c 93       	mov	r3,r6
8000a50e:	18 96       	mov	r6,r12
8000a510:	c0 f8       	rjmp	8000a52e <_dtoa_r+0x39e>
8000a512:	fa ea 00 18 	ld.d	r10,sp[24]
8000a516:	ed b4 00 00 	bld	r4,0x0
8000a51a:	c0 81       	brne	8000a52a <_dtoa_r+0x39a>
8000a51c:	ec e8 00 00 	ld.d	r8,r6[0]
8000a520:	2f f5       	sub	r5,-1
8000a522:	e0 a0 0c 9f 	rcall	8000be60 <__avr32_f64_mul>
8000a526:	fa eb 00 18 	st.d	sp[24],r10
8000a52a:	a1 54       	asr	r4,0x1
8000a52c:	2f 86       	sub	r6,-8
8000a52e:	58 04       	cp.w	r4,0
8000a530:	cf 11       	brne	8000a512 <_dtoa_r+0x382>
8000a532:	fa e8 00 18 	ld.d	r8,sp[24]
8000a536:	fa ea 00 08 	ld.d	r10,sp[8]
8000a53a:	06 96       	mov	r6,r3
8000a53c:	e0 a0 0f d8 	rcall	8000c4ec <__avr32_f64_div>
8000a540:	40 a3       	lddsp	r3,sp[0x28]
8000a542:	14 98       	mov	r8,r10
8000a544:	16 99       	mov	r9,r11
8000a546:	fa e9 00 08 	st.d	sp[8],r8
8000a54a:	c2 f8       	rjmp	8000a5a8 <_dtoa_r+0x418>
8000a54c:	ec 08 11 00 	rsub	r8,r6,0
8000a550:	c0 31       	brne	8000a556 <_dtoa_r+0x3c6>
8000a552:	30 25       	mov	r5,2
8000a554:	c2 a8       	rjmp	8000a5a8 <_dtoa_r+0x418>
8000a556:	fe cc c2 c6 	sub	r12,pc,-15674
8000a55a:	f0 04 14 04 	asr	r4,r8,0x4
8000a55e:	50 1c       	stdsp	sp[0x4],r12
8000a560:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
8000a564:	fe c9 c3 9c 	sub	r9,pc,-15460
8000a568:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a56c:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000a570:	e0 a0 0c 78 	rcall	8000be60 <__avr32_f64_mul>
8000a574:	40 1c       	lddsp	r12,sp[0x4]
8000a576:	50 63       	stdsp	sp[0x18],r3
8000a578:	30 25       	mov	r5,2
8000a57a:	0c 93       	mov	r3,r6
8000a57c:	fa eb 00 08 	st.d	sp[8],r10
8000a580:	18 96       	mov	r6,r12
8000a582:	c0 f8       	rjmp	8000a5a0 <_dtoa_r+0x410>
8000a584:	fa ea 00 08 	ld.d	r10,sp[8]
8000a588:	ed b4 00 00 	bld	r4,0x0
8000a58c:	c0 81       	brne	8000a59c <_dtoa_r+0x40c>
8000a58e:	ec e8 00 00 	ld.d	r8,r6[0]
8000a592:	2f f5       	sub	r5,-1
8000a594:	e0 a0 0c 66 	rcall	8000be60 <__avr32_f64_mul>
8000a598:	fa eb 00 08 	st.d	sp[8],r10
8000a59c:	a1 54       	asr	r4,0x1
8000a59e:	2f 86       	sub	r6,-8
8000a5a0:	58 04       	cp.w	r4,0
8000a5a2:	cf 11       	brne	8000a584 <_dtoa_r+0x3f4>
8000a5a4:	06 96       	mov	r6,r3
8000a5a6:	40 63       	lddsp	r3,sp[0x18]
8000a5a8:	41 4a       	lddsp	r10,sp[0x50]
8000a5aa:	58 0a       	cp.w	r10,0
8000a5ac:	c2 a0       	breq	8000a600 <_dtoa_r+0x470>
8000a5ae:	fa e8 00 08 	ld.d	r8,sp[8]
8000a5b2:	58 01       	cp.w	r1,0
8000a5b4:	5f 94       	srgt	r4
8000a5b6:	fa e9 00 18 	st.d	sp[24],r8
8000a5ba:	30 08       	mov	r8,0
8000a5bc:	fc 19 3f f0 	movh	r9,0x3ff0
8000a5c0:	fa ea 00 18 	ld.d	r10,sp[24]
8000a5c4:	e0 a0 0f 60 	rcall	8000c484 <__avr32_f64_cmp_lt>
8000a5c8:	f9 bc 00 00 	moveq	r12,0
8000a5cc:	f9 bc 01 01 	movne	r12,1
8000a5d0:	e9 ec 00 0c 	and	r12,r4,r12
8000a5d4:	c1 60       	breq	8000a600 <_dtoa_r+0x470>
8000a5d6:	40 98       	lddsp	r8,sp[0x24]
8000a5d8:	58 08       	cp.w	r8,0
8000a5da:	e0 8a 00 f1 	brle	8000a7bc <_dtoa_r+0x62c>
8000a5de:	30 08       	mov	r8,0
8000a5e0:	fc 19 40 24 	movh	r9,0x4024
8000a5e4:	ec c4 00 01 	sub	r4,r6,1
8000a5e8:	fa ea 00 18 	ld.d	r10,sp[24]
8000a5ec:	2f f5       	sub	r5,-1
8000a5ee:	50 64       	stdsp	sp[0x18],r4
8000a5f0:	e0 a0 0c 38 	rcall	8000be60 <__avr32_f64_mul>
8000a5f4:	40 94       	lddsp	r4,sp[0x24]
8000a5f6:	14 98       	mov	r8,r10
8000a5f8:	16 99       	mov	r9,r11
8000a5fa:	fa e9 00 08 	st.d	sp[8],r8
8000a5fe:	c0 38       	rjmp	8000a604 <_dtoa_r+0x474>
8000a600:	50 66       	stdsp	sp[0x18],r6
8000a602:	02 94       	mov	r4,r1
8000a604:	0a 9c       	mov	r12,r5
8000a606:	e0 a0 0e 88 	rcall	8000c316 <__avr32_s32_to_f64>
8000a60a:	fa e8 00 08 	ld.d	r8,sp[8]
8000a60e:	e0 a0 0c 29 	rcall	8000be60 <__avr32_f64_mul>
8000a612:	30 08       	mov	r8,0
8000a614:	fc 19 40 1c 	movh	r9,0x401c
8000a618:	e0 a0 0d de 	rcall	8000c1d4 <__avr32_f64_add>
8000a61c:	14 98       	mov	r8,r10
8000a61e:	16 99       	mov	r9,r11
8000a620:	fa e9 00 28 	st.d	sp[40],r8
8000a624:	fc 18 fc c0 	movh	r8,0xfcc0
8000a628:	40 a5       	lddsp	r5,sp[0x28]
8000a62a:	10 05       	add	r5,r8
8000a62c:	50 a5       	stdsp	sp[0x28],r5
8000a62e:	58 04       	cp.w	r4,0
8000a630:	c2 11       	brne	8000a672 <_dtoa_r+0x4e2>
8000a632:	fa ea 00 08 	ld.d	r10,sp[8]
8000a636:	30 08       	mov	r8,0
8000a638:	fc 19 40 14 	movh	r9,0x4014
8000a63c:	e0 a0 0c fe 	rcall	8000c038 <__avr32_f64_sub>
8000a640:	40 bc       	lddsp	r12,sp[0x2c]
8000a642:	fa eb 00 08 	st.d	sp[8],r10
8000a646:	14 98       	mov	r8,r10
8000a648:	16 99       	mov	r9,r11
8000a64a:	18 9a       	mov	r10,r12
8000a64c:	0a 9b       	mov	r11,r5
8000a64e:	e0 a0 0f 1b 	rcall	8000c484 <__avr32_f64_cmp_lt>
8000a652:	e0 81 02 54 	brne	8000aafa <_dtoa_r+0x96a>
8000a656:	0a 98       	mov	r8,r5
8000a658:	40 b9       	lddsp	r9,sp[0x2c]
8000a65a:	ee 18 80 00 	eorh	r8,0x8000
8000a65e:	fa ea 00 08 	ld.d	r10,sp[8]
8000a662:	10 95       	mov	r5,r8
8000a664:	12 98       	mov	r8,r9
8000a666:	0a 99       	mov	r9,r5
8000a668:	e0 a0 0f 0e 	rcall	8000c484 <__avr32_f64_cmp_lt>
8000a66c:	e0 81 02 3e 	brne	8000aae8 <_dtoa_r+0x958>
8000a670:	ca 68       	rjmp	8000a7bc <_dtoa_r+0x62c>
8000a672:	fe c9 c4 aa 	sub	r9,pc,-15190
8000a676:	e8 c8 00 01 	sub	r8,r4,1
8000a67a:	40 d5       	lddsp	r5,sp[0x34]
8000a67c:	58 05       	cp.w	r5,0
8000a67e:	c4 f0       	breq	8000a71c <_dtoa_r+0x58c>
8000a680:	30 0c       	mov	r12,0
8000a682:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000a686:	51 3c       	stdsp	sp[0x4c],r12
8000a688:	30 0a       	mov	r10,0
8000a68a:	fc 1b 3f e0 	movh	r11,0x3fe0
8000a68e:	e0 a0 0f 2f 	rcall	8000c4ec <__avr32_f64_div>
8000a692:	fa e8 00 28 	ld.d	r8,sp[40]
8000a696:	40 85       	lddsp	r5,sp[0x20]
8000a698:	e0 a0 0c d0 	rcall	8000c038 <__avr32_f64_sub>
8000a69c:	fa eb 00 28 	st.d	sp[40],r10
8000a6a0:	fa ea 00 08 	ld.d	r10,sp[8]
8000a6a4:	e0 a0 0e 22 	rcall	8000c2e8 <__avr32_f64_to_s32>
8000a6a8:	51 6c       	stdsp	sp[0x58],r12
8000a6aa:	e0 a0 0e 36 	rcall	8000c316 <__avr32_s32_to_f64>
8000a6ae:	14 98       	mov	r8,r10
8000a6b0:	16 99       	mov	r9,r11
8000a6b2:	fa ea 00 08 	ld.d	r10,sp[8]
8000a6b6:	e0 a0 0c c1 	rcall	8000c038 <__avr32_f64_sub>
8000a6ba:	fa eb 00 08 	st.d	sp[8],r10
8000a6be:	41 68       	lddsp	r8,sp[0x58]
8000a6c0:	2d 08       	sub	r8,-48
8000a6c2:	0a c8       	st.b	r5++,r8
8000a6c4:	41 39       	lddsp	r9,sp[0x4c]
8000a6c6:	2f f9       	sub	r9,-1
8000a6c8:	51 39       	stdsp	sp[0x4c],r9
8000a6ca:	fa e8 00 28 	ld.d	r8,sp[40]
8000a6ce:	e0 a0 0e db 	rcall	8000c484 <__avr32_f64_cmp_lt>
8000a6d2:	e0 81 03 39 	brne	8000ad44 <_dtoa_r+0xbb4>
8000a6d6:	fa e8 00 08 	ld.d	r8,sp[8]
8000a6da:	30 0a       	mov	r10,0
8000a6dc:	fc 1b 3f f0 	movh	r11,0x3ff0
8000a6e0:	e0 a0 0c ac 	rcall	8000c038 <__avr32_f64_sub>
8000a6e4:	fa e8 00 28 	ld.d	r8,sp[40]
8000a6e8:	e0 a0 0e ce 	rcall	8000c484 <__avr32_f64_cmp_lt>
8000a6ec:	fa ea 00 28 	ld.d	r10,sp[40]
8000a6f0:	30 08       	mov	r8,0
8000a6f2:	fc 19 40 24 	movh	r9,0x4024
8000a6f6:	e0 81 00 da 	brne	8000a8aa <_dtoa_r+0x71a>
8000a6fa:	41 3c       	lddsp	r12,sp[0x4c]
8000a6fc:	08 3c       	cp.w	r12,r4
8000a6fe:	c5 f4       	brge	8000a7bc <_dtoa_r+0x62c>
8000a700:	e0 a0 0b b0 	rcall	8000be60 <__avr32_f64_mul>
8000a704:	30 08       	mov	r8,0
8000a706:	fa eb 00 28 	st.d	sp[40],r10
8000a70a:	fc 19 40 24 	movh	r9,0x4024
8000a70e:	fa ea 00 08 	ld.d	r10,sp[8]
8000a712:	e0 a0 0b a7 	rcall	8000be60 <__avr32_f64_mul>
8000a716:	fa eb 00 08 	st.d	sp[8],r10
8000a71a:	cc 3b       	rjmp	8000a6a0 <_dtoa_r+0x510>
8000a71c:	40 85       	lddsp	r5,sp[0x20]
8000a71e:	08 05       	add	r5,r4
8000a720:	f2 08 02 3a 	ld.d	r10,r9[r8<<0x3]
8000a724:	51 35       	stdsp	sp[0x4c],r5
8000a726:	fa e8 00 28 	ld.d	r8,sp[40]
8000a72a:	40 85       	lddsp	r5,sp[0x20]
8000a72c:	e0 a0 0b 9a 	rcall	8000be60 <__avr32_f64_mul>
8000a730:	fa eb 00 28 	st.d	sp[40],r10
8000a734:	fa ea 00 08 	ld.d	r10,sp[8]
8000a738:	e0 a0 0d d8 	rcall	8000c2e8 <__avr32_f64_to_s32>
8000a73c:	51 6c       	stdsp	sp[0x58],r12
8000a73e:	e0 a0 0d ec 	rcall	8000c316 <__avr32_s32_to_f64>
8000a742:	14 98       	mov	r8,r10
8000a744:	16 99       	mov	r9,r11
8000a746:	fa ea 00 08 	ld.d	r10,sp[8]
8000a74a:	e0 a0 0c 77 	rcall	8000c038 <__avr32_f64_sub>
8000a74e:	fa eb 00 08 	st.d	sp[8],r10
8000a752:	41 68       	lddsp	r8,sp[0x58]
8000a754:	2d 08       	sub	r8,-48
8000a756:	0a c8       	st.b	r5++,r8
8000a758:	41 3c       	lddsp	r12,sp[0x4c]
8000a75a:	18 35       	cp.w	r5,r12
8000a75c:	c2 81       	brne	8000a7ac <_dtoa_r+0x61c>
8000a75e:	30 08       	mov	r8,0
8000a760:	fc 19 3f e0 	movh	r9,0x3fe0
8000a764:	fa ea 00 28 	ld.d	r10,sp[40]
8000a768:	e0 a0 0d 36 	rcall	8000c1d4 <__avr32_f64_add>
8000a76c:	40 85       	lddsp	r5,sp[0x20]
8000a76e:	fa e8 00 08 	ld.d	r8,sp[8]
8000a772:	08 05       	add	r5,r4
8000a774:	e0 a0 0e 88 	rcall	8000c484 <__avr32_f64_cmp_lt>
8000a778:	e0 81 00 99 	brne	8000a8aa <_dtoa_r+0x71a>
8000a77c:	fa e8 00 28 	ld.d	r8,sp[40]
8000a780:	30 0a       	mov	r10,0
8000a782:	fc 1b 3f e0 	movh	r11,0x3fe0
8000a786:	e0 a0 0c 59 	rcall	8000c038 <__avr32_f64_sub>
8000a78a:	14 98       	mov	r8,r10
8000a78c:	16 99       	mov	r9,r11
8000a78e:	fa ea 00 08 	ld.d	r10,sp[8]
8000a792:	e0 a0 0e 79 	rcall	8000c484 <__avr32_f64_cmp_lt>
8000a796:	c1 30       	breq	8000a7bc <_dtoa_r+0x62c>
8000a798:	33 09       	mov	r9,48
8000a79a:	0a 98       	mov	r8,r5
8000a79c:	11 7a       	ld.ub	r10,--r8
8000a79e:	f2 0a 18 00 	cp.b	r10,r9
8000a7a2:	e0 81 02 d1 	brne	8000ad44 <_dtoa_r+0xbb4>
8000a7a6:	10 95       	mov	r5,r8
8000a7a8:	cf 9b       	rjmp	8000a79a <_dtoa_r+0x60a>
8000a7aa:	d7 03       	nop
8000a7ac:	30 08       	mov	r8,0
8000a7ae:	fc 19 40 24 	movh	r9,0x4024
8000a7b2:	e0 a0 0b 57 	rcall	8000be60 <__avr32_f64_mul>
8000a7b6:	fa eb 00 08 	st.d	sp[8],r10
8000a7ba:	cb db       	rjmp	8000a734 <_dtoa_r+0x5a4>
8000a7bc:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a7c0:	fa eb 00 08 	st.d	sp[8],r10
8000a7c4:	58 e6       	cp.w	r6,14
8000a7c6:	5f ab       	srle	r11
8000a7c8:	41 8a       	lddsp	r10,sp[0x60]
8000a7ca:	30 08       	mov	r8,0
8000a7cc:	f4 09 11 ff 	rsub	r9,r10,-1
8000a7d0:	f7 e9 03 f9 	and	r9,r11,r9>>0x1f
8000a7d4:	f0 09 18 00 	cp.b	r9,r8
8000a7d8:	e0 80 00 82 	breq	8000a8dc <_dtoa_r+0x74c>
8000a7dc:	40 ea       	lddsp	r10,sp[0x38]
8000a7de:	58 01       	cp.w	r1,0
8000a7e0:	5f a9       	srle	r9
8000a7e2:	f3 ea 03 f9 	and	r9,r9,r10>>0x1f
8000a7e6:	fe ca c6 1e 	sub	r10,pc,-14818
8000a7ea:	f4 06 02 34 	ld.d	r4,r10[r6<<0x3]
8000a7ee:	fa e5 00 10 	st.d	sp[16],r4
8000a7f2:	f0 09 18 00 	cp.b	r9,r8
8000a7f6:	c1 40       	breq	8000a81e <_dtoa_r+0x68e>
8000a7f8:	58 01       	cp.w	r1,0
8000a7fa:	e0 81 01 77 	brne	8000aae8 <_dtoa_r+0x958>
8000a7fe:	30 08       	mov	r8,0
8000a800:	fc 19 40 14 	movh	r9,0x4014
8000a804:	08 9a       	mov	r10,r4
8000a806:	0a 9b       	mov	r11,r5
8000a808:	e0 a0 0b 2c 	rcall	8000be60 <__avr32_f64_mul>
8000a80c:	fa e8 00 08 	ld.d	r8,sp[8]
8000a810:	e0 a0 0e 06 	rcall	8000c41c <__avr32_f64_cmp_ge>
8000a814:	e0 81 01 6a 	brne	8000aae8 <_dtoa_r+0x958>
8000a818:	02 92       	mov	r2,r1
8000a81a:	e0 8f 01 72 	bral	8000aafe <_dtoa_r+0x96e>
8000a81e:	40 85       	lddsp	r5,sp[0x20]
8000a820:	30 14       	mov	r4,1
8000a822:	fa e8 00 10 	ld.d	r8,sp[16]
8000a826:	fa ea 00 08 	ld.d	r10,sp[8]
8000a82a:	e0 a0 0e 61 	rcall	8000c4ec <__avr32_f64_div>
8000a82e:	e0 a0 0d 5d 	rcall	8000c2e8 <__avr32_f64_to_s32>
8000a832:	18 92       	mov	r2,r12
8000a834:	e0 a0 0d 71 	rcall	8000c316 <__avr32_s32_to_f64>
8000a838:	fa e8 00 10 	ld.d	r8,sp[16]
8000a83c:	e0 a0 0b 12 	rcall	8000be60 <__avr32_f64_mul>
8000a840:	14 98       	mov	r8,r10
8000a842:	16 99       	mov	r9,r11
8000a844:	fa ea 00 08 	ld.d	r10,sp[8]
8000a848:	e0 a0 0b f8 	rcall	8000c038 <__avr32_f64_sub>
8000a84c:	fa eb 00 08 	st.d	sp[8],r10
8000a850:	e4 c8 ff d0 	sub	r8,r2,-48
8000a854:	0a c8       	st.b	r5++,r8
8000a856:	fc 19 40 24 	movh	r9,0x4024
8000a85a:	30 08       	mov	r8,0
8000a85c:	02 34       	cp.w	r4,r1
8000a85e:	c3 31       	brne	8000a8c4 <_dtoa_r+0x734>
8000a860:	fa e8 00 08 	ld.d	r8,sp[8]
8000a864:	e0 a0 0c b8 	rcall	8000c1d4 <__avr32_f64_add>
8000a868:	16 91       	mov	r1,r11
8000a86a:	14 90       	mov	r0,r10
8000a86c:	14 98       	mov	r8,r10
8000a86e:	02 99       	mov	r9,r1
8000a870:	fa ea 00 10 	ld.d	r10,sp[16]
8000a874:	e0 a0 0e 08 	rcall	8000c484 <__avr32_f64_cmp_lt>
8000a878:	c1 a1       	brne	8000a8ac <_dtoa_r+0x71c>
8000a87a:	fa e8 00 10 	ld.d	r8,sp[16]
8000a87e:	00 9a       	mov	r10,r0
8000a880:	02 9b       	mov	r11,r1
8000a882:	e0 a0 0d ba 	rcall	8000c3f6 <__avr32_f64_cmp_eq>
8000a886:	e0 80 02 5e 	breq	8000ad42 <_dtoa_r+0xbb2>
8000a88a:	e5 d2 c0 01 	bfextu	r2,r2,0x0,0x1
8000a88e:	c0 f1       	brne	8000a8ac <_dtoa_r+0x71c>
8000a890:	e0 8f 02 59 	bral	8000ad42 <_dtoa_r+0xbb2>
8000a894:	40 8a       	lddsp	r10,sp[0x20]
8000a896:	14 38       	cp.w	r8,r10
8000a898:	c0 30       	breq	8000a89e <_dtoa_r+0x70e>
8000a89a:	10 95       	mov	r5,r8
8000a89c:	c0 98       	rjmp	8000a8ae <_dtoa_r+0x71e>
8000a89e:	33 08       	mov	r8,48
8000a8a0:	40 89       	lddsp	r9,sp[0x20]
8000a8a2:	2f f6       	sub	r6,-1
8000a8a4:	b2 88       	st.b	r9[0x0],r8
8000a8a6:	40 88       	lddsp	r8,sp[0x20]
8000a8a8:	c0 88       	rjmp	8000a8b8 <_dtoa_r+0x728>
8000a8aa:	40 66       	lddsp	r6,sp[0x18]
8000a8ac:	33 99       	mov	r9,57
8000a8ae:	0a 98       	mov	r8,r5
8000a8b0:	11 7a       	ld.ub	r10,--r8
8000a8b2:	f2 0a 18 00 	cp.b	r10,r9
8000a8b6:	ce f0       	breq	8000a894 <_dtoa_r+0x704>
8000a8b8:	50 66       	stdsp	sp[0x18],r6
8000a8ba:	11 89       	ld.ub	r9,r8[0x0]
8000a8bc:	2f f9       	sub	r9,-1
8000a8be:	b0 89       	st.b	r8[0x0],r9
8000a8c0:	e0 8f 02 42 	bral	8000ad44 <_dtoa_r+0xbb4>
8000a8c4:	e0 a0 0a ce 	rcall	8000be60 <__avr32_f64_mul>
8000a8c8:	2f f4       	sub	r4,-1
8000a8ca:	fa eb 00 08 	st.d	sp[8],r10
8000a8ce:	30 08       	mov	r8,0
8000a8d0:	30 09       	mov	r9,0
8000a8d2:	e0 a0 0d 92 	rcall	8000c3f6 <__avr32_f64_cmp_eq>
8000a8d6:	ca 60       	breq	8000a822 <_dtoa_r+0x692>
8000a8d8:	e0 8f 02 35 	bral	8000ad42 <_dtoa_r+0xbb2>
8000a8dc:	40 d8       	lddsp	r8,sp[0x34]
8000a8de:	58 08       	cp.w	r8,0
8000a8e0:	c0 51       	brne	8000a8ea <_dtoa_r+0x75a>
8000a8e2:	04 98       	mov	r8,r2
8000a8e4:	00 95       	mov	r5,r0
8000a8e6:	40 d4       	lddsp	r4,sp[0x34]
8000a8e8:	c3 78       	rjmp	8000a956 <_dtoa_r+0x7c6>
8000a8ea:	40 c5       	lddsp	r5,sp[0x30]
8000a8ec:	58 15       	cp.w	r5,1
8000a8ee:	e0 89 00 0f 	brgt	8000a90c <_dtoa_r+0x77c>
8000a8f2:	41 74       	lddsp	r4,sp[0x5c]
8000a8f4:	58 04       	cp.w	r4,0
8000a8f6:	c0 40       	breq	8000a8fe <_dtoa_r+0x76e>
8000a8f8:	f4 c9 fb cd 	sub	r9,r10,-1075
8000a8fc:	c0 48       	rjmp	8000a904 <_dtoa_r+0x774>
8000a8fe:	41 99       	lddsp	r9,sp[0x64]
8000a900:	f2 09 11 36 	rsub	r9,r9,54
8000a904:	04 98       	mov	r8,r2
8000a906:	00 95       	mov	r5,r0
8000a908:	c1 c8       	rjmp	8000a940 <_dtoa_r+0x7b0>
8000a90a:	d7 03       	nop
8000a90c:	e2 c8 00 01 	sub	r8,r1,1
8000a910:	58 01       	cp.w	r1,0
8000a912:	e0 05 17 40 	movge	r5,r0
8000a916:	e2 09 17 40 	movge	r9,r1
8000a91a:	e1 d1 e5 15 	sublt	r5,r0,r1
8000a91e:	f9 b9 05 00 	movlt	r9,0
8000a922:	10 32       	cp.w	r2,r8
8000a924:	e5 d8 e4 18 	subge	r8,r2,r8
8000a928:	f1 d2 e5 18 	sublt	r8,r8,r2
8000a92c:	e5 d8 e5 02 	addlt	r2,r2,r8
8000a930:	fb fc 50 11 	ld.wlt	r12,sp[0x44]
8000a934:	f9 d8 e5 0c 	addlt	r12,r12,r8
8000a938:	fb fc 5a 11 	st.wlt	sp[0x44],r12
8000a93c:	f9 b8 05 00 	movlt	r8,0
8000a940:	40 4b       	lddsp	r11,sp[0x10]
8000a942:	12 0b       	add	r11,r9
8000a944:	50 08       	stdsp	sp[0x0],r8
8000a946:	50 4b       	stdsp	sp[0x10],r11
8000a948:	12 00       	add	r0,r9
8000a94a:	30 1b       	mov	r11,1
8000a94c:	0e 9c       	mov	r12,r7
8000a94e:	e0 a0 08 a7 	rcall	8000ba9c <__i2b>
8000a952:	40 08       	lddsp	r8,sp[0x0]
8000a954:	18 94       	mov	r4,r12
8000a956:	40 4a       	lddsp	r10,sp[0x10]
8000a958:	58 05       	cp.w	r5,0
8000a95a:	5f 99       	srgt	r9
8000a95c:	58 0a       	cp.w	r10,0
8000a95e:	5f 9a       	srgt	r10
8000a960:	f5 e9 00 09 	and	r9,r10,r9
8000a964:	c0 80       	breq	8000a974 <_dtoa_r+0x7e4>
8000a966:	40 4c       	lddsp	r12,sp[0x10]
8000a968:	f8 05 0d 49 	min	r9,r12,r5
8000a96c:	12 1c       	sub	r12,r9
8000a96e:	12 10       	sub	r0,r9
8000a970:	50 4c       	stdsp	sp[0x10],r12
8000a972:	12 15       	sub	r5,r9
8000a974:	58 02       	cp.w	r2,0
8000a976:	e0 8a 00 27 	brle	8000a9c4 <_dtoa_r+0x834>
8000a97a:	40 db       	lddsp	r11,sp[0x34]
8000a97c:	58 0b       	cp.w	r11,0
8000a97e:	c1 d0       	breq	8000a9b8 <_dtoa_r+0x828>
8000a980:	58 08       	cp.w	r8,0
8000a982:	e0 8a 00 17 	brle	8000a9b0 <_dtoa_r+0x820>
8000a986:	10 9a       	mov	r10,r8
8000a988:	50 08       	stdsp	sp[0x0],r8
8000a98a:	08 9b       	mov	r11,r4
8000a98c:	0e 9c       	mov	r12,r7
8000a98e:	e0 a0 08 cd 	rcall	8000bb28 <__pow5mult>
8000a992:	06 9a       	mov	r10,r3
8000a994:	18 9b       	mov	r11,r12
8000a996:	18 94       	mov	r4,r12
8000a998:	0e 9c       	mov	r12,r7
8000a99a:	e0 a0 08 01 	rcall	8000b99c <__multiply>
8000a99e:	18 99       	mov	r9,r12
8000a9a0:	06 9b       	mov	r11,r3
8000a9a2:	50 19       	stdsp	sp[0x4],r9
8000a9a4:	0e 9c       	mov	r12,r7
8000a9a6:	e0 a0 06 ad 	rcall	8000b700 <_Bfree>
8000a9aa:	40 19       	lddsp	r9,sp[0x4]
8000a9ac:	40 08       	lddsp	r8,sp[0x0]
8000a9ae:	12 93       	mov	r3,r9
8000a9b0:	e4 08 01 0a 	sub	r10,r2,r8
8000a9b4:	c0 80       	breq	8000a9c4 <_dtoa_r+0x834>
8000a9b6:	c0 28       	rjmp	8000a9ba <_dtoa_r+0x82a>
8000a9b8:	04 9a       	mov	r10,r2
8000a9ba:	06 9b       	mov	r11,r3
8000a9bc:	0e 9c       	mov	r12,r7
8000a9be:	e0 a0 08 b5 	rcall	8000bb28 <__pow5mult>
8000a9c2:	18 93       	mov	r3,r12
8000a9c4:	30 1b       	mov	r11,1
8000a9c6:	0e 9c       	mov	r12,r7
8000a9c8:	e0 a0 08 6a 	rcall	8000ba9c <__i2b>
8000a9cc:	41 1a       	lddsp	r10,sp[0x44]
8000a9ce:	18 92       	mov	r2,r12
8000a9d0:	58 0a       	cp.w	r10,0
8000a9d2:	e0 8a 00 07 	brle	8000a9e0 <_dtoa_r+0x850>
8000a9d6:	18 9b       	mov	r11,r12
8000a9d8:	0e 9c       	mov	r12,r7
8000a9da:	e0 a0 08 a7 	rcall	8000bb28 <__pow5mult>
8000a9de:	18 92       	mov	r2,r12
8000a9e0:	40 c9       	lddsp	r9,sp[0x30]
8000a9e2:	58 19       	cp.w	r9,1
8000a9e4:	e0 89 00 14 	brgt	8000aa0c <_dtoa_r+0x87c>
8000a9e8:	40 38       	lddsp	r8,sp[0xc]
8000a9ea:	58 08       	cp.w	r8,0
8000a9ec:	c1 01       	brne	8000aa0c <_dtoa_r+0x87c>
8000a9ee:	40 29       	lddsp	r9,sp[0x8]
8000a9f0:	f1 d9 c0 14 	bfextu	r8,r9,0x0,0x14
8000a9f4:	c0 c1       	brne	8000aa0c <_dtoa_r+0x87c>
8000a9f6:	12 98       	mov	r8,r9
8000a9f8:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000a9fc:	c0 80       	breq	8000aa0c <_dtoa_r+0x87c>
8000a9fe:	40 4c       	lddsp	r12,sp[0x10]
8000aa00:	30 1b       	mov	r11,1
8000aa02:	2f fc       	sub	r12,-1
8000aa04:	2f f0       	sub	r0,-1
8000aa06:	50 4c       	stdsp	sp[0x10],r12
8000aa08:	50 6b       	stdsp	sp[0x18],r11
8000aa0a:	c0 38       	rjmp	8000aa10 <_dtoa_r+0x880>
8000aa0c:	30 0a       	mov	r10,0
8000aa0e:	50 6a       	stdsp	sp[0x18],r10
8000aa10:	41 19       	lddsp	r9,sp[0x44]
8000aa12:	58 09       	cp.w	r9,0
8000aa14:	c0 31       	brne	8000aa1a <_dtoa_r+0x88a>
8000aa16:	30 1c       	mov	r12,1
8000aa18:	c0 98       	rjmp	8000aa2a <_dtoa_r+0x89a>
8000aa1a:	64 48       	ld.w	r8,r2[0x10]
8000aa1c:	2f c8       	sub	r8,-4
8000aa1e:	e4 08 03 2c 	ld.w	r12,r2[r8<<0x2]
8000aa22:	e0 a0 05 df 	rcall	8000b5e0 <__hi0bits>
8000aa26:	f8 0c 11 20 	rsub	r12,r12,32
8000aa2a:	40 4b       	lddsp	r11,sp[0x10]
8000aa2c:	f8 0b 00 08 	add	r8,r12,r11
8000aa30:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000aa34:	c0 c0       	breq	8000aa4c <_dtoa_r+0x8bc>
8000aa36:	f0 08 11 20 	rsub	r8,r8,32
8000aa3a:	58 48       	cp.w	r8,4
8000aa3c:	e0 8a 00 06 	brle	8000aa48 <_dtoa_r+0x8b8>
8000aa40:	20 48       	sub	r8,4
8000aa42:	10 0b       	add	r11,r8
8000aa44:	50 4b       	stdsp	sp[0x10],r11
8000aa46:	c0 78       	rjmp	8000aa54 <_dtoa_r+0x8c4>
8000aa48:	58 48       	cp.w	r8,4
8000aa4a:	c0 70       	breq	8000aa58 <_dtoa_r+0x8c8>
8000aa4c:	40 4a       	lddsp	r10,sp[0x10]
8000aa4e:	2e 48       	sub	r8,-28
8000aa50:	10 0a       	add	r10,r8
8000aa52:	50 4a       	stdsp	sp[0x10],r10
8000aa54:	10 00       	add	r0,r8
8000aa56:	10 05       	add	r5,r8
8000aa58:	58 00       	cp.w	r0,0
8000aa5a:	e0 8a 00 08 	brle	8000aa6a <_dtoa_r+0x8da>
8000aa5e:	06 9b       	mov	r11,r3
8000aa60:	00 9a       	mov	r10,r0
8000aa62:	0e 9c       	mov	r12,r7
8000aa64:	e0 a0 07 58 	rcall	8000b914 <__lshift>
8000aa68:	18 93       	mov	r3,r12
8000aa6a:	40 49       	lddsp	r9,sp[0x10]
8000aa6c:	58 09       	cp.w	r9,0
8000aa6e:	e0 8a 00 08 	brle	8000aa7e <_dtoa_r+0x8ee>
8000aa72:	04 9b       	mov	r11,r2
8000aa74:	12 9a       	mov	r10,r9
8000aa76:	0e 9c       	mov	r12,r7
8000aa78:	e0 a0 07 4e 	rcall	8000b914 <__lshift>
8000aa7c:	18 92       	mov	r2,r12
8000aa7e:	41 48       	lddsp	r8,sp[0x50]
8000aa80:	58 08       	cp.w	r8,0
8000aa82:	c1 b0       	breq	8000aab8 <_dtoa_r+0x928>
8000aa84:	04 9b       	mov	r11,r2
8000aa86:	06 9c       	mov	r12,r3
8000aa88:	e0 a0 06 23 	rcall	8000b6ce <__mcmp>
8000aa8c:	c1 64       	brge	8000aab8 <_dtoa_r+0x928>
8000aa8e:	06 9b       	mov	r11,r3
8000aa90:	30 09       	mov	r9,0
8000aa92:	30 aa       	mov	r10,10
8000aa94:	0e 9c       	mov	r12,r7
8000aa96:	e0 a0 08 0b 	rcall	8000baac <__multadd>
8000aa9a:	20 16       	sub	r6,1
8000aa9c:	18 93       	mov	r3,r12
8000aa9e:	40 dc       	lddsp	r12,sp[0x34]
8000aaa0:	58 0c       	cp.w	r12,0
8000aaa2:	c0 31       	brne	8000aaa8 <_dtoa_r+0x918>
8000aaa4:	40 91       	lddsp	r1,sp[0x24]
8000aaa6:	c0 98       	rjmp	8000aab8 <_dtoa_r+0x928>
8000aaa8:	08 9b       	mov	r11,r4
8000aaaa:	40 91       	lddsp	r1,sp[0x24]
8000aaac:	30 09       	mov	r9,0
8000aaae:	30 aa       	mov	r10,10
8000aab0:	0e 9c       	mov	r12,r7
8000aab2:	e0 a0 07 fd 	rcall	8000baac <__multadd>
8000aab6:	18 94       	mov	r4,r12
8000aab8:	58 01       	cp.w	r1,0
8000aaba:	5f a9       	srle	r9
8000aabc:	40 cb       	lddsp	r11,sp[0x30]
8000aabe:	58 2b       	cp.w	r11,2
8000aac0:	5f 98       	srgt	r8
8000aac2:	f3 e8 00 08 	and	r8,r9,r8
8000aac6:	c2 50       	breq	8000ab10 <_dtoa_r+0x980>
8000aac8:	58 01       	cp.w	r1,0
8000aaca:	c1 11       	brne	8000aaec <_dtoa_r+0x95c>
8000aacc:	04 9b       	mov	r11,r2
8000aace:	02 99       	mov	r9,r1
8000aad0:	30 5a       	mov	r10,5
8000aad2:	0e 9c       	mov	r12,r7
8000aad4:	e0 a0 07 ec 	rcall	8000baac <__multadd>
8000aad8:	18 92       	mov	r2,r12
8000aada:	18 9b       	mov	r11,r12
8000aadc:	06 9c       	mov	r12,r3
8000aade:	e0 a0 05 f8 	rcall	8000b6ce <__mcmp>
8000aae2:	e0 89 00 0f 	brgt	8000ab00 <_dtoa_r+0x970>
8000aae6:	c0 38       	rjmp	8000aaec <_dtoa_r+0x95c>
8000aae8:	30 02       	mov	r2,0
8000aaea:	04 94       	mov	r4,r2
8000aaec:	40 ea       	lddsp	r10,sp[0x38]
8000aaee:	30 09       	mov	r9,0
8000aaf0:	5c da       	com	r10
8000aaf2:	40 85       	lddsp	r5,sp[0x20]
8000aaf4:	50 6a       	stdsp	sp[0x18],r10
8000aaf6:	50 49       	stdsp	sp[0x10],r9
8000aaf8:	c0 f9       	rjmp	8000ad16 <_dtoa_r+0xb86>
8000aafa:	08 92       	mov	r2,r4
8000aafc:	40 66       	lddsp	r6,sp[0x18]
8000aafe:	04 94       	mov	r4,r2
8000ab00:	2f f6       	sub	r6,-1
8000ab02:	50 66       	stdsp	sp[0x18],r6
8000ab04:	33 18       	mov	r8,49
8000ab06:	40 85       	lddsp	r5,sp[0x20]
8000ab08:	0a c8       	st.b	r5++,r8
8000ab0a:	30 08       	mov	r8,0
8000ab0c:	50 48       	stdsp	sp[0x10],r8
8000ab0e:	c0 49       	rjmp	8000ad16 <_dtoa_r+0xb86>
8000ab10:	40 dc       	lddsp	r12,sp[0x34]
8000ab12:	58 0c       	cp.w	r12,0
8000ab14:	e0 80 00 b5 	breq	8000ac7e <_dtoa_r+0xaee>
8000ab18:	58 05       	cp.w	r5,0
8000ab1a:	e0 8a 00 08 	brle	8000ab2a <_dtoa_r+0x99a>
8000ab1e:	08 9b       	mov	r11,r4
8000ab20:	0a 9a       	mov	r10,r5
8000ab22:	0e 9c       	mov	r12,r7
8000ab24:	e0 a0 06 f8 	rcall	8000b914 <__lshift>
8000ab28:	18 94       	mov	r4,r12
8000ab2a:	40 6b       	lddsp	r11,sp[0x18]
8000ab2c:	58 0b       	cp.w	r11,0
8000ab2e:	c0 31       	brne	8000ab34 <_dtoa_r+0x9a4>
8000ab30:	08 9c       	mov	r12,r4
8000ab32:	c1 38       	rjmp	8000ab58 <_dtoa_r+0x9c8>
8000ab34:	68 1b       	ld.w	r11,r4[0x4]
8000ab36:	0e 9c       	mov	r12,r7
8000ab38:	e0 a0 05 fe 	rcall	8000b734 <_Balloc>
8000ab3c:	68 4a       	ld.w	r10,r4[0x10]
8000ab3e:	18 95       	mov	r5,r12
8000ab40:	e8 cb ff f4 	sub	r11,r4,-12
8000ab44:	2f ea       	sub	r10,-2
8000ab46:	2f 4c       	sub	r12,-12
8000ab48:	a3 6a       	lsl	r10,0x2
8000ab4a:	fe b0 e6 4f 	rcall	800077e8 <memcpy>
8000ab4e:	0a 9b       	mov	r11,r5
8000ab50:	30 1a       	mov	r10,1
8000ab52:	0e 9c       	mov	r12,r7
8000ab54:	e0 a0 06 e0 	rcall	8000b914 <__lshift>
8000ab58:	50 44       	stdsp	sp[0x10],r4
8000ab5a:	40 3a       	lddsp	r10,sp[0xc]
8000ab5c:	30 19       	mov	r9,1
8000ab5e:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
8000ab62:	18 94       	mov	r4,r12
8000ab64:	50 da       	stdsp	sp[0x34],r10
8000ab66:	40 85       	lddsp	r5,sp[0x20]
8000ab68:	50 99       	stdsp	sp[0x24],r9
8000ab6a:	50 26       	stdsp	sp[0x8],r6
8000ab6c:	50 e1       	stdsp	sp[0x38],r1
8000ab6e:	04 9b       	mov	r11,r2
8000ab70:	06 9c       	mov	r12,r3
8000ab72:	fe b0 fa 7f 	rcall	8000a070 <quorem>
8000ab76:	40 4b       	lddsp	r11,sp[0x10]
8000ab78:	f8 c0 ff d0 	sub	r0,r12,-48
8000ab7c:	06 9c       	mov	r12,r3
8000ab7e:	e0 a0 05 a8 	rcall	8000b6ce <__mcmp>
8000ab82:	08 9a       	mov	r10,r4
8000ab84:	50 6c       	stdsp	sp[0x18],r12
8000ab86:	04 9b       	mov	r11,r2
8000ab88:	0e 9c       	mov	r12,r7
8000ab8a:	e0 a0 06 5d 	rcall	8000b844 <__mdiff>
8000ab8e:	18 91       	mov	r1,r12
8000ab90:	78 38       	ld.w	r8,r12[0xc]
8000ab92:	58 08       	cp.w	r8,0
8000ab94:	c0 30       	breq	8000ab9a <_dtoa_r+0xa0a>
8000ab96:	30 16       	mov	r6,1
8000ab98:	c0 68       	rjmp	8000aba4 <_dtoa_r+0xa14>
8000ab9a:	18 9b       	mov	r11,r12
8000ab9c:	06 9c       	mov	r12,r3
8000ab9e:	e0 a0 05 98 	rcall	8000b6ce <__mcmp>
8000aba2:	18 96       	mov	r6,r12
8000aba4:	0e 9c       	mov	r12,r7
8000aba6:	02 9b       	mov	r11,r1
8000aba8:	e0 a0 05 ac 	rcall	8000b700 <_Bfree>
8000abac:	40 cc       	lddsp	r12,sp[0x30]
8000abae:	ed ec 10 08 	or	r8,r6,r12
8000abb2:	c0 d1       	brne	8000abcc <_dtoa_r+0xa3c>
8000abb4:	40 db       	lddsp	r11,sp[0x34]
8000abb6:	58 0b       	cp.w	r11,0
8000abb8:	c0 a1       	brne	8000abcc <_dtoa_r+0xa3c>
8000abba:	40 26       	lddsp	r6,sp[0x8]
8000abbc:	e0 40 00 39 	cp.w	r0,57
8000abc0:	c3 00       	breq	8000ac20 <_dtoa_r+0xa90>
8000abc2:	40 6a       	lddsp	r10,sp[0x18]
8000abc4:	58 0a       	cp.w	r10,0
8000abc6:	e0 89 00 24 	brgt	8000ac0e <_dtoa_r+0xa7e>
8000abca:	c2 f8       	rjmp	8000ac28 <_dtoa_r+0xa98>
8000abcc:	40 69       	lddsp	r9,sp[0x18]
8000abce:	58 09       	cp.w	r9,0
8000abd0:	c0 85       	brlt	8000abe0 <_dtoa_r+0xa50>
8000abd2:	12 98       	mov	r8,r9
8000abd4:	40 cc       	lddsp	r12,sp[0x30]
8000abd6:	18 48       	or	r8,r12
8000abd8:	c1 d1       	brne	8000ac12 <_dtoa_r+0xa82>
8000abda:	40 db       	lddsp	r11,sp[0x34]
8000abdc:	58 0b       	cp.w	r11,0
8000abde:	c1 a1       	brne	8000ac12 <_dtoa_r+0xa82>
8000abe0:	0c 99       	mov	r9,r6
8000abe2:	40 26       	lddsp	r6,sp[0x8]
8000abe4:	58 09       	cp.w	r9,0
8000abe6:	e0 8a 00 21 	brle	8000ac28 <_dtoa_r+0xa98>
8000abea:	06 9b       	mov	r11,r3
8000abec:	30 1a       	mov	r10,1
8000abee:	0e 9c       	mov	r12,r7
8000abf0:	e0 a0 06 92 	rcall	8000b914 <__lshift>
8000abf4:	04 9b       	mov	r11,r2
8000abf6:	18 93       	mov	r3,r12
8000abf8:	e0 a0 05 6b 	rcall	8000b6ce <__mcmp>
8000abfc:	e0 89 00 06 	brgt	8000ac08 <_dtoa_r+0xa78>
8000ac00:	c1 41       	brne	8000ac28 <_dtoa_r+0xa98>
8000ac02:	ed b0 00 00 	bld	r0,0x0
8000ac06:	c1 11       	brne	8000ac28 <_dtoa_r+0xa98>
8000ac08:	e0 40 00 39 	cp.w	r0,57
8000ac0c:	c0 a0       	breq	8000ac20 <_dtoa_r+0xa90>
8000ac0e:	2f f0       	sub	r0,-1
8000ac10:	c0 c8       	rjmp	8000ac28 <_dtoa_r+0xa98>
8000ac12:	58 06       	cp.w	r6,0
8000ac14:	e0 8a 00 0c 	brle	8000ac2c <_dtoa_r+0xa9c>
8000ac18:	40 26       	lddsp	r6,sp[0x8]
8000ac1a:	e0 40 00 39 	cp.w	r0,57
8000ac1e:	c0 41       	brne	8000ac26 <_dtoa_r+0xa96>
8000ac20:	33 98       	mov	r8,57
8000ac22:	0a c8       	st.b	r5++,r8
8000ac24:	c6 78       	rjmp	8000acf2 <_dtoa_r+0xb62>
8000ac26:	2f f0       	sub	r0,-1
8000ac28:	0a c0       	st.b	r5++,r0
8000ac2a:	c7 58       	rjmp	8000ad14 <_dtoa_r+0xb84>
8000ac2c:	0a c0       	st.b	r5++,r0
8000ac2e:	40 9a       	lddsp	r10,sp[0x24]
8000ac30:	40 e9       	lddsp	r9,sp[0x38]
8000ac32:	12 3a       	cp.w	r10,r9
8000ac34:	c4 30       	breq	8000acba <_dtoa_r+0xb2a>
8000ac36:	06 9b       	mov	r11,r3
8000ac38:	30 09       	mov	r9,0
8000ac3a:	30 aa       	mov	r10,10
8000ac3c:	0e 9c       	mov	r12,r7
8000ac3e:	e0 a0 07 37 	rcall	8000baac <__multadd>
8000ac42:	40 48       	lddsp	r8,sp[0x10]
8000ac44:	18 93       	mov	r3,r12
8000ac46:	08 38       	cp.w	r8,r4
8000ac48:	c0 91       	brne	8000ac5a <_dtoa_r+0xaca>
8000ac4a:	10 9b       	mov	r11,r8
8000ac4c:	30 09       	mov	r9,0
8000ac4e:	30 aa       	mov	r10,10
8000ac50:	0e 9c       	mov	r12,r7
8000ac52:	e0 a0 07 2d 	rcall	8000baac <__multadd>
8000ac56:	50 4c       	stdsp	sp[0x10],r12
8000ac58:	c0 e8       	rjmp	8000ac74 <_dtoa_r+0xae4>
8000ac5a:	40 4b       	lddsp	r11,sp[0x10]
8000ac5c:	30 09       	mov	r9,0
8000ac5e:	30 aa       	mov	r10,10
8000ac60:	0e 9c       	mov	r12,r7
8000ac62:	e0 a0 07 25 	rcall	8000baac <__multadd>
8000ac66:	08 9b       	mov	r11,r4
8000ac68:	50 4c       	stdsp	sp[0x10],r12
8000ac6a:	30 09       	mov	r9,0
8000ac6c:	30 aa       	mov	r10,10
8000ac6e:	0e 9c       	mov	r12,r7
8000ac70:	e0 a0 07 1e 	rcall	8000baac <__multadd>
8000ac74:	18 94       	mov	r4,r12
8000ac76:	40 9c       	lddsp	r12,sp[0x24]
8000ac78:	2f fc       	sub	r12,-1
8000ac7a:	50 9c       	stdsp	sp[0x24],r12
8000ac7c:	c7 9b       	rjmp	8000ab6e <_dtoa_r+0x9de>
8000ac7e:	30 18       	mov	r8,1
8000ac80:	06 90       	mov	r0,r3
8000ac82:	40 85       	lddsp	r5,sp[0x20]
8000ac84:	08 93       	mov	r3,r4
8000ac86:	0c 94       	mov	r4,r6
8000ac88:	10 96       	mov	r6,r8
8000ac8a:	04 9b       	mov	r11,r2
8000ac8c:	00 9c       	mov	r12,r0
8000ac8e:	fe b0 f9 f1 	rcall	8000a070 <quorem>
8000ac92:	2d 0c       	sub	r12,-48
8000ac94:	0a cc       	st.b	r5++,r12
8000ac96:	02 36       	cp.w	r6,r1
8000ac98:	c0 a4       	brge	8000acac <_dtoa_r+0xb1c>
8000ac9a:	00 9b       	mov	r11,r0
8000ac9c:	30 09       	mov	r9,0
8000ac9e:	30 aa       	mov	r10,10
8000aca0:	0e 9c       	mov	r12,r7
8000aca2:	2f f6       	sub	r6,-1
8000aca4:	e0 a0 07 04 	rcall	8000baac <__multadd>
8000aca8:	18 90       	mov	r0,r12
8000acaa:	cf 0b       	rjmp	8000ac8a <_dtoa_r+0xafa>
8000acac:	08 96       	mov	r6,r4
8000acae:	30 0b       	mov	r11,0
8000acb0:	06 94       	mov	r4,r3
8000acb2:	50 4b       	stdsp	sp[0x10],r11
8000acb4:	00 93       	mov	r3,r0
8000acb6:	18 90       	mov	r0,r12
8000acb8:	c0 28       	rjmp	8000acbc <_dtoa_r+0xb2c>
8000acba:	40 26       	lddsp	r6,sp[0x8]
8000acbc:	06 9b       	mov	r11,r3
8000acbe:	30 1a       	mov	r10,1
8000acc0:	0e 9c       	mov	r12,r7
8000acc2:	e0 a0 06 29 	rcall	8000b914 <__lshift>
8000acc6:	04 9b       	mov	r11,r2
8000acc8:	18 93       	mov	r3,r12
8000acca:	e0 a0 05 02 	rcall	8000b6ce <__mcmp>
8000acce:	e0 89 00 12 	brgt	8000acf2 <_dtoa_r+0xb62>
8000acd2:	c1 b1       	brne	8000ad08 <_dtoa_r+0xb78>
8000acd4:	e1 d0 c0 01 	bfextu	r0,r0,0x0,0x1
8000acd8:	c0 d1       	brne	8000acf2 <_dtoa_r+0xb62>
8000acda:	c1 78       	rjmp	8000ad08 <_dtoa_r+0xb78>
8000acdc:	40 89       	lddsp	r9,sp[0x20]
8000acde:	12 38       	cp.w	r8,r9
8000ace0:	c0 30       	breq	8000ace6 <_dtoa_r+0xb56>
8000ace2:	10 95       	mov	r5,r8
8000ace4:	c0 88       	rjmp	8000acf4 <_dtoa_r+0xb64>
8000ace6:	2f f6       	sub	r6,-1
8000ace8:	50 66       	stdsp	sp[0x18],r6
8000acea:	33 18       	mov	r8,49
8000acec:	40 8c       	lddsp	r12,sp[0x20]
8000acee:	b8 88       	st.b	r12[0x0],r8
8000acf0:	c1 38       	rjmp	8000ad16 <_dtoa_r+0xb86>
8000acf2:	33 9a       	mov	r10,57
8000acf4:	0a 98       	mov	r8,r5
8000acf6:	11 79       	ld.ub	r9,--r8
8000acf8:	f4 09 18 00 	cp.b	r9,r10
8000acfc:	cf 00       	breq	8000acdc <_dtoa_r+0xb4c>
8000acfe:	2f f9       	sub	r9,-1
8000ad00:	b0 89       	st.b	r8[0x0],r9
8000ad02:	c0 98       	rjmp	8000ad14 <_dtoa_r+0xb84>
8000ad04:	10 95       	mov	r5,r8
8000ad06:	c0 28       	rjmp	8000ad0a <_dtoa_r+0xb7a>
8000ad08:	33 09       	mov	r9,48
8000ad0a:	0a 98       	mov	r8,r5
8000ad0c:	11 7a       	ld.ub	r10,--r8
8000ad0e:	f2 0a 18 00 	cp.b	r10,r9
8000ad12:	cf 90       	breq	8000ad04 <_dtoa_r+0xb74>
8000ad14:	50 66       	stdsp	sp[0x18],r6
8000ad16:	04 9b       	mov	r11,r2
8000ad18:	0e 9c       	mov	r12,r7
8000ad1a:	e0 a0 04 f3 	rcall	8000b700 <_Bfree>
8000ad1e:	58 04       	cp.w	r4,0
8000ad20:	c1 20       	breq	8000ad44 <_dtoa_r+0xbb4>
8000ad22:	40 4b       	lddsp	r11,sp[0x10]
8000ad24:	08 3b       	cp.w	r11,r4
8000ad26:	5f 19       	srne	r9
8000ad28:	58 0b       	cp.w	r11,0
8000ad2a:	5f 18       	srne	r8
8000ad2c:	f3 e8 00 08 	and	r8,r9,r8
8000ad30:	c0 40       	breq	8000ad38 <_dtoa_r+0xba8>
8000ad32:	0e 9c       	mov	r12,r7
8000ad34:	e0 a0 04 e6 	rcall	8000b700 <_Bfree>
8000ad38:	08 9b       	mov	r11,r4
8000ad3a:	0e 9c       	mov	r12,r7
8000ad3c:	e0 a0 04 e2 	rcall	8000b700 <_Bfree>
8000ad40:	c0 28       	rjmp	8000ad44 <_dtoa_r+0xbb4>
8000ad42:	50 66       	stdsp	sp[0x18],r6
8000ad44:	0e 9c       	mov	r12,r7
8000ad46:	06 9b       	mov	r11,r3
8000ad48:	e0 a0 04 dc 	rcall	8000b700 <_Bfree>
8000ad4c:	30 08       	mov	r8,0
8000ad4e:	aa 88       	st.b	r5[0x0],r8
8000ad50:	40 68       	lddsp	r8,sp[0x18]
8000ad52:	41 5a       	lddsp	r10,sp[0x54]
8000ad54:	2f f8       	sub	r8,-1
8000ad56:	41 29       	lddsp	r9,sp[0x48]
8000ad58:	95 08       	st.w	r10[0x0],r8
8000ad5a:	40 8c       	lddsp	r12,sp[0x20]
8000ad5c:	58 09       	cp.w	r9,0
8000ad5e:	fb f8 10 12 	ld.wne	r8,sp[0x48]
8000ad62:	f1 f5 1a 00 	st.wne	r8[0x0],r5
8000ad66:	2e 6d       	sub	sp,-104
8000ad68:	d8 32       	popm	r0-r7,pc
8000ad6a:	d7 03       	nop

8000ad6c <__errno>:
8000ad6c:	e0 68 0a 3c 	mov	r8,2620
8000ad70:	70 0c       	ld.w	r12,r8[0x0]
8000ad72:	2f 4c       	sub	r12,-12
8000ad74:	5e fc       	retal	r12
8000ad76:	d7 03       	nop

8000ad78 <_fflush_r>:
8000ad78:	d4 21       	pushm	r4-r7,lr
8000ad7a:	16 97       	mov	r7,r11
8000ad7c:	18 96       	mov	r6,r12
8000ad7e:	76 48       	ld.w	r8,r11[0x10]
8000ad80:	58 08       	cp.w	r8,0
8000ad82:	c7 f0       	breq	8000ae80 <_fflush_r+0x108>
8000ad84:	58 0c       	cp.w	r12,0
8000ad86:	c0 50       	breq	8000ad90 <_fflush_r+0x18>
8000ad88:	78 68       	ld.w	r8,r12[0x18]
8000ad8a:	58 08       	cp.w	r8,0
8000ad8c:	c0 21       	brne	8000ad90 <_fflush_r+0x18>
8000ad8e:	cc dc       	rcall	8000af28 <__sinit>
8000ad90:	fe c8 cc 78 	sub	r8,pc,-13192
8000ad94:	10 37       	cp.w	r7,r8
8000ad96:	c0 31       	brne	8000ad9c <_fflush_r+0x24>
8000ad98:	6c 07       	ld.w	r7,r6[0x0]
8000ad9a:	c0 c8       	rjmp	8000adb2 <_fflush_r+0x3a>
8000ad9c:	fe c8 cc 64 	sub	r8,pc,-13212
8000ada0:	10 37       	cp.w	r7,r8
8000ada2:	c0 31       	brne	8000ada8 <_fflush_r+0x30>
8000ada4:	6c 17       	ld.w	r7,r6[0x4]
8000ada6:	c0 68       	rjmp	8000adb2 <_fflush_r+0x3a>
8000ada8:	fe c8 cc 50 	sub	r8,pc,-13232
8000adac:	10 37       	cp.w	r7,r8
8000adae:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000adb2:	8e 6a       	ld.sh	r10,r7[0xc]
8000adb4:	14 98       	mov	r8,r10
8000adb6:	ed ba 00 03 	bld	r10,0x3
8000adba:	c4 20       	breq	8000ae3e <_fflush_r+0xc6>
8000adbc:	ab ba       	sbr	r10,0xb
8000adbe:	ae 6a       	st.h	r7[0xc],r10
8000adc0:	6e 18       	ld.w	r8,r7[0x4]
8000adc2:	58 08       	cp.w	r8,0
8000adc4:	e0 89 00 06 	brgt	8000add0 <_fflush_r+0x58>
8000adc8:	6f 08       	ld.w	r8,r7[0x40]
8000adca:	58 08       	cp.w	r8,0
8000adcc:	e0 8a 00 5a 	brle	8000ae80 <_fflush_r+0x108>
8000add0:	6e b8       	ld.w	r8,r7[0x2c]
8000add2:	58 08       	cp.w	r8,0
8000add4:	c5 60       	breq	8000ae80 <_fflush_r+0x108>
8000add6:	e2 1a 10 00 	andl	r10,0x1000,COH
8000adda:	c0 30       	breq	8000ade0 <_fflush_r+0x68>
8000addc:	6f 55       	ld.w	r5,r7[0x54]
8000adde:	c0 f8       	rjmp	8000adfc <_fflush_r+0x84>
8000ade0:	30 19       	mov	r9,1
8000ade2:	6e 8b       	ld.w	r11,r7[0x20]
8000ade4:	0c 9c       	mov	r12,r6
8000ade6:	5d 18       	icall	r8
8000ade8:	18 95       	mov	r5,r12
8000adea:	5b fc       	cp.w	r12,-1
8000adec:	c0 81       	brne	8000adfc <_fflush_r+0x84>
8000adee:	6c 38       	ld.w	r8,r6[0xc]
8000adf0:	59 d8       	cp.w	r8,29
8000adf2:	c4 70       	breq	8000ae80 <_fflush_r+0x108>
8000adf4:	8e 68       	ld.sh	r8,r7[0xc]
8000adf6:	a7 a8       	sbr	r8,0x6
8000adf8:	ae 68       	st.h	r7[0xc],r8
8000adfa:	d8 22       	popm	r4-r7,pc
8000adfc:	8e 68       	ld.sh	r8,r7[0xc]
8000adfe:	ed b8 00 02 	bld	r8,0x2
8000ae02:	c0 91       	brne	8000ae14 <_fflush_r+0x9c>
8000ae04:	6e 18       	ld.w	r8,r7[0x4]
8000ae06:	10 15       	sub	r5,r8
8000ae08:	6e d8       	ld.w	r8,r7[0x34]
8000ae0a:	58 08       	cp.w	r8,0
8000ae0c:	ef f8 10 10 	ld.wne	r8,r7[0x40]
8000ae10:	eb d8 e1 15 	subne	r5,r5,r8
8000ae14:	6e b8       	ld.w	r8,r7[0x2c]
8000ae16:	0c 9c       	mov	r12,r6
8000ae18:	30 09       	mov	r9,0
8000ae1a:	0a 9a       	mov	r10,r5
8000ae1c:	6e 8b       	ld.w	r11,r7[0x20]
8000ae1e:	5d 18       	icall	r8
8000ae20:	8e 68       	ld.sh	r8,r7[0xc]
8000ae22:	0a 3c       	cp.w	r12,r5
8000ae24:	c2 61       	brne	8000ae70 <_fflush_r+0xf8>
8000ae26:	ab d8       	cbr	r8,0xb
8000ae28:	30 0c       	mov	r12,0
8000ae2a:	6e 49       	ld.w	r9,r7[0x10]
8000ae2c:	ae 68       	st.h	r7[0xc],r8
8000ae2e:	8f 1c       	st.w	r7[0x4],r12
8000ae30:	8f 09       	st.w	r7[0x0],r9
8000ae32:	ed b8 00 0c 	bld	r8,0xc
8000ae36:	c2 51       	brne	8000ae80 <_fflush_r+0x108>
8000ae38:	ef 45 00 54 	st.w	r7[84],r5
8000ae3c:	d8 22       	popm	r4-r7,pc
8000ae3e:	6e 45       	ld.w	r5,r7[0x10]
8000ae40:	58 05       	cp.w	r5,0
8000ae42:	c1 f0       	breq	8000ae80 <_fflush_r+0x108>
8000ae44:	6e 04       	ld.w	r4,r7[0x0]
8000ae46:	f5 da c0 02 	bfextu	r10,r10,0x0,0x2
8000ae4a:	8f 05       	st.w	r7[0x0],r5
8000ae4c:	f9 b8 01 00 	movne	r8,0
8000ae50:	ef f8 00 05 	ld.weq	r8,r7[0x14]
8000ae54:	0a 14       	sub	r4,r5
8000ae56:	8f 28       	st.w	r7[0x8],r8
8000ae58:	c1 18       	rjmp	8000ae7a <_fflush_r+0x102>
8000ae5a:	08 99       	mov	r9,r4
8000ae5c:	0a 9a       	mov	r10,r5
8000ae5e:	6e a8       	ld.w	r8,r7[0x28]
8000ae60:	6e 8b       	ld.w	r11,r7[0x20]
8000ae62:	0c 9c       	mov	r12,r6
8000ae64:	5d 18       	icall	r8
8000ae66:	18 14       	sub	r4,r12
8000ae68:	58 0c       	cp.w	r12,0
8000ae6a:	e0 89 00 07 	brgt	8000ae78 <_fflush_r+0x100>
8000ae6e:	8e 68       	ld.sh	r8,r7[0xc]
8000ae70:	a7 a8       	sbr	r8,0x6
8000ae72:	3f fc       	mov	r12,-1
8000ae74:	ae 68       	st.h	r7[0xc],r8
8000ae76:	d8 22       	popm	r4-r7,pc
8000ae78:	18 05       	add	r5,r12
8000ae7a:	58 04       	cp.w	r4,0
8000ae7c:	fe 99 ff ef 	brgt	8000ae5a <_fflush_r+0xe2>
8000ae80:	d8 2a       	popm	r4-r7,pc,r12=0
8000ae82:	d7 03       	nop

8000ae84 <__sfp_lock_acquire>:
8000ae84:	5e fc       	retal	r12

8000ae86 <__sfp_lock_release>:
8000ae86:	5e fc       	retal	r12

8000ae88 <_cleanup_r>:
8000ae88:	d4 01       	pushm	lr
8000ae8a:	fe cb f0 ae 	sub	r11,pc,-3922
8000ae8e:	e0 a0 02 f7 	rcall	8000b47c <_fwalk>
8000ae92:	d8 02       	popm	pc

8000ae94 <__sfmoreglue>:
8000ae94:	d4 21       	pushm	r4-r7,lr
8000ae96:	16 95       	mov	r5,r11
8000ae98:	f6 06 10 5c 	mul	r6,r11,92
8000ae9c:	ec cb ff f4 	sub	r11,r6,-12
8000aea0:	fe b0 e2 88 	rcall	800073b0 <_malloc_r>
8000aea4:	18 97       	mov	r7,r12
8000aea6:	c0 90       	breq	8000aeb8 <__sfmoreglue+0x24>
8000aea8:	99 15       	st.w	r12[0x4],r5
8000aeaa:	30 0b       	mov	r11,0
8000aeac:	2f 4c       	sub	r12,-12
8000aeae:	0c 9a       	mov	r10,r6
8000aeb0:	8f 2c       	st.w	r7[0x8],r12
8000aeb2:	8f 0b       	st.w	r7[0x0],r11
8000aeb4:	fe b0 e5 3e 	rcall	80007930 <memset>
8000aeb8:	0e 9c       	mov	r12,r7
8000aeba:	d8 22       	popm	r4-r7,pc

8000aebc <__sfp>:
8000aebc:	d4 21       	pushm	r4-r7,lr
8000aebe:	fe c8 cd 42 	sub	r8,pc,-12990
8000aec2:	18 96       	mov	r6,r12
8000aec4:	70 07       	ld.w	r7,r8[0x0]
8000aec6:	6e 68       	ld.w	r8,r7[0x18]
8000aec8:	58 08       	cp.w	r8,0
8000aeca:	c0 31       	brne	8000aed0 <__sfp+0x14>
8000aecc:	0e 9c       	mov	r12,r7
8000aece:	c2 dc       	rcall	8000af28 <__sinit>
8000aed0:	ee c7 ff 28 	sub	r7,r7,-216
8000aed4:	30 05       	mov	r5,0
8000aed6:	6e 2c       	ld.w	r12,r7[0x8]
8000aed8:	6e 18       	ld.w	r8,r7[0x4]
8000aeda:	c0 68       	rjmp	8000aee6 <__sfp+0x2a>
8000aedc:	98 69       	ld.sh	r9,r12[0xc]
8000aede:	ea 09 19 00 	cp.h	r9,r5
8000aee2:	c1 10       	breq	8000af04 <__sfp+0x48>
8000aee4:	2a 4c       	sub	r12,-92
8000aee6:	20 18       	sub	r8,1
8000aee8:	cf a7       	brpl	8000aedc <__sfp+0x20>
8000aeea:	6e 08       	ld.w	r8,r7[0x0]
8000aeec:	58 08       	cp.w	r8,0
8000aeee:	c0 61       	brne	8000aefa <__sfp+0x3e>
8000aef0:	30 4b       	mov	r11,4
8000aef2:	0c 9c       	mov	r12,r6
8000aef4:	cd 0f       	rcall	8000ae94 <__sfmoreglue>
8000aef6:	8f 0c       	st.w	r7[0x0],r12
8000aef8:	c0 30       	breq	8000aefe <__sfp+0x42>
8000aefa:	6e 07       	ld.w	r7,r7[0x0]
8000aefc:	ce db       	rjmp	8000aed6 <__sfp+0x1a>
8000aefe:	30 c8       	mov	r8,12
8000af00:	8d 38       	st.w	r6[0xc],r8
8000af02:	d8 22       	popm	r4-r7,pc
8000af04:	30 08       	mov	r8,0
8000af06:	f9 48 00 4c 	st.w	r12[76],r8
8000af0a:	99 08       	st.w	r12[0x0],r8
8000af0c:	99 28       	st.w	r12[0x8],r8
8000af0e:	99 18       	st.w	r12[0x4],r8
8000af10:	99 48       	st.w	r12[0x10],r8
8000af12:	99 58       	st.w	r12[0x14],r8
8000af14:	99 68       	st.w	r12[0x18],r8
8000af16:	99 d8       	st.w	r12[0x34],r8
8000af18:	99 e8       	st.w	r12[0x38],r8
8000af1a:	f9 48 00 48 	st.w	r12[72],r8
8000af1e:	3f f8       	mov	r8,-1
8000af20:	b8 78       	st.h	r12[0xe],r8
8000af22:	30 18       	mov	r8,1
8000af24:	b8 68       	st.h	r12[0xc],r8
8000af26:	d8 22       	popm	r4-r7,pc

8000af28 <__sinit>:
8000af28:	d4 21       	pushm	r4-r7,lr
8000af2a:	18 96       	mov	r6,r12
8000af2c:	78 67       	ld.w	r7,r12[0x18]
8000af2e:	58 07       	cp.w	r7,0
8000af30:	c4 91       	brne	8000afc2 <__sinit+0x9a>
8000af32:	fe c8 00 aa 	sub	r8,pc,170
8000af36:	30 15       	mov	r5,1
8000af38:	99 a8       	st.w	r12[0x28],r8
8000af3a:	f9 47 00 d8 	st.w	r12[216],r7
8000af3e:	f9 47 00 dc 	st.w	r12[220],r7
8000af42:	f9 47 00 e0 	st.w	r12[224],r7
8000af46:	99 65       	st.w	r12[0x18],r5
8000af48:	cb af       	rcall	8000aebc <__sfp>
8000af4a:	8d 0c       	st.w	r6[0x0],r12
8000af4c:	0c 9c       	mov	r12,r6
8000af4e:	cb 7f       	rcall	8000aebc <__sfp>
8000af50:	8d 1c       	st.w	r6[0x4],r12
8000af52:	0c 9c       	mov	r12,r6
8000af54:	cb 4f       	rcall	8000aebc <__sfp>
8000af56:	6c 09       	ld.w	r9,r6[0x0]
8000af58:	30 48       	mov	r8,4
8000af5a:	93 07       	st.w	r9[0x0],r7
8000af5c:	b2 68       	st.h	r9[0xc],r8
8000af5e:	93 17       	st.w	r9[0x4],r7
8000af60:	93 27       	st.w	r9[0x8],r7
8000af62:	6c 18       	ld.w	r8,r6[0x4]
8000af64:	b2 77       	st.h	r9[0xe],r7
8000af66:	93 47       	st.w	r9[0x10],r7
8000af68:	93 57       	st.w	r9[0x14],r7
8000af6a:	93 67       	st.w	r9[0x18],r7
8000af6c:	93 89       	st.w	r9[0x20],r9
8000af6e:	91 07       	st.w	r8[0x0],r7
8000af70:	91 17       	st.w	r8[0x4],r7
8000af72:	91 27       	st.w	r8[0x8],r7
8000af74:	fe ce f3 24 	sub	lr,pc,-3292
8000af78:	fe cb f3 54 	sub	r11,pc,-3244
8000af7c:	93 9e       	st.w	r9[0x24],lr
8000af7e:	93 ab       	st.w	r9[0x28],r11
8000af80:	fe ca f3 7c 	sub	r10,pc,-3204
8000af84:	fe c4 f3 88 	sub	r4,pc,-3192
8000af88:	93 ba       	st.w	r9[0x2c],r10
8000af8a:	93 c4       	st.w	r9[0x30],r4
8000af8c:	30 99       	mov	r9,9
8000af8e:	b0 69       	st.h	r8[0xc],r9
8000af90:	b0 75       	st.h	r8[0xe],r5
8000af92:	91 c4       	st.w	r8[0x30],r4
8000af94:	91 47       	st.w	r8[0x10],r7
8000af96:	91 57       	st.w	r8[0x14],r7
8000af98:	91 67       	st.w	r8[0x18],r7
8000af9a:	91 88       	st.w	r8[0x20],r8
8000af9c:	91 9e       	st.w	r8[0x24],lr
8000af9e:	91 ab       	st.w	r8[0x28],r11
8000afa0:	91 ba       	st.w	r8[0x2c],r10
8000afa2:	8d 2c       	st.w	r6[0x8],r12
8000afa4:	31 28       	mov	r8,18
8000afa6:	99 07       	st.w	r12[0x0],r7
8000afa8:	b8 68       	st.h	r12[0xc],r8
8000afaa:	99 17       	st.w	r12[0x4],r7
8000afac:	99 27       	st.w	r12[0x8],r7
8000afae:	30 28       	mov	r8,2
8000afb0:	b8 78       	st.h	r12[0xe],r8
8000afb2:	99 c4       	st.w	r12[0x30],r4
8000afb4:	99 67       	st.w	r12[0x18],r7
8000afb6:	99 9e       	st.w	r12[0x24],lr
8000afb8:	99 ab       	st.w	r12[0x28],r11
8000afba:	99 ba       	st.w	r12[0x2c],r10
8000afbc:	99 47       	st.w	r12[0x10],r7
8000afbe:	99 57       	st.w	r12[0x14],r7
8000afc0:	99 8c       	st.w	r12[0x20],r12
8000afc2:	d8 22       	popm	r4-r7,pc

8000afc4 <_malloc_trim_r>:
8000afc4:	d4 21       	pushm	r4-r7,lr
8000afc6:	16 95       	mov	r5,r11
8000afc8:	18 97       	mov	r7,r12
8000afca:	fe b0 d7 ad 	rcall	80005f24 <__malloc_lock>
8000afce:	e0 64 05 3c 	mov	r4,1340
8000afd2:	68 28       	ld.w	r8,r4[0x8]
8000afd4:	70 16       	ld.w	r6,r8[0x4]
8000afd6:	e0 16 ff fc 	andl	r6,0xfffc
8000afda:	ec c8 ff 91 	sub	r8,r6,-111
8000afde:	f0 05 01 05 	sub	r5,r8,r5
8000afe2:	e0 15 ff 80 	andl	r5,0xff80
8000afe6:	ea c5 00 80 	sub	r5,r5,128
8000afea:	e0 45 00 7f 	cp.w	r5,127
8000afee:	e0 8a 00 25 	brle	8000b038 <_malloc_trim_r+0x74>
8000aff2:	30 0b       	mov	r11,0
8000aff4:	0e 9c       	mov	r12,r7
8000aff6:	fe b0 e6 05 	rcall	80007c00 <_sbrk_r>
8000affa:	68 28       	ld.w	r8,r4[0x8]
8000affc:	0c 08       	add	r8,r6
8000affe:	10 3c       	cp.w	r12,r8
8000b000:	c1 c1       	brne	8000b038 <_malloc_trim_r+0x74>
8000b002:	ea 0b 11 00 	rsub	r11,r5,0
8000b006:	0e 9c       	mov	r12,r7
8000b008:	fe b0 e5 fc 	rcall	80007c00 <_sbrk_r>
8000b00c:	5b fc       	cp.w	r12,-1
8000b00e:	c1 91       	brne	8000b040 <_malloc_trim_r+0x7c>
8000b010:	30 0b       	mov	r11,0
8000b012:	0e 9c       	mov	r12,r7
8000b014:	fe b0 e5 f6 	rcall	80007c00 <_sbrk_r>
8000b018:	68 28       	ld.w	r8,r4[0x8]
8000b01a:	f8 08 01 09 	sub	r9,r12,r8
8000b01e:	58 f9       	cp.w	r9,15
8000b020:	e0 8a 00 0c 	brle	8000b038 <_malloc_trim_r+0x74>
8000b024:	a1 a9       	sbr	r9,0x0
8000b026:	91 19       	st.w	r8[0x4],r9
8000b028:	e0 68 09 48 	mov	r8,2376
8000b02c:	70 09       	ld.w	r9,r8[0x0]
8000b02e:	e0 68 0d 74 	mov	r8,3444
8000b032:	f8 09 01 09 	sub	r9,r12,r9
8000b036:	91 09       	st.w	r8[0x0],r9
8000b038:	0e 9c       	mov	r12,r7
8000b03a:	fe b0 d7 7b 	rcall	80005f30 <__malloc_unlock>
8000b03e:	d8 2a       	popm	r4-r7,pc,r12=0
8000b040:	68 28       	ld.w	r8,r4[0x8]
8000b042:	0a 16       	sub	r6,r5
8000b044:	a1 a6       	sbr	r6,0x0
8000b046:	91 16       	st.w	r8[0x4],r6
8000b048:	e0 68 0d 74 	mov	r8,3444
8000b04c:	70 09       	ld.w	r9,r8[0x0]
8000b04e:	0a 19       	sub	r9,r5
8000b050:	0e 9c       	mov	r12,r7
8000b052:	91 09       	st.w	r8[0x0],r9
8000b054:	fe b0 d7 6e 	rcall	80005f30 <__malloc_unlock>
8000b058:	da 2a       	popm	r4-r7,pc,r12=1
8000b05a:	d7 03       	nop

8000b05c <_free_r>:
8000b05c:	d4 21       	pushm	r4-r7,lr
8000b05e:	16 96       	mov	r6,r11
8000b060:	18 97       	mov	r7,r12
8000b062:	58 0b       	cp.w	r11,0
8000b064:	e0 80 00 c0 	breq	8000b1e4 <_free_r+0x188>
8000b068:	fe b0 d7 5e 	rcall	80005f24 <__malloc_lock>
8000b06c:	20 86       	sub	r6,8
8000b06e:	e0 6a 05 3c 	mov	r10,1340
8000b072:	6c 18       	ld.w	r8,r6[0x4]
8000b074:	74 2e       	ld.w	lr,r10[0x8]
8000b076:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
8000b07a:	a1 c8       	cbr	r8,0x0
8000b07c:	ec 08 00 09 	add	r9,r6,r8
8000b080:	72 1b       	ld.w	r11,r9[0x4]
8000b082:	e0 1b ff fc 	andl	r11,0xfffc
8000b086:	1c 39       	cp.w	r9,lr
8000b088:	c1 e1       	brne	8000b0c4 <_free_r+0x68>
8000b08a:	f6 08 00 08 	add	r8,r11,r8
8000b08e:	58 0c       	cp.w	r12,0
8000b090:	c0 81       	brne	8000b0a0 <_free_r+0x44>
8000b092:	6c 09       	ld.w	r9,r6[0x0]
8000b094:	12 16       	sub	r6,r9
8000b096:	12 08       	add	r8,r9
8000b098:	6c 3b       	ld.w	r11,r6[0xc]
8000b09a:	6c 29       	ld.w	r9,r6[0x8]
8000b09c:	97 29       	st.w	r11[0x8],r9
8000b09e:	93 3b       	st.w	r9[0xc],r11
8000b0a0:	10 99       	mov	r9,r8
8000b0a2:	95 26       	st.w	r10[0x8],r6
8000b0a4:	a1 a9       	sbr	r9,0x0
8000b0a6:	8d 19       	st.w	r6[0x4],r9
8000b0a8:	e0 69 09 44 	mov	r9,2372
8000b0ac:	72 09       	ld.w	r9,r9[0x0]
8000b0ae:	12 38       	cp.w	r8,r9
8000b0b0:	c0 63       	brcs	8000b0bc <_free_r+0x60>
8000b0b2:	e0 68 0d 70 	mov	r8,3440
8000b0b6:	0e 9c       	mov	r12,r7
8000b0b8:	70 0b       	ld.w	r11,r8[0x0]
8000b0ba:	c8 5f       	rcall	8000afc4 <_malloc_trim_r>
8000b0bc:	0e 9c       	mov	r12,r7
8000b0be:	fe b0 d7 39 	rcall	80005f30 <__malloc_unlock>
8000b0c2:	d8 22       	popm	r4-r7,pc
8000b0c4:	93 1b       	st.w	r9[0x4],r11
8000b0c6:	58 0c       	cp.w	r12,0
8000b0c8:	c0 30       	breq	8000b0ce <_free_r+0x72>
8000b0ca:	30 0c       	mov	r12,0
8000b0cc:	c1 08       	rjmp	8000b0ec <_free_r+0x90>
8000b0ce:	6c 0e       	ld.w	lr,r6[0x0]
8000b0d0:	f4 c5 ff f8 	sub	r5,r10,-8
8000b0d4:	1c 16       	sub	r6,lr
8000b0d6:	1c 08       	add	r8,lr
8000b0d8:	6c 2e       	ld.w	lr,r6[0x8]
8000b0da:	0a 3e       	cp.w	lr,r5
8000b0dc:	f9 bc 00 01 	moveq	r12,1
8000b0e0:	ed f5 10 03 	ld.wne	r5,r6[0xc]
8000b0e4:	eb fe 1a 02 	st.wne	r5[0x8],lr
8000b0e8:	fd f5 1a 03 	st.wne	lr[0xc],r5
8000b0ec:	f2 0b 00 0e 	add	lr,r9,r11
8000b0f0:	7c 1e       	ld.w	lr,lr[0x4]
8000b0f2:	ed be 00 00 	bld	lr,0x0
8000b0f6:	c1 40       	breq	8000b11e <_free_r+0xc2>
8000b0f8:	16 08       	add	r8,r11
8000b0fa:	58 0c       	cp.w	r12,0
8000b0fc:	c0 d1       	brne	8000b116 <_free_r+0xba>
8000b0fe:	e0 6e 05 3c 	mov	lr,1340
8000b102:	72 2b       	ld.w	r11,r9[0x8]
8000b104:	2f 8e       	sub	lr,-8
8000b106:	1c 3b       	cp.w	r11,lr
8000b108:	c0 71       	brne	8000b116 <_free_r+0xba>
8000b10a:	97 36       	st.w	r11[0xc],r6
8000b10c:	97 26       	st.w	r11[0x8],r6
8000b10e:	8d 2b       	st.w	r6[0x8],r11
8000b110:	8d 3b       	st.w	r6[0xc],r11
8000b112:	30 1c       	mov	r12,1
8000b114:	c0 58       	rjmp	8000b11e <_free_r+0xc2>
8000b116:	72 2b       	ld.w	r11,r9[0x8]
8000b118:	72 39       	ld.w	r9,r9[0xc]
8000b11a:	93 2b       	st.w	r9[0x8],r11
8000b11c:	97 39       	st.w	r11[0xc],r9
8000b11e:	10 99       	mov	r9,r8
8000b120:	ec 08 09 08 	st.w	r6[r8],r8
8000b124:	a1 a9       	sbr	r9,0x0
8000b126:	8d 19       	st.w	r6[0x4],r9
8000b128:	58 0c       	cp.w	r12,0
8000b12a:	c5 a1       	brne	8000b1de <_free_r+0x182>
8000b12c:	e0 48 01 ff 	cp.w	r8,511
8000b130:	e0 8b 00 13 	brhi	8000b156 <_free_r+0xfa>
8000b134:	a3 98       	lsr	r8,0x3
8000b136:	f4 08 00 39 	add	r9,r10,r8<<0x3
8000b13a:	72 2b       	ld.w	r11,r9[0x8]
8000b13c:	8d 39       	st.w	r6[0xc],r9
8000b13e:	8d 2b       	st.w	r6[0x8],r11
8000b140:	97 36       	st.w	r11[0xc],r6
8000b142:	93 26       	st.w	r9[0x8],r6
8000b144:	a3 48       	asr	r8,0x2
8000b146:	74 19       	ld.w	r9,r10[0x4]
8000b148:	30 1b       	mov	r11,1
8000b14a:	f6 08 09 48 	lsl	r8,r11,r8
8000b14e:	f3 e8 10 08 	or	r8,r9,r8
8000b152:	95 18       	st.w	r10[0x4],r8
8000b154:	c4 58       	rjmp	8000b1de <_free_r+0x182>
8000b156:	f0 0b 16 09 	lsr	r11,r8,0x9
8000b15a:	58 4b       	cp.w	r11,4
8000b15c:	e0 8b 00 06 	brhi	8000b168 <_free_r+0x10c>
8000b160:	f0 0b 16 06 	lsr	r11,r8,0x6
8000b164:	2c 8b       	sub	r11,-56
8000b166:	c2 08       	rjmp	8000b1a6 <_free_r+0x14a>
8000b168:	59 4b       	cp.w	r11,20
8000b16a:	e0 8b 00 04 	brhi	8000b172 <_free_r+0x116>
8000b16e:	2a 5b       	sub	r11,-91
8000b170:	c1 b8       	rjmp	8000b1a6 <_free_r+0x14a>
8000b172:	e0 4b 00 54 	cp.w	r11,84
8000b176:	e0 8b 00 06 	brhi	8000b182 <_free_r+0x126>
8000b17a:	f0 0b 16 0c 	lsr	r11,r8,0xc
8000b17e:	29 2b       	sub	r11,-110
8000b180:	c1 38       	rjmp	8000b1a6 <_free_r+0x14a>
8000b182:	e0 4b 01 54 	cp.w	r11,340
8000b186:	e0 8b 00 06 	brhi	8000b192 <_free_r+0x136>
8000b18a:	f0 0b 16 0f 	lsr	r11,r8,0xf
8000b18e:	28 9b       	sub	r11,-119
8000b190:	c0 b8       	rjmp	8000b1a6 <_free_r+0x14a>
8000b192:	e0 4b 05 54 	cp.w	r11,1364
8000b196:	e0 88 00 05 	brls	8000b1a0 <_free_r+0x144>
8000b19a:	37 eb       	mov	r11,126
8000b19c:	c0 58       	rjmp	8000b1a6 <_free_r+0x14a>
8000b19e:	d7 03       	nop
8000b1a0:	f0 0b 16 12 	lsr	r11,r8,0x12
8000b1a4:	28 4b       	sub	r11,-124
8000b1a6:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
8000b1aa:	78 29       	ld.w	r9,r12[0x8]
8000b1ac:	18 39       	cp.w	r9,r12
8000b1ae:	c0 e1       	brne	8000b1ca <_free_r+0x16e>
8000b1b0:	74 18       	ld.w	r8,r10[0x4]
8000b1b2:	a3 4b       	asr	r11,0x2
8000b1b4:	30 1c       	mov	r12,1
8000b1b6:	f8 0b 09 4b 	lsl	r11,r12,r11
8000b1ba:	f1 eb 10 0b 	or	r11,r8,r11
8000b1be:	12 98       	mov	r8,r9
8000b1c0:	95 1b       	st.w	r10[0x4],r11
8000b1c2:	c0 a8       	rjmp	8000b1d6 <_free_r+0x17a>
8000b1c4:	72 29       	ld.w	r9,r9[0x8]
8000b1c6:	18 39       	cp.w	r9,r12
8000b1c8:	c0 60       	breq	8000b1d4 <_free_r+0x178>
8000b1ca:	72 1a       	ld.w	r10,r9[0x4]
8000b1cc:	e0 1a ff fc 	andl	r10,0xfffc
8000b1d0:	14 38       	cp.w	r8,r10
8000b1d2:	cf 93       	brcs	8000b1c4 <_free_r+0x168>
8000b1d4:	72 38       	ld.w	r8,r9[0xc]
8000b1d6:	8d 38       	st.w	r6[0xc],r8
8000b1d8:	8d 29       	st.w	r6[0x8],r9
8000b1da:	93 36       	st.w	r9[0xc],r6
8000b1dc:	91 26       	st.w	r8[0x8],r6
8000b1de:	0e 9c       	mov	r12,r7
8000b1e0:	fe b0 d6 a8 	rcall	80005f30 <__malloc_unlock>
8000b1e4:	d8 22       	popm	r4-r7,pc
8000b1e6:	d7 03       	nop

8000b1e8 <__sfvwrite_r>:
8000b1e8:	d4 31       	pushm	r0-r7,lr
8000b1ea:	20 3d       	sub	sp,12
8000b1ec:	14 94       	mov	r4,r10
8000b1ee:	18 95       	mov	r5,r12
8000b1f0:	16 97       	mov	r7,r11
8000b1f2:	74 28       	ld.w	r8,r10[0x8]
8000b1f4:	58 08       	cp.w	r8,0
8000b1f6:	e0 80 01 40 	breq	8000b476 <__sfvwrite_r+0x28e>
8000b1fa:	96 68       	ld.sh	r8,r11[0xc]
8000b1fc:	ed b8 00 03 	bld	r8,0x3
8000b200:	c0 41       	brne	8000b208 <__sfvwrite_r+0x20>
8000b202:	76 48       	ld.w	r8,r11[0x10]
8000b204:	58 08       	cp.w	r8,0
8000b206:	c0 c1       	brne	8000b21e <__sfvwrite_r+0x36>
8000b208:	0e 9b       	mov	r11,r7
8000b20a:	0a 9c       	mov	r12,r5
8000b20c:	fe b0 f6 c4 	rcall	80009f94 <__swsetup_r>
8000b210:	c0 70       	breq	8000b21e <__sfvwrite_r+0x36>
8000b212:	8e 68       	ld.sh	r8,r7[0xc]
8000b214:	a7 a8       	sbr	r8,0x6
8000b216:	ae 68       	st.h	r7[0xc],r8
8000b218:	30 98       	mov	r8,9
8000b21a:	8b 38       	st.w	r5[0xc],r8
8000b21c:	c2 b9       	rjmp	8000b472 <__sfvwrite_r+0x28a>
8000b21e:	8e 63       	ld.sh	r3,r7[0xc]
8000b220:	68 00       	ld.w	r0,r4[0x0]
8000b222:	06 96       	mov	r6,r3
8000b224:	e2 16 00 02 	andl	r6,0x2,COH
8000b228:	c2 10       	breq	8000b26a <__sfvwrite_r+0x82>
8000b22a:	30 03       	mov	r3,0
8000b22c:	e0 62 04 00 	mov	r2,1024
8000b230:	06 96       	mov	r6,r3
8000b232:	c0 48       	rjmp	8000b23a <__sfvwrite_r+0x52>
8000b234:	60 03       	ld.w	r3,r0[0x0]
8000b236:	60 16       	ld.w	r6,r0[0x4]
8000b238:	2f 80       	sub	r0,-8
8000b23a:	58 06       	cp.w	r6,0
8000b23c:	cf c0       	breq	8000b234 <__sfvwrite_r+0x4c>
8000b23e:	e0 46 04 00 	cp.w	r6,1024
8000b242:	ec 09 17 80 	movls	r9,r6
8000b246:	e4 09 17 b0 	movhi	r9,r2
8000b24a:	06 9a       	mov	r10,r3
8000b24c:	6e a8       	ld.w	r8,r7[0x28]
8000b24e:	6e 8b       	ld.w	r11,r7[0x20]
8000b250:	0a 9c       	mov	r12,r5
8000b252:	5d 18       	icall	r8
8000b254:	18 16       	sub	r6,r12
8000b256:	58 0c       	cp.w	r12,0
8000b258:	e0 8a 01 0a 	brle	8000b46c <__sfvwrite_r+0x284>
8000b25c:	68 28       	ld.w	r8,r4[0x8]
8000b25e:	18 18       	sub	r8,r12
8000b260:	89 28       	st.w	r4[0x8],r8
8000b262:	e0 80 01 0a 	breq	8000b476 <__sfvwrite_r+0x28e>
8000b266:	18 03       	add	r3,r12
8000b268:	ce 9b       	rjmp	8000b23a <__sfvwrite_r+0x52>
8000b26a:	e7 d3 c0 01 	bfextu	r3,r3,0x0,0x1
8000b26e:	c0 70       	breq	8000b27c <__sfvwrite_r+0x94>
8000b270:	50 06       	stdsp	sp[0x0],r6
8000b272:	0c 93       	mov	r3,r6
8000b274:	0c 91       	mov	r1,r6
8000b276:	50 15       	stdsp	sp[0x4],r5
8000b278:	08 92       	mov	r2,r4
8000b27a:	c9 c8       	rjmp	8000b3b2 <__sfvwrite_r+0x1ca>
8000b27c:	06 96       	mov	r6,r3
8000b27e:	08 91       	mov	r1,r4
8000b280:	c0 48       	rjmp	8000b288 <__sfvwrite_r+0xa0>
8000b282:	60 03       	ld.w	r3,r0[0x0]
8000b284:	60 16       	ld.w	r6,r0[0x4]
8000b286:	2f 80       	sub	r0,-8
8000b288:	58 06       	cp.w	r6,0
8000b28a:	cf c0       	breq	8000b282 <__sfvwrite_r+0x9a>
8000b28c:	8e 68       	ld.sh	r8,r7[0xc]
8000b28e:	6e 24       	ld.w	r4,r7[0x8]
8000b290:	10 99       	mov	r9,r8
8000b292:	e2 19 02 00 	andl	r9,0x200,COH
8000b296:	c5 50       	breq	8000b340 <__sfvwrite_r+0x158>
8000b298:	08 36       	cp.w	r6,r4
8000b29a:	c4 43       	brcs	8000b322 <__sfvwrite_r+0x13a>
8000b29c:	10 99       	mov	r9,r8
8000b29e:	e2 19 04 80 	andl	r9,0x480,COH
8000b2a2:	c4 00       	breq	8000b322 <__sfvwrite_r+0x13a>
8000b2a4:	6e 4b       	ld.w	r11,r7[0x10]
8000b2a6:	6e 09       	ld.w	r9,r7[0x0]
8000b2a8:	16 19       	sub	r9,r11
8000b2aa:	50 09       	stdsp	sp[0x0],r9
8000b2ac:	6e 59       	ld.w	r9,r7[0x14]
8000b2ae:	10 9c       	mov	r12,r8
8000b2b0:	f2 09 00 1a 	add	r10,r9,r9<<0x1
8000b2b4:	30 28       	mov	r8,2
8000b2b6:	f4 08 0c 08 	divs	r8,r10,r8
8000b2ba:	fa e9 00 04 	st.d	sp[4],r8
8000b2be:	10 94       	mov	r4,r8
8000b2c0:	40 09       	lddsp	r9,sp[0x0]
8000b2c2:	e2 1c 04 00 	andl	r12,0x400,COH
8000b2c6:	2f f9       	sub	r9,-1
8000b2c8:	0c 09       	add	r9,r6
8000b2ca:	12 38       	cp.w	r8,r9
8000b2cc:	f2 04 17 30 	movlo	r4,r9
8000b2d0:	58 0c       	cp.w	r12,0
8000b2d2:	c1 10       	breq	8000b2f4 <__sfvwrite_r+0x10c>
8000b2d4:	08 9b       	mov	r11,r4
8000b2d6:	0a 9c       	mov	r12,r5
8000b2d8:	fe b0 e0 6c 	rcall	800073b0 <_malloc_r>
8000b2dc:	18 92       	mov	r2,r12
8000b2de:	c1 40       	breq	8000b306 <__sfvwrite_r+0x11e>
8000b2e0:	40 0a       	lddsp	r10,sp[0x0]
8000b2e2:	6e 4b       	ld.w	r11,r7[0x10]
8000b2e4:	fe b0 e2 82 	rcall	800077e8 <memcpy>
8000b2e8:	8e 68       	ld.sh	r8,r7[0xc]
8000b2ea:	e0 18 fb 7f 	andl	r8,0xfb7f
8000b2ee:	a7 b8       	sbr	r8,0x7
8000b2f0:	ae 68       	st.h	r7[0xc],r8
8000b2f2:	c0 d8       	rjmp	8000b30c <__sfvwrite_r+0x124>
8000b2f4:	08 9a       	mov	r10,r4
8000b2f6:	0a 9c       	mov	r12,r5
8000b2f8:	fe b0 e3 24 	rcall	80007940 <_realloc_r>
8000b2fc:	18 92       	mov	r2,r12
8000b2fe:	c0 71       	brne	8000b30c <__sfvwrite_r+0x124>
8000b300:	6e 4b       	ld.w	r11,r7[0x10]
8000b302:	0a 9c       	mov	r12,r5
8000b304:	ca ce       	rcall	8000b05c <_free_r>
8000b306:	30 c8       	mov	r8,12
8000b308:	8b 38       	st.w	r5[0xc],r8
8000b30a:	cb 18       	rjmp	8000b46c <__sfvwrite_r+0x284>
8000b30c:	40 0a       	lddsp	r10,sp[0x0]
8000b30e:	40 09       	lddsp	r9,sp[0x0]
8000b310:	e8 0a 01 0a 	sub	r10,r4,r10
8000b314:	e4 09 00 08 	add	r8,r2,r9
8000b318:	8f 54       	st.w	r7[0x14],r4
8000b31a:	8f 2a       	st.w	r7[0x8],r10
8000b31c:	8f 08       	st.w	r7[0x0],r8
8000b31e:	8f 42       	st.w	r7[0x10],r2
8000b320:	0c 94       	mov	r4,r6
8000b322:	08 36       	cp.w	r6,r4
8000b324:	ec 04 17 30 	movlo	r4,r6
8000b328:	06 9b       	mov	r11,r3
8000b32a:	08 9a       	mov	r10,r4
8000b32c:	6e 0c       	ld.w	r12,r7[0x0]
8000b32e:	c3 ad       	rcall	8000b5a2 <memmove>
8000b330:	6e 08       	ld.w	r8,r7[0x0]
8000b332:	08 08       	add	r8,r4
8000b334:	8f 08       	st.w	r7[0x0],r8
8000b336:	6e 28       	ld.w	r8,r7[0x8]
8000b338:	08 18       	sub	r8,r4
8000b33a:	0c 94       	mov	r4,r6
8000b33c:	8f 28       	st.w	r7[0x8],r8
8000b33e:	c2 e8       	rjmp	8000b39a <__sfvwrite_r+0x1b2>
8000b340:	08 36       	cp.w	r6,r4
8000b342:	5f ba       	srhi	r10
8000b344:	6e 0c       	ld.w	r12,r7[0x0]
8000b346:	6e 48       	ld.w	r8,r7[0x10]
8000b348:	10 3c       	cp.w	r12,r8
8000b34a:	5f b8       	srhi	r8
8000b34c:	f5 e8 00 08 	and	r8,r10,r8
8000b350:	f2 08 18 00 	cp.b	r8,r9
8000b354:	c0 d0       	breq	8000b36e <__sfvwrite_r+0x186>
8000b356:	06 9b       	mov	r11,r3
8000b358:	08 9a       	mov	r10,r4
8000b35a:	c2 4d       	rcall	8000b5a2 <memmove>
8000b35c:	6e 08       	ld.w	r8,r7[0x0]
8000b35e:	08 08       	add	r8,r4
8000b360:	0e 9b       	mov	r11,r7
8000b362:	8f 08       	st.w	r7[0x0],r8
8000b364:	0a 9c       	mov	r12,r5
8000b366:	fe b0 fd 09 	rcall	8000ad78 <_fflush_r>
8000b36a:	c1 80       	breq	8000b39a <__sfvwrite_r+0x1b2>
8000b36c:	c8 08       	rjmp	8000b46c <__sfvwrite_r+0x284>
8000b36e:	6e 59       	ld.w	r9,r7[0x14]
8000b370:	12 36       	cp.w	r6,r9
8000b372:	c0 a3       	brcs	8000b386 <__sfvwrite_r+0x19e>
8000b374:	6e a8       	ld.w	r8,r7[0x28]
8000b376:	06 9a       	mov	r10,r3
8000b378:	6e 8b       	ld.w	r11,r7[0x20]
8000b37a:	0a 9c       	mov	r12,r5
8000b37c:	5d 18       	icall	r8
8000b37e:	18 94       	mov	r4,r12
8000b380:	e0 89 00 0d 	brgt	8000b39a <__sfvwrite_r+0x1b2>
8000b384:	c7 48       	rjmp	8000b46c <__sfvwrite_r+0x284>
8000b386:	0c 9a       	mov	r10,r6
8000b388:	06 9b       	mov	r11,r3
8000b38a:	c0 cd       	rcall	8000b5a2 <memmove>
8000b38c:	6e 08       	ld.w	r8,r7[0x0]
8000b38e:	0c 08       	add	r8,r6
8000b390:	0c 94       	mov	r4,r6
8000b392:	8f 08       	st.w	r7[0x0],r8
8000b394:	6e 28       	ld.w	r8,r7[0x8]
8000b396:	0c 18       	sub	r8,r6
8000b398:	8f 28       	st.w	r7[0x8],r8
8000b39a:	62 28       	ld.w	r8,r1[0x8]
8000b39c:	08 18       	sub	r8,r4
8000b39e:	83 28       	st.w	r1[0x8],r8
8000b3a0:	c6 b0       	breq	8000b476 <__sfvwrite_r+0x28e>
8000b3a2:	08 16       	sub	r6,r4
8000b3a4:	08 03       	add	r3,r4
8000b3a6:	c7 1b       	rjmp	8000b288 <__sfvwrite_r+0xa0>
8000b3a8:	60 03       	ld.w	r3,r0[0x0]
8000b3aa:	60 11       	ld.w	r1,r0[0x4]
8000b3ac:	30 08       	mov	r8,0
8000b3ae:	2f 80       	sub	r0,-8
8000b3b0:	50 08       	stdsp	sp[0x0],r8
8000b3b2:	58 01       	cp.w	r1,0
8000b3b4:	cf a0       	breq	8000b3a8 <__sfvwrite_r+0x1c0>
8000b3b6:	40 0a       	lddsp	r10,sp[0x0]
8000b3b8:	58 0a       	cp.w	r10,0
8000b3ba:	c1 41       	brne	8000b3e2 <__sfvwrite_r+0x1fa>
8000b3bc:	e2 c6 ff ff 	sub	r6,r1,-1
8000b3c0:	02 9a       	mov	r10,r1
8000b3c2:	30 ab       	mov	r11,10
8000b3c4:	06 9c       	mov	r12,r3
8000b3c6:	ce 3c       	rcall	8000b58c <memchr>
8000b3c8:	f8 c8 ff ff 	sub	r8,r12,-1
8000b3cc:	58 0c       	cp.w	r12,0
8000b3ce:	f1 d3 e1 16 	subne	r6,r8,r3
8000b3d2:	f9 b9 01 01 	movne	r9,1
8000b3d6:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000b3da:	f9 b8 00 01 	moveq	r8,1
8000b3de:	fb f8 0a 00 	st.weq	sp[0x0],r8
8000b3e2:	02 36       	cp.w	r6,r1
8000b3e4:	ec 04 17 80 	movls	r4,r6
8000b3e8:	e2 04 17 b0 	movhi	r4,r1
8000b3ec:	6e 59       	ld.w	r9,r7[0x14]
8000b3ee:	6e 25       	ld.w	r5,r7[0x8]
8000b3f0:	f2 05 00 05 	add	r5,r9,r5
8000b3f4:	0a 34       	cp.w	r4,r5
8000b3f6:	5f 9a       	srgt	r10
8000b3f8:	6e 0c       	ld.w	r12,r7[0x0]
8000b3fa:	6e 48       	ld.w	r8,r7[0x10]
8000b3fc:	10 3c       	cp.w	r12,r8
8000b3fe:	5f b8       	srhi	r8
8000b400:	f5 e8 00 08 	and	r8,r10,r8
8000b404:	30 0a       	mov	r10,0
8000b406:	f4 08 18 00 	cp.b	r8,r10
8000b40a:	c0 d0       	breq	8000b424 <__sfvwrite_r+0x23c>
8000b40c:	06 9b       	mov	r11,r3
8000b40e:	0a 9a       	mov	r10,r5
8000b410:	cc 9c       	rcall	8000b5a2 <memmove>
8000b412:	6e 08       	ld.w	r8,r7[0x0]
8000b414:	0a 08       	add	r8,r5
8000b416:	0e 9b       	mov	r11,r7
8000b418:	8f 08       	st.w	r7[0x0],r8
8000b41a:	40 1c       	lddsp	r12,sp[0x4]
8000b41c:	fe b0 fc ae 	rcall	8000ad78 <_fflush_r>
8000b420:	c1 70       	breq	8000b44e <__sfvwrite_r+0x266>
8000b422:	c2 58       	rjmp	8000b46c <__sfvwrite_r+0x284>
8000b424:	12 34       	cp.w	r4,r9
8000b426:	c0 a5       	brlt	8000b43a <__sfvwrite_r+0x252>
8000b428:	6e a8       	ld.w	r8,r7[0x28]
8000b42a:	06 9a       	mov	r10,r3
8000b42c:	6e 8b       	ld.w	r11,r7[0x20]
8000b42e:	40 1c       	lddsp	r12,sp[0x4]
8000b430:	5d 18       	icall	r8
8000b432:	18 95       	mov	r5,r12
8000b434:	e0 89 00 0d 	brgt	8000b44e <__sfvwrite_r+0x266>
8000b438:	c1 a8       	rjmp	8000b46c <__sfvwrite_r+0x284>
8000b43a:	08 9a       	mov	r10,r4
8000b43c:	06 9b       	mov	r11,r3
8000b43e:	cb 2c       	rcall	8000b5a2 <memmove>
8000b440:	6e 08       	ld.w	r8,r7[0x0]
8000b442:	08 08       	add	r8,r4
8000b444:	08 95       	mov	r5,r4
8000b446:	8f 08       	st.w	r7[0x0],r8
8000b448:	6e 28       	ld.w	r8,r7[0x8]
8000b44a:	08 18       	sub	r8,r4
8000b44c:	8f 28       	st.w	r7[0x8],r8
8000b44e:	0a 16       	sub	r6,r5
8000b450:	c0 71       	brne	8000b45e <__sfvwrite_r+0x276>
8000b452:	0e 9b       	mov	r11,r7
8000b454:	40 1c       	lddsp	r12,sp[0x4]
8000b456:	fe b0 fc 91 	rcall	8000ad78 <_fflush_r>
8000b45a:	c0 91       	brne	8000b46c <__sfvwrite_r+0x284>
8000b45c:	50 06       	stdsp	sp[0x0],r6
8000b45e:	64 28       	ld.w	r8,r2[0x8]
8000b460:	0a 18       	sub	r8,r5
8000b462:	85 28       	st.w	r2[0x8],r8
8000b464:	c0 90       	breq	8000b476 <__sfvwrite_r+0x28e>
8000b466:	0a 11       	sub	r1,r5
8000b468:	0a 03       	add	r3,r5
8000b46a:	ca 4b       	rjmp	8000b3b2 <__sfvwrite_r+0x1ca>
8000b46c:	8e 68       	ld.sh	r8,r7[0xc]
8000b46e:	a7 a8       	sbr	r8,0x6
8000b470:	ae 68       	st.h	r7[0xc],r8
8000b472:	3f fc       	mov	r12,-1
8000b474:	c0 28       	rjmp	8000b478 <__sfvwrite_r+0x290>
8000b476:	30 0c       	mov	r12,0
8000b478:	2f dd       	sub	sp,-12
8000b47a:	d8 32       	popm	r0-r7,pc

8000b47c <_fwalk>:
8000b47c:	d4 31       	pushm	r0-r7,lr
8000b47e:	30 05       	mov	r5,0
8000b480:	16 91       	mov	r1,r11
8000b482:	f8 c7 ff 28 	sub	r7,r12,-216
8000b486:	0a 92       	mov	r2,r5
8000b488:	fe b0 fc fe 	rcall	8000ae84 <__sfp_lock_acquire>
8000b48c:	3f f3       	mov	r3,-1
8000b48e:	c1 68       	rjmp	8000b4ba <_fwalk+0x3e>
8000b490:	6e 26       	ld.w	r6,r7[0x8]
8000b492:	6e 14       	ld.w	r4,r7[0x4]
8000b494:	2f 46       	sub	r6,-12
8000b496:	c0 c8       	rjmp	8000b4ae <_fwalk+0x32>
8000b498:	8c 08       	ld.sh	r8,r6[0x0]
8000b49a:	e4 08 19 00 	cp.h	r8,r2
8000b49e:	c0 70       	breq	8000b4ac <_fwalk+0x30>
8000b4a0:	8c 18       	ld.sh	r8,r6[0x2]
8000b4a2:	e6 08 19 00 	cp.h	r8,r3
8000b4a6:	c0 30       	breq	8000b4ac <_fwalk+0x30>
8000b4a8:	5d 11       	icall	r1
8000b4aa:	18 45       	or	r5,r12
8000b4ac:	2a 46       	sub	r6,-92
8000b4ae:	20 14       	sub	r4,1
8000b4b0:	ec cc 00 0c 	sub	r12,r6,12
8000b4b4:	58 04       	cp.w	r4,0
8000b4b6:	cf 14       	brge	8000b498 <_fwalk+0x1c>
8000b4b8:	6e 07       	ld.w	r7,r7[0x0]
8000b4ba:	58 07       	cp.w	r7,0
8000b4bc:	ce a1       	brne	8000b490 <_fwalk+0x14>
8000b4be:	fe b0 fc e4 	rcall	8000ae86 <__sfp_lock_release>
8000b4c2:	0a 9c       	mov	r12,r5
8000b4c4:	d8 32       	popm	r0-r7,pc
8000b4c6:	d7 03       	nop

8000b4c8 <_localeconv_r>:
8000b4c8:	fe cc d3 48 	sub	r12,pc,-11448
8000b4cc:	5e fc       	retal	r12
8000b4ce:	d7 03       	nop

8000b4d0 <__smakebuf_r>:
8000b4d0:	d4 21       	pushm	r4-r7,lr
8000b4d2:	20 fd       	sub	sp,60
8000b4d4:	96 68       	ld.sh	r8,r11[0xc]
8000b4d6:	16 97       	mov	r7,r11
8000b4d8:	18 96       	mov	r6,r12
8000b4da:	e2 18 00 02 	andl	r8,0x2,COH
8000b4de:	c3 d1       	brne	8000b558 <__smakebuf_r+0x88>
8000b4e0:	96 7b       	ld.sh	r11,r11[0xe]
8000b4e2:	f0 0b 19 00 	cp.h	r11,r8
8000b4e6:	c0 55       	brlt	8000b4f0 <__smakebuf_r+0x20>
8000b4e8:	1a 9a       	mov	r10,sp
8000b4ea:	e0 a0 04 81 	rcall	8000bdec <_fstat_r>
8000b4ee:	c0 f4       	brge	8000b50c <__smakebuf_r+0x3c>
8000b4f0:	8e 65       	ld.sh	r5,r7[0xc]
8000b4f2:	0a 98       	mov	r8,r5
8000b4f4:	ab b8       	sbr	r8,0xb
8000b4f6:	e2 15 00 80 	andl	r5,0x80,COH
8000b4fa:	ae 68       	st.h	r7[0xc],r8
8000b4fc:	30 04       	mov	r4,0
8000b4fe:	e0 68 04 00 	mov	r8,1024
8000b502:	f9 b5 01 40 	movne	r5,64
8000b506:	f0 05 17 00 	moveq	r5,r8
8000b50a:	c1 c8       	rjmp	8000b542 <__smakebuf_r+0x72>
8000b50c:	40 18       	lddsp	r8,sp[0x4]
8000b50e:	e2 18 f0 00 	andl	r8,0xf000,COH
8000b512:	e0 48 20 00 	cp.w	r8,8192
8000b516:	5f 04       	sreq	r4
8000b518:	e0 48 80 00 	cp.w	r8,32768
8000b51c:	c0 e1       	brne	8000b538 <__smakebuf_r+0x68>
8000b51e:	6e b9       	ld.w	r9,r7[0x2c]
8000b520:	fe c8 f9 1c 	sub	r8,pc,-1764
8000b524:	10 39       	cp.w	r9,r8
8000b526:	c0 91       	brne	8000b538 <__smakebuf_r+0x68>
8000b528:	8e 68       	ld.sh	r8,r7[0xc]
8000b52a:	e0 65 04 00 	mov	r5,1024
8000b52e:	ab a8       	sbr	r8,0xa
8000b530:	ef 45 00 50 	st.w	r7[80],r5
8000b534:	ae 68       	st.h	r7[0xc],r8
8000b536:	c0 68       	rjmp	8000b542 <__smakebuf_r+0x72>
8000b538:	8e 68       	ld.sh	r8,r7[0xc]
8000b53a:	e0 65 04 00 	mov	r5,1024
8000b53e:	ab b8       	sbr	r8,0xb
8000b540:	ae 68       	st.h	r7[0xc],r8
8000b542:	0a 9b       	mov	r11,r5
8000b544:	0c 9c       	mov	r12,r6
8000b546:	fe b0 df 35 	rcall	800073b0 <_malloc_r>
8000b54a:	8e 68       	ld.sh	r8,r7[0xc]
8000b54c:	c0 d1       	brne	8000b566 <__smakebuf_r+0x96>
8000b54e:	ed b8 00 09 	bld	r8,0x9
8000b552:	c1 b0       	breq	8000b588 <__smakebuf_r+0xb8>
8000b554:	a1 b8       	sbr	r8,0x1
8000b556:	ae 68       	st.h	r7[0xc],r8
8000b558:	ee c8 ff b9 	sub	r8,r7,-71
8000b55c:	8f 48       	st.w	r7[0x10],r8
8000b55e:	8f 08       	st.w	r7[0x0],r8
8000b560:	30 18       	mov	r8,1
8000b562:	8f 58       	st.w	r7[0x14],r8
8000b564:	c1 28       	rjmp	8000b588 <__smakebuf_r+0xb8>
8000b566:	a7 b8       	sbr	r8,0x7
8000b568:	8f 4c       	st.w	r7[0x10],r12
8000b56a:	ae 68       	st.h	r7[0xc],r8
8000b56c:	8f 55       	st.w	r7[0x14],r5
8000b56e:	fe c8 06 e6 	sub	r8,pc,1766
8000b572:	8f 0c       	st.w	r7[0x0],r12
8000b574:	8d a8       	st.w	r6[0x28],r8
8000b576:	58 04       	cp.w	r4,0
8000b578:	c0 80       	breq	8000b588 <__smakebuf_r+0xb8>
8000b57a:	8e 7c       	ld.sh	r12,r7[0xe]
8000b57c:	fe b0 e3 94 	rcall	80007ca4 <isatty>
8000b580:	c0 40       	breq	8000b588 <__smakebuf_r+0xb8>
8000b582:	8e 68       	ld.sh	r8,r7[0xc]
8000b584:	a1 a8       	sbr	r8,0x0
8000b586:	ae 68       	st.h	r7[0xc],r8
8000b588:	2f 1d       	sub	sp,-60
8000b58a:	d8 22       	popm	r4-r7,pc

8000b58c <memchr>:
8000b58c:	f7 db c0 08 	bfextu	r11,r11,0x0,0x8
8000b590:	c0 68       	rjmp	8000b59c <memchr+0x10>
8000b592:	20 1a       	sub	r10,1
8000b594:	19 88       	ld.ub	r8,r12[0x0]
8000b596:	16 38       	cp.w	r8,r11
8000b598:	5e 0c       	reteq	r12
8000b59a:	2f fc       	sub	r12,-1
8000b59c:	58 0a       	cp.w	r10,0
8000b59e:	cf a1       	brne	8000b592 <memchr+0x6>
8000b5a0:	5e fa       	retal	r10

8000b5a2 <memmove>:
8000b5a2:	d4 01       	pushm	lr
8000b5a4:	18 3b       	cp.w	r11,r12
8000b5a6:	c1 92       	brcc	8000b5d8 <memmove+0x36>
8000b5a8:	f6 0a 00 09 	add	r9,r11,r10
8000b5ac:	12 3c       	cp.w	r12,r9
8000b5ae:	c1 52       	brcc	8000b5d8 <memmove+0x36>
8000b5b0:	f8 0a 00 0b 	add	r11,r12,r10
8000b5b4:	30 08       	mov	r8,0
8000b5b6:	c0 68       	rjmp	8000b5c2 <memmove+0x20>
8000b5b8:	f2 08 07 0e 	ld.ub	lr,r9[r8]
8000b5bc:	20 1a       	sub	r10,1
8000b5be:	f6 08 0b 0e 	st.b	r11[r8],lr
8000b5c2:	20 18       	sub	r8,1
8000b5c4:	58 0a       	cp.w	r10,0
8000b5c6:	cf 91       	brne	8000b5b8 <memmove+0x16>
8000b5c8:	d8 02       	popm	pc
8000b5ca:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000b5ce:	20 1a       	sub	r10,1
8000b5d0:	f8 08 0b 09 	st.b	r12[r8],r9
8000b5d4:	2f f8       	sub	r8,-1
8000b5d6:	c0 28       	rjmp	8000b5da <memmove+0x38>
8000b5d8:	30 08       	mov	r8,0
8000b5da:	58 0a       	cp.w	r10,0
8000b5dc:	cf 71       	brne	8000b5ca <memmove+0x28>
8000b5de:	d8 02       	popm	pc

8000b5e0 <__hi0bits>:
8000b5e0:	18 98       	mov	r8,r12
8000b5e2:	e0 1c 00 00 	andl	r12,0x0
8000b5e6:	f0 09 15 10 	lsl	r9,r8,0x10
8000b5ea:	58 0c       	cp.w	r12,0
8000b5ec:	f2 08 17 00 	moveq	r8,r9
8000b5f0:	f9 bc 00 10 	moveq	r12,16
8000b5f4:	f9 bc 01 00 	movne	r12,0
8000b5f8:	10 9a       	mov	r10,r8
8000b5fa:	f0 09 15 08 	lsl	r9,r8,0x8
8000b5fe:	e6 1a ff 00 	andh	r10,0xff00,COH
8000b602:	f7 bc 00 f8 	subeq	r12,-8
8000b606:	f2 08 17 00 	moveq	r8,r9
8000b60a:	10 9a       	mov	r10,r8
8000b60c:	f0 09 15 04 	lsl	r9,r8,0x4
8000b610:	e6 1a f0 00 	andh	r10,0xf000,COH
8000b614:	f7 bc 00 fc 	subeq	r12,-4
8000b618:	f2 08 17 00 	moveq	r8,r9
8000b61c:	10 9a       	mov	r10,r8
8000b61e:	f0 09 15 02 	lsl	r9,r8,0x2
8000b622:	e6 1a c0 00 	andh	r10,0xc000,COH
8000b626:	f7 bc 00 fe 	subeq	r12,-2
8000b62a:	f2 08 17 00 	moveq	r8,r9
8000b62e:	58 08       	cp.w	r8,0
8000b630:	5e 5c       	retlt	r12
8000b632:	ed b8 00 1e 	bld	r8,0x1e
8000b636:	f9 bc 01 20 	movne	r12,32
8000b63a:	f7 bc 00 ff 	subeq	r12,-1
8000b63e:	5e fc       	retal	r12

8000b640 <__lo0bits>:
8000b640:	18 99       	mov	r9,r12
8000b642:	78 08       	ld.w	r8,r12[0x0]
8000b644:	f9 d8 c0 03 	bfextu	r12,r8,0x0,0x3
8000b648:	c1 50       	breq	8000b672 <__lo0bits+0x32>
8000b64a:	ed b8 00 00 	bld	r8,0x0
8000b64e:	c0 21       	brne	8000b652 <__lo0bits+0x12>
8000b650:	5e fd       	retal	0
8000b652:	10 9b       	mov	r11,r8
8000b654:	f0 0a 16 01 	lsr	r10,r8,0x1
8000b658:	e2 1b 00 02 	andl	r11,0x2,COH
8000b65c:	a3 88       	lsr	r8,0x2
8000b65e:	58 0b       	cp.w	r11,0
8000b660:	f3 fa 1a 00 	st.wne	r9[0x0],r10
8000b664:	f9 bc 01 01 	movne	r12,1
8000b668:	f3 f8 0a 00 	st.weq	r9[0x0],r8
8000b66c:	f9 bc 00 02 	moveq	r12,2
8000b670:	5e fc       	retal	r12
8000b672:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
8000b676:	f0 0b 16 10 	lsr	r11,r8,0x10
8000b67a:	58 0a       	cp.w	r10,0
8000b67c:	f6 08 17 00 	moveq	r8,r11
8000b680:	f9 bc 00 10 	moveq	r12,16
8000b684:	f7 d8 c0 08 	bfextu	r11,r8,0x0,0x8
8000b688:	f0 0a 16 08 	lsr	r10,r8,0x8
8000b68c:	58 0b       	cp.w	r11,0
8000b68e:	f7 bc 00 f8 	subeq	r12,-8
8000b692:	f4 08 17 00 	moveq	r8,r10
8000b696:	f7 d8 c0 04 	bfextu	r11,r8,0x0,0x4
8000b69a:	f0 0a 16 04 	lsr	r10,r8,0x4
8000b69e:	58 0b       	cp.w	r11,0
8000b6a0:	f7 bc 00 fc 	subeq	r12,-4
8000b6a4:	f4 08 17 00 	moveq	r8,r10
8000b6a8:	f7 d8 c0 02 	bfextu	r11,r8,0x0,0x2
8000b6ac:	f0 0a 16 02 	lsr	r10,r8,0x2
8000b6b0:	58 0b       	cp.w	r11,0
8000b6b2:	f7 bc 00 fe 	subeq	r12,-2
8000b6b6:	f4 08 17 00 	moveq	r8,r10
8000b6ba:	ed b8 00 00 	bld	r8,0x0
8000b6be:	c0 60       	breq	8000b6ca <__lo0bits+0x8a>
8000b6c0:	a1 98       	lsr	r8,0x1
8000b6c2:	c0 31       	brne	8000b6c8 <__lo0bits+0x88>
8000b6c4:	32 0c       	mov	r12,32
8000b6c6:	5e fc       	retal	r12
8000b6c8:	2f fc       	sub	r12,-1
8000b6ca:	93 08       	st.w	r9[0x0],r8
8000b6cc:	5e fc       	retal	r12

8000b6ce <__mcmp>:
8000b6ce:	d4 01       	pushm	lr
8000b6d0:	18 98       	mov	r8,r12
8000b6d2:	76 49       	ld.w	r9,r11[0x10]
8000b6d4:	78 4c       	ld.w	r12,r12[0x10]
8000b6d6:	12 1c       	sub	r12,r9
8000b6d8:	c1 31       	brne	8000b6fe <__mcmp+0x30>
8000b6da:	2f b9       	sub	r9,-5
8000b6dc:	a3 69       	lsl	r9,0x2
8000b6de:	12 0b       	add	r11,r9
8000b6e0:	f0 09 00 09 	add	r9,r8,r9
8000b6e4:	2e c8       	sub	r8,-20
8000b6e6:	13 4e       	ld.w	lr,--r9
8000b6e8:	17 4a       	ld.w	r10,--r11
8000b6ea:	14 3e       	cp.w	lr,r10
8000b6ec:	c0 60       	breq	8000b6f8 <__mcmp+0x2a>
8000b6ee:	f9 bc 03 ff 	movlo	r12,-1
8000b6f2:	f9 bc 02 01 	movhs	r12,1
8000b6f6:	d8 02       	popm	pc
8000b6f8:	10 39       	cp.w	r9,r8
8000b6fa:	fe 9b ff f6 	brhi	8000b6e6 <__mcmp+0x18>
8000b6fe:	d8 02       	popm	pc

8000b700 <_Bfree>:
8000b700:	d4 21       	pushm	r4-r7,lr
8000b702:	18 97       	mov	r7,r12
8000b704:	16 95       	mov	r5,r11
8000b706:	78 96       	ld.w	r6,r12[0x24]
8000b708:	58 06       	cp.w	r6,0
8000b70a:	c0 91       	brne	8000b71c <_Bfree+0x1c>
8000b70c:	31 0c       	mov	r12,16
8000b70e:	fe b0 de 49 	rcall	800073a0 <malloc>
8000b712:	99 36       	st.w	r12[0xc],r6
8000b714:	8f 9c       	st.w	r7[0x24],r12
8000b716:	99 16       	st.w	r12[0x4],r6
8000b718:	99 26       	st.w	r12[0x8],r6
8000b71a:	99 06       	st.w	r12[0x0],r6
8000b71c:	58 05       	cp.w	r5,0
8000b71e:	c0 90       	breq	8000b730 <_Bfree+0x30>
8000b720:	6a 19       	ld.w	r9,r5[0x4]
8000b722:	6e 98       	ld.w	r8,r7[0x24]
8000b724:	70 38       	ld.w	r8,r8[0xc]
8000b726:	f0 09 03 2a 	ld.w	r10,r8[r9<<0x2]
8000b72a:	8b 0a       	st.w	r5[0x0],r10
8000b72c:	f0 09 09 25 	st.w	r8[r9<<0x2],r5
8000b730:	d8 22       	popm	r4-r7,pc
8000b732:	d7 03       	nop

8000b734 <_Balloc>:
8000b734:	d4 21       	pushm	r4-r7,lr
8000b736:	18 97       	mov	r7,r12
8000b738:	16 96       	mov	r6,r11
8000b73a:	78 95       	ld.w	r5,r12[0x24]
8000b73c:	58 05       	cp.w	r5,0
8000b73e:	c0 91       	brne	8000b750 <_Balloc+0x1c>
8000b740:	31 0c       	mov	r12,16
8000b742:	fe b0 de 2f 	rcall	800073a0 <malloc>
8000b746:	99 35       	st.w	r12[0xc],r5
8000b748:	8f 9c       	st.w	r7[0x24],r12
8000b74a:	99 15       	st.w	r12[0x4],r5
8000b74c:	99 25       	st.w	r12[0x8],r5
8000b74e:	99 05       	st.w	r12[0x0],r5
8000b750:	6e 95       	ld.w	r5,r7[0x24]
8000b752:	6a 38       	ld.w	r8,r5[0xc]
8000b754:	58 08       	cp.w	r8,0
8000b756:	c0 b1       	brne	8000b76c <_Balloc+0x38>
8000b758:	31 0a       	mov	r10,16
8000b75a:	30 4b       	mov	r11,4
8000b75c:	0e 9c       	mov	r12,r7
8000b75e:	e0 a0 02 a7 	rcall	8000bcac <_calloc_r>
8000b762:	8b 3c       	st.w	r5[0xc],r12
8000b764:	6e 98       	ld.w	r8,r7[0x24]
8000b766:	70 3c       	ld.w	r12,r8[0xc]
8000b768:	58 0c       	cp.w	r12,0
8000b76a:	c1 b0       	breq	8000b7a0 <_Balloc+0x6c>
8000b76c:	6e 98       	ld.w	r8,r7[0x24]
8000b76e:	70 38       	ld.w	r8,r8[0xc]
8000b770:	f0 06 00 28 	add	r8,r8,r6<<0x2
8000b774:	70 0c       	ld.w	r12,r8[0x0]
8000b776:	58 0c       	cp.w	r12,0
8000b778:	c0 40       	breq	8000b780 <_Balloc+0x4c>
8000b77a:	78 09       	ld.w	r9,r12[0x0]
8000b77c:	91 09       	st.w	r8[0x0],r9
8000b77e:	c0 e8       	rjmp	8000b79a <_Balloc+0x66>
8000b780:	0e 9c       	mov	r12,r7
8000b782:	30 17       	mov	r7,1
8000b784:	0e 9b       	mov	r11,r7
8000b786:	ee 06 09 47 	lsl	r7,r7,r6
8000b78a:	ee ca ff fb 	sub	r10,r7,-5
8000b78e:	a3 6a       	lsl	r10,0x2
8000b790:	e0 a0 02 8e 	rcall	8000bcac <_calloc_r>
8000b794:	c0 60       	breq	8000b7a0 <_Balloc+0x6c>
8000b796:	99 16       	st.w	r12[0x4],r6
8000b798:	99 27       	st.w	r12[0x8],r7
8000b79a:	30 08       	mov	r8,0
8000b79c:	99 38       	st.w	r12[0xc],r8
8000b79e:	99 48       	st.w	r12[0x10],r8
8000b7a0:	d8 22       	popm	r4-r7,pc
8000b7a2:	d7 03       	nop

8000b7a4 <__d2b>:
8000b7a4:	d4 31       	pushm	r0-r7,lr
8000b7a6:	20 2d       	sub	sp,8
8000b7a8:	16 93       	mov	r3,r11
8000b7aa:	12 96       	mov	r6,r9
8000b7ac:	10 95       	mov	r5,r8
8000b7ae:	14 92       	mov	r2,r10
8000b7b0:	30 1b       	mov	r11,1
8000b7b2:	cc 1f       	rcall	8000b734 <_Balloc>
8000b7b4:	f3 d3 c0 14 	bfextu	r9,r3,0x0,0x14
8000b7b8:	50 09       	stdsp	sp[0x0],r9
8000b7ba:	f1 d3 c0 1f 	bfextu	r8,r3,0x0,0x1f
8000b7be:	b5 a9       	sbr	r9,0x14
8000b7c0:	f0 01 16 14 	lsr	r1,r8,0x14
8000b7c4:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000b7c8:	18 94       	mov	r4,r12
8000b7ca:	58 02       	cp.w	r2,0
8000b7cc:	c1 d0       	breq	8000b806 <__d2b+0x62>
8000b7ce:	fa cc ff f8 	sub	r12,sp,-8
8000b7d2:	18 d2       	st.w	--r12,r2
8000b7d4:	c3 6f       	rcall	8000b640 <__lo0bits>
8000b7d6:	40 18       	lddsp	r8,sp[0x4]
8000b7d8:	c0 d0       	breq	8000b7f2 <__d2b+0x4e>
8000b7da:	40 09       	lddsp	r9,sp[0x0]
8000b7dc:	f8 0a 11 20 	rsub	r10,r12,32
8000b7e0:	f2 0a 09 4a 	lsl	r10,r9,r10
8000b7e4:	f5 e8 10 08 	or	r8,r10,r8
8000b7e8:	89 58       	st.w	r4[0x14],r8
8000b7ea:	f2 0c 0a 49 	lsr	r9,r9,r12
8000b7ee:	50 09       	stdsp	sp[0x0],r9
8000b7f0:	c0 28       	rjmp	8000b7f4 <__d2b+0x50>
8000b7f2:	89 58       	st.w	r4[0x14],r8
8000b7f4:	40 08       	lddsp	r8,sp[0x0]
8000b7f6:	58 08       	cp.w	r8,0
8000b7f8:	f9 b3 01 02 	movne	r3,2
8000b7fc:	f9 b3 00 01 	moveq	r3,1
8000b800:	89 68       	st.w	r4[0x18],r8
8000b802:	89 43       	st.w	r4[0x10],r3
8000b804:	c0 88       	rjmp	8000b814 <__d2b+0x70>
8000b806:	1a 9c       	mov	r12,sp
8000b808:	c1 cf       	rcall	8000b640 <__lo0bits>
8000b80a:	30 13       	mov	r3,1
8000b80c:	40 08       	lddsp	r8,sp[0x0]
8000b80e:	2e 0c       	sub	r12,-32
8000b810:	89 43       	st.w	r4[0x10],r3
8000b812:	89 58       	st.w	r4[0x14],r8
8000b814:	58 01       	cp.w	r1,0
8000b816:	c0 90       	breq	8000b828 <__d2b+0x84>
8000b818:	e2 c1 04 33 	sub	r1,r1,1075
8000b81c:	18 01       	add	r1,r12
8000b81e:	8d 01       	st.w	r6[0x0],r1
8000b820:	f8 0c 11 35 	rsub	r12,r12,53
8000b824:	8b 0c       	st.w	r5[0x0],r12
8000b826:	c0 c8       	rjmp	8000b83e <__d2b+0x9a>
8000b828:	e6 c8 ff fc 	sub	r8,r3,-4
8000b82c:	f8 cc 04 32 	sub	r12,r12,1074
8000b830:	a5 73       	lsl	r3,0x5
8000b832:	8d 0c       	st.w	r6[0x0],r12
8000b834:	e8 08 03 2c 	ld.w	r12,r4[r8<<0x2]
8000b838:	cd 4e       	rcall	8000b5e0 <__hi0bits>
8000b83a:	18 13       	sub	r3,r12
8000b83c:	8b 03       	st.w	r5[0x0],r3
8000b83e:	08 9c       	mov	r12,r4
8000b840:	2f ed       	sub	sp,-8
8000b842:	d8 32       	popm	r0-r7,pc

8000b844 <__mdiff>:
8000b844:	d4 31       	pushm	r0-r7,lr
8000b846:	74 48       	ld.w	r8,r10[0x10]
8000b848:	76 45       	ld.w	r5,r11[0x10]
8000b84a:	16 97       	mov	r7,r11
8000b84c:	14 96       	mov	r6,r10
8000b84e:	10 15       	sub	r5,r8
8000b850:	c1 31       	brne	8000b876 <__mdiff+0x32>
8000b852:	2f b8       	sub	r8,-5
8000b854:	ee ce ff ec 	sub	lr,r7,-20
8000b858:	a3 68       	lsl	r8,0x2
8000b85a:	f4 08 00 0b 	add	r11,r10,r8
8000b85e:	ee 08 00 08 	add	r8,r7,r8
8000b862:	11 4a       	ld.w	r10,--r8
8000b864:	17 49       	ld.w	r9,--r11
8000b866:	12 3a       	cp.w	r10,r9
8000b868:	c0 30       	breq	8000b86e <__mdiff+0x2a>
8000b86a:	c0 e2       	brcc	8000b886 <__mdiff+0x42>
8000b86c:	c0 78       	rjmp	8000b87a <__mdiff+0x36>
8000b86e:	1c 38       	cp.w	r8,lr
8000b870:	fe 9b ff f9 	brhi	8000b862 <__mdiff+0x1e>
8000b874:	c4 98       	rjmp	8000b906 <__mdiff+0xc2>
8000b876:	58 05       	cp.w	r5,0
8000b878:	c0 64       	brge	8000b884 <__mdiff+0x40>
8000b87a:	0e 98       	mov	r8,r7
8000b87c:	30 15       	mov	r5,1
8000b87e:	0c 97       	mov	r7,r6
8000b880:	10 96       	mov	r6,r8
8000b882:	c0 28       	rjmp	8000b886 <__mdiff+0x42>
8000b884:	30 05       	mov	r5,0
8000b886:	6e 1b       	ld.w	r11,r7[0x4]
8000b888:	c5 6f       	rcall	8000b734 <_Balloc>
8000b88a:	6e 49       	ld.w	r9,r7[0x10]
8000b88c:	6c 44       	ld.w	r4,r6[0x10]
8000b88e:	99 35       	st.w	r12[0xc],r5
8000b890:	2f b4       	sub	r4,-5
8000b892:	f2 c5 ff fb 	sub	r5,r9,-5
8000b896:	ec 04 00 24 	add	r4,r6,r4<<0x2
8000b89a:	ee 05 00 25 	add	r5,r7,r5<<0x2
8000b89e:	2e c6       	sub	r6,-20
8000b8a0:	2e c7       	sub	r7,-20
8000b8a2:	f8 c8 ff ec 	sub	r8,r12,-20
8000b8a6:	30 0a       	mov	r10,0
8000b8a8:	0f 0e       	ld.w	lr,r7++
8000b8aa:	0d 0b       	ld.w	r11,r6++
8000b8ac:	fc 02 16 10 	lsr	r2,lr,0x10
8000b8b0:	f6 03 16 10 	lsr	r3,r11,0x10
8000b8b4:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000b8b8:	e4 03 01 03 	sub	r3,r2,r3
8000b8bc:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000b8c0:	fc 0b 01 0b 	sub	r11,lr,r11
8000b8c4:	f6 0a 00 0a 	add	r10,r11,r10
8000b8c8:	b0 1a       	st.h	r8[0x2],r10
8000b8ca:	b1 4a       	asr	r10,0x10
8000b8cc:	e6 0a 00 0a 	add	r10,r3,r10
8000b8d0:	b0 0a       	st.h	r8[0x0],r10
8000b8d2:	2f c8       	sub	r8,-4
8000b8d4:	b1 4a       	asr	r10,0x10
8000b8d6:	08 36       	cp.w	r6,r4
8000b8d8:	ce 83       	brcs	8000b8a8 <__mdiff+0x64>
8000b8da:	c0 d8       	rjmp	8000b8f4 <__mdiff+0xb0>
8000b8dc:	0f 0b       	ld.w	r11,r7++
8000b8de:	f6 0e 16 10 	lsr	lr,r11,0x10
8000b8e2:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000b8e6:	16 0a       	add	r10,r11
8000b8e8:	b0 1a       	st.h	r8[0x2],r10
8000b8ea:	b1 4a       	asr	r10,0x10
8000b8ec:	1c 0a       	add	r10,lr
8000b8ee:	b0 0a       	st.h	r8[0x0],r10
8000b8f0:	2f c8       	sub	r8,-4
8000b8f2:	b1 4a       	asr	r10,0x10
8000b8f4:	0a 37       	cp.w	r7,r5
8000b8f6:	cf 33       	brcs	8000b8dc <__mdiff+0x98>
8000b8f8:	c0 28       	rjmp	8000b8fc <__mdiff+0xb8>
8000b8fa:	20 19       	sub	r9,1
8000b8fc:	11 4a       	ld.w	r10,--r8
8000b8fe:	58 0a       	cp.w	r10,0
8000b900:	cf d0       	breq	8000b8fa <__mdiff+0xb6>
8000b902:	99 49       	st.w	r12[0x10],r9
8000b904:	d8 32       	popm	r0-r7,pc
8000b906:	30 0b       	mov	r11,0
8000b908:	c1 6f       	rcall	8000b734 <_Balloc>
8000b90a:	30 18       	mov	r8,1
8000b90c:	99 48       	st.w	r12[0x10],r8
8000b90e:	30 08       	mov	r8,0
8000b910:	99 58       	st.w	r12[0x14],r8
8000b912:	d8 32       	popm	r0-r7,pc

8000b914 <__lshift>:
8000b914:	d4 31       	pushm	r0-r7,lr
8000b916:	16 97       	mov	r7,r11
8000b918:	76 46       	ld.w	r6,r11[0x10]
8000b91a:	f4 02 14 05 	asr	r2,r10,0x5
8000b91e:	2f f6       	sub	r6,-1
8000b920:	14 93       	mov	r3,r10
8000b922:	18 94       	mov	r4,r12
8000b924:	04 06       	add	r6,r2
8000b926:	76 1b       	ld.w	r11,r11[0x4]
8000b928:	6e 28       	ld.w	r8,r7[0x8]
8000b92a:	c0 38       	rjmp	8000b930 <__lshift+0x1c>
8000b92c:	2f fb       	sub	r11,-1
8000b92e:	a1 78       	lsl	r8,0x1
8000b930:	10 36       	cp.w	r6,r8
8000b932:	fe 99 ff fd 	brgt	8000b92c <__lshift+0x18>
8000b936:	08 9c       	mov	r12,r4
8000b938:	cf ee       	rcall	8000b734 <_Balloc>
8000b93a:	30 09       	mov	r9,0
8000b93c:	18 95       	mov	r5,r12
8000b93e:	f8 c8 ff ec 	sub	r8,r12,-20
8000b942:	12 9a       	mov	r10,r9
8000b944:	c0 38       	rjmp	8000b94a <__lshift+0x36>
8000b946:	10 aa       	st.w	r8++,r10
8000b948:	2f f9       	sub	r9,-1
8000b94a:	04 39       	cp.w	r9,r2
8000b94c:	cf d5       	brlt	8000b946 <__lshift+0x32>
8000b94e:	6e 4b       	ld.w	r11,r7[0x10]
8000b950:	e7 d3 c0 05 	bfextu	r3,r3,0x0,0x5
8000b954:	2f bb       	sub	r11,-5
8000b956:	ee c9 ff ec 	sub	r9,r7,-20
8000b95a:	ee 0b 00 2b 	add	r11,r7,r11<<0x2
8000b95e:	58 03       	cp.w	r3,0
8000b960:	c1 30       	breq	8000b986 <__lshift+0x72>
8000b962:	e6 0c 11 20 	rsub	r12,r3,32
8000b966:	30 0a       	mov	r10,0
8000b968:	72 02       	ld.w	r2,r9[0x0]
8000b96a:	e4 03 09 42 	lsl	r2,r2,r3
8000b96e:	04 4a       	or	r10,r2
8000b970:	10 aa       	st.w	r8++,r10
8000b972:	13 0a       	ld.w	r10,r9++
8000b974:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000b978:	16 39       	cp.w	r9,r11
8000b97a:	cf 73       	brcs	8000b968 <__lshift+0x54>
8000b97c:	91 0a       	st.w	r8[0x0],r10
8000b97e:	58 0a       	cp.w	r10,0
8000b980:	c0 70       	breq	8000b98e <__lshift+0x7a>
8000b982:	2f f6       	sub	r6,-1
8000b984:	c0 58       	rjmp	8000b98e <__lshift+0x7a>
8000b986:	13 0a       	ld.w	r10,r9++
8000b988:	10 aa       	st.w	r8++,r10
8000b98a:	16 39       	cp.w	r9,r11
8000b98c:	cf d3       	brcs	8000b986 <__lshift+0x72>
8000b98e:	08 9c       	mov	r12,r4
8000b990:	20 16       	sub	r6,1
8000b992:	0e 9b       	mov	r11,r7
8000b994:	8b 46       	st.w	r5[0x10],r6
8000b996:	cb 5e       	rcall	8000b700 <_Bfree>
8000b998:	0a 9c       	mov	r12,r5
8000b99a:	d8 32       	popm	r0-r7,pc

8000b99c <__multiply>:
8000b99c:	d4 31       	pushm	r0-r7,lr
8000b99e:	20 2d       	sub	sp,8
8000b9a0:	76 49       	ld.w	r9,r11[0x10]
8000b9a2:	74 48       	ld.w	r8,r10[0x10]
8000b9a4:	16 96       	mov	r6,r11
8000b9a6:	14 95       	mov	r5,r10
8000b9a8:	10 39       	cp.w	r9,r8
8000b9aa:	ec 08 17 50 	movlt	r8,r6
8000b9ae:	ea 06 17 50 	movlt	r6,r5
8000b9b2:	f0 05 17 50 	movlt	r5,r8
8000b9b6:	6c 28       	ld.w	r8,r6[0x8]
8000b9b8:	76 43       	ld.w	r3,r11[0x10]
8000b9ba:	74 42       	ld.w	r2,r10[0x10]
8000b9bc:	76 1b       	ld.w	r11,r11[0x4]
8000b9be:	e4 03 00 07 	add	r7,r2,r3
8000b9c2:	10 37       	cp.w	r7,r8
8000b9c4:	f7 bb 09 ff 	subgt	r11,-1
8000b9c8:	cb 6e       	rcall	8000b734 <_Balloc>
8000b9ca:	ee c4 ff fb 	sub	r4,r7,-5
8000b9ce:	f8 c9 ff ec 	sub	r9,r12,-20
8000b9d2:	f8 04 00 24 	add	r4,r12,r4<<0x2
8000b9d6:	30 0a       	mov	r10,0
8000b9d8:	12 98       	mov	r8,r9
8000b9da:	c0 28       	rjmp	8000b9de <__multiply+0x42>
8000b9dc:	10 aa       	st.w	r8++,r10
8000b9de:	08 38       	cp.w	r8,r4
8000b9e0:	cf e3       	brcs	8000b9dc <__multiply+0x40>
8000b9e2:	2f b3       	sub	r3,-5
8000b9e4:	2f b2       	sub	r2,-5
8000b9e6:	ec 03 00 23 	add	r3,r6,r3<<0x2
8000b9ea:	ea 02 00 22 	add	r2,r5,r2<<0x2
8000b9ee:	ec cb ff ec 	sub	r11,r6,-20
8000b9f2:	50 12       	stdsp	sp[0x4],r2
8000b9f4:	ea ca ff ec 	sub	r10,r5,-20
8000b9f8:	c4 48       	rjmp	8000ba80 <__multiply+0xe4>
8000b9fa:	94 95       	ld.uh	r5,r10[0x2]
8000b9fc:	58 05       	cp.w	r5,0
8000b9fe:	c2 00       	breq	8000ba3e <__multiply+0xa2>
8000ba00:	12 98       	mov	r8,r9
8000ba02:	16 96       	mov	r6,r11
8000ba04:	30 0e       	mov	lr,0
8000ba06:	50 09       	stdsp	sp[0x0],r9
8000ba08:	0d 02       	ld.w	r2,r6++
8000ba0a:	e4 00 16 10 	lsr	r0,r2,0x10
8000ba0e:	70 01       	ld.w	r1,r8[0x0]
8000ba10:	70 09       	ld.w	r9,r8[0x0]
8000ba12:	b1 81       	lsr	r1,0x10
8000ba14:	e5 d2 c0 10 	bfextu	r2,r2,0x0,0x10
8000ba18:	e0 05 03 41 	mac	r1,r0,r5
8000ba1c:	ab 32       	mul	r2,r5
8000ba1e:	e1 d9 c0 10 	bfextu	r0,r9,0x0,0x10
8000ba22:	00 02       	add	r2,r0
8000ba24:	e4 0e 00 0e 	add	lr,r2,lr
8000ba28:	b0 1e       	st.h	r8[0x2],lr
8000ba2a:	b1 8e       	lsr	lr,0x10
8000ba2c:	1c 01       	add	r1,lr
8000ba2e:	b0 01       	st.h	r8[0x0],r1
8000ba30:	e2 0e 16 10 	lsr	lr,r1,0x10
8000ba34:	2f c8       	sub	r8,-4
8000ba36:	06 36       	cp.w	r6,r3
8000ba38:	ce 83       	brcs	8000ba08 <__multiply+0x6c>
8000ba3a:	40 09       	lddsp	r9,sp[0x0]
8000ba3c:	91 0e       	st.w	r8[0x0],lr
8000ba3e:	94 86       	ld.uh	r6,r10[0x0]
8000ba40:	58 06       	cp.w	r6,0
8000ba42:	c1 d0       	breq	8000ba7c <__multiply+0xe0>
8000ba44:	72 02       	ld.w	r2,r9[0x0]
8000ba46:	12 98       	mov	r8,r9
8000ba48:	16 9e       	mov	lr,r11
8000ba4a:	30 05       	mov	r5,0
8000ba4c:	b0 12       	st.h	r8[0x2],r2
8000ba4e:	1d 01       	ld.w	r1,lr++
8000ba50:	90 82       	ld.uh	r2,r8[0x0]
8000ba52:	e1 d1 c0 10 	bfextu	r0,r1,0x0,0x10
8000ba56:	ad 30       	mul	r0,r6
8000ba58:	e0 02 00 02 	add	r2,r0,r2
8000ba5c:	e4 05 00 05 	add	r5,r2,r5
8000ba60:	b0 05       	st.h	r8[0x0],r5
8000ba62:	b1 85       	lsr	r5,0x10
8000ba64:	b1 81       	lsr	r1,0x10
8000ba66:	2f c8       	sub	r8,-4
8000ba68:	ad 31       	mul	r1,r6
8000ba6a:	90 92       	ld.uh	r2,r8[0x2]
8000ba6c:	e2 02 00 02 	add	r2,r1,r2
8000ba70:	0a 02       	add	r2,r5
8000ba72:	e4 05 16 10 	lsr	r5,r2,0x10
8000ba76:	06 3e       	cp.w	lr,r3
8000ba78:	ce a3       	brcs	8000ba4c <__multiply+0xb0>
8000ba7a:	91 02       	st.w	r8[0x0],r2
8000ba7c:	2f ca       	sub	r10,-4
8000ba7e:	2f c9       	sub	r9,-4
8000ba80:	40 18       	lddsp	r8,sp[0x4]
8000ba82:	10 3a       	cp.w	r10,r8
8000ba84:	cb b3       	brcs	8000b9fa <__multiply+0x5e>
8000ba86:	c0 28       	rjmp	8000ba8a <__multiply+0xee>
8000ba88:	20 17       	sub	r7,1
8000ba8a:	58 07       	cp.w	r7,0
8000ba8c:	e0 8a 00 05 	brle	8000ba96 <__multiply+0xfa>
8000ba90:	09 48       	ld.w	r8,--r4
8000ba92:	58 08       	cp.w	r8,0
8000ba94:	cf a0       	breq	8000ba88 <__multiply+0xec>
8000ba96:	99 47       	st.w	r12[0x10],r7
8000ba98:	2f ed       	sub	sp,-8
8000ba9a:	d8 32       	popm	r0-r7,pc

8000ba9c <__i2b>:
8000ba9c:	d4 21       	pushm	r4-r7,lr
8000ba9e:	16 97       	mov	r7,r11
8000baa0:	30 1b       	mov	r11,1
8000baa2:	c4 9e       	rcall	8000b734 <_Balloc>
8000baa4:	30 19       	mov	r9,1
8000baa6:	99 57       	st.w	r12[0x14],r7
8000baa8:	99 49       	st.w	r12[0x10],r9
8000baaa:	d8 22       	popm	r4-r7,pc

8000baac <__multadd>:
8000baac:	d4 31       	pushm	r0-r7,lr
8000baae:	30 08       	mov	r8,0
8000bab0:	12 95       	mov	r5,r9
8000bab2:	16 97       	mov	r7,r11
8000bab4:	18 96       	mov	r6,r12
8000bab6:	76 44       	ld.w	r4,r11[0x10]
8000bab8:	f6 c9 ff ec 	sub	r9,r11,-20
8000babc:	72 0b       	ld.w	r11,r9[0x0]
8000babe:	f6 0c 16 10 	lsr	r12,r11,0x10
8000bac2:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000bac6:	f4 0c 02 4c 	mul	r12,r10,r12
8000baca:	f4 0b 03 45 	mac	r5,r10,r11
8000bace:	f7 d5 c0 10 	bfextu	r11,r5,0x0,0x10
8000bad2:	b1 85       	lsr	r5,0x10
8000bad4:	18 05       	add	r5,r12
8000bad6:	ea 0c 15 10 	lsl	r12,r5,0x10
8000bada:	f8 0b 00 0b 	add	r11,r12,r11
8000bade:	12 ab       	st.w	r9++,r11
8000bae0:	2f f8       	sub	r8,-1
8000bae2:	b1 85       	lsr	r5,0x10
8000bae4:	08 38       	cp.w	r8,r4
8000bae6:	ce b5       	brlt	8000babc <__multadd+0x10>
8000bae8:	58 05       	cp.w	r5,0
8000baea:	c1 c0       	breq	8000bb22 <__multadd+0x76>
8000baec:	6e 28       	ld.w	r8,r7[0x8]
8000baee:	10 34       	cp.w	r4,r8
8000baf0:	c1 35       	brlt	8000bb16 <__multadd+0x6a>
8000baf2:	6e 1b       	ld.w	r11,r7[0x4]
8000baf4:	0c 9c       	mov	r12,r6
8000baf6:	2f fb       	sub	r11,-1
8000baf8:	c1 ee       	rcall	8000b734 <_Balloc>
8000bafa:	6e 4a       	ld.w	r10,r7[0x10]
8000bafc:	ee cb ff f4 	sub	r11,r7,-12
8000bb00:	18 93       	mov	r3,r12
8000bb02:	2f ea       	sub	r10,-2
8000bb04:	2f 4c       	sub	r12,-12
8000bb06:	a3 6a       	lsl	r10,0x2
8000bb08:	fe b0 de 70 	rcall	800077e8 <memcpy>
8000bb0c:	0e 9b       	mov	r11,r7
8000bb0e:	0c 9c       	mov	r12,r6
8000bb10:	fe b0 fd f8 	rcall	8000b700 <_Bfree>
8000bb14:	06 97       	mov	r7,r3
8000bb16:	e8 c8 ff ff 	sub	r8,r4,-1
8000bb1a:	2f b4       	sub	r4,-5
8000bb1c:	8f 48       	st.w	r7[0x10],r8
8000bb1e:	ee 04 09 25 	st.w	r7[r4<<0x2],r5
8000bb22:	0e 9c       	mov	r12,r7
8000bb24:	d8 32       	popm	r0-r7,pc
8000bb26:	d7 03       	nop

8000bb28 <__pow5mult>:
8000bb28:	d4 31       	pushm	r0-r7,lr
8000bb2a:	14 96       	mov	r6,r10
8000bb2c:	18 97       	mov	r7,r12
8000bb2e:	16 94       	mov	r4,r11
8000bb30:	f1 da c0 02 	bfextu	r8,r10,0x0,0x2
8000bb34:	c0 90       	breq	8000bb46 <__pow5mult+0x1e>
8000bb36:	20 18       	sub	r8,1
8000bb38:	fe c9 d9 7c 	sub	r9,pc,-9860
8000bb3c:	f2 08 03 2a 	ld.w	r10,r9[r8<<0x2]
8000bb40:	30 09       	mov	r9,0
8000bb42:	cb 5f       	rcall	8000baac <__multadd>
8000bb44:	18 94       	mov	r4,r12
8000bb46:	a3 46       	asr	r6,0x2
8000bb48:	c3 40       	breq	8000bbb0 <__pow5mult+0x88>
8000bb4a:	6e 95       	ld.w	r5,r7[0x24]
8000bb4c:	58 05       	cp.w	r5,0
8000bb4e:	c0 91       	brne	8000bb60 <__pow5mult+0x38>
8000bb50:	31 0c       	mov	r12,16
8000bb52:	fe b0 dc 27 	rcall	800073a0 <malloc>
8000bb56:	99 35       	st.w	r12[0xc],r5
8000bb58:	8f 9c       	st.w	r7[0x24],r12
8000bb5a:	99 15       	st.w	r12[0x4],r5
8000bb5c:	99 25       	st.w	r12[0x8],r5
8000bb5e:	99 05       	st.w	r12[0x0],r5
8000bb60:	6e 93       	ld.w	r3,r7[0x24]
8000bb62:	66 25       	ld.w	r5,r3[0x8]
8000bb64:	58 05       	cp.w	r5,0
8000bb66:	c0 c1       	brne	8000bb7e <__pow5mult+0x56>
8000bb68:	e0 6b 02 71 	mov	r11,625
8000bb6c:	0e 9c       	mov	r12,r7
8000bb6e:	c9 7f       	rcall	8000ba9c <__i2b>
8000bb70:	87 2c       	st.w	r3[0x8],r12
8000bb72:	30 08       	mov	r8,0
8000bb74:	18 95       	mov	r5,r12
8000bb76:	99 08       	st.w	r12[0x0],r8
8000bb78:	c0 38       	rjmp	8000bb7e <__pow5mult+0x56>
8000bb7a:	06 9c       	mov	r12,r3
8000bb7c:	18 95       	mov	r5,r12
8000bb7e:	ed b6 00 00 	bld	r6,0x0
8000bb82:	c0 b1       	brne	8000bb98 <__pow5mult+0x70>
8000bb84:	08 9b       	mov	r11,r4
8000bb86:	0a 9a       	mov	r10,r5
8000bb88:	0e 9c       	mov	r12,r7
8000bb8a:	c0 9f       	rcall	8000b99c <__multiply>
8000bb8c:	08 9b       	mov	r11,r4
8000bb8e:	18 93       	mov	r3,r12
8000bb90:	0e 9c       	mov	r12,r7
8000bb92:	06 94       	mov	r4,r3
8000bb94:	fe b0 fd b6 	rcall	8000b700 <_Bfree>
8000bb98:	a1 56       	asr	r6,0x1
8000bb9a:	c0 b0       	breq	8000bbb0 <__pow5mult+0x88>
8000bb9c:	6a 03       	ld.w	r3,r5[0x0]
8000bb9e:	58 03       	cp.w	r3,0
8000bba0:	ce d1       	brne	8000bb7a <__pow5mult+0x52>
8000bba2:	0a 9a       	mov	r10,r5
8000bba4:	0a 9b       	mov	r11,r5
8000bba6:	0e 9c       	mov	r12,r7
8000bba8:	cf ae       	rcall	8000b99c <__multiply>
8000bbaa:	8b 0c       	st.w	r5[0x0],r12
8000bbac:	99 03       	st.w	r12[0x0],r3
8000bbae:	ce 7b       	rjmp	8000bb7c <__pow5mult+0x54>
8000bbb0:	08 9c       	mov	r12,r4
8000bbb2:	d8 32       	popm	r0-r7,pc

8000bbb4 <__isinfd>:
8000bbb4:	14 98       	mov	r8,r10
8000bbb6:	fc 19 7f f0 	movh	r9,0x7ff0
8000bbba:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000bbbe:	f0 0b 11 00 	rsub	r11,r8,0
8000bbc2:	f7 e8 10 08 	or	r8,r11,r8
8000bbc6:	f5 e8 13 f8 	or	r8,r10,r8>>0x1f
8000bbca:	f2 08 01 08 	sub	r8,r9,r8
8000bbce:	f0 0c 11 00 	rsub	r12,r8,0
8000bbd2:	f9 e8 10 08 	or	r8,r12,r8
8000bbd6:	f0 0c 14 1f 	asr	r12,r8,0x1f
8000bbda:	2f fc       	sub	r12,-1
8000bbdc:	5e fc       	retal	r12

8000bbde <__isnand>:
8000bbde:	14 98       	mov	r8,r10
8000bbe0:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000bbe4:	f0 0c 11 00 	rsub	r12,r8,0
8000bbe8:	10 4c       	or	r12,r8
8000bbea:	fc 18 7f f0 	movh	r8,0x7ff0
8000bbee:	f5 ec 13 fc 	or	r12,r10,r12>>0x1f
8000bbf2:	f0 0c 01 0c 	sub	r12,r8,r12
8000bbf6:	bf 9c       	lsr	r12,0x1f
8000bbf8:	5e fc       	retal	r12
8000bbfa:	d7 03       	nop

8000bbfc <__sclose>:
8000bbfc:	d4 01       	pushm	lr
8000bbfe:	96 7b       	ld.sh	r11,r11[0xe]
8000bc00:	c8 2c       	rcall	8000bd04 <_close_r>
8000bc02:	d8 02       	popm	pc

8000bc04 <__sseek>:
8000bc04:	d4 21       	pushm	r4-r7,lr
8000bc06:	16 97       	mov	r7,r11
8000bc08:	96 7b       	ld.sh	r11,r11[0xe]
8000bc0a:	c0 3d       	rcall	8000be10 <_lseek_r>
8000bc0c:	8e 68       	ld.sh	r8,r7[0xc]
8000bc0e:	10 99       	mov	r9,r8
8000bc10:	ad c8       	cbr	r8,0xc
8000bc12:	ad a9       	sbr	r9,0xc
8000bc14:	5b fc       	cp.w	r12,-1
8000bc16:	ef f8 0c 06 	st.heq	r7[0xc],r8
8000bc1a:	ef f9 1c 06 	st.hne	r7[0xc],r9
8000bc1e:	ef fc 1a 15 	st.wne	r7[0x54],r12
8000bc22:	d8 22       	popm	r4-r7,pc

8000bc24 <__swrite>:
8000bc24:	d4 21       	pushm	r4-r7,lr
8000bc26:	96 68       	ld.sh	r8,r11[0xc]
8000bc28:	16 97       	mov	r7,r11
8000bc2a:	14 95       	mov	r5,r10
8000bc2c:	12 94       	mov	r4,r9
8000bc2e:	e2 18 01 00 	andl	r8,0x100,COH
8000bc32:	18 96       	mov	r6,r12
8000bc34:	c0 50       	breq	8000bc3e <__swrite+0x1a>
8000bc36:	30 29       	mov	r9,2
8000bc38:	30 0a       	mov	r10,0
8000bc3a:	96 7b       	ld.sh	r11,r11[0xe]
8000bc3c:	ce ac       	rcall	8000be10 <_lseek_r>
8000bc3e:	8e 68       	ld.sh	r8,r7[0xc]
8000bc40:	ad c8       	cbr	r8,0xc
8000bc42:	08 99       	mov	r9,r4
8000bc44:	0a 9a       	mov	r10,r5
8000bc46:	8e 7b       	ld.sh	r11,r7[0xe]
8000bc48:	0c 9c       	mov	r12,r6
8000bc4a:	ae 68       	st.h	r7[0xc],r8
8000bc4c:	c1 cc       	rcall	8000bc84 <_write_r>
8000bc4e:	d8 22       	popm	r4-r7,pc

8000bc50 <__sread>:
8000bc50:	d4 21       	pushm	r4-r7,lr
8000bc52:	16 97       	mov	r7,r11
8000bc54:	96 7b       	ld.sh	r11,r11[0xe]
8000bc56:	cf 1c       	rcall	8000be38 <_read_r>
8000bc58:	c0 65       	brlt	8000bc64 <__sread+0x14>
8000bc5a:	6f 58       	ld.w	r8,r7[0x54]
8000bc5c:	18 08       	add	r8,r12
8000bc5e:	ef 48 00 54 	st.w	r7[84],r8
8000bc62:	d8 22       	popm	r4-r7,pc
8000bc64:	8e 68       	ld.sh	r8,r7[0xc]
8000bc66:	ad c8       	cbr	r8,0xc
8000bc68:	ae 68       	st.h	r7[0xc],r8
8000bc6a:	d8 22       	popm	r4-r7,pc

8000bc6c <strlen>:
8000bc6c:	30 09       	mov	r9,0
8000bc6e:	18 98       	mov	r8,r12
8000bc70:	c0 28       	rjmp	8000bc74 <strlen+0x8>
8000bc72:	2f f8       	sub	r8,-1
8000bc74:	11 8a       	ld.ub	r10,r8[0x0]
8000bc76:	f2 0a 18 00 	cp.b	r10,r9
8000bc7a:	cf c1       	brne	8000bc72 <strlen+0x6>
8000bc7c:	f0 0c 01 0c 	sub	r12,r8,r12
8000bc80:	5e fc       	retal	r12
8000bc82:	d7 03       	nop

8000bc84 <_write_r>:
8000bc84:	d4 21       	pushm	r4-r7,lr
8000bc86:	16 98       	mov	r8,r11
8000bc88:	18 97       	mov	r7,r12
8000bc8a:	10 9c       	mov	r12,r8
8000bc8c:	30 08       	mov	r8,0
8000bc8e:	14 9b       	mov	r11,r10
8000bc90:	e0 66 65 9c 	mov	r6,26012
8000bc94:	12 9a       	mov	r10,r9
8000bc96:	8d 08       	st.w	r6[0x0],r8
8000bc98:	fe b0 d1 72 	rcall	80005f7c <_write>
8000bc9c:	5b fc       	cp.w	r12,-1
8000bc9e:	c0 51       	brne	8000bca8 <_write_r+0x24>
8000bca0:	6c 08       	ld.w	r8,r6[0x0]
8000bca2:	58 08       	cp.w	r8,0
8000bca4:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000bca8:	d8 22       	popm	r4-r7,pc
8000bcaa:	d7 03       	nop

8000bcac <_calloc_r>:
8000bcac:	d4 21       	pushm	r4-r7,lr
8000bcae:	f4 0b 02 4b 	mul	r11,r10,r11
8000bcb2:	fe b0 db 7f 	rcall	800073b0 <_malloc_r>
8000bcb6:	18 97       	mov	r7,r12
8000bcb8:	c2 30       	breq	8000bcfe <_calloc_r+0x52>
8000bcba:	f8 fa ff fc 	ld.w	r10,r12[-4]
8000bcbe:	e0 1a ff fc 	andl	r10,0xfffc
8000bcc2:	20 4a       	sub	r10,4
8000bcc4:	e0 4a 00 24 	cp.w	r10,36
8000bcc8:	e0 8b 00 18 	brhi	8000bcf8 <_calloc_r+0x4c>
8000bccc:	18 98       	mov	r8,r12
8000bcce:	59 3a       	cp.w	r10,19
8000bcd0:	e0 88 00 0f 	brls	8000bcee <_calloc_r+0x42>
8000bcd4:	30 09       	mov	r9,0
8000bcd6:	10 a9       	st.w	r8++,r9
8000bcd8:	10 a9       	st.w	r8++,r9
8000bcda:	59 ba       	cp.w	r10,27
8000bcdc:	e0 88 00 09 	brls	8000bcee <_calloc_r+0x42>
8000bce0:	10 a9       	st.w	r8++,r9
8000bce2:	10 a9       	st.w	r8++,r9
8000bce4:	e0 4a 00 24 	cp.w	r10,36
8000bce8:	c0 31       	brne	8000bcee <_calloc_r+0x42>
8000bcea:	10 a9       	st.w	r8++,r9
8000bcec:	10 a9       	st.w	r8++,r9
8000bcee:	30 09       	mov	r9,0
8000bcf0:	10 a9       	st.w	r8++,r9
8000bcf2:	91 19       	st.w	r8[0x4],r9
8000bcf4:	91 09       	st.w	r8[0x0],r9
8000bcf6:	c0 48       	rjmp	8000bcfe <_calloc_r+0x52>
8000bcf8:	30 0b       	mov	r11,0
8000bcfa:	fe b0 de 1b 	rcall	80007930 <memset>
8000bcfe:	0e 9c       	mov	r12,r7
8000bd00:	d8 22       	popm	r4-r7,pc
8000bd02:	d7 03       	nop

8000bd04 <_close_r>:
8000bd04:	d4 21       	pushm	r4-r7,lr
8000bd06:	30 08       	mov	r8,0
8000bd08:	18 97       	mov	r7,r12
8000bd0a:	e0 66 65 9c 	mov	r6,26012
8000bd0e:	16 9c       	mov	r12,r11
8000bd10:	8d 08       	st.w	r6[0x0],r8
8000bd12:	fe b0 df b5 	rcall	80007c7c <_close>
8000bd16:	5b fc       	cp.w	r12,-1
8000bd18:	c0 51       	brne	8000bd22 <_close_r+0x1e>
8000bd1a:	6c 08       	ld.w	r8,r6[0x0]
8000bd1c:	58 08       	cp.w	r8,0
8000bd1e:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000bd22:	d8 22       	popm	r4-r7,pc

8000bd24 <_fclose_r>:
8000bd24:	d4 21       	pushm	r4-r7,lr
8000bd26:	18 96       	mov	r6,r12
8000bd28:	16 97       	mov	r7,r11
8000bd2a:	58 0b       	cp.w	r11,0
8000bd2c:	c0 31       	brne	8000bd32 <_fclose_r+0xe>
8000bd2e:	16 95       	mov	r5,r11
8000bd30:	c5 38       	rjmp	8000bdd6 <_fclose_r+0xb2>
8000bd32:	fe b0 f8 a9 	rcall	8000ae84 <__sfp_lock_acquire>
8000bd36:	58 06       	cp.w	r6,0
8000bd38:	c0 70       	breq	8000bd46 <_fclose_r+0x22>
8000bd3a:	6c 68       	ld.w	r8,r6[0x18]
8000bd3c:	58 08       	cp.w	r8,0
8000bd3e:	c0 41       	brne	8000bd46 <_fclose_r+0x22>
8000bd40:	0c 9c       	mov	r12,r6
8000bd42:	fe b0 f8 f3 	rcall	8000af28 <__sinit>
8000bd46:	fe c8 dc 2e 	sub	r8,pc,-9170
8000bd4a:	10 37       	cp.w	r7,r8
8000bd4c:	c0 31       	brne	8000bd52 <_fclose_r+0x2e>
8000bd4e:	6c 07       	ld.w	r7,r6[0x0]
8000bd50:	c0 c8       	rjmp	8000bd68 <_fclose_r+0x44>
8000bd52:	fe c8 dc 1a 	sub	r8,pc,-9190
8000bd56:	10 37       	cp.w	r7,r8
8000bd58:	c0 31       	brne	8000bd5e <_fclose_r+0x3a>
8000bd5a:	6c 17       	ld.w	r7,r6[0x4]
8000bd5c:	c0 68       	rjmp	8000bd68 <_fclose_r+0x44>
8000bd5e:	fe c8 dc 06 	sub	r8,pc,-9210
8000bd62:	10 37       	cp.w	r7,r8
8000bd64:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000bd68:	8e 69       	ld.sh	r9,r7[0xc]
8000bd6a:	30 08       	mov	r8,0
8000bd6c:	f0 09 19 00 	cp.h	r9,r8
8000bd70:	c0 51       	brne	8000bd7a <_fclose_r+0x56>
8000bd72:	fe b0 f8 8a 	rcall	8000ae86 <__sfp_lock_release>
8000bd76:	30 05       	mov	r5,0
8000bd78:	c2 f8       	rjmp	8000bdd6 <_fclose_r+0xb2>
8000bd7a:	0e 9b       	mov	r11,r7
8000bd7c:	0c 9c       	mov	r12,r6
8000bd7e:	fe b0 f7 fd 	rcall	8000ad78 <_fflush_r>
8000bd82:	6e c8       	ld.w	r8,r7[0x30]
8000bd84:	18 95       	mov	r5,r12
8000bd86:	58 08       	cp.w	r8,0
8000bd88:	c0 60       	breq	8000bd94 <_fclose_r+0x70>
8000bd8a:	6e 8b       	ld.w	r11,r7[0x20]
8000bd8c:	0c 9c       	mov	r12,r6
8000bd8e:	5d 18       	icall	r8
8000bd90:	f9 b5 05 ff 	movlt	r5,-1
8000bd94:	8e 68       	ld.sh	r8,r7[0xc]
8000bd96:	ed b8 00 07 	bld	r8,0x7
8000bd9a:	c0 51       	brne	8000bda4 <_fclose_r+0x80>
8000bd9c:	6e 4b       	ld.w	r11,r7[0x10]
8000bd9e:	0c 9c       	mov	r12,r6
8000bda0:	fe b0 f9 5e 	rcall	8000b05c <_free_r>
8000bda4:	6e db       	ld.w	r11,r7[0x34]
8000bda6:	58 0b       	cp.w	r11,0
8000bda8:	c0 a0       	breq	8000bdbc <_fclose_r+0x98>
8000bdaa:	ee c8 ff bc 	sub	r8,r7,-68
8000bdae:	10 3b       	cp.w	r11,r8
8000bdb0:	c0 40       	breq	8000bdb8 <_fclose_r+0x94>
8000bdb2:	0c 9c       	mov	r12,r6
8000bdb4:	fe b0 f9 54 	rcall	8000b05c <_free_r>
8000bdb8:	30 08       	mov	r8,0
8000bdba:	8f d8       	st.w	r7[0x34],r8
8000bdbc:	6f 2b       	ld.w	r11,r7[0x48]
8000bdbe:	58 0b       	cp.w	r11,0
8000bdc0:	c0 70       	breq	8000bdce <_fclose_r+0xaa>
8000bdc2:	0c 9c       	mov	r12,r6
8000bdc4:	fe b0 f9 4c 	rcall	8000b05c <_free_r>
8000bdc8:	30 08       	mov	r8,0
8000bdca:	ef 48 00 48 	st.w	r7[72],r8
8000bdce:	30 08       	mov	r8,0
8000bdd0:	ae 68       	st.h	r7[0xc],r8
8000bdd2:	fe b0 f8 5a 	rcall	8000ae86 <__sfp_lock_release>
8000bdd6:	0a 9c       	mov	r12,r5
8000bdd8:	d8 22       	popm	r4-r7,pc
8000bdda:	d7 03       	nop

8000bddc <fclose>:
8000bddc:	d4 01       	pushm	lr
8000bdde:	e0 68 0a 3c 	mov	r8,2620
8000bde2:	18 9b       	mov	r11,r12
8000bde4:	70 0c       	ld.w	r12,r8[0x0]
8000bde6:	c9 ff       	rcall	8000bd24 <_fclose_r>
8000bde8:	d8 02       	popm	pc
8000bdea:	d7 03       	nop

8000bdec <_fstat_r>:
8000bdec:	d4 21       	pushm	r4-r7,lr
8000bdee:	16 98       	mov	r8,r11
8000bdf0:	18 97       	mov	r7,r12
8000bdf2:	10 9c       	mov	r12,r8
8000bdf4:	30 08       	mov	r8,0
8000bdf6:	e0 66 65 9c 	mov	r6,26012
8000bdfa:	14 9b       	mov	r11,r10
8000bdfc:	8d 08       	st.w	r6[0x0],r8
8000bdfe:	fe b0 df 67 	rcall	80007ccc <_fstat>
8000be02:	5b fc       	cp.w	r12,-1
8000be04:	c0 51       	brne	8000be0e <_fstat_r+0x22>
8000be06:	6c 08       	ld.w	r8,r6[0x0]
8000be08:	58 08       	cp.w	r8,0
8000be0a:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000be0e:	d8 22       	popm	r4-r7,pc

8000be10 <_lseek_r>:
8000be10:	d4 21       	pushm	r4-r7,lr
8000be12:	16 98       	mov	r8,r11
8000be14:	18 97       	mov	r7,r12
8000be16:	10 9c       	mov	r12,r8
8000be18:	30 08       	mov	r8,0
8000be1a:	14 9b       	mov	r11,r10
8000be1c:	e0 66 65 9c 	mov	r6,26012
8000be20:	12 9a       	mov	r10,r9
8000be22:	8d 08       	st.w	r6[0x0],r8
8000be24:	fe b0 df 36 	rcall	80007c90 <_lseek>
8000be28:	5b fc       	cp.w	r12,-1
8000be2a:	c0 51       	brne	8000be34 <_lseek_r+0x24>
8000be2c:	6c 08       	ld.w	r8,r6[0x0]
8000be2e:	58 08       	cp.w	r8,0
8000be30:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000be34:	d8 22       	popm	r4-r7,pc
8000be36:	d7 03       	nop

8000be38 <_read_r>:
8000be38:	d4 21       	pushm	r4-r7,lr
8000be3a:	16 98       	mov	r8,r11
8000be3c:	18 97       	mov	r7,r12
8000be3e:	10 9c       	mov	r12,r8
8000be40:	30 08       	mov	r8,0
8000be42:	14 9b       	mov	r11,r10
8000be44:	e0 66 65 9c 	mov	r6,26012
8000be48:	12 9a       	mov	r10,r9
8000be4a:	8d 08       	st.w	r6[0x0],r8
8000be4c:	fe b0 d0 78 	rcall	80005f3c <_read>
8000be50:	5b fc       	cp.w	r12,-1
8000be52:	c0 51       	brne	8000be5c <_read_r+0x24>
8000be54:	6c 08       	ld.w	r8,r6[0x0]
8000be56:	58 08       	cp.w	r8,0
8000be58:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000be5c:	d8 22       	popm	r4-r7,pc
8000be5e:	d7 03       	nop

8000be60 <__avr32_f64_mul>:
8000be60:	f5 eb 10 1c 	or	r12,r10,r11<<0x1
8000be64:	e0 80 00 dc 	breq	8000c01c <__avr32_f64_mul_op1_zero>
8000be68:	d4 21       	pushm	r4-r7,lr
8000be6a:	f7 e9 20 0e 	eor	lr,r11,r9
8000be6e:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000be72:	30 15       	mov	r5,1
8000be74:	c4 30       	breq	8000befa <__avr32_f64_mul_op1_subnormal>
8000be76:	ab 6b       	lsl	r11,0xa
8000be78:	f7 ea 13 6b 	or	r11,r11,r10>>0x16
8000be7c:	ab 6a       	lsl	r10,0xa
8000be7e:	f7 d5 d3 c2 	bfins	r11,r5,0x1e,0x2
8000be82:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000be86:	c5 c0       	breq	8000bf3e <__avr32_f64_mul_op2_subnormal>
8000be88:	a1 78       	lsl	r8,0x1
8000be8a:	5c f9       	rol	r9
8000be8c:	f3 d5 d2 ab 	bfins	r9,r5,0x15,0xb
8000be90:	e0 47 07 ff 	cp.w	r7,2047
8000be94:	c7 70       	breq	8000bf82 <__avr32_f64_mul_op_nan_or_inf>
8000be96:	e0 46 07 ff 	cp.w	r6,2047
8000be9a:	c7 40       	breq	8000bf82 <__avr32_f64_mul_op_nan_or_inf>
8000be9c:	ee 06 00 0c 	add	r12,r7,r6
8000bea0:	e0 2c 03 fe 	sub	r12,1022
8000bea4:	f6 08 06 44 	mulu.d	r4,r11,r8
8000bea8:	f4 09 07 44 	macu.d	r4,r10,r9
8000beac:	f4 08 06 46 	mulu.d	r6,r10,r8
8000beb0:	f6 09 06 4a 	mulu.d	r10,r11,r9
8000beb4:	08 07       	add	r7,r4
8000beb6:	f4 05 00 4a 	adc	r10,r10,r5
8000beba:	5c 0b       	acr	r11
8000bebc:	ed bb 00 14 	bld	r11,0x14
8000bec0:	c0 50       	breq	8000beca <__avr32_f64_mul+0x6a>
8000bec2:	a1 77       	lsl	r7,0x1
8000bec4:	5c fa       	rol	r10
8000bec6:	5c fb       	rol	r11
8000bec8:	20 1c       	sub	r12,1
8000beca:	58 0c       	cp.w	r12,0
8000becc:	e0 8a 00 6f 	brle	8000bfaa <__avr32_f64_mul_res_subnormal>
8000bed0:	e0 4c 07 ff 	cp.w	r12,2047
8000bed4:	e0 84 00 9c 	brge	8000c00c <__avr32_f64_mul_res_inf>
8000bed8:	f7 dc d2 8b 	bfins	r11,r12,0x14,0xb
8000bedc:	ed ea 11 f6 	or	r6,r6,r10<<0x1f
8000bee0:	ef e6 12 17 	or	r7,r7,r6>>0x1
8000bee4:	ee 17 80 00 	eorh	r7,0x8000
8000bee8:	f1 b7 04 20 	satu	r7,0x1
8000beec:	0e 0a       	add	r10,r7
8000beee:	5c 0b       	acr	r11
8000bef0:	ed be 00 1f 	bld	lr,0x1f
8000bef4:	ef bb 00 1f 	bst	r11,0x1f
8000bef8:	d8 22       	popm	r4-r7,pc

8000befa <__avr32_f64_mul_op1_subnormal>:
8000befa:	e4 1b 00 0f 	andh	r11,0xf
8000befe:	f4 0c 12 00 	clz	r12,r10
8000bf02:	f6 06 12 00 	clz	r6,r11
8000bf06:	f7 bc 03 e1 	sublo	r12,-31
8000bf0a:	f8 06 17 30 	movlo	r6,r12
8000bf0e:	f7 b6 02 01 	subhs	r6,1
8000bf12:	e0 46 00 20 	cp.w	r6,32
8000bf16:	c0 d4       	brge	8000bf30 <__avr32_f64_mul_op1_subnormal+0x36>
8000bf18:	ec 0c 11 20 	rsub	r12,r6,32
8000bf1c:	f6 06 09 4b 	lsl	r11,r11,r6
8000bf20:	f4 0c 0a 4c 	lsr	r12,r10,r12
8000bf24:	18 4b       	or	r11,r12
8000bf26:	f4 06 09 4a 	lsl	r10,r10,r6
8000bf2a:	20 b6       	sub	r6,11
8000bf2c:	0c 17       	sub	r7,r6
8000bf2e:	ca ab       	rjmp	8000be82 <__avr32_f64_mul+0x22>
8000bf30:	f4 06 09 4b 	lsl	r11,r10,r6
8000bf34:	c6 40       	breq	8000bffc <__avr32_f64_mul_res_zero>
8000bf36:	30 0a       	mov	r10,0
8000bf38:	20 b6       	sub	r6,11
8000bf3a:	0c 17       	sub	r7,r6
8000bf3c:	ca 3b       	rjmp	8000be82 <__avr32_f64_mul+0x22>

8000bf3e <__avr32_f64_mul_op2_subnormal>:
8000bf3e:	e4 19 00 0f 	andh	r9,0xf
8000bf42:	f0 0c 12 00 	clz	r12,r8
8000bf46:	f2 05 12 00 	clz	r5,r9
8000bf4a:	f7 bc 03 ea 	sublo	r12,-22
8000bf4e:	f8 05 17 30 	movlo	r5,r12
8000bf52:	f7 b5 02 0a 	subhs	r5,10
8000bf56:	e0 45 00 20 	cp.w	r5,32
8000bf5a:	c0 d4       	brge	8000bf74 <__avr32_f64_mul_op2_subnormal+0x36>
8000bf5c:	ea 0c 11 20 	rsub	r12,r5,32
8000bf60:	f2 05 09 49 	lsl	r9,r9,r5
8000bf64:	f0 0c 0a 4c 	lsr	r12,r8,r12
8000bf68:	18 49       	or	r9,r12
8000bf6a:	f0 05 09 48 	lsl	r8,r8,r5
8000bf6e:	20 25       	sub	r5,2
8000bf70:	0a 16       	sub	r6,r5
8000bf72:	c8 fb       	rjmp	8000be90 <__avr32_f64_mul+0x30>
8000bf74:	f0 05 09 49 	lsl	r9,r8,r5
8000bf78:	c4 20       	breq	8000bffc <__avr32_f64_mul_res_zero>
8000bf7a:	30 08       	mov	r8,0
8000bf7c:	20 25       	sub	r5,2
8000bf7e:	0a 16       	sub	r6,r5
8000bf80:	c8 8b       	rjmp	8000be90 <__avr32_f64_mul+0x30>

8000bf82 <__avr32_f64_mul_op_nan_or_inf>:
8000bf82:	e4 19 00 0f 	andh	r9,0xf
8000bf86:	e4 1b 00 0f 	andh	r11,0xf
8000bf8a:	14 4b       	or	r11,r10
8000bf8c:	10 49       	or	r9,r8
8000bf8e:	e0 47 07 ff 	cp.w	r7,2047
8000bf92:	c0 91       	brne	8000bfa4 <__avr32_f64_mul_op1_not_naninf>
8000bf94:	58 0b       	cp.w	r11,0
8000bf96:	c3 81       	brne	8000c006 <__avr32_f64_mul_res_nan>
8000bf98:	e0 46 07 ff 	cp.w	r6,2047
8000bf9c:	c3 81       	brne	8000c00c <__avr32_f64_mul_res_inf>
8000bf9e:	58 09       	cp.w	r9,0
8000bfa0:	c3 60       	breq	8000c00c <__avr32_f64_mul_res_inf>
8000bfa2:	c3 28       	rjmp	8000c006 <__avr32_f64_mul_res_nan>

8000bfa4 <__avr32_f64_mul_op1_not_naninf>:
8000bfa4:	58 09       	cp.w	r9,0
8000bfa6:	c3 30       	breq	8000c00c <__avr32_f64_mul_res_inf>
8000bfa8:	c2 f8       	rjmp	8000c006 <__avr32_f64_mul_res_nan>

8000bfaa <__avr32_f64_mul_res_subnormal>:
8000bfaa:	5c 3c       	neg	r12
8000bfac:	2f fc       	sub	r12,-1
8000bfae:	f1 bc 04 c0 	satu	r12,0x6
8000bfb2:	e0 4c 00 20 	cp.w	r12,32
8000bfb6:	c1 14       	brge	8000bfd8 <__avr32_f64_mul_res_subnormal+0x2e>
8000bfb8:	f8 08 11 20 	rsub	r8,r12,32
8000bfbc:	0e 46       	or	r6,r7
8000bfbe:	ee 0c 0a 47 	lsr	r7,r7,r12
8000bfc2:	f4 08 09 49 	lsl	r9,r10,r8
8000bfc6:	12 47       	or	r7,r9
8000bfc8:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000bfcc:	f6 08 09 49 	lsl	r9,r11,r8
8000bfd0:	12 4a       	or	r10,r9
8000bfd2:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000bfd6:	c8 3b       	rjmp	8000bedc <__avr32_f64_mul+0x7c>
8000bfd8:	f8 08 11 20 	rsub	r8,r12,32
8000bfdc:	f9 b9 00 00 	moveq	r9,0
8000bfe0:	c0 30       	breq	8000bfe6 <__avr32_f64_mul_res_subnormal+0x3c>
8000bfe2:	f6 08 09 49 	lsl	r9,r11,r8
8000bfe6:	0e 46       	or	r6,r7
8000bfe8:	ed ea 10 16 	or	r6,r6,r10<<0x1
8000bfec:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000bff0:	f3 ea 10 07 	or	r7,r9,r10
8000bff4:	f6 0c 0a 4a 	lsr	r10,r11,r12
8000bff8:	30 0b       	mov	r11,0
8000bffa:	c7 1b       	rjmp	8000bedc <__avr32_f64_mul+0x7c>

8000bffc <__avr32_f64_mul_res_zero>:
8000bffc:	1c 9b       	mov	r11,lr
8000bffe:	e6 1b 80 00 	andh	r11,0x8000,COH
8000c002:	30 0a       	mov	r10,0
8000c004:	d8 22       	popm	r4-r7,pc

8000c006 <__avr32_f64_mul_res_nan>:
8000c006:	3f fb       	mov	r11,-1
8000c008:	3f fa       	mov	r10,-1
8000c00a:	d8 22       	popm	r4-r7,pc

8000c00c <__avr32_f64_mul_res_inf>:
8000c00c:	f0 6b 00 00 	mov	r11,-1048576
8000c010:	ed be 00 1f 	bld	lr,0x1f
8000c014:	ef bb 00 1f 	bst	r11,0x1f
8000c018:	30 0a       	mov	r10,0
8000c01a:	d8 22       	popm	r4-r7,pc

8000c01c <__avr32_f64_mul_op1_zero>:
8000c01c:	f7 e9 20 0b 	eor	r11,r11,r9
8000c020:	e6 1b 80 00 	andh	r11,0x8000,COH
8000c024:	f9 d9 c2 8b 	bfextu	r12,r9,0x14,0xb
8000c028:	e0 4c 07 ff 	cp.w	r12,2047
8000c02c:	5e 1c       	retne	r12
8000c02e:	3f fa       	mov	r10,-1
8000c030:	3f fb       	mov	r11,-1
8000c032:	5e fc       	retal	r12

8000c034 <__avr32_f64_sub_from_add>:
8000c034:	ee 19 80 00 	eorh	r9,0x8000

8000c038 <__avr32_f64_sub>:
8000c038:	f7 e9 20 0c 	eor	r12,r11,r9
8000c03c:	e0 86 00 ca 	brmi	8000c1d0 <__avr32_f64_add_from_sub>
8000c040:	eb cd 40 e0 	pushm	r5-r7,lr
8000c044:	16 9c       	mov	r12,r11
8000c046:	e6 1c 80 00 	andh	r12,0x8000,COH
8000c04a:	bf db       	cbr	r11,0x1f
8000c04c:	bf d9       	cbr	r9,0x1f
8000c04e:	10 3a       	cp.w	r10,r8
8000c050:	f2 0b 13 00 	cpc	r11,r9
8000c054:	c0 92       	brcc	8000c066 <__avr32_f64_sub+0x2e>
8000c056:	16 97       	mov	r7,r11
8000c058:	12 9b       	mov	r11,r9
8000c05a:	0e 99       	mov	r9,r7
8000c05c:	14 97       	mov	r7,r10
8000c05e:	10 9a       	mov	r10,r8
8000c060:	0e 98       	mov	r8,r7
8000c062:	ee 1c 80 00 	eorh	r12,0x8000
8000c066:	f6 07 16 14 	lsr	r7,r11,0x14
8000c06a:	ab 7b       	lsl	r11,0xb
8000c06c:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000c070:	ab 7a       	lsl	r10,0xb
8000c072:	bf bb       	sbr	r11,0x1f
8000c074:	f2 06 16 14 	lsr	r6,r9,0x14
8000c078:	c4 40       	breq	8000c100 <__avr32_f64_sub_opL_subnormal>
8000c07a:	ab 79       	lsl	r9,0xb
8000c07c:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000c080:	ab 78       	lsl	r8,0xb
8000c082:	bf b9       	sbr	r9,0x1f

8000c084 <__avr32_f64_sub_opL_subnormal_done>:
8000c084:	e0 47 07 ff 	cp.w	r7,2047
8000c088:	c4 f0       	breq	8000c126 <__avr32_f64_sub_opH_nan_or_inf>
8000c08a:	0e 26       	rsub	r6,r7
8000c08c:	c1 20       	breq	8000c0b0 <__avr32_f64_sub_shift_done>
8000c08e:	ec 05 11 20 	rsub	r5,r6,32
8000c092:	e0 46 00 20 	cp.w	r6,32
8000c096:	c7 c2       	brcc	8000c18e <__avr32_f64_sub_longshift>
8000c098:	f0 05 09 4e 	lsl	lr,r8,r5
8000c09c:	f2 05 09 45 	lsl	r5,r9,r5
8000c0a0:	f0 06 0a 48 	lsr	r8,r8,r6
8000c0a4:	f2 06 0a 49 	lsr	r9,r9,r6
8000c0a8:	0a 48       	or	r8,r5
8000c0aa:	58 0e       	cp.w	lr,0
8000c0ac:	5f 1e       	srne	lr
8000c0ae:	1c 48       	or	r8,lr

8000c0b0 <__avr32_f64_sub_shift_done>:
8000c0b0:	10 1a       	sub	r10,r8
8000c0b2:	f6 09 01 4b 	sbc	r11,r11,r9
8000c0b6:	f6 06 12 00 	clz	r6,r11
8000c0ba:	c0 e0       	breq	8000c0d6 <__avr32_f64_sub_longnormalize_done>
8000c0bc:	c7 83       	brcs	8000c1ac <__avr32_f64_sub_longnormalize>
8000c0be:	ec 0e 11 20 	rsub	lr,r6,32
8000c0c2:	f6 06 09 4b 	lsl	r11,r11,r6
8000c0c6:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000c0ca:	1c 4b       	or	r11,lr
8000c0cc:	f4 06 09 4a 	lsl	r10,r10,r6
8000c0d0:	0c 17       	sub	r7,r6
8000c0d2:	e0 8a 00 39 	brle	8000c144 <__avr32_f64_sub_subnormal_result>

8000c0d6 <__avr32_f64_sub_longnormalize_done>:
8000c0d6:	f4 09 15 15 	lsl	r9,r10,0x15
8000c0da:	ab 9a       	lsr	r10,0xb
8000c0dc:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000c0e0:	ab 9b       	lsr	r11,0xb
8000c0e2:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000c0e6:	18 4b       	or	r11,r12

8000c0e8 <__avr32_f64_sub_round>:
8000c0e8:	fc 17 80 00 	movh	r7,0x8000
8000c0ec:	ed ba 00 00 	bld	r10,0x0
8000c0f0:	f7 b7 01 ff 	subne	r7,-1
8000c0f4:	0e 39       	cp.w	r9,r7
8000c0f6:	5f 29       	srhs	r9
8000c0f8:	12 0a       	add	r10,r9
8000c0fa:	5c 0b       	acr	r11
8000c0fc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c100 <__avr32_f64_sub_opL_subnormal>:
8000c100:	ab 79       	lsl	r9,0xb
8000c102:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000c106:	ab 78       	lsl	r8,0xb
8000c108:	f3 e8 10 0e 	or	lr,r9,r8
8000c10c:	f9 b6 01 01 	movne	r6,1
8000c110:	ee 0e 11 00 	rsub	lr,r7,0
8000c114:	f9 b7 00 01 	moveq	r7,1
8000c118:	ef bb 00 1f 	bst	r11,0x1f
8000c11c:	f7 ea 10 0e 	or	lr,r11,r10
8000c120:	f9 b7 00 00 	moveq	r7,0
8000c124:	cb 0b       	rjmp	8000c084 <__avr32_f64_sub_opL_subnormal_done>

8000c126 <__avr32_f64_sub_opH_nan_or_inf>:
8000c126:	bf db       	cbr	r11,0x1f
8000c128:	f7 ea 10 0e 	or	lr,r11,r10
8000c12c:	c0 81       	brne	8000c13c <__avr32_f64_sub_return_nan>
8000c12e:	e0 46 07 ff 	cp.w	r6,2047
8000c132:	c0 50       	breq	8000c13c <__avr32_f64_sub_return_nan>
8000c134:	f9 e7 11 4b 	or	r11,r12,r7<<0x14
8000c138:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c13c <__avr32_f64_sub_return_nan>:
8000c13c:	3f fa       	mov	r10,-1
8000c13e:	3f fb       	mov	r11,-1
8000c140:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c144 <__avr32_f64_sub_subnormal_result>:
8000c144:	5c 37       	neg	r7
8000c146:	2f f7       	sub	r7,-1
8000c148:	f1 b7 04 c0 	satu	r7,0x6
8000c14c:	e0 47 00 20 	cp.w	r7,32
8000c150:	c1 14       	brge	8000c172 <__avr32_f64_sub_subnormal_result+0x2e>
8000c152:	ee 08 11 20 	rsub	r8,r7,32
8000c156:	f4 08 09 49 	lsl	r9,r10,r8
8000c15a:	5f 16       	srne	r6
8000c15c:	f4 07 0a 4a 	lsr	r10,r10,r7
8000c160:	0c 4a       	or	r10,r6
8000c162:	f6 08 09 49 	lsl	r9,r11,r8
8000c166:	f5 e9 10 0a 	or	r10,r10,r9
8000c16a:	f4 07 0a 4b 	lsr	r11,r10,r7
8000c16e:	30 07       	mov	r7,0
8000c170:	cb 3b       	rjmp	8000c0d6 <__avr32_f64_sub_longnormalize_done>
8000c172:	ee 08 11 40 	rsub	r8,r7,64
8000c176:	f6 08 09 49 	lsl	r9,r11,r8
8000c17a:	14 49       	or	r9,r10
8000c17c:	5f 16       	srne	r6
8000c17e:	f6 07 0a 4a 	lsr	r10,r11,r7
8000c182:	0c 4a       	or	r10,r6
8000c184:	30 0b       	mov	r11,0
8000c186:	30 07       	mov	r7,0
8000c188:	ca 7b       	rjmp	8000c0d6 <__avr32_f64_sub_longnormalize_done>
8000c18a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c18e <__avr32_f64_sub_longshift>:
8000c18e:	f1 b6 04 c0 	satu	r6,0x6
8000c192:	f0 0e 17 00 	moveq	lr,r8
8000c196:	c0 40       	breq	8000c19e <__avr32_f64_sub_longshift+0x10>
8000c198:	f2 05 09 4e 	lsl	lr,r9,r5
8000c19c:	10 4e       	or	lr,r8
8000c19e:	f2 06 0a 48 	lsr	r8,r9,r6
8000c1a2:	30 09       	mov	r9,0
8000c1a4:	58 0e       	cp.w	lr,0
8000c1a6:	5f 1e       	srne	lr
8000c1a8:	1c 48       	or	r8,lr
8000c1aa:	c8 3b       	rjmp	8000c0b0 <__avr32_f64_sub_shift_done>

8000c1ac <__avr32_f64_sub_longnormalize>:
8000c1ac:	f4 06 12 00 	clz	r6,r10
8000c1b0:	f9 b7 03 00 	movlo	r7,0
8000c1b4:	f9 b6 03 00 	movlo	r6,0
8000c1b8:	f9 bc 03 00 	movlo	r12,0
8000c1bc:	f7 b6 02 e0 	subhs	r6,-32
8000c1c0:	f4 06 09 4b 	lsl	r11,r10,r6
8000c1c4:	30 0a       	mov	r10,0
8000c1c6:	0c 17       	sub	r7,r6
8000c1c8:	fe 9a ff be 	brle	8000c144 <__avr32_f64_sub_subnormal_result>
8000c1cc:	c8 5b       	rjmp	8000c0d6 <__avr32_f64_sub_longnormalize_done>
8000c1ce:	d7 03       	nop

8000c1d0 <__avr32_f64_add_from_sub>:
8000c1d0:	ee 19 80 00 	eorh	r9,0x8000

8000c1d4 <__avr32_f64_add>:
8000c1d4:	f7 e9 20 0c 	eor	r12,r11,r9
8000c1d8:	fe 96 ff 2e 	brmi	8000c034 <__avr32_f64_sub_from_add>
8000c1dc:	eb cd 40 e0 	pushm	r5-r7,lr
8000c1e0:	16 9c       	mov	r12,r11
8000c1e2:	e6 1c 80 00 	andh	r12,0x8000,COH
8000c1e6:	bf db       	cbr	r11,0x1f
8000c1e8:	bf d9       	cbr	r9,0x1f
8000c1ea:	12 3b       	cp.w	r11,r9
8000c1ec:	c0 72       	brcc	8000c1fa <__avr32_f64_add+0x26>
8000c1ee:	16 97       	mov	r7,r11
8000c1f0:	12 9b       	mov	r11,r9
8000c1f2:	0e 99       	mov	r9,r7
8000c1f4:	14 97       	mov	r7,r10
8000c1f6:	10 9a       	mov	r10,r8
8000c1f8:	0e 98       	mov	r8,r7
8000c1fa:	30 0e       	mov	lr,0
8000c1fc:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000c200:	f7 db c0 14 	bfextu	r11,r11,0x0,0x14
8000c204:	b5 ab       	sbr	r11,0x14
8000c206:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000c20a:	c6 20       	breq	8000c2ce <__avr32_f64_add_op2_subnormal>
8000c20c:	f3 d9 c0 14 	bfextu	r9,r9,0x0,0x14
8000c210:	b5 a9       	sbr	r9,0x14
8000c212:	e0 47 07 ff 	cp.w	r7,2047
8000c216:	c2 80       	breq	8000c266 <__avr32_f64_add_opH_nan_or_inf>
8000c218:	0e 26       	rsub	r6,r7
8000c21a:	c1 20       	breq	8000c23e <__avr32_f64_add_shift_done>
8000c21c:	e0 46 00 36 	cp.w	r6,54
8000c220:	c1 52       	brcc	8000c24a <__avr32_f64_add_res_of_done>
8000c222:	ec 05 11 20 	rsub	r5,r6,32
8000c226:	e0 46 00 20 	cp.w	r6,32
8000c22a:	c3 52       	brcc	8000c294 <__avr32_f64_add_longshift>
8000c22c:	f0 05 09 4e 	lsl	lr,r8,r5
8000c230:	f2 05 09 45 	lsl	r5,r9,r5
8000c234:	f0 06 0a 48 	lsr	r8,r8,r6
8000c238:	f2 06 0a 49 	lsr	r9,r9,r6
8000c23c:	0a 48       	or	r8,r5

8000c23e <__avr32_f64_add_shift_done>:
8000c23e:	10 0a       	add	r10,r8
8000c240:	f6 09 00 4b 	adc	r11,r11,r9
8000c244:	ed bb 00 15 	bld	r11,0x15
8000c248:	c3 40       	breq	8000c2b0 <__avr32_f64_add_res_of>

8000c24a <__avr32_f64_add_res_of_done>:
8000c24a:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000c24e:	18 4b       	or	r11,r12

8000c250 <__avr32_f64_add_round>:
8000c250:	f9 da c0 01 	bfextu	r12,r10,0x0,0x1
8000c254:	18 4e       	or	lr,r12
8000c256:	ee 1e 80 00 	eorh	lr,0x8000
8000c25a:	f1 be 04 20 	satu	lr,0x1
8000c25e:	1c 0a       	add	r10,lr
8000c260:	5c 0b       	acr	r11
8000c262:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c266 <__avr32_f64_add_opH_nan_or_inf>:
8000c266:	b5 cb       	cbr	r11,0x14
8000c268:	f7 ea 10 0e 	or	lr,r11,r10
8000c26c:	c1 01       	brne	8000c28c <__avr32_f64_add_return_nan>
8000c26e:	e0 46 07 ff 	cp.w	r6,2047
8000c272:	c0 30       	breq	8000c278 <__avr32_f64_add_opL_nan_or_inf>
8000c274:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c278 <__avr32_f64_add_opL_nan_or_inf>:
8000c278:	b5 c9       	cbr	r9,0x14
8000c27a:	f3 e8 10 0e 	or	lr,r9,r8
8000c27e:	c0 71       	brne	8000c28c <__avr32_f64_add_return_nan>
8000c280:	30 0a       	mov	r10,0
8000c282:	fc 1b 7f f0 	movh	r11,0x7ff0
8000c286:	18 4b       	or	r11,r12
8000c288:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c28c <__avr32_f64_add_return_nan>:
8000c28c:	3f fa       	mov	r10,-1
8000c28e:	3f fb       	mov	r11,-1
8000c290:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c294 <__avr32_f64_add_longshift>:
8000c294:	f1 b6 04 c0 	satu	r6,0x6
8000c298:	f0 0e 17 00 	moveq	lr,r8
8000c29c:	c0 60       	breq	8000c2a8 <__avr32_f64_add_longshift+0x14>
8000c29e:	f2 05 09 4e 	lsl	lr,r9,r5
8000c2a2:	58 08       	cp.w	r8,0
8000c2a4:	5f 18       	srne	r8
8000c2a6:	10 4e       	or	lr,r8
8000c2a8:	f2 06 0a 48 	lsr	r8,r9,r6
8000c2ac:	30 09       	mov	r9,0
8000c2ae:	cc 8b       	rjmp	8000c23e <__avr32_f64_add_shift_done>

8000c2b0 <__avr32_f64_add_res_of>:
8000c2b0:	fd ee 10 1e 	or	lr,lr,lr<<0x1
8000c2b4:	a1 9b       	lsr	r11,0x1
8000c2b6:	5d 0a       	ror	r10
8000c2b8:	5d 0e       	ror	lr
8000c2ba:	2f f7       	sub	r7,-1
8000c2bc:	e0 47 07 ff 	cp.w	r7,2047
8000c2c0:	f9 ba 00 00 	moveq	r10,0
8000c2c4:	f9 bb 00 00 	moveq	r11,0
8000c2c8:	f9 be 00 00 	moveq	lr,0
8000c2cc:	cb fb       	rjmp	8000c24a <__avr32_f64_add_res_of_done>

8000c2ce <__avr32_f64_add_op2_subnormal>:
8000c2ce:	30 16       	mov	r6,1
8000c2d0:	58 07       	cp.w	r7,0
8000c2d2:	ca 01       	brne	8000c212 <__avr32_f64_add+0x3e>
8000c2d4:	b5 cb       	cbr	r11,0x14
8000c2d6:	10 0a       	add	r10,r8
8000c2d8:	f6 09 00 4b 	adc	r11,r11,r9
8000c2dc:	18 4b       	or	r11,r12
8000c2de:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000c2e2:	d7 03       	nop

8000c2e4 <__avr32_f64_to_u32>:
8000c2e4:	58 0b       	cp.w	r11,0
8000c2e6:	5e 6d       	retmi	0

8000c2e8 <__avr32_f64_to_s32>:
8000c2e8:	f6 0c 15 01 	lsl	r12,r11,0x1
8000c2ec:	b5 9c       	lsr	r12,0x15
8000c2ee:	e0 2c 03 ff 	sub	r12,1023
8000c2f2:	5e 3d       	retlo	0
8000c2f4:	f8 0c 11 1f 	rsub	r12,r12,31
8000c2f8:	16 99       	mov	r9,r11
8000c2fa:	ab 7b       	lsl	r11,0xb
8000c2fc:	bf bb       	sbr	r11,0x1f
8000c2fe:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000c302:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000c306:	a1 79       	lsl	r9,0x1
8000c308:	5e 2b       	reths	r11
8000c30a:	5c 3b       	neg	r11
8000c30c:	5e fb       	retal	r11

8000c30e <__avr32_u32_to_f64>:
8000c30e:	f8 cb 00 00 	sub	r11,r12,0
8000c312:	30 0c       	mov	r12,0
8000c314:	c0 38       	rjmp	8000c31a <__avr32_s32_to_f64+0x4>

8000c316 <__avr32_s32_to_f64>:
8000c316:	18 9b       	mov	r11,r12
8000c318:	5c 4b       	abs	r11
8000c31a:	30 0a       	mov	r10,0
8000c31c:	5e 0b       	reteq	r11
8000c31e:	d4 01       	pushm	lr
8000c320:	e0 69 04 1e 	mov	r9,1054
8000c324:	f6 08 12 00 	clz	r8,r11
8000c328:	c1 70       	breq	8000c356 <__avr32_s32_to_f64+0x40>
8000c32a:	c0 c3       	brcs	8000c342 <__avr32_s32_to_f64+0x2c>
8000c32c:	f0 0e 11 20 	rsub	lr,r8,32
8000c330:	f6 08 09 4b 	lsl	r11,r11,r8
8000c334:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000c338:	1c 4b       	or	r11,lr
8000c33a:	f4 08 09 4a 	lsl	r10,r10,r8
8000c33e:	10 19       	sub	r9,r8
8000c340:	c0 b8       	rjmp	8000c356 <__avr32_s32_to_f64+0x40>
8000c342:	f4 08 12 00 	clz	r8,r10
8000c346:	f9 b8 03 00 	movlo	r8,0
8000c34a:	f7 b8 02 e0 	subhs	r8,-32
8000c34e:	f4 08 09 4b 	lsl	r11,r10,r8
8000c352:	30 0a       	mov	r10,0
8000c354:	10 19       	sub	r9,r8
8000c356:	58 09       	cp.w	r9,0
8000c358:	e0 89 00 30 	brgt	8000c3b8 <__avr32_s32_to_f64+0xa2>
8000c35c:	5c 39       	neg	r9
8000c35e:	2f f9       	sub	r9,-1
8000c360:	e0 49 00 36 	cp.w	r9,54
8000c364:	c0 43       	brcs	8000c36c <__avr32_s32_to_f64+0x56>
8000c366:	30 0b       	mov	r11,0
8000c368:	30 0a       	mov	r10,0
8000c36a:	c2 68       	rjmp	8000c3b6 <__avr32_s32_to_f64+0xa0>
8000c36c:	2f 69       	sub	r9,-10
8000c36e:	f2 08 11 20 	rsub	r8,r9,32
8000c372:	e0 49 00 20 	cp.w	r9,32
8000c376:	c0 b2       	brcc	8000c38c <__avr32_s32_to_f64+0x76>
8000c378:	f4 08 09 4e 	lsl	lr,r10,r8
8000c37c:	f6 08 09 48 	lsl	r8,r11,r8
8000c380:	f4 09 0a 4a 	lsr	r10,r10,r9
8000c384:	f6 09 0a 4b 	lsr	r11,r11,r9
8000c388:	10 4b       	or	r11,r8
8000c38a:	c0 88       	rjmp	8000c39a <__avr32_s32_to_f64+0x84>
8000c38c:	f6 08 09 4e 	lsl	lr,r11,r8
8000c390:	14 4e       	or	lr,r10
8000c392:	16 9a       	mov	r10,r11
8000c394:	30 0b       	mov	r11,0
8000c396:	f4 09 0a 4a 	lsr	r10,r10,r9
8000c39a:	ed ba 00 00 	bld	r10,0x0
8000c39e:	c0 92       	brcc	8000c3b0 <__avr32_s32_to_f64+0x9a>
8000c3a0:	1c 7e       	tst	lr,lr
8000c3a2:	c0 41       	brne	8000c3aa <__avr32_s32_to_f64+0x94>
8000c3a4:	ed ba 00 01 	bld	r10,0x1
8000c3a8:	c0 42       	brcc	8000c3b0 <__avr32_s32_to_f64+0x9a>
8000c3aa:	2f fa       	sub	r10,-1
8000c3ac:	f7 bb 02 ff 	subhs	r11,-1
8000c3b0:	5c fc       	rol	r12
8000c3b2:	5d 0b       	ror	r11
8000c3b4:	5d 0a       	ror	r10
8000c3b6:	d8 02       	popm	pc
8000c3b8:	e0 68 03 ff 	mov	r8,1023
8000c3bc:	ed ba 00 0b 	bld	r10,0xb
8000c3c0:	f7 b8 00 ff 	subeq	r8,-1
8000c3c4:	10 0a       	add	r10,r8
8000c3c6:	5c 0b       	acr	r11
8000c3c8:	f7 b9 03 fe 	sublo	r9,-2
8000c3cc:	e0 49 07 ff 	cp.w	r9,2047
8000c3d0:	c0 55       	brlt	8000c3da <__avr32_s32_to_f64+0xc4>
8000c3d2:	30 0a       	mov	r10,0
8000c3d4:	fc 1b ff e0 	movh	r11,0xffe0
8000c3d8:	c0 c8       	rjmp	8000c3f0 <__floatsidf_return_op1>
8000c3da:	ed bb 00 1f 	bld	r11,0x1f
8000c3de:	f7 b9 01 01 	subne	r9,1
8000c3e2:	ab 9a       	lsr	r10,0xb
8000c3e4:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000c3e8:	a1 7b       	lsl	r11,0x1
8000c3ea:	ab 9b       	lsr	r11,0xb
8000c3ec:	f7 e9 11 5b 	or	r11,r11,r9<<0x15

8000c3f0 <__floatsidf_return_op1>:
8000c3f0:	a1 7c       	lsl	r12,0x1
8000c3f2:	5d 0b       	ror	r11
8000c3f4:	d8 02       	popm	pc

8000c3f6 <__avr32_f64_cmp_eq>:
8000c3f6:	10 3a       	cp.w	r10,r8
8000c3f8:	f2 0b 13 00 	cpc	r11,r9
8000c3fc:	c0 80       	breq	8000c40c <__avr32_f64_cmp_eq+0x16>
8000c3fe:	a1 7b       	lsl	r11,0x1
8000c400:	a1 79       	lsl	r9,0x1
8000c402:	14 4b       	or	r11,r10
8000c404:	12 4b       	or	r11,r9
8000c406:	10 4b       	or	r11,r8
8000c408:	5e 0f       	reteq	1
8000c40a:	5e fd       	retal	0
8000c40c:	a1 7b       	lsl	r11,0x1
8000c40e:	fc 1c ff e0 	movh	r12,0xffe0
8000c412:	58 0a       	cp.w	r10,0
8000c414:	f8 0b 13 00 	cpc	r11,r12
8000c418:	5e 8f       	retls	1
8000c41a:	5e fd       	retal	0

8000c41c <__avr32_f64_cmp_ge>:
8000c41c:	1a de       	st.w	--sp,lr
8000c41e:	1a d7       	st.w	--sp,r7
8000c420:	a1 7b       	lsl	r11,0x1
8000c422:	5f 3c       	srlo	r12
8000c424:	a1 79       	lsl	r9,0x1
8000c426:	5f 37       	srlo	r7
8000c428:	5c fc       	rol	r12
8000c42a:	fc 1e ff e0 	movh	lr,0xffe0
8000c42e:	58 0a       	cp.w	r10,0
8000c430:	fc 0b 13 00 	cpc	r11,lr
8000c434:	e0 8b 00 1d 	brhi	8000c46e <__avr32_f64_cmp_ge+0x52>
8000c438:	58 08       	cp.w	r8,0
8000c43a:	fc 09 13 00 	cpc	r9,lr
8000c43e:	e0 8b 00 18 	brhi	8000c46e <__avr32_f64_cmp_ge+0x52>
8000c442:	58 0b       	cp.w	r11,0
8000c444:	f5 ba 00 00 	subfeq	r10,0
8000c448:	c1 50       	breq	8000c472 <__avr32_f64_cmp_ge+0x56>
8000c44a:	1b 07       	ld.w	r7,sp++
8000c44c:	1b 0e       	ld.w	lr,sp++
8000c44e:	58 3c       	cp.w	r12,3
8000c450:	c0 a0       	breq	8000c464 <__avr32_f64_cmp_ge+0x48>
8000c452:	58 1c       	cp.w	r12,1
8000c454:	c0 33       	brcs	8000c45a <__avr32_f64_cmp_ge+0x3e>
8000c456:	5e 0f       	reteq	1
8000c458:	5e 1d       	retne	0
8000c45a:	10 3a       	cp.w	r10,r8
8000c45c:	f2 0b 13 00 	cpc	r11,r9
8000c460:	5e 2f       	reths	1
8000c462:	5e 3d       	retlo	0
8000c464:	14 38       	cp.w	r8,r10
8000c466:	f6 09 13 00 	cpc	r9,r11
8000c46a:	5e 2f       	reths	1
8000c46c:	5e 3d       	retlo	0
8000c46e:	1b 07       	ld.w	r7,sp++
8000c470:	d8 0a       	popm	pc,r12=0
8000c472:	58 17       	cp.w	r7,1
8000c474:	5f 0c       	sreq	r12
8000c476:	58 09       	cp.w	r9,0
8000c478:	f5 b8 00 00 	subfeq	r8,0
8000c47c:	1b 07       	ld.w	r7,sp++
8000c47e:	1b 0e       	ld.w	lr,sp++
8000c480:	5e 0f       	reteq	1
8000c482:	5e fc       	retal	r12

8000c484 <__avr32_f64_cmp_lt>:
8000c484:	1a de       	st.w	--sp,lr
8000c486:	1a d7       	st.w	--sp,r7
8000c488:	a1 7b       	lsl	r11,0x1
8000c48a:	5f 3c       	srlo	r12
8000c48c:	a1 79       	lsl	r9,0x1
8000c48e:	5f 37       	srlo	r7
8000c490:	5c fc       	rol	r12
8000c492:	fc 1e ff e0 	movh	lr,0xffe0
8000c496:	58 0a       	cp.w	r10,0
8000c498:	fc 0b 13 00 	cpc	r11,lr
8000c49c:	e0 8b 00 1d 	brhi	8000c4d6 <__avr32_f64_cmp_lt+0x52>
8000c4a0:	58 08       	cp.w	r8,0
8000c4a2:	fc 09 13 00 	cpc	r9,lr
8000c4a6:	e0 8b 00 18 	brhi	8000c4d6 <__avr32_f64_cmp_lt+0x52>
8000c4aa:	58 0b       	cp.w	r11,0
8000c4ac:	f5 ba 00 00 	subfeq	r10,0
8000c4b0:	c1 50       	breq	8000c4da <__avr32_f64_cmp_lt+0x56>
8000c4b2:	1b 07       	ld.w	r7,sp++
8000c4b4:	1b 0e       	ld.w	lr,sp++
8000c4b6:	58 3c       	cp.w	r12,3
8000c4b8:	c0 a0       	breq	8000c4cc <__avr32_f64_cmp_lt+0x48>
8000c4ba:	58 1c       	cp.w	r12,1
8000c4bc:	c0 33       	brcs	8000c4c2 <__avr32_f64_cmp_lt+0x3e>
8000c4be:	5e 0d       	reteq	0
8000c4c0:	5e 1f       	retne	1
8000c4c2:	10 3a       	cp.w	r10,r8
8000c4c4:	f2 0b 13 00 	cpc	r11,r9
8000c4c8:	5e 2d       	reths	0
8000c4ca:	5e 3f       	retlo	1
8000c4cc:	14 38       	cp.w	r8,r10
8000c4ce:	f6 09 13 00 	cpc	r9,r11
8000c4d2:	5e 2d       	reths	0
8000c4d4:	5e 3f       	retlo	1
8000c4d6:	1b 07       	ld.w	r7,sp++
8000c4d8:	d8 0a       	popm	pc,r12=0
8000c4da:	58 17       	cp.w	r7,1
8000c4dc:	5f 1c       	srne	r12
8000c4de:	58 09       	cp.w	r9,0
8000c4e0:	f5 b8 00 00 	subfeq	r8,0
8000c4e4:	1b 07       	ld.w	r7,sp++
8000c4e6:	1b 0e       	ld.w	lr,sp++
8000c4e8:	5e 0d       	reteq	0
8000c4ea:	5e fc       	retal	r12

8000c4ec <__avr32_f64_div>:
8000c4ec:	eb cd 40 ff 	pushm	r0-r7,lr
8000c4f0:	f7 e9 20 0e 	eor	lr,r11,r9
8000c4f4:	f6 07 16 14 	lsr	r7,r11,0x14
8000c4f8:	a9 7b       	lsl	r11,0x9
8000c4fa:	f7 ea 13 7b 	or	r11,r11,r10>>0x17
8000c4fe:	a9 7a       	lsl	r10,0x9
8000c500:	bd bb       	sbr	r11,0x1d
8000c502:	e4 1b 3f ff 	andh	r11,0x3fff
8000c506:	ab d7       	cbr	r7,0xb
8000c508:	e0 80 00 cc 	breq	8000c6a0 <__avr32_f64_div_round_subnormal+0x54>
8000c50c:	e0 47 07 ff 	cp.w	r7,2047
8000c510:	e0 84 00 b5 	brge	8000c67a <__avr32_f64_div_round_subnormal+0x2e>
8000c514:	f2 06 16 14 	lsr	r6,r9,0x14
8000c518:	a9 79       	lsl	r9,0x9
8000c51a:	f3 e8 13 79 	or	r9,r9,r8>>0x17
8000c51e:	a9 78       	lsl	r8,0x9
8000c520:	bd b9       	sbr	r9,0x1d
8000c522:	e4 19 3f ff 	andh	r9,0x3fff
8000c526:	ab d6       	cbr	r6,0xb
8000c528:	e0 80 00 e2 	breq	8000c6ec <__avr32_f64_div_round_subnormal+0xa0>
8000c52c:	e0 46 07 ff 	cp.w	r6,2047
8000c530:	e0 84 00 b2 	brge	8000c694 <__avr32_f64_div_round_subnormal+0x48>
8000c534:	0c 17       	sub	r7,r6
8000c536:	fe 37 fc 01 	sub	r7,-1023
8000c53a:	fc 1c 80 00 	movh	r12,0x8000
8000c53e:	f8 03 16 01 	lsr	r3,r12,0x1
8000c542:	e9 d9 c3 62 	bfextu	r4,r9,0x1b,0x2
8000c546:	5c d4       	com	r4
8000c548:	e7 d4 d3 82 	bfins	r3,r4,0x1c,0x2
8000c54c:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c550:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000c554:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c558:	ea 03 15 02 	lsl	r3,r5,0x2
8000c55c:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c560:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000c564:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c568:	ea 03 15 02 	lsl	r3,r5,0x2
8000c56c:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c570:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000c574:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c578:	ea 03 15 02 	lsl	r3,r5,0x2
8000c57c:	e6 08 06 40 	mulu.d	r0,r3,r8
8000c580:	e4 09 07 40 	macu.d	r0,r2,r9
8000c584:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c588:	02 04       	add	r4,r1
8000c58a:	5c 05       	acr	r5
8000c58c:	a3 65       	lsl	r5,0x2
8000c58e:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000c592:	a3 64       	lsl	r4,0x2
8000c594:	5c 34       	neg	r4
8000c596:	f8 05 01 45 	sbc	r5,r12,r5
8000c59a:	e6 04 06 40 	mulu.d	r0,r3,r4
8000c59e:	e4 05 07 40 	macu.d	r0,r2,r5
8000c5a2:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c5a6:	02 04       	add	r4,r1
8000c5a8:	5c 05       	acr	r5
8000c5aa:	ea 03 15 02 	lsl	r3,r5,0x2
8000c5ae:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000c5b2:	e8 02 15 02 	lsl	r2,r4,0x2
8000c5b6:	e6 08 06 40 	mulu.d	r0,r3,r8
8000c5ba:	e4 09 07 40 	macu.d	r0,r2,r9
8000c5be:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c5c2:	02 04       	add	r4,r1
8000c5c4:	5c 05       	acr	r5
8000c5c6:	a3 65       	lsl	r5,0x2
8000c5c8:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000c5cc:	a3 64       	lsl	r4,0x2
8000c5ce:	5c 34       	neg	r4
8000c5d0:	f8 05 01 45 	sbc	r5,r12,r5
8000c5d4:	e6 04 06 40 	mulu.d	r0,r3,r4
8000c5d8:	e4 05 07 40 	macu.d	r0,r2,r5
8000c5dc:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c5e0:	02 04       	add	r4,r1
8000c5e2:	5c 05       	acr	r5
8000c5e4:	ea 03 15 02 	lsl	r3,r5,0x2
8000c5e8:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000c5ec:	e8 02 15 02 	lsl	r2,r4,0x2
8000c5f0:	e6 0a 06 40 	mulu.d	r0,r3,r10
8000c5f4:	e4 0b 07 40 	macu.d	r0,r2,r11
8000c5f8:	e6 0b 06 42 	mulu.d	r2,r3,r11
8000c5fc:	02 02       	add	r2,r1
8000c5fe:	5c 03       	acr	r3
8000c600:	ed b3 00 1c 	bld	r3,0x1c
8000c604:	c0 90       	breq	8000c616 <__avr32_f64_div+0x12a>
8000c606:	a1 72       	lsl	r2,0x1
8000c608:	5c f3       	rol	r3
8000c60a:	20 17       	sub	r7,1
8000c60c:	a3 9a       	lsr	r10,0x3
8000c60e:	f5 eb 11 da 	or	r10,r10,r11<<0x1d
8000c612:	a3 9b       	lsr	r11,0x3
8000c614:	c0 58       	rjmp	8000c61e <__avr32_f64_div+0x132>
8000c616:	a5 8a       	lsr	r10,0x4
8000c618:	f5 eb 11 ca 	or	r10,r10,r11<<0x1c
8000c61c:	a5 8b       	lsr	r11,0x4
8000c61e:	58 07       	cp.w	r7,0
8000c620:	e0 8a 00 8b 	brle	8000c736 <__avr32_f64_div_res_subnormal>
8000c624:	e0 12 ff 00 	andl	r2,0xff00
8000c628:	e8 12 00 80 	orl	r2,0x80
8000c62c:	e6 08 06 40 	mulu.d	r0,r3,r8
8000c630:	e4 09 07 40 	macu.d	r0,r2,r9
8000c634:	e4 08 06 44 	mulu.d	r4,r2,r8
8000c638:	e6 09 06 48 	mulu.d	r8,r3,r9
8000c63c:	00 05       	add	r5,r0
8000c63e:	f0 01 00 48 	adc	r8,r8,r1
8000c642:	5c 09       	acr	r9
8000c644:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000c648:	58 04       	cp.w	r4,0
8000c64a:	5c 25       	cpc	r5

8000c64c <__avr32_f64_div_round_subnormal>:
8000c64c:	f4 08 13 00 	cpc	r8,r10
8000c650:	f6 09 13 00 	cpc	r9,r11
8000c654:	5f 36       	srlo	r6
8000c656:	f8 06 17 00 	moveq	r6,r12
8000c65a:	e4 0a 16 08 	lsr	r10,r2,0x8
8000c65e:	f5 e3 11 8a 	or	r10,r10,r3<<0x18
8000c662:	e6 0b 16 08 	lsr	r11,r3,0x8
8000c666:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000c66a:	ed be 00 1f 	bld	lr,0x1f
8000c66e:	ef bb 00 1f 	bst	r11,0x1f
8000c672:	0c 0a       	add	r10,r6
8000c674:	5c 0b       	acr	r11
8000c676:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000c67a:	e4 1b 00 0f 	andh	r11,0xf
8000c67e:	14 4b       	or	r11,r10
8000c680:	e0 81 00 a7 	brne	8000c7ce <__avr32_f64_div_res_subnormal+0x98>
8000c684:	f2 06 16 14 	lsr	r6,r9,0x14
8000c688:	ab d6       	cbr	r6,0xb
8000c68a:	e0 46 07 ff 	cp.w	r6,2047
8000c68e:	e0 81 00 a4 	brne	8000c7d6 <__avr32_f64_div_res_subnormal+0xa0>
8000c692:	c9 e8       	rjmp	8000c7ce <__avr32_f64_div_res_subnormal+0x98>
8000c694:	e4 19 00 0f 	andh	r9,0xf
8000c698:	10 49       	or	r9,r8
8000c69a:	e0 81 00 9a 	brne	8000c7ce <__avr32_f64_div_res_subnormal+0x98>
8000c69e:	c9 28       	rjmp	8000c7c2 <__avr32_f64_div_res_subnormal+0x8c>
8000c6a0:	a3 7b       	lsl	r11,0x3
8000c6a2:	f7 ea 13 db 	or	r11,r11,r10>>0x1d
8000c6a6:	a3 7a       	lsl	r10,0x3
8000c6a8:	f5 eb 10 04 	or	r4,r10,r11
8000c6ac:	e0 80 00 a0 	breq	8000c7ec <__avr32_f64_div_op1_zero>
8000c6b0:	f6 04 12 00 	clz	r4,r11
8000c6b4:	c1 70       	breq	8000c6e2 <__avr32_f64_div_round_subnormal+0x96>
8000c6b6:	c0 c3       	brcs	8000c6ce <__avr32_f64_div_round_subnormal+0x82>
8000c6b8:	e8 05 11 20 	rsub	r5,r4,32
8000c6bc:	f6 04 09 4b 	lsl	r11,r11,r4
8000c6c0:	f4 05 0a 45 	lsr	r5,r10,r5
8000c6c4:	0a 4b       	or	r11,r5
8000c6c6:	f4 04 09 4a 	lsl	r10,r10,r4
8000c6ca:	08 17       	sub	r7,r4
8000c6cc:	c0 b8       	rjmp	8000c6e2 <__avr32_f64_div_round_subnormal+0x96>
8000c6ce:	f4 04 12 00 	clz	r4,r10
8000c6d2:	f9 b4 03 00 	movlo	r4,0
8000c6d6:	f7 b4 02 e0 	subhs	r4,-32
8000c6da:	f4 04 09 4b 	lsl	r11,r10,r4
8000c6de:	30 0a       	mov	r10,0
8000c6e0:	08 17       	sub	r7,r4
8000c6e2:	a3 8a       	lsr	r10,0x2
8000c6e4:	f5 eb 11 ea 	or	r10,r10,r11<<0x1e
8000c6e8:	a3 8b       	lsr	r11,0x2
8000c6ea:	c1 1b       	rjmp	8000c50c <__avr32_f64_div+0x20>
8000c6ec:	a3 79       	lsl	r9,0x3
8000c6ee:	f3 e8 13 d9 	or	r9,r9,r8>>0x1d
8000c6f2:	a3 78       	lsl	r8,0x3
8000c6f4:	f3 e8 10 04 	or	r4,r9,r8
8000c6f8:	c6 f0       	breq	8000c7d6 <__avr32_f64_div_res_subnormal+0xa0>
8000c6fa:	f2 04 12 00 	clz	r4,r9
8000c6fe:	c1 70       	breq	8000c72c <__avr32_f64_div_round_subnormal+0xe0>
8000c700:	c0 c3       	brcs	8000c718 <__avr32_f64_div_round_subnormal+0xcc>
8000c702:	e8 05 11 20 	rsub	r5,r4,32
8000c706:	f2 04 09 49 	lsl	r9,r9,r4
8000c70a:	f0 05 0a 45 	lsr	r5,r8,r5
8000c70e:	0a 49       	or	r9,r5
8000c710:	f0 04 09 48 	lsl	r8,r8,r4
8000c714:	08 16       	sub	r6,r4
8000c716:	c0 b8       	rjmp	8000c72c <__avr32_f64_div_round_subnormal+0xe0>
8000c718:	f0 04 12 00 	clz	r4,r8
8000c71c:	f9 b4 03 00 	movlo	r4,0
8000c720:	f7 b4 02 e0 	subhs	r4,-32
8000c724:	f0 04 09 49 	lsl	r9,r8,r4
8000c728:	30 08       	mov	r8,0
8000c72a:	08 16       	sub	r6,r4
8000c72c:	a3 88       	lsr	r8,0x2
8000c72e:	f1 e9 11 e8 	or	r8,r8,r9<<0x1e
8000c732:	a3 89       	lsr	r9,0x2
8000c734:	cf ca       	rjmp	8000c52c <__avr32_f64_div+0x40>

8000c736 <__avr32_f64_div_res_subnormal>:
8000c736:	5c 37       	neg	r7
8000c738:	2f f7       	sub	r7,-1
8000c73a:	f1 b7 04 c0 	satu	r7,0x6
8000c73e:	e0 47 00 20 	cp.w	r7,32
8000c742:	c1 54       	brge	8000c76c <__avr32_f64_div_res_subnormal+0x36>
8000c744:	ee 06 11 20 	rsub	r6,r7,32
8000c748:	e4 07 0a 42 	lsr	r2,r2,r7
8000c74c:	e6 06 09 4c 	lsl	r12,r3,r6
8000c750:	18 42       	or	r2,r12
8000c752:	e6 07 0a 43 	lsr	r3,r3,r7
8000c756:	f4 06 09 41 	lsl	r1,r10,r6
8000c75a:	f4 07 0a 4a 	lsr	r10,r10,r7
8000c75e:	f6 06 09 4c 	lsl	r12,r11,r6
8000c762:	18 4a       	or	r10,r12
8000c764:	f6 07 0a 4b 	lsr	r11,r11,r7
8000c768:	30 00       	mov	r0,0
8000c76a:	c1 58       	rjmp	8000c794 <__avr32_f64_div_res_subnormal+0x5e>
8000c76c:	ee 06 11 20 	rsub	r6,r7,32
8000c770:	f9 b0 00 00 	moveq	r0,0
8000c774:	f9 bc 00 00 	moveq	r12,0
8000c778:	c0 50       	breq	8000c782 <__avr32_f64_div_res_subnormal+0x4c>
8000c77a:	f4 06 09 40 	lsl	r0,r10,r6
8000c77e:	f6 06 09 4c 	lsl	r12,r11,r6
8000c782:	e6 07 0a 42 	lsr	r2,r3,r7
8000c786:	30 03       	mov	r3,0
8000c788:	f4 07 0a 41 	lsr	r1,r10,r7
8000c78c:	18 41       	or	r1,r12
8000c78e:	f6 07 0a 4a 	lsr	r10,r11,r7
8000c792:	30 0b       	mov	r11,0
8000c794:	e0 12 ff 00 	andl	r2,0xff00
8000c798:	e8 12 00 80 	orl	r2,0x80
8000c79c:	e6 08 06 46 	mulu.d	r6,r3,r8
8000c7a0:	e4 09 07 46 	macu.d	r6,r2,r9
8000c7a4:	e4 08 06 44 	mulu.d	r4,r2,r8
8000c7a8:	e6 09 06 48 	mulu.d	r8,r3,r9
8000c7ac:	0c 05       	add	r5,r6
8000c7ae:	f0 07 00 48 	adc	r8,r8,r7
8000c7b2:	5c 09       	acr	r9
8000c7b4:	30 07       	mov	r7,0
8000c7b6:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000c7ba:	00 34       	cp.w	r4,r0
8000c7bc:	e2 05 13 00 	cpc	r5,r1
8000c7c0:	c4 6b       	rjmp	8000c64c <__avr32_f64_div_round_subnormal>
8000c7c2:	1c 9b       	mov	r11,lr
8000c7c4:	e6 1b 80 00 	andh	r11,0x8000,COH
8000c7c8:	30 0a       	mov	r10,0
8000c7ca:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000c7ce:	3f fb       	mov	r11,-1
8000c7d0:	30 0a       	mov	r10,0
8000c7d2:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000c7d6:	f5 eb 10 04 	or	r4,r10,r11
8000c7da:	c0 90       	breq	8000c7ec <__avr32_f64_div_op1_zero>
8000c7dc:	1c 9b       	mov	r11,lr
8000c7de:	e6 1b 80 00 	andh	r11,0x8000,COH
8000c7e2:	ea 1b 7f f0 	orh	r11,0x7ff0
8000c7e6:	30 0a       	mov	r10,0
8000c7e8:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc

8000c7ec <__avr32_f64_div_op1_zero>:
8000c7ec:	f1 e9 10 15 	or	r5,r8,r9<<0x1
8000c7f0:	ce f0       	breq	8000c7ce <__avr32_f64_div_res_subnormal+0x98>
8000c7f2:	e9 d9 c2 8b 	bfextu	r4,r9,0x14,0xb
8000c7f6:	e0 44 07 ff 	cp.w	r4,2047
8000c7fa:	ce 41       	brne	8000c7c2 <__avr32_f64_div_res_subnormal+0x8c>
8000c7fc:	f1 e9 10 c5 	or	r5,r8,r9<<0xc
8000c800:	ce 10       	breq	8000c7c2 <__avr32_f64_div_res_subnormal+0x8c>
8000c802:	ce 6b       	rjmp	8000c7ce <__avr32_f64_div_res_subnormal+0x98>

8000c804 <__avr32_udiv64>:
8000c804:	d4 31       	pushm	r0-r7,lr
8000c806:	1a 97       	mov	r7,sp
8000c808:	20 3d       	sub	sp,12
8000c80a:	10 9c       	mov	r12,r8
8000c80c:	12 9e       	mov	lr,r9
8000c80e:	14 93       	mov	r3,r10
8000c810:	58 09       	cp.w	r9,0
8000c812:	e0 81 00 bd 	brne	8000c98c <__avr32_udiv64+0x188>
8000c816:	16 38       	cp.w	r8,r11
8000c818:	e0 88 00 40 	brls	8000c898 <__avr32_udiv64+0x94>
8000c81c:	f0 08 12 00 	clz	r8,r8
8000c820:	c0 d0       	breq	8000c83a <__avr32_udiv64+0x36>
8000c822:	f6 08 09 4b 	lsl	r11,r11,r8
8000c826:	f0 09 11 20 	rsub	r9,r8,32
8000c82a:	f8 08 09 4c 	lsl	r12,r12,r8
8000c82e:	f4 09 0a 49 	lsr	r9,r10,r9
8000c832:	f4 08 09 43 	lsl	r3,r10,r8
8000c836:	f3 eb 10 0b 	or	r11,r9,r11
8000c83a:	f8 0e 16 10 	lsr	lr,r12,0x10
8000c83e:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000c842:	f6 0e 0d 00 	divu	r0,r11,lr
8000c846:	e6 0b 16 10 	lsr	r11,r3,0x10
8000c84a:	00 99       	mov	r9,r0
8000c84c:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c850:	e0 0a 02 48 	mul	r8,r0,r10
8000c854:	10 3b       	cp.w	r11,r8
8000c856:	c0 a2       	brcc	8000c86a <__avr32_udiv64+0x66>
8000c858:	20 19       	sub	r9,1
8000c85a:	18 0b       	add	r11,r12
8000c85c:	18 3b       	cp.w	r11,r12
8000c85e:	c0 63       	brcs	8000c86a <__avr32_udiv64+0x66>
8000c860:	10 3b       	cp.w	r11,r8
8000c862:	f7 b9 03 01 	sublo	r9,1
8000c866:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c86a:	f6 08 01 01 	sub	r1,r11,r8
8000c86e:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000c872:	e2 0e 0d 00 	divu	r0,r1,lr
8000c876:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000c87a:	00 98       	mov	r8,r0
8000c87c:	e0 0a 02 4a 	mul	r10,r0,r10
8000c880:	14 33       	cp.w	r3,r10
8000c882:	c0 82       	brcc	8000c892 <__avr32_udiv64+0x8e>
8000c884:	20 18       	sub	r8,1
8000c886:	18 03       	add	r3,r12
8000c888:	18 33       	cp.w	r3,r12
8000c88a:	c0 43       	brcs	8000c892 <__avr32_udiv64+0x8e>
8000c88c:	14 33       	cp.w	r3,r10
8000c88e:	f7 b8 03 01 	sublo	r8,1
8000c892:	f1 e9 11 08 	or	r8,r8,r9<<0x10
8000c896:	cd f8       	rjmp	8000ca54 <__avr32_udiv64+0x250>
8000c898:	58 08       	cp.w	r8,0
8000c89a:	c0 51       	brne	8000c8a4 <__avr32_udiv64+0xa0>
8000c89c:	30 19       	mov	r9,1
8000c89e:	f2 08 0d 08 	divu	r8,r9,r8
8000c8a2:	10 9c       	mov	r12,r8
8000c8a4:	f8 06 12 00 	clz	r6,r12
8000c8a8:	c0 41       	brne	8000c8b0 <__avr32_udiv64+0xac>
8000c8aa:	18 1b       	sub	r11,r12
8000c8ac:	30 19       	mov	r9,1
8000c8ae:	c4 08       	rjmp	8000c92e <__avr32_udiv64+0x12a>
8000c8b0:	ec 01 11 20 	rsub	r1,r6,32
8000c8b4:	f4 01 0a 49 	lsr	r9,r10,r1
8000c8b8:	f8 06 09 4c 	lsl	r12,r12,r6
8000c8bc:	f6 06 09 48 	lsl	r8,r11,r6
8000c8c0:	f6 01 0a 41 	lsr	r1,r11,r1
8000c8c4:	f3 e8 10 08 	or	r8,r9,r8
8000c8c8:	f8 03 16 10 	lsr	r3,r12,0x10
8000c8cc:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000c8d0:	e2 03 0d 00 	divu	r0,r1,r3
8000c8d4:	f0 0b 16 10 	lsr	r11,r8,0x10
8000c8d8:	00 9e       	mov	lr,r0
8000c8da:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c8de:	e0 05 02 49 	mul	r9,r0,r5
8000c8e2:	12 3b       	cp.w	r11,r9
8000c8e4:	c0 a2       	brcc	8000c8f8 <__avr32_udiv64+0xf4>
8000c8e6:	20 1e       	sub	lr,1
8000c8e8:	18 0b       	add	r11,r12
8000c8ea:	18 3b       	cp.w	r11,r12
8000c8ec:	c0 63       	brcs	8000c8f8 <__avr32_udiv64+0xf4>
8000c8ee:	12 3b       	cp.w	r11,r9
8000c8f0:	f7 be 03 01 	sublo	lr,1
8000c8f4:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c8f8:	12 1b       	sub	r11,r9
8000c8fa:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
8000c8fe:	f6 03 0d 02 	divu	r2,r11,r3
8000c902:	f1 e3 11 08 	or	r8,r8,r3<<0x10
8000c906:	04 99       	mov	r9,r2
8000c908:	e4 05 02 4b 	mul	r11,r2,r5
8000c90c:	16 38       	cp.w	r8,r11
8000c90e:	c0 a2       	brcc	8000c922 <__avr32_udiv64+0x11e>
8000c910:	20 19       	sub	r9,1
8000c912:	18 08       	add	r8,r12
8000c914:	18 38       	cp.w	r8,r12
8000c916:	c0 63       	brcs	8000c922 <__avr32_udiv64+0x11e>
8000c918:	16 38       	cp.w	r8,r11
8000c91a:	f7 b9 03 01 	sublo	r9,1
8000c91e:	f1 dc e3 08 	addcs	r8,r8,r12
8000c922:	f4 06 09 43 	lsl	r3,r10,r6
8000c926:	f0 0b 01 0b 	sub	r11,r8,r11
8000c92a:	f3 ee 11 09 	or	r9,r9,lr<<0x10
8000c92e:	f8 06 16 10 	lsr	r6,r12,0x10
8000c932:	fd dc c0 10 	bfextu	lr,r12,0x0,0x10
8000c936:	f6 06 0d 00 	divu	r0,r11,r6
8000c93a:	e6 0b 16 10 	lsr	r11,r3,0x10
8000c93e:	00 9a       	mov	r10,r0
8000c940:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c944:	e0 0e 02 48 	mul	r8,r0,lr
8000c948:	10 3b       	cp.w	r11,r8
8000c94a:	c0 a2       	brcc	8000c95e <__avr32_udiv64+0x15a>
8000c94c:	20 1a       	sub	r10,1
8000c94e:	18 0b       	add	r11,r12
8000c950:	18 3b       	cp.w	r11,r12
8000c952:	c0 63       	brcs	8000c95e <__avr32_udiv64+0x15a>
8000c954:	10 3b       	cp.w	r11,r8
8000c956:	f7 ba 03 01 	sublo	r10,1
8000c95a:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c95e:	f6 08 01 01 	sub	r1,r11,r8
8000c962:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000c966:	e2 06 0d 00 	divu	r0,r1,r6
8000c96a:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000c96e:	00 98       	mov	r8,r0
8000c970:	e0 0e 02 4b 	mul	r11,r0,lr
8000c974:	16 33       	cp.w	r3,r11
8000c976:	c0 82       	brcc	8000c986 <__avr32_udiv64+0x182>
8000c978:	20 18       	sub	r8,1
8000c97a:	18 03       	add	r3,r12
8000c97c:	18 33       	cp.w	r3,r12
8000c97e:	c0 43       	brcs	8000c986 <__avr32_udiv64+0x182>
8000c980:	16 33       	cp.w	r3,r11
8000c982:	f7 b8 03 01 	sublo	r8,1
8000c986:	f1 ea 11 08 	or	r8,r8,r10<<0x10
8000c98a:	c6 98       	rjmp	8000ca5c <__avr32_udiv64+0x258>
8000c98c:	16 39       	cp.w	r9,r11
8000c98e:	e0 8b 00 65 	brhi	8000ca58 <__avr32_udiv64+0x254>
8000c992:	f2 09 12 00 	clz	r9,r9
8000c996:	c0 b1       	brne	8000c9ac <__avr32_udiv64+0x1a8>
8000c998:	10 3a       	cp.w	r10,r8
8000c99a:	5f 2a       	srhs	r10
8000c99c:	1c 3b       	cp.w	r11,lr
8000c99e:	5f b8       	srhi	r8
8000c9a0:	10 4a       	or	r10,r8
8000c9a2:	f2 0a 18 00 	cp.b	r10,r9
8000c9a6:	c5 90       	breq	8000ca58 <__avr32_udiv64+0x254>
8000c9a8:	30 18       	mov	r8,1
8000c9aa:	c5 98       	rjmp	8000ca5c <__avr32_udiv64+0x258>
8000c9ac:	f0 09 09 46 	lsl	r6,r8,r9
8000c9b0:	f2 03 11 20 	rsub	r3,r9,32
8000c9b4:	fc 09 09 4e 	lsl	lr,lr,r9
8000c9b8:	f0 03 0a 48 	lsr	r8,r8,r3
8000c9bc:	f6 09 09 4c 	lsl	r12,r11,r9
8000c9c0:	f4 03 0a 42 	lsr	r2,r10,r3
8000c9c4:	ef 46 ff f4 	st.w	r7[-12],r6
8000c9c8:	f6 03 0a 43 	lsr	r3,r11,r3
8000c9cc:	18 42       	or	r2,r12
8000c9ce:	f1 ee 10 0c 	or	r12,r8,lr
8000c9d2:	f8 01 16 10 	lsr	r1,r12,0x10
8000c9d6:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000c9da:	e6 01 0d 04 	divu	r4,r3,r1
8000c9de:	e4 03 16 10 	lsr	r3,r2,0x10
8000c9e2:	08 9e       	mov	lr,r4
8000c9e4:	e7 e5 11 03 	or	r3,r3,r5<<0x10
8000c9e8:	e8 06 02 48 	mul	r8,r4,r6
8000c9ec:	10 33       	cp.w	r3,r8
8000c9ee:	c0 a2       	brcc	8000ca02 <__avr32_udiv64+0x1fe>
8000c9f0:	20 1e       	sub	lr,1
8000c9f2:	18 03       	add	r3,r12
8000c9f4:	18 33       	cp.w	r3,r12
8000c9f6:	c0 63       	brcs	8000ca02 <__avr32_udiv64+0x1fe>
8000c9f8:	10 33       	cp.w	r3,r8
8000c9fa:	f7 be 03 01 	sublo	lr,1
8000c9fe:	e7 dc e3 03 	addcs	r3,r3,r12
8000ca02:	10 13       	sub	r3,r8
8000ca04:	f7 d2 c0 10 	bfextu	r11,r2,0x0,0x10
8000ca08:	e6 01 0d 00 	divu	r0,r3,r1
8000ca0c:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000ca10:	00 98       	mov	r8,r0
8000ca12:	e0 06 02 46 	mul	r6,r0,r6
8000ca16:	0c 3b       	cp.w	r11,r6
8000ca18:	c0 a2       	brcc	8000ca2c <__avr32_udiv64+0x228>
8000ca1a:	20 18       	sub	r8,1
8000ca1c:	18 0b       	add	r11,r12
8000ca1e:	18 3b       	cp.w	r11,r12
8000ca20:	c0 63       	brcs	8000ca2c <__avr32_udiv64+0x228>
8000ca22:	0c 3b       	cp.w	r11,r6
8000ca24:	f7 dc e3 0b 	addcs	r11,r11,r12
8000ca28:	f7 b8 03 01 	sublo	r8,1
8000ca2c:	f1 ee 11 08 	or	r8,r8,lr<<0x10
8000ca30:	ee f4 ff f4 	ld.w	r4,r7[-12]
8000ca34:	0c 1b       	sub	r11,r6
8000ca36:	f0 04 06 42 	mulu.d	r2,r8,r4
8000ca3a:	06 95       	mov	r5,r3
8000ca3c:	16 35       	cp.w	r5,r11
8000ca3e:	e0 8b 00 0a 	brhi	8000ca52 <__avr32_udiv64+0x24e>
8000ca42:	5f 0b       	sreq	r11
8000ca44:	f4 09 09 49 	lsl	r9,r10,r9
8000ca48:	12 32       	cp.w	r2,r9
8000ca4a:	5f b9       	srhi	r9
8000ca4c:	f7 e9 00 09 	and	r9,r11,r9
8000ca50:	c0 60       	breq	8000ca5c <__avr32_udiv64+0x258>
8000ca52:	20 18       	sub	r8,1
8000ca54:	30 09       	mov	r9,0
8000ca56:	c0 38       	rjmp	8000ca5c <__avr32_udiv64+0x258>
8000ca58:	30 09       	mov	r9,0
8000ca5a:	12 98       	mov	r8,r9
8000ca5c:	10 9a       	mov	r10,r8
8000ca5e:	12 93       	mov	r3,r9
8000ca60:	10 92       	mov	r2,r8
8000ca62:	12 9b       	mov	r11,r9
8000ca64:	2f dd       	sub	sp,-12
8000ca66:	d8 32       	popm	r0-r7,pc

8000ca68 <__avr32_umod64>:
8000ca68:	d4 31       	pushm	r0-r7,lr
8000ca6a:	1a 97       	mov	r7,sp
8000ca6c:	20 3d       	sub	sp,12
8000ca6e:	10 9c       	mov	r12,r8
8000ca70:	12 95       	mov	r5,r9
8000ca72:	14 9e       	mov	lr,r10
8000ca74:	16 91       	mov	r1,r11
8000ca76:	16 96       	mov	r6,r11
8000ca78:	58 09       	cp.w	r9,0
8000ca7a:	e0 81 00 81 	brne	8000cb7c <__avr32_umod64+0x114>
8000ca7e:	16 38       	cp.w	r8,r11
8000ca80:	e0 88 00 12 	brls	8000caa4 <__avr32_umod64+0x3c>
8000ca84:	f0 08 12 00 	clz	r8,r8
8000ca88:	c4 e0       	breq	8000cb24 <__avr32_umod64+0xbc>
8000ca8a:	f6 08 09 46 	lsl	r6,r11,r8
8000ca8e:	f8 08 09 4c 	lsl	r12,r12,r8
8000ca92:	f0 0b 11 20 	rsub	r11,r8,32
8000ca96:	f4 08 09 4e 	lsl	lr,r10,r8
8000ca9a:	f4 0b 0a 4b 	lsr	r11,r10,r11
8000ca9e:	f7 e6 10 06 	or	r6,r11,r6
8000caa2:	c4 18       	rjmp	8000cb24 <__avr32_umod64+0xbc>
8000caa4:	58 08       	cp.w	r8,0
8000caa6:	c0 51       	brne	8000cab0 <__avr32_umod64+0x48>
8000caa8:	30 19       	mov	r9,1
8000caaa:	f2 08 0d 08 	divu	r8,r9,r8
8000caae:	10 9c       	mov	r12,r8
8000cab0:	f8 08 12 00 	clz	r8,r12
8000cab4:	c0 31       	brne	8000caba <__avr32_umod64+0x52>
8000cab6:	18 16       	sub	r6,r12
8000cab8:	c3 68       	rjmp	8000cb24 <__avr32_umod64+0xbc>
8000caba:	f0 03 11 20 	rsub	r3,r8,32
8000cabe:	f4 03 0a 4b 	lsr	r11,r10,r3
8000cac2:	f8 08 09 4c 	lsl	r12,r12,r8
8000cac6:	ec 08 09 49 	lsl	r9,r6,r8
8000caca:	ec 03 0a 43 	lsr	r3,r6,r3
8000cace:	f7 e9 10 09 	or	r9,r11,r9
8000cad2:	f8 05 16 10 	lsr	r5,r12,0x10
8000cad6:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000cada:	e6 05 0d 02 	divu	r2,r3,r5
8000cade:	f2 0e 16 10 	lsr	lr,r9,0x10
8000cae2:	ec 02 02 4b 	mul	r11,r6,r2
8000cae6:	fd e3 11 0e 	or	lr,lr,r3<<0x10
8000caea:	16 3e       	cp.w	lr,r11
8000caec:	c0 72       	brcc	8000cafa <__avr32_umod64+0x92>
8000caee:	18 0e       	add	lr,r12
8000caf0:	18 3e       	cp.w	lr,r12
8000caf2:	c0 43       	brcs	8000cafa <__avr32_umod64+0x92>
8000caf4:	16 3e       	cp.w	lr,r11
8000caf6:	fd dc e3 0e 	addcs	lr,lr,r12
8000cafa:	fc 0b 01 03 	sub	r3,lr,r11
8000cafe:	f3 d9 c0 10 	bfextu	r9,r9,0x0,0x10
8000cb02:	e6 05 0d 02 	divu	r2,r3,r5
8000cb06:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000cb0a:	a5 36       	mul	r6,r2
8000cb0c:	0c 39       	cp.w	r9,r6
8000cb0e:	c0 72       	brcc	8000cb1c <__avr32_umod64+0xb4>
8000cb10:	18 09       	add	r9,r12
8000cb12:	18 39       	cp.w	r9,r12
8000cb14:	c0 43       	brcs	8000cb1c <__avr32_umod64+0xb4>
8000cb16:	0c 39       	cp.w	r9,r6
8000cb18:	f3 dc e3 09 	addcs	r9,r9,r12
8000cb1c:	f2 06 01 06 	sub	r6,r9,r6
8000cb20:	f4 08 09 4e 	lsl	lr,r10,r8
8000cb24:	f8 0a 16 10 	lsr	r10,r12,0x10
8000cb28:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000cb2c:	ec 0a 0d 02 	divu	r2,r6,r10
8000cb30:	fc 09 16 10 	lsr	r9,lr,0x10
8000cb34:	ea 02 02 4b 	mul	r11,r5,r2
8000cb38:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000cb3c:	16 39       	cp.w	r9,r11
8000cb3e:	c0 72       	brcc	8000cb4c <__avr32_umod64+0xe4>
8000cb40:	18 09       	add	r9,r12
8000cb42:	18 39       	cp.w	r9,r12
8000cb44:	c0 43       	brcs	8000cb4c <__avr32_umod64+0xe4>
8000cb46:	16 39       	cp.w	r9,r11
8000cb48:	f3 dc e3 09 	addcs	r9,r9,r12
8000cb4c:	f2 0b 01 0b 	sub	r11,r9,r11
8000cb50:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000cb54:	f6 0a 0d 0a 	divu	r10,r11,r10
8000cb58:	fd eb 11 0e 	or	lr,lr,r11<<0x10
8000cb5c:	ea 0a 02 4a 	mul	r10,r5,r10
8000cb60:	14 3e       	cp.w	lr,r10
8000cb62:	c0 72       	brcc	8000cb70 <__avr32_umod64+0x108>
8000cb64:	18 0e       	add	lr,r12
8000cb66:	18 3e       	cp.w	lr,r12
8000cb68:	c0 43       	brcs	8000cb70 <__avr32_umod64+0x108>
8000cb6a:	14 3e       	cp.w	lr,r10
8000cb6c:	fd dc e3 0e 	addcs	lr,lr,r12
8000cb70:	fc 0a 01 0a 	sub	r10,lr,r10
8000cb74:	30 0b       	mov	r11,0
8000cb76:	f4 08 0a 4a 	lsr	r10,r10,r8
8000cb7a:	c7 b8       	rjmp	8000cc70 <__avr32_umod64+0x208>
8000cb7c:	16 39       	cp.w	r9,r11
8000cb7e:	e0 8b 00 79 	brhi	8000cc70 <__avr32_umod64+0x208>
8000cb82:	f2 09 12 00 	clz	r9,r9
8000cb86:	c1 21       	brne	8000cbaa <__avr32_umod64+0x142>
8000cb88:	10 3a       	cp.w	r10,r8
8000cb8a:	5f 2b       	srhs	r11
8000cb8c:	0a 31       	cp.w	r1,r5
8000cb8e:	5f ba       	srhi	r10
8000cb90:	f7 ea 10 0a 	or	r10,r11,r10
8000cb94:	f2 0a 18 00 	cp.b	r10,r9
8000cb98:	c0 60       	breq	8000cba4 <__avr32_umod64+0x13c>
8000cb9a:	fc 08 01 0c 	sub	r12,lr,r8
8000cb9e:	e2 05 01 46 	sbc	r6,r1,r5
8000cba2:	18 9e       	mov	lr,r12
8000cba4:	0c 9b       	mov	r11,r6
8000cba6:	1c 9a       	mov	r10,lr
8000cba8:	c6 48       	rjmp	8000cc70 <__avr32_umod64+0x208>
8000cbaa:	ea 09 09 4c 	lsl	r12,r5,r9
8000cbae:	f2 06 11 20 	rsub	r6,r9,32
8000cbb2:	f6 09 09 4b 	lsl	r11,r11,r9
8000cbb6:	f0 09 09 42 	lsl	r2,r8,r9
8000cbba:	ef 46 ff f4 	st.w	r7[-12],r6
8000cbbe:	f0 06 0a 48 	lsr	r8,r8,r6
8000cbc2:	18 48       	or	r8,r12
8000cbc4:	e2 06 0a 4c 	lsr	r12,r1,r6
8000cbc8:	f4 09 09 43 	lsl	r3,r10,r9
8000cbcc:	fd d8 c0 10 	bfextu	lr,r8,0x0,0x10
8000cbd0:	f4 06 0a 4a 	lsr	r10,r10,r6
8000cbd4:	16 4a       	or	r10,r11
8000cbd6:	f0 0b 16 10 	lsr	r11,r8,0x10
8000cbda:	f8 0b 0d 04 	divu	r4,r12,r11
8000cbde:	f4 0c 16 10 	lsr	r12,r10,0x10
8000cbe2:	08 91       	mov	r1,r4
8000cbe4:	f9 e5 11 0c 	or	r12,r12,r5<<0x10
8000cbe8:	e8 0e 02 46 	mul	r6,r4,lr
8000cbec:	0c 3c       	cp.w	r12,r6
8000cbee:	c0 a2       	brcc	8000cc02 <__avr32_umod64+0x19a>
8000cbf0:	20 11       	sub	r1,1
8000cbf2:	10 0c       	add	r12,r8
8000cbf4:	10 3c       	cp.w	r12,r8
8000cbf6:	c0 63       	brcs	8000cc02 <__avr32_umod64+0x19a>
8000cbf8:	0c 3c       	cp.w	r12,r6
8000cbfa:	f7 b1 03 01 	sublo	r1,1
8000cbfe:	f9 d8 e3 0c 	addcs	r12,r12,r8
8000cc02:	0c 1c       	sub	r12,r6
8000cc04:	f5 da c0 10 	bfextu	r10,r10,0x0,0x10
8000cc08:	f8 0b 0d 04 	divu	r4,r12,r11
8000cc0c:	f5 e5 11 0b 	or	r11,r10,r5<<0x10
8000cc10:	08 96       	mov	r6,r4
8000cc12:	e8 0e 02 4e 	mul	lr,r4,lr
8000cc16:	1c 3b       	cp.w	r11,lr
8000cc18:	c0 a2       	brcc	8000cc2c <__avr32_umod64+0x1c4>
8000cc1a:	20 16       	sub	r6,1
8000cc1c:	10 0b       	add	r11,r8
8000cc1e:	10 3b       	cp.w	r11,r8
8000cc20:	c0 63       	brcs	8000cc2c <__avr32_umod64+0x1c4>
8000cc22:	1c 3b       	cp.w	r11,lr
8000cc24:	f7 b6 03 01 	sublo	r6,1
8000cc28:	f7 d8 e3 0b 	addcs	r11,r11,r8
8000cc2c:	ed e1 11 01 	or	r1,r6,r1<<0x10
8000cc30:	1c 1b       	sub	r11,lr
8000cc32:	e2 02 06 40 	mulu.d	r0,r1,r2
8000cc36:	00 9e       	mov	lr,r0
8000cc38:	02 9c       	mov	r12,r1
8000cc3a:	16 3c       	cp.w	r12,r11
8000cc3c:	e0 8b 00 08 	brhi	8000cc4c <__avr32_umod64+0x1e4>
8000cc40:	5f 06       	sreq	r6
8000cc42:	06 30       	cp.w	r0,r3
8000cc44:	5f ba       	srhi	r10
8000cc46:	ed ea 00 0a 	and	r10,r6,r10
8000cc4a:	c0 60       	breq	8000cc56 <__avr32_umod64+0x1ee>
8000cc4c:	fc 02 01 04 	sub	r4,lr,r2
8000cc50:	f8 08 01 4c 	sbc	r12,r12,r8
8000cc54:	08 9e       	mov	lr,r4
8000cc56:	e6 0e 01 0a 	sub	r10,r3,lr
8000cc5a:	f6 0c 01 4c 	sbc	r12,r11,r12
8000cc5e:	ee f1 ff f4 	ld.w	r1,r7[-12]
8000cc62:	f8 09 0a 4b 	lsr	r11,r12,r9
8000cc66:	f4 09 0a 4a 	lsr	r10,r10,r9
8000cc6a:	f8 01 09 4c 	lsl	r12,r12,r1
8000cc6e:	18 4a       	or	r10,r12
8000cc70:	2f dd       	sub	sp,-12
8000cc72:	d8 32       	popm	r0-r7,pc

Disassembly of section .exception:

8000ce00 <_evba>:
_evba:

        .org  0x000
        // Unrecoverable Exception.
_handle_Unrecoverable_Exception:
        rjmp $
8000ce00:	c0 08       	rjmp	8000ce00 <_evba>
	...

8000ce04 <_handle_TLB_Multiple_Hit>:

        .org  0x004
        // TLB Multiple Hit: UNUSED IN AVR32UC.
_handle_TLB_Multiple_Hit:
        rjmp $
8000ce04:	c0 08       	rjmp	8000ce04 <_handle_TLB_Multiple_Hit>
	...

8000ce08 <_handle_Bus_Error_Data_Fetch>:

        .org  0x008
        // Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
        rjmp $
8000ce08:	c0 08       	rjmp	8000ce08 <_handle_Bus_Error_Data_Fetch>
	...

8000ce0c <_handle_Bus_Error_Instruction_Fetch>:

        .org  0x00C
         // Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
        rjmp $
8000ce0c:	c0 08       	rjmp	8000ce0c <_handle_Bus_Error_Instruction_Fetch>
	...

8000ce10 <_handle_NMI>:

        .org  0x010
        // NMI.
_handle_NMI:
        rjmp $
8000ce10:	c0 08       	rjmp	8000ce10 <_handle_NMI>
	...

8000ce14 <_handle_Instruction_Address>:

        .org  0x014
        // Instruction Address.
_handle_Instruction_Address:
        rjmp $
8000ce14:	c0 08       	rjmp	8000ce14 <_handle_Instruction_Address>
	...

8000ce18 <_handle_ITLB_Protection>:

        .org  0x018
        // ITLB Protection.
_handle_ITLB_Protection:
        rjmp $
8000ce18:	c0 08       	rjmp	8000ce18 <_handle_ITLB_Protection>
	...

8000ce1c <_handle_Breakpoint>:

        .org  0x01C
        // Breakpoint.
_handle_Breakpoint:
        rjmp $
8000ce1c:	c0 08       	rjmp	8000ce1c <_handle_Breakpoint>
	...

8000ce20 <_handle_Illegal_Opcode>:

        .org  0x020
        // Illegal Opcode.
_handle_Illegal_Opcode:
        rjmp $
8000ce20:	c0 08       	rjmp	8000ce20 <_handle_Illegal_Opcode>
	...

8000ce24 <_handle_Unimplemented_Instruction>:

        .org  0x024
        // Unimplemented Instruction.
_handle_Unimplemented_Instruction:
        rjmp $
8000ce24:	c0 08       	rjmp	8000ce24 <_handle_Unimplemented_Instruction>
	...

8000ce28 <_handle_Privilege_Violation>:

        .org  0x028
        // Privilege Violation.
_handle_Privilege_Violation:
        rjmp $
8000ce28:	c0 08       	rjmp	8000ce28 <_handle_Privilege_Violation>
	...

8000ce2c <_handle_Floating_Point>:

        .org  0x02C
        // Floating-Point: UNUSED IN AVR32UC.
_handle_Floating_Point:
        rjmp $
8000ce2c:	c0 08       	rjmp	8000ce2c <_handle_Floating_Point>
	...

8000ce30 <_handle_Coprocessor_Absent>:

        .org  0x030
        // Coprocessor Absent: UNUSED IN AVR32UC.
_handle_Coprocessor_Absent:
        rjmp $
8000ce30:	c0 08       	rjmp	8000ce30 <_handle_Coprocessor_Absent>
	...

8000ce34 <_handle_Data_Address_Read>:

        .org  0x034
        // Data Address (Read).
_handle_Data_Address_Read:
        rjmp $
8000ce34:	c0 08       	rjmp	8000ce34 <_handle_Data_Address_Read>
	...

8000ce38 <_handle_Data_Address_Write>:

        .org  0x038
        // Data Address (Write).
_handle_Data_Address_Write:
        rjmp $
8000ce38:	c0 08       	rjmp	8000ce38 <_handle_Data_Address_Write>
	...

8000ce3c <_handle_DTLB_Protection_Read>:

        .org  0x03C
        // DTLB Protection (Read).
_handle_DTLB_Protection_Read:
        rjmp $
8000ce3c:	c0 08       	rjmp	8000ce3c <_handle_DTLB_Protection_Read>
	...

8000ce40 <_handle_DTLB_Protection_Write>:

        .org  0x040
        // DTLB Protection (Write).
_handle_DTLB_Protection_Write:
        rjmp $
8000ce40:	c0 08       	rjmp	8000ce40 <_handle_DTLB_Protection_Write>
	...

8000ce44 <_handle_DTLB_Modified>:

        .org  0x044
        // DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
        rjmp $
8000ce44:	c0 08       	rjmp	8000ce44 <_handle_DTLB_Modified>
	...

8000ce50 <_handle_ITLB_Miss>:

        .org  0x050
        // ITLB Miss: UNUSED IN AVR32UC.
_handle_ITLB_Miss:
        rjmp $
8000ce50:	c0 08       	rjmp	8000ce50 <_handle_ITLB_Miss>
	...

8000ce60 <_handle_DTLB_Miss_Read>:

        .org  0x060
        // DTLB Miss (Read): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Read:
        rjmp $
8000ce60:	c0 08       	rjmp	8000ce60 <_handle_DTLB_Miss_Read>
	...

8000ce70 <_handle_DTLB_Miss_Write>:

        .org  0x070
        // DTLB Miss (Write): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Write:
        rjmp $
8000ce70:	c0 08       	rjmp	8000ce70 <_handle_DTLB_Miss_Write>
	...

8000cf00 <_handle_Supervisor_Call>:

        .org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	lda.w   pc, SCALLYield
8000cf00:	fe cf 71 24 	sub	pc,pc,28964

8000cf04 <_int0>:
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
	rete
.endr
8000cf04:	30 0c       	mov	r12,0
8000cf06:	fe b0 c3 89 	rcall	80005618 <_get_interrupt_handler>
8000cf0a:	58 0c       	cp.w	r12,0
8000cf0c:	f8 0f 17 10 	movne	pc,r12
8000cf10:	d6 03       	rete

8000cf12 <_int1>:
8000cf12:	30 1c       	mov	r12,1
8000cf14:	fe b0 c3 82 	rcall	80005618 <_get_interrupt_handler>
8000cf18:	58 0c       	cp.w	r12,0
8000cf1a:	f8 0f 17 10 	movne	pc,r12
8000cf1e:	d6 03       	rete

8000cf20 <_int2>:
8000cf20:	30 2c       	mov	r12,2
8000cf22:	fe b0 c3 7b 	rcall	80005618 <_get_interrupt_handler>
8000cf26:	58 0c       	cp.w	r12,0
8000cf28:	f8 0f 17 10 	movne	pc,r12
8000cf2c:	d6 03       	rete

8000cf2e <_int3>:
8000cf2e:	30 3c       	mov	r12,3
8000cf30:	fe b0 c3 74 	rcall	80005618 <_get_interrupt_handler>
8000cf34:	58 0c       	cp.w	r12,0
8000cf36:	f8 0f 17 10 	movne	pc,r12
8000cf3a:	d6 03       	rete

8000cf3c <ipr_val>:
8000cf3c:	00 00 01 04 40 00 01 12 80 00 01 20 c0 00 01 2e     ....@...... ....
8000cf4c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cf5c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cf6c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cf7c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cf8c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cf9c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cfac:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cfbc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cfcc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cfdc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cfec:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cffc:	d7 03 d7 03                                         ....
