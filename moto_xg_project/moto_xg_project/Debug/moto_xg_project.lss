
moto_xg_project.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00002004  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         0000aaf0  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .exception    00000200  8000cc00  8000cc00  0000d000  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       000012b4  8000ce00  8000ce00  0000d200  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .dalign       00000004  8000e0b4  8000e0b4  0000e4b4  2**0
                  ALLOC
  6 .data         00000a3c  00000004  8000e0b8  0000e804  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .bss          0000b5b8  00000a40  8000eaf4  0000f240  2**2
                  ALLOC
  8 .comment      00000030  00000000  00000000  0000f240  2**0
                  CONTENTS, READONLY
  9 .debug_aranges 00001688  00000000  00000000  0000f270  2**3
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_pubnames 00003666  00000000  00000000  000108f8  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_info   0002c6cd  00000000  00000000  00013f5e  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_abbrev 000072d0  00000000  00000000  0004062b  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_line   0000d464  00000000  00000000  000478fb  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_frame  00003d30  00000000  00000000  00054d60  2**2
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_str    00008033  00000000  00000000  00058a90  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_loc    0000f384  00000000  00000000  00060ac3  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .stack        00001000  00017000  00017000  00000400  2**0
                  ALLOC
 18 .debug_ranges 00001750  00000000  00000000  0006fe48  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_trampoline>:

  .global _trampoline
  .type _trampoline, @function
_trampoline:
  // Jump to program start.
  rjmp    program_start
80000000:	e0 8f 10 00 	bral	80002000 <program_start>
	...

80002000 <program_start>:
	   // rjmp    program_start

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002000:	fe cf c5 70 	sub	pc,pc,-14992

Disassembly of section .text:

80002004 <DeviceManagement_brdcst_func>:
80002004:	f8 c8 ff fe 	sub	r8,r12,-2
void DeviceManagement_brdcst_func(xcmp_fragment_t * xcmp)
{
		U16 temp = 0;
		/*point to xcmp payload*/
		DeviceManagement_brdcast_t *ptr = (DeviceManagement_brdcast_t* )xcmp->u8;
		temp  = ptr->Device_Type << 8;
80002008:	f1 2a 00 01 	ld.sb	r10,r8[1]
		//log("DeviceManagement_brdcst...\n");
		//log("temp: %x\n", temp);
		//log("xnl_information.logical_address: %x\n", xnl_information.logical_address);
		//temp  = xcmp->u8[1] << 8;
		//temp |= xcmp->u8[2];
		if (temp == xnl_information.logical_address)
8000200c:	48 c9       	lddpc	r9,8000203c <DeviceManagement_brdcst_func+0x38>
8000200e:	92 39       	ld.sh	r9,r9[0x6]
{
		U16 temp = 0;
		/*point to xcmp payload*/
		DeviceManagement_brdcast_t *ptr = (DeviceManagement_brdcast_t* )xcmp->u8;
		temp  = ptr->Device_Type << 8;
		temp |= ptr->XCMP_Device_ID;
80002010:	11 a8       	ld.ub	r8,r8[0x2]
80002012:	f1 ea 10 88 	or	r8,r8,r10<<0x8
80002016:	f0 09 19 00 	cp.h	r9,r8
8000201a:	5e 1c       	retne	r12
		//log("xnl_information.logical_address: %x\n", xnl_information.logical_address);
		//temp  = xcmp->u8[1] << 8;
		//temp |= xcmp->u8[2];
		if (temp == xnl_information.logical_address)
		{
			if (xcmp->u8[0] == 0x01)
8000201c:	19 a9       	ld.ub	r9,r12[0x2]
8000201e:	30 18       	mov	r8,1
80002020:	f0 09 18 00 	cp.b	r9,r8
80002024:	c0 61       	brne	80002030 <DeviceManagement_brdcst_func+0x2c>
			//if(ptr->Function == Start)
			{
				//Enable Option Board
				bunchofrandomstatusflags |= 0x00000002;
80002026:	48 78       	lddpc	r8,80002040 <DeviceManagement_brdcst_func+0x3c>
80002028:	70 09       	ld.w	r9,r8[0x0]
8000202a:	a1 b9       	sbr	r9,0x1
8000202c:	91 09       	st.w	r8[0x0],r9
8000202e:	5e fc       	retal	r12
			}
			else
			{
				//Disable Option Board.
				//log("Device State : %d\n", );
				bunchofrandomstatusflags &= 0xFFFFFFFD;
80002030:	48 48       	lddpc	r8,80002040 <DeviceManagement_brdcst_func+0x3c>
80002032:	70 09       	ld.w	r9,r8[0x0]
80002034:	a1 d9       	cbr	r9,0x1
80002036:	91 09       	st.w	r8[0x0],r9
80002038:	5e fc       	retal	r12
8000203a:	00 00       	add	r0,r0
8000203c:	00 00       	add	r0,r0
8000203e:	97 1c       	st.w	r11[0x4],r12
80002040:	00 00       	add	r0,r0
80002042:	0d 98       	ld.ub	r8,r6[0x1]

80002044 <Volume_brdcst_func>:
	//log("Attenuator_Number: %x \n",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
	
	//log("Audio_Parameter: %x \n", ptr->Audio_Parameter);
	
	
}
80002044:	5e fc       	retal	r12

80002046 <AudioRoutingControl_brdcst_func>:
	//
	//log("\n\r Audio-Function: %x \n\r", xcmp->u8[3+j*2-1]);
	
	
	
}
80002046:	5e fc       	retal	r12

80002048 <vApplicationIdleHook>:
}

void vApplicationIdleHook( void )
{
	/* This hook function does nothing but increment a counter. */
	ulIdleCycleCount++;
80002048:	48 38       	lddpc	r8,80002054 <vApplicationIdleHook+0xc>
8000204a:	70 09       	ld.w	r9,r8[0x0]
8000204c:	2f f9       	sub	r9,-1
8000204e:	91 09       	st.w	r8[0x0],r9
	
}
80002050:	5e fc       	retal	r12
80002052:	00 00       	add	r0,r0
80002054:	00 00       	add	r0,r0
80002056:	0a 64       	and	r4,r5

80002058 <app_payload_tx_proc>:

}


static void app_payload_tx_proc(void  * payload)
{
80002058:	d4 01       	pushm	lr
  log("R");
8000205a:	48 3c       	lddpc	r12,80002064 <app_payload_tx_proc+0xc>
8000205c:	f0 1f 00 03 	mcall	80002068 <app_payload_tx_proc+0x10>
  //
  //
  //set_payload_idle(payload);


}
80002060:	d8 02       	popm	pc
80002062:	00 00       	add	r0,r0
80002064:	80 00       	ld.sh	r0,r0[0x0]
80002066:	ce 00       	breq	80002026 <DeviceManagement_brdcst_func+0x22>
80002068:	80 00       	ld.sh	r0,r0[0x0]
8000206a:	6d ec       	ld.w	r12,r6[0x78]

8000206c <app_payload_rx_proc>:
	}
}


static void app_payload_rx_proc(void  * payload)
{
8000206c:	d4 01       	pushm	lr
	static  U8 times_counter = 0;
	
	times_counter++;
8000206e:	48 99       	lddpc	r9,80002090 <app_payload_rx_proc+0x24>
80002070:	13 88       	ld.ub	r8,r9[0x0]
80002072:	2f f8       	sub	r8,-1
80002074:	b2 88       	st.b	r9[0x0],r8
	if (times_counter == 3)
80002076:	30 39       	mov	r9,3
80002078:	f2 08 18 00 	cp.b	r8,r9
8000207c:	c0 71       	brne	8000208a <app_payload_rx_proc+0x1e>
	{
		times_counter = 0 ;
8000207e:	30 09       	mov	r9,0
80002080:	48 48       	lddpc	r8,80002090 <app_payload_rx_proc+0x24>
80002082:	b0 89       	st.b	r8[0x0],r9
		log("\n\r w: \n\r");
80002084:	48 4c       	lddpc	r12,80002094 <app_payload_rx_proc+0x28>
80002086:	f0 1f 00 05 	mcall	80002098 <app_payload_rx_proc+0x2c>
	}
	//log("\n\r w: \n\r");
	if (AMBE_tx_flag)//本地发送方的mic录音
8000208a:	48 58       	lddpc	r8,8000209c <app_payload_rx_proc+0x30>
8000208c:	11 88       	ld.ub	r8,r8[0x0]
	}
	
	//payload_fragment_t * ptr = (payload_fragment_t *)payload;
	//set_payload_idle(payload);

}
8000208e:	d8 02       	popm	pc
80002090:	00 00       	add	r0,r0
80002092:	0a 60       	and	r0,r5
80002094:	80 00       	ld.sh	r0,r0[0x0]
80002096:	ce 04       	brge	80002056 <vApplicationIdleHook+0xe>
80002098:	80 00       	ld.sh	r0,r0[0x0]
8000209a:	6d ec       	ld.w	r12,r6[0x78]
8000209c:	00 00       	add	r0,r0
8000209e:	0a 49       	or	r9,r5

800020a0 <FD_brdcst_func>:
	
	
}

void FD_brdcst_func(xcmp_fragment_t * xcmp)
{
800020a0:	d4 01       	pushm	lr
	
	
	log("\n\r Forward Data Broadcast \n\r");
800020a2:	48 3c       	lddpc	r12,800020ac <FD_brdcst_func+0xc>
800020a4:	f0 1f 00 03 	mcall	800020b0 <FD_brdcst_func+0x10>
	
}
800020a8:	d8 02       	popm	pc
800020aa:	00 00       	add	r0,r0
800020ac:	80 00       	ld.sh	r0,r0[0x0]
800020ae:	ce 10       	breq	80002070 <app_payload_rx_proc+0x4>
800020b0:	80 00       	ld.sh	r0,r0[0x0]
800020b2:	6d ec       	ld.w	r12,r6[0x78]

800020b4 <FD_reply_func>:
	
	
}

void FD_reply_func(xcmp_fragment_t * xcmp)
{
800020b4:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Reply \n\r");
800020b6:	48 3c       	lddpc	r12,800020c0 <FD_reply_func+0xc>
800020b8:	f0 1f 00 03 	mcall	800020c4 <FD_reply_func+0x10>
	
	
}
800020bc:	d8 02       	popm	pc
800020be:	00 00       	add	r0,r0
800020c0:	80 00       	ld.sh	r0,r0[0x0]
800020c2:	ce 30       	breq	80002088 <app_payload_rx_proc+0x1c>
800020c4:	80 00       	ld.sh	r0,r0[0x0]
800020c6:	6d ec       	ld.w	r12,r6[0x78]

800020c8 <FD_request_func>:
}



void FD_request_func(xcmp_fragment_t * xcmp)
{
800020c8:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Request \n\r");
800020ca:	48 3c       	lddpc	r12,800020d4 <FD_request_func+0xc>
800020cc:	f0 1f 00 03 	mcall	800020d8 <FD_request_func+0x10>
	
	
}
800020d0:	d8 02       	popm	pc
800020d2:	00 00       	add	r0,r0
800020d4:	80 00       	ld.sh	r0,r0[0x0]
800020d6:	ce 4c       	rcall	8000229e <ButtonConfig_reply_func+0x16>
800020d8:	80 00       	ld.sh	r0,r0[0x0]
800020da:	6d ec       	ld.w	r12,r6[0x78]

800020dc <EnOB_brdcst_func>:
	
	
}

void EnOB_brdcst_func(xcmp_fragment_t * xcmp)
{
800020dc:	d4 01       	pushm	lr
	
	
	log("\n\r En_OB Broadcast \n\r");
800020de:	48 3c       	lddpc	r12,800020e8 <EnOB_brdcst_func+0xc>
800020e0:	f0 1f 00 03 	mcall	800020ec <EnOB_brdcst_func+0x10>
}
800020e4:	d8 02       	popm	pc
800020e6:	00 00       	add	r0,r0
800020e8:	80 00       	ld.sh	r0,r0[0x0]
800020ea:	ce 68       	rjmp	800022b6 <ButtonConfig_reply_func+0x2e>
800020ec:	80 00       	ld.sh	r0,r0[0x0]
800020ee:	6d ec       	ld.w	r12,r6[0x78]

800020f0 <EnOB_reply_func>:
}



void EnOB_reply_func(xcmp_fragment_t * xcmp)
{
800020f0:	eb cd 40 80 	pushm	r7,lr
800020f4:	18 97       	mov	r7,r12
		/*point to xcmp payload*/
	//En_OB_Control_reply_t *ptr = (En_OB_Control_reply_t* )xcmp->u8;
	//log("\n\r Xcmp_opcode: %x \n\r", xcmp->xcmp_opcode);
	
	if (xcmp->u8[0]== xcmp_Res_Success)
800020f6:	19 a9       	ld.ub	r9,r12[0x2]
800020f8:	30 08       	mov	r8,0
800020fa:	f0 09 18 00 	cp.b	r9,r8
800020fe:	c1 91       	brne	80002130 <EnOB_reply_func+0x40>
	{
		if (xcmp->u8[1] == EN_OB_Enter)
80002100:	19 b8       	ld.ub	r8,r12[0x3]
80002102:	30 19       	mov	r9,1
80002104:	f2 08 18 00 	cp.b	r8,r9
80002108:	c0 61       	brne	80002114 <EnOB_reply_func+0x24>
		{
		
			log("\n\r En_OB_Enter OK \n\r");
8000210a:	49 0c       	lddpc	r12,80002148 <EnOB_reply_func+0x58>
8000210c:	f0 1f 00 10 	mcall	8000214c <EnOB_reply_func+0x5c>
80002110:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else if (xcmp->u8[1] == EN_OB_Exit )
80002114:	58 08       	cp.w	r8,0
80002116:	c0 61       	brne	80002122 <EnOB_reply_func+0x32>
		{
			log("\n\r En_OB_Exit OK \n\r");
80002118:	48 ec       	lddpc	r12,80002150 <EnOB_reply_func+0x60>
8000211a:	f0 1f 00 0d 	mcall	8000214c <EnOB_reply_func+0x5c>
8000211e:	e3 cd 80 80 	ldm	sp++,r7,pc
		}
		else
		{
			
			log("\n\r En_OB_Control: %x \n\r", xcmp->u8[1]);
80002122:	1a d8       	st.w	--sp,r8
80002124:	48 cc       	lddpc	r12,80002154 <EnOB_reply_func+0x64>
80002126:	f0 1f 00 0a 	mcall	8000214c <EnOB_reply_func+0x5c>
8000212a:	2f fd       	sub	sp,-4
8000212c:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r En_OB_Control error \n\r");
80002130:	48 ac       	lddpc	r12,80002158 <EnOB_reply_func+0x68>
80002132:	f0 1f 00 07 	mcall	8000214c <EnOB_reply_func+0x5c>
		log("\n\r En_OB_result: %x \n\r", xcmp->u8[0]);
80002136:	0f a8       	ld.ub	r8,r7[0x2]
80002138:	1a d8       	st.w	--sp,r8
8000213a:	48 9c       	lddpc	r12,8000215c <EnOB_reply_func+0x6c>
8000213c:	f0 1f 00 04 	mcall	8000214c <EnOB_reply_func+0x5c>
80002140:	2f fd       	sub	sp,-4
80002142:	e3 cd 80 80 	ldm	sp++,r7,pc
80002146:	00 00       	add	r0,r0
80002148:	80 00       	ld.sh	r0,r0[0x0]
8000214a:	ce 80       	breq	8000211a <EnOB_reply_func+0x2a>
8000214c:	80 00       	ld.sh	r0,r0[0x0]
8000214e:	6d ec       	ld.w	r12,r6[0x78]
80002150:	80 00       	ld.sh	r0,r0[0x0]
80002152:	ce 98       	rjmp	80002324 <ShutDown_brdcst_func+0x28>
80002154:	80 00       	ld.sh	r0,r0[0x0]
80002156:	ce ac       	rcall	8000232a <ShutDown_brdcst_func+0x2e>
80002158:	80 00       	ld.sh	r0,r0[0x0]
8000215a:	ce c4       	brge	80002132 <EnOB_reply_func+0x42>
8000215c:	80 00       	ld.sh	r0,r0[0x0]
8000215e:	ce e0       	breq	8000213a <EnOB_reply_func+0x4a>

80002160 <SingleDetection_brdcst_func>:
	
}


void SingleDetection_brdcst_func(xcmp_fragment_t * xcmp)
{
80002160:	eb cd 40 80 	pushm	r7,lr
80002164:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == 0x11)
80002166:	19 a9       	ld.ub	r9,r12[0x2]
80002168:	31 18       	mov	r8,17
8000216a:	f0 09 18 00 	cp.b	r9,r8
8000216e:	c0 91       	brne	80002180 <SingleDetection_brdcst_func+0x20>
	{
		log("\n\r DMR_CSBK OK \n\r");
80002170:	48 ac       	lddpc	r12,80002198 <SingleDetection_brdcst_func+0x38>
80002172:	f0 1f 00 0b 	mcall	8000219c <SingleDetection_brdcst_func+0x3c>
		get_time_okay = TRUE;
80002176:	30 19       	mov	r9,1
80002178:	48 a8       	lddpc	r8,800021a0 <SingleDetection_brdcst_func+0x40>
8000217a:	b0 89       	st.b	r8[0x0],r9
8000217c:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	//if(xcmp->u8[1] == 0x11)
	else
	{
		log("SIGBRCST error\n");
80002180:	48 9c       	lddpc	r12,800021a4 <SingleDetection_brdcst_func+0x44>
80002182:	f0 1f 00 07 	mcall	8000219c <SingleDetection_brdcst_func+0x3c>
		log("\Signal_type: %X \n\r", xcmp->u8[0] );
80002186:	0f a8       	ld.ub	r8,r7[0x2]
80002188:	1a d8       	st.w	--sp,r8
8000218a:	48 8c       	lddpc	r12,800021a8 <SingleDetection_brdcst_func+0x48>
8000218c:	f0 1f 00 04 	mcall	8000219c <SingleDetection_brdcst_func+0x3c>
80002190:	2f fd       	sub	sp,-4
80002192:	e3 cd 80 80 	ldm	sp++,r7,pc
80002196:	00 00       	add	r0,r0
80002198:	80 00       	ld.sh	r0,r0[0x0]
8000219a:	ce f8       	rjmp	80002378 <DataSession_reply_func+0x4c>
8000219c:	80 00       	ld.sh	r0,r0[0x0]
8000219e:	6d ec       	ld.w	r12,r6[0x78]
800021a0:	00 00       	add	r0,r0
800021a2:	00 04       	add	r4,r0
800021a4:	80 00       	ld.sh	r0,r0[0x0]
800021a6:	cf 0c       	rcall	80002386 <DataSession_reply_func+0x5a>
800021a8:	80 00       	ld.sh	r0,r0[0x0]
800021aa:	cf 1c       	rcall	8000238c <CallControl_brdcst_func+0x4>

800021ac <ButtonConfig_brdcst_func>:
	
}


void ButtonConfig_brdcst_func(xcmp_fragment_t * xcmp)
{
800021ac:	d4 31       	pushm	r0-r7,lr
	U8 Num_Button =0;
	U8 i = 0 ;
	/*point to xcmp payload*/
	ButtonConfig_brdcst_t  *ptr = (ButtonConfig_brdcst_t* )xcmp->u8;
800021ae:	f8 c7 ff fe 	sub	r7,r12,-2
	
	Num_Button = ptr->NumOfButtons;
800021b2:	0f 95       	ld.ub	r5,r7[0x1]
	
	log("\n\r ButtonConfig_broadcast  \n\r"  );
800021b4:	4a bc       	lddpc	r12,80002260 <ButtonConfig_brdcst_func+0xb4>
800021b6:	f0 1f 00 2c 	mcall	80002264 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r Function: %X \n\r" , ptr->Function );
800021ba:	0f 88       	ld.ub	r8,r7[0x0]
800021bc:	1a d8       	st.w	--sp,r8
800021be:	4a bc       	lddpc	r12,80002268 <ButtonConfig_brdcst_func+0xbc>
800021c0:	f0 1f 00 29 	mcall	80002264 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
800021c4:	1a d5       	st.w	--sp,r5
800021c6:	4a ac       	lddpc	r12,8000226c <ButtonConfig_brdcst_func+0xc0>
800021c8:	f0 1f 00 27 	mcall	80002264 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
800021cc:	0f a8       	ld.ub	r8,r7[0x2]
800021ce:	1a d8       	st.w	--sp,r8
800021d0:	4a 8c       	lddpc	r12,80002270 <ButtonConfig_brdcst_func+0xc4>
800021d2:	f0 1f 00 25 	mcall	80002264 <ButtonConfig_brdcst_func+0xb8>
	
	for (i; i<Num_Button; i++)
800021d6:	2f dd       	sub	sp,-12
800021d8:	58 05       	cp.w	r5,0
800021da:	c4 10       	breq	8000225c <ButtonConfig_brdcst_func+0xb0>
800021dc:	30 06       	mov	r6,0
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
800021de:	4a 64       	lddpc	r4,80002274 <ButtonConfig_brdcst_func+0xc8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
800021e0:	4a 63       	lddpc	r3,80002278 <ButtonConfig_brdcst_func+0xcc>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
800021e2:	4a 72       	lddpc	r2,8000227c <ButtonConfig_brdcst_func+0xd0>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
800021e4:	4a 71       	lddpc	r1,80002280 <ButtonConfig_brdcst_func+0xd4>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
800021e6:	4a 80       	lddpc	r0,80002284 <ButtonConfig_brdcst_func+0xd8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
800021e8:	0f b9       	ld.ub	r9,r7[0x3]
800021ea:	0f c8       	ld.ub	r8,r7[0x4]
800021ec:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800021f0:	1a d8       	st.w	--sp,r8
800021f2:	1a d6       	st.w	--sp,r6
800021f4:	08 9c       	mov	r12,r4
800021f6:	f0 1f 00 1c 	mcall	80002264 <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
800021fa:	0f d9       	ld.ub	r9,r7[0x5]
800021fc:	0f e8       	ld.ub	r8,r7[0x6]
800021fe:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002202:	1a d8       	st.w	--sp,r8
80002204:	1a d6       	st.w	--sp,r6
80002206:	06 9c       	mov	r12,r3
80002208:	f0 1f 00 17 	mcall	80002264 <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
8000220c:	0f f9       	ld.ub	r9,r7[0x7]
8000220e:	ef 38 00 08 	ld.ub	r8,r7[8]
80002212:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002216:	1a d8       	st.w	--sp,r8
80002218:	1a d6       	st.w	--sp,r6
8000221a:	04 9c       	mov	r12,r2
8000221c:	f0 1f 00 12 	mcall	80002264 <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
80002220:	ef 39 00 09 	ld.ub	r9,r7[9]
80002224:	ef 38 00 0a 	ld.ub	r8,r7[10]
80002228:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000222c:	1a d8       	st.w	--sp,r8
8000222e:	1a d6       	st.w	--sp,r6
80002230:	02 9c       	mov	r12,r1
80002232:	f0 1f 00 0d 	mcall	80002264 <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
80002236:	2f 8d       	sub	sp,-32
80002238:	ef 39 00 0b 	ld.ub	r9,r7[11]
8000223c:	ef 38 00 0c 	ld.ub	r8,r7[12]
80002240:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002244:	1a d8       	st.w	--sp,r8
80002246:	1a d6       	st.w	--sp,r6
80002248:	00 9c       	mov	r12,r0
8000224a:	f0 1f 00 07 	mcall	80002264 <ButtonConfig_brdcst_func+0xb8>
8000224e:	2f f6       	sub	r6,-1
80002250:	2f 67       	sub	r7,-10
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
80002252:	2f ed       	sub	sp,-8
80002254:	ec 05 18 00 	cp.b	r5,r6
80002258:	fe 9b ff c8 	brhi	800021e8 <ButtonConfig_brdcst_func+0x3c>
8000225c:	d8 32       	popm	r0-r7,pc
8000225e:	00 00       	add	r0,r0
80002260:	80 00       	ld.sh	r0,r0[0x0]
80002262:	cf 30       	breq	80002248 <ButtonConfig_brdcst_func+0x9c>
80002264:	80 00       	ld.sh	r0,r0[0x0]
80002266:	6d ec       	ld.w	r12,r6[0x78]
80002268:	80 00       	ld.sh	r0,r0[0x0]
8000226a:	cf 50       	breq	80002254 <ButtonConfig_brdcst_func+0xa8>
8000226c:	80 00       	ld.sh	r0,r0[0x0]
8000226e:	cf 64       	brge	8000225a <ButtonConfig_brdcst_func+0xae>
80002270:	80 00       	ld.sh	r0,r0[0x0]
80002272:	cf 7c       	rcall	80002460 <TransmitControl_reply_func+0x4c>
80002274:	80 00       	ld.sh	r0,r0[0x0]
80002276:	cf 9c       	rcall	80002468 <TransmitControl_reply_func+0x54>
80002278:	80 00       	ld.sh	r0,r0[0x0]
8000227a:	cf c4       	brge	80002272 <ButtonConfig_brdcst_func+0xc6>
8000227c:	80 00       	ld.sh	r0,r0[0x0]
8000227e:	cf ec       	rcall	8000247a <AudioRoutingControl_reply_func+0x6>
80002280:	80 00       	ld.sh	r0,r0[0x0]
80002282:	d0 10       	acall	0x1
80002284:	80 00       	ld.sh	r0,r0[0x0]
80002286:	d0 38       	*unknown*

80002288 <ButtonConfig_reply_func>:
	}
	
}

void ButtonConfig_reply_func(xcmp_fragment_t * xcmp)
{
80002288:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	ButtonConfig_reply_t *ptr = (ButtonConfig_reply_t* )(xcmp->u8);
8000228c:	f8 c7 ff fe 	sub	r7,r12,-2
	if (ptr->Result == xcmp_Res_Success)
80002290:	0f 89       	ld.ub	r9,r7[0x0]
80002292:	30 08       	mov	r8,0
80002294:	f0 09 18 00 	cp.b	r9,r8
80002298:	c0 c1       	brne	800022b0 <ButtonConfig_reply_func+0x28>
	{
		log("\n\r Button_Config OK \n\r");
8000229a:	48 9c       	lddpc	r12,800022bc <ButtonConfig_reply_func+0x34>
8000229c:	f0 1f 00 09 	mcall	800022c0 <ButtonConfig_reply_func+0x38>
		
		log("\n\r Function: %X \n\r" , ptr->Function );
800022a0:	0f 98       	ld.ub	r8,r7[0x1]
800022a2:	1a d8       	st.w	--sp,r8
800022a4:	48 8c       	lddpc	r12,800022c4 <ButtonConfig_reply_func+0x3c>
800022a6:	f0 1f 00 07 	mcall	800022c0 <ButtonConfig_reply_func+0x38>
800022aa:	2f fd       	sub	sp,-4
800022ac:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r Button_Request error \n\r");
800022b0:	48 6c       	lddpc	r12,800022c8 <ButtonConfig_reply_func+0x40>
800022b2:	f0 1f 00 04 	mcall	800022c0 <ButtonConfig_reply_func+0x38>
800022b6:	e3 cd 80 80 	ldm	sp++,r7,pc
800022ba:	00 00       	add	r0,r0
800022bc:	80 00       	ld.sh	r0,r0[0x0]
800022be:	d0 5c       	*unknown*
800022c0:	80 00       	ld.sh	r0,r0[0x0]
800022c2:	6d ec       	ld.w	r12,r6[0x78]
800022c4:	80 00       	ld.sh	r0,r0[0x0]
800022c6:	cf 50       	breq	800022b0 <ButtonConfig_reply_func+0x28>
800022c8:	80 00       	ld.sh	r0,r0[0x0]
800022ca:	d0 74       	*unknown*

800022cc <BatteryLevel_brdcst_func>:
	
}


void BatteryLevel_brdcst_func(xcmp_fragment_t * xcmp)
{
800022cc:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	BatteryLevel_brdcast_t *ptr = (BatteryLevel_brdcast_t* )(xcmp->u8);
800022d0:	f8 c7 ff fe 	sub	r7,r12,-2
	if(ptr->State == Battery_Okay)
800022d4:	0f 89       	ld.ub	r9,r7[0x0]
800022d6:	30 08       	mov	r8,0
800022d8:	f0 09 18 00 	cp.b	r9,r8
800022dc:	c0 40       	breq	800022e4 <BatteryLevel_brdcst_func+0x18>
		;//log("\n Battery Okay\n");
	else
		log("\n Battery Low !!!\n");
800022de:	48 5c       	lddpc	r12,800022f0 <BatteryLevel_brdcst_func+0x24>
800022e0:	f0 1f 00 05 	mcall	800022f4 <BatteryLevel_brdcst_func+0x28>
		
	//log("\n Battery charge: %X \n" , ptr->Charge);
	//log("\n Battery voltage: %X \n" , ptr->Voltage);
	
	Battery_Flag = ptr->State;
800022e4:	0f 89       	ld.ub	r9,r7[0x0]
800022e6:	48 58       	lddpc	r8,800022f8 <BatteryLevel_brdcst_func+0x2c>
800022e8:	b0 89       	st.b	r8[0x0],r9

}
800022ea:	e3 cd 80 80 	ldm	sp++,r7,pc
800022ee:	00 00       	add	r0,r0
800022f0:	80 00       	ld.sh	r0,r0[0x0]
800022f2:	d0 90       	acall	0x9
800022f4:	80 00       	ld.sh	r0,r0[0x0]
800022f6:	6d ec       	ld.w	r12,r6[0x78]
800022f8:	00 00       	add	r0,r0
800022fa:	0a 41       	or	r1,r5

800022fc <ShutDown_brdcst_func>:
		log("ID:  %X \n", xcmp->u8[2]);
	}
	
}
void ShutDown_brdcst_func(xcmp_fragment_t * xcmp)
{
800022fc:	d4 01       	pushm	lr
	if (xcmp->u8[0] == Shut_Down_Device)
800022fe:	19 a8       	ld.ub	r8,r12[0x2]
80002300:	30 19       	mov	r9,1
80002302:	f2 08 18 00 	cp.b	r8,r9
80002306:	c0 51       	brne	80002310 <ShutDown_brdcst_func+0x14>
	{
		log("Shut_Down_Device \n");
80002308:	48 6c       	lddpc	r12,80002320 <ShutDown_brdcst_func+0x24>
8000230a:	f0 1f 00 07 	mcall	80002324 <ShutDown_brdcst_func+0x28>
8000230e:	d8 02       	popm	pc
		
	}
	else if(xcmp->u8[0] == Reset_Device)
80002310:	30 29       	mov	r9,2
80002312:	f2 08 18 00 	cp.b	r8,r9
80002316:	c0 41       	brne	8000231e <ShutDown_brdcst_func+0x22>
	{
		log("Reset_Device \n");
80002318:	48 4c       	lddpc	r12,80002328 <ShutDown_brdcst_func+0x2c>
8000231a:	f0 1f 00 03 	mcall	80002324 <ShutDown_brdcst_func+0x28>
8000231e:	d8 02       	popm	pc
80002320:	80 00       	ld.sh	r0,r0[0x0]
80002322:	d0 a4       	*unknown*
80002324:	80 00       	ld.sh	r0,r0[0x0]
80002326:	6d ec       	ld.w	r12,r6[0x78]
80002328:	80 00       	ld.sh	r0,r0[0x0]
8000232a:	d0 b8       	*unknown*

8000232c <DataSession_reply_func>:
	
	
}

void DataSession_reply_func(xcmp_fragment_t * xcmp)
{
8000232c:	eb cd 40 80 	pushm	r7,lr
80002330:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
80002332:	19 a9       	ld.ub	r9,r12[0x2]
80002334:	30 08       	mov	r8,0
80002336:	f0 09 18 00 	cp.b	r9,r8
8000233a:	c0 61       	brne	80002346 <DataSession_reply_func+0x1a>
	{
		log("DATArep OK \n");
8000233c:	48 dc       	lddpc	r12,80002370 <DataSession_reply_func+0x44>
8000233e:	f0 1f 00 0e 	mcall	80002374 <DataSession_reply_func+0x48>
80002342:	e3 cd 80 80 	ldm	sp++,r7,pc
		//log("ID: %X \n", xcmp->u8[2]);
		
	}
	else
	{	
		log("DATArep error \n");
80002346:	48 dc       	lddpc	r12,80002378 <DataSession_reply_func+0x4c>
80002348:	f0 1f 00 0b 	mcall	80002374 <DataSession_reply_func+0x48>
		log("Result:  %X \n", xcmp->u8[0]);
8000234c:	0f a8       	ld.ub	r8,r7[0x2]
8000234e:	1a d8       	st.w	--sp,r8
80002350:	48 bc       	lddpc	r12,8000237c <DataSession_reply_func+0x50>
80002352:	f0 1f 00 09 	mcall	80002374 <DataSession_reply_func+0x48>
		log("Func:  %X \n", xcmp->u8[1]);
80002356:	0f b8       	ld.ub	r8,r7[0x3]
80002358:	1a d8       	st.w	--sp,r8
8000235a:	48 ac       	lddpc	r12,80002380 <DataSession_reply_func+0x54>
8000235c:	f0 1f 00 06 	mcall	80002374 <DataSession_reply_func+0x48>
		log("ID:  %X \n", xcmp->u8[2]);
80002360:	0f c8       	ld.ub	r8,r7[0x4]
80002362:	1a d8       	st.w	--sp,r8
80002364:	48 8c       	lddpc	r12,80002384 <DataSession_reply_func+0x58>
80002366:	f0 1f 00 04 	mcall	80002374 <DataSession_reply_func+0x48>
8000236a:	2f dd       	sub	sp,-12
8000236c:	e3 cd 80 80 	ldm	sp++,r7,pc
80002370:	80 00       	ld.sh	r0,r0[0x0]
80002372:	d0 c8       	*unknown*
80002374:	80 00       	ld.sh	r0,r0[0x0]
80002376:	6d ec       	ld.w	r12,r6[0x78]
80002378:	80 00       	ld.sh	r0,r0[0x0]
8000237a:	d0 d8       	*unknown*
8000237c:	80 00       	ld.sh	r0,r0[0x0]
8000237e:	d0 e8       	*unknown*
80002380:	80 00       	ld.sh	r0,r0[0x0]
80002382:	d0 f8       	*unknown*
80002384:	80 00       	ld.sh	r0,r0[0x0]
80002386:	d1 04       	*unknown*

80002388 <CallControl_brdcst_func>:
	
}


void CallControl_brdcst_func(xcmp_fragment_t * xcmp)
{
80002388:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	CallControl_brdcst_t *ptr = (CallControl_brdcst_t* )xcmp->u8;
8000238c:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  CallControl brst \n\r ");
	//log("\n\r  Call_type: %x \n\r ", ptr->Calltype );
	log("\n\r  Call_state: %x \n\r ", ptr->Callstate );
80002390:	0f 98       	ld.ub	r8,r7[0x1]
80002392:	1a d8       	st.w	--sp,r8
80002394:	48 bc       	lddpc	r12,800023c0 <CallControl_brdcst_func+0x38>
80002396:	f0 1f 00 0c 	mcall	800023c4 <CallControl_brdcst_func+0x3c>
	if (ptr->Callstate == Call_Ended)//0x03
8000239a:	2f fd       	sub	sp,-4
8000239c:	0f 99       	ld.ub	r9,r7[0x1]
8000239e:	30 38       	mov	r8,3
800023a0:	f0 09 18 00 	cp.b	r9,r8
800023a4:	c0 41       	brne	800023ac <CallControl_brdcst_func+0x24>
	{
		//恢复正常语音路径通道
		//xcmp_audio_route_revert();
		Call_Begin = 0;
800023a6:	30 09       	mov	r9,0
800023a8:	48 88       	lddpc	r8,800023c8 <CallControl_brdcst_func+0x40>
800023aa:	b0 89       	st.b	r8[0x0],r9
		
	}
	
	if (ptr->Callstate == Call_Initiated)//0x04
800023ac:	0f 99       	ld.ub	r9,r7[0x1]
800023ae:	30 48       	mov	r8,4
800023b0:	f0 09 18 00 	cp.b	r9,r8
800023b4:	c0 41       	brne	800023bc <CallControl_brdcst_func+0x34>
	{
		Call_Begin = 1;
800023b6:	30 19       	mov	r9,1
800023b8:	48 48       	lddpc	r8,800023c8 <CallControl_brdcst_func+0x40>
800023ba:	b0 89       	st.b	r8[0x0],r9
800023bc:	e3 cd 80 80 	ldm	sp++,r7,pc
800023c0:	80 00       	ld.sh	r0,r0[0x0]
800023c2:	d1 10       	acall	0x11
800023c4:	80 00       	ld.sh	r0,r0[0x0]
800023c6:	6d ec       	ld.w	r12,r6[0x78]
800023c8:	00 00       	add	r0,r0
800023ca:	0a 4b       	or	r11,r5

800023cc <TransmitControl_brdcst_func>:

}


void TransmitControl_brdcst_func(xcmp_fragment_t * xcmp)
{
800023cc:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	TransmitControl_brdcast_t *ptr = (TransmitControl_brdcast_t* )xcmp->u8;
800023d0:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  TransmitControl broadcast \n\r ");
	//log("\n\r  Mode_Of_Operation: %x \n\r ", ptr->Mode_Of_Operation );
	if (ptr->State == 0x00)
800023d4:	0f 99       	ld.ub	r9,r7[0x1]
800023d6:	30 08       	mov	r8,0
800023d8:	f0 09 18 00 	cp.b	r9,r8
800023dc:	c0 71       	brne	800023ea <TransmitControl_brdcst_func+0x1e>
	{
		log("\n\r  Standby-Receive \n\r ");
800023de:	48 ac       	lddpc	r12,80002404 <TransmitControl_brdcst_func+0x38>
800023e0:	f0 1f 00 0a 	mcall	80002408 <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 0;
800023e4:	30 09       	mov	r9,0
800023e6:	48 a8       	lddpc	r8,8000240c <TransmitControl_brdcst_func+0x40>
800023e8:	b0 89       	st.b	r8[0x0],r9
	}
	if (ptr->State == 0x01)
800023ea:	0f 99       	ld.ub	r9,r7[0x1]
800023ec:	30 18       	mov	r8,1
800023ee:	f0 09 18 00 	cp.b	r9,r8
800023f2:	c0 71       	brne	80002400 <TransmitControl_brdcst_func+0x34>
	{
		log("\n\r  Transmit \n\r ");
800023f4:	48 7c       	lddpc	r12,80002410 <TransmitControl_brdcst_func+0x44>
800023f6:	f0 1f 00 05 	mcall	80002408 <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 1;
800023fa:	30 19       	mov	r9,1
800023fc:	48 48       	lddpc	r8,8000240c <TransmitControl_brdcst_func+0x40>
800023fe:	b0 89       	st.b	r8[0x0],r9
80002400:	e3 cd 80 80 	ldm	sp++,r7,pc
80002404:	80 00       	ld.sh	r0,r0[0x0]
80002406:	d1 28       	*unknown*
80002408:	80 00       	ld.sh	r0,r0[0x0]
8000240a:	6d ec       	ld.w	r12,r6[0x78]
8000240c:	00 00       	add	r0,r0
8000240e:	0a 4a       	or	r10,r5
80002410:	80 00       	ld.sh	r0,r0[0x0]
80002412:	d1 40       	acall	0x14

80002414 <TransmitControl_reply_func>:




void TransmitControl_reply_func(xcmp_fragment_t * xcmp)
{
80002414:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	TransmitControl_reply_t *ptr = (TransmitControl_reply_t* )xcmp->u8;
80002418:	f8 c7 ff fe 	sub	r7,r12,-2
	
	if (ptr->Result == xcmp_Res_Success)
8000241c:	0f 89       	ld.ub	r9,r7[0x0]
8000241e:	30 08       	mov	r8,0
80002420:	f0 09 18 00 	cp.b	r9,r8
80002424:	c1 61       	brne	80002450 <TransmitControl_reply_func+0x3c>
	{
		
		log("\n\r  TransmitControl OK \n\r ");
80002426:	48 ec       	lddpc	r12,8000245c <TransmitControl_reply_func+0x48>
80002428:	f0 1f 00 0e 	mcall	80002460 <TransmitControl_reply_func+0x4c>
		log("\n\r Function: %x \n\r", ptr->Function);
8000242c:	0f 98       	ld.ub	r8,r7[0x1]
8000242e:	1a d8       	st.w	--sp,r8
80002430:	48 dc       	lddpc	r12,80002464 <TransmitControl_reply_func+0x50>
80002432:	f0 1f 00 0c 	mcall	80002460 <TransmitControl_reply_func+0x4c>
		log("\n\r Mode of Operation: %x \n\r", ptr->Mode_Of_Operation);
80002436:	0f a8       	ld.ub	r8,r7[0x2]
80002438:	1a d8       	st.w	--sp,r8
8000243a:	48 cc       	lddpc	r12,80002468 <TransmitControl_reply_func+0x54>
8000243c:	f0 1f 00 09 	mcall	80002460 <TransmitControl_reply_func+0x4c>
		log("\n\r State: %x \n\r", ptr->State);
80002440:	0f b8       	ld.ub	r8,r7[0x3]
80002442:	1a d8       	st.w	--sp,r8
80002444:	48 ac       	lddpc	r12,8000246c <TransmitControl_reply_func+0x58>
80002446:	f0 1f 00 07 	mcall	80002460 <TransmitControl_reply_func+0x4c>
8000244a:	2f dd       	sub	sp,-12
8000244c:	e3 cd 80 80 	ldm	sp++,r7,pc
		
		//Silent_flag = 1;
	}
	else
	{
		log("TransmitControl error");
80002450:	48 8c       	lddpc	r12,80002470 <TransmitControl_reply_func+0x5c>
80002452:	f0 1f 00 04 	mcall	80002460 <TransmitControl_reply_func+0x4c>
80002456:	e3 cd 80 80 	ldm	sp++,r7,pc
8000245a:	00 00       	add	r0,r0
8000245c:	80 00       	ld.sh	r0,r0[0x0]
8000245e:	d1 54       	*unknown*
80002460:	80 00       	ld.sh	r0,r0[0x0]
80002462:	6d ec       	ld.w	r12,r6[0x78]
80002464:	80 00       	ld.sh	r0,r0[0x0]
80002466:	d1 70       	acall	0x17
80002468:	80 00       	ld.sh	r0,r0[0x0]
8000246a:	d1 84       	*unknown*
8000246c:	80 00       	ld.sh	r0,r0[0x0]
8000246e:	d1 a0       	acall	0x1a
80002470:	80 00       	ld.sh	r0,r0[0x0]
80002472:	d1 b0       	acall	0x1b

80002474 <AudioRoutingControl_reply_func>:
	
}


void AudioRoutingControl_reply_func(xcmp_fragment_t * xcmp)
{
80002474:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
80002476:	19 a9       	ld.ub	r9,r12[0x2]
80002478:	30 08       	mov	r8,0
8000247a:	f0 09 18 00 	cp.b	r9,r8
8000247e:	c0 51       	brne	80002488 <AudioRoutingControl_reply_func+0x14>
	{
		log("AudioRouting OK");
80002480:	48 4c       	lddpc	r12,80002490 <AudioRoutingControl_reply_func+0x1c>
80002482:	f0 1f 00 05 	mcall	80002494 <AudioRoutingControl_reply_func+0x20>
80002486:	d8 02       	popm	pc
		//xcmp_IdleTestTone();
		//Speaker_is_unmute = 1;
	}
	else
	{
		log("AudioRouting error");
80002488:	48 4c       	lddpc	r12,80002498 <AudioRoutingControl_reply_func+0x24>
8000248a:	f0 1f 00 03 	mcall	80002494 <AudioRoutingControl_reply_func+0x20>
8000248e:	d8 02       	popm	pc
80002490:	80 00       	ld.sh	r0,r0[0x0]
80002492:	d1 c8       	*unknown*
80002494:	80 00       	ld.sh	r0,r0[0x0]
80002496:	6d ec       	ld.w	r12,r6[0x78]
80002498:	80 00       	ld.sh	r0,r0[0x0]
8000249a:	d1 d8       	*unknown*

8000249c <Volume_reply_func>:
	
}


void Volume_reply_func(xcmp_fragment_t * xcmp)
{
8000249c:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	VolumeControl_reply_t *ptr = (VolumeControl_reply_t* )xcmp->u8;
800024a0:	f8 c7 ff fe 	sub	r7,r12,-2
	
		if (ptr->Result == xcmp_Res_Success)
800024a4:	0f 89       	ld.ub	r9,r7[0x0]
800024a6:	30 08       	mov	r8,0
800024a8:	f0 09 18 00 	cp.b	r9,r8
800024ac:	c1 b1       	brne	800024e2 <Volume_reply_func+0x46>
		{
			if (ptr->Function == Enable_IntelligentAudio)
800024ae:	0f b8       	ld.ub	r8,r7[0x3]
800024b0:	31 09       	mov	r9,16
800024b2:	f2 08 18 00 	cp.b	r8,r9
800024b6:	c0 f1       	brne	800024d4 <Volume_reply_func+0x38>
			{
				log("\n\r Enable_IA OK \n\r");
800024b8:	48 dc       	lddpc	r12,800024ec <Volume_reply_func+0x50>
800024ba:	f0 1f 00 0e 	mcall	800024f0 <Volume_reply_func+0x54>
				log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
800024be:	0f 99       	ld.ub	r9,r7[0x1]
800024c0:	0f a8       	ld.ub	r8,r7[0x2]
800024c2:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800024c6:	1a d8       	st.w	--sp,r8
800024c8:	48 bc       	lddpc	r12,800024f4 <Volume_reply_func+0x58>
800024ca:	f0 1f 00 0a 	mcall	800024f0 <Volume_reply_func+0x54>
800024ce:	2f fd       	sub	sp,-4
800024d0:	e3 cd 80 80 	ldm	sp++,r7,pc
	
			}
			else
			{
				
				log("\n\r VolumeControl: %x \n\r", ptr->Function);
800024d4:	1a d8       	st.w	--sp,r8
800024d6:	48 9c       	lddpc	r12,800024f8 <Volume_reply_func+0x5c>
800024d8:	f0 1f 00 06 	mcall	800024f0 <Volume_reply_func+0x54>
800024dc:	2f fd       	sub	sp,-4
800024de:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		
		else
		{
			log("\n\r Enable_IA error \n\r");
800024e2:	48 7c       	lddpc	r12,800024fc <Volume_reply_func+0x60>
800024e4:	f0 1f 00 03 	mcall	800024f0 <Volume_reply_func+0x54>
800024e8:	e3 cd 80 80 	ldm	sp++,r7,pc
800024ec:	80 00       	ld.sh	r0,r0[0x0]
800024ee:	d1 ec       	*unknown*
800024f0:	80 00       	ld.sh	r0,r0[0x0]
800024f2:	6d ec       	ld.w	r12,r6[0x78]
800024f4:	80 00       	ld.sh	r0,r0[0x0]
800024f6:	d2 00       	acall	0x20
800024f8:	80 00       	ld.sh	r0,r0[0x0]
800024fa:	d2 1c       	*unknown*
800024fc:	80 00       	ld.sh	r0,r0[0x0]
800024fe:	d2 34       	*unknown*

80002500 <spk_brdcst_func>:
		log("spk error");
	}
}

void spk_brdcst_func(xcmp_fragment_t * xcmp)
{
80002500:	d4 01       	pushm	lr
	if (xcmp->u8[3] == xcmp_Res_Success)//0x0000:mute
80002502:	19 d9       	ld.ub	r9,r12[0x5]
80002504:	30 08       	mov	r8,0
80002506:	f0 09 18 00 	cp.b	r9,r8
8000250a:	c0 81       	brne	8000251a <spk_brdcst_func+0x1a>
	{
		Speaker_is_unmute =0;
8000250c:	10 99       	mov	r9,r8
8000250e:	48 78       	lddpc	r8,80002528 <spk_brdcst_func+0x28>
80002510:	b0 89       	st.b	r8[0x0],r9
		//Silent_flag = 0;
		log("spk_s_close ");
80002512:	48 7c       	lddpc	r12,8000252c <spk_brdcst_func+0x2c>
80002514:	f0 1f 00 07 	mcall	80002530 <spk_brdcst_func+0x30>
80002518:	d8 02       	popm	pc
		
	}
	else
	{
		//Silent_flag = 1;
		Speaker_is_unmute = 1;
8000251a:	30 19       	mov	r9,1
8000251c:	48 38       	lddpc	r8,80002528 <spk_brdcst_func+0x28>
8000251e:	b0 89       	st.b	r8[0x0],r9
		log("spk_s_open ");	
80002520:	48 5c       	lddpc	r12,80002534 <spk_brdcst_func+0x34>
80002522:	f0 1f 00 04 	mcall	80002530 <spk_brdcst_func+0x30>
80002526:	d8 02       	popm	pc
80002528:	00 00       	add	r0,r0
8000252a:	0a 40       	or	r0,r5
8000252c:	80 00       	ld.sh	r0,r0[0x0]
8000252e:	d2 4c       	*unknown*
80002530:	80 00       	ld.sh	r0,r0[0x0]
80002532:	6d ec       	ld.w	r12,r6[0x78]
80002534:	80 00       	ld.sh	r0,r0[0x0]
80002536:	d2 5c       	*unknown*

80002538 <spk_reply_func>:
			
	
}

void spk_reply_func(xcmp_fragment_t * xcmp)
{
80002538:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
8000253a:	19 a9       	ld.ub	r9,r12[0x2]
8000253c:	30 08       	mov	r8,0
8000253e:	f0 09 18 00 	cp.b	r9,r8
80002542:	c0 f1       	brne	80002560 <spk_reply_func+0x28>
	{
		
		if(xcmp->u8[4])
80002544:	19 e9       	ld.ub	r9,r12[0x6]
80002546:	f0 09 18 00 	cp.b	r9,r8
8000254a:	c0 40       	breq	80002552 <spk_reply_func+0x1a>
		{
			Speaker_is_unmute = 1;
8000254c:	30 19       	mov	r9,1
8000254e:	48 98       	lddpc	r8,80002570 <spk_reply_func+0x38>
80002550:	b0 89       	st.b	r8[0x0],r9
			
			//Silent_flag = 1;
		}
		log("spk OK -st%2x", xcmp->u8[4] );
80002552:	19 e8       	ld.ub	r8,r12[0x6]
80002554:	1a d8       	st.w	--sp,r8
80002556:	48 8c       	lddpc	r12,80002574 <spk_reply_func+0x3c>
80002558:	f0 1f 00 08 	mcall	80002578 <spk_reply_func+0x40>
8000255c:	2f fd       	sub	sp,-4
8000255e:	d8 02       	popm	pc
		
	}
	else
	{
		Speaker_is_unmute = 0;
80002560:	30 09       	mov	r9,0
80002562:	48 48       	lddpc	r8,80002570 <spk_reply_func+0x38>
80002564:	b0 89       	st.b	r8[0x0],r9
		log("spk error");
80002566:	48 6c       	lddpc	r12,8000257c <spk_reply_func+0x44>
80002568:	f0 1f 00 04 	mcall	80002578 <spk_reply_func+0x40>
8000256c:	d8 02       	popm	pc
8000256e:	00 00       	add	r0,r0
80002570:	00 00       	add	r0,r0
80002572:	0a 40       	or	r0,r5
80002574:	80 00       	ld.sh	r0,r0[0x0]
80002576:	d2 68       	*unknown*
80002578:	80 00       	ld.sh	r0,r0[0x0]
8000257a:	6d ec       	ld.w	r12,r6[0x78]
8000257c:	80 00       	ld.sh	r0,r0[0x0]
8000257e:	d2 78       	*unknown*

80002580 <mic_brdcst_func>:
	
	
}

void mic_brdcst_func(xcmp_fragment_t * xcmp)
{
80002580:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_brdcast_t *ptr = (MicControl_brdcast_t* )xcmp->u8;
80002584:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r Mic_brdcst \n\r");		
	//log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
	//log("\n\r Signal_type: %x \n\r " ,  ptr->Signaling_Type);
	if (ptr->Mic_State == 0x00)
80002588:	0f a9       	ld.ub	r9,r7[0x2]
8000258a:	30 08       	mov	r8,0
8000258c:	f0 09 18 00 	cp.b	r9,r8
80002590:	c0 71       	brne	8000259e <mic_brdcst_func+0x1e>
	{
		log("\n\r Mic_Disabled \n\r");	
80002592:	48 dc       	lddpc	r12,800025c4 <mic_brdcst_func+0x44>
80002594:	f0 1f 00 0d 	mcall	800025c8 <mic_brdcst_func+0x48>
		Mic_is_Enabled = 0;
80002598:	30 09       	mov	r9,0
8000259a:	48 d8       	lddpc	r8,800025cc <mic_brdcst_func+0x4c>
8000259c:	b0 89       	st.b	r8[0x0],r9
	} 
	if(ptr->Mic_State == 0x11)
8000259e:	0f a9       	ld.ub	r9,r7[0x2]
800025a0:	31 18       	mov	r8,17
800025a2:	f0 09 18 00 	cp.b	r9,r8
800025a6:	c0 d1       	brne	800025c0 <mic_brdcst_func+0x40>
	{
		log("\n\r Mic_Enabled \n\r");
800025a8:	48 ac       	lddpc	r12,800025d0 <mic_brdcst_func+0x50>
800025aa:	f0 1f 00 08 	mcall	800025c8 <mic_brdcst_func+0x48>
		Mic_is_Enabled = 1;
800025ae:	48 89       	lddpc	r9,800025cc <mic_brdcst_func+0x4c>
800025b0:	30 18       	mov	r8,1
800025b2:	b2 88       	st.b	r9[0x0],r8
		
		if ((Mic_is_Enabled == 1) && (Call_Begin == 1))
800025b4:	13 89       	ld.ub	r9,r9[0x0]
800025b6:	f0 09 18 00 	cp.b	r9,r8
800025ba:	c0 31       	brne	800025c0 <mic_brdcst_func+0x40>
800025bc:	48 68       	lddpc	r8,800025d4 <mic_brdcst_func+0x54>
800025be:	11 88       	ld.ub	r8,r8[0x0]
800025c0:	e3 cd 80 80 	ldm	sp++,r7,pc
800025c4:	80 00       	ld.sh	r0,r0[0x0]
800025c6:	d2 84       	*unknown*
800025c8:	80 00       	ld.sh	r0,r0[0x0]
800025ca:	6d ec       	ld.w	r12,r6[0x78]
800025cc:	00 00       	add	r0,r0
800025ce:	0a 54       	eor	r4,r5
800025d0:	80 00       	ld.sh	r0,r0[0x0]
800025d2:	d2 98       	*unknown*
800025d4:	00 00       	add	r0,r0
800025d6:	0a 4b       	or	r11,r5

800025d8 <mic_reply_func>:
	
	
}

void mic_reply_func(xcmp_fragment_t * xcmp)
{
800025d8:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_reply_t *ptr = (MicControl_reply_t* )xcmp->u8;
800025dc:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Mic_reply \n\r");
800025e0:	49 ac       	lddpc	r12,80002648 <mic_reply_func+0x70>
800025e2:	f0 1f 00 1b 	mcall	8000264c <mic_reply_func+0x74>
	if (ptr->Result == 0x00)
800025e6:	0f 89       	ld.ub	r9,r7[0x0]
800025e8:	30 08       	mov	r8,0
800025ea:	f0 09 18 00 	cp.b	r9,r8
800025ee:	c2 71       	brne	8000263c <mic_reply_func+0x64>
	{
		
		if (ptr->Function == Mic_Disable)
800025f0:	0f 98       	ld.ub	r8,r7[0x1]
800025f2:	30 29       	mov	r9,2
800025f4:	f2 08 18 00 	cp.b	r8,r9
800025f8:	c1 b1       	brne	8000262e <mic_reply_func+0x56>
		{
		
			log("\n\r Mic_close_ok \n\r " );
800025fa:	49 6c       	lddpc	r12,80002650 <mic_reply_func+0x78>
800025fc:	f0 1f 00 14 	mcall	8000264c <mic_reply_func+0x74>
			log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
80002600:	0f a8       	ld.ub	r8,r7[0x2]
80002602:	1a d8       	st.w	--sp,r8
80002604:	49 4c       	lddpc	r12,80002654 <mic_reply_func+0x7c>
80002606:	f0 1f 00 12 	mcall	8000264c <mic_reply_func+0x74>
			log("\n\r Signaling_type: %x \n\r " ,  ptr->Signaling_Type);
8000260a:	0f b8       	ld.ub	r8,r7[0x3]
8000260c:	1a d8       	st.w	--sp,r8
8000260e:	49 3c       	lddpc	r12,80002658 <mic_reply_func+0x80>
80002610:	f0 1f 00 0f 	mcall	8000264c <mic_reply_func+0x74>
			log("\n\r Mic_state: %x \n\r " ,  ptr->Mic_State);
80002614:	0f c8       	ld.ub	r8,r7[0x4]
80002616:	1a d8       	st.w	--sp,r8
80002618:	49 1c       	lddpc	r12,8000265c <mic_reply_func+0x84>
8000261a:	f0 1f 00 0d 	mcall	8000264c <mic_reply_func+0x74>
			log("\n\r Gain_offset: %x \n\r " ,  ptr->Gain_Offset);
8000261e:	0f d8       	ld.ub	r8,r7[0x5]
80002620:	1a d8       	st.w	--sp,r8
80002622:	49 0c       	lddpc	r12,80002660 <mic_reply_func+0x88>
80002624:	f0 1f 00 0a 	mcall	8000264c <mic_reply_func+0x74>
80002628:	2f cd       	sub	sp,-16
8000262a:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else
		{
			log("\n\r Mic_function: %x \n\r ", ptr->Function );
8000262e:	1a d8       	st.w	--sp,r8
80002630:	48 dc       	lddpc	r12,80002664 <mic_reply_func+0x8c>
80002632:	f0 1f 00 07 	mcall	8000264c <mic_reply_func+0x74>
80002636:	2f fd       	sub	sp,-4
80002638:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else 
	{
		
	
		log("\n\r Mic error \n\r");
8000263c:	48 bc       	lddpc	r12,80002668 <mic_reply_func+0x90>
8000263e:	f0 1f 00 04 	mcall	8000264c <mic_reply_func+0x74>
80002642:	e3 cd 80 80 	ldm	sp++,r7,pc
80002646:	00 00       	add	r0,r0
80002648:	80 00       	ld.sh	r0,r0[0x0]
8000264a:	d2 ac       	*unknown*
8000264c:	80 00       	ld.sh	r0,r0[0x0]
8000264e:	6d ec       	ld.w	r12,r6[0x78]
80002650:	80 00       	ld.sh	r0,r0[0x0]
80002652:	d2 bc       	*unknown*
80002654:	80 00       	ld.sh	r0,r0[0x0]
80002656:	d2 d0       	acall	0x2d
80002658:	80 00       	ld.sh	r0,r0[0x0]
8000265a:	d2 e4       	*unknown*
8000265c:	80 00       	ld.sh	r0,r0[0x0]
8000265e:	d3 00       	acall	0x30
80002660:	80 00       	ld.sh	r0,r0[0x0]
80002662:	d3 18       	*unknown*
80002664:	80 00       	ld.sh	r0,r0[0x0]
80002666:	d3 30       	acall	0x33
80002668:	80 00       	ld.sh	r0,r0[0x0]
8000266a:	d3 48       	*unknown*

8000266c <dcm_brdcst_func>:
	}
}


void dcm_brdcst_func(xcmp_fragment_t * xcmp)
{
8000266c:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	DeviceControlMode_brdcst_t *ptr = (DeviceControlMode_brdcst_t* )xcmp->u8;
80002670:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Dcm_brdcst \n\r");		
80002674:	48 bc       	lddpc	r12,800026a0 <dcm_brdcst_func+0x34>
80002676:	f0 1f 00 0c 	mcall	800026a4 <dcm_brdcst_func+0x38>
	log("\n\r Function: %x \n\r " ,  ptr->Function);
8000267a:	0f 88       	ld.ub	r8,r7[0x0]
8000267c:	1a d8       	st.w	--sp,r8
8000267e:	48 bc       	lddpc	r12,800026a8 <dcm_brdcst_func+0x3c>
80002680:	f0 1f 00 09 	mcall	800026a4 <dcm_brdcst_func+0x38>
	log("\n\r ControlType: %x \n\r " ,  ptr->ControlType);
80002684:	0f a8       	ld.ub	r8,r7[0x2]
80002686:	1a d8       	st.w	--sp,r8
80002688:	48 9c       	lddpc	r12,800026ac <dcm_brdcst_func+0x40>
8000268a:	f0 1f 00 07 	mcall	800026a4 <dcm_brdcst_func+0x38>
	log("\n\r ControlTypeSize: %x \n\r " ,  ptr->ControlTypeSize);
8000268e:	0f 98       	ld.ub	r8,r7[0x1]
80002690:	1a d8       	st.w	--sp,r8
80002692:	48 8c       	lddpc	r12,800026b0 <dcm_brdcst_func+0x44>
80002694:	f0 1f 00 04 	mcall	800026a4 <dcm_brdcst_func+0x38>
80002698:	2f dd       	sub	sp,-12
	
	
}
8000269a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000269e:	00 00       	add	r0,r0
800026a0:	80 00       	ld.sh	r0,r0[0x0]
800026a2:	d3 58       	*unknown*
800026a4:	80 00       	ld.sh	r0,r0[0x0]
800026a6:	6d ec       	ld.w	r12,r6[0x78]
800026a8:	80 00       	ld.sh	r0,r0[0x0]
800026aa:	d3 6c       	*unknown*
800026ac:	80 00       	ld.sh	r0,r0[0x0]
800026ae:	d3 80       	acall	0x38
800026b0:	80 00       	ld.sh	r0,r0[0x0]
800026b2:	d3 98       	*unknown*

800026b4 <dcm_reply_func>:
		log("Tone error");
	}
}

void dcm_reply_func(xcmp_fragment_t * xcmp)
{
800026b4:	eb cd 40 80 	pushm	r7,lr
800026b8:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
800026ba:	19 a9       	ld.ub	r9,r12[0x2]
800026bc:	30 08       	mov	r8,0
800026be:	f0 09 18 00 	cp.b	r9,r8
800026c2:	c1 b1       	brne	800026f8 <dcm_reply_func+0x44>
	{
		if(xcmp->u8[1] == DCM_ENTER)
800026c4:	19 b8       	ld.ub	r8,r12[0x3]
800026c6:	30 19       	mov	r9,1
800026c8:	f2 08 18 00 	cp.b	r8,r9
800026cc:	c0 51       	brne	800026d6 <dcm_reply_func+0x22>
		{
			log("\n\r Dcm-Enter OK \n\r");
800026ce:	48 ec       	lddpc	r12,80002704 <dcm_reply_func+0x50>
800026d0:	f0 1f 00 0e 	mcall	80002708 <dcm_reply_func+0x54>
800026d4:	c0 a8       	rjmp	800026e8 <dcm_reply_func+0x34>
			
		}
		else if (xcmp->u8[1] == DCM_EXIT)
800026d6:	58 08       	cp.w	r8,0
800026d8:	c0 51       	brne	800026e2 <dcm_reply_func+0x2e>
		{
			log("\n\r Dcm-Exit OK \n\r");
800026da:	48 dc       	lddpc	r12,8000270c <dcm_reply_func+0x58>
800026dc:	f0 1f 00 0b 	mcall	80002708 <dcm_reply_func+0x54>
800026e0:	c0 48       	rjmp	800026e8 <dcm_reply_func+0x34>
		}
		else
		{
			log("\n\r Dcm-Revoke \n\r");
800026e2:	48 cc       	lddpc	r12,80002710 <dcm_reply_func+0x5c>
800026e4:	f0 1f 00 09 	mcall	80002708 <dcm_reply_func+0x54>
		}
		
		log("dcm OK-mo%X", xcmp->u8[3]);
800026e8:	0f d8       	ld.ub	r8,r7[0x5]
800026ea:	1a d8       	st.w	--sp,r8
800026ec:	48 ac       	lddpc	r12,80002714 <dcm_reply_func+0x60>
800026ee:	f0 1f 00 07 	mcall	80002708 <dcm_reply_func+0x54>
800026f2:	2f fd       	sub	sp,-4
800026f4:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		log("dcm error");
800026f8:	48 8c       	lddpc	r12,80002718 <dcm_reply_func+0x64>
800026fa:	f0 1f 00 04 	mcall	80002708 <dcm_reply_func+0x54>
800026fe:	e3 cd 80 80 	ldm	sp++,r7,pc
80002702:	00 00       	add	r0,r0
80002704:	80 00       	ld.sh	r0,r0[0x0]
80002706:	d3 b4       	*unknown*
80002708:	80 00       	ld.sh	r0,r0[0x0]
8000270a:	6d ec       	ld.w	r12,r6[0x78]
8000270c:	80 00       	ld.sh	r0,r0[0x0]
8000270e:	d3 c8       	*unknown*
80002710:	80 00       	ld.sh	r0,r0[0x0]
80002712:	d3 dc       	*unknown*
80002714:	80 00       	ld.sh	r0,r0[0x0]
80002716:	d3 f0       	acall	0x3f
80002718:	80 00       	ld.sh	r0,r0[0x0]
8000271a:	d3 fc       	*unknown*

8000271c <ToneControl_reply_func>:
			//log("Device State : %d\n", ptr->Device_State);
		}
}

void ToneControl_reply_func(xcmp_fragment_t * xcmp)
{
8000271c:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
8000271e:	19 a9       	ld.ub	r9,r12[0x2]
80002720:	30 08       	mov	r8,0
80002722:	f0 09 18 00 	cp.b	r9,r8
80002726:	c0 51       	brne	80002730 <ToneControl_reply_func+0x14>
	{		
		log("Tone OK\n");
80002728:	48 4c       	lddpc	r12,80002738 <ToneControl_reply_func+0x1c>
8000272a:	f0 1f 00 05 	mcall	8000273c <ToneControl_reply_func+0x20>
8000272e:	d8 02       	popm	pc
		//fl_write("/test.txt", FILE_END, (void *)"send tone ok\r\n", sizeof("send tone ok\r\n") - 1);
	}
	else
	{
		log("Tone error");
80002730:	48 4c       	lddpc	r12,80002740 <ToneControl_reply_func+0x24>
80002732:	f0 1f 00 03 	mcall	8000273c <ToneControl_reply_func+0x20>
80002736:	d8 02       	popm	pc
80002738:	80 00       	ld.sh	r0,r0[0x0]
8000273a:	d4 08       	*unknown*
8000273c:	80 00       	ld.sh	r0,r0[0x0]
8000273e:	6d ec       	ld.w	r12,r6[0x78]
80002740:	80 00       	ld.sh	r0,r0[0x0]
80002742:	d4 14       	*unknown*

80002744 <app_init>:
	//0x00,0x39


};
void app_init(void)
{	
80002744:	d4 01       	pushm	lr
	xcmp_register_app_list(the_app_list);
80002746:	49 1c       	lddpc	r12,80002788 <app_init+0x44>
80002748:	f0 1f 00 11 	mcall	8000278c <app_init+0x48>
	
	//将app_payload_rx_proc更改为PCM加密功能
	payload_init( app_payload_rx_proc , app_payload_tx_proc );
8000274c:	49 1b       	lddpc	r11,80002790 <app_init+0x4c>
8000274e:	49 2c       	lddpc	r12,80002794 <app_init+0x50>
80002750:	f0 1f 00 12 	mcall	80002798 <app_init+0x54>
	
	/* Create the mutex semaphore to guard a shared global_count.*/
	count_mutex = xSemaphoreCreateMutex();
80002754:	f0 1f 00 12 	mcall	8000279c <app_init+0x58>
80002758:	49 28       	lddpc	r8,800027a0 <app_init+0x5c>
8000275a:	91 0c       	st.w	r8[0x0],r12
	if (count_mutex == NULL)
8000275c:	70 08       	ld.w	r8,r8[0x0]
8000275e:	58 08       	cp.w	r8,0
80002760:	c0 41       	brne	80002768 <app_init+0x24>
	{
		log("Create the count_mutex semaphore failure\n");
80002762:	49 1c       	lddpc	r12,800027a4 <app_init+0x60>
80002764:	f0 1f 00 11 	mcall	800027a8 <app_init+0x64>
	}
	
	
	static portBASE_TYPE res = 0;
	 res = xTaskCreate(
80002768:	30 09       	mov	r9,0
8000276a:	1a d9       	st.w	--sp,r9
8000276c:	1a d9       	st.w	--sp,r9
8000276e:	1a d9       	st.w	--sp,r9
80002770:	30 18       	mov	r8,1
80002772:	e0 6a 03 20 	mov	r10,800
80002776:	48 eb       	lddpc	r11,800027ac <app_init+0x68>
80002778:	48 ec       	lddpc	r12,800027b0 <app_init+0x6c>
8000277a:	f0 1f 00 0f 	mcall	800027b4 <app_init+0x70>
8000277e:	48 f8       	lddpc	r8,800027b8 <app_init+0x74>
80002780:	91 0c       	st.w	r8[0x0],r12
80002782:	2f dd       	sub	sp,-12
	,  800//1024//800//384
	,  NULL
	,  1
	,  NULL );
		
}
80002784:	d8 02       	popm	pc
80002786:	00 00       	add	r0,r0
80002788:	00 00       	add	r0,r0
8000278a:	00 08       	add	r8,r0
8000278c:	80 00       	ld.sh	r0,r0[0x0]
8000278e:	3d a8       	mov	r8,-38
80002790:	80 00       	ld.sh	r0,r0[0x0]
80002792:	20 58       	sub	r8,5
80002794:	80 00       	ld.sh	r0,r0[0x0]
80002796:	20 6c       	sub	r12,6
80002798:	80 00       	ld.sh	r0,r0[0x0]
8000279a:	2a 58       	sub	r8,-91
8000279c:	80 00       	ld.sh	r0,r0[0x0]
8000279e:	62 b4       	ld.w	r4,r1[0x2c]
800027a0:	00 00       	add	r0,r0
800027a2:	0a 58       	eor	r8,r5
800027a4:	80 00       	ld.sh	r0,r0[0x0]
800027a6:	d4 20       	acall	0x42
800027a8:	80 00       	ld.sh	r0,r0[0x0]
800027aa:	6d ec       	ld.w	r12,r6[0x78]
800027ac:	80 00       	ld.sh	r0,r0[0x0]
800027ae:	d4 4c       	*unknown*
800027b0:	80 00       	ld.sh	r0,r0[0x0]
800027b2:	27 bc       	sub	r12,123
800027b4:	80 00       	ld.sh	r0,r0[0x0]
800027b6:	6a 28       	ld.w	r8,r5[0x8]
800027b8:	00 00       	add	r0,r0
800027ba:	0a 44       	or	r4,r5

800027bc <app_cfg>:
extern void xnl_send_device_master_query(void);
//extern portTickType water_value;
//extern portTickType tx_water_value;
//extern portTickType log_water_value;
static __app_Thread_(app_cfg)
{
800027bc:	d4 31       	pushm	r0-r7,lr
800027be:	21 4d       	sub	sp,80
	static  portTickType xLastWakeTime;
	const portTickType xFrequency = 4000;//2s,定时问题已经修正。2s x  2000hz = 4000
	U8 Burst_ID = 0;
	char card_id[4]={0};
	U16  * data_ptr;
	Message_Protocol_t *m_buff = (Message_Protocol_t *) pvPortMalloc(sizeof(Message_Protocol_t));
800027c0:	31 ac       	mov	r12,26
800027c2:	f0 1f 00 38 	mcall	800028a0 <app_cfg+0xe4>
	static	OB_States OB_State = OB_UNCONNECTEDWAITINGSTATUS;
	static xgflash_status_t status = XG_ERROR;
	xLastWakeTime = xTaskGetTickCount();
800027c6:	f0 1f 00 38 	mcall	800028a4 <app_cfg+0xe8>
800027ca:	4b 88       	lddpc	r8,800028a8 <app_cfg+0xec>
800027cc:	91 0c       	st.w	r8[0x0],r12
	
	static const uint8_t test_data[8] = {0x11, 0x23, 0x33, 0x67, 0x89, 0xAB, 0xCD, 0xEF};
	char str[80];
	memset(str, 0x00, 80);
800027ce:	35 0a       	mov	r10,80
800027d0:	30 0b       	mov	r11,0
800027d2:	1a 9c       	mov	r12,sp
800027d4:	f0 1f 00 36 	mcall	800028ac <app_cfg+0xf0>
	
	/* 'Give' the semaphore to unblock the task. */
	 //if( xBinarySemaphore != NULL ){
		//xSemaphoreGive(xBinarySemaphore);
	 //}
	 xSemaphoreTake(xBinarySemaphore, portMAX_DELAY); 
800027d8:	4b 68       	lddpc	r8,800028b0 <app_cfg+0xf4>
800027da:	70 0c       	ld.w	r12,r8[0x0]
800027dc:	30 09       	mov	r9,0
800027de:	3f fa       	mov	r10,-1
800027e0:	12 9b       	mov	r11,r9
800027e2:	f0 1f 00 35 	mcall	800028b4 <app_cfg+0xf8>
		
	for(;;)
	{
		switch(OB_State)
800027e6:	4b 55       	lddpc	r5,800028b8 <app_cfg+0xfc>
		{
			case OB_UNCONNECTEDWAITINGSTATUS:
			
				if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
800027e8:	4b 54       	lddpc	r4,800028bc <app_cfg+0x100>
					nop();
					nop();
					nop();
					/*send device_master_query to connect radio*/
					xnl_send_device_master_query();
					log("connecting...\n");
800027ea:	4b 62       	lddpc	r2,800028c0 <app_cfg+0x104>
					vTaskDelayUntil( &xLastWakeTime, (1000*2) / portTICK_RATE_MS  );//精确的以1000ms为周期执行。
800027ec:	4a f6       	lddpc	r6,800028a8 <app_cfg+0xec>
800027ee:	e0 67 07 d0 	mov	r7,2000
	{
		switch(OB_State)
		{
			case OB_UNCONNECTEDWAITINGSTATUS:
			
				if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
800027f2:	4b 53       	lddpc	r3,800028c4 <app_cfg+0x108>
				{
					connect_flag=1;
					xcmp_IdleTestTone(Tone_Start, Priority_Beep);//set tone to indicate connection success!!!
800027f4:	30 c0       	mov	r0,12
800027f6:	30 11       	mov	r1,1
	 //}
	 xSemaphoreTake(xBinarySemaphore, portMAX_DELAY); 
		
	for(;;)
	{
		switch(OB_State)
800027f8:	6a 08       	ld.w	r8,r5[0x0]
800027fa:	58 08       	cp.w	r8,0
800027fc:	c0 40       	breq	80002804 <app_cfg+0x48>
800027fe:	58 38       	cp.w	r8,3
80002800:	c4 b1       	brne	80002896 <app_cfg+0xda>
80002802:	c3 b8       	rjmp	80002878 <app_cfg+0xbc>
		{
			case OB_UNCONNECTEDWAITINGSTATUS:
			
				if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
80002804:	68 08       	ld.w	r8,r4[0x0]
80002806:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
8000280a:	58 38       	cp.w	r8,3
8000280c:	c2 91       	brne	8000285e <app_cfg+0xa2>
8000280e:	07 88       	ld.ub	r8,r3[0x0]
80002810:	58 08       	cp.w	r8,0
80002812:	c2 61       	brne	8000285e <app_cfg+0xa2>
				{
					connect_flag=1;
80002814:	30 18       	mov	r8,1
80002816:	a6 88       	st.b	r3[0x0],r8
					xcmp_IdleTestTone(Tone_Start, Priority_Beep);//set tone to indicate connection success!!!
80002818:	00 9b       	mov	r11,r0
8000281a:	02 9c       	mov	r12,r1
8000281c:	f0 1f 00 2b 	mcall	800028c8 <app_cfg+0x10c>
					xcmp_IdleTestTone(Tone_Start, Priority_Beep);//set tone to indicate connection success!!!
80002820:	00 9b       	mov	r11,r0
80002822:	02 9c       	mov	r12,r1
80002824:	f0 1f 00 29 	mcall	800028c8 <app_cfg+0x10c>
					OB_State = OB_WAITINGAPPTASK;
80002828:	30 38       	mov	r8,3
8000282a:	8b 08       	st.w	r5[0x0],r8
					log("connect OB okay!\n");
8000282c:	4a 8c       	lddpc	r12,800028cc <app_cfg+0x110>
8000282e:	f0 1f 00 29 	mcall	800028d0 <app_cfg+0x114>
					log("XCMP_Version: %d.%d.%d.%d\n", XCMP_Version[0],  XCMP_Version[1],
													 XCMP_Version[2],  XCMP_Version[3]);
80002832:	4a 98       	lddpc	r8,800028d4 <app_cfg+0x118>
80002834:	11 bb       	ld.ub	r11,r8[0x3]
80002836:	11 aa       	ld.ub	r10,r8[0x2]
					connect_flag=1;
					xcmp_IdleTestTone(Tone_Start, Priority_Beep);//set tone to indicate connection success!!!
					xcmp_IdleTestTone(Tone_Start, Priority_Beep);//set tone to indicate connection success!!!
					OB_State = OB_WAITINGAPPTASK;
					log("connect OB okay!\n");
					log("XCMP_Version: %d.%d.%d.%d\n", XCMP_Version[0],  XCMP_Version[1],
80002838:	11 99       	ld.ub	r9,r8[0x1]
8000283a:	11 88       	ld.ub	r8,r8[0x0]
8000283c:	1a db       	st.w	--sp,r11
8000283e:	1a da       	st.w	--sp,r10
80002840:	1a d9       	st.w	--sp,r9
80002842:	1a d8       	st.w	--sp,r8
80002844:	4a 5c       	lddpc	r12,800028d8 <app_cfg+0x11c>
80002846:	f0 1f 00 23 	mcall	800028d0 <app_cfg+0x114>
													 XCMP_Version[2],  XCMP_Version[3]);
					log("OB_Firmware_Version: %d.%d.%d\n", OB_Firmware_Version[0],  OB_Firmware_Version[1], OB_Firmware_Version[2]);							 
8000284a:	1a d1       	st.w	--sp,r1
8000284c:	30 08       	mov	r8,0
8000284e:	1a d8       	st.w	--sp,r8
80002850:	30 28       	mov	r8,2
80002852:	1a d8       	st.w	--sp,r8
80002854:	4a 2c       	lddpc	r12,800028dc <app_cfg+0x120>
80002856:	f0 1f 00 1f 	mcall	800028d0 <app_cfg+0x114>
	{
		switch(OB_State)
		{
			case OB_UNCONNECTEDWAITINGSTATUS:
			
				if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
8000285a:	2f 9d       	sub	sp,-28
8000285c:	c1 d8       	rjmp	80002896 <app_cfg+0xda>
													 XCMP_Version[2],  XCMP_Version[3]);
					log("OB_Firmware_Version: %d.%d.%d\n", OB_Firmware_Version[0],  OB_Firmware_Version[1], OB_Firmware_Version[2]);							 
				}
				else
				{
					nop();
8000285e:	d7 03       	nop
					nop();
80002860:	d7 03       	nop
					nop();
80002862:	d7 03       	nop
					/*send device_master_query to connect radio*/
					xnl_send_device_master_query();
80002864:	f0 1f 00 1f 	mcall	800028e0 <app_cfg+0x124>
					log("connecting...\n");
80002868:	04 9c       	mov	r12,r2
8000286a:	f0 1f 00 1a 	mcall	800028d0 <app_cfg+0x114>
					vTaskDelayUntil( &xLastWakeTime, (1000*2) / portTICK_RATE_MS  );//精确的以1000ms为周期执行。
8000286e:	0e 9b       	mov	r11,r7
80002870:	0c 9c       	mov	r12,r6
80002872:	f0 1f 00 1d 	mcall	800028e4 <app_cfg+0x128>
80002876:	c1 08       	rjmp	80002896 <app_cfg+0xda>
							//}
						//
						//}
					}
					
					if (0x00000003 != (bunchofrandomstatusflags & 0x00000003))//掉线
80002878:	68 08       	ld.w	r8,r4[0x0]
8000287a:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
8000287e:	58 38       	cp.w	r8,3
80002880:	c0 70       	breq	8000288e <app_cfg+0xd2>
					{					
						OB_State = OB_UNCONNECTEDWAITINGSTATUS;
80002882:	30 08       	mov	r8,0
80002884:	8b 08       	st.w	r5[0x0],r8
						connect_flag=0;
80002886:	a6 88       	st.b	r3[0x0],r8
						log("OB disconnecting!!!\n");
80002888:	49 8c       	lddpc	r12,800028e8 <app_cfg+0x12c>
8000288a:	f0 1f 00 12 	mcall	800028d0 <app_cfg+0x114>
							//memset(str, 0x00, 80);
						//}
					//}
					
											
					nop();
8000288e:	d7 03       	nop
					log("app task run!\n");
80002890:	49 7c       	lddpc	r12,800028ec <app_cfg+0x130>
80002892:	f0 1f 00 10 	mcall	800028d0 <app_cfg+0x114>
			break;
			default:
			break;
				
		} //End of switch on OB_State.
		vTaskDelayUntil( &xLastWakeTime, (1000*2) / portTICK_RATE_MS  );//精确的以1000ms为周期执行。
80002896:	0e 9b       	mov	r11,r7
80002898:	0c 9c       	mov	r12,r6
8000289a:	f0 1f 00 13 	mcall	800028e4 <app_cfg+0x128>
	}
8000289e:	ca db       	rjmp	800027f8 <app_cfg+0x3c>
800028a0:	80 00       	ld.sh	r0,r0[0x0]
800028a2:	5e 60       	retmi	r0
800028a4:	80 00       	ld.sh	r0,r0[0x0]
800028a6:	67 18       	ld.w	r8,r3[0x44]
800028a8:	00 00       	add	r0,r0
800028aa:	0a 50       	eor	r0,r5
800028ac:	80 00       	ld.sh	r0,r0[0x0]
800028ae:	77 b0       	ld.w	r0,r11[0x6c]
800028b0:	00 00       	add	r0,r0
800028b2:	0b 70       	ld.ub	r0,--r5
800028b4:	80 00       	ld.sh	r0,r0[0x0]
800028b6:	5f a8       	srle	r8
800028b8:	00 00       	add	r0,r0
800028ba:	0a 5c       	eor	r12,r5
800028bc:	00 00       	add	r0,r0
800028be:	0d 98       	ld.ub	r8,r6[0x1]
800028c0:	80 00       	ld.sh	r0,r0[0x0]
800028c2:	d4 a4       	*unknown*
800028c4:	00 00       	add	r0,r0
800028c6:	0a 4e       	or	lr,r5
800028c8:	80 00       	ld.sh	r0,r0[0x0]
800028ca:	3f 40       	mov	r0,-12
800028cc:	80 00       	ld.sh	r0,r0[0x0]
800028ce:	d4 54       	*unknown*
800028d0:	80 00       	ld.sh	r0,r0[0x0]
800028d2:	6d ec       	ld.w	r12,r6[0x78]
800028d4:	00 00       	add	r0,r0
800028d6:	0d 94       	ld.ub	r4,r6[0x1]
800028d8:	80 00       	ld.sh	r0,r0[0x0]
800028da:	d4 68       	*unknown*
800028dc:	80 00       	ld.sh	r0,r0[0x0]
800028de:	d4 84       	*unknown*
800028e0:	80 00       	ld.sh	r0,r0[0x0]
800028e2:	46 ec       	lddsp	r12,sp[0x1b8]
800028e4:	80 00       	ld.sh	r0,r0[0x0]
800028e6:	68 c8       	ld.w	r8,r4[0x30]
800028e8:	80 00       	ld.sh	r0,r0[0x0]
800028ea:	d4 b4       	*unknown*
800028ec:	80 00       	ld.sh	r0,r0[0x0]
800028ee:	d4 cc       	*unknown*

800028f0 <DataSession_brdcst_func>:
	Battery_Flag = ptr->State;

}

void DataSession_brdcst_func(xcmp_fragment_t * xcmp)
{
800028f0:	d4 21       	pushm	r4-r7,lr
	U32 card_id =0;
	U8 i = 0;
	xgflash_status_t return_value = XG_ERROR;
	
	/*point to xcmp payload*/
	DataSession_brdcst_t *ptr = (DataSession_brdcst_t* )xcmp->u8;
800028f2:	f8 c6 ff fe 	sub	r6,r12,-2
	
	if (ptr->State == CSBK_DATA_RX_Suc)
800028f6:	0d 88       	ld.ub	r8,r6[0x0]
800028f8:	32 49       	mov	r9,36
800028fa:	f2 08 18 00 	cp.b	r8,r9
800028fe:	c2 91       	brne	80002950 <DataSession_brdcst_func+0x60>
	{
		
		log("\n\r CSBK_RX OK \n\r");
80002900:	49 dc       	lddpc	r12,80002974 <DataSession_brdcst_func+0x84>
80002902:	f0 1f 00 1e 	mcall	80002978 <DataSession_brdcst_func+0x88>
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
80002906:	0d a5       	ld.ub	r5,r6[0x2]
80002908:	0d b8       	ld.ub	r8,r6[0x3]
8000290a:	f1 e5 10 85 	or	r5,r8,r5<<0x8
8000290e:	5c 85       	casts.h	r5

		log("\n\r Session_ID: %x \n\r",Session_number );
80002910:	0d 98       	ld.ub	r8,r6[0x1]
80002912:	1a d8       	st.w	--sp,r8
80002914:	49 ac       	lddpc	r12,8000297c <DataSession_brdcst_func+0x8c>
80002916:	f0 1f 00 19 	mcall	80002978 <DataSession_brdcst_func+0x88>
		log("\n\r paylaod_length: %d \n\r",data_length );
8000291a:	f1 d5 c0 10 	bfextu	r8,r5,0x0,0x10
8000291e:	1a d8       	st.w	--sp,r8
80002920:	49 8c       	lddpc	r12,80002980 <DataSession_brdcst_func+0x90>
80002922:	f0 1f 00 16 	mcall	80002978 <DataSession_brdcst_func+0x88>
		for(i=0; i<data_length; i++)
80002926:	2f ed       	sub	sp,-8
80002928:	58 05       	cp.w	r5,0
8000292a:	c2 40       	breq	80002972 <DataSession_brdcst_func+0x82>
8000292c:	30 07       	mov	r7,0
		{
			
			//log("\n\r payload[%d]: %X \n\r", i, xcmp->u8[4+i]);
			log("\n\r payload[%d]: %X \n\r", i, ptr->DataPayload.DataPayload[i]);
8000292e:	49 64       	lddpc	r4,80002984 <DataSession_brdcst_func+0x94>
80002930:	ec 07 00 08 	add	r8,r6,r7
80002934:	11 c8       	ld.ub	r8,r8[0x4]
80002936:	1a d8       	st.w	--sp,r8
80002938:	1a d7       	st.w	--sp,r7
8000293a:	08 9c       	mov	r12,r4
8000293c:	f0 1f 00 0f 	mcall	80002978 <DataSession_brdcst_func+0x88>
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);

		log("\n\r Session_ID: %x \n\r",Session_number );
		log("\n\r paylaod_length: %d \n\r",data_length );
		for(i=0; i<data_length; i++)
80002940:	2f f7       	sub	r7,-1
80002942:	5c 57       	castu.b	r7
80002944:	2f ed       	sub	sp,-8
80002946:	ee 05 19 00 	cp.h	r5,r7
8000294a:	fe 9b ff f3 	brhi	80002930 <DataSession_brdcst_func+0x40>
8000294e:	d8 22       	popm	r4-r7,pc
	else
	{
		//log("\n\r State: 0x %X \n\r", xcmp->u8[0]);
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];				
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
		log("State: %X \n", ptr->State);
80002950:	1a d8       	st.w	--sp,r8
80002952:	48 ec       	lddpc	r12,80002988 <DataSession_brdcst_func+0x98>
80002954:	f0 1f 00 09 	mcall	80002978 <DataSession_brdcst_func+0x88>
		if (ptr->State == DATA_SESSION_TX_Suc)
80002958:	2f fd       	sub	sp,-4
8000295a:	0d 89       	ld.ub	r9,r6[0x0]
8000295c:	30 38       	mov	r8,3
8000295e:	f0 09 18 00 	cp.b	r9,r8
80002962:	c0 81       	brne	80002972 <DataSession_brdcst_func+0x82>
		{
			log("data transmit success\n");
80002964:	48 ac       	lddpc	r12,8000298c <DataSession_brdcst_func+0x9c>
80002966:	f0 1f 00 05 	mcall	80002978 <DataSession_brdcst_func+0x88>
			vTaskDelay(1000*2 / portTICK_RATE_MS);//延迟1000ms
8000296a:	e0 6c 07 d0 	mov	r12,2000
8000296e:	f0 1f 00 09 	mcall	80002990 <DataSession_brdcst_func+0xa0>
80002972:	d8 22       	popm	r4-r7,pc
80002974:	80 00       	ld.sh	r0,r0[0x0]
80002976:	d4 dc       	*unknown*
80002978:	80 00       	ld.sh	r0,r0[0x0]
8000297a:	6d ec       	ld.w	r12,r6[0x78]
8000297c:	80 00       	ld.sh	r0,r0[0x0]
8000297e:	d4 f0       	acall	0x4f
80002980:	80 00       	ld.sh	r0,r0[0x0]
80002982:	d5 08       	*unknown*
80002984:	80 00       	ld.sh	r0,r0[0x0]
80002986:	d5 24       	*unknown*
80002988:	80 00       	ld.sh	r0,r0[0x0]
8000298a:	d5 3c       	*unknown*
8000298c:	80 00       	ld.sh	r0,r0[0x0]
8000298e:	d5 48       	*unknown*
80002990:	80 00       	ld.sh	r0,r0[0x0]
80002992:	68 80       	ld.w	r0,r4[0x20]

80002994 <Phyuserinput_brdcst_func>:
	
}


void Phyuserinput_brdcst_func(xcmp_fragment_t * xcmp)
{
80002994:	eb cd 40 80 	pushm	r7,lr
	U8 PUI_State_Min_Value =0;
	U8 PUI_State_Max_Value =0;
	
	PUI_Source = xcmp->u8[0];
	PUI_Type = xcmp ->u8[1];
	PUI_ID = ((xcmp->u8[2]<<8) | xcmp->u8[3]);
80002998:	19 c7       	ld.ub	r7,r12[0x4]
8000299a:	19 d8       	ld.ub	r8,r12[0x5]
8000299c:	f1 e7 10 87 	or	r7,r8,r7<<0x8
800029a0:	5c 87       	casts.h	r7
	PUI_State = xcmp->u8[4];
	PUI_State_Min_Value = xcmp->u8[5];
	PUI_State_Max_Value = xcmp->u8[6];
	
	log("PhysicalUserInput_broadcast  \n\r"  );
800029a2:	48 dc       	lddpc	r12,800029d4 <Phyuserinput_brdcst_func+0x40>
800029a4:	f0 1f 00 0d 	mcall	800029d8 <Phyuserinput_brdcst_func+0x44>
	
	if((PUI_ID == 0x0060) && (PUI_State = 0x02) && (connect_flag == 1)){
800029a8:	36 08       	mov	r8,96
800029aa:	f0 07 19 00 	cp.h	r7,r8
800029ae:	c1 11       	brne	800029d0 <Phyuserinput_brdcst_func+0x3c>
800029b0:	48 b8       	lddpc	r8,800029dc <Phyuserinput_brdcst_func+0x48>
800029b2:	11 89       	ld.ub	r9,r8[0x0]
800029b4:	30 18       	mov	r8,1
800029b6:	f0 09 18 00 	cp.b	r9,r8
800029ba:	c0 b1       	brne	800029d0 <Phyuserinput_brdcst_func+0x3c>
		//log("send message\n");
		xcmp_IdleTestTone(Tone_Start, Ring_Style_Tone_9);//set tone to indicate the scan!!!
800029bc:	34 5b       	mov	r11,69
800029be:	30 1c       	mov	r12,1
800029c0:	f0 1f 00 08 	mcall	800029e0 <Phyuserinput_brdcst_func+0x4c>
			
		vTaskDelay(100*2 / portTICK_RATE_MS);//延迟100ms
800029c4:	e0 6c 00 c8 	mov	r12,200
800029c8:	f0 1f 00 07 	mcall	800029e4 <Phyuserinput_brdcst_func+0x50>
		//delay_ms(200);
		rfid_sendID_message();//send message	
800029cc:	f0 1f 00 07 	mcall	800029e8 <Phyuserinput_brdcst_func+0x54>
800029d0:	e3 cd 80 80 	ldm	sp++,r7,pc
800029d4:	80 00       	ld.sh	r0,r0[0x0]
800029d6:	d5 60       	acall	0x56
800029d8:	80 00       	ld.sh	r0,r0[0x0]
800029da:	6d ec       	ld.w	r12,r6[0x78]
800029dc:	00 00       	add	r0,r0
800029de:	0a 4e       	or	lr,r5
800029e0:	80 00       	ld.sh	r0,r0[0x0]
800029e2:	3f 40       	mov	r0,-12
800029e4:	80 00       	ld.sh	r0,r0[0x0]
800029e6:	68 80       	ld.w	r0,r4[0x20]
800029e8:	80 00       	ld.sh	r0,r0[0x0]
800029ea:	4f 98       	lddpc	r8,80002bcc <phy_tx_func+0x50>

800029ec <DeviceInitializationStatus_brdcst_func>:
//xnl_content_master_status_brdcst_t XCMP_Version;

//app func--list

void DeviceInitializationStatus_brdcst_func(xcmp_fragment_t  * xcmp)
{
800029ec:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	DeviceInitializationStatus_brdcst_t *ptr = (DeviceInitializationStatus_brdcst_t* )xcmp->u8;
800029f0:	f8 c7 ff fe 	sub	r7,r12,-2
	
	//log("DeviceInitializationStatus_brdcst...\n");
	
	memcpy(XCMP_Version, &(ptr->XCMPVersion[0]), sizeof(XCMP_Version));
800029f4:	30 4a       	mov	r10,4
800029f6:	0e 9b       	mov	r11,r7
800029f8:	48 dc       	lddpc	r12,80002a2c <DeviceInitializationStatus_brdcst_func+0x40>
800029fa:	f0 1f 00 0e 	mcall	80002a30 <DeviceInitializationStatus_brdcst_func+0x44>
	
	if (ptr->DeviceInitType == Device_Init_Complete)
800029fe:	0f c8       	ld.ub	r8,r7[0x4]
80002a00:	30 19       	mov	r9,1
80002a02:	f2 08 18 00 	cp.b	r8,r9
80002a06:	c0 71       	brne	80002a14 <DeviceInitializationStatus_brdcst_func+0x28>
	{
		bunchofrandomstatusflags |= 0x01;  //Need do nothing else.
80002a08:	48 b8       	lddpc	r8,80002a34 <DeviceInitializationStatus_brdcst_func+0x48>
80002a0a:	70 09       	ld.w	r9,r8[0x0]
80002a0c:	a1 a9       	sbr	r9,0x0
80002a0e:	91 09       	st.w	r8[0x0],r9
80002a10:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else if(ptr->DeviceInitType  == Device_Init_Status)
80002a14:	58 08       	cp.w	r8,0
80002a16:	c0 81       	brne	80002a26 <DeviceInitializationStatus_brdcst_func+0x3a>
	{
		bunchofrandomstatusflags  &= 0xFFFFFFFC; //Device Init no longer Complete.
80002a18:	48 78       	lddpc	r8,80002a34 <DeviceInitializationStatus_brdcst_func+0x48>
80002a1a:	70 09       	ld.w	r9,r8[0x0]
80002a1c:	e0 19 ff fc 	andl	r9,0xfffc
80002a20:	91 09       	st.w	r8[0x0],r9
		xcmp_DeviceInitializationStatus_request();
80002a22:	f0 1f 00 06 	mcall	80002a38 <DeviceInitializationStatus_brdcst_func+0x4c>
80002a26:	e3 cd 80 80 	ldm	sp++,r7,pc
80002a2a:	00 00       	add	r0,r0
80002a2c:	00 00       	add	r0,r0
80002a2e:	0d 94       	ld.ub	r4,r6[0x1]
80002a30:	80 00       	ld.sh	r0,r0[0x0]
80002a32:	76 68       	ld.w	r8,r11[0x18]
80002a34:	00 00       	add	r0,r0
80002a36:	0d 98       	ld.ub	r8,r6[0x1]
80002a38:	80 00       	ld.sh	r0,r0[0x0]
80002a3a:	3e 8c       	mov	r12,-24

80002a3c <CalculateBurst>:
Calls:
Called By: phy_payload_rx
*/

volatile RxAMBEBurstType CalculateBurst(U8 vf_sn)
{
80002a3c:	20 1c       	sub	r12,1
80002a3e:	5c 5c       	castu.b	r12
80002a40:	31 18       	mov	r8,17
80002a42:	f0 0c 18 00 	cp.b	r12,r8
80002a46:	e0 88 00 03 	brls	80002a4c <CalculateBurst+0x10>
80002a4a:	5e fd       	retal	0
80002a4c:	48 28       	lddpc	r8,80002a54 <CalculateBurst+0x18>
80002a4e:	f0 0c 03 2c 	ld.w	r12,r8[r12<<0x2]
			Burst_ID = 0x00;
			return VOICE_WATING;
		
	}
	
}
80002a52:	5e fc       	retal	r12
80002a54:	80 00       	ld.sh	r0,r0[0x0]
80002a56:	d5 80       	acall	0x58

80002a58 <payload_init>:
Calls: xTaskCreate--freertos
Called By:app_init -- app.c
*/
void payload_init(void ( *payload_rx_func)(void * ), void ( *payload_tx_func)(void * ) )
{				
	payload_rx_exec = payload_rx_func;
80002a58:	48 38       	lddpc	r8,80002a64 <payload_init+0xc>
80002a5a:	91 0c       	st.w	r8[0x0],r12
	payload_tx_exec = payload_tx_func;
80002a5c:	48 38       	lddpc	r8,80002a68 <payload_init+0x10>
80002a5e:	91 0b       	st.w	r8[0x0],r11
	//,  2
	//,  NULL
	//);
	//
	
}
80002a60:	5e fc       	retal	r12
80002a62:	00 00       	add	r0,r0
80002a64:	00 00       	add	r0,r0
80002a66:	0a 68       	and	r8,r5
80002a68:	00 00       	add	r0,r0
80002a6a:	0a 6c       	and	r12,r5

80002a6c <set_idle_store_isr>:
{
	xQueueSend(store, &ptr, 0);
}

void set_idle_store_isr(xQueueHandle store, void * ptr)
{
80002a6c:	d4 01       	pushm	lr
80002a6e:	20 2d       	sub	sp,8
80002a70:	50 0b       	stdsp	sp[0x0],r11
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002a72:	30 09       	mov	r9,0
80002a74:	fa ca ff f8 	sub	r10,sp,-8
80002a78:	14 d9       	st.w	--r10,r9
	xQueueSendFromISR(store, &ptr, &xHigherPriorityTaskWoken);
80002a7a:	1a 9b       	mov	r11,sp
80002a7c:	f0 1f 00 02 	mcall	80002a84 <set_idle_store_isr+0x18>
}
80002a80:	2f ed       	sub	sp,-8
80002a82:	d8 02       	popm	pc
80002a84:	80 00       	ld.sh	r0,r0[0x0]
80002a86:	61 64       	ld.w	r4,r0[0x58]

80002a88 <payload_rx>:
		//logFromISR("ss");
	}
}

static void payload_rx(void * payload)
{
80002a88:	d4 01       	pushm	lr
    set_payload_idle_isr(payload);
80002a8a:	48 48       	lddpc	r8,80002a98 <payload_rx+0x10>
80002a8c:	70 08       	ld.w	r8,r8[0x0]
80002a8e:	18 9b       	mov	r11,r12
80002a90:	10 9c       	mov	r12,r8
80002a92:	f0 1f 00 03 	mcall	80002a9c <payload_rx+0x14>
	else
	{
		//logFromISR("ss");
	}
	#endif
}
80002a96:	d8 02       	popm	pc
80002a98:	00 00       	add	r0,r0
80002a9a:	0a a4       	st.w	r5++,r4
80002a9c:	80 00       	ld.sh	r0,r0[0x0]
80002a9e:	2a 6c       	sub	r12,-90

80002aa0 <phy_rx>:
	xQueueSendFromISR -- freertos
Called By: phy_xnl_rx
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
80002aa0:	d4 01       	pushm	lr
80002aa2:	20 2d       	sub	sp,8
80002aa4:	50 0c       	stdsp	sp[0x0],r12
	//memcpy(xx, phy_ptr, sizeof(phy_fragment_t));
	//set_phy_idle_isr(&phy_ptr, &xHigherPriorityTaskWoken);
	
	Bool res = FALSE;
	
	if(NULL == phy_ptr)
80002aa6:	58 0c       	cp.w	r12,0
80002aa8:	c1 10       	breq	80002aca <phy_rx+0x2a>
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
    /*variables are used to store the push result in interrupt*/
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002aaa:	30 08       	mov	r8,0
80002aac:	50 18       	stdsp	sp[0x4],r8
	if(NULL == phy_ptr)
	{
		return;
	}
	
    U16 phy_ctrl = phy_ptr->xnl_fragment.phy_header.phy_control;
80002aae:	98 88       	ld.uh	r8,r12[0x0]
80002ab0:	e2 18 f0 00 	andl	r8,0xf000,COH
80002ab4:	e0 48 40 00 	cp.w	r8,16384
80002ab8:	c0 91       	brne	80002aca <phy_rx+0x2a>

    if (XCMPXNL_DATA == (phy_ctrl & 0xF000))
    {
        /*push the xnl packet to queue*/
        if( pdTRUE == xQueueSendFromISR(
80002aba:	48 68       	lddpc	r8,80002ad0 <phy_rx+0x30>
80002abc:	70 0c       	ld.w	r12,r8[0x0]
80002abe:	30 09       	mov	r9,0
80002ac0:	fa ca ff fc 	sub	r10,sp,-4
80002ac4:	1a 9b       	mov	r11,sp
80002ac6:	f0 1f 00 04 	mcall	80002ad4 <phy_rx+0x34>
		}	

    }
		
 
}
80002aca:	2f ed       	sub	sp,-8
80002acc:	d8 02       	popm	pc
80002ace:	00 00       	add	r0,r0
80002ad0:	00 00       	add	r0,r0
80002ad2:	0a b0       	st.h	r5++,r0
80002ad4:	80 00       	ld.sh	r0,r0[0x0]
80002ad6:	61 64       	ld.w	r4,r0[0x58]

80002ad8 <set_idle_store>:
	}
}


void set_idle_store(xQueueHandle store, void * ptr)
{
80002ad8:	eb cd 40 80 	pushm	r7,lr
80002adc:	20 1d       	sub	sp,4
80002ade:	fa c7 ff fc 	sub	r7,sp,-4
80002ae2:	0e db       	st.w	--r7,r11
	xQueueSend(store, &ptr, 0);
80002ae4:	30 09       	mov	r9,0
80002ae6:	12 9a       	mov	r10,r9
80002ae8:	1a 9b       	mov	r11,sp
80002aea:	f0 1f 00 03 	mcall	80002af4 <set_idle_store+0x1c>
}
80002aee:	2f fd       	sub	sp,-4
80002af0:	e3 cd 80 80 	ldm	sp++,r7,pc
80002af4:	80 00       	ld.sh	r0,r0[0x0]
80002af6:	61 b4       	ld.w	r4,r0[0x6c]

80002af8 <phy_tx>:
Calls:   
	xQueueSend -- freertos
Called By: xnl_tx -- xnl.c
*/
void phy_tx(phy_fragment_t * phy)
{	
80002af8:	d4 01       	pushm	lr
80002afa:	20 1d       	sub	sp,4
80002afc:	50 0c       	stdsp	sp[0x0],r12
	
	//phy_fragment_t * phy_ptr = malloc(sizeof(phy_fragment_t));
	//memcpy(phy_ptr, phy, sizeof(phy_fragment_t));
	//log("\n\r T_xcmp:%4x \n\r", phy->xnl_fragment.xnl_payload.xnl_content_data_msg.xcmp_opcode);
	//log("T_xnl-opcode:%4x", xnl->xnl_header.opcode);//log:R_xnl指令	
	if(XCMPXNL_DATA == (phy_ctrl & 0xF000))
80002afe:	98 88       	ld.uh	r8,r12[0x0]
80002b00:	e2 18 f0 00 	andl	r8,0xf000,COH
80002b04:	e0 48 40 00 	cp.w	r8,16384
80002b08:	c0 d1       	brne	80002b22 <phy_tx+0x2a>
	{
		/*push the xnl packet to queue to send */
		if(NULL != phy_xnl_frame_tx)
80002b0a:	49 08       	lddpc	r8,80002b48 <phy_tx+0x50>
80002b0c:	70 08       	ld.w	r8,r8[0x0]
80002b0e:	58 08       	cp.w	r8,0
80002b10:	c1 a0       	breq	80002b44 <phy_tx+0x4c>
		{
			if( pdTRUE == xQueueSend(phy_xnl_frame_tx, &phy, 0))
80002b12:	48 e8       	lddpc	r8,80002b48 <phy_tx+0x50>
80002b14:	70 0c       	ld.w	r12,r8[0x0]
80002b16:	30 09       	mov	r9,0
80002b18:	12 9a       	mov	r10,r9
80002b1a:	1a 9b       	mov	r11,sp
80002b1c:	f0 1f 00 0c 	mcall	80002b4c <phy_tx+0x54>
80002b20:	c1 28       	rjmp	80002b44 <phy_tx+0x4c>
		}
	}
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE		
	else if((SPEAKER_DATA == (phy_ctrl & 0xF000))
80002b22:	e0 48 10 00 	cp.w	r8,4096
80002b26:	5f 0a       	sreq	r10
80002b28:	e0 48 20 00 	cp.w	r8,8192
80002b2c:	5f 09       	sreq	r9
80002b2e:	f5 e9 10 09 	or	r9,r10,r9
80002b32:	c0 71       	brne	80002b40 <phy_tx+0x48>
80002b34:	e0 48 50 00 	cp.w	r8,20480
80002b38:	c0 40       	breq	80002b40 <phy_tx+0x48>
80002b3a:	e0 48 60 00 	cp.w	r8,24576
80002b3e:	c0 31       	brne	80002b44 <phy_tx+0x4c>
	    || (MIC_DATA  == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_RX == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_TX == (phy_ctrl & 0xF000))
	)
	{		
		if(NULL == phy_payload_frame_tx)
80002b40:	48 48       	lddpc	r8,80002b50 <phy_tx+0x58>
80002b42:	70 08       	ld.w	r8,r8[0x0]
	
	if(res != TRUE)
	{
		//vPortFree(phy_ptr);
	}
}
80002b44:	2f fd       	sub	sp,-4
80002b46:	d8 02       	popm	pc
80002b48:	00 00       	add	r0,r0
80002b4a:	0a d0       	st.w	--r5,r0
80002b4c:	80 00       	ld.sh	r0,r0[0x0]
80002b4e:	61 b4       	ld.w	r4,r0[0x6c]
80002b50:	00 00       	add	r0,r0
80002b52:	0a c4       	st.b	r5++,r4

80002b54 <get_idle_store_isr>:
		return NULL;
	}
}

void * get_idle_store_isr(xQueueHandle store)
{
80002b54:	d4 01       	pushm	lr
80002b56:	20 2d       	sub	sp,8
	void * ptr = NULL;
80002b58:	30 08       	mov	r8,0
80002b5a:	50 18       	stdsp	sp[0x4],r8
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002b5c:	50 08       	stdsp	sp[0x0],r8
	
	if(pdTRUE == xQueueReceiveFromISR(store, &ptr, &xHigherPriorityTaskWoken))
80002b5e:	1a 9a       	mov	r10,sp
80002b60:	fa cb ff fc 	sub	r11,sp,-4
80002b64:	f0 1f 00 05 	mcall	80002b78 <get_idle_store_isr+0x24>
80002b68:	58 1c       	cp.w	r12,1
80002b6a:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80002b6e:	fb fc 00 01 	ld.weq	r12,sp[0x4]
	}
	else
	{
		return NULL;
	}
}
80002b72:	2f ed       	sub	sp,-8
80002b74:	d8 02       	popm	pc
80002b76:	00 00       	add	r0,r0
80002b78:	80 00       	ld.sh	r0,r0[0x0]
80002b7a:	5e b8       	rethi	r8

80002b7c <phy_tx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_tx_func( void * ssc)
{
80002b7c:	eb cd 40 c0 	pushm	r6-r7,lr
80002b80:	20 1d       	sub	sp,4
80002b82:	18 97       	mov	r7,r12
    if(NULL != phy_xnl_frame_tx)
80002b84:	4b a8       	lddpc	r8,80002c6c <phy_tx_func+0xf0>
80002b86:	70 08       	ld.w	r8,r8[0x0]
80002b88:	58 08       	cp.w	r8,0
80002b8a:	c6 60       	breq	80002c56 <phy_tx_func+0xda>
    {
  	  	/*send ssc data in xnl frame*/
  	  	phy_xnl_tx(&(((ssc_fragment_t * )ssc)->xnl_channel));		
80002b8c:	18 96       	mov	r6,r12
Called By:phy_tx_func
*/
static void phy_xnl_tx(xnl_channel_t * xnl_tx_channel)
{
	/*variables are used to store the push result in interrupt*/
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002b8e:	30 08       	mov	r8,0
80002b90:	50 08       	stdsp	sp[0x0],r8
	
	static S16 phy_tx_expexted_length = 0;
	static U8 phy_tx_index = 0;
	
	/*his is the code for handling any outgoing XNL Phy message*/
	switch(phy_tx_state)
80002b92:	4b 88       	lddpc	r8,80002c70 <phy_tx_func+0xf4>
80002b94:	70 08       	ld.w	r8,r8[0x0]
80002b96:	58 18       	cp.w	r8,1
80002b98:	c2 60       	breq	80002be4 <phy_tx_func+0x68>
80002b9a:	c0 43       	brcs	80002ba2 <phy_tx_func+0x26>
80002b9c:	58 28       	cp.w	r8,2
80002b9e:	c5 c1       	brne	80002c56 <phy_tx_func+0xda>
80002ba0:	c5 58       	rjmp	80002c4a <phy_tx_func+0xce>
	{
		/*Waiting for the send xnl packet*/
		case WAITING_FOR_PHY_TX:			
			if( pdTRUE == xQueueReceiveFromISR(
80002ba2:	4b 38       	lddpc	r8,80002c6c <phy_tx_func+0xf0>
80002ba4:	70 0c       	ld.w	r12,r8[0x0]
80002ba6:	1a 9a       	mov	r10,sp
80002ba8:	4b 3b       	lddpc	r11,80002c74 <phy_tx_func+0xf8>
80002baa:	f0 1f 00 34 	mcall	80002c78 <phy_tx_func+0xfc>
80002bae:	58 1c       	cp.w	r12,1
80002bb0:	c1 41       	brne	80002bd8 <phy_tx_func+0x5c>
				  phy_xnl_frame_tx
				, &phy_ptr
				, &xHigherPriorityTaskWoken 
			))
			{								
				phy_tx_expexted_length = 
80002bb2:	4b 18       	lddpc	r8,80002c74 <phy_tx_func+0xf8>
80002bb4:	70 08       	ld.w	r8,r8[0x0]
80002bb6:	90 08       	ld.sh	r8,r8[0x0]
80002bb8:	10 9a       	mov	r10,r8
80002bba:	f5 da c0 08 	bfextu	r10,r10,0x0,0x8
80002bbe:	4b 09       	lddpc	r9,80002c7c <phy_tx_func+0x100>
80002bc0:	b2 0a       	st.h	r9[0x0],r10
				*/
				xnl_tx_channel->dword = 
				                   phy_ptr->xnl_fragment.phy_header.phy_control;
				
				/*Transmit 0xABCD0000 | Type/Length.*/
				xnl_tx_channel->dword |= PHYHEADER32;
80002bc2:	5c 78       	castu.h	r8
80002bc4:	ea 18 ab cd 	orh	r8,0xabcd
80002bc8:	8f 18       	st.w	r7[0x4],r8
				
				phy_tx_index = 1;
80002bca:	30 19       	mov	r9,1
80002bcc:	4a d8       	lddpc	r8,80002c80 <phy_tx_func+0x104>
80002bce:	b0 89       	st.b	r8[0x0],r9
				phy_tx_state = WRITE_NEXT_DWORD;	
80002bd0:	30 19       	mov	r9,1
80002bd2:	4a 88       	lddpc	r8,80002c70 <phy_tx_func+0xf4>
80002bd4:	91 09       	st.w	r8[0x0],r9
80002bd6:	c4 08       	rjmp	80002c56 <phy_tx_func+0xda>
				/*The new transmission has started.*/
			}
			else
			{
				/*Nothing new to transmit, send an idle frame*/
				xnl_tx_channel->dword = XNL_IDLE;
80002bd8:	e0 68 5a 5a 	mov	r8,23130
80002bdc:	ea 18 ab cd 	orh	r8,0xabcd
80002be0:	8f 18       	st.w	r7[0x4],r8
80002be2:	c3 a8       	rjmp	80002c56 <phy_tx_func+0xda>
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80002be4:	4a 7a       	lddpc	r10,80002c80 <phy_tx_func+0x104>
80002be6:	15 88       	ld.ub	r8,r10[0x0]
				xnl_tx_channel->dword = XNL_IDLE;
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
80002be8:	4a 39       	lddpc	r9,80002c74 <phy_tx_func+0xf8>
80002bea:	72 09       	ld.w	r9,r9[0x0]
80002bec:	f2 08 05 19 	ld.uh	r9,r9[r8<<0x1]
80002bf0:	b1 69       	lsl	r9,0x10
80002bf2:	99 19       	st.w	r12[0x4],r9
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80002bf4:	2f f8       	sub	r8,-1
80002bf6:	5c 58       	castu.b	r8
80002bf8:	b4 88       	st.b	r10[0x0],r8

			phy_tx_expexted_length -= 2;
80002bfa:	4a 1b       	lddpc	r11,80002c7c <phy_tx_func+0x100>
80002bfc:	96 0c       	ld.sh	r12,r11[0x0]
80002bfe:	20 2c       	sub	r12,2
80002c00:	5c 8c       	casts.h	r12
80002c02:	f5 dc b0 10 	bfexts	r10,r12,0x0,0x10
80002c06:	b6 0a       	st.h	r11[0x0],r10
			
			/*have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80002c08:	30 0b       	mov	r11,0
80002c0a:	f6 0a 19 00 	cp.h	r10,r11
80002c0e:	e0 89 00 09 	brgt	80002c20 <phy_tx_func+0xa4>
			{
				/*Must immediately send 0x00BA in Slot 4.*/
				xnl_tx_channel->dword |= PHYTERMRIGHT;
80002c12:	e8 19 00 ba 	orl	r9,0xba
80002c16:	8f 19       	st.w	r7[0x4],r9
				
				/*Go back to waiting.*/
				phy_tx_state = WAITING_FOR_PHY_TX;
80002c18:	30 09       	mov	r9,0
80002c1a:	49 68       	lddpc	r8,80002c70 <phy_tx_func+0xf4>
80002c1c:	91 09       	st.w	r8[0x0],r9
80002c1e:	c1 c8       	rjmp	80002c56 <phy_tx_func+0xda>
				break;
			}

			/*Have not broken. Transmit 2nd hWord.*/
			xnl_tx_channel->dword |=  phy_ptr->fragment_element[phy_tx_index++];
80002c20:	49 5a       	lddpc	r10,80002c74 <phy_tx_func+0xf8>
80002c22:	74 0a       	ld.w	r10,r10[0x0]
80002c24:	f4 08 05 1a 	ld.uh	r10,r10[r8<<0x1]
80002c28:	14 49       	or	r9,r10
80002c2a:	8f 19       	st.w	r7[0x4],r9
80002c2c:	2f f8       	sub	r8,-1
80002c2e:	49 59       	lddpc	r9,80002c80 <phy_tx_func+0x104>
80002c30:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
80002c32:	20 2c       	sub	r12,2
80002c34:	49 28       	lddpc	r8,80002c7c <phy_tx_func+0x100>
80002c36:	b0 0c       	st.h	r8[0x0],r12
			
			/*Have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80002c38:	30 08       	mov	r8,0
80002c3a:	f0 0c 19 00 	cp.h	r12,r8
80002c3e:	e0 89 00 0c 	brgt	80002c56 <phy_tx_func+0xda>
			{
				/*Must send 0x00BA0000 next interrupt in Slot 3&4*/
				phy_tx_state = SEND_TAILED;
80002c42:	30 29       	mov	r9,2
80002c44:	48 b8       	lddpc	r8,80002c70 <phy_tx_func+0xf4>
80002c46:	91 09       	st.w	r8[0x0],r9
80002c48:	c0 78       	rjmp	80002c56 <phy_tx_func+0xda>
			}
			break;

		case SEND_TAILED:
			/*send 0x00BA0000*/
			xnl_tx_channel->dword = PHYTERMLEFT;
80002c4a:	fc 18 00 ba 	movh	r8,0xba
80002c4e:	99 18       	st.w	r12[0x4],r8
			
			/*Go back to waiting.*/		
			phy_tx_state = WAITING_FOR_PHY_TX;		
80002c50:	30 09       	mov	r9,0
80002c52:	48 88       	lddpc	r8,80002c70 <phy_tx_func+0xf4>
80002c54:	91 09       	st.w	r8[0x0],r9
	//#else
	///*send idle frame*/	
	//((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
	//((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
	//#endif /*end if*/
	((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
80002c56:	e0 68 5a 5a 	mov	r8,23130
80002c5a:	ea 18 ab cd 	orh	r8,0xabcd
80002c5e:	8f 28       	st.w	r7[0x8],r8
	((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
80002c60:	30 08       	mov	r8,0
80002c62:	8f 38       	st.w	r7[0xc],r8
}
80002c64:	2f fd       	sub	sp,-4
80002c66:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002c6a:	00 00       	add	r0,r0
80002c6c:	00 00       	add	r0,r0
80002c6e:	0a d0       	st.w	--r5,r0
80002c70:	00 00       	add	r0,r0
80002c72:	0a 90       	mov	r0,r5
80002c74:	00 00       	add	r0,r0
80002c76:	0a 9c       	mov	r12,r5
80002c78:	80 00       	ld.sh	r0,r0[0x0]
80002c7a:	5e b8       	rethi	r8
80002c7c:	00 00       	add	r0,r0
80002c7e:	0a b8       	st.h	r5++,r8
80002c80:	00 00       	add	r0,r0
80002c82:	0a 70       	tst	r0,r5

80002c84 <get_idle_store>:
	}//End of RxMedia Phy Handler.
}
#endif /*end if*/

void * get_idle_store(xQueueHandle store)
{
80002c84:	d4 01       	pushm	lr
80002c86:	20 1d       	sub	sp,4
	void * ptr = NULL;
80002c88:	30 0a       	mov	r10,0
80002c8a:	fa cb ff fc 	sub	r11,sp,-4
80002c8e:	16 da       	st.w	--r11,r10

	if(pdTRUE == xQueueReceive(store, &ptr, 0))
80002c90:	14 99       	mov	r9,r10
80002c92:	1a 9b       	mov	r11,sp
80002c94:	f0 1f 00 05 	mcall	80002ca8 <get_idle_store+0x24>
80002c98:	58 1c       	cp.w	r12,1
80002c9a:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80002c9e:	fb fc 00 00 	ld.weq	r12,sp[0x0]
	}
	else
	{
		return NULL;
	}
}
80002ca2:	2f fd       	sub	sp,-4
80002ca4:	d8 02       	popm	pc
80002ca6:	00 00       	add	r0,r0
80002ca8:	80 00       	ld.sh	r0,r0[0x0]
80002caa:	5f a8       	srle	r8

80002cac <phy_init>:
    register_rx_tx_func -- ssc.c
	xQueueCreate -- freertos
Called By: xnl_init -- xnl.c
*/
void phy_init( void )
{
80002cac:	d4 01       	pushm	lr
    /*register the func to send/receive ssc packet*/
    register_rx_tx_func(phy_rx_func, phy_tx_func);	
80002cae:	48 4b       	lddpc	r11,80002cbc <phy_init+0x10>
80002cb0:	48 4c       	lddpc	r12,80002cc0 <phy_init+0x14>
80002cb2:	f0 1f 00 05 	mcall	80002cc4 <phy_init+0x18>
	
	/*initialize the SSC*/
	ssc_init();
80002cb6:	f0 1f 00 05 	mcall	80002cc8 <phy_init+0x1c>
	
	/*send device_master_query to connect radio*/
	//xnl_send_device_master_query();
	
}
80002cba:	d8 02       	popm	pc
80002cbc:	80 00       	ld.sh	r0,r0[0x0]
80002cbe:	2b 7c       	sub	r12,-73
80002cc0:	80 00       	ld.sh	r0,r0[0x0]
80002cc2:	2c cc       	sub	r12,-52
80002cc4:	80 00       	ld.sh	r0,r0[0x0]
80002cc6:	3d 20       	mov	r0,-46
80002cc8:	80 00       	ld.sh	r0,r0[0x0]
80002cca:	3d 34       	mov	r4,-45

80002ccc <phy_rx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_rx_func( void * ssc)
{    
80002ccc:	eb cd 40 e0 	pushm	r5-r7,lr
80002cd0:	18 97       	mov	r7,r12
		
	if(NULL != phy_xnl_frame_rx)
80002cd2:	fe f8 0e 7a 	ld.w	r8,pc[3706]
80002cd6:	70 08       	ld.w	r8,r8[0x0]
80002cd8:	58 08       	cp.w	r8,0
80002cda:	e0 80 01 08 	breq	80002eea <phy_rx_func+0x21e>
	static U16 phy_check_sum = 0;

	static phy_rx_state_t  phy_rx_state = WAITING_FOR_HEADER;
	static U32 phy_rx_count = 0;

	U32 phy_dword = xnl_rx_channel->dword;	
80002cde:	78 16       	ld.w	r6,r12[0x4]

	phy_rx_count++;
80002ce0:	fe f8 0e 70 	ld.w	r8,pc[3696]
80002ce4:	70 09       	ld.w	r9,r8[0x0]
80002ce6:	2f f9       	sub	r9,-1
80002ce8:	91 09       	st.w	r8[0x0],r9
	
	/*This is the code for parsing the incoming physical message.*/
	switch (phy_rx_state)
80002cea:	fe f8 0e 6a 	ld.w	r8,pc[3690]
80002cee:	70 08       	ld.w	r8,r8[0x0]
80002cf0:	58 18       	cp.w	r8,1
80002cf2:	e0 80 00 85 	breq	80002dfc <phy_rx_func+0x130>
80002cf6:	c0 73       	brcs	80002d04 <phy_rx_func+0x38>
80002cf8:	58 28       	cp.w	r8,2
80002cfa:	c5 c0       	breq	80002db2 <phy_rx_func+0xe6>
80002cfc:	58 38       	cp.w	r8,3
80002cfe:	e0 81 00 f6 	brne	80002eea <phy_rx_func+0x21e>
80002d02:	cd 58       	rjmp	80002eac <phy_rx_func+0x1e0>

        /*Waiting for something. Most frequent visit.*/		
		case WAITING_FOR_HEADER:
		
			/*Ignore Idles.*/
			if (0xABCD5A5A == phy_dword)
80002d04:	e0 6a 5a 5a 	mov	r10,23130
80002d08:	ea 1a ab cd 	orh	r10,0xabcd
80002d0c:	14 36       	cp.w	r6,r10
80002d0e:	e0 80 00 ee 	breq	80002eea <phy_rx_func+0x21e>
			{
				break;
			}	

			/*Skip until Header.*/		
			if (0xABCD != (phy_dword >> 16))
80002d12:	ec 08 16 10 	lsr	r8,r6,0x10
80002d16:	e0 48 ab cd 	cp.w	r8,43981
80002d1a:	e0 81 00 e8 	brne	80002eea <phy_rx_func+0x21e>
			{			
				break;
			}
		
			/*Length excluding CSUM.*/
			phy_rx_expexted_length = (phy_dword & 0x000000FF) - 2;
80002d1e:	eb d6 b0 10 	bfexts	r5,r6,0x0,0x10
80002d22:	f1 d5 c0 08 	bfextu	r8,r5,0x0,0x8
80002d26:	20 28       	sub	r8,2
80002d28:	fe f9 0e 30 	ld.w	r9,pc[3632]
80002d2c:	b2 08       	st.h	r9[0x0],r8
			
			/*Discard degenerate message.*/
			if (phy_rx_expexted_length <= 0)
80002d2e:	30 09       	mov	r9,0
80002d30:	f2 08 19 00 	cp.h	r8,r9
80002d34:	e0 8a 00 db 	brle	80002eea <phy_rx_func+0x21e>
			{
				break;
			}
		
			phy_rx_length = 0;
80002d38:	fe f8 0e 24 	ld.w	r8,pc[3620]
80002d3c:	b0 09       	st.h	r8[0x0],r9

			phy_frame_ptr = get_xnl_idle_isr();
80002d3e:	fe f8 0e 22 	ld.w	r8,pc[3618]
80002d42:	70 0c       	ld.w	r12,r8[0x0]
80002d44:	f0 1f 03 88 	mcall	80003b64 <phy_rx_func+0xe98>
80002d48:	fe f8 0e 20 	ld.w	r8,pc[3616]
80002d4c:	91 0c       	st.w	r8[0x0],r12
			if(NULL == phy_frame_ptr)
80002d4e:	58 0c       	cp.w	r12,0
80002d50:	e0 80 00 cd 	breq	80002eea <phy_rx_func+0x21e>
			{
				break;
			}
					
			phy_frame_ptr->fragment_element[phy_rx_length++] = phy_dword;
80002d54:	fe f8 0e 08 	ld.w	r8,pc[3592]
80002d58:	90 09       	ld.sh	r9,r8[0x0]
80002d5a:	f8 09 0a 15 	st.h	r12[r9<<0x1],r5
80002d5e:	2f f9       	sub	r9,-1
80002d60:	5c 89       	casts.h	r9
			
			/*time stamp*/
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
80002d62:	fe fa 0e 06 	ld.w	r10,pc[3590]
80002d66:	74 0a       	ld.w	r10,r10[0x0]
80002d68:	fe fb 0d e8 	ld.w	r11,pc[3560]
80002d6c:	76 0b       	ld.w	r11,r11[0x0]
80002d6e:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
80002d72:	2f f9       	sub	r9,-1
80002d74:	b0 09       	st.h	r8[0x0],r9
													(phy_rx_count) & 0x0000FFFF;
			
			/*This switch tests the fragment type, and adjusts receiver state
			accordingly.*/
			/*Check frag type*/
			switch (phy_dword & 0x00000F00)
80002d76:	e2 16 0f 00 	andl	r6,0xf00,COH
80002d7a:	e0 46 01 00 	cp.w	r6,256
80002d7e:	c0 c0       	breq	80002d96 <phy_rx_func+0xca>
80002d80:	e0 8b 00 05 	brhi	80002d8a <phy_rx_func+0xbe>
80002d84:	58 06       	cp.w	r6,0
80002d86:	c0 80       	breq	80002d96 <phy_rx_func+0xca>
80002d88:	c0 c8       	rjmp	80002da0 <phy_rx_func+0xd4>
80002d8a:	e0 46 02 00 	cp.w	r6,512
80002d8e:	c0 40       	breq	80002d96 <phy_rx_func+0xca>
80002d90:	e0 46 03 00 	cp.w	r6,768
80002d94:	c0 61       	brne	80002da0 <phy_rx_func+0xd4>
			{
				case SINGLE_FRAGMENT:  //Only Fragment.
				case FIRST_FRAGMENT:   //First of Multi-fragment.
				case MIDDLE_FRAGMENT:  //Continuing Multi-fragment.
				case LAST_FRAGMENT:    //Last Multi-fragment.
					phy_rx_state = WAITING_CHECK_SUM;
80002d96:	30 29       	mov	r9,2
80002d98:	fe f8 0d bc 	ld.w	r8,pc[3516]
80002d9c:	91 09       	st.w	r8[0x0],r9
80002d9e:	ca 68       	rjmp	80002eea <phy_rx_func+0x21e>
				break;
				default:
					set_xnl_idle_isr(phy_frame_ptr);			
80002da0:	fe f8 0d c0 	ld.w	r8,pc[3520]
80002da4:	70 0c       	ld.w	r12,r8[0x0]
80002da6:	fe f8 0d c2 	ld.w	r8,pc[3522]
80002daa:	70 0b       	ld.w	r11,r8[0x0]
80002dac:	f0 1f 03 70 	mcall	80003b6c <phy_rx_func+0xea0>
80002db0:	c9 d8       	rjmp	80002eea <phy_rx_func+0x21e>
		
			/*Stores CSUM*/
			phy_check_sum  = (phy_dword & 0xFFFF0000) >> 16;
			
			/*sums in first hWord*/
			phy_check_sum += (phy_dword & 0x0000FFFF);		
80002db2:	f5 d6 b0 10 	bfexts	r10,r6,0x0,0x10
80002db6:	b1 86       	lsr	r6,0x10
80002db8:	14 06       	add	r6,r10
80002dba:	fe f8 0d b6 	ld.w	r8,pc[3510]
80002dbe:	b0 06       	st.h	r8[0x0],r6
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
80002dc0:	fe f8 0d 9c 	ld.w	r8,pc[3484]
80002dc4:	90 09       	ld.sh	r9,r8[0x0]
80002dc6:	fe fb 0d a2 	ld.w	r11,pc[3490]
80002dca:	76 0b       	ld.w	r11,r11[0x0]
80002dcc:	f6 09 0a 1a 	st.h	r11[r9<<0x1],r10
80002dd0:	2f f9       	sub	r9,-1
80002dd2:	b0 09       	st.h	r8[0x0],r9
														 phy_dword & 0x0000FFFF;
					
			phy_rx_expexted_length -= 2;
80002dd4:	fe f9 0d 84 	ld.w	r9,pc[3460]
80002dd8:	92 08       	ld.sh	r8,r9[0x0]
80002dda:	20 28       	sub	r8,2
80002ddc:	b2 08       	st.h	r9[0x0],r8
			
			/*Normal case for greater than one byte payloads.*/
			if (phy_rx_expexted_length > 0)
80002dde:	30 09       	mov	r9,0
80002de0:	f2 08 19 00 	cp.h	r8,r9
80002de4:	e0 8a 00 07 	brle	80002df2 <phy_rx_func+0x126>
			{					  
				phy_rx_state = READING_FRAGMENT;
80002de8:	30 19       	mov	r9,1
80002dea:	fe f8 0d 6a 	ld.w	r8,pc[3434]
80002dee:	91 09       	st.w	r8[0x0],r9
80002df0:	c7 d8       	rjmp	80002eea <phy_rx_func+0x21e>
	    		Note that all segments must align with a 32-bit boundary and
				beginning of each XCMP/XNL payload frame must start on slot 3
				Thus, segments of odd length must append a 0x0000 at the end
				(slot 4) to ensure alignment. [9.1.3]
				*/
				phy_rx_state = WAITING_LAST_TERM;
80002df2:	30 39       	mov	r9,3
80002df4:	fe f8 0d 60 	ld.w	r8,pc[3424]
80002df8:	91 09       	st.w	r8[0x0],r9
80002dfa:	c7 88       	rjmp	80002eea <phy_rx_func+0x21e>
			}			
		
			break;

		case READING_FRAGMENT:
			phy_check_sum += (phy_dword & 0xFFFF0000) >> 16;
80002dfc:	ec 0a 14 10 	asr	r10,r6,0x10
80002e00:	fe f8 0d 70 	ld.w	r8,pc[3440]
80002e04:	90 09       	ld.sh	r9,r8[0x0]
80002e06:	14 09       	add	r9,r10
80002e08:	b0 09       	st.h	r8[0x0],r9
	
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
80002e0a:	fe f9 0d 52 	ld.w	r9,pc[3410]
80002e0e:	92 08       	ld.sh	r8,r9[0x0]
80002e10:	fe fb 0d 58 	ld.w	r11,pc[3416]
80002e14:	76 0b       	ld.w	r11,r11[0x0]
80002e16:	f6 08 0a 1a 	st.h	r11[r8<<0x1],r10
80002e1a:	2f f8       	sub	r8,-1
80002e1c:	5c 88       	casts.h	r8
80002e1e:	b2 08       	st.h	r9[0x0],r8
												 (phy_dword & 0xFFFF0000) >> 16;
	
			phy_rx_expexted_length -= 2;
80002e20:	fe fa 0d 38 	ld.w	r10,pc[3384]
80002e24:	94 09       	ld.sh	r9,r10[0x0]
80002e26:	20 29       	sub	r9,2
80002e28:	b4 09       	st.h	r10[0x0],r9
			if (phy_rx_expexted_length <= 0)
80002e2a:	30 0a       	mov	r10,0
80002e2c:	f4 09 19 00 	cp.h	r9,r10
80002e30:	e0 89 00 20 	brgt	80002e70 <phy_rx_func+0x1a4>
				Terminator should be in 2nd hWord.
				Shaoqun says useful bits not used. The packet will always end
				with $00BA. [9.1.2.8]	
				*/
				
				if ((0x000000BA == (phy_dword  & 0x0000FFFF)) 
80002e34:	ed d6 c0 10 	bfextu	r6,r6,0x0,0x10
80002e38:	e0 46 00 ba 	cp.w	r6,186
80002e3c:	c0 d1       	brne	80002e56 <phy_rx_func+0x18a>
80002e3e:	fe f8 0d 32 	ld.w	r8,pc[3378]
80002e42:	90 09       	ld.sh	r9,r8[0x0]
80002e44:	f4 09 19 00 	cp.h	r9,r10
80002e48:	c0 71       	brne	80002e56 <phy_rx_func+0x18a>
					&& (phy_check_sum == 0))
				{
					phy_rx(phy_frame_ptr);
80002e4a:	fe f8 0d 1e 	ld.w	r8,pc[3358]
80002e4e:	70 0c       	ld.w	r12,r8[0x0]
80002e50:	f0 1f 03 49 	mcall	80003b74 <phy_rx_func+0xea8>
80002e54:	c0 98       	rjmp	80002e66 <phy_rx_func+0x19a>
				}
				else
				{
					set_xnl_idle_isr(phy_frame_ptr);
80002e56:	fe f8 0d 0a 	ld.w	r8,pc[3338]
80002e5a:	70 0c       	ld.w	r12,r8[0x0]
80002e5c:	fe f8 0d 0c 	ld.w	r8,pc[3340]
80002e60:	70 0b       	ld.w	r11,r8[0x0]
80002e62:	f0 1f 03 43 	mcall	80003b6c <phy_rx_func+0xea0>
				}

				phy_rx_state = WAITING_FOR_HEADER;
80002e66:	30 09       	mov	r9,0
80002e68:	fe f8 0c ec 	ld.w	r8,pc[3308]
80002e6c:	91 09       	st.w	r8[0x0],r9
80002e6e:	c3 e8       	rjmp	80002eea <phy_rx_func+0x21e>
				break;
			}
		
			/*Have not broken. 2nd hWord contains payload.*/
			phy_check_sum += (phy_dword & 0x0000FFFF);
80002e70:	5c 86       	casts.h	r6
80002e72:	fe f9 0c fe 	ld.w	r9,pc[3326]
80002e76:	92 0a       	ld.sh	r10,r9[0x0]
80002e78:	0c 0a       	add	r10,r6
80002e7a:	b2 0a       	st.h	r9[0x0],r10
		
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
80002e7c:	fe f9 0c ec 	ld.w	r9,pc[3308]
80002e80:	72 09       	ld.w	r9,r9[0x0]
80002e82:	f2 08 0a 16 	st.h	r9[r8<<0x1],r6
80002e86:	2f f8       	sub	r8,-1
80002e88:	fe f9 0c d4 	ld.w	r9,pc[3284]
80002e8c:	b2 08       	st.h	r9[0x0],r8
													   (phy_dword & 0x0000FFFF);
		
			phy_rx_expexted_length -= 2;
80002e8e:	fe f9 0c ca 	ld.w	r9,pc[3274]
80002e92:	92 08       	ld.sh	r8,r9[0x0]
80002e94:	20 28       	sub	r8,2
80002e96:	b2 08       	st.h	r9[0x0],r8
			if (phy_rx_expexted_length <= 0)
80002e98:	30 09       	mov	r9,0
80002e9a:	f2 08 19 00 	cp.h	r8,r9
80002e9e:	e0 89 00 26 	brgt	80002eea <phy_rx_func+0x21e>
			{
				/*All read in. Next Word should be 0x00BA0000.*/
				phy_rx_state = WAITING_LAST_TERM;
80002ea2:	30 39       	mov	r9,3
80002ea4:	fe f8 0c b0 	ld.w	r8,pc[3248]
80002ea8:	91 09       	st.w	r8[0x0],r9
80002eaa:	c2 08       	rjmp	80002eea <phy_rx_func+0x21e>
			}/*else, next Word contains more payload.*/
			break;

		/*Expecting last terminator 0x00BA0000.*/	
		case WAITING_LAST_TERM:			
			if ((0x00BA0000 == (phy_dword  & 0x00FF0000)) /*Expected found.*/
80002eac:	e6 16 00 ff 	andh	r6,0xff,COH
80002eb0:	fc 19 00 ba 	movh	r9,0xba
80002eb4:	12 36       	cp.w	r6,r9
80002eb6:	c0 e1       	brne	80002ed2 <phy_rx_func+0x206>
80002eb8:	fe f8 0c b8 	ld.w	r8,pc[3256]
80002ebc:	90 09       	ld.sh	r9,r8[0x0]
80002ebe:	30 08       	mov	r8,0
80002ec0:	f0 09 19 00 	cp.h	r9,r8
80002ec4:	c0 71       	brne	80002ed2 <phy_rx_func+0x206>
				&& (phy_check_sum == 0))/*Good checksum*/
			{
				phy_rx(phy_frame_ptr);
80002ec6:	fe f8 0c a2 	ld.w	r8,pc[3234]
80002eca:	70 0c       	ld.w	r12,r8[0x0]
80002ecc:	f0 1f 03 2a 	mcall	80003b74 <phy_rx_func+0xea8>
80002ed0:	c0 98       	rjmp	80002ee2 <phy_rx_func+0x216>

			}
			else
			{
				set_xnl_idle_isr(phy_frame_ptr);
80002ed2:	fe f8 0c 8e 	ld.w	r8,pc[3214]
80002ed6:	70 0c       	ld.w	r12,r8[0x0]
80002ed8:	fe f8 0c 90 	ld.w	r8,pc[3216]
80002edc:	70 0b       	ld.w	r11,r8[0x0]
80002ede:	f0 1f 03 24 	mcall	80003b6c <phy_rx_func+0xea0>
			}
				
			phy_rx_state = WAITING_FOR_HEADER;
80002ee2:	30 09       	mov	r9,0
80002ee4:	fe f8 0c 70 	ld.w	r8,pc[3184]
80002ee8:	91 09       	st.w	r8[0x0],r9
	static U8 _flag = 1;//0xABCDC014时，_flag为0；
						//0xABCDC010时，_flag为1；
			
	//payload_ptr_t *AMBE_payload_ptr;		
	
	if(is_first == FALSE)
80002eea:	fe f8 0c 8e 	ld.w	r8,pc[3214]
80002eee:	11 89       	ld.ub	r9,r8[0x0]
80002ef0:	30 08       	mov	r8,0
80002ef2:	f0 09 18 00 	cp.b	r9,r8
80002ef6:	c1 31       	brne	80002f1c <phy_rx_func+0x250>
	{
		payload_ptr = get_payload_idle_isr();
80002ef8:	fe f6 0c 84 	ld.w	r6,pc[3204]
80002efc:	6c 0c       	ld.w	r12,r6[0x0]
80002efe:	f0 1f 03 1a 	mcall	80003b64 <phy_rx_func+0xe98>
80002f02:	fe f8 0c 7e 	ld.w	r8,pc[3198]
80002f06:	91 0c       	st.w	r8[0x0],r12
		AMBE_payload_ptr = get_payload_idle_isr();
80002f08:	6c 0c       	ld.w	r12,r6[0x0]
80002f0a:	f0 1f 03 17 	mcall	80003b64 <phy_rx_func+0xe98>
80002f0e:	fe f8 0c 76 	ld.w	r8,pc[3190]
80002f12:	91 0c       	st.w	r8[0x0],r12
		is_first = TRUE;
80002f14:	30 19       	mov	r9,1
80002f16:	fe f8 0c 62 	ld.w	r8,pc[3170]
80002f1a:	b0 89       	st.b	r8[0x0],r9
	}	
	
	//This is the RxMedia Phy Handler.
	switch (RxMediaState)
80002f1c:	fe f8 0c 6c 	ld.w	r8,pc[3180]
80002f20:	70 08       	ld.w	r8,r8[0x0]
80002f22:	58 28       	cp.w	r8,2
80002f24:	e0 80 01 98 	breq	80003254 <phy_rx_func+0x588>
80002f28:	e0 8b 00 06 	brhi	80002f34 <phy_rx_func+0x268>
80002f2c:	58 08       	cp.w	r8,0
80002f2e:	c0 b0       	breq	80002f44 <phy_rx_func+0x278>
80002f30:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80002f34:	58 38       	cp.w	r8,3
80002f36:	e0 80 05 c5 	breq	80003ac0 <phy_rx_func+0xdf4>
80002f3a:	58 48       	cp.w	r8,4
80002f3c:	e0 81 06 05 	brne	80003b46 <phy_rx_func+0xe7a>
80002f40:	e0 8f 02 4b 	bral	800033d6 <phy_rx_func+0x70a>
	{
		case WAITINGABAB:

			
			if (payload_rx_channel->dword[0] == 0xABCD5A5A)//Ignore Idles.
80002f44:	6e 28       	ld.w	r8,r7[0x8]
80002f46:	e0 6a 5a 5a 	mov	r10,23130
80002f4a:	ea 1a ab cd 	orh	r10,0xabcd
80002f4e:	14 38       	cp.w	r8,r10
80002f50:	c0 71       	brne	80002f5e <phy_rx_func+0x292>
			{
				m_RxBurstType = VOICE_WATING;
80002f52:	30 09       	mov	r9,0
80002f54:	fe f8 0c 38 	ld.w	r8,pc[3128]
80002f58:	91 09       	st.w	r8[0x0],r9
80002f5a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
				//Upon receiving the idle frame, the m Rx Burst Type into an idle state in order to transmit the synchronization wait
				 break; 
			}
            
			if ((payload_rx_channel->dword[0]  & 0xFFFF0000) != 0xABCD0000)break; //Skip until Header. 
80002f5e:	10 99       	mov	r9,r8
80002f60:	e0 19 00 00 	andl	r9,0x0
80002f64:	fc 1a ab cd 	movh	r10,0xabcd
80002f68:	14 39       	cp.w	r9,r10
80002f6a:	e0 81 05 ee 	brne	80003b46 <phy_rx_func+0xe7a>
			}
			//logFromISR("\n\r P: %X \n\r", payload_rx_channel->word[1]);//测试收到的数据
			
#endif
			
			RxBytesWaiting = payload_rx_channel->dword[0] & 0x000000FF;
80002f6e:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
80002f72:	fe f9 0c 1e 	ld.w	r9,pc[3102]
80002f76:	93 08       	st.w	r9[0x0],r8
			/****Note AMBE stream protocol frame structure and the PCM frame structure is different*****/
					
			if ((payload_rx_channel->dword[0] & 0x0000F000 ) == PAYLOAD_DATA_ENH )//PAYLOAD_DATA_ENH (0x0c))
80002f78:	6e 29       	ld.w	r9,r7[0x8]
80002f7a:	e2 19 f0 00 	andl	r9,0xf000,COH
80002f7e:	e0 49 c0 00 	cp.w	r9,49152
80002f82:	e0 81 00 ce 	brne	8000311e <phy_rx_func+0x452>
			{
				AMBE_Media = 1;	
80002f86:	30 1a       	mov	r10,1
80002f88:	fe f9 0c 0c 	ld.w	r9,pc[3084]
80002f8c:	b2 8a       	st.b	r9[0x0],r10
				
				if (NULL== AMBE_payload_ptr){
80002f8e:	fe f9 0b f6 	ld.w	r9,pc[3062]
80002f92:	72 09       	ld.w	r9,r9[0x0]
80002f94:	58 09       	cp.w	r9,0
80002f96:	c0 71       	brne	80002fa4 <phy_rx_func+0x2d8>
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//测试是否有这种情况出现
80002f98:	fe fc 0c 00 	ld.w	r12,pc[3072]
80002f9c:	f0 1f 03 00 	mcall	80003b9c <phy_rx_func+0xed0>
80002fa0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
																	
				Item_ID = payload_rx_channel->byte[5];
80002fa4:	ef 3a 00 0d 	ld.ub	r10,r7[13]
80002fa8:	fe f9 0b f8 	ld.w	r9,pc[3064]
80002fac:	b2 8a       	st.b	r9[0x0],r10
				
				Item_Length = (payload_rx_channel->byte[4] & 0x7F);//7bits
80002fae:	ef 3b 00 0c 	ld.ub	r11,r7[12]
80002fb2:	f7 db c0 07 	bfextu	r11,r11,0x0,0x7
80002fb6:	fe fa 0b ee 	ld.w	r10,pc[3054]
80002fba:	95 0b       	st.w	r10[0x0],r11
								
				switch(Item_ID)
80002fbc:	13 89       	ld.ub	r9,r9[0x0]
80002fbe:	37 fa       	mov	r10,127
80002fc0:	f4 09 18 00 	cp.b	r9,r10
80002fc4:	c6 d0       	breq	8000309e <phy_rx_func+0x3d2>
80002fc6:	e0 8b 00 0c 	brhi	80002fde <phy_rx_func+0x312>
80002fca:	31 2a       	mov	r10,18
80002fcc:	f4 09 18 00 	cp.b	r9,r10
80002fd0:	c4 20       	breq	80003054 <phy_rx_func+0x388>
80002fd2:	31 3a       	mov	r10,19
80002fd4:	f4 09 18 00 	cp.b	r9,r10
80002fd8:	e0 81 00 83 	brne	800030de <phy_rx_func+0x412>
80002fdc:	c5 b8       	rjmp	80003092 <phy_rx_func+0x3c6>
80002fde:	2f 09       	sub	r9,-16
80002fe0:	30 1a       	mov	r10,1
80002fe2:	f4 09 18 00 	cp.b	r9,r10
80002fe6:	e0 8b 00 7c 	brhi	800030de <phy_rx_func+0x412>
					//The OB know the Call begin and discard the Voice Header
					//The OB know the Call end and discard the Voice  Terminator
					case Raw_Tx_Data_HT://0xF0
					case Raw_Rx_Data_HT://0xF1
					
							if ((payload_rx_channel->byte[6] & 0xF0 )== 0x10)//header
80002fea:	ef 38 00 0e 	ld.ub	r8,r7[14]
80002fee:	e2 18 00 f0 	andl	r8,0xf0,COH
80002ff2:	59 08       	cp.w	r8,16
80002ff4:	c0 71       	brne	80003002 <phy_rx_func+0x336>
							{
								m_RxBurstType = VOICEHEADER;
80002ff6:	30 19       	mov	r9,1
80002ff8:	fe f8 0b 94 	ld.w	r8,pc[2964]
80002ffc:	91 09       	st.w	r8[0x0],r9
80002ffe:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

							}
							else if ((payload_rx_channel->byte[6] & 0xF0) == 0x20)//Terminator
80003002:	e0 48 00 20 	cp.w	r8,32
80003006:	c2 11       	brne	80003048 <phy_rx_func+0x37c>
							{
								m_RxBurstType = VOICETERMINATOR;
80003008:	30 a9       	mov	r9,10
8000300a:	fe f8 0b 82 	ld.w	r8,pc[2946]
8000300e:	91 09       	st.w	r8[0x0],r9
								//AMBE-data and PCM-data is not the same. AMBE is compressed data,
								//if there was a missing portion, a clear voice is difficult to extract the data.
								//It must ensure that all the data received AMBE.
								
								//注意！！！考虑是否需要把剩余的空间置0。
								memset((AMBE_payload_ptr+ (RxAMBE_IsFillingNext8 +1)), 0x00, (512-(RxAMBE_IsFillingNext8 + 1)));
80003010:	fe f6 0b 98 	ld.w	r6,pc[2968]
80003014:	6c 08       	ld.w	r8,r6[0x0]
80003016:	f0 0a 11 ff 	rsub	r10,r8,-1
8000301a:	fe f7 0b 6a 	ld.w	r7,pc[2922]
8000301e:	2f f8       	sub	r8,-1
80003020:	6e 0c       	ld.w	r12,r7[0x0]
80003022:	f4 ca fe 00 	sub	r10,r10,-512
80003026:	30 0b       	mov	r11,0
80003028:	10 0c       	add	r12,r8
8000302a:	f0 1f 02 e1 	mcall	80003bac <phy_rx_func+0xee0>
								
								RxAMBE_IsFillingNext8 = 0;
8000302e:	30 08       	mov	r8,0
80003030:	8d 08       	st.w	r6[0x0],r8
								payload_rx(AMBE_payload_ptr);
80003032:	6e 0c       	ld.w	r12,r7[0x0]
80003034:	f0 1f 02 df 	mcall	80003bb0 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003038:	fe f8 0b 44 	ld.w	r8,pc[2884]
8000303c:	70 0c       	ld.w	r12,r8[0x0]
8000303e:	f0 1f 02 ca 	mcall	80003b64 <phy_rx_func+0xe98>
80003042:	8f 0c       	st.w	r7[0x0],r12
80003044:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								//logFromISR("\n\r QQ1 \n\r");
								
							}
							else//error voice
							{
								m_RxBurstType = VOICE_WATING;
80003048:	30 09       	mov	r9,0
8000304a:	fe f8 0b 42 	ld.w	r8,pc[2882]
8000304e:	91 09       	st.w	r8[0x0],r9
80003050:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;//WAITINGABAB.
					
		
					case Vocoder_Bit_Stream_Parameter://0x12
							
							if ((RxBytesWaiting -= 4) <= 0) break;
80003054:	20 48       	sub	r8,4
80003056:	fe f9 0b 3a 	ld.w	r9,pc[2874]
8000305a:	93 08       	st.w	r9[0x0],r8
8000305c:	58 08       	cp.w	r8,0
8000305e:	e0 80 05 74 	breq	80003b46 <phy_rx_func+0xe7a>
					
							//Vocoder Bits Stream Parameter
							VF_SN = (payload_rx_channel->byte[7] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
80003062:	ef 3c 00 0f 	ld.ub	r12,r7[15]
80003066:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
8000306a:	fe f8 0b 4a 	ld.w	r8,pc[2890]
8000306e:	b0 8c       	st.b	r8[0x0],r12
							
							VBSP_data[0] = payload_rx_channel->word[2];
80003070:	8e 69       	ld.sh	r9,r7[0xc]
80003072:	fe f8 0b 46 	ld.w	r8,pc[2886]
80003076:	b0 09       	st.h	r8[0x0],r9
							VBSP_data[1] = payload_rx_channel->word[3];
80003078:	8e 79       	ld.sh	r9,r7[0xe]
8000307a:	b0 19       	st.h	r8[0x2],r9
							
							m_RxBurstType = CalculateBurst(VF_SN);
8000307c:	f0 1f 02 d0 	mcall	80003bbc <phy_rx_func+0xef0>
80003080:	fe f8 0b 0c 	ld.w	r8,pc[2828]
80003084:	91 0c       	st.w	r8[0x0],r12
							
							RxMediaState = READING_AMBE_MEDIA;//Jump
80003086:	30 49       	mov	r9,4
80003088:	fe f8 0b 00 	ld.w	r8,pc[2816]
8000308c:	91 09       	st.w	r8[0x0],r9
8000308e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							
					//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
					// or discard it to reduce payload size.	
					//This shouldn't happen, but must check.	
					case Soft_Decision_Value://0x13
						m_RxBurstType = VOICE_WATING;
80003092:	30 09       	mov	r9,0
80003094:	fe f8 0a f8 	ld.w	r8,pc[2808]
80003098:	91 09       	st.w	r8[0x0],r9
8000309a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
					case Radio_Internal_Parameter://0x7F
							
							//logFromISR("\n\r Item_Length:%d\n\r", Item_Length);
							
							if ((RxBytesWaiting -= 4) <= 0) break;
8000309e:	20 48       	sub	r8,4
800030a0:	fe f9 0a f0 	ld.w	r9,pc[2800]
800030a4:	93 08       	st.w	r9[0x0],r8
800030a6:	58 08       	cp.w	r8,0
800030a8:	e0 80 05 4f 	breq	80003b46 <phy_rx_func+0xe7a>
							//Radio Internal Parameter
							Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[3];
800030ac:	fe f8 0b 14 	ld.w	r8,pc[2836]
800030b0:	70 09       	ld.w	r9,r8[0x0]
800030b2:	8e 7b       	ld.sh	r11,r7[0xe]
800030b4:	fe fa 0b 10 	ld.w	r10,pc[2832]
800030b8:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
							RxData_IsFillingNext16 += 1; 
800030bc:	2f f9       	sub	r9,-1
800030be:	91 09       	st.w	r8[0x0],r9
							Item_Length -= 2 ;
800030c0:	fe f8 0a e4 	ld.w	r8,pc[2788]
800030c4:	70 09       	ld.w	r9,r8[0x0]
800030c6:	20 29       	sub	r9,2
800030c8:	91 09       	st.w	r8[0x0],r9
							//....................................................
							m_RxBurstType = RADIOINTERNAL;
800030ca:	30 29       	mov	r9,2
800030cc:	fe f8 0a c0 	ld.w	r8,pc[2752]
800030d0:	91 09       	st.w	r8[0x0],r9

							RxMediaState = READING_AMBE_AUX;//Jump
800030d2:	30 39       	mov	r9,3
800030d4:	fe f8 0a b4 	ld.w	r8,pc[2740]
800030d8:	91 09       	st.w	r8[0x0],r9
800030da:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									
					default://0x03,0x04
						
						//((Item_ID == 0x04) || (Item_ID == 0x03) )//Unknown type data directly back hair
							//break;
							m_RxBurstType = UNSUREDATA;
800030de:	30 3a       	mov	r10,3
800030e0:	fe f9 0a ac 	ld.w	r9,pc[2732]
800030e4:	93 0a       	st.w	r9[0x0],r10
							AMBE_HT[0] = payload_rx_channel->dword[0];
800030e6:	6e 2a       	ld.w	r10,r7[0x8]
800030e8:	fe f9 0a e0 	ld.w	r9,pc[2784]
800030ec:	93 0a       	st.w	r9[0x0],r10
							AMBE_HT[1] = payload_rx_channel->dword[1];
800030ee:	6e 3a       	ld.w	r10,r7[0xc]
800030f0:	93 1a       	st.w	r9[0x4],r10
							
							if (RxBytesWaiting == 0x00000014)
800030f2:	59 48       	cp.w	r8,20
800030f4:	c0 61       	brne	80003100 <phy_rx_func+0x434>
							{
								RxBytesWaiting = 0x18;//24 Reassigned
800030f6:	31 89       	mov	r9,24
800030f8:	fe f8 0a 98 	ld.w	r8,pc[2712]
800030fc:	91 09       	st.w	r8[0x0],r9
800030fe:	c0 a8       	rjmp	80003112 <phy_rx_func+0x446>
								//_flag =0;
								
							}
							if (RxBytesWaiting == 0x00000010)
80003100:	fe f8 0a 90 	ld.w	r8,pc[2704]
80003104:	70 08       	ld.w	r8,r8[0x0]
80003106:	59 08       	cp.w	r8,16
80003108:	c0 51       	brne	80003112 <phy_rx_func+0x446>
							{
								RxBytesWaiting = 0x10;//16 Reassigned
8000310a:	31 09       	mov	r9,16
8000310c:	fe f8 0a 84 	ld.w	r8,pc[2692]
80003110:	91 09       	st.w	r8[0x0],r9
								//_flag =1;
							}
					
							RxMediaState = READING_AMBE_MEDIA;//Jump
80003112:	30 49       	mov	r9,4
80003114:	fe f8 0a 74 	ld.w	r8,pc[2676]
80003118:	91 09       	st.w	r8[0x0],r9
8000311a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
//#if 0
			else//PCM-media-data
			{	
				//logFromISR("\n\r RX:%x \n\r", payload_rx_channel->dword[0]);
				//SPEAKER_DATA or  //MIC_DATA
				if (((payload_rx_channel->dword[0] & 0x0000F000 ) != SPEAKER_DATA ) 
8000311e:	e0 49 10 00 	cp.w	r9,4096
80003122:	5f 1a       	srne	r10
80003124:	e0 49 20 00 	cp.w	r9,8192
80003128:	5f 19       	srne	r9
8000312a:	f5 e9 00 09 	and	r9,r10,r9
8000312e:	e0 81 05 0c 	brne	80003b46 <phy_rx_func+0xe7a>
					&& ((payload_rx_channel->dword[0] & 0x0000F000 ) != MIC_DATA ))break;
				
				AMBE_tx_flag = 0;
80003132:	fe fa 0a 9a 	ld.w	r10,pc[2714]
80003136:	b4 89       	st.b	r10[0x0],r9
				AMBE_rx_flag = 0;
80003138:	fe fa 0a 98 	ld.w	r10,pc[2712]
8000313c:	b4 89       	st.b	r10[0x0],r9
				
				Item_ID = 0;//To make sure your save PCM data.
8000313e:	fe fa 0a 62 	ld.w	r10,pc[2658]
80003142:	b4 89       	st.b	r10[0x0],r9
			
				if (NULL== payload_ptr){
80003144:	fe f9 0a 3c 	ld.w	r9,pc[2620]
80003148:	72 09       	ld.w	r9,r9[0x0]
8000314a:	58 09       	cp.w	r9,0
8000314c:	c0 71       	brne	8000315a <phy_rx_func+0x48e>
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//测试是否有这种情况出现
8000314e:	fe fc 0a 4a 	ld.w	r12,pc[2634]
80003152:	f0 1f 02 93 	mcall	80003b9c <phy_rx_func+0xed0>
80003156:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
8000315a:	6e 2a       	ld.w	r10,r7[0x8]
8000315c:	e2 1a 0f 00 	andl	r10,0xf00,COH
80003160:	58 1a       	cp.w	r10,1
80003162:	e0 8b 00 4d 	brhi	800031fc <phy_rx_func+0x530>
				
				if ((payload_rx_channel->dword[0]  & 0x00000F00) <= 1){  //Flag type must process Array Descriptor.
				//The first word of the media access payload must be the Array descriptor length. And the
				//unit of the length is in word (16-bit). The length field itself does not count into the length.
				//When there is no array descriptor, the length must be set to zero.[9.1.4.1]
					if ((RxBytesWaiting -= 4) <= 0) break;          //Nothing beyond this Phy buffer. Keep looking for Header
80003166:	20 48       	sub	r8,4
80003168:	fe f9 0a 28 	ld.w	r9,pc[2600]
8000316c:	93 08       	st.w	r9[0x0],r8
8000316e:	58 08       	cp.w	r8,0
80003170:	e0 80 04 eb 	breq	80003b46 <phy_rx_func+0xe7a>
					ArrayDiscLength = payload_rx_channel->word[2];
80003174:	8e 68       	ld.sh	r8,r7[0xc]
80003176:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
8000317a:	fe f9 0a 5a 	ld.w	r9,pc[2650]
8000317e:	93 0a       	st.w	r9[0x0],r10
					switch (ArrayDiscLength){
80003180:	30 09       	mov	r9,0
80003182:	f2 08 19 00 	cp.h	r8,r9
80003186:	c0 70       	breq	80003194 <phy_rx_func+0x4c8>
80003188:	30 19       	mov	r9,1
8000318a:	f2 08 19 00 	cp.h	r8,r9
8000318e:	e0 81 04 dc 	brne	80003b46 <phy_rx_func+0xe7a>
80003192:	c2 68       	rjmp	800031de <phy_rx_func+0x512>
						case 0:          //The usual case. Remaining word in Phy buffer is Audio.
								
							payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
80003194:	fe f8 0a 44 	ld.w	r8,pc[2628]
80003198:	70 0a       	ld.w	r10,r8[0x0]
8000319a:	fe f9 09 e6 	ld.w	r9,pc[2534]
8000319e:	72 09       	ld.w	r9,r9[0x0]
800031a0:	8e 7b       	ld.sh	r11,r7[0xe]
800031a2:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
							RxMedia_IsFillingNext16 += 1;
800031a6:	70 09       	ld.w	r9,r8[0x0]
800031a8:	2f f9       	sub	r9,-1
800031aa:	91 09       	st.w	r8[0x0],r9
							if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800031ac:	e0 49 00 ff 	cp.w	r9,255
800031b0:	e0 88 00 11 	brls	800031d2 <phy_rx_func+0x506>
							{
								RxMedia_IsFillingNext16 = 0;	
800031b4:	30 09       	mov	r9,0
800031b6:	91 09       	st.w	r8[0x0],r9
								payload_rx(payload_ptr);	
800031b8:	fe f7 09 c8 	ld.w	r7,pc[2504]
800031bc:	6e 0c       	ld.w	r12,r7[0x0]
800031be:	f0 1f 02 7d 	mcall	80003bb0 <phy_rx_func+0xee4>
								payload_ptr = get_payload_idle_isr();
800031c2:	fe f8 09 ba 	ld.w	r8,pc[2490]
800031c6:	70 0c       	ld.w	r12,r8[0x0]
800031c8:	f0 1f 02 67 	mcall	80003b64 <phy_rx_func+0xe98>
800031cc:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == payload_ptr){
800031ce:	e0 80 04 bc 	breq	80003b46 <phy_rx_func+0xe7a>
									break;
								}				
							}
							RxMediaState = READINGMEDIA;
800031d2:	30 29       	mov	r9,2
800031d4:	fe f8 09 b4 	ld.w	r8,pc[2484]
800031d8:	91 09       	st.w	r8[0x0],r9
800031da:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
800031de:	8e 79       	ld.sh	r9,r7[0xe]
800031e0:	30 38       	mov	r8,3
800031e2:	f0 09 19 00 	cp.h	r9,r8
800031e6:	c0 51       	brne	800031f0 <phy_rx_func+0x524>
				
						case 1: //The next usual case.
								//In general case, add code to process single word Array descriptor.
								if (payload_rx_channel->word[3] == 0x0003)//Stream Terminator
								{
									Terminator_Flag = 1;
800031e8:	30 19       	mov	r9,1
800031ea:	fe f8 09 f2 	ld.w	r8,pc[2546]
800031ee:	b0 89       	st.b	r8[0x0],r9
								else
								{
									//Terminator_Flag = 0;
								}
								
								RxMediaState = READINGMEDIA;
800031f0:	30 29       	mov	r9,2
800031f2:	fe f8 09 96 	ld.w	r8,pc[2454]
800031f6:	91 09       	st.w	r8[0x0],r9
800031f8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
				break;
			}
		
				//Code gets here on Middle or last Fragment. No Array descriptor.
				if (RxBytesWaiting < 2) break;//This shouldn't happen, but must check.
800031fc:	58 18       	cp.w	r8,1
800031fe:	e0 88 04 a4 	brls	80003b46 <phy_rx_func+0xe7a>
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->dword[1] & 0x0000FFFF;
80003202:	fe f8 09 d6 	ld.w	r8,pc[2518]
80003206:	70 0a       	ld.w	r10,r8[0x0]
80003208:	6e 3b       	ld.w	r11,r7[0xc]
8000320a:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
8000320e:	70 09       	ld.w	r9,r8[0x0]
80003210:	2f f9       	sub	r9,-1
80003212:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003214:	e0 49 00 ff 	cp.w	r9,255
80003218:	e0 88 00 11 	brls	8000323a <phy_rx_func+0x56e>
				{
					RxMedia_IsFillingNext16 = 0;
8000321c:	30 09       	mov	r9,0
8000321e:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003220:	fe f7 09 60 	ld.w	r7,pc[2400]
80003224:	6e 0c       	ld.w	r12,r7[0x0]
80003226:	f0 1f 02 63 	mcall	80003bb0 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
8000322a:	fe f8 09 52 	ld.w	r8,pc[2386]
8000322e:	70 0c       	ld.w	r12,r8[0x0]
80003230:	f0 1f 02 4d 	mcall	80003b64 <phy_rx_func+0xe98>
80003234:	8f 0c       	st.w	r7[0x0],r12
					if(NULL == payload_ptr)
80003236:	e0 80 04 88 	breq	80003b46 <phy_rx_func+0xe7a>
					{
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0) break;  //This shouldn't happen, but must check;
8000323a:	fe f9 09 56 	ld.w	r9,pc[2390]
8000323e:	72 08       	ld.w	r8,r9[0x0]
80003240:	20 28       	sub	r8,2
80003242:	93 08       	st.w	r9[0x0],r8
80003244:	e0 80 04 81 	breq	80003b46 <phy_rx_func+0xe7a>
				RxMediaState = READINGMEDIA;
80003248:	30 29       	mov	r9,2
8000324a:	fe f8 09 3e 	ld.w	r8,pc[2366]
8000324e:	91 09       	st.w	r8[0x0],r9
80003250:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
		case READINGMEDIA:
				
			/***PCM-media-data ****/
			{
				
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[0];
80003254:	fe f8 09 84 	ld.w	r8,pc[2436]
80003258:	70 0a       	ld.w	r10,r8[0x0]
8000325a:	fe f9 09 26 	ld.w	r9,pc[2342]
8000325e:	72 09       	ld.w	r9,r9[0x0]
80003260:	8e 4b       	ld.sh	r11,r7[0x8]
80003262:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;	
80003266:	70 09       	ld.w	r9,r8[0x0]
80003268:	2f f9       	sub	r9,-1
8000326a:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
8000326c:	e0 49 00 ff 	cp.w	r9,255
80003270:	e0 88 00 16 	brls	8000329c <phy_rx_func+0x5d0>
				{
					RxMedia_IsFillingNext16 = 0;
80003274:	30 09       	mov	r9,0
80003276:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003278:	fe f6 09 08 	ld.w	r6,pc[2312]
8000327c:	6c 0c       	ld.w	r12,r6[0x0]
8000327e:	f0 1f 02 4d 	mcall	80003bb0 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
80003282:	fe f8 08 fa 	ld.w	r8,pc[2298]
80003286:	70 0c       	ld.w	r12,r8[0x0]
80003288:	f0 1f 02 37 	mcall	80003b64 <phy_rx_func+0xe98>
8000328c:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
8000328e:	c0 71       	brne	8000329c <phy_rx_func+0x5d0>
					{
						RxMediaState = WAITINGABAB;
80003290:	30 09       	mov	r9,0
80003292:	fe f8 08 f6 	ld.w	r8,pc[2294]
80003296:	91 09       	st.w	r8[0x0],r9
80003298:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0)
8000329c:	fe f9 08 f4 	ld.w	r9,pc[2292]
800032a0:	72 08       	ld.w	r8,r9[0x0]
800032a2:	20 28       	sub	r8,2
800032a4:	93 08       	st.w	r9[0x0],r8
800032a6:	c0 71       	brne	800032b4 <phy_rx_func+0x5e8>
				{
					RxMediaState = WAITINGABAB;
800032a8:	30 09       	mov	r9,0
800032aa:	fe f8 08 de 	ld.w	r8,pc[2270]
800032ae:	91 09       	st.w	r8[0x0],r9
800032b0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[1];
800032b4:	fe f8 09 24 	ld.w	r8,pc[2340]
800032b8:	70 0a       	ld.w	r10,r8[0x0]
800032ba:	fe f9 08 c6 	ld.w	r9,pc[2246]
800032be:	72 09       	ld.w	r9,r9[0x0]
800032c0:	8e 5b       	ld.sh	r11,r7[0xa]
800032c2:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
800032c6:	70 09       	ld.w	r9,r8[0x0]
800032c8:	2f f9       	sub	r9,-1
800032ca:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800032cc:	e0 49 00 ff 	cp.w	r9,255
800032d0:	e0 88 00 16 	brls	800032fc <phy_rx_func+0x630>
				{
					RxMedia_IsFillingNext16 = 0;
800032d4:	30 09       	mov	r9,0
800032d6:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
800032d8:	fe f6 08 a8 	ld.w	r6,pc[2216]
800032dc:	6c 0c       	ld.w	r12,r6[0x0]
800032de:	f0 1f 02 35 	mcall	80003bb0 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
800032e2:	fe f8 08 9a 	ld.w	r8,pc[2202]
800032e6:	70 0c       	ld.w	r12,r8[0x0]
800032e8:	f0 1f 02 1f 	mcall	80003b64 <phy_rx_func+0xe98>
800032ec:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
800032ee:	c0 71       	brne	800032fc <phy_rx_func+0x630>
					{
						RxMediaState = WAITINGABAB;
800032f0:	30 09       	mov	r9,0
800032f2:	fe f8 08 96 	ld.w	r8,pc[2198]
800032f6:	91 09       	st.w	r8[0x0],r9
800032f8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
800032fc:	fe f9 08 94 	ld.w	r9,pc[2196]
80003300:	72 08       	ld.w	r8,r9[0x0]
80003302:	20 28       	sub	r8,2
80003304:	93 08       	st.w	r9[0x0],r8
80003306:	c0 71       	brne	80003314 <phy_rx_func+0x648>
					RxMediaState = WAITINGABAB;
80003308:	30 09       	mov	r9,0
8000330a:	fe f8 08 7e 	ld.w	r8,pc[2174]
8000330e:	91 09       	st.w	r8[0x0],r9
80003310:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}

				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[2];
80003314:	fe f8 08 c4 	ld.w	r8,pc[2244]
80003318:	70 0a       	ld.w	r10,r8[0x0]
8000331a:	fe f9 08 66 	ld.w	r9,pc[2150]
8000331e:	72 09       	ld.w	r9,r9[0x0]
80003320:	8e 6b       	ld.sh	r11,r7[0xc]
80003322:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80003326:	70 09       	ld.w	r9,r8[0x0]
80003328:	2f f9       	sub	r9,-1
8000332a:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
8000332c:	e0 49 00 ff 	cp.w	r9,255
80003330:	e0 88 00 16 	brls	8000335c <phy_rx_func+0x690>
				{
					RxMedia_IsFillingNext16 = 0;
80003334:	30 09       	mov	r9,0
80003336:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003338:	fe f6 08 48 	ld.w	r6,pc[2120]
8000333c:	6c 0c       	ld.w	r12,r6[0x0]
8000333e:	f0 1f 02 1d 	mcall	80003bb0 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
80003342:	fe f8 08 3a 	ld.w	r8,pc[2106]
80003346:	70 0c       	ld.w	r12,r8[0x0]
80003348:	f0 1f 02 07 	mcall	80003b64 <phy_rx_func+0xe98>
8000334c:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
8000334e:	c0 71       	brne	8000335c <phy_rx_func+0x690>
					{
						RxMediaState = WAITINGABAB;
80003350:	30 09       	mov	r9,0
80003352:	fe f8 08 36 	ld.w	r8,pc[2102]
80003356:	91 09       	st.w	r8[0x0],r9
80003358:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
8000335c:	fe f9 08 34 	ld.w	r9,pc[2100]
80003360:	72 08       	ld.w	r8,r9[0x0]
80003362:	20 28       	sub	r8,2
80003364:	93 08       	st.w	r9[0x0],r8
80003366:	c0 71       	brne	80003374 <phy_rx_func+0x6a8>
					RxMediaState = WAITINGABAB;
80003368:	30 09       	mov	r9,0
8000336a:	fe f8 08 1e 	ld.w	r8,pc[2078]
8000336e:	91 09       	st.w	r8[0x0],r9
80003370:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
80003374:	fe f8 08 64 	ld.w	r8,pc[2148]
80003378:	70 0a       	ld.w	r10,r8[0x0]
8000337a:	fe f9 08 06 	ld.w	r9,pc[2054]
8000337e:	72 09       	ld.w	r9,r9[0x0]
80003380:	8e 7b       	ld.sh	r11,r7[0xe]
80003382:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80003386:	70 09       	ld.w	r9,r8[0x0]
80003388:	2f f9       	sub	r9,-1
8000338a:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
8000338c:	e0 49 00 ff 	cp.w	r9,255
80003390:	e0 88 00 16 	brls	800033bc <phy_rx_func+0x6f0>
				{
					RxMedia_IsFillingNext16 = 0;
80003394:	30 09       	mov	r9,0
80003396:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003398:	fe f7 07 e8 	ld.w	r7,pc[2024]
8000339c:	6e 0c       	ld.w	r12,r7[0x0]
8000339e:	f0 1f 02 05 	mcall	80003bb0 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
800033a2:	fe f8 07 da 	ld.w	r8,pc[2010]
800033a6:	70 0c       	ld.w	r12,r8[0x0]
800033a8:	f0 1f 01 ef 	mcall	80003b64 <phy_rx_func+0xe98>
800033ac:	8f 0c       	st.w	r7[0x0],r12
					if(NULL == payload_ptr)
800033ae:	c0 71       	brne	800033bc <phy_rx_func+0x6f0>
					{
						RxMediaState = WAITINGABAB;
800033b0:	30 09       	mov	r9,0
800033b2:	fe f8 07 d6 	ld.w	r8,pc[2006]
800033b6:	91 09       	st.w	r8[0x0],r9
800033b8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
800033bc:	fe f9 07 d4 	ld.w	r9,pc[2004]
800033c0:	72 08       	ld.w	r8,r9[0x0]
800033c2:	20 28       	sub	r8,2
800033c4:	93 08       	st.w	r9[0x0],r8
800033c6:	e0 81 03 c0 	brne	80003b46 <phy_rx_func+0xe7a>
					RxMediaState = WAITINGABAB;
800033ca:	30 09       	mov	r9,0
800033cc:	fe f8 07 bc 	ld.w	r8,pc[1980]
800033d0:	91 09       	st.w	r8[0x0],r9
800033d2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

		case READING_AMBE_MEDIA:
		
			/****AMBE-media-data ****/
		
					if ((Item_ID == Vocoder_Bit_Stream_Parameter))//PAYLOAD_DATA_ENH (0x0c))
800033d6:	fe f8 07 ca 	ld.w	r8,pc[1994]
800033da:	11 89       	ld.ub	r9,r8[0x0]
800033dc:	31 28       	mov	r8,18
800033de:	f0 09 18 00 	cp.b	r9,r8
800033e2:	e0 81 01 4c 	brne	8000367a <phy_rx_func+0x9ae>
					{
						Item_ID = payload_rx_channel->byte[1];
800033e6:	ef 39 00 09 	ld.ub	r9,r7[9]
800033ea:	fe f8 07 b6 	ld.w	r8,pc[1974]
800033ee:	b0 89       	st.b	r8[0x0],r9
						if (Item_ID == Post_Voice_Encoder_Data)//发送方的压缩类型数据
800033f0:	11 89       	ld.ub	r9,r8[0x0]
800033f2:	3f 28       	mov	r8,-14
800033f4:	f0 09 18 00 	cp.b	r9,r8
800033f8:	e0 81 01 3b 	brne	8000366e <phy_rx_func+0x9a2>
						{
							AMBE_tx_flag = 1;
800033fc:	30 19       	mov	r9,1
800033fe:	fe f8 07 ce 	ld.w	r8,pc[1998]
80003402:	b0 89       	st.b	r8[0x0],r9
							
							RxBytesWaiting = ((payload_rx_channel->dword[0] & 0x7F000000) >>24);//Test calculations are correct; 8
80003404:	6e 29       	ld.w	r9,r7[0x8]
80003406:	f3 d9 c3 07 	bfextu	r9,r9,0x18,0x7
8000340a:	fe f8 07 86 	ld.w	r8,pc[1926]
8000340e:	91 09       	st.w	r8[0x0],r9
							
							//For looping back to Radio
							AMBEBurst_rawdata[0] = payload_rx_channel->word[1];
80003410:	8e 59       	ld.sh	r9,r7[0xa]
80003412:	fe f8 07 ce 	ld.w	r8,pc[1998]
80003416:	b0 09       	st.h	r8[0x0],r9
							AMBEBurst_rawdata[1] = payload_rx_channel->word[2];
80003418:	8e 69       	ld.sh	r9,r7[0xc]
8000341a:	b0 19       	st.h	r8[0x2],r9
							AMBEBurst_rawdata[2] = payload_rx_channel->word[3];
8000341c:	8e 79       	ld.sh	r9,r7[0xe]
8000341e:	b0 29       	st.h	r8[0x4],r9
							
							//To be tested. Also locally stored RAW-AMBER-DATA
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//1
80003420:	fe f8 07 88 	ld.w	r8,pc[1928]
80003424:	fe f9 07 60 	ld.w	r9,pc[1888]
80003428:	72 0a       	ld.w	r10,r9[0x0]
8000342a:	70 09       	ld.w	r9,r8[0x0]
8000342c:	ef 3b 00 0a 	ld.ub	r11,r7[10]
80003430:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003434:	70 09       	ld.w	r9,r8[0x0]
80003436:	2f f9       	sub	r9,-1
80003438:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000343a:	e0 49 01 ff 	cp.w	r9,511
8000343e:	e0 88 00 16 	brls	8000346a <phy_rx_func+0x79e>
							{
								RxAMBE_IsFillingNext8 = 0;
80003442:	30 09       	mov	r9,0
80003444:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003446:	fe f6 07 3e 	ld.w	r6,pc[1854]
8000344a:	6c 0c       	ld.w	r12,r6[0x0]
8000344c:	f0 1f 01 d9 	mcall	80003bb0 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003450:	fe f8 07 2c 	ld.w	r8,pc[1836]
80003454:	70 0c       	ld.w	r12,r8[0x0]
80003456:	f0 1f 01 c4 	mcall	80003b64 <phy_rx_func+0xe98>
8000345a:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
8000345c:	c0 71       	brne	8000346a <phy_rx_func+0x79e>
								{
									RxMediaState = WAITINGABAB;
8000345e:	30 09       	mov	r9,0
80003460:	fe f8 07 28 	ld.w	r8,pc[1832]
80003464:	91 09       	st.w	r8[0x0],r9
80003466:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
8000346a:	fe f9 07 26 	ld.w	r9,pc[1830]
8000346e:	72 08       	ld.w	r8,r9[0x0]
80003470:	20 18       	sub	r8,1
80003472:	93 08       	st.w	r9[0x0],r8
80003474:	c0 71       	brne	80003482 <phy_rx_func+0x7b6>
								RxMediaState = WAITINGABAB;
80003476:	30 09       	mov	r9,0
80003478:	fe f8 07 10 	ld.w	r8,pc[1808]
8000347c:	91 09       	st.w	r8[0x0],r9
8000347e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}			
							
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//2
80003482:	fe f8 07 26 	ld.w	r8,pc[1830]
80003486:	fe f9 06 fe 	ld.w	r9,pc[1790]
8000348a:	72 0a       	ld.w	r10,r9[0x0]
8000348c:	70 09       	ld.w	r9,r8[0x0]
8000348e:	ef 3b 00 0b 	ld.ub	r11,r7[11]
80003492:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003496:	70 09       	ld.w	r9,r8[0x0]
80003498:	2f f9       	sub	r9,-1
8000349a:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000349c:	e0 49 01 ff 	cp.w	r9,511
800034a0:	e0 88 00 16 	brls	800034cc <phy_rx_func+0x800>
							{
								RxAMBE_IsFillingNext8 = 0;
800034a4:	30 09       	mov	r9,0
800034a6:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
800034a8:	fe f6 06 dc 	ld.w	r6,pc[1756]
800034ac:	6c 0c       	ld.w	r12,r6[0x0]
800034ae:	f0 1f 01 c1 	mcall	80003bb0 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
800034b2:	fe f8 06 ca 	ld.w	r8,pc[1738]
800034b6:	70 0c       	ld.w	r12,r8[0x0]
800034b8:	f0 1f 01 ab 	mcall	80003b64 <phy_rx_func+0xe98>
800034bc:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
800034be:	c0 71       	brne	800034cc <phy_rx_func+0x800>
								{
									RxMediaState = WAITINGABAB;
800034c0:	30 09       	mov	r9,0
800034c2:	fe f8 06 c6 	ld.w	r8,pc[1734]
800034c6:	91 09       	st.w	r8[0x0],r9
800034c8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800034cc:	fe f9 06 c4 	ld.w	r9,pc[1732]
800034d0:	72 08       	ld.w	r8,r9[0x0]
800034d2:	20 18       	sub	r8,1
800034d4:	93 08       	st.w	r9[0x0],r8
800034d6:	c0 71       	brne	800034e4 <phy_rx_func+0x818>
								RxMediaState = WAITINGABAB;
800034d8:	30 09       	mov	r9,0
800034da:	fe f8 06 ae 	ld.w	r8,pc[1710]
800034de:	91 09       	st.w	r8[0x0],r9
800034e0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}		
						
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//3
800034e4:	fe f8 06 c4 	ld.w	r8,pc[1732]
800034e8:	fe f9 06 9c 	ld.w	r9,pc[1692]
800034ec:	72 0a       	ld.w	r10,r9[0x0]
800034ee:	70 09       	ld.w	r9,r8[0x0]
800034f0:	ef 3b 00 0c 	ld.ub	r11,r7[12]
800034f4:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
800034f8:	70 09       	ld.w	r9,r8[0x0]
800034fa:	2f f9       	sub	r9,-1
800034fc:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800034fe:	e0 49 01 ff 	cp.w	r9,511
80003502:	e0 88 00 16 	brls	8000352e <phy_rx_func+0x862>
							{
								RxAMBE_IsFillingNext8 = 0;
80003506:	30 09       	mov	r9,0
80003508:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
8000350a:	fe f6 06 7a 	ld.w	r6,pc[1658]
8000350e:	6c 0c       	ld.w	r12,r6[0x0]
80003510:	f0 1f 01 a8 	mcall	80003bb0 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003514:	fe f8 06 68 	ld.w	r8,pc[1640]
80003518:	70 0c       	ld.w	r12,r8[0x0]
8000351a:	f0 1f 01 93 	mcall	80003b64 <phy_rx_func+0xe98>
8000351e:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003520:	c0 71       	brne	8000352e <phy_rx_func+0x862>
								{
									RxMediaState = WAITINGABAB;
80003522:	30 09       	mov	r9,0
80003524:	fe f8 06 64 	ld.w	r8,pc[1636]
80003528:	91 09       	st.w	r8[0x0],r9
8000352a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
8000352e:	fe f9 06 62 	ld.w	r9,pc[1634]
80003532:	72 08       	ld.w	r8,r9[0x0]
80003534:	20 18       	sub	r8,1
80003536:	93 08       	st.w	r9[0x0],r8
80003538:	c0 71       	brne	80003546 <phy_rx_func+0x87a>
								RxMediaState = WAITINGABAB;
8000353a:	30 09       	mov	r9,0
8000353c:	fe f8 06 4c 	ld.w	r8,pc[1612]
80003540:	91 09       	st.w	r8[0x0],r9
80003542:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[5];//4
80003546:	fe f8 06 62 	ld.w	r8,pc[1634]
8000354a:	fe f9 06 3a 	ld.w	r9,pc[1594]
8000354e:	72 0a       	ld.w	r10,r9[0x0]
80003550:	70 09       	ld.w	r9,r8[0x0]
80003552:	ef 3b 00 0d 	ld.ub	r11,r7[13]
80003556:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
8000355a:	70 09       	ld.w	r9,r8[0x0]
8000355c:	2f f9       	sub	r9,-1
8000355e:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003560:	e0 49 01 ff 	cp.w	r9,511
80003564:	e0 88 00 16 	brls	80003590 <phy_rx_func+0x8c4>
							{
								RxAMBE_IsFillingNext8 = 0;
80003568:	30 09       	mov	r9,0
8000356a:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
8000356c:	fe f6 06 18 	ld.w	r6,pc[1560]
80003570:	6c 0c       	ld.w	r12,r6[0x0]
80003572:	f0 1f 01 90 	mcall	80003bb0 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003576:	fe f8 06 06 	ld.w	r8,pc[1542]
8000357a:	70 0c       	ld.w	r12,r8[0x0]
8000357c:	f0 1f 01 7a 	mcall	80003b64 <phy_rx_func+0xe98>
80003580:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003582:	c0 71       	brne	80003590 <phy_rx_func+0x8c4>
								{
									RxMediaState = WAITINGABAB;
80003584:	30 09       	mov	r9,0
80003586:	fe f8 06 02 	ld.w	r8,pc[1538]
8000358a:	91 09       	st.w	r8[0x0],r9
8000358c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003590:	fe f9 06 00 	ld.w	r9,pc[1536]
80003594:	72 08       	ld.w	r8,r9[0x0]
80003596:	20 18       	sub	r8,1
80003598:	93 08       	st.w	r9[0x0],r8
8000359a:	c0 71       	brne	800035a8 <phy_rx_func+0x8dc>
								RxMediaState = WAITINGABAB;
8000359c:	30 09       	mov	r9,0
8000359e:	fe f8 05 ea 	ld.w	r8,pc[1514]
800035a2:	91 09       	st.w	r8[0x0],r9
800035a4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//5
800035a8:	fe f8 06 00 	ld.w	r8,pc[1536]
800035ac:	fe f9 05 d8 	ld.w	r9,pc[1496]
800035b0:	72 0a       	ld.w	r10,r9[0x0]
800035b2:	70 09       	ld.w	r9,r8[0x0]
800035b4:	ef 3b 00 0e 	ld.ub	r11,r7[14]
800035b8:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
800035bc:	70 09       	ld.w	r9,r8[0x0]
800035be:	2f f9       	sub	r9,-1
800035c0:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800035c2:	e0 49 01 ff 	cp.w	r9,511
800035c6:	e0 88 00 16 	brls	800035f2 <phy_rx_func+0x926>
							{
								RxAMBE_IsFillingNext8 = 0;
800035ca:	30 09       	mov	r9,0
800035cc:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
800035ce:	fe f6 05 b6 	ld.w	r6,pc[1462]
800035d2:	6c 0c       	ld.w	r12,r6[0x0]
800035d4:	f0 1f 01 77 	mcall	80003bb0 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
800035d8:	fe f8 05 a4 	ld.w	r8,pc[1444]
800035dc:	70 0c       	ld.w	r12,r8[0x0]
800035de:	f0 1f 01 62 	mcall	80003b64 <phy_rx_func+0xe98>
800035e2:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
800035e4:	c0 71       	brne	800035f2 <phy_rx_func+0x926>
								{
									RxMediaState = WAITINGABAB;
800035e6:	30 09       	mov	r9,0
800035e8:	fe f8 05 a0 	ld.w	r8,pc[1440]
800035ec:	91 09       	st.w	r8[0x0],r9
800035ee:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800035f2:	fe f9 05 9e 	ld.w	r9,pc[1438]
800035f6:	72 08       	ld.w	r8,r9[0x0]
800035f8:	20 18       	sub	r8,1
800035fa:	93 08       	st.w	r9[0x0],r8
800035fc:	c0 71       	brne	8000360a <phy_rx_func+0x93e>
								RxMediaState = WAITINGABAB;
800035fe:	30 09       	mov	r9,0
80003600:	fe f8 05 88 	ld.w	r8,pc[1416]
80003604:	91 09       	st.w	r8[0x0],r9
80003606:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//6
8000360a:	fe f8 05 9e 	ld.w	r8,pc[1438]
8000360e:	fe f9 05 76 	ld.w	r9,pc[1398]
80003612:	72 0a       	ld.w	r10,r9[0x0]
80003614:	70 09       	ld.w	r9,r8[0x0]
80003616:	ef 3b 00 0f 	ld.ub	r11,r7[15]
8000361a:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
8000361e:	70 09       	ld.w	r9,r8[0x0]
80003620:	2f f9       	sub	r9,-1
80003622:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003624:	e0 49 01 ff 	cp.w	r9,511
80003628:	e0 88 00 16 	brls	80003654 <phy_rx_func+0x988>
							{
								RxAMBE_IsFillingNext8 = 0;
8000362c:	30 09       	mov	r9,0
8000362e:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003630:	fe f7 05 54 	ld.w	r7,pc[1364]
80003634:	6e 0c       	ld.w	r12,r7[0x0]
80003636:	f0 1f 01 5f 	mcall	80003bb0 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
8000363a:	fe f8 05 42 	ld.w	r8,pc[1346]
8000363e:	70 0c       	ld.w	r12,r8[0x0]
80003640:	f0 1f 01 49 	mcall	80003b64 <phy_rx_func+0xe98>
80003644:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003646:	c0 71       	brne	80003654 <phy_rx_func+0x988>
								{
									RxMediaState = WAITINGABAB;
80003648:	30 09       	mov	r9,0
8000364a:	fe f8 05 3e 	ld.w	r8,pc[1342]
8000364e:	91 09       	st.w	r8[0x0],r9
80003650:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003654:	fe f9 05 3c 	ld.w	r9,pc[1340]
80003658:	72 08       	ld.w	r8,r9[0x0]
8000365a:	20 18       	sub	r8,1
8000365c:	93 08       	st.w	r9[0x0],r8
8000365e:	e0 81 02 74 	brne	80003b46 <phy_rx_func+0xe7a>
								RxMediaState = WAITINGABAB;
80003662:	30 09       	mov	r9,0
80003664:	fe f8 05 24 	ld.w	r8,pc[1316]
80003668:	91 09       	st.w	r8[0x0],r9
8000366a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							//}
							
						}
						else//error
						{
							RxMediaState = WAITINGABAB;
8000366e:	30 09       	mov	r9,0
80003670:	fe f8 05 18 	ld.w	r8,pc[1304]
80003674:	91 09       	st.w	r8[0x0],r9
80003676:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
					}
					else if (Item_ID == Post_Voice_Encoder_Data)//(bit48~Pad-bits)
8000367a:	fe f8 05 26 	ld.w	r8,pc[1318]
8000367e:	11 89       	ld.ub	r9,r8[0x0]
80003680:	3f 28       	mov	r8,-14
80003682:	f0 09 18 00 	cp.b	r9,r8
80003686:	c4 31       	brne	8000370c <phy_rx_func+0xa40>
					{
					
						AMBEBurst_rawdata[3] = payload_rx_channel->word[0];//(bit48~Pad-bits)
80003688:	8e 49       	ld.sh	r9,r7[0x8]
8000368a:	fe f8 05 56 	ld.w	r8,pc[1366]
8000368e:	b0 39       	st.h	r8[0x6],r9
						//AMBE_Per_Burst_Flag = 1;
						
						//根据MOTO.bit文件数据分布，建议测试pad-bits的最后一个字节不保存。
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//7
80003690:	fe f8 05 18 	ld.w	r8,pc[1304]
80003694:	fe f9 04 f0 	ld.w	r9,pc[1264]
80003698:	72 0a       	ld.w	r10,r9[0x0]
8000369a:	70 09       	ld.w	r9,r8[0x0]
8000369c:	ef 3b 00 08 	ld.ub	r11,r7[8]
800036a0:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
800036a4:	70 09       	ld.w	r9,r8[0x0]
800036a6:	2f f9       	sub	r9,-1
800036a8:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800036aa:	e0 49 01 ff 	cp.w	r9,511
800036ae:	e0 88 00 16 	brls	800036da <phy_rx_func+0xa0e>
						{
							RxAMBE_IsFillingNext8 = 0;
800036b2:	30 09       	mov	r9,0
800036b4:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
800036b6:	fe f7 04 ce 	ld.w	r7,pc[1230]
800036ba:	6e 0c       	ld.w	r12,r7[0x0]
800036bc:	f0 1f 01 3d 	mcall	80003bb0 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
800036c0:	fe f8 04 bc 	ld.w	r8,pc[1212]
800036c4:	70 0c       	ld.w	r12,r8[0x0]
800036c6:	f0 1f 01 28 	mcall	80003b64 <phy_rx_func+0xe98>
800036ca:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
800036cc:	c0 71       	brne	800036da <phy_rx_func+0xa0e>
							{
								RxMediaState = WAITINGABAB;
800036ce:	30 09       	mov	r9,0
800036d0:	fe f8 04 b8 	ld.w	r8,pc[1208]
800036d4:	91 09       	st.w	r8[0x0],r9
800036d6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
800036da:	fe f9 04 b6 	ld.w	r9,pc[1206]
800036de:	72 08       	ld.w	r8,r9[0x0]
800036e0:	20 18       	sub	r8,1
800036e2:	93 08       	st.w	r9[0x0],r8
800036e4:	c0 71       	brne	800036f2 <phy_rx_func+0xa26>
							RxMediaState = WAITINGABAB;
800036e6:	30 09       	mov	r9,0
800036e8:	fe f8 04 a0 	ld.w	r8,pc[1184]
800036ec:	91 09       	st.w	r8[0x0],r9
800036ee:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
						if ((RxBytesWaiting -= 1) <= 0){//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
800036f2:	20 18       	sub	r8,1
800036f4:	fe f9 04 9c 	ld.w	r9,pc[1180]
800036f8:	93 08       	st.w	r9[0x0],r8
800036fa:	58 08       	cp.w	r8,0
800036fc:	e0 81 02 25 	brne	80003b46 <phy_rx_func+0xe7a>
							RxMediaState = WAITINGABAB;
80003700:	30 09       	mov	r9,0
80003702:	fe f8 04 86 	ld.w	r8,pc[1158]
80003706:	91 09       	st.w	r8[0x0],r9
80003708:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
								
					}
					else if (Item_ID == Pre_Voice_Decoder_Data)//bit16~bit63
8000370c:	fe f8 04 94 	ld.w	r8,pc[1172]
80003710:	11 89       	ld.ub	r9,r8[0x0]
80003712:	3f 38       	mov	r8,-13
80003714:	f0 09 18 00 	cp.b	r9,r8
80003718:	e0 81 01 0c 	brne	80003930 <phy_rx_func+0xc64>
					{
						//接收方的解压类型数据
						//For looping back to Radio
						AMBEBurst_rawdata[1] = payload_rx_channel->word[0];
8000371c:	8e 49       	ld.sh	r9,r7[0x8]
8000371e:	fe f8 04 c2 	ld.w	r8,pc[1218]
80003722:	b0 19       	st.h	r8[0x2],r9
						AMBEBurst_rawdata[2] = payload_rx_channel->word[1];
80003724:	8e 59       	ld.sh	r9,r7[0xa]
80003726:	b0 29       	st.h	r8[0x4],r9
						AMBEBurst_rawdata[3] = payload_rx_channel->word[2];
80003728:	8e 69       	ld.sh	r9,r7[0xc]
8000372a:	b0 39       	st.h	r8[0x6],r9
						//if((m_RxBurstType == VOICEBURST_A) && (VF_SN == 1))
						//logFromISR("\n\r Pre_rx:%X\n\r", payload_rx_channel->word[2]);
						
						//To be tested. Also locally stored RAW-AMBER-DATA
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//3
8000372c:	fe f8 04 7c 	ld.w	r8,pc[1148]
80003730:	fe f9 04 54 	ld.w	r9,pc[1108]
80003734:	72 0a       	ld.w	r10,r9[0x0]
80003736:	70 09       	ld.w	r9,r8[0x0]
80003738:	ef 3b 00 08 	ld.ub	r11,r7[8]
8000373c:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003740:	70 09       	ld.w	r9,r8[0x0]
80003742:	2f f9       	sub	r9,-1
80003744:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003746:	e0 49 01 ff 	cp.w	r9,511
8000374a:	e0 88 00 16 	brls	80003776 <phy_rx_func+0xaaa>
						{
							RxAMBE_IsFillingNext8 = 0;
8000374e:	30 09       	mov	r9,0
80003750:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003752:	fe f6 04 32 	ld.w	r6,pc[1074]
80003756:	6c 0c       	ld.w	r12,r6[0x0]
80003758:	f0 1f 01 16 	mcall	80003bb0 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
8000375c:	fe f8 04 20 	ld.w	r8,pc[1056]
80003760:	70 0c       	ld.w	r12,r8[0x0]
80003762:	f0 1f 01 01 	mcall	80003b64 <phy_rx_func+0xe98>
80003766:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003768:	c0 71       	brne	80003776 <phy_rx_func+0xaaa>
							{
								RxMediaState = WAITINGABAB;
8000376a:	30 09       	mov	r9,0
8000376c:	fe f8 04 1c 	ld.w	r8,pc[1052]
80003770:	91 09       	st.w	r8[0x0],r9
80003772:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003776:	fe f9 04 1a 	ld.w	r9,pc[1050]
8000377a:	72 08       	ld.w	r8,r9[0x0]
8000377c:	20 18       	sub	r8,1
8000377e:	93 08       	st.w	r9[0x0],r8
80003780:	c0 71       	brne	8000378e <phy_rx_func+0xac2>
							RxMediaState = WAITINGABAB;
80003782:	30 09       	mov	r9,0
80003784:	fe f8 04 04 	ld.w	r8,pc[1028]
80003788:	91 09       	st.w	r8[0x0],r9
8000378a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[1];//4
8000378e:	fe f8 04 1a 	ld.w	r8,pc[1050]
80003792:	fe f9 03 f2 	ld.w	r9,pc[1010]
80003796:	72 0a       	ld.w	r10,r9[0x0]
80003798:	70 09       	ld.w	r9,r8[0x0]
8000379a:	ef 3b 00 09 	ld.ub	r11,r7[9]
8000379e:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
800037a2:	70 09       	ld.w	r9,r8[0x0]
800037a4:	2f f9       	sub	r9,-1
800037a6:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800037a8:	e0 49 01 ff 	cp.w	r9,511
800037ac:	e0 88 00 16 	brls	800037d8 <phy_rx_func+0xb0c>
						{
							RxAMBE_IsFillingNext8 = 0;
800037b0:	30 09       	mov	r9,0
800037b2:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
800037b4:	fe f6 03 d0 	ld.w	r6,pc[976]
800037b8:	6c 0c       	ld.w	r12,r6[0x0]
800037ba:	f0 1f 00 fe 	mcall	80003bb0 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
800037be:	fe f8 03 be 	ld.w	r8,pc[958]
800037c2:	70 0c       	ld.w	r12,r8[0x0]
800037c4:	f0 1f 00 e8 	mcall	80003b64 <phy_rx_func+0xe98>
800037c8:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
800037ca:	c0 71       	brne	800037d8 <phy_rx_func+0xb0c>
							{
								RxMediaState = WAITINGABAB;
800037cc:	30 09       	mov	r9,0
800037ce:	fe f8 03 ba 	ld.w	r8,pc[954]
800037d2:	91 09       	st.w	r8[0x0],r9
800037d4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
800037d8:	fe f9 03 b8 	ld.w	r9,pc[952]
800037dc:	72 08       	ld.w	r8,r9[0x0]
800037de:	20 18       	sub	r8,1
800037e0:	93 08       	st.w	r9[0x0],r8
800037e2:	c0 71       	brne	800037f0 <phy_rx_func+0xb24>
							RxMediaState = WAITINGABAB;
800037e4:	30 09       	mov	r9,0
800037e6:	fe f8 03 a2 	ld.w	r8,pc[930]
800037ea:	91 09       	st.w	r8[0x0],r9
800037ec:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//5
800037f0:	fe f8 03 b8 	ld.w	r8,pc[952]
800037f4:	fe f9 03 90 	ld.w	r9,pc[912]
800037f8:	72 0a       	ld.w	r10,r9[0x0]
800037fa:	70 09       	ld.w	r9,r8[0x0]
800037fc:	ef 3b 00 0a 	ld.ub	r11,r7[10]
80003800:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003804:	70 09       	ld.w	r9,r8[0x0]
80003806:	2f f9       	sub	r9,-1
80003808:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000380a:	e0 49 01 ff 	cp.w	r9,511
8000380e:	e0 88 00 16 	brls	8000383a <phy_rx_func+0xb6e>
						{
							RxAMBE_IsFillingNext8 = 0;
80003812:	30 09       	mov	r9,0
80003814:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003816:	fe f6 03 6e 	ld.w	r6,pc[878]
8000381a:	6c 0c       	ld.w	r12,r6[0x0]
8000381c:	f0 1f 00 e5 	mcall	80003bb0 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003820:	fe f8 03 5c 	ld.w	r8,pc[860]
80003824:	70 0c       	ld.w	r12,r8[0x0]
80003826:	f0 1f 00 d0 	mcall	80003b64 <phy_rx_func+0xe98>
8000382a:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
8000382c:	c0 71       	brne	8000383a <phy_rx_func+0xb6e>
							{
								RxMediaState = WAITINGABAB;
8000382e:	30 09       	mov	r9,0
80003830:	fe f8 03 58 	ld.w	r8,pc[856]
80003834:	91 09       	st.w	r8[0x0],r9
80003836:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
8000383a:	fe f9 03 56 	ld.w	r9,pc[854]
8000383e:	72 08       	ld.w	r8,r9[0x0]
80003840:	20 18       	sub	r8,1
80003842:	93 08       	st.w	r9[0x0],r8
80003844:	c0 71       	brne	80003852 <phy_rx_func+0xb86>
							RxMediaState = WAITINGABAB;
80003846:	30 09       	mov	r9,0
80003848:	fe f8 03 40 	ld.w	r8,pc[832]
8000384c:	91 09       	st.w	r8[0x0],r9
8000384e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//6
80003852:	fe f8 03 56 	ld.w	r8,pc[854]
80003856:	fe f9 03 2e 	ld.w	r9,pc[814]
8000385a:	72 0a       	ld.w	r10,r9[0x0]
8000385c:	70 09       	ld.w	r9,r8[0x0]
8000385e:	ef 3b 00 0b 	ld.ub	r11,r7[11]
80003862:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003866:	70 09       	ld.w	r9,r8[0x0]
80003868:	2f f9       	sub	r9,-1
8000386a:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000386c:	e0 49 01 ff 	cp.w	r9,511
80003870:	e0 88 00 16 	brls	8000389c <phy_rx_func+0xbd0>
						{
							RxAMBE_IsFillingNext8 = 0;
80003874:	30 09       	mov	r9,0
80003876:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003878:	fe f6 03 0c 	ld.w	r6,pc[780]
8000387c:	6c 0c       	ld.w	r12,r6[0x0]
8000387e:	f0 1f 00 cd 	mcall	80003bb0 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003882:	fe f8 02 fa 	ld.w	r8,pc[762]
80003886:	70 0c       	ld.w	r12,r8[0x0]
80003888:	f0 1f 00 b7 	mcall	80003b64 <phy_rx_func+0xe98>
8000388c:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
8000388e:	c0 71       	brne	8000389c <phy_rx_func+0xbd0>
							{
								RxMediaState = WAITINGABAB;
80003890:	30 09       	mov	r9,0
80003892:	fe f8 02 f6 	ld.w	r8,pc[758]
80003896:	91 09       	st.w	r8[0x0],r9
80003898:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
8000389c:	fe f9 02 f4 	ld.w	r9,pc[756]
800038a0:	72 08       	ld.w	r8,r9[0x0]
800038a2:	20 18       	sub	r8,1
800038a4:	93 08       	st.w	r9[0x0],r8
800038a6:	c0 71       	brne	800038b4 <phy_rx_func+0xbe8>
							RxMediaState = WAITINGABAB;
800038a8:	30 09       	mov	r9,0
800038aa:	fe f8 02 de 	ld.w	r8,pc[734]
800038ae:	91 09       	st.w	r8[0x0],r9
800038b0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//7
800038b4:	fe f8 02 f4 	ld.w	r8,pc[756]
800038b8:	fe f9 02 cc 	ld.w	r9,pc[716]
800038bc:	72 0a       	ld.w	r10,r9[0x0]
800038be:	70 09       	ld.w	r9,r8[0x0]
800038c0:	ef 3b 00 0c 	ld.ub	r11,r7[12]
800038c4:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
800038c8:	70 09       	ld.w	r9,r8[0x0]
800038ca:	2f f9       	sub	r9,-1
800038cc:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800038ce:	e0 49 01 ff 	cp.w	r9,511
800038d2:	e0 88 00 16 	brls	800038fe <phy_rx_func+0xc32>
						{
							RxAMBE_IsFillingNext8 = 0;
800038d6:	30 09       	mov	r9,0
800038d8:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
800038da:	fe f7 02 aa 	ld.w	r7,pc[682]
800038de:	6e 0c       	ld.w	r12,r7[0x0]
800038e0:	f0 1f 00 b4 	mcall	80003bb0 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
800038e4:	fe f8 02 98 	ld.w	r8,pc[664]
800038e8:	70 0c       	ld.w	r12,r8[0x0]
800038ea:	f0 1f 00 9f 	mcall	80003b64 <phy_rx_func+0xe98>
800038ee:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
800038f0:	c0 71       	brne	800038fe <phy_rx_func+0xc32>
							{
								RxMediaState = WAITINGABAB;
800038f2:	30 09       	mov	r9,0
800038f4:	fe f8 02 94 	ld.w	r8,pc[660]
800038f8:	91 09       	st.w	r8[0x0],r9
800038fa:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
800038fe:	fe f9 02 92 	ld.w	r9,pc[658]
80003902:	72 08       	ld.w	r8,r9[0x0]
80003904:	20 18       	sub	r8,1
80003906:	93 08       	st.w	r9[0x0],r8
80003908:	c0 71       	brne	80003916 <phy_rx_func+0xc4a>
							RxMediaState = WAITINGABAB;
8000390a:	30 09       	mov	r9,0
8000390c:	fe f8 02 7c 	ld.w	r8,pc[636]
80003910:	91 09       	st.w	r8[0x0],r9
80003912:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
						if ((RxBytesWaiting -= 1) <= 0){
80003916:	20 18       	sub	r8,1
80003918:	fe f9 02 78 	ld.w	r9,pc[632]
8000391c:	93 08       	st.w	r9[0x0],r8
8000391e:	58 08       	cp.w	r8,0
80003920:	e0 81 01 13 	brne	80003b46 <phy_rx_func+0xe7a>
							
							//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
							//or discard it to reduce payload size.
							
							RxMediaState = WAITINGABAB;
80003924:	30 09       	mov	r9,0
80003926:	fe f8 02 62 	ld.w	r8,pc[610]
8000392a:	91 09       	st.w	r8[0x0],r9
8000392c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
					}
					else if ((Item_ID == 0x04)  ||  (Item_ID == 0x03))//Unknown type data directly back hair
80003930:	fe f8 02 70 	ld.w	r8,pc[624]
80003934:	11 89       	ld.ub	r9,r8[0x0]
80003936:	30 48       	mov	r8,4
80003938:	f0 09 18 00 	cp.b	r9,r8
8000393c:	c0 80       	breq	8000394c <phy_rx_func+0xc80>
8000393e:	fe f8 02 62 	ld.w	r8,pc[610]
80003942:	11 89       	ld.ub	r9,r8[0x0]
80003944:	30 38       	mov	r8,3
80003946:	f0 09 18 00 	cp.b	r9,r8
8000394a:	c1 41       	brne	80003972 <phy_rx_func+0xca6>
					{
						AMBE_HT[0] = payload_rx_channel->dword[0];
8000394c:	6e 29       	ld.w	r9,r7[0x8]
8000394e:	fe f8 02 7a 	ld.w	r8,pc[634]
80003952:	91 09       	st.w	r8[0x0],r9
						AMBE_HT[1] = payload_rx_channel->dword[1];				
80003954:	6e 39       	ld.w	r9,r7[0xc]
80003956:	91 19       	st.w	r8[0x4],r9
						
						if ((RxBytesWaiting -= 8) <= 0)//Consider two cases 0xABCDC014 and 0xABCDC010
80003958:	fe f9 02 38 	ld.w	r9,pc[568]
8000395c:	72 08       	ld.w	r8,r9[0x0]
8000395e:	20 88       	sub	r8,8
80003960:	93 08       	st.w	r9[0x0],r8
80003962:	e0 81 00 f2 	brne	80003b46 <phy_rx_func+0xe7a>
						{
					
							RxBytesWaiting = 0;
80003966:	93 08       	st.w	r9[0x0],r8
							RxMediaState = WAITINGABAB;
80003968:	fe f9 02 20 	ld.w	r9,pc[544]
8000396c:	93 08       	st.w	r9[0x0],r8
8000396e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
						}
						break;

					}
					else if (Item_ID == Soft_Decision_Value)
80003972:	fe f8 02 2e 	ld.w	r8,pc[558]
80003976:	11 89       	ld.ub	r9,r8[0x0]
80003978:	31 38       	mov	r8,19
8000397a:	f0 09 18 00 	cp.b	r9,r8
8000397e:	e0 81 00 9c 	brne	80003ab6 <phy_rx_func+0xdea>
					{							
						if (SDV_Index == 12)
80003982:	fe f8 02 62 	ld.w	r8,pc[610]
80003986:	11 88       	ld.ub	r8,r8[0x0]
80003988:	30 c9       	mov	r9,12
8000398a:	f2 08 18 00 	cp.b	r8,r9
8000398e:	e0 81 00 7b 	brne	80003a84 <phy_rx_func+0xdb8>
						{
							Soft_Decision_Data[SDV_Index]= payload_rx_channel->word[0];
80003992:	8e 49       	ld.sh	r9,r7[0x8]
80003994:	fe f8 02 54 	ld.w	r8,pc[596]
80003998:	f1 59 00 18 	st.h	r8[24],r9
							
							SDV_Index = 0;
8000399c:	30 09       	mov	r9,0
8000399e:	fe f8 02 46 	ld.w	r8,pc[582]
800039a2:	b0 89       	st.b	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
800039a4:	ef 39 00 0d 	ld.ub	r9,r7[13]
800039a8:	3f 38       	mov	r8,-13
800039aa:	f0 09 18 00 	cp.b	r9,r8
800039ae:	c6 61       	brne	80003a7a <phy_rx_func+0xdae>
							
							SDV_Index = 0;
								
							if (payload_rx_channel->byte[5] == Pre_Voice_Decoder_Data )//0xF3
							{
									Item_ID = Pre_Voice_Decoder_Data;
800039b0:	10 99       	mov	r9,r8
800039b2:	4f c8       	lddpc	r8,80003ba0 <phy_rx_func+0xed4>
800039b4:	b0 89       	st.b	r8[0x0],r9
									RxBytesWaiting = (payload_rx_channel->byte[4] & 0x7F);//Test calculations are correct; 8
800039b6:	ef 39 00 0c 	ld.ub	r9,r7[12]
800039ba:	f3 d9 c0 07 	bfextu	r9,r9,0x0,0x7
800039be:	4f 58       	lddpc	r8,80003b90 <phy_rx_func+0xec4>
800039c0:	91 09       	st.w	r8[0x0],r9
									AMBE_rx_flag = 1;//本地作为AMBE数据的解密方
800039c2:	30 19       	mov	r9,1
800039c4:	fe f8 02 0c 	ld.w	r8,pc[524]
800039c8:	b0 89       	st.b	r8[0x0],r9
		
									AMBEBurst_rawdata[0] = payload_rx_channel->word[3];//用于解密的中间数据变量
800039ca:	8e 79       	ld.sh	r9,r7[0xe]
800039cc:	fe f8 02 14 	ld.w	r8,pc[532]
800039d0:	b0 09       	st.h	r8[0x0],r9
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//1
800039d2:	4f 68       	lddpc	r8,80003ba8 <phy_rx_func+0xedc>
800039d4:	4e c9       	lddpc	r9,80003b84 <phy_rx_func+0xeb8>
800039d6:	72 0a       	ld.w	r10,r9[0x0]
800039d8:	70 09       	ld.w	r9,r8[0x0]
800039da:	ef 3b 00 0e 	ld.ub	r11,r7[14]
800039de:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
800039e2:	70 09       	ld.w	r9,r8[0x0]
800039e4:	2f f9       	sub	r9,-1
800039e6:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800039e8:	e0 49 01 ff 	cp.w	r9,511
800039ec:	e0 88 00 13 	brls	80003a12 <phy_rx_func+0xd46>
									{
										RxAMBE_IsFillingNext8 = 0;
800039f0:	30 09       	mov	r9,0
800039f2:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
800039f4:	4e 46       	lddpc	r6,80003b84 <phy_rx_func+0xeb8>
800039f6:	6c 0c       	ld.w	r12,r6[0x0]
800039f8:	f0 1f 00 6e 	mcall	80003bb0 <phy_rx_func+0xee4>
										AMBE_payload_ptr = get_payload_idle_isr();
800039fc:	4e 08       	lddpc	r8,80003b7c <phy_rx_func+0xeb0>
800039fe:	70 0c       	ld.w	r12,r8[0x0]
80003a00:	f0 1f 00 59 	mcall	80003b64 <phy_rx_func+0xe98>
80003a04:	8d 0c       	st.w	r6[0x0],r12
										if(NULL == AMBE_payload_ptr)
80003a06:	c0 61       	brne	80003a12 <phy_rx_func+0xd46>
										{
											RxMediaState = WAITINGABAB;
80003a08:	30 09       	mov	r9,0
80003a0a:	4e 08       	lddpc	r8,80003b88 <phy_rx_func+0xebc>
80003a0c:	91 09       	st.w	r8[0x0],r9
80003a0e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
80003a12:	4e 09       	lddpc	r9,80003b90 <phy_rx_func+0xec4>
80003a14:	72 08       	ld.w	r8,r9[0x0]
80003a16:	20 18       	sub	r8,1
80003a18:	93 08       	st.w	r9[0x0],r8
80003a1a:	c0 61       	brne	80003a26 <phy_rx_func+0xd5a>
										RxMediaState = WAITINGABAB;
80003a1c:	30 09       	mov	r9,0
80003a1e:	4d b8       	lddpc	r8,80003b88 <phy_rx_func+0xebc>
80003a20:	91 09       	st.w	r8[0x0],r9
80003a22:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//2
80003a26:	4e 18       	lddpc	r8,80003ba8 <phy_rx_func+0xedc>
80003a28:	4d 79       	lddpc	r9,80003b84 <phy_rx_func+0xeb8>
80003a2a:	72 0a       	ld.w	r10,r9[0x0]
80003a2c:	70 09       	ld.w	r9,r8[0x0]
80003a2e:	ef 3b 00 0f 	ld.ub	r11,r7[15]
80003a32:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
80003a36:	70 09       	ld.w	r9,r8[0x0]
80003a38:	2f f9       	sub	r9,-1
80003a3a:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003a3c:	e0 49 01 ff 	cp.w	r9,511
80003a40:	e0 88 00 13 	brls	80003a66 <phy_rx_func+0xd9a>
									{
										RxAMBE_IsFillingNext8 = 0;
80003a44:	30 09       	mov	r9,0
80003a46:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
80003a48:	4c f7       	lddpc	r7,80003b84 <phy_rx_func+0xeb8>
80003a4a:	6e 0c       	ld.w	r12,r7[0x0]
80003a4c:	f0 1f 00 59 	mcall	80003bb0 <phy_rx_func+0xee4>
										AMBE_payload_ptr = get_payload_idle_isr();
80003a50:	4c b8       	lddpc	r8,80003b7c <phy_rx_func+0xeb0>
80003a52:	70 0c       	ld.w	r12,r8[0x0]
80003a54:	f0 1f 00 44 	mcall	80003b64 <phy_rx_func+0xe98>
80003a58:	8f 0c       	st.w	r7[0x0],r12
										if(NULL == AMBE_payload_ptr)
80003a5a:	c0 61       	brne	80003a66 <phy_rx_func+0xd9a>
										{
											RxMediaState = WAITINGABAB;
80003a5c:	30 09       	mov	r9,0
80003a5e:	4c b8       	lddpc	r8,80003b88 <phy_rx_func+0xebc>
80003a60:	91 09       	st.w	r8[0x0],r9
80003a62:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
80003a66:	4c b9       	lddpc	r9,80003b90 <phy_rx_func+0xec4>
80003a68:	72 08       	ld.w	r8,r9[0x0]
80003a6a:	20 18       	sub	r8,1
80003a6c:	93 08       	st.w	r9[0x0],r8
80003a6e:	c6 c1       	brne	80003b46 <phy_rx_func+0xe7a>
										RxMediaState = WAITINGABAB;
80003a70:	30 09       	mov	r9,0
80003a72:	4c 68       	lddpc	r8,80003b88 <phy_rx_func+0xebc>
80003a74:	91 09       	st.w	r8[0x0],r9
80003a76:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
							}
							else
							RxMediaState = WAITINGABAB;
80003a7a:	30 09       	mov	r9,0
80003a7c:	4c 38       	lddpc	r8,80003b88 <phy_rx_func+0xebc>
80003a7e:	91 09       	st.w	r8[0x0],r9
80003a80:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
						}
						else
						{
									
							Soft_Decision_Data[SDV_Index]	  = payload_rx_channel->word[0];
80003a84:	8e 4a       	ld.sh	r10,r7[0x8]
80003a86:	4d 99       	lddpc	r9,80003be8 <phy_rx_func+0xf1c>
80003a88:	f2 08 0a 1a 	st.h	r9[r8<<0x1],r10
							Soft_Decision_Data[SDV_Index+1]	  = payload_rx_channel->word[1];
80003a8c:	4d 6a       	lddpc	r10,80003be4 <phy_rx_func+0xf18>
80003a8e:	15 88       	ld.ub	r8,r10[0x0]
80003a90:	f0 cb ff ff 	sub	r11,r8,-1
80003a94:	8e 5c       	ld.sh	r12,r7[0xa]
80003a96:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+2]	  = payload_rx_channel->word[2];
80003a9a:	f0 cb ff fe 	sub	r11,r8,-2
80003a9e:	8e 6c       	ld.sh	r12,r7[0xc]
80003aa0:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+3]	  = payload_rx_channel->word[3];
80003aa4:	f0 cb ff fd 	sub	r11,r8,-3
80003aa8:	8e 7c       	ld.sh	r12,r7[0xe]
80003aaa:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							SDV_Index +=4;
80003aae:	2f c8       	sub	r8,-4
80003ab0:	b4 88       	st.b	r10[0x0],r8
80003ab2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					
					else
					{
						
						RxMediaState  = WAITINGABAB;
80003ab6:	30 09       	mov	r9,0
80003ab8:	4b 48       	lddpc	r8,80003b88 <phy_rx_func+0xebc>
80003aba:	91 09       	st.w	r8[0x0],r9
80003abc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
		break;//End of READING_AMBE_MEDIA.

        case READING_AMBE_AUX:
			
				Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[0];
80003ac0:	4c 08       	lddpc	r8,80003bc0 <phy_rx_func+0xef4>
80003ac2:	70 09       	ld.w	r9,r8[0x0]
80003ac4:	8e 4b       	ld.sh	r11,r7[0x8]
80003ac6:	4c 0a       	lddpc	r10,80003bc4 <phy_rx_func+0xef8>
80003ac8:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
				RxData_IsFillingNext16 += 1;
80003acc:	2f f9       	sub	r9,-1
80003ace:	91 09       	st.w	r8[0x0],r9
			
				if ((Item_Length -= 2) <= 0)
80003ad0:	4b 58       	lddpc	r8,80003ba4 <phy_rx_func+0xed8>
80003ad2:	70 09       	ld.w	r9,r8[0x0]
80003ad4:	20 29       	sub	r9,2
80003ad6:	91 09       	st.w	r8[0x0],r9
80003ad8:	70 08       	ld.w	r8,r8[0x0]
80003ada:	58 08       	cp.w	r8,0
80003adc:	c2 f1       	brne	80003b3a <phy_rx_func+0xe6e>
				{
					RxData_IsFillingNext16 = 0;
80003ade:	30 09       	mov	r9,0
80003ae0:	4b 88       	lddpc	r8,80003bc0 <phy_rx_func+0xef4>
80003ae2:	91 09       	st.w	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003ae4:	8e 59       	ld.sh	r9,r7[0xa]
80003ae6:	fe 78 82 12 	mov	r8,-32238
80003aea:	f0 09 19 00 	cp.h	r9,r8
80003aee:	c2 11       	brne	80003b30 <phy_rx_func+0xe64>
					{
						//Item_ID = Vocoder_Bit_Stream_Parameter;
						//Vocoder Bits Stream Parameter
						//Its value ranges from 1 to 18 for one voice superframe contains 6 voice bursts
						// and each burst contains 3 VFs.
						VF_SN = (payload_rx_channel->byte[5] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
80003af0:	ef 3c 00 0d 	ld.ub	r12,r7[13]
80003af4:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
80003af8:	4a f8       	lddpc	r8,80003bb4 <phy_rx_func+0xee8>
80003afa:	b0 8c       	st.b	r8[0x0],r12
							
						VBSP_data[0] = payload_rx_channel->word[1];
80003afc:	8e 59       	ld.sh	r9,r7[0xa]
80003afe:	4a f8       	lddpc	r8,80003bb8 <phy_rx_func+0xeec>
80003b00:	b0 09       	st.h	r8[0x0],r9
						VBSP_data[1] = payload_rx_channel->word[2];
80003b02:	8e 69       	ld.sh	r9,r7[0xc]
80003b04:	b0 19       	st.h	r8[0x2],r9
							
						m_RxBurstType = CalculateBurst(VF_SN);
80003b06:	f0 1f 00 2e 	mcall	80003bbc <phy_rx_func+0xef0>
80003b0a:	4a 18       	lddpc	r8,80003b8c <phy_rx_func+0xec0>
80003b0c:	91 0c       	st.w	r8[0x0],r12
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003b0e:	ef 39 00 0f 	ld.ub	r9,r7[15]
80003b12:	31 38       	mov	r8,19
80003b14:	f0 09 18 00 	cp.b	r9,r8
80003b18:	c0 71       	brne	80003b26 <phy_rx_func+0xe5a>
							
						m_RxBurstType = CalculateBurst(VF_SN);
						
						if (payload_rx_channel->byte[7] == Soft_Decision_Value)//0x13
						{
							Item_ID = Soft_Decision_Value;	
80003b1a:	10 99       	mov	r9,r8
80003b1c:	4a 18       	lddpc	r8,80003ba0 <phy_rx_func+0xed4>
80003b1e:	b0 89       	st.b	r8[0x0],r9
							RxBytesWaiting = ((payload_rx_channel->dword[1] & 0x00007F00) >>24);//Test calculations are correct; 26
80003b20:	30 09       	mov	r9,0
80003b22:	49 c8       	lddpc	r8,80003b90 <phy_rx_func+0xec4>
80003b24:	91 09       	st.w	r8[0x0],r9
						else
						{//error
								RxMediaState = WAITINGABAB;//Jump
						}
							
						RxMediaState = READING_AMBE_MEDIA;//Jump
80003b26:	30 49       	mov	r9,4
80003b28:	49 88       	lddpc	r8,80003b88 <phy_rx_func+0xebc>
80003b2a:	91 09       	st.w	r8[0x0],r9
80003b2c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					else
					{
						RxMediaState = WAITINGABAB;//Jump
80003b30:	30 09       	mov	r9,0
80003b32:	49 68       	lddpc	r8,80003b88 <phy_rx_func+0xebc>
80003b34:	91 09       	st.w	r8[0x0],r9
80003b36:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}

				}
				else
				{//测试看看是几个字节数据
					logFromISR("\n\r Radio Internal parameter length error \n\r");
80003b3a:	4a dc       	lddpc	r12,80003bec <phy_rx_func+0xf20>
80003b3c:	f0 1f 00 18 	mcall	80003b9c <phy_rx_func+0xed0>
					RxMediaState = WAITINGABAB;//Jump
80003b40:	30 09       	mov	r9,0
80003b42:	49 28       	lddpc	r8,80003b88 <phy_rx_func+0xebc>
80003b44:	91 09       	st.w	r8[0x0],r9
80003b46:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80003b4a:	00 00       	add	r0,r0
80003b4c:	00 00       	add	r0,r0
80003b4e:	0a b0       	st.h	r5++,r0
80003b50:	00 00       	add	r0,r0
80003b52:	0a c8       	st.b	r5++,r8
80003b54:	00 00       	add	r0,r0
80003b56:	0a a8       	st.w	r5++,r8
80003b58:	00 00       	add	r0,r0
80003b5a:	0a 8a       	andn	r10,r5
80003b5c:	00 00       	add	r0,r0
80003b5e:	0a 78       	tst	r8,r5
80003b60:	00 00       	add	r0,r0
80003b62:	0a a0       	st.w	r5++,r0
80003b64:	80 00       	ld.sh	r0,r0[0x0]
80003b66:	2b 54       	sub	r4,-75
80003b68:	00 00       	add	r0,r0
80003b6a:	0a 98       	mov	r8,r5
80003b6c:	80 00       	ld.sh	r0,r0[0x0]
80003b6e:	2a 6c       	sub	r12,-90
80003b70:	00 00       	add	r0,r0
80003b72:	0a ac       	st.w	r5++,r12
80003b74:	80 00       	ld.sh	r0,r0[0x0]
80003b76:	2a a0       	sub	r0,-86
80003b78:	00 00       	add	r0,r0
80003b7a:	0a 89       	andn	r9,r5
80003b7c:	00 00       	add	r0,r0
80003b7e:	0a a4       	st.w	r5++,r4
80003b80:	00 00       	add	r0,r0
80003b82:	0a b4       	st.h	r5++,r4
80003b84:	00 00       	add	r0,r0
80003b86:	0a 8c       	andn	r12,r5
80003b88:	00 00       	add	r0,r0
80003b8a:	0a d4       	st.w	--r5,r4
80003b8c:	00 00       	add	r0,r0
80003b8e:	0a bc       	st.h	r5++,r12
80003b90:	00 00       	add	r0,r0
80003b92:	0a 74       	tst	r4,r5
80003b94:	00 00       	add	r0,r0
80003b96:	0a 4d       	or	sp,r5
80003b98:	80 00       	ld.sh	r0,r0[0x0]
80003b9a:	d5 c8       	*unknown*
80003b9c:	80 00       	ld.sh	r0,r0[0x0]
80003b9e:	6f 78       	ld.w	r8,r7[0x5c]
80003ba0:	00 00       	add	r0,r0
80003ba2:	0a 88       	andn	r8,r5
80003ba4:	00 00       	add	r0,r0
80003ba6:	0a e0       	st.h	--r5,r0
80003ba8:	00 00       	add	r0,r0
80003baa:	0a c0       	st.b	r5++,r0
80003bac:	80 00       	ld.sh	r0,r0[0x0]
80003bae:	77 b0       	ld.w	r0,r11[0x6c]
80003bb0:	80 00       	ld.sh	r0,r0[0x0]
80003bb2:	2a 88       	sub	r8,-88
80003bb4:	00 00       	add	r0,r0
80003bb6:	0a 48       	or	r8,r5
80003bb8:	00 00       	add	r0,r0
80003bba:	1e ac       	st.w	pc++,r12
80003bbc:	80 00       	ld.sh	r0,r0[0x0]
80003bbe:	2a 3c       	sub	r12,-93
80003bc0:	00 00       	add	r0,r0
80003bc2:	0a 7c       	tst	r12,r5
80003bc4:	00 00       	add	r0,r0
80003bc6:	1d b0       	ld.ub	r0,lr[0x3]
80003bc8:	00 00       	add	r0,r0
80003bca:	0a 80       	andn	r0,r5
80003bcc:	00 00       	add	r0,r0
80003bce:	0a 49       	or	r9,r5
80003bd0:	00 00       	add	r0,r0
80003bd2:	0a 4c       	or	r12,r5
80003bd4:	00 00       	add	r0,r0
80003bd6:	0a d8       	st.w	--r5,r8
80003bd8:	00 00       	add	r0,r0
80003bda:	0a 94       	mov	r4,r5
80003bdc:	00 00       	add	r0,r0
80003bde:	0a 55       	eor	r5,r5
80003be0:	00 00       	add	r0,r0
80003be2:	1d a8       	ld.ub	r8,lr[0x2]
80003be4:	00 00       	add	r0,r0
80003be6:	0a cc       	st.b	r5++,r12
80003be8:	00 00       	add	r0,r0
80003bea:	1e b0       	st.h	pc++,r0
80003bec:	80 00       	ld.sh	r0,r0[0x0]
80003bee:	d5 e0       	acall	0x5e

80003bf0 <pdca_int_handler>:
    void (*phy_rx_exec)(void *)--callback function for receive SSC data 
Called By: interrupt
*/
__attribute__((__interrupt__))
static void pdca_int_handler(void)
{
80003bf0:	d4 01       	pushm	lr
	//xHigherPriorityTaskWoken = pdFALSE;
	
	static U32 count=0;
	//intStartCount = Get_system_register(AVR32_COUNT);
	
	count++;
80003bf2:	49 a8       	lddpc	r8,80003c58 <pdca_int_handler+0x68>
80003bf4:	70 09       	ld.w	r9,r8[0x0]
80003bf6:	2f f9       	sub	r9,-1
80003bf8:	91 09       	st.w	r8[0x0],r9
	/*Toggle Index*/
    BufferIndex ^= 0x01;
80003bfa:	49 98       	lddpc	r8,80003c5c <pdca_int_handler+0x6c>
80003bfc:	11 89       	ld.ub	r9,r8[0x0]
80003bfe:	ec 19 00 01 	eorl	r9,0x1
80003c02:	b0 89       	st.b	r8[0x0],r9
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);
80003c04:	11 89       	ld.ub	r9,r8[0x0]
80003c06:	a5 69       	lsl	r9,0x4
80003c08:	2f c9       	sub	r9,-4
80003c0a:	49 6a       	lddpc	r10,80003c60 <pdca_int_handler+0x70>
80003c0c:	14 09       	add	r9,r10
	count++;
	/*Toggle Index*/
    BufferIndex ^= 0x01;
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
80003c0e:	fe 7a 00 40 	mov	r10,-65472
80003c12:	95 39       	st.w	r10[0xc],r9
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80003c14:	30 39       	mov	r9,3
80003c16:	95 49       	st.w	r10[0x10],r9

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);
80003c18:	11 8a       	ld.ub	r10,r8[0x0]
80003c1a:	a5 6a       	lsl	r10,0x4
80003c1c:	2f ca       	sub	r10,-4
80003c1e:	49 28       	lddpc	r8,80003c64 <pdca_int_handler+0x74>
80003c20:	10 0a       	add	r10,r8
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
80003c22:	fe 78 00 00 	mov	r8,-65536
80003c26:	91 3a       	st.w	r8[0xc],r10
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80003c28:	91 49       	st.w	r8[0x10],r9
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr;
80003c2a:	70 b8       	ld.w	r8,r8[0x2c]
	
	/*receive SSC data*/
    if(phy_rx_exec != NULL)phy_rx_exec((void *)&RxBuffer[BufferIndex]);
80003c2c:	48 f8       	lddpc	r8,80003c68 <pdca_int_handler+0x78>
80003c2e:	70 08       	ld.w	r8,r8[0x0]
80003c30:	58 08       	cp.w	r8,0
80003c32:	c0 70       	breq	80003c40 <pdca_int_handler+0x50>
80003c34:	48 a9       	lddpc	r9,80003c5c <pdca_int_handler+0x6c>
80003c36:	13 89       	ld.ub	r9,r9[0x0]
80003c38:	a5 69       	lsl	r9,0x4
80003c3a:	48 bc       	lddpc	r12,80003c64 <pdca_int_handler+0x74>
80003c3c:	12 0c       	add	r12,r9
80003c3e:	5d 18       	icall	r8

    /*transmit SSC data*/

	if(phy_tx_exec != NULL)phy_tx_exec((void *)&TxBuffer[BufferIndex]);//phy_tx_func, phy_rx_func
80003c40:	48 b8       	lddpc	r8,80003c6c <pdca_int_handler+0x7c>
80003c42:	70 08       	ld.w	r8,r8[0x0]
80003c44:	58 08       	cp.w	r8,0
80003c46:	c0 70       	breq	80003c54 <pdca_int_handler+0x64>
80003c48:	48 59       	lddpc	r9,80003c5c <pdca_int_handler+0x6c>
80003c4a:	13 89       	ld.ub	r9,r9[0x0]
80003c4c:	a5 69       	lsl	r9,0x4
80003c4e:	48 5c       	lddpc	r12,80003c60 <pdca_int_handler+0x70>
80003c50:	12 0c       	add	r12,r9
80003c52:	5d 18       	icall	r8

	
	//intDuration = Get_system_register(AVR32_COUNT) - intStartCount;
	
	
}/*End of pdca_int_handler.*/
80003c54:	d4 02       	popm	lr
80003c56:	d6 03       	rete
80003c58:	00 00       	add	r0,r0
80003c5a:	0a e8       	st.h	--r5,r8
80003c5c:	00 00       	add	r0,r0
80003c5e:	96 d0       	ld.uh	r0,r11[0xa]
80003c60:	00 00       	add	r0,r0
80003c62:	96 f8       	ld.uh	r8,r11[0xe]
80003c64:	00 00       	add	r0,r0
80003c66:	96 d8       	ld.uh	r8,r11[0xa]
80003c68:	00 00       	add	r0,r0
80003c6a:	0a e4       	st.h	--r5,r4
80003c6c:	00 00       	add	r0,r0
80003c6e:	0a ec       	st.h	--r5,r12

80003c70 <local_start_SSC>:
void local_start_SSC(void)
{
    /*Assign GPIO to SSC.
    gpio_enable_module
    gpio_enable_module_pin*/
    AVR32_GPIO.port[1].pmr0c = 0x00000DC0;
80003c70:	fe 78 10 00 	mov	r8,-61440
80003c74:	e0 69 0d c0 	mov	r9,3520
80003c78:	f1 49 01 18 	st.w	r8[280],r9
    AVR32_GPIO.port[1].pmr1c = 0x00000DC0;
80003c7c:	f1 49 01 28 	st.w	r8[296],r9
    AVR32_GPIO.port[1].gperc = 0x00000DC0;
80003c80:	f1 49 01 08 	st.w	r8[264],r9

    /*Software reset SSC*/
    (&AVR32_SSC)->cr = AVR32_SSC_CR_SWRST_MASK;
80003c84:	fe 78 34 00 	mov	r8,-52224
80003c88:	e0 69 80 00 	mov	r9,32768
80003c8c:	91 09       	st.w	r8[0x0],r9
    (&AVR32_SSC)->cmr 
80003c8e:	30 09       	mov	r9,0
80003c90:	91 19       	st.w	r8[0x4],r9
                     = AVR32_SSC_CMR_DIV_NOT_ACTIVE << AVR32_SSC_CMR_DIV_OFFSET;

    /*For Slave*/
    (&AVR32_SSC)->tcmr =
80003c92:	e0 69 04 21 	mov	r9,1057
80003c96:	ea 19 3f 20 	orh	r9,0x3f20
80003c9a:	91 69       	st.w	r8[0x18],r9
	      32								<< AVR32_SSC_TCMR_STTDLY_OFFSET	|
	      63								<< AVR32_SSC_TCMR_PERIOD_OFFSET;


    /*For Slave*/
    (&AVR32_SSC)->tfmr = 
80003c9c:	e0 69 02 9f 	mov	r9,671
80003ca0:	ea 19 01 00 	orh	r9,0x100
80003ca4:	91 79       	st.w	r8[0x1c],r9
	     0									<< AVR32_SSC_TFMR_FSDEN_OFFSET	|
	     1									<< AVR32_SSC_TFMR_FSEDGE_OFFSET;

	/*For Slave*/

	(&AVR32_SSC)->rcmr = 
80003ca6:	e0 6a 04 02 	mov	r10,1026
80003caa:	ea 1a 3f 20 	orh	r10,0x3f20
80003cae:	91 4a       	st.w	r8[0x10],r10
	     0									<< AVR32_SSC_RCMR_STOP_OFFSET	|
	     32									<< AVR32_SSC_RCMR_STTDLY_OFFSET	|
	     63									<< AVR32_SSC_RCMR_PERIOD_OFFSET;

	/*For Slave*/
	(&AVR32_SSC)->rfmr = 
80003cb0:	91 59       	st.w	r8[0x14],r9
	    1									<< AVR32_SSC_RFMR_MSBF_OFFSET	|
	    2									<< AVR32_SSC_RFMR_DATNB_OFFSET	|
	    0									<< AVR32_SSC_RFMR_FSLEN_OFFSET	|
	    AVR32_SSC_RFMR_FSOS_INPUT_ONLY		<< AVR32_SSC_RFMR_FSOS_OFFSET	|
	    1									<< AVR32_SSC_RFMR_FSEDGE_OFFSET;
}/*End of local_start_SSC.*/
80003cb2:	5e fc       	retal	r12

80003cb4 <local_start_PDC>:
Function: local_start_PDC
Description: none
Called By: void ssc_init(void) -- ssc.c
*/
void local_start_PDC(void)
{
80003cb4:	d4 01       	pushm	lr
    /*Toggle Index*/	
    BufferIndex = 1;
80003cb6:	30 19       	mov	r9,1
80003cb8:	49 78       	lddpc	r8,80003d14 <local_start_PDC+0x60>
80003cba:	b0 89       	st.b	r8[0x0],r9
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
80003cbc:	fe 78 00 00 	mov	r8,-65536
80003cc0:	30 7b       	mov	r11,7
80003cc2:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
80003cc4:	70 b9       	ld.w	r9,r8[0x2c]
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
80003cc6:	49 59       	lddpc	r9,80003d18 <local_start_PDC+0x64>
80003cc8:	f2 ca ff fc 	sub	r10,r9,-4
    BufferIndex = 1;
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
80003ccc:	91 0a       	st.w	r8[0x0],r10
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
80003cce:	30 3a       	mov	r10,3
80003cd0:	91 2a       	st.w	r8[0x8],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
80003cd2:	30 1c       	mov	r12,1
80003cd4:	91 1c       	st.w	r8[0x4],r12
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
80003cd6:	2e c9       	sub	r9,-20
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
80003cd8:	91 39       	st.w	r8[0xc],r9
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80003cda:	91 4a       	st.w	r8[0x10],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80003cdc:	30 2c       	mov	r12,2
80003cde:	91 6c       	st.w	r8[0x18],r12

	TxBuffer[0].xnl_channel.dword = XNL_IDLE;
80003ce0:	48 f9       	lddpc	r9,80003d1c <local_start_PDC+0x68>
80003ce2:	e0 68 5a 5a 	mov	r8,23130
80003ce6:	ea 18 ab cd 	orh	r8,0xabcd
80003cea:	93 18       	st.w	r9[0x4],r8
	TxBuffer[0].payload_channel.dword[0] = PAYLOADIDLE0;
80003cec:	93 28       	st.w	r9[0x8],r8
	TxBuffer[0].payload_channel.dword[1] = PAYLOADIDLE1;
80003cee:	30 0e       	mov	lr,0
80003cf0:	93 3e       	st.w	r9[0xc],lr
	TxBuffer[1].xnl_channel.dword = XNL_IDLE;
80003cf2:	93 58       	st.w	r9[0x14],r8
	TxBuffer[1].payload_channel.dword[0] = PAYLOADIDLE0;
80003cf4:	93 68       	st.w	r9[0x18],r8
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;
80003cf6:	93 7e       	st.w	r9[0x1c],lr

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
80003cf8:	fe 78 00 40 	mov	r8,-65472
80003cfc:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
80003cfe:	70 be       	ld.w	lr,r8[0x2c]
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
80003d00:	f2 ce ff fc 	sub	lr,r9,-4
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
80003d04:	91 0e       	st.w	r8[0x0],lr
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
80003d06:	91 2a       	st.w	r8[0x8],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
80003d08:	91 1b       	st.w	r8[0x4],r11
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
80003d0a:	2e c9       	sub	r9,-20
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
80003d0c:	91 39       	st.w	r8[0xc],r9
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80003d0e:	91 4a       	st.w	r8[0x10],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80003d10:	91 6c       	st.w	r8[0x18],r12
}/*End of local_start_PDC.*/
80003d12:	d8 02       	popm	pc
80003d14:	00 00       	add	r0,r0
80003d16:	96 d0       	ld.uh	r0,r11[0xa]
80003d18:	00 00       	add	r0,r0
80003d1a:	96 d8       	ld.uh	r8,r11[0xa]
80003d1c:	00 00       	add	r0,r0
80003d1e:	96 f8       	ld.uh	r8,r11[0xe]

80003d20 <register_rx_tx_func>:
Description: register the rx function(callback function)
Called By: phy_init -- physical.c
*/
void register_rx_tx_func(void (*rx_exec)(void *),  void ( *tx_exec)(void *))
{
	 phy_rx_exec = rx_exec;
80003d20:	48 38       	lddpc	r8,80003d2c <register_rx_tx_func+0xc>
80003d22:	91 0c       	st.w	r8[0x0],r12
	 phy_tx_exec = tx_exec;//phy_tx_func, phy_rx_func
80003d24:	48 38       	lddpc	r8,80003d30 <register_rx_tx_func+0x10>
80003d26:	91 0b       	st.w	r8[0x0],r11
	 
}/*End of register_tx_rx_func.*/
80003d28:	5e fc       	retal	r12
80003d2a:	00 00       	add	r0,r0
80003d2c:	00 00       	add	r0,r0
80003d2e:	0a e4       	st.h	--r5,r4
80003d30:	00 00       	add	r0,r0
80003d32:	0a ec       	st.h	--r5,r12

80003d34 <ssc_init>:
    local_start_SSC -- ssc.c
    local_start_PDC -- ssc.c
Called By: phy_init -- physical.c
*/
void ssc_init(void)
{		
80003d34:	d4 01       	pushm	lr
    /*Set up PB01 to watch FS.*/
    AVR32_GPIO.port[1].oderc = 0x00000002;
80003d36:	fe 78 10 00 	mov	r8,-61440
80003d3a:	30 29       	mov	r9,2
80003d3c:	f1 49 01 48 	st.w	r8[328],r9
    AVR32_GPIO.port[1].gpers = 0x00000002;
80003d40:	f1 49 01 04 	st.w	r8[260],r9
	
	Disable_global_interrupt();
80003d44:	d3 03       	ssrf	0x10
	
	INTC_register_interrupt (
80003d46:	30 3a       	mov	r10,3
80003d48:	36 0b       	mov	r11,96
80003d4a:	49 4c       	lddpc	r12,80003d98 <ssc_init+0x64>
80003d4c:	f0 1f 00 14 	mcall	80003d9c <ssc_init+0x68>
	&pdca_int_handler
	, AVR32_PDCA_IRQ_0 //PDCA_CHANNEL_SSCRX_EXAMPLE = 0
	, AVR32_INTC_INT3 //highest priority.
	);
	
	Enable_global_interrupt();
80003d50:	d5 03       	csrf	0x10
	
    /*Waits for radio to start making FSYNC.*/
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
80003d52:	fe 79 10 00 	mov	r9,-61440
80003d56:	f2 f8 01 60 	ld.w	r8,r9[352]
80003d5a:	e2 18 00 02 	andl	r8,0x2,COH
80003d5e:	cf c0       	breq	80003d56 <ssc_init+0x22>
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
80003d60:	fe 79 10 00 	mov	r9,-61440
80003d64:	f2 f8 01 60 	ld.w	r8,r9[352]
80003d68:	e2 18 00 02 	andl	r8,0x2,COH
80003d6c:	cf c1       	brne	80003d64 <ssc_init+0x30>
			
	Disable_global_interrupt(); // resume to before
80003d6e:	d3 03       	ssrf	0x10
				
    /*config the SSC*/
    local_start_SSC();
80003d70:	f0 1f 00 0c 	mcall	80003da0 <ssc_init+0x6c>

    /*config the PDCA*/
    local_start_PDC();
80003d74:	f0 1f 00 0c 	mcall	80003da4 <ssc_init+0x70>
		
    /*Start the SSC Physical Layer.*/

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80003d78:	fe 79 00 00 	mov	r9,-65536
80003d7c:	30 18       	mov	r8,1
80003d7e:	93 58       	st.w	r9[0x14],r8
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80003d80:	fe 7a 00 40 	mov	r10,-65472
80003d84:	95 58       	st.w	r10[0x14],r8
    (&AVR32_SSC)->cr = AVR32_SSC_CR_RXEN_MASK | AVR32_SSC_CR_TXEN_MASK;
80003d86:	e0 6b 01 01 	mov	r11,257
80003d8a:	fe 7a 34 00 	mov	r10,-52224
80003d8e:	95 0b       	st.w	r10[0x0],r11
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->ier = AVR32_PDCA_RCZ_MASK;
80003d90:	93 88       	st.w	r9[0x20],r8
															
	Enable_global_interrupt();
80003d92:	d5 03       	csrf	0x10
															
}/*End of ssc_init.*/
80003d94:	d8 02       	popm	pc
80003d96:	00 00       	add	r0,r0
80003d98:	80 00       	ld.sh	r0,r0[0x0]
80003d9a:	3b f0       	mov	r0,-65
80003d9c:	80 00       	ld.sh	r0,r0[0x0]
80003d9e:	53 c4       	stdsp	sp[0xf0],r4
80003da0:	80 00       	ld.sh	r0,r0[0x0]
80003da2:	3c 70       	mov	r0,-57
80003da4:	80 00       	ld.sh	r0,r0[0x0]
80003da6:	3c b4       	mov	r4,-53

80003da8 <xcmp_register_app_list>:
Calls: 
Called By: app_init -- app.c
*/
void xcmp_register_app_list(void * list)
{
	app_list = (app_exec_t *)list;
80003da8:	48 28       	lddpc	r8,80003db0 <xcmp_register_app_list+0x8>
80003daa:	91 0c       	st.w	r8[0x0],r12
}
80003dac:	5e fc       	retal	r12
80003dae:	00 00       	add	r0,r0
80003db0:	00 00       	add	r0,r0
80003db2:	97 18       	st.w	r11[0x4],r8

80003db4 <xcmp_tx>:
Calls:   
	xnl_tx -- xnl.c
Called By: ...
*/
static void xcmp_tx( xcmp_fragment_t * xcmp, U8 payload_len)
{
80003db4:	eb cd 40 80 	pushm	r7,lr
80003db8:	fa cd 01 00 	sub	sp,sp,256
80003dbc:	16 97       	mov	r7,r11
	Length :xnl length + checksum
	= checksum + xnl header + xcmp opcode + xcmp payload
	= 0x02 + 0x0C + 0x02 + xcmp payload
	= 0x10 + xcmp payload
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | ( 0x10 + payload_len);
80003dbe:	16 98       	mov	r8,r11
80003dc0:	2f 08       	sub	r8,-16
80003dc2:	af a8       	sbr	r8,0xe
80003dc4:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE; 
80003dc6:	3f f8       	mov	r8,-1
80003dc8:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG;
80003dca:	30 b9       	mov	r9,11
80003dcc:	ba 29       	st.h	sp[0x4],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;	
80003dce:	ba 38       	st.h	sp[0x6],r8
	xnl_frame.xnl_header.destination = DEFAULT_VALUE;
80003dd0:	ba 48       	st.h	sp[0x8],r8
	xnl_frame.xnl_header.source = DEFAULT_VALUE;	
80003dd2:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80003dd4:	ba 68       	st.h	sp[0xc],r8
	
	/*insert xcmp frame data*/
	memcpy(&xnl_frame.xnl_payload.xnl_content_data_msg, xcmp, payload_len + 2);
80003dd6:	f6 ca ff fe 	sub	r10,r11,-2
80003dda:	18 9b       	mov	r11,r12
80003ddc:	fa cc ff f0 	sub	r12,sp,-16
80003de0:	f0 1f 00 05 	mcall	80003df4 <xcmp_tx+0x40>
	xnl_frame.xnl_header.payload_length = payload_len + 2;	
80003de4:	2f e7       	sub	r7,-2
80003de6:	ba 77       	st.h	sp[0xe],r7
	
	/* send xnl frame*/	
	xnl_tx(&xnl_frame);
80003de8:	1a 9c       	mov	r12,sp
80003dea:	f0 1f 00 04 	mcall	80003df8 <xcmp_tx+0x44>
}
80003dee:	2c 0d       	sub	sp,-256
80003df0:	e3 cd 80 80 	ldm	sp++,r7,pc
80003df4:	80 00       	ld.sh	r0,r0[0x0]
80003df6:	76 68       	ld.w	r8,r11[0x18]
80003df8:	80 00       	ld.sh	r0,r0[0x0]
80003dfa:	43 cc       	lddsp	r12,sp[0xf0]

80003dfc <xcmp_data_session_req>:
Description: send data-session request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_data_session_req(void *message, U16 length, U32 dest)
{
80003dfc:	d4 21       	pushm	r4-r7,lr
80003dfe:	fa cd 00 d0 	sub	sp,sp,208
80003e02:	18 94       	mov	r4,r12
80003e04:	16 97       	mov	r7,r11
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
	
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
	
	if (length > 256)return -1;
80003e06:	e0 68 01 00 	mov	r8,256
80003e0a:	f0 0b 19 00 	cp.h	r11,r8
80003e0e:	e0 8b 00 38 	brhi	80003e7e <xcmp_data_session_req+0x82>
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
	
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
80003e12:	fa c5 ff f8 	sub	r5,sp,-8
	//U8 SizeofAddress = Remote_Mototrbo_Address_Size;// 3;//可能会变化
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
80003e16:	e0 68 04 1d 	mov	r8,1053
80003e1a:	ba 38       	st.h	sp[0x6],r8
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
	
	if (length > 256)return -1;
	
	ptr->Function = Single_Data_Uint;
80003e1c:	30 18       	mov	r8,1
80003e1e:	aa 88       	st.b	r5[0x0],r8
	
	ptr->DataDefinition.Data_Protocol_Version = TMP_Ver_1_1;//0x20
80003e20:	32 08       	mov	r8,32
80003e22:	aa 98       	st.b	r5[0x1],r8
	
	ptr->DataDefinition.Dest_Address.Remote_Address_Type = Remote_IPV4_Address;//0x02
80003e24:	30 28       	mov	r8,2
80003e26:	aa a8       	st.b	r5[0x2],r8
	
	ptr->DataDefinition.Dest_Address.Remote_Address_Size = Remote_IPV4_Address_Size;//0x04
80003e28:	30 48       	mov	r8,4
80003e2a:	aa b8       	st.b	r5[0x3],r8
	
	unsigned int addr = 0x0C000000 | (dest & 0x00FFFFFF);
80003e2c:	f5 da c0 18 	bfextu	r10,r10,0x0,0x18
80003e30:	ea 1a 0c 00 	orh	r10,0xc00
80003e34:	50 0a       	stdsp	sp[0x0],r10
	memcpy(ptr->DataDefinition.Dest_Address.Remote_Address, &addr, Remote_IPV4_Address_Size);
80003e36:	30 4a       	mov	r10,4
80003e38:	1a 9b       	mov	r11,sp
80003e3a:	fa cc ff f4 	sub	r12,sp,-12
80003e3e:	f0 1f 00 12 	mcall	80003e84 <xcmp_data_session_req+0x88>
	//ptr->DataDefinition.Dest_Address.Remote_Address[0] = 0x0C;//12
	//ptr->DataDefinition.Dest_Address.Remote_Address[1] = 0x00;//0
	//ptr->DataDefinition.Dest_Address.Remote_Address[2] = 0x00;//0
	//ptr->DataDefinition.Dest_Address.Remote_Address[3] = 0x02;//2
	
	ptr->DataDefinition.Dest_Address.Remote_Port_Com[0] = (Remote_Port >>8) & 0xFF;//4007
80003e42:	30 f8       	mov	r8,15
80003e44:	eb 68 00 08 	st.b	r5[8],r8
	ptr->DataDefinition.Dest_Address.Remote_Port_Com[1] = Remote_Port & 0xFF;//
80003e48:	3a 78       	mov	r8,-89
80003e4a:	eb 68 00 09 	st.b	r5[9],r8
	
    
	ptr->DataPayload.Session_ID_Number = Session_ID;//0x00
80003e4e:	30 08       	mov	r8,0
80003e50:	eb 68 00 0a 	st.b	r5[10],r8
	
	ptr->DataPayload.DataPayload_Length[0] =(length >> 8) & 0xFF ;//可能会变化
80003e54:	0e 9a       	mov	r10,r7
80003e56:	5c 7a       	castu.h	r10
80003e58:	f4 08 16 08 	lsr	r8,r10,0x8
80003e5c:	eb 68 00 0b 	st.b	r5[11],r8
	ptr->DataPayload.DataPayload_Length[1] =length & 0xFF  ;//可能会变化
80003e60:	0e 96       	mov	r6,r7
80003e62:	eb 67 00 0c 	st.b	r5[12],r7
	
	memcpy(&(ptr->DataPayload.DataPayload[0]), message, length);
80003e66:	08 9b       	mov	r11,r4
80003e68:	fa cc ff eb 	sub	r12,sp,-21
80003e6c:	f0 1f 00 06 	mcall	80003e84 <xcmp_data_session_req+0x88>
	
	xcmp_tx(&xcmp_farme, sizeof(DataSession_req_t) - (256 - length));
80003e70:	ee cb ff f3 	sub	r11,r7,-13
80003e74:	5c 5b       	castu.b	r11
80003e76:	fa cc ff fa 	sub	r12,sp,-6
80003e7a:	f0 1f 00 04 	mcall	80003e88 <xcmp_data_session_req+0x8c>
}
80003e7e:	2c cd       	sub	sp,-208
80003e80:	d8 22       	popm	r4-r7,pc
80003e82:	00 00       	add	r0,r0
80003e84:	80 00       	ld.sh	r0,r0[0x0]
80003e86:	76 68       	ld.w	r8,r11[0x18]
80003e88:	80 00       	ld.sh	r0,r0[0x0]
80003e8a:	3d b4       	mov	r4,-37

80003e8c <xcmp_DeviceInitializationStatus_request>:
Description: send device initialization status request
Calls: xcmp_tx
Called By:...
*/
void xcmp_DeviceInitializationStatus_request(void)
{
80003e8c:	d4 01       	pushm	lr
80003e8e:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
		
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_BRDCAST | DEVICE_INITIALIZATION_STATUS;
80003e92:	fe 78 b4 00 	mov	r8,-19456
80003e96:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	DeviceInitializationStatus_brdcst_t * ptr 
						 = (DeviceInitializationStatus_brdcst_t *)xcmp_farme.u8;
80003e98:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*xcmp version 8.1.0.5*///版本号未正确填写，纠正
	ptr->XCMPVersion[0] = XCMP_Version[0];
80003e9c:	48 c9       	lddpc	r9,80003ecc <xcmp_DeviceInitializationStatus_request+0x40>
80003e9e:	13 8a       	ld.ub	r10,r9[0x0]
80003ea0:	b0 8a       	st.b	r8[0x0],r10
	ptr->XCMPVersion[1] = XCMP_Version[1];
80003ea2:	13 9a       	ld.ub	r10,r9[0x1]
80003ea4:	b0 9a       	st.b	r8[0x1],r10
	ptr->XCMPVersion[2] = XCMP_Version[2];
80003ea6:	13 aa       	ld.ub	r10,r9[0x2]
80003ea8:	b0 aa       	st.b	r8[0x2],r10
	ptr->XCMPVersion[3] = XCMP_Version[3];
80003eaa:	13 b9       	ld.ub	r9,r9[0x3]
80003eac:	b0 b9       	st.b	r8[0x3],r9
	/*
	0x00:
	This is the message that the device sends at power up or after a reset. It 
	will give the initial status and capabilities for the device.
	*/
	ptr->DeviceInitType = 0x00;
80003eae:	30 09       	mov	r9,0
80003eb0:	b0 c9       	st.b	r8[0x4],r9
	types of devices may provide a set of services to the radio system, but do 
	not have the ability to be the master.
	
	0x07:OptionBoard,3rd party Option Board-based application.
	*/
	ptr->DeviceStatusInfo.DeviceType = 0x07;
80003eb2:	30 7a       	mov	r10,7
80003eb4:	b0 da       	st.b	r8[0x5],r10
	
	/*Power Up Success, Device has powered up with no errors*/
	ptr->DeviceStatusInfo.DeviceStatus[0] = 0x00;
80003eb6:	b0 e9       	st.b	r8[0x6],r9
	ptr->DeviceStatusInfo.DeviceStatus[1] = 0x00;
80003eb8:	b0 f9       	st.b	r8[0x7],r9
	
	/*
	This number is the size of the Device Descriptor data structure with a 
	maximum size not exceeding 255 bytes.
	*/
	ptr->DeviceStatusInfo.DeviceDescriptorSize = 0x00;
80003eba:	f1 69 00 08 	st.b	r8[8],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme
80003ebe:	30 9b       	mov	r11,9
80003ec0:	fa cc ff fe 	sub	r12,sp,-2
80003ec4:	f0 1f 00 03 	mcall	80003ed0 <xcmp_DeviceInitializationStatus_request+0x44>
		, sizeof(DeviceInitializationStatus_brdcst_t) - MAX_DEVICE_DESC_SIZE);
}
80003ec8:	2c dd       	sub	sp,-204
80003eca:	d8 02       	popm	pc
80003ecc:	00 00       	add	r0,r0
80003ece:	0d 94       	ld.ub	r4,r6[0x1]
80003ed0:	80 00       	ld.sh	r0,r0[0x0]
80003ed2:	3d b4       	mov	r4,-37

80003ed4 <xcmp_opcode_not_supported>:
Description: register the app list
Calls: xcmp_tx
Called By:...
*/
void xcmp_opcode_not_supported( void )
{
80003ed4:	d4 01       	pushm	lr
80003ed6:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REPLY;
80003eda:	fe 78 80 00 	mov	r8,-32768
80003ede:	ba 18       	st.h	sp[0x2],r8
	
	/*The radio does not support this opcode.*/
	xcmp_farme.u8[0] = xcmp_Res_Opcode_Not_Supported;
80003ee0:	30 38       	mov	r8,3
80003ee2:	ba c8       	st.b	sp[0x4],r8
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, 1);
80003ee4:	30 1b       	mov	r11,1
80003ee6:	fa cc ff fe 	sub	r12,sp,-2
80003eea:	f0 1f 00 03 	mcall	80003ef4 <xcmp_opcode_not_supported+0x20>
}
80003eee:	2c dd       	sub	sp,-204
80003ef0:	d8 02       	popm	pc
80003ef2:	00 00       	add	r0,r0
80003ef4:	80 00       	ld.sh	r0,r0[0x0]
80003ef6:	3d b4       	mov	r4,-37

80003ef8 <xcmp_exec_func>:
Description: Perform XCMP corresponding functions
Calls:   
Called By: xcmp_rx_process--task
*/
static void xcmp_exec_func(app_exec_t * exec, xcmp_fragment_t * xcmp)
{
80003ef8:	d4 01       	pushm	lr
	/*The message types*/
	switch(xcmp->xcmp_opcode & 0xF000)
80003efa:	96 88       	ld.uh	r8,r11[0x0]
80003efc:	e2 18 f0 00 	andl	r8,0xf000,COH
80003f00:	e0 48 80 00 	cp.w	r8,32768
80003f04:	c0 f0       	breq	80003f22 <xcmp_exec_func+0x2a>
80003f06:	e0 48 b0 00 	cp.w	r8,45056
80003f0a:	c1 20       	breq	80003f2e <xcmp_exec_func+0x36>
80003f0c:	58 08       	cp.w	r8,0
80003f0e:	c1 51       	brne	80003f38 <xcmp_exec_func+0x40>
	{
		case XCMP_REQUEST:
			if(NULL != exec->xcmp_rx_req)
80003f10:	78 08       	ld.w	r8,r12[0x0]
80003f12:	58 08       	cp.w	r8,0
80003f14:	c0 40       	breq	80003f1c <xcmp_exec_func+0x24>
			{
				exec->xcmp_rx_req(xcmp);
80003f16:	16 9c       	mov	r12,r11
80003f18:	5d 18       	icall	r8
80003f1a:	d8 02       	popm	pc
			}
			else 
			{
				/*No function to register the request message*/
				/*send not supported opcode to raido */
				xcmp_opcode_not_supported();
80003f1c:	f0 1f 00 08 	mcall	80003f3c <xcmp_exec_func+0x44>
80003f20:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_REPLY:		
			if(NULL != exec->xcmp_rx_reply)
80003f22:	78 18       	ld.w	r8,r12[0x4]
80003f24:	58 08       	cp.w	r8,0
80003f26:	c0 90       	breq	80003f38 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_reply(xcmp);
80003f28:	16 9c       	mov	r12,r11
80003f2a:	5d 18       	icall	r8
80003f2c:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_BRDCAST:	
			if(NULL != exec->xcmp_rx_brdcst)
80003f2e:	78 28       	ld.w	r8,r12[0x8]
80003f30:	58 08       	cp.w	r8,0
80003f32:	c0 30       	breq	80003f38 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_brdcst(xcmp);
80003f34:	16 9c       	mov	r12,r11
80003f36:	5d 18       	icall	r8
80003f38:	d8 02       	popm	pc
80003f3a:	00 00       	add	r0,r0
80003f3c:	80 00       	ld.sh	r0,r0[0x0]
80003f3e:	3e d4       	mov	r4,-19

80003f40 <xcmp_IdleTestTone>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_IdleTestTone(U8 type, U16 toneID)
{
80003f40:	d4 01       	pushm	lr
80003f42:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | TONE_CONTROL;
80003f46:	e0 68 04 09 	mov	r8,1033
80003f4a:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	ToneControl_req_t * ptr = (ToneControl_req_t *)xcmp_farme.u8;
80003f4c:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*Starts the specific tone*/	
	ptr->Function = type;
80003f50:	b0 8c       	st.b	r8[0x0],r12
	
	/*This tone shall be sounded when radio landed on a priority channel*/
	//ptr->ToneIdentifier[0] = (Priority_Beep >> 8) & 0xFF;
	//ptr->ToneIdentifier[1] = Priority_Beep & 0xFF;
	
	ptr->ToneIdentifier[0] = (toneID >> 8) & 0xFF;
80003f52:	f3 db c1 08 	bfextu	r9,r11,0x8,0x8
80003f56:	b0 99       	st.b	r8[0x1],r9
	ptr->ToneIdentifier[1] = toneID & 0xFF;	
80003f58:	b0 ab       	st.b	r8[0x2],r11
	
	/*
	The alert tone is played according to any rules for alert tones, given the 
	current volume setting. Settings for this field are 8 to 255 (0x08 ?0xFF).
	*/
	ptr->ToneVolumeControl = Current_Volume;
80003f5a:	30 09       	mov	r9,0
80003f5c:	b0 b9       	st.b	r8[0x3],r9
	
	/*clear reserved*/
	memset(ptr->Reserved, 0, 8);
80003f5e:	fb 69 00 08 	st.b	sp[8],r9
80003f62:	fa c8 ff f7 	sub	r8,sp,-9
80003f66:	b0 89       	st.b	r8[0x0],r9
80003f68:	fa c8 ff f6 	sub	r8,sp,-10
80003f6c:	b0 89       	st.b	r8[0x0],r9
80003f6e:	fa c8 ff f5 	sub	r8,sp,-11
80003f72:	b0 89       	st.b	r8[0x0],r9
80003f74:	fa c8 ff f4 	sub	r8,sp,-12
80003f78:	b0 89       	st.b	r8[0x0],r9
80003f7a:	fa c8 ff f3 	sub	r8,sp,-13
80003f7e:	b0 89       	st.b	r8[0x0],r9
80003f80:	fa c8 ff f2 	sub	r8,sp,-14
80003f84:	b0 89       	st.b	r8[0x0],r9
80003f86:	fa c8 ff f1 	sub	r8,sp,-15
80003f8a:	b0 89       	st.b	r8[0x0],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(ToneControl_req_t));
80003f8c:	30 cb       	mov	r11,12
80003f8e:	fa cc ff fe 	sub	r12,sp,-2
80003f92:	f0 1f 00 03 	mcall	80003f9c <xcmp_IdleTestTone+0x5c>
}
80003f96:	2c dd       	sub	sp,-204
80003f98:	d8 02       	popm	pc
80003f9a:	00 00       	add	r0,r0
80003f9c:	80 00       	ld.sh	r0,r0[0x0]
80003f9e:	3d b4       	mov	r4,-37

80003fa0 <xcmp_init>:
	xQueueCreate -- freertos
	xTaskCreate -- freertos
Called By: main -- main.c
*/
void xcmp_init(void)
{
80003fa0:	d4 01       	pushm	lr
	/*register the xcmp function(callback function)*/
	xnl_register_xcmp_func( xcmp_rx );
80003fa2:	48 dc       	lddpc	r12,80003fd4 <xcmp_init+0x34>
80003fa4:	f0 1f 00 0d 	mcall	80003fd8 <xcmp_init+0x38>
	
	/*initialize the queue*/
	xcmp_frame_rx = xQueueCreate(20, sizeof(xcmp_fragment_t *));
80003fa8:	30 4b       	mov	r11,4
80003faa:	31 4c       	mov	r12,20
80003fac:	f0 1f 00 0c 	mcall	80003fdc <xcmp_init+0x3c>
80003fb0:	48 c8       	lddpc	r8,80003fe0 <xcmp_init+0x40>
80003fb2:	91 0c       	st.w	r8[0x0],r12
	/*create task*/	
	/*this task is used to execute xcmp message*/
	xTaskCreate(
80003fb4:	30 09       	mov	r9,0
80003fb6:	1a d9       	st.w	--sp,r9
80003fb8:	1a d9       	st.w	--sp,r9
80003fba:	1a d9       	st.w	--sp,r9
80003fbc:	30 38       	mov	r8,3
80003fbe:	e0 6a 04 00 	mov	r10,1024
80003fc2:	48 9b       	lddpc	r11,80003fe4 <xcmp_init+0x44>
80003fc4:	48 9c       	lddpc	r12,80003fe8 <xcmp_init+0x48>
80003fc6:	f0 1f 00 0a 	mcall	80003fec <xcmp_init+0x4c>
	,  tskXCMP_PRIORITY
	,  NULL
	);
	
	/*initialize the xnl*/
	xnl_init();
80003fca:	f0 1f 00 0a 	mcall	80003ff0 <xcmp_init+0x50>
80003fce:	2f dd       	sub	sp,-12
	
}
80003fd0:	d8 02       	popm	pc
80003fd2:	00 00       	add	r0,r0
80003fd4:	80 00       	ld.sh	r0,r0[0x0]
80003fd6:	40 f0       	lddsp	r0,sp[0x3c]
80003fd8:	80 00       	ld.sh	r0,r0[0x0]
80003fda:	41 3c       	lddsp	r12,sp[0x4c]
80003fdc:	80 00       	ld.sh	r0,r0[0x0]
80003fde:	63 0c       	ld.w	r12,r1[0x40]
80003fe0:	00 00       	add	r0,r0
80003fe2:	0b 08       	ld.w	r8,r5++
80003fe4:	80 00       	ld.sh	r0,r0[0x0]
80003fe6:	d6 0c       	*unknown*
80003fe8:	80 00       	ld.sh	r0,r0[0x0]
80003fea:	3f f4       	mov	r4,-1
80003fec:	80 00       	ld.sh	r0,r0[0x0]
80003fee:	6a 28       	ld.w	r8,r5[0x8]
80003ff0:	80 00       	ld.sh	r0,r0[0x0]
80003ff2:	41 74       	lddsp	r4,sp[0x5c]

80003ff4 <xcmp_rx_process>:
Calls: xQueueReceive -- freerots
	xcmp_exec_func
Called By: task
*/
static void xcmp_rx_process(void * pvParameters)
{
80003ff4:	d4 31       	pushm	r0-r7,lr
80003ff6:	20 1d       	sub	sp,4
	xcmp_fragment_t * ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
80003ff8:	4b 16       	lddpc	r6,800040bc <xcmp_rx_process+0xc8>
80003ffa:	30 05       	mov	r5,0
80003ffc:	31 44       	mov	r4,20
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
80003ffe:	4b 13       	lddpc	r3,800040c0 <xcmp_rx_process+0xcc>
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
					break;
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
80004000:	4b 12       	lddpc	r2,800040c4 <xcmp_rx_process+0xd0>
						, ptr);
					break;
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
80004002:	4b 21       	lddpc	r1,800040c8 <xcmp_rx_process+0xd4>
					break;
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
80004004:	4b 20       	lddpc	r0,800040cc <xcmp_rx_process+0xd8>
	xcmp_fragment_t * ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
80004006:	6c 0c       	ld.w	r12,r6[0x0]
80004008:	0a 99       	mov	r9,r5
8000400a:	08 9a       	mov	r10,r4
8000400c:	1a 9b       	mov	r11,sp
8000400e:	f0 1f 00 31 	mcall	800040d0 <xcmp_rx_process+0xdc>
80004012:	58 1c       	cp.w	r12,1
80004014:	cf 91       	brne	80004006 <xcmp_rx_process+0x12>
		{									
			if(NULL == ptr)
80004016:	40 0b       	lddsp	r11,sp[0x0]
80004018:	58 0b       	cp.w	r11,0
8000401a:	cf 60       	breq	80004006 <xcmp_rx_process+0x12>
			
			//log("\n\r R_xcmp : %4x \n\r",ptr->xcmp_opcode);//log:R_xcmp指令	
			//static  portTickType water_value;
			//water_value = uxTaskGetStackHighWaterMark(NULL);
			//log("water_value: %d\n", water_value);			
			switch(ptr->xcmp_opcode & 0x0FFF)
8000401c:	96 0a       	ld.sh	r10,r11[0x0]
8000401e:	f3 da c0 10 	bfextu	r9,r10,0x0,0x10
80004022:	f1 d9 c0 0c 	bfextu	r8,r9,0x0,0xc
80004026:	59 c8       	cp.w	r8,28
80004028:	c1 e0       	breq	80004064 <xcmp_rx_process+0x70>
8000402a:	e0 89 00 07 	brgt	80004038 <xcmp_rx_process+0x44>
8000402e:	58 e8       	cp.w	r8,14
80004030:	c0 e0       	breq	8000404c <xcmp_rx_process+0x58>
80004032:	58 f8       	cp.w	r8,15
80004034:	c2 41       	brne	8000407c <xcmp_rx_process+0x88>
80004036:	c0 f8       	rjmp	80004054 <xcmp_rx_process+0x60>
80004038:	e0 48 01 09 	cp.w	r8,265
8000403c:	c1 80       	breq	8000406c <xcmp_rx_process+0x78>
8000403e:	e0 48 01 0a 	cp.w	r8,266
80004042:	c1 90       	breq	80004074 <xcmp_rx_process+0x80>
80004044:	e0 48 00 2c 	cp.w	r8,44
80004048:	c1 a1       	brne	8000407c <xcmp_rx_process+0x88>
8000404a:	c0 98       	rjmp	8000405c <xcmp_rx_process+0x68>
			{
				case RADIO_STATUS:				
					xcmp_exec_func(&radio_status, ptr);
8000404c:	4a 2c       	lddpc	r12,800040d4 <xcmp_rx_process+0xe0>
8000404e:	f0 1f 00 23 	mcall	800040d8 <xcmp_rx_process+0xe4>
					break;
80004052:	c2 f8       	rjmp	800040b0 <xcmp_rx_process+0xbc>
					
				case VERSION_INFORMATION:
					xcmp_exec_func(&version_information, ptr);
80004054:	4a 2c       	lddpc	r12,800040dc <xcmp_rx_process+0xe8>
80004056:	f0 1f 00 21 	mcall	800040d8 <xcmp_rx_process+0xe4>
					break;
8000405a:	c2 b8       	rjmp	800040b0 <xcmp_rx_process+0xbc>
					
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
8000405c:	4a 1c       	lddpc	r12,800040e0 <xcmp_rx_process+0xec>
8000405e:	f0 1f 00 1f 	mcall	800040d8 <xcmp_rx_process+0xe4>
					break;
80004062:	c2 78       	rjmp	800040b0 <xcmp_rx_process+0xbc>
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
80004064:	04 9c       	mov	r12,r2
80004066:	f0 1f 00 1d 	mcall	800040d8 <xcmp_rx_process+0xe4>
						, ptr);
					break;
8000406a:	c2 38       	rjmp	800040b0 <xcmp_rx_process+0xbc>
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
8000406c:	02 9c       	mov	r12,r1
8000406e:	f0 1f 00 1b 	mcall	800040d8 <xcmp_rx_process+0xe4>
					break;
80004072:	c1 f8       	rjmp	800040b0 <xcmp_rx_process+0xbc>
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
80004074:	00 9c       	mov	r12,r0
80004076:	f0 1f 00 19 	mcall	800040d8 <xcmp_rx_process+0xe4>
					break;
8000407a:	c1 b8       	rjmp	800040b0 <xcmp_rx_process+0xbc>
					
				default:
				
					/*the xcmp message not in order list*/
					/*over the length of the list*/
					if((0x0400 != (ptr->xcmp_opcode & 0x0400)) 
8000407c:	12 98       	mov	r8,r9
8000407e:	e2 18 04 00 	andl	r8,0x400,COH
80004082:	c0 70       	breq	80004090 <xcmp_rx_process+0x9c>
80004084:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
80004088:	e0 48 00 68 	cp.w	r8,104
8000408c:	e0 8a 00 08 	brle	8000409c <xcmp_rx_process+0xa8>
						|| (MAX_APP_FUNC <= (ptr->xcmp_opcode & 0x00FF))
					)
					{
						/*xcmp request*/
						if( XCMP_REQUEST == (ptr->xcmp_opcode & 0xF000))
80004090:	e2 19 f0 00 	andl	r9,0xf000,COH
80004094:	c0 e1       	brne	800040b0 <xcmp_rx_process+0xbc>
						{
							/*send not supported opcode to raido */
							xcmp_opcode_not_supported();
80004096:	f0 1f 00 14 	mcall	800040e4 <xcmp_rx_process+0xf0>
8000409a:	c0 b8       	rjmp	800040b0 <xcmp_rx_process+0xbc>
						}
					}
					else
					{					
						xcmp_exec_func( &app_list[ptr->xcmp_opcode & 0x00FF]
8000409c:	f9 da c0 08 	bfextu	r12,r10,0x0,0x8
800040a0:	f8 0c 00 1c 	add	r12,r12,r12<<0x1
800040a4:	49 19       	lddpc	r9,800040e8 <xcmp_rx_process+0xf4>
800040a6:	72 08       	ld.w	r8,r9[0x0]
800040a8:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800040ac:	f0 1f 00 0b 	mcall	800040d8 <xcmp_rx_process+0xe4>
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
800040b0:	66 0c       	ld.w	r12,r3[0x0]
800040b2:	40 0b       	lddsp	r11,sp[0x0]
800040b4:	f0 1f 00 0e 	mcall	800040ec <xcmp_rx_process+0xf8>
800040b8:	ca 7b       	rjmp	80004006 <xcmp_rx_process+0x12>
800040ba:	00 00       	add	r0,r0
800040bc:	00 00       	add	r0,r0
800040be:	0b 08       	ld.w	r8,r5++
800040c0:	00 00       	add	r0,r0
800040c2:	0a a0       	st.w	r5++,r0
800040c4:	00 00       	add	r0,r0
800040c6:	0b 18       	ld.sh	r8,r5++
800040c8:	00 00       	add	r0,r0
800040ca:	0b 0c       	ld.w	r12,r5++
800040cc:	00 00       	add	r0,r0
800040ce:	0a fc       	st.b	--r5,r12
800040d0:	80 00       	ld.sh	r0,r0[0x0]
800040d2:	5f a8       	srle	r8
800040d4:	00 00       	add	r0,r0
800040d6:	0b 30       	ld.ub	r0,r5++
800040d8:	80 00       	ld.sh	r0,r0[0x0]
800040da:	3e f8       	mov	r8,-17
800040dc:	00 00       	add	r0,r0
800040de:	0a f0       	st.b	--r5,r0
800040e0:	00 00       	add	r0,r0
800040e2:	0b 24       	ld.uh	r4,r5++
800040e4:	80 00       	ld.sh	r0,r0[0x0]
800040e6:	3e d4       	mov	r4,-19
800040e8:	00 00       	add	r0,r0
800040ea:	97 18       	st.w	r11[0x4],r8
800040ec:	80 00       	ld.sh	r0,r0[0x0]
800040ee:	2a d8       	sub	r8,-83

800040f0 <xcmp_rx>:
Calls:   
	xQueueSend -- xnl.c
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
800040f0:	eb cd 40 90 	pushm	r4,r7,lr
800040f4:	20 1d       	sub	sp,4
800040f6:	fa c4 ff f0 	sub	r4,sp,-16
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
800040fa:	48 c8       	lddpc	r8,80004128 <xcmp_rx+0x38>
800040fc:	70 0c       	ld.w	r12,r8[0x0]
800040fe:	f0 1f 00 0c 	mcall	8000412c <xcmp_rx+0x3c>
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
80004102:	c1 00       	breq	80004122 <xcmp_rx+0x32>
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
80004104:	fa c7 ff fc 	sub	r7,sp,-4
80004108:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
	{
		memcpy(xcmp_ptr, &xcmp, sizeof(xcmp_fragment_t));				
8000410a:	e0 6a 00 ca 	mov	r10,202
8000410e:	08 9b       	mov	r11,r4
80004110:	f0 1f 00 08 	mcall	80004130 <xcmp_rx+0x40>
		xQueueSend(xcmp_frame_rx, &xcmp_ptr, 0);	
80004114:	48 88       	lddpc	r8,80004134 <xcmp_rx+0x44>
80004116:	70 0c       	ld.w	r12,r8[0x0]
80004118:	30 09       	mov	r9,0
8000411a:	12 9a       	mov	r10,r9
8000411c:	1a 9b       	mov	r11,sp
8000411e:	f0 1f 00 07 	mcall	80004138 <xcmp_rx+0x48>
	}	
}
80004122:	2f fd       	sub	sp,-4
80004124:	e3 cd 80 90 	ldm	sp++,r4,r7,pc
80004128:	00 00       	add	r0,r0
8000412a:	0a a0       	st.w	r5++,r0
8000412c:	80 00       	ld.sh	r0,r0[0x0]
8000412e:	2c 84       	sub	r4,-56
80004130:	80 00       	ld.sh	r0,r0[0x0]
80004132:	76 68       	ld.w	r8,r11[0x18]
80004134:	00 00       	add	r0,r0
80004136:	0b 08       	ld.w	r8,r5++
80004138:	80 00       	ld.sh	r0,r0[0x0]
8000413a:	61 b4       	ld.w	r4,r0[0x6c]

8000413c <xnl_register_xcmp_func>:
Function: xnl_register_xcmp_func
Description: register the xcmp function(callback function)
*/
void xnl_register_xcmp_func( void ( *func)(xnl_content_data_msg_t))
{
	 xcmp_exec = func;
8000413c:	48 28       	lddpc	r8,80004144 <xnl_register_xcmp_func+0x8>
8000413e:	91 0c       	st.w	r8[0x0],r12
}
80004140:	5e fc       	retal	r12
80004142:	00 00       	add	r0,r0
80004144:	00 00       	add	r0,r0
80004146:	0b 54       	ld.sh	r4,--r5

80004148 <xnl_get_msg_ack_func>:
Description: process while receive msg ack.
Calls:xSemaphoreGive--freertos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
80004148:	d4 01       	pushm	lr
	
	DestinationAddress = xnl->xnl_header.destination;
	/*No timeout*/		
	 //One relationship is controlled by a state machine, only the current MSG received the ACK, 
	//then the program will clear the current MSG sending address and out of standby and will jump to the sending state.
	if (DestinationAddress == xnl_information.device_address )
8000414a:	48 88       	lddpc	r8,80004168 <xnl_get_msg_ack_func+0x20>
8000414c:	90 28       	ld.sh	r8,r8[0x4]
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
	U16 DestinationAddress;
	U16 TransactionID;
	
	DestinationAddress = xnl->xnl_header.destination;
8000414e:	98 49       	ld.sh	r9,r12[0x8]
80004150:	f0 09 19 00 	cp.h	r9,r8
80004154:	c0 81       	brne	80004164 <xnl_get_msg_ack_func+0x1c>
	if (DestinationAddress == xnl_information.device_address )
	{
		//The ack is for me.
		
		TransactionID = xnl->xnl_header.transaction_id;
		xSemaphoreGive(xnl_timeout_semphr);	
80004156:	48 68       	lddpc	r8,8000416c <xnl_get_msg_ack_func+0x24>
80004158:	70 0c       	ld.w	r12,r8[0x0]
8000415a:	30 09       	mov	r9,0
8000415c:	12 9a       	mov	r10,r9
8000415e:	12 9b       	mov	r11,r9
80004160:	f0 1f 00 04 	mcall	80004170 <xnl_get_msg_ack_func+0x28>
80004164:	d8 02       	popm	pc
80004166:	00 00       	add	r0,r0
80004168:	00 00       	add	r0,r0
8000416a:	97 1c       	st.w	r11[0x4],r12
8000416c:	00 00       	add	r0,r0
8000416e:	0b 3c       	ld.ub	r12,r5++
80004170:	80 00       	ld.sh	r0,r0[0x0]
80004172:	61 b4       	ld.w	r4,r0[0x6c]

80004174 <xnl_init>:
	xTaskCreate--freertos
	xnl_send_device_master_query
Called By:xcmp_init -- xcmp.c
*/
void xnl_init(void)
{
80004174:	eb cd 40 e0 	pushm	r5-r7,lr
	
	xnl_information.is_connected = FALSE;
80004178:	30 09       	mov	r9,0
8000417a:	4b 78       	lddpc	r8,80004254 <xnl_init+0xe0>
8000417c:	b0 89       	st.b	r8[0x0],r9

	/*initialize the semaphore and queue*/
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
8000417e:	30 0b       	mov	r11,0
80004180:	30 1c       	mov	r12,1
80004182:	f0 1f 00 36 	mcall	80004258 <xnl_init+0xe4>
80004186:	4b 68       	lddpc	r8,8000425c <xnl_init+0xe8>
80004188:	91 0c       	st.w	r8[0x0],r12
8000418a:	70 08       	ld.w	r8,r8[0x0]
8000418c:	58 08       	cp.w	r8,0
8000418e:	c0 80       	breq	8000419e <xnl_init+0x2a>
80004190:	4b 38       	lddpc	r8,8000425c <xnl_init+0xe8>
80004192:	70 0c       	ld.w	r12,r8[0x0]
80004194:	30 09       	mov	r9,0
80004196:	12 9a       	mov	r10,r9
80004198:	12 9b       	mov	r11,r9
8000419a:	f0 1f 00 32 	mcall	80004260 <xnl_init+0xec>
	
	xnl_frame_tx = xQueueCreate(50, sizeof(xnl_fragment_t *)); //扩大xnl_frame_tx的队列深度
8000419e:	30 4b       	mov	r11,4
800041a0:	33 2c       	mov	r12,50
800041a2:	f0 1f 00 2e 	mcall	80004258 <xnl_init+0xe4>
800041a6:	4b 08       	lddpc	r8,80004264 <xnl_init+0xf0>
800041a8:	91 0c       	st.w	r8[0x0],r12
		
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
800041aa:	30 4b       	mov	r11,4
800041ac:	36 4c       	mov	r12,100
800041ae:	f0 1f 00 2b 	mcall	80004258 <xnl_init+0xe4>
800041b2:	4a e8       	lddpc	r8,80004268 <xnl_init+0xf4>
800041b4:	91 0c       	st.w	r8[0x0],r12
800041b6:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_XNL_STORE; i++ )
	{
		set_xnl_idle(&xnl_store[i]);
800041b8:	10 96       	mov	r6,r8
800041ba:	4a d5       	lddpc	r5,8000426c <xnl_init+0xf8>
800041bc:	6c 0c       	ld.w	r12,r6[0x0]
800041be:	ea 07 00 0b 	add	r11,r5,r7
800041c2:	f0 1f 00 2c 	mcall	80004270 <xnl_init+0xfc>
800041c6:	ee c7 ff 00 	sub	r7,r7,-256
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
	
	xnl_frame_tx = xQueueCreate(50, sizeof(xnl_fragment_t *)); //扩大xnl_frame_tx的队列深度
		
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
	for(int i= 0; i < MAX_XNL_STORE; i++ )
800041ca:	e0 47 64 00 	cp.w	r7,25600
800041ce:	cf 71       	brne	800041bc <xnl_init+0x48>
	{
		set_xnl_idle(&xnl_store[i]);
	}
	
	/*initialize the queue to send/receive xnl packet */
	phy_xnl_frame_tx = xQueueCreate(TX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
800041d0:	30 4b       	mov	r11,4
800041d2:	31 4c       	mov	r12,20
800041d4:	f0 1f 00 21 	mcall	80004258 <xnl_init+0xe4>
800041d8:	4a 78       	lddpc	r8,80004274 <xnl_init+0x100>
800041da:	91 0c       	st.w	r8[0x0],r12
	phy_xnl_frame_rx = xQueueCreate(RX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
800041dc:	30 4b       	mov	r11,4
800041de:	31 4c       	mov	r12,20
800041e0:	f0 1f 00 1e 	mcall	80004258 <xnl_init+0xe4>
800041e4:	4a 58       	lddpc	r8,80004278 <xnl_init+0x104>
800041e6:	91 0c       	st.w	r8[0x0],r12
	
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
800041e8:	30 4b       	mov	r11,4
800041ea:	30 ac       	mov	r12,10
800041ec:	f0 1f 00 1b 	mcall	80004258 <xnl_init+0xe4>
800041f0:	4a 38       	lddpc	r8,8000427c <xnl_init+0x108>
800041f2:	91 0c       	st.w	r8[0x0],r12
800041f4:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
	{
		set_payload_idle(payload_store[i]);
800041f6:	10 96       	mov	r6,r8
800041f8:	4a 25       	lddpc	r5,80004280 <xnl_init+0x10c>
800041fa:	6c 0c       	ld.w	r12,r6[0x0]
800041fc:	ea 07 00 0b 	add	r11,r5,r7
80004200:	f0 1f 00 1c 	mcall	80004270 <xnl_init+0xfc>
80004204:	ee c7 fe 00 	sub	r7,r7,-512
	
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
80004208:	e0 47 14 00 	cp.w	r7,5120
8000420c:	cf 71       	brne	800041fa <xnl_init+0x86>
	
	/*initialize the queue to send/receive payload packet */
	//phy_payload_frame_tx =
	//xQueueCreate(TX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t));
	
	phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
8000420e:	30 4b       	mov	r11,4
80004210:	30 5c       	mov	r12,5
80004212:	f0 1f 00 12 	mcall	80004258 <xnl_init+0xe4>
80004216:	49 c8       	lddpc	r8,80004284 <xnl_init+0x110>
80004218:	91 0c       	st.w	r8[0x0],r12
	
	#endif /*end if*/
		
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
8000421a:	30 07       	mov	r7,0
8000421c:	1a d7       	st.w	--sp,r7
8000421e:	1a d7       	st.w	--sp,r7
80004220:	1a d7       	st.w	--sp,r7
80004222:	30 38       	mov	r8,3
80004224:	0e 99       	mov	r9,r7
80004226:	e0 6a 02 00 	mov	r10,512
8000422a:	49 8b       	lddpc	r11,80004288 <xnl_init+0x114>
8000422c:	49 8c       	lddpc	r12,8000428c <xnl_init+0x118>
8000422e:	f0 1f 00 19 	mcall	80004290 <xnl_init+0x11c>
	,  tskXNL_PRIORITY //+ 1
	,  NULL
	);
	
	/*this task is used to send xnl message*/
	xTaskCreate(
80004232:	1a d7       	st.w	--sp,r7
80004234:	1a d7       	st.w	--sp,r7
80004236:	1a d7       	st.w	--sp,r7
80004238:	30 38       	mov	r8,3
8000423a:	0e 99       	mov	r9,r7
8000423c:	e0 6a 00 82 	mov	r10,130
80004240:	49 5b       	lddpc	r11,80004294 <xnl_init+0x120>
80004242:	49 6c       	lddpc	r12,80004298 <xnl_init+0x124>
80004244:	f0 1f 00 13 	mcall	80004290 <xnl_init+0x11c>
	,  tskXNL_PRIORITY//+1
	,  NULL
	);
	
	/*initialize the physical layer*/
	phy_init();
80004248:	f0 1f 00 15 	mcall	8000429c <xnl_init+0x128>
8000424c:	2f ad       	sub	sp,-24
}
8000424e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80004252:	00 00       	add	r0,r0
80004254:	00 00       	add	r0,r0
80004256:	97 1c       	st.w	r11[0x4],r12
80004258:	80 00       	ld.sh	r0,r0[0x0]
8000425a:	63 0c       	ld.w	r12,r1[0x40]
8000425c:	00 00       	add	r0,r0
8000425e:	0b 3c       	ld.ub	r12,r5++
80004260:	80 00       	ld.sh	r0,r0[0x0]
80004262:	61 b4       	ld.w	r4,r0[0x6c]
80004264:	00 00       	add	r0,r0
80004266:	0b 48       	ld.w	r8,--r5
80004268:	00 00       	add	r0,r0
8000426a:	0a a0       	st.w	r5++,r0
8000426c:	00 00       	add	r0,r0
8000426e:	32 ca       	mov	r10,44
80004270:	80 00       	ld.sh	r0,r0[0x0]
80004272:	2a d8       	sub	r8,-83
80004274:	00 00       	add	r0,r0
80004276:	0a d0       	st.w	--r5,r0
80004278:	00 00       	add	r0,r0
8000427a:	0a b0       	st.h	r5++,r0
8000427c:	00 00       	add	r0,r0
8000427e:	0a a4       	st.w	r5++,r4
80004280:	00 00       	add	r0,r0
80004282:	1e ca       	st.b	pc++,r10
80004284:	00 00       	add	r0,r0
80004286:	0a dc       	st.w	--r5,r12
80004288:	80 00       	ld.sh	r0,r0[0x0]
8000428a:	d6 14       	*unknown*
8000428c:	80 00       	ld.sh	r0,r0[0x0]
8000428e:	42 a0       	lddsp	r0,sp[0xa8]
80004290:	80 00       	ld.sh	r0,r0[0x0]
80004292:	6a 28       	ld.w	r8,r5[0x8]
80004294:	80 00       	ld.sh	r0,r0[0x0]
80004296:	d6 1c       	*unknown*
80004298:	80 00       	ld.sh	r0,r0[0x0]
8000429a:	43 00       	lddsp	r0,sp[0xc0]
8000429c:	80 00       	ld.sh	r0,r0[0x0]
8000429e:	2c ac       	sub	r12,-54

800042a0 <xnl_rx_process>:
Calls: 
Called By:task
*/
//portTickType water_value =0;
static void xnl_rx_process(void * pvParameters)
{
800042a0:	eb cd 40 fe 	pushm	r1-r7,lr
800042a4:	20 1d       	sub	sp,4
	xnl_fragment_t * xnl_ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
800042a6:	49 26       	lddpc	r6,800042ec <xnl_rx_process+0x4c>
800042a8:	30 05       	mov	r5,0
800042aa:	3f f4       	mov	r4,-1
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
800042ac:	30 c3       	mov	r3,12
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
800042ae:	49 11       	lddpc	r1,800042f0 <xnl_rx_process+0x50>
	if(xnl->xnl_header.opcode > 0x0C)	
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
800042b0:	49 12       	lddpc	r2,800042f4 <xnl_rx_process+0x54>
	xnl_fragment_t * xnl_ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
800042b2:	6c 0c       	ld.w	r12,r6[0x0]
800042b4:	0a 99       	mov	r9,r5
800042b6:	08 9a       	mov	r10,r4
800042b8:	1a 9b       	mov	r11,sp
800042ba:	f0 1f 00 10 	mcall	800042f8 <xnl_rx_process+0x58>
800042be:	58 1c       	cp.w	r12,1
800042c0:	cf 91       	brne	800042b2 <xnl_rx_process+0x12>
		, portMAX_DELAY ))
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
800042c2:	40 0c       	lddsp	r12,sp[0x0]
800042c4:	58 0c       	cp.w	r12,0
800042c6:	cf 60       	breq	800042b2 <xnl_rx_process+0x12>
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
800042c8:	98 28       	ld.sh	r8,r12[0x4]
800042ca:	e6 08 19 00 	cp.h	r8,r3
800042ce:	e0 8b 00 0a 	brhi	800042e2 <xnl_rx_process+0x42>
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
800042d2:	5c 78       	castu.h	r8
800042d4:	e4 08 03 29 	ld.w	r9,r2[r8<<0x2]
800042d8:	58 09       	cp.w	r9,0
800042da:	c0 40       	breq	800042e2 <xnl_rx_process+0x42>
	{
		//log("\n\r R_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:R_xnl指令
		/*execute the function in list*/
		xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec(xnl);
800042dc:	e4 08 03 28 	ld.w	r8,r2[r8<<0x2]
800042e0:	5d 18       	icall	r8
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
800042e2:	62 0c       	ld.w	r12,r1[0x0]
800042e4:	40 0b       	lddsp	r11,sp[0x0]
800042e6:	f0 1f 00 06 	mcall	800042fc <xnl_rx_process+0x5c>
800042ea:	ce 4b       	rjmp	800042b2 <xnl_rx_process+0x12>
800042ec:	00 00       	add	r0,r0
800042ee:	0a b0       	st.h	r5++,r0
800042f0:	00 00       	add	r0,r0
800042f2:	0a a0       	st.w	r5++,r0
800042f4:	00 00       	add	r0,r0
800042f6:	04 f4       	st.b	--r2,r4
800042f8:	80 00       	ld.sh	r0,r0[0x0]
800042fa:	5f a8       	srle	r8
800042fc:	80 00       	ld.sh	r0,r0[0x0]
800042fe:	2a d8       	sub	r8,-83

80004300 <xnl_tx_process>:
	phy_tx -- physical.c
Called By: task
*/
//portTickType tx_water_value =0;
static void xnl_tx_process(void * pvParameters)
{
80004300:	d4 31       	pushm	r0-r7,lr
	
	
	for(;;)
	{		
		//tx_water_value = uxTaskGetStackHighWaterMark(NULL);
		switch(xnl_tx_state)
80004302:	4a a6       	lddpc	r6,800043a8 <xnl_tx_process+0xa8>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
80004304:	4a a2       	lddpc	r2,800043ac <xnl_tx_process+0xac>
80004306:	4a b4       	lddpc	r4,800043b0 <xnl_tx_process+0xb0>
80004308:	30 07       	mov	r7,0
8000430a:	3f f1       	mov	r1,-1
					if(NULL == ptr)
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
8000430c:	30 00       	mov	r0,0
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;				
8000430e:	4a a5       	lddpc	r5,800043b4 <xnl_tx_process+0xb4>
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
80004310:	4a a3       	lddpc	r3,800043b8 <xnl_tx_process+0xb8>
	
	
	for(;;)
	{		
		//tx_water_value = uxTaskGetStackHighWaterMark(NULL);
		switch(xnl_tx_state)
80004312:	6c 08       	ld.w	r8,r6[0x0]
80004314:	58 08       	cp.w	r8,0
80004316:	c0 40       	breq	8000431e <xnl_tx_process+0x1e>
80004318:	58 18       	cp.w	r8,1
8000431a:	cf d1       	brne	80004314 <xnl_tx_process+0x14>
8000431c:	c2 48       	rjmp	80004364 <xnl_tx_process+0x64>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
8000431e:	64 0c       	ld.w	r12,r2[0x0]
80004320:	0e 99       	mov	r9,r7
80004322:	02 9a       	mov	r10,r1
80004324:	08 9b       	mov	r11,r4
80004326:	f0 1f 00 26 	mcall	800043bc <xnl_tx_process+0xbc>
8000432a:	58 1c       	cp.w	r12,1
8000432c:	cf 31       	brne	80004312 <xnl_tx_process+0x12>
					, portMAX_DELAY ))
				{				
					if(NULL == ptr)
8000432e:	68 0b       	ld.w	r11,r4[0x0]
80004330:	58 0b       	cp.w	r11,0
80004332:	cf 00       	breq	80004312 <xnl_tx_process+0x12>
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
80004334:	96 28       	ld.sh	r8,r11[0x4]
80004336:	e0 08 19 00 	cp.h	r8,r0
8000433a:	c0 71       	brne	80004348 <xnl_tx_process+0x48>
					{
						/*invalid XNL opcode*/
						set_xnl_idle(ptr);
8000433c:	4a 18       	lddpc	r8,800043c0 <xnl_tx_process+0xc0>
8000433e:	70 08       	ld.w	r8,r8[0x0]
80004340:	10 9c       	mov	r12,r8
80004342:	f0 1f 00 21 	mcall	800043c4 <xnl_tx_process+0xc4>
						break;
80004346:	ce 6b       	rjmp	80004312 <xnl_tx_process+0x12>
					}
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
80004348:	16 9c       	mov	r12,r11
8000434a:	f0 1f 00 20 	mcall	800043c8 <xnl_tx_process+0xc8>
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;				
8000434e:	30 18       	mov	r8,1
80004350:	8b 08       	st.w	r5[0x0],r8
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
80004352:	66 0c       	ld.w	r12,r3[0x0]
80004354:	0e 99       	mov	r9,r7
80004356:	0e 9a       	mov	r10,r7
80004358:	0e 9b       	mov	r11,r7
8000435a:	f0 1f 00 19 	mcall	800043bc <xnl_tx_process+0xbc>
					xnl_tx_state = WAITING_FOR_REPLY;
8000435e:	30 18       	mov	r8,1
80004360:	8d 08       	st.w	r6[0x0],r8
80004362:	cd 8b       	rjmp	80004312 <xnl_tx_process+0x12>
				}
				break;
			
			/*wait XNL reply*/			
			case WAITING_FOR_REPLY://直到回答ACK才再发送下一条data/control
				if(pdTRUE == xSemaphoreTake( xnl_timeout_semphr
80004364:	66 0c       	ld.w	r12,r3[0x0]
80004366:	0e 99       	mov	r9,r7
80004368:	36 4a       	mov	r10,100
8000436a:	0e 9b       	mov	r11,r7
8000436c:	f0 1f 00 14 	mcall	800043bc <xnl_tx_process+0xbc>
80004370:	58 1c       	cp.w	r12,1
80004372:	c0 81       	brne	80004382 <xnl_tx_process+0x82>
					, ( portTickType )50*2/ portTICK_RATE_MS))//按ADK文档中提示500ms一次超时,但是实际情况下程序中启用freertos的任务延时不够精准。因此根据经验需要降低延时等待的时间
				{
					/*No timeout*/
					set_xnl_idle(ptr);			
80004374:	49 38       	lddpc	r8,800043c0 <xnl_tx_process+0xc0>
80004376:	70 0c       	ld.w	r12,r8[0x0]
80004378:	68 0b       	ld.w	r11,r4[0x0]
8000437a:	f0 1f 00 13 	mcall	800043c4 <xnl_tx_process+0xc4>
					xnl_tx_state = WAITING_FOR_TX;
8000437e:	8d 07       	st.w	r6[0x0],r7
80004380:	cc 9b       	rjmp	80004312 <xnl_tx_process+0x12>
				}
				else
				{
					/*time out*/
					if(xnl_send_times <= MIN_RESEND_TIMES)
80004382:	6a 08       	ld.w	r8,r5[0x0]
80004384:	58 38       	cp.w	r8,3
80004386:	e0 89 00 09 	brgt	80004398 <xnl_tx_process+0x98>
					{
						/*If times smaller than A supermarket, then resend the 
						instructions*/
						phy_tx((phy_fragment_t *)ptr);
8000438a:	68 0c       	ld.w	r12,r4[0x0]
8000438c:	f0 1f 00 0f 	mcall	800043c8 <xnl_tx_process+0xc8>
						xnl_send_times++;
80004390:	6a 08       	ld.w	r8,r5[0x0]
80004392:	2f f8       	sub	r8,-1
80004394:	8b 08       	st.w	r5[0x0],r8
80004396:	cb eb       	rjmp	80004312 <xnl_tx_process+0x12>
					}
					else
					{
						//can not send data, disconnected						
						//vPortFree(ptr);	
						set_xnl_idle(ptr);									
80004398:	48 a8       	lddpc	r8,800043c0 <xnl_tx_process+0xc0>
8000439a:	70 0c       	ld.w	r12,r8[0x0]
8000439c:	68 0b       	ld.w	r11,r4[0x0]
8000439e:	f0 1f 00 0a 	mcall	800043c4 <xnl_tx_process+0xc4>
						xnl_tx_state = WAITING_FOR_TX;
800043a2:	8d 07       	st.w	r6[0x0],r7
800043a4:	cb 7b       	rjmp	80004312 <xnl_tx_process+0x12>
800043a6:	00 00       	add	r0,r0
800043a8:	00 00       	add	r0,r0
800043aa:	0b 44       	ld.w	r4,--r5
800043ac:	00 00       	add	r0,r0
800043ae:	0b 48       	ld.w	r8,--r5
800043b0:	00 00       	add	r0,r0
800043b2:	0b 50       	ld.sh	r0,--r5
800043b4:	00 00       	add	r0,r0
800043b6:	0b 4c       	ld.w	r12,--r5
800043b8:	00 00       	add	r0,r0
800043ba:	0b 3c       	ld.ub	r12,r5++
800043bc:	80 00       	ld.sh	r0,r0[0x0]
800043be:	5f a8       	srle	r8
800043c0:	00 00       	add	r0,r0
800043c2:	0a a0       	st.w	r5++,r0
800043c4:	80 00       	ld.sh	r0,r0[0x0]
800043c6:	2a d8       	sub	r8,-83
800043c8:	80 00       	ld.sh	r0,r0[0x0]
800043ca:	2a f8       	sub	r8,-81

800043cc <xnl_tx>:
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
{
800043cc:	eb cd 40 c0 	pushm	r6-r7,lr
800043d0:	20 1d       	sub	sp,4
800043d2:	18 96       	mov	r6,r12
	message that is sent. The same value should be used for all retries.
	*/
	static U8 flags = 0;
	
	/*If the value is DEFAULT_VALUE, the value will be modified*/
	if(DEFAULT_VALUE == xnl->xnl_header.flags)
800043d4:	98 39       	ld.sh	r9,r12[0x6]
800043d6:	3f f8       	mov	r8,-1
800043d8:	f0 09 19 00 	cp.h	r9,r8
800043dc:	c0 a1       	brne	800043f0 <xnl_tx+0x24>
	{
		xnl->xnl_header.flags =  0x0100 | ((++flags) & 0x07);
800043de:	4a e9       	lddpc	r9,80004494 <xnl_tx+0xc8>
800043e0:	13 88       	ld.ub	r8,r9[0x0]
800043e2:	2f f8       	sub	r8,-1
800043e4:	5c 58       	castu.b	r8
800043e6:	b2 88       	st.b	r9[0x0],r8
800043e8:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
800043ec:	a9 a8       	sbr	r8,0x8
800043ee:	b8 38       	st.h	r12[0x6],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.destination)
800043f0:	8c 49       	ld.sh	r9,r6[0x8]
800043f2:	3f f8       	mov	r8,-1
800043f4:	f0 09 19 00 	cp.h	r9,r8
800043f8:	c0 41       	brne	80004400 <xnl_tx+0x34>
	{		
		/*Use actual Master address.*/
		xnl->xnl_header.destination = xnl_information.master_address;
800043fa:	4a 88       	lddpc	r8,80004498 <xnl_tx+0xcc>
800043fc:	90 18       	ld.sh	r8,r8[0x2]
800043fe:	ac 48       	st.h	r6[0x8],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.source)
80004400:	8c 59       	ld.sh	r9,r6[0xa]
80004402:	3f f8       	mov	r8,-1
80004404:	f0 09 19 00 	cp.h	r9,r8
80004408:	c0 41       	brne	80004410 <xnl_tx+0x44>
	{
		/*Use Temporary address.*/	
		xnl->xnl_header.source = xnl_information.device_address;
8000440a:	4a 48       	lddpc	r8,80004498 <xnl_tx+0xcc>
8000440c:	90 28       	ld.sh	r8,r8[0x4]
8000440e:	ac 58       	st.h	r6[0xa],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
80004410:	8c 69       	ld.sh	r9,r6[0xc]
80004412:	3f f8       	mov	r8,-1
80004414:	f0 09 19 00 	cp.h	r9,r8
80004418:	c0 e1       	brne	80004434 <xnl_tx+0x68>
	{		
		xnl->xnl_header.transaction_id = 
		  ((++xnl_information.transaction_id) & 0xFF) 
8000441a:	4a 08       	lddpc	r8,80004498 <xnl_tx+0xcc>
8000441c:	90 49       	ld.sh	r9,r8[0x8]
8000441e:	2f f9       	sub	r9,-1
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
80004420:	b0 49       	st.h	r8[0x8],r9
		  ((++xnl_information.transaction_id) & 0xFF) 
80004422:	90 4a       	ld.sh	r10,r8[0x8]
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
80004424:	90 49       	ld.sh	r9,r8[0x8]
80004426:	e0 19 ff 00 	andl	r9,0xff00
8000442a:	f1 da c0 08 	bfextu	r8,r10,0x0,0x8
8000442e:	f3 e8 10 08 	or	r8,r9,r8
80004432:	ac 68       	st.h	r6[0xc],r8
	U16  sumScratch;
	U32  indextohWord;
	S32  hWordswithinFrag;
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
80004434:	0d 98       	ld.ub	r8,r6[0x1]
80004436:	20 28       	sub	r8,2
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
80004438:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
8000443c:	10 0c       	add	r12,r8
8000443e:	a1 5c       	asr	r12,0x1
	indextohWord = 2;
	while (hWordswithinFrag > 0)
80004440:	58 0c       	cp.w	r12,0
80004442:	e0 89 00 04 	brgt	8000444a <xnl_tx+0x7e>
80004446:	30 09       	mov	r9,0
80004448:	c0 d8       	rjmp	80004462 <xnl_tx+0x96>
8000444a:	ec ca ff fc 	sub	r10,r6,-4
Parameters: xnl_fragment_t * 
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
8000444e:	2f ec       	sub	r12,-2
80004450:	30 09       	mov	r9,0
80004452:	30 28       	mov	r8,2
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
	{
		sumScratch += *((U16*)xnl + indextohWord);
80004454:	15 1b       	ld.sh	r11,r10++
80004456:	f6 09 00 09 	add	r9,r11,r9
8000445a:	5c 89       	casts.h	r9
		indextohWord     += 1;
8000445c:	2f f8       	sub	r8,-1
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
8000445e:	18 38       	cp.w	r8,r12
80004460:	cf a1       	brne	80004454 <xnl_tx+0x88>
		  ((++xnl_information.transaction_id) & 0xFF) 
		| (xnl_information.transaction_id & 0xFF00);
	}
	
	/*count check sum */
	xnl->phy_header.check_sum = check_sum( xnl );
80004462:	5c 39       	neg	r9
80004464:	ac 19       	st.h	r6[0x2],r9
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
80004466:	48 e8       	lddpc	r8,8000449c <xnl_tx+0xd0>
80004468:	70 0c       	ld.w	r12,r8[0x0]
8000446a:	f0 1f 00 0e 	mcall	800044a0 <xnl_tx+0xd4>
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
8000446e:	c1 00       	breq	8000448e <xnl_tx+0xc2>
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
80004470:	fa c7 ff fc 	sub	r7,sp,-4
80004474:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
	{
		memcpy(ptr, xnl, sizeof(xnl_fragment_t));
80004476:	e0 6a 01 00 	mov	r10,256
8000447a:	0c 9b       	mov	r11,r6
8000447c:	f0 1f 00 0a 	mcall	800044a4 <xnl_tx+0xd8>
	
		/*push to queue and send*/
		
		//log("ptr -%8x", ptr);
		
		xQueueSend(xnl_frame_tx, &ptr, 0);
80004480:	48 a8       	lddpc	r8,800044a8 <xnl_tx+0xdc>
80004482:	70 0c       	ld.w	r12,r8[0x0]
80004484:	30 09       	mov	r9,0
80004486:	12 9a       	mov	r10,r9
80004488:	1a 9b       	mov	r11,sp
8000448a:	f0 1f 00 09 	mcall	800044ac <xnl_tx+0xe0>
		//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
		
		//vPortFree(ptr);
	}
}
8000448e:	2f fd       	sub	sp,-4
80004490:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004494:	00 00       	add	r0,r0
80004496:	0b 40       	ld.w	r0,--r5
80004498:	00 00       	add	r0,r0
8000449a:	97 1c       	st.w	r11[0x4],r12
8000449c:	00 00       	add	r0,r0
8000449e:	0a a0       	st.w	r5++,r0
800044a0:	80 00       	ld.sh	r0,r0[0x0]
800044a2:	2c 84       	sub	r4,-56
800044a4:	80 00       	ld.sh	r0,r0[0x0]
800044a6:	76 68       	ld.w	r8,r11[0x18]
800044a8:	00 00       	add	r0,r0
800044aa:	0b 48       	ld.w	r8,--r5
800044ac:	80 00       	ld.sh	r0,r0[0x0]
800044ae:	61 b4       	ld.w	r4,r0[0x6c]

800044b0 <xnl_data_msg_func>:
Description: process while receive data message.
Calls:xnl_send_msg_ack, xcmp_exec(function in xcmp)
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_data_msg_func(xnl_fragment_t * xnl)
{
800044b0:	eb cd 40 80 	pushm	r7,lr
800044b4:	fa cd 01 00 	sub	sp,sp,256
800044b8:	18 97       	mov	r7,r12
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
800044ba:	e0 68 40 0e 	mov	r8,16398
800044be:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
800044c0:	3f f8       	mov	r8,-1
800044c2:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG_ACK;
800044c4:	30 c8       	mov	r8,12
800044c6:	ba 28       	st.h	sp[0x4],r8
	
	/*Turn around Flags.*/	
	xnl_frame.xnl_header.flags = hdr->flags;
800044c8:	98 38       	ld.sh	r8,r12[0x6]
800044ca:	ba 38       	st.h	sp[0x6],r8
	
	/*ACK Destination Address is Source of XNL_Message.*/
	xnl_frame.xnl_header.destination = hdr->source;
800044cc:	98 58       	ld.sh	r8,r12[0xa]
800044ce:	ba 48       	st.h	sp[0x8],r8
	
	/*ACK Source Address is my address.*/
	xnl_frame.xnl_header.source = hdr->destination;
800044d0:	98 48       	ld.sh	r8,r12[0x8]
800044d2:	ba 58       	st.h	sp[0xa],r8
	
	/*Turn around Transaction ID.*/
	xnl_frame.xnl_header.transaction_id = hdr->transaction_id;
800044d4:	98 68       	ld.sh	r8,r12[0xc]
800044d6:	ba 68       	st.h	sp[0xc],r8
	xnl_frame.xnl_header.payload_length = 0;
800044d8:	30 08       	mov	r8,0
800044da:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
800044dc:	1a 9c       	mov	r12,sp
800044de:	f0 1f 00 0a 	mcall	80004504 <xnl_data_msg_func+0x54>
	transmitter, but possibly is waiting in Queue with immediate timeout.
	 */
	xnl_send_msg_ack(&xnl->xnl_header);
	
	/*exec xcmp function*/
	xcmp_exec(xnl->xnl_payload.xnl_content_data_msg);//xcmp_rx
800044e2:	fa cd 00 cc 	sub	sp,sp,204
800044e6:	e0 6a 00 ca 	mov	r10,202
800044ea:	ee cb ff f0 	sub	r11,r7,-16
800044ee:	1a 9c       	mov	r12,sp
800044f0:	f0 1f 00 06 	mcall	80004508 <xnl_data_msg_func+0x58>
800044f4:	48 68       	lddpc	r8,8000450c <xnl_data_msg_func+0x5c>
800044f6:	70 08       	ld.w	r8,r8[0x0]
800044f8:	5d 18       	icall	r8
800044fa:	fa cd ff 34 	sub	sp,sp,-204
}
800044fe:	2c 0d       	sub	sp,-256
80004500:	e3 cd 80 80 	ldm	sp++,r7,pc
80004504:	80 00       	ld.sh	r0,r0[0x0]
80004506:	43 cc       	lddsp	r12,sp[0xf0]
80004508:	80 00       	ld.sh	r0,r0[0x0]
8000450a:	76 68       	ld.w	r8,r11[0x18]
8000450c:	00 00       	add	r0,r0
8000450e:	0b 54       	ld.sh	r4,--r5

80004510 <xnl_device_auth_reply_func>:
Description: process while receive device auth reply.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_auth_reply_func(xnl_fragment_t * xnl)
{
80004510:	d4 21       	pushm	r4-r7,lr
80004512:	fa cd 01 00 	sub	sp,sp,256
80004516:	18 97       	mov	r7,r12
	the receiving device and will be used to authenticate the connection 
	request. 5.4.4
	*/
	//log("R_xnl-opcode:%4x", xnl->xnl_header.opcode);
	
	if(xnl_information.is_connected)
80004518:	4c 28       	lddpc	r8,80004620 <xnl_device_auth_reply_func+0x110>
8000451a:	11 88       	ld.ub	r8,r8[0x0]
8000451c:	58 08       	cp.w	r8,0
8000451e:	e0 81 00 7f 	brne	8000461c <xnl_device_auth_reply_func+0x10c>
	{
		return;		
	}
	
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);
80004522:	4c 18       	lddpc	r8,80004624 <xnl_device_auth_reply_func+0x114>
80004524:	70 0c       	ld.w	r12,r8[0x0]
80004526:	30 09       	mov	r9,0
80004528:	12 9a       	mov	r10,r9
8000452a:	12 9b       	mov	r11,r9
8000452c:	f0 1f 00 3f 	mcall	80004628 <xnl_device_auth_reply_func+0x118>

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
80004530:	ef 09 00 10 	ld.sh	r9,r7[16]
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
80004534:	4b b8       	lddpc	r8,80004620 <xnl_device_auth_reply_func+0x110>
80004536:	b0 29       	st.h	r8[0x4],r9
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
	
	/*Get Array of values to be encrypted into an aligned 2X32bits.*/
	v_vector[0] =
80004538:	ef 39 00 12 	ld.ub	r9,r7[18]
8000453c:	ef 38 00 13 	ld.ub	r8,r7[19]
80004540:	b1 68       	lsl	r8,0x10
80004542:	f1 e9 11 89 	or	r9,r8,r9<<0x18
80004546:	ef 38 00 15 	ld.ub	r8,r7[21]
8000454a:	f3 e8 10 08 	or	r8,r9,r8
8000454e:	ef 39 00 14 	ld.ub	r9,r7[20]
80004552:	f1 e9 10 89 	or	r9,r8,r9<<0x8
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[2])<<8	  
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[3]);
	
	v_vector[1] =
80004556:	ef 3a 00 16 	ld.ub	r10,r7[22]
8000455a:	ef 38 00 17 	ld.ub	r8,r7[23]
8000455e:	b1 68       	lsl	r8,0x10
80004560:	f1 ea 11 8a 	or	r10,r8,r10<<0x18
80004564:	ef 38 00 19 	ld.ub	r8,r7[25]
80004568:	f5 e8 10 08 	or	r8,r10,r8
8000456c:	ef 3a 00 18 	ld.ub	r10,r7[24]
80004570:	f1 ea 10 88 	or	r8,r8,r10<<0x8
80004574:	30 0a       	mov	r10,0
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
80004576:	e0 64 79 b9 	mov	r4,31161
8000457a:	ea 14 9e 37 	orh	r4,0x9e37
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
8000457e:	e0 65 45 07 	mov	r5,17671
80004582:	ea 15 8a bd 	orh	r5,0x8abd
80004586:	e0 66 f9 3d 	mov	r6,63805
8000458a:	ea 16 99 68 	orh	r6,0x9968
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
8000458e:	e0 6e b8 cf 	mov	lr,47311
80004592:	ea 1e 36 83 	orh	lr,0x3683
80004596:	e0 67 aa 1c 	mov	r7,43548
8000459a:	ea 17 9c 36 	orh	r7,0x9c36
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
8000459e:	08 0a       	add	r10,r4
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
800045a0:	f4 08 00 0c 	add	r12,r10,r8
800045a4:	f0 0b 15 04 	lsl	r11,r8,0x4
800045a8:	0a 0b       	add	r11,r5
800045aa:	f9 eb 20 0b 	eor	r11,r12,r11
800045ae:	f0 0c 16 05 	lsr	r12,r8,0x5
800045b2:	0c 0c       	add	r12,r6
800045b4:	18 5b       	eor	r11,r12
800045b6:	16 09       	add	r9,r11
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
800045b8:	f2 0c 15 04 	lsl	r12,r9,0x4
800045bc:	1c 0c       	add	r12,lr
800045be:	f2 0b 16 05 	lsr	r11,r9,0x5
800045c2:	0e 0b       	add	r11,r7
800045c4:	f9 eb 20 0b 	eor	r11,r12,r11
800045c8:	f2 0a 00 0c 	add	r12,r9,r10
800045cc:	18 5b       	eor	r11,r12
800045ce:	16 08       	add	r8,r11
{
	register U32 y=v[0], z=v[1], sum=0;
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
800045d0:	e0 6b 37 20 	mov	r11,14112
800045d4:	ea 1b c6 ef 	orh	r11,0xc6ef
800045d8:	16 3a       	cp.w	r10,r11
800045da:	ce 21       	brne	8000459e <xnl_device_auth_reply_func+0x8e>
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :24 + 2(xnl length(24) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 24 + 2;
800045dc:	e0 6a 40 1a 	mov	r10,16410
800045e0:	ba 0a       	st.h	sp[0x0],r10
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
800045e2:	3f fa       	mov	r10,-1
800045e4:	ba 1a       	st.h	sp[0x2],r10
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_CONN_REQUEST;
800045e6:	30 6b       	mov	r11,6
800045e8:	ba 2b       	st.h	sp[0x4],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
800045ea:	ba 3a       	st.h	sp[0x6],r10
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
800045ec:	48 db       	lddpc	r11,80004620 <xnl_device_auth_reply_func+0x110>
800045ee:	96 1c       	ld.sh	r12,r11[0x2]
800045f0:	ba 4c       	st.h	sp[0x8],r12
	message here, and all will receive the same DEVICE_CONN_REPLY. Not real 
	sure what's going to happen with multiple conrol heads, etc. One suspects 
	the Rocket Scientists will eventually figure this out, and demand a 
	transaction ID based on Device Type in the XNL_DEVICE_AUTH_KEY_REQUEST.
	*/
	xnl_frame.xnl_header.source = xnl_information.device_address;
800045f2:	96 2b       	ld.sh	r11,r11[0x4]
800045f4:	ba 5b       	st.h	sp[0xa],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
800045f6:	ba 6a       	st.h	sp[0xc],r10
	
    /*his message contains 12 payload bytes*/	
	xnl_frame.xnl_header.payload_length = 0x000C;
800045f8:	30 ca       	mov	r10,12
800045fa:	ba 7a       	st.h	sp[0xe],r10
	
	/*No Preferred XNL Address*/
	xnl_frame.xnl_payload.xnl_content_device_conn_req.preferred_xnl_address = 
800045fc:	30 0a       	mov	r10,0
800045fe:	fb 5a 00 10 	st.h	sp[16],r10
	XCMP/XNL Development Specification Section 4.5.3.2.1.
	Same as in MOTOTRBO?XCMP/XNL Development Specification?
	evice_type--Option Board(0x07)
	authentication_index--Option Board(0x02)
	*/	
	xnl_frame.xnl_payload.xnl_content_device_conn_req.device_type = 0x07;
80004602:	30 7a       	mov	r10,7
80004604:	fb 6a 00 12 	st.b	sp[18],r10
	xnl_frame.xnl_payload.xnl_content_device_conn_req.authentication_index =
80004608:	30 2a       	mov	r10,2
8000460a:	fb 6a 00 13 	st.b	sp[19],r10
	                                                                       0x02;
		
	//We know encrypted array happens to be aligned to 32-bit boundary.
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
8000460e:	fa ca ff ec 	sub	r10,sp,-20
80004612:	95 09       	st.w	r10[0x0],r9
	                         .encrypted_authentication_value[0])) = w_vector[0];
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
80004614:	95 18       	st.w	r10[0x4],r8
	                         .encrypted_authentication_value[4])) = w_vector[1];
	
	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004616:	1a 9c       	mov	r12,sp
80004618:	f0 1f 00 05 	mcall	8000462c <xnl_device_auth_reply_func+0x11c>
}
8000461c:	2c 0d       	sub	sp,-256
8000461e:	d8 22       	popm	r4-r7,pc
80004620:	00 00       	add	r0,r0
80004622:	97 1c       	st.w	r11[0x4],r12
80004624:	00 00       	add	r0,r0
80004626:	0b 3c       	ld.ub	r12,r5++
80004628:	80 00       	ld.sh	r0,r0[0x0]
8000462a:	61 b4       	ld.w	r4,r0[0x6c]
8000462c:	80 00       	ld.sh	r0,r0[0x0]
8000462e:	43 cc       	lddsp	r12,sp[0xf0]

80004630 <xnl_master_status_brdcst_func>:
Description: process while receive master status boardcast.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_master_status_brdcst_func(xnl_fragment_t * xnl)
{	
80004630:	eb cd 40 80 	pushm	r7,lr
80004634:	fa cd 01 00 	sub	sp,sp,256
80004638:	18 97       	mov	r7,r12
	not an XNL_DATA_MSG has been sent out. This will indicate to a connecting 
	device that it has missed messages. The XNL header will contain the 
	master?XNL address. 5.4.1
	*/
	
	if(xnl_information.is_connected)
8000463a:	49 28       	lddpc	r8,80004680 <xnl_master_status_brdcst_func+0x50>
8000463c:	11 88       	ld.ub	r8,r8[0x0]
8000463e:	58 08       	cp.w	r8,0
80004640:	c1 c1       	brne	80004678 <xnl_master_status_brdcst_func+0x48>
	{
		return;	
	}
	
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);	
80004642:	49 18       	lddpc	r8,80004684 <xnl_master_status_brdcst_func+0x54>
80004644:	70 0c       	ld.w	r12,r8[0x0]
80004646:	30 09       	mov	r9,0
80004648:	12 9a       	mov	r10,r9
8000464a:	12 9b       	mov	r11,r9
8000464c:	f0 1f 00 0f 	mcall	80004688 <xnl_master_status_brdcst_func+0x58>

	//log("xnl-ma:%4x", xnl->xnl_header.source);
	/*get the master adderss from this message*/	
	xnl_information.master_address = xnl->xnl_header.source;	
80004650:	8e 58       	ld.sh	r8,r7[0xa]
80004652:	48 c9       	lddpc	r9,80004680 <xnl_master_status_brdcst_func+0x50>
80004654:	b2 18       	st.h	r9[0x2],r8
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80004656:	e0 68 40 0e 	mov	r8,16398
8000465a:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
8000465c:	3f f8       	mov	r8,-1
8000465e:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_AUTH_KEY_REQUEST;
80004660:	30 4a       	mov	r10,4
80004662:	ba 2a       	st.h	sp[0x4],r10
		
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/	
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
80004664:	ba 38       	st.h	sp[0x6],r8
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
80004666:	92 19       	ld.sh	r9,r9[0x2]
80004668:	ba 49       	st.h	sp[0x8],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.source = DEFAULT_VALUE;
8000466a:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
8000466c:	ba 68       	st.h	sp[0xc],r8
		
	xnl_frame.xnl_header.payload_length = 0;
8000466e:	30 08       	mov	r8,0
80004670:	ba 78       	st.h	sp[0xe],r8
	
	/*send XNL message*/	
	xnl_tx(&xnl_frame);
80004672:	1a 9c       	mov	r12,sp
80004674:	f0 1f 00 06 	mcall	8000468c <xnl_master_status_brdcst_func+0x5c>
}
80004678:	2c 0d       	sub	sp,-256
8000467a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000467e:	00 00       	add	r0,r0
80004680:	00 00       	add	r0,r0
80004682:	97 1c       	st.w	r11[0x4],r12
80004684:	00 00       	add	r0,r0
80004686:	0b 3c       	ld.ub	r12,r5++
80004688:	80 00       	ld.sh	r0,r0[0x0]
8000468a:	61 b4       	ld.w	r4,r0[0x6c]
8000468c:	80 00       	ld.sh	r0,r0[0x0]
8000468e:	43 cc       	lddsp	r12,sp[0xf0]

80004690 <xnl_device_conn_reply_func>:
Description: process while receive device conn reply.
Calls:xSemaphoreGive--freestos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_conn_reply_func(xnl_fragment_t * xnl)
{
80004690:	eb cd 40 80 	pushm	r7,lr
80004694:	18 97       	mov	r7,r12
	transaction ID and an 8-byte encrypted value that the device can use to 
	authenticate the master. XCMP/XNL Development Guide 5.4.6
	*/
	
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);
80004696:	49 28       	lddpc	r8,800046dc <xnl_device_conn_reply_func+0x4c>
80004698:	70 0c       	ld.w	r12,r8[0x0]
8000469a:	30 09       	mov	r9,0
8000469c:	12 9a       	mov	r10,r9
8000469e:	12 9b       	mov	r11,r9
800046a0:	f0 1f 00 10 	mcall	800046e0 <xnl_device_conn_reply_func+0x50>

	/*Test result code*/
	if((xnl->xnl_payload.xnl_content_device_conn_reply.result_base & 0x0000FF00)
800046a4:	ef 18 00 10 	ld.uh	r8,r7[16]
800046a8:	10 99       	mov	r9,r8
800046aa:	e2 19 ff 00 	andl	r9,0xff00,COH
800046ae:	e0 49 01 00 	cp.w	r9,256
800046b2:	c0 60       	breq	800046be <xnl_device_conn_reply_func+0x2e>
		/*
		Rejected. The device must retry the authentication process at this 
		point by sending out a new AUTH_KEY_REQUEST message. XCMP/XNL 
		Development Guide Section 5.2.3
		*/
		xnl_master_status_brdcst_func(xnl);			
800046b4:	0e 9c       	mov	r12,r7
800046b6:	f0 1f 00 0c 	mcall	800046e4 <xnl_device_conn_reply_func+0x54>
800046ba:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/*connection accepted*/		
		/*Record Transaction ID Base*/
		xnl_information.transaction_id =  
800046be:	a9 68       	lsl	r8,0x8
800046c0:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
800046c4:	48 98       	lddpc	r8,800046e8 <xnl_device_conn_reply_func+0x58>
800046c6:	b0 49       	st.h	r8[0x8],r9
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
800046c8:	ef 09 00 14 	ld.sh	r9,r7[20]
		xnl_information.transaction_id =  
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
800046cc:	b0 39       	st.h	r8[0x6],r9
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
800046ce:	ef 09 00 12 	ld.sh	r9,r7[18]
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
800046d2:	b0 29       	st.h	r8[0x4],r9
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
		
		/*connect finish*/
		xnl_information.is_connected = TRUE;
800046d4:	30 19       	mov	r9,1
800046d6:	b0 89       	st.b	r8[0x0],r9
800046d8:	e3 cd 80 80 	ldm	sp++,r7,pc
800046dc:	00 00       	add	r0,r0
800046de:	0b 3c       	ld.ub	r12,r5++
800046e0:	80 00       	ld.sh	r0,r0[0x0]
800046e2:	61 b4       	ld.w	r4,r0[0x6c]
800046e4:	80 00       	ld.sh	r0,r0[0x0]
800046e6:	46 30       	lddsp	r0,sp[0x18c]
800046e8:	00 00       	add	r0,r0
800046ea:	97 1c       	st.w	r11[0x4],r12

800046ec <xnl_send_device_master_query>:
Description: send device_master_query to connect radio.
Calls:xnl_tx
Call By:xnl_init
*/
void xnl_send_device_master_query(void)
{
800046ec:	d4 01       	pushm	lr
800046ee:	fa cd 01 00 	sub	sp,sp,256
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
800046f2:	e0 68 40 0e 	mov	r8,16398
800046f6:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
800046f8:	3f f8       	mov	r8,-1
800046fa:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_MASTER_QUERY;
800046fc:	30 38       	mov	r8,3
800046fe:	ba 28       	st.h	sp[0x4],r8
	
	/*The initial value*/
	xnl_frame.xnl_header.flags = 0;
80004700:	30 08       	mov	r8,0
80004702:	ba 38       	st.h	sp[0x6],r8
	
	/*XNL address of the master device, if known;otherwise 0x0000*/
	xnl_frame.xnl_header.destination = 0;
80004704:	ba 48       	st.h	sp[0x8],r8
	
	/*XNL address, if assigned; otherwise 0x0000*/
	xnl_frame.xnl_header.source = 0;
80004706:	ba 58       	st.h	sp[0xa],r8
	
	/*No transaction ID required for this message*/
	xnl_frame.xnl_header.transaction_id = 0;
80004708:	ba 68       	st.h	sp[0xc],r8
	
	/*This message contains no payload*/
	xnl_frame.xnl_header.payload_length = 0;
8000470a:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
8000470c:	1a 9c       	mov	r12,sp
8000470e:	f0 1f 00 03 	mcall	80004718 <xnl_send_device_master_query+0x2c>
}
80004712:	2c 0d       	sub	sp,-256
80004714:	d8 02       	popm	pc
80004716:	00 00       	add	r0,r0
80004718:	80 00       	ld.sh	r0,r0[0x0]
8000471a:	43 cc       	lddsp	r12,sp[0xf0]

8000471c <RC522_SPI_SetSpeed>:
	//SET_SPI_CS;

}

void RC522_SPI_SetSpeed(U16 SPI_BaudRatePrescaler)
{
8000471c:	d4 01       	pushm	lr
	spi->csr0 = (spi->csr0 & (U16)0x00FF) |SPI_BaudRatePrescaler;
8000471e:	48 78       	lddpc	r8,80004738 <RC522_SPI_SetSpeed+0x1c>
80004720:	70 09       	ld.w	r9,r8[0x0]
80004722:	72 ca       	ld.w	r10,r9[0x30]
80004724:	5c 7c       	castu.h	r12
80004726:	f5 da c0 08 	bfextu	r10,r10,0x0,0x8
8000472a:	f9 ea 10 0a 	or	r10,r12,r10
8000472e:	93 ca       	st.w	r9[0x30],r10

	spi_enable(spi); /*!< SD_SPI enable */
80004730:	70 0c       	ld.w	r12,r8[0x0]
80004732:	f0 1f 00 03 	mcall	8000473c <RC522_SPI_SetSpeed+0x20>
		
	
}
80004736:	d8 02       	popm	pc
80004738:	00 00       	add	r0,r0
8000473a:	1d a4       	ld.ub	r4,lr[0x2]
8000473c:	80 00       	ld.sh	r0,r0[0x0]
8000473e:	56 a4       	stdsp	sp[0x1a8],r4

80004740 <RC522_SPI_SetSpeedLow>:
void RC522_SPI_SetSpeedLow(void)
{
80004740:	d4 01       	pushm	lr
	RC522_SPI_SetSpeed(0x0A00);//baudDiv=4
80004742:	e0 6c 0a 00 	mov	r12,2560
80004746:	f0 1f 00 02 	mcall	8000474c <RC522_SPI_SetSpeedLow+0xc>
	
}
8000474a:	d8 02       	popm	pc
8000474c:	80 00       	ld.sh	r0,r0[0x0]
8000474e:	47 1c       	lddsp	r12,sp[0x1c4]

80004750 <RC522_ReadByte>:
	/*!< Return the byte read from the SPI bus */
	return  temp;

}
U8 RC522_ReadByte(void)
{
80004750:	eb cd 40 c0 	pushm	r6-r7,lr
	//蹇椤昏锋芥ｅ父璇诲
	//spi_selectChip(spi, DF_SPI_PCS_0);
	
	/*!< Send the byte */

	spi_write(spi,  0xFF);
80004754:	48 76       	lddpc	r6,80004770 <RC522_ReadByte+0x20>
80004756:	e0 6b 00 ff 	mov	r11,255
8000475a:	6c 0c       	ld.w	r12,r6[0x0]
8000475c:	f0 1f 00 06 	mcall	80004774 <RC522_ReadByte+0x24>
	
	/*!< Return the byte read from the SPI bus */

	spi_read(spi, Data);
80004760:	30 07       	mov	r7,0
80004762:	0e 9b       	mov	r11,r7
80004764:	6c 0c       	ld.w	r12,r6[0x0]
80004766:	f0 1f 00 05 	mcall	80004778 <RC522_ReadByte+0x28>
	
	//spi_unselectChip(spi, DF_SPI_PCS_0);
	
	return (U8)(*Data);
	
}
8000476a:	0f 9c       	ld.ub	r12,r7[0x1]
8000476c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004770:	00 00       	add	r0,r0
80004772:	1d a4       	ld.ub	r4,lr[0x2]
80004774:	80 00       	ld.sh	r0,r0[0x0]
80004776:	56 aa       	stdsp	sp[0x1a8],r10
80004778:	80 00       	ld.sh	r0,r0[0x0]
8000477a:	56 c6       	stdsp	sp[0x1b0],r6

8000477c <RC522_WriteByte>:


U8 rc522_init_failure =0;

U8 RC522_WriteByte(U8 Data)
{
8000477c:	eb cd 40 80 	pushm	r7,lr
80004780:	20 1d       	sub	sp,4
80004782:	ba 8c       	st.b	sp[0x0],r12
	U8 temp =0;
	
	//spi_selectChip(spi, DF_SPI_PCS_0);
	
	/*!< Send the byte */
	spi_write(spi,  (U16)Data);
80004784:	48 77       	lddpc	r7,800047a0 <RC522_WriteByte+0x24>
80004786:	f7 dc c0 08 	bfextu	r11,r12,0x0,0x8
8000478a:	6e 0c       	ld.w	r12,r7[0x0]
8000478c:	f0 1f 00 06 	mcall	800047a4 <RC522_WriteByte+0x28>
	
	/*!< Wait to receive a byte*/

	temp = spi_read(spi, (U16*)&Data);
80004790:	1a 9b       	mov	r11,sp
80004792:	6e 0c       	ld.w	r12,r7[0x0]
80004794:	f0 1f 00 05 	mcall	800047a8 <RC522_WriteByte+0x2c>
	//spi_unselectChip(spi, DF_SPI_PCS_0);
	
	/*!< Return the byte read from the SPI bus */
	return  temp;

}
80004798:	5c 5c       	castu.b	r12
8000479a:	2f fd       	sub	sp,-4
8000479c:	e3 cd 80 80 	ldm	sp++,r7,pc
800047a0:	00 00       	add	r0,r0
800047a2:	1d a4       	ld.ub	r4,lr[0x2]
800047a4:	80 00       	ld.sh	r0,r0[0x0]
800047a6:	56 aa       	stdsp	sp[0x1a8],r10
800047a8:	80 00       	ld.sh	r0,r0[0x0]
800047aa:	56 c6       	stdsp	sp[0x1b0],r6

800047ac <WriteRawRC>:
//    斤RC632瀵瀛
//拌存锛Address[IN]:瀵瀛ㄥ板
//          value[IN]:ョ
/////////////////////////////////////////////////////////////////////
void WriteRawRC(U8   Address, U8   value)
{
800047ac:	eb cd 40 e0 	pushm	r5-r7,lr
800047b0:	18 96       	mov	r6,r12
800047b2:	16 95       	mov	r5,r11
	U8   ucAddr;

	//CLR_SPI_CS;	
	spi_selectChip(spi, DF_SPI_PCS_0);
800047b4:	48 a7       	lddpc	r7,800047dc <WriteRawRC+0x30>
800047b6:	30 0b       	mov	r11,0
800047b8:	6e 0c       	ld.w	r12,r7[0x0]
800047ba:	f0 1f 00 0a 	mcall	800047e0 <WriteRawRC+0x34>
	
	ucAddr = ((Address<<1)&0x7E);
	RC522_WriteByte(ucAddr);
800047be:	ec 0c 15 01 	lsl	r12,r6,0x1
800047c2:	e2 1c 00 7e 	andl	r12,0x7e,COH
800047c6:	f0 1f 00 08 	mcall	800047e4 <WriteRawRC+0x38>
	RC522_WriteByte(value);
800047ca:	0a 9c       	mov	r12,r5
800047cc:	f0 1f 00 06 	mcall	800047e4 <WriteRawRC+0x38>
	
	spi_unselectChip(spi, DF_SPI_PCS_0);
800047d0:	30 0b       	mov	r11,0
800047d2:	6e 0c       	ld.w	r12,r7[0x0]
800047d4:	f0 1f 00 05 	mcall	800047e8 <WriteRawRC+0x3c>
	
	//SET_SPI_CS;

}
800047d8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800047dc:	00 00       	add	r0,r0
800047de:	1d a4       	ld.ub	r4,lr[0x2]
800047e0:	80 00       	ld.sh	r0,r0[0x0]
800047e2:	58 10       	cp.w	r0,1
800047e4:	80 00       	ld.sh	r0,r0[0x0]
800047e6:	47 7c       	lddsp	r12,sp[0x1dc]
800047e8:	80 00       	ld.sh	r0,r0[0x0]
800047ea:	57 d0       	stdsp	sp[0x1f4],r0

800047ec <PcdReset>:
/////////////////////////////////////////////////////////////////////
//    斤澶浣RC522
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdReset(void)
{
800047ec:	d4 01       	pushm	lr

	SET_RC522RST;
800047ee:	31 9c       	mov	r12,25
800047f0:	f0 1f 00 1b 	mcall	8000485c <PcdReset+0x70>
	delay_ns(10);
800047f4:	30 ac       	mov	r12,10
800047f6:	f0 1f 00 1b 	mcall	80004860 <PcdReset+0x74>

	CLR_RC522RST;
800047fa:	31 9c       	mov	r12,25
800047fc:	f0 1f 00 1a 	mcall	80004864 <PcdReset+0x78>
	delay_ns(10);
80004800:	30 ac       	mov	r12,10
80004802:	f0 1f 00 18 	mcall	80004860 <PcdReset+0x74>

	SET_RC522RST;
80004806:	31 9c       	mov	r12,25
80004808:	f0 1f 00 15 	mcall	8000485c <PcdReset+0x70>
	delay_ns(10);
8000480c:	30 ac       	mov	r12,10
8000480e:	f0 1f 00 15 	mcall	80004860 <PcdReset+0x74>
	WriteRawRC(CommandReg,PCD_RESETPHASE);
80004812:	30 fb       	mov	r11,15
80004814:	30 1c       	mov	r12,1
80004816:	f0 1f 00 15 	mcall	80004868 <PcdReset+0x7c>
	WriteRawRC(CommandReg,PCD_RESETPHASE);
8000481a:	30 fb       	mov	r11,15
8000481c:	30 1c       	mov	r12,1
8000481e:	f0 1f 00 13 	mcall	80004868 <PcdReset+0x7c>
	delay_ns(10);
80004822:	30 ac       	mov	r12,10
80004824:	f0 1f 00 0f 	mcall	80004860 <PcdReset+0x74>
	
	WriteRawRC(ModeReg,0x3D);            //Mifare￠璁锛CRC濮0x6363
80004828:	33 db       	mov	r11,61
8000482a:	31 1c       	mov	r12,17
8000482c:	f0 1f 00 0f 	mcall	80004868 <PcdReset+0x7c>
	WriteRawRC(TReloadRegL,30);
80004830:	31 eb       	mov	r11,30
80004832:	32 dc       	mov	r12,45
80004834:	f0 1f 00 0d 	mcall	80004868 <PcdReset+0x7c>
	WriteRawRC(TReloadRegH,0);
80004838:	30 0b       	mov	r11,0
8000483a:	32 cc       	mov	r12,44
8000483c:	f0 1f 00 0b 	mcall	80004868 <PcdReset+0x7c>
	WriteRawRC(TModeReg,0x8D);
80004840:	e0 6b 00 8d 	mov	r11,141
80004844:	32 ac       	mov	r12,42
80004846:	f0 1f 00 09 	mcall	80004868 <PcdReset+0x7c>
	WriteRawRC(TPrescalerReg,0x3E);
8000484a:	33 eb       	mov	r11,62
8000484c:	32 bc       	mov	r12,43
8000484e:	f0 1f 00 07 	mcall	80004868 <PcdReset+0x7c>
	
	WriteRawRC(TxAutoReg,0x40);//蹇椤昏
80004852:	34 0b       	mov	r11,64
80004854:	31 5c       	mov	r12,21
80004856:	f0 1f 00 05 	mcall	80004868 <PcdReset+0x7c>
	
	return MI_OK;
}
8000485a:	d8 0a       	popm	pc,r12=0
8000485c:	80 00       	ld.sh	r0,r0[0x0]
8000485e:	53 88       	stdsp	sp[0xe0],r8
80004860:	80 00       	ld.sh	r0,r0[0x0]
80004862:	51 28       	stdsp	sp[0x48],r8
80004864:	80 00       	ld.sh	r0,r0[0x0]
80004866:	53 a4       	stdsp	sp[0xe8],r4
80004868:	80 00       	ld.sh	r0,r0[0x0]
8000486a:	47 ac       	lddsp	r12,sp[0x1e8]

8000486c <ReadRawRC>:
//    斤璇RC632瀵瀛
//拌存锛Address[IN]:瀵瀛ㄥ板
//杩    锛璇诲虹
/////////////////////////////////////////////////////////////////////
U8 ReadRawRC(U8   Address)
{
8000486c:	eb cd 40 c0 	pushm	r6-r7,lr
80004870:	18 96       	mov	r6,r12
	U8   ucAddr;
	U8   ucResult=0;
	//CLR_SPI_CS;	
	spi_selectChip(spi, DF_SPI_PCS_0);
80004872:	48 c7       	lddpc	r7,800048a0 <ReadRawRC+0x34>
80004874:	30 0b       	mov	r11,0
80004876:	6e 0c       	ld.w	r12,r7[0x0]
80004878:	f0 1f 00 0b 	mcall	800048a4 <ReadRawRC+0x38>
	 
	ucAddr = ((Address<<1)&0x7E)|0x80;
	
	RC522_WriteByte(ucAddr);
8000487c:	a1 76       	lsl	r6,0x1
8000487e:	0c 9c       	mov	r12,r6
80004880:	e2 1c 00 7e 	andl	r12,0x7e,COH
80004884:	a7 bc       	sbr	r12,0x7
80004886:	f0 1f 00 09 	mcall	800048a8 <ReadRawRC+0x3c>
	ucResult = RC522_ReadByte();
8000488a:	f0 1f 00 09 	mcall	800048ac <ReadRawRC+0x40>
8000488e:	18 96       	mov	r6,r12
	
	spi_unselectChip(spi, DF_SPI_PCS_0);
80004890:	30 0b       	mov	r11,0
80004892:	6e 0c       	ld.w	r12,r7[0x0]
80004894:	f0 1f 00 07 	mcall	800048b0 <ReadRawRC+0x44>
	//SET_SPI_CS;
	return ucResult;
}
80004898:	0c 9c       	mov	r12,r6
8000489a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000489e:	00 00       	add	r0,r0
800048a0:	00 00       	add	r0,r0
800048a2:	1d a4       	ld.ub	r4,lr[0x2]
800048a4:	80 00       	ld.sh	r0,r0[0x0]
800048a6:	58 10       	cp.w	r0,1
800048a8:	80 00       	ld.sh	r0,r0[0x0]
800048aa:	47 7c       	lddsp	r12,sp[0x1dc]
800048ac:	80 00       	ld.sh	r0,r0[0x0]
800048ae:	47 50       	lddsp	r0,sp[0x1d4]
800048b0:	80 00       	ld.sh	r0,r0[0x0]
800048b2:	57 d0       	stdsp	sp[0x1f4],r0

800048b4 <Wait_Wakeup_RC522>:

/////////////////////////////////////////////////////////////////////
//    斤绛寰RC522
/////////////////////////////////////////////////////////////////////
void Wait_Wakeup_RC522(void)
{
800048b4:	d4 01       	pushm	lr
	char   tmp = 0x0;
	char   reg = CommandReg;
	
	do 
	{
		tmp = ReadRawRC(reg);
800048b6:	30 1c       	mov	r12,1
800048b8:	f0 1f 00 02 	mcall	800048c0 <Wait_Wakeup_RC522+0xc>
			
	//tmp = ReadRawRC(reg);
	//if((tmp & 0x10) == 0)
	//WriteRawRC(reg,tmp | PCD_POWERDOWN);  // set bit powerdown
	
}
800048bc:	d8 02       	popm	pc
800048be:	00 00       	add	r0,r0
800048c0:	80 00       	ld.sh	r0,r0[0x0]
800048c2:	48 6c       	lddpc	r12,800048d8 <Powerdown_RC522+0x14>

800048c4 <Powerdown_RC522>:
/////////////////////////////////////////////////////////////////////
//    斤浣RC522杩ヨ蒋垫ā寮
//
/////////////////////////////////////////////////////////////////////
void Powerdown_RC522(U8 act)
{
800048c4:	eb cd 40 80 	pushm	r7,lr
800048c8:	18 97       	mov	r7,r12
	char   tmp = 0x0;
	char   reg = CommandReg;
	
	tmp = ReadRawRC(reg);
800048ca:	30 1c       	mov	r12,1
800048cc:	f0 1f 00 0d 	mcall	80004900 <Powerdown_RC522+0x3c>
	if(act == ENTER_POWERDOWN)//1
800048d0:	30 18       	mov	r8,1
800048d2:	f0 07 18 00 	cp.b	r7,r8
800048d6:	c0 91       	brne	800048e8 <Powerdown_RC522+0x24>
		WriteRawRC(reg,tmp | PCD_POWERDOWN);  // set bit powerdown
800048d8:	18 9b       	mov	r11,r12
800048da:	a5 ab       	sbr	r11,0x4
800048dc:	5c 5b       	castu.b	r11
800048de:	30 1c       	mov	r12,1
800048e0:	f0 1f 00 09 	mcall	80004904 <Powerdown_RC522+0x40>
800048e4:	e3 cd 80 80 	ldm	sp++,r7,pc
	else
	{
		WriteRawRC(reg,tmp | PCD_IDLE);  // wake up rc522
800048e8:	18 9b       	mov	r11,r12
800048ea:	30 1c       	mov	r12,1
800048ec:	f0 1f 00 06 	mcall	80004904 <Powerdown_RC522+0x40>
		delay_ns(2);
800048f0:	30 2c       	mov	r12,2
800048f2:	f0 1f 00 06 	mcall	80004908 <Powerdown_RC522+0x44>
		Wait_Wakeup_RC522();
800048f6:	f0 1f 00 06 	mcall	8000490c <Powerdown_RC522+0x48>
800048fa:	e3 cd 80 80 	ldm	sp++,r7,pc
800048fe:	00 00       	add	r0,r0
80004900:	80 00       	ld.sh	r0,r0[0x0]
80004902:	48 6c       	lddpc	r12,80004918 <SetBitMask+0x8>
80004904:	80 00       	ld.sh	r0,r0[0x0]
80004906:	47 ac       	lddsp	r12,sp[0x1e8]
80004908:	80 00       	ld.sh	r0,r0[0x0]
8000490a:	51 28       	stdsp	sp[0x48],r8
8000490c:	80 00       	ld.sh	r0,r0[0x0]
8000490e:	48 b4       	lddpc	r4,80004938 <PcdAntennaOn+0x4>

80004910 <SetBitMask>:
//    斤缃RC522瀵瀛ㄤ
//拌存锛reg[IN]:瀵瀛ㄥ板
//          mask[IN]:缃浣
/////////////////////////////////////////////////////////////////////
void SetBitMask(U8   reg,U8   mask)
{
80004910:	eb cd 40 c0 	pushm	r6-r7,lr
80004914:	18 97       	mov	r7,r12
80004916:	16 96       	mov	r6,r11
	char   tmp = 0x0;
	tmp = ReadRawRC(reg);
80004918:	f0 1f 00 05 	mcall	8000492c <SetBitMask+0x1c>
	WriteRawRC(reg,tmp | mask);  // set bit mask
8000491c:	f9 e6 10 0b 	or	r11,r12,r6
80004920:	5c 5b       	castu.b	r11
80004922:	0e 9c       	mov	r12,r7
80004924:	f0 1f 00 03 	mcall	80004930 <SetBitMask+0x20>
}
80004928:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000492c:	80 00       	ld.sh	r0,r0[0x0]
8000492e:	48 6c       	lddpc	r12,80004944 <PcdAntennaOn+0x10>
80004930:	80 00       	ld.sh	r0,r0[0x0]
80004932:	47 ac       	lddsp	r12,sp[0x1e8]

80004934 <PcdAntennaOn>:
/////////////////////////////////////////////////////////////////////
//寮澶╃嚎
//姣娆″ㄦ抽澶╅╁灏涔村冲1ms撮
/////////////////////////////////////////////////////////////////////
void PcdAntennaOn(void)
{
80004934:	d4 01       	pushm	lr
	U8   i;
	i = ReadRawRC(TxControlReg);
80004936:	31 4c       	mov	r12,20
80004938:	f0 1f 00 05 	mcall	8000494c <PcdAntennaOn+0x18>
	if (!(i & 0x03))
8000493c:	f9 dc c0 02 	bfextu	r12,r12,0x0,0x2
80004940:	c0 51       	brne	8000494a <PcdAntennaOn+0x16>
	{
		SetBitMask(TxControlReg, 0x03);
80004942:	30 3b       	mov	r11,3
80004944:	31 4c       	mov	r12,20
80004946:	f0 1f 00 03 	mcall	80004950 <PcdAntennaOn+0x1c>
8000494a:	d8 02       	popm	pc
8000494c:	80 00       	ld.sh	r0,r0[0x0]
8000494e:	48 6c       	lddpc	r12,80004964 <ClearBitMask+0x10>
80004950:	80 00       	ld.sh	r0,r0[0x0]
80004952:	49 10       	lddpc	r0,80004994 <M500PcdConfigISOType+0x8>

80004954 <ClearBitMask>:
//    斤娓RC522瀵瀛ㄤ
//拌存锛reg[IN]:瀵瀛ㄥ板
//         mask[IN]:娓浣
/////////////////////////////////////////////////////////////////////
void ClearBitMask(U8   reg,U8   mask)
{
80004954:	eb cd 40 c0 	pushm	r6-r7,lr
80004958:	18 97       	mov	r7,r12
8000495a:	16 96       	mov	r6,r11
	  char   tmp = 0x0;
	  tmp = ReadRawRC(reg);
8000495c:	f0 1f 00 06 	mcall	80004974 <ClearBitMask+0x20>
	  WriteRawRC(reg, tmp & ~mask);  // clear bit mask
80004960:	5c d6       	com	r6
80004962:	f9 e6 00 06 	and	r6,r12,r6
80004966:	f7 d6 c0 08 	bfextu	r11,r6,0x0,0x8
8000496a:	0e 9c       	mov	r12,r7
8000496c:	f0 1f 00 03 	mcall	80004978 <ClearBitMask+0x24>
	
}
80004970:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004974:	80 00       	ld.sh	r0,r0[0x0]
80004976:	48 6c       	lddpc	r12,8000498c <M500PcdConfigISOType>
80004978:	80 00       	ld.sh	r0,r0[0x0]
8000497a:	47 ac       	lddsp	r12,sp[0x1e8]

8000497c <PcdAntennaOff>:

/////////////////////////////////////////////////////////////////////
//抽澶╃嚎
/////////////////////////////////////////////////////////////////////
void PcdAntennaOff(void)
{
8000497c:	d4 01       	pushm	lr
	ClearBitMask(TxControlReg, 0x03);
8000497e:	30 3b       	mov	r11,3
80004980:	31 4c       	mov	r12,20
80004982:	f0 1f 00 02 	mcall	80004988 <PcdAntennaOff+0xc>
}
80004986:	d8 02       	popm	pc
80004988:	80 00       	ld.sh	r0,r0[0x0]
8000498a:	49 54       	lddpc	r4,800049dc <M500PcdConfigISOType+0x50>

8000498c <M500PcdConfigISOType>:

//////////////////////////////////////////////////////////////////////
//璁剧疆RC632宸ヤ瑰
//////////////////////////////////////////////////////////////////////
char M500PcdConfigISOType(U8   type)
{
8000498c:	d4 01       	pushm	lr
	if (type == 'A')                     //ISO14443_A
8000498e:	34 18       	mov	r8,65
80004990:	f0 0c 18 00 	cp.b	r12,r8
80004994:	c0 20       	breq	80004998 <M500PcdConfigISOType+0xc>
80004996:	da 0a       	popm	pc,r12=1
	{
		ClearBitMask(Status2Reg,0x08);
80004998:	30 8b       	mov	r11,8
8000499a:	16 9c       	mov	r12,r11
8000499c:	f0 1f 00 14 	mcall	800049ec <M500PcdConfigISOType+0x60>
		WriteRawRC(ModeReg,0x3D);//3F
800049a0:	33 db       	mov	r11,61
800049a2:	31 1c       	mov	r12,17
800049a4:	f0 1f 00 13 	mcall	800049f0 <M500PcdConfigISOType+0x64>
		WriteRawRC(RxSelReg,0x86);//84
800049a8:	e0 6b 00 86 	mov	r11,134
800049ac:	31 7c       	mov	r12,23
800049ae:	f0 1f 00 11 	mcall	800049f0 <M500PcdConfigISOType+0x64>
		WriteRawRC(RFCfgReg,0x7F);   //4F
800049b2:	37 fb       	mov	r11,127
800049b4:	32 6c       	mov	r12,38
800049b6:	f0 1f 00 0f 	mcall	800049f0 <M500PcdConfigISOType+0x64>
		WriteRawRC(TReloadRegL,30);//tmoLength);// TReloadVal = 'h6a =tmoLength(dec)
800049ba:	31 eb       	mov	r11,30
800049bc:	32 dc       	mov	r12,45
800049be:	f0 1f 00 0d 	mcall	800049f0 <M500PcdConfigISOType+0x64>
		WriteRawRC(TReloadRegH,0);
800049c2:	30 0b       	mov	r11,0
800049c4:	32 cc       	mov	r12,44
800049c6:	f0 1f 00 0b 	mcall	800049f0 <M500PcdConfigISOType+0x64>
		WriteRawRC(TModeReg,0x8D);
800049ca:	e0 6b 00 8d 	mov	r11,141
800049ce:	32 ac       	mov	r12,42
800049d0:	f0 1f 00 08 	mcall	800049f0 <M500PcdConfigISOType+0x64>
		WriteRawRC(TPrescalerReg,0x3E);
800049d4:	33 eb       	mov	r11,62
800049d6:	32 bc       	mov	r12,43
800049d8:	f0 1f 00 06 	mcall	800049f0 <M500PcdConfigISOType+0x64>
		delay_ns(1000);
800049dc:	e0 6c 03 e8 	mov	r12,1000
800049e0:	f0 1f 00 05 	mcall	800049f4 <M500PcdConfigISOType+0x68>
		PcdAntennaOn();
800049e4:	f0 1f 00 05 	mcall	800049f8 <M500PcdConfigISOType+0x6c>
800049e8:	d8 0a       	popm	pc,r12=0
800049ea:	00 00       	add	r0,r0
800049ec:	80 00       	ld.sh	r0,r0[0x0]
800049ee:	49 54       	lddpc	r4,80004a40 <rc522_init+0x44>
800049f0:	80 00       	ld.sh	r0,r0[0x0]
800049f2:	47 ac       	lddsp	r12,sp[0x1e8]
800049f4:	80 00       	ld.sh	r0,r0[0x0]
800049f6:	51 28       	stdsp	sp[0x48],r8
800049f8:	80 00       	ld.sh	r0,r0[0x0]
800049fa:	49 34       	lddpc	r4,80004a44 <rc522_init+0x48>

800049fc <rc522_init>:


//mfrc522 init

void rc522_init()
{
800049fc:	eb cd 40 c0 	pushm	r6-r7,lr
80004a00:	20 4d       	sub	sp,16
		.spck_delay   = 0,
		.trans_delay  = 0,
		.stay_act     = 1,
		.spi_mode     = 0,
		.modfdis      = 1
	};
80004a02:	4a 38       	lddpc	r8,80004a8c <rc522_init+0x90>
80004a04:	1a 96       	mov	r6,sp
80004a06:	f0 ea 00 00 	ld.d	r10,r8[0]
80004a0a:	fa eb 00 00 	st.d	sp[0],r10
80004a0e:	f0 e8 00 08 	ld.d	r8,r8[8]
80004a12:	fa e9 00 08 	st.d	sp[8],r8

	// Assign I/Os to SPI.
	gpio_enable_module(RC522_SPI_GPIO_MAP, sizeof(RC522_SPI_GPIO_MAP) / sizeof(RC522_SPI_GPIO_MAP[0]));
80004a16:	30 4b       	mov	r11,4
80004a18:	49 ec       	lddpc	r12,80004a90 <rc522_init+0x94>
80004a1a:	f0 1f 00 1f 	mcall	80004a94 <rc522_init+0x98>

	// Configure PA25 as RST pin
	gpio_enable_gpio_pin(AVR32_PIN_PA25);
80004a1e:	31 9c       	mov	r12,25
80004a20:	f0 1f 00 1e 	mcall	80004a98 <rc522_init+0x9c>
	gpio_set_gpio_pin(AVR32_PIN_PA25);
80004a24:	31 9c       	mov	r12,25
80004a26:	f0 1f 00 1e 	mcall	80004a9c <rc522_init+0xa0>

	spi = &AVR32_SPI;
80004a2a:	49 e7       	lddpc	r7,80004aa0 <rc522_init+0xa4>
80004a2c:	fe 7c 24 00 	mov	r12,-56320
80004a30:	8f 0c       	st.w	r7[0x0],r12

	// Initialize as master.
	spi_initMaster(spi, &spiOptions);
80004a32:	1a 9b       	mov	r11,sp
80004a34:	f0 1f 00 1c 	mcall	80004aa4 <rc522_init+0xa8>

	// Set selection mode: variable_ps, pcs_decode, delay.
	spi_selectionMode(spi, 0, 0, 0);
80004a38:	30 09       	mov	r9,0
80004a3a:	12 9a       	mov	r10,r9
80004a3c:	12 9b       	mov	r11,r9
80004a3e:	6e 0c       	ld.w	r12,r7[0x0]
80004a40:	f0 1f 00 1a 	mcall	80004aa8 <rc522_init+0xac>

	// Enable SPI.
	spi_enable(spi);
80004a44:	6e 0c       	ld.w	r12,r7[0x0]
80004a46:	f0 1f 00 1a 	mcall	80004aac <rc522_init+0xb0>

	// Initialize RC522 with SPI clock PBA.
	if (spi_setupChipReg(spi, &spiOptions, 2*12000000) != SPI_OK)
80004a4a:	e0 6a 36 00 	mov	r10,13824
80004a4e:	ea 1a 01 6e 	orh	r10,0x16e
80004a52:	1a 9b       	mov	r11,sp
80004a54:	6e 0c       	ld.w	r12,r7[0x0]
80004a56:	f0 1f 00 17 	mcall	80004ab0 <rc522_init+0xb4>
80004a5a:	c0 50       	breq	80004a64 <rc522_init+0x68>
	{
		
		rc522_init_failure = FATAL_ERROR_RC522_SPI_INIT;
80004a5c:	30 29       	mov	r9,2
80004a5e:	49 68       	lddpc	r8,80004ab4 <rc522_init+0xb8>
80004a60:	b0 89       	st.b	r8[0x0],r9
80004a62:	c0 38       	rjmp	80004a68 <rc522_init+0x6c>
		return;
	}
	
	RC522_SPI_SetSpeedLow();
80004a64:	f0 1f 00 15 	mcall	80004ab8 <rc522_init+0xbc>
void rc522_init()
{
	
	spi_init();
	
	PcdReset();
80004a68:	f0 1f 00 15 	mcall	80004abc <rc522_init+0xc0>
	
	PcdAntennaOff();
80004a6c:	f0 1f 00 15 	mcall	80004ac0 <rc522_init+0xc4>
	
	delay_ms(2); 
80004a70:	30 2c       	mov	r12,2
80004a72:	f0 1f 00 15 	mcall	80004ac4 <rc522_init+0xc8>
	
	PcdAntennaOn();
80004a76:	f0 1f 00 15 	mcall	80004ac8 <rc522_init+0xcc>
	
	M500PcdConfigISOType( 'A' );
80004a7a:	34 1c       	mov	r12,65
80004a7c:	f0 1f 00 14 	mcall	80004acc <rc522_init+0xd0>
	
	Powerdown_RC522(ENTER_POWERDOWN);
80004a80:	30 1c       	mov	r12,1
80004a82:	f0 1f 00 14 	mcall	80004ad0 <rc522_init+0xd4>
	//Powerdown_RC522(ENTER_POWERDOWN);
	
	//Powerdown_RC522(WAKEUP_RC522);
	

80004a86:	2f cd       	sub	sp,-16
80004a88:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004a8c:	80 00       	ld.sh	r0,r0[0x0]
80004a8e:	d6 4c       	*unknown*
80004a90:	80 00       	ld.sh	r0,r0[0x0]
80004a92:	d6 2c       	*unknown*
80004a94:	80 00       	ld.sh	r0,r0[0x0]
80004a96:	53 40       	stdsp	sp[0xd0],r0
80004a98:	80 00       	ld.sh	r0,r0[0x0]
80004a9a:	53 70       	stdsp	sp[0xdc],r0
80004a9c:	80 00       	ld.sh	r0,r0[0x0]
80004a9e:	53 88       	stdsp	sp[0xe0],r8
80004aa0:	00 00       	add	r0,r0
80004aa2:	1d a4       	ld.ub	r4,lr[0x2]
80004aa4:	80 00       	ld.sh	r0,r0[0x0]
80004aa6:	56 40       	stdsp	sp[0x190],r0
80004aa8:	80 00       	ld.sh	r0,r0[0x0]
80004aaa:	56 78       	stdsp	sp[0x19c],r8
80004aac:	80 00       	ld.sh	r0,r0[0x0]
80004aae:	56 a4       	stdsp	sp[0x1a8],r4
80004ab0:	80 00       	ld.sh	r0,r0[0x0]
80004ab2:	56 e8       	stdsp	sp[0x1b8],r8
80004ab4:	00 00       	add	r0,r0
80004ab6:	0b 58       	ld.sh	r8,--r5
80004ab8:	80 00       	ld.sh	r0,r0[0x0]
80004aba:	47 40       	lddsp	r0,sp[0x1d0]
80004abc:	80 00       	ld.sh	r0,r0[0x0]
80004abe:	47 ec       	lddsp	r12,sp[0x1f8]
80004ac0:	80 00       	ld.sh	r0,r0[0x0]
80004ac2:	49 7c       	lddpc	r12,80004b1c <PcdComMF522+0x48>
80004ac4:	80 00       	ld.sh	r0,r0[0x0]
80004ac6:	51 68       	stdsp	sp[0x58],r8
80004ac8:	80 00       	ld.sh	r0,r0[0x0]
80004aca:	49 34       	lddpc	r4,80004b14 <PcdComMF522+0x40>
80004acc:	80 00       	ld.sh	r0,r0[0x0]
80004ace:	49 8c       	lddpc	r12,80004b2c <PcdComMF522+0x58>
80004ad0:	80 00       	ld.sh	r0,r0[0x0]
80004ad2:	48 c4       	lddpc	r4,80004b00 <PcdComMF522+0x2c>

80004ad4 <PcdComMF522>:
char PcdComMF522(U8  Command,
				 U8 *pIn ,
				 U8  InLenByte,
				 U8 *pOut ,
				 U8 *pOutLenBit)
{
80004ad4:	d4 31       	pushm	r0-r7,lr
80004ad6:	20 1d       	sub	sp,4
80004ad8:	18 92       	mov	r2,r12
80004ada:	16 95       	mov	r5,r11
80004adc:	14 96       	mov	r6,r10
80004ade:	50 09       	stdsp	sp[0x0],r9
80004ae0:	10 90       	mov	r0,r8
80004ae2:	f8 c8 00 0c 	sub	r8,r12,12
80004ae6:	5c 58       	castu.b	r8
80004ae8:	30 29       	mov	r9,2
80004aea:	f2 08 18 00 	cp.b	r8,r9
80004aee:	e0 88 00 05 	brls	80004af8 <PcdComMF522+0x24>
80004af2:	30 03       	mov	r3,0
80004af4:	06 91       	mov	r1,r3
80004af6:	c0 78       	rjmp	80004b04 <PcdComMF522+0x30>
80004af8:	4c f9       	lddpc	r9,80004c34 <PcdComMF522+0x160>
80004afa:	f2 08 07 01 	ld.ub	r1,r9[r8]
80004afe:	4c f9       	lddpc	r9,80004c38 <PcdComMF522+0x164>
80004b00:	f2 08 07 03 	ld.ub	r3,r9[r8]
		break;
		default:
		break;
	}
	
	WriteRawRC(ComIEnReg,irqEn|0x80);
80004b04:	02 9b       	mov	r11,r1
80004b06:	a7 bb       	sbr	r11,0x7
80004b08:	30 2c       	mov	r12,2
80004b0a:	f0 1f 00 4d 	mcall	80004c3c <PcdComMF522+0x168>
	ClearBitMask(ComIrqReg,0x80);	//娓涓浣
80004b0e:	e0 6b 00 80 	mov	r11,128
80004b12:	30 4c       	mov	r12,4
80004b14:	f0 1f 00 4b 	mcall	80004c40 <PcdComMF522+0x16c>
	WriteRawRC(CommandReg,PCD_IDLE);
80004b18:	30 0b       	mov	r11,0
80004b1a:	30 1c       	mov	r12,1
80004b1c:	f0 1f 00 48 	mcall	80004c3c <PcdComMF522+0x168>
	SetBitMask(FIFOLevelReg,0x80);	 	//娓FIFO缂瀛
80004b20:	e0 6b 00 80 	mov	r11,128
80004b24:	30 ac       	mov	r12,10
80004b26:	f0 1f 00 48 	mcall	80004c44 <PcdComMF522+0x170>
	
	for (i=0; i<InLenByte; i++)
80004b2a:	58 06       	cp.w	r6,0
80004b2c:	c0 c0       	breq	80004b44 <PcdComMF522+0x70>
80004b2e:	0a 97       	mov	r7,r5
	{   
		WriteRawRC(FIFODataReg, pIn [i]);
80004b30:	30 94       	mov	r4,9
80004b32:	0f 3b       	ld.ub	r11,r7++
80004b34:	08 9c       	mov	r12,r4
80004b36:	f0 1f 00 42 	mcall	80004c3c <PcdComMF522+0x168>
	WriteRawRC(ComIEnReg,irqEn|0x80);
	ClearBitMask(ComIrqReg,0x80);	//娓涓浣
	WriteRawRC(CommandReg,PCD_IDLE);
	SetBitMask(FIFOLevelReg,0x80);	 	//娓FIFO缂瀛
	
	for (i=0; i<InLenByte; i++)
80004b3a:	0e 98       	mov	r8,r7
80004b3c:	0a 18       	sub	r8,r5
80004b3e:	ec 08 19 00 	cp.h	r8,r6
80004b42:	cf 83       	brcs	80004b32 <PcdComMF522+0x5e>
	{   
		WriteRawRC(FIFODataReg, pIn [i]);
	}
	WriteRawRC(CommandReg, Command);
80004b44:	04 9b       	mov	r11,r2
80004b46:	30 1c       	mov	r12,1
80004b48:	f0 1f 00 3d 	mcall	80004c3c <PcdComMF522+0x168>
	
	if (Command == PCD_TRANSCEIVE)
80004b4c:	30 c8       	mov	r8,12
80004b4e:	f0 02 18 00 	cp.b	r2,r8
80004b52:	c0 61       	brne	80004b5e <PcdComMF522+0x8a>
	{    
		SetBitMask(BitFramingReg,0x80);  
80004b54:	e0 6b 00 80 	mov	r11,128
80004b58:	30 dc       	mov	r12,13
80004b5a:	f0 1f 00 3b 	mcall	80004c44 <PcdComMF522+0x170>
	
	//i = 600;//规堕棰璋达浣M1℃澶х寰堕25ms
	i = 2000;
	do
	{
		n = ReadRawRC(ComIrqReg);
80004b5e:	30 4c       	mov	r12,4
80004b60:	f0 1f 00 3a 	mcall	80004c48 <PcdComMF522+0x174>
80004b64:	18 97       	mov	r7,r12
80004b66:	e0 66 07 cf 	mov	r6,1999
		i--;
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
80004b6a:	30 05       	mov	r5,0
	
	//i = 600;//规堕棰璋达浣M1℃澶х寰堕25ms
	i = 2000;
	do
	{
		n = ReadRawRC(ComIrqReg);
80004b6c:	30 44       	mov	r4,4
80004b6e:	c0 88       	rjmp	80004b7e <PcdComMF522+0xaa>
80004b70:	08 9c       	mov	r12,r4
80004b72:	f0 1f 00 36 	mcall	80004c48 <PcdComMF522+0x174>
80004b76:	18 97       	mov	r7,r12
		i--;
80004b78:	20 16       	sub	r6,1
80004b7a:	5c 86       	casts.h	r6
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
80004b7c:	c0 a0       	breq	80004b90 <PcdComMF522+0xbc>
80004b7e:	f1 d7 c0 01 	bfextu	r8,r7,0x0,0x1
80004b82:	c4 c1       	brne	80004c1a <PcdComMF522+0x146>
80004b84:	ef e3 00 08 	and	r8,r7,r3
80004b88:	ea 08 18 00 	cp.b	r8,r5
80004b8c:	cf 20       	breq	80004b70 <PcdComMF522+0x9c>
80004b8e:	c4 68       	rjmp	80004c1a <PcdComMF522+0x146>
	ClearBitMask(BitFramingReg,0x80);
80004b90:	e0 6b 00 80 	mov	r11,128
80004b94:	30 dc       	mov	r12,13
80004b96:	f0 1f 00 2b 	mcall	80004c40 <PcdComMF522+0x16c>
80004b9a:	30 27       	mov	r7,2
80004b9c:	c3 38       	rjmp	80004c02 <PcdComMF522+0x12e>
80004b9e:	02 67       	and	r7,r1
80004ba0:	ef d7 c0 01 	bfextu	r7,r7,0x0,0x1
		if(!(ReadRawRC(ErrorReg)&0x1B))
		{
			status = MI_OK;
			if (n & irqEn & 0x01)
			{   status = MI_NOTAGERR;   }
			if (Command == PCD_TRANSCEIVE)
80004ba4:	30 c8       	mov	r8,12
80004ba6:	f0 02 18 00 	cp.b	r2,r8
80004baa:	c2 c1       	brne	80004c02 <PcdComMF522+0x12e>
			{
				n = ReadRawRC(FIFOLevelReg);
80004bac:	30 ac       	mov	r12,10
80004bae:	f0 1f 00 27 	mcall	80004c48 <PcdComMF522+0x174>
80004bb2:	18 94       	mov	r4,r12
				lastBits = ReadRawRC(ControlReg) & 0x07;
80004bb4:	30 cc       	mov	r12,12
80004bb6:	f0 1f 00 25 	mcall	80004c48 <PcdComMF522+0x174>
80004bba:	f9 dc c0 03 	bfextu	r12,r12,0x0,0x3
				if (lastBits)
80004bbe:	c0 70       	breq	80004bcc <PcdComMF522+0xf8>
				{   *pOutLenBit = (n-1)*8 + lastBits;   }
80004bc0:	08 98       	mov	r8,r4
80004bc2:	20 18       	sub	r8,1
80004bc4:	f8 08 00 3c 	add	r12,r12,r8<<0x3
80004bc8:	a0 8c       	st.b	r0[0x0],r12
80004bca:	c0 48       	rjmp	80004bd2 <PcdComMF522+0xfe>
				else
				{   *pOutLenBit = n*8;   }
80004bcc:	e8 08 15 03 	lsl	r8,r4,0x3
80004bd0:	a0 88       	st.b	r0[0x0],r8
				if (n == 0)
80004bd2:	58 04       	cp.w	r4,0
80004bd4:	c0 61       	brne	80004be0 <PcdComMF522+0x10c>
80004bd6:	30 14       	mov	r4,1
80004bd8:	40 05       	lddsp	r5,sp[0x0]
80004bda:	0a 96       	mov	r6,r5
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
				{   pOut [i] = ReadRawRC(FIFODataReg);    }
80004bdc:	30 93       	mov	r3,9
80004bde:	c0 98       	rjmp	80004bf0 <PcdComMF522+0x11c>
				{   *pOutLenBit = n*8;   }
				if (n == 0)
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
80004be0:	31 28       	mov	r8,18
80004be2:	f0 04 18 00 	cp.b	r4,r8
80004be6:	f9 b4 0b 12 	movhi	r4,18
80004bea:	58 04       	cp.w	r4,0
80004bec:	cf 61       	brne	80004bd8 <PcdComMF522+0x104>
80004bee:	c0 a8       	rjmp	80004c02 <PcdComMF522+0x12e>
				{   pOut [i] = ReadRawRC(FIFODataReg);    }
80004bf0:	06 9c       	mov	r12,r3
80004bf2:	f0 1f 00 16 	mcall	80004c48 <PcdComMF522+0x174>
80004bf6:	0c cc       	st.b	r6++,r12
				{   *pOutLenBit = n*8;   }
				if (n == 0)
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
80004bf8:	ec 05 01 08 	sub	r8,r6,r5
80004bfc:	e8 08 19 00 	cp.h	r8,r4
80004c00:	cf 83       	brcs	80004bf0 <PcdComMF522+0x11c>
		{   status = MI_ERR;   }
		
	}
	

	SetBitMask(ControlReg,0x80);           // stop timer now
80004c02:	e0 6b 00 80 	mov	r11,128
80004c06:	30 cc       	mov	r12,12
80004c08:	f0 1f 00 0f 	mcall	80004c44 <PcdComMF522+0x170>
	WriteRawRC(CommandReg,PCD_IDLE);
80004c0c:	30 0b       	mov	r11,0
80004c0e:	30 1c       	mov	r12,1
80004c10:	f0 1f 00 0b 	mcall	80004c3c <PcdComMF522+0x168>
	return status;
}
80004c14:	0e 9c       	mov	r12,r7
80004c16:	2f fd       	sub	sp,-4
80004c18:	d8 32       	popm	r0-r7,pc
	{
		n = ReadRawRC(ComIrqReg);
		i--;
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
	ClearBitMask(BitFramingReg,0x80);
80004c1a:	e0 6b 00 80 	mov	r11,128
80004c1e:	30 dc       	mov	r12,13
80004c20:	f0 1f 00 08 	mcall	80004c40 <PcdComMF522+0x16c>

	if (i!=0)
	{
		if(!(ReadRawRC(ErrorReg)&0x1B))
80004c24:	30 6c       	mov	r12,6
80004c26:	f0 1f 00 09 	mcall	80004c48 <PcdComMF522+0x174>
80004c2a:	e2 1c 00 1b 	andl	r12,0x1b,COH
80004c2e:	cb 80       	breq	80004b9e <PcdComMF522+0xca>
80004c30:	30 27       	mov	r7,2
80004c32:	ce 8b       	rjmp	80004c02 <PcdComMF522+0x12e>
80004c34:	80 00       	ld.sh	r0,r0[0x0]
80004c36:	d6 24       	*unknown*
80004c38:	80 00       	ld.sh	r0,r0[0x0]
80004c3a:	d6 28       	*unknown*
80004c3c:	80 00       	ld.sh	r0,r0[0x0]
80004c3e:	47 ac       	lddsp	r12,sp[0x1e8]
80004c40:	80 00       	ld.sh	r0,r0[0x0]
80004c42:	49 54       	lddpc	r4,80004c94 <PcdAnticoll+0x48>
80004c44:	80 00       	ld.sh	r0,r0[0x0]
80004c46:	49 10       	lddpc	r0,80004c88 <PcdAnticoll+0x3c>
80004c48:	80 00       	ld.sh	r0,r0[0x0]
80004c4a:	48 6c       	lddpc	r12,80004c60 <PcdAnticoll+0x14>

80004c4c <PcdAnticoll>:
//    斤插叉
//拌存: pSnr[OUT]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdAnticoll(U8 *pSnr)
{
80004c4c:	eb cd 40 c0 	pushm	r6-r7,lr
80004c50:	20 5d       	sub	sp,20
80004c52:	18 96       	mov	r6,r12
	U8   i,snr_check=0;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];
	

	ClearBitMask(Status2Reg,0x08);
80004c54:	30 8b       	mov	r11,8
80004c56:	16 9c       	mov	r12,r11
80004c58:	f0 1f 00 1a 	mcall	80004cc0 <PcdAnticoll+0x74>
	WriteRawRC(BitFramingReg,0x00);
80004c5c:	30 0b       	mov	r11,0
80004c5e:	30 dc       	mov	r12,13
80004c60:	f0 1f 00 19 	mcall	80004cc4 <PcdAnticoll+0x78>
	ClearBitMask(CollReg,0x80);
80004c64:	e0 6b 00 80 	mov	r11,128
80004c68:	30 ec       	mov	r12,14
80004c6a:	f0 1f 00 16 	mcall	80004cc0 <PcdAnticoll+0x74>
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
80004c6e:	39 38       	mov	r8,-109
80004c70:	ba 88       	st.b	sp[0x0],r8
	ucComMF522Buf[1] = 0x20;
80004c72:	32 08       	mov	r8,32
80004c74:	ba 98       	st.b	sp[0x1],r8

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,2,ucComMF522Buf,&unLen);
80004c76:	1a 9b       	mov	r11,sp
80004c78:	fa c8 ff ed 	sub	r8,sp,-19
80004c7c:	1a 99       	mov	r9,sp
80004c7e:	30 2a       	mov	r10,2
80004c80:	30 cc       	mov	r12,12
80004c82:	f0 1f 00 12 	mcall	80004cc8 <PcdAnticoll+0x7c>
80004c86:	18 97       	mov	r7,r12

	if (status == MI_OK)
80004c88:	c1 21       	brne	80004cac <PcdAnticoll+0x60>
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
80004c8a:	1b 89       	ld.ub	r9,sp[0x0]
80004c8c:	ac 89       	st.b	r6[0x0],r9
80004c8e:	1b 98       	ld.ub	r8,sp[0x1]
80004c90:	ac 98       	st.b	r6[0x1],r8
			snr_check ^= ucComMF522Buf[i];
80004c92:	10 59       	eor	r9,r8

	if (status == MI_OK)
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
80004c94:	1b a8       	ld.ub	r8,sp[0x2]
80004c96:	ac a8       	st.b	r6[0x2],r8
			snr_check ^= ucComMF522Buf[i];
80004c98:	f3 e8 20 08 	eor	r8,r9,r8

	if (status == MI_OK)
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
80004c9c:	1b b9       	ld.ub	r9,sp[0x3]
80004c9e:	ac b9       	st.b	r6[0x3],r9
			snr_check ^= ucComMF522Buf[i];
80004ca0:	12 58       	eor	r8,r9
		}
		if (snr_check != ucComMF522Buf[i])
80004ca2:	1b c9       	ld.ub	r9,sp[0x4]
80004ca4:	f0 09 18 00 	cp.b	r9,r8
80004ca8:	f9 b7 01 02 	movne	r7,2
		{   status = MI_ERR;    }
	}
	
	SetBitMask(CollReg,0x80);
80004cac:	e0 6b 00 80 	mov	r11,128
80004cb0:	30 ec       	mov	r12,14
80004cb2:	f0 1f 00 07 	mcall	80004ccc <PcdAnticoll+0x80>
	return status;
}
80004cb6:	0e 9c       	mov	r12,r7
80004cb8:	2f bd       	sub	sp,-20
80004cba:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004cbe:	00 00       	add	r0,r0
80004cc0:	80 00       	ld.sh	r0,r0[0x0]
80004cc2:	49 54       	lddpc	r4,80004d14 <PcdRequest+0x44>
80004cc4:	80 00       	ld.sh	r0,r0[0x0]
80004cc6:	47 ac       	lddsp	r12,sp[0x1e8]
80004cc8:	80 00       	ld.sh	r0,r0[0x0]
80004cca:	4a d4       	lddpc	r4,80004d7c <CalulateCRC+0x48>
80004ccc:	80 00       	ld.sh	r0,r0[0x0]
80004cce:	49 10       	lddpc	r0,80004d10 <PcdRequest+0x40>

80004cd0 <PcdRequest>:
//                0x0800 = Mifare_Pro(X)
//                0x4403 = Mifare_DESFire
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdRequest(U8   req_code,U8 *pTagType)
{
80004cd0:	eb cd 40 c0 	pushm	r6-r7,lr
80004cd4:	20 5d       	sub	sp,20
80004cd6:	18 97       	mov	r7,r12
80004cd8:	16 96       	mov	r6,r11
	char   status;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];

	ClearBitMask(Status2Reg,0x08);
80004cda:	30 8b       	mov	r11,8
80004cdc:	16 9c       	mov	r12,r11
80004cde:	f0 1f 00 12 	mcall	80004d24 <PcdRequest+0x54>
	WriteRawRC(BitFramingReg,0x07);
80004ce2:	30 7b       	mov	r11,7
80004ce4:	30 dc       	mov	r12,13
80004ce6:	f0 1f 00 11 	mcall	80004d28 <PcdRequest+0x58>
	SetBitMask(TxControlReg,0x03);
80004cea:	30 3b       	mov	r11,3
80004cec:	31 4c       	mov	r12,20
80004cee:	f0 1f 00 10 	mcall	80004d2c <PcdRequest+0x5c>
	
	ucComMF522Buf[0] = req_code;
80004cf2:	ba 87       	st.b	sp[0x0],r7

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,1,ucComMF522Buf,&unLen);
80004cf4:	1a 9b       	mov	r11,sp
80004cf6:	fa c8 ff ed 	sub	r8,sp,-19
80004cfa:	1a 99       	mov	r9,sp
80004cfc:	30 1a       	mov	r10,1
80004cfe:	30 cc       	mov	r12,12
80004d00:	f0 1f 00 0c 	mcall	80004d30 <PcdRequest+0x60>

	if ((status == MI_OK) && (unLen == 0x10))
80004d04:	c0 c1       	brne	80004d1c <PcdRequest+0x4c>
80004d06:	31 08       	mov	r8,16
80004d08:	fb 39 00 13 	ld.ub	r9,sp[19]
80004d0c:	f0 09 18 00 	cp.b	r9,r8
80004d10:	c0 61       	brne	80004d1c <PcdRequest+0x4c>
	{
		*pTagType     = ucComMF522Buf[0];
80004d12:	1b 88       	ld.ub	r8,sp[0x0]
80004d14:	ac 88       	st.b	r6[0x0],r8
		*(pTagType+1) = ucComMF522Buf[1];
80004d16:	1b 98       	ld.ub	r8,sp[0x1]
80004d18:	ac 98       	st.b	r6[0x1],r8
	
	ucComMF522Buf[0] = req_code;

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,1,ucComMF522Buf,&unLen);

	if ((status == MI_OK) && (unLen == 0x10))
80004d1a:	c0 28       	rjmp	80004d1e <PcdRequest+0x4e>
80004d1c:	30 2c       	mov	r12,2
	}
	else
	{   status = MI_ERR;   }
	
	return status;
}
80004d1e:	2f bd       	sub	sp,-20
80004d20:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004d24:	80 00       	ld.sh	r0,r0[0x0]
80004d26:	49 54       	lddpc	r4,80004d78 <CalulateCRC+0x44>
80004d28:	80 00       	ld.sh	r0,r0[0x0]
80004d2a:	47 ac       	lddsp	r12,sp[0x1e8]
80004d2c:	80 00       	ld.sh	r0,r0[0x0]
80004d2e:	49 10       	lddpc	r0,80004d70 <CalulateCRC+0x3c>
80004d30:	80 00       	ld.sh	r0,r0[0x0]
80004d32:	4a d4       	lddpc	r4,80004de4 <PcdSelect+0x24>

80004d34 <CalulateCRC>:

/////////////////////////////////////////////////////////////////////
//MF522璁＄CRC16芥
/////////////////////////////////////////////////////////////////////
void CalulateCRC(U8 *pIn ,U8   len,U8 *pOut )
{
80004d34:	eb cd 40 f8 	pushm	r3-r7,lr
80004d38:	18 95       	mov	r5,r12
80004d3a:	16 96       	mov	r6,r11
80004d3c:	14 93       	mov	r3,r10
	U8   i,n;
	ClearBitMask(DivIrqReg,0x04);
80004d3e:	30 4b       	mov	r11,4
80004d40:	30 5c       	mov	r12,5
80004d42:	f0 1f 00 1c 	mcall	80004db0 <CalulateCRC+0x7c>
	WriteRawRC(CommandReg,PCD_IDLE);
80004d46:	30 0b       	mov	r11,0
80004d48:	30 1c       	mov	r12,1
80004d4a:	f0 1f 00 1b 	mcall	80004db4 <CalulateCRC+0x80>
	SetBitMask(FIFOLevelReg,0x80);
80004d4e:	e0 6b 00 80 	mov	r11,128
80004d52:	30 ac       	mov	r12,10
80004d54:	f0 1f 00 19 	mcall	80004db8 <CalulateCRC+0x84>
	for (i=0; i<len; i++)
80004d58:	58 06       	cp.w	r6,0
80004d5a:	c0 c0       	breq	80004d72 <CalulateCRC+0x3e>
80004d5c:	0a 97       	mov	r7,r5
	{   WriteRawRC(FIFODataReg, *(pIn +i));   }
80004d5e:	30 94       	mov	r4,9
80004d60:	0f 3b       	ld.ub	r11,r7++
80004d62:	08 9c       	mov	r12,r4
80004d64:	f0 1f 00 14 	mcall	80004db4 <CalulateCRC+0x80>
{
	U8   i,n;
	ClearBitMask(DivIrqReg,0x04);
	WriteRawRC(CommandReg,PCD_IDLE);
	SetBitMask(FIFOLevelReg,0x80);
	for (i=0; i<len; i++)
80004d68:	0e 98       	mov	r8,r7
80004d6a:	0a 18       	sub	r8,r5
80004d6c:	ec 08 18 00 	cp.b	r8,r6
80004d70:	cf 83       	brcs	80004d60 <CalulateCRC+0x2c>
	{   WriteRawRC(FIFODataReg, *(pIn +i));   }
	WriteRawRC(CommandReg, PCD_CALCCRC);
80004d72:	30 3b       	mov	r11,3
80004d74:	30 1c       	mov	r12,1
80004d76:	f0 1f 00 10 	mcall	80004db4 <CalulateCRC+0x80>
	i = 0xFF;
	do
	{
		n = ReadRawRC(DivIrqReg);
80004d7a:	30 5c       	mov	r12,5
80004d7c:	f0 1f 00 10 	mcall	80004dbc <CalulateCRC+0x88>
80004d80:	e0 67 00 fe 	mov	r7,254
80004d84:	30 56       	mov	r6,5
80004d86:	c0 78       	rjmp	80004d94 <CalulateCRC+0x60>
80004d88:	0c 9c       	mov	r12,r6
80004d8a:	f0 1f 00 0d 	mcall	80004dbc <CalulateCRC+0x88>
		i--;
80004d8e:	20 17       	sub	r7,1
80004d90:	5c 57       	castu.b	r7
	}
	while ((i!=0) && !(n&0x04));
80004d92:	c0 40       	breq	80004d9a <CalulateCRC+0x66>
80004d94:	e2 1c 00 04 	andl	r12,0x4,COH
80004d98:	cf 80       	breq	80004d88 <CalulateCRC+0x54>
	pOut [0] = ReadRawRC(CRCResultRegL);
80004d9a:	32 2c       	mov	r12,34
80004d9c:	f0 1f 00 08 	mcall	80004dbc <CalulateCRC+0x88>
80004da0:	a6 8c       	st.b	r3[0x0],r12
	pOut [1] = ReadRawRC(CRCResultRegM);
80004da2:	32 1c       	mov	r12,33
80004da4:	f0 1f 00 06 	mcall	80004dbc <CalulateCRC+0x88>
80004da8:	a6 9c       	st.b	r3[0x1],r12
}
80004daa:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80004dae:	00 00       	add	r0,r0
80004db0:	80 00       	ld.sh	r0,r0[0x0]
80004db2:	49 54       	lddpc	r4,80004e04 <PcdSelect+0x44>
80004db4:	80 00       	ld.sh	r0,r0[0x0]
80004db6:	47 ac       	lddsp	r12,sp[0x1e8]
80004db8:	80 00       	ld.sh	r0,r0[0x0]
80004dba:	49 10       	lddpc	r0,80004dfc <PcdSelect+0x3c>
80004dbc:	80 00       	ld.sh	r0,r0[0x0]
80004dbe:	48 6c       	lddpc	r12,80004dd4 <PcdSelect+0x14>

80004dc0 <PcdSelect>:
//    斤瀹＄
//拌存: pSnr[IN]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdSelect(U8 *pSnr)
{
80004dc0:	eb cd 40 80 	pushm	r7,lr
80004dc4:	20 5d       	sub	sp,20
	char   status;
	U8   i;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
80004dc6:	39 38       	mov	r8,-109
80004dc8:	ba 88       	st.b	sp[0x0],r8
	ucComMF522Buf[1] = 0x70;
80004dca:	37 08       	mov	r8,112
80004dcc:	ba 98       	st.b	sp[0x1],r8
	ucComMF522Buf[6] = 0;
80004dce:	30 08       	mov	r8,0
80004dd0:	ba e8       	st.b	sp[0x6],r8
80004dd2:	fa c8 ff fe 	sub	r8,sp,-2
/////////////////////////////////////////////////////////////////////
//    斤瀹＄
//拌存: pSnr[IN]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdSelect(U8 *pSnr)
80004dd6:	fa cb ff fa 	sub	r11,sp,-6
	ucComMF522Buf[0] = PICC_ANTICOLL1;
	ucComMF522Buf[1] = 0x70;
	ucComMF522Buf[6] = 0;
	for (i=0; i<4; i++)
	{
		ucComMF522Buf[i+2] = *(pSnr+i);
80004dda:	19 89       	ld.ub	r9,r12[0x0]
80004ddc:	10 c9       	st.b	r8++,r9
		ucComMF522Buf[6]  ^= *(pSnr+i);
80004dde:	19 3a       	ld.ub	r10,r12++
80004de0:	1b e9       	ld.ub	r9,sp[0x6]
80004de2:	f5 e9 20 09 	eor	r9,r10,r9
80004de6:	ba e9       	st.b	sp[0x6],r9
	U8   ucComMF522Buf[MAXRLEN];
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
	ucComMF522Buf[1] = 0x70;
	ucComMF522Buf[6] = 0;
	for (i=0; i<4; i++)
80004de8:	16 38       	cp.w	r8,r11
80004dea:	cf 81       	brne	80004dda <PcdSelect+0x1a>
	{
		ucComMF522Buf[i+2] = *(pSnr+i);
		ucComMF522Buf[6]  ^= *(pSnr+i);
	}
	CalulateCRC(ucComMF522Buf,7,&ucComMF522Buf[7]);
80004dec:	1a 97       	mov	r7,sp
80004dee:	fa ca ff f9 	sub	r10,sp,-7
80004df2:	30 7b       	mov	r11,7
80004df4:	1a 9c       	mov	r12,sp
80004df6:	f0 1f 00 0d 	mcall	80004e28 <PcdSelect+0x68>
	
	ClearBitMask(Status2Reg,0x08);
80004dfa:	30 8b       	mov	r11,8
80004dfc:	16 9c       	mov	r12,r11
80004dfe:	f0 1f 00 0c 	mcall	80004e2c <PcdSelect+0x6c>

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,9,ucComMF522Buf,&unLen);
80004e02:	fa c8 ff ed 	sub	r8,sp,-19
80004e06:	1a 99       	mov	r9,sp
80004e08:	30 9a       	mov	r10,9
80004e0a:	1a 9b       	mov	r11,sp
80004e0c:	30 cc       	mov	r12,12
80004e0e:	f0 1f 00 09 	mcall	80004e30 <PcdSelect+0x70>
	
	if ((status == MI_OK) && (unLen == 0x18))
80004e12:	c0 71       	brne	80004e20 <PcdSelect+0x60>
80004e14:	31 88       	mov	r8,24
80004e16:	fb 39 00 13 	ld.ub	r9,sp[19]
80004e1a:	f0 09 18 00 	cp.b	r9,r8
80004e1e:	c0 20       	breq	80004e22 <PcdSelect+0x62>
80004e20:	30 2c       	mov	r12,2
	{   status = MI_OK;  }
	else
	{   status = MI_ERR;    }

	return status;
}
80004e22:	2f bd       	sub	sp,-20
80004e24:	e3 cd 80 80 	ldm	sp++,r7,pc
80004e28:	80 00       	ld.sh	r0,r0[0x0]
80004e2a:	4d 34       	lddpc	r4,80004f74 <scan_patrol+0x2c>
80004e2c:	80 00       	ld.sh	r0,r0[0x0]
80004e2e:	49 54       	lddpc	r4,80004e80 <rfid_auto_reader+0x4c>
80004e30:	80 00       	ld.sh	r0,r0[0x0]
80004e32:	4a d4       	lddpc	r4,80004ee4 <rfid_auto_reader+0xb0>

80004e34 <rfid_auto_reader>:
		//
}

//娴绋锛瀵诲->插叉->->″
U8 rfid_auto_reader(void *card_id)
{
80004e34:	eb cd 40 c0 	pushm	r6-r7,lr
80004e38:	18 96       	mov	r6,r12
	U8 status = MI_ERR;
	
	PcdReset();
80004e3a:	f0 1f 00 35 	mcall	80004f0c <rfid_auto_reader+0xd8>
//while(1){
	status=PcdRequest(PICC_REQALL,	CT);//瀵诲ぉ绾垮哄ㄩㄧ★杩＄绫诲 2瀛
80004e3e:	4b 5b       	lddpc	r11,80004f10 <rfid_auto_reader+0xdc>
80004e40:	35 2c       	mov	r12,82
80004e42:	f0 1f 00 35 	mcall	80004f14 <rfid_auto_reader+0xe0>
80004e46:	18 97       	mov	r7,r12
	if(status!=MI_OK) return status;
80004e48:	c5 e1       	brne	80004f04 <rfid_auto_reader+0xd0>
	//continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
80004e4a:	4b 28       	lddpc	r8,80004f10 <rfid_auto_reader+0xdc>
80004e4c:	11 88       	ld.ub	r8,r8[0x0]
80004e4e:	30 49       	mov	r9,4
80004e50:	f2 08 18 00 	cp.b	r8,r9
80004e54:	c0 b1       	brne	80004e6a <rfid_auto_reader+0x36>
80004e56:	4a f9       	lddpc	r9,80004f10 <rfid_auto_reader+0xdc>
80004e58:	13 9a       	ld.ub	r10,r9[0x1]
80004e5a:	30 09       	mov	r9,0
80004e5c:	f2 0a 18 00 	cp.b	r10,r9
80004e60:	c0 51       	brne	80004e6a <rfid_auto_reader+0x36>
		log("MFOne-S50\n");
80004e62:	4a ec       	lddpc	r12,80004f18 <rfid_auto_reader+0xe4>
80004e64:	f0 1f 00 2e 	mcall	80004f1c <rfid_auto_reader+0xe8>
//while(1){
	status=PcdRequest(PICC_REQALL,	CT);//瀵诲ぉ绾垮哄ㄩㄧ★杩＄绫诲 2瀛
	if(status!=MI_OK) return status;
	//continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
80004e68:	c3 c8       	rjmp	80004ee0 <rfid_auto_reader+0xac>
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
80004e6a:	30 29       	mov	r9,2
80004e6c:	f2 08 18 00 	cp.b	r8,r9
80004e70:	c0 b1       	brne	80004e86 <rfid_auto_reader+0x52>
80004e72:	4a 89       	lddpc	r9,80004f10 <rfid_auto_reader+0xdc>
80004e74:	13 9a       	ld.ub	r10,r9[0x1]
80004e76:	30 09       	mov	r9,0
80004e78:	f2 0a 18 00 	cp.b	r10,r9
80004e7c:	c0 51       	brne	80004e86 <rfid_auto_reader+0x52>
		log("MFOne-S70\n");
80004e7e:	4a 9c       	lddpc	r12,80004f20 <rfid_auto_reader+0xec>
80004e80:	f0 1f 00 27 	mcall	80004f1c <rfid_auto_reader+0xe8>
	if(status!=MI_OK) return status;
	//continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
80004e84:	c2 e8       	rjmp	80004ee0 <rfid_auto_reader+0xac>
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
80004e86:	34 49       	mov	r9,68
80004e88:	f2 08 18 00 	cp.b	r8,r9
80004e8c:	c0 b1       	brne	80004ea2 <rfid_auto_reader+0x6e>
80004e8e:	4a 19       	lddpc	r9,80004f10 <rfid_auto_reader+0xdc>
80004e90:	13 9a       	ld.ub	r10,r9[0x1]
80004e92:	30 09       	mov	r9,0
80004e94:	f2 0a 18 00 	cp.b	r10,r9
80004e98:	c0 51       	brne	80004ea2 <rfid_auto_reader+0x6e>
		log("MF-UltraLight\n");
80004e9a:	4a 3c       	lddpc	r12,80004f24 <rfid_auto_reader+0xf0>
80004e9c:	f0 1f 00 20 	mcall	80004f1c <rfid_auto_reader+0xe8>
	
	if(CT[0]==0x04&&CT[1]==0x00)
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
80004ea0:	c2 08       	rjmp	80004ee0 <rfid_auto_reader+0xac>
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
80004ea2:	30 89       	mov	r9,8
80004ea4:	f2 08 18 00 	cp.b	r8,r9
80004ea8:	c0 b1       	brne	80004ebe <rfid_auto_reader+0x8a>
80004eaa:	49 a9       	lddpc	r9,80004f10 <rfid_auto_reader+0xdc>
80004eac:	13 9a       	ld.ub	r10,r9[0x1]
80004eae:	30 09       	mov	r9,0
80004eb0:	f2 0a 18 00 	cp.b	r10,r9
80004eb4:	c0 51       	brne	80004ebe <rfid_auto_reader+0x8a>
		log("MF-Pro\n");
80004eb6:	49 dc       	lddpc	r12,80004f28 <rfid_auto_reader+0xf4>
80004eb8:	f0 1f 00 19 	mcall	80004f1c <rfid_auto_reader+0xe8>
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
80004ebc:	c1 28       	rjmp	80004ee0 <rfid_auto_reader+0xac>
		log("MF-Pro\n");
	else if(CT[0]==0x44&&CT[1]==0x03)
80004ebe:	34 49       	mov	r9,68
80004ec0:	f2 08 18 00 	cp.b	r8,r9
80004ec4:	c0 b1       	brne	80004eda <rfid_auto_reader+0xa6>
80004ec6:	49 38       	lddpc	r8,80004f10 <rfid_auto_reader+0xdc>
80004ec8:	11 99       	ld.ub	r9,r8[0x1]
80004eca:	30 38       	mov	r8,3
80004ecc:	f0 09 18 00 	cp.b	r9,r8
80004ed0:	c0 51       	brne	80004eda <rfid_auto_reader+0xa6>
		log("MF Desire\n");
80004ed2:	49 7c       	lddpc	r12,80004f2c <rfid_auto_reader+0xf8>
80004ed4:	f0 1f 00 12 	mcall	80004f1c <rfid_auto_reader+0xe8>
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
		log("MF-Pro\n");
	else if(CT[0]==0x44&&CT[1]==0x03)
80004ed8:	c0 48       	rjmp	80004ee0 <rfid_auto_reader+0xac>
		log("MF Desire\n");
	else
		log("Unknown\n");
80004eda:	49 6c       	lddpc	r12,80004f30 <rfid_auto_reader+0xfc>
80004edc:	f0 1f 00 10 	mcall	80004f1c <rfid_auto_reader+0xe8>
		
	status=PcdAnticoll(SN);//插叉锛杩＄搴 4瀛
80004ee0:	49 5c       	lddpc	r12,80004f34 <rfid_auto_reader+0x100>
80004ee2:	f0 1f 00 16 	mcall	80004f38 <rfid_auto_reader+0x104>
80004ee6:	18 97       	mov	r7,r12
	if(status!=MI_OK)
80004ee8:	c0 e1       	brne	80004f04 <rfid_auto_reader+0xd0>
		return status;
		//continue;
	}
	
	//memcpy(MLastSelectedSnr,&RevBuffer[2],4);
	status=PcdSelect(SN);//
80004eea:	49 3c       	lddpc	r12,80004f34 <rfid_auto_reader+0x100>
80004eec:	f0 1f 00 14 	mcall	80004f3c <rfid_auto_reader+0x108>
80004ef0:	18 97       	mov	r7,r12
	if(status!=MI_OK)return status;
80004ef2:	c0 91       	brne	80004f04 <rfid_auto_reader+0xd0>
	//continue;
	else{//℃
			
		memcpy(card_id, SN, 4);
80004ef4:	30 4a       	mov	r10,4
80004ef6:	49 0b       	lddpc	r11,80004f34 <rfid_auto_reader+0x100>
80004ef8:	0c 9c       	mov	r12,r6
80004efa:	f0 1f 00 12 	mcall	80004f40 <rfid_auto_reader+0x10c>
		log("select okay\n");
80004efe:	49 2c       	lddpc	r12,80004f44 <rfid_auto_reader+0x110>
80004f00:	f0 1f 00 07 	mcall	80004f1c <rfid_auto_reader+0xe8>
		return status;	
	}
	
//}
	
}
80004f04:	0e 9c       	mov	r12,r7
80004f06:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004f0a:	00 00       	add	r0,r0
80004f0c:	80 00       	ld.sh	r0,r0[0x0]
80004f0e:	47 ec       	lddsp	r12,sp[0x1f8]
80004f10:	00 00       	add	r0,r0
80004f12:	97 38       	st.w	r11[0xc],r8
80004f14:	80 00       	ld.sh	r0,r0[0x0]
80004f16:	4c d0       	lddpc	r0,80005048 <rfid_sendID_message+0xb0>
80004f18:	80 00       	ld.sh	r0,r0[0x0]
80004f1a:	d6 5c       	*unknown*
80004f1c:	80 00       	ld.sh	r0,r0[0x0]
80004f1e:	6d ec       	ld.w	r12,r6[0x78]
80004f20:	80 00       	ld.sh	r0,r0[0x0]
80004f22:	d6 68       	*unknown*
80004f24:	80 00       	ld.sh	r0,r0[0x0]
80004f26:	d6 74       	*unknown*
80004f28:	80 00       	ld.sh	r0,r0[0x0]
80004f2a:	d6 84       	*unknown*
80004f2c:	80 00       	ld.sh	r0,r0[0x0]
80004f2e:	d6 8c       	*unknown*
80004f30:	80 00       	ld.sh	r0,r0[0x0]
80004f32:	d6 98       	*unknown*
80004f34:	00 00       	add	r0,r0
80004f36:	97 3c       	st.w	r11[0xc],r12
80004f38:	80 00       	ld.sh	r0,r0[0x0]
80004f3a:	4c 4c       	lddpc	r12,80005048 <rfid_sendID_message+0xb0>
80004f3c:	80 00       	ld.sh	r0,r0[0x0]
80004f3e:	4d c0       	lddpc	r0,800050ac <rfid_sendID_message+0x114>
80004f40:	80 00       	ld.sh	r0,r0[0x0]
80004f42:	76 68       	ld.w	r8,r11[0x18]
80004f44:	80 00       	ld.sh	r0,r0[0x0]
80004f46:	d6 a4       	*unknown*

80004f48 <scan_patrol>:
	return return_err;
	
}

U8 scan_patrol(char* SN)
{
80004f48:	eb cd 40 80 	pushm	r7,lr
80004f4c:	18 97       	mov	r7,r12
	U8 return_err = MI_ERR;
	
	PcdReset();
80004f4e:	f0 1f 00 0d 	mcall	80004f80 <scan_patrol+0x38>
	Powerdown_RC522(WAKEUP_RC522);
80004f52:	30 0c       	mov	r12,0
80004f54:	f0 1f 00 0c 	mcall	80004f84 <scan_patrol+0x3c>
	return_err = rfid_auto_reader(SN);
80004f58:	0e 9c       	mov	r12,r7
80004f5a:	f0 1f 00 0c 	mcall	80004f88 <scan_patrol+0x40>
80004f5e:	18 97       	mov	r7,r12
	Powerdown_RC522(ENTER_POWERDOWN);
80004f60:	30 1c       	mov	r12,1
80004f62:	f0 1f 00 09 	mcall	80004f84 <scan_patrol+0x3c>
	if(return_err == 0)
80004f66:	58 07       	cp.w	r7,0
80004f68:	c0 51       	brne	80004f72 <scan_patrol+0x2a>
		log("scan_patrol okay!\n");
80004f6a:	48 9c       	lddpc	r12,80004f8c <scan_patrol+0x44>
80004f6c:	f0 1f 00 09 	mcall	80004f90 <scan_patrol+0x48>
80004f70:	c0 48       	rjmp	80004f78 <scan_patrol+0x30>
	else
		log("scan_patrol err!\n");
80004f72:	48 9c       	lddpc	r12,80004f94 <scan_patrol+0x4c>
80004f74:	f0 1f 00 07 	mcall	80004f90 <scan_patrol+0x48>
		
	return return_err;

}
80004f78:	0e 9c       	mov	r12,r7
80004f7a:	e3 cd 80 80 	ldm	sp++,r7,pc
80004f7e:	00 00       	add	r0,r0
80004f80:	80 00       	ld.sh	r0,r0[0x0]
80004f82:	47 ec       	lddsp	r12,sp[0x1f8]
80004f84:	80 00       	ld.sh	r0,r0[0x0]
80004f86:	48 c4       	lddpc	r4,80004fb4 <rfid_sendID_message+0x1c>
80004f88:	80 00       	ld.sh	r0,r0[0x0]
80004f8a:	4e 34       	lddpc	r4,80005114 <rfid_sendID_message+0x17c>
80004f8c:	80 00       	ld.sh	r0,r0[0x0]
80004f8e:	d6 b4       	*unknown*
80004f90:	80 00       	ld.sh	r0,r0[0x0]
80004f92:	6d ec       	ld.w	r12,r6[0x78]
80004f94:	80 00       	ld.sh	r0,r0[0x0]
80004f96:	d6 c8       	*unknown*

80004f98 <rfid_sendID_message>:

extern volatile DateTime_t Current_time;
/*the queue is used to receive failure-send message*/

U8 rfid_sendID_message()
{
80004f98:	eb cd 40 f8 	pushm	r3-r7,lr
80004f9c:	21 bd       	sub	sp,108
	U32 destination = DEST;
	static U8 start_session = 0x80;
	Message_Header_t header;
	Message_Data_t data_buffer;//22bytes
	
	memset(SN, 0x00, 10);
80004f9e:	4d 5a       	lddpc	r10,800050f0 <rfid_sendID_message+0x158>
80004fa0:	30 08       	mov	r8,0
80004fa2:	30 09       	mov	r9,0
80004fa4:	f4 e9 00 00 	st.d	r10[0],r8
80004fa8:	30 0b       	mov	r11,0
80004faa:	b4 4b       	st.h	r10[0x8],r11
	memset(message, 0x00, 80);
80004fac:	fa e9 00 1c 	st.d	sp[28],r8
80004fb0:	fa e9 00 24 	st.d	sp[36],r8
80004fb4:	fa e9 00 2c 	st.d	sp[44],r8
80004fb8:	fa e9 00 34 	st.d	sp[52],r8
80004fbc:	fa e9 00 3c 	st.d	sp[60],r8
80004fc0:	fa e9 00 44 	st.d	sp[68],r8
80004fc4:	fa e9 00 4c 	st.d	sp[76],r8
80004fc8:	fa e9 00 54 	st.d	sp[84],r8
80004fcc:	fa e9 00 5c 	st.d	sp[92],r8
80004fd0:	fa e9 00 64 	st.d	sp[100],r8
80004fd4:	30 07       	mov	r7,0
	
	//return_err = scan_patrol(SN);
	
	do 
	{	
		return_err = scan_patrol(SN);
80004fd6:	14 94       	mov	r4,r10
		if(return_err == 0)break;
		else
		{
			vTaskDelay(400*2 / portTICK_RATE_MS);//寤惰400ms
80004fd8:	e0 63 03 20 	mov	r3,800
		}
		connect_counts++;
		
	} while ((connect_counts < 7) && (return_err !=0));
80004fdc:	30 75       	mov	r5,7
	
	//return_err = scan_patrol(SN);
	
	do 
	{	
		return_err = scan_patrol(SN);
80004fde:	08 9c       	mov	r12,r4
80004fe0:	f0 1f 00 45 	mcall	800050f4 <rfid_sendID_message+0x15c>
80004fe4:	18 96       	mov	r6,r12
		if(return_err == 0)break;
80004fe6:	c0 a0       	breq	80004ffa <rfid_sendID_message+0x62>
		else
		{
			vTaskDelay(400*2 / portTICK_RATE_MS);//寤惰400ms
80004fe8:	06 9c       	mov	r12,r3
80004fea:	f0 1f 00 44 	mcall	800050f8 <rfid_sendID_message+0x160>
		}
		connect_counts++;
80004fee:	2f f7       	sub	r7,-1
80004ff0:	5c 57       	castu.b	r7
		
	} while ((connect_counts < 7) && (return_err !=0));
80004ff2:	ea 07 18 00 	cp.b	r7,r5
80004ff6:	cf 41       	brne	80004fde <rfid_sendID_message+0x46>
80004ff8:	c7 08       	rjmp	800050d8 <rfid_sendID_message+0x140>
	
	if(return_err == 0){
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
80004ffa:	4b e7       	lddpc	r7,800050f0 <rfid_sendID_message+0x158>
80004ffc:	0f b8       	ld.ub	r8,r7[0x3]
80004ffe:	1a d8       	st.w	--sp,r8
80005000:	0f a8       	ld.ub	r8,r7[0x2]
80005002:	1a d8       	st.w	--sp,r8
80005004:	0f 98       	ld.ub	r8,r7[0x1]
80005006:	1a d8       	st.w	--sp,r8
80005008:	0f 88       	ld.ub	r8,r7[0x0]
8000500a:	1a d8       	st.w	--sp,r8
8000500c:	4b cc       	lddpc	r12,800050fc <rfid_sendID_message+0x164>
8000500e:	f0 1f 00 3d 	mcall	80005100 <rfid_sendID_message+0x168>
		xcmp_IdleTestTone(Tone_Start, Ring_Style_Tone_8);//set tone to indicate scan rfid success!!!		 
80005012:	34 4b       	mov	r11,68
80005014:	30 1c       	mov	r12,1
80005016:	f0 1f 00 3c 	mcall	80005104 <rfid_sendID_message+0x16c>
8000501a:	fa c8 ff ee 	sub	r8,sp,-18
8000501e:	fa c9 ff ec 	sub	r9,sp,-20
}

extern volatile DateTime_t Current_time;
/*the queue is used to receive failure-send message*/

U8 rfid_sendID_message()
80005022:	ee c4 ff fc 	sub	r4,r7,-4
80005026:	2f cd       	sub	sp,-16
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, Ring_Style_Tone_8);//set tone to indicate scan rfid success!!!		 
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″	
		
			 temp = ((SN[i] & 0xF0) >> 4);//瀛楂浣
			 if((temp >= 0) && (temp <= 9))data_buffer.RFID_ID[i*4] = temp+0x30;
80005028:	30 95       	mov	r5,9
			 else 
				data_buffer.RFID_ID[i*4] = ((temp - 0x0a)+0x61);
			
			 data_buffer.RFID_ID[i*4+1] = 0x00;
8000502a:	30 0c       	mov	r12,0
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, Ring_Style_Tone_8);//set tone to indicate scan rfid success!!!		 
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″	
		
			 temp = ((SN[i] & 0xF0) >> 4);//瀛楂浣
8000502c:	0f 8a       	ld.ub	r10,r7[0x0]
8000502e:	f4 0b 16 04 	lsr	r11,r10,0x4
			 if((temp >= 0) && (temp <= 9))data_buffer.RFID_ID[i*4] = temp+0x30;
80005032:	ea 0b 18 00 	cp.b	r11,r5
80005036:	f7 bb 08 d0 	subls	r11,-48
8000503a:	f1 fb 8e 00 	st.bls	r8[0x0],r11
			 else 
				data_buffer.RFID_ID[i*4] = ((temp - 0x0a)+0x61);
8000503e:	f7 bb 0b a9 	subhi	r11,-87
80005042:	f1 fb be 00 	st.bhi	r8[0x0],r11
			
			 data_buffer.RFID_ID[i*4+1] = 0x00;
80005046:	b0 9c       	st.b	r8[0x1],r12
		 
			 temp = (SN[i] & 0x0F);//瀛浣浣
80005048:	f5 da c0 04 	bfextu	r10,r10,0x0,0x4
			 if((temp >= 0) && (temp <= 9))data_buffer.RFID_ID[i*4+2] = temp+0x30;
8000504c:	ea 0a 18 00 	cp.b	r10,r5
80005050:	f7 ba 08 d0 	subls	r10,-48
80005054:	f3 fa 8e 00 	st.bls	r9[0x0],r10
			 else
				data_buffer.RFID_ID[i*4+2] = ((temp - 0x0a)+0x61);
80005058:	f7 ba 0b a9 	subhi	r10,-87
8000505c:	f3 fa be 00 	st.bhi	r9[0x0],r10

			 data_buffer.RFID_ID[i*4+3] = 0x00; 
80005060:	b0 bc       	st.b	r8[0x3],r12
80005062:	2f f7       	sub	r7,-1
80005064:	2f c8       	sub	r8,-4
80005066:	2f c9       	sub	r9,-4
	
	if(return_err == 0){
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, Ring_Style_Tone_8);//set tone to indicate scan rfid success!!!		 
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″	
80005068:	08 37       	cp.w	r7,r4
8000506a:	ce 11       	brne	8000502c <rfid_sendID_message+0x94>
		
		//memcpy(&data_buffer.XG_Time.Year, &Current_time.Year, sizeof(DateTime_t))	;
	
		header.length = (0x0008 + sizeof(Message_Data_t));
	
		if(start_session > 0x9f)start_session = 0x80;
8000506c:	4a 78       	lddpc	r8,80005108 <rfid_sendID_message+0x170>
8000506e:	11 89       	ld.ub	r9,r8[0x0]
80005070:	39 f8       	mov	r8,-97
80005072:	f0 09 18 00 	cp.b	r9,r8
80005076:	e0 88 00 05 	brls	80005080 <rfid_sendID_message+0xe8>
8000507a:	38 09       	mov	r9,-128
8000507c:	4a 38       	lddpc	r8,80005108 <rfid_sendID_message+0x170>
8000507e:	b0 89       	st.b	r8[0x0],r9
	
		header.session_id = (++start_session);
80005080:	4a 28       	lddpc	r8,80005108 <rfid_sendID_message+0x170>
80005082:	11 87       	ld.ub	r7,r8[0x0]
80005084:	2f f7       	sub	r7,-1
80005086:	b0 87       	st.b	r8[0x0],r7
	
		memcpy(&header.fixed_data[0], unsure_data, sizeof(unsure_data));
80005088:	30 5a       	mov	r10,5
8000508a:	4a 1b       	lddpc	r11,8000510c <rfid_sendID_message+0x174>
8000508c:	fa cc ff e9 	sub	r12,sp,-23
80005090:	f0 1f 00 20 	mcall	80005110 <rfid_sendID_message+0x178>
		header.type = 0xe000;
	
		memcpy(message, &header, sizeof(Message_Header_t));//疯header版
80005094:	31 88       	mov	r8,24
80005096:	fb 58 00 12 	st.h	sp[18],r8
8000509a:	fb 67 00 16 	st.b	sp[22],r7
8000509e:	fe 78 e0 00 	mov	r8,-8192
800050a2:	fb 58 00 14 	st.h	sp[20],r8
800050a6:	fa c7 ff e4 	sub	r7,sp,-28
800050aa:	30 aa       	mov	r10,10
800050ac:	fa cb ff ee 	sub	r11,sp,-18
800050b0:	0e 9c       	mov	r12,r7
800050b2:	f0 1f 00 18 	mcall	80005110 <rfid_sendID_message+0x178>
		memcpy(&message[sizeof(Message_Header_t)], &data_buffer, sizeof(Message_Data_t));//疯淇″瀹规版
800050b6:	31 0a       	mov	r10,16
800050b8:	fa cb ff fe 	sub	r11,sp,-2
800050bc:	fa cc ff da 	sub	r12,sp,-38
800050c0:	f0 1f 00 14 	mcall	80005110 <rfid_sendID_message+0x178>
	
		xcmp_data_session_req(message, (sizeof(Message_Header_t)+sizeof(Message_Data_t)), destination);
800050c4:	e0 6a ff ff 	mov	r10,65535
800050c8:	31 ab       	mov	r11,26
800050ca:	0e 9c       	mov	r12,r7
800050cc:	f0 1f 00 12 	mcall	80005114 <rfid_sendID_message+0x17c>
		log("no card find...\n");
	}
	
	return return_err;
	
}
800050d0:	0c 9c       	mov	r12,r6
800050d2:	2e 5d       	sub	sp,-108
800050d4:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
		xcmp_data_session_req(message, (sizeof(Message_Header_t)+sizeof(Message_Data_t)), destination);
		
	}
	else
	{
		vTaskDelay(500*2 / portTICK_RATE_MS);//寤惰500ms
800050d8:	e0 6c 03 e8 	mov	r12,1000
800050dc:	f0 1f 00 07 	mcall	800050f8 <rfid_sendID_message+0x160>
		xcmp_IdleTestTone(Tone_Start, Low_Battery_3);//set tone to indicate scan rfid failure!!!
800050e0:	34 fb       	mov	r11,79
800050e2:	30 1c       	mov	r12,1
800050e4:	f0 1f 00 08 	mcall	80005104 <rfid_sendID_message+0x16c>
		log("no card find...\n");
800050e8:	48 cc       	lddpc	r12,80005118 <rfid_sendID_message+0x180>
800050ea:	f0 1f 00 06 	mcall	80005100 <rfid_sendID_message+0x168>
800050ee:	cf 1b       	rjmp	800050d0 <rfid_sendID_message+0x138>
800050f0:	00 00       	add	r0,r0
800050f2:	0b 5c       	ld.sh	r12,--r5
800050f4:	80 00       	ld.sh	r0,r0[0x0]
800050f6:	4f 48       	lddpc	r8,800052c4 <xg_flashc_init+0x74>
800050f8:	80 00       	ld.sh	r0,r0[0x0]
800050fa:	68 80       	ld.w	r0,r4[0x20]
800050fc:	80 00       	ld.sh	r0,r0[0x0]
800050fe:	d6 dc       	*unknown*
80005100:	80 00       	ld.sh	r0,r0[0x0]
80005102:	6d ec       	ld.w	r12,r6[0x78]
80005104:	80 00       	ld.sh	r0,r0[0x0]
80005106:	3f 40       	mov	r0,-12
80005108:	00 00       	add	r0,r0
8000510a:	05 28       	ld.uh	r8,r2++
8000510c:	00 00       	add	r0,r0
8000510e:	05 2c       	ld.uh	r12,r2++
80005110:	80 00       	ld.sh	r0,r0[0x0]
80005112:	76 68       	ld.w	r8,r11[0x18]
80005114:	80 00       	ld.sh	r0,r0[0x0]
80005116:	3d fc       	mov	r12,-33
80005118:	80 00       	ld.sh	r0,r0[0x0]
8000511a:	d7 20       	acall	0x72

8000511c <rfid_init>:
extern volatile U32 global_count;
extern volatile xSemaphoreHandle count_mutex;


void rfid_init()
{
8000511c:	d4 01       	pushm	lr
	char card_id[4]={0};
	//tc_init();//ㄥ跺200msㄥ诲
	
	rc522_init();
8000511e:	f0 1f 00 02 	mcall	80005124 <rfid_init+0x8>
	
	//if(rfid_auto_reader(card_id) == 0){
		//log("card_id : 0x%x, 0x%x, 0x%x, 0x%x\n", &card_id[0], &card_id[1], &card_id[2], &card_id[3]);	
	//}
		//
}
80005122:	d8 02       	popm	pc
80005124:	80 00       	ld.sh	r0,r0[0x0]
80005126:	49 fc       	lddpc	r12,800051a0 <local_start_timer+0x10>

80005128 <delay_ns>:
}

void delay_ns(U32 ns)
{
	U32 i;
	for(i=0;i<ns;i++)
80005128:	58 0c       	cp.w	r12,0
8000512a:	5e 0c       	reteq	r12
8000512c:	30 08       	mov	r8,0
	{
		nop();
8000512e:	d7 03       	nop
		nop();
80005130:	d7 03       	nop
		nop();
80005132:	d7 03       	nop
}

void delay_ns(U32 ns)
{
	U32 i;
	for(i=0;i<ns;i++)
80005134:	2f f8       	sub	r8,-1
80005136:	10 3c       	cp.w	r12,r8
80005138:	fe 9b ff fb 	brhi	8000512e <delay_ns+0x6>
8000513c:	5e fc       	retal	r12
8000513e:	d7 03       	nop

80005140 <delay_us>:
		nop();
		nop();
	}
}
void delay_us(U32 us)
{
80005140:	eb cd 40 e0 	pushm	r5-r7,lr
80005144:	18 96       	mov	r6,r12
	for(int i =0; i<us; i++){
80005146:	58 0c       	cp.w	r12,0
80005148:	c0 b0       	breq	8000515e <delay_us+0x1e>
8000514a:	30 07       	mov	r7,0
		delay_ns(1000);
8000514c:	e0 65 03 e8 	mov	r5,1000
80005150:	0a 9c       	mov	r12,r5
80005152:	f0 1f 00 05 	mcall	80005164 <delay_us+0x24>
		nop();
	}
}
void delay_us(U32 us)
{
	for(int i =0; i<us; i++){
80005156:	2f f7       	sub	r7,-1
80005158:	0e 36       	cp.w	r6,r7
8000515a:	fe 9b ff fb 	brhi	80005150 <delay_us+0x10>
8000515e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80005162:	00 00       	add	r0,r0
80005164:	80 00       	ld.sh	r0,r0[0x0]
80005166:	51 28       	stdsp	sp[0x48],r8

80005168 <delay_ms>:
		delay_ns(1000);
	}

}
void delay_ms(U32 ms)
{
80005168:	eb cd 40 e0 	pushm	r5-r7,lr
8000516c:	18 96       	mov	r6,r12
	for(int i =0; i<ms; i++){
8000516e:	58 0c       	cp.w	r12,0
80005170:	c0 b0       	breq	80005186 <delay_ms+0x1e>
80005172:	30 07       	mov	r7,0
		delay_us(1000);
80005174:	e0 65 03 e8 	mov	r5,1000
80005178:	0a 9c       	mov	r12,r5
8000517a:	f0 1f 00 05 	mcall	8000518c <delay_ms+0x24>
	}

}
void delay_ms(U32 ms)
{
	for(int i =0; i<ms; i++){
8000517e:	2f f7       	sub	r7,-1
80005180:	0e 36       	cp.w	r6,r7
80005182:	fe 9b ff fb 	brhi	80005178 <delay_ms+0x10>
80005186:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000518a:	00 00       	add	r0,r0
8000518c:	80 00       	ld.sh	r0,r0[0x0]
8000518e:	51 40       	stdsp	sp[0x50],r0

80005190 <local_start_timer>:
//	SSC_TX_DATA_ENABLE		AVR32_TC_A0_0_0_PIN					[32 PortB Pin  0 00000001 Func 0]
//	MAKO_TX					AVR32_SSC_TX_DATA_0_PIN				[42 PortB Pin 10 00000400 Func 0]
//	MAKO_RX					AVR32_SSC_RX_DATA_0_PIN				[39 PortB Pin  7 00000080 Func 0]
//
void local_start_timer(void)
{
80005190:	d4 01       	pushm	lr
	{
		{TIMER_TC_CLK_PIN,      TIMER_TC_CLK_FUNCTION     },
		{TIMER_TC_FS_PIN,       TIMER_TC_FS_FUNCTION      },
		{TIMER_EN_CLK_PIN,      TIMER_EN_CLK_FUNCTION     }
	};
	gpio_enable_module(TC_GPIO_MAP, sizeof(TC_GPIO_MAP) / sizeof(TC_GPIO_MAP[0]));
80005192:	30 3b       	mov	r11,3
80005194:	48 8c       	lddpc	r12,800051b4 <local_start_timer+0x24>
80005196:	f0 1f 00 09 	mcall	800051b8 <local_start_timer+0x28>

	(&AVR32_TC)->channel[0].cmr =
8000519a:	fe 78 38 00 	mov	r8,-51200
8000519e:	e0 69 91 0d 	mov	r9,37133
800051a2:	ea 19 00 52 	orh	r9,0x52
800051a6:	91 19       	st.w	r8[0x4],r9
	1                          << AVR32_TC_CLKI_OFFSET     |
	AVR32_TC_TCCLKS_XC0        << AVR32_TC_TCCLKS_OFFSET;



	(&AVR32_TC)->channel[0].ra = 32;
800051a8:	32 09       	mov	r9,32
800051aa:	91 59       	st.w	r8[0x14],r9
	(&AVR32_TC)->channel[0].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
800051ac:	30 59       	mov	r9,5
800051ae:	91 09       	st.w	r8[0x0],r9
}
800051b0:	d8 02       	popm	pc
800051b2:	00 00       	add	r0,r0
800051b4:	80 00       	ld.sh	r0,r0[0x0]
800051b6:	d7 34       	*unknown*
800051b8:	80 00       	ld.sh	r0,r0[0x0]
800051ba:	53 40       	stdsp	sp[0xd0],r0

800051bc <local_start_pll0>:
//In the SSC description, Master Clock (MCK) is the bus clock of the peripheral bus to which the
//SSC is connected. [23.6.2]
//Switch to clock Osc0 (crystal)
//start PLL0 and switch main clock to PLL0 output
void local_start_pll0(void)
{
800051bc:	d4 01       	pushm	lr
	AVR32_HMATRIX.mcfg[AVR32_HMATRIX_MASTER_CPU_INSTRUCTION] = 0x1;
	
***/
	
/*****/
	pm_switch_to_osc0(&AVR32_PM, 12000000, OSC0_STARTUP);
800051be:	30 3a       	mov	r10,3
800051c0:	e0 6b 1b 00 	mov	r11,6912
800051c4:	ea 1b 00 b7 	orh	r11,0xb7
800051c8:	fe 7c 0c 00 	mov	r12,-62464
800051cc:	f0 1f 00 19 	mcall	80005230 <local_start_pll0+0x74>

	pm_pll_setup(&AVR32_PM,
800051d0:	31 08       	mov	r8,16
800051d2:	1a d8       	st.w	--sp,r8
800051d4:	30 08       	mov	r8,0
800051d6:	30 19       	mov	r9,1
800051d8:	30 7a       	mov	r10,7
800051da:	10 9b       	mov	r11,r8
800051dc:	fe 7c 0c 00 	mov	r12,-62464
800051e0:	f0 1f 00 15 	mcall	80005234 <local_start_pll0+0x78>
	               0,   // use PLL0
	               7,   // MUL=7 in the formula
	               1,   // DIV=1 in the formula
	               0,   // Sel Osc0/PLL0 or Osc1/PLL1
	               16); // lockcount in main clock for the PLL wait lock
	pm_pll_set_option(&AVR32_PM, 0, //PLL number 0
800051e4:	30 08       	mov	r8,0
800051e6:	30 19       	mov	r9,1
800051e8:	12 9a       	mov	r10,r9
800051ea:	10 9b       	mov	r11,r8
800051ec:	fe 7c 0c 00 	mov	r12,-62464
800051f0:	f0 1f 00 12 	mcall	80005238 <local_start_pll0+0x7c>
	                        1, //freq Set to 1 for VCO frequency range 80-180MHz
	                        1, //div2 Divide the PLL output frequency by 2
	                        0);//0 to enable the Wide-Bandith Mode
	pm_pll_enable(&AVR32_PM,0);
800051f4:	30 0b       	mov	r11,0
800051f6:	fe 7c 0c 00 	mov	r12,-62464
800051fa:	f0 1f 00 11 	mcall	8000523c <local_start_pll0+0x80>


	pm_wait_for_pll0_locked(&AVR32_PM);
800051fe:	fe 7c 0c 00 	mov	r12,-62464
80005202:	f0 1f 00 10 	mcall	80005240 <local_start_pll0+0x84>


	pm_cksel(&AVR32_PM, 1,  //Bus A clock divisor enable = 1
80005206:	30 0a       	mov	r10,0
80005208:	1a da       	st.w	--sp,r10
8000520a:	1a da       	st.w	--sp,r10
8000520c:	14 98       	mov	r8,r10
8000520e:	14 99       	mov	r9,r10
80005210:	30 1b       	mov	r11,1
80005212:	fe 7c 0c 00 	mov	r12,-62464
80005216:	f0 1f 00 0c 	mcall	80005244 <local_start_pll0+0x88>
	             0,  //B clock divisor enable = 0
	             0,  //Bus B select = 0
	             0,  //HS Bus clock divisor enable = 0
	             0); //HS Bus select = 0
				 
	flashc_set_wait_state(1);
8000521a:	30 1c       	mov	r12,1
8000521c:	f0 1f 00 0b 	mcall	80005248 <local_start_pll0+0x8c>
	//AVR32_FLASHC.fcr = 0x00000040;

	pm_switch_to_clock(&AVR32_PM, AVR32_PM_MCSEL_PLL0);
80005220:	30 2b       	mov	r11,2
80005222:	fe 7c 0c 00 	mov	r12,-62464
80005226:	f0 1f 00 0a 	mcall	8000524c <local_start_pll0+0x90>
8000522a:	2f dd       	sub	sp,-12
/****/
}
8000522c:	d8 02       	popm	pc
8000522e:	00 00       	add	r0,r0
80005230:	80 00       	ld.sh	r0,r0[0x0]
80005232:	55 f4       	stdsp	sp[0x17c],r4
80005234:	80 00       	ld.sh	r0,r0[0x0]
80005236:	55 96       	stdsp	sp[0x164],r6
80005238:	80 00       	ld.sh	r0,r0[0x0]
8000523a:	55 b8       	stdsp	sp[0x16c],r8
8000523c:	80 00       	ld.sh	r0,r0[0x0]
8000523e:	55 d2       	stdsp	sp[0x174],r2
80005240:	80 00       	ld.sh	r0,r0[0x0]
80005242:	55 e0       	stdsp	sp[0x178],r0
80005244:	80 00       	ld.sh	r0,r0[0x0]
80005246:	55 50       	stdsp	sp[0x154],r0
80005248:	80 00       	ld.sh	r0,r0[0x0]
8000524a:	52 e0       	stdsp	sp[0xb8],r0
8000524c:	80 00       	ld.sh	r0,r0[0x0]
8000524e:	55 ea       	stdsp	sp[0x178],r10

80005250 <xg_flashc_init>:
}


//U16	Current_total_message_count=0;
void xg_flashc_init(void)
{
80005250:	eb cd 40 e0 	pushm	r5-r7,lr
	//{
		//log("Create the xgflash_mutex semaphore failure\n");
	//}
	//
	/* Create the binary semaphore to Synchronize other threads.*/
	vSemaphoreCreateBinary(xBinarySemaphore);
80005254:	30 0b       	mov	r11,0
80005256:	30 1c       	mov	r12,1
80005258:	f0 1f 00 19 	mcall	800052bc <xg_flashc_init+0x6c>
8000525c:	49 98       	lddpc	r8,800052c0 <xg_flashc_init+0x70>
8000525e:	91 0c       	st.w	r8[0x0],r12
80005260:	70 08       	ld.w	r8,r8[0x0]
80005262:	58 08       	cp.w	r8,0
80005264:	c0 80       	breq	80005274 <xg_flashc_init+0x24>
80005266:	49 78       	lddpc	r8,800052c0 <xg_flashc_init+0x70>
80005268:	70 0c       	ld.w	r12,r8[0x0]
8000526a:	30 09       	mov	r9,0
8000526c:	12 9a       	mov	r10,r9
8000526e:	12 9b       	mov	r11,r9
80005270:	f0 1f 00 15 	mcall	800052c4 <xg_flashc_init+0x74>
	if (xBinarySemaphore == NULL)
80005274:	49 38       	lddpc	r8,800052c0 <xg_flashc_init+0x70>
80005276:	70 08       	ld.w	r8,r8[0x0]
80005278:	58 08       	cp.w	r8,0
8000527a:	c0 41       	brne	80005282 <xg_flashc_init+0x32>
	{
		log("Create the xBinarySemaphore failure\n");
8000527c:	49 3c       	lddpc	r12,800052c8 <xg_flashc_init+0x78>
8000527e:	f0 1f 00 14 	mcall	800052cc <xg_flashc_init+0x7c>
	//if (SendM_CountingSemaphore == NULL)
	//{
		//log("Create the SendM_Counting semaphore failure\n");
	//}
	//
	xg_resend_queue = xQueueCreate(300, sizeof(U32));
80005282:	30 4b       	mov	r11,4
80005284:	e0 6c 01 2c 	mov	r12,300
80005288:	f0 1f 00 0d 	mcall	800052bc <xg_flashc_init+0x6c>
8000528c:	49 18       	lddpc	r8,800052d0 <xg_flashc_init+0x80>
8000528e:	91 0c       	st.w	r8[0x0],r12
	/*initialize the queue*/
	message_storage_queue = xQueueCreate(MAX_MESSAGE_STORE, sizeof(U32));
80005290:	30 4b       	mov	r11,4
80005292:	e0 6c 01 90 	mov	r12,400
80005296:	f0 1f 00 0a 	mcall	800052bc <xg_flashc_init+0x6c>
8000529a:	48 f8       	lddpc	r8,800052d4 <xg_flashc_init+0x84>
8000529c:	91 0c       	st.w	r8[0x0],r12
8000529e:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_MESSAGE_STORE; i++ )
	{
		set_message_store(&message_store[i]);//push <message_store> address to the message_storage_queue;
800052a0:	10 96       	mov	r6,r8
800052a2:	48 e5       	lddpc	r5,800052d8 <xg_flashc_init+0x88>
800052a4:	6c 0c       	ld.w	r12,r6[0x0]
800052a6:	ea 07 00 0b 	add	r11,r5,r7
800052aa:	f0 1f 00 0d 	mcall	800052dc <xg_flashc_init+0x8c>
800052ae:	2e 67       	sub	r7,-26
	//}
	//
	xg_resend_queue = xQueueCreate(300, sizeof(U32));
	/*initialize the queue*/
	message_storage_queue = xQueueCreate(MAX_MESSAGE_STORE, sizeof(U32));
	for(int i= 0; i < MAX_MESSAGE_STORE; i++ )
800052b0:	e0 47 28 a0 	cp.w	r7,10400
800052b4:	cf 81       	brne	800052a4 <xg_flashc_init+0x54>
	//flashc_lock_all_regions(false);
	//xgflash_list_info_init();
	
	
	//create_xg_flash_test_task();
}
800052b6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800052ba:	00 00       	add	r0,r0
800052bc:	80 00       	ld.sh	r0,r0[0x0]
800052be:	63 0c       	ld.w	r12,r1[0x40]
800052c0:	00 00       	add	r0,r0
800052c2:	0b 70       	ld.ub	r0,--r5
800052c4:	80 00       	ld.sh	r0,r0[0x0]
800052c6:	61 b4       	ld.w	r4,r0[0x6c]
800052c8:	80 00       	ld.sh	r0,r0[0x0]
800052ca:	d7 4c       	*unknown*
800052cc:	80 00       	ld.sh	r0,r0[0x0]
800052ce:	6d ec       	ld.w	r12,r6[0x78]
800052d0:	00 00       	add	r0,r0
800052d2:	0b 68       	ld.uh	r8,--r5
800052d4:	00 00       	add	r0,r0
800052d6:	0b 6c       	ld.uh	r12,--r5
800052d8:	00 00       	add	r0,r0
800052da:	97 40       	st.w	r11[0x10],r0
800052dc:	80 00       	ld.sh	r0,r0[0x0]
800052de:	2a d8       	sub	r8,-83

800052e0 <flashc_set_wait_state>:
}


void flashc_set_wait_state(unsigned int wait_state)
{
	u_avr32_flashc_fcr_t u_avr32_flashc_fcr = {AVR32_FLASHC.fcr};
800052e0:	fe 68 14 00 	mov	r8,-125952
800052e4:	70 09       	ld.w	r9,r8[0x0]
	u_avr32_flashc_fcr.FCR.fws = wait_state;
800052e6:	f3 dc d0 c1 	bfins	r9,r12,0x6,0x1
	AVR32_FLASHC.fcr = u_avr32_flashc_fcr.fcr;
800052ea:	91 09       	st.w	r8[0x0],r9
}
800052ec:	5e fc       	retal	r12

800052ee <gpio_enable_module_pin>:
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
800052ee:	f8 08 16 05 	lsr	r8,r12,0x5
800052f2:	a9 68       	lsl	r8,0x8
800052f4:	e0 28 f0 00 	sub	r8,61440

	/* Enable the correct function. */
	switch (function) {
800052f8:	58 1b       	cp.w	r11,1
800052fa:	c0 d0       	breq	80005314 <gpio_enable_module_pin+0x26>
800052fc:	c0 63       	brcs	80005308 <gpio_enable_module_pin+0x1a>
800052fe:	58 2b       	cp.w	r11,2
80005300:	c1 00       	breq	80005320 <gpio_enable_module_pin+0x32>
80005302:	58 3b       	cp.w	r11,3
80005304:	c1 40       	breq	8000532c <gpio_enable_module_pin+0x3e>
80005306:	5e ff       	retal	1
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80005308:	30 19       	mov	r9,1
8000530a:	f2 0c 09 49 	lsl	r9,r9,r12
8000530e:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80005310:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80005312:	c1 28       	rjmp	80005336 <gpio_enable_module_pin+0x48>

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80005314:	30 19       	mov	r9,1
80005316:	f2 0c 09 49 	lsl	r9,r9,r12
8000531a:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
8000531c:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
8000531e:	c0 c8       	rjmp	80005336 <gpio_enable_module_pin+0x48>

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80005320:	30 19       	mov	r9,1
80005322:	f2 0c 09 49 	lsl	r9,r9,r12
80005326:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80005328:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
8000532a:	c0 68       	rjmp	80005336 <gpio_enable_module_pin+0x48>

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
8000532c:	30 19       	mov	r9,1
8000532e:	f2 0c 09 49 	lsl	r9,r9,r12
80005332:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80005334:	91 99       	st.w	r8[0x24],r9
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
80005336:	30 19       	mov	r9,1
80005338:	f2 0c 09 4c 	lsl	r12,r9,r12
8000533c:	91 2c       	st.w	r8[0x8],r12
8000533e:	5e fd       	retal	0

80005340 <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
80005340:	d4 21       	pushm	r4-r7,lr
80005342:	18 97       	mov	r7,r12
80005344:	16 94       	mov	r4,r11
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
80005346:	58 0b       	cp.w	r11,0
80005348:	c0 31       	brne	8000534e <gpio_enable_module+0xe>
8000534a:	30 05       	mov	r5,0
8000534c:	c0 d8       	rjmp	80005366 <gpio_enable_module+0x26>
8000534e:	30 06       	mov	r6,0
80005350:	0c 95       	mov	r5,r6
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
80005352:	6e 1b       	ld.w	r11,r7[0x4]
80005354:	6e 0c       	ld.w	r12,r7[0x0]
80005356:	f0 1f 00 06 	mcall	8000536c <gpio_enable_module+0x2c>
8000535a:	18 45       	or	r5,r12
		gpiomap++;
8000535c:	2f 87       	sub	r7,-8
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
8000535e:	2f f6       	sub	r6,-1
80005360:	0c 34       	cp.w	r4,r6
80005362:	fe 9b ff f8 	brhi	80005352 <gpio_enable_module+0x12>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
}
80005366:	0a 9c       	mov	r12,r5
80005368:	d8 22       	popm	r4-r7,pc
8000536a:	00 00       	add	r0,r0
8000536c:	80 00       	ld.sh	r0,r0[0x0]
8000536e:	52 ee       	stdsp	sp[0xb8],lr

80005370 <gpio_enable_gpio_pin>:
 *            AVR32_PWM_3_PIN for PWM channel 3 can also be used to release
 *            module pins for GPIO.
 */
void gpio_enable_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80005370:	f8 08 16 05 	lsr	r8,r12,0x5
80005374:	a9 68       	lsl	r8,0x8
80005376:	e0 28 f0 00 	sub	r8,61440
	
	gpio_port->oderc = 1 << (pin & 0x1F);
8000537a:	30 19       	mov	r9,1
8000537c:	f2 0c 09 4c 	lsl	r12,r9,r12
80005380:	f1 4c 00 48 	st.w	r8[72],r12
	gpio_port->gpers = 1 << (pin & 0x1F);
80005384:	91 1c       	st.w	r8[0x4],r12
}
80005386:	5e fc       	retal	r12

80005388 <gpio_set_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_set_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80005388:	f8 08 16 05 	lsr	r8,r12,0x5
8000538c:	a9 68       	lsl	r8,0x8
8000538e:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 1. */
	gpio_port->ovrs  = 1 << (pin & 0x1F);
80005392:	30 19       	mov	r9,1
80005394:	f2 0c 09 4c 	lsl	r12,r9,r12
80005398:	f1 4c 00 54 	st.w	r8[84],r12
	/* The GPIO output driver is enabled for that pin. */ 
	gpio_port->oders = 1 << (pin & 0x1F);
8000539c:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
800053a0:	91 1c       	st.w	r8[0x4],r12
}
800053a2:	5e fc       	retal	r12

800053a4 <gpio_clr_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_clr_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
800053a4:	f8 08 16 05 	lsr	r8,r12,0x5
800053a8:	a9 68       	lsl	r8,0x8
800053aa:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 0. */
	gpio_port->ovrc  = 1 << (pin & 0x1F);
800053ae:	30 19       	mov	r9,1
800053b0:	f2 0c 09 4c 	lsl	r12,r9,r12
800053b4:	f1 4c 00 58 	st.w	r8[88],r12
	/* The GPIO output driver is enabled for that pin. */
	gpio_port->oders = 1 << (pin & 0x1F);
800053b8:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
800053bc:	91 1c       	st.w	r8[0x4],r12
}
800053be:	5e fc       	retal	r12

800053c0 <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
800053c0:	c0 08       	rjmp	800053c0 <_unhandled_interrupt>
800053c2:	d7 03       	nop

800053c4 <INTC_register_interrupt>:
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
800053c4:	f6 08 16 05 	lsr	r8,r11,0x5

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
800053c8:	49 99       	lddpc	r9,8000542c <INTC_register_interrupt+0x68>
800053ca:	f2 08 00 39 	add	r9,r9,r8<<0x3
800053ce:	f7 db c0 05 	bfextu	r11,r11,0x0,0x5
800053d2:	72 19       	ld.w	r9,r9[0x4]
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
800053d4:	f2 0b 09 2c 	st.w	r9[r11<<0x2],r12
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
800053d8:	58 0a       	cp.w	r10,0
800053da:	c0 91       	brne	800053ec <INTC_register_interrupt+0x28>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
800053dc:	49 59       	lddpc	r9,80005430 <INTC_register_interrupt+0x6c>
800053de:	49 6a       	lddpc	r10,80005434 <INTC_register_interrupt+0x70>
800053e0:	12 1a       	sub	r10,r9
800053e2:	fe 79 08 00 	mov	r9,-63488
800053e6:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800053ea:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT1) {
800053ec:	58 1a       	cp.w	r10,1
800053ee:	c0 a1       	brne	80005402 <INTC_register_interrupt+0x3e>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
800053f0:	49 09       	lddpc	r9,80005430 <INTC_register_interrupt+0x6c>
800053f2:	49 2a       	lddpc	r10,80005438 <INTC_register_interrupt+0x74>
800053f4:	12 1a       	sub	r10,r9
800053f6:	bf aa       	sbr	r10,0x1e
800053f8:	fe 79 08 00 	mov	r9,-63488
800053fc:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80005400:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT2) {
80005402:	58 2a       	cp.w	r10,2
80005404:	c0 a1       	brne	80005418 <INTC_register_interrupt+0x54>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
80005406:	48 b9       	lddpc	r9,80005430 <INTC_register_interrupt+0x6c>
80005408:	48 da       	lddpc	r10,8000543c <INTC_register_interrupt+0x78>
8000540a:	12 1a       	sub	r10,r9
8000540c:	bf ba       	sbr	r10,0x1f
8000540e:	fe 79 08 00 	mov	r9,-63488
80005412:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80005416:	5e fc       	retal	r12
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
80005418:	48 69       	lddpc	r9,80005430 <INTC_register_interrupt+0x6c>
8000541a:	48 aa       	lddpc	r10,80005440 <INTC_register_interrupt+0x7c>
8000541c:	12 1a       	sub	r10,r9
8000541e:	ea 1a c0 00 	orh	r10,0xc000
80005422:	fe 79 08 00 	mov	r9,-63488
80005426:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
8000542a:	5e fc       	retal	r12
8000542c:	80 00       	ld.sh	r0,r0[0x0]
8000542e:	d7 84       	*unknown*
80005430:	80 00       	ld.sh	r0,r0[0x0]
80005432:	cc 00       	breq	800053b2 <gpio_clr_gpio_pin+0xe>
80005434:	80 00       	ld.sh	r0,r0[0x0]
80005436:	cd 04       	brge	800053d6 <INTC_register_interrupt+0x12>
80005438:	80 00       	ld.sh	r0,r0[0x0]
8000543a:	cd 12       	brcc	800053dc <INTC_register_interrupt+0x18>
8000543c:	80 00       	ld.sh	r0,r0[0x0]
8000543e:	cd 20       	breq	800053e2 <INTC_register_interrupt+0x1e>
80005440:	80 00       	ld.sh	r0,r0[0x0]
80005442:	cd 2e       	rcall	800051e6 <local_start_pll0+0x2a>

80005444 <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
80005444:	d4 21       	pushm	r4-r7,lr
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
80005446:	49 18       	lddpc	r8,80005488 <INTC_init_interrupts+0x44>
80005448:	e3 b8 00 01 	mtsr	0x4,r8
8000544c:	49 0e       	lddpc	lr,8000548c <INTC_init_interrupts+0x48>
8000544e:	30 07       	mov	r7,0
80005450:	0e 94       	mov	r4,r7
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
80005452:	49 0c       	lddpc	r12,80005490 <INTC_init_interrupts+0x4c>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80005454:	49 05       	lddpc	r5,80005494 <INTC_init_interrupts+0x50>
80005456:	10 15       	sub	r5,r8
80005458:	fe 76 08 00 	mov	r6,-63488
8000545c:	c1 08       	rjmp	8000547c <INTC_init_interrupts+0x38>
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
8000545e:	08 98       	mov	r8,r4
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
				._int_line_handler_table[int_req]
80005460:	7c 1b       	ld.w	r11,lr[0x4]

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80005462:	7c 0a       	ld.w	r10,lr[0x0]
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
80005464:	f6 08 09 2c 	st.w	r11[r8<<0x2],r12
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
80005468:	2f f8       	sub	r8,-1

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
8000546a:	10 3a       	cp.w	r10,r8
8000546c:	fe 9b ff fc 	brhi	80005464 <INTC_init_interrupts+0x20>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80005470:	ec 07 09 25 	st.w	r6[r7<<0x2],r5
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
80005474:	2f f7       	sub	r7,-1
80005476:	2f 8e       	sub	lr,-8
80005478:	59 37       	cp.w	r7,19
8000547a:	c0 50       	breq	80005484 <INTC_init_interrupts+0x40>
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
8000547c:	7c 08       	ld.w	r8,lr[0x0]
8000547e:	58 08       	cp.w	r8,0
80005480:	ce f1       	brne	8000545e <INTC_init_interrupts+0x1a>
80005482:	cf 7b       	rjmp	80005470 <INTC_init_interrupts+0x2c>
80005484:	d8 22       	popm	r4-r7,pc
80005486:	00 00       	add	r0,r0
80005488:	80 00       	ld.sh	r0,r0[0x0]
8000548a:	cc 00       	breq	8000540a <INTC_register_interrupt+0x46>
8000548c:	80 00       	ld.sh	r0,r0[0x0]
8000548e:	d7 84       	*unknown*
80005490:	80 00       	ld.sh	r0,r0[0x0]
80005492:	53 c0       	stdsp	sp[0xf0],r0
80005494:	80 00       	ld.sh	r0,r0[0x0]
80005496:	cd 04       	brge	80005436 <INTC_register_interrupt+0x72>

80005498 <_get_interrupt_handler>:
__int_handler _get_interrupt_handler(uint32_t int_level)
{
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
80005498:	fe 78 08 00 	mov	r8,-63488
8000549c:	e0 69 00 83 	mov	r9,131
800054a0:	f2 0c 01 0c 	sub	r12,r9,r12
800054a4:	f0 0c 03 29 	ld.w	r9,r8[r12<<0x2]
	uint32_t int_req = AVR32_INTC.irr[int_grp];
800054a8:	f2 ca ff c0 	sub	r10,r9,-64
800054ac:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
800054b0:	58 08       	cp.w	r8,0
800054b2:	c0 21       	brne	800054b6 <_get_interrupt_handler+0x1e>
800054b4:	5e fd       	retal	0
		? _int_handler_table[int_grp]._int_line_handler_table[32
800054b6:	f0 08 12 00 	clz	r8,r8
800054ba:	48 5a       	lddpc	r10,800054cc <_get_interrupt_handler+0x34>
800054bc:	f4 09 00 39 	add	r9,r10,r9<<0x3
800054c0:	f0 08 11 1f 	rsub	r8,r8,31
800054c4:	72 19       	ld.w	r9,r9[0x4]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
800054c6:	f2 08 03 2c 	ld.w	r12,r9[r8<<0x2]
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
800054ca:	5e fc       	retal	r12
800054cc:	80 00       	ld.sh	r0,r0[0x0]
800054ce:	d7 84       	*unknown*

800054d0 <pm_set_osc0_mode>:
 * \param mode Oscillator 0 mode (i.e. AVR32_PM_OSCCTRL0_MODE_x).
 */
static void pm_set_osc0_mode(volatile avr32_pm_t *pm, unsigned int mode)
{
  // Read
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
800054d0:	78 a8       	ld.w	r8,r12[0x28]
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.mode = mode;
800054d2:	f1 db d0 03 	bfins	r8,r11,0x0,0x3
  // Write
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
800054d6:	99 a8       	st.w	r12[0x28],r8
}
800054d8:	5e fc       	retal	r12
800054da:	d7 03       	nop

800054dc <pm_enable_osc0_crystal>:
  pm_set_osc0_mode(pm, AVR32_PM_OSCCTRL0_MODE_EXT_CLOCK);
}


void pm_enable_osc0_crystal(volatile avr32_pm_t *pm, unsigned int fosc0)
{
800054dc:	d4 01       	pushm	lr
  pm_set_osc0_mode(pm, (fosc0 <  900000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G0 :
800054de:	ec 5b bb 9f 	cp.w	r11,899999
800054e2:	e0 8b 00 04 	brhi	800054ea <pm_enable_osc0_crystal+0xe>
800054e6:	30 4b       	mov	r11,4
800054e8:	c1 38       	rjmp	8000550e <pm_enable_osc0_crystal+0x32>
800054ea:	e0 68 c6 bf 	mov	r8,50879
800054ee:	ea 18 00 2d 	orh	r8,0x2d
800054f2:	10 3b       	cp.w	r11,r8
800054f4:	e0 8b 00 04 	brhi	800054fc <pm_enable_osc0_crystal+0x20>
800054f8:	30 5b       	mov	r11,5
800054fa:	c0 a8       	rjmp	8000550e <pm_enable_osc0_crystal+0x32>
800054fc:	e0 68 12 00 	mov	r8,4608
80005500:	ea 18 00 7a 	orh	r8,0x7a
80005504:	10 3b       	cp.w	r11,r8
80005506:	f9 bb 03 06 	movlo	r11,6
8000550a:	f9 bb 02 07 	movhs	r11,7
8000550e:	f0 1f 00 02 	mcall	80005514 <pm_enable_osc0_crystal+0x38>
                       (fosc0 < 3000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G1 :
                       (fosc0 < 8000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G2 :
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}
80005512:	d8 02       	popm	pc
80005514:	80 00       	ld.sh	r0,r0[0x0]
80005516:	54 d0       	stdsp	sp[0x134],r0

80005518 <pm_enable_clk0_no_wait>:


void pm_enable_clk0_no_wait(volatile avr32_pm_t *pm, unsigned int startup)
{
  // Read register
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
80005518:	78 a8       	ld.w	r8,r12[0x28]
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.startup = startup;
8000551a:	f1 db d1 03 	bfins	r8,r11,0x8,0x3
  // Write back
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
8000551e:	99 a8       	st.w	r12[0x28],r8

  pm->mcctrl |= AVR32_PM_MCCTRL_OSC0EN_MASK;
80005520:	78 08       	ld.w	r8,r12[0x0]
80005522:	a3 a8       	sbr	r8,0x2
80005524:	99 08       	st.w	r12[0x0],r8
}
80005526:	5e fc       	retal	r12

80005528 <pm_wait_for_clk0_ready>:


void pm_wait_for_clk0_ready(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
80005528:	79 58       	ld.w	r8,r12[0x54]
8000552a:	e2 18 00 80 	andl	r8,0x80,COH
8000552e:	cf d0       	breq	80005528 <pm_wait_for_clk0_ready>
}
80005530:	5e fc       	retal	r12
80005532:	d7 03       	nop

80005534 <pm_enable_clk0>:
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}


void pm_enable_clk0(volatile avr32_pm_t *pm, unsigned int startup)
{
80005534:	eb cd 40 80 	pushm	r7,lr
80005538:	18 97       	mov	r7,r12
  pm_enable_clk0_no_wait(pm, startup);
8000553a:	f0 1f 00 04 	mcall	80005548 <pm_enable_clk0+0x14>
  pm_wait_for_clk0_ready(pm);
8000553e:	0e 9c       	mov	r12,r7
80005540:	f0 1f 00 03 	mcall	8000554c <pm_enable_clk0+0x18>
}
80005544:	e3 cd 80 80 	ldm	sp++,r7,pc
80005548:	80 00       	ld.sh	r0,r0[0x0]
8000554a:	55 18       	stdsp	sp[0x144],r8
8000554c:	80 00       	ld.sh	r0,r0[0x0]
8000554e:	55 28       	stdsp	sp[0x148],r8

80005550 <pm_cksel>:
              unsigned int pbasel,
              unsigned int pbbdiv,
              unsigned int pbbsel,
              unsigned int hsbdiv,
              unsigned int hsbsel)
{
80005550:	eb cd 40 d0 	pushm	r4,r6-r7,lr
80005554:	fa c4 ff f0 	sub	r4,sp,-16
  u_avr32_pm_cksel_t u_avr32_pm_cksel = {0};
80005558:	30 0e       	mov	lr,0

  u_avr32_pm_cksel.CKSEL.cpusel = hsbsel;
8000555a:	09 f7       	ld.ub	r7,r4[0x7]
8000555c:	ef d7 c0 03 	bfextu	r7,r7,0x0,0x3
80005560:	fd d7 d0 03 	bfins	lr,r7,0x0,0x3
  u_avr32_pm_cksel.CKSEL.cpudiv = hsbdiv;
80005564:	09 b4       	ld.ub	r4,r4[0x3]
80005566:	08 96       	mov	r6,r4
80005568:	e9 d4 c0 01 	bfextu	r4,r4,0x0,0x1
8000556c:	fd d4 d0 e1 	bfins	lr,r4,0x7,0x1
  u_avr32_pm_cksel.CKSEL.hsbsel = hsbsel;
80005570:	fd d7 d1 03 	bfins	lr,r7,0x8,0x3
  u_avr32_pm_cksel.CKSEL.hsbdiv = hsbdiv;
80005574:	fd d4 d1 e1 	bfins	lr,r4,0xf,0x1
  u_avr32_pm_cksel.CKSEL.pbasel = pbasel;
80005578:	fd da d2 03 	bfins	lr,r10,0x10,0x3
  u_avr32_pm_cksel.CKSEL.pbadiv = pbadiv;
8000557c:	fd db d2 e1 	bfins	lr,r11,0x17,0x1
  u_avr32_pm_cksel.CKSEL.pbbsel = pbbsel;
80005580:	fd d8 d3 03 	bfins	lr,r8,0x18,0x3
  u_avr32_pm_cksel.CKSEL.pbbdiv = pbbdiv;
80005584:	fd d9 d3 e1 	bfins	lr,r9,0x1f,0x1

  pm->cksel = u_avr32_pm_cksel.cksel;
80005588:	99 1e       	st.w	r12[0x4],lr

  // Wait for ckrdy bit and then clear it
  while (!(pm->poscsr & AVR32_PM_POSCSR_CKRDY_MASK));
8000558a:	79 58       	ld.w	r8,r12[0x54]
8000558c:	e2 18 00 20 	andl	r8,0x20,COH
80005590:	cf d0       	breq	8000558a <pm_cksel+0x3a>
}
80005592:	e3 cd 80 d0 	ldm	sp++,r4,r6-r7,pc

80005596 <pm_pll_setup>:
                  unsigned int pll,
                  unsigned int mul,
                  unsigned int div,
                  unsigned int osc,
                  unsigned int lockcount)
{
80005596:	eb cd 40 80 	pushm	r7,lr
8000559a:	40 27       	lddsp	r7,sp[0x8]
  u_avr32_pm_pll_t u_avr32_pm_pll = {0};
8000559c:	30 0e       	mov	lr,0

  u_avr32_pm_pll.PLL.pllosc   = osc;
8000559e:	fd d8 d0 21 	bfins	lr,r8,0x1,0x1
  u_avr32_pm_pll.PLL.plldiv   = div;
800055a2:	fd d9 d1 04 	bfins	lr,r9,0x8,0x4
  u_avr32_pm_pll.PLL.pllmul   = mul;
800055a6:	fd da d2 04 	bfins	lr,r10,0x10,0x4
  u_avr32_pm_pll.PLL.pllcount = lockcount;
800055aa:	fd d7 d3 06 	bfins	lr,r7,0x18,0x6

  pm->pll[pll] = u_avr32_pm_pll.pll;
800055ae:	2f 8b       	sub	r11,-8
800055b0:	f8 0b 09 2e 	st.w	r12[r11<<0x2],lr
}
800055b4:	e3 cd 80 80 	ldm	sp++,r7,pc

800055b8 <pm_pll_set_option>:
void pm_pll_set_option(volatile avr32_pm_t *pm,
                       unsigned int pll,
                       unsigned int pll_freq,
                       unsigned int pll_div2,
                       unsigned int pll_wbwdisable)
{
800055b8:	d4 01       	pushm	lr
  u_avr32_pm_pll_t u_avr32_pm_pll = {pm->pll[pll]};
800055ba:	2f 8b       	sub	r11,-8
800055bc:	f8 0b 03 2e 	ld.w	lr,r12[r11<<0x2]
  u_avr32_pm_pll.PLL.pllopt = pll_freq | (pll_div2 << 1) | (pll_wbwdisable << 2);
800055c0:	f5 e9 10 19 	or	r9,r10,r9<<0x1
800055c4:	f3 e8 10 28 	or	r8,r9,r8<<0x2
800055c8:	fd d8 d0 43 	bfins	lr,r8,0x2,0x3
  pm->pll[pll] = u_avr32_pm_pll.pll;
800055cc:	f8 0b 09 2e 	st.w	r12[r11<<0x2],lr
}
800055d0:	d8 02       	popm	pc

800055d2 <pm_pll_enable>:


void pm_pll_enable(volatile avr32_pm_t *pm,
                  unsigned int pll)
{
  pm->pll[pll] |= AVR32_PM_PLLEN_MASK;
800055d2:	2f 8b       	sub	r11,-8
800055d4:	f8 0b 03 28 	ld.w	r8,r12[r11<<0x2]
800055d8:	a1 a8       	sbr	r8,0x0
800055da:	f8 0b 09 28 	st.w	r12[r11<<0x2],r8
}
800055de:	5e fc       	retal	r12

800055e0 <pm_wait_for_pll0_locked>:
}


void pm_wait_for_pll0_locked(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_LOCK0_MASK));
800055e0:	79 58       	ld.w	r8,r12[0x54]
800055e2:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800055e6:	cf d0       	breq	800055e0 <pm_wait_for_pll0_locked>
}
800055e8:	5e fc       	retal	r12

800055ea <pm_switch_to_clock>:


void pm_switch_to_clock(volatile avr32_pm_t *pm, unsigned long clock)
{
  // Read
  u_avr32_pm_mcctrl_t u_avr32_pm_mcctrl = {pm->mcctrl};
800055ea:	78 08       	ld.w	r8,r12[0x0]
  // Modify
  u_avr32_pm_mcctrl.MCCTRL.mcsel = clock;
800055ec:	f1 db d0 02 	bfins	r8,r11,0x0,0x2
  // Write back
  pm->mcctrl = u_avr32_pm_mcctrl.mcctrl;
800055f0:	99 08       	st.w	r12[0x0],r8
}
800055f2:	5e fc       	retal	r12

800055f4 <pm_switch_to_osc0>:


void pm_switch_to_osc0(volatile avr32_pm_t *pm, unsigned int fosc0, unsigned int startup)
{
800055f4:	eb cd 40 c0 	pushm	r6-r7,lr
800055f8:	18 97       	mov	r7,r12
800055fa:	14 96       	mov	r6,r10
  pm_enable_osc0_crystal(pm, fosc0);            // Enable the Osc0 in crystal mode
800055fc:	f0 1f 00 06 	mcall	80005614 <pm_switch_to_osc0+0x20>
  pm_enable_clk0(pm, startup);                  // Crystal startup time - This parameter is critical and depends on the characteristics of the crystal
80005600:	0c 9b       	mov	r11,r6
80005602:	0e 9c       	mov	r12,r7
80005604:	f0 1f 00 05 	mcall	80005618 <pm_switch_to_osc0+0x24>
  pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);  // Then switch main clock to Osc0
80005608:	30 1b       	mov	r11,1
8000560a:	0e 9c       	mov	r12,r7
8000560c:	f0 1f 00 04 	mcall	8000561c <pm_switch_to_osc0+0x28>
}
80005610:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005614:	80 00       	ld.sh	r0,r0[0x0]
80005616:	54 dc       	stdsp	sp[0x134],r12
80005618:	80 00       	ld.sh	r0,r0[0x0]
8000561a:	55 34       	stdsp	sp[0x14c],r4
8000561c:	80 00       	ld.sh	r0,r0[0x0]
8000561e:	55 ea       	stdsp	sp[0x178],r10

80005620 <getBaudDiv>:
xSemaphoreHandle xSPIMutex;
#endif

int16_t getBaudDiv(const uint32_t baudrate, uint32_t pb_hz)
{
	uint32_t baudDiv = div_ceil(pb_hz, baudrate);
80005620:	f8 c8 00 01 	sub	r8,r12,1
80005624:	f0 0b 00 0b 	add	r11,r8,r11
80005628:	f6 0c 0d 0a 	divu	r10,r11,r12
8000562c:	14 9c       	mov	r12,r10

	if (baudDiv <= 0 || baudDiv > 255) {
8000562e:	f4 c8 00 01 	sub	r8,r10,1
80005632:	e0 48 00 fe 	cp.w	r8,254
80005636:	e0 88 00 03 	brls	8000563c <getBaudDiv+0x1c>
8000563a:	5e fe       	retal	-1
		return -1;
	}

	return baudDiv;
8000563c:	5c 8c       	casts.h	r12
}
8000563e:	5e fc       	retal	r12

80005640 <spi_initMaster>:
spi_status_t spi_initMaster(volatile avr32_spi_t *spi,
		const spi_options_t *options)
{
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (options->modfdis > 1) {
80005640:	f7 39 00 0d 	ld.ub	r9,r11[13]
80005644:	30 18       	mov	r8,1
80005646:	f0 09 18 00 	cp.b	r9,r8
8000564a:	e0 88 00 04 	brls	80005652 <spi_initMaster+0x12>
8000564e:	30 2c       	mov	r12,2
80005650:	5e fc       	retal	r12
		return SPI_ERROR_ARGUMENT;
	}

	/* Reset. */
	spi->cr = AVR32_SPI_CR_SWRST_MASK;
80005652:	e0 68 00 80 	mov	r8,128
80005656:	99 08       	st.w	r12[0x0],r8

	/* Master Mode. */
	u_avr32_spi_mr.mr = spi->mr;
80005658:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.mstr = 1;
8000565a:	30 19       	mov	r9,1
8000565c:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_mr.MR.modfdis = options->modfdis;
80005660:	f7 39 00 0d 	ld.ub	r9,r11[13]
80005664:	f1 d9 d0 81 	bfins	r8,r9,0x4,0x1
	u_avr32_spi_mr.MR.llb = 0;
80005668:	30 09       	mov	r9,0
8000566a:	f1 d9 d0 e1 	bfins	r8,r9,0x7,0x1
	u_avr32_spi_mr.MR.pcs = (1 << AVR32_SPI_MR_PCS_SIZE) - 1;
8000566e:	30 fa       	mov	r10,15
80005670:	f1 da d2 04 	bfins	r8,r10,0x10,0x4
	spi->mr = u_avr32_spi_mr.mr;
80005674:	99 18       	st.w	r12[0x4],r8
80005676:	5e f9       	retal	r9

80005678 <spi_selectionMode>:

spi_status_t spi_selectionMode(volatile avr32_spi_t *spi,
		uint8_t variable_ps,
		uint8_t pcs_decode,
		uint8_t delay)
{
80005678:	d4 01       	pushm	lr
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (variable_ps > 1 ||
8000567a:	30 18       	mov	r8,1
8000567c:	f0 0b 18 00 	cp.b	r11,r8
80005680:	5f be       	srhi	lr
80005682:	f0 0a 18 00 	cp.b	r10,r8
80005686:	5f b8       	srhi	r8
80005688:	fd e8 10 08 	or	r8,lr,r8
8000568c:	c0 30       	breq	80005692 <spi_selectionMode+0x1a>
8000568e:	30 2c       	mov	r12,2
80005690:	d8 02       	popm	pc
			pcs_decode > 1) {
		return SPI_ERROR_ARGUMENT;
	}

	u_avr32_spi_mr.mr = spi->mr;
80005692:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.ps = variable_ps;
80005694:	f1 db d0 21 	bfins	r8,r11,0x1,0x1
	u_avr32_spi_mr.MR.pcsdec = pcs_decode;
80005698:	f1 da d0 41 	bfins	r8,r10,0x2,0x1
	u_avr32_spi_mr.MR.dlybcs = delay;
8000569c:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8
	spi->mr = u_avr32_spi_mr.mr;
800056a0:	99 18       	st.w	r12[0x4],r8
800056a2:	d8 0a       	popm	pc,r12=0

800056a4 <spi_enable>:
	return SPI_OK;
}

void spi_enable(volatile avr32_spi_t *spi)
{
	spi->cr = AVR32_SPI_CR_SPIEN_MASK;
800056a4:	30 18       	mov	r8,1
800056a6:	99 08       	st.w	r12[0x0],r8
}
800056a8:	5e fc       	retal	r12

800056aa <spi_write>:
{
	return ((spi->sr & AVR32_SPI_SR_TDRE_MASK) != 0);
}

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
800056aa:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
800056ae:	c0 58       	rjmp	800056b8 <spi_write+0xe>
		if (!timeout--) {
800056b0:	58 08       	cp.w	r8,0
800056b2:	c0 21       	brne	800056b6 <spi_write+0xc>
800056b4:	5e ff       	retal	1
800056b6:	20 18       	sub	r8,1

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
800056b8:	78 49       	ld.w	r9,r12[0x10]
800056ba:	e2 19 00 02 	andl	r9,0x2,COH
800056be:	cf 90       	breq	800056b0 <spi_write+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	spi->tdr = data << AVR32_SPI_TDR_TD_OFFSET;
800056c0:	5c 7b       	castu.h	r11
800056c2:	99 3b       	st.w	r12[0xc],r11
800056c4:	5e fd       	retal	0

800056c6 <spi_read>:
{
	return ((spi->sr & AVR32_SPI_SR_RDRF_MASK) != 0);
}

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
800056c6:	e0 68 3a 98 	mov	r8,15000
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
800056ca:	c0 58       	rjmp	800056d4 <spi_read+0xe>
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) !=
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) {
		if (!timeout--) {
800056cc:	58 08       	cp.w	r8,0
800056ce:	c0 21       	brne	800056d2 <spi_read+0xc>
800056d0:	5e ff       	retal	1
800056d2:	20 18       	sub	r8,1

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
800056d4:	78 49       	ld.w	r9,r12[0x10]
800056d6:	e2 19 02 01 	andl	r9,0x201,COH
800056da:	e0 49 02 01 	cp.w	r9,513
800056de:	cf 71       	brne	800056cc <spi_read+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	*data = spi->rdr >> AVR32_SPI_RDR_RD_OFFSET;
800056e0:	78 28       	ld.w	r8,r12[0x8]
800056e2:	b6 08       	st.h	r11[0x0],r8
800056e4:	5e fd       	retal	0
800056e6:	d7 03       	nop

800056e8 <spi_setupChipReg>:
}

spi_status_t spi_setupChipReg(volatile avr32_spi_t *spi,
		const spi_options_t *options,
		uint32_t pb_hz)
{
800056e8:	eb cd 40 f8 	pushm	r3-r7,lr
800056ec:	18 95       	mov	r5,r12
800056ee:	16 97       	mov	r7,r11
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
800056f0:	f7 36 00 0c 	ld.ub	r6,r11[12]
800056f4:	30 38       	mov	r8,3
800056f6:	f0 06 18 00 	cp.b	r6,r8
800056fa:	e0 8b 00 5e 	brhi	800057b6 <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
800056fe:	f7 34 00 0b 	ld.ub	r4,r11[11]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
80005702:	30 18       	mov	r8,1
80005704:	f0 04 18 00 	cp.b	r4,r8
80005708:	e0 8b 00 57 	brhi	800057b6 <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
8000570c:	f7 33 00 08 	ld.ub	r3,r11[8]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
80005710:	30 78       	mov	r8,7
80005712:	f0 03 18 00 	cp.b	r3,r8
80005716:	e0 88 00 50 	brls	800057b6 <spi_setupChipReg+0xce>
8000571a:	31 08       	mov	r8,16
8000571c:	f0 03 18 00 	cp.b	r3,r8
80005720:	e0 8b 00 4b 	brhi	800057b6 <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
		return SPI_ERROR_ARGUMENT;
	}

	int baudDiv = getBaudDiv(options->baudrate, pb_hz);
80005724:	14 9b       	mov	r11,r10
80005726:	6e 1c       	ld.w	r12,r7[0x4]
80005728:	f0 1f 00 26 	mcall	800057c0 <spi_setupChipReg+0xd8>

	if (baudDiv < 0) {
8000572c:	c4 55       	brlt	800057b6 <spi_setupChipReg+0xce>
		return SPI_ERROR_ARGUMENT;
	}

	/* Will use CSR0 offsets; these are the same for CSR0 to CSR3. */
	u_avr32_spi_csr.csr = 0;
8000572e:	30 08       	mov	r8,0
	u_avr32_spi_csr.CSR.cpol   = options->spi_mode >> 1;
80005730:	ec 09 16 01 	lsr	r9,r6,0x1
80005734:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_csr.CSR.ncpha  = (options->spi_mode & 0x1) ^ 0x1;
80005738:	ec 16 00 01 	eorl	r6,0x1
8000573c:	f1 d6 d0 21 	bfins	r8,r6,0x1,0x1
	u_avr32_spi_csr.CSR.csaat  = options->stay_act;
80005740:	f1 d4 d0 61 	bfins	r8,r4,0x3,0x1
	u_avr32_spi_csr.CSR.bits   = options->bits - 8;
80005744:	20 83       	sub	r3,8
80005746:	f1 d3 d0 84 	bfins	r8,r3,0x4,0x4
	u_avr32_spi_csr.CSR.scbr   = baudDiv;
8000574a:	f1 dc d1 08 	bfins	r8,r12,0x8,0x8
	u_avr32_spi_csr.CSR.dlybs  = options->spck_delay;
8000574e:	ef 39 00 09 	ld.ub	r9,r7[9]
80005752:	f1 d9 d2 08 	bfins	r8,r9,0x10,0x8
	u_avr32_spi_csr.CSR.dlybct = options->trans_delay;
80005756:	ef 39 00 0a 	ld.ub	r9,r7[10]
8000575a:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8

	switch (options->reg) {
8000575e:	0f 89       	ld.ub	r9,r7[0x0]
80005760:	30 1a       	mov	r10,1
80005762:	f4 09 18 00 	cp.b	r9,r10
80005766:	c0 d0       	breq	80005780 <spi_setupChipReg+0x98>
80005768:	c0 a3       	brcs	8000577c <spi_setupChipReg+0x94>
8000576a:	30 2a       	mov	r10,2
8000576c:	f4 09 18 00 	cp.b	r9,r10
80005770:	c0 a0       	breq	80005784 <spi_setupChipReg+0x9c>
80005772:	30 3a       	mov	r10,3
80005774:	f4 09 18 00 	cp.b	r9,r10
80005778:	c1 f1       	brne	800057b6 <spi_setupChipReg+0xce>
8000577a:	c0 78       	rjmp	80005788 <spi_setupChipReg+0xa0>
	case 0:
		spi->csr0 = u_avr32_spi_csr.csr;
8000577c:	8b c8       	st.w	r5[0x30],r8
		break;
8000577e:	c0 68       	rjmp	8000578a <spi_setupChipReg+0xa2>

	case 1:
		spi->csr1 = u_avr32_spi_csr.csr;
80005780:	8b d8       	st.w	r5[0x34],r8
		break;
80005782:	c0 48       	rjmp	8000578a <spi_setupChipReg+0xa2>

	case 2:
		spi->csr2 = u_avr32_spi_csr.csr;
80005784:	8b e8       	st.w	r5[0x38],r8
		break;
80005786:	c0 28       	rjmp	8000578a <spi_setupChipReg+0xa2>

	case 3:
		spi->csr3 = u_avr32_spi_csr.csr;
80005788:	8b f8       	st.w	r5[0x3c],r8
	default:
		return SPI_ERROR_ARGUMENT;
	}

#ifdef FREERTOS_USED
	if (!xSPIMutex) {
8000578a:	48 f8       	lddpc	r8,800057c4 <spi_setupChipReg+0xdc>
8000578c:	70 08       	ld.w	r8,r8[0x0]
8000578e:	58 08       	cp.w	r8,0
80005790:	c1 61       	brne	800057bc <spi_setupChipReg+0xd4>
		/* Create the SPI mutex. */
		vSemaphoreCreateBinary(xSPIMutex);
80005792:	30 0b       	mov	r11,0
80005794:	30 1c       	mov	r12,1
80005796:	f0 1f 00 0d 	mcall	800057c8 <spi_setupChipReg+0xe0>
8000579a:	48 b8       	lddpc	r8,800057c4 <spi_setupChipReg+0xdc>
8000579c:	91 0c       	st.w	r8[0x0],r12
8000579e:	58 0c       	cp.w	r12,0
800057a0:	c0 a0       	breq	800057b4 <spi_setupChipReg+0xcc>
800057a2:	30 09       	mov	r9,0
800057a4:	12 9a       	mov	r10,r9
800057a6:	12 9b       	mov	r11,r9
800057a8:	f0 1f 00 09 	mcall	800057cc <spi_setupChipReg+0xe4>
		if (!xSPIMutex) {
800057ac:	48 68       	lddpc	r8,800057c4 <spi_setupChipReg+0xdc>
800057ae:	70 08       	ld.w	r8,r8[0x0]
800057b0:	58 08       	cp.w	r8,0
800057b2:	c0 51       	brne	800057bc <spi_setupChipReg+0xd4>
800057b4:	c0 08       	rjmp	800057b4 <spi_setupChipReg+0xcc>
800057b6:	30 2c       	mov	r12,2
800057b8:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
800057bc:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
800057c0:	80 00       	ld.sh	r0,r0[0x0]
800057c2:	56 20       	stdsp	sp[0x188],r0
800057c4:	00 00       	add	r0,r0
800057c6:	bf e4       	*unknown*
800057c8:	80 00       	ld.sh	r0,r0[0x0]
800057ca:	63 0c       	ld.w	r12,r1[0x40]
800057cc:	80 00       	ld.sh	r0,r0[0x0]
800057ce:	61 b4       	ld.w	r4,r0[0x6c]

800057d0 <spi_unselectChip>:

	return SPI_OK;
}

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
800057d0:	d4 01       	pushm	lr
800057d2:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
800057d6:	c0 58       	rjmp	800057e0 <spi_unselectChip+0x10>
		if (!timeout--) {
800057d8:	58 08       	cp.w	r8,0
800057da:	c0 21       	brne	800057de <spi_unselectChip+0xe>
800057dc:	da 0a       	popm	pc,r12=1
800057de:	20 18       	sub	r8,1

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
800057e0:	78 49       	ld.w	r9,r12[0x10]
800057e2:	e2 19 02 00 	andl	r9,0x200,COH
800057e6:	cf 90       	breq	800057d8 <spi_unselectChip+0x8>
			return SPI_ERROR_TIMEOUT;
		}
	}

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
800057e8:	78 18       	ld.w	r8,r12[0x4]
800057ea:	ea 18 00 0f 	orh	r8,0xf
800057ee:	99 18       	st.w	r12[0x4],r8

	/* Last transfer, so de-assert the current NPCS if CSAAT is set. */
	spi->cr = AVR32_SPI_CR_LASTXFER_MASK;
800057f0:	fc 18 01 00 	movh	r8,0x100
800057f4:	99 08       	st.w	r12[0x0],r8

#ifdef FREERTOS_USED
	xSemaphoreGive(xSPIMutex);
800057f6:	30 09       	mov	r9,0
800057f8:	12 9a       	mov	r10,r9
800057fa:	12 9b       	mov	r11,r9
800057fc:	48 38       	lddpc	r8,80005808 <spi_unselectChip+0x38>
800057fe:	70 0c       	ld.w	r12,r8[0x0]
80005800:	f0 1f 00 03 	mcall	8000580c <spi_unselectChip+0x3c>
80005804:	d8 0a       	popm	pc,r12=0
80005806:	00 00       	add	r0,r0
80005808:	00 00       	add	r0,r0
8000580a:	bf e4       	*unknown*
8000580c:	80 00       	ld.sh	r0,r0[0x0]
8000580e:	61 b4       	ld.w	r4,r0[0x6c]

80005810 <spi_selectChip>:

	return SPI_OK;
}

spi_status_t spi_selectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
80005810:	eb cd 40 f8 	pushm	r3-r7,lr
80005814:	18 94       	mov	r4,r12
80005816:	16 93       	mov	r3,r11
#ifdef FREERTOS_USED
	while (pdFALSE == xSemaphoreTake(xSPIMutex, 20)) {
80005818:	49 a6       	lddpc	r6,80005880 <spi_selectChip+0x70>
8000581a:	30 07       	mov	r7,0
8000581c:	31 45       	mov	r5,20
8000581e:	0e 99       	mov	r9,r7
80005820:	0a 9a       	mov	r10,r5
80005822:	0e 9b       	mov	r11,r7
80005824:	6c 0c       	ld.w	r12,r6[0x0]
80005826:	f0 1f 00 18 	mcall	80005884 <spi_selectChip+0x74>
8000582a:	cf a0       	breq	8000581e <spi_selectChip+0xe>
	}
#endif

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
8000582c:	68 18       	ld.w	r8,r4[0x4]
8000582e:	ea 18 00 0f 	orh	r8,0xf
80005832:	89 18       	st.w	r4[0x4],r8

	if (spi->mr & AVR32_SPI_MR_PCSDEC_MASK) {
80005834:	68 18       	ld.w	r8,r4[0x4]
80005836:	e2 18 00 04 	andl	r8,0x4,COH
8000583a:	c1 10       	breq	8000585c <spi_selectChip+0x4c>
		/* The signal is decoded; allow up to 15 chips. */
		if (chip > 14) {
8000583c:	30 e8       	mov	r8,14
8000583e:	f0 03 18 00 	cp.b	r3,r8
80005842:	e0 8b 00 1c 	brhi	8000587a <spi_selectChip+0x6a>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~AVR32_SPI_MR_PCS_MASK |
80005846:	68 19       	ld.w	r9,r4[0x4]
80005848:	e6 08 15 10 	lsl	r8,r3,0x10
8000584c:	ea 18 ff f0 	orh	r8,0xfff0
80005850:	e8 18 ff ff 	orl	r8,0xffff
80005854:	12 68       	and	r8,r9
80005856:	89 18       	st.w	r4[0x4],r8
80005858:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
				(chip << AVR32_SPI_MR_PCS_OFFSET);
	} else {
		if (chip > 3) {
8000585c:	30 38       	mov	r8,3
8000585e:	f0 03 18 00 	cp.b	r3,r8
80005862:	e0 8b 00 0c 	brhi	8000587a <spi_selectChip+0x6a>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~(1 << (AVR32_SPI_MR_PCS_OFFSET + chip));
80005866:	68 19       	ld.w	r9,r4[0x4]
80005868:	2f 03       	sub	r3,-16
8000586a:	30 18       	mov	r8,1
8000586c:	f0 03 09 48 	lsl	r8,r8,r3
80005870:	5c d8       	com	r8
80005872:	12 68       	and	r8,r9
80005874:	89 18       	st.w	r4[0x4],r8
80005876:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
8000587a:	30 2c       	mov	r12,2
	}

	return SPI_OK;
}
8000587c:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80005880:	00 00       	add	r0,r0
80005882:	bf e4       	*unknown*
80005884:	80 00       	ld.sh	r0,r0[0x0]
80005886:	5f a8       	srle	r8

80005888 <usart_set_async_baudrate>:
 *
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
80005888:	d4 01       	pushm	lr
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
8000588a:	f6 08 15 04 	lsl	r8,r11,0x4
8000588e:	14 38       	cp.w	r8,r10
80005890:	f9 b8 08 10 	movls	r8,16
80005894:	f9 b8 0b 08 	movhi	r8,8
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
80005898:	f0 0b 02 4b 	mul	r11,r8,r11
8000589c:	f6 09 16 01 	lsr	r9,r11,0x1
800058a0:	f2 0a 00 3a 	add	r10,r9,r10<<0x3
800058a4:	f4 0b 0d 0a 	divu	r10,r10,r11
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
800058a8:	f4 09 16 03 	lsr	r9,r10,0x3
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
800058ac:	f2 cb 00 01 	sub	r11,r9,1
800058b0:	e0 4b ff fe 	cp.w	r11,65534
800058b4:	e0 88 00 03 	brls	800058ba <usart_set_async_baudrate+0x32>
800058b8:	da 0a       	popm	pc,r12=1
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
800058ba:	78 1b       	ld.w	r11,r12[0x4]
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
800058bc:	e8 6e 00 00 	mov	lr,524288
800058c0:	59 08       	cp.w	r8,16
800058c2:	fc 08 17 10 	movne	r8,lr
800058c6:	f9 b8 00 00 	moveq	r8,0
800058ca:	e4 1b ff f7 	andh	r11,0xfff7
800058ce:	e0 1b fe cf 	andl	r11,0xfecf
800058d2:	16 48       	or	r8,r11
800058d4:	99 18       	st.w	r12[0x4],r8
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
800058d6:	f5 da c0 03 	bfextu	r10,r10,0x0,0x3
800058da:	f3 ea 11 09 	or	r9,r9,r10<<0x10
800058de:	99 89       	st.w	r12[0x20],r9
800058e0:	d8 0a       	popm	pc,r12=0

800058e2 <usart_write_char>:
 *
 * \return \c 1 if the USART Transmit Holding Register is free, otherwise \c 0.
 */
__always_inline static int usart_tx_ready(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_TXRDY_MASK) != 0;
800058e2:	78 58       	ld.w	r8,r12[0x14]
}


int usart_write_char(volatile avr32_usart_t *usart, int c)
{
  if (usart_tx_ready(usart))
800058e4:	e2 18 00 02 	andl	r8,0x2,COH
800058e8:	c0 31       	brne	800058ee <usart_write_char+0xc>
800058ea:	30 2c       	mov	r12,2
800058ec:	5e fc       	retal	r12
  {
    usart->thr = (c << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
800058ee:	f7 db c0 09 	bfextu	r11,r11,0x0,0x9
800058f2:	99 7b       	st.w	r12[0x1c],r11
800058f4:	5e fd       	retal	0
800058f6:	d7 03       	nop

800058f8 <usart_putchar>:
    return USART_TX_BUSY;
}


int usart_putchar(volatile avr32_usart_t *usart, int c)
{
800058f8:	eb cd 40 e0 	pushm	r5-r7,lr
800058fc:	18 96       	mov	r6,r12
800058fe:	16 95       	mov	r5,r11
80005900:	e0 67 27 0f 	mov	r7,9999
80005904:	c0 68       	rjmp	80005910 <usart_putchar+0x18>
  int timeout = USART_DEFAULT_TIMEOUT;

  do
  {
    if (!timeout--) return USART_FAILURE;
80005906:	58 07       	cp.w	r7,0
80005908:	c0 31       	brne	8000590e <usart_putchar+0x16>
8000590a:	e3 cf c0 e0 	ldm	sp++,r5-r7,pc,r12=-1
8000590e:	20 17       	sub	r7,1
  } while (usart_write_char(usart, c) != USART_SUCCESS);
80005910:	0a 9b       	mov	r11,r5
80005912:	0c 9c       	mov	r12,r6
80005914:	f0 1f 00 03 	mcall	80005920 <usart_putchar+0x28>
80005918:	cf 71       	brne	80005906 <usart_putchar+0xe>

  return USART_SUCCESS;
}
8000591a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000591e:	00 00       	add	r0,r0
80005920:	80 00       	ld.sh	r0,r0[0x0]
80005922:	58 e2       	cp.w	r2,14

80005924 <usart_read_char>:

int usart_read_char(volatile avr32_usart_t *usart, int *c)
{
  // Check for errors: frame, parity and overrun. In RS485 mode, a parity error
  // would mean that an address char has been received.
  if (usart->csr & (AVR32_USART_CSR_OVRE_MASK |
80005924:	78 58       	ld.w	r8,r12[0x14]
80005926:	e2 18 00 e0 	andl	r8,0xe0,COH
8000592a:	c0 30       	breq	80005930 <usart_read_char+0xc>
8000592c:	30 4c       	mov	r12,4
8000592e:	5e fc       	retal	r12
 *
 * \return \c 1 if the USART Receive Holding Register is full, otherwise \c 0.
 */
__always_inline static int usart_test_hit(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_RXRDY_MASK) != 0;
80005930:	78 58       	ld.w	r8,r12[0x14]
                    AVR32_USART_CSR_FRAME_MASK |
                    AVR32_USART_CSR_PARE_MASK))
    return USART_RX_ERROR;

  // No error; if we really did receive a char, read it and return SUCCESS.
  if (usart_test_hit(usart))
80005932:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80005936:	c0 31       	brne	8000593c <usart_read_char+0x18>
80005938:	30 3c       	mov	r12,3
8000593a:	5e fc       	retal	r12
  {
    *c = (usart->rhr & AVR32_USART_RHR_RXCHR_MASK) >> AVR32_USART_RHR_RXCHR_OFFSET;
8000593c:	78 68       	ld.w	r8,r12[0x18]
8000593e:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
80005942:	97 08       	st.w	r11[0x0],r8
80005944:	5e fd       	retal	0
80005946:	d7 03       	nop

80005948 <usart_getchar>:
    return USART_RX_EMPTY;
}


int usart_getchar(volatile avr32_usart_t *usart)
{
80005948:	eb cd 40 c0 	pushm	r6-r7,lr
8000594c:	20 1d       	sub	sp,4
8000594e:	18 96       	mov	r6,r12
  int c, ret;

  while ((ret = usart_read_char(usart, &c)) == USART_RX_EMPTY);
80005950:	1a 97       	mov	r7,sp
80005952:	1a 9b       	mov	r11,sp
80005954:	0c 9c       	mov	r12,r6
80005956:	f0 1f 00 07 	mcall	80005970 <usart_getchar+0x28>
8000595a:	58 3c       	cp.w	r12,3
8000595c:	cf b0       	breq	80005952 <usart_getchar+0xa>

  if (ret == USART_RX_ERROR)
8000595e:	58 4c       	cp.w	r12,4
80005960:	f9 bc 00 ff 	moveq	r12,-1
    return USART_FAILURE;

  return c;
80005964:	fb fc 10 00 	ld.wne	r12,sp[0x0]
}
80005968:	2f fd       	sub	sp,-4
8000596a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000596e:	00 00       	add	r0,r0
80005970:	80 00       	ld.sh	r0,r0[0x0]
80005972:	59 24       	cp.w	r4,18

80005974 <usart_write_line>:


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
80005974:	eb cd 40 c0 	pushm	r6-r7,lr
80005978:	18 96       	mov	r6,r12
8000597a:	16 97       	mov	r7,r11
  while (*string != '\0')
8000597c:	17 8b       	ld.ub	r11,r11[0x0]
8000597e:	58 0b       	cp.w	r11,0
80005980:	c0 80       	breq	80005990 <usart_write_line+0x1c>
    usart_putchar(usart, *string++);
80005982:	2f f7       	sub	r7,-1
80005984:	0c 9c       	mov	r12,r6
80005986:	f0 1f 00 04 	mcall	80005994 <usart_write_line+0x20>
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
8000598a:	0f 8b       	ld.ub	r11,r7[0x0]
8000598c:	58 0b       	cp.w	r11,0
8000598e:	cf a1       	brne	80005982 <usart_write_line+0xe>
80005990:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005994:	80 00       	ld.sh	r0,r0[0x0]
80005996:	58 f8       	cp.w	r8,15

80005998 <usart_reset>:
//! @{


void usart_reset(volatile avr32_usart_t *usart)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
80005998:	e1 b8 00 00 	mfsr	r8,0x0

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
8000599c:	e6 18 00 01 	andh	r8,0x1,COH
800059a0:	c0 71       	brne	800059ae <usart_reset+0x16>
800059a2:	d3 03       	ssrf	0x10
  usart->idr = 0xFFFFFFFF;
800059a4:	3f f8       	mov	r8,-1
800059a6:	99 38       	st.w	r12[0xc],r8
  usart->csr;
800059a8:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();
800059aa:	d5 03       	csrf	0x10
800059ac:	c0 48       	rjmp	800059b4 <usart_reset+0x1c>
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
  usart->idr = 0xFFFFFFFF;
800059ae:	3f f8       	mov	r8,-1
800059b0:	99 38       	st.w	r12[0xc],r8
  usart->csr;
800059b2:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();

  // Reset mode and other registers that could cause unpredictable behavior after reset.
  usart->mr = 0;
800059b4:	30 08       	mov	r8,0
800059b6:	99 18       	st.w	r12[0x4],r8
  usart->rtor = 0;
800059b8:	99 98       	st.w	r12[0x24],r8
  usart->ttgr = 0;
800059ba:	99 a8       	st.w	r12[0x28],r8

  // Shutdown TX and RX (will be re-enabled when setup has successfully completed),
  // reset status bits and turn off DTR and RTS.
  usart->cr = AVR32_USART_CR_RSTRX_MASK   |
800059bc:	ea 68 61 0c 	mov	r8,680204
800059c0:	99 08       	st.w	r12[0x0],r8
#ifndef AVR32_USART_440_H_INCLUDED
// Note: Modem Signal Management DTR-DSR-DCD-RI are not included in USART rev.440.
              AVR32_USART_CR_DTRDIS_MASK  |
#endif
              AVR32_USART_CR_RTSDIS_MASK;
}
800059c2:	5e fc       	retal	r12

800059c4 <usart_init_rs232>:


int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
{
800059c4:	eb cd 40 e0 	pushm	r5-r7,lr
800059c8:	18 96       	mov	r6,r12
800059ca:	16 97       	mov	r7,r11
800059cc:	14 95       	mov	r5,r10
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);
800059ce:	f0 1f 00 2f 	mcall	80005a88 <usart_init_rs232+0xc4>

  // Check input values.
  if (!opt || // Null pointer.
800059d2:	58 07       	cp.w	r7,0
800059d4:	c5 80       	breq	80005a84 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
800059d6:	0f c8       	ld.ub	r8,r7[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
800059d8:	30 49       	mov	r9,4
800059da:	f2 08 18 00 	cp.b	r8,r9
800059de:	e0 88 00 53 	brls	80005a84 <usart_init_rs232+0xc0>
800059e2:	30 99       	mov	r9,9
800059e4:	f2 08 18 00 	cp.b	r8,r9
800059e8:	e0 8b 00 4e 	brhi	80005a84 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
800059ec:	0f d9       	ld.ub	r9,r7[0x5]
800059ee:	30 78       	mov	r8,7
800059f0:	f0 09 18 00 	cp.b	r9,r8
800059f4:	e0 8b 00 48 	brhi	80005a84 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
800059f8:	8e 39       	ld.sh	r9,r7[0x6]
800059fa:	e0 68 01 01 	mov	r8,257
800059fe:	f0 09 19 00 	cp.h	r9,r8
80005a02:	e0 8b 00 41 	brhi	80005a84 <usart_init_rs232+0xc0>
      opt->channelmode > 3 ||
80005a06:	ef 39 00 08 	ld.ub	r9,r7[8]
80005a0a:	30 38       	mov	r8,3
80005a0c:	f0 09 18 00 	cp.b	r9,r8
80005a10:	e0 8b 00 3a 	brhi	80005a84 <usart_init_rs232+0xc0>
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
80005a14:	0a 9a       	mov	r10,r5
80005a16:	6e 0b       	ld.w	r11,r7[0x0]
80005a18:	0c 9c       	mov	r12,r6
80005a1a:	f0 1f 00 1d 	mcall	80005a8c <usart_init_rs232+0xc8>
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80005a1e:	58 1c       	cp.w	r12,1
80005a20:	c3 20       	breq	80005a84 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
    return USART_INVALID_INPUT;

  if (opt->charlength == 9)
80005a22:	0f c8       	ld.ub	r8,r7[0x4]
80005a24:	30 99       	mov	r9,9
80005a26:	f2 08 18 00 	cp.b	r8,r9
80005a2a:	c0 51       	brne	80005a34 <usart_init_rs232+0x70>
  {
    // Character length set to 9 bits. MODE9 dominates CHRL.
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
80005a2c:	6c 18       	ld.w	r8,r6[0x4]
80005a2e:	b1 b8       	sbr	r8,0x11
80005a30:	8d 18       	st.w	r6[0x4],r8
80005a32:	c0 68       	rjmp	80005a3e <usart_init_rs232+0x7a>
  }
  else
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
80005a34:	6c 19       	ld.w	r9,r6[0x4]
80005a36:	20 58       	sub	r8,5
80005a38:	f3 e8 10 68 	or	r8,r9,r8<<0x6
80005a3c:	8d 18       	st.w	r6[0x4],r8
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
80005a3e:	6c 19       	ld.w	r9,r6[0x4]
80005a40:	ef 3a 00 08 	ld.ub	r10,r7[8]
80005a44:	0f d8       	ld.ub	r8,r7[0x5]
80005a46:	a9 78       	lsl	r8,0x9
80005a48:	f1 ea 10 e8 	or	r8,r8,r10<<0xe
80005a4c:	12 48       	or	r8,r9
80005a4e:	8d 18       	st.w	r6[0x4],r8
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;

  if (opt->stopbits > USART_2_STOPBITS)
80005a50:	8e 38       	ld.sh	r8,r7[0x6]
80005a52:	30 29       	mov	r9,2
80005a54:	f2 08 19 00 	cp.h	r8,r9
80005a58:	e0 88 00 09 	brls	80005a6a <usart_init_rs232+0xa6>
  {
    // Set two stop bits
    usart->mr |= AVR32_USART_MR_NBSTOP_2 << AVR32_USART_MR_NBSTOP_OFFSET;
80005a5c:	6c 18       	ld.w	r8,r6[0x4]
80005a5e:	ad b8       	sbr	r8,0xd
80005a60:	8d 18       	st.w	r6[0x4],r8
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
80005a62:	8e b8       	ld.uh	r8,r7[0x6]
80005a64:	20 28       	sub	r8,2
80005a66:	8d a8       	st.w	r6[0x28],r8
80005a68:	c0 68       	rjmp	80005a74 <usart_init_rs232+0xb0>
  }
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;
80005a6a:	6c 19       	ld.w	r9,r6[0x4]
80005a6c:	5c 78       	castu.h	r8
80005a6e:	f3 e8 10 c8 	or	r8,r9,r8<<0xc
80005a72:	8d 18       	st.w	r6[0x4],r8

  // Set normal mode.
  usart->mr = (usart->mr & ~AVR32_USART_MR_MODE_MASK) |
80005a74:	6c 18       	ld.w	r8,r6[0x4]
80005a76:	e0 18 ff f0 	andl	r8,0xfff0
80005a7a:	8d 18       	st.w	r6[0x4],r8
              AVR32_USART_MR_MODE_NORMAL << AVR32_USART_MR_MODE_OFFSET;

  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
80005a7c:	35 08       	mov	r8,80
80005a7e:	8d 08       	st.w	r6[0x0],r8
80005a80:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
80005a84:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
80005a88:	80 00       	ld.sh	r0,r0[0x0]
80005a8a:	59 98       	cp.w	r8,25
80005a8c:	80 00       	ld.sh	r0,r0[0x0]
80005a8e:	58 88       	cp.w	r8,8

80005a90 <_stext>:

  .global _stext
  .type _stext, @function
_stext:
  // Set initial stack pointer.
  lda.w   sp, _estack
80005a90:	e0 7d 80 00 	mov	sp,98304

  // Set up EVBA so interrupts can be enabled.
  lda.w   r0, _evba
  mtsr    AVR32_EVBA, r0
80005a94:	fe c0 8e 94 	sub	r0,pc,-29036

  // Enable the exception processing.
  csrf    AVR32_SR_EM_OFFSET
80005a98:	e3 b0 00 01 	mtsr	0x4,r0

  // Load initialized data having a global lifetime from the data LMA.
  lda.w   r0, _data
  lda.w   r1, _edata
80005a9c:	d5 53       	csrf	0x15
  cp      r0, r1
80005a9e:	30 40       	mov	r0,4
  brhs    idata_load_loop_end
80005aa0:	e0 61 0a 40 	mov	r1,2624
  lda.w   r2, _data_lma
idata_load_loop:
  ld.d    r4, r2++
80005aa4:	02 30       	cp.w	r0,r1
  st.d    r0++, r4
80005aa6:	c0 62       	brcc	80005ab2 <idata_load_loop_end>
  cp      r0, r1
80005aa8:	48 92       	lddpc	r2,80005acc <udata_clear_loop_end+0x4>

80005aaa <idata_load_loop>:
  brlo    idata_load_loop
80005aaa:	a5 05       	ld.d	r4,r2++
idata_load_loop_end:

  // Clear uninitialized data having a global lifetime in the blank static storage section.
  lda.w   r0, __bss_start
80005aac:	a1 24       	st.d	r0++,r4
  lda.w   r1, _end
80005aae:	02 30       	cp.w	r0,r1
  cp      r0, r1
80005ab0:	cf d3       	brcs	80005aaa <idata_load_loop>

80005ab2 <idata_load_loop_end>:
  brhs    udata_clear_loop_end
80005ab2:	e0 60 0a 40 	mov	r0,2624
  mov     r2, 0
  mov     r3, 0
80005ab6:	e0 61 bf f8 	mov	r1,49144
udata_clear_loop:
  st.d    r0++, r2
  cp      r0, r1
80005aba:	02 30       	cp.w	r0,r1
  brlo    udata_clear_loop
80005abc:	c0 62       	brcc	80005ac8 <udata_clear_loop_end>
  // Safety: Set the default "return" @ to the exit routine address.
  lda.w   lr, exit
#endif

  // Start the show.
  lda.w   pc, main
80005abe:	30 02       	mov	r2,0
80005ac0:	30 03       	mov	r3,0

80005ac2 <udata_clear_loop>:
80005ac2:	a1 22       	st.d	r0++,r2
80005ac4:	02 30       	cp.w	r0,r1
80005ac6:	cf e3       	brcs	80005ac2 <udata_clear_loop>

80005ac8 <udata_clear_loop_end>:
80005ac8:	fe cf e9 28 	sub	pc,pc,-5848
80005acc:	80 00       	ld.sh	r0,r0[0x0]
80005ace:	e0 b8       	*unknown*

80005ad0 <vListInitialise>:
void vListInitialise( xList *pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
80005ad0:	f8 c8 ff f8 	sub	r8,r12,-8
80005ad4:	99 18       	st.w	r12[0x4],r8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
80005ad6:	3f f9       	mov	r9,-1
80005ad8:	99 29       	st.w	r12[0x8],r9

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
80005ada:	99 38       	st.w	r12[0xc],r8
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
80005adc:	99 48       	st.w	r12[0x10],r8

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
80005ade:	30 08       	mov	r8,0
80005ae0:	99 08       	st.w	r12[0x0],r8
}
80005ae2:	5e fc       	retal	r12

80005ae4 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
80005ae4:	30 08       	mov	r8,0
80005ae6:	99 48       	st.w	r12[0x10],r8
}
80005ae8:	5e fc       	retal	r12

80005aea <vListInsertEnd>:

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
80005aea:	78 18       	ld.w	r8,r12[0x4]

	pxNewListItem->pxNext = pxIndex->pxNext;
80005aec:	70 19       	ld.w	r9,r8[0x4]
80005aee:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxPrevious = pxList->pxIndex;
80005af0:	78 19       	ld.w	r9,r12[0x4]
80005af2:	97 29       	st.w	r11[0x8],r9
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80005af4:	70 19       	ld.w	r9,r8[0x4]
80005af6:	93 2b       	st.w	r9[0x8],r11
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
80005af8:	91 1b       	st.w	r8[0x4],r11
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
80005afa:	99 1b       	st.w	r12[0x4],r11

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80005afc:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80005afe:	78 08       	ld.w	r8,r12[0x0]
80005b00:	2f f8       	sub	r8,-1
80005b02:	99 08       	st.w	r12[0x0],r8
}
80005b04:	5e fc       	retal	r12

80005b06 <vListInsert>:
{
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
80005b06:	76 0a       	ld.w	r10,r11[0x0]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
80005b08:	5b fa       	cp.w	r10,-1
80005b0a:	c0 31       	brne	80005b10 <vListInsert+0xa>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
80005b0c:	78 48       	ld.w	r8,r12[0x10]
80005b0e:	c0 c8       	rjmp	80005b26 <vListInsert+0x20>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
80005b10:	f8 c8 ff f8 	sub	r8,r12,-8
80005b14:	70 19       	ld.w	r9,r8[0x4]
80005b16:	72 09       	ld.w	r9,r9[0x0]
80005b18:	12 3a       	cp.w	r10,r9
80005b1a:	c0 63       	brcs	80005b26 <vListInsert+0x20>
80005b1c:	70 18       	ld.w	r8,r8[0x4]
80005b1e:	70 19       	ld.w	r9,r8[0x4]
80005b20:	72 09       	ld.w	r9,r9[0x0]
80005b22:	12 3a       	cp.w	r10,r9
80005b24:	cf c2       	brcc	80005b1c <vListInsert+0x16>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
80005b26:	70 19       	ld.w	r9,r8[0x4]
80005b28:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80005b2a:	93 2b       	st.w	r9[0x8],r11
	pxNewListItem->pxPrevious = pxIterator;
80005b2c:	97 28       	st.w	r11[0x8],r8
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
80005b2e:	91 1b       	st.w	r8[0x4],r11

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80005b30:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80005b32:	78 08       	ld.w	r8,r12[0x0]
80005b34:	2f f8       	sub	r8,-1
80005b36:	99 08       	st.w	r12[0x0],r8
}
80005b38:	5e fc       	retal	r12

80005b3a <vListRemove>:

void vListRemove( xListItem *pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
80005b3a:	78 18       	ld.w	r8,r12[0x4]
80005b3c:	78 29       	ld.w	r9,r12[0x8]
80005b3e:	91 29       	st.w	r8[0x8],r9
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
80005b40:	78 28       	ld.w	r8,r12[0x8]
80005b42:	78 19       	ld.w	r9,r12[0x4]
80005b44:	91 19       	st.w	r8[0x4],r9

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
80005b46:	78 48       	ld.w	r8,r12[0x10]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
80005b48:	70 19       	ld.w	r9,r8[0x4]
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
80005b4a:	18 39       	cp.w	r9,r12
80005b4c:	f9 f9 00 02 	ld.weq	r9,r12[0x8]
80005b50:	f1 f9 0a 01 	st.weq	r8[0x4],r9
	}

	pxItemToRemove->pvContainer = NULL;
80005b54:	30 09       	mov	r9,0
80005b56:	99 49       	st.w	r12[0x10],r9
	( pxList->uxNumberOfItems )--;
80005b58:	70 09       	ld.w	r9,r8[0x0]
80005b5a:	20 19       	sub	r9,1
80005b5c:	91 09       	st.w	r8[0x0],r9
}
80005b5e:	5e fc       	retal	r12

80005b60 <pxPortInitialiseStack>:
	/* Setup the initial stack of the task.  The stack is set exactly as
	expected by the portRESTORE_CONTEXT() macro. */

	/* When the task starts, it will expect to find the function parameter in R12. */
	pxTopOfStack--;
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x08080808;					/* R8 */
80005b60:	e0 68 08 08 	mov	r8,2056
80005b64:	ea 18 08 08 	orh	r8,0x808
80005b68:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x09090909;					/* R9 */
80005b6a:	e0 68 09 09 	mov	r8,2313
80005b6e:	ea 18 09 09 	orh	r8,0x909
80005b72:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0A0A0A0A;					/* R10 */
80005b74:	e0 68 0a 0a 	mov	r8,2570
80005b78:	ea 18 0a 0a 	orh	r8,0xa0a
80005b7c:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0B0B0B0B;					/* R11 */
80005b7e:	e0 68 0b 0b 	mov	r8,2827
80005b82:	ea 18 0b 0b 	orh	r8,0xb0b
80005b86:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pvParameters;					/* R12 */
80005b88:	18 da       	st.w	--r12,r10
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xDEADBEEF;					/* R14/LR */
80005b8a:	e0 68 be ef 	mov	r8,48879
80005b8e:	ea 18 de ad 	orh	r8,0xdead
80005b92:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pxCode + portINSTRUCTION_SIZE; /* R15/PC */
80005b94:	18 db       	st.w	--r12,r11
	*pxTopOfStack-- = ( portSTACK_TYPE ) portINITIAL_SR;				/* SR */
80005b96:	fc 18 00 40 	movh	r8,0x40
80005b9a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xFF0000FF;					/* R0 */
80005b9c:	e0 68 00 ff 	mov	r8,255
80005ba0:	ea 18 ff 00 	orh	r8,0xff00
80005ba4:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x01010101;					/* R1 */
80005ba6:	e0 68 01 01 	mov	r8,257
80005baa:	ea 18 01 01 	orh	r8,0x101
80005bae:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x02020202;					/* R2 */
80005bb0:	e0 68 02 02 	mov	r8,514
80005bb4:	ea 18 02 02 	orh	r8,0x202
80005bb8:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x03030303;					/* R3 */
80005bba:	e0 68 03 03 	mov	r8,771
80005bbe:	ea 18 03 03 	orh	r8,0x303
80005bc2:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x04040404;					/* R4 */
80005bc4:	e0 68 04 04 	mov	r8,1028
80005bc8:	ea 18 04 04 	orh	r8,0x404
80005bcc:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x05050505;					/* R5 */
80005bce:	e0 68 05 05 	mov	r8,1285
80005bd2:	ea 18 05 05 	orh	r8,0x505
80005bd6:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x06060606;					/* R6 */
80005bd8:	e0 68 06 06 	mov	r8,1542
80005bdc:	ea 18 06 06 	orh	r8,0x606
80005be0:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x07070707;					/* R7 */
80005be2:	e0 68 07 07 	mov	r8,1799
80005be6:	ea 18 07 07 	orh	r8,0x707
80005bea:	18 d8       	st.w	--r12,r8
	*pxTopOfStack = ( portSTACK_TYPE ) portNO_CRITICAL_NESTING;			/* ulCriticalNesting */
80005bec:	30 08       	mov	r8,0
80005bee:	18 d8       	st.w	--r12,r8

	return pxTopOfStack;
}
80005bf0:	5e fc       	retal	r12
80005bf2:	d7 03       	nop

80005bf4 <vPortEnterCritical>:
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
__attribute__((__noinline__)) void vPortEnterCritical( void )
{
	/* Disable interrupts */
	portDISABLE_INTERRUPTS();
80005bf4:	d3 03       	ssrf	0x10

	/* Now interrupts are disabled ulCriticalNesting can be accessed
	 directly.  Increment ulCriticalNesting to keep a count of how many times
	 portENTER_CRITICAL() has been called. */
	ulCriticalNesting++;
80005bf6:	48 38       	lddpc	r8,80005c00 <vPortEnterCritical+0xc>
80005bf8:	70 09       	ld.w	r9,r8[0x0]
80005bfa:	2f f9       	sub	r9,-1
80005bfc:	91 09       	st.w	r8[0x0],r9
}
80005bfe:	5e fc       	retal	r12
80005c00:	00 00       	add	r0,r0
80005c02:	05 34       	ld.ub	r4,r2++

80005c04 <xPortStartScheduler>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
80005c04:	d4 01       	pushm	lr
	};

#endif

	/* Disable all interrupt/exception. */
	portDISABLE_INTERRUPTS();
80005c06:	d3 03       	ssrf	0x10
		/* Start the timer/counter. */
		tc_start(tc, configTICK_TC_CHANNEL);
	}
	#else
	{
		INTC_register_interrupt(&vTick, AVR32_CORE_COMPARE_IRQ, AVR32_INTC_INT0);
80005c08:	30 0a       	mov	r10,0
80005c0a:	14 9b       	mov	r11,r10
80005c0c:	49 2c       	lddpc	r12,80005c54 <xPortStartScheduler+0x50>
80005c0e:	f0 1f 00 13 	mcall	80005c58 <xPortStartScheduler+0x54>
/* Schedule the COUNT&COMPARE match interrupt in (configCPU_CLOCK_HZ/configTICK_RATE_HZ)
clock cycles from now. */
#if( configTICK_USE_TC==0 )
	static void prvScheduleFirstTick(void)
	{
		Set_system_register(AVR32_COMPARE, configCPU_CLOCK_HZ/configTICK_RATE_HZ);//cause!!!
80005c12:	e0 68 5d c0 	mov	r8,24000
80005c16:	e3 b8 00 43 	mtsr	0x10c,r8
		Set_system_register(AVR32_COUNT, 0);
80005c1a:	30 08       	mov	r8,0
80005c1c:	e3 b8 00 42 	mtsr	0x108,r8
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();

	/* Start the first task. */
	portRESTORE_CONTEXT();
80005c20:	e0 68 0c ec 	mov	r8,3308
80005c24:	ea 18 00 00 	orh	r8,0x0
80005c28:	70 00       	ld.w	r0,r8[0x0]
80005c2a:	60 0d       	ld.w	sp,r0[0x0]
80005c2c:	1b 00       	ld.w	r0,sp++
80005c2e:	e0 68 05 34 	mov	r8,1332
80005c32:	ea 18 00 00 	orh	r8,0x0
80005c36:	91 00       	st.w	r8[0x0],r0
80005c38:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005c3c:	2f ed       	sub	sp,-8
80005c3e:	e3 cd 5f 00 	ldm	sp++,r8-r12,lr
80005c42:	fa f0 ff e0 	ld.w	r0,sp[-32]
80005c46:	e3 b0 00 00 	mtsr	0x0,r0
80005c4a:	fa f0 ff dc 	ld.w	r0,sp[-36]
80005c4e:	fa ff ff e4 	ld.w	pc,sp[-28]

	/* Should not get here! */
	return 0;
}
80005c52:	d8 0a       	popm	pc,r12=0
80005c54:	80 00       	ld.sh	r0,r0[0x0]
80005c56:	5d 20       	mustr	r0
80005c58:	80 00       	ld.sh	r0,r0[0x0]
80005c5a:	53 c4       	stdsp	sp[0xf0],r4

80005c5c <SCALLYield>:
/*-----------------------------------------------------------*/
__attribute__((__naked__)) void SCALLYield( void );
__attribute__((__naked__)) void SCALLYield( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_SCALL();
80005c5c:	20 6d       	sub	sp,24
80005c5e:	eb cd 00 ff 	pushm	r0-r7
80005c62:	fa c7 ff c0 	sub	r7,sp,-64
80005c66:	ee f0 ff f8 	ld.w	r0,r7[-8]
80005c6a:	ef 40 ff e0 	st.w	r7[-32],r0
80005c6e:	ee f0 ff fc 	ld.w	r0,r7[-4]
80005c72:	ef 40 ff e4 	st.w	r7[-28],r0
80005c76:	eb c7 5f 00 	stm	--r7,r8-r12,lr
80005c7a:	e0 68 05 34 	mov	r8,1332
80005c7e:	ea 18 00 00 	orh	r8,0x0
80005c82:	70 00       	ld.w	r0,r8[0x0]
80005c84:	1a d0       	st.w	--sp,r0
80005c86:	f0 1f 00 1a 	mcall	80005cec <LABEL_RET_SCALL_263+0x14>
80005c8a:	e0 68 0c ec 	mov	r8,3308
80005c8e:	ea 18 00 00 	orh	r8,0x0
80005c92:	70 00       	ld.w	r0,r8[0x0]
80005c94:	81 0d       	st.w	r0[0x0],sp
	vTaskSwitchContext();
80005c96:	f0 1f 00 17 	mcall	80005cf0 <LABEL_RET_SCALL_263+0x18>
	portRESTORE_CONTEXT_SCALL();
80005c9a:	e0 68 0c ec 	mov	r8,3308
80005c9e:	ea 18 00 00 	orh	r8,0x0
80005ca2:	70 00       	ld.w	r0,r8[0x0]
80005ca4:	60 0d       	ld.w	sp,r0[0x0]
80005ca6:	1b 00       	ld.w	r0,sp++
80005ca8:	e0 68 05 34 	mov	r8,1332
80005cac:	ea 18 00 00 	orh	r8,0x0
80005cb0:	91 00       	st.w	r8[0x0],r0
80005cb2:	fa c7 ff d8 	sub	r7,sp,-40
80005cb6:	e3 c7 5f 00 	ldm	r7++,r8-r12,lr
80005cba:	ee f0 ff e0 	ld.w	r0,r7[-32]
80005cbe:	e0 61 05 34 	mov	r1,1332
80005cc2:	ea 11 00 00 	orh	r1,0x0
80005cc6:	62 02       	ld.w	r2,r1[0x0]
80005cc8:	58 02       	cp.w	r2,0
80005cca:	c0 70       	breq	80005cd8 <LABEL_RET_SCALL_263>
80005ccc:	e4 c2 00 01 	sub	r2,r2,1
80005cd0:	83 02       	st.w	r1[0x0],r2
80005cd2:	58 02       	cp.w	r2,0
80005cd4:	c0 21       	brne	80005cd8 <LABEL_RET_SCALL_263>
80005cd6:	b1 c0       	cbr	r0,0x10

80005cd8 <LABEL_RET_SCALL_263>:
80005cd8:	ef 40 ff f8 	st.w	r7[-8],r0
80005cdc:	ee f0 ff e4 	ld.w	r0,r7[-28]
80005ce0:	ef 40 ff fc 	st.w	r7[-4],r0
80005ce4:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005ce8:	2f ad       	sub	sp,-24
80005cea:	d6 13       	rets
80005cec:	80 00       	ld.sh	r0,r0[0x0]
80005cee:	5b f4       	cp.w	r4,-1
80005cf0:	80 00       	ld.sh	r0,r0[0x0]
80005cf2:	63 90       	ld.w	r0,r1[0x64]

80005cf4 <prvClearCcInt>:
		Set_system_register(AVR32_COUNT, 0);
	}

	__attribute__((__noinline__)) static void prvClearCcInt(void)
	{
		Set_system_register(AVR32_COMPARE, Get_system_register(AVR32_COMPARE));
80005cf4:	e1 b8 00 43 	mfsr	r8,0x10c
80005cf8:	e3 b8 00 43 	mtsr	0x10c,r8
	}
80005cfc:	5e fc       	retal	r12
80005cfe:	d7 03       	nop

80005d00 <vPortExitCritical>:
}
/*-----------------------------------------------------------*/

__attribute__((__noinline__)) void vPortExitCritical( void )
{
	if(ulCriticalNesting > portNO_CRITICAL_NESTING)
80005d00:	48 78       	lddpc	r8,80005d1c <vPortExitCritical+0x1c>
80005d02:	70 08       	ld.w	r8,r8[0x0]
80005d04:	58 08       	cp.w	r8,0
80005d06:	5e 0c       	reteq	r12
	{
		ulCriticalNesting--;
80005d08:	48 58       	lddpc	r8,80005d1c <vPortExitCritical+0x1c>
80005d0a:	70 09       	ld.w	r9,r8[0x0]
80005d0c:	20 19       	sub	r9,1
80005d0e:	91 09       	st.w	r8[0x0],r9
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
80005d10:	70 08       	ld.w	r8,r8[0x0]
80005d12:	58 08       	cp.w	r8,0
80005d14:	5e 1c       	retne	r12
		{
			/* Enable all interrupt/exception. */
			portENABLE_INTERRUPTS();
80005d16:	d5 03       	csrf	0x10
80005d18:	5e fc       	retal	r12
80005d1a:	00 00       	add	r0,r0
80005d1c:	00 00       	add	r0,r0
80005d1e:	05 34       	ld.ub	r4,r2++

80005d20 <vTick>:
/* The preemptive scheduler is defined as "naked" as the full context is saved
on entry as part of the context switch. */
__attribute__((__naked__)) static void vTick( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_OS_INT();
80005d20:	eb cd 00 ff 	pushm	r0-r7
80005d24:	e0 68 05 34 	mov	r8,1332
80005d28:	ea 18 00 00 	orh	r8,0x0
80005d2c:	70 00       	ld.w	r0,r8[0x0]
80005d2e:	1a d0       	st.w	--sp,r0
80005d30:	7a 90       	ld.w	r0,sp[0x24]
80005d32:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80005d36:	58 10       	cp.w	r0,1
80005d38:	e0 8b 00 08 	brhi	80005d48 <LABEL_INT_SKIP_SAVE_CONTEXT_237>
80005d3c:	e0 68 0c ec 	mov	r8,3308
80005d40:	ea 18 00 00 	orh	r8,0x0
80005d44:	70 00       	ld.w	r0,r8[0x0]
80005d46:	81 0d       	st.w	r0[0x0],sp

80005d48 <LABEL_INT_SKIP_SAVE_CONTEXT_237>:
	#if( configTICK_USE_TC==1 )
		/* Clear the interrupt flag. */
		prvClearTcInt();
	#else
		/* Clear the interrupt flag. */
		prvClearCcInt();
80005d48:	f0 1f 00 12 	mcall	80005d90 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x14>
	#endif

	/* Because FreeRTOS is not supposed to run with nested interrupts, put all OS
	calls in a critical section . */
	portENTER_CRITICAL();
80005d4c:	f0 1f 00 12 	mcall	80005d94 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
		vTaskIncrementTick();
80005d50:	f0 1f 00 12 	mcall	80005d98 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x1c>
	portEXIT_CRITICAL();
80005d54:	f0 1f 00 12 	mcall	80005d9c <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>

	/* Restore the context of the "elected task". */
	portRESTORE_CONTEXT_OS_INT();
80005d58:	7a 90       	ld.w	r0,sp[0x24]
80005d5a:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80005d5e:	58 10       	cp.w	r0,1
80005d60:	e0 8b 00 0e 	brhi	80005d7c <LABEL_INT_SKIP_RESTORE_CONTEXT_254>
80005d64:	f0 1f 00 0c 	mcall	80005d94 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
80005d68:	f0 1f 00 0e 	mcall	80005da0 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x24>
80005d6c:	f0 1f 00 0c 	mcall	80005d9c <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>
80005d70:	e0 68 0c ec 	mov	r8,3308
80005d74:	ea 18 00 00 	orh	r8,0x0
80005d78:	70 00       	ld.w	r0,r8[0x0]
80005d7a:	60 0d       	ld.w	sp,r0[0x0]

80005d7c <LABEL_INT_SKIP_RESTORE_CONTEXT_254>:
80005d7c:	1b 00       	ld.w	r0,sp++
80005d7e:	e0 68 05 34 	mov	r8,1332
80005d82:	ea 18 00 00 	orh	r8,0x0
80005d86:	91 00       	st.w	r8[0x0],r0
80005d88:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005d8c:	d6 03       	rete
80005d8e:	00 00       	add	r0,r0
80005d90:	80 00       	ld.sh	r0,r0[0x0]
80005d92:	5c f4       	rol	r4
80005d94:	80 00       	ld.sh	r0,r0[0x0]
80005d96:	5b f4       	cp.w	r4,-1
80005d98:	80 00       	ld.sh	r0,r0[0x0]
80005d9a:	65 94       	ld.w	r4,r2[0x64]
80005d9c:	80 00       	ld.sh	r0,r0[0x0]
80005d9e:	5d 00       	ror	r0
80005da0:	80 00       	ld.sh	r0,r0[0x0]
80005da2:	63 90       	ld.w	r0,r1[0x64]

80005da4 <__malloc_lock>:
 * safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_lock(struct _reent *ptr);
void __malloc_lock(struct _reent *ptr)
{
80005da4:	d4 01       	pushm	lr
	vTaskSuspendAll();
80005da6:	f0 1f 00 02 	mcall	80005dac <__malloc_lock+0x8>
}
80005daa:	d8 02       	popm	pc
80005dac:	80 00       	ld.sh	r0,r0[0x0]
80005dae:	63 80       	ld.w	r0,r1[0x60]

80005db0 <__malloc_unlock>:
 * a safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_unlock(struct _reent *ptr);
void __malloc_unlock(struct _reent *ptr)
{
80005db0:	d4 01       	pushm	lr
	xTaskResumeAll();
80005db2:	f0 1f 00 02 	mcall	80005db8 <__malloc_unlock+0x8>
}
80005db6:	d8 02       	popm	pc
80005db8:	80 00       	ld.sh	r0,r0[0x0]
80005dba:	67 3c       	ld.w	r12,r3[0x4c]

80005dbc <_read>:
/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
{
80005dbc:	d4 21       	pushm	r4-r7,lr
80005dbe:	16 95       	mov	r5,r11
80005dc0:	14 96       	mov	r6,r10
  int nChars = 0;

  if (file != 0)
80005dc2:	58 0c       	cp.w	r12,0
80005dc4:	c0 30       	breq	80005dca <_read+0xe>
80005dc6:	3f f7       	mov	r7,-1
80005dc8:	c1 48       	rjmp	80005df0 <_read+0x34>
    return -1;

  for (; len > 0; --len)
80005dca:	58 0a       	cp.w	r10,0
80005dcc:	e0 89 00 04 	brgt	80005dd4 <_read+0x18>
80005dd0:	30 07       	mov	r7,0
80005dd2:	c0 f8       	rjmp	80005df0 <_read+0x34>
80005dd4:	30 07       	mov	r7,0
  {
    int c = usart_getchar(stdio_usart_base);
80005dd6:	48 84       	lddpc	r4,80005df4 <_read+0x38>
80005dd8:	68 0c       	ld.w	r12,r4[0x0]
80005dda:	f0 1f 00 08 	mcall	80005df8 <_read+0x3c>
    if (c < 0)
80005dde:	c0 95       	brlt	80005df0 <_read+0x34>
      break;

    *ptr++ = c;
80005de0:	ea 07 0b 0c 	st.b	r5[r7],r12
    ++nChars;
80005de4:	2f f7       	sub	r7,-1

/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
80005de6:	ec 07 01 08 	sub	r8,r6,r7
  int nChars = 0;

  if (file != 0)
    return -1;

  for (; len > 0; --len)
80005dea:	58 08       	cp.w	r8,0
80005dec:	fe 99 ff f6 	brgt	80005dd8 <_read+0x1c>
    *ptr++ = c;
    ++nChars;
  }

  return nChars;
}
80005df0:	0e 9c       	mov	r12,r7
80005df2:	d8 22       	popm	r4-r7,pc
80005df4:	00 00       	add	r0,r0
80005df6:	bf e8       	*unknown*
80005df8:	80 00       	ld.sh	r0,r0[0x0]
80005dfa:	59 48       	cp.w	r8,20

80005dfc <_write>:
 * 1 and 2 is stdout and stderr which goes to usart
 * 3 is framebuffer
 */
int __attribute__((weak))
_write (int file, char * ptr, int len)
{
80005dfc:	d4 21       	pushm	r4-r7,lr
80005dfe:	16 95       	mov	r5,r11
80005e00:	14 96       	mov	r6,r10
  int nChars = 0;

  if ( (file != 1)
80005e02:	20 1c       	sub	r12,1
80005e04:	58 2c       	cp.w	r12,2
80005e06:	e0 8b 00 12 	brhi	80005e2a <_write+0x2e>
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80005e0a:	58 0a       	cp.w	r10,0
80005e0c:	c0 31       	brne	80005e12 <_write+0x16>
80005e0e:	30 07       	mov	r7,0
80005e10:	c0 e8       	rjmp	80005e2c <_write+0x30>
80005e12:	30 07       	mov	r7,0
  {
    if (usart_putchar(stdio_usart_base, *ptr++) < 0)
80005e14:	48 74       	lddpc	r4,80005e30 <_write+0x34>
80005e16:	68 0c       	ld.w	r12,r4[0x0]
80005e18:	ea 07 07 0b 	ld.ub	r11,r5[r7]
80005e1c:	f0 1f 00 06 	mcall	80005e34 <_write+0x38>
80005e20:	c0 55       	brlt	80005e2a <_write+0x2e>
    {
      return -1;
    }

    ++nChars;
80005e22:	2f f7       	sub	r7,-1

  if ( (file != 1)
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80005e24:	0e 36       	cp.w	r6,r7
80005e26:	cf 81       	brne	80005e16 <_write+0x1a>
80005e28:	c0 28       	rjmp	80005e2c <_write+0x30>
80005e2a:	3f f7       	mov	r7,-1

    ++nChars;
  }

  return nChars;
}
80005e2c:	0e 9c       	mov	r12,r7
80005e2e:	d8 22       	popm	r4-r7,pc
80005e30:	00 00       	add	r0,r0
80005e32:	bf e8       	*unknown*
80005e34:	80 00       	ld.sh	r0,r0[0x0]
80005e36:	58 f8       	cp.w	r8,15

80005e38 <vPortFree>:
	return pvReturn;
}
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
80005e38:	eb cd 40 80 	pushm	r7,lr
80005e3c:	18 97       	mov	r7,r12
	if( pv )
80005e3e:	58 0c       	cp.w	r12,0
80005e40:	c0 80       	breq	80005e50 <vPortFree+0x18>
	{
		vTaskSuspendAll();
80005e42:	f0 1f 00 05 	mcall	80005e54 <vPortFree+0x1c>
		{
			free( pv );
80005e46:	0e 9c       	mov	r12,r7
80005e48:	f0 1f 00 04 	mcall	80005e58 <vPortFree+0x20>
		}
		xTaskResumeAll();
80005e4c:	f0 1f 00 04 	mcall	80005e5c <vPortFree+0x24>
80005e50:	e3 cd 80 80 	ldm	sp++,r7,pc
80005e54:	80 00       	ld.sh	r0,r0[0x0]
80005e56:	63 80       	ld.w	r0,r1[0x60]
80005e58:	80 00       	ld.sh	r0,r0[0x0]
80005e5a:	72 10       	ld.w	r0,r9[0x4]
80005e5c:	80 00       	ld.sh	r0,r0[0x0]
80005e5e:	67 3c       	ld.w	r12,r3[0x4c]

80005e60 <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
80005e60:	eb cd 40 80 	pushm	r7,lr
80005e64:	18 97       	mov	r7,r12
void *pvReturn;

	vTaskSuspendAll();
80005e66:	f0 1f 00 06 	mcall	80005e7c <pvPortMalloc+0x1c>
	{
		pvReturn = malloc( xWantedSize );
80005e6a:	0e 9c       	mov	r12,r7
80005e6c:	f0 1f 00 05 	mcall	80005e80 <pvPortMalloc+0x20>
80005e70:	18 97       	mov	r7,r12
	}
	xTaskResumeAll();
80005e72:	f0 1f 00 05 	mcall	80005e84 <pvPortMalloc+0x24>
		}
	}
	#endif

	return pvReturn;
}
80005e76:	0e 9c       	mov	r12,r7
80005e78:	e3 cd 80 80 	ldm	sp++,r7,pc
80005e7c:	80 00       	ld.sh	r0,r0[0x0]
80005e7e:	63 80       	ld.w	r0,r1[0x60]
80005e80:	80 00       	ld.sh	r0,r0[0x0]
80005e82:	72 20       	ld.w	r0,r9[0x8]
80005e84:	80 00       	ld.sh	r0,r0[0x0]
80005e86:	67 3c       	ld.w	r12,r3[0x4c]

80005e88 <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
80005e88:	d4 01       	pushm	lr
80005e8a:	16 98       	mov	r8,r11
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
80005e8c:	78 09       	ld.w	r9,r12[0x0]
80005e8e:	58 09       	cp.w	r9,0
80005e90:	c1 10       	breq	80005eb2 <prvCopyDataFromQueue+0x2a>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
80005e92:	78 3a       	ld.w	r10,r12[0xc]
80005e94:	79 09       	ld.w	r9,r12[0x40]
80005e96:	f4 09 00 09 	add	r9,r10,r9
80005e9a:	99 39       	st.w	r12[0xc],r9
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
80005e9c:	78 1a       	ld.w	r10,r12[0x4]
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
80005e9e:	14 39       	cp.w	r9,r10
80005ea0:	f9 f9 20 00 	ld.wcc	r9,r12[0x0]
80005ea4:	f9 f9 2a 03 	st.wcc	r12[0xc],r9
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
80005ea8:	79 0a       	ld.w	r10,r12[0x40]
80005eaa:	78 3b       	ld.w	r11,r12[0xc]
80005eac:	10 9c       	mov	r12,r8
80005eae:	f0 1f 00 02 	mcall	80005eb4 <prvCopyDataFromQueue+0x2c>
80005eb2:	d8 02       	popm	pc
80005eb4:	80 00       	ld.sh	r0,r0[0x0]
80005eb6:	76 68       	ld.w	r8,r11[0x18]

80005eb8 <xQueueReceiveFromISR>:
	}
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
80005eb8:	eb cd 40 c0 	pushm	r6-r7,lr
80005ebc:	18 97       	mov	r7,r12
80005ebe:	14 96       	mov	r6,r10
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80005ec0:	78 e8       	ld.w	r8,r12[0x38]
80005ec2:	58 08       	cp.w	r8,0
80005ec4:	c0 31       	brne	80005eca <xQueueReceiveFromISR+0x12>
80005ec6:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
80005eca:	f0 1f 00 0e 	mcall	80005f00 <xQueueReceiveFromISR+0x48>
			--( pxQueue->uxMessagesWaiting );
80005ece:	6e e8       	ld.w	r8,r7[0x38]
80005ed0:	20 18       	sub	r8,1
80005ed2:	8f e8       	st.w	r7[0x38],r8

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
80005ed4:	6f 18       	ld.w	r8,r7[0x44]
80005ed6:	5b f8       	cp.w	r8,-1
80005ed8:	c0 d1       	brne	80005ef2 <xQueueReceiveFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80005eda:	6e 48       	ld.w	r8,r7[0x10]
80005edc:	58 08       	cp.w	r8,0
80005ede:	c0 f0       	breq	80005efc <xQueueReceiveFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80005ee0:	ee cc ff f0 	sub	r12,r7,-16
80005ee4:	f0 1f 00 08 	mcall	80005f04 <xQueueReceiveFromISR+0x4c>
80005ee8:	c0 a0       	breq	80005efc <xQueueReceiveFromISR+0x44>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
80005eea:	30 1c       	mov	r12,1
80005eec:	8d 0c       	st.w	r6[0x0],r12
80005eee:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
80005ef2:	2f f8       	sub	r8,-1
80005ef4:	ef 48 00 44 	st.w	r7[68],r8
80005ef8:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80005efc:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80005f00:	80 00       	ld.sh	r0,r0[0x0]
80005f02:	5e 88       	retls	r8
80005f04:	80 00       	ld.sh	r0,r0[0x0]
80005f06:	65 18       	ld.w	r8,r2[0x44]

80005f08 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
80005f08:	eb cd 40 c0 	pushm	r6-r7,lr
80005f0c:	18 97       	mov	r7,r12

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
80005f0e:	f0 1f 00 23 	mcall	80005f98 <prvUnlockQueue+0x90>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80005f12:	6f 28       	ld.w	r8,r7[0x48]
80005f14:	58 08       	cp.w	r8,0
80005f16:	e0 8a 00 18 	brle	80005f46 <prvUnlockQueue+0x3e>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005f1a:	6e 98       	ld.w	r8,r7[0x24]
80005f1c:	58 08       	cp.w	r8,0
80005f1e:	c1 40       	breq	80005f46 <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80005f20:	ee c6 ff dc 	sub	r6,r7,-36
80005f24:	c0 48       	rjmp	80005f2c <prvUnlockQueue+0x24>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005f26:	6e 98       	ld.w	r8,r7[0x24]
80005f28:	58 08       	cp.w	r8,0
80005f2a:	c0 e0       	breq	80005f46 <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80005f2c:	0c 9c       	mov	r12,r6
80005f2e:	f0 1f 00 1c 	mcall	80005f9c <prvUnlockQueue+0x94>
80005f32:	c0 30       	breq	80005f38 <prvUnlockQueue+0x30>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
80005f34:	f0 1f 00 1b 	mcall	80005fa0 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xTxLock );
80005f38:	6f 28       	ld.w	r8,r7[0x48]
80005f3a:	20 18       	sub	r8,1
80005f3c:	ef 48 00 48 	st.w	r7[72],r8
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80005f40:	58 08       	cp.w	r8,0
80005f42:	fe 99 ff f2 	brgt	80005f26 <prvUnlockQueue+0x1e>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
80005f46:	3f f8       	mov	r8,-1
80005f48:	ef 48 00 48 	st.w	r7[72],r8
	}
	taskEXIT_CRITICAL();
80005f4c:	f0 1f 00 16 	mcall	80005fa4 <prvUnlockQueue+0x9c>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
80005f50:	f0 1f 00 12 	mcall	80005f98 <prvUnlockQueue+0x90>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
80005f54:	6f 18       	ld.w	r8,r7[0x44]
80005f56:	58 08       	cp.w	r8,0
80005f58:	e0 8a 00 18 	brle	80005f88 <prvUnlockQueue+0x80>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80005f5c:	6e 48       	ld.w	r8,r7[0x10]
80005f5e:	58 08       	cp.w	r8,0
80005f60:	c1 40       	breq	80005f88 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80005f62:	ee c6 ff f0 	sub	r6,r7,-16
80005f66:	c0 48       	rjmp	80005f6e <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80005f68:	6e 48       	ld.w	r8,r7[0x10]
80005f6a:	58 08       	cp.w	r8,0
80005f6c:	c0 e0       	breq	80005f88 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80005f6e:	0c 9c       	mov	r12,r6
80005f70:	f0 1f 00 0b 	mcall	80005f9c <prvUnlockQueue+0x94>
80005f74:	c0 30       	breq	80005f7a <prvUnlockQueue+0x72>
				{
					vTaskMissedYield();
80005f76:	f0 1f 00 0b 	mcall	80005fa0 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xRxLock );
80005f7a:	6f 18       	ld.w	r8,r7[0x44]
80005f7c:	20 18       	sub	r8,1
80005f7e:	ef 48 00 44 	st.w	r7[68],r8
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
80005f82:	58 08       	cp.w	r8,0
80005f84:	fe 99 ff f2 	brgt	80005f68 <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
80005f88:	3f f8       	mov	r8,-1
80005f8a:	ef 48 00 44 	st.w	r7[68],r8
	}
	taskEXIT_CRITICAL();
80005f8e:	f0 1f 00 06 	mcall	80005fa4 <prvUnlockQueue+0x9c>
}
80005f92:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005f96:	00 00       	add	r0,r0
80005f98:	80 00       	ld.sh	r0,r0[0x0]
80005f9a:	5b f4       	cp.w	r4,-1
80005f9c:	80 00       	ld.sh	r0,r0[0x0]
80005f9e:	65 18       	ld.w	r8,r2[0x44]
80005fa0:	80 00       	ld.sh	r0,r0[0x0]
80005fa2:	64 24       	ld.w	r4,r2[0x8]
80005fa4:	80 00       	ld.sh	r0,r0[0x0]
80005fa6:	5d 00       	ror	r0

80005fa8 <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
80005fa8:	d4 31       	pushm	r0-r7,lr
80005faa:	20 5d       	sub	sp,20
80005fac:	18 97       	mov	r7,r12
80005fae:	50 0b       	stdsp	sp[0x0],r11
80005fb0:	50 2a       	stdsp	sp[0x8],r10
80005fb2:	50 19       	stdsp	sp[0x4],r9
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80005fb4:	f8 c2 ff dc 	sub	r2,r12,-36
80005fb8:	30 05       	mov	r5,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80005fba:	fa c4 ff f4 	sub	r4,sp,-12
80005fbe:	30 10       	mov	r0,1

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
80005fc0:	0a 91       	mov	r1,r5

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80005fc2:	fa c3 ff f8 	sub	r3,sp,-8
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
80005fc6:	f0 1f 00 3e 	mcall	800060bc <xQueueGenericReceive+0x114>
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80005fca:	6e e8       	ld.w	r8,r7[0x38]
80005fcc:	58 08       	cp.w	r8,0
80005fce:	c2 a0       	breq	80006022 <xQueueGenericReceive+0x7a>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
80005fd0:	6e 36       	ld.w	r6,r7[0xc]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
80005fd2:	40 0b       	lddsp	r11,sp[0x0]
80005fd4:	0e 9c       	mov	r12,r7
80005fd6:	f0 1f 00 3b 	mcall	800060c0 <xQueueGenericReceive+0x118>

				if( xJustPeeking == pdFALSE )
80005fda:	40 18       	lddsp	r8,sp[0x4]
80005fdc:	58 08       	cp.w	r8,0
80005fde:	c1 51       	brne	80006008 <xQueueGenericReceive+0x60>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
80005fe0:	6e e8       	ld.w	r8,r7[0x38]
80005fe2:	20 18       	sub	r8,1
80005fe4:	8f e8       	st.w	r7[0x38],r8

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80005fe6:	6e 08       	ld.w	r8,r7[0x0]
80005fe8:	58 08       	cp.w	r8,0
80005fea:	c0 41       	brne	80005ff2 <xQueueGenericReceive+0x4a>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
80005fec:	f0 1f 00 36 	mcall	800060c4 <xQueueGenericReceive+0x11c>
80005ff0:	8f 1c       	st.w	r7[0x4],r12
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80005ff2:	6e 48       	ld.w	r8,r7[0x10]
80005ff4:	58 08       	cp.w	r8,0
80005ff6:	c1 20       	breq	8000601a <xQueueGenericReceive+0x72>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
80005ff8:	ee cc ff f0 	sub	r12,r7,-16
80005ffc:	f0 1f 00 33 	mcall	800060c8 <xQueueGenericReceive+0x120>
80006000:	58 1c       	cp.w	r12,1
80006002:	c0 c1       	brne	8000601a <xQueueGenericReceive+0x72>
						{
							portYIELD_WITHIN_API();
80006004:	d7 33       	scall
80006006:	c0 a8       	rjmp	8000601a <xQueueGenericReceive+0x72>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
80006008:	8f 36       	st.w	r7[0xc],r6

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
8000600a:	6e 98       	ld.w	r8,r7[0x24]
8000600c:	58 08       	cp.w	r8,0
8000600e:	c0 60       	breq	8000601a <xQueueGenericReceive+0x72>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80006010:	04 9c       	mov	r12,r2
80006012:	f0 1f 00 2e 	mcall	800060c8 <xQueueGenericReceive+0x120>
80006016:	c0 20       	breq	8000601a <xQueueGenericReceive+0x72>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
80006018:	d7 33       	scall
						}
					}

				}

				taskEXIT_CRITICAL();
8000601a:	f0 1f 00 2d 	mcall	800060cc <xQueueGenericReceive+0x124>
8000601e:	30 1c       	mov	r12,1
				return pdPASS;
80006020:	c4 c8       	rjmp	800060b8 <xQueueGenericReceive+0x110>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
80006022:	40 28       	lddsp	r8,sp[0x8]
80006024:	58 08       	cp.w	r8,0
80006026:	c0 51       	brne	80006030 <xQueueGenericReceive+0x88>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80006028:	f0 1f 00 29 	mcall	800060cc <xQueueGenericReceive+0x124>
8000602c:	30 0c       	mov	r12,0
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
8000602e:	c4 58       	rjmp	800060b8 <xQueueGenericReceive+0x110>
				}
				else if( xEntryTimeSet == pdFALSE )
80006030:	58 05       	cp.w	r5,0
80006032:	c0 51       	brne	8000603c <xQueueGenericReceive+0x94>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80006034:	08 9c       	mov	r12,r4
80006036:	f0 1f 00 27 	mcall	800060d0 <xQueueGenericReceive+0x128>
8000603a:	00 95       	mov	r5,r0
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
8000603c:	f0 1f 00 24 	mcall	800060cc <xQueueGenericReceive+0x124>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80006040:	f0 1f 00 25 	mcall	800060d4 <xQueueGenericReceive+0x12c>
		prvLockQueue( pxQueue );
80006044:	f0 1f 00 1e 	mcall	800060bc <xQueueGenericReceive+0x114>
80006048:	6f 18       	ld.w	r8,r7[0x44]
8000604a:	5b f8       	cp.w	r8,-1
8000604c:	ef f1 0a 11 	st.weq	r7[0x44],r1
80006050:	6f 28       	ld.w	r8,r7[0x48]
80006052:	5b f8       	cp.w	r8,-1
80006054:	ef f1 0a 12 	st.weq	r7[0x48],r1
80006058:	f0 1f 00 1d 	mcall	800060cc <xQueueGenericReceive+0x124>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
8000605c:	06 9b       	mov	r11,r3
8000605e:	08 9c       	mov	r12,r4
80006060:	f0 1f 00 1e 	mcall	800060d8 <xQueueGenericReceive+0x130>
80006064:	c2 41       	brne	800060ac <xQueueGenericReceive+0x104>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
80006066:	f0 1f 00 16 	mcall	800060bc <xQueueGenericReceive+0x114>
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
8000606a:	6e e6       	ld.w	r6,r7[0x38]
	taskEXIT_CRITICAL();
8000606c:	f0 1f 00 18 	mcall	800060cc <xQueueGenericReceive+0x124>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) )
80006070:	58 06       	cp.w	r6,0
80006072:	c1 71       	brne	800060a0 <xQueueGenericReceive+0xf8>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80006074:	6e 08       	ld.w	r8,r7[0x0]
80006076:	58 08       	cp.w	r8,0
80006078:	c0 81       	brne	80006088 <xQueueGenericReceive+0xe0>
					{
						portENTER_CRITICAL();
8000607a:	f0 1f 00 11 	mcall	800060bc <xQueueGenericReceive+0x114>
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
8000607e:	6e 1c       	ld.w	r12,r7[0x4]
80006080:	f0 1f 00 17 	mcall	800060dc <xQueueGenericReceive+0x134>
						}
						portEXIT_CRITICAL();
80006084:	f0 1f 00 12 	mcall	800060cc <xQueueGenericReceive+0x124>
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80006088:	40 2b       	lddsp	r11,sp[0x8]
8000608a:	04 9c       	mov	r12,r2
8000608c:	f0 1f 00 15 	mcall	800060e0 <xQueueGenericReceive+0x138>
				prvUnlockQueue( pxQueue );
80006090:	0e 9c       	mov	r12,r7
80006092:	f0 1f 00 15 	mcall	800060e4 <xQueueGenericReceive+0x13c>
				if( !xTaskResumeAll() )
80006096:	f0 1f 00 15 	mcall	800060e8 <xQueueGenericReceive+0x140>
8000609a:	c9 61       	brne	80005fc6 <xQueueGenericReceive+0x1e>
				{
					portYIELD_WITHIN_API();
8000609c:	d7 33       	scall
8000609e:	c9 4b       	rjmp	80005fc6 <xQueueGenericReceive+0x1e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
800060a0:	0e 9c       	mov	r12,r7
800060a2:	f0 1f 00 11 	mcall	800060e4 <xQueueGenericReceive+0x13c>
				( void ) xTaskResumeAll();
800060a6:	f0 1f 00 11 	mcall	800060e8 <xQueueGenericReceive+0x140>
800060aa:	c8 eb       	rjmp	80005fc6 <xQueueGenericReceive+0x1e>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
800060ac:	0e 9c       	mov	r12,r7
800060ae:	f0 1f 00 0e 	mcall	800060e4 <xQueueGenericReceive+0x13c>
			( void ) xTaskResumeAll();
800060b2:	f0 1f 00 0e 	mcall	800060e8 <xQueueGenericReceive+0x140>
800060b6:	30 0c       	mov	r12,0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
800060b8:	2f bd       	sub	sp,-20
800060ba:	d8 32       	popm	r0-r7,pc
800060bc:	80 00       	ld.sh	r0,r0[0x0]
800060be:	5b f4       	cp.w	r4,-1
800060c0:	80 00       	ld.sh	r0,r0[0x0]
800060c2:	5e 88       	retls	r8
800060c4:	80 00       	ld.sh	r0,r0[0x0]
800060c6:	64 30       	ld.w	r0,r2[0xc]
800060c8:	80 00       	ld.sh	r0,r0[0x0]
800060ca:	65 18       	ld.w	r8,r2[0x44]
800060cc:	80 00       	ld.sh	r0,r0[0x0]
800060ce:	5d 00       	ror	r0
800060d0:	80 00       	ld.sh	r0,r0[0x0]
800060d2:	64 0c       	ld.w	r12,r2[0x0]
800060d4:	80 00       	ld.sh	r0,r0[0x0]
800060d6:	63 80       	ld.w	r0,r1[0x60]
800060d8:	80 00       	ld.sh	r0,r0[0x0]
800060da:	66 a8       	ld.w	r8,r3[0x28]
800060dc:	80 00       	ld.sh	r0,r0[0x0]
800060de:	64 94       	ld.w	r4,r2[0x24]
800060e0:	80 00       	ld.sh	r0,r0[0x0]
800060e2:	69 48       	ld.w	r8,r4[0x50]
800060e4:	80 00       	ld.sh	r0,r0[0x0]
800060e6:	5f 08       	sreq	r8
800060e8:	80 00       	ld.sh	r0,r0[0x0]
800060ea:	67 3c       	ld.w	r12,r3[0x4c]

800060ec <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
800060ec:	eb cd 40 80 	pushm	r7,lr
800060f0:	18 97       	mov	r7,r12
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
800060f2:	79 08       	ld.w	r8,r12[0x40]
800060f4:	58 08       	cp.w	r8,0
800060f6:	c0 a1       	brne	8000610a <prvCopyDataToQueue+0x1e>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
800060f8:	78 08       	ld.w	r8,r12[0x0]
800060fa:	58 08       	cp.w	r8,0
800060fc:	c2 b1       	brne	80006152 <prvCopyDataToQueue+0x66>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
800060fe:	78 1c       	ld.w	r12,r12[0x4]
80006100:	f0 1f 00 17 	mcall	8000615c <prvCopyDataToQueue+0x70>
				pxQueue->pxMutexHolder = NULL;
80006104:	30 08       	mov	r8,0
80006106:	8f 18       	st.w	r7[0x4],r8
80006108:	c2 58       	rjmp	80006152 <prvCopyDataToQueue+0x66>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
8000610a:	58 0a       	cp.w	r10,0
8000610c:	c1 01       	brne	8000612c <prvCopyDataToQueue+0x40>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
8000610e:	10 9a       	mov	r10,r8
80006110:	78 2c       	ld.w	r12,r12[0x8]
80006112:	f0 1f 00 14 	mcall	80006160 <prvCopyDataToQueue+0x74>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
80006116:	6e 29       	ld.w	r9,r7[0x8]
80006118:	6f 08       	ld.w	r8,r7[0x40]
8000611a:	f2 08 00 08 	add	r8,r9,r8
8000611e:	8f 28       	st.w	r7[0x8],r8
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
80006120:	6e 19       	ld.w	r9,r7[0x4]
80006122:	12 38       	cp.w	r8,r9
80006124:	c1 73       	brcs	80006152 <prvCopyDataToQueue+0x66>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
80006126:	6e 08       	ld.w	r8,r7[0x0]
80006128:	8f 28       	st.w	r7[0x8],r8
8000612a:	c1 48       	rjmp	80006152 <prvCopyDataToQueue+0x66>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
8000612c:	10 9a       	mov	r10,r8
8000612e:	78 3c       	ld.w	r12,r12[0xc]
80006130:	f0 1f 00 0c 	mcall	80006160 <prvCopyDataToQueue+0x74>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
80006134:	6f 08       	ld.w	r8,r7[0x40]
80006136:	6e 39       	ld.w	r9,r7[0xc]
80006138:	f2 08 01 08 	sub	r8,r9,r8
8000613c:	8f 38       	st.w	r7[0xc],r8
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
8000613e:	6e 09       	ld.w	r9,r7[0x0]
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
80006140:	12 38       	cp.w	r8,r9
80006142:	ef f8 30 10 	ld.wcs	r8,r7[0x40]
80006146:	ef f9 30 01 	ld.wcs	r9,r7[0x4]
8000614a:	f3 d8 e3 19 	subcs	r9,r9,r8
8000614e:	ef f9 3a 03 	st.wcs	r7[0xc],r9
		}
	}

	++( pxQueue->uxMessagesWaiting );
80006152:	6e e8       	ld.w	r8,r7[0x38]
80006154:	2f f8       	sub	r8,-1
80006156:	8f e8       	st.w	r7[0x38],r8
}
80006158:	e3 cd 80 80 	ldm	sp++,r7,pc
8000615c:	80 00       	ld.sh	r0,r0[0x0]
8000615e:	64 3c       	ld.w	r12,r2[0xc]
80006160:	80 00       	ld.sh	r0,r0[0x0]
80006162:	76 68       	ld.w	r8,r11[0x18]

80006164 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
80006164:	eb cd 40 c0 	pushm	r6-r7,lr
80006168:	18 97       	mov	r7,r12
8000616a:	14 96       	mov	r6,r10
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
8000616c:	78 ec       	ld.w	r12,r12[0x38]
8000616e:	6e f8       	ld.w	r8,r7[0x3c]
80006170:	10 3c       	cp.w	r12,r8
80006172:	c0 33       	brcs	80006178 <xQueueGenericSendFromISR+0x14>
80006174:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80006178:	12 9a       	mov	r10,r9
8000617a:	0e 9c       	mov	r12,r7
8000617c:	f0 1f 00 0c 	mcall	800061ac <xQueueGenericSendFromISR+0x48>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
80006180:	6f 28       	ld.w	r8,r7[0x48]
80006182:	5b f8       	cp.w	r8,-1
80006184:	c0 d1       	brne	8000619e <xQueueGenericSendFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80006186:	6e 98       	ld.w	r8,r7[0x24]
80006188:	58 08       	cp.w	r8,0
8000618a:	c0 f0       	breq	800061a8 <xQueueGenericSendFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
8000618c:	ee cc ff dc 	sub	r12,r7,-36
80006190:	f0 1f 00 08 	mcall	800061b0 <xQueueGenericSendFromISR+0x4c>
80006194:	c0 a0       	breq	800061a8 <xQueueGenericSendFromISR+0x44>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
80006196:	30 1c       	mov	r12,1
80006198:	8d 0c       	st.w	r6[0x0],r12
8000619a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
8000619e:	2f f8       	sub	r8,-1
800061a0:	ef 48 00 48 	st.w	r7[72],r8
800061a4:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
800061a8:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
800061ac:	80 00       	ld.sh	r0,r0[0x0]
800061ae:	60 ec       	ld.w	r12,r0[0x38]
800061b0:	80 00       	ld.sh	r0,r0[0x0]
800061b2:	65 18       	ld.w	r8,r2[0x44]

800061b4 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
800061b4:	d4 31       	pushm	r0-r7,lr
800061b6:	20 5d       	sub	sp,20
800061b8:	18 97       	mov	r7,r12
800061ba:	50 0b       	stdsp	sp[0x0],r11
800061bc:	50 2a       	stdsp	sp[0x8],r10
800061be:	50 19       	stdsp	sp[0x4],r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
800061c0:	f8 c0 ff f0 	sub	r0,r12,-16
800061c4:	30 04       	mov	r4,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
800061c6:	fa c3 ff f4 	sub	r3,sp,-12

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
800061ca:	08 91       	mov	r1,r4

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
800061cc:	fa c2 ff f8 	sub	r2,sp,-8
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
800061d0:	f0 1f 00 2f 	mcall	8000628c <xQueueGenericSend+0xd8>
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
800061d4:	6e e9       	ld.w	r9,r7[0x38]
800061d6:	6e f8       	ld.w	r8,r7[0x3c]
800061d8:	10 39       	cp.w	r9,r8
800061da:	c1 42       	brcc	80006202 <xQueueGenericSend+0x4e>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
800061dc:	40 1a       	lddsp	r10,sp[0x4]
800061de:	40 0b       	lddsp	r11,sp[0x0]
800061e0:	0e 9c       	mov	r12,r7
800061e2:	f0 1f 00 2c 	mcall	80006290 <xQueueGenericSend+0xdc>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
800061e6:	6e 98       	ld.w	r8,r7[0x24]
800061e8:	58 08       	cp.w	r8,0
800061ea:	c0 80       	breq	800061fa <xQueueGenericSend+0x46>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
800061ec:	ee cc ff dc 	sub	r12,r7,-36
800061f0:	f0 1f 00 29 	mcall	80006294 <xQueueGenericSend+0xe0>
800061f4:	58 1c       	cp.w	r12,1
800061f6:	c0 21       	brne	800061fa <xQueueGenericSend+0x46>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
800061f8:	d7 33       	scall
					}
				}

				taskEXIT_CRITICAL();
800061fa:	f0 1f 00 28 	mcall	80006298 <xQueueGenericSend+0xe4>
800061fe:	30 1c       	mov	r12,1

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
80006200:	c4 38       	rjmp	80006286 <xQueueGenericSend+0xd2>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
80006202:	40 28       	lddsp	r8,sp[0x8]
80006204:	58 08       	cp.w	r8,0
80006206:	c0 51       	brne	80006210 <xQueueGenericSend+0x5c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80006208:	f0 1f 00 24 	mcall	80006298 <xQueueGenericSend+0xe4>
8000620c:	30 0c       	mov	r12,0

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
8000620e:	c3 c8       	rjmp	80006286 <xQueueGenericSend+0xd2>
				}
				else if( xEntryTimeSet == pdFALSE )
80006210:	58 04       	cp.w	r4,0
80006212:	c0 51       	brne	8000621c <xQueueGenericSend+0x68>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80006214:	06 9c       	mov	r12,r3
80006216:	f0 1f 00 22 	mcall	8000629c <xQueueGenericSend+0xe8>
8000621a:	30 14       	mov	r4,1
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
8000621c:	f0 1f 00 1f 	mcall	80006298 <xQueueGenericSend+0xe4>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80006220:	f0 1f 00 20 	mcall	800062a0 <xQueueGenericSend+0xec>
		prvLockQueue( pxQueue );
80006224:	f0 1f 00 1a 	mcall	8000628c <xQueueGenericSend+0xd8>
80006228:	6f 18       	ld.w	r8,r7[0x44]
8000622a:	5b f8       	cp.w	r8,-1
8000622c:	ef f1 0a 11 	st.weq	r7[0x44],r1
80006230:	6f 28       	ld.w	r8,r7[0x48]
80006232:	5b f8       	cp.w	r8,-1
80006234:	ef f1 0a 12 	st.weq	r7[0x48],r1
80006238:	f0 1f 00 18 	mcall	80006298 <xQueueGenericSend+0xe4>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
8000623c:	04 9b       	mov	r11,r2
8000623e:	06 9c       	mov	r12,r3
80006240:	f0 1f 00 19 	mcall	800062a4 <xQueueGenericSend+0xf0>
80006244:	c1 b1       	brne	8000627a <xQueueGenericSend+0xc6>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
80006246:	f0 1f 00 12 	mcall	8000628c <xQueueGenericSend+0xd8>
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
8000624a:	6e e5       	ld.w	r5,r7[0x38]
8000624c:	6e f6       	ld.w	r6,r7[0x3c]
	taskEXIT_CRITICAL();
8000624e:	f0 1f 00 13 	mcall	80006298 <xQueueGenericSend+0xe4>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
80006252:	0c 35       	cp.w	r5,r6
80006254:	c0 d1       	brne	8000626e <xQueueGenericSend+0xba>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
80006256:	40 2b       	lddsp	r11,sp[0x8]
80006258:	00 9c       	mov	r12,r0
8000625a:	f0 1f 00 14 	mcall	800062a8 <xQueueGenericSend+0xf4>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
8000625e:	0e 9c       	mov	r12,r7
80006260:	f0 1f 00 13 	mcall	800062ac <xQueueGenericSend+0xf8>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
80006264:	f0 1f 00 13 	mcall	800062b0 <xQueueGenericSend+0xfc>
80006268:	cb 41       	brne	800061d0 <xQueueGenericSend+0x1c>
				{
					portYIELD_WITHIN_API();
8000626a:	d7 33       	scall
8000626c:	cb 2b       	rjmp	800061d0 <xQueueGenericSend+0x1c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
8000626e:	0e 9c       	mov	r12,r7
80006270:	f0 1f 00 0f 	mcall	800062ac <xQueueGenericSend+0xf8>
				( void ) xTaskResumeAll();
80006274:	f0 1f 00 0f 	mcall	800062b0 <xQueueGenericSend+0xfc>
80006278:	ca cb       	rjmp	800061d0 <xQueueGenericSend+0x1c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
8000627a:	0e 9c       	mov	r12,r7
8000627c:	f0 1f 00 0c 	mcall	800062ac <xQueueGenericSend+0xf8>
			( void ) xTaskResumeAll();
80006280:	f0 1f 00 0c 	mcall	800062b0 <xQueueGenericSend+0xfc>
80006284:	30 0c       	mov	r12,0
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
80006286:	2f bd       	sub	sp,-20
80006288:	d8 32       	popm	r0-r7,pc
8000628a:	00 00       	add	r0,r0
8000628c:	80 00       	ld.sh	r0,r0[0x0]
8000628e:	5b f4       	cp.w	r4,-1
80006290:	80 00       	ld.sh	r0,r0[0x0]
80006292:	60 ec       	ld.w	r12,r0[0x38]
80006294:	80 00       	ld.sh	r0,r0[0x0]
80006296:	65 18       	ld.w	r8,r2[0x44]
80006298:	80 00       	ld.sh	r0,r0[0x0]
8000629a:	5d 00       	ror	r0
8000629c:	80 00       	ld.sh	r0,r0[0x0]
8000629e:	64 0c       	ld.w	r12,r2[0x0]
800062a0:	80 00       	ld.sh	r0,r0[0x0]
800062a2:	63 80       	ld.w	r0,r1[0x60]
800062a4:	80 00       	ld.sh	r0,r0[0x0]
800062a6:	66 a8       	ld.w	r8,r3[0x28]
800062a8:	80 00       	ld.sh	r0,r0[0x0]
800062aa:	69 48       	ld.w	r8,r4[0x50]
800062ac:	80 00       	ld.sh	r0,r0[0x0]
800062ae:	5f 08       	sreq	r8
800062b0:	80 00       	ld.sh	r0,r0[0x0]
800062b2:	67 3c       	ld.w	r12,r3[0x4c]

800062b4 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	xQueueHandle xQueueCreateMutex( void )
	{
800062b4:	eb cd 40 c0 	pushm	r6-r7,lr
	xQUEUE *pxNewQueue;

		/* Allocate the new queue structure. */
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
800062b8:	34 cc       	mov	r12,76
800062ba:	f0 1f 00 12 	mcall	80006300 <xQueueCreateMutex+0x4c>
800062be:	18 97       	mov	r7,r12
		if( pxNewQueue != NULL )
800062c0:	c1 d0       	breq	800062fa <xQueueCreateMutex+0x46>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
800062c2:	30 06       	mov	r6,0
800062c4:	99 16       	st.w	r12[0x4],r6
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
800062c6:	99 06       	st.w	r12[0x0],r6

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
800062c8:	99 26       	st.w	r12[0x8],r6
			pxNewQueue->pcReadFrom = NULL;
800062ca:	99 36       	st.w	r12[0xc],r6

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
800062cc:	99 e6       	st.w	r12[0x38],r6
			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
800062ce:	30 18       	mov	r8,1
800062d0:	99 f8       	st.w	r12[0x3c],r8
			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
800062d2:	f9 46 00 40 	st.w	r12[64],r6
			pxNewQueue->xRxLock = queueUNLOCKED;
800062d6:	3f f8       	mov	r8,-1
800062d8:	f9 48 00 44 	st.w	r12[68],r8
			pxNewQueue->xTxLock = queueUNLOCKED;
800062dc:	f9 48 00 48 	st.w	r12[72],r8

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
800062e0:	2f 0c       	sub	r12,-16
800062e2:	f0 1f 00 09 	mcall	80006304 <xQueueCreateMutex+0x50>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
800062e6:	ee cc ff dc 	sub	r12,r7,-36
800062ea:	f0 1f 00 07 	mcall	80006304 <xQueueCreateMutex+0x50>

			/* Start with the semaphore in the expected state. */
			xQueueGenericSend( pxNewQueue, NULL, ( portTickType ) 0U, queueSEND_TO_BACK );
800062ee:	0c 99       	mov	r9,r6
800062f0:	0c 9a       	mov	r10,r6
800062f2:	0c 9b       	mov	r11,r6
800062f4:	0e 9c       	mov	r12,r7
800062f6:	f0 1f 00 05 	mcall	80006308 <xQueueCreateMutex+0x54>
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
800062fa:	0e 9c       	mov	r12,r7
800062fc:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006300:	80 00       	ld.sh	r0,r0[0x0]
80006302:	5e 60       	retmi	r0
80006304:	80 00       	ld.sh	r0,r0[0x0]
80006306:	5a d0       	cp.w	r0,-19
80006308:	80 00       	ld.sh	r0,r0[0x0]
8000630a:	61 b4       	ld.w	r4,r0[0x6c]

8000630c <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
8000630c:	d4 21       	pushm	r4-r7,lr
8000630e:	18 97       	mov	r7,r12
80006310:	16 96       	mov	r6,r11
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
80006312:	58 0c       	cp.w	r12,0
80006314:	c2 f0       	breq	80006372 <xQueueCreate+0x66>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
80006316:	34 cc       	mov	r12,76
80006318:	f0 1f 00 17 	mcall	80006374 <xQueueCreate+0x68>
8000631c:	18 95       	mov	r5,r12
		if( pxNewQueue != NULL )
8000631e:	c2 a0       	breq	80006372 <xQueueCreate+0x66>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
80006320:	ec 07 02 44 	mul	r4,r6,r7

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
80006324:	e8 cc ff ff 	sub	r12,r4,-1
80006328:	f0 1f 00 13 	mcall	80006374 <xQueueCreate+0x68>
8000632c:	8b 0c       	st.w	r5[0x0],r12
			if( pxNewQueue->pcHead != NULL )
8000632e:	c1 e0       	breq	8000636a <xQueueCreate+0x5e>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
80006330:	f8 04 00 04 	add	r4,r12,r4
80006334:	8b 14       	st.w	r5[0x4],r4
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
80006336:	30 08       	mov	r8,0
80006338:	8b e8       	st.w	r5[0x38],r8
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
8000633a:	8b 2c       	st.w	r5[0x8],r12
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
8000633c:	ee c8 00 01 	sub	r8,r7,1
80006340:	ad 38       	mul	r8,r6
80006342:	10 0c       	add	r12,r8
80006344:	8b 3c       	st.w	r5[0xc],r12
				pxNewQueue->uxLength = uxQueueLength;
80006346:	8b f7       	st.w	r5[0x3c],r7
				pxNewQueue->uxItemSize = uxItemSize;
80006348:	eb 46 00 40 	st.w	r5[64],r6
				pxNewQueue->xRxLock = queueUNLOCKED;
8000634c:	3f f8       	mov	r8,-1
8000634e:	eb 48 00 44 	st.w	r5[68],r8
				pxNewQueue->xTxLock = queueUNLOCKED;
80006352:	eb 48 00 48 	st.w	r5[72],r8

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
80006356:	ea cc ff f0 	sub	r12,r5,-16
8000635a:	f0 1f 00 08 	mcall	80006378 <xQueueCreate+0x6c>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
8000635e:	ea cc ff dc 	sub	r12,r5,-36
80006362:	f0 1f 00 06 	mcall	80006378 <xQueueCreate+0x6c>
80006366:	0a 9c       	mov	r12,r5
80006368:	d8 22       	popm	r4-r7,pc
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
8000636a:	0a 9c       	mov	r12,r5
8000636c:	f0 1f 00 04 	mcall	8000637c <xQueueCreate+0x70>
80006370:	d8 2a       	popm	r4-r7,pc,r12=0
80006372:	d8 2a       	popm	r4-r7,pc,r12=0
80006374:	80 00       	ld.sh	r0,r0[0x0]
80006376:	5e 60       	retmi	r0
80006378:	80 00       	ld.sh	r0,r0[0x0]
8000637a:	5a d0       	cp.w	r0,-19
8000637c:	80 00       	ld.sh	r0,r0[0x0]
8000637e:	5e 38       	retlo	r8

80006380 <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
80006380:	48 38       	lddpc	r8,8000638c <vTaskSuspendAll+0xc>
80006382:	70 09       	ld.w	r9,r8[0x0]
80006384:	2f f9       	sub	r9,-1
80006386:	91 09       	st.w	r8[0x0],r9
}
80006388:	5e fc       	retal	r12
8000638a:	00 00       	add	r0,r0
8000638c:	00 00       	add	r0,r0
8000638e:	0d 1c       	ld.sh	r12,r6++

80006390 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
80006390:	49 a8       	lddpc	r8,800063f8 <vTaskSwitchContext+0x68>
80006392:	70 08       	ld.w	r8,r8[0x0]
80006394:	58 08       	cp.w	r8,0
80006396:	c0 b1       	brne	800063ac <vTaskSwitchContext+0x1c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80006398:	49 98       	lddpc	r8,800063fc <vTaskSwitchContext+0x6c>
8000639a:	70 08       	ld.w	r8,r8[0x0]
8000639c:	f0 08 00 28 	add	r8,r8,r8<<0x2
800063a0:	49 89       	lddpc	r9,80006400 <vTaskSwitchContext+0x70>
800063a2:	f2 08 03 28 	ld.w	r8,r9[r8<<0x2]
800063a6:	58 08       	cp.w	r8,0
800063a8:	c0 60       	breq	800063b4 <vTaskSwitchContext+0x24>
800063aa:	c1 18       	rjmp	800063cc <vTaskSwitchContext+0x3c>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
800063ac:	30 19       	mov	r9,1
800063ae:	49 68       	lddpc	r8,80006404 <vTaskSwitchContext+0x74>
800063b0:	91 09       	st.w	r8[0x0],r9
800063b2:	5e fc       	retal	r12

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
800063b4:	49 28       	lddpc	r8,800063fc <vTaskSwitchContext+0x6c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
800063b6:	49 3a       	lddpc	r10,80006400 <vTaskSwitchContext+0x70>
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
800063b8:	70 09       	ld.w	r9,r8[0x0]
800063ba:	20 19       	sub	r9,1
800063bc:	91 09       	st.w	r8[0x0],r9

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
800063be:	70 09       	ld.w	r9,r8[0x0]
800063c0:	f2 09 00 29 	add	r9,r9,r9<<0x2
800063c4:	f4 09 03 29 	ld.w	r9,r10[r9<<0x2]
800063c8:	58 09       	cp.w	r9,0
800063ca:	cf 70       	breq	800063b8 <vTaskSwitchContext+0x28>
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
800063cc:	48 c8       	lddpc	r8,800063fc <vTaskSwitchContext+0x6c>
800063ce:	70 08       	ld.w	r8,r8[0x0]
800063d0:	f0 08 00 28 	add	r8,r8,r8<<0x2
800063d4:	48 b9       	lddpc	r9,80006400 <vTaskSwitchContext+0x70>
800063d6:	f2 08 00 28 	add	r8,r9,r8<<0x2
800063da:	70 19       	ld.w	r9,r8[0x4]
800063dc:	72 19       	ld.w	r9,r9[0x4]
800063de:	91 19       	st.w	r8[0x4],r9
800063e0:	f0 ca ff f8 	sub	r10,r8,-8
800063e4:	14 39       	cp.w	r9,r10
800063e6:	f3 f9 00 01 	ld.weq	r9,r9[0x4]
800063ea:	f1 f9 0a 01 	st.weq	r8[0x4],r9
800063ee:	70 18       	ld.w	r8,r8[0x4]
800063f0:	70 39       	ld.w	r9,r8[0xc]
800063f2:	48 68       	lddpc	r8,80006408 <vTaskSwitchContext+0x78>
800063f4:	91 09       	st.w	r8[0x0],r9
800063f6:	5e fc       	retal	r12
800063f8:	00 00       	add	r0,r0
800063fa:	0d 1c       	ld.sh	r12,r6++
800063fc:	00 00       	add	r0,r0
800063fe:	0d 54       	ld.sh	r4,--r6
80006400:	00 00       	add	r0,r0
80006402:	0c 38       	cp.w	r8,r6
80006404:	00 00       	add	r0,r0
80006406:	0d 3c       	ld.ub	r12,r6++
80006408:	00 00       	add	r0,r0
8000640a:	0c ec       	st.h	--r6,r12

8000640c <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
8000640c:	48 48       	lddpc	r8,8000641c <vTaskSetTimeOutState+0x10>
8000640e:	70 08       	ld.w	r8,r8[0x0]
80006410:	99 08       	st.w	r12[0x0],r8
	pxTimeOut->xTimeOnEntering = xTickCount;
80006412:	48 48       	lddpc	r8,80006420 <vTaskSetTimeOutState+0x14>
80006414:	70 08       	ld.w	r8,r8[0x0]
80006416:	99 18       	st.w	r12[0x4],r8
}
80006418:	5e fc       	retal	r12
8000641a:	00 00       	add	r0,r0
8000641c:	00 00       	add	r0,r0
8000641e:	0c 30       	cp.w	r0,r6
80006420:	00 00       	add	r0,r0
80006422:	0d 18       	ld.sh	r8,r6++

80006424 <vTaskMissedYield>:
}
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
80006424:	30 19       	mov	r9,1
80006426:	48 28       	lddpc	r8,8000642c <vTaskMissedYield+0x8>
80006428:	91 09       	st.w	r8[0x0],r9
}
8000642a:	5e fc       	retal	r12
8000642c:	00 00       	add	r0,r0
8000642e:	0d 3c       	ld.ub	r12,r6++

80006430 <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
80006430:	48 28       	lddpc	r8,80006438 <xTaskGetCurrentTaskHandle+0x8>
80006432:	70 0c       	ld.w	r12,r8[0x0]

		return xReturn;
	}
80006434:	5e fc       	retal	r12
80006436:	00 00       	add	r0,r0
80006438:	00 00       	add	r0,r0
8000643a:	0c ec       	st.h	--r6,r12

8000643c <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
8000643c:	eb cd 40 c0 	pushm	r6-r7,lr
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
80006440:	58 0c       	cp.w	r12,0
80006442:	c1 f0       	breq	80006480 <vTaskPriorityDisinherit+0x44>

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
80006444:	18 97       	mov	r7,r12

		if( pxMutexHolder != NULL )
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
80006446:	78 b9       	ld.w	r9,r12[0x2c]
80006448:	79 18       	ld.w	r8,r12[0x44]
8000644a:	10 39       	cp.w	r9,r8
8000644c:	c1 a0       	breq	80006480 <vTaskPriorityDisinherit+0x44>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
8000644e:	f8 c6 ff fc 	sub	r6,r12,-4
80006452:	0c 9c       	mov	r12,r6
80006454:	f0 1f 00 0c 	mcall	80006484 <vTaskPriorityDisinherit+0x48>

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
80006458:	6f 1c       	ld.w	r12,r7[0x44]
8000645a:	8f bc       	st.w	r7[0x2c],r12
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
8000645c:	f8 08 11 08 	rsub	r8,r12,8
80006460:	8f 68       	st.w	r7[0x18],r8
				prvAddTaskToReadyQueue( pxTCB );
80006462:	48 a8       	lddpc	r8,80006488 <vTaskPriorityDisinherit+0x4c>
80006464:	70 08       	ld.w	r8,r8[0x0]
80006466:	10 3c       	cp.w	r12,r8
80006468:	e0 88 00 04 	brls	80006470 <vTaskPriorityDisinherit+0x34>
8000646c:	48 78       	lddpc	r8,80006488 <vTaskPriorityDisinherit+0x4c>
8000646e:	91 0c       	st.w	r8[0x0],r12
80006470:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006474:	0c 9b       	mov	r11,r6
80006476:	48 68       	lddpc	r8,8000648c <vTaskPriorityDisinherit+0x50>
80006478:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
8000647c:	f0 1f 00 05 	mcall	80006490 <vTaskPriorityDisinherit+0x54>
80006480:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006484:	80 00       	ld.sh	r0,r0[0x0]
80006486:	5b 3a       	cp.w	r10,-13
80006488:	00 00       	add	r0,r0
8000648a:	0d 54       	ld.sh	r4,--r6
8000648c:	00 00       	add	r0,r0
8000648e:	0c 38       	cp.w	r8,r6
80006490:	80 00       	ld.sh	r0,r0[0x0]
80006492:	5a ea       	cp.w	r10,-18

80006494 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
80006494:	eb cd 40 c0 	pushm	r6-r7,lr
80006498:	18 97       	mov	r7,r12
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
8000649a:	49 b8       	lddpc	r8,80006504 <vTaskPriorityInherit+0x70>
8000649c:	70 08       	ld.w	r8,r8[0x0]
8000649e:	78 b9       	ld.w	r9,r12[0x2c]
800064a0:	70 b8       	ld.w	r8,r8[0x2c]
800064a2:	10 39       	cp.w	r9,r8
800064a4:	c2 d2       	brcc	800064fe <vTaskPriorityInherit+0x6a>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
800064a6:	49 88       	lddpc	r8,80006504 <vTaskPriorityInherit+0x70>
800064a8:	70 08       	ld.w	r8,r8[0x0]
800064aa:	70 b8       	ld.w	r8,r8[0x2c]
800064ac:	f0 08 11 08 	rsub	r8,r8,8
800064b0:	99 68       	st.w	r12[0x18],r8

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
800064b2:	f2 09 00 28 	add	r8,r9,r9<<0x2
800064b6:	49 59       	lddpc	r9,80006508 <vTaskPriorityInherit+0x74>
800064b8:	f2 08 00 28 	add	r8,r9,r8<<0x2
800064bc:	78 59       	ld.w	r9,r12[0x14]
800064be:	10 39       	cp.w	r9,r8
800064c0:	c1 b1       	brne	800064f6 <vTaskPriorityInherit+0x62>
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
800064c2:	f8 c6 ff fc 	sub	r6,r12,-4
800064c6:	0c 9c       	mov	r12,r6
800064c8:	f0 1f 00 11 	mcall	8000650c <vTaskPriorityInherit+0x78>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
800064cc:	48 e8       	lddpc	r8,80006504 <vTaskPriorityInherit+0x70>
800064ce:	70 08       	ld.w	r8,r8[0x0]
800064d0:	70 bc       	ld.w	r12,r8[0x2c]
800064d2:	8f bc       	st.w	r7[0x2c],r12
				prvAddTaskToReadyQueue( pxTCB );
800064d4:	48 f8       	lddpc	r8,80006510 <vTaskPriorityInherit+0x7c>
800064d6:	70 08       	ld.w	r8,r8[0x0]
800064d8:	10 3c       	cp.w	r12,r8
800064da:	e0 88 00 04 	brls	800064e2 <vTaskPriorityInherit+0x4e>
800064de:	48 d8       	lddpc	r8,80006510 <vTaskPriorityInherit+0x7c>
800064e0:	91 0c       	st.w	r8[0x0],r12
800064e2:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800064e6:	0c 9b       	mov	r11,r6
800064e8:	48 88       	lddpc	r8,80006508 <vTaskPriorityInherit+0x74>
800064ea:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800064ee:	f0 1f 00 0a 	mcall	80006514 <vTaskPriorityInherit+0x80>
800064f2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
800064f6:	48 48       	lddpc	r8,80006504 <vTaskPriorityInherit+0x70>
800064f8:	70 08       	ld.w	r8,r8[0x0]
800064fa:	70 b8       	ld.w	r8,r8[0x2c]
800064fc:	99 b8       	st.w	r12[0x2c],r8
800064fe:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006502:	00 00       	add	r0,r0
80006504:	00 00       	add	r0,r0
80006506:	0c ec       	st.h	--r6,r12
80006508:	00 00       	add	r0,r0
8000650a:	0c 38       	cp.w	r8,r6
8000650c:	80 00       	ld.sh	r0,r0[0x0]
8000650e:	5b 3a       	cp.w	r10,-13
80006510:	00 00       	add	r0,r0
80006512:	0d 54       	ld.sh	r4,--r6
80006514:	80 00       	ld.sh	r0,r0[0x0]
80006516:	5a ea       	cp.w	r10,-18

80006518 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
80006518:	eb cd 40 c0 	pushm	r6-r7,lr
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
8000651c:	78 38       	ld.w	r8,r12[0xc]
8000651e:	70 37       	ld.w	r7,r8[0xc]
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
80006520:	ee c6 ff e8 	sub	r6,r7,-24
80006524:	0c 9c       	mov	r12,r6
80006526:	f0 1f 00 15 	mcall	80006578 <xTaskRemoveFromEventList+0x60>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
8000652a:	49 58       	lddpc	r8,8000657c <xTaskRemoveFromEventList+0x64>
8000652c:	70 08       	ld.w	r8,r8[0x0]
8000652e:	58 08       	cp.w	r8,0
80006530:	c1 71       	brne	8000655e <xTaskRemoveFromEventList+0x46>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
80006532:	ee c6 ff fc 	sub	r6,r7,-4
80006536:	0c 9c       	mov	r12,r6
80006538:	f0 1f 00 10 	mcall	80006578 <xTaskRemoveFromEventList+0x60>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
8000653c:	6e bc       	ld.w	r12,r7[0x2c]
8000653e:	49 18       	lddpc	r8,80006580 <xTaskRemoveFromEventList+0x68>
80006540:	70 08       	ld.w	r8,r8[0x0]
80006542:	10 3c       	cp.w	r12,r8
80006544:	e0 88 00 04 	brls	8000654c <xTaskRemoveFromEventList+0x34>
80006548:	48 e8       	lddpc	r8,80006580 <xTaskRemoveFromEventList+0x68>
8000654a:	91 0c       	st.w	r8[0x0],r12
8000654c:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006550:	0c 9b       	mov	r11,r6
80006552:	48 d8       	lddpc	r8,80006584 <xTaskRemoveFromEventList+0x6c>
80006554:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80006558:	f0 1f 00 0c 	mcall	80006588 <xTaskRemoveFromEventList+0x70>
8000655c:	c0 58       	rjmp	80006566 <xTaskRemoveFromEventList+0x4e>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
8000655e:	0c 9b       	mov	r11,r6
80006560:	48 bc       	lddpc	r12,8000658c <xTaskRemoveFromEventList+0x74>
80006562:	f0 1f 00 0a 	mcall	80006588 <xTaskRemoveFromEventList+0x70>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
80006566:	48 b8       	lddpc	r8,80006590 <xTaskRemoveFromEventList+0x78>
80006568:	70 08       	ld.w	r8,r8[0x0]
8000656a:	6e b9       	ld.w	r9,r7[0x2c]
8000656c:	70 b8       	ld.w	r8,r8[0x2c]
8000656e:	10 39       	cp.w	r9,r8
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
80006570:	5f 2c       	srhs	r12
80006572:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006576:	00 00       	add	r0,r0
80006578:	80 00       	ld.sh	r0,r0[0x0]
8000657a:	5b 3a       	cp.w	r10,-13
8000657c:	00 00       	add	r0,r0
8000657e:	0d 1c       	ld.sh	r12,r6++
80006580:	00 00       	add	r0,r0
80006582:	0d 54       	ld.sh	r4,--r6
80006584:	00 00       	add	r0,r0
80006586:	0c 38       	cp.w	r8,r6
80006588:	80 00       	ld.sh	r0,r0[0x0]
8000658a:	5a ea       	cp.w	r10,-18
8000658c:	00 00       	add	r0,r0
8000658e:	0c f0       	st.b	--r6,r0
80006590:	00 00       	add	r0,r0
80006592:	0c ec       	st.h	--r6,r12

80006594 <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
80006594:	eb cd 40 fc 	pushm	r2-r7,lr
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80006598:	4b 98       	lddpc	r8,8000667c <vTaskIncrementTick+0xe8>
8000659a:	70 08       	ld.w	r8,r8[0x0]
8000659c:	58 08       	cp.w	r8,0
8000659e:	c6 91       	brne	80006670 <vTaskIncrementTick+0xdc>
	{
		++xTickCount;
800065a0:	4b 88       	lddpc	r8,80006680 <vTaskIncrementTick+0xec>
800065a2:	70 09       	ld.w	r9,r8[0x0]
800065a4:	2f f9       	sub	r9,-1
800065a6:	91 09       	st.w	r8[0x0],r9
		if( xTickCount == ( portTickType ) 0 )
800065a8:	70 08       	ld.w	r8,r8[0x0]
800065aa:	58 08       	cp.w	r8,0
800065ac:	c1 a1       	brne	800065e0 <vTaskIncrementTick+0x4c>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
800065ae:	4b 68       	lddpc	r8,80006684 <vTaskIncrementTick+0xf0>
800065b0:	70 0a       	ld.w	r10,r8[0x0]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
800065b2:	4b 69       	lddpc	r9,80006688 <vTaskIncrementTick+0xf4>
800065b4:	72 0b       	ld.w	r11,r9[0x0]
800065b6:	91 0b       	st.w	r8[0x0],r11
			pxOverflowDelayedTaskList = pxTemp;
800065b8:	93 0a       	st.w	r9[0x0],r10
			xNumOfOverflows++;
800065ba:	4b 59       	lddpc	r9,8000668c <vTaskIncrementTick+0xf8>
800065bc:	72 0a       	ld.w	r10,r9[0x0]
800065be:	2f fa       	sub	r10,-1
800065c0:	93 0a       	st.w	r9[0x0],r10

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
800065c2:	70 08       	ld.w	r8,r8[0x0]
800065c4:	70 08       	ld.w	r8,r8[0x0]
800065c6:	58 08       	cp.w	r8,0
800065c8:	c0 51       	brne	800065d2 <vTaskIncrementTick+0x3e>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
800065ca:	3f f9       	mov	r9,-1
800065cc:	4b 18       	lddpc	r8,80006690 <vTaskIncrementTick+0xfc>
800065ce:	91 09       	st.w	r8[0x0],r9
800065d0:	c0 88       	rjmp	800065e0 <vTaskIncrementTick+0x4c>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
800065d2:	4a d8       	lddpc	r8,80006684 <vTaskIncrementTick+0xf0>
800065d4:	70 08       	ld.w	r8,r8[0x0]
800065d6:	70 38       	ld.w	r8,r8[0xc]
800065d8:	70 38       	ld.w	r8,r8[0xc]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
800065da:	70 19       	ld.w	r9,r8[0x4]
800065dc:	4a d8       	lddpc	r8,80006690 <vTaskIncrementTick+0xfc>
800065de:	91 09       	st.w	r8[0x0],r9
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
800065e0:	4a 88       	lddpc	r8,80006680 <vTaskIncrementTick+0xec>
800065e2:	70 09       	ld.w	r9,r8[0x0]
800065e4:	4a b8       	lddpc	r8,80006690 <vTaskIncrementTick+0xfc>
800065e6:	70 08       	ld.w	r8,r8[0x0]
800065e8:	10 39       	cp.w	r9,r8
800065ea:	c4 73       	brcs	80006678 <vTaskIncrementTick+0xe4>
800065ec:	4a 68       	lddpc	r8,80006684 <vTaskIncrementTick+0xf0>
800065ee:	70 08       	ld.w	r8,r8[0x0]
800065f0:	70 08       	ld.w	r8,r8[0x0]
800065f2:	58 08       	cp.w	r8,0
800065f4:	c0 c0       	breq	8000660c <vTaskIncrementTick+0x78>
800065f6:	4a 48       	lddpc	r8,80006684 <vTaskIncrementTick+0xf0>
800065f8:	70 08       	ld.w	r8,r8[0x0]
800065fa:	70 38       	ld.w	r8,r8[0xc]
800065fc:	70 37       	ld.w	r7,r8[0xc]
800065fe:	6e 18       	ld.w	r8,r7[0x4]
80006600:	4a 09       	lddpc	r9,80006680 <vTaskIncrementTick+0xec>
80006602:	72 09       	ld.w	r9,r9[0x0]
80006604:	12 38       	cp.w	r8,r9
80006606:	e0 88 00 14 	brls	8000662e <vTaskIncrementTick+0x9a>
8000660a:	c0 e8       	rjmp	80006626 <vTaskIncrementTick+0x92>
8000660c:	3f f9       	mov	r9,-1
8000660e:	4a 18       	lddpc	r8,80006690 <vTaskIncrementTick+0xfc>
80006610:	91 09       	st.w	r8[0x0],r9
80006612:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80006616:	6a 08       	ld.w	r8,r5[0x0]
80006618:	70 38       	ld.w	r8,r8[0xc]
8000661a:	70 37       	ld.w	r7,r8[0xc]
8000661c:	6e 18       	ld.w	r8,r7[0x4]
8000661e:	64 09       	ld.w	r9,r2[0x0]
80006620:	12 38       	cp.w	r8,r9
80006622:	e0 88 00 0a 	brls	80006636 <vTaskIncrementTick+0xa2>
80006626:	49 b9       	lddpc	r9,80006690 <vTaskIncrementTick+0xfc>
80006628:	93 08       	st.w	r9[0x0],r8
8000662a:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
8000662e:	49 a4       	lddpc	r4,80006694 <vTaskIncrementTick+0x100>
80006630:	49 a3       	lddpc	r3,80006698 <vTaskIncrementTick+0x104>
80006632:	49 55       	lddpc	r5,80006684 <vTaskIncrementTick+0xf0>
80006634:	49 32       	lddpc	r2,80006680 <vTaskIncrementTick+0xec>
80006636:	ee c6 ff fc 	sub	r6,r7,-4
8000663a:	0c 9c       	mov	r12,r6
8000663c:	f0 1f 00 18 	mcall	8000669c <vTaskIncrementTick+0x108>
80006640:	6e a8       	ld.w	r8,r7[0x28]
80006642:	58 08       	cp.w	r8,0
80006644:	c0 50       	breq	8000664e <vTaskIncrementTick+0xba>
80006646:	ee cc ff e8 	sub	r12,r7,-24
8000664a:	f0 1f 00 15 	mcall	8000669c <vTaskIncrementTick+0x108>
8000664e:	6e bc       	ld.w	r12,r7[0x2c]
80006650:	68 08       	ld.w	r8,r4[0x0]
80006652:	10 3c       	cp.w	r12,r8
80006654:	e9 fc ba 00 	st.whi	r4[0x0],r12
80006658:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
8000665c:	0c 9b       	mov	r11,r6
8000665e:	e6 0c 00 2c 	add	r12,r3,r12<<0x2
80006662:	f0 1f 00 10 	mcall	800066a0 <vTaskIncrementTick+0x10c>
80006666:	6a 08       	ld.w	r8,r5[0x0]
80006668:	70 08       	ld.w	r8,r8[0x0]
8000666a:	58 08       	cp.w	r8,0
8000666c:	cd 51       	brne	80006616 <vTaskIncrementTick+0x82>
8000666e:	cc fb       	rjmp	8000660c <vTaskIncrementTick+0x78>
	}
	else
	{
		++uxMissedTicks;
80006670:	48 d8       	lddpc	r8,800066a4 <vTaskIncrementTick+0x110>
80006672:	70 09       	ld.w	r9,r8[0x0]
80006674:	2f f9       	sub	r9,-1
80006676:	91 09       	st.w	r8[0x0],r9
80006678:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
8000667c:	00 00       	add	r0,r0
8000667e:	0d 1c       	ld.sh	r12,r6++
80006680:	00 00       	add	r0,r0
80006682:	0d 18       	ld.sh	r8,r6++
80006684:	00 00       	add	r0,r0
80006686:	0c 24       	rsub	r4,r6
80006688:	00 00       	add	r0,r0
8000668a:	0c 34       	cp.w	r4,r6
8000668c:	00 00       	add	r0,r0
8000668e:	0c 30       	cp.w	r0,r6
80006690:	00 00       	add	r0,r0
80006692:	05 38       	ld.ub	r8,r2++
80006694:	00 00       	add	r0,r0
80006696:	0d 54       	ld.sh	r4,--r6
80006698:	00 00       	add	r0,r0
8000669a:	0c 38       	cp.w	r8,r6
8000669c:	80 00       	ld.sh	r0,r0[0x0]
8000669e:	5b 3a       	cp.w	r10,-13
800066a0:	80 00       	ld.sh	r0,r0[0x0]
800066a2:	5a ea       	cp.w	r10,-18
800066a4:	00 00       	add	r0,r0
800066a6:	0c 1c       	sub	r12,r6

800066a8 <xTaskCheckForTimeOut>:
	pxTimeOut->xTimeOnEntering = xTickCount;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
800066a8:	eb cd 40 c0 	pushm	r6-r7,lr
800066ac:	18 97       	mov	r7,r12
800066ae:	16 96       	mov	r6,r11
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
800066b0:	f0 1f 00 15 	mcall	80006704 <xTaskCheckForTimeOut+0x5c>
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
800066b4:	6c 08       	ld.w	r8,r6[0x0]
800066b6:	5b f8       	cp.w	r8,-1
800066b8:	c0 31       	brne	800066be <xTaskCheckForTimeOut+0x16>
800066ba:	30 07       	mov	r7,0
800066bc:	c1 f8       	rjmp	800066fa <xTaskCheckForTimeOut+0x52>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
800066be:	49 39       	lddpc	r9,80006708 <xTaskCheckForTimeOut+0x60>
800066c0:	72 09       	ld.w	r9,r9[0x0]
800066c2:	6e 0a       	ld.w	r10,r7[0x0]
800066c4:	12 3a       	cp.w	r10,r9
800066c6:	c0 70       	breq	800066d4 <xTaskCheckForTimeOut+0x2c>
800066c8:	49 19       	lddpc	r9,8000670c <xTaskCheckForTimeOut+0x64>
800066ca:	72 09       	ld.w	r9,r9[0x0]
800066cc:	6e 1a       	ld.w	r10,r7[0x4]
800066ce:	12 3a       	cp.w	r10,r9
800066d0:	e0 88 00 14 	brls	800066f8 <xTaskCheckForTimeOut+0x50>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
800066d4:	48 e9       	lddpc	r9,8000670c <xTaskCheckForTimeOut+0x64>
800066d6:	72 0a       	ld.w	r10,r9[0x0]
800066d8:	6e 19       	ld.w	r9,r7[0x4]
800066da:	12 1a       	sub	r10,r9
800066dc:	14 38       	cp.w	r8,r10
800066de:	e0 88 00 0d 	brls	800066f8 <xTaskCheckForTimeOut+0x50>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
800066e2:	48 ba       	lddpc	r10,8000670c <xTaskCheckForTimeOut+0x64>
800066e4:	74 0a       	ld.w	r10,r10[0x0]
800066e6:	14 19       	sub	r9,r10
800066e8:	f2 08 00 08 	add	r8,r9,r8
800066ec:	8d 08       	st.w	r6[0x0],r8
			vTaskSetTimeOutState( pxTimeOut );
800066ee:	0e 9c       	mov	r12,r7
800066f0:	f0 1f 00 08 	mcall	80006710 <xTaskCheckForTimeOut+0x68>
800066f4:	30 07       	mov	r7,0
800066f6:	c0 28       	rjmp	800066fa <xTaskCheckForTimeOut+0x52>
800066f8:	30 17       	mov	r7,1
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
800066fa:	f0 1f 00 07 	mcall	80006714 <xTaskCheckForTimeOut+0x6c>

	return xReturn;
}
800066fe:	0e 9c       	mov	r12,r7
80006700:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006704:	80 00       	ld.sh	r0,r0[0x0]
80006706:	5b f4       	cp.w	r4,-1
80006708:	00 00       	add	r0,r0
8000670a:	0c 30       	cp.w	r0,r6
8000670c:	00 00       	add	r0,r0
8000670e:	0d 18       	ld.sh	r8,r6++
80006710:	80 00       	ld.sh	r0,r0[0x0]
80006712:	64 0c       	ld.w	r12,r2[0x0]
80006714:	80 00       	ld.sh	r0,r0[0x0]
80006716:	5d 00       	ror	r0

80006718 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
80006718:	eb cd 40 80 	pushm	r7,lr
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
8000671c:	f0 1f 00 05 	mcall	80006730 <xTaskGetTickCount+0x18>
	{
		xTicks = xTickCount;
80006720:	48 58       	lddpc	r8,80006734 <xTaskGetTickCount+0x1c>
80006722:	70 07       	ld.w	r7,r8[0x0]
	}
	taskEXIT_CRITICAL();
80006724:	f0 1f 00 05 	mcall	80006738 <xTaskGetTickCount+0x20>

	return xTicks;
}
80006728:	0e 9c       	mov	r12,r7
8000672a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000672e:	00 00       	add	r0,r0
80006730:	80 00       	ld.sh	r0,r0[0x0]
80006732:	5b f4       	cp.w	r4,-1
80006734:	00 00       	add	r0,r0
80006736:	0d 18       	ld.sh	r8,r6++
80006738:	80 00       	ld.sh	r0,r0[0x0]
8000673a:	5d 00       	ror	r0

8000673c <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
8000673c:	eb cd 40 fe 	pushm	r1-r7,lr
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
80006740:	f0 1f 00 2c 	mcall	800067f0 <xTaskResumeAll+0xb4>
	{
		--uxSchedulerSuspended;
80006744:	4a c8       	lddpc	r8,800067f4 <xTaskResumeAll+0xb8>
80006746:	70 09       	ld.w	r9,r8[0x0]
80006748:	20 19       	sub	r9,1
8000674a:	91 09       	st.w	r8[0x0],r9

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
8000674c:	70 08       	ld.w	r8,r8[0x0]
8000674e:	58 08       	cp.w	r8,0
80006750:	c4 91       	brne	800067e2 <xTaskResumeAll+0xa6>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
80006752:	4a a8       	lddpc	r8,800067f8 <xTaskResumeAll+0xbc>
80006754:	70 08       	ld.w	r8,r8[0x0]
80006756:	58 08       	cp.w	r8,0
80006758:	c4 50       	breq	800067e2 <xTaskResumeAll+0xa6>
8000675a:	30 04       	mov	r4,0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
8000675c:	4a 85       	lddpc	r5,800067fc <xTaskResumeAll+0xc0>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
8000675e:	4a 93       	lddpc	r3,80006800 <xTaskResumeAll+0xc4>
80006760:	4a 92       	lddpc	r2,80006804 <xTaskResumeAll+0xc8>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80006762:	4a a1       	lddpc	r1,80006808 <xTaskResumeAll+0xcc>
80006764:	c1 e8       	rjmp	800067a0 <xTaskResumeAll+0x64>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
80006766:	6a 38       	ld.w	r8,r5[0xc]
80006768:	70 37       	ld.w	r7,r8[0xc]
					vListRemove( &( pxTCB->xEventListItem ) );
8000676a:	ee cc ff e8 	sub	r12,r7,-24
8000676e:	f0 1f 00 28 	mcall	8000680c <xTaskResumeAll+0xd0>
					vListRemove( &( pxTCB->xGenericListItem ) );
80006772:	ee c6 ff fc 	sub	r6,r7,-4
80006776:	0c 9c       	mov	r12,r6
80006778:	f0 1f 00 25 	mcall	8000680c <xTaskResumeAll+0xd0>
					prvAddTaskToReadyQueue( pxTCB );
8000677c:	6e bc       	ld.w	r12,r7[0x2c]
8000677e:	66 08       	ld.w	r8,r3[0x0]
80006780:	10 3c       	cp.w	r12,r8
80006782:	e7 fc ba 00 	st.whi	r3[0x0],r12
80006786:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
8000678a:	0c 9b       	mov	r11,r6
8000678c:	e4 0c 00 2c 	add	r12,r2,r12<<0x2
80006790:	f0 1f 00 20 	mcall	80006810 <xTaskResumeAll+0xd4>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80006794:	62 08       	ld.w	r8,r1[0x0]
80006796:	6e b9       	ld.w	r9,r7[0x2c]
80006798:	70 b8       	ld.w	r8,r8[0x2c]
8000679a:	10 39       	cp.w	r9,r8
8000679c:	f9 b4 02 01 	movhs	r4,1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
800067a0:	6a 08       	ld.w	r8,r5[0x0]
800067a2:	58 08       	cp.w	r8,0
800067a4:	ce 11       	brne	80006766 <xTaskResumeAll+0x2a>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
800067a6:	49 c8       	lddpc	r8,80006814 <xTaskResumeAll+0xd8>
800067a8:	70 08       	ld.w	r8,r8[0x0]
800067aa:	58 08       	cp.w	r8,0
800067ac:	c0 f0       	breq	800067ca <xTaskResumeAll+0x8e>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
800067ae:	49 a8       	lddpc	r8,80006814 <xTaskResumeAll+0xd8>
800067b0:	70 08       	ld.w	r8,r8[0x0]
800067b2:	58 08       	cp.w	r8,0
800067b4:	c1 10       	breq	800067d6 <xTaskResumeAll+0x9a>
					{
						vTaskIncrementTick();
						--uxMissedTicks;
800067b6:	49 87       	lddpc	r7,80006814 <xTaskResumeAll+0xd8>
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
800067b8:	f0 1f 00 18 	mcall	80006818 <xTaskResumeAll+0xdc>
						--uxMissedTicks;
800067bc:	6e 08       	ld.w	r8,r7[0x0]
800067be:	20 18       	sub	r8,1
800067c0:	8f 08       	st.w	r7[0x0],r8
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
800067c2:	6e 08       	ld.w	r8,r7[0x0]
800067c4:	58 08       	cp.w	r8,0
800067c6:	cf 91       	brne	800067b8 <xTaskResumeAll+0x7c>
800067c8:	c0 78       	rjmp	800067d6 <xTaskResumeAll+0x9a>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
800067ca:	58 14       	cp.w	r4,1
800067cc:	c0 50       	breq	800067d6 <xTaskResumeAll+0x9a>
800067ce:	49 48       	lddpc	r8,8000681c <xTaskResumeAll+0xe0>
800067d0:	70 08       	ld.w	r8,r8[0x0]
800067d2:	58 18       	cp.w	r8,1
800067d4:	c0 71       	brne	800067e2 <xTaskResumeAll+0xa6>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
800067d6:	30 09       	mov	r9,0
800067d8:	49 18       	lddpc	r8,8000681c <xTaskResumeAll+0xe0>
800067da:	91 09       	st.w	r8[0x0],r9
					portYIELD_WITHIN_API();
800067dc:	d7 33       	scall
800067de:	30 17       	mov	r7,1
800067e0:	c0 28       	rjmp	800067e4 <xTaskResumeAll+0xa8>
800067e2:	30 07       	mov	r7,0
				}
			}
		}
	}
	taskEXIT_CRITICAL();
800067e4:	f0 1f 00 0f 	mcall	80006820 <xTaskResumeAll+0xe4>

	return xAlreadyYielded;
}
800067e8:	0e 9c       	mov	r12,r7
800067ea:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
800067ee:	00 00       	add	r0,r0
800067f0:	80 00       	ld.sh	r0,r0[0x0]
800067f2:	5b f4       	cp.w	r4,-1
800067f4:	00 00       	add	r0,r0
800067f6:	0d 1c       	ld.sh	r12,r6++
800067f8:	00 00       	add	r0,r0
800067fa:	0d 38       	ld.ub	r8,r6++
800067fc:	00 00       	add	r0,r0
800067fe:	0c f0       	st.b	--r6,r0
80006800:	00 00       	add	r0,r0
80006802:	0d 54       	ld.sh	r4,--r6
80006804:	00 00       	add	r0,r0
80006806:	0c 38       	cp.w	r8,r6
80006808:	00 00       	add	r0,r0
8000680a:	0c ec       	st.h	--r6,r12
8000680c:	80 00       	ld.sh	r0,r0[0x0]
8000680e:	5b 3a       	cp.w	r10,-13
80006810:	80 00       	ld.sh	r0,r0[0x0]
80006812:	5a ea       	cp.w	r10,-18
80006814:	00 00       	add	r0,r0
80006816:	0c 1c       	sub	r12,r6
80006818:	80 00       	ld.sh	r0,r0[0x0]
8000681a:	65 94       	ld.w	r4,r2[0x64]
8000681c:	00 00       	add	r0,r0
8000681e:	0d 3c       	ld.ub	r12,r6++
80006820:	80 00       	ld.sh	r0,r0[0x0]
80006822:	5d 00       	ror	r0

80006824 <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
80006824:	eb cd 40 80 	pushm	r7,lr
80006828:	18 97       	mov	r7,r12
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
8000682a:	49 08       	lddpc	r8,80006868 <prvAddCurrentTaskToDelayedList+0x44>
8000682c:	70 08       	ld.w	r8,r8[0x0]
8000682e:	91 1c       	st.w	r8[0x4],r12

	if( xTimeToWake < xTickCount )
80006830:	48 f8       	lddpc	r8,8000686c <prvAddCurrentTaskToDelayedList+0x48>
80006832:	70 08       	ld.w	r8,r8[0x0]
80006834:	10 3c       	cp.w	r12,r8
80006836:	c0 a2       	brcc	8000684a <prvAddCurrentTaskToDelayedList+0x26>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006838:	48 c8       	lddpc	r8,80006868 <prvAddCurrentTaskToDelayedList+0x44>
8000683a:	70 0b       	ld.w	r11,r8[0x0]
8000683c:	48 d8       	lddpc	r8,80006870 <prvAddCurrentTaskToDelayedList+0x4c>
8000683e:	70 0c       	ld.w	r12,r8[0x0]
80006840:	2f cb       	sub	r11,-4
80006842:	f0 1f 00 0d 	mcall	80006874 <prvAddCurrentTaskToDelayedList+0x50>
80006846:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
8000684a:	48 88       	lddpc	r8,80006868 <prvAddCurrentTaskToDelayedList+0x44>
8000684c:	70 0b       	ld.w	r11,r8[0x0]
8000684e:	48 b8       	lddpc	r8,80006878 <prvAddCurrentTaskToDelayedList+0x54>
80006850:	70 0c       	ld.w	r12,r8[0x0]
80006852:	2f cb       	sub	r11,-4
80006854:	f0 1f 00 08 	mcall	80006874 <prvAddCurrentTaskToDelayedList+0x50>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
80006858:	48 98       	lddpc	r8,8000687c <prvAddCurrentTaskToDelayedList+0x58>
8000685a:	70 08       	ld.w	r8,r8[0x0]
8000685c:	10 37       	cp.w	r7,r8
8000685e:	c0 32       	brcc	80006864 <prvAddCurrentTaskToDelayedList+0x40>
		{
			xNextTaskUnblockTime = xTimeToWake;
80006860:	48 78       	lddpc	r8,8000687c <prvAddCurrentTaskToDelayedList+0x58>
80006862:	91 07       	st.w	r8[0x0],r7
80006864:	e3 cd 80 80 	ldm	sp++,r7,pc
80006868:	00 00       	add	r0,r0
8000686a:	0c ec       	st.h	--r6,r12
8000686c:	00 00       	add	r0,r0
8000686e:	0d 18       	ld.sh	r8,r6++
80006870:	00 00       	add	r0,r0
80006872:	0c 34       	cp.w	r4,r6
80006874:	80 00       	ld.sh	r0,r0[0x0]
80006876:	5b 06       	cp.w	r6,-16
80006878:	00 00       	add	r0,r0
8000687a:	0c 24       	rsub	r4,r6
8000687c:	00 00       	add	r0,r0
8000687e:	05 38       	ld.ub	r8,r2++

80006880 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
80006880:	eb cd 40 c0 	pushm	r6-r7,lr
80006884:	18 97       	mov	r7,r12
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0 )
80006886:	58 0c       	cp.w	r12,0
80006888:	c1 10       	breq	800068aa <vTaskDelay+0x2a>
		{
			vTaskSuspendAll();
8000688a:	f0 1f 00 0a 	mcall	800068b0 <vTaskDelay+0x30>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
8000688e:	48 a8       	lddpc	r8,800068b4 <vTaskDelay+0x34>
80006890:	70 06       	ld.w	r6,r8[0x0]

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006892:	48 a8       	lddpc	r8,800068b8 <vTaskDelay+0x38>
80006894:	70 0c       	ld.w	r12,r8[0x0]
80006896:	2f cc       	sub	r12,-4
80006898:	f0 1f 00 09 	mcall	800068bc <vTaskDelay+0x3c>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
8000689c:	ee 06 00 0c 	add	r12,r7,r6
800068a0:	f0 1f 00 08 	mcall	800068c0 <vTaskDelay+0x40>
			}
			xAlreadyYielded = xTaskResumeAll();
800068a4:	f0 1f 00 08 	mcall	800068c4 <vTaskDelay+0x44>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
800068a8:	c0 21       	brne	800068ac <vTaskDelay+0x2c>
		{
			portYIELD_WITHIN_API();
800068aa:	d7 33       	scall
800068ac:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800068b0:	80 00       	ld.sh	r0,r0[0x0]
800068b2:	63 80       	ld.w	r0,r1[0x60]
800068b4:	00 00       	add	r0,r0
800068b6:	0d 18       	ld.sh	r8,r6++
800068b8:	00 00       	add	r0,r0
800068ba:	0c ec       	st.h	--r6,r12
800068bc:	80 00       	ld.sh	r0,r0[0x0]
800068be:	5b 3a       	cp.w	r10,-13
800068c0:	80 00       	ld.sh	r0,r0[0x0]
800068c2:	68 24       	ld.w	r4,r4[0x8]
800068c4:	80 00       	ld.sh	r0,r0[0x0]
800068c6:	67 3c       	ld.w	r12,r3[0x4c]

800068c8 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
800068c8:	eb cd 40 c0 	pushm	r6-r7,lr
800068cc:	18 96       	mov	r6,r12
800068ce:	16 97       	mov	r7,r11
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0 ) );

		vTaskSuspendAll();
800068d0:	f0 1f 00 18 	mcall	80006930 <vTaskDelayUntil+0x68>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
800068d4:	6c 08       	ld.w	r8,r6[0x0]
800068d6:	10 07       	add	r7,r8

			if( xTickCount < *pxPreviousWakeTime )
800068d8:	49 79       	lddpc	r9,80006934 <vTaskDelayUntil+0x6c>
800068da:	72 09       	ld.w	r9,r9[0x0]
800068dc:	12 38       	cp.w	r8,r9
800068de:	e0 88 00 0c 	brls	800068f6 <vTaskDelayUntil+0x2e>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
800068e2:	0e 38       	cp.w	r8,r7
800068e4:	e0 88 00 22 	brls	80006928 <vTaskDelayUntil+0x60>
800068e8:	49 38       	lddpc	r8,80006934 <vTaskDelayUntil+0x6c>
800068ea:	70 08       	ld.w	r8,r8[0x0]
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
800068ec:	8d 07       	st.w	r6[0x0],r7

			if( xShouldDelay != pdFALSE )
800068ee:	10 37       	cp.w	r7,r8
800068f0:	e0 88 00 14 	brls	80006918 <vTaskDelayUntil+0x50>
800068f4:	c0 a8       	rjmp	80006908 <vTaskDelayUntil+0x40>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
800068f6:	0e 38       	cp.w	r8,r7
800068f8:	e0 8b 00 16 	brhi	80006924 <vTaskDelayUntil+0x5c>
800068fc:	48 e8       	lddpc	r8,80006934 <vTaskDelayUntil+0x6c>
800068fe:	70 08       	ld.w	r8,r8[0x0]
80006900:	10 37       	cp.w	r7,r8
80006902:	e0 8b 00 11 	brhi	80006924 <vTaskDelayUntil+0x5c>
80006906:	c1 18       	rjmp	80006928 <vTaskDelayUntil+0x60>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006908:	48 c8       	lddpc	r8,80006938 <vTaskDelayUntil+0x70>
8000690a:	70 0c       	ld.w	r12,r8[0x0]
8000690c:	2f cc       	sub	r12,-4
8000690e:	f0 1f 00 0c 	mcall	8000693c <vTaskDelayUntil+0x74>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
80006912:	0e 9c       	mov	r12,r7
80006914:	f0 1f 00 0b 	mcall	80006940 <vTaskDelayUntil+0x78>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
80006918:	f0 1f 00 0b 	mcall	80006944 <vTaskDelayUntil+0x7c>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
8000691c:	c0 81       	brne	8000692c <vTaskDelayUntil+0x64>
		{
			portYIELD_WITHIN_API();
8000691e:	d7 33       	scall
80006920:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80006924:	8d 07       	st.w	r6[0x0],r7
80006926:	cf 1b       	rjmp	80006908 <vTaskDelayUntil+0x40>
80006928:	8d 07       	st.w	r6[0x0],r7
8000692a:	cf 7b       	rjmp	80006918 <vTaskDelayUntil+0x50>
8000692c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006930:	80 00       	ld.sh	r0,r0[0x0]
80006932:	63 80       	ld.w	r0,r1[0x60]
80006934:	00 00       	add	r0,r0
80006936:	0d 18       	ld.sh	r8,r6++
80006938:	00 00       	add	r0,r0
8000693a:	0c ec       	st.h	--r6,r12
8000693c:	80 00       	ld.sh	r0,r0[0x0]
8000693e:	5b 3a       	cp.w	r10,-13
80006940:	80 00       	ld.sh	r0,r0[0x0]
80006942:	68 24       	ld.w	r4,r4[0x8]
80006944:	80 00       	ld.sh	r0,r0[0x0]
80006946:	67 3c       	ld.w	r12,r3[0x4c]

80006948 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
80006948:	eb cd 40 c0 	pushm	r6-r7,lr
8000694c:	16 96       	mov	r6,r11
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
8000694e:	48 e7       	lddpc	r7,80006984 <vTaskPlaceOnEventList+0x3c>
80006950:	6e 0b       	ld.w	r11,r7[0x0]
80006952:	2e 8b       	sub	r11,-24
80006954:	f0 1f 00 0d 	mcall	80006988 <vTaskPlaceOnEventList+0x40>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006958:	6e 0c       	ld.w	r12,r7[0x0]
8000695a:	2f cc       	sub	r12,-4
8000695c:	f0 1f 00 0c 	mcall	8000698c <vTaskPlaceOnEventList+0x44>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
80006960:	5b f6       	cp.w	r6,-1
80006962:	c0 81       	brne	80006972 <vTaskPlaceOnEventList+0x2a>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006964:	6e 0b       	ld.w	r11,r7[0x0]
80006966:	2f cb       	sub	r11,-4
80006968:	48 ac       	lddpc	r12,80006990 <vTaskPlaceOnEventList+0x48>
8000696a:	f0 1f 00 0b 	mcall	80006994 <vTaskPlaceOnEventList+0x4c>
8000696e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
80006972:	48 a8       	lddpc	r8,80006998 <vTaskPlaceOnEventList+0x50>
80006974:	70 0c       	ld.w	r12,r8[0x0]
			prvAddCurrentTaskToDelayedList( xTimeToWake );
80006976:	ec 0c 00 0c 	add	r12,r6,r12
8000697a:	f0 1f 00 09 	mcall	8000699c <vTaskPlaceOnEventList+0x54>
8000697e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006982:	00 00       	add	r0,r0
80006984:	00 00       	add	r0,r0
80006986:	0c ec       	st.h	--r6,r12
80006988:	80 00       	ld.sh	r0,r0[0x0]
8000698a:	5b 06       	cp.w	r6,-16
8000698c:	80 00       	ld.sh	r0,r0[0x0]
8000698e:	5b 3a       	cp.w	r10,-13
80006990:	00 00       	add	r0,r0
80006992:	0d 40       	ld.w	r0,--r6
80006994:	80 00       	ld.sh	r0,r0[0x0]
80006996:	5a ea       	cp.w	r10,-18
80006998:	00 00       	add	r0,r0
8000699a:	0d 18       	ld.sh	r8,r6++
8000699c:	80 00       	ld.sh	r0,r0[0x0]
8000699e:	68 24       	ld.w	r4,r4[0x8]

800069a0 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
800069a0:	eb cd 40 f8 	pushm	r3-r7,lr
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
800069a4:	49 67       	lddpc	r7,800069fc <prvIdleTask+0x5c>
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
800069a6:	49 74       	lddpc	r4,80006a00 <prvIdleTask+0x60>

				taskENTER_CRITICAL();
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					--uxCurrentNumberOfTasks;
800069a8:	49 73       	lddpc	r3,80006a04 <prvIdleTask+0x64>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
800069aa:	49 85       	lddpc	r5,80006a08 <prvIdleTask+0x68>
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
800069ac:	6e 08       	ld.w	r8,r7[0x0]
800069ae:	58 08       	cp.w	r8,0
800069b0:	c1 e0       	breq	800069ec <prvIdleTask+0x4c>
		{
			vTaskSuspendAll();
800069b2:	f0 1f 00 17 	mcall	80006a0c <prvIdleTask+0x6c>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
800069b6:	68 06       	ld.w	r6,r4[0x0]
			xTaskResumeAll();
800069b8:	f0 1f 00 16 	mcall	80006a10 <prvIdleTask+0x70>

			if( xListIsEmpty == pdFALSE )
800069bc:	58 06       	cp.w	r6,0
800069be:	c1 70       	breq	800069ec <prvIdleTask+0x4c>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
800069c0:	f0 1f 00 15 	mcall	80006a14 <prvIdleTask+0x74>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
800069c4:	68 38       	ld.w	r8,r4[0xc]
800069c6:	70 36       	ld.w	r6,r8[0xc]
					vListRemove( &( pxTCB->xGenericListItem ) );
800069c8:	ec cc ff fc 	sub	r12,r6,-4
800069cc:	f0 1f 00 13 	mcall	80006a18 <prvIdleTask+0x78>
					--uxCurrentNumberOfTasks;
800069d0:	66 08       	ld.w	r8,r3[0x0]
800069d2:	20 18       	sub	r8,1
800069d4:	87 08       	st.w	r3[0x0],r8
					--uxTasksDeleted;
800069d6:	6e 08       	ld.w	r8,r7[0x0]
800069d8:	20 18       	sub	r8,1
800069da:	8f 08       	st.w	r7[0x0],r8
				}
				taskEXIT_CRITICAL();
800069dc:	f0 1f 00 10 	mcall	80006a1c <prvIdleTask+0x7c>

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
800069e0:	6c cc       	ld.w	r12,r6[0x30]
800069e2:	f0 1f 00 10 	mcall	80006a20 <prvIdleTask+0x80>
		vPortFree( pxTCB );
800069e6:	0c 9c       	mov	r12,r6
800069e8:	f0 1f 00 0e 	mcall	80006a20 <prvIdleTask+0x80>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
800069ec:	6a 08       	ld.w	r8,r5[0x0]
800069ee:	58 18       	cp.w	r8,1
800069f0:	e0 88 00 03 	brls	800069f6 <prvIdleTask+0x56>
			{
				taskYIELD();
800069f4:	d7 33       	scall
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
800069f6:	f0 1f 00 0c 	mcall	80006a24 <prvIdleTask+0x84>
		}
		#endif
	}
800069fa:	cd 9b       	rjmp	800069ac <prvIdleTask+0xc>
800069fc:	00 00       	add	r0,r0
800069fe:	0c 2c       	rsub	r12,r6
80006a00:	00 00       	add	r0,r0
80006a02:	0c d8       	st.w	--r6,r8
80006a04:	00 00       	add	r0,r0
80006a06:	0d 38       	ld.ub	r8,r6++
80006a08:	00 00       	add	r0,r0
80006a0a:	0c 38       	cp.w	r8,r6
80006a0c:	80 00       	ld.sh	r0,r0[0x0]
80006a0e:	63 80       	ld.w	r0,r1[0x60]
80006a10:	80 00       	ld.sh	r0,r0[0x0]
80006a12:	67 3c       	ld.w	r12,r3[0x4c]
80006a14:	80 00       	ld.sh	r0,r0[0x0]
80006a16:	5b f4       	cp.w	r4,-1
80006a18:	80 00       	ld.sh	r0,r0[0x0]
80006a1a:	5b 3a       	cp.w	r10,-13
80006a1c:	80 00       	ld.sh	r0,r0[0x0]
80006a1e:	5d 00       	ror	r0
80006a20:	80 00       	ld.sh	r0,r0[0x0]
80006a22:	5e 38       	retlo	r8
80006a24:	80 00       	ld.sh	r0,r0[0x0]
80006a26:	20 48       	sub	r8,4

80006a28 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
80006a28:	d4 31       	pushm	r0-r7,lr
80006a2a:	20 1d       	sub	sp,4
80006a2c:	fa c4 ff d8 	sub	r4,sp,-40
80006a30:	50 0c       	stdsp	sp[0x0],r12
80006a32:	16 91       	mov	r1,r11
80006a34:	14 97       	mov	r7,r10
80006a36:	12 90       	mov	r0,r9
80006a38:	10 93       	mov	r3,r8
80006a3a:	68 02       	ld.w	r2,r4[0x0]
80006a3c:	68 16       	ld.w	r6,r4[0x4]
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
80006a3e:	34 8c       	mov	r12,72
80006a40:	f0 1f 00 5c 	mcall	80006bb0 <xTaskGenericCreate+0x188>
80006a44:	18 95       	mov	r5,r12

	if( pxNewTCB != NULL )
80006a46:	c0 31       	brne	80006a4c <xTaskGenericCreate+0x24>
80006a48:	3f fc       	mov	r12,-1
80006a4a:	ca f8       	rjmp	80006ba8 <xTaskGenericCreate+0x180>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80006a4c:	58 06       	cp.w	r6,0
80006a4e:	e0 81 00 af 	brne	80006bac <xTaskGenericCreate+0x184>
80006a52:	0e 9c       	mov	r12,r7
80006a54:	5c 7c       	castu.h	r12
80006a56:	a3 6c       	lsl	r12,0x2
80006a58:	f0 1f 00 56 	mcall	80006bb0 <xTaskGenericCreate+0x188>
80006a5c:	18 96       	mov	r6,r12
80006a5e:	8b cc       	st.w	r5[0x30],r12

		if( pxNewTCB->pxStack == NULL )
80006a60:	c0 61       	brne	80006a6c <xTaskGenericCreate+0x44>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
80006a62:	0a 9c       	mov	r12,r5
80006a64:	f0 1f 00 54 	mcall	80006bb4 <xTaskGenericCreate+0x18c>
80006a68:	3f fc       	mov	r12,-1
80006a6a:	c9 f8       	rjmp	80006ba8 <xTaskGenericCreate+0x180>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
80006a6c:	5c 77       	castu.h	r7
80006a6e:	ee 0a 15 02 	lsl	r10,r7,0x2
80006a72:	e0 6b 00 a5 	mov	r11,165
80006a76:	0c 9c       	mov	r12,r6
80006a78:	f0 1f 00 50 	mcall	80006bb8 <xTaskGenericCreate+0x190>
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~portBYTE_ALIGNMENT_MASK  ) );
80006a7c:	ee c6 00 01 	sub	r6,r7,1
80006a80:	6a c8       	ld.w	r8,r5[0x30]
80006a82:	f0 06 00 26 	add	r6,r8,r6<<0x2
80006a86:	e0 16 ff fc 	andl	r6,0xfffc
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
80006a8a:	31 0a       	mov	r10,16
80006a8c:	02 9b       	mov	r11,r1
80006a8e:	ea cc ff cc 	sub	r12,r5,-52
80006a92:	f0 1f 00 4b 	mcall	80006bbc <xTaskGenericCreate+0x194>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
80006a96:	30 08       	mov	r8,0
80006a98:	eb 68 00 43 	st.b	r5[67],r8
80006a9c:	58 73       	cp.w	r3,7
80006a9e:	e6 07 17 80 	movls	r7,r3
80006aa2:	f9 b7 0b 07 	movhi	r7,7
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
80006aa6:	8b b7       	st.w	r5[0x2c],r7
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
80006aa8:	eb 47 00 44 	st.w	r5[68],r7
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
80006aac:	ea c4 ff fc 	sub	r4,r5,-4
80006ab0:	08 9c       	mov	r12,r4
80006ab2:	f0 1f 00 44 	mcall	80006bc0 <xTaskGenericCreate+0x198>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
80006ab6:	ea cc ff e8 	sub	r12,r5,-24
80006aba:	f0 1f 00 42 	mcall	80006bc0 <xTaskGenericCreate+0x198>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
80006abe:	8b 45       	st.w	r5[0x10],r5

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
80006ac0:	ee 07 11 08 	rsub	r7,r7,8
80006ac4:	8b 67       	st.w	r5[0x18],r7
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
80006ac6:	8b 95       	st.w	r5[0x24],r5
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
80006ac8:	00 9a       	mov	r10,r0
80006aca:	40 0b       	lddsp	r11,sp[0x0]
80006acc:	0c 9c       	mov	r12,r6
80006ace:	f0 1f 00 3e 	mcall	80006bc4 <xTaskGenericCreate+0x19c>
80006ad2:	8b 0c       	st.w	r5[0x0],r12
		if( ( void * ) pxCreatedTask != NULL )
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
80006ad4:	58 02       	cp.w	r2,0
80006ad6:	e5 f5 1a 00 	st.wne	r2[0x0],r5
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
80006ada:	f0 1f 00 3c 	mcall	80006bc8 <xTaskGenericCreate+0x1a0>
		{
			uxCurrentNumberOfTasks++;
80006ade:	4b c8       	lddpc	r8,80006bcc <xTaskGenericCreate+0x1a4>
80006ae0:	70 09       	ld.w	r9,r8[0x0]
80006ae2:	2f f9       	sub	r9,-1
80006ae4:	91 09       	st.w	r8[0x0],r9
			if( pxCurrentTCB == NULL )
80006ae6:	4b b8       	lddpc	r8,80006bd0 <xTaskGenericCreate+0x1a8>
80006ae8:	70 08       	ld.w	r8,r8[0x0]
80006aea:	58 08       	cp.w	r8,0
80006aec:	c2 61       	brne	80006b38 <xTaskGenericCreate+0x110>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
80006aee:	4b 98       	lddpc	r8,80006bd0 <xTaskGenericCreate+0x1a8>
80006af0:	91 05       	st.w	r8[0x0],r5

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
80006af2:	4b 78       	lddpc	r8,80006bcc <xTaskGenericCreate+0x1a4>
80006af4:	70 08       	ld.w	r8,r8[0x0]
80006af6:	58 18       	cp.w	r8,1
80006af8:	c2 b1       	brne	80006b4e <xTaskGenericCreate+0x126>
80006afa:	4b 77       	lddpc	r7,80006bd4 <xTaskGenericCreate+0x1ac>

/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
80006afc:	ee c6 ff 60 	sub	r6,r7,-160
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
80006b00:	0e 9c       	mov	r12,r7
80006b02:	f0 1f 00 36 	mcall	80006bd8 <xTaskGenericCreate+0x1b0>
80006b06:	2e c7       	sub	r7,-20

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
80006b08:	0c 37       	cp.w	r7,r6
80006b0a:	cf b1       	brne	80006b00 <xTaskGenericCreate+0xd8>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
80006b0c:	4b 47       	lddpc	r7,80006bdc <xTaskGenericCreate+0x1b4>
80006b0e:	0e 9c       	mov	r12,r7
80006b10:	f0 1f 00 32 	mcall	80006bd8 <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
80006b14:	4b 36       	lddpc	r6,80006be0 <xTaskGenericCreate+0x1b8>
80006b16:	0c 9c       	mov	r12,r6
80006b18:	f0 1f 00 30 	mcall	80006bd8 <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xPendingReadyList );
80006b1c:	4b 2c       	lddpc	r12,80006be4 <xTaskGenericCreate+0x1bc>
80006b1e:	f0 1f 00 2f 	mcall	80006bd8 <xTaskGenericCreate+0x1b0>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
80006b22:	4b 2c       	lddpc	r12,80006be8 <xTaskGenericCreate+0x1c0>
80006b24:	f0 1f 00 2d 	mcall	80006bd8 <xTaskGenericCreate+0x1b0>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
80006b28:	4b 1c       	lddpc	r12,80006bec <xTaskGenericCreate+0x1c4>
80006b2a:	f0 1f 00 2c 	mcall	80006bd8 <xTaskGenericCreate+0x1b0>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
80006b2e:	4b 18       	lddpc	r8,80006bf0 <xTaskGenericCreate+0x1c8>
80006b30:	91 07       	st.w	r8[0x0],r7
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
80006b32:	4b 18       	lddpc	r8,80006bf4 <xTaskGenericCreate+0x1cc>
80006b34:	91 06       	st.w	r8[0x0],r6
80006b36:	c0 c8       	rjmp	80006b4e <xTaskGenericCreate+0x126>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
80006b38:	4b 08       	lddpc	r8,80006bf8 <xTaskGenericCreate+0x1d0>
80006b3a:	70 08       	ld.w	r8,r8[0x0]
80006b3c:	58 08       	cp.w	r8,0
80006b3e:	c0 81       	brne	80006b4e <xTaskGenericCreate+0x126>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
80006b40:	4a 48       	lddpc	r8,80006bd0 <xTaskGenericCreate+0x1a8>
80006b42:	70 08       	ld.w	r8,r8[0x0]
80006b44:	70 b8       	ld.w	r8,r8[0x2c]
80006b46:	10 33       	cp.w	r3,r8
80006b48:	c0 33       	brcs	80006b4e <xTaskGenericCreate+0x126>
					{
						pxCurrentTCB = pxNewTCB;
80006b4a:	4a 28       	lddpc	r8,80006bd0 <xTaskGenericCreate+0x1a8>
80006b4c:	91 05       	st.w	r8[0x0],r5
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
80006b4e:	6a b8       	ld.w	r8,r5[0x2c]
80006b50:	4a b9       	lddpc	r9,80006bfc <xTaskGenericCreate+0x1d4>
80006b52:	72 09       	ld.w	r9,r9[0x0]
80006b54:	12 38       	cp.w	r8,r9
80006b56:	e0 88 00 04 	brls	80006b5e <xTaskGenericCreate+0x136>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
80006b5a:	4a 99       	lddpc	r9,80006bfc <xTaskGenericCreate+0x1d4>
80006b5c:	93 08       	st.w	r9[0x0],r8
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
80006b5e:	4a 98       	lddpc	r8,80006c00 <xTaskGenericCreate+0x1d8>
80006b60:	70 09       	ld.w	r9,r8[0x0]
80006b62:	2f f9       	sub	r9,-1
80006b64:	91 09       	st.w	r8[0x0],r9

			prvAddTaskToReadyQueue( pxNewTCB );
80006b66:	6a b8       	ld.w	r8,r5[0x2c]
80006b68:	4a 79       	lddpc	r9,80006c04 <xTaskGenericCreate+0x1dc>
80006b6a:	72 09       	ld.w	r9,r9[0x0]
80006b6c:	12 38       	cp.w	r8,r9
80006b6e:	e0 88 00 04 	brls	80006b76 <xTaskGenericCreate+0x14e>
80006b72:	4a 59       	lddpc	r9,80006c04 <xTaskGenericCreate+0x1dc>
80006b74:	93 08       	st.w	r9[0x0],r8
80006b76:	6a bc       	ld.w	r12,r5[0x2c]
80006b78:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006b7c:	08 9b       	mov	r11,r4
80006b7e:	49 68       	lddpc	r8,80006bd4 <xTaskGenericCreate+0x1ac>
80006b80:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80006b84:	f0 1f 00 21 	mcall	80006c08 <xTaskGenericCreate+0x1e0>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
80006b88:	f0 1f 00 21 	mcall	80006c0c <xTaskGenericCreate+0x1e4>
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
80006b8c:	49 b8       	lddpc	r8,80006bf8 <xTaskGenericCreate+0x1d0>
80006b8e:	70 08       	ld.w	r8,r8[0x0]
80006b90:	58 08       	cp.w	r8,0
80006b92:	c0 a0       	breq	80006ba6 <xTaskGenericCreate+0x17e>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
80006b94:	48 f8       	lddpc	r8,80006bd0 <xTaskGenericCreate+0x1a8>
80006b96:	70 08       	ld.w	r8,r8[0x0]
80006b98:	70 b8       	ld.w	r8,r8[0x2c]
80006b9a:	10 33       	cp.w	r3,r8
80006b9c:	e0 88 00 05 	brls	80006ba6 <xTaskGenericCreate+0x17e>
			{
				portYIELD_WITHIN_API();
80006ba0:	d7 33       	scall
80006ba2:	30 1c       	mov	r12,1
80006ba4:	c0 28       	rjmp	80006ba8 <xTaskGenericCreate+0x180>
80006ba6:	30 1c       	mov	r12,1
			}
		}
	}

	return xReturn;
}
80006ba8:	2f fd       	sub	sp,-4
80006baa:	d8 32       	popm	r0-r7,pc
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80006bac:	99 c6       	st.w	r12[0x30],r6
80006bae:	c5 fb       	rjmp	80006a6c <xTaskGenericCreate+0x44>
80006bb0:	80 00       	ld.sh	r0,r0[0x0]
80006bb2:	5e 60       	retmi	r0
80006bb4:	80 00       	ld.sh	r0,r0[0x0]
80006bb6:	5e 38       	retlo	r8
80006bb8:	80 00       	ld.sh	r0,r0[0x0]
80006bba:	77 b0       	ld.w	r0,r11[0x6c]
80006bbc:	80 00       	ld.sh	r0,r0[0x0]
80006bbe:	7a dc       	ld.w	r12,sp[0x34]
80006bc0:	80 00       	ld.sh	r0,r0[0x0]
80006bc2:	5a e4       	cp.w	r4,-18
80006bc4:	80 00       	ld.sh	r0,r0[0x0]
80006bc6:	5b 60       	cp.w	r0,-10
80006bc8:	80 00       	ld.sh	r0,r0[0x0]
80006bca:	5b f4       	cp.w	r4,-1
80006bcc:	00 00       	add	r0,r0
80006bce:	0d 38       	ld.ub	r8,r6++
80006bd0:	00 00       	add	r0,r0
80006bd2:	0c ec       	st.h	--r6,r12
80006bd4:	00 00       	add	r0,r0
80006bd6:	0c 38       	cp.w	r8,r6
80006bd8:	80 00       	ld.sh	r0,r0[0x0]
80006bda:	5a d0       	cp.w	r0,-19
80006bdc:	00 00       	add	r0,r0
80006bde:	0d 04       	ld.w	r4,r6++
80006be0:	00 00       	add	r0,r0
80006be2:	0d 20       	ld.uh	r0,r6++
80006be4:	00 00       	add	r0,r0
80006be6:	0c f0       	st.b	--r6,r0
80006be8:	00 00       	add	r0,r0
80006bea:	0c d8       	st.w	--r6,r8
80006bec:	00 00       	add	r0,r0
80006bee:	0d 40       	ld.w	r0,--r6
80006bf0:	00 00       	add	r0,r0
80006bf2:	0c 24       	rsub	r4,r6
80006bf4:	00 00       	add	r0,r0
80006bf6:	0c 34       	cp.w	r4,r6
80006bf8:	00 00       	add	r0,r0
80006bfa:	0c 28       	rsub	r8,r6
80006bfc:	00 00       	add	r0,r0
80006bfe:	0c 20       	rsub	r0,r6
80006c00:	00 00       	add	r0,r0
80006c02:	0d 34       	ld.ub	r4,r6++
80006c04:	00 00       	add	r0,r0
80006c06:	0d 54       	ld.sh	r4,--r6
80006c08:	80 00       	ld.sh	r0,r0[0x0]
80006c0a:	5a ea       	cp.w	r10,-18
80006c0c:	80 00       	ld.sh	r0,r0[0x0]
80006c0e:	5d 00       	ror	r0

80006c10 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
80006c10:	d4 01       	pushm	lr
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
80006c12:	30 09       	mov	r9,0
80006c14:	1a d9       	st.w	--sp,r9
80006c16:	1a d9       	st.w	--sp,r9
80006c18:	1a d9       	st.w	--sp,r9
80006c1a:	12 98       	mov	r8,r9
80006c1c:	e0 6a 01 00 	mov	r10,256
80006c20:	48 9b       	lddpc	r11,80006c44 <vTaskStartScheduler+0x34>
80006c22:	48 ac       	lddpc	r12,80006c48 <vTaskStartScheduler+0x38>
80006c24:	f0 1f 00 0a 	mcall	80006c4c <vTaskStartScheduler+0x3c>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
80006c28:	2f dd       	sub	sp,-12
80006c2a:	58 1c       	cp.w	r12,1
80006c2c:	c0 a1       	brne	80006c40 <vTaskStartScheduler+0x30>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
80006c2e:	d3 03       	ssrf	0x10

		xSchedulerRunning = pdTRUE;
80006c30:	30 19       	mov	r9,1
80006c32:	48 88       	lddpc	r8,80006c50 <vTaskStartScheduler+0x40>
80006c34:	91 09       	st.w	r8[0x0],r9
		xTickCount = ( portTickType ) 0;
80006c36:	30 09       	mov	r9,0
80006c38:	48 78       	lddpc	r8,80006c54 <vTaskStartScheduler+0x44>
80006c3a:	91 09       	st.w	r8[0x0],r9
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
80006c3c:	f0 1f 00 07 	mcall	80006c58 <vTaskStartScheduler+0x48>
80006c40:	d8 02       	popm	pc
80006c42:	00 00       	add	r0,r0
80006c44:	80 00       	ld.sh	r0,r0[0x0]
80006c46:	d8 1c       	*unknown*
80006c48:	80 00       	ld.sh	r0,r0[0x0]
80006c4a:	69 a0       	ld.w	r0,r4[0x68]
80006c4c:	80 00       	ld.sh	r0,r0[0x0]
80006c4e:	6a 28       	ld.w	r8,r5[0x8]
80006c50:	00 00       	add	r0,r0
80006c52:	0c 28       	rsub	r8,r6
80006c54:	00 00       	add	r0,r0
80006c56:	0d 18       	ld.sh	r8,r6++
80006c58:	80 00       	ld.sh	r0,r0[0x0]
80006c5a:	5c 04       	acr	r4

80006c5c <PrintChar>:
	
static void task_log(void * pvParameters);

char *  PrintChar(char c, char * str)
{
	*str++ = c;
80006c5c:	16 cc       	st.b	r11++,r12
	return str;
}
80006c5e:	5e fb       	retal	r11

80006c60 <PrintHex>:
	
	return str;
}

char * PrintHex(int i,char len, char * str)
{
80006c60:	eb cd 40 c0 	pushm	r6-r7,lr
80006c64:	20 3d       	sub	sp,12
80006c66:	18 98       	mov	r8,r12
	char * p = str;
	char s[12];
	memset(s, 0 , 12);
80006c68:	30 06       	mov	r6,0
80006c6a:	30 07       	mov	r7,0
80006c6c:	fa e7 00 00 	st.d	sp[0],r6
80006c70:	30 0c       	mov	r12,0
80006c72:	50 2c       	stdsp	sp[0x8],r12
	int cnt=0;
	
	if(i)
80006c74:	58 08       	cp.w	r8,0
80006c76:	c1 30       	breq	80006c9c <PrintHex+0x3c>
80006c78:	18 99       	mov	r9,r12
	while(i)
	{
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
80006c7a:	1a 9c       	mov	r12,sp
80006c7c:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80006c80:	58 9e       	cp.w	lr,9
80006c82:	e0 8a 00 04 	brle	80006c8a <PrintHex+0x2a>
80006c86:	2c 9e       	sub	lr,-55
80006c88:	c0 48       	rjmp	80006c90 <PrintHex+0x30>
80006c8a:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80006c8e:	2d 0e       	sub	lr,-48
80006c90:	f8 09 0b 0e 	st.b	r12[r9],lr
80006c94:	2f f9       	sub	r9,-1
		i = (i >> 4 ) & 0x0FFFFFFF;
80006c96:	a5 88       	lsr	r8,0x4
	char s[12];
	memset(s, 0 , 12);
	int cnt=0;
	
	if(i)
	while(i)
80006c98:	cf 21       	brne	80006c7c <PrintHex+0x1c>
80006c9a:	c0 48       	rjmp	80006ca2 <PrintHex+0x42>
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
		i = (i >> 4 ) & 0x0FFFFFFF;
		//i >>= 4
	}
	else
	s[cnt++] = '0';
80006c9c:	33 08       	mov	r8,48
80006c9e:	ba 88       	st.b	sp[0x0],r8
80006ca0:	30 19       	mov	r9,1
	
	if(len - cnt > 0 )
80006ca2:	f6 09 01 08 	sub	r8,r11,r9
80006ca6:	58 08       	cp.w	r8,0
80006ca8:	e0 8a 00 13 	brle	80006cce <PrintHex+0x6e>
	{
		char num = len - cnt;
80006cac:	12 1b       	sub	r11,r9
80006cae:	f9 db c0 08 	bfextu	r12,r11,0x0,0x8
		for(int i = 0; i < num; i++)
80006cb2:	18 9e       	mov	lr,r12
80006cb4:	58 0c       	cp.w	r12,0
80006cb6:	e0 8a 00 0c 	brle	80006cce <PrintHex+0x6e>
80006cba:	1a 9b       	mov	r11,sp
80006cbc:	12 0b       	add	r11,r9
80006cbe:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80006cc0:	33 07       	mov	r7,48
80006cc2:	16 c7       	st.b	r11++,r7
	s[cnt++] = '0';
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80006cc4:	2f f8       	sub	r8,-1
80006cc6:	1c 38       	cp.w	r8,lr
80006cc8:	cf d5       	brlt	80006cc2 <PrintHex+0x62>
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
80006cca:	f8 09 00 09 	add	r9,r12,r9
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80006cce:	f2 c8 ff ff 	sub	r8,r9,-1
	s[cnt++] = '0';
	
	while(cnt>0)
80006cd2:	f0 cb ff ff 	sub	r11,r8,-1
80006cd6:	58 0b       	cp.w	r11,0
80006cd8:	e0 8a 00 19 	brle	80006d0a <PrintHex+0xaa>
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80006cdc:	fa cb ff f4 	sub	r11,sp,-12
80006ce0:	f6 09 00 09 	add	r9,r11,r9
80006ce4:	37 8b       	mov	r11,120
80006ce6:	f3 6b ff f4 	st.b	r9[-12],r11
	s[cnt++] = '0';
80006cea:	fa c9 ff f4 	sub	r9,sp,-12
80006cee:	10 09       	add	r9,r8
80006cf0:	33 0b       	mov	r11,48
80006cf2:	f3 6b ff f4 	st.b	r9[-12],r11
80006cf6:	fa 08 00 08 	add	r8,sp,r8
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
80006cfa:	fa ce 00 01 	sub	lr,sp,1
80006cfe:	14 99       	mov	r9,r10
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
	*p++ = s[--cnt];
80006d00:	11 8b       	ld.ub	r11,r8[0x0]
80006d02:	12 cb       	st.b	r9++,r11
80006d04:	20 18       	sub	r8,1
	}
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
80006d06:	1c 38       	cp.w	r8,lr
80006d08:	cf c1       	brne	80006d00 <PrintHex+0xa0>
	*p++ = s[--cnt];
		
	return str;
}
80006d0a:	14 9c       	mov	r12,r10
80006d0c:	2f dd       	sub	sp,-12
80006d0e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

80006d12 <PrintDec>:
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
{
80006d12:	d4 21       	pushm	r4-r7,lr
80006d14:	20 3d       	sub	sp,12
80006d16:	18 98       	mov	r8,r12
	char * p = str;
	
	int sign = i>=0 ? 0 : 1;
	char s[10];
	memset(s, 0 , 10);
80006d18:	30 06       	mov	r6,0
80006d1a:	30 07       	mov	r7,0
80006d1c:	fa e7 00 00 	st.d	sp[0],r6
80006d20:	30 0c       	mov	r12,0
80006d22:	ba 4c       	st.h	sp[0x8],r12
	int cnt=0;
	if(sign)
80006d24:	58 08       	cp.w	r8,0
80006d26:	c0 35       	brlt	80006d2c <PrintDec+0x1a>
80006d28:	14 97       	mov	r7,r10
80006d2a:	c0 58       	rjmp	80006d34 <PrintDec+0x22>
	{
		*p++ = '-';
80006d2c:	14 97       	mov	r7,r10
80006d2e:	32 d9       	mov	r9,45
80006d30:	0e c9       	st.b	r7++,r9
		i = -i;
80006d32:	5c 38       	neg	r8
	}
	
	if(i == 0 )s[cnt++] = '0';
80006d34:	58 08       	cp.w	r8,0
80006d36:	c0 51       	brne	80006d40 <PrintDec+0x2e>
80006d38:	33 08       	mov	r8,48
80006d3a:	ba 88       	st.b	sp[0x0],r8
80006d3c:	30 1e       	mov	lr,1
80006d3e:	c2 f8       	rjmp	80006d9c <PrintDec+0x8a>
	
	int ten = i%10;
80006d40:	e0 65 66 67 	mov	r5,26215
80006d44:	ea 15 66 66 	orh	r5,0x6666
80006d48:	f0 05 04 44 	muls.d	r4,r8,r5
80006d4c:	ea 0c 14 02 	asr	r12,r5,0x2
80006d50:	f0 09 14 1f 	asr	r9,r8,0x1f
80006d54:	f8 09 01 09 	sub	r9,r12,r9
80006d58:	f2 09 00 29 	add	r9,r9,r9<<0x2
80006d5c:	f0 09 01 19 	sub	r9,r8,r9<<0x1
80006d60:	30 0e       	mov	lr,0
	while(i)
	{
		s[cnt] = ten+'0';
80006d62:	1a 9c       	mov	r12,sp
		cnt++;
		i /= 10;
80006d64:	e0 66 66 67 	mov	r6,26215
80006d68:	ea 16 66 66 	orh	r6,0x6666
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
	{
		s[cnt] = ten+'0';
80006d6c:	2d 09       	sub	r9,-48
80006d6e:	f8 0e 0b 09 	st.b	r12[lr],r9
		cnt++;
80006d72:	2f fe       	sub	lr,-1
		i /= 10;
80006d74:	f0 06 04 44 	muls.d	r4,r8,r6
80006d78:	ea 09 14 02 	asr	r9,r5,0x2
80006d7c:	bf 58       	asr	r8,0x1f
80006d7e:	f2 08 01 08 	sub	r8,r9,r8
		ten = i%10;
80006d82:	f0 06 04 44 	muls.d	r4,r8,r6
80006d86:	ea 09 14 02 	asr	r9,r5,0x2
80006d8a:	f0 05 14 1f 	asr	r5,r8,0x1f
80006d8e:	0a 19       	sub	r9,r5
80006d90:	f2 09 00 29 	add	r9,r9,r9<<0x2
80006d94:	f0 09 01 19 	sub	r9,r8,r9<<0x1
	}
	
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
80006d98:	58 08       	cp.w	r8,0
80006d9a:	ce 91       	brne	80006d6c <PrintDec+0x5a>
		cnt++;
		i /= 10;
		ten = i%10;
	}
	
	if(len - cnt > 0 )
80006d9c:	f6 0e 01 08 	sub	r8,r11,lr
80006da0:	58 08       	cp.w	r8,0
80006da2:	e0 89 00 06 	brgt	80006dae <PrintDec+0x9c>
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80006da6:	58 0e       	cp.w	lr,0
80006da8:	e0 89 00 14 	brgt	80006dd0 <PrintDec+0xbe>
80006dac:	c1 d8       	rjmp	80006de6 <PrintDec+0xd4>
		ten = i%10;
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
80006dae:	1c 1b       	sub	r11,lr
80006db0:	5c 5b       	castu.b	r11
		for(int i = 0; i < num; i++)
80006db2:	16 9c       	mov	r12,r11
80006db4:	58 0b       	cp.w	r11,0
80006db6:	fe 9a ff f8 	brle	80006da6 <PrintDec+0x94>
80006dba:	1a 99       	mov	r9,sp
80006dbc:	1c 09       	add	r9,lr
80006dbe:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80006dc0:	33 06       	mov	r6,48
80006dc2:	12 c6       	st.b	r9++,r6
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80006dc4:	2f f8       	sub	r8,-1
80006dc6:	18 38       	cp.w	r8,r12
80006dc8:	cf d5       	brlt	80006dc2 <PrintDec+0xb0>
{
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
80006dca:	f6 0e 00 0e 	add	lr,r11,lr
80006dce:	ce cb       	rjmp	80006da6 <PrintDec+0x94>
80006dd0:	fa c8 ff f4 	sub	r8,sp,-12
80006dd4:	1c 08       	add	r8,lr
80006dd6:	20 d8       	sub	r8,13
80006dd8:	fa cb 00 01 	sub	r11,sp,1
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
	*p++ = s[--cnt];
80006ddc:	11 89       	ld.ub	r9,r8[0x0]
80006dde:	0e c9       	st.b	r7++,r9
80006de0:	20 18       	sub	r8,1
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80006de2:	16 38       	cp.w	r8,r11
80006de4:	cf c1       	brne	80006ddc <PrintDec+0xca>
	*p++ = s[--cnt];
	
	return str;
}
80006de6:	14 9c       	mov	r12,r10
80006de8:	2f dd       	sub	sp,-12
80006dea:	d8 22       	popm	r4-r7,pc

80006dec <log>:
	,  NULL );
	
}

int log(char * content, ...)
{
80006dec:	d4 31       	pushm	r0-r7,lr
80006dee:	fa cd 02 08 	sub	sp,sp,520
80006df2:	18 97       	mov	r7,r12
	
	
	char logTmp[MAX_LOG_LINE_SIZE];
	memset(logTmp, '\0', MAX_LOG_LINE_SIZE);	
80006df4:	e0 6a 01 00 	mov	r10,256
80006df8:	30 0b       	mov	r11,0
80006dfa:	fa cc fe f8 	sub	r12,sp,-264
80006dfe:	f0 1f 00 4e 	mcall	80006f34 <log+0x148>
	,  tskLOG_PRIORITY
	,  NULL );
	
}

int log(char * content, ...)
80006e02:	fa c4 fd d4 	sub	r4,sp,-556
80006e06:	30 0a       	mov	r10,0
80006e08:	50 0a       	stdsp	sp[0x0],r10
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80006e0a:	fa c3 ff fc 	sub	r3,sp,-4
80006e0e:	e0 61 01 00 	mov	r1,256
80006e12:	14 90       	mov	r0,r10
			
					if(*str == '%')
80006e14:	32 52       	mov	r2,37
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
80006e16:	fa c6 fe f8 	sub	r6,sp,-264
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80006e1a:	02 9a       	mov	r10,r1
80006e1c:	00 9b       	mov	r11,r0
80006e1e:	06 9c       	mov	r12,r3
80006e20:	f0 1f 00 45 	mcall	80006f34 <log+0x148>
			
					if(*str == '%')
80006e24:	0f 88       	ld.ub	r8,r7[0x0]
80006e26:	e4 08 18 00 	cp.b	r8,r2
80006e2a:	c5 71       	brne	80006ed8 <log+0xec>
					{
						static char lench = 0;
						lench =*(str + 1);
80006e2c:	ee c8 ff ff 	sub	r8,r7,-1
80006e30:	11 89       	ld.ub	r9,r8[0x0]
80006e32:	4c 2a       	lddpc	r10,80006f38 <log+0x14c>
80006e34:	b4 89       	st.b	r10[0x0],r9
						if((lench >= '0') &&  (lench <= '9'))
80006e36:	23 09       	sub	r9,48
80006e38:	30 9a       	mov	r10,9
80006e3a:	f4 09 18 00 	cp.b	r9,r10
80006e3e:	ee 08 17 b0 	movhi	r8,r7
						{
							len = *(++str) - '0';
80006e42:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
80006e46:	f7 b9 08 30 	subls	r9,48
80006e4a:	fb f9 8a 00 	st.wls	sp[0x0],r9
						}
						
						str++;
80006e4e:	f0 c7 ff ff 	sub	r7,r8,-1
						
						switch(*(str))
80006e52:	0f 88       	ld.ub	r8,r7[0x0]
80006e54:	22 58       	sub	r8,37
80006e56:	e0 48 00 53 	cp.w	r8,83
80006e5a:	e0 8b 00 31 	brhi	80006ebc <log+0xd0>
80006e5e:	4b 89       	lddpc	r9,80006f3c <log+0x150>
80006e60:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
						{
							case('i'):
							case('I'):
							case('d'):
							case('D'):
							x = va_arg(arg_ptr,int);
80006e64:	e8 c5 ff fc 	sub	r5,r4,-4
							strTmp = PrintDec(x, len, strTmp);
80006e68:	06 9a       	mov	r10,r3
80006e6a:	40 0b       	lddsp	r11,sp[0x0]
80006e6c:	5c 5b       	castu.b	r11
80006e6e:	68 0c       	ld.w	r12,r4[0x0]
80006e70:	f0 1f 00 34 	mcall	80006f40 <log+0x154>
							break;
80006e74:	c2 98       	rjmp	80006ec6 <log+0xda>
							
							case('f')://浮点数输出
							case('F'):
							//f = va_arg(arg_ptr,int);
							//strTmp = PrintDec(x, len, strTmp);
							log("I need float.");
80006e76:	4b 4c       	lddpc	r12,80006f44 <log+0x158>
80006e78:	f0 1f 00 34 	mcall	80006f48 <log+0x15c>
80006e7c:	08 95       	mov	r5,r4
80006e7e:	06 9c       	mov	r12,r3
							break;
80006e80:	c2 38       	rjmp	80006ec6 <log+0xda>
							
							
							case('x'):
							case('X'):
							x = va_arg(arg_ptr,int);
80006e82:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintHex(x,len, strTmp);
80006e86:	06 9a       	mov	r10,r3
80006e88:	40 0b       	lddsp	r11,sp[0x0]
80006e8a:	5c 5b       	castu.b	r11
80006e8c:	68 0c       	ld.w	r12,r4[0x0]
80006e8e:	f0 1f 00 30 	mcall	80006f4c <log+0x160>
80006e92:	06 9c       	mov	r12,r3
							break;
80006e94:	c1 98       	rjmp	80006ec6 <log+0xda>
							
							case('c'):
							case('C'):
							y = va_arg(arg_ptr,int);
80006e96:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintChar(y, strTmp);
80006e9a:	06 9b       	mov	r11,r3
80006e9c:	09 bc       	ld.ub	r12,r4[0x3]
80006e9e:	f0 1f 00 2d 	mcall	80006f50 <log+0x164>
80006ea2:	06 9c       	mov	r12,r3
							break;
80006ea4:	c1 18       	rjmp	80006ec6 <log+0xda>
							
							case('s'):
							case('S'):
							strTmp = va_arg(arg_ptr,char*);
80006ea6:	e8 c5 ff fc 	sub	r5,r4,-4
80006eaa:	68 0c       	ld.w	r12,r4[0x0]
							//PrintStr(s);
							break;
80006eac:	c0 d8       	rjmp	80006ec6 <log+0xda>
							
							case('%'):
							PrintChar('%', strTmp);
80006eae:	06 9b       	mov	r11,r3
80006eb0:	32 5c       	mov	r12,37
80006eb2:	f0 1f 00 28 	mcall	80006f50 <log+0x164>
80006eb6:	08 95       	mov	r5,r4
80006eb8:	06 9c       	mov	r12,r3
							//PrintChar('%');
							break;
80006eba:	c0 68       	rjmp	80006ec6 <log+0xda>
							
							default:
							log("I need relax.");
80006ebc:	4a 6c       	lddpc	r12,80006f54 <log+0x168>
80006ebe:	f0 1f 00 23 	mcall	80006f48 <log+0x15c>
80006ec2:	08 95       	mov	r5,r4
80006ec4:	06 9c       	mov	r12,r3
						}
						str++;
80006ec6:	2f f7       	sub	r7,-1
						
						length = sprintf(logTmp,"%s%s",logTmp,strTmp );
80006ec8:	1a dc       	st.w	--sp,r12
80006eca:	1a d6       	st.w	--sp,r6
80006ecc:	4a 3b       	lddpc	r11,80006f58 <log+0x16c>
80006ece:	0c 9c       	mov	r12,r6
80006ed0:	f0 1f 00 23 	mcall	80006f5c <log+0x170>
80006ed4:	2f ed       	sub	sp,-8
80006ed6:	c0 a8       	rjmp	80006eea <log+0xfe>
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
80006ed8:	2f f7       	sub	r7,-1
80006eda:	1a d8       	st.w	--sp,r8
80006edc:	1a d6       	st.w	--sp,r6
80006ede:	4a 1b       	lddpc	r11,80006f60 <log+0x174>
80006ee0:	0c 9c       	mov	r12,r6
80006ee2:	f0 1f 00 1f 	mcall	80006f5c <log+0x170>
80006ee6:	08 95       	mov	r5,r4
80006ee8:	2f ed       	sub	sp,-8
			
			
			
	}while(*str != '\0');
80006eea:	0f 89       	ld.ub	r9,r7[0x0]
80006eec:	30 08       	mov	r8,0
80006eee:	f0 09 18 00 	cp.b	r9,r8
80006ef2:	c0 30       	breq	80006ef8 <log+0x10c>
80006ef4:	0a 94       	mov	r4,r5
80006ef6:	c9 2b       	rjmp	80006e1a <log+0x2e>
		
		
				
	va_end(arg_ptr);
	//while(1)		
	length = sprintf(logTmp,"%s\r\n",logTmp);
80006ef8:	fa c7 fe f8 	sub	r7,sp,-264
80006efc:	1a d7       	st.w	--sp,r7
80006efe:	49 ab       	lddpc	r11,80006f64 <log+0x178>
80006f00:	0e 9c       	mov	r12,r7
80006f02:	f0 1f 00 17 	mcall	80006f5c <log+0x170>
	
	char * p = pvPortMalloc(length+1);
80006f06:	5c 5c       	castu.b	r12
80006f08:	f8 c6 ff ff 	sub	r6,r12,-1
80006f0c:	0c 9c       	mov	r12,r6
80006f0e:	f0 1f 00 17 	mcall	80006f68 <log+0x17c>
80006f12:	54 2c       	stdsp	sp[0x108],r12
	memcpy(p, logTmp, length+1);
80006f14:	0c 9a       	mov	r10,r6
80006f16:	0e 9b       	mov	r11,r7
80006f18:	f0 1f 00 15 	mcall	80006f6c <log+0x180>
	//
	//usart_write_line(EXAMPLE_USART, logTmp)
	
	xQueueSend( logQueue, &p, 5);
80006f1c:	30 09       	mov	r9,0
80006f1e:	30 5a       	mov	r10,5
80006f20:	fa cb fe f8 	sub	r11,sp,-264
80006f24:	49 38       	lddpc	r8,80006f70 <log+0x184>
80006f26:	70 0c       	ld.w	r12,r8[0x0]
80006f28:	f0 1f 00 13 	mcall	80006f74 <log+0x188>
80006f2c:	2f fd       	sub	sp,-4
	
	
}
80006f2e:	fe 3d fd f8 	sub	sp,-520
80006f32:	d8 32       	popm	r0-r7,pc
80006f34:	80 00       	ld.sh	r0,r0[0x0]
80006f36:	77 b0       	ld.w	r0,r11[0x6c]
80006f38:	00 00       	add	r0,r0
80006f3a:	0d 58       	ld.sh	r8,--r6
80006f3c:	80 00       	ld.sh	r0,r0[0x0]
80006f3e:	d8 24       	*unknown*
80006f40:	80 00       	ld.sh	r0,r0[0x0]
80006f42:	6d 12       	ld.w	r2,r6[0x44]
80006f44:	80 00       	ld.sh	r0,r0[0x0]
80006f46:	da d0       	acall	0xad
80006f48:	80 00       	ld.sh	r0,r0[0x0]
80006f4a:	6d ec       	ld.w	r12,r6[0x78]
80006f4c:	80 00       	ld.sh	r0,r0[0x0]
80006f4e:	6c 60       	ld.w	r0,r6[0x18]
80006f50:	80 00       	ld.sh	r0,r0[0x0]
80006f52:	6c 5c       	ld.w	r12,r6[0x14]
80006f54:	80 00       	ld.sh	r0,r0[0x0]
80006f56:	da e0       	acall	0xae
80006f58:	80 00       	ld.sh	r0,r0[0x0]
80006f5a:	da f0       	acall	0xaf
80006f5c:	80 00       	ld.sh	r0,r0[0x0]
80006f5e:	7a a0       	ld.w	r0,sp[0x28]
80006f60:	80 00       	ld.sh	r0,r0[0x0]
80006f62:	da f8       	*unknown*
80006f64:	80 00       	ld.sh	r0,r0[0x0]
80006f66:	db 00       	acall	0xb0
80006f68:	80 00       	ld.sh	r0,r0[0x0]
80006f6a:	5e 60       	retmi	r0
80006f6c:	80 00       	ld.sh	r0,r0[0x0]
80006f6e:	76 68       	ld.w	r8,r11[0x18]
80006f70:	00 00       	add	r0,r0
80006f72:	bf ec       	*unknown*
80006f74:	80 00       	ld.sh	r0,r0[0x0]
80006f76:	61 b4       	ld.w	r4,r0[0x6c]

80006f78 <logFromISR>:
	
	
int logFromISR(char * content, ...)
	{
80006f78:	d4 31       	pushm	r0-r7,lr
80006f7a:	fa cd 02 0c 	sub	sp,sp,524
80006f7e:	18 97       	mov	r7,r12
		
		
		char logTmp[MAX_LOG_LINE_SIZE];
		memset(logTmp, '\0', MAX_LOG_LINE_SIZE);
80006f80:	e0 6a 01 00 	mov	r10,256
80006f84:	30 0b       	mov	r11,0
80006f86:	fa cc fe f4 	sub	r12,sp,-268
80006f8a:	f0 1f 00 4c 	mcall	800070b8 <logFromISR+0x140>
	
	
}
	
	
int logFromISR(char * content, ...)
80006f8e:	fa c4 fd d0 	sub	r4,sp,-560
80006f92:	30 0a       	mov	r10,0
80006f94:	50 0a       	stdsp	sp[0x0],r10
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80006f96:	fa c3 ff fc 	sub	r3,sp,-4
80006f9a:	e0 61 01 00 	mov	r1,256
80006f9e:	14 90       	mov	r0,r10
			
			if(*str == '%')
80006fa0:	32 52       	mov	r2,37
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
80006fa2:	fa c6 fe f4 	sub	r6,sp,-268
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80006fa6:	02 9a       	mov	r10,r1
80006fa8:	00 9b       	mov	r11,r0
80006faa:	06 9c       	mov	r12,r3
80006fac:	f0 1f 00 43 	mcall	800070b8 <logFromISR+0x140>
			
			if(*str == '%')
80006fb0:	0f 88       	ld.ub	r8,r7[0x0]
80006fb2:	e4 08 18 00 	cp.b	r8,r2
80006fb6:	c5 11       	brne	80007058 <logFromISR+0xe0>
			{
				static char lench = 0;
				lench =*(str + 1);
80006fb8:	ee c8 ff ff 	sub	r8,r7,-1
80006fbc:	11 89       	ld.ub	r9,r8[0x0]
80006fbe:	4c 0a       	lddpc	r10,800070bc <logFromISR+0x144>
80006fc0:	b4 89       	st.b	r10[0x0],r9
				if((lench >= '0') &&  (lench <= '9'))
80006fc2:	23 09       	sub	r9,48
80006fc4:	30 9a       	mov	r10,9
80006fc6:	f4 09 18 00 	cp.b	r9,r10
80006fca:	ee 08 17 b0 	movhi	r8,r7
				{
					len = *(++str) - '0';
80006fce:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
80006fd2:	f7 b9 08 30 	subls	r9,48
80006fd6:	fb f9 8a 00 	st.wls	sp[0x0],r9
				}
				
				str++;
80006fda:	f0 c7 ff ff 	sub	r7,r8,-1
				
				switch(*(str))
80006fde:	0f 88       	ld.ub	r8,r7[0x0]
80006fe0:	22 58       	sub	r8,37
80006fe2:	e0 48 00 53 	cp.w	r8,83
80006fe6:	e0 8b 00 2b 	brhi	8000703c <logFromISR+0xc4>
80006fea:	4b 69       	lddpc	r9,800070c0 <logFromISR+0x148>
80006fec:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
				{
					case('d'):
					case('D'):
					x = va_arg(arg_ptr,int);
80006ff0:	e8 c5 ff fc 	sub	r5,r4,-4
					strTmp = PrintDec(x, len, strTmp);
80006ff4:	06 9a       	mov	r10,r3
80006ff6:	40 0b       	lddsp	r11,sp[0x0]
80006ff8:	5c 5b       	castu.b	r11
80006ffa:	68 0c       	ld.w	r12,r4[0x0]
80006ffc:	f0 1f 00 32 	mcall	800070c4 <logFromISR+0x14c>
					break;
80007000:	c2 38       	rjmp	80007046 <logFromISR+0xce>
					case('x'):
					case('X'):
					x = va_arg(arg_ptr,int);
80007002:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintHex(x,len, strTmp);
80007006:	06 9a       	mov	r10,r3
80007008:	40 0b       	lddsp	r11,sp[0x0]
8000700a:	5c 5b       	castu.b	r11
8000700c:	68 0c       	ld.w	r12,r4[0x0]
8000700e:	f0 1f 00 2f 	mcall	800070c8 <logFromISR+0x150>
80007012:	06 9c       	mov	r12,r3
					break;
80007014:	c1 98       	rjmp	80007046 <logFromISR+0xce>
					case('c'):
					case('C'):
					y = va_arg(arg_ptr,int);
80007016:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintChar(y, strTmp);
8000701a:	06 9b       	mov	r11,r3
8000701c:	09 bc       	ld.ub	r12,r4[0x3]
8000701e:	f0 1f 00 2c 	mcall	800070cc <logFromISR+0x154>
80007022:	06 9c       	mov	r12,r3
					break;
80007024:	c1 18       	rjmp	80007046 <logFromISR+0xce>
					case('s'):
					case('S'):
					strTmp = va_arg(arg_ptr,char*);
80007026:	e8 c5 ff fc 	sub	r5,r4,-4
8000702a:	68 0c       	ld.w	r12,r4[0x0]
					//PrintStr(s);
					break;
8000702c:	c0 d8       	rjmp	80007046 <logFromISR+0xce>
					case('%'):
					PrintChar('%', strTmp);
8000702e:	06 9b       	mov	r11,r3
80007030:	32 5c       	mov	r12,37
80007032:	f0 1f 00 27 	mcall	800070cc <logFromISR+0x154>
80007036:	08 95       	mov	r5,r4
80007038:	06 9c       	mov	r12,r3
					//PrintChar('%');
					break;
8000703a:	c0 68       	rjmp	80007046 <logFromISR+0xce>
					default:
					log("I need relax.");
8000703c:	4a 5c       	lddpc	r12,800070d0 <logFromISR+0x158>
8000703e:	f0 1f 00 26 	mcall	800070d4 <logFromISR+0x15c>
80007042:	08 95       	mov	r5,r4
80007044:	06 9c       	mov	r12,r3
				}
				str++;
80007046:	2f f7       	sub	r7,-1
				
				length = sprintf(logTmp,"%s%s",logTmp,strTmp );
80007048:	1a dc       	st.w	--sp,r12
8000704a:	1a d6       	st.w	--sp,r6
8000704c:	4a 3b       	lddpc	r11,800070d8 <logFromISR+0x160>
8000704e:	0c 9c       	mov	r12,r6
80007050:	f0 1f 00 23 	mcall	800070dc <logFromISR+0x164>
80007054:	2f ed       	sub	sp,-8
80007056:	c0 a8       	rjmp	8000706a <logFromISR+0xf2>
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
80007058:	2f f7       	sub	r7,-1
8000705a:	1a d8       	st.w	--sp,r8
8000705c:	1a d6       	st.w	--sp,r6
8000705e:	4a 1b       	lddpc	r11,800070e0 <logFromISR+0x168>
80007060:	0c 9c       	mov	r12,r6
80007062:	f0 1f 00 1f 	mcall	800070dc <logFromISR+0x164>
80007066:	08 95       	mov	r5,r4
80007068:	2f ed       	sub	sp,-8
			
			
			
		}while(*str != '\0');
8000706a:	0f 89       	ld.ub	r9,r7[0x0]
8000706c:	30 08       	mov	r8,0
8000706e:	f0 09 18 00 	cp.b	r9,r8
80007072:	c0 30       	breq	80007078 <logFromISR+0x100>
80007074:	0a 94       	mov	r4,r5
80007076:	c9 8b       	rjmp	80006fa6 <logFromISR+0x2e>
		
		
		
		va_end(arg_ptr);
		//while(1)
		length = sprintf(logTmp,"%s\r\n",logTmp);
80007078:	fa c7 fe f4 	sub	r7,sp,-268
8000707c:	1a d7       	st.w	--sp,r7
8000707e:	49 ab       	lddpc	r11,800070e4 <logFromISR+0x16c>
80007080:	0e 9c       	mov	r12,r7
80007082:	f0 1f 00 17 	mcall	800070dc <logFromISR+0x164>
		
		char * p = pvPortMalloc(length+1);
80007086:	5c 5c       	castu.b	r12
80007088:	f8 c6 ff ff 	sub	r6,r12,-1
8000708c:	0c 9c       	mov	r12,r6
8000708e:	f0 1f 00 17 	mcall	800070e8 <logFromISR+0x170>
80007092:	54 3c       	stdsp	sp[0x10c],r12
		memcpy(p, logTmp, length+1);
80007094:	0c 9a       	mov	r10,r6
80007096:	0e 9b       	mov	r11,r7
80007098:	f0 1f 00 15 	mcall	800070ec <logFromISR+0x174>
		//
		portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
8000709c:	30 09       	mov	r9,0
8000709e:	54 29       	stdsp	sp[0x108],r9
		
		//usart_write_line(EXAMPLE_USART, p);
		//vPortFree(p);
		xQueueSendFromISR( logQueue, &p, &xHigherPriorityTaskWoken );
800070a0:	fa ca fe f8 	sub	r10,sp,-264
800070a4:	fa cb fe f4 	sub	r11,sp,-268
800070a8:	49 28       	lddpc	r8,800070f0 <logFromISR+0x178>
800070aa:	70 0c       	ld.w	r12,r8[0x0]
800070ac:	f0 1f 00 12 	mcall	800070f4 <logFromISR+0x17c>
800070b0:	2f fd       	sub	sp,-4
		
		//if (xHigherPriorityTaskWoken == pdTRUE)
		//{
			////taskYIELD();
		//}
	}
800070b2:	fe 3d fd f4 	sub	sp,-524
800070b6:	d8 32       	popm	r0-r7,pc
800070b8:	80 00       	ld.sh	r0,r0[0x0]
800070ba:	77 b0       	ld.w	r0,r11[0x6c]
800070bc:	00 00       	add	r0,r0
800070be:	0d 59       	ld.sh	r9,--r6
800070c0:	80 00       	ld.sh	r0,r0[0x0]
800070c2:	d9 74       	*unknown*
800070c4:	80 00       	ld.sh	r0,r0[0x0]
800070c6:	6d 12       	ld.w	r2,r6[0x44]
800070c8:	80 00       	ld.sh	r0,r0[0x0]
800070ca:	6c 60       	ld.w	r0,r6[0x18]
800070cc:	80 00       	ld.sh	r0,r0[0x0]
800070ce:	6c 5c       	ld.w	r12,r6[0x14]
800070d0:	80 00       	ld.sh	r0,r0[0x0]
800070d2:	da e0       	acall	0xae
800070d4:	80 00       	ld.sh	r0,r0[0x0]
800070d6:	6d ec       	ld.w	r12,r6[0x78]
800070d8:	80 00       	ld.sh	r0,r0[0x0]
800070da:	da f0       	acall	0xaf
800070dc:	80 00       	ld.sh	r0,r0[0x0]
800070de:	7a a0       	ld.w	r0,sp[0x28]
800070e0:	80 00       	ld.sh	r0,r0[0x0]
800070e2:	da f8       	*unknown*
800070e4:	80 00       	ld.sh	r0,r0[0x0]
800070e6:	db 00       	acall	0xb0
800070e8:	80 00       	ld.sh	r0,r0[0x0]
800070ea:	5e 60       	retmi	r0
800070ec:	80 00       	ld.sh	r0,r0[0x0]
800070ee:	76 68       	ld.w	r8,r11[0x18]
800070f0:	00 00       	add	r0,r0
800070f2:	bf ec       	*unknown*
800070f4:	80 00       	ld.sh	r0,r0[0x0]
800070f6:	61 64       	ld.w	r4,r0[0x58]

800070f8 <log_init>:
		
	return str;
}

void log_init(void)
{
800070f8:	d4 01       	pushm	lr
		.stopbits     = USART_1_STOPBIT,
		.channelmode  = USART_NORMAL_CHMODE
	};

	// Assign GPIO to USART.
	gpio_enable_module(USART_GPIO_MAP,
800070fa:	30 2b       	mov	r11,2
800070fc:	48 fc       	lddpc	r12,80007138 <log_init+0x40>
800070fe:	f0 1f 00 10 	mcall	8000713c <log_init+0x44>
	sizeof(USART_GPIO_MAP) / sizeof(USART_GPIO_MAP[0]));

	// Initialize USART in RS232 mode.
	usart_init_rs232(EXAMPLE_USART, &USART_OPTIONS, EXAMPLE_TARGET_PBACLK_FREQ_HZ);			
80007102:	e0 6a 36 00 	mov	r10,13824
80007106:	ea 1a 01 6e 	orh	r10,0x16e
8000710a:	48 eb       	lddpc	r11,80007140 <log_init+0x48>
8000710c:	fe 7c 18 00 	mov	r12,-59392
80007110:	f0 1f 00 0d 	mcall	80007144 <log_init+0x4c>
			
	logQueue  = xQueueCreate(50, sizeof(char *));
80007114:	30 4b       	mov	r11,4
80007116:	33 2c       	mov	r12,50
80007118:	f0 1f 00 0c 	mcall	80007148 <log_init+0x50>
8000711c:	48 c8       	lddpc	r8,8000714c <log_init+0x54>
8000711e:	91 0c       	st.w	r8[0x0],r12
	
	xTaskCreate(
80007120:	30 09       	mov	r9,0
80007122:	1a d9       	st.w	--sp,r9
80007124:	1a d9       	st.w	--sp,r9
80007126:	1a d9       	st.w	--sp,r9
80007128:	30 28       	mov	r8,2
8000712a:	36 4a       	mov	r10,100
8000712c:	48 9b       	lddpc	r11,80007150 <log_init+0x58>
8000712e:	48 ac       	lddpc	r12,80007154 <log_init+0x5c>
80007130:	f0 1f 00 0a 	mcall	80007158 <log_init+0x60>
80007134:	2f dd       	sub	sp,-12
	,  100//384
	,  NULL
	,  tskLOG_PRIORITY
	,  NULL );
	
}
80007136:	d8 02       	popm	pc
80007138:	80 00       	ld.sh	r0,r0[0x0]
8000713a:	db 0c       	*unknown*
8000713c:	80 00       	ld.sh	r0,r0[0x0]
8000713e:	53 40       	stdsp	sp[0xd0],r0
80007140:	80 00       	ld.sh	r0,r0[0x0]
80007142:	da c4       	*unknown*
80007144:	80 00       	ld.sh	r0,r0[0x0]
80007146:	59 c4       	cp.w	r4,28
80007148:	80 00       	ld.sh	r0,r0[0x0]
8000714a:	63 0c       	ld.w	r12,r1[0x40]
8000714c:	00 00       	add	r0,r0
8000714e:	bf ec       	*unknown*
80007150:	80 00       	ld.sh	r0,r0[0x0]
80007152:	db 08       	*unknown*
80007154:	80 00       	ld.sh	r0,r0[0x0]
80007156:	71 5c       	ld.w	r12,r8[0x54]
80007158:	80 00       	ld.sh	r0,r0[0x0]
8000715a:	6a 28       	ld.w	r8,r5[0x8]

8000715c <task_log>:
			////taskYIELD();
		//}
	}
//portTickType log_water_value =0;	
static void task_log(void * pvParameters)
{
8000715c:	eb cd 40 f8 	pushm	r3-r7,lr
80007160:	20 1d       	sub	sp,4
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		//log_water_value = uxTaskGetStackHighWaterMark(NULL);
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
80007162:	48 c7       	lddpc	r7,80007190 <task_log+0x34>
80007164:	30 05       	mov	r5,0
80007166:	3f f4       	mov	r4,-1
		{
			if( NULL != str)
			{
				usart_write_line(EXAMPLE_USART, str);
80007168:	fe 73 18 00 	mov	r3,-59392
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		//log_water_value = uxTaskGetStackHighWaterMark(NULL);
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
8000716c:	0a 99       	mov	r9,r5
8000716e:	08 9a       	mov	r10,r4
80007170:	1a 9b       	mov	r11,sp
80007172:	6e 0c       	ld.w	r12,r7[0x0]
80007174:	f0 1f 00 08 	mcall	80007194 <task_log+0x38>
80007178:	58 1c       	cp.w	r12,1
8000717a:	cf 91       	brne	8000716c <task_log+0x10>
		{
			if( NULL != str)
8000717c:	40 0b       	lddsp	r11,sp[0x0]
8000717e:	58 0b       	cp.w	r11,0
80007180:	cf 60       	breq	8000716c <task_log+0x10>
			{
				usart_write_line(EXAMPLE_USART, str);
80007182:	06 9c       	mov	r12,r3
80007184:	f0 1f 00 05 	mcall	80007198 <task_log+0x3c>
				vPortFree(str);
80007188:	40 0c       	lddsp	r12,sp[0x0]
8000718a:	f0 1f 00 05 	mcall	8000719c <task_log+0x40>
8000718e:	ce fb       	rjmp	8000716c <task_log+0x10>
80007190:	00 00       	add	r0,r0
80007192:	bf ec       	*unknown*
80007194:	80 00       	ld.sh	r0,r0[0x0]
80007196:	5f a8       	srle	r8
80007198:	80 00       	ld.sh	r0,r0[0x0]
8000719a:	59 74       	cp.w	r4,23
8000719c:	80 00       	ld.sh	r0,r0[0x0]
8000719e:	5e 38       	retlo	r8

800071a0 <main>:
#include "xgflash.h"
#include "app.h"


int main (void)
{
800071a0:	d4 01       	pushm	lr
	
	//Force SSC_TX_DATA_ENABLE Disabled as soon as possible.
	AVR32_GPIO.port[1].ovrs  =  0x00000001;  //Value will be high.
800071a2:	fe 78 10 00 	mov	r8,-61440
800071a6:	30 19       	mov	r9,1
800071a8:	f1 49 01 54 	st.w	r8[340],r9
	AVR32_GPIO.port[1].oders =  0x00000001;  //Output Driver will be Enabled.
800071ac:	f1 49 01 44 	st.w	r8[324],r9
	AVR32_GPIO.port[1].gpers =  0x00000001;  //Enable as GPIO.
800071b0:	f1 49 01 04 	st.w	r8[260],r9
		
	Disable_global_interrupt();
800071b4:	d3 03       	ssrf	0x10
	local_start_pll0();
800071b6:	f0 1f 00 0c 	mcall	800071e4 <main+0x44>
		
	INTC_init_interrupts();
800071ba:	f0 1f 00 0c 	mcall	800071e8 <main+0x48>
		
	log_init();
800071be:	f0 1f 00 0c 	mcall	800071ec <main+0x4c>
	log("----start debug----");
800071c2:	48 cc       	lddpc	r12,800071f0 <main+0x50>
800071c4:	f0 1f 00 0c 	mcall	800071f4 <main+0x54>
	
	xg_flashc_init();
800071c8:	f0 1f 00 0c 	mcall	800071f8 <main+0x58>
	
	rfid_init();
800071cc:	f0 1f 00 0c 	mcall	800071fc <main+0x5c>
		
	app_init();
800071d0:	f0 1f 00 0c 	mcall	80007200 <main+0x60>
		
	xcmp_init();
800071d4:	f0 1f 00 0c 	mcall	80007204 <main+0x64>

	local_start_timer();
800071d8:	f0 1f 00 0c 	mcall	80007208 <main+0x68>
		
	vTaskStartScheduler();
800071dc:	f0 1f 00 0c 	mcall	8000720c <main+0x6c>
	return 0;
	
}
800071e0:	d8 0a       	popm	pc,r12=0
800071e2:	00 00       	add	r0,r0
800071e4:	80 00       	ld.sh	r0,r0[0x0]
800071e6:	51 bc       	stdsp	sp[0x6c],r12
800071e8:	80 00       	ld.sh	r0,r0[0x0]
800071ea:	54 44       	stdsp	sp[0x110],r4
800071ec:	80 00       	ld.sh	r0,r0[0x0]
800071ee:	70 f8       	ld.w	r8,r8[0x3c]
800071f0:	80 00       	ld.sh	r0,r0[0x0]
800071f2:	db 1c       	*unknown*
800071f4:	80 00       	ld.sh	r0,r0[0x0]
800071f6:	6d ec       	ld.w	r12,r6[0x78]
800071f8:	80 00       	ld.sh	r0,r0[0x0]
800071fa:	52 50       	stdsp	sp[0x94],r0
800071fc:	80 00       	ld.sh	r0,r0[0x0]
800071fe:	51 1c       	stdsp	sp[0x44],r12
80007200:	80 00       	ld.sh	r0,r0[0x0]
80007202:	27 44       	sub	r4,116
80007204:	80 00       	ld.sh	r0,r0[0x0]
80007206:	3f a0       	mov	r0,-6
80007208:	80 00       	ld.sh	r0,r0[0x0]
8000720a:	51 90       	stdsp	sp[0x64],r0
8000720c:	80 00       	ld.sh	r0,r0[0x0]
8000720e:	6c 10       	ld.w	r0,r6[0x4]

80007210 <free>:
80007210:	d4 01       	pushm	lr
80007212:	e0 68 0a 3c 	mov	r8,2620
80007216:	18 9b       	mov	r11,r12
80007218:	70 0c       	ld.w	r12,r8[0x0]
8000721a:	e0 a0 1e 61 	rcall	8000aedc <_free_r>
8000721e:	d8 02       	popm	pc

80007220 <malloc>:
80007220:	d4 01       	pushm	lr
80007222:	e0 68 0a 3c 	mov	r8,2620
80007226:	18 9b       	mov	r11,r12
80007228:	70 0c       	ld.w	r12,r8[0x0]
8000722a:	c0 3c       	rcall	80007230 <_malloc_r>
8000722c:	d8 02       	popm	pc
8000722e:	d7 03       	nop

80007230 <_malloc_r>:
80007230:	d4 31       	pushm	r0-r7,lr
80007232:	f6 c8 ff f5 	sub	r8,r11,-11
80007236:	18 95       	mov	r5,r12
80007238:	10 97       	mov	r7,r8
8000723a:	e0 17 ff f8 	andl	r7,0xfff8
8000723e:	59 68       	cp.w	r8,22
80007240:	f9 b7 08 10 	movls	r7,16
80007244:	16 37       	cp.w	r7,r11
80007246:	5f 38       	srlo	r8
80007248:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
8000724c:	c0 50       	breq	80007256 <_malloc_r+0x26>
8000724e:	30 c8       	mov	r8,12
80007250:	99 38       	st.w	r12[0xc],r8
80007252:	e0 8f 01 fa 	bral	80007646 <_malloc_r+0x416>
80007256:	fe b0 f5 a7 	rcall	80005da4 <__malloc_lock>
8000725a:	e0 47 01 f7 	cp.w	r7,503
8000725e:	e0 8b 00 1d 	brhi	80007298 <_malloc_r+0x68>
80007262:	ee 03 16 03 	lsr	r3,r7,0x3
80007266:	e0 68 05 3c 	mov	r8,1340
8000726a:	f0 03 00 38 	add	r8,r8,r3<<0x3
8000726e:	70 36       	ld.w	r6,r8[0xc]
80007270:	10 36       	cp.w	r6,r8
80007272:	c0 61       	brne	8000727e <_malloc_r+0x4e>
80007274:	ec c8 ff f8 	sub	r8,r6,-8
80007278:	70 36       	ld.w	r6,r8[0xc]
8000727a:	10 36       	cp.w	r6,r8
8000727c:	c0 c0       	breq	80007294 <_malloc_r+0x64>
8000727e:	6c 18       	ld.w	r8,r6[0x4]
80007280:	e0 18 ff fc 	andl	r8,0xfffc
80007284:	6c 3a       	ld.w	r10,r6[0xc]
80007286:	ec 08 00 09 	add	r9,r6,r8
8000728a:	0a 9c       	mov	r12,r5
8000728c:	6c 28       	ld.w	r8,r6[0x8]
8000728e:	95 28       	st.w	r10[0x8],r8
80007290:	91 3a       	st.w	r8[0xc],r10
80007292:	c4 78       	rjmp	80007320 <_malloc_r+0xf0>
80007294:	2f e3       	sub	r3,-2
80007296:	c4 d8       	rjmp	80007330 <_malloc_r+0x100>
80007298:	ee 03 16 09 	lsr	r3,r7,0x9
8000729c:	c0 41       	brne	800072a4 <_malloc_r+0x74>
8000729e:	ee 03 16 03 	lsr	r3,r7,0x3
800072a2:	c2 68       	rjmp	800072ee <_malloc_r+0xbe>
800072a4:	58 43       	cp.w	r3,4
800072a6:	e0 8b 00 06 	brhi	800072b2 <_malloc_r+0x82>
800072aa:	ee 03 16 06 	lsr	r3,r7,0x6
800072ae:	2c 83       	sub	r3,-56
800072b0:	c1 f8       	rjmp	800072ee <_malloc_r+0xbe>
800072b2:	59 43       	cp.w	r3,20
800072b4:	e0 8b 00 04 	brhi	800072bc <_malloc_r+0x8c>
800072b8:	2a 53       	sub	r3,-91
800072ba:	c1 a8       	rjmp	800072ee <_malloc_r+0xbe>
800072bc:	e0 43 00 54 	cp.w	r3,84
800072c0:	e0 8b 00 06 	brhi	800072cc <_malloc_r+0x9c>
800072c4:	ee 03 16 0c 	lsr	r3,r7,0xc
800072c8:	29 23       	sub	r3,-110
800072ca:	c1 28       	rjmp	800072ee <_malloc_r+0xbe>
800072cc:	e0 43 01 54 	cp.w	r3,340
800072d0:	e0 8b 00 06 	brhi	800072dc <_malloc_r+0xac>
800072d4:	ee 03 16 0f 	lsr	r3,r7,0xf
800072d8:	28 93       	sub	r3,-119
800072da:	c0 a8       	rjmp	800072ee <_malloc_r+0xbe>
800072dc:	e0 43 05 54 	cp.w	r3,1364
800072e0:	e0 88 00 04 	brls	800072e8 <_malloc_r+0xb8>
800072e4:	37 e3       	mov	r3,126
800072e6:	c0 48       	rjmp	800072ee <_malloc_r+0xbe>
800072e8:	ee 03 16 12 	lsr	r3,r7,0x12
800072ec:	28 43       	sub	r3,-124
800072ee:	e0 6a 05 3c 	mov	r10,1340
800072f2:	f4 03 00 3a 	add	r10,r10,r3<<0x3
800072f6:	74 36       	ld.w	r6,r10[0xc]
800072f8:	c1 98       	rjmp	8000732a <_malloc_r+0xfa>
800072fa:	6c 19       	ld.w	r9,r6[0x4]
800072fc:	e0 19 ff fc 	andl	r9,0xfffc
80007300:	f2 07 01 0b 	sub	r11,r9,r7
80007304:	58 fb       	cp.w	r11,15
80007306:	e0 8a 00 04 	brle	8000730e <_malloc_r+0xde>
8000730a:	20 13       	sub	r3,1
8000730c:	c1 18       	rjmp	8000732e <_malloc_r+0xfe>
8000730e:	6c 38       	ld.w	r8,r6[0xc]
80007310:	58 0b       	cp.w	r11,0
80007312:	c0 b5       	brlt	80007328 <_malloc_r+0xf8>
80007314:	6c 2a       	ld.w	r10,r6[0x8]
80007316:	ec 09 00 09 	add	r9,r6,r9
8000731a:	0a 9c       	mov	r12,r5
8000731c:	91 2a       	st.w	r8[0x8],r10
8000731e:	95 38       	st.w	r10[0xc],r8
80007320:	72 18       	ld.w	r8,r9[0x4]
80007322:	a1 a8       	sbr	r8,0x0
80007324:	93 18       	st.w	r9[0x4],r8
80007326:	cb c8       	rjmp	8000749e <_malloc_r+0x26e>
80007328:	10 96       	mov	r6,r8
8000732a:	14 36       	cp.w	r6,r10
8000732c:	ce 71       	brne	800072fa <_malloc_r+0xca>
8000732e:	2f f3       	sub	r3,-1
80007330:	e0 6a 05 3c 	mov	r10,1340
80007334:	f4 cc ff f8 	sub	r12,r10,-8
80007338:	78 26       	ld.w	r6,r12[0x8]
8000733a:	18 36       	cp.w	r6,r12
8000733c:	c6 c0       	breq	80007414 <_malloc_r+0x1e4>
8000733e:	6c 19       	ld.w	r9,r6[0x4]
80007340:	e0 19 ff fc 	andl	r9,0xfffc
80007344:	f2 07 01 08 	sub	r8,r9,r7
80007348:	58 f8       	cp.w	r8,15
8000734a:	e0 89 00 8f 	brgt	80007468 <_malloc_r+0x238>
8000734e:	99 3c       	st.w	r12[0xc],r12
80007350:	99 2c       	st.w	r12[0x8],r12
80007352:	58 08       	cp.w	r8,0
80007354:	c0 55       	brlt	8000735e <_malloc_r+0x12e>
80007356:	ec 09 00 09 	add	r9,r6,r9
8000735a:	0a 9c       	mov	r12,r5
8000735c:	ce 2b       	rjmp	80007320 <_malloc_r+0xf0>
8000735e:	e0 49 01 ff 	cp.w	r9,511
80007362:	e0 8b 00 13 	brhi	80007388 <_malloc_r+0x158>
80007366:	a3 99       	lsr	r9,0x3
80007368:	f4 09 00 38 	add	r8,r10,r9<<0x3
8000736c:	70 2b       	ld.w	r11,r8[0x8]
8000736e:	8d 38       	st.w	r6[0xc],r8
80007370:	8d 2b       	st.w	r6[0x8],r11
80007372:	97 36       	st.w	r11[0xc],r6
80007374:	91 26       	st.w	r8[0x8],r6
80007376:	a3 49       	asr	r9,0x2
80007378:	74 18       	ld.w	r8,r10[0x4]
8000737a:	30 1b       	mov	r11,1
8000737c:	f6 09 09 49 	lsl	r9,r11,r9
80007380:	f1 e9 10 09 	or	r9,r8,r9
80007384:	95 19       	st.w	r10[0x4],r9
80007386:	c4 78       	rjmp	80007414 <_malloc_r+0x1e4>
80007388:	f2 0a 16 09 	lsr	r10,r9,0x9
8000738c:	58 4a       	cp.w	r10,4
8000738e:	e0 8b 00 07 	brhi	8000739c <_malloc_r+0x16c>
80007392:	f2 0a 16 06 	lsr	r10,r9,0x6
80007396:	2c 8a       	sub	r10,-56
80007398:	c2 08       	rjmp	800073d8 <_malloc_r+0x1a8>
8000739a:	d7 03       	nop
8000739c:	59 4a       	cp.w	r10,20
8000739e:	e0 8b 00 04 	brhi	800073a6 <_malloc_r+0x176>
800073a2:	2a 5a       	sub	r10,-91
800073a4:	c1 a8       	rjmp	800073d8 <_malloc_r+0x1a8>
800073a6:	e0 4a 00 54 	cp.w	r10,84
800073aa:	e0 8b 00 06 	brhi	800073b6 <_malloc_r+0x186>
800073ae:	f2 0a 16 0c 	lsr	r10,r9,0xc
800073b2:	29 2a       	sub	r10,-110
800073b4:	c1 28       	rjmp	800073d8 <_malloc_r+0x1a8>
800073b6:	e0 4a 01 54 	cp.w	r10,340
800073ba:	e0 8b 00 06 	brhi	800073c6 <_malloc_r+0x196>
800073be:	f2 0a 16 0f 	lsr	r10,r9,0xf
800073c2:	28 9a       	sub	r10,-119
800073c4:	c0 a8       	rjmp	800073d8 <_malloc_r+0x1a8>
800073c6:	e0 4a 05 54 	cp.w	r10,1364
800073ca:	e0 88 00 04 	brls	800073d2 <_malloc_r+0x1a2>
800073ce:	37 ea       	mov	r10,126
800073d0:	c0 48       	rjmp	800073d8 <_malloc_r+0x1a8>
800073d2:	f2 0a 16 12 	lsr	r10,r9,0x12
800073d6:	28 4a       	sub	r10,-124
800073d8:	e0 6b 05 3c 	mov	r11,1340
800073dc:	f6 0a 00 34 	add	r4,r11,r10<<0x3
800073e0:	68 28       	ld.w	r8,r4[0x8]
800073e2:	08 38       	cp.w	r8,r4
800073e4:	c0 e1       	brne	80007400 <_malloc_r+0x1d0>
800073e6:	76 19       	ld.w	r9,r11[0x4]
800073e8:	a3 4a       	asr	r10,0x2
800073ea:	30 1e       	mov	lr,1
800073ec:	fc 0a 09 4a 	lsl	r10,lr,r10
800073f0:	f3 ea 10 0a 	or	r10,r9,r10
800073f4:	10 99       	mov	r9,r8
800073f6:	97 1a       	st.w	r11[0x4],r10
800073f8:	c0 a8       	rjmp	8000740c <_malloc_r+0x1dc>
800073fa:	70 28       	ld.w	r8,r8[0x8]
800073fc:	08 38       	cp.w	r8,r4
800073fe:	c0 60       	breq	8000740a <_malloc_r+0x1da>
80007400:	70 1a       	ld.w	r10,r8[0x4]
80007402:	e0 1a ff fc 	andl	r10,0xfffc
80007406:	14 39       	cp.w	r9,r10
80007408:	cf 93       	brcs	800073fa <_malloc_r+0x1ca>
8000740a:	70 39       	ld.w	r9,r8[0xc]
8000740c:	8d 39       	st.w	r6[0xc],r9
8000740e:	8d 28       	st.w	r6[0x8],r8
80007410:	91 36       	st.w	r8[0xc],r6
80007412:	93 26       	st.w	r9[0x8],r6
80007414:	e6 08 14 02 	asr	r8,r3,0x2
80007418:	30 1b       	mov	r11,1
8000741a:	e0 64 05 3c 	mov	r4,1340
8000741e:	f6 08 09 4b 	lsl	r11,r11,r8
80007422:	68 18       	ld.w	r8,r4[0x4]
80007424:	10 3b       	cp.w	r11,r8
80007426:	e0 8b 00 6b 	brhi	800074fc <_malloc_r+0x2cc>
8000742a:	f7 e8 00 09 	and	r9,r11,r8
8000742e:	c0 b1       	brne	80007444 <_malloc_r+0x214>
80007430:	e0 13 ff fc 	andl	r3,0xfffc
80007434:	a1 7b       	lsl	r11,0x1
80007436:	2f c3       	sub	r3,-4
80007438:	c0 38       	rjmp	8000743e <_malloc_r+0x20e>
8000743a:	2f c3       	sub	r3,-4
8000743c:	a1 7b       	lsl	r11,0x1
8000743e:	f7 e8 00 09 	and	r9,r11,r8
80007442:	cf c0       	breq	8000743a <_malloc_r+0x20a>
80007444:	e8 03 00 3e 	add	lr,r4,r3<<0x3
80007448:	06 92       	mov	r2,r3
8000744a:	1c 91       	mov	r1,lr
8000744c:	62 36       	ld.w	r6,r1[0xc]
8000744e:	c2 e8       	rjmp	800074aa <_malloc_r+0x27a>
80007450:	6c 1a       	ld.w	r10,r6[0x4]
80007452:	e0 1a ff fc 	andl	r10,0xfffc
80007456:	f4 07 01 08 	sub	r8,r10,r7
8000745a:	58 f8       	cp.w	r8,15
8000745c:	e0 8a 00 15 	brle	80007486 <_malloc_r+0x256>
80007460:	6c 3a       	ld.w	r10,r6[0xc]
80007462:	6c 29       	ld.w	r9,r6[0x8]
80007464:	95 29       	st.w	r10[0x8],r9
80007466:	93 3a       	st.w	r9[0xc],r10
80007468:	0e 99       	mov	r9,r7
8000746a:	ec 07 00 07 	add	r7,r6,r7
8000746e:	a1 a9       	sbr	r9,0x0
80007470:	99 37       	st.w	r12[0xc],r7
80007472:	99 27       	st.w	r12[0x8],r7
80007474:	8d 19       	st.w	r6[0x4],r9
80007476:	ee 08 09 08 	st.w	r7[r8],r8
8000747a:	8f 2c       	st.w	r7[0x8],r12
8000747c:	8f 3c       	st.w	r7[0xc],r12
8000747e:	a1 a8       	sbr	r8,0x0
80007480:	0a 9c       	mov	r12,r5
80007482:	8f 18       	st.w	r7[0x4],r8
80007484:	c0 d8       	rjmp	8000749e <_malloc_r+0x26e>
80007486:	6c 39       	ld.w	r9,r6[0xc]
80007488:	58 08       	cp.w	r8,0
8000748a:	c0 f5       	brlt	800074a8 <_malloc_r+0x278>
8000748c:	ec 0a 00 0a 	add	r10,r6,r10
80007490:	74 18       	ld.w	r8,r10[0x4]
80007492:	a1 a8       	sbr	r8,0x0
80007494:	0a 9c       	mov	r12,r5
80007496:	95 18       	st.w	r10[0x4],r8
80007498:	6c 28       	ld.w	r8,r6[0x8]
8000749a:	93 28       	st.w	r9[0x8],r8
8000749c:	91 39       	st.w	r8[0xc],r9
8000749e:	fe b0 f4 89 	rcall	80005db0 <__malloc_unlock>
800074a2:	ec cc ff f8 	sub	r12,r6,-8
800074a6:	d8 32       	popm	r0-r7,pc
800074a8:	12 96       	mov	r6,r9
800074aa:	02 36       	cp.w	r6,r1
800074ac:	cd 21       	brne	80007450 <_malloc_r+0x220>
800074ae:	2f f2       	sub	r2,-1
800074b0:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
800074b4:	c0 30       	breq	800074ba <_malloc_r+0x28a>
800074b6:	2f 81       	sub	r1,-8
800074b8:	cc ab       	rjmp	8000744c <_malloc_r+0x21c>
800074ba:	1c 98       	mov	r8,lr
800074bc:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
800074c0:	c0 81       	brne	800074d0 <_malloc_r+0x2a0>
800074c2:	68 19       	ld.w	r9,r4[0x4]
800074c4:	f6 08 11 ff 	rsub	r8,r11,-1
800074c8:	f3 e8 00 08 	and	r8,r9,r8
800074cc:	89 18       	st.w	r4[0x4],r8
800074ce:	c0 78       	rjmp	800074dc <_malloc_r+0x2ac>
800074d0:	f0 c9 00 08 	sub	r9,r8,8
800074d4:	20 13       	sub	r3,1
800074d6:	70 08       	ld.w	r8,r8[0x0]
800074d8:	12 38       	cp.w	r8,r9
800074da:	cf 10       	breq	800074bc <_malloc_r+0x28c>
800074dc:	a1 7b       	lsl	r11,0x1
800074de:	68 18       	ld.w	r8,r4[0x4]
800074e0:	10 3b       	cp.w	r11,r8
800074e2:	e0 8b 00 0d 	brhi	800074fc <_malloc_r+0x2cc>
800074e6:	58 0b       	cp.w	r11,0
800074e8:	c0 a0       	breq	800074fc <_malloc_r+0x2cc>
800074ea:	04 93       	mov	r3,r2
800074ec:	c0 38       	rjmp	800074f2 <_malloc_r+0x2c2>
800074ee:	2f c3       	sub	r3,-4
800074f0:	a1 7b       	lsl	r11,0x1
800074f2:	f7 e8 00 09 	and	r9,r11,r8
800074f6:	ca 71       	brne	80007444 <_malloc_r+0x214>
800074f8:	cf bb       	rjmp	800074ee <_malloc_r+0x2be>
800074fa:	d7 03       	nop
800074fc:	68 23       	ld.w	r3,r4[0x8]
800074fe:	66 12       	ld.w	r2,r3[0x4]
80007500:	e0 12 ff fc 	andl	r2,0xfffc
80007504:	0e 32       	cp.w	r2,r7
80007506:	5f 39       	srlo	r9
80007508:	e4 07 01 08 	sub	r8,r2,r7
8000750c:	58 f8       	cp.w	r8,15
8000750e:	5f aa       	srle	r10
80007510:	f5 e9 10 09 	or	r9,r10,r9
80007514:	e0 80 00 9a 	breq	80007648 <_malloc_r+0x418>
80007518:	e0 68 0d 64 	mov	r8,3428
8000751c:	70 01       	ld.w	r1,r8[0x0]
8000751e:	e0 68 09 48 	mov	r8,2376
80007522:	2f 01       	sub	r1,-16
80007524:	70 08       	ld.w	r8,r8[0x0]
80007526:	0e 01       	add	r1,r7
80007528:	5b f8       	cp.w	r8,-1
8000752a:	c0 40       	breq	80007532 <_malloc_r+0x302>
8000752c:	28 11       	sub	r1,-127
8000752e:	e0 11 ff 80 	andl	r1,0xff80
80007532:	02 9b       	mov	r11,r1
80007534:	0a 9c       	mov	r12,r5
80007536:	e0 a0 02 a5 	rcall	80007a80 <_sbrk_r>
8000753a:	18 96       	mov	r6,r12
8000753c:	5b fc       	cp.w	r12,-1
8000753e:	c7 50       	breq	80007628 <_malloc_r+0x3f8>
80007540:	e6 02 00 08 	add	r8,r3,r2
80007544:	10 3c       	cp.w	r12,r8
80007546:	c0 32       	brcc	8000754c <_malloc_r+0x31c>
80007548:	08 33       	cp.w	r3,r4
8000754a:	c6 f1       	brne	80007628 <_malloc_r+0x3f8>
8000754c:	e0 6a 0d 68 	mov	r10,3432
80007550:	74 09       	ld.w	r9,r10[0x0]
80007552:	e2 09 00 09 	add	r9,r1,r9
80007556:	95 09       	st.w	r10[0x0],r9
80007558:	10 36       	cp.w	r6,r8
8000755a:	c0 a1       	brne	8000756e <_malloc_r+0x33e>
8000755c:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
80007560:	c0 71       	brne	8000756e <_malloc_r+0x33e>
80007562:	e2 02 00 02 	add	r2,r1,r2
80007566:	68 28       	ld.w	r8,r4[0x8]
80007568:	a1 a2       	sbr	r2,0x0
8000756a:	91 12       	st.w	r8[0x4],r2
8000756c:	c4 f8       	rjmp	8000760a <_malloc_r+0x3da>
8000756e:	e0 6a 09 48 	mov	r10,2376
80007572:	74 0b       	ld.w	r11,r10[0x0]
80007574:	5b fb       	cp.w	r11,-1
80007576:	c0 31       	brne	8000757c <_malloc_r+0x34c>
80007578:	95 06       	st.w	r10[0x0],r6
8000757a:	c0 78       	rjmp	80007588 <_malloc_r+0x358>
8000757c:	ec 09 00 09 	add	r9,r6,r9
80007580:	e0 6a 0d 68 	mov	r10,3432
80007584:	10 19       	sub	r9,r8
80007586:	95 09       	st.w	r10[0x0],r9
80007588:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
8000758c:	f0 09 11 08 	rsub	r9,r8,8
80007590:	58 08       	cp.w	r8,0
80007592:	f2 08 17 10 	movne	r8,r9
80007596:	ed d8 e1 06 	addne	r6,r6,r8
8000759a:	28 08       	sub	r8,-128
8000759c:	ec 01 00 01 	add	r1,r6,r1
800075a0:	0a 9c       	mov	r12,r5
800075a2:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
800075a6:	f0 01 01 01 	sub	r1,r8,r1
800075aa:	02 9b       	mov	r11,r1
800075ac:	e0 a0 02 6a 	rcall	80007a80 <_sbrk_r>
800075b0:	e0 68 0d 68 	mov	r8,3432
800075b4:	5b fc       	cp.w	r12,-1
800075b6:	ec 0c 17 00 	moveq	r12,r6
800075ba:	f9 b1 00 00 	moveq	r1,0
800075be:	70 09       	ld.w	r9,r8[0x0]
800075c0:	0c 1c       	sub	r12,r6
800075c2:	89 26       	st.w	r4[0x8],r6
800075c4:	02 0c       	add	r12,r1
800075c6:	12 01       	add	r1,r9
800075c8:	a1 ac       	sbr	r12,0x0
800075ca:	91 01       	st.w	r8[0x0],r1
800075cc:	8d 1c       	st.w	r6[0x4],r12
800075ce:	08 33       	cp.w	r3,r4
800075d0:	c1 d0       	breq	8000760a <_malloc_r+0x3da>
800075d2:	58 f2       	cp.w	r2,15
800075d4:	e0 8b 00 05 	brhi	800075de <_malloc_r+0x3ae>
800075d8:	30 18       	mov	r8,1
800075da:	8d 18       	st.w	r6[0x4],r8
800075dc:	c2 68       	rjmp	80007628 <_malloc_r+0x3f8>
800075de:	30 59       	mov	r9,5
800075e0:	20 c2       	sub	r2,12
800075e2:	e0 12 ff f8 	andl	r2,0xfff8
800075e6:	e6 02 00 08 	add	r8,r3,r2
800075ea:	91 29       	st.w	r8[0x8],r9
800075ec:	91 19       	st.w	r8[0x4],r9
800075ee:	66 18       	ld.w	r8,r3[0x4]
800075f0:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800075f4:	e5 e8 10 08 	or	r8,r2,r8
800075f8:	87 18       	st.w	r3[0x4],r8
800075fa:	58 f2       	cp.w	r2,15
800075fc:	e0 88 00 07 	brls	8000760a <_malloc_r+0x3da>
80007600:	e6 cb ff f8 	sub	r11,r3,-8
80007604:	0a 9c       	mov	r12,r5
80007606:	e0 a0 1c 6b 	rcall	8000aedc <_free_r>
8000760a:	e0 69 0d 60 	mov	r9,3424
8000760e:	72 0a       	ld.w	r10,r9[0x0]
80007610:	e0 68 0d 68 	mov	r8,3432
80007614:	70 08       	ld.w	r8,r8[0x0]
80007616:	14 38       	cp.w	r8,r10
80007618:	f3 f8 ba 00 	st.whi	r9[0x0],r8
8000761c:	e0 69 0d 5c 	mov	r9,3420
80007620:	72 0a       	ld.w	r10,r9[0x0]
80007622:	14 38       	cp.w	r8,r10
80007624:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80007628:	68 28       	ld.w	r8,r4[0x8]
8000762a:	70 18       	ld.w	r8,r8[0x4]
8000762c:	e0 18 ff fc 	andl	r8,0xfffc
80007630:	0e 38       	cp.w	r8,r7
80007632:	5f 39       	srlo	r9
80007634:	0e 18       	sub	r8,r7
80007636:	58 f8       	cp.w	r8,15
80007638:	5f aa       	srle	r10
8000763a:	f5 e9 10 09 	or	r9,r10,r9
8000763e:	c0 50       	breq	80007648 <_malloc_r+0x418>
80007640:	0a 9c       	mov	r12,r5
80007642:	fe b0 f3 b7 	rcall	80005db0 <__malloc_unlock>
80007646:	d8 3a       	popm	r0-r7,pc,r12=0
80007648:	68 26       	ld.w	r6,r4[0x8]
8000764a:	a1 a8       	sbr	r8,0x0
8000764c:	0e 99       	mov	r9,r7
8000764e:	a1 a9       	sbr	r9,0x0
80007650:	8d 19       	st.w	r6[0x4],r9
80007652:	ec 07 00 07 	add	r7,r6,r7
80007656:	0a 9c       	mov	r12,r5
80007658:	89 27       	st.w	r4[0x8],r7
8000765a:	8f 18       	st.w	r7[0x4],r8
8000765c:	fe b0 f3 aa 	rcall	80005db0 <__malloc_unlock>
80007660:	ec cc ff f8 	sub	r12,r6,-8
80007664:	d8 32       	popm	r0-r7,pc
80007666:	d7 03       	nop

80007668 <memcpy>:
80007668:	58 8a       	cp.w	r10,8
8000766a:	c2 f5       	brlt	800076c8 <memcpy+0x60>
8000766c:	f9 eb 10 09 	or	r9,r12,r11
80007670:	e2 19 00 03 	andl	r9,0x3,COH
80007674:	e0 81 00 97 	brne	800077a2 <memcpy+0x13a>
80007678:	e0 4a 00 20 	cp.w	r10,32
8000767c:	c3 b4       	brge	800076f2 <memcpy+0x8a>
8000767e:	f4 08 14 02 	asr	r8,r10,0x2
80007682:	f0 09 11 08 	rsub	r9,r8,8
80007686:	fe 09 00 2f 	add	pc,pc,r9<<0x2
8000768a:	76 69       	ld.w	r9,r11[0x18]
8000768c:	99 69       	st.w	r12[0x18],r9
8000768e:	76 59       	ld.w	r9,r11[0x14]
80007690:	99 59       	st.w	r12[0x14],r9
80007692:	76 49       	ld.w	r9,r11[0x10]
80007694:	99 49       	st.w	r12[0x10],r9
80007696:	76 39       	ld.w	r9,r11[0xc]
80007698:	99 39       	st.w	r12[0xc],r9
8000769a:	76 29       	ld.w	r9,r11[0x8]
8000769c:	99 29       	st.w	r12[0x8],r9
8000769e:	76 19       	ld.w	r9,r11[0x4]
800076a0:	99 19       	st.w	r12[0x4],r9
800076a2:	76 09       	ld.w	r9,r11[0x0]
800076a4:	99 09       	st.w	r12[0x0],r9
800076a6:	f6 08 00 2b 	add	r11,r11,r8<<0x2
800076aa:	f8 08 00 28 	add	r8,r12,r8<<0x2
800076ae:	e0 1a 00 03 	andl	r10,0x3
800076b2:	f4 0a 11 04 	rsub	r10,r10,4
800076b6:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
800076ba:	17 a9       	ld.ub	r9,r11[0x2]
800076bc:	b0 a9       	st.b	r8[0x2],r9
800076be:	17 99       	ld.ub	r9,r11[0x1]
800076c0:	b0 99       	st.b	r8[0x1],r9
800076c2:	17 89       	ld.ub	r9,r11[0x0]
800076c4:	b0 89       	st.b	r8[0x0],r9
800076c6:	5e fc       	retal	r12
800076c8:	f4 0a 11 09 	rsub	r10,r10,9
800076cc:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
800076d0:	17 f9       	ld.ub	r9,r11[0x7]
800076d2:	b8 f9       	st.b	r12[0x7],r9
800076d4:	17 e9       	ld.ub	r9,r11[0x6]
800076d6:	b8 e9       	st.b	r12[0x6],r9
800076d8:	17 d9       	ld.ub	r9,r11[0x5]
800076da:	b8 d9       	st.b	r12[0x5],r9
800076dc:	17 c9       	ld.ub	r9,r11[0x4]
800076de:	b8 c9       	st.b	r12[0x4],r9
800076e0:	17 b9       	ld.ub	r9,r11[0x3]
800076e2:	b8 b9       	st.b	r12[0x3],r9
800076e4:	17 a9       	ld.ub	r9,r11[0x2]
800076e6:	b8 a9       	st.b	r12[0x2],r9
800076e8:	17 99       	ld.ub	r9,r11[0x1]
800076ea:	b8 99       	st.b	r12[0x1],r9
800076ec:	17 89       	ld.ub	r9,r11[0x0]
800076ee:	b8 89       	st.b	r12[0x0],r9
800076f0:	5e fc       	retal	r12
800076f2:	eb cd 40 c0 	pushm	r6-r7,lr
800076f6:	18 99       	mov	r9,r12
800076f8:	22 0a       	sub	r10,32
800076fa:	b7 07       	ld.d	r6,r11++
800076fc:	b3 26       	st.d	r9++,r6
800076fe:	b7 07       	ld.d	r6,r11++
80007700:	b3 26       	st.d	r9++,r6
80007702:	b7 07       	ld.d	r6,r11++
80007704:	b3 26       	st.d	r9++,r6
80007706:	b7 07       	ld.d	r6,r11++
80007708:	b3 26       	st.d	r9++,r6
8000770a:	22 0a       	sub	r10,32
8000770c:	cf 74       	brge	800076fa <memcpy+0x92>
8000770e:	2f 0a       	sub	r10,-16
80007710:	c0 65       	brlt	8000771c <memcpy+0xb4>
80007712:	b7 07       	ld.d	r6,r11++
80007714:	b3 26       	st.d	r9++,r6
80007716:	b7 07       	ld.d	r6,r11++
80007718:	b3 26       	st.d	r9++,r6
8000771a:	21 0a       	sub	r10,16
8000771c:	5c 3a       	neg	r10
8000771e:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
80007722:	d7 03       	nop
80007724:	d7 03       	nop
80007726:	f7 36 00 0e 	ld.ub	r6,r11[14]
8000772a:	f3 66 00 0e 	st.b	r9[14],r6
8000772e:	f7 36 00 0d 	ld.ub	r6,r11[13]
80007732:	f3 66 00 0d 	st.b	r9[13],r6
80007736:	f7 36 00 0c 	ld.ub	r6,r11[12]
8000773a:	f3 66 00 0c 	st.b	r9[12],r6
8000773e:	f7 36 00 0b 	ld.ub	r6,r11[11]
80007742:	f3 66 00 0b 	st.b	r9[11],r6
80007746:	f7 36 00 0a 	ld.ub	r6,r11[10]
8000774a:	f3 66 00 0a 	st.b	r9[10],r6
8000774e:	f7 36 00 09 	ld.ub	r6,r11[9]
80007752:	f3 66 00 09 	st.b	r9[9],r6
80007756:	f7 36 00 08 	ld.ub	r6,r11[8]
8000775a:	f3 66 00 08 	st.b	r9[8],r6
8000775e:	f7 36 00 07 	ld.ub	r6,r11[7]
80007762:	f3 66 00 07 	st.b	r9[7],r6
80007766:	f7 36 00 06 	ld.ub	r6,r11[6]
8000776a:	f3 66 00 06 	st.b	r9[6],r6
8000776e:	f7 36 00 05 	ld.ub	r6,r11[5]
80007772:	f3 66 00 05 	st.b	r9[5],r6
80007776:	f7 36 00 04 	ld.ub	r6,r11[4]
8000777a:	f3 66 00 04 	st.b	r9[4],r6
8000777e:	f7 36 00 03 	ld.ub	r6,r11[3]
80007782:	f3 66 00 03 	st.b	r9[3],r6
80007786:	f7 36 00 02 	ld.ub	r6,r11[2]
8000778a:	f3 66 00 02 	st.b	r9[2],r6
8000778e:	f7 36 00 01 	ld.ub	r6,r11[1]
80007792:	f3 66 00 01 	st.b	r9[1],r6
80007796:	f7 36 00 00 	ld.ub	r6,r11[0]
8000779a:	f3 66 00 00 	st.b	r9[0],r6
8000779e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800077a2:	20 1a       	sub	r10,1
800077a4:	f6 0a 07 09 	ld.ub	r9,r11[r10]
800077a8:	f8 0a 0b 09 	st.b	r12[r10],r9
800077ac:	cf b1       	brne	800077a2 <memcpy+0x13a>
800077ae:	5e fc       	retal	r12

800077b0 <memset>:
800077b0:	18 98       	mov	r8,r12
800077b2:	c0 38       	rjmp	800077b8 <memset+0x8>
800077b4:	10 cb       	st.b	r8++,r11
800077b6:	20 1a       	sub	r10,1
800077b8:	58 0a       	cp.w	r10,0
800077ba:	cf d1       	brne	800077b4 <memset+0x4>
800077bc:	5e fc       	retal	r12
800077be:	d7 03       	nop

800077c0 <_realloc_r>:
800077c0:	d4 31       	pushm	r0-r7,lr
800077c2:	20 1d       	sub	sp,4
800077c4:	16 94       	mov	r4,r11
800077c6:	18 92       	mov	r2,r12
800077c8:	14 9b       	mov	r11,r10
800077ca:	58 04       	cp.w	r4,0
800077cc:	c0 51       	brne	800077d6 <_realloc_r+0x16>
800077ce:	fe b0 fd 31 	rcall	80007230 <_malloc_r>
800077d2:	18 95       	mov	r5,r12
800077d4:	c5 39       	rjmp	80007a7a <_realloc_r+0x2ba>
800077d6:	50 0a       	stdsp	sp[0x0],r10
800077d8:	fe b0 f2 e6 	rcall	80005da4 <__malloc_lock>
800077dc:	40 0b       	lddsp	r11,sp[0x0]
800077de:	f6 c8 ff f5 	sub	r8,r11,-11
800077e2:	e8 c1 00 08 	sub	r1,r4,8
800077e6:	10 96       	mov	r6,r8
800077e8:	62 1c       	ld.w	r12,r1[0x4]
800077ea:	e0 16 ff f8 	andl	r6,0xfff8
800077ee:	59 68       	cp.w	r8,22
800077f0:	f9 b6 08 10 	movls	r6,16
800077f4:	16 36       	cp.w	r6,r11
800077f6:	5f 38       	srlo	r8
800077f8:	f1 e6 13 f8 	or	r8,r8,r6>>0x1f
800077fc:	c0 50       	breq	80007806 <_realloc_r+0x46>
800077fe:	30 c8       	mov	r8,12
80007800:	30 05       	mov	r5,0
80007802:	85 38       	st.w	r2[0xc],r8
80007804:	c3 b9       	rjmp	80007a7a <_realloc_r+0x2ba>
80007806:	18 90       	mov	r0,r12
80007808:	e0 10 ff fc 	andl	r0,0xfffc
8000780c:	0c 30       	cp.w	r0,r6
8000780e:	e0 84 01 0b 	brge	80007a24 <_realloc_r+0x264>
80007812:	e0 68 05 3c 	mov	r8,1340
80007816:	e2 00 00 09 	add	r9,r1,r0
8000781a:	70 25       	ld.w	r5,r8[0x8]
8000781c:	0a 39       	cp.w	r9,r5
8000781e:	c0 90       	breq	80007830 <_realloc_r+0x70>
80007820:	72 1a       	ld.w	r10,r9[0x4]
80007822:	a1 ca       	cbr	r10,0x0
80007824:	f2 0a 00 0a 	add	r10,r9,r10
80007828:	74 1a       	ld.w	r10,r10[0x4]
8000782a:	ed ba 00 00 	bld	r10,0x0
8000782e:	c2 20       	breq	80007872 <_realloc_r+0xb2>
80007830:	72 1a       	ld.w	r10,r9[0x4]
80007832:	e0 1a ff fc 	andl	r10,0xfffc
80007836:	f4 00 00 03 	add	r3,r10,r0
8000783a:	0a 39       	cp.w	r9,r5
8000783c:	c1 31       	brne	80007862 <_realloc_r+0xa2>
8000783e:	ec c7 ff f0 	sub	r7,r6,-16
80007842:	0e 33       	cp.w	r3,r7
80007844:	c1 95       	brlt	80007876 <_realloc_r+0xb6>
80007846:	e2 06 00 09 	add	r9,r1,r6
8000784a:	0c 13       	sub	r3,r6
8000784c:	a1 a3       	sbr	r3,0x0
8000784e:	93 13       	st.w	r9[0x4],r3
80007850:	91 29       	st.w	r8[0x8],r9
80007852:	04 9c       	mov	r12,r2
80007854:	62 18       	ld.w	r8,r1[0x4]
80007856:	08 95       	mov	r5,r4
80007858:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000785c:	10 46       	or	r6,r8
8000785e:	83 16       	st.w	r1[0x4],r6
80007860:	c0 b9       	rjmp	80007a76 <_realloc_r+0x2b6>
80007862:	0c 33       	cp.w	r3,r6
80007864:	c0 95       	brlt	80007876 <_realloc_r+0xb6>
80007866:	72 28       	ld.w	r8,r9[0x8]
80007868:	02 97       	mov	r7,r1
8000786a:	72 39       	ld.w	r9,r9[0xc]
8000786c:	93 28       	st.w	r9[0x8],r8
8000786e:	91 39       	st.w	r8[0xc],r9
80007870:	cd c8       	rjmp	80007a28 <_realloc_r+0x268>
80007872:	30 0a       	mov	r10,0
80007874:	14 99       	mov	r9,r10
80007876:	ed bc 00 00 	bld	r12,0x0
8000787a:	e0 80 00 95 	breq	800079a4 <_realloc_r+0x1e4>
8000787e:	62 07       	ld.w	r7,r1[0x0]
80007880:	e2 07 01 07 	sub	r7,r1,r7
80007884:	6e 1c       	ld.w	r12,r7[0x4]
80007886:	e0 1c ff fc 	andl	r12,0xfffc
8000788a:	58 09       	cp.w	r9,0
8000788c:	c5 60       	breq	80007938 <_realloc_r+0x178>
8000788e:	f8 00 00 03 	add	r3,r12,r0
80007892:	0a 39       	cp.w	r9,r5
80007894:	c4 81       	brne	80007924 <_realloc_r+0x164>
80007896:	14 03       	add	r3,r10
80007898:	ec c9 ff f0 	sub	r9,r6,-16
8000789c:	12 33       	cp.w	r3,r9
8000789e:	c4 d5       	brlt	80007938 <_realloc_r+0x178>
800078a0:	6e 3a       	ld.w	r10,r7[0xc]
800078a2:	6e 29       	ld.w	r9,r7[0x8]
800078a4:	95 29       	st.w	r10[0x8],r9
800078a6:	93 3a       	st.w	r9[0xc],r10
800078a8:	ee c5 ff f8 	sub	r5,r7,-8
800078ac:	e0 ca 00 04 	sub	r10,r0,4
800078b0:	e0 4a 00 24 	cp.w	r10,36
800078b4:	e0 8b 00 25 	brhi	800078fe <_realloc_r+0x13e>
800078b8:	0a 99       	mov	r9,r5
800078ba:	59 3a       	cp.w	r10,19
800078bc:	e0 88 00 1a 	brls	800078f0 <_realloc_r+0x130>
800078c0:	09 09       	ld.w	r9,r4++
800078c2:	8b 09       	st.w	r5[0x0],r9
800078c4:	09 09       	ld.w	r9,r4++
800078c6:	8f 39       	st.w	r7[0xc],r9
800078c8:	ee c9 ff f0 	sub	r9,r7,-16
800078cc:	59 ba       	cp.w	r10,27
800078ce:	e0 88 00 11 	brls	800078f0 <_realloc_r+0x130>
800078d2:	09 0b       	ld.w	r11,r4++
800078d4:	93 0b       	st.w	r9[0x0],r11
800078d6:	09 09       	ld.w	r9,r4++
800078d8:	8f 59       	st.w	r7[0x14],r9
800078da:	ee c9 ff e8 	sub	r9,r7,-24
800078de:	e0 4a 00 24 	cp.w	r10,36
800078e2:	c0 71       	brne	800078f0 <_realloc_r+0x130>
800078e4:	09 0a       	ld.w	r10,r4++
800078e6:	93 0a       	st.w	r9[0x0],r10
800078e8:	ee c9 ff e0 	sub	r9,r7,-32
800078ec:	09 0a       	ld.w	r10,r4++
800078ee:	8f 7a       	st.w	r7[0x1c],r10
800078f0:	09 0a       	ld.w	r10,r4++
800078f2:	12 aa       	st.w	r9++,r10
800078f4:	68 0a       	ld.w	r10,r4[0x0]
800078f6:	93 0a       	st.w	r9[0x0],r10
800078f8:	68 1a       	ld.w	r10,r4[0x4]
800078fa:	93 1a       	st.w	r9[0x4],r10
800078fc:	c0 78       	rjmp	8000790a <_realloc_r+0x14a>
800078fe:	50 08       	stdsp	sp[0x0],r8
80007900:	08 9b       	mov	r11,r4
80007902:	0a 9c       	mov	r12,r5
80007904:	e0 a0 1d 8f 	rcall	8000b422 <memmove>
80007908:	40 08       	lddsp	r8,sp[0x0]
8000790a:	ee 06 00 09 	add	r9,r7,r6
8000790e:	0c 13       	sub	r3,r6
80007910:	a1 a3       	sbr	r3,0x0
80007912:	93 13       	st.w	r9[0x4],r3
80007914:	91 29       	st.w	r8[0x8],r9
80007916:	04 9c       	mov	r12,r2
80007918:	6e 18       	ld.w	r8,r7[0x4]
8000791a:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000791e:	10 46       	or	r6,r8
80007920:	8f 16       	st.w	r7[0x4],r6
80007922:	ca a8       	rjmp	80007a76 <_realloc_r+0x2b6>
80007924:	14 03       	add	r3,r10
80007926:	0c 33       	cp.w	r3,r6
80007928:	c0 85       	brlt	80007938 <_realloc_r+0x178>
8000792a:	72 28       	ld.w	r8,r9[0x8]
8000792c:	72 39       	ld.w	r9,r9[0xc]
8000792e:	93 28       	st.w	r9[0x8],r8
80007930:	91 39       	st.w	r8[0xc],r9
80007932:	6e 28       	ld.w	r8,r7[0x8]
80007934:	6e 39       	ld.w	r9,r7[0xc]
80007936:	c0 78       	rjmp	80007944 <_realloc_r+0x184>
80007938:	f8 00 00 03 	add	r3,r12,r0
8000793c:	0c 33       	cp.w	r3,r6
8000793e:	c3 35       	brlt	800079a4 <_realloc_r+0x1e4>
80007940:	6e 39       	ld.w	r9,r7[0xc]
80007942:	6e 28       	ld.w	r8,r7[0x8]
80007944:	93 28       	st.w	r9[0x8],r8
80007946:	91 39       	st.w	r8[0xc],r9
80007948:	e0 ca 00 04 	sub	r10,r0,4
8000794c:	ee cc ff f8 	sub	r12,r7,-8
80007950:	e0 4a 00 24 	cp.w	r10,36
80007954:	e0 8b 00 24 	brhi	8000799c <_realloc_r+0x1dc>
80007958:	59 3a       	cp.w	r10,19
8000795a:	e0 88 00 1a 	brls	8000798e <_realloc_r+0x1ce>
8000795e:	09 08       	ld.w	r8,r4++
80007960:	99 08       	st.w	r12[0x0],r8
80007962:	09 08       	ld.w	r8,r4++
80007964:	8f 38       	st.w	r7[0xc],r8
80007966:	ee cc ff f0 	sub	r12,r7,-16
8000796a:	59 ba       	cp.w	r10,27
8000796c:	e0 88 00 11 	brls	8000798e <_realloc_r+0x1ce>
80007970:	09 08       	ld.w	r8,r4++
80007972:	99 08       	st.w	r12[0x0],r8
80007974:	09 08       	ld.w	r8,r4++
80007976:	8f 58       	st.w	r7[0x14],r8
80007978:	ee cc ff e8 	sub	r12,r7,-24
8000797c:	e0 4a 00 24 	cp.w	r10,36
80007980:	c0 71       	brne	8000798e <_realloc_r+0x1ce>
80007982:	09 08       	ld.w	r8,r4++
80007984:	99 08       	st.w	r12[0x0],r8
80007986:	ee cc ff e0 	sub	r12,r7,-32
8000798a:	09 08       	ld.w	r8,r4++
8000798c:	8f 78       	st.w	r7[0x1c],r8
8000798e:	09 08       	ld.w	r8,r4++
80007990:	18 a8       	st.w	r12++,r8
80007992:	68 08       	ld.w	r8,r4[0x0]
80007994:	99 08       	st.w	r12[0x0],r8
80007996:	68 18       	ld.w	r8,r4[0x4]
80007998:	99 18       	st.w	r12[0x4],r8
8000799a:	c4 78       	rjmp	80007a28 <_realloc_r+0x268>
8000799c:	08 9b       	mov	r11,r4
8000799e:	e0 a0 1d 42 	rcall	8000b422 <memmove>
800079a2:	c4 38       	rjmp	80007a28 <_realloc_r+0x268>
800079a4:	04 9c       	mov	r12,r2
800079a6:	fe b0 fc 45 	rcall	80007230 <_malloc_r>
800079aa:	18 95       	mov	r5,r12
800079ac:	c3 a0       	breq	80007a20 <_realloc_r+0x260>
800079ae:	62 18       	ld.w	r8,r1[0x4]
800079b0:	f8 c9 00 08 	sub	r9,r12,8
800079b4:	a1 c8       	cbr	r8,0x0
800079b6:	e2 08 00 08 	add	r8,r1,r8
800079ba:	10 39       	cp.w	r9,r8
800079bc:	c0 71       	brne	800079ca <_realloc_r+0x20a>
800079be:	72 13       	ld.w	r3,r9[0x4]
800079c0:	02 97       	mov	r7,r1
800079c2:	e0 13 ff fc 	andl	r3,0xfffc
800079c6:	00 03       	add	r3,r0
800079c8:	c3 08       	rjmp	80007a28 <_realloc_r+0x268>
800079ca:	e0 ca 00 04 	sub	r10,r0,4
800079ce:	e0 4a 00 24 	cp.w	r10,36
800079d2:	e0 8b 00 20 	brhi	80007a12 <_realloc_r+0x252>
800079d6:	08 99       	mov	r9,r4
800079d8:	18 98       	mov	r8,r12
800079da:	59 3a       	cp.w	r10,19
800079dc:	e0 88 00 14 	brls	80007a04 <_realloc_r+0x244>
800079e0:	13 0b       	ld.w	r11,r9++
800079e2:	10 ab       	st.w	r8++,r11
800079e4:	13 0b       	ld.w	r11,r9++
800079e6:	10 ab       	st.w	r8++,r11
800079e8:	59 ba       	cp.w	r10,27
800079ea:	e0 88 00 0d 	brls	80007a04 <_realloc_r+0x244>
800079ee:	13 0b       	ld.w	r11,r9++
800079f0:	10 ab       	st.w	r8++,r11
800079f2:	13 0b       	ld.w	r11,r9++
800079f4:	10 ab       	st.w	r8++,r11
800079f6:	e0 4a 00 24 	cp.w	r10,36
800079fa:	c0 51       	brne	80007a04 <_realloc_r+0x244>
800079fc:	13 0a       	ld.w	r10,r9++
800079fe:	10 aa       	st.w	r8++,r10
80007a00:	13 0a       	ld.w	r10,r9++
80007a02:	10 aa       	st.w	r8++,r10
80007a04:	13 0a       	ld.w	r10,r9++
80007a06:	10 aa       	st.w	r8++,r10
80007a08:	72 0a       	ld.w	r10,r9[0x0]
80007a0a:	91 0a       	st.w	r8[0x0],r10
80007a0c:	72 19       	ld.w	r9,r9[0x4]
80007a0e:	91 19       	st.w	r8[0x4],r9
80007a10:	c0 48       	rjmp	80007a18 <_realloc_r+0x258>
80007a12:	08 9b       	mov	r11,r4
80007a14:	e0 a0 1d 07 	rcall	8000b422 <memmove>
80007a18:	08 9b       	mov	r11,r4
80007a1a:	04 9c       	mov	r12,r2
80007a1c:	e0 a0 1a 60 	rcall	8000aedc <_free_r>
80007a20:	04 9c       	mov	r12,r2
80007a22:	c2 a8       	rjmp	80007a76 <_realloc_r+0x2b6>
80007a24:	00 93       	mov	r3,r0
80007a26:	02 97       	mov	r7,r1
80007a28:	e6 06 01 09 	sub	r9,r3,r6
80007a2c:	6e 18       	ld.w	r8,r7[0x4]
80007a2e:	58 f9       	cp.w	r9,15
80007a30:	e0 88 00 16 	brls	80007a5c <_realloc_r+0x29c>
80007a34:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007a38:	ed e8 10 08 	or	r8,r6,r8
80007a3c:	8f 18       	st.w	r7[0x4],r8
80007a3e:	12 98       	mov	r8,r9
80007a40:	a1 a8       	sbr	r8,0x0
80007a42:	ee 06 00 0b 	add	r11,r7,r6
80007a46:	f6 09 00 09 	add	r9,r11,r9
80007a4a:	97 18       	st.w	r11[0x4],r8
80007a4c:	72 18       	ld.w	r8,r9[0x4]
80007a4e:	a1 a8       	sbr	r8,0x0
80007a50:	2f 8b       	sub	r11,-8
80007a52:	93 18       	st.w	r9[0x4],r8
80007a54:	04 9c       	mov	r12,r2
80007a56:	e0 a0 1a 43 	rcall	8000aedc <_free_r>
80007a5a:	c0 b8       	rjmp	80007a70 <_realloc_r+0x2b0>
80007a5c:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007a60:	e7 e8 10 08 	or	r8,r3,r8
80007a64:	8f 18       	st.w	r7[0x4],r8
80007a66:	ee 03 00 03 	add	r3,r7,r3
80007a6a:	66 18       	ld.w	r8,r3[0x4]
80007a6c:	a1 a8       	sbr	r8,0x0
80007a6e:	87 18       	st.w	r3[0x4],r8
80007a70:	04 9c       	mov	r12,r2
80007a72:	ee c5 ff f8 	sub	r5,r7,-8
80007a76:	fe b0 f1 9d 	rcall	80005db0 <__malloc_unlock>
80007a7a:	0a 9c       	mov	r12,r5
80007a7c:	2f fd       	sub	sp,-4
80007a7e:	d8 32       	popm	r0-r7,pc

80007a80 <_sbrk_r>:
80007a80:	d4 21       	pushm	r4-r7,lr
80007a82:	30 08       	mov	r8,0
80007a84:	18 97       	mov	r7,r12
80007a86:	e0 66 bf f0 	mov	r6,49136
80007a8a:	16 9c       	mov	r12,r11
80007a8c:	8d 08       	st.w	r6[0x0],r8
80007a8e:	c8 5c       	rcall	80007b98 <_sbrk>
80007a90:	5b fc       	cp.w	r12,-1
80007a92:	c0 51       	brne	80007a9c <_sbrk_r+0x1c>
80007a94:	6c 08       	ld.w	r8,r6[0x0]
80007a96:	58 08       	cp.w	r8,0
80007a98:	ef f8 1a 03 	st.wne	r7[0xc],r8
80007a9c:	d8 22       	popm	r4-r7,pc
80007a9e:	d7 03       	nop

80007aa0 <sprintf>:
80007aa0:	d4 01       	pushm	lr
80007aa2:	21 7d       	sub	sp,92
80007aa4:	e0 68 ff ff 	mov	r8,65535
80007aa8:	ea 18 7f ff 	orh	r8,0x7fff
80007aac:	50 58       	stdsp	sp[0x14],r8
80007aae:	50 28       	stdsp	sp[0x8],r8
80007ab0:	e0 68 02 08 	mov	r8,520
80007ab4:	ba 68       	st.h	sp[0xc],r8
80007ab6:	3f f8       	mov	r8,-1
80007ab8:	ba 78       	st.h	sp[0xe],r8
80007aba:	e0 68 0a 3c 	mov	r8,2620
80007abe:	50 4c       	stdsp	sp[0x10],r12
80007ac0:	16 9a       	mov	r10,r11
80007ac2:	50 0c       	stdsp	sp[0x0],r12
80007ac4:	fa c9 ff a0 	sub	r9,sp,-96
80007ac8:	70 0c       	ld.w	r12,r8[0x0]
80007aca:	1a 9b       	mov	r11,sp
80007acc:	e0 a0 02 1a 	rcall	80007f00 <_vfprintf_r>
80007ad0:	30 09       	mov	r9,0
80007ad2:	40 08       	lddsp	r8,sp[0x0]
80007ad4:	b0 89       	st.b	r8[0x0],r9
80007ad6:	2e 9d       	sub	sp,-92
80007ad8:	d8 02       	popm	pc
80007ada:	d7 03       	nop

80007adc <strncpy>:
80007adc:	30 08       	mov	r8,0
80007ade:	10 3a       	cp.w	r10,r8
80007ae0:	5e 0c       	reteq	r12
80007ae2:	f6 08 07 09 	ld.ub	r9,r11[r8]
80007ae6:	f8 08 0b 09 	st.b	r12[r8],r9
80007aea:	2f f8       	sub	r8,-1
80007aec:	58 09       	cp.w	r9,0
80007aee:	cf 81       	brne	80007ade <strncpy+0x2>
80007af0:	10 3a       	cp.w	r10,r8
80007af2:	5e 0c       	reteq	r12
80007af4:	f8 08 0b 09 	st.b	r12[r8],r9
80007af8:	2f f8       	sub	r8,-1
80007afa:	cf bb       	rjmp	80007af0 <strncpy+0x14>

80007afc <_close>:
80007afc:	30 28       	mov	r8,2
80007afe:	d6 73       	breakpoint
80007b00:	3f fc       	mov	r12,-1
80007b02:	35 8b       	mov	r11,88
80007b04:	58 0c       	cp.w	r12,0
80007b06:	5e 4c       	retge	r12
80007b08:	e0 6a bf f0 	mov	r10,49136
80007b0c:	95 0b       	st.w	r10[0x0],r11
80007b0e:	5e fc       	retal	r12

80007b10 <_lseek>:
80007b10:	30 58       	mov	r8,5
80007b12:	d6 73       	breakpoint
80007b14:	3f fc       	mov	r12,-1
80007b16:	35 8b       	mov	r11,88
80007b18:	58 0c       	cp.w	r12,0
80007b1a:	5e 4c       	retge	r12
80007b1c:	e0 6a bf f0 	mov	r10,49136
80007b20:	95 0b       	st.w	r10[0x0],r11
80007b22:	5e fc       	retal	r12

80007b24 <isatty>:
80007b24:	30 b8       	mov	r8,11
80007b26:	d6 73       	breakpoint
80007b28:	3f fc       	mov	r12,-1
80007b2a:	35 8b       	mov	r11,88
80007b2c:	58 0c       	cp.w	r12,0
80007b2e:	5e 4c       	retge	r12
80007b30:	e0 6a bf f0 	mov	r10,49136
80007b34:	95 0b       	st.w	r10[0x0],r11
80007b36:	5e fc       	retal	r12

80007b38 <_fstat_host>:
80007b38:	30 98       	mov	r8,9
80007b3a:	d6 73       	breakpoint
80007b3c:	3f fc       	mov	r12,-1
80007b3e:	35 8b       	mov	r11,88
80007b40:	58 0c       	cp.w	r12,0
80007b42:	5e 4c       	retge	r12
80007b44:	e0 6a bf f0 	mov	r10,49136
80007b48:	95 0b       	st.w	r10[0x0],r11
80007b4a:	5e fc       	retal	r12

80007b4c <_fstat>:
80007b4c:	d4 21       	pushm	r4-r7,lr
80007b4e:	21 0d       	sub	sp,64
80007b50:	16 97       	mov	r7,r11
80007b52:	1a 9b       	mov	r11,sp
80007b54:	cf 2f       	rcall	80007b38 <_fstat_host>
80007b56:	c0 34       	brge	80007b5c <_fstat+0x10>
80007b58:	3f fc       	mov	r12,-1
80007b5a:	c1 c8       	rjmp	80007b92 <_fstat+0x46>
80007b5c:	40 08       	lddsp	r8,sp[0x0]
80007b5e:	ae 08       	st.h	r7[0x0],r8
80007b60:	40 18       	lddsp	r8,sp[0x4]
80007b62:	ae 18       	st.h	r7[0x2],r8
80007b64:	40 28       	lddsp	r8,sp[0x8]
80007b66:	8f 18       	st.w	r7[0x4],r8
80007b68:	40 38       	lddsp	r8,sp[0xc]
80007b6a:	ae 48       	st.h	r7[0x8],r8
80007b6c:	40 48       	lddsp	r8,sp[0x10]
80007b6e:	ae 58       	st.h	r7[0xa],r8
80007b70:	40 58       	lddsp	r8,sp[0x14]
80007b72:	ae 68       	st.h	r7[0xc],r8
80007b74:	40 68       	lddsp	r8,sp[0x18]
80007b76:	ae 78       	st.h	r7[0xe],r8
80007b78:	40 88       	lddsp	r8,sp[0x20]
80007b7a:	8f 48       	st.w	r7[0x10],r8
80007b7c:	40 a8       	lddsp	r8,sp[0x28]
80007b7e:	8f b8       	st.w	r7[0x2c],r8
80007b80:	40 c8       	lddsp	r8,sp[0x30]
80007b82:	8f c8       	st.w	r7[0x30],r8
80007b84:	40 d8       	lddsp	r8,sp[0x34]
80007b86:	8f 58       	st.w	r7[0x14],r8
80007b88:	40 e8       	lddsp	r8,sp[0x38]
80007b8a:	30 0c       	mov	r12,0
80007b8c:	8f 78       	st.w	r7[0x1c],r8
80007b8e:	40 f8       	lddsp	r8,sp[0x3c]
80007b90:	8f 98       	st.w	r7[0x24],r8
80007b92:	2f 0d       	sub	sp,-64
80007b94:	d8 22       	popm	r4-r7,pc
80007b96:	d7 03       	nop

80007b98 <_sbrk>:
80007b98:	d4 01       	pushm	lr
80007b9a:	e0 68 0d 90 	mov	r8,3472
80007b9e:	70 09       	ld.w	r9,r8[0x0]
80007ba0:	58 09       	cp.w	r9,0
80007ba2:	c0 41       	brne	80007baa <_sbrk+0x12>
80007ba4:	e0 69 bf f8 	mov	r9,49144
80007ba8:	91 09       	st.w	r8[0x0],r9
80007baa:	e0 69 0d 90 	mov	r9,3472
80007bae:	e0 7a 70 00 	mov	r10,94208
80007bb2:	72 08       	ld.w	r8,r9[0x0]
80007bb4:	f0 0c 00 0c 	add	r12,r8,r12
80007bb8:	14 3c       	cp.w	r12,r10
80007bba:	e0 8b 00 04 	brhi	80007bc2 <_sbrk+0x2a>
80007bbe:	93 0c       	st.w	r9[0x0],r12
80007bc0:	c0 68       	rjmp	80007bcc <_sbrk+0x34>
80007bc2:	e0 a0 18 15 	rcall	8000abec <__errno>
80007bc6:	30 c8       	mov	r8,12
80007bc8:	99 08       	st.w	r12[0x0],r8
80007bca:	3f f8       	mov	r8,-1
80007bcc:	10 9c       	mov	r12,r8
80007bce:	d8 02       	popm	pc

80007bd0 <get_arg>:
80007bd0:	d4 31       	pushm	r0-r7,lr
80007bd2:	20 8d       	sub	sp,32
80007bd4:	fa c4 ff bc 	sub	r4,sp,-68
80007bd8:	50 4b       	stdsp	sp[0x10],r11
80007bda:	68 2e       	ld.w	lr,r4[0x8]
80007bdc:	50 58       	stdsp	sp[0x14],r8
80007bde:	12 96       	mov	r6,r9
80007be0:	7c 0b       	ld.w	r11,lr[0x0]
80007be2:	70 05       	ld.w	r5,r8[0x0]
80007be4:	50 6e       	stdsp	sp[0x18],lr
80007be6:	58 0b       	cp.w	r11,0
80007be8:	f4 0b 17 00 	moveq	r11,r10
80007bec:	68 03       	ld.w	r3,r4[0x0]
80007bee:	68 11       	ld.w	r1,r4[0x4]
80007bf0:	40 49       	lddsp	r9,sp[0x10]
80007bf2:	30 08       	mov	r8,0
80007bf4:	c2 89       	rjmp	80007e44 <get_arg+0x274>
80007bf6:	2f fb       	sub	r11,-1
80007bf8:	32 5c       	mov	r12,37
80007bfa:	17 8a       	ld.ub	r10,r11[0x0]
80007bfc:	f8 0a 18 00 	cp.b	r10,r12
80007c00:	5f 1e       	srne	lr
80007c02:	f0 0a 18 00 	cp.b	r10,r8
80007c06:	5f 1c       	srne	r12
80007c08:	fd ec 00 0c 	and	r12,lr,r12
80007c0c:	f0 0c 18 00 	cp.b	r12,r8
80007c10:	cf 31       	brne	80007bf6 <get_arg+0x26>
80007c12:	58 0a       	cp.w	r10,0
80007c14:	e0 80 01 25 	breq	80007e5e <get_arg+0x28e>
80007c18:	30 0c       	mov	r12,0
80007c1a:	3f fa       	mov	r10,-1
80007c1c:	18 90       	mov	r0,r12
80007c1e:	50 3a       	stdsp	sp[0xc],r10
80007c20:	18 94       	mov	r4,r12
80007c22:	18 92       	mov	r2,r12
80007c24:	f8 0c 00 3c 	add	r12,r12,r12<<0x3
80007c28:	16 97       	mov	r7,r11
80007c2a:	50 7c       	stdsp	sp[0x1c],r12
80007c2c:	fe cc 9e 28 	sub	r12,pc,-25048
80007c30:	0f 3a       	ld.ub	r10,r7++
80007c32:	f8 0a 07 0e 	ld.ub	lr,r12[r10]
80007c36:	40 7c       	lddsp	r12,sp[0x1c]
80007c38:	1c 0c       	add	r12,lr
80007c3a:	fe ce 9e fe 	sub	lr,pc,-24834
80007c3e:	fc 0c 07 0e 	ld.ub	lr,lr[r12]
80007c42:	20 1e       	sub	lr,1
80007c44:	50 0e       	stdsp	sp[0x0],lr
80007c46:	fe ce 9f 76 	sub	lr,pc,-24714
80007c4a:	fc 0c 07 0c 	ld.ub	r12,lr[r12]
80007c4e:	50 7c       	stdsp	sp[0x1c],r12
80007c50:	40 0c       	lddsp	r12,sp[0x0]
80007c52:	58 7c       	cp.w	r12,7
80007c54:	e0 8b 00 f1 	brhi	80007e36 <get_arg+0x266>
80007c58:	fe ce a1 28 	sub	lr,pc,-24280
80007c5c:	fc 0c 03 2f 	ld.w	pc,lr[r12<<0x2]
80007c60:	36 8b       	mov	r11,104
80007c62:	f6 0a 18 00 	cp.b	r10,r11
80007c66:	e0 80 00 e8 	breq	80007e36 <get_arg+0x266>
80007c6a:	37 1b       	mov	r11,113
80007c6c:	f6 0a 18 00 	cp.b	r10,r11
80007c70:	c0 70       	breq	80007c7e <get_arg+0xae>
80007c72:	34 cb       	mov	r11,76
80007c74:	f6 0a 18 00 	cp.b	r10,r11
80007c78:	c0 51       	brne	80007c82 <get_arg+0xb2>
80007c7a:	a3 b4       	sbr	r4,0x3
80007c7c:	cd d8       	rjmp	80007e36 <get_arg+0x266>
80007c7e:	a5 b4       	sbr	r4,0x5
80007c80:	cd b8       	rjmp	80007e36 <get_arg+0x266>
80007c82:	08 9a       	mov	r10,r4
80007c84:	0e 9b       	mov	r11,r7
80007c86:	a5 aa       	sbr	r10,0x4
80007c88:	17 3c       	ld.ub	r12,r11++
80007c8a:	a5 b4       	sbr	r4,0x5
80007c8c:	36 ce       	mov	lr,108
80007c8e:	fc 0c 18 00 	cp.b	r12,lr
80007c92:	e0 80 00 d3 	breq	80007e38 <get_arg+0x268>
80007c96:	14 94       	mov	r4,r10
80007c98:	cc f8       	rjmp	80007e36 <get_arg+0x266>
80007c9a:	eb d5 c0 05 	bfextu	r5,r5,0x0,0x5
80007c9e:	36 7c       	mov	r12,103
80007ca0:	f8 0a 18 00 	cp.b	r10,r12
80007ca4:	e0 8b 00 27 	brhi	80007cf2 <get_arg+0x122>
80007ca8:	36 5b       	mov	r11,101
80007caa:	f6 0a 18 00 	cp.b	r10,r11
80007cae:	c4 82       	brcc	80007d3e <get_arg+0x16e>
80007cb0:	34 fb       	mov	r11,79
80007cb2:	f6 0a 18 00 	cp.b	r10,r11
80007cb6:	c4 80       	breq	80007d46 <get_arg+0x176>
80007cb8:	e0 8b 00 0c 	brhi	80007cd0 <get_arg+0x100>
80007cbc:	34 5b       	mov	r11,69
80007cbe:	f6 0a 18 00 	cp.b	r10,r11
80007cc2:	c3 e0       	breq	80007d3e <get_arg+0x16e>
80007cc4:	34 7b       	mov	r11,71
80007cc6:	f6 0a 18 00 	cp.b	r10,r11
80007cca:	c3 a0       	breq	80007d3e <get_arg+0x16e>
80007ccc:	34 4b       	mov	r11,68
80007cce:	c0 88       	rjmp	80007cde <get_arg+0x10e>
80007cd0:	35 8b       	mov	r11,88
80007cd2:	f6 0a 18 00 	cp.b	r10,r11
80007cd6:	c2 c0       	breq	80007d2e <get_arg+0x15e>
80007cd8:	e0 8b 00 07 	brhi	80007ce6 <get_arg+0x116>
80007cdc:	35 5b       	mov	r11,85
80007cde:	f6 0a 18 00 	cp.b	r10,r11
80007ce2:	c3 51       	brne	80007d4c <get_arg+0x17c>
80007ce4:	c3 18       	rjmp	80007d46 <get_arg+0x176>
80007ce6:	36 3b       	mov	r11,99
80007ce8:	f6 0a 18 00 	cp.b	r10,r11
80007cec:	c2 f0       	breq	80007d4a <get_arg+0x17a>
80007cee:	36 4b       	mov	r11,100
80007cf0:	c0 e8       	rjmp	80007d0c <get_arg+0x13c>
80007cf2:	37 0b       	mov	r11,112
80007cf4:	f6 0a 18 00 	cp.b	r10,r11
80007cf8:	c2 50       	breq	80007d42 <get_arg+0x172>
80007cfa:	e0 8b 00 0d 	brhi	80007d14 <get_arg+0x144>
80007cfe:	36 eb       	mov	r11,110
80007d00:	f6 0a 18 00 	cp.b	r10,r11
80007d04:	c1 f0       	breq	80007d42 <get_arg+0x172>
80007d06:	e0 8b 00 14 	brhi	80007d2e <get_arg+0x15e>
80007d0a:	36 9b       	mov	r11,105
80007d0c:	f6 0a 18 00 	cp.b	r10,r11
80007d10:	c1 e1       	brne	80007d4c <get_arg+0x17c>
80007d12:	c0 e8       	rjmp	80007d2e <get_arg+0x15e>
80007d14:	37 5b       	mov	r11,117
80007d16:	f6 0a 18 00 	cp.b	r10,r11
80007d1a:	c0 a0       	breq	80007d2e <get_arg+0x15e>
80007d1c:	37 8b       	mov	r11,120
80007d1e:	f6 0a 18 00 	cp.b	r10,r11
80007d22:	c0 60       	breq	80007d2e <get_arg+0x15e>
80007d24:	37 3b       	mov	r11,115
80007d26:	f6 0a 18 00 	cp.b	r10,r11
80007d2a:	c1 11       	brne	80007d4c <get_arg+0x17c>
80007d2c:	c0 b8       	rjmp	80007d42 <get_arg+0x172>
80007d2e:	ed b4 00 04 	bld	r4,0x4
80007d32:	c0 a0       	breq	80007d46 <get_arg+0x176>
80007d34:	ed b4 00 05 	bld	r4,0x5
80007d38:	c0 91       	brne	80007d4a <get_arg+0x17a>
80007d3a:	30 20       	mov	r0,2
80007d3c:	c0 88       	rjmp	80007d4c <get_arg+0x17c>
80007d3e:	30 40       	mov	r0,4
80007d40:	c0 68       	rjmp	80007d4c <get_arg+0x17c>
80007d42:	30 30       	mov	r0,3
80007d44:	c0 48       	rjmp	80007d4c <get_arg+0x17c>
80007d46:	30 10       	mov	r0,1
80007d48:	c0 28       	rjmp	80007d4c <get_arg+0x17c>
80007d4a:	30 00       	mov	r0,0
80007d4c:	40 3b       	lddsp	r11,sp[0xc]
80007d4e:	5b fb       	cp.w	r11,-1
80007d50:	c0 40       	breq	80007d58 <get_arg+0x188>
80007d52:	e2 0b 09 20 	st.w	r1[r11<<0x2],r0
80007d56:	c7 08       	rjmp	80007e36 <get_arg+0x266>
80007d58:	58 60       	cp.w	r0,6
80007d5a:	e0 8b 00 6e 	brhi	80007e36 <get_arg+0x266>
80007d5e:	6c 0a       	ld.w	r10,r6[0x0]
80007d60:	ea cc ff ff 	sub	r12,r5,-1
80007d64:	fe ce a2 14 	sub	lr,pc,-24044
80007d68:	fc 00 03 2f 	ld.w	pc,lr[r0<<0x2]
80007d6c:	f4 cb ff f8 	sub	r11,r10,-8
80007d70:	8d 0b       	st.w	r6[0x0],r11
80007d72:	f4 ea 00 00 	ld.d	r10,r10[0]
80007d76:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80007d7a:	c0 f8       	rjmp	80007d98 <get_arg+0x1c8>
80007d7c:	f4 cb ff fc 	sub	r11,r10,-4
80007d80:	8d 0b       	st.w	r6[0x0],r11
80007d82:	74 0a       	ld.w	r10,r10[0x0]
80007d84:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80007d88:	c0 88       	rjmp	80007d98 <get_arg+0x1c8>
80007d8a:	f4 cb ff f8 	sub	r11,r10,-8
80007d8e:	8d 0b       	st.w	r6[0x0],r11
80007d90:	f4 ea 00 00 	ld.d	r10,r10[0]
80007d94:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80007d98:	0e 9b       	mov	r11,r7
80007d9a:	18 95       	mov	r5,r12
80007d9c:	c4 e8       	rjmp	80007e38 <get_arg+0x268>
80007d9e:	62 0a       	ld.w	r10,r1[0x0]
80007da0:	5b fa       	cp.w	r10,-1
80007da2:	c0 b1       	brne	80007db8 <get_arg+0x1e8>
80007da4:	50 19       	stdsp	sp[0x4],r9
80007da6:	50 28       	stdsp	sp[0x8],r8
80007da8:	e0 6a 00 80 	mov	r10,128
80007dac:	30 0b       	mov	r11,0
80007dae:	02 9c       	mov	r12,r1
80007db0:	fe b0 fd 00 	rcall	800077b0 <memset>
80007db4:	40 28       	lddsp	r8,sp[0x8]
80007db6:	40 19       	lddsp	r9,sp[0x4]
80007db8:	e4 cc 00 01 	sub	r12,r2,1
80007dbc:	0e 9b       	mov	r11,r7
80007dbe:	50 3c       	stdsp	sp[0xc],r12
80007dc0:	f2 0c 0c 49 	max	r9,r9,r12
80007dc4:	c3 a8       	rjmp	80007e38 <get_arg+0x268>
80007dc6:	62 0a       	ld.w	r10,r1[0x0]
80007dc8:	5b fa       	cp.w	r10,-1
80007dca:	c0 b1       	brne	80007de0 <get_arg+0x210>
80007dcc:	50 19       	stdsp	sp[0x4],r9
80007dce:	50 28       	stdsp	sp[0x8],r8
80007dd0:	e0 6a 00 80 	mov	r10,128
80007dd4:	30 0b       	mov	r11,0
80007dd6:	02 9c       	mov	r12,r1
80007dd8:	fe b0 fc ec 	rcall	800077b0 <memset>
80007ddc:	40 28       	lddsp	r8,sp[0x8]
80007dde:	40 19       	lddsp	r9,sp[0x4]
80007de0:	20 12       	sub	r2,1
80007de2:	30 0a       	mov	r10,0
80007de4:	0e 9b       	mov	r11,r7
80007de6:	e2 02 09 2a 	st.w	r1[r2<<0x2],r10
80007dea:	f2 02 0c 49 	max	r9,r9,r2
80007dee:	c2 58       	rjmp	80007e38 <get_arg+0x268>
80007df0:	16 97       	mov	r7,r11
80007df2:	6c 0a       	ld.w	r10,r6[0x0]
80007df4:	f4 cb ff fc 	sub	r11,r10,-4
80007df8:	8d 0b       	st.w	r6[0x0],r11
80007dfa:	74 0a       	ld.w	r10,r10[0x0]
80007dfc:	0e 9b       	mov	r11,r7
80007dfe:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80007e02:	2f f5       	sub	r5,-1
80007e04:	c1 a8       	rjmp	80007e38 <get_arg+0x268>
80007e06:	f4 c2 00 30 	sub	r2,r10,48
80007e0a:	c0 68       	rjmp	80007e16 <get_arg+0x246>
80007e0c:	e4 02 00 22 	add	r2,r2,r2<<0x2
80007e10:	2f f7       	sub	r7,-1
80007e12:	f4 02 00 12 	add	r2,r10,r2<<0x1
80007e16:	0f 8a       	ld.ub	r10,r7[0x0]
80007e18:	58 0a       	cp.w	r10,0
80007e1a:	c0 e0       	breq	80007e36 <get_arg+0x266>
80007e1c:	23 0a       	sub	r10,48
80007e1e:	58 9a       	cp.w	r10,9
80007e20:	fe 98 ff f6 	brls	80007e0c <get_arg+0x23c>
80007e24:	c0 98       	rjmp	80007e36 <get_arg+0x266>
80007e26:	2f f7       	sub	r7,-1
80007e28:	0f 8a       	ld.ub	r10,r7[0x0]
80007e2a:	58 0a       	cp.w	r10,0
80007e2c:	c0 50       	breq	80007e36 <get_arg+0x266>
80007e2e:	23 0a       	sub	r10,48
80007e30:	58 9a       	cp.w	r10,9
80007e32:	fe 98 ff fa 	brls	80007e26 <get_arg+0x256>
80007e36:	0e 9b       	mov	r11,r7
80007e38:	40 7c       	lddsp	r12,sp[0x1c]
80007e3a:	30 ba       	mov	r10,11
80007e3c:	f4 0c 18 00 	cp.b	r12,r10
80007e40:	fe 91 fe f2 	brne	80007c24 <get_arg+0x54>
80007e44:	40 42       	lddsp	r2,sp[0x10]
80007e46:	17 8c       	ld.ub	r12,r11[0x0]
80007e48:	0a 32       	cp.w	r2,r5
80007e4a:	5f 4a       	srge	r10
80007e4c:	f0 0c 18 00 	cp.b	r12,r8
80007e50:	5f 1c       	srne	r12
80007e52:	f9 ea 00 0a 	and	r10,r12,r10
80007e56:	f0 0a 18 00 	cp.b	r10,r8
80007e5a:	fe 91 fe cf 	brne	80007bf8 <get_arg+0x28>
80007e5e:	30 08       	mov	r8,0
80007e60:	40 4e       	lddsp	lr,sp[0x10]
80007e62:	17 8a       	ld.ub	r10,r11[0x0]
80007e64:	e2 05 00 21 	add	r1,r1,r5<<0x2
80007e68:	f0 0a 18 00 	cp.b	r10,r8
80007e6c:	fc 09 17 10 	movne	r9,lr
80007e70:	e6 05 00 38 	add	r8,r3,r5<<0x3
80007e74:	06 9e       	mov	lr,r3
80007e76:	c2 a8       	rjmp	80007eca <get_arg+0x2fa>
80007e78:	62 0a       	ld.w	r10,r1[0x0]
80007e7a:	58 3a       	cp.w	r10,3
80007e7c:	c1 e0       	breq	80007eb8 <get_arg+0x2e8>
80007e7e:	e0 89 00 07 	brgt	80007e8c <get_arg+0x2bc>
80007e82:	58 1a       	cp.w	r10,1
80007e84:	c1 a0       	breq	80007eb8 <get_arg+0x2e8>
80007e86:	58 2a       	cp.w	r10,2
80007e88:	c1 81       	brne	80007eb8 <get_arg+0x2e8>
80007e8a:	c0 58       	rjmp	80007e94 <get_arg+0x2c4>
80007e8c:	58 5a       	cp.w	r10,5
80007e8e:	c0 c0       	breq	80007ea6 <get_arg+0x2d6>
80007e90:	c0 b5       	brlt	80007ea6 <get_arg+0x2d6>
80007e92:	c1 38       	rjmp	80007eb8 <get_arg+0x2e8>
80007e94:	6c 0a       	ld.w	r10,r6[0x0]
80007e96:	f4 cc ff f8 	sub	r12,r10,-8
80007e9a:	8d 0c       	st.w	r6[0x0],r12
80007e9c:	f4 e2 00 00 	ld.d	r2,r10[0]
80007ea0:	f0 e3 00 00 	st.d	r8[0],r2
80007ea4:	c1 08       	rjmp	80007ec4 <get_arg+0x2f4>
80007ea6:	6c 0a       	ld.w	r10,r6[0x0]
80007ea8:	f4 cc ff f8 	sub	r12,r10,-8
80007eac:	8d 0c       	st.w	r6[0x0],r12
80007eae:	f4 e2 00 00 	ld.d	r2,r10[0]
80007eb2:	f0 e3 00 00 	st.d	r8[0],r2
80007eb6:	c0 78       	rjmp	80007ec4 <get_arg+0x2f4>
80007eb8:	6c 0a       	ld.w	r10,r6[0x0]
80007eba:	f4 cc ff fc 	sub	r12,r10,-4
80007ebe:	8d 0c       	st.w	r6[0x0],r12
80007ec0:	74 0a       	ld.w	r10,r10[0x0]
80007ec2:	91 0a       	st.w	r8[0x0],r10
80007ec4:	2f f5       	sub	r5,-1
80007ec6:	2f 88       	sub	r8,-8
80007ec8:	2f c1       	sub	r1,-4
80007eca:	12 35       	cp.w	r5,r9
80007ecc:	fe 9a ff d6 	brle	80007e78 <get_arg+0x2a8>
80007ed0:	1c 93       	mov	r3,lr
80007ed2:	40 52       	lddsp	r2,sp[0x14]
80007ed4:	40 6e       	lddsp	lr,sp[0x18]
80007ed6:	85 05       	st.w	r2[0x0],r5
80007ed8:	9d 0b       	st.w	lr[0x0],r11
80007eda:	40 4b       	lddsp	r11,sp[0x10]
80007edc:	e6 0b 00 3c 	add	r12,r3,r11<<0x3
80007ee0:	2f 8d       	sub	sp,-32
80007ee2:	d8 32       	popm	r0-r7,pc

80007ee4 <__sprint_r>:
80007ee4:	d4 21       	pushm	r4-r7,lr
80007ee6:	14 97       	mov	r7,r10
80007ee8:	74 28       	ld.w	r8,r10[0x8]
80007eea:	58 08       	cp.w	r8,0
80007eec:	c0 41       	brne	80007ef4 <__sprint_r+0x10>
80007eee:	95 18       	st.w	r10[0x4],r8
80007ef0:	10 9c       	mov	r12,r8
80007ef2:	d8 22       	popm	r4-r7,pc
80007ef4:	e0 a0 18 ba 	rcall	8000b068 <__sfvwrite_r>
80007ef8:	30 08       	mov	r8,0
80007efa:	8f 18       	st.w	r7[0x4],r8
80007efc:	8f 28       	st.w	r7[0x8],r8
80007efe:	d8 22       	popm	r4-r7,pc

80007f00 <_vfprintf_r>:
80007f00:	d4 31       	pushm	r0-r7,lr
80007f02:	fa cd 06 bc 	sub	sp,sp,1724
80007f06:	51 09       	stdsp	sp[0x40],r9
80007f08:	16 91       	mov	r1,r11
80007f0a:	14 97       	mov	r7,r10
80007f0c:	18 95       	mov	r5,r12
80007f0e:	e0 a0 1a 1d 	rcall	8000b348 <_localeconv_r>
80007f12:	78 0c       	ld.w	r12,r12[0x0]
80007f14:	50 cc       	stdsp	sp[0x30],r12
80007f16:	58 05       	cp.w	r5,0
80007f18:	c0 70       	breq	80007f26 <_vfprintf_r+0x26>
80007f1a:	6a 68       	ld.w	r8,r5[0x18]
80007f1c:	58 08       	cp.w	r8,0
80007f1e:	c0 41       	brne	80007f26 <_vfprintf_r+0x26>
80007f20:	0a 9c       	mov	r12,r5
80007f22:	e0 a0 17 43 	rcall	8000ada8 <__sinit>
80007f26:	fe c8 a0 12 	sub	r8,pc,-24558
80007f2a:	10 31       	cp.w	r1,r8
80007f2c:	c0 31       	brne	80007f32 <_vfprintf_r+0x32>
80007f2e:	6a 01       	ld.w	r1,r5[0x0]
80007f30:	c0 c8       	rjmp	80007f48 <_vfprintf_r+0x48>
80007f32:	fe c8 9f fe 	sub	r8,pc,-24578
80007f36:	10 31       	cp.w	r1,r8
80007f38:	c0 31       	brne	80007f3e <_vfprintf_r+0x3e>
80007f3a:	6a 11       	ld.w	r1,r5[0x4]
80007f3c:	c0 68       	rjmp	80007f48 <_vfprintf_r+0x48>
80007f3e:	fe c8 9f ea 	sub	r8,pc,-24598
80007f42:	10 31       	cp.w	r1,r8
80007f44:	eb f1 00 02 	ld.weq	r1,r5[0x8]
80007f48:	82 68       	ld.sh	r8,r1[0xc]
80007f4a:	ed b8 00 03 	bld	r8,0x3
80007f4e:	c0 41       	brne	80007f56 <_vfprintf_r+0x56>
80007f50:	62 48       	ld.w	r8,r1[0x10]
80007f52:	58 08       	cp.w	r8,0
80007f54:	c0 71       	brne	80007f62 <_vfprintf_r+0x62>
80007f56:	02 9b       	mov	r11,r1
80007f58:	0a 9c       	mov	r12,r5
80007f5a:	e0 a0 0f 5d 	rcall	80009e14 <__swsetup_r>
80007f5e:	e0 81 0f 54 	brne	80009e06 <_vfprintf_r+0x1f06>
80007f62:	82 68       	ld.sh	r8,r1[0xc]
80007f64:	10 99       	mov	r9,r8
80007f66:	e2 19 00 1a 	andl	r9,0x1a,COH
80007f6a:	58 a9       	cp.w	r9,10
80007f6c:	c3 c1       	brne	80007fe4 <_vfprintf_r+0xe4>
80007f6e:	82 79       	ld.sh	r9,r1[0xe]
80007f70:	30 0a       	mov	r10,0
80007f72:	f4 09 19 00 	cp.h	r9,r10
80007f76:	c3 75       	brlt	80007fe4 <_vfprintf_r+0xe4>
80007f78:	a1 d8       	cbr	r8,0x1
80007f7a:	fb 58 05 d0 	st.h	sp[1488],r8
80007f7e:	62 88       	ld.w	r8,r1[0x20]
80007f80:	fb 48 05 e4 	st.w	sp[1508],r8
80007f84:	62 a8       	ld.w	r8,r1[0x28]
80007f86:	fb 48 05 ec 	st.w	sp[1516],r8
80007f8a:	fa c8 ff bc 	sub	r8,sp,-68
80007f8e:	fb 48 05 d4 	st.w	sp[1492],r8
80007f92:	fb 48 05 c4 	st.w	sp[1476],r8
80007f96:	e0 68 04 00 	mov	r8,1024
80007f9a:	fb 48 05 d8 	st.w	sp[1496],r8
80007f9e:	fb 48 05 cc 	st.w	sp[1484],r8
80007fa2:	30 08       	mov	r8,0
80007fa4:	fb 59 05 d2 	st.h	sp[1490],r9
80007fa8:	0e 9a       	mov	r10,r7
80007faa:	41 09       	lddsp	r9,sp[0x40]
80007fac:	fa c7 fa 3c 	sub	r7,sp,-1476
80007fb0:	fb 48 05 dc 	st.w	sp[1500],r8
80007fb4:	0a 9c       	mov	r12,r5
80007fb6:	0e 9b       	mov	r11,r7
80007fb8:	ca 4f       	rcall	80007f00 <_vfprintf_r>
80007fba:	50 bc       	stdsp	sp[0x2c],r12
80007fbc:	c0 95       	brlt	80007fce <_vfprintf_r+0xce>
80007fbe:	0e 9b       	mov	r11,r7
80007fc0:	0a 9c       	mov	r12,r5
80007fc2:	e0 a0 16 1b 	rcall	8000abf8 <_fflush_r>
80007fc6:	40 be       	lddsp	lr,sp[0x2c]
80007fc8:	f9 be 01 ff 	movne	lr,-1
80007fcc:	50 be       	stdsp	sp[0x2c],lr
80007fce:	fb 08 05 d0 	ld.sh	r8,sp[1488]
80007fd2:	ed b8 00 06 	bld	r8,0x6
80007fd6:	e0 81 0f 1a 	brne	80009e0a <_vfprintf_r+0x1f0a>
80007fda:	82 68       	ld.sh	r8,r1[0xc]
80007fdc:	a7 a8       	sbr	r8,0x6
80007fde:	a2 68       	st.h	r1[0xc],r8
80007fe0:	e0 8f 0f 15 	bral	80009e0a <_vfprintf_r+0x1f0a>
80007fe4:	30 08       	mov	r8,0
80007fe6:	fb 48 06 b4 	st.w	sp[1716],r8
80007fea:	fb 48 06 90 	st.w	sp[1680],r8
80007fee:	fb 48 06 8c 	st.w	sp[1676],r8
80007ff2:	fb 48 06 b0 	st.w	sp[1712],r8
80007ff6:	30 08       	mov	r8,0
80007ff8:	30 09       	mov	r9,0
80007ffa:	50 a7       	stdsp	sp[0x28],r7
80007ffc:	50 78       	stdsp	sp[0x1c],r8
80007ffe:	fa c3 f9 e0 	sub	r3,sp,-1568
80008002:	3f f8       	mov	r8,-1
80008004:	50 59       	stdsp	sp[0x14],r9
80008006:	fb 43 06 88 	st.w	sp[1672],r3
8000800a:	fb 48 05 44 	st.w	sp[1348],r8
8000800e:	12 9c       	mov	r12,r9
80008010:	50 69       	stdsp	sp[0x18],r9
80008012:	50 d9       	stdsp	sp[0x34],r9
80008014:	50 e9       	stdsp	sp[0x38],r9
80008016:	50 b9       	stdsp	sp[0x2c],r9
80008018:	12 97       	mov	r7,r9
8000801a:	0a 94       	mov	r4,r5
8000801c:	40 a2       	lddsp	r2,sp[0x28]
8000801e:	32 5a       	mov	r10,37
80008020:	30 08       	mov	r8,0
80008022:	c0 28       	rjmp	80008026 <_vfprintf_r+0x126>
80008024:	2f f2       	sub	r2,-1
80008026:	05 89       	ld.ub	r9,r2[0x0]
80008028:	f0 09 18 00 	cp.b	r9,r8
8000802c:	5f 1b       	srne	r11
8000802e:	f4 09 18 00 	cp.b	r9,r10
80008032:	5f 19       	srne	r9
80008034:	f3 eb 00 0b 	and	r11,r9,r11
80008038:	f0 0b 18 00 	cp.b	r11,r8
8000803c:	cf 41       	brne	80008024 <_vfprintf_r+0x124>
8000803e:	40 ab       	lddsp	r11,sp[0x28]
80008040:	e4 0b 01 06 	sub	r6,r2,r11
80008044:	c1 e0       	breq	80008080 <_vfprintf_r+0x180>
80008046:	fa f8 06 90 	ld.w	r8,sp[1680]
8000804a:	0c 08       	add	r8,r6
8000804c:	87 0b       	st.w	r3[0x0],r11
8000804e:	fb 48 06 90 	st.w	sp[1680],r8
80008052:	87 16       	st.w	r3[0x4],r6
80008054:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008058:	2f f8       	sub	r8,-1
8000805a:	fb 48 06 8c 	st.w	sp[1676],r8
8000805e:	58 78       	cp.w	r8,7
80008060:	e0 89 00 04 	brgt	80008068 <_vfprintf_r+0x168>
80008064:	2f 83       	sub	r3,-8
80008066:	c0 a8       	rjmp	8000807a <_vfprintf_r+0x17a>
80008068:	fa ca f9 78 	sub	r10,sp,-1672
8000806c:	02 9b       	mov	r11,r1
8000806e:	08 9c       	mov	r12,r4
80008070:	c3 af       	rcall	80007ee4 <__sprint_r>
80008072:	e0 81 0e c6 	brne	80009dfe <_vfprintf_r+0x1efe>
80008076:	fa c3 f9 e0 	sub	r3,sp,-1568
8000807a:	40 ba       	lddsp	r10,sp[0x2c]
8000807c:	0c 0a       	add	r10,r6
8000807e:	50 ba       	stdsp	sp[0x2c],r10
80008080:	05 89       	ld.ub	r9,r2[0x0]
80008082:	30 08       	mov	r8,0
80008084:	f0 09 18 00 	cp.b	r9,r8
80008088:	e0 80 0e aa 	breq	80009ddc <_vfprintf_r+0x1edc>
8000808c:	30 09       	mov	r9,0
8000808e:	fb 68 06 bb 	st.b	sp[1723],r8
80008092:	0e 96       	mov	r6,r7
80008094:	e4 c8 ff ff 	sub	r8,r2,-1
80008098:	3f fe       	mov	lr,-1
8000809a:	50 93       	stdsp	sp[0x24],r3
8000809c:	50 41       	stdsp	sp[0x10],r1
8000809e:	0e 93       	mov	r3,r7
800080a0:	04 91       	mov	r1,r2
800080a2:	50 89       	stdsp	sp[0x20],r9
800080a4:	50 a8       	stdsp	sp[0x28],r8
800080a6:	50 2e       	stdsp	sp[0x8],lr
800080a8:	50 39       	stdsp	sp[0xc],r9
800080aa:	12 95       	mov	r5,r9
800080ac:	12 90       	mov	r0,r9
800080ae:	10 97       	mov	r7,r8
800080b0:	08 92       	mov	r2,r4
800080b2:	c0 78       	rjmp	800080c0 <_vfprintf_r+0x1c0>
800080b4:	3f fc       	mov	r12,-1
800080b6:	08 97       	mov	r7,r4
800080b8:	50 2c       	stdsp	sp[0x8],r12
800080ba:	c0 38       	rjmp	800080c0 <_vfprintf_r+0x1c0>
800080bc:	30 0b       	mov	r11,0
800080be:	50 3b       	stdsp	sp[0xc],r11
800080c0:	0f 38       	ld.ub	r8,r7++
800080c2:	c0 28       	rjmp	800080c6 <_vfprintf_r+0x1c6>
800080c4:	12 90       	mov	r0,r9
800080c6:	f0 c9 00 20 	sub	r9,r8,32
800080ca:	e0 49 00 58 	cp.w	r9,88
800080ce:	e0 8b 0a 30 	brhi	8000952e <_vfprintf_r+0x162e>
800080d2:	fe ca a5 66 	sub	r10,pc,-23194
800080d6:	f4 09 03 2f 	ld.w	pc,r10[r9<<0x2]
800080da:	50 a7       	stdsp	sp[0x28],r7
800080dc:	50 80       	stdsp	sp[0x20],r0
800080de:	0c 97       	mov	r7,r6
800080e0:	04 94       	mov	r4,r2
800080e2:	06 96       	mov	r6,r3
800080e4:	02 92       	mov	r2,r1
800080e6:	fe c9 a3 3e 	sub	r9,pc,-23746
800080ea:	40 93       	lddsp	r3,sp[0x24]
800080ec:	10 90       	mov	r0,r8
800080ee:	40 41       	lddsp	r1,sp[0x10]
800080f0:	50 d9       	stdsp	sp[0x34],r9
800080f2:	e0 8f 08 8e 	bral	8000920e <_vfprintf_r+0x130e>
800080f6:	30 08       	mov	r8,0
800080f8:	fb 39 06 bb 	ld.ub	r9,sp[1723]
800080fc:	f0 09 18 00 	cp.b	r9,r8
80008100:	ce 01       	brne	800080c0 <_vfprintf_r+0x1c0>
80008102:	32 08       	mov	r8,32
80008104:	c6 e8       	rjmp	800081e0 <_vfprintf_r+0x2e0>
80008106:	a1 a5       	sbr	r5,0x0
80008108:	cd cb       	rjmp	800080c0 <_vfprintf_r+0x1c0>
8000810a:	0f 89       	ld.ub	r9,r7[0x0]
8000810c:	f2 c8 00 30 	sub	r8,r9,48
80008110:	58 98       	cp.w	r8,9
80008112:	e0 8b 00 1d 	brhi	8000814c <_vfprintf_r+0x24c>
80008116:	ee c8 ff ff 	sub	r8,r7,-1
8000811a:	30 0b       	mov	r11,0
8000811c:	23 09       	sub	r9,48
8000811e:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
80008122:	f2 0b 00 1b 	add	r11,r9,r11<<0x1
80008126:	11 39       	ld.ub	r9,r8++
80008128:	f2 ca 00 30 	sub	r10,r9,48
8000812c:	58 9a       	cp.w	r10,9
8000812e:	fe 98 ff f7 	brls	8000811c <_vfprintf_r+0x21c>
80008132:	e0 49 00 24 	cp.w	r9,36
80008136:	cc 31       	brne	800080bc <_vfprintf_r+0x1bc>
80008138:	e0 4b 00 20 	cp.w	r11,32
8000813c:	e0 89 0e 60 	brgt	80009dfc <_vfprintf_r+0x1efc>
80008140:	20 1b       	sub	r11,1
80008142:	fa f9 06 b4 	ld.w	r9,sp[1716]
80008146:	12 3b       	cp.w	r11,r9
80008148:	c0 95       	brlt	8000815a <_vfprintf_r+0x25a>
8000814a:	c1 08       	rjmp	8000816a <_vfprintf_r+0x26a>
8000814c:	fa f9 06 b4 	ld.w	r9,sp[1716]
80008150:	ec ca ff ff 	sub	r10,r6,-1
80008154:	12 36       	cp.w	r6,r9
80008156:	c1 f5       	brlt	80008194 <_vfprintf_r+0x294>
80008158:	c2 68       	rjmp	800081a4 <_vfprintf_r+0x2a4>
8000815a:	fa ce f9 44 	sub	lr,sp,-1724
8000815e:	10 97       	mov	r7,r8
80008160:	fc 0b 00 3b 	add	r11,lr,r11<<0x3
80008164:	f6 f0 fd 88 	ld.w	r0,r11[-632]
80008168:	c3 58       	rjmp	800081d2 <_vfprintf_r+0x2d2>
8000816a:	10 97       	mov	r7,r8
8000816c:	fa c8 f9 50 	sub	r8,sp,-1712
80008170:	1a d8       	st.w	--sp,r8
80008172:	fa c8 fa b8 	sub	r8,sp,-1352
80008176:	1a d8       	st.w	--sp,r8
80008178:	fa c8 fb b4 	sub	r8,sp,-1100
8000817c:	02 9a       	mov	r10,r1
8000817e:	1a d8       	st.w	--sp,r8
80008180:	04 9c       	mov	r12,r2
80008182:	fa c8 f9 40 	sub	r8,sp,-1728
80008186:	fa c9 ff b4 	sub	r9,sp,-76
8000818a:	fe b0 fd 23 	rcall	80007bd0 <get_arg>
8000818e:	2f dd       	sub	sp,-12
80008190:	78 00       	ld.w	r0,r12[0x0]
80008192:	c2 08       	rjmp	800081d2 <_vfprintf_r+0x2d2>
80008194:	fa cc f9 44 	sub	r12,sp,-1724
80008198:	14 96       	mov	r6,r10
8000819a:	f8 03 00 38 	add	r8,r12,r3<<0x3
8000819e:	f0 f0 fd 88 	ld.w	r0,r8[-632]
800081a2:	c1 88       	rjmp	800081d2 <_vfprintf_r+0x2d2>
800081a4:	41 08       	lddsp	r8,sp[0x40]
800081a6:	59 f9       	cp.w	r9,31
800081a8:	e0 89 00 11 	brgt	800081ca <_vfprintf_r+0x2ca>
800081ac:	f0 cb ff fc 	sub	r11,r8,-4
800081b0:	51 0b       	stdsp	sp[0x40],r11
800081b2:	70 00       	ld.w	r0,r8[0x0]
800081b4:	fa cb f9 44 	sub	r11,sp,-1724
800081b8:	f6 09 00 38 	add	r8,r11,r9<<0x3
800081bc:	f1 40 fd 88 	st.w	r8[-632],r0
800081c0:	2f f9       	sub	r9,-1
800081c2:	14 96       	mov	r6,r10
800081c4:	fb 49 06 b4 	st.w	sp[1716],r9
800081c8:	c0 58       	rjmp	800081d2 <_vfprintf_r+0x2d2>
800081ca:	70 00       	ld.w	r0,r8[0x0]
800081cc:	14 96       	mov	r6,r10
800081ce:	2f c8       	sub	r8,-4
800081d0:	51 08       	stdsp	sp[0x40],r8
800081d2:	58 00       	cp.w	r0,0
800081d4:	fe 94 ff 76 	brge	800080c0 <_vfprintf_r+0x1c0>
800081d8:	5c 30       	neg	r0
800081da:	a3 a5       	sbr	r5,0x2
800081dc:	c7 2b       	rjmp	800080c0 <_vfprintf_r+0x1c0>
800081de:	32 b8       	mov	r8,43
800081e0:	fb 68 06 bb 	st.b	sp[1723],r8
800081e4:	c6 eb       	rjmp	800080c0 <_vfprintf_r+0x1c0>
800081e6:	0f 38       	ld.ub	r8,r7++
800081e8:	e0 48 00 2a 	cp.w	r8,42
800081ec:	c0 30       	breq	800081f2 <_vfprintf_r+0x2f2>
800081ee:	30 09       	mov	r9,0
800081f0:	c7 98       	rjmp	800082e2 <_vfprintf_r+0x3e2>
800081f2:	0f 88       	ld.ub	r8,r7[0x0]
800081f4:	f0 c9 00 30 	sub	r9,r8,48
800081f8:	58 99       	cp.w	r9,9
800081fa:	e0 8b 00 1f 	brhi	80008238 <_vfprintf_r+0x338>
800081fe:	ee c4 ff ff 	sub	r4,r7,-1
80008202:	30 0b       	mov	r11,0
80008204:	23 08       	sub	r8,48
80008206:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
8000820a:	f0 0b 00 1b 	add	r11,r8,r11<<0x1
8000820e:	09 38       	ld.ub	r8,r4++
80008210:	f0 c9 00 30 	sub	r9,r8,48
80008214:	58 99       	cp.w	r9,9
80008216:	fe 98 ff f7 	brls	80008204 <_vfprintf_r+0x304>
8000821a:	e0 48 00 24 	cp.w	r8,36
8000821e:	fe 91 ff 4f 	brne	800080bc <_vfprintf_r+0x1bc>
80008222:	e0 4b 00 20 	cp.w	r11,32
80008226:	e0 89 0d eb 	brgt	80009dfc <_vfprintf_r+0x1efc>
8000822a:	20 1b       	sub	r11,1
8000822c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008230:	10 3b       	cp.w	r11,r8
80008232:	c0 a5       	brlt	80008246 <_vfprintf_r+0x346>
80008234:	c1 18       	rjmp	80008256 <_vfprintf_r+0x356>
80008236:	d7 03       	nop
80008238:	fa fa 06 b4 	ld.w	r10,sp[1716]
8000823c:	ec c9 ff ff 	sub	r9,r6,-1
80008240:	14 36       	cp.w	r6,r10
80008242:	c1 f5       	brlt	80008280 <_vfprintf_r+0x380>
80008244:	c2 88       	rjmp	80008294 <_vfprintf_r+0x394>
80008246:	fa ca f9 44 	sub	r10,sp,-1724
8000824a:	f4 0b 00 3b 	add	r11,r10,r11<<0x3
8000824e:	f6 fb fd 88 	ld.w	r11,r11[-632]
80008252:	50 2b       	stdsp	sp[0x8],r11
80008254:	c3 c8       	rjmp	800082cc <_vfprintf_r+0x3cc>
80008256:	fa c8 f9 50 	sub	r8,sp,-1712
8000825a:	1a d8       	st.w	--sp,r8
8000825c:	fa c8 fa b8 	sub	r8,sp,-1352
80008260:	1a d8       	st.w	--sp,r8
80008262:	fa c8 fb b4 	sub	r8,sp,-1100
80008266:	02 9a       	mov	r10,r1
80008268:	1a d8       	st.w	--sp,r8
8000826a:	04 9c       	mov	r12,r2
8000826c:	fa c8 f9 40 	sub	r8,sp,-1728
80008270:	fa c9 ff b4 	sub	r9,sp,-76
80008274:	fe b0 fc ae 	rcall	80007bd0 <get_arg>
80008278:	2f dd       	sub	sp,-12
8000827a:	78 0c       	ld.w	r12,r12[0x0]
8000827c:	50 2c       	stdsp	sp[0x8],r12
8000827e:	c2 78       	rjmp	800082cc <_vfprintf_r+0x3cc>
80008280:	12 96       	mov	r6,r9
80008282:	0e 94       	mov	r4,r7
80008284:	fa c9 f9 44 	sub	r9,sp,-1724
80008288:	f2 03 00 38 	add	r8,r9,r3<<0x3
8000828c:	f0 f8 fd 88 	ld.w	r8,r8[-632]
80008290:	50 28       	stdsp	sp[0x8],r8
80008292:	c1 d8       	rjmp	800082cc <_vfprintf_r+0x3cc>
80008294:	41 08       	lddsp	r8,sp[0x40]
80008296:	59 fa       	cp.w	r10,31
80008298:	e0 89 00 14 	brgt	800082c0 <_vfprintf_r+0x3c0>
8000829c:	f0 cb ff fc 	sub	r11,r8,-4
800082a0:	70 08       	ld.w	r8,r8[0x0]
800082a2:	51 0b       	stdsp	sp[0x40],r11
800082a4:	50 28       	stdsp	sp[0x8],r8
800082a6:	fa c6 f9 44 	sub	r6,sp,-1724
800082aa:	40 2e       	lddsp	lr,sp[0x8]
800082ac:	ec 0a 00 38 	add	r8,r6,r10<<0x3
800082b0:	f1 4e fd 88 	st.w	r8[-632],lr
800082b4:	2f fa       	sub	r10,-1
800082b6:	0e 94       	mov	r4,r7
800082b8:	fb 4a 06 b4 	st.w	sp[1716],r10
800082bc:	12 96       	mov	r6,r9
800082be:	c0 78       	rjmp	800082cc <_vfprintf_r+0x3cc>
800082c0:	70 0c       	ld.w	r12,r8[0x0]
800082c2:	0e 94       	mov	r4,r7
800082c4:	2f c8       	sub	r8,-4
800082c6:	50 2c       	stdsp	sp[0x8],r12
800082c8:	12 96       	mov	r6,r9
800082ca:	51 08       	stdsp	sp[0x40],r8
800082cc:	40 2b       	lddsp	r11,sp[0x8]
800082ce:	58 0b       	cp.w	r11,0
800082d0:	fe 95 fe f2 	brlt	800080b4 <_vfprintf_r+0x1b4>
800082d4:	08 97       	mov	r7,r4
800082d6:	cf 5a       	rjmp	800080c0 <_vfprintf_r+0x1c0>
800082d8:	f2 09 00 29 	add	r9,r9,r9<<0x2
800082dc:	0f 38       	ld.ub	r8,r7++
800082de:	f4 09 00 19 	add	r9,r10,r9<<0x1
800082e2:	f0 ca 00 30 	sub	r10,r8,48
800082e6:	58 9a       	cp.w	r10,9
800082e8:	fe 98 ff f8 	brls	800082d8 <_vfprintf_r+0x3d8>
800082ec:	3f fa       	mov	r10,-1
800082ee:	f2 0a 0c 49 	max	r9,r9,r10
800082f2:	50 29       	stdsp	sp[0x8],r9
800082f4:	ce 9a       	rjmp	800080c6 <_vfprintf_r+0x1c6>
800082f6:	a7 b5       	sbr	r5,0x7
800082f8:	ce 4a       	rjmp	800080c0 <_vfprintf_r+0x1c0>
800082fa:	30 09       	mov	r9,0
800082fc:	23 08       	sub	r8,48
800082fe:	f2 09 00 29 	add	r9,r9,r9<<0x2
80008302:	f0 09 00 19 	add	r9,r8,r9<<0x1
80008306:	0f 38       	ld.ub	r8,r7++
80008308:	f0 ca 00 30 	sub	r10,r8,48
8000830c:	58 9a       	cp.w	r10,9
8000830e:	fe 98 ff f7 	brls	800082fc <_vfprintf_r+0x3fc>
80008312:	e0 48 00 24 	cp.w	r8,36
80008316:	fe 91 fe d7 	brne	800080c4 <_vfprintf_r+0x1c4>
8000831a:	e0 49 00 20 	cp.w	r9,32
8000831e:	e0 89 0d 6f 	brgt	80009dfc <_vfprintf_r+0x1efc>
80008322:	f2 c3 00 01 	sub	r3,r9,1
80008326:	30 19       	mov	r9,1
80008328:	50 39       	stdsp	sp[0xc],r9
8000832a:	cc ba       	rjmp	800080c0 <_vfprintf_r+0x1c0>
8000832c:	a3 b5       	sbr	r5,0x3
8000832e:	cc 9a       	rjmp	800080c0 <_vfprintf_r+0x1c0>
80008330:	a7 a5       	sbr	r5,0x6
80008332:	cc 7a       	rjmp	800080c0 <_vfprintf_r+0x1c0>
80008334:	0a 98       	mov	r8,r5
80008336:	a5 b5       	sbr	r5,0x5
80008338:	a5 a8       	sbr	r8,0x4
8000833a:	0f 89       	ld.ub	r9,r7[0x0]
8000833c:	36 ce       	mov	lr,108
8000833e:	fc 09 18 00 	cp.b	r9,lr
80008342:	f7 b7 00 ff 	subeq	r7,-1
80008346:	f0 05 17 10 	movne	r5,r8
8000834a:	cb ba       	rjmp	800080c0 <_vfprintf_r+0x1c0>
8000834c:	a5 b5       	sbr	r5,0x5
8000834e:	cb 9a       	rjmp	800080c0 <_vfprintf_r+0x1c0>
80008350:	50 a7       	stdsp	sp[0x28],r7
80008352:	50 80       	stdsp	sp[0x20],r0
80008354:	0c 97       	mov	r7,r6
80008356:	10 90       	mov	r0,r8
80008358:	06 96       	mov	r6,r3
8000835a:	04 94       	mov	r4,r2
8000835c:	40 93       	lddsp	r3,sp[0x24]
8000835e:	02 92       	mov	r2,r1
80008360:	0e 99       	mov	r9,r7
80008362:	40 41       	lddsp	r1,sp[0x10]
80008364:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008368:	40 3c       	lddsp	r12,sp[0xc]
8000836a:	58 0c       	cp.w	r12,0
8000836c:	c1 d0       	breq	800083a6 <_vfprintf_r+0x4a6>
8000836e:	10 36       	cp.w	r6,r8
80008370:	c0 64       	brge	8000837c <_vfprintf_r+0x47c>
80008372:	fa cb f9 44 	sub	r11,sp,-1724
80008376:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000837a:	c1 d8       	rjmp	800083b4 <_vfprintf_r+0x4b4>
8000837c:	fa c8 f9 50 	sub	r8,sp,-1712
80008380:	1a d8       	st.w	--sp,r8
80008382:	fa c8 fa b8 	sub	r8,sp,-1352
80008386:	1a d8       	st.w	--sp,r8
80008388:	fa c8 fb b4 	sub	r8,sp,-1100
8000838c:	1a d8       	st.w	--sp,r8
8000838e:	fa c8 f9 40 	sub	r8,sp,-1728
80008392:	fa c9 ff b4 	sub	r9,sp,-76
80008396:	04 9a       	mov	r10,r2
80008398:	0c 9b       	mov	r11,r6
8000839a:	08 9c       	mov	r12,r4
8000839c:	fe b0 fc 1a 	rcall	80007bd0 <get_arg>
800083a0:	2f dd       	sub	sp,-12
800083a2:	19 b8       	ld.ub	r8,r12[0x3]
800083a4:	c2 28       	rjmp	800083e8 <_vfprintf_r+0x4e8>
800083a6:	2f f7       	sub	r7,-1
800083a8:	10 39       	cp.w	r9,r8
800083aa:	c0 84       	brge	800083ba <_vfprintf_r+0x4ba>
800083ac:	fa ca f9 44 	sub	r10,sp,-1724
800083b0:	f4 06 00 36 	add	r6,r10,r6<<0x3
800083b4:	ed 38 fd 8b 	ld.ub	r8,r6[-629]
800083b8:	c1 88       	rjmp	800083e8 <_vfprintf_r+0x4e8>
800083ba:	41 09       	lddsp	r9,sp[0x40]
800083bc:	59 f8       	cp.w	r8,31
800083be:	e0 89 00 12 	brgt	800083e2 <_vfprintf_r+0x4e2>
800083c2:	f2 ca ff fc 	sub	r10,r9,-4
800083c6:	51 0a       	stdsp	sp[0x40],r10
800083c8:	72 09       	ld.w	r9,r9[0x0]
800083ca:	fa c6 f9 44 	sub	r6,sp,-1724
800083ce:	ec 08 00 3a 	add	r10,r6,r8<<0x3
800083d2:	2f f8       	sub	r8,-1
800083d4:	f5 49 fd 88 	st.w	r10[-632],r9
800083d8:	fb 48 06 b4 	st.w	sp[1716],r8
800083dc:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
800083e0:	c0 48       	rjmp	800083e8 <_vfprintf_r+0x4e8>
800083e2:	13 b8       	ld.ub	r8,r9[0x3]
800083e4:	2f c9       	sub	r9,-4
800083e6:	51 09       	stdsp	sp[0x40],r9
800083e8:	fb 68 06 60 	st.b	sp[1632],r8
800083ec:	30 0e       	mov	lr,0
800083ee:	30 08       	mov	r8,0
800083f0:	30 12       	mov	r2,1
800083f2:	fb 68 06 bb 	st.b	sp[1723],r8
800083f6:	50 2e       	stdsp	sp[0x8],lr
800083f8:	e0 8f 08 ad 	bral	80009552 <_vfprintf_r+0x1652>
800083fc:	50 a7       	stdsp	sp[0x28],r7
800083fe:	50 80       	stdsp	sp[0x20],r0
80008400:	0c 97       	mov	r7,r6
80008402:	04 94       	mov	r4,r2
80008404:	06 96       	mov	r6,r3
80008406:	02 92       	mov	r2,r1
80008408:	40 93       	lddsp	r3,sp[0x24]
8000840a:	10 90       	mov	r0,r8
8000840c:	40 41       	lddsp	r1,sp[0x10]
8000840e:	a5 a5       	sbr	r5,0x4
80008410:	c0 a8       	rjmp	80008424 <_vfprintf_r+0x524>
80008412:	50 a7       	stdsp	sp[0x28],r7
80008414:	50 80       	stdsp	sp[0x20],r0
80008416:	0c 97       	mov	r7,r6
80008418:	04 94       	mov	r4,r2
8000841a:	06 96       	mov	r6,r3
8000841c:	02 92       	mov	r2,r1
8000841e:	40 93       	lddsp	r3,sp[0x24]
80008420:	10 90       	mov	r0,r8
80008422:	40 41       	lddsp	r1,sp[0x10]
80008424:	ed b5 00 05 	bld	r5,0x5
80008428:	c5 11       	brne	800084ca <_vfprintf_r+0x5ca>
8000842a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000842e:	40 3c       	lddsp	r12,sp[0xc]
80008430:	58 0c       	cp.w	r12,0
80008432:	c1 e0       	breq	8000846e <_vfprintf_r+0x56e>
80008434:	10 36       	cp.w	r6,r8
80008436:	c0 64       	brge	80008442 <_vfprintf_r+0x542>
80008438:	fa cb f9 44 	sub	r11,sp,-1724
8000843c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008440:	c2 08       	rjmp	80008480 <_vfprintf_r+0x580>
80008442:	fa c8 f9 50 	sub	r8,sp,-1712
80008446:	1a d8       	st.w	--sp,r8
80008448:	fa c8 fa b8 	sub	r8,sp,-1352
8000844c:	0c 9b       	mov	r11,r6
8000844e:	1a d8       	st.w	--sp,r8
80008450:	fa c8 fb b4 	sub	r8,sp,-1100
80008454:	1a d8       	st.w	--sp,r8
80008456:	fa c9 ff b4 	sub	r9,sp,-76
8000845a:	fa c8 f9 40 	sub	r8,sp,-1728
8000845e:	04 9a       	mov	r10,r2
80008460:	08 9c       	mov	r12,r4
80008462:	fe b0 fb b7 	rcall	80007bd0 <get_arg>
80008466:	2f dd       	sub	sp,-12
80008468:	78 1b       	ld.w	r11,r12[0x4]
8000846a:	78 09       	ld.w	r9,r12[0x0]
8000846c:	c2 b8       	rjmp	800084c2 <_vfprintf_r+0x5c2>
8000846e:	ee ca ff ff 	sub	r10,r7,-1
80008472:	10 37       	cp.w	r7,r8
80008474:	c0 b4       	brge	8000848a <_vfprintf_r+0x58a>
80008476:	fa c9 f9 44 	sub	r9,sp,-1724
8000847a:	14 97       	mov	r7,r10
8000847c:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008480:	ec fb fd 8c 	ld.w	r11,r6[-628]
80008484:	ec f9 fd 88 	ld.w	r9,r6[-632]
80008488:	c1 d8       	rjmp	800084c2 <_vfprintf_r+0x5c2>
8000848a:	41 09       	lddsp	r9,sp[0x40]
8000848c:	59 f8       	cp.w	r8,31
8000848e:	e0 89 00 14 	brgt	800084b6 <_vfprintf_r+0x5b6>
80008492:	f2 cb ff f8 	sub	r11,r9,-8
80008496:	51 0b       	stdsp	sp[0x40],r11
80008498:	fa c6 f9 44 	sub	r6,sp,-1724
8000849c:	72 1b       	ld.w	r11,r9[0x4]
8000849e:	ec 08 00 3c 	add	r12,r6,r8<<0x3
800084a2:	72 09       	ld.w	r9,r9[0x0]
800084a4:	f9 4b fd 8c 	st.w	r12[-628],r11
800084a8:	f9 49 fd 88 	st.w	r12[-632],r9
800084ac:	2f f8       	sub	r8,-1
800084ae:	14 97       	mov	r7,r10
800084b0:	fb 48 06 b4 	st.w	sp[1716],r8
800084b4:	c0 78       	rjmp	800084c2 <_vfprintf_r+0x5c2>
800084b6:	f2 c8 ff f8 	sub	r8,r9,-8
800084ba:	72 1b       	ld.w	r11,r9[0x4]
800084bc:	14 97       	mov	r7,r10
800084be:	51 08       	stdsp	sp[0x40],r8
800084c0:	72 09       	ld.w	r9,r9[0x0]
800084c2:	16 98       	mov	r8,r11
800084c4:	fa e9 00 00 	st.d	sp[0],r8
800084c8:	ca e8       	rjmp	80008624 <_vfprintf_r+0x724>
800084ca:	ed b5 00 04 	bld	r5,0x4
800084ce:	c1 71       	brne	800084fc <_vfprintf_r+0x5fc>
800084d0:	fa f8 06 b4 	ld.w	r8,sp[1716]
800084d4:	40 3e       	lddsp	lr,sp[0xc]
800084d6:	58 0e       	cp.w	lr,0
800084d8:	c0 80       	breq	800084e8 <_vfprintf_r+0x5e8>
800084da:	10 36       	cp.w	r6,r8
800084dc:	c6 94       	brge	800085ae <_vfprintf_r+0x6ae>
800084de:	fa cc f9 44 	sub	r12,sp,-1724
800084e2:	f8 06 00 36 	add	r6,r12,r6<<0x3
800084e6:	c8 28       	rjmp	800085ea <_vfprintf_r+0x6ea>
800084e8:	ee ca ff ff 	sub	r10,r7,-1
800084ec:	10 37       	cp.w	r7,r8
800084ee:	e0 84 00 81 	brge	800085f0 <_vfprintf_r+0x6f0>
800084f2:	fa cb f9 44 	sub	r11,sp,-1724
800084f6:	f6 06 00 36 	add	r6,r11,r6<<0x3
800084fa:	c7 78       	rjmp	800085e8 <_vfprintf_r+0x6e8>
800084fc:	ed b5 00 06 	bld	r5,0x6
80008500:	c4 b1       	brne	80008596 <_vfprintf_r+0x696>
80008502:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008506:	40 3c       	lddsp	r12,sp[0xc]
80008508:	58 0c       	cp.w	r12,0
8000850a:	c1 d0       	breq	80008544 <_vfprintf_r+0x644>
8000850c:	10 36       	cp.w	r6,r8
8000850e:	c0 64       	brge	8000851a <_vfprintf_r+0x61a>
80008510:	fa cb f9 44 	sub	r11,sp,-1724
80008514:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008518:	c1 f8       	rjmp	80008556 <_vfprintf_r+0x656>
8000851a:	fa c8 f9 50 	sub	r8,sp,-1712
8000851e:	1a d8       	st.w	--sp,r8
80008520:	fa c8 fa b8 	sub	r8,sp,-1352
80008524:	1a d8       	st.w	--sp,r8
80008526:	fa c8 fb b4 	sub	r8,sp,-1100
8000852a:	1a d8       	st.w	--sp,r8
8000852c:	fa c8 f9 40 	sub	r8,sp,-1728
80008530:	fa c9 ff b4 	sub	r9,sp,-76
80008534:	04 9a       	mov	r10,r2
80008536:	0c 9b       	mov	r11,r6
80008538:	08 9c       	mov	r12,r4
8000853a:	fe b0 fb 4b 	rcall	80007bd0 <get_arg>
8000853e:	2f dd       	sub	sp,-12
80008540:	98 18       	ld.sh	r8,r12[0x2]
80008542:	c2 68       	rjmp	8000858e <_vfprintf_r+0x68e>
80008544:	ee ca ff ff 	sub	r10,r7,-1
80008548:	10 37       	cp.w	r7,r8
8000854a:	c0 94       	brge	8000855c <_vfprintf_r+0x65c>
8000854c:	fa c9 f9 44 	sub	r9,sp,-1724
80008550:	14 97       	mov	r7,r10
80008552:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008556:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000855a:	c1 a8       	rjmp	8000858e <_vfprintf_r+0x68e>
8000855c:	41 09       	lddsp	r9,sp[0x40]
8000855e:	59 f8       	cp.w	r8,31
80008560:	e0 89 00 13 	brgt	80008586 <_vfprintf_r+0x686>
80008564:	f2 cb ff fc 	sub	r11,r9,-4
80008568:	51 0b       	stdsp	sp[0x40],r11
8000856a:	72 09       	ld.w	r9,r9[0x0]
8000856c:	fa c6 f9 44 	sub	r6,sp,-1724
80008570:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80008574:	2f f8       	sub	r8,-1
80008576:	f7 49 fd 88 	st.w	r11[-632],r9
8000857a:	fb 48 06 b4 	st.w	sp[1716],r8
8000857e:	14 97       	mov	r7,r10
80008580:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80008584:	c0 58       	rjmp	8000858e <_vfprintf_r+0x68e>
80008586:	92 18       	ld.sh	r8,r9[0x2]
80008588:	14 97       	mov	r7,r10
8000858a:	2f c9       	sub	r9,-4
8000858c:	51 09       	stdsp	sp[0x40],r9
8000858e:	50 18       	stdsp	sp[0x4],r8
80008590:	bf 58       	asr	r8,0x1f
80008592:	50 08       	stdsp	sp[0x0],r8
80008594:	c4 88       	rjmp	80008624 <_vfprintf_r+0x724>
80008596:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000859a:	40 3c       	lddsp	r12,sp[0xc]
8000859c:	58 0c       	cp.w	r12,0
8000859e:	c1 d0       	breq	800085d8 <_vfprintf_r+0x6d8>
800085a0:	10 36       	cp.w	r6,r8
800085a2:	c0 64       	brge	800085ae <_vfprintf_r+0x6ae>
800085a4:	fa cb f9 44 	sub	r11,sp,-1724
800085a8:	f6 06 00 36 	add	r6,r11,r6<<0x3
800085ac:	c1 f8       	rjmp	800085ea <_vfprintf_r+0x6ea>
800085ae:	fa c8 f9 50 	sub	r8,sp,-1712
800085b2:	1a d8       	st.w	--sp,r8
800085b4:	fa c8 fa b8 	sub	r8,sp,-1352
800085b8:	0c 9b       	mov	r11,r6
800085ba:	1a d8       	st.w	--sp,r8
800085bc:	fa c8 fb b4 	sub	r8,sp,-1100
800085c0:	04 9a       	mov	r10,r2
800085c2:	1a d8       	st.w	--sp,r8
800085c4:	08 9c       	mov	r12,r4
800085c6:	fa c8 f9 40 	sub	r8,sp,-1728
800085ca:	fa c9 ff b4 	sub	r9,sp,-76
800085ce:	fe b0 fb 01 	rcall	80007bd0 <get_arg>
800085d2:	2f dd       	sub	sp,-12
800085d4:	78 0b       	ld.w	r11,r12[0x0]
800085d6:	c2 48       	rjmp	8000861e <_vfprintf_r+0x71e>
800085d8:	ee ca ff ff 	sub	r10,r7,-1
800085dc:	10 37       	cp.w	r7,r8
800085de:	c0 94       	brge	800085f0 <_vfprintf_r+0x6f0>
800085e0:	fa c9 f9 44 	sub	r9,sp,-1724
800085e4:	f2 06 00 36 	add	r6,r9,r6<<0x3
800085e8:	14 97       	mov	r7,r10
800085ea:	ec fb fd 88 	ld.w	r11,r6[-632]
800085ee:	c1 88       	rjmp	8000861e <_vfprintf_r+0x71e>
800085f0:	41 09       	lddsp	r9,sp[0x40]
800085f2:	59 f8       	cp.w	r8,31
800085f4:	e0 89 00 11 	brgt	80008616 <_vfprintf_r+0x716>
800085f8:	f2 cb ff fc 	sub	r11,r9,-4
800085fc:	51 0b       	stdsp	sp[0x40],r11
800085fe:	fa c6 f9 44 	sub	r6,sp,-1724
80008602:	72 0b       	ld.w	r11,r9[0x0]
80008604:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008608:	f3 4b fd 88 	st.w	r9[-632],r11
8000860c:	2f f8       	sub	r8,-1
8000860e:	14 97       	mov	r7,r10
80008610:	fb 48 06 b4 	st.w	sp[1716],r8
80008614:	c0 58       	rjmp	8000861e <_vfprintf_r+0x71e>
80008616:	72 0b       	ld.w	r11,r9[0x0]
80008618:	14 97       	mov	r7,r10
8000861a:	2f c9       	sub	r9,-4
8000861c:	51 09       	stdsp	sp[0x40],r9
8000861e:	50 1b       	stdsp	sp[0x4],r11
80008620:	bf 5b       	asr	r11,0x1f
80008622:	50 0b       	stdsp	sp[0x0],r11
80008624:	fa ea 00 00 	ld.d	r10,sp[0]
80008628:	58 0a       	cp.w	r10,0
8000862a:	5c 2b       	cpc	r11
8000862c:	c0 e4       	brge	80008648 <_vfprintf_r+0x748>
8000862e:	30 08       	mov	r8,0
80008630:	fa ea 00 00 	ld.d	r10,sp[0]
80008634:	30 09       	mov	r9,0
80008636:	f0 0a 01 0a 	sub	r10,r8,r10
8000863a:	f2 0b 01 4b 	sbc	r11,r9,r11
8000863e:	32 d8       	mov	r8,45
80008640:	fa eb 00 00 	st.d	sp[0],r10
80008644:	fb 68 06 bb 	st.b	sp[1723],r8
80008648:	30 18       	mov	r8,1
8000864a:	e0 8f 06 fa 	bral	8000943e <_vfprintf_r+0x153e>
8000864e:	50 a7       	stdsp	sp[0x28],r7
80008650:	50 80       	stdsp	sp[0x20],r0
80008652:	0c 97       	mov	r7,r6
80008654:	04 94       	mov	r4,r2
80008656:	06 96       	mov	r6,r3
80008658:	02 92       	mov	r2,r1
8000865a:	40 93       	lddsp	r3,sp[0x24]
8000865c:	10 90       	mov	r0,r8
8000865e:	40 41       	lddsp	r1,sp[0x10]
80008660:	0e 99       	mov	r9,r7
80008662:	ed b5 00 03 	bld	r5,0x3
80008666:	c4 11       	brne	800086e8 <_vfprintf_r+0x7e8>
80008668:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000866c:	40 3a       	lddsp	r10,sp[0xc]
8000866e:	58 0a       	cp.w	r10,0
80008670:	c1 90       	breq	800086a2 <_vfprintf_r+0x7a2>
80008672:	10 36       	cp.w	r6,r8
80008674:	c6 45       	brlt	8000873c <_vfprintf_r+0x83c>
80008676:	fa c8 f9 50 	sub	r8,sp,-1712
8000867a:	1a d8       	st.w	--sp,r8
8000867c:	fa c8 fa b8 	sub	r8,sp,-1352
80008680:	1a d8       	st.w	--sp,r8
80008682:	fa c8 fb b4 	sub	r8,sp,-1100
80008686:	0c 9b       	mov	r11,r6
80008688:	1a d8       	st.w	--sp,r8
8000868a:	04 9a       	mov	r10,r2
8000868c:	fa c8 f9 40 	sub	r8,sp,-1728
80008690:	fa c9 ff b4 	sub	r9,sp,-76
80008694:	08 9c       	mov	r12,r4
80008696:	fe b0 fa 9d 	rcall	80007bd0 <get_arg>
8000869a:	2f dd       	sub	sp,-12
8000869c:	78 16       	ld.w	r6,r12[0x4]
8000869e:	50 76       	stdsp	sp[0x1c],r6
800086a0:	c4 88       	rjmp	80008730 <_vfprintf_r+0x830>
800086a2:	2f f7       	sub	r7,-1
800086a4:	10 39       	cp.w	r9,r8
800086a6:	c0 c4       	brge	800086be <_vfprintf_r+0x7be>
800086a8:	fa ce f9 44 	sub	lr,sp,-1724
800086ac:	fc 06 00 36 	add	r6,lr,r6<<0x3
800086b0:	ec fc fd 8c 	ld.w	r12,r6[-628]
800086b4:	50 7c       	stdsp	sp[0x1c],r12
800086b6:	ec f6 fd 88 	ld.w	r6,r6[-632]
800086ba:	50 56       	stdsp	sp[0x14],r6
800086bc:	c6 68       	rjmp	80008788 <_vfprintf_r+0x888>
800086be:	41 09       	lddsp	r9,sp[0x40]
800086c0:	59 f8       	cp.w	r8,31
800086c2:	e0 89 00 10 	brgt	800086e2 <_vfprintf_r+0x7e2>
800086c6:	f2 ca ff f8 	sub	r10,r9,-8
800086ca:	72 1b       	ld.w	r11,r9[0x4]
800086cc:	51 0a       	stdsp	sp[0x40],r10
800086ce:	72 09       	ld.w	r9,r9[0x0]
800086d0:	fa ca f9 44 	sub	r10,sp,-1724
800086d4:	50 7b       	stdsp	sp[0x1c],r11
800086d6:	50 59       	stdsp	sp[0x14],r9
800086d8:	f4 08 00 39 	add	r9,r10,r8<<0x3
800086dc:	40 5b       	lddsp	r11,sp[0x14]
800086de:	40 7a       	lddsp	r10,sp[0x1c]
800086e0:	c4 78       	rjmp	8000876e <_vfprintf_r+0x86e>
800086e2:	72 18       	ld.w	r8,r9[0x4]
800086e4:	50 78       	stdsp	sp[0x1c],r8
800086e6:	c4 c8       	rjmp	8000877e <_vfprintf_r+0x87e>
800086e8:	fa f8 06 b4 	ld.w	r8,sp[1716]
800086ec:	40 3e       	lddsp	lr,sp[0xc]
800086ee:	58 0e       	cp.w	lr,0
800086f0:	c2 30       	breq	80008736 <_vfprintf_r+0x836>
800086f2:	10 36       	cp.w	r6,r8
800086f4:	c0 94       	brge	80008706 <_vfprintf_r+0x806>
800086f6:	fa cc f9 44 	sub	r12,sp,-1724
800086fa:	f8 06 00 36 	add	r6,r12,r6<<0x3
800086fe:	ec fb fd 8c 	ld.w	r11,r6[-628]
80008702:	50 7b       	stdsp	sp[0x1c],r11
80008704:	cd 9b       	rjmp	800086b6 <_vfprintf_r+0x7b6>
80008706:	fa c8 f9 50 	sub	r8,sp,-1712
8000870a:	1a d8       	st.w	--sp,r8
8000870c:	fa c8 fa b8 	sub	r8,sp,-1352
80008710:	04 9a       	mov	r10,r2
80008712:	1a d8       	st.w	--sp,r8
80008714:	fa c8 fb b4 	sub	r8,sp,-1100
80008718:	0c 9b       	mov	r11,r6
8000871a:	1a d8       	st.w	--sp,r8
8000871c:	08 9c       	mov	r12,r4
8000871e:	fa c8 f9 40 	sub	r8,sp,-1728
80008722:	fa c9 ff b4 	sub	r9,sp,-76
80008726:	fe b0 fa 55 	rcall	80007bd0 <get_arg>
8000872a:	2f dd       	sub	sp,-12
8000872c:	78 1a       	ld.w	r10,r12[0x4]
8000872e:	50 7a       	stdsp	sp[0x1c],r10
80008730:	78 0c       	ld.w	r12,r12[0x0]
80008732:	50 5c       	stdsp	sp[0x14],r12
80008734:	c2 a8       	rjmp	80008788 <_vfprintf_r+0x888>
80008736:	2f f7       	sub	r7,-1
80008738:	10 39       	cp.w	r9,r8
8000873a:	c0 94       	brge	8000874c <_vfprintf_r+0x84c>
8000873c:	fa c9 f9 44 	sub	r9,sp,-1724
80008740:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008744:	ec f8 fd 8c 	ld.w	r8,r6[-628]
80008748:	50 78       	stdsp	sp[0x1c],r8
8000874a:	cb 6b       	rjmp	800086b6 <_vfprintf_r+0x7b6>
8000874c:	41 09       	lddsp	r9,sp[0x40]
8000874e:	59 f8       	cp.w	r8,31
80008750:	e0 89 00 15 	brgt	8000877a <_vfprintf_r+0x87a>
80008754:	f2 ca ff f8 	sub	r10,r9,-8
80008758:	72 16       	ld.w	r6,r9[0x4]
8000875a:	72 09       	ld.w	r9,r9[0x0]
8000875c:	51 0a       	stdsp	sp[0x40],r10
8000875e:	50 59       	stdsp	sp[0x14],r9
80008760:	fa ce f9 44 	sub	lr,sp,-1724
80008764:	50 76       	stdsp	sp[0x1c],r6
80008766:	fc 08 00 39 	add	r9,lr,r8<<0x3
8000876a:	40 5b       	lddsp	r11,sp[0x14]
8000876c:	0c 9a       	mov	r10,r6
8000876e:	f2 eb fd 88 	st.d	r9[-632],r10
80008772:	2f f8       	sub	r8,-1
80008774:	fb 48 06 b4 	st.w	sp[1716],r8
80008778:	c0 88       	rjmp	80008788 <_vfprintf_r+0x888>
8000877a:	72 1c       	ld.w	r12,r9[0x4]
8000877c:	50 7c       	stdsp	sp[0x1c],r12
8000877e:	f2 c8 ff f8 	sub	r8,r9,-8
80008782:	51 08       	stdsp	sp[0x40],r8
80008784:	72 09       	ld.w	r9,r9[0x0]
80008786:	50 59       	stdsp	sp[0x14],r9
80008788:	40 5b       	lddsp	r11,sp[0x14]
8000878a:	40 7a       	lddsp	r10,sp[0x1c]
8000878c:	e0 a0 19 54 	rcall	8000ba34 <__isinfd>
80008790:	18 96       	mov	r6,r12
80008792:	c1 70       	breq	800087c0 <_vfprintf_r+0x8c0>
80008794:	30 08       	mov	r8,0
80008796:	30 09       	mov	r9,0
80008798:	40 5b       	lddsp	r11,sp[0x14]
8000879a:	40 7a       	lddsp	r10,sp[0x1c]
8000879c:	e0 a0 1d b4 	rcall	8000c304 <__avr32_f64_cmp_lt>
800087a0:	c0 40       	breq	800087a8 <_vfprintf_r+0x8a8>
800087a2:	32 d8       	mov	r8,45
800087a4:	fb 68 06 bb 	st.b	sp[1723],r8
800087a8:	fe c8 a9 ec 	sub	r8,pc,-22036
800087ac:	fe c6 a9 ec 	sub	r6,pc,-22036
800087b0:	a7 d5       	cbr	r5,0x7
800087b2:	e0 40 00 47 	cp.w	r0,71
800087b6:	f0 06 17 a0 	movle	r6,r8
800087ba:	30 32       	mov	r2,3
800087bc:	e0 8f 06 ce 	bral	80009558 <_vfprintf_r+0x1658>
800087c0:	40 5b       	lddsp	r11,sp[0x14]
800087c2:	40 7a       	lddsp	r10,sp[0x1c]
800087c4:	e0 a0 19 4d 	rcall	8000ba5e <__isnand>
800087c8:	c0 e0       	breq	800087e4 <_vfprintf_r+0x8e4>
800087ca:	50 26       	stdsp	sp[0x8],r6
800087cc:	fe c8 aa 08 	sub	r8,pc,-22008
800087d0:	fe c6 aa 08 	sub	r6,pc,-22008
800087d4:	a7 d5       	cbr	r5,0x7
800087d6:	e0 40 00 47 	cp.w	r0,71
800087da:	f0 06 17 a0 	movle	r6,r8
800087de:	30 32       	mov	r2,3
800087e0:	e0 8f 06 c2 	bral	80009564 <_vfprintf_r+0x1664>
800087e4:	40 2a       	lddsp	r10,sp[0x8]
800087e6:	5b fa       	cp.w	r10,-1
800087e8:	c0 41       	brne	800087f0 <_vfprintf_r+0x8f0>
800087ea:	30 69       	mov	r9,6
800087ec:	50 29       	stdsp	sp[0x8],r9
800087ee:	c1 18       	rjmp	80008810 <_vfprintf_r+0x910>
800087f0:	e0 40 00 47 	cp.w	r0,71
800087f4:	5f 09       	sreq	r9
800087f6:	e0 40 00 67 	cp.w	r0,103
800087fa:	5f 08       	sreq	r8
800087fc:	f3 e8 10 08 	or	r8,r9,r8
80008800:	f8 08 18 00 	cp.b	r8,r12
80008804:	c0 60       	breq	80008810 <_vfprintf_r+0x910>
80008806:	40 28       	lddsp	r8,sp[0x8]
80008808:	58 08       	cp.w	r8,0
8000880a:	f9 b8 00 01 	moveq	r8,1
8000880e:	50 28       	stdsp	sp[0x8],r8
80008810:	40 78       	lddsp	r8,sp[0x1c]
80008812:	40 59       	lddsp	r9,sp[0x14]
80008814:	fa e9 06 94 	st.d	sp[1684],r8
80008818:	a9 a5       	sbr	r5,0x8
8000881a:	fa f8 06 94 	ld.w	r8,sp[1684]
8000881e:	58 08       	cp.w	r8,0
80008820:	c0 65       	brlt	8000882c <_vfprintf_r+0x92c>
80008822:	40 5e       	lddsp	lr,sp[0x14]
80008824:	30 0c       	mov	r12,0
80008826:	50 6e       	stdsp	sp[0x18],lr
80008828:	50 9c       	stdsp	sp[0x24],r12
8000882a:	c0 78       	rjmp	80008838 <_vfprintf_r+0x938>
8000882c:	40 5b       	lddsp	r11,sp[0x14]
8000882e:	32 da       	mov	r10,45
80008830:	ee 1b 80 00 	eorh	r11,0x8000
80008834:	50 9a       	stdsp	sp[0x24],r10
80008836:	50 6b       	stdsp	sp[0x18],r11
80008838:	e0 40 00 46 	cp.w	r0,70
8000883c:	5f 09       	sreq	r9
8000883e:	e0 40 00 66 	cp.w	r0,102
80008842:	5f 08       	sreq	r8
80008844:	f3 e8 10 08 	or	r8,r9,r8
80008848:	50 48       	stdsp	sp[0x10],r8
8000884a:	c0 40       	breq	80008852 <_vfprintf_r+0x952>
8000884c:	40 22       	lddsp	r2,sp[0x8]
8000884e:	30 39       	mov	r9,3
80008850:	c1 08       	rjmp	80008870 <_vfprintf_r+0x970>
80008852:	e0 40 00 45 	cp.w	r0,69
80008856:	5f 09       	sreq	r9
80008858:	e0 40 00 65 	cp.w	r0,101
8000885c:	5f 08       	sreq	r8
8000885e:	40 22       	lddsp	r2,sp[0x8]
80008860:	10 49       	or	r9,r8
80008862:	2f f2       	sub	r2,-1
80008864:	40 46       	lddsp	r6,sp[0x10]
80008866:	ec 09 18 00 	cp.b	r9,r6
8000886a:	fb f2 00 02 	ld.weq	r2,sp[0x8]
8000886e:	30 29       	mov	r9,2
80008870:	fa c8 f9 5c 	sub	r8,sp,-1700
80008874:	1a d8       	st.w	--sp,r8
80008876:	fa c8 f9 54 	sub	r8,sp,-1708
8000887a:	1a d8       	st.w	--sp,r8
8000887c:	fa c8 f9 4c 	sub	r8,sp,-1716
80008880:	08 9c       	mov	r12,r4
80008882:	1a d8       	st.w	--sp,r8
80008884:	04 98       	mov	r8,r2
80008886:	40 9b       	lddsp	r11,sp[0x24]
80008888:	40 aa       	lddsp	r10,sp[0x28]
8000888a:	e0 a0 0b c3 	rcall	8000a010 <_dtoa_r>
8000888e:	e0 40 00 47 	cp.w	r0,71
80008892:	5f 19       	srne	r9
80008894:	e0 40 00 67 	cp.w	r0,103
80008898:	5f 18       	srne	r8
8000889a:	18 96       	mov	r6,r12
8000889c:	2f dd       	sub	sp,-12
8000889e:	f3 e8 00 08 	and	r8,r9,r8
800088a2:	c0 41       	brne	800088aa <_vfprintf_r+0x9aa>
800088a4:	ed b5 00 00 	bld	r5,0x0
800088a8:	c3 01       	brne	80008908 <_vfprintf_r+0xa08>
800088aa:	ec 02 00 0e 	add	lr,r6,r2
800088ae:	50 3e       	stdsp	sp[0xc],lr
800088b0:	40 4c       	lddsp	r12,sp[0x10]
800088b2:	58 0c       	cp.w	r12,0
800088b4:	c1 50       	breq	800088de <_vfprintf_r+0x9de>
800088b6:	0d 89       	ld.ub	r9,r6[0x0]
800088b8:	33 08       	mov	r8,48
800088ba:	f0 09 18 00 	cp.b	r9,r8
800088be:	c0 b1       	brne	800088d4 <_vfprintf_r+0x9d4>
800088c0:	30 08       	mov	r8,0
800088c2:	30 09       	mov	r9,0
800088c4:	40 6b       	lddsp	r11,sp[0x18]
800088c6:	40 7a       	lddsp	r10,sp[0x1c]
800088c8:	e0 a0 1c d7 	rcall	8000c276 <__avr32_f64_cmp_eq>
800088cc:	fb b2 00 01 	rsubeq	r2,1
800088d0:	fb f2 0b ab 	st.weq	sp[0x6ac],r2
800088d4:	40 3b       	lddsp	r11,sp[0xc]
800088d6:	fa f8 06 ac 	ld.w	r8,sp[1708]
800088da:	10 0b       	add	r11,r8
800088dc:	50 3b       	stdsp	sp[0xc],r11
800088de:	40 6b       	lddsp	r11,sp[0x18]
800088e0:	30 08       	mov	r8,0
800088e2:	30 09       	mov	r9,0
800088e4:	40 7a       	lddsp	r10,sp[0x1c]
800088e6:	e0 a0 1c c8 	rcall	8000c276 <__avr32_f64_cmp_eq>
800088ea:	c0 90       	breq	800088fc <_vfprintf_r+0x9fc>
800088ec:	40 3a       	lddsp	r10,sp[0xc]
800088ee:	fb 4a 06 a4 	st.w	sp[1700],r10
800088f2:	c0 58       	rjmp	800088fc <_vfprintf_r+0x9fc>
800088f4:	10 c9       	st.b	r8++,r9
800088f6:	fb 48 06 a4 	st.w	sp[1700],r8
800088fa:	c0 28       	rjmp	800088fe <_vfprintf_r+0x9fe>
800088fc:	33 09       	mov	r9,48
800088fe:	fa f8 06 a4 	ld.w	r8,sp[1700]
80008902:	40 3e       	lddsp	lr,sp[0xc]
80008904:	1c 38       	cp.w	r8,lr
80008906:	cf 73       	brcs	800088f4 <_vfprintf_r+0x9f4>
80008908:	e0 40 00 47 	cp.w	r0,71
8000890c:	5f 09       	sreq	r9
8000890e:	e0 40 00 67 	cp.w	r0,103
80008912:	5f 08       	sreq	r8
80008914:	f3 e8 10 08 	or	r8,r9,r8
80008918:	fa f9 06 a4 	ld.w	r9,sp[1700]
8000891c:	0c 19       	sub	r9,r6
8000891e:	50 69       	stdsp	sp[0x18],r9
80008920:	58 08       	cp.w	r8,0
80008922:	c0 b0       	breq	80008938 <_vfprintf_r+0xa38>
80008924:	fa f8 06 ac 	ld.w	r8,sp[1708]
80008928:	5b d8       	cp.w	r8,-3
8000892a:	c0 55       	brlt	80008934 <_vfprintf_r+0xa34>
8000892c:	40 2c       	lddsp	r12,sp[0x8]
8000892e:	18 38       	cp.w	r8,r12
80008930:	e0 8a 00 6a 	brle	80008a04 <_vfprintf_r+0xb04>
80008934:	20 20       	sub	r0,2
80008936:	c0 58       	rjmp	80008940 <_vfprintf_r+0xa40>
80008938:	e0 40 00 65 	cp.w	r0,101
8000893c:	e0 89 00 46 	brgt	800089c8 <_vfprintf_r+0xac8>
80008940:	fa fb 06 ac 	ld.w	r11,sp[1708]
80008944:	fb 60 06 9c 	st.b	sp[1692],r0
80008948:	20 1b       	sub	r11,1
8000894a:	fb 4b 06 ac 	st.w	sp[1708],r11
8000894e:	c0 47       	brpl	80008956 <_vfprintf_r+0xa56>
80008950:	5c 3b       	neg	r11
80008952:	32 d8       	mov	r8,45
80008954:	c0 28       	rjmp	80008958 <_vfprintf_r+0xa58>
80008956:	32 b8       	mov	r8,43
80008958:	fb 68 06 9d 	st.b	sp[1693],r8
8000895c:	58 9b       	cp.w	r11,9
8000895e:	e0 8a 00 1d 	brle	80008998 <_vfprintf_r+0xa98>
80008962:	fa c9 fa 35 	sub	r9,sp,-1483
80008966:	30 aa       	mov	r10,10
80008968:	12 98       	mov	r8,r9
8000896a:	0e 9c       	mov	r12,r7
8000896c:	0c 92       	mov	r2,r6
8000896e:	f6 0a 0c 06 	divs	r6,r11,r10
80008972:	0e 9b       	mov	r11,r7
80008974:	2d 0b       	sub	r11,-48
80008976:	10 fb       	st.b	--r8,r11
80008978:	0c 9b       	mov	r11,r6
8000897a:	58 96       	cp.w	r6,9
8000897c:	fe 99 ff f9 	brgt	8000896e <_vfprintf_r+0xa6e>
80008980:	2d 0b       	sub	r11,-48
80008982:	18 97       	mov	r7,r12
80008984:	04 96       	mov	r6,r2
80008986:	10 fb       	st.b	--r8,r11
80008988:	fa ca f9 62 	sub	r10,sp,-1694
8000898c:	c0 38       	rjmp	80008992 <_vfprintf_r+0xa92>
8000898e:	11 3b       	ld.ub	r11,r8++
80008990:	14 cb       	st.b	r10++,r11
80008992:	12 38       	cp.w	r8,r9
80008994:	cf d3       	brcs	8000898e <_vfprintf_r+0xa8e>
80008996:	c0 98       	rjmp	800089a8 <_vfprintf_r+0xaa8>
80008998:	2d 0b       	sub	r11,-48
8000899a:	33 08       	mov	r8,48
8000899c:	fb 6b 06 9f 	st.b	sp[1695],r11
800089a0:	fb 68 06 9e 	st.b	sp[1694],r8
800089a4:	fa ca f9 60 	sub	r10,sp,-1696
800089a8:	fa c8 f9 64 	sub	r8,sp,-1692
800089ac:	f4 08 01 08 	sub	r8,r10,r8
800089b0:	50 e8       	stdsp	sp[0x38],r8
800089b2:	10 92       	mov	r2,r8
800089b4:	40 6b       	lddsp	r11,sp[0x18]
800089b6:	16 02       	add	r2,r11
800089b8:	58 1b       	cp.w	r11,1
800089ba:	e0 89 00 05 	brgt	800089c4 <_vfprintf_r+0xac4>
800089be:	ed b5 00 00 	bld	r5,0x0
800089c2:	c3 51       	brne	80008a2c <_vfprintf_r+0xb2c>
800089c4:	2f f2       	sub	r2,-1
800089c6:	c3 38       	rjmp	80008a2c <_vfprintf_r+0xb2c>
800089c8:	e0 40 00 66 	cp.w	r0,102
800089cc:	c1 c1       	brne	80008a04 <_vfprintf_r+0xb04>
800089ce:	fa f2 06 ac 	ld.w	r2,sp[1708]
800089d2:	58 02       	cp.w	r2,0
800089d4:	e0 8a 00 0c 	brle	800089ec <_vfprintf_r+0xaec>
800089d8:	40 2a       	lddsp	r10,sp[0x8]
800089da:	58 0a       	cp.w	r10,0
800089dc:	c0 41       	brne	800089e4 <_vfprintf_r+0xae4>
800089de:	ed b5 00 00 	bld	r5,0x0
800089e2:	c2 51       	brne	80008a2c <_vfprintf_r+0xb2c>
800089e4:	2f f2       	sub	r2,-1
800089e6:	40 29       	lddsp	r9,sp[0x8]
800089e8:	12 02       	add	r2,r9
800089ea:	c0 b8       	rjmp	80008a00 <_vfprintf_r+0xb00>
800089ec:	40 28       	lddsp	r8,sp[0x8]
800089ee:	58 08       	cp.w	r8,0
800089f0:	c0 61       	brne	800089fc <_vfprintf_r+0xafc>
800089f2:	ed b5 00 00 	bld	r5,0x0
800089f6:	c0 30       	breq	800089fc <_vfprintf_r+0xafc>
800089f8:	30 12       	mov	r2,1
800089fa:	c1 98       	rjmp	80008a2c <_vfprintf_r+0xb2c>
800089fc:	40 22       	lddsp	r2,sp[0x8]
800089fe:	2f e2       	sub	r2,-2
80008a00:	36 60       	mov	r0,102
80008a02:	c1 58       	rjmp	80008a2c <_vfprintf_r+0xb2c>
80008a04:	fa f2 06 ac 	ld.w	r2,sp[1708]
80008a08:	40 6e       	lddsp	lr,sp[0x18]
80008a0a:	1c 32       	cp.w	r2,lr
80008a0c:	c0 65       	brlt	80008a18 <_vfprintf_r+0xb18>
80008a0e:	ed b5 00 00 	bld	r5,0x0
80008a12:	f7 b2 00 ff 	subeq	r2,-1
80008a16:	c0 a8       	rjmp	80008a2a <_vfprintf_r+0xb2a>
80008a18:	e4 08 11 02 	rsub	r8,r2,2
80008a1c:	40 6c       	lddsp	r12,sp[0x18]
80008a1e:	58 02       	cp.w	r2,0
80008a20:	f0 02 17 a0 	movle	r2,r8
80008a24:	f9 b2 09 01 	movgt	r2,1
80008a28:	18 02       	add	r2,r12
80008a2a:	36 70       	mov	r0,103
80008a2c:	40 9b       	lddsp	r11,sp[0x24]
80008a2e:	58 0b       	cp.w	r11,0
80008a30:	e0 80 05 94 	breq	80009558 <_vfprintf_r+0x1658>
80008a34:	32 d8       	mov	r8,45
80008a36:	fb 68 06 bb 	st.b	sp[1723],r8
80008a3a:	e0 8f 05 93 	bral	80009560 <_vfprintf_r+0x1660>
80008a3e:	50 a7       	stdsp	sp[0x28],r7
80008a40:	04 94       	mov	r4,r2
80008a42:	0c 97       	mov	r7,r6
80008a44:	02 92       	mov	r2,r1
80008a46:	06 96       	mov	r6,r3
80008a48:	40 41       	lddsp	r1,sp[0x10]
80008a4a:	40 93       	lddsp	r3,sp[0x24]
80008a4c:	0e 99       	mov	r9,r7
80008a4e:	ed b5 00 05 	bld	r5,0x5
80008a52:	c4 81       	brne	80008ae2 <_vfprintf_r+0xbe2>
80008a54:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008a58:	40 3e       	lddsp	lr,sp[0xc]
80008a5a:	58 0e       	cp.w	lr,0
80008a5c:	c1 d0       	breq	80008a96 <_vfprintf_r+0xb96>
80008a5e:	10 36       	cp.w	r6,r8
80008a60:	c0 64       	brge	80008a6c <_vfprintf_r+0xb6c>
80008a62:	fa cc f9 44 	sub	r12,sp,-1724
80008a66:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008a6a:	c1 d8       	rjmp	80008aa4 <_vfprintf_r+0xba4>
80008a6c:	fa c8 f9 50 	sub	r8,sp,-1712
80008a70:	1a d8       	st.w	--sp,r8
80008a72:	fa c8 fa b8 	sub	r8,sp,-1352
80008a76:	04 9a       	mov	r10,r2
80008a78:	1a d8       	st.w	--sp,r8
80008a7a:	fa c8 fb b4 	sub	r8,sp,-1100
80008a7e:	0c 9b       	mov	r11,r6
80008a80:	1a d8       	st.w	--sp,r8
80008a82:	08 9c       	mov	r12,r4
80008a84:	fa c8 f9 40 	sub	r8,sp,-1728
80008a88:	fa c9 ff b4 	sub	r9,sp,-76
80008a8c:	fe b0 f8 a2 	rcall	80007bd0 <get_arg>
80008a90:	2f dd       	sub	sp,-12
80008a92:	78 0a       	ld.w	r10,r12[0x0]
80008a94:	c2 08       	rjmp	80008ad4 <_vfprintf_r+0xbd4>
80008a96:	2f f7       	sub	r7,-1
80008a98:	10 39       	cp.w	r9,r8
80008a9a:	c0 84       	brge	80008aaa <_vfprintf_r+0xbaa>
80008a9c:	fa cb f9 44 	sub	r11,sp,-1724
80008aa0:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008aa4:	ec fa fd 88 	ld.w	r10,r6[-632]
80008aa8:	c1 68       	rjmp	80008ad4 <_vfprintf_r+0xbd4>
80008aaa:	41 09       	lddsp	r9,sp[0x40]
80008aac:	59 f8       	cp.w	r8,31
80008aae:	e0 89 00 10 	brgt	80008ace <_vfprintf_r+0xbce>
80008ab2:	f2 ca ff fc 	sub	r10,r9,-4
80008ab6:	51 0a       	stdsp	sp[0x40],r10
80008ab8:	fa c6 f9 44 	sub	r6,sp,-1724
80008abc:	72 0a       	ld.w	r10,r9[0x0]
80008abe:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008ac2:	f3 4a fd 88 	st.w	r9[-632],r10
80008ac6:	2f f8       	sub	r8,-1
80008ac8:	fb 48 06 b4 	st.w	sp[1716],r8
80008acc:	c0 48       	rjmp	80008ad4 <_vfprintf_r+0xbd4>
80008ace:	72 0a       	ld.w	r10,r9[0x0]
80008ad0:	2f c9       	sub	r9,-4
80008ad2:	51 09       	stdsp	sp[0x40],r9
80008ad4:	40 be       	lddsp	lr,sp[0x2c]
80008ad6:	1c 98       	mov	r8,lr
80008ad8:	95 1e       	st.w	r10[0x4],lr
80008ada:	bf 58       	asr	r8,0x1f
80008adc:	95 08       	st.w	r10[0x0],r8
80008ade:	fe 9f fa 9f 	bral	8000801c <_vfprintf_r+0x11c>
80008ae2:	ed b5 00 04 	bld	r5,0x4
80008ae6:	c4 80       	breq	80008b76 <_vfprintf_r+0xc76>
80008ae8:	e2 15 00 40 	andl	r5,0x40,COH
80008aec:	c4 50       	breq	80008b76 <_vfprintf_r+0xc76>
80008aee:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008af2:	40 3c       	lddsp	r12,sp[0xc]
80008af4:	58 0c       	cp.w	r12,0
80008af6:	c1 d0       	breq	80008b30 <_vfprintf_r+0xc30>
80008af8:	10 36       	cp.w	r6,r8
80008afa:	c0 64       	brge	80008b06 <_vfprintf_r+0xc06>
80008afc:	fa cb f9 44 	sub	r11,sp,-1724
80008b00:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008b04:	c1 d8       	rjmp	80008b3e <_vfprintf_r+0xc3e>
80008b06:	fa c8 f9 50 	sub	r8,sp,-1712
80008b0a:	1a d8       	st.w	--sp,r8
80008b0c:	fa c8 fa b8 	sub	r8,sp,-1352
80008b10:	04 9a       	mov	r10,r2
80008b12:	1a d8       	st.w	--sp,r8
80008b14:	fa c8 fb b4 	sub	r8,sp,-1100
80008b18:	0c 9b       	mov	r11,r6
80008b1a:	1a d8       	st.w	--sp,r8
80008b1c:	08 9c       	mov	r12,r4
80008b1e:	fa c8 f9 40 	sub	r8,sp,-1728
80008b22:	fa c9 ff b4 	sub	r9,sp,-76
80008b26:	fe b0 f8 55 	rcall	80007bd0 <get_arg>
80008b2a:	2f dd       	sub	sp,-12
80008b2c:	78 0a       	ld.w	r10,r12[0x0]
80008b2e:	c2 08       	rjmp	80008b6e <_vfprintf_r+0xc6e>
80008b30:	2f f7       	sub	r7,-1
80008b32:	10 39       	cp.w	r9,r8
80008b34:	c0 84       	brge	80008b44 <_vfprintf_r+0xc44>
80008b36:	fa ca f9 44 	sub	r10,sp,-1724
80008b3a:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008b3e:	ec fa fd 88 	ld.w	r10,r6[-632]
80008b42:	c1 68       	rjmp	80008b6e <_vfprintf_r+0xc6e>
80008b44:	41 09       	lddsp	r9,sp[0x40]
80008b46:	59 f8       	cp.w	r8,31
80008b48:	e0 89 00 10 	brgt	80008b68 <_vfprintf_r+0xc68>
80008b4c:	f2 ca ff fc 	sub	r10,r9,-4
80008b50:	51 0a       	stdsp	sp[0x40],r10
80008b52:	fa c6 f9 44 	sub	r6,sp,-1724
80008b56:	72 0a       	ld.w	r10,r9[0x0]
80008b58:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008b5c:	f3 4a fd 88 	st.w	r9[-632],r10
80008b60:	2f f8       	sub	r8,-1
80008b62:	fb 48 06 b4 	st.w	sp[1716],r8
80008b66:	c0 48       	rjmp	80008b6e <_vfprintf_r+0xc6e>
80008b68:	72 0a       	ld.w	r10,r9[0x0]
80008b6a:	2f c9       	sub	r9,-4
80008b6c:	51 09       	stdsp	sp[0x40],r9
80008b6e:	40 be       	lddsp	lr,sp[0x2c]
80008b70:	b4 0e       	st.h	r10[0x0],lr
80008b72:	fe 9f fa 55 	bral	8000801c <_vfprintf_r+0x11c>
80008b76:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008b7a:	40 3c       	lddsp	r12,sp[0xc]
80008b7c:	58 0c       	cp.w	r12,0
80008b7e:	c1 d0       	breq	80008bb8 <_vfprintf_r+0xcb8>
80008b80:	10 36       	cp.w	r6,r8
80008b82:	c0 64       	brge	80008b8e <_vfprintf_r+0xc8e>
80008b84:	fa cb f9 44 	sub	r11,sp,-1724
80008b88:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008b8c:	c1 d8       	rjmp	80008bc6 <_vfprintf_r+0xcc6>
80008b8e:	fa c8 f9 50 	sub	r8,sp,-1712
80008b92:	1a d8       	st.w	--sp,r8
80008b94:	fa c8 fa b8 	sub	r8,sp,-1352
80008b98:	04 9a       	mov	r10,r2
80008b9a:	1a d8       	st.w	--sp,r8
80008b9c:	fa c8 fb b4 	sub	r8,sp,-1100
80008ba0:	0c 9b       	mov	r11,r6
80008ba2:	1a d8       	st.w	--sp,r8
80008ba4:	08 9c       	mov	r12,r4
80008ba6:	fa c8 f9 40 	sub	r8,sp,-1728
80008baa:	fa c9 ff b4 	sub	r9,sp,-76
80008bae:	fe b0 f8 11 	rcall	80007bd0 <get_arg>
80008bb2:	2f dd       	sub	sp,-12
80008bb4:	78 0a       	ld.w	r10,r12[0x0]
80008bb6:	c2 08       	rjmp	80008bf6 <_vfprintf_r+0xcf6>
80008bb8:	2f f7       	sub	r7,-1
80008bba:	10 39       	cp.w	r9,r8
80008bbc:	c0 84       	brge	80008bcc <_vfprintf_r+0xccc>
80008bbe:	fa ca f9 44 	sub	r10,sp,-1724
80008bc2:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008bc6:	ec fa fd 88 	ld.w	r10,r6[-632]
80008bca:	c1 68       	rjmp	80008bf6 <_vfprintf_r+0xcf6>
80008bcc:	41 09       	lddsp	r9,sp[0x40]
80008bce:	59 f8       	cp.w	r8,31
80008bd0:	e0 89 00 10 	brgt	80008bf0 <_vfprintf_r+0xcf0>
80008bd4:	f2 ca ff fc 	sub	r10,r9,-4
80008bd8:	51 0a       	stdsp	sp[0x40],r10
80008bda:	fa c6 f9 44 	sub	r6,sp,-1724
80008bde:	72 0a       	ld.w	r10,r9[0x0]
80008be0:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008be4:	f3 4a fd 88 	st.w	r9[-632],r10
80008be8:	2f f8       	sub	r8,-1
80008bea:	fb 48 06 b4 	st.w	sp[1716],r8
80008bee:	c0 48       	rjmp	80008bf6 <_vfprintf_r+0xcf6>
80008bf0:	72 0a       	ld.w	r10,r9[0x0]
80008bf2:	2f c9       	sub	r9,-4
80008bf4:	51 09       	stdsp	sp[0x40],r9
80008bf6:	40 be       	lddsp	lr,sp[0x2c]
80008bf8:	95 0e       	st.w	r10[0x0],lr
80008bfa:	fe 9f fa 11 	bral	8000801c <_vfprintf_r+0x11c>
80008bfe:	50 a7       	stdsp	sp[0x28],r7
80008c00:	50 80       	stdsp	sp[0x20],r0
80008c02:	0c 97       	mov	r7,r6
80008c04:	04 94       	mov	r4,r2
80008c06:	06 96       	mov	r6,r3
80008c08:	02 92       	mov	r2,r1
80008c0a:	40 93       	lddsp	r3,sp[0x24]
80008c0c:	10 90       	mov	r0,r8
80008c0e:	40 41       	lddsp	r1,sp[0x10]
80008c10:	a5 a5       	sbr	r5,0x4
80008c12:	c0 a8       	rjmp	80008c26 <_vfprintf_r+0xd26>
80008c14:	50 a7       	stdsp	sp[0x28],r7
80008c16:	50 80       	stdsp	sp[0x20],r0
80008c18:	0c 97       	mov	r7,r6
80008c1a:	04 94       	mov	r4,r2
80008c1c:	06 96       	mov	r6,r3
80008c1e:	02 92       	mov	r2,r1
80008c20:	40 93       	lddsp	r3,sp[0x24]
80008c22:	10 90       	mov	r0,r8
80008c24:	40 41       	lddsp	r1,sp[0x10]
80008c26:	ed b5 00 05 	bld	r5,0x5
80008c2a:	c5 d1       	brne	80008ce4 <_vfprintf_r+0xde4>
80008c2c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008c30:	40 3c       	lddsp	r12,sp[0xc]
80008c32:	58 0c       	cp.w	r12,0
80008c34:	c2 60       	breq	80008c80 <_vfprintf_r+0xd80>
80008c36:	10 36       	cp.w	r6,r8
80008c38:	c0 a4       	brge	80008c4c <_vfprintf_r+0xd4c>
80008c3a:	fa cb f9 44 	sub	r11,sp,-1724
80008c3e:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008c42:	ec e8 fd 88 	ld.d	r8,r6[-632]
80008c46:	fa e9 00 00 	st.d	sp[0],r8
80008c4a:	c1 88       	rjmp	80008c7a <_vfprintf_r+0xd7a>
80008c4c:	fa c8 f9 50 	sub	r8,sp,-1712
80008c50:	1a d8       	st.w	--sp,r8
80008c52:	fa c8 fa b8 	sub	r8,sp,-1352
80008c56:	04 9a       	mov	r10,r2
80008c58:	1a d8       	st.w	--sp,r8
80008c5a:	0c 9b       	mov	r11,r6
80008c5c:	fa c8 fb b4 	sub	r8,sp,-1100
80008c60:	08 9c       	mov	r12,r4
80008c62:	1a d8       	st.w	--sp,r8
80008c64:	fa c8 f9 40 	sub	r8,sp,-1728
80008c68:	fa c9 ff b4 	sub	r9,sp,-76
80008c6c:	fe b0 f7 b2 	rcall	80007bd0 <get_arg>
80008c70:	2f dd       	sub	sp,-12
80008c72:	f8 ea 00 00 	ld.d	r10,r12[0]
80008c76:	fa eb 00 00 	st.d	sp[0],r10
80008c7a:	30 08       	mov	r8,0
80008c7c:	e0 8f 03 de 	bral	80009438 <_vfprintf_r+0x1538>
80008c80:	ee ca ff ff 	sub	r10,r7,-1
80008c84:	10 37       	cp.w	r7,r8
80008c86:	c0 b4       	brge	80008c9c <_vfprintf_r+0xd9c>
80008c88:	fa c9 f9 44 	sub	r9,sp,-1724
80008c8c:	14 97       	mov	r7,r10
80008c8e:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008c92:	ec ea fd 88 	ld.d	r10,r6[-632]
80008c96:	fa eb 00 00 	st.d	sp[0],r10
80008c9a:	c1 88       	rjmp	80008cca <_vfprintf_r+0xdca>
80008c9c:	41 09       	lddsp	r9,sp[0x40]
80008c9e:	59 f8       	cp.w	r8,31
80008ca0:	e0 89 00 18 	brgt	80008cd0 <_vfprintf_r+0xdd0>
80008ca4:	f2 e6 00 00 	ld.d	r6,r9[0]
80008ca8:	f2 cb ff f8 	sub	r11,r9,-8
80008cac:	fa e7 00 00 	st.d	sp[0],r6
80008cb0:	51 0b       	stdsp	sp[0x40],r11
80008cb2:	fa c6 f9 44 	sub	r6,sp,-1724
80008cb6:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008cba:	fa e6 00 00 	ld.d	r6,sp[0]
80008cbe:	f2 e7 fd 88 	st.d	r9[-632],r6
80008cc2:	2f f8       	sub	r8,-1
80008cc4:	14 97       	mov	r7,r10
80008cc6:	fb 48 06 b4 	st.w	sp[1716],r8
80008cca:	40 38       	lddsp	r8,sp[0xc]
80008ccc:	e0 8f 03 b6 	bral	80009438 <_vfprintf_r+0x1538>
80008cd0:	f2 e6 00 00 	ld.d	r6,r9[0]
80008cd4:	40 38       	lddsp	r8,sp[0xc]
80008cd6:	fa e7 00 00 	st.d	sp[0],r6
80008cda:	2f 89       	sub	r9,-8
80008cdc:	14 97       	mov	r7,r10
80008cde:	51 09       	stdsp	sp[0x40],r9
80008ce0:	e0 8f 03 ac 	bral	80009438 <_vfprintf_r+0x1538>
80008ce4:	ed b5 00 04 	bld	r5,0x4
80008ce8:	c1 61       	brne	80008d14 <_vfprintf_r+0xe14>
80008cea:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008cee:	40 3e       	lddsp	lr,sp[0xc]
80008cf0:	58 0e       	cp.w	lr,0
80008cf2:	c0 80       	breq	80008d02 <_vfprintf_r+0xe02>
80008cf4:	10 36       	cp.w	r6,r8
80008cf6:	c6 74       	brge	80008dc4 <_vfprintf_r+0xec4>
80008cf8:	fa cc f9 44 	sub	r12,sp,-1724
80008cfc:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008d00:	c8 08       	rjmp	80008e00 <_vfprintf_r+0xf00>
80008d02:	ee ca ff ff 	sub	r10,r7,-1
80008d06:	10 37       	cp.w	r7,r8
80008d08:	c7 f4       	brge	80008e06 <_vfprintf_r+0xf06>
80008d0a:	fa cb f9 44 	sub	r11,sp,-1724
80008d0e:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008d12:	c7 68       	rjmp	80008dfe <_vfprintf_r+0xefe>
80008d14:	ed b5 00 06 	bld	r5,0x6
80008d18:	c4 a1       	brne	80008dac <_vfprintf_r+0xeac>
80008d1a:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008d1e:	40 3c       	lddsp	r12,sp[0xc]
80008d20:	58 0c       	cp.w	r12,0
80008d22:	c1 d0       	breq	80008d5c <_vfprintf_r+0xe5c>
80008d24:	10 36       	cp.w	r6,r8
80008d26:	c0 64       	brge	80008d32 <_vfprintf_r+0xe32>
80008d28:	fa cb f9 44 	sub	r11,sp,-1724
80008d2c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008d30:	c1 f8       	rjmp	80008d6e <_vfprintf_r+0xe6e>
80008d32:	fa c8 f9 50 	sub	r8,sp,-1712
80008d36:	1a d8       	st.w	--sp,r8
80008d38:	fa c8 fa b8 	sub	r8,sp,-1352
80008d3c:	1a d8       	st.w	--sp,r8
80008d3e:	fa c8 fb b4 	sub	r8,sp,-1100
80008d42:	1a d8       	st.w	--sp,r8
80008d44:	fa c8 f9 40 	sub	r8,sp,-1728
80008d48:	fa c9 ff b4 	sub	r9,sp,-76
80008d4c:	04 9a       	mov	r10,r2
80008d4e:	0c 9b       	mov	r11,r6
80008d50:	08 9c       	mov	r12,r4
80008d52:	fe b0 f7 3f 	rcall	80007bd0 <get_arg>
80008d56:	2f dd       	sub	sp,-12
80008d58:	98 18       	ld.sh	r8,r12[0x2]
80008d5a:	c2 68       	rjmp	80008da6 <_vfprintf_r+0xea6>
80008d5c:	ee ca ff ff 	sub	r10,r7,-1
80008d60:	10 37       	cp.w	r7,r8
80008d62:	c0 94       	brge	80008d74 <_vfprintf_r+0xe74>
80008d64:	fa c9 f9 44 	sub	r9,sp,-1724
80008d68:	14 97       	mov	r7,r10
80008d6a:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008d6e:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80008d72:	c1 a8       	rjmp	80008da6 <_vfprintf_r+0xea6>
80008d74:	41 09       	lddsp	r9,sp[0x40]
80008d76:	59 f8       	cp.w	r8,31
80008d78:	e0 89 00 13 	brgt	80008d9e <_vfprintf_r+0xe9e>
80008d7c:	f2 cb ff fc 	sub	r11,r9,-4
80008d80:	51 0b       	stdsp	sp[0x40],r11
80008d82:	72 09       	ld.w	r9,r9[0x0]
80008d84:	fa c6 f9 44 	sub	r6,sp,-1724
80008d88:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80008d8c:	2f f8       	sub	r8,-1
80008d8e:	f7 49 fd 88 	st.w	r11[-632],r9
80008d92:	fb 48 06 b4 	st.w	sp[1716],r8
80008d96:	14 97       	mov	r7,r10
80008d98:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80008d9c:	c0 58       	rjmp	80008da6 <_vfprintf_r+0xea6>
80008d9e:	92 18       	ld.sh	r8,r9[0x2]
80008da0:	14 97       	mov	r7,r10
80008da2:	2f c9       	sub	r9,-4
80008da4:	51 09       	stdsp	sp[0x40],r9
80008da6:	5c 78       	castu.h	r8
80008da8:	50 18       	stdsp	sp[0x4],r8
80008daa:	c4 68       	rjmp	80008e36 <_vfprintf_r+0xf36>
80008dac:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008db0:	40 3c       	lddsp	r12,sp[0xc]
80008db2:	58 0c       	cp.w	r12,0
80008db4:	c1 d0       	breq	80008dee <_vfprintf_r+0xeee>
80008db6:	10 36       	cp.w	r6,r8
80008db8:	c0 64       	brge	80008dc4 <_vfprintf_r+0xec4>
80008dba:	fa cb f9 44 	sub	r11,sp,-1724
80008dbe:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008dc2:	c1 f8       	rjmp	80008e00 <_vfprintf_r+0xf00>
80008dc4:	fa c8 f9 50 	sub	r8,sp,-1712
80008dc8:	1a d8       	st.w	--sp,r8
80008dca:	fa c8 fa b8 	sub	r8,sp,-1352
80008dce:	0c 9b       	mov	r11,r6
80008dd0:	1a d8       	st.w	--sp,r8
80008dd2:	fa c8 fb b4 	sub	r8,sp,-1100
80008dd6:	04 9a       	mov	r10,r2
80008dd8:	1a d8       	st.w	--sp,r8
80008dda:	08 9c       	mov	r12,r4
80008ddc:	fa c8 f9 40 	sub	r8,sp,-1728
80008de0:	fa c9 ff b4 	sub	r9,sp,-76
80008de4:	fe b0 f6 f6 	rcall	80007bd0 <get_arg>
80008de8:	2f dd       	sub	sp,-12
80008dea:	78 0b       	ld.w	r11,r12[0x0]
80008dec:	c2 48       	rjmp	80008e34 <_vfprintf_r+0xf34>
80008dee:	ee ca ff ff 	sub	r10,r7,-1
80008df2:	10 37       	cp.w	r7,r8
80008df4:	c0 94       	brge	80008e06 <_vfprintf_r+0xf06>
80008df6:	fa c9 f9 44 	sub	r9,sp,-1724
80008dfa:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008dfe:	14 97       	mov	r7,r10
80008e00:	ec fb fd 88 	ld.w	r11,r6[-632]
80008e04:	c1 88       	rjmp	80008e34 <_vfprintf_r+0xf34>
80008e06:	41 09       	lddsp	r9,sp[0x40]
80008e08:	59 f8       	cp.w	r8,31
80008e0a:	e0 89 00 11 	brgt	80008e2c <_vfprintf_r+0xf2c>
80008e0e:	f2 cb ff fc 	sub	r11,r9,-4
80008e12:	51 0b       	stdsp	sp[0x40],r11
80008e14:	fa c6 f9 44 	sub	r6,sp,-1724
80008e18:	72 0b       	ld.w	r11,r9[0x0]
80008e1a:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008e1e:	f3 4b fd 88 	st.w	r9[-632],r11
80008e22:	2f f8       	sub	r8,-1
80008e24:	14 97       	mov	r7,r10
80008e26:	fb 48 06 b4 	st.w	sp[1716],r8
80008e2a:	c0 58       	rjmp	80008e34 <_vfprintf_r+0xf34>
80008e2c:	72 0b       	ld.w	r11,r9[0x0]
80008e2e:	14 97       	mov	r7,r10
80008e30:	2f c9       	sub	r9,-4
80008e32:	51 09       	stdsp	sp[0x40],r9
80008e34:	50 1b       	stdsp	sp[0x4],r11
80008e36:	30 0e       	mov	lr,0
80008e38:	50 0e       	stdsp	sp[0x0],lr
80008e3a:	1c 98       	mov	r8,lr
80008e3c:	e0 8f 02 fe 	bral	80009438 <_vfprintf_r+0x1538>
80008e40:	50 a7       	stdsp	sp[0x28],r7
80008e42:	50 80       	stdsp	sp[0x20],r0
80008e44:	0c 97       	mov	r7,r6
80008e46:	04 94       	mov	r4,r2
80008e48:	06 96       	mov	r6,r3
80008e4a:	02 92       	mov	r2,r1
80008e4c:	40 93       	lddsp	r3,sp[0x24]
80008e4e:	40 41       	lddsp	r1,sp[0x10]
80008e50:	0e 99       	mov	r9,r7
80008e52:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008e56:	40 3c       	lddsp	r12,sp[0xc]
80008e58:	58 0c       	cp.w	r12,0
80008e5a:	c1 d0       	breq	80008e94 <_vfprintf_r+0xf94>
80008e5c:	10 36       	cp.w	r6,r8
80008e5e:	c0 64       	brge	80008e6a <_vfprintf_r+0xf6a>
80008e60:	fa cb f9 44 	sub	r11,sp,-1724
80008e64:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008e68:	c1 d8       	rjmp	80008ea2 <_vfprintf_r+0xfa2>
80008e6a:	fa c8 f9 50 	sub	r8,sp,-1712
80008e6e:	1a d8       	st.w	--sp,r8
80008e70:	fa c8 fa b8 	sub	r8,sp,-1352
80008e74:	1a d8       	st.w	--sp,r8
80008e76:	fa c8 fb b4 	sub	r8,sp,-1100
80008e7a:	1a d8       	st.w	--sp,r8
80008e7c:	fa c9 ff b4 	sub	r9,sp,-76
80008e80:	fa c8 f9 40 	sub	r8,sp,-1728
80008e84:	04 9a       	mov	r10,r2
80008e86:	0c 9b       	mov	r11,r6
80008e88:	08 9c       	mov	r12,r4
80008e8a:	fe b0 f6 a3 	rcall	80007bd0 <get_arg>
80008e8e:	2f dd       	sub	sp,-12
80008e90:	78 09       	ld.w	r9,r12[0x0]
80008e92:	c2 18       	rjmp	80008ed4 <_vfprintf_r+0xfd4>
80008e94:	2f f7       	sub	r7,-1
80008e96:	10 39       	cp.w	r9,r8
80008e98:	c0 84       	brge	80008ea8 <_vfprintf_r+0xfa8>
80008e9a:	fa ca f9 44 	sub	r10,sp,-1724
80008e9e:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008ea2:	ec f9 fd 88 	ld.w	r9,r6[-632]
80008ea6:	c1 78       	rjmp	80008ed4 <_vfprintf_r+0xfd4>
80008ea8:	41 09       	lddsp	r9,sp[0x40]
80008eaa:	59 f8       	cp.w	r8,31
80008eac:	e0 89 00 10 	brgt	80008ecc <_vfprintf_r+0xfcc>
80008eb0:	f2 ca ff fc 	sub	r10,r9,-4
80008eb4:	51 0a       	stdsp	sp[0x40],r10
80008eb6:	fa c6 f9 44 	sub	r6,sp,-1724
80008eba:	72 09       	ld.w	r9,r9[0x0]
80008ebc:	ec 08 00 3a 	add	r10,r6,r8<<0x3
80008ec0:	f5 49 fd 88 	st.w	r10[-632],r9
80008ec4:	2f f8       	sub	r8,-1
80008ec6:	fb 48 06 b4 	st.w	sp[1716],r8
80008eca:	c0 58       	rjmp	80008ed4 <_vfprintf_r+0xfd4>
80008ecc:	f2 c8 ff fc 	sub	r8,r9,-4
80008ed0:	51 08       	stdsp	sp[0x40],r8
80008ed2:	72 09       	ld.w	r9,r9[0x0]
80008ed4:	33 08       	mov	r8,48
80008ed6:	fb 68 06 b8 	st.b	sp[1720],r8
80008eda:	37 88       	mov	r8,120
80008edc:	30 0e       	mov	lr,0
80008ede:	fb 68 06 b9 	st.b	sp[1721],r8
80008ee2:	fe cc b1 16 	sub	r12,pc,-20202
80008ee6:	50 19       	stdsp	sp[0x4],r9
80008ee8:	a1 b5       	sbr	r5,0x1
80008eea:	50 0e       	stdsp	sp[0x0],lr
80008eec:	50 dc       	stdsp	sp[0x34],r12
80008eee:	30 28       	mov	r8,2
80008ef0:	37 80       	mov	r0,120
80008ef2:	e0 8f 02 a3 	bral	80009438 <_vfprintf_r+0x1538>
80008ef6:	50 a7       	stdsp	sp[0x28],r7
80008ef8:	50 80       	stdsp	sp[0x20],r0
80008efa:	10 90       	mov	r0,r8
80008efc:	30 08       	mov	r8,0
80008efe:	fb 68 06 bb 	st.b	sp[1723],r8
80008f02:	0c 97       	mov	r7,r6
80008f04:	04 94       	mov	r4,r2
80008f06:	06 96       	mov	r6,r3
80008f08:	02 92       	mov	r2,r1
80008f0a:	40 93       	lddsp	r3,sp[0x24]
80008f0c:	40 41       	lddsp	r1,sp[0x10]
80008f0e:	0e 99       	mov	r9,r7
80008f10:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008f14:	40 3b       	lddsp	r11,sp[0xc]
80008f16:	58 0b       	cp.w	r11,0
80008f18:	c1 d0       	breq	80008f52 <_vfprintf_r+0x1052>
80008f1a:	10 36       	cp.w	r6,r8
80008f1c:	c0 64       	brge	80008f28 <_vfprintf_r+0x1028>
80008f1e:	fa ca f9 44 	sub	r10,sp,-1724
80008f22:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008f26:	c1 d8       	rjmp	80008f60 <_vfprintf_r+0x1060>
80008f28:	fa c8 f9 50 	sub	r8,sp,-1712
80008f2c:	1a d8       	st.w	--sp,r8
80008f2e:	fa c8 fa b8 	sub	r8,sp,-1352
80008f32:	1a d8       	st.w	--sp,r8
80008f34:	fa c8 fb b4 	sub	r8,sp,-1100
80008f38:	0c 9b       	mov	r11,r6
80008f3a:	1a d8       	st.w	--sp,r8
80008f3c:	04 9a       	mov	r10,r2
80008f3e:	fa c8 f9 40 	sub	r8,sp,-1728
80008f42:	fa c9 ff b4 	sub	r9,sp,-76
80008f46:	08 9c       	mov	r12,r4
80008f48:	fe b0 f6 44 	rcall	80007bd0 <get_arg>
80008f4c:	2f dd       	sub	sp,-12
80008f4e:	78 06       	ld.w	r6,r12[0x0]
80008f50:	c2 08       	rjmp	80008f90 <_vfprintf_r+0x1090>
80008f52:	2f f7       	sub	r7,-1
80008f54:	10 39       	cp.w	r9,r8
80008f56:	c0 84       	brge	80008f66 <_vfprintf_r+0x1066>
80008f58:	fa c9 f9 44 	sub	r9,sp,-1724
80008f5c:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008f60:	ec f6 fd 88 	ld.w	r6,r6[-632]
80008f64:	c1 68       	rjmp	80008f90 <_vfprintf_r+0x1090>
80008f66:	41 09       	lddsp	r9,sp[0x40]
80008f68:	59 f8       	cp.w	r8,31
80008f6a:	e0 89 00 10 	brgt	80008f8a <_vfprintf_r+0x108a>
80008f6e:	f2 ca ff fc 	sub	r10,r9,-4
80008f72:	51 0a       	stdsp	sp[0x40],r10
80008f74:	72 06       	ld.w	r6,r9[0x0]
80008f76:	fa ce f9 44 	sub	lr,sp,-1724
80008f7a:	fc 08 00 39 	add	r9,lr,r8<<0x3
80008f7e:	f3 46 fd 88 	st.w	r9[-632],r6
80008f82:	2f f8       	sub	r8,-1
80008f84:	fb 48 06 b4 	st.w	sp[1716],r8
80008f88:	c0 48       	rjmp	80008f90 <_vfprintf_r+0x1090>
80008f8a:	72 06       	ld.w	r6,r9[0x0]
80008f8c:	2f c9       	sub	r9,-4
80008f8e:	51 09       	stdsp	sp[0x40],r9
80008f90:	40 2c       	lddsp	r12,sp[0x8]
80008f92:	58 0c       	cp.w	r12,0
80008f94:	c1 05       	brlt	80008fb4 <_vfprintf_r+0x10b4>
80008f96:	18 9a       	mov	r10,r12
80008f98:	30 0b       	mov	r11,0
80008f9a:	0c 9c       	mov	r12,r6
80008f9c:	e0 a0 12 38 	rcall	8000b40c <memchr>
80008fa0:	e0 80 02 df 	breq	8000955e <_vfprintf_r+0x165e>
80008fa4:	f8 06 01 02 	sub	r2,r12,r6
80008fa8:	40 2b       	lddsp	r11,sp[0x8]
80008faa:	16 32       	cp.w	r2,r11
80008fac:	e0 89 02 d9 	brgt	8000955e <_vfprintf_r+0x165e>
80008fb0:	e0 8f 02 d4 	bral	80009558 <_vfprintf_r+0x1658>
80008fb4:	30 0a       	mov	r10,0
80008fb6:	0c 9c       	mov	r12,r6
80008fb8:	50 2a       	stdsp	sp[0x8],r10
80008fba:	e0 a0 15 99 	rcall	8000baec <strlen>
80008fbe:	18 92       	mov	r2,r12
80008fc0:	e0 8f 02 d2 	bral	80009564 <_vfprintf_r+0x1664>
80008fc4:	50 a7       	stdsp	sp[0x28],r7
80008fc6:	50 80       	stdsp	sp[0x20],r0
80008fc8:	0c 97       	mov	r7,r6
80008fca:	04 94       	mov	r4,r2
80008fcc:	06 96       	mov	r6,r3
80008fce:	02 92       	mov	r2,r1
80008fd0:	40 93       	lddsp	r3,sp[0x24]
80008fd2:	10 90       	mov	r0,r8
80008fd4:	40 41       	lddsp	r1,sp[0x10]
80008fd6:	a5 a5       	sbr	r5,0x4
80008fd8:	c0 a8       	rjmp	80008fec <_vfprintf_r+0x10ec>
80008fda:	50 a7       	stdsp	sp[0x28],r7
80008fdc:	50 80       	stdsp	sp[0x20],r0
80008fde:	0c 97       	mov	r7,r6
80008fe0:	04 94       	mov	r4,r2
80008fe2:	06 96       	mov	r6,r3
80008fe4:	02 92       	mov	r2,r1
80008fe6:	40 93       	lddsp	r3,sp[0x24]
80008fe8:	10 90       	mov	r0,r8
80008fea:	40 41       	lddsp	r1,sp[0x10]
80008fec:	ed b5 00 05 	bld	r5,0x5
80008ff0:	c5 61       	brne	8000909c <_vfprintf_r+0x119c>
80008ff2:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008ff6:	40 39       	lddsp	r9,sp[0xc]
80008ff8:	58 09       	cp.w	r9,0
80008ffa:	c2 10       	breq	8000903c <_vfprintf_r+0x113c>
80008ffc:	10 36       	cp.w	r6,r8
80008ffe:	c0 74       	brge	8000900c <_vfprintf_r+0x110c>
80009000:	fa c8 f9 44 	sub	r8,sp,-1724
80009004:	f0 06 00 36 	add	r6,r8,r6<<0x3
80009008:	c2 38       	rjmp	8000904e <_vfprintf_r+0x114e>
8000900a:	d7 03       	nop
8000900c:	fa c8 f9 50 	sub	r8,sp,-1712
80009010:	1a d8       	st.w	--sp,r8
80009012:	fa c8 fa b8 	sub	r8,sp,-1352
80009016:	1a d8       	st.w	--sp,r8
80009018:	fa c8 fb b4 	sub	r8,sp,-1100
8000901c:	1a d8       	st.w	--sp,r8
8000901e:	fa c8 f9 40 	sub	r8,sp,-1728
80009022:	fa c9 ff b4 	sub	r9,sp,-76
80009026:	04 9a       	mov	r10,r2
80009028:	0c 9b       	mov	r11,r6
8000902a:	08 9c       	mov	r12,r4
8000902c:	fe b0 f5 d2 	rcall	80007bd0 <get_arg>
80009030:	2f dd       	sub	sp,-12
80009032:	f8 e8 00 00 	ld.d	r8,r12[0]
80009036:	fa e9 00 00 	st.d	sp[0],r8
8000903a:	c2 e8       	rjmp	80009096 <_vfprintf_r+0x1196>
8000903c:	ee ca ff ff 	sub	r10,r7,-1
80009040:	10 37       	cp.w	r7,r8
80009042:	c0 b4       	brge	80009058 <_vfprintf_r+0x1158>
80009044:	fa c8 f9 44 	sub	r8,sp,-1724
80009048:	14 97       	mov	r7,r10
8000904a:	f0 06 00 36 	add	r6,r8,r6<<0x3
8000904e:	ec ea fd 88 	ld.d	r10,r6[-632]
80009052:	fa eb 00 00 	st.d	sp[0],r10
80009056:	c2 08       	rjmp	80009096 <_vfprintf_r+0x1196>
80009058:	41 09       	lddsp	r9,sp[0x40]
8000905a:	59 f8       	cp.w	r8,31
8000905c:	e0 89 00 16 	brgt	80009088 <_vfprintf_r+0x1188>
80009060:	f2 e6 00 00 	ld.d	r6,r9[0]
80009064:	f2 cb ff f8 	sub	r11,r9,-8
80009068:	fa e7 00 00 	st.d	sp[0],r6
8000906c:	51 0b       	stdsp	sp[0x40],r11
8000906e:	fa c6 f9 44 	sub	r6,sp,-1724
80009072:	ec 08 00 39 	add	r9,r6,r8<<0x3
80009076:	fa e6 00 00 	ld.d	r6,sp[0]
8000907a:	f2 e7 fd 88 	st.d	r9[-632],r6
8000907e:	2f f8       	sub	r8,-1
80009080:	14 97       	mov	r7,r10
80009082:	fb 48 06 b4 	st.w	sp[1716],r8
80009086:	c0 88       	rjmp	80009096 <_vfprintf_r+0x1196>
80009088:	f2 e6 00 00 	ld.d	r6,r9[0]
8000908c:	2f 89       	sub	r9,-8
8000908e:	fa e7 00 00 	st.d	sp[0],r6
80009092:	51 09       	stdsp	sp[0x40],r9
80009094:	14 97       	mov	r7,r10
80009096:	30 18       	mov	r8,1
80009098:	e0 8f 01 d0 	bral	80009438 <_vfprintf_r+0x1538>
8000909c:	ed b5 00 04 	bld	r5,0x4
800090a0:	c1 61       	brne	800090cc <_vfprintf_r+0x11cc>
800090a2:	fa f8 06 b4 	ld.w	r8,sp[1716]
800090a6:	40 3e       	lddsp	lr,sp[0xc]
800090a8:	58 0e       	cp.w	lr,0
800090aa:	c0 80       	breq	800090ba <_vfprintf_r+0x11ba>
800090ac:	10 36       	cp.w	r6,r8
800090ae:	c6 74       	brge	8000917c <_vfprintf_r+0x127c>
800090b0:	fa cc f9 44 	sub	r12,sp,-1724
800090b4:	f8 06 00 36 	add	r6,r12,r6<<0x3
800090b8:	c8 08       	rjmp	800091b8 <_vfprintf_r+0x12b8>
800090ba:	ee ca ff ff 	sub	r10,r7,-1
800090be:	10 37       	cp.w	r7,r8
800090c0:	c7 f4       	brge	800091be <_vfprintf_r+0x12be>
800090c2:	fa cb f9 44 	sub	r11,sp,-1724
800090c6:	f6 06 00 36 	add	r6,r11,r6<<0x3
800090ca:	c7 68       	rjmp	800091b6 <_vfprintf_r+0x12b6>
800090cc:	ed b5 00 06 	bld	r5,0x6
800090d0:	c4 a1       	brne	80009164 <_vfprintf_r+0x1264>
800090d2:	fa f8 06 b4 	ld.w	r8,sp[1716]
800090d6:	40 3c       	lddsp	r12,sp[0xc]
800090d8:	58 0c       	cp.w	r12,0
800090da:	c1 d0       	breq	80009114 <_vfprintf_r+0x1214>
800090dc:	10 36       	cp.w	r6,r8
800090de:	c0 64       	brge	800090ea <_vfprintf_r+0x11ea>
800090e0:	fa cb f9 44 	sub	r11,sp,-1724
800090e4:	f6 06 00 36 	add	r6,r11,r6<<0x3
800090e8:	c1 f8       	rjmp	80009126 <_vfprintf_r+0x1226>
800090ea:	fa c8 f9 50 	sub	r8,sp,-1712
800090ee:	1a d8       	st.w	--sp,r8
800090f0:	fa c8 fa b8 	sub	r8,sp,-1352
800090f4:	1a d8       	st.w	--sp,r8
800090f6:	fa c8 fb b4 	sub	r8,sp,-1100
800090fa:	1a d8       	st.w	--sp,r8
800090fc:	fa c8 f9 40 	sub	r8,sp,-1728
80009100:	fa c9 ff b4 	sub	r9,sp,-76
80009104:	04 9a       	mov	r10,r2
80009106:	0c 9b       	mov	r11,r6
80009108:	08 9c       	mov	r12,r4
8000910a:	fe b0 f5 63 	rcall	80007bd0 <get_arg>
8000910e:	2f dd       	sub	sp,-12
80009110:	98 18       	ld.sh	r8,r12[0x2]
80009112:	c2 68       	rjmp	8000915e <_vfprintf_r+0x125e>
80009114:	ee ca ff ff 	sub	r10,r7,-1
80009118:	10 37       	cp.w	r7,r8
8000911a:	c0 94       	brge	8000912c <_vfprintf_r+0x122c>
8000911c:	fa c9 f9 44 	sub	r9,sp,-1724
80009120:	14 97       	mov	r7,r10
80009122:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009126:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000912a:	c1 a8       	rjmp	8000915e <_vfprintf_r+0x125e>
8000912c:	41 09       	lddsp	r9,sp[0x40]
8000912e:	59 f8       	cp.w	r8,31
80009130:	e0 89 00 13 	brgt	80009156 <_vfprintf_r+0x1256>
80009134:	f2 cb ff fc 	sub	r11,r9,-4
80009138:	51 0b       	stdsp	sp[0x40],r11
8000913a:	72 09       	ld.w	r9,r9[0x0]
8000913c:	fa c6 f9 44 	sub	r6,sp,-1724
80009140:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80009144:	2f f8       	sub	r8,-1
80009146:	f7 49 fd 88 	st.w	r11[-632],r9
8000914a:	fb 48 06 b4 	st.w	sp[1716],r8
8000914e:	14 97       	mov	r7,r10
80009150:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80009154:	c0 58       	rjmp	8000915e <_vfprintf_r+0x125e>
80009156:	92 18       	ld.sh	r8,r9[0x2]
80009158:	14 97       	mov	r7,r10
8000915a:	2f c9       	sub	r9,-4
8000915c:	51 09       	stdsp	sp[0x40],r9
8000915e:	5c 78       	castu.h	r8
80009160:	50 18       	stdsp	sp[0x4],r8
80009162:	c4 68       	rjmp	800091ee <_vfprintf_r+0x12ee>
80009164:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009168:	40 3c       	lddsp	r12,sp[0xc]
8000916a:	58 0c       	cp.w	r12,0
8000916c:	c1 d0       	breq	800091a6 <_vfprintf_r+0x12a6>
8000916e:	10 36       	cp.w	r6,r8
80009170:	c0 64       	brge	8000917c <_vfprintf_r+0x127c>
80009172:	fa cb f9 44 	sub	r11,sp,-1724
80009176:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000917a:	c1 f8       	rjmp	800091b8 <_vfprintf_r+0x12b8>
8000917c:	fa c8 f9 50 	sub	r8,sp,-1712
80009180:	1a d8       	st.w	--sp,r8
80009182:	fa c8 fa b8 	sub	r8,sp,-1352
80009186:	0c 9b       	mov	r11,r6
80009188:	1a d8       	st.w	--sp,r8
8000918a:	fa c8 fb b4 	sub	r8,sp,-1100
8000918e:	04 9a       	mov	r10,r2
80009190:	1a d8       	st.w	--sp,r8
80009192:	08 9c       	mov	r12,r4
80009194:	fa c8 f9 40 	sub	r8,sp,-1728
80009198:	fa c9 ff b4 	sub	r9,sp,-76
8000919c:	fe b0 f5 1a 	rcall	80007bd0 <get_arg>
800091a0:	2f dd       	sub	sp,-12
800091a2:	78 0b       	ld.w	r11,r12[0x0]
800091a4:	c2 48       	rjmp	800091ec <_vfprintf_r+0x12ec>
800091a6:	ee ca ff ff 	sub	r10,r7,-1
800091aa:	10 37       	cp.w	r7,r8
800091ac:	c0 94       	brge	800091be <_vfprintf_r+0x12be>
800091ae:	fa c9 f9 44 	sub	r9,sp,-1724
800091b2:	f2 06 00 36 	add	r6,r9,r6<<0x3
800091b6:	14 97       	mov	r7,r10
800091b8:	ec fb fd 88 	ld.w	r11,r6[-632]
800091bc:	c1 88       	rjmp	800091ec <_vfprintf_r+0x12ec>
800091be:	41 09       	lddsp	r9,sp[0x40]
800091c0:	59 f8       	cp.w	r8,31
800091c2:	e0 89 00 11 	brgt	800091e4 <_vfprintf_r+0x12e4>
800091c6:	f2 cb ff fc 	sub	r11,r9,-4
800091ca:	51 0b       	stdsp	sp[0x40],r11
800091cc:	fa c6 f9 44 	sub	r6,sp,-1724
800091d0:	72 0b       	ld.w	r11,r9[0x0]
800091d2:	ec 08 00 39 	add	r9,r6,r8<<0x3
800091d6:	f3 4b fd 88 	st.w	r9[-632],r11
800091da:	2f f8       	sub	r8,-1
800091dc:	14 97       	mov	r7,r10
800091de:	fb 48 06 b4 	st.w	sp[1716],r8
800091e2:	c0 58       	rjmp	800091ec <_vfprintf_r+0x12ec>
800091e4:	72 0b       	ld.w	r11,r9[0x0]
800091e6:	14 97       	mov	r7,r10
800091e8:	2f c9       	sub	r9,-4
800091ea:	51 09       	stdsp	sp[0x40],r9
800091ec:	50 1b       	stdsp	sp[0x4],r11
800091ee:	30 0e       	mov	lr,0
800091f0:	30 18       	mov	r8,1
800091f2:	50 0e       	stdsp	sp[0x0],lr
800091f4:	c2 29       	rjmp	80009438 <_vfprintf_r+0x1538>
800091f6:	50 a7       	stdsp	sp[0x28],r7
800091f8:	50 80       	stdsp	sp[0x20],r0
800091fa:	0c 97       	mov	r7,r6
800091fc:	04 94       	mov	r4,r2
800091fe:	06 96       	mov	r6,r3
80009200:	02 92       	mov	r2,r1
80009202:	fe cc b4 36 	sub	r12,pc,-19402
80009206:	40 93       	lddsp	r3,sp[0x24]
80009208:	10 90       	mov	r0,r8
8000920a:	40 41       	lddsp	r1,sp[0x10]
8000920c:	50 dc       	stdsp	sp[0x34],r12
8000920e:	ed b5 00 05 	bld	r5,0x5
80009212:	c5 51       	brne	800092bc <_vfprintf_r+0x13bc>
80009214:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009218:	40 3b       	lddsp	r11,sp[0xc]
8000921a:	58 0b       	cp.w	r11,0
8000921c:	c2 20       	breq	80009260 <_vfprintf_r+0x1360>
8000921e:	10 36       	cp.w	r6,r8
80009220:	c0 a4       	brge	80009234 <_vfprintf_r+0x1334>
80009222:	fa ca f9 44 	sub	r10,sp,-1724
80009226:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000922a:	ec e8 fd 88 	ld.d	r8,r6[-632]
8000922e:	fa e9 00 00 	st.d	sp[0],r8
80009232:	cf 28       	rjmp	80009416 <_vfprintf_r+0x1516>
80009234:	fa c8 f9 50 	sub	r8,sp,-1712
80009238:	1a d8       	st.w	--sp,r8
8000923a:	fa c8 fa b8 	sub	r8,sp,-1352
8000923e:	04 9a       	mov	r10,r2
80009240:	1a d8       	st.w	--sp,r8
80009242:	0c 9b       	mov	r11,r6
80009244:	fa c8 fb b4 	sub	r8,sp,-1100
80009248:	08 9c       	mov	r12,r4
8000924a:	1a d8       	st.w	--sp,r8
8000924c:	fa c8 f9 40 	sub	r8,sp,-1728
80009250:	fa c9 ff b4 	sub	r9,sp,-76
80009254:	fe b0 f4 be 	rcall	80007bd0 <get_arg>
80009258:	2f dd       	sub	sp,-12
8000925a:	f8 ea 00 00 	ld.d	r10,r12[0]
8000925e:	c0 c8       	rjmp	80009276 <_vfprintf_r+0x1376>
80009260:	ee ca ff ff 	sub	r10,r7,-1
80009264:	10 37       	cp.w	r7,r8
80009266:	c0 b4       	brge	8000927c <_vfprintf_r+0x137c>
80009268:	fa c9 f9 44 	sub	r9,sp,-1724
8000926c:	14 97       	mov	r7,r10
8000926e:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009272:	ec ea fd 88 	ld.d	r10,r6[-632]
80009276:	fa eb 00 00 	st.d	sp[0],r10
8000927a:	cc e8       	rjmp	80009416 <_vfprintf_r+0x1516>
8000927c:	41 09       	lddsp	r9,sp[0x40]
8000927e:	59 f8       	cp.w	r8,31
80009280:	e0 89 00 16 	brgt	800092ac <_vfprintf_r+0x13ac>
80009284:	f2 e6 00 00 	ld.d	r6,r9[0]
80009288:	f2 cb ff f8 	sub	r11,r9,-8
8000928c:	fa e7 00 00 	st.d	sp[0],r6
80009290:	51 0b       	stdsp	sp[0x40],r11
80009292:	fa c6 f9 44 	sub	r6,sp,-1724
80009296:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000929a:	fa e6 00 00 	ld.d	r6,sp[0]
8000929e:	f2 e7 fd 88 	st.d	r9[-632],r6
800092a2:	2f f8       	sub	r8,-1
800092a4:	14 97       	mov	r7,r10
800092a6:	fb 48 06 b4 	st.w	sp[1716],r8
800092aa:	cb 68       	rjmp	80009416 <_vfprintf_r+0x1516>
800092ac:	f2 e6 00 00 	ld.d	r6,r9[0]
800092b0:	2f 89       	sub	r9,-8
800092b2:	fa e7 00 00 	st.d	sp[0],r6
800092b6:	51 09       	stdsp	sp[0x40],r9
800092b8:	14 97       	mov	r7,r10
800092ba:	ca e8       	rjmp	80009416 <_vfprintf_r+0x1516>
800092bc:	ed b5 00 04 	bld	r5,0x4
800092c0:	c1 71       	brne	800092ee <_vfprintf_r+0x13ee>
800092c2:	fa f8 06 b4 	ld.w	r8,sp[1716]
800092c6:	40 3e       	lddsp	lr,sp[0xc]
800092c8:	58 0e       	cp.w	lr,0
800092ca:	c0 80       	breq	800092da <_vfprintf_r+0x13da>
800092cc:	10 36       	cp.w	r6,r8
800092ce:	c6 94       	brge	800093a0 <_vfprintf_r+0x14a0>
800092d0:	fa cc f9 44 	sub	r12,sp,-1724
800092d4:	f8 06 00 36 	add	r6,r12,r6<<0x3
800092d8:	c8 28       	rjmp	800093dc <_vfprintf_r+0x14dc>
800092da:	ee ca ff ff 	sub	r10,r7,-1
800092de:	10 37       	cp.w	r7,r8
800092e0:	e0 84 00 81 	brge	800093e2 <_vfprintf_r+0x14e2>
800092e4:	fa cb f9 44 	sub	r11,sp,-1724
800092e8:	f6 06 00 36 	add	r6,r11,r6<<0x3
800092ec:	c7 78       	rjmp	800093da <_vfprintf_r+0x14da>
800092ee:	ed b5 00 06 	bld	r5,0x6
800092f2:	c4 b1       	brne	80009388 <_vfprintf_r+0x1488>
800092f4:	fa f8 06 b4 	ld.w	r8,sp[1716]
800092f8:	40 3c       	lddsp	r12,sp[0xc]
800092fa:	58 0c       	cp.w	r12,0
800092fc:	c1 d0       	breq	80009336 <_vfprintf_r+0x1436>
800092fe:	10 36       	cp.w	r6,r8
80009300:	c0 64       	brge	8000930c <_vfprintf_r+0x140c>
80009302:	fa cb f9 44 	sub	r11,sp,-1724
80009306:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000930a:	c1 f8       	rjmp	80009348 <_vfprintf_r+0x1448>
8000930c:	fa c8 f9 50 	sub	r8,sp,-1712
80009310:	1a d8       	st.w	--sp,r8
80009312:	fa c8 fa b8 	sub	r8,sp,-1352
80009316:	1a d8       	st.w	--sp,r8
80009318:	fa c8 fb b4 	sub	r8,sp,-1100
8000931c:	1a d8       	st.w	--sp,r8
8000931e:	fa c8 f9 40 	sub	r8,sp,-1728
80009322:	fa c9 ff b4 	sub	r9,sp,-76
80009326:	04 9a       	mov	r10,r2
80009328:	0c 9b       	mov	r11,r6
8000932a:	08 9c       	mov	r12,r4
8000932c:	fe b0 f4 52 	rcall	80007bd0 <get_arg>
80009330:	2f dd       	sub	sp,-12
80009332:	98 18       	ld.sh	r8,r12[0x2]
80009334:	c2 78       	rjmp	80009382 <_vfprintf_r+0x1482>
80009336:	ee ca ff ff 	sub	r10,r7,-1
8000933a:	10 37       	cp.w	r7,r8
8000933c:	c0 a4       	brge	80009350 <_vfprintf_r+0x1450>
8000933e:	fa c9 f9 44 	sub	r9,sp,-1724
80009342:	14 97       	mov	r7,r10
80009344:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009348:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000934c:	c1 b8       	rjmp	80009382 <_vfprintf_r+0x1482>
8000934e:	d7 03       	nop
80009350:	41 09       	lddsp	r9,sp[0x40]
80009352:	59 f8       	cp.w	r8,31
80009354:	e0 89 00 13 	brgt	8000937a <_vfprintf_r+0x147a>
80009358:	f2 cb ff fc 	sub	r11,r9,-4
8000935c:	51 0b       	stdsp	sp[0x40],r11
8000935e:	72 09       	ld.w	r9,r9[0x0]
80009360:	fa c6 f9 44 	sub	r6,sp,-1724
80009364:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80009368:	2f f8       	sub	r8,-1
8000936a:	f7 49 fd 88 	st.w	r11[-632],r9
8000936e:	fb 48 06 b4 	st.w	sp[1716],r8
80009372:	14 97       	mov	r7,r10
80009374:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80009378:	c0 58       	rjmp	80009382 <_vfprintf_r+0x1482>
8000937a:	92 18       	ld.sh	r8,r9[0x2]
8000937c:	14 97       	mov	r7,r10
8000937e:	2f c9       	sub	r9,-4
80009380:	51 09       	stdsp	sp[0x40],r9
80009382:	5c 78       	castu.h	r8
80009384:	50 18       	stdsp	sp[0x4],r8
80009386:	c4 68       	rjmp	80009412 <_vfprintf_r+0x1512>
80009388:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000938c:	40 3c       	lddsp	r12,sp[0xc]
8000938e:	58 0c       	cp.w	r12,0
80009390:	c1 d0       	breq	800093ca <_vfprintf_r+0x14ca>
80009392:	10 36       	cp.w	r6,r8
80009394:	c0 64       	brge	800093a0 <_vfprintf_r+0x14a0>
80009396:	fa cb f9 44 	sub	r11,sp,-1724
8000939a:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000939e:	c1 f8       	rjmp	800093dc <_vfprintf_r+0x14dc>
800093a0:	fa c8 f9 50 	sub	r8,sp,-1712
800093a4:	1a d8       	st.w	--sp,r8
800093a6:	fa c8 fa b8 	sub	r8,sp,-1352
800093aa:	0c 9b       	mov	r11,r6
800093ac:	1a d8       	st.w	--sp,r8
800093ae:	fa c8 fb b4 	sub	r8,sp,-1100
800093b2:	04 9a       	mov	r10,r2
800093b4:	1a d8       	st.w	--sp,r8
800093b6:	08 9c       	mov	r12,r4
800093b8:	fa c8 f9 40 	sub	r8,sp,-1728
800093bc:	fa c9 ff b4 	sub	r9,sp,-76
800093c0:	fe b0 f4 08 	rcall	80007bd0 <get_arg>
800093c4:	2f dd       	sub	sp,-12
800093c6:	78 0b       	ld.w	r11,r12[0x0]
800093c8:	c2 48       	rjmp	80009410 <_vfprintf_r+0x1510>
800093ca:	ee ca ff ff 	sub	r10,r7,-1
800093ce:	10 37       	cp.w	r7,r8
800093d0:	c0 94       	brge	800093e2 <_vfprintf_r+0x14e2>
800093d2:	fa c9 f9 44 	sub	r9,sp,-1724
800093d6:	f2 06 00 36 	add	r6,r9,r6<<0x3
800093da:	14 97       	mov	r7,r10
800093dc:	ec fb fd 88 	ld.w	r11,r6[-632]
800093e0:	c1 88       	rjmp	80009410 <_vfprintf_r+0x1510>
800093e2:	41 09       	lddsp	r9,sp[0x40]
800093e4:	59 f8       	cp.w	r8,31
800093e6:	e0 89 00 11 	brgt	80009408 <_vfprintf_r+0x1508>
800093ea:	f2 cb ff fc 	sub	r11,r9,-4
800093ee:	51 0b       	stdsp	sp[0x40],r11
800093f0:	fa c6 f9 44 	sub	r6,sp,-1724
800093f4:	72 0b       	ld.w	r11,r9[0x0]
800093f6:	ec 08 00 39 	add	r9,r6,r8<<0x3
800093fa:	f3 4b fd 88 	st.w	r9[-632],r11
800093fe:	2f f8       	sub	r8,-1
80009400:	14 97       	mov	r7,r10
80009402:	fb 48 06 b4 	st.w	sp[1716],r8
80009406:	c0 58       	rjmp	80009410 <_vfprintf_r+0x1510>
80009408:	72 0b       	ld.w	r11,r9[0x0]
8000940a:	14 97       	mov	r7,r10
8000940c:	2f c9       	sub	r9,-4
8000940e:	51 09       	stdsp	sp[0x40],r9
80009410:	50 1b       	stdsp	sp[0x4],r11
80009412:	30 0e       	mov	lr,0
80009414:	50 0e       	stdsp	sp[0x0],lr
80009416:	40 08       	lddsp	r8,sp[0x0]
80009418:	40 1c       	lddsp	r12,sp[0x4]
8000941a:	18 48       	or	r8,r12
8000941c:	5f 19       	srne	r9
8000941e:	0a 98       	mov	r8,r5
80009420:	eb e9 00 09 	and	r9,r5,r9
80009424:	a1 b8       	sbr	r8,0x1
80009426:	58 09       	cp.w	r9,0
80009428:	c0 70       	breq	80009436 <_vfprintf_r+0x1536>
8000942a:	10 95       	mov	r5,r8
8000942c:	fb 60 06 b9 	st.b	sp[1721],r0
80009430:	33 08       	mov	r8,48
80009432:	fb 68 06 b8 	st.b	sp[1720],r8
80009436:	30 28       	mov	r8,2
80009438:	30 09       	mov	r9,0
8000943a:	fb 69 06 bb 	st.b	sp[1723],r9
8000943e:	0a 99       	mov	r9,r5
80009440:	a7 d9       	cbr	r9,0x7
80009442:	40 2b       	lddsp	r11,sp[0x8]
80009444:	40 16       	lddsp	r6,sp[0x4]
80009446:	58 0b       	cp.w	r11,0
80009448:	5f 1a       	srne	r10
8000944a:	f2 05 17 40 	movge	r5,r9
8000944e:	fa c2 f9 78 	sub	r2,sp,-1672
80009452:	40 09       	lddsp	r9,sp[0x0]
80009454:	0c 49       	or	r9,r6
80009456:	5f 19       	srne	r9
80009458:	f5 e9 10 09 	or	r9,r10,r9
8000945c:	c5 c0       	breq	80009514 <_vfprintf_r+0x1614>
8000945e:	30 19       	mov	r9,1
80009460:	f2 08 18 00 	cp.b	r8,r9
80009464:	c0 60       	breq	80009470 <_vfprintf_r+0x1570>
80009466:	30 29       	mov	r9,2
80009468:	f2 08 18 00 	cp.b	r8,r9
8000946c:	c0 41       	brne	80009474 <_vfprintf_r+0x1574>
8000946e:	c3 c8       	rjmp	800094e6 <_vfprintf_r+0x15e6>
80009470:	04 96       	mov	r6,r2
80009472:	c3 08       	rjmp	800094d2 <_vfprintf_r+0x15d2>
80009474:	04 96       	mov	r6,r2
80009476:	fa e8 00 00 	ld.d	r8,sp[0]
8000947a:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
8000947e:	2d 0a       	sub	r10,-48
80009480:	0c fa       	st.b	--r6,r10
80009482:	f0 0b 16 03 	lsr	r11,r8,0x3
80009486:	f2 0c 16 03 	lsr	r12,r9,0x3
8000948a:	f7 e9 11 db 	or	r11,r11,r9<<0x1d
8000948e:	18 99       	mov	r9,r12
80009490:	16 98       	mov	r8,r11
80009492:	58 08       	cp.w	r8,0
80009494:	5c 29       	cpc	r9
80009496:	cf 21       	brne	8000947a <_vfprintf_r+0x157a>
80009498:	fa e9 00 00 	st.d	sp[0],r8
8000949c:	ed b5 00 00 	bld	r5,0x0
800094a0:	c4 51       	brne	8000952a <_vfprintf_r+0x162a>
800094a2:	33 09       	mov	r9,48
800094a4:	f2 0a 18 00 	cp.b	r10,r9
800094a8:	c4 10       	breq	8000952a <_vfprintf_r+0x162a>
800094aa:	0c f9       	st.b	--r6,r9
800094ac:	c3 f8       	rjmp	8000952a <_vfprintf_r+0x162a>
800094ae:	fa ea 00 00 	ld.d	r10,sp[0]
800094b2:	30 a8       	mov	r8,10
800094b4:	30 09       	mov	r9,0
800094b6:	e0 a0 1a 19 	rcall	8000c8e8 <__avr32_umod64>
800094ba:	30 a8       	mov	r8,10
800094bc:	2d 0a       	sub	r10,-48
800094be:	30 09       	mov	r9,0
800094c0:	ac 8a       	st.b	r6[0x0],r10
800094c2:	fa ea 00 00 	ld.d	r10,sp[0]
800094c6:	e0 a0 18 df 	rcall	8000c684 <__avr32_udiv64>
800094ca:	16 99       	mov	r9,r11
800094cc:	14 98       	mov	r8,r10
800094ce:	fa e9 00 00 	st.d	sp[0],r8
800094d2:	20 16       	sub	r6,1
800094d4:	fa ea 00 00 	ld.d	r10,sp[0]
800094d8:	58 9a       	cp.w	r10,9
800094da:	5c 2b       	cpc	r11
800094dc:	fe 9b ff e9 	brhi	800094ae <_vfprintf_r+0x15ae>
800094e0:	1b f8       	ld.ub	r8,sp[0x7]
800094e2:	2d 08       	sub	r8,-48
800094e4:	c2 08       	rjmp	80009524 <_vfprintf_r+0x1624>
800094e6:	04 96       	mov	r6,r2
800094e8:	fa e8 00 00 	ld.d	r8,sp[0]
800094ec:	f5 d8 c0 04 	bfextu	r10,r8,0x0,0x4
800094f0:	40 de       	lddsp	lr,sp[0x34]
800094f2:	fc 0a 07 0a 	ld.ub	r10,lr[r10]
800094f6:	0c fa       	st.b	--r6,r10
800094f8:	f2 0b 16 04 	lsr	r11,r9,0x4
800094fc:	f0 0a 16 04 	lsr	r10,r8,0x4
80009500:	f5 e9 11 ca 	or	r10,r10,r9<<0x1c
80009504:	16 99       	mov	r9,r11
80009506:	14 98       	mov	r8,r10
80009508:	58 08       	cp.w	r8,0
8000950a:	5c 29       	cpc	r9
8000950c:	cf 01       	brne	800094ec <_vfprintf_r+0x15ec>
8000950e:	fa e9 00 00 	st.d	sp[0],r8
80009512:	c0 c8       	rjmp	8000952a <_vfprintf_r+0x162a>
80009514:	58 08       	cp.w	r8,0
80009516:	c0 91       	brne	80009528 <_vfprintf_r+0x1628>
80009518:	ed b5 00 00 	bld	r5,0x0
8000951c:	c0 61       	brne	80009528 <_vfprintf_r+0x1628>
8000951e:	fa c6 f9 79 	sub	r6,sp,-1671
80009522:	33 08       	mov	r8,48
80009524:	ac 88       	st.b	r6[0x0],r8
80009526:	c0 28       	rjmp	8000952a <_vfprintf_r+0x162a>
80009528:	04 96       	mov	r6,r2
8000952a:	0c 12       	sub	r2,r6
8000952c:	c1 c8       	rjmp	80009564 <_vfprintf_r+0x1664>
8000952e:	50 a7       	stdsp	sp[0x28],r7
80009530:	50 80       	stdsp	sp[0x20],r0
80009532:	40 93       	lddsp	r3,sp[0x24]
80009534:	0c 97       	mov	r7,r6
80009536:	10 90       	mov	r0,r8
80009538:	04 94       	mov	r4,r2
8000953a:	40 41       	lddsp	r1,sp[0x10]
8000953c:	58 08       	cp.w	r8,0
8000953e:	e0 80 04 4f 	breq	80009ddc <_vfprintf_r+0x1edc>
80009542:	fb 68 06 60 	st.b	sp[1632],r8
80009546:	30 0c       	mov	r12,0
80009548:	30 08       	mov	r8,0
8000954a:	30 12       	mov	r2,1
8000954c:	fb 68 06 bb 	st.b	sp[1723],r8
80009550:	50 2c       	stdsp	sp[0x8],r12
80009552:	fa c6 f9 a0 	sub	r6,sp,-1632
80009556:	c0 78       	rjmp	80009564 <_vfprintf_r+0x1664>
80009558:	30 0b       	mov	r11,0
8000955a:	50 2b       	stdsp	sp[0x8],r11
8000955c:	c0 48       	rjmp	80009564 <_vfprintf_r+0x1664>
8000955e:	40 22       	lddsp	r2,sp[0x8]
80009560:	30 0a       	mov	r10,0
80009562:	50 2a       	stdsp	sp[0x8],r10
80009564:	40 29       	lddsp	r9,sp[0x8]
80009566:	e4 09 0c 49 	max	r9,r2,r9
8000956a:	fb 38 06 bb 	ld.ub	r8,sp[1723]
8000956e:	50 39       	stdsp	sp[0xc],r9
80009570:	0a 9e       	mov	lr,r5
80009572:	30 09       	mov	r9,0
80009574:	e2 1e 00 02 	andl	lr,0x2,COH
80009578:	f2 08 18 00 	cp.b	r8,r9
8000957c:	fb f8 10 03 	ld.wne	r8,sp[0xc]
80009580:	f7 b8 01 ff 	subne	r8,-1
80009584:	fb f8 1a 03 	st.wne	sp[0xc],r8
80009588:	0a 9b       	mov	r11,r5
8000958a:	58 0e       	cp.w	lr,0
8000958c:	fb fc 10 03 	ld.wne	r12,sp[0xc]
80009590:	f7 bc 01 fe 	subne	r12,-2
80009594:	fb fc 1a 03 	st.wne	sp[0xc],r12
80009598:	e2 1b 00 84 	andl	r11,0x84,COH
8000959c:	50 fe       	stdsp	sp[0x3c],lr
8000959e:	50 9b       	stdsp	sp[0x24],r11
800095a0:	c4 71       	brne	8000962e <_vfprintf_r+0x172e>
800095a2:	40 8a       	lddsp	r10,sp[0x20]
800095a4:	40 39       	lddsp	r9,sp[0xc]
800095a6:	12 1a       	sub	r10,r9
800095a8:	50 4a       	stdsp	sp[0x10],r10
800095aa:	58 0a       	cp.w	r10,0
800095ac:	e0 89 00 20 	brgt	800095ec <_vfprintf_r+0x16ec>
800095b0:	c3 f8       	rjmp	8000962e <_vfprintf_r+0x172e>
800095b2:	2f 09       	sub	r9,-16
800095b4:	2f f8       	sub	r8,-1
800095b6:	fe ce b7 d2 	sub	lr,pc,-18478
800095ba:	31 0c       	mov	r12,16
800095bc:	fb 49 06 90 	st.w	sp[1680],r9
800095c0:	87 0e       	st.w	r3[0x0],lr
800095c2:	87 1c       	st.w	r3[0x4],r12
800095c4:	fb 48 06 8c 	st.w	sp[1676],r8
800095c8:	58 78       	cp.w	r8,7
800095ca:	e0 89 00 04 	brgt	800095d2 <_vfprintf_r+0x16d2>
800095ce:	2f 83       	sub	r3,-8
800095d0:	c0 b8       	rjmp	800095e6 <_vfprintf_r+0x16e6>
800095d2:	fa ca f9 78 	sub	r10,sp,-1672
800095d6:	02 9b       	mov	r11,r1
800095d8:	08 9c       	mov	r12,r4
800095da:	fe b0 f4 85 	rcall	80007ee4 <__sprint_r>
800095de:	e0 81 04 10 	brne	80009dfe <_vfprintf_r+0x1efe>
800095e2:	fa c3 f9 e0 	sub	r3,sp,-1568
800095e6:	40 4b       	lddsp	r11,sp[0x10]
800095e8:	21 0b       	sub	r11,16
800095ea:	50 4b       	stdsp	sp[0x10],r11
800095ec:	fa f9 06 90 	ld.w	r9,sp[1680]
800095f0:	fa f8 06 8c 	ld.w	r8,sp[1676]
800095f4:	fe ca b8 10 	sub	r10,pc,-18416
800095f8:	40 4e       	lddsp	lr,sp[0x10]
800095fa:	59 0e       	cp.w	lr,16
800095fc:	fe 99 ff db 	brgt	800095b2 <_vfprintf_r+0x16b2>
80009600:	1c 09       	add	r9,lr
80009602:	2f f8       	sub	r8,-1
80009604:	87 0a       	st.w	r3[0x0],r10
80009606:	fb 49 06 90 	st.w	sp[1680],r9
8000960a:	87 1e       	st.w	r3[0x4],lr
8000960c:	fb 48 06 8c 	st.w	sp[1676],r8
80009610:	58 78       	cp.w	r8,7
80009612:	e0 89 00 04 	brgt	8000961a <_vfprintf_r+0x171a>
80009616:	2f 83       	sub	r3,-8
80009618:	c0 b8       	rjmp	8000962e <_vfprintf_r+0x172e>
8000961a:	fa ca f9 78 	sub	r10,sp,-1672
8000961e:	02 9b       	mov	r11,r1
80009620:	08 9c       	mov	r12,r4
80009622:	fe b0 f4 61 	rcall	80007ee4 <__sprint_r>
80009626:	e0 81 03 ec 	brne	80009dfe <_vfprintf_r+0x1efe>
8000962a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000962e:	30 09       	mov	r9,0
80009630:	fb 38 06 bb 	ld.ub	r8,sp[1723]
80009634:	f2 08 18 00 	cp.b	r8,r9
80009638:	c1 f0       	breq	80009676 <_vfprintf_r+0x1776>
8000963a:	fa f8 06 90 	ld.w	r8,sp[1680]
8000963e:	fa c9 f9 45 	sub	r9,sp,-1723
80009642:	2f f8       	sub	r8,-1
80009644:	87 09       	st.w	r3[0x0],r9
80009646:	fb 48 06 90 	st.w	sp[1680],r8
8000964a:	30 19       	mov	r9,1
8000964c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009650:	87 19       	st.w	r3[0x4],r9
80009652:	2f f8       	sub	r8,-1
80009654:	fb 48 06 8c 	st.w	sp[1676],r8
80009658:	58 78       	cp.w	r8,7
8000965a:	e0 89 00 04 	brgt	80009662 <_vfprintf_r+0x1762>
8000965e:	2f 83       	sub	r3,-8
80009660:	c0 b8       	rjmp	80009676 <_vfprintf_r+0x1776>
80009662:	fa ca f9 78 	sub	r10,sp,-1672
80009666:	02 9b       	mov	r11,r1
80009668:	08 9c       	mov	r12,r4
8000966a:	fe b0 f4 3d 	rcall	80007ee4 <__sprint_r>
8000966e:	e0 81 03 c8 	brne	80009dfe <_vfprintf_r+0x1efe>
80009672:	fa c3 f9 e0 	sub	r3,sp,-1568
80009676:	40 fc       	lddsp	r12,sp[0x3c]
80009678:	58 0c       	cp.w	r12,0
8000967a:	c1 f0       	breq	800096b8 <_vfprintf_r+0x17b8>
8000967c:	fa f8 06 90 	ld.w	r8,sp[1680]
80009680:	fa c9 f9 48 	sub	r9,sp,-1720
80009684:	2f e8       	sub	r8,-2
80009686:	87 09       	st.w	r3[0x0],r9
80009688:	fb 48 06 90 	st.w	sp[1680],r8
8000968c:	30 29       	mov	r9,2
8000968e:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009692:	87 19       	st.w	r3[0x4],r9
80009694:	2f f8       	sub	r8,-1
80009696:	fb 48 06 8c 	st.w	sp[1676],r8
8000969a:	58 78       	cp.w	r8,7
8000969c:	e0 89 00 04 	brgt	800096a4 <_vfprintf_r+0x17a4>
800096a0:	2f 83       	sub	r3,-8
800096a2:	c0 b8       	rjmp	800096b8 <_vfprintf_r+0x17b8>
800096a4:	fa ca f9 78 	sub	r10,sp,-1672
800096a8:	02 9b       	mov	r11,r1
800096aa:	08 9c       	mov	r12,r4
800096ac:	fe b0 f4 1c 	rcall	80007ee4 <__sprint_r>
800096b0:	e0 81 03 a7 	brne	80009dfe <_vfprintf_r+0x1efe>
800096b4:	fa c3 f9 e0 	sub	r3,sp,-1568
800096b8:	40 9b       	lddsp	r11,sp[0x24]
800096ba:	e0 4b 00 80 	cp.w	r11,128
800096be:	c4 71       	brne	8000974c <_vfprintf_r+0x184c>
800096c0:	40 8a       	lddsp	r10,sp[0x20]
800096c2:	40 39       	lddsp	r9,sp[0xc]
800096c4:	12 1a       	sub	r10,r9
800096c6:	50 4a       	stdsp	sp[0x10],r10
800096c8:	58 0a       	cp.w	r10,0
800096ca:	e0 89 00 20 	brgt	8000970a <_vfprintf_r+0x180a>
800096ce:	c3 f8       	rjmp	8000974c <_vfprintf_r+0x184c>
800096d0:	2f 09       	sub	r9,-16
800096d2:	2f f8       	sub	r8,-1
800096d4:	fe ce b8 e0 	sub	lr,pc,-18208
800096d8:	31 0c       	mov	r12,16
800096da:	fb 49 06 90 	st.w	sp[1680],r9
800096de:	87 0e       	st.w	r3[0x0],lr
800096e0:	87 1c       	st.w	r3[0x4],r12
800096e2:	fb 48 06 8c 	st.w	sp[1676],r8
800096e6:	58 78       	cp.w	r8,7
800096e8:	e0 89 00 04 	brgt	800096f0 <_vfprintf_r+0x17f0>
800096ec:	2f 83       	sub	r3,-8
800096ee:	c0 b8       	rjmp	80009704 <_vfprintf_r+0x1804>
800096f0:	fa ca f9 78 	sub	r10,sp,-1672
800096f4:	02 9b       	mov	r11,r1
800096f6:	08 9c       	mov	r12,r4
800096f8:	fe b0 f3 f6 	rcall	80007ee4 <__sprint_r>
800096fc:	e0 81 03 81 	brne	80009dfe <_vfprintf_r+0x1efe>
80009700:	fa c3 f9 e0 	sub	r3,sp,-1568
80009704:	40 4b       	lddsp	r11,sp[0x10]
80009706:	21 0b       	sub	r11,16
80009708:	50 4b       	stdsp	sp[0x10],r11
8000970a:	fa f9 06 90 	ld.w	r9,sp[1680]
8000970e:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009712:	fe ca b9 1e 	sub	r10,pc,-18146
80009716:	40 4e       	lddsp	lr,sp[0x10]
80009718:	59 0e       	cp.w	lr,16
8000971a:	fe 99 ff db 	brgt	800096d0 <_vfprintf_r+0x17d0>
8000971e:	1c 09       	add	r9,lr
80009720:	2f f8       	sub	r8,-1
80009722:	87 0a       	st.w	r3[0x0],r10
80009724:	fb 49 06 90 	st.w	sp[1680],r9
80009728:	87 1e       	st.w	r3[0x4],lr
8000972a:	fb 48 06 8c 	st.w	sp[1676],r8
8000972e:	58 78       	cp.w	r8,7
80009730:	e0 89 00 04 	brgt	80009738 <_vfprintf_r+0x1838>
80009734:	2f 83       	sub	r3,-8
80009736:	c0 b8       	rjmp	8000974c <_vfprintf_r+0x184c>
80009738:	fa ca f9 78 	sub	r10,sp,-1672
8000973c:	02 9b       	mov	r11,r1
8000973e:	08 9c       	mov	r12,r4
80009740:	fe b0 f3 d2 	rcall	80007ee4 <__sprint_r>
80009744:	e0 81 03 5d 	brne	80009dfe <_vfprintf_r+0x1efe>
80009748:	fa c3 f9 e0 	sub	r3,sp,-1568
8000974c:	40 2c       	lddsp	r12,sp[0x8]
8000974e:	04 1c       	sub	r12,r2
80009750:	50 2c       	stdsp	sp[0x8],r12
80009752:	58 0c       	cp.w	r12,0
80009754:	e0 89 00 20 	brgt	80009794 <_vfprintf_r+0x1894>
80009758:	c3 f8       	rjmp	800097d6 <_vfprintf_r+0x18d6>
8000975a:	2f 09       	sub	r9,-16
8000975c:	2f f8       	sub	r8,-1
8000975e:	fe cb b9 6a 	sub	r11,pc,-18070
80009762:	31 0a       	mov	r10,16
80009764:	fb 49 06 90 	st.w	sp[1680],r9
80009768:	87 0b       	st.w	r3[0x0],r11
8000976a:	87 1a       	st.w	r3[0x4],r10
8000976c:	fb 48 06 8c 	st.w	sp[1676],r8
80009770:	58 78       	cp.w	r8,7
80009772:	e0 89 00 04 	brgt	8000977a <_vfprintf_r+0x187a>
80009776:	2f 83       	sub	r3,-8
80009778:	c0 b8       	rjmp	8000978e <_vfprintf_r+0x188e>
8000977a:	fa ca f9 78 	sub	r10,sp,-1672
8000977e:	02 9b       	mov	r11,r1
80009780:	08 9c       	mov	r12,r4
80009782:	fe b0 f3 b1 	rcall	80007ee4 <__sprint_r>
80009786:	e0 81 03 3c 	brne	80009dfe <_vfprintf_r+0x1efe>
8000978a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000978e:	40 29       	lddsp	r9,sp[0x8]
80009790:	21 09       	sub	r9,16
80009792:	50 29       	stdsp	sp[0x8],r9
80009794:	fa f9 06 90 	ld.w	r9,sp[1680]
80009798:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000979c:	fe ca b9 a8 	sub	r10,pc,-18008
800097a0:	40 2e       	lddsp	lr,sp[0x8]
800097a2:	59 0e       	cp.w	lr,16
800097a4:	fe 99 ff db 	brgt	8000975a <_vfprintf_r+0x185a>
800097a8:	1c 09       	add	r9,lr
800097aa:	2f f8       	sub	r8,-1
800097ac:	87 0a       	st.w	r3[0x0],r10
800097ae:	fb 49 06 90 	st.w	sp[1680],r9
800097b2:	87 1e       	st.w	r3[0x4],lr
800097b4:	fb 48 06 8c 	st.w	sp[1676],r8
800097b8:	58 78       	cp.w	r8,7
800097ba:	e0 89 00 04 	brgt	800097c2 <_vfprintf_r+0x18c2>
800097be:	2f 83       	sub	r3,-8
800097c0:	c0 b8       	rjmp	800097d6 <_vfprintf_r+0x18d6>
800097c2:	fa ca f9 78 	sub	r10,sp,-1672
800097c6:	02 9b       	mov	r11,r1
800097c8:	08 9c       	mov	r12,r4
800097ca:	fe b0 f3 8d 	rcall	80007ee4 <__sprint_r>
800097ce:	e0 81 03 18 	brne	80009dfe <_vfprintf_r+0x1efe>
800097d2:	fa c3 f9 e0 	sub	r3,sp,-1568
800097d6:	ed b5 00 08 	bld	r5,0x8
800097da:	c0 b0       	breq	800097f0 <_vfprintf_r+0x18f0>
800097dc:	fa f8 06 90 	ld.w	r8,sp[1680]
800097e0:	87 12       	st.w	r3[0x4],r2
800097e2:	87 06       	st.w	r3[0x0],r6
800097e4:	f0 02 00 02 	add	r2,r8,r2
800097e8:	fb 42 06 90 	st.w	sp[1680],r2
800097ec:	e0 8f 01 d4 	bral	80009b94 <_vfprintf_r+0x1c94>
800097f0:	e0 40 00 65 	cp.w	r0,101
800097f4:	e0 8a 01 d6 	brle	80009ba0 <_vfprintf_r+0x1ca0>
800097f8:	30 08       	mov	r8,0
800097fa:	30 09       	mov	r9,0
800097fc:	40 5b       	lddsp	r11,sp[0x14]
800097fe:	40 7a       	lddsp	r10,sp[0x1c]
80009800:	e0 a0 15 3b 	rcall	8000c276 <__avr32_f64_cmp_eq>
80009804:	c7 90       	breq	800098f6 <_vfprintf_r+0x19f6>
80009806:	fa f8 06 90 	ld.w	r8,sp[1680]
8000980a:	fe c9 ba 2a 	sub	r9,pc,-17878
8000980e:	2f f8       	sub	r8,-1
80009810:	87 09       	st.w	r3[0x0],r9
80009812:	fb 48 06 90 	st.w	sp[1680],r8
80009816:	30 19       	mov	r9,1
80009818:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000981c:	87 19       	st.w	r3[0x4],r9
8000981e:	2f f8       	sub	r8,-1
80009820:	fb 48 06 8c 	st.w	sp[1676],r8
80009824:	58 78       	cp.w	r8,7
80009826:	e0 89 00 05 	brgt	80009830 <_vfprintf_r+0x1930>
8000982a:	2f 83       	sub	r3,-8
8000982c:	c0 c8       	rjmp	80009844 <_vfprintf_r+0x1944>
8000982e:	d7 03       	nop
80009830:	fa ca f9 78 	sub	r10,sp,-1672
80009834:	02 9b       	mov	r11,r1
80009836:	08 9c       	mov	r12,r4
80009838:	fe b0 f3 56 	rcall	80007ee4 <__sprint_r>
8000983c:	e0 81 02 e1 	brne	80009dfe <_vfprintf_r+0x1efe>
80009840:	fa c3 f9 e0 	sub	r3,sp,-1568
80009844:	fa f8 06 ac 	ld.w	r8,sp[1708]
80009848:	40 6c       	lddsp	r12,sp[0x18]
8000984a:	18 38       	cp.w	r8,r12
8000984c:	c0 55       	brlt	80009856 <_vfprintf_r+0x1956>
8000984e:	ed b5 00 00 	bld	r5,0x0
80009852:	e0 81 02 6b 	brne	80009d28 <_vfprintf_r+0x1e28>
80009856:	fa f8 06 90 	ld.w	r8,sp[1680]
8000985a:	2f f8       	sub	r8,-1
8000985c:	40 cb       	lddsp	r11,sp[0x30]
8000985e:	fb 48 06 90 	st.w	sp[1680],r8
80009862:	30 19       	mov	r9,1
80009864:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009868:	87 0b       	st.w	r3[0x0],r11
8000986a:	2f f8       	sub	r8,-1
8000986c:	87 19       	st.w	r3[0x4],r9
8000986e:	fb 48 06 8c 	st.w	sp[1676],r8
80009872:	58 78       	cp.w	r8,7
80009874:	e0 89 00 04 	brgt	8000987c <_vfprintf_r+0x197c>
80009878:	2f 83       	sub	r3,-8
8000987a:	c0 b8       	rjmp	80009890 <_vfprintf_r+0x1990>
8000987c:	fa ca f9 78 	sub	r10,sp,-1672
80009880:	02 9b       	mov	r11,r1
80009882:	08 9c       	mov	r12,r4
80009884:	fe b0 f3 30 	rcall	80007ee4 <__sprint_r>
80009888:	e0 81 02 bb 	brne	80009dfe <_vfprintf_r+0x1efe>
8000988c:	fa c3 f9 e0 	sub	r3,sp,-1568
80009890:	40 66       	lddsp	r6,sp[0x18]
80009892:	20 16       	sub	r6,1
80009894:	58 06       	cp.w	r6,0
80009896:	e0 89 00 1d 	brgt	800098d0 <_vfprintf_r+0x19d0>
8000989a:	e0 8f 02 47 	bral	80009d28 <_vfprintf_r+0x1e28>
8000989e:	2f 09       	sub	r9,-16
800098a0:	2f f8       	sub	r8,-1
800098a2:	fb 49 06 90 	st.w	sp[1680],r9
800098a6:	87 02       	st.w	r3[0x0],r2
800098a8:	87 10       	st.w	r3[0x4],r0
800098aa:	fb 48 06 8c 	st.w	sp[1676],r8
800098ae:	58 78       	cp.w	r8,7
800098b0:	e0 89 00 04 	brgt	800098b8 <_vfprintf_r+0x19b8>
800098b4:	2f 83       	sub	r3,-8
800098b6:	c0 b8       	rjmp	800098cc <_vfprintf_r+0x19cc>
800098b8:	fa ca f9 78 	sub	r10,sp,-1672
800098bc:	02 9b       	mov	r11,r1
800098be:	08 9c       	mov	r12,r4
800098c0:	fe b0 f3 12 	rcall	80007ee4 <__sprint_r>
800098c4:	e0 81 02 9d 	brne	80009dfe <_vfprintf_r+0x1efe>
800098c8:	fa c3 f9 e0 	sub	r3,sp,-1568
800098cc:	21 06       	sub	r6,16
800098ce:	c0 48       	rjmp	800098d6 <_vfprintf_r+0x19d6>
800098d0:	fe c2 ba dc 	sub	r2,pc,-17700
800098d4:	31 00       	mov	r0,16
800098d6:	fa f9 06 90 	ld.w	r9,sp[1680]
800098da:	fa f8 06 8c 	ld.w	r8,sp[1676]
800098de:	fe ca ba ea 	sub	r10,pc,-17686
800098e2:	59 06       	cp.w	r6,16
800098e4:	fe 99 ff dd 	brgt	8000989e <_vfprintf_r+0x199e>
800098e8:	0c 09       	add	r9,r6
800098ea:	87 0a       	st.w	r3[0x0],r10
800098ec:	fb 49 06 90 	st.w	sp[1680],r9
800098f0:	2f f8       	sub	r8,-1
800098f2:	87 16       	st.w	r3[0x4],r6
800098f4:	c5 39       	rjmp	80009b9a <_vfprintf_r+0x1c9a>
800098f6:	fa fa 06 ac 	ld.w	r10,sp[1708]
800098fa:	58 0a       	cp.w	r10,0
800098fc:	e0 89 00 92 	brgt	80009a20 <_vfprintf_r+0x1b20>
80009900:	fa f8 06 90 	ld.w	r8,sp[1680]
80009904:	fe c9 bb 24 	sub	r9,pc,-17628
80009908:	2f f8       	sub	r8,-1
8000990a:	87 09       	st.w	r3[0x0],r9
8000990c:	fb 48 06 90 	st.w	sp[1680],r8
80009910:	30 19       	mov	r9,1
80009912:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009916:	87 19       	st.w	r3[0x4],r9
80009918:	2f f8       	sub	r8,-1
8000991a:	fb 48 06 8c 	st.w	sp[1676],r8
8000991e:	58 78       	cp.w	r8,7
80009920:	e0 89 00 04 	brgt	80009928 <_vfprintf_r+0x1a28>
80009924:	2f 83       	sub	r3,-8
80009926:	c0 b8       	rjmp	8000993c <_vfprintf_r+0x1a3c>
80009928:	fa ca f9 78 	sub	r10,sp,-1672
8000992c:	02 9b       	mov	r11,r1
8000992e:	08 9c       	mov	r12,r4
80009930:	fe b0 f2 da 	rcall	80007ee4 <__sprint_r>
80009934:	e0 81 02 65 	brne	80009dfe <_vfprintf_r+0x1efe>
80009938:	fa c3 f9 e0 	sub	r3,sp,-1568
8000993c:	fa f8 06 ac 	ld.w	r8,sp[1708]
80009940:	58 08       	cp.w	r8,0
80009942:	c0 81       	brne	80009952 <_vfprintf_r+0x1a52>
80009944:	40 6a       	lddsp	r10,sp[0x18]
80009946:	58 0a       	cp.w	r10,0
80009948:	c0 51       	brne	80009952 <_vfprintf_r+0x1a52>
8000994a:	ed b5 00 00 	bld	r5,0x0
8000994e:	e0 81 01 ed 	brne	80009d28 <_vfprintf_r+0x1e28>
80009952:	40 c9       	lddsp	r9,sp[0x30]
80009954:	fa f8 06 90 	ld.w	r8,sp[1680]
80009958:	2f f8       	sub	r8,-1
8000995a:	87 09       	st.w	r3[0x0],r9
8000995c:	fb 48 06 90 	st.w	sp[1680],r8
80009960:	30 19       	mov	r9,1
80009962:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009966:	87 19       	st.w	r3[0x4],r9
80009968:	2f f8       	sub	r8,-1
8000996a:	fb 48 06 8c 	st.w	sp[1676],r8
8000996e:	58 78       	cp.w	r8,7
80009970:	e0 89 00 04 	brgt	80009978 <_vfprintf_r+0x1a78>
80009974:	2f 83       	sub	r3,-8
80009976:	c0 b8       	rjmp	8000998c <_vfprintf_r+0x1a8c>
80009978:	fa ca f9 78 	sub	r10,sp,-1672
8000997c:	02 9b       	mov	r11,r1
8000997e:	08 9c       	mov	r12,r4
80009980:	fe b0 f2 b2 	rcall	80007ee4 <__sprint_r>
80009984:	e0 81 02 3d 	brne	80009dfe <_vfprintf_r+0x1efe>
80009988:	fa c3 f9 e0 	sub	r3,sp,-1568
8000998c:	fa f2 06 ac 	ld.w	r2,sp[1708]
80009990:	5c 32       	neg	r2
80009992:	58 02       	cp.w	r2,0
80009994:	e0 89 00 1d 	brgt	800099ce <_vfprintf_r+0x1ace>
80009998:	c3 d8       	rjmp	80009a12 <_vfprintf_r+0x1b12>
8000999a:	2f 09       	sub	r9,-16
8000999c:	2f f8       	sub	r8,-1
8000999e:	31 0e       	mov	lr,16
800099a0:	fb 49 06 90 	st.w	sp[1680],r9
800099a4:	87 00       	st.w	r3[0x0],r0
800099a6:	87 1e       	st.w	r3[0x4],lr
800099a8:	fb 48 06 8c 	st.w	sp[1676],r8
800099ac:	58 78       	cp.w	r8,7
800099ae:	e0 89 00 04 	brgt	800099b6 <_vfprintf_r+0x1ab6>
800099b2:	2f 83       	sub	r3,-8
800099b4:	c0 b8       	rjmp	800099ca <_vfprintf_r+0x1aca>
800099b6:	fa ca f9 78 	sub	r10,sp,-1672
800099ba:	02 9b       	mov	r11,r1
800099bc:	08 9c       	mov	r12,r4
800099be:	fe b0 f2 93 	rcall	80007ee4 <__sprint_r>
800099c2:	e0 81 02 1e 	brne	80009dfe <_vfprintf_r+0x1efe>
800099c6:	fa c3 f9 e0 	sub	r3,sp,-1568
800099ca:	21 02       	sub	r2,16
800099cc:	c0 38       	rjmp	800099d2 <_vfprintf_r+0x1ad2>
800099ce:	fe c0 bb da 	sub	r0,pc,-17446
800099d2:	fa f9 06 90 	ld.w	r9,sp[1680]
800099d6:	fa f8 06 8c 	ld.w	r8,sp[1676]
800099da:	fe ca bb e6 	sub	r10,pc,-17434
800099de:	59 02       	cp.w	r2,16
800099e0:	fe 99 ff dd 	brgt	8000999a <_vfprintf_r+0x1a9a>
800099e4:	04 09       	add	r9,r2
800099e6:	2f f8       	sub	r8,-1
800099e8:	87 0a       	st.w	r3[0x0],r10
800099ea:	fb 49 06 90 	st.w	sp[1680],r9
800099ee:	87 12       	st.w	r3[0x4],r2
800099f0:	fb 48 06 8c 	st.w	sp[1676],r8
800099f4:	58 78       	cp.w	r8,7
800099f6:	e0 89 00 04 	brgt	800099fe <_vfprintf_r+0x1afe>
800099fa:	2f 83       	sub	r3,-8
800099fc:	c0 b8       	rjmp	80009a12 <_vfprintf_r+0x1b12>
800099fe:	fa ca f9 78 	sub	r10,sp,-1672
80009a02:	02 9b       	mov	r11,r1
80009a04:	08 9c       	mov	r12,r4
80009a06:	fe b0 f2 6f 	rcall	80007ee4 <__sprint_r>
80009a0a:	e0 81 01 fa 	brne	80009dfe <_vfprintf_r+0x1efe>
80009a0e:	fa c3 f9 e0 	sub	r3,sp,-1568
80009a12:	40 6c       	lddsp	r12,sp[0x18]
80009a14:	fa f8 06 90 	ld.w	r8,sp[1680]
80009a18:	87 06       	st.w	r3[0x0],r6
80009a1a:	87 1c       	st.w	r3[0x4],r12
80009a1c:	18 08       	add	r8,r12
80009a1e:	cb 98       	rjmp	80009b90 <_vfprintf_r+0x1c90>
80009a20:	fa f9 06 90 	ld.w	r9,sp[1680]
80009a24:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009a28:	40 6b       	lddsp	r11,sp[0x18]
80009a2a:	16 3a       	cp.w	r10,r11
80009a2c:	c6 f5       	brlt	80009b0a <_vfprintf_r+0x1c0a>
80009a2e:	16 09       	add	r9,r11
80009a30:	2f f8       	sub	r8,-1
80009a32:	87 06       	st.w	r3[0x0],r6
80009a34:	fb 49 06 90 	st.w	sp[1680],r9
80009a38:	87 1b       	st.w	r3[0x4],r11
80009a3a:	fb 48 06 8c 	st.w	sp[1676],r8
80009a3e:	58 78       	cp.w	r8,7
80009a40:	e0 89 00 04 	brgt	80009a48 <_vfprintf_r+0x1b48>
80009a44:	2f 83       	sub	r3,-8
80009a46:	c0 b8       	rjmp	80009a5c <_vfprintf_r+0x1b5c>
80009a48:	fa ca f9 78 	sub	r10,sp,-1672
80009a4c:	02 9b       	mov	r11,r1
80009a4e:	08 9c       	mov	r12,r4
80009a50:	fe b0 f2 4a 	rcall	80007ee4 <__sprint_r>
80009a54:	e0 81 01 d5 	brne	80009dfe <_vfprintf_r+0x1efe>
80009a58:	fa c3 f9 e0 	sub	r3,sp,-1568
80009a5c:	fa f6 06 ac 	ld.w	r6,sp[1708]
80009a60:	40 6a       	lddsp	r10,sp[0x18]
80009a62:	14 16       	sub	r6,r10
80009a64:	58 06       	cp.w	r6,0
80009a66:	e0 89 00 1c 	brgt	80009a9e <_vfprintf_r+0x1b9e>
80009a6a:	c3 d8       	rjmp	80009ae4 <_vfprintf_r+0x1be4>
80009a6c:	2f 09       	sub	r9,-16
80009a6e:	2f f8       	sub	r8,-1
80009a70:	fb 49 06 90 	st.w	sp[1680],r9
80009a74:	87 02       	st.w	r3[0x0],r2
80009a76:	87 10       	st.w	r3[0x4],r0
80009a78:	fb 48 06 8c 	st.w	sp[1676],r8
80009a7c:	58 78       	cp.w	r8,7
80009a7e:	e0 89 00 04 	brgt	80009a86 <_vfprintf_r+0x1b86>
80009a82:	2f 83       	sub	r3,-8
80009a84:	c0 b8       	rjmp	80009a9a <_vfprintf_r+0x1b9a>
80009a86:	fa ca f9 78 	sub	r10,sp,-1672
80009a8a:	02 9b       	mov	r11,r1
80009a8c:	08 9c       	mov	r12,r4
80009a8e:	fe b0 f2 2b 	rcall	80007ee4 <__sprint_r>
80009a92:	e0 81 01 b6 	brne	80009dfe <_vfprintf_r+0x1efe>
80009a96:	fa c3 f9 e0 	sub	r3,sp,-1568
80009a9a:	21 06       	sub	r6,16
80009a9c:	c0 48       	rjmp	80009aa4 <_vfprintf_r+0x1ba4>
80009a9e:	fe c2 bc aa 	sub	r2,pc,-17238
80009aa2:	31 00       	mov	r0,16
80009aa4:	fa f9 06 90 	ld.w	r9,sp[1680]
80009aa8:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009aac:	fe ca bc b8 	sub	r10,pc,-17224
80009ab0:	59 06       	cp.w	r6,16
80009ab2:	fe 99 ff dd 	brgt	80009a6c <_vfprintf_r+0x1b6c>
80009ab6:	0c 09       	add	r9,r6
80009ab8:	2f f8       	sub	r8,-1
80009aba:	87 0a       	st.w	r3[0x0],r10
80009abc:	fb 49 06 90 	st.w	sp[1680],r9
80009ac0:	87 16       	st.w	r3[0x4],r6
80009ac2:	fb 48 06 8c 	st.w	sp[1676],r8
80009ac6:	58 78       	cp.w	r8,7
80009ac8:	e0 89 00 04 	brgt	80009ad0 <_vfprintf_r+0x1bd0>
80009acc:	2f 83       	sub	r3,-8
80009ace:	c0 b8       	rjmp	80009ae4 <_vfprintf_r+0x1be4>
80009ad0:	fa ca f9 78 	sub	r10,sp,-1672
80009ad4:	02 9b       	mov	r11,r1
80009ad6:	08 9c       	mov	r12,r4
80009ad8:	fe b0 f2 06 	rcall	80007ee4 <__sprint_r>
80009adc:	e0 81 01 91 	brne	80009dfe <_vfprintf_r+0x1efe>
80009ae0:	fa c3 f9 e0 	sub	r3,sp,-1568
80009ae4:	ed b5 00 00 	bld	r5,0x0
80009ae8:	e0 81 01 20 	brne	80009d28 <_vfprintf_r+0x1e28>
80009aec:	40 c9       	lddsp	r9,sp[0x30]
80009aee:	fa f8 06 90 	ld.w	r8,sp[1680]
80009af2:	2f f8       	sub	r8,-1
80009af4:	87 09       	st.w	r3[0x0],r9
80009af6:	fb 48 06 90 	st.w	sp[1680],r8
80009afa:	30 19       	mov	r9,1
80009afc:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009b00:	87 19       	st.w	r3[0x4],r9
80009b02:	2f f8       	sub	r8,-1
80009b04:	fb 48 06 8c 	st.w	sp[1676],r8
80009b08:	c0 29       	rjmp	80009d0c <_vfprintf_r+0x1e0c>
80009b0a:	14 09       	add	r9,r10
80009b0c:	2f f8       	sub	r8,-1
80009b0e:	fb 49 06 90 	st.w	sp[1680],r9
80009b12:	87 06       	st.w	r3[0x0],r6
80009b14:	87 1a       	st.w	r3[0x4],r10
80009b16:	fb 48 06 8c 	st.w	sp[1676],r8
80009b1a:	58 78       	cp.w	r8,7
80009b1c:	e0 89 00 04 	brgt	80009b24 <_vfprintf_r+0x1c24>
80009b20:	2f 83       	sub	r3,-8
80009b22:	c0 b8       	rjmp	80009b38 <_vfprintf_r+0x1c38>
80009b24:	fa ca f9 78 	sub	r10,sp,-1672
80009b28:	02 9b       	mov	r11,r1
80009b2a:	08 9c       	mov	r12,r4
80009b2c:	fe b0 f1 dc 	rcall	80007ee4 <__sprint_r>
80009b30:	e0 81 01 67 	brne	80009dfe <_vfprintf_r+0x1efe>
80009b34:	fa c3 f9 e0 	sub	r3,sp,-1568
80009b38:	40 c8       	lddsp	r8,sp[0x30]
80009b3a:	87 08       	st.w	r3[0x0],r8
80009b3c:	fa f8 06 90 	ld.w	r8,sp[1680]
80009b40:	2f f8       	sub	r8,-1
80009b42:	30 19       	mov	r9,1
80009b44:	fb 48 06 90 	st.w	sp[1680],r8
80009b48:	87 19       	st.w	r3[0x4],r9
80009b4a:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009b4e:	2f f8       	sub	r8,-1
80009b50:	fb 48 06 8c 	st.w	sp[1676],r8
80009b54:	fa f2 06 ac 	ld.w	r2,sp[1708]
80009b58:	58 78       	cp.w	r8,7
80009b5a:	e0 89 00 04 	brgt	80009b62 <_vfprintf_r+0x1c62>
80009b5e:	2f 83       	sub	r3,-8
80009b60:	c0 b8       	rjmp	80009b76 <_vfprintf_r+0x1c76>
80009b62:	fa ca f9 78 	sub	r10,sp,-1672
80009b66:	02 9b       	mov	r11,r1
80009b68:	08 9c       	mov	r12,r4
80009b6a:	fe b0 f1 bd 	rcall	80007ee4 <__sprint_r>
80009b6e:	e0 81 01 48 	brne	80009dfe <_vfprintf_r+0x1efe>
80009b72:	fa c3 f9 e0 	sub	r3,sp,-1568
80009b76:	04 06       	add	r6,r2
80009b78:	fa f8 06 ac 	ld.w	r8,sp[1708]
80009b7c:	87 06       	st.w	r3[0x0],r6
80009b7e:	fa f9 06 90 	ld.w	r9,sp[1680]
80009b82:	40 66       	lddsp	r6,sp[0x18]
80009b84:	40 6e       	lddsp	lr,sp[0x18]
80009b86:	10 16       	sub	r6,r8
80009b88:	f2 08 01 08 	sub	r8,r9,r8
80009b8c:	87 16       	st.w	r3[0x4],r6
80009b8e:	1c 08       	add	r8,lr
80009b90:	fb 48 06 90 	st.w	sp[1680],r8
80009b94:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009b98:	2f f8       	sub	r8,-1
80009b9a:	fb 48 06 8c 	st.w	sp[1676],r8
80009b9e:	cb 78       	rjmp	80009d0c <_vfprintf_r+0x1e0c>
80009ba0:	40 6c       	lddsp	r12,sp[0x18]
80009ba2:	58 1c       	cp.w	r12,1
80009ba4:	e0 89 00 06 	brgt	80009bb0 <_vfprintf_r+0x1cb0>
80009ba8:	ed b5 00 00 	bld	r5,0x0
80009bac:	e0 81 00 85 	brne	80009cb6 <_vfprintf_r+0x1db6>
80009bb0:	fa f8 06 90 	ld.w	r8,sp[1680]
80009bb4:	2f f8       	sub	r8,-1
80009bb6:	30 19       	mov	r9,1
80009bb8:	fb 48 06 90 	st.w	sp[1680],r8
80009bbc:	87 06       	st.w	r3[0x0],r6
80009bbe:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009bc2:	87 19       	st.w	r3[0x4],r9
80009bc4:	2f f8       	sub	r8,-1
80009bc6:	fb 48 06 8c 	st.w	sp[1676],r8
80009bca:	58 78       	cp.w	r8,7
80009bcc:	e0 89 00 04 	brgt	80009bd4 <_vfprintf_r+0x1cd4>
80009bd0:	2f 83       	sub	r3,-8
80009bd2:	c0 b8       	rjmp	80009be8 <_vfprintf_r+0x1ce8>
80009bd4:	fa ca f9 78 	sub	r10,sp,-1672
80009bd8:	02 9b       	mov	r11,r1
80009bda:	08 9c       	mov	r12,r4
80009bdc:	fe b0 f1 84 	rcall	80007ee4 <__sprint_r>
80009be0:	e0 81 01 0f 	brne	80009dfe <_vfprintf_r+0x1efe>
80009be4:	fa c3 f9 e0 	sub	r3,sp,-1568
80009be8:	fa f8 06 90 	ld.w	r8,sp[1680]
80009bec:	2f f8       	sub	r8,-1
80009bee:	40 cb       	lddsp	r11,sp[0x30]
80009bf0:	fb 48 06 90 	st.w	sp[1680],r8
80009bf4:	30 19       	mov	r9,1
80009bf6:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009bfa:	87 0b       	st.w	r3[0x0],r11
80009bfc:	2f f8       	sub	r8,-1
80009bfe:	87 19       	st.w	r3[0x4],r9
80009c00:	fb 48 06 8c 	st.w	sp[1676],r8
80009c04:	58 78       	cp.w	r8,7
80009c06:	e0 89 00 05 	brgt	80009c10 <_vfprintf_r+0x1d10>
80009c0a:	2f 83       	sub	r3,-8
80009c0c:	c0 c8       	rjmp	80009c24 <_vfprintf_r+0x1d24>
80009c0e:	d7 03       	nop
80009c10:	fa ca f9 78 	sub	r10,sp,-1672
80009c14:	02 9b       	mov	r11,r1
80009c16:	08 9c       	mov	r12,r4
80009c18:	fe b0 f1 66 	rcall	80007ee4 <__sprint_r>
80009c1c:	e0 81 00 f1 	brne	80009dfe <_vfprintf_r+0x1efe>
80009c20:	fa c3 f9 e0 	sub	r3,sp,-1568
80009c24:	30 08       	mov	r8,0
80009c26:	30 09       	mov	r9,0
80009c28:	40 5b       	lddsp	r11,sp[0x14]
80009c2a:	40 7a       	lddsp	r10,sp[0x1c]
80009c2c:	e0 a0 13 25 	rcall	8000c276 <__avr32_f64_cmp_eq>
80009c30:	40 68       	lddsp	r8,sp[0x18]
80009c32:	20 18       	sub	r8,1
80009c34:	58 0c       	cp.w	r12,0
80009c36:	c0 d1       	brne	80009c50 <_vfprintf_r+0x1d50>
80009c38:	2f f6       	sub	r6,-1
80009c3a:	87 18       	st.w	r3[0x4],r8
80009c3c:	87 06       	st.w	r3[0x0],r6
80009c3e:	fa f6 06 90 	ld.w	r6,sp[1680]
80009c42:	10 06       	add	r6,r8
80009c44:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009c48:	fb 46 06 90 	st.w	sp[1680],r6
80009c4c:	2f f8       	sub	r8,-1
80009c4e:	c3 18       	rjmp	80009cb0 <_vfprintf_r+0x1db0>
80009c50:	10 96       	mov	r6,r8
80009c52:	58 08       	cp.w	r8,0
80009c54:	e0 89 00 1c 	brgt	80009c8c <_vfprintf_r+0x1d8c>
80009c58:	c4 b8       	rjmp	80009cee <_vfprintf_r+0x1dee>
80009c5a:	2f 09       	sub	r9,-16
80009c5c:	2f f8       	sub	r8,-1
80009c5e:	fb 49 06 90 	st.w	sp[1680],r9
80009c62:	87 02       	st.w	r3[0x0],r2
80009c64:	87 10       	st.w	r3[0x4],r0
80009c66:	fb 48 06 8c 	st.w	sp[1676],r8
80009c6a:	58 78       	cp.w	r8,7
80009c6c:	e0 89 00 04 	brgt	80009c74 <_vfprintf_r+0x1d74>
80009c70:	2f 83       	sub	r3,-8
80009c72:	c0 b8       	rjmp	80009c88 <_vfprintf_r+0x1d88>
80009c74:	fa ca f9 78 	sub	r10,sp,-1672
80009c78:	02 9b       	mov	r11,r1
80009c7a:	08 9c       	mov	r12,r4
80009c7c:	fe b0 f1 34 	rcall	80007ee4 <__sprint_r>
80009c80:	e0 81 00 bf 	brne	80009dfe <_vfprintf_r+0x1efe>
80009c84:	fa c3 f9 e0 	sub	r3,sp,-1568
80009c88:	21 06       	sub	r6,16
80009c8a:	c0 48       	rjmp	80009c92 <_vfprintf_r+0x1d92>
80009c8c:	fe c2 be 98 	sub	r2,pc,-16744
80009c90:	31 00       	mov	r0,16
80009c92:	fa f9 06 90 	ld.w	r9,sp[1680]
80009c96:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009c9a:	fe ca be a6 	sub	r10,pc,-16730
80009c9e:	59 06       	cp.w	r6,16
80009ca0:	fe 99 ff dd 	brgt	80009c5a <_vfprintf_r+0x1d5a>
80009ca4:	0c 09       	add	r9,r6
80009ca6:	87 0a       	st.w	r3[0x0],r10
80009ca8:	fb 49 06 90 	st.w	sp[1680],r9
80009cac:	2f f8       	sub	r8,-1
80009cae:	87 16       	st.w	r3[0x4],r6
80009cb0:	fb 48 06 8c 	st.w	sp[1676],r8
80009cb4:	c0 e8       	rjmp	80009cd0 <_vfprintf_r+0x1dd0>
80009cb6:	fa f8 06 90 	ld.w	r8,sp[1680]
80009cba:	2f f8       	sub	r8,-1
80009cbc:	30 19       	mov	r9,1
80009cbe:	fb 48 06 90 	st.w	sp[1680],r8
80009cc2:	87 06       	st.w	r3[0x0],r6
80009cc4:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009cc8:	87 19       	st.w	r3[0x4],r9
80009cca:	2f f8       	sub	r8,-1
80009ccc:	fb 48 06 8c 	st.w	sp[1676],r8
80009cd0:	58 78       	cp.w	r8,7
80009cd2:	e0 89 00 04 	brgt	80009cda <_vfprintf_r+0x1dda>
80009cd6:	2f 83       	sub	r3,-8
80009cd8:	c0 b8       	rjmp	80009cee <_vfprintf_r+0x1dee>
80009cda:	fa ca f9 78 	sub	r10,sp,-1672
80009cde:	02 9b       	mov	r11,r1
80009ce0:	08 9c       	mov	r12,r4
80009ce2:	fe b0 f1 01 	rcall	80007ee4 <__sprint_r>
80009ce6:	e0 81 00 8c 	brne	80009dfe <_vfprintf_r+0x1efe>
80009cea:	fa c3 f9 e0 	sub	r3,sp,-1568
80009cee:	40 ea       	lddsp	r10,sp[0x38]
80009cf0:	fa f8 06 90 	ld.w	r8,sp[1680]
80009cf4:	14 08       	add	r8,r10
80009cf6:	fa c9 f9 64 	sub	r9,sp,-1692
80009cfa:	fb 48 06 90 	st.w	sp[1680],r8
80009cfe:	87 1a       	st.w	r3[0x4],r10
80009d00:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009d04:	87 09       	st.w	r3[0x0],r9
80009d06:	2f f8       	sub	r8,-1
80009d08:	fb 48 06 8c 	st.w	sp[1676],r8
80009d0c:	58 78       	cp.w	r8,7
80009d0e:	e0 89 00 04 	brgt	80009d16 <_vfprintf_r+0x1e16>
80009d12:	2f 83       	sub	r3,-8
80009d14:	c0 a8       	rjmp	80009d28 <_vfprintf_r+0x1e28>
80009d16:	fa ca f9 78 	sub	r10,sp,-1672
80009d1a:	02 9b       	mov	r11,r1
80009d1c:	08 9c       	mov	r12,r4
80009d1e:	fe b0 f0 e3 	rcall	80007ee4 <__sprint_r>
80009d22:	c6 e1       	brne	80009dfe <_vfprintf_r+0x1efe>
80009d24:	fa c3 f9 e0 	sub	r3,sp,-1568
80009d28:	e2 15 00 04 	andl	r5,0x4,COH
80009d2c:	c3 f0       	breq	80009daa <_vfprintf_r+0x1eaa>
80009d2e:	40 86       	lddsp	r6,sp[0x20]
80009d30:	40 39       	lddsp	r9,sp[0xc]
80009d32:	12 16       	sub	r6,r9
80009d34:	58 06       	cp.w	r6,0
80009d36:	e0 89 00 1a 	brgt	80009d6a <_vfprintf_r+0x1e6a>
80009d3a:	c3 88       	rjmp	80009daa <_vfprintf_r+0x1eaa>
80009d3c:	2f 09       	sub	r9,-16
80009d3e:	2f f8       	sub	r8,-1
80009d40:	fb 49 06 90 	st.w	sp[1680],r9
80009d44:	87 05       	st.w	r3[0x0],r5
80009d46:	87 12       	st.w	r3[0x4],r2
80009d48:	fb 48 06 8c 	st.w	sp[1676],r8
80009d4c:	58 78       	cp.w	r8,7
80009d4e:	e0 89 00 04 	brgt	80009d56 <_vfprintf_r+0x1e56>
80009d52:	2f 83       	sub	r3,-8
80009d54:	c0 98       	rjmp	80009d66 <_vfprintf_r+0x1e66>
80009d56:	00 9a       	mov	r10,r0
80009d58:	02 9b       	mov	r11,r1
80009d5a:	08 9c       	mov	r12,r4
80009d5c:	fe b0 f0 c4 	rcall	80007ee4 <__sprint_r>
80009d60:	c4 f1       	brne	80009dfe <_vfprintf_r+0x1efe>
80009d62:	fa c3 f9 e0 	sub	r3,sp,-1568
80009d66:	21 06       	sub	r6,16
80009d68:	c0 68       	rjmp	80009d74 <_vfprintf_r+0x1e74>
80009d6a:	fe c5 bf 86 	sub	r5,pc,-16506
80009d6e:	31 02       	mov	r2,16
80009d70:	fa c0 f9 78 	sub	r0,sp,-1672
80009d74:	fa f9 06 90 	ld.w	r9,sp[1680]
80009d78:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009d7c:	fe ca bf 98 	sub	r10,pc,-16488
80009d80:	59 06       	cp.w	r6,16
80009d82:	fe 99 ff dd 	brgt	80009d3c <_vfprintf_r+0x1e3c>
80009d86:	0c 09       	add	r9,r6
80009d88:	2f f8       	sub	r8,-1
80009d8a:	87 0a       	st.w	r3[0x0],r10
80009d8c:	87 16       	st.w	r3[0x4],r6
80009d8e:	fb 49 06 90 	st.w	sp[1680],r9
80009d92:	fb 48 06 8c 	st.w	sp[1676],r8
80009d96:	58 78       	cp.w	r8,7
80009d98:	e0 8a 00 09 	brle	80009daa <_vfprintf_r+0x1eaa>
80009d9c:	fa ca f9 78 	sub	r10,sp,-1672
80009da0:	02 9b       	mov	r11,r1
80009da2:	08 9c       	mov	r12,r4
80009da4:	fe b0 f0 a0 	rcall	80007ee4 <__sprint_r>
80009da8:	c2 b1       	brne	80009dfe <_vfprintf_r+0x1efe>
80009daa:	40 bc       	lddsp	r12,sp[0x2c]
80009dac:	40 36       	lddsp	r6,sp[0xc]
80009dae:	40 8e       	lddsp	lr,sp[0x20]
80009db0:	ec 0e 0c 48 	max	r8,r6,lr
80009db4:	10 0c       	add	r12,r8
80009db6:	50 bc       	stdsp	sp[0x2c],r12
80009db8:	fa f8 06 90 	ld.w	r8,sp[1680]
80009dbc:	58 08       	cp.w	r8,0
80009dbe:	c0 80       	breq	80009dce <_vfprintf_r+0x1ece>
80009dc0:	fa ca f9 78 	sub	r10,sp,-1672
80009dc4:	02 9b       	mov	r11,r1
80009dc6:	08 9c       	mov	r12,r4
80009dc8:	fe b0 f0 8e 	rcall	80007ee4 <__sprint_r>
80009dcc:	c1 91       	brne	80009dfe <_vfprintf_r+0x1efe>
80009dce:	30 0b       	mov	r11,0
80009dd0:	fa c3 f9 e0 	sub	r3,sp,-1568
80009dd4:	fb 4b 06 8c 	st.w	sp[1676],r11
80009dd8:	fe 9f f1 22 	bral	8000801c <_vfprintf_r+0x11c>
80009ddc:	08 95       	mov	r5,r4
80009dde:	fa f8 06 90 	ld.w	r8,sp[1680]
80009de2:	58 08       	cp.w	r8,0
80009de4:	c0 80       	breq	80009df4 <_vfprintf_r+0x1ef4>
80009de6:	08 9c       	mov	r12,r4
80009de8:	fa ca f9 78 	sub	r10,sp,-1672
80009dec:	02 9b       	mov	r11,r1
80009dee:	fe b0 f0 7b 	rcall	80007ee4 <__sprint_r>
80009df2:	c0 61       	brne	80009dfe <_vfprintf_r+0x1efe>
80009df4:	30 08       	mov	r8,0
80009df6:	fb 48 06 8c 	st.w	sp[1676],r8
80009dfa:	c0 28       	rjmp	80009dfe <_vfprintf_r+0x1efe>
80009dfc:	40 41       	lddsp	r1,sp[0x10]
80009dfe:	82 68       	ld.sh	r8,r1[0xc]
80009e00:	ed b8 00 06 	bld	r8,0x6
80009e04:	c0 31       	brne	80009e0a <_vfprintf_r+0x1f0a>
80009e06:	3f fa       	mov	r10,-1
80009e08:	50 ba       	stdsp	sp[0x2c],r10
80009e0a:	40 bc       	lddsp	r12,sp[0x2c]
80009e0c:	fe 3d f9 44 	sub	sp,-1724
80009e10:	d8 32       	popm	r0-r7,pc
80009e12:	d7 03       	nop

80009e14 <__swsetup_r>:
80009e14:	d4 21       	pushm	r4-r7,lr
80009e16:	e0 68 0a 3c 	mov	r8,2620
80009e1a:	18 96       	mov	r6,r12
80009e1c:	16 97       	mov	r7,r11
80009e1e:	70 0c       	ld.w	r12,r8[0x0]
80009e20:	58 0c       	cp.w	r12,0
80009e22:	c0 60       	breq	80009e2e <__swsetup_r+0x1a>
80009e24:	78 68       	ld.w	r8,r12[0x18]
80009e26:	58 08       	cp.w	r8,0
80009e28:	c0 31       	brne	80009e2e <__swsetup_r+0x1a>
80009e2a:	e0 a0 07 bf 	rcall	8000ada8 <__sinit>
80009e2e:	fe c8 bf 1a 	sub	r8,pc,-16614
80009e32:	10 37       	cp.w	r7,r8
80009e34:	c0 61       	brne	80009e40 <__swsetup_r+0x2c>
80009e36:	e0 68 0a 3c 	mov	r8,2620
80009e3a:	70 08       	ld.w	r8,r8[0x0]
80009e3c:	70 07       	ld.w	r7,r8[0x0]
80009e3e:	c1 28       	rjmp	80009e62 <__swsetup_r+0x4e>
80009e40:	fe c8 bf 0c 	sub	r8,pc,-16628
80009e44:	10 37       	cp.w	r7,r8
80009e46:	c0 61       	brne	80009e52 <__swsetup_r+0x3e>
80009e48:	e0 68 0a 3c 	mov	r8,2620
80009e4c:	70 08       	ld.w	r8,r8[0x0]
80009e4e:	70 17       	ld.w	r7,r8[0x4]
80009e50:	c0 98       	rjmp	80009e62 <__swsetup_r+0x4e>
80009e52:	fe c8 be fe 	sub	r8,pc,-16642
80009e56:	10 37       	cp.w	r7,r8
80009e58:	c0 51       	brne	80009e62 <__swsetup_r+0x4e>
80009e5a:	e0 68 0a 3c 	mov	r8,2620
80009e5e:	70 08       	ld.w	r8,r8[0x0]
80009e60:	70 27       	ld.w	r7,r8[0x8]
80009e62:	8e 68       	ld.sh	r8,r7[0xc]
80009e64:	ed b8 00 03 	bld	r8,0x3
80009e68:	c1 e0       	breq	80009ea4 <__swsetup_r+0x90>
80009e6a:	ed b8 00 04 	bld	r8,0x4
80009e6e:	c3 e1       	brne	80009eea <__swsetup_r+0xd6>
80009e70:	ed b8 00 02 	bld	r8,0x2
80009e74:	c1 51       	brne	80009e9e <__swsetup_r+0x8a>
80009e76:	6e db       	ld.w	r11,r7[0x34]
80009e78:	58 0b       	cp.w	r11,0
80009e7a:	c0 a0       	breq	80009e8e <__swsetup_r+0x7a>
80009e7c:	ee c8 ff bc 	sub	r8,r7,-68
80009e80:	10 3b       	cp.w	r11,r8
80009e82:	c0 40       	breq	80009e8a <__swsetup_r+0x76>
80009e84:	0c 9c       	mov	r12,r6
80009e86:	e0 a0 08 2b 	rcall	8000aedc <_free_r>
80009e8a:	30 08       	mov	r8,0
80009e8c:	8f d8       	st.w	r7[0x34],r8
80009e8e:	8e 68       	ld.sh	r8,r7[0xc]
80009e90:	e0 18 ff db 	andl	r8,0xffdb
80009e94:	ae 68       	st.h	r7[0xc],r8
80009e96:	30 08       	mov	r8,0
80009e98:	8f 18       	st.w	r7[0x4],r8
80009e9a:	6e 48       	ld.w	r8,r7[0x10]
80009e9c:	8f 08       	st.w	r7[0x0],r8
80009e9e:	8e 68       	ld.sh	r8,r7[0xc]
80009ea0:	a3 b8       	sbr	r8,0x3
80009ea2:	ae 68       	st.h	r7[0xc],r8
80009ea4:	6e 48       	ld.w	r8,r7[0x10]
80009ea6:	58 08       	cp.w	r8,0
80009ea8:	c0 b1       	brne	80009ebe <__swsetup_r+0xaa>
80009eaa:	8e 68       	ld.sh	r8,r7[0xc]
80009eac:	e2 18 02 80 	andl	r8,0x280,COH
80009eb0:	e0 48 02 00 	cp.w	r8,512
80009eb4:	c0 50       	breq	80009ebe <__swsetup_r+0xaa>
80009eb6:	0c 9c       	mov	r12,r6
80009eb8:	0e 9b       	mov	r11,r7
80009eba:	e0 a0 0a 4b 	rcall	8000b350 <__smakebuf_r>
80009ebe:	8e 69       	ld.sh	r9,r7[0xc]
80009ec0:	f1 d9 c0 01 	bfextu	r8,r9,0x0,0x1
80009ec4:	c0 70       	breq	80009ed2 <__swsetup_r+0xbe>
80009ec6:	30 08       	mov	r8,0
80009ec8:	8f 28       	st.w	r7[0x8],r8
80009eca:	6e 58       	ld.w	r8,r7[0x14]
80009ecc:	5c 38       	neg	r8
80009ece:	8f 68       	st.w	r7[0x18],r8
80009ed0:	c0 68       	rjmp	80009edc <__swsetup_r+0xc8>
80009ed2:	ed b9 00 01 	bld	r9,0x1
80009ed6:	ef f8 10 05 	ld.wne	r8,r7[0x14]
80009eda:	8f 28       	st.w	r7[0x8],r8
80009edc:	6e 48       	ld.w	r8,r7[0x10]
80009ede:	58 08       	cp.w	r8,0
80009ee0:	c0 61       	brne	80009eec <__swsetup_r+0xd8>
80009ee2:	8e 68       	ld.sh	r8,r7[0xc]
80009ee4:	ed b8 00 07 	bld	r8,0x7
80009ee8:	c0 21       	brne	80009eec <__swsetup_r+0xd8>
80009eea:	dc 2a       	popm	r4-r7,pc,r12=-1
80009eec:	d8 2a       	popm	r4-r7,pc,r12=0
80009eee:	d7 03       	nop

80009ef0 <quorem>:
80009ef0:	d4 31       	pushm	r0-r7,lr
80009ef2:	20 2d       	sub	sp,8
80009ef4:	18 97       	mov	r7,r12
80009ef6:	78 48       	ld.w	r8,r12[0x10]
80009ef8:	76 46       	ld.w	r6,r11[0x10]
80009efa:	0c 38       	cp.w	r8,r6
80009efc:	c0 34       	brge	80009f02 <quorem+0x12>
80009efe:	30 0c       	mov	r12,0
80009f00:	c8 58       	rjmp	8000a00a <quorem+0x11a>
80009f02:	ec c2 ff fc 	sub	r2,r6,-4
80009f06:	f6 c3 ff ec 	sub	r3,r11,-20
80009f0a:	f6 02 03 29 	ld.w	r9,r11[r2<<0x2]
80009f0e:	f8 02 03 2c 	ld.w	r12,r12[r2<<0x2]
80009f12:	2f f9       	sub	r9,-1
80009f14:	20 16       	sub	r6,1
80009f16:	f8 09 0d 08 	divu	r8,r12,r9
80009f1a:	f6 02 00 22 	add	r2,r11,r2<<0x2
80009f1e:	ee c4 ff ec 	sub	r4,r7,-20
80009f22:	10 95       	mov	r5,r8
80009f24:	58 08       	cp.w	r8,0
80009f26:	c4 10       	breq	80009fa8 <quorem+0xb8>
80009f28:	30 09       	mov	r9,0
80009f2a:	06 9a       	mov	r10,r3
80009f2c:	08 98       	mov	r8,r4
80009f2e:	12 91       	mov	r1,r9
80009f30:	50 0b       	stdsp	sp[0x0],r11
80009f32:	70 0e       	ld.w	lr,r8[0x0]
80009f34:	b1 8e       	lsr	lr,0x10
80009f36:	50 1e       	stdsp	sp[0x4],lr
80009f38:	15 0e       	ld.w	lr,r10++
80009f3a:	fc 00 16 10 	lsr	r0,lr,0x10
80009f3e:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
80009f42:	ea 0e 03 41 	mac	r1,r5,lr
80009f46:	fd d1 c0 10 	bfextu	lr,r1,0x0,0x10
80009f4a:	b1 81       	lsr	r1,0x10
80009f4c:	40 1b       	lddsp	r11,sp[0x4]
80009f4e:	ea 00 02 40 	mul	r0,r5,r0
80009f52:	e2 00 00 00 	add	r0,r1,r0
80009f56:	e3 d0 c0 10 	bfextu	r1,r0,0x0,0x10
80009f5a:	02 1b       	sub	r11,r1
80009f5c:	50 1b       	stdsp	sp[0x4],r11
80009f5e:	70 0b       	ld.w	r11,r8[0x0]
80009f60:	e3 db c0 10 	bfextu	r1,r11,0x0,0x10
80009f64:	02 09       	add	r9,r1
80009f66:	f2 0e 01 0e 	sub	lr,r9,lr
80009f6a:	b0 1e       	st.h	r8[0x2],lr
80009f6c:	fc 09 14 10 	asr	r9,lr,0x10
80009f70:	40 1e       	lddsp	lr,sp[0x4]
80009f72:	fc 09 00 09 	add	r9,lr,r9
80009f76:	b0 09       	st.h	r8[0x0],r9
80009f78:	e0 01 16 10 	lsr	r1,r0,0x10
80009f7c:	2f c8       	sub	r8,-4
80009f7e:	b1 49       	asr	r9,0x10
80009f80:	04 3a       	cp.w	r10,r2
80009f82:	fe 98 ff d8 	brls	80009f32 <quorem+0x42>
80009f86:	40 0b       	lddsp	r11,sp[0x0]
80009f88:	58 0c       	cp.w	r12,0
80009f8a:	c0 f1       	brne	80009fa8 <quorem+0xb8>
80009f8c:	ec c8 ff fb 	sub	r8,r6,-5
80009f90:	ee 08 00 28 	add	r8,r7,r8<<0x2
80009f94:	c0 28       	rjmp	80009f98 <quorem+0xa8>
80009f96:	20 16       	sub	r6,1
80009f98:	20 48       	sub	r8,4
80009f9a:	08 38       	cp.w	r8,r4
80009f9c:	e0 88 00 05 	brls	80009fa6 <quorem+0xb6>
80009fa0:	70 09       	ld.w	r9,r8[0x0]
80009fa2:	58 09       	cp.w	r9,0
80009fa4:	cf 90       	breq	80009f96 <quorem+0xa6>
80009fa6:	8f 46       	st.w	r7[0x10],r6
80009fa8:	0e 9c       	mov	r12,r7
80009faa:	e0 a0 0a d2 	rcall	8000b54e <__mcmp>
80009fae:	c2 d5       	brlt	8000a008 <quorem+0x118>
80009fb0:	2f f5       	sub	r5,-1
80009fb2:	08 98       	mov	r8,r4
80009fb4:	30 09       	mov	r9,0
80009fb6:	07 0b       	ld.w	r11,r3++
80009fb8:	f6 0a 16 10 	lsr	r10,r11,0x10
80009fbc:	70 0c       	ld.w	r12,r8[0x0]
80009fbe:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
80009fc2:	f8 0e 16 10 	lsr	lr,r12,0x10
80009fc6:	14 1e       	sub	lr,r10
80009fc8:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
80009fcc:	16 1a       	sub	r10,r11
80009fce:	12 0a       	add	r10,r9
80009fd0:	b0 1a       	st.h	r8[0x2],r10
80009fd2:	b1 4a       	asr	r10,0x10
80009fd4:	fc 0a 00 09 	add	r9,lr,r10
80009fd8:	b0 09       	st.h	r8[0x0],r9
80009fda:	2f c8       	sub	r8,-4
80009fdc:	b1 49       	asr	r9,0x10
80009fde:	04 33       	cp.w	r3,r2
80009fe0:	fe 98 ff eb 	brls	80009fb6 <quorem+0xc6>
80009fe4:	ec c8 ff fb 	sub	r8,r6,-5
80009fe8:	ee 08 03 29 	ld.w	r9,r7[r8<<0x2]
80009fec:	58 09       	cp.w	r9,0
80009fee:	c0 d1       	brne	8000a008 <quorem+0x118>
80009ff0:	ee 08 00 28 	add	r8,r7,r8<<0x2
80009ff4:	c0 28       	rjmp	80009ff8 <quorem+0x108>
80009ff6:	20 16       	sub	r6,1
80009ff8:	20 48       	sub	r8,4
80009ffa:	08 38       	cp.w	r8,r4
80009ffc:	e0 88 00 05 	brls	8000a006 <quorem+0x116>
8000a000:	70 09       	ld.w	r9,r8[0x0]
8000a002:	58 09       	cp.w	r9,0
8000a004:	cf 90       	breq	80009ff6 <quorem+0x106>
8000a006:	8f 46       	st.w	r7[0x10],r6
8000a008:	0a 9c       	mov	r12,r5
8000a00a:	2f ed       	sub	sp,-8
8000a00c:	d8 32       	popm	r0-r7,pc
8000a00e:	d7 03       	nop

8000a010 <_dtoa_r>:
8000a010:	d4 31       	pushm	r0-r7,lr
8000a012:	21 ad       	sub	sp,104
8000a014:	fa c4 ff 74 	sub	r4,sp,-140
8000a018:	18 97       	mov	r7,r12
8000a01a:	16 95       	mov	r5,r11
8000a01c:	68 2c       	ld.w	r12,r4[0x8]
8000a01e:	50 c9       	stdsp	sp[0x30],r9
8000a020:	68 16       	ld.w	r6,r4[0x4]
8000a022:	68 09       	ld.w	r9,r4[0x0]
8000a024:	50 e8       	stdsp	sp[0x38],r8
8000a026:	14 94       	mov	r4,r10
8000a028:	51 2c       	stdsp	sp[0x48],r12
8000a02a:	fa e5 00 08 	st.d	sp[8],r4
8000a02e:	51 59       	stdsp	sp[0x54],r9
8000a030:	6e 95       	ld.w	r5,r7[0x24]
8000a032:	58 05       	cp.w	r5,0
8000a034:	c0 91       	brne	8000a046 <_dtoa_r+0x36>
8000a036:	31 0c       	mov	r12,16
8000a038:	fe b0 e8 f4 	rcall	80007220 <malloc>
8000a03c:	99 35       	st.w	r12[0xc],r5
8000a03e:	8f 9c       	st.w	r7[0x24],r12
8000a040:	99 15       	st.w	r12[0x4],r5
8000a042:	99 25       	st.w	r12[0x8],r5
8000a044:	99 05       	st.w	r12[0x0],r5
8000a046:	6e 99       	ld.w	r9,r7[0x24]
8000a048:	72 08       	ld.w	r8,r9[0x0]
8000a04a:	58 08       	cp.w	r8,0
8000a04c:	c0 f0       	breq	8000a06a <_dtoa_r+0x5a>
8000a04e:	72 1a       	ld.w	r10,r9[0x4]
8000a050:	91 1a       	st.w	r8[0x4],r10
8000a052:	30 1a       	mov	r10,1
8000a054:	72 19       	ld.w	r9,r9[0x4]
8000a056:	f4 09 09 49 	lsl	r9,r10,r9
8000a05a:	10 9b       	mov	r11,r8
8000a05c:	91 29       	st.w	r8[0x8],r9
8000a05e:	0e 9c       	mov	r12,r7
8000a060:	e0 a0 0a 90 	rcall	8000b580 <_Bfree>
8000a064:	6e 98       	ld.w	r8,r7[0x24]
8000a066:	30 09       	mov	r9,0
8000a068:	91 09       	st.w	r8[0x0],r9
8000a06a:	40 28       	lddsp	r8,sp[0x8]
8000a06c:	10 94       	mov	r4,r8
8000a06e:	58 08       	cp.w	r8,0
8000a070:	c0 64       	brge	8000a07c <_dtoa_r+0x6c>
8000a072:	f1 d8 c0 1f 	bfextu	r8,r8,0x0,0x1f
8000a076:	50 28       	stdsp	sp[0x8],r8
8000a078:	30 18       	mov	r8,1
8000a07a:	c0 28       	rjmp	8000a07e <_dtoa_r+0x6e>
8000a07c:	30 08       	mov	r8,0
8000a07e:	8d 08       	st.w	r6[0x0],r8
8000a080:	fc 1c 7f f0 	movh	r12,0x7ff0
8000a084:	40 26       	lddsp	r6,sp[0x8]
8000a086:	0c 98       	mov	r8,r6
8000a088:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000a08c:	18 38       	cp.w	r8,r12
8000a08e:	c2 01       	brne	8000a0ce <_dtoa_r+0xbe>
8000a090:	e0 68 27 0f 	mov	r8,9999
8000a094:	41 5b       	lddsp	r11,sp[0x54]
8000a096:	97 08       	st.w	r11[0x0],r8
8000a098:	40 3a       	lddsp	r10,sp[0xc]
8000a09a:	58 0a       	cp.w	r10,0
8000a09c:	c0 71       	brne	8000a0aa <_dtoa_r+0x9a>
8000a09e:	ed d6 c0 14 	bfextu	r6,r6,0x0,0x14
8000a0a2:	c0 41       	brne	8000a0aa <_dtoa_r+0x9a>
8000a0a4:	fe cc c1 a0 	sub	r12,pc,-15968
8000a0a8:	c0 38       	rjmp	8000a0ae <_dtoa_r+0x9e>
8000a0aa:	fe cc c1 9a 	sub	r12,pc,-15974
8000a0ae:	41 29       	lddsp	r9,sp[0x48]
8000a0b0:	58 09       	cp.w	r9,0
8000a0b2:	e0 80 05 9a 	breq	8000abe6 <_dtoa_r+0xbd6>
8000a0b6:	f8 c8 ff fd 	sub	r8,r12,-3
8000a0ba:	f8 c9 ff f8 	sub	r9,r12,-8
8000a0be:	11 8b       	ld.ub	r11,r8[0x0]
8000a0c0:	30 0a       	mov	r10,0
8000a0c2:	41 25       	lddsp	r5,sp[0x48]
8000a0c4:	f4 0b 18 00 	cp.b	r11,r10
8000a0c8:	f2 08 17 10 	movne	r8,r9
8000a0cc:	c1 68       	rjmp	8000a0f8 <_dtoa_r+0xe8>
8000a0ce:	fa ea 00 08 	ld.d	r10,sp[8]
8000a0d2:	30 08       	mov	r8,0
8000a0d4:	fa eb 00 3c 	st.d	sp[60],r10
8000a0d8:	30 09       	mov	r9,0
8000a0da:	e0 a0 10 ce 	rcall	8000c276 <__avr32_f64_cmp_eq>
8000a0de:	c1 00       	breq	8000a0fe <_dtoa_r+0xee>
8000a0e0:	30 18       	mov	r8,1
8000a0e2:	41 5a       	lddsp	r10,sp[0x54]
8000a0e4:	95 08       	st.w	r10[0x0],r8
8000a0e6:	fe cc c3 06 	sub	r12,pc,-15610
8000a0ea:	41 29       	lddsp	r9,sp[0x48]
8000a0ec:	f8 08 00 08 	add	r8,r12,r8
8000a0f0:	58 09       	cp.w	r9,0
8000a0f2:	e0 80 05 7a 	breq	8000abe6 <_dtoa_r+0xbd6>
8000a0f6:	12 95       	mov	r5,r9
8000a0f8:	8b 08       	st.w	r5[0x0],r8
8000a0fa:	e0 8f 05 76 	bral	8000abe6 <_dtoa_r+0xbd6>
8000a0fe:	fa c8 ff 9c 	sub	r8,sp,-100
8000a102:	fa c9 ff a0 	sub	r9,sp,-96
8000a106:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a10a:	0e 9c       	mov	r12,r7
8000a10c:	eb d6 c2 8b 	bfextu	r5,r6,0x14,0xb
8000a110:	e0 a0 0a 8a 	rcall	8000b624 <__d2b>
8000a114:	18 93       	mov	r3,r12
8000a116:	58 05       	cp.w	r5,0
8000a118:	c0 d0       	breq	8000a132 <_dtoa_r+0x122>
8000a11a:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a11e:	30 04       	mov	r4,0
8000a120:	f1 db c0 14 	bfextu	r8,r11,0x0,0x14
8000a124:	ea c5 03 ff 	sub	r5,r5,1023
8000a128:	10 9b       	mov	r11,r8
8000a12a:	51 74       	stdsp	sp[0x5c],r4
8000a12c:	ea 1b 3f f0 	orh	r11,0x3ff0
8000a130:	c2 58       	rjmp	8000a17a <_dtoa_r+0x16a>
8000a132:	41 88       	lddsp	r8,sp[0x60]
8000a134:	41 9c       	lddsp	r12,sp[0x64]
8000a136:	10 0c       	add	r12,r8
8000a138:	f8 c5 fb ce 	sub	r5,r12,-1074
8000a13c:	e0 45 00 20 	cp.w	r5,32
8000a140:	e0 8a 00 0e 	brle	8000a15c <_dtoa_r+0x14c>
8000a144:	f8 cc fb ee 	sub	r12,r12,-1042
8000a148:	40 3b       	lddsp	r11,sp[0xc]
8000a14a:	ea 08 11 40 	rsub	r8,r5,64
8000a14e:	f6 0c 0a 4c 	lsr	r12,r11,r12
8000a152:	ec 08 09 46 	lsl	r6,r6,r8
8000a156:	0c 4c       	or	r12,r6
8000a158:	c0 78       	rjmp	8000a166 <_dtoa_r+0x156>
8000a15a:	d7 03       	nop
8000a15c:	ea 0c 11 20 	rsub	r12,r5,32
8000a160:	40 3a       	lddsp	r10,sp[0xc]
8000a162:	f4 0c 09 4c 	lsl	r12,r10,r12
8000a166:	e0 a0 10 14 	rcall	8000c18e <__avr32_u32_to_f64>
8000a16a:	fc 18 fe 10 	movh	r8,0xfe10
8000a16e:	30 19       	mov	r9,1
8000a170:	ea c5 04 33 	sub	r5,r5,1075
8000a174:	f0 0b 00 0b 	add	r11,r8,r11
8000a178:	51 79       	stdsp	sp[0x5c],r9
8000a17a:	30 08       	mov	r8,0
8000a17c:	fc 19 3f f8 	movh	r9,0x3ff8
8000a180:	e0 a0 0e 9c 	rcall	8000beb8 <__avr32_f64_sub>
8000a184:	e0 68 43 61 	mov	r8,17249
8000a188:	ea 18 63 6f 	orh	r8,0x636f
8000a18c:	e0 69 87 a7 	mov	r9,34727
8000a190:	ea 19 3f d2 	orh	r9,0x3fd2
8000a194:	e0 a0 0d a6 	rcall	8000bce0 <__avr32_f64_mul>
8000a198:	e0 68 c8 b3 	mov	r8,51379
8000a19c:	ea 18 8b 60 	orh	r8,0x8b60
8000a1a0:	e0 69 8a 28 	mov	r9,35368
8000a1a4:	ea 19 3f c6 	orh	r9,0x3fc6
8000a1a8:	e0 a0 0f 56 	rcall	8000c054 <__avr32_f64_add>
8000a1ac:	0a 9c       	mov	r12,r5
8000a1ae:	14 90       	mov	r0,r10
8000a1b0:	16 91       	mov	r1,r11
8000a1b2:	e0 a0 0f f2 	rcall	8000c196 <__avr32_s32_to_f64>
8000a1b6:	e0 68 79 fb 	mov	r8,31227
8000a1ba:	ea 18 50 9f 	orh	r8,0x509f
8000a1be:	e0 69 44 13 	mov	r9,17427
8000a1c2:	ea 19 3f d3 	orh	r9,0x3fd3
8000a1c6:	e0 a0 0d 8d 	rcall	8000bce0 <__avr32_f64_mul>
8000a1ca:	14 98       	mov	r8,r10
8000a1cc:	16 99       	mov	r9,r11
8000a1ce:	00 9a       	mov	r10,r0
8000a1d0:	02 9b       	mov	r11,r1
8000a1d2:	e0 a0 0f 41 	rcall	8000c054 <__avr32_f64_add>
8000a1d6:	14 90       	mov	r0,r10
8000a1d8:	16 91       	mov	r1,r11
8000a1da:	e0 a0 0f c7 	rcall	8000c168 <__avr32_f64_to_s32>
8000a1de:	30 08       	mov	r8,0
8000a1e0:	18 96       	mov	r6,r12
8000a1e2:	30 09       	mov	r9,0
8000a1e4:	00 9a       	mov	r10,r0
8000a1e6:	02 9b       	mov	r11,r1
8000a1e8:	e0 a0 10 8e 	rcall	8000c304 <__avr32_f64_cmp_lt>
8000a1ec:	c0 c0       	breq	8000a204 <_dtoa_r+0x1f4>
8000a1ee:	0c 9c       	mov	r12,r6
8000a1f0:	e0 a0 0f d3 	rcall	8000c196 <__avr32_s32_to_f64>
8000a1f4:	14 98       	mov	r8,r10
8000a1f6:	16 99       	mov	r9,r11
8000a1f8:	00 9a       	mov	r10,r0
8000a1fa:	02 9b       	mov	r11,r1
8000a1fc:	e0 a0 10 3d 	rcall	8000c276 <__avr32_f64_cmp_eq>
8000a200:	f7 b6 00 01 	subeq	r6,1
8000a204:	59 66       	cp.w	r6,22
8000a206:	e0 88 00 05 	brls	8000a210 <_dtoa_r+0x200>
8000a20a:	30 18       	mov	r8,1
8000a20c:	51 48       	stdsp	sp[0x50],r8
8000a20e:	c1 38       	rjmp	8000a234 <_dtoa_r+0x224>
8000a210:	fe c8 c2 4c 	sub	r8,pc,-15796
8000a214:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a218:	f0 06 02 38 	ld.d	r8,r8[r6<<0x3]
8000a21c:	e0 a0 10 74 	rcall	8000c304 <__avr32_f64_cmp_lt>
8000a220:	f9 b4 00 00 	moveq	r4,0
8000a224:	fb f4 0a 14 	st.weq	sp[0x50],r4
8000a228:	f7 b6 01 01 	subne	r6,1
8000a22c:	f9 bc 01 00 	movne	r12,0
8000a230:	fb fc 1a 14 	st.wne	sp[0x50],r12
8000a234:	41 90       	lddsp	r0,sp[0x64]
8000a236:	20 10       	sub	r0,1
8000a238:	0a 10       	sub	r0,r5
8000a23a:	c0 46       	brmi	8000a242 <_dtoa_r+0x232>
8000a23c:	50 40       	stdsp	sp[0x10],r0
8000a23e:	30 00       	mov	r0,0
8000a240:	c0 48       	rjmp	8000a248 <_dtoa_r+0x238>
8000a242:	30 0b       	mov	r11,0
8000a244:	5c 30       	neg	r0
8000a246:	50 4b       	stdsp	sp[0x10],r11
8000a248:	ec 02 11 00 	rsub	r2,r6,0
8000a24c:	58 06       	cp.w	r6,0
8000a24e:	fb fa 40 04 	ld.wge	r10,sp[0x10]
8000a252:	f5 d6 e4 0a 	addge	r10,r10,r6
8000a256:	fb fa 4a 04 	st.wge	sp[0x10],r10
8000a25a:	fb f6 4a 11 	st.wge	sp[0x44],r6
8000a25e:	f9 b2 04 00 	movge	r2,0
8000a262:	e1 d6 e5 10 	sublt	r0,r0,r6
8000a266:	f9 b9 05 00 	movlt	r9,0
8000a26a:	fb f9 5a 11 	st.wlt	sp[0x44],r9
8000a26e:	40 c8       	lddsp	r8,sp[0x30]
8000a270:	58 98       	cp.w	r8,9
8000a272:	e0 8b 00 20 	brhi	8000a2b2 <_dtoa_r+0x2a2>
8000a276:	58 58       	cp.w	r8,5
8000a278:	f9 b4 0a 01 	movle	r4,1
8000a27c:	fb f5 90 0c 	ld.wgt	r5,sp[0x30]
8000a280:	f7 b5 09 04 	subgt	r5,4
8000a284:	fb f5 9a 0c 	st.wgt	sp[0x30],r5
8000a288:	f9 b4 09 00 	movgt	r4,0
8000a28c:	40 cc       	lddsp	r12,sp[0x30]
8000a28e:	58 3c       	cp.w	r12,3
8000a290:	c2 d0       	breq	8000a2ea <_dtoa_r+0x2da>
8000a292:	e0 89 00 05 	brgt	8000a29c <_dtoa_r+0x28c>
8000a296:	58 2c       	cp.w	r12,2
8000a298:	c1 01       	brne	8000a2b8 <_dtoa_r+0x2a8>
8000a29a:	c1 88       	rjmp	8000a2ca <_dtoa_r+0x2ba>
8000a29c:	40 cb       	lddsp	r11,sp[0x30]
8000a29e:	58 4b       	cp.w	r11,4
8000a2a0:	c0 60       	breq	8000a2ac <_dtoa_r+0x29c>
8000a2a2:	58 5b       	cp.w	r11,5
8000a2a4:	c0 a1       	brne	8000a2b8 <_dtoa_r+0x2a8>
8000a2a6:	30 1a       	mov	r10,1
8000a2a8:	50 da       	stdsp	sp[0x34],r10
8000a2aa:	c2 28       	rjmp	8000a2ee <_dtoa_r+0x2de>
8000a2ac:	30 19       	mov	r9,1
8000a2ae:	50 d9       	stdsp	sp[0x34],r9
8000a2b0:	c0 f8       	rjmp	8000a2ce <_dtoa_r+0x2be>
8000a2b2:	30 08       	mov	r8,0
8000a2b4:	30 14       	mov	r4,1
8000a2b6:	50 c8       	stdsp	sp[0x30],r8
8000a2b8:	3f f5       	mov	r5,-1
8000a2ba:	30 1c       	mov	r12,1
8000a2bc:	30 0b       	mov	r11,0
8000a2be:	50 95       	stdsp	sp[0x24],r5
8000a2c0:	50 dc       	stdsp	sp[0x34],r12
8000a2c2:	0a 91       	mov	r1,r5
8000a2c4:	31 28       	mov	r8,18
8000a2c6:	50 eb       	stdsp	sp[0x38],r11
8000a2c8:	c2 08       	rjmp	8000a308 <_dtoa_r+0x2f8>
8000a2ca:	30 0a       	mov	r10,0
8000a2cc:	50 da       	stdsp	sp[0x34],r10
8000a2ce:	40 e9       	lddsp	r9,sp[0x38]
8000a2d0:	58 09       	cp.w	r9,0
8000a2d2:	e0 89 00 07 	brgt	8000a2e0 <_dtoa_r+0x2d0>
8000a2d6:	30 18       	mov	r8,1
8000a2d8:	50 98       	stdsp	sp[0x24],r8
8000a2da:	10 91       	mov	r1,r8
8000a2dc:	50 e8       	stdsp	sp[0x38],r8
8000a2de:	c1 58       	rjmp	8000a308 <_dtoa_r+0x2f8>
8000a2e0:	40 e5       	lddsp	r5,sp[0x38]
8000a2e2:	50 95       	stdsp	sp[0x24],r5
8000a2e4:	0a 91       	mov	r1,r5
8000a2e6:	0a 98       	mov	r8,r5
8000a2e8:	c1 08       	rjmp	8000a308 <_dtoa_r+0x2f8>
8000a2ea:	30 0c       	mov	r12,0
8000a2ec:	50 dc       	stdsp	sp[0x34],r12
8000a2ee:	40 eb       	lddsp	r11,sp[0x38]
8000a2f0:	ec 0b 00 0b 	add	r11,r6,r11
8000a2f4:	50 9b       	stdsp	sp[0x24],r11
8000a2f6:	16 98       	mov	r8,r11
8000a2f8:	2f f8       	sub	r8,-1
8000a2fa:	58 08       	cp.w	r8,0
8000a2fc:	e0 89 00 05 	brgt	8000a306 <_dtoa_r+0x2f6>
8000a300:	10 91       	mov	r1,r8
8000a302:	30 18       	mov	r8,1
8000a304:	c0 28       	rjmp	8000a308 <_dtoa_r+0x2f8>
8000a306:	10 91       	mov	r1,r8
8000a308:	30 09       	mov	r9,0
8000a30a:	6e 9a       	ld.w	r10,r7[0x24]
8000a30c:	95 19       	st.w	r10[0x4],r9
8000a30e:	30 49       	mov	r9,4
8000a310:	c0 68       	rjmp	8000a31c <_dtoa_r+0x30c>
8000a312:	d7 03       	nop
8000a314:	6a 1a       	ld.w	r10,r5[0x4]
8000a316:	a1 79       	lsl	r9,0x1
8000a318:	2f fa       	sub	r10,-1
8000a31a:	8b 1a       	st.w	r5[0x4],r10
8000a31c:	6e 95       	ld.w	r5,r7[0x24]
8000a31e:	f2 ca ff ec 	sub	r10,r9,-20
8000a322:	10 3a       	cp.w	r10,r8
8000a324:	fe 98 ff f8 	brls	8000a314 <_dtoa_r+0x304>
8000a328:	6a 1b       	ld.w	r11,r5[0x4]
8000a32a:	0e 9c       	mov	r12,r7
8000a32c:	e0 a0 09 44 	rcall	8000b5b4 <_Balloc>
8000a330:	58 e1       	cp.w	r1,14
8000a332:	5f 88       	srls	r8
8000a334:	8b 0c       	st.w	r5[0x0],r12
8000a336:	f1 e4 00 04 	and	r4,r8,r4
8000a33a:	6e 98       	ld.w	r8,r7[0x24]
8000a33c:	70 08       	ld.w	r8,r8[0x0]
8000a33e:	50 88       	stdsp	sp[0x20],r8
8000a340:	e0 80 01 82 	breq	8000a644 <_dtoa_r+0x634>
8000a344:	58 06       	cp.w	r6,0
8000a346:	e0 8a 00 43 	brle	8000a3cc <_dtoa_r+0x3bc>
8000a34a:	f3 d6 c0 04 	bfextu	r9,r6,0x0,0x4
8000a34e:	fe c8 c3 8a 	sub	r8,pc,-15478
8000a352:	f0 09 02 34 	ld.d	r4,r8[r9<<0x3]
8000a356:	fa e5 00 18 	st.d	sp[24],r4
8000a35a:	ec 04 14 04 	asr	r4,r6,0x4
8000a35e:	ed b4 00 04 	bld	r4,0x4
8000a362:	c0 30       	breq	8000a368 <_dtoa_r+0x358>
8000a364:	30 25       	mov	r5,2
8000a366:	c1 08       	rjmp	8000a386 <_dtoa_r+0x376>
8000a368:	fe c8 c2 dc 	sub	r8,pc,-15652
8000a36c:	f0 e8 00 20 	ld.d	r8,r8[32]
8000a370:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a374:	e9 d4 c0 04 	bfextu	r4,r4,0x0,0x4
8000a378:	e0 a0 0f fa 	rcall	8000c36c <__avr32_f64_div>
8000a37c:	30 35       	mov	r5,3
8000a37e:	14 98       	mov	r8,r10
8000a380:	16 99       	mov	r9,r11
8000a382:	fa e9 00 08 	st.d	sp[8],r8
8000a386:	fe cc c2 fa 	sub	r12,pc,-15622
8000a38a:	50 a3       	stdsp	sp[0x28],r3
8000a38c:	0c 93       	mov	r3,r6
8000a38e:	18 96       	mov	r6,r12
8000a390:	c0 f8       	rjmp	8000a3ae <_dtoa_r+0x39e>
8000a392:	fa ea 00 18 	ld.d	r10,sp[24]
8000a396:	ed b4 00 00 	bld	r4,0x0
8000a39a:	c0 81       	brne	8000a3aa <_dtoa_r+0x39a>
8000a39c:	ec e8 00 00 	ld.d	r8,r6[0]
8000a3a0:	2f f5       	sub	r5,-1
8000a3a2:	e0 a0 0c 9f 	rcall	8000bce0 <__avr32_f64_mul>
8000a3a6:	fa eb 00 18 	st.d	sp[24],r10
8000a3aa:	a1 54       	asr	r4,0x1
8000a3ac:	2f 86       	sub	r6,-8
8000a3ae:	58 04       	cp.w	r4,0
8000a3b0:	cf 11       	brne	8000a392 <_dtoa_r+0x382>
8000a3b2:	fa e8 00 18 	ld.d	r8,sp[24]
8000a3b6:	fa ea 00 08 	ld.d	r10,sp[8]
8000a3ba:	06 96       	mov	r6,r3
8000a3bc:	e0 a0 0f d8 	rcall	8000c36c <__avr32_f64_div>
8000a3c0:	40 a3       	lddsp	r3,sp[0x28]
8000a3c2:	14 98       	mov	r8,r10
8000a3c4:	16 99       	mov	r9,r11
8000a3c6:	fa e9 00 08 	st.d	sp[8],r8
8000a3ca:	c2 f8       	rjmp	8000a428 <_dtoa_r+0x418>
8000a3cc:	ec 08 11 00 	rsub	r8,r6,0
8000a3d0:	c0 31       	brne	8000a3d6 <_dtoa_r+0x3c6>
8000a3d2:	30 25       	mov	r5,2
8000a3d4:	c2 a8       	rjmp	8000a428 <_dtoa_r+0x418>
8000a3d6:	fe cc c3 4a 	sub	r12,pc,-15542
8000a3da:	f0 04 14 04 	asr	r4,r8,0x4
8000a3de:	50 1c       	stdsp	sp[0x4],r12
8000a3e0:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
8000a3e4:	fe c9 c4 20 	sub	r9,pc,-15328
8000a3e8:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a3ec:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000a3f0:	e0 a0 0c 78 	rcall	8000bce0 <__avr32_f64_mul>
8000a3f4:	40 1c       	lddsp	r12,sp[0x4]
8000a3f6:	50 63       	stdsp	sp[0x18],r3
8000a3f8:	30 25       	mov	r5,2
8000a3fa:	0c 93       	mov	r3,r6
8000a3fc:	fa eb 00 08 	st.d	sp[8],r10
8000a400:	18 96       	mov	r6,r12
8000a402:	c0 f8       	rjmp	8000a420 <_dtoa_r+0x410>
8000a404:	fa ea 00 08 	ld.d	r10,sp[8]
8000a408:	ed b4 00 00 	bld	r4,0x0
8000a40c:	c0 81       	brne	8000a41c <_dtoa_r+0x40c>
8000a40e:	ec e8 00 00 	ld.d	r8,r6[0]
8000a412:	2f f5       	sub	r5,-1
8000a414:	e0 a0 0c 66 	rcall	8000bce0 <__avr32_f64_mul>
8000a418:	fa eb 00 08 	st.d	sp[8],r10
8000a41c:	a1 54       	asr	r4,0x1
8000a41e:	2f 86       	sub	r6,-8
8000a420:	58 04       	cp.w	r4,0
8000a422:	cf 11       	brne	8000a404 <_dtoa_r+0x3f4>
8000a424:	06 96       	mov	r6,r3
8000a426:	40 63       	lddsp	r3,sp[0x18]
8000a428:	41 4a       	lddsp	r10,sp[0x50]
8000a42a:	58 0a       	cp.w	r10,0
8000a42c:	c2 a0       	breq	8000a480 <_dtoa_r+0x470>
8000a42e:	fa e8 00 08 	ld.d	r8,sp[8]
8000a432:	58 01       	cp.w	r1,0
8000a434:	5f 94       	srgt	r4
8000a436:	fa e9 00 18 	st.d	sp[24],r8
8000a43a:	30 08       	mov	r8,0
8000a43c:	fc 19 3f f0 	movh	r9,0x3ff0
8000a440:	fa ea 00 18 	ld.d	r10,sp[24]
8000a444:	e0 a0 0f 60 	rcall	8000c304 <__avr32_f64_cmp_lt>
8000a448:	f9 bc 00 00 	moveq	r12,0
8000a44c:	f9 bc 01 01 	movne	r12,1
8000a450:	e9 ec 00 0c 	and	r12,r4,r12
8000a454:	c1 60       	breq	8000a480 <_dtoa_r+0x470>
8000a456:	40 98       	lddsp	r8,sp[0x24]
8000a458:	58 08       	cp.w	r8,0
8000a45a:	e0 8a 00 f1 	brle	8000a63c <_dtoa_r+0x62c>
8000a45e:	30 08       	mov	r8,0
8000a460:	fc 19 40 24 	movh	r9,0x4024
8000a464:	ec c4 00 01 	sub	r4,r6,1
8000a468:	fa ea 00 18 	ld.d	r10,sp[24]
8000a46c:	2f f5       	sub	r5,-1
8000a46e:	50 64       	stdsp	sp[0x18],r4
8000a470:	e0 a0 0c 38 	rcall	8000bce0 <__avr32_f64_mul>
8000a474:	40 94       	lddsp	r4,sp[0x24]
8000a476:	14 98       	mov	r8,r10
8000a478:	16 99       	mov	r9,r11
8000a47a:	fa e9 00 08 	st.d	sp[8],r8
8000a47e:	c0 38       	rjmp	8000a484 <_dtoa_r+0x474>
8000a480:	50 66       	stdsp	sp[0x18],r6
8000a482:	02 94       	mov	r4,r1
8000a484:	0a 9c       	mov	r12,r5
8000a486:	e0 a0 0e 88 	rcall	8000c196 <__avr32_s32_to_f64>
8000a48a:	fa e8 00 08 	ld.d	r8,sp[8]
8000a48e:	e0 a0 0c 29 	rcall	8000bce0 <__avr32_f64_mul>
8000a492:	30 08       	mov	r8,0
8000a494:	fc 19 40 1c 	movh	r9,0x401c
8000a498:	e0 a0 0d de 	rcall	8000c054 <__avr32_f64_add>
8000a49c:	14 98       	mov	r8,r10
8000a49e:	16 99       	mov	r9,r11
8000a4a0:	fa e9 00 28 	st.d	sp[40],r8
8000a4a4:	fc 18 fc c0 	movh	r8,0xfcc0
8000a4a8:	40 a5       	lddsp	r5,sp[0x28]
8000a4aa:	10 05       	add	r5,r8
8000a4ac:	50 a5       	stdsp	sp[0x28],r5
8000a4ae:	58 04       	cp.w	r4,0
8000a4b0:	c2 11       	brne	8000a4f2 <_dtoa_r+0x4e2>
8000a4b2:	fa ea 00 08 	ld.d	r10,sp[8]
8000a4b6:	30 08       	mov	r8,0
8000a4b8:	fc 19 40 14 	movh	r9,0x4014
8000a4bc:	e0 a0 0c fe 	rcall	8000beb8 <__avr32_f64_sub>
8000a4c0:	40 bc       	lddsp	r12,sp[0x2c]
8000a4c2:	fa eb 00 08 	st.d	sp[8],r10
8000a4c6:	14 98       	mov	r8,r10
8000a4c8:	16 99       	mov	r9,r11
8000a4ca:	18 9a       	mov	r10,r12
8000a4cc:	0a 9b       	mov	r11,r5
8000a4ce:	e0 a0 0f 1b 	rcall	8000c304 <__avr32_f64_cmp_lt>
8000a4d2:	e0 81 02 54 	brne	8000a97a <_dtoa_r+0x96a>
8000a4d6:	0a 98       	mov	r8,r5
8000a4d8:	40 b9       	lddsp	r9,sp[0x2c]
8000a4da:	ee 18 80 00 	eorh	r8,0x8000
8000a4de:	fa ea 00 08 	ld.d	r10,sp[8]
8000a4e2:	10 95       	mov	r5,r8
8000a4e4:	12 98       	mov	r8,r9
8000a4e6:	0a 99       	mov	r9,r5
8000a4e8:	e0 a0 0f 0e 	rcall	8000c304 <__avr32_f64_cmp_lt>
8000a4ec:	e0 81 02 3e 	brne	8000a968 <_dtoa_r+0x958>
8000a4f0:	ca 68       	rjmp	8000a63c <_dtoa_r+0x62c>
8000a4f2:	fe c9 c5 2e 	sub	r9,pc,-15058
8000a4f6:	e8 c8 00 01 	sub	r8,r4,1
8000a4fa:	40 d5       	lddsp	r5,sp[0x34]
8000a4fc:	58 05       	cp.w	r5,0
8000a4fe:	c4 f0       	breq	8000a59c <_dtoa_r+0x58c>
8000a500:	30 0c       	mov	r12,0
8000a502:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000a506:	51 3c       	stdsp	sp[0x4c],r12
8000a508:	30 0a       	mov	r10,0
8000a50a:	fc 1b 3f e0 	movh	r11,0x3fe0
8000a50e:	e0 a0 0f 2f 	rcall	8000c36c <__avr32_f64_div>
8000a512:	fa e8 00 28 	ld.d	r8,sp[40]
8000a516:	40 85       	lddsp	r5,sp[0x20]
8000a518:	e0 a0 0c d0 	rcall	8000beb8 <__avr32_f64_sub>
8000a51c:	fa eb 00 28 	st.d	sp[40],r10
8000a520:	fa ea 00 08 	ld.d	r10,sp[8]
8000a524:	e0 a0 0e 22 	rcall	8000c168 <__avr32_f64_to_s32>
8000a528:	51 6c       	stdsp	sp[0x58],r12
8000a52a:	e0 a0 0e 36 	rcall	8000c196 <__avr32_s32_to_f64>
8000a52e:	14 98       	mov	r8,r10
8000a530:	16 99       	mov	r9,r11
8000a532:	fa ea 00 08 	ld.d	r10,sp[8]
8000a536:	e0 a0 0c c1 	rcall	8000beb8 <__avr32_f64_sub>
8000a53a:	fa eb 00 08 	st.d	sp[8],r10
8000a53e:	41 68       	lddsp	r8,sp[0x58]
8000a540:	2d 08       	sub	r8,-48
8000a542:	0a c8       	st.b	r5++,r8
8000a544:	41 39       	lddsp	r9,sp[0x4c]
8000a546:	2f f9       	sub	r9,-1
8000a548:	51 39       	stdsp	sp[0x4c],r9
8000a54a:	fa e8 00 28 	ld.d	r8,sp[40]
8000a54e:	e0 a0 0e db 	rcall	8000c304 <__avr32_f64_cmp_lt>
8000a552:	e0 81 03 39 	brne	8000abc4 <_dtoa_r+0xbb4>
8000a556:	fa e8 00 08 	ld.d	r8,sp[8]
8000a55a:	30 0a       	mov	r10,0
8000a55c:	fc 1b 3f f0 	movh	r11,0x3ff0
8000a560:	e0 a0 0c ac 	rcall	8000beb8 <__avr32_f64_sub>
8000a564:	fa e8 00 28 	ld.d	r8,sp[40]
8000a568:	e0 a0 0e ce 	rcall	8000c304 <__avr32_f64_cmp_lt>
8000a56c:	fa ea 00 28 	ld.d	r10,sp[40]
8000a570:	30 08       	mov	r8,0
8000a572:	fc 19 40 24 	movh	r9,0x4024
8000a576:	e0 81 00 da 	brne	8000a72a <_dtoa_r+0x71a>
8000a57a:	41 3c       	lddsp	r12,sp[0x4c]
8000a57c:	08 3c       	cp.w	r12,r4
8000a57e:	c5 f4       	brge	8000a63c <_dtoa_r+0x62c>
8000a580:	e0 a0 0b b0 	rcall	8000bce0 <__avr32_f64_mul>
8000a584:	30 08       	mov	r8,0
8000a586:	fa eb 00 28 	st.d	sp[40],r10
8000a58a:	fc 19 40 24 	movh	r9,0x4024
8000a58e:	fa ea 00 08 	ld.d	r10,sp[8]
8000a592:	e0 a0 0b a7 	rcall	8000bce0 <__avr32_f64_mul>
8000a596:	fa eb 00 08 	st.d	sp[8],r10
8000a59a:	cc 3b       	rjmp	8000a520 <_dtoa_r+0x510>
8000a59c:	40 85       	lddsp	r5,sp[0x20]
8000a59e:	08 05       	add	r5,r4
8000a5a0:	f2 08 02 3a 	ld.d	r10,r9[r8<<0x3]
8000a5a4:	51 35       	stdsp	sp[0x4c],r5
8000a5a6:	fa e8 00 28 	ld.d	r8,sp[40]
8000a5aa:	40 85       	lddsp	r5,sp[0x20]
8000a5ac:	e0 a0 0b 9a 	rcall	8000bce0 <__avr32_f64_mul>
8000a5b0:	fa eb 00 28 	st.d	sp[40],r10
8000a5b4:	fa ea 00 08 	ld.d	r10,sp[8]
8000a5b8:	e0 a0 0d d8 	rcall	8000c168 <__avr32_f64_to_s32>
8000a5bc:	51 6c       	stdsp	sp[0x58],r12
8000a5be:	e0 a0 0d ec 	rcall	8000c196 <__avr32_s32_to_f64>
8000a5c2:	14 98       	mov	r8,r10
8000a5c4:	16 99       	mov	r9,r11
8000a5c6:	fa ea 00 08 	ld.d	r10,sp[8]
8000a5ca:	e0 a0 0c 77 	rcall	8000beb8 <__avr32_f64_sub>
8000a5ce:	fa eb 00 08 	st.d	sp[8],r10
8000a5d2:	41 68       	lddsp	r8,sp[0x58]
8000a5d4:	2d 08       	sub	r8,-48
8000a5d6:	0a c8       	st.b	r5++,r8
8000a5d8:	41 3c       	lddsp	r12,sp[0x4c]
8000a5da:	18 35       	cp.w	r5,r12
8000a5dc:	c2 81       	brne	8000a62c <_dtoa_r+0x61c>
8000a5de:	30 08       	mov	r8,0
8000a5e0:	fc 19 3f e0 	movh	r9,0x3fe0
8000a5e4:	fa ea 00 28 	ld.d	r10,sp[40]
8000a5e8:	e0 a0 0d 36 	rcall	8000c054 <__avr32_f64_add>
8000a5ec:	40 85       	lddsp	r5,sp[0x20]
8000a5ee:	fa e8 00 08 	ld.d	r8,sp[8]
8000a5f2:	08 05       	add	r5,r4
8000a5f4:	e0 a0 0e 88 	rcall	8000c304 <__avr32_f64_cmp_lt>
8000a5f8:	e0 81 00 99 	brne	8000a72a <_dtoa_r+0x71a>
8000a5fc:	fa e8 00 28 	ld.d	r8,sp[40]
8000a600:	30 0a       	mov	r10,0
8000a602:	fc 1b 3f e0 	movh	r11,0x3fe0
8000a606:	e0 a0 0c 59 	rcall	8000beb8 <__avr32_f64_sub>
8000a60a:	14 98       	mov	r8,r10
8000a60c:	16 99       	mov	r9,r11
8000a60e:	fa ea 00 08 	ld.d	r10,sp[8]
8000a612:	e0 a0 0e 79 	rcall	8000c304 <__avr32_f64_cmp_lt>
8000a616:	c1 30       	breq	8000a63c <_dtoa_r+0x62c>
8000a618:	33 09       	mov	r9,48
8000a61a:	0a 98       	mov	r8,r5
8000a61c:	11 7a       	ld.ub	r10,--r8
8000a61e:	f2 0a 18 00 	cp.b	r10,r9
8000a622:	e0 81 02 d1 	brne	8000abc4 <_dtoa_r+0xbb4>
8000a626:	10 95       	mov	r5,r8
8000a628:	cf 9b       	rjmp	8000a61a <_dtoa_r+0x60a>
8000a62a:	d7 03       	nop
8000a62c:	30 08       	mov	r8,0
8000a62e:	fc 19 40 24 	movh	r9,0x4024
8000a632:	e0 a0 0b 57 	rcall	8000bce0 <__avr32_f64_mul>
8000a636:	fa eb 00 08 	st.d	sp[8],r10
8000a63a:	cb db       	rjmp	8000a5b4 <_dtoa_r+0x5a4>
8000a63c:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a640:	fa eb 00 08 	st.d	sp[8],r10
8000a644:	58 e6       	cp.w	r6,14
8000a646:	5f ab       	srle	r11
8000a648:	41 8a       	lddsp	r10,sp[0x60]
8000a64a:	30 08       	mov	r8,0
8000a64c:	f4 09 11 ff 	rsub	r9,r10,-1
8000a650:	f7 e9 03 f9 	and	r9,r11,r9>>0x1f
8000a654:	f0 09 18 00 	cp.b	r9,r8
8000a658:	e0 80 00 82 	breq	8000a75c <_dtoa_r+0x74c>
8000a65c:	40 ea       	lddsp	r10,sp[0x38]
8000a65e:	58 01       	cp.w	r1,0
8000a660:	5f a9       	srle	r9
8000a662:	f3 ea 03 f9 	and	r9,r9,r10>>0x1f
8000a666:	fe ca c6 a2 	sub	r10,pc,-14686
8000a66a:	f4 06 02 34 	ld.d	r4,r10[r6<<0x3]
8000a66e:	fa e5 00 10 	st.d	sp[16],r4
8000a672:	f0 09 18 00 	cp.b	r9,r8
8000a676:	c1 40       	breq	8000a69e <_dtoa_r+0x68e>
8000a678:	58 01       	cp.w	r1,0
8000a67a:	e0 81 01 77 	brne	8000a968 <_dtoa_r+0x958>
8000a67e:	30 08       	mov	r8,0
8000a680:	fc 19 40 14 	movh	r9,0x4014
8000a684:	08 9a       	mov	r10,r4
8000a686:	0a 9b       	mov	r11,r5
8000a688:	e0 a0 0b 2c 	rcall	8000bce0 <__avr32_f64_mul>
8000a68c:	fa e8 00 08 	ld.d	r8,sp[8]
8000a690:	e0 a0 0e 06 	rcall	8000c29c <__avr32_f64_cmp_ge>
8000a694:	e0 81 01 6a 	brne	8000a968 <_dtoa_r+0x958>
8000a698:	02 92       	mov	r2,r1
8000a69a:	e0 8f 01 72 	bral	8000a97e <_dtoa_r+0x96e>
8000a69e:	40 85       	lddsp	r5,sp[0x20]
8000a6a0:	30 14       	mov	r4,1
8000a6a2:	fa e8 00 10 	ld.d	r8,sp[16]
8000a6a6:	fa ea 00 08 	ld.d	r10,sp[8]
8000a6aa:	e0 a0 0e 61 	rcall	8000c36c <__avr32_f64_div>
8000a6ae:	e0 a0 0d 5d 	rcall	8000c168 <__avr32_f64_to_s32>
8000a6b2:	18 92       	mov	r2,r12
8000a6b4:	e0 a0 0d 71 	rcall	8000c196 <__avr32_s32_to_f64>
8000a6b8:	fa e8 00 10 	ld.d	r8,sp[16]
8000a6bc:	e0 a0 0b 12 	rcall	8000bce0 <__avr32_f64_mul>
8000a6c0:	14 98       	mov	r8,r10
8000a6c2:	16 99       	mov	r9,r11
8000a6c4:	fa ea 00 08 	ld.d	r10,sp[8]
8000a6c8:	e0 a0 0b f8 	rcall	8000beb8 <__avr32_f64_sub>
8000a6cc:	fa eb 00 08 	st.d	sp[8],r10
8000a6d0:	e4 c8 ff d0 	sub	r8,r2,-48
8000a6d4:	0a c8       	st.b	r5++,r8
8000a6d6:	fc 19 40 24 	movh	r9,0x4024
8000a6da:	30 08       	mov	r8,0
8000a6dc:	02 34       	cp.w	r4,r1
8000a6de:	c3 31       	brne	8000a744 <_dtoa_r+0x734>
8000a6e0:	fa e8 00 08 	ld.d	r8,sp[8]
8000a6e4:	e0 a0 0c b8 	rcall	8000c054 <__avr32_f64_add>
8000a6e8:	16 91       	mov	r1,r11
8000a6ea:	14 90       	mov	r0,r10
8000a6ec:	14 98       	mov	r8,r10
8000a6ee:	02 99       	mov	r9,r1
8000a6f0:	fa ea 00 10 	ld.d	r10,sp[16]
8000a6f4:	e0 a0 0e 08 	rcall	8000c304 <__avr32_f64_cmp_lt>
8000a6f8:	c1 a1       	brne	8000a72c <_dtoa_r+0x71c>
8000a6fa:	fa e8 00 10 	ld.d	r8,sp[16]
8000a6fe:	00 9a       	mov	r10,r0
8000a700:	02 9b       	mov	r11,r1
8000a702:	e0 a0 0d ba 	rcall	8000c276 <__avr32_f64_cmp_eq>
8000a706:	e0 80 02 5e 	breq	8000abc2 <_dtoa_r+0xbb2>
8000a70a:	e5 d2 c0 01 	bfextu	r2,r2,0x0,0x1
8000a70e:	c0 f1       	brne	8000a72c <_dtoa_r+0x71c>
8000a710:	e0 8f 02 59 	bral	8000abc2 <_dtoa_r+0xbb2>
8000a714:	40 8a       	lddsp	r10,sp[0x20]
8000a716:	14 38       	cp.w	r8,r10
8000a718:	c0 30       	breq	8000a71e <_dtoa_r+0x70e>
8000a71a:	10 95       	mov	r5,r8
8000a71c:	c0 98       	rjmp	8000a72e <_dtoa_r+0x71e>
8000a71e:	33 08       	mov	r8,48
8000a720:	40 89       	lddsp	r9,sp[0x20]
8000a722:	2f f6       	sub	r6,-1
8000a724:	b2 88       	st.b	r9[0x0],r8
8000a726:	40 88       	lddsp	r8,sp[0x20]
8000a728:	c0 88       	rjmp	8000a738 <_dtoa_r+0x728>
8000a72a:	40 66       	lddsp	r6,sp[0x18]
8000a72c:	33 99       	mov	r9,57
8000a72e:	0a 98       	mov	r8,r5
8000a730:	11 7a       	ld.ub	r10,--r8
8000a732:	f2 0a 18 00 	cp.b	r10,r9
8000a736:	ce f0       	breq	8000a714 <_dtoa_r+0x704>
8000a738:	50 66       	stdsp	sp[0x18],r6
8000a73a:	11 89       	ld.ub	r9,r8[0x0]
8000a73c:	2f f9       	sub	r9,-1
8000a73e:	b0 89       	st.b	r8[0x0],r9
8000a740:	e0 8f 02 42 	bral	8000abc4 <_dtoa_r+0xbb4>
8000a744:	e0 a0 0a ce 	rcall	8000bce0 <__avr32_f64_mul>
8000a748:	2f f4       	sub	r4,-1
8000a74a:	fa eb 00 08 	st.d	sp[8],r10
8000a74e:	30 08       	mov	r8,0
8000a750:	30 09       	mov	r9,0
8000a752:	e0 a0 0d 92 	rcall	8000c276 <__avr32_f64_cmp_eq>
8000a756:	ca 60       	breq	8000a6a2 <_dtoa_r+0x692>
8000a758:	e0 8f 02 35 	bral	8000abc2 <_dtoa_r+0xbb2>
8000a75c:	40 d8       	lddsp	r8,sp[0x34]
8000a75e:	58 08       	cp.w	r8,0
8000a760:	c0 51       	brne	8000a76a <_dtoa_r+0x75a>
8000a762:	04 98       	mov	r8,r2
8000a764:	00 95       	mov	r5,r0
8000a766:	40 d4       	lddsp	r4,sp[0x34]
8000a768:	c3 78       	rjmp	8000a7d6 <_dtoa_r+0x7c6>
8000a76a:	40 c5       	lddsp	r5,sp[0x30]
8000a76c:	58 15       	cp.w	r5,1
8000a76e:	e0 89 00 0f 	brgt	8000a78c <_dtoa_r+0x77c>
8000a772:	41 74       	lddsp	r4,sp[0x5c]
8000a774:	58 04       	cp.w	r4,0
8000a776:	c0 40       	breq	8000a77e <_dtoa_r+0x76e>
8000a778:	f4 c9 fb cd 	sub	r9,r10,-1075
8000a77c:	c0 48       	rjmp	8000a784 <_dtoa_r+0x774>
8000a77e:	41 99       	lddsp	r9,sp[0x64]
8000a780:	f2 09 11 36 	rsub	r9,r9,54
8000a784:	04 98       	mov	r8,r2
8000a786:	00 95       	mov	r5,r0
8000a788:	c1 c8       	rjmp	8000a7c0 <_dtoa_r+0x7b0>
8000a78a:	d7 03       	nop
8000a78c:	e2 c8 00 01 	sub	r8,r1,1
8000a790:	58 01       	cp.w	r1,0
8000a792:	e0 05 17 40 	movge	r5,r0
8000a796:	e2 09 17 40 	movge	r9,r1
8000a79a:	e1 d1 e5 15 	sublt	r5,r0,r1
8000a79e:	f9 b9 05 00 	movlt	r9,0
8000a7a2:	10 32       	cp.w	r2,r8
8000a7a4:	e5 d8 e4 18 	subge	r8,r2,r8
8000a7a8:	f1 d2 e5 18 	sublt	r8,r8,r2
8000a7ac:	e5 d8 e5 02 	addlt	r2,r2,r8
8000a7b0:	fb fc 50 11 	ld.wlt	r12,sp[0x44]
8000a7b4:	f9 d8 e5 0c 	addlt	r12,r12,r8
8000a7b8:	fb fc 5a 11 	st.wlt	sp[0x44],r12
8000a7bc:	f9 b8 05 00 	movlt	r8,0
8000a7c0:	40 4b       	lddsp	r11,sp[0x10]
8000a7c2:	12 0b       	add	r11,r9
8000a7c4:	50 08       	stdsp	sp[0x0],r8
8000a7c6:	50 4b       	stdsp	sp[0x10],r11
8000a7c8:	12 00       	add	r0,r9
8000a7ca:	30 1b       	mov	r11,1
8000a7cc:	0e 9c       	mov	r12,r7
8000a7ce:	e0 a0 08 a7 	rcall	8000b91c <__i2b>
8000a7d2:	40 08       	lddsp	r8,sp[0x0]
8000a7d4:	18 94       	mov	r4,r12
8000a7d6:	40 4a       	lddsp	r10,sp[0x10]
8000a7d8:	58 05       	cp.w	r5,0
8000a7da:	5f 99       	srgt	r9
8000a7dc:	58 0a       	cp.w	r10,0
8000a7de:	5f 9a       	srgt	r10
8000a7e0:	f5 e9 00 09 	and	r9,r10,r9
8000a7e4:	c0 80       	breq	8000a7f4 <_dtoa_r+0x7e4>
8000a7e6:	40 4c       	lddsp	r12,sp[0x10]
8000a7e8:	f8 05 0d 49 	min	r9,r12,r5
8000a7ec:	12 1c       	sub	r12,r9
8000a7ee:	12 10       	sub	r0,r9
8000a7f0:	50 4c       	stdsp	sp[0x10],r12
8000a7f2:	12 15       	sub	r5,r9
8000a7f4:	58 02       	cp.w	r2,0
8000a7f6:	e0 8a 00 27 	brle	8000a844 <_dtoa_r+0x834>
8000a7fa:	40 db       	lddsp	r11,sp[0x34]
8000a7fc:	58 0b       	cp.w	r11,0
8000a7fe:	c1 d0       	breq	8000a838 <_dtoa_r+0x828>
8000a800:	58 08       	cp.w	r8,0
8000a802:	e0 8a 00 17 	brle	8000a830 <_dtoa_r+0x820>
8000a806:	10 9a       	mov	r10,r8
8000a808:	50 08       	stdsp	sp[0x0],r8
8000a80a:	08 9b       	mov	r11,r4
8000a80c:	0e 9c       	mov	r12,r7
8000a80e:	e0 a0 08 cd 	rcall	8000b9a8 <__pow5mult>
8000a812:	06 9a       	mov	r10,r3
8000a814:	18 9b       	mov	r11,r12
8000a816:	18 94       	mov	r4,r12
8000a818:	0e 9c       	mov	r12,r7
8000a81a:	e0 a0 08 01 	rcall	8000b81c <__multiply>
8000a81e:	18 99       	mov	r9,r12
8000a820:	06 9b       	mov	r11,r3
8000a822:	50 19       	stdsp	sp[0x4],r9
8000a824:	0e 9c       	mov	r12,r7
8000a826:	e0 a0 06 ad 	rcall	8000b580 <_Bfree>
8000a82a:	40 19       	lddsp	r9,sp[0x4]
8000a82c:	40 08       	lddsp	r8,sp[0x0]
8000a82e:	12 93       	mov	r3,r9
8000a830:	e4 08 01 0a 	sub	r10,r2,r8
8000a834:	c0 80       	breq	8000a844 <_dtoa_r+0x834>
8000a836:	c0 28       	rjmp	8000a83a <_dtoa_r+0x82a>
8000a838:	04 9a       	mov	r10,r2
8000a83a:	06 9b       	mov	r11,r3
8000a83c:	0e 9c       	mov	r12,r7
8000a83e:	e0 a0 08 b5 	rcall	8000b9a8 <__pow5mult>
8000a842:	18 93       	mov	r3,r12
8000a844:	30 1b       	mov	r11,1
8000a846:	0e 9c       	mov	r12,r7
8000a848:	e0 a0 08 6a 	rcall	8000b91c <__i2b>
8000a84c:	41 1a       	lddsp	r10,sp[0x44]
8000a84e:	18 92       	mov	r2,r12
8000a850:	58 0a       	cp.w	r10,0
8000a852:	e0 8a 00 07 	brle	8000a860 <_dtoa_r+0x850>
8000a856:	18 9b       	mov	r11,r12
8000a858:	0e 9c       	mov	r12,r7
8000a85a:	e0 a0 08 a7 	rcall	8000b9a8 <__pow5mult>
8000a85e:	18 92       	mov	r2,r12
8000a860:	40 c9       	lddsp	r9,sp[0x30]
8000a862:	58 19       	cp.w	r9,1
8000a864:	e0 89 00 14 	brgt	8000a88c <_dtoa_r+0x87c>
8000a868:	40 38       	lddsp	r8,sp[0xc]
8000a86a:	58 08       	cp.w	r8,0
8000a86c:	c1 01       	brne	8000a88c <_dtoa_r+0x87c>
8000a86e:	40 29       	lddsp	r9,sp[0x8]
8000a870:	f1 d9 c0 14 	bfextu	r8,r9,0x0,0x14
8000a874:	c0 c1       	brne	8000a88c <_dtoa_r+0x87c>
8000a876:	12 98       	mov	r8,r9
8000a878:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000a87c:	c0 80       	breq	8000a88c <_dtoa_r+0x87c>
8000a87e:	40 4c       	lddsp	r12,sp[0x10]
8000a880:	30 1b       	mov	r11,1
8000a882:	2f fc       	sub	r12,-1
8000a884:	2f f0       	sub	r0,-1
8000a886:	50 4c       	stdsp	sp[0x10],r12
8000a888:	50 6b       	stdsp	sp[0x18],r11
8000a88a:	c0 38       	rjmp	8000a890 <_dtoa_r+0x880>
8000a88c:	30 0a       	mov	r10,0
8000a88e:	50 6a       	stdsp	sp[0x18],r10
8000a890:	41 19       	lddsp	r9,sp[0x44]
8000a892:	58 09       	cp.w	r9,0
8000a894:	c0 31       	brne	8000a89a <_dtoa_r+0x88a>
8000a896:	30 1c       	mov	r12,1
8000a898:	c0 98       	rjmp	8000a8aa <_dtoa_r+0x89a>
8000a89a:	64 48       	ld.w	r8,r2[0x10]
8000a89c:	2f c8       	sub	r8,-4
8000a89e:	e4 08 03 2c 	ld.w	r12,r2[r8<<0x2]
8000a8a2:	e0 a0 05 df 	rcall	8000b460 <__hi0bits>
8000a8a6:	f8 0c 11 20 	rsub	r12,r12,32
8000a8aa:	40 4b       	lddsp	r11,sp[0x10]
8000a8ac:	f8 0b 00 08 	add	r8,r12,r11
8000a8b0:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000a8b4:	c0 c0       	breq	8000a8cc <_dtoa_r+0x8bc>
8000a8b6:	f0 08 11 20 	rsub	r8,r8,32
8000a8ba:	58 48       	cp.w	r8,4
8000a8bc:	e0 8a 00 06 	brle	8000a8c8 <_dtoa_r+0x8b8>
8000a8c0:	20 48       	sub	r8,4
8000a8c2:	10 0b       	add	r11,r8
8000a8c4:	50 4b       	stdsp	sp[0x10],r11
8000a8c6:	c0 78       	rjmp	8000a8d4 <_dtoa_r+0x8c4>
8000a8c8:	58 48       	cp.w	r8,4
8000a8ca:	c0 70       	breq	8000a8d8 <_dtoa_r+0x8c8>
8000a8cc:	40 4a       	lddsp	r10,sp[0x10]
8000a8ce:	2e 48       	sub	r8,-28
8000a8d0:	10 0a       	add	r10,r8
8000a8d2:	50 4a       	stdsp	sp[0x10],r10
8000a8d4:	10 00       	add	r0,r8
8000a8d6:	10 05       	add	r5,r8
8000a8d8:	58 00       	cp.w	r0,0
8000a8da:	e0 8a 00 08 	brle	8000a8ea <_dtoa_r+0x8da>
8000a8de:	06 9b       	mov	r11,r3
8000a8e0:	00 9a       	mov	r10,r0
8000a8e2:	0e 9c       	mov	r12,r7
8000a8e4:	e0 a0 07 58 	rcall	8000b794 <__lshift>
8000a8e8:	18 93       	mov	r3,r12
8000a8ea:	40 49       	lddsp	r9,sp[0x10]
8000a8ec:	58 09       	cp.w	r9,0
8000a8ee:	e0 8a 00 08 	brle	8000a8fe <_dtoa_r+0x8ee>
8000a8f2:	04 9b       	mov	r11,r2
8000a8f4:	12 9a       	mov	r10,r9
8000a8f6:	0e 9c       	mov	r12,r7
8000a8f8:	e0 a0 07 4e 	rcall	8000b794 <__lshift>
8000a8fc:	18 92       	mov	r2,r12
8000a8fe:	41 48       	lddsp	r8,sp[0x50]
8000a900:	58 08       	cp.w	r8,0
8000a902:	c1 b0       	breq	8000a938 <_dtoa_r+0x928>
8000a904:	04 9b       	mov	r11,r2
8000a906:	06 9c       	mov	r12,r3
8000a908:	e0 a0 06 23 	rcall	8000b54e <__mcmp>
8000a90c:	c1 64       	brge	8000a938 <_dtoa_r+0x928>
8000a90e:	06 9b       	mov	r11,r3
8000a910:	30 09       	mov	r9,0
8000a912:	30 aa       	mov	r10,10
8000a914:	0e 9c       	mov	r12,r7
8000a916:	e0 a0 08 0b 	rcall	8000b92c <__multadd>
8000a91a:	20 16       	sub	r6,1
8000a91c:	18 93       	mov	r3,r12
8000a91e:	40 dc       	lddsp	r12,sp[0x34]
8000a920:	58 0c       	cp.w	r12,0
8000a922:	c0 31       	brne	8000a928 <_dtoa_r+0x918>
8000a924:	40 91       	lddsp	r1,sp[0x24]
8000a926:	c0 98       	rjmp	8000a938 <_dtoa_r+0x928>
8000a928:	08 9b       	mov	r11,r4
8000a92a:	40 91       	lddsp	r1,sp[0x24]
8000a92c:	30 09       	mov	r9,0
8000a92e:	30 aa       	mov	r10,10
8000a930:	0e 9c       	mov	r12,r7
8000a932:	e0 a0 07 fd 	rcall	8000b92c <__multadd>
8000a936:	18 94       	mov	r4,r12
8000a938:	58 01       	cp.w	r1,0
8000a93a:	5f a9       	srle	r9
8000a93c:	40 cb       	lddsp	r11,sp[0x30]
8000a93e:	58 2b       	cp.w	r11,2
8000a940:	5f 98       	srgt	r8
8000a942:	f3 e8 00 08 	and	r8,r9,r8
8000a946:	c2 50       	breq	8000a990 <_dtoa_r+0x980>
8000a948:	58 01       	cp.w	r1,0
8000a94a:	c1 11       	brne	8000a96c <_dtoa_r+0x95c>
8000a94c:	04 9b       	mov	r11,r2
8000a94e:	02 99       	mov	r9,r1
8000a950:	30 5a       	mov	r10,5
8000a952:	0e 9c       	mov	r12,r7
8000a954:	e0 a0 07 ec 	rcall	8000b92c <__multadd>
8000a958:	18 92       	mov	r2,r12
8000a95a:	18 9b       	mov	r11,r12
8000a95c:	06 9c       	mov	r12,r3
8000a95e:	e0 a0 05 f8 	rcall	8000b54e <__mcmp>
8000a962:	e0 89 00 0f 	brgt	8000a980 <_dtoa_r+0x970>
8000a966:	c0 38       	rjmp	8000a96c <_dtoa_r+0x95c>
8000a968:	30 02       	mov	r2,0
8000a96a:	04 94       	mov	r4,r2
8000a96c:	40 ea       	lddsp	r10,sp[0x38]
8000a96e:	30 09       	mov	r9,0
8000a970:	5c da       	com	r10
8000a972:	40 85       	lddsp	r5,sp[0x20]
8000a974:	50 6a       	stdsp	sp[0x18],r10
8000a976:	50 49       	stdsp	sp[0x10],r9
8000a978:	c0 f9       	rjmp	8000ab96 <_dtoa_r+0xb86>
8000a97a:	08 92       	mov	r2,r4
8000a97c:	40 66       	lddsp	r6,sp[0x18]
8000a97e:	04 94       	mov	r4,r2
8000a980:	2f f6       	sub	r6,-1
8000a982:	50 66       	stdsp	sp[0x18],r6
8000a984:	33 18       	mov	r8,49
8000a986:	40 85       	lddsp	r5,sp[0x20]
8000a988:	0a c8       	st.b	r5++,r8
8000a98a:	30 08       	mov	r8,0
8000a98c:	50 48       	stdsp	sp[0x10],r8
8000a98e:	c0 49       	rjmp	8000ab96 <_dtoa_r+0xb86>
8000a990:	40 dc       	lddsp	r12,sp[0x34]
8000a992:	58 0c       	cp.w	r12,0
8000a994:	e0 80 00 b5 	breq	8000aafe <_dtoa_r+0xaee>
8000a998:	58 05       	cp.w	r5,0
8000a99a:	e0 8a 00 08 	brle	8000a9aa <_dtoa_r+0x99a>
8000a99e:	08 9b       	mov	r11,r4
8000a9a0:	0a 9a       	mov	r10,r5
8000a9a2:	0e 9c       	mov	r12,r7
8000a9a4:	e0 a0 06 f8 	rcall	8000b794 <__lshift>
8000a9a8:	18 94       	mov	r4,r12
8000a9aa:	40 6b       	lddsp	r11,sp[0x18]
8000a9ac:	58 0b       	cp.w	r11,0
8000a9ae:	c0 31       	brne	8000a9b4 <_dtoa_r+0x9a4>
8000a9b0:	08 9c       	mov	r12,r4
8000a9b2:	c1 38       	rjmp	8000a9d8 <_dtoa_r+0x9c8>
8000a9b4:	68 1b       	ld.w	r11,r4[0x4]
8000a9b6:	0e 9c       	mov	r12,r7
8000a9b8:	e0 a0 05 fe 	rcall	8000b5b4 <_Balloc>
8000a9bc:	68 4a       	ld.w	r10,r4[0x10]
8000a9be:	18 95       	mov	r5,r12
8000a9c0:	e8 cb ff f4 	sub	r11,r4,-12
8000a9c4:	2f ea       	sub	r10,-2
8000a9c6:	2f 4c       	sub	r12,-12
8000a9c8:	a3 6a       	lsl	r10,0x2
8000a9ca:	fe b0 e6 4f 	rcall	80007668 <memcpy>
8000a9ce:	0a 9b       	mov	r11,r5
8000a9d0:	30 1a       	mov	r10,1
8000a9d2:	0e 9c       	mov	r12,r7
8000a9d4:	e0 a0 06 e0 	rcall	8000b794 <__lshift>
8000a9d8:	50 44       	stdsp	sp[0x10],r4
8000a9da:	40 3a       	lddsp	r10,sp[0xc]
8000a9dc:	30 19       	mov	r9,1
8000a9de:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
8000a9e2:	18 94       	mov	r4,r12
8000a9e4:	50 da       	stdsp	sp[0x34],r10
8000a9e6:	40 85       	lddsp	r5,sp[0x20]
8000a9e8:	50 99       	stdsp	sp[0x24],r9
8000a9ea:	50 26       	stdsp	sp[0x8],r6
8000a9ec:	50 e1       	stdsp	sp[0x38],r1
8000a9ee:	04 9b       	mov	r11,r2
8000a9f0:	06 9c       	mov	r12,r3
8000a9f2:	fe b0 fa 7f 	rcall	80009ef0 <quorem>
8000a9f6:	40 4b       	lddsp	r11,sp[0x10]
8000a9f8:	f8 c0 ff d0 	sub	r0,r12,-48
8000a9fc:	06 9c       	mov	r12,r3
8000a9fe:	e0 a0 05 a8 	rcall	8000b54e <__mcmp>
8000aa02:	08 9a       	mov	r10,r4
8000aa04:	50 6c       	stdsp	sp[0x18],r12
8000aa06:	04 9b       	mov	r11,r2
8000aa08:	0e 9c       	mov	r12,r7
8000aa0a:	e0 a0 06 5d 	rcall	8000b6c4 <__mdiff>
8000aa0e:	18 91       	mov	r1,r12
8000aa10:	78 38       	ld.w	r8,r12[0xc]
8000aa12:	58 08       	cp.w	r8,0
8000aa14:	c0 30       	breq	8000aa1a <_dtoa_r+0xa0a>
8000aa16:	30 16       	mov	r6,1
8000aa18:	c0 68       	rjmp	8000aa24 <_dtoa_r+0xa14>
8000aa1a:	18 9b       	mov	r11,r12
8000aa1c:	06 9c       	mov	r12,r3
8000aa1e:	e0 a0 05 98 	rcall	8000b54e <__mcmp>
8000aa22:	18 96       	mov	r6,r12
8000aa24:	0e 9c       	mov	r12,r7
8000aa26:	02 9b       	mov	r11,r1
8000aa28:	e0 a0 05 ac 	rcall	8000b580 <_Bfree>
8000aa2c:	40 cc       	lddsp	r12,sp[0x30]
8000aa2e:	ed ec 10 08 	or	r8,r6,r12
8000aa32:	c0 d1       	brne	8000aa4c <_dtoa_r+0xa3c>
8000aa34:	40 db       	lddsp	r11,sp[0x34]
8000aa36:	58 0b       	cp.w	r11,0
8000aa38:	c0 a1       	brne	8000aa4c <_dtoa_r+0xa3c>
8000aa3a:	40 26       	lddsp	r6,sp[0x8]
8000aa3c:	e0 40 00 39 	cp.w	r0,57
8000aa40:	c3 00       	breq	8000aaa0 <_dtoa_r+0xa90>
8000aa42:	40 6a       	lddsp	r10,sp[0x18]
8000aa44:	58 0a       	cp.w	r10,0
8000aa46:	e0 89 00 24 	brgt	8000aa8e <_dtoa_r+0xa7e>
8000aa4a:	c2 f8       	rjmp	8000aaa8 <_dtoa_r+0xa98>
8000aa4c:	40 69       	lddsp	r9,sp[0x18]
8000aa4e:	58 09       	cp.w	r9,0
8000aa50:	c0 85       	brlt	8000aa60 <_dtoa_r+0xa50>
8000aa52:	12 98       	mov	r8,r9
8000aa54:	40 cc       	lddsp	r12,sp[0x30]
8000aa56:	18 48       	or	r8,r12
8000aa58:	c1 d1       	brne	8000aa92 <_dtoa_r+0xa82>
8000aa5a:	40 db       	lddsp	r11,sp[0x34]
8000aa5c:	58 0b       	cp.w	r11,0
8000aa5e:	c1 a1       	brne	8000aa92 <_dtoa_r+0xa82>
8000aa60:	0c 99       	mov	r9,r6
8000aa62:	40 26       	lddsp	r6,sp[0x8]
8000aa64:	58 09       	cp.w	r9,0
8000aa66:	e0 8a 00 21 	brle	8000aaa8 <_dtoa_r+0xa98>
8000aa6a:	06 9b       	mov	r11,r3
8000aa6c:	30 1a       	mov	r10,1
8000aa6e:	0e 9c       	mov	r12,r7
8000aa70:	e0 a0 06 92 	rcall	8000b794 <__lshift>
8000aa74:	04 9b       	mov	r11,r2
8000aa76:	18 93       	mov	r3,r12
8000aa78:	e0 a0 05 6b 	rcall	8000b54e <__mcmp>
8000aa7c:	e0 89 00 06 	brgt	8000aa88 <_dtoa_r+0xa78>
8000aa80:	c1 41       	brne	8000aaa8 <_dtoa_r+0xa98>
8000aa82:	ed b0 00 00 	bld	r0,0x0
8000aa86:	c1 11       	brne	8000aaa8 <_dtoa_r+0xa98>
8000aa88:	e0 40 00 39 	cp.w	r0,57
8000aa8c:	c0 a0       	breq	8000aaa0 <_dtoa_r+0xa90>
8000aa8e:	2f f0       	sub	r0,-1
8000aa90:	c0 c8       	rjmp	8000aaa8 <_dtoa_r+0xa98>
8000aa92:	58 06       	cp.w	r6,0
8000aa94:	e0 8a 00 0c 	brle	8000aaac <_dtoa_r+0xa9c>
8000aa98:	40 26       	lddsp	r6,sp[0x8]
8000aa9a:	e0 40 00 39 	cp.w	r0,57
8000aa9e:	c0 41       	brne	8000aaa6 <_dtoa_r+0xa96>
8000aaa0:	33 98       	mov	r8,57
8000aaa2:	0a c8       	st.b	r5++,r8
8000aaa4:	c6 78       	rjmp	8000ab72 <_dtoa_r+0xb62>
8000aaa6:	2f f0       	sub	r0,-1
8000aaa8:	0a c0       	st.b	r5++,r0
8000aaaa:	c7 58       	rjmp	8000ab94 <_dtoa_r+0xb84>
8000aaac:	0a c0       	st.b	r5++,r0
8000aaae:	40 9a       	lddsp	r10,sp[0x24]
8000aab0:	40 e9       	lddsp	r9,sp[0x38]
8000aab2:	12 3a       	cp.w	r10,r9
8000aab4:	c4 30       	breq	8000ab3a <_dtoa_r+0xb2a>
8000aab6:	06 9b       	mov	r11,r3
8000aab8:	30 09       	mov	r9,0
8000aaba:	30 aa       	mov	r10,10
8000aabc:	0e 9c       	mov	r12,r7
8000aabe:	e0 a0 07 37 	rcall	8000b92c <__multadd>
8000aac2:	40 48       	lddsp	r8,sp[0x10]
8000aac4:	18 93       	mov	r3,r12
8000aac6:	08 38       	cp.w	r8,r4
8000aac8:	c0 91       	brne	8000aada <_dtoa_r+0xaca>
8000aaca:	10 9b       	mov	r11,r8
8000aacc:	30 09       	mov	r9,0
8000aace:	30 aa       	mov	r10,10
8000aad0:	0e 9c       	mov	r12,r7
8000aad2:	e0 a0 07 2d 	rcall	8000b92c <__multadd>
8000aad6:	50 4c       	stdsp	sp[0x10],r12
8000aad8:	c0 e8       	rjmp	8000aaf4 <_dtoa_r+0xae4>
8000aada:	40 4b       	lddsp	r11,sp[0x10]
8000aadc:	30 09       	mov	r9,0
8000aade:	30 aa       	mov	r10,10
8000aae0:	0e 9c       	mov	r12,r7
8000aae2:	e0 a0 07 25 	rcall	8000b92c <__multadd>
8000aae6:	08 9b       	mov	r11,r4
8000aae8:	50 4c       	stdsp	sp[0x10],r12
8000aaea:	30 09       	mov	r9,0
8000aaec:	30 aa       	mov	r10,10
8000aaee:	0e 9c       	mov	r12,r7
8000aaf0:	e0 a0 07 1e 	rcall	8000b92c <__multadd>
8000aaf4:	18 94       	mov	r4,r12
8000aaf6:	40 9c       	lddsp	r12,sp[0x24]
8000aaf8:	2f fc       	sub	r12,-1
8000aafa:	50 9c       	stdsp	sp[0x24],r12
8000aafc:	c7 9b       	rjmp	8000a9ee <_dtoa_r+0x9de>
8000aafe:	30 18       	mov	r8,1
8000ab00:	06 90       	mov	r0,r3
8000ab02:	40 85       	lddsp	r5,sp[0x20]
8000ab04:	08 93       	mov	r3,r4
8000ab06:	0c 94       	mov	r4,r6
8000ab08:	10 96       	mov	r6,r8
8000ab0a:	04 9b       	mov	r11,r2
8000ab0c:	00 9c       	mov	r12,r0
8000ab0e:	fe b0 f9 f1 	rcall	80009ef0 <quorem>
8000ab12:	2d 0c       	sub	r12,-48
8000ab14:	0a cc       	st.b	r5++,r12
8000ab16:	02 36       	cp.w	r6,r1
8000ab18:	c0 a4       	brge	8000ab2c <_dtoa_r+0xb1c>
8000ab1a:	00 9b       	mov	r11,r0
8000ab1c:	30 09       	mov	r9,0
8000ab1e:	30 aa       	mov	r10,10
8000ab20:	0e 9c       	mov	r12,r7
8000ab22:	2f f6       	sub	r6,-1
8000ab24:	e0 a0 07 04 	rcall	8000b92c <__multadd>
8000ab28:	18 90       	mov	r0,r12
8000ab2a:	cf 0b       	rjmp	8000ab0a <_dtoa_r+0xafa>
8000ab2c:	08 96       	mov	r6,r4
8000ab2e:	30 0b       	mov	r11,0
8000ab30:	06 94       	mov	r4,r3
8000ab32:	50 4b       	stdsp	sp[0x10],r11
8000ab34:	00 93       	mov	r3,r0
8000ab36:	18 90       	mov	r0,r12
8000ab38:	c0 28       	rjmp	8000ab3c <_dtoa_r+0xb2c>
8000ab3a:	40 26       	lddsp	r6,sp[0x8]
8000ab3c:	06 9b       	mov	r11,r3
8000ab3e:	30 1a       	mov	r10,1
8000ab40:	0e 9c       	mov	r12,r7
8000ab42:	e0 a0 06 29 	rcall	8000b794 <__lshift>
8000ab46:	04 9b       	mov	r11,r2
8000ab48:	18 93       	mov	r3,r12
8000ab4a:	e0 a0 05 02 	rcall	8000b54e <__mcmp>
8000ab4e:	e0 89 00 12 	brgt	8000ab72 <_dtoa_r+0xb62>
8000ab52:	c1 b1       	brne	8000ab88 <_dtoa_r+0xb78>
8000ab54:	e1 d0 c0 01 	bfextu	r0,r0,0x0,0x1
8000ab58:	c0 d1       	brne	8000ab72 <_dtoa_r+0xb62>
8000ab5a:	c1 78       	rjmp	8000ab88 <_dtoa_r+0xb78>
8000ab5c:	40 89       	lddsp	r9,sp[0x20]
8000ab5e:	12 38       	cp.w	r8,r9
8000ab60:	c0 30       	breq	8000ab66 <_dtoa_r+0xb56>
8000ab62:	10 95       	mov	r5,r8
8000ab64:	c0 88       	rjmp	8000ab74 <_dtoa_r+0xb64>
8000ab66:	2f f6       	sub	r6,-1
8000ab68:	50 66       	stdsp	sp[0x18],r6
8000ab6a:	33 18       	mov	r8,49
8000ab6c:	40 8c       	lddsp	r12,sp[0x20]
8000ab6e:	b8 88       	st.b	r12[0x0],r8
8000ab70:	c1 38       	rjmp	8000ab96 <_dtoa_r+0xb86>
8000ab72:	33 9a       	mov	r10,57
8000ab74:	0a 98       	mov	r8,r5
8000ab76:	11 79       	ld.ub	r9,--r8
8000ab78:	f4 09 18 00 	cp.b	r9,r10
8000ab7c:	cf 00       	breq	8000ab5c <_dtoa_r+0xb4c>
8000ab7e:	2f f9       	sub	r9,-1
8000ab80:	b0 89       	st.b	r8[0x0],r9
8000ab82:	c0 98       	rjmp	8000ab94 <_dtoa_r+0xb84>
8000ab84:	10 95       	mov	r5,r8
8000ab86:	c0 28       	rjmp	8000ab8a <_dtoa_r+0xb7a>
8000ab88:	33 09       	mov	r9,48
8000ab8a:	0a 98       	mov	r8,r5
8000ab8c:	11 7a       	ld.ub	r10,--r8
8000ab8e:	f2 0a 18 00 	cp.b	r10,r9
8000ab92:	cf 90       	breq	8000ab84 <_dtoa_r+0xb74>
8000ab94:	50 66       	stdsp	sp[0x18],r6
8000ab96:	04 9b       	mov	r11,r2
8000ab98:	0e 9c       	mov	r12,r7
8000ab9a:	e0 a0 04 f3 	rcall	8000b580 <_Bfree>
8000ab9e:	58 04       	cp.w	r4,0
8000aba0:	c1 20       	breq	8000abc4 <_dtoa_r+0xbb4>
8000aba2:	40 4b       	lddsp	r11,sp[0x10]
8000aba4:	08 3b       	cp.w	r11,r4
8000aba6:	5f 19       	srne	r9
8000aba8:	58 0b       	cp.w	r11,0
8000abaa:	5f 18       	srne	r8
8000abac:	f3 e8 00 08 	and	r8,r9,r8
8000abb0:	c0 40       	breq	8000abb8 <_dtoa_r+0xba8>
8000abb2:	0e 9c       	mov	r12,r7
8000abb4:	e0 a0 04 e6 	rcall	8000b580 <_Bfree>
8000abb8:	08 9b       	mov	r11,r4
8000abba:	0e 9c       	mov	r12,r7
8000abbc:	e0 a0 04 e2 	rcall	8000b580 <_Bfree>
8000abc0:	c0 28       	rjmp	8000abc4 <_dtoa_r+0xbb4>
8000abc2:	50 66       	stdsp	sp[0x18],r6
8000abc4:	0e 9c       	mov	r12,r7
8000abc6:	06 9b       	mov	r11,r3
8000abc8:	e0 a0 04 dc 	rcall	8000b580 <_Bfree>
8000abcc:	30 08       	mov	r8,0
8000abce:	aa 88       	st.b	r5[0x0],r8
8000abd0:	40 68       	lddsp	r8,sp[0x18]
8000abd2:	41 5a       	lddsp	r10,sp[0x54]
8000abd4:	2f f8       	sub	r8,-1
8000abd6:	41 29       	lddsp	r9,sp[0x48]
8000abd8:	95 08       	st.w	r10[0x0],r8
8000abda:	40 8c       	lddsp	r12,sp[0x20]
8000abdc:	58 09       	cp.w	r9,0
8000abde:	fb f8 10 12 	ld.wne	r8,sp[0x48]
8000abe2:	f1 f5 1a 00 	st.wne	r8[0x0],r5
8000abe6:	2e 6d       	sub	sp,-104
8000abe8:	d8 32       	popm	r0-r7,pc
8000abea:	d7 03       	nop

8000abec <__errno>:
8000abec:	e0 68 0a 3c 	mov	r8,2620
8000abf0:	70 0c       	ld.w	r12,r8[0x0]
8000abf2:	2f 4c       	sub	r12,-12
8000abf4:	5e fc       	retal	r12
8000abf6:	d7 03       	nop

8000abf8 <_fflush_r>:
8000abf8:	d4 21       	pushm	r4-r7,lr
8000abfa:	16 97       	mov	r7,r11
8000abfc:	18 96       	mov	r6,r12
8000abfe:	76 48       	ld.w	r8,r11[0x10]
8000ac00:	58 08       	cp.w	r8,0
8000ac02:	c7 f0       	breq	8000ad00 <_fflush_r+0x108>
8000ac04:	58 0c       	cp.w	r12,0
8000ac06:	c0 50       	breq	8000ac10 <_fflush_r+0x18>
8000ac08:	78 68       	ld.w	r8,r12[0x18]
8000ac0a:	58 08       	cp.w	r8,0
8000ac0c:	c0 21       	brne	8000ac10 <_fflush_r+0x18>
8000ac0e:	cc dc       	rcall	8000ada8 <__sinit>
8000ac10:	fe c8 cc fc 	sub	r8,pc,-13060
8000ac14:	10 37       	cp.w	r7,r8
8000ac16:	c0 31       	brne	8000ac1c <_fflush_r+0x24>
8000ac18:	6c 07       	ld.w	r7,r6[0x0]
8000ac1a:	c0 c8       	rjmp	8000ac32 <_fflush_r+0x3a>
8000ac1c:	fe c8 cc e8 	sub	r8,pc,-13080
8000ac20:	10 37       	cp.w	r7,r8
8000ac22:	c0 31       	brne	8000ac28 <_fflush_r+0x30>
8000ac24:	6c 17       	ld.w	r7,r6[0x4]
8000ac26:	c0 68       	rjmp	8000ac32 <_fflush_r+0x3a>
8000ac28:	fe c8 cc d4 	sub	r8,pc,-13100
8000ac2c:	10 37       	cp.w	r7,r8
8000ac2e:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000ac32:	8e 6a       	ld.sh	r10,r7[0xc]
8000ac34:	14 98       	mov	r8,r10
8000ac36:	ed ba 00 03 	bld	r10,0x3
8000ac3a:	c4 20       	breq	8000acbe <_fflush_r+0xc6>
8000ac3c:	ab ba       	sbr	r10,0xb
8000ac3e:	ae 6a       	st.h	r7[0xc],r10
8000ac40:	6e 18       	ld.w	r8,r7[0x4]
8000ac42:	58 08       	cp.w	r8,0
8000ac44:	e0 89 00 06 	brgt	8000ac50 <_fflush_r+0x58>
8000ac48:	6f 08       	ld.w	r8,r7[0x40]
8000ac4a:	58 08       	cp.w	r8,0
8000ac4c:	e0 8a 00 5a 	brle	8000ad00 <_fflush_r+0x108>
8000ac50:	6e b8       	ld.w	r8,r7[0x2c]
8000ac52:	58 08       	cp.w	r8,0
8000ac54:	c5 60       	breq	8000ad00 <_fflush_r+0x108>
8000ac56:	e2 1a 10 00 	andl	r10,0x1000,COH
8000ac5a:	c0 30       	breq	8000ac60 <_fflush_r+0x68>
8000ac5c:	6f 55       	ld.w	r5,r7[0x54]
8000ac5e:	c0 f8       	rjmp	8000ac7c <_fflush_r+0x84>
8000ac60:	30 19       	mov	r9,1
8000ac62:	6e 8b       	ld.w	r11,r7[0x20]
8000ac64:	0c 9c       	mov	r12,r6
8000ac66:	5d 18       	icall	r8
8000ac68:	18 95       	mov	r5,r12
8000ac6a:	5b fc       	cp.w	r12,-1
8000ac6c:	c0 81       	brne	8000ac7c <_fflush_r+0x84>
8000ac6e:	6c 38       	ld.w	r8,r6[0xc]
8000ac70:	59 d8       	cp.w	r8,29
8000ac72:	c4 70       	breq	8000ad00 <_fflush_r+0x108>
8000ac74:	8e 68       	ld.sh	r8,r7[0xc]
8000ac76:	a7 a8       	sbr	r8,0x6
8000ac78:	ae 68       	st.h	r7[0xc],r8
8000ac7a:	d8 22       	popm	r4-r7,pc
8000ac7c:	8e 68       	ld.sh	r8,r7[0xc]
8000ac7e:	ed b8 00 02 	bld	r8,0x2
8000ac82:	c0 91       	brne	8000ac94 <_fflush_r+0x9c>
8000ac84:	6e 18       	ld.w	r8,r7[0x4]
8000ac86:	10 15       	sub	r5,r8
8000ac88:	6e d8       	ld.w	r8,r7[0x34]
8000ac8a:	58 08       	cp.w	r8,0
8000ac8c:	ef f8 10 10 	ld.wne	r8,r7[0x40]
8000ac90:	eb d8 e1 15 	subne	r5,r5,r8
8000ac94:	6e b8       	ld.w	r8,r7[0x2c]
8000ac96:	0c 9c       	mov	r12,r6
8000ac98:	30 09       	mov	r9,0
8000ac9a:	0a 9a       	mov	r10,r5
8000ac9c:	6e 8b       	ld.w	r11,r7[0x20]
8000ac9e:	5d 18       	icall	r8
8000aca0:	8e 68       	ld.sh	r8,r7[0xc]
8000aca2:	0a 3c       	cp.w	r12,r5
8000aca4:	c2 61       	brne	8000acf0 <_fflush_r+0xf8>
8000aca6:	ab d8       	cbr	r8,0xb
8000aca8:	30 0c       	mov	r12,0
8000acaa:	6e 49       	ld.w	r9,r7[0x10]
8000acac:	ae 68       	st.h	r7[0xc],r8
8000acae:	8f 1c       	st.w	r7[0x4],r12
8000acb0:	8f 09       	st.w	r7[0x0],r9
8000acb2:	ed b8 00 0c 	bld	r8,0xc
8000acb6:	c2 51       	brne	8000ad00 <_fflush_r+0x108>
8000acb8:	ef 45 00 54 	st.w	r7[84],r5
8000acbc:	d8 22       	popm	r4-r7,pc
8000acbe:	6e 45       	ld.w	r5,r7[0x10]
8000acc0:	58 05       	cp.w	r5,0
8000acc2:	c1 f0       	breq	8000ad00 <_fflush_r+0x108>
8000acc4:	6e 04       	ld.w	r4,r7[0x0]
8000acc6:	f5 da c0 02 	bfextu	r10,r10,0x0,0x2
8000acca:	8f 05       	st.w	r7[0x0],r5
8000accc:	f9 b8 01 00 	movne	r8,0
8000acd0:	ef f8 00 05 	ld.weq	r8,r7[0x14]
8000acd4:	0a 14       	sub	r4,r5
8000acd6:	8f 28       	st.w	r7[0x8],r8
8000acd8:	c1 18       	rjmp	8000acfa <_fflush_r+0x102>
8000acda:	08 99       	mov	r9,r4
8000acdc:	0a 9a       	mov	r10,r5
8000acde:	6e a8       	ld.w	r8,r7[0x28]
8000ace0:	6e 8b       	ld.w	r11,r7[0x20]
8000ace2:	0c 9c       	mov	r12,r6
8000ace4:	5d 18       	icall	r8
8000ace6:	18 14       	sub	r4,r12
8000ace8:	58 0c       	cp.w	r12,0
8000acea:	e0 89 00 07 	brgt	8000acf8 <_fflush_r+0x100>
8000acee:	8e 68       	ld.sh	r8,r7[0xc]
8000acf0:	a7 a8       	sbr	r8,0x6
8000acf2:	3f fc       	mov	r12,-1
8000acf4:	ae 68       	st.h	r7[0xc],r8
8000acf6:	d8 22       	popm	r4-r7,pc
8000acf8:	18 05       	add	r5,r12
8000acfa:	58 04       	cp.w	r4,0
8000acfc:	fe 99 ff ef 	brgt	8000acda <_fflush_r+0xe2>
8000ad00:	d8 2a       	popm	r4-r7,pc,r12=0
8000ad02:	d7 03       	nop

8000ad04 <__sfp_lock_acquire>:
8000ad04:	5e fc       	retal	r12

8000ad06 <__sfp_lock_release>:
8000ad06:	5e fc       	retal	r12

8000ad08 <_cleanup_r>:
8000ad08:	d4 01       	pushm	lr
8000ad0a:	fe cb f0 ae 	sub	r11,pc,-3922
8000ad0e:	e0 a0 02 f7 	rcall	8000b2fc <_fwalk>
8000ad12:	d8 02       	popm	pc

8000ad14 <__sfmoreglue>:
8000ad14:	d4 21       	pushm	r4-r7,lr
8000ad16:	16 95       	mov	r5,r11
8000ad18:	f6 06 10 5c 	mul	r6,r11,92
8000ad1c:	ec cb ff f4 	sub	r11,r6,-12
8000ad20:	fe b0 e2 88 	rcall	80007230 <_malloc_r>
8000ad24:	18 97       	mov	r7,r12
8000ad26:	c0 90       	breq	8000ad38 <__sfmoreglue+0x24>
8000ad28:	99 15       	st.w	r12[0x4],r5
8000ad2a:	30 0b       	mov	r11,0
8000ad2c:	2f 4c       	sub	r12,-12
8000ad2e:	0c 9a       	mov	r10,r6
8000ad30:	8f 2c       	st.w	r7[0x8],r12
8000ad32:	8f 0b       	st.w	r7[0x0],r11
8000ad34:	fe b0 e5 3e 	rcall	800077b0 <memset>
8000ad38:	0e 9c       	mov	r12,r7
8000ad3a:	d8 22       	popm	r4-r7,pc

8000ad3c <__sfp>:
8000ad3c:	d4 21       	pushm	r4-r7,lr
8000ad3e:	fe c8 cd c6 	sub	r8,pc,-12858
8000ad42:	18 96       	mov	r6,r12
8000ad44:	70 07       	ld.w	r7,r8[0x0]
8000ad46:	6e 68       	ld.w	r8,r7[0x18]
8000ad48:	58 08       	cp.w	r8,0
8000ad4a:	c0 31       	brne	8000ad50 <__sfp+0x14>
8000ad4c:	0e 9c       	mov	r12,r7
8000ad4e:	c2 dc       	rcall	8000ada8 <__sinit>
8000ad50:	ee c7 ff 28 	sub	r7,r7,-216
8000ad54:	30 05       	mov	r5,0
8000ad56:	6e 2c       	ld.w	r12,r7[0x8]
8000ad58:	6e 18       	ld.w	r8,r7[0x4]
8000ad5a:	c0 68       	rjmp	8000ad66 <__sfp+0x2a>
8000ad5c:	98 69       	ld.sh	r9,r12[0xc]
8000ad5e:	ea 09 19 00 	cp.h	r9,r5
8000ad62:	c1 10       	breq	8000ad84 <__sfp+0x48>
8000ad64:	2a 4c       	sub	r12,-92
8000ad66:	20 18       	sub	r8,1
8000ad68:	cf a7       	brpl	8000ad5c <__sfp+0x20>
8000ad6a:	6e 08       	ld.w	r8,r7[0x0]
8000ad6c:	58 08       	cp.w	r8,0
8000ad6e:	c0 61       	brne	8000ad7a <__sfp+0x3e>
8000ad70:	30 4b       	mov	r11,4
8000ad72:	0c 9c       	mov	r12,r6
8000ad74:	cd 0f       	rcall	8000ad14 <__sfmoreglue>
8000ad76:	8f 0c       	st.w	r7[0x0],r12
8000ad78:	c0 30       	breq	8000ad7e <__sfp+0x42>
8000ad7a:	6e 07       	ld.w	r7,r7[0x0]
8000ad7c:	ce db       	rjmp	8000ad56 <__sfp+0x1a>
8000ad7e:	30 c8       	mov	r8,12
8000ad80:	8d 38       	st.w	r6[0xc],r8
8000ad82:	d8 22       	popm	r4-r7,pc
8000ad84:	30 08       	mov	r8,0
8000ad86:	f9 48 00 4c 	st.w	r12[76],r8
8000ad8a:	99 08       	st.w	r12[0x0],r8
8000ad8c:	99 28       	st.w	r12[0x8],r8
8000ad8e:	99 18       	st.w	r12[0x4],r8
8000ad90:	99 48       	st.w	r12[0x10],r8
8000ad92:	99 58       	st.w	r12[0x14],r8
8000ad94:	99 68       	st.w	r12[0x18],r8
8000ad96:	99 d8       	st.w	r12[0x34],r8
8000ad98:	99 e8       	st.w	r12[0x38],r8
8000ad9a:	f9 48 00 48 	st.w	r12[72],r8
8000ad9e:	3f f8       	mov	r8,-1
8000ada0:	b8 78       	st.h	r12[0xe],r8
8000ada2:	30 18       	mov	r8,1
8000ada4:	b8 68       	st.h	r12[0xc],r8
8000ada6:	d8 22       	popm	r4-r7,pc

8000ada8 <__sinit>:
8000ada8:	d4 21       	pushm	r4-r7,lr
8000adaa:	18 96       	mov	r6,r12
8000adac:	78 67       	ld.w	r7,r12[0x18]
8000adae:	58 07       	cp.w	r7,0
8000adb0:	c4 91       	brne	8000ae42 <__sinit+0x9a>
8000adb2:	fe c8 00 aa 	sub	r8,pc,170
8000adb6:	30 15       	mov	r5,1
8000adb8:	99 a8       	st.w	r12[0x28],r8
8000adba:	f9 47 00 d8 	st.w	r12[216],r7
8000adbe:	f9 47 00 dc 	st.w	r12[220],r7
8000adc2:	f9 47 00 e0 	st.w	r12[224],r7
8000adc6:	99 65       	st.w	r12[0x18],r5
8000adc8:	cb af       	rcall	8000ad3c <__sfp>
8000adca:	8d 0c       	st.w	r6[0x0],r12
8000adcc:	0c 9c       	mov	r12,r6
8000adce:	cb 7f       	rcall	8000ad3c <__sfp>
8000add0:	8d 1c       	st.w	r6[0x4],r12
8000add2:	0c 9c       	mov	r12,r6
8000add4:	cb 4f       	rcall	8000ad3c <__sfp>
8000add6:	6c 09       	ld.w	r9,r6[0x0]
8000add8:	30 48       	mov	r8,4
8000adda:	93 07       	st.w	r9[0x0],r7
8000addc:	b2 68       	st.h	r9[0xc],r8
8000adde:	93 17       	st.w	r9[0x4],r7
8000ade0:	93 27       	st.w	r9[0x8],r7
8000ade2:	6c 18       	ld.w	r8,r6[0x4]
8000ade4:	b2 77       	st.h	r9[0xe],r7
8000ade6:	93 47       	st.w	r9[0x10],r7
8000ade8:	93 57       	st.w	r9[0x14],r7
8000adea:	93 67       	st.w	r9[0x18],r7
8000adec:	93 89       	st.w	r9[0x20],r9
8000adee:	91 07       	st.w	r8[0x0],r7
8000adf0:	91 17       	st.w	r8[0x4],r7
8000adf2:	91 27       	st.w	r8[0x8],r7
8000adf4:	fe ce f3 24 	sub	lr,pc,-3292
8000adf8:	fe cb f3 54 	sub	r11,pc,-3244
8000adfc:	93 9e       	st.w	r9[0x24],lr
8000adfe:	93 ab       	st.w	r9[0x28],r11
8000ae00:	fe ca f3 7c 	sub	r10,pc,-3204
8000ae04:	fe c4 f3 88 	sub	r4,pc,-3192
8000ae08:	93 ba       	st.w	r9[0x2c],r10
8000ae0a:	93 c4       	st.w	r9[0x30],r4
8000ae0c:	30 99       	mov	r9,9
8000ae0e:	b0 69       	st.h	r8[0xc],r9
8000ae10:	b0 75       	st.h	r8[0xe],r5
8000ae12:	91 c4       	st.w	r8[0x30],r4
8000ae14:	91 47       	st.w	r8[0x10],r7
8000ae16:	91 57       	st.w	r8[0x14],r7
8000ae18:	91 67       	st.w	r8[0x18],r7
8000ae1a:	91 88       	st.w	r8[0x20],r8
8000ae1c:	91 9e       	st.w	r8[0x24],lr
8000ae1e:	91 ab       	st.w	r8[0x28],r11
8000ae20:	91 ba       	st.w	r8[0x2c],r10
8000ae22:	8d 2c       	st.w	r6[0x8],r12
8000ae24:	31 28       	mov	r8,18
8000ae26:	99 07       	st.w	r12[0x0],r7
8000ae28:	b8 68       	st.h	r12[0xc],r8
8000ae2a:	99 17       	st.w	r12[0x4],r7
8000ae2c:	99 27       	st.w	r12[0x8],r7
8000ae2e:	30 28       	mov	r8,2
8000ae30:	b8 78       	st.h	r12[0xe],r8
8000ae32:	99 c4       	st.w	r12[0x30],r4
8000ae34:	99 67       	st.w	r12[0x18],r7
8000ae36:	99 9e       	st.w	r12[0x24],lr
8000ae38:	99 ab       	st.w	r12[0x28],r11
8000ae3a:	99 ba       	st.w	r12[0x2c],r10
8000ae3c:	99 47       	st.w	r12[0x10],r7
8000ae3e:	99 57       	st.w	r12[0x14],r7
8000ae40:	99 8c       	st.w	r12[0x20],r12
8000ae42:	d8 22       	popm	r4-r7,pc

8000ae44 <_malloc_trim_r>:
8000ae44:	d4 21       	pushm	r4-r7,lr
8000ae46:	16 95       	mov	r5,r11
8000ae48:	18 97       	mov	r7,r12
8000ae4a:	fe b0 d7 ad 	rcall	80005da4 <__malloc_lock>
8000ae4e:	e0 64 05 3c 	mov	r4,1340
8000ae52:	68 28       	ld.w	r8,r4[0x8]
8000ae54:	70 16       	ld.w	r6,r8[0x4]
8000ae56:	e0 16 ff fc 	andl	r6,0xfffc
8000ae5a:	ec c8 ff 91 	sub	r8,r6,-111
8000ae5e:	f0 05 01 05 	sub	r5,r8,r5
8000ae62:	e0 15 ff 80 	andl	r5,0xff80
8000ae66:	ea c5 00 80 	sub	r5,r5,128
8000ae6a:	e0 45 00 7f 	cp.w	r5,127
8000ae6e:	e0 8a 00 25 	brle	8000aeb8 <_malloc_trim_r+0x74>
8000ae72:	30 0b       	mov	r11,0
8000ae74:	0e 9c       	mov	r12,r7
8000ae76:	fe b0 e6 05 	rcall	80007a80 <_sbrk_r>
8000ae7a:	68 28       	ld.w	r8,r4[0x8]
8000ae7c:	0c 08       	add	r8,r6
8000ae7e:	10 3c       	cp.w	r12,r8
8000ae80:	c1 c1       	brne	8000aeb8 <_malloc_trim_r+0x74>
8000ae82:	ea 0b 11 00 	rsub	r11,r5,0
8000ae86:	0e 9c       	mov	r12,r7
8000ae88:	fe b0 e5 fc 	rcall	80007a80 <_sbrk_r>
8000ae8c:	5b fc       	cp.w	r12,-1
8000ae8e:	c1 91       	brne	8000aec0 <_malloc_trim_r+0x7c>
8000ae90:	30 0b       	mov	r11,0
8000ae92:	0e 9c       	mov	r12,r7
8000ae94:	fe b0 e5 f6 	rcall	80007a80 <_sbrk_r>
8000ae98:	68 28       	ld.w	r8,r4[0x8]
8000ae9a:	f8 08 01 09 	sub	r9,r12,r8
8000ae9e:	58 f9       	cp.w	r9,15
8000aea0:	e0 8a 00 0c 	brle	8000aeb8 <_malloc_trim_r+0x74>
8000aea4:	a1 a9       	sbr	r9,0x0
8000aea6:	91 19       	st.w	r8[0x4],r9
8000aea8:	e0 68 09 48 	mov	r8,2376
8000aeac:	70 09       	ld.w	r9,r8[0x0]
8000aeae:	e0 68 0d 68 	mov	r8,3432
8000aeb2:	f8 09 01 09 	sub	r9,r12,r9
8000aeb6:	91 09       	st.w	r8[0x0],r9
8000aeb8:	0e 9c       	mov	r12,r7
8000aeba:	fe b0 d7 7b 	rcall	80005db0 <__malloc_unlock>
8000aebe:	d8 2a       	popm	r4-r7,pc,r12=0
8000aec0:	68 28       	ld.w	r8,r4[0x8]
8000aec2:	0a 16       	sub	r6,r5
8000aec4:	a1 a6       	sbr	r6,0x0
8000aec6:	91 16       	st.w	r8[0x4],r6
8000aec8:	e0 68 0d 68 	mov	r8,3432
8000aecc:	70 09       	ld.w	r9,r8[0x0]
8000aece:	0a 19       	sub	r9,r5
8000aed0:	0e 9c       	mov	r12,r7
8000aed2:	91 09       	st.w	r8[0x0],r9
8000aed4:	fe b0 d7 6e 	rcall	80005db0 <__malloc_unlock>
8000aed8:	da 2a       	popm	r4-r7,pc,r12=1
8000aeda:	d7 03       	nop

8000aedc <_free_r>:
8000aedc:	d4 21       	pushm	r4-r7,lr
8000aede:	16 96       	mov	r6,r11
8000aee0:	18 97       	mov	r7,r12
8000aee2:	58 0b       	cp.w	r11,0
8000aee4:	e0 80 00 c0 	breq	8000b064 <_free_r+0x188>
8000aee8:	fe b0 d7 5e 	rcall	80005da4 <__malloc_lock>
8000aeec:	20 86       	sub	r6,8
8000aeee:	e0 6a 05 3c 	mov	r10,1340
8000aef2:	6c 18       	ld.w	r8,r6[0x4]
8000aef4:	74 2e       	ld.w	lr,r10[0x8]
8000aef6:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
8000aefa:	a1 c8       	cbr	r8,0x0
8000aefc:	ec 08 00 09 	add	r9,r6,r8
8000af00:	72 1b       	ld.w	r11,r9[0x4]
8000af02:	e0 1b ff fc 	andl	r11,0xfffc
8000af06:	1c 39       	cp.w	r9,lr
8000af08:	c1 e1       	brne	8000af44 <_free_r+0x68>
8000af0a:	f6 08 00 08 	add	r8,r11,r8
8000af0e:	58 0c       	cp.w	r12,0
8000af10:	c0 81       	brne	8000af20 <_free_r+0x44>
8000af12:	6c 09       	ld.w	r9,r6[0x0]
8000af14:	12 16       	sub	r6,r9
8000af16:	12 08       	add	r8,r9
8000af18:	6c 3b       	ld.w	r11,r6[0xc]
8000af1a:	6c 29       	ld.w	r9,r6[0x8]
8000af1c:	97 29       	st.w	r11[0x8],r9
8000af1e:	93 3b       	st.w	r9[0xc],r11
8000af20:	10 99       	mov	r9,r8
8000af22:	95 26       	st.w	r10[0x8],r6
8000af24:	a1 a9       	sbr	r9,0x0
8000af26:	8d 19       	st.w	r6[0x4],r9
8000af28:	e0 69 09 44 	mov	r9,2372
8000af2c:	72 09       	ld.w	r9,r9[0x0]
8000af2e:	12 38       	cp.w	r8,r9
8000af30:	c0 63       	brcs	8000af3c <_free_r+0x60>
8000af32:	e0 68 0d 64 	mov	r8,3428
8000af36:	0e 9c       	mov	r12,r7
8000af38:	70 0b       	ld.w	r11,r8[0x0]
8000af3a:	c8 5f       	rcall	8000ae44 <_malloc_trim_r>
8000af3c:	0e 9c       	mov	r12,r7
8000af3e:	fe b0 d7 39 	rcall	80005db0 <__malloc_unlock>
8000af42:	d8 22       	popm	r4-r7,pc
8000af44:	93 1b       	st.w	r9[0x4],r11
8000af46:	58 0c       	cp.w	r12,0
8000af48:	c0 30       	breq	8000af4e <_free_r+0x72>
8000af4a:	30 0c       	mov	r12,0
8000af4c:	c1 08       	rjmp	8000af6c <_free_r+0x90>
8000af4e:	6c 0e       	ld.w	lr,r6[0x0]
8000af50:	f4 c5 ff f8 	sub	r5,r10,-8
8000af54:	1c 16       	sub	r6,lr
8000af56:	1c 08       	add	r8,lr
8000af58:	6c 2e       	ld.w	lr,r6[0x8]
8000af5a:	0a 3e       	cp.w	lr,r5
8000af5c:	f9 bc 00 01 	moveq	r12,1
8000af60:	ed f5 10 03 	ld.wne	r5,r6[0xc]
8000af64:	eb fe 1a 02 	st.wne	r5[0x8],lr
8000af68:	fd f5 1a 03 	st.wne	lr[0xc],r5
8000af6c:	f2 0b 00 0e 	add	lr,r9,r11
8000af70:	7c 1e       	ld.w	lr,lr[0x4]
8000af72:	ed be 00 00 	bld	lr,0x0
8000af76:	c1 40       	breq	8000af9e <_free_r+0xc2>
8000af78:	16 08       	add	r8,r11
8000af7a:	58 0c       	cp.w	r12,0
8000af7c:	c0 d1       	brne	8000af96 <_free_r+0xba>
8000af7e:	e0 6e 05 3c 	mov	lr,1340
8000af82:	72 2b       	ld.w	r11,r9[0x8]
8000af84:	2f 8e       	sub	lr,-8
8000af86:	1c 3b       	cp.w	r11,lr
8000af88:	c0 71       	brne	8000af96 <_free_r+0xba>
8000af8a:	97 36       	st.w	r11[0xc],r6
8000af8c:	97 26       	st.w	r11[0x8],r6
8000af8e:	8d 2b       	st.w	r6[0x8],r11
8000af90:	8d 3b       	st.w	r6[0xc],r11
8000af92:	30 1c       	mov	r12,1
8000af94:	c0 58       	rjmp	8000af9e <_free_r+0xc2>
8000af96:	72 2b       	ld.w	r11,r9[0x8]
8000af98:	72 39       	ld.w	r9,r9[0xc]
8000af9a:	93 2b       	st.w	r9[0x8],r11
8000af9c:	97 39       	st.w	r11[0xc],r9
8000af9e:	10 99       	mov	r9,r8
8000afa0:	ec 08 09 08 	st.w	r6[r8],r8
8000afa4:	a1 a9       	sbr	r9,0x0
8000afa6:	8d 19       	st.w	r6[0x4],r9
8000afa8:	58 0c       	cp.w	r12,0
8000afaa:	c5 a1       	brne	8000b05e <_free_r+0x182>
8000afac:	e0 48 01 ff 	cp.w	r8,511
8000afb0:	e0 8b 00 13 	brhi	8000afd6 <_free_r+0xfa>
8000afb4:	a3 98       	lsr	r8,0x3
8000afb6:	f4 08 00 39 	add	r9,r10,r8<<0x3
8000afba:	72 2b       	ld.w	r11,r9[0x8]
8000afbc:	8d 39       	st.w	r6[0xc],r9
8000afbe:	8d 2b       	st.w	r6[0x8],r11
8000afc0:	97 36       	st.w	r11[0xc],r6
8000afc2:	93 26       	st.w	r9[0x8],r6
8000afc4:	a3 48       	asr	r8,0x2
8000afc6:	74 19       	ld.w	r9,r10[0x4]
8000afc8:	30 1b       	mov	r11,1
8000afca:	f6 08 09 48 	lsl	r8,r11,r8
8000afce:	f3 e8 10 08 	or	r8,r9,r8
8000afd2:	95 18       	st.w	r10[0x4],r8
8000afd4:	c4 58       	rjmp	8000b05e <_free_r+0x182>
8000afd6:	f0 0b 16 09 	lsr	r11,r8,0x9
8000afda:	58 4b       	cp.w	r11,4
8000afdc:	e0 8b 00 06 	brhi	8000afe8 <_free_r+0x10c>
8000afe0:	f0 0b 16 06 	lsr	r11,r8,0x6
8000afe4:	2c 8b       	sub	r11,-56
8000afe6:	c2 08       	rjmp	8000b026 <_free_r+0x14a>
8000afe8:	59 4b       	cp.w	r11,20
8000afea:	e0 8b 00 04 	brhi	8000aff2 <_free_r+0x116>
8000afee:	2a 5b       	sub	r11,-91
8000aff0:	c1 b8       	rjmp	8000b026 <_free_r+0x14a>
8000aff2:	e0 4b 00 54 	cp.w	r11,84
8000aff6:	e0 8b 00 06 	brhi	8000b002 <_free_r+0x126>
8000affa:	f0 0b 16 0c 	lsr	r11,r8,0xc
8000affe:	29 2b       	sub	r11,-110
8000b000:	c1 38       	rjmp	8000b026 <_free_r+0x14a>
8000b002:	e0 4b 01 54 	cp.w	r11,340
8000b006:	e0 8b 00 06 	brhi	8000b012 <_free_r+0x136>
8000b00a:	f0 0b 16 0f 	lsr	r11,r8,0xf
8000b00e:	28 9b       	sub	r11,-119
8000b010:	c0 b8       	rjmp	8000b026 <_free_r+0x14a>
8000b012:	e0 4b 05 54 	cp.w	r11,1364
8000b016:	e0 88 00 05 	brls	8000b020 <_free_r+0x144>
8000b01a:	37 eb       	mov	r11,126
8000b01c:	c0 58       	rjmp	8000b026 <_free_r+0x14a>
8000b01e:	d7 03       	nop
8000b020:	f0 0b 16 12 	lsr	r11,r8,0x12
8000b024:	28 4b       	sub	r11,-124
8000b026:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
8000b02a:	78 29       	ld.w	r9,r12[0x8]
8000b02c:	18 39       	cp.w	r9,r12
8000b02e:	c0 e1       	brne	8000b04a <_free_r+0x16e>
8000b030:	74 18       	ld.w	r8,r10[0x4]
8000b032:	a3 4b       	asr	r11,0x2
8000b034:	30 1c       	mov	r12,1
8000b036:	f8 0b 09 4b 	lsl	r11,r12,r11
8000b03a:	f1 eb 10 0b 	or	r11,r8,r11
8000b03e:	12 98       	mov	r8,r9
8000b040:	95 1b       	st.w	r10[0x4],r11
8000b042:	c0 a8       	rjmp	8000b056 <_free_r+0x17a>
8000b044:	72 29       	ld.w	r9,r9[0x8]
8000b046:	18 39       	cp.w	r9,r12
8000b048:	c0 60       	breq	8000b054 <_free_r+0x178>
8000b04a:	72 1a       	ld.w	r10,r9[0x4]
8000b04c:	e0 1a ff fc 	andl	r10,0xfffc
8000b050:	14 38       	cp.w	r8,r10
8000b052:	cf 93       	brcs	8000b044 <_free_r+0x168>
8000b054:	72 38       	ld.w	r8,r9[0xc]
8000b056:	8d 38       	st.w	r6[0xc],r8
8000b058:	8d 29       	st.w	r6[0x8],r9
8000b05a:	93 36       	st.w	r9[0xc],r6
8000b05c:	91 26       	st.w	r8[0x8],r6
8000b05e:	0e 9c       	mov	r12,r7
8000b060:	fe b0 d6 a8 	rcall	80005db0 <__malloc_unlock>
8000b064:	d8 22       	popm	r4-r7,pc
8000b066:	d7 03       	nop

8000b068 <__sfvwrite_r>:
8000b068:	d4 31       	pushm	r0-r7,lr
8000b06a:	20 3d       	sub	sp,12
8000b06c:	14 94       	mov	r4,r10
8000b06e:	18 95       	mov	r5,r12
8000b070:	16 97       	mov	r7,r11
8000b072:	74 28       	ld.w	r8,r10[0x8]
8000b074:	58 08       	cp.w	r8,0
8000b076:	e0 80 01 40 	breq	8000b2f6 <__sfvwrite_r+0x28e>
8000b07a:	96 68       	ld.sh	r8,r11[0xc]
8000b07c:	ed b8 00 03 	bld	r8,0x3
8000b080:	c0 41       	brne	8000b088 <__sfvwrite_r+0x20>
8000b082:	76 48       	ld.w	r8,r11[0x10]
8000b084:	58 08       	cp.w	r8,0
8000b086:	c0 c1       	brne	8000b09e <__sfvwrite_r+0x36>
8000b088:	0e 9b       	mov	r11,r7
8000b08a:	0a 9c       	mov	r12,r5
8000b08c:	fe b0 f6 c4 	rcall	80009e14 <__swsetup_r>
8000b090:	c0 70       	breq	8000b09e <__sfvwrite_r+0x36>
8000b092:	8e 68       	ld.sh	r8,r7[0xc]
8000b094:	a7 a8       	sbr	r8,0x6
8000b096:	ae 68       	st.h	r7[0xc],r8
8000b098:	30 98       	mov	r8,9
8000b09a:	8b 38       	st.w	r5[0xc],r8
8000b09c:	c2 b9       	rjmp	8000b2f2 <__sfvwrite_r+0x28a>
8000b09e:	8e 63       	ld.sh	r3,r7[0xc]
8000b0a0:	68 00       	ld.w	r0,r4[0x0]
8000b0a2:	06 96       	mov	r6,r3
8000b0a4:	e2 16 00 02 	andl	r6,0x2,COH
8000b0a8:	c2 10       	breq	8000b0ea <__sfvwrite_r+0x82>
8000b0aa:	30 03       	mov	r3,0
8000b0ac:	e0 62 04 00 	mov	r2,1024
8000b0b0:	06 96       	mov	r6,r3
8000b0b2:	c0 48       	rjmp	8000b0ba <__sfvwrite_r+0x52>
8000b0b4:	60 03       	ld.w	r3,r0[0x0]
8000b0b6:	60 16       	ld.w	r6,r0[0x4]
8000b0b8:	2f 80       	sub	r0,-8
8000b0ba:	58 06       	cp.w	r6,0
8000b0bc:	cf c0       	breq	8000b0b4 <__sfvwrite_r+0x4c>
8000b0be:	e0 46 04 00 	cp.w	r6,1024
8000b0c2:	ec 09 17 80 	movls	r9,r6
8000b0c6:	e4 09 17 b0 	movhi	r9,r2
8000b0ca:	06 9a       	mov	r10,r3
8000b0cc:	6e a8       	ld.w	r8,r7[0x28]
8000b0ce:	6e 8b       	ld.w	r11,r7[0x20]
8000b0d0:	0a 9c       	mov	r12,r5
8000b0d2:	5d 18       	icall	r8
8000b0d4:	18 16       	sub	r6,r12
8000b0d6:	58 0c       	cp.w	r12,0
8000b0d8:	e0 8a 01 0a 	brle	8000b2ec <__sfvwrite_r+0x284>
8000b0dc:	68 28       	ld.w	r8,r4[0x8]
8000b0de:	18 18       	sub	r8,r12
8000b0e0:	89 28       	st.w	r4[0x8],r8
8000b0e2:	e0 80 01 0a 	breq	8000b2f6 <__sfvwrite_r+0x28e>
8000b0e6:	18 03       	add	r3,r12
8000b0e8:	ce 9b       	rjmp	8000b0ba <__sfvwrite_r+0x52>
8000b0ea:	e7 d3 c0 01 	bfextu	r3,r3,0x0,0x1
8000b0ee:	c0 70       	breq	8000b0fc <__sfvwrite_r+0x94>
8000b0f0:	50 06       	stdsp	sp[0x0],r6
8000b0f2:	0c 93       	mov	r3,r6
8000b0f4:	0c 91       	mov	r1,r6
8000b0f6:	50 15       	stdsp	sp[0x4],r5
8000b0f8:	08 92       	mov	r2,r4
8000b0fa:	c9 c8       	rjmp	8000b232 <__sfvwrite_r+0x1ca>
8000b0fc:	06 96       	mov	r6,r3
8000b0fe:	08 91       	mov	r1,r4
8000b100:	c0 48       	rjmp	8000b108 <__sfvwrite_r+0xa0>
8000b102:	60 03       	ld.w	r3,r0[0x0]
8000b104:	60 16       	ld.w	r6,r0[0x4]
8000b106:	2f 80       	sub	r0,-8
8000b108:	58 06       	cp.w	r6,0
8000b10a:	cf c0       	breq	8000b102 <__sfvwrite_r+0x9a>
8000b10c:	8e 68       	ld.sh	r8,r7[0xc]
8000b10e:	6e 24       	ld.w	r4,r7[0x8]
8000b110:	10 99       	mov	r9,r8
8000b112:	e2 19 02 00 	andl	r9,0x200,COH
8000b116:	c5 50       	breq	8000b1c0 <__sfvwrite_r+0x158>
8000b118:	08 36       	cp.w	r6,r4
8000b11a:	c4 43       	brcs	8000b1a2 <__sfvwrite_r+0x13a>
8000b11c:	10 99       	mov	r9,r8
8000b11e:	e2 19 04 80 	andl	r9,0x480,COH
8000b122:	c4 00       	breq	8000b1a2 <__sfvwrite_r+0x13a>
8000b124:	6e 4b       	ld.w	r11,r7[0x10]
8000b126:	6e 09       	ld.w	r9,r7[0x0]
8000b128:	16 19       	sub	r9,r11
8000b12a:	50 09       	stdsp	sp[0x0],r9
8000b12c:	6e 59       	ld.w	r9,r7[0x14]
8000b12e:	10 9c       	mov	r12,r8
8000b130:	f2 09 00 1a 	add	r10,r9,r9<<0x1
8000b134:	30 28       	mov	r8,2
8000b136:	f4 08 0c 08 	divs	r8,r10,r8
8000b13a:	fa e9 00 04 	st.d	sp[4],r8
8000b13e:	10 94       	mov	r4,r8
8000b140:	40 09       	lddsp	r9,sp[0x0]
8000b142:	e2 1c 04 00 	andl	r12,0x400,COH
8000b146:	2f f9       	sub	r9,-1
8000b148:	0c 09       	add	r9,r6
8000b14a:	12 38       	cp.w	r8,r9
8000b14c:	f2 04 17 30 	movlo	r4,r9
8000b150:	58 0c       	cp.w	r12,0
8000b152:	c1 10       	breq	8000b174 <__sfvwrite_r+0x10c>
8000b154:	08 9b       	mov	r11,r4
8000b156:	0a 9c       	mov	r12,r5
8000b158:	fe b0 e0 6c 	rcall	80007230 <_malloc_r>
8000b15c:	18 92       	mov	r2,r12
8000b15e:	c1 40       	breq	8000b186 <__sfvwrite_r+0x11e>
8000b160:	40 0a       	lddsp	r10,sp[0x0]
8000b162:	6e 4b       	ld.w	r11,r7[0x10]
8000b164:	fe b0 e2 82 	rcall	80007668 <memcpy>
8000b168:	8e 68       	ld.sh	r8,r7[0xc]
8000b16a:	e0 18 fb 7f 	andl	r8,0xfb7f
8000b16e:	a7 b8       	sbr	r8,0x7
8000b170:	ae 68       	st.h	r7[0xc],r8
8000b172:	c0 d8       	rjmp	8000b18c <__sfvwrite_r+0x124>
8000b174:	08 9a       	mov	r10,r4
8000b176:	0a 9c       	mov	r12,r5
8000b178:	fe b0 e3 24 	rcall	800077c0 <_realloc_r>
8000b17c:	18 92       	mov	r2,r12
8000b17e:	c0 71       	brne	8000b18c <__sfvwrite_r+0x124>
8000b180:	6e 4b       	ld.w	r11,r7[0x10]
8000b182:	0a 9c       	mov	r12,r5
8000b184:	ca ce       	rcall	8000aedc <_free_r>
8000b186:	30 c8       	mov	r8,12
8000b188:	8b 38       	st.w	r5[0xc],r8
8000b18a:	cb 18       	rjmp	8000b2ec <__sfvwrite_r+0x284>
8000b18c:	40 0a       	lddsp	r10,sp[0x0]
8000b18e:	40 09       	lddsp	r9,sp[0x0]
8000b190:	e8 0a 01 0a 	sub	r10,r4,r10
8000b194:	e4 09 00 08 	add	r8,r2,r9
8000b198:	8f 54       	st.w	r7[0x14],r4
8000b19a:	8f 2a       	st.w	r7[0x8],r10
8000b19c:	8f 08       	st.w	r7[0x0],r8
8000b19e:	8f 42       	st.w	r7[0x10],r2
8000b1a0:	0c 94       	mov	r4,r6
8000b1a2:	08 36       	cp.w	r6,r4
8000b1a4:	ec 04 17 30 	movlo	r4,r6
8000b1a8:	06 9b       	mov	r11,r3
8000b1aa:	08 9a       	mov	r10,r4
8000b1ac:	6e 0c       	ld.w	r12,r7[0x0]
8000b1ae:	c3 ad       	rcall	8000b422 <memmove>
8000b1b0:	6e 08       	ld.w	r8,r7[0x0]
8000b1b2:	08 08       	add	r8,r4
8000b1b4:	8f 08       	st.w	r7[0x0],r8
8000b1b6:	6e 28       	ld.w	r8,r7[0x8]
8000b1b8:	08 18       	sub	r8,r4
8000b1ba:	0c 94       	mov	r4,r6
8000b1bc:	8f 28       	st.w	r7[0x8],r8
8000b1be:	c2 e8       	rjmp	8000b21a <__sfvwrite_r+0x1b2>
8000b1c0:	08 36       	cp.w	r6,r4
8000b1c2:	5f ba       	srhi	r10
8000b1c4:	6e 0c       	ld.w	r12,r7[0x0]
8000b1c6:	6e 48       	ld.w	r8,r7[0x10]
8000b1c8:	10 3c       	cp.w	r12,r8
8000b1ca:	5f b8       	srhi	r8
8000b1cc:	f5 e8 00 08 	and	r8,r10,r8
8000b1d0:	f2 08 18 00 	cp.b	r8,r9
8000b1d4:	c0 d0       	breq	8000b1ee <__sfvwrite_r+0x186>
8000b1d6:	06 9b       	mov	r11,r3
8000b1d8:	08 9a       	mov	r10,r4
8000b1da:	c2 4d       	rcall	8000b422 <memmove>
8000b1dc:	6e 08       	ld.w	r8,r7[0x0]
8000b1de:	08 08       	add	r8,r4
8000b1e0:	0e 9b       	mov	r11,r7
8000b1e2:	8f 08       	st.w	r7[0x0],r8
8000b1e4:	0a 9c       	mov	r12,r5
8000b1e6:	fe b0 fd 09 	rcall	8000abf8 <_fflush_r>
8000b1ea:	c1 80       	breq	8000b21a <__sfvwrite_r+0x1b2>
8000b1ec:	c8 08       	rjmp	8000b2ec <__sfvwrite_r+0x284>
8000b1ee:	6e 59       	ld.w	r9,r7[0x14]
8000b1f0:	12 36       	cp.w	r6,r9
8000b1f2:	c0 a3       	brcs	8000b206 <__sfvwrite_r+0x19e>
8000b1f4:	6e a8       	ld.w	r8,r7[0x28]
8000b1f6:	06 9a       	mov	r10,r3
8000b1f8:	6e 8b       	ld.w	r11,r7[0x20]
8000b1fa:	0a 9c       	mov	r12,r5
8000b1fc:	5d 18       	icall	r8
8000b1fe:	18 94       	mov	r4,r12
8000b200:	e0 89 00 0d 	brgt	8000b21a <__sfvwrite_r+0x1b2>
8000b204:	c7 48       	rjmp	8000b2ec <__sfvwrite_r+0x284>
8000b206:	0c 9a       	mov	r10,r6
8000b208:	06 9b       	mov	r11,r3
8000b20a:	c0 cd       	rcall	8000b422 <memmove>
8000b20c:	6e 08       	ld.w	r8,r7[0x0]
8000b20e:	0c 08       	add	r8,r6
8000b210:	0c 94       	mov	r4,r6
8000b212:	8f 08       	st.w	r7[0x0],r8
8000b214:	6e 28       	ld.w	r8,r7[0x8]
8000b216:	0c 18       	sub	r8,r6
8000b218:	8f 28       	st.w	r7[0x8],r8
8000b21a:	62 28       	ld.w	r8,r1[0x8]
8000b21c:	08 18       	sub	r8,r4
8000b21e:	83 28       	st.w	r1[0x8],r8
8000b220:	c6 b0       	breq	8000b2f6 <__sfvwrite_r+0x28e>
8000b222:	08 16       	sub	r6,r4
8000b224:	08 03       	add	r3,r4
8000b226:	c7 1b       	rjmp	8000b108 <__sfvwrite_r+0xa0>
8000b228:	60 03       	ld.w	r3,r0[0x0]
8000b22a:	60 11       	ld.w	r1,r0[0x4]
8000b22c:	30 08       	mov	r8,0
8000b22e:	2f 80       	sub	r0,-8
8000b230:	50 08       	stdsp	sp[0x0],r8
8000b232:	58 01       	cp.w	r1,0
8000b234:	cf a0       	breq	8000b228 <__sfvwrite_r+0x1c0>
8000b236:	40 0a       	lddsp	r10,sp[0x0]
8000b238:	58 0a       	cp.w	r10,0
8000b23a:	c1 41       	brne	8000b262 <__sfvwrite_r+0x1fa>
8000b23c:	e2 c6 ff ff 	sub	r6,r1,-1
8000b240:	02 9a       	mov	r10,r1
8000b242:	30 ab       	mov	r11,10
8000b244:	06 9c       	mov	r12,r3
8000b246:	ce 3c       	rcall	8000b40c <memchr>
8000b248:	f8 c8 ff ff 	sub	r8,r12,-1
8000b24c:	58 0c       	cp.w	r12,0
8000b24e:	f1 d3 e1 16 	subne	r6,r8,r3
8000b252:	f9 b9 01 01 	movne	r9,1
8000b256:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000b25a:	f9 b8 00 01 	moveq	r8,1
8000b25e:	fb f8 0a 00 	st.weq	sp[0x0],r8
8000b262:	02 36       	cp.w	r6,r1
8000b264:	ec 04 17 80 	movls	r4,r6
8000b268:	e2 04 17 b0 	movhi	r4,r1
8000b26c:	6e 59       	ld.w	r9,r7[0x14]
8000b26e:	6e 25       	ld.w	r5,r7[0x8]
8000b270:	f2 05 00 05 	add	r5,r9,r5
8000b274:	0a 34       	cp.w	r4,r5
8000b276:	5f 9a       	srgt	r10
8000b278:	6e 0c       	ld.w	r12,r7[0x0]
8000b27a:	6e 48       	ld.w	r8,r7[0x10]
8000b27c:	10 3c       	cp.w	r12,r8
8000b27e:	5f b8       	srhi	r8
8000b280:	f5 e8 00 08 	and	r8,r10,r8
8000b284:	30 0a       	mov	r10,0
8000b286:	f4 08 18 00 	cp.b	r8,r10
8000b28a:	c0 d0       	breq	8000b2a4 <__sfvwrite_r+0x23c>
8000b28c:	06 9b       	mov	r11,r3
8000b28e:	0a 9a       	mov	r10,r5
8000b290:	cc 9c       	rcall	8000b422 <memmove>
8000b292:	6e 08       	ld.w	r8,r7[0x0]
8000b294:	0a 08       	add	r8,r5
8000b296:	0e 9b       	mov	r11,r7
8000b298:	8f 08       	st.w	r7[0x0],r8
8000b29a:	40 1c       	lddsp	r12,sp[0x4]
8000b29c:	fe b0 fc ae 	rcall	8000abf8 <_fflush_r>
8000b2a0:	c1 70       	breq	8000b2ce <__sfvwrite_r+0x266>
8000b2a2:	c2 58       	rjmp	8000b2ec <__sfvwrite_r+0x284>
8000b2a4:	12 34       	cp.w	r4,r9
8000b2a6:	c0 a5       	brlt	8000b2ba <__sfvwrite_r+0x252>
8000b2a8:	6e a8       	ld.w	r8,r7[0x28]
8000b2aa:	06 9a       	mov	r10,r3
8000b2ac:	6e 8b       	ld.w	r11,r7[0x20]
8000b2ae:	40 1c       	lddsp	r12,sp[0x4]
8000b2b0:	5d 18       	icall	r8
8000b2b2:	18 95       	mov	r5,r12
8000b2b4:	e0 89 00 0d 	brgt	8000b2ce <__sfvwrite_r+0x266>
8000b2b8:	c1 a8       	rjmp	8000b2ec <__sfvwrite_r+0x284>
8000b2ba:	08 9a       	mov	r10,r4
8000b2bc:	06 9b       	mov	r11,r3
8000b2be:	cb 2c       	rcall	8000b422 <memmove>
8000b2c0:	6e 08       	ld.w	r8,r7[0x0]
8000b2c2:	08 08       	add	r8,r4
8000b2c4:	08 95       	mov	r5,r4
8000b2c6:	8f 08       	st.w	r7[0x0],r8
8000b2c8:	6e 28       	ld.w	r8,r7[0x8]
8000b2ca:	08 18       	sub	r8,r4
8000b2cc:	8f 28       	st.w	r7[0x8],r8
8000b2ce:	0a 16       	sub	r6,r5
8000b2d0:	c0 71       	brne	8000b2de <__sfvwrite_r+0x276>
8000b2d2:	0e 9b       	mov	r11,r7
8000b2d4:	40 1c       	lddsp	r12,sp[0x4]
8000b2d6:	fe b0 fc 91 	rcall	8000abf8 <_fflush_r>
8000b2da:	c0 91       	brne	8000b2ec <__sfvwrite_r+0x284>
8000b2dc:	50 06       	stdsp	sp[0x0],r6
8000b2de:	64 28       	ld.w	r8,r2[0x8]
8000b2e0:	0a 18       	sub	r8,r5
8000b2e2:	85 28       	st.w	r2[0x8],r8
8000b2e4:	c0 90       	breq	8000b2f6 <__sfvwrite_r+0x28e>
8000b2e6:	0a 11       	sub	r1,r5
8000b2e8:	0a 03       	add	r3,r5
8000b2ea:	ca 4b       	rjmp	8000b232 <__sfvwrite_r+0x1ca>
8000b2ec:	8e 68       	ld.sh	r8,r7[0xc]
8000b2ee:	a7 a8       	sbr	r8,0x6
8000b2f0:	ae 68       	st.h	r7[0xc],r8
8000b2f2:	3f fc       	mov	r12,-1
8000b2f4:	c0 28       	rjmp	8000b2f8 <__sfvwrite_r+0x290>
8000b2f6:	30 0c       	mov	r12,0
8000b2f8:	2f dd       	sub	sp,-12
8000b2fa:	d8 32       	popm	r0-r7,pc

8000b2fc <_fwalk>:
8000b2fc:	d4 31       	pushm	r0-r7,lr
8000b2fe:	30 05       	mov	r5,0
8000b300:	16 91       	mov	r1,r11
8000b302:	f8 c7 ff 28 	sub	r7,r12,-216
8000b306:	0a 92       	mov	r2,r5
8000b308:	fe b0 fc fe 	rcall	8000ad04 <__sfp_lock_acquire>
8000b30c:	3f f3       	mov	r3,-1
8000b30e:	c1 68       	rjmp	8000b33a <_fwalk+0x3e>
8000b310:	6e 26       	ld.w	r6,r7[0x8]
8000b312:	6e 14       	ld.w	r4,r7[0x4]
8000b314:	2f 46       	sub	r6,-12
8000b316:	c0 c8       	rjmp	8000b32e <_fwalk+0x32>
8000b318:	8c 08       	ld.sh	r8,r6[0x0]
8000b31a:	e4 08 19 00 	cp.h	r8,r2
8000b31e:	c0 70       	breq	8000b32c <_fwalk+0x30>
8000b320:	8c 18       	ld.sh	r8,r6[0x2]
8000b322:	e6 08 19 00 	cp.h	r8,r3
8000b326:	c0 30       	breq	8000b32c <_fwalk+0x30>
8000b328:	5d 11       	icall	r1
8000b32a:	18 45       	or	r5,r12
8000b32c:	2a 46       	sub	r6,-92
8000b32e:	20 14       	sub	r4,1
8000b330:	ec cc 00 0c 	sub	r12,r6,12
8000b334:	58 04       	cp.w	r4,0
8000b336:	cf 14       	brge	8000b318 <_fwalk+0x1c>
8000b338:	6e 07       	ld.w	r7,r7[0x0]
8000b33a:	58 07       	cp.w	r7,0
8000b33c:	ce a1       	brne	8000b310 <_fwalk+0x14>
8000b33e:	fe b0 fc e4 	rcall	8000ad06 <__sfp_lock_release>
8000b342:	0a 9c       	mov	r12,r5
8000b344:	d8 32       	popm	r0-r7,pc
8000b346:	d7 03       	nop

8000b348 <_localeconv_r>:
8000b348:	fe cc d3 cc 	sub	r12,pc,-11316
8000b34c:	5e fc       	retal	r12
8000b34e:	d7 03       	nop

8000b350 <__smakebuf_r>:
8000b350:	d4 21       	pushm	r4-r7,lr
8000b352:	20 fd       	sub	sp,60
8000b354:	96 68       	ld.sh	r8,r11[0xc]
8000b356:	16 97       	mov	r7,r11
8000b358:	18 96       	mov	r6,r12
8000b35a:	e2 18 00 02 	andl	r8,0x2,COH
8000b35e:	c3 d1       	brne	8000b3d8 <__smakebuf_r+0x88>
8000b360:	96 7b       	ld.sh	r11,r11[0xe]
8000b362:	f0 0b 19 00 	cp.h	r11,r8
8000b366:	c0 55       	brlt	8000b370 <__smakebuf_r+0x20>
8000b368:	1a 9a       	mov	r10,sp
8000b36a:	e0 a0 04 81 	rcall	8000bc6c <_fstat_r>
8000b36e:	c0 f4       	brge	8000b38c <__smakebuf_r+0x3c>
8000b370:	8e 65       	ld.sh	r5,r7[0xc]
8000b372:	0a 98       	mov	r8,r5
8000b374:	ab b8       	sbr	r8,0xb
8000b376:	e2 15 00 80 	andl	r5,0x80,COH
8000b37a:	ae 68       	st.h	r7[0xc],r8
8000b37c:	30 04       	mov	r4,0
8000b37e:	e0 68 04 00 	mov	r8,1024
8000b382:	f9 b5 01 40 	movne	r5,64
8000b386:	f0 05 17 00 	moveq	r5,r8
8000b38a:	c1 c8       	rjmp	8000b3c2 <__smakebuf_r+0x72>
8000b38c:	40 18       	lddsp	r8,sp[0x4]
8000b38e:	e2 18 f0 00 	andl	r8,0xf000,COH
8000b392:	e0 48 20 00 	cp.w	r8,8192
8000b396:	5f 04       	sreq	r4
8000b398:	e0 48 80 00 	cp.w	r8,32768
8000b39c:	c0 e1       	brne	8000b3b8 <__smakebuf_r+0x68>
8000b39e:	6e b9       	ld.w	r9,r7[0x2c]
8000b3a0:	fe c8 f9 1c 	sub	r8,pc,-1764
8000b3a4:	10 39       	cp.w	r9,r8
8000b3a6:	c0 91       	brne	8000b3b8 <__smakebuf_r+0x68>
8000b3a8:	8e 68       	ld.sh	r8,r7[0xc]
8000b3aa:	e0 65 04 00 	mov	r5,1024
8000b3ae:	ab a8       	sbr	r8,0xa
8000b3b0:	ef 45 00 50 	st.w	r7[80],r5
8000b3b4:	ae 68       	st.h	r7[0xc],r8
8000b3b6:	c0 68       	rjmp	8000b3c2 <__smakebuf_r+0x72>
8000b3b8:	8e 68       	ld.sh	r8,r7[0xc]
8000b3ba:	e0 65 04 00 	mov	r5,1024
8000b3be:	ab b8       	sbr	r8,0xb
8000b3c0:	ae 68       	st.h	r7[0xc],r8
8000b3c2:	0a 9b       	mov	r11,r5
8000b3c4:	0c 9c       	mov	r12,r6
8000b3c6:	fe b0 df 35 	rcall	80007230 <_malloc_r>
8000b3ca:	8e 68       	ld.sh	r8,r7[0xc]
8000b3cc:	c0 d1       	brne	8000b3e6 <__smakebuf_r+0x96>
8000b3ce:	ed b8 00 09 	bld	r8,0x9
8000b3d2:	c1 b0       	breq	8000b408 <__smakebuf_r+0xb8>
8000b3d4:	a1 b8       	sbr	r8,0x1
8000b3d6:	ae 68       	st.h	r7[0xc],r8
8000b3d8:	ee c8 ff b9 	sub	r8,r7,-71
8000b3dc:	8f 48       	st.w	r7[0x10],r8
8000b3de:	8f 08       	st.w	r7[0x0],r8
8000b3e0:	30 18       	mov	r8,1
8000b3e2:	8f 58       	st.w	r7[0x14],r8
8000b3e4:	c1 28       	rjmp	8000b408 <__smakebuf_r+0xb8>
8000b3e6:	a7 b8       	sbr	r8,0x7
8000b3e8:	8f 4c       	st.w	r7[0x10],r12
8000b3ea:	ae 68       	st.h	r7[0xc],r8
8000b3ec:	8f 55       	st.w	r7[0x14],r5
8000b3ee:	fe c8 06 e6 	sub	r8,pc,1766
8000b3f2:	8f 0c       	st.w	r7[0x0],r12
8000b3f4:	8d a8       	st.w	r6[0x28],r8
8000b3f6:	58 04       	cp.w	r4,0
8000b3f8:	c0 80       	breq	8000b408 <__smakebuf_r+0xb8>
8000b3fa:	8e 7c       	ld.sh	r12,r7[0xe]
8000b3fc:	fe b0 e3 94 	rcall	80007b24 <isatty>
8000b400:	c0 40       	breq	8000b408 <__smakebuf_r+0xb8>
8000b402:	8e 68       	ld.sh	r8,r7[0xc]
8000b404:	a1 a8       	sbr	r8,0x0
8000b406:	ae 68       	st.h	r7[0xc],r8
8000b408:	2f 1d       	sub	sp,-60
8000b40a:	d8 22       	popm	r4-r7,pc

8000b40c <memchr>:
8000b40c:	f7 db c0 08 	bfextu	r11,r11,0x0,0x8
8000b410:	c0 68       	rjmp	8000b41c <memchr+0x10>
8000b412:	20 1a       	sub	r10,1
8000b414:	19 88       	ld.ub	r8,r12[0x0]
8000b416:	16 38       	cp.w	r8,r11
8000b418:	5e 0c       	reteq	r12
8000b41a:	2f fc       	sub	r12,-1
8000b41c:	58 0a       	cp.w	r10,0
8000b41e:	cf a1       	brne	8000b412 <memchr+0x6>
8000b420:	5e fa       	retal	r10

8000b422 <memmove>:
8000b422:	d4 01       	pushm	lr
8000b424:	18 3b       	cp.w	r11,r12
8000b426:	c1 92       	brcc	8000b458 <memmove+0x36>
8000b428:	f6 0a 00 09 	add	r9,r11,r10
8000b42c:	12 3c       	cp.w	r12,r9
8000b42e:	c1 52       	brcc	8000b458 <memmove+0x36>
8000b430:	f8 0a 00 0b 	add	r11,r12,r10
8000b434:	30 08       	mov	r8,0
8000b436:	c0 68       	rjmp	8000b442 <memmove+0x20>
8000b438:	f2 08 07 0e 	ld.ub	lr,r9[r8]
8000b43c:	20 1a       	sub	r10,1
8000b43e:	f6 08 0b 0e 	st.b	r11[r8],lr
8000b442:	20 18       	sub	r8,1
8000b444:	58 0a       	cp.w	r10,0
8000b446:	cf 91       	brne	8000b438 <memmove+0x16>
8000b448:	d8 02       	popm	pc
8000b44a:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000b44e:	20 1a       	sub	r10,1
8000b450:	f8 08 0b 09 	st.b	r12[r8],r9
8000b454:	2f f8       	sub	r8,-1
8000b456:	c0 28       	rjmp	8000b45a <memmove+0x38>
8000b458:	30 08       	mov	r8,0
8000b45a:	58 0a       	cp.w	r10,0
8000b45c:	cf 71       	brne	8000b44a <memmove+0x28>
8000b45e:	d8 02       	popm	pc

8000b460 <__hi0bits>:
8000b460:	18 98       	mov	r8,r12
8000b462:	e0 1c 00 00 	andl	r12,0x0
8000b466:	f0 09 15 10 	lsl	r9,r8,0x10
8000b46a:	58 0c       	cp.w	r12,0
8000b46c:	f2 08 17 00 	moveq	r8,r9
8000b470:	f9 bc 00 10 	moveq	r12,16
8000b474:	f9 bc 01 00 	movne	r12,0
8000b478:	10 9a       	mov	r10,r8
8000b47a:	f0 09 15 08 	lsl	r9,r8,0x8
8000b47e:	e6 1a ff 00 	andh	r10,0xff00,COH
8000b482:	f7 bc 00 f8 	subeq	r12,-8
8000b486:	f2 08 17 00 	moveq	r8,r9
8000b48a:	10 9a       	mov	r10,r8
8000b48c:	f0 09 15 04 	lsl	r9,r8,0x4
8000b490:	e6 1a f0 00 	andh	r10,0xf000,COH
8000b494:	f7 bc 00 fc 	subeq	r12,-4
8000b498:	f2 08 17 00 	moveq	r8,r9
8000b49c:	10 9a       	mov	r10,r8
8000b49e:	f0 09 15 02 	lsl	r9,r8,0x2
8000b4a2:	e6 1a c0 00 	andh	r10,0xc000,COH
8000b4a6:	f7 bc 00 fe 	subeq	r12,-2
8000b4aa:	f2 08 17 00 	moveq	r8,r9
8000b4ae:	58 08       	cp.w	r8,0
8000b4b0:	5e 5c       	retlt	r12
8000b4b2:	ed b8 00 1e 	bld	r8,0x1e
8000b4b6:	f9 bc 01 20 	movne	r12,32
8000b4ba:	f7 bc 00 ff 	subeq	r12,-1
8000b4be:	5e fc       	retal	r12

8000b4c0 <__lo0bits>:
8000b4c0:	18 99       	mov	r9,r12
8000b4c2:	78 08       	ld.w	r8,r12[0x0]
8000b4c4:	f9 d8 c0 03 	bfextu	r12,r8,0x0,0x3
8000b4c8:	c1 50       	breq	8000b4f2 <__lo0bits+0x32>
8000b4ca:	ed b8 00 00 	bld	r8,0x0
8000b4ce:	c0 21       	brne	8000b4d2 <__lo0bits+0x12>
8000b4d0:	5e fd       	retal	0
8000b4d2:	10 9b       	mov	r11,r8
8000b4d4:	f0 0a 16 01 	lsr	r10,r8,0x1
8000b4d8:	e2 1b 00 02 	andl	r11,0x2,COH
8000b4dc:	a3 88       	lsr	r8,0x2
8000b4de:	58 0b       	cp.w	r11,0
8000b4e0:	f3 fa 1a 00 	st.wne	r9[0x0],r10
8000b4e4:	f9 bc 01 01 	movne	r12,1
8000b4e8:	f3 f8 0a 00 	st.weq	r9[0x0],r8
8000b4ec:	f9 bc 00 02 	moveq	r12,2
8000b4f0:	5e fc       	retal	r12
8000b4f2:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
8000b4f6:	f0 0b 16 10 	lsr	r11,r8,0x10
8000b4fa:	58 0a       	cp.w	r10,0
8000b4fc:	f6 08 17 00 	moveq	r8,r11
8000b500:	f9 bc 00 10 	moveq	r12,16
8000b504:	f7 d8 c0 08 	bfextu	r11,r8,0x0,0x8
8000b508:	f0 0a 16 08 	lsr	r10,r8,0x8
8000b50c:	58 0b       	cp.w	r11,0
8000b50e:	f7 bc 00 f8 	subeq	r12,-8
8000b512:	f4 08 17 00 	moveq	r8,r10
8000b516:	f7 d8 c0 04 	bfextu	r11,r8,0x0,0x4
8000b51a:	f0 0a 16 04 	lsr	r10,r8,0x4
8000b51e:	58 0b       	cp.w	r11,0
8000b520:	f7 bc 00 fc 	subeq	r12,-4
8000b524:	f4 08 17 00 	moveq	r8,r10
8000b528:	f7 d8 c0 02 	bfextu	r11,r8,0x0,0x2
8000b52c:	f0 0a 16 02 	lsr	r10,r8,0x2
8000b530:	58 0b       	cp.w	r11,0
8000b532:	f7 bc 00 fe 	subeq	r12,-2
8000b536:	f4 08 17 00 	moveq	r8,r10
8000b53a:	ed b8 00 00 	bld	r8,0x0
8000b53e:	c0 60       	breq	8000b54a <__lo0bits+0x8a>
8000b540:	a1 98       	lsr	r8,0x1
8000b542:	c0 31       	brne	8000b548 <__lo0bits+0x88>
8000b544:	32 0c       	mov	r12,32
8000b546:	5e fc       	retal	r12
8000b548:	2f fc       	sub	r12,-1
8000b54a:	93 08       	st.w	r9[0x0],r8
8000b54c:	5e fc       	retal	r12

8000b54e <__mcmp>:
8000b54e:	d4 01       	pushm	lr
8000b550:	18 98       	mov	r8,r12
8000b552:	76 49       	ld.w	r9,r11[0x10]
8000b554:	78 4c       	ld.w	r12,r12[0x10]
8000b556:	12 1c       	sub	r12,r9
8000b558:	c1 31       	brne	8000b57e <__mcmp+0x30>
8000b55a:	2f b9       	sub	r9,-5
8000b55c:	a3 69       	lsl	r9,0x2
8000b55e:	12 0b       	add	r11,r9
8000b560:	f0 09 00 09 	add	r9,r8,r9
8000b564:	2e c8       	sub	r8,-20
8000b566:	13 4e       	ld.w	lr,--r9
8000b568:	17 4a       	ld.w	r10,--r11
8000b56a:	14 3e       	cp.w	lr,r10
8000b56c:	c0 60       	breq	8000b578 <__mcmp+0x2a>
8000b56e:	f9 bc 03 ff 	movlo	r12,-1
8000b572:	f9 bc 02 01 	movhs	r12,1
8000b576:	d8 02       	popm	pc
8000b578:	10 39       	cp.w	r9,r8
8000b57a:	fe 9b ff f6 	brhi	8000b566 <__mcmp+0x18>
8000b57e:	d8 02       	popm	pc

8000b580 <_Bfree>:
8000b580:	d4 21       	pushm	r4-r7,lr
8000b582:	18 97       	mov	r7,r12
8000b584:	16 95       	mov	r5,r11
8000b586:	78 96       	ld.w	r6,r12[0x24]
8000b588:	58 06       	cp.w	r6,0
8000b58a:	c0 91       	brne	8000b59c <_Bfree+0x1c>
8000b58c:	31 0c       	mov	r12,16
8000b58e:	fe b0 de 49 	rcall	80007220 <malloc>
8000b592:	99 36       	st.w	r12[0xc],r6
8000b594:	8f 9c       	st.w	r7[0x24],r12
8000b596:	99 16       	st.w	r12[0x4],r6
8000b598:	99 26       	st.w	r12[0x8],r6
8000b59a:	99 06       	st.w	r12[0x0],r6
8000b59c:	58 05       	cp.w	r5,0
8000b59e:	c0 90       	breq	8000b5b0 <_Bfree+0x30>
8000b5a0:	6a 19       	ld.w	r9,r5[0x4]
8000b5a2:	6e 98       	ld.w	r8,r7[0x24]
8000b5a4:	70 38       	ld.w	r8,r8[0xc]
8000b5a6:	f0 09 03 2a 	ld.w	r10,r8[r9<<0x2]
8000b5aa:	8b 0a       	st.w	r5[0x0],r10
8000b5ac:	f0 09 09 25 	st.w	r8[r9<<0x2],r5
8000b5b0:	d8 22       	popm	r4-r7,pc
8000b5b2:	d7 03       	nop

8000b5b4 <_Balloc>:
8000b5b4:	d4 21       	pushm	r4-r7,lr
8000b5b6:	18 97       	mov	r7,r12
8000b5b8:	16 96       	mov	r6,r11
8000b5ba:	78 95       	ld.w	r5,r12[0x24]
8000b5bc:	58 05       	cp.w	r5,0
8000b5be:	c0 91       	brne	8000b5d0 <_Balloc+0x1c>
8000b5c0:	31 0c       	mov	r12,16
8000b5c2:	fe b0 de 2f 	rcall	80007220 <malloc>
8000b5c6:	99 35       	st.w	r12[0xc],r5
8000b5c8:	8f 9c       	st.w	r7[0x24],r12
8000b5ca:	99 15       	st.w	r12[0x4],r5
8000b5cc:	99 25       	st.w	r12[0x8],r5
8000b5ce:	99 05       	st.w	r12[0x0],r5
8000b5d0:	6e 95       	ld.w	r5,r7[0x24]
8000b5d2:	6a 38       	ld.w	r8,r5[0xc]
8000b5d4:	58 08       	cp.w	r8,0
8000b5d6:	c0 b1       	brne	8000b5ec <_Balloc+0x38>
8000b5d8:	31 0a       	mov	r10,16
8000b5da:	30 4b       	mov	r11,4
8000b5dc:	0e 9c       	mov	r12,r7
8000b5de:	e0 a0 02 a7 	rcall	8000bb2c <_calloc_r>
8000b5e2:	8b 3c       	st.w	r5[0xc],r12
8000b5e4:	6e 98       	ld.w	r8,r7[0x24]
8000b5e6:	70 3c       	ld.w	r12,r8[0xc]
8000b5e8:	58 0c       	cp.w	r12,0
8000b5ea:	c1 b0       	breq	8000b620 <_Balloc+0x6c>
8000b5ec:	6e 98       	ld.w	r8,r7[0x24]
8000b5ee:	70 38       	ld.w	r8,r8[0xc]
8000b5f0:	f0 06 00 28 	add	r8,r8,r6<<0x2
8000b5f4:	70 0c       	ld.w	r12,r8[0x0]
8000b5f6:	58 0c       	cp.w	r12,0
8000b5f8:	c0 40       	breq	8000b600 <_Balloc+0x4c>
8000b5fa:	78 09       	ld.w	r9,r12[0x0]
8000b5fc:	91 09       	st.w	r8[0x0],r9
8000b5fe:	c0 e8       	rjmp	8000b61a <_Balloc+0x66>
8000b600:	0e 9c       	mov	r12,r7
8000b602:	30 17       	mov	r7,1
8000b604:	0e 9b       	mov	r11,r7
8000b606:	ee 06 09 47 	lsl	r7,r7,r6
8000b60a:	ee ca ff fb 	sub	r10,r7,-5
8000b60e:	a3 6a       	lsl	r10,0x2
8000b610:	e0 a0 02 8e 	rcall	8000bb2c <_calloc_r>
8000b614:	c0 60       	breq	8000b620 <_Balloc+0x6c>
8000b616:	99 16       	st.w	r12[0x4],r6
8000b618:	99 27       	st.w	r12[0x8],r7
8000b61a:	30 08       	mov	r8,0
8000b61c:	99 38       	st.w	r12[0xc],r8
8000b61e:	99 48       	st.w	r12[0x10],r8
8000b620:	d8 22       	popm	r4-r7,pc
8000b622:	d7 03       	nop

8000b624 <__d2b>:
8000b624:	d4 31       	pushm	r0-r7,lr
8000b626:	20 2d       	sub	sp,8
8000b628:	16 93       	mov	r3,r11
8000b62a:	12 96       	mov	r6,r9
8000b62c:	10 95       	mov	r5,r8
8000b62e:	14 92       	mov	r2,r10
8000b630:	30 1b       	mov	r11,1
8000b632:	cc 1f       	rcall	8000b5b4 <_Balloc>
8000b634:	f3 d3 c0 14 	bfextu	r9,r3,0x0,0x14
8000b638:	50 09       	stdsp	sp[0x0],r9
8000b63a:	f1 d3 c0 1f 	bfextu	r8,r3,0x0,0x1f
8000b63e:	b5 a9       	sbr	r9,0x14
8000b640:	f0 01 16 14 	lsr	r1,r8,0x14
8000b644:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000b648:	18 94       	mov	r4,r12
8000b64a:	58 02       	cp.w	r2,0
8000b64c:	c1 d0       	breq	8000b686 <__d2b+0x62>
8000b64e:	fa cc ff f8 	sub	r12,sp,-8
8000b652:	18 d2       	st.w	--r12,r2
8000b654:	c3 6f       	rcall	8000b4c0 <__lo0bits>
8000b656:	40 18       	lddsp	r8,sp[0x4]
8000b658:	c0 d0       	breq	8000b672 <__d2b+0x4e>
8000b65a:	40 09       	lddsp	r9,sp[0x0]
8000b65c:	f8 0a 11 20 	rsub	r10,r12,32
8000b660:	f2 0a 09 4a 	lsl	r10,r9,r10
8000b664:	f5 e8 10 08 	or	r8,r10,r8
8000b668:	89 58       	st.w	r4[0x14],r8
8000b66a:	f2 0c 0a 49 	lsr	r9,r9,r12
8000b66e:	50 09       	stdsp	sp[0x0],r9
8000b670:	c0 28       	rjmp	8000b674 <__d2b+0x50>
8000b672:	89 58       	st.w	r4[0x14],r8
8000b674:	40 08       	lddsp	r8,sp[0x0]
8000b676:	58 08       	cp.w	r8,0
8000b678:	f9 b3 01 02 	movne	r3,2
8000b67c:	f9 b3 00 01 	moveq	r3,1
8000b680:	89 68       	st.w	r4[0x18],r8
8000b682:	89 43       	st.w	r4[0x10],r3
8000b684:	c0 88       	rjmp	8000b694 <__d2b+0x70>
8000b686:	1a 9c       	mov	r12,sp
8000b688:	c1 cf       	rcall	8000b4c0 <__lo0bits>
8000b68a:	30 13       	mov	r3,1
8000b68c:	40 08       	lddsp	r8,sp[0x0]
8000b68e:	2e 0c       	sub	r12,-32
8000b690:	89 43       	st.w	r4[0x10],r3
8000b692:	89 58       	st.w	r4[0x14],r8
8000b694:	58 01       	cp.w	r1,0
8000b696:	c0 90       	breq	8000b6a8 <__d2b+0x84>
8000b698:	e2 c1 04 33 	sub	r1,r1,1075
8000b69c:	18 01       	add	r1,r12
8000b69e:	8d 01       	st.w	r6[0x0],r1
8000b6a0:	f8 0c 11 35 	rsub	r12,r12,53
8000b6a4:	8b 0c       	st.w	r5[0x0],r12
8000b6a6:	c0 c8       	rjmp	8000b6be <__d2b+0x9a>
8000b6a8:	e6 c8 ff fc 	sub	r8,r3,-4
8000b6ac:	f8 cc 04 32 	sub	r12,r12,1074
8000b6b0:	a5 73       	lsl	r3,0x5
8000b6b2:	8d 0c       	st.w	r6[0x0],r12
8000b6b4:	e8 08 03 2c 	ld.w	r12,r4[r8<<0x2]
8000b6b8:	cd 4e       	rcall	8000b460 <__hi0bits>
8000b6ba:	18 13       	sub	r3,r12
8000b6bc:	8b 03       	st.w	r5[0x0],r3
8000b6be:	08 9c       	mov	r12,r4
8000b6c0:	2f ed       	sub	sp,-8
8000b6c2:	d8 32       	popm	r0-r7,pc

8000b6c4 <__mdiff>:
8000b6c4:	d4 31       	pushm	r0-r7,lr
8000b6c6:	74 48       	ld.w	r8,r10[0x10]
8000b6c8:	76 45       	ld.w	r5,r11[0x10]
8000b6ca:	16 97       	mov	r7,r11
8000b6cc:	14 96       	mov	r6,r10
8000b6ce:	10 15       	sub	r5,r8
8000b6d0:	c1 31       	brne	8000b6f6 <__mdiff+0x32>
8000b6d2:	2f b8       	sub	r8,-5
8000b6d4:	ee ce ff ec 	sub	lr,r7,-20
8000b6d8:	a3 68       	lsl	r8,0x2
8000b6da:	f4 08 00 0b 	add	r11,r10,r8
8000b6de:	ee 08 00 08 	add	r8,r7,r8
8000b6e2:	11 4a       	ld.w	r10,--r8
8000b6e4:	17 49       	ld.w	r9,--r11
8000b6e6:	12 3a       	cp.w	r10,r9
8000b6e8:	c0 30       	breq	8000b6ee <__mdiff+0x2a>
8000b6ea:	c0 e2       	brcc	8000b706 <__mdiff+0x42>
8000b6ec:	c0 78       	rjmp	8000b6fa <__mdiff+0x36>
8000b6ee:	1c 38       	cp.w	r8,lr
8000b6f0:	fe 9b ff f9 	brhi	8000b6e2 <__mdiff+0x1e>
8000b6f4:	c4 98       	rjmp	8000b786 <__mdiff+0xc2>
8000b6f6:	58 05       	cp.w	r5,0
8000b6f8:	c0 64       	brge	8000b704 <__mdiff+0x40>
8000b6fa:	0e 98       	mov	r8,r7
8000b6fc:	30 15       	mov	r5,1
8000b6fe:	0c 97       	mov	r7,r6
8000b700:	10 96       	mov	r6,r8
8000b702:	c0 28       	rjmp	8000b706 <__mdiff+0x42>
8000b704:	30 05       	mov	r5,0
8000b706:	6e 1b       	ld.w	r11,r7[0x4]
8000b708:	c5 6f       	rcall	8000b5b4 <_Balloc>
8000b70a:	6e 49       	ld.w	r9,r7[0x10]
8000b70c:	6c 44       	ld.w	r4,r6[0x10]
8000b70e:	99 35       	st.w	r12[0xc],r5
8000b710:	2f b4       	sub	r4,-5
8000b712:	f2 c5 ff fb 	sub	r5,r9,-5
8000b716:	ec 04 00 24 	add	r4,r6,r4<<0x2
8000b71a:	ee 05 00 25 	add	r5,r7,r5<<0x2
8000b71e:	2e c6       	sub	r6,-20
8000b720:	2e c7       	sub	r7,-20
8000b722:	f8 c8 ff ec 	sub	r8,r12,-20
8000b726:	30 0a       	mov	r10,0
8000b728:	0f 0e       	ld.w	lr,r7++
8000b72a:	0d 0b       	ld.w	r11,r6++
8000b72c:	fc 02 16 10 	lsr	r2,lr,0x10
8000b730:	f6 03 16 10 	lsr	r3,r11,0x10
8000b734:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000b738:	e4 03 01 03 	sub	r3,r2,r3
8000b73c:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000b740:	fc 0b 01 0b 	sub	r11,lr,r11
8000b744:	f6 0a 00 0a 	add	r10,r11,r10
8000b748:	b0 1a       	st.h	r8[0x2],r10
8000b74a:	b1 4a       	asr	r10,0x10
8000b74c:	e6 0a 00 0a 	add	r10,r3,r10
8000b750:	b0 0a       	st.h	r8[0x0],r10
8000b752:	2f c8       	sub	r8,-4
8000b754:	b1 4a       	asr	r10,0x10
8000b756:	08 36       	cp.w	r6,r4
8000b758:	ce 83       	brcs	8000b728 <__mdiff+0x64>
8000b75a:	c0 d8       	rjmp	8000b774 <__mdiff+0xb0>
8000b75c:	0f 0b       	ld.w	r11,r7++
8000b75e:	f6 0e 16 10 	lsr	lr,r11,0x10
8000b762:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000b766:	16 0a       	add	r10,r11
8000b768:	b0 1a       	st.h	r8[0x2],r10
8000b76a:	b1 4a       	asr	r10,0x10
8000b76c:	1c 0a       	add	r10,lr
8000b76e:	b0 0a       	st.h	r8[0x0],r10
8000b770:	2f c8       	sub	r8,-4
8000b772:	b1 4a       	asr	r10,0x10
8000b774:	0a 37       	cp.w	r7,r5
8000b776:	cf 33       	brcs	8000b75c <__mdiff+0x98>
8000b778:	c0 28       	rjmp	8000b77c <__mdiff+0xb8>
8000b77a:	20 19       	sub	r9,1
8000b77c:	11 4a       	ld.w	r10,--r8
8000b77e:	58 0a       	cp.w	r10,0
8000b780:	cf d0       	breq	8000b77a <__mdiff+0xb6>
8000b782:	99 49       	st.w	r12[0x10],r9
8000b784:	d8 32       	popm	r0-r7,pc
8000b786:	30 0b       	mov	r11,0
8000b788:	c1 6f       	rcall	8000b5b4 <_Balloc>
8000b78a:	30 18       	mov	r8,1
8000b78c:	99 48       	st.w	r12[0x10],r8
8000b78e:	30 08       	mov	r8,0
8000b790:	99 58       	st.w	r12[0x14],r8
8000b792:	d8 32       	popm	r0-r7,pc

8000b794 <__lshift>:
8000b794:	d4 31       	pushm	r0-r7,lr
8000b796:	16 97       	mov	r7,r11
8000b798:	76 46       	ld.w	r6,r11[0x10]
8000b79a:	f4 02 14 05 	asr	r2,r10,0x5
8000b79e:	2f f6       	sub	r6,-1
8000b7a0:	14 93       	mov	r3,r10
8000b7a2:	18 94       	mov	r4,r12
8000b7a4:	04 06       	add	r6,r2
8000b7a6:	76 1b       	ld.w	r11,r11[0x4]
8000b7a8:	6e 28       	ld.w	r8,r7[0x8]
8000b7aa:	c0 38       	rjmp	8000b7b0 <__lshift+0x1c>
8000b7ac:	2f fb       	sub	r11,-1
8000b7ae:	a1 78       	lsl	r8,0x1
8000b7b0:	10 36       	cp.w	r6,r8
8000b7b2:	fe 99 ff fd 	brgt	8000b7ac <__lshift+0x18>
8000b7b6:	08 9c       	mov	r12,r4
8000b7b8:	cf ee       	rcall	8000b5b4 <_Balloc>
8000b7ba:	30 09       	mov	r9,0
8000b7bc:	18 95       	mov	r5,r12
8000b7be:	f8 c8 ff ec 	sub	r8,r12,-20
8000b7c2:	12 9a       	mov	r10,r9
8000b7c4:	c0 38       	rjmp	8000b7ca <__lshift+0x36>
8000b7c6:	10 aa       	st.w	r8++,r10
8000b7c8:	2f f9       	sub	r9,-1
8000b7ca:	04 39       	cp.w	r9,r2
8000b7cc:	cf d5       	brlt	8000b7c6 <__lshift+0x32>
8000b7ce:	6e 4b       	ld.w	r11,r7[0x10]
8000b7d0:	e7 d3 c0 05 	bfextu	r3,r3,0x0,0x5
8000b7d4:	2f bb       	sub	r11,-5
8000b7d6:	ee c9 ff ec 	sub	r9,r7,-20
8000b7da:	ee 0b 00 2b 	add	r11,r7,r11<<0x2
8000b7de:	58 03       	cp.w	r3,0
8000b7e0:	c1 30       	breq	8000b806 <__lshift+0x72>
8000b7e2:	e6 0c 11 20 	rsub	r12,r3,32
8000b7e6:	30 0a       	mov	r10,0
8000b7e8:	72 02       	ld.w	r2,r9[0x0]
8000b7ea:	e4 03 09 42 	lsl	r2,r2,r3
8000b7ee:	04 4a       	or	r10,r2
8000b7f0:	10 aa       	st.w	r8++,r10
8000b7f2:	13 0a       	ld.w	r10,r9++
8000b7f4:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000b7f8:	16 39       	cp.w	r9,r11
8000b7fa:	cf 73       	brcs	8000b7e8 <__lshift+0x54>
8000b7fc:	91 0a       	st.w	r8[0x0],r10
8000b7fe:	58 0a       	cp.w	r10,0
8000b800:	c0 70       	breq	8000b80e <__lshift+0x7a>
8000b802:	2f f6       	sub	r6,-1
8000b804:	c0 58       	rjmp	8000b80e <__lshift+0x7a>
8000b806:	13 0a       	ld.w	r10,r9++
8000b808:	10 aa       	st.w	r8++,r10
8000b80a:	16 39       	cp.w	r9,r11
8000b80c:	cf d3       	brcs	8000b806 <__lshift+0x72>
8000b80e:	08 9c       	mov	r12,r4
8000b810:	20 16       	sub	r6,1
8000b812:	0e 9b       	mov	r11,r7
8000b814:	8b 46       	st.w	r5[0x10],r6
8000b816:	cb 5e       	rcall	8000b580 <_Bfree>
8000b818:	0a 9c       	mov	r12,r5
8000b81a:	d8 32       	popm	r0-r7,pc

8000b81c <__multiply>:
8000b81c:	d4 31       	pushm	r0-r7,lr
8000b81e:	20 2d       	sub	sp,8
8000b820:	76 49       	ld.w	r9,r11[0x10]
8000b822:	74 48       	ld.w	r8,r10[0x10]
8000b824:	16 96       	mov	r6,r11
8000b826:	14 95       	mov	r5,r10
8000b828:	10 39       	cp.w	r9,r8
8000b82a:	ec 08 17 50 	movlt	r8,r6
8000b82e:	ea 06 17 50 	movlt	r6,r5
8000b832:	f0 05 17 50 	movlt	r5,r8
8000b836:	6c 28       	ld.w	r8,r6[0x8]
8000b838:	76 43       	ld.w	r3,r11[0x10]
8000b83a:	74 42       	ld.w	r2,r10[0x10]
8000b83c:	76 1b       	ld.w	r11,r11[0x4]
8000b83e:	e4 03 00 07 	add	r7,r2,r3
8000b842:	10 37       	cp.w	r7,r8
8000b844:	f7 bb 09 ff 	subgt	r11,-1
8000b848:	cb 6e       	rcall	8000b5b4 <_Balloc>
8000b84a:	ee c4 ff fb 	sub	r4,r7,-5
8000b84e:	f8 c9 ff ec 	sub	r9,r12,-20
8000b852:	f8 04 00 24 	add	r4,r12,r4<<0x2
8000b856:	30 0a       	mov	r10,0
8000b858:	12 98       	mov	r8,r9
8000b85a:	c0 28       	rjmp	8000b85e <__multiply+0x42>
8000b85c:	10 aa       	st.w	r8++,r10
8000b85e:	08 38       	cp.w	r8,r4
8000b860:	cf e3       	brcs	8000b85c <__multiply+0x40>
8000b862:	2f b3       	sub	r3,-5
8000b864:	2f b2       	sub	r2,-5
8000b866:	ec 03 00 23 	add	r3,r6,r3<<0x2
8000b86a:	ea 02 00 22 	add	r2,r5,r2<<0x2
8000b86e:	ec cb ff ec 	sub	r11,r6,-20
8000b872:	50 12       	stdsp	sp[0x4],r2
8000b874:	ea ca ff ec 	sub	r10,r5,-20
8000b878:	c4 48       	rjmp	8000b900 <__multiply+0xe4>
8000b87a:	94 95       	ld.uh	r5,r10[0x2]
8000b87c:	58 05       	cp.w	r5,0
8000b87e:	c2 00       	breq	8000b8be <__multiply+0xa2>
8000b880:	12 98       	mov	r8,r9
8000b882:	16 96       	mov	r6,r11
8000b884:	30 0e       	mov	lr,0
8000b886:	50 09       	stdsp	sp[0x0],r9
8000b888:	0d 02       	ld.w	r2,r6++
8000b88a:	e4 00 16 10 	lsr	r0,r2,0x10
8000b88e:	70 01       	ld.w	r1,r8[0x0]
8000b890:	70 09       	ld.w	r9,r8[0x0]
8000b892:	b1 81       	lsr	r1,0x10
8000b894:	e5 d2 c0 10 	bfextu	r2,r2,0x0,0x10
8000b898:	e0 05 03 41 	mac	r1,r0,r5
8000b89c:	ab 32       	mul	r2,r5
8000b89e:	e1 d9 c0 10 	bfextu	r0,r9,0x0,0x10
8000b8a2:	00 02       	add	r2,r0
8000b8a4:	e4 0e 00 0e 	add	lr,r2,lr
8000b8a8:	b0 1e       	st.h	r8[0x2],lr
8000b8aa:	b1 8e       	lsr	lr,0x10
8000b8ac:	1c 01       	add	r1,lr
8000b8ae:	b0 01       	st.h	r8[0x0],r1
8000b8b0:	e2 0e 16 10 	lsr	lr,r1,0x10
8000b8b4:	2f c8       	sub	r8,-4
8000b8b6:	06 36       	cp.w	r6,r3
8000b8b8:	ce 83       	brcs	8000b888 <__multiply+0x6c>
8000b8ba:	40 09       	lddsp	r9,sp[0x0]
8000b8bc:	91 0e       	st.w	r8[0x0],lr
8000b8be:	94 86       	ld.uh	r6,r10[0x0]
8000b8c0:	58 06       	cp.w	r6,0
8000b8c2:	c1 d0       	breq	8000b8fc <__multiply+0xe0>
8000b8c4:	72 02       	ld.w	r2,r9[0x0]
8000b8c6:	12 98       	mov	r8,r9
8000b8c8:	16 9e       	mov	lr,r11
8000b8ca:	30 05       	mov	r5,0
8000b8cc:	b0 12       	st.h	r8[0x2],r2
8000b8ce:	1d 01       	ld.w	r1,lr++
8000b8d0:	90 82       	ld.uh	r2,r8[0x0]
8000b8d2:	e1 d1 c0 10 	bfextu	r0,r1,0x0,0x10
8000b8d6:	ad 30       	mul	r0,r6
8000b8d8:	e0 02 00 02 	add	r2,r0,r2
8000b8dc:	e4 05 00 05 	add	r5,r2,r5
8000b8e0:	b0 05       	st.h	r8[0x0],r5
8000b8e2:	b1 85       	lsr	r5,0x10
8000b8e4:	b1 81       	lsr	r1,0x10
8000b8e6:	2f c8       	sub	r8,-4
8000b8e8:	ad 31       	mul	r1,r6
8000b8ea:	90 92       	ld.uh	r2,r8[0x2]
8000b8ec:	e2 02 00 02 	add	r2,r1,r2
8000b8f0:	0a 02       	add	r2,r5
8000b8f2:	e4 05 16 10 	lsr	r5,r2,0x10
8000b8f6:	06 3e       	cp.w	lr,r3
8000b8f8:	ce a3       	brcs	8000b8cc <__multiply+0xb0>
8000b8fa:	91 02       	st.w	r8[0x0],r2
8000b8fc:	2f ca       	sub	r10,-4
8000b8fe:	2f c9       	sub	r9,-4
8000b900:	40 18       	lddsp	r8,sp[0x4]
8000b902:	10 3a       	cp.w	r10,r8
8000b904:	cb b3       	brcs	8000b87a <__multiply+0x5e>
8000b906:	c0 28       	rjmp	8000b90a <__multiply+0xee>
8000b908:	20 17       	sub	r7,1
8000b90a:	58 07       	cp.w	r7,0
8000b90c:	e0 8a 00 05 	brle	8000b916 <__multiply+0xfa>
8000b910:	09 48       	ld.w	r8,--r4
8000b912:	58 08       	cp.w	r8,0
8000b914:	cf a0       	breq	8000b908 <__multiply+0xec>
8000b916:	99 47       	st.w	r12[0x10],r7
8000b918:	2f ed       	sub	sp,-8
8000b91a:	d8 32       	popm	r0-r7,pc

8000b91c <__i2b>:
8000b91c:	d4 21       	pushm	r4-r7,lr
8000b91e:	16 97       	mov	r7,r11
8000b920:	30 1b       	mov	r11,1
8000b922:	c4 9e       	rcall	8000b5b4 <_Balloc>
8000b924:	30 19       	mov	r9,1
8000b926:	99 57       	st.w	r12[0x14],r7
8000b928:	99 49       	st.w	r12[0x10],r9
8000b92a:	d8 22       	popm	r4-r7,pc

8000b92c <__multadd>:
8000b92c:	d4 31       	pushm	r0-r7,lr
8000b92e:	30 08       	mov	r8,0
8000b930:	12 95       	mov	r5,r9
8000b932:	16 97       	mov	r7,r11
8000b934:	18 96       	mov	r6,r12
8000b936:	76 44       	ld.w	r4,r11[0x10]
8000b938:	f6 c9 ff ec 	sub	r9,r11,-20
8000b93c:	72 0b       	ld.w	r11,r9[0x0]
8000b93e:	f6 0c 16 10 	lsr	r12,r11,0x10
8000b942:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000b946:	f4 0c 02 4c 	mul	r12,r10,r12
8000b94a:	f4 0b 03 45 	mac	r5,r10,r11
8000b94e:	f7 d5 c0 10 	bfextu	r11,r5,0x0,0x10
8000b952:	b1 85       	lsr	r5,0x10
8000b954:	18 05       	add	r5,r12
8000b956:	ea 0c 15 10 	lsl	r12,r5,0x10
8000b95a:	f8 0b 00 0b 	add	r11,r12,r11
8000b95e:	12 ab       	st.w	r9++,r11
8000b960:	2f f8       	sub	r8,-1
8000b962:	b1 85       	lsr	r5,0x10
8000b964:	08 38       	cp.w	r8,r4
8000b966:	ce b5       	brlt	8000b93c <__multadd+0x10>
8000b968:	58 05       	cp.w	r5,0
8000b96a:	c1 c0       	breq	8000b9a2 <__multadd+0x76>
8000b96c:	6e 28       	ld.w	r8,r7[0x8]
8000b96e:	10 34       	cp.w	r4,r8
8000b970:	c1 35       	brlt	8000b996 <__multadd+0x6a>
8000b972:	6e 1b       	ld.w	r11,r7[0x4]
8000b974:	0c 9c       	mov	r12,r6
8000b976:	2f fb       	sub	r11,-1
8000b978:	c1 ee       	rcall	8000b5b4 <_Balloc>
8000b97a:	6e 4a       	ld.w	r10,r7[0x10]
8000b97c:	ee cb ff f4 	sub	r11,r7,-12
8000b980:	18 93       	mov	r3,r12
8000b982:	2f ea       	sub	r10,-2
8000b984:	2f 4c       	sub	r12,-12
8000b986:	a3 6a       	lsl	r10,0x2
8000b988:	fe b0 de 70 	rcall	80007668 <memcpy>
8000b98c:	0e 9b       	mov	r11,r7
8000b98e:	0c 9c       	mov	r12,r6
8000b990:	fe b0 fd f8 	rcall	8000b580 <_Bfree>
8000b994:	06 97       	mov	r7,r3
8000b996:	e8 c8 ff ff 	sub	r8,r4,-1
8000b99a:	2f b4       	sub	r4,-5
8000b99c:	8f 48       	st.w	r7[0x10],r8
8000b99e:	ee 04 09 25 	st.w	r7[r4<<0x2],r5
8000b9a2:	0e 9c       	mov	r12,r7
8000b9a4:	d8 32       	popm	r0-r7,pc
8000b9a6:	d7 03       	nop

8000b9a8 <__pow5mult>:
8000b9a8:	d4 31       	pushm	r0-r7,lr
8000b9aa:	14 96       	mov	r6,r10
8000b9ac:	18 97       	mov	r7,r12
8000b9ae:	16 94       	mov	r4,r11
8000b9b0:	f1 da c0 02 	bfextu	r8,r10,0x0,0x2
8000b9b4:	c0 90       	breq	8000b9c6 <__pow5mult+0x1e>
8000b9b6:	20 18       	sub	r8,1
8000b9b8:	fe c9 da 00 	sub	r9,pc,-9728
8000b9bc:	f2 08 03 2a 	ld.w	r10,r9[r8<<0x2]
8000b9c0:	30 09       	mov	r9,0
8000b9c2:	cb 5f       	rcall	8000b92c <__multadd>
8000b9c4:	18 94       	mov	r4,r12
8000b9c6:	a3 46       	asr	r6,0x2
8000b9c8:	c3 40       	breq	8000ba30 <__pow5mult+0x88>
8000b9ca:	6e 95       	ld.w	r5,r7[0x24]
8000b9cc:	58 05       	cp.w	r5,0
8000b9ce:	c0 91       	brne	8000b9e0 <__pow5mult+0x38>
8000b9d0:	31 0c       	mov	r12,16
8000b9d2:	fe b0 dc 27 	rcall	80007220 <malloc>
8000b9d6:	99 35       	st.w	r12[0xc],r5
8000b9d8:	8f 9c       	st.w	r7[0x24],r12
8000b9da:	99 15       	st.w	r12[0x4],r5
8000b9dc:	99 25       	st.w	r12[0x8],r5
8000b9de:	99 05       	st.w	r12[0x0],r5
8000b9e0:	6e 93       	ld.w	r3,r7[0x24]
8000b9e2:	66 25       	ld.w	r5,r3[0x8]
8000b9e4:	58 05       	cp.w	r5,0
8000b9e6:	c0 c1       	brne	8000b9fe <__pow5mult+0x56>
8000b9e8:	e0 6b 02 71 	mov	r11,625
8000b9ec:	0e 9c       	mov	r12,r7
8000b9ee:	c9 7f       	rcall	8000b91c <__i2b>
8000b9f0:	87 2c       	st.w	r3[0x8],r12
8000b9f2:	30 08       	mov	r8,0
8000b9f4:	18 95       	mov	r5,r12
8000b9f6:	99 08       	st.w	r12[0x0],r8
8000b9f8:	c0 38       	rjmp	8000b9fe <__pow5mult+0x56>
8000b9fa:	06 9c       	mov	r12,r3
8000b9fc:	18 95       	mov	r5,r12
8000b9fe:	ed b6 00 00 	bld	r6,0x0
8000ba02:	c0 b1       	brne	8000ba18 <__pow5mult+0x70>
8000ba04:	08 9b       	mov	r11,r4
8000ba06:	0a 9a       	mov	r10,r5
8000ba08:	0e 9c       	mov	r12,r7
8000ba0a:	c0 9f       	rcall	8000b81c <__multiply>
8000ba0c:	08 9b       	mov	r11,r4
8000ba0e:	18 93       	mov	r3,r12
8000ba10:	0e 9c       	mov	r12,r7
8000ba12:	06 94       	mov	r4,r3
8000ba14:	fe b0 fd b6 	rcall	8000b580 <_Bfree>
8000ba18:	a1 56       	asr	r6,0x1
8000ba1a:	c0 b0       	breq	8000ba30 <__pow5mult+0x88>
8000ba1c:	6a 03       	ld.w	r3,r5[0x0]
8000ba1e:	58 03       	cp.w	r3,0
8000ba20:	ce d1       	brne	8000b9fa <__pow5mult+0x52>
8000ba22:	0a 9a       	mov	r10,r5
8000ba24:	0a 9b       	mov	r11,r5
8000ba26:	0e 9c       	mov	r12,r7
8000ba28:	cf ae       	rcall	8000b81c <__multiply>
8000ba2a:	8b 0c       	st.w	r5[0x0],r12
8000ba2c:	99 03       	st.w	r12[0x0],r3
8000ba2e:	ce 7b       	rjmp	8000b9fc <__pow5mult+0x54>
8000ba30:	08 9c       	mov	r12,r4
8000ba32:	d8 32       	popm	r0-r7,pc

8000ba34 <__isinfd>:
8000ba34:	14 98       	mov	r8,r10
8000ba36:	fc 19 7f f0 	movh	r9,0x7ff0
8000ba3a:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000ba3e:	f0 0b 11 00 	rsub	r11,r8,0
8000ba42:	f7 e8 10 08 	or	r8,r11,r8
8000ba46:	f5 e8 13 f8 	or	r8,r10,r8>>0x1f
8000ba4a:	f2 08 01 08 	sub	r8,r9,r8
8000ba4e:	f0 0c 11 00 	rsub	r12,r8,0
8000ba52:	f9 e8 10 08 	or	r8,r12,r8
8000ba56:	f0 0c 14 1f 	asr	r12,r8,0x1f
8000ba5a:	2f fc       	sub	r12,-1
8000ba5c:	5e fc       	retal	r12

8000ba5e <__isnand>:
8000ba5e:	14 98       	mov	r8,r10
8000ba60:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000ba64:	f0 0c 11 00 	rsub	r12,r8,0
8000ba68:	10 4c       	or	r12,r8
8000ba6a:	fc 18 7f f0 	movh	r8,0x7ff0
8000ba6e:	f5 ec 13 fc 	or	r12,r10,r12>>0x1f
8000ba72:	f0 0c 01 0c 	sub	r12,r8,r12
8000ba76:	bf 9c       	lsr	r12,0x1f
8000ba78:	5e fc       	retal	r12
8000ba7a:	d7 03       	nop

8000ba7c <__sclose>:
8000ba7c:	d4 01       	pushm	lr
8000ba7e:	96 7b       	ld.sh	r11,r11[0xe]
8000ba80:	c8 2c       	rcall	8000bb84 <_close_r>
8000ba82:	d8 02       	popm	pc

8000ba84 <__sseek>:
8000ba84:	d4 21       	pushm	r4-r7,lr
8000ba86:	16 97       	mov	r7,r11
8000ba88:	96 7b       	ld.sh	r11,r11[0xe]
8000ba8a:	c0 3d       	rcall	8000bc90 <_lseek_r>
8000ba8c:	8e 68       	ld.sh	r8,r7[0xc]
8000ba8e:	10 99       	mov	r9,r8
8000ba90:	ad c8       	cbr	r8,0xc
8000ba92:	ad a9       	sbr	r9,0xc
8000ba94:	5b fc       	cp.w	r12,-1
8000ba96:	ef f8 0c 06 	st.heq	r7[0xc],r8
8000ba9a:	ef f9 1c 06 	st.hne	r7[0xc],r9
8000ba9e:	ef fc 1a 15 	st.wne	r7[0x54],r12
8000baa2:	d8 22       	popm	r4-r7,pc

8000baa4 <__swrite>:
8000baa4:	d4 21       	pushm	r4-r7,lr
8000baa6:	96 68       	ld.sh	r8,r11[0xc]
8000baa8:	16 97       	mov	r7,r11
8000baaa:	14 95       	mov	r5,r10
8000baac:	12 94       	mov	r4,r9
8000baae:	e2 18 01 00 	andl	r8,0x100,COH
8000bab2:	18 96       	mov	r6,r12
8000bab4:	c0 50       	breq	8000babe <__swrite+0x1a>
8000bab6:	30 29       	mov	r9,2
8000bab8:	30 0a       	mov	r10,0
8000baba:	96 7b       	ld.sh	r11,r11[0xe]
8000babc:	ce ac       	rcall	8000bc90 <_lseek_r>
8000babe:	8e 68       	ld.sh	r8,r7[0xc]
8000bac0:	ad c8       	cbr	r8,0xc
8000bac2:	08 99       	mov	r9,r4
8000bac4:	0a 9a       	mov	r10,r5
8000bac6:	8e 7b       	ld.sh	r11,r7[0xe]
8000bac8:	0c 9c       	mov	r12,r6
8000baca:	ae 68       	st.h	r7[0xc],r8
8000bacc:	c1 cc       	rcall	8000bb04 <_write_r>
8000bace:	d8 22       	popm	r4-r7,pc

8000bad0 <__sread>:
8000bad0:	d4 21       	pushm	r4-r7,lr
8000bad2:	16 97       	mov	r7,r11
8000bad4:	96 7b       	ld.sh	r11,r11[0xe]
8000bad6:	cf 1c       	rcall	8000bcb8 <_read_r>
8000bad8:	c0 65       	brlt	8000bae4 <__sread+0x14>
8000bada:	6f 58       	ld.w	r8,r7[0x54]
8000badc:	18 08       	add	r8,r12
8000bade:	ef 48 00 54 	st.w	r7[84],r8
8000bae2:	d8 22       	popm	r4-r7,pc
8000bae4:	8e 68       	ld.sh	r8,r7[0xc]
8000bae6:	ad c8       	cbr	r8,0xc
8000bae8:	ae 68       	st.h	r7[0xc],r8
8000baea:	d8 22       	popm	r4-r7,pc

8000baec <strlen>:
8000baec:	30 09       	mov	r9,0
8000baee:	18 98       	mov	r8,r12
8000baf0:	c0 28       	rjmp	8000baf4 <strlen+0x8>
8000baf2:	2f f8       	sub	r8,-1
8000baf4:	11 8a       	ld.ub	r10,r8[0x0]
8000baf6:	f2 0a 18 00 	cp.b	r10,r9
8000bafa:	cf c1       	brne	8000baf2 <strlen+0x6>
8000bafc:	f0 0c 01 0c 	sub	r12,r8,r12
8000bb00:	5e fc       	retal	r12
8000bb02:	d7 03       	nop

8000bb04 <_write_r>:
8000bb04:	d4 21       	pushm	r4-r7,lr
8000bb06:	16 98       	mov	r8,r11
8000bb08:	18 97       	mov	r7,r12
8000bb0a:	10 9c       	mov	r12,r8
8000bb0c:	30 08       	mov	r8,0
8000bb0e:	14 9b       	mov	r11,r10
8000bb10:	e0 66 bf f0 	mov	r6,49136
8000bb14:	12 9a       	mov	r10,r9
8000bb16:	8d 08       	st.w	r6[0x0],r8
8000bb18:	fe b0 d1 72 	rcall	80005dfc <_write>
8000bb1c:	5b fc       	cp.w	r12,-1
8000bb1e:	c0 51       	brne	8000bb28 <_write_r+0x24>
8000bb20:	6c 08       	ld.w	r8,r6[0x0]
8000bb22:	58 08       	cp.w	r8,0
8000bb24:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000bb28:	d8 22       	popm	r4-r7,pc
8000bb2a:	d7 03       	nop

8000bb2c <_calloc_r>:
8000bb2c:	d4 21       	pushm	r4-r7,lr
8000bb2e:	f4 0b 02 4b 	mul	r11,r10,r11
8000bb32:	fe b0 db 7f 	rcall	80007230 <_malloc_r>
8000bb36:	18 97       	mov	r7,r12
8000bb38:	c2 30       	breq	8000bb7e <_calloc_r+0x52>
8000bb3a:	f8 fa ff fc 	ld.w	r10,r12[-4]
8000bb3e:	e0 1a ff fc 	andl	r10,0xfffc
8000bb42:	20 4a       	sub	r10,4
8000bb44:	e0 4a 00 24 	cp.w	r10,36
8000bb48:	e0 8b 00 18 	brhi	8000bb78 <_calloc_r+0x4c>
8000bb4c:	18 98       	mov	r8,r12
8000bb4e:	59 3a       	cp.w	r10,19
8000bb50:	e0 88 00 0f 	brls	8000bb6e <_calloc_r+0x42>
8000bb54:	30 09       	mov	r9,0
8000bb56:	10 a9       	st.w	r8++,r9
8000bb58:	10 a9       	st.w	r8++,r9
8000bb5a:	59 ba       	cp.w	r10,27
8000bb5c:	e0 88 00 09 	brls	8000bb6e <_calloc_r+0x42>
8000bb60:	10 a9       	st.w	r8++,r9
8000bb62:	10 a9       	st.w	r8++,r9
8000bb64:	e0 4a 00 24 	cp.w	r10,36
8000bb68:	c0 31       	brne	8000bb6e <_calloc_r+0x42>
8000bb6a:	10 a9       	st.w	r8++,r9
8000bb6c:	10 a9       	st.w	r8++,r9
8000bb6e:	30 09       	mov	r9,0
8000bb70:	10 a9       	st.w	r8++,r9
8000bb72:	91 19       	st.w	r8[0x4],r9
8000bb74:	91 09       	st.w	r8[0x0],r9
8000bb76:	c0 48       	rjmp	8000bb7e <_calloc_r+0x52>
8000bb78:	30 0b       	mov	r11,0
8000bb7a:	fe b0 de 1b 	rcall	800077b0 <memset>
8000bb7e:	0e 9c       	mov	r12,r7
8000bb80:	d8 22       	popm	r4-r7,pc
8000bb82:	d7 03       	nop

8000bb84 <_close_r>:
8000bb84:	d4 21       	pushm	r4-r7,lr
8000bb86:	30 08       	mov	r8,0
8000bb88:	18 97       	mov	r7,r12
8000bb8a:	e0 66 bf f0 	mov	r6,49136
8000bb8e:	16 9c       	mov	r12,r11
8000bb90:	8d 08       	st.w	r6[0x0],r8
8000bb92:	fe b0 df b5 	rcall	80007afc <_close>
8000bb96:	5b fc       	cp.w	r12,-1
8000bb98:	c0 51       	brne	8000bba2 <_close_r+0x1e>
8000bb9a:	6c 08       	ld.w	r8,r6[0x0]
8000bb9c:	58 08       	cp.w	r8,0
8000bb9e:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000bba2:	d8 22       	popm	r4-r7,pc

8000bba4 <_fclose_r>:
8000bba4:	d4 21       	pushm	r4-r7,lr
8000bba6:	18 96       	mov	r6,r12
8000bba8:	16 97       	mov	r7,r11
8000bbaa:	58 0b       	cp.w	r11,0
8000bbac:	c0 31       	brne	8000bbb2 <_fclose_r+0xe>
8000bbae:	16 95       	mov	r5,r11
8000bbb0:	c5 38       	rjmp	8000bc56 <_fclose_r+0xb2>
8000bbb2:	fe b0 f8 a9 	rcall	8000ad04 <__sfp_lock_acquire>
8000bbb6:	58 06       	cp.w	r6,0
8000bbb8:	c0 70       	breq	8000bbc6 <_fclose_r+0x22>
8000bbba:	6c 68       	ld.w	r8,r6[0x18]
8000bbbc:	58 08       	cp.w	r8,0
8000bbbe:	c0 41       	brne	8000bbc6 <_fclose_r+0x22>
8000bbc0:	0c 9c       	mov	r12,r6
8000bbc2:	fe b0 f8 f3 	rcall	8000ada8 <__sinit>
8000bbc6:	fe c8 dc b2 	sub	r8,pc,-9038
8000bbca:	10 37       	cp.w	r7,r8
8000bbcc:	c0 31       	brne	8000bbd2 <_fclose_r+0x2e>
8000bbce:	6c 07       	ld.w	r7,r6[0x0]
8000bbd0:	c0 c8       	rjmp	8000bbe8 <_fclose_r+0x44>
8000bbd2:	fe c8 dc 9e 	sub	r8,pc,-9058
8000bbd6:	10 37       	cp.w	r7,r8
8000bbd8:	c0 31       	brne	8000bbde <_fclose_r+0x3a>
8000bbda:	6c 17       	ld.w	r7,r6[0x4]
8000bbdc:	c0 68       	rjmp	8000bbe8 <_fclose_r+0x44>
8000bbde:	fe c8 dc 8a 	sub	r8,pc,-9078
8000bbe2:	10 37       	cp.w	r7,r8
8000bbe4:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000bbe8:	8e 69       	ld.sh	r9,r7[0xc]
8000bbea:	30 08       	mov	r8,0
8000bbec:	f0 09 19 00 	cp.h	r9,r8
8000bbf0:	c0 51       	brne	8000bbfa <_fclose_r+0x56>
8000bbf2:	fe b0 f8 8a 	rcall	8000ad06 <__sfp_lock_release>
8000bbf6:	30 05       	mov	r5,0
8000bbf8:	c2 f8       	rjmp	8000bc56 <_fclose_r+0xb2>
8000bbfa:	0e 9b       	mov	r11,r7
8000bbfc:	0c 9c       	mov	r12,r6
8000bbfe:	fe b0 f7 fd 	rcall	8000abf8 <_fflush_r>
8000bc02:	6e c8       	ld.w	r8,r7[0x30]
8000bc04:	18 95       	mov	r5,r12
8000bc06:	58 08       	cp.w	r8,0
8000bc08:	c0 60       	breq	8000bc14 <_fclose_r+0x70>
8000bc0a:	6e 8b       	ld.w	r11,r7[0x20]
8000bc0c:	0c 9c       	mov	r12,r6
8000bc0e:	5d 18       	icall	r8
8000bc10:	f9 b5 05 ff 	movlt	r5,-1
8000bc14:	8e 68       	ld.sh	r8,r7[0xc]
8000bc16:	ed b8 00 07 	bld	r8,0x7
8000bc1a:	c0 51       	brne	8000bc24 <_fclose_r+0x80>
8000bc1c:	6e 4b       	ld.w	r11,r7[0x10]
8000bc1e:	0c 9c       	mov	r12,r6
8000bc20:	fe b0 f9 5e 	rcall	8000aedc <_free_r>
8000bc24:	6e db       	ld.w	r11,r7[0x34]
8000bc26:	58 0b       	cp.w	r11,0
8000bc28:	c0 a0       	breq	8000bc3c <_fclose_r+0x98>
8000bc2a:	ee c8 ff bc 	sub	r8,r7,-68
8000bc2e:	10 3b       	cp.w	r11,r8
8000bc30:	c0 40       	breq	8000bc38 <_fclose_r+0x94>
8000bc32:	0c 9c       	mov	r12,r6
8000bc34:	fe b0 f9 54 	rcall	8000aedc <_free_r>
8000bc38:	30 08       	mov	r8,0
8000bc3a:	8f d8       	st.w	r7[0x34],r8
8000bc3c:	6f 2b       	ld.w	r11,r7[0x48]
8000bc3e:	58 0b       	cp.w	r11,0
8000bc40:	c0 70       	breq	8000bc4e <_fclose_r+0xaa>
8000bc42:	0c 9c       	mov	r12,r6
8000bc44:	fe b0 f9 4c 	rcall	8000aedc <_free_r>
8000bc48:	30 08       	mov	r8,0
8000bc4a:	ef 48 00 48 	st.w	r7[72],r8
8000bc4e:	30 08       	mov	r8,0
8000bc50:	ae 68       	st.h	r7[0xc],r8
8000bc52:	fe b0 f8 5a 	rcall	8000ad06 <__sfp_lock_release>
8000bc56:	0a 9c       	mov	r12,r5
8000bc58:	d8 22       	popm	r4-r7,pc
8000bc5a:	d7 03       	nop

8000bc5c <fclose>:
8000bc5c:	d4 01       	pushm	lr
8000bc5e:	e0 68 0a 3c 	mov	r8,2620
8000bc62:	18 9b       	mov	r11,r12
8000bc64:	70 0c       	ld.w	r12,r8[0x0]
8000bc66:	c9 ff       	rcall	8000bba4 <_fclose_r>
8000bc68:	d8 02       	popm	pc
8000bc6a:	d7 03       	nop

8000bc6c <_fstat_r>:
8000bc6c:	d4 21       	pushm	r4-r7,lr
8000bc6e:	16 98       	mov	r8,r11
8000bc70:	18 97       	mov	r7,r12
8000bc72:	10 9c       	mov	r12,r8
8000bc74:	30 08       	mov	r8,0
8000bc76:	e0 66 bf f0 	mov	r6,49136
8000bc7a:	14 9b       	mov	r11,r10
8000bc7c:	8d 08       	st.w	r6[0x0],r8
8000bc7e:	fe b0 df 67 	rcall	80007b4c <_fstat>
8000bc82:	5b fc       	cp.w	r12,-1
8000bc84:	c0 51       	brne	8000bc8e <_fstat_r+0x22>
8000bc86:	6c 08       	ld.w	r8,r6[0x0]
8000bc88:	58 08       	cp.w	r8,0
8000bc8a:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000bc8e:	d8 22       	popm	r4-r7,pc

8000bc90 <_lseek_r>:
8000bc90:	d4 21       	pushm	r4-r7,lr
8000bc92:	16 98       	mov	r8,r11
8000bc94:	18 97       	mov	r7,r12
8000bc96:	10 9c       	mov	r12,r8
8000bc98:	30 08       	mov	r8,0
8000bc9a:	14 9b       	mov	r11,r10
8000bc9c:	e0 66 bf f0 	mov	r6,49136
8000bca0:	12 9a       	mov	r10,r9
8000bca2:	8d 08       	st.w	r6[0x0],r8
8000bca4:	fe b0 df 36 	rcall	80007b10 <_lseek>
8000bca8:	5b fc       	cp.w	r12,-1
8000bcaa:	c0 51       	brne	8000bcb4 <_lseek_r+0x24>
8000bcac:	6c 08       	ld.w	r8,r6[0x0]
8000bcae:	58 08       	cp.w	r8,0
8000bcb0:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000bcb4:	d8 22       	popm	r4-r7,pc
8000bcb6:	d7 03       	nop

8000bcb8 <_read_r>:
8000bcb8:	d4 21       	pushm	r4-r7,lr
8000bcba:	16 98       	mov	r8,r11
8000bcbc:	18 97       	mov	r7,r12
8000bcbe:	10 9c       	mov	r12,r8
8000bcc0:	30 08       	mov	r8,0
8000bcc2:	14 9b       	mov	r11,r10
8000bcc4:	e0 66 bf f0 	mov	r6,49136
8000bcc8:	12 9a       	mov	r10,r9
8000bcca:	8d 08       	st.w	r6[0x0],r8
8000bccc:	fe b0 d0 78 	rcall	80005dbc <_read>
8000bcd0:	5b fc       	cp.w	r12,-1
8000bcd2:	c0 51       	brne	8000bcdc <_read_r+0x24>
8000bcd4:	6c 08       	ld.w	r8,r6[0x0]
8000bcd6:	58 08       	cp.w	r8,0
8000bcd8:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000bcdc:	d8 22       	popm	r4-r7,pc
8000bcde:	d7 03       	nop

8000bce0 <__avr32_f64_mul>:
8000bce0:	f5 eb 10 1c 	or	r12,r10,r11<<0x1
8000bce4:	e0 80 00 dc 	breq	8000be9c <__avr32_f64_mul_op1_zero>
8000bce8:	d4 21       	pushm	r4-r7,lr
8000bcea:	f7 e9 20 0e 	eor	lr,r11,r9
8000bcee:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000bcf2:	30 15       	mov	r5,1
8000bcf4:	c4 30       	breq	8000bd7a <__avr32_f64_mul_op1_subnormal>
8000bcf6:	ab 6b       	lsl	r11,0xa
8000bcf8:	f7 ea 13 6b 	or	r11,r11,r10>>0x16
8000bcfc:	ab 6a       	lsl	r10,0xa
8000bcfe:	f7 d5 d3 c2 	bfins	r11,r5,0x1e,0x2
8000bd02:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000bd06:	c5 c0       	breq	8000bdbe <__avr32_f64_mul_op2_subnormal>
8000bd08:	a1 78       	lsl	r8,0x1
8000bd0a:	5c f9       	rol	r9
8000bd0c:	f3 d5 d2 ab 	bfins	r9,r5,0x15,0xb
8000bd10:	e0 47 07 ff 	cp.w	r7,2047
8000bd14:	c7 70       	breq	8000be02 <__avr32_f64_mul_op_nan_or_inf>
8000bd16:	e0 46 07 ff 	cp.w	r6,2047
8000bd1a:	c7 40       	breq	8000be02 <__avr32_f64_mul_op_nan_or_inf>
8000bd1c:	ee 06 00 0c 	add	r12,r7,r6
8000bd20:	e0 2c 03 fe 	sub	r12,1022
8000bd24:	f6 08 06 44 	mulu.d	r4,r11,r8
8000bd28:	f4 09 07 44 	macu.d	r4,r10,r9
8000bd2c:	f4 08 06 46 	mulu.d	r6,r10,r8
8000bd30:	f6 09 06 4a 	mulu.d	r10,r11,r9
8000bd34:	08 07       	add	r7,r4
8000bd36:	f4 05 00 4a 	adc	r10,r10,r5
8000bd3a:	5c 0b       	acr	r11
8000bd3c:	ed bb 00 14 	bld	r11,0x14
8000bd40:	c0 50       	breq	8000bd4a <__avr32_f64_mul+0x6a>
8000bd42:	a1 77       	lsl	r7,0x1
8000bd44:	5c fa       	rol	r10
8000bd46:	5c fb       	rol	r11
8000bd48:	20 1c       	sub	r12,1
8000bd4a:	58 0c       	cp.w	r12,0
8000bd4c:	e0 8a 00 6f 	brle	8000be2a <__avr32_f64_mul_res_subnormal>
8000bd50:	e0 4c 07 ff 	cp.w	r12,2047
8000bd54:	e0 84 00 9c 	brge	8000be8c <__avr32_f64_mul_res_inf>
8000bd58:	f7 dc d2 8b 	bfins	r11,r12,0x14,0xb
8000bd5c:	ed ea 11 f6 	or	r6,r6,r10<<0x1f
8000bd60:	ef e6 12 17 	or	r7,r7,r6>>0x1
8000bd64:	ee 17 80 00 	eorh	r7,0x8000
8000bd68:	f1 b7 04 20 	satu	r7,0x1
8000bd6c:	0e 0a       	add	r10,r7
8000bd6e:	5c 0b       	acr	r11
8000bd70:	ed be 00 1f 	bld	lr,0x1f
8000bd74:	ef bb 00 1f 	bst	r11,0x1f
8000bd78:	d8 22       	popm	r4-r7,pc

8000bd7a <__avr32_f64_mul_op1_subnormal>:
8000bd7a:	e4 1b 00 0f 	andh	r11,0xf
8000bd7e:	f4 0c 12 00 	clz	r12,r10
8000bd82:	f6 06 12 00 	clz	r6,r11
8000bd86:	f7 bc 03 e1 	sublo	r12,-31
8000bd8a:	f8 06 17 30 	movlo	r6,r12
8000bd8e:	f7 b6 02 01 	subhs	r6,1
8000bd92:	e0 46 00 20 	cp.w	r6,32
8000bd96:	c0 d4       	brge	8000bdb0 <__avr32_f64_mul_op1_subnormal+0x36>
8000bd98:	ec 0c 11 20 	rsub	r12,r6,32
8000bd9c:	f6 06 09 4b 	lsl	r11,r11,r6
8000bda0:	f4 0c 0a 4c 	lsr	r12,r10,r12
8000bda4:	18 4b       	or	r11,r12
8000bda6:	f4 06 09 4a 	lsl	r10,r10,r6
8000bdaa:	20 b6       	sub	r6,11
8000bdac:	0c 17       	sub	r7,r6
8000bdae:	ca ab       	rjmp	8000bd02 <__avr32_f64_mul+0x22>
8000bdb0:	f4 06 09 4b 	lsl	r11,r10,r6
8000bdb4:	c6 40       	breq	8000be7c <__avr32_f64_mul_res_zero>
8000bdb6:	30 0a       	mov	r10,0
8000bdb8:	20 b6       	sub	r6,11
8000bdba:	0c 17       	sub	r7,r6
8000bdbc:	ca 3b       	rjmp	8000bd02 <__avr32_f64_mul+0x22>

8000bdbe <__avr32_f64_mul_op2_subnormal>:
8000bdbe:	e4 19 00 0f 	andh	r9,0xf
8000bdc2:	f0 0c 12 00 	clz	r12,r8
8000bdc6:	f2 05 12 00 	clz	r5,r9
8000bdca:	f7 bc 03 ea 	sublo	r12,-22
8000bdce:	f8 05 17 30 	movlo	r5,r12
8000bdd2:	f7 b5 02 0a 	subhs	r5,10
8000bdd6:	e0 45 00 20 	cp.w	r5,32
8000bdda:	c0 d4       	brge	8000bdf4 <__avr32_f64_mul_op2_subnormal+0x36>
8000bddc:	ea 0c 11 20 	rsub	r12,r5,32
8000bde0:	f2 05 09 49 	lsl	r9,r9,r5
8000bde4:	f0 0c 0a 4c 	lsr	r12,r8,r12
8000bde8:	18 49       	or	r9,r12
8000bdea:	f0 05 09 48 	lsl	r8,r8,r5
8000bdee:	20 25       	sub	r5,2
8000bdf0:	0a 16       	sub	r6,r5
8000bdf2:	c8 fb       	rjmp	8000bd10 <__avr32_f64_mul+0x30>
8000bdf4:	f0 05 09 49 	lsl	r9,r8,r5
8000bdf8:	c4 20       	breq	8000be7c <__avr32_f64_mul_res_zero>
8000bdfa:	30 08       	mov	r8,0
8000bdfc:	20 25       	sub	r5,2
8000bdfe:	0a 16       	sub	r6,r5
8000be00:	c8 8b       	rjmp	8000bd10 <__avr32_f64_mul+0x30>

8000be02 <__avr32_f64_mul_op_nan_or_inf>:
8000be02:	e4 19 00 0f 	andh	r9,0xf
8000be06:	e4 1b 00 0f 	andh	r11,0xf
8000be0a:	14 4b       	or	r11,r10
8000be0c:	10 49       	or	r9,r8
8000be0e:	e0 47 07 ff 	cp.w	r7,2047
8000be12:	c0 91       	brne	8000be24 <__avr32_f64_mul_op1_not_naninf>
8000be14:	58 0b       	cp.w	r11,0
8000be16:	c3 81       	brne	8000be86 <__avr32_f64_mul_res_nan>
8000be18:	e0 46 07 ff 	cp.w	r6,2047
8000be1c:	c3 81       	brne	8000be8c <__avr32_f64_mul_res_inf>
8000be1e:	58 09       	cp.w	r9,0
8000be20:	c3 60       	breq	8000be8c <__avr32_f64_mul_res_inf>
8000be22:	c3 28       	rjmp	8000be86 <__avr32_f64_mul_res_nan>

8000be24 <__avr32_f64_mul_op1_not_naninf>:
8000be24:	58 09       	cp.w	r9,0
8000be26:	c3 30       	breq	8000be8c <__avr32_f64_mul_res_inf>
8000be28:	c2 f8       	rjmp	8000be86 <__avr32_f64_mul_res_nan>

8000be2a <__avr32_f64_mul_res_subnormal>:
8000be2a:	5c 3c       	neg	r12
8000be2c:	2f fc       	sub	r12,-1
8000be2e:	f1 bc 04 c0 	satu	r12,0x6
8000be32:	e0 4c 00 20 	cp.w	r12,32
8000be36:	c1 14       	brge	8000be58 <__avr32_f64_mul_res_subnormal+0x2e>
8000be38:	f8 08 11 20 	rsub	r8,r12,32
8000be3c:	0e 46       	or	r6,r7
8000be3e:	ee 0c 0a 47 	lsr	r7,r7,r12
8000be42:	f4 08 09 49 	lsl	r9,r10,r8
8000be46:	12 47       	or	r7,r9
8000be48:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000be4c:	f6 08 09 49 	lsl	r9,r11,r8
8000be50:	12 4a       	or	r10,r9
8000be52:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000be56:	c8 3b       	rjmp	8000bd5c <__avr32_f64_mul+0x7c>
8000be58:	f8 08 11 20 	rsub	r8,r12,32
8000be5c:	f9 b9 00 00 	moveq	r9,0
8000be60:	c0 30       	breq	8000be66 <__avr32_f64_mul_res_subnormal+0x3c>
8000be62:	f6 08 09 49 	lsl	r9,r11,r8
8000be66:	0e 46       	or	r6,r7
8000be68:	ed ea 10 16 	or	r6,r6,r10<<0x1
8000be6c:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000be70:	f3 ea 10 07 	or	r7,r9,r10
8000be74:	f6 0c 0a 4a 	lsr	r10,r11,r12
8000be78:	30 0b       	mov	r11,0
8000be7a:	c7 1b       	rjmp	8000bd5c <__avr32_f64_mul+0x7c>

8000be7c <__avr32_f64_mul_res_zero>:
8000be7c:	1c 9b       	mov	r11,lr
8000be7e:	e6 1b 80 00 	andh	r11,0x8000,COH
8000be82:	30 0a       	mov	r10,0
8000be84:	d8 22       	popm	r4-r7,pc

8000be86 <__avr32_f64_mul_res_nan>:
8000be86:	3f fb       	mov	r11,-1
8000be88:	3f fa       	mov	r10,-1
8000be8a:	d8 22       	popm	r4-r7,pc

8000be8c <__avr32_f64_mul_res_inf>:
8000be8c:	f0 6b 00 00 	mov	r11,-1048576
8000be90:	ed be 00 1f 	bld	lr,0x1f
8000be94:	ef bb 00 1f 	bst	r11,0x1f
8000be98:	30 0a       	mov	r10,0
8000be9a:	d8 22       	popm	r4-r7,pc

8000be9c <__avr32_f64_mul_op1_zero>:
8000be9c:	f7 e9 20 0b 	eor	r11,r11,r9
8000bea0:	e6 1b 80 00 	andh	r11,0x8000,COH
8000bea4:	f9 d9 c2 8b 	bfextu	r12,r9,0x14,0xb
8000bea8:	e0 4c 07 ff 	cp.w	r12,2047
8000beac:	5e 1c       	retne	r12
8000beae:	3f fa       	mov	r10,-1
8000beb0:	3f fb       	mov	r11,-1
8000beb2:	5e fc       	retal	r12

8000beb4 <__avr32_f64_sub_from_add>:
8000beb4:	ee 19 80 00 	eorh	r9,0x8000

8000beb8 <__avr32_f64_sub>:
8000beb8:	f7 e9 20 0c 	eor	r12,r11,r9
8000bebc:	e0 86 00 ca 	brmi	8000c050 <__avr32_f64_add_from_sub>
8000bec0:	eb cd 40 e0 	pushm	r5-r7,lr
8000bec4:	16 9c       	mov	r12,r11
8000bec6:	e6 1c 80 00 	andh	r12,0x8000,COH
8000beca:	bf db       	cbr	r11,0x1f
8000becc:	bf d9       	cbr	r9,0x1f
8000bece:	10 3a       	cp.w	r10,r8
8000bed0:	f2 0b 13 00 	cpc	r11,r9
8000bed4:	c0 92       	brcc	8000bee6 <__avr32_f64_sub+0x2e>
8000bed6:	16 97       	mov	r7,r11
8000bed8:	12 9b       	mov	r11,r9
8000beda:	0e 99       	mov	r9,r7
8000bedc:	14 97       	mov	r7,r10
8000bede:	10 9a       	mov	r10,r8
8000bee0:	0e 98       	mov	r8,r7
8000bee2:	ee 1c 80 00 	eorh	r12,0x8000
8000bee6:	f6 07 16 14 	lsr	r7,r11,0x14
8000beea:	ab 7b       	lsl	r11,0xb
8000beec:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000bef0:	ab 7a       	lsl	r10,0xb
8000bef2:	bf bb       	sbr	r11,0x1f
8000bef4:	f2 06 16 14 	lsr	r6,r9,0x14
8000bef8:	c4 40       	breq	8000bf80 <__avr32_f64_sub_opL_subnormal>
8000befa:	ab 79       	lsl	r9,0xb
8000befc:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000bf00:	ab 78       	lsl	r8,0xb
8000bf02:	bf b9       	sbr	r9,0x1f

8000bf04 <__avr32_f64_sub_opL_subnormal_done>:
8000bf04:	e0 47 07 ff 	cp.w	r7,2047
8000bf08:	c4 f0       	breq	8000bfa6 <__avr32_f64_sub_opH_nan_or_inf>
8000bf0a:	0e 26       	rsub	r6,r7
8000bf0c:	c1 20       	breq	8000bf30 <__avr32_f64_sub_shift_done>
8000bf0e:	ec 05 11 20 	rsub	r5,r6,32
8000bf12:	e0 46 00 20 	cp.w	r6,32
8000bf16:	c7 c2       	brcc	8000c00e <__avr32_f64_sub_longshift>
8000bf18:	f0 05 09 4e 	lsl	lr,r8,r5
8000bf1c:	f2 05 09 45 	lsl	r5,r9,r5
8000bf20:	f0 06 0a 48 	lsr	r8,r8,r6
8000bf24:	f2 06 0a 49 	lsr	r9,r9,r6
8000bf28:	0a 48       	or	r8,r5
8000bf2a:	58 0e       	cp.w	lr,0
8000bf2c:	5f 1e       	srne	lr
8000bf2e:	1c 48       	or	r8,lr

8000bf30 <__avr32_f64_sub_shift_done>:
8000bf30:	10 1a       	sub	r10,r8
8000bf32:	f6 09 01 4b 	sbc	r11,r11,r9
8000bf36:	f6 06 12 00 	clz	r6,r11
8000bf3a:	c0 e0       	breq	8000bf56 <__avr32_f64_sub_longnormalize_done>
8000bf3c:	c7 83       	brcs	8000c02c <__avr32_f64_sub_longnormalize>
8000bf3e:	ec 0e 11 20 	rsub	lr,r6,32
8000bf42:	f6 06 09 4b 	lsl	r11,r11,r6
8000bf46:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000bf4a:	1c 4b       	or	r11,lr
8000bf4c:	f4 06 09 4a 	lsl	r10,r10,r6
8000bf50:	0c 17       	sub	r7,r6
8000bf52:	e0 8a 00 39 	brle	8000bfc4 <__avr32_f64_sub_subnormal_result>

8000bf56 <__avr32_f64_sub_longnormalize_done>:
8000bf56:	f4 09 15 15 	lsl	r9,r10,0x15
8000bf5a:	ab 9a       	lsr	r10,0xb
8000bf5c:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000bf60:	ab 9b       	lsr	r11,0xb
8000bf62:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000bf66:	18 4b       	or	r11,r12

8000bf68 <__avr32_f64_sub_round>:
8000bf68:	fc 17 80 00 	movh	r7,0x8000
8000bf6c:	ed ba 00 00 	bld	r10,0x0
8000bf70:	f7 b7 01 ff 	subne	r7,-1
8000bf74:	0e 39       	cp.w	r9,r7
8000bf76:	5f 29       	srhs	r9
8000bf78:	12 0a       	add	r10,r9
8000bf7a:	5c 0b       	acr	r11
8000bf7c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bf80 <__avr32_f64_sub_opL_subnormal>:
8000bf80:	ab 79       	lsl	r9,0xb
8000bf82:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000bf86:	ab 78       	lsl	r8,0xb
8000bf88:	f3 e8 10 0e 	or	lr,r9,r8
8000bf8c:	f9 b6 01 01 	movne	r6,1
8000bf90:	ee 0e 11 00 	rsub	lr,r7,0
8000bf94:	f9 b7 00 01 	moveq	r7,1
8000bf98:	ef bb 00 1f 	bst	r11,0x1f
8000bf9c:	f7 ea 10 0e 	or	lr,r11,r10
8000bfa0:	f9 b7 00 00 	moveq	r7,0
8000bfa4:	cb 0b       	rjmp	8000bf04 <__avr32_f64_sub_opL_subnormal_done>

8000bfa6 <__avr32_f64_sub_opH_nan_or_inf>:
8000bfa6:	bf db       	cbr	r11,0x1f
8000bfa8:	f7 ea 10 0e 	or	lr,r11,r10
8000bfac:	c0 81       	brne	8000bfbc <__avr32_f64_sub_return_nan>
8000bfae:	e0 46 07 ff 	cp.w	r6,2047
8000bfb2:	c0 50       	breq	8000bfbc <__avr32_f64_sub_return_nan>
8000bfb4:	f9 e7 11 4b 	or	r11,r12,r7<<0x14
8000bfb8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bfbc <__avr32_f64_sub_return_nan>:
8000bfbc:	3f fa       	mov	r10,-1
8000bfbe:	3f fb       	mov	r11,-1
8000bfc0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bfc4 <__avr32_f64_sub_subnormal_result>:
8000bfc4:	5c 37       	neg	r7
8000bfc6:	2f f7       	sub	r7,-1
8000bfc8:	f1 b7 04 c0 	satu	r7,0x6
8000bfcc:	e0 47 00 20 	cp.w	r7,32
8000bfd0:	c1 14       	brge	8000bff2 <__avr32_f64_sub_subnormal_result+0x2e>
8000bfd2:	ee 08 11 20 	rsub	r8,r7,32
8000bfd6:	f4 08 09 49 	lsl	r9,r10,r8
8000bfda:	5f 16       	srne	r6
8000bfdc:	f4 07 0a 4a 	lsr	r10,r10,r7
8000bfe0:	0c 4a       	or	r10,r6
8000bfe2:	f6 08 09 49 	lsl	r9,r11,r8
8000bfe6:	f5 e9 10 0a 	or	r10,r10,r9
8000bfea:	f4 07 0a 4b 	lsr	r11,r10,r7
8000bfee:	30 07       	mov	r7,0
8000bff0:	cb 3b       	rjmp	8000bf56 <__avr32_f64_sub_longnormalize_done>
8000bff2:	ee 08 11 40 	rsub	r8,r7,64
8000bff6:	f6 08 09 49 	lsl	r9,r11,r8
8000bffa:	14 49       	or	r9,r10
8000bffc:	5f 16       	srne	r6
8000bffe:	f6 07 0a 4a 	lsr	r10,r11,r7
8000c002:	0c 4a       	or	r10,r6
8000c004:	30 0b       	mov	r11,0
8000c006:	30 07       	mov	r7,0
8000c008:	ca 7b       	rjmp	8000bf56 <__avr32_f64_sub_longnormalize_done>
8000c00a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c00e <__avr32_f64_sub_longshift>:
8000c00e:	f1 b6 04 c0 	satu	r6,0x6
8000c012:	f0 0e 17 00 	moveq	lr,r8
8000c016:	c0 40       	breq	8000c01e <__avr32_f64_sub_longshift+0x10>
8000c018:	f2 05 09 4e 	lsl	lr,r9,r5
8000c01c:	10 4e       	or	lr,r8
8000c01e:	f2 06 0a 48 	lsr	r8,r9,r6
8000c022:	30 09       	mov	r9,0
8000c024:	58 0e       	cp.w	lr,0
8000c026:	5f 1e       	srne	lr
8000c028:	1c 48       	or	r8,lr
8000c02a:	c8 3b       	rjmp	8000bf30 <__avr32_f64_sub_shift_done>

8000c02c <__avr32_f64_sub_longnormalize>:
8000c02c:	f4 06 12 00 	clz	r6,r10
8000c030:	f9 b7 03 00 	movlo	r7,0
8000c034:	f9 b6 03 00 	movlo	r6,0
8000c038:	f9 bc 03 00 	movlo	r12,0
8000c03c:	f7 b6 02 e0 	subhs	r6,-32
8000c040:	f4 06 09 4b 	lsl	r11,r10,r6
8000c044:	30 0a       	mov	r10,0
8000c046:	0c 17       	sub	r7,r6
8000c048:	fe 9a ff be 	brle	8000bfc4 <__avr32_f64_sub_subnormal_result>
8000c04c:	c8 5b       	rjmp	8000bf56 <__avr32_f64_sub_longnormalize_done>
8000c04e:	d7 03       	nop

8000c050 <__avr32_f64_add_from_sub>:
8000c050:	ee 19 80 00 	eorh	r9,0x8000

8000c054 <__avr32_f64_add>:
8000c054:	f7 e9 20 0c 	eor	r12,r11,r9
8000c058:	fe 96 ff 2e 	brmi	8000beb4 <__avr32_f64_sub_from_add>
8000c05c:	eb cd 40 e0 	pushm	r5-r7,lr
8000c060:	16 9c       	mov	r12,r11
8000c062:	e6 1c 80 00 	andh	r12,0x8000,COH
8000c066:	bf db       	cbr	r11,0x1f
8000c068:	bf d9       	cbr	r9,0x1f
8000c06a:	12 3b       	cp.w	r11,r9
8000c06c:	c0 72       	brcc	8000c07a <__avr32_f64_add+0x26>
8000c06e:	16 97       	mov	r7,r11
8000c070:	12 9b       	mov	r11,r9
8000c072:	0e 99       	mov	r9,r7
8000c074:	14 97       	mov	r7,r10
8000c076:	10 9a       	mov	r10,r8
8000c078:	0e 98       	mov	r8,r7
8000c07a:	30 0e       	mov	lr,0
8000c07c:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000c080:	f7 db c0 14 	bfextu	r11,r11,0x0,0x14
8000c084:	b5 ab       	sbr	r11,0x14
8000c086:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000c08a:	c6 20       	breq	8000c14e <__avr32_f64_add_op2_subnormal>
8000c08c:	f3 d9 c0 14 	bfextu	r9,r9,0x0,0x14
8000c090:	b5 a9       	sbr	r9,0x14
8000c092:	e0 47 07 ff 	cp.w	r7,2047
8000c096:	c2 80       	breq	8000c0e6 <__avr32_f64_add_opH_nan_or_inf>
8000c098:	0e 26       	rsub	r6,r7
8000c09a:	c1 20       	breq	8000c0be <__avr32_f64_add_shift_done>
8000c09c:	e0 46 00 36 	cp.w	r6,54
8000c0a0:	c1 52       	brcc	8000c0ca <__avr32_f64_add_res_of_done>
8000c0a2:	ec 05 11 20 	rsub	r5,r6,32
8000c0a6:	e0 46 00 20 	cp.w	r6,32
8000c0aa:	c3 52       	brcc	8000c114 <__avr32_f64_add_longshift>
8000c0ac:	f0 05 09 4e 	lsl	lr,r8,r5
8000c0b0:	f2 05 09 45 	lsl	r5,r9,r5
8000c0b4:	f0 06 0a 48 	lsr	r8,r8,r6
8000c0b8:	f2 06 0a 49 	lsr	r9,r9,r6
8000c0bc:	0a 48       	or	r8,r5

8000c0be <__avr32_f64_add_shift_done>:
8000c0be:	10 0a       	add	r10,r8
8000c0c0:	f6 09 00 4b 	adc	r11,r11,r9
8000c0c4:	ed bb 00 15 	bld	r11,0x15
8000c0c8:	c3 40       	breq	8000c130 <__avr32_f64_add_res_of>

8000c0ca <__avr32_f64_add_res_of_done>:
8000c0ca:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000c0ce:	18 4b       	or	r11,r12

8000c0d0 <__avr32_f64_add_round>:
8000c0d0:	f9 da c0 01 	bfextu	r12,r10,0x0,0x1
8000c0d4:	18 4e       	or	lr,r12
8000c0d6:	ee 1e 80 00 	eorh	lr,0x8000
8000c0da:	f1 be 04 20 	satu	lr,0x1
8000c0de:	1c 0a       	add	r10,lr
8000c0e0:	5c 0b       	acr	r11
8000c0e2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c0e6 <__avr32_f64_add_opH_nan_or_inf>:
8000c0e6:	b5 cb       	cbr	r11,0x14
8000c0e8:	f7 ea 10 0e 	or	lr,r11,r10
8000c0ec:	c1 01       	brne	8000c10c <__avr32_f64_add_return_nan>
8000c0ee:	e0 46 07 ff 	cp.w	r6,2047
8000c0f2:	c0 30       	breq	8000c0f8 <__avr32_f64_add_opL_nan_or_inf>
8000c0f4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c0f8 <__avr32_f64_add_opL_nan_or_inf>:
8000c0f8:	b5 c9       	cbr	r9,0x14
8000c0fa:	f3 e8 10 0e 	or	lr,r9,r8
8000c0fe:	c0 71       	brne	8000c10c <__avr32_f64_add_return_nan>
8000c100:	30 0a       	mov	r10,0
8000c102:	fc 1b 7f f0 	movh	r11,0x7ff0
8000c106:	18 4b       	or	r11,r12
8000c108:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c10c <__avr32_f64_add_return_nan>:
8000c10c:	3f fa       	mov	r10,-1
8000c10e:	3f fb       	mov	r11,-1
8000c110:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c114 <__avr32_f64_add_longshift>:
8000c114:	f1 b6 04 c0 	satu	r6,0x6
8000c118:	f0 0e 17 00 	moveq	lr,r8
8000c11c:	c0 60       	breq	8000c128 <__avr32_f64_add_longshift+0x14>
8000c11e:	f2 05 09 4e 	lsl	lr,r9,r5
8000c122:	58 08       	cp.w	r8,0
8000c124:	5f 18       	srne	r8
8000c126:	10 4e       	or	lr,r8
8000c128:	f2 06 0a 48 	lsr	r8,r9,r6
8000c12c:	30 09       	mov	r9,0
8000c12e:	cc 8b       	rjmp	8000c0be <__avr32_f64_add_shift_done>

8000c130 <__avr32_f64_add_res_of>:
8000c130:	fd ee 10 1e 	or	lr,lr,lr<<0x1
8000c134:	a1 9b       	lsr	r11,0x1
8000c136:	5d 0a       	ror	r10
8000c138:	5d 0e       	ror	lr
8000c13a:	2f f7       	sub	r7,-1
8000c13c:	e0 47 07 ff 	cp.w	r7,2047
8000c140:	f9 ba 00 00 	moveq	r10,0
8000c144:	f9 bb 00 00 	moveq	r11,0
8000c148:	f9 be 00 00 	moveq	lr,0
8000c14c:	cb fb       	rjmp	8000c0ca <__avr32_f64_add_res_of_done>

8000c14e <__avr32_f64_add_op2_subnormal>:
8000c14e:	30 16       	mov	r6,1
8000c150:	58 07       	cp.w	r7,0
8000c152:	ca 01       	brne	8000c092 <__avr32_f64_add+0x3e>
8000c154:	b5 cb       	cbr	r11,0x14
8000c156:	10 0a       	add	r10,r8
8000c158:	f6 09 00 4b 	adc	r11,r11,r9
8000c15c:	18 4b       	or	r11,r12
8000c15e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000c162:	d7 03       	nop

8000c164 <__avr32_f64_to_u32>:
8000c164:	58 0b       	cp.w	r11,0
8000c166:	5e 6d       	retmi	0

8000c168 <__avr32_f64_to_s32>:
8000c168:	f6 0c 15 01 	lsl	r12,r11,0x1
8000c16c:	b5 9c       	lsr	r12,0x15
8000c16e:	e0 2c 03 ff 	sub	r12,1023
8000c172:	5e 3d       	retlo	0
8000c174:	f8 0c 11 1f 	rsub	r12,r12,31
8000c178:	16 99       	mov	r9,r11
8000c17a:	ab 7b       	lsl	r11,0xb
8000c17c:	bf bb       	sbr	r11,0x1f
8000c17e:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000c182:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000c186:	a1 79       	lsl	r9,0x1
8000c188:	5e 2b       	reths	r11
8000c18a:	5c 3b       	neg	r11
8000c18c:	5e fb       	retal	r11

8000c18e <__avr32_u32_to_f64>:
8000c18e:	f8 cb 00 00 	sub	r11,r12,0
8000c192:	30 0c       	mov	r12,0
8000c194:	c0 38       	rjmp	8000c19a <__avr32_s32_to_f64+0x4>

8000c196 <__avr32_s32_to_f64>:
8000c196:	18 9b       	mov	r11,r12
8000c198:	5c 4b       	abs	r11
8000c19a:	30 0a       	mov	r10,0
8000c19c:	5e 0b       	reteq	r11
8000c19e:	d4 01       	pushm	lr
8000c1a0:	e0 69 04 1e 	mov	r9,1054
8000c1a4:	f6 08 12 00 	clz	r8,r11
8000c1a8:	c1 70       	breq	8000c1d6 <__avr32_s32_to_f64+0x40>
8000c1aa:	c0 c3       	brcs	8000c1c2 <__avr32_s32_to_f64+0x2c>
8000c1ac:	f0 0e 11 20 	rsub	lr,r8,32
8000c1b0:	f6 08 09 4b 	lsl	r11,r11,r8
8000c1b4:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000c1b8:	1c 4b       	or	r11,lr
8000c1ba:	f4 08 09 4a 	lsl	r10,r10,r8
8000c1be:	10 19       	sub	r9,r8
8000c1c0:	c0 b8       	rjmp	8000c1d6 <__avr32_s32_to_f64+0x40>
8000c1c2:	f4 08 12 00 	clz	r8,r10
8000c1c6:	f9 b8 03 00 	movlo	r8,0
8000c1ca:	f7 b8 02 e0 	subhs	r8,-32
8000c1ce:	f4 08 09 4b 	lsl	r11,r10,r8
8000c1d2:	30 0a       	mov	r10,0
8000c1d4:	10 19       	sub	r9,r8
8000c1d6:	58 09       	cp.w	r9,0
8000c1d8:	e0 89 00 30 	brgt	8000c238 <__avr32_s32_to_f64+0xa2>
8000c1dc:	5c 39       	neg	r9
8000c1de:	2f f9       	sub	r9,-1
8000c1e0:	e0 49 00 36 	cp.w	r9,54
8000c1e4:	c0 43       	brcs	8000c1ec <__avr32_s32_to_f64+0x56>
8000c1e6:	30 0b       	mov	r11,0
8000c1e8:	30 0a       	mov	r10,0
8000c1ea:	c2 68       	rjmp	8000c236 <__avr32_s32_to_f64+0xa0>
8000c1ec:	2f 69       	sub	r9,-10
8000c1ee:	f2 08 11 20 	rsub	r8,r9,32
8000c1f2:	e0 49 00 20 	cp.w	r9,32
8000c1f6:	c0 b2       	brcc	8000c20c <__avr32_s32_to_f64+0x76>
8000c1f8:	f4 08 09 4e 	lsl	lr,r10,r8
8000c1fc:	f6 08 09 48 	lsl	r8,r11,r8
8000c200:	f4 09 0a 4a 	lsr	r10,r10,r9
8000c204:	f6 09 0a 4b 	lsr	r11,r11,r9
8000c208:	10 4b       	or	r11,r8
8000c20a:	c0 88       	rjmp	8000c21a <__avr32_s32_to_f64+0x84>
8000c20c:	f6 08 09 4e 	lsl	lr,r11,r8
8000c210:	14 4e       	or	lr,r10
8000c212:	16 9a       	mov	r10,r11
8000c214:	30 0b       	mov	r11,0
8000c216:	f4 09 0a 4a 	lsr	r10,r10,r9
8000c21a:	ed ba 00 00 	bld	r10,0x0
8000c21e:	c0 92       	brcc	8000c230 <__avr32_s32_to_f64+0x9a>
8000c220:	1c 7e       	tst	lr,lr
8000c222:	c0 41       	brne	8000c22a <__avr32_s32_to_f64+0x94>
8000c224:	ed ba 00 01 	bld	r10,0x1
8000c228:	c0 42       	brcc	8000c230 <__avr32_s32_to_f64+0x9a>
8000c22a:	2f fa       	sub	r10,-1
8000c22c:	f7 bb 02 ff 	subhs	r11,-1
8000c230:	5c fc       	rol	r12
8000c232:	5d 0b       	ror	r11
8000c234:	5d 0a       	ror	r10
8000c236:	d8 02       	popm	pc
8000c238:	e0 68 03 ff 	mov	r8,1023
8000c23c:	ed ba 00 0b 	bld	r10,0xb
8000c240:	f7 b8 00 ff 	subeq	r8,-1
8000c244:	10 0a       	add	r10,r8
8000c246:	5c 0b       	acr	r11
8000c248:	f7 b9 03 fe 	sublo	r9,-2
8000c24c:	e0 49 07 ff 	cp.w	r9,2047
8000c250:	c0 55       	brlt	8000c25a <__avr32_s32_to_f64+0xc4>
8000c252:	30 0a       	mov	r10,0
8000c254:	fc 1b ff e0 	movh	r11,0xffe0
8000c258:	c0 c8       	rjmp	8000c270 <__floatsidf_return_op1>
8000c25a:	ed bb 00 1f 	bld	r11,0x1f
8000c25e:	f7 b9 01 01 	subne	r9,1
8000c262:	ab 9a       	lsr	r10,0xb
8000c264:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000c268:	a1 7b       	lsl	r11,0x1
8000c26a:	ab 9b       	lsr	r11,0xb
8000c26c:	f7 e9 11 5b 	or	r11,r11,r9<<0x15

8000c270 <__floatsidf_return_op1>:
8000c270:	a1 7c       	lsl	r12,0x1
8000c272:	5d 0b       	ror	r11
8000c274:	d8 02       	popm	pc

8000c276 <__avr32_f64_cmp_eq>:
8000c276:	10 3a       	cp.w	r10,r8
8000c278:	f2 0b 13 00 	cpc	r11,r9
8000c27c:	c0 80       	breq	8000c28c <__avr32_f64_cmp_eq+0x16>
8000c27e:	a1 7b       	lsl	r11,0x1
8000c280:	a1 79       	lsl	r9,0x1
8000c282:	14 4b       	or	r11,r10
8000c284:	12 4b       	or	r11,r9
8000c286:	10 4b       	or	r11,r8
8000c288:	5e 0f       	reteq	1
8000c28a:	5e fd       	retal	0
8000c28c:	a1 7b       	lsl	r11,0x1
8000c28e:	fc 1c ff e0 	movh	r12,0xffe0
8000c292:	58 0a       	cp.w	r10,0
8000c294:	f8 0b 13 00 	cpc	r11,r12
8000c298:	5e 8f       	retls	1
8000c29a:	5e fd       	retal	0

8000c29c <__avr32_f64_cmp_ge>:
8000c29c:	1a de       	st.w	--sp,lr
8000c29e:	1a d7       	st.w	--sp,r7
8000c2a0:	a1 7b       	lsl	r11,0x1
8000c2a2:	5f 3c       	srlo	r12
8000c2a4:	a1 79       	lsl	r9,0x1
8000c2a6:	5f 37       	srlo	r7
8000c2a8:	5c fc       	rol	r12
8000c2aa:	fc 1e ff e0 	movh	lr,0xffe0
8000c2ae:	58 0a       	cp.w	r10,0
8000c2b0:	fc 0b 13 00 	cpc	r11,lr
8000c2b4:	e0 8b 00 1d 	brhi	8000c2ee <__avr32_f64_cmp_ge+0x52>
8000c2b8:	58 08       	cp.w	r8,0
8000c2ba:	fc 09 13 00 	cpc	r9,lr
8000c2be:	e0 8b 00 18 	brhi	8000c2ee <__avr32_f64_cmp_ge+0x52>
8000c2c2:	58 0b       	cp.w	r11,0
8000c2c4:	f5 ba 00 00 	subfeq	r10,0
8000c2c8:	c1 50       	breq	8000c2f2 <__avr32_f64_cmp_ge+0x56>
8000c2ca:	1b 07       	ld.w	r7,sp++
8000c2cc:	1b 0e       	ld.w	lr,sp++
8000c2ce:	58 3c       	cp.w	r12,3
8000c2d0:	c0 a0       	breq	8000c2e4 <__avr32_f64_cmp_ge+0x48>
8000c2d2:	58 1c       	cp.w	r12,1
8000c2d4:	c0 33       	brcs	8000c2da <__avr32_f64_cmp_ge+0x3e>
8000c2d6:	5e 0f       	reteq	1
8000c2d8:	5e 1d       	retne	0
8000c2da:	10 3a       	cp.w	r10,r8
8000c2dc:	f2 0b 13 00 	cpc	r11,r9
8000c2e0:	5e 2f       	reths	1
8000c2e2:	5e 3d       	retlo	0
8000c2e4:	14 38       	cp.w	r8,r10
8000c2e6:	f6 09 13 00 	cpc	r9,r11
8000c2ea:	5e 2f       	reths	1
8000c2ec:	5e 3d       	retlo	0
8000c2ee:	1b 07       	ld.w	r7,sp++
8000c2f0:	d8 0a       	popm	pc,r12=0
8000c2f2:	58 17       	cp.w	r7,1
8000c2f4:	5f 0c       	sreq	r12
8000c2f6:	58 09       	cp.w	r9,0
8000c2f8:	f5 b8 00 00 	subfeq	r8,0
8000c2fc:	1b 07       	ld.w	r7,sp++
8000c2fe:	1b 0e       	ld.w	lr,sp++
8000c300:	5e 0f       	reteq	1
8000c302:	5e fc       	retal	r12

8000c304 <__avr32_f64_cmp_lt>:
8000c304:	1a de       	st.w	--sp,lr
8000c306:	1a d7       	st.w	--sp,r7
8000c308:	a1 7b       	lsl	r11,0x1
8000c30a:	5f 3c       	srlo	r12
8000c30c:	a1 79       	lsl	r9,0x1
8000c30e:	5f 37       	srlo	r7
8000c310:	5c fc       	rol	r12
8000c312:	fc 1e ff e0 	movh	lr,0xffe0
8000c316:	58 0a       	cp.w	r10,0
8000c318:	fc 0b 13 00 	cpc	r11,lr
8000c31c:	e0 8b 00 1d 	brhi	8000c356 <__avr32_f64_cmp_lt+0x52>
8000c320:	58 08       	cp.w	r8,0
8000c322:	fc 09 13 00 	cpc	r9,lr
8000c326:	e0 8b 00 18 	brhi	8000c356 <__avr32_f64_cmp_lt+0x52>
8000c32a:	58 0b       	cp.w	r11,0
8000c32c:	f5 ba 00 00 	subfeq	r10,0
8000c330:	c1 50       	breq	8000c35a <__avr32_f64_cmp_lt+0x56>
8000c332:	1b 07       	ld.w	r7,sp++
8000c334:	1b 0e       	ld.w	lr,sp++
8000c336:	58 3c       	cp.w	r12,3
8000c338:	c0 a0       	breq	8000c34c <__avr32_f64_cmp_lt+0x48>
8000c33a:	58 1c       	cp.w	r12,1
8000c33c:	c0 33       	brcs	8000c342 <__avr32_f64_cmp_lt+0x3e>
8000c33e:	5e 0d       	reteq	0
8000c340:	5e 1f       	retne	1
8000c342:	10 3a       	cp.w	r10,r8
8000c344:	f2 0b 13 00 	cpc	r11,r9
8000c348:	5e 2d       	reths	0
8000c34a:	5e 3f       	retlo	1
8000c34c:	14 38       	cp.w	r8,r10
8000c34e:	f6 09 13 00 	cpc	r9,r11
8000c352:	5e 2d       	reths	0
8000c354:	5e 3f       	retlo	1
8000c356:	1b 07       	ld.w	r7,sp++
8000c358:	d8 0a       	popm	pc,r12=0
8000c35a:	58 17       	cp.w	r7,1
8000c35c:	5f 1c       	srne	r12
8000c35e:	58 09       	cp.w	r9,0
8000c360:	f5 b8 00 00 	subfeq	r8,0
8000c364:	1b 07       	ld.w	r7,sp++
8000c366:	1b 0e       	ld.w	lr,sp++
8000c368:	5e 0d       	reteq	0
8000c36a:	5e fc       	retal	r12

8000c36c <__avr32_f64_div>:
8000c36c:	eb cd 40 ff 	pushm	r0-r7,lr
8000c370:	f7 e9 20 0e 	eor	lr,r11,r9
8000c374:	f6 07 16 14 	lsr	r7,r11,0x14
8000c378:	a9 7b       	lsl	r11,0x9
8000c37a:	f7 ea 13 7b 	or	r11,r11,r10>>0x17
8000c37e:	a9 7a       	lsl	r10,0x9
8000c380:	bd bb       	sbr	r11,0x1d
8000c382:	e4 1b 3f ff 	andh	r11,0x3fff
8000c386:	ab d7       	cbr	r7,0xb
8000c388:	e0 80 00 cc 	breq	8000c520 <__avr32_f64_div_round_subnormal+0x54>
8000c38c:	e0 47 07 ff 	cp.w	r7,2047
8000c390:	e0 84 00 b5 	brge	8000c4fa <__avr32_f64_div_round_subnormal+0x2e>
8000c394:	f2 06 16 14 	lsr	r6,r9,0x14
8000c398:	a9 79       	lsl	r9,0x9
8000c39a:	f3 e8 13 79 	or	r9,r9,r8>>0x17
8000c39e:	a9 78       	lsl	r8,0x9
8000c3a0:	bd b9       	sbr	r9,0x1d
8000c3a2:	e4 19 3f ff 	andh	r9,0x3fff
8000c3a6:	ab d6       	cbr	r6,0xb
8000c3a8:	e0 80 00 e2 	breq	8000c56c <__avr32_f64_div_round_subnormal+0xa0>
8000c3ac:	e0 46 07 ff 	cp.w	r6,2047
8000c3b0:	e0 84 00 b2 	brge	8000c514 <__avr32_f64_div_round_subnormal+0x48>
8000c3b4:	0c 17       	sub	r7,r6
8000c3b6:	fe 37 fc 01 	sub	r7,-1023
8000c3ba:	fc 1c 80 00 	movh	r12,0x8000
8000c3be:	f8 03 16 01 	lsr	r3,r12,0x1
8000c3c2:	e9 d9 c3 62 	bfextu	r4,r9,0x1b,0x2
8000c3c6:	5c d4       	com	r4
8000c3c8:	e7 d4 d3 82 	bfins	r3,r4,0x1c,0x2
8000c3cc:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c3d0:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000c3d4:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c3d8:	ea 03 15 02 	lsl	r3,r5,0x2
8000c3dc:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c3e0:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000c3e4:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c3e8:	ea 03 15 02 	lsl	r3,r5,0x2
8000c3ec:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c3f0:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000c3f4:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c3f8:	ea 03 15 02 	lsl	r3,r5,0x2
8000c3fc:	e6 08 06 40 	mulu.d	r0,r3,r8
8000c400:	e4 09 07 40 	macu.d	r0,r2,r9
8000c404:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c408:	02 04       	add	r4,r1
8000c40a:	5c 05       	acr	r5
8000c40c:	a3 65       	lsl	r5,0x2
8000c40e:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000c412:	a3 64       	lsl	r4,0x2
8000c414:	5c 34       	neg	r4
8000c416:	f8 05 01 45 	sbc	r5,r12,r5
8000c41a:	e6 04 06 40 	mulu.d	r0,r3,r4
8000c41e:	e4 05 07 40 	macu.d	r0,r2,r5
8000c422:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c426:	02 04       	add	r4,r1
8000c428:	5c 05       	acr	r5
8000c42a:	ea 03 15 02 	lsl	r3,r5,0x2
8000c42e:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000c432:	e8 02 15 02 	lsl	r2,r4,0x2
8000c436:	e6 08 06 40 	mulu.d	r0,r3,r8
8000c43a:	e4 09 07 40 	macu.d	r0,r2,r9
8000c43e:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c442:	02 04       	add	r4,r1
8000c444:	5c 05       	acr	r5
8000c446:	a3 65       	lsl	r5,0x2
8000c448:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000c44c:	a3 64       	lsl	r4,0x2
8000c44e:	5c 34       	neg	r4
8000c450:	f8 05 01 45 	sbc	r5,r12,r5
8000c454:	e6 04 06 40 	mulu.d	r0,r3,r4
8000c458:	e4 05 07 40 	macu.d	r0,r2,r5
8000c45c:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c460:	02 04       	add	r4,r1
8000c462:	5c 05       	acr	r5
8000c464:	ea 03 15 02 	lsl	r3,r5,0x2
8000c468:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000c46c:	e8 02 15 02 	lsl	r2,r4,0x2
8000c470:	e6 0a 06 40 	mulu.d	r0,r3,r10
8000c474:	e4 0b 07 40 	macu.d	r0,r2,r11
8000c478:	e6 0b 06 42 	mulu.d	r2,r3,r11
8000c47c:	02 02       	add	r2,r1
8000c47e:	5c 03       	acr	r3
8000c480:	ed b3 00 1c 	bld	r3,0x1c
8000c484:	c0 90       	breq	8000c496 <__avr32_f64_div+0x12a>
8000c486:	a1 72       	lsl	r2,0x1
8000c488:	5c f3       	rol	r3
8000c48a:	20 17       	sub	r7,1
8000c48c:	a3 9a       	lsr	r10,0x3
8000c48e:	f5 eb 11 da 	or	r10,r10,r11<<0x1d
8000c492:	a3 9b       	lsr	r11,0x3
8000c494:	c0 58       	rjmp	8000c49e <__avr32_f64_div+0x132>
8000c496:	a5 8a       	lsr	r10,0x4
8000c498:	f5 eb 11 ca 	or	r10,r10,r11<<0x1c
8000c49c:	a5 8b       	lsr	r11,0x4
8000c49e:	58 07       	cp.w	r7,0
8000c4a0:	e0 8a 00 8b 	brle	8000c5b6 <__avr32_f64_div_res_subnormal>
8000c4a4:	e0 12 ff 00 	andl	r2,0xff00
8000c4a8:	e8 12 00 80 	orl	r2,0x80
8000c4ac:	e6 08 06 40 	mulu.d	r0,r3,r8
8000c4b0:	e4 09 07 40 	macu.d	r0,r2,r9
8000c4b4:	e4 08 06 44 	mulu.d	r4,r2,r8
8000c4b8:	e6 09 06 48 	mulu.d	r8,r3,r9
8000c4bc:	00 05       	add	r5,r0
8000c4be:	f0 01 00 48 	adc	r8,r8,r1
8000c4c2:	5c 09       	acr	r9
8000c4c4:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000c4c8:	58 04       	cp.w	r4,0
8000c4ca:	5c 25       	cpc	r5

8000c4cc <__avr32_f64_div_round_subnormal>:
8000c4cc:	f4 08 13 00 	cpc	r8,r10
8000c4d0:	f6 09 13 00 	cpc	r9,r11
8000c4d4:	5f 36       	srlo	r6
8000c4d6:	f8 06 17 00 	moveq	r6,r12
8000c4da:	e4 0a 16 08 	lsr	r10,r2,0x8
8000c4de:	f5 e3 11 8a 	or	r10,r10,r3<<0x18
8000c4e2:	e6 0b 16 08 	lsr	r11,r3,0x8
8000c4e6:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000c4ea:	ed be 00 1f 	bld	lr,0x1f
8000c4ee:	ef bb 00 1f 	bst	r11,0x1f
8000c4f2:	0c 0a       	add	r10,r6
8000c4f4:	5c 0b       	acr	r11
8000c4f6:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000c4fa:	e4 1b 00 0f 	andh	r11,0xf
8000c4fe:	14 4b       	or	r11,r10
8000c500:	e0 81 00 a7 	brne	8000c64e <__avr32_f64_div_res_subnormal+0x98>
8000c504:	f2 06 16 14 	lsr	r6,r9,0x14
8000c508:	ab d6       	cbr	r6,0xb
8000c50a:	e0 46 07 ff 	cp.w	r6,2047
8000c50e:	e0 81 00 a4 	brne	8000c656 <__avr32_f64_div_res_subnormal+0xa0>
8000c512:	c9 e8       	rjmp	8000c64e <__avr32_f64_div_res_subnormal+0x98>
8000c514:	e4 19 00 0f 	andh	r9,0xf
8000c518:	10 49       	or	r9,r8
8000c51a:	e0 81 00 9a 	brne	8000c64e <__avr32_f64_div_res_subnormal+0x98>
8000c51e:	c9 28       	rjmp	8000c642 <__avr32_f64_div_res_subnormal+0x8c>
8000c520:	a3 7b       	lsl	r11,0x3
8000c522:	f7 ea 13 db 	or	r11,r11,r10>>0x1d
8000c526:	a3 7a       	lsl	r10,0x3
8000c528:	f5 eb 10 04 	or	r4,r10,r11
8000c52c:	e0 80 00 a0 	breq	8000c66c <__avr32_f64_div_op1_zero>
8000c530:	f6 04 12 00 	clz	r4,r11
8000c534:	c1 70       	breq	8000c562 <__avr32_f64_div_round_subnormal+0x96>
8000c536:	c0 c3       	brcs	8000c54e <__avr32_f64_div_round_subnormal+0x82>
8000c538:	e8 05 11 20 	rsub	r5,r4,32
8000c53c:	f6 04 09 4b 	lsl	r11,r11,r4
8000c540:	f4 05 0a 45 	lsr	r5,r10,r5
8000c544:	0a 4b       	or	r11,r5
8000c546:	f4 04 09 4a 	lsl	r10,r10,r4
8000c54a:	08 17       	sub	r7,r4
8000c54c:	c0 b8       	rjmp	8000c562 <__avr32_f64_div_round_subnormal+0x96>
8000c54e:	f4 04 12 00 	clz	r4,r10
8000c552:	f9 b4 03 00 	movlo	r4,0
8000c556:	f7 b4 02 e0 	subhs	r4,-32
8000c55a:	f4 04 09 4b 	lsl	r11,r10,r4
8000c55e:	30 0a       	mov	r10,0
8000c560:	08 17       	sub	r7,r4
8000c562:	a3 8a       	lsr	r10,0x2
8000c564:	f5 eb 11 ea 	or	r10,r10,r11<<0x1e
8000c568:	a3 8b       	lsr	r11,0x2
8000c56a:	c1 1b       	rjmp	8000c38c <__avr32_f64_div+0x20>
8000c56c:	a3 79       	lsl	r9,0x3
8000c56e:	f3 e8 13 d9 	or	r9,r9,r8>>0x1d
8000c572:	a3 78       	lsl	r8,0x3
8000c574:	f3 e8 10 04 	or	r4,r9,r8
8000c578:	c6 f0       	breq	8000c656 <__avr32_f64_div_res_subnormal+0xa0>
8000c57a:	f2 04 12 00 	clz	r4,r9
8000c57e:	c1 70       	breq	8000c5ac <__avr32_f64_div_round_subnormal+0xe0>
8000c580:	c0 c3       	brcs	8000c598 <__avr32_f64_div_round_subnormal+0xcc>
8000c582:	e8 05 11 20 	rsub	r5,r4,32
8000c586:	f2 04 09 49 	lsl	r9,r9,r4
8000c58a:	f0 05 0a 45 	lsr	r5,r8,r5
8000c58e:	0a 49       	or	r9,r5
8000c590:	f0 04 09 48 	lsl	r8,r8,r4
8000c594:	08 16       	sub	r6,r4
8000c596:	c0 b8       	rjmp	8000c5ac <__avr32_f64_div_round_subnormal+0xe0>
8000c598:	f0 04 12 00 	clz	r4,r8
8000c59c:	f9 b4 03 00 	movlo	r4,0
8000c5a0:	f7 b4 02 e0 	subhs	r4,-32
8000c5a4:	f0 04 09 49 	lsl	r9,r8,r4
8000c5a8:	30 08       	mov	r8,0
8000c5aa:	08 16       	sub	r6,r4
8000c5ac:	a3 88       	lsr	r8,0x2
8000c5ae:	f1 e9 11 e8 	or	r8,r8,r9<<0x1e
8000c5b2:	a3 89       	lsr	r9,0x2
8000c5b4:	cf ca       	rjmp	8000c3ac <__avr32_f64_div+0x40>

8000c5b6 <__avr32_f64_div_res_subnormal>:
8000c5b6:	5c 37       	neg	r7
8000c5b8:	2f f7       	sub	r7,-1
8000c5ba:	f1 b7 04 c0 	satu	r7,0x6
8000c5be:	e0 47 00 20 	cp.w	r7,32
8000c5c2:	c1 54       	brge	8000c5ec <__avr32_f64_div_res_subnormal+0x36>
8000c5c4:	ee 06 11 20 	rsub	r6,r7,32
8000c5c8:	e4 07 0a 42 	lsr	r2,r2,r7
8000c5cc:	e6 06 09 4c 	lsl	r12,r3,r6
8000c5d0:	18 42       	or	r2,r12
8000c5d2:	e6 07 0a 43 	lsr	r3,r3,r7
8000c5d6:	f4 06 09 41 	lsl	r1,r10,r6
8000c5da:	f4 07 0a 4a 	lsr	r10,r10,r7
8000c5de:	f6 06 09 4c 	lsl	r12,r11,r6
8000c5e2:	18 4a       	or	r10,r12
8000c5e4:	f6 07 0a 4b 	lsr	r11,r11,r7
8000c5e8:	30 00       	mov	r0,0
8000c5ea:	c1 58       	rjmp	8000c614 <__avr32_f64_div_res_subnormal+0x5e>
8000c5ec:	ee 06 11 20 	rsub	r6,r7,32
8000c5f0:	f9 b0 00 00 	moveq	r0,0
8000c5f4:	f9 bc 00 00 	moveq	r12,0
8000c5f8:	c0 50       	breq	8000c602 <__avr32_f64_div_res_subnormal+0x4c>
8000c5fa:	f4 06 09 40 	lsl	r0,r10,r6
8000c5fe:	f6 06 09 4c 	lsl	r12,r11,r6
8000c602:	e6 07 0a 42 	lsr	r2,r3,r7
8000c606:	30 03       	mov	r3,0
8000c608:	f4 07 0a 41 	lsr	r1,r10,r7
8000c60c:	18 41       	or	r1,r12
8000c60e:	f6 07 0a 4a 	lsr	r10,r11,r7
8000c612:	30 0b       	mov	r11,0
8000c614:	e0 12 ff 00 	andl	r2,0xff00
8000c618:	e8 12 00 80 	orl	r2,0x80
8000c61c:	e6 08 06 46 	mulu.d	r6,r3,r8
8000c620:	e4 09 07 46 	macu.d	r6,r2,r9
8000c624:	e4 08 06 44 	mulu.d	r4,r2,r8
8000c628:	e6 09 06 48 	mulu.d	r8,r3,r9
8000c62c:	0c 05       	add	r5,r6
8000c62e:	f0 07 00 48 	adc	r8,r8,r7
8000c632:	5c 09       	acr	r9
8000c634:	30 07       	mov	r7,0
8000c636:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000c63a:	00 34       	cp.w	r4,r0
8000c63c:	e2 05 13 00 	cpc	r5,r1
8000c640:	c4 6b       	rjmp	8000c4cc <__avr32_f64_div_round_subnormal>
8000c642:	1c 9b       	mov	r11,lr
8000c644:	e6 1b 80 00 	andh	r11,0x8000,COH
8000c648:	30 0a       	mov	r10,0
8000c64a:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000c64e:	3f fb       	mov	r11,-1
8000c650:	30 0a       	mov	r10,0
8000c652:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000c656:	f5 eb 10 04 	or	r4,r10,r11
8000c65a:	c0 90       	breq	8000c66c <__avr32_f64_div_op1_zero>
8000c65c:	1c 9b       	mov	r11,lr
8000c65e:	e6 1b 80 00 	andh	r11,0x8000,COH
8000c662:	ea 1b 7f f0 	orh	r11,0x7ff0
8000c666:	30 0a       	mov	r10,0
8000c668:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc

8000c66c <__avr32_f64_div_op1_zero>:
8000c66c:	f1 e9 10 15 	or	r5,r8,r9<<0x1
8000c670:	ce f0       	breq	8000c64e <__avr32_f64_div_res_subnormal+0x98>
8000c672:	e9 d9 c2 8b 	bfextu	r4,r9,0x14,0xb
8000c676:	e0 44 07 ff 	cp.w	r4,2047
8000c67a:	ce 41       	brne	8000c642 <__avr32_f64_div_res_subnormal+0x8c>
8000c67c:	f1 e9 10 c5 	or	r5,r8,r9<<0xc
8000c680:	ce 10       	breq	8000c642 <__avr32_f64_div_res_subnormal+0x8c>
8000c682:	ce 6b       	rjmp	8000c64e <__avr32_f64_div_res_subnormal+0x98>

8000c684 <__avr32_udiv64>:
8000c684:	d4 31       	pushm	r0-r7,lr
8000c686:	1a 97       	mov	r7,sp
8000c688:	20 3d       	sub	sp,12
8000c68a:	10 9c       	mov	r12,r8
8000c68c:	12 9e       	mov	lr,r9
8000c68e:	14 93       	mov	r3,r10
8000c690:	58 09       	cp.w	r9,0
8000c692:	e0 81 00 bd 	brne	8000c80c <__avr32_udiv64+0x188>
8000c696:	16 38       	cp.w	r8,r11
8000c698:	e0 88 00 40 	brls	8000c718 <__avr32_udiv64+0x94>
8000c69c:	f0 08 12 00 	clz	r8,r8
8000c6a0:	c0 d0       	breq	8000c6ba <__avr32_udiv64+0x36>
8000c6a2:	f6 08 09 4b 	lsl	r11,r11,r8
8000c6a6:	f0 09 11 20 	rsub	r9,r8,32
8000c6aa:	f8 08 09 4c 	lsl	r12,r12,r8
8000c6ae:	f4 09 0a 49 	lsr	r9,r10,r9
8000c6b2:	f4 08 09 43 	lsl	r3,r10,r8
8000c6b6:	f3 eb 10 0b 	or	r11,r9,r11
8000c6ba:	f8 0e 16 10 	lsr	lr,r12,0x10
8000c6be:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000c6c2:	f6 0e 0d 00 	divu	r0,r11,lr
8000c6c6:	e6 0b 16 10 	lsr	r11,r3,0x10
8000c6ca:	00 99       	mov	r9,r0
8000c6cc:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c6d0:	e0 0a 02 48 	mul	r8,r0,r10
8000c6d4:	10 3b       	cp.w	r11,r8
8000c6d6:	c0 a2       	brcc	8000c6ea <__avr32_udiv64+0x66>
8000c6d8:	20 19       	sub	r9,1
8000c6da:	18 0b       	add	r11,r12
8000c6dc:	18 3b       	cp.w	r11,r12
8000c6de:	c0 63       	brcs	8000c6ea <__avr32_udiv64+0x66>
8000c6e0:	10 3b       	cp.w	r11,r8
8000c6e2:	f7 b9 03 01 	sublo	r9,1
8000c6e6:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c6ea:	f6 08 01 01 	sub	r1,r11,r8
8000c6ee:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000c6f2:	e2 0e 0d 00 	divu	r0,r1,lr
8000c6f6:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000c6fa:	00 98       	mov	r8,r0
8000c6fc:	e0 0a 02 4a 	mul	r10,r0,r10
8000c700:	14 33       	cp.w	r3,r10
8000c702:	c0 82       	brcc	8000c712 <__avr32_udiv64+0x8e>
8000c704:	20 18       	sub	r8,1
8000c706:	18 03       	add	r3,r12
8000c708:	18 33       	cp.w	r3,r12
8000c70a:	c0 43       	brcs	8000c712 <__avr32_udiv64+0x8e>
8000c70c:	14 33       	cp.w	r3,r10
8000c70e:	f7 b8 03 01 	sublo	r8,1
8000c712:	f1 e9 11 08 	or	r8,r8,r9<<0x10
8000c716:	cd f8       	rjmp	8000c8d4 <__avr32_udiv64+0x250>
8000c718:	58 08       	cp.w	r8,0
8000c71a:	c0 51       	brne	8000c724 <__avr32_udiv64+0xa0>
8000c71c:	30 19       	mov	r9,1
8000c71e:	f2 08 0d 08 	divu	r8,r9,r8
8000c722:	10 9c       	mov	r12,r8
8000c724:	f8 06 12 00 	clz	r6,r12
8000c728:	c0 41       	brne	8000c730 <__avr32_udiv64+0xac>
8000c72a:	18 1b       	sub	r11,r12
8000c72c:	30 19       	mov	r9,1
8000c72e:	c4 08       	rjmp	8000c7ae <__avr32_udiv64+0x12a>
8000c730:	ec 01 11 20 	rsub	r1,r6,32
8000c734:	f4 01 0a 49 	lsr	r9,r10,r1
8000c738:	f8 06 09 4c 	lsl	r12,r12,r6
8000c73c:	f6 06 09 48 	lsl	r8,r11,r6
8000c740:	f6 01 0a 41 	lsr	r1,r11,r1
8000c744:	f3 e8 10 08 	or	r8,r9,r8
8000c748:	f8 03 16 10 	lsr	r3,r12,0x10
8000c74c:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000c750:	e2 03 0d 00 	divu	r0,r1,r3
8000c754:	f0 0b 16 10 	lsr	r11,r8,0x10
8000c758:	00 9e       	mov	lr,r0
8000c75a:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c75e:	e0 05 02 49 	mul	r9,r0,r5
8000c762:	12 3b       	cp.w	r11,r9
8000c764:	c0 a2       	brcc	8000c778 <__avr32_udiv64+0xf4>
8000c766:	20 1e       	sub	lr,1
8000c768:	18 0b       	add	r11,r12
8000c76a:	18 3b       	cp.w	r11,r12
8000c76c:	c0 63       	brcs	8000c778 <__avr32_udiv64+0xf4>
8000c76e:	12 3b       	cp.w	r11,r9
8000c770:	f7 be 03 01 	sublo	lr,1
8000c774:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c778:	12 1b       	sub	r11,r9
8000c77a:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
8000c77e:	f6 03 0d 02 	divu	r2,r11,r3
8000c782:	f1 e3 11 08 	or	r8,r8,r3<<0x10
8000c786:	04 99       	mov	r9,r2
8000c788:	e4 05 02 4b 	mul	r11,r2,r5
8000c78c:	16 38       	cp.w	r8,r11
8000c78e:	c0 a2       	brcc	8000c7a2 <__avr32_udiv64+0x11e>
8000c790:	20 19       	sub	r9,1
8000c792:	18 08       	add	r8,r12
8000c794:	18 38       	cp.w	r8,r12
8000c796:	c0 63       	brcs	8000c7a2 <__avr32_udiv64+0x11e>
8000c798:	16 38       	cp.w	r8,r11
8000c79a:	f7 b9 03 01 	sublo	r9,1
8000c79e:	f1 dc e3 08 	addcs	r8,r8,r12
8000c7a2:	f4 06 09 43 	lsl	r3,r10,r6
8000c7a6:	f0 0b 01 0b 	sub	r11,r8,r11
8000c7aa:	f3 ee 11 09 	or	r9,r9,lr<<0x10
8000c7ae:	f8 06 16 10 	lsr	r6,r12,0x10
8000c7b2:	fd dc c0 10 	bfextu	lr,r12,0x0,0x10
8000c7b6:	f6 06 0d 00 	divu	r0,r11,r6
8000c7ba:	e6 0b 16 10 	lsr	r11,r3,0x10
8000c7be:	00 9a       	mov	r10,r0
8000c7c0:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c7c4:	e0 0e 02 48 	mul	r8,r0,lr
8000c7c8:	10 3b       	cp.w	r11,r8
8000c7ca:	c0 a2       	brcc	8000c7de <__avr32_udiv64+0x15a>
8000c7cc:	20 1a       	sub	r10,1
8000c7ce:	18 0b       	add	r11,r12
8000c7d0:	18 3b       	cp.w	r11,r12
8000c7d2:	c0 63       	brcs	8000c7de <__avr32_udiv64+0x15a>
8000c7d4:	10 3b       	cp.w	r11,r8
8000c7d6:	f7 ba 03 01 	sublo	r10,1
8000c7da:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c7de:	f6 08 01 01 	sub	r1,r11,r8
8000c7e2:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000c7e6:	e2 06 0d 00 	divu	r0,r1,r6
8000c7ea:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000c7ee:	00 98       	mov	r8,r0
8000c7f0:	e0 0e 02 4b 	mul	r11,r0,lr
8000c7f4:	16 33       	cp.w	r3,r11
8000c7f6:	c0 82       	brcc	8000c806 <__avr32_udiv64+0x182>
8000c7f8:	20 18       	sub	r8,1
8000c7fa:	18 03       	add	r3,r12
8000c7fc:	18 33       	cp.w	r3,r12
8000c7fe:	c0 43       	brcs	8000c806 <__avr32_udiv64+0x182>
8000c800:	16 33       	cp.w	r3,r11
8000c802:	f7 b8 03 01 	sublo	r8,1
8000c806:	f1 ea 11 08 	or	r8,r8,r10<<0x10
8000c80a:	c6 98       	rjmp	8000c8dc <__avr32_udiv64+0x258>
8000c80c:	16 39       	cp.w	r9,r11
8000c80e:	e0 8b 00 65 	brhi	8000c8d8 <__avr32_udiv64+0x254>
8000c812:	f2 09 12 00 	clz	r9,r9
8000c816:	c0 b1       	brne	8000c82c <__avr32_udiv64+0x1a8>
8000c818:	10 3a       	cp.w	r10,r8
8000c81a:	5f 2a       	srhs	r10
8000c81c:	1c 3b       	cp.w	r11,lr
8000c81e:	5f b8       	srhi	r8
8000c820:	10 4a       	or	r10,r8
8000c822:	f2 0a 18 00 	cp.b	r10,r9
8000c826:	c5 90       	breq	8000c8d8 <__avr32_udiv64+0x254>
8000c828:	30 18       	mov	r8,1
8000c82a:	c5 98       	rjmp	8000c8dc <__avr32_udiv64+0x258>
8000c82c:	f0 09 09 46 	lsl	r6,r8,r9
8000c830:	f2 03 11 20 	rsub	r3,r9,32
8000c834:	fc 09 09 4e 	lsl	lr,lr,r9
8000c838:	f0 03 0a 48 	lsr	r8,r8,r3
8000c83c:	f6 09 09 4c 	lsl	r12,r11,r9
8000c840:	f4 03 0a 42 	lsr	r2,r10,r3
8000c844:	ef 46 ff f4 	st.w	r7[-12],r6
8000c848:	f6 03 0a 43 	lsr	r3,r11,r3
8000c84c:	18 42       	or	r2,r12
8000c84e:	f1 ee 10 0c 	or	r12,r8,lr
8000c852:	f8 01 16 10 	lsr	r1,r12,0x10
8000c856:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000c85a:	e6 01 0d 04 	divu	r4,r3,r1
8000c85e:	e4 03 16 10 	lsr	r3,r2,0x10
8000c862:	08 9e       	mov	lr,r4
8000c864:	e7 e5 11 03 	or	r3,r3,r5<<0x10
8000c868:	e8 06 02 48 	mul	r8,r4,r6
8000c86c:	10 33       	cp.w	r3,r8
8000c86e:	c0 a2       	brcc	8000c882 <__avr32_udiv64+0x1fe>
8000c870:	20 1e       	sub	lr,1
8000c872:	18 03       	add	r3,r12
8000c874:	18 33       	cp.w	r3,r12
8000c876:	c0 63       	brcs	8000c882 <__avr32_udiv64+0x1fe>
8000c878:	10 33       	cp.w	r3,r8
8000c87a:	f7 be 03 01 	sublo	lr,1
8000c87e:	e7 dc e3 03 	addcs	r3,r3,r12
8000c882:	10 13       	sub	r3,r8
8000c884:	f7 d2 c0 10 	bfextu	r11,r2,0x0,0x10
8000c888:	e6 01 0d 00 	divu	r0,r3,r1
8000c88c:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c890:	00 98       	mov	r8,r0
8000c892:	e0 06 02 46 	mul	r6,r0,r6
8000c896:	0c 3b       	cp.w	r11,r6
8000c898:	c0 a2       	brcc	8000c8ac <__avr32_udiv64+0x228>
8000c89a:	20 18       	sub	r8,1
8000c89c:	18 0b       	add	r11,r12
8000c89e:	18 3b       	cp.w	r11,r12
8000c8a0:	c0 63       	brcs	8000c8ac <__avr32_udiv64+0x228>
8000c8a2:	0c 3b       	cp.w	r11,r6
8000c8a4:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c8a8:	f7 b8 03 01 	sublo	r8,1
8000c8ac:	f1 ee 11 08 	or	r8,r8,lr<<0x10
8000c8b0:	ee f4 ff f4 	ld.w	r4,r7[-12]
8000c8b4:	0c 1b       	sub	r11,r6
8000c8b6:	f0 04 06 42 	mulu.d	r2,r8,r4
8000c8ba:	06 95       	mov	r5,r3
8000c8bc:	16 35       	cp.w	r5,r11
8000c8be:	e0 8b 00 0a 	brhi	8000c8d2 <__avr32_udiv64+0x24e>
8000c8c2:	5f 0b       	sreq	r11
8000c8c4:	f4 09 09 49 	lsl	r9,r10,r9
8000c8c8:	12 32       	cp.w	r2,r9
8000c8ca:	5f b9       	srhi	r9
8000c8cc:	f7 e9 00 09 	and	r9,r11,r9
8000c8d0:	c0 60       	breq	8000c8dc <__avr32_udiv64+0x258>
8000c8d2:	20 18       	sub	r8,1
8000c8d4:	30 09       	mov	r9,0
8000c8d6:	c0 38       	rjmp	8000c8dc <__avr32_udiv64+0x258>
8000c8d8:	30 09       	mov	r9,0
8000c8da:	12 98       	mov	r8,r9
8000c8dc:	10 9a       	mov	r10,r8
8000c8de:	12 93       	mov	r3,r9
8000c8e0:	10 92       	mov	r2,r8
8000c8e2:	12 9b       	mov	r11,r9
8000c8e4:	2f dd       	sub	sp,-12
8000c8e6:	d8 32       	popm	r0-r7,pc

8000c8e8 <__avr32_umod64>:
8000c8e8:	d4 31       	pushm	r0-r7,lr
8000c8ea:	1a 97       	mov	r7,sp
8000c8ec:	20 3d       	sub	sp,12
8000c8ee:	10 9c       	mov	r12,r8
8000c8f0:	12 95       	mov	r5,r9
8000c8f2:	14 9e       	mov	lr,r10
8000c8f4:	16 91       	mov	r1,r11
8000c8f6:	16 96       	mov	r6,r11
8000c8f8:	58 09       	cp.w	r9,0
8000c8fa:	e0 81 00 81 	brne	8000c9fc <__avr32_umod64+0x114>
8000c8fe:	16 38       	cp.w	r8,r11
8000c900:	e0 88 00 12 	brls	8000c924 <__avr32_umod64+0x3c>
8000c904:	f0 08 12 00 	clz	r8,r8
8000c908:	c4 e0       	breq	8000c9a4 <__avr32_umod64+0xbc>
8000c90a:	f6 08 09 46 	lsl	r6,r11,r8
8000c90e:	f8 08 09 4c 	lsl	r12,r12,r8
8000c912:	f0 0b 11 20 	rsub	r11,r8,32
8000c916:	f4 08 09 4e 	lsl	lr,r10,r8
8000c91a:	f4 0b 0a 4b 	lsr	r11,r10,r11
8000c91e:	f7 e6 10 06 	or	r6,r11,r6
8000c922:	c4 18       	rjmp	8000c9a4 <__avr32_umod64+0xbc>
8000c924:	58 08       	cp.w	r8,0
8000c926:	c0 51       	brne	8000c930 <__avr32_umod64+0x48>
8000c928:	30 19       	mov	r9,1
8000c92a:	f2 08 0d 08 	divu	r8,r9,r8
8000c92e:	10 9c       	mov	r12,r8
8000c930:	f8 08 12 00 	clz	r8,r12
8000c934:	c0 31       	brne	8000c93a <__avr32_umod64+0x52>
8000c936:	18 16       	sub	r6,r12
8000c938:	c3 68       	rjmp	8000c9a4 <__avr32_umod64+0xbc>
8000c93a:	f0 03 11 20 	rsub	r3,r8,32
8000c93e:	f4 03 0a 4b 	lsr	r11,r10,r3
8000c942:	f8 08 09 4c 	lsl	r12,r12,r8
8000c946:	ec 08 09 49 	lsl	r9,r6,r8
8000c94a:	ec 03 0a 43 	lsr	r3,r6,r3
8000c94e:	f7 e9 10 09 	or	r9,r11,r9
8000c952:	f8 05 16 10 	lsr	r5,r12,0x10
8000c956:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000c95a:	e6 05 0d 02 	divu	r2,r3,r5
8000c95e:	f2 0e 16 10 	lsr	lr,r9,0x10
8000c962:	ec 02 02 4b 	mul	r11,r6,r2
8000c966:	fd e3 11 0e 	or	lr,lr,r3<<0x10
8000c96a:	16 3e       	cp.w	lr,r11
8000c96c:	c0 72       	brcc	8000c97a <__avr32_umod64+0x92>
8000c96e:	18 0e       	add	lr,r12
8000c970:	18 3e       	cp.w	lr,r12
8000c972:	c0 43       	brcs	8000c97a <__avr32_umod64+0x92>
8000c974:	16 3e       	cp.w	lr,r11
8000c976:	fd dc e3 0e 	addcs	lr,lr,r12
8000c97a:	fc 0b 01 03 	sub	r3,lr,r11
8000c97e:	f3 d9 c0 10 	bfextu	r9,r9,0x0,0x10
8000c982:	e6 05 0d 02 	divu	r2,r3,r5
8000c986:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000c98a:	a5 36       	mul	r6,r2
8000c98c:	0c 39       	cp.w	r9,r6
8000c98e:	c0 72       	brcc	8000c99c <__avr32_umod64+0xb4>
8000c990:	18 09       	add	r9,r12
8000c992:	18 39       	cp.w	r9,r12
8000c994:	c0 43       	brcs	8000c99c <__avr32_umod64+0xb4>
8000c996:	0c 39       	cp.w	r9,r6
8000c998:	f3 dc e3 09 	addcs	r9,r9,r12
8000c99c:	f2 06 01 06 	sub	r6,r9,r6
8000c9a0:	f4 08 09 4e 	lsl	lr,r10,r8
8000c9a4:	f8 0a 16 10 	lsr	r10,r12,0x10
8000c9a8:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000c9ac:	ec 0a 0d 02 	divu	r2,r6,r10
8000c9b0:	fc 09 16 10 	lsr	r9,lr,0x10
8000c9b4:	ea 02 02 4b 	mul	r11,r5,r2
8000c9b8:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000c9bc:	16 39       	cp.w	r9,r11
8000c9be:	c0 72       	brcc	8000c9cc <__avr32_umod64+0xe4>
8000c9c0:	18 09       	add	r9,r12
8000c9c2:	18 39       	cp.w	r9,r12
8000c9c4:	c0 43       	brcs	8000c9cc <__avr32_umod64+0xe4>
8000c9c6:	16 39       	cp.w	r9,r11
8000c9c8:	f3 dc e3 09 	addcs	r9,r9,r12
8000c9cc:	f2 0b 01 0b 	sub	r11,r9,r11
8000c9d0:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000c9d4:	f6 0a 0d 0a 	divu	r10,r11,r10
8000c9d8:	fd eb 11 0e 	or	lr,lr,r11<<0x10
8000c9dc:	ea 0a 02 4a 	mul	r10,r5,r10
8000c9e0:	14 3e       	cp.w	lr,r10
8000c9e2:	c0 72       	brcc	8000c9f0 <__avr32_umod64+0x108>
8000c9e4:	18 0e       	add	lr,r12
8000c9e6:	18 3e       	cp.w	lr,r12
8000c9e8:	c0 43       	brcs	8000c9f0 <__avr32_umod64+0x108>
8000c9ea:	14 3e       	cp.w	lr,r10
8000c9ec:	fd dc e3 0e 	addcs	lr,lr,r12
8000c9f0:	fc 0a 01 0a 	sub	r10,lr,r10
8000c9f4:	30 0b       	mov	r11,0
8000c9f6:	f4 08 0a 4a 	lsr	r10,r10,r8
8000c9fa:	c7 b8       	rjmp	8000caf0 <__avr32_umod64+0x208>
8000c9fc:	16 39       	cp.w	r9,r11
8000c9fe:	e0 8b 00 79 	brhi	8000caf0 <__avr32_umod64+0x208>
8000ca02:	f2 09 12 00 	clz	r9,r9
8000ca06:	c1 21       	brne	8000ca2a <__avr32_umod64+0x142>
8000ca08:	10 3a       	cp.w	r10,r8
8000ca0a:	5f 2b       	srhs	r11
8000ca0c:	0a 31       	cp.w	r1,r5
8000ca0e:	5f ba       	srhi	r10
8000ca10:	f7 ea 10 0a 	or	r10,r11,r10
8000ca14:	f2 0a 18 00 	cp.b	r10,r9
8000ca18:	c0 60       	breq	8000ca24 <__avr32_umod64+0x13c>
8000ca1a:	fc 08 01 0c 	sub	r12,lr,r8
8000ca1e:	e2 05 01 46 	sbc	r6,r1,r5
8000ca22:	18 9e       	mov	lr,r12
8000ca24:	0c 9b       	mov	r11,r6
8000ca26:	1c 9a       	mov	r10,lr
8000ca28:	c6 48       	rjmp	8000caf0 <__avr32_umod64+0x208>
8000ca2a:	ea 09 09 4c 	lsl	r12,r5,r9
8000ca2e:	f2 06 11 20 	rsub	r6,r9,32
8000ca32:	f6 09 09 4b 	lsl	r11,r11,r9
8000ca36:	f0 09 09 42 	lsl	r2,r8,r9
8000ca3a:	ef 46 ff f4 	st.w	r7[-12],r6
8000ca3e:	f0 06 0a 48 	lsr	r8,r8,r6
8000ca42:	18 48       	or	r8,r12
8000ca44:	e2 06 0a 4c 	lsr	r12,r1,r6
8000ca48:	f4 09 09 43 	lsl	r3,r10,r9
8000ca4c:	fd d8 c0 10 	bfextu	lr,r8,0x0,0x10
8000ca50:	f4 06 0a 4a 	lsr	r10,r10,r6
8000ca54:	16 4a       	or	r10,r11
8000ca56:	f0 0b 16 10 	lsr	r11,r8,0x10
8000ca5a:	f8 0b 0d 04 	divu	r4,r12,r11
8000ca5e:	f4 0c 16 10 	lsr	r12,r10,0x10
8000ca62:	08 91       	mov	r1,r4
8000ca64:	f9 e5 11 0c 	or	r12,r12,r5<<0x10
8000ca68:	e8 0e 02 46 	mul	r6,r4,lr
8000ca6c:	0c 3c       	cp.w	r12,r6
8000ca6e:	c0 a2       	brcc	8000ca82 <__avr32_umod64+0x19a>
8000ca70:	20 11       	sub	r1,1
8000ca72:	10 0c       	add	r12,r8
8000ca74:	10 3c       	cp.w	r12,r8
8000ca76:	c0 63       	brcs	8000ca82 <__avr32_umod64+0x19a>
8000ca78:	0c 3c       	cp.w	r12,r6
8000ca7a:	f7 b1 03 01 	sublo	r1,1
8000ca7e:	f9 d8 e3 0c 	addcs	r12,r12,r8
8000ca82:	0c 1c       	sub	r12,r6
8000ca84:	f5 da c0 10 	bfextu	r10,r10,0x0,0x10
8000ca88:	f8 0b 0d 04 	divu	r4,r12,r11
8000ca8c:	f5 e5 11 0b 	or	r11,r10,r5<<0x10
8000ca90:	08 96       	mov	r6,r4
8000ca92:	e8 0e 02 4e 	mul	lr,r4,lr
8000ca96:	1c 3b       	cp.w	r11,lr
8000ca98:	c0 a2       	brcc	8000caac <__avr32_umod64+0x1c4>
8000ca9a:	20 16       	sub	r6,1
8000ca9c:	10 0b       	add	r11,r8
8000ca9e:	10 3b       	cp.w	r11,r8
8000caa0:	c0 63       	brcs	8000caac <__avr32_umod64+0x1c4>
8000caa2:	1c 3b       	cp.w	r11,lr
8000caa4:	f7 b6 03 01 	sublo	r6,1
8000caa8:	f7 d8 e3 0b 	addcs	r11,r11,r8
8000caac:	ed e1 11 01 	or	r1,r6,r1<<0x10
8000cab0:	1c 1b       	sub	r11,lr
8000cab2:	e2 02 06 40 	mulu.d	r0,r1,r2
8000cab6:	00 9e       	mov	lr,r0
8000cab8:	02 9c       	mov	r12,r1
8000caba:	16 3c       	cp.w	r12,r11
8000cabc:	e0 8b 00 08 	brhi	8000cacc <__avr32_umod64+0x1e4>
8000cac0:	5f 06       	sreq	r6
8000cac2:	06 30       	cp.w	r0,r3
8000cac4:	5f ba       	srhi	r10
8000cac6:	ed ea 00 0a 	and	r10,r6,r10
8000caca:	c0 60       	breq	8000cad6 <__avr32_umod64+0x1ee>
8000cacc:	fc 02 01 04 	sub	r4,lr,r2
8000cad0:	f8 08 01 4c 	sbc	r12,r12,r8
8000cad4:	08 9e       	mov	lr,r4
8000cad6:	e6 0e 01 0a 	sub	r10,r3,lr
8000cada:	f6 0c 01 4c 	sbc	r12,r11,r12
8000cade:	ee f1 ff f4 	ld.w	r1,r7[-12]
8000cae2:	f8 09 0a 4b 	lsr	r11,r12,r9
8000cae6:	f4 09 0a 4a 	lsr	r10,r10,r9
8000caea:	f8 01 09 4c 	lsl	r12,r12,r1
8000caee:	18 4a       	or	r10,r12
8000caf0:	2f dd       	sub	sp,-12
8000caf2:	d8 32       	popm	r0-r7,pc

Disassembly of section .exception:

8000cc00 <_evba>:
_evba:

        .org  0x000
        // Unrecoverable Exception.
_handle_Unrecoverable_Exception:
        rjmp $
8000cc00:	c0 08       	rjmp	8000cc00 <_evba>
	...

8000cc04 <_handle_TLB_Multiple_Hit>:

        .org  0x004
        // TLB Multiple Hit: UNUSED IN AVR32UC.
_handle_TLB_Multiple_Hit:
        rjmp $
8000cc04:	c0 08       	rjmp	8000cc04 <_handle_TLB_Multiple_Hit>
	...

8000cc08 <_handle_Bus_Error_Data_Fetch>:

        .org  0x008
        // Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
        rjmp $
8000cc08:	c0 08       	rjmp	8000cc08 <_handle_Bus_Error_Data_Fetch>
	...

8000cc0c <_handle_Bus_Error_Instruction_Fetch>:

        .org  0x00C
         // Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
        rjmp $
8000cc0c:	c0 08       	rjmp	8000cc0c <_handle_Bus_Error_Instruction_Fetch>
	...

8000cc10 <_handle_NMI>:

        .org  0x010
        // NMI.
_handle_NMI:
        rjmp $
8000cc10:	c0 08       	rjmp	8000cc10 <_handle_NMI>
	...

8000cc14 <_handle_Instruction_Address>:

        .org  0x014
        // Instruction Address.
_handle_Instruction_Address:
        rjmp $
8000cc14:	c0 08       	rjmp	8000cc14 <_handle_Instruction_Address>
	...

8000cc18 <_handle_ITLB_Protection>:

        .org  0x018
        // ITLB Protection.
_handle_ITLB_Protection:
        rjmp $
8000cc18:	c0 08       	rjmp	8000cc18 <_handle_ITLB_Protection>
	...

8000cc1c <_handle_Breakpoint>:

        .org  0x01C
        // Breakpoint.
_handle_Breakpoint:
        rjmp $
8000cc1c:	c0 08       	rjmp	8000cc1c <_handle_Breakpoint>
	...

8000cc20 <_handle_Illegal_Opcode>:

        .org  0x020
        // Illegal Opcode.
_handle_Illegal_Opcode:
        rjmp $
8000cc20:	c0 08       	rjmp	8000cc20 <_handle_Illegal_Opcode>
	...

8000cc24 <_handle_Unimplemented_Instruction>:

        .org  0x024
        // Unimplemented Instruction.
_handle_Unimplemented_Instruction:
        rjmp $
8000cc24:	c0 08       	rjmp	8000cc24 <_handle_Unimplemented_Instruction>
	...

8000cc28 <_handle_Privilege_Violation>:

        .org  0x028
        // Privilege Violation.
_handle_Privilege_Violation:
        rjmp $
8000cc28:	c0 08       	rjmp	8000cc28 <_handle_Privilege_Violation>
	...

8000cc2c <_handle_Floating_Point>:

        .org  0x02C
        // Floating-Point: UNUSED IN AVR32UC.
_handle_Floating_Point:
        rjmp $
8000cc2c:	c0 08       	rjmp	8000cc2c <_handle_Floating_Point>
	...

8000cc30 <_handle_Coprocessor_Absent>:

        .org  0x030
        // Coprocessor Absent: UNUSED IN AVR32UC.
_handle_Coprocessor_Absent:
        rjmp $
8000cc30:	c0 08       	rjmp	8000cc30 <_handle_Coprocessor_Absent>
	...

8000cc34 <_handle_Data_Address_Read>:

        .org  0x034
        // Data Address (Read).
_handle_Data_Address_Read:
        rjmp $
8000cc34:	c0 08       	rjmp	8000cc34 <_handle_Data_Address_Read>
	...

8000cc38 <_handle_Data_Address_Write>:

        .org  0x038
        // Data Address (Write).
_handle_Data_Address_Write:
        rjmp $
8000cc38:	c0 08       	rjmp	8000cc38 <_handle_Data_Address_Write>
	...

8000cc3c <_handle_DTLB_Protection_Read>:

        .org  0x03C
        // DTLB Protection (Read).
_handle_DTLB_Protection_Read:
        rjmp $
8000cc3c:	c0 08       	rjmp	8000cc3c <_handle_DTLB_Protection_Read>
	...

8000cc40 <_handle_DTLB_Protection_Write>:

        .org  0x040
        // DTLB Protection (Write).
_handle_DTLB_Protection_Write:
        rjmp $
8000cc40:	c0 08       	rjmp	8000cc40 <_handle_DTLB_Protection_Write>
	...

8000cc44 <_handle_DTLB_Modified>:

        .org  0x044
        // DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
        rjmp $
8000cc44:	c0 08       	rjmp	8000cc44 <_handle_DTLB_Modified>
	...

8000cc50 <_handle_ITLB_Miss>:

        .org  0x050
        // ITLB Miss: UNUSED IN AVR32UC.
_handle_ITLB_Miss:
        rjmp $
8000cc50:	c0 08       	rjmp	8000cc50 <_handle_ITLB_Miss>
	...

8000cc60 <_handle_DTLB_Miss_Read>:

        .org  0x060
        // DTLB Miss (Read): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Read:
        rjmp $
8000cc60:	c0 08       	rjmp	8000cc60 <_handle_DTLB_Miss_Read>
	...

8000cc70 <_handle_DTLB_Miss_Write>:

        .org  0x070
        // DTLB Miss (Write): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Write:
        rjmp $
8000cc70:	c0 08       	rjmp	8000cc70 <_handle_DTLB_Miss_Write>
	...

8000cd00 <_handle_Supervisor_Call>:

        .org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	lda.w   pc, SCALLYield
8000cd00:	fe cf 70 a4 	sub	pc,pc,28836

8000cd04 <_int0>:
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
	rete
.endr
8000cd04:	30 0c       	mov	r12,0
8000cd06:	fe b0 c3 c9 	rcall	80005498 <_get_interrupt_handler>
8000cd0a:	58 0c       	cp.w	r12,0
8000cd0c:	f8 0f 17 10 	movne	pc,r12
8000cd10:	d6 03       	rete

8000cd12 <_int1>:
8000cd12:	30 1c       	mov	r12,1
8000cd14:	fe b0 c3 c2 	rcall	80005498 <_get_interrupt_handler>
8000cd18:	58 0c       	cp.w	r12,0
8000cd1a:	f8 0f 17 10 	movne	pc,r12
8000cd1e:	d6 03       	rete

8000cd20 <_int2>:
8000cd20:	30 2c       	mov	r12,2
8000cd22:	fe b0 c3 bb 	rcall	80005498 <_get_interrupt_handler>
8000cd26:	58 0c       	cp.w	r12,0
8000cd28:	f8 0f 17 10 	movne	pc,r12
8000cd2c:	d6 03       	rete

8000cd2e <_int3>:
8000cd2e:	30 3c       	mov	r12,3
8000cd30:	fe b0 c3 b4 	rcall	80005498 <_get_interrupt_handler>
8000cd34:	58 0c       	cp.w	r12,0
8000cd36:	f8 0f 17 10 	movne	pc,r12
8000cd3a:	d6 03       	rete

8000cd3c <ipr_val>:
8000cd3c:	00 00 01 04 40 00 01 12 80 00 01 20 c0 00 01 2e     ....@...... ....
8000cd4c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cd5c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cd6c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cd7c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cd8c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cd9c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cdac:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cdbc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cdcc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cddc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cdec:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cdfc:	d7 03 d7 03                                         ....
