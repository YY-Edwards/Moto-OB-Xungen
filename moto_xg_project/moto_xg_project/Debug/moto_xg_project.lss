
moto_xg_project.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00002004  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         0000b58c  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .exception    00000200  8000d600  8000d600  0000da00  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       00001420  8000d800  8000d800  0000dc00  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .data         00000a4c  00000004  8000ec20  0000f404  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .bss          000049e8  00000a50  8000f66c  0000fe50  2**2
                  ALLOC
  7 .comment      00000030  00000000  00000000  0000fe50  2**0
                  CONTENTS, READONLY
  8 .debug_aranges 00001770  00000000  00000000  0000fe80  2**3
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_pubnames 000037c3  00000000  00000000  000115f0  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_info   0002dfa0  00000000  00000000  00014db3  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_abbrev 000077f7  00000000  00000000  00042d53  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   0000db9c  00000000  00000000  0004a54a  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_frame  00003fa8  00000000  00000000  000580e8  2**2
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    000081ca  00000000  00000000  0005c090  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_loc    0000fba7  00000000  00000000  0006425a  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .stack        00001000  00017000  00017000  00000400  2**0
                  ALLOC
 17 .debug_ranges 00001820  00000000  00000000  00073e08  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_trampoline>:

  .global _trampoline
  .type _trampoline, @function
_trampoline:
  // Jump to program start.
  rjmp    program_start
80000000:	e0 8f 10 00 	bral	80002000 <program_start>
	...

80002000 <program_start>:
	   // rjmp    program_start

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002000:	fe cf bb 00 	sub	pc,pc,-17664

Disassembly of section .text:

80002004 <DeviceManagement_brdcst_func>:
80002004:	19 a9       	ld.ub	r9,r12[0x2]
80002006:	30 18       	mov	r8,1
		U8 temp = 0;
		temp  = xcmp->u8[1] << 8;
		temp |= xcmp->u8[2];
		//if (temp == theXNL_Ctrlr.XNL_DeviceLogicalAddress)
		{
			if (xcmp->u8[0] == 0x01)
80002008:	f0 09 18 00 	cp.b	r9,r8
8000200c:	c0 61       	brne	80002018 <DeviceManagement_brdcst_func+0x14>
			{
				bunchofrandomstatusflags |= 0x00000002;
8000200e:	48 68       	lddpc	r8,80002024 <DeviceManagement_brdcst_func+0x20>
80002010:	70 09       	ld.w	r9,r8[0x0]
80002012:	a1 b9       	sbr	r9,0x1
80002014:	91 09       	st.w	r8[0x0],r9
80002016:	5e fc       	retal	r12
			}
			else
			{
				bunchofrandomstatusflags &= 0xFFFFFFFD;
80002018:	48 38       	lddpc	r8,80002024 <DeviceManagement_brdcst_func+0x20>
8000201a:	70 09       	ld.w	r9,r8[0x0]
8000201c:	a1 d9       	cbr	r9,0x1
8000201e:	91 09       	st.w	r8[0x0],r9
80002020:	5e fc       	retal	r12
80002022:	00 00       	add	r0,r0
80002024:	00 00       	add	r0,r0
80002026:	0e 04       	add	r4,r7

80002028 <Volume_brdcst_func>:
	//log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
	
	//log("\n\r Audio_Parameter: %x \n\r", ptr->Audio_Parameter);
	
	
}
80002028:	5e fc       	retal	r12

8000202a <AudioRoutingControl_brdcst_func>:
	//
	//log("\n\r Audio-Function: %x \n\r", xcmp->u8[3+j*2-1]);
	
	
	
}
8000202a:	5e fc       	retal	r12

8000202c <vApplicationIdleHook>:
}

void vApplicationIdleHook( void )
{
	/* This hook function does nothing but increment a counter. */
	ulIdleCycleCount++;
8000202c:	48 38       	lddpc	r8,80002038 <vApplicationIdleHook+0xc>
8000202e:	70 09       	ld.w	r9,r8[0x0]
80002030:	2f f9       	sub	r9,-1
80002032:	91 09       	st.w	r8[0x0],r9
	
}
80002034:	5e fc       	retal	r12
80002036:	00 00       	add	r0,r0
80002038:	00 00       	add	r0,r0
8000203a:	0a 6c       	and	r12,r5

8000203c <app_init>:
	//0x00,0x39


};
void app_init(void)
{	
8000203c:	d4 01       	pushm	lr
	xcmp_register_app_list(the_app_list);
8000203e:	48 cc       	lddpc	r12,8000206c <app_init+0x30>
80002040:	f0 1f 00 0c 	mcall	80002070 <app_init+0x34>
	
	//将app_payload_rx_proc更改为PCM加密功能
	payload_init( app_payload_rx_proc , app_payload_tx_proc );
80002044:	48 cb       	lddpc	r11,80002074 <app_init+0x38>
80002046:	48 dc       	lddpc	r12,80002078 <app_init+0x3c>
80002048:	f0 1f 00 0d 	mcall	8000207c <app_init+0x40>
	
	static portBASE_TYPE res = 0;
	 res = xTaskCreate(
8000204c:	30 09       	mov	r9,0
8000204e:	1a d9       	st.w	--sp,r9
80002050:	1a d9       	st.w	--sp,r9
80002052:	1a d9       	st.w	--sp,r9
80002054:	30 18       	mov	r8,1
80002056:	e0 6a 01 80 	mov	r10,384
8000205a:	48 ab       	lddpc	r11,80002080 <app_init+0x44>
8000205c:	48 ac       	lddpc	r12,80002084 <app_init+0x48>
8000205e:	f0 1f 00 0b 	mcall	80002088 <app_init+0x4c>
80002062:	48 b8       	lddpc	r8,8000208c <app_init+0x50>
80002064:	91 0c       	st.w	r8[0x0],r12
80002066:	2f dd       	sub	sp,-12
	,  384//1024//800//384
	,  NULL
	,  1
	,  NULL );
	
}
80002068:	d8 02       	popm	pc
8000206a:	00 00       	add	r0,r0
8000206c:	00 00       	add	r0,r0
8000206e:	00 08       	add	r8,r0
80002070:	80 00       	ld.sh	r0,r0[0x0]
80002072:	45 00       	lddsp	r0,sp[0x140]
80002074:	80 00       	ld.sh	r0,r0[0x0]
80002076:	20 90       	sub	r0,9
80002078:	80 00       	ld.sh	r0,r0[0x0]
8000207a:	20 a4       	sub	r4,10
8000207c:	80 00       	ld.sh	r0,r0[0x0]
8000207e:	31 9c       	mov	r12,25
80002080:	80 00       	ld.sh	r0,r0[0x0]
80002082:	d8 00       	acall	0x80
80002084:	80 00       	ld.sh	r0,r0[0x0]
80002086:	27 3c       	sub	r12,115
80002088:	80 00       	ld.sh	r0,r0[0x0]
8000208a:	74 98       	ld.w	r8,r10[0x24]
8000208c:	00 00       	add	r0,r0
8000208e:	0a 64       	and	r4,r5

80002090 <app_payload_tx_proc>:

}


static void app_payload_tx_proc(void  * payload)
{
80002090:	d4 01       	pushm	lr
  log("R");
80002092:	48 3c       	lddpc	r12,8000209c <app_payload_tx_proc+0xc>
80002094:	f0 1f 00 03 	mcall	800020a0 <app_payload_tx_proc+0x10>
  //
  //
  //set_payload_idle(payload);


}
80002098:	d8 02       	popm	pc
8000209a:	00 00       	add	r0,r0
8000209c:	80 00       	ld.sh	r0,r0[0x0]
8000209e:	d8 08       	*unknown*
800020a0:	80 00       	ld.sh	r0,r0[0x0]
800020a2:	78 5c       	ld.w	r12,r12[0x14]

800020a4 <app_payload_rx_proc>:
}



static void app_payload_rx_proc(void  * payload)
{
800020a4:	d4 01       	pushm	lr
	static  U8 times_counter = 0;
	
	times_counter++;
800020a6:	48 99       	lddpc	r9,800020c8 <app_payload_rx_proc+0x24>
800020a8:	13 88       	ld.ub	r8,r9[0x0]
800020aa:	2f f8       	sub	r8,-1
800020ac:	b2 88       	st.b	r9[0x0],r8
	if (times_counter == 3)
800020ae:	30 39       	mov	r9,3
800020b0:	f2 08 18 00 	cp.b	r8,r9
800020b4:	c0 71       	brne	800020c2 <app_payload_rx_proc+0x1e>
	{
		times_counter = 0 ;
800020b6:	30 09       	mov	r9,0
800020b8:	48 48       	lddpc	r8,800020c8 <app_payload_rx_proc+0x24>
800020ba:	b0 89       	st.b	r8[0x0],r9
		log("\n\r w: \n\r");
800020bc:	48 4c       	lddpc	r12,800020cc <app_payload_rx_proc+0x28>
800020be:	f0 1f 00 05 	mcall	800020d0 <app_payload_rx_proc+0x2c>
	}
	//log("\n\r w: \n\r");
	if (AMBE_tx_flag)//本地发送方的mic录音
800020c2:	48 58       	lddpc	r8,800020d4 <app_payload_rx_proc+0x30>
800020c4:	11 88       	ld.ub	r8,r8[0x0]
	}
	
	//payload_fragment_t * ptr = (payload_fragment_t *)payload;
	//set_payload_idle(payload);

}
800020c6:	d8 02       	popm	pc
800020c8:	00 00       	add	r0,r0
800020ca:	0a 56       	eor	r6,r5
800020cc:	80 00       	ld.sh	r0,r0[0x0]
800020ce:	d8 0c       	*unknown*
800020d0:	80 00       	ld.sh	r0,r0[0x0]
800020d2:	78 5c       	ld.w	r12,r12[0x14]
800020d4:	00 00       	add	r0,r0
800020d6:	0a 53       	eor	r3,r5

800020d8 <FD_brdcst_func>:
	
	
}

void FD_brdcst_func(xcmp_fragment_t * xcmp)
{
800020d8:	d4 01       	pushm	lr
	
	
	log("\n\r Forward Data Broadcast \n\r");
800020da:	48 3c       	lddpc	r12,800020e4 <FD_brdcst_func+0xc>
800020dc:	f0 1f 00 03 	mcall	800020e8 <FD_brdcst_func+0x10>
	
}
800020e0:	d8 02       	popm	pc
800020e2:	00 00       	add	r0,r0
800020e4:	80 00       	ld.sh	r0,r0[0x0]
800020e6:	d8 18       	*unknown*
800020e8:	80 00       	ld.sh	r0,r0[0x0]
800020ea:	78 5c       	ld.w	r12,r12[0x14]

800020ec <FD_reply_func>:
	
	
}

void FD_reply_func(xcmp_fragment_t * xcmp)
{
800020ec:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Reply \n\r");
800020ee:	48 3c       	lddpc	r12,800020f8 <FD_reply_func+0xc>
800020f0:	f0 1f 00 03 	mcall	800020fc <FD_reply_func+0x10>
	
	
}
800020f4:	d8 02       	popm	pc
800020f6:	00 00       	add	r0,r0
800020f8:	80 00       	ld.sh	r0,r0[0x0]
800020fa:	d8 38       	*unknown*
800020fc:	80 00       	ld.sh	r0,r0[0x0]
800020fe:	78 5c       	ld.w	r12,r12[0x14]

80002100 <FD_request_func>:
}



void FD_request_func(xcmp_fragment_t * xcmp)
{
80002100:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Request \n\r");
80002102:	48 3c       	lddpc	r12,8000210c <FD_request_func+0xc>
80002104:	f0 1f 00 03 	mcall	80002110 <FD_request_func+0x10>
	
	
}
80002108:	d8 02       	popm	pc
8000210a:	00 00       	add	r0,r0
8000210c:	80 00       	ld.sh	r0,r0[0x0]
8000210e:	d8 54       	*unknown*
80002110:	80 00       	ld.sh	r0,r0[0x0]
80002112:	78 5c       	ld.w	r12,r12[0x14]

80002114 <EnOB_brdcst_func>:
	
	
}

void EnOB_brdcst_func(xcmp_fragment_t * xcmp)
{
80002114:	d4 01       	pushm	lr
	
	
	log("\n\r En_OB Broadcast \n\r");
80002116:	48 3c       	lddpc	r12,80002120 <EnOB_brdcst_func+0xc>
80002118:	f0 1f 00 03 	mcall	80002124 <EnOB_brdcst_func+0x10>
}
8000211c:	d8 02       	popm	pc
8000211e:	00 00       	add	r0,r0
80002120:	80 00       	ld.sh	r0,r0[0x0]
80002122:	d8 70       	acall	0x87
80002124:	80 00       	ld.sh	r0,r0[0x0]
80002126:	78 5c       	ld.w	r12,r12[0x14]

80002128 <EnOB_reply_func>:
}



void EnOB_reply_func(xcmp_fragment_t * xcmp)
{
80002128:	eb cd 40 80 	pushm	r7,lr
8000212c:	18 97       	mov	r7,r12
		/*point to xcmp payload*/
	//En_OB_Control_reply_t *ptr = (En_OB_Control_reply_t* )xcmp->u8;
	//log("\n\r Xcmp_opcode: %x \n\r", xcmp->xcmp_opcode);
	
	if (xcmp->u8[0]== xcmp_Res_Success)
8000212e:	19 a9       	ld.ub	r9,r12[0x2]
80002130:	30 08       	mov	r8,0
80002132:	f0 09 18 00 	cp.b	r9,r8
80002136:	c1 91       	brne	80002168 <EnOB_reply_func+0x40>
	{
		if (xcmp->u8[1] == EN_OB_Enter)
80002138:	19 b8       	ld.ub	r8,r12[0x3]
8000213a:	30 19       	mov	r9,1
8000213c:	f2 08 18 00 	cp.b	r8,r9
80002140:	c0 61       	brne	8000214c <EnOB_reply_func+0x24>
		{
		
			log("\n\r En_OB_Enter OK \n\r");
80002142:	49 0c       	lddpc	r12,80002180 <EnOB_reply_func+0x58>
80002144:	f0 1f 00 10 	mcall	80002184 <EnOB_reply_func+0x5c>
80002148:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else if (xcmp->u8[1] == EN_OB_Exit )
8000214c:	58 08       	cp.w	r8,0
8000214e:	c0 61       	brne	8000215a <EnOB_reply_func+0x32>
		{
			log("\n\r En_OB_Exit OK \n\r");
80002150:	48 ec       	lddpc	r12,80002188 <EnOB_reply_func+0x60>
80002152:	f0 1f 00 0d 	mcall	80002184 <EnOB_reply_func+0x5c>
80002156:	e3 cd 80 80 	ldm	sp++,r7,pc
		}
		else
		{
			
			log("\n\r En_OB_Control: %x \n\r", xcmp->u8[1]);
8000215a:	1a d8       	st.w	--sp,r8
8000215c:	48 cc       	lddpc	r12,8000218c <EnOB_reply_func+0x64>
8000215e:	f0 1f 00 0a 	mcall	80002184 <EnOB_reply_func+0x5c>
80002162:	2f fd       	sub	sp,-4
80002164:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r En_OB_Control error \n\r");
80002168:	48 ac       	lddpc	r12,80002190 <EnOB_reply_func+0x68>
8000216a:	f0 1f 00 07 	mcall	80002184 <EnOB_reply_func+0x5c>
		log("\n\r En_OB_result: %x \n\r", xcmp->u8[0]);
8000216e:	0f a8       	ld.ub	r8,r7[0x2]
80002170:	1a d8       	st.w	--sp,r8
80002172:	48 9c       	lddpc	r12,80002194 <EnOB_reply_func+0x6c>
80002174:	f0 1f 00 04 	mcall	80002184 <EnOB_reply_func+0x5c>
80002178:	2f fd       	sub	sp,-4
8000217a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000217e:	00 00       	add	r0,r0
80002180:	80 00       	ld.sh	r0,r0[0x0]
80002182:	d8 88       	*unknown*
80002184:	80 00       	ld.sh	r0,r0[0x0]
80002186:	78 5c       	ld.w	r12,r12[0x14]
80002188:	80 00       	ld.sh	r0,r0[0x0]
8000218a:	d8 a0       	acall	0x8a
8000218c:	80 00       	ld.sh	r0,r0[0x0]
8000218e:	d8 b4       	*unknown*
80002190:	80 00       	ld.sh	r0,r0[0x0]
80002192:	d8 cc       	*unknown*
80002194:	80 00       	ld.sh	r0,r0[0x0]
80002196:	d8 e8       	*unknown*

80002198 <SingleDetection_brdcst_func>:
	
}


void SingleDetection_brdcst_func(xcmp_fragment_t * xcmp)
{
80002198:	eb cd 40 80 	pushm	r7,lr
8000219c:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == 0x11)
8000219e:	19 a9       	ld.ub	r9,r12[0x2]
800021a0:	31 18       	mov	r8,17
800021a2:	f0 09 18 00 	cp.b	r9,r8
800021a6:	c0 91       	brne	800021b8 <SingleDetection_brdcst_func+0x20>
	{
		log("\n\r DMR_CSBK OK \n\r");
800021a8:	48 ac       	lddpc	r12,800021d0 <SingleDetection_brdcst_func+0x38>
800021aa:	f0 1f 00 0b 	mcall	800021d4 <SingleDetection_brdcst_func+0x3c>
		get_time_okay = TRUE;
800021ae:	30 19       	mov	r9,1
800021b0:	48 a8       	lddpc	r8,800021d8 <SingleDetection_brdcst_func+0x40>
800021b2:	b0 89       	st.b	r8[0x0],r9
800021b4:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	//if(xcmp->u8[1] == 0x11)
	else
	{
		log("SIGBRCST error\n");
800021b8:	48 9c       	lddpc	r12,800021dc <SingleDetection_brdcst_func+0x44>
800021ba:	f0 1f 00 07 	mcall	800021d4 <SingleDetection_brdcst_func+0x3c>
		log("\Signal_type: %X \n\r", xcmp->u8[0] );
800021be:	0f a8       	ld.ub	r8,r7[0x2]
800021c0:	1a d8       	st.w	--sp,r8
800021c2:	48 8c       	lddpc	r12,800021e0 <SingleDetection_brdcst_func+0x48>
800021c4:	f0 1f 00 04 	mcall	800021d4 <SingleDetection_brdcst_func+0x3c>
800021c8:	2f fd       	sub	sp,-4
800021ca:	e3 cd 80 80 	ldm	sp++,r7,pc
800021ce:	00 00       	add	r0,r0
800021d0:	80 00       	ld.sh	r0,r0[0x0]
800021d2:	d9 00       	acall	0x90
800021d4:	80 00       	ld.sh	r0,r0[0x0]
800021d6:	78 5c       	ld.w	r12,r12[0x14]
800021d8:	00 00       	add	r0,r0
800021da:	00 04       	add	r4,r0
800021dc:	80 00       	ld.sh	r0,r0[0x0]
800021de:	d9 14       	*unknown*
800021e0:	80 00       	ld.sh	r0,r0[0x0]
800021e2:	d9 24       	*unknown*

800021e4 <ButtonConfig_brdcst_func>:
	
}


void ButtonConfig_brdcst_func(xcmp_fragment_t * xcmp)
{
800021e4:	d4 31       	pushm	r0-r7,lr
	U8 Num_Button =0;
	U8 i = 0 ;
	/*point to xcmp payload*/
	ButtonConfig_brdcst_t  *ptr = (ButtonConfig_brdcst_t* )xcmp->u8;
800021e6:	f8 c7 ff fe 	sub	r7,r12,-2
	
	Num_Button = ptr->NumOfButtons;
800021ea:	0f 95       	ld.ub	r5,r7[0x1]
	
	log("\n\r ButtonConfig_broadcast  \n\r"  );
800021ec:	4a bc       	lddpc	r12,80002298 <ButtonConfig_brdcst_func+0xb4>
800021ee:	f0 1f 00 2c 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r Function: %X \n\r" , ptr->Function );
800021f2:	0f 88       	ld.ub	r8,r7[0x0]
800021f4:	1a d8       	st.w	--sp,r8
800021f6:	4a bc       	lddpc	r12,800022a0 <ButtonConfig_brdcst_func+0xbc>
800021f8:	f0 1f 00 29 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
800021fc:	1a d5       	st.w	--sp,r5
800021fe:	4a ac       	lddpc	r12,800022a4 <ButtonConfig_brdcst_func+0xc0>
80002200:	f0 1f 00 27 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
80002204:	0f a8       	ld.ub	r8,r7[0x2]
80002206:	1a d8       	st.w	--sp,r8
80002208:	4a 8c       	lddpc	r12,800022a8 <ButtonConfig_brdcst_func+0xc4>
8000220a:	f0 1f 00 25 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
	
	for (i; i<Num_Button; i++)
8000220e:	2f dd       	sub	sp,-12
80002210:	58 05       	cp.w	r5,0
80002212:	c4 10       	breq	80002294 <ButtonConfig_brdcst_func+0xb0>
80002214:	30 06       	mov	r6,0
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
80002216:	4a 64       	lddpc	r4,800022ac <ButtonConfig_brdcst_func+0xc8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
80002218:	4a 63       	lddpc	r3,800022b0 <ButtonConfig_brdcst_func+0xcc>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
8000221a:	4a 72       	lddpc	r2,800022b4 <ButtonConfig_brdcst_func+0xd0>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
8000221c:	4a 71       	lddpc	r1,800022b8 <ButtonConfig_brdcst_func+0xd4>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
8000221e:	4a 80       	lddpc	r0,800022bc <ButtonConfig_brdcst_func+0xd8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
80002220:	0f b9       	ld.ub	r9,r7[0x3]
80002222:	0f c8       	ld.ub	r8,r7[0x4]
80002224:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002228:	1a d8       	st.w	--sp,r8
8000222a:	1a d6       	st.w	--sp,r6
8000222c:	08 9c       	mov	r12,r4
8000222e:	f0 1f 00 1c 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
80002232:	0f d9       	ld.ub	r9,r7[0x5]
80002234:	0f e8       	ld.ub	r8,r7[0x6]
80002236:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000223a:	1a d8       	st.w	--sp,r8
8000223c:	1a d6       	st.w	--sp,r6
8000223e:	06 9c       	mov	r12,r3
80002240:	f0 1f 00 17 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
80002244:	0f f9       	ld.ub	r9,r7[0x7]
80002246:	ef 38 00 08 	ld.ub	r8,r7[8]
8000224a:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000224e:	1a d8       	st.w	--sp,r8
80002250:	1a d6       	st.w	--sp,r6
80002252:	04 9c       	mov	r12,r2
80002254:	f0 1f 00 12 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
80002258:	ef 39 00 09 	ld.ub	r9,r7[9]
8000225c:	ef 38 00 0a 	ld.ub	r8,r7[10]
80002260:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002264:	1a d8       	st.w	--sp,r8
80002266:	1a d6       	st.w	--sp,r6
80002268:	02 9c       	mov	r12,r1
8000226a:	f0 1f 00 0d 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
8000226e:	2f 8d       	sub	sp,-32
80002270:	ef 39 00 0b 	ld.ub	r9,r7[11]
80002274:	ef 38 00 0c 	ld.ub	r8,r7[12]
80002278:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000227c:	1a d8       	st.w	--sp,r8
8000227e:	1a d6       	st.w	--sp,r6
80002280:	00 9c       	mov	r12,r0
80002282:	f0 1f 00 07 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
80002286:	2f f6       	sub	r6,-1
80002288:	2f 67       	sub	r7,-10
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
8000228a:	2f ed       	sub	sp,-8
8000228c:	ec 05 18 00 	cp.b	r5,r6
80002290:	fe 9b ff c8 	brhi	80002220 <ButtonConfig_brdcst_func+0x3c>
80002294:	d8 32       	popm	r0-r7,pc
80002296:	00 00       	add	r0,r0
80002298:	80 00       	ld.sh	r0,r0[0x0]
8000229a:	d9 38       	*unknown*
8000229c:	80 00       	ld.sh	r0,r0[0x0]
8000229e:	78 5c       	ld.w	r12,r12[0x14]
800022a0:	80 00       	ld.sh	r0,r0[0x0]
800022a2:	d9 58       	*unknown*
800022a4:	80 00       	ld.sh	r0,r0[0x0]
800022a6:	d9 6c       	*unknown*
800022a8:	80 00       	ld.sh	r0,r0[0x0]
800022aa:	d9 84       	*unknown*
800022ac:	80 00       	ld.sh	r0,r0[0x0]
800022ae:	d9 a4       	*unknown*
800022b0:	80 00       	ld.sh	r0,r0[0x0]
800022b2:	d9 cc       	*unknown*
800022b4:	80 00       	ld.sh	r0,r0[0x0]
800022b6:	d9 f4       	*unknown*
800022b8:	80 00       	ld.sh	r0,r0[0x0]
800022ba:	da 18       	*unknown*
800022bc:	80 00       	ld.sh	r0,r0[0x0]
800022be:	da 40       	acall	0xa4

800022c0 <ButtonConfig_reply_func>:
	}
	
}

void ButtonConfig_reply_func(xcmp_fragment_t * xcmp)
{
800022c0:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	ButtonConfig_reply_t *ptr = (ButtonConfig_reply_t* )(xcmp->u8);
800022c4:	f8 c7 ff fe 	sub	r7,r12,-2
	if (ptr->Result == xcmp_Res_Success)
800022c8:	0f 89       	ld.ub	r9,r7[0x0]
800022ca:	30 08       	mov	r8,0
800022cc:	f0 09 18 00 	cp.b	r9,r8
800022d0:	c0 c1       	brne	800022e8 <ButtonConfig_reply_func+0x28>
	{
		log("\n\r Button_Config OK \n\r");
800022d2:	48 9c       	lddpc	r12,800022f4 <ButtonConfig_reply_func+0x34>
800022d4:	f0 1f 00 09 	mcall	800022f8 <ButtonConfig_reply_func+0x38>
		
		log("\n\r Function: %X \n\r" , ptr->Function );
800022d8:	0f 98       	ld.ub	r8,r7[0x1]
800022da:	1a d8       	st.w	--sp,r8
800022dc:	48 8c       	lddpc	r12,800022fc <ButtonConfig_reply_func+0x3c>
800022de:	f0 1f 00 07 	mcall	800022f8 <ButtonConfig_reply_func+0x38>
800022e2:	2f fd       	sub	sp,-4
800022e4:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r Button_Request error \n\r");
800022e8:	48 6c       	lddpc	r12,80002300 <ButtonConfig_reply_func+0x40>
800022ea:	f0 1f 00 04 	mcall	800022f8 <ButtonConfig_reply_func+0x38>
800022ee:	e3 cd 80 80 	ldm	sp++,r7,pc
800022f2:	00 00       	add	r0,r0
800022f4:	80 00       	ld.sh	r0,r0[0x0]
800022f6:	da 64       	*unknown*
800022f8:	80 00       	ld.sh	r0,r0[0x0]
800022fa:	78 5c       	ld.w	r12,r12[0x14]
800022fc:	80 00       	ld.sh	r0,r0[0x0]
800022fe:	d9 58       	*unknown*
80002300:	80 00       	ld.sh	r0,r0[0x0]
80002302:	da 7c       	*unknown*

80002304 <DataSession_reply_func>:
	
	
}

void DataSession_reply_func(xcmp_fragment_t * xcmp)
{
80002304:	eb cd 40 80 	pushm	r7,lr
80002308:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
8000230a:	19 a9       	ld.ub	r9,r12[0x2]
8000230c:	30 08       	mov	r8,0
8000230e:	f0 09 18 00 	cp.b	r9,r8
80002312:	c1 11       	brne	80002334 <DataSession_reply_func+0x30>
	{
		log("DATArep OK \n");
80002314:	49 3c       	lddpc	r12,80002360 <DataSession_reply_func+0x5c>
80002316:	f0 1f 00 14 	mcall	80002364 <DataSession_reply_func+0x60>
		log("Func: %X \n", xcmp->u8[1]);
8000231a:	0f b8       	ld.ub	r8,r7[0x3]
8000231c:	1a d8       	st.w	--sp,r8
8000231e:	49 3c       	lddpc	r12,80002368 <DataSession_reply_func+0x64>
80002320:	f0 1f 00 11 	mcall	80002364 <DataSession_reply_func+0x60>
		log("ID: %X \n", xcmp->u8[2]);
80002324:	0f c8       	ld.ub	r8,r7[0x4]
80002326:	1a d8       	st.w	--sp,r8
80002328:	49 1c       	lddpc	r12,8000236c <DataSession_reply_func+0x68>
8000232a:	f0 1f 00 0f 	mcall	80002364 <DataSession_reply_func+0x60>
8000232e:	2f ed       	sub	sp,-8
80002330:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	else
	{	
		log("DATArep error \n");
80002334:	48 fc       	lddpc	r12,80002370 <DataSession_reply_func+0x6c>
80002336:	f0 1f 00 0c 	mcall	80002364 <DataSession_reply_func+0x60>
		log("Result:  %X \n", xcmp->u8[0]);
8000233a:	0f a8       	ld.ub	r8,r7[0x2]
8000233c:	1a d8       	st.w	--sp,r8
8000233e:	48 ec       	lddpc	r12,80002374 <DataSession_reply_func+0x70>
80002340:	f0 1f 00 09 	mcall	80002364 <DataSession_reply_func+0x60>
		log("Func:  %X \n", xcmp->u8[1]);
80002344:	0f b8       	ld.ub	r8,r7[0x3]
80002346:	1a d8       	st.w	--sp,r8
80002348:	48 cc       	lddpc	r12,80002378 <DataSession_reply_func+0x74>
8000234a:	f0 1f 00 07 	mcall	80002364 <DataSession_reply_func+0x60>
		log("ID:  %X \n", xcmp->u8[2]);
8000234e:	0f c8       	ld.ub	r8,r7[0x4]
80002350:	1a d8       	st.w	--sp,r8
80002352:	48 bc       	lddpc	r12,8000237c <DataSession_reply_func+0x78>
80002354:	f0 1f 00 04 	mcall	80002364 <DataSession_reply_func+0x60>
80002358:	2f dd       	sub	sp,-12
8000235a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000235e:	00 00       	add	r0,r0
80002360:	80 00       	ld.sh	r0,r0[0x0]
80002362:	da 98       	*unknown*
80002364:	80 00       	ld.sh	r0,r0[0x0]
80002366:	78 5c       	ld.w	r12,r12[0x14]
80002368:	80 00       	ld.sh	r0,r0[0x0]
8000236a:	da a8       	*unknown*
8000236c:	80 00       	ld.sh	r0,r0[0x0]
8000236e:	da b4       	*unknown*
80002370:	80 00       	ld.sh	r0,r0[0x0]
80002372:	da c0       	acall	0xac
80002374:	80 00       	ld.sh	r0,r0[0x0]
80002376:	da d0       	acall	0xad
80002378:	80 00       	ld.sh	r0,r0[0x0]
8000237a:	da e0       	acall	0xae
8000237c:	80 00       	ld.sh	r0,r0[0x0]
8000237e:	da ec       	*unknown*

80002380 <CallControl_brdcst_func>:
	
}


void CallControl_brdcst_func(xcmp_fragment_t * xcmp)
{
80002380:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	CallControl_brdcst_t *ptr = (CallControl_brdcst_t* )xcmp->u8;
80002384:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  CallControl brst \n\r ");
	//log("\n\r  Call_type: %x \n\r ", ptr->Calltype );
	log("\n\r  Call_state: %x \n\r ", ptr->Callstate );
80002388:	0f 98       	ld.ub	r8,r7[0x1]
8000238a:	1a d8       	st.w	--sp,r8
8000238c:	48 bc       	lddpc	r12,800023b8 <CallControl_brdcst_func+0x38>
8000238e:	f0 1f 00 0c 	mcall	800023bc <CallControl_brdcst_func+0x3c>
	if (ptr->Callstate == Call_Ended)//0x03
80002392:	2f fd       	sub	sp,-4
80002394:	0f 99       	ld.ub	r9,r7[0x1]
80002396:	30 38       	mov	r8,3
80002398:	f0 09 18 00 	cp.b	r9,r8
8000239c:	c0 41       	brne	800023a4 <CallControl_brdcst_func+0x24>
	{
		//恢复正常语音路径通道
		//xcmp_audio_route_revert();
		Call_Begin = 0;
8000239e:	30 09       	mov	r9,0
800023a0:	48 88       	lddpc	r8,800023c0 <CallControl_brdcst_func+0x40>
800023a2:	b0 89       	st.b	r8[0x0],r9
		
	}
	
	if (ptr->Callstate == Call_Initiated)//0x04
800023a4:	0f 99       	ld.ub	r9,r7[0x1]
800023a6:	30 48       	mov	r8,4
800023a8:	f0 09 18 00 	cp.b	r9,r8
800023ac:	c0 41       	brne	800023b4 <CallControl_brdcst_func+0x34>
	{
		Call_Begin = 1;
800023ae:	30 19       	mov	r9,1
800023b0:	48 48       	lddpc	r8,800023c0 <CallControl_brdcst_func+0x40>
800023b2:	b0 89       	st.b	r8[0x0],r9
800023b4:	e3 cd 80 80 	ldm	sp++,r7,pc
800023b8:	80 00       	ld.sh	r0,r0[0x0]
800023ba:	da f8       	*unknown*
800023bc:	80 00       	ld.sh	r0,r0[0x0]
800023be:	78 5c       	ld.w	r12,r12[0x14]
800023c0:	00 00       	add	r0,r0
800023c2:	0a 55       	eor	r5,r5

800023c4 <TransmitControl_brdcst_func>:

}


void TransmitControl_brdcst_func(xcmp_fragment_t * xcmp)
{
800023c4:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	TransmitControl_brdcast_t *ptr = (TransmitControl_brdcast_t* )xcmp->u8;
800023c8:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  TransmitControl broadcast \n\r ");
	//log("\n\r  Mode_Of_Operation: %x \n\r ", ptr->Mode_Of_Operation );
	if (ptr->State == 0x00)
800023cc:	0f 99       	ld.ub	r9,r7[0x1]
800023ce:	30 08       	mov	r8,0
800023d0:	f0 09 18 00 	cp.b	r9,r8
800023d4:	c0 71       	brne	800023e2 <TransmitControl_brdcst_func+0x1e>
	{
		log("\n\r  Standby-Receive \n\r ");
800023d6:	48 ac       	lddpc	r12,800023fc <TransmitControl_brdcst_func+0x38>
800023d8:	f0 1f 00 0a 	mcall	80002400 <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 0;
800023dc:	30 09       	mov	r9,0
800023de:	48 a8       	lddpc	r8,80002404 <TransmitControl_brdcst_func+0x40>
800023e0:	b0 89       	st.b	r8[0x0],r9
	}
	if (ptr->State == 0x01)
800023e2:	0f 99       	ld.ub	r9,r7[0x1]
800023e4:	30 18       	mov	r8,1
800023e6:	f0 09 18 00 	cp.b	r9,r8
800023ea:	c0 71       	brne	800023f8 <TransmitControl_brdcst_func+0x34>
	{
		log("\n\r  Transmit \n\r ");
800023ec:	48 7c       	lddpc	r12,80002408 <TransmitControl_brdcst_func+0x44>
800023ee:	f0 1f 00 05 	mcall	80002400 <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 1;
800023f2:	30 19       	mov	r9,1
800023f4:	48 48       	lddpc	r8,80002404 <TransmitControl_brdcst_func+0x40>
800023f6:	b0 89       	st.b	r8[0x0],r9
800023f8:	e3 cd 80 80 	ldm	sp++,r7,pc
800023fc:	80 00       	ld.sh	r0,r0[0x0]
800023fe:	db 10       	acall	0xb1
80002400:	80 00       	ld.sh	r0,r0[0x0]
80002402:	78 5c       	ld.w	r12,r12[0x14]
80002404:	00 00       	add	r0,r0
80002406:	0a 54       	eor	r4,r5
80002408:	80 00       	ld.sh	r0,r0[0x0]
8000240a:	db 28       	*unknown*

8000240c <TransmitControl_reply_func>:




void TransmitControl_reply_func(xcmp_fragment_t * xcmp)
{
8000240c:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	TransmitControl_reply_t *ptr = (TransmitControl_reply_t* )xcmp->u8;
80002410:	f8 c7 ff fe 	sub	r7,r12,-2
	
	if (ptr->Result == xcmp_Res_Success)
80002414:	0f 89       	ld.ub	r9,r7[0x0]
80002416:	30 08       	mov	r8,0
80002418:	f0 09 18 00 	cp.b	r9,r8
8000241c:	c1 61       	brne	80002448 <TransmitControl_reply_func+0x3c>
	{
		
		log("\n\r  TransmitControl OK \n\r ");
8000241e:	48 ec       	lddpc	r12,80002454 <TransmitControl_reply_func+0x48>
80002420:	f0 1f 00 0e 	mcall	80002458 <TransmitControl_reply_func+0x4c>
		log("\n\r Function: %x \n\r", ptr->Function);
80002424:	0f 98       	ld.ub	r8,r7[0x1]
80002426:	1a d8       	st.w	--sp,r8
80002428:	48 dc       	lddpc	r12,8000245c <TransmitControl_reply_func+0x50>
8000242a:	f0 1f 00 0c 	mcall	80002458 <TransmitControl_reply_func+0x4c>
		log("\n\r Mode of Operation: %x \n\r", ptr->Mode_Of_Operation);
8000242e:	0f a8       	ld.ub	r8,r7[0x2]
80002430:	1a d8       	st.w	--sp,r8
80002432:	48 cc       	lddpc	r12,80002460 <TransmitControl_reply_func+0x54>
80002434:	f0 1f 00 09 	mcall	80002458 <TransmitControl_reply_func+0x4c>
		log("\n\r State: %x \n\r", ptr->State);
80002438:	0f b8       	ld.ub	r8,r7[0x3]
8000243a:	1a d8       	st.w	--sp,r8
8000243c:	48 ac       	lddpc	r12,80002464 <TransmitControl_reply_func+0x58>
8000243e:	f0 1f 00 07 	mcall	80002458 <TransmitControl_reply_func+0x4c>
80002442:	2f dd       	sub	sp,-12
80002444:	e3 cd 80 80 	ldm	sp++,r7,pc
		
		//Silent_flag = 1;
	}
	else
	{
		log("TransmitControl error");
80002448:	48 8c       	lddpc	r12,80002468 <TransmitControl_reply_func+0x5c>
8000244a:	f0 1f 00 04 	mcall	80002458 <TransmitControl_reply_func+0x4c>
8000244e:	e3 cd 80 80 	ldm	sp++,r7,pc
80002452:	00 00       	add	r0,r0
80002454:	80 00       	ld.sh	r0,r0[0x0]
80002456:	db 3c       	*unknown*
80002458:	80 00       	ld.sh	r0,r0[0x0]
8000245a:	78 5c       	ld.w	r12,r12[0x14]
8000245c:	80 00       	ld.sh	r0,r0[0x0]
8000245e:	db 58       	*unknown*
80002460:	80 00       	ld.sh	r0,r0[0x0]
80002462:	db 6c       	*unknown*
80002464:	80 00       	ld.sh	r0,r0[0x0]
80002466:	db 88       	*unknown*
80002468:	80 00       	ld.sh	r0,r0[0x0]
8000246a:	db 98       	*unknown*

8000246c <AudioRoutingControl_reply_func>:
	
}


void AudioRoutingControl_reply_func(xcmp_fragment_t * xcmp)
{
8000246c:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
8000246e:	19 a9       	ld.ub	r9,r12[0x2]
80002470:	30 08       	mov	r8,0
80002472:	f0 09 18 00 	cp.b	r9,r8
80002476:	c0 51       	brne	80002480 <AudioRoutingControl_reply_func+0x14>
	{
		log("AudioRouting OK");
80002478:	48 4c       	lddpc	r12,80002488 <AudioRoutingControl_reply_func+0x1c>
8000247a:	f0 1f 00 05 	mcall	8000248c <AudioRoutingControl_reply_func+0x20>
8000247e:	d8 02       	popm	pc
		//xcmp_IdleTestTone();
		//Speaker_is_unmute = 1;
	}
	else
	{
		log("AudioRouting error");
80002480:	48 4c       	lddpc	r12,80002490 <AudioRoutingControl_reply_func+0x24>
80002482:	f0 1f 00 03 	mcall	8000248c <AudioRoutingControl_reply_func+0x20>
80002486:	d8 02       	popm	pc
80002488:	80 00       	ld.sh	r0,r0[0x0]
8000248a:	db b0       	acall	0xbb
8000248c:	80 00       	ld.sh	r0,r0[0x0]
8000248e:	78 5c       	ld.w	r12,r12[0x14]
80002490:	80 00       	ld.sh	r0,r0[0x0]
80002492:	db c0       	acall	0xbc

80002494 <Volume_reply_func>:
	
}


void Volume_reply_func(xcmp_fragment_t * xcmp)
{
80002494:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	VolumeControl_reply_t *ptr = (VolumeControl_reply_t* )xcmp->u8;
80002498:	f8 c7 ff fe 	sub	r7,r12,-2
	
		if (ptr->Result == xcmp_Res_Success)
8000249c:	0f 89       	ld.ub	r9,r7[0x0]
8000249e:	30 08       	mov	r8,0
800024a0:	f0 09 18 00 	cp.b	r9,r8
800024a4:	c1 b1       	brne	800024da <Volume_reply_func+0x46>
		{
			if (ptr->Function == Enable_IntelligentAudio)
800024a6:	0f b8       	ld.ub	r8,r7[0x3]
800024a8:	31 09       	mov	r9,16
800024aa:	f2 08 18 00 	cp.b	r8,r9
800024ae:	c0 f1       	brne	800024cc <Volume_reply_func+0x38>
			{
				log("\n\r Enable_IA OK \n\r");
800024b0:	48 dc       	lddpc	r12,800024e4 <Volume_reply_func+0x50>
800024b2:	f0 1f 00 0e 	mcall	800024e8 <Volume_reply_func+0x54>
				log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
800024b6:	0f 99       	ld.ub	r9,r7[0x1]
800024b8:	0f a8       	ld.ub	r8,r7[0x2]
800024ba:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800024be:	1a d8       	st.w	--sp,r8
800024c0:	48 bc       	lddpc	r12,800024ec <Volume_reply_func+0x58>
800024c2:	f0 1f 00 0a 	mcall	800024e8 <Volume_reply_func+0x54>
800024c6:	2f fd       	sub	sp,-4
800024c8:	e3 cd 80 80 	ldm	sp++,r7,pc
	
			}
			else
			{
				
				log("\n\r VolumeControl: %x \n\r", ptr->Function);
800024cc:	1a d8       	st.w	--sp,r8
800024ce:	48 9c       	lddpc	r12,800024f0 <Volume_reply_func+0x5c>
800024d0:	f0 1f 00 06 	mcall	800024e8 <Volume_reply_func+0x54>
800024d4:	2f fd       	sub	sp,-4
800024d6:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		
		else
		{
			log("\n\r Enable_IA error \n\r");
800024da:	48 7c       	lddpc	r12,800024f4 <Volume_reply_func+0x60>
800024dc:	f0 1f 00 03 	mcall	800024e8 <Volume_reply_func+0x54>
800024e0:	e3 cd 80 80 	ldm	sp++,r7,pc
800024e4:	80 00       	ld.sh	r0,r0[0x0]
800024e6:	db d4       	*unknown*
800024e8:	80 00       	ld.sh	r0,r0[0x0]
800024ea:	78 5c       	ld.w	r12,r12[0x14]
800024ec:	80 00       	ld.sh	r0,r0[0x0]
800024ee:	db e8       	*unknown*
800024f0:	80 00       	ld.sh	r0,r0[0x0]
800024f2:	dc 04       	*unknown*
800024f4:	80 00       	ld.sh	r0,r0[0x0]
800024f6:	dc 1c       	*unknown*

800024f8 <spk_brdcst_func>:
		log("spk error");
	}
}

void spk_brdcst_func(xcmp_fragment_t * xcmp)
{
800024f8:	d4 01       	pushm	lr
	if (xcmp->u8[3] == xcmp_Res_Success)//0x0000:mute
800024fa:	19 d9       	ld.ub	r9,r12[0x5]
800024fc:	30 08       	mov	r8,0
800024fe:	f0 09 18 00 	cp.b	r9,r8
80002502:	c0 81       	brne	80002512 <spk_brdcst_func+0x1a>
	{
		Speaker_is_unmute =0;
80002504:	10 99       	mov	r9,r8
80002506:	48 78       	lddpc	r8,80002520 <spk_brdcst_func+0x28>
80002508:	b0 89       	st.b	r8[0x0],r9
		//Silent_flag = 0;
		log("spk_s_close ");
8000250a:	48 7c       	lddpc	r12,80002524 <spk_brdcst_func+0x2c>
8000250c:	f0 1f 00 07 	mcall	80002528 <spk_brdcst_func+0x30>
80002510:	d8 02       	popm	pc
		
	}
	else
	{
		//Silent_flag = 1;
		Speaker_is_unmute = 1;
80002512:	30 19       	mov	r9,1
80002514:	48 38       	lddpc	r8,80002520 <spk_brdcst_func+0x28>
80002516:	b0 89       	st.b	r8[0x0],r9
		log("spk_s_open ");	
80002518:	48 5c       	lddpc	r12,8000252c <spk_brdcst_func+0x34>
8000251a:	f0 1f 00 04 	mcall	80002528 <spk_brdcst_func+0x30>
8000251e:	d8 02       	popm	pc
80002520:	00 00       	add	r0,r0
80002522:	0a 50       	eor	r0,r5
80002524:	80 00       	ld.sh	r0,r0[0x0]
80002526:	dc 34       	*unknown*
80002528:	80 00       	ld.sh	r0,r0[0x0]
8000252a:	78 5c       	ld.w	r12,r12[0x14]
8000252c:	80 00       	ld.sh	r0,r0[0x0]
8000252e:	dc 44       	*unknown*

80002530 <spk_reply_func>:
			
	
}

void spk_reply_func(xcmp_fragment_t * xcmp)
{
80002530:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
80002532:	19 a9       	ld.ub	r9,r12[0x2]
80002534:	30 08       	mov	r8,0
80002536:	f0 09 18 00 	cp.b	r9,r8
8000253a:	c0 f1       	brne	80002558 <spk_reply_func+0x28>
	{
		
		if(xcmp->u8[4])
8000253c:	19 e9       	ld.ub	r9,r12[0x6]
8000253e:	f0 09 18 00 	cp.b	r9,r8
80002542:	c0 40       	breq	8000254a <spk_reply_func+0x1a>
		{
			Speaker_is_unmute = 1;
80002544:	30 19       	mov	r9,1
80002546:	48 98       	lddpc	r8,80002568 <spk_reply_func+0x38>
80002548:	b0 89       	st.b	r8[0x0],r9
			
			//Silent_flag = 1;
		}
		log("spk OK -st%2x", xcmp->u8[4] );
8000254a:	19 e8       	ld.ub	r8,r12[0x6]
8000254c:	1a d8       	st.w	--sp,r8
8000254e:	48 8c       	lddpc	r12,8000256c <spk_reply_func+0x3c>
80002550:	f0 1f 00 08 	mcall	80002570 <spk_reply_func+0x40>
80002554:	2f fd       	sub	sp,-4
80002556:	d8 02       	popm	pc
		
	}
	else
	{
		Speaker_is_unmute = 0;
80002558:	30 09       	mov	r9,0
8000255a:	48 48       	lddpc	r8,80002568 <spk_reply_func+0x38>
8000255c:	b0 89       	st.b	r8[0x0],r9
		log("spk error");
8000255e:	48 6c       	lddpc	r12,80002574 <spk_reply_func+0x44>
80002560:	f0 1f 00 04 	mcall	80002570 <spk_reply_func+0x40>
80002564:	d8 02       	popm	pc
80002566:	00 00       	add	r0,r0
80002568:	00 00       	add	r0,r0
8000256a:	0a 50       	eor	r0,r5
8000256c:	80 00       	ld.sh	r0,r0[0x0]
8000256e:	dc 50       	acall	0xc5
80002570:	80 00       	ld.sh	r0,r0[0x0]
80002572:	78 5c       	ld.w	r12,r12[0x14]
80002574:	80 00       	ld.sh	r0,r0[0x0]
80002576:	dc 60       	acall	0xc6

80002578 <mic_brdcst_func>:
	
	
}

void mic_brdcst_func(xcmp_fragment_t * xcmp)
{
80002578:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_brdcast_t *ptr = (MicControl_brdcast_t* )xcmp->u8;
8000257c:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r Mic_brdcst \n\r");		
	//log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
	//log("\n\r Signal_type: %x \n\r " ,  ptr->Signaling_Type);
	if (ptr->Mic_State == 0x00)
80002580:	0f a9       	ld.ub	r9,r7[0x2]
80002582:	30 08       	mov	r8,0
80002584:	f0 09 18 00 	cp.b	r9,r8
80002588:	c0 71       	brne	80002596 <mic_brdcst_func+0x1e>
	{
		log("\n\r Mic_Disabled \n\r");	
8000258a:	48 dc       	lddpc	r12,800025bc <mic_brdcst_func+0x44>
8000258c:	f0 1f 00 0d 	mcall	800025c0 <mic_brdcst_func+0x48>
		Mic_is_Enabled = 0;
80002590:	30 09       	mov	r9,0
80002592:	48 d8       	lddpc	r8,800025c4 <mic_brdcst_func+0x4c>
80002594:	b0 89       	st.b	r8[0x0],r9
	} 
	if(ptr->Mic_State == 0x11)
80002596:	0f a9       	ld.ub	r9,r7[0x2]
80002598:	31 18       	mov	r8,17
8000259a:	f0 09 18 00 	cp.b	r9,r8
8000259e:	c0 d1       	brne	800025b8 <mic_brdcst_func+0x40>
	{
		log("\n\r Mic_Enabled \n\r");
800025a0:	48 ac       	lddpc	r12,800025c8 <mic_brdcst_func+0x50>
800025a2:	f0 1f 00 08 	mcall	800025c0 <mic_brdcst_func+0x48>
		Mic_is_Enabled = 1;
800025a6:	48 89       	lddpc	r9,800025c4 <mic_brdcst_func+0x4c>
800025a8:	30 18       	mov	r8,1
800025aa:	b2 88       	st.b	r9[0x0],r8
		
		if ((Mic_is_Enabled == 1) && (Call_Begin == 1))
800025ac:	13 89       	ld.ub	r9,r9[0x0]
800025ae:	f0 09 18 00 	cp.b	r9,r8
800025b2:	c0 31       	brne	800025b8 <mic_brdcst_func+0x40>
800025b4:	48 68       	lddpc	r8,800025cc <mic_brdcst_func+0x54>
800025b6:	11 88       	ld.ub	r8,r8[0x0]
800025b8:	e3 cd 80 80 	ldm	sp++,r7,pc
800025bc:	80 00       	ld.sh	r0,r0[0x0]
800025be:	dc 6c       	*unknown*
800025c0:	80 00       	ld.sh	r0,r0[0x0]
800025c2:	78 5c       	ld.w	r12,r12[0x14]
800025c4:	00 00       	add	r0,r0
800025c6:	0a 5d       	eor	sp,r5
800025c8:	80 00       	ld.sh	r0,r0[0x0]
800025ca:	dc 80       	acall	0xc8
800025cc:	00 00       	add	r0,r0
800025ce:	0a 55       	eor	r5,r5

800025d0 <mic_reply_func>:
	
	
}

void mic_reply_func(xcmp_fragment_t * xcmp)
{
800025d0:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_reply_t *ptr = (MicControl_reply_t* )xcmp->u8;
800025d4:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Mic_reply \n\r");
800025d8:	49 ac       	lddpc	r12,80002640 <mic_reply_func+0x70>
800025da:	f0 1f 00 1b 	mcall	80002644 <mic_reply_func+0x74>
	if (ptr->Result == 0x00)
800025de:	0f 89       	ld.ub	r9,r7[0x0]
800025e0:	30 08       	mov	r8,0
800025e2:	f0 09 18 00 	cp.b	r9,r8
800025e6:	c2 71       	brne	80002634 <mic_reply_func+0x64>
	{
		
		if (ptr->Function == Mic_Disable)
800025e8:	0f 98       	ld.ub	r8,r7[0x1]
800025ea:	30 29       	mov	r9,2
800025ec:	f2 08 18 00 	cp.b	r8,r9
800025f0:	c1 b1       	brne	80002626 <mic_reply_func+0x56>
		{
		
			log("\n\r Mic_close_ok \n\r " );
800025f2:	49 6c       	lddpc	r12,80002648 <mic_reply_func+0x78>
800025f4:	f0 1f 00 14 	mcall	80002644 <mic_reply_func+0x74>
			log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
800025f8:	0f a8       	ld.ub	r8,r7[0x2]
800025fa:	1a d8       	st.w	--sp,r8
800025fc:	49 4c       	lddpc	r12,8000264c <mic_reply_func+0x7c>
800025fe:	f0 1f 00 12 	mcall	80002644 <mic_reply_func+0x74>
			log("\n\r Signaling_type: %x \n\r " ,  ptr->Signaling_Type);
80002602:	0f b8       	ld.ub	r8,r7[0x3]
80002604:	1a d8       	st.w	--sp,r8
80002606:	49 3c       	lddpc	r12,80002650 <mic_reply_func+0x80>
80002608:	f0 1f 00 0f 	mcall	80002644 <mic_reply_func+0x74>
			log("\n\r Mic_state: %x \n\r " ,  ptr->Mic_State);
8000260c:	0f c8       	ld.ub	r8,r7[0x4]
8000260e:	1a d8       	st.w	--sp,r8
80002610:	49 1c       	lddpc	r12,80002654 <mic_reply_func+0x84>
80002612:	f0 1f 00 0d 	mcall	80002644 <mic_reply_func+0x74>
			log("\n\r Gain_offset: %x \n\r " ,  ptr->Gain_Offset);
80002616:	0f d8       	ld.ub	r8,r7[0x5]
80002618:	1a d8       	st.w	--sp,r8
8000261a:	49 0c       	lddpc	r12,80002658 <mic_reply_func+0x88>
8000261c:	f0 1f 00 0a 	mcall	80002644 <mic_reply_func+0x74>
80002620:	2f cd       	sub	sp,-16
80002622:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else
		{
			log("\n\r Mic_function: %x \n\r ", ptr->Function );
80002626:	1a d8       	st.w	--sp,r8
80002628:	48 dc       	lddpc	r12,8000265c <mic_reply_func+0x8c>
8000262a:	f0 1f 00 07 	mcall	80002644 <mic_reply_func+0x74>
8000262e:	2f fd       	sub	sp,-4
80002630:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else 
	{
		
	
		log("\n\r Mic error \n\r");
80002634:	48 bc       	lddpc	r12,80002660 <mic_reply_func+0x90>
80002636:	f0 1f 00 04 	mcall	80002644 <mic_reply_func+0x74>
8000263a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000263e:	00 00       	add	r0,r0
80002640:	80 00       	ld.sh	r0,r0[0x0]
80002642:	dc 94       	*unknown*
80002644:	80 00       	ld.sh	r0,r0[0x0]
80002646:	78 5c       	ld.w	r12,r12[0x14]
80002648:	80 00       	ld.sh	r0,r0[0x0]
8000264a:	dc a4       	*unknown*
8000264c:	80 00       	ld.sh	r0,r0[0x0]
8000264e:	dc b8       	*unknown*
80002650:	80 00       	ld.sh	r0,r0[0x0]
80002652:	dc cc       	*unknown*
80002654:	80 00       	ld.sh	r0,r0[0x0]
80002656:	dc e8       	*unknown*
80002658:	80 00       	ld.sh	r0,r0[0x0]
8000265a:	dd 00       	acall	0xd0
8000265c:	80 00       	ld.sh	r0,r0[0x0]
8000265e:	dd 18       	*unknown*
80002660:	80 00       	ld.sh	r0,r0[0x0]
80002662:	dd 30       	acall	0xd3

80002664 <dcm_brdcst_func>:
	}
}


void dcm_brdcst_func(xcmp_fragment_t * xcmp)
{
80002664:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	DeviceControlMode_brdcst_t *ptr = (DeviceControlMode_brdcst_t* )xcmp->u8;
80002668:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Dcm_brdcst \n\r");		
8000266c:	48 bc       	lddpc	r12,80002698 <dcm_brdcst_func+0x34>
8000266e:	f0 1f 00 0c 	mcall	8000269c <dcm_brdcst_func+0x38>
	log("\n\r Function: %x \n\r " ,  ptr->Function);
80002672:	0f 88       	ld.ub	r8,r7[0x0]
80002674:	1a d8       	st.w	--sp,r8
80002676:	48 bc       	lddpc	r12,800026a0 <dcm_brdcst_func+0x3c>
80002678:	f0 1f 00 09 	mcall	8000269c <dcm_brdcst_func+0x38>
	log("\n\r ControlType: %x \n\r " ,  ptr->ControlType);
8000267c:	0f a8       	ld.ub	r8,r7[0x2]
8000267e:	1a d8       	st.w	--sp,r8
80002680:	48 9c       	lddpc	r12,800026a4 <dcm_brdcst_func+0x40>
80002682:	f0 1f 00 07 	mcall	8000269c <dcm_brdcst_func+0x38>
	log("\n\r ControlTypeSize: %x \n\r " ,  ptr->ControlTypeSize);
80002686:	0f 98       	ld.ub	r8,r7[0x1]
80002688:	1a d8       	st.w	--sp,r8
8000268a:	48 8c       	lddpc	r12,800026a8 <dcm_brdcst_func+0x44>
8000268c:	f0 1f 00 04 	mcall	8000269c <dcm_brdcst_func+0x38>
80002690:	2f dd       	sub	sp,-12
	
	
}
80002692:	e3 cd 80 80 	ldm	sp++,r7,pc
80002696:	00 00       	add	r0,r0
80002698:	80 00       	ld.sh	r0,r0[0x0]
8000269a:	dd 40       	acall	0xd4
8000269c:	80 00       	ld.sh	r0,r0[0x0]
8000269e:	78 5c       	ld.w	r12,r12[0x14]
800026a0:	80 00       	ld.sh	r0,r0[0x0]
800026a2:	dd 54       	*unknown*
800026a4:	80 00       	ld.sh	r0,r0[0x0]
800026a6:	dd 68       	*unknown*
800026a8:	80 00       	ld.sh	r0,r0[0x0]
800026aa:	dd 80       	acall	0xd8

800026ac <dcm_reply_func>:
		log("Tone error");
	}
}

void dcm_reply_func(xcmp_fragment_t * xcmp)
{
800026ac:	eb cd 40 80 	pushm	r7,lr
800026b0:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
800026b2:	19 a9       	ld.ub	r9,r12[0x2]
800026b4:	30 08       	mov	r8,0
800026b6:	f0 09 18 00 	cp.b	r9,r8
800026ba:	c1 b1       	brne	800026f0 <dcm_reply_func+0x44>
	{
		if(xcmp->u8[1] == DCM_ENTER)
800026bc:	19 b8       	ld.ub	r8,r12[0x3]
800026be:	30 19       	mov	r9,1
800026c0:	f2 08 18 00 	cp.b	r8,r9
800026c4:	c0 51       	brne	800026ce <dcm_reply_func+0x22>
		{
			log("\n\r Dcm-Enter OK \n\r");
800026c6:	48 ec       	lddpc	r12,800026fc <dcm_reply_func+0x50>
800026c8:	f0 1f 00 0e 	mcall	80002700 <dcm_reply_func+0x54>
800026cc:	c0 a8       	rjmp	800026e0 <dcm_reply_func+0x34>
			
		}
		else if (xcmp->u8[1] == DCM_EXIT)
800026ce:	58 08       	cp.w	r8,0
800026d0:	c0 51       	brne	800026da <dcm_reply_func+0x2e>
		{
			log("\n\r Dcm-Exit OK \n\r");
800026d2:	48 dc       	lddpc	r12,80002704 <dcm_reply_func+0x58>
800026d4:	f0 1f 00 0b 	mcall	80002700 <dcm_reply_func+0x54>
800026d8:	c0 48       	rjmp	800026e0 <dcm_reply_func+0x34>
		}
		else
		{
			log("\n\r Dcm-Revoke \n\r");
800026da:	48 cc       	lddpc	r12,80002708 <dcm_reply_func+0x5c>
800026dc:	f0 1f 00 09 	mcall	80002700 <dcm_reply_func+0x54>
		}
		
		log("dcm OK-mo%X", xcmp->u8[3]);
800026e0:	0f d8       	ld.ub	r8,r7[0x5]
800026e2:	1a d8       	st.w	--sp,r8
800026e4:	48 ac       	lddpc	r12,8000270c <dcm_reply_func+0x60>
800026e6:	f0 1f 00 07 	mcall	80002700 <dcm_reply_func+0x54>
800026ea:	2f fd       	sub	sp,-4
800026ec:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		log("dcm error");
800026f0:	48 8c       	lddpc	r12,80002710 <dcm_reply_func+0x64>
800026f2:	f0 1f 00 04 	mcall	80002700 <dcm_reply_func+0x54>
800026f6:	e3 cd 80 80 	ldm	sp++,r7,pc
800026fa:	00 00       	add	r0,r0
800026fc:	80 00       	ld.sh	r0,r0[0x0]
800026fe:	dd 9c       	*unknown*
80002700:	80 00       	ld.sh	r0,r0[0x0]
80002702:	78 5c       	ld.w	r12,r12[0x14]
80002704:	80 00       	ld.sh	r0,r0[0x0]
80002706:	dd b0       	acall	0xdb
80002708:	80 00       	ld.sh	r0,r0[0x0]
8000270a:	dd c4       	*unknown*
8000270c:	80 00       	ld.sh	r0,r0[0x0]
8000270e:	dd d8       	*unknown*
80002710:	80 00       	ld.sh	r0,r0[0x0]
80002712:	dd e4       	*unknown*

80002714 <ToneControl_reply_func>:
			}
		}
}

void ToneControl_reply_func(xcmp_fragment_t * xcmp)
{
80002714:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
80002716:	19 a9       	ld.ub	r9,r12[0x2]
80002718:	30 08       	mov	r8,0
8000271a:	f0 09 18 00 	cp.b	r9,r8
8000271e:	c0 51       	brne	80002728 <ToneControl_reply_func+0x14>
	{		
		log("Tone OK\n");
80002720:	48 4c       	lddpc	r12,80002730 <ToneControl_reply_func+0x1c>
80002722:	f0 1f 00 05 	mcall	80002734 <ToneControl_reply_func+0x20>
80002726:	d8 02       	popm	pc
		//fl_write("/test.txt", FILE_END, (void *)"send tone ok\r\n", sizeof("send tone ok\r\n") - 1);
	}
	else
	{
		log("Tone error");
80002728:	48 4c       	lddpc	r12,80002738 <ToneControl_reply_func+0x24>
8000272a:	f0 1f 00 03 	mcall	80002734 <ToneControl_reply_func+0x20>
8000272e:	d8 02       	popm	pc
80002730:	80 00       	ld.sh	r0,r0[0x0]
80002732:	dd f0       	acall	0xdf
80002734:	80 00       	ld.sh	r0,r0[0x0]
80002736:	78 5c       	ld.w	r12,r12[0x14]
80002738:	80 00       	ld.sh	r0,r0[0x0]
8000273a:	dd fc       	*unknown*

8000273c <app_cfg>:
extern volatile  xTaskHandle save_handle; 
//extern portTickType water_value;
//extern portTickType tx_water_value;
//extern portTickType log_water_value;
static __app_Thread_(app_cfg)
{
8000273c:	d4 31       	pushm	r0-r7,lr
8000273e:	20 1d       	sub	sp,4
	U8 Burst_ID = 0;
	char card_id[4]={0};
	U16  * data_ptr;
	//static const uint8_t test_data[8] = {0x11, 0x23, 0x33, 0x67, 0x89, 0xAB, 0xCD, 0xEF};
	static	OB_States OB_State = OB_UNCONNECTEDWAITINGSTATUS;
	xLastWakeTime = xTaskGetTickCount();
80002740:	f0 1f 00 39 	mcall	80002824 <app_cfg+0xe8>
80002744:	4b 98       	lddpc	r8,80002828 <app_cfg+0xec>
80002746:	91 0c       	st.w	r8[0x0],r12
		
	for(;;)
	{
		switch(OB_State)
80002748:	4b 97       	lddpc	r7,8000282c <app_cfg+0xf0>
				}
								
			break;
			case OB_CONNECTEDWAITTINGSYNTIME:
			
						if(get_time_okay){
8000274a:	4b a5       	lddpc	r5,80002830 <app_cfg+0xf4>
							OB_State = OB_WAITINGAPPTASK;
							log("get time okay!\n");
						}
						else
						{						
							xcmp_data_session_req(0x00, sizeof(Message_Protocol_t), DEST);//request to get system time						
8000274c:	30 92       	mov	r2,9
8000274e:	32 01       	mov	r1,32
80002750:	30 06       	mov	r6,0
			break;
			case OB_CONNECTEDWAITTINGSYNTIME:
			
						if(get_time_okay){
							
							OB_State = OB_WAITINGAPPTASK;
80002752:	30 30       	mov	r0,3
							xcmp_data_session_req(0x00, sizeof(Message_Protocol_t), DEST);//request to get system time						
						}
			break;
			case OB_WAITINGAPPTASK:
			
					if(pdPASS == xQueueReceive(xg_resend_queue, &data_ptr, (2000*2) / portTICK_RATE_MS))
80002754:	4b 84       	lddpc	r4,80002834 <app_cfg+0xf8>
	static	OB_States OB_State = OB_UNCONNECTEDWAITINGSTATUS;
	xLastWakeTime = xTaskGetTickCount();
		
	for(;;)
	{
		switch(OB_State)
80002756:	6e 08       	ld.w	r8,r7[0x0]
80002758:	58 28       	cp.w	r8,2
8000275a:	c3 40       	breq	800027c2 <app_cfg+0x86>
8000275c:	58 38       	cp.w	r8,3
8000275e:	c4 00       	breq	800027de <app_cfg+0xa2>
80002760:	58 08       	cp.w	r8,0
80002762:	c5 a1       	brne	80002816 <app_cfg+0xda>
		{
			case OB_UNCONNECTEDWAITINGSTATUS:
			
				if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
80002764:	4b 58       	lddpc	r8,80002838 <app_cfg+0xfc>
80002766:	70 08       	ld.w	r8,r8[0x0]
80002768:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
8000276c:	58 38       	cp.w	r8,3
8000276e:	c1 21       	brne	80002792 <app_cfg+0x56>
80002770:	4b 38       	lddpc	r8,8000283c <app_cfg+0x100>
80002772:	11 88       	ld.ub	r8,r8[0x0]
80002774:	58 08       	cp.w	r8,0
80002776:	c0 e1       	brne	80002792 <app_cfg+0x56>
				{
					connect_flag=1;
80002778:	30 19       	mov	r9,1
8000277a:	4b 18       	lddpc	r8,8000283c <app_cfg+0x100>
8000277c:	b0 89       	st.b	r8[0x0],r9
					xcmp_IdleTestTone(Tone_Start, Priority_Beep);//set tone to indicate connection success!!!
8000277e:	30 cb       	mov	r11,12
80002780:	30 1c       	mov	r12,1
80002782:	f0 1f 00 30 	mcall	80002840 <app_cfg+0x104>
					OB_State = OB_CONNECTEDWAITTINGSYNTIME;
80002786:	30 28       	mov	r8,2
80002788:	8f 08       	st.w	r7[0x0],r8
					//vTaskResume(save_handle);
					log("connect OB okay!\n");
8000278a:	4a fc       	lddpc	r12,80002844 <app_cfg+0x108>
8000278c:	f0 1f 00 2f 	mcall	80002848 <app_cfg+0x10c>
	{
		switch(OB_State)
		{
			case OB_UNCONNECTEDWAITINGSTATUS:
			
				if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
80002790:	c4 38       	rjmp	80002816 <app_cfg+0xda>
					//vTaskResume(save_handle);
					log("connect OB okay!\n");
				}
				else
				{
					nop();
80002792:	d7 03       	nop
					nop();
80002794:	d7 03       	nop
					nop();
80002796:	d7 03       	nop
					//xcmp_IdleTestTone(Tone_Start, Bad_Key_Chirp);//set tone to indicate connection failure!!!
					log("connecting...\n");
80002798:	4a dc       	lddpc	r12,8000284c <app_cfg+0x110>
8000279a:	f0 1f 00 2c 	mcall	80002848 <app_cfg+0x10c>
					log("Current time is :20%d:%2d:%2d, %2d:%2d:%2d\n",
					Current_time.Year, Current_time.Month, Current_time.Day,
					Current_time.Hour, Current_time.Minute, Current_time.Second);
8000279e:	4a d8       	lddpc	r8,80002850 <app_cfg+0x114>
800027a0:	11 de       	ld.ub	lr,r8[0x5]
800027a2:	11 cc       	ld.ub	r12,r8[0x4]
800027a4:	11 bb       	ld.ub	r11,r8[0x3]
					nop();
					nop();
					//xcmp_IdleTestTone(Tone_Start, Bad_Key_Chirp);//set tone to indicate connection failure!!!
					log("connecting...\n");
					log("Current time is :20%d:%2d:%2d, %2d:%2d:%2d\n",
					Current_time.Year, Current_time.Month, Current_time.Day,
800027a6:	11 aa       	ld.ub	r10,r8[0x2]
800027a8:	11 99       	ld.ub	r9,r8[0x1]
800027aa:	11 88       	ld.ub	r8,r8[0x0]
					nop();
					nop();
					nop();
					//xcmp_IdleTestTone(Tone_Start, Bad_Key_Chirp);//set tone to indicate connection failure!!!
					log("connecting...\n");
					log("Current time is :20%d:%2d:%2d, %2d:%2d:%2d\n",
800027ac:	1a de       	st.w	--sp,lr
800027ae:	1a dc       	st.w	--sp,r12
800027b0:	1a db       	st.w	--sp,r11
800027b2:	1a da       	st.w	--sp,r10
800027b4:	1a d9       	st.w	--sp,r9
800027b6:	1a d8       	st.w	--sp,r8
800027b8:	4a 7c       	lddpc	r12,80002854 <app_cfg+0x118>
800027ba:	f0 1f 00 24 	mcall	80002848 <app_cfg+0x10c>
800027be:	2f ad       	sub	sp,-24
800027c0:	c2 b8       	rjmp	80002816 <app_cfg+0xda>
				}
								
			break;
			case OB_CONNECTEDWAITTINGSYNTIME:
			
						if(get_time_okay){
800027c2:	0b 88       	ld.ub	r8,r5[0x0]
800027c4:	58 08       	cp.w	r8,0
800027c6:	c0 60       	breq	800027d2 <app_cfg+0x96>
							
							OB_State = OB_WAITINGAPPTASK;
800027c8:	8f 00       	st.w	r7[0x0],r0
							log("get time okay!\n");
800027ca:	4a 4c       	lddpc	r12,80002858 <app_cfg+0x11c>
800027cc:	f0 1f 00 1f 	mcall	80002848 <app_cfg+0x10c>
800027d0:	c2 38       	rjmp	80002816 <app_cfg+0xda>
						}
						else
						{						
							xcmp_data_session_req(0x00, sizeof(Message_Protocol_t), DEST);//request to get system time						
800027d2:	04 9a       	mov	r10,r2
800027d4:	02 9b       	mov	r11,r1
800027d6:	0c 9c       	mov	r12,r6
800027d8:	f0 1f 00 21 	mcall	8000285c <app_cfg+0x120>
800027dc:	c1 d8       	rjmp	80002816 <app_cfg+0xda>
						}
			break;
			case OB_WAITINGAPPTASK:
			
					if(pdPASS == xQueueReceive(xg_resend_queue, &data_ptr, (2000*2) / portTICK_RATE_MS))
800027de:	68 0c       	ld.w	r12,r4[0x0]
800027e0:	0c 99       	mov	r9,r6
800027e2:	e0 6a 0f a0 	mov	r10,4000
800027e6:	1a 9b       	mov	r11,sp
800027e8:	f0 1f 00 1e 	mcall	80002860 <app_cfg+0x124>
800027ec:	58 1c       	cp.w	r12,1
800027ee:	c1 01       	brne	8000280e <app_cfg+0xd2>
					{
						if(data_ptr!=NULL){//Resend message
800027f0:	40 0c       	lddsp	r12,sp[0x0]
800027f2:	58 0c       	cp.w	r12,0
800027f4:	c0 d0       	breq	8000280e <app_cfg+0xd2>
							
							//Message_Protocol_t *ptr = (Message_Protocol_t* )data_ptr;
							//xgflash_message_save(data_ptr, sizeof(Message_Protocol_t), TRUE);
							//log("receive data : %d", ptr->data.XG_Time.Second);
							xcmp_data_session_req(data_ptr, sizeof(Message_Protocol_t), DEST);
800027f6:	04 9a       	mov	r10,r2
800027f8:	02 9b       	mov	r11,r1
800027fa:	f0 1f 00 19 	mcall	8000285c <app_cfg+0x120>
							
							//flashc_memset8((void*)0x80038000, 0x02, 5, TRUE);
							
							set_message_store(data_ptr);
800027fe:	49 a8       	lddpc	r8,80002864 <app_cfg+0x128>
80002800:	70 0c       	ld.w	r12,r8[0x0]
80002802:	40 0b       	lddsp	r11,sp[0x0]
80002804:	f0 1f 00 19 	mcall	80002868 <app_cfg+0x12c>
							log("receive okay!\n");
80002808:	49 9c       	lddpc	r12,8000286c <app_cfg+0x130>
8000280a:	f0 1f 00 10 	mcall	80002848 <app_cfg+0x10c>
					//}
					//else
					//{
					//log("no find card...\n");
					//}
					nop();
8000280e:	d7 03       	nop
					//log("Current time is :20%d:%2d:%2d, %2d:%2d:%2d\n",
					//Current_time.Year, Current_time.Month, Current_time.Day,
					//Current_time.Hour, Current_time.Minute, Current_time.Second);
					log("app task run!\n");
80002810:	49 8c       	lddpc	r12,80002870 <app_cfg+0x134>
80002812:	f0 1f 00 0e 	mcall	80002848 <app_cfg+0x10c>
			break;
				
		} //End of switch on OB_State.
		//vTaskDelay(300*2 / portTICK_RATE_MS);//延迟300ms
		//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
		vTaskDelayUntil( &xLastWakeTime, (2000*2) / portTICK_RATE_MS  );//精确的以1000ms为周期执行。
80002816:	e0 6b 0f a0 	mov	r11,4000
8000281a:	48 4c       	lddpc	r12,80002828 <app_cfg+0xec>
8000281c:	f0 1f 00 16 	mcall	80002874 <app_cfg+0x138>
	}
80002820:	c9 bb       	rjmp	80002756 <app_cfg+0x1a>
80002822:	00 00       	add	r0,r0
80002824:	80 00       	ld.sh	r0,r0[0x0]
80002826:	71 88       	ld.w	r8,r8[0x60]
80002828:	00 00       	add	r0,r0
8000282a:	0a 60       	and	r0,r5
8000282c:	00 00       	add	r0,r0
8000282e:	0a 58       	eor	r8,r5
80002830:	00 00       	add	r0,r0
80002832:	00 04       	add	r4,r0
80002834:	00 00       	add	r0,r0
80002836:	0b 80       	ld.ub	r0,r5[0x0]
80002838:	00 00       	add	r0,r0
8000283a:	0e 04       	add	r4,r7
8000283c:	00 00       	add	r0,r0
8000283e:	0a 5c       	eor	r12,r5
80002840:	80 00       	ld.sh	r0,r0[0x0]
80002842:	46 8c       	lddsp	r12,sp[0x1a0]
80002844:	80 00       	ld.sh	r0,r0[0x0]
80002846:	de 08       	*unknown*
80002848:	80 00       	ld.sh	r0,r0[0x0]
8000284a:	78 5c       	ld.w	r12,r12[0x14]
8000284c:	80 00       	ld.sh	r0,r0[0x0]
8000284e:	de 1c       	*unknown*
80002850:	00 00       	add	r0,r0
80002852:	0e 08       	add	r8,r7
80002854:	80 00       	ld.sh	r0,r0[0x0]
80002856:	de 2c       	*unknown*
80002858:	80 00       	ld.sh	r0,r0[0x0]
8000285a:	de 58       	*unknown*
8000285c:	80 00       	ld.sh	r0,r0[0x0]
8000285e:	45 54       	lddsp	r4,sp[0x154]
80002860:	80 00       	ld.sh	r0,r0[0x0]
80002862:	6a 18       	ld.w	r8,r5[0x4]
80002864:	00 00       	add	r0,r0
80002866:	0b 90       	ld.ub	r0,r5[0x1]
80002868:	80 00       	ld.sh	r0,r0[0x0]
8000286a:	32 1c       	mov	r12,33
8000286c:	80 00       	ld.sh	r0,r0[0x0]
8000286e:	de 68       	*unknown*
80002870:	80 00       	ld.sh	r0,r0[0x0]
80002872:	de 78       	*unknown*
80002874:	80 00       	ld.sh	r0,r0[0x0]
80002876:	73 38       	ld.w	r8,r9[0x4c]

80002878 <Phyuserinput_brdcst_func>:
	
}


void Phyuserinput_brdcst_func(xcmp_fragment_t * xcmp)
{
80002878:	eb cd 40 80 	pushm	r7,lr
	U8 PUI_State_Min_Value =0;
	U8 PUI_State_Max_Value =0;
	
	PUI_Source = xcmp->u8[0];
	PUI_Type = xcmp ->u8[1];
	PUI_ID = ((xcmp->u8[2]<<8) | xcmp->u8[3]);
8000287c:	19 c7       	ld.ub	r7,r12[0x4]
8000287e:	19 d8       	ld.ub	r8,r12[0x5]
80002880:	f1 e7 10 87 	or	r7,r8,r7<<0x8
80002884:	5c 87       	casts.h	r7
	PUI_State = xcmp->u8[4];
	PUI_State_Min_Value = xcmp->u8[5];
	PUI_State_Max_Value = xcmp->u8[6];
	
	log("PhysicalUserInput_broadcast  \n\r"  );
80002886:	48 dc       	lddpc	r12,800028b8 <Phyuserinput_brdcst_func+0x40>
80002888:	f0 1f 00 0d 	mcall	800028bc <Phyuserinput_brdcst_func+0x44>
	
	if((PUI_ID == 0x0060) && (PUI_State = 0x02) && (connect_flag == 1)){
8000288c:	36 08       	mov	r8,96
8000288e:	f0 07 19 00 	cp.h	r7,r8
80002892:	c1 11       	brne	800028b4 <Phyuserinput_brdcst_func+0x3c>
80002894:	48 b8       	lddpc	r8,800028c0 <Phyuserinput_brdcst_func+0x48>
80002896:	11 89       	ld.ub	r9,r8[0x0]
80002898:	30 18       	mov	r8,1
8000289a:	f0 09 18 00 	cp.b	r9,r8
8000289e:	c0 b1       	brne	800028b4 <Phyuserinput_brdcst_func+0x3c>
		//log("send message\n");
		xcmp_IdleTestTone(Tone_Start, ACK_Received_Tone);//set tone to indicate the scan!!!
800028a0:	31 4b       	mov	r11,20
800028a2:	30 1c       	mov	r12,1
800028a4:	f0 1f 00 08 	mcall	800028c4 <Phyuserinput_brdcst_func+0x4c>
			
		vTaskDelay(400*2 / portTICK_RATE_MS);//延迟400ms
800028a8:	e0 6c 03 20 	mov	r12,800
800028ac:	f0 1f 00 07 	mcall	800028c8 <Phyuserinput_brdcst_func+0x50>
		//delay_ms(200);
		rfid_sendID_message();//send message		
800028b0:	f0 1f 00 07 	mcall	800028cc <Phyuserinput_brdcst_func+0x54>
800028b4:	e3 cd 80 80 	ldm	sp++,r7,pc
800028b8:	80 00       	ld.sh	r0,r0[0x0]
800028ba:	de 88       	*unknown*
800028bc:	80 00       	ld.sh	r0,r0[0x0]
800028be:	78 5c       	ld.w	r12,r12[0x14]
800028c0:	00 00       	add	r0,r0
800028c2:	0a 5c       	eor	r12,r5
800028c4:	80 00       	ld.sh	r0,r0[0x0]
800028c6:	46 8c       	lddsp	r12,sp[0x1a0]
800028c8:	80 00       	ld.sh	r0,r0[0x0]
800028ca:	72 f0       	ld.w	r0,r9[0x3c]
800028cc:	80 00       	ld.sh	r0,r0[0x0]
800028ce:	56 d0       	stdsp	sp[0x1b4],r0

800028d0 <DataSession_brdcst_func>:
	}
	
}

void DataSession_brdcst_func(xcmp_fragment_t * xcmp)
{
800028d0:	d4 21       	pushm	r4-r7,lr
800028d2:	20 9d       	sub	sp,36
	U32 card_id =0;
	U8 i = 0;
	xgflash_status_t return_value = XG_ERROR;
	
	/*point to xcmp payload*/
	DataSession_brdcst_t *ptr = (DataSession_brdcst_t* )xcmp->u8;
800028d4:	f8 c6 ff fe 	sub	r6,r12,-2
	
	if (ptr->State == CSBK_DATA_RX_Suc)
800028d8:	0d 88       	ld.ub	r8,r6[0x0]
800028da:	32 49       	mov	r9,36
800028dc:	f2 08 18 00 	cp.b	r8,r9
800028e0:	c2 91       	brne	80002932 <DataSession_brdcst_func+0x62>
	{
		
		log("\n\r CSBK_RX OK \n\r");
800028e2:	4a dc       	lddpc	r12,80002994 <DataSession_brdcst_func+0xc4>
800028e4:	f0 1f 00 2d 	mcall	80002998 <DataSession_brdcst_func+0xc8>
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
800028e8:	0d a5       	ld.ub	r5,r6[0x2]
800028ea:	0d b8       	ld.ub	r8,r6[0x3]
800028ec:	f1 e5 10 85 	or	r5,r8,r5<<0x8
800028f0:	5c 85       	casts.h	r5

		log("\n\r Session_ID: %x \n\r",Session_number );
800028f2:	0d 98       	ld.ub	r8,r6[0x1]
800028f4:	1a d8       	st.w	--sp,r8
800028f6:	4a ac       	lddpc	r12,8000299c <DataSession_brdcst_func+0xcc>
800028f8:	f0 1f 00 28 	mcall	80002998 <DataSession_brdcst_func+0xc8>
		log("\n\r paylaod_length: %d \n\r",data_length );
800028fc:	f1 d5 c0 10 	bfextu	r8,r5,0x0,0x10
80002900:	1a d8       	st.w	--sp,r8
80002902:	4a 8c       	lddpc	r12,800029a0 <DataSession_brdcst_func+0xd0>
80002904:	f0 1f 00 25 	mcall	80002998 <DataSession_brdcst_func+0xc8>
		for(i=0; i<data_length; i++)
80002908:	2f ed       	sub	sp,-8
8000290a:	58 05       	cp.w	r5,0
8000290c:	c4 10       	breq	8000298e <DataSession_brdcst_func+0xbe>
8000290e:	30 07       	mov	r7,0
		{
			
			//log("\n\r payload[%d]: %X \n\r", i, xcmp->u8[4+i]);
			log("\n\r payload[%d]: %X \n\r", i, ptr->DataPayload.DataPayload[i]);
80002910:	4a 54       	lddpc	r4,800029a4 <DataSession_brdcst_func+0xd4>
80002912:	ec 07 00 08 	add	r8,r6,r7
80002916:	11 c8       	ld.ub	r8,r8[0x4]
80002918:	1a d8       	st.w	--sp,r8
8000291a:	1a d7       	st.w	--sp,r7
8000291c:	08 9c       	mov	r12,r4
8000291e:	f0 1f 00 1f 	mcall	80002998 <DataSession_brdcst_func+0xc8>
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);

		log("\n\r Session_ID: %x \n\r",Session_number );
		log("\n\r paylaod_length: %d \n\r",data_length );
		for(i=0; i<data_length; i++)
80002922:	2f f7       	sub	r7,-1
80002924:	5c 57       	castu.b	r7
80002926:	2f ed       	sub	sp,-8
80002928:	ee 05 19 00 	cp.h	r5,r7
8000292c:	fe 9b ff f3 	brhi	80002912 <DataSession_brdcst_func+0x42>
80002930:	c2 f8       	rjmp	8000298e <DataSession_brdcst_func+0xbe>
	else
	{
		//log("\n\r State: 0x %X \n\r", xcmp->u8[0]);
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];				
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
		log("State: %X \n", ptr->State);
80002932:	1a d8       	st.w	--sp,r8
80002934:	49 dc       	lddpc	r12,800029a8 <DataSession_brdcst_func+0xd8>
80002936:	f0 1f 00 19 	mcall	80002998 <DataSession_brdcst_func+0xc8>
		if (ptr->State == DATA_SESSION_TX_Suc)
8000293a:	0d 88       	ld.ub	r8,r6[0x0]
8000293c:	2f fd       	sub	sp,-4
8000293e:	30 39       	mov	r9,3
80002940:	f2 08 18 00 	cp.b	r8,r9
80002944:	c0 51       	brne	8000294e <DataSession_brdcst_func+0x7e>
		{
			log("data transmit success\n");
80002946:	49 ac       	lddpc	r12,800029ac <DataSession_brdcst_func+0xdc>
80002948:	f0 1f 00 14 	mcall	80002998 <DataSession_brdcst_func+0xc8>
8000294c:	c2 18       	rjmp	8000298e <DataSession_brdcst_func+0xbe>
		}
		else if(ptr->State == DATA_SESSION_TX_Fail)
8000294e:	30 49       	mov	r9,4
80002950:	f2 08 18 00 	cp.b	r8,r9
80002954:	c1 d1       	brne	8000298e <DataSession_brdcst_func+0xbe>
		{
			//Message_Protocol_t  *xgmessage = (Message_Protocol_t  *)ptr->DataPayload.DataPayload;
			Message_Protocol_t  xgmessage;
			memcpy(&xgmessage, ptr->DataPayload.DataPayload, sizeof(Message_Protocol_t));
80002956:	32 0a       	mov	r10,32
80002958:	ec cb ff fc 	sub	r11,r6,-4
8000295c:	1a 9c       	mov	r12,sp
8000295e:	f0 1f 00 15 	mcall	800029b0 <DataSession_brdcst_func+0xe0>
			//xgmessage.data.XG_Time.Year, xgmessage.data.XG_Time.Month, xgmessage.data.XG_Time.Day,
			//xgmessage.data.XG_Time.Hour, xgmessage.data.XG_Time.Minute, xgmessage.data.XG_Time.Second);

			//return_value = xgflash_message_save(&xgmessage, sizeof(Message_Protocol_t), TRUE);

			Message_Protocol_t * myptr = get_message_store();	
80002962:	49 58       	lddpc	r8,800029b4 <DataSession_brdcst_func+0xe4>
80002964:	70 0c       	ld.w	r12,r8[0x0]
80002966:	f0 1f 00 15 	mcall	800029b8 <DataSession_brdcst_func+0xe8>
8000296a:	50 8c       	stdsp	sp[0x20],r12
			if(NULL != myptr)
8000296c:	c0 e0       	breq	80002988 <DataSession_brdcst_func+0xb8>
			{
				memcpy(myptr, &xgmessage, sizeof(Message_Protocol_t));			
8000296e:	32 0a       	mov	r10,32
80002970:	1a 9b       	mov	r11,sp
80002972:	f0 1f 00 10 	mcall	800029b0 <DataSession_brdcst_func+0xe0>
				xQueueSend(xg_resend_queue, &myptr, 0);
80002976:	49 28       	lddpc	r8,800029bc <DataSession_brdcst_func+0xec>
80002978:	70 0c       	ld.w	r12,r8[0x0]
8000297a:	30 09       	mov	r9,0
8000297c:	12 9a       	mov	r10,r9
8000297e:	fa cb ff e0 	sub	r11,sp,-32
80002982:	f0 1f 00 10 	mcall	800029c0 <DataSession_brdcst_func+0xf0>
80002986:	c0 48       	rjmp	8000298e <DataSession_brdcst_func+0xbe>
			}
			else
			{
				log("myptr: err\n\r" );
80002988:	48 fc       	lddpc	r12,800029c4 <DataSession_brdcst_func+0xf4>
8000298a:	f0 1f 00 04 	mcall	80002998 <DataSession_brdcst_func+0xc8>
				//
		//}
		
	}
	
}
8000298e:	2f 7d       	sub	sp,-36
80002990:	d8 22       	popm	r4-r7,pc
80002992:	00 00       	add	r0,r0
80002994:	80 00       	ld.sh	r0,r0[0x0]
80002996:	de a8       	*unknown*
80002998:	80 00       	ld.sh	r0,r0[0x0]
8000299a:	78 5c       	ld.w	r12,r12[0x14]
8000299c:	80 00       	ld.sh	r0,r0[0x0]
8000299e:	de bc       	*unknown*
800029a0:	80 00       	ld.sh	r0,r0[0x0]
800029a2:	de d4       	*unknown*
800029a4:	80 00       	ld.sh	r0,r0[0x0]
800029a6:	de f0       	acall	0xef
800029a8:	80 00       	ld.sh	r0,r0[0x0]
800029aa:	df 08       	*unknown*
800029ac:	80 00       	ld.sh	r0,r0[0x0]
800029ae:	df 14       	*unknown*
800029b0:	80 00       	ld.sh	r0,r0[0x0]
800029b2:	81 06       	st.w	r0[0x0],r6
800029b4:	00 00       	add	r0,r0
800029b6:	0b 90       	ld.ub	r0,r5[0x1]
800029b8:	80 00       	ld.sh	r0,r0[0x0]
800029ba:	33 c8       	mov	r8,60
800029bc:	00 00       	add	r0,r0
800029be:	0b 80       	ld.ub	r0,r5[0x0]
800029c0:	80 00       	ld.sh	r0,r0[0x0]
800029c2:	6c 24       	ld.w	r4,r6[0x8]
800029c4:	80 00       	ld.sh	r0,r0[0x0]
800029c6:	df 2c       	*unknown*

800029c8 <DeviceInitializationStatus_brdcst_func>:
extern volatile xQueueHandle xg_resend_queue ;

//app func--list

void DeviceInitializationStatus_brdcst_func(xcmp_fragment_t  * xcmp)
{
800029c8:	d4 01       	pushm	lr
	if (xcmp->u8[4] == 0x01)
800029ca:	19 e8       	ld.ub	r8,r12[0x6]
800029cc:	30 19       	mov	r9,1
800029ce:	f2 08 18 00 	cp.b	r8,r9
800029d2:	c0 61       	brne	800029de <DeviceInitializationStatus_brdcst_func+0x16>
	{
		bunchofrandomstatusflags |= 0x01;  //Need do nothing else.
800029d4:	48 98       	lddpc	r8,800029f8 <DeviceInitializationStatus_brdcst_func+0x30>
800029d6:	70 09       	ld.w	r9,r8[0x0]
800029d8:	a1 a9       	sbr	r9,0x0
800029da:	91 09       	st.w	r8[0x0],r9
800029dc:	d8 02       	popm	pc
	}
	else if(xcmp->u8[4] != 0x02)
800029de:	30 29       	mov	r9,2
800029e0:	f2 08 18 00 	cp.b	r8,r9
800029e4:	c0 80       	breq	800029f4 <DeviceInitializationStatus_brdcst_func+0x2c>
	{
		bunchofrandomstatusflags  &= 0xFFFFFFFC; //Device Init no longer Complete.
800029e6:	48 58       	lddpc	r8,800029f8 <DeviceInitializationStatus_brdcst_func+0x30>
800029e8:	70 09       	ld.w	r9,r8[0x0]
800029ea:	e0 19 ff fc 	andl	r9,0xfffc
800029ee:	91 09       	st.w	r8[0x0],r9
		xcmp_DeviceInitializationStatus_request();
800029f0:	f0 1f 00 03 	mcall	800029fc <DeviceInitializationStatus_brdcst_func+0x34>
800029f4:	d8 02       	popm	pc
800029f6:	00 00       	add	r0,r0
800029f8:	00 00       	add	r0,r0
800029fa:	0e 04       	add	r4,r7
800029fc:	80 00       	ld.sh	r0,r0[0x0]
800029fe:	45 e0       	lddsp	r0,sp[0x178]

80002a00 <send_flash_command>:
* ----------  --------  ----------  --------------------------------------------
* 10-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
U16 send_flash_command(U16 command, U32 address, U8 *data_ptr, U16 length)
{
80002a00:	eb cd 40 fc 	pushm	r2-r7,lr
80002a04:	20 1d       	sub	sp,4
80002a06:	18 97       	mov	r7,r12
80002a08:	14 95       	mov	r5,r10
80002a0a:	12 96       	mov	r6,r9
	U16 status = 1;
80002a0c:	30 18       	mov	r8,1
80002a0e:	ba 18       	st.h	sp[0x2],r8
	U16 i = 0;

    /* in order to call spi_write(U16* data), change 3-bytes address to 3-U16 address */
	U16 addr[3];
	addr[2] = (address & 0x00ff0000) >> 16;
80002a10:	e9 db c2 08 	bfextu	r4,r11,0x10,0x8
	addr[1] = (address & 0x0000ff00) >> 8;
80002a14:	e7 db c1 08 	bfextu	r3,r11,0x8,0x8
	addr[0] = (address & 0x000000ff);
80002a18:	e5 db c0 08 	bfextu	r2,r11,0x0,0x8

	U16 data_u16;

	spi_selectChip(spi, DF_SPI_PCS_1);
80002a1c:	30 1b       	mov	r11,1
80002a1e:	4e 58       	lddpc	r8,80002bb0 <send_flash_command+0x1b0>
80002a20:	70 0c       	ld.w	r12,r8[0x0]
80002a22:	f0 1f 00 65 	mcall	80002bb4 <send_flash_command+0x1b4>

    switch (command)
80002a26:	30 58       	mov	r8,5
80002a28:	f0 07 19 00 	cp.h	r7,r8
80002a2c:	c3 40       	breq	80002a94 <send_flash_command+0x94>
80002a2e:	e0 8b 00 18 	brhi	80002a5e <send_flash_command+0x5e>
80002a32:	30 28       	mov	r8,2
80002a34:	f0 07 19 00 	cp.h	r7,r8
80002a38:	c5 e0       	breq	80002af4 <send_flash_command+0xf4>
80002a3a:	e0 8b 00 08 	brhi	80002a4a <send_flash_command+0x4a>
80002a3e:	30 18       	mov	r8,1
80002a40:	f0 07 19 00 	cp.h	r7,r8
80002a44:	e0 81 00 ad 	brne	80002b9e <send_flash_command+0x19e>
80002a48:	c9 e8       	rjmp	80002b84 <send_flash_command+0x184>
80002a4a:	30 38       	mov	r8,3
80002a4c:	f0 07 19 00 	cp.h	r7,r8
80002a50:	c7 20       	breq	80002b34 <send_flash_command+0x134>
80002a52:	30 48       	mov	r8,4
80002a54:	f0 07 19 00 	cp.h	r7,r8
80002a58:	e0 81 00 a3 	brne	80002b9e <send_flash_command+0x19e>
80002a5c:	c2 c8       	rjmp	80002ab4 <send_flash_command+0xb4>
80002a5e:	35 28       	mov	r8,82
80002a60:	f0 07 19 00 	cp.h	r7,r8
80002a64:	c2 f0       	breq	80002ac2 <send_flash_command+0xc2>
80002a66:	e0 8b 00 0c 	brhi	80002a7e <send_flash_command+0x7e>
80002a6a:	30 68       	mov	r8,6
80002a6c:	f0 07 19 00 	cp.h	r7,r8
80002a70:	c2 20       	breq	80002ab4 <send_flash_command+0xb4>
80002a72:	32 08       	mov	r8,32
80002a74:	f0 07 19 00 	cp.h	r7,r8
80002a78:	e0 81 00 93 	brne	80002b9e <send_flash_command+0x19e>
80002a7c:	c2 38       	rjmp	80002ac2 <send_flash_command+0xc2>
80002a7e:	36 08       	mov	r8,96
80002a80:	f0 07 19 00 	cp.h	r7,r8
80002a84:	c3 20       	breq	80002ae8 <send_flash_command+0xe8>
80002a86:	e0 68 00 d8 	mov	r8,216
80002a8a:	f0 07 19 00 	cp.h	r7,r8
80002a8e:	e0 81 00 88 	brne	80002b9e <send_flash_command+0x19e>
80002a92:	c1 88       	rjmp	80002ac2 <send_flash_command+0xc2>
	{
		case READ_STATUS_REG:
			spi_write_byte(command);
80002a94:	4c 77       	lddpc	r7,80002bb0 <send_flash_command+0x1b0>
80002a96:	30 5b       	mov	r11,5
80002a98:	6e 0c       	ld.w	r12,r7[0x0]
80002a9a:	f0 1f 00 48 	mcall	80002bb8 <send_flash_command+0x1b8>
			spi_write_dummy();
80002a9e:	e0 6b 00 ff 	mov	r11,255
80002aa2:	6e 0c       	ld.w	r12,r7[0x0]
80002aa4:	f0 1f 00 45 	mcall	80002bb8 <send_flash_command+0x1b8>
			spi_read_byte(&status);
80002aa8:	fa cb ff fe 	sub	r11,sp,-2
80002aac:	6e 0c       	ld.w	r12,r7[0x0]
80002aae:	f0 1f 00 44 	mcall	80002bbc <send_flash_command+0x1bc>
			break;
80002ab2:	c7 68       	rjmp	80002b9e <send_flash_command+0x19e>
		case WRITE_ENABLE:
		case WRITE_DISABLE:
			spi_write_byte(command);
80002ab4:	0e 9b       	mov	r11,r7
80002ab6:	5c 7b       	castu.h	r11
80002ab8:	4b e8       	lddpc	r8,80002bb0 <send_flash_command+0x1b0>
80002aba:	70 0c       	ld.w	r12,r8[0x0]
80002abc:	f0 1f 00 3f 	mcall	80002bb8 <send_flash_command+0x1b8>
			break;
80002ac0:	c6 f8       	rjmp	80002b9e <send_flash_command+0x19e>
		case BLOCK_ERASE_4KB:
		case BLOCK_ERASE_32KB:
		case BLOCK_ERASE_64KB:
			spi_write_byte(command);
80002ac2:	4b c6       	lddpc	r6,80002bb0 <send_flash_command+0x1b0>
80002ac4:	0e 9b       	mov	r11,r7
80002ac6:	5c 7b       	castu.h	r11
80002ac8:	6c 0c       	ld.w	r12,r6[0x0]
80002aca:	f0 1f 00 3c 	mcall	80002bb8 <send_flash_command+0x1b8>
			spi_write_byte(addr[2]);
80002ace:	08 9b       	mov	r11,r4
80002ad0:	6c 0c       	ld.w	r12,r6[0x0]
80002ad2:	f0 1f 00 3a 	mcall	80002bb8 <send_flash_command+0x1b8>
			spi_write_byte(addr[1]);
80002ad6:	06 9b       	mov	r11,r3
80002ad8:	6c 0c       	ld.w	r12,r6[0x0]
80002ada:	f0 1f 00 38 	mcall	80002bb8 <send_flash_command+0x1b8>
			spi_write_byte(addr[0]);
80002ade:	04 9b       	mov	r11,r2
80002ae0:	6c 0c       	ld.w	r12,r6[0x0]
80002ae2:	f0 1f 00 36 	mcall	80002bb8 <send_flash_command+0x1b8>
			break;
80002ae6:	c5 c8       	rjmp	80002b9e <send_flash_command+0x19e>
		case CHIP_ERASE:
			spi_write_byte(command);
80002ae8:	36 0b       	mov	r11,96
80002aea:	4b 28       	lddpc	r8,80002bb0 <send_flash_command+0x1b0>
80002aec:	70 0c       	ld.w	r12,r8[0x0]
80002aee:	f0 1f 00 33 	mcall	80002bb8 <send_flash_command+0x1b8>
			break;
80002af2:	c5 68       	rjmp	80002b9e <send_flash_command+0x19e>
		case BYTE_PROGRAM: /* PAGE_PROGRAM use the same value */
			spi_write_byte(command);
80002af4:	4a f7       	lddpc	r7,80002bb0 <send_flash_command+0x1b0>
80002af6:	30 2b       	mov	r11,2
80002af8:	6e 0c       	ld.w	r12,r7[0x0]
80002afa:	f0 1f 00 30 	mcall	80002bb8 <send_flash_command+0x1b8>
			spi_write_byte(addr[2]);
80002afe:	08 9b       	mov	r11,r4
80002b00:	6e 0c       	ld.w	r12,r7[0x0]
80002b02:	f0 1f 00 2e 	mcall	80002bb8 <send_flash_command+0x1b8>
			spi_write_byte(addr[1]);
80002b06:	06 9b       	mov	r11,r3
80002b08:	6e 0c       	ld.w	r12,r7[0x0]
80002b0a:	f0 1f 00 2c 	mcall	80002bb8 <send_flash_command+0x1b8>
			spi_write_byte(addr[0]);
80002b0e:	04 9b       	mov	r11,r2
80002b10:	6e 0c       	ld.w	r12,r7[0x0]
80002b12:	f0 1f 00 2a 	mcall	80002bb8 <send_flash_command+0x1b8>
			for (i = 0; i < length; i++)
80002b16:	58 06       	cp.w	r6,0
80002b18:	c4 30       	breq	80002b9e <send_flash_command+0x19e>
80002b1a:	0a 97       	mov	r7,r5
			{
				data_u16 = (*data_ptr)&0x00ff;//modified by huayi
				data_ptr++;
				spi_write_byte(data_u16);
80002b1c:	4a 54       	lddpc	r4,80002bb0 <send_flash_command+0x1b0>
			spi_write_byte(addr[2]);
			spi_write_byte(addr[1]);
			spi_write_byte(addr[0]);
			for (i = 0; i < length; i++)
			{
				data_u16 = (*data_ptr)&0x00ff;//modified by huayi
80002b1e:	0f 3b       	ld.ub	r11,r7++
80002b20:	ba 0b       	st.h	sp[0x0],r11
				data_ptr++;
				spi_write_byte(data_u16);
80002b22:	68 0c       	ld.w	r12,r4[0x0]
80002b24:	f0 1f 00 25 	mcall	80002bb8 <send_flash_command+0x1b8>
		case BYTE_PROGRAM: /* PAGE_PROGRAM use the same value */
			spi_write_byte(command);
			spi_write_byte(addr[2]);
			spi_write_byte(addr[1]);
			spi_write_byte(addr[0]);
			for (i = 0; i < length; i++)
80002b28:	0e 98       	mov	r8,r7
80002b2a:	0a 18       	sub	r8,r5
80002b2c:	ec 08 19 00 	cp.h	r8,r6
80002b30:	cf 73       	brcs	80002b1e <send_flash_command+0x11e>
80002b32:	c3 68       	rjmp	80002b9e <send_flash_command+0x19e>
				data_ptr++;
				spi_write_byte(data_u16);
			}
			break;
		case READ_ARRAY:
			spi_write_byte(command);
80002b34:	49 f7       	lddpc	r7,80002bb0 <send_flash_command+0x1b0>
80002b36:	30 3b       	mov	r11,3
80002b38:	6e 0c       	ld.w	r12,r7[0x0]
80002b3a:	f0 1f 00 20 	mcall	80002bb8 <send_flash_command+0x1b8>
			spi_write_byte(addr[2]);
80002b3e:	08 9b       	mov	r11,r4
80002b40:	6e 0c       	ld.w	r12,r7[0x0]
80002b42:	f0 1f 00 1e 	mcall	80002bb8 <send_flash_command+0x1b8>
			spi_write_byte(addr[1]);
80002b46:	06 9b       	mov	r11,r3
80002b48:	6e 0c       	ld.w	r12,r7[0x0]
80002b4a:	f0 1f 00 1c 	mcall	80002bb8 <send_flash_command+0x1b8>
			spi_write_byte(addr[0]);
80002b4e:	04 9b       	mov	r11,r2
80002b50:	6e 0c       	ld.w	r12,r7[0x0]
80002b52:	f0 1f 00 1a 	mcall	80002bb8 <send_flash_command+0x1b8>
			for (i = 0; i < length; i++)
80002b56:	58 06       	cp.w	r6,0
80002b58:	c2 30       	breq	80002b9e <send_flash_command+0x19e>
80002b5a:	0a 97       	mov	r7,r5
			{
				spi_write_dummy();
80002b5c:	49 54       	lddpc	r4,80002bb0 <send_flash_command+0x1b0>
80002b5e:	e0 63 00 ff 	mov	r3,255
				spi_read_byte(&data_u16);
80002b62:	1a 92       	mov	r2,sp
			spi_write_byte(addr[2]);
			spi_write_byte(addr[1]);
			spi_write_byte(addr[0]);
			for (i = 0; i < length; i++)
			{
				spi_write_dummy();
80002b64:	06 9b       	mov	r11,r3
80002b66:	68 0c       	ld.w	r12,r4[0x0]
80002b68:	f0 1f 00 14 	mcall	80002bb8 <send_flash_command+0x1b8>
				spi_read_byte(&data_u16);
80002b6c:	1a 9b       	mov	r11,sp
80002b6e:	68 0c       	ld.w	r12,r4[0x0]
80002b70:	f0 1f 00 13 	mcall	80002bbc <send_flash_command+0x1bc>
				*data_ptr = (U8)data_u16;
80002b74:	9a 08       	ld.sh	r8,sp[0x0]
80002b76:	0e c8       	st.b	r7++,r8
		case READ_ARRAY:
			spi_write_byte(command);
			spi_write_byte(addr[2]);
			spi_write_byte(addr[1]);
			spi_write_byte(addr[0]);
			for (i = 0; i < length; i++)
80002b78:	0e 98       	mov	r8,r7
80002b7a:	0a 18       	sub	r8,r5
80002b7c:	ec 08 19 00 	cp.h	r8,r6
80002b80:	cf 23       	brcs	80002b64 <send_flash_command+0x164>
80002b82:	c0 e8       	rjmp	80002b9e <send_flash_command+0x19e>
				*data_ptr = (U8)data_u16;
				data_ptr++;
			}
			break;
		case WRITE_STATUS_REG_BYTE_1:
			spi_write_byte(command);
80002b84:	48 b7       	lddpc	r7,80002bb0 <send_flash_command+0x1b0>
80002b86:	30 1b       	mov	r11,1
80002b88:	6e 0c       	ld.w	r12,r7[0x0]
80002b8a:	f0 1f 00 0c 	mcall	80002bb8 <send_flash_command+0x1b8>
			spi_write_byte(UNPROTECT_ALL_SECTORS);
80002b8e:	30 0b       	mov	r11,0
80002b90:	6e 0c       	ld.w	r12,r7[0x0]
80002b92:	f0 1f 00 0a 	mcall	80002bb8 <send_flash_command+0x1b8>
			spi_write_byte(UNPROTECT_ALL_SECTORS);
80002b96:	30 0b       	mov	r11,0
80002b98:	6e 0c       	ld.w	r12,r7[0x0]
80002b9a:	f0 1f 00 08 	mcall	80002bb8 <send_flash_command+0x1b8>
			break;
		default:
			break;
	}

	spi_unselectChip(spi, DF_SPI_PCS_1);
80002b9e:	30 1b       	mov	r11,1
80002ba0:	48 48       	lddpc	r8,80002bb0 <send_flash_command+0x1b0>
80002ba2:	70 0c       	ld.w	r12,r8[0x0]
80002ba4:	f0 1f 00 07 	mcall	80002bc0 <send_flash_command+0x1c0>

	return status;
}
80002ba8:	9a 1c       	ld.sh	r12,sp[0x2]
80002baa:	2f fd       	sub	sp,-4
80002bac:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80002bb0:	00 00       	add	r0,r0
80002bb2:	20 90       	sub	r0,9
80002bb4:	80 00       	ld.sh	r0,r0[0x0]
80002bb6:	62 80       	ld.w	r0,r1[0x20]
80002bb8:	80 00       	ld.sh	r0,r0[0x0]
80002bba:	61 1a       	ld.w	r10,r0[0x44]
80002bbc:	80 00       	ld.sh	r0,r0[0x0]
80002bbe:	61 36       	ld.w	r6,r0[0x4c]
80002bc0:	80 00       	ld.sh	r0,r0[0x0]
80002bc2:	62 40       	ld.w	r0,r1[0x10]

80002bc4 <data_flash_read_block>:
* ----------  --------  ----------  --------------------------------------------
* 25-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_read_block(U32 address, U16 length, U8 *data_ptr)
{
80002bc4:	d4 01       	pushm	lr
	/* check input parameter */
	if (data_ptr == NULL || address >= DF_MAX_ADDR || length > 0x1000)
80002bc6:	58 0a       	cp.w	r10,0
80002bc8:	5f 09       	sreq	r9
80002bca:	e0 68 ff fe 	mov	r8,65534
80002bce:	ea 18 00 7f 	orh	r8,0x7f
80002bd2:	10 3c       	cp.w	r12,r8
80002bd4:	5f b8       	srhi	r8
80002bd6:	f3 e8 10 08 	or	r8,r9,r8
80002bda:	c0 e1       	brne	80002bf6 <data_flash_read_block+0x32>
80002bdc:	e0 68 10 00 	mov	r8,4096
80002be0:	f0 0b 19 00 	cp.h	r11,r8
80002be4:	e0 8b 00 09 	brhi	80002bf6 <data_flash_read_block+0x32>
	{
		return DF_INVALID_PARAM;
	}

	send_flash_command(READ_ARRAY, address, data_ptr, length);
80002be8:	f3 db c0 10 	bfextu	r9,r11,0x0,0x10
80002bec:	18 9b       	mov	r11,r12
80002bee:	30 3c       	mov	r12,3
80002bf0:	f0 1f 00 02 	mcall	80002bf8 <data_flash_read_block+0x34>
80002bf4:	d8 0a       	popm	pc,r12=0

	return DF_OK;
80002bf6:	da 0a       	popm	pc,r12=1
80002bf8:	80 00       	ld.sh	r0,r0[0x0]
80002bfa:	2a 00       	sub	r0,-96

80002bfc <data_flash_write_page>:
* ----------  --------  ----------  --------------------------------------------
* 25-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_write_page(U8 *data_ptr, U32 address, U16 length)
{
80002bfc:	eb cd 40 fc 	pushm	r2-r7,lr
80002c00:	18 94       	mov	r4,r12
80002c02:	16 93       	mov	r3,r11
80002c04:	14 92       	mov	r2,r10
	U16 status = 1;
	df_status_t return_code = DF_WRITE_FAIL;
	U16 count = 0; /* to monitor write time consumption */

	/* check input parameter */
	if (data_ptr == NULL || address >= DF_MAX_ADDR || length > DF_PAGE_SIZE)
80002c06:	58 0c       	cp.w	r12,0
80002c08:	5f 09       	sreq	r9
80002c0a:	e0 68 ff fe 	mov	r8,65534
80002c0e:	ea 18 00 7f 	orh	r8,0x7f
80002c12:	10 3b       	cp.w	r11,r8
80002c14:	5f b8       	srhi	r8
80002c16:	f3 e8 10 08 	or	r8,r9,r8
80002c1a:	c3 a1       	brne	80002c8e <data_flash_write_page+0x92>
80002c1c:	e0 68 01 00 	mov	r8,256
80002c20:	f0 0a 19 00 	cp.h	r10,r8
80002c24:	e0 8b 00 35 	brhi	80002c8e <data_flash_write_page+0x92>
	{
		return DF_INVALID_PARAM;
	}

	while(status = send_flash_command(READ_STATUS_REG, 0, NULL, 0) == STATUS_BUSY);
80002c28:	30 06       	mov	r6,0
80002c2a:	30 55       	mov	r5,5
80002c2c:	30 17       	mov	r7,1
80002c2e:	0c 99       	mov	r9,r6
80002c30:	0c 9a       	mov	r10,r6
80002c32:	0c 9b       	mov	r11,r6
80002c34:	0a 9c       	mov	r12,r5
80002c36:	f0 1f 00 19 	mcall	80002c98 <data_flash_write_page+0x9c>
80002c3a:	ee 0c 19 00 	cp.h	r12,r7
80002c3e:	cf 80       	breq	80002c2e <data_flash_write_page+0x32>
	//{
		//return DF_DEVICE_BUSY;
	//}

	/* send WRITE_ENABLE command */
	send_flash_command(WRITE_ENABLE, 0, NULL, 0);
80002c40:	30 09       	mov	r9,0
80002c42:	12 9a       	mov	r10,r9
80002c44:	12 9b       	mov	r11,r9
80002c46:	30 6c       	mov	r12,6
80002c48:	f0 1f 00 14 	mcall	80002c98 <data_flash_write_page+0x9c>

	/* send PAGE_PROGRAM command */
	send_flash_command(PAGE_PROGRAM, address, data_ptr, length);
80002c4c:	f3 d2 c0 10 	bfextu	r9,r2,0x0,0x10
80002c50:	08 9a       	mov	r10,r4
80002c52:	06 9b       	mov	r11,r3
80002c54:	30 2c       	mov	r12,2
80002c56:	f0 1f 00 11 	mcall	80002c98 <data_flash_write_page+0x9c>
	do {
		status = send_flash_command(READ_STATUS_REG, 0, NULL, 0);
80002c5a:	30 06       	mov	r6,0
80002c5c:	30 57       	mov	r7,5
80002c5e:	0c 99       	mov	r9,r6
80002c60:	0c 9a       	mov	r10,r6
80002c62:	0c 9b       	mov	r11,r6
80002c64:	0e 9c       	mov	r12,r7
80002c66:	f0 1f 00 0d 	mcall	80002c98 <data_flash_write_page+0x9c>
		count++;
	} while((status & STATUS_BUSY) != 0);
80002c6a:	5c 7c       	castu.h	r12
80002c6c:	f1 dc c0 01 	bfextu	r8,r12,0x0,0x1
80002c70:	cf 71       	brne	80002c5e <data_flash_write_page+0x62>

	/*  Check Status Register */
	if ((status & STATUS_ERASE_PROG_ERROR) != 0)
80002c72:	18 97       	mov	r7,r12
80002c74:	e2 17 00 20 	andl	r7,0x20,COH
80002c78:	f9 b7 01 06 	movne	r7,6
80002c7c:	f9 b7 00 07 	moveq	r7,7
		/*  Erase Successful.  */
		return_code = DF_WRITE_COMPLETED;
	}

	/* send WRITE_DISABLE command */
	send_flash_command(WRITE_DISABLE, 0, NULL, 0);
80002c80:	30 09       	mov	r9,0
80002c82:	12 9a       	mov	r10,r9
80002c84:	12 9b       	mov	r11,r9
80002c86:	30 4c       	mov	r12,4
80002c88:	f0 1f 00 04 	mcall	80002c98 <data_flash_write_page+0x9c>

	return return_code;
80002c8c:	c0 28       	rjmp	80002c90 <data_flash_write_page+0x94>
80002c8e:	30 17       	mov	r7,1
}
80002c90:	0e 9c       	mov	r12,r7
80002c92:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80002c96:	00 00       	add	r0,r0
80002c98:	80 00       	ld.sh	r0,r0[0x0]
80002c9a:	2a 00       	sub	r0,-96

80002c9c <data_flash_write_block>:
* ----------  --------  ----------  --------------------------------------------
* 25-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_write_block(U8 *data_ptr, U32 address, U16 data_length)
{
80002c9c:	d4 31       	pushm	r0-r7,lr
80002c9e:	18 94       	mov	r4,r12
80002ca0:	ed da b0 10 	bfexts	r6,r10,0x0,0x10
80002ca4:	16 97       	mov	r7,r11
80002ca6:	30 7c       	mov	r12,7
	df_status_t return_code = DF_WRITE_COMPLETED;
	U32 write_addr = address;
	U16 bytes_remained = data_length;

	while (bytes_remained >= 1 && return_code == DF_WRITE_COMPLETED)
80002ca8:	30 03       	mov	r3,0
80002caa:	06 92       	mov	r2,r3
	{
		if ((write_addr & 0xFF) == 0)
		{
			/* address 256 bytes aligned */

			if (bytes_remained <= DF_PAGE_SIZE)
80002cac:	e0 60 01 00 	mov	r0,256
{
	df_status_t return_code = DF_WRITE_COMPLETED;
	U32 write_addr = address;
	U16 bytes_remained = data_length;

	while (bytes_remained >= 1 && return_code == DF_WRITE_COMPLETED)
80002cb0:	c4 98       	rjmp	80002d42 <data_flash_write_block+0xa6>
	{
		if ((write_addr & 0xFF) == 0)
80002cb2:	eb d7 c0 08 	bfextu	r5,r7,0x0,0x8
80002cb6:	c1 b1       	brne	80002cec <data_flash_write_block+0x50>
		{
			/* address 256 bytes aligned */

			if (bytes_remained <= DF_PAGE_SIZE)
80002cb8:	e0 06 19 00 	cp.h	r6,r0
80002cbc:	e0 8b 00 0a 	brhi	80002cd0 <data_flash_write_block+0x34>
			{
				/* bytes remained less than one page */
				return_code = data_flash_write_page(data_ptr, write_addr, bytes_remained);
80002cc0:	f5 d6 c0 10 	bfextu	r10,r6,0x0,0x10
80002cc4:	0e 9b       	mov	r11,r7
80002cc6:	08 9c       	mov	r12,r4
80002cc8:	f0 1f 00 24 	mcall	80002d58 <data_flash_write_block+0xbc>
80002ccc:	30 06       	mov	r6,0
80002cce:	c3 a8       	rjmp	80002d42 <data_flash_write_block+0xa6>
				bytes_remained = 0;	/* end while loop */
			}
			else /* (bytes_remained > DF_PAGE_SIZE) */
			{
				/* bytes remained more than one page */
				return_code = data_flash_write_page(data_ptr, write_addr, DF_PAGE_SIZE);
80002cd0:	e0 6a 01 00 	mov	r10,256
80002cd4:	0e 9b       	mov	r11,r7
80002cd6:	08 9c       	mov	r12,r4
80002cd8:	f0 1f 00 20 	mcall	80002d58 <data_flash_write_block+0xbc>
				bytes_remained -= DF_PAGE_SIZE;
80002cdc:	ec c6 01 00 	sub	r6,r6,256
80002ce0:	5c 86       	casts.h	r6
				data_ptr += DF_PAGE_SIZE;
80002ce2:	e8 c4 ff 00 	sub	r4,r4,-256
				write_addr += DF_PAGE_SIZE;
80002ce6:	ee c7 ff 00 	sub	r7,r7,-256
80002cea:	c2 c8       	rjmp	80002d42 <data_flash_write_block+0xa6>
		}
		else
		{
			/*(write_addr & 0xFF != 0), address not 256 bytes aligned */

			if (BEYOND_PAGE_BOUNDARY(write_addr, bytes_remained) == TRUE)
80002cec:	f3 d6 c0 10 	bfextu	r9,r6,0x0,0x10
80002cf0:	0e 09       	add	r9,r7
80002cf2:	0e 98       	mov	r8,r7
80002cf4:	e4 18 00 7f 	andh	r8,0x7f
80002cf8:	e0 18 ff 00 	andl	r8,0xff00
80002cfc:	f0 c8 ff 00 	sub	r8,r8,-256
80002d00:	10 39       	cp.w	r9,r8
80002d02:	e0 88 00 19 	brls	80002d34 <data_flash_write_block+0x98>
			{
				/* bytes remained exceed current page, only write data within current page */
				return_code = data_flash_write_page(data_ptr, write_addr, BYTES_TO_NEXT_PAGE_BOUNDARY(write_addr));
80002d06:	0e 91       	mov	r1,r7
80002d08:	5c 51       	castu.b	r1
80002d0a:	e0 6a 01 00 	mov	r10,256
80002d0e:	02 1a       	sub	r10,r1
80002d10:	5c 7a       	castu.h	r10
80002d12:	0e 9b       	mov	r11,r7
80002d14:	08 9c       	mov	r12,r4
80002d16:	f0 1f 00 11 	mcall	80002d58 <data_flash_write_block+0xbc>
				bytes_remained -= BYTES_TO_NEXT_PAGE_BOUNDARY(write_addr);
80002d1a:	ec c6 01 00 	sub	r6,r6,256
80002d1e:	02 06       	add	r6,r1
80002d20:	5c 86       	casts.h	r6
				data_ptr += BYTES_TO_NEXT_PAGE_BOUNDARY(write_addr);
80002d22:	e0 68 01 00 	mov	r8,256
80002d26:	f0 05 01 05 	sub	r5,r8,r5
80002d2a:	0a 04       	add	r4,r5
				write_addr += BYTES_TO_NEXT_PAGE_BOUNDARY(write_addr); /* now became 256 bytes aligned */
80002d2c:	e0 17 ff 00 	andl	r7,0xff00
80002d30:	10 07       	add	r7,r8
80002d32:	c0 88       	rjmp	80002d42 <data_flash_write_block+0xa6>
			}
			else
			{
				/* bytes remained not exceed current page */
				return_code = data_flash_write_page(data_ptr, write_addr, bytes_remained);
80002d34:	f5 d6 c0 10 	bfextu	r10,r6,0x0,0x10
80002d38:	0e 9b       	mov	r11,r7
80002d3a:	08 9c       	mov	r12,r4
80002d3c:	f0 1f 00 07 	mcall	80002d58 <data_flash_write_block+0xbc>
80002d40:	30 06       	mov	r6,0
{
	df_status_t return_code = DF_WRITE_COMPLETED;
	U32 write_addr = address;
	U16 bytes_remained = data_length;

	while (bytes_remained >= 1 && return_code == DF_WRITE_COMPLETED)
80002d42:	e6 06 19 00 	cp.h	r6,r3
80002d46:	5f 19       	srne	r9
80002d48:	58 7c       	cp.w	r12,7
80002d4a:	5f 08       	sreq	r8
80002d4c:	f3 e8 00 08 	and	r8,r9,r8
80002d50:	e4 08 18 00 	cp.b	r8,r2
80002d54:	ca f1       	brne	80002cb2 <data_flash_write_block+0x16>
			}
		}
	}	/* end of while */

	return return_code;
}
80002d56:	d8 32       	popm	r0-r7,pc
80002d58:	80 00       	ld.sh	r0,r0[0x0]
80002d5a:	2b fc       	sub	r12,-65

80002d5c <data_flash_erase_block>:
* ----------  --------  ----------  --------------------------------------------
* 25-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_erase_block(U32 address, df_block_size_t block_size)
{
80002d5c:	eb cd 40 f8 	pushm	r3-r7,lr
80002d60:	18 94       	mov	r4,r12
	U16 erase_commond;
	df_status_t return_code = DF_ERASE_FAIL;
	U16 count = 0; /* to monitor erase time consumption */

	/* check input parameter */
	if (address >= DF_MAX_ADDR)
80002d62:	e0 68 ff fe 	mov	r8,65534
80002d66:	ea 18 00 7f 	orh	r8,0x7f
80002d6a:	10 3c       	cp.w	r12,r8
80002d6c:	e0 88 00 04 	brls	80002d74 <data_flash_erase_block+0x18>
80002d70:	30 17       	mov	r7,1
80002d72:	c3 f8       	rjmp	80002df0 <data_flash_erase_block+0x94>
	{
		return DF_INVALID_PARAM;
	}

	/* determine erase command to be issued */
	if (block_size == DF_BLOCK_4KB)
80002d74:	58 1b       	cp.w	r11,1
80002d76:	c0 31       	brne	80002d7c <data_flash_erase_block+0x20>
80002d78:	32 03       	mov	r3,32
80002d7a:	c0 a8       	rjmp	80002d8e <data_flash_erase_block+0x32>
		erase_commond = BLOCK_ERASE_4KB;
	else if (block_size == DF_BLOCK_32KB)
80002d7c:	58 2b       	cp.w	r11,2
80002d7e:	c0 31       	brne	80002d84 <data_flash_erase_block+0x28>
80002d80:	35 23       	mov	r3,82
80002d82:	c0 68       	rjmp	80002d8e <data_flash_erase_block+0x32>
		erase_commond = BLOCK_ERASE_32KB;
	else if(block_size == DF_BLOCK_64KB)
80002d84:	e0 63 00 d8 	mov	r3,216
80002d88:	58 3b       	cp.w	r11,3
80002d8a:	f9 b3 01 60 	movne	r3,96
		erase_commond = BLOCK_ERASE_64KB;
	else/*(block_size == DF_BLOCK_ALL)*/
		erase_commond = CHIP_ERASE;

	while(status = send_flash_command(READ_STATUS_REG, 0, NULL, 0) == STATUS_BUSY);
80002d8e:	30 06       	mov	r6,0
80002d90:	30 55       	mov	r5,5
80002d92:	30 17       	mov	r7,1
80002d94:	0c 99       	mov	r9,r6
80002d96:	0c 9a       	mov	r10,r6
80002d98:	0c 9b       	mov	r11,r6
80002d9a:	0a 9c       	mov	r12,r5
80002d9c:	f0 1f 00 17 	mcall	80002df8 <data_flash_erase_block+0x9c>
80002da0:	ee 0c 19 00 	cp.h	r12,r7
80002da4:	cf 80       	breq	80002d94 <data_flash_erase_block+0x38>
	//{
		//return DF_DEVICE_BUSY;
	//}

	/* send WRITE_ENABLE command */
	send_flash_command(WRITE_ENABLE, 0, NULL, 0);
80002da6:	30 09       	mov	r9,0
80002da8:	12 9a       	mov	r10,r9
80002daa:	12 9b       	mov	r11,r9
80002dac:	30 6c       	mov	r12,6
80002dae:	f0 1f 00 13 	mcall	80002df8 <data_flash_erase_block+0x9c>

	/* send BLOCK_ERASE command */
	send_flash_command(erase_commond, address, NULL, 0);
80002db2:	30 09       	mov	r9,0
80002db4:	12 9a       	mov	r10,r9
80002db6:	08 9b       	mov	r11,r4
80002db8:	06 9c       	mov	r12,r3
80002dba:	f0 1f 00 10 	mcall	80002df8 <data_flash_erase_block+0x9c>
	do {
		status = send_flash_command(READ_STATUS_REG, 0, NULL, 0);
80002dbe:	30 06       	mov	r6,0
80002dc0:	30 57       	mov	r7,5
80002dc2:	0c 99       	mov	r9,r6
80002dc4:	0c 9a       	mov	r10,r6
80002dc6:	0c 9b       	mov	r11,r6
80002dc8:	0e 9c       	mov	r12,r7
80002dca:	f0 1f 00 0c 	mcall	80002df8 <data_flash_erase_block+0x9c>
		count++;
	} while((status & STATUS_BUSY) != 0);
80002dce:	5c 7c       	castu.h	r12
80002dd0:	f1 dc c0 01 	bfextu	r8,r12,0x0,0x1
80002dd4:	cf 71       	brne	80002dc2 <data_flash_erase_block+0x66>

	/*  Check Status Register */
	if ((status & STATUS_ERASE_PROG_ERROR) != 0)
80002dd6:	18 97       	mov	r7,r12
80002dd8:	e2 17 00 20 	andl	r7,0x20,COH
80002ddc:	f9 b7 01 04 	movne	r7,4
80002de0:	f9 b7 00 05 	moveq	r7,5
		/*  Erase Successful.  */
		return_code = DF_ERASE_COMPLETED;
	}

	/* send WRITE_DISABLE command */
	send_flash_command(WRITE_DISABLE, 0, NULL, 0);
80002de4:	30 09       	mov	r9,0
80002de6:	12 9a       	mov	r10,r9
80002de8:	12 9b       	mov	r11,r9
80002dea:	30 4c       	mov	r12,4
80002dec:	f0 1f 00 03 	mcall	80002df8 <data_flash_erase_block+0x9c>

	return return_code;
}
80002df0:	0e 9c       	mov	r12,r7
80002df2:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80002df6:	00 00       	add	r0,r0
80002df8:	80 00       	ld.sh	r0,r0[0x0]
80002dfa:	2a 00       	sub	r0,-96

80002dfc <data_flash_write>:
* ----------  --------  ----------  --------------------------------------------
* 25-Fri-17   Edwards    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_write(U8 *data_ptr, U32 address, U16 data_length)
{
80002dfc:	d4 31       	pushm	r0-r7,lr
80002dfe:	20 3d       	sub	sp,12
80002e00:	50 0c       	stdsp	sp[0x0],r12
80002e02:	16 91       	mov	r1,r11
80002e04:	14 95       	mov	r5,r10
	U16 secremain;
	U16 i;
	df_status_t return_code = DF_OK;

	secpos	=	address/4096;//扇区地址 0~2047 for AT25DF641 
	secoff	=	address%4096;//在扇区内的偏移
80002e06:	f5 db c0 0c 	bfextu	r10,r11,0x0,0xc
80002e0a:	50 1a       	stdsp	sp[0x4],r10
	secremain	=	4096-secoff;//扇区剩余空间大小
80002e0c:	e0 69 10 00 	mov	r9,4096
80002e10:	f2 0a 01 07 	sub	r7,r9,r10
80002e14:	ea 07 19 00 	cp.h	r7,r5
80002e18:	ea 07 17 b0 	movhi	r7,r5
80002e1c:	5c 87       	casts.h	r7
80002e1e:	16 92       	mov	r2,r11
80002e20:	e0 12 f0 00 	andl	r2,0xf000
	if(data_length <= secremain)secremain = data_length;//不大于4096个字节
	while(1)
	{
		data_flash_read_block(secpos*4096, 4096, FLASH_BUF);//读出整个扇区的内容
80002e24:	4a e4       	lddpc	r4,80002edc <data_flash_write+0xe0>
		for(i=0; i<secremain; i++)//校验数据
		{
			if(FLASH_BUF[secoff+i]!=0XFF)break;//需要擦除
80002e26:	3f f6       	mov	r6,-1
* Date        Name      Prob#       Description
* ----------  --------  ----------  --------------------------------------------
* 25-Fri-17   Edwards    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_write(U8 *data_ptr, U32 address, U16 data_length)
80002e28:	e8 c8 ff ff 	sub	r8,r4,-1
80002e2c:	50 28       	stdsp	sp[0x8],r8
			secpos++;//扇区地址增1
			secoff=0;//偏移位置为0

			data_ptr+=secremain;  //指针偏移
			address+=secremain;//写地址偏移
			data_length-=secremain;				//字节数递减
80002e2e:	12 90       	mov	r0,r9
	secoff	=	address%4096;//在扇区内的偏移
	secremain	=	4096-secoff;//扇区剩余空间大小
	if(data_length <= secremain)secremain = data_length;//不大于4096个字节
	while(1)
	{
		data_flash_read_block(secpos*4096, 4096, FLASH_BUF);//读出整个扇区的内容
80002e30:	08 9a       	mov	r10,r4
80002e32:	e0 6b 10 00 	mov	r11,4096
80002e36:	04 9c       	mov	r12,r2
80002e38:	f0 1f 00 2a 	mcall	80002ee0 <data_flash_write+0xe4>
		for(i=0; i<secremain; i++)//校验数据
80002e3c:	58 07       	cp.w	r7,0
80002e3e:	c3 00       	breq	80002e9e <data_flash_write+0xa2>
		{
			if(FLASH_BUF[secoff+i]!=0XFF)break;//需要擦除
80002e40:	40 13       	lddsp	r3,sp[0x4]
80002e42:	5c 73       	castu.h	r3
80002e44:	e8 03 07 08 	ld.ub	r8,r4[r3]
80002e48:	ec 08 18 00 	cp.b	r8,r6
80002e4c:	c1 11       	brne	80002e6e <data_flash_write+0x72>
80002e4e:	e6 c9 ff ff 	sub	r9,r3,-1
80002e52:	08 09       	add	r9,r4
80002e54:	30 08       	mov	r8,0
80002e56:	c0 58       	rjmp	80002e60 <data_flash_write+0x64>
80002e58:	13 3a       	ld.ub	r10,r9++
80002e5a:	ec 0a 18 00 	cp.b	r10,r6
80002e5e:	c0 81       	brne	80002e6e <data_flash_write+0x72>
	secremain	=	4096-secoff;//扇区剩余空间大小
	if(data_length <= secremain)secremain = data_length;//不大于4096个字节
	while(1)
	{
		data_flash_read_block(secpos*4096, 4096, FLASH_BUF);//读出整个扇区的内容
		for(i=0; i<secremain; i++)//校验数据
80002e60:	2f f8       	sub	r8,-1
80002e62:	5c 88       	casts.h	r8
80002e64:	f0 07 19 00 	cp.h	r7,r8
80002e68:	fe 9b ff f8 	brhi	80002e58 <data_flash_write+0x5c>
80002e6c:	c1 98       	rjmp	80002e9e <data_flash_write+0xa2>
		{
			if(FLASH_BUF[secoff+i]!=0XFF)break;//需要擦除
		}
		if(i < secremain)//需要擦除
		{
			return_code = data_flash_erase_block(secpos*4096, DF_BLOCK_4KB);//擦除这个扇区
80002e6e:	30 1b       	mov	r11,1
80002e70:	04 9c       	mov	r12,r2
80002e72:	f0 1f 00 1d 	mcall	80002ee4 <data_flash_write+0xe8>
80002e76:	40 08       	lddsp	r8,sp[0x0]
80002e78:	08 03       	add	r3,r4
* Date        Name      Prob#       Description
* ----------  --------  ----------  --------------------------------------------
* 25-Fri-17   Edwards    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_write(U8 *data_ptr, U32 address, U16 data_length)
80002e7a:	40 2a       	lddsp	r10,sp[0x8]
80002e7c:	40 19       	lddsp	r9,sp[0x4]
80002e7e:	12 0a       	add	r10,r9
80002e80:	0e 99       	mov	r9,r7
80002e82:	20 19       	sub	r9,1
80002e84:	5c 79       	castu.h	r9
80002e86:	12 0a       	add	r10,r9
		if(i < secremain)//需要擦除
		{
			return_code = data_flash_erase_block(secpos*4096, DF_BLOCK_4KB);//擦除这个扇区
			for(i=0; i<secremain; i++)	   //复制
			{
				FLASH_BUF[i+secoff]=data_ptr[i];
80002e88:	11 39       	ld.ub	r9,r8++
80002e8a:	06 c9       	st.b	r3++,r9
			if(FLASH_BUF[secoff+i]!=0XFF)break;//需要擦除
		}
		if(i < secremain)//需要擦除
		{
			return_code = data_flash_erase_block(secpos*4096, DF_BLOCK_4KB);//擦除这个扇区
			for(i=0; i<secremain; i++)	   //复制
80002e8c:	14 33       	cp.w	r3,r10
80002e8e:	cf d1       	brne	80002e88 <data_flash_write+0x8c>
			{
				FLASH_BUF[i+secoff]=data_ptr[i];
			}
			return_code = data_flash_write_block(FLASH_BUF, secpos*4096, 4096);//写入整个扇区
80002e90:	e0 6a 10 00 	mov	r10,4096
80002e94:	04 9b       	mov	r11,r2
80002e96:	08 9c       	mov	r12,r4
80002e98:	f0 1f 00 14 	mcall	80002ee8 <data_flash_write+0xec>
80002e9c:	c0 78       	rjmp	80002eaa <data_flash_write+0xae>

		}
		else 
		{
			return_code = data_flash_write_block(data_ptr, address, secremain);//写已经擦除了的,直接写入扇区剩余区间.
80002e9e:	0e 9a       	mov	r10,r7
80002ea0:	5c 7a       	castu.h	r10
80002ea2:	02 9b       	mov	r11,r1
80002ea4:	40 0c       	lddsp	r12,sp[0x0]
80002ea6:	f0 1f 00 11 	mcall	80002ee8 <data_flash_write+0xec>
80002eaa:	e4 c2 f0 00 	sub	r2,r2,-4096
		}
		if(data_length==secremain)break;//写入结束了
80002eae:	0e 98       	mov	r8,r7
80002eb0:	ee 05 19 00 	cp.h	r5,r7
80002eb4:	c1 20       	breq	80002ed8 <data_flash_write+0xdc>
		else//写入未结束
		{
			secpos++;//扇区地址增1
			secoff=0;//偏移位置为0

			data_ptr+=secremain;  //指针偏移
80002eb6:	5c 78       	castu.h	r8
80002eb8:	40 0a       	lddsp	r10,sp[0x0]
80002eba:	10 0a       	add	r10,r8
80002ebc:	50 0a       	stdsp	sp[0x0],r10
			address+=secremain;//写地址偏移
80002ebe:	10 01       	add	r1,r8
			data_length-=secremain;				//字节数递减
80002ec0:	0e 15       	sub	r5,r7
80002ec2:	5c 85       	casts.h	r5
80002ec4:	e0 05 19 00 	cp.h	r5,r0
80002ec8:	ea 07 17 80 	movls	r7,r5
80002ecc:	e0 07 17 b0 	movhi	r7,r0
80002ed0:	5c 87       	casts.h	r7
80002ed2:	30 09       	mov	r9,0
80002ed4:	50 19       	stdsp	sp[0x4],r9
80002ed6:	ca db       	rjmp	80002e30 <data_flash_write+0x34>
		}
	}
	
	return return_code;
	
}
80002ed8:	2f dd       	sub	sp,-12
80002eda:	d8 32       	popm	r0-r7,pc
80002edc:	00 00       	add	r0,r0
80002ede:	10 90       	mov	r0,r8
80002ee0:	80 00       	ld.sh	r0,r0[0x0]
80002ee2:	2b c4       	sub	r4,-68
80002ee4:	80 00       	ld.sh	r0,r0[0x0]
80002ee6:	2d 5c       	sub	r12,-43
80002ee8:	80 00       	ld.sh	r0,r0[0x0]
80002eea:	2c 9c       	sub	r12,-55

80002eec <data_flash_init>:
* ----------  --------  ----------  --------------------------------------------
* 10-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
void data_flash_init(void)
{
80002eec:	eb cd 40 c0 	pushm	r6-r7,lr
80002ef0:	20 5d       	sub	sp,20
		.spck_delay   = 0,
		.trans_delay  = 0,
		.stay_act     = 1,
		.spi_mode     = 1,//0,0 针对不同的存储芯片，注意模式
		.modfdis      = 1
	};
80002ef2:	4b 98       	lddpc	r8,80002fd4 <data_flash_init+0xe8>
80002ef4:	fa c6 ff fc 	sub	r6,sp,-4
80002ef8:	f0 ea 00 00 	ld.d	r10,r8[0]
80002efc:	ec eb 00 00 	st.d	r6[0],r10
80002f00:	f0 e8 00 08 	ld.d	r8,r8[8]
80002f04:	ec e9 00 08 	st.d	r6[8],r8

	// Assign I/Os to SPI.
	gpio_enable_module(DF_SPI_GPIO_MAP, sizeof(DF_SPI_GPIO_MAP) / sizeof(DF_SPI_GPIO_MAP[0]));
80002f08:	30 4b       	mov	r11,4
80002f0a:	4b 4c       	lddpc	r12,80002fd8 <data_flash_init+0xec>
80002f0c:	f0 1f 00 34 	mcall	80002fdc <data_flash_init+0xf0>

	spi = &AVR32_SPI;
80002f10:	4b 47       	lddpc	r7,80002fe0 <data_flash_init+0xf4>
80002f12:	fe 7c 24 00 	mov	r12,-56320
80002f16:	8f 0c       	st.w	r7[0x0],r12

	// Initialize as master.
	spi_initMaster(spi, &spiOptions);
80002f18:	0c 9b       	mov	r11,r6
80002f1a:	f0 1f 00 33 	mcall	80002fe4 <data_flash_init+0xf8>

	// Set selection mode: variable_ps, pcs_decode, delay.
	spi_selectionMode(spi, 0, 0, 0);
80002f1e:	30 09       	mov	r9,0
80002f20:	12 9a       	mov	r10,r9
80002f22:	12 9b       	mov	r11,r9
80002f24:	6e 0c       	ld.w	r12,r7[0x0]
80002f26:	f0 1f 00 31 	mcall	80002fe8 <data_flash_init+0xfc>

	// Enable SPI.
	spi_enable(spi);
80002f2a:	6e 0c       	ld.w	r12,r7[0x0]
80002f2c:	f0 1f 00 30 	mcall	80002fec <data_flash_init+0x100>

	// Initialize data flash with SPI clock PBA.
	if (spi_setupChipReg(spi, &spiOptions, 2*12000000) != SPI_OK)
80002f30:	e0 6a 36 00 	mov	r10,13824
80002f34:	ea 1a 01 6e 	orh	r10,0x16e
80002f38:	0c 9b       	mov	r11,r6
80002f3a:	6e 0c       	ld.w	r12,r7[0x0]
80002f3c:	f0 1f 00 2d 	mcall	80002ff0 <data_flash_init+0x104>
80002f40:	c0 50       	breq	80002f4a <data_flash_init+0x5e>
	{
		data_flash_failure = FATAL_ERROR_DATA_FLASH_SPI_INIT;
80002f42:	30 29       	mov	r9,2
80002f44:	4a c8       	lddpc	r8,80002ff4 <data_flash_init+0x108>
80002f46:	b0 89       	st.b	r8[0x0],r9
		return;
80002f48:	c4 28       	rjmp	80002fcc <data_flash_init+0xe0>
* 10-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
static Bool data_flash_check_device_id(void)
{
	U16 manufacturer_device_id[2] = {0x5A5A, 0x5A5A};
80002f4a:	1a 96       	mov	r6,sp
80002f4c:	30 4a       	mov	r10,4
80002f4e:	4a bb       	lddpc	r11,80002ff8 <data_flash_init+0x10c>
80002f50:	1a 9c       	mov	r12,sp
80002f52:	f0 1f 00 2b 	mcall	80002ffc <data_flash_init+0x110>

	/* DF memory check. */
	/* Select the DF memory to check. */
	spi_selectChip(spi, DF_SPI_PCS_1);
80002f56:	4a 37       	lddpc	r7,80002fe0 <data_flash_init+0xf4>
80002f58:	30 1b       	mov	r11,1
80002f5a:	6e 0c       	ld.w	r12,r7[0x0]
80002f5c:	f0 1f 00 29 	mcall	80003000 <data_flash_init+0x114>

	/* Send the Manufacturer/Device ID Read command. */
	spi_write(spi, READ_M_D_ID);	
80002f60:	e0 6b 00 90 	mov	r11,144
80002f64:	6e 0c       	ld.w	r12,r7[0x0]
80002f66:	f0 1f 00 28 	mcall	80003004 <data_flash_init+0x118>
	spi_write_zero();
80002f6a:	30 0b       	mov	r11,0
80002f6c:	6e 0c       	ld.w	r12,r7[0x0]
80002f6e:	f0 1f 00 26 	mcall	80003004 <data_flash_init+0x118>
	spi_write_zero();
80002f72:	30 0b       	mov	r11,0
80002f74:	6e 0c       	ld.w	r12,r7[0x0]
80002f76:	f0 1f 00 24 	mcall	80003004 <data_flash_init+0x118>
	spi_write_zero();
80002f7a:	30 0b       	mov	r11,0
80002f7c:	6e 0c       	ld.w	r12,r7[0x0]
80002f7e:	f0 1f 00 22 	mcall	80003004 <data_flash_init+0x118>

	/* Send 2 dummy byte to read the status register. */
	
	spi_write_dummy();
80002f82:	e0 6b 00 ff 	mov	r11,255
80002f86:	6e 0c       	ld.w	r12,r7[0x0]
80002f88:	f0 1f 00 1f 	mcall	80003004 <data_flash_init+0x118>
	spi_read(spi, &manufacturer_device_id[0]);
80002f8c:	1a 9b       	mov	r11,sp
80002f8e:	6e 0c       	ld.w	r12,r7[0x0]
80002f90:	f0 1f 00 1e 	mcall	80003008 <data_flash_init+0x11c>
	
	spi_write_dummy();
80002f94:	e0 6b 00 ff 	mov	r11,255
80002f98:	6e 0c       	ld.w	r12,r7[0x0]
80002f9a:	f0 1f 00 1b 	mcall	80003004 <data_flash_init+0x118>
	spi_read(spi, &manufacturer_device_id[1]);
80002f9e:	fa cb ff fe 	sub	r11,sp,-2
80002fa2:	6e 0c       	ld.w	r12,r7[0x0]
80002fa4:	f0 1f 00 19 	mcall	80003008 <data_flash_init+0x11c>

	/* Unselect the checked DF memory. */
	spi_unselectChip(spi, DF_SPI_PCS_1);
80002fa8:	30 1b       	mov	r11,1
80002faa:	6e 0c       	ld.w	r12,r7[0x0]
80002fac:	f0 1f 00 18 	mcall	8000300c <data_flash_init+0x120>

	/* Unexpected device ID. */
    if ((manufacturer_device_id[0] != 0xEF) || (manufacturer_device_id[1] != 0x16))
80002fb0:	e0 68 00 ef 	mov	r8,239
80002fb4:	9a 09       	ld.sh	r9,sp[0x0]
80002fb6:	f0 09 19 00 	cp.h	r9,r8
80002fba:	c0 61       	brne	80002fc6 <data_flash_init+0xda>
80002fbc:	31 68       	mov	r8,22
80002fbe:	9a 19       	ld.sh	r9,sp[0x2]
80002fc0:	f0 09 19 00 	cp.h	r9,r8
80002fc4:	c0 40       	breq	80002fcc <data_flash_init+0xe0>
		return;
	}
	 
	if (data_flash_check_device_id() != TRUE)//check W25Q64 ID
	{
		data_flash_failure = FATAL_ERROR_DATA_FLASH_READ_ID;
80002fc6:	30 39       	mov	r9,3
80002fc8:	48 b8       	lddpc	r8,80002ff4 <data_flash_init+0x108>
80002fca:	b0 89       	st.b	r8[0x0],r9
	//send_flash_command(WRITE_ENABLE, 0, NULL, 0);
	//send_flash_command(WRITE_STATUS_REG_BYTE_1, 0, NULL, 0);
	//status = send_flash_command(READ_STATUS_REG, 0, NULL, 0);
	
	return;
}
80002fcc:	2f bd       	sub	sp,-20
80002fce:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002fd2:	00 00       	add	r0,r0
80002fd4:	80 00       	ld.sh	r0,r0[0x0]
80002fd6:	df 5c       	*unknown*
80002fd8:	80 00       	ld.sh	r0,r0[0x0]
80002fda:	df 3c       	*unknown*
80002fdc:	80 00       	ld.sh	r0,r0[0x0]
80002fde:	5c 40       	abs	r0
80002fe0:	00 00       	add	r0,r0
80002fe2:	20 90       	sub	r0,9
80002fe4:	80 00       	ld.sh	r0,r0[0x0]
80002fe6:	60 b0       	ld.w	r0,r0[0x2c]
80002fe8:	80 00       	ld.sh	r0,r0[0x0]
80002fea:	60 e8       	ld.w	r8,r0[0x38]
80002fec:	80 00       	ld.sh	r0,r0[0x0]
80002fee:	61 14       	ld.w	r4,r0[0x44]
80002ff0:	80 00       	ld.sh	r0,r0[0x0]
80002ff2:	61 58       	ld.w	r8,r0[0x54]
80002ff4:	00 00       	add	r0,r0
80002ff6:	0a 70       	tst	r0,r5
80002ff8:	80 00       	ld.sh	r0,r0[0x0]
80002ffa:	df 6c       	*unknown*
80002ffc:	80 00       	ld.sh	r0,r0[0x0]
80002ffe:	81 06       	st.w	r0[0x0],r6
80003000:	80 00       	ld.sh	r0,r0[0x0]
80003002:	62 80       	ld.w	r0,r1[0x20]
80003004:	80 00       	ld.sh	r0,r0[0x0]
80003006:	61 1a       	ld.w	r10,r0[0x44]
80003008:	80 00       	ld.sh	r0,r0[0x0]
8000300a:	61 36       	ld.w	r6,r0[0x4c]
8000300c:	80 00       	ld.sh	r0,r0[0x0]
8000300e:	62 40       	ld.w	r0,r1[0x10]

80003010 <xg_rtc_init>:
}



void xg_rtc_init(void)
{
80003010:	d4 01       	pushm	lr
	
	// Disable all interrupts. */
	Disable_global_interrupt();
80003012:	d3 03       	ssrf	0x10
	  
	// Register the RTC interrupt handler to the interrupt controller.
	INTC_register_interrupt(&rtc_irq, AVR32_RTC_IRQ, AVR32_INTC_INT0);
80003014:	30 0a       	mov	r10,0
80003016:	32 8b       	mov	r11,40
80003018:	49 5c       	lddpc	r12,8000306c <xg_rtc_init+0x5c>
8000301a:	f0 1f 00 16 	mcall	80003070 <xg_rtc_init+0x60>

	// Initialize the RTC
	//if (!rtc_init(&AVR32_RTC, RTC_OSC_RC, RTC_PSEL_RC_1_76HZ))
	if (!rtc_init(&AVR32_RTC, RTC_OSC_32KHZ, RTC_PSEL_32KHZ_1HZ))
8000301e:	30 ea       	mov	r10,14
80003020:	30 1b       	mov	r11,1
80003022:	fe 7c 0d 00 	mov	r12,-62208
80003026:	f0 1f 00 14 	mcall	80003074 <xg_rtc_init+0x64>
8000302a:	c0 41       	brne	80003032 <xg_rtc_init+0x22>
	{
		log("Error initializing the RTC\r\n");
8000302c:	49 3c       	lddpc	r12,80003078 <xg_rtc_init+0x68>
8000302e:	f0 1f 00 14 	mcall	8000307c <xg_rtc_init+0x6c>
	}
	// Set top value to 0 to generate an interrupt every seconds */
	rtc_set_top_value(&AVR32_RTC, 0);
80003032:	30 0b       	mov	r11,0
80003034:	fe 7c 0d 00 	mov	r12,-62208
80003038:	f0 1f 00 12 	mcall	80003080 <xg_rtc_init+0x70>
	// Enable the interrupts
	rtc_enable_interrupt(&AVR32_RTC);
8000303c:	fe 7c 0d 00 	mov	r12,-62208
80003040:	f0 1f 00 11 	mcall	80003084 <xg_rtc_init+0x74>
	// Enable the RTC
	rtc_enable(&AVR32_RTC);
80003044:	fe 7c 0d 00 	mov	r12,-62208
80003048:	f0 1f 00 10 	mcall	80003088 <xg_rtc_init+0x78>

	Current_time.Year		= 16;
8000304c:	49 08       	lddpc	r8,8000308c <xg_rtc_init+0x7c>
8000304e:	31 09       	mov	r9,16
80003050:	b0 89       	st.b	r8[0x0],r9
	Current_time.Month		= 2;
80003052:	30 29       	mov	r9,2
80003054:	b0 99       	st.b	r8[0x1],r9
	Current_time.Day		= 29;
80003056:	31 d9       	mov	r9,29
80003058:	b0 a9       	st.b	r8[0x2],r9
	Current_time.Hour		= 23;
8000305a:	31 79       	mov	r9,23
8000305c:	b0 b9       	st.b	r8[0x3],r9
	Current_time.Minute		= 59;
8000305e:	33 b9       	mov	r9,59
80003060:	b0 c9       	st.b	r8[0x4],r9
	Current_time.Second		= 40;
80003062:	32 89       	mov	r9,40
80003064:	b0 d9       	st.b	r8[0x5],r9
	
	// Enable global interrupts
	Enable_global_interrupt();
80003066:	d5 03       	csrf	0x10
	  
	//RTC_Test();	

}
80003068:	d8 02       	popm	pc
8000306a:	00 00       	add	r0,r0
8000306c:	80 00       	ld.sh	r0,r0[0x0]
8000306e:	30 90       	mov	r0,9
80003070:	80 00       	ld.sh	r0,r0[0x0]
80003072:	5c c4       	swap.bh	r4
80003074:	80 00       	ld.sh	r0,r0[0x0]
80003076:	60 10       	ld.w	r0,r0[0x4]
80003078:	80 00       	ld.sh	r0,r0[0x0]
8000307a:	df 70       	acall	0xf7
8000307c:	80 00       	ld.sh	r0,r0[0x0]
8000307e:	78 5c       	ld.w	r12,r12[0x14]
80003080:	80 00       	ld.sh	r0,r0[0x0]
80003082:	5f cc       	srvs	r12
80003084:	80 00       	ld.sh	r0,r0[0x0]
80003086:	5f c4       	srvs	r4
80003088:	80 00       	ld.sh	r0,r0[0x0]
8000308a:	5f a0       	srle	r0
8000308c:	00 00       	add	r0,r0
8000308e:	0e 08       	add	r8,r7

80003090 <rtc_irq>:
/* RTC Interrupt  */
#pragma handler = AVR32_RTC_IRQ_GROUP, 1
__interrupt
#endif
void rtc_irq(void)
{
80003090:	d4 01       	pushm	lr
	U8 T,K;
	U32 T16,K16;
	// Increment the minutes counter
	//sec++;
	
	Current_time.Second++;
80003092:	4b 98       	lddpc	r8,80003174 <rtc_irq+0xe4>
80003094:	11 d9       	ld.ub	r9,r8[0x5]
80003096:	2f f9       	sub	r9,-1
80003098:	b0 d9       	st.b	r8[0x5],r9
	if(Current_time.Second>=60)
8000309a:	11 d9       	ld.ub	r9,r8[0x5]
8000309c:	33 b8       	mov	r8,59
8000309e:	f0 09 18 00 	cp.b	r9,r8
800030a2:	e0 88 00 5f 	brls	80003160 <rtc_irq+0xd0>
	{
		Current_time.Second =0;
800030a6:	4b 48       	lddpc	r8,80003174 <rtc_irq+0xe4>
800030a8:	30 09       	mov	r9,0
800030aa:	b0 d9       	st.b	r8[0x5],r9
		Current_time.Minute++;
800030ac:	11 c9       	ld.ub	r9,r8[0x4]
800030ae:	2f f9       	sub	r9,-1
800030b0:	b0 c9       	st.b	r8[0x4],r9
		if(Current_time.Minute>=60)
800030b2:	11 c9       	ld.ub	r9,r8[0x4]
800030b4:	33 b8       	mov	r8,59
800030b6:	f0 09 18 00 	cp.b	r9,r8
800030ba:	e0 88 00 53 	brls	80003160 <rtc_irq+0xd0>
		{
			Current_time.Minute=0;
800030be:	4a e8       	lddpc	r8,80003174 <rtc_irq+0xe4>
800030c0:	30 09       	mov	r9,0
800030c2:	b0 c9       	st.b	r8[0x4],r9
			Current_time.Hour++;
800030c4:	11 b9       	ld.ub	r9,r8[0x3]
800030c6:	2f f9       	sub	r9,-1
800030c8:	b0 b9       	st.b	r8[0x3],r9
			if (Current_time.Hour>=24)
800030ca:	11 b9       	ld.ub	r9,r8[0x3]
800030cc:	31 78       	mov	r8,23
800030ce:	f0 09 18 00 	cp.b	r9,r8
800030d2:	e0 88 00 47 	brls	80003160 <rtc_irq+0xd0>
			{
				Current_time.Hour=0;
800030d6:	4a 88       	lddpc	r8,80003174 <rtc_irq+0xe4>
800030d8:	30 09       	mov	r9,0
800030da:	b0 b9       	st.b	r8[0x3],r9
				K16=(Current_time.Year&0x03)?365:366;				//判断当年是否为闰年,并获取当年的总天数（此算法时间起点为2000年）
800030dc:	11 88       	ld.ub	r8,r8[0x0]
800030de:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
800030e2:	e0 69 01 6e 	mov	r9,366
800030e6:	e0 6a 01 6d 	mov	r10,365
800030ea:	f4 08 17 10 	movne	r8,r10
800030ee:	f2 08 17 00 	moveq	r8,r9
				K16-=337;											//计算当年二月份天数
				//统计当月天数				
				K=(Current_time.Month==2)?K16:(((Current_time.Month+(Current_time.Month>>3))&0x01)+30);			
800030f2:	4a 19       	lddpc	r9,80003174 <rtc_irq+0xe4>
800030f4:	13 9a       	ld.ub	r10,r9[0x1]
800030f6:	30 29       	mov	r9,2
800030f8:	f2 0a 18 00 	cp.b	r10,r9
800030fc:	c0 b0       	breq	80003112 <rtc_irq+0x82>
800030fe:	49 e8       	lddpc	r8,80003174 <rtc_irq+0xe4>
80003100:	11 99       	ld.ub	r9,r8[0x1]
80003102:	11 9a       	ld.ub	r10,r8[0x1]
80003104:	a3 9a       	lsr	r10,0x3
80003106:	12 0a       	add	r10,r9
80003108:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
8000310c:	2e 2a       	sub	r10,-30
8000310e:	5c 5a       	castu.b	r10
80003110:	c0 58       	rjmp	8000311a <rtc_irq+0x8a>
80003112:	f0 c8 01 51 	sub	r8,r8,337
80003116:	f5 d8 c0 08 	bfextu	r10,r8,0x0,0x8
				Current_time.Day++;
8000311a:	49 78       	lddpc	r8,80003174 <rtc_irq+0xe4>
8000311c:	11 a9       	ld.ub	r9,r8[0x2]
8000311e:	2f f9       	sub	r9,-1
80003120:	b0 a9       	st.b	r8[0x2],r9
				if(Current_time.Day>K)
80003122:	11 a8       	ld.ub	r8,r8[0x2]
80003124:	f0 0a 18 00 	cp.b	r10,r8
80003128:	c1 c2       	brcc	80003160 <rtc_irq+0xd0>
				{	
					Current_time.Day = 1;//重置到下月1号
8000312a:	49 38       	lddpc	r8,80003174 <rtc_irq+0xe4>
8000312c:	30 19       	mov	r9,1
8000312e:	b0 a9       	st.b	r8[0x2],r9
					Current_time.Month++;
80003130:	11 99       	ld.ub	r9,r8[0x1]
80003132:	2f f9       	sub	r9,-1
80003134:	b0 99       	st.b	r8[0x1],r9
					if(Current_time.Month>12)
80003136:	11 99       	ld.ub	r9,r8[0x1]
80003138:	30 c8       	mov	r8,12
8000313a:	f0 09 18 00 	cp.b	r9,r8
8000313e:	e0 88 00 11 	brls	80003160 <rtc_irq+0xd0>
					{
						Current_time.Month = 1;//重置到下一年的第一个月
80003142:	48 d8       	lddpc	r8,80003174 <rtc_irq+0xe4>
80003144:	30 19       	mov	r9,1
80003146:	b0 99       	st.b	r8[0x1],r9
						Current_time.Year++;
80003148:	11 89       	ld.ub	r9,r8[0x0]
8000314a:	2f f9       	sub	r9,-1
8000314c:	b0 89       	st.b	r8[0x0],r9
						if (Current_time.Year>150)Current_time.Year=0;//重置年份											
8000314e:	11 89       	ld.ub	r9,r8[0x0]
80003150:	39 68       	mov	r8,-106
80003152:	f0 09 18 00 	cp.b	r9,r8
80003156:	e0 88 00 05 	brls	80003160 <rtc_irq+0xd0>
8000315a:	30 09       	mov	r9,0
8000315c:	48 68       	lddpc	r8,80003174 <rtc_irq+0xe4>
8000315e:	b0 89       	st.b	r8[0x0],r9
	}
	
	//Time_scale++;

	// clear the interrupt flag
	rtc_clear_interrupt(&AVR32_RTC);
80003160:	fe 7c 0d 00 	mov	r12,-62208
80003164:	f0 1f 00 05 	mcall	80003178 <rtc_irq+0xe8>

	// specify that an interrupt has been raised
	print_sec = 1;
80003168:	30 19       	mov	r9,1
8000316a:	48 58       	lddpc	r8,8000317c <rtc_irq+0xec>
8000316c:	91 09       	st.w	r8[0x0],r9
}
8000316e:	d4 02       	popm	lr
80003170:	d6 03       	rete
80003172:	00 00       	add	r0,r0
80003174:	00 00       	add	r0,r0
80003176:	0e 08       	add	r8,r7
80003178:	80 00       	ld.sh	r0,r0[0x0]
8000317a:	5f f0       	sral	r0
8000317c:	00 00       	add	r0,r0
8000317e:	04 f4       	st.b	--r2,r4

80003180 <CalculateBurst>:
Calls:
Called By: phy_payload_rx
*/

volatile RxAMBEBurstType CalculateBurst(U8 vf_sn)
{
80003180:	20 1c       	sub	r12,1
80003182:	5c 5c       	castu.b	r12
80003184:	31 18       	mov	r8,17
80003186:	f0 0c 18 00 	cp.b	r12,r8
8000318a:	e0 88 00 03 	brls	80003190 <CalculateBurst+0x10>
8000318e:	5e fd       	retal	0
80003190:	48 28       	lddpc	r8,80003198 <CalculateBurst+0x18>
80003192:	f0 0c 03 2c 	ld.w	r12,r8[r12<<0x2]
			Burst_ID = 0x00;
			return VOICE_WATING;
		
	}
	
}
80003196:	5e fc       	retal	r12
80003198:	80 00       	ld.sh	r0,r0[0x0]
8000319a:	df 90       	acall	0xf9

8000319c <payload_init>:
Calls: xTaskCreate--freertos
Called By:app_init -- app.c
*/
void payload_init(void ( *payload_rx_func)(void * ), void ( *payload_tx_func)(void * ) )
{				
	payload_rx_exec = payload_rx_func;
8000319c:	48 38       	lddpc	r8,800031a8 <payload_init+0xc>
8000319e:	91 0c       	st.w	r8[0x0],r12
	payload_tx_exec = payload_tx_func;
800031a0:	48 38       	lddpc	r8,800031ac <payload_init+0x10>
800031a2:	91 0b       	st.w	r8[0x0],r11
	//,  2
	//,  NULL
	//);
	//
	
}
800031a4:	5e fc       	retal	r12
800031a6:	00 00       	add	r0,r0
800031a8:	00 00       	add	r0,r0
800031aa:	0a 74       	tst	r4,r5
800031ac:	00 00       	add	r0,r0
800031ae:	0a 78       	tst	r8,r5

800031b0 <set_idle_store_isr>:
{
	xQueueSend(store, &ptr, 0);
}

void set_idle_store_isr(xQueueHandle store, void * ptr)
{
800031b0:	d4 01       	pushm	lr
800031b2:	20 2d       	sub	sp,8
800031b4:	50 0b       	stdsp	sp[0x0],r11
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
800031b6:	30 09       	mov	r9,0
800031b8:	fa ca ff f8 	sub	r10,sp,-8
800031bc:	14 d9       	st.w	--r10,r9
	xQueueSendFromISR(store, &ptr, &xHigherPriorityTaskWoken);
800031be:	1a 9b       	mov	r11,sp
800031c0:	f0 1f 00 02 	mcall	800031c8 <set_idle_store_isr+0x18>
}
800031c4:	2f ed       	sub	sp,-8
800031c6:	d8 02       	popm	pc
800031c8:	80 00       	ld.sh	r0,r0[0x0]
800031ca:	6b d4       	ld.w	r4,r5[0x74]

800031cc <payload_rx>:
		//logFromISR("ss");
	}
}

static void payload_rx(void * payload)
{
800031cc:	d4 01       	pushm	lr
    set_payload_idle_isr(payload);
800031ce:	48 48       	lddpc	r8,800031dc <payload_rx+0x10>
800031d0:	70 08       	ld.w	r8,r8[0x0]
800031d2:	18 9b       	mov	r11,r12
800031d4:	10 9c       	mov	r12,r8
800031d6:	f0 1f 00 03 	mcall	800031e0 <payload_rx+0x14>
	else
	{
		//logFromISR("ss");
	}
	#endif
}
800031da:	d8 02       	popm	pc
800031dc:	00 00       	add	r0,r0
800031de:	0a b0       	st.h	r5++,r0
800031e0:	80 00       	ld.sh	r0,r0[0x0]
800031e2:	31 b0       	mov	r0,27

800031e4 <phy_rx>:
	xQueueSendFromISR -- freertos
Called By: phy_xnl_rx
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
800031e4:	d4 01       	pushm	lr
800031e6:	20 2d       	sub	sp,8
800031e8:	50 0c       	stdsp	sp[0x0],r12
	//memcpy(xx, phy_ptr, sizeof(phy_fragment_t));
	//set_phy_idle_isr(&phy_ptr, &xHigherPriorityTaskWoken);
	
	Bool res = FALSE;
	
	if(NULL == phy_ptr)
800031ea:	58 0c       	cp.w	r12,0
800031ec:	c1 10       	breq	8000320e <phy_rx+0x2a>
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
    /*variables are used to store the push result in interrupt*/
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
800031ee:	30 08       	mov	r8,0
800031f0:	50 18       	stdsp	sp[0x4],r8
	if(NULL == phy_ptr)
	{
		return;
	}
	
    U16 phy_ctrl = phy_ptr->xnl_fragment.phy_header.phy_control;
800031f2:	98 88       	ld.uh	r8,r12[0x0]
800031f4:	e2 18 f0 00 	andl	r8,0xf000,COH
800031f8:	e0 48 40 00 	cp.w	r8,16384
800031fc:	c0 91       	brne	8000320e <phy_rx+0x2a>

    if (XCMPXNL_DATA == (phy_ctrl & 0xF000))
    {
        /*push the xnl packet to queue*/
        if( pdTRUE == xQueueSendFromISR(
800031fe:	48 68       	lddpc	r8,80003214 <phy_rx+0x30>
80003200:	70 0c       	ld.w	r12,r8[0x0]
80003202:	30 09       	mov	r9,0
80003204:	fa ca ff fc 	sub	r10,sp,-4
80003208:	1a 9b       	mov	r11,sp
8000320a:	f0 1f 00 04 	mcall	80003218 <phy_rx+0x34>
		}	

    }
		
 
}
8000320e:	2f ed       	sub	sp,-8
80003210:	d8 02       	popm	pc
80003212:	00 00       	add	r0,r0
80003214:	00 00       	add	r0,r0
80003216:	0a bc       	st.h	r5++,r12
80003218:	80 00       	ld.sh	r0,r0[0x0]
8000321a:	6b d4       	ld.w	r4,r5[0x74]

8000321c <set_idle_store>:
	}
}


void set_idle_store(xQueueHandle store, void * ptr)
{
8000321c:	eb cd 40 80 	pushm	r7,lr
80003220:	20 1d       	sub	sp,4
80003222:	fa c7 ff fc 	sub	r7,sp,-4
80003226:	0e db       	st.w	--r7,r11
	xQueueSend(store, &ptr, 0);
80003228:	30 09       	mov	r9,0
8000322a:	12 9a       	mov	r10,r9
8000322c:	1a 9b       	mov	r11,sp
8000322e:	f0 1f 00 03 	mcall	80003238 <set_idle_store+0x1c>
}
80003232:	2f fd       	sub	sp,-4
80003234:	e3 cd 80 80 	ldm	sp++,r7,pc
80003238:	80 00       	ld.sh	r0,r0[0x0]
8000323a:	6c 24       	ld.w	r4,r6[0x8]

8000323c <phy_tx>:
Calls:   
	xQueueSend -- freertos
Called By: xnl_tx -- xnl.c
*/
void phy_tx(phy_fragment_t * phy)
{	
8000323c:	d4 01       	pushm	lr
8000323e:	20 1d       	sub	sp,4
80003240:	50 0c       	stdsp	sp[0x0],r12
	
	//phy_fragment_t * phy_ptr = malloc(sizeof(phy_fragment_t));
	//memcpy(phy_ptr, phy, sizeof(phy_fragment_t));
	//log("\n\r T_xcmp:%4x \n\r", phy->xnl_fragment.xnl_payload.xnl_content_data_msg.xcmp_opcode);
	//log("T_xnl-opcode:%4x", xnl->xnl_header.opcode);//log:R_xnl指令	
	if(XCMPXNL_DATA == (phy_ctrl & 0xF000))
80003242:	98 88       	ld.uh	r8,r12[0x0]
80003244:	e2 18 f0 00 	andl	r8,0xf000,COH
80003248:	e0 48 40 00 	cp.w	r8,16384
8000324c:	c0 d1       	brne	80003266 <phy_tx+0x2a>
	{
		/*push the xnl packet to queue to send */
		if(NULL != phy_xnl_frame_tx)
8000324e:	49 08       	lddpc	r8,8000328c <phy_tx+0x50>
80003250:	70 08       	ld.w	r8,r8[0x0]
80003252:	58 08       	cp.w	r8,0
80003254:	c1 a0       	breq	80003288 <phy_tx+0x4c>
		{
			if( pdTRUE == xQueueSend(phy_xnl_frame_tx, &phy, 0))
80003256:	48 e8       	lddpc	r8,8000328c <phy_tx+0x50>
80003258:	70 0c       	ld.w	r12,r8[0x0]
8000325a:	30 09       	mov	r9,0
8000325c:	12 9a       	mov	r10,r9
8000325e:	1a 9b       	mov	r11,sp
80003260:	f0 1f 00 0c 	mcall	80003290 <phy_tx+0x54>
80003264:	c1 28       	rjmp	80003288 <phy_tx+0x4c>
		}
	}
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE		
	else if((SPEAKER_DATA == (phy_ctrl & 0xF000))
80003266:	e0 48 10 00 	cp.w	r8,4096
8000326a:	5f 0a       	sreq	r10
8000326c:	e0 48 20 00 	cp.w	r8,8192
80003270:	5f 09       	sreq	r9
80003272:	f5 e9 10 09 	or	r9,r10,r9
80003276:	c0 71       	brne	80003284 <phy_tx+0x48>
80003278:	e0 48 50 00 	cp.w	r8,20480
8000327c:	c0 40       	breq	80003284 <phy_tx+0x48>
8000327e:	e0 48 60 00 	cp.w	r8,24576
80003282:	c0 31       	brne	80003288 <phy_tx+0x4c>
	    || (MIC_DATA  == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_RX == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_TX == (phy_ctrl & 0xF000))
	)
	{		
		if(NULL == phy_payload_frame_tx)
80003284:	48 48       	lddpc	r8,80003294 <phy_tx+0x58>
80003286:	70 08       	ld.w	r8,r8[0x0]
	
	if(res != TRUE)
	{
		//vPortFree(phy_ptr);
	}
}
80003288:	2f fd       	sub	sp,-4
8000328a:	d8 02       	popm	pc
8000328c:	00 00       	add	r0,r0
8000328e:	0a dc       	st.w	--r5,r12
80003290:	80 00       	ld.sh	r0,r0[0x0]
80003292:	6c 24       	ld.w	r4,r6[0x8]
80003294:	00 00       	add	r0,r0
80003296:	0a d0       	st.w	--r5,r0

80003298 <get_idle_store_isr>:
		return NULL;
	}
}

void * get_idle_store_isr(xQueueHandle store)
{
80003298:	d4 01       	pushm	lr
8000329a:	20 2d       	sub	sp,8
	void * ptr = NULL;
8000329c:	30 08       	mov	r8,0
8000329e:	50 18       	stdsp	sp[0x4],r8
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
800032a0:	50 08       	stdsp	sp[0x0],r8
	
	if(pdTRUE == xQueueReceiveFromISR(store, &ptr, &xHigherPriorityTaskWoken))
800032a2:	1a 9a       	mov	r10,sp
800032a4:	fa cb ff fc 	sub	r11,sp,-4
800032a8:	f0 1f 00 05 	mcall	800032bc <get_idle_store_isr+0x24>
800032ac:	58 1c       	cp.w	r12,1
800032ae:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
800032b2:	fb fc 00 01 	ld.weq	r12,sp[0x4]
	}
	else
	{
		return NULL;
	}
}
800032b6:	2f ed       	sub	sp,-8
800032b8:	d8 02       	popm	pc
800032ba:	00 00       	add	r0,r0
800032bc:	80 00       	ld.sh	r0,r0[0x0]
800032be:	69 28       	ld.w	r8,r4[0x48]

800032c0 <phy_tx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_tx_func( void * ssc)
{
800032c0:	eb cd 40 c0 	pushm	r6-r7,lr
800032c4:	20 1d       	sub	sp,4
800032c6:	18 97       	mov	r7,r12
    if(NULL != phy_xnl_frame_tx)
800032c8:	4b a8       	lddpc	r8,800033b0 <phy_tx_func+0xf0>
800032ca:	70 08       	ld.w	r8,r8[0x0]
800032cc:	58 08       	cp.w	r8,0
800032ce:	c6 60       	breq	8000339a <phy_tx_func+0xda>
    {
  	  	/*send ssc data in xnl frame*/
  	  	phy_xnl_tx(&(((ssc_fragment_t * )ssc)->xnl_channel));		
800032d0:	18 96       	mov	r6,r12
Called By:phy_tx_func
*/
static void phy_xnl_tx(xnl_channel_t * xnl_tx_channel)
{
	/*variables are used to store the push result in interrupt*/
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
800032d2:	30 08       	mov	r8,0
800032d4:	50 08       	stdsp	sp[0x0],r8
	
	static S16 phy_tx_expexted_length = 0;
	static U8 phy_tx_index = 0;
	
	/*his is the code for handling any outgoing XNL Phy message*/
	switch(phy_tx_state)
800032d6:	4b 88       	lddpc	r8,800033b4 <phy_tx_func+0xf4>
800032d8:	70 08       	ld.w	r8,r8[0x0]
800032da:	58 18       	cp.w	r8,1
800032dc:	c2 60       	breq	80003328 <phy_tx_func+0x68>
800032de:	c0 43       	brcs	800032e6 <phy_tx_func+0x26>
800032e0:	58 28       	cp.w	r8,2
800032e2:	c5 c1       	brne	8000339a <phy_tx_func+0xda>
800032e4:	c5 58       	rjmp	8000338e <phy_tx_func+0xce>
	{
		/*Waiting for the send xnl packet*/
		case WAITING_FOR_PHY_TX:			
			if( pdTRUE == xQueueReceiveFromISR(
800032e6:	4b 38       	lddpc	r8,800033b0 <phy_tx_func+0xf0>
800032e8:	70 0c       	ld.w	r12,r8[0x0]
800032ea:	1a 9a       	mov	r10,sp
800032ec:	4b 3b       	lddpc	r11,800033b8 <phy_tx_func+0xf8>
800032ee:	f0 1f 00 34 	mcall	800033bc <phy_tx_func+0xfc>
800032f2:	58 1c       	cp.w	r12,1
800032f4:	c1 41       	brne	8000331c <phy_tx_func+0x5c>
				  phy_xnl_frame_tx
				, &phy_ptr
				, &xHigherPriorityTaskWoken 
			))
			{								
				phy_tx_expexted_length = 
800032f6:	4b 18       	lddpc	r8,800033b8 <phy_tx_func+0xf8>
800032f8:	70 08       	ld.w	r8,r8[0x0]
800032fa:	90 08       	ld.sh	r8,r8[0x0]
800032fc:	10 9a       	mov	r10,r8
800032fe:	f5 da c0 08 	bfextu	r10,r10,0x0,0x8
80003302:	4b 09       	lddpc	r9,800033c0 <phy_tx_func+0x100>
80003304:	b2 0a       	st.h	r9[0x0],r10
				*/
				xnl_tx_channel->dword = 
				                   phy_ptr->xnl_fragment.phy_header.phy_control;
				
				/*Transmit 0xABCD0000 | Type/Length.*/
				xnl_tx_channel->dword |= PHYHEADER32;
80003306:	5c 78       	castu.h	r8
80003308:	ea 18 ab cd 	orh	r8,0xabcd
8000330c:	8f 18       	st.w	r7[0x4],r8
				
				phy_tx_index = 1;
8000330e:	30 19       	mov	r9,1
80003310:	4a d8       	lddpc	r8,800033c4 <phy_tx_func+0x104>
80003312:	b0 89       	st.b	r8[0x0],r9
				phy_tx_state = WRITE_NEXT_DWORD;	
80003314:	30 19       	mov	r9,1
80003316:	4a 88       	lddpc	r8,800033b4 <phy_tx_func+0xf4>
80003318:	91 09       	st.w	r8[0x0],r9
8000331a:	c4 08       	rjmp	8000339a <phy_tx_func+0xda>
				/*The new transmission has started.*/
			}
			else
			{
				/*Nothing new to transmit, send an idle frame*/
				xnl_tx_channel->dword = XNL_IDLE;
8000331c:	e0 68 5a 5a 	mov	r8,23130
80003320:	ea 18 ab cd 	orh	r8,0xabcd
80003324:	8f 18       	st.w	r7[0x4],r8
80003326:	c3 a8       	rjmp	8000339a <phy_tx_func+0xda>
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80003328:	4a 7a       	lddpc	r10,800033c4 <phy_tx_func+0x104>
8000332a:	15 88       	ld.ub	r8,r10[0x0]
				xnl_tx_channel->dword = XNL_IDLE;
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
8000332c:	4a 39       	lddpc	r9,800033b8 <phy_tx_func+0xf8>
8000332e:	72 09       	ld.w	r9,r9[0x0]
80003330:	f2 08 05 19 	ld.uh	r9,r9[r8<<0x1]
80003334:	b1 69       	lsl	r9,0x10
80003336:	99 19       	st.w	r12[0x4],r9
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80003338:	2f f8       	sub	r8,-1
8000333a:	5c 58       	castu.b	r8
8000333c:	b4 88       	st.b	r10[0x0],r8

			phy_tx_expexted_length -= 2;
8000333e:	4a 1b       	lddpc	r11,800033c0 <phy_tx_func+0x100>
80003340:	96 0c       	ld.sh	r12,r11[0x0]
80003342:	20 2c       	sub	r12,2
80003344:	5c 8c       	casts.h	r12
80003346:	f5 dc b0 10 	bfexts	r10,r12,0x0,0x10
8000334a:	b6 0a       	st.h	r11[0x0],r10
			
			/*have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
8000334c:	30 0b       	mov	r11,0
8000334e:	f6 0a 19 00 	cp.h	r10,r11
80003352:	e0 89 00 09 	brgt	80003364 <phy_tx_func+0xa4>
			{
				/*Must immediately send 0x00BA in Slot 4.*/
				xnl_tx_channel->dword |= PHYTERMRIGHT;
80003356:	e8 19 00 ba 	orl	r9,0xba
8000335a:	8f 19       	st.w	r7[0x4],r9
				
				/*Go back to waiting.*/
				phy_tx_state = WAITING_FOR_PHY_TX;
8000335c:	30 09       	mov	r9,0
8000335e:	49 68       	lddpc	r8,800033b4 <phy_tx_func+0xf4>
80003360:	91 09       	st.w	r8[0x0],r9
80003362:	c1 c8       	rjmp	8000339a <phy_tx_func+0xda>
				break;
			}

			/*Have not broken. Transmit 2nd hWord.*/
			xnl_tx_channel->dword |=  phy_ptr->fragment_element[phy_tx_index++];
80003364:	49 5a       	lddpc	r10,800033b8 <phy_tx_func+0xf8>
80003366:	74 0a       	ld.w	r10,r10[0x0]
80003368:	f4 08 05 1a 	ld.uh	r10,r10[r8<<0x1]
8000336c:	14 49       	or	r9,r10
8000336e:	8f 19       	st.w	r7[0x4],r9
80003370:	2f f8       	sub	r8,-1
80003372:	49 59       	lddpc	r9,800033c4 <phy_tx_func+0x104>
80003374:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
80003376:	20 2c       	sub	r12,2
80003378:	49 28       	lddpc	r8,800033c0 <phy_tx_func+0x100>
8000337a:	b0 0c       	st.h	r8[0x0],r12
			
			/*Have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
8000337c:	30 08       	mov	r8,0
8000337e:	f0 0c 19 00 	cp.h	r12,r8
80003382:	e0 89 00 0c 	brgt	8000339a <phy_tx_func+0xda>
			{
				/*Must send 0x00BA0000 next interrupt in Slot 3&4*/
				phy_tx_state = SEND_TAILED;
80003386:	30 29       	mov	r9,2
80003388:	48 b8       	lddpc	r8,800033b4 <phy_tx_func+0xf4>
8000338a:	91 09       	st.w	r8[0x0],r9
8000338c:	c0 78       	rjmp	8000339a <phy_tx_func+0xda>
			}
			break;

		case SEND_TAILED:
			/*send 0x00BA0000*/
			xnl_tx_channel->dword = PHYTERMLEFT;
8000338e:	fc 18 00 ba 	movh	r8,0xba
80003392:	99 18       	st.w	r12[0x4],r8
			
			/*Go back to waiting.*/		
			phy_tx_state = WAITING_FOR_PHY_TX;		
80003394:	30 09       	mov	r9,0
80003396:	48 88       	lddpc	r8,800033b4 <phy_tx_func+0xf4>
80003398:	91 09       	st.w	r8[0x0],r9
	//#else
	///*send idle frame*/	
	//((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
	//((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
	//#endif /*end if*/
	((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
8000339a:	e0 68 5a 5a 	mov	r8,23130
8000339e:	ea 18 ab cd 	orh	r8,0xabcd
800033a2:	8f 28       	st.w	r7[0x8],r8
	((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
800033a4:	30 08       	mov	r8,0
800033a6:	8f 38       	st.w	r7[0xc],r8
}
800033a8:	2f fd       	sub	sp,-4
800033aa:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800033ae:	00 00       	add	r0,r0
800033b0:	00 00       	add	r0,r0
800033b2:	0a dc       	st.w	--r5,r12
800033b4:	00 00       	add	r0,r0
800033b6:	0a 9c       	mov	r12,r5
800033b8:	00 00       	add	r0,r0
800033ba:	0a a8       	st.w	r5++,r8
800033bc:	80 00       	ld.sh	r0,r0[0x0]
800033be:	69 28       	ld.w	r8,r4[0x48]
800033c0:	00 00       	add	r0,r0
800033c2:	0a c4       	st.b	r5++,r4
800033c4:	00 00       	add	r0,r0
800033c6:	0a 7c       	tst	r12,r5

800033c8 <get_idle_store>:
	}//End of RxMedia Phy Handler.
}
#endif /*end if*/

void * get_idle_store(xQueueHandle store)
{
800033c8:	d4 01       	pushm	lr
800033ca:	20 1d       	sub	sp,4
	void * ptr = NULL;
800033cc:	30 0a       	mov	r10,0
800033ce:	fa cb ff fc 	sub	r11,sp,-4
800033d2:	16 da       	st.w	--r11,r10

	if(pdTRUE == xQueueReceive(store, &ptr, 0))
800033d4:	14 99       	mov	r9,r10
800033d6:	1a 9b       	mov	r11,sp
800033d8:	f0 1f 00 05 	mcall	800033ec <get_idle_store+0x24>
800033dc:	58 1c       	cp.w	r12,1
800033de:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
800033e2:	fb fc 00 00 	ld.weq	r12,sp[0x0]
	}
	else
	{
		return NULL;
	}
}
800033e6:	2f fd       	sub	sp,-4
800033e8:	d8 02       	popm	pc
800033ea:	00 00       	add	r0,r0
800033ec:	80 00       	ld.sh	r0,r0[0x0]
800033ee:	6a 18       	ld.w	r8,r5[0x4]

800033f0 <phy_init>:
    register_rx_tx_func -- ssc.c
	xQueueCreate -- freertos
Called By: xnl_init -- xnl.c
*/
void phy_init( void )
{
800033f0:	d4 01       	pushm	lr
    /*register the func to send/receive ssc packet*/
    register_rx_tx_func(phy_rx_func, phy_tx_func);	
800033f2:	48 5b       	lddpc	r11,80003404 <phy_init+0x14>
800033f4:	48 5c       	lddpc	r12,80003408 <phy_init+0x18>
800033f6:	f0 1f 00 06 	mcall	8000340c <phy_init+0x1c>
	
	/*initialize the SSC*/
	ssc_init();
800033fa:	f0 1f 00 06 	mcall	80003410 <phy_init+0x20>
	
	/*send device_master_query to connect radio*/
	xnl_send_device_master_query();
800033fe:	f0 1f 00 06 	mcall	80003414 <phy_init+0x24>
	
}
80003402:	d8 02       	popm	pc
80003404:	80 00       	ld.sh	r0,r0[0x0]
80003406:	32 c0       	mov	r0,44
80003408:	80 00       	ld.sh	r0,r0[0x0]
8000340a:	34 18       	mov	r8,65
8000340c:	80 00       	ld.sh	r0,r0[0x0]
8000340e:	44 78       	lddsp	r8,sp[0x11c]
80003410:	80 00       	ld.sh	r0,r0[0x0]
80003412:	44 8c       	lddsp	r12,sp[0x120]
80003414:	80 00       	ld.sh	r0,r0[0x0]
80003416:	4e 38       	lddpc	r8,800035a0 <phy_rx_func+0x188>

80003418 <phy_rx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_rx_func( void * ssc)
{    
80003418:	eb cd 40 e0 	pushm	r5-r7,lr
8000341c:	18 97       	mov	r7,r12
		
	if(NULL != phy_xnl_frame_rx)
8000341e:	fe f8 0e 7a 	ld.w	r8,pc[3706]
80003422:	70 08       	ld.w	r8,r8[0x0]
80003424:	58 08       	cp.w	r8,0
80003426:	e0 80 01 08 	breq	80003636 <phy_rx_func+0x21e>
	static U16 phy_check_sum = 0;

	static phy_rx_state_t  phy_rx_state = WAITING_FOR_HEADER;
	static U32 phy_rx_count = 0;

	U32 phy_dword = xnl_rx_channel->dword;	
8000342a:	78 16       	ld.w	r6,r12[0x4]

	phy_rx_count++;
8000342c:	fe f8 0e 70 	ld.w	r8,pc[3696]
80003430:	70 09       	ld.w	r9,r8[0x0]
80003432:	2f f9       	sub	r9,-1
80003434:	91 09       	st.w	r8[0x0],r9
	
	/*This is the code for parsing the incoming physical message.*/
	switch (phy_rx_state)
80003436:	fe f8 0e 6a 	ld.w	r8,pc[3690]
8000343a:	70 08       	ld.w	r8,r8[0x0]
8000343c:	58 18       	cp.w	r8,1
8000343e:	e0 80 00 85 	breq	80003548 <phy_rx_func+0x130>
80003442:	c0 73       	brcs	80003450 <phy_rx_func+0x38>
80003444:	58 28       	cp.w	r8,2
80003446:	c5 c0       	breq	800034fe <phy_rx_func+0xe6>
80003448:	58 38       	cp.w	r8,3
8000344a:	e0 81 00 f6 	brne	80003636 <phy_rx_func+0x21e>
8000344e:	cd 58       	rjmp	800035f8 <phy_rx_func+0x1e0>

        /*Waiting for something. Most frequent visit.*/		
		case WAITING_FOR_HEADER:
		
			/*Ignore Idles.*/
			if (0xABCD5A5A == phy_dword)
80003450:	e0 6a 5a 5a 	mov	r10,23130
80003454:	ea 1a ab cd 	orh	r10,0xabcd
80003458:	14 36       	cp.w	r6,r10
8000345a:	e0 80 00 ee 	breq	80003636 <phy_rx_func+0x21e>
			{
				break;
			}	

			/*Skip until Header.*/		
			if (0xABCD != (phy_dword >> 16))
8000345e:	ec 08 16 10 	lsr	r8,r6,0x10
80003462:	e0 48 ab cd 	cp.w	r8,43981
80003466:	e0 81 00 e8 	brne	80003636 <phy_rx_func+0x21e>
			{			
				break;
			}
		
			/*Length excluding CSUM.*/
			phy_rx_expexted_length = (phy_dword & 0x000000FF) - 2;
8000346a:	eb d6 b0 10 	bfexts	r5,r6,0x0,0x10
8000346e:	f1 d5 c0 08 	bfextu	r8,r5,0x0,0x8
80003472:	20 28       	sub	r8,2
80003474:	fe f9 0e 30 	ld.w	r9,pc[3632]
80003478:	b2 08       	st.h	r9[0x0],r8
			
			/*Discard degenerate message.*/
			if (phy_rx_expexted_length <= 0)
8000347a:	30 09       	mov	r9,0
8000347c:	f2 08 19 00 	cp.h	r8,r9
80003480:	e0 8a 00 db 	brle	80003636 <phy_rx_func+0x21e>
			{
				break;
			}
		
			phy_rx_length = 0;
80003484:	fe f8 0e 24 	ld.w	r8,pc[3620]
80003488:	b0 09       	st.h	r8[0x0],r9

			phy_frame_ptr = get_xnl_idle_isr();
8000348a:	fe f8 0e 22 	ld.w	r8,pc[3618]
8000348e:	70 0c       	ld.w	r12,r8[0x0]
80003490:	f0 1f 03 88 	mcall	800042b0 <phy_rx_func+0xe98>
80003494:	fe f8 0e 20 	ld.w	r8,pc[3616]
80003498:	91 0c       	st.w	r8[0x0],r12
			if(NULL == phy_frame_ptr)
8000349a:	58 0c       	cp.w	r12,0
8000349c:	e0 80 00 cd 	breq	80003636 <phy_rx_func+0x21e>
			{
				break;
			}
					
			phy_frame_ptr->fragment_element[phy_rx_length++] = phy_dword;
800034a0:	fe f8 0e 08 	ld.w	r8,pc[3592]
800034a4:	90 09       	ld.sh	r9,r8[0x0]
800034a6:	f8 09 0a 15 	st.h	r12[r9<<0x1],r5
800034aa:	2f f9       	sub	r9,-1
800034ac:	5c 89       	casts.h	r9
			
			/*time stamp*/
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
800034ae:	fe fa 0e 06 	ld.w	r10,pc[3590]
800034b2:	74 0a       	ld.w	r10,r10[0x0]
800034b4:	fe fb 0d e8 	ld.w	r11,pc[3560]
800034b8:	76 0b       	ld.w	r11,r11[0x0]
800034ba:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
800034be:	2f f9       	sub	r9,-1
800034c0:	b0 09       	st.h	r8[0x0],r9
													(phy_rx_count) & 0x0000FFFF;
			
			/*This switch tests the fragment type, and adjusts receiver state
			accordingly.*/
			/*Check frag type*/
			switch (phy_dword & 0x00000F00)
800034c2:	e2 16 0f 00 	andl	r6,0xf00,COH
800034c6:	e0 46 01 00 	cp.w	r6,256
800034ca:	c0 c0       	breq	800034e2 <phy_rx_func+0xca>
800034cc:	e0 8b 00 05 	brhi	800034d6 <phy_rx_func+0xbe>
800034d0:	58 06       	cp.w	r6,0
800034d2:	c0 80       	breq	800034e2 <phy_rx_func+0xca>
800034d4:	c0 c8       	rjmp	800034ec <phy_rx_func+0xd4>
800034d6:	e0 46 02 00 	cp.w	r6,512
800034da:	c0 40       	breq	800034e2 <phy_rx_func+0xca>
800034dc:	e0 46 03 00 	cp.w	r6,768
800034e0:	c0 61       	brne	800034ec <phy_rx_func+0xd4>
			{
				case SINGLE_FRAGMENT:  //Only Fragment.
				case FIRST_FRAGMENT:   //First of Multi-fragment.
				case MIDDLE_FRAGMENT:  //Continuing Multi-fragment.
				case LAST_FRAGMENT:    //Last Multi-fragment.
					phy_rx_state = WAITING_CHECK_SUM;
800034e2:	30 29       	mov	r9,2
800034e4:	fe f8 0d bc 	ld.w	r8,pc[3516]
800034e8:	91 09       	st.w	r8[0x0],r9
800034ea:	ca 68       	rjmp	80003636 <phy_rx_func+0x21e>
				break;
				default:
					set_xnl_idle_isr(phy_frame_ptr);			
800034ec:	fe f8 0d c0 	ld.w	r8,pc[3520]
800034f0:	70 0c       	ld.w	r12,r8[0x0]
800034f2:	fe f8 0d c2 	ld.w	r8,pc[3522]
800034f6:	70 0b       	ld.w	r11,r8[0x0]
800034f8:	f0 1f 03 70 	mcall	800042b8 <phy_rx_func+0xea0>
800034fc:	c9 d8       	rjmp	80003636 <phy_rx_func+0x21e>
		
			/*Stores CSUM*/
			phy_check_sum  = (phy_dword & 0xFFFF0000) >> 16;
			
			/*sums in first hWord*/
			phy_check_sum += (phy_dword & 0x0000FFFF);		
800034fe:	f5 d6 b0 10 	bfexts	r10,r6,0x0,0x10
80003502:	b1 86       	lsr	r6,0x10
80003504:	14 06       	add	r6,r10
80003506:	fe f8 0d b6 	ld.w	r8,pc[3510]
8000350a:	b0 06       	st.h	r8[0x0],r6
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
8000350c:	fe f8 0d 9c 	ld.w	r8,pc[3484]
80003510:	90 09       	ld.sh	r9,r8[0x0]
80003512:	fe fb 0d a2 	ld.w	r11,pc[3490]
80003516:	76 0b       	ld.w	r11,r11[0x0]
80003518:	f6 09 0a 1a 	st.h	r11[r9<<0x1],r10
8000351c:	2f f9       	sub	r9,-1
8000351e:	b0 09       	st.h	r8[0x0],r9
														 phy_dword & 0x0000FFFF;
					
			phy_rx_expexted_length -= 2;
80003520:	fe f9 0d 84 	ld.w	r9,pc[3460]
80003524:	92 08       	ld.sh	r8,r9[0x0]
80003526:	20 28       	sub	r8,2
80003528:	b2 08       	st.h	r9[0x0],r8
			
			/*Normal case for greater than one byte payloads.*/
			if (phy_rx_expexted_length > 0)
8000352a:	30 09       	mov	r9,0
8000352c:	f2 08 19 00 	cp.h	r8,r9
80003530:	e0 8a 00 07 	brle	8000353e <phy_rx_func+0x126>
			{					  
				phy_rx_state = READING_FRAGMENT;
80003534:	30 19       	mov	r9,1
80003536:	fe f8 0d 6a 	ld.w	r8,pc[3434]
8000353a:	91 09       	st.w	r8[0x0],r9
8000353c:	c7 d8       	rjmp	80003636 <phy_rx_func+0x21e>
	    		Note that all segments must align with a 32-bit boundary and
				beginning of each XCMP/XNL payload frame must start on slot 3
				Thus, segments of odd length must append a 0x0000 at the end
				(slot 4) to ensure alignment. [9.1.3]
				*/
				phy_rx_state = WAITING_LAST_TERM;
8000353e:	30 39       	mov	r9,3
80003540:	fe f8 0d 60 	ld.w	r8,pc[3424]
80003544:	91 09       	st.w	r8[0x0],r9
80003546:	c7 88       	rjmp	80003636 <phy_rx_func+0x21e>
			}			
		
			break;

		case READING_FRAGMENT:
			phy_check_sum += (phy_dword & 0xFFFF0000) >> 16;
80003548:	ec 0a 14 10 	asr	r10,r6,0x10
8000354c:	fe f8 0d 70 	ld.w	r8,pc[3440]
80003550:	90 09       	ld.sh	r9,r8[0x0]
80003552:	14 09       	add	r9,r10
80003554:	b0 09       	st.h	r8[0x0],r9
	
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
80003556:	fe f9 0d 52 	ld.w	r9,pc[3410]
8000355a:	92 08       	ld.sh	r8,r9[0x0]
8000355c:	fe fb 0d 58 	ld.w	r11,pc[3416]
80003560:	76 0b       	ld.w	r11,r11[0x0]
80003562:	f6 08 0a 1a 	st.h	r11[r8<<0x1],r10
80003566:	2f f8       	sub	r8,-1
80003568:	5c 88       	casts.h	r8
8000356a:	b2 08       	st.h	r9[0x0],r8
												 (phy_dword & 0xFFFF0000) >> 16;
	
			phy_rx_expexted_length -= 2;
8000356c:	fe fa 0d 38 	ld.w	r10,pc[3384]
80003570:	94 09       	ld.sh	r9,r10[0x0]
80003572:	20 29       	sub	r9,2
80003574:	b4 09       	st.h	r10[0x0],r9
			if (phy_rx_expexted_length <= 0)
80003576:	30 0a       	mov	r10,0
80003578:	f4 09 19 00 	cp.h	r9,r10
8000357c:	e0 89 00 20 	brgt	800035bc <phy_rx_func+0x1a4>
				Terminator should be in 2nd hWord.
				Shaoqun says useful bits not used. The packet will always end
				with $00BA. [9.1.2.8]	
				*/
				
				if ((0x000000BA == (phy_dword  & 0x0000FFFF)) 
80003580:	ed d6 c0 10 	bfextu	r6,r6,0x0,0x10
80003584:	e0 46 00 ba 	cp.w	r6,186
80003588:	c0 d1       	brne	800035a2 <phy_rx_func+0x18a>
8000358a:	fe f8 0d 32 	ld.w	r8,pc[3378]
8000358e:	90 09       	ld.sh	r9,r8[0x0]
80003590:	f4 09 19 00 	cp.h	r9,r10
80003594:	c0 71       	brne	800035a2 <phy_rx_func+0x18a>
					&& (phy_check_sum == 0))
				{
					phy_rx(phy_frame_ptr);
80003596:	fe f8 0d 1e 	ld.w	r8,pc[3358]
8000359a:	70 0c       	ld.w	r12,r8[0x0]
8000359c:	f0 1f 03 49 	mcall	800042c0 <phy_rx_func+0xea8>
800035a0:	c0 98       	rjmp	800035b2 <phy_rx_func+0x19a>
				}
				else
				{
					set_xnl_idle_isr(phy_frame_ptr);
800035a2:	fe f8 0d 0a 	ld.w	r8,pc[3338]
800035a6:	70 0c       	ld.w	r12,r8[0x0]
800035a8:	fe f8 0d 0c 	ld.w	r8,pc[3340]
800035ac:	70 0b       	ld.w	r11,r8[0x0]
800035ae:	f0 1f 03 43 	mcall	800042b8 <phy_rx_func+0xea0>
				}

				phy_rx_state = WAITING_FOR_HEADER;
800035b2:	30 09       	mov	r9,0
800035b4:	fe f8 0c ec 	ld.w	r8,pc[3308]
800035b8:	91 09       	st.w	r8[0x0],r9
800035ba:	c3 e8       	rjmp	80003636 <phy_rx_func+0x21e>
				break;
			}
		
			/*Have not broken. 2nd hWord contains payload.*/
			phy_check_sum += (phy_dword & 0x0000FFFF);
800035bc:	5c 86       	casts.h	r6
800035be:	fe f9 0c fe 	ld.w	r9,pc[3326]
800035c2:	92 0a       	ld.sh	r10,r9[0x0]
800035c4:	0c 0a       	add	r10,r6
800035c6:	b2 0a       	st.h	r9[0x0],r10
		
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
800035c8:	fe f9 0c ec 	ld.w	r9,pc[3308]
800035cc:	72 09       	ld.w	r9,r9[0x0]
800035ce:	f2 08 0a 16 	st.h	r9[r8<<0x1],r6
800035d2:	2f f8       	sub	r8,-1
800035d4:	fe f9 0c d4 	ld.w	r9,pc[3284]
800035d8:	b2 08       	st.h	r9[0x0],r8
													   (phy_dword & 0x0000FFFF);
		
			phy_rx_expexted_length -= 2;
800035da:	fe f9 0c ca 	ld.w	r9,pc[3274]
800035de:	92 08       	ld.sh	r8,r9[0x0]
800035e0:	20 28       	sub	r8,2
800035e2:	b2 08       	st.h	r9[0x0],r8
			if (phy_rx_expexted_length <= 0)
800035e4:	30 09       	mov	r9,0
800035e6:	f2 08 19 00 	cp.h	r8,r9
800035ea:	e0 89 00 26 	brgt	80003636 <phy_rx_func+0x21e>
			{
				/*All read in. Next Word should be 0x00BA0000.*/
				phy_rx_state = WAITING_LAST_TERM;
800035ee:	30 39       	mov	r9,3
800035f0:	fe f8 0c b0 	ld.w	r8,pc[3248]
800035f4:	91 09       	st.w	r8[0x0],r9
800035f6:	c2 08       	rjmp	80003636 <phy_rx_func+0x21e>
			}/*else, next Word contains more payload.*/
			break;

		/*Expecting last terminator 0x00BA0000.*/	
		case WAITING_LAST_TERM:			
			if ((0x00BA0000 == (phy_dword  & 0x00FF0000)) /*Expected found.*/
800035f8:	e6 16 00 ff 	andh	r6,0xff,COH
800035fc:	fc 19 00 ba 	movh	r9,0xba
80003600:	12 36       	cp.w	r6,r9
80003602:	c0 e1       	brne	8000361e <phy_rx_func+0x206>
80003604:	fe f8 0c b8 	ld.w	r8,pc[3256]
80003608:	90 09       	ld.sh	r9,r8[0x0]
8000360a:	30 08       	mov	r8,0
8000360c:	f0 09 19 00 	cp.h	r9,r8
80003610:	c0 71       	brne	8000361e <phy_rx_func+0x206>
				&& (phy_check_sum == 0))/*Good checksum*/
			{
				phy_rx(phy_frame_ptr);
80003612:	fe f8 0c a2 	ld.w	r8,pc[3234]
80003616:	70 0c       	ld.w	r12,r8[0x0]
80003618:	f0 1f 03 2a 	mcall	800042c0 <phy_rx_func+0xea8>
8000361c:	c0 98       	rjmp	8000362e <phy_rx_func+0x216>

			}
			else
			{
				set_xnl_idle_isr(phy_frame_ptr);
8000361e:	fe f8 0c 8e 	ld.w	r8,pc[3214]
80003622:	70 0c       	ld.w	r12,r8[0x0]
80003624:	fe f8 0c 90 	ld.w	r8,pc[3216]
80003628:	70 0b       	ld.w	r11,r8[0x0]
8000362a:	f0 1f 03 24 	mcall	800042b8 <phy_rx_func+0xea0>
			}
				
			phy_rx_state = WAITING_FOR_HEADER;
8000362e:	30 09       	mov	r9,0
80003630:	fe f8 0c 70 	ld.w	r8,pc[3184]
80003634:	91 09       	st.w	r8[0x0],r9
	static U8 _flag = 1;//0xABCDC014时，_flag为0；
						//0xABCDC010时，_flag为1；
			
	//payload_ptr_t *AMBE_payload_ptr;		
	
	if(is_first == FALSE)
80003636:	fe f8 0c 8e 	ld.w	r8,pc[3214]
8000363a:	11 89       	ld.ub	r9,r8[0x0]
8000363c:	30 08       	mov	r8,0
8000363e:	f0 09 18 00 	cp.b	r9,r8
80003642:	c1 31       	brne	80003668 <phy_rx_func+0x250>
	{
		payload_ptr = get_payload_idle_isr();
80003644:	fe f6 0c 84 	ld.w	r6,pc[3204]
80003648:	6c 0c       	ld.w	r12,r6[0x0]
8000364a:	f0 1f 03 1a 	mcall	800042b0 <phy_rx_func+0xe98>
8000364e:	fe f8 0c 7e 	ld.w	r8,pc[3198]
80003652:	91 0c       	st.w	r8[0x0],r12
		AMBE_payload_ptr = get_payload_idle_isr();
80003654:	6c 0c       	ld.w	r12,r6[0x0]
80003656:	f0 1f 03 17 	mcall	800042b0 <phy_rx_func+0xe98>
8000365a:	fe f8 0c 76 	ld.w	r8,pc[3190]
8000365e:	91 0c       	st.w	r8[0x0],r12
		is_first = TRUE;
80003660:	30 19       	mov	r9,1
80003662:	fe f8 0c 62 	ld.w	r8,pc[3170]
80003666:	b0 89       	st.b	r8[0x0],r9
	}	
	
	//This is the RxMedia Phy Handler.
	switch (RxMediaState)
80003668:	fe f8 0c 6c 	ld.w	r8,pc[3180]
8000366c:	70 08       	ld.w	r8,r8[0x0]
8000366e:	58 28       	cp.w	r8,2
80003670:	e0 80 01 98 	breq	800039a0 <phy_rx_func+0x588>
80003674:	e0 8b 00 06 	brhi	80003680 <phy_rx_func+0x268>
80003678:	58 08       	cp.w	r8,0
8000367a:	c0 b0       	breq	80003690 <phy_rx_func+0x278>
8000367c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80003680:	58 38       	cp.w	r8,3
80003682:	e0 80 05 c5 	breq	8000420c <phy_rx_func+0xdf4>
80003686:	58 48       	cp.w	r8,4
80003688:	e0 81 06 05 	brne	80004292 <phy_rx_func+0xe7a>
8000368c:	e0 8f 02 4b 	bral	80003b22 <phy_rx_func+0x70a>
	{
		case WAITINGABAB:

			
			if (payload_rx_channel->dword[0] == 0xABCD5A5A)//Ignore Idles.
80003690:	6e 28       	ld.w	r8,r7[0x8]
80003692:	e0 6a 5a 5a 	mov	r10,23130
80003696:	ea 1a ab cd 	orh	r10,0xabcd
8000369a:	14 38       	cp.w	r8,r10
8000369c:	c0 71       	brne	800036aa <phy_rx_func+0x292>
			{
				m_RxBurstType = VOICE_WATING;
8000369e:	30 09       	mov	r9,0
800036a0:	fe f8 0c 38 	ld.w	r8,pc[3128]
800036a4:	91 09       	st.w	r8[0x0],r9
800036a6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
				//Upon receiving the idle frame, the m Rx Burst Type into an idle state in order to transmit the synchronization wait
				 break; 
			}
            
			if ((payload_rx_channel->dword[0]  & 0xFFFF0000) != 0xABCD0000)break; //Skip until Header. 
800036aa:	10 99       	mov	r9,r8
800036ac:	e0 19 00 00 	andl	r9,0x0
800036b0:	fc 1a ab cd 	movh	r10,0xabcd
800036b4:	14 39       	cp.w	r9,r10
800036b6:	e0 81 05 ee 	brne	80004292 <phy_rx_func+0xe7a>
			}
			//logFromISR("\n\r P: %X \n\r", payload_rx_channel->word[1]);//测试收到的数据
			
#endif
			
			RxBytesWaiting = payload_rx_channel->dword[0] & 0x000000FF;
800036ba:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
800036be:	fe f9 0c 1e 	ld.w	r9,pc[3102]
800036c2:	93 08       	st.w	r9[0x0],r8
			/****Note AMBE stream protocol frame structure and the PCM frame structure is different*****/
					
			if ((payload_rx_channel->dword[0] & 0x0000F000 ) == PAYLOAD_DATA_ENH )//PAYLOAD_DATA_ENH (0x0c))
800036c4:	6e 29       	ld.w	r9,r7[0x8]
800036c6:	e2 19 f0 00 	andl	r9,0xf000,COH
800036ca:	e0 49 c0 00 	cp.w	r9,49152
800036ce:	e0 81 00 ce 	brne	8000386a <phy_rx_func+0x452>
			{
				AMBE_Media = 1;	
800036d2:	30 1a       	mov	r10,1
800036d4:	fe f9 0c 0c 	ld.w	r9,pc[3084]
800036d8:	b2 8a       	st.b	r9[0x0],r10
				
				if (NULL== AMBE_payload_ptr){
800036da:	fe f9 0b f6 	ld.w	r9,pc[3062]
800036de:	72 09       	ld.w	r9,r9[0x0]
800036e0:	58 09       	cp.w	r9,0
800036e2:	c0 71       	brne	800036f0 <phy_rx_func+0x2d8>
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//测试是否有这种情况出现
800036e4:	fe fc 0c 00 	ld.w	r12,pc[3072]
800036e8:	f0 1f 03 00 	mcall	800042e8 <phy_rx_func+0xed0>
800036ec:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
																	
				Item_ID = payload_rx_channel->byte[5];
800036f0:	ef 3a 00 0d 	ld.ub	r10,r7[13]
800036f4:	fe f9 0b f8 	ld.w	r9,pc[3064]
800036f8:	b2 8a       	st.b	r9[0x0],r10
				
				Item_Length = (payload_rx_channel->byte[4] & 0x7F);//7bits
800036fa:	ef 3b 00 0c 	ld.ub	r11,r7[12]
800036fe:	f7 db c0 07 	bfextu	r11,r11,0x0,0x7
80003702:	fe fa 0b ee 	ld.w	r10,pc[3054]
80003706:	95 0b       	st.w	r10[0x0],r11
								
				switch(Item_ID)
80003708:	13 89       	ld.ub	r9,r9[0x0]
8000370a:	37 fa       	mov	r10,127
8000370c:	f4 09 18 00 	cp.b	r9,r10
80003710:	c6 d0       	breq	800037ea <phy_rx_func+0x3d2>
80003712:	e0 8b 00 0c 	brhi	8000372a <phy_rx_func+0x312>
80003716:	31 2a       	mov	r10,18
80003718:	f4 09 18 00 	cp.b	r9,r10
8000371c:	c4 20       	breq	800037a0 <phy_rx_func+0x388>
8000371e:	31 3a       	mov	r10,19
80003720:	f4 09 18 00 	cp.b	r9,r10
80003724:	e0 81 00 83 	brne	8000382a <phy_rx_func+0x412>
80003728:	c5 b8       	rjmp	800037de <phy_rx_func+0x3c6>
8000372a:	2f 09       	sub	r9,-16
8000372c:	30 1a       	mov	r10,1
8000372e:	f4 09 18 00 	cp.b	r9,r10
80003732:	e0 8b 00 7c 	brhi	8000382a <phy_rx_func+0x412>
					//The OB know the Call begin and discard the Voice Header
					//The OB know the Call end and discard the Voice  Terminator
					case Raw_Tx_Data_HT://0xF0
					case Raw_Rx_Data_HT://0xF1
					
							if ((payload_rx_channel->byte[6] & 0xF0 )== 0x10)//header
80003736:	ef 38 00 0e 	ld.ub	r8,r7[14]
8000373a:	e2 18 00 f0 	andl	r8,0xf0,COH
8000373e:	59 08       	cp.w	r8,16
80003740:	c0 71       	brne	8000374e <phy_rx_func+0x336>
							{
								m_RxBurstType = VOICEHEADER;
80003742:	30 19       	mov	r9,1
80003744:	fe f8 0b 94 	ld.w	r8,pc[2964]
80003748:	91 09       	st.w	r8[0x0],r9
8000374a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

							}
							else if ((payload_rx_channel->byte[6] & 0xF0) == 0x20)//Terminator
8000374e:	e0 48 00 20 	cp.w	r8,32
80003752:	c2 11       	brne	80003794 <phy_rx_func+0x37c>
							{
								m_RxBurstType = VOICETERMINATOR;
80003754:	30 a9       	mov	r9,10
80003756:	fe f8 0b 82 	ld.w	r8,pc[2946]
8000375a:	91 09       	st.w	r8[0x0],r9
								//AMBE-data and PCM-data is not the same. AMBE is compressed data,
								//if there was a missing portion, a clear voice is difficult to extract the data.
								//It must ensure that all the data received AMBE.
								
								//注意！！！考虑是否需要把剩余的空间置0。
								memset((AMBE_payload_ptr+ (RxAMBE_IsFillingNext8 +1)), 0x00, (512-(RxAMBE_IsFillingNext8 + 1)));
8000375c:	fe f6 0b 98 	ld.w	r6,pc[2968]
80003760:	6c 08       	ld.w	r8,r6[0x0]
80003762:	f0 0a 11 ff 	rsub	r10,r8,-1
80003766:	fe f7 0b 6a 	ld.w	r7,pc[2922]
8000376a:	2f f8       	sub	r8,-1
8000376c:	6e 0c       	ld.w	r12,r7[0x0]
8000376e:	f4 ca fe 00 	sub	r10,r10,-512
80003772:	30 0b       	mov	r11,0
80003774:	10 0c       	add	r12,r8
80003776:	f0 1f 02 e1 	mcall	800042f8 <phy_rx_func+0xee0>
								
								RxAMBE_IsFillingNext8 = 0;
8000377a:	30 08       	mov	r8,0
8000377c:	8d 08       	st.w	r6[0x0],r8
								payload_rx(AMBE_payload_ptr);
8000377e:	6e 0c       	ld.w	r12,r7[0x0]
80003780:	f0 1f 02 df 	mcall	800042fc <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003784:	fe f8 0b 44 	ld.w	r8,pc[2884]
80003788:	70 0c       	ld.w	r12,r8[0x0]
8000378a:	f0 1f 02 ca 	mcall	800042b0 <phy_rx_func+0xe98>
8000378e:	8f 0c       	st.w	r7[0x0],r12
80003790:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								//logFromISR("\n\r QQ1 \n\r");
								
							}
							else//error voice
							{
								m_RxBurstType = VOICE_WATING;
80003794:	30 09       	mov	r9,0
80003796:	fe f8 0b 42 	ld.w	r8,pc[2882]
8000379a:	91 09       	st.w	r8[0x0],r9
8000379c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;//WAITINGABAB.
					
		
					case Vocoder_Bit_Stream_Parameter://0x12
							
							if ((RxBytesWaiting -= 4) <= 0) break;
800037a0:	20 48       	sub	r8,4
800037a2:	fe f9 0b 3a 	ld.w	r9,pc[2874]
800037a6:	93 08       	st.w	r9[0x0],r8
800037a8:	58 08       	cp.w	r8,0
800037aa:	e0 80 05 74 	breq	80004292 <phy_rx_func+0xe7a>
					
							//Vocoder Bits Stream Parameter
							VF_SN = (payload_rx_channel->byte[7] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
800037ae:	ef 3c 00 0f 	ld.ub	r12,r7[15]
800037b2:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
800037b6:	fe f8 0b 4a 	ld.w	r8,pc[2890]
800037ba:	b0 8c       	st.b	r8[0x0],r12
							
							VBSP_data[0] = payload_rx_channel->word[2];
800037bc:	8e 69       	ld.sh	r9,r7[0xc]
800037be:	fe f8 0b 46 	ld.w	r8,pc[2886]
800037c2:	b0 09       	st.h	r8[0x0],r9
							VBSP_data[1] = payload_rx_channel->word[3];
800037c4:	8e 79       	ld.sh	r9,r7[0xe]
800037c6:	b0 19       	st.h	r8[0x2],r9
							
							m_RxBurstType = CalculateBurst(VF_SN);
800037c8:	f0 1f 02 d0 	mcall	80004308 <phy_rx_func+0xef0>
800037cc:	fe f8 0b 0c 	ld.w	r8,pc[2828]
800037d0:	91 0c       	st.w	r8[0x0],r12
							
							RxMediaState = READING_AMBE_MEDIA;//Jump
800037d2:	30 49       	mov	r9,4
800037d4:	fe f8 0b 00 	ld.w	r8,pc[2816]
800037d8:	91 09       	st.w	r8[0x0],r9
800037da:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							
					//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
					// or discard it to reduce payload size.	
					//This shouldn't happen, but must check.	
					case Soft_Decision_Value://0x13
						m_RxBurstType = VOICE_WATING;
800037de:	30 09       	mov	r9,0
800037e0:	fe f8 0a f8 	ld.w	r8,pc[2808]
800037e4:	91 09       	st.w	r8[0x0],r9
800037e6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
					case Radio_Internal_Parameter://0x7F
							
							//logFromISR("\n\r Item_Length:%d\n\r", Item_Length);
							
							if ((RxBytesWaiting -= 4) <= 0) break;
800037ea:	20 48       	sub	r8,4
800037ec:	fe f9 0a f0 	ld.w	r9,pc[2800]
800037f0:	93 08       	st.w	r9[0x0],r8
800037f2:	58 08       	cp.w	r8,0
800037f4:	e0 80 05 4f 	breq	80004292 <phy_rx_func+0xe7a>
							//Radio Internal Parameter
							Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[3];
800037f8:	fe f8 0b 14 	ld.w	r8,pc[2836]
800037fc:	70 09       	ld.w	r9,r8[0x0]
800037fe:	8e 7b       	ld.sh	r11,r7[0xe]
80003800:	fe fa 0b 10 	ld.w	r10,pc[2832]
80003804:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
							RxData_IsFillingNext16 += 1; 
80003808:	2f f9       	sub	r9,-1
8000380a:	91 09       	st.w	r8[0x0],r9
							Item_Length -= 2 ;
8000380c:	fe f8 0a e4 	ld.w	r8,pc[2788]
80003810:	70 09       	ld.w	r9,r8[0x0]
80003812:	20 29       	sub	r9,2
80003814:	91 09       	st.w	r8[0x0],r9
							//....................................................
							m_RxBurstType = RADIOINTERNAL;
80003816:	30 29       	mov	r9,2
80003818:	fe f8 0a c0 	ld.w	r8,pc[2752]
8000381c:	91 09       	st.w	r8[0x0],r9

							RxMediaState = READING_AMBE_AUX;//Jump
8000381e:	30 39       	mov	r9,3
80003820:	fe f8 0a b4 	ld.w	r8,pc[2740]
80003824:	91 09       	st.w	r8[0x0],r9
80003826:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									
					default://0x03,0x04
						
						//((Item_ID == 0x04) || (Item_ID == 0x03) )//Unknown type data directly back hair
							//break;
							m_RxBurstType = UNSUREDATA;
8000382a:	30 3a       	mov	r10,3
8000382c:	fe f9 0a ac 	ld.w	r9,pc[2732]
80003830:	93 0a       	st.w	r9[0x0],r10
							AMBE_HT[0] = payload_rx_channel->dword[0];
80003832:	6e 2a       	ld.w	r10,r7[0x8]
80003834:	fe f9 0a e0 	ld.w	r9,pc[2784]
80003838:	93 0a       	st.w	r9[0x0],r10
							AMBE_HT[1] = payload_rx_channel->dword[1];
8000383a:	6e 3a       	ld.w	r10,r7[0xc]
8000383c:	93 1a       	st.w	r9[0x4],r10
							
							if (RxBytesWaiting == 0x00000014)
8000383e:	59 48       	cp.w	r8,20
80003840:	c0 61       	brne	8000384c <phy_rx_func+0x434>
							{
								RxBytesWaiting = 0x18;//24 Reassigned
80003842:	31 89       	mov	r9,24
80003844:	fe f8 0a 98 	ld.w	r8,pc[2712]
80003848:	91 09       	st.w	r8[0x0],r9
8000384a:	c0 a8       	rjmp	8000385e <phy_rx_func+0x446>
								//_flag =0;
								
							}
							if (RxBytesWaiting == 0x00000010)
8000384c:	fe f8 0a 90 	ld.w	r8,pc[2704]
80003850:	70 08       	ld.w	r8,r8[0x0]
80003852:	59 08       	cp.w	r8,16
80003854:	c0 51       	brne	8000385e <phy_rx_func+0x446>
							{
								RxBytesWaiting = 0x10;//16 Reassigned
80003856:	31 09       	mov	r9,16
80003858:	fe f8 0a 84 	ld.w	r8,pc[2692]
8000385c:	91 09       	st.w	r8[0x0],r9
								//_flag =1;
							}
					
							RxMediaState = READING_AMBE_MEDIA;//Jump
8000385e:	30 49       	mov	r9,4
80003860:	fe f8 0a 74 	ld.w	r8,pc[2676]
80003864:	91 09       	st.w	r8[0x0],r9
80003866:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
//#if 0
			else//PCM-media-data
			{	
				//logFromISR("\n\r RX:%x \n\r", payload_rx_channel->dword[0]);
				//SPEAKER_DATA or  //MIC_DATA
				if (((payload_rx_channel->dword[0] & 0x0000F000 ) != SPEAKER_DATA ) 
8000386a:	e0 49 10 00 	cp.w	r9,4096
8000386e:	5f 1a       	srne	r10
80003870:	e0 49 20 00 	cp.w	r9,8192
80003874:	5f 19       	srne	r9
80003876:	f5 e9 00 09 	and	r9,r10,r9
8000387a:	e0 81 05 0c 	brne	80004292 <phy_rx_func+0xe7a>
					&& ((payload_rx_channel->dword[0] & 0x0000F000 ) != MIC_DATA ))break;
				
				AMBE_tx_flag = 0;
8000387e:	fe fa 0a 9a 	ld.w	r10,pc[2714]
80003882:	b4 89       	st.b	r10[0x0],r9
				AMBE_rx_flag = 0;
80003884:	fe fa 0a 98 	ld.w	r10,pc[2712]
80003888:	b4 89       	st.b	r10[0x0],r9
				
				Item_ID = 0;//To make sure your save PCM data.
8000388a:	fe fa 0a 62 	ld.w	r10,pc[2658]
8000388e:	b4 89       	st.b	r10[0x0],r9
			
				if (NULL== payload_ptr){
80003890:	fe f9 0a 3c 	ld.w	r9,pc[2620]
80003894:	72 09       	ld.w	r9,r9[0x0]
80003896:	58 09       	cp.w	r9,0
80003898:	c0 71       	brne	800038a6 <phy_rx_func+0x48e>
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//测试是否有这种情况出现
8000389a:	fe fc 0a 4a 	ld.w	r12,pc[2634]
8000389e:	f0 1f 02 93 	mcall	800042e8 <phy_rx_func+0xed0>
800038a2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
800038a6:	6e 2a       	ld.w	r10,r7[0x8]
800038a8:	e2 1a 0f 00 	andl	r10,0xf00,COH
800038ac:	58 1a       	cp.w	r10,1
800038ae:	e0 8b 00 4d 	brhi	80003948 <phy_rx_func+0x530>
				
				if ((payload_rx_channel->dword[0]  & 0x00000F00) <= 1){  //Flag type must process Array Descriptor.
				//The first word of the media access payload must be the Array descriptor length. And the
				//unit of the length is in word (16-bit). The length field itself does not count into the length.
				//When there is no array descriptor, the length must be set to zero.[9.1.4.1]
					if ((RxBytesWaiting -= 4) <= 0) break;          //Nothing beyond this Phy buffer. Keep looking for Header
800038b2:	20 48       	sub	r8,4
800038b4:	fe f9 0a 28 	ld.w	r9,pc[2600]
800038b8:	93 08       	st.w	r9[0x0],r8
800038ba:	58 08       	cp.w	r8,0
800038bc:	e0 80 04 eb 	breq	80004292 <phy_rx_func+0xe7a>
					ArrayDiscLength = payload_rx_channel->word[2];
800038c0:	8e 68       	ld.sh	r8,r7[0xc]
800038c2:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
800038c6:	fe f9 0a 5a 	ld.w	r9,pc[2650]
800038ca:	93 0a       	st.w	r9[0x0],r10
					switch (ArrayDiscLength){
800038cc:	30 09       	mov	r9,0
800038ce:	f2 08 19 00 	cp.h	r8,r9
800038d2:	c0 70       	breq	800038e0 <phy_rx_func+0x4c8>
800038d4:	30 19       	mov	r9,1
800038d6:	f2 08 19 00 	cp.h	r8,r9
800038da:	e0 81 04 dc 	brne	80004292 <phy_rx_func+0xe7a>
800038de:	c2 68       	rjmp	8000392a <phy_rx_func+0x512>
						case 0:          //The usual case. Remaining word in Phy buffer is Audio.
								
							payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
800038e0:	fe f8 0a 44 	ld.w	r8,pc[2628]
800038e4:	70 0a       	ld.w	r10,r8[0x0]
800038e6:	fe f9 09 e6 	ld.w	r9,pc[2534]
800038ea:	72 09       	ld.w	r9,r9[0x0]
800038ec:	8e 7b       	ld.sh	r11,r7[0xe]
800038ee:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
							RxMedia_IsFillingNext16 += 1;
800038f2:	70 09       	ld.w	r9,r8[0x0]
800038f4:	2f f9       	sub	r9,-1
800038f6:	91 09       	st.w	r8[0x0],r9
							if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800038f8:	e0 49 00 ff 	cp.w	r9,255
800038fc:	e0 88 00 11 	brls	8000391e <phy_rx_func+0x506>
							{
								RxMedia_IsFillingNext16 = 0;	
80003900:	30 09       	mov	r9,0
80003902:	91 09       	st.w	r8[0x0],r9
								payload_rx(payload_ptr);	
80003904:	fe f7 09 c8 	ld.w	r7,pc[2504]
80003908:	6e 0c       	ld.w	r12,r7[0x0]
8000390a:	f0 1f 02 7d 	mcall	800042fc <phy_rx_func+0xee4>
								payload_ptr = get_payload_idle_isr();
8000390e:	fe f8 09 ba 	ld.w	r8,pc[2490]
80003912:	70 0c       	ld.w	r12,r8[0x0]
80003914:	f0 1f 02 67 	mcall	800042b0 <phy_rx_func+0xe98>
80003918:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == payload_ptr){
8000391a:	e0 80 04 bc 	breq	80004292 <phy_rx_func+0xe7a>
									break;
								}				
							}
							RxMediaState = READINGMEDIA;
8000391e:	30 29       	mov	r9,2
80003920:	fe f8 09 b4 	ld.w	r8,pc[2484]
80003924:	91 09       	st.w	r8[0x0],r9
80003926:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
8000392a:	8e 79       	ld.sh	r9,r7[0xe]
8000392c:	30 38       	mov	r8,3
8000392e:	f0 09 19 00 	cp.h	r9,r8
80003932:	c0 51       	brne	8000393c <phy_rx_func+0x524>
				
						case 1: //The next usual case.
								//In general case, add code to process single word Array descriptor.
								if (payload_rx_channel->word[3] == 0x0003)//Stream Terminator
								{
									Terminator_Flag = 1;
80003934:	30 19       	mov	r9,1
80003936:	fe f8 09 f2 	ld.w	r8,pc[2546]
8000393a:	b0 89       	st.b	r8[0x0],r9
								else
								{
									//Terminator_Flag = 0;
								}
								
								RxMediaState = READINGMEDIA;
8000393c:	30 29       	mov	r9,2
8000393e:	fe f8 09 96 	ld.w	r8,pc[2454]
80003942:	91 09       	st.w	r8[0x0],r9
80003944:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
				break;
			}
		
				//Code gets here on Middle or last Fragment. No Array descriptor.
				if (RxBytesWaiting < 2) break;//This shouldn't happen, but must check.
80003948:	58 18       	cp.w	r8,1
8000394a:	e0 88 04 a4 	brls	80004292 <phy_rx_func+0xe7a>
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->dword[1] & 0x0000FFFF;
8000394e:	fe f8 09 d6 	ld.w	r8,pc[2518]
80003952:	70 0a       	ld.w	r10,r8[0x0]
80003954:	6e 3b       	ld.w	r11,r7[0xc]
80003956:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
8000395a:	70 09       	ld.w	r9,r8[0x0]
8000395c:	2f f9       	sub	r9,-1
8000395e:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003960:	e0 49 00 ff 	cp.w	r9,255
80003964:	e0 88 00 11 	brls	80003986 <phy_rx_func+0x56e>
				{
					RxMedia_IsFillingNext16 = 0;
80003968:	30 09       	mov	r9,0
8000396a:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
8000396c:	fe f7 09 60 	ld.w	r7,pc[2400]
80003970:	6e 0c       	ld.w	r12,r7[0x0]
80003972:	f0 1f 02 63 	mcall	800042fc <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
80003976:	fe f8 09 52 	ld.w	r8,pc[2386]
8000397a:	70 0c       	ld.w	r12,r8[0x0]
8000397c:	f0 1f 02 4d 	mcall	800042b0 <phy_rx_func+0xe98>
80003980:	8f 0c       	st.w	r7[0x0],r12
					if(NULL == payload_ptr)
80003982:	e0 80 04 88 	breq	80004292 <phy_rx_func+0xe7a>
					{
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0) break;  //This shouldn't happen, but must check;
80003986:	fe f9 09 56 	ld.w	r9,pc[2390]
8000398a:	72 08       	ld.w	r8,r9[0x0]
8000398c:	20 28       	sub	r8,2
8000398e:	93 08       	st.w	r9[0x0],r8
80003990:	e0 80 04 81 	breq	80004292 <phy_rx_func+0xe7a>
				RxMediaState = READINGMEDIA;
80003994:	30 29       	mov	r9,2
80003996:	fe f8 09 3e 	ld.w	r8,pc[2366]
8000399a:	91 09       	st.w	r8[0x0],r9
8000399c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
		case READINGMEDIA:
				
			/***PCM-media-data ****/
			{
				
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[0];
800039a0:	fe f8 09 84 	ld.w	r8,pc[2436]
800039a4:	70 0a       	ld.w	r10,r8[0x0]
800039a6:	fe f9 09 26 	ld.w	r9,pc[2342]
800039aa:	72 09       	ld.w	r9,r9[0x0]
800039ac:	8e 4b       	ld.sh	r11,r7[0x8]
800039ae:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;	
800039b2:	70 09       	ld.w	r9,r8[0x0]
800039b4:	2f f9       	sub	r9,-1
800039b6:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800039b8:	e0 49 00 ff 	cp.w	r9,255
800039bc:	e0 88 00 16 	brls	800039e8 <phy_rx_func+0x5d0>
				{
					RxMedia_IsFillingNext16 = 0;
800039c0:	30 09       	mov	r9,0
800039c2:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
800039c4:	fe f6 09 08 	ld.w	r6,pc[2312]
800039c8:	6c 0c       	ld.w	r12,r6[0x0]
800039ca:	f0 1f 02 4d 	mcall	800042fc <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
800039ce:	fe f8 08 fa 	ld.w	r8,pc[2298]
800039d2:	70 0c       	ld.w	r12,r8[0x0]
800039d4:	f0 1f 02 37 	mcall	800042b0 <phy_rx_func+0xe98>
800039d8:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
800039da:	c0 71       	brne	800039e8 <phy_rx_func+0x5d0>
					{
						RxMediaState = WAITINGABAB;
800039dc:	30 09       	mov	r9,0
800039de:	fe f8 08 f6 	ld.w	r8,pc[2294]
800039e2:	91 09       	st.w	r8[0x0],r9
800039e4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0)
800039e8:	fe f9 08 f4 	ld.w	r9,pc[2292]
800039ec:	72 08       	ld.w	r8,r9[0x0]
800039ee:	20 28       	sub	r8,2
800039f0:	93 08       	st.w	r9[0x0],r8
800039f2:	c0 71       	brne	80003a00 <phy_rx_func+0x5e8>
				{
					RxMediaState = WAITINGABAB;
800039f4:	30 09       	mov	r9,0
800039f6:	fe f8 08 de 	ld.w	r8,pc[2270]
800039fa:	91 09       	st.w	r8[0x0],r9
800039fc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[1];
80003a00:	fe f8 09 24 	ld.w	r8,pc[2340]
80003a04:	70 0a       	ld.w	r10,r8[0x0]
80003a06:	fe f9 08 c6 	ld.w	r9,pc[2246]
80003a0a:	72 09       	ld.w	r9,r9[0x0]
80003a0c:	8e 5b       	ld.sh	r11,r7[0xa]
80003a0e:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80003a12:	70 09       	ld.w	r9,r8[0x0]
80003a14:	2f f9       	sub	r9,-1
80003a16:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003a18:	e0 49 00 ff 	cp.w	r9,255
80003a1c:	e0 88 00 16 	brls	80003a48 <phy_rx_func+0x630>
				{
					RxMedia_IsFillingNext16 = 0;
80003a20:	30 09       	mov	r9,0
80003a22:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003a24:	fe f6 08 a8 	ld.w	r6,pc[2216]
80003a28:	6c 0c       	ld.w	r12,r6[0x0]
80003a2a:	f0 1f 02 35 	mcall	800042fc <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
80003a2e:	fe f8 08 9a 	ld.w	r8,pc[2202]
80003a32:	70 0c       	ld.w	r12,r8[0x0]
80003a34:	f0 1f 02 1f 	mcall	800042b0 <phy_rx_func+0xe98>
80003a38:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
80003a3a:	c0 71       	brne	80003a48 <phy_rx_func+0x630>
					{
						RxMediaState = WAITINGABAB;
80003a3c:	30 09       	mov	r9,0
80003a3e:	fe f8 08 96 	ld.w	r8,pc[2198]
80003a42:	91 09       	st.w	r8[0x0],r9
80003a44:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
80003a48:	fe f9 08 94 	ld.w	r9,pc[2196]
80003a4c:	72 08       	ld.w	r8,r9[0x0]
80003a4e:	20 28       	sub	r8,2
80003a50:	93 08       	st.w	r9[0x0],r8
80003a52:	c0 71       	brne	80003a60 <phy_rx_func+0x648>
					RxMediaState = WAITINGABAB;
80003a54:	30 09       	mov	r9,0
80003a56:	fe f8 08 7e 	ld.w	r8,pc[2174]
80003a5a:	91 09       	st.w	r8[0x0],r9
80003a5c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}

				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[2];
80003a60:	fe f8 08 c4 	ld.w	r8,pc[2244]
80003a64:	70 0a       	ld.w	r10,r8[0x0]
80003a66:	fe f9 08 66 	ld.w	r9,pc[2150]
80003a6a:	72 09       	ld.w	r9,r9[0x0]
80003a6c:	8e 6b       	ld.sh	r11,r7[0xc]
80003a6e:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80003a72:	70 09       	ld.w	r9,r8[0x0]
80003a74:	2f f9       	sub	r9,-1
80003a76:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003a78:	e0 49 00 ff 	cp.w	r9,255
80003a7c:	e0 88 00 16 	brls	80003aa8 <phy_rx_func+0x690>
				{
					RxMedia_IsFillingNext16 = 0;
80003a80:	30 09       	mov	r9,0
80003a82:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003a84:	fe f6 08 48 	ld.w	r6,pc[2120]
80003a88:	6c 0c       	ld.w	r12,r6[0x0]
80003a8a:	f0 1f 02 1d 	mcall	800042fc <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
80003a8e:	fe f8 08 3a 	ld.w	r8,pc[2106]
80003a92:	70 0c       	ld.w	r12,r8[0x0]
80003a94:	f0 1f 02 07 	mcall	800042b0 <phy_rx_func+0xe98>
80003a98:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
80003a9a:	c0 71       	brne	80003aa8 <phy_rx_func+0x690>
					{
						RxMediaState = WAITINGABAB;
80003a9c:	30 09       	mov	r9,0
80003a9e:	fe f8 08 36 	ld.w	r8,pc[2102]
80003aa2:	91 09       	st.w	r8[0x0],r9
80003aa4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
80003aa8:	fe f9 08 34 	ld.w	r9,pc[2100]
80003aac:	72 08       	ld.w	r8,r9[0x0]
80003aae:	20 28       	sub	r8,2
80003ab0:	93 08       	st.w	r9[0x0],r8
80003ab2:	c0 71       	brne	80003ac0 <phy_rx_func+0x6a8>
					RxMediaState = WAITINGABAB;
80003ab4:	30 09       	mov	r9,0
80003ab6:	fe f8 08 1e 	ld.w	r8,pc[2078]
80003aba:	91 09       	st.w	r8[0x0],r9
80003abc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
80003ac0:	fe f8 08 64 	ld.w	r8,pc[2148]
80003ac4:	70 0a       	ld.w	r10,r8[0x0]
80003ac6:	fe f9 08 06 	ld.w	r9,pc[2054]
80003aca:	72 09       	ld.w	r9,r9[0x0]
80003acc:	8e 7b       	ld.sh	r11,r7[0xe]
80003ace:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80003ad2:	70 09       	ld.w	r9,r8[0x0]
80003ad4:	2f f9       	sub	r9,-1
80003ad6:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003ad8:	e0 49 00 ff 	cp.w	r9,255
80003adc:	e0 88 00 16 	brls	80003b08 <phy_rx_func+0x6f0>
				{
					RxMedia_IsFillingNext16 = 0;
80003ae0:	30 09       	mov	r9,0
80003ae2:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003ae4:	fe f7 07 e8 	ld.w	r7,pc[2024]
80003ae8:	6e 0c       	ld.w	r12,r7[0x0]
80003aea:	f0 1f 02 05 	mcall	800042fc <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
80003aee:	fe f8 07 da 	ld.w	r8,pc[2010]
80003af2:	70 0c       	ld.w	r12,r8[0x0]
80003af4:	f0 1f 01 ef 	mcall	800042b0 <phy_rx_func+0xe98>
80003af8:	8f 0c       	st.w	r7[0x0],r12
					if(NULL == payload_ptr)
80003afa:	c0 71       	brne	80003b08 <phy_rx_func+0x6f0>
					{
						RxMediaState = WAITINGABAB;
80003afc:	30 09       	mov	r9,0
80003afe:	fe f8 07 d6 	ld.w	r8,pc[2006]
80003b02:	91 09       	st.w	r8[0x0],r9
80003b04:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
80003b08:	fe f9 07 d4 	ld.w	r9,pc[2004]
80003b0c:	72 08       	ld.w	r8,r9[0x0]
80003b0e:	20 28       	sub	r8,2
80003b10:	93 08       	st.w	r9[0x0],r8
80003b12:	e0 81 03 c0 	brne	80004292 <phy_rx_func+0xe7a>
					RxMediaState = WAITINGABAB;
80003b16:	30 09       	mov	r9,0
80003b18:	fe f8 07 bc 	ld.w	r8,pc[1980]
80003b1c:	91 09       	st.w	r8[0x0],r9
80003b1e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

		case READING_AMBE_MEDIA:
		
			/****AMBE-media-data ****/
		
					if ((Item_ID == Vocoder_Bit_Stream_Parameter))//PAYLOAD_DATA_ENH (0x0c))
80003b22:	fe f8 07 ca 	ld.w	r8,pc[1994]
80003b26:	11 89       	ld.ub	r9,r8[0x0]
80003b28:	31 28       	mov	r8,18
80003b2a:	f0 09 18 00 	cp.b	r9,r8
80003b2e:	e0 81 01 4c 	brne	80003dc6 <phy_rx_func+0x9ae>
					{
						Item_ID = payload_rx_channel->byte[1];
80003b32:	ef 39 00 09 	ld.ub	r9,r7[9]
80003b36:	fe f8 07 b6 	ld.w	r8,pc[1974]
80003b3a:	b0 89       	st.b	r8[0x0],r9
						if (Item_ID == Post_Voice_Encoder_Data)//发送方的压缩类型数据
80003b3c:	11 89       	ld.ub	r9,r8[0x0]
80003b3e:	3f 28       	mov	r8,-14
80003b40:	f0 09 18 00 	cp.b	r9,r8
80003b44:	e0 81 01 3b 	brne	80003dba <phy_rx_func+0x9a2>
						{
							AMBE_tx_flag = 1;
80003b48:	30 19       	mov	r9,1
80003b4a:	fe f8 07 ce 	ld.w	r8,pc[1998]
80003b4e:	b0 89       	st.b	r8[0x0],r9
							
							RxBytesWaiting = ((payload_rx_channel->dword[0] & 0x7F000000) >>24);//Test calculations are correct; 8
80003b50:	6e 29       	ld.w	r9,r7[0x8]
80003b52:	f3 d9 c3 07 	bfextu	r9,r9,0x18,0x7
80003b56:	fe f8 07 86 	ld.w	r8,pc[1926]
80003b5a:	91 09       	st.w	r8[0x0],r9
							
							//For looping back to Radio
							AMBEBurst_rawdata[0] = payload_rx_channel->word[1];
80003b5c:	8e 59       	ld.sh	r9,r7[0xa]
80003b5e:	fe f8 07 ce 	ld.w	r8,pc[1998]
80003b62:	b0 09       	st.h	r8[0x0],r9
							AMBEBurst_rawdata[1] = payload_rx_channel->word[2];
80003b64:	8e 69       	ld.sh	r9,r7[0xc]
80003b66:	b0 19       	st.h	r8[0x2],r9
							AMBEBurst_rawdata[2] = payload_rx_channel->word[3];
80003b68:	8e 79       	ld.sh	r9,r7[0xe]
80003b6a:	b0 29       	st.h	r8[0x4],r9
							
							//To be tested. Also locally stored RAW-AMBER-DATA
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//1
80003b6c:	fe f8 07 88 	ld.w	r8,pc[1928]
80003b70:	fe f9 07 60 	ld.w	r9,pc[1888]
80003b74:	72 0a       	ld.w	r10,r9[0x0]
80003b76:	70 09       	ld.w	r9,r8[0x0]
80003b78:	ef 3b 00 0a 	ld.ub	r11,r7[10]
80003b7c:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003b80:	70 09       	ld.w	r9,r8[0x0]
80003b82:	2f f9       	sub	r9,-1
80003b84:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003b86:	e0 49 01 ff 	cp.w	r9,511
80003b8a:	e0 88 00 16 	brls	80003bb6 <phy_rx_func+0x79e>
							{
								RxAMBE_IsFillingNext8 = 0;
80003b8e:	30 09       	mov	r9,0
80003b90:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003b92:	fe f6 07 3e 	ld.w	r6,pc[1854]
80003b96:	6c 0c       	ld.w	r12,r6[0x0]
80003b98:	f0 1f 01 d9 	mcall	800042fc <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003b9c:	fe f8 07 2c 	ld.w	r8,pc[1836]
80003ba0:	70 0c       	ld.w	r12,r8[0x0]
80003ba2:	f0 1f 01 c4 	mcall	800042b0 <phy_rx_func+0xe98>
80003ba6:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003ba8:	c0 71       	brne	80003bb6 <phy_rx_func+0x79e>
								{
									RxMediaState = WAITINGABAB;
80003baa:	30 09       	mov	r9,0
80003bac:	fe f8 07 28 	ld.w	r8,pc[1832]
80003bb0:	91 09       	st.w	r8[0x0],r9
80003bb2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003bb6:	fe f9 07 26 	ld.w	r9,pc[1830]
80003bba:	72 08       	ld.w	r8,r9[0x0]
80003bbc:	20 18       	sub	r8,1
80003bbe:	93 08       	st.w	r9[0x0],r8
80003bc0:	c0 71       	brne	80003bce <phy_rx_func+0x7b6>
								RxMediaState = WAITINGABAB;
80003bc2:	30 09       	mov	r9,0
80003bc4:	fe f8 07 10 	ld.w	r8,pc[1808]
80003bc8:	91 09       	st.w	r8[0x0],r9
80003bca:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}			
							
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//2
80003bce:	fe f8 07 26 	ld.w	r8,pc[1830]
80003bd2:	fe f9 06 fe 	ld.w	r9,pc[1790]
80003bd6:	72 0a       	ld.w	r10,r9[0x0]
80003bd8:	70 09       	ld.w	r9,r8[0x0]
80003bda:	ef 3b 00 0b 	ld.ub	r11,r7[11]
80003bde:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003be2:	70 09       	ld.w	r9,r8[0x0]
80003be4:	2f f9       	sub	r9,-1
80003be6:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003be8:	e0 49 01 ff 	cp.w	r9,511
80003bec:	e0 88 00 16 	brls	80003c18 <phy_rx_func+0x800>
							{
								RxAMBE_IsFillingNext8 = 0;
80003bf0:	30 09       	mov	r9,0
80003bf2:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003bf4:	fe f6 06 dc 	ld.w	r6,pc[1756]
80003bf8:	6c 0c       	ld.w	r12,r6[0x0]
80003bfa:	f0 1f 01 c1 	mcall	800042fc <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003bfe:	fe f8 06 ca 	ld.w	r8,pc[1738]
80003c02:	70 0c       	ld.w	r12,r8[0x0]
80003c04:	f0 1f 01 ab 	mcall	800042b0 <phy_rx_func+0xe98>
80003c08:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003c0a:	c0 71       	brne	80003c18 <phy_rx_func+0x800>
								{
									RxMediaState = WAITINGABAB;
80003c0c:	30 09       	mov	r9,0
80003c0e:	fe f8 06 c6 	ld.w	r8,pc[1734]
80003c12:	91 09       	st.w	r8[0x0],r9
80003c14:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003c18:	fe f9 06 c4 	ld.w	r9,pc[1732]
80003c1c:	72 08       	ld.w	r8,r9[0x0]
80003c1e:	20 18       	sub	r8,1
80003c20:	93 08       	st.w	r9[0x0],r8
80003c22:	c0 71       	brne	80003c30 <phy_rx_func+0x818>
								RxMediaState = WAITINGABAB;
80003c24:	30 09       	mov	r9,0
80003c26:	fe f8 06 ae 	ld.w	r8,pc[1710]
80003c2a:	91 09       	st.w	r8[0x0],r9
80003c2c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}		
						
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//3
80003c30:	fe f8 06 c4 	ld.w	r8,pc[1732]
80003c34:	fe f9 06 9c 	ld.w	r9,pc[1692]
80003c38:	72 0a       	ld.w	r10,r9[0x0]
80003c3a:	70 09       	ld.w	r9,r8[0x0]
80003c3c:	ef 3b 00 0c 	ld.ub	r11,r7[12]
80003c40:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003c44:	70 09       	ld.w	r9,r8[0x0]
80003c46:	2f f9       	sub	r9,-1
80003c48:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003c4a:	e0 49 01 ff 	cp.w	r9,511
80003c4e:	e0 88 00 16 	brls	80003c7a <phy_rx_func+0x862>
							{
								RxAMBE_IsFillingNext8 = 0;
80003c52:	30 09       	mov	r9,0
80003c54:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003c56:	fe f6 06 7a 	ld.w	r6,pc[1658]
80003c5a:	6c 0c       	ld.w	r12,r6[0x0]
80003c5c:	f0 1f 01 a8 	mcall	800042fc <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003c60:	fe f8 06 68 	ld.w	r8,pc[1640]
80003c64:	70 0c       	ld.w	r12,r8[0x0]
80003c66:	f0 1f 01 93 	mcall	800042b0 <phy_rx_func+0xe98>
80003c6a:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003c6c:	c0 71       	brne	80003c7a <phy_rx_func+0x862>
								{
									RxMediaState = WAITINGABAB;
80003c6e:	30 09       	mov	r9,0
80003c70:	fe f8 06 64 	ld.w	r8,pc[1636]
80003c74:	91 09       	st.w	r8[0x0],r9
80003c76:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003c7a:	fe f9 06 62 	ld.w	r9,pc[1634]
80003c7e:	72 08       	ld.w	r8,r9[0x0]
80003c80:	20 18       	sub	r8,1
80003c82:	93 08       	st.w	r9[0x0],r8
80003c84:	c0 71       	brne	80003c92 <phy_rx_func+0x87a>
								RxMediaState = WAITINGABAB;
80003c86:	30 09       	mov	r9,0
80003c88:	fe f8 06 4c 	ld.w	r8,pc[1612]
80003c8c:	91 09       	st.w	r8[0x0],r9
80003c8e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[5];//4
80003c92:	fe f8 06 62 	ld.w	r8,pc[1634]
80003c96:	fe f9 06 3a 	ld.w	r9,pc[1594]
80003c9a:	72 0a       	ld.w	r10,r9[0x0]
80003c9c:	70 09       	ld.w	r9,r8[0x0]
80003c9e:	ef 3b 00 0d 	ld.ub	r11,r7[13]
80003ca2:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003ca6:	70 09       	ld.w	r9,r8[0x0]
80003ca8:	2f f9       	sub	r9,-1
80003caa:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003cac:	e0 49 01 ff 	cp.w	r9,511
80003cb0:	e0 88 00 16 	brls	80003cdc <phy_rx_func+0x8c4>
							{
								RxAMBE_IsFillingNext8 = 0;
80003cb4:	30 09       	mov	r9,0
80003cb6:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003cb8:	fe f6 06 18 	ld.w	r6,pc[1560]
80003cbc:	6c 0c       	ld.w	r12,r6[0x0]
80003cbe:	f0 1f 01 90 	mcall	800042fc <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003cc2:	fe f8 06 06 	ld.w	r8,pc[1542]
80003cc6:	70 0c       	ld.w	r12,r8[0x0]
80003cc8:	f0 1f 01 7a 	mcall	800042b0 <phy_rx_func+0xe98>
80003ccc:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003cce:	c0 71       	brne	80003cdc <phy_rx_func+0x8c4>
								{
									RxMediaState = WAITINGABAB;
80003cd0:	30 09       	mov	r9,0
80003cd2:	fe f8 06 02 	ld.w	r8,pc[1538]
80003cd6:	91 09       	st.w	r8[0x0],r9
80003cd8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003cdc:	fe f9 06 00 	ld.w	r9,pc[1536]
80003ce0:	72 08       	ld.w	r8,r9[0x0]
80003ce2:	20 18       	sub	r8,1
80003ce4:	93 08       	st.w	r9[0x0],r8
80003ce6:	c0 71       	brne	80003cf4 <phy_rx_func+0x8dc>
								RxMediaState = WAITINGABAB;
80003ce8:	30 09       	mov	r9,0
80003cea:	fe f8 05 ea 	ld.w	r8,pc[1514]
80003cee:	91 09       	st.w	r8[0x0],r9
80003cf0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//5
80003cf4:	fe f8 06 00 	ld.w	r8,pc[1536]
80003cf8:	fe f9 05 d8 	ld.w	r9,pc[1496]
80003cfc:	72 0a       	ld.w	r10,r9[0x0]
80003cfe:	70 09       	ld.w	r9,r8[0x0]
80003d00:	ef 3b 00 0e 	ld.ub	r11,r7[14]
80003d04:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003d08:	70 09       	ld.w	r9,r8[0x0]
80003d0a:	2f f9       	sub	r9,-1
80003d0c:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003d0e:	e0 49 01 ff 	cp.w	r9,511
80003d12:	e0 88 00 16 	brls	80003d3e <phy_rx_func+0x926>
							{
								RxAMBE_IsFillingNext8 = 0;
80003d16:	30 09       	mov	r9,0
80003d18:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003d1a:	fe f6 05 b6 	ld.w	r6,pc[1462]
80003d1e:	6c 0c       	ld.w	r12,r6[0x0]
80003d20:	f0 1f 01 77 	mcall	800042fc <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003d24:	fe f8 05 a4 	ld.w	r8,pc[1444]
80003d28:	70 0c       	ld.w	r12,r8[0x0]
80003d2a:	f0 1f 01 62 	mcall	800042b0 <phy_rx_func+0xe98>
80003d2e:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003d30:	c0 71       	brne	80003d3e <phy_rx_func+0x926>
								{
									RxMediaState = WAITINGABAB;
80003d32:	30 09       	mov	r9,0
80003d34:	fe f8 05 a0 	ld.w	r8,pc[1440]
80003d38:	91 09       	st.w	r8[0x0],r9
80003d3a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003d3e:	fe f9 05 9e 	ld.w	r9,pc[1438]
80003d42:	72 08       	ld.w	r8,r9[0x0]
80003d44:	20 18       	sub	r8,1
80003d46:	93 08       	st.w	r9[0x0],r8
80003d48:	c0 71       	brne	80003d56 <phy_rx_func+0x93e>
								RxMediaState = WAITINGABAB;
80003d4a:	30 09       	mov	r9,0
80003d4c:	fe f8 05 88 	ld.w	r8,pc[1416]
80003d50:	91 09       	st.w	r8[0x0],r9
80003d52:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//6
80003d56:	fe f8 05 9e 	ld.w	r8,pc[1438]
80003d5a:	fe f9 05 76 	ld.w	r9,pc[1398]
80003d5e:	72 0a       	ld.w	r10,r9[0x0]
80003d60:	70 09       	ld.w	r9,r8[0x0]
80003d62:	ef 3b 00 0f 	ld.ub	r11,r7[15]
80003d66:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003d6a:	70 09       	ld.w	r9,r8[0x0]
80003d6c:	2f f9       	sub	r9,-1
80003d6e:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003d70:	e0 49 01 ff 	cp.w	r9,511
80003d74:	e0 88 00 16 	brls	80003da0 <phy_rx_func+0x988>
							{
								RxAMBE_IsFillingNext8 = 0;
80003d78:	30 09       	mov	r9,0
80003d7a:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003d7c:	fe f7 05 54 	ld.w	r7,pc[1364]
80003d80:	6e 0c       	ld.w	r12,r7[0x0]
80003d82:	f0 1f 01 5f 	mcall	800042fc <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003d86:	fe f8 05 42 	ld.w	r8,pc[1346]
80003d8a:	70 0c       	ld.w	r12,r8[0x0]
80003d8c:	f0 1f 01 49 	mcall	800042b0 <phy_rx_func+0xe98>
80003d90:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003d92:	c0 71       	brne	80003da0 <phy_rx_func+0x988>
								{
									RxMediaState = WAITINGABAB;
80003d94:	30 09       	mov	r9,0
80003d96:	fe f8 05 3e 	ld.w	r8,pc[1342]
80003d9a:	91 09       	st.w	r8[0x0],r9
80003d9c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003da0:	fe f9 05 3c 	ld.w	r9,pc[1340]
80003da4:	72 08       	ld.w	r8,r9[0x0]
80003da6:	20 18       	sub	r8,1
80003da8:	93 08       	st.w	r9[0x0],r8
80003daa:	e0 81 02 74 	brne	80004292 <phy_rx_func+0xe7a>
								RxMediaState = WAITINGABAB;
80003dae:	30 09       	mov	r9,0
80003db0:	fe f8 05 24 	ld.w	r8,pc[1316]
80003db4:	91 09       	st.w	r8[0x0],r9
80003db6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							//}
							
						}
						else//error
						{
							RxMediaState = WAITINGABAB;
80003dba:	30 09       	mov	r9,0
80003dbc:	fe f8 05 18 	ld.w	r8,pc[1304]
80003dc0:	91 09       	st.w	r8[0x0],r9
80003dc2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
					}
					else if (Item_ID == Post_Voice_Encoder_Data)//(bit48~Pad-bits)
80003dc6:	fe f8 05 26 	ld.w	r8,pc[1318]
80003dca:	11 89       	ld.ub	r9,r8[0x0]
80003dcc:	3f 28       	mov	r8,-14
80003dce:	f0 09 18 00 	cp.b	r9,r8
80003dd2:	c4 31       	brne	80003e58 <phy_rx_func+0xa40>
					{
					
						AMBEBurst_rawdata[3] = payload_rx_channel->word[0];//(bit48~Pad-bits)
80003dd4:	8e 49       	ld.sh	r9,r7[0x8]
80003dd6:	fe f8 05 56 	ld.w	r8,pc[1366]
80003dda:	b0 39       	st.h	r8[0x6],r9
						//AMBE_Per_Burst_Flag = 1;
						
						//根据MOTO.bit文件数据分布，建议测试pad-bits的最后一个字节不保存。
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//7
80003ddc:	fe f8 05 18 	ld.w	r8,pc[1304]
80003de0:	fe f9 04 f0 	ld.w	r9,pc[1264]
80003de4:	72 0a       	ld.w	r10,r9[0x0]
80003de6:	70 09       	ld.w	r9,r8[0x0]
80003de8:	ef 3b 00 08 	ld.ub	r11,r7[8]
80003dec:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003df0:	70 09       	ld.w	r9,r8[0x0]
80003df2:	2f f9       	sub	r9,-1
80003df4:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003df6:	e0 49 01 ff 	cp.w	r9,511
80003dfa:	e0 88 00 16 	brls	80003e26 <phy_rx_func+0xa0e>
						{
							RxAMBE_IsFillingNext8 = 0;
80003dfe:	30 09       	mov	r9,0
80003e00:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003e02:	fe f7 04 ce 	ld.w	r7,pc[1230]
80003e06:	6e 0c       	ld.w	r12,r7[0x0]
80003e08:	f0 1f 01 3d 	mcall	800042fc <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003e0c:	fe f8 04 bc 	ld.w	r8,pc[1212]
80003e10:	70 0c       	ld.w	r12,r8[0x0]
80003e12:	f0 1f 01 28 	mcall	800042b0 <phy_rx_func+0xe98>
80003e16:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003e18:	c0 71       	brne	80003e26 <phy_rx_func+0xa0e>
							{
								RxMediaState = WAITINGABAB;
80003e1a:	30 09       	mov	r9,0
80003e1c:	fe f8 04 b8 	ld.w	r8,pc[1208]
80003e20:	91 09       	st.w	r8[0x0],r9
80003e22:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003e26:	fe f9 04 b6 	ld.w	r9,pc[1206]
80003e2a:	72 08       	ld.w	r8,r9[0x0]
80003e2c:	20 18       	sub	r8,1
80003e2e:	93 08       	st.w	r9[0x0],r8
80003e30:	c0 71       	brne	80003e3e <phy_rx_func+0xa26>
							RxMediaState = WAITINGABAB;
80003e32:	30 09       	mov	r9,0
80003e34:	fe f8 04 a0 	ld.w	r8,pc[1184]
80003e38:	91 09       	st.w	r8[0x0],r9
80003e3a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
						if ((RxBytesWaiting -= 1) <= 0){//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
80003e3e:	20 18       	sub	r8,1
80003e40:	fe f9 04 9c 	ld.w	r9,pc[1180]
80003e44:	93 08       	st.w	r9[0x0],r8
80003e46:	58 08       	cp.w	r8,0
80003e48:	e0 81 02 25 	brne	80004292 <phy_rx_func+0xe7a>
							RxMediaState = WAITINGABAB;
80003e4c:	30 09       	mov	r9,0
80003e4e:	fe f8 04 86 	ld.w	r8,pc[1158]
80003e52:	91 09       	st.w	r8[0x0],r9
80003e54:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
								
					}
					else if (Item_ID == Pre_Voice_Decoder_Data)//bit16~bit63
80003e58:	fe f8 04 94 	ld.w	r8,pc[1172]
80003e5c:	11 89       	ld.ub	r9,r8[0x0]
80003e5e:	3f 38       	mov	r8,-13
80003e60:	f0 09 18 00 	cp.b	r9,r8
80003e64:	e0 81 01 0c 	brne	8000407c <phy_rx_func+0xc64>
					{
						//接收方的解压类型数据
						//For looping back to Radio
						AMBEBurst_rawdata[1] = payload_rx_channel->word[0];
80003e68:	8e 49       	ld.sh	r9,r7[0x8]
80003e6a:	fe f8 04 c2 	ld.w	r8,pc[1218]
80003e6e:	b0 19       	st.h	r8[0x2],r9
						AMBEBurst_rawdata[2] = payload_rx_channel->word[1];
80003e70:	8e 59       	ld.sh	r9,r7[0xa]
80003e72:	b0 29       	st.h	r8[0x4],r9
						AMBEBurst_rawdata[3] = payload_rx_channel->word[2];
80003e74:	8e 69       	ld.sh	r9,r7[0xc]
80003e76:	b0 39       	st.h	r8[0x6],r9
						//if((m_RxBurstType == VOICEBURST_A) && (VF_SN == 1))
						//logFromISR("\n\r Pre_rx:%X\n\r", payload_rx_channel->word[2]);
						
						//To be tested. Also locally stored RAW-AMBER-DATA
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//3
80003e78:	fe f8 04 7c 	ld.w	r8,pc[1148]
80003e7c:	fe f9 04 54 	ld.w	r9,pc[1108]
80003e80:	72 0a       	ld.w	r10,r9[0x0]
80003e82:	70 09       	ld.w	r9,r8[0x0]
80003e84:	ef 3b 00 08 	ld.ub	r11,r7[8]
80003e88:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003e8c:	70 09       	ld.w	r9,r8[0x0]
80003e8e:	2f f9       	sub	r9,-1
80003e90:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003e92:	e0 49 01 ff 	cp.w	r9,511
80003e96:	e0 88 00 16 	brls	80003ec2 <phy_rx_func+0xaaa>
						{
							RxAMBE_IsFillingNext8 = 0;
80003e9a:	30 09       	mov	r9,0
80003e9c:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003e9e:	fe f6 04 32 	ld.w	r6,pc[1074]
80003ea2:	6c 0c       	ld.w	r12,r6[0x0]
80003ea4:	f0 1f 01 16 	mcall	800042fc <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003ea8:	fe f8 04 20 	ld.w	r8,pc[1056]
80003eac:	70 0c       	ld.w	r12,r8[0x0]
80003eae:	f0 1f 01 01 	mcall	800042b0 <phy_rx_func+0xe98>
80003eb2:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003eb4:	c0 71       	brne	80003ec2 <phy_rx_func+0xaaa>
							{
								RxMediaState = WAITINGABAB;
80003eb6:	30 09       	mov	r9,0
80003eb8:	fe f8 04 1c 	ld.w	r8,pc[1052]
80003ebc:	91 09       	st.w	r8[0x0],r9
80003ebe:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003ec2:	fe f9 04 1a 	ld.w	r9,pc[1050]
80003ec6:	72 08       	ld.w	r8,r9[0x0]
80003ec8:	20 18       	sub	r8,1
80003eca:	93 08       	st.w	r9[0x0],r8
80003ecc:	c0 71       	brne	80003eda <phy_rx_func+0xac2>
							RxMediaState = WAITINGABAB;
80003ece:	30 09       	mov	r9,0
80003ed0:	fe f8 04 04 	ld.w	r8,pc[1028]
80003ed4:	91 09       	st.w	r8[0x0],r9
80003ed6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[1];//4
80003eda:	fe f8 04 1a 	ld.w	r8,pc[1050]
80003ede:	fe f9 03 f2 	ld.w	r9,pc[1010]
80003ee2:	72 0a       	ld.w	r10,r9[0x0]
80003ee4:	70 09       	ld.w	r9,r8[0x0]
80003ee6:	ef 3b 00 09 	ld.ub	r11,r7[9]
80003eea:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003eee:	70 09       	ld.w	r9,r8[0x0]
80003ef0:	2f f9       	sub	r9,-1
80003ef2:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003ef4:	e0 49 01 ff 	cp.w	r9,511
80003ef8:	e0 88 00 16 	brls	80003f24 <phy_rx_func+0xb0c>
						{
							RxAMBE_IsFillingNext8 = 0;
80003efc:	30 09       	mov	r9,0
80003efe:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003f00:	fe f6 03 d0 	ld.w	r6,pc[976]
80003f04:	6c 0c       	ld.w	r12,r6[0x0]
80003f06:	f0 1f 00 fe 	mcall	800042fc <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003f0a:	fe f8 03 be 	ld.w	r8,pc[958]
80003f0e:	70 0c       	ld.w	r12,r8[0x0]
80003f10:	f0 1f 00 e8 	mcall	800042b0 <phy_rx_func+0xe98>
80003f14:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003f16:	c0 71       	brne	80003f24 <phy_rx_func+0xb0c>
							{
								RxMediaState = WAITINGABAB;
80003f18:	30 09       	mov	r9,0
80003f1a:	fe f8 03 ba 	ld.w	r8,pc[954]
80003f1e:	91 09       	st.w	r8[0x0],r9
80003f20:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003f24:	fe f9 03 b8 	ld.w	r9,pc[952]
80003f28:	72 08       	ld.w	r8,r9[0x0]
80003f2a:	20 18       	sub	r8,1
80003f2c:	93 08       	st.w	r9[0x0],r8
80003f2e:	c0 71       	brne	80003f3c <phy_rx_func+0xb24>
							RxMediaState = WAITINGABAB;
80003f30:	30 09       	mov	r9,0
80003f32:	fe f8 03 a2 	ld.w	r8,pc[930]
80003f36:	91 09       	st.w	r8[0x0],r9
80003f38:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//5
80003f3c:	fe f8 03 b8 	ld.w	r8,pc[952]
80003f40:	fe f9 03 90 	ld.w	r9,pc[912]
80003f44:	72 0a       	ld.w	r10,r9[0x0]
80003f46:	70 09       	ld.w	r9,r8[0x0]
80003f48:	ef 3b 00 0a 	ld.ub	r11,r7[10]
80003f4c:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003f50:	70 09       	ld.w	r9,r8[0x0]
80003f52:	2f f9       	sub	r9,-1
80003f54:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003f56:	e0 49 01 ff 	cp.w	r9,511
80003f5a:	e0 88 00 16 	brls	80003f86 <phy_rx_func+0xb6e>
						{
							RxAMBE_IsFillingNext8 = 0;
80003f5e:	30 09       	mov	r9,0
80003f60:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003f62:	fe f6 03 6e 	ld.w	r6,pc[878]
80003f66:	6c 0c       	ld.w	r12,r6[0x0]
80003f68:	f0 1f 00 e5 	mcall	800042fc <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003f6c:	fe f8 03 5c 	ld.w	r8,pc[860]
80003f70:	70 0c       	ld.w	r12,r8[0x0]
80003f72:	f0 1f 00 d0 	mcall	800042b0 <phy_rx_func+0xe98>
80003f76:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003f78:	c0 71       	brne	80003f86 <phy_rx_func+0xb6e>
							{
								RxMediaState = WAITINGABAB;
80003f7a:	30 09       	mov	r9,0
80003f7c:	fe f8 03 58 	ld.w	r8,pc[856]
80003f80:	91 09       	st.w	r8[0x0],r9
80003f82:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003f86:	fe f9 03 56 	ld.w	r9,pc[854]
80003f8a:	72 08       	ld.w	r8,r9[0x0]
80003f8c:	20 18       	sub	r8,1
80003f8e:	93 08       	st.w	r9[0x0],r8
80003f90:	c0 71       	brne	80003f9e <phy_rx_func+0xb86>
							RxMediaState = WAITINGABAB;
80003f92:	30 09       	mov	r9,0
80003f94:	fe f8 03 40 	ld.w	r8,pc[832]
80003f98:	91 09       	st.w	r8[0x0],r9
80003f9a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//6
80003f9e:	fe f8 03 56 	ld.w	r8,pc[854]
80003fa2:	fe f9 03 2e 	ld.w	r9,pc[814]
80003fa6:	72 0a       	ld.w	r10,r9[0x0]
80003fa8:	70 09       	ld.w	r9,r8[0x0]
80003faa:	ef 3b 00 0b 	ld.ub	r11,r7[11]
80003fae:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003fb2:	70 09       	ld.w	r9,r8[0x0]
80003fb4:	2f f9       	sub	r9,-1
80003fb6:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003fb8:	e0 49 01 ff 	cp.w	r9,511
80003fbc:	e0 88 00 16 	brls	80003fe8 <phy_rx_func+0xbd0>
						{
							RxAMBE_IsFillingNext8 = 0;
80003fc0:	30 09       	mov	r9,0
80003fc2:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003fc4:	fe f6 03 0c 	ld.w	r6,pc[780]
80003fc8:	6c 0c       	ld.w	r12,r6[0x0]
80003fca:	f0 1f 00 cd 	mcall	800042fc <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003fce:	fe f8 02 fa 	ld.w	r8,pc[762]
80003fd2:	70 0c       	ld.w	r12,r8[0x0]
80003fd4:	f0 1f 00 b7 	mcall	800042b0 <phy_rx_func+0xe98>
80003fd8:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003fda:	c0 71       	brne	80003fe8 <phy_rx_func+0xbd0>
							{
								RxMediaState = WAITINGABAB;
80003fdc:	30 09       	mov	r9,0
80003fde:	fe f8 02 f6 	ld.w	r8,pc[758]
80003fe2:	91 09       	st.w	r8[0x0],r9
80003fe4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003fe8:	fe f9 02 f4 	ld.w	r9,pc[756]
80003fec:	72 08       	ld.w	r8,r9[0x0]
80003fee:	20 18       	sub	r8,1
80003ff0:	93 08       	st.w	r9[0x0],r8
80003ff2:	c0 71       	brne	80004000 <phy_rx_func+0xbe8>
							RxMediaState = WAITINGABAB;
80003ff4:	30 09       	mov	r9,0
80003ff6:	fe f8 02 de 	ld.w	r8,pc[734]
80003ffa:	91 09       	st.w	r8[0x0],r9
80003ffc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//7
80004000:	fe f8 02 f4 	ld.w	r8,pc[756]
80004004:	fe f9 02 cc 	ld.w	r9,pc[716]
80004008:	72 0a       	ld.w	r10,r9[0x0]
8000400a:	70 09       	ld.w	r9,r8[0x0]
8000400c:	ef 3b 00 0c 	ld.ub	r11,r7[12]
80004010:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80004014:	70 09       	ld.w	r9,r8[0x0]
80004016:	2f f9       	sub	r9,-1
80004018:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000401a:	e0 49 01 ff 	cp.w	r9,511
8000401e:	e0 88 00 16 	brls	8000404a <phy_rx_func+0xc32>
						{
							RxAMBE_IsFillingNext8 = 0;
80004022:	30 09       	mov	r9,0
80004024:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80004026:	fe f7 02 aa 	ld.w	r7,pc[682]
8000402a:	6e 0c       	ld.w	r12,r7[0x0]
8000402c:	f0 1f 00 b4 	mcall	800042fc <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80004030:	fe f8 02 98 	ld.w	r8,pc[664]
80004034:	70 0c       	ld.w	r12,r8[0x0]
80004036:	f0 1f 00 9f 	mcall	800042b0 <phy_rx_func+0xe98>
8000403a:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
8000403c:	c0 71       	brne	8000404a <phy_rx_func+0xc32>
							{
								RxMediaState = WAITINGABAB;
8000403e:	30 09       	mov	r9,0
80004040:	fe f8 02 94 	ld.w	r8,pc[660]
80004044:	91 09       	st.w	r8[0x0],r9
80004046:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
8000404a:	fe f9 02 92 	ld.w	r9,pc[658]
8000404e:	72 08       	ld.w	r8,r9[0x0]
80004050:	20 18       	sub	r8,1
80004052:	93 08       	st.w	r9[0x0],r8
80004054:	c0 71       	brne	80004062 <phy_rx_func+0xc4a>
							RxMediaState = WAITINGABAB;
80004056:	30 09       	mov	r9,0
80004058:	fe f8 02 7c 	ld.w	r8,pc[636]
8000405c:	91 09       	st.w	r8[0x0],r9
8000405e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
						if ((RxBytesWaiting -= 1) <= 0){
80004062:	20 18       	sub	r8,1
80004064:	fe f9 02 78 	ld.w	r9,pc[632]
80004068:	93 08       	st.w	r9[0x0],r8
8000406a:	58 08       	cp.w	r8,0
8000406c:	e0 81 01 13 	brne	80004292 <phy_rx_func+0xe7a>
							
							//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
							//or discard it to reduce payload size.
							
							RxMediaState = WAITINGABAB;
80004070:	30 09       	mov	r9,0
80004072:	fe f8 02 62 	ld.w	r8,pc[610]
80004076:	91 09       	st.w	r8[0x0],r9
80004078:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
					}
					else if ((Item_ID == 0x04)  ||  (Item_ID == 0x03))//Unknown type data directly back hair
8000407c:	fe f8 02 70 	ld.w	r8,pc[624]
80004080:	11 89       	ld.ub	r9,r8[0x0]
80004082:	30 48       	mov	r8,4
80004084:	f0 09 18 00 	cp.b	r9,r8
80004088:	c0 80       	breq	80004098 <phy_rx_func+0xc80>
8000408a:	fe f8 02 62 	ld.w	r8,pc[610]
8000408e:	11 89       	ld.ub	r9,r8[0x0]
80004090:	30 38       	mov	r8,3
80004092:	f0 09 18 00 	cp.b	r9,r8
80004096:	c1 41       	brne	800040be <phy_rx_func+0xca6>
					{
						AMBE_HT[0] = payload_rx_channel->dword[0];
80004098:	6e 29       	ld.w	r9,r7[0x8]
8000409a:	fe f8 02 7a 	ld.w	r8,pc[634]
8000409e:	91 09       	st.w	r8[0x0],r9
						AMBE_HT[1] = payload_rx_channel->dword[1];				
800040a0:	6e 39       	ld.w	r9,r7[0xc]
800040a2:	91 19       	st.w	r8[0x4],r9
						
						if ((RxBytesWaiting -= 8) <= 0)//Consider two cases 0xABCDC014 and 0xABCDC010
800040a4:	fe f9 02 38 	ld.w	r9,pc[568]
800040a8:	72 08       	ld.w	r8,r9[0x0]
800040aa:	20 88       	sub	r8,8
800040ac:	93 08       	st.w	r9[0x0],r8
800040ae:	e0 81 00 f2 	brne	80004292 <phy_rx_func+0xe7a>
						{
					
							RxBytesWaiting = 0;
800040b2:	93 08       	st.w	r9[0x0],r8
							RxMediaState = WAITINGABAB;
800040b4:	fe f9 02 20 	ld.w	r9,pc[544]
800040b8:	93 08       	st.w	r9[0x0],r8
800040ba:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
						}
						break;

					}
					else if (Item_ID == Soft_Decision_Value)
800040be:	fe f8 02 2e 	ld.w	r8,pc[558]
800040c2:	11 89       	ld.ub	r9,r8[0x0]
800040c4:	31 38       	mov	r8,19
800040c6:	f0 09 18 00 	cp.b	r9,r8
800040ca:	e0 81 00 9c 	brne	80004202 <phy_rx_func+0xdea>
					{							
						if (SDV_Index == 12)
800040ce:	fe f8 02 62 	ld.w	r8,pc[610]
800040d2:	11 88       	ld.ub	r8,r8[0x0]
800040d4:	30 c9       	mov	r9,12
800040d6:	f2 08 18 00 	cp.b	r8,r9
800040da:	e0 81 00 7b 	brne	800041d0 <phy_rx_func+0xdb8>
						{
							Soft_Decision_Data[SDV_Index]= payload_rx_channel->word[0];
800040de:	8e 49       	ld.sh	r9,r7[0x8]
800040e0:	fe f8 02 54 	ld.w	r8,pc[596]
800040e4:	f1 59 00 18 	st.h	r8[24],r9
							
							SDV_Index = 0;
800040e8:	30 09       	mov	r9,0
800040ea:	fe f8 02 46 	ld.w	r8,pc[582]
800040ee:	b0 89       	st.b	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
800040f0:	ef 39 00 0d 	ld.ub	r9,r7[13]
800040f4:	3f 38       	mov	r8,-13
800040f6:	f0 09 18 00 	cp.b	r9,r8
800040fa:	c6 61       	brne	800041c6 <phy_rx_func+0xdae>
							
							SDV_Index = 0;
								
							if (payload_rx_channel->byte[5] == Pre_Voice_Decoder_Data )//0xF3
							{
									Item_ID = Pre_Voice_Decoder_Data;
800040fc:	10 99       	mov	r9,r8
800040fe:	4f c8       	lddpc	r8,800042ec <phy_rx_func+0xed4>
80004100:	b0 89       	st.b	r8[0x0],r9
									RxBytesWaiting = (payload_rx_channel->byte[4] & 0x7F);//Test calculations are correct; 8
80004102:	ef 39 00 0c 	ld.ub	r9,r7[12]
80004106:	f3 d9 c0 07 	bfextu	r9,r9,0x0,0x7
8000410a:	4f 58       	lddpc	r8,800042dc <phy_rx_func+0xec4>
8000410c:	91 09       	st.w	r8[0x0],r9
									AMBE_rx_flag = 1;//本地作为AMBE数据的解密方
8000410e:	30 19       	mov	r9,1
80004110:	fe f8 02 0c 	ld.w	r8,pc[524]
80004114:	b0 89       	st.b	r8[0x0],r9
		
									AMBEBurst_rawdata[0] = payload_rx_channel->word[3];//用于解密的中间数据变量
80004116:	8e 79       	ld.sh	r9,r7[0xe]
80004118:	fe f8 02 14 	ld.w	r8,pc[532]
8000411c:	b0 09       	st.h	r8[0x0],r9
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//1
8000411e:	4f 68       	lddpc	r8,800042f4 <phy_rx_func+0xedc>
80004120:	4e c9       	lddpc	r9,800042d0 <phy_rx_func+0xeb8>
80004122:	72 0a       	ld.w	r10,r9[0x0]
80004124:	70 09       	ld.w	r9,r8[0x0]
80004126:	ef 3b 00 0e 	ld.ub	r11,r7[14]
8000412a:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
8000412e:	70 09       	ld.w	r9,r8[0x0]
80004130:	2f f9       	sub	r9,-1
80004132:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80004134:	e0 49 01 ff 	cp.w	r9,511
80004138:	e0 88 00 13 	brls	8000415e <phy_rx_func+0xd46>
									{
										RxAMBE_IsFillingNext8 = 0;
8000413c:	30 09       	mov	r9,0
8000413e:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
80004140:	4e 46       	lddpc	r6,800042d0 <phy_rx_func+0xeb8>
80004142:	6c 0c       	ld.w	r12,r6[0x0]
80004144:	f0 1f 00 6e 	mcall	800042fc <phy_rx_func+0xee4>
										AMBE_payload_ptr = get_payload_idle_isr();
80004148:	4e 08       	lddpc	r8,800042c8 <phy_rx_func+0xeb0>
8000414a:	70 0c       	ld.w	r12,r8[0x0]
8000414c:	f0 1f 00 59 	mcall	800042b0 <phy_rx_func+0xe98>
80004150:	8d 0c       	st.w	r6[0x0],r12
										if(NULL == AMBE_payload_ptr)
80004152:	c0 61       	brne	8000415e <phy_rx_func+0xd46>
										{
											RxMediaState = WAITINGABAB;
80004154:	30 09       	mov	r9,0
80004156:	4e 08       	lddpc	r8,800042d4 <phy_rx_func+0xebc>
80004158:	91 09       	st.w	r8[0x0],r9
8000415a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
8000415e:	4e 09       	lddpc	r9,800042dc <phy_rx_func+0xec4>
80004160:	72 08       	ld.w	r8,r9[0x0]
80004162:	20 18       	sub	r8,1
80004164:	93 08       	st.w	r9[0x0],r8
80004166:	c0 61       	brne	80004172 <phy_rx_func+0xd5a>
										RxMediaState = WAITINGABAB;
80004168:	30 09       	mov	r9,0
8000416a:	4d b8       	lddpc	r8,800042d4 <phy_rx_func+0xebc>
8000416c:	91 09       	st.w	r8[0x0],r9
8000416e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//2
80004172:	4e 18       	lddpc	r8,800042f4 <phy_rx_func+0xedc>
80004174:	4d 79       	lddpc	r9,800042d0 <phy_rx_func+0xeb8>
80004176:	72 0a       	ld.w	r10,r9[0x0]
80004178:	70 09       	ld.w	r9,r8[0x0]
8000417a:	ef 3b 00 0f 	ld.ub	r11,r7[15]
8000417e:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
80004182:	70 09       	ld.w	r9,r8[0x0]
80004184:	2f f9       	sub	r9,-1
80004186:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80004188:	e0 49 01 ff 	cp.w	r9,511
8000418c:	e0 88 00 13 	brls	800041b2 <phy_rx_func+0xd9a>
									{
										RxAMBE_IsFillingNext8 = 0;
80004190:	30 09       	mov	r9,0
80004192:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
80004194:	4c f7       	lddpc	r7,800042d0 <phy_rx_func+0xeb8>
80004196:	6e 0c       	ld.w	r12,r7[0x0]
80004198:	f0 1f 00 59 	mcall	800042fc <phy_rx_func+0xee4>
										AMBE_payload_ptr = get_payload_idle_isr();
8000419c:	4c b8       	lddpc	r8,800042c8 <phy_rx_func+0xeb0>
8000419e:	70 0c       	ld.w	r12,r8[0x0]
800041a0:	f0 1f 00 44 	mcall	800042b0 <phy_rx_func+0xe98>
800041a4:	8f 0c       	st.w	r7[0x0],r12
										if(NULL == AMBE_payload_ptr)
800041a6:	c0 61       	brne	800041b2 <phy_rx_func+0xd9a>
										{
											RxMediaState = WAITINGABAB;
800041a8:	30 09       	mov	r9,0
800041aa:	4c b8       	lddpc	r8,800042d4 <phy_rx_func+0xebc>
800041ac:	91 09       	st.w	r8[0x0],r9
800041ae:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
800041b2:	4c b9       	lddpc	r9,800042dc <phy_rx_func+0xec4>
800041b4:	72 08       	ld.w	r8,r9[0x0]
800041b6:	20 18       	sub	r8,1
800041b8:	93 08       	st.w	r9[0x0],r8
800041ba:	c6 c1       	brne	80004292 <phy_rx_func+0xe7a>
										RxMediaState = WAITINGABAB;
800041bc:	30 09       	mov	r9,0
800041be:	4c 68       	lddpc	r8,800042d4 <phy_rx_func+0xebc>
800041c0:	91 09       	st.w	r8[0x0],r9
800041c2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
							}
							else
							RxMediaState = WAITINGABAB;
800041c6:	30 09       	mov	r9,0
800041c8:	4c 38       	lddpc	r8,800042d4 <phy_rx_func+0xebc>
800041ca:	91 09       	st.w	r8[0x0],r9
800041cc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
						}
						else
						{
									
							Soft_Decision_Data[SDV_Index]	  = payload_rx_channel->word[0];
800041d0:	8e 4a       	ld.sh	r10,r7[0x8]
800041d2:	4d 99       	lddpc	r9,80004334 <phy_rx_func+0xf1c>
800041d4:	f2 08 0a 1a 	st.h	r9[r8<<0x1],r10
							Soft_Decision_Data[SDV_Index+1]	  = payload_rx_channel->word[1];
800041d8:	4d 6a       	lddpc	r10,80004330 <phy_rx_func+0xf18>
800041da:	15 88       	ld.ub	r8,r10[0x0]
800041dc:	f0 cb ff ff 	sub	r11,r8,-1
800041e0:	8e 5c       	ld.sh	r12,r7[0xa]
800041e2:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+2]	  = payload_rx_channel->word[2];
800041e6:	f0 cb ff fe 	sub	r11,r8,-2
800041ea:	8e 6c       	ld.sh	r12,r7[0xc]
800041ec:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+3]	  = payload_rx_channel->word[3];
800041f0:	f0 cb ff fd 	sub	r11,r8,-3
800041f4:	8e 7c       	ld.sh	r12,r7[0xe]
800041f6:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							SDV_Index +=4;
800041fa:	2f c8       	sub	r8,-4
800041fc:	b4 88       	st.b	r10[0x0],r8
800041fe:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					
					else
					{
						
						RxMediaState  = WAITINGABAB;
80004202:	30 09       	mov	r9,0
80004204:	4b 48       	lddpc	r8,800042d4 <phy_rx_func+0xebc>
80004206:	91 09       	st.w	r8[0x0],r9
80004208:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
		break;//End of READING_AMBE_MEDIA.

        case READING_AMBE_AUX:
			
				Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[0];
8000420c:	4c 08       	lddpc	r8,8000430c <phy_rx_func+0xef4>
8000420e:	70 09       	ld.w	r9,r8[0x0]
80004210:	8e 4b       	ld.sh	r11,r7[0x8]
80004212:	4c 0a       	lddpc	r10,80004310 <phy_rx_func+0xef8>
80004214:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
				RxData_IsFillingNext16 += 1;
80004218:	2f f9       	sub	r9,-1
8000421a:	91 09       	st.w	r8[0x0],r9
			
				if ((Item_Length -= 2) <= 0)
8000421c:	4b 58       	lddpc	r8,800042f0 <phy_rx_func+0xed8>
8000421e:	70 09       	ld.w	r9,r8[0x0]
80004220:	20 29       	sub	r9,2
80004222:	91 09       	st.w	r8[0x0],r9
80004224:	70 08       	ld.w	r8,r8[0x0]
80004226:	58 08       	cp.w	r8,0
80004228:	c2 f1       	brne	80004286 <phy_rx_func+0xe6e>
				{
					RxData_IsFillingNext16 = 0;
8000422a:	30 09       	mov	r9,0
8000422c:	4b 88       	lddpc	r8,8000430c <phy_rx_func+0xef4>
8000422e:	91 09       	st.w	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80004230:	8e 59       	ld.sh	r9,r7[0xa]
80004232:	fe 78 82 12 	mov	r8,-32238
80004236:	f0 09 19 00 	cp.h	r9,r8
8000423a:	c2 11       	brne	8000427c <phy_rx_func+0xe64>
					{
						//Item_ID = Vocoder_Bit_Stream_Parameter;
						//Vocoder Bits Stream Parameter
						//Its value ranges from 1 to 18 for one voice superframe contains 6 voice bursts
						// and each burst contains 3 VFs.
						VF_SN = (payload_rx_channel->byte[5] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
8000423c:	ef 3c 00 0d 	ld.ub	r12,r7[13]
80004240:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
80004244:	4a f8       	lddpc	r8,80004300 <phy_rx_func+0xee8>
80004246:	b0 8c       	st.b	r8[0x0],r12
							
						VBSP_data[0] = payload_rx_channel->word[1];
80004248:	8e 59       	ld.sh	r9,r7[0xa]
8000424a:	4a f8       	lddpc	r8,80004304 <phy_rx_func+0xeec>
8000424c:	b0 09       	st.h	r8[0x0],r9
						VBSP_data[1] = payload_rx_channel->word[2];
8000424e:	8e 69       	ld.sh	r9,r7[0xc]
80004250:	b0 19       	st.h	r8[0x2],r9
							
						m_RxBurstType = CalculateBurst(VF_SN);
80004252:	f0 1f 00 2e 	mcall	80004308 <phy_rx_func+0xef0>
80004256:	4a 18       	lddpc	r8,800042d8 <phy_rx_func+0xec0>
80004258:	91 0c       	st.w	r8[0x0],r12
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
8000425a:	ef 39 00 0f 	ld.ub	r9,r7[15]
8000425e:	31 38       	mov	r8,19
80004260:	f0 09 18 00 	cp.b	r9,r8
80004264:	c0 71       	brne	80004272 <phy_rx_func+0xe5a>
							
						m_RxBurstType = CalculateBurst(VF_SN);
						
						if (payload_rx_channel->byte[7] == Soft_Decision_Value)//0x13
						{
							Item_ID = Soft_Decision_Value;	
80004266:	10 99       	mov	r9,r8
80004268:	4a 18       	lddpc	r8,800042ec <phy_rx_func+0xed4>
8000426a:	b0 89       	st.b	r8[0x0],r9
							RxBytesWaiting = ((payload_rx_channel->dword[1] & 0x00007F00) >>24);//Test calculations are correct; 26
8000426c:	30 09       	mov	r9,0
8000426e:	49 c8       	lddpc	r8,800042dc <phy_rx_func+0xec4>
80004270:	91 09       	st.w	r8[0x0],r9
						else
						{//error
								RxMediaState = WAITINGABAB;//Jump
						}
							
						RxMediaState = READING_AMBE_MEDIA;//Jump
80004272:	30 49       	mov	r9,4
80004274:	49 88       	lddpc	r8,800042d4 <phy_rx_func+0xebc>
80004276:	91 09       	st.w	r8[0x0],r9
80004278:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					else
					{
						RxMediaState = WAITINGABAB;//Jump
8000427c:	30 09       	mov	r9,0
8000427e:	49 68       	lddpc	r8,800042d4 <phy_rx_func+0xebc>
80004280:	91 09       	st.w	r8[0x0],r9
80004282:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}

				}
				else
				{//测试看看是几个字节数据
					logFromISR("\n\r Radio Internal parameter length error \n\r");
80004286:	4a dc       	lddpc	r12,80004338 <phy_rx_func+0xf20>
80004288:	f0 1f 00 18 	mcall	800042e8 <phy_rx_func+0xed0>
					RxMediaState = WAITINGABAB;//Jump
8000428c:	30 09       	mov	r9,0
8000428e:	49 28       	lddpc	r8,800042d4 <phy_rx_func+0xebc>
80004290:	91 09       	st.w	r8[0x0],r9
80004292:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80004296:	00 00       	add	r0,r0
80004298:	00 00       	add	r0,r0
8000429a:	0a bc       	st.h	r5++,r12
8000429c:	00 00       	add	r0,r0
8000429e:	0a d4       	st.w	--r5,r4
800042a0:	00 00       	add	r0,r0
800042a2:	0a b4       	st.h	r5++,r4
800042a4:	00 00       	add	r0,r0
800042a6:	0a 96       	mov	r6,r5
800042a8:	00 00       	add	r0,r0
800042aa:	0a 84       	andn	r4,r5
800042ac:	00 00       	add	r0,r0
800042ae:	0a ac       	st.w	r5++,r12
800042b0:	80 00       	ld.sh	r0,r0[0x0]
800042b2:	32 98       	mov	r8,41
800042b4:	00 00       	add	r0,r0
800042b6:	0a a4       	st.w	r5++,r4
800042b8:	80 00       	ld.sh	r0,r0[0x0]
800042ba:	31 b0       	mov	r0,27
800042bc:	00 00       	add	r0,r0
800042be:	0a b8       	st.h	r5++,r8
800042c0:	80 00       	ld.sh	r0,r0[0x0]
800042c2:	31 e4       	mov	r4,30
800042c4:	00 00       	add	r0,r0
800042c6:	0a 95       	mov	r5,r5
800042c8:	00 00       	add	r0,r0
800042ca:	0a b0       	st.h	r5++,r0
800042cc:	00 00       	add	r0,r0
800042ce:	0a c0       	st.b	r5++,r0
800042d0:	00 00       	add	r0,r0
800042d2:	0a 98       	mov	r8,r5
800042d4:	00 00       	add	r0,r0
800042d6:	0a e0       	st.h	--r5,r0
800042d8:	00 00       	add	r0,r0
800042da:	0a c8       	st.b	r5++,r8
800042dc:	00 00       	add	r0,r0
800042de:	0a 80       	andn	r0,r5
800042e0:	00 00       	add	r0,r0
800042e2:	0a 57       	eor	r7,r5
800042e4:	80 00       	ld.sh	r0,r0[0x0]
800042e6:	df d8       	*unknown*
800042e8:	80 00       	ld.sh	r0,r0[0x0]
800042ea:	79 e8       	ld.w	r8,r12[0x78]
800042ec:	00 00       	add	r0,r0
800042ee:	0a 94       	mov	r4,r5
800042f0:	00 00       	add	r0,r0
800042f2:	0a ec       	st.h	--r5,r12
800042f4:	00 00       	add	r0,r0
800042f6:	0a cc       	st.b	r5++,r12
800042f8:	80 00       	ld.sh	r0,r0[0x0]
800042fa:	82 4e       	ld.sh	lr,r1[0x8]
800042fc:	80 00       	ld.sh	r0,r0[0x0]
800042fe:	31 cc       	mov	r12,28
80004300:	00 00       	add	r0,r0
80004302:	0a 52       	eor	r2,r5
80004304:	00 00       	add	r0,r0
80004306:	21 98       	sub	r8,25
80004308:	80 00       	ld.sh	r0,r0[0x0]
8000430a:	31 80       	mov	r0,24
8000430c:	00 00       	add	r0,r0
8000430e:	0a 88       	andn	r8,r5
80004310:	00 00       	add	r0,r0
80004312:	20 9c       	sub	r12,9
80004314:	00 00       	add	r0,r0
80004316:	0a 8c       	andn	r12,r5
80004318:	00 00       	add	r0,r0
8000431a:	0a 53       	eor	r3,r5
8000431c:	00 00       	add	r0,r0
8000431e:	0a 51       	eor	r1,r5
80004320:	00 00       	add	r0,r0
80004322:	0a e4       	st.h	--r5,r4
80004324:	00 00       	add	r0,r0
80004326:	0a a0       	st.w	r5++,r0
80004328:	00 00       	add	r0,r0
8000432a:	0a 68       	and	r8,r5
8000432c:	00 00       	add	r0,r0
8000432e:	20 94       	sub	r4,9
80004330:	00 00       	add	r0,r0
80004332:	0a d8       	st.w	--r5,r8
80004334:	00 00       	add	r0,r0
80004336:	21 9c       	sub	r12,25
80004338:	80 00       	ld.sh	r0,r0[0x0]
8000433a:	df f0       	acall	0xff

8000433c <pdca_int_handler>:
    void (*phy_rx_exec)(void *)--callback function for receive SSC data 
Called By: interrupt
*/
__attribute__((__interrupt__))
static void pdca_int_handler(void)
{
8000433c:	d4 01       	pushm	lr
    
	static portBASE_TYPE xHigherPriorityTaskWoken;
	xHigherPriorityTaskWoken = pdFALSE;
8000433e:	30 09       	mov	r9,0
80004340:	49 b8       	lddpc	r8,800043ac <pdca_int_handler+0x70>
80004342:	91 09       	st.w	r8[0x0],r9
	
	static U32 count=0;
	//intStartCount = Get_system_register(AVR32_COUNT);
	
	count++;
80004344:	49 b8       	lddpc	r8,800043b0 <pdca_int_handler+0x74>
80004346:	70 09       	ld.w	r9,r8[0x0]
80004348:	2f f9       	sub	r9,-1
8000434a:	91 09       	st.w	r8[0x0],r9
	/*Toggle Index*/
    BufferIndex ^= 0x01;
8000434c:	49 a8       	lddpc	r8,800043b4 <pdca_int_handler+0x78>
8000434e:	11 89       	ld.ub	r9,r8[0x0]
80004350:	ec 19 00 01 	eorl	r9,0x1
80004354:	b0 89       	st.b	r8[0x0],r9
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);
80004356:	11 89       	ld.ub	r9,r8[0x0]
80004358:	a5 69       	lsl	r9,0x4
8000435a:	2f c9       	sub	r9,-4
8000435c:	49 7a       	lddpc	r10,800043b8 <pdca_int_handler+0x7c>
8000435e:	14 09       	add	r9,r10
	count++;
	/*Toggle Index*/
    BufferIndex ^= 0x01;
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
80004360:	fe 7a 00 40 	mov	r10,-65472
80004364:	95 39       	st.w	r10[0xc],r9
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80004366:	30 39       	mov	r9,3
80004368:	95 49       	st.w	r10[0x10],r9

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);
8000436a:	11 8a       	ld.ub	r10,r8[0x0]
8000436c:	a5 6a       	lsl	r10,0x4
8000436e:	2f ca       	sub	r10,-4
80004370:	49 38       	lddpc	r8,800043bc <pdca_int_handler+0x80>
80004372:	10 0a       	add	r10,r8
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
80004374:	fe 78 00 00 	mov	r8,-65536
80004378:	91 3a       	st.w	r8[0xc],r10
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
8000437a:	91 49       	st.w	r8[0x10],r9
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr;
8000437c:	70 b8       	ld.w	r8,r8[0x2c]
	
	/*receive SSC data*/
    if(phy_rx_exec != NULL)phy_rx_exec((void *)&RxBuffer[BufferIndex]);
8000437e:	49 18       	lddpc	r8,800043c0 <pdca_int_handler+0x84>
80004380:	70 08       	ld.w	r8,r8[0x0]
80004382:	58 08       	cp.w	r8,0
80004384:	c0 70       	breq	80004392 <pdca_int_handler+0x56>
80004386:	48 c9       	lddpc	r9,800043b4 <pdca_int_handler+0x78>
80004388:	13 89       	ld.ub	r9,r9[0x0]
8000438a:	a5 69       	lsl	r9,0x4
8000438c:	48 cc       	lddpc	r12,800043bc <pdca_int_handler+0x80>
8000438e:	12 0c       	add	r12,r9
80004390:	5d 18       	icall	r8

    /*transmit SSC data*/

	if(phy_tx_exec != NULL)phy_tx_exec((void *)&TxBuffer[BufferIndex]);//phy_tx_func, phy_rx_func
80004392:	48 d8       	lddpc	r8,800043c4 <pdca_int_handler+0x88>
80004394:	70 08       	ld.w	r8,r8[0x0]
80004396:	58 08       	cp.w	r8,0
80004398:	c0 70       	breq	800043a6 <pdca_int_handler+0x6a>
8000439a:	48 79       	lddpc	r9,800043b4 <pdca_int_handler+0x78>
8000439c:	13 89       	ld.ub	r9,r9[0x0]
8000439e:	a5 69       	lsl	r9,0x4
800043a0:	48 6c       	lddpc	r12,800043b8 <pdca_int_handler+0x7c>
800043a2:	12 0c       	add	r12,r9
800043a4:	5d 18       	icall	r8

	
	//intDuration = Get_system_register(AVR32_COUNT) - intStartCount;
	
	
}/*End of pdca_int_handler.*/
800043a6:	d4 02       	popm	lr
800043a8:	d6 03       	rete
800043aa:	00 00       	add	r0,r0
800043ac:	00 00       	add	r0,r0
800043ae:	0a f4       	st.b	--r5,r4
800043b0:	00 00       	add	r0,r0
800043b2:	0a f8       	st.b	--r5,r8
800043b4:	00 00       	add	r0,r0
800043b6:	53 bc       	stdsp	sp[0xec],r12
800043b8:	00 00       	add	r0,r0
800043ba:	53 e4       	stdsp	sp[0xf8],r4
800043bc:	00 00       	add	r0,r0
800043be:	53 c4       	stdsp	sp[0xf0],r4
800043c0:	00 00       	add	r0,r0
800043c2:	0a f0       	st.b	--r5,r0
800043c4:	00 00       	add	r0,r0
800043c6:	0a fc       	st.b	--r5,r12

800043c8 <local_start_SSC>:
void local_start_SSC(void)
{
    /*Assign GPIO to SSC.
    gpio_enable_module
    gpio_enable_module_pin*/
    AVR32_GPIO.port[1].pmr0c = 0x00000DC0;
800043c8:	fe 78 10 00 	mov	r8,-61440
800043cc:	e0 69 0d c0 	mov	r9,3520
800043d0:	f1 49 01 18 	st.w	r8[280],r9
    AVR32_GPIO.port[1].pmr1c = 0x00000DC0;
800043d4:	f1 49 01 28 	st.w	r8[296],r9
    AVR32_GPIO.port[1].gperc = 0x00000DC0;
800043d8:	f1 49 01 08 	st.w	r8[264],r9

    /*Software reset SSC*/
    (&AVR32_SSC)->cr = AVR32_SSC_CR_SWRST_MASK;
800043dc:	fe 78 34 00 	mov	r8,-52224
800043e0:	e0 69 80 00 	mov	r9,32768
800043e4:	91 09       	st.w	r8[0x0],r9
    (&AVR32_SSC)->cmr 
800043e6:	30 09       	mov	r9,0
800043e8:	91 19       	st.w	r8[0x4],r9
                     = AVR32_SSC_CMR_DIV_NOT_ACTIVE << AVR32_SSC_CMR_DIV_OFFSET;

    /*For Slave*/
    (&AVR32_SSC)->tcmr =
800043ea:	e0 69 04 21 	mov	r9,1057
800043ee:	ea 19 3f 20 	orh	r9,0x3f20
800043f2:	91 69       	st.w	r8[0x18],r9
	      32								<< AVR32_SSC_TCMR_STTDLY_OFFSET	|
	      63								<< AVR32_SSC_TCMR_PERIOD_OFFSET;


    /*For Slave*/
    (&AVR32_SSC)->tfmr = 
800043f4:	e0 69 02 9f 	mov	r9,671
800043f8:	ea 19 01 00 	orh	r9,0x100
800043fc:	91 79       	st.w	r8[0x1c],r9
	     0									<< AVR32_SSC_TFMR_FSDEN_OFFSET	|
	     1									<< AVR32_SSC_TFMR_FSEDGE_OFFSET;

	/*For Slave*/

	(&AVR32_SSC)->rcmr = 
800043fe:	e0 6a 04 02 	mov	r10,1026
80004402:	ea 1a 3f 20 	orh	r10,0x3f20
80004406:	91 4a       	st.w	r8[0x10],r10
	     0									<< AVR32_SSC_RCMR_STOP_OFFSET	|
	     32									<< AVR32_SSC_RCMR_STTDLY_OFFSET	|
	     63									<< AVR32_SSC_RCMR_PERIOD_OFFSET;

	/*For Slave*/
	(&AVR32_SSC)->rfmr = 
80004408:	91 59       	st.w	r8[0x14],r9
	    1									<< AVR32_SSC_RFMR_MSBF_OFFSET	|
	    2									<< AVR32_SSC_RFMR_DATNB_OFFSET	|
	    0									<< AVR32_SSC_RFMR_FSLEN_OFFSET	|
	    AVR32_SSC_RFMR_FSOS_INPUT_ONLY		<< AVR32_SSC_RFMR_FSOS_OFFSET	|
	    1									<< AVR32_SSC_RFMR_FSEDGE_OFFSET;
}/*End of local_start_SSC.*/
8000440a:	5e fc       	retal	r12

8000440c <local_start_PDC>:
Function: local_start_PDC
Description: none
Called By: void ssc_init(void) -- ssc.c
*/
void local_start_PDC(void)
{
8000440c:	d4 01       	pushm	lr
    /*Toggle Index*/	
    BufferIndex = 1;
8000440e:	30 19       	mov	r9,1
80004410:	49 78       	lddpc	r8,8000446c <local_start_PDC+0x60>
80004412:	b0 89       	st.b	r8[0x0],r9
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
80004414:	fe 78 00 00 	mov	r8,-65536
80004418:	30 7b       	mov	r11,7
8000441a:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
8000441c:	70 b9       	ld.w	r9,r8[0x2c]
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
8000441e:	49 59       	lddpc	r9,80004470 <local_start_PDC+0x64>
80004420:	f2 ca ff fc 	sub	r10,r9,-4
    BufferIndex = 1;
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
80004424:	91 0a       	st.w	r8[0x0],r10
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
80004426:	30 3a       	mov	r10,3
80004428:	91 2a       	st.w	r8[0x8],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
8000442a:	30 1c       	mov	r12,1
8000442c:	91 1c       	st.w	r8[0x4],r12
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
8000442e:	2e c9       	sub	r9,-20
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
80004430:	91 39       	st.w	r8[0xc],r9
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80004432:	91 4a       	st.w	r8[0x10],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80004434:	30 2c       	mov	r12,2
80004436:	91 6c       	st.w	r8[0x18],r12

	TxBuffer[0].xnl_channel.dword = XNL_IDLE;
80004438:	48 f9       	lddpc	r9,80004474 <local_start_PDC+0x68>
8000443a:	e0 68 5a 5a 	mov	r8,23130
8000443e:	ea 18 ab cd 	orh	r8,0xabcd
80004442:	93 18       	st.w	r9[0x4],r8
	TxBuffer[0].payload_channel.dword[0] = PAYLOADIDLE0;
80004444:	93 28       	st.w	r9[0x8],r8
	TxBuffer[0].payload_channel.dword[1] = PAYLOADIDLE1;
80004446:	30 0e       	mov	lr,0
80004448:	93 3e       	st.w	r9[0xc],lr
	TxBuffer[1].xnl_channel.dword = XNL_IDLE;
8000444a:	93 58       	st.w	r9[0x14],r8
	TxBuffer[1].payload_channel.dword[0] = PAYLOADIDLE0;
8000444c:	93 68       	st.w	r9[0x18],r8
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;
8000444e:	93 7e       	st.w	r9[0x1c],lr

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
80004450:	fe 78 00 40 	mov	r8,-65472
80004454:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
80004456:	70 be       	ld.w	lr,r8[0x2c]
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
80004458:	f2 ce ff fc 	sub	lr,r9,-4
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
8000445c:	91 0e       	st.w	r8[0x0],lr
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
8000445e:	91 2a       	st.w	r8[0x8],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
80004460:	91 1b       	st.w	r8[0x4],r11
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
80004462:	2e c9       	sub	r9,-20
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
80004464:	91 39       	st.w	r8[0xc],r9
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80004466:	91 4a       	st.w	r8[0x10],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80004468:	91 6c       	st.w	r8[0x18],r12
}/*End of local_start_PDC.*/
8000446a:	d8 02       	popm	pc
8000446c:	00 00       	add	r0,r0
8000446e:	53 bc       	stdsp	sp[0xec],r12
80004470:	00 00       	add	r0,r0
80004472:	53 c4       	stdsp	sp[0xf0],r4
80004474:	00 00       	add	r0,r0
80004476:	53 e4       	stdsp	sp[0xf8],r4

80004478 <register_rx_tx_func>:
Description: register the rx function(callback function)
Called By: phy_init -- physical.c
*/
void register_rx_tx_func(void (*rx_exec)(void *),  void ( *tx_exec)(void *))
{
	 phy_rx_exec = rx_exec;
80004478:	48 38       	lddpc	r8,80004484 <register_rx_tx_func+0xc>
8000447a:	91 0c       	st.w	r8[0x0],r12
	 phy_tx_exec = tx_exec;//phy_tx_func, phy_rx_func
8000447c:	48 38       	lddpc	r8,80004488 <register_rx_tx_func+0x10>
8000447e:	91 0b       	st.w	r8[0x0],r11
	 
}/*End of register_tx_rx_func.*/
80004480:	5e fc       	retal	r12
80004482:	00 00       	add	r0,r0
80004484:	00 00       	add	r0,r0
80004486:	0a f0       	st.b	--r5,r0
80004488:	00 00       	add	r0,r0
8000448a:	0a fc       	st.b	--r5,r12

8000448c <ssc_init>:
    local_start_SSC -- ssc.c
    local_start_PDC -- ssc.c
Called By: phy_init -- physical.c
*/
void ssc_init(void)
{		
8000448c:	d4 01       	pushm	lr
    /*Set up PB01 to watch FS.*/
    AVR32_GPIO.port[1].oderc = 0x00000002;
8000448e:	fe 78 10 00 	mov	r8,-61440
80004492:	30 29       	mov	r9,2
80004494:	f1 49 01 48 	st.w	r8[328],r9
    AVR32_GPIO.port[1].gpers = 0x00000002;
80004498:	f1 49 01 04 	st.w	r8[260],r9
	
	Disable_global_interrupt();
8000449c:	d3 03       	ssrf	0x10
	
	INTC_register_interrupt (
8000449e:	30 3a       	mov	r10,3
800044a0:	36 0b       	mov	r11,96
800044a2:	49 4c       	lddpc	r12,800044f0 <ssc_init+0x64>
800044a4:	f0 1f 00 14 	mcall	800044f4 <ssc_init+0x68>
	&pdca_int_handler
	, AVR32_PDCA_IRQ_0 //PDCA_CHANNEL_SSCRX_EXAMPLE = 0
	, AVR32_INTC_INT3 //highest priority.
	);
	
	Enable_global_interrupt();
800044a8:	d5 03       	csrf	0x10
	
    /*Waits for radio to start making FSYNC.*/
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
800044aa:	fe 79 10 00 	mov	r9,-61440
800044ae:	f2 f8 01 60 	ld.w	r8,r9[352]
800044b2:	e2 18 00 02 	andl	r8,0x2,COH
800044b6:	cf c0       	breq	800044ae <ssc_init+0x22>
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
800044b8:	fe 79 10 00 	mov	r9,-61440
800044bc:	f2 f8 01 60 	ld.w	r8,r9[352]
800044c0:	e2 18 00 02 	andl	r8,0x2,COH
800044c4:	cf c1       	brne	800044bc <ssc_init+0x30>
			
	Disable_global_interrupt(); // resume to before
800044c6:	d3 03       	ssrf	0x10
				
    /*config the SSC*/
    local_start_SSC();
800044c8:	f0 1f 00 0c 	mcall	800044f8 <ssc_init+0x6c>

    /*config the PDCA*/
    local_start_PDC();
800044cc:	f0 1f 00 0c 	mcall	800044fc <ssc_init+0x70>
		
    /*Start the SSC Physical Layer.*/

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
800044d0:	fe 79 00 00 	mov	r9,-65536
800044d4:	30 18       	mov	r8,1
800044d6:	93 58       	st.w	r9[0x14],r8
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
800044d8:	fe 7a 00 40 	mov	r10,-65472
800044dc:	95 58       	st.w	r10[0x14],r8
    (&AVR32_SSC)->cr = AVR32_SSC_CR_RXEN_MASK | AVR32_SSC_CR_TXEN_MASK;
800044de:	e0 6b 01 01 	mov	r11,257
800044e2:	fe 7a 34 00 	mov	r10,-52224
800044e6:	95 0b       	st.w	r10[0x0],r11
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->ier = AVR32_PDCA_RCZ_MASK;
800044e8:	93 88       	st.w	r9[0x20],r8
															
	Enable_global_interrupt();
800044ea:	d5 03       	csrf	0x10
															
}/*End of ssc_init.*/
800044ec:	d8 02       	popm	pc
800044ee:	00 00       	add	r0,r0
800044f0:	80 00       	ld.sh	r0,r0[0x0]
800044f2:	43 3c       	lddsp	r12,sp[0xcc]
800044f4:	80 00       	ld.sh	r0,r0[0x0]
800044f6:	5c c4       	swap.bh	r4
800044f8:	80 00       	ld.sh	r0,r0[0x0]
800044fa:	43 c8       	lddsp	r8,sp[0xf0]
800044fc:	80 00       	ld.sh	r0,r0[0x0]
800044fe:	44 0c       	lddsp	r12,sp[0x100]

80004500 <xcmp_register_app_list>:
Calls: 
Called By: app_init -- app.c
*/
void xcmp_register_app_list(void * list)
{
	app_list = (app_exec_t *)list;
80004500:	48 28       	lddpc	r8,80004508 <xcmp_register_app_list+0x8>
80004502:	91 0c       	st.w	r8[0x0],r12
}
80004504:	5e fc       	retal	r12
80004506:	00 00       	add	r0,r0
80004508:	00 00       	add	r0,r0
8000450a:	54 04       	stdsp	sp[0x100],r4

8000450c <xcmp_tx>:
Calls:   
	xnl_tx -- xnl.c
Called By: ...
*/
static void xcmp_tx( xcmp_fragment_t * xcmp, U8 payload_len)
{
8000450c:	eb cd 40 80 	pushm	r7,lr
80004510:	fa cd 01 00 	sub	sp,sp,256
80004514:	16 97       	mov	r7,r11
	Length :xnl length + checksum
	= checksum + xnl header + xcmp opcode + xcmp payload
	= 0x02 + 0x0C + 0x02 + xcmp payload
	= 0x10 + xcmp payload
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | ( 0x10 + payload_len);
80004516:	16 98       	mov	r8,r11
80004518:	2f 08       	sub	r8,-16
8000451a:	af a8       	sbr	r8,0xe
8000451c:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE; 
8000451e:	3f f8       	mov	r8,-1
80004520:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG;
80004522:	30 b9       	mov	r9,11
80004524:	ba 29       	st.h	sp[0x4],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;	
80004526:	ba 38       	st.h	sp[0x6],r8
	xnl_frame.xnl_header.destination = DEFAULT_VALUE;
80004528:	ba 48       	st.h	sp[0x8],r8
	xnl_frame.xnl_header.source = DEFAULT_VALUE;	
8000452a:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
8000452c:	ba 68       	st.h	sp[0xc],r8
	
	/*insert xcmp frame data*/
	memcpy(&xnl_frame.xnl_payload.xnl_content_data_msg, xcmp, payload_len + 2);
8000452e:	f6 ca ff fe 	sub	r10,r11,-2
80004532:	18 9b       	mov	r11,r12
80004534:	fa cc ff f0 	sub	r12,sp,-16
80004538:	f0 1f 00 05 	mcall	8000454c <xcmp_tx+0x40>
	xnl_frame.xnl_header.payload_length = payload_len + 2;	
8000453c:	2f e7       	sub	r7,-2
8000453e:	ba 77       	st.h	sp[0xe],r7
	
	/* send xnl frame*/	
	xnl_tx(&xnl_frame);
80004540:	1a 9c       	mov	r12,sp
80004542:	f0 1f 00 04 	mcall	80004550 <xcmp_tx+0x44>
}
80004546:	2c 0d       	sub	sp,-256
80004548:	e3 cd 80 80 	ldm	sp++,r7,pc
8000454c:	80 00       	ld.sh	r0,r0[0x0]
8000454e:	81 06       	st.w	r0[0x0],r6
80004550:	80 00       	ld.sh	r0,r0[0x0]
80004552:	4b 18       	lddpc	r8,80004614 <xcmp_DeviceInitializationStatus_request+0x34>

80004554 <xcmp_data_session_req>:
Description: send data-session request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_data_session_req(void *message, U16 length, U8 dest)
{
80004554:	d4 21       	pushm	r4-r7,lr
80004556:	fa cd 00 d0 	sub	sp,sp,208
8000455a:	18 94       	mov	r4,r12
8000455c:	16 97       	mov	r7,r11
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
	
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
	
	if (length > 256)return -1;
8000455e:	e0 68 01 00 	mov	r8,256
80004562:	f0 0b 19 00 	cp.h	r11,r8
80004566:	e0 8b 00 36 	brhi	800045d2 <xcmp_data_session_req+0x7e>
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
	
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
8000456a:	fa c5 ff f8 	sub	r5,sp,-8
	//U8 SizeofAddress = Remote_Mototrbo_Address_Size;// 3;//可能会变化
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
8000456e:	e0 68 04 1d 	mov	r8,1053
80004572:	ba 38       	st.h	sp[0x6],r8
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
	
	if (length > 256)return -1;
	
	ptr->Function = Single_Data_Uint;
80004574:	30 18       	mov	r8,1
80004576:	aa 88       	st.b	r5[0x0],r8
	
	ptr->DataDefinition.Data_Protocol_Version = TMP_Ver_1_1;//0x20
80004578:	32 08       	mov	r8,32
8000457a:	aa 98       	st.b	r5[0x1],r8
	
	ptr->DataDefinition.Dest_Address.Remote_Address_Type = Remote_IPV4_Address;//0x02
8000457c:	30 28       	mov	r8,2
8000457e:	aa a8       	st.b	r5[0x2],r8
	
	ptr->DataDefinition.Dest_Address.Remote_Address_Size = Remote_IPV4_Address_Size;//0x04
80004580:	30 48       	mov	r8,4
80004582:	aa b8       	st.b	r5[0x3],r8
	
	unsigned int addr = 0x0C000000 | (dest & 0x00FFFFFF);
80004584:	ea 1a 0c 00 	orh	r10,0xc00
80004588:	50 0a       	stdsp	sp[0x0],r10
	memcpy(ptr->DataDefinition.Dest_Address.Remote_Address, &addr, Remote_IPV4_Address_Size);
8000458a:	30 4a       	mov	r10,4
8000458c:	1a 9b       	mov	r11,sp
8000458e:	fa cc ff f4 	sub	r12,sp,-12
80004592:	f0 1f 00 12 	mcall	800045d8 <xcmp_data_session_req+0x84>
	//ptr->DataDefinition.Dest_Address.Remote_Address[0] = 0x0C;//12
	//ptr->DataDefinition.Dest_Address.Remote_Address[1] = 0x00;//0
	//ptr->DataDefinition.Dest_Address.Remote_Address[2] = 0x00;//0
	//ptr->DataDefinition.Dest_Address.Remote_Address[3] = 0x02;//2
	
	ptr->DataDefinition.Dest_Address.Remote_Port_Com[0] = (Remote_Port >>8) & 0xFF;//4007
80004596:	30 f8       	mov	r8,15
80004598:	eb 68 00 08 	st.b	r5[8],r8
	ptr->DataDefinition.Dest_Address.Remote_Port_Com[1] = Remote_Port & 0xFF;//
8000459c:	3a 78       	mov	r8,-89
8000459e:	eb 68 00 09 	st.b	r5[9],r8
	
    
	ptr->DataPayload.Session_ID_Number = Session_ID;//0x00
800045a2:	30 08       	mov	r8,0
800045a4:	eb 68 00 0a 	st.b	r5[10],r8
	
	ptr->DataPayload.DataPayload_Length[0] =(length >> 8) & 0xFF ;//可能会变化
800045a8:	0e 9a       	mov	r10,r7
800045aa:	5c 7a       	castu.h	r10
800045ac:	f4 08 16 08 	lsr	r8,r10,0x8
800045b0:	eb 68 00 0b 	st.b	r5[11],r8
	ptr->DataPayload.DataPayload_Length[1] =length & 0xFF  ;//可能会变化
800045b4:	0e 96       	mov	r6,r7
800045b6:	eb 67 00 0c 	st.b	r5[12],r7
	
	memcpy(&(ptr->DataPayload.DataPayload[0]), message, length);
800045ba:	08 9b       	mov	r11,r4
800045bc:	fa cc ff eb 	sub	r12,sp,-21
800045c0:	f0 1f 00 06 	mcall	800045d8 <xcmp_data_session_req+0x84>
	
	xcmp_tx(&xcmp_farme, sizeof(DataSession_req_t) - (256 - length));
800045c4:	ee cb ff f3 	sub	r11,r7,-13
800045c8:	5c 5b       	castu.b	r11
800045ca:	fa cc ff fa 	sub	r12,sp,-6
800045ce:	f0 1f 00 04 	mcall	800045dc <xcmp_data_session_req+0x88>
}
800045d2:	2c cd       	sub	sp,-208
800045d4:	d8 22       	popm	r4-r7,pc
800045d6:	00 00       	add	r0,r0
800045d8:	80 00       	ld.sh	r0,r0[0x0]
800045da:	81 06       	st.w	r0[0x0],r6
800045dc:	80 00       	ld.sh	r0,r0[0x0]
800045de:	45 0c       	lddsp	r12,sp[0x140]

800045e0 <xcmp_DeviceInitializationStatus_request>:
Description: send device initialization status request
Calls: xcmp_tx
Called By:...
*/
void xcmp_DeviceInitializationStatus_request(void)
{
800045e0:	d4 01       	pushm	lr
800045e2:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
		
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_BRDCAST | DEVICE_INITIALIZATION_STATUS;
800045e6:	fe 78 b4 00 	mov	r8,-19456
800045ea:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	DeviceInitializationStatus_brdcst_t * ptr 
						 = (DeviceInitializationStatus_brdcst_t *)xcmp_farme.u8;
800045ec:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*xcmp version 8.1.0.5*///版本号未正确填写，纠正
	ptr->XCMPVersion[0] = 0x08;
800045f0:	30 89       	mov	r9,8
800045f2:	b0 89       	st.b	r8[0x0],r9
	ptr->XCMPVersion[1] = 0x01;
800045f4:	30 19       	mov	r9,1
800045f6:	b0 99       	st.b	r8[0x1],r9
	ptr->XCMPVersion[2] = 0x00;
800045f8:	30 09       	mov	r9,0
800045fa:	b0 a9       	st.b	r8[0x2],r9
	ptr->XCMPVersion[3] = 0x05;
800045fc:	30 5a       	mov	r10,5
800045fe:	b0 ba       	st.b	r8[0x3],r10
	/*
	0x00:
	This is the message that the device sends at power up or after a reset. It 
	will give the initial status and capabilities for the device.
	*/
	ptr->DeviceInitType = 0x00;
80004600:	b0 c9       	st.b	r8[0x4],r9
	types of devices may provide a set of services to the radio system, but do 
	not have the ability to be the master.
	
	0x07:OptionBoard,3rd party Option Board-based application.
	*/
	ptr->DeviceStatusInfo.DeviceType = 0x07;
80004602:	30 7a       	mov	r10,7
80004604:	b0 da       	st.b	r8[0x5],r10
	
	/*Power Up Success, Device has powered up with no errors*/
	ptr->DeviceStatusInfo.DeviceStatus[0] = 0x00;
80004606:	b0 e9       	st.b	r8[0x6],r9
	ptr->DeviceStatusInfo.DeviceStatus[1] = 0x00;
80004608:	b0 f9       	st.b	r8[0x7],r9
	
	/*
	This number is the size of the Device Descriptor data structure with a 
	maximum size not exceeding 255 bytes.
	*/
	ptr->DeviceStatusInfo.DeviceDescriptorSize = 0x00;
8000460a:	f1 69 00 08 	st.b	r8[8],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme
8000460e:	30 9b       	mov	r11,9
80004610:	fa cc ff fe 	sub	r12,sp,-2
80004614:	f0 1f 00 02 	mcall	8000461c <xcmp_DeviceInitializationStatus_request+0x3c>
		, sizeof(DeviceInitializationStatus_brdcst_t) - MAX_DEVICE_DESC_SIZE);
}
80004618:	2c dd       	sub	sp,-204
8000461a:	d8 02       	popm	pc
8000461c:	80 00       	ld.sh	r0,r0[0x0]
8000461e:	45 0c       	lddsp	r12,sp[0x140]

80004620 <xcmp_opcode_not_supported>:
Description: register the app list
Calls: xcmp_tx
Called By:...
*/
void xcmp_opcode_not_supported( void )
{
80004620:	d4 01       	pushm	lr
80004622:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REPLY;
80004626:	fe 78 80 00 	mov	r8,-32768
8000462a:	ba 18       	st.h	sp[0x2],r8
	
	/*The radio does not support this opcode.*/
	xcmp_farme.u8[0] = xcmp_Res_Opcode_Not_Supported;
8000462c:	30 38       	mov	r8,3
8000462e:	ba c8       	st.b	sp[0x4],r8
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, 1);
80004630:	30 1b       	mov	r11,1
80004632:	fa cc ff fe 	sub	r12,sp,-2
80004636:	f0 1f 00 03 	mcall	80004640 <xcmp_opcode_not_supported+0x20>
}
8000463a:	2c dd       	sub	sp,-204
8000463c:	d8 02       	popm	pc
8000463e:	00 00       	add	r0,r0
80004640:	80 00       	ld.sh	r0,r0[0x0]
80004642:	45 0c       	lddsp	r12,sp[0x140]

80004644 <xcmp_exec_func>:
Description: Perform XCMP corresponding functions
Calls:   
Called By: xcmp_rx_process--task
*/
static void xcmp_exec_func(app_exec_t * exec, xcmp_fragment_t * xcmp)
{
80004644:	d4 01       	pushm	lr
	/*The message types*/
	switch(xcmp->xcmp_opcode & 0xF000)
80004646:	96 88       	ld.uh	r8,r11[0x0]
80004648:	e2 18 f0 00 	andl	r8,0xf000,COH
8000464c:	e0 48 80 00 	cp.w	r8,32768
80004650:	c0 f0       	breq	8000466e <xcmp_exec_func+0x2a>
80004652:	e0 48 b0 00 	cp.w	r8,45056
80004656:	c1 20       	breq	8000467a <xcmp_exec_func+0x36>
80004658:	58 08       	cp.w	r8,0
8000465a:	c1 51       	brne	80004684 <xcmp_exec_func+0x40>
	{
		case XCMP_REQUEST:
			if(NULL != exec->xcmp_rx_req)
8000465c:	78 08       	ld.w	r8,r12[0x0]
8000465e:	58 08       	cp.w	r8,0
80004660:	c0 40       	breq	80004668 <xcmp_exec_func+0x24>
			{
				exec->xcmp_rx_req(xcmp);
80004662:	16 9c       	mov	r12,r11
80004664:	5d 18       	icall	r8
80004666:	d8 02       	popm	pc
			}
			else 
			{
				/*No function to register the request message*/
				/*send not supported opcode to raido */
				xcmp_opcode_not_supported();
80004668:	f0 1f 00 08 	mcall	80004688 <xcmp_exec_func+0x44>
8000466c:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_REPLY:		
			if(NULL != exec->xcmp_rx_reply)
8000466e:	78 18       	ld.w	r8,r12[0x4]
80004670:	58 08       	cp.w	r8,0
80004672:	c0 90       	breq	80004684 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_reply(xcmp);
80004674:	16 9c       	mov	r12,r11
80004676:	5d 18       	icall	r8
80004678:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_BRDCAST:	
			if(NULL != exec->xcmp_rx_brdcst)
8000467a:	78 28       	ld.w	r8,r12[0x8]
8000467c:	58 08       	cp.w	r8,0
8000467e:	c0 30       	breq	80004684 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_brdcst(xcmp);
80004680:	16 9c       	mov	r12,r11
80004682:	5d 18       	icall	r8
80004684:	d8 02       	popm	pc
80004686:	00 00       	add	r0,r0
80004688:	80 00       	ld.sh	r0,r0[0x0]
8000468a:	46 20       	lddsp	r0,sp[0x188]

8000468c <xcmp_IdleTestTone>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_IdleTestTone(U8 type, U16 toneID)
{
8000468c:	d4 01       	pushm	lr
8000468e:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | TONE_CONTROL;
80004692:	e0 68 04 09 	mov	r8,1033
80004696:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	ToneControl_req_t * ptr = (ToneControl_req_t *)xcmp_farme.u8;
80004698:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*Starts the specific tone*/	
	ptr->Function = type;
8000469c:	b0 8c       	st.b	r8[0x0],r12
	
	/*This tone shall be sounded when radio landed on a priority channel*/
	//ptr->ToneIdentifier[0] = (Priority_Beep >> 8) & 0xFF;
	//ptr->ToneIdentifier[1] = Priority_Beep & 0xFF;
	
	ptr->ToneIdentifier[0] = (toneID >> 8) & 0xFF;
8000469e:	f3 db c1 08 	bfextu	r9,r11,0x8,0x8
800046a2:	b0 99       	st.b	r8[0x1],r9
	ptr->ToneIdentifier[1] = toneID & 0xFF;	
800046a4:	b0 ab       	st.b	r8[0x2],r11
	
	/*
	The alert tone is played according to any rules for alert tones, given the 
	current volume setting. Settings for this field are 8 to 255 (0x08 ?0xFF).
	*/
	ptr->ToneVolumeControl = Current_Volume;
800046a6:	30 09       	mov	r9,0
800046a8:	b0 b9       	st.b	r8[0x3],r9
	
	/*clear reserved*/
	memset(ptr->Reserved, 0, 8);
800046aa:	fb 69 00 08 	st.b	sp[8],r9
800046ae:	fa c8 ff f7 	sub	r8,sp,-9
800046b2:	b0 89       	st.b	r8[0x0],r9
800046b4:	fa c8 ff f6 	sub	r8,sp,-10
800046b8:	b0 89       	st.b	r8[0x0],r9
800046ba:	fa c8 ff f5 	sub	r8,sp,-11
800046be:	b0 89       	st.b	r8[0x0],r9
800046c0:	fa c8 ff f4 	sub	r8,sp,-12
800046c4:	b0 89       	st.b	r8[0x0],r9
800046c6:	fa c8 ff f3 	sub	r8,sp,-13
800046ca:	b0 89       	st.b	r8[0x0],r9
800046cc:	fa c8 ff f2 	sub	r8,sp,-14
800046d0:	b0 89       	st.b	r8[0x0],r9
800046d2:	fa c8 ff f1 	sub	r8,sp,-15
800046d6:	b0 89       	st.b	r8[0x0],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(ToneControl_req_t));
800046d8:	30 cb       	mov	r11,12
800046da:	fa cc ff fe 	sub	r12,sp,-2
800046de:	f0 1f 00 03 	mcall	800046e8 <xcmp_IdleTestTone+0x5c>
}
800046e2:	2c dd       	sub	sp,-204
800046e4:	d8 02       	popm	pc
800046e6:	00 00       	add	r0,r0
800046e8:	80 00       	ld.sh	r0,r0[0x0]
800046ea:	45 0c       	lddsp	r12,sp[0x140]

800046ec <xcmp_init>:
	xQueueCreate -- freertos
	xTaskCreate -- freertos
Called By: main -- main.c
*/
void xcmp_init(void)
{
800046ec:	d4 01       	pushm	lr
	/*register the xcmp function(callback function)*/
	xnl_register_xcmp_func( xcmp_rx );
800046ee:	48 dc       	lddpc	r12,80004720 <xcmp_init+0x34>
800046f0:	f0 1f 00 0d 	mcall	80004724 <xcmp_init+0x38>
	
	/*initialize the queue*/
	xcmp_frame_rx = xQueueCreate(20, sizeof(xcmp_fragment_t *));
800046f4:	30 4b       	mov	r11,4
800046f6:	31 4c       	mov	r12,20
800046f8:	f0 1f 00 0c 	mcall	80004728 <xcmp_init+0x3c>
800046fc:	48 c8       	lddpc	r8,8000472c <xcmp_init+0x40>
800046fe:	91 0c       	st.w	r8[0x0],r12
	/*create task*/	
	/*this task is used to execute xcmp message*/
	xTaskCreate(
80004700:	30 09       	mov	r9,0
80004702:	1a d9       	st.w	--sp,r9
80004704:	1a d9       	st.w	--sp,r9
80004706:	1a d9       	st.w	--sp,r9
80004708:	30 38       	mov	r8,3
8000470a:	e0 6a 04 00 	mov	r10,1024
8000470e:	48 9b       	lddpc	r11,80004730 <xcmp_init+0x44>
80004710:	48 9c       	lddpc	r12,80004734 <xcmp_init+0x48>
80004712:	f0 1f 00 0a 	mcall	80004738 <xcmp_init+0x4c>
	,  tskXCMP_PRIORITY
	,  NULL
	);
	
	/*initialize the xnl*/
	xnl_init();
80004716:	f0 1f 00 0a 	mcall	8000473c <xcmp_init+0x50>
8000471a:	2f dd       	sub	sp,-12
	
}
8000471c:	d8 02       	popm	pc
8000471e:	00 00       	add	r0,r0
80004720:	80 00       	ld.sh	r0,r0[0x0]
80004722:	48 3c       	lddpc	r12,8000472c <xcmp_init+0x40>
80004724:	80 00       	ld.sh	r0,r0[0x0]
80004726:	48 88       	lddpc	r8,80004744 <xcmp_rx_process+0x4>
80004728:	80 00       	ld.sh	r0,r0[0x0]
8000472a:	6d 7c       	ld.w	r12,r6[0x5c]
8000472c:	00 00       	add	r0,r0
8000472e:	0b 18       	ld.sh	r8,r5++
80004730:	80 00       	ld.sh	r0,r0[0x0]
80004732:	e0 1c 80 00 	andl	r12,0x8000
80004736:	47 40       	lddsp	r0,sp[0x1d0]
80004738:	80 00       	ld.sh	r0,r0[0x0]
8000473a:	74 98       	ld.w	r8,r10[0x24]
8000473c:	80 00       	ld.sh	r0,r0[0x0]
8000473e:	48 c0       	lddpc	r0,8000476c <xcmp_rx_process+0x2c>

80004740 <xcmp_rx_process>:
Calls: xQueueReceive -- freerots
	xcmp_exec_func
Called By: task
*/
static void xcmp_rx_process(void * pvParameters)
{
80004740:	d4 31       	pushm	r0-r7,lr
80004742:	20 1d       	sub	sp,4
	xcmp_fragment_t * ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
80004744:	4b 16       	lddpc	r6,80004808 <xcmp_rx_process+0xc8>
80004746:	30 05       	mov	r5,0
80004748:	31 44       	mov	r4,20
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
8000474a:	4b 13       	lddpc	r3,8000480c <xcmp_rx_process+0xcc>
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
					break;
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
8000474c:	4b 12       	lddpc	r2,80004810 <xcmp_rx_process+0xd0>
						, ptr);
					break;
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
8000474e:	4b 21       	lddpc	r1,80004814 <xcmp_rx_process+0xd4>
					break;
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
80004750:	4b 20       	lddpc	r0,80004818 <xcmp_rx_process+0xd8>
	xcmp_fragment_t * ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
80004752:	6c 0c       	ld.w	r12,r6[0x0]
80004754:	0a 99       	mov	r9,r5
80004756:	08 9a       	mov	r10,r4
80004758:	1a 9b       	mov	r11,sp
8000475a:	f0 1f 00 31 	mcall	8000481c <xcmp_rx_process+0xdc>
8000475e:	58 1c       	cp.w	r12,1
80004760:	cf 91       	brne	80004752 <xcmp_rx_process+0x12>
		{									
			if(NULL == ptr)
80004762:	40 0b       	lddsp	r11,sp[0x0]
80004764:	58 0b       	cp.w	r11,0
80004766:	cf 60       	breq	80004752 <xcmp_rx_process+0x12>
			
			//log("\n\r R_xcmp : %4x \n\r",ptr->xcmp_opcode);//log:R_xcmp指令	
			//static  portTickType water_value;
			//water_value = uxTaskGetStackHighWaterMark(NULL);
			//log("water_value: %d\n", water_value);			
			switch(ptr->xcmp_opcode & 0x0FFF)
80004768:	96 0a       	ld.sh	r10,r11[0x0]
8000476a:	f3 da c0 10 	bfextu	r9,r10,0x0,0x10
8000476e:	f1 d9 c0 0c 	bfextu	r8,r9,0x0,0xc
80004772:	59 c8       	cp.w	r8,28
80004774:	c1 e0       	breq	800047b0 <xcmp_rx_process+0x70>
80004776:	e0 89 00 07 	brgt	80004784 <xcmp_rx_process+0x44>
8000477a:	58 e8       	cp.w	r8,14
8000477c:	c0 e0       	breq	80004798 <xcmp_rx_process+0x58>
8000477e:	58 f8       	cp.w	r8,15
80004780:	c2 41       	brne	800047c8 <xcmp_rx_process+0x88>
80004782:	c0 f8       	rjmp	800047a0 <xcmp_rx_process+0x60>
80004784:	e0 48 01 09 	cp.w	r8,265
80004788:	c1 80       	breq	800047b8 <xcmp_rx_process+0x78>
8000478a:	e0 48 01 0a 	cp.w	r8,266
8000478e:	c1 90       	breq	800047c0 <xcmp_rx_process+0x80>
80004790:	e0 48 00 2c 	cp.w	r8,44
80004794:	c1 a1       	brne	800047c8 <xcmp_rx_process+0x88>
80004796:	c0 98       	rjmp	800047a8 <xcmp_rx_process+0x68>
			{
				case RADIO_STATUS:				
					xcmp_exec_func(&radio_status, ptr);
80004798:	4a 2c       	lddpc	r12,80004820 <xcmp_rx_process+0xe0>
8000479a:	f0 1f 00 23 	mcall	80004824 <xcmp_rx_process+0xe4>
					break;
8000479e:	c2 f8       	rjmp	800047fc <xcmp_rx_process+0xbc>
					
				case VERSION_INFORMATION:
					xcmp_exec_func(&version_information, ptr);
800047a0:	4a 2c       	lddpc	r12,80004828 <xcmp_rx_process+0xe8>
800047a2:	f0 1f 00 21 	mcall	80004824 <xcmp_rx_process+0xe4>
					break;
800047a6:	c2 b8       	rjmp	800047fc <xcmp_rx_process+0xbc>
					
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
800047a8:	4a 1c       	lddpc	r12,8000482c <xcmp_rx_process+0xec>
800047aa:	f0 1f 00 1f 	mcall	80004824 <xcmp_rx_process+0xe4>
					break;
800047ae:	c2 78       	rjmp	800047fc <xcmp_rx_process+0xbc>
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
800047b0:	04 9c       	mov	r12,r2
800047b2:	f0 1f 00 1d 	mcall	80004824 <xcmp_rx_process+0xe4>
						, ptr);
					break;
800047b6:	c2 38       	rjmp	800047fc <xcmp_rx_process+0xbc>
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
800047b8:	02 9c       	mov	r12,r1
800047ba:	f0 1f 00 1b 	mcall	80004824 <xcmp_rx_process+0xe4>
					break;
800047be:	c1 f8       	rjmp	800047fc <xcmp_rx_process+0xbc>
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
800047c0:	00 9c       	mov	r12,r0
800047c2:	f0 1f 00 19 	mcall	80004824 <xcmp_rx_process+0xe4>
					break;
800047c6:	c1 b8       	rjmp	800047fc <xcmp_rx_process+0xbc>
					
				default:
				
					/*the xcmp message not in order list*/
					/*over the length of the list*/
					if((0x0400 != (ptr->xcmp_opcode & 0x0400)) 
800047c8:	12 98       	mov	r8,r9
800047ca:	e2 18 04 00 	andl	r8,0x400,COH
800047ce:	c0 70       	breq	800047dc <xcmp_rx_process+0x9c>
800047d0:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
800047d4:	e0 48 00 68 	cp.w	r8,104
800047d8:	e0 8a 00 08 	brle	800047e8 <xcmp_rx_process+0xa8>
						|| (MAX_APP_FUNC <= (ptr->xcmp_opcode & 0x00FF))
					)
					{
						/*xcmp request*/
						if( XCMP_REQUEST == (ptr->xcmp_opcode & 0xF000))
800047dc:	e2 19 f0 00 	andl	r9,0xf000,COH
800047e0:	c0 e1       	brne	800047fc <xcmp_rx_process+0xbc>
						{
							/*send not supported opcode to raido */
							xcmp_opcode_not_supported();
800047e2:	f0 1f 00 14 	mcall	80004830 <xcmp_rx_process+0xf0>
800047e6:	c0 b8       	rjmp	800047fc <xcmp_rx_process+0xbc>
						}
					}
					else
					{					
						xcmp_exec_func( &app_list[ptr->xcmp_opcode & 0x00FF]
800047e8:	f9 da c0 08 	bfextu	r12,r10,0x0,0x8
800047ec:	f8 0c 00 1c 	add	r12,r12,r12<<0x1
800047f0:	49 19       	lddpc	r9,80004834 <xcmp_rx_process+0xf4>
800047f2:	72 08       	ld.w	r8,r9[0x0]
800047f4:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800047f8:	f0 1f 00 0b 	mcall	80004824 <xcmp_rx_process+0xe4>
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
800047fc:	66 0c       	ld.w	r12,r3[0x0]
800047fe:	40 0b       	lddsp	r11,sp[0x0]
80004800:	f0 1f 00 0e 	mcall	80004838 <xcmp_rx_process+0xf8>
80004804:	ca 7b       	rjmp	80004752 <xcmp_rx_process+0x12>
80004806:	00 00       	add	r0,r0
80004808:	00 00       	add	r0,r0
8000480a:	0b 18       	ld.sh	r8,r5++
8000480c:	00 00       	add	r0,r0
8000480e:	0a ac       	st.w	r5++,r12
80004810:	00 00       	add	r0,r0
80004812:	0b 28       	ld.uh	r8,r5++
80004814:	00 00       	add	r0,r0
80004816:	0b 1c       	ld.sh	r12,r5++
80004818:	00 00       	add	r0,r0
8000481a:	0b 0c       	ld.w	r12,r5++
8000481c:	80 00       	ld.sh	r0,r0[0x0]
8000481e:	6a 18       	ld.w	r8,r5[0x4]
80004820:	00 00       	add	r0,r0
80004822:	0b 40       	ld.w	r0,--r5
80004824:	80 00       	ld.sh	r0,r0[0x0]
80004826:	46 44       	lddsp	r4,sp[0x190]
80004828:	00 00       	add	r0,r0
8000482a:	0b 00       	ld.w	r0,r5++
8000482c:	00 00       	add	r0,r0
8000482e:	0b 34       	ld.ub	r4,r5++
80004830:	80 00       	ld.sh	r0,r0[0x0]
80004832:	46 20       	lddsp	r0,sp[0x188]
80004834:	00 00       	add	r0,r0
80004836:	54 04       	stdsp	sp[0x100],r4
80004838:	80 00       	ld.sh	r0,r0[0x0]
8000483a:	32 1c       	mov	r12,33

8000483c <xcmp_rx>:
Calls:   
	xQueueSend -- xnl.c
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
8000483c:	eb cd 40 90 	pushm	r4,r7,lr
80004840:	20 1d       	sub	sp,4
80004842:	fa c4 ff f0 	sub	r4,sp,-16
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
80004846:	48 c8       	lddpc	r8,80004874 <xcmp_rx+0x38>
80004848:	70 0c       	ld.w	r12,r8[0x0]
8000484a:	f0 1f 00 0c 	mcall	80004878 <xcmp_rx+0x3c>
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
8000484e:	c1 00       	breq	8000486e <xcmp_rx+0x32>
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
80004850:	fa c7 ff fc 	sub	r7,sp,-4
80004854:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
	{
		memcpy(xcmp_ptr, &xcmp, sizeof(xcmp_fragment_t));				
80004856:	e0 6a 00 ca 	mov	r10,202
8000485a:	08 9b       	mov	r11,r4
8000485c:	f0 1f 00 08 	mcall	8000487c <xcmp_rx+0x40>
		xQueueSend(xcmp_frame_rx, &xcmp_ptr, 0);	
80004860:	48 88       	lddpc	r8,80004880 <xcmp_rx+0x44>
80004862:	70 0c       	ld.w	r12,r8[0x0]
80004864:	30 09       	mov	r9,0
80004866:	12 9a       	mov	r10,r9
80004868:	1a 9b       	mov	r11,sp
8000486a:	f0 1f 00 07 	mcall	80004884 <xcmp_rx+0x48>
	}	
}
8000486e:	2f fd       	sub	sp,-4
80004870:	e3 cd 80 90 	ldm	sp++,r4,r7,pc
80004874:	00 00       	add	r0,r0
80004876:	0a ac       	st.w	r5++,r12
80004878:	80 00       	ld.sh	r0,r0[0x0]
8000487a:	33 c8       	mov	r8,60
8000487c:	80 00       	ld.sh	r0,r0[0x0]
8000487e:	81 06       	st.w	r0[0x0],r6
80004880:	00 00       	add	r0,r0
80004882:	0b 18       	ld.sh	r8,r5++
80004884:	80 00       	ld.sh	r0,r0[0x0]
80004886:	6c 24       	ld.w	r4,r6[0x8]

80004888 <xnl_register_xcmp_func>:
Function: xnl_register_xcmp_func
Description: register the xcmp function(callback function)
*/
void xnl_register_xcmp_func( void ( *func)(xnl_content_data_msg_t))
{
	 xcmp_exec = func;
80004888:	48 28       	lddpc	r8,80004890 <xnl_register_xcmp_func+0x8>
8000488a:	91 0c       	st.w	r8[0x0],r12
}
8000488c:	5e fc       	retal	r12
8000488e:	00 00       	add	r0,r0
80004890:	00 00       	add	r0,r0
80004892:	0b 6c       	ld.uh	r12,--r5

80004894 <xnl_get_msg_ack_func>:
Description: process while receive msg ack.
Calls:xSemaphoreGive--freertos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
80004894:	d4 01       	pushm	lr
	
	DestinationAddress = xnl->xnl_header.destination;
	/*No timeout*/		
	 //One relationship is controlled by a state machine, only the current MSG received the ACK, 
	//then the program will clear the current MSG sending address and out of standby and will jump to the sending state.
	if (DestinationAddress == xnl_information.device_address )
80004896:	48 88       	lddpc	r8,800048b4 <xnl_get_msg_ack_func+0x20>
80004898:	90 28       	ld.sh	r8,r8[0x4]
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
	U16 DestinationAddress;
	U16 TransactionID;
	
	DestinationAddress = xnl->xnl_header.destination;
8000489a:	98 49       	ld.sh	r9,r12[0x8]
8000489c:	f0 09 19 00 	cp.h	r9,r8
800048a0:	c0 81       	brne	800048b0 <xnl_get_msg_ack_func+0x1c>
	if (DestinationAddress == xnl_information.device_address )
	{
		//The ack is for me.
		
		TransactionID = xnl->xnl_header.transaction_id;
		xSemaphoreGive(xnl_timeout_semphr);	
800048a2:	48 68       	lddpc	r8,800048b8 <xnl_get_msg_ack_func+0x24>
800048a4:	70 0c       	ld.w	r12,r8[0x0]
800048a6:	30 09       	mov	r9,0
800048a8:	12 9a       	mov	r10,r9
800048aa:	12 9b       	mov	r11,r9
800048ac:	f0 1f 00 04 	mcall	800048bc <xnl_get_msg_ack_func+0x28>
800048b0:	d8 02       	popm	pc
800048b2:	00 00       	add	r0,r0
800048b4:	00 00       	add	r0,r0
800048b6:	0b 52       	ld.sh	r2,--r5
800048b8:	00 00       	add	r0,r0
800048ba:	0b 4c       	ld.w	r12,--r5
800048bc:	80 00       	ld.sh	r0,r0[0x0]
800048be:	6c 24       	ld.w	r4,r6[0x8]

800048c0 <xnl_init>:
	xTaskCreate--freertos
	xnl_send_device_master_query
Called By:xcmp_init -- xcmp.c
*/
void xnl_init(void)
{
800048c0:	eb cd 40 e0 	pushm	r5-r7,lr
	
	xnl_information.is_connected = FALSE;
800048c4:	30 09       	mov	r9,0
800048c6:	4b 78       	lddpc	r8,800049a0 <xnl_init+0xe0>
800048c8:	b0 89       	st.b	r8[0x0],r9

	/*initialize the semaphore and queue*/
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
800048ca:	30 0b       	mov	r11,0
800048cc:	30 1c       	mov	r12,1
800048ce:	f0 1f 00 36 	mcall	800049a4 <xnl_init+0xe4>
800048d2:	4b 68       	lddpc	r8,800049a8 <xnl_init+0xe8>
800048d4:	91 0c       	st.w	r8[0x0],r12
800048d6:	70 08       	ld.w	r8,r8[0x0]
800048d8:	58 08       	cp.w	r8,0
800048da:	c0 80       	breq	800048ea <xnl_init+0x2a>
800048dc:	4b 38       	lddpc	r8,800049a8 <xnl_init+0xe8>
800048de:	70 0c       	ld.w	r12,r8[0x0]
800048e0:	30 09       	mov	r9,0
800048e2:	12 9a       	mov	r10,r9
800048e4:	12 9b       	mov	r11,r9
800048e6:	f0 1f 00 32 	mcall	800049ac <xnl_init+0xec>
	
	xnl_frame_tx = xQueueCreate(20, sizeof(xnl_fragment_t *)); //扩大xnl_frame_tx的队列深度
800048ea:	30 4b       	mov	r11,4
800048ec:	31 4c       	mov	r12,20
800048ee:	f0 1f 00 2e 	mcall	800049a4 <xnl_init+0xe4>
800048f2:	4b 08       	lddpc	r8,800049b0 <xnl_init+0xf0>
800048f4:	91 0c       	st.w	r8[0x0],r12
		
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
800048f6:	30 4b       	mov	r11,4
800048f8:	31 ec       	mov	r12,30
800048fa:	f0 1f 00 2b 	mcall	800049a4 <xnl_init+0xe4>
800048fe:	4a e8       	lddpc	r8,800049b4 <xnl_init+0xf4>
80004900:	91 0c       	st.w	r8[0x0],r12
80004902:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_XNL_STORE; i++ )
	{
		set_xnl_idle(&xnl_store[i]);
80004904:	10 96       	mov	r6,r8
80004906:	4a d5       	lddpc	r5,800049b8 <xnl_init+0xf8>
80004908:	6c 0c       	ld.w	r12,r6[0x0]
8000490a:	ea 07 00 0b 	add	r11,r5,r7
8000490e:	f0 1f 00 2c 	mcall	800049bc <xnl_init+0xfc>
80004912:	ee c7 ff 00 	sub	r7,r7,-256
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
	
	xnl_frame_tx = xQueueCreate(20, sizeof(xnl_fragment_t *)); //扩大xnl_frame_tx的队列深度
		
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
	for(int i= 0; i < MAX_XNL_STORE; i++ )
80004916:	e0 47 1e 00 	cp.w	r7,7680
8000491a:	cf 71       	brne	80004908 <xnl_init+0x48>
	{
		set_xnl_idle(&xnl_store[i]);
	}
	
	/*initialize the queue to send/receive xnl packet */
	phy_xnl_frame_tx = xQueueCreate(TX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
8000491c:	30 4b       	mov	r11,4
8000491e:	31 4c       	mov	r12,20
80004920:	f0 1f 00 21 	mcall	800049a4 <xnl_init+0xe4>
80004924:	4a 78       	lddpc	r8,800049c0 <xnl_init+0x100>
80004926:	91 0c       	st.w	r8[0x0],r12
	phy_xnl_frame_rx = xQueueCreate(RX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
80004928:	30 4b       	mov	r11,4
8000492a:	30 ac       	mov	r12,10
8000492c:	f0 1f 00 1e 	mcall	800049a4 <xnl_init+0xe4>
80004930:	4a 58       	lddpc	r8,800049c4 <xnl_init+0x104>
80004932:	91 0c       	st.w	r8[0x0],r12
	
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
80004934:	30 4b       	mov	r11,4
80004936:	30 ac       	mov	r12,10
80004938:	f0 1f 00 1b 	mcall	800049a4 <xnl_init+0xe4>
8000493c:	4a 38       	lddpc	r8,800049c8 <xnl_init+0x108>
8000493e:	91 0c       	st.w	r8[0x0],r12
80004940:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
	{
		set_payload_idle(payload_store[i]);
80004942:	10 96       	mov	r6,r8
80004944:	4a 25       	lddpc	r5,800049cc <xnl_init+0x10c>
80004946:	6c 0c       	ld.w	r12,r6[0x0]
80004948:	ea 07 00 0b 	add	r11,r5,r7
8000494c:	f0 1f 00 1c 	mcall	800049bc <xnl_init+0xfc>
80004950:	ee c7 fe 00 	sub	r7,r7,-512
	
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
80004954:	e0 47 14 00 	cp.w	r7,5120
80004958:	cf 71       	brne	80004946 <xnl_init+0x86>
	
	/*initialize the queue to send/receive payload packet */
	//phy_payload_frame_tx =
	//xQueueCreate(TX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t));
	
	phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
8000495a:	30 4b       	mov	r11,4
8000495c:	30 5c       	mov	r12,5
8000495e:	f0 1f 00 12 	mcall	800049a4 <xnl_init+0xe4>
80004962:	49 c8       	lddpc	r8,800049d0 <xnl_init+0x110>
80004964:	91 0c       	st.w	r8[0x0],r12
	
	#endif /*end if*/
		
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
80004966:	30 07       	mov	r7,0
80004968:	1a d7       	st.w	--sp,r7
8000496a:	1a d7       	st.w	--sp,r7
8000496c:	1a d7       	st.w	--sp,r7
8000496e:	30 38       	mov	r8,3
80004970:	0e 99       	mov	r9,r7
80004972:	e0 6a 00 dc 	mov	r10,220
80004976:	49 8b       	lddpc	r11,800049d4 <xnl_init+0x114>
80004978:	49 8c       	lddpc	r12,800049d8 <xnl_init+0x118>
8000497a:	f0 1f 00 19 	mcall	800049dc <xnl_init+0x11c>
	,  tskXNL_PRIORITY //+ 1
	,  NULL
	);
	
	/*this task is used to send xnl message*/
	xTaskCreate(
8000497e:	1a d7       	st.w	--sp,r7
80004980:	1a d7       	st.w	--sp,r7
80004982:	1a d7       	st.w	--sp,r7
80004984:	30 38       	mov	r8,3
80004986:	0e 99       	mov	r9,r7
80004988:	e0 6a 00 82 	mov	r10,130
8000498c:	49 5b       	lddpc	r11,800049e0 <xnl_init+0x120>
8000498e:	49 6c       	lddpc	r12,800049e4 <xnl_init+0x124>
80004990:	f0 1f 00 13 	mcall	800049dc <xnl_init+0x11c>
	,  tskXNL_PRIORITY//+1
	,  NULL
	);
	
	/*initialize the physical layer*/
	phy_init();
80004994:	f0 1f 00 15 	mcall	800049e8 <xnl_init+0x128>
80004998:	2f ad       	sub	sp,-24
}
8000499a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000499e:	00 00       	add	r0,r0
800049a0:	00 00       	add	r0,r0
800049a2:	0b 52       	ld.sh	r2,--r5
800049a4:	80 00       	ld.sh	r0,r0[0x0]
800049a6:	6d 7c       	ld.w	r12,r6[0x5c]
800049a8:	00 00       	add	r0,r0
800049aa:	0b 4c       	ld.w	r12,--r5
800049ac:	80 00       	ld.sh	r0,r0[0x0]
800049ae:	6c 24       	ld.w	r4,r6[0x8]
800049b0:	00 00       	add	r0,r0
800049b2:	0b 60       	ld.uh	r0,--r5
800049b4:	00 00       	add	r0,r0
800049b6:	0a ac       	st.w	r5++,r12
800049b8:	00 00       	add	r0,r0
800049ba:	35 b6       	mov	r6,91
800049bc:	80 00       	ld.sh	r0,r0[0x0]
800049be:	32 1c       	mov	r12,33
800049c0:	00 00       	add	r0,r0
800049c2:	0a dc       	st.w	--r5,r12
800049c4:	00 00       	add	r0,r0
800049c6:	0a bc       	st.h	r5++,r12
800049c8:	00 00       	add	r0,r0
800049ca:	0a b0       	st.h	r5++,r0
800049cc:	00 00       	add	r0,r0
800049ce:	21 b6       	sub	r6,27
800049d0:	00 00       	add	r0,r0
800049d2:	0a e8       	st.h	--r5,r8
800049d4:	80 00       	ld.sh	r0,r0[0x0]
800049d6:	e0 24 80 00 	sub	r4,32768
800049da:	49 ec       	lddpc	r12,80004a50 <xnl_tx_process+0x4>
800049dc:	80 00       	ld.sh	r0,r0[0x0]
800049de:	74 98       	ld.w	r8,r10[0x24]
800049e0:	80 00       	ld.sh	r0,r0[0x0]
800049e2:	e0 2c 80 00 	sub	r12,32768
800049e6:	4a 4c       	lddpc	r12,80004a74 <xnl_tx_process+0x28>
800049e8:	80 00       	ld.sh	r0,r0[0x0]
800049ea:	33 f0       	mov	r0,63

800049ec <xnl_rx_process>:
Calls: 
Called By:task
*/
//portTickType water_value =0;
static void xnl_rx_process(void * pvParameters)
{
800049ec:	eb cd 40 fe 	pushm	r1-r7,lr
800049f0:	20 1d       	sub	sp,4
	xnl_fragment_t * xnl_ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
800049f2:	49 26       	lddpc	r6,80004a38 <xnl_rx_process+0x4c>
800049f4:	30 05       	mov	r5,0
800049f6:	3f f4       	mov	r4,-1
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
800049f8:	30 c3       	mov	r3,12
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
800049fa:	49 11       	lddpc	r1,80004a3c <xnl_rx_process+0x50>
	if(xnl->xnl_header.opcode > 0x0C)	
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
800049fc:	49 12       	lddpc	r2,80004a40 <xnl_rx_process+0x54>
	xnl_fragment_t * xnl_ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
800049fe:	6c 0c       	ld.w	r12,r6[0x0]
80004a00:	0a 99       	mov	r9,r5
80004a02:	08 9a       	mov	r10,r4
80004a04:	1a 9b       	mov	r11,sp
80004a06:	f0 1f 00 10 	mcall	80004a44 <xnl_rx_process+0x58>
80004a0a:	58 1c       	cp.w	r12,1
80004a0c:	cf 91       	brne	800049fe <xnl_rx_process+0x12>
		, portMAX_DELAY ))
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
80004a0e:	40 0c       	lddsp	r12,sp[0x0]
80004a10:	58 0c       	cp.w	r12,0
80004a12:	cf 60       	breq	800049fe <xnl_rx_process+0x12>
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
80004a14:	98 28       	ld.sh	r8,r12[0x4]
80004a16:	e6 08 19 00 	cp.h	r8,r3
80004a1a:	e0 8b 00 0a 	brhi	80004a2e <xnl_rx_process+0x42>
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
80004a1e:	5c 78       	castu.h	r8
80004a20:	e4 08 03 29 	ld.w	r9,r2[r8<<0x2]
80004a24:	58 09       	cp.w	r9,0
80004a26:	c0 40       	breq	80004a2e <xnl_rx_process+0x42>
	{
		//log("\n\r R_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:R_xnl指令
		/*execute the function in list*/
		xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec(xnl);
80004a28:	e4 08 03 28 	ld.w	r8,r2[r8<<0x2]
80004a2c:	5d 18       	icall	r8
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
80004a2e:	62 0c       	ld.w	r12,r1[0x0]
80004a30:	40 0b       	lddsp	r11,sp[0x0]
80004a32:	f0 1f 00 06 	mcall	80004a48 <xnl_rx_process+0x5c>
80004a36:	ce 4b       	rjmp	800049fe <xnl_rx_process+0x12>
80004a38:	00 00       	add	r0,r0
80004a3a:	0a bc       	st.h	r5++,r12
80004a3c:	00 00       	add	r0,r0
80004a3e:	0a ac       	st.w	r5++,r12
80004a40:	00 00       	add	r0,r0
80004a42:	04 f8       	st.b	--r2,r8
80004a44:	80 00       	ld.sh	r0,r0[0x0]
80004a46:	6a 18       	ld.w	r8,r5[0x4]
80004a48:	80 00       	ld.sh	r0,r0[0x0]
80004a4a:	32 1c       	mov	r12,33

80004a4c <xnl_tx_process>:
	phy_tx -- physical.c
Called By: task
*/
//portTickType tx_water_value =0;
static void xnl_tx_process(void * pvParameters)
{
80004a4c:	d4 31       	pushm	r0-r7,lr
	
	
	for(;;)
	{		
		//tx_water_value = uxTaskGetStackHighWaterMark(NULL);
		switch(xnl_tx_state)
80004a4e:	4a a6       	lddpc	r6,80004af4 <xnl_tx_process+0xa8>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
80004a50:	4a a2       	lddpc	r2,80004af8 <xnl_tx_process+0xac>
80004a52:	4a b4       	lddpc	r4,80004afc <xnl_tx_process+0xb0>
80004a54:	30 07       	mov	r7,0
80004a56:	3f f1       	mov	r1,-1
					if(NULL == ptr)
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
80004a58:	30 00       	mov	r0,0
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;				
80004a5a:	4a a5       	lddpc	r5,80004b00 <xnl_tx_process+0xb4>
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
80004a5c:	4a a3       	lddpc	r3,80004b04 <xnl_tx_process+0xb8>
	
	
	for(;;)
	{		
		//tx_water_value = uxTaskGetStackHighWaterMark(NULL);
		switch(xnl_tx_state)
80004a5e:	6c 08       	ld.w	r8,r6[0x0]
80004a60:	58 08       	cp.w	r8,0
80004a62:	c0 40       	breq	80004a6a <xnl_tx_process+0x1e>
80004a64:	58 18       	cp.w	r8,1
80004a66:	cf d1       	brne	80004a60 <xnl_tx_process+0x14>
80004a68:	c2 48       	rjmp	80004ab0 <xnl_tx_process+0x64>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
80004a6a:	64 0c       	ld.w	r12,r2[0x0]
80004a6c:	0e 99       	mov	r9,r7
80004a6e:	02 9a       	mov	r10,r1
80004a70:	08 9b       	mov	r11,r4
80004a72:	f0 1f 00 26 	mcall	80004b08 <xnl_tx_process+0xbc>
80004a76:	58 1c       	cp.w	r12,1
80004a78:	cf 31       	brne	80004a5e <xnl_tx_process+0x12>
					, portMAX_DELAY ))
				{				
					if(NULL == ptr)
80004a7a:	68 0b       	ld.w	r11,r4[0x0]
80004a7c:	58 0b       	cp.w	r11,0
80004a7e:	cf 00       	breq	80004a5e <xnl_tx_process+0x12>
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
80004a80:	96 28       	ld.sh	r8,r11[0x4]
80004a82:	e0 08 19 00 	cp.h	r8,r0
80004a86:	c0 71       	brne	80004a94 <xnl_tx_process+0x48>
					{
						/*invalid XNL opcode*/
						set_xnl_idle(ptr);
80004a88:	4a 18       	lddpc	r8,80004b0c <xnl_tx_process+0xc0>
80004a8a:	70 08       	ld.w	r8,r8[0x0]
80004a8c:	10 9c       	mov	r12,r8
80004a8e:	f0 1f 00 21 	mcall	80004b10 <xnl_tx_process+0xc4>
						break;
80004a92:	ce 6b       	rjmp	80004a5e <xnl_tx_process+0x12>
					}
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
80004a94:	16 9c       	mov	r12,r11
80004a96:	f0 1f 00 20 	mcall	80004b14 <xnl_tx_process+0xc8>
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;				
80004a9a:	30 18       	mov	r8,1
80004a9c:	8b 08       	st.w	r5[0x0],r8
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
80004a9e:	66 0c       	ld.w	r12,r3[0x0]
80004aa0:	0e 99       	mov	r9,r7
80004aa2:	0e 9a       	mov	r10,r7
80004aa4:	0e 9b       	mov	r11,r7
80004aa6:	f0 1f 00 19 	mcall	80004b08 <xnl_tx_process+0xbc>
					xnl_tx_state = WAITING_FOR_REPLY;
80004aaa:	30 18       	mov	r8,1
80004aac:	8d 08       	st.w	r6[0x0],r8
80004aae:	cd 8b       	rjmp	80004a5e <xnl_tx_process+0x12>
				}
				break;
			
			/*wait XNL reply*/			
			case WAITING_FOR_REPLY://直到回答ACK才再发送下一条data/control
				if(pdTRUE == xSemaphoreTake( xnl_timeout_semphr
80004ab0:	66 0c       	ld.w	r12,r3[0x0]
80004ab2:	0e 99       	mov	r9,r7
80004ab4:	36 4a       	mov	r10,100
80004ab6:	0e 9b       	mov	r11,r7
80004ab8:	f0 1f 00 14 	mcall	80004b08 <xnl_tx_process+0xbc>
80004abc:	58 1c       	cp.w	r12,1
80004abe:	c0 81       	brne	80004ace <xnl_tx_process+0x82>
					, ( portTickType )50*2/ portTICK_RATE_MS))//按ADK文档中提示500ms一次超时,但是实际情况下程序中启用freertos的任务延时不够精准。因此根据经验需要降低延时等待的时间
				{
					/*No timeout*/
					set_xnl_idle(ptr);			
80004ac0:	49 38       	lddpc	r8,80004b0c <xnl_tx_process+0xc0>
80004ac2:	70 0c       	ld.w	r12,r8[0x0]
80004ac4:	68 0b       	ld.w	r11,r4[0x0]
80004ac6:	f0 1f 00 13 	mcall	80004b10 <xnl_tx_process+0xc4>
					xnl_tx_state = WAITING_FOR_TX;
80004aca:	8d 07       	st.w	r6[0x0],r7
80004acc:	cc 9b       	rjmp	80004a5e <xnl_tx_process+0x12>
				}
				else
				{
					/*time out*/
					if(xnl_send_times <= MIN_RESEND_TIMES)
80004ace:	6a 08       	ld.w	r8,r5[0x0]
80004ad0:	58 38       	cp.w	r8,3
80004ad2:	e0 89 00 09 	brgt	80004ae4 <xnl_tx_process+0x98>
					{
						/*If times smaller than A supermarket, then resend the 
						instructions*/
						phy_tx((phy_fragment_t *)ptr);
80004ad6:	68 0c       	ld.w	r12,r4[0x0]
80004ad8:	f0 1f 00 0f 	mcall	80004b14 <xnl_tx_process+0xc8>
						xnl_send_times++;
80004adc:	6a 08       	ld.w	r8,r5[0x0]
80004ade:	2f f8       	sub	r8,-1
80004ae0:	8b 08       	st.w	r5[0x0],r8
80004ae2:	cb eb       	rjmp	80004a5e <xnl_tx_process+0x12>
					}
					else
					{
						//can not send data, disconnected						
						//vPortFree(ptr);	
						set_xnl_idle(ptr);									
80004ae4:	48 a8       	lddpc	r8,80004b0c <xnl_tx_process+0xc0>
80004ae6:	70 0c       	ld.w	r12,r8[0x0]
80004ae8:	68 0b       	ld.w	r11,r4[0x0]
80004aea:	f0 1f 00 0a 	mcall	80004b10 <xnl_tx_process+0xc4>
						xnl_tx_state = WAITING_FOR_TX;
80004aee:	8d 07       	st.w	r6[0x0],r7
80004af0:	cb 7b       	rjmp	80004a5e <xnl_tx_process+0x12>
80004af2:	00 00       	add	r0,r0
80004af4:	00 00       	add	r0,r0
80004af6:	0b 5c       	ld.sh	r12,--r5
80004af8:	00 00       	add	r0,r0
80004afa:	0b 60       	ld.uh	r0,--r5
80004afc:	00 00       	add	r0,r0
80004afe:	0b 68       	ld.uh	r8,--r5
80004b00:	00 00       	add	r0,r0
80004b02:	0b 64       	ld.uh	r4,--r5
80004b04:	00 00       	add	r0,r0
80004b06:	0b 4c       	ld.w	r12,--r5
80004b08:	80 00       	ld.sh	r0,r0[0x0]
80004b0a:	6a 18       	ld.w	r8,r5[0x4]
80004b0c:	00 00       	add	r0,r0
80004b0e:	0a ac       	st.w	r5++,r12
80004b10:	80 00       	ld.sh	r0,r0[0x0]
80004b12:	32 1c       	mov	r12,33
80004b14:	80 00       	ld.sh	r0,r0[0x0]
80004b16:	32 3c       	mov	r12,35

80004b18 <xnl_tx>:
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
{
80004b18:	eb cd 40 c0 	pushm	r6-r7,lr
80004b1c:	20 1d       	sub	sp,4
80004b1e:	18 96       	mov	r6,r12
	message that is sent. The same value should be used for all retries.
	*/
	static U8 flags = 0;
	
	/*If the value is DEFAULT_VALUE, the value will be modified*/
	if(DEFAULT_VALUE == xnl->xnl_header.flags)
80004b20:	98 39       	ld.sh	r9,r12[0x6]
80004b22:	3f f8       	mov	r8,-1
80004b24:	f0 09 19 00 	cp.h	r9,r8
80004b28:	c0 a1       	brne	80004b3c <xnl_tx+0x24>
	{
		xnl->xnl_header.flags =  0x0100 | ((++flags) & 0x07);
80004b2a:	4a e9       	lddpc	r9,80004be0 <xnl_tx+0xc8>
80004b2c:	13 88       	ld.ub	r8,r9[0x0]
80004b2e:	2f f8       	sub	r8,-1
80004b30:	5c 58       	castu.b	r8
80004b32:	b2 88       	st.b	r9[0x0],r8
80004b34:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
80004b38:	a9 a8       	sbr	r8,0x8
80004b3a:	b8 38       	st.h	r12[0x6],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.destination)
80004b3c:	8c 49       	ld.sh	r9,r6[0x8]
80004b3e:	3f f8       	mov	r8,-1
80004b40:	f0 09 19 00 	cp.h	r9,r8
80004b44:	c0 41       	brne	80004b4c <xnl_tx+0x34>
	{		
		/*Use actual Master address.*/
		xnl->xnl_header.destination = xnl_information.master_address;
80004b46:	4a 88       	lddpc	r8,80004be4 <xnl_tx+0xcc>
80004b48:	90 18       	ld.sh	r8,r8[0x2]
80004b4a:	ac 48       	st.h	r6[0x8],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.source)
80004b4c:	8c 59       	ld.sh	r9,r6[0xa]
80004b4e:	3f f8       	mov	r8,-1
80004b50:	f0 09 19 00 	cp.h	r9,r8
80004b54:	c0 41       	brne	80004b5c <xnl_tx+0x44>
	{
		/*Use Temporary address.*/	
		xnl->xnl_header.source = xnl_information.device_address;
80004b56:	4a 48       	lddpc	r8,80004be4 <xnl_tx+0xcc>
80004b58:	90 28       	ld.sh	r8,r8[0x4]
80004b5a:	ac 58       	st.h	r6[0xa],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
80004b5c:	8c 69       	ld.sh	r9,r6[0xc]
80004b5e:	3f f8       	mov	r8,-1
80004b60:	f0 09 19 00 	cp.h	r9,r8
80004b64:	c0 e1       	brne	80004b80 <xnl_tx+0x68>
	{		
		xnl->xnl_header.transaction_id = 
		  ((++xnl_information.transaction_id) & 0xFF) 
80004b66:	4a 08       	lddpc	r8,80004be4 <xnl_tx+0xcc>
80004b68:	90 49       	ld.sh	r9,r8[0x8]
80004b6a:	2f f9       	sub	r9,-1
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
80004b6c:	b0 49       	st.h	r8[0x8],r9
		  ((++xnl_information.transaction_id) & 0xFF) 
80004b6e:	90 4a       	ld.sh	r10,r8[0x8]
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
80004b70:	90 49       	ld.sh	r9,r8[0x8]
80004b72:	e0 19 ff 00 	andl	r9,0xff00
80004b76:	f1 da c0 08 	bfextu	r8,r10,0x0,0x8
80004b7a:	f3 e8 10 08 	or	r8,r9,r8
80004b7e:	ac 68       	st.h	r6[0xc],r8
	U16  sumScratch;
	U32  indextohWord;
	S32  hWordswithinFrag;
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
80004b80:	0d 98       	ld.ub	r8,r6[0x1]
80004b82:	20 28       	sub	r8,2
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
80004b84:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
80004b88:	10 0c       	add	r12,r8
80004b8a:	a1 5c       	asr	r12,0x1
	indextohWord = 2;
	while (hWordswithinFrag > 0)
80004b8c:	58 0c       	cp.w	r12,0
80004b8e:	e0 89 00 04 	brgt	80004b96 <xnl_tx+0x7e>
80004b92:	30 09       	mov	r9,0
80004b94:	c0 d8       	rjmp	80004bae <xnl_tx+0x96>
80004b96:	ec ca ff fc 	sub	r10,r6,-4
Parameters: xnl_fragment_t * 
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
80004b9a:	2f ec       	sub	r12,-2
80004b9c:	30 09       	mov	r9,0
80004b9e:	30 28       	mov	r8,2
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
	{
		sumScratch += *((U16*)xnl + indextohWord);
80004ba0:	15 1b       	ld.sh	r11,r10++
80004ba2:	f6 09 00 09 	add	r9,r11,r9
80004ba6:	5c 89       	casts.h	r9
		indextohWord     += 1;
80004ba8:	2f f8       	sub	r8,-1
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
80004baa:	18 38       	cp.w	r8,r12
80004bac:	cf a1       	brne	80004ba0 <xnl_tx+0x88>
		  ((++xnl_information.transaction_id) & 0xFF) 
		| (xnl_information.transaction_id & 0xFF00);
	}
	
	/*count check sum */
	xnl->phy_header.check_sum = check_sum( xnl );
80004bae:	5c 39       	neg	r9
80004bb0:	ac 19       	st.h	r6[0x2],r9
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
80004bb2:	48 e8       	lddpc	r8,80004be8 <xnl_tx+0xd0>
80004bb4:	70 0c       	ld.w	r12,r8[0x0]
80004bb6:	f0 1f 00 0e 	mcall	80004bec <xnl_tx+0xd4>
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
80004bba:	c1 00       	breq	80004bda <xnl_tx+0xc2>
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
80004bbc:	fa c7 ff fc 	sub	r7,sp,-4
80004bc0:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
	{
		memcpy(ptr, xnl, sizeof(xnl_fragment_t));
80004bc2:	e0 6a 01 00 	mov	r10,256
80004bc6:	0c 9b       	mov	r11,r6
80004bc8:	f0 1f 00 0a 	mcall	80004bf0 <xnl_tx+0xd8>
	
		/*push to queue and send*/
		
		//log("ptr -%8x", ptr);
		
		xQueueSend(xnl_frame_tx, &ptr, 0);
80004bcc:	48 a8       	lddpc	r8,80004bf4 <xnl_tx+0xdc>
80004bce:	70 0c       	ld.w	r12,r8[0x0]
80004bd0:	30 09       	mov	r9,0
80004bd2:	12 9a       	mov	r10,r9
80004bd4:	1a 9b       	mov	r11,sp
80004bd6:	f0 1f 00 09 	mcall	80004bf8 <xnl_tx+0xe0>
		//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
		
		//vPortFree(ptr);
	}
}
80004bda:	2f fd       	sub	sp,-4
80004bdc:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004be0:	00 00       	add	r0,r0
80004be2:	0b 50       	ld.sh	r0,--r5
80004be4:	00 00       	add	r0,r0
80004be6:	0b 52       	ld.sh	r2,--r5
80004be8:	00 00       	add	r0,r0
80004bea:	0a ac       	st.w	r5++,r12
80004bec:	80 00       	ld.sh	r0,r0[0x0]
80004bee:	33 c8       	mov	r8,60
80004bf0:	80 00       	ld.sh	r0,r0[0x0]
80004bf2:	81 06       	st.w	r0[0x0],r6
80004bf4:	00 00       	add	r0,r0
80004bf6:	0b 60       	ld.uh	r0,--r5
80004bf8:	80 00       	ld.sh	r0,r0[0x0]
80004bfa:	6c 24       	ld.w	r4,r6[0x8]

80004bfc <xnl_data_msg_func>:
Description: process while receive data message.
Calls:xnl_send_msg_ack, xcmp_exec(function in xcmp)
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_data_msg_func(xnl_fragment_t * xnl)
{
80004bfc:	eb cd 40 80 	pushm	r7,lr
80004c00:	fa cd 01 00 	sub	sp,sp,256
80004c04:	18 97       	mov	r7,r12
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80004c06:	e0 68 40 0e 	mov	r8,16398
80004c0a:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004c0c:	3f f8       	mov	r8,-1
80004c0e:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG_ACK;
80004c10:	30 c8       	mov	r8,12
80004c12:	ba 28       	st.h	sp[0x4],r8
	
	/*Turn around Flags.*/	
	xnl_frame.xnl_header.flags = hdr->flags;
80004c14:	98 38       	ld.sh	r8,r12[0x6]
80004c16:	ba 38       	st.h	sp[0x6],r8
	
	/*ACK Destination Address is Source of XNL_Message.*/
	xnl_frame.xnl_header.destination = hdr->source;
80004c18:	98 58       	ld.sh	r8,r12[0xa]
80004c1a:	ba 48       	st.h	sp[0x8],r8
	
	/*ACK Source Address is my address.*/
	xnl_frame.xnl_header.source = hdr->destination;
80004c1c:	98 48       	ld.sh	r8,r12[0x8]
80004c1e:	ba 58       	st.h	sp[0xa],r8
	
	/*Turn around Transaction ID.*/
	xnl_frame.xnl_header.transaction_id = hdr->transaction_id;
80004c20:	98 68       	ld.sh	r8,r12[0xc]
80004c22:	ba 68       	st.h	sp[0xc],r8
	xnl_frame.xnl_header.payload_length = 0;
80004c24:	30 08       	mov	r8,0
80004c26:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004c28:	1a 9c       	mov	r12,sp
80004c2a:	f0 1f 00 0a 	mcall	80004c50 <xnl_data_msg_func+0x54>
	transmitter, but possibly is waiting in Queue with immediate timeout.
	 */
	xnl_send_msg_ack(&xnl->xnl_header);
	
	/*exec xcmp function*/
	xcmp_exec(xnl->xnl_payload.xnl_content_data_msg);//xcmp_rx
80004c2e:	fa cd 00 cc 	sub	sp,sp,204
80004c32:	e0 6a 00 ca 	mov	r10,202
80004c36:	ee cb ff f0 	sub	r11,r7,-16
80004c3a:	1a 9c       	mov	r12,sp
80004c3c:	f0 1f 00 06 	mcall	80004c54 <xnl_data_msg_func+0x58>
80004c40:	48 68       	lddpc	r8,80004c58 <xnl_data_msg_func+0x5c>
80004c42:	70 08       	ld.w	r8,r8[0x0]
80004c44:	5d 18       	icall	r8
80004c46:	fa cd ff 34 	sub	sp,sp,-204
}
80004c4a:	2c 0d       	sub	sp,-256
80004c4c:	e3 cd 80 80 	ldm	sp++,r7,pc
80004c50:	80 00       	ld.sh	r0,r0[0x0]
80004c52:	4b 18       	lddpc	r8,80004d14 <xnl_device_auth_reply_func+0xb8>
80004c54:	80 00       	ld.sh	r0,r0[0x0]
80004c56:	81 06       	st.w	r0[0x0],r6
80004c58:	00 00       	add	r0,r0
80004c5a:	0b 6c       	ld.uh	r12,--r5

80004c5c <xnl_device_auth_reply_func>:
Description: process while receive device auth reply.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_auth_reply_func(xnl_fragment_t * xnl)
{
80004c5c:	d4 21       	pushm	r4-r7,lr
80004c5e:	fa cd 01 00 	sub	sp,sp,256
80004c62:	18 97       	mov	r7,r12
	the receiving device and will be used to authenticate the connection 
	request. 5.4.4
	*/
	//log("R_xnl-opcode:%4x", xnl->xnl_header.opcode);
	
	if(xnl_information.is_connected)
80004c64:	4c 28       	lddpc	r8,80004d6c <xnl_device_auth_reply_func+0x110>
80004c66:	11 88       	ld.ub	r8,r8[0x0]
80004c68:	58 08       	cp.w	r8,0
80004c6a:	e0 81 00 7f 	brne	80004d68 <xnl_device_auth_reply_func+0x10c>
	{
		return;		
	}
	
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);
80004c6e:	4c 18       	lddpc	r8,80004d70 <xnl_device_auth_reply_func+0x114>
80004c70:	70 0c       	ld.w	r12,r8[0x0]
80004c72:	30 09       	mov	r9,0
80004c74:	12 9a       	mov	r10,r9
80004c76:	12 9b       	mov	r11,r9
80004c78:	f0 1f 00 3f 	mcall	80004d74 <xnl_device_auth_reply_func+0x118>

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
80004c7c:	ef 09 00 10 	ld.sh	r9,r7[16]
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
80004c80:	4b b8       	lddpc	r8,80004d6c <xnl_device_auth_reply_func+0x110>
80004c82:	b0 29       	st.h	r8[0x4],r9
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
	
	/*Get Array of values to be encrypted into an aligned 2X32bits.*/
	v_vector[0] =
80004c84:	ef 39 00 12 	ld.ub	r9,r7[18]
80004c88:	ef 38 00 13 	ld.ub	r8,r7[19]
80004c8c:	b1 68       	lsl	r8,0x10
80004c8e:	f1 e9 11 89 	or	r9,r8,r9<<0x18
80004c92:	ef 38 00 15 	ld.ub	r8,r7[21]
80004c96:	f3 e8 10 08 	or	r8,r9,r8
80004c9a:	ef 39 00 14 	ld.ub	r9,r7[20]
80004c9e:	f1 e9 10 89 	or	r9,r8,r9<<0x8
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[2])<<8	  
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[3]);
	
	v_vector[1] =
80004ca2:	ef 3a 00 16 	ld.ub	r10,r7[22]
80004ca6:	ef 38 00 17 	ld.ub	r8,r7[23]
80004caa:	b1 68       	lsl	r8,0x10
80004cac:	f1 ea 11 8a 	or	r10,r8,r10<<0x18
80004cb0:	ef 38 00 19 	ld.ub	r8,r7[25]
80004cb4:	f5 e8 10 08 	or	r8,r10,r8
80004cb8:	ef 3a 00 18 	ld.ub	r10,r7[24]
80004cbc:	f1 ea 10 88 	or	r8,r8,r10<<0x8
80004cc0:	30 0a       	mov	r10,0
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
80004cc2:	e0 64 79 b9 	mov	r4,31161
80004cc6:	ea 14 9e 37 	orh	r4,0x9e37
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
80004cca:	e0 65 45 07 	mov	r5,17671
80004cce:	ea 15 8a bd 	orh	r5,0x8abd
80004cd2:	e0 66 f9 3d 	mov	r6,63805
80004cd6:	ea 16 99 68 	orh	r6,0x9968
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
80004cda:	e0 6e b8 cf 	mov	lr,47311
80004cde:	ea 1e 36 83 	orh	lr,0x3683
80004ce2:	e0 67 aa 1c 	mov	r7,43548
80004ce6:	ea 17 9c 36 	orh	r7,0x9c36
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
80004cea:	08 0a       	add	r10,r4
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
80004cec:	f4 08 00 0c 	add	r12,r10,r8
80004cf0:	f0 0b 15 04 	lsl	r11,r8,0x4
80004cf4:	0a 0b       	add	r11,r5
80004cf6:	f9 eb 20 0b 	eor	r11,r12,r11
80004cfa:	f0 0c 16 05 	lsr	r12,r8,0x5
80004cfe:	0c 0c       	add	r12,r6
80004d00:	18 5b       	eor	r11,r12
80004d02:	16 09       	add	r9,r11
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
80004d04:	f2 0c 15 04 	lsl	r12,r9,0x4
80004d08:	1c 0c       	add	r12,lr
80004d0a:	f2 0b 16 05 	lsr	r11,r9,0x5
80004d0e:	0e 0b       	add	r11,r7
80004d10:	f9 eb 20 0b 	eor	r11,r12,r11
80004d14:	f2 0a 00 0c 	add	r12,r9,r10
80004d18:	18 5b       	eor	r11,r12
80004d1a:	16 08       	add	r8,r11
{
	register U32 y=v[0], z=v[1], sum=0;
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
80004d1c:	e0 6b 37 20 	mov	r11,14112
80004d20:	ea 1b c6 ef 	orh	r11,0xc6ef
80004d24:	16 3a       	cp.w	r10,r11
80004d26:	ce 21       	brne	80004cea <xnl_device_auth_reply_func+0x8e>
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :24 + 2(xnl length(24) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 24 + 2;
80004d28:	e0 6a 40 1a 	mov	r10,16410
80004d2c:	ba 0a       	st.h	sp[0x0],r10
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004d2e:	3f fa       	mov	r10,-1
80004d30:	ba 1a       	st.h	sp[0x2],r10
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_CONN_REQUEST;
80004d32:	30 6b       	mov	r11,6
80004d34:	ba 2b       	st.h	sp[0x4],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
80004d36:	ba 3a       	st.h	sp[0x6],r10
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
80004d38:	48 db       	lddpc	r11,80004d6c <xnl_device_auth_reply_func+0x110>
80004d3a:	96 1c       	ld.sh	r12,r11[0x2]
80004d3c:	ba 4c       	st.h	sp[0x8],r12
	message here, and all will receive the same DEVICE_CONN_REPLY. Not real 
	sure what's going to happen with multiple conrol heads, etc. One suspects 
	the Rocket Scientists will eventually figure this out, and demand a 
	transaction ID based on Device Type in the XNL_DEVICE_AUTH_KEY_REQUEST.
	*/
	xnl_frame.xnl_header.source = xnl_information.device_address;
80004d3e:	96 2b       	ld.sh	r11,r11[0x4]
80004d40:	ba 5b       	st.h	sp[0xa],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80004d42:	ba 6a       	st.h	sp[0xc],r10
	
    /*his message contains 12 payload bytes*/	
	xnl_frame.xnl_header.payload_length = 0x000C;
80004d44:	30 ca       	mov	r10,12
80004d46:	ba 7a       	st.h	sp[0xe],r10
	
	/*No Preferred XNL Address*/
	xnl_frame.xnl_payload.xnl_content_device_conn_req.preferred_xnl_address = 
80004d48:	30 0a       	mov	r10,0
80004d4a:	fb 5a 00 10 	st.h	sp[16],r10
	XCMP/XNL Development Specification Section 4.5.3.2.1.
	Same as in MOTOTRBO?XCMP/XNL Development Specification?
	evice_type--Option Board(0x07)
	authentication_index--Option Board(0x02)
	*/	
	xnl_frame.xnl_payload.xnl_content_device_conn_req.device_type = 0x07;
80004d4e:	30 7a       	mov	r10,7
80004d50:	fb 6a 00 12 	st.b	sp[18],r10
	xnl_frame.xnl_payload.xnl_content_device_conn_req.authentication_index =
80004d54:	30 2a       	mov	r10,2
80004d56:	fb 6a 00 13 	st.b	sp[19],r10
	                                                                       0x02;
		
	//We know encrypted array happens to be aligned to 32-bit boundary.
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
80004d5a:	fa ca ff ec 	sub	r10,sp,-20
80004d5e:	95 09       	st.w	r10[0x0],r9
	                         .encrypted_authentication_value[0])) = w_vector[0];
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
80004d60:	95 18       	st.w	r10[0x4],r8
	                         .encrypted_authentication_value[4])) = w_vector[1];
	
	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004d62:	1a 9c       	mov	r12,sp
80004d64:	f0 1f 00 05 	mcall	80004d78 <xnl_device_auth_reply_func+0x11c>
}
80004d68:	2c 0d       	sub	sp,-256
80004d6a:	d8 22       	popm	r4-r7,pc
80004d6c:	00 00       	add	r0,r0
80004d6e:	0b 52       	ld.sh	r2,--r5
80004d70:	00 00       	add	r0,r0
80004d72:	0b 4c       	ld.w	r12,--r5
80004d74:	80 00       	ld.sh	r0,r0[0x0]
80004d76:	6c 24       	ld.w	r4,r6[0x8]
80004d78:	80 00       	ld.sh	r0,r0[0x0]
80004d7a:	4b 18       	lddpc	r8,80004e3c <xnl_send_device_master_query+0x4>

80004d7c <xnl_master_status_brdcst_func>:
Description: process while receive master status boardcast.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_master_status_brdcst_func(xnl_fragment_t * xnl)
{	
80004d7c:	eb cd 40 80 	pushm	r7,lr
80004d80:	fa cd 01 00 	sub	sp,sp,256
80004d84:	18 97       	mov	r7,r12
	not an XNL_DATA_MSG has been sent out. This will indicate to a connecting 
	device that it has missed messages. The XNL header will contain the 
	master?XNL address. 5.4.1
	*/
	
	if(xnl_information.is_connected)
80004d86:	49 28       	lddpc	r8,80004dcc <xnl_master_status_brdcst_func+0x50>
80004d88:	11 88       	ld.ub	r8,r8[0x0]
80004d8a:	58 08       	cp.w	r8,0
80004d8c:	c1 c1       	brne	80004dc4 <xnl_master_status_brdcst_func+0x48>
	{
		return;	
	}
		
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);	
80004d8e:	49 18       	lddpc	r8,80004dd0 <xnl_master_status_brdcst_func+0x54>
80004d90:	70 0c       	ld.w	r12,r8[0x0]
80004d92:	30 09       	mov	r9,0
80004d94:	12 9a       	mov	r10,r9
80004d96:	12 9b       	mov	r11,r9
80004d98:	f0 1f 00 0f 	mcall	80004dd4 <xnl_master_status_brdcst_func+0x58>

	//log("xnl-ma:%4x", xnl->xnl_header.source);
	/*get the master adderss from this message*/	
	xnl_information.master_address = xnl->xnl_header.source;	
80004d9c:	8e 58       	ld.sh	r8,r7[0xa]
80004d9e:	48 c9       	lddpc	r9,80004dcc <xnl_master_status_brdcst_func+0x50>
80004da0:	b2 18       	st.h	r9[0x2],r8
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80004da2:	e0 68 40 0e 	mov	r8,16398
80004da6:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004da8:	3f f8       	mov	r8,-1
80004daa:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_AUTH_KEY_REQUEST;
80004dac:	30 4a       	mov	r10,4
80004dae:	ba 2a       	st.h	sp[0x4],r10
		
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/	
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
80004db0:	ba 38       	st.h	sp[0x6],r8
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
80004db2:	92 19       	ld.sh	r9,r9[0x2]
80004db4:	ba 49       	st.h	sp[0x8],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.source = DEFAULT_VALUE;
80004db6:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80004db8:	ba 68       	st.h	sp[0xc],r8
		
	xnl_frame.xnl_header.payload_length = 0;
80004dba:	30 08       	mov	r8,0
80004dbc:	ba 78       	st.h	sp[0xe],r8
	
	/*send XNL message*/	
	xnl_tx(&xnl_frame);
80004dbe:	1a 9c       	mov	r12,sp
80004dc0:	f0 1f 00 06 	mcall	80004dd8 <xnl_master_status_brdcst_func+0x5c>
}
80004dc4:	2c 0d       	sub	sp,-256
80004dc6:	e3 cd 80 80 	ldm	sp++,r7,pc
80004dca:	00 00       	add	r0,r0
80004dcc:	00 00       	add	r0,r0
80004dce:	0b 52       	ld.sh	r2,--r5
80004dd0:	00 00       	add	r0,r0
80004dd2:	0b 4c       	ld.w	r12,--r5
80004dd4:	80 00       	ld.sh	r0,r0[0x0]
80004dd6:	6c 24       	ld.w	r4,r6[0x8]
80004dd8:	80 00       	ld.sh	r0,r0[0x0]
80004dda:	4b 18       	lddpc	r8,80004e9c <RC522_ReadByte>

80004ddc <xnl_device_conn_reply_func>:
Description: process while receive device conn reply.
Calls:xSemaphoreGive--freestos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_conn_reply_func(xnl_fragment_t * xnl)
{
80004ddc:	eb cd 40 80 	pushm	r7,lr
80004de0:	18 97       	mov	r7,r12
	transaction ID and an 8-byte encrypted value that the device can use to 
	authenticate the master. XCMP/XNL Development Guide 5.4.6
	*/
	
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);
80004de2:	49 28       	lddpc	r8,80004e28 <xnl_device_conn_reply_func+0x4c>
80004de4:	70 0c       	ld.w	r12,r8[0x0]
80004de6:	30 09       	mov	r9,0
80004de8:	12 9a       	mov	r10,r9
80004dea:	12 9b       	mov	r11,r9
80004dec:	f0 1f 00 10 	mcall	80004e2c <xnl_device_conn_reply_func+0x50>

	/*Test result code*/
	if((xnl->xnl_payload.xnl_content_device_conn_reply.result_base & 0x0000FF00)
80004df0:	ef 18 00 10 	ld.uh	r8,r7[16]
80004df4:	10 99       	mov	r9,r8
80004df6:	e2 19 ff 00 	andl	r9,0xff00,COH
80004dfa:	e0 49 01 00 	cp.w	r9,256
80004dfe:	c0 60       	breq	80004e0a <xnl_device_conn_reply_func+0x2e>
		/*
		Rejected. The device must retry the authentication process at this 
		point by sending out a new AUTH_KEY_REQUEST message. XCMP/XNL 
		Development Guide Section 5.2.3
		*/
		xnl_master_status_brdcst_func(xnl);			
80004e00:	0e 9c       	mov	r12,r7
80004e02:	f0 1f 00 0c 	mcall	80004e30 <xnl_device_conn_reply_func+0x54>
80004e06:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/*connection accepted*/		
		/*Record Transaction ID Base*/
		xnl_information.transaction_id =  
80004e0a:	a9 68       	lsl	r8,0x8
80004e0c:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
80004e10:	48 98       	lddpc	r8,80004e34 <xnl_device_conn_reply_func+0x58>
80004e12:	b0 49       	st.h	r8[0x8],r9
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
80004e14:	ef 09 00 14 	ld.sh	r9,r7[20]
		xnl_information.transaction_id =  
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
80004e18:	b0 39       	st.h	r8[0x6],r9
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
80004e1a:	ef 09 00 12 	ld.sh	r9,r7[18]
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
80004e1e:	b0 29       	st.h	r8[0x4],r9
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
		
		/*connect finish*/
		xnl_information.is_connected = TRUE;
80004e20:	30 19       	mov	r9,1
80004e22:	b0 89       	st.b	r8[0x0],r9
80004e24:	e3 cd 80 80 	ldm	sp++,r7,pc
80004e28:	00 00       	add	r0,r0
80004e2a:	0b 4c       	ld.w	r12,--r5
80004e2c:	80 00       	ld.sh	r0,r0[0x0]
80004e2e:	6c 24       	ld.w	r4,r6[0x8]
80004e30:	80 00       	ld.sh	r0,r0[0x0]
80004e32:	4d 7c       	lddpc	r12,80004f8c <PcdReset+0x54>
80004e34:	00 00       	add	r0,r0
80004e36:	0b 52       	ld.sh	r2,--r5

80004e38 <xnl_send_device_master_query>:
Description: send device_master_query to connect radio.
Calls:xnl_tx
Call By:xnl_init
*/
void xnl_send_device_master_query(void)
{
80004e38:	d4 01       	pushm	lr
80004e3a:	fa cd 01 00 	sub	sp,sp,256
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80004e3e:	e0 68 40 0e 	mov	r8,16398
80004e42:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004e44:	3f f8       	mov	r8,-1
80004e46:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_MASTER_QUERY;
80004e48:	30 38       	mov	r8,3
80004e4a:	ba 28       	st.h	sp[0x4],r8
	
	/*The initial value*/
	xnl_frame.xnl_header.flags = 0;
80004e4c:	30 08       	mov	r8,0
80004e4e:	ba 38       	st.h	sp[0x6],r8
	
	/*XNL address of the master device, if known;otherwise 0x0000*/
	xnl_frame.xnl_header.destination = 0;
80004e50:	ba 48       	st.h	sp[0x8],r8
	
	/*XNL address, if assigned; otherwise 0x0000*/
	xnl_frame.xnl_header.source = 0;
80004e52:	ba 58       	st.h	sp[0xa],r8
	
	/*No transaction ID required for this message*/
	xnl_frame.xnl_header.transaction_id = 0;
80004e54:	ba 68       	st.h	sp[0xc],r8
	
	/*This message contains no payload*/
	xnl_frame.xnl_header.payload_length = 0;
80004e56:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004e58:	1a 9c       	mov	r12,sp
80004e5a:	f0 1f 00 03 	mcall	80004e64 <xnl_send_device_master_query+0x2c>
}
80004e5e:	2c 0d       	sub	sp,-256
80004e60:	d8 02       	popm	pc
80004e62:	00 00       	add	r0,r0
80004e64:	80 00       	ld.sh	r0,r0[0x0]
80004e66:	4b 18       	lddpc	r8,80004f28 <WriteRawRC+0x30>

80004e68 <RC522_SPI_SetSpeed>:
	//SET_SPI_CS;

}

void RC522_SPI_SetSpeed(U16 SPI_BaudRatePrescaler)
{
80004e68:	d4 01       	pushm	lr
	spi->csr0 = (spi->csr0 & (U16)0x00FF) |SPI_BaudRatePrescaler;
80004e6a:	48 78       	lddpc	r8,80004e84 <RC522_SPI_SetSpeed+0x1c>
80004e6c:	70 09       	ld.w	r9,r8[0x0]
80004e6e:	72 ca       	ld.w	r10,r9[0x30]
80004e70:	5c 7c       	castu.h	r12
80004e72:	f5 da c0 08 	bfextu	r10,r10,0x0,0x8
80004e76:	f9 ea 10 0a 	or	r10,r12,r10
80004e7a:	93 ca       	st.w	r9[0x30],r10

	spi_enable(spi); /*!< SD_SPI enable */
80004e7c:	70 0c       	ld.w	r12,r8[0x0]
80004e7e:	f0 1f 00 03 	mcall	80004e88 <RC522_SPI_SetSpeed+0x20>
		
	
}
80004e82:	d8 02       	popm	pc
80004e84:	00 00       	add	r0,r0
80004e86:	20 90       	sub	r0,9
80004e88:	80 00       	ld.sh	r0,r0[0x0]
80004e8a:	61 14       	ld.w	r4,r0[0x44]

80004e8c <RC522_SPI_SetSpeedLow>:
void RC522_SPI_SetSpeedLow(void)
{
80004e8c:	d4 01       	pushm	lr
	RC522_SPI_SetSpeed(0x0400);//baudDiv=4
80004e8e:	e0 6c 04 00 	mov	r12,1024
80004e92:	f0 1f 00 02 	mcall	80004e98 <RC522_SPI_SetSpeedLow+0xc>
	
}
80004e96:	d8 02       	popm	pc
80004e98:	80 00       	ld.sh	r0,r0[0x0]
80004e9a:	4e 68       	lddpc	r8,80005030 <Powerdown_RC522+0x20>

80004e9c <RC522_ReadByte>:
	/*!< Return the byte read from the SPI bus */
	return  temp;

}
U8 RC522_ReadByte(void)
{
80004e9c:	eb cd 40 c0 	pushm	r6-r7,lr
	//蹇椤昏锋芥ｅ父璇诲
	//spi_selectChip(spi, DF_SPI_PCS_0);
	
	/*!< Send the byte */

	spi_write(spi,  0xFF);
80004ea0:	48 76       	lddpc	r6,80004ebc <RC522_ReadByte+0x20>
80004ea2:	e0 6b 00 ff 	mov	r11,255
80004ea6:	6c 0c       	ld.w	r12,r6[0x0]
80004ea8:	f0 1f 00 06 	mcall	80004ec0 <RC522_ReadByte+0x24>
	
	/*!< Return the byte read from the SPI bus */

	spi_read(spi, Data);
80004eac:	30 07       	mov	r7,0
80004eae:	0e 9b       	mov	r11,r7
80004eb0:	6c 0c       	ld.w	r12,r6[0x0]
80004eb2:	f0 1f 00 05 	mcall	80004ec4 <RC522_ReadByte+0x28>
	
	//spi_unselectChip(spi, DF_SPI_PCS_0);
	
	return (U8)(*Data);
	
}
80004eb6:	0f 9c       	ld.ub	r12,r7[0x1]
80004eb8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004ebc:	00 00       	add	r0,r0
80004ebe:	20 90       	sub	r0,9
80004ec0:	80 00       	ld.sh	r0,r0[0x0]
80004ec2:	61 1a       	ld.w	r10,r0[0x44]
80004ec4:	80 00       	ld.sh	r0,r0[0x0]
80004ec6:	61 36       	ld.w	r6,r0[0x4c]

80004ec8 <RC522_WriteByte>:


U8 rc522_init_failure =0;

U8 RC522_WriteByte(U8 Data)
{
80004ec8:	eb cd 40 80 	pushm	r7,lr
80004ecc:	20 1d       	sub	sp,4
80004ece:	ba 8c       	st.b	sp[0x0],r12
	U8 temp =0;
	
	//spi_selectChip(spi, DF_SPI_PCS_0);
	
	/*!< Send the byte */
	spi_write(spi,  (U16)Data);
80004ed0:	48 77       	lddpc	r7,80004eec <RC522_WriteByte+0x24>
80004ed2:	f7 dc c0 08 	bfextu	r11,r12,0x0,0x8
80004ed6:	6e 0c       	ld.w	r12,r7[0x0]
80004ed8:	f0 1f 00 06 	mcall	80004ef0 <RC522_WriteByte+0x28>
	
	/*!< Wait to receive a byte*/

	temp = spi_read(spi, (U16*)&Data);
80004edc:	1a 9b       	mov	r11,sp
80004ede:	6e 0c       	ld.w	r12,r7[0x0]
80004ee0:	f0 1f 00 05 	mcall	80004ef4 <RC522_WriteByte+0x2c>
	//spi_unselectChip(spi, DF_SPI_PCS_0);
	
	/*!< Return the byte read from the SPI bus */
	return  temp;

}
80004ee4:	5c 5c       	castu.b	r12
80004ee6:	2f fd       	sub	sp,-4
80004ee8:	e3 cd 80 80 	ldm	sp++,r7,pc
80004eec:	00 00       	add	r0,r0
80004eee:	20 90       	sub	r0,9
80004ef0:	80 00       	ld.sh	r0,r0[0x0]
80004ef2:	61 1a       	ld.w	r10,r0[0x44]
80004ef4:	80 00       	ld.sh	r0,r0[0x0]
80004ef6:	61 36       	ld.w	r6,r0[0x4c]

80004ef8 <WriteRawRC>:
//    斤RC632瀵瀛
//拌存锛Address[IN]:瀵瀛ㄥ板
//          value[IN]:ョ
/////////////////////////////////////////////////////////////////////
void WriteRawRC(U8   Address, U8   value)
{
80004ef8:	eb cd 40 e0 	pushm	r5-r7,lr
80004efc:	18 96       	mov	r6,r12
80004efe:	16 95       	mov	r5,r11
	U8   ucAddr;

	//CLR_SPI_CS;	
	spi_selectChip(spi, DF_SPI_PCS_0);
80004f00:	48 a7       	lddpc	r7,80004f28 <WriteRawRC+0x30>
80004f02:	30 0b       	mov	r11,0
80004f04:	6e 0c       	ld.w	r12,r7[0x0]
80004f06:	f0 1f 00 0a 	mcall	80004f2c <WriteRawRC+0x34>
	
	ucAddr = ((Address<<1)&0x7E);
	RC522_WriteByte(ucAddr);
80004f0a:	ec 0c 15 01 	lsl	r12,r6,0x1
80004f0e:	e2 1c 00 7e 	andl	r12,0x7e,COH
80004f12:	f0 1f 00 08 	mcall	80004f30 <WriteRawRC+0x38>
	RC522_WriteByte(value);
80004f16:	0a 9c       	mov	r12,r5
80004f18:	f0 1f 00 06 	mcall	80004f30 <WriteRawRC+0x38>
	
	spi_unselectChip(spi, DF_SPI_PCS_0);
80004f1c:	30 0b       	mov	r11,0
80004f1e:	6e 0c       	ld.w	r12,r7[0x0]
80004f20:	f0 1f 00 05 	mcall	80004f34 <WriteRawRC+0x3c>
	
	//SET_SPI_CS;

}
80004f24:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80004f28:	00 00       	add	r0,r0
80004f2a:	20 90       	sub	r0,9
80004f2c:	80 00       	ld.sh	r0,r0[0x0]
80004f2e:	62 80       	ld.w	r0,r1[0x20]
80004f30:	80 00       	ld.sh	r0,r0[0x0]
80004f32:	4e c8       	lddpc	r8,800050e0 <M500PcdConfigISOType+0x8>
80004f34:	80 00       	ld.sh	r0,r0[0x0]
80004f36:	62 40       	ld.w	r0,r1[0x10]

80004f38 <PcdReset>:
/////////////////////////////////////////////////////////////////////
//    斤澶浣RC522
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdReset(void)
{
80004f38:	d4 01       	pushm	lr

	SET_RC522RST;
80004f3a:	31 9c       	mov	r12,25
80004f3c:	f0 1f 00 1b 	mcall	80004fa8 <PcdReset+0x70>
	delay_ns(10);
80004f40:	30 ac       	mov	r12,10
80004f42:	f0 1f 00 1b 	mcall	80004fac <PcdReset+0x74>

	CLR_RC522RST;
80004f46:	31 9c       	mov	r12,25
80004f48:	f0 1f 00 1a 	mcall	80004fb0 <PcdReset+0x78>
	delay_ns(10);
80004f4c:	30 ac       	mov	r12,10
80004f4e:	f0 1f 00 18 	mcall	80004fac <PcdReset+0x74>

	SET_RC522RST;
80004f52:	31 9c       	mov	r12,25
80004f54:	f0 1f 00 15 	mcall	80004fa8 <PcdReset+0x70>
	delay_ns(10);
80004f58:	30 ac       	mov	r12,10
80004f5a:	f0 1f 00 15 	mcall	80004fac <PcdReset+0x74>
	WriteRawRC(CommandReg,PCD_RESETPHASE);
80004f5e:	30 fb       	mov	r11,15
80004f60:	30 1c       	mov	r12,1
80004f62:	f0 1f 00 15 	mcall	80004fb4 <PcdReset+0x7c>
	WriteRawRC(CommandReg,PCD_RESETPHASE);
80004f66:	30 fb       	mov	r11,15
80004f68:	30 1c       	mov	r12,1
80004f6a:	f0 1f 00 13 	mcall	80004fb4 <PcdReset+0x7c>
	delay_ns(10);
80004f6e:	30 ac       	mov	r12,10
80004f70:	f0 1f 00 0f 	mcall	80004fac <PcdReset+0x74>
	
	WriteRawRC(ModeReg,0x3D);            //Mifare￠璁锛CRC濮0x6363
80004f74:	33 db       	mov	r11,61
80004f76:	31 1c       	mov	r12,17
80004f78:	f0 1f 00 0f 	mcall	80004fb4 <PcdReset+0x7c>
	WriteRawRC(TReloadRegL,30);
80004f7c:	31 eb       	mov	r11,30
80004f7e:	32 dc       	mov	r12,45
80004f80:	f0 1f 00 0d 	mcall	80004fb4 <PcdReset+0x7c>
	WriteRawRC(TReloadRegH,0);
80004f84:	30 0b       	mov	r11,0
80004f86:	32 cc       	mov	r12,44
80004f88:	f0 1f 00 0b 	mcall	80004fb4 <PcdReset+0x7c>
	WriteRawRC(TModeReg,0x8D);
80004f8c:	e0 6b 00 8d 	mov	r11,141
80004f90:	32 ac       	mov	r12,42
80004f92:	f0 1f 00 09 	mcall	80004fb4 <PcdReset+0x7c>
	WriteRawRC(TPrescalerReg,0x3E);
80004f96:	33 eb       	mov	r11,62
80004f98:	32 bc       	mov	r12,43
80004f9a:	f0 1f 00 07 	mcall	80004fb4 <PcdReset+0x7c>
	
	WriteRawRC(TxAutoReg,0x40);//蹇椤昏
80004f9e:	34 0b       	mov	r11,64
80004fa0:	31 5c       	mov	r12,21
80004fa2:	f0 1f 00 05 	mcall	80004fb4 <PcdReset+0x7c>
	
	return MI_OK;
}
80004fa6:	d8 0a       	popm	pc,r12=0
80004fa8:	80 00       	ld.sh	r0,r0[0x0]
80004faa:	5c 88       	casts.h	r8
80004fac:	80 00       	ld.sh	r0,r0[0x0]
80004fae:	58 44       	cp.w	r4,4
80004fb0:	80 00       	ld.sh	r0,r0[0x0]
80004fb2:	5c a4       	swap.h	r4
80004fb4:	80 00       	ld.sh	r0,r0[0x0]
80004fb6:	4e f8       	lddpc	r8,80005170 <rc522_init+0x28>

80004fb8 <ReadRawRC>:
//    斤璇RC632瀵瀛
//拌存锛Address[IN]:瀵瀛ㄥ板
//杩    锛璇诲虹
/////////////////////////////////////////////////////////////////////
U8 ReadRawRC(U8   Address)
{
80004fb8:	eb cd 40 c0 	pushm	r6-r7,lr
80004fbc:	18 96       	mov	r6,r12
	U8   ucAddr;
	U8   ucResult=0;
	//CLR_SPI_CS;	
	spi_selectChip(spi, DF_SPI_PCS_0);
80004fbe:	48 c7       	lddpc	r7,80004fec <ReadRawRC+0x34>
80004fc0:	30 0b       	mov	r11,0
80004fc2:	6e 0c       	ld.w	r12,r7[0x0]
80004fc4:	f0 1f 00 0b 	mcall	80004ff0 <ReadRawRC+0x38>
	 
	ucAddr = ((Address<<1)&0x7E)|0x80;
	
	RC522_WriteByte(ucAddr);
80004fc8:	a1 76       	lsl	r6,0x1
80004fca:	0c 9c       	mov	r12,r6
80004fcc:	e2 1c 00 7e 	andl	r12,0x7e,COH
80004fd0:	a7 bc       	sbr	r12,0x7
80004fd2:	f0 1f 00 09 	mcall	80004ff4 <ReadRawRC+0x3c>
	ucResult = RC522_ReadByte();
80004fd6:	f0 1f 00 09 	mcall	80004ff8 <ReadRawRC+0x40>
80004fda:	18 96       	mov	r6,r12
	
	spi_unselectChip(spi, DF_SPI_PCS_0);
80004fdc:	30 0b       	mov	r11,0
80004fde:	6e 0c       	ld.w	r12,r7[0x0]
80004fe0:	f0 1f 00 07 	mcall	80004ffc <ReadRawRC+0x44>
	//SET_SPI_CS;
	return ucResult;
}
80004fe4:	0c 9c       	mov	r12,r6
80004fe6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004fea:	00 00       	add	r0,r0
80004fec:	00 00       	add	r0,r0
80004fee:	20 90       	sub	r0,9
80004ff0:	80 00       	ld.sh	r0,r0[0x0]
80004ff2:	62 80       	ld.w	r0,r1[0x20]
80004ff4:	80 00       	ld.sh	r0,r0[0x0]
80004ff6:	4e c8       	lddpc	r8,800051a4 <rc522_init+0x5c>
80004ff8:	80 00       	ld.sh	r0,r0[0x0]
80004ffa:	4e 9c       	lddpc	r12,8000519c <rc522_init+0x54>
80004ffc:	80 00       	ld.sh	r0,r0[0x0]
80004ffe:	62 40       	ld.w	r0,r1[0x10]

80005000 <Wait_Wakeup_RC522>:

/////////////////////////////////////////////////////////////////////
//    斤绛寰RC522
/////////////////////////////////////////////////////////////////////
void Wait_Wakeup_RC522(void)
{
80005000:	d4 01       	pushm	lr
	char   tmp = 0x0;
	char   reg = CommandReg;
	
	do 
	{
		tmp = ReadRawRC(reg);
80005002:	30 1c       	mov	r12,1
80005004:	f0 1f 00 02 	mcall	8000500c <Wait_Wakeup_RC522+0xc>
			
	//tmp = ReadRawRC(reg);
	//if((tmp & 0x10) == 0)
	//WriteRawRC(reg,tmp | PCD_POWERDOWN);  // set bit powerdown
	
}
80005008:	d8 02       	popm	pc
8000500a:	00 00       	add	r0,r0
8000500c:	80 00       	ld.sh	r0,r0[0x0]
8000500e:	4f b8       	lddpc	r8,800051f8 <rc522_init+0xb0>

80005010 <Powerdown_RC522>:
/////////////////////////////////////////////////////////////////////
//    斤浣RC522杩ヨ蒋垫ā寮
//
/////////////////////////////////////////////////////////////////////
void Powerdown_RC522(U8 act)
{
80005010:	eb cd 40 80 	pushm	r7,lr
80005014:	18 97       	mov	r7,r12
	char   tmp = 0x0;
	char   reg = CommandReg;
	
	tmp = ReadRawRC(reg);
80005016:	30 1c       	mov	r12,1
80005018:	f0 1f 00 0d 	mcall	8000504c <Powerdown_RC522+0x3c>
	if(act == ENTER_POWERDOWN)//1
8000501c:	30 18       	mov	r8,1
8000501e:	f0 07 18 00 	cp.b	r7,r8
80005022:	c0 91       	brne	80005034 <Powerdown_RC522+0x24>
		WriteRawRC(reg,tmp | PCD_POWERDOWN);  // set bit powerdown
80005024:	18 9b       	mov	r11,r12
80005026:	a5 ab       	sbr	r11,0x4
80005028:	5c 5b       	castu.b	r11
8000502a:	30 1c       	mov	r12,1
8000502c:	f0 1f 00 09 	mcall	80005050 <Powerdown_RC522+0x40>
80005030:	e3 cd 80 80 	ldm	sp++,r7,pc
	else
	{
		WriteRawRC(reg,tmp | PCD_IDLE);  // wake up rc522
80005034:	18 9b       	mov	r11,r12
80005036:	30 1c       	mov	r12,1
80005038:	f0 1f 00 06 	mcall	80005050 <Powerdown_RC522+0x40>
		delay_ns(2);
8000503c:	30 2c       	mov	r12,2
8000503e:	f0 1f 00 06 	mcall	80005054 <Powerdown_RC522+0x44>
		Wait_Wakeup_RC522();
80005042:	f0 1f 00 06 	mcall	80005058 <Powerdown_RC522+0x48>
80005046:	e3 cd 80 80 	ldm	sp++,r7,pc
8000504a:	00 00       	add	r0,r0
8000504c:	80 00       	ld.sh	r0,r0[0x0]
8000504e:	4f b8       	lddpc	r8,80005238 <PcdComMF522+0x18>
80005050:	80 00       	ld.sh	r0,r0[0x0]
80005052:	4e f8       	lddpc	r8,8000520c <rc522_init+0xc4>
80005054:	80 00       	ld.sh	r0,r0[0x0]
80005056:	58 44       	cp.w	r4,4
80005058:	80 00       	ld.sh	r0,r0[0x0]
8000505a:	50 00       	stdsp	sp[0x0],r0

8000505c <SetBitMask>:
//    斤缃RC522瀵瀛ㄤ
//拌存锛reg[IN]:瀵瀛ㄥ板
//          mask[IN]:缃浣
/////////////////////////////////////////////////////////////////////
void SetBitMask(U8   reg,U8   mask)
{
8000505c:	eb cd 40 c0 	pushm	r6-r7,lr
80005060:	18 97       	mov	r7,r12
80005062:	16 96       	mov	r6,r11
	char   tmp = 0x0;
	tmp = ReadRawRC(reg);
80005064:	f0 1f 00 05 	mcall	80005078 <SetBitMask+0x1c>
	WriteRawRC(reg,tmp | mask);  // set bit mask
80005068:	f9 e6 10 0b 	or	r11,r12,r6
8000506c:	5c 5b       	castu.b	r11
8000506e:	0e 9c       	mov	r12,r7
80005070:	f0 1f 00 03 	mcall	8000507c <SetBitMask+0x20>
}
80005074:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005078:	80 00       	ld.sh	r0,r0[0x0]
8000507a:	4f b8       	lddpc	r8,80005264 <PcdComMF522+0x44>
8000507c:	80 00       	ld.sh	r0,r0[0x0]
8000507e:	4e f8       	lddpc	r8,80005238 <PcdComMF522+0x18>

80005080 <PcdAntennaOn>:
/////////////////////////////////////////////////////////////////////
//寮澶╃嚎
//姣娆″ㄦ抽澶╅╁灏涔村冲1ms撮
/////////////////////////////////////////////////////////////////////
void PcdAntennaOn(void)
{
80005080:	d4 01       	pushm	lr
	U8   i;
	i = ReadRawRC(TxControlReg);
80005082:	31 4c       	mov	r12,20
80005084:	f0 1f 00 05 	mcall	80005098 <PcdAntennaOn+0x18>
	if (!(i & 0x03))
80005088:	f9 dc c0 02 	bfextu	r12,r12,0x0,0x2
8000508c:	c0 51       	brne	80005096 <PcdAntennaOn+0x16>
	{
		SetBitMask(TxControlReg, 0x03);
8000508e:	30 3b       	mov	r11,3
80005090:	31 4c       	mov	r12,20
80005092:	f0 1f 00 03 	mcall	8000509c <PcdAntennaOn+0x1c>
80005096:	d8 02       	popm	pc
80005098:	80 00       	ld.sh	r0,r0[0x0]
8000509a:	4f b8       	lddpc	r8,80005284 <PcdComMF522+0x64>
8000509c:	80 00       	ld.sh	r0,r0[0x0]
8000509e:	50 5c       	stdsp	sp[0x14],r12

800050a0 <ClearBitMask>:
//    斤娓RC522瀵瀛ㄤ
//拌存锛reg[IN]:瀵瀛ㄥ板
//         mask[IN]:娓浣
/////////////////////////////////////////////////////////////////////
void ClearBitMask(U8   reg,U8   mask)
{
800050a0:	eb cd 40 c0 	pushm	r6-r7,lr
800050a4:	18 97       	mov	r7,r12
800050a6:	16 96       	mov	r6,r11
	  char   tmp = 0x0;
	  tmp = ReadRawRC(reg);
800050a8:	f0 1f 00 06 	mcall	800050c0 <ClearBitMask+0x20>
	  WriteRawRC(reg, tmp & ~mask);  // clear bit mask
800050ac:	5c d6       	com	r6
800050ae:	f9 e6 00 06 	and	r6,r12,r6
800050b2:	f7 d6 c0 08 	bfextu	r11,r6,0x0,0x8
800050b6:	0e 9c       	mov	r12,r7
800050b8:	f0 1f 00 03 	mcall	800050c4 <ClearBitMask+0x24>
	
}
800050bc:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800050c0:	80 00       	ld.sh	r0,r0[0x0]
800050c2:	4f b8       	lddpc	r8,800052ac <PcdComMF522+0x8c>
800050c4:	80 00       	ld.sh	r0,r0[0x0]
800050c6:	4e f8       	lddpc	r8,80005280 <PcdComMF522+0x60>

800050c8 <PcdAntennaOff>:

/////////////////////////////////////////////////////////////////////
//抽澶╃嚎
/////////////////////////////////////////////////////////////////////
void PcdAntennaOff(void)
{
800050c8:	d4 01       	pushm	lr
	ClearBitMask(TxControlReg, 0x03);
800050ca:	30 3b       	mov	r11,3
800050cc:	31 4c       	mov	r12,20
800050ce:	f0 1f 00 02 	mcall	800050d4 <PcdAntennaOff+0xc>
}
800050d2:	d8 02       	popm	pc
800050d4:	80 00       	ld.sh	r0,r0[0x0]
800050d6:	50 a0       	stdsp	sp[0x28],r0

800050d8 <M500PcdConfigISOType>:

//////////////////////////////////////////////////////////////////////
//璁剧疆RC632宸ヤ瑰
//////////////////////////////////////////////////////////////////////
char M500PcdConfigISOType(U8   type)
{
800050d8:	d4 01       	pushm	lr
	if (type == 'A')                     //ISO14443_A
800050da:	34 18       	mov	r8,65
800050dc:	f0 0c 18 00 	cp.b	r12,r8
800050e0:	c0 20       	breq	800050e4 <M500PcdConfigISOType+0xc>
800050e2:	da 0a       	popm	pc,r12=1
	{
		ClearBitMask(Status2Reg,0x08);
800050e4:	30 8b       	mov	r11,8
800050e6:	16 9c       	mov	r12,r11
800050e8:	f0 1f 00 14 	mcall	80005138 <M500PcdConfigISOType+0x60>
		WriteRawRC(ModeReg,0x3D);//3F
800050ec:	33 db       	mov	r11,61
800050ee:	31 1c       	mov	r12,17
800050f0:	f0 1f 00 13 	mcall	8000513c <M500PcdConfigISOType+0x64>
		WriteRawRC(RxSelReg,0x86);//84
800050f4:	e0 6b 00 86 	mov	r11,134
800050f8:	31 7c       	mov	r12,23
800050fa:	f0 1f 00 11 	mcall	8000513c <M500PcdConfigISOType+0x64>
		WriteRawRC(RFCfgReg,0x7F);   //4F
800050fe:	37 fb       	mov	r11,127
80005100:	32 6c       	mov	r12,38
80005102:	f0 1f 00 0f 	mcall	8000513c <M500PcdConfigISOType+0x64>
		WriteRawRC(TReloadRegL,30);//tmoLength);// TReloadVal = 'h6a =tmoLength(dec)
80005106:	31 eb       	mov	r11,30
80005108:	32 dc       	mov	r12,45
8000510a:	f0 1f 00 0d 	mcall	8000513c <M500PcdConfigISOType+0x64>
		WriteRawRC(TReloadRegH,0);
8000510e:	30 0b       	mov	r11,0
80005110:	32 cc       	mov	r12,44
80005112:	f0 1f 00 0b 	mcall	8000513c <M500PcdConfigISOType+0x64>
		WriteRawRC(TModeReg,0x8D);
80005116:	e0 6b 00 8d 	mov	r11,141
8000511a:	32 ac       	mov	r12,42
8000511c:	f0 1f 00 08 	mcall	8000513c <M500PcdConfigISOType+0x64>
		WriteRawRC(TPrescalerReg,0x3E);
80005120:	33 eb       	mov	r11,62
80005122:	32 bc       	mov	r12,43
80005124:	f0 1f 00 06 	mcall	8000513c <M500PcdConfigISOType+0x64>
		delay_ns(1000);
80005128:	e0 6c 03 e8 	mov	r12,1000
8000512c:	f0 1f 00 05 	mcall	80005140 <M500PcdConfigISOType+0x68>
		PcdAntennaOn();
80005130:	f0 1f 00 05 	mcall	80005144 <M500PcdConfigISOType+0x6c>
80005134:	d8 0a       	popm	pc,r12=0
80005136:	00 00       	add	r0,r0
80005138:	80 00       	ld.sh	r0,r0[0x0]
8000513a:	50 a0       	stdsp	sp[0x28],r0
8000513c:	80 00       	ld.sh	r0,r0[0x0]
8000513e:	4e f8       	lddpc	r8,800052f8 <PcdComMF522+0xd8>
80005140:	80 00       	ld.sh	r0,r0[0x0]
80005142:	58 44       	cp.w	r4,4
80005144:	80 00       	ld.sh	r0,r0[0x0]
80005146:	50 80       	stdsp	sp[0x20],r0

80005148 <rc522_init>:


//mfrc522 init

void rc522_init()
{
80005148:	eb cd 40 c0 	pushm	r6-r7,lr
8000514c:	20 4d       	sub	sp,16
		.spck_delay   = 0,
		.trans_delay  = 0,
		.stay_act     = 1,
		.spi_mode     = 0,
		.modfdis      = 1
	};
8000514e:	4a 38       	lddpc	r8,800051d8 <rc522_init+0x90>
80005150:	1a 96       	mov	r6,sp
80005152:	f0 ea 00 00 	ld.d	r10,r8[0]
80005156:	fa eb 00 00 	st.d	sp[0],r10
8000515a:	f0 e8 00 08 	ld.d	r8,r8[8]
8000515e:	fa e9 00 08 	st.d	sp[8],r8

	// Assign I/Os to SPI.
	gpio_enable_module(RC522_SPI_GPIO_MAP, sizeof(RC522_SPI_GPIO_MAP) / sizeof(RC522_SPI_GPIO_MAP[0]));
80005162:	30 4b       	mov	r11,4
80005164:	49 ec       	lddpc	r12,800051dc <rc522_init+0x94>
80005166:	f0 1f 00 1f 	mcall	800051e0 <rc522_init+0x98>

	// Configure PA25 as RST pin
	gpio_enable_gpio_pin(AVR32_PIN_PA25);
8000516a:	31 9c       	mov	r12,25
8000516c:	f0 1f 00 1e 	mcall	800051e4 <rc522_init+0x9c>
	gpio_set_gpio_pin(AVR32_PIN_PA25);
80005170:	31 9c       	mov	r12,25
80005172:	f0 1f 00 1e 	mcall	800051e8 <rc522_init+0xa0>
	
	//gpio_enable_gpio_pin(AVR32_PIN_PA24);

	spi = &AVR32_SPI;
80005176:	49 e7       	lddpc	r7,800051ec <rc522_init+0xa4>
80005178:	fe 7c 24 00 	mov	r12,-56320
8000517c:	8f 0c       	st.w	r7[0x0],r12

	// Initialize as master.
	spi_initMaster(spi, &spiOptions);
8000517e:	1a 9b       	mov	r11,sp
80005180:	f0 1f 00 1c 	mcall	800051f0 <rc522_init+0xa8>

	// Set selection mode: variable_ps, pcs_decode, delay.
	spi_selectionMode(spi, 0, 0, 0);
80005184:	30 09       	mov	r9,0
80005186:	12 9a       	mov	r10,r9
80005188:	12 9b       	mov	r11,r9
8000518a:	6e 0c       	ld.w	r12,r7[0x0]
8000518c:	f0 1f 00 1a 	mcall	800051f4 <rc522_init+0xac>

	// Enable SPI.
	spi_enable(spi);
80005190:	6e 0c       	ld.w	r12,r7[0x0]
80005192:	f0 1f 00 1a 	mcall	800051f8 <rc522_init+0xb0>

	// Initialize RC522 with SPI clock PBA.
	if (spi_setupChipReg(spi, &spiOptions, 2*12000000) != SPI_OK)
80005196:	e0 6a 36 00 	mov	r10,13824
8000519a:	ea 1a 01 6e 	orh	r10,0x16e
8000519e:	1a 9b       	mov	r11,sp
800051a0:	6e 0c       	ld.w	r12,r7[0x0]
800051a2:	f0 1f 00 17 	mcall	800051fc <rc522_init+0xb4>
800051a6:	c0 50       	breq	800051b0 <rc522_init+0x68>
	{
		
		rc522_init_failure = FATAL_ERROR_RC522_SPI_INIT;
800051a8:	30 29       	mov	r9,2
800051aa:	49 68       	lddpc	r8,80005200 <rc522_init+0xb8>
800051ac:	b0 89       	st.b	r8[0x0],r9
800051ae:	c0 38       	rjmp	800051b4 <rc522_init+0x6c>
		return;
	}
	
	RC522_SPI_SetSpeedLow();
800051b0:	f0 1f 00 15 	mcall	80005204 <rc522_init+0xbc>
void rc522_init()
{
	
	spi_init();
	
	PcdReset();
800051b4:	f0 1f 00 15 	mcall	80005208 <rc522_init+0xc0>
	
	PcdAntennaOff();
800051b8:	f0 1f 00 15 	mcall	8000520c <rc522_init+0xc4>
	
	delay_ms(2); 
800051bc:	30 2c       	mov	r12,2
800051be:	f0 1f 00 15 	mcall	80005210 <rc522_init+0xc8>
	
	PcdAntennaOn();
800051c2:	f0 1f 00 15 	mcall	80005214 <rc522_init+0xcc>
	
	M500PcdConfigISOType( 'A' );
800051c6:	34 1c       	mov	r12,65
800051c8:	f0 1f 00 14 	mcall	80005218 <rc522_init+0xd0>
	
	Powerdown_RC522(ENTER_POWERDOWN);
800051cc:	30 1c       	mov	r12,1
800051ce:	f0 1f 00 14 	mcall	8000521c <rc522_init+0xd4>
	//Powerdown_RC522(ENTER_POWERDOWN);
	
	//Powerdown_RC522(WAKEUP_RC522);
	

800051d2:	2f cd       	sub	sp,-16
800051d4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800051d8:	80 00       	ld.sh	r0,r0[0x0]
800051da:	e0 34 80 00 	sub	r4,98304
800051de:	e0 4c 80 00 	cp.w	r12,32768
800051e2:	5c 40       	abs	r0
800051e4:	80 00       	ld.sh	r0,r0[0x0]
800051e6:	5c 70       	castu.h	r0
800051e8:	80 00       	ld.sh	r0,r0[0x0]
800051ea:	5c 88       	casts.h	r8
800051ec:	00 00       	add	r0,r0
800051ee:	20 90       	sub	r0,9
800051f0:	80 00       	ld.sh	r0,r0[0x0]
800051f2:	60 b0       	ld.w	r0,r0[0x2c]
800051f4:	80 00       	ld.sh	r0,r0[0x0]
800051f6:	60 e8       	ld.w	r8,r0[0x38]
800051f8:	80 00       	ld.sh	r0,r0[0x0]
800051fa:	61 14       	ld.w	r4,r0[0x44]
800051fc:	80 00       	ld.sh	r0,r0[0x0]
800051fe:	61 58       	ld.w	r8,r0[0x54]
80005200:	00 00       	add	r0,r0
80005202:	0b 70       	ld.ub	r0,--r5
80005204:	80 00       	ld.sh	r0,r0[0x0]
80005206:	4e 8c       	lddpc	r12,800053a4 <PcdAnticoll+0xc>
80005208:	80 00       	ld.sh	r0,r0[0x0]
8000520a:	4f 38       	lddpc	r8,800053d4 <PcdAnticoll+0x3c>
8000520c:	80 00       	ld.sh	r0,r0[0x0]
8000520e:	50 c8       	stdsp	sp[0x30],r8
80005210:	80 00       	ld.sh	r0,r0[0x0]
80005212:	58 84       	cp.w	r4,8
80005214:	80 00       	ld.sh	r0,r0[0x0]
80005216:	50 80       	stdsp	sp[0x20],r0
80005218:	80 00       	ld.sh	r0,r0[0x0]
8000521a:	50 d8       	stdsp	sp[0x34],r8
8000521c:	80 00       	ld.sh	r0,r0[0x0]
8000521e:	50 10       	stdsp	sp[0x4],r0

80005220 <PcdComMF522>:
char PcdComMF522(U8  Command,
				 U8 *pIn ,
				 U8  InLenByte,
				 U8 *pOut ,
				 U8 *pOutLenBit)
{
80005220:	d4 31       	pushm	r0-r7,lr
80005222:	20 1d       	sub	sp,4
80005224:	18 92       	mov	r2,r12
80005226:	16 95       	mov	r5,r11
80005228:	14 96       	mov	r6,r10
8000522a:	50 09       	stdsp	sp[0x0],r9
8000522c:	10 90       	mov	r0,r8
8000522e:	f8 c8 00 0c 	sub	r8,r12,12
80005232:	5c 58       	castu.b	r8
80005234:	30 29       	mov	r9,2
80005236:	f2 08 18 00 	cp.b	r8,r9
8000523a:	e0 88 00 05 	brls	80005244 <PcdComMF522+0x24>
8000523e:	30 03       	mov	r3,0
80005240:	06 91       	mov	r1,r3
80005242:	c0 78       	rjmp	80005250 <PcdComMF522+0x30>
80005244:	4c f9       	lddpc	r9,80005380 <PcdComMF522+0x160>
80005246:	f2 08 07 01 	ld.ub	r1,r9[r8]
8000524a:	4c f9       	lddpc	r9,80005384 <PcdComMF522+0x164>
8000524c:	f2 08 07 03 	ld.ub	r3,r9[r8]
		break;
		default:
		break;
	}
	
	WriteRawRC(ComIEnReg,irqEn|0x80);
80005250:	02 9b       	mov	r11,r1
80005252:	a7 bb       	sbr	r11,0x7
80005254:	30 2c       	mov	r12,2
80005256:	f0 1f 00 4d 	mcall	80005388 <PcdComMF522+0x168>
	ClearBitMask(ComIrqReg,0x80);	//娓涓浣
8000525a:	e0 6b 00 80 	mov	r11,128
8000525e:	30 4c       	mov	r12,4
80005260:	f0 1f 00 4b 	mcall	8000538c <PcdComMF522+0x16c>
	WriteRawRC(CommandReg,PCD_IDLE);
80005264:	30 0b       	mov	r11,0
80005266:	30 1c       	mov	r12,1
80005268:	f0 1f 00 48 	mcall	80005388 <PcdComMF522+0x168>
	SetBitMask(FIFOLevelReg,0x80);	 	//娓FIFO缂瀛
8000526c:	e0 6b 00 80 	mov	r11,128
80005270:	30 ac       	mov	r12,10
80005272:	f0 1f 00 48 	mcall	80005390 <PcdComMF522+0x170>
	
	for (i=0; i<InLenByte; i++)
80005276:	58 06       	cp.w	r6,0
80005278:	c0 c0       	breq	80005290 <PcdComMF522+0x70>
8000527a:	0a 97       	mov	r7,r5
	{   
		WriteRawRC(FIFODataReg, pIn [i]);
8000527c:	30 94       	mov	r4,9
8000527e:	0f 3b       	ld.ub	r11,r7++
80005280:	08 9c       	mov	r12,r4
80005282:	f0 1f 00 42 	mcall	80005388 <PcdComMF522+0x168>
	WriteRawRC(ComIEnReg,irqEn|0x80);
	ClearBitMask(ComIrqReg,0x80);	//娓涓浣
	WriteRawRC(CommandReg,PCD_IDLE);
	SetBitMask(FIFOLevelReg,0x80);	 	//娓FIFO缂瀛
	
	for (i=0; i<InLenByte; i++)
80005286:	0e 98       	mov	r8,r7
80005288:	0a 18       	sub	r8,r5
8000528a:	ec 08 19 00 	cp.h	r8,r6
8000528e:	cf 83       	brcs	8000527e <PcdComMF522+0x5e>
	{   
		WriteRawRC(FIFODataReg, pIn [i]);
	}
	WriteRawRC(CommandReg, Command);
80005290:	04 9b       	mov	r11,r2
80005292:	30 1c       	mov	r12,1
80005294:	f0 1f 00 3d 	mcall	80005388 <PcdComMF522+0x168>
	
	if (Command == PCD_TRANSCEIVE)
80005298:	30 c8       	mov	r8,12
8000529a:	f0 02 18 00 	cp.b	r2,r8
8000529e:	c0 61       	brne	800052aa <PcdComMF522+0x8a>
	{    
		SetBitMask(BitFramingReg,0x80);  
800052a0:	e0 6b 00 80 	mov	r11,128
800052a4:	30 dc       	mov	r12,13
800052a6:	f0 1f 00 3b 	mcall	80005390 <PcdComMF522+0x170>
	
	//i = 600;//规堕棰璋达浣M1℃澶х寰堕25ms
	i = 2000;
	do
	{
		n = ReadRawRC(ComIrqReg);
800052aa:	30 4c       	mov	r12,4
800052ac:	f0 1f 00 3a 	mcall	80005394 <PcdComMF522+0x174>
800052b0:	18 97       	mov	r7,r12
800052b2:	e0 66 07 cf 	mov	r6,1999
		i--;
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
800052b6:	30 05       	mov	r5,0
	
	//i = 600;//规堕棰璋达浣M1℃澶х寰堕25ms
	i = 2000;
	do
	{
		n = ReadRawRC(ComIrqReg);
800052b8:	30 44       	mov	r4,4
800052ba:	c0 88       	rjmp	800052ca <PcdComMF522+0xaa>
800052bc:	08 9c       	mov	r12,r4
800052be:	f0 1f 00 36 	mcall	80005394 <PcdComMF522+0x174>
800052c2:	18 97       	mov	r7,r12
		i--;
800052c4:	20 16       	sub	r6,1
800052c6:	5c 86       	casts.h	r6
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
800052c8:	c0 a0       	breq	800052dc <PcdComMF522+0xbc>
800052ca:	f1 d7 c0 01 	bfextu	r8,r7,0x0,0x1
800052ce:	c4 c1       	brne	80005366 <PcdComMF522+0x146>
800052d0:	ef e3 00 08 	and	r8,r7,r3
800052d4:	ea 08 18 00 	cp.b	r8,r5
800052d8:	cf 20       	breq	800052bc <PcdComMF522+0x9c>
800052da:	c4 68       	rjmp	80005366 <PcdComMF522+0x146>
	ClearBitMask(BitFramingReg,0x80);
800052dc:	e0 6b 00 80 	mov	r11,128
800052e0:	30 dc       	mov	r12,13
800052e2:	f0 1f 00 2b 	mcall	8000538c <PcdComMF522+0x16c>
800052e6:	30 27       	mov	r7,2
800052e8:	c3 38       	rjmp	8000534e <PcdComMF522+0x12e>
800052ea:	02 67       	and	r7,r1
800052ec:	ef d7 c0 01 	bfextu	r7,r7,0x0,0x1
		if(!(ReadRawRC(ErrorReg)&0x1B))
		{
			status = MI_OK;
			if (n & irqEn & 0x01)
			{   status = MI_NOTAGERR;   }
			if (Command == PCD_TRANSCEIVE)
800052f0:	30 c8       	mov	r8,12
800052f2:	f0 02 18 00 	cp.b	r2,r8
800052f6:	c2 c1       	brne	8000534e <PcdComMF522+0x12e>
			{
				n = ReadRawRC(FIFOLevelReg);
800052f8:	30 ac       	mov	r12,10
800052fa:	f0 1f 00 27 	mcall	80005394 <PcdComMF522+0x174>
800052fe:	18 94       	mov	r4,r12
				lastBits = ReadRawRC(ControlReg) & 0x07;
80005300:	30 cc       	mov	r12,12
80005302:	f0 1f 00 25 	mcall	80005394 <PcdComMF522+0x174>
80005306:	f9 dc c0 03 	bfextu	r12,r12,0x0,0x3
				if (lastBits)
8000530a:	c0 70       	breq	80005318 <PcdComMF522+0xf8>
				{   *pOutLenBit = (n-1)*8 + lastBits;   }
8000530c:	08 98       	mov	r8,r4
8000530e:	20 18       	sub	r8,1
80005310:	f8 08 00 3c 	add	r12,r12,r8<<0x3
80005314:	a0 8c       	st.b	r0[0x0],r12
80005316:	c0 48       	rjmp	8000531e <PcdComMF522+0xfe>
				else
				{   *pOutLenBit = n*8;   }
80005318:	e8 08 15 03 	lsl	r8,r4,0x3
8000531c:	a0 88       	st.b	r0[0x0],r8
				if (n == 0)
8000531e:	58 04       	cp.w	r4,0
80005320:	c0 61       	brne	8000532c <PcdComMF522+0x10c>
80005322:	30 14       	mov	r4,1
80005324:	40 05       	lddsp	r5,sp[0x0]
80005326:	0a 96       	mov	r6,r5
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
				{   pOut [i] = ReadRawRC(FIFODataReg);    }
80005328:	30 93       	mov	r3,9
8000532a:	c0 98       	rjmp	8000533c <PcdComMF522+0x11c>
				{   *pOutLenBit = n*8;   }
				if (n == 0)
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
8000532c:	31 28       	mov	r8,18
8000532e:	f0 04 18 00 	cp.b	r4,r8
80005332:	f9 b4 0b 12 	movhi	r4,18
80005336:	58 04       	cp.w	r4,0
80005338:	cf 61       	brne	80005324 <PcdComMF522+0x104>
8000533a:	c0 a8       	rjmp	8000534e <PcdComMF522+0x12e>
				{   pOut [i] = ReadRawRC(FIFODataReg);    }
8000533c:	06 9c       	mov	r12,r3
8000533e:	f0 1f 00 16 	mcall	80005394 <PcdComMF522+0x174>
80005342:	0c cc       	st.b	r6++,r12
				{   *pOutLenBit = n*8;   }
				if (n == 0)
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
80005344:	ec 05 01 08 	sub	r8,r6,r5
80005348:	e8 08 19 00 	cp.h	r8,r4
8000534c:	cf 83       	brcs	8000533c <PcdComMF522+0x11c>
		{   status = MI_ERR;   }
		
	}
	

	SetBitMask(ControlReg,0x80);           // stop timer now
8000534e:	e0 6b 00 80 	mov	r11,128
80005352:	30 cc       	mov	r12,12
80005354:	f0 1f 00 0f 	mcall	80005390 <PcdComMF522+0x170>
	WriteRawRC(CommandReg,PCD_IDLE);
80005358:	30 0b       	mov	r11,0
8000535a:	30 1c       	mov	r12,1
8000535c:	f0 1f 00 0b 	mcall	80005388 <PcdComMF522+0x168>
	return status;
}
80005360:	0e 9c       	mov	r12,r7
80005362:	2f fd       	sub	sp,-4
80005364:	d8 32       	popm	r0-r7,pc
	{
		n = ReadRawRC(ComIrqReg);
		i--;
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
	ClearBitMask(BitFramingReg,0x80);
80005366:	e0 6b 00 80 	mov	r11,128
8000536a:	30 dc       	mov	r12,13
8000536c:	f0 1f 00 08 	mcall	8000538c <PcdComMF522+0x16c>

	if (i!=0)
	{
		if(!(ReadRawRC(ErrorReg)&0x1B))
80005370:	30 6c       	mov	r12,6
80005372:	f0 1f 00 09 	mcall	80005394 <PcdComMF522+0x174>
80005376:	e2 1c 00 1b 	andl	r12,0x1b,COH
8000537a:	cb 80       	breq	800052ea <PcdComMF522+0xca>
8000537c:	30 27       	mov	r7,2
8000537e:	ce 8b       	rjmp	8000534e <PcdComMF522+0x12e>
80005380:	80 00       	ld.sh	r0,r0[0x0]
80005382:	e0 48 80 00 	cp.w	r8,32768
80005386:	e0 44 80 00 	cp.w	r4,32768
8000538a:	4e f8       	lddpc	r8,80005544 <PcdSelect+0x38>
8000538c:	80 00       	ld.sh	r0,r0[0x0]
8000538e:	50 a0       	stdsp	sp[0x28],r0
80005390:	80 00       	ld.sh	r0,r0[0x0]
80005392:	50 5c       	stdsp	sp[0x14],r12
80005394:	80 00       	ld.sh	r0,r0[0x0]
80005396:	4f b8       	lddpc	r8,80005580 <rfid_auto_reader>

80005398 <PcdAnticoll>:
//    斤插叉
//拌存: pSnr[OUT]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdAnticoll(U8 *pSnr)
{
80005398:	eb cd 40 c0 	pushm	r6-r7,lr
8000539c:	20 5d       	sub	sp,20
8000539e:	18 96       	mov	r6,r12
	U8   i,snr_check=0;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];
	

	ClearBitMask(Status2Reg,0x08);
800053a0:	30 8b       	mov	r11,8
800053a2:	16 9c       	mov	r12,r11
800053a4:	f0 1f 00 1a 	mcall	8000540c <PcdAnticoll+0x74>
	WriteRawRC(BitFramingReg,0x00);
800053a8:	30 0b       	mov	r11,0
800053aa:	30 dc       	mov	r12,13
800053ac:	f0 1f 00 19 	mcall	80005410 <PcdAnticoll+0x78>
	ClearBitMask(CollReg,0x80);
800053b0:	e0 6b 00 80 	mov	r11,128
800053b4:	30 ec       	mov	r12,14
800053b6:	f0 1f 00 16 	mcall	8000540c <PcdAnticoll+0x74>
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
800053ba:	39 38       	mov	r8,-109
800053bc:	ba 88       	st.b	sp[0x0],r8
	ucComMF522Buf[1] = 0x20;
800053be:	32 08       	mov	r8,32
800053c0:	ba 98       	st.b	sp[0x1],r8

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,2,ucComMF522Buf,&unLen);
800053c2:	1a 9b       	mov	r11,sp
800053c4:	fa c8 ff ed 	sub	r8,sp,-19
800053c8:	1a 99       	mov	r9,sp
800053ca:	30 2a       	mov	r10,2
800053cc:	30 cc       	mov	r12,12
800053ce:	f0 1f 00 12 	mcall	80005414 <PcdAnticoll+0x7c>
800053d2:	18 97       	mov	r7,r12

	if (status == MI_OK)
800053d4:	c1 21       	brne	800053f8 <PcdAnticoll+0x60>
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
800053d6:	1b 89       	ld.ub	r9,sp[0x0]
800053d8:	ac 89       	st.b	r6[0x0],r9
800053da:	1b 98       	ld.ub	r8,sp[0x1]
800053dc:	ac 98       	st.b	r6[0x1],r8
			snr_check ^= ucComMF522Buf[i];
800053de:	10 59       	eor	r9,r8

	if (status == MI_OK)
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
800053e0:	1b a8       	ld.ub	r8,sp[0x2]
800053e2:	ac a8       	st.b	r6[0x2],r8
			snr_check ^= ucComMF522Buf[i];
800053e4:	f3 e8 20 08 	eor	r8,r9,r8

	if (status == MI_OK)
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
800053e8:	1b b9       	ld.ub	r9,sp[0x3]
800053ea:	ac b9       	st.b	r6[0x3],r9
			snr_check ^= ucComMF522Buf[i];
800053ec:	12 58       	eor	r8,r9
		}
		if (snr_check != ucComMF522Buf[i])
800053ee:	1b c9       	ld.ub	r9,sp[0x4]
800053f0:	f0 09 18 00 	cp.b	r9,r8
800053f4:	f9 b7 01 02 	movne	r7,2
		{   status = MI_ERR;    }
	}
	
	SetBitMask(CollReg,0x80);
800053f8:	e0 6b 00 80 	mov	r11,128
800053fc:	30 ec       	mov	r12,14
800053fe:	f0 1f 00 07 	mcall	80005418 <PcdAnticoll+0x80>
	return status;
}
80005402:	0e 9c       	mov	r12,r7
80005404:	2f bd       	sub	sp,-20
80005406:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000540a:	00 00       	add	r0,r0
8000540c:	80 00       	ld.sh	r0,r0[0x0]
8000540e:	50 a0       	stdsp	sp[0x28],r0
80005410:	80 00       	ld.sh	r0,r0[0x0]
80005412:	4e f8       	lddpc	r8,800055cc <rfid_auto_reader+0x4c>
80005414:	80 00       	ld.sh	r0,r0[0x0]
80005416:	52 20       	stdsp	sp[0x88],r0
80005418:	80 00       	ld.sh	r0,r0[0x0]
8000541a:	50 5c       	stdsp	sp[0x14],r12

8000541c <PcdRequest>:
//                0x0800 = Mifare_Pro(X)
//                0x4403 = Mifare_DESFire
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdRequest(U8   req_code,U8 *pTagType)
{
8000541c:	eb cd 40 c0 	pushm	r6-r7,lr
80005420:	20 5d       	sub	sp,20
80005422:	18 97       	mov	r7,r12
80005424:	16 96       	mov	r6,r11
	char   status;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];

	ClearBitMask(Status2Reg,0x08);
80005426:	30 8b       	mov	r11,8
80005428:	16 9c       	mov	r12,r11
8000542a:	f0 1f 00 12 	mcall	80005470 <PcdRequest+0x54>
	WriteRawRC(BitFramingReg,0x07);
8000542e:	30 7b       	mov	r11,7
80005430:	30 dc       	mov	r12,13
80005432:	f0 1f 00 11 	mcall	80005474 <PcdRequest+0x58>
	SetBitMask(TxControlReg,0x03);
80005436:	30 3b       	mov	r11,3
80005438:	31 4c       	mov	r12,20
8000543a:	f0 1f 00 10 	mcall	80005478 <PcdRequest+0x5c>
	
	ucComMF522Buf[0] = req_code;
8000543e:	ba 87       	st.b	sp[0x0],r7

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,1,ucComMF522Buf,&unLen);
80005440:	1a 9b       	mov	r11,sp
80005442:	fa c8 ff ed 	sub	r8,sp,-19
80005446:	1a 99       	mov	r9,sp
80005448:	30 1a       	mov	r10,1
8000544a:	30 cc       	mov	r12,12
8000544c:	f0 1f 00 0c 	mcall	8000547c <PcdRequest+0x60>

	if ((status == MI_OK) && (unLen == 0x10))
80005450:	c0 c1       	brne	80005468 <PcdRequest+0x4c>
80005452:	31 08       	mov	r8,16
80005454:	fb 39 00 13 	ld.ub	r9,sp[19]
80005458:	f0 09 18 00 	cp.b	r9,r8
8000545c:	c0 61       	brne	80005468 <PcdRequest+0x4c>
	{
		*pTagType     = ucComMF522Buf[0];
8000545e:	1b 88       	ld.ub	r8,sp[0x0]
80005460:	ac 88       	st.b	r6[0x0],r8
		*(pTagType+1) = ucComMF522Buf[1];
80005462:	1b 98       	ld.ub	r8,sp[0x1]
80005464:	ac 98       	st.b	r6[0x1],r8
	
	ucComMF522Buf[0] = req_code;

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,1,ucComMF522Buf,&unLen);

	if ((status == MI_OK) && (unLen == 0x10))
80005466:	c0 28       	rjmp	8000546a <PcdRequest+0x4e>
80005468:	30 2c       	mov	r12,2
	}
	else
	{   status = MI_ERR;   }
	
	return status;
}
8000546a:	2f bd       	sub	sp,-20
8000546c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005470:	80 00       	ld.sh	r0,r0[0x0]
80005472:	50 a0       	stdsp	sp[0x28],r0
80005474:	80 00       	ld.sh	r0,r0[0x0]
80005476:	4e f8       	lddpc	r8,80005630 <rfid_auto_reader+0xb0>
80005478:	80 00       	ld.sh	r0,r0[0x0]
8000547a:	50 5c       	stdsp	sp[0x14],r12
8000547c:	80 00       	ld.sh	r0,r0[0x0]
8000547e:	52 20       	stdsp	sp[0x88],r0

80005480 <CalulateCRC>:

/////////////////////////////////////////////////////////////////////
//MF522璁＄CRC16芥
/////////////////////////////////////////////////////////////////////
void CalulateCRC(U8 *pIn ,U8   len,U8 *pOut )
{
80005480:	eb cd 40 f8 	pushm	r3-r7,lr
80005484:	18 95       	mov	r5,r12
80005486:	16 96       	mov	r6,r11
80005488:	14 93       	mov	r3,r10
	U8   i,n;
	ClearBitMask(DivIrqReg,0x04);
8000548a:	30 4b       	mov	r11,4
8000548c:	30 5c       	mov	r12,5
8000548e:	f0 1f 00 1c 	mcall	800054fc <CalulateCRC+0x7c>
	WriteRawRC(CommandReg,PCD_IDLE);
80005492:	30 0b       	mov	r11,0
80005494:	30 1c       	mov	r12,1
80005496:	f0 1f 00 1b 	mcall	80005500 <CalulateCRC+0x80>
	SetBitMask(FIFOLevelReg,0x80);
8000549a:	e0 6b 00 80 	mov	r11,128
8000549e:	30 ac       	mov	r12,10
800054a0:	f0 1f 00 19 	mcall	80005504 <CalulateCRC+0x84>
	for (i=0; i<len; i++)
800054a4:	58 06       	cp.w	r6,0
800054a6:	c0 c0       	breq	800054be <CalulateCRC+0x3e>
800054a8:	0a 97       	mov	r7,r5
	{   WriteRawRC(FIFODataReg, *(pIn +i));   }
800054aa:	30 94       	mov	r4,9
800054ac:	0f 3b       	ld.ub	r11,r7++
800054ae:	08 9c       	mov	r12,r4
800054b0:	f0 1f 00 14 	mcall	80005500 <CalulateCRC+0x80>
{
	U8   i,n;
	ClearBitMask(DivIrqReg,0x04);
	WriteRawRC(CommandReg,PCD_IDLE);
	SetBitMask(FIFOLevelReg,0x80);
	for (i=0; i<len; i++)
800054b4:	0e 98       	mov	r8,r7
800054b6:	0a 18       	sub	r8,r5
800054b8:	ec 08 18 00 	cp.b	r8,r6
800054bc:	cf 83       	brcs	800054ac <CalulateCRC+0x2c>
	{   WriteRawRC(FIFODataReg, *(pIn +i));   }
	WriteRawRC(CommandReg, PCD_CALCCRC);
800054be:	30 3b       	mov	r11,3
800054c0:	30 1c       	mov	r12,1
800054c2:	f0 1f 00 10 	mcall	80005500 <CalulateCRC+0x80>
	i = 0xFF;
	do
	{
		n = ReadRawRC(DivIrqReg);
800054c6:	30 5c       	mov	r12,5
800054c8:	f0 1f 00 10 	mcall	80005508 <CalulateCRC+0x88>
800054cc:	e0 67 00 fe 	mov	r7,254
800054d0:	30 56       	mov	r6,5
800054d2:	c0 78       	rjmp	800054e0 <CalulateCRC+0x60>
800054d4:	0c 9c       	mov	r12,r6
800054d6:	f0 1f 00 0d 	mcall	80005508 <CalulateCRC+0x88>
		i--;
800054da:	20 17       	sub	r7,1
800054dc:	5c 57       	castu.b	r7
	}
	while ((i!=0) && !(n&0x04));
800054de:	c0 40       	breq	800054e6 <CalulateCRC+0x66>
800054e0:	e2 1c 00 04 	andl	r12,0x4,COH
800054e4:	cf 80       	breq	800054d4 <CalulateCRC+0x54>
	pOut [0] = ReadRawRC(CRCResultRegL);
800054e6:	32 2c       	mov	r12,34
800054e8:	f0 1f 00 08 	mcall	80005508 <CalulateCRC+0x88>
800054ec:	a6 8c       	st.b	r3[0x0],r12
	pOut [1] = ReadRawRC(CRCResultRegM);
800054ee:	32 1c       	mov	r12,33
800054f0:	f0 1f 00 06 	mcall	80005508 <CalulateCRC+0x88>
800054f4:	a6 9c       	st.b	r3[0x1],r12
}
800054f6:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
800054fa:	00 00       	add	r0,r0
800054fc:	80 00       	ld.sh	r0,r0[0x0]
800054fe:	50 a0       	stdsp	sp[0x28],r0
80005500:	80 00       	ld.sh	r0,r0[0x0]
80005502:	4e f8       	lddpc	r8,800056bc <scan_patrol+0x1c>
80005504:	80 00       	ld.sh	r0,r0[0x0]
80005506:	50 5c       	stdsp	sp[0x14],r12
80005508:	80 00       	ld.sh	r0,r0[0x0]
8000550a:	4f b8       	lddpc	r8,800056f4 <rfid_sendID_message+0x24>

8000550c <PcdSelect>:
//    斤瀹＄
//拌存: pSnr[IN]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdSelect(U8 *pSnr)
{
8000550c:	eb cd 40 80 	pushm	r7,lr
80005510:	20 5d       	sub	sp,20
	char   status;
	U8   i;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
80005512:	39 38       	mov	r8,-109
80005514:	ba 88       	st.b	sp[0x0],r8
	ucComMF522Buf[1] = 0x70;
80005516:	37 08       	mov	r8,112
80005518:	ba 98       	st.b	sp[0x1],r8
	ucComMF522Buf[6] = 0;
8000551a:	30 08       	mov	r8,0
8000551c:	ba e8       	st.b	sp[0x6],r8
8000551e:	fa c8 ff fe 	sub	r8,sp,-2
/////////////////////////////////////////////////////////////////////
//    斤瀹＄
//拌存: pSnr[IN]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdSelect(U8 *pSnr)
80005522:	fa cb ff fa 	sub	r11,sp,-6
	ucComMF522Buf[0] = PICC_ANTICOLL1;
	ucComMF522Buf[1] = 0x70;
	ucComMF522Buf[6] = 0;
	for (i=0; i<4; i++)
	{
		ucComMF522Buf[i+2] = *(pSnr+i);
80005526:	19 89       	ld.ub	r9,r12[0x0]
80005528:	10 c9       	st.b	r8++,r9
		ucComMF522Buf[6]  ^= *(pSnr+i);
8000552a:	19 3a       	ld.ub	r10,r12++
8000552c:	1b e9       	ld.ub	r9,sp[0x6]
8000552e:	f5 e9 20 09 	eor	r9,r10,r9
80005532:	ba e9       	st.b	sp[0x6],r9
	U8   ucComMF522Buf[MAXRLEN];
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
	ucComMF522Buf[1] = 0x70;
	ucComMF522Buf[6] = 0;
	for (i=0; i<4; i++)
80005534:	16 38       	cp.w	r8,r11
80005536:	cf 81       	brne	80005526 <PcdSelect+0x1a>
	{
		ucComMF522Buf[i+2] = *(pSnr+i);
		ucComMF522Buf[6]  ^= *(pSnr+i);
	}
	CalulateCRC(ucComMF522Buf,7,&ucComMF522Buf[7]);
80005538:	1a 97       	mov	r7,sp
8000553a:	fa ca ff f9 	sub	r10,sp,-7
8000553e:	30 7b       	mov	r11,7
80005540:	1a 9c       	mov	r12,sp
80005542:	f0 1f 00 0d 	mcall	80005574 <PcdSelect+0x68>
	
	ClearBitMask(Status2Reg,0x08);
80005546:	30 8b       	mov	r11,8
80005548:	16 9c       	mov	r12,r11
8000554a:	f0 1f 00 0c 	mcall	80005578 <PcdSelect+0x6c>

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,9,ucComMF522Buf,&unLen);
8000554e:	fa c8 ff ed 	sub	r8,sp,-19
80005552:	1a 99       	mov	r9,sp
80005554:	30 9a       	mov	r10,9
80005556:	1a 9b       	mov	r11,sp
80005558:	30 cc       	mov	r12,12
8000555a:	f0 1f 00 09 	mcall	8000557c <PcdSelect+0x70>
	
	if ((status == MI_OK) && (unLen == 0x18))
8000555e:	c0 71       	brne	8000556c <PcdSelect+0x60>
80005560:	31 88       	mov	r8,24
80005562:	fb 39 00 13 	ld.ub	r9,sp[19]
80005566:	f0 09 18 00 	cp.b	r9,r8
8000556a:	c0 20       	breq	8000556e <PcdSelect+0x62>
8000556c:	30 2c       	mov	r12,2
	{   status = MI_OK;  }
	else
	{   status = MI_ERR;    }

	return status;
}
8000556e:	2f bd       	sub	sp,-20
80005570:	e3 cd 80 80 	ldm	sp++,r7,pc
80005574:	80 00       	ld.sh	r0,r0[0x0]
80005576:	54 80       	stdsp	sp[0x120],r0
80005578:	80 00       	ld.sh	r0,r0[0x0]
8000557a:	50 a0       	stdsp	sp[0x28],r0
8000557c:	80 00       	ld.sh	r0,r0[0x0]
8000557e:	52 20       	stdsp	sp[0x88],r0

80005580 <rfid_auto_reader>:
		//
}

//娴绋锛瀵诲->插叉->->″
U8 rfid_auto_reader(void *card_id)
{
80005580:	eb cd 40 c0 	pushm	r6-r7,lr
80005584:	18 96       	mov	r6,r12
	U8 status = MI_ERR;
	
	PcdReset();
80005586:	f0 1f 00 37 	mcall	80005660 <rfid_auto_reader+0xe0>
//while(1){
	status=PcdRequest(PICC_REQALL,	CT);//瀵诲ぉ绾垮哄ㄩㄧ★杩＄绫诲 2瀛
8000558a:	4b 7b       	lddpc	r11,80005664 <rfid_auto_reader+0xe4>
8000558c:	35 2c       	mov	r12,82
8000558e:	f0 1f 00 37 	mcall	80005668 <rfid_auto_reader+0xe8>
80005592:	18 97       	mov	r7,r12
	if(status!=MI_OK) return status;
80005594:	c6 31       	brne	8000565a <rfid_auto_reader+0xda>
	//continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
80005596:	4b 48       	lddpc	r8,80005664 <rfid_auto_reader+0xe4>
80005598:	11 88       	ld.ub	r8,r8[0x0]
8000559a:	30 49       	mov	r9,4
8000559c:	f2 08 18 00 	cp.b	r8,r9
800055a0:	c0 b1       	brne	800055b6 <rfid_auto_reader+0x36>
800055a2:	4b 19       	lddpc	r9,80005664 <rfid_auto_reader+0xe4>
800055a4:	13 9a       	ld.ub	r10,r9[0x1]
800055a6:	30 09       	mov	r9,0
800055a8:	f2 0a 18 00 	cp.b	r10,r9
800055ac:	c0 51       	brne	800055b6 <rfid_auto_reader+0x36>
		log("MFOne-S50\n");
800055ae:	4b 0c       	lddpc	r12,8000566c <rfid_auto_reader+0xec>
800055b0:	f0 1f 00 30 	mcall	80005670 <rfid_auto_reader+0xf0>
//while(1){
	status=PcdRequest(PICC_REQALL,	CT);//瀵诲ぉ绾垮哄ㄩㄧ★杩＄绫诲 2瀛
	if(status!=MI_OK) return status;
	//continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
800055b4:	c3 c8       	rjmp	8000562c <rfid_auto_reader+0xac>
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
800055b6:	30 29       	mov	r9,2
800055b8:	f2 08 18 00 	cp.b	r8,r9
800055bc:	c0 b1       	brne	800055d2 <rfid_auto_reader+0x52>
800055be:	4a a9       	lddpc	r9,80005664 <rfid_auto_reader+0xe4>
800055c0:	13 9a       	ld.ub	r10,r9[0x1]
800055c2:	30 09       	mov	r9,0
800055c4:	f2 0a 18 00 	cp.b	r10,r9
800055c8:	c0 51       	brne	800055d2 <rfid_auto_reader+0x52>
		log("MFOne-S70\n");
800055ca:	4a bc       	lddpc	r12,80005674 <rfid_auto_reader+0xf4>
800055cc:	f0 1f 00 29 	mcall	80005670 <rfid_auto_reader+0xf0>
	if(status!=MI_OK) return status;
	//continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
800055d0:	c2 e8       	rjmp	8000562c <rfid_auto_reader+0xac>
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
800055d2:	34 49       	mov	r9,68
800055d4:	f2 08 18 00 	cp.b	r8,r9
800055d8:	c0 b1       	brne	800055ee <rfid_auto_reader+0x6e>
800055da:	4a 39       	lddpc	r9,80005664 <rfid_auto_reader+0xe4>
800055dc:	13 9a       	ld.ub	r10,r9[0x1]
800055de:	30 09       	mov	r9,0
800055e0:	f2 0a 18 00 	cp.b	r10,r9
800055e4:	c0 51       	brne	800055ee <rfid_auto_reader+0x6e>
		log("MF-UltraLight\n");
800055e6:	4a 5c       	lddpc	r12,80005678 <rfid_auto_reader+0xf8>
800055e8:	f0 1f 00 22 	mcall	80005670 <rfid_auto_reader+0xf0>
	
	if(CT[0]==0x04&&CT[1]==0x00)
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
800055ec:	c2 08       	rjmp	8000562c <rfid_auto_reader+0xac>
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
800055ee:	30 89       	mov	r9,8
800055f0:	f2 08 18 00 	cp.b	r8,r9
800055f4:	c0 b1       	brne	8000560a <rfid_auto_reader+0x8a>
800055f6:	49 c9       	lddpc	r9,80005664 <rfid_auto_reader+0xe4>
800055f8:	13 9a       	ld.ub	r10,r9[0x1]
800055fa:	30 09       	mov	r9,0
800055fc:	f2 0a 18 00 	cp.b	r10,r9
80005600:	c0 51       	brne	8000560a <rfid_auto_reader+0x8a>
		log("MF-Pro\n");
80005602:	49 fc       	lddpc	r12,8000567c <rfid_auto_reader+0xfc>
80005604:	f0 1f 00 1b 	mcall	80005670 <rfid_auto_reader+0xf0>
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
80005608:	c1 28       	rjmp	8000562c <rfid_auto_reader+0xac>
		log("MF-Pro\n");
	else if(CT[0]==0x44&&CT[1]==0x03)
8000560a:	34 49       	mov	r9,68
8000560c:	f2 08 18 00 	cp.b	r8,r9
80005610:	c0 b1       	brne	80005626 <rfid_auto_reader+0xa6>
80005612:	49 58       	lddpc	r8,80005664 <rfid_auto_reader+0xe4>
80005614:	11 99       	ld.ub	r9,r8[0x1]
80005616:	30 38       	mov	r8,3
80005618:	f0 09 18 00 	cp.b	r9,r8
8000561c:	c0 51       	brne	80005626 <rfid_auto_reader+0xa6>
		log("MF Desire\n");
8000561e:	49 9c       	lddpc	r12,80005680 <rfid_auto_reader+0x100>
80005620:	f0 1f 00 14 	mcall	80005670 <rfid_auto_reader+0xf0>
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
		log("MF-Pro\n");
	else if(CT[0]==0x44&&CT[1]==0x03)
80005624:	c0 48       	rjmp	8000562c <rfid_auto_reader+0xac>
		log("MF Desire\n");
	else
		log("Unknown\n");
80005626:	49 8c       	lddpc	r12,80005684 <rfid_auto_reader+0x104>
80005628:	f0 1f 00 12 	mcall	80005670 <rfid_auto_reader+0xf0>
		
	status=PcdAnticoll(SN);//插叉锛杩＄搴 4瀛
8000562c:	49 7c       	lddpc	r12,80005688 <rfid_auto_reader+0x108>
8000562e:	f0 1f 00 18 	mcall	8000568c <rfid_auto_reader+0x10c>
80005632:	18 97       	mov	r7,r12
	if(status!=MI_OK)
80005634:	c0 60       	breq	80005640 <rfid_auto_reader+0xc0>
	{
		xcmp_IdleTestTone(Tone_Start, BT_Disconnecting_Success_Tone);//set tone to noticy failure!!!
80005636:	37 8b       	mov	r11,120
80005638:	30 1c       	mov	r12,1
8000563a:	f0 1f 00 16 	mcall	80005690 <rfid_auto_reader+0x110>
		return status;
8000563e:	c0 e8       	rjmp	8000565a <rfid_auto_reader+0xda>
		//continue;
	}
	
	//memcpy(MLastSelectedSnr,&RevBuffer[2],4);
	status=PcdSelect(SN);//
80005640:	49 2c       	lddpc	r12,80005688 <rfid_auto_reader+0x108>
80005642:	f0 1f 00 15 	mcall	80005694 <rfid_auto_reader+0x114>
80005646:	18 97       	mov	r7,r12
	if(status!=MI_OK)return status;
80005648:	c0 91       	brne	8000565a <rfid_auto_reader+0xda>
	//continue;
	else{//℃
			
		memcpy(card_id, SN, 4);
8000564a:	30 4a       	mov	r10,4
8000564c:	48 fb       	lddpc	r11,80005688 <rfid_auto_reader+0x108>
8000564e:	0c 9c       	mov	r12,r6
80005650:	f0 1f 00 12 	mcall	80005698 <rfid_auto_reader+0x118>
		log("select okay\n");
80005654:	49 2c       	lddpc	r12,8000569c <rfid_auto_reader+0x11c>
80005656:	f0 1f 00 07 	mcall	80005670 <rfid_auto_reader+0xf0>
		return status;	
	}
	
//}
	
}
8000565a:	0e 9c       	mov	r12,r7
8000565c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005660:	80 00       	ld.sh	r0,r0[0x0]
80005662:	4f 38       	lddpc	r8,8000582c <rfid_sendID_message+0x15c>
80005664:	00 00       	add	r0,r0
80005666:	54 18       	stdsp	sp[0x104],r8
80005668:	80 00       	ld.sh	r0,r0[0x0]
8000566a:	54 1c       	stdsp	sp[0x104],r12
8000566c:	80 00       	ld.sh	r0,r0[0x0]
8000566e:	e0 6c 80 00 	mov	r12,32768
80005672:	78 5c       	ld.w	r12,r12[0x14]
80005674:	80 00       	ld.sh	r0,r0[0x0]
80005676:	e0 78 80 00 	mov	r8,98304
8000567a:	e0 84 80 00 	brge	8001567a <_data_lma+0x6a5a>
8000567e:	e0 94 80 00 	brge	8003567e <_data_lma+0x26a5e>
80005682:	e0 9c 80 00 	brvs	80035682 <_data_lma+0x26a62>
80005686:	e0 a8       	*unknown*
80005688:	00 00       	add	r0,r0
8000568a:	54 1c       	stdsp	sp[0x104],r12
8000568c:	80 00       	ld.sh	r0,r0[0x0]
8000568e:	53 98       	stdsp	sp[0xe4],r8
80005690:	80 00       	ld.sh	r0,r0[0x0]
80005692:	46 8c       	lddsp	r12,sp[0x1a0]
80005694:	80 00       	ld.sh	r0,r0[0x0]
80005696:	55 0c       	stdsp	sp[0x140],r12
80005698:	80 00       	ld.sh	r0,r0[0x0]
8000569a:	81 06       	st.w	r0[0x0],r6
8000569c:	80 00       	ld.sh	r0,r0[0x0]
8000569e:	e0 b4       	*unknown*

800056a0 <scan_patrol>:
	return return_err;
	
}

U8 scan_patrol(char* SN)
{
800056a0:	eb cd 40 80 	pushm	r7,lr
800056a4:	18 97       	mov	r7,r12
	U8 return_err = MI_ERR;
	
	PcdReset();
800056a6:	f0 1f 00 08 	mcall	800056c4 <scan_patrol+0x24>
	Powerdown_RC522(WAKEUP_RC522);
800056aa:	30 0c       	mov	r12,0
800056ac:	f0 1f 00 07 	mcall	800056c8 <scan_patrol+0x28>
	return_err = rfid_auto_reader(SN);
800056b0:	0e 9c       	mov	r12,r7
800056b2:	f0 1f 00 07 	mcall	800056cc <scan_patrol+0x2c>
800056b6:	18 97       	mov	r7,r12
	Powerdown_RC522(ENTER_POWERDOWN);
800056b8:	30 1c       	mov	r12,1
800056ba:	f0 1f 00 04 	mcall	800056c8 <scan_patrol+0x28>
	//else
		//log("scan_patrol err!\n");
		
	return return_err;

}
800056be:	0e 9c       	mov	r12,r7
800056c0:	e3 cd 80 80 	ldm	sp++,r7,pc
800056c4:	80 00       	ld.sh	r0,r0[0x0]
800056c6:	4f 38       	lddpc	r8,80005890 <delay_ms+0xc>
800056c8:	80 00       	ld.sh	r0,r0[0x0]
800056ca:	50 10       	stdsp	sp[0x4],r0
800056cc:	80 00       	ld.sh	r0,r0[0x0]
800056ce:	55 80       	stdsp	sp[0x160],r0

800056d0 <rfid_sendID_message>:
	
}

extern volatile DateTime_t Current_time;
U8 rfid_sendID_message()
{
800056d0:	eb cd 40 e0 	pushm	r5-r7,lr
800056d4:	21 cd       	sub	sp,112
	static U8 start_session = 0x80;
	Message_Header_t header;
	Message_Data_t data_buffer;//22bytes
	
	//memset(data_buffer, 0x00, 16);
	memset(SN, 0x00, 10);
800056d6:	4c ec       	lddpc	r12,8000580c <rfid_sendID_message+0x13c>
800056d8:	30 08       	mov	r8,0
800056da:	30 09       	mov	r9,0
800056dc:	f8 e9 00 00 	st.d	r12[0],r8
800056e0:	30 0a       	mov	r10,0
800056e2:	b8 4a       	st.h	r12[0x8],r10
	memset(message, 0x00, 80);
800056e4:	fa e9 00 20 	st.d	sp[32],r8
800056e8:	fa e9 00 28 	st.d	sp[40],r8
800056ec:	fa e9 00 30 	st.d	sp[48],r8
800056f0:	fa e9 00 38 	st.d	sp[56],r8
800056f4:	fa e9 00 40 	st.d	sp[64],r8
800056f8:	fa e9 00 48 	st.d	sp[72],r8
800056fc:	fa e9 00 50 	st.d	sp[80],r8
80005700:	fa e9 00 58 	st.d	sp[88],r8
80005704:	fa e9 00 60 	st.d	sp[96],r8
80005708:	fa e9 00 68 	st.d	sp[104],r8
	//PcdReset();
	//Powerdown_RC522(WAKEUP_RC522);
	//return_err = rfid_auto_reader(SN);
	//Powerdown_RC522(ENTER_POWERDOWN);
	
	return_err = scan_patrol(SN);
8000570c:	f0 1f 00 41 	mcall	80005810 <rfid_sendID_message+0x140>
80005710:	18 97       	mov	r7,r12
	
	if(return_err == 0){
80005712:	c7 11       	brne	800057f4 <rfid_sendID_message+0x124>
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
80005714:	4b e6       	lddpc	r6,8000580c <rfid_sendID_message+0x13c>
80005716:	0d b8       	ld.ub	r8,r6[0x3]
80005718:	1a d8       	st.w	--sp,r8
8000571a:	0d a8       	ld.ub	r8,r6[0x2]
8000571c:	1a d8       	st.w	--sp,r8
8000571e:	0d 98       	ld.ub	r8,r6[0x1]
80005720:	1a d8       	st.w	--sp,r8
80005722:	0d 88       	ld.ub	r8,r6[0x0]
80005724:	1a d8       	st.w	--sp,r8
80005726:	4b cc       	lddpc	r12,80005814 <rfid_sendID_message+0x144>
80005728:	f0 1f 00 3c 	mcall	80005818 <rfid_sendID_message+0x148>
		xcmp_IdleTestTone(Tone_Start, BT_Connection_Success_Tone);//set tone to indicate scan rfid success!!!		 
8000572c:	37 7b       	mov	r11,119
8000572e:	30 1c       	mov	r12,1
80005730:	f0 1f 00 3b 	mcall	8000581c <rfid_sendID_message+0x14c>
80005734:	fa c8 ff f0 	sub	r8,sp,-16
80005738:	fa c9 ff ee 	sub	r9,sp,-18
//}
	
}

extern volatile DateTime_t Current_time;
U8 rfid_sendID_message()
8000573c:	ec c5 ff fc 	sub	r5,r6,-4
80005740:	10 9d       	mov	sp,r8
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, BT_Connection_Success_Tone);//set tone to indicate scan rfid success!!!		 
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″	
		
			 temp = ((SN[i] & 0xF0) >> 4);//瀛楂浣
			 if((temp >= 0) && (temp <= 9))data_buffer.RFID_ID[i*4] = temp+0x30;
80005742:	30 9e       	mov	lr,9
			 else 
				data_buffer.RFID_ID[i*4] = ((temp - 0x0a)+0x61);
			
			 data_buffer.RFID_ID[i*4+1] = 0x00;
80005744:	30 0c       	mov	r12,0
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, BT_Connection_Success_Tone);//set tone to indicate scan rfid success!!!		 
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″	
		
			 temp = ((SN[i] & 0xF0) >> 4);//瀛楂浣
80005746:	0d 8a       	ld.ub	r10,r6[0x0]
80005748:	f4 0b 16 04 	lsr	r11,r10,0x4
			 if((temp >= 0) && (temp <= 9))data_buffer.RFID_ID[i*4] = temp+0x30;
8000574c:	fc 0b 18 00 	cp.b	r11,lr
80005750:	f7 bb 08 d0 	subls	r11,-48
80005754:	f1 fb 8e 00 	st.bls	r8[0x0],r11
			 else 
				data_buffer.RFID_ID[i*4] = ((temp - 0x0a)+0x61);
80005758:	f7 bb 0b a9 	subhi	r11,-87
8000575c:	f1 fb be 00 	st.bhi	r8[0x0],r11
			
			 data_buffer.RFID_ID[i*4+1] = 0x00;
80005760:	b0 9c       	st.b	r8[0x1],r12
		 
			 temp = (SN[i] & 0x0F);//瀛浣浣
80005762:	f5 da c0 04 	bfextu	r10,r10,0x0,0x4
			 if((temp >= 0) && (temp <= 9))data_buffer.RFID_ID[i*4+2] = temp+0x30;
80005766:	fc 0a 18 00 	cp.b	r10,lr
8000576a:	f7 ba 08 d0 	subls	r10,-48
8000576e:	f3 fa 8e 00 	st.bls	r9[0x0],r10
			 else
				data_buffer.RFID_ID[i*4+2] = ((temp - 0x0a)+0x61);
80005772:	f7 ba 0b a9 	subhi	r10,-87
80005776:	f3 fa be 00 	st.bhi	r9[0x0],r10

			 data_buffer.RFID_ID[i*4+3] = 0x00; 
8000577a:	b0 bc       	st.b	r8[0x3],r12
8000577c:	2f f6       	sub	r6,-1
8000577e:	2f c8       	sub	r8,-4
80005780:	2f c9       	sub	r9,-4
	
	if(return_err == 0){
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, BT_Connection_Success_Tone);//set tone to indicate scan rfid success!!!		 
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″	
80005782:	0a 36       	cp.w	r6,r5
80005784:	ce 11       	brne	80005746 <rfid_sendID_message+0x76>
				data_buffer.RFID_ID[i*4+2] = ((temp - 0x0a)+0x61);

			 data_buffer.RFID_ID[i*4+3] = 0x00; 
		}
		
		memcpy(&data_buffer.XG_Time.Year, &Current_time.Year, sizeof(DateTime_t))	;
80005786:	30 6a       	mov	r10,6
80005788:	4a 6b       	lddpc	r11,80005820 <rfid_sendID_message+0x150>
8000578a:	fa cc ff f0 	sub	r12,sp,-16
8000578e:	f0 1f 00 26 	mcall	80005824 <rfid_sendID_message+0x154>
	
		header.length = (0x0008 + sizeof(Message_Data_t));
	
		if(start_session > 0x9f)start_session = 0x80;
80005792:	4a 68       	lddpc	r8,80005828 <rfid_sendID_message+0x158>
80005794:	11 89       	ld.ub	r9,r8[0x0]
80005796:	39 f8       	mov	r8,-97
80005798:	f0 09 18 00 	cp.b	r9,r8
8000579c:	e0 88 00 05 	brls	800057a6 <rfid_sendID_message+0xd6>
800057a0:	38 09       	mov	r9,-128
800057a2:	4a 28       	lddpc	r8,80005828 <rfid_sendID_message+0x158>
800057a4:	b0 89       	st.b	r8[0x0],r9
	
		header.session_id = (++start_session);
800057a6:	4a 18       	lddpc	r8,80005828 <rfid_sendID_message+0x158>
800057a8:	11 86       	ld.ub	r6,r8[0x0]
800057aa:	2f f6       	sub	r6,-1
800057ac:	b0 86       	st.b	r8[0x0],r6
	
		memcpy(&header.fixed_data[0], unsure_data, sizeof(unsure_data));
800057ae:	30 5a       	mov	r10,5
800057b0:	49 fb       	lddpc	r11,8000582c <rfid_sendID_message+0x15c>
800057b2:	fa cc ff e5 	sub	r12,sp,-27
800057b6:	f0 1f 00 1c 	mcall	80005824 <rfid_sendID_message+0x154>
		header.type = 0xe000;
	
		memcpy(message, &header, sizeof(Message_Header_t));//疯header版
800057ba:	31 e8       	mov	r8,30
800057bc:	fb 58 00 16 	st.h	sp[22],r8
800057c0:	fb 66 00 1a 	st.b	sp[26],r6
800057c4:	fe 78 e0 00 	mov	r8,-8192
800057c8:	fb 58 00 18 	st.h	sp[24],r8
800057cc:	fa c6 ff e0 	sub	r6,sp,-32
800057d0:	30 aa       	mov	r10,10
800057d2:	fa cb ff ea 	sub	r11,sp,-22
800057d6:	0c 9c       	mov	r12,r6
800057d8:	f0 1f 00 13 	mcall	80005824 <rfid_sendID_message+0x154>
		memcpy(&message[sizeof(Message_Header_t)], &data_buffer, sizeof(Message_Data_t));//疯淇″瀹规版
800057dc:	31 6a       	mov	r10,22
800057de:	1a 9b       	mov	r11,sp
800057e0:	fa cc ff d6 	sub	r12,sp,-42
800057e4:	f0 1f 00 10 	mcall	80005824 <rfid_sendID_message+0x154>
	
		xcmp_data_session_req(message, (sizeof(Message_Header_t)+sizeof(Message_Data_t)), destination);
800057e8:	30 9a       	mov	r10,9
800057ea:	32 0b       	mov	r11,32
800057ec:	0c 9c       	mov	r12,r6
800057ee:	f0 1f 00 11 	mcall	80005830 <rfid_sendID_message+0x160>
800057f2:	c0 88       	rjmp	80005802 <rfid_sendID_message+0x132>
		
	}
	else
	{
		xcmp_IdleTestTone(Tone_Start, BT_Disconnecting_Success_Tone);//set tone to indicate scan rfid failure!!!
800057f4:	37 8b       	mov	r11,120
800057f6:	30 1c       	mov	r12,1
800057f8:	f0 1f 00 09 	mcall	8000581c <rfid_sendID_message+0x14c>
		log("no card find...\n");
800057fc:	48 ec       	lddpc	r12,80005834 <rfid_sendID_message+0x164>
800057fe:	f0 1f 00 07 	mcall	80005818 <rfid_sendID_message+0x148>
	}
	
	return return_err;
	
}
80005802:	0e 9c       	mov	r12,r7
80005804:	2e 4d       	sub	sp,-112
80005806:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000580a:	00 00       	add	r0,r0
8000580c:	00 00       	add	r0,r0
8000580e:	0b 74       	ld.ub	r4,--r5
80005810:	80 00       	ld.sh	r0,r0[0x0]
80005812:	56 a0       	stdsp	sp[0x1a8],r0
80005814:	80 00       	ld.sh	r0,r0[0x0]
80005816:	e0 c4 80 00 	sub	r4,r0,-32768
8000581a:	78 5c       	ld.w	r12,r12[0x14]
8000581c:	80 00       	ld.sh	r0,r0[0x0]
8000581e:	46 8c       	lddsp	r12,sp[0x1a0]
80005820:	00 00       	add	r0,r0
80005822:	0e 08       	add	r8,r7
80005824:	80 00       	ld.sh	r0,r0[0x0]
80005826:	81 06       	st.w	r0[0x0],r6
80005828:	00 00       	add	r0,r0
8000582a:	05 34       	ld.ub	r4,r2++
8000582c:	00 00       	add	r0,r0
8000582e:	05 2c       	ld.uh	r12,r2++
80005830:	80 00       	ld.sh	r0,r0[0x0]
80005832:	45 54       	lddsp	r4,sp[0x154]
80005834:	80 00       	ld.sh	r0,r0[0x0]
80005836:	e0 e0 d4 01 	ld.d	r0,r0[-11263]

80005838 <rfid_init>:
U8 RFID[16];			//瀛RFID
U8 unsure_data[5]={0x04, 0x0d, 0x00, 0x0a, 0x00};


void rfid_init()
{
80005838:	d4 01       	pushm	lr
	char card_id[4]={0};
	//tc_init();//ㄥ跺200msㄥ诲
	
	rc522_init();
8000583a:	f0 1f 00 02 	mcall	80005840 <rfid_init+0x8>
	
	//if(rfid_auto_reader(card_id) == 0){
		//log("card_id : 0x%x, 0x%x, 0x%x, 0x%x\n", &card_id[0], &card_id[1], &card_id[2], &card_id[3]);	
	//}
		//
}
8000583e:	d8 02       	popm	pc
80005840:	80 00       	ld.sh	r0,r0[0x0]
80005842:	51 48       	stdsp	sp[0x50],r8

80005844 <delay_ns>:
}

void delay_ns(U32 ns)
{
	U32 i;
	for(i=0;i<ns;i++)
80005844:	58 0c       	cp.w	r12,0
80005846:	5e 0c       	reteq	r12
80005848:	30 08       	mov	r8,0
	{
		nop();
8000584a:	d7 03       	nop
		nop();
8000584c:	d7 03       	nop
		nop();
8000584e:	d7 03       	nop
}

void delay_ns(U32 ns)
{
	U32 i;
	for(i=0;i<ns;i++)
80005850:	2f f8       	sub	r8,-1
80005852:	10 3c       	cp.w	r12,r8
80005854:	fe 9b ff fb 	brhi	8000584a <delay_ns+0x6>
80005858:	5e fc       	retal	r12
8000585a:	d7 03       	nop

8000585c <delay_us>:
		nop();
		nop();
	}
}
void delay_us(U32 us)
{
8000585c:	eb cd 40 e0 	pushm	r5-r7,lr
80005860:	18 96       	mov	r6,r12
	for(int i =0; i<us; i++){
80005862:	58 0c       	cp.w	r12,0
80005864:	c0 b0       	breq	8000587a <delay_us+0x1e>
80005866:	30 07       	mov	r7,0
		delay_ns(1000);
80005868:	e0 65 03 e8 	mov	r5,1000
8000586c:	0a 9c       	mov	r12,r5
8000586e:	f0 1f 00 05 	mcall	80005880 <delay_us+0x24>
		nop();
	}
}
void delay_us(U32 us)
{
	for(int i =0; i<us; i++){
80005872:	2f f7       	sub	r7,-1
80005874:	0e 36       	cp.w	r6,r7
80005876:	fe 9b ff fb 	brhi	8000586c <delay_us+0x10>
8000587a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000587e:	00 00       	add	r0,r0
80005880:	80 00       	ld.sh	r0,r0[0x0]
80005882:	58 44       	cp.w	r4,4

80005884 <delay_ms>:
		delay_ns(1000);
	}

}
void delay_ms(U32 ms)
{
80005884:	eb cd 40 e0 	pushm	r5-r7,lr
80005888:	18 96       	mov	r6,r12
	for(int i =0; i<ms; i++){
8000588a:	58 0c       	cp.w	r12,0
8000588c:	c0 b0       	breq	800058a2 <delay_ms+0x1e>
8000588e:	30 07       	mov	r7,0
		delay_us(1000);
80005890:	e0 65 03 e8 	mov	r5,1000
80005894:	0a 9c       	mov	r12,r5
80005896:	f0 1f 00 05 	mcall	800058a8 <delay_ms+0x24>
	}

}
void delay_ms(U32 ms)
{
	for(int i =0; i<ms; i++){
8000589a:	2f f7       	sub	r7,-1
8000589c:	0e 36       	cp.w	r6,r7
8000589e:	fe 9b ff fb 	brhi	80005894 <delay_ms+0x10>
800058a2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800058a6:	00 00       	add	r0,r0
800058a8:	80 00       	ld.sh	r0,r0[0x0]
800058aa:	58 5c       	cp.w	r12,5

800058ac <local_start_timer>:
//	SSC_TX_DATA_ENABLE		AVR32_TC_A0_0_0_PIN					[32 PortB Pin  0 00000001 Func 0]
//	MAKO_TX					AVR32_SSC_TX_DATA_0_PIN				[42 PortB Pin 10 00000400 Func 0]
//	MAKO_RX					AVR32_SSC_RX_DATA_0_PIN				[39 PortB Pin  7 00000080 Func 0]
//
void local_start_timer(void)
{
800058ac:	d4 01       	pushm	lr
	{
		{TIMER_TC_CLK_PIN,      TIMER_TC_CLK_FUNCTION     },
		{TIMER_TC_FS_PIN,       TIMER_TC_FS_FUNCTION      },
		{TIMER_EN_CLK_PIN,      TIMER_EN_CLK_FUNCTION     }
	};
	gpio_enable_module(TC_GPIO_MAP, sizeof(TC_GPIO_MAP) / sizeof(TC_GPIO_MAP[0]));
800058ae:	30 3b       	mov	r11,3
800058b0:	48 8c       	lddpc	r12,800058d0 <local_start_timer+0x24>
800058b2:	f0 1f 00 09 	mcall	800058d4 <local_start_timer+0x28>

	(&AVR32_TC)->channel[0].cmr =
800058b6:	fe 78 38 00 	mov	r8,-51200
800058ba:	e0 69 91 0d 	mov	r9,37133
800058be:	ea 19 00 52 	orh	r9,0x52
800058c2:	91 19       	st.w	r8[0x4],r9
	1                          << AVR32_TC_CLKI_OFFSET     |
	AVR32_TC_TCCLKS_XC0        << AVR32_TC_TCCLKS_OFFSET;



	(&AVR32_TC)->channel[0].ra = 32;
800058c4:	32 09       	mov	r9,32
800058c6:	91 59       	st.w	r8[0x14],r9
	(&AVR32_TC)->channel[0].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
800058c8:	30 59       	mov	r9,5
800058ca:	91 09       	st.w	r8[0x0],r9
}
800058cc:	d8 02       	popm	pc
800058ce:	00 00       	add	r0,r0
800058d0:	80 00       	ld.sh	r0,r0[0x0]
800058d2:	e0 f4 80 00 	ld.w	r4,r0[-32768]
800058d6:	5c 40       	abs	r0

800058d8 <local_start_pll0>:
//In the SSC description, Master Clock (MCK) is the bus clock of the peripheral bus to which the
//SSC is connected. [23.6.2]
//Switch to clock Osc0 (crystal)
//start PLL0 and switch main clock to PLL0 output
void local_start_pll0(void)
{
800058d8:	d4 01       	pushm	lr
	AVR32_HMATRIX.mcfg[AVR32_HMATRIX_MASTER_CPU_INSTRUCTION] = 0x1;
	
***/
	
/*****/
	pm_switch_to_osc0(&AVR32_PM, 12000000, OSC0_STARTUP);
800058da:	30 3a       	mov	r10,3
800058dc:	e0 6b 1b 00 	mov	r11,6912
800058e0:	ea 1b 00 b7 	orh	r11,0xb7
800058e4:	fe 7c 0c 00 	mov	r12,-62464
800058e8:	f0 1f 00 19 	mcall	8000594c <local_start_pll0+0x74>

	pm_pll_setup(&AVR32_PM,
800058ec:	31 08       	mov	r8,16
800058ee:	1a d8       	st.w	--sp,r8
800058f0:	30 08       	mov	r8,0
800058f2:	30 19       	mov	r9,1
800058f4:	30 7a       	mov	r10,7
800058f6:	10 9b       	mov	r11,r8
800058f8:	fe 7c 0c 00 	mov	r12,-62464
800058fc:	f0 1f 00 15 	mcall	80005950 <local_start_pll0+0x78>
	               0,   // use PLL0
	               7,   // MUL=7 in the formula
	               1,   // DIV=1 in the formula
	               0,   // Sel Osc0/PLL0 or Osc1/PLL1
	               16); // lockcount in main clock for the PLL wait lock
	pm_pll_set_option(&AVR32_PM, 0, //PLL number 0
80005900:	30 08       	mov	r8,0
80005902:	30 19       	mov	r9,1
80005904:	12 9a       	mov	r10,r9
80005906:	10 9b       	mov	r11,r8
80005908:	fe 7c 0c 00 	mov	r12,-62464
8000590c:	f0 1f 00 12 	mcall	80005954 <local_start_pll0+0x7c>
	                        1, //freq Set to 1 for VCO frequency range 80-180MHz
	                        1, //div2 Divide the PLL output frequency by 2
	                        0);//0 to enable the Wide-Bandith Mode
	pm_pll_enable(&AVR32_PM,0);
80005910:	30 0b       	mov	r11,0
80005912:	fe 7c 0c 00 	mov	r12,-62464
80005916:	f0 1f 00 11 	mcall	80005958 <local_start_pll0+0x80>


	pm_wait_for_pll0_locked(&AVR32_PM);
8000591a:	fe 7c 0c 00 	mov	r12,-62464
8000591e:	f0 1f 00 10 	mcall	8000595c <local_start_pll0+0x84>


	pm_cksel(&AVR32_PM, 1,  //Bus A clock divisor enable = 1
80005922:	30 0a       	mov	r10,0
80005924:	1a da       	st.w	--sp,r10
80005926:	1a da       	st.w	--sp,r10
80005928:	14 98       	mov	r8,r10
8000592a:	14 99       	mov	r9,r10
8000592c:	30 1b       	mov	r11,1
8000592e:	fe 7c 0c 00 	mov	r12,-62464
80005932:	f0 1f 00 0c 	mcall	80005960 <local_start_pll0+0x88>
	             0,  //B clock divisor enable = 0
	             0,  //Bus B select = 0
	             0,  //HS Bus clock divisor enable = 0
	             0); //HS Bus select = 0
				 
	flashc_set_wait_state(1);
80005936:	30 1c       	mov	r12,1
80005938:	f0 1f 00 0b 	mcall	80005964 <local_start_pll0+0x8c>
	//AVR32_FLASHC.fcr = 0x00000040;

	pm_switch_to_clock(&AVR32_PM, AVR32_PM_MCSEL_PLL0);
8000593c:	30 2b       	mov	r11,2
8000593e:	fe 7c 0c 00 	mov	r12,-62464
80005942:	f0 1f 00 0a 	mcall	80005968 <local_start_pll0+0x90>
80005946:	2f dd       	sub	sp,-12
/****/
}
80005948:	d8 02       	popm	pc
8000594a:	00 00       	add	r0,r0
8000594c:	80 00       	ld.sh	r0,r0[0x0]
8000594e:	5f 48       	srge	r8
80005950:	80 00       	ld.sh	r0,r0[0x0]
80005952:	5e ea       	retqs	r10
80005954:	80 00       	ld.sh	r0,r0[0x0]
80005956:	5f 0c       	sreq	r12
80005958:	80 00       	ld.sh	r0,r0[0x0]
8000595a:	5f 26       	srhs	r6
8000595c:	80 00       	ld.sh	r0,r0[0x0]
8000595e:	5f 34       	srlo	r4
80005960:	80 00       	ld.sh	r0,r0[0x0]
80005962:	5e a4       	retle	r4
80005964:	80 00       	ld.sh	r0,r0[0x0]
80005966:	5b e0       	cp.w	r0,-2
80005968:	80 00       	ld.sh	r0,r0[0x0]
8000596a:	5f 3e       	srlo	lr

8000596c <xg_flashc_init>:
}


//U16	Current_total_message_count=0;
void xg_flashc_init(void)
{
8000596c:	d4 31       	pushm	r0-r7,lr
8000596e:	20 3d       	sub	sp,12
	
	/* Create the mutex semaphore to guard a shared xgflash.*/
	xgflash_mutex = xSemaphoreCreateMutex();
80005970:	f0 1f 00 80 	mcall	80005b70 <xg_flashc_init+0x204>
80005974:	fe f8 02 00 	ld.w	r8,pc[512]
80005978:	91 0c       	st.w	r8[0x0],r12
	if (xgflash_mutex == NULL)
8000597a:	70 08       	ld.w	r8,r8[0x0]
8000597c:	58 08       	cp.w	r8,0
8000597e:	c0 41       	brne	80005986 <xg_flashc_init+0x1a>
	{
		log("Create the xgflash_mutex semaphore failure\n");
80005980:	4f ec       	lddpc	r12,80005b78 <xg_flashc_init+0x20c>
80005982:	f0 1f 00 7f 	mcall	80005b7c <xg_flashc_init+0x210>
	}
	
	/* Create the binary semaphore to Synchronize other threads.*/
	vSemaphoreCreateBinary(xBinarySemaphore);
80005986:	30 0b       	mov	r11,0
80005988:	30 1c       	mov	r12,1
8000598a:	f0 1f 00 7e 	mcall	80005b80 <xg_flashc_init+0x214>
8000598e:	4f e8       	lddpc	r8,80005b84 <xg_flashc_init+0x218>
80005990:	91 0c       	st.w	r8[0x0],r12
80005992:	70 08       	ld.w	r8,r8[0x0]
80005994:	58 08       	cp.w	r8,0
80005996:	c0 80       	breq	800059a6 <xg_flashc_init+0x3a>
80005998:	4f b8       	lddpc	r8,80005b84 <xg_flashc_init+0x218>
8000599a:	70 0c       	ld.w	r12,r8[0x0]
8000599c:	30 09       	mov	r9,0
8000599e:	12 9a       	mov	r10,r9
800059a0:	12 9b       	mov	r11,r9
800059a2:	f0 1f 00 7a 	mcall	80005b88 <xg_flashc_init+0x21c>
	
	
	xg_resend_queue = xQueueCreate(20, sizeof(U32));
800059a6:	30 4b       	mov	r11,4
800059a8:	31 4c       	mov	r12,20
800059aa:	f0 1f 00 76 	mcall	80005b80 <xg_flashc_init+0x214>
800059ae:	4f 88       	lddpc	r8,80005b8c <xg_flashc_init+0x220>
800059b0:	91 0c       	st.w	r8[0x0],r12
	/*initialize the queue*/
	message_storage_queue = xQueueCreate(20, sizeof(U32));
800059b2:	30 4b       	mov	r11,4
800059b4:	31 4c       	mov	r12,20
800059b6:	f0 1f 00 73 	mcall	80005b80 <xg_flashc_init+0x214>
800059ba:	4f 68       	lddpc	r8,80005b90 <xg_flashc_init+0x224>
800059bc:	91 0c       	st.w	r8[0x0],r12
800059be:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_MESSAGE_STORE; i++ )
	{
		set_message_store(&message_store[i]);//push <message_store> address to the message_storage_queue;
800059c0:	10 96       	mov	r6,r8
800059c2:	4f 55       	lddpc	r5,80005b94 <xg_flashc_init+0x228>
800059c4:	6c 0c       	ld.w	r12,r6[0x0]
800059c6:	ea 07 00 0b 	add	r11,r5,r7
800059ca:	f0 1f 00 74 	mcall	80005b98 <xg_flashc_init+0x22c>
800059ce:	2e 07       	sub	r7,-32
	
	
	xg_resend_queue = xQueueCreate(20, sizeof(U32));
	/*initialize the queue*/
	message_storage_queue = xQueueCreate(20, sizeof(U32));
	for(int i= 0; i < MAX_MESSAGE_STORE; i++ )
800059d0:	e0 47 02 80 	cp.w	r7,640
800059d4:	cf 81       	brne	800059c4 <xg_flashc_init+0x58>
	{
		set_message_store(&message_store[i]);//push <message_store> address to the message_storage_queue;
	}
	
	
	data_flash_init();//interface
800059d6:	f0 1f 00 72 	mcall	80005b9c <xg_flashc_init+0x230>
	df_status_t return_code = DF_OK;
	static U32 current_page_number =0;
	unsigned int i = 0;
	unsigned int address =0x00000000;
	static char str[80];
	memset(str, 0x00, sizeof(str));
800059da:	30 0a       	mov	r10,0
800059dc:	30 0b       	mov	r11,0
800059de:	4f 18       	lddpc	r8,80005ba0 <xg_flashc_init+0x234>
800059e0:	b1 2a       	st.d	r8++,r10
800059e2:	b1 2a       	st.d	r8++,r10
800059e4:	b1 2a       	st.d	r8++,r10
800059e6:	b1 2a       	st.d	r8++,r10
800059e8:	b1 2a       	st.d	r8++,r10
800059ea:	b1 2a       	st.d	r8++,r10
800059ec:	b1 2a       	st.d	r8++,r10
800059ee:	b1 2a       	st.d	r8++,r10
800059f0:	b1 2a       	st.d	r8++,r10
800059f2:	f0 eb 00 00 	st.d	r8[0],r10
800059f6:	30 05       	mov	r5,0
	
start:
	
	 //bytes remained less than one page 
	return_code = data_flash_read_block(LABEL_ADDRESS, LABEL_LENGTH, str);
800059f8:	4e a7       	lddpc	r7,80005ba0 <xg_flashc_init+0x234>
			if(return_code == DF_OK)
			{
				//Calculates the offset address of the current stored message
				if(current_message_index != 0){
					
					memset(str, 0x00, sizeof(str));	
800059fa:	ee c4 ff f8 	sub	r4,r7,-8
800059fe:	e8 c3 ff f8 	sub	r3,r4,-8
80005a02:	e6 c2 ff f8 	sub	r2,r3,-8
80005a06:	e4 c1 ff f8 	sub	r1,r2,-8
80005a0a:	e2 c0 ff f8 	sub	r0,r1,-8
80005a0e:	e0 ca ff f8 	sub	r10,r0,-8
80005a12:	50 0a       	stdsp	sp[0x0],r10
80005a14:	2f 8a       	sub	r10,-8
80005a16:	50 1a       	stdsp	sp[0x4],r10
80005a18:	2f 8a       	sub	r10,-8
80005a1a:	50 2a       	stdsp	sp[0x8],r10
	memset(str, 0x00, sizeof(str));
	
start:
	
	 //bytes remained less than one page 
	return_code = data_flash_read_block(LABEL_ADDRESS, LABEL_LENGTH, str);
80005a1c:	0e 9a       	mov	r10,r7
80005a1e:	30 6b       	mov	r11,6
80005a20:	30 0c       	mov	r12,0
80005a22:	f0 1f 00 61 	mcall	80005ba4 <xg_flashc_init+0x238>
	{
		if(memcmp(XGFlashLabel, str, sizeof(XGFlashLabel)-1) != 0)//compare label
80005a26:	30 6a       	mov	r10,6
80005a28:	0e 9b       	mov	r11,r7
80005a2a:	4e 0c       	lddpc	r12,80005ba8 <xg_flashc_init+0x23c>
80005a2c:	f0 1f 00 60 	mcall	80005bac <xg_flashc_init+0x240>
80005a30:	c1 c0       	breq	80005a68 <xg_flashc_init+0xfc>
80005a32:	c8 58       	rjmp	80005b3c <xg_flashc_init+0x1d0>
					return FALSE;
				}
				address+=65536;//64k*1024=65536bytes
			}
			//set label
			return_code = data_flash_write(XGFlashLabel, LABEL_ADDRESS, LABEL_LENGTH);
80005a34:	30 6a       	mov	r10,6
80005a36:	30 0b       	mov	r11,0
80005a38:	4d cc       	lddpc	r12,80005ba8 <xg_flashc_init+0x23c>
80005a3a:	f0 1f 00 5e 	mcall	80005bb0 <xg_flashc_init+0x244>
			
			//set current_voice_index
			memset(str, 0x00, sizeof(str));
80005a3e:	4d 97       	lddpc	r7,80005ba0 <xg_flashc_init+0x234>
80005a40:	35 0a       	mov	r10,80
80005a42:	30 0b       	mov	r11,0
80005a44:	0e 9c       	mov	r12,r7
80005a46:	f0 1f 00 5c 	mcall	80005bb4 <xg_flashc_init+0x248>
			return_code = data_flash_write(str, MESSAGE_NUMBERS_ADD, MESSAGE_NUMBERS_LENGTH);
80005a4a:	30 2a       	mov	r10,2
80005a4c:	30 6b       	mov	r11,6
80005a4e:	0e 9c       	mov	r12,r7
80005a50:	f0 1f 00 58 	mcall	80005bb0 <xg_flashc_init+0x244>
			if(return_code != DF_WRITE_COMPLETED)
80005a54:	58 7c       	cp.w	r12,7
80005a56:	e0 81 00 8a 	brne	80005b6a <xg_flashc_init+0x1fe>
			{
				return FALSE;
			}
			current_message_index = 0;
80005a5a:	30 09       	mov	r9,0
80005a5c:	4d 78       	lddpc	r8,80005bb8 <xg_flashc_init+0x24c>
80005a5e:	b0 09       	st.h	r8[0x0],r9
			log("\r\n----create xg message info okay!----\r\n");
80005a60:	4d 7c       	lddpc	r12,80005bbc <xg_flashc_init+0x250>
80005a62:	f0 1f 00 47 	mcall	80005b7c <xg_flashc_init+0x210>
80005a66:	c7 f8       	rjmp	80005b64 <xg_flashc_init+0x1f8>
		}
		else//success
		{
			log("\nLABEL: %s\n", str);
80005a68:	1a d7       	st.w	--sp,r7
80005a6a:	4d 6c       	lddpc	r12,80005bc0 <xg_flashc_init+0x254>
80005a6c:	f0 1f 00 44 	mcall	80005b7c <xg_flashc_init+0x210>
			//Get the current voice index
			return_code = data_flash_read_block(MESSAGE_NUMBERS_ADD, MESSAGE_NUMBERS_LENGTH, &current_message_index);								
80005a70:	4d 2a       	lddpc	r10,80005bb8 <xg_flashc_init+0x24c>
80005a72:	30 2b       	mov	r11,2
80005a74:	30 6c       	mov	r12,6
80005a76:	f0 1f 00 4c 	mcall	80005ba4 <xg_flashc_init+0x238>
			if(return_code == DF_OK)
80005a7a:	2f fd       	sub	sp,-4
80005a7c:	58 0c       	cp.w	r12,0
80005a7e:	c7 61       	brne	80005b6a <xg_flashc_init+0x1fe>
			{
				//Calculates the offset address of the current stored message
				if(current_message_index != 0){
80005a80:	4c e8       	lddpc	r8,80005bb8 <xg_flashc_init+0x24c>
80005a82:	90 09       	ld.sh	r9,r8[0x0]
80005a84:	30 08       	mov	r8,0
80005a86:	f0 09 19 00 	cp.h	r9,r8
80005a8a:	c6 a0       	breq	80005b5e <xg_flashc_init+0x1f2>
					
					memset(str, 0x00, sizeof(str));	
80005a8c:	30 08       	mov	r8,0
80005a8e:	30 09       	mov	r9,0
80005a90:	ee e9 00 00 	st.d	r7[0],r8
80005a94:	e8 e9 00 00 	st.d	r4[0],r8
80005a98:	e6 e9 00 00 	st.d	r3[0],r8
80005a9c:	e4 e9 00 00 	st.d	r2[0],r8
80005aa0:	e2 e9 00 00 	st.d	r1[0],r8
80005aa4:	e0 e9 00 00 	st.d	r0[0],r8
80005aa8:	40 0a       	lddsp	r10,sp[0x0]
80005aaa:	f4 e9 00 00 	st.d	r10[0],r8
80005aae:	40 1a       	lddsp	r10,sp[0x4]
80005ab0:	f4 e9 00 00 	st.d	r10[0],r8
80005ab4:	40 2a       	lddsp	r10,sp[0x8]
80005ab6:	b5 28       	st.d	r10++,r8
80005ab8:	f4 e9 00 00 	st.d	r10[0],r8
					address = XG_MESSAGE_INFO_HEADER_START_ADD + ((current_message_index -1)*XG_MESSAGE_INFO_HEADER_LENGTH);
80005abc:	4b f8       	lddpc	r8,80005bb8 <xg_flashc_init+0x24c>
80005abe:	90 85       	ld.uh	r5,r8[0x0]
80005ac0:	a3 75       	lsl	r5,0x3
					return_code = data_flash_read_block(address, XG_MESSAGE_INFO_HEADER_LENGTH, (U8 *)str);			
80005ac2:	0e 9a       	mov	r10,r7
80005ac4:	30 8b       	mov	r11,8
80005ac6:	0a 9c       	mov	r12,r5
80005ac8:	f0 1f 00 37 	mcall	80005ba4 <xg_flashc_init+0x238>
					if(return_code == DF_OK)
80005acc:	c4 91       	brne	80005b5e <xg_flashc_init+0x1f2>
					{
						MessageList_Info_t *ptr = (MessageList_Info_t *)str;
						if(ptr->numb == current_message_index)
80005ace:	0f 89       	ld.ub	r9,r7[0x0]
80005ad0:	0f 98       	ld.ub	r8,r7[0x1]
80005ad2:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80005ad6:	4b 99       	lddpc	r9,80005bb8 <xg_flashc_init+0x24c>
80005ad8:	92 09       	ld.sh	r9,r9[0x0]
80005ada:	f0 09 19 00 	cp.h	r9,r8
80005ade:	c2 c1       	brne	80005b36 <xg_flashc_init+0x1ca>
						{
							current_save_message_offset = ptr->address + ptr->offset;
80005ae0:	0f e9       	ld.ub	r9,r7[0x6]
80005ae2:	0f f8       	ld.ub	r8,r7[0x7]
80005ae4:	f1 e9 10 89 	or	r9,r8,r9<<0x8
80005ae8:	0f aa       	ld.ub	r10,r7[0x2]
80005aea:	0f b8       	ld.ub	r8,r7[0x3]
80005aec:	b1 68       	lsl	r8,0x10
80005aee:	f1 ea 11 88 	or	r8,r8,r10<<0x18
80005af2:	0f ca       	ld.ub	r10,r7[0x4]
80005af4:	f1 ea 10 88 	or	r8,r8,r10<<0x8
80005af8:	0f da       	ld.ub	r10,r7[0x5]
80005afa:	f5 e8 10 08 	or	r8,r10,r8
80005afe:	f2 08 00 08 	add	r8,r9,r8
80005b02:	4b 16       	lddpc	r6,80005bc4 <xg_flashc_init+0x258>
80005b04:	8d 08       	st.w	r6[0x0],r8
							log("current_save_message_offset : %X\n", current_save_message_offset);
80005b06:	1a d8       	st.w	--sp,r8
80005b08:	4b 0c       	lddpc	r12,80005bc8 <xg_flashc_init+0x25c>
80005b0a:	f0 1f 00 1d 	mcall	80005b7c <xg_flashc_init+0x210>
							if(current_save_message_offset > XG_MESSAGE_DATA_BOUNDARY_ADD){
80005b0e:	2f fd       	sub	sp,-4
80005b10:	6c 08       	ld.w	r8,r6[0x0]
80005b12:	e0 69 ff ff 	mov	r9,65535
80005b16:	ea 19 00 7f 	orh	r9,0x7f
80005b1a:	12 38       	cp.w	r8,r9
80005b1c:	e0 88 00 21 	brls	80005b5e <xg_flashc_init+0x1f2>
										
								log("\r\n----message storage is full!!!----\r\n");
80005b20:	4a bc       	lddpc	r12,80005bcc <xg_flashc_init+0x260>
80005b22:	f0 1f 00 17 	mcall	80005b7c <xg_flashc_init+0x210>
								//xgflash erase

								return_code = data_flash_erase_block(0, DF_BLOCK_ALL);
80005b26:	30 4b       	mov	r11,4
80005b28:	30 0c       	mov	r12,0
80005b2a:	f0 1f 00 2a 	mcall	80005bd0 <xg_flashc_init+0x264>
								if(return_code == DF_ERASE_COMPLETED)goto start;
80005b2e:	58 5c       	cp.w	r12,5
80005b30:	fe 90 ff 76 	breq	80005a1c <xg_flashc_init+0xb0>
80005b34:	c1 b8       	rjmp	80005b6a <xg_flashc_init+0x1fe>

							}
						}
						else
						{
							log("\r\n----message storage is err!!!----\r\n");
80005b36:	4a 8c       	lddpc	r12,80005bd4 <xg_flashc_init+0x268>
80005b38:	f0 1f 00 11 	mcall	80005b7c <xg_flashc_init+0x210>
		{
			ERASE:
			//erase list
			for(i; i < (XG_MESSAGE_LISTINFO_BOUNDARY_ADD/(64*1024)); i++)//2*64k
			{
				return_code = data_flash_erase_block(address, DF_BLOCK_64KB);
80005b3c:	30 3b       	mov	r11,3
80005b3e:	0a 9c       	mov	r12,r5
80005b40:	f0 1f 00 24 	mcall	80005bd0 <xg_flashc_init+0x264>
				if(return_code != DF_ERASE_COMPLETED)
80005b44:	58 5c       	cp.w	r12,5
80005b46:	c1 21       	brne	80005b6a <xg_flashc_init+0x1fe>
		{
			ERASE:
			//erase list
			for(i; i < (XG_MESSAGE_LISTINFO_BOUNDARY_ADD/(64*1024)); i++)//2*64k
			{
				return_code = data_flash_erase_block(address, DF_BLOCK_64KB);
80005b48:	30 3b       	mov	r11,3
80005b4a:	e0 78 00 00 	mov	r8,65536
80005b4e:	ea 08 00 0c 	add	r12,r5,r8
80005b52:	f0 1f 00 20 	mcall	80005bd0 <xg_flashc_init+0x264>
				if(return_code != DF_ERASE_COMPLETED)
80005b56:	58 5c       	cp.w	r12,5
80005b58:	fe 90 ff 6e 	breq	80005a34 <xg_flashc_init+0xc8>
80005b5c:	c0 78       	rjmp	80005b6a <xg_flashc_init+0x1fe>
							log("\r\n----message storage is err!!!----\r\n");
							goto ERASE;
						}
					}
				}
				log("\r\n----xoxo read message info okay!----\r\n");
80005b5e:	49 fc       	lddpc	r12,80005bd8 <xg_flashc_init+0x26c>
80005b60:	f0 1f 00 07 	mcall	80005b7c <xg_flashc_init+0x210>
			else
				return FALSE;
			
		}
				
		list_init_success_flag = 1;
80005b64:	30 19       	mov	r9,1
80005b66:	49 e8       	lddpc	r8,80005bdc <xg_flashc_init+0x270>
80005b68:	b0 89       	st.b	r8[0x0],r9
	
	//flashc_lock_all_regions(false);
	xgflash_list_info_init();
	//create_xg_flash_test_task();

}
80005b6a:	2f dd       	sub	sp,-12
80005b6c:	d8 32       	popm	r0-r7,pc
80005b6e:	00 00       	add	r0,r0
80005b70:	80 00       	ld.sh	r0,r0[0x0]
80005b72:	6d 24       	ld.w	r4,r6[0x48]
80005b74:	00 00       	add	r0,r0
80005b76:	0b 88       	ld.ub	r8,r5[0x0]
80005b78:	80 00       	ld.sh	r0,r0[0x0]
80005b7a:	e1 0c 80 00 	ld.sh	r12,r0[-32768]
80005b7e:	78 5c       	ld.w	r12,r12[0x14]
80005b80:	80 00       	ld.sh	r0,r0[0x0]
80005b82:	6d 7c       	ld.w	r12,r6[0x5c]
80005b84:	00 00       	add	r0,r0
80005b86:	54 20       	stdsp	sp[0x108],r0
80005b88:	80 00       	ld.sh	r0,r0[0x0]
80005b8a:	6c 24       	ld.w	r4,r6[0x8]
80005b8c:	00 00       	add	r0,r0
80005b8e:	0b 80       	ld.ub	r0,r5[0x0]
80005b90:	00 00       	add	r0,r0
80005b92:	0b 90       	ld.ub	r0,r5[0x1]
80005b94:	00 00       	add	r0,r0
80005b96:	0e 0e       	add	lr,r7
80005b98:	80 00       	ld.sh	r0,r0[0x0]
80005b9a:	32 1c       	mov	r12,33
80005b9c:	80 00       	ld.sh	r0,r0[0x0]
80005b9e:	2e ec       	sub	r12,-18
80005ba0:	00 00       	add	r0,r0
80005ba2:	0b 94       	ld.ub	r4,r5[0x1]
80005ba4:	80 00       	ld.sh	r0,r0[0x0]
80005ba6:	2b c4       	sub	r4,-68
80005ba8:	00 00       	add	r0,r0
80005baa:	05 38       	ld.ub	r8,r2++
80005bac:	80 00       	ld.sh	r0,r0[0x0]
80005bae:	80 e0       	ld.uh	r0,r0[0xc]
80005bb0:	80 00       	ld.sh	r0,r0[0x0]
80005bb2:	2d fc       	sub	r12,-33
80005bb4:	80 00       	ld.sh	r0,r0[0x0]
80005bb6:	82 4e       	ld.sh	lr,r1[0x8]
80005bb8:	00 00       	add	r0,r0
80005bba:	0b 8c       	ld.ub	r12,r5[0x0]
80005bbc:	80 00       	ld.sh	r0,r0[0x0]
80005bbe:	e1 38 80 00 	ld.ub	r8,r0[-32768]
80005bc2:	e1 64 00 00 	st.b	r0[0],r4
80005bc6:	05 40       	ld.w	r0,--r2
80005bc8:	80 00       	ld.sh	r0,r0[0x0]
80005bca:	e1 70 80 00 	stcond	r0[-32768],r0
80005bce:	e1 94       	*unknown*
80005bd0:	80 00       	ld.sh	r0,r0[0x0]
80005bd2:	2d 5c       	sub	r12,-43
80005bd4:	80 00       	ld.sh	r0,r0[0x0]
80005bd6:	e1 bc       	*unknown*
80005bd8:	80 00       	ld.sh	r0,r0[0x0]
80005bda:	e1 e4 00 00 	and	r0,r0,r4
80005bde:	0b 84       	ld.ub	r4,r5[0x0]

80005be0 <flashc_set_wait_state>:
}


void flashc_set_wait_state(unsigned int wait_state)
{
	u_avr32_flashc_fcr_t u_avr32_flashc_fcr = {AVR32_FLASHC.fcr};
80005be0:	fe 68 14 00 	mov	r8,-125952
80005be4:	70 09       	ld.w	r9,r8[0x0]
	u_avr32_flashc_fcr.FCR.fws = wait_state;
80005be6:	f3 dc d0 c1 	bfins	r9,r12,0x6,0x1
	AVR32_FLASHC.fcr = u_avr32_flashc_fcr.fcr;
80005bea:	91 09       	st.w	r8[0x0],r9
}
80005bec:	5e fc       	retal	r12

80005bee <gpio_enable_module_pin>:
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80005bee:	f8 08 16 05 	lsr	r8,r12,0x5
80005bf2:	a9 68       	lsl	r8,0x8
80005bf4:	e0 28 f0 00 	sub	r8,61440

	/* Enable the correct function. */
	switch (function) {
80005bf8:	58 1b       	cp.w	r11,1
80005bfa:	c0 d0       	breq	80005c14 <gpio_enable_module_pin+0x26>
80005bfc:	c0 63       	brcs	80005c08 <gpio_enable_module_pin+0x1a>
80005bfe:	58 2b       	cp.w	r11,2
80005c00:	c1 00       	breq	80005c20 <gpio_enable_module_pin+0x32>
80005c02:	58 3b       	cp.w	r11,3
80005c04:	c1 40       	breq	80005c2c <gpio_enable_module_pin+0x3e>
80005c06:	5e ff       	retal	1
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80005c08:	30 19       	mov	r9,1
80005c0a:	f2 0c 09 49 	lsl	r9,r9,r12
80005c0e:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80005c10:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80005c12:	c1 28       	rjmp	80005c36 <gpio_enable_module_pin+0x48>

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80005c14:	30 19       	mov	r9,1
80005c16:	f2 0c 09 49 	lsl	r9,r9,r12
80005c1a:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80005c1c:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80005c1e:	c0 c8       	rjmp	80005c36 <gpio_enable_module_pin+0x48>

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80005c20:	30 19       	mov	r9,1
80005c22:	f2 0c 09 49 	lsl	r9,r9,r12
80005c26:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80005c28:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80005c2a:	c0 68       	rjmp	80005c36 <gpio_enable_module_pin+0x48>

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80005c2c:	30 19       	mov	r9,1
80005c2e:	f2 0c 09 49 	lsl	r9,r9,r12
80005c32:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80005c34:	91 99       	st.w	r8[0x24],r9
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
80005c36:	30 19       	mov	r9,1
80005c38:	f2 0c 09 4c 	lsl	r12,r9,r12
80005c3c:	91 2c       	st.w	r8[0x8],r12
80005c3e:	5e fd       	retal	0

80005c40 <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
80005c40:	d4 21       	pushm	r4-r7,lr
80005c42:	18 97       	mov	r7,r12
80005c44:	16 94       	mov	r4,r11
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
80005c46:	58 0b       	cp.w	r11,0
80005c48:	c0 31       	brne	80005c4e <gpio_enable_module+0xe>
80005c4a:	30 05       	mov	r5,0
80005c4c:	c0 d8       	rjmp	80005c66 <gpio_enable_module+0x26>
80005c4e:	30 06       	mov	r6,0
80005c50:	0c 95       	mov	r5,r6
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
80005c52:	6e 1b       	ld.w	r11,r7[0x4]
80005c54:	6e 0c       	ld.w	r12,r7[0x0]
80005c56:	f0 1f 00 06 	mcall	80005c6c <gpio_enable_module+0x2c>
80005c5a:	18 45       	or	r5,r12
		gpiomap++;
80005c5c:	2f 87       	sub	r7,-8
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
80005c5e:	2f f6       	sub	r6,-1
80005c60:	0c 34       	cp.w	r4,r6
80005c62:	fe 9b ff f8 	brhi	80005c52 <gpio_enable_module+0x12>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
}
80005c66:	0a 9c       	mov	r12,r5
80005c68:	d8 22       	popm	r4-r7,pc
80005c6a:	00 00       	add	r0,r0
80005c6c:	80 00       	ld.sh	r0,r0[0x0]
80005c6e:	5b ee       	cp.w	lr,-2

80005c70 <gpio_enable_gpio_pin>:
 *            AVR32_PWM_3_PIN for PWM channel 3 can also be used to release
 *            module pins for GPIO.
 */
void gpio_enable_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80005c70:	f8 08 16 05 	lsr	r8,r12,0x5
80005c74:	a9 68       	lsl	r8,0x8
80005c76:	e0 28 f0 00 	sub	r8,61440
	
	gpio_port->oderc = 1 << (pin & 0x1F);
80005c7a:	30 19       	mov	r9,1
80005c7c:	f2 0c 09 4c 	lsl	r12,r9,r12
80005c80:	f1 4c 00 48 	st.w	r8[72],r12
	gpio_port->gpers = 1 << (pin & 0x1F);
80005c84:	91 1c       	st.w	r8[0x4],r12
}
80005c86:	5e fc       	retal	r12

80005c88 <gpio_set_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_set_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80005c88:	f8 08 16 05 	lsr	r8,r12,0x5
80005c8c:	a9 68       	lsl	r8,0x8
80005c8e:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 1. */
	gpio_port->ovrs  = 1 << (pin & 0x1F);
80005c92:	30 19       	mov	r9,1
80005c94:	f2 0c 09 4c 	lsl	r12,r9,r12
80005c98:	f1 4c 00 54 	st.w	r8[84],r12
	/* The GPIO output driver is enabled for that pin. */ 
	gpio_port->oders = 1 << (pin & 0x1F);
80005c9c:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
80005ca0:	91 1c       	st.w	r8[0x4],r12
}
80005ca2:	5e fc       	retal	r12

80005ca4 <gpio_clr_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_clr_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80005ca4:	f8 08 16 05 	lsr	r8,r12,0x5
80005ca8:	a9 68       	lsl	r8,0x8
80005caa:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 0. */
	gpio_port->ovrc  = 1 << (pin & 0x1F);
80005cae:	30 19       	mov	r9,1
80005cb0:	f2 0c 09 4c 	lsl	r12,r9,r12
80005cb4:	f1 4c 00 58 	st.w	r8[88],r12
	/* The GPIO output driver is enabled for that pin. */
	gpio_port->oders = 1 << (pin & 0x1F);
80005cb8:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
80005cbc:	91 1c       	st.w	r8[0x4],r12
}
80005cbe:	5e fc       	retal	r12

80005cc0 <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
80005cc0:	c0 08       	rjmp	80005cc0 <_unhandled_interrupt>
80005cc2:	d7 03       	nop

80005cc4 <INTC_register_interrupt>:
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
80005cc4:	f6 08 16 05 	lsr	r8,r11,0x5

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
80005cc8:	49 99       	lddpc	r9,80005d2c <INTC_register_interrupt+0x68>
80005cca:	f2 08 00 39 	add	r9,r9,r8<<0x3
80005cce:	f7 db c0 05 	bfextu	r11,r11,0x0,0x5
80005cd2:	72 19       	ld.w	r9,r9[0x4]
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
80005cd4:	f2 0b 09 2c 	st.w	r9[r11<<0x2],r12
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
80005cd8:	58 0a       	cp.w	r10,0
80005cda:	c0 91       	brne	80005cec <INTC_register_interrupt+0x28>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80005cdc:	49 59       	lddpc	r9,80005d30 <INTC_register_interrupt+0x6c>
80005cde:	49 6a       	lddpc	r10,80005d34 <INTC_register_interrupt+0x70>
80005ce0:	12 1a       	sub	r10,r9
80005ce2:	fe 79 08 00 	mov	r9,-63488
80005ce6:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80005cea:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT1) {
80005cec:	58 1a       	cp.w	r10,1
80005cee:	c0 a1       	brne	80005d02 <INTC_register_interrupt+0x3e>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
80005cf0:	49 09       	lddpc	r9,80005d30 <INTC_register_interrupt+0x6c>
80005cf2:	49 2a       	lddpc	r10,80005d38 <INTC_register_interrupt+0x74>
80005cf4:	12 1a       	sub	r10,r9
80005cf6:	bf aa       	sbr	r10,0x1e
80005cf8:	fe 79 08 00 	mov	r9,-63488
80005cfc:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80005d00:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT2) {
80005d02:	58 2a       	cp.w	r10,2
80005d04:	c0 a1       	brne	80005d18 <INTC_register_interrupt+0x54>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
80005d06:	48 b9       	lddpc	r9,80005d30 <INTC_register_interrupt+0x6c>
80005d08:	48 da       	lddpc	r10,80005d3c <INTC_register_interrupt+0x78>
80005d0a:	12 1a       	sub	r10,r9
80005d0c:	bf ba       	sbr	r10,0x1f
80005d0e:	fe 79 08 00 	mov	r9,-63488
80005d12:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80005d16:	5e fc       	retal	r12
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
80005d18:	48 69       	lddpc	r9,80005d30 <INTC_register_interrupt+0x6c>
80005d1a:	48 aa       	lddpc	r10,80005d40 <INTC_register_interrupt+0x7c>
80005d1c:	12 1a       	sub	r10,r9
80005d1e:	ea 1a c0 00 	orh	r10,0xc000
80005d22:	fe 79 08 00 	mov	r9,-63488
80005d26:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80005d2a:	5e fc       	retal	r12
80005d2c:	80 00       	ld.sh	r0,r0[0x0]
80005d2e:	e2 f0 80 00 	ld.w	r0,r1[-32768]
80005d32:	d6 00       	acall	0x60
80005d34:	80 00       	ld.sh	r0,r0[0x0]
80005d36:	d7 04       	*unknown*
80005d38:	80 00       	ld.sh	r0,r0[0x0]
80005d3a:	d7 12       	popm	r0-r3,r11-r12,lr
80005d3c:	80 00       	ld.sh	r0,r0[0x0]
80005d3e:	d7 20       	acall	0x72
80005d40:	80 00       	ld.sh	r0,r0[0x0]
80005d42:	d7 2e       	*unknown*

80005d44 <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
80005d44:	d4 21       	pushm	r4-r7,lr
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
80005d46:	49 18       	lddpc	r8,80005d88 <INTC_init_interrupts+0x44>
80005d48:	e3 b8 00 01 	mtsr	0x4,r8
80005d4c:	49 0e       	lddpc	lr,80005d8c <INTC_init_interrupts+0x48>
80005d4e:	30 07       	mov	r7,0
80005d50:	0e 94       	mov	r4,r7
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
80005d52:	49 0c       	lddpc	r12,80005d90 <INTC_init_interrupts+0x4c>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80005d54:	49 05       	lddpc	r5,80005d94 <INTC_init_interrupts+0x50>
80005d56:	10 15       	sub	r5,r8
80005d58:	fe 76 08 00 	mov	r6,-63488
80005d5c:	c1 08       	rjmp	80005d7c <INTC_init_interrupts+0x38>
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
80005d5e:	08 98       	mov	r8,r4
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
				._int_line_handler_table[int_req]
80005d60:	7c 1b       	ld.w	r11,lr[0x4]

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80005d62:	7c 0a       	ld.w	r10,lr[0x0]
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
80005d64:	f6 08 09 2c 	st.w	r11[r8<<0x2],r12
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
80005d68:	2f f8       	sub	r8,-1

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80005d6a:	10 3a       	cp.w	r10,r8
80005d6c:	fe 9b ff fc 	brhi	80005d64 <INTC_init_interrupts+0x20>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80005d70:	ec 07 09 25 	st.w	r6[r7<<0x2],r5
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
80005d74:	2f f7       	sub	r7,-1
80005d76:	2f 8e       	sub	lr,-8
80005d78:	59 37       	cp.w	r7,19
80005d7a:	c0 50       	breq	80005d84 <INTC_init_interrupts+0x40>
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80005d7c:	7c 08       	ld.w	r8,lr[0x0]
80005d7e:	58 08       	cp.w	r8,0
80005d80:	ce f1       	brne	80005d5e <INTC_init_interrupts+0x1a>
80005d82:	cf 7b       	rjmp	80005d70 <INTC_init_interrupts+0x2c>
80005d84:	d8 22       	popm	r4-r7,pc
80005d86:	00 00       	add	r0,r0
80005d88:	80 00       	ld.sh	r0,r0[0x0]
80005d8a:	d6 00       	acall	0x60
80005d8c:	80 00       	ld.sh	r0,r0[0x0]
80005d8e:	e2 f0 80 00 	ld.w	r0,r1[-32768]
80005d92:	5c c0       	swap.bh	r0
80005d94:	80 00       	ld.sh	r0,r0[0x0]
80005d96:	d7 04       	*unknown*

80005d98 <_get_interrupt_handler>:
__int_handler _get_interrupt_handler(uint32_t int_level)
{
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
80005d98:	fe 78 08 00 	mov	r8,-63488
80005d9c:	e0 69 00 83 	mov	r9,131
80005da0:	f2 0c 01 0c 	sub	r12,r9,r12
80005da4:	f0 0c 03 29 	ld.w	r9,r8[r12<<0x2]
	uint32_t int_req = AVR32_INTC.irr[int_grp];
80005da8:	f2 ca ff c0 	sub	r10,r9,-64
80005dac:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
80005db0:	58 08       	cp.w	r8,0
80005db2:	c0 21       	brne	80005db6 <_get_interrupt_handler+0x1e>
80005db4:	5e fd       	retal	0
		? _int_handler_table[int_grp]._int_line_handler_table[32
80005db6:	f0 08 12 00 	clz	r8,r8
80005dba:	48 5a       	lddpc	r10,80005dcc <_get_interrupt_handler+0x34>
80005dbc:	f4 09 00 39 	add	r9,r10,r9<<0x3
80005dc0:	f0 08 11 1f 	rsub	r8,r8,31
80005dc4:	72 19       	ld.w	r9,r9[0x4]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
80005dc6:	f2 08 03 2c 	ld.w	r12,r9[r8<<0x2]
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
80005dca:	5e fc       	retal	r12
80005dcc:	80 00       	ld.sh	r0,r0[0x0]
80005dce:	e2 f0 78 a8 	ld.w	r0,r1[30888]

80005dd0 <pm_set_osc0_mode>:
 * \param mode Oscillator 0 mode (i.e. AVR32_PM_OSCCTRL0_MODE_x).
 */
static void pm_set_osc0_mode(volatile avr32_pm_t *pm, unsigned int mode)
{
  // Read
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
80005dd0:	78 a8       	ld.w	r8,r12[0x28]
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.mode = mode;
80005dd2:	f1 db d0 03 	bfins	r8,r11,0x0,0x3
  // Write
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
80005dd6:	99 a8       	st.w	r12[0x28],r8
}
80005dd8:	5e fc       	retal	r12
80005dda:	d7 03       	nop

80005ddc <pm_enable_osc0_crystal>:
  pm_set_osc0_mode(pm, AVR32_PM_OSCCTRL0_MODE_EXT_CLOCK);
}


void pm_enable_osc0_crystal(volatile avr32_pm_t *pm, unsigned int fosc0)
{
80005ddc:	d4 01       	pushm	lr
  pm_set_osc0_mode(pm, (fosc0 <  900000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G0 :
80005dde:	ec 5b bb 9f 	cp.w	r11,899999
80005de2:	e0 8b 00 04 	brhi	80005dea <pm_enable_osc0_crystal+0xe>
80005de6:	30 4b       	mov	r11,4
80005de8:	c1 38       	rjmp	80005e0e <pm_enable_osc0_crystal+0x32>
80005dea:	e0 68 c6 bf 	mov	r8,50879
80005dee:	ea 18 00 2d 	orh	r8,0x2d
80005df2:	10 3b       	cp.w	r11,r8
80005df4:	e0 8b 00 04 	brhi	80005dfc <pm_enable_osc0_crystal+0x20>
80005df8:	30 5b       	mov	r11,5
80005dfa:	c0 a8       	rjmp	80005e0e <pm_enable_osc0_crystal+0x32>
80005dfc:	e0 68 12 00 	mov	r8,4608
80005e00:	ea 18 00 7a 	orh	r8,0x7a
80005e04:	10 3b       	cp.w	r11,r8
80005e06:	f9 bb 03 06 	movlo	r11,6
80005e0a:	f9 bb 02 07 	movhs	r11,7
80005e0e:	f0 1f 00 02 	mcall	80005e14 <pm_enable_osc0_crystal+0x38>
                       (fosc0 < 3000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G1 :
                       (fosc0 < 8000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G2 :
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}
80005e12:	d8 02       	popm	pc
80005e14:	80 00       	ld.sh	r0,r0[0x0]
80005e16:	5d d0       	*unknown*

80005e18 <pm_enable_clk0_no_wait>:


void pm_enable_clk0_no_wait(volatile avr32_pm_t *pm, unsigned int startup)
{
  // Read register
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
80005e18:	78 a8       	ld.w	r8,r12[0x28]
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.startup = startup;
80005e1a:	f1 db d1 03 	bfins	r8,r11,0x8,0x3
  // Write back
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
80005e1e:	99 a8       	st.w	r12[0x28],r8

  pm->mcctrl |= AVR32_PM_MCCTRL_OSC0EN_MASK;
80005e20:	78 08       	ld.w	r8,r12[0x0]
80005e22:	a3 a8       	sbr	r8,0x2
80005e24:	99 08       	st.w	r12[0x0],r8
}
80005e26:	5e fc       	retal	r12

80005e28 <pm_wait_for_clk0_ready>:


void pm_wait_for_clk0_ready(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
80005e28:	79 58       	ld.w	r8,r12[0x54]
80005e2a:	e2 18 00 80 	andl	r8,0x80,COH
80005e2e:	cf d0       	breq	80005e28 <pm_wait_for_clk0_ready>
}
80005e30:	5e fc       	retal	r12
80005e32:	d7 03       	nop

80005e34 <pm_enable_clk0>:
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}


void pm_enable_clk0(volatile avr32_pm_t *pm, unsigned int startup)
{
80005e34:	eb cd 40 80 	pushm	r7,lr
80005e38:	18 97       	mov	r7,r12
  pm_enable_clk0_no_wait(pm, startup);
80005e3a:	f0 1f 00 04 	mcall	80005e48 <pm_enable_clk0+0x14>
  pm_wait_for_clk0_ready(pm);
80005e3e:	0e 9c       	mov	r12,r7
80005e40:	f0 1f 00 03 	mcall	80005e4c <pm_enable_clk0+0x18>
}
80005e44:	e3 cd 80 80 	ldm	sp++,r7,pc
80005e48:	80 00       	ld.sh	r0,r0[0x0]
80005e4a:	5e 18       	retne	r8
80005e4c:	80 00       	ld.sh	r0,r0[0x0]
80005e4e:	5e 28       	reths	r8

80005e50 <pm_set_osc32_mode>:
 * \param mode 32-kHz oscillator mode (i.e. AVR32_PM_OSCCTRL32_MODE_x).
 */
static void pm_set_osc32_mode(volatile avr32_pm_t *pm, unsigned int mode)
{
  // Read
  u_avr32_pm_oscctrl32_t u_avr32_pm_oscctrl32 = {pm->oscctrl32};
80005e50:	78 c8       	ld.w	r8,r12[0x30]
  // Modify
  u_avr32_pm_oscctrl32.OSCCTRL32.mode = mode;
80005e52:	f1 db d1 03 	bfins	r8,r11,0x8,0x3
  // Write
  pm->oscctrl32 = u_avr32_pm_oscctrl32.oscctrl32;
80005e56:	99 c8       	st.w	r12[0x30],r8
}
80005e58:	5e fc       	retal	r12
80005e5a:	d7 03       	nop

80005e5c <pm_enable_osc32_crystal>:
  pm_set_osc32_mode(pm, AVR32_PM_OSCCTRL32_MODE_EXT_CLOCK);
}


void pm_enable_osc32_crystal(volatile avr32_pm_t *pm)
{
80005e5c:	d4 01       	pushm	lr
  pm_set_osc32_mode(pm, AVR32_PM_OSCCTRL32_MODE_CRYSTAL);
80005e5e:	30 1b       	mov	r11,1
80005e60:	f0 1f 00 02 	mcall	80005e68 <pm_enable_osc32_crystal+0xc>
}
80005e64:	d8 02       	popm	pc
80005e66:	00 00       	add	r0,r0
80005e68:	80 00       	ld.sh	r0,r0[0x0]
80005e6a:	5e 50       	retlt	r0

80005e6c <pm_enable_clk32_no_wait>:


void pm_enable_clk32_no_wait(volatile avr32_pm_t *pm, unsigned int startup)
{
  // Read register
  u_avr32_pm_oscctrl32_t u_avr32_pm_oscctrl32 = {pm->oscctrl32};
80005e6c:	78 c8       	ld.w	r8,r12[0x30]
  // Modify
  u_avr32_pm_oscctrl32.OSCCTRL32.osc32en = 1;
80005e6e:	30 19       	mov	r9,1
80005e70:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
  u_avr32_pm_oscctrl32.OSCCTRL32.startup = startup;
80005e74:	f1 db d2 03 	bfins	r8,r11,0x10,0x3
  // Write back
  pm->oscctrl32 = u_avr32_pm_oscctrl32.oscctrl32;
80005e78:	99 c8       	st.w	r12[0x30],r8
}
80005e7a:	5e fc       	retal	r12

80005e7c <pm_wait_for_clk32_ready>:


void pm_wait_for_clk32_ready(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_OSC32RDY_MASK));
80005e7c:	79 58       	ld.w	r8,r12[0x54]
80005e7e:	e2 18 02 00 	andl	r8,0x200,COH
80005e82:	cf d0       	breq	80005e7c <pm_wait_for_clk32_ready>
}
80005e84:	5e fc       	retal	r12
80005e86:	d7 03       	nop

80005e88 <pm_enable_clk32>:
  pm_set_osc32_mode(pm, AVR32_PM_OSCCTRL32_MODE_CRYSTAL);
}


void pm_enable_clk32(volatile avr32_pm_t *pm, unsigned int startup)
{
80005e88:	eb cd 40 80 	pushm	r7,lr
80005e8c:	18 97       	mov	r7,r12
  pm_enable_clk32_no_wait(pm, startup);
80005e8e:	f0 1f 00 04 	mcall	80005e9c <pm_enable_clk32+0x14>
  pm_wait_for_clk32_ready(pm);
80005e92:	0e 9c       	mov	r12,r7
80005e94:	f0 1f 00 03 	mcall	80005ea0 <pm_enable_clk32+0x18>
}
80005e98:	e3 cd 80 80 	ldm	sp++,r7,pc
80005e9c:	80 00       	ld.sh	r0,r0[0x0]
80005e9e:	5e 6c       	retmi	r12
80005ea0:	80 00       	ld.sh	r0,r0[0x0]
80005ea2:	5e 7c       	retpl	r12

80005ea4 <pm_cksel>:
              unsigned int pbasel,
              unsigned int pbbdiv,
              unsigned int pbbsel,
              unsigned int hsbdiv,
              unsigned int hsbsel)
{
80005ea4:	eb cd 40 d0 	pushm	r4,r6-r7,lr
80005ea8:	fa c4 ff f0 	sub	r4,sp,-16
  u_avr32_pm_cksel_t u_avr32_pm_cksel = {0};
80005eac:	30 0e       	mov	lr,0

  u_avr32_pm_cksel.CKSEL.cpusel = hsbsel;
80005eae:	09 f7       	ld.ub	r7,r4[0x7]
80005eb0:	ef d7 c0 03 	bfextu	r7,r7,0x0,0x3
80005eb4:	fd d7 d0 03 	bfins	lr,r7,0x0,0x3
  u_avr32_pm_cksel.CKSEL.cpudiv = hsbdiv;
80005eb8:	09 b4       	ld.ub	r4,r4[0x3]
80005eba:	08 96       	mov	r6,r4
80005ebc:	e9 d4 c0 01 	bfextu	r4,r4,0x0,0x1
80005ec0:	fd d4 d0 e1 	bfins	lr,r4,0x7,0x1
  u_avr32_pm_cksel.CKSEL.hsbsel = hsbsel;
80005ec4:	fd d7 d1 03 	bfins	lr,r7,0x8,0x3
  u_avr32_pm_cksel.CKSEL.hsbdiv = hsbdiv;
80005ec8:	fd d4 d1 e1 	bfins	lr,r4,0xf,0x1
  u_avr32_pm_cksel.CKSEL.pbasel = pbasel;
80005ecc:	fd da d2 03 	bfins	lr,r10,0x10,0x3
  u_avr32_pm_cksel.CKSEL.pbadiv = pbadiv;
80005ed0:	fd db d2 e1 	bfins	lr,r11,0x17,0x1
  u_avr32_pm_cksel.CKSEL.pbbsel = pbbsel;
80005ed4:	fd d8 d3 03 	bfins	lr,r8,0x18,0x3
  u_avr32_pm_cksel.CKSEL.pbbdiv = pbbdiv;
80005ed8:	fd d9 d3 e1 	bfins	lr,r9,0x1f,0x1

  pm->cksel = u_avr32_pm_cksel.cksel;
80005edc:	99 1e       	st.w	r12[0x4],lr

  // Wait for ckrdy bit and then clear it
  while (!(pm->poscsr & AVR32_PM_POSCSR_CKRDY_MASK));
80005ede:	79 58       	ld.w	r8,r12[0x54]
80005ee0:	e2 18 00 20 	andl	r8,0x20,COH
80005ee4:	cf d0       	breq	80005ede <pm_cksel+0x3a>
}
80005ee6:	e3 cd 80 d0 	ldm	sp++,r4,r6-r7,pc

80005eea <pm_pll_setup>:
                  unsigned int pll,
                  unsigned int mul,
                  unsigned int div,
                  unsigned int osc,
                  unsigned int lockcount)
{
80005eea:	eb cd 40 80 	pushm	r7,lr
80005eee:	40 27       	lddsp	r7,sp[0x8]
  u_avr32_pm_pll_t u_avr32_pm_pll = {0};
80005ef0:	30 0e       	mov	lr,0

  u_avr32_pm_pll.PLL.pllosc   = osc;
80005ef2:	fd d8 d0 21 	bfins	lr,r8,0x1,0x1
  u_avr32_pm_pll.PLL.plldiv   = div;
80005ef6:	fd d9 d1 04 	bfins	lr,r9,0x8,0x4
  u_avr32_pm_pll.PLL.pllmul   = mul;
80005efa:	fd da d2 04 	bfins	lr,r10,0x10,0x4
  u_avr32_pm_pll.PLL.pllcount = lockcount;
80005efe:	fd d7 d3 06 	bfins	lr,r7,0x18,0x6

  pm->pll[pll] = u_avr32_pm_pll.pll;
80005f02:	2f 8b       	sub	r11,-8
80005f04:	f8 0b 09 2e 	st.w	r12[r11<<0x2],lr
}
80005f08:	e3 cd 80 80 	ldm	sp++,r7,pc

80005f0c <pm_pll_set_option>:
void pm_pll_set_option(volatile avr32_pm_t *pm,
                       unsigned int pll,
                       unsigned int pll_freq,
                       unsigned int pll_div2,
                       unsigned int pll_wbwdisable)
{
80005f0c:	d4 01       	pushm	lr
  u_avr32_pm_pll_t u_avr32_pm_pll = {pm->pll[pll]};
80005f0e:	2f 8b       	sub	r11,-8
80005f10:	f8 0b 03 2e 	ld.w	lr,r12[r11<<0x2]
  u_avr32_pm_pll.PLL.pllopt = pll_freq | (pll_div2 << 1) | (pll_wbwdisable << 2);
80005f14:	f5 e9 10 19 	or	r9,r10,r9<<0x1
80005f18:	f3 e8 10 28 	or	r8,r9,r8<<0x2
80005f1c:	fd d8 d0 43 	bfins	lr,r8,0x2,0x3
  pm->pll[pll] = u_avr32_pm_pll.pll;
80005f20:	f8 0b 09 2e 	st.w	r12[r11<<0x2],lr
}
80005f24:	d8 02       	popm	pc

80005f26 <pm_pll_enable>:


void pm_pll_enable(volatile avr32_pm_t *pm,
                  unsigned int pll)
{
  pm->pll[pll] |= AVR32_PM_PLLEN_MASK;
80005f26:	2f 8b       	sub	r11,-8
80005f28:	f8 0b 03 28 	ld.w	r8,r12[r11<<0x2]
80005f2c:	a1 a8       	sbr	r8,0x0
80005f2e:	f8 0b 09 28 	st.w	r12[r11<<0x2],r8
}
80005f32:	5e fc       	retal	r12

80005f34 <pm_wait_for_pll0_locked>:
}


void pm_wait_for_pll0_locked(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_LOCK0_MASK));
80005f34:	79 58       	ld.w	r8,r12[0x54]
80005f36:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80005f3a:	cf d0       	breq	80005f34 <pm_wait_for_pll0_locked>
}
80005f3c:	5e fc       	retal	r12

80005f3e <pm_switch_to_clock>:


void pm_switch_to_clock(volatile avr32_pm_t *pm, unsigned long clock)
{
  // Read
  u_avr32_pm_mcctrl_t u_avr32_pm_mcctrl = {pm->mcctrl};
80005f3e:	78 08       	ld.w	r8,r12[0x0]
  // Modify
  u_avr32_pm_mcctrl.MCCTRL.mcsel = clock;
80005f40:	f1 db d0 02 	bfins	r8,r11,0x0,0x2
  // Write back
  pm->mcctrl = u_avr32_pm_mcctrl.mcctrl;
80005f44:	99 08       	st.w	r12[0x0],r8
}
80005f46:	5e fc       	retal	r12

80005f48 <pm_switch_to_osc0>:


void pm_switch_to_osc0(volatile avr32_pm_t *pm, unsigned int fosc0, unsigned int startup)
{
80005f48:	eb cd 40 c0 	pushm	r6-r7,lr
80005f4c:	18 97       	mov	r7,r12
80005f4e:	14 96       	mov	r6,r10
  pm_enable_osc0_crystal(pm, fosc0);            // Enable the Osc0 in crystal mode
80005f50:	f0 1f 00 06 	mcall	80005f68 <pm_switch_to_osc0+0x20>
  pm_enable_clk0(pm, startup);                  // Crystal startup time - This parameter is critical and depends on the characteristics of the crystal
80005f54:	0c 9b       	mov	r11,r6
80005f56:	0e 9c       	mov	r12,r7
80005f58:	f0 1f 00 05 	mcall	80005f6c <pm_switch_to_osc0+0x24>
  pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);  // Then switch main clock to Osc0
80005f5c:	30 1b       	mov	r11,1
80005f5e:	0e 9c       	mov	r12,r7
80005f60:	f0 1f 00 04 	mcall	80005f70 <pm_switch_to_osc0+0x28>
}
80005f64:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005f68:	80 00       	ld.sh	r0,r0[0x0]
80005f6a:	5d dc       	*unknown*
80005f6c:	80 00       	ld.sh	r0,r0[0x0]
80005f6e:	5e 34       	retlo	r4
80005f70:	80 00       	ld.sh	r0,r0[0x0]
80005f72:	5f 3e       	srlo	lr

80005f74 <rtc_is_busy>:
#include "rtc.h"


int rtc_is_busy(volatile avr32_rtc_t *rtc)
{
  return (rtc->ctrl & AVR32_RTC_CTRL_BUSY_MASK) != 0;
80005f74:	78 0c       	ld.w	r12,r12[0x0]
}
80005f76:	f9 dc c0 81 	bfextu	r12,r12,0x4,0x1
80005f7a:	5e fc       	retal	r12

80005f7c <rtc_set_value>:
  return 1;
}


void rtc_set_value(volatile avr32_rtc_t *rtc, unsigned long val)
{
80005f7c:	eb cd 40 c0 	pushm	r6-r7,lr
80005f80:	18 97       	mov	r7,r12
80005f82:	16 96       	mov	r6,r11
  // Wait until we can write into the VAL register
  while (rtc_is_busy(rtc));
80005f84:	0e 9c       	mov	r12,r7
80005f86:	f0 1f 00 06 	mcall	80005f9c <rtc_set_value+0x20>
80005f8a:	cf d1       	brne	80005f84 <rtc_set_value+0x8>
  // Set the new val value
  rtc->val = val;
80005f8c:	8f 16       	st.w	r7[0x4],r6
  // Wait until write is done
  while (rtc_is_busy(rtc));
80005f8e:	0e 9c       	mov	r12,r7
80005f90:	f0 1f 00 03 	mcall	80005f9c <rtc_set_value+0x20>
80005f94:	cf d1       	brne	80005f8e <rtc_set_value+0x12>
}
80005f96:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005f9a:	00 00       	add	r0,r0
80005f9c:	80 00       	ld.sh	r0,r0[0x0]
80005f9e:	5f 74       	srpl	r4

80005fa0 <rtc_enable>:
  while (rtc_is_busy(rtc));
}


void rtc_enable(volatile avr32_rtc_t *rtc)
{
80005fa0:	eb cd 40 80 	pushm	r7,lr
80005fa4:	18 97       	mov	r7,r12
  // Wait until the rtc CTRL register is up-to-date
  while (rtc_is_busy(rtc));
80005fa6:	0e 9c       	mov	r12,r7
80005fa8:	f0 1f 00 06 	mcall	80005fc0 <rtc_enable+0x20>
80005fac:	cf d1       	brne	80005fa6 <rtc_enable+0x6>
  // Enable the RTC
  rtc->ctrl |= AVR32_RTC_CTRL_EN_MASK;
80005fae:	6e 08       	ld.w	r8,r7[0x0]
80005fb0:	a1 a8       	sbr	r8,0x0
80005fb2:	8f 08       	st.w	r7[0x0],r8
  // Wait until write is done
  while (rtc_is_busy(rtc));
80005fb4:	0e 9c       	mov	r12,r7
80005fb6:	f0 1f 00 03 	mcall	80005fc0 <rtc_enable+0x20>
80005fba:	cf d1       	brne	80005fb4 <rtc_enable+0x14>
}
80005fbc:	e3 cd 80 80 	ldm	sp++,r7,pc
80005fc0:	80 00       	ld.sh	r0,r0[0x0]
80005fc2:	5f 74       	srpl	r4

80005fc4 <rtc_enable_interrupt>:
}


void rtc_enable_interrupt(volatile avr32_rtc_t *rtc)
{
  rtc->ier = AVR32_RTC_IER_TOPI_MASK;
80005fc4:	30 18       	mov	r8,1
80005fc6:	99 48       	st.w	r12[0x10],r8
}
80005fc8:	5e fc       	retal	r12
80005fca:	d7 03       	nop

80005fcc <rtc_set_top_value>:
  if (global_interrupt_enabled) cpu_irq_enable();
}


void rtc_set_top_value(volatile avr32_rtc_t *rtc, unsigned long top)
{
80005fcc:	eb cd 40 c0 	pushm	r6-r7,lr
80005fd0:	18 97       	mov	r7,r12
80005fd2:	16 96       	mov	r6,r11
  // Wait until we can write into the VAL register
  while (rtc_is_busy(rtc));
80005fd4:	0e 9c       	mov	r12,r7
80005fd6:	f0 1f 00 06 	mcall	80005fec <rtc_set_top_value+0x20>
80005fda:	cf d1       	brne	80005fd4 <rtc_set_top_value+0x8>
  // Set the new val value
  rtc->top = top;
80005fdc:	8f 26       	st.w	r7[0x8],r6
  // Wait until write is done
  while (rtc_is_busy(rtc));
80005fde:	0e 9c       	mov	r12,r7
80005fe0:	f0 1f 00 03 	mcall	80005fec <rtc_set_top_value+0x20>
80005fe4:	cf d1       	brne	80005fde <rtc_set_top_value+0x12>
}
80005fe6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005fea:	00 00       	add	r0,r0
80005fec:	80 00       	ld.sh	r0,r0[0x0]
80005fee:	5f 74       	srpl	r4

80005ff0 <rtc_clear_interrupt>:
}


void rtc_clear_interrupt(volatile avr32_rtc_t *rtc)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
80005ff0:	e1 b8 00 00 	mfsr	r8,0x0

  if (global_interrupt_enabled) cpu_irq_disable();
80005ff4:	e6 18 00 01 	andh	r8,0x1,COH
80005ff8:	c0 71       	brne	80006006 <rtc_clear_interrupt+0x16>
80005ffa:	d3 03       	ssrf	0x10
  rtc->icr = AVR32_RTC_ICR_TOPI_MASK;
80005ffc:	30 18       	mov	r8,1
80005ffe:	99 88       	st.w	r12[0x20],r8
  rtc->isr;
80006000:	78 78       	ld.w	r8,r12[0x1c]
  if (global_interrupt_enabled) cpu_irq_enable();
80006002:	d5 03       	csrf	0x10
80006004:	5e fc       	retal	r12
void rtc_clear_interrupt(volatile avr32_rtc_t *rtc)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  if (global_interrupt_enabled) cpu_irq_disable();
  rtc->icr = AVR32_RTC_ICR_TOPI_MASK;
80006006:	30 18       	mov	r8,1
80006008:	99 88       	st.w	r12[0x20],r8
  rtc->isr;
8000600a:	78 78       	ld.w	r8,r12[0x1c]
8000600c:	5e fc       	retal	r12
8000600e:	d7 03       	nop

80006010 <rtc_init>:
  return (rtc->ctrl & AVR32_RTC_CTRL_BUSY_MASK) != 0;
}


int rtc_init(volatile avr32_rtc_t *rtc, unsigned char osc_type, unsigned char psel)
{
80006010:	eb cd 40 e0 	pushm	r5-r7,lr
80006014:	18 97       	mov	r7,r12
80006016:	16 96       	mov	r6,r11
80006018:	14 95       	mov	r5,r10
  // If exit, it means that the configuration has not been set correctly
  if (osc_type > (1 << AVR32_RTC_CTRL_CLK32_SIZE) - 1 ||
8000601a:	30 18       	mov	r8,1
8000601c:	f0 0b 18 00 	cp.b	r11,r8
80006020:	5f b9       	srhi	r9
80006022:	30 f8       	mov	r8,15
80006024:	f0 0a 18 00 	cp.b	r10,r8
80006028:	5f b8       	srhi	r8
8000602a:	f3 e8 10 08 	or	r8,r9,r8
8000602e:	c0 30       	breq	80006034 <rtc_init+0x24>
80006030:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
      psel > (1 << AVR32_RTC_CTRL_PSEL_SIZE) - 1)
    return 0;

  // If we use the 32-kHz oscillator, we have to enable it first
  if (osc_type == RTC_OSC_32KHZ)
80006034:	30 18       	mov	r8,1
80006036:	f0 0b 18 00 	cp.b	r11,r8
8000603a:	c0 a1       	brne	8000604e <rtc_init+0x3e>
  {
    // Select the 32-kHz oscillator crystal
    pm_enable_osc32_crystal(&AVR32_PM);
8000603c:	fe 7c 0c 00 	mov	r12,-62464
80006040:	f0 1f 00 0f 	mcall	8000607c <rtc_init+0x6c>
    // Enable the 32-kHz clock and wait until the osc32 clock is ready.
    pm_enable_clk32(&AVR32_PM, AVR32_PM_OSCCTRL32_STARTUP_0_RCOSC);
80006044:	30 0b       	mov	r11,0
80006046:	fe 7c 0c 00 	mov	r12,-62464
8000604a:	f0 1f 00 0e 	mcall	80006080 <rtc_init+0x70>
  }

  // Wait until the rtc accepts writes to the CTRL register
  while (rtc_is_busy(rtc));
8000604e:	0e 9c       	mov	r12,r7
80006050:	f0 1f 00 0d 	mcall	80006084 <rtc_init+0x74>
80006054:	cf d1       	brne	8000604e <rtc_init+0x3e>

  // Set the new RTC configuration
  rtc->ctrl = osc_type << AVR32_RTC_CTRL_CLK32_OFFSET |
80006056:	a3 76       	lsl	r6,0x3
80006058:	b1 a6       	sbr	r6,0x10
8000605a:	ed e5 10 85 	or	r5,r6,r5<<0x8
8000605e:	8f 05       	st.w	r7[0x0],r5
              psel << AVR32_RTC_CTRL_PSEL_OFFSET |
              AVR32_RTC_CTRL_CLKEN_MASK;

  // Wait until write is done
  while (rtc_is_busy(rtc));
80006060:	0e 9c       	mov	r12,r7
80006062:	f0 1f 00 09 	mcall	80006084 <rtc_init+0x74>
80006066:	cf d1       	brne	80006060 <rtc_init+0x50>

  // Set the counter value to 0
  rtc_set_value(rtc, 0x00000000);
80006068:	30 0b       	mov	r11,0
8000606a:	0e 9c       	mov	r12,r7
8000606c:	f0 1f 00 07 	mcall	80006088 <rtc_init+0x78>
  // Set the top value to 0xFFFFFFFF
  rtc_set_top_value(rtc, 0xFFFFFFFF);
80006070:	3f fb       	mov	r11,-1
80006072:	0e 9c       	mov	r12,r7
80006074:	f0 1f 00 06 	mcall	8000608c <rtc_init+0x7c>
80006078:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
8000607c:	80 00       	ld.sh	r0,r0[0x0]
8000607e:	5e 5c       	retlt	r12
80006080:	80 00       	ld.sh	r0,r0[0x0]
80006082:	5e 88       	retls	r8
80006084:	80 00       	ld.sh	r0,r0[0x0]
80006086:	5f 74       	srpl	r4
80006088:	80 00       	ld.sh	r0,r0[0x0]
8000608a:	5f 7c       	srpl	r12
8000608c:	80 00       	ld.sh	r0,r0[0x0]
8000608e:	5f cc       	srvs	r12

80006090 <getBaudDiv>:
xSemaphoreHandle xSPIMutex;
#endif

int16_t getBaudDiv(const uint32_t baudrate, uint32_t pb_hz)
{
	uint32_t baudDiv = div_ceil(pb_hz, baudrate);
80006090:	f8 c8 00 01 	sub	r8,r12,1
80006094:	f0 0b 00 0b 	add	r11,r8,r11
80006098:	f6 0c 0d 0a 	divu	r10,r11,r12
8000609c:	14 9c       	mov	r12,r10

	if (baudDiv <= 0 || baudDiv > 255) {
8000609e:	f4 c8 00 01 	sub	r8,r10,1
800060a2:	e0 48 00 fe 	cp.w	r8,254
800060a6:	e0 88 00 03 	brls	800060ac <getBaudDiv+0x1c>
800060aa:	5e fe       	retal	-1
		return -1;
	}

	return baudDiv;
800060ac:	5c 8c       	casts.h	r12
}
800060ae:	5e fc       	retal	r12

800060b0 <spi_initMaster>:
spi_status_t spi_initMaster(volatile avr32_spi_t *spi,
		const spi_options_t *options)
{
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (options->modfdis > 1) {
800060b0:	f7 39 00 0d 	ld.ub	r9,r11[13]
800060b4:	30 18       	mov	r8,1
800060b6:	f0 09 18 00 	cp.b	r9,r8
800060ba:	e0 88 00 04 	brls	800060c2 <spi_initMaster+0x12>
800060be:	30 2c       	mov	r12,2
800060c0:	5e fc       	retal	r12
		return SPI_ERROR_ARGUMENT;
	}

	/* Reset. */
	spi->cr = AVR32_SPI_CR_SWRST_MASK;
800060c2:	e0 68 00 80 	mov	r8,128
800060c6:	99 08       	st.w	r12[0x0],r8

	/* Master Mode. */
	u_avr32_spi_mr.mr = spi->mr;
800060c8:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.mstr = 1;
800060ca:	30 19       	mov	r9,1
800060cc:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_mr.MR.modfdis = options->modfdis;
800060d0:	f7 39 00 0d 	ld.ub	r9,r11[13]
800060d4:	f1 d9 d0 81 	bfins	r8,r9,0x4,0x1
	u_avr32_spi_mr.MR.llb = 0;
800060d8:	30 09       	mov	r9,0
800060da:	f1 d9 d0 e1 	bfins	r8,r9,0x7,0x1
	u_avr32_spi_mr.MR.pcs = (1 << AVR32_SPI_MR_PCS_SIZE) - 1;
800060de:	30 fa       	mov	r10,15
800060e0:	f1 da d2 04 	bfins	r8,r10,0x10,0x4
	spi->mr = u_avr32_spi_mr.mr;
800060e4:	99 18       	st.w	r12[0x4],r8
800060e6:	5e f9       	retal	r9

800060e8 <spi_selectionMode>:

spi_status_t spi_selectionMode(volatile avr32_spi_t *spi,
		uint8_t variable_ps,
		uint8_t pcs_decode,
		uint8_t delay)
{
800060e8:	d4 01       	pushm	lr
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (variable_ps > 1 ||
800060ea:	30 18       	mov	r8,1
800060ec:	f0 0b 18 00 	cp.b	r11,r8
800060f0:	5f be       	srhi	lr
800060f2:	f0 0a 18 00 	cp.b	r10,r8
800060f6:	5f b8       	srhi	r8
800060f8:	fd e8 10 08 	or	r8,lr,r8
800060fc:	c0 30       	breq	80006102 <spi_selectionMode+0x1a>
800060fe:	30 2c       	mov	r12,2
80006100:	d8 02       	popm	pc
			pcs_decode > 1) {
		return SPI_ERROR_ARGUMENT;
	}

	u_avr32_spi_mr.mr = spi->mr;
80006102:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.ps = variable_ps;
80006104:	f1 db d0 21 	bfins	r8,r11,0x1,0x1
	u_avr32_spi_mr.MR.pcsdec = pcs_decode;
80006108:	f1 da d0 41 	bfins	r8,r10,0x2,0x1
	u_avr32_spi_mr.MR.dlybcs = delay;
8000610c:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8
	spi->mr = u_avr32_spi_mr.mr;
80006110:	99 18       	st.w	r12[0x4],r8
80006112:	d8 0a       	popm	pc,r12=0

80006114 <spi_enable>:
	return SPI_OK;
}

void spi_enable(volatile avr32_spi_t *spi)
{
	spi->cr = AVR32_SPI_CR_SPIEN_MASK;
80006114:	30 18       	mov	r8,1
80006116:	99 08       	st.w	r12[0x0],r8
}
80006118:	5e fc       	retal	r12

8000611a <spi_write>:
{
	return ((spi->sr & AVR32_SPI_SR_TDRE_MASK) != 0);
}

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
8000611a:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
8000611e:	c0 58       	rjmp	80006128 <spi_write+0xe>
		if (!timeout--) {
80006120:	58 08       	cp.w	r8,0
80006122:	c0 21       	brne	80006126 <spi_write+0xc>
80006124:	5e ff       	retal	1
80006126:	20 18       	sub	r8,1

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
80006128:	78 49       	ld.w	r9,r12[0x10]
8000612a:	e2 19 00 02 	andl	r9,0x2,COH
8000612e:	cf 90       	breq	80006120 <spi_write+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	spi->tdr = data << AVR32_SPI_TDR_TD_OFFSET;
80006130:	5c 7b       	castu.h	r11
80006132:	99 3b       	st.w	r12[0xc],r11
80006134:	5e fd       	retal	0

80006136 <spi_read>:
{
	return ((spi->sr & AVR32_SPI_SR_RDRF_MASK) != 0);
}

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
80006136:	e0 68 3a 98 	mov	r8,15000
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
8000613a:	c0 58       	rjmp	80006144 <spi_read+0xe>
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) !=
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) {
		if (!timeout--) {
8000613c:	58 08       	cp.w	r8,0
8000613e:	c0 21       	brne	80006142 <spi_read+0xc>
80006140:	5e ff       	retal	1
80006142:	20 18       	sub	r8,1

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
80006144:	78 49       	ld.w	r9,r12[0x10]
80006146:	e2 19 02 01 	andl	r9,0x201,COH
8000614a:	e0 49 02 01 	cp.w	r9,513
8000614e:	cf 71       	brne	8000613c <spi_read+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	*data = spi->rdr >> AVR32_SPI_RDR_RD_OFFSET;
80006150:	78 28       	ld.w	r8,r12[0x8]
80006152:	b6 08       	st.h	r11[0x0],r8
80006154:	5e fd       	retal	0
80006156:	d7 03       	nop

80006158 <spi_setupChipReg>:
}

spi_status_t spi_setupChipReg(volatile avr32_spi_t *spi,
		const spi_options_t *options,
		uint32_t pb_hz)
{
80006158:	eb cd 40 f8 	pushm	r3-r7,lr
8000615c:	18 95       	mov	r5,r12
8000615e:	16 97       	mov	r7,r11
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
80006160:	f7 36 00 0c 	ld.ub	r6,r11[12]
80006164:	30 38       	mov	r8,3
80006166:	f0 06 18 00 	cp.b	r6,r8
8000616a:	e0 8b 00 5e 	brhi	80006226 <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
8000616e:	f7 34 00 0b 	ld.ub	r4,r11[11]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
80006172:	30 18       	mov	r8,1
80006174:	f0 04 18 00 	cp.b	r4,r8
80006178:	e0 8b 00 57 	brhi	80006226 <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
8000617c:	f7 33 00 08 	ld.ub	r3,r11[8]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
80006180:	30 78       	mov	r8,7
80006182:	f0 03 18 00 	cp.b	r3,r8
80006186:	e0 88 00 50 	brls	80006226 <spi_setupChipReg+0xce>
8000618a:	31 08       	mov	r8,16
8000618c:	f0 03 18 00 	cp.b	r3,r8
80006190:	e0 8b 00 4b 	brhi	80006226 <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
		return SPI_ERROR_ARGUMENT;
	}

	int baudDiv = getBaudDiv(options->baudrate, pb_hz);
80006194:	14 9b       	mov	r11,r10
80006196:	6e 1c       	ld.w	r12,r7[0x4]
80006198:	f0 1f 00 26 	mcall	80006230 <spi_setupChipReg+0xd8>

	if (baudDiv < 0) {
8000619c:	c4 55       	brlt	80006226 <spi_setupChipReg+0xce>
		return SPI_ERROR_ARGUMENT;
	}

	/* Will use CSR0 offsets; these are the same for CSR0 to CSR3. */
	u_avr32_spi_csr.csr = 0;
8000619e:	30 08       	mov	r8,0
	u_avr32_spi_csr.CSR.cpol   = options->spi_mode >> 1;
800061a0:	ec 09 16 01 	lsr	r9,r6,0x1
800061a4:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_csr.CSR.ncpha  = (options->spi_mode & 0x1) ^ 0x1;
800061a8:	ec 16 00 01 	eorl	r6,0x1
800061ac:	f1 d6 d0 21 	bfins	r8,r6,0x1,0x1
	u_avr32_spi_csr.CSR.csaat  = options->stay_act;
800061b0:	f1 d4 d0 61 	bfins	r8,r4,0x3,0x1
	u_avr32_spi_csr.CSR.bits   = options->bits - 8;
800061b4:	20 83       	sub	r3,8
800061b6:	f1 d3 d0 84 	bfins	r8,r3,0x4,0x4
	u_avr32_spi_csr.CSR.scbr   = baudDiv;
800061ba:	f1 dc d1 08 	bfins	r8,r12,0x8,0x8
	u_avr32_spi_csr.CSR.dlybs  = options->spck_delay;
800061be:	ef 39 00 09 	ld.ub	r9,r7[9]
800061c2:	f1 d9 d2 08 	bfins	r8,r9,0x10,0x8
	u_avr32_spi_csr.CSR.dlybct = options->trans_delay;
800061c6:	ef 39 00 0a 	ld.ub	r9,r7[10]
800061ca:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8

	switch (options->reg) {
800061ce:	0f 89       	ld.ub	r9,r7[0x0]
800061d0:	30 1a       	mov	r10,1
800061d2:	f4 09 18 00 	cp.b	r9,r10
800061d6:	c0 d0       	breq	800061f0 <spi_setupChipReg+0x98>
800061d8:	c0 a3       	brcs	800061ec <spi_setupChipReg+0x94>
800061da:	30 2a       	mov	r10,2
800061dc:	f4 09 18 00 	cp.b	r9,r10
800061e0:	c0 a0       	breq	800061f4 <spi_setupChipReg+0x9c>
800061e2:	30 3a       	mov	r10,3
800061e4:	f4 09 18 00 	cp.b	r9,r10
800061e8:	c1 f1       	brne	80006226 <spi_setupChipReg+0xce>
800061ea:	c0 78       	rjmp	800061f8 <spi_setupChipReg+0xa0>
	case 0:
		spi->csr0 = u_avr32_spi_csr.csr;
800061ec:	8b c8       	st.w	r5[0x30],r8
		break;
800061ee:	c0 68       	rjmp	800061fa <spi_setupChipReg+0xa2>

	case 1:
		spi->csr1 = u_avr32_spi_csr.csr;
800061f0:	8b d8       	st.w	r5[0x34],r8
		break;
800061f2:	c0 48       	rjmp	800061fa <spi_setupChipReg+0xa2>

	case 2:
		spi->csr2 = u_avr32_spi_csr.csr;
800061f4:	8b e8       	st.w	r5[0x38],r8
		break;
800061f6:	c0 28       	rjmp	800061fa <spi_setupChipReg+0xa2>

	case 3:
		spi->csr3 = u_avr32_spi_csr.csr;
800061f8:	8b f8       	st.w	r5[0x3c],r8
	default:
		return SPI_ERROR_ARGUMENT;
	}

#ifdef FREERTOS_USED
	if (!xSPIMutex) {
800061fa:	48 f8       	lddpc	r8,80006234 <spi_setupChipReg+0xdc>
800061fc:	70 08       	ld.w	r8,r8[0x0]
800061fe:	58 08       	cp.w	r8,0
80006200:	c1 61       	brne	8000622c <spi_setupChipReg+0xd4>
		/* Create the SPI mutex. */
		vSemaphoreCreateBinary(xSPIMutex);
80006202:	30 0b       	mov	r11,0
80006204:	30 1c       	mov	r12,1
80006206:	f0 1f 00 0d 	mcall	80006238 <spi_setupChipReg+0xe0>
8000620a:	48 b8       	lddpc	r8,80006234 <spi_setupChipReg+0xdc>
8000620c:	91 0c       	st.w	r8[0x0],r12
8000620e:	58 0c       	cp.w	r12,0
80006210:	c0 a0       	breq	80006224 <spi_setupChipReg+0xcc>
80006212:	30 09       	mov	r9,0
80006214:	12 9a       	mov	r10,r9
80006216:	12 9b       	mov	r11,r9
80006218:	f0 1f 00 09 	mcall	8000623c <spi_setupChipReg+0xe4>
		if (!xSPIMutex) {
8000621c:	48 68       	lddpc	r8,80006234 <spi_setupChipReg+0xdc>
8000621e:	70 08       	ld.w	r8,r8[0x0]
80006220:	58 08       	cp.w	r8,0
80006222:	c0 51       	brne	8000622c <spi_setupChipReg+0xd4>
80006224:	c0 08       	rjmp	80006224 <spi_setupChipReg+0xcc>
80006226:	30 2c       	mov	r12,2
80006228:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
8000622c:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
80006230:	80 00       	ld.sh	r0,r0[0x0]
80006232:	60 90       	ld.w	r0,r0[0x24]
80006234:	00 00       	add	r0,r0
80006236:	54 28       	stdsp	sp[0x108],r8
80006238:	80 00       	ld.sh	r0,r0[0x0]
8000623a:	6d 7c       	ld.w	r12,r6[0x5c]
8000623c:	80 00       	ld.sh	r0,r0[0x0]
8000623e:	6c 24       	ld.w	r4,r6[0x8]

80006240 <spi_unselectChip>:

	return SPI_OK;
}

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
80006240:	d4 01       	pushm	lr
80006242:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
80006246:	c0 58       	rjmp	80006250 <spi_unselectChip+0x10>
		if (!timeout--) {
80006248:	58 08       	cp.w	r8,0
8000624a:	c0 21       	brne	8000624e <spi_unselectChip+0xe>
8000624c:	da 0a       	popm	pc,r12=1
8000624e:	20 18       	sub	r8,1

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
80006250:	78 49       	ld.w	r9,r12[0x10]
80006252:	e2 19 02 00 	andl	r9,0x200,COH
80006256:	cf 90       	breq	80006248 <spi_unselectChip+0x8>
			return SPI_ERROR_TIMEOUT;
		}
	}

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
80006258:	78 18       	ld.w	r8,r12[0x4]
8000625a:	ea 18 00 0f 	orh	r8,0xf
8000625e:	99 18       	st.w	r12[0x4],r8

	/* Last transfer, so de-assert the current NPCS if CSAAT is set. */
	spi->cr = AVR32_SPI_CR_LASTXFER_MASK;
80006260:	fc 18 01 00 	movh	r8,0x100
80006264:	99 08       	st.w	r12[0x0],r8

#ifdef FREERTOS_USED
	xSemaphoreGive(xSPIMutex);
80006266:	30 09       	mov	r9,0
80006268:	12 9a       	mov	r10,r9
8000626a:	12 9b       	mov	r11,r9
8000626c:	48 38       	lddpc	r8,80006278 <spi_unselectChip+0x38>
8000626e:	70 0c       	ld.w	r12,r8[0x0]
80006270:	f0 1f 00 03 	mcall	8000627c <spi_unselectChip+0x3c>
80006274:	d8 0a       	popm	pc,r12=0
80006276:	00 00       	add	r0,r0
80006278:	00 00       	add	r0,r0
8000627a:	54 28       	stdsp	sp[0x108],r8
8000627c:	80 00       	ld.sh	r0,r0[0x0]
8000627e:	6c 24       	ld.w	r4,r6[0x8]

80006280 <spi_selectChip>:

	return SPI_OK;
}

spi_status_t spi_selectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
80006280:	eb cd 40 f8 	pushm	r3-r7,lr
80006284:	18 94       	mov	r4,r12
80006286:	16 93       	mov	r3,r11
#ifdef FREERTOS_USED
	while (pdFALSE == xSemaphoreTake(xSPIMutex, 20)) {
80006288:	49 a6       	lddpc	r6,800062f0 <spi_selectChip+0x70>
8000628a:	30 07       	mov	r7,0
8000628c:	31 45       	mov	r5,20
8000628e:	0e 99       	mov	r9,r7
80006290:	0a 9a       	mov	r10,r5
80006292:	0e 9b       	mov	r11,r7
80006294:	6c 0c       	ld.w	r12,r6[0x0]
80006296:	f0 1f 00 18 	mcall	800062f4 <spi_selectChip+0x74>
8000629a:	cf a0       	breq	8000628e <spi_selectChip+0xe>
	}
#endif

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
8000629c:	68 18       	ld.w	r8,r4[0x4]
8000629e:	ea 18 00 0f 	orh	r8,0xf
800062a2:	89 18       	st.w	r4[0x4],r8

	if (spi->mr & AVR32_SPI_MR_PCSDEC_MASK) {
800062a4:	68 18       	ld.w	r8,r4[0x4]
800062a6:	e2 18 00 04 	andl	r8,0x4,COH
800062aa:	c1 10       	breq	800062cc <spi_selectChip+0x4c>
		/* The signal is decoded; allow up to 15 chips. */
		if (chip > 14) {
800062ac:	30 e8       	mov	r8,14
800062ae:	f0 03 18 00 	cp.b	r3,r8
800062b2:	e0 8b 00 1c 	brhi	800062ea <spi_selectChip+0x6a>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~AVR32_SPI_MR_PCS_MASK |
800062b6:	68 19       	ld.w	r9,r4[0x4]
800062b8:	e6 08 15 10 	lsl	r8,r3,0x10
800062bc:	ea 18 ff f0 	orh	r8,0xfff0
800062c0:	e8 18 ff ff 	orl	r8,0xffff
800062c4:	12 68       	and	r8,r9
800062c6:	89 18       	st.w	r4[0x4],r8
800062c8:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
				(chip << AVR32_SPI_MR_PCS_OFFSET);
	} else {
		if (chip > 3) {
800062cc:	30 38       	mov	r8,3
800062ce:	f0 03 18 00 	cp.b	r3,r8
800062d2:	e0 8b 00 0c 	brhi	800062ea <spi_selectChip+0x6a>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~(1 << (AVR32_SPI_MR_PCS_OFFSET + chip));
800062d6:	68 19       	ld.w	r9,r4[0x4]
800062d8:	2f 03       	sub	r3,-16
800062da:	30 18       	mov	r8,1
800062dc:	f0 03 09 48 	lsl	r8,r8,r3
800062e0:	5c d8       	com	r8
800062e2:	12 68       	and	r8,r9
800062e4:	89 18       	st.w	r4[0x4],r8
800062e6:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
800062ea:	30 2c       	mov	r12,2
	}

	return SPI_OK;
}
800062ec:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
800062f0:	00 00       	add	r0,r0
800062f2:	54 28       	stdsp	sp[0x108],r8
800062f4:	80 00       	ld.sh	r0,r0[0x0]
800062f6:	6a 18       	ld.w	r8,r5[0x4]

800062f8 <usart_set_async_baudrate>:
 *
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
800062f8:	d4 01       	pushm	lr
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
800062fa:	f6 08 15 04 	lsl	r8,r11,0x4
800062fe:	14 38       	cp.w	r8,r10
80006300:	f9 b8 08 10 	movls	r8,16
80006304:	f9 b8 0b 08 	movhi	r8,8
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
80006308:	f0 0b 02 4b 	mul	r11,r8,r11
8000630c:	f6 09 16 01 	lsr	r9,r11,0x1
80006310:	f2 0a 00 3a 	add	r10,r9,r10<<0x3
80006314:	f4 0b 0d 0a 	divu	r10,r10,r11
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
80006318:	f4 09 16 03 	lsr	r9,r10,0x3
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
8000631c:	f2 cb 00 01 	sub	r11,r9,1
80006320:	e0 4b ff fe 	cp.w	r11,65534
80006324:	e0 88 00 03 	brls	8000632a <usart_set_async_baudrate+0x32>
80006328:	da 0a       	popm	pc,r12=1
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
8000632a:	78 1b       	ld.w	r11,r12[0x4]
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
8000632c:	e8 6e 00 00 	mov	lr,524288
80006330:	59 08       	cp.w	r8,16
80006332:	fc 08 17 10 	movne	r8,lr
80006336:	f9 b8 00 00 	moveq	r8,0
8000633a:	e4 1b ff f7 	andh	r11,0xfff7
8000633e:	e0 1b fe cf 	andl	r11,0xfecf
80006342:	16 48       	or	r8,r11
80006344:	99 18       	st.w	r12[0x4],r8
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
80006346:	f5 da c0 03 	bfextu	r10,r10,0x0,0x3
8000634a:	f3 ea 11 09 	or	r9,r9,r10<<0x10
8000634e:	99 89       	st.w	r12[0x20],r9
80006350:	d8 0a       	popm	pc,r12=0

80006352 <usart_write_char>:
 *
 * \return \c 1 if the USART Transmit Holding Register is free, otherwise \c 0.
 */
__always_inline static int usart_tx_ready(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_TXRDY_MASK) != 0;
80006352:	78 58       	ld.w	r8,r12[0x14]
}


int usart_write_char(volatile avr32_usart_t *usart, int c)
{
  if (usart_tx_ready(usart))
80006354:	e2 18 00 02 	andl	r8,0x2,COH
80006358:	c0 31       	brne	8000635e <usart_write_char+0xc>
8000635a:	30 2c       	mov	r12,2
8000635c:	5e fc       	retal	r12
  {
    usart->thr = (c << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
8000635e:	f7 db c0 09 	bfextu	r11,r11,0x0,0x9
80006362:	99 7b       	st.w	r12[0x1c],r11
80006364:	5e fd       	retal	0
80006366:	d7 03       	nop

80006368 <usart_putchar>:
    return USART_TX_BUSY;
}


int usart_putchar(volatile avr32_usart_t *usart, int c)
{
80006368:	eb cd 40 e0 	pushm	r5-r7,lr
8000636c:	18 96       	mov	r6,r12
8000636e:	16 95       	mov	r5,r11
80006370:	e0 67 27 0f 	mov	r7,9999
80006374:	c0 68       	rjmp	80006380 <usart_putchar+0x18>
  int timeout = USART_DEFAULT_TIMEOUT;

  do
  {
    if (!timeout--) return USART_FAILURE;
80006376:	58 07       	cp.w	r7,0
80006378:	c0 31       	brne	8000637e <usart_putchar+0x16>
8000637a:	e3 cf c0 e0 	ldm	sp++,r5-r7,pc,r12=-1
8000637e:	20 17       	sub	r7,1
  } while (usart_write_char(usart, c) != USART_SUCCESS);
80006380:	0a 9b       	mov	r11,r5
80006382:	0c 9c       	mov	r12,r6
80006384:	f0 1f 00 03 	mcall	80006390 <usart_putchar+0x28>
80006388:	cf 71       	brne	80006376 <usart_putchar+0xe>

  return USART_SUCCESS;
}
8000638a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000638e:	00 00       	add	r0,r0
80006390:	80 00       	ld.sh	r0,r0[0x0]
80006392:	63 52       	ld.w	r2,r1[0x54]

80006394 <usart_read_char>:

int usart_read_char(volatile avr32_usart_t *usart, int *c)
{
  // Check for errors: frame, parity and overrun. In RS485 mode, a parity error
  // would mean that an address char has been received.
  if (usart->csr & (AVR32_USART_CSR_OVRE_MASK |
80006394:	78 58       	ld.w	r8,r12[0x14]
80006396:	e2 18 00 e0 	andl	r8,0xe0,COH
8000639a:	c0 30       	breq	800063a0 <usart_read_char+0xc>
8000639c:	30 4c       	mov	r12,4
8000639e:	5e fc       	retal	r12
 *
 * \return \c 1 if the USART Receive Holding Register is full, otherwise \c 0.
 */
__always_inline static int usart_test_hit(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_RXRDY_MASK) != 0;
800063a0:	78 58       	ld.w	r8,r12[0x14]
                    AVR32_USART_CSR_FRAME_MASK |
                    AVR32_USART_CSR_PARE_MASK))
    return USART_RX_ERROR;

  // No error; if we really did receive a char, read it and return SUCCESS.
  if (usart_test_hit(usart))
800063a2:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800063a6:	c0 31       	brne	800063ac <usart_read_char+0x18>
800063a8:	30 3c       	mov	r12,3
800063aa:	5e fc       	retal	r12
  {
    *c = (usart->rhr & AVR32_USART_RHR_RXCHR_MASK) >> AVR32_USART_RHR_RXCHR_OFFSET;
800063ac:	78 68       	ld.w	r8,r12[0x18]
800063ae:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
800063b2:	97 08       	st.w	r11[0x0],r8
800063b4:	5e fd       	retal	0
800063b6:	d7 03       	nop

800063b8 <usart_getchar>:
    return USART_RX_EMPTY;
}


int usart_getchar(volatile avr32_usart_t *usart)
{
800063b8:	eb cd 40 c0 	pushm	r6-r7,lr
800063bc:	20 1d       	sub	sp,4
800063be:	18 96       	mov	r6,r12
  int c, ret;

  while ((ret = usart_read_char(usart, &c)) == USART_RX_EMPTY);
800063c0:	1a 97       	mov	r7,sp
800063c2:	1a 9b       	mov	r11,sp
800063c4:	0c 9c       	mov	r12,r6
800063c6:	f0 1f 00 07 	mcall	800063e0 <usart_getchar+0x28>
800063ca:	58 3c       	cp.w	r12,3
800063cc:	cf b0       	breq	800063c2 <usart_getchar+0xa>

  if (ret == USART_RX_ERROR)
800063ce:	58 4c       	cp.w	r12,4
800063d0:	f9 bc 00 ff 	moveq	r12,-1
    return USART_FAILURE;

  return c;
800063d4:	fb fc 10 00 	ld.wne	r12,sp[0x0]
}
800063d8:	2f fd       	sub	sp,-4
800063da:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800063de:	00 00       	add	r0,r0
800063e0:	80 00       	ld.sh	r0,r0[0x0]
800063e2:	63 94       	ld.w	r4,r1[0x64]

800063e4 <usart_write_line>:


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
800063e4:	eb cd 40 c0 	pushm	r6-r7,lr
800063e8:	18 96       	mov	r6,r12
800063ea:	16 97       	mov	r7,r11
  while (*string != '\0')
800063ec:	17 8b       	ld.ub	r11,r11[0x0]
800063ee:	58 0b       	cp.w	r11,0
800063f0:	c0 80       	breq	80006400 <usart_write_line+0x1c>
    usart_putchar(usart, *string++);
800063f2:	2f f7       	sub	r7,-1
800063f4:	0c 9c       	mov	r12,r6
800063f6:	f0 1f 00 04 	mcall	80006404 <usart_write_line+0x20>
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
800063fa:	0f 8b       	ld.ub	r11,r7[0x0]
800063fc:	58 0b       	cp.w	r11,0
800063fe:	cf a1       	brne	800063f2 <usart_write_line+0xe>
80006400:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006404:	80 00       	ld.sh	r0,r0[0x0]
80006406:	63 68       	ld.w	r8,r1[0x58]

80006408 <usart_reset>:
//! @{


void usart_reset(volatile avr32_usart_t *usart)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
80006408:	e1 b8 00 00 	mfsr	r8,0x0

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
8000640c:	e6 18 00 01 	andh	r8,0x1,COH
80006410:	c0 71       	brne	8000641e <usart_reset+0x16>
80006412:	d3 03       	ssrf	0x10
  usart->idr = 0xFFFFFFFF;
80006414:	3f f8       	mov	r8,-1
80006416:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80006418:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();
8000641a:	d5 03       	csrf	0x10
8000641c:	c0 48       	rjmp	80006424 <usart_reset+0x1c>
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
  usart->idr = 0xFFFFFFFF;
8000641e:	3f f8       	mov	r8,-1
80006420:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80006422:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();

  // Reset mode and other registers that could cause unpredictable behavior after reset.
  usart->mr = 0;
80006424:	30 08       	mov	r8,0
80006426:	99 18       	st.w	r12[0x4],r8
  usart->rtor = 0;
80006428:	99 98       	st.w	r12[0x24],r8
  usart->ttgr = 0;
8000642a:	99 a8       	st.w	r12[0x28],r8

  // Shutdown TX and RX (will be re-enabled when setup has successfully completed),
  // reset status bits and turn off DTR and RTS.
  usart->cr = AVR32_USART_CR_RSTRX_MASK   |
8000642c:	ea 68 61 0c 	mov	r8,680204
80006430:	99 08       	st.w	r12[0x0],r8
#ifndef AVR32_USART_440_H_INCLUDED
// Note: Modem Signal Management DTR-DSR-DCD-RI are not included in USART rev.440.
              AVR32_USART_CR_DTRDIS_MASK  |
#endif
              AVR32_USART_CR_RTSDIS_MASK;
}
80006432:	5e fc       	retal	r12

80006434 <usart_init_rs232>:


int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
{
80006434:	eb cd 40 e0 	pushm	r5-r7,lr
80006438:	18 96       	mov	r6,r12
8000643a:	16 97       	mov	r7,r11
8000643c:	14 95       	mov	r5,r10
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);
8000643e:	f0 1f 00 2f 	mcall	800064f8 <usart_init_rs232+0xc4>

  // Check input values.
  if (!opt || // Null pointer.
80006442:	58 07       	cp.w	r7,0
80006444:	c5 80       	breq	800064f4 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
80006446:	0f c8       	ld.ub	r8,r7[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80006448:	30 49       	mov	r9,4
8000644a:	f2 08 18 00 	cp.b	r8,r9
8000644e:	e0 88 00 53 	brls	800064f4 <usart_init_rs232+0xc0>
80006452:	30 99       	mov	r9,9
80006454:	f2 08 18 00 	cp.b	r8,r9
80006458:	e0 8b 00 4e 	brhi	800064f4 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
8000645c:	0f d9       	ld.ub	r9,r7[0x5]
8000645e:	30 78       	mov	r8,7
80006460:	f0 09 18 00 	cp.b	r9,r8
80006464:	e0 8b 00 48 	brhi	800064f4 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
80006468:	8e 39       	ld.sh	r9,r7[0x6]
8000646a:	e0 68 01 01 	mov	r8,257
8000646e:	f0 09 19 00 	cp.h	r9,r8
80006472:	e0 8b 00 41 	brhi	800064f4 <usart_init_rs232+0xc0>
      opt->channelmode > 3 ||
80006476:	ef 39 00 08 	ld.ub	r9,r7[8]
8000647a:	30 38       	mov	r8,3
8000647c:	f0 09 18 00 	cp.b	r9,r8
80006480:	e0 8b 00 3a 	brhi	800064f4 <usart_init_rs232+0xc0>
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
80006484:	0a 9a       	mov	r10,r5
80006486:	6e 0b       	ld.w	r11,r7[0x0]
80006488:	0c 9c       	mov	r12,r6
8000648a:	f0 1f 00 1d 	mcall	800064fc <usart_init_rs232+0xc8>
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
8000648e:	58 1c       	cp.w	r12,1
80006490:	c3 20       	breq	800064f4 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
    return USART_INVALID_INPUT;

  if (opt->charlength == 9)
80006492:	0f c8       	ld.ub	r8,r7[0x4]
80006494:	30 99       	mov	r9,9
80006496:	f2 08 18 00 	cp.b	r8,r9
8000649a:	c0 51       	brne	800064a4 <usart_init_rs232+0x70>
  {
    // Character length set to 9 bits. MODE9 dominates CHRL.
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
8000649c:	6c 18       	ld.w	r8,r6[0x4]
8000649e:	b1 b8       	sbr	r8,0x11
800064a0:	8d 18       	st.w	r6[0x4],r8
800064a2:	c0 68       	rjmp	800064ae <usart_init_rs232+0x7a>
  }
  else
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
800064a4:	6c 19       	ld.w	r9,r6[0x4]
800064a6:	20 58       	sub	r8,5
800064a8:	f3 e8 10 68 	or	r8,r9,r8<<0x6
800064ac:	8d 18       	st.w	r6[0x4],r8
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
800064ae:	6c 19       	ld.w	r9,r6[0x4]
800064b0:	ef 3a 00 08 	ld.ub	r10,r7[8]
800064b4:	0f d8       	ld.ub	r8,r7[0x5]
800064b6:	a9 78       	lsl	r8,0x9
800064b8:	f1 ea 10 e8 	or	r8,r8,r10<<0xe
800064bc:	12 48       	or	r8,r9
800064be:	8d 18       	st.w	r6[0x4],r8
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;

  if (opt->stopbits > USART_2_STOPBITS)
800064c0:	8e 38       	ld.sh	r8,r7[0x6]
800064c2:	30 29       	mov	r9,2
800064c4:	f2 08 19 00 	cp.h	r8,r9
800064c8:	e0 88 00 09 	brls	800064da <usart_init_rs232+0xa6>
  {
    // Set two stop bits
    usart->mr |= AVR32_USART_MR_NBSTOP_2 << AVR32_USART_MR_NBSTOP_OFFSET;
800064cc:	6c 18       	ld.w	r8,r6[0x4]
800064ce:	ad b8       	sbr	r8,0xd
800064d0:	8d 18       	st.w	r6[0x4],r8
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
800064d2:	8e b8       	ld.uh	r8,r7[0x6]
800064d4:	20 28       	sub	r8,2
800064d6:	8d a8       	st.w	r6[0x28],r8
800064d8:	c0 68       	rjmp	800064e4 <usart_init_rs232+0xb0>
  }
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;
800064da:	6c 19       	ld.w	r9,r6[0x4]
800064dc:	5c 78       	castu.h	r8
800064de:	f3 e8 10 c8 	or	r8,r9,r8<<0xc
800064e2:	8d 18       	st.w	r6[0x4],r8

  // Set normal mode.
  usart->mr = (usart->mr & ~AVR32_USART_MR_MODE_MASK) |
800064e4:	6c 18       	ld.w	r8,r6[0x4]
800064e6:	e0 18 ff f0 	andl	r8,0xfff0
800064ea:	8d 18       	st.w	r6[0x4],r8
              AVR32_USART_MR_MODE_NORMAL << AVR32_USART_MR_MODE_OFFSET;

  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
800064ec:	35 08       	mov	r8,80
800064ee:	8d 08       	st.w	r6[0x0],r8
800064f0:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
800064f4:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
800064f8:	80 00       	ld.sh	r0,r0[0x0]
800064fa:	64 08       	ld.w	r8,r2[0x0]
800064fc:	80 00       	ld.sh	r0,r0[0x0]
800064fe:	62 f8       	ld.w	r8,r1[0x3c]

80006500 <_stext>:

  .global _stext
  .type _stext, @function
_stext:
  // Set initial stack pointer.
  lda.w   sp, _estack
80006500:	e0 7d 80 00 	mov	sp,98304

  // Set up EVBA so interrupts can be enabled.
  lda.w   r0, _evba
  mtsr    AVR32_EVBA, r0
80006504:	fe c0 8f 04 	sub	r0,pc,-28924

  // Enable the exception processing.
  csrf    AVR32_SR_EM_OFFSET
80006508:	e3 b0 00 01 	mtsr	0x4,r0

  // Load initialized data having a global lifetime from the data LMA.
  lda.w   r0, _data
  lda.w   r1, _edata
8000650c:	d5 53       	csrf	0x15
  cp      r0, r1
8000650e:	30 40       	mov	r0,4
  brhs    idata_load_loop_end
80006510:	e0 61 0a 50 	mov	r1,2640
  lda.w   r2, _data_lma
idata_load_loop:
  ld.d    r4, r2++
80006514:	02 30       	cp.w	r0,r1
  st.d    r0++, r4
80006516:	c0 62       	brcc	80006522 <idata_load_loop_end>
  cp      r0, r1
80006518:	48 92       	lddpc	r2,8000653c <udata_clear_loop_end+0x4>

8000651a <idata_load_loop>:
  brlo    idata_load_loop
8000651a:	a5 05       	ld.d	r4,r2++
idata_load_loop_end:

  // Clear uninitialized data having a global lifetime in the blank static storage section.
  lda.w   r0, __bss_start
8000651c:	a1 24       	st.d	r0++,r4
  lda.w   r1, _end
8000651e:	02 30       	cp.w	r0,r1
  cp      r0, r1
80006520:	cf d3       	brcs	8000651a <idata_load_loop>

80006522 <idata_load_loop_end>:
  brhs    udata_clear_loop_end
80006522:	e0 60 0a 50 	mov	r0,2640
  mov     r2, 0
  mov     r3, 0
80006526:	e0 61 54 38 	mov	r1,21560
udata_clear_loop:
  st.d    r0++, r2
  cp      r0, r1
8000652a:	02 30       	cp.w	r0,r1
  brlo    udata_clear_loop
8000652c:	c0 62       	brcc	80006538 <udata_clear_loop_end>
  // Safety: Set the default "return" @ to the exit routine address.
  lda.w   lr, exit
#endif

  // Start the show.
  lda.w   pc, main
8000652e:	30 02       	mov	r2,0
80006530:	30 03       	mov	r3,0

80006532 <udata_clear_loop>:
80006532:	a1 22       	st.d	r0++,r2
80006534:	02 30       	cp.w	r0,r1
80006536:	cf e3       	brcs	80006532 <udata_clear_loop>

80006538 <udata_clear_loop_end>:
80006538:	fe cf e9 28 	sub	pc,pc,-5848
8000653c:	80 00       	ld.sh	r0,r0[0x0]
8000653e:	ec 20 f8 c8 	sub	r0,850120

80006540 <vListInitialise>:
void vListInitialise( xList *pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
80006540:	f8 c8 ff f8 	sub	r8,r12,-8
80006544:	99 18       	st.w	r12[0x4],r8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
80006546:	3f f9       	mov	r9,-1
80006548:	99 29       	st.w	r12[0x8],r9

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
8000654a:	99 38       	st.w	r12[0xc],r8
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
8000654c:	99 48       	st.w	r12[0x10],r8

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
8000654e:	30 08       	mov	r8,0
80006550:	99 08       	st.w	r12[0x0],r8
}
80006552:	5e fc       	retal	r12

80006554 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
80006554:	30 08       	mov	r8,0
80006556:	99 48       	st.w	r12[0x10],r8
}
80006558:	5e fc       	retal	r12

8000655a <vListInsertEnd>:

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
8000655a:	78 18       	ld.w	r8,r12[0x4]

	pxNewListItem->pxNext = pxIndex->pxNext;
8000655c:	70 19       	ld.w	r9,r8[0x4]
8000655e:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxPrevious = pxList->pxIndex;
80006560:	78 19       	ld.w	r9,r12[0x4]
80006562:	97 29       	st.w	r11[0x8],r9
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80006564:	70 19       	ld.w	r9,r8[0x4]
80006566:	93 2b       	st.w	r9[0x8],r11
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
80006568:	91 1b       	st.w	r8[0x4],r11
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
8000656a:	99 1b       	st.w	r12[0x4],r11

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
8000656c:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
8000656e:	78 08       	ld.w	r8,r12[0x0]
80006570:	2f f8       	sub	r8,-1
80006572:	99 08       	st.w	r12[0x0],r8
}
80006574:	5e fc       	retal	r12

80006576 <vListInsert>:
{
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
80006576:	76 0a       	ld.w	r10,r11[0x0]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
80006578:	5b fa       	cp.w	r10,-1
8000657a:	c0 31       	brne	80006580 <vListInsert+0xa>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
8000657c:	78 48       	ld.w	r8,r12[0x10]
8000657e:	c0 c8       	rjmp	80006596 <vListInsert+0x20>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
80006580:	f8 c8 ff f8 	sub	r8,r12,-8
80006584:	70 19       	ld.w	r9,r8[0x4]
80006586:	72 09       	ld.w	r9,r9[0x0]
80006588:	12 3a       	cp.w	r10,r9
8000658a:	c0 63       	brcs	80006596 <vListInsert+0x20>
8000658c:	70 18       	ld.w	r8,r8[0x4]
8000658e:	70 19       	ld.w	r9,r8[0x4]
80006590:	72 09       	ld.w	r9,r9[0x0]
80006592:	12 3a       	cp.w	r10,r9
80006594:	cf c2       	brcc	8000658c <vListInsert+0x16>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
80006596:	70 19       	ld.w	r9,r8[0x4]
80006598:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
8000659a:	93 2b       	st.w	r9[0x8],r11
	pxNewListItem->pxPrevious = pxIterator;
8000659c:	97 28       	st.w	r11[0x8],r8
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
8000659e:	91 1b       	st.w	r8[0x4],r11

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
800065a0:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
800065a2:	78 08       	ld.w	r8,r12[0x0]
800065a4:	2f f8       	sub	r8,-1
800065a6:	99 08       	st.w	r12[0x0],r8
}
800065a8:	5e fc       	retal	r12

800065aa <vListRemove>:

void vListRemove( xListItem *pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
800065aa:	78 18       	ld.w	r8,r12[0x4]
800065ac:	78 29       	ld.w	r9,r12[0x8]
800065ae:	91 29       	st.w	r8[0x8],r9
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
800065b0:	78 28       	ld.w	r8,r12[0x8]
800065b2:	78 19       	ld.w	r9,r12[0x4]
800065b4:	91 19       	st.w	r8[0x4],r9

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
800065b6:	78 48       	ld.w	r8,r12[0x10]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
800065b8:	70 19       	ld.w	r9,r8[0x4]
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
800065ba:	18 39       	cp.w	r9,r12
800065bc:	f9 f9 00 02 	ld.weq	r9,r12[0x8]
800065c0:	f1 f9 0a 01 	st.weq	r8[0x4],r9
	}

	pxItemToRemove->pvContainer = NULL;
800065c4:	30 09       	mov	r9,0
800065c6:	99 49       	st.w	r12[0x10],r9
	( pxList->uxNumberOfItems )--;
800065c8:	70 09       	ld.w	r9,r8[0x0]
800065ca:	20 19       	sub	r9,1
800065cc:	91 09       	st.w	r8[0x0],r9
}
800065ce:	5e fc       	retal	r12

800065d0 <pxPortInitialiseStack>:
	/* Setup the initial stack of the task.  The stack is set exactly as
	expected by the portRESTORE_CONTEXT() macro. */

	/* When the task starts, it will expect to find the function parameter in R12. */
	pxTopOfStack--;
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x08080808;					/* R8 */
800065d0:	e0 68 08 08 	mov	r8,2056
800065d4:	ea 18 08 08 	orh	r8,0x808
800065d8:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x09090909;					/* R9 */
800065da:	e0 68 09 09 	mov	r8,2313
800065de:	ea 18 09 09 	orh	r8,0x909
800065e2:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0A0A0A0A;					/* R10 */
800065e4:	e0 68 0a 0a 	mov	r8,2570
800065e8:	ea 18 0a 0a 	orh	r8,0xa0a
800065ec:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0B0B0B0B;					/* R11 */
800065ee:	e0 68 0b 0b 	mov	r8,2827
800065f2:	ea 18 0b 0b 	orh	r8,0xb0b
800065f6:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pvParameters;					/* R12 */
800065f8:	18 da       	st.w	--r12,r10
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xDEADBEEF;					/* R14/LR */
800065fa:	e0 68 be ef 	mov	r8,48879
800065fe:	ea 18 de ad 	orh	r8,0xdead
80006602:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pxCode + portINSTRUCTION_SIZE; /* R15/PC */
80006604:	18 db       	st.w	--r12,r11
	*pxTopOfStack-- = ( portSTACK_TYPE ) portINITIAL_SR;				/* SR */
80006606:	fc 18 00 40 	movh	r8,0x40
8000660a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xFF0000FF;					/* R0 */
8000660c:	e0 68 00 ff 	mov	r8,255
80006610:	ea 18 ff 00 	orh	r8,0xff00
80006614:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x01010101;					/* R1 */
80006616:	e0 68 01 01 	mov	r8,257
8000661a:	ea 18 01 01 	orh	r8,0x101
8000661e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x02020202;					/* R2 */
80006620:	e0 68 02 02 	mov	r8,514
80006624:	ea 18 02 02 	orh	r8,0x202
80006628:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x03030303;					/* R3 */
8000662a:	e0 68 03 03 	mov	r8,771
8000662e:	ea 18 03 03 	orh	r8,0x303
80006632:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x04040404;					/* R4 */
80006634:	e0 68 04 04 	mov	r8,1028
80006638:	ea 18 04 04 	orh	r8,0x404
8000663c:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x05050505;					/* R5 */
8000663e:	e0 68 05 05 	mov	r8,1285
80006642:	ea 18 05 05 	orh	r8,0x505
80006646:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x06060606;					/* R6 */
80006648:	e0 68 06 06 	mov	r8,1542
8000664c:	ea 18 06 06 	orh	r8,0x606
80006650:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x07070707;					/* R7 */
80006652:	e0 68 07 07 	mov	r8,1799
80006656:	ea 18 07 07 	orh	r8,0x707
8000665a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack = ( portSTACK_TYPE ) portNO_CRITICAL_NESTING;			/* ulCriticalNesting */
8000665c:	30 08       	mov	r8,0
8000665e:	18 d8       	st.w	--r12,r8

	return pxTopOfStack;
}
80006660:	5e fc       	retal	r12
80006662:	d7 03       	nop

80006664 <vPortEnterCritical>:
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
__attribute__((__noinline__)) void vPortEnterCritical( void )
{
	/* Disable interrupts */
	portDISABLE_INTERRUPTS();
80006664:	d3 03       	ssrf	0x10

	/* Now interrupts are disabled ulCriticalNesting can be accessed
	 directly.  Increment ulCriticalNesting to keep a count of how many times
	 portENTER_CRITICAL() has been called. */
	ulCriticalNesting++;
80006666:	48 38       	lddpc	r8,80006670 <vPortEnterCritical+0xc>
80006668:	70 09       	ld.w	r9,r8[0x0]
8000666a:	2f f9       	sub	r9,-1
8000666c:	91 09       	st.w	r8[0x0],r9
}
8000666e:	5e fc       	retal	r12
80006670:	00 00       	add	r0,r0
80006672:	05 44       	ld.w	r4,--r2

80006674 <xPortStartScheduler>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
80006674:	d4 01       	pushm	lr
	};

#endif

	/* Disable all interrupt/exception. */
	portDISABLE_INTERRUPTS();
80006676:	d3 03       	ssrf	0x10
		/* Start the timer/counter. */
		tc_start(tc, configTICK_TC_CHANNEL);
	}
	#else
	{
		INTC_register_interrupt(&vTick, AVR32_CORE_COMPARE_IRQ, AVR32_INTC_INT0);
80006678:	30 0a       	mov	r10,0
8000667a:	14 9b       	mov	r11,r10
8000667c:	49 2c       	lddpc	r12,800066c4 <xPortStartScheduler+0x50>
8000667e:	f0 1f 00 13 	mcall	800066c8 <xPortStartScheduler+0x54>
/* Schedule the COUNT&COMPARE match interrupt in (configCPU_CLOCK_HZ/configTICK_RATE_HZ)
clock cycles from now. */
#if( configTICK_USE_TC==0 )
	static void prvScheduleFirstTick(void)
	{
		Set_system_register(AVR32_COMPARE, configCPU_CLOCK_HZ/configTICK_RATE_HZ);//cause!!!
80006682:	e0 68 5d c0 	mov	r8,24000
80006686:	e3 b8 00 43 	mtsr	0x10c,r8
		Set_system_register(AVR32_COUNT, 0);
8000668a:	30 08       	mov	r8,0
8000668c:	e3 b8 00 42 	mtsr	0x108,r8
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();

	/* Start the first task. */
	portRESTORE_CONTEXT();
80006690:	e0 68 0d 5c 	mov	r8,3420
80006694:	ea 18 00 00 	orh	r8,0x0
80006698:	70 00       	ld.w	r0,r8[0x0]
8000669a:	60 0d       	ld.w	sp,r0[0x0]
8000669c:	1b 00       	ld.w	r0,sp++
8000669e:	e0 68 05 44 	mov	r8,1348
800066a2:	ea 18 00 00 	orh	r8,0x0
800066a6:	91 00       	st.w	r8[0x0],r0
800066a8:	e3 cd 00 ff 	ldm	sp++,r0-r7
800066ac:	2f ed       	sub	sp,-8
800066ae:	e3 cd 5f 00 	ldm	sp++,r8-r12,lr
800066b2:	fa f0 ff e0 	ld.w	r0,sp[-32]
800066b6:	e3 b0 00 00 	mtsr	0x0,r0
800066ba:	fa f0 ff dc 	ld.w	r0,sp[-36]
800066be:	fa ff ff e4 	ld.w	pc,sp[-28]

	/* Should not get here! */
	return 0;
}
800066c2:	d8 0a       	popm	pc,r12=0
800066c4:	80 00       	ld.sh	r0,r0[0x0]
800066c6:	67 90       	ld.w	r0,r3[0x64]
800066c8:	80 00       	ld.sh	r0,r0[0x0]
800066ca:	5c c4       	swap.bh	r4

800066cc <SCALLYield>:
/*-----------------------------------------------------------*/
__attribute__((__naked__)) void SCALLYield( void );
__attribute__((__naked__)) void SCALLYield( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_SCALL();
800066cc:	20 6d       	sub	sp,24
800066ce:	eb cd 00 ff 	pushm	r0-r7
800066d2:	fa c7 ff c0 	sub	r7,sp,-64
800066d6:	ee f0 ff f8 	ld.w	r0,r7[-8]
800066da:	ef 40 ff e0 	st.w	r7[-32],r0
800066de:	ee f0 ff fc 	ld.w	r0,r7[-4]
800066e2:	ef 40 ff e4 	st.w	r7[-28],r0
800066e6:	eb c7 5f 00 	stm	--r7,r8-r12,lr
800066ea:	e0 68 05 44 	mov	r8,1348
800066ee:	ea 18 00 00 	orh	r8,0x0
800066f2:	70 00       	ld.w	r0,r8[0x0]
800066f4:	1a d0       	st.w	--sp,r0
800066f6:	f0 1f 00 1a 	mcall	8000675c <LABEL_RET_SCALL_263+0x14>
800066fa:	e0 68 0d 5c 	mov	r8,3420
800066fe:	ea 18 00 00 	orh	r8,0x0
80006702:	70 00       	ld.w	r0,r8[0x0]
80006704:	81 0d       	st.w	r0[0x0],sp
	vTaskSwitchContext();
80006706:	f0 1f 00 17 	mcall	80006760 <LABEL_RET_SCALL_263+0x18>
	portRESTORE_CONTEXT_SCALL();
8000670a:	e0 68 0d 5c 	mov	r8,3420
8000670e:	ea 18 00 00 	orh	r8,0x0
80006712:	70 00       	ld.w	r0,r8[0x0]
80006714:	60 0d       	ld.w	sp,r0[0x0]
80006716:	1b 00       	ld.w	r0,sp++
80006718:	e0 68 05 44 	mov	r8,1348
8000671c:	ea 18 00 00 	orh	r8,0x0
80006720:	91 00       	st.w	r8[0x0],r0
80006722:	fa c7 ff d8 	sub	r7,sp,-40
80006726:	e3 c7 5f 00 	ldm	r7++,r8-r12,lr
8000672a:	ee f0 ff e0 	ld.w	r0,r7[-32]
8000672e:	e0 61 05 44 	mov	r1,1348
80006732:	ea 11 00 00 	orh	r1,0x0
80006736:	62 02       	ld.w	r2,r1[0x0]
80006738:	58 02       	cp.w	r2,0
8000673a:	c0 70       	breq	80006748 <LABEL_RET_SCALL_263>
8000673c:	e4 c2 00 01 	sub	r2,r2,1
80006740:	83 02       	st.w	r1[0x0],r2
80006742:	58 02       	cp.w	r2,0
80006744:	c0 21       	brne	80006748 <LABEL_RET_SCALL_263>
80006746:	b1 c0       	cbr	r0,0x10

80006748 <LABEL_RET_SCALL_263>:
80006748:	ef 40 ff f8 	st.w	r7[-8],r0
8000674c:	ee f0 ff e4 	ld.w	r0,r7[-28]
80006750:	ef 40 ff fc 	st.w	r7[-4],r0
80006754:	e3 cd 00 ff 	ldm	sp++,r0-r7
80006758:	2f ad       	sub	sp,-24
8000675a:	d6 13       	rets
8000675c:	80 00       	ld.sh	r0,r0[0x0]
8000675e:	66 64       	ld.w	r4,r3[0x18]
80006760:	80 00       	ld.sh	r0,r0[0x0]
80006762:	6e 00       	ld.w	r0,r7[0x0]

80006764 <prvClearCcInt>:
		Set_system_register(AVR32_COUNT, 0);
	}

	__attribute__((__noinline__)) static void prvClearCcInt(void)
	{
		Set_system_register(AVR32_COMPARE, Get_system_register(AVR32_COMPARE));
80006764:	e1 b8 00 43 	mfsr	r8,0x10c
80006768:	e3 b8 00 43 	mtsr	0x10c,r8
	}
8000676c:	5e fc       	retal	r12
8000676e:	d7 03       	nop

80006770 <vPortExitCritical>:
}
/*-----------------------------------------------------------*/

__attribute__((__noinline__)) void vPortExitCritical( void )
{
	if(ulCriticalNesting > portNO_CRITICAL_NESTING)
80006770:	48 78       	lddpc	r8,8000678c <vPortExitCritical+0x1c>
80006772:	70 08       	ld.w	r8,r8[0x0]
80006774:	58 08       	cp.w	r8,0
80006776:	5e 0c       	reteq	r12
	{
		ulCriticalNesting--;
80006778:	48 58       	lddpc	r8,8000678c <vPortExitCritical+0x1c>
8000677a:	70 09       	ld.w	r9,r8[0x0]
8000677c:	20 19       	sub	r9,1
8000677e:	91 09       	st.w	r8[0x0],r9
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
80006780:	70 08       	ld.w	r8,r8[0x0]
80006782:	58 08       	cp.w	r8,0
80006784:	5e 1c       	retne	r12
		{
			/* Enable all interrupt/exception. */
			portENABLE_INTERRUPTS();
80006786:	d5 03       	csrf	0x10
80006788:	5e fc       	retal	r12
8000678a:	00 00       	add	r0,r0
8000678c:	00 00       	add	r0,r0
8000678e:	05 44       	ld.w	r4,--r2

80006790 <vTick>:
/* The preemptive scheduler is defined as "naked" as the full context is saved
on entry as part of the context switch. */
__attribute__((__naked__)) static void vTick( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_OS_INT();
80006790:	eb cd 00 ff 	pushm	r0-r7
80006794:	e0 68 05 44 	mov	r8,1348
80006798:	ea 18 00 00 	orh	r8,0x0
8000679c:	70 00       	ld.w	r0,r8[0x0]
8000679e:	1a d0       	st.w	--sp,r0
800067a0:	7a 90       	ld.w	r0,sp[0x24]
800067a2:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
800067a6:	58 10       	cp.w	r0,1
800067a8:	e0 8b 00 08 	brhi	800067b8 <LABEL_INT_SKIP_SAVE_CONTEXT_237>
800067ac:	e0 68 0d 5c 	mov	r8,3420
800067b0:	ea 18 00 00 	orh	r8,0x0
800067b4:	70 00       	ld.w	r0,r8[0x0]
800067b6:	81 0d       	st.w	r0[0x0],sp

800067b8 <LABEL_INT_SKIP_SAVE_CONTEXT_237>:
	#if( configTICK_USE_TC==1 )
		/* Clear the interrupt flag. */
		prvClearTcInt();
	#else
		/* Clear the interrupt flag. */
		prvClearCcInt();
800067b8:	f0 1f 00 12 	mcall	80006800 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x14>
	#endif

	/* Because FreeRTOS is not supposed to run with nested interrupts, put all OS
	calls in a critical section . */
	portENTER_CRITICAL();
800067bc:	f0 1f 00 12 	mcall	80006804 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
		vTaskIncrementTick();
800067c0:	f0 1f 00 12 	mcall	80006808 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x1c>
	portEXIT_CRITICAL();
800067c4:	f0 1f 00 12 	mcall	8000680c <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>

	/* Restore the context of the "elected task". */
	portRESTORE_CONTEXT_OS_INT();
800067c8:	7a 90       	ld.w	r0,sp[0x24]
800067ca:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
800067ce:	58 10       	cp.w	r0,1
800067d0:	e0 8b 00 0e 	brhi	800067ec <LABEL_INT_SKIP_RESTORE_CONTEXT_254>
800067d4:	f0 1f 00 0c 	mcall	80006804 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
800067d8:	f0 1f 00 0e 	mcall	80006810 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x24>
800067dc:	f0 1f 00 0c 	mcall	8000680c <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>
800067e0:	e0 68 0d 5c 	mov	r8,3420
800067e4:	ea 18 00 00 	orh	r8,0x0
800067e8:	70 00       	ld.w	r0,r8[0x0]
800067ea:	60 0d       	ld.w	sp,r0[0x0]

800067ec <LABEL_INT_SKIP_RESTORE_CONTEXT_254>:
800067ec:	1b 00       	ld.w	r0,sp++
800067ee:	e0 68 05 44 	mov	r8,1348
800067f2:	ea 18 00 00 	orh	r8,0x0
800067f6:	91 00       	st.w	r8[0x0],r0
800067f8:	e3 cd 00 ff 	ldm	sp++,r0-r7
800067fc:	d6 03       	rete
800067fe:	00 00       	add	r0,r0
80006800:	80 00       	ld.sh	r0,r0[0x0]
80006802:	67 64       	ld.w	r4,r3[0x58]
80006804:	80 00       	ld.sh	r0,r0[0x0]
80006806:	66 64       	ld.w	r4,r3[0x18]
80006808:	80 00       	ld.sh	r0,r0[0x0]
8000680a:	70 04       	ld.w	r4,r8[0x0]
8000680c:	80 00       	ld.sh	r0,r0[0x0]
8000680e:	67 70       	ld.w	r0,r3[0x5c]
80006810:	80 00       	ld.sh	r0,r0[0x0]
80006812:	6e 00       	ld.w	r0,r7[0x0]

80006814 <__malloc_lock>:
 * safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_lock(struct _reent *ptr);
void __malloc_lock(struct _reent *ptr)
{
80006814:	d4 01       	pushm	lr
	vTaskSuspendAll();
80006816:	f0 1f 00 02 	mcall	8000681c <__malloc_lock+0x8>
}
8000681a:	d8 02       	popm	pc
8000681c:	80 00       	ld.sh	r0,r0[0x0]
8000681e:	6d f0       	ld.w	r0,r6[0x7c]

80006820 <__malloc_unlock>:
 * a safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_unlock(struct _reent *ptr);
void __malloc_unlock(struct _reent *ptr)
{
80006820:	d4 01       	pushm	lr
	xTaskResumeAll();
80006822:	f0 1f 00 02 	mcall	80006828 <__malloc_unlock+0x8>
}
80006826:	d8 02       	popm	pc
80006828:	80 00       	ld.sh	r0,r0[0x0]
8000682a:	71 ac       	ld.w	r12,r8[0x68]

8000682c <_read>:
/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
{
8000682c:	d4 21       	pushm	r4-r7,lr
8000682e:	16 95       	mov	r5,r11
80006830:	14 96       	mov	r6,r10
  int nChars = 0;

  if (file != 0)
80006832:	58 0c       	cp.w	r12,0
80006834:	c0 30       	breq	8000683a <_read+0xe>
80006836:	3f f7       	mov	r7,-1
80006838:	c1 48       	rjmp	80006860 <_read+0x34>
    return -1;

  for (; len > 0; --len)
8000683a:	58 0a       	cp.w	r10,0
8000683c:	e0 89 00 04 	brgt	80006844 <_read+0x18>
80006840:	30 07       	mov	r7,0
80006842:	c0 f8       	rjmp	80006860 <_read+0x34>
80006844:	30 07       	mov	r7,0
  {
    int c = usart_getchar(stdio_usart_base);
80006846:	48 84       	lddpc	r4,80006864 <_read+0x38>
80006848:	68 0c       	ld.w	r12,r4[0x0]
8000684a:	f0 1f 00 08 	mcall	80006868 <_read+0x3c>
    if (c < 0)
8000684e:	c0 95       	brlt	80006860 <_read+0x34>
      break;

    *ptr++ = c;
80006850:	ea 07 0b 0c 	st.b	r5[r7],r12
    ++nChars;
80006854:	2f f7       	sub	r7,-1

/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
80006856:	ec 07 01 08 	sub	r8,r6,r7
  int nChars = 0;

  if (file != 0)
    return -1;

  for (; len > 0; --len)
8000685a:	58 08       	cp.w	r8,0
8000685c:	fe 99 ff f6 	brgt	80006848 <_read+0x1c>
    *ptr++ = c;
    ++nChars;
  }

  return nChars;
}
80006860:	0e 9c       	mov	r12,r7
80006862:	d8 22       	popm	r4-r7,pc
80006864:	00 00       	add	r0,r0
80006866:	54 2c       	stdsp	sp[0x108],r12
80006868:	80 00       	ld.sh	r0,r0[0x0]
8000686a:	63 b8       	ld.w	r8,r1[0x6c]

8000686c <_write>:
 * 1 and 2 is stdout and stderr which goes to usart
 * 3 is framebuffer
 */
int __attribute__((weak))
_write (int file, char * ptr, int len)
{
8000686c:	d4 21       	pushm	r4-r7,lr
8000686e:	16 95       	mov	r5,r11
80006870:	14 96       	mov	r6,r10
  int nChars = 0;

  if ( (file != 1)
80006872:	20 1c       	sub	r12,1
80006874:	58 2c       	cp.w	r12,2
80006876:	e0 8b 00 12 	brhi	8000689a <_write+0x2e>
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
8000687a:	58 0a       	cp.w	r10,0
8000687c:	c0 31       	brne	80006882 <_write+0x16>
8000687e:	30 07       	mov	r7,0
80006880:	c0 e8       	rjmp	8000689c <_write+0x30>
80006882:	30 07       	mov	r7,0
  {
    if (usart_putchar(stdio_usart_base, *ptr++) < 0)
80006884:	48 74       	lddpc	r4,800068a0 <_write+0x34>
80006886:	68 0c       	ld.w	r12,r4[0x0]
80006888:	ea 07 07 0b 	ld.ub	r11,r5[r7]
8000688c:	f0 1f 00 06 	mcall	800068a4 <_write+0x38>
80006890:	c0 55       	brlt	8000689a <_write+0x2e>
    {
      return -1;
    }

    ++nChars;
80006892:	2f f7       	sub	r7,-1

  if ( (file != 1)
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80006894:	0e 36       	cp.w	r6,r7
80006896:	cf 81       	brne	80006886 <_write+0x1a>
80006898:	c0 28       	rjmp	8000689c <_write+0x30>
8000689a:	3f f7       	mov	r7,-1

    ++nChars;
  }

  return nChars;
}
8000689c:	0e 9c       	mov	r12,r7
8000689e:	d8 22       	popm	r4-r7,pc
800068a0:	00 00       	add	r0,r0
800068a2:	54 2c       	stdsp	sp[0x108],r12
800068a4:	80 00       	ld.sh	r0,r0[0x0]
800068a6:	63 68       	ld.w	r8,r1[0x58]

800068a8 <vPortFree>:
	return pvReturn;
}
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
800068a8:	eb cd 40 80 	pushm	r7,lr
800068ac:	18 97       	mov	r7,r12
	if( pv )
800068ae:	58 0c       	cp.w	r12,0
800068b0:	c0 80       	breq	800068c0 <vPortFree+0x18>
	{
		vTaskSuspendAll();
800068b2:	f0 1f 00 05 	mcall	800068c4 <vPortFree+0x1c>
		{
			free( pv );
800068b6:	0e 9c       	mov	r12,r7
800068b8:	f0 1f 00 04 	mcall	800068c8 <vPortFree+0x20>
		}
		xTaskResumeAll();
800068bc:	f0 1f 00 04 	mcall	800068cc <vPortFree+0x24>
800068c0:	e3 cd 80 80 	ldm	sp++,r7,pc
800068c4:	80 00       	ld.sh	r0,r0[0x0]
800068c6:	6d f0       	ld.w	r0,r6[0x7c]
800068c8:	80 00       	ld.sh	r0,r0[0x0]
800068ca:	7c 88       	ld.w	r8,lr[0x20]
800068cc:	80 00       	ld.sh	r0,r0[0x0]
800068ce:	71 ac       	ld.w	r12,r8[0x68]

800068d0 <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
800068d0:	eb cd 40 80 	pushm	r7,lr
800068d4:	18 97       	mov	r7,r12
void *pvReturn;

	vTaskSuspendAll();
800068d6:	f0 1f 00 06 	mcall	800068ec <pvPortMalloc+0x1c>
	{
		pvReturn = malloc( xWantedSize );
800068da:	0e 9c       	mov	r12,r7
800068dc:	f0 1f 00 05 	mcall	800068f0 <pvPortMalloc+0x20>
800068e0:	18 97       	mov	r7,r12
	}
	xTaskResumeAll();
800068e2:	f0 1f 00 05 	mcall	800068f4 <pvPortMalloc+0x24>
		}
	}
	#endif

	return pvReturn;
}
800068e6:	0e 9c       	mov	r12,r7
800068e8:	e3 cd 80 80 	ldm	sp++,r7,pc
800068ec:	80 00       	ld.sh	r0,r0[0x0]
800068ee:	6d f0       	ld.w	r0,r6[0x7c]
800068f0:	80 00       	ld.sh	r0,r0[0x0]
800068f2:	7c 98       	ld.w	r8,lr[0x24]
800068f4:	80 00       	ld.sh	r0,r0[0x0]
800068f6:	71 ac       	ld.w	r12,r8[0x68]

800068f8 <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
800068f8:	d4 01       	pushm	lr
800068fa:	16 98       	mov	r8,r11
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
800068fc:	78 09       	ld.w	r9,r12[0x0]
800068fe:	58 09       	cp.w	r9,0
80006900:	c1 10       	breq	80006922 <prvCopyDataFromQueue+0x2a>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
80006902:	78 3a       	ld.w	r10,r12[0xc]
80006904:	79 09       	ld.w	r9,r12[0x40]
80006906:	f4 09 00 09 	add	r9,r10,r9
8000690a:	99 39       	st.w	r12[0xc],r9
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
8000690c:	78 1a       	ld.w	r10,r12[0x4]
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
8000690e:	14 39       	cp.w	r9,r10
80006910:	f9 f9 20 00 	ld.wcc	r9,r12[0x0]
80006914:	f9 f9 2a 03 	st.wcc	r12[0xc],r9
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
80006918:	79 0a       	ld.w	r10,r12[0x40]
8000691a:	78 3b       	ld.w	r11,r12[0xc]
8000691c:	10 9c       	mov	r12,r8
8000691e:	f0 1f 00 02 	mcall	80006924 <prvCopyDataFromQueue+0x2c>
80006922:	d8 02       	popm	pc
80006924:	80 00       	ld.sh	r0,r0[0x0]
80006926:	81 06       	st.w	r0[0x0],r6

80006928 <xQueueReceiveFromISR>:
	}
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
80006928:	eb cd 40 c0 	pushm	r6-r7,lr
8000692c:	18 97       	mov	r7,r12
8000692e:	14 96       	mov	r6,r10
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80006930:	78 e8       	ld.w	r8,r12[0x38]
80006932:	58 08       	cp.w	r8,0
80006934:	c0 31       	brne	8000693a <xQueueReceiveFromISR+0x12>
80006936:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
8000693a:	f0 1f 00 0e 	mcall	80006970 <xQueueReceiveFromISR+0x48>
			--( pxQueue->uxMessagesWaiting );
8000693e:	6e e8       	ld.w	r8,r7[0x38]
80006940:	20 18       	sub	r8,1
80006942:	8f e8       	st.w	r7[0x38],r8

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
80006944:	6f 18       	ld.w	r8,r7[0x44]
80006946:	5b f8       	cp.w	r8,-1
80006948:	c0 d1       	brne	80006962 <xQueueReceiveFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
8000694a:	6e 48       	ld.w	r8,r7[0x10]
8000694c:	58 08       	cp.w	r8,0
8000694e:	c0 f0       	breq	8000696c <xQueueReceiveFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80006950:	ee cc ff f0 	sub	r12,r7,-16
80006954:	f0 1f 00 08 	mcall	80006974 <xQueueReceiveFromISR+0x4c>
80006958:	c0 a0       	breq	8000696c <xQueueReceiveFromISR+0x44>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
8000695a:	30 1c       	mov	r12,1
8000695c:	8d 0c       	st.w	r6[0x0],r12
8000695e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
80006962:	2f f8       	sub	r8,-1
80006964:	ef 48 00 44 	st.w	r7[68],r8
80006968:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
8000696c:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80006970:	80 00       	ld.sh	r0,r0[0x0]
80006972:	68 f8       	ld.w	r8,r4[0x3c]
80006974:	80 00       	ld.sh	r0,r0[0x0]
80006976:	6f 88       	ld.w	r8,r7[0x60]

80006978 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
80006978:	eb cd 40 c0 	pushm	r6-r7,lr
8000697c:	18 97       	mov	r7,r12

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
8000697e:	f0 1f 00 23 	mcall	80006a08 <prvUnlockQueue+0x90>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80006982:	6f 28       	ld.w	r8,r7[0x48]
80006984:	58 08       	cp.w	r8,0
80006986:	e0 8a 00 18 	brle	800069b6 <prvUnlockQueue+0x3e>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
8000698a:	6e 98       	ld.w	r8,r7[0x24]
8000698c:	58 08       	cp.w	r8,0
8000698e:	c1 40       	breq	800069b6 <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80006990:	ee c6 ff dc 	sub	r6,r7,-36
80006994:	c0 48       	rjmp	8000699c <prvUnlockQueue+0x24>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80006996:	6e 98       	ld.w	r8,r7[0x24]
80006998:	58 08       	cp.w	r8,0
8000699a:	c0 e0       	breq	800069b6 <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
8000699c:	0c 9c       	mov	r12,r6
8000699e:	f0 1f 00 1c 	mcall	80006a0c <prvUnlockQueue+0x94>
800069a2:	c0 30       	breq	800069a8 <prvUnlockQueue+0x30>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
800069a4:	f0 1f 00 1b 	mcall	80006a10 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xTxLock );
800069a8:	6f 28       	ld.w	r8,r7[0x48]
800069aa:	20 18       	sub	r8,1
800069ac:	ef 48 00 48 	st.w	r7[72],r8
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
800069b0:	58 08       	cp.w	r8,0
800069b2:	fe 99 ff f2 	brgt	80006996 <prvUnlockQueue+0x1e>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
800069b6:	3f f8       	mov	r8,-1
800069b8:	ef 48 00 48 	st.w	r7[72],r8
	}
	taskEXIT_CRITICAL();
800069bc:	f0 1f 00 16 	mcall	80006a14 <prvUnlockQueue+0x9c>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
800069c0:	f0 1f 00 12 	mcall	80006a08 <prvUnlockQueue+0x90>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
800069c4:	6f 18       	ld.w	r8,r7[0x44]
800069c6:	58 08       	cp.w	r8,0
800069c8:	e0 8a 00 18 	brle	800069f8 <prvUnlockQueue+0x80>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
800069cc:	6e 48       	ld.w	r8,r7[0x10]
800069ce:	58 08       	cp.w	r8,0
800069d0:	c1 40       	breq	800069f8 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
800069d2:	ee c6 ff f0 	sub	r6,r7,-16
800069d6:	c0 48       	rjmp	800069de <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
800069d8:	6e 48       	ld.w	r8,r7[0x10]
800069da:	58 08       	cp.w	r8,0
800069dc:	c0 e0       	breq	800069f8 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
800069de:	0c 9c       	mov	r12,r6
800069e0:	f0 1f 00 0b 	mcall	80006a0c <prvUnlockQueue+0x94>
800069e4:	c0 30       	breq	800069ea <prvUnlockQueue+0x72>
				{
					vTaskMissedYield();
800069e6:	f0 1f 00 0b 	mcall	80006a10 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xRxLock );
800069ea:	6f 18       	ld.w	r8,r7[0x44]
800069ec:	20 18       	sub	r8,1
800069ee:	ef 48 00 44 	st.w	r7[68],r8
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
800069f2:	58 08       	cp.w	r8,0
800069f4:	fe 99 ff f2 	brgt	800069d8 <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
800069f8:	3f f8       	mov	r8,-1
800069fa:	ef 48 00 44 	st.w	r7[68],r8
	}
	taskEXIT_CRITICAL();
800069fe:	f0 1f 00 06 	mcall	80006a14 <prvUnlockQueue+0x9c>
}
80006a02:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006a06:	00 00       	add	r0,r0
80006a08:	80 00       	ld.sh	r0,r0[0x0]
80006a0a:	66 64       	ld.w	r4,r3[0x18]
80006a0c:	80 00       	ld.sh	r0,r0[0x0]
80006a0e:	6f 88       	ld.w	r8,r7[0x60]
80006a10:	80 00       	ld.sh	r0,r0[0x0]
80006a12:	6e 94       	ld.w	r4,r7[0x24]
80006a14:	80 00       	ld.sh	r0,r0[0x0]
80006a16:	67 70       	ld.w	r0,r3[0x5c]

80006a18 <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
80006a18:	d4 31       	pushm	r0-r7,lr
80006a1a:	20 5d       	sub	sp,20
80006a1c:	18 97       	mov	r7,r12
80006a1e:	50 0b       	stdsp	sp[0x0],r11
80006a20:	50 2a       	stdsp	sp[0x8],r10
80006a22:	50 19       	stdsp	sp[0x4],r9
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80006a24:	f8 c2 ff dc 	sub	r2,r12,-36
80006a28:	30 05       	mov	r5,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80006a2a:	fa c4 ff f4 	sub	r4,sp,-12
80006a2e:	30 10       	mov	r0,1

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
80006a30:	0a 91       	mov	r1,r5

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80006a32:	fa c3 ff f8 	sub	r3,sp,-8
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
80006a36:	f0 1f 00 3e 	mcall	80006b2c <xQueueGenericReceive+0x114>
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80006a3a:	6e e8       	ld.w	r8,r7[0x38]
80006a3c:	58 08       	cp.w	r8,0
80006a3e:	c2 a0       	breq	80006a92 <xQueueGenericReceive+0x7a>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
80006a40:	6e 36       	ld.w	r6,r7[0xc]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
80006a42:	40 0b       	lddsp	r11,sp[0x0]
80006a44:	0e 9c       	mov	r12,r7
80006a46:	f0 1f 00 3b 	mcall	80006b30 <xQueueGenericReceive+0x118>

				if( xJustPeeking == pdFALSE )
80006a4a:	40 18       	lddsp	r8,sp[0x4]
80006a4c:	58 08       	cp.w	r8,0
80006a4e:	c1 51       	brne	80006a78 <xQueueGenericReceive+0x60>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
80006a50:	6e e8       	ld.w	r8,r7[0x38]
80006a52:	20 18       	sub	r8,1
80006a54:	8f e8       	st.w	r7[0x38],r8

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80006a56:	6e 08       	ld.w	r8,r7[0x0]
80006a58:	58 08       	cp.w	r8,0
80006a5a:	c0 41       	brne	80006a62 <xQueueGenericReceive+0x4a>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
80006a5c:	f0 1f 00 36 	mcall	80006b34 <xQueueGenericReceive+0x11c>
80006a60:	8f 1c       	st.w	r7[0x4],r12
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80006a62:	6e 48       	ld.w	r8,r7[0x10]
80006a64:	58 08       	cp.w	r8,0
80006a66:	c1 20       	breq	80006a8a <xQueueGenericReceive+0x72>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
80006a68:	ee cc ff f0 	sub	r12,r7,-16
80006a6c:	f0 1f 00 33 	mcall	80006b38 <xQueueGenericReceive+0x120>
80006a70:	58 1c       	cp.w	r12,1
80006a72:	c0 c1       	brne	80006a8a <xQueueGenericReceive+0x72>
						{
							portYIELD_WITHIN_API();
80006a74:	d7 33       	scall
80006a76:	c0 a8       	rjmp	80006a8a <xQueueGenericReceive+0x72>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
80006a78:	8f 36       	st.w	r7[0xc],r6

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80006a7a:	6e 98       	ld.w	r8,r7[0x24]
80006a7c:	58 08       	cp.w	r8,0
80006a7e:	c0 60       	breq	80006a8a <xQueueGenericReceive+0x72>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80006a80:	04 9c       	mov	r12,r2
80006a82:	f0 1f 00 2e 	mcall	80006b38 <xQueueGenericReceive+0x120>
80006a86:	c0 20       	breq	80006a8a <xQueueGenericReceive+0x72>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
80006a88:	d7 33       	scall
						}
					}

				}

				taskEXIT_CRITICAL();
80006a8a:	f0 1f 00 2d 	mcall	80006b3c <xQueueGenericReceive+0x124>
80006a8e:	30 1c       	mov	r12,1
				return pdPASS;
80006a90:	c4 c8       	rjmp	80006b28 <xQueueGenericReceive+0x110>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
80006a92:	40 28       	lddsp	r8,sp[0x8]
80006a94:	58 08       	cp.w	r8,0
80006a96:	c0 51       	brne	80006aa0 <xQueueGenericReceive+0x88>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80006a98:	f0 1f 00 29 	mcall	80006b3c <xQueueGenericReceive+0x124>
80006a9c:	30 0c       	mov	r12,0
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
80006a9e:	c4 58       	rjmp	80006b28 <xQueueGenericReceive+0x110>
				}
				else if( xEntryTimeSet == pdFALSE )
80006aa0:	58 05       	cp.w	r5,0
80006aa2:	c0 51       	brne	80006aac <xQueueGenericReceive+0x94>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80006aa4:	08 9c       	mov	r12,r4
80006aa6:	f0 1f 00 27 	mcall	80006b40 <xQueueGenericReceive+0x128>
80006aaa:	00 95       	mov	r5,r0
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80006aac:	f0 1f 00 24 	mcall	80006b3c <xQueueGenericReceive+0x124>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80006ab0:	f0 1f 00 25 	mcall	80006b44 <xQueueGenericReceive+0x12c>
		prvLockQueue( pxQueue );
80006ab4:	f0 1f 00 1e 	mcall	80006b2c <xQueueGenericReceive+0x114>
80006ab8:	6f 18       	ld.w	r8,r7[0x44]
80006aba:	5b f8       	cp.w	r8,-1
80006abc:	ef f1 0a 11 	st.weq	r7[0x44],r1
80006ac0:	6f 28       	ld.w	r8,r7[0x48]
80006ac2:	5b f8       	cp.w	r8,-1
80006ac4:	ef f1 0a 12 	st.weq	r7[0x48],r1
80006ac8:	f0 1f 00 1d 	mcall	80006b3c <xQueueGenericReceive+0x124>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80006acc:	06 9b       	mov	r11,r3
80006ace:	08 9c       	mov	r12,r4
80006ad0:	f0 1f 00 1e 	mcall	80006b48 <xQueueGenericReceive+0x130>
80006ad4:	c2 41       	brne	80006b1c <xQueueGenericReceive+0x104>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
80006ad6:	f0 1f 00 16 	mcall	80006b2c <xQueueGenericReceive+0x114>
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
80006ada:	6e e6       	ld.w	r6,r7[0x38]
	taskEXIT_CRITICAL();
80006adc:	f0 1f 00 18 	mcall	80006b3c <xQueueGenericReceive+0x124>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) )
80006ae0:	58 06       	cp.w	r6,0
80006ae2:	c1 71       	brne	80006b10 <xQueueGenericReceive+0xf8>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80006ae4:	6e 08       	ld.w	r8,r7[0x0]
80006ae6:	58 08       	cp.w	r8,0
80006ae8:	c0 81       	brne	80006af8 <xQueueGenericReceive+0xe0>
					{
						portENTER_CRITICAL();
80006aea:	f0 1f 00 11 	mcall	80006b2c <xQueueGenericReceive+0x114>
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
80006aee:	6e 1c       	ld.w	r12,r7[0x4]
80006af0:	f0 1f 00 17 	mcall	80006b4c <xQueueGenericReceive+0x134>
						}
						portEXIT_CRITICAL();
80006af4:	f0 1f 00 12 	mcall	80006b3c <xQueueGenericReceive+0x124>
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80006af8:	40 2b       	lddsp	r11,sp[0x8]
80006afa:	04 9c       	mov	r12,r2
80006afc:	f0 1f 00 15 	mcall	80006b50 <xQueueGenericReceive+0x138>
				prvUnlockQueue( pxQueue );
80006b00:	0e 9c       	mov	r12,r7
80006b02:	f0 1f 00 15 	mcall	80006b54 <xQueueGenericReceive+0x13c>
				if( !xTaskResumeAll() )
80006b06:	f0 1f 00 15 	mcall	80006b58 <xQueueGenericReceive+0x140>
80006b0a:	c9 61       	brne	80006a36 <xQueueGenericReceive+0x1e>
				{
					portYIELD_WITHIN_API();
80006b0c:	d7 33       	scall
80006b0e:	c9 4b       	rjmp	80006a36 <xQueueGenericReceive+0x1e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
80006b10:	0e 9c       	mov	r12,r7
80006b12:	f0 1f 00 11 	mcall	80006b54 <xQueueGenericReceive+0x13c>
				( void ) xTaskResumeAll();
80006b16:	f0 1f 00 11 	mcall	80006b58 <xQueueGenericReceive+0x140>
80006b1a:	c8 eb       	rjmp	80006a36 <xQueueGenericReceive+0x1e>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
80006b1c:	0e 9c       	mov	r12,r7
80006b1e:	f0 1f 00 0e 	mcall	80006b54 <xQueueGenericReceive+0x13c>
			( void ) xTaskResumeAll();
80006b22:	f0 1f 00 0e 	mcall	80006b58 <xQueueGenericReceive+0x140>
80006b26:	30 0c       	mov	r12,0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
80006b28:	2f bd       	sub	sp,-20
80006b2a:	d8 32       	popm	r0-r7,pc
80006b2c:	80 00       	ld.sh	r0,r0[0x0]
80006b2e:	66 64       	ld.w	r4,r3[0x18]
80006b30:	80 00       	ld.sh	r0,r0[0x0]
80006b32:	68 f8       	ld.w	r8,r4[0x3c]
80006b34:	80 00       	ld.sh	r0,r0[0x0]
80006b36:	6e a0       	ld.w	r0,r7[0x28]
80006b38:	80 00       	ld.sh	r0,r0[0x0]
80006b3a:	6f 88       	ld.w	r8,r7[0x60]
80006b3c:	80 00       	ld.sh	r0,r0[0x0]
80006b3e:	67 70       	ld.w	r0,r3[0x5c]
80006b40:	80 00       	ld.sh	r0,r0[0x0]
80006b42:	6e 7c       	ld.w	r12,r7[0x1c]
80006b44:	80 00       	ld.sh	r0,r0[0x0]
80006b46:	6d f0       	ld.w	r0,r6[0x7c]
80006b48:	80 00       	ld.sh	r0,r0[0x0]
80006b4a:	71 18       	ld.w	r8,r8[0x44]
80006b4c:	80 00       	ld.sh	r0,r0[0x0]
80006b4e:	6f 04       	ld.w	r4,r7[0x40]
80006b50:	80 00       	ld.sh	r0,r0[0x0]
80006b52:	73 b8       	ld.w	r8,r9[0x6c]
80006b54:	80 00       	ld.sh	r0,r0[0x0]
80006b56:	69 78       	ld.w	r8,r4[0x5c]
80006b58:	80 00       	ld.sh	r0,r0[0x0]
80006b5a:	71 ac       	ld.w	r12,r8[0x68]

80006b5c <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
80006b5c:	eb cd 40 80 	pushm	r7,lr
80006b60:	18 97       	mov	r7,r12
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
80006b62:	79 08       	ld.w	r8,r12[0x40]
80006b64:	58 08       	cp.w	r8,0
80006b66:	c0 a1       	brne	80006b7a <prvCopyDataToQueue+0x1e>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80006b68:	78 08       	ld.w	r8,r12[0x0]
80006b6a:	58 08       	cp.w	r8,0
80006b6c:	c2 b1       	brne	80006bc2 <prvCopyDataToQueue+0x66>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
80006b6e:	78 1c       	ld.w	r12,r12[0x4]
80006b70:	f0 1f 00 17 	mcall	80006bcc <prvCopyDataToQueue+0x70>
				pxQueue->pxMutexHolder = NULL;
80006b74:	30 08       	mov	r8,0
80006b76:	8f 18       	st.w	r7[0x4],r8
80006b78:	c2 58       	rjmp	80006bc2 <prvCopyDataToQueue+0x66>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
80006b7a:	58 0a       	cp.w	r10,0
80006b7c:	c1 01       	brne	80006b9c <prvCopyDataToQueue+0x40>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80006b7e:	10 9a       	mov	r10,r8
80006b80:	78 2c       	ld.w	r12,r12[0x8]
80006b82:	f0 1f 00 14 	mcall	80006bd0 <prvCopyDataToQueue+0x74>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
80006b86:	6e 29       	ld.w	r9,r7[0x8]
80006b88:	6f 08       	ld.w	r8,r7[0x40]
80006b8a:	f2 08 00 08 	add	r8,r9,r8
80006b8e:	8f 28       	st.w	r7[0x8],r8
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
80006b90:	6e 19       	ld.w	r9,r7[0x4]
80006b92:	12 38       	cp.w	r8,r9
80006b94:	c1 73       	brcs	80006bc2 <prvCopyDataToQueue+0x66>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
80006b96:	6e 08       	ld.w	r8,r7[0x0]
80006b98:	8f 28       	st.w	r7[0x8],r8
80006b9a:	c1 48       	rjmp	80006bc2 <prvCopyDataToQueue+0x66>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80006b9c:	10 9a       	mov	r10,r8
80006b9e:	78 3c       	ld.w	r12,r12[0xc]
80006ba0:	f0 1f 00 0c 	mcall	80006bd0 <prvCopyDataToQueue+0x74>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
80006ba4:	6f 08       	ld.w	r8,r7[0x40]
80006ba6:	6e 39       	ld.w	r9,r7[0xc]
80006ba8:	f2 08 01 08 	sub	r8,r9,r8
80006bac:	8f 38       	st.w	r7[0xc],r8
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
80006bae:	6e 09       	ld.w	r9,r7[0x0]
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
80006bb0:	12 38       	cp.w	r8,r9
80006bb2:	ef f8 30 10 	ld.wcs	r8,r7[0x40]
80006bb6:	ef f9 30 01 	ld.wcs	r9,r7[0x4]
80006bba:	f3 d8 e3 19 	subcs	r9,r9,r8
80006bbe:	ef f9 3a 03 	st.wcs	r7[0xc],r9
		}
	}

	++( pxQueue->uxMessagesWaiting );
80006bc2:	6e e8       	ld.w	r8,r7[0x38]
80006bc4:	2f f8       	sub	r8,-1
80006bc6:	8f e8       	st.w	r7[0x38],r8
}
80006bc8:	e3 cd 80 80 	ldm	sp++,r7,pc
80006bcc:	80 00       	ld.sh	r0,r0[0x0]
80006bce:	6e ac       	ld.w	r12,r7[0x28]
80006bd0:	80 00       	ld.sh	r0,r0[0x0]
80006bd2:	81 06       	st.w	r0[0x0],r6

80006bd4 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
80006bd4:	eb cd 40 c0 	pushm	r6-r7,lr
80006bd8:	18 97       	mov	r7,r12
80006bda:	14 96       	mov	r6,r10
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
80006bdc:	78 ec       	ld.w	r12,r12[0x38]
80006bde:	6e f8       	ld.w	r8,r7[0x3c]
80006be0:	10 3c       	cp.w	r12,r8
80006be2:	c0 33       	brcs	80006be8 <xQueueGenericSendFromISR+0x14>
80006be4:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80006be8:	12 9a       	mov	r10,r9
80006bea:	0e 9c       	mov	r12,r7
80006bec:	f0 1f 00 0c 	mcall	80006c1c <xQueueGenericSendFromISR+0x48>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
80006bf0:	6f 28       	ld.w	r8,r7[0x48]
80006bf2:	5b f8       	cp.w	r8,-1
80006bf4:	c0 d1       	brne	80006c0e <xQueueGenericSendFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80006bf6:	6e 98       	ld.w	r8,r7[0x24]
80006bf8:	58 08       	cp.w	r8,0
80006bfa:	c0 f0       	breq	80006c18 <xQueueGenericSendFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80006bfc:	ee cc ff dc 	sub	r12,r7,-36
80006c00:	f0 1f 00 08 	mcall	80006c20 <xQueueGenericSendFromISR+0x4c>
80006c04:	c0 a0       	breq	80006c18 <xQueueGenericSendFromISR+0x44>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
80006c06:	30 1c       	mov	r12,1
80006c08:	8d 0c       	st.w	r6[0x0],r12
80006c0a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
80006c0e:	2f f8       	sub	r8,-1
80006c10:	ef 48 00 48 	st.w	r7[72],r8
80006c14:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80006c18:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80006c1c:	80 00       	ld.sh	r0,r0[0x0]
80006c1e:	6b 5c       	ld.w	r12,r5[0x54]
80006c20:	80 00       	ld.sh	r0,r0[0x0]
80006c22:	6f 88       	ld.w	r8,r7[0x60]

80006c24 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
80006c24:	d4 31       	pushm	r0-r7,lr
80006c26:	20 5d       	sub	sp,20
80006c28:	18 97       	mov	r7,r12
80006c2a:	50 0b       	stdsp	sp[0x0],r11
80006c2c:	50 2a       	stdsp	sp[0x8],r10
80006c2e:	50 19       	stdsp	sp[0x4],r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
80006c30:	f8 c0 ff f0 	sub	r0,r12,-16
80006c34:	30 04       	mov	r4,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80006c36:	fa c3 ff f4 	sub	r3,sp,-12

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
80006c3a:	08 91       	mov	r1,r4

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80006c3c:	fa c2 ff f8 	sub	r2,sp,-8
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
80006c40:	f0 1f 00 2f 	mcall	80006cfc <xQueueGenericSend+0xd8>
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
80006c44:	6e e9       	ld.w	r9,r7[0x38]
80006c46:	6e f8       	ld.w	r8,r7[0x3c]
80006c48:	10 39       	cp.w	r9,r8
80006c4a:	c1 42       	brcc	80006c72 <xQueueGenericSend+0x4e>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80006c4c:	40 1a       	lddsp	r10,sp[0x4]
80006c4e:	40 0b       	lddsp	r11,sp[0x0]
80006c50:	0e 9c       	mov	r12,r7
80006c52:	f0 1f 00 2c 	mcall	80006d00 <xQueueGenericSend+0xdc>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80006c56:	6e 98       	ld.w	r8,r7[0x24]
80006c58:	58 08       	cp.w	r8,0
80006c5a:	c0 80       	breq	80006c6a <xQueueGenericSend+0x46>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
80006c5c:	ee cc ff dc 	sub	r12,r7,-36
80006c60:	f0 1f 00 29 	mcall	80006d04 <xQueueGenericSend+0xe0>
80006c64:	58 1c       	cp.w	r12,1
80006c66:	c0 21       	brne	80006c6a <xQueueGenericSend+0x46>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
80006c68:	d7 33       	scall
					}
				}

				taskEXIT_CRITICAL();
80006c6a:	f0 1f 00 28 	mcall	80006d08 <xQueueGenericSend+0xe4>
80006c6e:	30 1c       	mov	r12,1

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
80006c70:	c4 38       	rjmp	80006cf6 <xQueueGenericSend+0xd2>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
80006c72:	40 28       	lddsp	r8,sp[0x8]
80006c74:	58 08       	cp.w	r8,0
80006c76:	c0 51       	brne	80006c80 <xQueueGenericSend+0x5c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80006c78:	f0 1f 00 24 	mcall	80006d08 <xQueueGenericSend+0xe4>
80006c7c:	30 0c       	mov	r12,0

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
80006c7e:	c3 c8       	rjmp	80006cf6 <xQueueGenericSend+0xd2>
				}
				else if( xEntryTimeSet == pdFALSE )
80006c80:	58 04       	cp.w	r4,0
80006c82:	c0 51       	brne	80006c8c <xQueueGenericSend+0x68>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80006c84:	06 9c       	mov	r12,r3
80006c86:	f0 1f 00 22 	mcall	80006d0c <xQueueGenericSend+0xe8>
80006c8a:	30 14       	mov	r4,1
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80006c8c:	f0 1f 00 1f 	mcall	80006d08 <xQueueGenericSend+0xe4>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80006c90:	f0 1f 00 20 	mcall	80006d10 <xQueueGenericSend+0xec>
		prvLockQueue( pxQueue );
80006c94:	f0 1f 00 1a 	mcall	80006cfc <xQueueGenericSend+0xd8>
80006c98:	6f 18       	ld.w	r8,r7[0x44]
80006c9a:	5b f8       	cp.w	r8,-1
80006c9c:	ef f1 0a 11 	st.weq	r7[0x44],r1
80006ca0:	6f 28       	ld.w	r8,r7[0x48]
80006ca2:	5b f8       	cp.w	r8,-1
80006ca4:	ef f1 0a 12 	st.weq	r7[0x48],r1
80006ca8:	f0 1f 00 18 	mcall	80006d08 <xQueueGenericSend+0xe4>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80006cac:	04 9b       	mov	r11,r2
80006cae:	06 9c       	mov	r12,r3
80006cb0:	f0 1f 00 19 	mcall	80006d14 <xQueueGenericSend+0xf0>
80006cb4:	c1 b1       	brne	80006cea <xQueueGenericSend+0xc6>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
80006cb6:	f0 1f 00 12 	mcall	80006cfc <xQueueGenericSend+0xd8>
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
80006cba:	6e e5       	ld.w	r5,r7[0x38]
80006cbc:	6e f6       	ld.w	r6,r7[0x3c]
	taskEXIT_CRITICAL();
80006cbe:	f0 1f 00 13 	mcall	80006d08 <xQueueGenericSend+0xe4>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
80006cc2:	0c 35       	cp.w	r5,r6
80006cc4:	c0 d1       	brne	80006cde <xQueueGenericSend+0xba>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
80006cc6:	40 2b       	lddsp	r11,sp[0x8]
80006cc8:	00 9c       	mov	r12,r0
80006cca:	f0 1f 00 14 	mcall	80006d18 <xQueueGenericSend+0xf4>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
80006cce:	0e 9c       	mov	r12,r7
80006cd0:	f0 1f 00 13 	mcall	80006d1c <xQueueGenericSend+0xf8>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
80006cd4:	f0 1f 00 13 	mcall	80006d20 <xQueueGenericSend+0xfc>
80006cd8:	cb 41       	brne	80006c40 <xQueueGenericSend+0x1c>
				{
					portYIELD_WITHIN_API();
80006cda:	d7 33       	scall
80006cdc:	cb 2b       	rjmp	80006c40 <xQueueGenericSend+0x1c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
80006cde:	0e 9c       	mov	r12,r7
80006ce0:	f0 1f 00 0f 	mcall	80006d1c <xQueueGenericSend+0xf8>
				( void ) xTaskResumeAll();
80006ce4:	f0 1f 00 0f 	mcall	80006d20 <xQueueGenericSend+0xfc>
80006ce8:	ca cb       	rjmp	80006c40 <xQueueGenericSend+0x1c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
80006cea:	0e 9c       	mov	r12,r7
80006cec:	f0 1f 00 0c 	mcall	80006d1c <xQueueGenericSend+0xf8>
			( void ) xTaskResumeAll();
80006cf0:	f0 1f 00 0c 	mcall	80006d20 <xQueueGenericSend+0xfc>
80006cf4:	30 0c       	mov	r12,0
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
80006cf6:	2f bd       	sub	sp,-20
80006cf8:	d8 32       	popm	r0-r7,pc
80006cfa:	00 00       	add	r0,r0
80006cfc:	80 00       	ld.sh	r0,r0[0x0]
80006cfe:	66 64       	ld.w	r4,r3[0x18]
80006d00:	80 00       	ld.sh	r0,r0[0x0]
80006d02:	6b 5c       	ld.w	r12,r5[0x54]
80006d04:	80 00       	ld.sh	r0,r0[0x0]
80006d06:	6f 88       	ld.w	r8,r7[0x60]
80006d08:	80 00       	ld.sh	r0,r0[0x0]
80006d0a:	67 70       	ld.w	r0,r3[0x5c]
80006d0c:	80 00       	ld.sh	r0,r0[0x0]
80006d0e:	6e 7c       	ld.w	r12,r7[0x1c]
80006d10:	80 00       	ld.sh	r0,r0[0x0]
80006d12:	6d f0       	ld.w	r0,r6[0x7c]
80006d14:	80 00       	ld.sh	r0,r0[0x0]
80006d16:	71 18       	ld.w	r8,r8[0x44]
80006d18:	80 00       	ld.sh	r0,r0[0x0]
80006d1a:	73 b8       	ld.w	r8,r9[0x6c]
80006d1c:	80 00       	ld.sh	r0,r0[0x0]
80006d1e:	69 78       	ld.w	r8,r4[0x5c]
80006d20:	80 00       	ld.sh	r0,r0[0x0]
80006d22:	71 ac       	ld.w	r12,r8[0x68]

80006d24 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	xQueueHandle xQueueCreateMutex( void )
	{
80006d24:	eb cd 40 c0 	pushm	r6-r7,lr
	xQUEUE *pxNewQueue;

		/* Allocate the new queue structure. */
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
80006d28:	34 cc       	mov	r12,76
80006d2a:	f0 1f 00 12 	mcall	80006d70 <xQueueCreateMutex+0x4c>
80006d2e:	18 97       	mov	r7,r12
		if( pxNewQueue != NULL )
80006d30:	c1 d0       	breq	80006d6a <xQueueCreateMutex+0x46>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
80006d32:	30 06       	mov	r6,0
80006d34:	99 16       	st.w	r12[0x4],r6
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
80006d36:	99 06       	st.w	r12[0x0],r6

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
80006d38:	99 26       	st.w	r12[0x8],r6
			pxNewQueue->pcReadFrom = NULL;
80006d3a:	99 36       	st.w	r12[0xc],r6

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
80006d3c:	99 e6       	st.w	r12[0x38],r6
			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
80006d3e:	30 18       	mov	r8,1
80006d40:	99 f8       	st.w	r12[0x3c],r8
			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
80006d42:	f9 46 00 40 	st.w	r12[64],r6
			pxNewQueue->xRxLock = queueUNLOCKED;
80006d46:	3f f8       	mov	r8,-1
80006d48:	f9 48 00 44 	st.w	r12[68],r8
			pxNewQueue->xTxLock = queueUNLOCKED;
80006d4c:	f9 48 00 48 	st.w	r12[72],r8

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
80006d50:	2f 0c       	sub	r12,-16
80006d52:	f0 1f 00 09 	mcall	80006d74 <xQueueCreateMutex+0x50>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
80006d56:	ee cc ff dc 	sub	r12,r7,-36
80006d5a:	f0 1f 00 07 	mcall	80006d74 <xQueueCreateMutex+0x50>

			/* Start with the semaphore in the expected state. */
			xQueueGenericSend( pxNewQueue, NULL, ( portTickType ) 0U, queueSEND_TO_BACK );
80006d5e:	0c 99       	mov	r9,r6
80006d60:	0c 9a       	mov	r10,r6
80006d62:	0c 9b       	mov	r11,r6
80006d64:	0e 9c       	mov	r12,r7
80006d66:	f0 1f 00 05 	mcall	80006d78 <xQueueCreateMutex+0x54>
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
80006d6a:	0e 9c       	mov	r12,r7
80006d6c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006d70:	80 00       	ld.sh	r0,r0[0x0]
80006d72:	68 d0       	ld.w	r0,r4[0x34]
80006d74:	80 00       	ld.sh	r0,r0[0x0]
80006d76:	65 40       	ld.w	r0,r2[0x50]
80006d78:	80 00       	ld.sh	r0,r0[0x0]
80006d7a:	6c 24       	ld.w	r4,r6[0x8]

80006d7c <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
80006d7c:	d4 21       	pushm	r4-r7,lr
80006d7e:	18 97       	mov	r7,r12
80006d80:	16 96       	mov	r6,r11
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
80006d82:	58 0c       	cp.w	r12,0
80006d84:	c2 f0       	breq	80006de2 <xQueueCreate+0x66>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
80006d86:	34 cc       	mov	r12,76
80006d88:	f0 1f 00 17 	mcall	80006de4 <xQueueCreate+0x68>
80006d8c:	18 95       	mov	r5,r12
		if( pxNewQueue != NULL )
80006d8e:	c2 a0       	breq	80006de2 <xQueueCreate+0x66>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
80006d90:	ec 07 02 44 	mul	r4,r6,r7

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
80006d94:	e8 cc ff ff 	sub	r12,r4,-1
80006d98:	f0 1f 00 13 	mcall	80006de4 <xQueueCreate+0x68>
80006d9c:	8b 0c       	st.w	r5[0x0],r12
			if( pxNewQueue->pcHead != NULL )
80006d9e:	c1 e0       	breq	80006dda <xQueueCreate+0x5e>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
80006da0:	f8 04 00 04 	add	r4,r12,r4
80006da4:	8b 14       	st.w	r5[0x4],r4
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
80006da6:	30 08       	mov	r8,0
80006da8:	8b e8       	st.w	r5[0x38],r8
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
80006daa:	8b 2c       	st.w	r5[0x8],r12
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
80006dac:	ee c8 00 01 	sub	r8,r7,1
80006db0:	ad 38       	mul	r8,r6
80006db2:	10 0c       	add	r12,r8
80006db4:	8b 3c       	st.w	r5[0xc],r12
				pxNewQueue->uxLength = uxQueueLength;
80006db6:	8b f7       	st.w	r5[0x3c],r7
				pxNewQueue->uxItemSize = uxItemSize;
80006db8:	eb 46 00 40 	st.w	r5[64],r6
				pxNewQueue->xRxLock = queueUNLOCKED;
80006dbc:	3f f8       	mov	r8,-1
80006dbe:	eb 48 00 44 	st.w	r5[68],r8
				pxNewQueue->xTxLock = queueUNLOCKED;
80006dc2:	eb 48 00 48 	st.w	r5[72],r8

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
80006dc6:	ea cc ff f0 	sub	r12,r5,-16
80006dca:	f0 1f 00 08 	mcall	80006de8 <xQueueCreate+0x6c>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
80006dce:	ea cc ff dc 	sub	r12,r5,-36
80006dd2:	f0 1f 00 06 	mcall	80006de8 <xQueueCreate+0x6c>
80006dd6:	0a 9c       	mov	r12,r5
80006dd8:	d8 22       	popm	r4-r7,pc
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
80006dda:	0a 9c       	mov	r12,r5
80006ddc:	f0 1f 00 04 	mcall	80006dec <xQueueCreate+0x70>
80006de0:	d8 2a       	popm	r4-r7,pc,r12=0
80006de2:	d8 2a       	popm	r4-r7,pc,r12=0
80006de4:	80 00       	ld.sh	r0,r0[0x0]
80006de6:	68 d0       	ld.w	r0,r4[0x34]
80006de8:	80 00       	ld.sh	r0,r0[0x0]
80006dea:	65 40       	ld.w	r0,r2[0x50]
80006dec:	80 00       	ld.sh	r0,r0[0x0]
80006dee:	68 a8       	ld.w	r8,r4[0x28]

80006df0 <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
80006df0:	48 38       	lddpc	r8,80006dfc <vTaskSuspendAll+0xc>
80006df2:	70 09       	ld.w	r9,r8[0x0]
80006df4:	2f f9       	sub	r9,-1
80006df6:	91 09       	st.w	r8[0x0],r9
}
80006df8:	5e fc       	retal	r12
80006dfa:	00 00       	add	r0,r0
80006dfc:	00 00       	add	r0,r0
80006dfe:	0d 8c       	ld.ub	r12,r6[0x0]

80006e00 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
80006e00:	49 a8       	lddpc	r8,80006e68 <vTaskSwitchContext+0x68>
80006e02:	70 08       	ld.w	r8,r8[0x0]
80006e04:	58 08       	cp.w	r8,0
80006e06:	c0 b1       	brne	80006e1c <vTaskSwitchContext+0x1c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80006e08:	49 98       	lddpc	r8,80006e6c <vTaskSwitchContext+0x6c>
80006e0a:	70 08       	ld.w	r8,r8[0x0]
80006e0c:	f0 08 00 28 	add	r8,r8,r8<<0x2
80006e10:	49 89       	lddpc	r9,80006e70 <vTaskSwitchContext+0x70>
80006e12:	f2 08 03 28 	ld.w	r8,r9[r8<<0x2]
80006e16:	58 08       	cp.w	r8,0
80006e18:	c0 60       	breq	80006e24 <vTaskSwitchContext+0x24>
80006e1a:	c1 18       	rjmp	80006e3c <vTaskSwitchContext+0x3c>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
80006e1c:	30 19       	mov	r9,1
80006e1e:	49 68       	lddpc	r8,80006e74 <vTaskSwitchContext+0x74>
80006e20:	91 09       	st.w	r8[0x0],r9
80006e22:	5e fc       	retal	r12

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
80006e24:	49 28       	lddpc	r8,80006e6c <vTaskSwitchContext+0x6c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80006e26:	49 3a       	lddpc	r10,80006e70 <vTaskSwitchContext+0x70>
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
80006e28:	70 09       	ld.w	r9,r8[0x0]
80006e2a:	20 19       	sub	r9,1
80006e2c:	91 09       	st.w	r8[0x0],r9

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80006e2e:	70 09       	ld.w	r9,r8[0x0]
80006e30:	f2 09 00 29 	add	r9,r9,r9<<0x2
80006e34:	f4 09 03 29 	ld.w	r9,r10[r9<<0x2]
80006e38:	58 09       	cp.w	r9,0
80006e3a:	cf 70       	breq	80006e28 <vTaskSwitchContext+0x28>
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
80006e3c:	48 c8       	lddpc	r8,80006e6c <vTaskSwitchContext+0x6c>
80006e3e:	70 08       	ld.w	r8,r8[0x0]
80006e40:	f0 08 00 28 	add	r8,r8,r8<<0x2
80006e44:	48 b9       	lddpc	r9,80006e70 <vTaskSwitchContext+0x70>
80006e46:	f2 08 00 28 	add	r8,r9,r8<<0x2
80006e4a:	70 19       	ld.w	r9,r8[0x4]
80006e4c:	72 19       	ld.w	r9,r9[0x4]
80006e4e:	91 19       	st.w	r8[0x4],r9
80006e50:	f0 ca ff f8 	sub	r10,r8,-8
80006e54:	14 39       	cp.w	r9,r10
80006e56:	f3 f9 00 01 	ld.weq	r9,r9[0x4]
80006e5a:	f1 f9 0a 01 	st.weq	r8[0x4],r9
80006e5e:	70 18       	ld.w	r8,r8[0x4]
80006e60:	70 39       	ld.w	r9,r8[0xc]
80006e62:	48 68       	lddpc	r8,80006e78 <vTaskSwitchContext+0x78>
80006e64:	91 09       	st.w	r8[0x0],r9
80006e66:	5e fc       	retal	r12
80006e68:	00 00       	add	r0,r0
80006e6a:	0d 8c       	ld.ub	r12,r6[0x0]
80006e6c:	00 00       	add	r0,r0
80006e6e:	0d c4       	ld.ub	r4,r6[0x4]
80006e70:	00 00       	add	r0,r0
80006e72:	0c a8       	st.w	r6++,r8
80006e74:	00 00       	add	r0,r0
80006e76:	0d ac       	ld.ub	r12,r6[0x2]
80006e78:	00 00       	add	r0,r0
80006e7a:	0d 5c       	ld.sh	r12,--r6

80006e7c <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
80006e7c:	48 48       	lddpc	r8,80006e8c <vTaskSetTimeOutState+0x10>
80006e7e:	70 08       	ld.w	r8,r8[0x0]
80006e80:	99 08       	st.w	r12[0x0],r8
	pxTimeOut->xTimeOnEntering = xTickCount;
80006e82:	48 48       	lddpc	r8,80006e90 <vTaskSetTimeOutState+0x14>
80006e84:	70 08       	ld.w	r8,r8[0x0]
80006e86:	99 18       	st.w	r12[0x4],r8
}
80006e88:	5e fc       	retal	r12
80006e8a:	00 00       	add	r0,r0
80006e8c:	00 00       	add	r0,r0
80006e8e:	0c a0       	st.w	r6++,r0
80006e90:	00 00       	add	r0,r0
80006e92:	0d 88       	ld.ub	r8,r6[0x0]

80006e94 <vTaskMissedYield>:
}
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
80006e94:	30 19       	mov	r9,1
80006e96:	48 28       	lddpc	r8,80006e9c <vTaskMissedYield+0x8>
80006e98:	91 09       	st.w	r8[0x0],r9
}
80006e9a:	5e fc       	retal	r12
80006e9c:	00 00       	add	r0,r0
80006e9e:	0d ac       	ld.ub	r12,r6[0x2]

80006ea0 <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
80006ea0:	48 28       	lddpc	r8,80006ea8 <xTaskGetCurrentTaskHandle+0x8>
80006ea2:	70 0c       	ld.w	r12,r8[0x0]

		return xReturn;
	}
80006ea4:	5e fc       	retal	r12
80006ea6:	00 00       	add	r0,r0
80006ea8:	00 00       	add	r0,r0
80006eaa:	0d 5c       	ld.sh	r12,--r6

80006eac <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
80006eac:	eb cd 40 c0 	pushm	r6-r7,lr
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
80006eb0:	58 0c       	cp.w	r12,0
80006eb2:	c1 f0       	breq	80006ef0 <vTaskPriorityDisinherit+0x44>

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
80006eb4:	18 97       	mov	r7,r12

		if( pxMutexHolder != NULL )
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
80006eb6:	78 b9       	ld.w	r9,r12[0x2c]
80006eb8:	79 18       	ld.w	r8,r12[0x44]
80006eba:	10 39       	cp.w	r9,r8
80006ebc:	c1 a0       	breq	80006ef0 <vTaskPriorityDisinherit+0x44>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
80006ebe:	f8 c6 ff fc 	sub	r6,r12,-4
80006ec2:	0c 9c       	mov	r12,r6
80006ec4:	f0 1f 00 0c 	mcall	80006ef4 <vTaskPriorityDisinherit+0x48>

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
80006ec8:	6f 1c       	ld.w	r12,r7[0x44]
80006eca:	8f bc       	st.w	r7[0x2c],r12
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
80006ecc:	f8 08 11 08 	rsub	r8,r12,8
80006ed0:	8f 68       	st.w	r7[0x18],r8
				prvAddTaskToReadyQueue( pxTCB );
80006ed2:	48 a8       	lddpc	r8,80006ef8 <vTaskPriorityDisinherit+0x4c>
80006ed4:	70 08       	ld.w	r8,r8[0x0]
80006ed6:	10 3c       	cp.w	r12,r8
80006ed8:	e0 88 00 04 	brls	80006ee0 <vTaskPriorityDisinherit+0x34>
80006edc:	48 78       	lddpc	r8,80006ef8 <vTaskPriorityDisinherit+0x4c>
80006ede:	91 0c       	st.w	r8[0x0],r12
80006ee0:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006ee4:	0c 9b       	mov	r11,r6
80006ee6:	48 68       	lddpc	r8,80006efc <vTaskPriorityDisinherit+0x50>
80006ee8:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80006eec:	f0 1f 00 05 	mcall	80006f00 <vTaskPriorityDisinherit+0x54>
80006ef0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006ef4:	80 00       	ld.sh	r0,r0[0x0]
80006ef6:	65 aa       	ld.w	r10,r2[0x68]
80006ef8:	00 00       	add	r0,r0
80006efa:	0d c4       	ld.ub	r4,r6[0x4]
80006efc:	00 00       	add	r0,r0
80006efe:	0c a8       	st.w	r6++,r8
80006f00:	80 00       	ld.sh	r0,r0[0x0]
80006f02:	65 5a       	ld.w	r10,r2[0x54]

80006f04 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
80006f04:	eb cd 40 c0 	pushm	r6-r7,lr
80006f08:	18 97       	mov	r7,r12
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
80006f0a:	49 b8       	lddpc	r8,80006f74 <vTaskPriorityInherit+0x70>
80006f0c:	70 08       	ld.w	r8,r8[0x0]
80006f0e:	78 b9       	ld.w	r9,r12[0x2c]
80006f10:	70 b8       	ld.w	r8,r8[0x2c]
80006f12:	10 39       	cp.w	r9,r8
80006f14:	c2 d2       	brcc	80006f6e <vTaskPriorityInherit+0x6a>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
80006f16:	49 88       	lddpc	r8,80006f74 <vTaskPriorityInherit+0x70>
80006f18:	70 08       	ld.w	r8,r8[0x0]
80006f1a:	70 b8       	ld.w	r8,r8[0x2c]
80006f1c:	f0 08 11 08 	rsub	r8,r8,8
80006f20:	99 68       	st.w	r12[0x18],r8

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
80006f22:	f2 09 00 28 	add	r8,r9,r9<<0x2
80006f26:	49 59       	lddpc	r9,80006f78 <vTaskPriorityInherit+0x74>
80006f28:	f2 08 00 28 	add	r8,r9,r8<<0x2
80006f2c:	78 59       	ld.w	r9,r12[0x14]
80006f2e:	10 39       	cp.w	r9,r8
80006f30:	c1 b1       	brne	80006f66 <vTaskPriorityInherit+0x62>
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
80006f32:	f8 c6 ff fc 	sub	r6,r12,-4
80006f36:	0c 9c       	mov	r12,r6
80006f38:	f0 1f 00 11 	mcall	80006f7c <vTaskPriorityInherit+0x78>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
80006f3c:	48 e8       	lddpc	r8,80006f74 <vTaskPriorityInherit+0x70>
80006f3e:	70 08       	ld.w	r8,r8[0x0]
80006f40:	70 bc       	ld.w	r12,r8[0x2c]
80006f42:	8f bc       	st.w	r7[0x2c],r12
				prvAddTaskToReadyQueue( pxTCB );
80006f44:	48 f8       	lddpc	r8,80006f80 <vTaskPriorityInherit+0x7c>
80006f46:	70 08       	ld.w	r8,r8[0x0]
80006f48:	10 3c       	cp.w	r12,r8
80006f4a:	e0 88 00 04 	brls	80006f52 <vTaskPriorityInherit+0x4e>
80006f4e:	48 d8       	lddpc	r8,80006f80 <vTaskPriorityInherit+0x7c>
80006f50:	91 0c       	st.w	r8[0x0],r12
80006f52:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006f56:	0c 9b       	mov	r11,r6
80006f58:	48 88       	lddpc	r8,80006f78 <vTaskPriorityInherit+0x74>
80006f5a:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80006f5e:	f0 1f 00 0a 	mcall	80006f84 <vTaskPriorityInherit+0x80>
80006f62:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
80006f66:	48 48       	lddpc	r8,80006f74 <vTaskPriorityInherit+0x70>
80006f68:	70 08       	ld.w	r8,r8[0x0]
80006f6a:	70 b8       	ld.w	r8,r8[0x2c]
80006f6c:	99 b8       	st.w	r12[0x2c],r8
80006f6e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006f72:	00 00       	add	r0,r0
80006f74:	00 00       	add	r0,r0
80006f76:	0d 5c       	ld.sh	r12,--r6
80006f78:	00 00       	add	r0,r0
80006f7a:	0c a8       	st.w	r6++,r8
80006f7c:	80 00       	ld.sh	r0,r0[0x0]
80006f7e:	65 aa       	ld.w	r10,r2[0x68]
80006f80:	00 00       	add	r0,r0
80006f82:	0d c4       	ld.ub	r4,r6[0x4]
80006f84:	80 00       	ld.sh	r0,r0[0x0]
80006f86:	65 5a       	ld.w	r10,r2[0x54]

80006f88 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
80006f88:	eb cd 40 c0 	pushm	r6-r7,lr
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
80006f8c:	78 38       	ld.w	r8,r12[0xc]
80006f8e:	70 37       	ld.w	r7,r8[0xc]
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
80006f90:	ee c6 ff e8 	sub	r6,r7,-24
80006f94:	0c 9c       	mov	r12,r6
80006f96:	f0 1f 00 15 	mcall	80006fe8 <xTaskRemoveFromEventList+0x60>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80006f9a:	49 58       	lddpc	r8,80006fec <xTaskRemoveFromEventList+0x64>
80006f9c:	70 08       	ld.w	r8,r8[0x0]
80006f9e:	58 08       	cp.w	r8,0
80006fa0:	c1 71       	brne	80006fce <xTaskRemoveFromEventList+0x46>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
80006fa2:	ee c6 ff fc 	sub	r6,r7,-4
80006fa6:	0c 9c       	mov	r12,r6
80006fa8:	f0 1f 00 10 	mcall	80006fe8 <xTaskRemoveFromEventList+0x60>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
80006fac:	6e bc       	ld.w	r12,r7[0x2c]
80006fae:	49 18       	lddpc	r8,80006ff0 <xTaskRemoveFromEventList+0x68>
80006fb0:	70 08       	ld.w	r8,r8[0x0]
80006fb2:	10 3c       	cp.w	r12,r8
80006fb4:	e0 88 00 04 	brls	80006fbc <xTaskRemoveFromEventList+0x34>
80006fb8:	48 e8       	lddpc	r8,80006ff0 <xTaskRemoveFromEventList+0x68>
80006fba:	91 0c       	st.w	r8[0x0],r12
80006fbc:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006fc0:	0c 9b       	mov	r11,r6
80006fc2:	48 d8       	lddpc	r8,80006ff4 <xTaskRemoveFromEventList+0x6c>
80006fc4:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80006fc8:	f0 1f 00 0c 	mcall	80006ff8 <xTaskRemoveFromEventList+0x70>
80006fcc:	c0 58       	rjmp	80006fd6 <xTaskRemoveFromEventList+0x4e>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
80006fce:	0c 9b       	mov	r11,r6
80006fd0:	48 bc       	lddpc	r12,80006ffc <xTaskRemoveFromEventList+0x74>
80006fd2:	f0 1f 00 0a 	mcall	80006ff8 <xTaskRemoveFromEventList+0x70>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
80006fd6:	48 b8       	lddpc	r8,80007000 <xTaskRemoveFromEventList+0x78>
80006fd8:	70 08       	ld.w	r8,r8[0x0]
80006fda:	6e b9       	ld.w	r9,r7[0x2c]
80006fdc:	70 b8       	ld.w	r8,r8[0x2c]
80006fde:	10 39       	cp.w	r9,r8
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
80006fe0:	5f 2c       	srhs	r12
80006fe2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006fe6:	00 00       	add	r0,r0
80006fe8:	80 00       	ld.sh	r0,r0[0x0]
80006fea:	65 aa       	ld.w	r10,r2[0x68]
80006fec:	00 00       	add	r0,r0
80006fee:	0d 8c       	ld.ub	r12,r6[0x0]
80006ff0:	00 00       	add	r0,r0
80006ff2:	0d c4       	ld.ub	r4,r6[0x4]
80006ff4:	00 00       	add	r0,r0
80006ff6:	0c a8       	st.w	r6++,r8
80006ff8:	80 00       	ld.sh	r0,r0[0x0]
80006ffa:	65 5a       	ld.w	r10,r2[0x54]
80006ffc:	00 00       	add	r0,r0
80006ffe:	0d 60       	ld.uh	r0,--r6
80007000:	00 00       	add	r0,r0
80007002:	0d 5c       	ld.sh	r12,--r6

80007004 <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
80007004:	eb cd 40 fc 	pushm	r2-r7,lr
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80007008:	4b 98       	lddpc	r8,800070ec <vTaskIncrementTick+0xe8>
8000700a:	70 08       	ld.w	r8,r8[0x0]
8000700c:	58 08       	cp.w	r8,0
8000700e:	c6 91       	brne	800070e0 <vTaskIncrementTick+0xdc>
	{
		++xTickCount;
80007010:	4b 88       	lddpc	r8,800070f0 <vTaskIncrementTick+0xec>
80007012:	70 09       	ld.w	r9,r8[0x0]
80007014:	2f f9       	sub	r9,-1
80007016:	91 09       	st.w	r8[0x0],r9
		if( xTickCount == ( portTickType ) 0 )
80007018:	70 08       	ld.w	r8,r8[0x0]
8000701a:	58 08       	cp.w	r8,0
8000701c:	c1 a1       	brne	80007050 <vTaskIncrementTick+0x4c>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
8000701e:	4b 68       	lddpc	r8,800070f4 <vTaskIncrementTick+0xf0>
80007020:	70 0a       	ld.w	r10,r8[0x0]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
80007022:	4b 69       	lddpc	r9,800070f8 <vTaskIncrementTick+0xf4>
80007024:	72 0b       	ld.w	r11,r9[0x0]
80007026:	91 0b       	st.w	r8[0x0],r11
			pxOverflowDelayedTaskList = pxTemp;
80007028:	93 0a       	st.w	r9[0x0],r10
			xNumOfOverflows++;
8000702a:	4b 59       	lddpc	r9,800070fc <vTaskIncrementTick+0xf8>
8000702c:	72 0a       	ld.w	r10,r9[0x0]
8000702e:	2f fa       	sub	r10,-1
80007030:	93 0a       	st.w	r9[0x0],r10

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
80007032:	70 08       	ld.w	r8,r8[0x0]
80007034:	70 08       	ld.w	r8,r8[0x0]
80007036:	58 08       	cp.w	r8,0
80007038:	c0 51       	brne	80007042 <vTaskIncrementTick+0x3e>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
8000703a:	3f f9       	mov	r9,-1
8000703c:	4b 18       	lddpc	r8,80007100 <vTaskIncrementTick+0xfc>
8000703e:	91 09       	st.w	r8[0x0],r9
80007040:	c0 88       	rjmp	80007050 <vTaskIncrementTick+0x4c>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
80007042:	4a d8       	lddpc	r8,800070f4 <vTaskIncrementTick+0xf0>
80007044:	70 08       	ld.w	r8,r8[0x0]
80007046:	70 38       	ld.w	r8,r8[0xc]
80007048:	70 38       	ld.w	r8,r8[0xc]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
8000704a:	70 19       	ld.w	r9,r8[0x4]
8000704c:	4a d8       	lddpc	r8,80007100 <vTaskIncrementTick+0xfc>
8000704e:	91 09       	st.w	r8[0x0],r9
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
80007050:	4a 88       	lddpc	r8,800070f0 <vTaskIncrementTick+0xec>
80007052:	70 09       	ld.w	r9,r8[0x0]
80007054:	4a b8       	lddpc	r8,80007100 <vTaskIncrementTick+0xfc>
80007056:	70 08       	ld.w	r8,r8[0x0]
80007058:	10 39       	cp.w	r9,r8
8000705a:	c4 73       	brcs	800070e8 <vTaskIncrementTick+0xe4>
8000705c:	4a 68       	lddpc	r8,800070f4 <vTaskIncrementTick+0xf0>
8000705e:	70 08       	ld.w	r8,r8[0x0]
80007060:	70 08       	ld.w	r8,r8[0x0]
80007062:	58 08       	cp.w	r8,0
80007064:	c0 c0       	breq	8000707c <vTaskIncrementTick+0x78>
80007066:	4a 48       	lddpc	r8,800070f4 <vTaskIncrementTick+0xf0>
80007068:	70 08       	ld.w	r8,r8[0x0]
8000706a:	70 38       	ld.w	r8,r8[0xc]
8000706c:	70 37       	ld.w	r7,r8[0xc]
8000706e:	6e 18       	ld.w	r8,r7[0x4]
80007070:	4a 09       	lddpc	r9,800070f0 <vTaskIncrementTick+0xec>
80007072:	72 09       	ld.w	r9,r9[0x0]
80007074:	12 38       	cp.w	r8,r9
80007076:	e0 88 00 14 	brls	8000709e <vTaskIncrementTick+0x9a>
8000707a:	c0 e8       	rjmp	80007096 <vTaskIncrementTick+0x92>
8000707c:	3f f9       	mov	r9,-1
8000707e:	4a 18       	lddpc	r8,80007100 <vTaskIncrementTick+0xfc>
80007080:	91 09       	st.w	r8[0x0],r9
80007082:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80007086:	6a 08       	ld.w	r8,r5[0x0]
80007088:	70 38       	ld.w	r8,r8[0xc]
8000708a:	70 37       	ld.w	r7,r8[0xc]
8000708c:	6e 18       	ld.w	r8,r7[0x4]
8000708e:	64 09       	ld.w	r9,r2[0x0]
80007090:	12 38       	cp.w	r8,r9
80007092:	e0 88 00 0a 	brls	800070a6 <vTaskIncrementTick+0xa2>
80007096:	49 b9       	lddpc	r9,80007100 <vTaskIncrementTick+0xfc>
80007098:	93 08       	st.w	r9[0x0],r8
8000709a:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
8000709e:	49 a4       	lddpc	r4,80007104 <vTaskIncrementTick+0x100>
800070a0:	49 a3       	lddpc	r3,80007108 <vTaskIncrementTick+0x104>
800070a2:	49 55       	lddpc	r5,800070f4 <vTaskIncrementTick+0xf0>
800070a4:	49 32       	lddpc	r2,800070f0 <vTaskIncrementTick+0xec>
800070a6:	ee c6 ff fc 	sub	r6,r7,-4
800070aa:	0c 9c       	mov	r12,r6
800070ac:	f0 1f 00 18 	mcall	8000710c <vTaskIncrementTick+0x108>
800070b0:	6e a8       	ld.w	r8,r7[0x28]
800070b2:	58 08       	cp.w	r8,0
800070b4:	c0 50       	breq	800070be <vTaskIncrementTick+0xba>
800070b6:	ee cc ff e8 	sub	r12,r7,-24
800070ba:	f0 1f 00 15 	mcall	8000710c <vTaskIncrementTick+0x108>
800070be:	6e bc       	ld.w	r12,r7[0x2c]
800070c0:	68 08       	ld.w	r8,r4[0x0]
800070c2:	10 3c       	cp.w	r12,r8
800070c4:	e9 fc ba 00 	st.whi	r4[0x0],r12
800070c8:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800070cc:	0c 9b       	mov	r11,r6
800070ce:	e6 0c 00 2c 	add	r12,r3,r12<<0x2
800070d2:	f0 1f 00 10 	mcall	80007110 <vTaskIncrementTick+0x10c>
800070d6:	6a 08       	ld.w	r8,r5[0x0]
800070d8:	70 08       	ld.w	r8,r8[0x0]
800070da:	58 08       	cp.w	r8,0
800070dc:	cd 51       	brne	80007086 <vTaskIncrementTick+0x82>
800070de:	cc fb       	rjmp	8000707c <vTaskIncrementTick+0x78>
	}
	else
	{
		++uxMissedTicks;
800070e0:	48 d8       	lddpc	r8,80007114 <vTaskIncrementTick+0x110>
800070e2:	70 09       	ld.w	r9,r8[0x0]
800070e4:	2f f9       	sub	r9,-1
800070e6:	91 09       	st.w	r8[0x0],r9
800070e8:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
800070ec:	00 00       	add	r0,r0
800070ee:	0d 8c       	ld.ub	r12,r6[0x0]
800070f0:	00 00       	add	r0,r0
800070f2:	0d 88       	ld.ub	r8,r6[0x0]
800070f4:	00 00       	add	r0,r0
800070f6:	0c 94       	mov	r4,r6
800070f8:	00 00       	add	r0,r0
800070fa:	0c a4       	st.w	r6++,r4
800070fc:	00 00       	add	r0,r0
800070fe:	0c a0       	st.w	r6++,r0
80007100:	00 00       	add	r0,r0
80007102:	05 48       	ld.w	r8,--r2
80007104:	00 00       	add	r0,r0
80007106:	0d c4       	ld.ub	r4,r6[0x4]
80007108:	00 00       	add	r0,r0
8000710a:	0c a8       	st.w	r6++,r8
8000710c:	80 00       	ld.sh	r0,r0[0x0]
8000710e:	65 aa       	ld.w	r10,r2[0x68]
80007110:	80 00       	ld.sh	r0,r0[0x0]
80007112:	65 5a       	ld.w	r10,r2[0x54]
80007114:	00 00       	add	r0,r0
80007116:	0c 8c       	andn	r12,r6

80007118 <xTaskCheckForTimeOut>:
	pxTimeOut->xTimeOnEntering = xTickCount;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
80007118:	eb cd 40 c0 	pushm	r6-r7,lr
8000711c:	18 97       	mov	r7,r12
8000711e:	16 96       	mov	r6,r11
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
80007120:	f0 1f 00 15 	mcall	80007174 <xTaskCheckForTimeOut+0x5c>
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
80007124:	6c 08       	ld.w	r8,r6[0x0]
80007126:	5b f8       	cp.w	r8,-1
80007128:	c0 31       	brne	8000712e <xTaskCheckForTimeOut+0x16>
8000712a:	30 07       	mov	r7,0
8000712c:	c1 f8       	rjmp	8000716a <xTaskCheckForTimeOut+0x52>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
8000712e:	49 39       	lddpc	r9,80007178 <xTaskCheckForTimeOut+0x60>
80007130:	72 09       	ld.w	r9,r9[0x0]
80007132:	6e 0a       	ld.w	r10,r7[0x0]
80007134:	12 3a       	cp.w	r10,r9
80007136:	c0 70       	breq	80007144 <xTaskCheckForTimeOut+0x2c>
80007138:	49 19       	lddpc	r9,8000717c <xTaskCheckForTimeOut+0x64>
8000713a:	72 09       	ld.w	r9,r9[0x0]
8000713c:	6e 1a       	ld.w	r10,r7[0x4]
8000713e:	12 3a       	cp.w	r10,r9
80007140:	e0 88 00 14 	brls	80007168 <xTaskCheckForTimeOut+0x50>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
80007144:	48 e9       	lddpc	r9,8000717c <xTaskCheckForTimeOut+0x64>
80007146:	72 0a       	ld.w	r10,r9[0x0]
80007148:	6e 19       	ld.w	r9,r7[0x4]
8000714a:	12 1a       	sub	r10,r9
8000714c:	14 38       	cp.w	r8,r10
8000714e:	e0 88 00 0d 	brls	80007168 <xTaskCheckForTimeOut+0x50>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
80007152:	48 ba       	lddpc	r10,8000717c <xTaskCheckForTimeOut+0x64>
80007154:	74 0a       	ld.w	r10,r10[0x0]
80007156:	14 19       	sub	r9,r10
80007158:	f2 08 00 08 	add	r8,r9,r8
8000715c:	8d 08       	st.w	r6[0x0],r8
			vTaskSetTimeOutState( pxTimeOut );
8000715e:	0e 9c       	mov	r12,r7
80007160:	f0 1f 00 08 	mcall	80007180 <xTaskCheckForTimeOut+0x68>
80007164:	30 07       	mov	r7,0
80007166:	c0 28       	rjmp	8000716a <xTaskCheckForTimeOut+0x52>
80007168:	30 17       	mov	r7,1
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
8000716a:	f0 1f 00 07 	mcall	80007184 <xTaskCheckForTimeOut+0x6c>

	return xReturn;
}
8000716e:	0e 9c       	mov	r12,r7
80007170:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80007174:	80 00       	ld.sh	r0,r0[0x0]
80007176:	66 64       	ld.w	r4,r3[0x18]
80007178:	00 00       	add	r0,r0
8000717a:	0c a0       	st.w	r6++,r0
8000717c:	00 00       	add	r0,r0
8000717e:	0d 88       	ld.ub	r8,r6[0x0]
80007180:	80 00       	ld.sh	r0,r0[0x0]
80007182:	6e 7c       	ld.w	r12,r7[0x1c]
80007184:	80 00       	ld.sh	r0,r0[0x0]
80007186:	67 70       	ld.w	r0,r3[0x5c]

80007188 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
80007188:	eb cd 40 80 	pushm	r7,lr
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
8000718c:	f0 1f 00 05 	mcall	800071a0 <xTaskGetTickCount+0x18>
	{
		xTicks = xTickCount;
80007190:	48 58       	lddpc	r8,800071a4 <xTaskGetTickCount+0x1c>
80007192:	70 07       	ld.w	r7,r8[0x0]
	}
	taskEXIT_CRITICAL();
80007194:	f0 1f 00 05 	mcall	800071a8 <xTaskGetTickCount+0x20>

	return xTicks;
}
80007198:	0e 9c       	mov	r12,r7
8000719a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000719e:	00 00       	add	r0,r0
800071a0:	80 00       	ld.sh	r0,r0[0x0]
800071a2:	66 64       	ld.w	r4,r3[0x18]
800071a4:	00 00       	add	r0,r0
800071a6:	0d 88       	ld.ub	r8,r6[0x0]
800071a8:	80 00       	ld.sh	r0,r0[0x0]
800071aa:	67 70       	ld.w	r0,r3[0x5c]

800071ac <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
800071ac:	eb cd 40 fe 	pushm	r1-r7,lr
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
800071b0:	f0 1f 00 2c 	mcall	80007260 <xTaskResumeAll+0xb4>
	{
		--uxSchedulerSuspended;
800071b4:	4a c8       	lddpc	r8,80007264 <xTaskResumeAll+0xb8>
800071b6:	70 09       	ld.w	r9,r8[0x0]
800071b8:	20 19       	sub	r9,1
800071ba:	91 09       	st.w	r8[0x0],r9

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
800071bc:	70 08       	ld.w	r8,r8[0x0]
800071be:	58 08       	cp.w	r8,0
800071c0:	c4 91       	brne	80007252 <xTaskResumeAll+0xa6>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
800071c2:	4a a8       	lddpc	r8,80007268 <xTaskResumeAll+0xbc>
800071c4:	70 08       	ld.w	r8,r8[0x0]
800071c6:	58 08       	cp.w	r8,0
800071c8:	c4 50       	breq	80007252 <xTaskResumeAll+0xa6>
800071ca:	30 04       	mov	r4,0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
800071cc:	4a 85       	lddpc	r5,8000726c <xTaskResumeAll+0xc0>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
800071ce:	4a 93       	lddpc	r3,80007270 <xTaskResumeAll+0xc4>
800071d0:	4a 92       	lddpc	r2,80007274 <xTaskResumeAll+0xc8>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
800071d2:	4a a1       	lddpc	r1,80007278 <xTaskResumeAll+0xcc>
800071d4:	c1 e8       	rjmp	80007210 <xTaskResumeAll+0x64>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
800071d6:	6a 38       	ld.w	r8,r5[0xc]
800071d8:	70 37       	ld.w	r7,r8[0xc]
					vListRemove( &( pxTCB->xEventListItem ) );
800071da:	ee cc ff e8 	sub	r12,r7,-24
800071de:	f0 1f 00 28 	mcall	8000727c <xTaskResumeAll+0xd0>
					vListRemove( &( pxTCB->xGenericListItem ) );
800071e2:	ee c6 ff fc 	sub	r6,r7,-4
800071e6:	0c 9c       	mov	r12,r6
800071e8:	f0 1f 00 25 	mcall	8000727c <xTaskResumeAll+0xd0>
					prvAddTaskToReadyQueue( pxTCB );
800071ec:	6e bc       	ld.w	r12,r7[0x2c]
800071ee:	66 08       	ld.w	r8,r3[0x0]
800071f0:	10 3c       	cp.w	r12,r8
800071f2:	e7 fc ba 00 	st.whi	r3[0x0],r12
800071f6:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800071fa:	0c 9b       	mov	r11,r6
800071fc:	e4 0c 00 2c 	add	r12,r2,r12<<0x2
80007200:	f0 1f 00 20 	mcall	80007280 <xTaskResumeAll+0xd4>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80007204:	62 08       	ld.w	r8,r1[0x0]
80007206:	6e b9       	ld.w	r9,r7[0x2c]
80007208:	70 b8       	ld.w	r8,r8[0x2c]
8000720a:	10 39       	cp.w	r9,r8
8000720c:	f9 b4 02 01 	movhs	r4,1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80007210:	6a 08       	ld.w	r8,r5[0x0]
80007212:	58 08       	cp.w	r8,0
80007214:	ce 11       	brne	800071d6 <xTaskResumeAll+0x2a>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80007216:	49 c8       	lddpc	r8,80007284 <xTaskResumeAll+0xd8>
80007218:	70 08       	ld.w	r8,r8[0x0]
8000721a:	58 08       	cp.w	r8,0
8000721c:	c0 f0       	breq	8000723a <xTaskResumeAll+0x8e>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
8000721e:	49 a8       	lddpc	r8,80007284 <xTaskResumeAll+0xd8>
80007220:	70 08       	ld.w	r8,r8[0x0]
80007222:	58 08       	cp.w	r8,0
80007224:	c1 10       	breq	80007246 <xTaskResumeAll+0x9a>
					{
						vTaskIncrementTick();
						--uxMissedTicks;
80007226:	49 87       	lddpc	r7,80007284 <xTaskResumeAll+0xd8>
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
80007228:	f0 1f 00 18 	mcall	80007288 <xTaskResumeAll+0xdc>
						--uxMissedTicks;
8000722c:	6e 08       	ld.w	r8,r7[0x0]
8000722e:	20 18       	sub	r8,1
80007230:	8f 08       	st.w	r7[0x0],r8
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80007232:	6e 08       	ld.w	r8,r7[0x0]
80007234:	58 08       	cp.w	r8,0
80007236:	cf 91       	brne	80007228 <xTaskResumeAll+0x7c>
80007238:	c0 78       	rjmp	80007246 <xTaskResumeAll+0x9a>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
8000723a:	58 14       	cp.w	r4,1
8000723c:	c0 50       	breq	80007246 <xTaskResumeAll+0x9a>
8000723e:	49 48       	lddpc	r8,8000728c <xTaskResumeAll+0xe0>
80007240:	70 08       	ld.w	r8,r8[0x0]
80007242:	58 18       	cp.w	r8,1
80007244:	c0 71       	brne	80007252 <xTaskResumeAll+0xa6>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
80007246:	30 09       	mov	r9,0
80007248:	49 18       	lddpc	r8,8000728c <xTaskResumeAll+0xe0>
8000724a:	91 09       	st.w	r8[0x0],r9
					portYIELD_WITHIN_API();
8000724c:	d7 33       	scall
8000724e:	30 17       	mov	r7,1
80007250:	c0 28       	rjmp	80007254 <xTaskResumeAll+0xa8>
80007252:	30 07       	mov	r7,0
				}
			}
		}
	}
	taskEXIT_CRITICAL();
80007254:	f0 1f 00 0f 	mcall	80007290 <xTaskResumeAll+0xe4>

	return xAlreadyYielded;
}
80007258:	0e 9c       	mov	r12,r7
8000725a:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
8000725e:	00 00       	add	r0,r0
80007260:	80 00       	ld.sh	r0,r0[0x0]
80007262:	66 64       	ld.w	r4,r3[0x18]
80007264:	00 00       	add	r0,r0
80007266:	0d 8c       	ld.ub	r12,r6[0x0]
80007268:	00 00       	add	r0,r0
8000726a:	0d a8       	ld.ub	r8,r6[0x2]
8000726c:	00 00       	add	r0,r0
8000726e:	0d 60       	ld.uh	r0,--r6
80007270:	00 00       	add	r0,r0
80007272:	0d c4       	ld.ub	r4,r6[0x4]
80007274:	00 00       	add	r0,r0
80007276:	0c a8       	st.w	r6++,r8
80007278:	00 00       	add	r0,r0
8000727a:	0d 5c       	ld.sh	r12,--r6
8000727c:	80 00       	ld.sh	r0,r0[0x0]
8000727e:	65 aa       	ld.w	r10,r2[0x68]
80007280:	80 00       	ld.sh	r0,r0[0x0]
80007282:	65 5a       	ld.w	r10,r2[0x54]
80007284:	00 00       	add	r0,r0
80007286:	0c 8c       	andn	r12,r6
80007288:	80 00       	ld.sh	r0,r0[0x0]
8000728a:	70 04       	ld.w	r4,r8[0x0]
8000728c:	00 00       	add	r0,r0
8000728e:	0d ac       	ld.ub	r12,r6[0x2]
80007290:	80 00       	ld.sh	r0,r0[0x0]
80007292:	67 70       	ld.w	r0,r3[0x5c]

80007294 <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
80007294:	eb cd 40 80 	pushm	r7,lr
80007298:	18 97       	mov	r7,r12
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
8000729a:	49 08       	lddpc	r8,800072d8 <prvAddCurrentTaskToDelayedList+0x44>
8000729c:	70 08       	ld.w	r8,r8[0x0]
8000729e:	91 1c       	st.w	r8[0x4],r12

	if( xTimeToWake < xTickCount )
800072a0:	48 f8       	lddpc	r8,800072dc <prvAddCurrentTaskToDelayedList+0x48>
800072a2:	70 08       	ld.w	r8,r8[0x0]
800072a4:	10 3c       	cp.w	r12,r8
800072a6:	c0 a2       	brcc	800072ba <prvAddCurrentTaskToDelayedList+0x26>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800072a8:	48 c8       	lddpc	r8,800072d8 <prvAddCurrentTaskToDelayedList+0x44>
800072aa:	70 0b       	ld.w	r11,r8[0x0]
800072ac:	48 d8       	lddpc	r8,800072e0 <prvAddCurrentTaskToDelayedList+0x4c>
800072ae:	70 0c       	ld.w	r12,r8[0x0]
800072b0:	2f cb       	sub	r11,-4
800072b2:	f0 1f 00 0d 	mcall	800072e4 <prvAddCurrentTaskToDelayedList+0x50>
800072b6:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800072ba:	48 88       	lddpc	r8,800072d8 <prvAddCurrentTaskToDelayedList+0x44>
800072bc:	70 0b       	ld.w	r11,r8[0x0]
800072be:	48 b8       	lddpc	r8,800072e8 <prvAddCurrentTaskToDelayedList+0x54>
800072c0:	70 0c       	ld.w	r12,r8[0x0]
800072c2:	2f cb       	sub	r11,-4
800072c4:	f0 1f 00 08 	mcall	800072e4 <prvAddCurrentTaskToDelayedList+0x50>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
800072c8:	48 98       	lddpc	r8,800072ec <prvAddCurrentTaskToDelayedList+0x58>
800072ca:	70 08       	ld.w	r8,r8[0x0]
800072cc:	10 37       	cp.w	r7,r8
800072ce:	c0 32       	brcc	800072d4 <prvAddCurrentTaskToDelayedList+0x40>
		{
			xNextTaskUnblockTime = xTimeToWake;
800072d0:	48 78       	lddpc	r8,800072ec <prvAddCurrentTaskToDelayedList+0x58>
800072d2:	91 07       	st.w	r8[0x0],r7
800072d4:	e3 cd 80 80 	ldm	sp++,r7,pc
800072d8:	00 00       	add	r0,r0
800072da:	0d 5c       	ld.sh	r12,--r6
800072dc:	00 00       	add	r0,r0
800072de:	0d 88       	ld.ub	r8,r6[0x0]
800072e0:	00 00       	add	r0,r0
800072e2:	0c a4       	st.w	r6++,r4
800072e4:	80 00       	ld.sh	r0,r0[0x0]
800072e6:	65 76       	ld.w	r6,r2[0x5c]
800072e8:	00 00       	add	r0,r0
800072ea:	0c 94       	mov	r4,r6
800072ec:	00 00       	add	r0,r0
800072ee:	05 48       	ld.w	r8,--r2

800072f0 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
800072f0:	eb cd 40 c0 	pushm	r6-r7,lr
800072f4:	18 97       	mov	r7,r12
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0 )
800072f6:	58 0c       	cp.w	r12,0
800072f8:	c1 10       	breq	8000731a <vTaskDelay+0x2a>
		{
			vTaskSuspendAll();
800072fa:	f0 1f 00 0a 	mcall	80007320 <vTaskDelay+0x30>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
800072fe:	48 a8       	lddpc	r8,80007324 <vTaskDelay+0x34>
80007300:	70 06       	ld.w	r6,r8[0x0]

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80007302:	48 a8       	lddpc	r8,80007328 <vTaskDelay+0x38>
80007304:	70 0c       	ld.w	r12,r8[0x0]
80007306:	2f cc       	sub	r12,-4
80007308:	f0 1f 00 09 	mcall	8000732c <vTaskDelay+0x3c>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
8000730c:	ee 06 00 0c 	add	r12,r7,r6
80007310:	f0 1f 00 08 	mcall	80007330 <vTaskDelay+0x40>
			}
			xAlreadyYielded = xTaskResumeAll();
80007314:	f0 1f 00 08 	mcall	80007334 <vTaskDelay+0x44>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
80007318:	c0 21       	brne	8000731c <vTaskDelay+0x2c>
		{
			portYIELD_WITHIN_API();
8000731a:	d7 33       	scall
8000731c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80007320:	80 00       	ld.sh	r0,r0[0x0]
80007322:	6d f0       	ld.w	r0,r6[0x7c]
80007324:	00 00       	add	r0,r0
80007326:	0d 88       	ld.ub	r8,r6[0x0]
80007328:	00 00       	add	r0,r0
8000732a:	0d 5c       	ld.sh	r12,--r6
8000732c:	80 00       	ld.sh	r0,r0[0x0]
8000732e:	65 aa       	ld.w	r10,r2[0x68]
80007330:	80 00       	ld.sh	r0,r0[0x0]
80007332:	72 94       	ld.w	r4,r9[0x24]
80007334:	80 00       	ld.sh	r0,r0[0x0]
80007336:	71 ac       	ld.w	r12,r8[0x68]

80007338 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
80007338:	eb cd 40 c0 	pushm	r6-r7,lr
8000733c:	18 96       	mov	r6,r12
8000733e:	16 97       	mov	r7,r11
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0 ) );

		vTaskSuspendAll();
80007340:	f0 1f 00 18 	mcall	800073a0 <vTaskDelayUntil+0x68>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
80007344:	6c 08       	ld.w	r8,r6[0x0]
80007346:	10 07       	add	r7,r8

			if( xTickCount < *pxPreviousWakeTime )
80007348:	49 79       	lddpc	r9,800073a4 <vTaskDelayUntil+0x6c>
8000734a:	72 09       	ld.w	r9,r9[0x0]
8000734c:	12 38       	cp.w	r8,r9
8000734e:	e0 88 00 0c 	brls	80007366 <vTaskDelayUntil+0x2e>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
80007352:	0e 38       	cp.w	r8,r7
80007354:	e0 88 00 22 	brls	80007398 <vTaskDelayUntil+0x60>
80007358:	49 38       	lddpc	r8,800073a4 <vTaskDelayUntil+0x6c>
8000735a:	70 08       	ld.w	r8,r8[0x0]
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
8000735c:	8d 07       	st.w	r6[0x0],r7

			if( xShouldDelay != pdFALSE )
8000735e:	10 37       	cp.w	r7,r8
80007360:	e0 88 00 14 	brls	80007388 <vTaskDelayUntil+0x50>
80007364:	c0 a8       	rjmp	80007378 <vTaskDelayUntil+0x40>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
80007366:	0e 38       	cp.w	r8,r7
80007368:	e0 8b 00 16 	brhi	80007394 <vTaskDelayUntil+0x5c>
8000736c:	48 e8       	lddpc	r8,800073a4 <vTaskDelayUntil+0x6c>
8000736e:	70 08       	ld.w	r8,r8[0x0]
80007370:	10 37       	cp.w	r7,r8
80007372:	e0 8b 00 11 	brhi	80007394 <vTaskDelayUntil+0x5c>
80007376:	c1 18       	rjmp	80007398 <vTaskDelayUntil+0x60>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80007378:	48 c8       	lddpc	r8,800073a8 <vTaskDelayUntil+0x70>
8000737a:	70 0c       	ld.w	r12,r8[0x0]
8000737c:	2f cc       	sub	r12,-4
8000737e:	f0 1f 00 0c 	mcall	800073ac <vTaskDelayUntil+0x74>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
80007382:	0e 9c       	mov	r12,r7
80007384:	f0 1f 00 0b 	mcall	800073b0 <vTaskDelayUntil+0x78>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
80007388:	f0 1f 00 0b 	mcall	800073b4 <vTaskDelayUntil+0x7c>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
8000738c:	c0 81       	brne	8000739c <vTaskDelayUntil+0x64>
		{
			portYIELD_WITHIN_API();
8000738e:	d7 33       	scall
80007390:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80007394:	8d 07       	st.w	r6[0x0],r7
80007396:	cf 1b       	rjmp	80007378 <vTaskDelayUntil+0x40>
80007398:	8d 07       	st.w	r6[0x0],r7
8000739a:	cf 7b       	rjmp	80007388 <vTaskDelayUntil+0x50>
8000739c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800073a0:	80 00       	ld.sh	r0,r0[0x0]
800073a2:	6d f0       	ld.w	r0,r6[0x7c]
800073a4:	00 00       	add	r0,r0
800073a6:	0d 88       	ld.ub	r8,r6[0x0]
800073a8:	00 00       	add	r0,r0
800073aa:	0d 5c       	ld.sh	r12,--r6
800073ac:	80 00       	ld.sh	r0,r0[0x0]
800073ae:	65 aa       	ld.w	r10,r2[0x68]
800073b0:	80 00       	ld.sh	r0,r0[0x0]
800073b2:	72 94       	ld.w	r4,r9[0x24]
800073b4:	80 00       	ld.sh	r0,r0[0x0]
800073b6:	71 ac       	ld.w	r12,r8[0x68]

800073b8 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
800073b8:	eb cd 40 c0 	pushm	r6-r7,lr
800073bc:	16 96       	mov	r6,r11
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
800073be:	48 e7       	lddpc	r7,800073f4 <vTaskPlaceOnEventList+0x3c>
800073c0:	6e 0b       	ld.w	r11,r7[0x0]
800073c2:	2e 8b       	sub	r11,-24
800073c4:	f0 1f 00 0d 	mcall	800073f8 <vTaskPlaceOnEventList+0x40>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800073c8:	6e 0c       	ld.w	r12,r7[0x0]
800073ca:	2f cc       	sub	r12,-4
800073cc:	f0 1f 00 0c 	mcall	800073fc <vTaskPlaceOnEventList+0x44>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
800073d0:	5b f6       	cp.w	r6,-1
800073d2:	c0 81       	brne	800073e2 <vTaskPlaceOnEventList+0x2a>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800073d4:	6e 0b       	ld.w	r11,r7[0x0]
800073d6:	2f cb       	sub	r11,-4
800073d8:	48 ac       	lddpc	r12,80007400 <vTaskPlaceOnEventList+0x48>
800073da:	f0 1f 00 0b 	mcall	80007404 <vTaskPlaceOnEventList+0x4c>
800073de:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
800073e2:	48 a8       	lddpc	r8,80007408 <vTaskPlaceOnEventList+0x50>
800073e4:	70 0c       	ld.w	r12,r8[0x0]
			prvAddCurrentTaskToDelayedList( xTimeToWake );
800073e6:	ec 0c 00 0c 	add	r12,r6,r12
800073ea:	f0 1f 00 09 	mcall	8000740c <vTaskPlaceOnEventList+0x54>
800073ee:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800073f2:	00 00       	add	r0,r0
800073f4:	00 00       	add	r0,r0
800073f6:	0d 5c       	ld.sh	r12,--r6
800073f8:	80 00       	ld.sh	r0,r0[0x0]
800073fa:	65 76       	ld.w	r6,r2[0x5c]
800073fc:	80 00       	ld.sh	r0,r0[0x0]
800073fe:	65 aa       	ld.w	r10,r2[0x68]
80007400:	00 00       	add	r0,r0
80007402:	0d b0       	ld.ub	r0,r6[0x3]
80007404:	80 00       	ld.sh	r0,r0[0x0]
80007406:	65 5a       	ld.w	r10,r2[0x54]
80007408:	00 00       	add	r0,r0
8000740a:	0d 88       	ld.ub	r8,r6[0x0]
8000740c:	80 00       	ld.sh	r0,r0[0x0]
8000740e:	72 94       	ld.w	r4,r9[0x24]

80007410 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
80007410:	eb cd 40 f8 	pushm	r3-r7,lr
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80007414:	49 67       	lddpc	r7,8000746c <prvIdleTask+0x5c>
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
80007416:	49 74       	lddpc	r4,80007470 <prvIdleTask+0x60>

				taskENTER_CRITICAL();
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					--uxCurrentNumberOfTasks;
80007418:	49 73       	lddpc	r3,80007474 <prvIdleTask+0x64>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
8000741a:	49 85       	lddpc	r5,80007478 <prvIdleTask+0x68>
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
8000741c:	6e 08       	ld.w	r8,r7[0x0]
8000741e:	58 08       	cp.w	r8,0
80007420:	c1 e0       	breq	8000745c <prvIdleTask+0x4c>
		{
			vTaskSuspendAll();
80007422:	f0 1f 00 17 	mcall	8000747c <prvIdleTask+0x6c>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
80007426:	68 06       	ld.w	r6,r4[0x0]
			xTaskResumeAll();
80007428:	f0 1f 00 16 	mcall	80007480 <prvIdleTask+0x70>

			if( xListIsEmpty == pdFALSE )
8000742c:	58 06       	cp.w	r6,0
8000742e:	c1 70       	breq	8000745c <prvIdleTask+0x4c>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
80007430:	f0 1f 00 15 	mcall	80007484 <prvIdleTask+0x74>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
80007434:	68 38       	ld.w	r8,r4[0xc]
80007436:	70 36       	ld.w	r6,r8[0xc]
					vListRemove( &( pxTCB->xGenericListItem ) );
80007438:	ec cc ff fc 	sub	r12,r6,-4
8000743c:	f0 1f 00 13 	mcall	80007488 <prvIdleTask+0x78>
					--uxCurrentNumberOfTasks;
80007440:	66 08       	ld.w	r8,r3[0x0]
80007442:	20 18       	sub	r8,1
80007444:	87 08       	st.w	r3[0x0],r8
					--uxTasksDeleted;
80007446:	6e 08       	ld.w	r8,r7[0x0]
80007448:	20 18       	sub	r8,1
8000744a:	8f 08       	st.w	r7[0x0],r8
				}
				taskEXIT_CRITICAL();
8000744c:	f0 1f 00 10 	mcall	8000748c <prvIdleTask+0x7c>

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
80007450:	6c cc       	ld.w	r12,r6[0x30]
80007452:	f0 1f 00 10 	mcall	80007490 <prvIdleTask+0x80>
		vPortFree( pxTCB );
80007456:	0c 9c       	mov	r12,r6
80007458:	f0 1f 00 0e 	mcall	80007490 <prvIdleTask+0x80>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
8000745c:	6a 08       	ld.w	r8,r5[0x0]
8000745e:	58 18       	cp.w	r8,1
80007460:	e0 88 00 03 	brls	80007466 <prvIdleTask+0x56>
			{
				taskYIELD();
80007464:	d7 33       	scall
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
80007466:	f0 1f 00 0c 	mcall	80007494 <prvIdleTask+0x84>
		}
		#endif
	}
8000746a:	cd 9b       	rjmp	8000741c <prvIdleTask+0xc>
8000746c:	00 00       	add	r0,r0
8000746e:	0c 9c       	mov	r12,r6
80007470:	00 00       	add	r0,r0
80007472:	0d 48       	ld.w	r8,--r6
80007474:	00 00       	add	r0,r0
80007476:	0d a8       	ld.ub	r8,r6[0x2]
80007478:	00 00       	add	r0,r0
8000747a:	0c a8       	st.w	r6++,r8
8000747c:	80 00       	ld.sh	r0,r0[0x0]
8000747e:	6d f0       	ld.w	r0,r6[0x7c]
80007480:	80 00       	ld.sh	r0,r0[0x0]
80007482:	71 ac       	ld.w	r12,r8[0x68]
80007484:	80 00       	ld.sh	r0,r0[0x0]
80007486:	66 64       	ld.w	r4,r3[0x18]
80007488:	80 00       	ld.sh	r0,r0[0x0]
8000748a:	65 aa       	ld.w	r10,r2[0x68]
8000748c:	80 00       	ld.sh	r0,r0[0x0]
8000748e:	67 70       	ld.w	r0,r3[0x5c]
80007490:	80 00       	ld.sh	r0,r0[0x0]
80007492:	68 a8       	ld.w	r8,r4[0x28]
80007494:	80 00       	ld.sh	r0,r0[0x0]
80007496:	20 2c       	sub	r12,2

80007498 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
80007498:	d4 31       	pushm	r0-r7,lr
8000749a:	20 1d       	sub	sp,4
8000749c:	fa c4 ff d8 	sub	r4,sp,-40
800074a0:	50 0c       	stdsp	sp[0x0],r12
800074a2:	16 91       	mov	r1,r11
800074a4:	14 97       	mov	r7,r10
800074a6:	12 90       	mov	r0,r9
800074a8:	10 93       	mov	r3,r8
800074aa:	68 02       	ld.w	r2,r4[0x0]
800074ac:	68 16       	ld.w	r6,r4[0x4]
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
800074ae:	34 8c       	mov	r12,72
800074b0:	f0 1f 00 5c 	mcall	80007620 <xTaskGenericCreate+0x188>
800074b4:	18 95       	mov	r5,r12

	if( pxNewTCB != NULL )
800074b6:	c0 31       	brne	800074bc <xTaskGenericCreate+0x24>
800074b8:	3f fc       	mov	r12,-1
800074ba:	ca f8       	rjmp	80007618 <xTaskGenericCreate+0x180>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
800074bc:	58 06       	cp.w	r6,0
800074be:	e0 81 00 af 	brne	8000761c <xTaskGenericCreate+0x184>
800074c2:	0e 9c       	mov	r12,r7
800074c4:	5c 7c       	castu.h	r12
800074c6:	a3 6c       	lsl	r12,0x2
800074c8:	f0 1f 00 56 	mcall	80007620 <xTaskGenericCreate+0x188>
800074cc:	18 96       	mov	r6,r12
800074ce:	8b cc       	st.w	r5[0x30],r12

		if( pxNewTCB->pxStack == NULL )
800074d0:	c0 61       	brne	800074dc <xTaskGenericCreate+0x44>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
800074d2:	0a 9c       	mov	r12,r5
800074d4:	f0 1f 00 54 	mcall	80007624 <xTaskGenericCreate+0x18c>
800074d8:	3f fc       	mov	r12,-1
800074da:	c9 f8       	rjmp	80007618 <xTaskGenericCreate+0x180>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
800074dc:	5c 77       	castu.h	r7
800074de:	ee 0a 15 02 	lsl	r10,r7,0x2
800074e2:	e0 6b 00 a5 	mov	r11,165
800074e6:	0c 9c       	mov	r12,r6
800074e8:	f0 1f 00 50 	mcall	80007628 <xTaskGenericCreate+0x190>
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~portBYTE_ALIGNMENT_MASK  ) );
800074ec:	ee c6 00 01 	sub	r6,r7,1
800074f0:	6a c8       	ld.w	r8,r5[0x30]
800074f2:	f0 06 00 26 	add	r6,r8,r6<<0x2
800074f6:	e0 16 ff fc 	andl	r6,0xfffc
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
800074fa:	31 0a       	mov	r10,16
800074fc:	02 9b       	mov	r11,r1
800074fe:	ea cc ff cc 	sub	r12,r5,-52
80007502:	f0 1f 00 4b 	mcall	8000762c <xTaskGenericCreate+0x194>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
80007506:	30 08       	mov	r8,0
80007508:	eb 68 00 43 	st.b	r5[67],r8
8000750c:	58 73       	cp.w	r3,7
8000750e:	e6 07 17 80 	movls	r7,r3
80007512:	f9 b7 0b 07 	movhi	r7,7
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
80007516:	8b b7       	st.w	r5[0x2c],r7
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
80007518:	eb 47 00 44 	st.w	r5[68],r7
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
8000751c:	ea c4 ff fc 	sub	r4,r5,-4
80007520:	08 9c       	mov	r12,r4
80007522:	f0 1f 00 44 	mcall	80007630 <xTaskGenericCreate+0x198>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
80007526:	ea cc ff e8 	sub	r12,r5,-24
8000752a:	f0 1f 00 42 	mcall	80007630 <xTaskGenericCreate+0x198>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
8000752e:	8b 45       	st.w	r5[0x10],r5

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
80007530:	ee 07 11 08 	rsub	r7,r7,8
80007534:	8b 67       	st.w	r5[0x18],r7
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
80007536:	8b 95       	st.w	r5[0x24],r5
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
80007538:	00 9a       	mov	r10,r0
8000753a:	40 0b       	lddsp	r11,sp[0x0]
8000753c:	0c 9c       	mov	r12,r6
8000753e:	f0 1f 00 3e 	mcall	80007634 <xTaskGenericCreate+0x19c>
80007542:	8b 0c       	st.w	r5[0x0],r12
		if( ( void * ) pxCreatedTask != NULL )
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
80007544:	58 02       	cp.w	r2,0
80007546:	e5 f5 1a 00 	st.wne	r2[0x0],r5
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
8000754a:	f0 1f 00 3c 	mcall	80007638 <xTaskGenericCreate+0x1a0>
		{
			uxCurrentNumberOfTasks++;
8000754e:	4b c8       	lddpc	r8,8000763c <xTaskGenericCreate+0x1a4>
80007550:	70 09       	ld.w	r9,r8[0x0]
80007552:	2f f9       	sub	r9,-1
80007554:	91 09       	st.w	r8[0x0],r9
			if( pxCurrentTCB == NULL )
80007556:	4b b8       	lddpc	r8,80007640 <xTaskGenericCreate+0x1a8>
80007558:	70 08       	ld.w	r8,r8[0x0]
8000755a:	58 08       	cp.w	r8,0
8000755c:	c2 61       	brne	800075a8 <xTaskGenericCreate+0x110>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
8000755e:	4b 98       	lddpc	r8,80007640 <xTaskGenericCreate+0x1a8>
80007560:	91 05       	st.w	r8[0x0],r5

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
80007562:	4b 78       	lddpc	r8,8000763c <xTaskGenericCreate+0x1a4>
80007564:	70 08       	ld.w	r8,r8[0x0]
80007566:	58 18       	cp.w	r8,1
80007568:	c2 b1       	brne	800075be <xTaskGenericCreate+0x126>
8000756a:	4b 77       	lddpc	r7,80007644 <xTaskGenericCreate+0x1ac>

/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
8000756c:	ee c6 ff 60 	sub	r6,r7,-160
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
80007570:	0e 9c       	mov	r12,r7
80007572:	f0 1f 00 36 	mcall	80007648 <xTaskGenericCreate+0x1b0>
80007576:	2e c7       	sub	r7,-20

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
80007578:	0c 37       	cp.w	r7,r6
8000757a:	cf b1       	brne	80007570 <xTaskGenericCreate+0xd8>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
8000757c:	4b 47       	lddpc	r7,8000764c <xTaskGenericCreate+0x1b4>
8000757e:	0e 9c       	mov	r12,r7
80007580:	f0 1f 00 32 	mcall	80007648 <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
80007584:	4b 36       	lddpc	r6,80007650 <xTaskGenericCreate+0x1b8>
80007586:	0c 9c       	mov	r12,r6
80007588:	f0 1f 00 30 	mcall	80007648 <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xPendingReadyList );
8000758c:	4b 2c       	lddpc	r12,80007654 <xTaskGenericCreate+0x1bc>
8000758e:	f0 1f 00 2f 	mcall	80007648 <xTaskGenericCreate+0x1b0>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
80007592:	4b 2c       	lddpc	r12,80007658 <xTaskGenericCreate+0x1c0>
80007594:	f0 1f 00 2d 	mcall	80007648 <xTaskGenericCreate+0x1b0>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
80007598:	4b 1c       	lddpc	r12,8000765c <xTaskGenericCreate+0x1c4>
8000759a:	f0 1f 00 2c 	mcall	80007648 <xTaskGenericCreate+0x1b0>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
8000759e:	4b 18       	lddpc	r8,80007660 <xTaskGenericCreate+0x1c8>
800075a0:	91 07       	st.w	r8[0x0],r7
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
800075a2:	4b 18       	lddpc	r8,80007664 <xTaskGenericCreate+0x1cc>
800075a4:	91 06       	st.w	r8[0x0],r6
800075a6:	c0 c8       	rjmp	800075be <xTaskGenericCreate+0x126>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
800075a8:	4b 08       	lddpc	r8,80007668 <xTaskGenericCreate+0x1d0>
800075aa:	70 08       	ld.w	r8,r8[0x0]
800075ac:	58 08       	cp.w	r8,0
800075ae:	c0 81       	brne	800075be <xTaskGenericCreate+0x126>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
800075b0:	4a 48       	lddpc	r8,80007640 <xTaskGenericCreate+0x1a8>
800075b2:	70 08       	ld.w	r8,r8[0x0]
800075b4:	70 b8       	ld.w	r8,r8[0x2c]
800075b6:	10 33       	cp.w	r3,r8
800075b8:	c0 33       	brcs	800075be <xTaskGenericCreate+0x126>
					{
						pxCurrentTCB = pxNewTCB;
800075ba:	4a 28       	lddpc	r8,80007640 <xTaskGenericCreate+0x1a8>
800075bc:	91 05       	st.w	r8[0x0],r5
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
800075be:	6a b8       	ld.w	r8,r5[0x2c]
800075c0:	4a b9       	lddpc	r9,8000766c <xTaskGenericCreate+0x1d4>
800075c2:	72 09       	ld.w	r9,r9[0x0]
800075c4:	12 38       	cp.w	r8,r9
800075c6:	e0 88 00 04 	brls	800075ce <xTaskGenericCreate+0x136>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
800075ca:	4a 99       	lddpc	r9,8000766c <xTaskGenericCreate+0x1d4>
800075cc:	93 08       	st.w	r9[0x0],r8
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
800075ce:	4a 98       	lddpc	r8,80007670 <xTaskGenericCreate+0x1d8>
800075d0:	70 09       	ld.w	r9,r8[0x0]
800075d2:	2f f9       	sub	r9,-1
800075d4:	91 09       	st.w	r8[0x0],r9

			prvAddTaskToReadyQueue( pxNewTCB );
800075d6:	6a b8       	ld.w	r8,r5[0x2c]
800075d8:	4a 79       	lddpc	r9,80007674 <xTaskGenericCreate+0x1dc>
800075da:	72 09       	ld.w	r9,r9[0x0]
800075dc:	12 38       	cp.w	r8,r9
800075de:	e0 88 00 04 	brls	800075e6 <xTaskGenericCreate+0x14e>
800075e2:	4a 59       	lddpc	r9,80007674 <xTaskGenericCreate+0x1dc>
800075e4:	93 08       	st.w	r9[0x0],r8
800075e6:	6a bc       	ld.w	r12,r5[0x2c]
800075e8:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800075ec:	08 9b       	mov	r11,r4
800075ee:	49 68       	lddpc	r8,80007644 <xTaskGenericCreate+0x1ac>
800075f0:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800075f4:	f0 1f 00 21 	mcall	80007678 <xTaskGenericCreate+0x1e0>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
800075f8:	f0 1f 00 21 	mcall	8000767c <xTaskGenericCreate+0x1e4>
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
800075fc:	49 b8       	lddpc	r8,80007668 <xTaskGenericCreate+0x1d0>
800075fe:	70 08       	ld.w	r8,r8[0x0]
80007600:	58 08       	cp.w	r8,0
80007602:	c0 a0       	breq	80007616 <xTaskGenericCreate+0x17e>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
80007604:	48 f8       	lddpc	r8,80007640 <xTaskGenericCreate+0x1a8>
80007606:	70 08       	ld.w	r8,r8[0x0]
80007608:	70 b8       	ld.w	r8,r8[0x2c]
8000760a:	10 33       	cp.w	r3,r8
8000760c:	e0 88 00 05 	brls	80007616 <xTaskGenericCreate+0x17e>
			{
				portYIELD_WITHIN_API();
80007610:	d7 33       	scall
80007612:	30 1c       	mov	r12,1
80007614:	c0 28       	rjmp	80007618 <xTaskGenericCreate+0x180>
80007616:	30 1c       	mov	r12,1
			}
		}
	}

	return xReturn;
}
80007618:	2f fd       	sub	sp,-4
8000761a:	d8 32       	popm	r0-r7,pc
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
8000761c:	99 c6       	st.w	r12[0x30],r6
8000761e:	c5 fb       	rjmp	800074dc <xTaskGenericCreate+0x44>
80007620:	80 00       	ld.sh	r0,r0[0x0]
80007622:	68 d0       	ld.w	r0,r4[0x34]
80007624:	80 00       	ld.sh	r0,r0[0x0]
80007626:	68 a8       	ld.w	r8,r4[0x28]
80007628:	80 00       	ld.sh	r0,r0[0x0]
8000762a:	82 4e       	ld.sh	lr,r1[0x8]
8000762c:	80 00       	ld.sh	r0,r0[0x0]
8000762e:	85 78       	st.w	r2[0x1c],r8
80007630:	80 00       	ld.sh	r0,r0[0x0]
80007632:	65 54       	ld.w	r4,r2[0x54]
80007634:	80 00       	ld.sh	r0,r0[0x0]
80007636:	65 d0       	ld.w	r0,r2[0x74]
80007638:	80 00       	ld.sh	r0,r0[0x0]
8000763a:	66 64       	ld.w	r4,r3[0x18]
8000763c:	00 00       	add	r0,r0
8000763e:	0d a8       	ld.ub	r8,r6[0x2]
80007640:	00 00       	add	r0,r0
80007642:	0d 5c       	ld.sh	r12,--r6
80007644:	00 00       	add	r0,r0
80007646:	0c a8       	st.w	r6++,r8
80007648:	80 00       	ld.sh	r0,r0[0x0]
8000764a:	65 40       	ld.w	r0,r2[0x50]
8000764c:	00 00       	add	r0,r0
8000764e:	0d 74       	ld.ub	r4,--r6
80007650:	00 00       	add	r0,r0
80007652:	0d 90       	ld.ub	r0,r6[0x1]
80007654:	00 00       	add	r0,r0
80007656:	0d 60       	ld.uh	r0,--r6
80007658:	00 00       	add	r0,r0
8000765a:	0d 48       	ld.w	r8,--r6
8000765c:	00 00       	add	r0,r0
8000765e:	0d b0       	ld.ub	r0,r6[0x3]
80007660:	00 00       	add	r0,r0
80007662:	0c 94       	mov	r4,r6
80007664:	00 00       	add	r0,r0
80007666:	0c a4       	st.w	r6++,r4
80007668:	00 00       	add	r0,r0
8000766a:	0c 98       	mov	r8,r6
8000766c:	00 00       	add	r0,r0
8000766e:	0c 90       	mov	r0,r6
80007670:	00 00       	add	r0,r0
80007672:	0d a4       	ld.ub	r4,r6[0x2]
80007674:	00 00       	add	r0,r0
80007676:	0d c4       	ld.ub	r4,r6[0x4]
80007678:	80 00       	ld.sh	r0,r0[0x0]
8000767a:	65 5a       	ld.w	r10,r2[0x54]
8000767c:	80 00       	ld.sh	r0,r0[0x0]
8000767e:	67 70       	ld.w	r0,r3[0x5c]

80007680 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
80007680:	d4 01       	pushm	lr
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
80007682:	30 09       	mov	r9,0
80007684:	1a d9       	st.w	--sp,r9
80007686:	1a d9       	st.w	--sp,r9
80007688:	1a d9       	st.w	--sp,r9
8000768a:	12 98       	mov	r8,r9
8000768c:	e0 6a 01 00 	mov	r10,256
80007690:	48 9b       	lddpc	r11,800076b4 <vTaskStartScheduler+0x34>
80007692:	48 ac       	lddpc	r12,800076b8 <vTaskStartScheduler+0x38>
80007694:	f0 1f 00 0a 	mcall	800076bc <vTaskStartScheduler+0x3c>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
80007698:	2f dd       	sub	sp,-12
8000769a:	58 1c       	cp.w	r12,1
8000769c:	c0 a1       	brne	800076b0 <vTaskStartScheduler+0x30>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
8000769e:	d3 03       	ssrf	0x10

		xSchedulerRunning = pdTRUE;
800076a0:	30 19       	mov	r9,1
800076a2:	48 88       	lddpc	r8,800076c0 <vTaskStartScheduler+0x40>
800076a4:	91 09       	st.w	r8[0x0],r9
		xTickCount = ( portTickType ) 0;
800076a6:	30 09       	mov	r9,0
800076a8:	48 78       	lddpc	r8,800076c4 <vTaskStartScheduler+0x44>
800076aa:	91 09       	st.w	r8[0x0],r9
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
800076ac:	f0 1f 00 07 	mcall	800076c8 <vTaskStartScheduler+0x48>
800076b0:	d8 02       	popm	pc
800076b2:	00 00       	add	r0,r0
800076b4:	80 00       	ld.sh	r0,r0[0x0]
800076b6:	e3 88       	*unknown*
800076b8:	80 00       	ld.sh	r0,r0[0x0]
800076ba:	74 10       	ld.w	r0,r10[0x4]
800076bc:	80 00       	ld.sh	r0,r0[0x0]
800076be:	74 98       	ld.w	r8,r10[0x24]
800076c0:	00 00       	add	r0,r0
800076c2:	0c 98       	mov	r8,r6
800076c4:	00 00       	add	r0,r0
800076c6:	0d 88       	ld.ub	r8,r6[0x0]
800076c8:	80 00       	ld.sh	r0,r0[0x0]
800076ca:	66 74       	ld.w	r4,r3[0x1c]

800076cc <PrintChar>:
	
static void task_log(void * pvParameters);

char *  PrintChar(char c, char * str)
{
	*str++ = c;
800076cc:	16 cc       	st.b	r11++,r12
	return str;
}
800076ce:	5e fb       	retal	r11

800076d0 <PrintHex>:
	
	return str;
}

char * PrintHex(int i,char len, char * str)
{
800076d0:	eb cd 40 c0 	pushm	r6-r7,lr
800076d4:	20 3d       	sub	sp,12
800076d6:	18 98       	mov	r8,r12
	char * p = str;
	char s[12];
	memset(s, 0 , 12);
800076d8:	30 06       	mov	r6,0
800076da:	30 07       	mov	r7,0
800076dc:	fa e7 00 00 	st.d	sp[0],r6
800076e0:	30 0c       	mov	r12,0
800076e2:	50 2c       	stdsp	sp[0x8],r12
	int cnt=0;
	
	if(i)
800076e4:	58 08       	cp.w	r8,0
800076e6:	c1 30       	breq	8000770c <PrintHex+0x3c>
800076e8:	18 99       	mov	r9,r12
	while(i)
	{
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
800076ea:	1a 9c       	mov	r12,sp
800076ec:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
800076f0:	58 9e       	cp.w	lr,9
800076f2:	e0 8a 00 04 	brle	800076fa <PrintHex+0x2a>
800076f6:	2c 9e       	sub	lr,-55
800076f8:	c0 48       	rjmp	80007700 <PrintHex+0x30>
800076fa:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
800076fe:	2d 0e       	sub	lr,-48
80007700:	f8 09 0b 0e 	st.b	r12[r9],lr
80007704:	2f f9       	sub	r9,-1
		i = (i >> 4 ) & 0x0FFFFFFF;
80007706:	a5 88       	lsr	r8,0x4
	char s[12];
	memset(s, 0 , 12);
	int cnt=0;
	
	if(i)
	while(i)
80007708:	cf 21       	brne	800076ec <PrintHex+0x1c>
8000770a:	c0 48       	rjmp	80007712 <PrintHex+0x42>
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
		i = (i >> 4 ) & 0x0FFFFFFF;
		//i >>= 4
	}
	else
	s[cnt++] = '0';
8000770c:	33 08       	mov	r8,48
8000770e:	ba 88       	st.b	sp[0x0],r8
80007710:	30 19       	mov	r9,1
	
	if(len - cnt > 0 )
80007712:	f6 09 01 08 	sub	r8,r11,r9
80007716:	58 08       	cp.w	r8,0
80007718:	e0 8a 00 13 	brle	8000773e <PrintHex+0x6e>
	{
		char num = len - cnt;
8000771c:	12 1b       	sub	r11,r9
8000771e:	f9 db c0 08 	bfextu	r12,r11,0x0,0x8
		for(int i = 0; i < num; i++)
80007722:	18 9e       	mov	lr,r12
80007724:	58 0c       	cp.w	r12,0
80007726:	e0 8a 00 0c 	brle	8000773e <PrintHex+0x6e>
8000772a:	1a 9b       	mov	r11,sp
8000772c:	12 0b       	add	r11,r9
8000772e:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80007730:	33 07       	mov	r7,48
80007732:	16 c7       	st.b	r11++,r7
	s[cnt++] = '0';
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80007734:	2f f8       	sub	r8,-1
80007736:	1c 38       	cp.w	r8,lr
80007738:	cf d5       	brlt	80007732 <PrintHex+0x62>
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
8000773a:	f8 09 00 09 	add	r9,r12,r9
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
8000773e:	f2 c8 ff ff 	sub	r8,r9,-1
	s[cnt++] = '0';
	
	while(cnt>0)
80007742:	f0 cb ff ff 	sub	r11,r8,-1
80007746:	58 0b       	cp.w	r11,0
80007748:	e0 8a 00 19 	brle	8000777a <PrintHex+0xaa>
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
8000774c:	fa cb ff f4 	sub	r11,sp,-12
80007750:	f6 09 00 09 	add	r9,r11,r9
80007754:	37 8b       	mov	r11,120
80007756:	f3 6b ff f4 	st.b	r9[-12],r11
	s[cnt++] = '0';
8000775a:	fa c9 ff f4 	sub	r9,sp,-12
8000775e:	10 09       	add	r9,r8
80007760:	33 0b       	mov	r11,48
80007762:	f3 6b ff f4 	st.b	r9[-12],r11
80007766:	fa 08 00 08 	add	r8,sp,r8
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
8000776a:	fa ce 00 01 	sub	lr,sp,1
8000776e:	14 99       	mov	r9,r10
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
	*p++ = s[--cnt];
80007770:	11 8b       	ld.ub	r11,r8[0x0]
80007772:	12 cb       	st.b	r9++,r11
80007774:	20 18       	sub	r8,1
	}
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
80007776:	1c 38       	cp.w	r8,lr
80007778:	cf c1       	brne	80007770 <PrintHex+0xa0>
	*p++ = s[--cnt];
		
	return str;
}
8000777a:	14 9c       	mov	r12,r10
8000777c:	2f dd       	sub	sp,-12
8000777e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

80007782 <PrintDec>:
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
{
80007782:	d4 21       	pushm	r4-r7,lr
80007784:	20 3d       	sub	sp,12
80007786:	18 98       	mov	r8,r12
	char * p = str;
	
	int sign = i>=0 ? 0 : 1;
	char s[10];
	memset(s, 0 , 10);
80007788:	30 06       	mov	r6,0
8000778a:	30 07       	mov	r7,0
8000778c:	fa e7 00 00 	st.d	sp[0],r6
80007790:	30 0c       	mov	r12,0
80007792:	ba 4c       	st.h	sp[0x8],r12
	int cnt=0;
	if(sign)
80007794:	58 08       	cp.w	r8,0
80007796:	c0 35       	brlt	8000779c <PrintDec+0x1a>
80007798:	14 97       	mov	r7,r10
8000779a:	c0 58       	rjmp	800077a4 <PrintDec+0x22>
	{
		*p++ = '-';
8000779c:	14 97       	mov	r7,r10
8000779e:	32 d9       	mov	r9,45
800077a0:	0e c9       	st.b	r7++,r9
		i = -i;
800077a2:	5c 38       	neg	r8
	}
	
	if(i == 0 )s[cnt++] = '0';
800077a4:	58 08       	cp.w	r8,0
800077a6:	c0 51       	brne	800077b0 <PrintDec+0x2e>
800077a8:	33 08       	mov	r8,48
800077aa:	ba 88       	st.b	sp[0x0],r8
800077ac:	30 1e       	mov	lr,1
800077ae:	c2 f8       	rjmp	8000780c <PrintDec+0x8a>
	
	int ten = i%10;
800077b0:	e0 65 66 67 	mov	r5,26215
800077b4:	ea 15 66 66 	orh	r5,0x6666
800077b8:	f0 05 04 44 	muls.d	r4,r8,r5
800077bc:	ea 0c 14 02 	asr	r12,r5,0x2
800077c0:	f0 09 14 1f 	asr	r9,r8,0x1f
800077c4:	f8 09 01 09 	sub	r9,r12,r9
800077c8:	f2 09 00 29 	add	r9,r9,r9<<0x2
800077cc:	f0 09 01 19 	sub	r9,r8,r9<<0x1
800077d0:	30 0e       	mov	lr,0
	while(i)
	{
		s[cnt] = ten+'0';
800077d2:	1a 9c       	mov	r12,sp
		cnt++;
		i /= 10;
800077d4:	e0 66 66 67 	mov	r6,26215
800077d8:	ea 16 66 66 	orh	r6,0x6666
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
	{
		s[cnt] = ten+'0';
800077dc:	2d 09       	sub	r9,-48
800077de:	f8 0e 0b 09 	st.b	r12[lr],r9
		cnt++;
800077e2:	2f fe       	sub	lr,-1
		i /= 10;
800077e4:	f0 06 04 44 	muls.d	r4,r8,r6
800077e8:	ea 09 14 02 	asr	r9,r5,0x2
800077ec:	bf 58       	asr	r8,0x1f
800077ee:	f2 08 01 08 	sub	r8,r9,r8
		ten = i%10;
800077f2:	f0 06 04 44 	muls.d	r4,r8,r6
800077f6:	ea 09 14 02 	asr	r9,r5,0x2
800077fa:	f0 05 14 1f 	asr	r5,r8,0x1f
800077fe:	0a 19       	sub	r9,r5
80007800:	f2 09 00 29 	add	r9,r9,r9<<0x2
80007804:	f0 09 01 19 	sub	r9,r8,r9<<0x1
	}
	
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
80007808:	58 08       	cp.w	r8,0
8000780a:	ce 91       	brne	800077dc <PrintDec+0x5a>
		cnt++;
		i /= 10;
		ten = i%10;
	}
	
	if(len - cnt > 0 )
8000780c:	f6 0e 01 08 	sub	r8,r11,lr
80007810:	58 08       	cp.w	r8,0
80007812:	e0 89 00 06 	brgt	8000781e <PrintDec+0x9c>
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80007816:	58 0e       	cp.w	lr,0
80007818:	e0 89 00 14 	brgt	80007840 <PrintDec+0xbe>
8000781c:	c1 d8       	rjmp	80007856 <PrintDec+0xd4>
		ten = i%10;
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
8000781e:	1c 1b       	sub	r11,lr
80007820:	5c 5b       	castu.b	r11
		for(int i = 0; i < num; i++)
80007822:	16 9c       	mov	r12,r11
80007824:	58 0b       	cp.w	r11,0
80007826:	fe 9a ff f8 	brle	80007816 <PrintDec+0x94>
8000782a:	1a 99       	mov	r9,sp
8000782c:	1c 09       	add	r9,lr
8000782e:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80007830:	33 06       	mov	r6,48
80007832:	12 c6       	st.b	r9++,r6
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80007834:	2f f8       	sub	r8,-1
80007836:	18 38       	cp.w	r8,r12
80007838:	cf d5       	brlt	80007832 <PrintDec+0xb0>
{
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
8000783a:	f6 0e 00 0e 	add	lr,r11,lr
8000783e:	ce cb       	rjmp	80007816 <PrintDec+0x94>
80007840:	fa c8 ff f4 	sub	r8,sp,-12
80007844:	1c 08       	add	r8,lr
80007846:	20 d8       	sub	r8,13
80007848:	fa cb 00 01 	sub	r11,sp,1
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
	*p++ = s[--cnt];
8000784c:	11 89       	ld.ub	r9,r8[0x0]
8000784e:	0e c9       	st.b	r7++,r9
80007850:	20 18       	sub	r8,1
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80007852:	16 38       	cp.w	r8,r11
80007854:	cf c1       	brne	8000784c <PrintDec+0xca>
	*p++ = s[--cnt];
	
	return str;
}
80007856:	14 9c       	mov	r12,r10
80007858:	2f dd       	sub	sp,-12
8000785a:	d8 22       	popm	r4-r7,pc

8000785c <log>:
	,  NULL );
	
}

int log(char * content, ...)
{
8000785c:	d4 31       	pushm	r0-r7,lr
8000785e:	fa cd 02 08 	sub	sp,sp,520
80007862:	18 97       	mov	r7,r12
	
	
	char logTmp[MAX_LOG_LINE_SIZE];
	memset(logTmp, '\0', MAX_LOG_LINE_SIZE);	
80007864:	e0 6a 01 00 	mov	r10,256
80007868:	30 0b       	mov	r11,0
8000786a:	fa cc fe f8 	sub	r12,sp,-264
8000786e:	f0 1f 00 4e 	mcall	800079a4 <log+0x148>
	,  tskLOG_PRIORITY
	,  NULL );
	
}

int log(char * content, ...)
80007872:	fa c4 fd d4 	sub	r4,sp,-556
80007876:	30 0a       	mov	r10,0
80007878:	50 0a       	stdsp	sp[0x0],r10
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
8000787a:	fa c3 ff fc 	sub	r3,sp,-4
8000787e:	e0 61 01 00 	mov	r1,256
80007882:	14 90       	mov	r0,r10
			
					if(*str == '%')
80007884:	32 52       	mov	r2,37
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
80007886:	fa c6 fe f8 	sub	r6,sp,-264
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
8000788a:	02 9a       	mov	r10,r1
8000788c:	00 9b       	mov	r11,r0
8000788e:	06 9c       	mov	r12,r3
80007890:	f0 1f 00 45 	mcall	800079a4 <log+0x148>
			
					if(*str == '%')
80007894:	0f 88       	ld.ub	r8,r7[0x0]
80007896:	e4 08 18 00 	cp.b	r8,r2
8000789a:	c5 71       	brne	80007948 <log+0xec>
					{
						static char lench = 0;
						lench =*(str + 1);
8000789c:	ee c8 ff ff 	sub	r8,r7,-1
800078a0:	11 89       	ld.ub	r9,r8[0x0]
800078a2:	4c 2a       	lddpc	r10,800079a8 <log+0x14c>
800078a4:	b4 89       	st.b	r10[0x0],r9
						if((lench >= '0') &&  (lench <= '9'))
800078a6:	23 09       	sub	r9,48
800078a8:	30 9a       	mov	r10,9
800078aa:	f4 09 18 00 	cp.b	r9,r10
800078ae:	ee 08 17 b0 	movhi	r8,r7
						{
							len = *(++str) - '0';
800078b2:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
800078b6:	f7 b9 08 30 	subls	r9,48
800078ba:	fb f9 8a 00 	st.wls	sp[0x0],r9
						}
						
						str++;
800078be:	f0 c7 ff ff 	sub	r7,r8,-1
						
						switch(*(str))
800078c2:	0f 88       	ld.ub	r8,r7[0x0]
800078c4:	22 58       	sub	r8,37
800078c6:	e0 48 00 53 	cp.w	r8,83
800078ca:	e0 8b 00 31 	brhi	8000792c <log+0xd0>
800078ce:	4b 89       	lddpc	r9,800079ac <log+0x150>
800078d0:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
						{
							case('i'):
							case('I'):
							case('d'):
							case('D'):
							x = va_arg(arg_ptr,int);
800078d4:	e8 c5 ff fc 	sub	r5,r4,-4
							strTmp = PrintDec(x, len, strTmp);
800078d8:	06 9a       	mov	r10,r3
800078da:	40 0b       	lddsp	r11,sp[0x0]
800078dc:	5c 5b       	castu.b	r11
800078de:	68 0c       	ld.w	r12,r4[0x0]
800078e0:	f0 1f 00 34 	mcall	800079b0 <log+0x154>
							break;
800078e4:	c2 98       	rjmp	80007936 <log+0xda>
							
							case('f')://浮点数输出
							case('F'):
							//f = va_arg(arg_ptr,int);
							//strTmp = PrintDec(x, len, strTmp);
							log("I need float.");
800078e6:	4b 4c       	lddpc	r12,800079b4 <log+0x158>
800078e8:	f0 1f 00 34 	mcall	800079b8 <log+0x15c>
800078ec:	08 95       	mov	r5,r4
800078ee:	06 9c       	mov	r12,r3
							break;
800078f0:	c2 38       	rjmp	80007936 <log+0xda>
							
							
							case('x'):
							case('X'):
							x = va_arg(arg_ptr,int);
800078f2:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintHex(x,len, strTmp);
800078f6:	06 9a       	mov	r10,r3
800078f8:	40 0b       	lddsp	r11,sp[0x0]
800078fa:	5c 5b       	castu.b	r11
800078fc:	68 0c       	ld.w	r12,r4[0x0]
800078fe:	f0 1f 00 30 	mcall	800079bc <log+0x160>
80007902:	06 9c       	mov	r12,r3
							break;
80007904:	c1 98       	rjmp	80007936 <log+0xda>
							
							case('c'):
							case('C'):
							y = va_arg(arg_ptr,int);
80007906:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintChar(y, strTmp);
8000790a:	06 9b       	mov	r11,r3
8000790c:	09 bc       	ld.ub	r12,r4[0x3]
8000790e:	f0 1f 00 2d 	mcall	800079c0 <log+0x164>
80007912:	06 9c       	mov	r12,r3
							break;
80007914:	c1 18       	rjmp	80007936 <log+0xda>
							
							case('s'):
							case('S'):
							strTmp = va_arg(arg_ptr,char*);
80007916:	e8 c5 ff fc 	sub	r5,r4,-4
8000791a:	68 0c       	ld.w	r12,r4[0x0]
							//PrintStr(s);
							break;
8000791c:	c0 d8       	rjmp	80007936 <log+0xda>
							
							case('%'):
							PrintChar('%', strTmp);
8000791e:	06 9b       	mov	r11,r3
80007920:	32 5c       	mov	r12,37
80007922:	f0 1f 00 28 	mcall	800079c0 <log+0x164>
80007926:	08 95       	mov	r5,r4
80007928:	06 9c       	mov	r12,r3
							//PrintChar('%');
							break;
8000792a:	c0 68       	rjmp	80007936 <log+0xda>
							
							default:
							log("I need relax.");
8000792c:	4a 6c       	lddpc	r12,800079c4 <log+0x168>
8000792e:	f0 1f 00 23 	mcall	800079b8 <log+0x15c>
80007932:	08 95       	mov	r5,r4
80007934:	06 9c       	mov	r12,r3
						}
						str++;
80007936:	2f f7       	sub	r7,-1
						
						length = sprintf(logTmp,"%s%s",logTmp,strTmp );
80007938:	1a dc       	st.w	--sp,r12
8000793a:	1a d6       	st.w	--sp,r6
8000793c:	4a 3b       	lddpc	r11,800079c8 <log+0x16c>
8000793e:	0c 9c       	mov	r12,r6
80007940:	f0 1f 00 23 	mcall	800079cc <log+0x170>
80007944:	2f ed       	sub	sp,-8
80007946:	c0 a8       	rjmp	8000795a <log+0xfe>
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
80007948:	2f f7       	sub	r7,-1
8000794a:	1a d8       	st.w	--sp,r8
8000794c:	1a d6       	st.w	--sp,r6
8000794e:	4a 1b       	lddpc	r11,800079d0 <log+0x174>
80007950:	0c 9c       	mov	r12,r6
80007952:	f0 1f 00 1f 	mcall	800079cc <log+0x170>
80007956:	08 95       	mov	r5,r4
80007958:	2f ed       	sub	sp,-8
			
			
			
	}while(*str != '\0');
8000795a:	0f 89       	ld.ub	r9,r7[0x0]
8000795c:	30 08       	mov	r8,0
8000795e:	f0 09 18 00 	cp.b	r9,r8
80007962:	c0 30       	breq	80007968 <log+0x10c>
80007964:	0a 94       	mov	r4,r5
80007966:	c9 2b       	rjmp	8000788a <log+0x2e>
		
		
				
	va_end(arg_ptr);
	//while(1)		
	length = sprintf(logTmp,"%s\r\n",logTmp);
80007968:	fa c7 fe f8 	sub	r7,sp,-264
8000796c:	1a d7       	st.w	--sp,r7
8000796e:	49 ab       	lddpc	r11,800079d4 <log+0x178>
80007970:	0e 9c       	mov	r12,r7
80007972:	f0 1f 00 17 	mcall	800079cc <log+0x170>
	
	char * p = pvPortMalloc(length+1);
80007976:	5c 5c       	castu.b	r12
80007978:	f8 c6 ff ff 	sub	r6,r12,-1
8000797c:	0c 9c       	mov	r12,r6
8000797e:	f0 1f 00 17 	mcall	800079d8 <log+0x17c>
80007982:	54 2c       	stdsp	sp[0x108],r12
	memcpy(p, logTmp, length+1);
80007984:	0c 9a       	mov	r10,r6
80007986:	0e 9b       	mov	r11,r7
80007988:	f0 1f 00 15 	mcall	800079dc <log+0x180>
	//
	//usart_write_line(EXAMPLE_USART, logTmp)
	
	xQueueSend( logQueue, &p, 5);
8000798c:	30 09       	mov	r9,0
8000798e:	30 5a       	mov	r10,5
80007990:	fa cb fe f8 	sub	r11,sp,-264
80007994:	49 38       	lddpc	r8,800079e0 <log+0x184>
80007996:	70 0c       	ld.w	r12,r8[0x0]
80007998:	f0 1f 00 13 	mcall	800079e4 <log+0x188>
8000799c:	2f fd       	sub	sp,-4
	
	
}
8000799e:	fe 3d fd f8 	sub	sp,-520
800079a2:	d8 32       	popm	r0-r7,pc
800079a4:	80 00       	ld.sh	r0,r0[0x0]
800079a6:	82 4e       	ld.sh	lr,r1[0x8]
800079a8:	00 00       	add	r0,r0
800079aa:	0d c8       	ld.ub	r8,r6[0x4]
800079ac:	80 00       	ld.sh	r0,r0[0x0]
800079ae:	e3 90       	*unknown*
800079b0:	80 00       	ld.sh	r0,r0[0x0]
800079b2:	77 82       	ld.w	r2,r11[0x60]
800079b4:	80 00       	ld.sh	r0,r0[0x0]
800079b6:	e6 3c 80 00 	sub	r12,491520
800079ba:	78 5c       	ld.w	r12,r12[0x14]
800079bc:	80 00       	ld.sh	r0,r0[0x0]
800079be:	76 d0       	ld.w	r0,r11[0x34]
800079c0:	80 00       	ld.sh	r0,r0[0x0]
800079c2:	76 cc       	ld.w	r12,r11[0x30]
800079c4:	80 00       	ld.sh	r0,r0[0x0]
800079c6:	e6 4c 80 00 	cp.w	r12,425984
800079ca:	e6 5c 80 00 	cp.w	r12,491520
800079ce:	85 3c       	st.w	r2[0xc],r12
800079d0:	80 00       	ld.sh	r0,r0[0x0]
800079d2:	e6 64 80 00 	mov	r4,425984
800079d6:	e6 6c 80 00 	mov	r12,425984
800079da:	68 d0       	ld.w	r0,r4[0x34]
800079dc:	80 00       	ld.sh	r0,r0[0x0]
800079de:	81 06       	st.w	r0[0x0],r6
800079e0:	00 00       	add	r0,r0
800079e2:	54 30       	stdsp	sp[0x10c],r0
800079e4:	80 00       	ld.sh	r0,r0[0x0]
800079e6:	6c 24       	ld.w	r4,r6[0x8]

800079e8 <logFromISR>:
	
	
int logFromISR(char * content, ...)
	{
800079e8:	d4 31       	pushm	r0-r7,lr
800079ea:	fa cd 02 0c 	sub	sp,sp,524
800079ee:	18 97       	mov	r7,r12
		
		
		char logTmp[MAX_LOG_LINE_SIZE];
		memset(logTmp, '\0', MAX_LOG_LINE_SIZE);
800079f0:	e0 6a 01 00 	mov	r10,256
800079f4:	30 0b       	mov	r11,0
800079f6:	fa cc fe f4 	sub	r12,sp,-268
800079fa:	f0 1f 00 4c 	mcall	80007b28 <logFromISR+0x140>
	
	
}
	
	
int logFromISR(char * content, ...)
800079fe:	fa c4 fd d0 	sub	r4,sp,-560
80007a02:	30 0a       	mov	r10,0
80007a04:	50 0a       	stdsp	sp[0x0],r10
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80007a06:	fa c3 ff fc 	sub	r3,sp,-4
80007a0a:	e0 61 01 00 	mov	r1,256
80007a0e:	14 90       	mov	r0,r10
			
			if(*str == '%')
80007a10:	32 52       	mov	r2,37
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
80007a12:	fa c6 fe f4 	sub	r6,sp,-268
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80007a16:	02 9a       	mov	r10,r1
80007a18:	00 9b       	mov	r11,r0
80007a1a:	06 9c       	mov	r12,r3
80007a1c:	f0 1f 00 43 	mcall	80007b28 <logFromISR+0x140>
			
			if(*str == '%')
80007a20:	0f 88       	ld.ub	r8,r7[0x0]
80007a22:	e4 08 18 00 	cp.b	r8,r2
80007a26:	c5 11       	brne	80007ac8 <logFromISR+0xe0>
			{
				static char lench = 0;
				lench =*(str + 1);
80007a28:	ee c8 ff ff 	sub	r8,r7,-1
80007a2c:	11 89       	ld.ub	r9,r8[0x0]
80007a2e:	4c 0a       	lddpc	r10,80007b2c <logFromISR+0x144>
80007a30:	b4 89       	st.b	r10[0x0],r9
				if((lench >= '0') &&  (lench <= '9'))
80007a32:	23 09       	sub	r9,48
80007a34:	30 9a       	mov	r10,9
80007a36:	f4 09 18 00 	cp.b	r9,r10
80007a3a:	ee 08 17 b0 	movhi	r8,r7
				{
					len = *(++str) - '0';
80007a3e:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
80007a42:	f7 b9 08 30 	subls	r9,48
80007a46:	fb f9 8a 00 	st.wls	sp[0x0],r9
				}
				
				str++;
80007a4a:	f0 c7 ff ff 	sub	r7,r8,-1
				
				switch(*(str))
80007a4e:	0f 88       	ld.ub	r8,r7[0x0]
80007a50:	22 58       	sub	r8,37
80007a52:	e0 48 00 53 	cp.w	r8,83
80007a56:	e0 8b 00 2b 	brhi	80007aac <logFromISR+0xc4>
80007a5a:	4b 69       	lddpc	r9,80007b30 <logFromISR+0x148>
80007a5c:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
				{
					case('d'):
					case('D'):
					x = va_arg(arg_ptr,int);
80007a60:	e8 c5 ff fc 	sub	r5,r4,-4
					strTmp = PrintDec(x, len, strTmp);
80007a64:	06 9a       	mov	r10,r3
80007a66:	40 0b       	lddsp	r11,sp[0x0]
80007a68:	5c 5b       	castu.b	r11
80007a6a:	68 0c       	ld.w	r12,r4[0x0]
80007a6c:	f0 1f 00 32 	mcall	80007b34 <logFromISR+0x14c>
					break;
80007a70:	c2 38       	rjmp	80007ab6 <logFromISR+0xce>
					case('x'):
					case('X'):
					x = va_arg(arg_ptr,int);
80007a72:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintHex(x,len, strTmp);
80007a76:	06 9a       	mov	r10,r3
80007a78:	40 0b       	lddsp	r11,sp[0x0]
80007a7a:	5c 5b       	castu.b	r11
80007a7c:	68 0c       	ld.w	r12,r4[0x0]
80007a7e:	f0 1f 00 2f 	mcall	80007b38 <logFromISR+0x150>
80007a82:	06 9c       	mov	r12,r3
					break;
80007a84:	c1 98       	rjmp	80007ab6 <logFromISR+0xce>
					case('c'):
					case('C'):
					y = va_arg(arg_ptr,int);
80007a86:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintChar(y, strTmp);
80007a8a:	06 9b       	mov	r11,r3
80007a8c:	09 bc       	ld.ub	r12,r4[0x3]
80007a8e:	f0 1f 00 2c 	mcall	80007b3c <logFromISR+0x154>
80007a92:	06 9c       	mov	r12,r3
					break;
80007a94:	c1 18       	rjmp	80007ab6 <logFromISR+0xce>
					case('s'):
					case('S'):
					strTmp = va_arg(arg_ptr,char*);
80007a96:	e8 c5 ff fc 	sub	r5,r4,-4
80007a9a:	68 0c       	ld.w	r12,r4[0x0]
					//PrintStr(s);
					break;
80007a9c:	c0 d8       	rjmp	80007ab6 <logFromISR+0xce>
					case('%'):
					PrintChar('%', strTmp);
80007a9e:	06 9b       	mov	r11,r3
80007aa0:	32 5c       	mov	r12,37
80007aa2:	f0 1f 00 27 	mcall	80007b3c <logFromISR+0x154>
80007aa6:	08 95       	mov	r5,r4
80007aa8:	06 9c       	mov	r12,r3
					//PrintChar('%');
					break;
80007aaa:	c0 68       	rjmp	80007ab6 <logFromISR+0xce>
					default:
					log("I need relax.");
80007aac:	4a 5c       	lddpc	r12,80007b40 <logFromISR+0x158>
80007aae:	f0 1f 00 26 	mcall	80007b44 <logFromISR+0x15c>
80007ab2:	08 95       	mov	r5,r4
80007ab4:	06 9c       	mov	r12,r3
				}
				str++;
80007ab6:	2f f7       	sub	r7,-1
				
				length = sprintf(logTmp,"%s%s",logTmp,strTmp );
80007ab8:	1a dc       	st.w	--sp,r12
80007aba:	1a d6       	st.w	--sp,r6
80007abc:	4a 3b       	lddpc	r11,80007b48 <logFromISR+0x160>
80007abe:	0c 9c       	mov	r12,r6
80007ac0:	f0 1f 00 23 	mcall	80007b4c <logFromISR+0x164>
80007ac4:	2f ed       	sub	sp,-8
80007ac6:	c0 a8       	rjmp	80007ada <logFromISR+0xf2>
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
80007ac8:	2f f7       	sub	r7,-1
80007aca:	1a d8       	st.w	--sp,r8
80007acc:	1a d6       	st.w	--sp,r6
80007ace:	4a 1b       	lddpc	r11,80007b50 <logFromISR+0x168>
80007ad0:	0c 9c       	mov	r12,r6
80007ad2:	f0 1f 00 1f 	mcall	80007b4c <logFromISR+0x164>
80007ad6:	08 95       	mov	r5,r4
80007ad8:	2f ed       	sub	sp,-8
			
			
			
		}while(*str != '\0');
80007ada:	0f 89       	ld.ub	r9,r7[0x0]
80007adc:	30 08       	mov	r8,0
80007ade:	f0 09 18 00 	cp.b	r9,r8
80007ae2:	c0 30       	breq	80007ae8 <logFromISR+0x100>
80007ae4:	0a 94       	mov	r4,r5
80007ae6:	c9 8b       	rjmp	80007a16 <logFromISR+0x2e>
		
		
		
		va_end(arg_ptr);
		//while(1)
		length = sprintf(logTmp,"%s\r\n",logTmp);
80007ae8:	fa c7 fe f4 	sub	r7,sp,-268
80007aec:	1a d7       	st.w	--sp,r7
80007aee:	49 ab       	lddpc	r11,80007b54 <logFromISR+0x16c>
80007af0:	0e 9c       	mov	r12,r7
80007af2:	f0 1f 00 17 	mcall	80007b4c <logFromISR+0x164>
		
		char * p = pvPortMalloc(length+1);
80007af6:	5c 5c       	castu.b	r12
80007af8:	f8 c6 ff ff 	sub	r6,r12,-1
80007afc:	0c 9c       	mov	r12,r6
80007afe:	f0 1f 00 17 	mcall	80007b58 <logFromISR+0x170>
80007b02:	54 3c       	stdsp	sp[0x10c],r12
		memcpy(p, logTmp, length+1);
80007b04:	0c 9a       	mov	r10,r6
80007b06:	0e 9b       	mov	r11,r7
80007b08:	f0 1f 00 15 	mcall	80007b5c <logFromISR+0x174>
		//
		portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80007b0c:	30 09       	mov	r9,0
80007b0e:	54 29       	stdsp	sp[0x108],r9
		
		//usart_write_line(EXAMPLE_USART, p);
		//vPortFree(p);
		xQueueSendFromISR( logQueue, &p, &xHigherPriorityTaskWoken );
80007b10:	fa ca fe f8 	sub	r10,sp,-264
80007b14:	fa cb fe f4 	sub	r11,sp,-268
80007b18:	49 28       	lddpc	r8,80007b60 <logFromISR+0x178>
80007b1a:	70 0c       	ld.w	r12,r8[0x0]
80007b1c:	f0 1f 00 12 	mcall	80007b64 <logFromISR+0x17c>
80007b20:	2f fd       	sub	sp,-4
		
		//if (xHigherPriorityTaskWoken == pdTRUE)
		//{
			////taskYIELD();
		//}
	}
80007b22:	fe 3d fd f4 	sub	sp,-524
80007b26:	d8 32       	popm	r0-r7,pc
80007b28:	80 00       	ld.sh	r0,r0[0x0]
80007b2a:	82 4e       	ld.sh	lr,r1[0x8]
80007b2c:	00 00       	add	r0,r0
80007b2e:	0d c9       	ld.ub	r9,r6[0x4]
80007b30:	80 00       	ld.sh	r0,r0[0x0]
80007b32:	e4 e0 80 00 	ld.d	r0,r2[-32768]
80007b36:	77 82       	ld.w	r2,r11[0x60]
80007b38:	80 00       	ld.sh	r0,r0[0x0]
80007b3a:	76 d0       	ld.w	r0,r11[0x34]
80007b3c:	80 00       	ld.sh	r0,r0[0x0]
80007b3e:	76 cc       	ld.w	r12,r11[0x30]
80007b40:	80 00       	ld.sh	r0,r0[0x0]
80007b42:	e6 4c 80 00 	cp.w	r12,425984
80007b46:	78 5c       	ld.w	r12,r12[0x14]
80007b48:	80 00       	ld.sh	r0,r0[0x0]
80007b4a:	e6 5c 80 00 	cp.w	r12,491520
80007b4e:	85 3c       	st.w	r2[0xc],r12
80007b50:	80 00       	ld.sh	r0,r0[0x0]
80007b52:	e6 64 80 00 	mov	r4,425984
80007b56:	e6 6c 80 00 	mov	r12,425984
80007b5a:	68 d0       	ld.w	r0,r4[0x34]
80007b5c:	80 00       	ld.sh	r0,r0[0x0]
80007b5e:	81 06       	st.w	r0[0x0],r6
80007b60:	00 00       	add	r0,r0
80007b62:	54 30       	stdsp	sp[0x10c],r0
80007b64:	80 00       	ld.sh	r0,r0[0x0]
80007b66:	6b d4       	ld.w	r4,r5[0x74]

80007b68 <log_init>:
		
	return str;
}

void log_init(void)
{
80007b68:	d4 01       	pushm	lr
		.stopbits     = USART_1_STOPBIT,
		.channelmode  = USART_NORMAL_CHMODE
	};

	// Assign GPIO to USART.
	gpio_enable_module(USART_GPIO_MAP,
80007b6a:	30 2b       	mov	r11,2
80007b6c:	48 fc       	lddpc	r12,80007ba8 <log_init+0x40>
80007b6e:	f0 1f 00 10 	mcall	80007bac <log_init+0x44>
	sizeof(USART_GPIO_MAP) / sizeof(USART_GPIO_MAP[0]));

	// Initialize USART in RS232 mode.
	usart_init_rs232(EXAMPLE_USART, &USART_OPTIONS, EXAMPLE_TARGET_PBACLK_FREQ_HZ);			
80007b72:	e0 6a 36 00 	mov	r10,13824
80007b76:	ea 1a 01 6e 	orh	r10,0x16e
80007b7a:	48 eb       	lddpc	r11,80007bb0 <log_init+0x48>
80007b7c:	fe 7c 18 00 	mov	r12,-59392
80007b80:	f0 1f 00 0d 	mcall	80007bb4 <log_init+0x4c>
			
	logQueue  = xQueueCreate(50, sizeof(char *));
80007b84:	30 4b       	mov	r11,4
80007b86:	33 2c       	mov	r12,50
80007b88:	f0 1f 00 0c 	mcall	80007bb8 <log_init+0x50>
80007b8c:	48 c8       	lddpc	r8,80007bbc <log_init+0x54>
80007b8e:	91 0c       	st.w	r8[0x0],r12
	
	xTaskCreate(
80007b90:	30 09       	mov	r9,0
80007b92:	1a d9       	st.w	--sp,r9
80007b94:	1a d9       	st.w	--sp,r9
80007b96:	1a d9       	st.w	--sp,r9
80007b98:	30 28       	mov	r8,2
80007b9a:	36 4a       	mov	r10,100
80007b9c:	48 9b       	lddpc	r11,80007bc0 <log_init+0x58>
80007b9e:	48 ac       	lddpc	r12,80007bc4 <log_init+0x5c>
80007ba0:	f0 1f 00 0a 	mcall	80007bc8 <log_init+0x60>
80007ba4:	2f dd       	sub	sp,-12
	,  100//384
	,  NULL
	,  tskLOG_PRIORITY
	,  NULL );
	
}
80007ba6:	d8 02       	popm	pc
80007ba8:	80 00       	ld.sh	r0,r0[0x0]
80007baa:	e6 78 80 00 	mov	r8,491520
80007bae:	5c 40       	abs	r0
80007bb0:	80 00       	ld.sh	r0,r0[0x0]
80007bb2:	e6 30 80 00 	sub	r0,491520
80007bb6:	64 34       	ld.w	r4,r2[0xc]
80007bb8:	80 00       	ld.sh	r0,r0[0x0]
80007bba:	6d 7c       	ld.w	r12,r6[0x5c]
80007bbc:	00 00       	add	r0,r0
80007bbe:	54 30       	stdsp	sp[0x10c],r0
80007bc0:	80 00       	ld.sh	r0,r0[0x0]
80007bc2:	e6 74 80 00 	mov	r4,491520
80007bc6:	7b cc       	ld.w	r12,sp[0x70]
80007bc8:	80 00       	ld.sh	r0,r0[0x0]
80007bca:	74 98       	ld.w	r8,r10[0x24]

80007bcc <task_log>:
			////taskYIELD();
		//}
	}
//portTickType log_water_value =0;	
static void task_log(void * pvParameters)
{
80007bcc:	eb cd 40 f8 	pushm	r3-r7,lr
80007bd0:	20 1d       	sub	sp,4
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		//log_water_value = uxTaskGetStackHighWaterMark(NULL);
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
80007bd2:	48 c7       	lddpc	r7,80007c00 <task_log+0x34>
80007bd4:	30 05       	mov	r5,0
80007bd6:	3f f4       	mov	r4,-1
		{
			if( NULL != str)
			{
				usart_write_line(EXAMPLE_USART, str);
80007bd8:	fe 73 18 00 	mov	r3,-59392
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		//log_water_value = uxTaskGetStackHighWaterMark(NULL);
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
80007bdc:	0a 99       	mov	r9,r5
80007bde:	08 9a       	mov	r10,r4
80007be0:	1a 9b       	mov	r11,sp
80007be2:	6e 0c       	ld.w	r12,r7[0x0]
80007be4:	f0 1f 00 08 	mcall	80007c04 <task_log+0x38>
80007be8:	58 1c       	cp.w	r12,1
80007bea:	cf 91       	brne	80007bdc <task_log+0x10>
		{
			if( NULL != str)
80007bec:	40 0b       	lddsp	r11,sp[0x0]
80007bee:	58 0b       	cp.w	r11,0
80007bf0:	cf 60       	breq	80007bdc <task_log+0x10>
			{
				usart_write_line(EXAMPLE_USART, str);
80007bf2:	06 9c       	mov	r12,r3
80007bf4:	f0 1f 00 05 	mcall	80007c08 <task_log+0x3c>
				vPortFree(str);
80007bf8:	40 0c       	lddsp	r12,sp[0x0]
80007bfa:	f0 1f 00 05 	mcall	80007c0c <task_log+0x40>
80007bfe:	ce fb       	rjmp	80007bdc <task_log+0x10>
80007c00:	00 00       	add	r0,r0
80007c02:	54 30       	stdsp	sp[0x10c],r0
80007c04:	80 00       	ld.sh	r0,r0[0x0]
80007c06:	6a 18       	ld.w	r8,r5[0x4]
80007c08:	80 00       	ld.sh	r0,r0[0x0]
80007c0a:	63 e4       	ld.w	r4,r1[0x78]
80007c0c:	80 00       	ld.sh	r0,r0[0x0]
80007c0e:	68 a8       	ld.w	r8,r4[0x28]

80007c10 <main>:
#include "xgflash.h"
#include "app.h"


int main (void)
{
80007c10:	d4 01       	pushm	lr
	
	//Force SSC_TX_DATA_ENABLE Disabled as soon as possible.
	AVR32_GPIO.port[1].ovrs  =  0x00000001;  //Value will be high.
80007c12:	fe 78 10 00 	mov	r8,-61440
80007c16:	30 19       	mov	r9,1
80007c18:	f1 49 01 54 	st.w	r8[340],r9
	AVR32_GPIO.port[1].oders =  0x00000001;  //Output Driver will be Enabled.
80007c1c:	f1 49 01 44 	st.w	r8[324],r9
	AVR32_GPIO.port[1].gpers =  0x00000001;  //Enable as GPIO.
80007c20:	f1 49 01 04 	st.w	r8[260],r9
		
	Disable_global_interrupt();
80007c24:	d3 03       	ssrf	0x10
	local_start_pll0();
80007c26:	f0 1f 00 0d 	mcall	80007c58 <main+0x48>
		
	INTC_init_interrupts();
80007c2a:	f0 1f 00 0d 	mcall	80007c5c <main+0x4c>
		
	log_init();
80007c2e:	f0 1f 00 0d 	mcall	80007c60 <main+0x50>
	log("----start debug----");
80007c32:	48 dc       	lddpc	r12,80007c64 <main+0x54>
80007c34:	f0 1f 00 0d 	mcall	80007c68 <main+0x58>
	
	xg_flashc_init();
80007c38:	f0 1f 00 0d 	mcall	80007c6c <main+0x5c>
		
	//voc_init();

	//tc_init();
	
	rfid_init();
80007c3c:	f0 1f 00 0d 	mcall	80007c70 <main+0x60>
		
	app_init();
80007c40:	f0 1f 00 0d 	mcall	80007c74 <main+0x64>
	
	xg_rtc_init();
80007c44:	f0 1f 00 0d 	mcall	80007c78 <main+0x68>
		
	xcmp_init();
80007c48:	f0 1f 00 0d 	mcall	80007c7c <main+0x6c>

	local_start_timer();
80007c4c:	f0 1f 00 0d 	mcall	80007c80 <main+0x70>
		
	vTaskStartScheduler();
80007c50:	f0 1f 00 0d 	mcall	80007c84 <main+0x74>
	return 0;
	
}
80007c54:	d8 0a       	popm	pc,r12=0
80007c56:	00 00       	add	r0,r0
80007c58:	80 00       	ld.sh	r0,r0[0x0]
80007c5a:	58 d8       	cp.w	r8,13
80007c5c:	80 00       	ld.sh	r0,r0[0x0]
80007c5e:	5d 44       	*unknown*
80007c60:	80 00       	ld.sh	r0,r0[0x0]
80007c62:	7b 68       	ld.w	r8,sp[0x58]
80007c64:	80 00       	ld.sh	r0,r0[0x0]
80007c66:	e6 88 80 00 	brls	800d7c66 <_data_lma+0xc9046>
80007c6a:	78 5c       	ld.w	r12,r12[0x14]
80007c6c:	80 00       	ld.sh	r0,r0[0x0]
80007c6e:	59 6c       	cp.w	r12,22
80007c70:	80 00       	ld.sh	r0,r0[0x0]
80007c72:	58 38       	cp.w	r8,3
80007c74:	80 00       	ld.sh	r0,r0[0x0]
80007c76:	20 3c       	sub	r12,3
80007c78:	80 00       	ld.sh	r0,r0[0x0]
80007c7a:	30 10       	mov	r0,1
80007c7c:	80 00       	ld.sh	r0,r0[0x0]
80007c7e:	46 ec       	lddsp	r12,sp[0x1b8]
80007c80:	80 00       	ld.sh	r0,r0[0x0]
80007c82:	58 ac       	cp.w	r12,10
80007c84:	80 00       	ld.sh	r0,r0[0x0]
80007c86:	76 80       	ld.w	r0,r11[0x20]

80007c88 <free>:
80007c88:	d4 01       	pushm	lr
80007c8a:	e0 68 0a 4c 	mov	r8,2636
80007c8e:	18 9b       	mov	r11,r12
80007c90:	70 0c       	ld.w	r12,r8[0x0]
80007c92:	e0 a0 1e 73 	rcall	8000b978 <_free_r>
80007c96:	d8 02       	popm	pc

80007c98 <malloc>:
80007c98:	d4 01       	pushm	lr
80007c9a:	e0 68 0a 4c 	mov	r8,2636
80007c9e:	18 9b       	mov	r11,r12
80007ca0:	70 0c       	ld.w	r12,r8[0x0]
80007ca2:	c0 3c       	rcall	80007ca8 <_malloc_r>
80007ca4:	d8 02       	popm	pc
80007ca6:	d7 03       	nop

80007ca8 <_malloc_r>:
80007ca8:	d4 31       	pushm	r0-r7,lr
80007caa:	f6 c8 ff f5 	sub	r8,r11,-11
80007cae:	18 95       	mov	r5,r12
80007cb0:	10 97       	mov	r7,r8
80007cb2:	e0 17 ff f8 	andl	r7,0xfff8
80007cb6:	59 68       	cp.w	r8,22
80007cb8:	f9 b7 08 10 	movls	r7,16
80007cbc:	16 37       	cp.w	r7,r11
80007cbe:	5f 38       	srlo	r8
80007cc0:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
80007cc4:	c0 50       	breq	80007cce <_malloc_r+0x26>
80007cc6:	30 c8       	mov	r8,12
80007cc8:	99 38       	st.w	r12[0xc],r8
80007cca:	e0 8f 01 fa 	bral	800080be <_malloc_r+0x416>
80007cce:	fe b0 f5 a3 	rcall	80006814 <__malloc_lock>
80007cd2:	e0 47 01 f7 	cp.w	r7,503
80007cd6:	e0 8b 00 1d 	brhi	80007d10 <_malloc_r+0x68>
80007cda:	ee 03 16 03 	lsr	r3,r7,0x3
80007cde:	e0 68 05 4c 	mov	r8,1356
80007ce2:	f0 03 00 38 	add	r8,r8,r3<<0x3
80007ce6:	70 36       	ld.w	r6,r8[0xc]
80007ce8:	10 36       	cp.w	r6,r8
80007cea:	c0 61       	brne	80007cf6 <_malloc_r+0x4e>
80007cec:	ec c8 ff f8 	sub	r8,r6,-8
80007cf0:	70 36       	ld.w	r6,r8[0xc]
80007cf2:	10 36       	cp.w	r6,r8
80007cf4:	c0 c0       	breq	80007d0c <_malloc_r+0x64>
80007cf6:	6c 18       	ld.w	r8,r6[0x4]
80007cf8:	e0 18 ff fc 	andl	r8,0xfffc
80007cfc:	6c 3a       	ld.w	r10,r6[0xc]
80007cfe:	ec 08 00 09 	add	r9,r6,r8
80007d02:	0a 9c       	mov	r12,r5
80007d04:	6c 28       	ld.w	r8,r6[0x8]
80007d06:	95 28       	st.w	r10[0x8],r8
80007d08:	91 3a       	st.w	r8[0xc],r10
80007d0a:	c4 78       	rjmp	80007d98 <_malloc_r+0xf0>
80007d0c:	2f e3       	sub	r3,-2
80007d0e:	c4 d8       	rjmp	80007da8 <_malloc_r+0x100>
80007d10:	ee 03 16 09 	lsr	r3,r7,0x9
80007d14:	c0 41       	brne	80007d1c <_malloc_r+0x74>
80007d16:	ee 03 16 03 	lsr	r3,r7,0x3
80007d1a:	c2 68       	rjmp	80007d66 <_malloc_r+0xbe>
80007d1c:	58 43       	cp.w	r3,4
80007d1e:	e0 8b 00 06 	brhi	80007d2a <_malloc_r+0x82>
80007d22:	ee 03 16 06 	lsr	r3,r7,0x6
80007d26:	2c 83       	sub	r3,-56
80007d28:	c1 f8       	rjmp	80007d66 <_malloc_r+0xbe>
80007d2a:	59 43       	cp.w	r3,20
80007d2c:	e0 8b 00 04 	brhi	80007d34 <_malloc_r+0x8c>
80007d30:	2a 53       	sub	r3,-91
80007d32:	c1 a8       	rjmp	80007d66 <_malloc_r+0xbe>
80007d34:	e0 43 00 54 	cp.w	r3,84
80007d38:	e0 8b 00 06 	brhi	80007d44 <_malloc_r+0x9c>
80007d3c:	ee 03 16 0c 	lsr	r3,r7,0xc
80007d40:	29 23       	sub	r3,-110
80007d42:	c1 28       	rjmp	80007d66 <_malloc_r+0xbe>
80007d44:	e0 43 01 54 	cp.w	r3,340
80007d48:	e0 8b 00 06 	brhi	80007d54 <_malloc_r+0xac>
80007d4c:	ee 03 16 0f 	lsr	r3,r7,0xf
80007d50:	28 93       	sub	r3,-119
80007d52:	c0 a8       	rjmp	80007d66 <_malloc_r+0xbe>
80007d54:	e0 43 05 54 	cp.w	r3,1364
80007d58:	e0 88 00 04 	brls	80007d60 <_malloc_r+0xb8>
80007d5c:	37 e3       	mov	r3,126
80007d5e:	c0 48       	rjmp	80007d66 <_malloc_r+0xbe>
80007d60:	ee 03 16 12 	lsr	r3,r7,0x12
80007d64:	28 43       	sub	r3,-124
80007d66:	e0 6a 05 4c 	mov	r10,1356
80007d6a:	f4 03 00 3a 	add	r10,r10,r3<<0x3
80007d6e:	74 36       	ld.w	r6,r10[0xc]
80007d70:	c1 98       	rjmp	80007da2 <_malloc_r+0xfa>
80007d72:	6c 19       	ld.w	r9,r6[0x4]
80007d74:	e0 19 ff fc 	andl	r9,0xfffc
80007d78:	f2 07 01 0b 	sub	r11,r9,r7
80007d7c:	58 fb       	cp.w	r11,15
80007d7e:	e0 8a 00 04 	brle	80007d86 <_malloc_r+0xde>
80007d82:	20 13       	sub	r3,1
80007d84:	c1 18       	rjmp	80007da6 <_malloc_r+0xfe>
80007d86:	6c 38       	ld.w	r8,r6[0xc]
80007d88:	58 0b       	cp.w	r11,0
80007d8a:	c0 b5       	brlt	80007da0 <_malloc_r+0xf8>
80007d8c:	6c 2a       	ld.w	r10,r6[0x8]
80007d8e:	ec 09 00 09 	add	r9,r6,r9
80007d92:	0a 9c       	mov	r12,r5
80007d94:	91 2a       	st.w	r8[0x8],r10
80007d96:	95 38       	st.w	r10[0xc],r8
80007d98:	72 18       	ld.w	r8,r9[0x4]
80007d9a:	a1 a8       	sbr	r8,0x0
80007d9c:	93 18       	st.w	r9[0x4],r8
80007d9e:	cb c8       	rjmp	80007f16 <_malloc_r+0x26e>
80007da0:	10 96       	mov	r6,r8
80007da2:	14 36       	cp.w	r6,r10
80007da4:	ce 71       	brne	80007d72 <_malloc_r+0xca>
80007da6:	2f f3       	sub	r3,-1
80007da8:	e0 6a 05 4c 	mov	r10,1356
80007dac:	f4 cc ff f8 	sub	r12,r10,-8
80007db0:	78 26       	ld.w	r6,r12[0x8]
80007db2:	18 36       	cp.w	r6,r12
80007db4:	c6 c0       	breq	80007e8c <_malloc_r+0x1e4>
80007db6:	6c 19       	ld.w	r9,r6[0x4]
80007db8:	e0 19 ff fc 	andl	r9,0xfffc
80007dbc:	f2 07 01 08 	sub	r8,r9,r7
80007dc0:	58 f8       	cp.w	r8,15
80007dc2:	e0 89 00 8f 	brgt	80007ee0 <_malloc_r+0x238>
80007dc6:	99 3c       	st.w	r12[0xc],r12
80007dc8:	99 2c       	st.w	r12[0x8],r12
80007dca:	58 08       	cp.w	r8,0
80007dcc:	c0 55       	brlt	80007dd6 <_malloc_r+0x12e>
80007dce:	ec 09 00 09 	add	r9,r6,r9
80007dd2:	0a 9c       	mov	r12,r5
80007dd4:	ce 2b       	rjmp	80007d98 <_malloc_r+0xf0>
80007dd6:	e0 49 01 ff 	cp.w	r9,511
80007dda:	e0 8b 00 13 	brhi	80007e00 <_malloc_r+0x158>
80007dde:	a3 99       	lsr	r9,0x3
80007de0:	f4 09 00 38 	add	r8,r10,r9<<0x3
80007de4:	70 2b       	ld.w	r11,r8[0x8]
80007de6:	8d 38       	st.w	r6[0xc],r8
80007de8:	8d 2b       	st.w	r6[0x8],r11
80007dea:	97 36       	st.w	r11[0xc],r6
80007dec:	91 26       	st.w	r8[0x8],r6
80007dee:	a3 49       	asr	r9,0x2
80007df0:	74 18       	ld.w	r8,r10[0x4]
80007df2:	30 1b       	mov	r11,1
80007df4:	f6 09 09 49 	lsl	r9,r11,r9
80007df8:	f1 e9 10 09 	or	r9,r8,r9
80007dfc:	95 19       	st.w	r10[0x4],r9
80007dfe:	c4 78       	rjmp	80007e8c <_malloc_r+0x1e4>
80007e00:	f2 0a 16 09 	lsr	r10,r9,0x9
80007e04:	58 4a       	cp.w	r10,4
80007e06:	e0 8b 00 07 	brhi	80007e14 <_malloc_r+0x16c>
80007e0a:	f2 0a 16 06 	lsr	r10,r9,0x6
80007e0e:	2c 8a       	sub	r10,-56
80007e10:	c2 08       	rjmp	80007e50 <_malloc_r+0x1a8>
80007e12:	d7 03       	nop
80007e14:	59 4a       	cp.w	r10,20
80007e16:	e0 8b 00 04 	brhi	80007e1e <_malloc_r+0x176>
80007e1a:	2a 5a       	sub	r10,-91
80007e1c:	c1 a8       	rjmp	80007e50 <_malloc_r+0x1a8>
80007e1e:	e0 4a 00 54 	cp.w	r10,84
80007e22:	e0 8b 00 06 	brhi	80007e2e <_malloc_r+0x186>
80007e26:	f2 0a 16 0c 	lsr	r10,r9,0xc
80007e2a:	29 2a       	sub	r10,-110
80007e2c:	c1 28       	rjmp	80007e50 <_malloc_r+0x1a8>
80007e2e:	e0 4a 01 54 	cp.w	r10,340
80007e32:	e0 8b 00 06 	brhi	80007e3e <_malloc_r+0x196>
80007e36:	f2 0a 16 0f 	lsr	r10,r9,0xf
80007e3a:	28 9a       	sub	r10,-119
80007e3c:	c0 a8       	rjmp	80007e50 <_malloc_r+0x1a8>
80007e3e:	e0 4a 05 54 	cp.w	r10,1364
80007e42:	e0 88 00 04 	brls	80007e4a <_malloc_r+0x1a2>
80007e46:	37 ea       	mov	r10,126
80007e48:	c0 48       	rjmp	80007e50 <_malloc_r+0x1a8>
80007e4a:	f2 0a 16 12 	lsr	r10,r9,0x12
80007e4e:	28 4a       	sub	r10,-124
80007e50:	e0 6b 05 4c 	mov	r11,1356
80007e54:	f6 0a 00 34 	add	r4,r11,r10<<0x3
80007e58:	68 28       	ld.w	r8,r4[0x8]
80007e5a:	08 38       	cp.w	r8,r4
80007e5c:	c0 e1       	brne	80007e78 <_malloc_r+0x1d0>
80007e5e:	76 19       	ld.w	r9,r11[0x4]
80007e60:	a3 4a       	asr	r10,0x2
80007e62:	30 1e       	mov	lr,1
80007e64:	fc 0a 09 4a 	lsl	r10,lr,r10
80007e68:	f3 ea 10 0a 	or	r10,r9,r10
80007e6c:	10 99       	mov	r9,r8
80007e6e:	97 1a       	st.w	r11[0x4],r10
80007e70:	c0 a8       	rjmp	80007e84 <_malloc_r+0x1dc>
80007e72:	70 28       	ld.w	r8,r8[0x8]
80007e74:	08 38       	cp.w	r8,r4
80007e76:	c0 60       	breq	80007e82 <_malloc_r+0x1da>
80007e78:	70 1a       	ld.w	r10,r8[0x4]
80007e7a:	e0 1a ff fc 	andl	r10,0xfffc
80007e7e:	14 39       	cp.w	r9,r10
80007e80:	cf 93       	brcs	80007e72 <_malloc_r+0x1ca>
80007e82:	70 39       	ld.w	r9,r8[0xc]
80007e84:	8d 39       	st.w	r6[0xc],r9
80007e86:	8d 28       	st.w	r6[0x8],r8
80007e88:	91 36       	st.w	r8[0xc],r6
80007e8a:	93 26       	st.w	r9[0x8],r6
80007e8c:	e6 08 14 02 	asr	r8,r3,0x2
80007e90:	30 1b       	mov	r11,1
80007e92:	e0 64 05 4c 	mov	r4,1356
80007e96:	f6 08 09 4b 	lsl	r11,r11,r8
80007e9a:	68 18       	ld.w	r8,r4[0x4]
80007e9c:	10 3b       	cp.w	r11,r8
80007e9e:	e0 8b 00 6b 	brhi	80007f74 <_malloc_r+0x2cc>
80007ea2:	f7 e8 00 09 	and	r9,r11,r8
80007ea6:	c0 b1       	brne	80007ebc <_malloc_r+0x214>
80007ea8:	e0 13 ff fc 	andl	r3,0xfffc
80007eac:	a1 7b       	lsl	r11,0x1
80007eae:	2f c3       	sub	r3,-4
80007eb0:	c0 38       	rjmp	80007eb6 <_malloc_r+0x20e>
80007eb2:	2f c3       	sub	r3,-4
80007eb4:	a1 7b       	lsl	r11,0x1
80007eb6:	f7 e8 00 09 	and	r9,r11,r8
80007eba:	cf c0       	breq	80007eb2 <_malloc_r+0x20a>
80007ebc:	e8 03 00 3e 	add	lr,r4,r3<<0x3
80007ec0:	06 92       	mov	r2,r3
80007ec2:	1c 91       	mov	r1,lr
80007ec4:	62 36       	ld.w	r6,r1[0xc]
80007ec6:	c2 e8       	rjmp	80007f22 <_malloc_r+0x27a>
80007ec8:	6c 1a       	ld.w	r10,r6[0x4]
80007eca:	e0 1a ff fc 	andl	r10,0xfffc
80007ece:	f4 07 01 08 	sub	r8,r10,r7
80007ed2:	58 f8       	cp.w	r8,15
80007ed4:	e0 8a 00 15 	brle	80007efe <_malloc_r+0x256>
80007ed8:	6c 3a       	ld.w	r10,r6[0xc]
80007eda:	6c 29       	ld.w	r9,r6[0x8]
80007edc:	95 29       	st.w	r10[0x8],r9
80007ede:	93 3a       	st.w	r9[0xc],r10
80007ee0:	0e 99       	mov	r9,r7
80007ee2:	ec 07 00 07 	add	r7,r6,r7
80007ee6:	a1 a9       	sbr	r9,0x0
80007ee8:	99 37       	st.w	r12[0xc],r7
80007eea:	99 27       	st.w	r12[0x8],r7
80007eec:	8d 19       	st.w	r6[0x4],r9
80007eee:	ee 08 09 08 	st.w	r7[r8],r8
80007ef2:	8f 2c       	st.w	r7[0x8],r12
80007ef4:	8f 3c       	st.w	r7[0xc],r12
80007ef6:	a1 a8       	sbr	r8,0x0
80007ef8:	0a 9c       	mov	r12,r5
80007efa:	8f 18       	st.w	r7[0x4],r8
80007efc:	c0 d8       	rjmp	80007f16 <_malloc_r+0x26e>
80007efe:	6c 39       	ld.w	r9,r6[0xc]
80007f00:	58 08       	cp.w	r8,0
80007f02:	c0 f5       	brlt	80007f20 <_malloc_r+0x278>
80007f04:	ec 0a 00 0a 	add	r10,r6,r10
80007f08:	74 18       	ld.w	r8,r10[0x4]
80007f0a:	a1 a8       	sbr	r8,0x0
80007f0c:	0a 9c       	mov	r12,r5
80007f0e:	95 18       	st.w	r10[0x4],r8
80007f10:	6c 28       	ld.w	r8,r6[0x8]
80007f12:	93 28       	st.w	r9[0x8],r8
80007f14:	91 39       	st.w	r8[0xc],r9
80007f16:	fe b0 f4 85 	rcall	80006820 <__malloc_unlock>
80007f1a:	ec cc ff f8 	sub	r12,r6,-8
80007f1e:	d8 32       	popm	r0-r7,pc
80007f20:	12 96       	mov	r6,r9
80007f22:	02 36       	cp.w	r6,r1
80007f24:	cd 21       	brne	80007ec8 <_malloc_r+0x220>
80007f26:	2f f2       	sub	r2,-1
80007f28:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
80007f2c:	c0 30       	breq	80007f32 <_malloc_r+0x28a>
80007f2e:	2f 81       	sub	r1,-8
80007f30:	cc ab       	rjmp	80007ec4 <_malloc_r+0x21c>
80007f32:	1c 98       	mov	r8,lr
80007f34:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
80007f38:	c0 81       	brne	80007f48 <_malloc_r+0x2a0>
80007f3a:	68 19       	ld.w	r9,r4[0x4]
80007f3c:	f6 08 11 ff 	rsub	r8,r11,-1
80007f40:	f3 e8 00 08 	and	r8,r9,r8
80007f44:	89 18       	st.w	r4[0x4],r8
80007f46:	c0 78       	rjmp	80007f54 <_malloc_r+0x2ac>
80007f48:	f0 c9 00 08 	sub	r9,r8,8
80007f4c:	20 13       	sub	r3,1
80007f4e:	70 08       	ld.w	r8,r8[0x0]
80007f50:	12 38       	cp.w	r8,r9
80007f52:	cf 10       	breq	80007f34 <_malloc_r+0x28c>
80007f54:	a1 7b       	lsl	r11,0x1
80007f56:	68 18       	ld.w	r8,r4[0x4]
80007f58:	10 3b       	cp.w	r11,r8
80007f5a:	e0 8b 00 0d 	brhi	80007f74 <_malloc_r+0x2cc>
80007f5e:	58 0b       	cp.w	r11,0
80007f60:	c0 a0       	breq	80007f74 <_malloc_r+0x2cc>
80007f62:	04 93       	mov	r3,r2
80007f64:	c0 38       	rjmp	80007f6a <_malloc_r+0x2c2>
80007f66:	2f c3       	sub	r3,-4
80007f68:	a1 7b       	lsl	r11,0x1
80007f6a:	f7 e8 00 09 	and	r9,r11,r8
80007f6e:	ca 71       	brne	80007ebc <_malloc_r+0x214>
80007f70:	cf bb       	rjmp	80007f66 <_malloc_r+0x2be>
80007f72:	d7 03       	nop
80007f74:	68 23       	ld.w	r3,r4[0x8]
80007f76:	66 12       	ld.w	r2,r3[0x4]
80007f78:	e0 12 ff fc 	andl	r2,0xfffc
80007f7c:	0e 32       	cp.w	r2,r7
80007f7e:	5f 39       	srlo	r9
80007f80:	e4 07 01 08 	sub	r8,r2,r7
80007f84:	58 f8       	cp.w	r8,15
80007f86:	5f aa       	srle	r10
80007f88:	f5 e9 10 09 	or	r9,r10,r9
80007f8c:	e0 80 00 9a 	breq	800080c0 <_malloc_r+0x418>
80007f90:	e0 68 0d d4 	mov	r8,3540
80007f94:	70 01       	ld.w	r1,r8[0x0]
80007f96:	e0 68 09 58 	mov	r8,2392
80007f9a:	2f 01       	sub	r1,-16
80007f9c:	70 08       	ld.w	r8,r8[0x0]
80007f9e:	0e 01       	add	r1,r7
80007fa0:	5b f8       	cp.w	r8,-1
80007fa2:	c0 40       	breq	80007faa <_malloc_r+0x302>
80007fa4:	28 11       	sub	r1,-127
80007fa6:	e0 11 ff 80 	andl	r1,0xff80
80007faa:	02 9b       	mov	r11,r1
80007fac:	0a 9c       	mov	r12,r5
80007fae:	e0 a0 02 b7 	rcall	8000851c <_sbrk_r>
80007fb2:	18 96       	mov	r6,r12
80007fb4:	5b fc       	cp.w	r12,-1
80007fb6:	c7 50       	breq	800080a0 <_malloc_r+0x3f8>
80007fb8:	e6 02 00 08 	add	r8,r3,r2
80007fbc:	10 3c       	cp.w	r12,r8
80007fbe:	c0 32       	brcc	80007fc4 <_malloc_r+0x31c>
80007fc0:	08 33       	cp.w	r3,r4
80007fc2:	c6 f1       	brne	800080a0 <_malloc_r+0x3f8>
80007fc4:	e0 6a 0d d8 	mov	r10,3544
80007fc8:	74 09       	ld.w	r9,r10[0x0]
80007fca:	e2 09 00 09 	add	r9,r1,r9
80007fce:	95 09       	st.w	r10[0x0],r9
80007fd0:	10 36       	cp.w	r6,r8
80007fd2:	c0 a1       	brne	80007fe6 <_malloc_r+0x33e>
80007fd4:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
80007fd8:	c0 71       	brne	80007fe6 <_malloc_r+0x33e>
80007fda:	e2 02 00 02 	add	r2,r1,r2
80007fde:	68 28       	ld.w	r8,r4[0x8]
80007fe0:	a1 a2       	sbr	r2,0x0
80007fe2:	91 12       	st.w	r8[0x4],r2
80007fe4:	c4 f8       	rjmp	80008082 <_malloc_r+0x3da>
80007fe6:	e0 6a 09 58 	mov	r10,2392
80007fea:	74 0b       	ld.w	r11,r10[0x0]
80007fec:	5b fb       	cp.w	r11,-1
80007fee:	c0 31       	brne	80007ff4 <_malloc_r+0x34c>
80007ff0:	95 06       	st.w	r10[0x0],r6
80007ff2:	c0 78       	rjmp	80008000 <_malloc_r+0x358>
80007ff4:	ec 09 00 09 	add	r9,r6,r9
80007ff8:	e0 6a 0d d8 	mov	r10,3544
80007ffc:	10 19       	sub	r9,r8
80007ffe:	95 09       	st.w	r10[0x0],r9
80008000:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
80008004:	f0 09 11 08 	rsub	r9,r8,8
80008008:	58 08       	cp.w	r8,0
8000800a:	f2 08 17 10 	movne	r8,r9
8000800e:	ed d8 e1 06 	addne	r6,r6,r8
80008012:	28 08       	sub	r8,-128
80008014:	ec 01 00 01 	add	r1,r6,r1
80008018:	0a 9c       	mov	r12,r5
8000801a:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
8000801e:	f0 01 01 01 	sub	r1,r8,r1
80008022:	02 9b       	mov	r11,r1
80008024:	e0 a0 02 7c 	rcall	8000851c <_sbrk_r>
80008028:	e0 68 0d d8 	mov	r8,3544
8000802c:	5b fc       	cp.w	r12,-1
8000802e:	ec 0c 17 00 	moveq	r12,r6
80008032:	f9 b1 00 00 	moveq	r1,0
80008036:	70 09       	ld.w	r9,r8[0x0]
80008038:	0c 1c       	sub	r12,r6
8000803a:	89 26       	st.w	r4[0x8],r6
8000803c:	02 0c       	add	r12,r1
8000803e:	12 01       	add	r1,r9
80008040:	a1 ac       	sbr	r12,0x0
80008042:	91 01       	st.w	r8[0x0],r1
80008044:	8d 1c       	st.w	r6[0x4],r12
80008046:	08 33       	cp.w	r3,r4
80008048:	c1 d0       	breq	80008082 <_malloc_r+0x3da>
8000804a:	58 f2       	cp.w	r2,15
8000804c:	e0 8b 00 05 	brhi	80008056 <_malloc_r+0x3ae>
80008050:	30 18       	mov	r8,1
80008052:	8d 18       	st.w	r6[0x4],r8
80008054:	c2 68       	rjmp	800080a0 <_malloc_r+0x3f8>
80008056:	30 59       	mov	r9,5
80008058:	20 c2       	sub	r2,12
8000805a:	e0 12 ff f8 	andl	r2,0xfff8
8000805e:	e6 02 00 08 	add	r8,r3,r2
80008062:	91 29       	st.w	r8[0x8],r9
80008064:	91 19       	st.w	r8[0x4],r9
80008066:	66 18       	ld.w	r8,r3[0x4]
80008068:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000806c:	e5 e8 10 08 	or	r8,r2,r8
80008070:	87 18       	st.w	r3[0x4],r8
80008072:	58 f2       	cp.w	r2,15
80008074:	e0 88 00 07 	brls	80008082 <_malloc_r+0x3da>
80008078:	e6 cb ff f8 	sub	r11,r3,-8
8000807c:	0a 9c       	mov	r12,r5
8000807e:	e0 a0 1c 7d 	rcall	8000b978 <_free_r>
80008082:	e0 69 0d d0 	mov	r9,3536
80008086:	72 0a       	ld.w	r10,r9[0x0]
80008088:	e0 68 0d d8 	mov	r8,3544
8000808c:	70 08       	ld.w	r8,r8[0x0]
8000808e:	14 38       	cp.w	r8,r10
80008090:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80008094:	e0 69 0d cc 	mov	r9,3532
80008098:	72 0a       	ld.w	r10,r9[0x0]
8000809a:	14 38       	cp.w	r8,r10
8000809c:	f3 f8 ba 00 	st.whi	r9[0x0],r8
800080a0:	68 28       	ld.w	r8,r4[0x8]
800080a2:	70 18       	ld.w	r8,r8[0x4]
800080a4:	e0 18 ff fc 	andl	r8,0xfffc
800080a8:	0e 38       	cp.w	r8,r7
800080aa:	5f 39       	srlo	r9
800080ac:	0e 18       	sub	r8,r7
800080ae:	58 f8       	cp.w	r8,15
800080b0:	5f aa       	srle	r10
800080b2:	f5 e9 10 09 	or	r9,r10,r9
800080b6:	c0 50       	breq	800080c0 <_malloc_r+0x418>
800080b8:	0a 9c       	mov	r12,r5
800080ba:	fe b0 f3 b3 	rcall	80006820 <__malloc_unlock>
800080be:	d8 3a       	popm	r0-r7,pc,r12=0
800080c0:	68 26       	ld.w	r6,r4[0x8]
800080c2:	a1 a8       	sbr	r8,0x0
800080c4:	0e 99       	mov	r9,r7
800080c6:	a1 a9       	sbr	r9,0x0
800080c8:	8d 19       	st.w	r6[0x4],r9
800080ca:	ec 07 00 07 	add	r7,r6,r7
800080ce:	0a 9c       	mov	r12,r5
800080d0:	89 27       	st.w	r4[0x8],r7
800080d2:	8f 18       	st.w	r7[0x4],r8
800080d4:	fe b0 f3 a6 	rcall	80006820 <__malloc_unlock>
800080d8:	ec cc ff f8 	sub	r12,r6,-8
800080dc:	d8 32       	popm	r0-r7,pc
800080de:	d7 03       	nop

800080e0 <memcmp>:
800080e0:	d4 01       	pushm	lr
800080e2:	30 08       	mov	r8,0
800080e4:	c0 d8       	rjmp	800080fe <memcmp+0x1e>
800080e6:	f8 08 07 0e 	ld.ub	lr,r12[r8]
800080ea:	f6 08 07 09 	ld.ub	r9,r11[r8]
800080ee:	20 1a       	sub	r10,1
800080f0:	2f f8       	sub	r8,-1
800080f2:	f2 0e 18 00 	cp.b	lr,r9
800080f6:	c0 40       	breq	800080fe <memcmp+0x1e>
800080f8:	fc 09 01 0c 	sub	r12,lr,r9
800080fc:	d8 02       	popm	pc
800080fe:	58 0a       	cp.w	r10,0
80008100:	cf 31       	brne	800080e6 <memcmp+0x6>
80008102:	14 9c       	mov	r12,r10
80008104:	d8 02       	popm	pc

80008106 <memcpy>:
80008106:	58 8a       	cp.w	r10,8
80008108:	c2 f5       	brlt	80008166 <memcpy+0x60>
8000810a:	f9 eb 10 09 	or	r9,r12,r11
8000810e:	e2 19 00 03 	andl	r9,0x3,COH
80008112:	e0 81 00 97 	brne	80008240 <memcpy+0x13a>
80008116:	e0 4a 00 20 	cp.w	r10,32
8000811a:	c3 b4       	brge	80008190 <memcpy+0x8a>
8000811c:	f4 08 14 02 	asr	r8,r10,0x2
80008120:	f0 09 11 08 	rsub	r9,r8,8
80008124:	fe 09 00 2f 	add	pc,pc,r9<<0x2
80008128:	76 69       	ld.w	r9,r11[0x18]
8000812a:	99 69       	st.w	r12[0x18],r9
8000812c:	76 59       	ld.w	r9,r11[0x14]
8000812e:	99 59       	st.w	r12[0x14],r9
80008130:	76 49       	ld.w	r9,r11[0x10]
80008132:	99 49       	st.w	r12[0x10],r9
80008134:	76 39       	ld.w	r9,r11[0xc]
80008136:	99 39       	st.w	r12[0xc],r9
80008138:	76 29       	ld.w	r9,r11[0x8]
8000813a:	99 29       	st.w	r12[0x8],r9
8000813c:	76 19       	ld.w	r9,r11[0x4]
8000813e:	99 19       	st.w	r12[0x4],r9
80008140:	76 09       	ld.w	r9,r11[0x0]
80008142:	99 09       	st.w	r12[0x0],r9
80008144:	f6 08 00 2b 	add	r11,r11,r8<<0x2
80008148:	f8 08 00 28 	add	r8,r12,r8<<0x2
8000814c:	e0 1a 00 03 	andl	r10,0x3
80008150:	f4 0a 11 04 	rsub	r10,r10,4
80008154:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
80008158:	17 a9       	ld.ub	r9,r11[0x2]
8000815a:	b0 a9       	st.b	r8[0x2],r9
8000815c:	17 99       	ld.ub	r9,r11[0x1]
8000815e:	b0 99       	st.b	r8[0x1],r9
80008160:	17 89       	ld.ub	r9,r11[0x0]
80008162:	b0 89       	st.b	r8[0x0],r9
80008164:	5e fc       	retal	r12
80008166:	f4 0a 11 09 	rsub	r10,r10,9
8000816a:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
8000816e:	17 f9       	ld.ub	r9,r11[0x7]
80008170:	b8 f9       	st.b	r12[0x7],r9
80008172:	17 e9       	ld.ub	r9,r11[0x6]
80008174:	b8 e9       	st.b	r12[0x6],r9
80008176:	17 d9       	ld.ub	r9,r11[0x5]
80008178:	b8 d9       	st.b	r12[0x5],r9
8000817a:	17 c9       	ld.ub	r9,r11[0x4]
8000817c:	b8 c9       	st.b	r12[0x4],r9
8000817e:	17 b9       	ld.ub	r9,r11[0x3]
80008180:	b8 b9       	st.b	r12[0x3],r9
80008182:	17 a9       	ld.ub	r9,r11[0x2]
80008184:	b8 a9       	st.b	r12[0x2],r9
80008186:	17 99       	ld.ub	r9,r11[0x1]
80008188:	b8 99       	st.b	r12[0x1],r9
8000818a:	17 89       	ld.ub	r9,r11[0x0]
8000818c:	b8 89       	st.b	r12[0x0],r9
8000818e:	5e fc       	retal	r12
80008190:	eb cd 40 c0 	pushm	r6-r7,lr
80008194:	18 99       	mov	r9,r12
80008196:	22 0a       	sub	r10,32
80008198:	b7 07       	ld.d	r6,r11++
8000819a:	b3 26       	st.d	r9++,r6
8000819c:	b7 07       	ld.d	r6,r11++
8000819e:	b3 26       	st.d	r9++,r6
800081a0:	b7 07       	ld.d	r6,r11++
800081a2:	b3 26       	st.d	r9++,r6
800081a4:	b7 07       	ld.d	r6,r11++
800081a6:	b3 26       	st.d	r9++,r6
800081a8:	22 0a       	sub	r10,32
800081aa:	cf 74       	brge	80008198 <memcpy+0x92>
800081ac:	2f 0a       	sub	r10,-16
800081ae:	c0 65       	brlt	800081ba <memcpy+0xb4>
800081b0:	b7 07       	ld.d	r6,r11++
800081b2:	b3 26       	st.d	r9++,r6
800081b4:	b7 07       	ld.d	r6,r11++
800081b6:	b3 26       	st.d	r9++,r6
800081b8:	21 0a       	sub	r10,16
800081ba:	5c 3a       	neg	r10
800081bc:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
800081c0:	d7 03       	nop
800081c2:	d7 03       	nop
800081c4:	f7 36 00 0e 	ld.ub	r6,r11[14]
800081c8:	f3 66 00 0e 	st.b	r9[14],r6
800081cc:	f7 36 00 0d 	ld.ub	r6,r11[13]
800081d0:	f3 66 00 0d 	st.b	r9[13],r6
800081d4:	f7 36 00 0c 	ld.ub	r6,r11[12]
800081d8:	f3 66 00 0c 	st.b	r9[12],r6
800081dc:	f7 36 00 0b 	ld.ub	r6,r11[11]
800081e0:	f3 66 00 0b 	st.b	r9[11],r6
800081e4:	f7 36 00 0a 	ld.ub	r6,r11[10]
800081e8:	f3 66 00 0a 	st.b	r9[10],r6
800081ec:	f7 36 00 09 	ld.ub	r6,r11[9]
800081f0:	f3 66 00 09 	st.b	r9[9],r6
800081f4:	f7 36 00 08 	ld.ub	r6,r11[8]
800081f8:	f3 66 00 08 	st.b	r9[8],r6
800081fc:	f7 36 00 07 	ld.ub	r6,r11[7]
80008200:	f3 66 00 07 	st.b	r9[7],r6
80008204:	f7 36 00 06 	ld.ub	r6,r11[6]
80008208:	f3 66 00 06 	st.b	r9[6],r6
8000820c:	f7 36 00 05 	ld.ub	r6,r11[5]
80008210:	f3 66 00 05 	st.b	r9[5],r6
80008214:	f7 36 00 04 	ld.ub	r6,r11[4]
80008218:	f3 66 00 04 	st.b	r9[4],r6
8000821c:	f7 36 00 03 	ld.ub	r6,r11[3]
80008220:	f3 66 00 03 	st.b	r9[3],r6
80008224:	f7 36 00 02 	ld.ub	r6,r11[2]
80008228:	f3 66 00 02 	st.b	r9[2],r6
8000822c:	f7 36 00 01 	ld.ub	r6,r11[1]
80008230:	f3 66 00 01 	st.b	r9[1],r6
80008234:	f7 36 00 00 	ld.ub	r6,r11[0]
80008238:	f3 66 00 00 	st.b	r9[0],r6
8000823c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80008240:	20 1a       	sub	r10,1
80008242:	f6 0a 07 09 	ld.ub	r9,r11[r10]
80008246:	f8 0a 0b 09 	st.b	r12[r10],r9
8000824a:	cf b1       	brne	80008240 <memcpy+0x13a>
8000824c:	5e fc       	retal	r12

8000824e <memset>:
8000824e:	18 98       	mov	r8,r12
80008250:	c0 38       	rjmp	80008256 <memset+0x8>
80008252:	10 cb       	st.b	r8++,r11
80008254:	20 1a       	sub	r10,1
80008256:	58 0a       	cp.w	r10,0
80008258:	cf d1       	brne	80008252 <memset+0x4>
8000825a:	5e fc       	retal	r12

8000825c <_realloc_r>:
8000825c:	d4 31       	pushm	r0-r7,lr
8000825e:	20 1d       	sub	sp,4
80008260:	16 94       	mov	r4,r11
80008262:	18 92       	mov	r2,r12
80008264:	14 9b       	mov	r11,r10
80008266:	58 04       	cp.w	r4,0
80008268:	c0 51       	brne	80008272 <_realloc_r+0x16>
8000826a:	fe b0 fd 1f 	rcall	80007ca8 <_malloc_r>
8000826e:	18 95       	mov	r5,r12
80008270:	c5 39       	rjmp	80008516 <_realloc_r+0x2ba>
80008272:	50 0a       	stdsp	sp[0x0],r10
80008274:	fe b0 f2 d0 	rcall	80006814 <__malloc_lock>
80008278:	40 0b       	lddsp	r11,sp[0x0]
8000827a:	f6 c8 ff f5 	sub	r8,r11,-11
8000827e:	e8 c1 00 08 	sub	r1,r4,8
80008282:	10 96       	mov	r6,r8
80008284:	62 1c       	ld.w	r12,r1[0x4]
80008286:	e0 16 ff f8 	andl	r6,0xfff8
8000828a:	59 68       	cp.w	r8,22
8000828c:	f9 b6 08 10 	movls	r6,16
80008290:	16 36       	cp.w	r6,r11
80008292:	5f 38       	srlo	r8
80008294:	f1 e6 13 f8 	or	r8,r8,r6>>0x1f
80008298:	c0 50       	breq	800082a2 <_realloc_r+0x46>
8000829a:	30 c8       	mov	r8,12
8000829c:	30 05       	mov	r5,0
8000829e:	85 38       	st.w	r2[0xc],r8
800082a0:	c3 b9       	rjmp	80008516 <_realloc_r+0x2ba>
800082a2:	18 90       	mov	r0,r12
800082a4:	e0 10 ff fc 	andl	r0,0xfffc
800082a8:	0c 30       	cp.w	r0,r6
800082aa:	e0 84 01 0b 	brge	800084c0 <_realloc_r+0x264>
800082ae:	e0 68 05 4c 	mov	r8,1356
800082b2:	e2 00 00 09 	add	r9,r1,r0
800082b6:	70 25       	ld.w	r5,r8[0x8]
800082b8:	0a 39       	cp.w	r9,r5
800082ba:	c0 90       	breq	800082cc <_realloc_r+0x70>
800082bc:	72 1a       	ld.w	r10,r9[0x4]
800082be:	a1 ca       	cbr	r10,0x0
800082c0:	f2 0a 00 0a 	add	r10,r9,r10
800082c4:	74 1a       	ld.w	r10,r10[0x4]
800082c6:	ed ba 00 00 	bld	r10,0x0
800082ca:	c2 20       	breq	8000830e <_realloc_r+0xb2>
800082cc:	72 1a       	ld.w	r10,r9[0x4]
800082ce:	e0 1a ff fc 	andl	r10,0xfffc
800082d2:	f4 00 00 03 	add	r3,r10,r0
800082d6:	0a 39       	cp.w	r9,r5
800082d8:	c1 31       	brne	800082fe <_realloc_r+0xa2>
800082da:	ec c7 ff f0 	sub	r7,r6,-16
800082de:	0e 33       	cp.w	r3,r7
800082e0:	c1 95       	brlt	80008312 <_realloc_r+0xb6>
800082e2:	e2 06 00 09 	add	r9,r1,r6
800082e6:	0c 13       	sub	r3,r6
800082e8:	a1 a3       	sbr	r3,0x0
800082ea:	93 13       	st.w	r9[0x4],r3
800082ec:	91 29       	st.w	r8[0x8],r9
800082ee:	04 9c       	mov	r12,r2
800082f0:	62 18       	ld.w	r8,r1[0x4]
800082f2:	08 95       	mov	r5,r4
800082f4:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800082f8:	10 46       	or	r6,r8
800082fa:	83 16       	st.w	r1[0x4],r6
800082fc:	c0 b9       	rjmp	80008512 <_realloc_r+0x2b6>
800082fe:	0c 33       	cp.w	r3,r6
80008300:	c0 95       	brlt	80008312 <_realloc_r+0xb6>
80008302:	72 28       	ld.w	r8,r9[0x8]
80008304:	02 97       	mov	r7,r1
80008306:	72 39       	ld.w	r9,r9[0xc]
80008308:	93 28       	st.w	r9[0x8],r8
8000830a:	91 39       	st.w	r8[0xc],r9
8000830c:	cd c8       	rjmp	800084c4 <_realloc_r+0x268>
8000830e:	30 0a       	mov	r10,0
80008310:	14 99       	mov	r9,r10
80008312:	ed bc 00 00 	bld	r12,0x0
80008316:	e0 80 00 95 	breq	80008440 <_realloc_r+0x1e4>
8000831a:	62 07       	ld.w	r7,r1[0x0]
8000831c:	e2 07 01 07 	sub	r7,r1,r7
80008320:	6e 1c       	ld.w	r12,r7[0x4]
80008322:	e0 1c ff fc 	andl	r12,0xfffc
80008326:	58 09       	cp.w	r9,0
80008328:	c5 60       	breq	800083d4 <_realloc_r+0x178>
8000832a:	f8 00 00 03 	add	r3,r12,r0
8000832e:	0a 39       	cp.w	r9,r5
80008330:	c4 81       	brne	800083c0 <_realloc_r+0x164>
80008332:	14 03       	add	r3,r10
80008334:	ec c9 ff f0 	sub	r9,r6,-16
80008338:	12 33       	cp.w	r3,r9
8000833a:	c4 d5       	brlt	800083d4 <_realloc_r+0x178>
8000833c:	6e 3a       	ld.w	r10,r7[0xc]
8000833e:	6e 29       	ld.w	r9,r7[0x8]
80008340:	95 29       	st.w	r10[0x8],r9
80008342:	93 3a       	st.w	r9[0xc],r10
80008344:	ee c5 ff f8 	sub	r5,r7,-8
80008348:	e0 ca 00 04 	sub	r10,r0,4
8000834c:	e0 4a 00 24 	cp.w	r10,36
80008350:	e0 8b 00 25 	brhi	8000839a <_realloc_r+0x13e>
80008354:	0a 99       	mov	r9,r5
80008356:	59 3a       	cp.w	r10,19
80008358:	e0 88 00 1a 	brls	8000838c <_realloc_r+0x130>
8000835c:	09 09       	ld.w	r9,r4++
8000835e:	8b 09       	st.w	r5[0x0],r9
80008360:	09 09       	ld.w	r9,r4++
80008362:	8f 39       	st.w	r7[0xc],r9
80008364:	ee c9 ff f0 	sub	r9,r7,-16
80008368:	59 ba       	cp.w	r10,27
8000836a:	e0 88 00 11 	brls	8000838c <_realloc_r+0x130>
8000836e:	09 0b       	ld.w	r11,r4++
80008370:	93 0b       	st.w	r9[0x0],r11
80008372:	09 09       	ld.w	r9,r4++
80008374:	8f 59       	st.w	r7[0x14],r9
80008376:	ee c9 ff e8 	sub	r9,r7,-24
8000837a:	e0 4a 00 24 	cp.w	r10,36
8000837e:	c0 71       	brne	8000838c <_realloc_r+0x130>
80008380:	09 0a       	ld.w	r10,r4++
80008382:	93 0a       	st.w	r9[0x0],r10
80008384:	ee c9 ff e0 	sub	r9,r7,-32
80008388:	09 0a       	ld.w	r10,r4++
8000838a:	8f 7a       	st.w	r7[0x1c],r10
8000838c:	09 0a       	ld.w	r10,r4++
8000838e:	12 aa       	st.w	r9++,r10
80008390:	68 0a       	ld.w	r10,r4[0x0]
80008392:	93 0a       	st.w	r9[0x0],r10
80008394:	68 1a       	ld.w	r10,r4[0x4]
80008396:	93 1a       	st.w	r9[0x4],r10
80008398:	c0 78       	rjmp	800083a6 <_realloc_r+0x14a>
8000839a:	50 08       	stdsp	sp[0x0],r8
8000839c:	08 9b       	mov	r11,r4
8000839e:	0a 9c       	mov	r12,r5
800083a0:	e0 a0 1d 8f 	rcall	8000bebe <memmove>
800083a4:	40 08       	lddsp	r8,sp[0x0]
800083a6:	ee 06 00 09 	add	r9,r7,r6
800083aa:	0c 13       	sub	r3,r6
800083ac:	a1 a3       	sbr	r3,0x0
800083ae:	93 13       	st.w	r9[0x4],r3
800083b0:	91 29       	st.w	r8[0x8],r9
800083b2:	04 9c       	mov	r12,r2
800083b4:	6e 18       	ld.w	r8,r7[0x4]
800083b6:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800083ba:	10 46       	or	r6,r8
800083bc:	8f 16       	st.w	r7[0x4],r6
800083be:	ca a8       	rjmp	80008512 <_realloc_r+0x2b6>
800083c0:	14 03       	add	r3,r10
800083c2:	0c 33       	cp.w	r3,r6
800083c4:	c0 85       	brlt	800083d4 <_realloc_r+0x178>
800083c6:	72 28       	ld.w	r8,r9[0x8]
800083c8:	72 39       	ld.w	r9,r9[0xc]
800083ca:	93 28       	st.w	r9[0x8],r8
800083cc:	91 39       	st.w	r8[0xc],r9
800083ce:	6e 28       	ld.w	r8,r7[0x8]
800083d0:	6e 39       	ld.w	r9,r7[0xc]
800083d2:	c0 78       	rjmp	800083e0 <_realloc_r+0x184>
800083d4:	f8 00 00 03 	add	r3,r12,r0
800083d8:	0c 33       	cp.w	r3,r6
800083da:	c3 35       	brlt	80008440 <_realloc_r+0x1e4>
800083dc:	6e 39       	ld.w	r9,r7[0xc]
800083de:	6e 28       	ld.w	r8,r7[0x8]
800083e0:	93 28       	st.w	r9[0x8],r8
800083e2:	91 39       	st.w	r8[0xc],r9
800083e4:	e0 ca 00 04 	sub	r10,r0,4
800083e8:	ee cc ff f8 	sub	r12,r7,-8
800083ec:	e0 4a 00 24 	cp.w	r10,36
800083f0:	e0 8b 00 24 	brhi	80008438 <_realloc_r+0x1dc>
800083f4:	59 3a       	cp.w	r10,19
800083f6:	e0 88 00 1a 	brls	8000842a <_realloc_r+0x1ce>
800083fa:	09 08       	ld.w	r8,r4++
800083fc:	99 08       	st.w	r12[0x0],r8
800083fe:	09 08       	ld.w	r8,r4++
80008400:	8f 38       	st.w	r7[0xc],r8
80008402:	ee cc ff f0 	sub	r12,r7,-16
80008406:	59 ba       	cp.w	r10,27
80008408:	e0 88 00 11 	brls	8000842a <_realloc_r+0x1ce>
8000840c:	09 08       	ld.w	r8,r4++
8000840e:	99 08       	st.w	r12[0x0],r8
80008410:	09 08       	ld.w	r8,r4++
80008412:	8f 58       	st.w	r7[0x14],r8
80008414:	ee cc ff e8 	sub	r12,r7,-24
80008418:	e0 4a 00 24 	cp.w	r10,36
8000841c:	c0 71       	brne	8000842a <_realloc_r+0x1ce>
8000841e:	09 08       	ld.w	r8,r4++
80008420:	99 08       	st.w	r12[0x0],r8
80008422:	ee cc ff e0 	sub	r12,r7,-32
80008426:	09 08       	ld.w	r8,r4++
80008428:	8f 78       	st.w	r7[0x1c],r8
8000842a:	09 08       	ld.w	r8,r4++
8000842c:	18 a8       	st.w	r12++,r8
8000842e:	68 08       	ld.w	r8,r4[0x0]
80008430:	99 08       	st.w	r12[0x0],r8
80008432:	68 18       	ld.w	r8,r4[0x4]
80008434:	99 18       	st.w	r12[0x4],r8
80008436:	c4 78       	rjmp	800084c4 <_realloc_r+0x268>
80008438:	08 9b       	mov	r11,r4
8000843a:	e0 a0 1d 42 	rcall	8000bebe <memmove>
8000843e:	c4 38       	rjmp	800084c4 <_realloc_r+0x268>
80008440:	04 9c       	mov	r12,r2
80008442:	fe b0 fc 33 	rcall	80007ca8 <_malloc_r>
80008446:	18 95       	mov	r5,r12
80008448:	c3 a0       	breq	800084bc <_realloc_r+0x260>
8000844a:	62 18       	ld.w	r8,r1[0x4]
8000844c:	f8 c9 00 08 	sub	r9,r12,8
80008450:	a1 c8       	cbr	r8,0x0
80008452:	e2 08 00 08 	add	r8,r1,r8
80008456:	10 39       	cp.w	r9,r8
80008458:	c0 71       	brne	80008466 <_realloc_r+0x20a>
8000845a:	72 13       	ld.w	r3,r9[0x4]
8000845c:	02 97       	mov	r7,r1
8000845e:	e0 13 ff fc 	andl	r3,0xfffc
80008462:	00 03       	add	r3,r0
80008464:	c3 08       	rjmp	800084c4 <_realloc_r+0x268>
80008466:	e0 ca 00 04 	sub	r10,r0,4
8000846a:	e0 4a 00 24 	cp.w	r10,36
8000846e:	e0 8b 00 20 	brhi	800084ae <_realloc_r+0x252>
80008472:	08 99       	mov	r9,r4
80008474:	18 98       	mov	r8,r12
80008476:	59 3a       	cp.w	r10,19
80008478:	e0 88 00 14 	brls	800084a0 <_realloc_r+0x244>
8000847c:	13 0b       	ld.w	r11,r9++
8000847e:	10 ab       	st.w	r8++,r11
80008480:	13 0b       	ld.w	r11,r9++
80008482:	10 ab       	st.w	r8++,r11
80008484:	59 ba       	cp.w	r10,27
80008486:	e0 88 00 0d 	brls	800084a0 <_realloc_r+0x244>
8000848a:	13 0b       	ld.w	r11,r9++
8000848c:	10 ab       	st.w	r8++,r11
8000848e:	13 0b       	ld.w	r11,r9++
80008490:	10 ab       	st.w	r8++,r11
80008492:	e0 4a 00 24 	cp.w	r10,36
80008496:	c0 51       	brne	800084a0 <_realloc_r+0x244>
80008498:	13 0a       	ld.w	r10,r9++
8000849a:	10 aa       	st.w	r8++,r10
8000849c:	13 0a       	ld.w	r10,r9++
8000849e:	10 aa       	st.w	r8++,r10
800084a0:	13 0a       	ld.w	r10,r9++
800084a2:	10 aa       	st.w	r8++,r10
800084a4:	72 0a       	ld.w	r10,r9[0x0]
800084a6:	91 0a       	st.w	r8[0x0],r10
800084a8:	72 19       	ld.w	r9,r9[0x4]
800084aa:	91 19       	st.w	r8[0x4],r9
800084ac:	c0 48       	rjmp	800084b4 <_realloc_r+0x258>
800084ae:	08 9b       	mov	r11,r4
800084b0:	e0 a0 1d 07 	rcall	8000bebe <memmove>
800084b4:	08 9b       	mov	r11,r4
800084b6:	04 9c       	mov	r12,r2
800084b8:	e0 a0 1a 60 	rcall	8000b978 <_free_r>
800084bc:	04 9c       	mov	r12,r2
800084be:	c2 a8       	rjmp	80008512 <_realloc_r+0x2b6>
800084c0:	00 93       	mov	r3,r0
800084c2:	02 97       	mov	r7,r1
800084c4:	e6 06 01 09 	sub	r9,r3,r6
800084c8:	6e 18       	ld.w	r8,r7[0x4]
800084ca:	58 f9       	cp.w	r9,15
800084cc:	e0 88 00 16 	brls	800084f8 <_realloc_r+0x29c>
800084d0:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800084d4:	ed e8 10 08 	or	r8,r6,r8
800084d8:	8f 18       	st.w	r7[0x4],r8
800084da:	12 98       	mov	r8,r9
800084dc:	a1 a8       	sbr	r8,0x0
800084de:	ee 06 00 0b 	add	r11,r7,r6
800084e2:	f6 09 00 09 	add	r9,r11,r9
800084e6:	97 18       	st.w	r11[0x4],r8
800084e8:	72 18       	ld.w	r8,r9[0x4]
800084ea:	a1 a8       	sbr	r8,0x0
800084ec:	2f 8b       	sub	r11,-8
800084ee:	93 18       	st.w	r9[0x4],r8
800084f0:	04 9c       	mov	r12,r2
800084f2:	e0 a0 1a 43 	rcall	8000b978 <_free_r>
800084f6:	c0 b8       	rjmp	8000850c <_realloc_r+0x2b0>
800084f8:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800084fc:	e7 e8 10 08 	or	r8,r3,r8
80008500:	8f 18       	st.w	r7[0x4],r8
80008502:	ee 03 00 03 	add	r3,r7,r3
80008506:	66 18       	ld.w	r8,r3[0x4]
80008508:	a1 a8       	sbr	r8,0x0
8000850a:	87 18       	st.w	r3[0x4],r8
8000850c:	04 9c       	mov	r12,r2
8000850e:	ee c5 ff f8 	sub	r5,r7,-8
80008512:	fe b0 f1 87 	rcall	80006820 <__malloc_unlock>
80008516:	0a 9c       	mov	r12,r5
80008518:	2f fd       	sub	sp,-4
8000851a:	d8 32       	popm	r0-r7,pc

8000851c <_sbrk_r>:
8000851c:	d4 21       	pushm	r4-r7,lr
8000851e:	30 08       	mov	r8,0
80008520:	18 97       	mov	r7,r12
80008522:	e0 66 54 34 	mov	r6,21556
80008526:	16 9c       	mov	r12,r11
80008528:	8d 08       	st.w	r6[0x0],r8
8000852a:	c8 5c       	rcall	80008634 <_sbrk>
8000852c:	5b fc       	cp.w	r12,-1
8000852e:	c0 51       	brne	80008538 <_sbrk_r+0x1c>
80008530:	6c 08       	ld.w	r8,r6[0x0]
80008532:	58 08       	cp.w	r8,0
80008534:	ef f8 1a 03 	st.wne	r7[0xc],r8
80008538:	d8 22       	popm	r4-r7,pc
8000853a:	d7 03       	nop

8000853c <sprintf>:
8000853c:	d4 01       	pushm	lr
8000853e:	21 7d       	sub	sp,92
80008540:	e0 68 ff ff 	mov	r8,65535
80008544:	ea 18 7f ff 	orh	r8,0x7fff
80008548:	50 58       	stdsp	sp[0x14],r8
8000854a:	50 28       	stdsp	sp[0x8],r8
8000854c:	e0 68 02 08 	mov	r8,520
80008550:	ba 68       	st.h	sp[0xc],r8
80008552:	3f f8       	mov	r8,-1
80008554:	ba 78       	st.h	sp[0xe],r8
80008556:	e0 68 0a 4c 	mov	r8,2636
8000855a:	50 4c       	stdsp	sp[0x10],r12
8000855c:	16 9a       	mov	r10,r11
8000855e:	50 0c       	stdsp	sp[0x0],r12
80008560:	fa c9 ff a0 	sub	r9,sp,-96
80008564:	70 0c       	ld.w	r12,r8[0x0]
80008566:	1a 9b       	mov	r11,sp
80008568:	e0 a0 02 1a 	rcall	8000899c <_vfprintf_r>
8000856c:	30 09       	mov	r9,0
8000856e:	40 08       	lddsp	r8,sp[0x0]
80008570:	b0 89       	st.b	r8[0x0],r9
80008572:	2e 9d       	sub	sp,-92
80008574:	d8 02       	popm	pc
80008576:	d7 03       	nop

80008578 <strncpy>:
80008578:	30 08       	mov	r8,0
8000857a:	10 3a       	cp.w	r10,r8
8000857c:	5e 0c       	reteq	r12
8000857e:	f6 08 07 09 	ld.ub	r9,r11[r8]
80008582:	f8 08 0b 09 	st.b	r12[r8],r9
80008586:	2f f8       	sub	r8,-1
80008588:	58 09       	cp.w	r9,0
8000858a:	cf 81       	brne	8000857a <strncpy+0x2>
8000858c:	10 3a       	cp.w	r10,r8
8000858e:	5e 0c       	reteq	r12
80008590:	f8 08 0b 09 	st.b	r12[r8],r9
80008594:	2f f8       	sub	r8,-1
80008596:	cf bb       	rjmp	8000858c <strncpy+0x14>

80008598 <_close>:
80008598:	30 28       	mov	r8,2
8000859a:	d6 73       	breakpoint
8000859c:	3f fc       	mov	r12,-1
8000859e:	35 8b       	mov	r11,88
800085a0:	58 0c       	cp.w	r12,0
800085a2:	5e 4c       	retge	r12
800085a4:	e0 6a 54 34 	mov	r10,21556
800085a8:	95 0b       	st.w	r10[0x0],r11
800085aa:	5e fc       	retal	r12

800085ac <_lseek>:
800085ac:	30 58       	mov	r8,5
800085ae:	d6 73       	breakpoint
800085b0:	3f fc       	mov	r12,-1
800085b2:	35 8b       	mov	r11,88
800085b4:	58 0c       	cp.w	r12,0
800085b6:	5e 4c       	retge	r12
800085b8:	e0 6a 54 34 	mov	r10,21556
800085bc:	95 0b       	st.w	r10[0x0],r11
800085be:	5e fc       	retal	r12

800085c0 <isatty>:
800085c0:	30 b8       	mov	r8,11
800085c2:	d6 73       	breakpoint
800085c4:	3f fc       	mov	r12,-1
800085c6:	35 8b       	mov	r11,88
800085c8:	58 0c       	cp.w	r12,0
800085ca:	5e 4c       	retge	r12
800085cc:	e0 6a 54 34 	mov	r10,21556
800085d0:	95 0b       	st.w	r10[0x0],r11
800085d2:	5e fc       	retal	r12

800085d4 <_fstat_host>:
800085d4:	30 98       	mov	r8,9
800085d6:	d6 73       	breakpoint
800085d8:	3f fc       	mov	r12,-1
800085da:	35 8b       	mov	r11,88
800085dc:	58 0c       	cp.w	r12,0
800085de:	5e 4c       	retge	r12
800085e0:	e0 6a 54 34 	mov	r10,21556
800085e4:	95 0b       	st.w	r10[0x0],r11
800085e6:	5e fc       	retal	r12

800085e8 <_fstat>:
800085e8:	d4 21       	pushm	r4-r7,lr
800085ea:	21 0d       	sub	sp,64
800085ec:	16 97       	mov	r7,r11
800085ee:	1a 9b       	mov	r11,sp
800085f0:	cf 2f       	rcall	800085d4 <_fstat_host>
800085f2:	c0 34       	brge	800085f8 <_fstat+0x10>
800085f4:	3f fc       	mov	r12,-1
800085f6:	c1 c8       	rjmp	8000862e <_fstat+0x46>
800085f8:	40 08       	lddsp	r8,sp[0x0]
800085fa:	ae 08       	st.h	r7[0x0],r8
800085fc:	40 18       	lddsp	r8,sp[0x4]
800085fe:	ae 18       	st.h	r7[0x2],r8
80008600:	40 28       	lddsp	r8,sp[0x8]
80008602:	8f 18       	st.w	r7[0x4],r8
80008604:	40 38       	lddsp	r8,sp[0xc]
80008606:	ae 48       	st.h	r7[0x8],r8
80008608:	40 48       	lddsp	r8,sp[0x10]
8000860a:	ae 58       	st.h	r7[0xa],r8
8000860c:	40 58       	lddsp	r8,sp[0x14]
8000860e:	ae 68       	st.h	r7[0xc],r8
80008610:	40 68       	lddsp	r8,sp[0x18]
80008612:	ae 78       	st.h	r7[0xe],r8
80008614:	40 88       	lddsp	r8,sp[0x20]
80008616:	8f 48       	st.w	r7[0x10],r8
80008618:	40 a8       	lddsp	r8,sp[0x28]
8000861a:	8f b8       	st.w	r7[0x2c],r8
8000861c:	40 c8       	lddsp	r8,sp[0x30]
8000861e:	8f c8       	st.w	r7[0x30],r8
80008620:	40 d8       	lddsp	r8,sp[0x34]
80008622:	8f 58       	st.w	r7[0x14],r8
80008624:	40 e8       	lddsp	r8,sp[0x38]
80008626:	30 0c       	mov	r12,0
80008628:	8f 78       	st.w	r7[0x1c],r8
8000862a:	40 f8       	lddsp	r8,sp[0x3c]
8000862c:	8f 98       	st.w	r7[0x24],r8
8000862e:	2f 0d       	sub	sp,-64
80008630:	d8 22       	popm	r4-r7,pc
80008632:	d7 03       	nop

80008634 <_sbrk>:
80008634:	d4 01       	pushm	lr
80008636:	e0 68 0e 00 	mov	r8,3584
8000863a:	70 09       	ld.w	r9,r8[0x0]
8000863c:	58 09       	cp.w	r9,0
8000863e:	c0 41       	brne	80008646 <_sbrk+0x12>
80008640:	e0 69 54 38 	mov	r9,21560
80008644:	91 09       	st.w	r8[0x0],r9
80008646:	e0 69 0e 00 	mov	r9,3584
8000864a:	e0 7a 70 00 	mov	r10,94208
8000864e:	72 08       	ld.w	r8,r9[0x0]
80008650:	f0 0c 00 0c 	add	r12,r8,r12
80008654:	14 3c       	cp.w	r12,r10
80008656:	e0 8b 00 04 	brhi	8000865e <_sbrk+0x2a>
8000865a:	93 0c       	st.w	r9[0x0],r12
8000865c:	c0 68       	rjmp	80008668 <_sbrk+0x34>
8000865e:	e0 a0 18 15 	rcall	8000b688 <__errno>
80008662:	30 c8       	mov	r8,12
80008664:	99 08       	st.w	r12[0x0],r8
80008666:	3f f8       	mov	r8,-1
80008668:	10 9c       	mov	r12,r8
8000866a:	d8 02       	popm	pc

8000866c <get_arg>:
8000866c:	d4 31       	pushm	r0-r7,lr
8000866e:	20 8d       	sub	sp,32
80008670:	fa c4 ff bc 	sub	r4,sp,-68
80008674:	50 4b       	stdsp	sp[0x10],r11
80008676:	68 2e       	ld.w	lr,r4[0x8]
80008678:	50 58       	stdsp	sp[0x14],r8
8000867a:	12 96       	mov	r6,r9
8000867c:	7c 0b       	ld.w	r11,lr[0x0]
8000867e:	70 05       	ld.w	r5,r8[0x0]
80008680:	50 6e       	stdsp	sp[0x18],lr
80008682:	58 0b       	cp.w	r11,0
80008684:	f4 0b 17 00 	moveq	r11,r10
80008688:	68 03       	ld.w	r3,r4[0x0]
8000868a:	68 11       	ld.w	r1,r4[0x4]
8000868c:	40 49       	lddsp	r9,sp[0x10]
8000868e:	30 08       	mov	r8,0
80008690:	c2 89       	rjmp	800088e0 <get_arg+0x274>
80008692:	2f fb       	sub	r11,-1
80008694:	32 5c       	mov	r12,37
80008696:	17 8a       	ld.ub	r10,r11[0x0]
80008698:	f8 0a 18 00 	cp.b	r10,r12
8000869c:	5f 1e       	srne	lr
8000869e:	f0 0a 18 00 	cp.b	r10,r8
800086a2:	5f 1c       	srne	r12
800086a4:	fd ec 00 0c 	and	r12,lr,r12
800086a8:	f0 0c 18 00 	cp.b	r12,r8
800086ac:	cf 31       	brne	80008692 <get_arg+0x26>
800086ae:	58 0a       	cp.w	r10,0
800086b0:	e0 80 01 25 	breq	800088fa <get_arg+0x28e>
800086b4:	30 0c       	mov	r12,0
800086b6:	3f fa       	mov	r10,-1
800086b8:	18 90       	mov	r0,r12
800086ba:	50 3a       	stdsp	sp[0xc],r10
800086bc:	18 94       	mov	r4,r12
800086be:	18 92       	mov	r2,r12
800086c0:	f8 0c 00 3c 	add	r12,r12,r12<<0x3
800086c4:	16 97       	mov	r7,r11
800086c6:	50 7c       	stdsp	sp[0x1c],r12
800086c8:	fe cc 9d 58 	sub	r12,pc,-25256
800086cc:	0f 3a       	ld.ub	r10,r7++
800086ce:	f8 0a 07 0e 	ld.ub	lr,r12[r10]
800086d2:	40 7c       	lddsp	r12,sp[0x1c]
800086d4:	1c 0c       	add	r12,lr
800086d6:	fe ce 9e 2e 	sub	lr,pc,-25042
800086da:	fc 0c 07 0e 	ld.ub	lr,lr[r12]
800086de:	20 1e       	sub	lr,1
800086e0:	50 0e       	stdsp	sp[0x0],lr
800086e2:	fe ce 9e a6 	sub	lr,pc,-24922
800086e6:	fc 0c 07 0c 	ld.ub	r12,lr[r12]
800086ea:	50 7c       	stdsp	sp[0x1c],r12
800086ec:	40 0c       	lddsp	r12,sp[0x0]
800086ee:	58 7c       	cp.w	r12,7
800086f0:	e0 8b 00 f1 	brhi	800088d2 <get_arg+0x266>
800086f4:	fe ce a0 58 	sub	lr,pc,-24488
800086f8:	fc 0c 03 2f 	ld.w	pc,lr[r12<<0x2]
800086fc:	36 8b       	mov	r11,104
800086fe:	f6 0a 18 00 	cp.b	r10,r11
80008702:	e0 80 00 e8 	breq	800088d2 <get_arg+0x266>
80008706:	37 1b       	mov	r11,113
80008708:	f6 0a 18 00 	cp.b	r10,r11
8000870c:	c0 70       	breq	8000871a <get_arg+0xae>
8000870e:	34 cb       	mov	r11,76
80008710:	f6 0a 18 00 	cp.b	r10,r11
80008714:	c0 51       	brne	8000871e <get_arg+0xb2>
80008716:	a3 b4       	sbr	r4,0x3
80008718:	cd d8       	rjmp	800088d2 <get_arg+0x266>
8000871a:	a5 b4       	sbr	r4,0x5
8000871c:	cd b8       	rjmp	800088d2 <get_arg+0x266>
8000871e:	08 9a       	mov	r10,r4
80008720:	0e 9b       	mov	r11,r7
80008722:	a5 aa       	sbr	r10,0x4
80008724:	17 3c       	ld.ub	r12,r11++
80008726:	a5 b4       	sbr	r4,0x5
80008728:	36 ce       	mov	lr,108
8000872a:	fc 0c 18 00 	cp.b	r12,lr
8000872e:	e0 80 00 d3 	breq	800088d4 <get_arg+0x268>
80008732:	14 94       	mov	r4,r10
80008734:	cc f8       	rjmp	800088d2 <get_arg+0x266>
80008736:	eb d5 c0 05 	bfextu	r5,r5,0x0,0x5
8000873a:	36 7c       	mov	r12,103
8000873c:	f8 0a 18 00 	cp.b	r10,r12
80008740:	e0 8b 00 27 	brhi	8000878e <get_arg+0x122>
80008744:	36 5b       	mov	r11,101
80008746:	f6 0a 18 00 	cp.b	r10,r11
8000874a:	c4 82       	brcc	800087da <get_arg+0x16e>
8000874c:	34 fb       	mov	r11,79
8000874e:	f6 0a 18 00 	cp.b	r10,r11
80008752:	c4 80       	breq	800087e2 <get_arg+0x176>
80008754:	e0 8b 00 0c 	brhi	8000876c <get_arg+0x100>
80008758:	34 5b       	mov	r11,69
8000875a:	f6 0a 18 00 	cp.b	r10,r11
8000875e:	c3 e0       	breq	800087da <get_arg+0x16e>
80008760:	34 7b       	mov	r11,71
80008762:	f6 0a 18 00 	cp.b	r10,r11
80008766:	c3 a0       	breq	800087da <get_arg+0x16e>
80008768:	34 4b       	mov	r11,68
8000876a:	c0 88       	rjmp	8000877a <get_arg+0x10e>
8000876c:	35 8b       	mov	r11,88
8000876e:	f6 0a 18 00 	cp.b	r10,r11
80008772:	c2 c0       	breq	800087ca <get_arg+0x15e>
80008774:	e0 8b 00 07 	brhi	80008782 <get_arg+0x116>
80008778:	35 5b       	mov	r11,85
8000877a:	f6 0a 18 00 	cp.b	r10,r11
8000877e:	c3 51       	brne	800087e8 <get_arg+0x17c>
80008780:	c3 18       	rjmp	800087e2 <get_arg+0x176>
80008782:	36 3b       	mov	r11,99
80008784:	f6 0a 18 00 	cp.b	r10,r11
80008788:	c2 f0       	breq	800087e6 <get_arg+0x17a>
8000878a:	36 4b       	mov	r11,100
8000878c:	c0 e8       	rjmp	800087a8 <get_arg+0x13c>
8000878e:	37 0b       	mov	r11,112
80008790:	f6 0a 18 00 	cp.b	r10,r11
80008794:	c2 50       	breq	800087de <get_arg+0x172>
80008796:	e0 8b 00 0d 	brhi	800087b0 <get_arg+0x144>
8000879a:	36 eb       	mov	r11,110
8000879c:	f6 0a 18 00 	cp.b	r10,r11
800087a0:	c1 f0       	breq	800087de <get_arg+0x172>
800087a2:	e0 8b 00 14 	brhi	800087ca <get_arg+0x15e>
800087a6:	36 9b       	mov	r11,105
800087a8:	f6 0a 18 00 	cp.b	r10,r11
800087ac:	c1 e1       	brne	800087e8 <get_arg+0x17c>
800087ae:	c0 e8       	rjmp	800087ca <get_arg+0x15e>
800087b0:	37 5b       	mov	r11,117
800087b2:	f6 0a 18 00 	cp.b	r10,r11
800087b6:	c0 a0       	breq	800087ca <get_arg+0x15e>
800087b8:	37 8b       	mov	r11,120
800087ba:	f6 0a 18 00 	cp.b	r10,r11
800087be:	c0 60       	breq	800087ca <get_arg+0x15e>
800087c0:	37 3b       	mov	r11,115
800087c2:	f6 0a 18 00 	cp.b	r10,r11
800087c6:	c1 11       	brne	800087e8 <get_arg+0x17c>
800087c8:	c0 b8       	rjmp	800087de <get_arg+0x172>
800087ca:	ed b4 00 04 	bld	r4,0x4
800087ce:	c0 a0       	breq	800087e2 <get_arg+0x176>
800087d0:	ed b4 00 05 	bld	r4,0x5
800087d4:	c0 91       	brne	800087e6 <get_arg+0x17a>
800087d6:	30 20       	mov	r0,2
800087d8:	c0 88       	rjmp	800087e8 <get_arg+0x17c>
800087da:	30 40       	mov	r0,4
800087dc:	c0 68       	rjmp	800087e8 <get_arg+0x17c>
800087de:	30 30       	mov	r0,3
800087e0:	c0 48       	rjmp	800087e8 <get_arg+0x17c>
800087e2:	30 10       	mov	r0,1
800087e4:	c0 28       	rjmp	800087e8 <get_arg+0x17c>
800087e6:	30 00       	mov	r0,0
800087e8:	40 3b       	lddsp	r11,sp[0xc]
800087ea:	5b fb       	cp.w	r11,-1
800087ec:	c0 40       	breq	800087f4 <get_arg+0x188>
800087ee:	e2 0b 09 20 	st.w	r1[r11<<0x2],r0
800087f2:	c7 08       	rjmp	800088d2 <get_arg+0x266>
800087f4:	58 60       	cp.w	r0,6
800087f6:	e0 8b 00 6e 	brhi	800088d2 <get_arg+0x266>
800087fa:	6c 0a       	ld.w	r10,r6[0x0]
800087fc:	ea cc ff ff 	sub	r12,r5,-1
80008800:	fe ce a1 44 	sub	lr,pc,-24252
80008804:	fc 00 03 2f 	ld.w	pc,lr[r0<<0x2]
80008808:	f4 cb ff f8 	sub	r11,r10,-8
8000880c:	8d 0b       	st.w	r6[0x0],r11
8000880e:	f4 ea 00 00 	ld.d	r10,r10[0]
80008812:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80008816:	c0 f8       	rjmp	80008834 <get_arg+0x1c8>
80008818:	f4 cb ff fc 	sub	r11,r10,-4
8000881c:	8d 0b       	st.w	r6[0x0],r11
8000881e:	74 0a       	ld.w	r10,r10[0x0]
80008820:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80008824:	c0 88       	rjmp	80008834 <get_arg+0x1c8>
80008826:	f4 cb ff f8 	sub	r11,r10,-8
8000882a:	8d 0b       	st.w	r6[0x0],r11
8000882c:	f4 ea 00 00 	ld.d	r10,r10[0]
80008830:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80008834:	0e 9b       	mov	r11,r7
80008836:	18 95       	mov	r5,r12
80008838:	c4 e8       	rjmp	800088d4 <get_arg+0x268>
8000883a:	62 0a       	ld.w	r10,r1[0x0]
8000883c:	5b fa       	cp.w	r10,-1
8000883e:	c0 b1       	brne	80008854 <get_arg+0x1e8>
80008840:	50 19       	stdsp	sp[0x4],r9
80008842:	50 28       	stdsp	sp[0x8],r8
80008844:	e0 6a 00 80 	mov	r10,128
80008848:	30 0b       	mov	r11,0
8000884a:	02 9c       	mov	r12,r1
8000884c:	fe b0 fd 01 	rcall	8000824e <memset>
80008850:	40 28       	lddsp	r8,sp[0x8]
80008852:	40 19       	lddsp	r9,sp[0x4]
80008854:	e4 cc 00 01 	sub	r12,r2,1
80008858:	0e 9b       	mov	r11,r7
8000885a:	50 3c       	stdsp	sp[0xc],r12
8000885c:	f2 0c 0c 49 	max	r9,r9,r12
80008860:	c3 a8       	rjmp	800088d4 <get_arg+0x268>
80008862:	62 0a       	ld.w	r10,r1[0x0]
80008864:	5b fa       	cp.w	r10,-1
80008866:	c0 b1       	brne	8000887c <get_arg+0x210>
80008868:	50 19       	stdsp	sp[0x4],r9
8000886a:	50 28       	stdsp	sp[0x8],r8
8000886c:	e0 6a 00 80 	mov	r10,128
80008870:	30 0b       	mov	r11,0
80008872:	02 9c       	mov	r12,r1
80008874:	fe b0 fc ed 	rcall	8000824e <memset>
80008878:	40 28       	lddsp	r8,sp[0x8]
8000887a:	40 19       	lddsp	r9,sp[0x4]
8000887c:	20 12       	sub	r2,1
8000887e:	30 0a       	mov	r10,0
80008880:	0e 9b       	mov	r11,r7
80008882:	e2 02 09 2a 	st.w	r1[r2<<0x2],r10
80008886:	f2 02 0c 49 	max	r9,r9,r2
8000888a:	c2 58       	rjmp	800088d4 <get_arg+0x268>
8000888c:	16 97       	mov	r7,r11
8000888e:	6c 0a       	ld.w	r10,r6[0x0]
80008890:	f4 cb ff fc 	sub	r11,r10,-4
80008894:	8d 0b       	st.w	r6[0x0],r11
80008896:	74 0a       	ld.w	r10,r10[0x0]
80008898:	0e 9b       	mov	r11,r7
8000889a:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
8000889e:	2f f5       	sub	r5,-1
800088a0:	c1 a8       	rjmp	800088d4 <get_arg+0x268>
800088a2:	f4 c2 00 30 	sub	r2,r10,48
800088a6:	c0 68       	rjmp	800088b2 <get_arg+0x246>
800088a8:	e4 02 00 22 	add	r2,r2,r2<<0x2
800088ac:	2f f7       	sub	r7,-1
800088ae:	f4 02 00 12 	add	r2,r10,r2<<0x1
800088b2:	0f 8a       	ld.ub	r10,r7[0x0]
800088b4:	58 0a       	cp.w	r10,0
800088b6:	c0 e0       	breq	800088d2 <get_arg+0x266>
800088b8:	23 0a       	sub	r10,48
800088ba:	58 9a       	cp.w	r10,9
800088bc:	fe 98 ff f6 	brls	800088a8 <get_arg+0x23c>
800088c0:	c0 98       	rjmp	800088d2 <get_arg+0x266>
800088c2:	2f f7       	sub	r7,-1
800088c4:	0f 8a       	ld.ub	r10,r7[0x0]
800088c6:	58 0a       	cp.w	r10,0
800088c8:	c0 50       	breq	800088d2 <get_arg+0x266>
800088ca:	23 0a       	sub	r10,48
800088cc:	58 9a       	cp.w	r10,9
800088ce:	fe 98 ff fa 	brls	800088c2 <get_arg+0x256>
800088d2:	0e 9b       	mov	r11,r7
800088d4:	40 7c       	lddsp	r12,sp[0x1c]
800088d6:	30 ba       	mov	r10,11
800088d8:	f4 0c 18 00 	cp.b	r12,r10
800088dc:	fe 91 fe f2 	brne	800086c0 <get_arg+0x54>
800088e0:	40 42       	lddsp	r2,sp[0x10]
800088e2:	17 8c       	ld.ub	r12,r11[0x0]
800088e4:	0a 32       	cp.w	r2,r5
800088e6:	5f 4a       	srge	r10
800088e8:	f0 0c 18 00 	cp.b	r12,r8
800088ec:	5f 1c       	srne	r12
800088ee:	f9 ea 00 0a 	and	r10,r12,r10
800088f2:	f0 0a 18 00 	cp.b	r10,r8
800088f6:	fe 91 fe cf 	brne	80008694 <get_arg+0x28>
800088fa:	30 08       	mov	r8,0
800088fc:	40 4e       	lddsp	lr,sp[0x10]
800088fe:	17 8a       	ld.ub	r10,r11[0x0]
80008900:	e2 05 00 21 	add	r1,r1,r5<<0x2
80008904:	f0 0a 18 00 	cp.b	r10,r8
80008908:	fc 09 17 10 	movne	r9,lr
8000890c:	e6 05 00 38 	add	r8,r3,r5<<0x3
80008910:	06 9e       	mov	lr,r3
80008912:	c2 a8       	rjmp	80008966 <get_arg+0x2fa>
80008914:	62 0a       	ld.w	r10,r1[0x0]
80008916:	58 3a       	cp.w	r10,3
80008918:	c1 e0       	breq	80008954 <get_arg+0x2e8>
8000891a:	e0 89 00 07 	brgt	80008928 <get_arg+0x2bc>
8000891e:	58 1a       	cp.w	r10,1
80008920:	c1 a0       	breq	80008954 <get_arg+0x2e8>
80008922:	58 2a       	cp.w	r10,2
80008924:	c1 81       	brne	80008954 <get_arg+0x2e8>
80008926:	c0 58       	rjmp	80008930 <get_arg+0x2c4>
80008928:	58 5a       	cp.w	r10,5
8000892a:	c0 c0       	breq	80008942 <get_arg+0x2d6>
8000892c:	c0 b5       	brlt	80008942 <get_arg+0x2d6>
8000892e:	c1 38       	rjmp	80008954 <get_arg+0x2e8>
80008930:	6c 0a       	ld.w	r10,r6[0x0]
80008932:	f4 cc ff f8 	sub	r12,r10,-8
80008936:	8d 0c       	st.w	r6[0x0],r12
80008938:	f4 e2 00 00 	ld.d	r2,r10[0]
8000893c:	f0 e3 00 00 	st.d	r8[0],r2
80008940:	c1 08       	rjmp	80008960 <get_arg+0x2f4>
80008942:	6c 0a       	ld.w	r10,r6[0x0]
80008944:	f4 cc ff f8 	sub	r12,r10,-8
80008948:	8d 0c       	st.w	r6[0x0],r12
8000894a:	f4 e2 00 00 	ld.d	r2,r10[0]
8000894e:	f0 e3 00 00 	st.d	r8[0],r2
80008952:	c0 78       	rjmp	80008960 <get_arg+0x2f4>
80008954:	6c 0a       	ld.w	r10,r6[0x0]
80008956:	f4 cc ff fc 	sub	r12,r10,-4
8000895a:	8d 0c       	st.w	r6[0x0],r12
8000895c:	74 0a       	ld.w	r10,r10[0x0]
8000895e:	91 0a       	st.w	r8[0x0],r10
80008960:	2f f5       	sub	r5,-1
80008962:	2f 88       	sub	r8,-8
80008964:	2f c1       	sub	r1,-4
80008966:	12 35       	cp.w	r5,r9
80008968:	fe 9a ff d6 	brle	80008914 <get_arg+0x2a8>
8000896c:	1c 93       	mov	r3,lr
8000896e:	40 52       	lddsp	r2,sp[0x14]
80008970:	40 6e       	lddsp	lr,sp[0x18]
80008972:	85 05       	st.w	r2[0x0],r5
80008974:	9d 0b       	st.w	lr[0x0],r11
80008976:	40 4b       	lddsp	r11,sp[0x10]
80008978:	e6 0b 00 3c 	add	r12,r3,r11<<0x3
8000897c:	2f 8d       	sub	sp,-32
8000897e:	d8 32       	popm	r0-r7,pc

80008980 <__sprint_r>:
80008980:	d4 21       	pushm	r4-r7,lr
80008982:	14 97       	mov	r7,r10
80008984:	74 28       	ld.w	r8,r10[0x8]
80008986:	58 08       	cp.w	r8,0
80008988:	c0 41       	brne	80008990 <__sprint_r+0x10>
8000898a:	95 18       	st.w	r10[0x4],r8
8000898c:	10 9c       	mov	r12,r8
8000898e:	d8 22       	popm	r4-r7,pc
80008990:	e0 a0 18 ba 	rcall	8000bb04 <__sfvwrite_r>
80008994:	30 08       	mov	r8,0
80008996:	8f 18       	st.w	r7[0x4],r8
80008998:	8f 28       	st.w	r7[0x8],r8
8000899a:	d8 22       	popm	r4-r7,pc

8000899c <_vfprintf_r>:
8000899c:	d4 31       	pushm	r0-r7,lr
8000899e:	fa cd 06 bc 	sub	sp,sp,1724
800089a2:	51 09       	stdsp	sp[0x40],r9
800089a4:	16 91       	mov	r1,r11
800089a6:	14 97       	mov	r7,r10
800089a8:	18 95       	mov	r5,r12
800089aa:	e0 a0 1a 1d 	rcall	8000bde4 <_localeconv_r>
800089ae:	78 0c       	ld.w	r12,r12[0x0]
800089b0:	50 cc       	stdsp	sp[0x30],r12
800089b2:	58 05       	cp.w	r5,0
800089b4:	c0 70       	breq	800089c2 <_vfprintf_r+0x26>
800089b6:	6a 68       	ld.w	r8,r5[0x18]
800089b8:	58 08       	cp.w	r8,0
800089ba:	c0 41       	brne	800089c2 <_vfprintf_r+0x26>
800089bc:	0a 9c       	mov	r12,r5
800089be:	e0 a0 17 43 	rcall	8000b844 <__sinit>
800089c2:	fe c8 9f 42 	sub	r8,pc,-24766
800089c6:	10 31       	cp.w	r1,r8
800089c8:	c0 31       	brne	800089ce <_vfprintf_r+0x32>
800089ca:	6a 01       	ld.w	r1,r5[0x0]
800089cc:	c0 c8       	rjmp	800089e4 <_vfprintf_r+0x48>
800089ce:	fe c8 9f 2e 	sub	r8,pc,-24786
800089d2:	10 31       	cp.w	r1,r8
800089d4:	c0 31       	brne	800089da <_vfprintf_r+0x3e>
800089d6:	6a 11       	ld.w	r1,r5[0x4]
800089d8:	c0 68       	rjmp	800089e4 <_vfprintf_r+0x48>
800089da:	fe c8 9f 1a 	sub	r8,pc,-24806
800089de:	10 31       	cp.w	r1,r8
800089e0:	eb f1 00 02 	ld.weq	r1,r5[0x8]
800089e4:	82 68       	ld.sh	r8,r1[0xc]
800089e6:	ed b8 00 03 	bld	r8,0x3
800089ea:	c0 41       	brne	800089f2 <_vfprintf_r+0x56>
800089ec:	62 48       	ld.w	r8,r1[0x10]
800089ee:	58 08       	cp.w	r8,0
800089f0:	c0 71       	brne	800089fe <_vfprintf_r+0x62>
800089f2:	02 9b       	mov	r11,r1
800089f4:	0a 9c       	mov	r12,r5
800089f6:	e0 a0 0f 5d 	rcall	8000a8b0 <__swsetup_r>
800089fa:	e0 81 0f 54 	brne	8000a8a2 <_vfprintf_r+0x1f06>
800089fe:	82 68       	ld.sh	r8,r1[0xc]
80008a00:	10 99       	mov	r9,r8
80008a02:	e2 19 00 1a 	andl	r9,0x1a,COH
80008a06:	58 a9       	cp.w	r9,10
80008a08:	c3 c1       	brne	80008a80 <_vfprintf_r+0xe4>
80008a0a:	82 79       	ld.sh	r9,r1[0xe]
80008a0c:	30 0a       	mov	r10,0
80008a0e:	f4 09 19 00 	cp.h	r9,r10
80008a12:	c3 75       	brlt	80008a80 <_vfprintf_r+0xe4>
80008a14:	a1 d8       	cbr	r8,0x1
80008a16:	fb 58 05 d0 	st.h	sp[1488],r8
80008a1a:	62 88       	ld.w	r8,r1[0x20]
80008a1c:	fb 48 05 e4 	st.w	sp[1508],r8
80008a20:	62 a8       	ld.w	r8,r1[0x28]
80008a22:	fb 48 05 ec 	st.w	sp[1516],r8
80008a26:	fa c8 ff bc 	sub	r8,sp,-68
80008a2a:	fb 48 05 d4 	st.w	sp[1492],r8
80008a2e:	fb 48 05 c4 	st.w	sp[1476],r8
80008a32:	e0 68 04 00 	mov	r8,1024
80008a36:	fb 48 05 d8 	st.w	sp[1496],r8
80008a3a:	fb 48 05 cc 	st.w	sp[1484],r8
80008a3e:	30 08       	mov	r8,0
80008a40:	fb 59 05 d2 	st.h	sp[1490],r9
80008a44:	0e 9a       	mov	r10,r7
80008a46:	41 09       	lddsp	r9,sp[0x40]
80008a48:	fa c7 fa 3c 	sub	r7,sp,-1476
80008a4c:	fb 48 05 dc 	st.w	sp[1500],r8
80008a50:	0a 9c       	mov	r12,r5
80008a52:	0e 9b       	mov	r11,r7
80008a54:	ca 4f       	rcall	8000899c <_vfprintf_r>
80008a56:	50 bc       	stdsp	sp[0x2c],r12
80008a58:	c0 95       	brlt	80008a6a <_vfprintf_r+0xce>
80008a5a:	0e 9b       	mov	r11,r7
80008a5c:	0a 9c       	mov	r12,r5
80008a5e:	e0 a0 16 1b 	rcall	8000b694 <_fflush_r>
80008a62:	40 be       	lddsp	lr,sp[0x2c]
80008a64:	f9 be 01 ff 	movne	lr,-1
80008a68:	50 be       	stdsp	sp[0x2c],lr
80008a6a:	fb 08 05 d0 	ld.sh	r8,sp[1488]
80008a6e:	ed b8 00 06 	bld	r8,0x6
80008a72:	e0 81 0f 1a 	brne	8000a8a6 <_vfprintf_r+0x1f0a>
80008a76:	82 68       	ld.sh	r8,r1[0xc]
80008a78:	a7 a8       	sbr	r8,0x6
80008a7a:	a2 68       	st.h	r1[0xc],r8
80008a7c:	e0 8f 0f 15 	bral	8000a8a6 <_vfprintf_r+0x1f0a>
80008a80:	30 08       	mov	r8,0
80008a82:	fb 48 06 b4 	st.w	sp[1716],r8
80008a86:	fb 48 06 90 	st.w	sp[1680],r8
80008a8a:	fb 48 06 8c 	st.w	sp[1676],r8
80008a8e:	fb 48 06 b0 	st.w	sp[1712],r8
80008a92:	30 08       	mov	r8,0
80008a94:	30 09       	mov	r9,0
80008a96:	50 a7       	stdsp	sp[0x28],r7
80008a98:	50 78       	stdsp	sp[0x1c],r8
80008a9a:	fa c3 f9 e0 	sub	r3,sp,-1568
80008a9e:	3f f8       	mov	r8,-1
80008aa0:	50 59       	stdsp	sp[0x14],r9
80008aa2:	fb 43 06 88 	st.w	sp[1672],r3
80008aa6:	fb 48 05 44 	st.w	sp[1348],r8
80008aaa:	12 9c       	mov	r12,r9
80008aac:	50 69       	stdsp	sp[0x18],r9
80008aae:	50 d9       	stdsp	sp[0x34],r9
80008ab0:	50 e9       	stdsp	sp[0x38],r9
80008ab2:	50 b9       	stdsp	sp[0x2c],r9
80008ab4:	12 97       	mov	r7,r9
80008ab6:	0a 94       	mov	r4,r5
80008ab8:	40 a2       	lddsp	r2,sp[0x28]
80008aba:	32 5a       	mov	r10,37
80008abc:	30 08       	mov	r8,0
80008abe:	c0 28       	rjmp	80008ac2 <_vfprintf_r+0x126>
80008ac0:	2f f2       	sub	r2,-1
80008ac2:	05 89       	ld.ub	r9,r2[0x0]
80008ac4:	f0 09 18 00 	cp.b	r9,r8
80008ac8:	5f 1b       	srne	r11
80008aca:	f4 09 18 00 	cp.b	r9,r10
80008ace:	5f 19       	srne	r9
80008ad0:	f3 eb 00 0b 	and	r11,r9,r11
80008ad4:	f0 0b 18 00 	cp.b	r11,r8
80008ad8:	cf 41       	brne	80008ac0 <_vfprintf_r+0x124>
80008ada:	40 ab       	lddsp	r11,sp[0x28]
80008adc:	e4 0b 01 06 	sub	r6,r2,r11
80008ae0:	c1 e0       	breq	80008b1c <_vfprintf_r+0x180>
80008ae2:	fa f8 06 90 	ld.w	r8,sp[1680]
80008ae6:	0c 08       	add	r8,r6
80008ae8:	87 0b       	st.w	r3[0x0],r11
80008aea:	fb 48 06 90 	st.w	sp[1680],r8
80008aee:	87 16       	st.w	r3[0x4],r6
80008af0:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008af4:	2f f8       	sub	r8,-1
80008af6:	fb 48 06 8c 	st.w	sp[1676],r8
80008afa:	58 78       	cp.w	r8,7
80008afc:	e0 89 00 04 	brgt	80008b04 <_vfprintf_r+0x168>
80008b00:	2f 83       	sub	r3,-8
80008b02:	c0 a8       	rjmp	80008b16 <_vfprintf_r+0x17a>
80008b04:	fa ca f9 78 	sub	r10,sp,-1672
80008b08:	02 9b       	mov	r11,r1
80008b0a:	08 9c       	mov	r12,r4
80008b0c:	c3 af       	rcall	80008980 <__sprint_r>
80008b0e:	e0 81 0e c6 	brne	8000a89a <_vfprintf_r+0x1efe>
80008b12:	fa c3 f9 e0 	sub	r3,sp,-1568
80008b16:	40 ba       	lddsp	r10,sp[0x2c]
80008b18:	0c 0a       	add	r10,r6
80008b1a:	50 ba       	stdsp	sp[0x2c],r10
80008b1c:	05 89       	ld.ub	r9,r2[0x0]
80008b1e:	30 08       	mov	r8,0
80008b20:	f0 09 18 00 	cp.b	r9,r8
80008b24:	e0 80 0e aa 	breq	8000a878 <_vfprintf_r+0x1edc>
80008b28:	30 09       	mov	r9,0
80008b2a:	fb 68 06 bb 	st.b	sp[1723],r8
80008b2e:	0e 96       	mov	r6,r7
80008b30:	e4 c8 ff ff 	sub	r8,r2,-1
80008b34:	3f fe       	mov	lr,-1
80008b36:	50 93       	stdsp	sp[0x24],r3
80008b38:	50 41       	stdsp	sp[0x10],r1
80008b3a:	0e 93       	mov	r3,r7
80008b3c:	04 91       	mov	r1,r2
80008b3e:	50 89       	stdsp	sp[0x20],r9
80008b40:	50 a8       	stdsp	sp[0x28],r8
80008b42:	50 2e       	stdsp	sp[0x8],lr
80008b44:	50 39       	stdsp	sp[0xc],r9
80008b46:	12 95       	mov	r5,r9
80008b48:	12 90       	mov	r0,r9
80008b4a:	10 97       	mov	r7,r8
80008b4c:	08 92       	mov	r2,r4
80008b4e:	c0 78       	rjmp	80008b5c <_vfprintf_r+0x1c0>
80008b50:	3f fc       	mov	r12,-1
80008b52:	08 97       	mov	r7,r4
80008b54:	50 2c       	stdsp	sp[0x8],r12
80008b56:	c0 38       	rjmp	80008b5c <_vfprintf_r+0x1c0>
80008b58:	30 0b       	mov	r11,0
80008b5a:	50 3b       	stdsp	sp[0xc],r11
80008b5c:	0f 38       	ld.ub	r8,r7++
80008b5e:	c0 28       	rjmp	80008b62 <_vfprintf_r+0x1c6>
80008b60:	12 90       	mov	r0,r9
80008b62:	f0 c9 00 20 	sub	r9,r8,32
80008b66:	e0 49 00 58 	cp.w	r9,88
80008b6a:	e0 8b 0a 30 	brhi	80009fca <_vfprintf_r+0x162e>
80008b6e:	fe ca a4 96 	sub	r10,pc,-23402
80008b72:	f4 09 03 2f 	ld.w	pc,r10[r9<<0x2]
80008b76:	50 a7       	stdsp	sp[0x28],r7
80008b78:	50 80       	stdsp	sp[0x20],r0
80008b7a:	0c 97       	mov	r7,r6
80008b7c:	04 94       	mov	r4,r2
80008b7e:	06 96       	mov	r6,r3
80008b80:	02 92       	mov	r2,r1
80008b82:	fe c9 a2 6e 	sub	r9,pc,-23954
80008b86:	40 93       	lddsp	r3,sp[0x24]
80008b88:	10 90       	mov	r0,r8
80008b8a:	40 41       	lddsp	r1,sp[0x10]
80008b8c:	50 d9       	stdsp	sp[0x34],r9
80008b8e:	e0 8f 08 8e 	bral	80009caa <_vfprintf_r+0x130e>
80008b92:	30 08       	mov	r8,0
80008b94:	fb 39 06 bb 	ld.ub	r9,sp[1723]
80008b98:	f0 09 18 00 	cp.b	r9,r8
80008b9c:	ce 01       	brne	80008b5c <_vfprintf_r+0x1c0>
80008b9e:	32 08       	mov	r8,32
80008ba0:	c6 e8       	rjmp	80008c7c <_vfprintf_r+0x2e0>
80008ba2:	a1 a5       	sbr	r5,0x0
80008ba4:	cd cb       	rjmp	80008b5c <_vfprintf_r+0x1c0>
80008ba6:	0f 89       	ld.ub	r9,r7[0x0]
80008ba8:	f2 c8 00 30 	sub	r8,r9,48
80008bac:	58 98       	cp.w	r8,9
80008bae:	e0 8b 00 1d 	brhi	80008be8 <_vfprintf_r+0x24c>
80008bb2:	ee c8 ff ff 	sub	r8,r7,-1
80008bb6:	30 0b       	mov	r11,0
80008bb8:	23 09       	sub	r9,48
80008bba:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
80008bbe:	f2 0b 00 1b 	add	r11,r9,r11<<0x1
80008bc2:	11 39       	ld.ub	r9,r8++
80008bc4:	f2 ca 00 30 	sub	r10,r9,48
80008bc8:	58 9a       	cp.w	r10,9
80008bca:	fe 98 ff f7 	brls	80008bb8 <_vfprintf_r+0x21c>
80008bce:	e0 49 00 24 	cp.w	r9,36
80008bd2:	cc 31       	brne	80008b58 <_vfprintf_r+0x1bc>
80008bd4:	e0 4b 00 20 	cp.w	r11,32
80008bd8:	e0 89 0e 60 	brgt	8000a898 <_vfprintf_r+0x1efc>
80008bdc:	20 1b       	sub	r11,1
80008bde:	fa f9 06 b4 	ld.w	r9,sp[1716]
80008be2:	12 3b       	cp.w	r11,r9
80008be4:	c0 95       	brlt	80008bf6 <_vfprintf_r+0x25a>
80008be6:	c1 08       	rjmp	80008c06 <_vfprintf_r+0x26a>
80008be8:	fa f9 06 b4 	ld.w	r9,sp[1716]
80008bec:	ec ca ff ff 	sub	r10,r6,-1
80008bf0:	12 36       	cp.w	r6,r9
80008bf2:	c1 f5       	brlt	80008c30 <_vfprintf_r+0x294>
80008bf4:	c2 68       	rjmp	80008c40 <_vfprintf_r+0x2a4>
80008bf6:	fa ce f9 44 	sub	lr,sp,-1724
80008bfa:	10 97       	mov	r7,r8
80008bfc:	fc 0b 00 3b 	add	r11,lr,r11<<0x3
80008c00:	f6 f0 fd 88 	ld.w	r0,r11[-632]
80008c04:	c3 58       	rjmp	80008c6e <_vfprintf_r+0x2d2>
80008c06:	10 97       	mov	r7,r8
80008c08:	fa c8 f9 50 	sub	r8,sp,-1712
80008c0c:	1a d8       	st.w	--sp,r8
80008c0e:	fa c8 fa b8 	sub	r8,sp,-1352
80008c12:	1a d8       	st.w	--sp,r8
80008c14:	fa c8 fb b4 	sub	r8,sp,-1100
80008c18:	02 9a       	mov	r10,r1
80008c1a:	1a d8       	st.w	--sp,r8
80008c1c:	04 9c       	mov	r12,r2
80008c1e:	fa c8 f9 40 	sub	r8,sp,-1728
80008c22:	fa c9 ff b4 	sub	r9,sp,-76
80008c26:	fe b0 fd 23 	rcall	8000866c <get_arg>
80008c2a:	2f dd       	sub	sp,-12
80008c2c:	78 00       	ld.w	r0,r12[0x0]
80008c2e:	c2 08       	rjmp	80008c6e <_vfprintf_r+0x2d2>
80008c30:	fa cc f9 44 	sub	r12,sp,-1724
80008c34:	14 96       	mov	r6,r10
80008c36:	f8 03 00 38 	add	r8,r12,r3<<0x3
80008c3a:	f0 f0 fd 88 	ld.w	r0,r8[-632]
80008c3e:	c1 88       	rjmp	80008c6e <_vfprintf_r+0x2d2>
80008c40:	41 08       	lddsp	r8,sp[0x40]
80008c42:	59 f9       	cp.w	r9,31
80008c44:	e0 89 00 11 	brgt	80008c66 <_vfprintf_r+0x2ca>
80008c48:	f0 cb ff fc 	sub	r11,r8,-4
80008c4c:	51 0b       	stdsp	sp[0x40],r11
80008c4e:	70 00       	ld.w	r0,r8[0x0]
80008c50:	fa cb f9 44 	sub	r11,sp,-1724
80008c54:	f6 09 00 38 	add	r8,r11,r9<<0x3
80008c58:	f1 40 fd 88 	st.w	r8[-632],r0
80008c5c:	2f f9       	sub	r9,-1
80008c5e:	14 96       	mov	r6,r10
80008c60:	fb 49 06 b4 	st.w	sp[1716],r9
80008c64:	c0 58       	rjmp	80008c6e <_vfprintf_r+0x2d2>
80008c66:	70 00       	ld.w	r0,r8[0x0]
80008c68:	14 96       	mov	r6,r10
80008c6a:	2f c8       	sub	r8,-4
80008c6c:	51 08       	stdsp	sp[0x40],r8
80008c6e:	58 00       	cp.w	r0,0
80008c70:	fe 94 ff 76 	brge	80008b5c <_vfprintf_r+0x1c0>
80008c74:	5c 30       	neg	r0
80008c76:	a3 a5       	sbr	r5,0x2
80008c78:	c7 2b       	rjmp	80008b5c <_vfprintf_r+0x1c0>
80008c7a:	32 b8       	mov	r8,43
80008c7c:	fb 68 06 bb 	st.b	sp[1723],r8
80008c80:	c6 eb       	rjmp	80008b5c <_vfprintf_r+0x1c0>
80008c82:	0f 38       	ld.ub	r8,r7++
80008c84:	e0 48 00 2a 	cp.w	r8,42
80008c88:	c0 30       	breq	80008c8e <_vfprintf_r+0x2f2>
80008c8a:	30 09       	mov	r9,0
80008c8c:	c7 98       	rjmp	80008d7e <_vfprintf_r+0x3e2>
80008c8e:	0f 88       	ld.ub	r8,r7[0x0]
80008c90:	f0 c9 00 30 	sub	r9,r8,48
80008c94:	58 99       	cp.w	r9,9
80008c96:	e0 8b 00 1f 	brhi	80008cd4 <_vfprintf_r+0x338>
80008c9a:	ee c4 ff ff 	sub	r4,r7,-1
80008c9e:	30 0b       	mov	r11,0
80008ca0:	23 08       	sub	r8,48
80008ca2:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
80008ca6:	f0 0b 00 1b 	add	r11,r8,r11<<0x1
80008caa:	09 38       	ld.ub	r8,r4++
80008cac:	f0 c9 00 30 	sub	r9,r8,48
80008cb0:	58 99       	cp.w	r9,9
80008cb2:	fe 98 ff f7 	brls	80008ca0 <_vfprintf_r+0x304>
80008cb6:	e0 48 00 24 	cp.w	r8,36
80008cba:	fe 91 ff 4f 	brne	80008b58 <_vfprintf_r+0x1bc>
80008cbe:	e0 4b 00 20 	cp.w	r11,32
80008cc2:	e0 89 0d eb 	brgt	8000a898 <_vfprintf_r+0x1efc>
80008cc6:	20 1b       	sub	r11,1
80008cc8:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008ccc:	10 3b       	cp.w	r11,r8
80008cce:	c0 a5       	brlt	80008ce2 <_vfprintf_r+0x346>
80008cd0:	c1 18       	rjmp	80008cf2 <_vfprintf_r+0x356>
80008cd2:	d7 03       	nop
80008cd4:	fa fa 06 b4 	ld.w	r10,sp[1716]
80008cd8:	ec c9 ff ff 	sub	r9,r6,-1
80008cdc:	14 36       	cp.w	r6,r10
80008cde:	c1 f5       	brlt	80008d1c <_vfprintf_r+0x380>
80008ce0:	c2 88       	rjmp	80008d30 <_vfprintf_r+0x394>
80008ce2:	fa ca f9 44 	sub	r10,sp,-1724
80008ce6:	f4 0b 00 3b 	add	r11,r10,r11<<0x3
80008cea:	f6 fb fd 88 	ld.w	r11,r11[-632]
80008cee:	50 2b       	stdsp	sp[0x8],r11
80008cf0:	c3 c8       	rjmp	80008d68 <_vfprintf_r+0x3cc>
80008cf2:	fa c8 f9 50 	sub	r8,sp,-1712
80008cf6:	1a d8       	st.w	--sp,r8
80008cf8:	fa c8 fa b8 	sub	r8,sp,-1352
80008cfc:	1a d8       	st.w	--sp,r8
80008cfe:	fa c8 fb b4 	sub	r8,sp,-1100
80008d02:	02 9a       	mov	r10,r1
80008d04:	1a d8       	st.w	--sp,r8
80008d06:	04 9c       	mov	r12,r2
80008d08:	fa c8 f9 40 	sub	r8,sp,-1728
80008d0c:	fa c9 ff b4 	sub	r9,sp,-76
80008d10:	fe b0 fc ae 	rcall	8000866c <get_arg>
80008d14:	2f dd       	sub	sp,-12
80008d16:	78 0c       	ld.w	r12,r12[0x0]
80008d18:	50 2c       	stdsp	sp[0x8],r12
80008d1a:	c2 78       	rjmp	80008d68 <_vfprintf_r+0x3cc>
80008d1c:	12 96       	mov	r6,r9
80008d1e:	0e 94       	mov	r4,r7
80008d20:	fa c9 f9 44 	sub	r9,sp,-1724
80008d24:	f2 03 00 38 	add	r8,r9,r3<<0x3
80008d28:	f0 f8 fd 88 	ld.w	r8,r8[-632]
80008d2c:	50 28       	stdsp	sp[0x8],r8
80008d2e:	c1 d8       	rjmp	80008d68 <_vfprintf_r+0x3cc>
80008d30:	41 08       	lddsp	r8,sp[0x40]
80008d32:	59 fa       	cp.w	r10,31
80008d34:	e0 89 00 14 	brgt	80008d5c <_vfprintf_r+0x3c0>
80008d38:	f0 cb ff fc 	sub	r11,r8,-4
80008d3c:	70 08       	ld.w	r8,r8[0x0]
80008d3e:	51 0b       	stdsp	sp[0x40],r11
80008d40:	50 28       	stdsp	sp[0x8],r8
80008d42:	fa c6 f9 44 	sub	r6,sp,-1724
80008d46:	40 2e       	lddsp	lr,sp[0x8]
80008d48:	ec 0a 00 38 	add	r8,r6,r10<<0x3
80008d4c:	f1 4e fd 88 	st.w	r8[-632],lr
80008d50:	2f fa       	sub	r10,-1
80008d52:	0e 94       	mov	r4,r7
80008d54:	fb 4a 06 b4 	st.w	sp[1716],r10
80008d58:	12 96       	mov	r6,r9
80008d5a:	c0 78       	rjmp	80008d68 <_vfprintf_r+0x3cc>
80008d5c:	70 0c       	ld.w	r12,r8[0x0]
80008d5e:	0e 94       	mov	r4,r7
80008d60:	2f c8       	sub	r8,-4
80008d62:	50 2c       	stdsp	sp[0x8],r12
80008d64:	12 96       	mov	r6,r9
80008d66:	51 08       	stdsp	sp[0x40],r8
80008d68:	40 2b       	lddsp	r11,sp[0x8]
80008d6a:	58 0b       	cp.w	r11,0
80008d6c:	fe 95 fe f2 	brlt	80008b50 <_vfprintf_r+0x1b4>
80008d70:	08 97       	mov	r7,r4
80008d72:	cf 5a       	rjmp	80008b5c <_vfprintf_r+0x1c0>
80008d74:	f2 09 00 29 	add	r9,r9,r9<<0x2
80008d78:	0f 38       	ld.ub	r8,r7++
80008d7a:	f4 09 00 19 	add	r9,r10,r9<<0x1
80008d7e:	f0 ca 00 30 	sub	r10,r8,48
80008d82:	58 9a       	cp.w	r10,9
80008d84:	fe 98 ff f8 	brls	80008d74 <_vfprintf_r+0x3d8>
80008d88:	3f fa       	mov	r10,-1
80008d8a:	f2 0a 0c 49 	max	r9,r9,r10
80008d8e:	50 29       	stdsp	sp[0x8],r9
80008d90:	ce 9a       	rjmp	80008b62 <_vfprintf_r+0x1c6>
80008d92:	a7 b5       	sbr	r5,0x7
80008d94:	ce 4a       	rjmp	80008b5c <_vfprintf_r+0x1c0>
80008d96:	30 09       	mov	r9,0
80008d98:	23 08       	sub	r8,48
80008d9a:	f2 09 00 29 	add	r9,r9,r9<<0x2
80008d9e:	f0 09 00 19 	add	r9,r8,r9<<0x1
80008da2:	0f 38       	ld.ub	r8,r7++
80008da4:	f0 ca 00 30 	sub	r10,r8,48
80008da8:	58 9a       	cp.w	r10,9
80008daa:	fe 98 ff f7 	brls	80008d98 <_vfprintf_r+0x3fc>
80008dae:	e0 48 00 24 	cp.w	r8,36
80008db2:	fe 91 fe d7 	brne	80008b60 <_vfprintf_r+0x1c4>
80008db6:	e0 49 00 20 	cp.w	r9,32
80008dba:	e0 89 0d 6f 	brgt	8000a898 <_vfprintf_r+0x1efc>
80008dbe:	f2 c3 00 01 	sub	r3,r9,1
80008dc2:	30 19       	mov	r9,1
80008dc4:	50 39       	stdsp	sp[0xc],r9
80008dc6:	cc ba       	rjmp	80008b5c <_vfprintf_r+0x1c0>
80008dc8:	a3 b5       	sbr	r5,0x3
80008dca:	cc 9a       	rjmp	80008b5c <_vfprintf_r+0x1c0>
80008dcc:	a7 a5       	sbr	r5,0x6
80008dce:	cc 7a       	rjmp	80008b5c <_vfprintf_r+0x1c0>
80008dd0:	0a 98       	mov	r8,r5
80008dd2:	a5 b5       	sbr	r5,0x5
80008dd4:	a5 a8       	sbr	r8,0x4
80008dd6:	0f 89       	ld.ub	r9,r7[0x0]
80008dd8:	36 ce       	mov	lr,108
80008dda:	fc 09 18 00 	cp.b	r9,lr
80008dde:	f7 b7 00 ff 	subeq	r7,-1
80008de2:	f0 05 17 10 	movne	r5,r8
80008de6:	cb ba       	rjmp	80008b5c <_vfprintf_r+0x1c0>
80008de8:	a5 b5       	sbr	r5,0x5
80008dea:	cb 9a       	rjmp	80008b5c <_vfprintf_r+0x1c0>
80008dec:	50 a7       	stdsp	sp[0x28],r7
80008dee:	50 80       	stdsp	sp[0x20],r0
80008df0:	0c 97       	mov	r7,r6
80008df2:	10 90       	mov	r0,r8
80008df4:	06 96       	mov	r6,r3
80008df6:	04 94       	mov	r4,r2
80008df8:	40 93       	lddsp	r3,sp[0x24]
80008dfa:	02 92       	mov	r2,r1
80008dfc:	0e 99       	mov	r9,r7
80008dfe:	40 41       	lddsp	r1,sp[0x10]
80008e00:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008e04:	40 3c       	lddsp	r12,sp[0xc]
80008e06:	58 0c       	cp.w	r12,0
80008e08:	c1 d0       	breq	80008e42 <_vfprintf_r+0x4a6>
80008e0a:	10 36       	cp.w	r6,r8
80008e0c:	c0 64       	brge	80008e18 <_vfprintf_r+0x47c>
80008e0e:	fa cb f9 44 	sub	r11,sp,-1724
80008e12:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008e16:	c1 d8       	rjmp	80008e50 <_vfprintf_r+0x4b4>
80008e18:	fa c8 f9 50 	sub	r8,sp,-1712
80008e1c:	1a d8       	st.w	--sp,r8
80008e1e:	fa c8 fa b8 	sub	r8,sp,-1352
80008e22:	1a d8       	st.w	--sp,r8
80008e24:	fa c8 fb b4 	sub	r8,sp,-1100
80008e28:	1a d8       	st.w	--sp,r8
80008e2a:	fa c8 f9 40 	sub	r8,sp,-1728
80008e2e:	fa c9 ff b4 	sub	r9,sp,-76
80008e32:	04 9a       	mov	r10,r2
80008e34:	0c 9b       	mov	r11,r6
80008e36:	08 9c       	mov	r12,r4
80008e38:	fe b0 fc 1a 	rcall	8000866c <get_arg>
80008e3c:	2f dd       	sub	sp,-12
80008e3e:	19 b8       	ld.ub	r8,r12[0x3]
80008e40:	c2 28       	rjmp	80008e84 <_vfprintf_r+0x4e8>
80008e42:	2f f7       	sub	r7,-1
80008e44:	10 39       	cp.w	r9,r8
80008e46:	c0 84       	brge	80008e56 <_vfprintf_r+0x4ba>
80008e48:	fa ca f9 44 	sub	r10,sp,-1724
80008e4c:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008e50:	ed 38 fd 8b 	ld.ub	r8,r6[-629]
80008e54:	c1 88       	rjmp	80008e84 <_vfprintf_r+0x4e8>
80008e56:	41 09       	lddsp	r9,sp[0x40]
80008e58:	59 f8       	cp.w	r8,31
80008e5a:	e0 89 00 12 	brgt	80008e7e <_vfprintf_r+0x4e2>
80008e5e:	f2 ca ff fc 	sub	r10,r9,-4
80008e62:	51 0a       	stdsp	sp[0x40],r10
80008e64:	72 09       	ld.w	r9,r9[0x0]
80008e66:	fa c6 f9 44 	sub	r6,sp,-1724
80008e6a:	ec 08 00 3a 	add	r10,r6,r8<<0x3
80008e6e:	2f f8       	sub	r8,-1
80008e70:	f5 49 fd 88 	st.w	r10[-632],r9
80008e74:	fb 48 06 b4 	st.w	sp[1716],r8
80008e78:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
80008e7c:	c0 48       	rjmp	80008e84 <_vfprintf_r+0x4e8>
80008e7e:	13 b8       	ld.ub	r8,r9[0x3]
80008e80:	2f c9       	sub	r9,-4
80008e82:	51 09       	stdsp	sp[0x40],r9
80008e84:	fb 68 06 60 	st.b	sp[1632],r8
80008e88:	30 0e       	mov	lr,0
80008e8a:	30 08       	mov	r8,0
80008e8c:	30 12       	mov	r2,1
80008e8e:	fb 68 06 bb 	st.b	sp[1723],r8
80008e92:	50 2e       	stdsp	sp[0x8],lr
80008e94:	e0 8f 08 ad 	bral	80009fee <_vfprintf_r+0x1652>
80008e98:	50 a7       	stdsp	sp[0x28],r7
80008e9a:	50 80       	stdsp	sp[0x20],r0
80008e9c:	0c 97       	mov	r7,r6
80008e9e:	04 94       	mov	r4,r2
80008ea0:	06 96       	mov	r6,r3
80008ea2:	02 92       	mov	r2,r1
80008ea4:	40 93       	lddsp	r3,sp[0x24]
80008ea6:	10 90       	mov	r0,r8
80008ea8:	40 41       	lddsp	r1,sp[0x10]
80008eaa:	a5 a5       	sbr	r5,0x4
80008eac:	c0 a8       	rjmp	80008ec0 <_vfprintf_r+0x524>
80008eae:	50 a7       	stdsp	sp[0x28],r7
80008eb0:	50 80       	stdsp	sp[0x20],r0
80008eb2:	0c 97       	mov	r7,r6
80008eb4:	04 94       	mov	r4,r2
80008eb6:	06 96       	mov	r6,r3
80008eb8:	02 92       	mov	r2,r1
80008eba:	40 93       	lddsp	r3,sp[0x24]
80008ebc:	10 90       	mov	r0,r8
80008ebe:	40 41       	lddsp	r1,sp[0x10]
80008ec0:	ed b5 00 05 	bld	r5,0x5
80008ec4:	c5 11       	brne	80008f66 <_vfprintf_r+0x5ca>
80008ec6:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008eca:	40 3c       	lddsp	r12,sp[0xc]
80008ecc:	58 0c       	cp.w	r12,0
80008ece:	c1 e0       	breq	80008f0a <_vfprintf_r+0x56e>
80008ed0:	10 36       	cp.w	r6,r8
80008ed2:	c0 64       	brge	80008ede <_vfprintf_r+0x542>
80008ed4:	fa cb f9 44 	sub	r11,sp,-1724
80008ed8:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008edc:	c2 08       	rjmp	80008f1c <_vfprintf_r+0x580>
80008ede:	fa c8 f9 50 	sub	r8,sp,-1712
80008ee2:	1a d8       	st.w	--sp,r8
80008ee4:	fa c8 fa b8 	sub	r8,sp,-1352
80008ee8:	0c 9b       	mov	r11,r6
80008eea:	1a d8       	st.w	--sp,r8
80008eec:	fa c8 fb b4 	sub	r8,sp,-1100
80008ef0:	1a d8       	st.w	--sp,r8
80008ef2:	fa c9 ff b4 	sub	r9,sp,-76
80008ef6:	fa c8 f9 40 	sub	r8,sp,-1728
80008efa:	04 9a       	mov	r10,r2
80008efc:	08 9c       	mov	r12,r4
80008efe:	fe b0 fb b7 	rcall	8000866c <get_arg>
80008f02:	2f dd       	sub	sp,-12
80008f04:	78 1b       	ld.w	r11,r12[0x4]
80008f06:	78 09       	ld.w	r9,r12[0x0]
80008f08:	c2 b8       	rjmp	80008f5e <_vfprintf_r+0x5c2>
80008f0a:	ee ca ff ff 	sub	r10,r7,-1
80008f0e:	10 37       	cp.w	r7,r8
80008f10:	c0 b4       	brge	80008f26 <_vfprintf_r+0x58a>
80008f12:	fa c9 f9 44 	sub	r9,sp,-1724
80008f16:	14 97       	mov	r7,r10
80008f18:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008f1c:	ec fb fd 8c 	ld.w	r11,r6[-628]
80008f20:	ec f9 fd 88 	ld.w	r9,r6[-632]
80008f24:	c1 d8       	rjmp	80008f5e <_vfprintf_r+0x5c2>
80008f26:	41 09       	lddsp	r9,sp[0x40]
80008f28:	59 f8       	cp.w	r8,31
80008f2a:	e0 89 00 14 	brgt	80008f52 <_vfprintf_r+0x5b6>
80008f2e:	f2 cb ff f8 	sub	r11,r9,-8
80008f32:	51 0b       	stdsp	sp[0x40],r11
80008f34:	fa c6 f9 44 	sub	r6,sp,-1724
80008f38:	72 1b       	ld.w	r11,r9[0x4]
80008f3a:	ec 08 00 3c 	add	r12,r6,r8<<0x3
80008f3e:	72 09       	ld.w	r9,r9[0x0]
80008f40:	f9 4b fd 8c 	st.w	r12[-628],r11
80008f44:	f9 49 fd 88 	st.w	r12[-632],r9
80008f48:	2f f8       	sub	r8,-1
80008f4a:	14 97       	mov	r7,r10
80008f4c:	fb 48 06 b4 	st.w	sp[1716],r8
80008f50:	c0 78       	rjmp	80008f5e <_vfprintf_r+0x5c2>
80008f52:	f2 c8 ff f8 	sub	r8,r9,-8
80008f56:	72 1b       	ld.w	r11,r9[0x4]
80008f58:	14 97       	mov	r7,r10
80008f5a:	51 08       	stdsp	sp[0x40],r8
80008f5c:	72 09       	ld.w	r9,r9[0x0]
80008f5e:	16 98       	mov	r8,r11
80008f60:	fa e9 00 00 	st.d	sp[0],r8
80008f64:	ca e8       	rjmp	800090c0 <_vfprintf_r+0x724>
80008f66:	ed b5 00 04 	bld	r5,0x4
80008f6a:	c1 71       	brne	80008f98 <_vfprintf_r+0x5fc>
80008f6c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008f70:	40 3e       	lddsp	lr,sp[0xc]
80008f72:	58 0e       	cp.w	lr,0
80008f74:	c0 80       	breq	80008f84 <_vfprintf_r+0x5e8>
80008f76:	10 36       	cp.w	r6,r8
80008f78:	c6 94       	brge	8000904a <_vfprintf_r+0x6ae>
80008f7a:	fa cc f9 44 	sub	r12,sp,-1724
80008f7e:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008f82:	c8 28       	rjmp	80009086 <_vfprintf_r+0x6ea>
80008f84:	ee ca ff ff 	sub	r10,r7,-1
80008f88:	10 37       	cp.w	r7,r8
80008f8a:	e0 84 00 81 	brge	8000908c <_vfprintf_r+0x6f0>
80008f8e:	fa cb f9 44 	sub	r11,sp,-1724
80008f92:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008f96:	c7 78       	rjmp	80009084 <_vfprintf_r+0x6e8>
80008f98:	ed b5 00 06 	bld	r5,0x6
80008f9c:	c4 b1       	brne	80009032 <_vfprintf_r+0x696>
80008f9e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008fa2:	40 3c       	lddsp	r12,sp[0xc]
80008fa4:	58 0c       	cp.w	r12,0
80008fa6:	c1 d0       	breq	80008fe0 <_vfprintf_r+0x644>
80008fa8:	10 36       	cp.w	r6,r8
80008faa:	c0 64       	brge	80008fb6 <_vfprintf_r+0x61a>
80008fac:	fa cb f9 44 	sub	r11,sp,-1724
80008fb0:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008fb4:	c1 f8       	rjmp	80008ff2 <_vfprintf_r+0x656>
80008fb6:	fa c8 f9 50 	sub	r8,sp,-1712
80008fba:	1a d8       	st.w	--sp,r8
80008fbc:	fa c8 fa b8 	sub	r8,sp,-1352
80008fc0:	1a d8       	st.w	--sp,r8
80008fc2:	fa c8 fb b4 	sub	r8,sp,-1100
80008fc6:	1a d8       	st.w	--sp,r8
80008fc8:	fa c8 f9 40 	sub	r8,sp,-1728
80008fcc:	fa c9 ff b4 	sub	r9,sp,-76
80008fd0:	04 9a       	mov	r10,r2
80008fd2:	0c 9b       	mov	r11,r6
80008fd4:	08 9c       	mov	r12,r4
80008fd6:	fe b0 fb 4b 	rcall	8000866c <get_arg>
80008fda:	2f dd       	sub	sp,-12
80008fdc:	98 18       	ld.sh	r8,r12[0x2]
80008fde:	c2 68       	rjmp	8000902a <_vfprintf_r+0x68e>
80008fe0:	ee ca ff ff 	sub	r10,r7,-1
80008fe4:	10 37       	cp.w	r7,r8
80008fe6:	c0 94       	brge	80008ff8 <_vfprintf_r+0x65c>
80008fe8:	fa c9 f9 44 	sub	r9,sp,-1724
80008fec:	14 97       	mov	r7,r10
80008fee:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008ff2:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80008ff6:	c1 a8       	rjmp	8000902a <_vfprintf_r+0x68e>
80008ff8:	41 09       	lddsp	r9,sp[0x40]
80008ffa:	59 f8       	cp.w	r8,31
80008ffc:	e0 89 00 13 	brgt	80009022 <_vfprintf_r+0x686>
80009000:	f2 cb ff fc 	sub	r11,r9,-4
80009004:	51 0b       	stdsp	sp[0x40],r11
80009006:	72 09       	ld.w	r9,r9[0x0]
80009008:	fa c6 f9 44 	sub	r6,sp,-1724
8000900c:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80009010:	2f f8       	sub	r8,-1
80009012:	f7 49 fd 88 	st.w	r11[-632],r9
80009016:	fb 48 06 b4 	st.w	sp[1716],r8
8000901a:	14 97       	mov	r7,r10
8000901c:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80009020:	c0 58       	rjmp	8000902a <_vfprintf_r+0x68e>
80009022:	92 18       	ld.sh	r8,r9[0x2]
80009024:	14 97       	mov	r7,r10
80009026:	2f c9       	sub	r9,-4
80009028:	51 09       	stdsp	sp[0x40],r9
8000902a:	50 18       	stdsp	sp[0x4],r8
8000902c:	bf 58       	asr	r8,0x1f
8000902e:	50 08       	stdsp	sp[0x0],r8
80009030:	c4 88       	rjmp	800090c0 <_vfprintf_r+0x724>
80009032:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009036:	40 3c       	lddsp	r12,sp[0xc]
80009038:	58 0c       	cp.w	r12,0
8000903a:	c1 d0       	breq	80009074 <_vfprintf_r+0x6d8>
8000903c:	10 36       	cp.w	r6,r8
8000903e:	c0 64       	brge	8000904a <_vfprintf_r+0x6ae>
80009040:	fa cb f9 44 	sub	r11,sp,-1724
80009044:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009048:	c1 f8       	rjmp	80009086 <_vfprintf_r+0x6ea>
8000904a:	fa c8 f9 50 	sub	r8,sp,-1712
8000904e:	1a d8       	st.w	--sp,r8
80009050:	fa c8 fa b8 	sub	r8,sp,-1352
80009054:	0c 9b       	mov	r11,r6
80009056:	1a d8       	st.w	--sp,r8
80009058:	fa c8 fb b4 	sub	r8,sp,-1100
8000905c:	04 9a       	mov	r10,r2
8000905e:	1a d8       	st.w	--sp,r8
80009060:	08 9c       	mov	r12,r4
80009062:	fa c8 f9 40 	sub	r8,sp,-1728
80009066:	fa c9 ff b4 	sub	r9,sp,-76
8000906a:	fe b0 fb 01 	rcall	8000866c <get_arg>
8000906e:	2f dd       	sub	sp,-12
80009070:	78 0b       	ld.w	r11,r12[0x0]
80009072:	c2 48       	rjmp	800090ba <_vfprintf_r+0x71e>
80009074:	ee ca ff ff 	sub	r10,r7,-1
80009078:	10 37       	cp.w	r7,r8
8000907a:	c0 94       	brge	8000908c <_vfprintf_r+0x6f0>
8000907c:	fa c9 f9 44 	sub	r9,sp,-1724
80009080:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009084:	14 97       	mov	r7,r10
80009086:	ec fb fd 88 	ld.w	r11,r6[-632]
8000908a:	c1 88       	rjmp	800090ba <_vfprintf_r+0x71e>
8000908c:	41 09       	lddsp	r9,sp[0x40]
8000908e:	59 f8       	cp.w	r8,31
80009090:	e0 89 00 11 	brgt	800090b2 <_vfprintf_r+0x716>
80009094:	f2 cb ff fc 	sub	r11,r9,-4
80009098:	51 0b       	stdsp	sp[0x40],r11
8000909a:	fa c6 f9 44 	sub	r6,sp,-1724
8000909e:	72 0b       	ld.w	r11,r9[0x0]
800090a0:	ec 08 00 39 	add	r9,r6,r8<<0x3
800090a4:	f3 4b fd 88 	st.w	r9[-632],r11
800090a8:	2f f8       	sub	r8,-1
800090aa:	14 97       	mov	r7,r10
800090ac:	fb 48 06 b4 	st.w	sp[1716],r8
800090b0:	c0 58       	rjmp	800090ba <_vfprintf_r+0x71e>
800090b2:	72 0b       	ld.w	r11,r9[0x0]
800090b4:	14 97       	mov	r7,r10
800090b6:	2f c9       	sub	r9,-4
800090b8:	51 09       	stdsp	sp[0x40],r9
800090ba:	50 1b       	stdsp	sp[0x4],r11
800090bc:	bf 5b       	asr	r11,0x1f
800090be:	50 0b       	stdsp	sp[0x0],r11
800090c0:	fa ea 00 00 	ld.d	r10,sp[0]
800090c4:	58 0a       	cp.w	r10,0
800090c6:	5c 2b       	cpc	r11
800090c8:	c0 e4       	brge	800090e4 <_vfprintf_r+0x748>
800090ca:	30 08       	mov	r8,0
800090cc:	fa ea 00 00 	ld.d	r10,sp[0]
800090d0:	30 09       	mov	r9,0
800090d2:	f0 0a 01 0a 	sub	r10,r8,r10
800090d6:	f2 0b 01 4b 	sbc	r11,r9,r11
800090da:	32 d8       	mov	r8,45
800090dc:	fa eb 00 00 	st.d	sp[0],r10
800090e0:	fb 68 06 bb 	st.b	sp[1723],r8
800090e4:	30 18       	mov	r8,1
800090e6:	e0 8f 06 fa 	bral	80009eda <_vfprintf_r+0x153e>
800090ea:	50 a7       	stdsp	sp[0x28],r7
800090ec:	50 80       	stdsp	sp[0x20],r0
800090ee:	0c 97       	mov	r7,r6
800090f0:	04 94       	mov	r4,r2
800090f2:	06 96       	mov	r6,r3
800090f4:	02 92       	mov	r2,r1
800090f6:	40 93       	lddsp	r3,sp[0x24]
800090f8:	10 90       	mov	r0,r8
800090fa:	40 41       	lddsp	r1,sp[0x10]
800090fc:	0e 99       	mov	r9,r7
800090fe:	ed b5 00 03 	bld	r5,0x3
80009102:	c4 11       	brne	80009184 <_vfprintf_r+0x7e8>
80009104:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009108:	40 3a       	lddsp	r10,sp[0xc]
8000910a:	58 0a       	cp.w	r10,0
8000910c:	c1 90       	breq	8000913e <_vfprintf_r+0x7a2>
8000910e:	10 36       	cp.w	r6,r8
80009110:	c6 45       	brlt	800091d8 <_vfprintf_r+0x83c>
80009112:	fa c8 f9 50 	sub	r8,sp,-1712
80009116:	1a d8       	st.w	--sp,r8
80009118:	fa c8 fa b8 	sub	r8,sp,-1352
8000911c:	1a d8       	st.w	--sp,r8
8000911e:	fa c8 fb b4 	sub	r8,sp,-1100
80009122:	0c 9b       	mov	r11,r6
80009124:	1a d8       	st.w	--sp,r8
80009126:	04 9a       	mov	r10,r2
80009128:	fa c8 f9 40 	sub	r8,sp,-1728
8000912c:	fa c9 ff b4 	sub	r9,sp,-76
80009130:	08 9c       	mov	r12,r4
80009132:	fe b0 fa 9d 	rcall	8000866c <get_arg>
80009136:	2f dd       	sub	sp,-12
80009138:	78 16       	ld.w	r6,r12[0x4]
8000913a:	50 76       	stdsp	sp[0x1c],r6
8000913c:	c4 88       	rjmp	800091cc <_vfprintf_r+0x830>
8000913e:	2f f7       	sub	r7,-1
80009140:	10 39       	cp.w	r9,r8
80009142:	c0 c4       	brge	8000915a <_vfprintf_r+0x7be>
80009144:	fa ce f9 44 	sub	lr,sp,-1724
80009148:	fc 06 00 36 	add	r6,lr,r6<<0x3
8000914c:	ec fc fd 8c 	ld.w	r12,r6[-628]
80009150:	50 7c       	stdsp	sp[0x1c],r12
80009152:	ec f6 fd 88 	ld.w	r6,r6[-632]
80009156:	50 56       	stdsp	sp[0x14],r6
80009158:	c6 68       	rjmp	80009224 <_vfprintf_r+0x888>
8000915a:	41 09       	lddsp	r9,sp[0x40]
8000915c:	59 f8       	cp.w	r8,31
8000915e:	e0 89 00 10 	brgt	8000917e <_vfprintf_r+0x7e2>
80009162:	f2 ca ff f8 	sub	r10,r9,-8
80009166:	72 1b       	ld.w	r11,r9[0x4]
80009168:	51 0a       	stdsp	sp[0x40],r10
8000916a:	72 09       	ld.w	r9,r9[0x0]
8000916c:	fa ca f9 44 	sub	r10,sp,-1724
80009170:	50 7b       	stdsp	sp[0x1c],r11
80009172:	50 59       	stdsp	sp[0x14],r9
80009174:	f4 08 00 39 	add	r9,r10,r8<<0x3
80009178:	40 5b       	lddsp	r11,sp[0x14]
8000917a:	40 7a       	lddsp	r10,sp[0x1c]
8000917c:	c4 78       	rjmp	8000920a <_vfprintf_r+0x86e>
8000917e:	72 18       	ld.w	r8,r9[0x4]
80009180:	50 78       	stdsp	sp[0x1c],r8
80009182:	c4 c8       	rjmp	8000921a <_vfprintf_r+0x87e>
80009184:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009188:	40 3e       	lddsp	lr,sp[0xc]
8000918a:	58 0e       	cp.w	lr,0
8000918c:	c2 30       	breq	800091d2 <_vfprintf_r+0x836>
8000918e:	10 36       	cp.w	r6,r8
80009190:	c0 94       	brge	800091a2 <_vfprintf_r+0x806>
80009192:	fa cc f9 44 	sub	r12,sp,-1724
80009196:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000919a:	ec fb fd 8c 	ld.w	r11,r6[-628]
8000919e:	50 7b       	stdsp	sp[0x1c],r11
800091a0:	cd 9b       	rjmp	80009152 <_vfprintf_r+0x7b6>
800091a2:	fa c8 f9 50 	sub	r8,sp,-1712
800091a6:	1a d8       	st.w	--sp,r8
800091a8:	fa c8 fa b8 	sub	r8,sp,-1352
800091ac:	04 9a       	mov	r10,r2
800091ae:	1a d8       	st.w	--sp,r8
800091b0:	fa c8 fb b4 	sub	r8,sp,-1100
800091b4:	0c 9b       	mov	r11,r6
800091b6:	1a d8       	st.w	--sp,r8
800091b8:	08 9c       	mov	r12,r4
800091ba:	fa c8 f9 40 	sub	r8,sp,-1728
800091be:	fa c9 ff b4 	sub	r9,sp,-76
800091c2:	fe b0 fa 55 	rcall	8000866c <get_arg>
800091c6:	2f dd       	sub	sp,-12
800091c8:	78 1a       	ld.w	r10,r12[0x4]
800091ca:	50 7a       	stdsp	sp[0x1c],r10
800091cc:	78 0c       	ld.w	r12,r12[0x0]
800091ce:	50 5c       	stdsp	sp[0x14],r12
800091d0:	c2 a8       	rjmp	80009224 <_vfprintf_r+0x888>
800091d2:	2f f7       	sub	r7,-1
800091d4:	10 39       	cp.w	r9,r8
800091d6:	c0 94       	brge	800091e8 <_vfprintf_r+0x84c>
800091d8:	fa c9 f9 44 	sub	r9,sp,-1724
800091dc:	f2 06 00 36 	add	r6,r9,r6<<0x3
800091e0:	ec f8 fd 8c 	ld.w	r8,r6[-628]
800091e4:	50 78       	stdsp	sp[0x1c],r8
800091e6:	cb 6b       	rjmp	80009152 <_vfprintf_r+0x7b6>
800091e8:	41 09       	lddsp	r9,sp[0x40]
800091ea:	59 f8       	cp.w	r8,31
800091ec:	e0 89 00 15 	brgt	80009216 <_vfprintf_r+0x87a>
800091f0:	f2 ca ff f8 	sub	r10,r9,-8
800091f4:	72 16       	ld.w	r6,r9[0x4]
800091f6:	72 09       	ld.w	r9,r9[0x0]
800091f8:	51 0a       	stdsp	sp[0x40],r10
800091fa:	50 59       	stdsp	sp[0x14],r9
800091fc:	fa ce f9 44 	sub	lr,sp,-1724
80009200:	50 76       	stdsp	sp[0x1c],r6
80009202:	fc 08 00 39 	add	r9,lr,r8<<0x3
80009206:	40 5b       	lddsp	r11,sp[0x14]
80009208:	0c 9a       	mov	r10,r6
8000920a:	f2 eb fd 88 	st.d	r9[-632],r10
8000920e:	2f f8       	sub	r8,-1
80009210:	fb 48 06 b4 	st.w	sp[1716],r8
80009214:	c0 88       	rjmp	80009224 <_vfprintf_r+0x888>
80009216:	72 1c       	ld.w	r12,r9[0x4]
80009218:	50 7c       	stdsp	sp[0x1c],r12
8000921a:	f2 c8 ff f8 	sub	r8,r9,-8
8000921e:	51 08       	stdsp	sp[0x40],r8
80009220:	72 09       	ld.w	r9,r9[0x0]
80009222:	50 59       	stdsp	sp[0x14],r9
80009224:	40 5b       	lddsp	r11,sp[0x14]
80009226:	40 7a       	lddsp	r10,sp[0x1c]
80009228:	e0 a0 19 54 	rcall	8000c4d0 <__isinfd>
8000922c:	18 96       	mov	r6,r12
8000922e:	c1 70       	breq	8000925c <_vfprintf_r+0x8c0>
80009230:	30 08       	mov	r8,0
80009232:	30 09       	mov	r9,0
80009234:	40 5b       	lddsp	r11,sp[0x14]
80009236:	40 7a       	lddsp	r10,sp[0x1c]
80009238:	e0 a0 1d b4 	rcall	8000cda0 <__avr32_f64_cmp_lt>
8000923c:	c0 40       	breq	80009244 <_vfprintf_r+0x8a8>
8000923e:	32 d8       	mov	r8,45
80009240:	fb 68 06 bb 	st.b	sp[1723],r8
80009244:	fe c8 a9 1c 	sub	r8,pc,-22244
80009248:	fe c6 a9 1c 	sub	r6,pc,-22244
8000924c:	a7 d5       	cbr	r5,0x7
8000924e:	e0 40 00 47 	cp.w	r0,71
80009252:	f0 06 17 a0 	movle	r6,r8
80009256:	30 32       	mov	r2,3
80009258:	e0 8f 06 ce 	bral	80009ff4 <_vfprintf_r+0x1658>
8000925c:	40 5b       	lddsp	r11,sp[0x14]
8000925e:	40 7a       	lddsp	r10,sp[0x1c]
80009260:	e0 a0 19 4d 	rcall	8000c4fa <__isnand>
80009264:	c0 e0       	breq	80009280 <_vfprintf_r+0x8e4>
80009266:	50 26       	stdsp	sp[0x8],r6
80009268:	fe c8 a9 38 	sub	r8,pc,-22216
8000926c:	fe c6 a9 38 	sub	r6,pc,-22216
80009270:	a7 d5       	cbr	r5,0x7
80009272:	e0 40 00 47 	cp.w	r0,71
80009276:	f0 06 17 a0 	movle	r6,r8
8000927a:	30 32       	mov	r2,3
8000927c:	e0 8f 06 c2 	bral	8000a000 <_vfprintf_r+0x1664>
80009280:	40 2a       	lddsp	r10,sp[0x8]
80009282:	5b fa       	cp.w	r10,-1
80009284:	c0 41       	brne	8000928c <_vfprintf_r+0x8f0>
80009286:	30 69       	mov	r9,6
80009288:	50 29       	stdsp	sp[0x8],r9
8000928a:	c1 18       	rjmp	800092ac <_vfprintf_r+0x910>
8000928c:	e0 40 00 47 	cp.w	r0,71
80009290:	5f 09       	sreq	r9
80009292:	e0 40 00 67 	cp.w	r0,103
80009296:	5f 08       	sreq	r8
80009298:	f3 e8 10 08 	or	r8,r9,r8
8000929c:	f8 08 18 00 	cp.b	r8,r12
800092a0:	c0 60       	breq	800092ac <_vfprintf_r+0x910>
800092a2:	40 28       	lddsp	r8,sp[0x8]
800092a4:	58 08       	cp.w	r8,0
800092a6:	f9 b8 00 01 	moveq	r8,1
800092aa:	50 28       	stdsp	sp[0x8],r8
800092ac:	40 78       	lddsp	r8,sp[0x1c]
800092ae:	40 59       	lddsp	r9,sp[0x14]
800092b0:	fa e9 06 94 	st.d	sp[1684],r8
800092b4:	a9 a5       	sbr	r5,0x8
800092b6:	fa f8 06 94 	ld.w	r8,sp[1684]
800092ba:	58 08       	cp.w	r8,0
800092bc:	c0 65       	brlt	800092c8 <_vfprintf_r+0x92c>
800092be:	40 5e       	lddsp	lr,sp[0x14]
800092c0:	30 0c       	mov	r12,0
800092c2:	50 6e       	stdsp	sp[0x18],lr
800092c4:	50 9c       	stdsp	sp[0x24],r12
800092c6:	c0 78       	rjmp	800092d4 <_vfprintf_r+0x938>
800092c8:	40 5b       	lddsp	r11,sp[0x14]
800092ca:	32 da       	mov	r10,45
800092cc:	ee 1b 80 00 	eorh	r11,0x8000
800092d0:	50 9a       	stdsp	sp[0x24],r10
800092d2:	50 6b       	stdsp	sp[0x18],r11
800092d4:	e0 40 00 46 	cp.w	r0,70
800092d8:	5f 09       	sreq	r9
800092da:	e0 40 00 66 	cp.w	r0,102
800092de:	5f 08       	sreq	r8
800092e0:	f3 e8 10 08 	or	r8,r9,r8
800092e4:	50 48       	stdsp	sp[0x10],r8
800092e6:	c0 40       	breq	800092ee <_vfprintf_r+0x952>
800092e8:	40 22       	lddsp	r2,sp[0x8]
800092ea:	30 39       	mov	r9,3
800092ec:	c1 08       	rjmp	8000930c <_vfprintf_r+0x970>
800092ee:	e0 40 00 45 	cp.w	r0,69
800092f2:	5f 09       	sreq	r9
800092f4:	e0 40 00 65 	cp.w	r0,101
800092f8:	5f 08       	sreq	r8
800092fa:	40 22       	lddsp	r2,sp[0x8]
800092fc:	10 49       	or	r9,r8
800092fe:	2f f2       	sub	r2,-1
80009300:	40 46       	lddsp	r6,sp[0x10]
80009302:	ec 09 18 00 	cp.b	r9,r6
80009306:	fb f2 00 02 	ld.weq	r2,sp[0x8]
8000930a:	30 29       	mov	r9,2
8000930c:	fa c8 f9 5c 	sub	r8,sp,-1700
80009310:	1a d8       	st.w	--sp,r8
80009312:	fa c8 f9 54 	sub	r8,sp,-1708
80009316:	1a d8       	st.w	--sp,r8
80009318:	fa c8 f9 4c 	sub	r8,sp,-1716
8000931c:	08 9c       	mov	r12,r4
8000931e:	1a d8       	st.w	--sp,r8
80009320:	04 98       	mov	r8,r2
80009322:	40 9b       	lddsp	r11,sp[0x24]
80009324:	40 aa       	lddsp	r10,sp[0x28]
80009326:	e0 a0 0b c3 	rcall	8000aaac <_dtoa_r>
8000932a:	e0 40 00 47 	cp.w	r0,71
8000932e:	5f 19       	srne	r9
80009330:	e0 40 00 67 	cp.w	r0,103
80009334:	5f 18       	srne	r8
80009336:	18 96       	mov	r6,r12
80009338:	2f dd       	sub	sp,-12
8000933a:	f3 e8 00 08 	and	r8,r9,r8
8000933e:	c0 41       	brne	80009346 <_vfprintf_r+0x9aa>
80009340:	ed b5 00 00 	bld	r5,0x0
80009344:	c3 01       	brne	800093a4 <_vfprintf_r+0xa08>
80009346:	ec 02 00 0e 	add	lr,r6,r2
8000934a:	50 3e       	stdsp	sp[0xc],lr
8000934c:	40 4c       	lddsp	r12,sp[0x10]
8000934e:	58 0c       	cp.w	r12,0
80009350:	c1 50       	breq	8000937a <_vfprintf_r+0x9de>
80009352:	0d 89       	ld.ub	r9,r6[0x0]
80009354:	33 08       	mov	r8,48
80009356:	f0 09 18 00 	cp.b	r9,r8
8000935a:	c0 b1       	brne	80009370 <_vfprintf_r+0x9d4>
8000935c:	30 08       	mov	r8,0
8000935e:	30 09       	mov	r9,0
80009360:	40 6b       	lddsp	r11,sp[0x18]
80009362:	40 7a       	lddsp	r10,sp[0x1c]
80009364:	e0 a0 1c d7 	rcall	8000cd12 <__avr32_f64_cmp_eq>
80009368:	fb b2 00 01 	rsubeq	r2,1
8000936c:	fb f2 0b ab 	st.weq	sp[0x6ac],r2
80009370:	40 3b       	lddsp	r11,sp[0xc]
80009372:	fa f8 06 ac 	ld.w	r8,sp[1708]
80009376:	10 0b       	add	r11,r8
80009378:	50 3b       	stdsp	sp[0xc],r11
8000937a:	40 6b       	lddsp	r11,sp[0x18]
8000937c:	30 08       	mov	r8,0
8000937e:	30 09       	mov	r9,0
80009380:	40 7a       	lddsp	r10,sp[0x1c]
80009382:	e0 a0 1c c8 	rcall	8000cd12 <__avr32_f64_cmp_eq>
80009386:	c0 90       	breq	80009398 <_vfprintf_r+0x9fc>
80009388:	40 3a       	lddsp	r10,sp[0xc]
8000938a:	fb 4a 06 a4 	st.w	sp[1700],r10
8000938e:	c0 58       	rjmp	80009398 <_vfprintf_r+0x9fc>
80009390:	10 c9       	st.b	r8++,r9
80009392:	fb 48 06 a4 	st.w	sp[1700],r8
80009396:	c0 28       	rjmp	8000939a <_vfprintf_r+0x9fe>
80009398:	33 09       	mov	r9,48
8000939a:	fa f8 06 a4 	ld.w	r8,sp[1700]
8000939e:	40 3e       	lddsp	lr,sp[0xc]
800093a0:	1c 38       	cp.w	r8,lr
800093a2:	cf 73       	brcs	80009390 <_vfprintf_r+0x9f4>
800093a4:	e0 40 00 47 	cp.w	r0,71
800093a8:	5f 09       	sreq	r9
800093aa:	e0 40 00 67 	cp.w	r0,103
800093ae:	5f 08       	sreq	r8
800093b0:	f3 e8 10 08 	or	r8,r9,r8
800093b4:	fa f9 06 a4 	ld.w	r9,sp[1700]
800093b8:	0c 19       	sub	r9,r6
800093ba:	50 69       	stdsp	sp[0x18],r9
800093bc:	58 08       	cp.w	r8,0
800093be:	c0 b0       	breq	800093d4 <_vfprintf_r+0xa38>
800093c0:	fa f8 06 ac 	ld.w	r8,sp[1708]
800093c4:	5b d8       	cp.w	r8,-3
800093c6:	c0 55       	brlt	800093d0 <_vfprintf_r+0xa34>
800093c8:	40 2c       	lddsp	r12,sp[0x8]
800093ca:	18 38       	cp.w	r8,r12
800093cc:	e0 8a 00 6a 	brle	800094a0 <_vfprintf_r+0xb04>
800093d0:	20 20       	sub	r0,2
800093d2:	c0 58       	rjmp	800093dc <_vfprintf_r+0xa40>
800093d4:	e0 40 00 65 	cp.w	r0,101
800093d8:	e0 89 00 46 	brgt	80009464 <_vfprintf_r+0xac8>
800093dc:	fa fb 06 ac 	ld.w	r11,sp[1708]
800093e0:	fb 60 06 9c 	st.b	sp[1692],r0
800093e4:	20 1b       	sub	r11,1
800093e6:	fb 4b 06 ac 	st.w	sp[1708],r11
800093ea:	c0 47       	brpl	800093f2 <_vfprintf_r+0xa56>
800093ec:	5c 3b       	neg	r11
800093ee:	32 d8       	mov	r8,45
800093f0:	c0 28       	rjmp	800093f4 <_vfprintf_r+0xa58>
800093f2:	32 b8       	mov	r8,43
800093f4:	fb 68 06 9d 	st.b	sp[1693],r8
800093f8:	58 9b       	cp.w	r11,9
800093fa:	e0 8a 00 1d 	brle	80009434 <_vfprintf_r+0xa98>
800093fe:	fa c9 fa 35 	sub	r9,sp,-1483
80009402:	30 aa       	mov	r10,10
80009404:	12 98       	mov	r8,r9
80009406:	0e 9c       	mov	r12,r7
80009408:	0c 92       	mov	r2,r6
8000940a:	f6 0a 0c 06 	divs	r6,r11,r10
8000940e:	0e 9b       	mov	r11,r7
80009410:	2d 0b       	sub	r11,-48
80009412:	10 fb       	st.b	--r8,r11
80009414:	0c 9b       	mov	r11,r6
80009416:	58 96       	cp.w	r6,9
80009418:	fe 99 ff f9 	brgt	8000940a <_vfprintf_r+0xa6e>
8000941c:	2d 0b       	sub	r11,-48
8000941e:	18 97       	mov	r7,r12
80009420:	04 96       	mov	r6,r2
80009422:	10 fb       	st.b	--r8,r11
80009424:	fa ca f9 62 	sub	r10,sp,-1694
80009428:	c0 38       	rjmp	8000942e <_vfprintf_r+0xa92>
8000942a:	11 3b       	ld.ub	r11,r8++
8000942c:	14 cb       	st.b	r10++,r11
8000942e:	12 38       	cp.w	r8,r9
80009430:	cf d3       	brcs	8000942a <_vfprintf_r+0xa8e>
80009432:	c0 98       	rjmp	80009444 <_vfprintf_r+0xaa8>
80009434:	2d 0b       	sub	r11,-48
80009436:	33 08       	mov	r8,48
80009438:	fb 6b 06 9f 	st.b	sp[1695],r11
8000943c:	fb 68 06 9e 	st.b	sp[1694],r8
80009440:	fa ca f9 60 	sub	r10,sp,-1696
80009444:	fa c8 f9 64 	sub	r8,sp,-1692
80009448:	f4 08 01 08 	sub	r8,r10,r8
8000944c:	50 e8       	stdsp	sp[0x38],r8
8000944e:	10 92       	mov	r2,r8
80009450:	40 6b       	lddsp	r11,sp[0x18]
80009452:	16 02       	add	r2,r11
80009454:	58 1b       	cp.w	r11,1
80009456:	e0 89 00 05 	brgt	80009460 <_vfprintf_r+0xac4>
8000945a:	ed b5 00 00 	bld	r5,0x0
8000945e:	c3 51       	brne	800094c8 <_vfprintf_r+0xb2c>
80009460:	2f f2       	sub	r2,-1
80009462:	c3 38       	rjmp	800094c8 <_vfprintf_r+0xb2c>
80009464:	e0 40 00 66 	cp.w	r0,102
80009468:	c1 c1       	brne	800094a0 <_vfprintf_r+0xb04>
8000946a:	fa f2 06 ac 	ld.w	r2,sp[1708]
8000946e:	58 02       	cp.w	r2,0
80009470:	e0 8a 00 0c 	brle	80009488 <_vfprintf_r+0xaec>
80009474:	40 2a       	lddsp	r10,sp[0x8]
80009476:	58 0a       	cp.w	r10,0
80009478:	c0 41       	brne	80009480 <_vfprintf_r+0xae4>
8000947a:	ed b5 00 00 	bld	r5,0x0
8000947e:	c2 51       	brne	800094c8 <_vfprintf_r+0xb2c>
80009480:	2f f2       	sub	r2,-1
80009482:	40 29       	lddsp	r9,sp[0x8]
80009484:	12 02       	add	r2,r9
80009486:	c0 b8       	rjmp	8000949c <_vfprintf_r+0xb00>
80009488:	40 28       	lddsp	r8,sp[0x8]
8000948a:	58 08       	cp.w	r8,0
8000948c:	c0 61       	brne	80009498 <_vfprintf_r+0xafc>
8000948e:	ed b5 00 00 	bld	r5,0x0
80009492:	c0 30       	breq	80009498 <_vfprintf_r+0xafc>
80009494:	30 12       	mov	r2,1
80009496:	c1 98       	rjmp	800094c8 <_vfprintf_r+0xb2c>
80009498:	40 22       	lddsp	r2,sp[0x8]
8000949a:	2f e2       	sub	r2,-2
8000949c:	36 60       	mov	r0,102
8000949e:	c1 58       	rjmp	800094c8 <_vfprintf_r+0xb2c>
800094a0:	fa f2 06 ac 	ld.w	r2,sp[1708]
800094a4:	40 6e       	lddsp	lr,sp[0x18]
800094a6:	1c 32       	cp.w	r2,lr
800094a8:	c0 65       	brlt	800094b4 <_vfprintf_r+0xb18>
800094aa:	ed b5 00 00 	bld	r5,0x0
800094ae:	f7 b2 00 ff 	subeq	r2,-1
800094b2:	c0 a8       	rjmp	800094c6 <_vfprintf_r+0xb2a>
800094b4:	e4 08 11 02 	rsub	r8,r2,2
800094b8:	40 6c       	lddsp	r12,sp[0x18]
800094ba:	58 02       	cp.w	r2,0
800094bc:	f0 02 17 a0 	movle	r2,r8
800094c0:	f9 b2 09 01 	movgt	r2,1
800094c4:	18 02       	add	r2,r12
800094c6:	36 70       	mov	r0,103
800094c8:	40 9b       	lddsp	r11,sp[0x24]
800094ca:	58 0b       	cp.w	r11,0
800094cc:	e0 80 05 94 	breq	80009ff4 <_vfprintf_r+0x1658>
800094d0:	32 d8       	mov	r8,45
800094d2:	fb 68 06 bb 	st.b	sp[1723],r8
800094d6:	e0 8f 05 93 	bral	80009ffc <_vfprintf_r+0x1660>
800094da:	50 a7       	stdsp	sp[0x28],r7
800094dc:	04 94       	mov	r4,r2
800094de:	0c 97       	mov	r7,r6
800094e0:	02 92       	mov	r2,r1
800094e2:	06 96       	mov	r6,r3
800094e4:	40 41       	lddsp	r1,sp[0x10]
800094e6:	40 93       	lddsp	r3,sp[0x24]
800094e8:	0e 99       	mov	r9,r7
800094ea:	ed b5 00 05 	bld	r5,0x5
800094ee:	c4 81       	brne	8000957e <_vfprintf_r+0xbe2>
800094f0:	fa f8 06 b4 	ld.w	r8,sp[1716]
800094f4:	40 3e       	lddsp	lr,sp[0xc]
800094f6:	58 0e       	cp.w	lr,0
800094f8:	c1 d0       	breq	80009532 <_vfprintf_r+0xb96>
800094fa:	10 36       	cp.w	r6,r8
800094fc:	c0 64       	brge	80009508 <_vfprintf_r+0xb6c>
800094fe:	fa cc f9 44 	sub	r12,sp,-1724
80009502:	f8 06 00 36 	add	r6,r12,r6<<0x3
80009506:	c1 d8       	rjmp	80009540 <_vfprintf_r+0xba4>
80009508:	fa c8 f9 50 	sub	r8,sp,-1712
8000950c:	1a d8       	st.w	--sp,r8
8000950e:	fa c8 fa b8 	sub	r8,sp,-1352
80009512:	04 9a       	mov	r10,r2
80009514:	1a d8       	st.w	--sp,r8
80009516:	fa c8 fb b4 	sub	r8,sp,-1100
8000951a:	0c 9b       	mov	r11,r6
8000951c:	1a d8       	st.w	--sp,r8
8000951e:	08 9c       	mov	r12,r4
80009520:	fa c8 f9 40 	sub	r8,sp,-1728
80009524:	fa c9 ff b4 	sub	r9,sp,-76
80009528:	fe b0 f8 a2 	rcall	8000866c <get_arg>
8000952c:	2f dd       	sub	sp,-12
8000952e:	78 0a       	ld.w	r10,r12[0x0]
80009530:	c2 08       	rjmp	80009570 <_vfprintf_r+0xbd4>
80009532:	2f f7       	sub	r7,-1
80009534:	10 39       	cp.w	r9,r8
80009536:	c0 84       	brge	80009546 <_vfprintf_r+0xbaa>
80009538:	fa cb f9 44 	sub	r11,sp,-1724
8000953c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009540:	ec fa fd 88 	ld.w	r10,r6[-632]
80009544:	c1 68       	rjmp	80009570 <_vfprintf_r+0xbd4>
80009546:	41 09       	lddsp	r9,sp[0x40]
80009548:	59 f8       	cp.w	r8,31
8000954a:	e0 89 00 10 	brgt	8000956a <_vfprintf_r+0xbce>
8000954e:	f2 ca ff fc 	sub	r10,r9,-4
80009552:	51 0a       	stdsp	sp[0x40],r10
80009554:	fa c6 f9 44 	sub	r6,sp,-1724
80009558:	72 0a       	ld.w	r10,r9[0x0]
8000955a:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000955e:	f3 4a fd 88 	st.w	r9[-632],r10
80009562:	2f f8       	sub	r8,-1
80009564:	fb 48 06 b4 	st.w	sp[1716],r8
80009568:	c0 48       	rjmp	80009570 <_vfprintf_r+0xbd4>
8000956a:	72 0a       	ld.w	r10,r9[0x0]
8000956c:	2f c9       	sub	r9,-4
8000956e:	51 09       	stdsp	sp[0x40],r9
80009570:	40 be       	lddsp	lr,sp[0x2c]
80009572:	1c 98       	mov	r8,lr
80009574:	95 1e       	st.w	r10[0x4],lr
80009576:	bf 58       	asr	r8,0x1f
80009578:	95 08       	st.w	r10[0x0],r8
8000957a:	fe 9f fa 9f 	bral	80008ab8 <_vfprintf_r+0x11c>
8000957e:	ed b5 00 04 	bld	r5,0x4
80009582:	c4 80       	breq	80009612 <_vfprintf_r+0xc76>
80009584:	e2 15 00 40 	andl	r5,0x40,COH
80009588:	c4 50       	breq	80009612 <_vfprintf_r+0xc76>
8000958a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000958e:	40 3c       	lddsp	r12,sp[0xc]
80009590:	58 0c       	cp.w	r12,0
80009592:	c1 d0       	breq	800095cc <_vfprintf_r+0xc30>
80009594:	10 36       	cp.w	r6,r8
80009596:	c0 64       	brge	800095a2 <_vfprintf_r+0xc06>
80009598:	fa cb f9 44 	sub	r11,sp,-1724
8000959c:	f6 06 00 36 	add	r6,r11,r6<<0x3
800095a0:	c1 d8       	rjmp	800095da <_vfprintf_r+0xc3e>
800095a2:	fa c8 f9 50 	sub	r8,sp,-1712
800095a6:	1a d8       	st.w	--sp,r8
800095a8:	fa c8 fa b8 	sub	r8,sp,-1352
800095ac:	04 9a       	mov	r10,r2
800095ae:	1a d8       	st.w	--sp,r8
800095b0:	fa c8 fb b4 	sub	r8,sp,-1100
800095b4:	0c 9b       	mov	r11,r6
800095b6:	1a d8       	st.w	--sp,r8
800095b8:	08 9c       	mov	r12,r4
800095ba:	fa c8 f9 40 	sub	r8,sp,-1728
800095be:	fa c9 ff b4 	sub	r9,sp,-76
800095c2:	fe b0 f8 55 	rcall	8000866c <get_arg>
800095c6:	2f dd       	sub	sp,-12
800095c8:	78 0a       	ld.w	r10,r12[0x0]
800095ca:	c2 08       	rjmp	8000960a <_vfprintf_r+0xc6e>
800095cc:	2f f7       	sub	r7,-1
800095ce:	10 39       	cp.w	r9,r8
800095d0:	c0 84       	brge	800095e0 <_vfprintf_r+0xc44>
800095d2:	fa ca f9 44 	sub	r10,sp,-1724
800095d6:	f4 06 00 36 	add	r6,r10,r6<<0x3
800095da:	ec fa fd 88 	ld.w	r10,r6[-632]
800095de:	c1 68       	rjmp	8000960a <_vfprintf_r+0xc6e>
800095e0:	41 09       	lddsp	r9,sp[0x40]
800095e2:	59 f8       	cp.w	r8,31
800095e4:	e0 89 00 10 	brgt	80009604 <_vfprintf_r+0xc68>
800095e8:	f2 ca ff fc 	sub	r10,r9,-4
800095ec:	51 0a       	stdsp	sp[0x40],r10
800095ee:	fa c6 f9 44 	sub	r6,sp,-1724
800095f2:	72 0a       	ld.w	r10,r9[0x0]
800095f4:	ec 08 00 39 	add	r9,r6,r8<<0x3
800095f8:	f3 4a fd 88 	st.w	r9[-632],r10
800095fc:	2f f8       	sub	r8,-1
800095fe:	fb 48 06 b4 	st.w	sp[1716],r8
80009602:	c0 48       	rjmp	8000960a <_vfprintf_r+0xc6e>
80009604:	72 0a       	ld.w	r10,r9[0x0]
80009606:	2f c9       	sub	r9,-4
80009608:	51 09       	stdsp	sp[0x40],r9
8000960a:	40 be       	lddsp	lr,sp[0x2c]
8000960c:	b4 0e       	st.h	r10[0x0],lr
8000960e:	fe 9f fa 55 	bral	80008ab8 <_vfprintf_r+0x11c>
80009612:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009616:	40 3c       	lddsp	r12,sp[0xc]
80009618:	58 0c       	cp.w	r12,0
8000961a:	c1 d0       	breq	80009654 <_vfprintf_r+0xcb8>
8000961c:	10 36       	cp.w	r6,r8
8000961e:	c0 64       	brge	8000962a <_vfprintf_r+0xc8e>
80009620:	fa cb f9 44 	sub	r11,sp,-1724
80009624:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009628:	c1 d8       	rjmp	80009662 <_vfprintf_r+0xcc6>
8000962a:	fa c8 f9 50 	sub	r8,sp,-1712
8000962e:	1a d8       	st.w	--sp,r8
80009630:	fa c8 fa b8 	sub	r8,sp,-1352
80009634:	04 9a       	mov	r10,r2
80009636:	1a d8       	st.w	--sp,r8
80009638:	fa c8 fb b4 	sub	r8,sp,-1100
8000963c:	0c 9b       	mov	r11,r6
8000963e:	1a d8       	st.w	--sp,r8
80009640:	08 9c       	mov	r12,r4
80009642:	fa c8 f9 40 	sub	r8,sp,-1728
80009646:	fa c9 ff b4 	sub	r9,sp,-76
8000964a:	fe b0 f8 11 	rcall	8000866c <get_arg>
8000964e:	2f dd       	sub	sp,-12
80009650:	78 0a       	ld.w	r10,r12[0x0]
80009652:	c2 08       	rjmp	80009692 <_vfprintf_r+0xcf6>
80009654:	2f f7       	sub	r7,-1
80009656:	10 39       	cp.w	r9,r8
80009658:	c0 84       	brge	80009668 <_vfprintf_r+0xccc>
8000965a:	fa ca f9 44 	sub	r10,sp,-1724
8000965e:	f4 06 00 36 	add	r6,r10,r6<<0x3
80009662:	ec fa fd 88 	ld.w	r10,r6[-632]
80009666:	c1 68       	rjmp	80009692 <_vfprintf_r+0xcf6>
80009668:	41 09       	lddsp	r9,sp[0x40]
8000966a:	59 f8       	cp.w	r8,31
8000966c:	e0 89 00 10 	brgt	8000968c <_vfprintf_r+0xcf0>
80009670:	f2 ca ff fc 	sub	r10,r9,-4
80009674:	51 0a       	stdsp	sp[0x40],r10
80009676:	fa c6 f9 44 	sub	r6,sp,-1724
8000967a:	72 0a       	ld.w	r10,r9[0x0]
8000967c:	ec 08 00 39 	add	r9,r6,r8<<0x3
80009680:	f3 4a fd 88 	st.w	r9[-632],r10
80009684:	2f f8       	sub	r8,-1
80009686:	fb 48 06 b4 	st.w	sp[1716],r8
8000968a:	c0 48       	rjmp	80009692 <_vfprintf_r+0xcf6>
8000968c:	72 0a       	ld.w	r10,r9[0x0]
8000968e:	2f c9       	sub	r9,-4
80009690:	51 09       	stdsp	sp[0x40],r9
80009692:	40 be       	lddsp	lr,sp[0x2c]
80009694:	95 0e       	st.w	r10[0x0],lr
80009696:	fe 9f fa 11 	bral	80008ab8 <_vfprintf_r+0x11c>
8000969a:	50 a7       	stdsp	sp[0x28],r7
8000969c:	50 80       	stdsp	sp[0x20],r0
8000969e:	0c 97       	mov	r7,r6
800096a0:	04 94       	mov	r4,r2
800096a2:	06 96       	mov	r6,r3
800096a4:	02 92       	mov	r2,r1
800096a6:	40 93       	lddsp	r3,sp[0x24]
800096a8:	10 90       	mov	r0,r8
800096aa:	40 41       	lddsp	r1,sp[0x10]
800096ac:	a5 a5       	sbr	r5,0x4
800096ae:	c0 a8       	rjmp	800096c2 <_vfprintf_r+0xd26>
800096b0:	50 a7       	stdsp	sp[0x28],r7
800096b2:	50 80       	stdsp	sp[0x20],r0
800096b4:	0c 97       	mov	r7,r6
800096b6:	04 94       	mov	r4,r2
800096b8:	06 96       	mov	r6,r3
800096ba:	02 92       	mov	r2,r1
800096bc:	40 93       	lddsp	r3,sp[0x24]
800096be:	10 90       	mov	r0,r8
800096c0:	40 41       	lddsp	r1,sp[0x10]
800096c2:	ed b5 00 05 	bld	r5,0x5
800096c6:	c5 d1       	brne	80009780 <_vfprintf_r+0xde4>
800096c8:	fa f8 06 b4 	ld.w	r8,sp[1716]
800096cc:	40 3c       	lddsp	r12,sp[0xc]
800096ce:	58 0c       	cp.w	r12,0
800096d0:	c2 60       	breq	8000971c <_vfprintf_r+0xd80>
800096d2:	10 36       	cp.w	r6,r8
800096d4:	c0 a4       	brge	800096e8 <_vfprintf_r+0xd4c>
800096d6:	fa cb f9 44 	sub	r11,sp,-1724
800096da:	f6 06 00 36 	add	r6,r11,r6<<0x3
800096de:	ec e8 fd 88 	ld.d	r8,r6[-632]
800096e2:	fa e9 00 00 	st.d	sp[0],r8
800096e6:	c1 88       	rjmp	80009716 <_vfprintf_r+0xd7a>
800096e8:	fa c8 f9 50 	sub	r8,sp,-1712
800096ec:	1a d8       	st.w	--sp,r8
800096ee:	fa c8 fa b8 	sub	r8,sp,-1352
800096f2:	04 9a       	mov	r10,r2
800096f4:	1a d8       	st.w	--sp,r8
800096f6:	0c 9b       	mov	r11,r6
800096f8:	fa c8 fb b4 	sub	r8,sp,-1100
800096fc:	08 9c       	mov	r12,r4
800096fe:	1a d8       	st.w	--sp,r8
80009700:	fa c8 f9 40 	sub	r8,sp,-1728
80009704:	fa c9 ff b4 	sub	r9,sp,-76
80009708:	fe b0 f7 b2 	rcall	8000866c <get_arg>
8000970c:	2f dd       	sub	sp,-12
8000970e:	f8 ea 00 00 	ld.d	r10,r12[0]
80009712:	fa eb 00 00 	st.d	sp[0],r10
80009716:	30 08       	mov	r8,0
80009718:	e0 8f 03 de 	bral	80009ed4 <_vfprintf_r+0x1538>
8000971c:	ee ca ff ff 	sub	r10,r7,-1
80009720:	10 37       	cp.w	r7,r8
80009722:	c0 b4       	brge	80009738 <_vfprintf_r+0xd9c>
80009724:	fa c9 f9 44 	sub	r9,sp,-1724
80009728:	14 97       	mov	r7,r10
8000972a:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000972e:	ec ea fd 88 	ld.d	r10,r6[-632]
80009732:	fa eb 00 00 	st.d	sp[0],r10
80009736:	c1 88       	rjmp	80009766 <_vfprintf_r+0xdca>
80009738:	41 09       	lddsp	r9,sp[0x40]
8000973a:	59 f8       	cp.w	r8,31
8000973c:	e0 89 00 18 	brgt	8000976c <_vfprintf_r+0xdd0>
80009740:	f2 e6 00 00 	ld.d	r6,r9[0]
80009744:	f2 cb ff f8 	sub	r11,r9,-8
80009748:	fa e7 00 00 	st.d	sp[0],r6
8000974c:	51 0b       	stdsp	sp[0x40],r11
8000974e:	fa c6 f9 44 	sub	r6,sp,-1724
80009752:	ec 08 00 39 	add	r9,r6,r8<<0x3
80009756:	fa e6 00 00 	ld.d	r6,sp[0]
8000975a:	f2 e7 fd 88 	st.d	r9[-632],r6
8000975e:	2f f8       	sub	r8,-1
80009760:	14 97       	mov	r7,r10
80009762:	fb 48 06 b4 	st.w	sp[1716],r8
80009766:	40 38       	lddsp	r8,sp[0xc]
80009768:	e0 8f 03 b6 	bral	80009ed4 <_vfprintf_r+0x1538>
8000976c:	f2 e6 00 00 	ld.d	r6,r9[0]
80009770:	40 38       	lddsp	r8,sp[0xc]
80009772:	fa e7 00 00 	st.d	sp[0],r6
80009776:	2f 89       	sub	r9,-8
80009778:	14 97       	mov	r7,r10
8000977a:	51 09       	stdsp	sp[0x40],r9
8000977c:	e0 8f 03 ac 	bral	80009ed4 <_vfprintf_r+0x1538>
80009780:	ed b5 00 04 	bld	r5,0x4
80009784:	c1 61       	brne	800097b0 <_vfprintf_r+0xe14>
80009786:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000978a:	40 3e       	lddsp	lr,sp[0xc]
8000978c:	58 0e       	cp.w	lr,0
8000978e:	c0 80       	breq	8000979e <_vfprintf_r+0xe02>
80009790:	10 36       	cp.w	r6,r8
80009792:	c6 74       	brge	80009860 <_vfprintf_r+0xec4>
80009794:	fa cc f9 44 	sub	r12,sp,-1724
80009798:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000979c:	c8 08       	rjmp	8000989c <_vfprintf_r+0xf00>
8000979e:	ee ca ff ff 	sub	r10,r7,-1
800097a2:	10 37       	cp.w	r7,r8
800097a4:	c7 f4       	brge	800098a2 <_vfprintf_r+0xf06>
800097a6:	fa cb f9 44 	sub	r11,sp,-1724
800097aa:	f6 06 00 36 	add	r6,r11,r6<<0x3
800097ae:	c7 68       	rjmp	8000989a <_vfprintf_r+0xefe>
800097b0:	ed b5 00 06 	bld	r5,0x6
800097b4:	c4 a1       	brne	80009848 <_vfprintf_r+0xeac>
800097b6:	fa f8 06 b4 	ld.w	r8,sp[1716]
800097ba:	40 3c       	lddsp	r12,sp[0xc]
800097bc:	58 0c       	cp.w	r12,0
800097be:	c1 d0       	breq	800097f8 <_vfprintf_r+0xe5c>
800097c0:	10 36       	cp.w	r6,r8
800097c2:	c0 64       	brge	800097ce <_vfprintf_r+0xe32>
800097c4:	fa cb f9 44 	sub	r11,sp,-1724
800097c8:	f6 06 00 36 	add	r6,r11,r6<<0x3
800097cc:	c1 f8       	rjmp	8000980a <_vfprintf_r+0xe6e>
800097ce:	fa c8 f9 50 	sub	r8,sp,-1712
800097d2:	1a d8       	st.w	--sp,r8
800097d4:	fa c8 fa b8 	sub	r8,sp,-1352
800097d8:	1a d8       	st.w	--sp,r8
800097da:	fa c8 fb b4 	sub	r8,sp,-1100
800097de:	1a d8       	st.w	--sp,r8
800097e0:	fa c8 f9 40 	sub	r8,sp,-1728
800097e4:	fa c9 ff b4 	sub	r9,sp,-76
800097e8:	04 9a       	mov	r10,r2
800097ea:	0c 9b       	mov	r11,r6
800097ec:	08 9c       	mov	r12,r4
800097ee:	fe b0 f7 3f 	rcall	8000866c <get_arg>
800097f2:	2f dd       	sub	sp,-12
800097f4:	98 18       	ld.sh	r8,r12[0x2]
800097f6:	c2 68       	rjmp	80009842 <_vfprintf_r+0xea6>
800097f8:	ee ca ff ff 	sub	r10,r7,-1
800097fc:	10 37       	cp.w	r7,r8
800097fe:	c0 94       	brge	80009810 <_vfprintf_r+0xe74>
80009800:	fa c9 f9 44 	sub	r9,sp,-1724
80009804:	14 97       	mov	r7,r10
80009806:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000980a:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000980e:	c1 a8       	rjmp	80009842 <_vfprintf_r+0xea6>
80009810:	41 09       	lddsp	r9,sp[0x40]
80009812:	59 f8       	cp.w	r8,31
80009814:	e0 89 00 13 	brgt	8000983a <_vfprintf_r+0xe9e>
80009818:	f2 cb ff fc 	sub	r11,r9,-4
8000981c:	51 0b       	stdsp	sp[0x40],r11
8000981e:	72 09       	ld.w	r9,r9[0x0]
80009820:	fa c6 f9 44 	sub	r6,sp,-1724
80009824:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80009828:	2f f8       	sub	r8,-1
8000982a:	f7 49 fd 88 	st.w	r11[-632],r9
8000982e:	fb 48 06 b4 	st.w	sp[1716],r8
80009832:	14 97       	mov	r7,r10
80009834:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80009838:	c0 58       	rjmp	80009842 <_vfprintf_r+0xea6>
8000983a:	92 18       	ld.sh	r8,r9[0x2]
8000983c:	14 97       	mov	r7,r10
8000983e:	2f c9       	sub	r9,-4
80009840:	51 09       	stdsp	sp[0x40],r9
80009842:	5c 78       	castu.h	r8
80009844:	50 18       	stdsp	sp[0x4],r8
80009846:	c4 68       	rjmp	800098d2 <_vfprintf_r+0xf36>
80009848:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000984c:	40 3c       	lddsp	r12,sp[0xc]
8000984e:	58 0c       	cp.w	r12,0
80009850:	c1 d0       	breq	8000988a <_vfprintf_r+0xeee>
80009852:	10 36       	cp.w	r6,r8
80009854:	c0 64       	brge	80009860 <_vfprintf_r+0xec4>
80009856:	fa cb f9 44 	sub	r11,sp,-1724
8000985a:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000985e:	c1 f8       	rjmp	8000989c <_vfprintf_r+0xf00>
80009860:	fa c8 f9 50 	sub	r8,sp,-1712
80009864:	1a d8       	st.w	--sp,r8
80009866:	fa c8 fa b8 	sub	r8,sp,-1352
8000986a:	0c 9b       	mov	r11,r6
8000986c:	1a d8       	st.w	--sp,r8
8000986e:	fa c8 fb b4 	sub	r8,sp,-1100
80009872:	04 9a       	mov	r10,r2
80009874:	1a d8       	st.w	--sp,r8
80009876:	08 9c       	mov	r12,r4
80009878:	fa c8 f9 40 	sub	r8,sp,-1728
8000987c:	fa c9 ff b4 	sub	r9,sp,-76
80009880:	fe b0 f6 f6 	rcall	8000866c <get_arg>
80009884:	2f dd       	sub	sp,-12
80009886:	78 0b       	ld.w	r11,r12[0x0]
80009888:	c2 48       	rjmp	800098d0 <_vfprintf_r+0xf34>
8000988a:	ee ca ff ff 	sub	r10,r7,-1
8000988e:	10 37       	cp.w	r7,r8
80009890:	c0 94       	brge	800098a2 <_vfprintf_r+0xf06>
80009892:	fa c9 f9 44 	sub	r9,sp,-1724
80009896:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000989a:	14 97       	mov	r7,r10
8000989c:	ec fb fd 88 	ld.w	r11,r6[-632]
800098a0:	c1 88       	rjmp	800098d0 <_vfprintf_r+0xf34>
800098a2:	41 09       	lddsp	r9,sp[0x40]
800098a4:	59 f8       	cp.w	r8,31
800098a6:	e0 89 00 11 	brgt	800098c8 <_vfprintf_r+0xf2c>
800098aa:	f2 cb ff fc 	sub	r11,r9,-4
800098ae:	51 0b       	stdsp	sp[0x40],r11
800098b0:	fa c6 f9 44 	sub	r6,sp,-1724
800098b4:	72 0b       	ld.w	r11,r9[0x0]
800098b6:	ec 08 00 39 	add	r9,r6,r8<<0x3
800098ba:	f3 4b fd 88 	st.w	r9[-632],r11
800098be:	2f f8       	sub	r8,-1
800098c0:	14 97       	mov	r7,r10
800098c2:	fb 48 06 b4 	st.w	sp[1716],r8
800098c6:	c0 58       	rjmp	800098d0 <_vfprintf_r+0xf34>
800098c8:	72 0b       	ld.w	r11,r9[0x0]
800098ca:	14 97       	mov	r7,r10
800098cc:	2f c9       	sub	r9,-4
800098ce:	51 09       	stdsp	sp[0x40],r9
800098d0:	50 1b       	stdsp	sp[0x4],r11
800098d2:	30 0e       	mov	lr,0
800098d4:	50 0e       	stdsp	sp[0x0],lr
800098d6:	1c 98       	mov	r8,lr
800098d8:	e0 8f 02 fe 	bral	80009ed4 <_vfprintf_r+0x1538>
800098dc:	50 a7       	stdsp	sp[0x28],r7
800098de:	50 80       	stdsp	sp[0x20],r0
800098e0:	0c 97       	mov	r7,r6
800098e2:	04 94       	mov	r4,r2
800098e4:	06 96       	mov	r6,r3
800098e6:	02 92       	mov	r2,r1
800098e8:	40 93       	lddsp	r3,sp[0x24]
800098ea:	40 41       	lddsp	r1,sp[0x10]
800098ec:	0e 99       	mov	r9,r7
800098ee:	fa f8 06 b4 	ld.w	r8,sp[1716]
800098f2:	40 3c       	lddsp	r12,sp[0xc]
800098f4:	58 0c       	cp.w	r12,0
800098f6:	c1 d0       	breq	80009930 <_vfprintf_r+0xf94>
800098f8:	10 36       	cp.w	r6,r8
800098fa:	c0 64       	brge	80009906 <_vfprintf_r+0xf6a>
800098fc:	fa cb f9 44 	sub	r11,sp,-1724
80009900:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009904:	c1 d8       	rjmp	8000993e <_vfprintf_r+0xfa2>
80009906:	fa c8 f9 50 	sub	r8,sp,-1712
8000990a:	1a d8       	st.w	--sp,r8
8000990c:	fa c8 fa b8 	sub	r8,sp,-1352
80009910:	1a d8       	st.w	--sp,r8
80009912:	fa c8 fb b4 	sub	r8,sp,-1100
80009916:	1a d8       	st.w	--sp,r8
80009918:	fa c9 ff b4 	sub	r9,sp,-76
8000991c:	fa c8 f9 40 	sub	r8,sp,-1728
80009920:	04 9a       	mov	r10,r2
80009922:	0c 9b       	mov	r11,r6
80009924:	08 9c       	mov	r12,r4
80009926:	fe b0 f6 a3 	rcall	8000866c <get_arg>
8000992a:	2f dd       	sub	sp,-12
8000992c:	78 09       	ld.w	r9,r12[0x0]
8000992e:	c2 18       	rjmp	80009970 <_vfprintf_r+0xfd4>
80009930:	2f f7       	sub	r7,-1
80009932:	10 39       	cp.w	r9,r8
80009934:	c0 84       	brge	80009944 <_vfprintf_r+0xfa8>
80009936:	fa ca f9 44 	sub	r10,sp,-1724
8000993a:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000993e:	ec f9 fd 88 	ld.w	r9,r6[-632]
80009942:	c1 78       	rjmp	80009970 <_vfprintf_r+0xfd4>
80009944:	41 09       	lddsp	r9,sp[0x40]
80009946:	59 f8       	cp.w	r8,31
80009948:	e0 89 00 10 	brgt	80009968 <_vfprintf_r+0xfcc>
8000994c:	f2 ca ff fc 	sub	r10,r9,-4
80009950:	51 0a       	stdsp	sp[0x40],r10
80009952:	fa c6 f9 44 	sub	r6,sp,-1724
80009956:	72 09       	ld.w	r9,r9[0x0]
80009958:	ec 08 00 3a 	add	r10,r6,r8<<0x3
8000995c:	f5 49 fd 88 	st.w	r10[-632],r9
80009960:	2f f8       	sub	r8,-1
80009962:	fb 48 06 b4 	st.w	sp[1716],r8
80009966:	c0 58       	rjmp	80009970 <_vfprintf_r+0xfd4>
80009968:	f2 c8 ff fc 	sub	r8,r9,-4
8000996c:	51 08       	stdsp	sp[0x40],r8
8000996e:	72 09       	ld.w	r9,r9[0x0]
80009970:	33 08       	mov	r8,48
80009972:	fb 68 06 b8 	st.b	sp[1720],r8
80009976:	37 88       	mov	r8,120
80009978:	30 0e       	mov	lr,0
8000997a:	fb 68 06 b9 	st.b	sp[1721],r8
8000997e:	fe cc b0 46 	sub	r12,pc,-20410
80009982:	50 19       	stdsp	sp[0x4],r9
80009984:	a1 b5       	sbr	r5,0x1
80009986:	50 0e       	stdsp	sp[0x0],lr
80009988:	50 dc       	stdsp	sp[0x34],r12
8000998a:	30 28       	mov	r8,2
8000998c:	37 80       	mov	r0,120
8000998e:	e0 8f 02 a3 	bral	80009ed4 <_vfprintf_r+0x1538>
80009992:	50 a7       	stdsp	sp[0x28],r7
80009994:	50 80       	stdsp	sp[0x20],r0
80009996:	10 90       	mov	r0,r8
80009998:	30 08       	mov	r8,0
8000999a:	fb 68 06 bb 	st.b	sp[1723],r8
8000999e:	0c 97       	mov	r7,r6
800099a0:	04 94       	mov	r4,r2
800099a2:	06 96       	mov	r6,r3
800099a4:	02 92       	mov	r2,r1
800099a6:	40 93       	lddsp	r3,sp[0x24]
800099a8:	40 41       	lddsp	r1,sp[0x10]
800099aa:	0e 99       	mov	r9,r7
800099ac:	fa f8 06 b4 	ld.w	r8,sp[1716]
800099b0:	40 3b       	lddsp	r11,sp[0xc]
800099b2:	58 0b       	cp.w	r11,0
800099b4:	c1 d0       	breq	800099ee <_vfprintf_r+0x1052>
800099b6:	10 36       	cp.w	r6,r8
800099b8:	c0 64       	brge	800099c4 <_vfprintf_r+0x1028>
800099ba:	fa ca f9 44 	sub	r10,sp,-1724
800099be:	f4 06 00 36 	add	r6,r10,r6<<0x3
800099c2:	c1 d8       	rjmp	800099fc <_vfprintf_r+0x1060>
800099c4:	fa c8 f9 50 	sub	r8,sp,-1712
800099c8:	1a d8       	st.w	--sp,r8
800099ca:	fa c8 fa b8 	sub	r8,sp,-1352
800099ce:	1a d8       	st.w	--sp,r8
800099d0:	fa c8 fb b4 	sub	r8,sp,-1100
800099d4:	0c 9b       	mov	r11,r6
800099d6:	1a d8       	st.w	--sp,r8
800099d8:	04 9a       	mov	r10,r2
800099da:	fa c8 f9 40 	sub	r8,sp,-1728
800099de:	fa c9 ff b4 	sub	r9,sp,-76
800099e2:	08 9c       	mov	r12,r4
800099e4:	fe b0 f6 44 	rcall	8000866c <get_arg>
800099e8:	2f dd       	sub	sp,-12
800099ea:	78 06       	ld.w	r6,r12[0x0]
800099ec:	c2 08       	rjmp	80009a2c <_vfprintf_r+0x1090>
800099ee:	2f f7       	sub	r7,-1
800099f0:	10 39       	cp.w	r9,r8
800099f2:	c0 84       	brge	80009a02 <_vfprintf_r+0x1066>
800099f4:	fa c9 f9 44 	sub	r9,sp,-1724
800099f8:	f2 06 00 36 	add	r6,r9,r6<<0x3
800099fc:	ec f6 fd 88 	ld.w	r6,r6[-632]
80009a00:	c1 68       	rjmp	80009a2c <_vfprintf_r+0x1090>
80009a02:	41 09       	lddsp	r9,sp[0x40]
80009a04:	59 f8       	cp.w	r8,31
80009a06:	e0 89 00 10 	brgt	80009a26 <_vfprintf_r+0x108a>
80009a0a:	f2 ca ff fc 	sub	r10,r9,-4
80009a0e:	51 0a       	stdsp	sp[0x40],r10
80009a10:	72 06       	ld.w	r6,r9[0x0]
80009a12:	fa ce f9 44 	sub	lr,sp,-1724
80009a16:	fc 08 00 39 	add	r9,lr,r8<<0x3
80009a1a:	f3 46 fd 88 	st.w	r9[-632],r6
80009a1e:	2f f8       	sub	r8,-1
80009a20:	fb 48 06 b4 	st.w	sp[1716],r8
80009a24:	c0 48       	rjmp	80009a2c <_vfprintf_r+0x1090>
80009a26:	72 06       	ld.w	r6,r9[0x0]
80009a28:	2f c9       	sub	r9,-4
80009a2a:	51 09       	stdsp	sp[0x40],r9
80009a2c:	40 2c       	lddsp	r12,sp[0x8]
80009a2e:	58 0c       	cp.w	r12,0
80009a30:	c1 05       	brlt	80009a50 <_vfprintf_r+0x10b4>
80009a32:	18 9a       	mov	r10,r12
80009a34:	30 0b       	mov	r11,0
80009a36:	0c 9c       	mov	r12,r6
80009a38:	e0 a0 12 38 	rcall	8000bea8 <memchr>
80009a3c:	e0 80 02 df 	breq	80009ffa <_vfprintf_r+0x165e>
80009a40:	f8 06 01 02 	sub	r2,r12,r6
80009a44:	40 2b       	lddsp	r11,sp[0x8]
80009a46:	16 32       	cp.w	r2,r11
80009a48:	e0 89 02 d9 	brgt	80009ffa <_vfprintf_r+0x165e>
80009a4c:	e0 8f 02 d4 	bral	80009ff4 <_vfprintf_r+0x1658>
80009a50:	30 0a       	mov	r10,0
80009a52:	0c 9c       	mov	r12,r6
80009a54:	50 2a       	stdsp	sp[0x8],r10
80009a56:	e0 a0 15 99 	rcall	8000c588 <strlen>
80009a5a:	18 92       	mov	r2,r12
80009a5c:	e0 8f 02 d2 	bral	8000a000 <_vfprintf_r+0x1664>
80009a60:	50 a7       	stdsp	sp[0x28],r7
80009a62:	50 80       	stdsp	sp[0x20],r0
80009a64:	0c 97       	mov	r7,r6
80009a66:	04 94       	mov	r4,r2
80009a68:	06 96       	mov	r6,r3
80009a6a:	02 92       	mov	r2,r1
80009a6c:	40 93       	lddsp	r3,sp[0x24]
80009a6e:	10 90       	mov	r0,r8
80009a70:	40 41       	lddsp	r1,sp[0x10]
80009a72:	a5 a5       	sbr	r5,0x4
80009a74:	c0 a8       	rjmp	80009a88 <_vfprintf_r+0x10ec>
80009a76:	50 a7       	stdsp	sp[0x28],r7
80009a78:	50 80       	stdsp	sp[0x20],r0
80009a7a:	0c 97       	mov	r7,r6
80009a7c:	04 94       	mov	r4,r2
80009a7e:	06 96       	mov	r6,r3
80009a80:	02 92       	mov	r2,r1
80009a82:	40 93       	lddsp	r3,sp[0x24]
80009a84:	10 90       	mov	r0,r8
80009a86:	40 41       	lddsp	r1,sp[0x10]
80009a88:	ed b5 00 05 	bld	r5,0x5
80009a8c:	c5 61       	brne	80009b38 <_vfprintf_r+0x119c>
80009a8e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009a92:	40 39       	lddsp	r9,sp[0xc]
80009a94:	58 09       	cp.w	r9,0
80009a96:	c2 10       	breq	80009ad8 <_vfprintf_r+0x113c>
80009a98:	10 36       	cp.w	r6,r8
80009a9a:	c0 74       	brge	80009aa8 <_vfprintf_r+0x110c>
80009a9c:	fa c8 f9 44 	sub	r8,sp,-1724
80009aa0:	f0 06 00 36 	add	r6,r8,r6<<0x3
80009aa4:	c2 38       	rjmp	80009aea <_vfprintf_r+0x114e>
80009aa6:	d7 03       	nop
80009aa8:	fa c8 f9 50 	sub	r8,sp,-1712
80009aac:	1a d8       	st.w	--sp,r8
80009aae:	fa c8 fa b8 	sub	r8,sp,-1352
80009ab2:	1a d8       	st.w	--sp,r8
80009ab4:	fa c8 fb b4 	sub	r8,sp,-1100
80009ab8:	1a d8       	st.w	--sp,r8
80009aba:	fa c8 f9 40 	sub	r8,sp,-1728
80009abe:	fa c9 ff b4 	sub	r9,sp,-76
80009ac2:	04 9a       	mov	r10,r2
80009ac4:	0c 9b       	mov	r11,r6
80009ac6:	08 9c       	mov	r12,r4
80009ac8:	fe b0 f5 d2 	rcall	8000866c <get_arg>
80009acc:	2f dd       	sub	sp,-12
80009ace:	f8 e8 00 00 	ld.d	r8,r12[0]
80009ad2:	fa e9 00 00 	st.d	sp[0],r8
80009ad6:	c2 e8       	rjmp	80009b32 <_vfprintf_r+0x1196>
80009ad8:	ee ca ff ff 	sub	r10,r7,-1
80009adc:	10 37       	cp.w	r7,r8
80009ade:	c0 b4       	brge	80009af4 <_vfprintf_r+0x1158>
80009ae0:	fa c8 f9 44 	sub	r8,sp,-1724
80009ae4:	14 97       	mov	r7,r10
80009ae6:	f0 06 00 36 	add	r6,r8,r6<<0x3
80009aea:	ec ea fd 88 	ld.d	r10,r6[-632]
80009aee:	fa eb 00 00 	st.d	sp[0],r10
80009af2:	c2 08       	rjmp	80009b32 <_vfprintf_r+0x1196>
80009af4:	41 09       	lddsp	r9,sp[0x40]
80009af6:	59 f8       	cp.w	r8,31
80009af8:	e0 89 00 16 	brgt	80009b24 <_vfprintf_r+0x1188>
80009afc:	f2 e6 00 00 	ld.d	r6,r9[0]
80009b00:	f2 cb ff f8 	sub	r11,r9,-8
80009b04:	fa e7 00 00 	st.d	sp[0],r6
80009b08:	51 0b       	stdsp	sp[0x40],r11
80009b0a:	fa c6 f9 44 	sub	r6,sp,-1724
80009b0e:	ec 08 00 39 	add	r9,r6,r8<<0x3
80009b12:	fa e6 00 00 	ld.d	r6,sp[0]
80009b16:	f2 e7 fd 88 	st.d	r9[-632],r6
80009b1a:	2f f8       	sub	r8,-1
80009b1c:	14 97       	mov	r7,r10
80009b1e:	fb 48 06 b4 	st.w	sp[1716],r8
80009b22:	c0 88       	rjmp	80009b32 <_vfprintf_r+0x1196>
80009b24:	f2 e6 00 00 	ld.d	r6,r9[0]
80009b28:	2f 89       	sub	r9,-8
80009b2a:	fa e7 00 00 	st.d	sp[0],r6
80009b2e:	51 09       	stdsp	sp[0x40],r9
80009b30:	14 97       	mov	r7,r10
80009b32:	30 18       	mov	r8,1
80009b34:	e0 8f 01 d0 	bral	80009ed4 <_vfprintf_r+0x1538>
80009b38:	ed b5 00 04 	bld	r5,0x4
80009b3c:	c1 61       	brne	80009b68 <_vfprintf_r+0x11cc>
80009b3e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009b42:	40 3e       	lddsp	lr,sp[0xc]
80009b44:	58 0e       	cp.w	lr,0
80009b46:	c0 80       	breq	80009b56 <_vfprintf_r+0x11ba>
80009b48:	10 36       	cp.w	r6,r8
80009b4a:	c6 74       	brge	80009c18 <_vfprintf_r+0x127c>
80009b4c:	fa cc f9 44 	sub	r12,sp,-1724
80009b50:	f8 06 00 36 	add	r6,r12,r6<<0x3
80009b54:	c8 08       	rjmp	80009c54 <_vfprintf_r+0x12b8>
80009b56:	ee ca ff ff 	sub	r10,r7,-1
80009b5a:	10 37       	cp.w	r7,r8
80009b5c:	c7 f4       	brge	80009c5a <_vfprintf_r+0x12be>
80009b5e:	fa cb f9 44 	sub	r11,sp,-1724
80009b62:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009b66:	c7 68       	rjmp	80009c52 <_vfprintf_r+0x12b6>
80009b68:	ed b5 00 06 	bld	r5,0x6
80009b6c:	c4 a1       	brne	80009c00 <_vfprintf_r+0x1264>
80009b6e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009b72:	40 3c       	lddsp	r12,sp[0xc]
80009b74:	58 0c       	cp.w	r12,0
80009b76:	c1 d0       	breq	80009bb0 <_vfprintf_r+0x1214>
80009b78:	10 36       	cp.w	r6,r8
80009b7a:	c0 64       	brge	80009b86 <_vfprintf_r+0x11ea>
80009b7c:	fa cb f9 44 	sub	r11,sp,-1724
80009b80:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009b84:	c1 f8       	rjmp	80009bc2 <_vfprintf_r+0x1226>
80009b86:	fa c8 f9 50 	sub	r8,sp,-1712
80009b8a:	1a d8       	st.w	--sp,r8
80009b8c:	fa c8 fa b8 	sub	r8,sp,-1352
80009b90:	1a d8       	st.w	--sp,r8
80009b92:	fa c8 fb b4 	sub	r8,sp,-1100
80009b96:	1a d8       	st.w	--sp,r8
80009b98:	fa c8 f9 40 	sub	r8,sp,-1728
80009b9c:	fa c9 ff b4 	sub	r9,sp,-76
80009ba0:	04 9a       	mov	r10,r2
80009ba2:	0c 9b       	mov	r11,r6
80009ba4:	08 9c       	mov	r12,r4
80009ba6:	fe b0 f5 63 	rcall	8000866c <get_arg>
80009baa:	2f dd       	sub	sp,-12
80009bac:	98 18       	ld.sh	r8,r12[0x2]
80009bae:	c2 68       	rjmp	80009bfa <_vfprintf_r+0x125e>
80009bb0:	ee ca ff ff 	sub	r10,r7,-1
80009bb4:	10 37       	cp.w	r7,r8
80009bb6:	c0 94       	brge	80009bc8 <_vfprintf_r+0x122c>
80009bb8:	fa c9 f9 44 	sub	r9,sp,-1724
80009bbc:	14 97       	mov	r7,r10
80009bbe:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009bc2:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80009bc6:	c1 a8       	rjmp	80009bfa <_vfprintf_r+0x125e>
80009bc8:	41 09       	lddsp	r9,sp[0x40]
80009bca:	59 f8       	cp.w	r8,31
80009bcc:	e0 89 00 13 	brgt	80009bf2 <_vfprintf_r+0x1256>
80009bd0:	f2 cb ff fc 	sub	r11,r9,-4
80009bd4:	51 0b       	stdsp	sp[0x40],r11
80009bd6:	72 09       	ld.w	r9,r9[0x0]
80009bd8:	fa c6 f9 44 	sub	r6,sp,-1724
80009bdc:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80009be0:	2f f8       	sub	r8,-1
80009be2:	f7 49 fd 88 	st.w	r11[-632],r9
80009be6:	fb 48 06 b4 	st.w	sp[1716],r8
80009bea:	14 97       	mov	r7,r10
80009bec:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80009bf0:	c0 58       	rjmp	80009bfa <_vfprintf_r+0x125e>
80009bf2:	92 18       	ld.sh	r8,r9[0x2]
80009bf4:	14 97       	mov	r7,r10
80009bf6:	2f c9       	sub	r9,-4
80009bf8:	51 09       	stdsp	sp[0x40],r9
80009bfa:	5c 78       	castu.h	r8
80009bfc:	50 18       	stdsp	sp[0x4],r8
80009bfe:	c4 68       	rjmp	80009c8a <_vfprintf_r+0x12ee>
80009c00:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009c04:	40 3c       	lddsp	r12,sp[0xc]
80009c06:	58 0c       	cp.w	r12,0
80009c08:	c1 d0       	breq	80009c42 <_vfprintf_r+0x12a6>
80009c0a:	10 36       	cp.w	r6,r8
80009c0c:	c0 64       	brge	80009c18 <_vfprintf_r+0x127c>
80009c0e:	fa cb f9 44 	sub	r11,sp,-1724
80009c12:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009c16:	c1 f8       	rjmp	80009c54 <_vfprintf_r+0x12b8>
80009c18:	fa c8 f9 50 	sub	r8,sp,-1712
80009c1c:	1a d8       	st.w	--sp,r8
80009c1e:	fa c8 fa b8 	sub	r8,sp,-1352
80009c22:	0c 9b       	mov	r11,r6
80009c24:	1a d8       	st.w	--sp,r8
80009c26:	fa c8 fb b4 	sub	r8,sp,-1100
80009c2a:	04 9a       	mov	r10,r2
80009c2c:	1a d8       	st.w	--sp,r8
80009c2e:	08 9c       	mov	r12,r4
80009c30:	fa c8 f9 40 	sub	r8,sp,-1728
80009c34:	fa c9 ff b4 	sub	r9,sp,-76
80009c38:	fe b0 f5 1a 	rcall	8000866c <get_arg>
80009c3c:	2f dd       	sub	sp,-12
80009c3e:	78 0b       	ld.w	r11,r12[0x0]
80009c40:	c2 48       	rjmp	80009c88 <_vfprintf_r+0x12ec>
80009c42:	ee ca ff ff 	sub	r10,r7,-1
80009c46:	10 37       	cp.w	r7,r8
80009c48:	c0 94       	brge	80009c5a <_vfprintf_r+0x12be>
80009c4a:	fa c9 f9 44 	sub	r9,sp,-1724
80009c4e:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009c52:	14 97       	mov	r7,r10
80009c54:	ec fb fd 88 	ld.w	r11,r6[-632]
80009c58:	c1 88       	rjmp	80009c88 <_vfprintf_r+0x12ec>
80009c5a:	41 09       	lddsp	r9,sp[0x40]
80009c5c:	59 f8       	cp.w	r8,31
80009c5e:	e0 89 00 11 	brgt	80009c80 <_vfprintf_r+0x12e4>
80009c62:	f2 cb ff fc 	sub	r11,r9,-4
80009c66:	51 0b       	stdsp	sp[0x40],r11
80009c68:	fa c6 f9 44 	sub	r6,sp,-1724
80009c6c:	72 0b       	ld.w	r11,r9[0x0]
80009c6e:	ec 08 00 39 	add	r9,r6,r8<<0x3
80009c72:	f3 4b fd 88 	st.w	r9[-632],r11
80009c76:	2f f8       	sub	r8,-1
80009c78:	14 97       	mov	r7,r10
80009c7a:	fb 48 06 b4 	st.w	sp[1716],r8
80009c7e:	c0 58       	rjmp	80009c88 <_vfprintf_r+0x12ec>
80009c80:	72 0b       	ld.w	r11,r9[0x0]
80009c82:	14 97       	mov	r7,r10
80009c84:	2f c9       	sub	r9,-4
80009c86:	51 09       	stdsp	sp[0x40],r9
80009c88:	50 1b       	stdsp	sp[0x4],r11
80009c8a:	30 0e       	mov	lr,0
80009c8c:	30 18       	mov	r8,1
80009c8e:	50 0e       	stdsp	sp[0x0],lr
80009c90:	c2 29       	rjmp	80009ed4 <_vfprintf_r+0x1538>
80009c92:	50 a7       	stdsp	sp[0x28],r7
80009c94:	50 80       	stdsp	sp[0x20],r0
80009c96:	0c 97       	mov	r7,r6
80009c98:	04 94       	mov	r4,r2
80009c9a:	06 96       	mov	r6,r3
80009c9c:	02 92       	mov	r2,r1
80009c9e:	fe cc b3 66 	sub	r12,pc,-19610
80009ca2:	40 93       	lddsp	r3,sp[0x24]
80009ca4:	10 90       	mov	r0,r8
80009ca6:	40 41       	lddsp	r1,sp[0x10]
80009ca8:	50 dc       	stdsp	sp[0x34],r12
80009caa:	ed b5 00 05 	bld	r5,0x5
80009cae:	c5 51       	brne	80009d58 <_vfprintf_r+0x13bc>
80009cb0:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009cb4:	40 3b       	lddsp	r11,sp[0xc]
80009cb6:	58 0b       	cp.w	r11,0
80009cb8:	c2 20       	breq	80009cfc <_vfprintf_r+0x1360>
80009cba:	10 36       	cp.w	r6,r8
80009cbc:	c0 a4       	brge	80009cd0 <_vfprintf_r+0x1334>
80009cbe:	fa ca f9 44 	sub	r10,sp,-1724
80009cc2:	f4 06 00 36 	add	r6,r10,r6<<0x3
80009cc6:	ec e8 fd 88 	ld.d	r8,r6[-632]
80009cca:	fa e9 00 00 	st.d	sp[0],r8
80009cce:	cf 28       	rjmp	80009eb2 <_vfprintf_r+0x1516>
80009cd0:	fa c8 f9 50 	sub	r8,sp,-1712
80009cd4:	1a d8       	st.w	--sp,r8
80009cd6:	fa c8 fa b8 	sub	r8,sp,-1352
80009cda:	04 9a       	mov	r10,r2
80009cdc:	1a d8       	st.w	--sp,r8
80009cde:	0c 9b       	mov	r11,r6
80009ce0:	fa c8 fb b4 	sub	r8,sp,-1100
80009ce4:	08 9c       	mov	r12,r4
80009ce6:	1a d8       	st.w	--sp,r8
80009ce8:	fa c8 f9 40 	sub	r8,sp,-1728
80009cec:	fa c9 ff b4 	sub	r9,sp,-76
80009cf0:	fe b0 f4 be 	rcall	8000866c <get_arg>
80009cf4:	2f dd       	sub	sp,-12
80009cf6:	f8 ea 00 00 	ld.d	r10,r12[0]
80009cfa:	c0 c8       	rjmp	80009d12 <_vfprintf_r+0x1376>
80009cfc:	ee ca ff ff 	sub	r10,r7,-1
80009d00:	10 37       	cp.w	r7,r8
80009d02:	c0 b4       	brge	80009d18 <_vfprintf_r+0x137c>
80009d04:	fa c9 f9 44 	sub	r9,sp,-1724
80009d08:	14 97       	mov	r7,r10
80009d0a:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009d0e:	ec ea fd 88 	ld.d	r10,r6[-632]
80009d12:	fa eb 00 00 	st.d	sp[0],r10
80009d16:	cc e8       	rjmp	80009eb2 <_vfprintf_r+0x1516>
80009d18:	41 09       	lddsp	r9,sp[0x40]
80009d1a:	59 f8       	cp.w	r8,31
80009d1c:	e0 89 00 16 	brgt	80009d48 <_vfprintf_r+0x13ac>
80009d20:	f2 e6 00 00 	ld.d	r6,r9[0]
80009d24:	f2 cb ff f8 	sub	r11,r9,-8
80009d28:	fa e7 00 00 	st.d	sp[0],r6
80009d2c:	51 0b       	stdsp	sp[0x40],r11
80009d2e:	fa c6 f9 44 	sub	r6,sp,-1724
80009d32:	ec 08 00 39 	add	r9,r6,r8<<0x3
80009d36:	fa e6 00 00 	ld.d	r6,sp[0]
80009d3a:	f2 e7 fd 88 	st.d	r9[-632],r6
80009d3e:	2f f8       	sub	r8,-1
80009d40:	14 97       	mov	r7,r10
80009d42:	fb 48 06 b4 	st.w	sp[1716],r8
80009d46:	cb 68       	rjmp	80009eb2 <_vfprintf_r+0x1516>
80009d48:	f2 e6 00 00 	ld.d	r6,r9[0]
80009d4c:	2f 89       	sub	r9,-8
80009d4e:	fa e7 00 00 	st.d	sp[0],r6
80009d52:	51 09       	stdsp	sp[0x40],r9
80009d54:	14 97       	mov	r7,r10
80009d56:	ca e8       	rjmp	80009eb2 <_vfprintf_r+0x1516>
80009d58:	ed b5 00 04 	bld	r5,0x4
80009d5c:	c1 71       	brne	80009d8a <_vfprintf_r+0x13ee>
80009d5e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009d62:	40 3e       	lddsp	lr,sp[0xc]
80009d64:	58 0e       	cp.w	lr,0
80009d66:	c0 80       	breq	80009d76 <_vfprintf_r+0x13da>
80009d68:	10 36       	cp.w	r6,r8
80009d6a:	c6 94       	brge	80009e3c <_vfprintf_r+0x14a0>
80009d6c:	fa cc f9 44 	sub	r12,sp,-1724
80009d70:	f8 06 00 36 	add	r6,r12,r6<<0x3
80009d74:	c8 28       	rjmp	80009e78 <_vfprintf_r+0x14dc>
80009d76:	ee ca ff ff 	sub	r10,r7,-1
80009d7a:	10 37       	cp.w	r7,r8
80009d7c:	e0 84 00 81 	brge	80009e7e <_vfprintf_r+0x14e2>
80009d80:	fa cb f9 44 	sub	r11,sp,-1724
80009d84:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009d88:	c7 78       	rjmp	80009e76 <_vfprintf_r+0x14da>
80009d8a:	ed b5 00 06 	bld	r5,0x6
80009d8e:	c4 b1       	brne	80009e24 <_vfprintf_r+0x1488>
80009d90:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009d94:	40 3c       	lddsp	r12,sp[0xc]
80009d96:	58 0c       	cp.w	r12,0
80009d98:	c1 d0       	breq	80009dd2 <_vfprintf_r+0x1436>
80009d9a:	10 36       	cp.w	r6,r8
80009d9c:	c0 64       	brge	80009da8 <_vfprintf_r+0x140c>
80009d9e:	fa cb f9 44 	sub	r11,sp,-1724
80009da2:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009da6:	c1 f8       	rjmp	80009de4 <_vfprintf_r+0x1448>
80009da8:	fa c8 f9 50 	sub	r8,sp,-1712
80009dac:	1a d8       	st.w	--sp,r8
80009dae:	fa c8 fa b8 	sub	r8,sp,-1352
80009db2:	1a d8       	st.w	--sp,r8
80009db4:	fa c8 fb b4 	sub	r8,sp,-1100
80009db8:	1a d8       	st.w	--sp,r8
80009dba:	fa c8 f9 40 	sub	r8,sp,-1728
80009dbe:	fa c9 ff b4 	sub	r9,sp,-76
80009dc2:	04 9a       	mov	r10,r2
80009dc4:	0c 9b       	mov	r11,r6
80009dc6:	08 9c       	mov	r12,r4
80009dc8:	fe b0 f4 52 	rcall	8000866c <get_arg>
80009dcc:	2f dd       	sub	sp,-12
80009dce:	98 18       	ld.sh	r8,r12[0x2]
80009dd0:	c2 78       	rjmp	80009e1e <_vfprintf_r+0x1482>
80009dd2:	ee ca ff ff 	sub	r10,r7,-1
80009dd6:	10 37       	cp.w	r7,r8
80009dd8:	c0 a4       	brge	80009dec <_vfprintf_r+0x1450>
80009dda:	fa c9 f9 44 	sub	r9,sp,-1724
80009dde:	14 97       	mov	r7,r10
80009de0:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009de4:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80009de8:	c1 b8       	rjmp	80009e1e <_vfprintf_r+0x1482>
80009dea:	d7 03       	nop
80009dec:	41 09       	lddsp	r9,sp[0x40]
80009dee:	59 f8       	cp.w	r8,31
80009df0:	e0 89 00 13 	brgt	80009e16 <_vfprintf_r+0x147a>
80009df4:	f2 cb ff fc 	sub	r11,r9,-4
80009df8:	51 0b       	stdsp	sp[0x40],r11
80009dfa:	72 09       	ld.w	r9,r9[0x0]
80009dfc:	fa c6 f9 44 	sub	r6,sp,-1724
80009e00:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80009e04:	2f f8       	sub	r8,-1
80009e06:	f7 49 fd 88 	st.w	r11[-632],r9
80009e0a:	fb 48 06 b4 	st.w	sp[1716],r8
80009e0e:	14 97       	mov	r7,r10
80009e10:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80009e14:	c0 58       	rjmp	80009e1e <_vfprintf_r+0x1482>
80009e16:	92 18       	ld.sh	r8,r9[0x2]
80009e18:	14 97       	mov	r7,r10
80009e1a:	2f c9       	sub	r9,-4
80009e1c:	51 09       	stdsp	sp[0x40],r9
80009e1e:	5c 78       	castu.h	r8
80009e20:	50 18       	stdsp	sp[0x4],r8
80009e22:	c4 68       	rjmp	80009eae <_vfprintf_r+0x1512>
80009e24:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009e28:	40 3c       	lddsp	r12,sp[0xc]
80009e2a:	58 0c       	cp.w	r12,0
80009e2c:	c1 d0       	breq	80009e66 <_vfprintf_r+0x14ca>
80009e2e:	10 36       	cp.w	r6,r8
80009e30:	c0 64       	brge	80009e3c <_vfprintf_r+0x14a0>
80009e32:	fa cb f9 44 	sub	r11,sp,-1724
80009e36:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009e3a:	c1 f8       	rjmp	80009e78 <_vfprintf_r+0x14dc>
80009e3c:	fa c8 f9 50 	sub	r8,sp,-1712
80009e40:	1a d8       	st.w	--sp,r8
80009e42:	fa c8 fa b8 	sub	r8,sp,-1352
80009e46:	0c 9b       	mov	r11,r6
80009e48:	1a d8       	st.w	--sp,r8
80009e4a:	fa c8 fb b4 	sub	r8,sp,-1100
80009e4e:	04 9a       	mov	r10,r2
80009e50:	1a d8       	st.w	--sp,r8
80009e52:	08 9c       	mov	r12,r4
80009e54:	fa c8 f9 40 	sub	r8,sp,-1728
80009e58:	fa c9 ff b4 	sub	r9,sp,-76
80009e5c:	fe b0 f4 08 	rcall	8000866c <get_arg>
80009e60:	2f dd       	sub	sp,-12
80009e62:	78 0b       	ld.w	r11,r12[0x0]
80009e64:	c2 48       	rjmp	80009eac <_vfprintf_r+0x1510>
80009e66:	ee ca ff ff 	sub	r10,r7,-1
80009e6a:	10 37       	cp.w	r7,r8
80009e6c:	c0 94       	brge	80009e7e <_vfprintf_r+0x14e2>
80009e6e:	fa c9 f9 44 	sub	r9,sp,-1724
80009e72:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009e76:	14 97       	mov	r7,r10
80009e78:	ec fb fd 88 	ld.w	r11,r6[-632]
80009e7c:	c1 88       	rjmp	80009eac <_vfprintf_r+0x1510>
80009e7e:	41 09       	lddsp	r9,sp[0x40]
80009e80:	59 f8       	cp.w	r8,31
80009e82:	e0 89 00 11 	brgt	80009ea4 <_vfprintf_r+0x1508>
80009e86:	f2 cb ff fc 	sub	r11,r9,-4
80009e8a:	51 0b       	stdsp	sp[0x40],r11
80009e8c:	fa c6 f9 44 	sub	r6,sp,-1724
80009e90:	72 0b       	ld.w	r11,r9[0x0]
80009e92:	ec 08 00 39 	add	r9,r6,r8<<0x3
80009e96:	f3 4b fd 88 	st.w	r9[-632],r11
80009e9a:	2f f8       	sub	r8,-1
80009e9c:	14 97       	mov	r7,r10
80009e9e:	fb 48 06 b4 	st.w	sp[1716],r8
80009ea2:	c0 58       	rjmp	80009eac <_vfprintf_r+0x1510>
80009ea4:	72 0b       	ld.w	r11,r9[0x0]
80009ea6:	14 97       	mov	r7,r10
80009ea8:	2f c9       	sub	r9,-4
80009eaa:	51 09       	stdsp	sp[0x40],r9
80009eac:	50 1b       	stdsp	sp[0x4],r11
80009eae:	30 0e       	mov	lr,0
80009eb0:	50 0e       	stdsp	sp[0x0],lr
80009eb2:	40 08       	lddsp	r8,sp[0x0]
80009eb4:	40 1c       	lddsp	r12,sp[0x4]
80009eb6:	18 48       	or	r8,r12
80009eb8:	5f 19       	srne	r9
80009eba:	0a 98       	mov	r8,r5
80009ebc:	eb e9 00 09 	and	r9,r5,r9
80009ec0:	a1 b8       	sbr	r8,0x1
80009ec2:	58 09       	cp.w	r9,0
80009ec4:	c0 70       	breq	80009ed2 <_vfprintf_r+0x1536>
80009ec6:	10 95       	mov	r5,r8
80009ec8:	fb 60 06 b9 	st.b	sp[1721],r0
80009ecc:	33 08       	mov	r8,48
80009ece:	fb 68 06 b8 	st.b	sp[1720],r8
80009ed2:	30 28       	mov	r8,2
80009ed4:	30 09       	mov	r9,0
80009ed6:	fb 69 06 bb 	st.b	sp[1723],r9
80009eda:	0a 99       	mov	r9,r5
80009edc:	a7 d9       	cbr	r9,0x7
80009ede:	40 2b       	lddsp	r11,sp[0x8]
80009ee0:	40 16       	lddsp	r6,sp[0x4]
80009ee2:	58 0b       	cp.w	r11,0
80009ee4:	5f 1a       	srne	r10
80009ee6:	f2 05 17 40 	movge	r5,r9
80009eea:	fa c2 f9 78 	sub	r2,sp,-1672
80009eee:	40 09       	lddsp	r9,sp[0x0]
80009ef0:	0c 49       	or	r9,r6
80009ef2:	5f 19       	srne	r9
80009ef4:	f5 e9 10 09 	or	r9,r10,r9
80009ef8:	c5 c0       	breq	80009fb0 <_vfprintf_r+0x1614>
80009efa:	30 19       	mov	r9,1
80009efc:	f2 08 18 00 	cp.b	r8,r9
80009f00:	c0 60       	breq	80009f0c <_vfprintf_r+0x1570>
80009f02:	30 29       	mov	r9,2
80009f04:	f2 08 18 00 	cp.b	r8,r9
80009f08:	c0 41       	brne	80009f10 <_vfprintf_r+0x1574>
80009f0a:	c3 c8       	rjmp	80009f82 <_vfprintf_r+0x15e6>
80009f0c:	04 96       	mov	r6,r2
80009f0e:	c3 08       	rjmp	80009f6e <_vfprintf_r+0x15d2>
80009f10:	04 96       	mov	r6,r2
80009f12:	fa e8 00 00 	ld.d	r8,sp[0]
80009f16:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
80009f1a:	2d 0a       	sub	r10,-48
80009f1c:	0c fa       	st.b	--r6,r10
80009f1e:	f0 0b 16 03 	lsr	r11,r8,0x3
80009f22:	f2 0c 16 03 	lsr	r12,r9,0x3
80009f26:	f7 e9 11 db 	or	r11,r11,r9<<0x1d
80009f2a:	18 99       	mov	r9,r12
80009f2c:	16 98       	mov	r8,r11
80009f2e:	58 08       	cp.w	r8,0
80009f30:	5c 29       	cpc	r9
80009f32:	cf 21       	brne	80009f16 <_vfprintf_r+0x157a>
80009f34:	fa e9 00 00 	st.d	sp[0],r8
80009f38:	ed b5 00 00 	bld	r5,0x0
80009f3c:	c4 51       	brne	80009fc6 <_vfprintf_r+0x162a>
80009f3e:	33 09       	mov	r9,48
80009f40:	f2 0a 18 00 	cp.b	r10,r9
80009f44:	c4 10       	breq	80009fc6 <_vfprintf_r+0x162a>
80009f46:	0c f9       	st.b	--r6,r9
80009f48:	c3 f8       	rjmp	80009fc6 <_vfprintf_r+0x162a>
80009f4a:	fa ea 00 00 	ld.d	r10,sp[0]
80009f4e:	30 a8       	mov	r8,10
80009f50:	30 09       	mov	r9,0
80009f52:	e0 a0 1a 19 	rcall	8000d384 <__avr32_umod64>
80009f56:	30 a8       	mov	r8,10
80009f58:	2d 0a       	sub	r10,-48
80009f5a:	30 09       	mov	r9,0
80009f5c:	ac 8a       	st.b	r6[0x0],r10
80009f5e:	fa ea 00 00 	ld.d	r10,sp[0]
80009f62:	e0 a0 18 df 	rcall	8000d120 <__avr32_udiv64>
80009f66:	16 99       	mov	r9,r11
80009f68:	14 98       	mov	r8,r10
80009f6a:	fa e9 00 00 	st.d	sp[0],r8
80009f6e:	20 16       	sub	r6,1
80009f70:	fa ea 00 00 	ld.d	r10,sp[0]
80009f74:	58 9a       	cp.w	r10,9
80009f76:	5c 2b       	cpc	r11
80009f78:	fe 9b ff e9 	brhi	80009f4a <_vfprintf_r+0x15ae>
80009f7c:	1b f8       	ld.ub	r8,sp[0x7]
80009f7e:	2d 08       	sub	r8,-48
80009f80:	c2 08       	rjmp	80009fc0 <_vfprintf_r+0x1624>
80009f82:	04 96       	mov	r6,r2
80009f84:	fa e8 00 00 	ld.d	r8,sp[0]
80009f88:	f5 d8 c0 04 	bfextu	r10,r8,0x0,0x4
80009f8c:	40 de       	lddsp	lr,sp[0x34]
80009f8e:	fc 0a 07 0a 	ld.ub	r10,lr[r10]
80009f92:	0c fa       	st.b	--r6,r10
80009f94:	f2 0b 16 04 	lsr	r11,r9,0x4
80009f98:	f0 0a 16 04 	lsr	r10,r8,0x4
80009f9c:	f5 e9 11 ca 	or	r10,r10,r9<<0x1c
80009fa0:	16 99       	mov	r9,r11
80009fa2:	14 98       	mov	r8,r10
80009fa4:	58 08       	cp.w	r8,0
80009fa6:	5c 29       	cpc	r9
80009fa8:	cf 01       	brne	80009f88 <_vfprintf_r+0x15ec>
80009faa:	fa e9 00 00 	st.d	sp[0],r8
80009fae:	c0 c8       	rjmp	80009fc6 <_vfprintf_r+0x162a>
80009fb0:	58 08       	cp.w	r8,0
80009fb2:	c0 91       	brne	80009fc4 <_vfprintf_r+0x1628>
80009fb4:	ed b5 00 00 	bld	r5,0x0
80009fb8:	c0 61       	brne	80009fc4 <_vfprintf_r+0x1628>
80009fba:	fa c6 f9 79 	sub	r6,sp,-1671
80009fbe:	33 08       	mov	r8,48
80009fc0:	ac 88       	st.b	r6[0x0],r8
80009fc2:	c0 28       	rjmp	80009fc6 <_vfprintf_r+0x162a>
80009fc4:	04 96       	mov	r6,r2
80009fc6:	0c 12       	sub	r2,r6
80009fc8:	c1 c8       	rjmp	8000a000 <_vfprintf_r+0x1664>
80009fca:	50 a7       	stdsp	sp[0x28],r7
80009fcc:	50 80       	stdsp	sp[0x20],r0
80009fce:	40 93       	lddsp	r3,sp[0x24]
80009fd0:	0c 97       	mov	r7,r6
80009fd2:	10 90       	mov	r0,r8
80009fd4:	04 94       	mov	r4,r2
80009fd6:	40 41       	lddsp	r1,sp[0x10]
80009fd8:	58 08       	cp.w	r8,0
80009fda:	e0 80 04 4f 	breq	8000a878 <_vfprintf_r+0x1edc>
80009fde:	fb 68 06 60 	st.b	sp[1632],r8
80009fe2:	30 0c       	mov	r12,0
80009fe4:	30 08       	mov	r8,0
80009fe6:	30 12       	mov	r2,1
80009fe8:	fb 68 06 bb 	st.b	sp[1723],r8
80009fec:	50 2c       	stdsp	sp[0x8],r12
80009fee:	fa c6 f9 a0 	sub	r6,sp,-1632
80009ff2:	c0 78       	rjmp	8000a000 <_vfprintf_r+0x1664>
80009ff4:	30 0b       	mov	r11,0
80009ff6:	50 2b       	stdsp	sp[0x8],r11
80009ff8:	c0 48       	rjmp	8000a000 <_vfprintf_r+0x1664>
80009ffa:	40 22       	lddsp	r2,sp[0x8]
80009ffc:	30 0a       	mov	r10,0
80009ffe:	50 2a       	stdsp	sp[0x8],r10
8000a000:	40 29       	lddsp	r9,sp[0x8]
8000a002:	e4 09 0c 49 	max	r9,r2,r9
8000a006:	fb 38 06 bb 	ld.ub	r8,sp[1723]
8000a00a:	50 39       	stdsp	sp[0xc],r9
8000a00c:	0a 9e       	mov	lr,r5
8000a00e:	30 09       	mov	r9,0
8000a010:	e2 1e 00 02 	andl	lr,0x2,COH
8000a014:	f2 08 18 00 	cp.b	r8,r9
8000a018:	fb f8 10 03 	ld.wne	r8,sp[0xc]
8000a01c:	f7 b8 01 ff 	subne	r8,-1
8000a020:	fb f8 1a 03 	st.wne	sp[0xc],r8
8000a024:	0a 9b       	mov	r11,r5
8000a026:	58 0e       	cp.w	lr,0
8000a028:	fb fc 10 03 	ld.wne	r12,sp[0xc]
8000a02c:	f7 bc 01 fe 	subne	r12,-2
8000a030:	fb fc 1a 03 	st.wne	sp[0xc],r12
8000a034:	e2 1b 00 84 	andl	r11,0x84,COH
8000a038:	50 fe       	stdsp	sp[0x3c],lr
8000a03a:	50 9b       	stdsp	sp[0x24],r11
8000a03c:	c4 71       	brne	8000a0ca <_vfprintf_r+0x172e>
8000a03e:	40 8a       	lddsp	r10,sp[0x20]
8000a040:	40 39       	lddsp	r9,sp[0xc]
8000a042:	12 1a       	sub	r10,r9
8000a044:	50 4a       	stdsp	sp[0x10],r10
8000a046:	58 0a       	cp.w	r10,0
8000a048:	e0 89 00 20 	brgt	8000a088 <_vfprintf_r+0x16ec>
8000a04c:	c3 f8       	rjmp	8000a0ca <_vfprintf_r+0x172e>
8000a04e:	2f 09       	sub	r9,-16
8000a050:	2f f8       	sub	r8,-1
8000a052:	fe ce b7 02 	sub	lr,pc,-18686
8000a056:	31 0c       	mov	r12,16
8000a058:	fb 49 06 90 	st.w	sp[1680],r9
8000a05c:	87 0e       	st.w	r3[0x0],lr
8000a05e:	87 1c       	st.w	r3[0x4],r12
8000a060:	fb 48 06 8c 	st.w	sp[1676],r8
8000a064:	58 78       	cp.w	r8,7
8000a066:	e0 89 00 04 	brgt	8000a06e <_vfprintf_r+0x16d2>
8000a06a:	2f 83       	sub	r3,-8
8000a06c:	c0 b8       	rjmp	8000a082 <_vfprintf_r+0x16e6>
8000a06e:	fa ca f9 78 	sub	r10,sp,-1672
8000a072:	02 9b       	mov	r11,r1
8000a074:	08 9c       	mov	r12,r4
8000a076:	fe b0 f4 85 	rcall	80008980 <__sprint_r>
8000a07a:	e0 81 04 10 	brne	8000a89a <_vfprintf_r+0x1efe>
8000a07e:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a082:	40 4b       	lddsp	r11,sp[0x10]
8000a084:	21 0b       	sub	r11,16
8000a086:	50 4b       	stdsp	sp[0x10],r11
8000a088:	fa f9 06 90 	ld.w	r9,sp[1680]
8000a08c:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a090:	fe ca b7 40 	sub	r10,pc,-18624
8000a094:	40 4e       	lddsp	lr,sp[0x10]
8000a096:	59 0e       	cp.w	lr,16
8000a098:	fe 99 ff db 	brgt	8000a04e <_vfprintf_r+0x16b2>
8000a09c:	1c 09       	add	r9,lr
8000a09e:	2f f8       	sub	r8,-1
8000a0a0:	87 0a       	st.w	r3[0x0],r10
8000a0a2:	fb 49 06 90 	st.w	sp[1680],r9
8000a0a6:	87 1e       	st.w	r3[0x4],lr
8000a0a8:	fb 48 06 8c 	st.w	sp[1676],r8
8000a0ac:	58 78       	cp.w	r8,7
8000a0ae:	e0 89 00 04 	brgt	8000a0b6 <_vfprintf_r+0x171a>
8000a0b2:	2f 83       	sub	r3,-8
8000a0b4:	c0 b8       	rjmp	8000a0ca <_vfprintf_r+0x172e>
8000a0b6:	fa ca f9 78 	sub	r10,sp,-1672
8000a0ba:	02 9b       	mov	r11,r1
8000a0bc:	08 9c       	mov	r12,r4
8000a0be:	fe b0 f4 61 	rcall	80008980 <__sprint_r>
8000a0c2:	e0 81 03 ec 	brne	8000a89a <_vfprintf_r+0x1efe>
8000a0c6:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a0ca:	30 09       	mov	r9,0
8000a0cc:	fb 38 06 bb 	ld.ub	r8,sp[1723]
8000a0d0:	f2 08 18 00 	cp.b	r8,r9
8000a0d4:	c1 f0       	breq	8000a112 <_vfprintf_r+0x1776>
8000a0d6:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a0da:	fa c9 f9 45 	sub	r9,sp,-1723
8000a0de:	2f f8       	sub	r8,-1
8000a0e0:	87 09       	st.w	r3[0x0],r9
8000a0e2:	fb 48 06 90 	st.w	sp[1680],r8
8000a0e6:	30 19       	mov	r9,1
8000a0e8:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a0ec:	87 19       	st.w	r3[0x4],r9
8000a0ee:	2f f8       	sub	r8,-1
8000a0f0:	fb 48 06 8c 	st.w	sp[1676],r8
8000a0f4:	58 78       	cp.w	r8,7
8000a0f6:	e0 89 00 04 	brgt	8000a0fe <_vfprintf_r+0x1762>
8000a0fa:	2f 83       	sub	r3,-8
8000a0fc:	c0 b8       	rjmp	8000a112 <_vfprintf_r+0x1776>
8000a0fe:	fa ca f9 78 	sub	r10,sp,-1672
8000a102:	02 9b       	mov	r11,r1
8000a104:	08 9c       	mov	r12,r4
8000a106:	fe b0 f4 3d 	rcall	80008980 <__sprint_r>
8000a10a:	e0 81 03 c8 	brne	8000a89a <_vfprintf_r+0x1efe>
8000a10e:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a112:	40 fc       	lddsp	r12,sp[0x3c]
8000a114:	58 0c       	cp.w	r12,0
8000a116:	c1 f0       	breq	8000a154 <_vfprintf_r+0x17b8>
8000a118:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a11c:	fa c9 f9 48 	sub	r9,sp,-1720
8000a120:	2f e8       	sub	r8,-2
8000a122:	87 09       	st.w	r3[0x0],r9
8000a124:	fb 48 06 90 	st.w	sp[1680],r8
8000a128:	30 29       	mov	r9,2
8000a12a:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a12e:	87 19       	st.w	r3[0x4],r9
8000a130:	2f f8       	sub	r8,-1
8000a132:	fb 48 06 8c 	st.w	sp[1676],r8
8000a136:	58 78       	cp.w	r8,7
8000a138:	e0 89 00 04 	brgt	8000a140 <_vfprintf_r+0x17a4>
8000a13c:	2f 83       	sub	r3,-8
8000a13e:	c0 b8       	rjmp	8000a154 <_vfprintf_r+0x17b8>
8000a140:	fa ca f9 78 	sub	r10,sp,-1672
8000a144:	02 9b       	mov	r11,r1
8000a146:	08 9c       	mov	r12,r4
8000a148:	fe b0 f4 1c 	rcall	80008980 <__sprint_r>
8000a14c:	e0 81 03 a7 	brne	8000a89a <_vfprintf_r+0x1efe>
8000a150:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a154:	40 9b       	lddsp	r11,sp[0x24]
8000a156:	e0 4b 00 80 	cp.w	r11,128
8000a15a:	c4 71       	brne	8000a1e8 <_vfprintf_r+0x184c>
8000a15c:	40 8a       	lddsp	r10,sp[0x20]
8000a15e:	40 39       	lddsp	r9,sp[0xc]
8000a160:	12 1a       	sub	r10,r9
8000a162:	50 4a       	stdsp	sp[0x10],r10
8000a164:	58 0a       	cp.w	r10,0
8000a166:	e0 89 00 20 	brgt	8000a1a6 <_vfprintf_r+0x180a>
8000a16a:	c3 f8       	rjmp	8000a1e8 <_vfprintf_r+0x184c>
8000a16c:	2f 09       	sub	r9,-16
8000a16e:	2f f8       	sub	r8,-1
8000a170:	fe ce b8 10 	sub	lr,pc,-18416
8000a174:	31 0c       	mov	r12,16
8000a176:	fb 49 06 90 	st.w	sp[1680],r9
8000a17a:	87 0e       	st.w	r3[0x0],lr
8000a17c:	87 1c       	st.w	r3[0x4],r12
8000a17e:	fb 48 06 8c 	st.w	sp[1676],r8
8000a182:	58 78       	cp.w	r8,7
8000a184:	e0 89 00 04 	brgt	8000a18c <_vfprintf_r+0x17f0>
8000a188:	2f 83       	sub	r3,-8
8000a18a:	c0 b8       	rjmp	8000a1a0 <_vfprintf_r+0x1804>
8000a18c:	fa ca f9 78 	sub	r10,sp,-1672
8000a190:	02 9b       	mov	r11,r1
8000a192:	08 9c       	mov	r12,r4
8000a194:	fe b0 f3 f6 	rcall	80008980 <__sprint_r>
8000a198:	e0 81 03 81 	brne	8000a89a <_vfprintf_r+0x1efe>
8000a19c:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a1a0:	40 4b       	lddsp	r11,sp[0x10]
8000a1a2:	21 0b       	sub	r11,16
8000a1a4:	50 4b       	stdsp	sp[0x10],r11
8000a1a6:	fa f9 06 90 	ld.w	r9,sp[1680]
8000a1aa:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a1ae:	fe ca b8 4e 	sub	r10,pc,-18354
8000a1b2:	40 4e       	lddsp	lr,sp[0x10]
8000a1b4:	59 0e       	cp.w	lr,16
8000a1b6:	fe 99 ff db 	brgt	8000a16c <_vfprintf_r+0x17d0>
8000a1ba:	1c 09       	add	r9,lr
8000a1bc:	2f f8       	sub	r8,-1
8000a1be:	87 0a       	st.w	r3[0x0],r10
8000a1c0:	fb 49 06 90 	st.w	sp[1680],r9
8000a1c4:	87 1e       	st.w	r3[0x4],lr
8000a1c6:	fb 48 06 8c 	st.w	sp[1676],r8
8000a1ca:	58 78       	cp.w	r8,7
8000a1cc:	e0 89 00 04 	brgt	8000a1d4 <_vfprintf_r+0x1838>
8000a1d0:	2f 83       	sub	r3,-8
8000a1d2:	c0 b8       	rjmp	8000a1e8 <_vfprintf_r+0x184c>
8000a1d4:	fa ca f9 78 	sub	r10,sp,-1672
8000a1d8:	02 9b       	mov	r11,r1
8000a1da:	08 9c       	mov	r12,r4
8000a1dc:	fe b0 f3 d2 	rcall	80008980 <__sprint_r>
8000a1e0:	e0 81 03 5d 	brne	8000a89a <_vfprintf_r+0x1efe>
8000a1e4:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a1e8:	40 2c       	lddsp	r12,sp[0x8]
8000a1ea:	04 1c       	sub	r12,r2
8000a1ec:	50 2c       	stdsp	sp[0x8],r12
8000a1ee:	58 0c       	cp.w	r12,0
8000a1f0:	e0 89 00 20 	brgt	8000a230 <_vfprintf_r+0x1894>
8000a1f4:	c3 f8       	rjmp	8000a272 <_vfprintf_r+0x18d6>
8000a1f6:	2f 09       	sub	r9,-16
8000a1f8:	2f f8       	sub	r8,-1
8000a1fa:	fe cb b8 9a 	sub	r11,pc,-18278
8000a1fe:	31 0a       	mov	r10,16
8000a200:	fb 49 06 90 	st.w	sp[1680],r9
8000a204:	87 0b       	st.w	r3[0x0],r11
8000a206:	87 1a       	st.w	r3[0x4],r10
8000a208:	fb 48 06 8c 	st.w	sp[1676],r8
8000a20c:	58 78       	cp.w	r8,7
8000a20e:	e0 89 00 04 	brgt	8000a216 <_vfprintf_r+0x187a>
8000a212:	2f 83       	sub	r3,-8
8000a214:	c0 b8       	rjmp	8000a22a <_vfprintf_r+0x188e>
8000a216:	fa ca f9 78 	sub	r10,sp,-1672
8000a21a:	02 9b       	mov	r11,r1
8000a21c:	08 9c       	mov	r12,r4
8000a21e:	fe b0 f3 b1 	rcall	80008980 <__sprint_r>
8000a222:	e0 81 03 3c 	brne	8000a89a <_vfprintf_r+0x1efe>
8000a226:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a22a:	40 29       	lddsp	r9,sp[0x8]
8000a22c:	21 09       	sub	r9,16
8000a22e:	50 29       	stdsp	sp[0x8],r9
8000a230:	fa f9 06 90 	ld.w	r9,sp[1680]
8000a234:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a238:	fe ca b8 d8 	sub	r10,pc,-18216
8000a23c:	40 2e       	lddsp	lr,sp[0x8]
8000a23e:	59 0e       	cp.w	lr,16
8000a240:	fe 99 ff db 	brgt	8000a1f6 <_vfprintf_r+0x185a>
8000a244:	1c 09       	add	r9,lr
8000a246:	2f f8       	sub	r8,-1
8000a248:	87 0a       	st.w	r3[0x0],r10
8000a24a:	fb 49 06 90 	st.w	sp[1680],r9
8000a24e:	87 1e       	st.w	r3[0x4],lr
8000a250:	fb 48 06 8c 	st.w	sp[1676],r8
8000a254:	58 78       	cp.w	r8,7
8000a256:	e0 89 00 04 	brgt	8000a25e <_vfprintf_r+0x18c2>
8000a25a:	2f 83       	sub	r3,-8
8000a25c:	c0 b8       	rjmp	8000a272 <_vfprintf_r+0x18d6>
8000a25e:	fa ca f9 78 	sub	r10,sp,-1672
8000a262:	02 9b       	mov	r11,r1
8000a264:	08 9c       	mov	r12,r4
8000a266:	fe b0 f3 8d 	rcall	80008980 <__sprint_r>
8000a26a:	e0 81 03 18 	brne	8000a89a <_vfprintf_r+0x1efe>
8000a26e:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a272:	ed b5 00 08 	bld	r5,0x8
8000a276:	c0 b0       	breq	8000a28c <_vfprintf_r+0x18f0>
8000a278:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a27c:	87 12       	st.w	r3[0x4],r2
8000a27e:	87 06       	st.w	r3[0x0],r6
8000a280:	f0 02 00 02 	add	r2,r8,r2
8000a284:	fb 42 06 90 	st.w	sp[1680],r2
8000a288:	e0 8f 01 d4 	bral	8000a630 <_vfprintf_r+0x1c94>
8000a28c:	e0 40 00 65 	cp.w	r0,101
8000a290:	e0 8a 01 d6 	brle	8000a63c <_vfprintf_r+0x1ca0>
8000a294:	30 08       	mov	r8,0
8000a296:	30 09       	mov	r9,0
8000a298:	40 5b       	lddsp	r11,sp[0x14]
8000a29a:	40 7a       	lddsp	r10,sp[0x1c]
8000a29c:	e0 a0 15 3b 	rcall	8000cd12 <__avr32_f64_cmp_eq>
8000a2a0:	c7 90       	breq	8000a392 <_vfprintf_r+0x19f6>
8000a2a2:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a2a6:	fe c9 b9 5a 	sub	r9,pc,-18086
8000a2aa:	2f f8       	sub	r8,-1
8000a2ac:	87 09       	st.w	r3[0x0],r9
8000a2ae:	fb 48 06 90 	st.w	sp[1680],r8
8000a2b2:	30 19       	mov	r9,1
8000a2b4:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a2b8:	87 19       	st.w	r3[0x4],r9
8000a2ba:	2f f8       	sub	r8,-1
8000a2bc:	fb 48 06 8c 	st.w	sp[1676],r8
8000a2c0:	58 78       	cp.w	r8,7
8000a2c2:	e0 89 00 05 	brgt	8000a2cc <_vfprintf_r+0x1930>
8000a2c6:	2f 83       	sub	r3,-8
8000a2c8:	c0 c8       	rjmp	8000a2e0 <_vfprintf_r+0x1944>
8000a2ca:	d7 03       	nop
8000a2cc:	fa ca f9 78 	sub	r10,sp,-1672
8000a2d0:	02 9b       	mov	r11,r1
8000a2d2:	08 9c       	mov	r12,r4
8000a2d4:	fe b0 f3 56 	rcall	80008980 <__sprint_r>
8000a2d8:	e0 81 02 e1 	brne	8000a89a <_vfprintf_r+0x1efe>
8000a2dc:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a2e0:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000a2e4:	40 6c       	lddsp	r12,sp[0x18]
8000a2e6:	18 38       	cp.w	r8,r12
8000a2e8:	c0 55       	brlt	8000a2f2 <_vfprintf_r+0x1956>
8000a2ea:	ed b5 00 00 	bld	r5,0x0
8000a2ee:	e0 81 02 6b 	brne	8000a7c4 <_vfprintf_r+0x1e28>
8000a2f2:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a2f6:	2f f8       	sub	r8,-1
8000a2f8:	40 cb       	lddsp	r11,sp[0x30]
8000a2fa:	fb 48 06 90 	st.w	sp[1680],r8
8000a2fe:	30 19       	mov	r9,1
8000a300:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a304:	87 0b       	st.w	r3[0x0],r11
8000a306:	2f f8       	sub	r8,-1
8000a308:	87 19       	st.w	r3[0x4],r9
8000a30a:	fb 48 06 8c 	st.w	sp[1676],r8
8000a30e:	58 78       	cp.w	r8,7
8000a310:	e0 89 00 04 	brgt	8000a318 <_vfprintf_r+0x197c>
8000a314:	2f 83       	sub	r3,-8
8000a316:	c0 b8       	rjmp	8000a32c <_vfprintf_r+0x1990>
8000a318:	fa ca f9 78 	sub	r10,sp,-1672
8000a31c:	02 9b       	mov	r11,r1
8000a31e:	08 9c       	mov	r12,r4
8000a320:	fe b0 f3 30 	rcall	80008980 <__sprint_r>
8000a324:	e0 81 02 bb 	brne	8000a89a <_vfprintf_r+0x1efe>
8000a328:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a32c:	40 66       	lddsp	r6,sp[0x18]
8000a32e:	20 16       	sub	r6,1
8000a330:	58 06       	cp.w	r6,0
8000a332:	e0 89 00 1d 	brgt	8000a36c <_vfprintf_r+0x19d0>
8000a336:	e0 8f 02 47 	bral	8000a7c4 <_vfprintf_r+0x1e28>
8000a33a:	2f 09       	sub	r9,-16
8000a33c:	2f f8       	sub	r8,-1
8000a33e:	fb 49 06 90 	st.w	sp[1680],r9
8000a342:	87 02       	st.w	r3[0x0],r2
8000a344:	87 10       	st.w	r3[0x4],r0
8000a346:	fb 48 06 8c 	st.w	sp[1676],r8
8000a34a:	58 78       	cp.w	r8,7
8000a34c:	e0 89 00 04 	brgt	8000a354 <_vfprintf_r+0x19b8>
8000a350:	2f 83       	sub	r3,-8
8000a352:	c0 b8       	rjmp	8000a368 <_vfprintf_r+0x19cc>
8000a354:	fa ca f9 78 	sub	r10,sp,-1672
8000a358:	02 9b       	mov	r11,r1
8000a35a:	08 9c       	mov	r12,r4
8000a35c:	fe b0 f3 12 	rcall	80008980 <__sprint_r>
8000a360:	e0 81 02 9d 	brne	8000a89a <_vfprintf_r+0x1efe>
8000a364:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a368:	21 06       	sub	r6,16
8000a36a:	c0 48       	rjmp	8000a372 <_vfprintf_r+0x19d6>
8000a36c:	fe c2 ba 0c 	sub	r2,pc,-17908
8000a370:	31 00       	mov	r0,16
8000a372:	fa f9 06 90 	ld.w	r9,sp[1680]
8000a376:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a37a:	fe ca ba 1a 	sub	r10,pc,-17894
8000a37e:	59 06       	cp.w	r6,16
8000a380:	fe 99 ff dd 	brgt	8000a33a <_vfprintf_r+0x199e>
8000a384:	0c 09       	add	r9,r6
8000a386:	87 0a       	st.w	r3[0x0],r10
8000a388:	fb 49 06 90 	st.w	sp[1680],r9
8000a38c:	2f f8       	sub	r8,-1
8000a38e:	87 16       	st.w	r3[0x4],r6
8000a390:	c5 39       	rjmp	8000a636 <_vfprintf_r+0x1c9a>
8000a392:	fa fa 06 ac 	ld.w	r10,sp[1708]
8000a396:	58 0a       	cp.w	r10,0
8000a398:	e0 89 00 92 	brgt	8000a4bc <_vfprintf_r+0x1b20>
8000a39c:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a3a0:	fe c9 ba 54 	sub	r9,pc,-17836
8000a3a4:	2f f8       	sub	r8,-1
8000a3a6:	87 09       	st.w	r3[0x0],r9
8000a3a8:	fb 48 06 90 	st.w	sp[1680],r8
8000a3ac:	30 19       	mov	r9,1
8000a3ae:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a3b2:	87 19       	st.w	r3[0x4],r9
8000a3b4:	2f f8       	sub	r8,-1
8000a3b6:	fb 48 06 8c 	st.w	sp[1676],r8
8000a3ba:	58 78       	cp.w	r8,7
8000a3bc:	e0 89 00 04 	brgt	8000a3c4 <_vfprintf_r+0x1a28>
8000a3c0:	2f 83       	sub	r3,-8
8000a3c2:	c0 b8       	rjmp	8000a3d8 <_vfprintf_r+0x1a3c>
8000a3c4:	fa ca f9 78 	sub	r10,sp,-1672
8000a3c8:	02 9b       	mov	r11,r1
8000a3ca:	08 9c       	mov	r12,r4
8000a3cc:	fe b0 f2 da 	rcall	80008980 <__sprint_r>
8000a3d0:	e0 81 02 65 	brne	8000a89a <_vfprintf_r+0x1efe>
8000a3d4:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a3d8:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000a3dc:	58 08       	cp.w	r8,0
8000a3de:	c0 81       	brne	8000a3ee <_vfprintf_r+0x1a52>
8000a3e0:	40 6a       	lddsp	r10,sp[0x18]
8000a3e2:	58 0a       	cp.w	r10,0
8000a3e4:	c0 51       	brne	8000a3ee <_vfprintf_r+0x1a52>
8000a3e6:	ed b5 00 00 	bld	r5,0x0
8000a3ea:	e0 81 01 ed 	brne	8000a7c4 <_vfprintf_r+0x1e28>
8000a3ee:	40 c9       	lddsp	r9,sp[0x30]
8000a3f0:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a3f4:	2f f8       	sub	r8,-1
8000a3f6:	87 09       	st.w	r3[0x0],r9
8000a3f8:	fb 48 06 90 	st.w	sp[1680],r8
8000a3fc:	30 19       	mov	r9,1
8000a3fe:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a402:	87 19       	st.w	r3[0x4],r9
8000a404:	2f f8       	sub	r8,-1
8000a406:	fb 48 06 8c 	st.w	sp[1676],r8
8000a40a:	58 78       	cp.w	r8,7
8000a40c:	e0 89 00 04 	brgt	8000a414 <_vfprintf_r+0x1a78>
8000a410:	2f 83       	sub	r3,-8
8000a412:	c0 b8       	rjmp	8000a428 <_vfprintf_r+0x1a8c>
8000a414:	fa ca f9 78 	sub	r10,sp,-1672
8000a418:	02 9b       	mov	r11,r1
8000a41a:	08 9c       	mov	r12,r4
8000a41c:	fe b0 f2 b2 	rcall	80008980 <__sprint_r>
8000a420:	e0 81 02 3d 	brne	8000a89a <_vfprintf_r+0x1efe>
8000a424:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a428:	fa f2 06 ac 	ld.w	r2,sp[1708]
8000a42c:	5c 32       	neg	r2
8000a42e:	58 02       	cp.w	r2,0
8000a430:	e0 89 00 1d 	brgt	8000a46a <_vfprintf_r+0x1ace>
8000a434:	c3 d8       	rjmp	8000a4ae <_vfprintf_r+0x1b12>
8000a436:	2f 09       	sub	r9,-16
8000a438:	2f f8       	sub	r8,-1
8000a43a:	31 0e       	mov	lr,16
8000a43c:	fb 49 06 90 	st.w	sp[1680],r9
8000a440:	87 00       	st.w	r3[0x0],r0
8000a442:	87 1e       	st.w	r3[0x4],lr
8000a444:	fb 48 06 8c 	st.w	sp[1676],r8
8000a448:	58 78       	cp.w	r8,7
8000a44a:	e0 89 00 04 	brgt	8000a452 <_vfprintf_r+0x1ab6>
8000a44e:	2f 83       	sub	r3,-8
8000a450:	c0 b8       	rjmp	8000a466 <_vfprintf_r+0x1aca>
8000a452:	fa ca f9 78 	sub	r10,sp,-1672
8000a456:	02 9b       	mov	r11,r1
8000a458:	08 9c       	mov	r12,r4
8000a45a:	fe b0 f2 93 	rcall	80008980 <__sprint_r>
8000a45e:	e0 81 02 1e 	brne	8000a89a <_vfprintf_r+0x1efe>
8000a462:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a466:	21 02       	sub	r2,16
8000a468:	c0 38       	rjmp	8000a46e <_vfprintf_r+0x1ad2>
8000a46a:	fe c0 bb 0a 	sub	r0,pc,-17654
8000a46e:	fa f9 06 90 	ld.w	r9,sp[1680]
8000a472:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a476:	fe ca bb 16 	sub	r10,pc,-17642
8000a47a:	59 02       	cp.w	r2,16
8000a47c:	fe 99 ff dd 	brgt	8000a436 <_vfprintf_r+0x1a9a>
8000a480:	04 09       	add	r9,r2
8000a482:	2f f8       	sub	r8,-1
8000a484:	87 0a       	st.w	r3[0x0],r10
8000a486:	fb 49 06 90 	st.w	sp[1680],r9
8000a48a:	87 12       	st.w	r3[0x4],r2
8000a48c:	fb 48 06 8c 	st.w	sp[1676],r8
8000a490:	58 78       	cp.w	r8,7
8000a492:	e0 89 00 04 	brgt	8000a49a <_vfprintf_r+0x1afe>
8000a496:	2f 83       	sub	r3,-8
8000a498:	c0 b8       	rjmp	8000a4ae <_vfprintf_r+0x1b12>
8000a49a:	fa ca f9 78 	sub	r10,sp,-1672
8000a49e:	02 9b       	mov	r11,r1
8000a4a0:	08 9c       	mov	r12,r4
8000a4a2:	fe b0 f2 6f 	rcall	80008980 <__sprint_r>
8000a4a6:	e0 81 01 fa 	brne	8000a89a <_vfprintf_r+0x1efe>
8000a4aa:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a4ae:	40 6c       	lddsp	r12,sp[0x18]
8000a4b0:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a4b4:	87 06       	st.w	r3[0x0],r6
8000a4b6:	87 1c       	st.w	r3[0x4],r12
8000a4b8:	18 08       	add	r8,r12
8000a4ba:	cb 98       	rjmp	8000a62c <_vfprintf_r+0x1c90>
8000a4bc:	fa f9 06 90 	ld.w	r9,sp[1680]
8000a4c0:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a4c4:	40 6b       	lddsp	r11,sp[0x18]
8000a4c6:	16 3a       	cp.w	r10,r11
8000a4c8:	c6 f5       	brlt	8000a5a6 <_vfprintf_r+0x1c0a>
8000a4ca:	16 09       	add	r9,r11
8000a4cc:	2f f8       	sub	r8,-1
8000a4ce:	87 06       	st.w	r3[0x0],r6
8000a4d0:	fb 49 06 90 	st.w	sp[1680],r9
8000a4d4:	87 1b       	st.w	r3[0x4],r11
8000a4d6:	fb 48 06 8c 	st.w	sp[1676],r8
8000a4da:	58 78       	cp.w	r8,7
8000a4dc:	e0 89 00 04 	brgt	8000a4e4 <_vfprintf_r+0x1b48>
8000a4e0:	2f 83       	sub	r3,-8
8000a4e2:	c0 b8       	rjmp	8000a4f8 <_vfprintf_r+0x1b5c>
8000a4e4:	fa ca f9 78 	sub	r10,sp,-1672
8000a4e8:	02 9b       	mov	r11,r1
8000a4ea:	08 9c       	mov	r12,r4
8000a4ec:	fe b0 f2 4a 	rcall	80008980 <__sprint_r>
8000a4f0:	e0 81 01 d5 	brne	8000a89a <_vfprintf_r+0x1efe>
8000a4f4:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a4f8:	fa f6 06 ac 	ld.w	r6,sp[1708]
8000a4fc:	40 6a       	lddsp	r10,sp[0x18]
8000a4fe:	14 16       	sub	r6,r10
8000a500:	58 06       	cp.w	r6,0
8000a502:	e0 89 00 1c 	brgt	8000a53a <_vfprintf_r+0x1b9e>
8000a506:	c3 d8       	rjmp	8000a580 <_vfprintf_r+0x1be4>
8000a508:	2f 09       	sub	r9,-16
8000a50a:	2f f8       	sub	r8,-1
8000a50c:	fb 49 06 90 	st.w	sp[1680],r9
8000a510:	87 02       	st.w	r3[0x0],r2
8000a512:	87 10       	st.w	r3[0x4],r0
8000a514:	fb 48 06 8c 	st.w	sp[1676],r8
8000a518:	58 78       	cp.w	r8,7
8000a51a:	e0 89 00 04 	brgt	8000a522 <_vfprintf_r+0x1b86>
8000a51e:	2f 83       	sub	r3,-8
8000a520:	c0 b8       	rjmp	8000a536 <_vfprintf_r+0x1b9a>
8000a522:	fa ca f9 78 	sub	r10,sp,-1672
8000a526:	02 9b       	mov	r11,r1
8000a528:	08 9c       	mov	r12,r4
8000a52a:	fe b0 f2 2b 	rcall	80008980 <__sprint_r>
8000a52e:	e0 81 01 b6 	brne	8000a89a <_vfprintf_r+0x1efe>
8000a532:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a536:	21 06       	sub	r6,16
8000a538:	c0 48       	rjmp	8000a540 <_vfprintf_r+0x1ba4>
8000a53a:	fe c2 bb da 	sub	r2,pc,-17446
8000a53e:	31 00       	mov	r0,16
8000a540:	fa f9 06 90 	ld.w	r9,sp[1680]
8000a544:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a548:	fe ca bb e8 	sub	r10,pc,-17432
8000a54c:	59 06       	cp.w	r6,16
8000a54e:	fe 99 ff dd 	brgt	8000a508 <_vfprintf_r+0x1b6c>
8000a552:	0c 09       	add	r9,r6
8000a554:	2f f8       	sub	r8,-1
8000a556:	87 0a       	st.w	r3[0x0],r10
8000a558:	fb 49 06 90 	st.w	sp[1680],r9
8000a55c:	87 16       	st.w	r3[0x4],r6
8000a55e:	fb 48 06 8c 	st.w	sp[1676],r8
8000a562:	58 78       	cp.w	r8,7
8000a564:	e0 89 00 04 	brgt	8000a56c <_vfprintf_r+0x1bd0>
8000a568:	2f 83       	sub	r3,-8
8000a56a:	c0 b8       	rjmp	8000a580 <_vfprintf_r+0x1be4>
8000a56c:	fa ca f9 78 	sub	r10,sp,-1672
8000a570:	02 9b       	mov	r11,r1
8000a572:	08 9c       	mov	r12,r4
8000a574:	fe b0 f2 06 	rcall	80008980 <__sprint_r>
8000a578:	e0 81 01 91 	brne	8000a89a <_vfprintf_r+0x1efe>
8000a57c:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a580:	ed b5 00 00 	bld	r5,0x0
8000a584:	e0 81 01 20 	brne	8000a7c4 <_vfprintf_r+0x1e28>
8000a588:	40 c9       	lddsp	r9,sp[0x30]
8000a58a:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a58e:	2f f8       	sub	r8,-1
8000a590:	87 09       	st.w	r3[0x0],r9
8000a592:	fb 48 06 90 	st.w	sp[1680],r8
8000a596:	30 19       	mov	r9,1
8000a598:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a59c:	87 19       	st.w	r3[0x4],r9
8000a59e:	2f f8       	sub	r8,-1
8000a5a0:	fb 48 06 8c 	st.w	sp[1676],r8
8000a5a4:	c0 29       	rjmp	8000a7a8 <_vfprintf_r+0x1e0c>
8000a5a6:	14 09       	add	r9,r10
8000a5a8:	2f f8       	sub	r8,-1
8000a5aa:	fb 49 06 90 	st.w	sp[1680],r9
8000a5ae:	87 06       	st.w	r3[0x0],r6
8000a5b0:	87 1a       	st.w	r3[0x4],r10
8000a5b2:	fb 48 06 8c 	st.w	sp[1676],r8
8000a5b6:	58 78       	cp.w	r8,7
8000a5b8:	e0 89 00 04 	brgt	8000a5c0 <_vfprintf_r+0x1c24>
8000a5bc:	2f 83       	sub	r3,-8
8000a5be:	c0 b8       	rjmp	8000a5d4 <_vfprintf_r+0x1c38>
8000a5c0:	fa ca f9 78 	sub	r10,sp,-1672
8000a5c4:	02 9b       	mov	r11,r1
8000a5c6:	08 9c       	mov	r12,r4
8000a5c8:	fe b0 f1 dc 	rcall	80008980 <__sprint_r>
8000a5cc:	e0 81 01 67 	brne	8000a89a <_vfprintf_r+0x1efe>
8000a5d0:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a5d4:	40 c8       	lddsp	r8,sp[0x30]
8000a5d6:	87 08       	st.w	r3[0x0],r8
8000a5d8:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a5dc:	2f f8       	sub	r8,-1
8000a5de:	30 19       	mov	r9,1
8000a5e0:	fb 48 06 90 	st.w	sp[1680],r8
8000a5e4:	87 19       	st.w	r3[0x4],r9
8000a5e6:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a5ea:	2f f8       	sub	r8,-1
8000a5ec:	fb 48 06 8c 	st.w	sp[1676],r8
8000a5f0:	fa f2 06 ac 	ld.w	r2,sp[1708]
8000a5f4:	58 78       	cp.w	r8,7
8000a5f6:	e0 89 00 04 	brgt	8000a5fe <_vfprintf_r+0x1c62>
8000a5fa:	2f 83       	sub	r3,-8
8000a5fc:	c0 b8       	rjmp	8000a612 <_vfprintf_r+0x1c76>
8000a5fe:	fa ca f9 78 	sub	r10,sp,-1672
8000a602:	02 9b       	mov	r11,r1
8000a604:	08 9c       	mov	r12,r4
8000a606:	fe b0 f1 bd 	rcall	80008980 <__sprint_r>
8000a60a:	e0 81 01 48 	brne	8000a89a <_vfprintf_r+0x1efe>
8000a60e:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a612:	04 06       	add	r6,r2
8000a614:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000a618:	87 06       	st.w	r3[0x0],r6
8000a61a:	fa f9 06 90 	ld.w	r9,sp[1680]
8000a61e:	40 66       	lddsp	r6,sp[0x18]
8000a620:	40 6e       	lddsp	lr,sp[0x18]
8000a622:	10 16       	sub	r6,r8
8000a624:	f2 08 01 08 	sub	r8,r9,r8
8000a628:	87 16       	st.w	r3[0x4],r6
8000a62a:	1c 08       	add	r8,lr
8000a62c:	fb 48 06 90 	st.w	sp[1680],r8
8000a630:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a634:	2f f8       	sub	r8,-1
8000a636:	fb 48 06 8c 	st.w	sp[1676],r8
8000a63a:	cb 78       	rjmp	8000a7a8 <_vfprintf_r+0x1e0c>
8000a63c:	40 6c       	lddsp	r12,sp[0x18]
8000a63e:	58 1c       	cp.w	r12,1
8000a640:	e0 89 00 06 	brgt	8000a64c <_vfprintf_r+0x1cb0>
8000a644:	ed b5 00 00 	bld	r5,0x0
8000a648:	e0 81 00 85 	brne	8000a752 <_vfprintf_r+0x1db6>
8000a64c:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a650:	2f f8       	sub	r8,-1
8000a652:	30 19       	mov	r9,1
8000a654:	fb 48 06 90 	st.w	sp[1680],r8
8000a658:	87 06       	st.w	r3[0x0],r6
8000a65a:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a65e:	87 19       	st.w	r3[0x4],r9
8000a660:	2f f8       	sub	r8,-1
8000a662:	fb 48 06 8c 	st.w	sp[1676],r8
8000a666:	58 78       	cp.w	r8,7
8000a668:	e0 89 00 04 	brgt	8000a670 <_vfprintf_r+0x1cd4>
8000a66c:	2f 83       	sub	r3,-8
8000a66e:	c0 b8       	rjmp	8000a684 <_vfprintf_r+0x1ce8>
8000a670:	fa ca f9 78 	sub	r10,sp,-1672
8000a674:	02 9b       	mov	r11,r1
8000a676:	08 9c       	mov	r12,r4
8000a678:	fe b0 f1 84 	rcall	80008980 <__sprint_r>
8000a67c:	e0 81 01 0f 	brne	8000a89a <_vfprintf_r+0x1efe>
8000a680:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a684:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a688:	2f f8       	sub	r8,-1
8000a68a:	40 cb       	lddsp	r11,sp[0x30]
8000a68c:	fb 48 06 90 	st.w	sp[1680],r8
8000a690:	30 19       	mov	r9,1
8000a692:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a696:	87 0b       	st.w	r3[0x0],r11
8000a698:	2f f8       	sub	r8,-1
8000a69a:	87 19       	st.w	r3[0x4],r9
8000a69c:	fb 48 06 8c 	st.w	sp[1676],r8
8000a6a0:	58 78       	cp.w	r8,7
8000a6a2:	e0 89 00 05 	brgt	8000a6ac <_vfprintf_r+0x1d10>
8000a6a6:	2f 83       	sub	r3,-8
8000a6a8:	c0 c8       	rjmp	8000a6c0 <_vfprintf_r+0x1d24>
8000a6aa:	d7 03       	nop
8000a6ac:	fa ca f9 78 	sub	r10,sp,-1672
8000a6b0:	02 9b       	mov	r11,r1
8000a6b2:	08 9c       	mov	r12,r4
8000a6b4:	fe b0 f1 66 	rcall	80008980 <__sprint_r>
8000a6b8:	e0 81 00 f1 	brne	8000a89a <_vfprintf_r+0x1efe>
8000a6bc:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a6c0:	30 08       	mov	r8,0
8000a6c2:	30 09       	mov	r9,0
8000a6c4:	40 5b       	lddsp	r11,sp[0x14]
8000a6c6:	40 7a       	lddsp	r10,sp[0x1c]
8000a6c8:	e0 a0 13 25 	rcall	8000cd12 <__avr32_f64_cmp_eq>
8000a6cc:	40 68       	lddsp	r8,sp[0x18]
8000a6ce:	20 18       	sub	r8,1
8000a6d0:	58 0c       	cp.w	r12,0
8000a6d2:	c0 d1       	brne	8000a6ec <_vfprintf_r+0x1d50>
8000a6d4:	2f f6       	sub	r6,-1
8000a6d6:	87 18       	st.w	r3[0x4],r8
8000a6d8:	87 06       	st.w	r3[0x0],r6
8000a6da:	fa f6 06 90 	ld.w	r6,sp[1680]
8000a6de:	10 06       	add	r6,r8
8000a6e0:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a6e4:	fb 46 06 90 	st.w	sp[1680],r6
8000a6e8:	2f f8       	sub	r8,-1
8000a6ea:	c3 18       	rjmp	8000a74c <_vfprintf_r+0x1db0>
8000a6ec:	10 96       	mov	r6,r8
8000a6ee:	58 08       	cp.w	r8,0
8000a6f0:	e0 89 00 1c 	brgt	8000a728 <_vfprintf_r+0x1d8c>
8000a6f4:	c4 b8       	rjmp	8000a78a <_vfprintf_r+0x1dee>
8000a6f6:	2f 09       	sub	r9,-16
8000a6f8:	2f f8       	sub	r8,-1
8000a6fa:	fb 49 06 90 	st.w	sp[1680],r9
8000a6fe:	87 02       	st.w	r3[0x0],r2
8000a700:	87 10       	st.w	r3[0x4],r0
8000a702:	fb 48 06 8c 	st.w	sp[1676],r8
8000a706:	58 78       	cp.w	r8,7
8000a708:	e0 89 00 04 	brgt	8000a710 <_vfprintf_r+0x1d74>
8000a70c:	2f 83       	sub	r3,-8
8000a70e:	c0 b8       	rjmp	8000a724 <_vfprintf_r+0x1d88>
8000a710:	fa ca f9 78 	sub	r10,sp,-1672
8000a714:	02 9b       	mov	r11,r1
8000a716:	08 9c       	mov	r12,r4
8000a718:	fe b0 f1 34 	rcall	80008980 <__sprint_r>
8000a71c:	e0 81 00 bf 	brne	8000a89a <_vfprintf_r+0x1efe>
8000a720:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a724:	21 06       	sub	r6,16
8000a726:	c0 48       	rjmp	8000a72e <_vfprintf_r+0x1d92>
8000a728:	fe c2 bd c8 	sub	r2,pc,-16952
8000a72c:	31 00       	mov	r0,16
8000a72e:	fa f9 06 90 	ld.w	r9,sp[1680]
8000a732:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a736:	fe ca bd d6 	sub	r10,pc,-16938
8000a73a:	59 06       	cp.w	r6,16
8000a73c:	fe 99 ff dd 	brgt	8000a6f6 <_vfprintf_r+0x1d5a>
8000a740:	0c 09       	add	r9,r6
8000a742:	87 0a       	st.w	r3[0x0],r10
8000a744:	fb 49 06 90 	st.w	sp[1680],r9
8000a748:	2f f8       	sub	r8,-1
8000a74a:	87 16       	st.w	r3[0x4],r6
8000a74c:	fb 48 06 8c 	st.w	sp[1676],r8
8000a750:	c0 e8       	rjmp	8000a76c <_vfprintf_r+0x1dd0>
8000a752:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a756:	2f f8       	sub	r8,-1
8000a758:	30 19       	mov	r9,1
8000a75a:	fb 48 06 90 	st.w	sp[1680],r8
8000a75e:	87 06       	st.w	r3[0x0],r6
8000a760:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a764:	87 19       	st.w	r3[0x4],r9
8000a766:	2f f8       	sub	r8,-1
8000a768:	fb 48 06 8c 	st.w	sp[1676],r8
8000a76c:	58 78       	cp.w	r8,7
8000a76e:	e0 89 00 04 	brgt	8000a776 <_vfprintf_r+0x1dda>
8000a772:	2f 83       	sub	r3,-8
8000a774:	c0 b8       	rjmp	8000a78a <_vfprintf_r+0x1dee>
8000a776:	fa ca f9 78 	sub	r10,sp,-1672
8000a77a:	02 9b       	mov	r11,r1
8000a77c:	08 9c       	mov	r12,r4
8000a77e:	fe b0 f1 01 	rcall	80008980 <__sprint_r>
8000a782:	e0 81 00 8c 	brne	8000a89a <_vfprintf_r+0x1efe>
8000a786:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a78a:	40 ea       	lddsp	r10,sp[0x38]
8000a78c:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a790:	14 08       	add	r8,r10
8000a792:	fa c9 f9 64 	sub	r9,sp,-1692
8000a796:	fb 48 06 90 	st.w	sp[1680],r8
8000a79a:	87 1a       	st.w	r3[0x4],r10
8000a79c:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a7a0:	87 09       	st.w	r3[0x0],r9
8000a7a2:	2f f8       	sub	r8,-1
8000a7a4:	fb 48 06 8c 	st.w	sp[1676],r8
8000a7a8:	58 78       	cp.w	r8,7
8000a7aa:	e0 89 00 04 	brgt	8000a7b2 <_vfprintf_r+0x1e16>
8000a7ae:	2f 83       	sub	r3,-8
8000a7b0:	c0 a8       	rjmp	8000a7c4 <_vfprintf_r+0x1e28>
8000a7b2:	fa ca f9 78 	sub	r10,sp,-1672
8000a7b6:	02 9b       	mov	r11,r1
8000a7b8:	08 9c       	mov	r12,r4
8000a7ba:	fe b0 f0 e3 	rcall	80008980 <__sprint_r>
8000a7be:	c6 e1       	brne	8000a89a <_vfprintf_r+0x1efe>
8000a7c0:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a7c4:	e2 15 00 04 	andl	r5,0x4,COH
8000a7c8:	c3 f0       	breq	8000a846 <_vfprintf_r+0x1eaa>
8000a7ca:	40 86       	lddsp	r6,sp[0x20]
8000a7cc:	40 39       	lddsp	r9,sp[0xc]
8000a7ce:	12 16       	sub	r6,r9
8000a7d0:	58 06       	cp.w	r6,0
8000a7d2:	e0 89 00 1a 	brgt	8000a806 <_vfprintf_r+0x1e6a>
8000a7d6:	c3 88       	rjmp	8000a846 <_vfprintf_r+0x1eaa>
8000a7d8:	2f 09       	sub	r9,-16
8000a7da:	2f f8       	sub	r8,-1
8000a7dc:	fb 49 06 90 	st.w	sp[1680],r9
8000a7e0:	87 05       	st.w	r3[0x0],r5
8000a7e2:	87 12       	st.w	r3[0x4],r2
8000a7e4:	fb 48 06 8c 	st.w	sp[1676],r8
8000a7e8:	58 78       	cp.w	r8,7
8000a7ea:	e0 89 00 04 	brgt	8000a7f2 <_vfprintf_r+0x1e56>
8000a7ee:	2f 83       	sub	r3,-8
8000a7f0:	c0 98       	rjmp	8000a802 <_vfprintf_r+0x1e66>
8000a7f2:	00 9a       	mov	r10,r0
8000a7f4:	02 9b       	mov	r11,r1
8000a7f6:	08 9c       	mov	r12,r4
8000a7f8:	fe b0 f0 c4 	rcall	80008980 <__sprint_r>
8000a7fc:	c4 f1       	brne	8000a89a <_vfprintf_r+0x1efe>
8000a7fe:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a802:	21 06       	sub	r6,16
8000a804:	c0 68       	rjmp	8000a810 <_vfprintf_r+0x1e74>
8000a806:	fe c5 be b6 	sub	r5,pc,-16714
8000a80a:	31 02       	mov	r2,16
8000a80c:	fa c0 f9 78 	sub	r0,sp,-1672
8000a810:	fa f9 06 90 	ld.w	r9,sp[1680]
8000a814:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a818:	fe ca be c8 	sub	r10,pc,-16696
8000a81c:	59 06       	cp.w	r6,16
8000a81e:	fe 99 ff dd 	brgt	8000a7d8 <_vfprintf_r+0x1e3c>
8000a822:	0c 09       	add	r9,r6
8000a824:	2f f8       	sub	r8,-1
8000a826:	87 0a       	st.w	r3[0x0],r10
8000a828:	87 16       	st.w	r3[0x4],r6
8000a82a:	fb 49 06 90 	st.w	sp[1680],r9
8000a82e:	fb 48 06 8c 	st.w	sp[1676],r8
8000a832:	58 78       	cp.w	r8,7
8000a834:	e0 8a 00 09 	brle	8000a846 <_vfprintf_r+0x1eaa>
8000a838:	fa ca f9 78 	sub	r10,sp,-1672
8000a83c:	02 9b       	mov	r11,r1
8000a83e:	08 9c       	mov	r12,r4
8000a840:	fe b0 f0 a0 	rcall	80008980 <__sprint_r>
8000a844:	c2 b1       	brne	8000a89a <_vfprintf_r+0x1efe>
8000a846:	40 bc       	lddsp	r12,sp[0x2c]
8000a848:	40 36       	lddsp	r6,sp[0xc]
8000a84a:	40 8e       	lddsp	lr,sp[0x20]
8000a84c:	ec 0e 0c 48 	max	r8,r6,lr
8000a850:	10 0c       	add	r12,r8
8000a852:	50 bc       	stdsp	sp[0x2c],r12
8000a854:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a858:	58 08       	cp.w	r8,0
8000a85a:	c0 80       	breq	8000a86a <_vfprintf_r+0x1ece>
8000a85c:	fa ca f9 78 	sub	r10,sp,-1672
8000a860:	02 9b       	mov	r11,r1
8000a862:	08 9c       	mov	r12,r4
8000a864:	fe b0 f0 8e 	rcall	80008980 <__sprint_r>
8000a868:	c1 91       	brne	8000a89a <_vfprintf_r+0x1efe>
8000a86a:	30 0b       	mov	r11,0
8000a86c:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a870:	fb 4b 06 8c 	st.w	sp[1676],r11
8000a874:	fe 9f f1 22 	bral	80008ab8 <_vfprintf_r+0x11c>
8000a878:	08 95       	mov	r5,r4
8000a87a:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a87e:	58 08       	cp.w	r8,0
8000a880:	c0 80       	breq	8000a890 <_vfprintf_r+0x1ef4>
8000a882:	08 9c       	mov	r12,r4
8000a884:	fa ca f9 78 	sub	r10,sp,-1672
8000a888:	02 9b       	mov	r11,r1
8000a88a:	fe b0 f0 7b 	rcall	80008980 <__sprint_r>
8000a88e:	c0 61       	brne	8000a89a <_vfprintf_r+0x1efe>
8000a890:	30 08       	mov	r8,0
8000a892:	fb 48 06 8c 	st.w	sp[1676],r8
8000a896:	c0 28       	rjmp	8000a89a <_vfprintf_r+0x1efe>
8000a898:	40 41       	lddsp	r1,sp[0x10]
8000a89a:	82 68       	ld.sh	r8,r1[0xc]
8000a89c:	ed b8 00 06 	bld	r8,0x6
8000a8a0:	c0 31       	brne	8000a8a6 <_vfprintf_r+0x1f0a>
8000a8a2:	3f fa       	mov	r10,-1
8000a8a4:	50 ba       	stdsp	sp[0x2c],r10
8000a8a6:	40 bc       	lddsp	r12,sp[0x2c]
8000a8a8:	fe 3d f9 44 	sub	sp,-1724
8000a8ac:	d8 32       	popm	r0-r7,pc
8000a8ae:	d7 03       	nop

8000a8b0 <__swsetup_r>:
8000a8b0:	d4 21       	pushm	r4-r7,lr
8000a8b2:	e0 68 0a 4c 	mov	r8,2636
8000a8b6:	18 96       	mov	r6,r12
8000a8b8:	16 97       	mov	r7,r11
8000a8ba:	70 0c       	ld.w	r12,r8[0x0]
8000a8bc:	58 0c       	cp.w	r12,0
8000a8be:	c0 60       	breq	8000a8ca <__swsetup_r+0x1a>
8000a8c0:	78 68       	ld.w	r8,r12[0x18]
8000a8c2:	58 08       	cp.w	r8,0
8000a8c4:	c0 31       	brne	8000a8ca <__swsetup_r+0x1a>
8000a8c6:	e0 a0 07 bf 	rcall	8000b844 <__sinit>
8000a8ca:	fe c8 be 4a 	sub	r8,pc,-16822
8000a8ce:	10 37       	cp.w	r7,r8
8000a8d0:	c0 61       	brne	8000a8dc <__swsetup_r+0x2c>
8000a8d2:	e0 68 0a 4c 	mov	r8,2636
8000a8d6:	70 08       	ld.w	r8,r8[0x0]
8000a8d8:	70 07       	ld.w	r7,r8[0x0]
8000a8da:	c1 28       	rjmp	8000a8fe <__swsetup_r+0x4e>
8000a8dc:	fe c8 be 3c 	sub	r8,pc,-16836
8000a8e0:	10 37       	cp.w	r7,r8
8000a8e2:	c0 61       	brne	8000a8ee <__swsetup_r+0x3e>
8000a8e4:	e0 68 0a 4c 	mov	r8,2636
8000a8e8:	70 08       	ld.w	r8,r8[0x0]
8000a8ea:	70 17       	ld.w	r7,r8[0x4]
8000a8ec:	c0 98       	rjmp	8000a8fe <__swsetup_r+0x4e>
8000a8ee:	fe c8 be 2e 	sub	r8,pc,-16850
8000a8f2:	10 37       	cp.w	r7,r8
8000a8f4:	c0 51       	brne	8000a8fe <__swsetup_r+0x4e>
8000a8f6:	e0 68 0a 4c 	mov	r8,2636
8000a8fa:	70 08       	ld.w	r8,r8[0x0]
8000a8fc:	70 27       	ld.w	r7,r8[0x8]
8000a8fe:	8e 68       	ld.sh	r8,r7[0xc]
8000a900:	ed b8 00 03 	bld	r8,0x3
8000a904:	c1 e0       	breq	8000a940 <__swsetup_r+0x90>
8000a906:	ed b8 00 04 	bld	r8,0x4
8000a90a:	c3 e1       	brne	8000a986 <__swsetup_r+0xd6>
8000a90c:	ed b8 00 02 	bld	r8,0x2
8000a910:	c1 51       	brne	8000a93a <__swsetup_r+0x8a>
8000a912:	6e db       	ld.w	r11,r7[0x34]
8000a914:	58 0b       	cp.w	r11,0
8000a916:	c0 a0       	breq	8000a92a <__swsetup_r+0x7a>
8000a918:	ee c8 ff bc 	sub	r8,r7,-68
8000a91c:	10 3b       	cp.w	r11,r8
8000a91e:	c0 40       	breq	8000a926 <__swsetup_r+0x76>
8000a920:	0c 9c       	mov	r12,r6
8000a922:	e0 a0 08 2b 	rcall	8000b978 <_free_r>
8000a926:	30 08       	mov	r8,0
8000a928:	8f d8       	st.w	r7[0x34],r8
8000a92a:	8e 68       	ld.sh	r8,r7[0xc]
8000a92c:	e0 18 ff db 	andl	r8,0xffdb
8000a930:	ae 68       	st.h	r7[0xc],r8
8000a932:	30 08       	mov	r8,0
8000a934:	8f 18       	st.w	r7[0x4],r8
8000a936:	6e 48       	ld.w	r8,r7[0x10]
8000a938:	8f 08       	st.w	r7[0x0],r8
8000a93a:	8e 68       	ld.sh	r8,r7[0xc]
8000a93c:	a3 b8       	sbr	r8,0x3
8000a93e:	ae 68       	st.h	r7[0xc],r8
8000a940:	6e 48       	ld.w	r8,r7[0x10]
8000a942:	58 08       	cp.w	r8,0
8000a944:	c0 b1       	brne	8000a95a <__swsetup_r+0xaa>
8000a946:	8e 68       	ld.sh	r8,r7[0xc]
8000a948:	e2 18 02 80 	andl	r8,0x280,COH
8000a94c:	e0 48 02 00 	cp.w	r8,512
8000a950:	c0 50       	breq	8000a95a <__swsetup_r+0xaa>
8000a952:	0c 9c       	mov	r12,r6
8000a954:	0e 9b       	mov	r11,r7
8000a956:	e0 a0 0a 4b 	rcall	8000bdec <__smakebuf_r>
8000a95a:	8e 69       	ld.sh	r9,r7[0xc]
8000a95c:	f1 d9 c0 01 	bfextu	r8,r9,0x0,0x1
8000a960:	c0 70       	breq	8000a96e <__swsetup_r+0xbe>
8000a962:	30 08       	mov	r8,0
8000a964:	8f 28       	st.w	r7[0x8],r8
8000a966:	6e 58       	ld.w	r8,r7[0x14]
8000a968:	5c 38       	neg	r8
8000a96a:	8f 68       	st.w	r7[0x18],r8
8000a96c:	c0 68       	rjmp	8000a978 <__swsetup_r+0xc8>
8000a96e:	ed b9 00 01 	bld	r9,0x1
8000a972:	ef f8 10 05 	ld.wne	r8,r7[0x14]
8000a976:	8f 28       	st.w	r7[0x8],r8
8000a978:	6e 48       	ld.w	r8,r7[0x10]
8000a97a:	58 08       	cp.w	r8,0
8000a97c:	c0 61       	brne	8000a988 <__swsetup_r+0xd8>
8000a97e:	8e 68       	ld.sh	r8,r7[0xc]
8000a980:	ed b8 00 07 	bld	r8,0x7
8000a984:	c0 21       	brne	8000a988 <__swsetup_r+0xd8>
8000a986:	dc 2a       	popm	r4-r7,pc,r12=-1
8000a988:	d8 2a       	popm	r4-r7,pc,r12=0
8000a98a:	d7 03       	nop

8000a98c <quorem>:
8000a98c:	d4 31       	pushm	r0-r7,lr
8000a98e:	20 2d       	sub	sp,8
8000a990:	18 97       	mov	r7,r12
8000a992:	78 48       	ld.w	r8,r12[0x10]
8000a994:	76 46       	ld.w	r6,r11[0x10]
8000a996:	0c 38       	cp.w	r8,r6
8000a998:	c0 34       	brge	8000a99e <quorem+0x12>
8000a99a:	30 0c       	mov	r12,0
8000a99c:	c8 58       	rjmp	8000aaa6 <quorem+0x11a>
8000a99e:	ec c2 ff fc 	sub	r2,r6,-4
8000a9a2:	f6 c3 ff ec 	sub	r3,r11,-20
8000a9a6:	f6 02 03 29 	ld.w	r9,r11[r2<<0x2]
8000a9aa:	f8 02 03 2c 	ld.w	r12,r12[r2<<0x2]
8000a9ae:	2f f9       	sub	r9,-1
8000a9b0:	20 16       	sub	r6,1
8000a9b2:	f8 09 0d 08 	divu	r8,r12,r9
8000a9b6:	f6 02 00 22 	add	r2,r11,r2<<0x2
8000a9ba:	ee c4 ff ec 	sub	r4,r7,-20
8000a9be:	10 95       	mov	r5,r8
8000a9c0:	58 08       	cp.w	r8,0
8000a9c2:	c4 10       	breq	8000aa44 <quorem+0xb8>
8000a9c4:	30 09       	mov	r9,0
8000a9c6:	06 9a       	mov	r10,r3
8000a9c8:	08 98       	mov	r8,r4
8000a9ca:	12 91       	mov	r1,r9
8000a9cc:	50 0b       	stdsp	sp[0x0],r11
8000a9ce:	70 0e       	ld.w	lr,r8[0x0]
8000a9d0:	b1 8e       	lsr	lr,0x10
8000a9d2:	50 1e       	stdsp	sp[0x4],lr
8000a9d4:	15 0e       	ld.w	lr,r10++
8000a9d6:	fc 00 16 10 	lsr	r0,lr,0x10
8000a9da:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000a9de:	ea 0e 03 41 	mac	r1,r5,lr
8000a9e2:	fd d1 c0 10 	bfextu	lr,r1,0x0,0x10
8000a9e6:	b1 81       	lsr	r1,0x10
8000a9e8:	40 1b       	lddsp	r11,sp[0x4]
8000a9ea:	ea 00 02 40 	mul	r0,r5,r0
8000a9ee:	e2 00 00 00 	add	r0,r1,r0
8000a9f2:	e3 d0 c0 10 	bfextu	r1,r0,0x0,0x10
8000a9f6:	02 1b       	sub	r11,r1
8000a9f8:	50 1b       	stdsp	sp[0x4],r11
8000a9fa:	70 0b       	ld.w	r11,r8[0x0]
8000a9fc:	e3 db c0 10 	bfextu	r1,r11,0x0,0x10
8000aa00:	02 09       	add	r9,r1
8000aa02:	f2 0e 01 0e 	sub	lr,r9,lr
8000aa06:	b0 1e       	st.h	r8[0x2],lr
8000aa08:	fc 09 14 10 	asr	r9,lr,0x10
8000aa0c:	40 1e       	lddsp	lr,sp[0x4]
8000aa0e:	fc 09 00 09 	add	r9,lr,r9
8000aa12:	b0 09       	st.h	r8[0x0],r9
8000aa14:	e0 01 16 10 	lsr	r1,r0,0x10
8000aa18:	2f c8       	sub	r8,-4
8000aa1a:	b1 49       	asr	r9,0x10
8000aa1c:	04 3a       	cp.w	r10,r2
8000aa1e:	fe 98 ff d8 	brls	8000a9ce <quorem+0x42>
8000aa22:	40 0b       	lddsp	r11,sp[0x0]
8000aa24:	58 0c       	cp.w	r12,0
8000aa26:	c0 f1       	brne	8000aa44 <quorem+0xb8>
8000aa28:	ec c8 ff fb 	sub	r8,r6,-5
8000aa2c:	ee 08 00 28 	add	r8,r7,r8<<0x2
8000aa30:	c0 28       	rjmp	8000aa34 <quorem+0xa8>
8000aa32:	20 16       	sub	r6,1
8000aa34:	20 48       	sub	r8,4
8000aa36:	08 38       	cp.w	r8,r4
8000aa38:	e0 88 00 05 	brls	8000aa42 <quorem+0xb6>
8000aa3c:	70 09       	ld.w	r9,r8[0x0]
8000aa3e:	58 09       	cp.w	r9,0
8000aa40:	cf 90       	breq	8000aa32 <quorem+0xa6>
8000aa42:	8f 46       	st.w	r7[0x10],r6
8000aa44:	0e 9c       	mov	r12,r7
8000aa46:	e0 a0 0a d2 	rcall	8000bfea <__mcmp>
8000aa4a:	c2 d5       	brlt	8000aaa4 <quorem+0x118>
8000aa4c:	2f f5       	sub	r5,-1
8000aa4e:	08 98       	mov	r8,r4
8000aa50:	30 09       	mov	r9,0
8000aa52:	07 0b       	ld.w	r11,r3++
8000aa54:	f6 0a 16 10 	lsr	r10,r11,0x10
8000aa58:	70 0c       	ld.w	r12,r8[0x0]
8000aa5a:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000aa5e:	f8 0e 16 10 	lsr	lr,r12,0x10
8000aa62:	14 1e       	sub	lr,r10
8000aa64:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000aa68:	16 1a       	sub	r10,r11
8000aa6a:	12 0a       	add	r10,r9
8000aa6c:	b0 1a       	st.h	r8[0x2],r10
8000aa6e:	b1 4a       	asr	r10,0x10
8000aa70:	fc 0a 00 09 	add	r9,lr,r10
8000aa74:	b0 09       	st.h	r8[0x0],r9
8000aa76:	2f c8       	sub	r8,-4
8000aa78:	b1 49       	asr	r9,0x10
8000aa7a:	04 33       	cp.w	r3,r2
8000aa7c:	fe 98 ff eb 	brls	8000aa52 <quorem+0xc6>
8000aa80:	ec c8 ff fb 	sub	r8,r6,-5
8000aa84:	ee 08 03 29 	ld.w	r9,r7[r8<<0x2]
8000aa88:	58 09       	cp.w	r9,0
8000aa8a:	c0 d1       	brne	8000aaa4 <quorem+0x118>
8000aa8c:	ee 08 00 28 	add	r8,r7,r8<<0x2
8000aa90:	c0 28       	rjmp	8000aa94 <quorem+0x108>
8000aa92:	20 16       	sub	r6,1
8000aa94:	20 48       	sub	r8,4
8000aa96:	08 38       	cp.w	r8,r4
8000aa98:	e0 88 00 05 	brls	8000aaa2 <quorem+0x116>
8000aa9c:	70 09       	ld.w	r9,r8[0x0]
8000aa9e:	58 09       	cp.w	r9,0
8000aaa0:	cf 90       	breq	8000aa92 <quorem+0x106>
8000aaa2:	8f 46       	st.w	r7[0x10],r6
8000aaa4:	0a 9c       	mov	r12,r5
8000aaa6:	2f ed       	sub	sp,-8
8000aaa8:	d8 32       	popm	r0-r7,pc
8000aaaa:	d7 03       	nop

8000aaac <_dtoa_r>:
8000aaac:	d4 31       	pushm	r0-r7,lr
8000aaae:	21 ad       	sub	sp,104
8000aab0:	fa c4 ff 74 	sub	r4,sp,-140
8000aab4:	18 97       	mov	r7,r12
8000aab6:	16 95       	mov	r5,r11
8000aab8:	68 2c       	ld.w	r12,r4[0x8]
8000aaba:	50 c9       	stdsp	sp[0x30],r9
8000aabc:	68 16       	ld.w	r6,r4[0x4]
8000aabe:	68 09       	ld.w	r9,r4[0x0]
8000aac0:	50 e8       	stdsp	sp[0x38],r8
8000aac2:	14 94       	mov	r4,r10
8000aac4:	51 2c       	stdsp	sp[0x48],r12
8000aac6:	fa e5 00 08 	st.d	sp[8],r4
8000aaca:	51 59       	stdsp	sp[0x54],r9
8000aacc:	6e 95       	ld.w	r5,r7[0x24]
8000aace:	58 05       	cp.w	r5,0
8000aad0:	c0 91       	brne	8000aae2 <_dtoa_r+0x36>
8000aad2:	31 0c       	mov	r12,16
8000aad4:	fe b0 e8 e2 	rcall	80007c98 <malloc>
8000aad8:	99 35       	st.w	r12[0xc],r5
8000aada:	8f 9c       	st.w	r7[0x24],r12
8000aadc:	99 15       	st.w	r12[0x4],r5
8000aade:	99 25       	st.w	r12[0x8],r5
8000aae0:	99 05       	st.w	r12[0x0],r5
8000aae2:	6e 99       	ld.w	r9,r7[0x24]
8000aae4:	72 08       	ld.w	r8,r9[0x0]
8000aae6:	58 08       	cp.w	r8,0
8000aae8:	c0 f0       	breq	8000ab06 <_dtoa_r+0x5a>
8000aaea:	72 1a       	ld.w	r10,r9[0x4]
8000aaec:	91 1a       	st.w	r8[0x4],r10
8000aaee:	30 1a       	mov	r10,1
8000aaf0:	72 19       	ld.w	r9,r9[0x4]
8000aaf2:	f4 09 09 49 	lsl	r9,r10,r9
8000aaf6:	10 9b       	mov	r11,r8
8000aaf8:	91 29       	st.w	r8[0x8],r9
8000aafa:	0e 9c       	mov	r12,r7
8000aafc:	e0 a0 0a 90 	rcall	8000c01c <_Bfree>
8000ab00:	6e 98       	ld.w	r8,r7[0x24]
8000ab02:	30 09       	mov	r9,0
8000ab04:	91 09       	st.w	r8[0x0],r9
8000ab06:	40 28       	lddsp	r8,sp[0x8]
8000ab08:	10 94       	mov	r4,r8
8000ab0a:	58 08       	cp.w	r8,0
8000ab0c:	c0 64       	brge	8000ab18 <_dtoa_r+0x6c>
8000ab0e:	f1 d8 c0 1f 	bfextu	r8,r8,0x0,0x1f
8000ab12:	50 28       	stdsp	sp[0x8],r8
8000ab14:	30 18       	mov	r8,1
8000ab16:	c0 28       	rjmp	8000ab1a <_dtoa_r+0x6e>
8000ab18:	30 08       	mov	r8,0
8000ab1a:	8d 08       	st.w	r6[0x0],r8
8000ab1c:	fc 1c 7f f0 	movh	r12,0x7ff0
8000ab20:	40 26       	lddsp	r6,sp[0x8]
8000ab22:	0c 98       	mov	r8,r6
8000ab24:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000ab28:	18 38       	cp.w	r8,r12
8000ab2a:	c2 01       	brne	8000ab6a <_dtoa_r+0xbe>
8000ab2c:	e0 68 27 0f 	mov	r8,9999
8000ab30:	41 5b       	lddsp	r11,sp[0x54]
8000ab32:	97 08       	st.w	r11[0x0],r8
8000ab34:	40 3a       	lddsp	r10,sp[0xc]
8000ab36:	58 0a       	cp.w	r10,0
8000ab38:	c0 71       	brne	8000ab46 <_dtoa_r+0x9a>
8000ab3a:	ed d6 c0 14 	bfextu	r6,r6,0x0,0x14
8000ab3e:	c0 41       	brne	8000ab46 <_dtoa_r+0x9a>
8000ab40:	fe cc c0 d0 	sub	r12,pc,-16176
8000ab44:	c0 38       	rjmp	8000ab4a <_dtoa_r+0x9e>
8000ab46:	fe cc c0 ca 	sub	r12,pc,-16182
8000ab4a:	41 29       	lddsp	r9,sp[0x48]
8000ab4c:	58 09       	cp.w	r9,0
8000ab4e:	e0 80 05 9a 	breq	8000b682 <_dtoa_r+0xbd6>
8000ab52:	f8 c8 ff fd 	sub	r8,r12,-3
8000ab56:	f8 c9 ff f8 	sub	r9,r12,-8
8000ab5a:	11 8b       	ld.ub	r11,r8[0x0]
8000ab5c:	30 0a       	mov	r10,0
8000ab5e:	41 25       	lddsp	r5,sp[0x48]
8000ab60:	f4 0b 18 00 	cp.b	r11,r10
8000ab64:	f2 08 17 10 	movne	r8,r9
8000ab68:	c1 68       	rjmp	8000ab94 <_dtoa_r+0xe8>
8000ab6a:	fa ea 00 08 	ld.d	r10,sp[8]
8000ab6e:	30 08       	mov	r8,0
8000ab70:	fa eb 00 3c 	st.d	sp[60],r10
8000ab74:	30 09       	mov	r9,0
8000ab76:	e0 a0 10 ce 	rcall	8000cd12 <__avr32_f64_cmp_eq>
8000ab7a:	c1 00       	breq	8000ab9a <_dtoa_r+0xee>
8000ab7c:	30 18       	mov	r8,1
8000ab7e:	41 5a       	lddsp	r10,sp[0x54]
8000ab80:	95 08       	st.w	r10[0x0],r8
8000ab82:	fe cc c2 36 	sub	r12,pc,-15818
8000ab86:	41 29       	lddsp	r9,sp[0x48]
8000ab88:	f8 08 00 08 	add	r8,r12,r8
8000ab8c:	58 09       	cp.w	r9,0
8000ab8e:	e0 80 05 7a 	breq	8000b682 <_dtoa_r+0xbd6>
8000ab92:	12 95       	mov	r5,r9
8000ab94:	8b 08       	st.w	r5[0x0],r8
8000ab96:	e0 8f 05 76 	bral	8000b682 <_dtoa_r+0xbd6>
8000ab9a:	fa c8 ff 9c 	sub	r8,sp,-100
8000ab9e:	fa c9 ff a0 	sub	r9,sp,-96
8000aba2:	fa ea 00 3c 	ld.d	r10,sp[60]
8000aba6:	0e 9c       	mov	r12,r7
8000aba8:	eb d6 c2 8b 	bfextu	r5,r6,0x14,0xb
8000abac:	e0 a0 0a 8a 	rcall	8000c0c0 <__d2b>
8000abb0:	18 93       	mov	r3,r12
8000abb2:	58 05       	cp.w	r5,0
8000abb4:	c0 d0       	breq	8000abce <_dtoa_r+0x122>
8000abb6:	fa ea 00 3c 	ld.d	r10,sp[60]
8000abba:	30 04       	mov	r4,0
8000abbc:	f1 db c0 14 	bfextu	r8,r11,0x0,0x14
8000abc0:	ea c5 03 ff 	sub	r5,r5,1023
8000abc4:	10 9b       	mov	r11,r8
8000abc6:	51 74       	stdsp	sp[0x5c],r4
8000abc8:	ea 1b 3f f0 	orh	r11,0x3ff0
8000abcc:	c2 58       	rjmp	8000ac16 <_dtoa_r+0x16a>
8000abce:	41 88       	lddsp	r8,sp[0x60]
8000abd0:	41 9c       	lddsp	r12,sp[0x64]
8000abd2:	10 0c       	add	r12,r8
8000abd4:	f8 c5 fb ce 	sub	r5,r12,-1074
8000abd8:	e0 45 00 20 	cp.w	r5,32
8000abdc:	e0 8a 00 0e 	brle	8000abf8 <_dtoa_r+0x14c>
8000abe0:	f8 cc fb ee 	sub	r12,r12,-1042
8000abe4:	40 3b       	lddsp	r11,sp[0xc]
8000abe6:	ea 08 11 40 	rsub	r8,r5,64
8000abea:	f6 0c 0a 4c 	lsr	r12,r11,r12
8000abee:	ec 08 09 46 	lsl	r6,r6,r8
8000abf2:	0c 4c       	or	r12,r6
8000abf4:	c0 78       	rjmp	8000ac02 <_dtoa_r+0x156>
8000abf6:	d7 03       	nop
8000abf8:	ea 0c 11 20 	rsub	r12,r5,32
8000abfc:	40 3a       	lddsp	r10,sp[0xc]
8000abfe:	f4 0c 09 4c 	lsl	r12,r10,r12
8000ac02:	e0 a0 10 14 	rcall	8000cc2a <__avr32_u32_to_f64>
8000ac06:	fc 18 fe 10 	movh	r8,0xfe10
8000ac0a:	30 19       	mov	r9,1
8000ac0c:	ea c5 04 33 	sub	r5,r5,1075
8000ac10:	f0 0b 00 0b 	add	r11,r8,r11
8000ac14:	51 79       	stdsp	sp[0x5c],r9
8000ac16:	30 08       	mov	r8,0
8000ac18:	fc 19 3f f8 	movh	r9,0x3ff8
8000ac1c:	e0 a0 0e 9c 	rcall	8000c954 <__avr32_f64_sub>
8000ac20:	e0 68 43 61 	mov	r8,17249
8000ac24:	ea 18 63 6f 	orh	r8,0x636f
8000ac28:	e0 69 87 a7 	mov	r9,34727
8000ac2c:	ea 19 3f d2 	orh	r9,0x3fd2
8000ac30:	e0 a0 0d a6 	rcall	8000c77c <__avr32_f64_mul>
8000ac34:	e0 68 c8 b3 	mov	r8,51379
8000ac38:	ea 18 8b 60 	orh	r8,0x8b60
8000ac3c:	e0 69 8a 28 	mov	r9,35368
8000ac40:	ea 19 3f c6 	orh	r9,0x3fc6
8000ac44:	e0 a0 0f 56 	rcall	8000caf0 <__avr32_f64_add>
8000ac48:	0a 9c       	mov	r12,r5
8000ac4a:	14 90       	mov	r0,r10
8000ac4c:	16 91       	mov	r1,r11
8000ac4e:	e0 a0 0f f2 	rcall	8000cc32 <__avr32_s32_to_f64>
8000ac52:	e0 68 79 fb 	mov	r8,31227
8000ac56:	ea 18 50 9f 	orh	r8,0x509f
8000ac5a:	e0 69 44 13 	mov	r9,17427
8000ac5e:	ea 19 3f d3 	orh	r9,0x3fd3
8000ac62:	e0 a0 0d 8d 	rcall	8000c77c <__avr32_f64_mul>
8000ac66:	14 98       	mov	r8,r10
8000ac68:	16 99       	mov	r9,r11
8000ac6a:	00 9a       	mov	r10,r0
8000ac6c:	02 9b       	mov	r11,r1
8000ac6e:	e0 a0 0f 41 	rcall	8000caf0 <__avr32_f64_add>
8000ac72:	14 90       	mov	r0,r10
8000ac74:	16 91       	mov	r1,r11
8000ac76:	e0 a0 0f c7 	rcall	8000cc04 <__avr32_f64_to_s32>
8000ac7a:	30 08       	mov	r8,0
8000ac7c:	18 96       	mov	r6,r12
8000ac7e:	30 09       	mov	r9,0
8000ac80:	00 9a       	mov	r10,r0
8000ac82:	02 9b       	mov	r11,r1
8000ac84:	e0 a0 10 8e 	rcall	8000cda0 <__avr32_f64_cmp_lt>
8000ac88:	c0 c0       	breq	8000aca0 <_dtoa_r+0x1f4>
8000ac8a:	0c 9c       	mov	r12,r6
8000ac8c:	e0 a0 0f d3 	rcall	8000cc32 <__avr32_s32_to_f64>
8000ac90:	14 98       	mov	r8,r10
8000ac92:	16 99       	mov	r9,r11
8000ac94:	00 9a       	mov	r10,r0
8000ac96:	02 9b       	mov	r11,r1
8000ac98:	e0 a0 10 3d 	rcall	8000cd12 <__avr32_f64_cmp_eq>
8000ac9c:	f7 b6 00 01 	subeq	r6,1
8000aca0:	59 66       	cp.w	r6,22
8000aca2:	e0 88 00 05 	brls	8000acac <_dtoa_r+0x200>
8000aca6:	30 18       	mov	r8,1
8000aca8:	51 48       	stdsp	sp[0x50],r8
8000acaa:	c1 38       	rjmp	8000acd0 <_dtoa_r+0x224>
8000acac:	fe c8 c1 7c 	sub	r8,pc,-16004
8000acb0:	fa ea 00 3c 	ld.d	r10,sp[60]
8000acb4:	f0 06 02 38 	ld.d	r8,r8[r6<<0x3]
8000acb8:	e0 a0 10 74 	rcall	8000cda0 <__avr32_f64_cmp_lt>
8000acbc:	f9 b4 00 00 	moveq	r4,0
8000acc0:	fb f4 0a 14 	st.weq	sp[0x50],r4
8000acc4:	f7 b6 01 01 	subne	r6,1
8000acc8:	f9 bc 01 00 	movne	r12,0
8000accc:	fb fc 1a 14 	st.wne	sp[0x50],r12
8000acd0:	41 90       	lddsp	r0,sp[0x64]
8000acd2:	20 10       	sub	r0,1
8000acd4:	0a 10       	sub	r0,r5
8000acd6:	c0 46       	brmi	8000acde <_dtoa_r+0x232>
8000acd8:	50 40       	stdsp	sp[0x10],r0
8000acda:	30 00       	mov	r0,0
8000acdc:	c0 48       	rjmp	8000ace4 <_dtoa_r+0x238>
8000acde:	30 0b       	mov	r11,0
8000ace0:	5c 30       	neg	r0
8000ace2:	50 4b       	stdsp	sp[0x10],r11
8000ace4:	ec 02 11 00 	rsub	r2,r6,0
8000ace8:	58 06       	cp.w	r6,0
8000acea:	fb fa 40 04 	ld.wge	r10,sp[0x10]
8000acee:	f5 d6 e4 0a 	addge	r10,r10,r6
8000acf2:	fb fa 4a 04 	st.wge	sp[0x10],r10
8000acf6:	fb f6 4a 11 	st.wge	sp[0x44],r6
8000acfa:	f9 b2 04 00 	movge	r2,0
8000acfe:	e1 d6 e5 10 	sublt	r0,r0,r6
8000ad02:	f9 b9 05 00 	movlt	r9,0
8000ad06:	fb f9 5a 11 	st.wlt	sp[0x44],r9
8000ad0a:	40 c8       	lddsp	r8,sp[0x30]
8000ad0c:	58 98       	cp.w	r8,9
8000ad0e:	e0 8b 00 20 	brhi	8000ad4e <_dtoa_r+0x2a2>
8000ad12:	58 58       	cp.w	r8,5
8000ad14:	f9 b4 0a 01 	movle	r4,1
8000ad18:	fb f5 90 0c 	ld.wgt	r5,sp[0x30]
8000ad1c:	f7 b5 09 04 	subgt	r5,4
8000ad20:	fb f5 9a 0c 	st.wgt	sp[0x30],r5
8000ad24:	f9 b4 09 00 	movgt	r4,0
8000ad28:	40 cc       	lddsp	r12,sp[0x30]
8000ad2a:	58 3c       	cp.w	r12,3
8000ad2c:	c2 d0       	breq	8000ad86 <_dtoa_r+0x2da>
8000ad2e:	e0 89 00 05 	brgt	8000ad38 <_dtoa_r+0x28c>
8000ad32:	58 2c       	cp.w	r12,2
8000ad34:	c1 01       	brne	8000ad54 <_dtoa_r+0x2a8>
8000ad36:	c1 88       	rjmp	8000ad66 <_dtoa_r+0x2ba>
8000ad38:	40 cb       	lddsp	r11,sp[0x30]
8000ad3a:	58 4b       	cp.w	r11,4
8000ad3c:	c0 60       	breq	8000ad48 <_dtoa_r+0x29c>
8000ad3e:	58 5b       	cp.w	r11,5
8000ad40:	c0 a1       	brne	8000ad54 <_dtoa_r+0x2a8>
8000ad42:	30 1a       	mov	r10,1
8000ad44:	50 da       	stdsp	sp[0x34],r10
8000ad46:	c2 28       	rjmp	8000ad8a <_dtoa_r+0x2de>
8000ad48:	30 19       	mov	r9,1
8000ad4a:	50 d9       	stdsp	sp[0x34],r9
8000ad4c:	c0 f8       	rjmp	8000ad6a <_dtoa_r+0x2be>
8000ad4e:	30 08       	mov	r8,0
8000ad50:	30 14       	mov	r4,1
8000ad52:	50 c8       	stdsp	sp[0x30],r8
8000ad54:	3f f5       	mov	r5,-1
8000ad56:	30 1c       	mov	r12,1
8000ad58:	30 0b       	mov	r11,0
8000ad5a:	50 95       	stdsp	sp[0x24],r5
8000ad5c:	50 dc       	stdsp	sp[0x34],r12
8000ad5e:	0a 91       	mov	r1,r5
8000ad60:	31 28       	mov	r8,18
8000ad62:	50 eb       	stdsp	sp[0x38],r11
8000ad64:	c2 08       	rjmp	8000ada4 <_dtoa_r+0x2f8>
8000ad66:	30 0a       	mov	r10,0
8000ad68:	50 da       	stdsp	sp[0x34],r10
8000ad6a:	40 e9       	lddsp	r9,sp[0x38]
8000ad6c:	58 09       	cp.w	r9,0
8000ad6e:	e0 89 00 07 	brgt	8000ad7c <_dtoa_r+0x2d0>
8000ad72:	30 18       	mov	r8,1
8000ad74:	50 98       	stdsp	sp[0x24],r8
8000ad76:	10 91       	mov	r1,r8
8000ad78:	50 e8       	stdsp	sp[0x38],r8
8000ad7a:	c1 58       	rjmp	8000ada4 <_dtoa_r+0x2f8>
8000ad7c:	40 e5       	lddsp	r5,sp[0x38]
8000ad7e:	50 95       	stdsp	sp[0x24],r5
8000ad80:	0a 91       	mov	r1,r5
8000ad82:	0a 98       	mov	r8,r5
8000ad84:	c1 08       	rjmp	8000ada4 <_dtoa_r+0x2f8>
8000ad86:	30 0c       	mov	r12,0
8000ad88:	50 dc       	stdsp	sp[0x34],r12
8000ad8a:	40 eb       	lddsp	r11,sp[0x38]
8000ad8c:	ec 0b 00 0b 	add	r11,r6,r11
8000ad90:	50 9b       	stdsp	sp[0x24],r11
8000ad92:	16 98       	mov	r8,r11
8000ad94:	2f f8       	sub	r8,-1
8000ad96:	58 08       	cp.w	r8,0
8000ad98:	e0 89 00 05 	brgt	8000ada2 <_dtoa_r+0x2f6>
8000ad9c:	10 91       	mov	r1,r8
8000ad9e:	30 18       	mov	r8,1
8000ada0:	c0 28       	rjmp	8000ada4 <_dtoa_r+0x2f8>
8000ada2:	10 91       	mov	r1,r8
8000ada4:	30 09       	mov	r9,0
8000ada6:	6e 9a       	ld.w	r10,r7[0x24]
8000ada8:	95 19       	st.w	r10[0x4],r9
8000adaa:	30 49       	mov	r9,4
8000adac:	c0 68       	rjmp	8000adb8 <_dtoa_r+0x30c>
8000adae:	d7 03       	nop
8000adb0:	6a 1a       	ld.w	r10,r5[0x4]
8000adb2:	a1 79       	lsl	r9,0x1
8000adb4:	2f fa       	sub	r10,-1
8000adb6:	8b 1a       	st.w	r5[0x4],r10
8000adb8:	6e 95       	ld.w	r5,r7[0x24]
8000adba:	f2 ca ff ec 	sub	r10,r9,-20
8000adbe:	10 3a       	cp.w	r10,r8
8000adc0:	fe 98 ff f8 	brls	8000adb0 <_dtoa_r+0x304>
8000adc4:	6a 1b       	ld.w	r11,r5[0x4]
8000adc6:	0e 9c       	mov	r12,r7
8000adc8:	e0 a0 09 44 	rcall	8000c050 <_Balloc>
8000adcc:	58 e1       	cp.w	r1,14
8000adce:	5f 88       	srls	r8
8000add0:	8b 0c       	st.w	r5[0x0],r12
8000add2:	f1 e4 00 04 	and	r4,r8,r4
8000add6:	6e 98       	ld.w	r8,r7[0x24]
8000add8:	70 08       	ld.w	r8,r8[0x0]
8000adda:	50 88       	stdsp	sp[0x20],r8
8000addc:	e0 80 01 82 	breq	8000b0e0 <_dtoa_r+0x634>
8000ade0:	58 06       	cp.w	r6,0
8000ade2:	e0 8a 00 43 	brle	8000ae68 <_dtoa_r+0x3bc>
8000ade6:	f3 d6 c0 04 	bfextu	r9,r6,0x0,0x4
8000adea:	fe c8 c2 ba 	sub	r8,pc,-15686
8000adee:	f0 09 02 34 	ld.d	r4,r8[r9<<0x3]
8000adf2:	fa e5 00 18 	st.d	sp[24],r4
8000adf6:	ec 04 14 04 	asr	r4,r6,0x4
8000adfa:	ed b4 00 04 	bld	r4,0x4
8000adfe:	c0 30       	breq	8000ae04 <_dtoa_r+0x358>
8000ae00:	30 25       	mov	r5,2
8000ae02:	c1 08       	rjmp	8000ae22 <_dtoa_r+0x376>
8000ae04:	fe c8 c2 0c 	sub	r8,pc,-15860
8000ae08:	f0 e8 00 20 	ld.d	r8,r8[32]
8000ae0c:	fa ea 00 3c 	ld.d	r10,sp[60]
8000ae10:	e9 d4 c0 04 	bfextu	r4,r4,0x0,0x4
8000ae14:	e0 a0 0f fa 	rcall	8000ce08 <__avr32_f64_div>
8000ae18:	30 35       	mov	r5,3
8000ae1a:	14 98       	mov	r8,r10
8000ae1c:	16 99       	mov	r9,r11
8000ae1e:	fa e9 00 08 	st.d	sp[8],r8
8000ae22:	fe cc c2 2a 	sub	r12,pc,-15830
8000ae26:	50 a3       	stdsp	sp[0x28],r3
8000ae28:	0c 93       	mov	r3,r6
8000ae2a:	18 96       	mov	r6,r12
8000ae2c:	c0 f8       	rjmp	8000ae4a <_dtoa_r+0x39e>
8000ae2e:	fa ea 00 18 	ld.d	r10,sp[24]
8000ae32:	ed b4 00 00 	bld	r4,0x0
8000ae36:	c0 81       	brne	8000ae46 <_dtoa_r+0x39a>
8000ae38:	ec e8 00 00 	ld.d	r8,r6[0]
8000ae3c:	2f f5       	sub	r5,-1
8000ae3e:	e0 a0 0c 9f 	rcall	8000c77c <__avr32_f64_mul>
8000ae42:	fa eb 00 18 	st.d	sp[24],r10
8000ae46:	a1 54       	asr	r4,0x1
8000ae48:	2f 86       	sub	r6,-8
8000ae4a:	58 04       	cp.w	r4,0
8000ae4c:	cf 11       	brne	8000ae2e <_dtoa_r+0x382>
8000ae4e:	fa e8 00 18 	ld.d	r8,sp[24]
8000ae52:	fa ea 00 08 	ld.d	r10,sp[8]
8000ae56:	06 96       	mov	r6,r3
8000ae58:	e0 a0 0f d8 	rcall	8000ce08 <__avr32_f64_div>
8000ae5c:	40 a3       	lddsp	r3,sp[0x28]
8000ae5e:	14 98       	mov	r8,r10
8000ae60:	16 99       	mov	r9,r11
8000ae62:	fa e9 00 08 	st.d	sp[8],r8
8000ae66:	c2 f8       	rjmp	8000aec4 <_dtoa_r+0x418>
8000ae68:	ec 08 11 00 	rsub	r8,r6,0
8000ae6c:	c0 31       	brne	8000ae72 <_dtoa_r+0x3c6>
8000ae6e:	30 25       	mov	r5,2
8000ae70:	c2 a8       	rjmp	8000aec4 <_dtoa_r+0x418>
8000ae72:	fe cc c2 7a 	sub	r12,pc,-15750
8000ae76:	f0 04 14 04 	asr	r4,r8,0x4
8000ae7a:	50 1c       	stdsp	sp[0x4],r12
8000ae7c:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
8000ae80:	fe c9 c3 50 	sub	r9,pc,-15536
8000ae84:	fa ea 00 3c 	ld.d	r10,sp[60]
8000ae88:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000ae8c:	e0 a0 0c 78 	rcall	8000c77c <__avr32_f64_mul>
8000ae90:	40 1c       	lddsp	r12,sp[0x4]
8000ae92:	50 63       	stdsp	sp[0x18],r3
8000ae94:	30 25       	mov	r5,2
8000ae96:	0c 93       	mov	r3,r6
8000ae98:	fa eb 00 08 	st.d	sp[8],r10
8000ae9c:	18 96       	mov	r6,r12
8000ae9e:	c0 f8       	rjmp	8000aebc <_dtoa_r+0x410>
8000aea0:	fa ea 00 08 	ld.d	r10,sp[8]
8000aea4:	ed b4 00 00 	bld	r4,0x0
8000aea8:	c0 81       	brne	8000aeb8 <_dtoa_r+0x40c>
8000aeaa:	ec e8 00 00 	ld.d	r8,r6[0]
8000aeae:	2f f5       	sub	r5,-1
8000aeb0:	e0 a0 0c 66 	rcall	8000c77c <__avr32_f64_mul>
8000aeb4:	fa eb 00 08 	st.d	sp[8],r10
8000aeb8:	a1 54       	asr	r4,0x1
8000aeba:	2f 86       	sub	r6,-8
8000aebc:	58 04       	cp.w	r4,0
8000aebe:	cf 11       	brne	8000aea0 <_dtoa_r+0x3f4>
8000aec0:	06 96       	mov	r6,r3
8000aec2:	40 63       	lddsp	r3,sp[0x18]
8000aec4:	41 4a       	lddsp	r10,sp[0x50]
8000aec6:	58 0a       	cp.w	r10,0
8000aec8:	c2 a0       	breq	8000af1c <_dtoa_r+0x470>
8000aeca:	fa e8 00 08 	ld.d	r8,sp[8]
8000aece:	58 01       	cp.w	r1,0
8000aed0:	5f 94       	srgt	r4
8000aed2:	fa e9 00 18 	st.d	sp[24],r8
8000aed6:	30 08       	mov	r8,0
8000aed8:	fc 19 3f f0 	movh	r9,0x3ff0
8000aedc:	fa ea 00 18 	ld.d	r10,sp[24]
8000aee0:	e0 a0 0f 60 	rcall	8000cda0 <__avr32_f64_cmp_lt>
8000aee4:	f9 bc 00 00 	moveq	r12,0
8000aee8:	f9 bc 01 01 	movne	r12,1
8000aeec:	e9 ec 00 0c 	and	r12,r4,r12
8000aef0:	c1 60       	breq	8000af1c <_dtoa_r+0x470>
8000aef2:	40 98       	lddsp	r8,sp[0x24]
8000aef4:	58 08       	cp.w	r8,0
8000aef6:	e0 8a 00 f1 	brle	8000b0d8 <_dtoa_r+0x62c>
8000aefa:	30 08       	mov	r8,0
8000aefc:	fc 19 40 24 	movh	r9,0x4024
8000af00:	ec c4 00 01 	sub	r4,r6,1
8000af04:	fa ea 00 18 	ld.d	r10,sp[24]
8000af08:	2f f5       	sub	r5,-1
8000af0a:	50 64       	stdsp	sp[0x18],r4
8000af0c:	e0 a0 0c 38 	rcall	8000c77c <__avr32_f64_mul>
8000af10:	40 94       	lddsp	r4,sp[0x24]
8000af12:	14 98       	mov	r8,r10
8000af14:	16 99       	mov	r9,r11
8000af16:	fa e9 00 08 	st.d	sp[8],r8
8000af1a:	c0 38       	rjmp	8000af20 <_dtoa_r+0x474>
8000af1c:	50 66       	stdsp	sp[0x18],r6
8000af1e:	02 94       	mov	r4,r1
8000af20:	0a 9c       	mov	r12,r5
8000af22:	e0 a0 0e 88 	rcall	8000cc32 <__avr32_s32_to_f64>
8000af26:	fa e8 00 08 	ld.d	r8,sp[8]
8000af2a:	e0 a0 0c 29 	rcall	8000c77c <__avr32_f64_mul>
8000af2e:	30 08       	mov	r8,0
8000af30:	fc 19 40 1c 	movh	r9,0x401c
8000af34:	e0 a0 0d de 	rcall	8000caf0 <__avr32_f64_add>
8000af38:	14 98       	mov	r8,r10
8000af3a:	16 99       	mov	r9,r11
8000af3c:	fa e9 00 28 	st.d	sp[40],r8
8000af40:	fc 18 fc c0 	movh	r8,0xfcc0
8000af44:	40 a5       	lddsp	r5,sp[0x28]
8000af46:	10 05       	add	r5,r8
8000af48:	50 a5       	stdsp	sp[0x28],r5
8000af4a:	58 04       	cp.w	r4,0
8000af4c:	c2 11       	brne	8000af8e <_dtoa_r+0x4e2>
8000af4e:	fa ea 00 08 	ld.d	r10,sp[8]
8000af52:	30 08       	mov	r8,0
8000af54:	fc 19 40 14 	movh	r9,0x4014
8000af58:	e0 a0 0c fe 	rcall	8000c954 <__avr32_f64_sub>
8000af5c:	40 bc       	lddsp	r12,sp[0x2c]
8000af5e:	fa eb 00 08 	st.d	sp[8],r10
8000af62:	14 98       	mov	r8,r10
8000af64:	16 99       	mov	r9,r11
8000af66:	18 9a       	mov	r10,r12
8000af68:	0a 9b       	mov	r11,r5
8000af6a:	e0 a0 0f 1b 	rcall	8000cda0 <__avr32_f64_cmp_lt>
8000af6e:	e0 81 02 54 	brne	8000b416 <_dtoa_r+0x96a>
8000af72:	0a 98       	mov	r8,r5
8000af74:	40 b9       	lddsp	r9,sp[0x2c]
8000af76:	ee 18 80 00 	eorh	r8,0x8000
8000af7a:	fa ea 00 08 	ld.d	r10,sp[8]
8000af7e:	10 95       	mov	r5,r8
8000af80:	12 98       	mov	r8,r9
8000af82:	0a 99       	mov	r9,r5
8000af84:	e0 a0 0f 0e 	rcall	8000cda0 <__avr32_f64_cmp_lt>
8000af88:	e0 81 02 3e 	brne	8000b404 <_dtoa_r+0x958>
8000af8c:	ca 68       	rjmp	8000b0d8 <_dtoa_r+0x62c>
8000af8e:	fe c9 c4 5e 	sub	r9,pc,-15266
8000af92:	e8 c8 00 01 	sub	r8,r4,1
8000af96:	40 d5       	lddsp	r5,sp[0x34]
8000af98:	58 05       	cp.w	r5,0
8000af9a:	c4 f0       	breq	8000b038 <_dtoa_r+0x58c>
8000af9c:	30 0c       	mov	r12,0
8000af9e:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000afa2:	51 3c       	stdsp	sp[0x4c],r12
8000afa4:	30 0a       	mov	r10,0
8000afa6:	fc 1b 3f e0 	movh	r11,0x3fe0
8000afaa:	e0 a0 0f 2f 	rcall	8000ce08 <__avr32_f64_div>
8000afae:	fa e8 00 28 	ld.d	r8,sp[40]
8000afb2:	40 85       	lddsp	r5,sp[0x20]
8000afb4:	e0 a0 0c d0 	rcall	8000c954 <__avr32_f64_sub>
8000afb8:	fa eb 00 28 	st.d	sp[40],r10
8000afbc:	fa ea 00 08 	ld.d	r10,sp[8]
8000afc0:	e0 a0 0e 22 	rcall	8000cc04 <__avr32_f64_to_s32>
8000afc4:	51 6c       	stdsp	sp[0x58],r12
8000afc6:	e0 a0 0e 36 	rcall	8000cc32 <__avr32_s32_to_f64>
8000afca:	14 98       	mov	r8,r10
8000afcc:	16 99       	mov	r9,r11
8000afce:	fa ea 00 08 	ld.d	r10,sp[8]
8000afd2:	e0 a0 0c c1 	rcall	8000c954 <__avr32_f64_sub>
8000afd6:	fa eb 00 08 	st.d	sp[8],r10
8000afda:	41 68       	lddsp	r8,sp[0x58]
8000afdc:	2d 08       	sub	r8,-48
8000afde:	0a c8       	st.b	r5++,r8
8000afe0:	41 39       	lddsp	r9,sp[0x4c]
8000afe2:	2f f9       	sub	r9,-1
8000afe4:	51 39       	stdsp	sp[0x4c],r9
8000afe6:	fa e8 00 28 	ld.d	r8,sp[40]
8000afea:	e0 a0 0e db 	rcall	8000cda0 <__avr32_f64_cmp_lt>
8000afee:	e0 81 03 39 	brne	8000b660 <_dtoa_r+0xbb4>
8000aff2:	fa e8 00 08 	ld.d	r8,sp[8]
8000aff6:	30 0a       	mov	r10,0
8000aff8:	fc 1b 3f f0 	movh	r11,0x3ff0
8000affc:	e0 a0 0c ac 	rcall	8000c954 <__avr32_f64_sub>
8000b000:	fa e8 00 28 	ld.d	r8,sp[40]
8000b004:	e0 a0 0e ce 	rcall	8000cda0 <__avr32_f64_cmp_lt>
8000b008:	fa ea 00 28 	ld.d	r10,sp[40]
8000b00c:	30 08       	mov	r8,0
8000b00e:	fc 19 40 24 	movh	r9,0x4024
8000b012:	e0 81 00 da 	brne	8000b1c6 <_dtoa_r+0x71a>
8000b016:	41 3c       	lddsp	r12,sp[0x4c]
8000b018:	08 3c       	cp.w	r12,r4
8000b01a:	c5 f4       	brge	8000b0d8 <_dtoa_r+0x62c>
8000b01c:	e0 a0 0b b0 	rcall	8000c77c <__avr32_f64_mul>
8000b020:	30 08       	mov	r8,0
8000b022:	fa eb 00 28 	st.d	sp[40],r10
8000b026:	fc 19 40 24 	movh	r9,0x4024
8000b02a:	fa ea 00 08 	ld.d	r10,sp[8]
8000b02e:	e0 a0 0b a7 	rcall	8000c77c <__avr32_f64_mul>
8000b032:	fa eb 00 08 	st.d	sp[8],r10
8000b036:	cc 3b       	rjmp	8000afbc <_dtoa_r+0x510>
8000b038:	40 85       	lddsp	r5,sp[0x20]
8000b03a:	08 05       	add	r5,r4
8000b03c:	f2 08 02 3a 	ld.d	r10,r9[r8<<0x3]
8000b040:	51 35       	stdsp	sp[0x4c],r5
8000b042:	fa e8 00 28 	ld.d	r8,sp[40]
8000b046:	40 85       	lddsp	r5,sp[0x20]
8000b048:	e0 a0 0b 9a 	rcall	8000c77c <__avr32_f64_mul>
8000b04c:	fa eb 00 28 	st.d	sp[40],r10
8000b050:	fa ea 00 08 	ld.d	r10,sp[8]
8000b054:	e0 a0 0d d8 	rcall	8000cc04 <__avr32_f64_to_s32>
8000b058:	51 6c       	stdsp	sp[0x58],r12
8000b05a:	e0 a0 0d ec 	rcall	8000cc32 <__avr32_s32_to_f64>
8000b05e:	14 98       	mov	r8,r10
8000b060:	16 99       	mov	r9,r11
8000b062:	fa ea 00 08 	ld.d	r10,sp[8]
8000b066:	e0 a0 0c 77 	rcall	8000c954 <__avr32_f64_sub>
8000b06a:	fa eb 00 08 	st.d	sp[8],r10
8000b06e:	41 68       	lddsp	r8,sp[0x58]
8000b070:	2d 08       	sub	r8,-48
8000b072:	0a c8       	st.b	r5++,r8
8000b074:	41 3c       	lddsp	r12,sp[0x4c]
8000b076:	18 35       	cp.w	r5,r12
8000b078:	c2 81       	brne	8000b0c8 <_dtoa_r+0x61c>
8000b07a:	30 08       	mov	r8,0
8000b07c:	fc 19 3f e0 	movh	r9,0x3fe0
8000b080:	fa ea 00 28 	ld.d	r10,sp[40]
8000b084:	e0 a0 0d 36 	rcall	8000caf0 <__avr32_f64_add>
8000b088:	40 85       	lddsp	r5,sp[0x20]
8000b08a:	fa e8 00 08 	ld.d	r8,sp[8]
8000b08e:	08 05       	add	r5,r4
8000b090:	e0 a0 0e 88 	rcall	8000cda0 <__avr32_f64_cmp_lt>
8000b094:	e0 81 00 99 	brne	8000b1c6 <_dtoa_r+0x71a>
8000b098:	fa e8 00 28 	ld.d	r8,sp[40]
8000b09c:	30 0a       	mov	r10,0
8000b09e:	fc 1b 3f e0 	movh	r11,0x3fe0
8000b0a2:	e0 a0 0c 59 	rcall	8000c954 <__avr32_f64_sub>
8000b0a6:	14 98       	mov	r8,r10
8000b0a8:	16 99       	mov	r9,r11
8000b0aa:	fa ea 00 08 	ld.d	r10,sp[8]
8000b0ae:	e0 a0 0e 79 	rcall	8000cda0 <__avr32_f64_cmp_lt>
8000b0b2:	c1 30       	breq	8000b0d8 <_dtoa_r+0x62c>
8000b0b4:	33 09       	mov	r9,48
8000b0b6:	0a 98       	mov	r8,r5
8000b0b8:	11 7a       	ld.ub	r10,--r8
8000b0ba:	f2 0a 18 00 	cp.b	r10,r9
8000b0be:	e0 81 02 d1 	brne	8000b660 <_dtoa_r+0xbb4>
8000b0c2:	10 95       	mov	r5,r8
8000b0c4:	cf 9b       	rjmp	8000b0b6 <_dtoa_r+0x60a>
8000b0c6:	d7 03       	nop
8000b0c8:	30 08       	mov	r8,0
8000b0ca:	fc 19 40 24 	movh	r9,0x4024
8000b0ce:	e0 a0 0b 57 	rcall	8000c77c <__avr32_f64_mul>
8000b0d2:	fa eb 00 08 	st.d	sp[8],r10
8000b0d6:	cb db       	rjmp	8000b050 <_dtoa_r+0x5a4>
8000b0d8:	fa ea 00 3c 	ld.d	r10,sp[60]
8000b0dc:	fa eb 00 08 	st.d	sp[8],r10
8000b0e0:	58 e6       	cp.w	r6,14
8000b0e2:	5f ab       	srle	r11
8000b0e4:	41 8a       	lddsp	r10,sp[0x60]
8000b0e6:	30 08       	mov	r8,0
8000b0e8:	f4 09 11 ff 	rsub	r9,r10,-1
8000b0ec:	f7 e9 03 f9 	and	r9,r11,r9>>0x1f
8000b0f0:	f0 09 18 00 	cp.b	r9,r8
8000b0f4:	e0 80 00 82 	breq	8000b1f8 <_dtoa_r+0x74c>
8000b0f8:	40 ea       	lddsp	r10,sp[0x38]
8000b0fa:	58 01       	cp.w	r1,0
8000b0fc:	5f a9       	srle	r9
8000b0fe:	f3 ea 03 f9 	and	r9,r9,r10>>0x1f
8000b102:	fe ca c5 d2 	sub	r10,pc,-14894
8000b106:	f4 06 02 34 	ld.d	r4,r10[r6<<0x3]
8000b10a:	fa e5 00 10 	st.d	sp[16],r4
8000b10e:	f0 09 18 00 	cp.b	r9,r8
8000b112:	c1 40       	breq	8000b13a <_dtoa_r+0x68e>
8000b114:	58 01       	cp.w	r1,0
8000b116:	e0 81 01 77 	brne	8000b404 <_dtoa_r+0x958>
8000b11a:	30 08       	mov	r8,0
8000b11c:	fc 19 40 14 	movh	r9,0x4014
8000b120:	08 9a       	mov	r10,r4
8000b122:	0a 9b       	mov	r11,r5
8000b124:	e0 a0 0b 2c 	rcall	8000c77c <__avr32_f64_mul>
8000b128:	fa e8 00 08 	ld.d	r8,sp[8]
8000b12c:	e0 a0 0e 06 	rcall	8000cd38 <__avr32_f64_cmp_ge>
8000b130:	e0 81 01 6a 	brne	8000b404 <_dtoa_r+0x958>
8000b134:	02 92       	mov	r2,r1
8000b136:	e0 8f 01 72 	bral	8000b41a <_dtoa_r+0x96e>
8000b13a:	40 85       	lddsp	r5,sp[0x20]
8000b13c:	30 14       	mov	r4,1
8000b13e:	fa e8 00 10 	ld.d	r8,sp[16]
8000b142:	fa ea 00 08 	ld.d	r10,sp[8]
8000b146:	e0 a0 0e 61 	rcall	8000ce08 <__avr32_f64_div>
8000b14a:	e0 a0 0d 5d 	rcall	8000cc04 <__avr32_f64_to_s32>
8000b14e:	18 92       	mov	r2,r12
8000b150:	e0 a0 0d 71 	rcall	8000cc32 <__avr32_s32_to_f64>
8000b154:	fa e8 00 10 	ld.d	r8,sp[16]
8000b158:	e0 a0 0b 12 	rcall	8000c77c <__avr32_f64_mul>
8000b15c:	14 98       	mov	r8,r10
8000b15e:	16 99       	mov	r9,r11
8000b160:	fa ea 00 08 	ld.d	r10,sp[8]
8000b164:	e0 a0 0b f8 	rcall	8000c954 <__avr32_f64_sub>
8000b168:	fa eb 00 08 	st.d	sp[8],r10
8000b16c:	e4 c8 ff d0 	sub	r8,r2,-48
8000b170:	0a c8       	st.b	r5++,r8
8000b172:	fc 19 40 24 	movh	r9,0x4024
8000b176:	30 08       	mov	r8,0
8000b178:	02 34       	cp.w	r4,r1
8000b17a:	c3 31       	brne	8000b1e0 <_dtoa_r+0x734>
8000b17c:	fa e8 00 08 	ld.d	r8,sp[8]
8000b180:	e0 a0 0c b8 	rcall	8000caf0 <__avr32_f64_add>
8000b184:	16 91       	mov	r1,r11
8000b186:	14 90       	mov	r0,r10
8000b188:	14 98       	mov	r8,r10
8000b18a:	02 99       	mov	r9,r1
8000b18c:	fa ea 00 10 	ld.d	r10,sp[16]
8000b190:	e0 a0 0e 08 	rcall	8000cda0 <__avr32_f64_cmp_lt>
8000b194:	c1 a1       	brne	8000b1c8 <_dtoa_r+0x71c>
8000b196:	fa e8 00 10 	ld.d	r8,sp[16]
8000b19a:	00 9a       	mov	r10,r0
8000b19c:	02 9b       	mov	r11,r1
8000b19e:	e0 a0 0d ba 	rcall	8000cd12 <__avr32_f64_cmp_eq>
8000b1a2:	e0 80 02 5e 	breq	8000b65e <_dtoa_r+0xbb2>
8000b1a6:	e5 d2 c0 01 	bfextu	r2,r2,0x0,0x1
8000b1aa:	c0 f1       	brne	8000b1c8 <_dtoa_r+0x71c>
8000b1ac:	e0 8f 02 59 	bral	8000b65e <_dtoa_r+0xbb2>
8000b1b0:	40 8a       	lddsp	r10,sp[0x20]
8000b1b2:	14 38       	cp.w	r8,r10
8000b1b4:	c0 30       	breq	8000b1ba <_dtoa_r+0x70e>
8000b1b6:	10 95       	mov	r5,r8
8000b1b8:	c0 98       	rjmp	8000b1ca <_dtoa_r+0x71e>
8000b1ba:	33 08       	mov	r8,48
8000b1bc:	40 89       	lddsp	r9,sp[0x20]
8000b1be:	2f f6       	sub	r6,-1
8000b1c0:	b2 88       	st.b	r9[0x0],r8
8000b1c2:	40 88       	lddsp	r8,sp[0x20]
8000b1c4:	c0 88       	rjmp	8000b1d4 <_dtoa_r+0x728>
8000b1c6:	40 66       	lddsp	r6,sp[0x18]
8000b1c8:	33 99       	mov	r9,57
8000b1ca:	0a 98       	mov	r8,r5
8000b1cc:	11 7a       	ld.ub	r10,--r8
8000b1ce:	f2 0a 18 00 	cp.b	r10,r9
8000b1d2:	ce f0       	breq	8000b1b0 <_dtoa_r+0x704>
8000b1d4:	50 66       	stdsp	sp[0x18],r6
8000b1d6:	11 89       	ld.ub	r9,r8[0x0]
8000b1d8:	2f f9       	sub	r9,-1
8000b1da:	b0 89       	st.b	r8[0x0],r9
8000b1dc:	e0 8f 02 42 	bral	8000b660 <_dtoa_r+0xbb4>
8000b1e0:	e0 a0 0a ce 	rcall	8000c77c <__avr32_f64_mul>
8000b1e4:	2f f4       	sub	r4,-1
8000b1e6:	fa eb 00 08 	st.d	sp[8],r10
8000b1ea:	30 08       	mov	r8,0
8000b1ec:	30 09       	mov	r9,0
8000b1ee:	e0 a0 0d 92 	rcall	8000cd12 <__avr32_f64_cmp_eq>
8000b1f2:	ca 60       	breq	8000b13e <_dtoa_r+0x692>
8000b1f4:	e0 8f 02 35 	bral	8000b65e <_dtoa_r+0xbb2>
8000b1f8:	40 d8       	lddsp	r8,sp[0x34]
8000b1fa:	58 08       	cp.w	r8,0
8000b1fc:	c0 51       	brne	8000b206 <_dtoa_r+0x75a>
8000b1fe:	04 98       	mov	r8,r2
8000b200:	00 95       	mov	r5,r0
8000b202:	40 d4       	lddsp	r4,sp[0x34]
8000b204:	c3 78       	rjmp	8000b272 <_dtoa_r+0x7c6>
8000b206:	40 c5       	lddsp	r5,sp[0x30]
8000b208:	58 15       	cp.w	r5,1
8000b20a:	e0 89 00 0f 	brgt	8000b228 <_dtoa_r+0x77c>
8000b20e:	41 74       	lddsp	r4,sp[0x5c]
8000b210:	58 04       	cp.w	r4,0
8000b212:	c0 40       	breq	8000b21a <_dtoa_r+0x76e>
8000b214:	f4 c9 fb cd 	sub	r9,r10,-1075
8000b218:	c0 48       	rjmp	8000b220 <_dtoa_r+0x774>
8000b21a:	41 99       	lddsp	r9,sp[0x64]
8000b21c:	f2 09 11 36 	rsub	r9,r9,54
8000b220:	04 98       	mov	r8,r2
8000b222:	00 95       	mov	r5,r0
8000b224:	c1 c8       	rjmp	8000b25c <_dtoa_r+0x7b0>
8000b226:	d7 03       	nop
8000b228:	e2 c8 00 01 	sub	r8,r1,1
8000b22c:	58 01       	cp.w	r1,0
8000b22e:	e0 05 17 40 	movge	r5,r0
8000b232:	e2 09 17 40 	movge	r9,r1
8000b236:	e1 d1 e5 15 	sublt	r5,r0,r1
8000b23a:	f9 b9 05 00 	movlt	r9,0
8000b23e:	10 32       	cp.w	r2,r8
8000b240:	e5 d8 e4 18 	subge	r8,r2,r8
8000b244:	f1 d2 e5 18 	sublt	r8,r8,r2
8000b248:	e5 d8 e5 02 	addlt	r2,r2,r8
8000b24c:	fb fc 50 11 	ld.wlt	r12,sp[0x44]
8000b250:	f9 d8 e5 0c 	addlt	r12,r12,r8
8000b254:	fb fc 5a 11 	st.wlt	sp[0x44],r12
8000b258:	f9 b8 05 00 	movlt	r8,0
8000b25c:	40 4b       	lddsp	r11,sp[0x10]
8000b25e:	12 0b       	add	r11,r9
8000b260:	50 08       	stdsp	sp[0x0],r8
8000b262:	50 4b       	stdsp	sp[0x10],r11
8000b264:	12 00       	add	r0,r9
8000b266:	30 1b       	mov	r11,1
8000b268:	0e 9c       	mov	r12,r7
8000b26a:	e0 a0 08 a7 	rcall	8000c3b8 <__i2b>
8000b26e:	40 08       	lddsp	r8,sp[0x0]
8000b270:	18 94       	mov	r4,r12
8000b272:	40 4a       	lddsp	r10,sp[0x10]
8000b274:	58 05       	cp.w	r5,0
8000b276:	5f 99       	srgt	r9
8000b278:	58 0a       	cp.w	r10,0
8000b27a:	5f 9a       	srgt	r10
8000b27c:	f5 e9 00 09 	and	r9,r10,r9
8000b280:	c0 80       	breq	8000b290 <_dtoa_r+0x7e4>
8000b282:	40 4c       	lddsp	r12,sp[0x10]
8000b284:	f8 05 0d 49 	min	r9,r12,r5
8000b288:	12 1c       	sub	r12,r9
8000b28a:	12 10       	sub	r0,r9
8000b28c:	50 4c       	stdsp	sp[0x10],r12
8000b28e:	12 15       	sub	r5,r9
8000b290:	58 02       	cp.w	r2,0
8000b292:	e0 8a 00 27 	brle	8000b2e0 <_dtoa_r+0x834>
8000b296:	40 db       	lddsp	r11,sp[0x34]
8000b298:	58 0b       	cp.w	r11,0
8000b29a:	c1 d0       	breq	8000b2d4 <_dtoa_r+0x828>
8000b29c:	58 08       	cp.w	r8,0
8000b29e:	e0 8a 00 17 	brle	8000b2cc <_dtoa_r+0x820>
8000b2a2:	10 9a       	mov	r10,r8
8000b2a4:	50 08       	stdsp	sp[0x0],r8
8000b2a6:	08 9b       	mov	r11,r4
8000b2a8:	0e 9c       	mov	r12,r7
8000b2aa:	e0 a0 08 cd 	rcall	8000c444 <__pow5mult>
8000b2ae:	06 9a       	mov	r10,r3
8000b2b0:	18 9b       	mov	r11,r12
8000b2b2:	18 94       	mov	r4,r12
8000b2b4:	0e 9c       	mov	r12,r7
8000b2b6:	e0 a0 08 01 	rcall	8000c2b8 <__multiply>
8000b2ba:	18 99       	mov	r9,r12
8000b2bc:	06 9b       	mov	r11,r3
8000b2be:	50 19       	stdsp	sp[0x4],r9
8000b2c0:	0e 9c       	mov	r12,r7
8000b2c2:	e0 a0 06 ad 	rcall	8000c01c <_Bfree>
8000b2c6:	40 19       	lddsp	r9,sp[0x4]
8000b2c8:	40 08       	lddsp	r8,sp[0x0]
8000b2ca:	12 93       	mov	r3,r9
8000b2cc:	e4 08 01 0a 	sub	r10,r2,r8
8000b2d0:	c0 80       	breq	8000b2e0 <_dtoa_r+0x834>
8000b2d2:	c0 28       	rjmp	8000b2d6 <_dtoa_r+0x82a>
8000b2d4:	04 9a       	mov	r10,r2
8000b2d6:	06 9b       	mov	r11,r3
8000b2d8:	0e 9c       	mov	r12,r7
8000b2da:	e0 a0 08 b5 	rcall	8000c444 <__pow5mult>
8000b2de:	18 93       	mov	r3,r12
8000b2e0:	30 1b       	mov	r11,1
8000b2e2:	0e 9c       	mov	r12,r7
8000b2e4:	e0 a0 08 6a 	rcall	8000c3b8 <__i2b>
8000b2e8:	41 1a       	lddsp	r10,sp[0x44]
8000b2ea:	18 92       	mov	r2,r12
8000b2ec:	58 0a       	cp.w	r10,0
8000b2ee:	e0 8a 00 07 	brle	8000b2fc <_dtoa_r+0x850>
8000b2f2:	18 9b       	mov	r11,r12
8000b2f4:	0e 9c       	mov	r12,r7
8000b2f6:	e0 a0 08 a7 	rcall	8000c444 <__pow5mult>
8000b2fa:	18 92       	mov	r2,r12
8000b2fc:	40 c9       	lddsp	r9,sp[0x30]
8000b2fe:	58 19       	cp.w	r9,1
8000b300:	e0 89 00 14 	brgt	8000b328 <_dtoa_r+0x87c>
8000b304:	40 38       	lddsp	r8,sp[0xc]
8000b306:	58 08       	cp.w	r8,0
8000b308:	c1 01       	brne	8000b328 <_dtoa_r+0x87c>
8000b30a:	40 29       	lddsp	r9,sp[0x8]
8000b30c:	f1 d9 c0 14 	bfextu	r8,r9,0x0,0x14
8000b310:	c0 c1       	brne	8000b328 <_dtoa_r+0x87c>
8000b312:	12 98       	mov	r8,r9
8000b314:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000b318:	c0 80       	breq	8000b328 <_dtoa_r+0x87c>
8000b31a:	40 4c       	lddsp	r12,sp[0x10]
8000b31c:	30 1b       	mov	r11,1
8000b31e:	2f fc       	sub	r12,-1
8000b320:	2f f0       	sub	r0,-1
8000b322:	50 4c       	stdsp	sp[0x10],r12
8000b324:	50 6b       	stdsp	sp[0x18],r11
8000b326:	c0 38       	rjmp	8000b32c <_dtoa_r+0x880>
8000b328:	30 0a       	mov	r10,0
8000b32a:	50 6a       	stdsp	sp[0x18],r10
8000b32c:	41 19       	lddsp	r9,sp[0x44]
8000b32e:	58 09       	cp.w	r9,0
8000b330:	c0 31       	brne	8000b336 <_dtoa_r+0x88a>
8000b332:	30 1c       	mov	r12,1
8000b334:	c0 98       	rjmp	8000b346 <_dtoa_r+0x89a>
8000b336:	64 48       	ld.w	r8,r2[0x10]
8000b338:	2f c8       	sub	r8,-4
8000b33a:	e4 08 03 2c 	ld.w	r12,r2[r8<<0x2]
8000b33e:	e0 a0 05 df 	rcall	8000befc <__hi0bits>
8000b342:	f8 0c 11 20 	rsub	r12,r12,32
8000b346:	40 4b       	lddsp	r11,sp[0x10]
8000b348:	f8 0b 00 08 	add	r8,r12,r11
8000b34c:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000b350:	c0 c0       	breq	8000b368 <_dtoa_r+0x8bc>
8000b352:	f0 08 11 20 	rsub	r8,r8,32
8000b356:	58 48       	cp.w	r8,4
8000b358:	e0 8a 00 06 	brle	8000b364 <_dtoa_r+0x8b8>
8000b35c:	20 48       	sub	r8,4
8000b35e:	10 0b       	add	r11,r8
8000b360:	50 4b       	stdsp	sp[0x10],r11
8000b362:	c0 78       	rjmp	8000b370 <_dtoa_r+0x8c4>
8000b364:	58 48       	cp.w	r8,4
8000b366:	c0 70       	breq	8000b374 <_dtoa_r+0x8c8>
8000b368:	40 4a       	lddsp	r10,sp[0x10]
8000b36a:	2e 48       	sub	r8,-28
8000b36c:	10 0a       	add	r10,r8
8000b36e:	50 4a       	stdsp	sp[0x10],r10
8000b370:	10 00       	add	r0,r8
8000b372:	10 05       	add	r5,r8
8000b374:	58 00       	cp.w	r0,0
8000b376:	e0 8a 00 08 	brle	8000b386 <_dtoa_r+0x8da>
8000b37a:	06 9b       	mov	r11,r3
8000b37c:	00 9a       	mov	r10,r0
8000b37e:	0e 9c       	mov	r12,r7
8000b380:	e0 a0 07 58 	rcall	8000c230 <__lshift>
8000b384:	18 93       	mov	r3,r12
8000b386:	40 49       	lddsp	r9,sp[0x10]
8000b388:	58 09       	cp.w	r9,0
8000b38a:	e0 8a 00 08 	brle	8000b39a <_dtoa_r+0x8ee>
8000b38e:	04 9b       	mov	r11,r2
8000b390:	12 9a       	mov	r10,r9
8000b392:	0e 9c       	mov	r12,r7
8000b394:	e0 a0 07 4e 	rcall	8000c230 <__lshift>
8000b398:	18 92       	mov	r2,r12
8000b39a:	41 48       	lddsp	r8,sp[0x50]
8000b39c:	58 08       	cp.w	r8,0
8000b39e:	c1 b0       	breq	8000b3d4 <_dtoa_r+0x928>
8000b3a0:	04 9b       	mov	r11,r2
8000b3a2:	06 9c       	mov	r12,r3
8000b3a4:	e0 a0 06 23 	rcall	8000bfea <__mcmp>
8000b3a8:	c1 64       	brge	8000b3d4 <_dtoa_r+0x928>
8000b3aa:	06 9b       	mov	r11,r3
8000b3ac:	30 09       	mov	r9,0
8000b3ae:	30 aa       	mov	r10,10
8000b3b0:	0e 9c       	mov	r12,r7
8000b3b2:	e0 a0 08 0b 	rcall	8000c3c8 <__multadd>
8000b3b6:	20 16       	sub	r6,1
8000b3b8:	18 93       	mov	r3,r12
8000b3ba:	40 dc       	lddsp	r12,sp[0x34]
8000b3bc:	58 0c       	cp.w	r12,0
8000b3be:	c0 31       	brne	8000b3c4 <_dtoa_r+0x918>
8000b3c0:	40 91       	lddsp	r1,sp[0x24]
8000b3c2:	c0 98       	rjmp	8000b3d4 <_dtoa_r+0x928>
8000b3c4:	08 9b       	mov	r11,r4
8000b3c6:	40 91       	lddsp	r1,sp[0x24]
8000b3c8:	30 09       	mov	r9,0
8000b3ca:	30 aa       	mov	r10,10
8000b3cc:	0e 9c       	mov	r12,r7
8000b3ce:	e0 a0 07 fd 	rcall	8000c3c8 <__multadd>
8000b3d2:	18 94       	mov	r4,r12
8000b3d4:	58 01       	cp.w	r1,0
8000b3d6:	5f a9       	srle	r9
8000b3d8:	40 cb       	lddsp	r11,sp[0x30]
8000b3da:	58 2b       	cp.w	r11,2
8000b3dc:	5f 98       	srgt	r8
8000b3de:	f3 e8 00 08 	and	r8,r9,r8
8000b3e2:	c2 50       	breq	8000b42c <_dtoa_r+0x980>
8000b3e4:	58 01       	cp.w	r1,0
8000b3e6:	c1 11       	brne	8000b408 <_dtoa_r+0x95c>
8000b3e8:	04 9b       	mov	r11,r2
8000b3ea:	02 99       	mov	r9,r1
8000b3ec:	30 5a       	mov	r10,5
8000b3ee:	0e 9c       	mov	r12,r7
8000b3f0:	e0 a0 07 ec 	rcall	8000c3c8 <__multadd>
8000b3f4:	18 92       	mov	r2,r12
8000b3f6:	18 9b       	mov	r11,r12
8000b3f8:	06 9c       	mov	r12,r3
8000b3fa:	e0 a0 05 f8 	rcall	8000bfea <__mcmp>
8000b3fe:	e0 89 00 0f 	brgt	8000b41c <_dtoa_r+0x970>
8000b402:	c0 38       	rjmp	8000b408 <_dtoa_r+0x95c>
8000b404:	30 02       	mov	r2,0
8000b406:	04 94       	mov	r4,r2
8000b408:	40 ea       	lddsp	r10,sp[0x38]
8000b40a:	30 09       	mov	r9,0
8000b40c:	5c da       	com	r10
8000b40e:	40 85       	lddsp	r5,sp[0x20]
8000b410:	50 6a       	stdsp	sp[0x18],r10
8000b412:	50 49       	stdsp	sp[0x10],r9
8000b414:	c0 f9       	rjmp	8000b632 <_dtoa_r+0xb86>
8000b416:	08 92       	mov	r2,r4
8000b418:	40 66       	lddsp	r6,sp[0x18]
8000b41a:	04 94       	mov	r4,r2
8000b41c:	2f f6       	sub	r6,-1
8000b41e:	50 66       	stdsp	sp[0x18],r6
8000b420:	33 18       	mov	r8,49
8000b422:	40 85       	lddsp	r5,sp[0x20]
8000b424:	0a c8       	st.b	r5++,r8
8000b426:	30 08       	mov	r8,0
8000b428:	50 48       	stdsp	sp[0x10],r8
8000b42a:	c0 49       	rjmp	8000b632 <_dtoa_r+0xb86>
8000b42c:	40 dc       	lddsp	r12,sp[0x34]
8000b42e:	58 0c       	cp.w	r12,0
8000b430:	e0 80 00 b5 	breq	8000b59a <_dtoa_r+0xaee>
8000b434:	58 05       	cp.w	r5,0
8000b436:	e0 8a 00 08 	brle	8000b446 <_dtoa_r+0x99a>
8000b43a:	08 9b       	mov	r11,r4
8000b43c:	0a 9a       	mov	r10,r5
8000b43e:	0e 9c       	mov	r12,r7
8000b440:	e0 a0 06 f8 	rcall	8000c230 <__lshift>
8000b444:	18 94       	mov	r4,r12
8000b446:	40 6b       	lddsp	r11,sp[0x18]
8000b448:	58 0b       	cp.w	r11,0
8000b44a:	c0 31       	brne	8000b450 <_dtoa_r+0x9a4>
8000b44c:	08 9c       	mov	r12,r4
8000b44e:	c1 38       	rjmp	8000b474 <_dtoa_r+0x9c8>
8000b450:	68 1b       	ld.w	r11,r4[0x4]
8000b452:	0e 9c       	mov	r12,r7
8000b454:	e0 a0 05 fe 	rcall	8000c050 <_Balloc>
8000b458:	68 4a       	ld.w	r10,r4[0x10]
8000b45a:	18 95       	mov	r5,r12
8000b45c:	e8 cb ff f4 	sub	r11,r4,-12
8000b460:	2f ea       	sub	r10,-2
8000b462:	2f 4c       	sub	r12,-12
8000b464:	a3 6a       	lsl	r10,0x2
8000b466:	fe b0 e6 50 	rcall	80008106 <memcpy>
8000b46a:	0a 9b       	mov	r11,r5
8000b46c:	30 1a       	mov	r10,1
8000b46e:	0e 9c       	mov	r12,r7
8000b470:	e0 a0 06 e0 	rcall	8000c230 <__lshift>
8000b474:	50 44       	stdsp	sp[0x10],r4
8000b476:	40 3a       	lddsp	r10,sp[0xc]
8000b478:	30 19       	mov	r9,1
8000b47a:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
8000b47e:	18 94       	mov	r4,r12
8000b480:	50 da       	stdsp	sp[0x34],r10
8000b482:	40 85       	lddsp	r5,sp[0x20]
8000b484:	50 99       	stdsp	sp[0x24],r9
8000b486:	50 26       	stdsp	sp[0x8],r6
8000b488:	50 e1       	stdsp	sp[0x38],r1
8000b48a:	04 9b       	mov	r11,r2
8000b48c:	06 9c       	mov	r12,r3
8000b48e:	fe b0 fa 7f 	rcall	8000a98c <quorem>
8000b492:	40 4b       	lddsp	r11,sp[0x10]
8000b494:	f8 c0 ff d0 	sub	r0,r12,-48
8000b498:	06 9c       	mov	r12,r3
8000b49a:	e0 a0 05 a8 	rcall	8000bfea <__mcmp>
8000b49e:	08 9a       	mov	r10,r4
8000b4a0:	50 6c       	stdsp	sp[0x18],r12
8000b4a2:	04 9b       	mov	r11,r2
8000b4a4:	0e 9c       	mov	r12,r7
8000b4a6:	e0 a0 06 5d 	rcall	8000c160 <__mdiff>
8000b4aa:	18 91       	mov	r1,r12
8000b4ac:	78 38       	ld.w	r8,r12[0xc]
8000b4ae:	58 08       	cp.w	r8,0
8000b4b0:	c0 30       	breq	8000b4b6 <_dtoa_r+0xa0a>
8000b4b2:	30 16       	mov	r6,1
8000b4b4:	c0 68       	rjmp	8000b4c0 <_dtoa_r+0xa14>
8000b4b6:	18 9b       	mov	r11,r12
8000b4b8:	06 9c       	mov	r12,r3
8000b4ba:	e0 a0 05 98 	rcall	8000bfea <__mcmp>
8000b4be:	18 96       	mov	r6,r12
8000b4c0:	0e 9c       	mov	r12,r7
8000b4c2:	02 9b       	mov	r11,r1
8000b4c4:	e0 a0 05 ac 	rcall	8000c01c <_Bfree>
8000b4c8:	40 cc       	lddsp	r12,sp[0x30]
8000b4ca:	ed ec 10 08 	or	r8,r6,r12
8000b4ce:	c0 d1       	brne	8000b4e8 <_dtoa_r+0xa3c>
8000b4d0:	40 db       	lddsp	r11,sp[0x34]
8000b4d2:	58 0b       	cp.w	r11,0
8000b4d4:	c0 a1       	brne	8000b4e8 <_dtoa_r+0xa3c>
8000b4d6:	40 26       	lddsp	r6,sp[0x8]
8000b4d8:	e0 40 00 39 	cp.w	r0,57
8000b4dc:	c3 00       	breq	8000b53c <_dtoa_r+0xa90>
8000b4de:	40 6a       	lddsp	r10,sp[0x18]
8000b4e0:	58 0a       	cp.w	r10,0
8000b4e2:	e0 89 00 24 	brgt	8000b52a <_dtoa_r+0xa7e>
8000b4e6:	c2 f8       	rjmp	8000b544 <_dtoa_r+0xa98>
8000b4e8:	40 69       	lddsp	r9,sp[0x18]
8000b4ea:	58 09       	cp.w	r9,0
8000b4ec:	c0 85       	brlt	8000b4fc <_dtoa_r+0xa50>
8000b4ee:	12 98       	mov	r8,r9
8000b4f0:	40 cc       	lddsp	r12,sp[0x30]
8000b4f2:	18 48       	or	r8,r12
8000b4f4:	c1 d1       	brne	8000b52e <_dtoa_r+0xa82>
8000b4f6:	40 db       	lddsp	r11,sp[0x34]
8000b4f8:	58 0b       	cp.w	r11,0
8000b4fa:	c1 a1       	brne	8000b52e <_dtoa_r+0xa82>
8000b4fc:	0c 99       	mov	r9,r6
8000b4fe:	40 26       	lddsp	r6,sp[0x8]
8000b500:	58 09       	cp.w	r9,0
8000b502:	e0 8a 00 21 	brle	8000b544 <_dtoa_r+0xa98>
8000b506:	06 9b       	mov	r11,r3
8000b508:	30 1a       	mov	r10,1
8000b50a:	0e 9c       	mov	r12,r7
8000b50c:	e0 a0 06 92 	rcall	8000c230 <__lshift>
8000b510:	04 9b       	mov	r11,r2
8000b512:	18 93       	mov	r3,r12
8000b514:	e0 a0 05 6b 	rcall	8000bfea <__mcmp>
8000b518:	e0 89 00 06 	brgt	8000b524 <_dtoa_r+0xa78>
8000b51c:	c1 41       	brne	8000b544 <_dtoa_r+0xa98>
8000b51e:	ed b0 00 00 	bld	r0,0x0
8000b522:	c1 11       	brne	8000b544 <_dtoa_r+0xa98>
8000b524:	e0 40 00 39 	cp.w	r0,57
8000b528:	c0 a0       	breq	8000b53c <_dtoa_r+0xa90>
8000b52a:	2f f0       	sub	r0,-1
8000b52c:	c0 c8       	rjmp	8000b544 <_dtoa_r+0xa98>
8000b52e:	58 06       	cp.w	r6,0
8000b530:	e0 8a 00 0c 	brle	8000b548 <_dtoa_r+0xa9c>
8000b534:	40 26       	lddsp	r6,sp[0x8]
8000b536:	e0 40 00 39 	cp.w	r0,57
8000b53a:	c0 41       	brne	8000b542 <_dtoa_r+0xa96>
8000b53c:	33 98       	mov	r8,57
8000b53e:	0a c8       	st.b	r5++,r8
8000b540:	c6 78       	rjmp	8000b60e <_dtoa_r+0xb62>
8000b542:	2f f0       	sub	r0,-1
8000b544:	0a c0       	st.b	r5++,r0
8000b546:	c7 58       	rjmp	8000b630 <_dtoa_r+0xb84>
8000b548:	0a c0       	st.b	r5++,r0
8000b54a:	40 9a       	lddsp	r10,sp[0x24]
8000b54c:	40 e9       	lddsp	r9,sp[0x38]
8000b54e:	12 3a       	cp.w	r10,r9
8000b550:	c4 30       	breq	8000b5d6 <_dtoa_r+0xb2a>
8000b552:	06 9b       	mov	r11,r3
8000b554:	30 09       	mov	r9,0
8000b556:	30 aa       	mov	r10,10
8000b558:	0e 9c       	mov	r12,r7
8000b55a:	e0 a0 07 37 	rcall	8000c3c8 <__multadd>
8000b55e:	40 48       	lddsp	r8,sp[0x10]
8000b560:	18 93       	mov	r3,r12
8000b562:	08 38       	cp.w	r8,r4
8000b564:	c0 91       	brne	8000b576 <_dtoa_r+0xaca>
8000b566:	10 9b       	mov	r11,r8
8000b568:	30 09       	mov	r9,0
8000b56a:	30 aa       	mov	r10,10
8000b56c:	0e 9c       	mov	r12,r7
8000b56e:	e0 a0 07 2d 	rcall	8000c3c8 <__multadd>
8000b572:	50 4c       	stdsp	sp[0x10],r12
8000b574:	c0 e8       	rjmp	8000b590 <_dtoa_r+0xae4>
8000b576:	40 4b       	lddsp	r11,sp[0x10]
8000b578:	30 09       	mov	r9,0
8000b57a:	30 aa       	mov	r10,10
8000b57c:	0e 9c       	mov	r12,r7
8000b57e:	e0 a0 07 25 	rcall	8000c3c8 <__multadd>
8000b582:	08 9b       	mov	r11,r4
8000b584:	50 4c       	stdsp	sp[0x10],r12
8000b586:	30 09       	mov	r9,0
8000b588:	30 aa       	mov	r10,10
8000b58a:	0e 9c       	mov	r12,r7
8000b58c:	e0 a0 07 1e 	rcall	8000c3c8 <__multadd>
8000b590:	18 94       	mov	r4,r12
8000b592:	40 9c       	lddsp	r12,sp[0x24]
8000b594:	2f fc       	sub	r12,-1
8000b596:	50 9c       	stdsp	sp[0x24],r12
8000b598:	c7 9b       	rjmp	8000b48a <_dtoa_r+0x9de>
8000b59a:	30 18       	mov	r8,1
8000b59c:	06 90       	mov	r0,r3
8000b59e:	40 85       	lddsp	r5,sp[0x20]
8000b5a0:	08 93       	mov	r3,r4
8000b5a2:	0c 94       	mov	r4,r6
8000b5a4:	10 96       	mov	r6,r8
8000b5a6:	04 9b       	mov	r11,r2
8000b5a8:	00 9c       	mov	r12,r0
8000b5aa:	fe b0 f9 f1 	rcall	8000a98c <quorem>
8000b5ae:	2d 0c       	sub	r12,-48
8000b5b0:	0a cc       	st.b	r5++,r12
8000b5b2:	02 36       	cp.w	r6,r1
8000b5b4:	c0 a4       	brge	8000b5c8 <_dtoa_r+0xb1c>
8000b5b6:	00 9b       	mov	r11,r0
8000b5b8:	30 09       	mov	r9,0
8000b5ba:	30 aa       	mov	r10,10
8000b5bc:	0e 9c       	mov	r12,r7
8000b5be:	2f f6       	sub	r6,-1
8000b5c0:	e0 a0 07 04 	rcall	8000c3c8 <__multadd>
8000b5c4:	18 90       	mov	r0,r12
8000b5c6:	cf 0b       	rjmp	8000b5a6 <_dtoa_r+0xafa>
8000b5c8:	08 96       	mov	r6,r4
8000b5ca:	30 0b       	mov	r11,0
8000b5cc:	06 94       	mov	r4,r3
8000b5ce:	50 4b       	stdsp	sp[0x10],r11
8000b5d0:	00 93       	mov	r3,r0
8000b5d2:	18 90       	mov	r0,r12
8000b5d4:	c0 28       	rjmp	8000b5d8 <_dtoa_r+0xb2c>
8000b5d6:	40 26       	lddsp	r6,sp[0x8]
8000b5d8:	06 9b       	mov	r11,r3
8000b5da:	30 1a       	mov	r10,1
8000b5dc:	0e 9c       	mov	r12,r7
8000b5de:	e0 a0 06 29 	rcall	8000c230 <__lshift>
8000b5e2:	04 9b       	mov	r11,r2
8000b5e4:	18 93       	mov	r3,r12
8000b5e6:	e0 a0 05 02 	rcall	8000bfea <__mcmp>
8000b5ea:	e0 89 00 12 	brgt	8000b60e <_dtoa_r+0xb62>
8000b5ee:	c1 b1       	brne	8000b624 <_dtoa_r+0xb78>
8000b5f0:	e1 d0 c0 01 	bfextu	r0,r0,0x0,0x1
8000b5f4:	c0 d1       	brne	8000b60e <_dtoa_r+0xb62>
8000b5f6:	c1 78       	rjmp	8000b624 <_dtoa_r+0xb78>
8000b5f8:	40 89       	lddsp	r9,sp[0x20]
8000b5fa:	12 38       	cp.w	r8,r9
8000b5fc:	c0 30       	breq	8000b602 <_dtoa_r+0xb56>
8000b5fe:	10 95       	mov	r5,r8
8000b600:	c0 88       	rjmp	8000b610 <_dtoa_r+0xb64>
8000b602:	2f f6       	sub	r6,-1
8000b604:	50 66       	stdsp	sp[0x18],r6
8000b606:	33 18       	mov	r8,49
8000b608:	40 8c       	lddsp	r12,sp[0x20]
8000b60a:	b8 88       	st.b	r12[0x0],r8
8000b60c:	c1 38       	rjmp	8000b632 <_dtoa_r+0xb86>
8000b60e:	33 9a       	mov	r10,57
8000b610:	0a 98       	mov	r8,r5
8000b612:	11 79       	ld.ub	r9,--r8
8000b614:	f4 09 18 00 	cp.b	r9,r10
8000b618:	cf 00       	breq	8000b5f8 <_dtoa_r+0xb4c>
8000b61a:	2f f9       	sub	r9,-1
8000b61c:	b0 89       	st.b	r8[0x0],r9
8000b61e:	c0 98       	rjmp	8000b630 <_dtoa_r+0xb84>
8000b620:	10 95       	mov	r5,r8
8000b622:	c0 28       	rjmp	8000b626 <_dtoa_r+0xb7a>
8000b624:	33 09       	mov	r9,48
8000b626:	0a 98       	mov	r8,r5
8000b628:	11 7a       	ld.ub	r10,--r8
8000b62a:	f2 0a 18 00 	cp.b	r10,r9
8000b62e:	cf 90       	breq	8000b620 <_dtoa_r+0xb74>
8000b630:	50 66       	stdsp	sp[0x18],r6
8000b632:	04 9b       	mov	r11,r2
8000b634:	0e 9c       	mov	r12,r7
8000b636:	e0 a0 04 f3 	rcall	8000c01c <_Bfree>
8000b63a:	58 04       	cp.w	r4,0
8000b63c:	c1 20       	breq	8000b660 <_dtoa_r+0xbb4>
8000b63e:	40 4b       	lddsp	r11,sp[0x10]
8000b640:	08 3b       	cp.w	r11,r4
8000b642:	5f 19       	srne	r9
8000b644:	58 0b       	cp.w	r11,0
8000b646:	5f 18       	srne	r8
8000b648:	f3 e8 00 08 	and	r8,r9,r8
8000b64c:	c0 40       	breq	8000b654 <_dtoa_r+0xba8>
8000b64e:	0e 9c       	mov	r12,r7
8000b650:	e0 a0 04 e6 	rcall	8000c01c <_Bfree>
8000b654:	08 9b       	mov	r11,r4
8000b656:	0e 9c       	mov	r12,r7
8000b658:	e0 a0 04 e2 	rcall	8000c01c <_Bfree>
8000b65c:	c0 28       	rjmp	8000b660 <_dtoa_r+0xbb4>
8000b65e:	50 66       	stdsp	sp[0x18],r6
8000b660:	0e 9c       	mov	r12,r7
8000b662:	06 9b       	mov	r11,r3
8000b664:	e0 a0 04 dc 	rcall	8000c01c <_Bfree>
8000b668:	30 08       	mov	r8,0
8000b66a:	aa 88       	st.b	r5[0x0],r8
8000b66c:	40 68       	lddsp	r8,sp[0x18]
8000b66e:	41 5a       	lddsp	r10,sp[0x54]
8000b670:	2f f8       	sub	r8,-1
8000b672:	41 29       	lddsp	r9,sp[0x48]
8000b674:	95 08       	st.w	r10[0x0],r8
8000b676:	40 8c       	lddsp	r12,sp[0x20]
8000b678:	58 09       	cp.w	r9,0
8000b67a:	fb f8 10 12 	ld.wne	r8,sp[0x48]
8000b67e:	f1 f5 1a 00 	st.wne	r8[0x0],r5
8000b682:	2e 6d       	sub	sp,-104
8000b684:	d8 32       	popm	r0-r7,pc
8000b686:	d7 03       	nop

8000b688 <__errno>:
8000b688:	e0 68 0a 4c 	mov	r8,2636
8000b68c:	70 0c       	ld.w	r12,r8[0x0]
8000b68e:	2f 4c       	sub	r12,-12
8000b690:	5e fc       	retal	r12
8000b692:	d7 03       	nop

8000b694 <_fflush_r>:
8000b694:	d4 21       	pushm	r4-r7,lr
8000b696:	16 97       	mov	r7,r11
8000b698:	18 96       	mov	r6,r12
8000b69a:	76 48       	ld.w	r8,r11[0x10]
8000b69c:	58 08       	cp.w	r8,0
8000b69e:	c7 f0       	breq	8000b79c <_fflush_r+0x108>
8000b6a0:	58 0c       	cp.w	r12,0
8000b6a2:	c0 50       	breq	8000b6ac <_fflush_r+0x18>
8000b6a4:	78 68       	ld.w	r8,r12[0x18]
8000b6a6:	58 08       	cp.w	r8,0
8000b6a8:	c0 21       	brne	8000b6ac <_fflush_r+0x18>
8000b6aa:	cc dc       	rcall	8000b844 <__sinit>
8000b6ac:	fe c8 cc 2c 	sub	r8,pc,-13268
8000b6b0:	10 37       	cp.w	r7,r8
8000b6b2:	c0 31       	brne	8000b6b8 <_fflush_r+0x24>
8000b6b4:	6c 07       	ld.w	r7,r6[0x0]
8000b6b6:	c0 c8       	rjmp	8000b6ce <_fflush_r+0x3a>
8000b6b8:	fe c8 cc 18 	sub	r8,pc,-13288
8000b6bc:	10 37       	cp.w	r7,r8
8000b6be:	c0 31       	brne	8000b6c4 <_fflush_r+0x30>
8000b6c0:	6c 17       	ld.w	r7,r6[0x4]
8000b6c2:	c0 68       	rjmp	8000b6ce <_fflush_r+0x3a>
8000b6c4:	fe c8 cc 04 	sub	r8,pc,-13308
8000b6c8:	10 37       	cp.w	r7,r8
8000b6ca:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000b6ce:	8e 6a       	ld.sh	r10,r7[0xc]
8000b6d0:	14 98       	mov	r8,r10
8000b6d2:	ed ba 00 03 	bld	r10,0x3
8000b6d6:	c4 20       	breq	8000b75a <_fflush_r+0xc6>
8000b6d8:	ab ba       	sbr	r10,0xb
8000b6da:	ae 6a       	st.h	r7[0xc],r10
8000b6dc:	6e 18       	ld.w	r8,r7[0x4]
8000b6de:	58 08       	cp.w	r8,0
8000b6e0:	e0 89 00 06 	brgt	8000b6ec <_fflush_r+0x58>
8000b6e4:	6f 08       	ld.w	r8,r7[0x40]
8000b6e6:	58 08       	cp.w	r8,0
8000b6e8:	e0 8a 00 5a 	brle	8000b79c <_fflush_r+0x108>
8000b6ec:	6e b8       	ld.w	r8,r7[0x2c]
8000b6ee:	58 08       	cp.w	r8,0
8000b6f0:	c5 60       	breq	8000b79c <_fflush_r+0x108>
8000b6f2:	e2 1a 10 00 	andl	r10,0x1000,COH
8000b6f6:	c0 30       	breq	8000b6fc <_fflush_r+0x68>
8000b6f8:	6f 55       	ld.w	r5,r7[0x54]
8000b6fa:	c0 f8       	rjmp	8000b718 <_fflush_r+0x84>
8000b6fc:	30 19       	mov	r9,1
8000b6fe:	6e 8b       	ld.w	r11,r7[0x20]
8000b700:	0c 9c       	mov	r12,r6
8000b702:	5d 18       	icall	r8
8000b704:	18 95       	mov	r5,r12
8000b706:	5b fc       	cp.w	r12,-1
8000b708:	c0 81       	brne	8000b718 <_fflush_r+0x84>
8000b70a:	6c 38       	ld.w	r8,r6[0xc]
8000b70c:	59 d8       	cp.w	r8,29
8000b70e:	c4 70       	breq	8000b79c <_fflush_r+0x108>
8000b710:	8e 68       	ld.sh	r8,r7[0xc]
8000b712:	a7 a8       	sbr	r8,0x6
8000b714:	ae 68       	st.h	r7[0xc],r8
8000b716:	d8 22       	popm	r4-r7,pc
8000b718:	8e 68       	ld.sh	r8,r7[0xc]
8000b71a:	ed b8 00 02 	bld	r8,0x2
8000b71e:	c0 91       	brne	8000b730 <_fflush_r+0x9c>
8000b720:	6e 18       	ld.w	r8,r7[0x4]
8000b722:	10 15       	sub	r5,r8
8000b724:	6e d8       	ld.w	r8,r7[0x34]
8000b726:	58 08       	cp.w	r8,0
8000b728:	ef f8 10 10 	ld.wne	r8,r7[0x40]
8000b72c:	eb d8 e1 15 	subne	r5,r5,r8
8000b730:	6e b8       	ld.w	r8,r7[0x2c]
8000b732:	0c 9c       	mov	r12,r6
8000b734:	30 09       	mov	r9,0
8000b736:	0a 9a       	mov	r10,r5
8000b738:	6e 8b       	ld.w	r11,r7[0x20]
8000b73a:	5d 18       	icall	r8
8000b73c:	8e 68       	ld.sh	r8,r7[0xc]
8000b73e:	0a 3c       	cp.w	r12,r5
8000b740:	c2 61       	brne	8000b78c <_fflush_r+0xf8>
8000b742:	ab d8       	cbr	r8,0xb
8000b744:	30 0c       	mov	r12,0
8000b746:	6e 49       	ld.w	r9,r7[0x10]
8000b748:	ae 68       	st.h	r7[0xc],r8
8000b74a:	8f 1c       	st.w	r7[0x4],r12
8000b74c:	8f 09       	st.w	r7[0x0],r9
8000b74e:	ed b8 00 0c 	bld	r8,0xc
8000b752:	c2 51       	brne	8000b79c <_fflush_r+0x108>
8000b754:	ef 45 00 54 	st.w	r7[84],r5
8000b758:	d8 22       	popm	r4-r7,pc
8000b75a:	6e 45       	ld.w	r5,r7[0x10]
8000b75c:	58 05       	cp.w	r5,0
8000b75e:	c1 f0       	breq	8000b79c <_fflush_r+0x108>
8000b760:	6e 04       	ld.w	r4,r7[0x0]
8000b762:	f5 da c0 02 	bfextu	r10,r10,0x0,0x2
8000b766:	8f 05       	st.w	r7[0x0],r5
8000b768:	f9 b8 01 00 	movne	r8,0
8000b76c:	ef f8 00 05 	ld.weq	r8,r7[0x14]
8000b770:	0a 14       	sub	r4,r5
8000b772:	8f 28       	st.w	r7[0x8],r8
8000b774:	c1 18       	rjmp	8000b796 <_fflush_r+0x102>
8000b776:	08 99       	mov	r9,r4
8000b778:	0a 9a       	mov	r10,r5
8000b77a:	6e a8       	ld.w	r8,r7[0x28]
8000b77c:	6e 8b       	ld.w	r11,r7[0x20]
8000b77e:	0c 9c       	mov	r12,r6
8000b780:	5d 18       	icall	r8
8000b782:	18 14       	sub	r4,r12
8000b784:	58 0c       	cp.w	r12,0
8000b786:	e0 89 00 07 	brgt	8000b794 <_fflush_r+0x100>
8000b78a:	8e 68       	ld.sh	r8,r7[0xc]
8000b78c:	a7 a8       	sbr	r8,0x6
8000b78e:	3f fc       	mov	r12,-1
8000b790:	ae 68       	st.h	r7[0xc],r8
8000b792:	d8 22       	popm	r4-r7,pc
8000b794:	18 05       	add	r5,r12
8000b796:	58 04       	cp.w	r4,0
8000b798:	fe 99 ff ef 	brgt	8000b776 <_fflush_r+0xe2>
8000b79c:	d8 2a       	popm	r4-r7,pc,r12=0
8000b79e:	d7 03       	nop

8000b7a0 <__sfp_lock_acquire>:
8000b7a0:	5e fc       	retal	r12

8000b7a2 <__sfp_lock_release>:
8000b7a2:	5e fc       	retal	r12

8000b7a4 <_cleanup_r>:
8000b7a4:	d4 01       	pushm	lr
8000b7a6:	fe cb f0 ae 	sub	r11,pc,-3922
8000b7aa:	e0 a0 02 f7 	rcall	8000bd98 <_fwalk>
8000b7ae:	d8 02       	popm	pc

8000b7b0 <__sfmoreglue>:
8000b7b0:	d4 21       	pushm	r4-r7,lr
8000b7b2:	16 95       	mov	r5,r11
8000b7b4:	f6 06 10 5c 	mul	r6,r11,92
8000b7b8:	ec cb ff f4 	sub	r11,r6,-12
8000b7bc:	fe b0 e2 76 	rcall	80007ca8 <_malloc_r>
8000b7c0:	18 97       	mov	r7,r12
8000b7c2:	c0 90       	breq	8000b7d4 <__sfmoreglue+0x24>
8000b7c4:	99 15       	st.w	r12[0x4],r5
8000b7c6:	30 0b       	mov	r11,0
8000b7c8:	2f 4c       	sub	r12,-12
8000b7ca:	0c 9a       	mov	r10,r6
8000b7cc:	8f 2c       	st.w	r7[0x8],r12
8000b7ce:	8f 0b       	st.w	r7[0x0],r11
8000b7d0:	fe b0 e5 3f 	rcall	8000824e <memset>
8000b7d4:	0e 9c       	mov	r12,r7
8000b7d6:	d8 22       	popm	r4-r7,pc

8000b7d8 <__sfp>:
8000b7d8:	d4 21       	pushm	r4-r7,lr
8000b7da:	fe c8 cc f6 	sub	r8,pc,-13066
8000b7de:	18 96       	mov	r6,r12
8000b7e0:	70 07       	ld.w	r7,r8[0x0]
8000b7e2:	6e 68       	ld.w	r8,r7[0x18]
8000b7e4:	58 08       	cp.w	r8,0
8000b7e6:	c0 31       	brne	8000b7ec <__sfp+0x14>
8000b7e8:	0e 9c       	mov	r12,r7
8000b7ea:	c2 dc       	rcall	8000b844 <__sinit>
8000b7ec:	ee c7 ff 28 	sub	r7,r7,-216
8000b7f0:	30 05       	mov	r5,0
8000b7f2:	6e 2c       	ld.w	r12,r7[0x8]
8000b7f4:	6e 18       	ld.w	r8,r7[0x4]
8000b7f6:	c0 68       	rjmp	8000b802 <__sfp+0x2a>
8000b7f8:	98 69       	ld.sh	r9,r12[0xc]
8000b7fa:	ea 09 19 00 	cp.h	r9,r5
8000b7fe:	c1 10       	breq	8000b820 <__sfp+0x48>
8000b800:	2a 4c       	sub	r12,-92
8000b802:	20 18       	sub	r8,1
8000b804:	cf a7       	brpl	8000b7f8 <__sfp+0x20>
8000b806:	6e 08       	ld.w	r8,r7[0x0]
8000b808:	58 08       	cp.w	r8,0
8000b80a:	c0 61       	brne	8000b816 <__sfp+0x3e>
8000b80c:	30 4b       	mov	r11,4
8000b80e:	0c 9c       	mov	r12,r6
8000b810:	cd 0f       	rcall	8000b7b0 <__sfmoreglue>
8000b812:	8f 0c       	st.w	r7[0x0],r12
8000b814:	c0 30       	breq	8000b81a <__sfp+0x42>
8000b816:	6e 07       	ld.w	r7,r7[0x0]
8000b818:	ce db       	rjmp	8000b7f2 <__sfp+0x1a>
8000b81a:	30 c8       	mov	r8,12
8000b81c:	8d 38       	st.w	r6[0xc],r8
8000b81e:	d8 22       	popm	r4-r7,pc
8000b820:	30 08       	mov	r8,0
8000b822:	f9 48 00 4c 	st.w	r12[76],r8
8000b826:	99 08       	st.w	r12[0x0],r8
8000b828:	99 28       	st.w	r12[0x8],r8
8000b82a:	99 18       	st.w	r12[0x4],r8
8000b82c:	99 48       	st.w	r12[0x10],r8
8000b82e:	99 58       	st.w	r12[0x14],r8
8000b830:	99 68       	st.w	r12[0x18],r8
8000b832:	99 d8       	st.w	r12[0x34],r8
8000b834:	99 e8       	st.w	r12[0x38],r8
8000b836:	f9 48 00 48 	st.w	r12[72],r8
8000b83a:	3f f8       	mov	r8,-1
8000b83c:	b8 78       	st.h	r12[0xe],r8
8000b83e:	30 18       	mov	r8,1
8000b840:	b8 68       	st.h	r12[0xc],r8
8000b842:	d8 22       	popm	r4-r7,pc

8000b844 <__sinit>:
8000b844:	d4 21       	pushm	r4-r7,lr
8000b846:	18 96       	mov	r6,r12
8000b848:	78 67       	ld.w	r7,r12[0x18]
8000b84a:	58 07       	cp.w	r7,0
8000b84c:	c4 91       	brne	8000b8de <__sinit+0x9a>
8000b84e:	fe c8 00 aa 	sub	r8,pc,170
8000b852:	30 15       	mov	r5,1
8000b854:	99 a8       	st.w	r12[0x28],r8
8000b856:	f9 47 00 d8 	st.w	r12[216],r7
8000b85a:	f9 47 00 dc 	st.w	r12[220],r7
8000b85e:	f9 47 00 e0 	st.w	r12[224],r7
8000b862:	99 65       	st.w	r12[0x18],r5
8000b864:	cb af       	rcall	8000b7d8 <__sfp>
8000b866:	8d 0c       	st.w	r6[0x0],r12
8000b868:	0c 9c       	mov	r12,r6
8000b86a:	cb 7f       	rcall	8000b7d8 <__sfp>
8000b86c:	8d 1c       	st.w	r6[0x4],r12
8000b86e:	0c 9c       	mov	r12,r6
8000b870:	cb 4f       	rcall	8000b7d8 <__sfp>
8000b872:	6c 09       	ld.w	r9,r6[0x0]
8000b874:	30 48       	mov	r8,4
8000b876:	93 07       	st.w	r9[0x0],r7
8000b878:	b2 68       	st.h	r9[0xc],r8
8000b87a:	93 17       	st.w	r9[0x4],r7
8000b87c:	93 27       	st.w	r9[0x8],r7
8000b87e:	6c 18       	ld.w	r8,r6[0x4]
8000b880:	b2 77       	st.h	r9[0xe],r7
8000b882:	93 47       	st.w	r9[0x10],r7
8000b884:	93 57       	st.w	r9[0x14],r7
8000b886:	93 67       	st.w	r9[0x18],r7
8000b888:	93 89       	st.w	r9[0x20],r9
8000b88a:	91 07       	st.w	r8[0x0],r7
8000b88c:	91 17       	st.w	r8[0x4],r7
8000b88e:	91 27       	st.w	r8[0x8],r7
8000b890:	fe ce f3 24 	sub	lr,pc,-3292
8000b894:	fe cb f3 54 	sub	r11,pc,-3244
8000b898:	93 9e       	st.w	r9[0x24],lr
8000b89a:	93 ab       	st.w	r9[0x28],r11
8000b89c:	fe ca f3 7c 	sub	r10,pc,-3204
8000b8a0:	fe c4 f3 88 	sub	r4,pc,-3192
8000b8a4:	93 ba       	st.w	r9[0x2c],r10
8000b8a6:	93 c4       	st.w	r9[0x30],r4
8000b8a8:	30 99       	mov	r9,9
8000b8aa:	b0 69       	st.h	r8[0xc],r9
8000b8ac:	b0 75       	st.h	r8[0xe],r5
8000b8ae:	91 c4       	st.w	r8[0x30],r4
8000b8b0:	91 47       	st.w	r8[0x10],r7
8000b8b2:	91 57       	st.w	r8[0x14],r7
8000b8b4:	91 67       	st.w	r8[0x18],r7
8000b8b6:	91 88       	st.w	r8[0x20],r8
8000b8b8:	91 9e       	st.w	r8[0x24],lr
8000b8ba:	91 ab       	st.w	r8[0x28],r11
8000b8bc:	91 ba       	st.w	r8[0x2c],r10
8000b8be:	8d 2c       	st.w	r6[0x8],r12
8000b8c0:	31 28       	mov	r8,18
8000b8c2:	99 07       	st.w	r12[0x0],r7
8000b8c4:	b8 68       	st.h	r12[0xc],r8
8000b8c6:	99 17       	st.w	r12[0x4],r7
8000b8c8:	99 27       	st.w	r12[0x8],r7
8000b8ca:	30 28       	mov	r8,2
8000b8cc:	b8 78       	st.h	r12[0xe],r8
8000b8ce:	99 c4       	st.w	r12[0x30],r4
8000b8d0:	99 67       	st.w	r12[0x18],r7
8000b8d2:	99 9e       	st.w	r12[0x24],lr
8000b8d4:	99 ab       	st.w	r12[0x28],r11
8000b8d6:	99 ba       	st.w	r12[0x2c],r10
8000b8d8:	99 47       	st.w	r12[0x10],r7
8000b8da:	99 57       	st.w	r12[0x14],r7
8000b8dc:	99 8c       	st.w	r12[0x20],r12
8000b8de:	d8 22       	popm	r4-r7,pc

8000b8e0 <_malloc_trim_r>:
8000b8e0:	d4 21       	pushm	r4-r7,lr
8000b8e2:	16 95       	mov	r5,r11
8000b8e4:	18 97       	mov	r7,r12
8000b8e6:	fe b0 d7 97 	rcall	80006814 <__malloc_lock>
8000b8ea:	e0 64 05 4c 	mov	r4,1356
8000b8ee:	68 28       	ld.w	r8,r4[0x8]
8000b8f0:	70 16       	ld.w	r6,r8[0x4]
8000b8f2:	e0 16 ff fc 	andl	r6,0xfffc
8000b8f6:	ec c8 ff 91 	sub	r8,r6,-111
8000b8fa:	f0 05 01 05 	sub	r5,r8,r5
8000b8fe:	e0 15 ff 80 	andl	r5,0xff80
8000b902:	ea c5 00 80 	sub	r5,r5,128
8000b906:	e0 45 00 7f 	cp.w	r5,127
8000b90a:	e0 8a 00 25 	brle	8000b954 <_malloc_trim_r+0x74>
8000b90e:	30 0b       	mov	r11,0
8000b910:	0e 9c       	mov	r12,r7
8000b912:	fe b0 e6 05 	rcall	8000851c <_sbrk_r>
8000b916:	68 28       	ld.w	r8,r4[0x8]
8000b918:	0c 08       	add	r8,r6
8000b91a:	10 3c       	cp.w	r12,r8
8000b91c:	c1 c1       	brne	8000b954 <_malloc_trim_r+0x74>
8000b91e:	ea 0b 11 00 	rsub	r11,r5,0
8000b922:	0e 9c       	mov	r12,r7
8000b924:	fe b0 e5 fc 	rcall	8000851c <_sbrk_r>
8000b928:	5b fc       	cp.w	r12,-1
8000b92a:	c1 91       	brne	8000b95c <_malloc_trim_r+0x7c>
8000b92c:	30 0b       	mov	r11,0
8000b92e:	0e 9c       	mov	r12,r7
8000b930:	fe b0 e5 f6 	rcall	8000851c <_sbrk_r>
8000b934:	68 28       	ld.w	r8,r4[0x8]
8000b936:	f8 08 01 09 	sub	r9,r12,r8
8000b93a:	58 f9       	cp.w	r9,15
8000b93c:	e0 8a 00 0c 	brle	8000b954 <_malloc_trim_r+0x74>
8000b940:	a1 a9       	sbr	r9,0x0
8000b942:	91 19       	st.w	r8[0x4],r9
8000b944:	e0 68 09 58 	mov	r8,2392
8000b948:	70 09       	ld.w	r9,r8[0x0]
8000b94a:	e0 68 0d d8 	mov	r8,3544
8000b94e:	f8 09 01 09 	sub	r9,r12,r9
8000b952:	91 09       	st.w	r8[0x0],r9
8000b954:	0e 9c       	mov	r12,r7
8000b956:	fe b0 d7 65 	rcall	80006820 <__malloc_unlock>
8000b95a:	d8 2a       	popm	r4-r7,pc,r12=0
8000b95c:	68 28       	ld.w	r8,r4[0x8]
8000b95e:	0a 16       	sub	r6,r5
8000b960:	a1 a6       	sbr	r6,0x0
8000b962:	91 16       	st.w	r8[0x4],r6
8000b964:	e0 68 0d d8 	mov	r8,3544
8000b968:	70 09       	ld.w	r9,r8[0x0]
8000b96a:	0a 19       	sub	r9,r5
8000b96c:	0e 9c       	mov	r12,r7
8000b96e:	91 09       	st.w	r8[0x0],r9
8000b970:	fe b0 d7 58 	rcall	80006820 <__malloc_unlock>
8000b974:	da 2a       	popm	r4-r7,pc,r12=1
8000b976:	d7 03       	nop

8000b978 <_free_r>:
8000b978:	d4 21       	pushm	r4-r7,lr
8000b97a:	16 96       	mov	r6,r11
8000b97c:	18 97       	mov	r7,r12
8000b97e:	58 0b       	cp.w	r11,0
8000b980:	e0 80 00 c0 	breq	8000bb00 <_free_r+0x188>
8000b984:	fe b0 d7 48 	rcall	80006814 <__malloc_lock>
8000b988:	20 86       	sub	r6,8
8000b98a:	e0 6a 05 4c 	mov	r10,1356
8000b98e:	6c 18       	ld.w	r8,r6[0x4]
8000b990:	74 2e       	ld.w	lr,r10[0x8]
8000b992:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
8000b996:	a1 c8       	cbr	r8,0x0
8000b998:	ec 08 00 09 	add	r9,r6,r8
8000b99c:	72 1b       	ld.w	r11,r9[0x4]
8000b99e:	e0 1b ff fc 	andl	r11,0xfffc
8000b9a2:	1c 39       	cp.w	r9,lr
8000b9a4:	c1 e1       	brne	8000b9e0 <_free_r+0x68>
8000b9a6:	f6 08 00 08 	add	r8,r11,r8
8000b9aa:	58 0c       	cp.w	r12,0
8000b9ac:	c0 81       	brne	8000b9bc <_free_r+0x44>
8000b9ae:	6c 09       	ld.w	r9,r6[0x0]
8000b9b0:	12 16       	sub	r6,r9
8000b9b2:	12 08       	add	r8,r9
8000b9b4:	6c 3b       	ld.w	r11,r6[0xc]
8000b9b6:	6c 29       	ld.w	r9,r6[0x8]
8000b9b8:	97 29       	st.w	r11[0x8],r9
8000b9ba:	93 3b       	st.w	r9[0xc],r11
8000b9bc:	10 99       	mov	r9,r8
8000b9be:	95 26       	st.w	r10[0x8],r6
8000b9c0:	a1 a9       	sbr	r9,0x0
8000b9c2:	8d 19       	st.w	r6[0x4],r9
8000b9c4:	e0 69 09 54 	mov	r9,2388
8000b9c8:	72 09       	ld.w	r9,r9[0x0]
8000b9ca:	12 38       	cp.w	r8,r9
8000b9cc:	c0 63       	brcs	8000b9d8 <_free_r+0x60>
8000b9ce:	e0 68 0d d4 	mov	r8,3540
8000b9d2:	0e 9c       	mov	r12,r7
8000b9d4:	70 0b       	ld.w	r11,r8[0x0]
8000b9d6:	c8 5f       	rcall	8000b8e0 <_malloc_trim_r>
8000b9d8:	0e 9c       	mov	r12,r7
8000b9da:	fe b0 d7 23 	rcall	80006820 <__malloc_unlock>
8000b9de:	d8 22       	popm	r4-r7,pc
8000b9e0:	93 1b       	st.w	r9[0x4],r11
8000b9e2:	58 0c       	cp.w	r12,0
8000b9e4:	c0 30       	breq	8000b9ea <_free_r+0x72>
8000b9e6:	30 0c       	mov	r12,0
8000b9e8:	c1 08       	rjmp	8000ba08 <_free_r+0x90>
8000b9ea:	6c 0e       	ld.w	lr,r6[0x0]
8000b9ec:	f4 c5 ff f8 	sub	r5,r10,-8
8000b9f0:	1c 16       	sub	r6,lr
8000b9f2:	1c 08       	add	r8,lr
8000b9f4:	6c 2e       	ld.w	lr,r6[0x8]
8000b9f6:	0a 3e       	cp.w	lr,r5
8000b9f8:	f9 bc 00 01 	moveq	r12,1
8000b9fc:	ed f5 10 03 	ld.wne	r5,r6[0xc]
8000ba00:	eb fe 1a 02 	st.wne	r5[0x8],lr
8000ba04:	fd f5 1a 03 	st.wne	lr[0xc],r5
8000ba08:	f2 0b 00 0e 	add	lr,r9,r11
8000ba0c:	7c 1e       	ld.w	lr,lr[0x4]
8000ba0e:	ed be 00 00 	bld	lr,0x0
8000ba12:	c1 40       	breq	8000ba3a <_free_r+0xc2>
8000ba14:	16 08       	add	r8,r11
8000ba16:	58 0c       	cp.w	r12,0
8000ba18:	c0 d1       	brne	8000ba32 <_free_r+0xba>
8000ba1a:	e0 6e 05 4c 	mov	lr,1356
8000ba1e:	72 2b       	ld.w	r11,r9[0x8]
8000ba20:	2f 8e       	sub	lr,-8
8000ba22:	1c 3b       	cp.w	r11,lr
8000ba24:	c0 71       	brne	8000ba32 <_free_r+0xba>
8000ba26:	97 36       	st.w	r11[0xc],r6
8000ba28:	97 26       	st.w	r11[0x8],r6
8000ba2a:	8d 2b       	st.w	r6[0x8],r11
8000ba2c:	8d 3b       	st.w	r6[0xc],r11
8000ba2e:	30 1c       	mov	r12,1
8000ba30:	c0 58       	rjmp	8000ba3a <_free_r+0xc2>
8000ba32:	72 2b       	ld.w	r11,r9[0x8]
8000ba34:	72 39       	ld.w	r9,r9[0xc]
8000ba36:	93 2b       	st.w	r9[0x8],r11
8000ba38:	97 39       	st.w	r11[0xc],r9
8000ba3a:	10 99       	mov	r9,r8
8000ba3c:	ec 08 09 08 	st.w	r6[r8],r8
8000ba40:	a1 a9       	sbr	r9,0x0
8000ba42:	8d 19       	st.w	r6[0x4],r9
8000ba44:	58 0c       	cp.w	r12,0
8000ba46:	c5 a1       	brne	8000bafa <_free_r+0x182>
8000ba48:	e0 48 01 ff 	cp.w	r8,511
8000ba4c:	e0 8b 00 13 	brhi	8000ba72 <_free_r+0xfa>
8000ba50:	a3 98       	lsr	r8,0x3
8000ba52:	f4 08 00 39 	add	r9,r10,r8<<0x3
8000ba56:	72 2b       	ld.w	r11,r9[0x8]
8000ba58:	8d 39       	st.w	r6[0xc],r9
8000ba5a:	8d 2b       	st.w	r6[0x8],r11
8000ba5c:	97 36       	st.w	r11[0xc],r6
8000ba5e:	93 26       	st.w	r9[0x8],r6
8000ba60:	a3 48       	asr	r8,0x2
8000ba62:	74 19       	ld.w	r9,r10[0x4]
8000ba64:	30 1b       	mov	r11,1
8000ba66:	f6 08 09 48 	lsl	r8,r11,r8
8000ba6a:	f3 e8 10 08 	or	r8,r9,r8
8000ba6e:	95 18       	st.w	r10[0x4],r8
8000ba70:	c4 58       	rjmp	8000bafa <_free_r+0x182>
8000ba72:	f0 0b 16 09 	lsr	r11,r8,0x9
8000ba76:	58 4b       	cp.w	r11,4
8000ba78:	e0 8b 00 06 	brhi	8000ba84 <_free_r+0x10c>
8000ba7c:	f0 0b 16 06 	lsr	r11,r8,0x6
8000ba80:	2c 8b       	sub	r11,-56
8000ba82:	c2 08       	rjmp	8000bac2 <_free_r+0x14a>
8000ba84:	59 4b       	cp.w	r11,20
8000ba86:	e0 8b 00 04 	brhi	8000ba8e <_free_r+0x116>
8000ba8a:	2a 5b       	sub	r11,-91
8000ba8c:	c1 b8       	rjmp	8000bac2 <_free_r+0x14a>
8000ba8e:	e0 4b 00 54 	cp.w	r11,84
8000ba92:	e0 8b 00 06 	brhi	8000ba9e <_free_r+0x126>
8000ba96:	f0 0b 16 0c 	lsr	r11,r8,0xc
8000ba9a:	29 2b       	sub	r11,-110
8000ba9c:	c1 38       	rjmp	8000bac2 <_free_r+0x14a>
8000ba9e:	e0 4b 01 54 	cp.w	r11,340
8000baa2:	e0 8b 00 06 	brhi	8000baae <_free_r+0x136>
8000baa6:	f0 0b 16 0f 	lsr	r11,r8,0xf
8000baaa:	28 9b       	sub	r11,-119
8000baac:	c0 b8       	rjmp	8000bac2 <_free_r+0x14a>
8000baae:	e0 4b 05 54 	cp.w	r11,1364
8000bab2:	e0 88 00 05 	brls	8000babc <_free_r+0x144>
8000bab6:	37 eb       	mov	r11,126
8000bab8:	c0 58       	rjmp	8000bac2 <_free_r+0x14a>
8000baba:	d7 03       	nop
8000babc:	f0 0b 16 12 	lsr	r11,r8,0x12
8000bac0:	28 4b       	sub	r11,-124
8000bac2:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
8000bac6:	78 29       	ld.w	r9,r12[0x8]
8000bac8:	18 39       	cp.w	r9,r12
8000baca:	c0 e1       	brne	8000bae6 <_free_r+0x16e>
8000bacc:	74 18       	ld.w	r8,r10[0x4]
8000bace:	a3 4b       	asr	r11,0x2
8000bad0:	30 1c       	mov	r12,1
8000bad2:	f8 0b 09 4b 	lsl	r11,r12,r11
8000bad6:	f1 eb 10 0b 	or	r11,r8,r11
8000bada:	12 98       	mov	r8,r9
8000badc:	95 1b       	st.w	r10[0x4],r11
8000bade:	c0 a8       	rjmp	8000baf2 <_free_r+0x17a>
8000bae0:	72 29       	ld.w	r9,r9[0x8]
8000bae2:	18 39       	cp.w	r9,r12
8000bae4:	c0 60       	breq	8000baf0 <_free_r+0x178>
8000bae6:	72 1a       	ld.w	r10,r9[0x4]
8000bae8:	e0 1a ff fc 	andl	r10,0xfffc
8000baec:	14 38       	cp.w	r8,r10
8000baee:	cf 93       	brcs	8000bae0 <_free_r+0x168>
8000baf0:	72 38       	ld.w	r8,r9[0xc]
8000baf2:	8d 38       	st.w	r6[0xc],r8
8000baf4:	8d 29       	st.w	r6[0x8],r9
8000baf6:	93 36       	st.w	r9[0xc],r6
8000baf8:	91 26       	st.w	r8[0x8],r6
8000bafa:	0e 9c       	mov	r12,r7
8000bafc:	fe b0 d6 92 	rcall	80006820 <__malloc_unlock>
8000bb00:	d8 22       	popm	r4-r7,pc
8000bb02:	d7 03       	nop

8000bb04 <__sfvwrite_r>:
8000bb04:	d4 31       	pushm	r0-r7,lr
8000bb06:	20 3d       	sub	sp,12
8000bb08:	14 94       	mov	r4,r10
8000bb0a:	18 95       	mov	r5,r12
8000bb0c:	16 97       	mov	r7,r11
8000bb0e:	74 28       	ld.w	r8,r10[0x8]
8000bb10:	58 08       	cp.w	r8,0
8000bb12:	e0 80 01 40 	breq	8000bd92 <__sfvwrite_r+0x28e>
8000bb16:	96 68       	ld.sh	r8,r11[0xc]
8000bb18:	ed b8 00 03 	bld	r8,0x3
8000bb1c:	c0 41       	brne	8000bb24 <__sfvwrite_r+0x20>
8000bb1e:	76 48       	ld.w	r8,r11[0x10]
8000bb20:	58 08       	cp.w	r8,0
8000bb22:	c0 c1       	brne	8000bb3a <__sfvwrite_r+0x36>
8000bb24:	0e 9b       	mov	r11,r7
8000bb26:	0a 9c       	mov	r12,r5
8000bb28:	fe b0 f6 c4 	rcall	8000a8b0 <__swsetup_r>
8000bb2c:	c0 70       	breq	8000bb3a <__sfvwrite_r+0x36>
8000bb2e:	8e 68       	ld.sh	r8,r7[0xc]
8000bb30:	a7 a8       	sbr	r8,0x6
8000bb32:	ae 68       	st.h	r7[0xc],r8
8000bb34:	30 98       	mov	r8,9
8000bb36:	8b 38       	st.w	r5[0xc],r8
8000bb38:	c2 b9       	rjmp	8000bd8e <__sfvwrite_r+0x28a>
8000bb3a:	8e 63       	ld.sh	r3,r7[0xc]
8000bb3c:	68 00       	ld.w	r0,r4[0x0]
8000bb3e:	06 96       	mov	r6,r3
8000bb40:	e2 16 00 02 	andl	r6,0x2,COH
8000bb44:	c2 10       	breq	8000bb86 <__sfvwrite_r+0x82>
8000bb46:	30 03       	mov	r3,0
8000bb48:	e0 62 04 00 	mov	r2,1024
8000bb4c:	06 96       	mov	r6,r3
8000bb4e:	c0 48       	rjmp	8000bb56 <__sfvwrite_r+0x52>
8000bb50:	60 03       	ld.w	r3,r0[0x0]
8000bb52:	60 16       	ld.w	r6,r0[0x4]
8000bb54:	2f 80       	sub	r0,-8
8000bb56:	58 06       	cp.w	r6,0
8000bb58:	cf c0       	breq	8000bb50 <__sfvwrite_r+0x4c>
8000bb5a:	e0 46 04 00 	cp.w	r6,1024
8000bb5e:	ec 09 17 80 	movls	r9,r6
8000bb62:	e4 09 17 b0 	movhi	r9,r2
8000bb66:	06 9a       	mov	r10,r3
8000bb68:	6e a8       	ld.w	r8,r7[0x28]
8000bb6a:	6e 8b       	ld.w	r11,r7[0x20]
8000bb6c:	0a 9c       	mov	r12,r5
8000bb6e:	5d 18       	icall	r8
8000bb70:	18 16       	sub	r6,r12
8000bb72:	58 0c       	cp.w	r12,0
8000bb74:	e0 8a 01 0a 	brle	8000bd88 <__sfvwrite_r+0x284>
8000bb78:	68 28       	ld.w	r8,r4[0x8]
8000bb7a:	18 18       	sub	r8,r12
8000bb7c:	89 28       	st.w	r4[0x8],r8
8000bb7e:	e0 80 01 0a 	breq	8000bd92 <__sfvwrite_r+0x28e>
8000bb82:	18 03       	add	r3,r12
8000bb84:	ce 9b       	rjmp	8000bb56 <__sfvwrite_r+0x52>
8000bb86:	e7 d3 c0 01 	bfextu	r3,r3,0x0,0x1
8000bb8a:	c0 70       	breq	8000bb98 <__sfvwrite_r+0x94>
8000bb8c:	50 06       	stdsp	sp[0x0],r6
8000bb8e:	0c 93       	mov	r3,r6
8000bb90:	0c 91       	mov	r1,r6
8000bb92:	50 15       	stdsp	sp[0x4],r5
8000bb94:	08 92       	mov	r2,r4
8000bb96:	c9 c8       	rjmp	8000bcce <__sfvwrite_r+0x1ca>
8000bb98:	06 96       	mov	r6,r3
8000bb9a:	08 91       	mov	r1,r4
8000bb9c:	c0 48       	rjmp	8000bba4 <__sfvwrite_r+0xa0>
8000bb9e:	60 03       	ld.w	r3,r0[0x0]
8000bba0:	60 16       	ld.w	r6,r0[0x4]
8000bba2:	2f 80       	sub	r0,-8
8000bba4:	58 06       	cp.w	r6,0
8000bba6:	cf c0       	breq	8000bb9e <__sfvwrite_r+0x9a>
8000bba8:	8e 68       	ld.sh	r8,r7[0xc]
8000bbaa:	6e 24       	ld.w	r4,r7[0x8]
8000bbac:	10 99       	mov	r9,r8
8000bbae:	e2 19 02 00 	andl	r9,0x200,COH
8000bbb2:	c5 50       	breq	8000bc5c <__sfvwrite_r+0x158>
8000bbb4:	08 36       	cp.w	r6,r4
8000bbb6:	c4 43       	brcs	8000bc3e <__sfvwrite_r+0x13a>
8000bbb8:	10 99       	mov	r9,r8
8000bbba:	e2 19 04 80 	andl	r9,0x480,COH
8000bbbe:	c4 00       	breq	8000bc3e <__sfvwrite_r+0x13a>
8000bbc0:	6e 4b       	ld.w	r11,r7[0x10]
8000bbc2:	6e 09       	ld.w	r9,r7[0x0]
8000bbc4:	16 19       	sub	r9,r11
8000bbc6:	50 09       	stdsp	sp[0x0],r9
8000bbc8:	6e 59       	ld.w	r9,r7[0x14]
8000bbca:	10 9c       	mov	r12,r8
8000bbcc:	f2 09 00 1a 	add	r10,r9,r9<<0x1
8000bbd0:	30 28       	mov	r8,2
8000bbd2:	f4 08 0c 08 	divs	r8,r10,r8
8000bbd6:	fa e9 00 04 	st.d	sp[4],r8
8000bbda:	10 94       	mov	r4,r8
8000bbdc:	40 09       	lddsp	r9,sp[0x0]
8000bbde:	e2 1c 04 00 	andl	r12,0x400,COH
8000bbe2:	2f f9       	sub	r9,-1
8000bbe4:	0c 09       	add	r9,r6
8000bbe6:	12 38       	cp.w	r8,r9
8000bbe8:	f2 04 17 30 	movlo	r4,r9
8000bbec:	58 0c       	cp.w	r12,0
8000bbee:	c1 10       	breq	8000bc10 <__sfvwrite_r+0x10c>
8000bbf0:	08 9b       	mov	r11,r4
8000bbf2:	0a 9c       	mov	r12,r5
8000bbf4:	fe b0 e0 5a 	rcall	80007ca8 <_malloc_r>
8000bbf8:	18 92       	mov	r2,r12
8000bbfa:	c1 40       	breq	8000bc22 <__sfvwrite_r+0x11e>
8000bbfc:	40 0a       	lddsp	r10,sp[0x0]
8000bbfe:	6e 4b       	ld.w	r11,r7[0x10]
8000bc00:	fe b0 e2 83 	rcall	80008106 <memcpy>
8000bc04:	8e 68       	ld.sh	r8,r7[0xc]
8000bc06:	e0 18 fb 7f 	andl	r8,0xfb7f
8000bc0a:	a7 b8       	sbr	r8,0x7
8000bc0c:	ae 68       	st.h	r7[0xc],r8
8000bc0e:	c0 d8       	rjmp	8000bc28 <__sfvwrite_r+0x124>
8000bc10:	08 9a       	mov	r10,r4
8000bc12:	0a 9c       	mov	r12,r5
8000bc14:	fe b0 e3 24 	rcall	8000825c <_realloc_r>
8000bc18:	18 92       	mov	r2,r12
8000bc1a:	c0 71       	brne	8000bc28 <__sfvwrite_r+0x124>
8000bc1c:	6e 4b       	ld.w	r11,r7[0x10]
8000bc1e:	0a 9c       	mov	r12,r5
8000bc20:	ca ce       	rcall	8000b978 <_free_r>
8000bc22:	30 c8       	mov	r8,12
8000bc24:	8b 38       	st.w	r5[0xc],r8
8000bc26:	cb 18       	rjmp	8000bd88 <__sfvwrite_r+0x284>
8000bc28:	40 0a       	lddsp	r10,sp[0x0]
8000bc2a:	40 09       	lddsp	r9,sp[0x0]
8000bc2c:	e8 0a 01 0a 	sub	r10,r4,r10
8000bc30:	e4 09 00 08 	add	r8,r2,r9
8000bc34:	8f 54       	st.w	r7[0x14],r4
8000bc36:	8f 2a       	st.w	r7[0x8],r10
8000bc38:	8f 08       	st.w	r7[0x0],r8
8000bc3a:	8f 42       	st.w	r7[0x10],r2
8000bc3c:	0c 94       	mov	r4,r6
8000bc3e:	08 36       	cp.w	r6,r4
8000bc40:	ec 04 17 30 	movlo	r4,r6
8000bc44:	06 9b       	mov	r11,r3
8000bc46:	08 9a       	mov	r10,r4
8000bc48:	6e 0c       	ld.w	r12,r7[0x0]
8000bc4a:	c3 ad       	rcall	8000bebe <memmove>
8000bc4c:	6e 08       	ld.w	r8,r7[0x0]
8000bc4e:	08 08       	add	r8,r4
8000bc50:	8f 08       	st.w	r7[0x0],r8
8000bc52:	6e 28       	ld.w	r8,r7[0x8]
8000bc54:	08 18       	sub	r8,r4
8000bc56:	0c 94       	mov	r4,r6
8000bc58:	8f 28       	st.w	r7[0x8],r8
8000bc5a:	c2 e8       	rjmp	8000bcb6 <__sfvwrite_r+0x1b2>
8000bc5c:	08 36       	cp.w	r6,r4
8000bc5e:	5f ba       	srhi	r10
8000bc60:	6e 0c       	ld.w	r12,r7[0x0]
8000bc62:	6e 48       	ld.w	r8,r7[0x10]
8000bc64:	10 3c       	cp.w	r12,r8
8000bc66:	5f b8       	srhi	r8
8000bc68:	f5 e8 00 08 	and	r8,r10,r8
8000bc6c:	f2 08 18 00 	cp.b	r8,r9
8000bc70:	c0 d0       	breq	8000bc8a <__sfvwrite_r+0x186>
8000bc72:	06 9b       	mov	r11,r3
8000bc74:	08 9a       	mov	r10,r4
8000bc76:	c2 4d       	rcall	8000bebe <memmove>
8000bc78:	6e 08       	ld.w	r8,r7[0x0]
8000bc7a:	08 08       	add	r8,r4
8000bc7c:	0e 9b       	mov	r11,r7
8000bc7e:	8f 08       	st.w	r7[0x0],r8
8000bc80:	0a 9c       	mov	r12,r5
8000bc82:	fe b0 fd 09 	rcall	8000b694 <_fflush_r>
8000bc86:	c1 80       	breq	8000bcb6 <__sfvwrite_r+0x1b2>
8000bc88:	c8 08       	rjmp	8000bd88 <__sfvwrite_r+0x284>
8000bc8a:	6e 59       	ld.w	r9,r7[0x14]
8000bc8c:	12 36       	cp.w	r6,r9
8000bc8e:	c0 a3       	brcs	8000bca2 <__sfvwrite_r+0x19e>
8000bc90:	6e a8       	ld.w	r8,r7[0x28]
8000bc92:	06 9a       	mov	r10,r3
8000bc94:	6e 8b       	ld.w	r11,r7[0x20]
8000bc96:	0a 9c       	mov	r12,r5
8000bc98:	5d 18       	icall	r8
8000bc9a:	18 94       	mov	r4,r12
8000bc9c:	e0 89 00 0d 	brgt	8000bcb6 <__sfvwrite_r+0x1b2>
8000bca0:	c7 48       	rjmp	8000bd88 <__sfvwrite_r+0x284>
8000bca2:	0c 9a       	mov	r10,r6
8000bca4:	06 9b       	mov	r11,r3
8000bca6:	c0 cd       	rcall	8000bebe <memmove>
8000bca8:	6e 08       	ld.w	r8,r7[0x0]
8000bcaa:	0c 08       	add	r8,r6
8000bcac:	0c 94       	mov	r4,r6
8000bcae:	8f 08       	st.w	r7[0x0],r8
8000bcb0:	6e 28       	ld.w	r8,r7[0x8]
8000bcb2:	0c 18       	sub	r8,r6
8000bcb4:	8f 28       	st.w	r7[0x8],r8
8000bcb6:	62 28       	ld.w	r8,r1[0x8]
8000bcb8:	08 18       	sub	r8,r4
8000bcba:	83 28       	st.w	r1[0x8],r8
8000bcbc:	c6 b0       	breq	8000bd92 <__sfvwrite_r+0x28e>
8000bcbe:	08 16       	sub	r6,r4
8000bcc0:	08 03       	add	r3,r4
8000bcc2:	c7 1b       	rjmp	8000bba4 <__sfvwrite_r+0xa0>
8000bcc4:	60 03       	ld.w	r3,r0[0x0]
8000bcc6:	60 11       	ld.w	r1,r0[0x4]
8000bcc8:	30 08       	mov	r8,0
8000bcca:	2f 80       	sub	r0,-8
8000bccc:	50 08       	stdsp	sp[0x0],r8
8000bcce:	58 01       	cp.w	r1,0
8000bcd0:	cf a0       	breq	8000bcc4 <__sfvwrite_r+0x1c0>
8000bcd2:	40 0a       	lddsp	r10,sp[0x0]
8000bcd4:	58 0a       	cp.w	r10,0
8000bcd6:	c1 41       	brne	8000bcfe <__sfvwrite_r+0x1fa>
8000bcd8:	e2 c6 ff ff 	sub	r6,r1,-1
8000bcdc:	02 9a       	mov	r10,r1
8000bcde:	30 ab       	mov	r11,10
8000bce0:	06 9c       	mov	r12,r3
8000bce2:	ce 3c       	rcall	8000bea8 <memchr>
8000bce4:	f8 c8 ff ff 	sub	r8,r12,-1
8000bce8:	58 0c       	cp.w	r12,0
8000bcea:	f1 d3 e1 16 	subne	r6,r8,r3
8000bcee:	f9 b9 01 01 	movne	r9,1
8000bcf2:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000bcf6:	f9 b8 00 01 	moveq	r8,1
8000bcfa:	fb f8 0a 00 	st.weq	sp[0x0],r8
8000bcfe:	02 36       	cp.w	r6,r1
8000bd00:	ec 04 17 80 	movls	r4,r6
8000bd04:	e2 04 17 b0 	movhi	r4,r1
8000bd08:	6e 59       	ld.w	r9,r7[0x14]
8000bd0a:	6e 25       	ld.w	r5,r7[0x8]
8000bd0c:	f2 05 00 05 	add	r5,r9,r5
8000bd10:	0a 34       	cp.w	r4,r5
8000bd12:	5f 9a       	srgt	r10
8000bd14:	6e 0c       	ld.w	r12,r7[0x0]
8000bd16:	6e 48       	ld.w	r8,r7[0x10]
8000bd18:	10 3c       	cp.w	r12,r8
8000bd1a:	5f b8       	srhi	r8
8000bd1c:	f5 e8 00 08 	and	r8,r10,r8
8000bd20:	30 0a       	mov	r10,0
8000bd22:	f4 08 18 00 	cp.b	r8,r10
8000bd26:	c0 d0       	breq	8000bd40 <__sfvwrite_r+0x23c>
8000bd28:	06 9b       	mov	r11,r3
8000bd2a:	0a 9a       	mov	r10,r5
8000bd2c:	cc 9c       	rcall	8000bebe <memmove>
8000bd2e:	6e 08       	ld.w	r8,r7[0x0]
8000bd30:	0a 08       	add	r8,r5
8000bd32:	0e 9b       	mov	r11,r7
8000bd34:	8f 08       	st.w	r7[0x0],r8
8000bd36:	40 1c       	lddsp	r12,sp[0x4]
8000bd38:	fe b0 fc ae 	rcall	8000b694 <_fflush_r>
8000bd3c:	c1 70       	breq	8000bd6a <__sfvwrite_r+0x266>
8000bd3e:	c2 58       	rjmp	8000bd88 <__sfvwrite_r+0x284>
8000bd40:	12 34       	cp.w	r4,r9
8000bd42:	c0 a5       	brlt	8000bd56 <__sfvwrite_r+0x252>
8000bd44:	6e a8       	ld.w	r8,r7[0x28]
8000bd46:	06 9a       	mov	r10,r3
8000bd48:	6e 8b       	ld.w	r11,r7[0x20]
8000bd4a:	40 1c       	lddsp	r12,sp[0x4]
8000bd4c:	5d 18       	icall	r8
8000bd4e:	18 95       	mov	r5,r12
8000bd50:	e0 89 00 0d 	brgt	8000bd6a <__sfvwrite_r+0x266>
8000bd54:	c1 a8       	rjmp	8000bd88 <__sfvwrite_r+0x284>
8000bd56:	08 9a       	mov	r10,r4
8000bd58:	06 9b       	mov	r11,r3
8000bd5a:	cb 2c       	rcall	8000bebe <memmove>
8000bd5c:	6e 08       	ld.w	r8,r7[0x0]
8000bd5e:	08 08       	add	r8,r4
8000bd60:	08 95       	mov	r5,r4
8000bd62:	8f 08       	st.w	r7[0x0],r8
8000bd64:	6e 28       	ld.w	r8,r7[0x8]
8000bd66:	08 18       	sub	r8,r4
8000bd68:	8f 28       	st.w	r7[0x8],r8
8000bd6a:	0a 16       	sub	r6,r5
8000bd6c:	c0 71       	brne	8000bd7a <__sfvwrite_r+0x276>
8000bd6e:	0e 9b       	mov	r11,r7
8000bd70:	40 1c       	lddsp	r12,sp[0x4]
8000bd72:	fe b0 fc 91 	rcall	8000b694 <_fflush_r>
8000bd76:	c0 91       	brne	8000bd88 <__sfvwrite_r+0x284>
8000bd78:	50 06       	stdsp	sp[0x0],r6
8000bd7a:	64 28       	ld.w	r8,r2[0x8]
8000bd7c:	0a 18       	sub	r8,r5
8000bd7e:	85 28       	st.w	r2[0x8],r8
8000bd80:	c0 90       	breq	8000bd92 <__sfvwrite_r+0x28e>
8000bd82:	0a 11       	sub	r1,r5
8000bd84:	0a 03       	add	r3,r5
8000bd86:	ca 4b       	rjmp	8000bcce <__sfvwrite_r+0x1ca>
8000bd88:	8e 68       	ld.sh	r8,r7[0xc]
8000bd8a:	a7 a8       	sbr	r8,0x6
8000bd8c:	ae 68       	st.h	r7[0xc],r8
8000bd8e:	3f fc       	mov	r12,-1
8000bd90:	c0 28       	rjmp	8000bd94 <__sfvwrite_r+0x290>
8000bd92:	30 0c       	mov	r12,0
8000bd94:	2f dd       	sub	sp,-12
8000bd96:	d8 32       	popm	r0-r7,pc

8000bd98 <_fwalk>:
8000bd98:	d4 31       	pushm	r0-r7,lr
8000bd9a:	30 05       	mov	r5,0
8000bd9c:	16 91       	mov	r1,r11
8000bd9e:	f8 c7 ff 28 	sub	r7,r12,-216
8000bda2:	0a 92       	mov	r2,r5
8000bda4:	fe b0 fc fe 	rcall	8000b7a0 <__sfp_lock_acquire>
8000bda8:	3f f3       	mov	r3,-1
8000bdaa:	c1 68       	rjmp	8000bdd6 <_fwalk+0x3e>
8000bdac:	6e 26       	ld.w	r6,r7[0x8]
8000bdae:	6e 14       	ld.w	r4,r7[0x4]
8000bdb0:	2f 46       	sub	r6,-12
8000bdb2:	c0 c8       	rjmp	8000bdca <_fwalk+0x32>
8000bdb4:	8c 08       	ld.sh	r8,r6[0x0]
8000bdb6:	e4 08 19 00 	cp.h	r8,r2
8000bdba:	c0 70       	breq	8000bdc8 <_fwalk+0x30>
8000bdbc:	8c 18       	ld.sh	r8,r6[0x2]
8000bdbe:	e6 08 19 00 	cp.h	r8,r3
8000bdc2:	c0 30       	breq	8000bdc8 <_fwalk+0x30>
8000bdc4:	5d 11       	icall	r1
8000bdc6:	18 45       	or	r5,r12
8000bdc8:	2a 46       	sub	r6,-92
8000bdca:	20 14       	sub	r4,1
8000bdcc:	ec cc 00 0c 	sub	r12,r6,12
8000bdd0:	58 04       	cp.w	r4,0
8000bdd2:	cf 14       	brge	8000bdb4 <_fwalk+0x1c>
8000bdd4:	6e 07       	ld.w	r7,r7[0x0]
8000bdd6:	58 07       	cp.w	r7,0
8000bdd8:	ce a1       	brne	8000bdac <_fwalk+0x14>
8000bdda:	fe b0 fc e4 	rcall	8000b7a2 <__sfp_lock_release>
8000bdde:	0a 9c       	mov	r12,r5
8000bde0:	d8 32       	popm	r0-r7,pc
8000bde2:	d7 03       	nop

8000bde4 <_localeconv_r>:
8000bde4:	fe cc d2 fc 	sub	r12,pc,-11524
8000bde8:	5e fc       	retal	r12
8000bdea:	d7 03       	nop

8000bdec <__smakebuf_r>:
8000bdec:	d4 21       	pushm	r4-r7,lr
8000bdee:	20 fd       	sub	sp,60
8000bdf0:	96 68       	ld.sh	r8,r11[0xc]
8000bdf2:	16 97       	mov	r7,r11
8000bdf4:	18 96       	mov	r6,r12
8000bdf6:	e2 18 00 02 	andl	r8,0x2,COH
8000bdfa:	c3 d1       	brne	8000be74 <__smakebuf_r+0x88>
8000bdfc:	96 7b       	ld.sh	r11,r11[0xe]
8000bdfe:	f0 0b 19 00 	cp.h	r11,r8
8000be02:	c0 55       	brlt	8000be0c <__smakebuf_r+0x20>
8000be04:	1a 9a       	mov	r10,sp
8000be06:	e0 a0 04 81 	rcall	8000c708 <_fstat_r>
8000be0a:	c0 f4       	brge	8000be28 <__smakebuf_r+0x3c>
8000be0c:	8e 65       	ld.sh	r5,r7[0xc]
8000be0e:	0a 98       	mov	r8,r5
8000be10:	ab b8       	sbr	r8,0xb
8000be12:	e2 15 00 80 	andl	r5,0x80,COH
8000be16:	ae 68       	st.h	r7[0xc],r8
8000be18:	30 04       	mov	r4,0
8000be1a:	e0 68 04 00 	mov	r8,1024
8000be1e:	f9 b5 01 40 	movne	r5,64
8000be22:	f0 05 17 00 	moveq	r5,r8
8000be26:	c1 c8       	rjmp	8000be5e <__smakebuf_r+0x72>
8000be28:	40 18       	lddsp	r8,sp[0x4]
8000be2a:	e2 18 f0 00 	andl	r8,0xf000,COH
8000be2e:	e0 48 20 00 	cp.w	r8,8192
8000be32:	5f 04       	sreq	r4
8000be34:	e0 48 80 00 	cp.w	r8,32768
8000be38:	c0 e1       	brne	8000be54 <__smakebuf_r+0x68>
8000be3a:	6e b9       	ld.w	r9,r7[0x2c]
8000be3c:	fe c8 f9 1c 	sub	r8,pc,-1764
8000be40:	10 39       	cp.w	r9,r8
8000be42:	c0 91       	brne	8000be54 <__smakebuf_r+0x68>
8000be44:	8e 68       	ld.sh	r8,r7[0xc]
8000be46:	e0 65 04 00 	mov	r5,1024
8000be4a:	ab a8       	sbr	r8,0xa
8000be4c:	ef 45 00 50 	st.w	r7[80],r5
8000be50:	ae 68       	st.h	r7[0xc],r8
8000be52:	c0 68       	rjmp	8000be5e <__smakebuf_r+0x72>
8000be54:	8e 68       	ld.sh	r8,r7[0xc]
8000be56:	e0 65 04 00 	mov	r5,1024
8000be5a:	ab b8       	sbr	r8,0xb
8000be5c:	ae 68       	st.h	r7[0xc],r8
8000be5e:	0a 9b       	mov	r11,r5
8000be60:	0c 9c       	mov	r12,r6
8000be62:	fe b0 df 23 	rcall	80007ca8 <_malloc_r>
8000be66:	8e 68       	ld.sh	r8,r7[0xc]
8000be68:	c0 d1       	brne	8000be82 <__smakebuf_r+0x96>
8000be6a:	ed b8 00 09 	bld	r8,0x9
8000be6e:	c1 b0       	breq	8000bea4 <__smakebuf_r+0xb8>
8000be70:	a1 b8       	sbr	r8,0x1
8000be72:	ae 68       	st.h	r7[0xc],r8
8000be74:	ee c8 ff b9 	sub	r8,r7,-71
8000be78:	8f 48       	st.w	r7[0x10],r8
8000be7a:	8f 08       	st.w	r7[0x0],r8
8000be7c:	30 18       	mov	r8,1
8000be7e:	8f 58       	st.w	r7[0x14],r8
8000be80:	c1 28       	rjmp	8000bea4 <__smakebuf_r+0xb8>
8000be82:	a7 b8       	sbr	r8,0x7
8000be84:	8f 4c       	st.w	r7[0x10],r12
8000be86:	ae 68       	st.h	r7[0xc],r8
8000be88:	8f 55       	st.w	r7[0x14],r5
8000be8a:	fe c8 06 e6 	sub	r8,pc,1766
8000be8e:	8f 0c       	st.w	r7[0x0],r12
8000be90:	8d a8       	st.w	r6[0x28],r8
8000be92:	58 04       	cp.w	r4,0
8000be94:	c0 80       	breq	8000bea4 <__smakebuf_r+0xb8>
8000be96:	8e 7c       	ld.sh	r12,r7[0xe]
8000be98:	fe b0 e3 94 	rcall	800085c0 <isatty>
8000be9c:	c0 40       	breq	8000bea4 <__smakebuf_r+0xb8>
8000be9e:	8e 68       	ld.sh	r8,r7[0xc]
8000bea0:	a1 a8       	sbr	r8,0x0
8000bea2:	ae 68       	st.h	r7[0xc],r8
8000bea4:	2f 1d       	sub	sp,-60
8000bea6:	d8 22       	popm	r4-r7,pc

8000bea8 <memchr>:
8000bea8:	f7 db c0 08 	bfextu	r11,r11,0x0,0x8
8000beac:	c0 68       	rjmp	8000beb8 <memchr+0x10>
8000beae:	20 1a       	sub	r10,1
8000beb0:	19 88       	ld.ub	r8,r12[0x0]
8000beb2:	16 38       	cp.w	r8,r11
8000beb4:	5e 0c       	reteq	r12
8000beb6:	2f fc       	sub	r12,-1
8000beb8:	58 0a       	cp.w	r10,0
8000beba:	cf a1       	brne	8000beae <memchr+0x6>
8000bebc:	5e fa       	retal	r10

8000bebe <memmove>:
8000bebe:	d4 01       	pushm	lr
8000bec0:	18 3b       	cp.w	r11,r12
8000bec2:	c1 92       	brcc	8000bef4 <memmove+0x36>
8000bec4:	f6 0a 00 09 	add	r9,r11,r10
8000bec8:	12 3c       	cp.w	r12,r9
8000beca:	c1 52       	brcc	8000bef4 <memmove+0x36>
8000becc:	f8 0a 00 0b 	add	r11,r12,r10
8000bed0:	30 08       	mov	r8,0
8000bed2:	c0 68       	rjmp	8000bede <memmove+0x20>
8000bed4:	f2 08 07 0e 	ld.ub	lr,r9[r8]
8000bed8:	20 1a       	sub	r10,1
8000beda:	f6 08 0b 0e 	st.b	r11[r8],lr
8000bede:	20 18       	sub	r8,1
8000bee0:	58 0a       	cp.w	r10,0
8000bee2:	cf 91       	brne	8000bed4 <memmove+0x16>
8000bee4:	d8 02       	popm	pc
8000bee6:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000beea:	20 1a       	sub	r10,1
8000beec:	f8 08 0b 09 	st.b	r12[r8],r9
8000bef0:	2f f8       	sub	r8,-1
8000bef2:	c0 28       	rjmp	8000bef6 <memmove+0x38>
8000bef4:	30 08       	mov	r8,0
8000bef6:	58 0a       	cp.w	r10,0
8000bef8:	cf 71       	brne	8000bee6 <memmove+0x28>
8000befa:	d8 02       	popm	pc

8000befc <__hi0bits>:
8000befc:	18 98       	mov	r8,r12
8000befe:	e0 1c 00 00 	andl	r12,0x0
8000bf02:	f0 09 15 10 	lsl	r9,r8,0x10
8000bf06:	58 0c       	cp.w	r12,0
8000bf08:	f2 08 17 00 	moveq	r8,r9
8000bf0c:	f9 bc 00 10 	moveq	r12,16
8000bf10:	f9 bc 01 00 	movne	r12,0
8000bf14:	10 9a       	mov	r10,r8
8000bf16:	f0 09 15 08 	lsl	r9,r8,0x8
8000bf1a:	e6 1a ff 00 	andh	r10,0xff00,COH
8000bf1e:	f7 bc 00 f8 	subeq	r12,-8
8000bf22:	f2 08 17 00 	moveq	r8,r9
8000bf26:	10 9a       	mov	r10,r8
8000bf28:	f0 09 15 04 	lsl	r9,r8,0x4
8000bf2c:	e6 1a f0 00 	andh	r10,0xf000,COH
8000bf30:	f7 bc 00 fc 	subeq	r12,-4
8000bf34:	f2 08 17 00 	moveq	r8,r9
8000bf38:	10 9a       	mov	r10,r8
8000bf3a:	f0 09 15 02 	lsl	r9,r8,0x2
8000bf3e:	e6 1a c0 00 	andh	r10,0xc000,COH
8000bf42:	f7 bc 00 fe 	subeq	r12,-2
8000bf46:	f2 08 17 00 	moveq	r8,r9
8000bf4a:	58 08       	cp.w	r8,0
8000bf4c:	5e 5c       	retlt	r12
8000bf4e:	ed b8 00 1e 	bld	r8,0x1e
8000bf52:	f9 bc 01 20 	movne	r12,32
8000bf56:	f7 bc 00 ff 	subeq	r12,-1
8000bf5a:	5e fc       	retal	r12

8000bf5c <__lo0bits>:
8000bf5c:	18 99       	mov	r9,r12
8000bf5e:	78 08       	ld.w	r8,r12[0x0]
8000bf60:	f9 d8 c0 03 	bfextu	r12,r8,0x0,0x3
8000bf64:	c1 50       	breq	8000bf8e <__lo0bits+0x32>
8000bf66:	ed b8 00 00 	bld	r8,0x0
8000bf6a:	c0 21       	brne	8000bf6e <__lo0bits+0x12>
8000bf6c:	5e fd       	retal	0
8000bf6e:	10 9b       	mov	r11,r8
8000bf70:	f0 0a 16 01 	lsr	r10,r8,0x1
8000bf74:	e2 1b 00 02 	andl	r11,0x2,COH
8000bf78:	a3 88       	lsr	r8,0x2
8000bf7a:	58 0b       	cp.w	r11,0
8000bf7c:	f3 fa 1a 00 	st.wne	r9[0x0],r10
8000bf80:	f9 bc 01 01 	movne	r12,1
8000bf84:	f3 f8 0a 00 	st.weq	r9[0x0],r8
8000bf88:	f9 bc 00 02 	moveq	r12,2
8000bf8c:	5e fc       	retal	r12
8000bf8e:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
8000bf92:	f0 0b 16 10 	lsr	r11,r8,0x10
8000bf96:	58 0a       	cp.w	r10,0
8000bf98:	f6 08 17 00 	moveq	r8,r11
8000bf9c:	f9 bc 00 10 	moveq	r12,16
8000bfa0:	f7 d8 c0 08 	bfextu	r11,r8,0x0,0x8
8000bfa4:	f0 0a 16 08 	lsr	r10,r8,0x8
8000bfa8:	58 0b       	cp.w	r11,0
8000bfaa:	f7 bc 00 f8 	subeq	r12,-8
8000bfae:	f4 08 17 00 	moveq	r8,r10
8000bfb2:	f7 d8 c0 04 	bfextu	r11,r8,0x0,0x4
8000bfb6:	f0 0a 16 04 	lsr	r10,r8,0x4
8000bfba:	58 0b       	cp.w	r11,0
8000bfbc:	f7 bc 00 fc 	subeq	r12,-4
8000bfc0:	f4 08 17 00 	moveq	r8,r10
8000bfc4:	f7 d8 c0 02 	bfextu	r11,r8,0x0,0x2
8000bfc8:	f0 0a 16 02 	lsr	r10,r8,0x2
8000bfcc:	58 0b       	cp.w	r11,0
8000bfce:	f7 bc 00 fe 	subeq	r12,-2
8000bfd2:	f4 08 17 00 	moveq	r8,r10
8000bfd6:	ed b8 00 00 	bld	r8,0x0
8000bfda:	c0 60       	breq	8000bfe6 <__lo0bits+0x8a>
8000bfdc:	a1 98       	lsr	r8,0x1
8000bfde:	c0 31       	brne	8000bfe4 <__lo0bits+0x88>
8000bfe0:	32 0c       	mov	r12,32
8000bfe2:	5e fc       	retal	r12
8000bfe4:	2f fc       	sub	r12,-1
8000bfe6:	93 08       	st.w	r9[0x0],r8
8000bfe8:	5e fc       	retal	r12

8000bfea <__mcmp>:
8000bfea:	d4 01       	pushm	lr
8000bfec:	18 98       	mov	r8,r12
8000bfee:	76 49       	ld.w	r9,r11[0x10]
8000bff0:	78 4c       	ld.w	r12,r12[0x10]
8000bff2:	12 1c       	sub	r12,r9
8000bff4:	c1 31       	brne	8000c01a <__mcmp+0x30>
8000bff6:	2f b9       	sub	r9,-5
8000bff8:	a3 69       	lsl	r9,0x2
8000bffa:	12 0b       	add	r11,r9
8000bffc:	f0 09 00 09 	add	r9,r8,r9
8000c000:	2e c8       	sub	r8,-20
8000c002:	13 4e       	ld.w	lr,--r9
8000c004:	17 4a       	ld.w	r10,--r11
8000c006:	14 3e       	cp.w	lr,r10
8000c008:	c0 60       	breq	8000c014 <__mcmp+0x2a>
8000c00a:	f9 bc 03 ff 	movlo	r12,-1
8000c00e:	f9 bc 02 01 	movhs	r12,1
8000c012:	d8 02       	popm	pc
8000c014:	10 39       	cp.w	r9,r8
8000c016:	fe 9b ff f6 	brhi	8000c002 <__mcmp+0x18>
8000c01a:	d8 02       	popm	pc

8000c01c <_Bfree>:
8000c01c:	d4 21       	pushm	r4-r7,lr
8000c01e:	18 97       	mov	r7,r12
8000c020:	16 95       	mov	r5,r11
8000c022:	78 96       	ld.w	r6,r12[0x24]
8000c024:	58 06       	cp.w	r6,0
8000c026:	c0 91       	brne	8000c038 <_Bfree+0x1c>
8000c028:	31 0c       	mov	r12,16
8000c02a:	fe b0 de 37 	rcall	80007c98 <malloc>
8000c02e:	99 36       	st.w	r12[0xc],r6
8000c030:	8f 9c       	st.w	r7[0x24],r12
8000c032:	99 16       	st.w	r12[0x4],r6
8000c034:	99 26       	st.w	r12[0x8],r6
8000c036:	99 06       	st.w	r12[0x0],r6
8000c038:	58 05       	cp.w	r5,0
8000c03a:	c0 90       	breq	8000c04c <_Bfree+0x30>
8000c03c:	6a 19       	ld.w	r9,r5[0x4]
8000c03e:	6e 98       	ld.w	r8,r7[0x24]
8000c040:	70 38       	ld.w	r8,r8[0xc]
8000c042:	f0 09 03 2a 	ld.w	r10,r8[r9<<0x2]
8000c046:	8b 0a       	st.w	r5[0x0],r10
8000c048:	f0 09 09 25 	st.w	r8[r9<<0x2],r5
8000c04c:	d8 22       	popm	r4-r7,pc
8000c04e:	d7 03       	nop

8000c050 <_Balloc>:
8000c050:	d4 21       	pushm	r4-r7,lr
8000c052:	18 97       	mov	r7,r12
8000c054:	16 96       	mov	r6,r11
8000c056:	78 95       	ld.w	r5,r12[0x24]
8000c058:	58 05       	cp.w	r5,0
8000c05a:	c0 91       	brne	8000c06c <_Balloc+0x1c>
8000c05c:	31 0c       	mov	r12,16
8000c05e:	fe b0 de 1d 	rcall	80007c98 <malloc>
8000c062:	99 35       	st.w	r12[0xc],r5
8000c064:	8f 9c       	st.w	r7[0x24],r12
8000c066:	99 15       	st.w	r12[0x4],r5
8000c068:	99 25       	st.w	r12[0x8],r5
8000c06a:	99 05       	st.w	r12[0x0],r5
8000c06c:	6e 95       	ld.w	r5,r7[0x24]
8000c06e:	6a 38       	ld.w	r8,r5[0xc]
8000c070:	58 08       	cp.w	r8,0
8000c072:	c0 b1       	brne	8000c088 <_Balloc+0x38>
8000c074:	31 0a       	mov	r10,16
8000c076:	30 4b       	mov	r11,4
8000c078:	0e 9c       	mov	r12,r7
8000c07a:	e0 a0 02 a7 	rcall	8000c5c8 <_calloc_r>
8000c07e:	8b 3c       	st.w	r5[0xc],r12
8000c080:	6e 98       	ld.w	r8,r7[0x24]
8000c082:	70 3c       	ld.w	r12,r8[0xc]
8000c084:	58 0c       	cp.w	r12,0
8000c086:	c1 b0       	breq	8000c0bc <_Balloc+0x6c>
8000c088:	6e 98       	ld.w	r8,r7[0x24]
8000c08a:	70 38       	ld.w	r8,r8[0xc]
8000c08c:	f0 06 00 28 	add	r8,r8,r6<<0x2
8000c090:	70 0c       	ld.w	r12,r8[0x0]
8000c092:	58 0c       	cp.w	r12,0
8000c094:	c0 40       	breq	8000c09c <_Balloc+0x4c>
8000c096:	78 09       	ld.w	r9,r12[0x0]
8000c098:	91 09       	st.w	r8[0x0],r9
8000c09a:	c0 e8       	rjmp	8000c0b6 <_Balloc+0x66>
8000c09c:	0e 9c       	mov	r12,r7
8000c09e:	30 17       	mov	r7,1
8000c0a0:	0e 9b       	mov	r11,r7
8000c0a2:	ee 06 09 47 	lsl	r7,r7,r6
8000c0a6:	ee ca ff fb 	sub	r10,r7,-5
8000c0aa:	a3 6a       	lsl	r10,0x2
8000c0ac:	e0 a0 02 8e 	rcall	8000c5c8 <_calloc_r>
8000c0b0:	c0 60       	breq	8000c0bc <_Balloc+0x6c>
8000c0b2:	99 16       	st.w	r12[0x4],r6
8000c0b4:	99 27       	st.w	r12[0x8],r7
8000c0b6:	30 08       	mov	r8,0
8000c0b8:	99 38       	st.w	r12[0xc],r8
8000c0ba:	99 48       	st.w	r12[0x10],r8
8000c0bc:	d8 22       	popm	r4-r7,pc
8000c0be:	d7 03       	nop

8000c0c0 <__d2b>:
8000c0c0:	d4 31       	pushm	r0-r7,lr
8000c0c2:	20 2d       	sub	sp,8
8000c0c4:	16 93       	mov	r3,r11
8000c0c6:	12 96       	mov	r6,r9
8000c0c8:	10 95       	mov	r5,r8
8000c0ca:	14 92       	mov	r2,r10
8000c0cc:	30 1b       	mov	r11,1
8000c0ce:	cc 1f       	rcall	8000c050 <_Balloc>
8000c0d0:	f3 d3 c0 14 	bfextu	r9,r3,0x0,0x14
8000c0d4:	50 09       	stdsp	sp[0x0],r9
8000c0d6:	f1 d3 c0 1f 	bfextu	r8,r3,0x0,0x1f
8000c0da:	b5 a9       	sbr	r9,0x14
8000c0dc:	f0 01 16 14 	lsr	r1,r8,0x14
8000c0e0:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000c0e4:	18 94       	mov	r4,r12
8000c0e6:	58 02       	cp.w	r2,0
8000c0e8:	c1 d0       	breq	8000c122 <__d2b+0x62>
8000c0ea:	fa cc ff f8 	sub	r12,sp,-8
8000c0ee:	18 d2       	st.w	--r12,r2
8000c0f0:	c3 6f       	rcall	8000bf5c <__lo0bits>
8000c0f2:	40 18       	lddsp	r8,sp[0x4]
8000c0f4:	c0 d0       	breq	8000c10e <__d2b+0x4e>
8000c0f6:	40 09       	lddsp	r9,sp[0x0]
8000c0f8:	f8 0a 11 20 	rsub	r10,r12,32
8000c0fc:	f2 0a 09 4a 	lsl	r10,r9,r10
8000c100:	f5 e8 10 08 	or	r8,r10,r8
8000c104:	89 58       	st.w	r4[0x14],r8
8000c106:	f2 0c 0a 49 	lsr	r9,r9,r12
8000c10a:	50 09       	stdsp	sp[0x0],r9
8000c10c:	c0 28       	rjmp	8000c110 <__d2b+0x50>
8000c10e:	89 58       	st.w	r4[0x14],r8
8000c110:	40 08       	lddsp	r8,sp[0x0]
8000c112:	58 08       	cp.w	r8,0
8000c114:	f9 b3 01 02 	movne	r3,2
8000c118:	f9 b3 00 01 	moveq	r3,1
8000c11c:	89 68       	st.w	r4[0x18],r8
8000c11e:	89 43       	st.w	r4[0x10],r3
8000c120:	c0 88       	rjmp	8000c130 <__d2b+0x70>
8000c122:	1a 9c       	mov	r12,sp
8000c124:	c1 cf       	rcall	8000bf5c <__lo0bits>
8000c126:	30 13       	mov	r3,1
8000c128:	40 08       	lddsp	r8,sp[0x0]
8000c12a:	2e 0c       	sub	r12,-32
8000c12c:	89 43       	st.w	r4[0x10],r3
8000c12e:	89 58       	st.w	r4[0x14],r8
8000c130:	58 01       	cp.w	r1,0
8000c132:	c0 90       	breq	8000c144 <__d2b+0x84>
8000c134:	e2 c1 04 33 	sub	r1,r1,1075
8000c138:	18 01       	add	r1,r12
8000c13a:	8d 01       	st.w	r6[0x0],r1
8000c13c:	f8 0c 11 35 	rsub	r12,r12,53
8000c140:	8b 0c       	st.w	r5[0x0],r12
8000c142:	c0 c8       	rjmp	8000c15a <__d2b+0x9a>
8000c144:	e6 c8 ff fc 	sub	r8,r3,-4
8000c148:	f8 cc 04 32 	sub	r12,r12,1074
8000c14c:	a5 73       	lsl	r3,0x5
8000c14e:	8d 0c       	st.w	r6[0x0],r12
8000c150:	e8 08 03 2c 	ld.w	r12,r4[r8<<0x2]
8000c154:	cd 4e       	rcall	8000befc <__hi0bits>
8000c156:	18 13       	sub	r3,r12
8000c158:	8b 03       	st.w	r5[0x0],r3
8000c15a:	08 9c       	mov	r12,r4
8000c15c:	2f ed       	sub	sp,-8
8000c15e:	d8 32       	popm	r0-r7,pc

8000c160 <__mdiff>:
8000c160:	d4 31       	pushm	r0-r7,lr
8000c162:	74 48       	ld.w	r8,r10[0x10]
8000c164:	76 45       	ld.w	r5,r11[0x10]
8000c166:	16 97       	mov	r7,r11
8000c168:	14 96       	mov	r6,r10
8000c16a:	10 15       	sub	r5,r8
8000c16c:	c1 31       	brne	8000c192 <__mdiff+0x32>
8000c16e:	2f b8       	sub	r8,-5
8000c170:	ee ce ff ec 	sub	lr,r7,-20
8000c174:	a3 68       	lsl	r8,0x2
8000c176:	f4 08 00 0b 	add	r11,r10,r8
8000c17a:	ee 08 00 08 	add	r8,r7,r8
8000c17e:	11 4a       	ld.w	r10,--r8
8000c180:	17 49       	ld.w	r9,--r11
8000c182:	12 3a       	cp.w	r10,r9
8000c184:	c0 30       	breq	8000c18a <__mdiff+0x2a>
8000c186:	c0 e2       	brcc	8000c1a2 <__mdiff+0x42>
8000c188:	c0 78       	rjmp	8000c196 <__mdiff+0x36>
8000c18a:	1c 38       	cp.w	r8,lr
8000c18c:	fe 9b ff f9 	brhi	8000c17e <__mdiff+0x1e>
8000c190:	c4 98       	rjmp	8000c222 <__mdiff+0xc2>
8000c192:	58 05       	cp.w	r5,0
8000c194:	c0 64       	brge	8000c1a0 <__mdiff+0x40>
8000c196:	0e 98       	mov	r8,r7
8000c198:	30 15       	mov	r5,1
8000c19a:	0c 97       	mov	r7,r6
8000c19c:	10 96       	mov	r6,r8
8000c19e:	c0 28       	rjmp	8000c1a2 <__mdiff+0x42>
8000c1a0:	30 05       	mov	r5,0
8000c1a2:	6e 1b       	ld.w	r11,r7[0x4]
8000c1a4:	c5 6f       	rcall	8000c050 <_Balloc>
8000c1a6:	6e 49       	ld.w	r9,r7[0x10]
8000c1a8:	6c 44       	ld.w	r4,r6[0x10]
8000c1aa:	99 35       	st.w	r12[0xc],r5
8000c1ac:	2f b4       	sub	r4,-5
8000c1ae:	f2 c5 ff fb 	sub	r5,r9,-5
8000c1b2:	ec 04 00 24 	add	r4,r6,r4<<0x2
8000c1b6:	ee 05 00 25 	add	r5,r7,r5<<0x2
8000c1ba:	2e c6       	sub	r6,-20
8000c1bc:	2e c7       	sub	r7,-20
8000c1be:	f8 c8 ff ec 	sub	r8,r12,-20
8000c1c2:	30 0a       	mov	r10,0
8000c1c4:	0f 0e       	ld.w	lr,r7++
8000c1c6:	0d 0b       	ld.w	r11,r6++
8000c1c8:	fc 02 16 10 	lsr	r2,lr,0x10
8000c1cc:	f6 03 16 10 	lsr	r3,r11,0x10
8000c1d0:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000c1d4:	e4 03 01 03 	sub	r3,r2,r3
8000c1d8:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000c1dc:	fc 0b 01 0b 	sub	r11,lr,r11
8000c1e0:	f6 0a 00 0a 	add	r10,r11,r10
8000c1e4:	b0 1a       	st.h	r8[0x2],r10
8000c1e6:	b1 4a       	asr	r10,0x10
8000c1e8:	e6 0a 00 0a 	add	r10,r3,r10
8000c1ec:	b0 0a       	st.h	r8[0x0],r10
8000c1ee:	2f c8       	sub	r8,-4
8000c1f0:	b1 4a       	asr	r10,0x10
8000c1f2:	08 36       	cp.w	r6,r4
8000c1f4:	ce 83       	brcs	8000c1c4 <__mdiff+0x64>
8000c1f6:	c0 d8       	rjmp	8000c210 <__mdiff+0xb0>
8000c1f8:	0f 0b       	ld.w	r11,r7++
8000c1fa:	f6 0e 16 10 	lsr	lr,r11,0x10
8000c1fe:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000c202:	16 0a       	add	r10,r11
8000c204:	b0 1a       	st.h	r8[0x2],r10
8000c206:	b1 4a       	asr	r10,0x10
8000c208:	1c 0a       	add	r10,lr
8000c20a:	b0 0a       	st.h	r8[0x0],r10
8000c20c:	2f c8       	sub	r8,-4
8000c20e:	b1 4a       	asr	r10,0x10
8000c210:	0a 37       	cp.w	r7,r5
8000c212:	cf 33       	brcs	8000c1f8 <__mdiff+0x98>
8000c214:	c0 28       	rjmp	8000c218 <__mdiff+0xb8>
8000c216:	20 19       	sub	r9,1
8000c218:	11 4a       	ld.w	r10,--r8
8000c21a:	58 0a       	cp.w	r10,0
8000c21c:	cf d0       	breq	8000c216 <__mdiff+0xb6>
8000c21e:	99 49       	st.w	r12[0x10],r9
8000c220:	d8 32       	popm	r0-r7,pc
8000c222:	30 0b       	mov	r11,0
8000c224:	c1 6f       	rcall	8000c050 <_Balloc>
8000c226:	30 18       	mov	r8,1
8000c228:	99 48       	st.w	r12[0x10],r8
8000c22a:	30 08       	mov	r8,0
8000c22c:	99 58       	st.w	r12[0x14],r8
8000c22e:	d8 32       	popm	r0-r7,pc

8000c230 <__lshift>:
8000c230:	d4 31       	pushm	r0-r7,lr
8000c232:	16 97       	mov	r7,r11
8000c234:	76 46       	ld.w	r6,r11[0x10]
8000c236:	f4 02 14 05 	asr	r2,r10,0x5
8000c23a:	2f f6       	sub	r6,-1
8000c23c:	14 93       	mov	r3,r10
8000c23e:	18 94       	mov	r4,r12
8000c240:	04 06       	add	r6,r2
8000c242:	76 1b       	ld.w	r11,r11[0x4]
8000c244:	6e 28       	ld.w	r8,r7[0x8]
8000c246:	c0 38       	rjmp	8000c24c <__lshift+0x1c>
8000c248:	2f fb       	sub	r11,-1
8000c24a:	a1 78       	lsl	r8,0x1
8000c24c:	10 36       	cp.w	r6,r8
8000c24e:	fe 99 ff fd 	brgt	8000c248 <__lshift+0x18>
8000c252:	08 9c       	mov	r12,r4
8000c254:	cf ee       	rcall	8000c050 <_Balloc>
8000c256:	30 09       	mov	r9,0
8000c258:	18 95       	mov	r5,r12
8000c25a:	f8 c8 ff ec 	sub	r8,r12,-20
8000c25e:	12 9a       	mov	r10,r9
8000c260:	c0 38       	rjmp	8000c266 <__lshift+0x36>
8000c262:	10 aa       	st.w	r8++,r10
8000c264:	2f f9       	sub	r9,-1
8000c266:	04 39       	cp.w	r9,r2
8000c268:	cf d5       	brlt	8000c262 <__lshift+0x32>
8000c26a:	6e 4b       	ld.w	r11,r7[0x10]
8000c26c:	e7 d3 c0 05 	bfextu	r3,r3,0x0,0x5
8000c270:	2f bb       	sub	r11,-5
8000c272:	ee c9 ff ec 	sub	r9,r7,-20
8000c276:	ee 0b 00 2b 	add	r11,r7,r11<<0x2
8000c27a:	58 03       	cp.w	r3,0
8000c27c:	c1 30       	breq	8000c2a2 <__lshift+0x72>
8000c27e:	e6 0c 11 20 	rsub	r12,r3,32
8000c282:	30 0a       	mov	r10,0
8000c284:	72 02       	ld.w	r2,r9[0x0]
8000c286:	e4 03 09 42 	lsl	r2,r2,r3
8000c28a:	04 4a       	or	r10,r2
8000c28c:	10 aa       	st.w	r8++,r10
8000c28e:	13 0a       	ld.w	r10,r9++
8000c290:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000c294:	16 39       	cp.w	r9,r11
8000c296:	cf 73       	brcs	8000c284 <__lshift+0x54>
8000c298:	91 0a       	st.w	r8[0x0],r10
8000c29a:	58 0a       	cp.w	r10,0
8000c29c:	c0 70       	breq	8000c2aa <__lshift+0x7a>
8000c29e:	2f f6       	sub	r6,-1
8000c2a0:	c0 58       	rjmp	8000c2aa <__lshift+0x7a>
8000c2a2:	13 0a       	ld.w	r10,r9++
8000c2a4:	10 aa       	st.w	r8++,r10
8000c2a6:	16 39       	cp.w	r9,r11
8000c2a8:	cf d3       	brcs	8000c2a2 <__lshift+0x72>
8000c2aa:	08 9c       	mov	r12,r4
8000c2ac:	20 16       	sub	r6,1
8000c2ae:	0e 9b       	mov	r11,r7
8000c2b0:	8b 46       	st.w	r5[0x10],r6
8000c2b2:	cb 5e       	rcall	8000c01c <_Bfree>
8000c2b4:	0a 9c       	mov	r12,r5
8000c2b6:	d8 32       	popm	r0-r7,pc

8000c2b8 <__multiply>:
8000c2b8:	d4 31       	pushm	r0-r7,lr
8000c2ba:	20 2d       	sub	sp,8
8000c2bc:	76 49       	ld.w	r9,r11[0x10]
8000c2be:	74 48       	ld.w	r8,r10[0x10]
8000c2c0:	16 96       	mov	r6,r11
8000c2c2:	14 95       	mov	r5,r10
8000c2c4:	10 39       	cp.w	r9,r8
8000c2c6:	ec 08 17 50 	movlt	r8,r6
8000c2ca:	ea 06 17 50 	movlt	r6,r5
8000c2ce:	f0 05 17 50 	movlt	r5,r8
8000c2d2:	6c 28       	ld.w	r8,r6[0x8]
8000c2d4:	76 43       	ld.w	r3,r11[0x10]
8000c2d6:	74 42       	ld.w	r2,r10[0x10]
8000c2d8:	76 1b       	ld.w	r11,r11[0x4]
8000c2da:	e4 03 00 07 	add	r7,r2,r3
8000c2de:	10 37       	cp.w	r7,r8
8000c2e0:	f7 bb 09 ff 	subgt	r11,-1
8000c2e4:	cb 6e       	rcall	8000c050 <_Balloc>
8000c2e6:	ee c4 ff fb 	sub	r4,r7,-5
8000c2ea:	f8 c9 ff ec 	sub	r9,r12,-20
8000c2ee:	f8 04 00 24 	add	r4,r12,r4<<0x2
8000c2f2:	30 0a       	mov	r10,0
8000c2f4:	12 98       	mov	r8,r9
8000c2f6:	c0 28       	rjmp	8000c2fa <__multiply+0x42>
8000c2f8:	10 aa       	st.w	r8++,r10
8000c2fa:	08 38       	cp.w	r8,r4
8000c2fc:	cf e3       	brcs	8000c2f8 <__multiply+0x40>
8000c2fe:	2f b3       	sub	r3,-5
8000c300:	2f b2       	sub	r2,-5
8000c302:	ec 03 00 23 	add	r3,r6,r3<<0x2
8000c306:	ea 02 00 22 	add	r2,r5,r2<<0x2
8000c30a:	ec cb ff ec 	sub	r11,r6,-20
8000c30e:	50 12       	stdsp	sp[0x4],r2
8000c310:	ea ca ff ec 	sub	r10,r5,-20
8000c314:	c4 48       	rjmp	8000c39c <__multiply+0xe4>
8000c316:	94 95       	ld.uh	r5,r10[0x2]
8000c318:	58 05       	cp.w	r5,0
8000c31a:	c2 00       	breq	8000c35a <__multiply+0xa2>
8000c31c:	12 98       	mov	r8,r9
8000c31e:	16 96       	mov	r6,r11
8000c320:	30 0e       	mov	lr,0
8000c322:	50 09       	stdsp	sp[0x0],r9
8000c324:	0d 02       	ld.w	r2,r6++
8000c326:	e4 00 16 10 	lsr	r0,r2,0x10
8000c32a:	70 01       	ld.w	r1,r8[0x0]
8000c32c:	70 09       	ld.w	r9,r8[0x0]
8000c32e:	b1 81       	lsr	r1,0x10
8000c330:	e5 d2 c0 10 	bfextu	r2,r2,0x0,0x10
8000c334:	e0 05 03 41 	mac	r1,r0,r5
8000c338:	ab 32       	mul	r2,r5
8000c33a:	e1 d9 c0 10 	bfextu	r0,r9,0x0,0x10
8000c33e:	00 02       	add	r2,r0
8000c340:	e4 0e 00 0e 	add	lr,r2,lr
8000c344:	b0 1e       	st.h	r8[0x2],lr
8000c346:	b1 8e       	lsr	lr,0x10
8000c348:	1c 01       	add	r1,lr
8000c34a:	b0 01       	st.h	r8[0x0],r1
8000c34c:	e2 0e 16 10 	lsr	lr,r1,0x10
8000c350:	2f c8       	sub	r8,-4
8000c352:	06 36       	cp.w	r6,r3
8000c354:	ce 83       	brcs	8000c324 <__multiply+0x6c>
8000c356:	40 09       	lddsp	r9,sp[0x0]
8000c358:	91 0e       	st.w	r8[0x0],lr
8000c35a:	94 86       	ld.uh	r6,r10[0x0]
8000c35c:	58 06       	cp.w	r6,0
8000c35e:	c1 d0       	breq	8000c398 <__multiply+0xe0>
8000c360:	72 02       	ld.w	r2,r9[0x0]
8000c362:	12 98       	mov	r8,r9
8000c364:	16 9e       	mov	lr,r11
8000c366:	30 05       	mov	r5,0
8000c368:	b0 12       	st.h	r8[0x2],r2
8000c36a:	1d 01       	ld.w	r1,lr++
8000c36c:	90 82       	ld.uh	r2,r8[0x0]
8000c36e:	e1 d1 c0 10 	bfextu	r0,r1,0x0,0x10
8000c372:	ad 30       	mul	r0,r6
8000c374:	e0 02 00 02 	add	r2,r0,r2
8000c378:	e4 05 00 05 	add	r5,r2,r5
8000c37c:	b0 05       	st.h	r8[0x0],r5
8000c37e:	b1 85       	lsr	r5,0x10
8000c380:	b1 81       	lsr	r1,0x10
8000c382:	2f c8       	sub	r8,-4
8000c384:	ad 31       	mul	r1,r6
8000c386:	90 92       	ld.uh	r2,r8[0x2]
8000c388:	e2 02 00 02 	add	r2,r1,r2
8000c38c:	0a 02       	add	r2,r5
8000c38e:	e4 05 16 10 	lsr	r5,r2,0x10
8000c392:	06 3e       	cp.w	lr,r3
8000c394:	ce a3       	brcs	8000c368 <__multiply+0xb0>
8000c396:	91 02       	st.w	r8[0x0],r2
8000c398:	2f ca       	sub	r10,-4
8000c39a:	2f c9       	sub	r9,-4
8000c39c:	40 18       	lddsp	r8,sp[0x4]
8000c39e:	10 3a       	cp.w	r10,r8
8000c3a0:	cb b3       	brcs	8000c316 <__multiply+0x5e>
8000c3a2:	c0 28       	rjmp	8000c3a6 <__multiply+0xee>
8000c3a4:	20 17       	sub	r7,1
8000c3a6:	58 07       	cp.w	r7,0
8000c3a8:	e0 8a 00 05 	brle	8000c3b2 <__multiply+0xfa>
8000c3ac:	09 48       	ld.w	r8,--r4
8000c3ae:	58 08       	cp.w	r8,0
8000c3b0:	cf a0       	breq	8000c3a4 <__multiply+0xec>
8000c3b2:	99 47       	st.w	r12[0x10],r7
8000c3b4:	2f ed       	sub	sp,-8
8000c3b6:	d8 32       	popm	r0-r7,pc

8000c3b8 <__i2b>:
8000c3b8:	d4 21       	pushm	r4-r7,lr
8000c3ba:	16 97       	mov	r7,r11
8000c3bc:	30 1b       	mov	r11,1
8000c3be:	c4 9e       	rcall	8000c050 <_Balloc>
8000c3c0:	30 19       	mov	r9,1
8000c3c2:	99 57       	st.w	r12[0x14],r7
8000c3c4:	99 49       	st.w	r12[0x10],r9
8000c3c6:	d8 22       	popm	r4-r7,pc

8000c3c8 <__multadd>:
8000c3c8:	d4 31       	pushm	r0-r7,lr
8000c3ca:	30 08       	mov	r8,0
8000c3cc:	12 95       	mov	r5,r9
8000c3ce:	16 97       	mov	r7,r11
8000c3d0:	18 96       	mov	r6,r12
8000c3d2:	76 44       	ld.w	r4,r11[0x10]
8000c3d4:	f6 c9 ff ec 	sub	r9,r11,-20
8000c3d8:	72 0b       	ld.w	r11,r9[0x0]
8000c3da:	f6 0c 16 10 	lsr	r12,r11,0x10
8000c3de:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000c3e2:	f4 0c 02 4c 	mul	r12,r10,r12
8000c3e6:	f4 0b 03 45 	mac	r5,r10,r11
8000c3ea:	f7 d5 c0 10 	bfextu	r11,r5,0x0,0x10
8000c3ee:	b1 85       	lsr	r5,0x10
8000c3f0:	18 05       	add	r5,r12
8000c3f2:	ea 0c 15 10 	lsl	r12,r5,0x10
8000c3f6:	f8 0b 00 0b 	add	r11,r12,r11
8000c3fa:	12 ab       	st.w	r9++,r11
8000c3fc:	2f f8       	sub	r8,-1
8000c3fe:	b1 85       	lsr	r5,0x10
8000c400:	08 38       	cp.w	r8,r4
8000c402:	ce b5       	brlt	8000c3d8 <__multadd+0x10>
8000c404:	58 05       	cp.w	r5,0
8000c406:	c1 c0       	breq	8000c43e <__multadd+0x76>
8000c408:	6e 28       	ld.w	r8,r7[0x8]
8000c40a:	10 34       	cp.w	r4,r8
8000c40c:	c1 35       	brlt	8000c432 <__multadd+0x6a>
8000c40e:	6e 1b       	ld.w	r11,r7[0x4]
8000c410:	0c 9c       	mov	r12,r6
8000c412:	2f fb       	sub	r11,-1
8000c414:	c1 ee       	rcall	8000c050 <_Balloc>
8000c416:	6e 4a       	ld.w	r10,r7[0x10]
8000c418:	ee cb ff f4 	sub	r11,r7,-12
8000c41c:	18 93       	mov	r3,r12
8000c41e:	2f ea       	sub	r10,-2
8000c420:	2f 4c       	sub	r12,-12
8000c422:	a3 6a       	lsl	r10,0x2
8000c424:	fe b0 de 71 	rcall	80008106 <memcpy>
8000c428:	0e 9b       	mov	r11,r7
8000c42a:	0c 9c       	mov	r12,r6
8000c42c:	fe b0 fd f8 	rcall	8000c01c <_Bfree>
8000c430:	06 97       	mov	r7,r3
8000c432:	e8 c8 ff ff 	sub	r8,r4,-1
8000c436:	2f b4       	sub	r4,-5
8000c438:	8f 48       	st.w	r7[0x10],r8
8000c43a:	ee 04 09 25 	st.w	r7[r4<<0x2],r5
8000c43e:	0e 9c       	mov	r12,r7
8000c440:	d8 32       	popm	r0-r7,pc
8000c442:	d7 03       	nop

8000c444 <__pow5mult>:
8000c444:	d4 31       	pushm	r0-r7,lr
8000c446:	14 96       	mov	r6,r10
8000c448:	18 97       	mov	r7,r12
8000c44a:	16 94       	mov	r4,r11
8000c44c:	f1 da c0 02 	bfextu	r8,r10,0x0,0x2
8000c450:	c0 90       	breq	8000c462 <__pow5mult+0x1e>
8000c452:	20 18       	sub	r8,1
8000c454:	fe c9 d9 30 	sub	r9,pc,-9936
8000c458:	f2 08 03 2a 	ld.w	r10,r9[r8<<0x2]
8000c45c:	30 09       	mov	r9,0
8000c45e:	cb 5f       	rcall	8000c3c8 <__multadd>
8000c460:	18 94       	mov	r4,r12
8000c462:	a3 46       	asr	r6,0x2
8000c464:	c3 40       	breq	8000c4cc <__pow5mult+0x88>
8000c466:	6e 95       	ld.w	r5,r7[0x24]
8000c468:	58 05       	cp.w	r5,0
8000c46a:	c0 91       	brne	8000c47c <__pow5mult+0x38>
8000c46c:	31 0c       	mov	r12,16
8000c46e:	fe b0 dc 15 	rcall	80007c98 <malloc>
8000c472:	99 35       	st.w	r12[0xc],r5
8000c474:	8f 9c       	st.w	r7[0x24],r12
8000c476:	99 15       	st.w	r12[0x4],r5
8000c478:	99 25       	st.w	r12[0x8],r5
8000c47a:	99 05       	st.w	r12[0x0],r5
8000c47c:	6e 93       	ld.w	r3,r7[0x24]
8000c47e:	66 25       	ld.w	r5,r3[0x8]
8000c480:	58 05       	cp.w	r5,0
8000c482:	c0 c1       	brne	8000c49a <__pow5mult+0x56>
8000c484:	e0 6b 02 71 	mov	r11,625
8000c488:	0e 9c       	mov	r12,r7
8000c48a:	c9 7f       	rcall	8000c3b8 <__i2b>
8000c48c:	87 2c       	st.w	r3[0x8],r12
8000c48e:	30 08       	mov	r8,0
8000c490:	18 95       	mov	r5,r12
8000c492:	99 08       	st.w	r12[0x0],r8
8000c494:	c0 38       	rjmp	8000c49a <__pow5mult+0x56>
8000c496:	06 9c       	mov	r12,r3
8000c498:	18 95       	mov	r5,r12
8000c49a:	ed b6 00 00 	bld	r6,0x0
8000c49e:	c0 b1       	brne	8000c4b4 <__pow5mult+0x70>
8000c4a0:	08 9b       	mov	r11,r4
8000c4a2:	0a 9a       	mov	r10,r5
8000c4a4:	0e 9c       	mov	r12,r7
8000c4a6:	c0 9f       	rcall	8000c2b8 <__multiply>
8000c4a8:	08 9b       	mov	r11,r4
8000c4aa:	18 93       	mov	r3,r12
8000c4ac:	0e 9c       	mov	r12,r7
8000c4ae:	06 94       	mov	r4,r3
8000c4b0:	fe b0 fd b6 	rcall	8000c01c <_Bfree>
8000c4b4:	a1 56       	asr	r6,0x1
8000c4b6:	c0 b0       	breq	8000c4cc <__pow5mult+0x88>
8000c4b8:	6a 03       	ld.w	r3,r5[0x0]
8000c4ba:	58 03       	cp.w	r3,0
8000c4bc:	ce d1       	brne	8000c496 <__pow5mult+0x52>
8000c4be:	0a 9a       	mov	r10,r5
8000c4c0:	0a 9b       	mov	r11,r5
8000c4c2:	0e 9c       	mov	r12,r7
8000c4c4:	cf ae       	rcall	8000c2b8 <__multiply>
8000c4c6:	8b 0c       	st.w	r5[0x0],r12
8000c4c8:	99 03       	st.w	r12[0x0],r3
8000c4ca:	ce 7b       	rjmp	8000c498 <__pow5mult+0x54>
8000c4cc:	08 9c       	mov	r12,r4
8000c4ce:	d8 32       	popm	r0-r7,pc

8000c4d0 <__isinfd>:
8000c4d0:	14 98       	mov	r8,r10
8000c4d2:	fc 19 7f f0 	movh	r9,0x7ff0
8000c4d6:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000c4da:	f0 0b 11 00 	rsub	r11,r8,0
8000c4de:	f7 e8 10 08 	or	r8,r11,r8
8000c4e2:	f5 e8 13 f8 	or	r8,r10,r8>>0x1f
8000c4e6:	f2 08 01 08 	sub	r8,r9,r8
8000c4ea:	f0 0c 11 00 	rsub	r12,r8,0
8000c4ee:	f9 e8 10 08 	or	r8,r12,r8
8000c4f2:	f0 0c 14 1f 	asr	r12,r8,0x1f
8000c4f6:	2f fc       	sub	r12,-1
8000c4f8:	5e fc       	retal	r12

8000c4fa <__isnand>:
8000c4fa:	14 98       	mov	r8,r10
8000c4fc:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000c500:	f0 0c 11 00 	rsub	r12,r8,0
8000c504:	10 4c       	or	r12,r8
8000c506:	fc 18 7f f0 	movh	r8,0x7ff0
8000c50a:	f5 ec 13 fc 	or	r12,r10,r12>>0x1f
8000c50e:	f0 0c 01 0c 	sub	r12,r8,r12
8000c512:	bf 9c       	lsr	r12,0x1f
8000c514:	5e fc       	retal	r12
8000c516:	d7 03       	nop

8000c518 <__sclose>:
8000c518:	d4 01       	pushm	lr
8000c51a:	96 7b       	ld.sh	r11,r11[0xe]
8000c51c:	c8 2c       	rcall	8000c620 <_close_r>
8000c51e:	d8 02       	popm	pc

8000c520 <__sseek>:
8000c520:	d4 21       	pushm	r4-r7,lr
8000c522:	16 97       	mov	r7,r11
8000c524:	96 7b       	ld.sh	r11,r11[0xe]
8000c526:	c0 3d       	rcall	8000c72c <_lseek_r>
8000c528:	8e 68       	ld.sh	r8,r7[0xc]
8000c52a:	10 99       	mov	r9,r8
8000c52c:	ad c8       	cbr	r8,0xc
8000c52e:	ad a9       	sbr	r9,0xc
8000c530:	5b fc       	cp.w	r12,-1
8000c532:	ef f8 0c 06 	st.heq	r7[0xc],r8
8000c536:	ef f9 1c 06 	st.hne	r7[0xc],r9
8000c53a:	ef fc 1a 15 	st.wne	r7[0x54],r12
8000c53e:	d8 22       	popm	r4-r7,pc

8000c540 <__swrite>:
8000c540:	d4 21       	pushm	r4-r7,lr
8000c542:	96 68       	ld.sh	r8,r11[0xc]
8000c544:	16 97       	mov	r7,r11
8000c546:	14 95       	mov	r5,r10
8000c548:	12 94       	mov	r4,r9
8000c54a:	e2 18 01 00 	andl	r8,0x100,COH
8000c54e:	18 96       	mov	r6,r12
8000c550:	c0 50       	breq	8000c55a <__swrite+0x1a>
8000c552:	30 29       	mov	r9,2
8000c554:	30 0a       	mov	r10,0
8000c556:	96 7b       	ld.sh	r11,r11[0xe]
8000c558:	ce ac       	rcall	8000c72c <_lseek_r>
8000c55a:	8e 68       	ld.sh	r8,r7[0xc]
8000c55c:	ad c8       	cbr	r8,0xc
8000c55e:	08 99       	mov	r9,r4
8000c560:	0a 9a       	mov	r10,r5
8000c562:	8e 7b       	ld.sh	r11,r7[0xe]
8000c564:	0c 9c       	mov	r12,r6
8000c566:	ae 68       	st.h	r7[0xc],r8
8000c568:	c1 cc       	rcall	8000c5a0 <_write_r>
8000c56a:	d8 22       	popm	r4-r7,pc

8000c56c <__sread>:
8000c56c:	d4 21       	pushm	r4-r7,lr
8000c56e:	16 97       	mov	r7,r11
8000c570:	96 7b       	ld.sh	r11,r11[0xe]
8000c572:	cf 1c       	rcall	8000c754 <_read_r>
8000c574:	c0 65       	brlt	8000c580 <__sread+0x14>
8000c576:	6f 58       	ld.w	r8,r7[0x54]
8000c578:	18 08       	add	r8,r12
8000c57a:	ef 48 00 54 	st.w	r7[84],r8
8000c57e:	d8 22       	popm	r4-r7,pc
8000c580:	8e 68       	ld.sh	r8,r7[0xc]
8000c582:	ad c8       	cbr	r8,0xc
8000c584:	ae 68       	st.h	r7[0xc],r8
8000c586:	d8 22       	popm	r4-r7,pc

8000c588 <strlen>:
8000c588:	30 09       	mov	r9,0
8000c58a:	18 98       	mov	r8,r12
8000c58c:	c0 28       	rjmp	8000c590 <strlen+0x8>
8000c58e:	2f f8       	sub	r8,-1
8000c590:	11 8a       	ld.ub	r10,r8[0x0]
8000c592:	f2 0a 18 00 	cp.b	r10,r9
8000c596:	cf c1       	brne	8000c58e <strlen+0x6>
8000c598:	f0 0c 01 0c 	sub	r12,r8,r12
8000c59c:	5e fc       	retal	r12
8000c59e:	d7 03       	nop

8000c5a0 <_write_r>:
8000c5a0:	d4 21       	pushm	r4-r7,lr
8000c5a2:	16 98       	mov	r8,r11
8000c5a4:	18 97       	mov	r7,r12
8000c5a6:	10 9c       	mov	r12,r8
8000c5a8:	30 08       	mov	r8,0
8000c5aa:	14 9b       	mov	r11,r10
8000c5ac:	e0 66 54 34 	mov	r6,21556
8000c5b0:	12 9a       	mov	r10,r9
8000c5b2:	8d 08       	st.w	r6[0x0],r8
8000c5b4:	fe b0 d1 5c 	rcall	8000686c <_write>
8000c5b8:	5b fc       	cp.w	r12,-1
8000c5ba:	c0 51       	brne	8000c5c4 <_write_r+0x24>
8000c5bc:	6c 08       	ld.w	r8,r6[0x0]
8000c5be:	58 08       	cp.w	r8,0
8000c5c0:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000c5c4:	d8 22       	popm	r4-r7,pc
8000c5c6:	d7 03       	nop

8000c5c8 <_calloc_r>:
8000c5c8:	d4 21       	pushm	r4-r7,lr
8000c5ca:	f4 0b 02 4b 	mul	r11,r10,r11
8000c5ce:	fe b0 db 6d 	rcall	80007ca8 <_malloc_r>
8000c5d2:	18 97       	mov	r7,r12
8000c5d4:	c2 30       	breq	8000c61a <_calloc_r+0x52>
8000c5d6:	f8 fa ff fc 	ld.w	r10,r12[-4]
8000c5da:	e0 1a ff fc 	andl	r10,0xfffc
8000c5de:	20 4a       	sub	r10,4
8000c5e0:	e0 4a 00 24 	cp.w	r10,36
8000c5e4:	e0 8b 00 18 	brhi	8000c614 <_calloc_r+0x4c>
8000c5e8:	18 98       	mov	r8,r12
8000c5ea:	59 3a       	cp.w	r10,19
8000c5ec:	e0 88 00 0f 	brls	8000c60a <_calloc_r+0x42>
8000c5f0:	30 09       	mov	r9,0
8000c5f2:	10 a9       	st.w	r8++,r9
8000c5f4:	10 a9       	st.w	r8++,r9
8000c5f6:	59 ba       	cp.w	r10,27
8000c5f8:	e0 88 00 09 	brls	8000c60a <_calloc_r+0x42>
8000c5fc:	10 a9       	st.w	r8++,r9
8000c5fe:	10 a9       	st.w	r8++,r9
8000c600:	e0 4a 00 24 	cp.w	r10,36
8000c604:	c0 31       	brne	8000c60a <_calloc_r+0x42>
8000c606:	10 a9       	st.w	r8++,r9
8000c608:	10 a9       	st.w	r8++,r9
8000c60a:	30 09       	mov	r9,0
8000c60c:	10 a9       	st.w	r8++,r9
8000c60e:	91 19       	st.w	r8[0x4],r9
8000c610:	91 09       	st.w	r8[0x0],r9
8000c612:	c0 48       	rjmp	8000c61a <_calloc_r+0x52>
8000c614:	30 0b       	mov	r11,0
8000c616:	fe b0 de 1c 	rcall	8000824e <memset>
8000c61a:	0e 9c       	mov	r12,r7
8000c61c:	d8 22       	popm	r4-r7,pc
8000c61e:	d7 03       	nop

8000c620 <_close_r>:
8000c620:	d4 21       	pushm	r4-r7,lr
8000c622:	30 08       	mov	r8,0
8000c624:	18 97       	mov	r7,r12
8000c626:	e0 66 54 34 	mov	r6,21556
8000c62a:	16 9c       	mov	r12,r11
8000c62c:	8d 08       	st.w	r6[0x0],r8
8000c62e:	fe b0 df b5 	rcall	80008598 <_close>
8000c632:	5b fc       	cp.w	r12,-1
8000c634:	c0 51       	brne	8000c63e <_close_r+0x1e>
8000c636:	6c 08       	ld.w	r8,r6[0x0]
8000c638:	58 08       	cp.w	r8,0
8000c63a:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000c63e:	d8 22       	popm	r4-r7,pc

8000c640 <_fclose_r>:
8000c640:	d4 21       	pushm	r4-r7,lr
8000c642:	18 96       	mov	r6,r12
8000c644:	16 97       	mov	r7,r11
8000c646:	58 0b       	cp.w	r11,0
8000c648:	c0 31       	brne	8000c64e <_fclose_r+0xe>
8000c64a:	16 95       	mov	r5,r11
8000c64c:	c5 38       	rjmp	8000c6f2 <_fclose_r+0xb2>
8000c64e:	fe b0 f8 a9 	rcall	8000b7a0 <__sfp_lock_acquire>
8000c652:	58 06       	cp.w	r6,0
8000c654:	c0 70       	breq	8000c662 <_fclose_r+0x22>
8000c656:	6c 68       	ld.w	r8,r6[0x18]
8000c658:	58 08       	cp.w	r8,0
8000c65a:	c0 41       	brne	8000c662 <_fclose_r+0x22>
8000c65c:	0c 9c       	mov	r12,r6
8000c65e:	fe b0 f8 f3 	rcall	8000b844 <__sinit>
8000c662:	fe c8 db e2 	sub	r8,pc,-9246
8000c666:	10 37       	cp.w	r7,r8
8000c668:	c0 31       	brne	8000c66e <_fclose_r+0x2e>
8000c66a:	6c 07       	ld.w	r7,r6[0x0]
8000c66c:	c0 c8       	rjmp	8000c684 <_fclose_r+0x44>
8000c66e:	fe c8 db ce 	sub	r8,pc,-9266
8000c672:	10 37       	cp.w	r7,r8
8000c674:	c0 31       	brne	8000c67a <_fclose_r+0x3a>
8000c676:	6c 17       	ld.w	r7,r6[0x4]
8000c678:	c0 68       	rjmp	8000c684 <_fclose_r+0x44>
8000c67a:	fe c8 db ba 	sub	r8,pc,-9286
8000c67e:	10 37       	cp.w	r7,r8
8000c680:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000c684:	8e 69       	ld.sh	r9,r7[0xc]
8000c686:	30 08       	mov	r8,0
8000c688:	f0 09 19 00 	cp.h	r9,r8
8000c68c:	c0 51       	brne	8000c696 <_fclose_r+0x56>
8000c68e:	fe b0 f8 8a 	rcall	8000b7a2 <__sfp_lock_release>
8000c692:	30 05       	mov	r5,0
8000c694:	c2 f8       	rjmp	8000c6f2 <_fclose_r+0xb2>
8000c696:	0e 9b       	mov	r11,r7
8000c698:	0c 9c       	mov	r12,r6
8000c69a:	fe b0 f7 fd 	rcall	8000b694 <_fflush_r>
8000c69e:	6e c8       	ld.w	r8,r7[0x30]
8000c6a0:	18 95       	mov	r5,r12
8000c6a2:	58 08       	cp.w	r8,0
8000c6a4:	c0 60       	breq	8000c6b0 <_fclose_r+0x70>
8000c6a6:	6e 8b       	ld.w	r11,r7[0x20]
8000c6a8:	0c 9c       	mov	r12,r6
8000c6aa:	5d 18       	icall	r8
8000c6ac:	f9 b5 05 ff 	movlt	r5,-1
8000c6b0:	8e 68       	ld.sh	r8,r7[0xc]
8000c6b2:	ed b8 00 07 	bld	r8,0x7
8000c6b6:	c0 51       	brne	8000c6c0 <_fclose_r+0x80>
8000c6b8:	6e 4b       	ld.w	r11,r7[0x10]
8000c6ba:	0c 9c       	mov	r12,r6
8000c6bc:	fe b0 f9 5e 	rcall	8000b978 <_free_r>
8000c6c0:	6e db       	ld.w	r11,r7[0x34]
8000c6c2:	58 0b       	cp.w	r11,0
8000c6c4:	c0 a0       	breq	8000c6d8 <_fclose_r+0x98>
8000c6c6:	ee c8 ff bc 	sub	r8,r7,-68
8000c6ca:	10 3b       	cp.w	r11,r8
8000c6cc:	c0 40       	breq	8000c6d4 <_fclose_r+0x94>
8000c6ce:	0c 9c       	mov	r12,r6
8000c6d0:	fe b0 f9 54 	rcall	8000b978 <_free_r>
8000c6d4:	30 08       	mov	r8,0
8000c6d6:	8f d8       	st.w	r7[0x34],r8
8000c6d8:	6f 2b       	ld.w	r11,r7[0x48]
8000c6da:	58 0b       	cp.w	r11,0
8000c6dc:	c0 70       	breq	8000c6ea <_fclose_r+0xaa>
8000c6de:	0c 9c       	mov	r12,r6
8000c6e0:	fe b0 f9 4c 	rcall	8000b978 <_free_r>
8000c6e4:	30 08       	mov	r8,0
8000c6e6:	ef 48 00 48 	st.w	r7[72],r8
8000c6ea:	30 08       	mov	r8,0
8000c6ec:	ae 68       	st.h	r7[0xc],r8
8000c6ee:	fe b0 f8 5a 	rcall	8000b7a2 <__sfp_lock_release>
8000c6f2:	0a 9c       	mov	r12,r5
8000c6f4:	d8 22       	popm	r4-r7,pc
8000c6f6:	d7 03       	nop

8000c6f8 <fclose>:
8000c6f8:	d4 01       	pushm	lr
8000c6fa:	e0 68 0a 4c 	mov	r8,2636
8000c6fe:	18 9b       	mov	r11,r12
8000c700:	70 0c       	ld.w	r12,r8[0x0]
8000c702:	c9 ff       	rcall	8000c640 <_fclose_r>
8000c704:	d8 02       	popm	pc
8000c706:	d7 03       	nop

8000c708 <_fstat_r>:
8000c708:	d4 21       	pushm	r4-r7,lr
8000c70a:	16 98       	mov	r8,r11
8000c70c:	18 97       	mov	r7,r12
8000c70e:	10 9c       	mov	r12,r8
8000c710:	30 08       	mov	r8,0
8000c712:	e0 66 54 34 	mov	r6,21556
8000c716:	14 9b       	mov	r11,r10
8000c718:	8d 08       	st.w	r6[0x0],r8
8000c71a:	fe b0 df 67 	rcall	800085e8 <_fstat>
8000c71e:	5b fc       	cp.w	r12,-1
8000c720:	c0 51       	brne	8000c72a <_fstat_r+0x22>
8000c722:	6c 08       	ld.w	r8,r6[0x0]
8000c724:	58 08       	cp.w	r8,0
8000c726:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000c72a:	d8 22       	popm	r4-r7,pc

8000c72c <_lseek_r>:
8000c72c:	d4 21       	pushm	r4-r7,lr
8000c72e:	16 98       	mov	r8,r11
8000c730:	18 97       	mov	r7,r12
8000c732:	10 9c       	mov	r12,r8
8000c734:	30 08       	mov	r8,0
8000c736:	14 9b       	mov	r11,r10
8000c738:	e0 66 54 34 	mov	r6,21556
8000c73c:	12 9a       	mov	r10,r9
8000c73e:	8d 08       	st.w	r6[0x0],r8
8000c740:	fe b0 df 36 	rcall	800085ac <_lseek>
8000c744:	5b fc       	cp.w	r12,-1
8000c746:	c0 51       	brne	8000c750 <_lseek_r+0x24>
8000c748:	6c 08       	ld.w	r8,r6[0x0]
8000c74a:	58 08       	cp.w	r8,0
8000c74c:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000c750:	d8 22       	popm	r4-r7,pc
8000c752:	d7 03       	nop

8000c754 <_read_r>:
8000c754:	d4 21       	pushm	r4-r7,lr
8000c756:	16 98       	mov	r8,r11
8000c758:	18 97       	mov	r7,r12
8000c75a:	10 9c       	mov	r12,r8
8000c75c:	30 08       	mov	r8,0
8000c75e:	14 9b       	mov	r11,r10
8000c760:	e0 66 54 34 	mov	r6,21556
8000c764:	12 9a       	mov	r10,r9
8000c766:	8d 08       	st.w	r6[0x0],r8
8000c768:	fe b0 d0 62 	rcall	8000682c <_read>
8000c76c:	5b fc       	cp.w	r12,-1
8000c76e:	c0 51       	brne	8000c778 <_read_r+0x24>
8000c770:	6c 08       	ld.w	r8,r6[0x0]
8000c772:	58 08       	cp.w	r8,0
8000c774:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000c778:	d8 22       	popm	r4-r7,pc
8000c77a:	d7 03       	nop

8000c77c <__avr32_f64_mul>:
8000c77c:	f5 eb 10 1c 	or	r12,r10,r11<<0x1
8000c780:	e0 80 00 dc 	breq	8000c938 <__avr32_f64_mul_op1_zero>
8000c784:	d4 21       	pushm	r4-r7,lr
8000c786:	f7 e9 20 0e 	eor	lr,r11,r9
8000c78a:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000c78e:	30 15       	mov	r5,1
8000c790:	c4 30       	breq	8000c816 <__avr32_f64_mul_op1_subnormal>
8000c792:	ab 6b       	lsl	r11,0xa
8000c794:	f7 ea 13 6b 	or	r11,r11,r10>>0x16
8000c798:	ab 6a       	lsl	r10,0xa
8000c79a:	f7 d5 d3 c2 	bfins	r11,r5,0x1e,0x2
8000c79e:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000c7a2:	c5 c0       	breq	8000c85a <__avr32_f64_mul_op2_subnormal>
8000c7a4:	a1 78       	lsl	r8,0x1
8000c7a6:	5c f9       	rol	r9
8000c7a8:	f3 d5 d2 ab 	bfins	r9,r5,0x15,0xb
8000c7ac:	e0 47 07 ff 	cp.w	r7,2047
8000c7b0:	c7 70       	breq	8000c89e <__avr32_f64_mul_op_nan_or_inf>
8000c7b2:	e0 46 07 ff 	cp.w	r6,2047
8000c7b6:	c7 40       	breq	8000c89e <__avr32_f64_mul_op_nan_or_inf>
8000c7b8:	ee 06 00 0c 	add	r12,r7,r6
8000c7bc:	e0 2c 03 fe 	sub	r12,1022
8000c7c0:	f6 08 06 44 	mulu.d	r4,r11,r8
8000c7c4:	f4 09 07 44 	macu.d	r4,r10,r9
8000c7c8:	f4 08 06 46 	mulu.d	r6,r10,r8
8000c7cc:	f6 09 06 4a 	mulu.d	r10,r11,r9
8000c7d0:	08 07       	add	r7,r4
8000c7d2:	f4 05 00 4a 	adc	r10,r10,r5
8000c7d6:	5c 0b       	acr	r11
8000c7d8:	ed bb 00 14 	bld	r11,0x14
8000c7dc:	c0 50       	breq	8000c7e6 <__avr32_f64_mul+0x6a>
8000c7de:	a1 77       	lsl	r7,0x1
8000c7e0:	5c fa       	rol	r10
8000c7e2:	5c fb       	rol	r11
8000c7e4:	20 1c       	sub	r12,1
8000c7e6:	58 0c       	cp.w	r12,0
8000c7e8:	e0 8a 00 6f 	brle	8000c8c6 <__avr32_f64_mul_res_subnormal>
8000c7ec:	e0 4c 07 ff 	cp.w	r12,2047
8000c7f0:	e0 84 00 9c 	brge	8000c928 <__avr32_f64_mul_res_inf>
8000c7f4:	f7 dc d2 8b 	bfins	r11,r12,0x14,0xb
8000c7f8:	ed ea 11 f6 	or	r6,r6,r10<<0x1f
8000c7fc:	ef e6 12 17 	or	r7,r7,r6>>0x1
8000c800:	ee 17 80 00 	eorh	r7,0x8000
8000c804:	f1 b7 04 20 	satu	r7,0x1
8000c808:	0e 0a       	add	r10,r7
8000c80a:	5c 0b       	acr	r11
8000c80c:	ed be 00 1f 	bld	lr,0x1f
8000c810:	ef bb 00 1f 	bst	r11,0x1f
8000c814:	d8 22       	popm	r4-r7,pc

8000c816 <__avr32_f64_mul_op1_subnormal>:
8000c816:	e4 1b 00 0f 	andh	r11,0xf
8000c81a:	f4 0c 12 00 	clz	r12,r10
8000c81e:	f6 06 12 00 	clz	r6,r11
8000c822:	f7 bc 03 e1 	sublo	r12,-31
8000c826:	f8 06 17 30 	movlo	r6,r12
8000c82a:	f7 b6 02 01 	subhs	r6,1
8000c82e:	e0 46 00 20 	cp.w	r6,32
8000c832:	c0 d4       	brge	8000c84c <__avr32_f64_mul_op1_subnormal+0x36>
8000c834:	ec 0c 11 20 	rsub	r12,r6,32
8000c838:	f6 06 09 4b 	lsl	r11,r11,r6
8000c83c:	f4 0c 0a 4c 	lsr	r12,r10,r12
8000c840:	18 4b       	or	r11,r12
8000c842:	f4 06 09 4a 	lsl	r10,r10,r6
8000c846:	20 b6       	sub	r6,11
8000c848:	0c 17       	sub	r7,r6
8000c84a:	ca ab       	rjmp	8000c79e <__avr32_f64_mul+0x22>
8000c84c:	f4 06 09 4b 	lsl	r11,r10,r6
8000c850:	c6 40       	breq	8000c918 <__avr32_f64_mul_res_zero>
8000c852:	30 0a       	mov	r10,0
8000c854:	20 b6       	sub	r6,11
8000c856:	0c 17       	sub	r7,r6
8000c858:	ca 3b       	rjmp	8000c79e <__avr32_f64_mul+0x22>

8000c85a <__avr32_f64_mul_op2_subnormal>:
8000c85a:	e4 19 00 0f 	andh	r9,0xf
8000c85e:	f0 0c 12 00 	clz	r12,r8
8000c862:	f2 05 12 00 	clz	r5,r9
8000c866:	f7 bc 03 ea 	sublo	r12,-22
8000c86a:	f8 05 17 30 	movlo	r5,r12
8000c86e:	f7 b5 02 0a 	subhs	r5,10
8000c872:	e0 45 00 20 	cp.w	r5,32
8000c876:	c0 d4       	brge	8000c890 <__avr32_f64_mul_op2_subnormal+0x36>
8000c878:	ea 0c 11 20 	rsub	r12,r5,32
8000c87c:	f2 05 09 49 	lsl	r9,r9,r5
8000c880:	f0 0c 0a 4c 	lsr	r12,r8,r12
8000c884:	18 49       	or	r9,r12
8000c886:	f0 05 09 48 	lsl	r8,r8,r5
8000c88a:	20 25       	sub	r5,2
8000c88c:	0a 16       	sub	r6,r5
8000c88e:	c8 fb       	rjmp	8000c7ac <__avr32_f64_mul+0x30>
8000c890:	f0 05 09 49 	lsl	r9,r8,r5
8000c894:	c4 20       	breq	8000c918 <__avr32_f64_mul_res_zero>
8000c896:	30 08       	mov	r8,0
8000c898:	20 25       	sub	r5,2
8000c89a:	0a 16       	sub	r6,r5
8000c89c:	c8 8b       	rjmp	8000c7ac <__avr32_f64_mul+0x30>

8000c89e <__avr32_f64_mul_op_nan_or_inf>:
8000c89e:	e4 19 00 0f 	andh	r9,0xf
8000c8a2:	e4 1b 00 0f 	andh	r11,0xf
8000c8a6:	14 4b       	or	r11,r10
8000c8a8:	10 49       	or	r9,r8
8000c8aa:	e0 47 07 ff 	cp.w	r7,2047
8000c8ae:	c0 91       	brne	8000c8c0 <__avr32_f64_mul_op1_not_naninf>
8000c8b0:	58 0b       	cp.w	r11,0
8000c8b2:	c3 81       	brne	8000c922 <__avr32_f64_mul_res_nan>
8000c8b4:	e0 46 07 ff 	cp.w	r6,2047
8000c8b8:	c3 81       	brne	8000c928 <__avr32_f64_mul_res_inf>
8000c8ba:	58 09       	cp.w	r9,0
8000c8bc:	c3 60       	breq	8000c928 <__avr32_f64_mul_res_inf>
8000c8be:	c3 28       	rjmp	8000c922 <__avr32_f64_mul_res_nan>

8000c8c0 <__avr32_f64_mul_op1_not_naninf>:
8000c8c0:	58 09       	cp.w	r9,0
8000c8c2:	c3 30       	breq	8000c928 <__avr32_f64_mul_res_inf>
8000c8c4:	c2 f8       	rjmp	8000c922 <__avr32_f64_mul_res_nan>

8000c8c6 <__avr32_f64_mul_res_subnormal>:
8000c8c6:	5c 3c       	neg	r12
8000c8c8:	2f fc       	sub	r12,-1
8000c8ca:	f1 bc 04 c0 	satu	r12,0x6
8000c8ce:	e0 4c 00 20 	cp.w	r12,32
8000c8d2:	c1 14       	brge	8000c8f4 <__avr32_f64_mul_res_subnormal+0x2e>
8000c8d4:	f8 08 11 20 	rsub	r8,r12,32
8000c8d8:	0e 46       	or	r6,r7
8000c8da:	ee 0c 0a 47 	lsr	r7,r7,r12
8000c8de:	f4 08 09 49 	lsl	r9,r10,r8
8000c8e2:	12 47       	or	r7,r9
8000c8e4:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000c8e8:	f6 08 09 49 	lsl	r9,r11,r8
8000c8ec:	12 4a       	or	r10,r9
8000c8ee:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000c8f2:	c8 3b       	rjmp	8000c7f8 <__avr32_f64_mul+0x7c>
8000c8f4:	f8 08 11 20 	rsub	r8,r12,32
8000c8f8:	f9 b9 00 00 	moveq	r9,0
8000c8fc:	c0 30       	breq	8000c902 <__avr32_f64_mul_res_subnormal+0x3c>
8000c8fe:	f6 08 09 49 	lsl	r9,r11,r8
8000c902:	0e 46       	or	r6,r7
8000c904:	ed ea 10 16 	or	r6,r6,r10<<0x1
8000c908:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000c90c:	f3 ea 10 07 	or	r7,r9,r10
8000c910:	f6 0c 0a 4a 	lsr	r10,r11,r12
8000c914:	30 0b       	mov	r11,0
8000c916:	c7 1b       	rjmp	8000c7f8 <__avr32_f64_mul+0x7c>

8000c918 <__avr32_f64_mul_res_zero>:
8000c918:	1c 9b       	mov	r11,lr
8000c91a:	e6 1b 80 00 	andh	r11,0x8000,COH
8000c91e:	30 0a       	mov	r10,0
8000c920:	d8 22       	popm	r4-r7,pc

8000c922 <__avr32_f64_mul_res_nan>:
8000c922:	3f fb       	mov	r11,-1
8000c924:	3f fa       	mov	r10,-1
8000c926:	d8 22       	popm	r4-r7,pc

8000c928 <__avr32_f64_mul_res_inf>:
8000c928:	f0 6b 00 00 	mov	r11,-1048576
8000c92c:	ed be 00 1f 	bld	lr,0x1f
8000c930:	ef bb 00 1f 	bst	r11,0x1f
8000c934:	30 0a       	mov	r10,0
8000c936:	d8 22       	popm	r4-r7,pc

8000c938 <__avr32_f64_mul_op1_zero>:
8000c938:	f7 e9 20 0b 	eor	r11,r11,r9
8000c93c:	e6 1b 80 00 	andh	r11,0x8000,COH
8000c940:	f9 d9 c2 8b 	bfextu	r12,r9,0x14,0xb
8000c944:	e0 4c 07 ff 	cp.w	r12,2047
8000c948:	5e 1c       	retne	r12
8000c94a:	3f fa       	mov	r10,-1
8000c94c:	3f fb       	mov	r11,-1
8000c94e:	5e fc       	retal	r12

8000c950 <__avr32_f64_sub_from_add>:
8000c950:	ee 19 80 00 	eorh	r9,0x8000

8000c954 <__avr32_f64_sub>:
8000c954:	f7 e9 20 0c 	eor	r12,r11,r9
8000c958:	e0 86 00 ca 	brmi	8000caec <__avr32_f64_add_from_sub>
8000c95c:	eb cd 40 e0 	pushm	r5-r7,lr
8000c960:	16 9c       	mov	r12,r11
8000c962:	e6 1c 80 00 	andh	r12,0x8000,COH
8000c966:	bf db       	cbr	r11,0x1f
8000c968:	bf d9       	cbr	r9,0x1f
8000c96a:	10 3a       	cp.w	r10,r8
8000c96c:	f2 0b 13 00 	cpc	r11,r9
8000c970:	c0 92       	brcc	8000c982 <__avr32_f64_sub+0x2e>
8000c972:	16 97       	mov	r7,r11
8000c974:	12 9b       	mov	r11,r9
8000c976:	0e 99       	mov	r9,r7
8000c978:	14 97       	mov	r7,r10
8000c97a:	10 9a       	mov	r10,r8
8000c97c:	0e 98       	mov	r8,r7
8000c97e:	ee 1c 80 00 	eorh	r12,0x8000
8000c982:	f6 07 16 14 	lsr	r7,r11,0x14
8000c986:	ab 7b       	lsl	r11,0xb
8000c988:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000c98c:	ab 7a       	lsl	r10,0xb
8000c98e:	bf bb       	sbr	r11,0x1f
8000c990:	f2 06 16 14 	lsr	r6,r9,0x14
8000c994:	c4 40       	breq	8000ca1c <__avr32_f64_sub_opL_subnormal>
8000c996:	ab 79       	lsl	r9,0xb
8000c998:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000c99c:	ab 78       	lsl	r8,0xb
8000c99e:	bf b9       	sbr	r9,0x1f

8000c9a0 <__avr32_f64_sub_opL_subnormal_done>:
8000c9a0:	e0 47 07 ff 	cp.w	r7,2047
8000c9a4:	c4 f0       	breq	8000ca42 <__avr32_f64_sub_opH_nan_or_inf>
8000c9a6:	0e 26       	rsub	r6,r7
8000c9a8:	c1 20       	breq	8000c9cc <__avr32_f64_sub_shift_done>
8000c9aa:	ec 05 11 20 	rsub	r5,r6,32
8000c9ae:	e0 46 00 20 	cp.w	r6,32
8000c9b2:	c7 c2       	brcc	8000caaa <__avr32_f64_sub_longshift>
8000c9b4:	f0 05 09 4e 	lsl	lr,r8,r5
8000c9b8:	f2 05 09 45 	lsl	r5,r9,r5
8000c9bc:	f0 06 0a 48 	lsr	r8,r8,r6
8000c9c0:	f2 06 0a 49 	lsr	r9,r9,r6
8000c9c4:	0a 48       	or	r8,r5
8000c9c6:	58 0e       	cp.w	lr,0
8000c9c8:	5f 1e       	srne	lr
8000c9ca:	1c 48       	or	r8,lr

8000c9cc <__avr32_f64_sub_shift_done>:
8000c9cc:	10 1a       	sub	r10,r8
8000c9ce:	f6 09 01 4b 	sbc	r11,r11,r9
8000c9d2:	f6 06 12 00 	clz	r6,r11
8000c9d6:	c0 e0       	breq	8000c9f2 <__avr32_f64_sub_longnormalize_done>
8000c9d8:	c7 83       	brcs	8000cac8 <__avr32_f64_sub_longnormalize>
8000c9da:	ec 0e 11 20 	rsub	lr,r6,32
8000c9de:	f6 06 09 4b 	lsl	r11,r11,r6
8000c9e2:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000c9e6:	1c 4b       	or	r11,lr
8000c9e8:	f4 06 09 4a 	lsl	r10,r10,r6
8000c9ec:	0c 17       	sub	r7,r6
8000c9ee:	e0 8a 00 39 	brle	8000ca60 <__avr32_f64_sub_subnormal_result>

8000c9f2 <__avr32_f64_sub_longnormalize_done>:
8000c9f2:	f4 09 15 15 	lsl	r9,r10,0x15
8000c9f6:	ab 9a       	lsr	r10,0xb
8000c9f8:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000c9fc:	ab 9b       	lsr	r11,0xb
8000c9fe:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000ca02:	18 4b       	or	r11,r12

8000ca04 <__avr32_f64_sub_round>:
8000ca04:	fc 17 80 00 	movh	r7,0x8000
8000ca08:	ed ba 00 00 	bld	r10,0x0
8000ca0c:	f7 b7 01 ff 	subne	r7,-1
8000ca10:	0e 39       	cp.w	r9,r7
8000ca12:	5f 29       	srhs	r9
8000ca14:	12 0a       	add	r10,r9
8000ca16:	5c 0b       	acr	r11
8000ca18:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000ca1c <__avr32_f64_sub_opL_subnormal>:
8000ca1c:	ab 79       	lsl	r9,0xb
8000ca1e:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000ca22:	ab 78       	lsl	r8,0xb
8000ca24:	f3 e8 10 0e 	or	lr,r9,r8
8000ca28:	f9 b6 01 01 	movne	r6,1
8000ca2c:	ee 0e 11 00 	rsub	lr,r7,0
8000ca30:	f9 b7 00 01 	moveq	r7,1
8000ca34:	ef bb 00 1f 	bst	r11,0x1f
8000ca38:	f7 ea 10 0e 	or	lr,r11,r10
8000ca3c:	f9 b7 00 00 	moveq	r7,0
8000ca40:	cb 0b       	rjmp	8000c9a0 <__avr32_f64_sub_opL_subnormal_done>

8000ca42 <__avr32_f64_sub_opH_nan_or_inf>:
8000ca42:	bf db       	cbr	r11,0x1f
8000ca44:	f7 ea 10 0e 	or	lr,r11,r10
8000ca48:	c0 81       	brne	8000ca58 <__avr32_f64_sub_return_nan>
8000ca4a:	e0 46 07 ff 	cp.w	r6,2047
8000ca4e:	c0 50       	breq	8000ca58 <__avr32_f64_sub_return_nan>
8000ca50:	f9 e7 11 4b 	or	r11,r12,r7<<0x14
8000ca54:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000ca58 <__avr32_f64_sub_return_nan>:
8000ca58:	3f fa       	mov	r10,-1
8000ca5a:	3f fb       	mov	r11,-1
8000ca5c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000ca60 <__avr32_f64_sub_subnormal_result>:
8000ca60:	5c 37       	neg	r7
8000ca62:	2f f7       	sub	r7,-1
8000ca64:	f1 b7 04 c0 	satu	r7,0x6
8000ca68:	e0 47 00 20 	cp.w	r7,32
8000ca6c:	c1 14       	brge	8000ca8e <__avr32_f64_sub_subnormal_result+0x2e>
8000ca6e:	ee 08 11 20 	rsub	r8,r7,32
8000ca72:	f4 08 09 49 	lsl	r9,r10,r8
8000ca76:	5f 16       	srne	r6
8000ca78:	f4 07 0a 4a 	lsr	r10,r10,r7
8000ca7c:	0c 4a       	or	r10,r6
8000ca7e:	f6 08 09 49 	lsl	r9,r11,r8
8000ca82:	f5 e9 10 0a 	or	r10,r10,r9
8000ca86:	f4 07 0a 4b 	lsr	r11,r10,r7
8000ca8a:	30 07       	mov	r7,0
8000ca8c:	cb 3b       	rjmp	8000c9f2 <__avr32_f64_sub_longnormalize_done>
8000ca8e:	ee 08 11 40 	rsub	r8,r7,64
8000ca92:	f6 08 09 49 	lsl	r9,r11,r8
8000ca96:	14 49       	or	r9,r10
8000ca98:	5f 16       	srne	r6
8000ca9a:	f6 07 0a 4a 	lsr	r10,r11,r7
8000ca9e:	0c 4a       	or	r10,r6
8000caa0:	30 0b       	mov	r11,0
8000caa2:	30 07       	mov	r7,0
8000caa4:	ca 7b       	rjmp	8000c9f2 <__avr32_f64_sub_longnormalize_done>
8000caa6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000caaa <__avr32_f64_sub_longshift>:
8000caaa:	f1 b6 04 c0 	satu	r6,0x6
8000caae:	f0 0e 17 00 	moveq	lr,r8
8000cab2:	c0 40       	breq	8000caba <__avr32_f64_sub_longshift+0x10>
8000cab4:	f2 05 09 4e 	lsl	lr,r9,r5
8000cab8:	10 4e       	or	lr,r8
8000caba:	f2 06 0a 48 	lsr	r8,r9,r6
8000cabe:	30 09       	mov	r9,0
8000cac0:	58 0e       	cp.w	lr,0
8000cac2:	5f 1e       	srne	lr
8000cac4:	1c 48       	or	r8,lr
8000cac6:	c8 3b       	rjmp	8000c9cc <__avr32_f64_sub_shift_done>

8000cac8 <__avr32_f64_sub_longnormalize>:
8000cac8:	f4 06 12 00 	clz	r6,r10
8000cacc:	f9 b7 03 00 	movlo	r7,0
8000cad0:	f9 b6 03 00 	movlo	r6,0
8000cad4:	f9 bc 03 00 	movlo	r12,0
8000cad8:	f7 b6 02 e0 	subhs	r6,-32
8000cadc:	f4 06 09 4b 	lsl	r11,r10,r6
8000cae0:	30 0a       	mov	r10,0
8000cae2:	0c 17       	sub	r7,r6
8000cae4:	fe 9a ff be 	brle	8000ca60 <__avr32_f64_sub_subnormal_result>
8000cae8:	c8 5b       	rjmp	8000c9f2 <__avr32_f64_sub_longnormalize_done>
8000caea:	d7 03       	nop

8000caec <__avr32_f64_add_from_sub>:
8000caec:	ee 19 80 00 	eorh	r9,0x8000

8000caf0 <__avr32_f64_add>:
8000caf0:	f7 e9 20 0c 	eor	r12,r11,r9
8000caf4:	fe 96 ff 2e 	brmi	8000c950 <__avr32_f64_sub_from_add>
8000caf8:	eb cd 40 e0 	pushm	r5-r7,lr
8000cafc:	16 9c       	mov	r12,r11
8000cafe:	e6 1c 80 00 	andh	r12,0x8000,COH
8000cb02:	bf db       	cbr	r11,0x1f
8000cb04:	bf d9       	cbr	r9,0x1f
8000cb06:	12 3b       	cp.w	r11,r9
8000cb08:	c0 72       	brcc	8000cb16 <__avr32_f64_add+0x26>
8000cb0a:	16 97       	mov	r7,r11
8000cb0c:	12 9b       	mov	r11,r9
8000cb0e:	0e 99       	mov	r9,r7
8000cb10:	14 97       	mov	r7,r10
8000cb12:	10 9a       	mov	r10,r8
8000cb14:	0e 98       	mov	r8,r7
8000cb16:	30 0e       	mov	lr,0
8000cb18:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000cb1c:	f7 db c0 14 	bfextu	r11,r11,0x0,0x14
8000cb20:	b5 ab       	sbr	r11,0x14
8000cb22:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000cb26:	c6 20       	breq	8000cbea <__avr32_f64_add_op2_subnormal>
8000cb28:	f3 d9 c0 14 	bfextu	r9,r9,0x0,0x14
8000cb2c:	b5 a9       	sbr	r9,0x14
8000cb2e:	e0 47 07 ff 	cp.w	r7,2047
8000cb32:	c2 80       	breq	8000cb82 <__avr32_f64_add_opH_nan_or_inf>
8000cb34:	0e 26       	rsub	r6,r7
8000cb36:	c1 20       	breq	8000cb5a <__avr32_f64_add_shift_done>
8000cb38:	e0 46 00 36 	cp.w	r6,54
8000cb3c:	c1 52       	brcc	8000cb66 <__avr32_f64_add_res_of_done>
8000cb3e:	ec 05 11 20 	rsub	r5,r6,32
8000cb42:	e0 46 00 20 	cp.w	r6,32
8000cb46:	c3 52       	brcc	8000cbb0 <__avr32_f64_add_longshift>
8000cb48:	f0 05 09 4e 	lsl	lr,r8,r5
8000cb4c:	f2 05 09 45 	lsl	r5,r9,r5
8000cb50:	f0 06 0a 48 	lsr	r8,r8,r6
8000cb54:	f2 06 0a 49 	lsr	r9,r9,r6
8000cb58:	0a 48       	or	r8,r5

8000cb5a <__avr32_f64_add_shift_done>:
8000cb5a:	10 0a       	add	r10,r8
8000cb5c:	f6 09 00 4b 	adc	r11,r11,r9
8000cb60:	ed bb 00 15 	bld	r11,0x15
8000cb64:	c3 40       	breq	8000cbcc <__avr32_f64_add_res_of>

8000cb66 <__avr32_f64_add_res_of_done>:
8000cb66:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000cb6a:	18 4b       	or	r11,r12

8000cb6c <__avr32_f64_add_round>:
8000cb6c:	f9 da c0 01 	bfextu	r12,r10,0x0,0x1
8000cb70:	18 4e       	or	lr,r12
8000cb72:	ee 1e 80 00 	eorh	lr,0x8000
8000cb76:	f1 be 04 20 	satu	lr,0x1
8000cb7a:	1c 0a       	add	r10,lr
8000cb7c:	5c 0b       	acr	r11
8000cb7e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000cb82 <__avr32_f64_add_opH_nan_or_inf>:
8000cb82:	b5 cb       	cbr	r11,0x14
8000cb84:	f7 ea 10 0e 	or	lr,r11,r10
8000cb88:	c1 01       	brne	8000cba8 <__avr32_f64_add_return_nan>
8000cb8a:	e0 46 07 ff 	cp.w	r6,2047
8000cb8e:	c0 30       	breq	8000cb94 <__avr32_f64_add_opL_nan_or_inf>
8000cb90:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000cb94 <__avr32_f64_add_opL_nan_or_inf>:
8000cb94:	b5 c9       	cbr	r9,0x14
8000cb96:	f3 e8 10 0e 	or	lr,r9,r8
8000cb9a:	c0 71       	brne	8000cba8 <__avr32_f64_add_return_nan>
8000cb9c:	30 0a       	mov	r10,0
8000cb9e:	fc 1b 7f f0 	movh	r11,0x7ff0
8000cba2:	18 4b       	or	r11,r12
8000cba4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000cba8 <__avr32_f64_add_return_nan>:
8000cba8:	3f fa       	mov	r10,-1
8000cbaa:	3f fb       	mov	r11,-1
8000cbac:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000cbb0 <__avr32_f64_add_longshift>:
8000cbb0:	f1 b6 04 c0 	satu	r6,0x6
8000cbb4:	f0 0e 17 00 	moveq	lr,r8
8000cbb8:	c0 60       	breq	8000cbc4 <__avr32_f64_add_longshift+0x14>
8000cbba:	f2 05 09 4e 	lsl	lr,r9,r5
8000cbbe:	58 08       	cp.w	r8,0
8000cbc0:	5f 18       	srne	r8
8000cbc2:	10 4e       	or	lr,r8
8000cbc4:	f2 06 0a 48 	lsr	r8,r9,r6
8000cbc8:	30 09       	mov	r9,0
8000cbca:	cc 8b       	rjmp	8000cb5a <__avr32_f64_add_shift_done>

8000cbcc <__avr32_f64_add_res_of>:
8000cbcc:	fd ee 10 1e 	or	lr,lr,lr<<0x1
8000cbd0:	a1 9b       	lsr	r11,0x1
8000cbd2:	5d 0a       	ror	r10
8000cbd4:	5d 0e       	ror	lr
8000cbd6:	2f f7       	sub	r7,-1
8000cbd8:	e0 47 07 ff 	cp.w	r7,2047
8000cbdc:	f9 ba 00 00 	moveq	r10,0
8000cbe0:	f9 bb 00 00 	moveq	r11,0
8000cbe4:	f9 be 00 00 	moveq	lr,0
8000cbe8:	cb fb       	rjmp	8000cb66 <__avr32_f64_add_res_of_done>

8000cbea <__avr32_f64_add_op2_subnormal>:
8000cbea:	30 16       	mov	r6,1
8000cbec:	58 07       	cp.w	r7,0
8000cbee:	ca 01       	brne	8000cb2e <__avr32_f64_add+0x3e>
8000cbf0:	b5 cb       	cbr	r11,0x14
8000cbf2:	10 0a       	add	r10,r8
8000cbf4:	f6 09 00 4b 	adc	r11,r11,r9
8000cbf8:	18 4b       	or	r11,r12
8000cbfa:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000cbfe:	d7 03       	nop

8000cc00 <__avr32_f64_to_u32>:
8000cc00:	58 0b       	cp.w	r11,0
8000cc02:	5e 6d       	retmi	0

8000cc04 <__avr32_f64_to_s32>:
8000cc04:	f6 0c 15 01 	lsl	r12,r11,0x1
8000cc08:	b5 9c       	lsr	r12,0x15
8000cc0a:	e0 2c 03 ff 	sub	r12,1023
8000cc0e:	5e 3d       	retlo	0
8000cc10:	f8 0c 11 1f 	rsub	r12,r12,31
8000cc14:	16 99       	mov	r9,r11
8000cc16:	ab 7b       	lsl	r11,0xb
8000cc18:	bf bb       	sbr	r11,0x1f
8000cc1a:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000cc1e:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000cc22:	a1 79       	lsl	r9,0x1
8000cc24:	5e 2b       	reths	r11
8000cc26:	5c 3b       	neg	r11
8000cc28:	5e fb       	retal	r11

8000cc2a <__avr32_u32_to_f64>:
8000cc2a:	f8 cb 00 00 	sub	r11,r12,0
8000cc2e:	30 0c       	mov	r12,0
8000cc30:	c0 38       	rjmp	8000cc36 <__avr32_s32_to_f64+0x4>

8000cc32 <__avr32_s32_to_f64>:
8000cc32:	18 9b       	mov	r11,r12
8000cc34:	5c 4b       	abs	r11
8000cc36:	30 0a       	mov	r10,0
8000cc38:	5e 0b       	reteq	r11
8000cc3a:	d4 01       	pushm	lr
8000cc3c:	e0 69 04 1e 	mov	r9,1054
8000cc40:	f6 08 12 00 	clz	r8,r11
8000cc44:	c1 70       	breq	8000cc72 <__avr32_s32_to_f64+0x40>
8000cc46:	c0 c3       	brcs	8000cc5e <__avr32_s32_to_f64+0x2c>
8000cc48:	f0 0e 11 20 	rsub	lr,r8,32
8000cc4c:	f6 08 09 4b 	lsl	r11,r11,r8
8000cc50:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000cc54:	1c 4b       	or	r11,lr
8000cc56:	f4 08 09 4a 	lsl	r10,r10,r8
8000cc5a:	10 19       	sub	r9,r8
8000cc5c:	c0 b8       	rjmp	8000cc72 <__avr32_s32_to_f64+0x40>
8000cc5e:	f4 08 12 00 	clz	r8,r10
8000cc62:	f9 b8 03 00 	movlo	r8,0
8000cc66:	f7 b8 02 e0 	subhs	r8,-32
8000cc6a:	f4 08 09 4b 	lsl	r11,r10,r8
8000cc6e:	30 0a       	mov	r10,0
8000cc70:	10 19       	sub	r9,r8
8000cc72:	58 09       	cp.w	r9,0
8000cc74:	e0 89 00 30 	brgt	8000ccd4 <__avr32_s32_to_f64+0xa2>
8000cc78:	5c 39       	neg	r9
8000cc7a:	2f f9       	sub	r9,-1
8000cc7c:	e0 49 00 36 	cp.w	r9,54
8000cc80:	c0 43       	brcs	8000cc88 <__avr32_s32_to_f64+0x56>
8000cc82:	30 0b       	mov	r11,0
8000cc84:	30 0a       	mov	r10,0
8000cc86:	c2 68       	rjmp	8000ccd2 <__avr32_s32_to_f64+0xa0>
8000cc88:	2f 69       	sub	r9,-10
8000cc8a:	f2 08 11 20 	rsub	r8,r9,32
8000cc8e:	e0 49 00 20 	cp.w	r9,32
8000cc92:	c0 b2       	brcc	8000cca8 <__avr32_s32_to_f64+0x76>
8000cc94:	f4 08 09 4e 	lsl	lr,r10,r8
8000cc98:	f6 08 09 48 	lsl	r8,r11,r8
8000cc9c:	f4 09 0a 4a 	lsr	r10,r10,r9
8000cca0:	f6 09 0a 4b 	lsr	r11,r11,r9
8000cca4:	10 4b       	or	r11,r8
8000cca6:	c0 88       	rjmp	8000ccb6 <__avr32_s32_to_f64+0x84>
8000cca8:	f6 08 09 4e 	lsl	lr,r11,r8
8000ccac:	14 4e       	or	lr,r10
8000ccae:	16 9a       	mov	r10,r11
8000ccb0:	30 0b       	mov	r11,0
8000ccb2:	f4 09 0a 4a 	lsr	r10,r10,r9
8000ccb6:	ed ba 00 00 	bld	r10,0x0
8000ccba:	c0 92       	brcc	8000cccc <__avr32_s32_to_f64+0x9a>
8000ccbc:	1c 7e       	tst	lr,lr
8000ccbe:	c0 41       	brne	8000ccc6 <__avr32_s32_to_f64+0x94>
8000ccc0:	ed ba 00 01 	bld	r10,0x1
8000ccc4:	c0 42       	brcc	8000cccc <__avr32_s32_to_f64+0x9a>
8000ccc6:	2f fa       	sub	r10,-1
8000ccc8:	f7 bb 02 ff 	subhs	r11,-1
8000cccc:	5c fc       	rol	r12
8000ccce:	5d 0b       	ror	r11
8000ccd0:	5d 0a       	ror	r10
8000ccd2:	d8 02       	popm	pc
8000ccd4:	e0 68 03 ff 	mov	r8,1023
8000ccd8:	ed ba 00 0b 	bld	r10,0xb
8000ccdc:	f7 b8 00 ff 	subeq	r8,-1
8000cce0:	10 0a       	add	r10,r8
8000cce2:	5c 0b       	acr	r11
8000cce4:	f7 b9 03 fe 	sublo	r9,-2
8000cce8:	e0 49 07 ff 	cp.w	r9,2047
8000ccec:	c0 55       	brlt	8000ccf6 <__avr32_s32_to_f64+0xc4>
8000ccee:	30 0a       	mov	r10,0
8000ccf0:	fc 1b ff e0 	movh	r11,0xffe0
8000ccf4:	c0 c8       	rjmp	8000cd0c <__floatsidf_return_op1>
8000ccf6:	ed bb 00 1f 	bld	r11,0x1f
8000ccfa:	f7 b9 01 01 	subne	r9,1
8000ccfe:	ab 9a       	lsr	r10,0xb
8000cd00:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000cd04:	a1 7b       	lsl	r11,0x1
8000cd06:	ab 9b       	lsr	r11,0xb
8000cd08:	f7 e9 11 5b 	or	r11,r11,r9<<0x15

8000cd0c <__floatsidf_return_op1>:
8000cd0c:	a1 7c       	lsl	r12,0x1
8000cd0e:	5d 0b       	ror	r11
8000cd10:	d8 02       	popm	pc

8000cd12 <__avr32_f64_cmp_eq>:
8000cd12:	10 3a       	cp.w	r10,r8
8000cd14:	f2 0b 13 00 	cpc	r11,r9
8000cd18:	c0 80       	breq	8000cd28 <__avr32_f64_cmp_eq+0x16>
8000cd1a:	a1 7b       	lsl	r11,0x1
8000cd1c:	a1 79       	lsl	r9,0x1
8000cd1e:	14 4b       	or	r11,r10
8000cd20:	12 4b       	or	r11,r9
8000cd22:	10 4b       	or	r11,r8
8000cd24:	5e 0f       	reteq	1
8000cd26:	5e fd       	retal	0
8000cd28:	a1 7b       	lsl	r11,0x1
8000cd2a:	fc 1c ff e0 	movh	r12,0xffe0
8000cd2e:	58 0a       	cp.w	r10,0
8000cd30:	f8 0b 13 00 	cpc	r11,r12
8000cd34:	5e 8f       	retls	1
8000cd36:	5e fd       	retal	0

8000cd38 <__avr32_f64_cmp_ge>:
8000cd38:	1a de       	st.w	--sp,lr
8000cd3a:	1a d7       	st.w	--sp,r7
8000cd3c:	a1 7b       	lsl	r11,0x1
8000cd3e:	5f 3c       	srlo	r12
8000cd40:	a1 79       	lsl	r9,0x1
8000cd42:	5f 37       	srlo	r7
8000cd44:	5c fc       	rol	r12
8000cd46:	fc 1e ff e0 	movh	lr,0xffe0
8000cd4a:	58 0a       	cp.w	r10,0
8000cd4c:	fc 0b 13 00 	cpc	r11,lr
8000cd50:	e0 8b 00 1d 	brhi	8000cd8a <__avr32_f64_cmp_ge+0x52>
8000cd54:	58 08       	cp.w	r8,0
8000cd56:	fc 09 13 00 	cpc	r9,lr
8000cd5a:	e0 8b 00 18 	brhi	8000cd8a <__avr32_f64_cmp_ge+0x52>
8000cd5e:	58 0b       	cp.w	r11,0
8000cd60:	f5 ba 00 00 	subfeq	r10,0
8000cd64:	c1 50       	breq	8000cd8e <__avr32_f64_cmp_ge+0x56>
8000cd66:	1b 07       	ld.w	r7,sp++
8000cd68:	1b 0e       	ld.w	lr,sp++
8000cd6a:	58 3c       	cp.w	r12,3
8000cd6c:	c0 a0       	breq	8000cd80 <__avr32_f64_cmp_ge+0x48>
8000cd6e:	58 1c       	cp.w	r12,1
8000cd70:	c0 33       	brcs	8000cd76 <__avr32_f64_cmp_ge+0x3e>
8000cd72:	5e 0f       	reteq	1
8000cd74:	5e 1d       	retne	0
8000cd76:	10 3a       	cp.w	r10,r8
8000cd78:	f2 0b 13 00 	cpc	r11,r9
8000cd7c:	5e 2f       	reths	1
8000cd7e:	5e 3d       	retlo	0
8000cd80:	14 38       	cp.w	r8,r10
8000cd82:	f6 09 13 00 	cpc	r9,r11
8000cd86:	5e 2f       	reths	1
8000cd88:	5e 3d       	retlo	0
8000cd8a:	1b 07       	ld.w	r7,sp++
8000cd8c:	d8 0a       	popm	pc,r12=0
8000cd8e:	58 17       	cp.w	r7,1
8000cd90:	5f 0c       	sreq	r12
8000cd92:	58 09       	cp.w	r9,0
8000cd94:	f5 b8 00 00 	subfeq	r8,0
8000cd98:	1b 07       	ld.w	r7,sp++
8000cd9a:	1b 0e       	ld.w	lr,sp++
8000cd9c:	5e 0f       	reteq	1
8000cd9e:	5e fc       	retal	r12

8000cda0 <__avr32_f64_cmp_lt>:
8000cda0:	1a de       	st.w	--sp,lr
8000cda2:	1a d7       	st.w	--sp,r7
8000cda4:	a1 7b       	lsl	r11,0x1
8000cda6:	5f 3c       	srlo	r12
8000cda8:	a1 79       	lsl	r9,0x1
8000cdaa:	5f 37       	srlo	r7
8000cdac:	5c fc       	rol	r12
8000cdae:	fc 1e ff e0 	movh	lr,0xffe0
8000cdb2:	58 0a       	cp.w	r10,0
8000cdb4:	fc 0b 13 00 	cpc	r11,lr
8000cdb8:	e0 8b 00 1d 	brhi	8000cdf2 <__avr32_f64_cmp_lt+0x52>
8000cdbc:	58 08       	cp.w	r8,0
8000cdbe:	fc 09 13 00 	cpc	r9,lr
8000cdc2:	e0 8b 00 18 	brhi	8000cdf2 <__avr32_f64_cmp_lt+0x52>
8000cdc6:	58 0b       	cp.w	r11,0
8000cdc8:	f5 ba 00 00 	subfeq	r10,0
8000cdcc:	c1 50       	breq	8000cdf6 <__avr32_f64_cmp_lt+0x56>
8000cdce:	1b 07       	ld.w	r7,sp++
8000cdd0:	1b 0e       	ld.w	lr,sp++
8000cdd2:	58 3c       	cp.w	r12,3
8000cdd4:	c0 a0       	breq	8000cde8 <__avr32_f64_cmp_lt+0x48>
8000cdd6:	58 1c       	cp.w	r12,1
8000cdd8:	c0 33       	brcs	8000cdde <__avr32_f64_cmp_lt+0x3e>
8000cdda:	5e 0d       	reteq	0
8000cddc:	5e 1f       	retne	1
8000cdde:	10 3a       	cp.w	r10,r8
8000cde0:	f2 0b 13 00 	cpc	r11,r9
8000cde4:	5e 2d       	reths	0
8000cde6:	5e 3f       	retlo	1
8000cde8:	14 38       	cp.w	r8,r10
8000cdea:	f6 09 13 00 	cpc	r9,r11
8000cdee:	5e 2d       	reths	0
8000cdf0:	5e 3f       	retlo	1
8000cdf2:	1b 07       	ld.w	r7,sp++
8000cdf4:	d8 0a       	popm	pc,r12=0
8000cdf6:	58 17       	cp.w	r7,1
8000cdf8:	5f 1c       	srne	r12
8000cdfa:	58 09       	cp.w	r9,0
8000cdfc:	f5 b8 00 00 	subfeq	r8,0
8000ce00:	1b 07       	ld.w	r7,sp++
8000ce02:	1b 0e       	ld.w	lr,sp++
8000ce04:	5e 0d       	reteq	0
8000ce06:	5e fc       	retal	r12

8000ce08 <__avr32_f64_div>:
8000ce08:	eb cd 40 ff 	pushm	r0-r7,lr
8000ce0c:	f7 e9 20 0e 	eor	lr,r11,r9
8000ce10:	f6 07 16 14 	lsr	r7,r11,0x14
8000ce14:	a9 7b       	lsl	r11,0x9
8000ce16:	f7 ea 13 7b 	or	r11,r11,r10>>0x17
8000ce1a:	a9 7a       	lsl	r10,0x9
8000ce1c:	bd bb       	sbr	r11,0x1d
8000ce1e:	e4 1b 3f ff 	andh	r11,0x3fff
8000ce22:	ab d7       	cbr	r7,0xb
8000ce24:	e0 80 00 cc 	breq	8000cfbc <__avr32_f64_div_round_subnormal+0x54>
8000ce28:	e0 47 07 ff 	cp.w	r7,2047
8000ce2c:	e0 84 00 b5 	brge	8000cf96 <__avr32_f64_div_round_subnormal+0x2e>
8000ce30:	f2 06 16 14 	lsr	r6,r9,0x14
8000ce34:	a9 79       	lsl	r9,0x9
8000ce36:	f3 e8 13 79 	or	r9,r9,r8>>0x17
8000ce3a:	a9 78       	lsl	r8,0x9
8000ce3c:	bd b9       	sbr	r9,0x1d
8000ce3e:	e4 19 3f ff 	andh	r9,0x3fff
8000ce42:	ab d6       	cbr	r6,0xb
8000ce44:	e0 80 00 e2 	breq	8000d008 <__avr32_f64_div_round_subnormal+0xa0>
8000ce48:	e0 46 07 ff 	cp.w	r6,2047
8000ce4c:	e0 84 00 b2 	brge	8000cfb0 <__avr32_f64_div_round_subnormal+0x48>
8000ce50:	0c 17       	sub	r7,r6
8000ce52:	fe 37 fc 01 	sub	r7,-1023
8000ce56:	fc 1c 80 00 	movh	r12,0x8000
8000ce5a:	f8 03 16 01 	lsr	r3,r12,0x1
8000ce5e:	e9 d9 c3 62 	bfextu	r4,r9,0x1b,0x2
8000ce62:	5c d4       	com	r4
8000ce64:	e7 d4 d3 82 	bfins	r3,r4,0x1c,0x2
8000ce68:	e6 09 06 44 	mulu.d	r4,r3,r9
8000ce6c:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000ce70:	e6 05 06 44 	mulu.d	r4,r3,r5
8000ce74:	ea 03 15 02 	lsl	r3,r5,0x2
8000ce78:	e6 09 06 44 	mulu.d	r4,r3,r9
8000ce7c:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000ce80:	e6 05 06 44 	mulu.d	r4,r3,r5
8000ce84:	ea 03 15 02 	lsl	r3,r5,0x2
8000ce88:	e6 09 06 44 	mulu.d	r4,r3,r9
8000ce8c:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000ce90:	e6 05 06 44 	mulu.d	r4,r3,r5
8000ce94:	ea 03 15 02 	lsl	r3,r5,0x2
8000ce98:	e6 08 06 40 	mulu.d	r0,r3,r8
8000ce9c:	e4 09 07 40 	macu.d	r0,r2,r9
8000cea0:	e6 09 06 44 	mulu.d	r4,r3,r9
8000cea4:	02 04       	add	r4,r1
8000cea6:	5c 05       	acr	r5
8000cea8:	a3 65       	lsl	r5,0x2
8000ceaa:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000ceae:	a3 64       	lsl	r4,0x2
8000ceb0:	5c 34       	neg	r4
8000ceb2:	f8 05 01 45 	sbc	r5,r12,r5
8000ceb6:	e6 04 06 40 	mulu.d	r0,r3,r4
8000ceba:	e4 05 07 40 	macu.d	r0,r2,r5
8000cebe:	e6 05 06 44 	mulu.d	r4,r3,r5
8000cec2:	02 04       	add	r4,r1
8000cec4:	5c 05       	acr	r5
8000cec6:	ea 03 15 02 	lsl	r3,r5,0x2
8000ceca:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000cece:	e8 02 15 02 	lsl	r2,r4,0x2
8000ced2:	e6 08 06 40 	mulu.d	r0,r3,r8
8000ced6:	e4 09 07 40 	macu.d	r0,r2,r9
8000ceda:	e6 09 06 44 	mulu.d	r4,r3,r9
8000cede:	02 04       	add	r4,r1
8000cee0:	5c 05       	acr	r5
8000cee2:	a3 65       	lsl	r5,0x2
8000cee4:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000cee8:	a3 64       	lsl	r4,0x2
8000ceea:	5c 34       	neg	r4
8000ceec:	f8 05 01 45 	sbc	r5,r12,r5
8000cef0:	e6 04 06 40 	mulu.d	r0,r3,r4
8000cef4:	e4 05 07 40 	macu.d	r0,r2,r5
8000cef8:	e6 05 06 44 	mulu.d	r4,r3,r5
8000cefc:	02 04       	add	r4,r1
8000cefe:	5c 05       	acr	r5
8000cf00:	ea 03 15 02 	lsl	r3,r5,0x2
8000cf04:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000cf08:	e8 02 15 02 	lsl	r2,r4,0x2
8000cf0c:	e6 0a 06 40 	mulu.d	r0,r3,r10
8000cf10:	e4 0b 07 40 	macu.d	r0,r2,r11
8000cf14:	e6 0b 06 42 	mulu.d	r2,r3,r11
8000cf18:	02 02       	add	r2,r1
8000cf1a:	5c 03       	acr	r3
8000cf1c:	ed b3 00 1c 	bld	r3,0x1c
8000cf20:	c0 90       	breq	8000cf32 <__avr32_f64_div+0x12a>
8000cf22:	a1 72       	lsl	r2,0x1
8000cf24:	5c f3       	rol	r3
8000cf26:	20 17       	sub	r7,1
8000cf28:	a3 9a       	lsr	r10,0x3
8000cf2a:	f5 eb 11 da 	or	r10,r10,r11<<0x1d
8000cf2e:	a3 9b       	lsr	r11,0x3
8000cf30:	c0 58       	rjmp	8000cf3a <__avr32_f64_div+0x132>
8000cf32:	a5 8a       	lsr	r10,0x4
8000cf34:	f5 eb 11 ca 	or	r10,r10,r11<<0x1c
8000cf38:	a5 8b       	lsr	r11,0x4
8000cf3a:	58 07       	cp.w	r7,0
8000cf3c:	e0 8a 00 8b 	brle	8000d052 <__avr32_f64_div_res_subnormal>
8000cf40:	e0 12 ff 00 	andl	r2,0xff00
8000cf44:	e8 12 00 80 	orl	r2,0x80
8000cf48:	e6 08 06 40 	mulu.d	r0,r3,r8
8000cf4c:	e4 09 07 40 	macu.d	r0,r2,r9
8000cf50:	e4 08 06 44 	mulu.d	r4,r2,r8
8000cf54:	e6 09 06 48 	mulu.d	r8,r3,r9
8000cf58:	00 05       	add	r5,r0
8000cf5a:	f0 01 00 48 	adc	r8,r8,r1
8000cf5e:	5c 09       	acr	r9
8000cf60:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000cf64:	58 04       	cp.w	r4,0
8000cf66:	5c 25       	cpc	r5

8000cf68 <__avr32_f64_div_round_subnormal>:
8000cf68:	f4 08 13 00 	cpc	r8,r10
8000cf6c:	f6 09 13 00 	cpc	r9,r11
8000cf70:	5f 36       	srlo	r6
8000cf72:	f8 06 17 00 	moveq	r6,r12
8000cf76:	e4 0a 16 08 	lsr	r10,r2,0x8
8000cf7a:	f5 e3 11 8a 	or	r10,r10,r3<<0x18
8000cf7e:	e6 0b 16 08 	lsr	r11,r3,0x8
8000cf82:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000cf86:	ed be 00 1f 	bld	lr,0x1f
8000cf8a:	ef bb 00 1f 	bst	r11,0x1f
8000cf8e:	0c 0a       	add	r10,r6
8000cf90:	5c 0b       	acr	r11
8000cf92:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000cf96:	e4 1b 00 0f 	andh	r11,0xf
8000cf9a:	14 4b       	or	r11,r10
8000cf9c:	e0 81 00 a7 	brne	8000d0ea <__avr32_f64_div_res_subnormal+0x98>
8000cfa0:	f2 06 16 14 	lsr	r6,r9,0x14
8000cfa4:	ab d6       	cbr	r6,0xb
8000cfa6:	e0 46 07 ff 	cp.w	r6,2047
8000cfaa:	e0 81 00 a4 	brne	8000d0f2 <__avr32_f64_div_res_subnormal+0xa0>
8000cfae:	c9 e8       	rjmp	8000d0ea <__avr32_f64_div_res_subnormal+0x98>
8000cfb0:	e4 19 00 0f 	andh	r9,0xf
8000cfb4:	10 49       	or	r9,r8
8000cfb6:	e0 81 00 9a 	brne	8000d0ea <__avr32_f64_div_res_subnormal+0x98>
8000cfba:	c9 28       	rjmp	8000d0de <__avr32_f64_div_res_subnormal+0x8c>
8000cfbc:	a3 7b       	lsl	r11,0x3
8000cfbe:	f7 ea 13 db 	or	r11,r11,r10>>0x1d
8000cfc2:	a3 7a       	lsl	r10,0x3
8000cfc4:	f5 eb 10 04 	or	r4,r10,r11
8000cfc8:	e0 80 00 a0 	breq	8000d108 <__avr32_f64_div_op1_zero>
8000cfcc:	f6 04 12 00 	clz	r4,r11
8000cfd0:	c1 70       	breq	8000cffe <__avr32_f64_div_round_subnormal+0x96>
8000cfd2:	c0 c3       	brcs	8000cfea <__avr32_f64_div_round_subnormal+0x82>
8000cfd4:	e8 05 11 20 	rsub	r5,r4,32
8000cfd8:	f6 04 09 4b 	lsl	r11,r11,r4
8000cfdc:	f4 05 0a 45 	lsr	r5,r10,r5
8000cfe0:	0a 4b       	or	r11,r5
8000cfe2:	f4 04 09 4a 	lsl	r10,r10,r4
8000cfe6:	08 17       	sub	r7,r4
8000cfe8:	c0 b8       	rjmp	8000cffe <__avr32_f64_div_round_subnormal+0x96>
8000cfea:	f4 04 12 00 	clz	r4,r10
8000cfee:	f9 b4 03 00 	movlo	r4,0
8000cff2:	f7 b4 02 e0 	subhs	r4,-32
8000cff6:	f4 04 09 4b 	lsl	r11,r10,r4
8000cffa:	30 0a       	mov	r10,0
8000cffc:	08 17       	sub	r7,r4
8000cffe:	a3 8a       	lsr	r10,0x2
8000d000:	f5 eb 11 ea 	or	r10,r10,r11<<0x1e
8000d004:	a3 8b       	lsr	r11,0x2
8000d006:	c1 1b       	rjmp	8000ce28 <__avr32_f64_div+0x20>
8000d008:	a3 79       	lsl	r9,0x3
8000d00a:	f3 e8 13 d9 	or	r9,r9,r8>>0x1d
8000d00e:	a3 78       	lsl	r8,0x3
8000d010:	f3 e8 10 04 	or	r4,r9,r8
8000d014:	c6 f0       	breq	8000d0f2 <__avr32_f64_div_res_subnormal+0xa0>
8000d016:	f2 04 12 00 	clz	r4,r9
8000d01a:	c1 70       	breq	8000d048 <__avr32_f64_div_round_subnormal+0xe0>
8000d01c:	c0 c3       	brcs	8000d034 <__avr32_f64_div_round_subnormal+0xcc>
8000d01e:	e8 05 11 20 	rsub	r5,r4,32
8000d022:	f2 04 09 49 	lsl	r9,r9,r4
8000d026:	f0 05 0a 45 	lsr	r5,r8,r5
8000d02a:	0a 49       	or	r9,r5
8000d02c:	f0 04 09 48 	lsl	r8,r8,r4
8000d030:	08 16       	sub	r6,r4
8000d032:	c0 b8       	rjmp	8000d048 <__avr32_f64_div_round_subnormal+0xe0>
8000d034:	f0 04 12 00 	clz	r4,r8
8000d038:	f9 b4 03 00 	movlo	r4,0
8000d03c:	f7 b4 02 e0 	subhs	r4,-32
8000d040:	f0 04 09 49 	lsl	r9,r8,r4
8000d044:	30 08       	mov	r8,0
8000d046:	08 16       	sub	r6,r4
8000d048:	a3 88       	lsr	r8,0x2
8000d04a:	f1 e9 11 e8 	or	r8,r8,r9<<0x1e
8000d04e:	a3 89       	lsr	r9,0x2
8000d050:	cf ca       	rjmp	8000ce48 <__avr32_f64_div+0x40>

8000d052 <__avr32_f64_div_res_subnormal>:
8000d052:	5c 37       	neg	r7
8000d054:	2f f7       	sub	r7,-1
8000d056:	f1 b7 04 c0 	satu	r7,0x6
8000d05a:	e0 47 00 20 	cp.w	r7,32
8000d05e:	c1 54       	brge	8000d088 <__avr32_f64_div_res_subnormal+0x36>
8000d060:	ee 06 11 20 	rsub	r6,r7,32
8000d064:	e4 07 0a 42 	lsr	r2,r2,r7
8000d068:	e6 06 09 4c 	lsl	r12,r3,r6
8000d06c:	18 42       	or	r2,r12
8000d06e:	e6 07 0a 43 	lsr	r3,r3,r7
8000d072:	f4 06 09 41 	lsl	r1,r10,r6
8000d076:	f4 07 0a 4a 	lsr	r10,r10,r7
8000d07a:	f6 06 09 4c 	lsl	r12,r11,r6
8000d07e:	18 4a       	or	r10,r12
8000d080:	f6 07 0a 4b 	lsr	r11,r11,r7
8000d084:	30 00       	mov	r0,0
8000d086:	c1 58       	rjmp	8000d0b0 <__avr32_f64_div_res_subnormal+0x5e>
8000d088:	ee 06 11 20 	rsub	r6,r7,32
8000d08c:	f9 b0 00 00 	moveq	r0,0
8000d090:	f9 bc 00 00 	moveq	r12,0
8000d094:	c0 50       	breq	8000d09e <__avr32_f64_div_res_subnormal+0x4c>
8000d096:	f4 06 09 40 	lsl	r0,r10,r6
8000d09a:	f6 06 09 4c 	lsl	r12,r11,r6
8000d09e:	e6 07 0a 42 	lsr	r2,r3,r7
8000d0a2:	30 03       	mov	r3,0
8000d0a4:	f4 07 0a 41 	lsr	r1,r10,r7
8000d0a8:	18 41       	or	r1,r12
8000d0aa:	f6 07 0a 4a 	lsr	r10,r11,r7
8000d0ae:	30 0b       	mov	r11,0
8000d0b0:	e0 12 ff 00 	andl	r2,0xff00
8000d0b4:	e8 12 00 80 	orl	r2,0x80
8000d0b8:	e6 08 06 46 	mulu.d	r6,r3,r8
8000d0bc:	e4 09 07 46 	macu.d	r6,r2,r9
8000d0c0:	e4 08 06 44 	mulu.d	r4,r2,r8
8000d0c4:	e6 09 06 48 	mulu.d	r8,r3,r9
8000d0c8:	0c 05       	add	r5,r6
8000d0ca:	f0 07 00 48 	adc	r8,r8,r7
8000d0ce:	5c 09       	acr	r9
8000d0d0:	30 07       	mov	r7,0
8000d0d2:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000d0d6:	00 34       	cp.w	r4,r0
8000d0d8:	e2 05 13 00 	cpc	r5,r1
8000d0dc:	c4 6b       	rjmp	8000cf68 <__avr32_f64_div_round_subnormal>
8000d0de:	1c 9b       	mov	r11,lr
8000d0e0:	e6 1b 80 00 	andh	r11,0x8000,COH
8000d0e4:	30 0a       	mov	r10,0
8000d0e6:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000d0ea:	3f fb       	mov	r11,-1
8000d0ec:	30 0a       	mov	r10,0
8000d0ee:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000d0f2:	f5 eb 10 04 	or	r4,r10,r11
8000d0f6:	c0 90       	breq	8000d108 <__avr32_f64_div_op1_zero>
8000d0f8:	1c 9b       	mov	r11,lr
8000d0fa:	e6 1b 80 00 	andh	r11,0x8000,COH
8000d0fe:	ea 1b 7f f0 	orh	r11,0x7ff0
8000d102:	30 0a       	mov	r10,0
8000d104:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc

8000d108 <__avr32_f64_div_op1_zero>:
8000d108:	f1 e9 10 15 	or	r5,r8,r9<<0x1
8000d10c:	ce f0       	breq	8000d0ea <__avr32_f64_div_res_subnormal+0x98>
8000d10e:	e9 d9 c2 8b 	bfextu	r4,r9,0x14,0xb
8000d112:	e0 44 07 ff 	cp.w	r4,2047
8000d116:	ce 41       	brne	8000d0de <__avr32_f64_div_res_subnormal+0x8c>
8000d118:	f1 e9 10 c5 	or	r5,r8,r9<<0xc
8000d11c:	ce 10       	breq	8000d0de <__avr32_f64_div_res_subnormal+0x8c>
8000d11e:	ce 6b       	rjmp	8000d0ea <__avr32_f64_div_res_subnormal+0x98>

8000d120 <__avr32_udiv64>:
8000d120:	d4 31       	pushm	r0-r7,lr
8000d122:	1a 97       	mov	r7,sp
8000d124:	20 3d       	sub	sp,12
8000d126:	10 9c       	mov	r12,r8
8000d128:	12 9e       	mov	lr,r9
8000d12a:	14 93       	mov	r3,r10
8000d12c:	58 09       	cp.w	r9,0
8000d12e:	e0 81 00 bd 	brne	8000d2a8 <__avr32_udiv64+0x188>
8000d132:	16 38       	cp.w	r8,r11
8000d134:	e0 88 00 40 	brls	8000d1b4 <__avr32_udiv64+0x94>
8000d138:	f0 08 12 00 	clz	r8,r8
8000d13c:	c0 d0       	breq	8000d156 <__avr32_udiv64+0x36>
8000d13e:	f6 08 09 4b 	lsl	r11,r11,r8
8000d142:	f0 09 11 20 	rsub	r9,r8,32
8000d146:	f8 08 09 4c 	lsl	r12,r12,r8
8000d14a:	f4 09 0a 49 	lsr	r9,r10,r9
8000d14e:	f4 08 09 43 	lsl	r3,r10,r8
8000d152:	f3 eb 10 0b 	or	r11,r9,r11
8000d156:	f8 0e 16 10 	lsr	lr,r12,0x10
8000d15a:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000d15e:	f6 0e 0d 00 	divu	r0,r11,lr
8000d162:	e6 0b 16 10 	lsr	r11,r3,0x10
8000d166:	00 99       	mov	r9,r0
8000d168:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000d16c:	e0 0a 02 48 	mul	r8,r0,r10
8000d170:	10 3b       	cp.w	r11,r8
8000d172:	c0 a2       	brcc	8000d186 <__avr32_udiv64+0x66>
8000d174:	20 19       	sub	r9,1
8000d176:	18 0b       	add	r11,r12
8000d178:	18 3b       	cp.w	r11,r12
8000d17a:	c0 63       	brcs	8000d186 <__avr32_udiv64+0x66>
8000d17c:	10 3b       	cp.w	r11,r8
8000d17e:	f7 b9 03 01 	sublo	r9,1
8000d182:	f7 dc e3 0b 	addcs	r11,r11,r12
8000d186:	f6 08 01 01 	sub	r1,r11,r8
8000d18a:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000d18e:	e2 0e 0d 00 	divu	r0,r1,lr
8000d192:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000d196:	00 98       	mov	r8,r0
8000d198:	e0 0a 02 4a 	mul	r10,r0,r10
8000d19c:	14 33       	cp.w	r3,r10
8000d19e:	c0 82       	brcc	8000d1ae <__avr32_udiv64+0x8e>
8000d1a0:	20 18       	sub	r8,1
8000d1a2:	18 03       	add	r3,r12
8000d1a4:	18 33       	cp.w	r3,r12
8000d1a6:	c0 43       	brcs	8000d1ae <__avr32_udiv64+0x8e>
8000d1a8:	14 33       	cp.w	r3,r10
8000d1aa:	f7 b8 03 01 	sublo	r8,1
8000d1ae:	f1 e9 11 08 	or	r8,r8,r9<<0x10
8000d1b2:	cd f8       	rjmp	8000d370 <__avr32_udiv64+0x250>
8000d1b4:	58 08       	cp.w	r8,0
8000d1b6:	c0 51       	brne	8000d1c0 <__avr32_udiv64+0xa0>
8000d1b8:	30 19       	mov	r9,1
8000d1ba:	f2 08 0d 08 	divu	r8,r9,r8
8000d1be:	10 9c       	mov	r12,r8
8000d1c0:	f8 06 12 00 	clz	r6,r12
8000d1c4:	c0 41       	brne	8000d1cc <__avr32_udiv64+0xac>
8000d1c6:	18 1b       	sub	r11,r12
8000d1c8:	30 19       	mov	r9,1
8000d1ca:	c4 08       	rjmp	8000d24a <__avr32_udiv64+0x12a>
8000d1cc:	ec 01 11 20 	rsub	r1,r6,32
8000d1d0:	f4 01 0a 49 	lsr	r9,r10,r1
8000d1d4:	f8 06 09 4c 	lsl	r12,r12,r6
8000d1d8:	f6 06 09 48 	lsl	r8,r11,r6
8000d1dc:	f6 01 0a 41 	lsr	r1,r11,r1
8000d1e0:	f3 e8 10 08 	or	r8,r9,r8
8000d1e4:	f8 03 16 10 	lsr	r3,r12,0x10
8000d1e8:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000d1ec:	e2 03 0d 00 	divu	r0,r1,r3
8000d1f0:	f0 0b 16 10 	lsr	r11,r8,0x10
8000d1f4:	00 9e       	mov	lr,r0
8000d1f6:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000d1fa:	e0 05 02 49 	mul	r9,r0,r5
8000d1fe:	12 3b       	cp.w	r11,r9
8000d200:	c0 a2       	brcc	8000d214 <__avr32_udiv64+0xf4>
8000d202:	20 1e       	sub	lr,1
8000d204:	18 0b       	add	r11,r12
8000d206:	18 3b       	cp.w	r11,r12
8000d208:	c0 63       	brcs	8000d214 <__avr32_udiv64+0xf4>
8000d20a:	12 3b       	cp.w	r11,r9
8000d20c:	f7 be 03 01 	sublo	lr,1
8000d210:	f7 dc e3 0b 	addcs	r11,r11,r12
8000d214:	12 1b       	sub	r11,r9
8000d216:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
8000d21a:	f6 03 0d 02 	divu	r2,r11,r3
8000d21e:	f1 e3 11 08 	or	r8,r8,r3<<0x10
8000d222:	04 99       	mov	r9,r2
8000d224:	e4 05 02 4b 	mul	r11,r2,r5
8000d228:	16 38       	cp.w	r8,r11
8000d22a:	c0 a2       	brcc	8000d23e <__avr32_udiv64+0x11e>
8000d22c:	20 19       	sub	r9,1
8000d22e:	18 08       	add	r8,r12
8000d230:	18 38       	cp.w	r8,r12
8000d232:	c0 63       	brcs	8000d23e <__avr32_udiv64+0x11e>
8000d234:	16 38       	cp.w	r8,r11
8000d236:	f7 b9 03 01 	sublo	r9,1
8000d23a:	f1 dc e3 08 	addcs	r8,r8,r12
8000d23e:	f4 06 09 43 	lsl	r3,r10,r6
8000d242:	f0 0b 01 0b 	sub	r11,r8,r11
8000d246:	f3 ee 11 09 	or	r9,r9,lr<<0x10
8000d24a:	f8 06 16 10 	lsr	r6,r12,0x10
8000d24e:	fd dc c0 10 	bfextu	lr,r12,0x0,0x10
8000d252:	f6 06 0d 00 	divu	r0,r11,r6
8000d256:	e6 0b 16 10 	lsr	r11,r3,0x10
8000d25a:	00 9a       	mov	r10,r0
8000d25c:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000d260:	e0 0e 02 48 	mul	r8,r0,lr
8000d264:	10 3b       	cp.w	r11,r8
8000d266:	c0 a2       	brcc	8000d27a <__avr32_udiv64+0x15a>
8000d268:	20 1a       	sub	r10,1
8000d26a:	18 0b       	add	r11,r12
8000d26c:	18 3b       	cp.w	r11,r12
8000d26e:	c0 63       	brcs	8000d27a <__avr32_udiv64+0x15a>
8000d270:	10 3b       	cp.w	r11,r8
8000d272:	f7 ba 03 01 	sublo	r10,1
8000d276:	f7 dc e3 0b 	addcs	r11,r11,r12
8000d27a:	f6 08 01 01 	sub	r1,r11,r8
8000d27e:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000d282:	e2 06 0d 00 	divu	r0,r1,r6
8000d286:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000d28a:	00 98       	mov	r8,r0
8000d28c:	e0 0e 02 4b 	mul	r11,r0,lr
8000d290:	16 33       	cp.w	r3,r11
8000d292:	c0 82       	brcc	8000d2a2 <__avr32_udiv64+0x182>
8000d294:	20 18       	sub	r8,1
8000d296:	18 03       	add	r3,r12
8000d298:	18 33       	cp.w	r3,r12
8000d29a:	c0 43       	brcs	8000d2a2 <__avr32_udiv64+0x182>
8000d29c:	16 33       	cp.w	r3,r11
8000d29e:	f7 b8 03 01 	sublo	r8,1
8000d2a2:	f1 ea 11 08 	or	r8,r8,r10<<0x10
8000d2a6:	c6 98       	rjmp	8000d378 <__avr32_udiv64+0x258>
8000d2a8:	16 39       	cp.w	r9,r11
8000d2aa:	e0 8b 00 65 	brhi	8000d374 <__avr32_udiv64+0x254>
8000d2ae:	f2 09 12 00 	clz	r9,r9
8000d2b2:	c0 b1       	brne	8000d2c8 <__avr32_udiv64+0x1a8>
8000d2b4:	10 3a       	cp.w	r10,r8
8000d2b6:	5f 2a       	srhs	r10
8000d2b8:	1c 3b       	cp.w	r11,lr
8000d2ba:	5f b8       	srhi	r8
8000d2bc:	10 4a       	or	r10,r8
8000d2be:	f2 0a 18 00 	cp.b	r10,r9
8000d2c2:	c5 90       	breq	8000d374 <__avr32_udiv64+0x254>
8000d2c4:	30 18       	mov	r8,1
8000d2c6:	c5 98       	rjmp	8000d378 <__avr32_udiv64+0x258>
8000d2c8:	f0 09 09 46 	lsl	r6,r8,r9
8000d2cc:	f2 03 11 20 	rsub	r3,r9,32
8000d2d0:	fc 09 09 4e 	lsl	lr,lr,r9
8000d2d4:	f0 03 0a 48 	lsr	r8,r8,r3
8000d2d8:	f6 09 09 4c 	lsl	r12,r11,r9
8000d2dc:	f4 03 0a 42 	lsr	r2,r10,r3
8000d2e0:	ef 46 ff f4 	st.w	r7[-12],r6
8000d2e4:	f6 03 0a 43 	lsr	r3,r11,r3
8000d2e8:	18 42       	or	r2,r12
8000d2ea:	f1 ee 10 0c 	or	r12,r8,lr
8000d2ee:	f8 01 16 10 	lsr	r1,r12,0x10
8000d2f2:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000d2f6:	e6 01 0d 04 	divu	r4,r3,r1
8000d2fa:	e4 03 16 10 	lsr	r3,r2,0x10
8000d2fe:	08 9e       	mov	lr,r4
8000d300:	e7 e5 11 03 	or	r3,r3,r5<<0x10
8000d304:	e8 06 02 48 	mul	r8,r4,r6
8000d308:	10 33       	cp.w	r3,r8
8000d30a:	c0 a2       	brcc	8000d31e <__avr32_udiv64+0x1fe>
8000d30c:	20 1e       	sub	lr,1
8000d30e:	18 03       	add	r3,r12
8000d310:	18 33       	cp.w	r3,r12
8000d312:	c0 63       	brcs	8000d31e <__avr32_udiv64+0x1fe>
8000d314:	10 33       	cp.w	r3,r8
8000d316:	f7 be 03 01 	sublo	lr,1
8000d31a:	e7 dc e3 03 	addcs	r3,r3,r12
8000d31e:	10 13       	sub	r3,r8
8000d320:	f7 d2 c0 10 	bfextu	r11,r2,0x0,0x10
8000d324:	e6 01 0d 00 	divu	r0,r3,r1
8000d328:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000d32c:	00 98       	mov	r8,r0
8000d32e:	e0 06 02 46 	mul	r6,r0,r6
8000d332:	0c 3b       	cp.w	r11,r6
8000d334:	c0 a2       	brcc	8000d348 <__avr32_udiv64+0x228>
8000d336:	20 18       	sub	r8,1
8000d338:	18 0b       	add	r11,r12
8000d33a:	18 3b       	cp.w	r11,r12
8000d33c:	c0 63       	brcs	8000d348 <__avr32_udiv64+0x228>
8000d33e:	0c 3b       	cp.w	r11,r6
8000d340:	f7 dc e3 0b 	addcs	r11,r11,r12
8000d344:	f7 b8 03 01 	sublo	r8,1
8000d348:	f1 ee 11 08 	or	r8,r8,lr<<0x10
8000d34c:	ee f4 ff f4 	ld.w	r4,r7[-12]
8000d350:	0c 1b       	sub	r11,r6
8000d352:	f0 04 06 42 	mulu.d	r2,r8,r4
8000d356:	06 95       	mov	r5,r3
8000d358:	16 35       	cp.w	r5,r11
8000d35a:	e0 8b 00 0a 	brhi	8000d36e <__avr32_udiv64+0x24e>
8000d35e:	5f 0b       	sreq	r11
8000d360:	f4 09 09 49 	lsl	r9,r10,r9
8000d364:	12 32       	cp.w	r2,r9
8000d366:	5f b9       	srhi	r9
8000d368:	f7 e9 00 09 	and	r9,r11,r9
8000d36c:	c0 60       	breq	8000d378 <__avr32_udiv64+0x258>
8000d36e:	20 18       	sub	r8,1
8000d370:	30 09       	mov	r9,0
8000d372:	c0 38       	rjmp	8000d378 <__avr32_udiv64+0x258>
8000d374:	30 09       	mov	r9,0
8000d376:	12 98       	mov	r8,r9
8000d378:	10 9a       	mov	r10,r8
8000d37a:	12 93       	mov	r3,r9
8000d37c:	10 92       	mov	r2,r8
8000d37e:	12 9b       	mov	r11,r9
8000d380:	2f dd       	sub	sp,-12
8000d382:	d8 32       	popm	r0-r7,pc

8000d384 <__avr32_umod64>:
8000d384:	d4 31       	pushm	r0-r7,lr
8000d386:	1a 97       	mov	r7,sp
8000d388:	20 3d       	sub	sp,12
8000d38a:	10 9c       	mov	r12,r8
8000d38c:	12 95       	mov	r5,r9
8000d38e:	14 9e       	mov	lr,r10
8000d390:	16 91       	mov	r1,r11
8000d392:	16 96       	mov	r6,r11
8000d394:	58 09       	cp.w	r9,0
8000d396:	e0 81 00 81 	brne	8000d498 <__avr32_umod64+0x114>
8000d39a:	16 38       	cp.w	r8,r11
8000d39c:	e0 88 00 12 	brls	8000d3c0 <__avr32_umod64+0x3c>
8000d3a0:	f0 08 12 00 	clz	r8,r8
8000d3a4:	c4 e0       	breq	8000d440 <__avr32_umod64+0xbc>
8000d3a6:	f6 08 09 46 	lsl	r6,r11,r8
8000d3aa:	f8 08 09 4c 	lsl	r12,r12,r8
8000d3ae:	f0 0b 11 20 	rsub	r11,r8,32
8000d3b2:	f4 08 09 4e 	lsl	lr,r10,r8
8000d3b6:	f4 0b 0a 4b 	lsr	r11,r10,r11
8000d3ba:	f7 e6 10 06 	or	r6,r11,r6
8000d3be:	c4 18       	rjmp	8000d440 <__avr32_umod64+0xbc>
8000d3c0:	58 08       	cp.w	r8,0
8000d3c2:	c0 51       	brne	8000d3cc <__avr32_umod64+0x48>
8000d3c4:	30 19       	mov	r9,1
8000d3c6:	f2 08 0d 08 	divu	r8,r9,r8
8000d3ca:	10 9c       	mov	r12,r8
8000d3cc:	f8 08 12 00 	clz	r8,r12
8000d3d0:	c0 31       	brne	8000d3d6 <__avr32_umod64+0x52>
8000d3d2:	18 16       	sub	r6,r12
8000d3d4:	c3 68       	rjmp	8000d440 <__avr32_umod64+0xbc>
8000d3d6:	f0 03 11 20 	rsub	r3,r8,32
8000d3da:	f4 03 0a 4b 	lsr	r11,r10,r3
8000d3de:	f8 08 09 4c 	lsl	r12,r12,r8
8000d3e2:	ec 08 09 49 	lsl	r9,r6,r8
8000d3e6:	ec 03 0a 43 	lsr	r3,r6,r3
8000d3ea:	f7 e9 10 09 	or	r9,r11,r9
8000d3ee:	f8 05 16 10 	lsr	r5,r12,0x10
8000d3f2:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000d3f6:	e6 05 0d 02 	divu	r2,r3,r5
8000d3fa:	f2 0e 16 10 	lsr	lr,r9,0x10
8000d3fe:	ec 02 02 4b 	mul	r11,r6,r2
8000d402:	fd e3 11 0e 	or	lr,lr,r3<<0x10
8000d406:	16 3e       	cp.w	lr,r11
8000d408:	c0 72       	brcc	8000d416 <__avr32_umod64+0x92>
8000d40a:	18 0e       	add	lr,r12
8000d40c:	18 3e       	cp.w	lr,r12
8000d40e:	c0 43       	brcs	8000d416 <__avr32_umod64+0x92>
8000d410:	16 3e       	cp.w	lr,r11
8000d412:	fd dc e3 0e 	addcs	lr,lr,r12
8000d416:	fc 0b 01 03 	sub	r3,lr,r11
8000d41a:	f3 d9 c0 10 	bfextu	r9,r9,0x0,0x10
8000d41e:	e6 05 0d 02 	divu	r2,r3,r5
8000d422:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000d426:	a5 36       	mul	r6,r2
8000d428:	0c 39       	cp.w	r9,r6
8000d42a:	c0 72       	brcc	8000d438 <__avr32_umod64+0xb4>
8000d42c:	18 09       	add	r9,r12
8000d42e:	18 39       	cp.w	r9,r12
8000d430:	c0 43       	brcs	8000d438 <__avr32_umod64+0xb4>
8000d432:	0c 39       	cp.w	r9,r6
8000d434:	f3 dc e3 09 	addcs	r9,r9,r12
8000d438:	f2 06 01 06 	sub	r6,r9,r6
8000d43c:	f4 08 09 4e 	lsl	lr,r10,r8
8000d440:	f8 0a 16 10 	lsr	r10,r12,0x10
8000d444:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000d448:	ec 0a 0d 02 	divu	r2,r6,r10
8000d44c:	fc 09 16 10 	lsr	r9,lr,0x10
8000d450:	ea 02 02 4b 	mul	r11,r5,r2
8000d454:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000d458:	16 39       	cp.w	r9,r11
8000d45a:	c0 72       	brcc	8000d468 <__avr32_umod64+0xe4>
8000d45c:	18 09       	add	r9,r12
8000d45e:	18 39       	cp.w	r9,r12
8000d460:	c0 43       	brcs	8000d468 <__avr32_umod64+0xe4>
8000d462:	16 39       	cp.w	r9,r11
8000d464:	f3 dc e3 09 	addcs	r9,r9,r12
8000d468:	f2 0b 01 0b 	sub	r11,r9,r11
8000d46c:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000d470:	f6 0a 0d 0a 	divu	r10,r11,r10
8000d474:	fd eb 11 0e 	or	lr,lr,r11<<0x10
8000d478:	ea 0a 02 4a 	mul	r10,r5,r10
8000d47c:	14 3e       	cp.w	lr,r10
8000d47e:	c0 72       	brcc	8000d48c <__avr32_umod64+0x108>
8000d480:	18 0e       	add	lr,r12
8000d482:	18 3e       	cp.w	lr,r12
8000d484:	c0 43       	brcs	8000d48c <__avr32_umod64+0x108>
8000d486:	14 3e       	cp.w	lr,r10
8000d488:	fd dc e3 0e 	addcs	lr,lr,r12
8000d48c:	fc 0a 01 0a 	sub	r10,lr,r10
8000d490:	30 0b       	mov	r11,0
8000d492:	f4 08 0a 4a 	lsr	r10,r10,r8
8000d496:	c7 b8       	rjmp	8000d58c <__avr32_umod64+0x208>
8000d498:	16 39       	cp.w	r9,r11
8000d49a:	e0 8b 00 79 	brhi	8000d58c <__avr32_umod64+0x208>
8000d49e:	f2 09 12 00 	clz	r9,r9
8000d4a2:	c1 21       	brne	8000d4c6 <__avr32_umod64+0x142>
8000d4a4:	10 3a       	cp.w	r10,r8
8000d4a6:	5f 2b       	srhs	r11
8000d4a8:	0a 31       	cp.w	r1,r5
8000d4aa:	5f ba       	srhi	r10
8000d4ac:	f7 ea 10 0a 	or	r10,r11,r10
8000d4b0:	f2 0a 18 00 	cp.b	r10,r9
8000d4b4:	c0 60       	breq	8000d4c0 <__avr32_umod64+0x13c>
8000d4b6:	fc 08 01 0c 	sub	r12,lr,r8
8000d4ba:	e2 05 01 46 	sbc	r6,r1,r5
8000d4be:	18 9e       	mov	lr,r12
8000d4c0:	0c 9b       	mov	r11,r6
8000d4c2:	1c 9a       	mov	r10,lr
8000d4c4:	c6 48       	rjmp	8000d58c <__avr32_umod64+0x208>
8000d4c6:	ea 09 09 4c 	lsl	r12,r5,r9
8000d4ca:	f2 06 11 20 	rsub	r6,r9,32
8000d4ce:	f6 09 09 4b 	lsl	r11,r11,r9
8000d4d2:	f0 09 09 42 	lsl	r2,r8,r9
8000d4d6:	ef 46 ff f4 	st.w	r7[-12],r6
8000d4da:	f0 06 0a 48 	lsr	r8,r8,r6
8000d4de:	18 48       	or	r8,r12
8000d4e0:	e2 06 0a 4c 	lsr	r12,r1,r6
8000d4e4:	f4 09 09 43 	lsl	r3,r10,r9
8000d4e8:	fd d8 c0 10 	bfextu	lr,r8,0x0,0x10
8000d4ec:	f4 06 0a 4a 	lsr	r10,r10,r6
8000d4f0:	16 4a       	or	r10,r11
8000d4f2:	f0 0b 16 10 	lsr	r11,r8,0x10
8000d4f6:	f8 0b 0d 04 	divu	r4,r12,r11
8000d4fa:	f4 0c 16 10 	lsr	r12,r10,0x10
8000d4fe:	08 91       	mov	r1,r4
8000d500:	f9 e5 11 0c 	or	r12,r12,r5<<0x10
8000d504:	e8 0e 02 46 	mul	r6,r4,lr
8000d508:	0c 3c       	cp.w	r12,r6
8000d50a:	c0 a2       	brcc	8000d51e <__avr32_umod64+0x19a>
8000d50c:	20 11       	sub	r1,1
8000d50e:	10 0c       	add	r12,r8
8000d510:	10 3c       	cp.w	r12,r8
8000d512:	c0 63       	brcs	8000d51e <__avr32_umod64+0x19a>
8000d514:	0c 3c       	cp.w	r12,r6
8000d516:	f7 b1 03 01 	sublo	r1,1
8000d51a:	f9 d8 e3 0c 	addcs	r12,r12,r8
8000d51e:	0c 1c       	sub	r12,r6
8000d520:	f5 da c0 10 	bfextu	r10,r10,0x0,0x10
8000d524:	f8 0b 0d 04 	divu	r4,r12,r11
8000d528:	f5 e5 11 0b 	or	r11,r10,r5<<0x10
8000d52c:	08 96       	mov	r6,r4
8000d52e:	e8 0e 02 4e 	mul	lr,r4,lr
8000d532:	1c 3b       	cp.w	r11,lr
8000d534:	c0 a2       	brcc	8000d548 <__avr32_umod64+0x1c4>
8000d536:	20 16       	sub	r6,1
8000d538:	10 0b       	add	r11,r8
8000d53a:	10 3b       	cp.w	r11,r8
8000d53c:	c0 63       	brcs	8000d548 <__avr32_umod64+0x1c4>
8000d53e:	1c 3b       	cp.w	r11,lr
8000d540:	f7 b6 03 01 	sublo	r6,1
8000d544:	f7 d8 e3 0b 	addcs	r11,r11,r8
8000d548:	ed e1 11 01 	or	r1,r6,r1<<0x10
8000d54c:	1c 1b       	sub	r11,lr
8000d54e:	e2 02 06 40 	mulu.d	r0,r1,r2
8000d552:	00 9e       	mov	lr,r0
8000d554:	02 9c       	mov	r12,r1
8000d556:	16 3c       	cp.w	r12,r11
8000d558:	e0 8b 00 08 	brhi	8000d568 <__avr32_umod64+0x1e4>
8000d55c:	5f 06       	sreq	r6
8000d55e:	06 30       	cp.w	r0,r3
8000d560:	5f ba       	srhi	r10
8000d562:	ed ea 00 0a 	and	r10,r6,r10
8000d566:	c0 60       	breq	8000d572 <__avr32_umod64+0x1ee>
8000d568:	fc 02 01 04 	sub	r4,lr,r2
8000d56c:	f8 08 01 4c 	sbc	r12,r12,r8
8000d570:	08 9e       	mov	lr,r4
8000d572:	e6 0e 01 0a 	sub	r10,r3,lr
8000d576:	f6 0c 01 4c 	sbc	r12,r11,r12
8000d57a:	ee f1 ff f4 	ld.w	r1,r7[-12]
8000d57e:	f8 09 0a 4b 	lsr	r11,r12,r9
8000d582:	f4 09 0a 4a 	lsr	r10,r10,r9
8000d586:	f8 01 09 4c 	lsl	r12,r12,r1
8000d58a:	18 4a       	or	r10,r12
8000d58c:	2f dd       	sub	sp,-12
8000d58e:	d8 32       	popm	r0-r7,pc

Disassembly of section .exception:

8000d600 <_evba>:
_evba:

        .org  0x000
        // Unrecoverable Exception.
_handle_Unrecoverable_Exception:
        rjmp $
8000d600:	c0 08       	rjmp	8000d600 <_evba>
	...

8000d604 <_handle_TLB_Multiple_Hit>:

        .org  0x004
        // TLB Multiple Hit: UNUSED IN AVR32UC.
_handle_TLB_Multiple_Hit:
        rjmp $
8000d604:	c0 08       	rjmp	8000d604 <_handle_TLB_Multiple_Hit>
	...

8000d608 <_handle_Bus_Error_Data_Fetch>:

        .org  0x008
        // Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
        rjmp $
8000d608:	c0 08       	rjmp	8000d608 <_handle_Bus_Error_Data_Fetch>
	...

8000d60c <_handle_Bus_Error_Instruction_Fetch>:

        .org  0x00C
         // Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
        rjmp $
8000d60c:	c0 08       	rjmp	8000d60c <_handle_Bus_Error_Instruction_Fetch>
	...

8000d610 <_handle_NMI>:

        .org  0x010
        // NMI.
_handle_NMI:
        rjmp $
8000d610:	c0 08       	rjmp	8000d610 <_handle_NMI>
	...

8000d614 <_handle_Instruction_Address>:

        .org  0x014
        // Instruction Address.
_handle_Instruction_Address:
        rjmp $
8000d614:	c0 08       	rjmp	8000d614 <_handle_Instruction_Address>
	...

8000d618 <_handle_ITLB_Protection>:

        .org  0x018
        // ITLB Protection.
_handle_ITLB_Protection:
        rjmp $
8000d618:	c0 08       	rjmp	8000d618 <_handle_ITLB_Protection>
	...

8000d61c <_handle_Breakpoint>:

        .org  0x01C
        // Breakpoint.
_handle_Breakpoint:
        rjmp $
8000d61c:	c0 08       	rjmp	8000d61c <_handle_Breakpoint>
	...

8000d620 <_handle_Illegal_Opcode>:

        .org  0x020
        // Illegal Opcode.
_handle_Illegal_Opcode:
        rjmp $
8000d620:	c0 08       	rjmp	8000d620 <_handle_Illegal_Opcode>
	...

8000d624 <_handle_Unimplemented_Instruction>:

        .org  0x024
        // Unimplemented Instruction.
_handle_Unimplemented_Instruction:
        rjmp $
8000d624:	c0 08       	rjmp	8000d624 <_handle_Unimplemented_Instruction>
	...

8000d628 <_handle_Privilege_Violation>:

        .org  0x028
        // Privilege Violation.
_handle_Privilege_Violation:
        rjmp $
8000d628:	c0 08       	rjmp	8000d628 <_handle_Privilege_Violation>
	...

8000d62c <_handle_Floating_Point>:

        .org  0x02C
        // Floating-Point: UNUSED IN AVR32UC.
_handle_Floating_Point:
        rjmp $
8000d62c:	c0 08       	rjmp	8000d62c <_handle_Floating_Point>
	...

8000d630 <_handle_Coprocessor_Absent>:

        .org  0x030
        // Coprocessor Absent: UNUSED IN AVR32UC.
_handle_Coprocessor_Absent:
        rjmp $
8000d630:	c0 08       	rjmp	8000d630 <_handle_Coprocessor_Absent>
	...

8000d634 <_handle_Data_Address_Read>:

        .org  0x034
        // Data Address (Read).
_handle_Data_Address_Read:
        rjmp $
8000d634:	c0 08       	rjmp	8000d634 <_handle_Data_Address_Read>
	...

8000d638 <_handle_Data_Address_Write>:

        .org  0x038
        // Data Address (Write).
_handle_Data_Address_Write:
        rjmp $
8000d638:	c0 08       	rjmp	8000d638 <_handle_Data_Address_Write>
	...

8000d63c <_handle_DTLB_Protection_Read>:

        .org  0x03C
        // DTLB Protection (Read).
_handle_DTLB_Protection_Read:
        rjmp $
8000d63c:	c0 08       	rjmp	8000d63c <_handle_DTLB_Protection_Read>
	...

8000d640 <_handle_DTLB_Protection_Write>:

        .org  0x040
        // DTLB Protection (Write).
_handle_DTLB_Protection_Write:
        rjmp $
8000d640:	c0 08       	rjmp	8000d640 <_handle_DTLB_Protection_Write>
	...

8000d644 <_handle_DTLB_Modified>:

        .org  0x044
        // DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
        rjmp $
8000d644:	c0 08       	rjmp	8000d644 <_handle_DTLB_Modified>
	...

8000d650 <_handle_ITLB_Miss>:

        .org  0x050
        // ITLB Miss: UNUSED IN AVR32UC.
_handle_ITLB_Miss:
        rjmp $
8000d650:	c0 08       	rjmp	8000d650 <_handle_ITLB_Miss>
	...

8000d660 <_handle_DTLB_Miss_Read>:

        .org  0x060
        // DTLB Miss (Read): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Read:
        rjmp $
8000d660:	c0 08       	rjmp	8000d660 <_handle_DTLB_Miss_Read>
	...

8000d670 <_handle_DTLB_Miss_Write>:

        .org  0x070
        // DTLB Miss (Write): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Write:
        rjmp $
8000d670:	c0 08       	rjmp	8000d670 <_handle_DTLB_Miss_Write>
	...

8000d700 <_handle_Supervisor_Call>:

        .org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	lda.w   pc, SCALLYield
8000d700:	fe cf 70 34 	sub	pc,pc,28724

8000d704 <_int0>:
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
	rete
.endr
8000d704:	30 0c       	mov	r12,0
8000d706:	fe b0 c3 49 	rcall	80005d98 <_get_interrupt_handler>
8000d70a:	58 0c       	cp.w	r12,0
8000d70c:	f8 0f 17 10 	movne	pc,r12
8000d710:	d6 03       	rete

8000d712 <_int1>:
8000d712:	30 1c       	mov	r12,1
8000d714:	fe b0 c3 42 	rcall	80005d98 <_get_interrupt_handler>
8000d718:	58 0c       	cp.w	r12,0
8000d71a:	f8 0f 17 10 	movne	pc,r12
8000d71e:	d6 03       	rete

8000d720 <_int2>:
8000d720:	30 2c       	mov	r12,2
8000d722:	fe b0 c3 3b 	rcall	80005d98 <_get_interrupt_handler>
8000d726:	58 0c       	cp.w	r12,0
8000d728:	f8 0f 17 10 	movne	pc,r12
8000d72c:	d6 03       	rete

8000d72e <_int3>:
8000d72e:	30 3c       	mov	r12,3
8000d730:	fe b0 c3 34 	rcall	80005d98 <_get_interrupt_handler>
8000d734:	58 0c       	cp.w	r12,0
8000d736:	f8 0f 17 10 	movne	pc,r12
8000d73a:	d6 03       	rete

8000d73c <ipr_val>:
8000d73c:	00 00 01 04 40 00 01 12 80 00 01 20 c0 00 01 2e     ....@...... ....
8000d74c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000d75c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000d76c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000d77c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000d78c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000d79c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000d7ac:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000d7bc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000d7cc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000d7dc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000d7ec:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000d7fc:	d7 03 d7 03                                         ....
