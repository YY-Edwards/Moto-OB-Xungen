
moto_xg_project.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00002004  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         0000ad64  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .exception    00000200  8000ce00  8000ce00  0000d200  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       000012e8  8000d000  8000d000  0000d400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .data         00000a3c  00000004  8000e2e8  0000e804  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .bss          0000b5b8  00000a40  8000ed24  0000f240  2**2
                  ALLOC
  7 .comment      00000030  00000000  00000000  0000f240  2**0
                  CONTENTS, READONLY
  8 .debug_aranges 00001688  00000000  00000000  0000f270  2**3
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_pubnames 00003666  00000000  00000000  000108f8  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_info   0002c70a  00000000  00000000  00013f5e  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_abbrev 000072d9  00000000  00000000  00040668  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   0000d485  00000000  00000000  00047941  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_frame  00003d3c  00000000  00000000  00054dc8  2**2
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    00008024  00000000  00000000  00058b04  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_loc    0000f3f8  00000000  00000000  00060b28  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .stack        00001000  00017000  00017000  00000400  2**0
                  ALLOC
 17 .debug_ranges 00001750  00000000  00000000  0006ff20  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_trampoline>:

  .global _trampoline
  .type _trampoline, @function
_trampoline:
  // Jump to program start.
  rjmp    program_start
80000000:	e0 8f 10 00 	bral	80002000 <program_start>
	...

80002000 <program_start>:
	   // rjmp    program_start

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002000:	fe cf c2 fc 	sub	pc,pc,-15620

Disassembly of section .text:

80002004 <DeviceManagement_brdcst_func>:
80002004:	f8 c8 ff fe 	sub	r8,r12,-2
void DeviceManagement_brdcst_func(xcmp_fragment_t * xcmp)
{
		U16 temp = 0;
		/*point to xcmp payload*/
		DeviceManagement_brdcast_t *ptr = (DeviceManagement_brdcast_t* )xcmp->u8;
		temp  = ptr->Device_Type << 8;
80002008:	f1 2a 00 01 	ld.sb	r10,r8[1]
		//log("DeviceManagement_brdcst...\n");
		//log("temp: %x\n", temp);
		//log("xnl_information.logical_address: %x\n", xnl_information.logical_address);
		//temp  = xcmp->u8[1] << 8;
		//temp |= xcmp->u8[2];
		if (temp == xnl_information.logical_address)
8000200c:	48 c9       	lddpc	r9,8000203c <DeviceManagement_brdcst_func+0x38>
8000200e:	92 39       	ld.sh	r9,r9[0x6]
{
		U16 temp = 0;
		/*point to xcmp payload*/
		DeviceManagement_brdcast_t *ptr = (DeviceManagement_brdcast_t* )xcmp->u8;
		temp  = ptr->Device_Type << 8;
		temp |= ptr->XCMP_Device_ID;
80002010:	11 a8       	ld.ub	r8,r8[0x2]
80002012:	f1 ea 10 88 	or	r8,r8,r10<<0x8
80002016:	f0 09 19 00 	cp.h	r9,r8
8000201a:	5e 1c       	retne	r12
		//log("xnl_information.logical_address: %x\n", xnl_information.logical_address);
		//temp  = xcmp->u8[1] << 8;
		//temp |= xcmp->u8[2];
		if (temp == xnl_information.logical_address)
		{
			if (xcmp->u8[0] == 0x01)
8000201c:	19 a9       	ld.ub	r9,r12[0x2]
8000201e:	30 18       	mov	r8,1
80002020:	f0 09 18 00 	cp.b	r9,r8
80002024:	c0 61       	brne	80002030 <DeviceManagement_brdcst_func+0x2c>
			//if(ptr->Function == Start)
			{
				//Enable Option Board
				bunchofrandomstatusflags |= 0x00000002;
80002026:	48 78       	lddpc	r8,80002040 <DeviceManagement_brdcst_func+0x3c>
80002028:	70 09       	ld.w	r9,r8[0x0]
8000202a:	a1 b9       	sbr	r9,0x1
8000202c:	91 09       	st.w	r8[0x0],r9
8000202e:	5e fc       	retal	r12
			}
			else
			{
				//Disable Option Board.
				//log("Device State : %d\n", );
				bunchofrandomstatusflags &= 0xFFFFFFFD;
80002030:	48 48       	lddpc	r8,80002040 <DeviceManagement_brdcst_func+0x3c>
80002032:	70 09       	ld.w	r9,r8[0x0]
80002034:	a1 d9       	cbr	r9,0x1
80002036:	91 09       	st.w	r8[0x0],r9
80002038:	5e fc       	retal	r12
8000203a:	00 00       	add	r0,r0
8000203c:	00 00       	add	r0,r0
8000203e:	97 20       	st.w	r11[0x8],r0
80002040:	00 00       	add	r0,r0
80002042:	0d 9c       	ld.ub	r12,r6[0x1]

80002044 <Volume_brdcst_func>:
	//log("Attenuator_Number: %x \n",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
	
	//log("Audio_Parameter: %x \n", ptr->Audio_Parameter);
	
	
}
80002044:	5e fc       	retal	r12

80002046 <AudioRoutingControl_brdcst_func>:
	//
	//log("\n\r Audio-Function: %x \n\r", xcmp->u8[3+j*2-1]);
	
	
	
}
80002046:	5e fc       	retal	r12

80002048 <vApplicationIdleHook>:
}

void vApplicationIdleHook( void )
{
	/* This hook function does nothing but increment a counter. */
	ulIdleCycleCount++;
80002048:	48 38       	lddpc	r8,80002054 <vApplicationIdleHook+0xc>
8000204a:	70 09       	ld.w	r9,r8[0x0]
8000204c:	2f f9       	sub	r9,-1
8000204e:	91 09       	st.w	r8[0x0],r9
	
}
80002050:	5e fc       	retal	r12
80002052:	00 00       	add	r0,r0
80002054:	00 00       	add	r0,r0
80002056:	0a 68       	and	r8,r5

80002058 <app_payload_tx_proc>:

}


static void app_payload_tx_proc(void  * payload)
{
80002058:	d4 01       	pushm	lr
  log("R");
8000205a:	48 3c       	lddpc	r12,80002064 <app_payload_tx_proc+0xc>
8000205c:	f0 1f 00 03 	mcall	80002068 <app_payload_tx_proc+0x10>
  //
  //
  //set_payload_idle(payload);


}
80002060:	d8 02       	popm	pc
80002062:	00 00       	add	r0,r0
80002064:	80 00       	ld.sh	r0,r0[0x0]
80002066:	d0 00       	acall	0x0
80002068:	80 00       	ld.sh	r0,r0[0x0]
8000206a:	70 60       	ld.w	r0,r8[0x18]

8000206c <app_payload_rx_proc>:
	}
}


static void app_payload_rx_proc(void  * payload)
{
8000206c:	d4 01       	pushm	lr
	static  U8 times_counter = 0;
	
	times_counter++;
8000206e:	48 99       	lddpc	r9,80002090 <app_payload_rx_proc+0x24>
80002070:	13 88       	ld.ub	r8,r9[0x0]
80002072:	2f f8       	sub	r8,-1
80002074:	b2 88       	st.b	r9[0x0],r8
	if (times_counter == 3)
80002076:	30 39       	mov	r9,3
80002078:	f2 08 18 00 	cp.b	r8,r9
8000207c:	c0 71       	brne	8000208a <app_payload_rx_proc+0x1e>
	{
		times_counter = 0 ;
8000207e:	30 09       	mov	r9,0
80002080:	48 48       	lddpc	r8,80002090 <app_payload_rx_proc+0x24>
80002082:	b0 89       	st.b	r8[0x0],r9
		log("\n\r w: \n\r");
80002084:	48 4c       	lddpc	r12,80002094 <app_payload_rx_proc+0x28>
80002086:	f0 1f 00 05 	mcall	80002098 <app_payload_rx_proc+0x2c>
	}
	//log("\n\r w: \n\r");
	if (AMBE_tx_flag)//本地发送方的mic录音
8000208a:	48 58       	lddpc	r8,8000209c <app_payload_rx_proc+0x30>
8000208c:	11 88       	ld.ub	r8,r8[0x0]
	}
	
	//payload_fragment_t * ptr = (payload_fragment_t *)payload;
	//set_payload_idle(payload);

}
8000208e:	d8 02       	popm	pc
80002090:	00 00       	add	r0,r0
80002092:	0a 5f       	eor	pc,r5
80002094:	80 00       	ld.sh	r0,r0[0x0]
80002096:	d0 04       	*unknown*
80002098:	80 00       	ld.sh	r0,r0[0x0]
8000209a:	70 60       	ld.w	r0,r8[0x18]
8000209c:	00 00       	add	r0,r0
8000209e:	0a 4c       	or	r12,r5

800020a0 <FD_brdcst_func>:
	
	
}

void FD_brdcst_func(xcmp_fragment_t * xcmp)
{
800020a0:	d4 01       	pushm	lr
	
	
	log("\n\r Forward Data Broadcast \n\r");
800020a2:	48 3c       	lddpc	r12,800020ac <FD_brdcst_func+0xc>
800020a4:	f0 1f 00 03 	mcall	800020b0 <FD_brdcst_func+0x10>
	
}
800020a8:	d8 02       	popm	pc
800020aa:	00 00       	add	r0,r0
800020ac:	80 00       	ld.sh	r0,r0[0x0]
800020ae:	d0 10       	acall	0x1
800020b0:	80 00       	ld.sh	r0,r0[0x0]
800020b2:	70 60       	ld.w	r0,r8[0x18]

800020b4 <FD_reply_func>:
	
	
}

void FD_reply_func(xcmp_fragment_t * xcmp)
{
800020b4:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Reply \n\r");
800020b6:	48 3c       	lddpc	r12,800020c0 <FD_reply_func+0xc>
800020b8:	f0 1f 00 03 	mcall	800020c4 <FD_reply_func+0x10>
	
	
}
800020bc:	d8 02       	popm	pc
800020be:	00 00       	add	r0,r0
800020c0:	80 00       	ld.sh	r0,r0[0x0]
800020c2:	d0 30       	acall	0x3
800020c4:	80 00       	ld.sh	r0,r0[0x0]
800020c6:	70 60       	ld.w	r0,r8[0x18]

800020c8 <FD_request_func>:
}



void FD_request_func(xcmp_fragment_t * xcmp)
{
800020c8:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Request \n\r");
800020ca:	48 3c       	lddpc	r12,800020d4 <FD_request_func+0xc>
800020cc:	f0 1f 00 03 	mcall	800020d8 <FD_request_func+0x10>
	
	
}
800020d0:	d8 02       	popm	pc
800020d2:	00 00       	add	r0,r0
800020d4:	80 00       	ld.sh	r0,r0[0x0]
800020d6:	d0 4c       	*unknown*
800020d8:	80 00       	ld.sh	r0,r0[0x0]
800020da:	70 60       	ld.w	r0,r8[0x18]

800020dc <EnOB_brdcst_func>:
	
	
}

void EnOB_brdcst_func(xcmp_fragment_t * xcmp)
{
800020dc:	d4 01       	pushm	lr
	
	
	log("\n\r En_OB Broadcast \n\r");
800020de:	48 3c       	lddpc	r12,800020e8 <EnOB_brdcst_func+0xc>
800020e0:	f0 1f 00 03 	mcall	800020ec <EnOB_brdcst_func+0x10>
}
800020e4:	d8 02       	popm	pc
800020e6:	00 00       	add	r0,r0
800020e8:	80 00       	ld.sh	r0,r0[0x0]
800020ea:	d0 68       	*unknown*
800020ec:	80 00       	ld.sh	r0,r0[0x0]
800020ee:	70 60       	ld.w	r0,r8[0x18]

800020f0 <EnOB_reply_func>:
}



void EnOB_reply_func(xcmp_fragment_t * xcmp)
{
800020f0:	eb cd 40 80 	pushm	r7,lr
800020f4:	18 97       	mov	r7,r12
		/*point to xcmp payload*/
	//En_OB_Control_reply_t *ptr = (En_OB_Control_reply_t* )xcmp->u8;
	//log("\n\r Xcmp_opcode: %x \n\r", xcmp->xcmp_opcode);
	
	if (xcmp->u8[0]== xcmp_Res_Success)
800020f6:	19 a9       	ld.ub	r9,r12[0x2]
800020f8:	30 08       	mov	r8,0
800020fa:	f0 09 18 00 	cp.b	r9,r8
800020fe:	c1 91       	brne	80002130 <EnOB_reply_func+0x40>
	{
		if (xcmp->u8[1] == EN_OB_Enter)
80002100:	19 b8       	ld.ub	r8,r12[0x3]
80002102:	30 19       	mov	r9,1
80002104:	f2 08 18 00 	cp.b	r8,r9
80002108:	c0 61       	brne	80002114 <EnOB_reply_func+0x24>
		{
		
			log("\n\r En_OB_Enter OK \n\r");
8000210a:	49 0c       	lddpc	r12,80002148 <EnOB_reply_func+0x58>
8000210c:	f0 1f 00 10 	mcall	8000214c <EnOB_reply_func+0x5c>
80002110:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else if (xcmp->u8[1] == EN_OB_Exit )
80002114:	58 08       	cp.w	r8,0
80002116:	c0 61       	brne	80002122 <EnOB_reply_func+0x32>
		{
			log("\n\r En_OB_Exit OK \n\r");
80002118:	48 ec       	lddpc	r12,80002150 <EnOB_reply_func+0x60>
8000211a:	f0 1f 00 0d 	mcall	8000214c <EnOB_reply_func+0x5c>
8000211e:	e3 cd 80 80 	ldm	sp++,r7,pc
		}
		else
		{
			
			log("\n\r En_OB_Control: %x \n\r", xcmp->u8[1]);
80002122:	1a d8       	st.w	--sp,r8
80002124:	48 cc       	lddpc	r12,80002154 <EnOB_reply_func+0x64>
80002126:	f0 1f 00 0a 	mcall	8000214c <EnOB_reply_func+0x5c>
8000212a:	2f fd       	sub	sp,-4
8000212c:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r En_OB_Control error \n\r");
80002130:	48 ac       	lddpc	r12,80002158 <EnOB_reply_func+0x68>
80002132:	f0 1f 00 07 	mcall	8000214c <EnOB_reply_func+0x5c>
		log("\n\r En_OB_result: %x \n\r", xcmp->u8[0]);
80002136:	0f a8       	ld.ub	r8,r7[0x2]
80002138:	1a d8       	st.w	--sp,r8
8000213a:	48 9c       	lddpc	r12,8000215c <EnOB_reply_func+0x6c>
8000213c:	f0 1f 00 04 	mcall	8000214c <EnOB_reply_func+0x5c>
80002140:	2f fd       	sub	sp,-4
80002142:	e3 cd 80 80 	ldm	sp++,r7,pc
80002146:	00 00       	add	r0,r0
80002148:	80 00       	ld.sh	r0,r0[0x0]
8000214a:	d0 80       	acall	0x8
8000214c:	80 00       	ld.sh	r0,r0[0x0]
8000214e:	70 60       	ld.w	r0,r8[0x18]
80002150:	80 00       	ld.sh	r0,r0[0x0]
80002152:	d0 98       	*unknown*
80002154:	80 00       	ld.sh	r0,r0[0x0]
80002156:	d0 ac       	*unknown*
80002158:	80 00       	ld.sh	r0,r0[0x0]
8000215a:	d0 c4       	*unknown*
8000215c:	80 00       	ld.sh	r0,r0[0x0]
8000215e:	d0 e0       	acall	0xe

80002160 <SingleDetection_brdcst_func>:
	
}


void SingleDetection_brdcst_func(xcmp_fragment_t * xcmp)
{
80002160:	eb cd 40 80 	pushm	r7,lr
80002164:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == 0x11)
80002166:	19 a9       	ld.ub	r9,r12[0x2]
80002168:	31 18       	mov	r8,17
8000216a:	f0 09 18 00 	cp.b	r9,r8
8000216e:	c0 91       	brne	80002180 <SingleDetection_brdcst_func+0x20>
	{
		log("\n\r DMR_CSBK OK \n\r");
80002170:	48 ac       	lddpc	r12,80002198 <SingleDetection_brdcst_func+0x38>
80002172:	f0 1f 00 0b 	mcall	8000219c <SingleDetection_brdcst_func+0x3c>
		get_time_okay = TRUE;
80002176:	30 19       	mov	r9,1
80002178:	48 a8       	lddpc	r8,800021a0 <SingleDetection_brdcst_func+0x40>
8000217a:	b0 89       	st.b	r8[0x0],r9
8000217c:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	//if(xcmp->u8[1] == 0x11)
	else
	{
		log("SIGBRCST error\n");
80002180:	48 9c       	lddpc	r12,800021a4 <SingleDetection_brdcst_func+0x44>
80002182:	f0 1f 00 07 	mcall	8000219c <SingleDetection_brdcst_func+0x3c>
		log("\Signal_type: %X \n\r", xcmp->u8[0] );
80002186:	0f a8       	ld.ub	r8,r7[0x2]
80002188:	1a d8       	st.w	--sp,r8
8000218a:	48 8c       	lddpc	r12,800021a8 <SingleDetection_brdcst_func+0x48>
8000218c:	f0 1f 00 04 	mcall	8000219c <SingleDetection_brdcst_func+0x3c>
80002190:	2f fd       	sub	sp,-4
80002192:	e3 cd 80 80 	ldm	sp++,r7,pc
80002196:	00 00       	add	r0,r0
80002198:	80 00       	ld.sh	r0,r0[0x0]
8000219a:	d0 f8       	*unknown*
8000219c:	80 00       	ld.sh	r0,r0[0x0]
8000219e:	70 60       	ld.w	r0,r8[0x18]
800021a0:	00 00       	add	r0,r0
800021a2:	00 04       	add	r4,r0
800021a4:	80 00       	ld.sh	r0,r0[0x0]
800021a6:	d1 0c       	*unknown*
800021a8:	80 00       	ld.sh	r0,r0[0x0]
800021aa:	d1 1c       	*unknown*

800021ac <ButtonConfig_brdcst_func>:
	
}


void ButtonConfig_brdcst_func(xcmp_fragment_t * xcmp)
{
800021ac:	d4 31       	pushm	r0-r7,lr
	U8 Num_Button =0;
	U8 i = 0 ;
	/*point to xcmp payload*/
	ButtonConfig_brdcst_t  *ptr = (ButtonConfig_brdcst_t* )xcmp->u8;
800021ae:	f8 c7 ff fe 	sub	r7,r12,-2
	
	Num_Button = ptr->NumOfButtons;
800021b2:	0f 95       	ld.ub	r5,r7[0x1]
	
	log("\n\r ButtonConfig_broadcast  \n\r"  );
800021b4:	4a bc       	lddpc	r12,80002260 <ButtonConfig_brdcst_func+0xb4>
800021b6:	f0 1f 00 2c 	mcall	80002264 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r Function: %X \n\r" , ptr->Function );
800021ba:	0f 88       	ld.ub	r8,r7[0x0]
800021bc:	1a d8       	st.w	--sp,r8
800021be:	4a bc       	lddpc	r12,80002268 <ButtonConfig_brdcst_func+0xbc>
800021c0:	f0 1f 00 29 	mcall	80002264 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
800021c4:	1a d5       	st.w	--sp,r5
800021c6:	4a ac       	lddpc	r12,8000226c <ButtonConfig_brdcst_func+0xc0>
800021c8:	f0 1f 00 27 	mcall	80002264 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
800021cc:	0f a8       	ld.ub	r8,r7[0x2]
800021ce:	1a d8       	st.w	--sp,r8
800021d0:	4a 8c       	lddpc	r12,80002270 <ButtonConfig_brdcst_func+0xc4>
800021d2:	f0 1f 00 25 	mcall	80002264 <ButtonConfig_brdcst_func+0xb8>
	
	for (i; i<Num_Button; i++)
800021d6:	2f dd       	sub	sp,-12
800021d8:	58 05       	cp.w	r5,0
800021da:	c4 10       	breq	8000225c <ButtonConfig_brdcst_func+0xb0>
800021dc:	30 06       	mov	r6,0
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
800021de:	4a 64       	lddpc	r4,80002274 <ButtonConfig_brdcst_func+0xc8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
800021e0:	4a 63       	lddpc	r3,80002278 <ButtonConfig_brdcst_func+0xcc>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
800021e2:	4a 72       	lddpc	r2,8000227c <ButtonConfig_brdcst_func+0xd0>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
800021e4:	4a 71       	lddpc	r1,80002280 <ButtonConfig_brdcst_func+0xd4>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
800021e6:	4a 80       	lddpc	r0,80002284 <ButtonConfig_brdcst_func+0xd8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
800021e8:	0f b9       	ld.ub	r9,r7[0x3]
800021ea:	0f c8       	ld.ub	r8,r7[0x4]
800021ec:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800021f0:	1a d8       	st.w	--sp,r8
800021f2:	1a d6       	st.w	--sp,r6
800021f4:	08 9c       	mov	r12,r4
800021f6:	f0 1f 00 1c 	mcall	80002264 <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
800021fa:	0f d9       	ld.ub	r9,r7[0x5]
800021fc:	0f e8       	ld.ub	r8,r7[0x6]
800021fe:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002202:	1a d8       	st.w	--sp,r8
80002204:	1a d6       	st.w	--sp,r6
80002206:	06 9c       	mov	r12,r3
80002208:	f0 1f 00 17 	mcall	80002264 <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
8000220c:	0f f9       	ld.ub	r9,r7[0x7]
8000220e:	ef 38 00 08 	ld.ub	r8,r7[8]
80002212:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002216:	1a d8       	st.w	--sp,r8
80002218:	1a d6       	st.w	--sp,r6
8000221a:	04 9c       	mov	r12,r2
8000221c:	f0 1f 00 12 	mcall	80002264 <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
80002220:	ef 39 00 09 	ld.ub	r9,r7[9]
80002224:	ef 38 00 0a 	ld.ub	r8,r7[10]
80002228:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000222c:	1a d8       	st.w	--sp,r8
8000222e:	1a d6       	st.w	--sp,r6
80002230:	02 9c       	mov	r12,r1
80002232:	f0 1f 00 0d 	mcall	80002264 <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
80002236:	2f 8d       	sub	sp,-32
80002238:	ef 39 00 0b 	ld.ub	r9,r7[11]
8000223c:	ef 38 00 0c 	ld.ub	r8,r7[12]
80002240:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002244:	1a d8       	st.w	--sp,r8
80002246:	1a d6       	st.w	--sp,r6
80002248:	00 9c       	mov	r12,r0
8000224a:	f0 1f 00 07 	mcall	80002264 <ButtonConfig_brdcst_func+0xb8>
8000224e:	2f f6       	sub	r6,-1
80002250:	2f 67       	sub	r7,-10
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
80002252:	2f ed       	sub	sp,-8
80002254:	ec 05 18 00 	cp.b	r5,r6
80002258:	fe 9b ff c8 	brhi	800021e8 <ButtonConfig_brdcst_func+0x3c>
8000225c:	d8 32       	popm	r0-r7,pc
8000225e:	00 00       	add	r0,r0
80002260:	80 00       	ld.sh	r0,r0[0x0]
80002262:	d1 30       	acall	0x13
80002264:	80 00       	ld.sh	r0,r0[0x0]
80002266:	70 60       	ld.w	r0,r8[0x18]
80002268:	80 00       	ld.sh	r0,r0[0x0]
8000226a:	d1 50       	acall	0x15
8000226c:	80 00       	ld.sh	r0,r0[0x0]
8000226e:	d1 64       	*unknown*
80002270:	80 00       	ld.sh	r0,r0[0x0]
80002272:	d1 7c       	*unknown*
80002274:	80 00       	ld.sh	r0,r0[0x0]
80002276:	d1 9c       	*unknown*
80002278:	80 00       	ld.sh	r0,r0[0x0]
8000227a:	d1 c4       	*unknown*
8000227c:	80 00       	ld.sh	r0,r0[0x0]
8000227e:	d1 ec       	*unknown*
80002280:	80 00       	ld.sh	r0,r0[0x0]
80002282:	d2 10       	acall	0x21
80002284:	80 00       	ld.sh	r0,r0[0x0]
80002286:	d2 38       	*unknown*

80002288 <ButtonConfig_reply_func>:
	}
	
}

void ButtonConfig_reply_func(xcmp_fragment_t * xcmp)
{
80002288:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	ButtonConfig_reply_t *ptr = (ButtonConfig_reply_t* )(xcmp->u8);
8000228c:	f8 c7 ff fe 	sub	r7,r12,-2
	if (ptr->Result == xcmp_Res_Success)
80002290:	0f 89       	ld.ub	r9,r7[0x0]
80002292:	30 08       	mov	r8,0
80002294:	f0 09 18 00 	cp.b	r9,r8
80002298:	c0 c1       	brne	800022b0 <ButtonConfig_reply_func+0x28>
	{
		log("\n\r Button_Config OK \n\r");
8000229a:	48 9c       	lddpc	r12,800022bc <ButtonConfig_reply_func+0x34>
8000229c:	f0 1f 00 09 	mcall	800022c0 <ButtonConfig_reply_func+0x38>
		
		log("\n\r Function: %X \n\r" , ptr->Function );
800022a0:	0f 98       	ld.ub	r8,r7[0x1]
800022a2:	1a d8       	st.w	--sp,r8
800022a4:	48 8c       	lddpc	r12,800022c4 <ButtonConfig_reply_func+0x3c>
800022a6:	f0 1f 00 07 	mcall	800022c0 <ButtonConfig_reply_func+0x38>
800022aa:	2f fd       	sub	sp,-4
800022ac:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r Button_Request error \n\r");
800022b0:	48 6c       	lddpc	r12,800022c8 <ButtonConfig_reply_func+0x40>
800022b2:	f0 1f 00 04 	mcall	800022c0 <ButtonConfig_reply_func+0x38>
800022b6:	e3 cd 80 80 	ldm	sp++,r7,pc
800022ba:	00 00       	add	r0,r0
800022bc:	80 00       	ld.sh	r0,r0[0x0]
800022be:	d2 5c       	*unknown*
800022c0:	80 00       	ld.sh	r0,r0[0x0]
800022c2:	70 60       	ld.w	r0,r8[0x18]
800022c4:	80 00       	ld.sh	r0,r0[0x0]
800022c6:	d1 50       	acall	0x15
800022c8:	80 00       	ld.sh	r0,r0[0x0]
800022ca:	d2 74       	*unknown*

800022cc <BatteryLevel_brdcst_func>:
	
}


void BatteryLevel_brdcst_func(xcmp_fragment_t * xcmp)
{
800022cc:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	BatteryLevel_brdcast_t *ptr = (BatteryLevel_brdcast_t* )(xcmp->u8);
800022d0:	f8 c7 ff fe 	sub	r7,r12,-2
	if(ptr->State == Battery_Okay)
800022d4:	0f 89       	ld.ub	r9,r7[0x0]
800022d6:	30 08       	mov	r8,0
800022d8:	f0 09 18 00 	cp.b	r9,r8
800022dc:	c0 40       	breq	800022e4 <BatteryLevel_brdcst_func+0x18>
		;//log("\n Battery Okay\n");
	else
		log("\n Battery Low !!!\n");
800022de:	48 5c       	lddpc	r12,800022f0 <BatteryLevel_brdcst_func+0x24>
800022e0:	f0 1f 00 05 	mcall	800022f4 <BatteryLevel_brdcst_func+0x28>
		
	//log("\n Battery charge: %X \n" , ptr->Charge);
	//log("\n Battery voltage: %X \n" , ptr->Voltage);
	
	Battery_Flag = ptr->State;
800022e4:	0f 89       	ld.ub	r9,r7[0x0]
800022e6:	48 58       	lddpc	r8,800022f8 <BatteryLevel_brdcst_func+0x2c>
800022e8:	b0 89       	st.b	r8[0x0],r9

}
800022ea:	e3 cd 80 80 	ldm	sp++,r7,pc
800022ee:	00 00       	add	r0,r0
800022f0:	80 00       	ld.sh	r0,r0[0x0]
800022f2:	d2 90       	acall	0x29
800022f4:	80 00       	ld.sh	r0,r0[0x0]
800022f6:	70 60       	ld.w	r0,r8[0x18]
800022f8:	00 00       	add	r0,r0
800022fa:	0a 41       	or	r1,r5

800022fc <ShutDown_brdcst_func>:
		log("ID:  %X \n", xcmp->u8[2]);
	}
	
}
void ShutDown_brdcst_func(xcmp_fragment_t * xcmp)
{
800022fc:	d4 01       	pushm	lr
	if (xcmp->u8[0] == Shut_Down_Device)
800022fe:	19 a8       	ld.ub	r8,r12[0x2]
80002300:	30 19       	mov	r9,1
80002302:	f2 08 18 00 	cp.b	r8,r9
80002306:	c0 51       	brne	80002310 <ShutDown_brdcst_func+0x14>
	{
		log("Shut_Down_Device \n");
80002308:	48 6c       	lddpc	r12,80002320 <ShutDown_brdcst_func+0x24>
8000230a:	f0 1f 00 07 	mcall	80002324 <ShutDown_brdcst_func+0x28>
8000230e:	d8 02       	popm	pc
		
	}
	else if(xcmp->u8[0] == Reset_Device)
80002310:	30 29       	mov	r9,2
80002312:	f2 08 18 00 	cp.b	r8,r9
80002316:	c0 41       	brne	8000231e <ShutDown_brdcst_func+0x22>
	{
		log("Reset_Device \n");
80002318:	48 4c       	lddpc	r12,80002328 <ShutDown_brdcst_func+0x2c>
8000231a:	f0 1f 00 03 	mcall	80002324 <ShutDown_brdcst_func+0x28>
8000231e:	d8 02       	popm	pc
80002320:	80 00       	ld.sh	r0,r0[0x0]
80002322:	d2 a4       	*unknown*
80002324:	80 00       	ld.sh	r0,r0[0x0]
80002326:	70 60       	ld.w	r0,r8[0x18]
80002328:	80 00       	ld.sh	r0,r0[0x0]
8000232a:	d2 b8       	*unknown*

8000232c <DataSession_reply_func>:
	
	
}

void DataSession_reply_func(xcmp_fragment_t * xcmp)
{
8000232c:	eb cd 40 80 	pushm	r7,lr
80002330:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
80002332:	19 a9       	ld.ub	r9,r12[0x2]
80002334:	30 08       	mov	r8,0
80002336:	f0 09 18 00 	cp.b	r9,r8
8000233a:	c0 61       	brne	80002346 <DataSession_reply_func+0x1a>
	{
		log("DATArep OK \n");
8000233c:	48 dc       	lddpc	r12,80002370 <DataSession_reply_func+0x44>
8000233e:	f0 1f 00 0e 	mcall	80002374 <DataSession_reply_func+0x48>
80002342:	e3 cd 80 80 	ldm	sp++,r7,pc
		//log("ID: %X \n", xcmp->u8[2]);
		
	}
	else
	{	
		log("DATArep error \n");
80002346:	48 dc       	lddpc	r12,80002378 <DataSession_reply_func+0x4c>
80002348:	f0 1f 00 0b 	mcall	80002374 <DataSession_reply_func+0x48>
		log("Result:  %X \n", xcmp->u8[0]);
8000234c:	0f a8       	ld.ub	r8,r7[0x2]
8000234e:	1a d8       	st.w	--sp,r8
80002350:	48 bc       	lddpc	r12,8000237c <DataSession_reply_func+0x50>
80002352:	f0 1f 00 09 	mcall	80002374 <DataSession_reply_func+0x48>
		log("Func:  %X \n", xcmp->u8[1]);
80002356:	0f b8       	ld.ub	r8,r7[0x3]
80002358:	1a d8       	st.w	--sp,r8
8000235a:	48 ac       	lddpc	r12,80002380 <DataSession_reply_func+0x54>
8000235c:	f0 1f 00 06 	mcall	80002374 <DataSession_reply_func+0x48>
		log("ID:  %X \n", xcmp->u8[2]);
80002360:	0f c8       	ld.ub	r8,r7[0x4]
80002362:	1a d8       	st.w	--sp,r8
80002364:	48 8c       	lddpc	r12,80002384 <DataSession_reply_func+0x58>
80002366:	f0 1f 00 04 	mcall	80002374 <DataSession_reply_func+0x48>
8000236a:	2f dd       	sub	sp,-12
8000236c:	e3 cd 80 80 	ldm	sp++,r7,pc
80002370:	80 00       	ld.sh	r0,r0[0x0]
80002372:	d2 c8       	*unknown*
80002374:	80 00       	ld.sh	r0,r0[0x0]
80002376:	70 60       	ld.w	r0,r8[0x18]
80002378:	80 00       	ld.sh	r0,r0[0x0]
8000237a:	d2 d8       	*unknown*
8000237c:	80 00       	ld.sh	r0,r0[0x0]
8000237e:	d2 e8       	*unknown*
80002380:	80 00       	ld.sh	r0,r0[0x0]
80002382:	d2 f8       	*unknown*
80002384:	80 00       	ld.sh	r0,r0[0x0]
80002386:	d3 04       	*unknown*

80002388 <CallControl_brdcst_func>:
	
}


void CallControl_brdcst_func(xcmp_fragment_t * xcmp)
{
80002388:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	CallControl_brdcst_t *ptr = (CallControl_brdcst_t* )xcmp->u8;
8000238c:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  CallControl brst \n\r ");
	//log("\n\r  Call_type: %x \n\r ", ptr->Calltype );
	log("\n\r  Call_state: %x \n\r ", ptr->Callstate );
80002390:	0f 98       	ld.ub	r8,r7[0x1]
80002392:	1a d8       	st.w	--sp,r8
80002394:	48 bc       	lddpc	r12,800023c0 <CallControl_brdcst_func+0x38>
80002396:	f0 1f 00 0c 	mcall	800023c4 <CallControl_brdcst_func+0x3c>
	if (ptr->Callstate == Call_Ended)//0x03
8000239a:	2f fd       	sub	sp,-4
8000239c:	0f 99       	ld.ub	r9,r7[0x1]
8000239e:	30 38       	mov	r8,3
800023a0:	f0 09 18 00 	cp.b	r9,r8
800023a4:	c0 41       	brne	800023ac <CallControl_brdcst_func+0x24>
	{
		//恢复正常语音路径通道
		//xcmp_audio_route_revert();
		Call_Begin = 0;
800023a6:	30 09       	mov	r9,0
800023a8:	48 88       	lddpc	r8,800023c8 <CallControl_brdcst_func+0x40>
800023aa:	b0 89       	st.b	r8[0x0],r9
		
	}
	
	if (ptr->Callstate == Call_Initiated)//0x04
800023ac:	0f 99       	ld.ub	r9,r7[0x1]
800023ae:	30 48       	mov	r8,4
800023b0:	f0 09 18 00 	cp.b	r9,r8
800023b4:	c0 41       	brne	800023bc <CallControl_brdcst_func+0x34>
	{
		Call_Begin = 1;
800023b6:	30 19       	mov	r9,1
800023b8:	48 48       	lddpc	r8,800023c8 <CallControl_brdcst_func+0x40>
800023ba:	b0 89       	st.b	r8[0x0],r9
800023bc:	e3 cd 80 80 	ldm	sp++,r7,pc
800023c0:	80 00       	ld.sh	r0,r0[0x0]
800023c2:	d3 10       	acall	0x31
800023c4:	80 00       	ld.sh	r0,r0[0x0]
800023c6:	70 60       	ld.w	r0,r8[0x18]
800023c8:	00 00       	add	r0,r0
800023ca:	0a 4e       	or	lr,r5

800023cc <TransmitControl_brdcst_func>:

}


void TransmitControl_brdcst_func(xcmp_fragment_t * xcmp)
{
800023cc:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	TransmitControl_brdcast_t *ptr = (TransmitControl_brdcast_t* )xcmp->u8;
800023d0:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  TransmitControl broadcast \n\r ");
	//log("\n\r  Mode_Of_Operation: %x \n\r ", ptr->Mode_Of_Operation );
	if (ptr->State == 0x00)
800023d4:	0f 99       	ld.ub	r9,r7[0x1]
800023d6:	30 08       	mov	r8,0
800023d8:	f0 09 18 00 	cp.b	r9,r8
800023dc:	c0 71       	brne	800023ea <TransmitControl_brdcst_func+0x1e>
	{
		log("\n\r  Standby-Receive \n\r ");
800023de:	48 ac       	lddpc	r12,80002404 <TransmitControl_brdcst_func+0x38>
800023e0:	f0 1f 00 0a 	mcall	80002408 <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 0;
800023e4:	30 09       	mov	r9,0
800023e6:	48 a8       	lddpc	r8,8000240c <TransmitControl_brdcst_func+0x40>
800023e8:	b0 89       	st.b	r8[0x0],r9
	}
	if (ptr->State == 0x01)
800023ea:	0f 99       	ld.ub	r9,r7[0x1]
800023ec:	30 18       	mov	r8,1
800023ee:	f0 09 18 00 	cp.b	r9,r8
800023f2:	c0 71       	brne	80002400 <TransmitControl_brdcst_func+0x34>
	{
		log("\n\r  Transmit \n\r ");
800023f4:	48 7c       	lddpc	r12,80002410 <TransmitControl_brdcst_func+0x44>
800023f6:	f0 1f 00 05 	mcall	80002408 <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 1;
800023fa:	30 19       	mov	r9,1
800023fc:	48 48       	lddpc	r8,8000240c <TransmitControl_brdcst_func+0x40>
800023fe:	b0 89       	st.b	r8[0x0],r9
80002400:	e3 cd 80 80 	ldm	sp++,r7,pc
80002404:	80 00       	ld.sh	r0,r0[0x0]
80002406:	d3 28       	*unknown*
80002408:	80 00       	ld.sh	r0,r0[0x0]
8000240a:	70 60       	ld.w	r0,r8[0x18]
8000240c:	00 00       	add	r0,r0
8000240e:	0a 4d       	or	sp,r5
80002410:	80 00       	ld.sh	r0,r0[0x0]
80002412:	d3 40       	acall	0x34

80002414 <TransmitControl_reply_func>:




void TransmitControl_reply_func(xcmp_fragment_t * xcmp)
{
80002414:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	TransmitControl_reply_t *ptr = (TransmitControl_reply_t* )xcmp->u8;
80002418:	f8 c7 ff fe 	sub	r7,r12,-2
	
	if (ptr->Result == xcmp_Res_Success)
8000241c:	0f 89       	ld.ub	r9,r7[0x0]
8000241e:	30 08       	mov	r8,0
80002420:	f0 09 18 00 	cp.b	r9,r8
80002424:	c1 61       	brne	80002450 <TransmitControl_reply_func+0x3c>
	{
		
		log("\n\r  TransmitControl OK \n\r ");
80002426:	48 ec       	lddpc	r12,8000245c <TransmitControl_reply_func+0x48>
80002428:	f0 1f 00 0e 	mcall	80002460 <TransmitControl_reply_func+0x4c>
		log("\n\r Function: %x \n\r", ptr->Function);
8000242c:	0f 98       	ld.ub	r8,r7[0x1]
8000242e:	1a d8       	st.w	--sp,r8
80002430:	48 dc       	lddpc	r12,80002464 <TransmitControl_reply_func+0x50>
80002432:	f0 1f 00 0c 	mcall	80002460 <TransmitControl_reply_func+0x4c>
		log("\n\r Mode of Operation: %x \n\r", ptr->Mode_Of_Operation);
80002436:	0f a8       	ld.ub	r8,r7[0x2]
80002438:	1a d8       	st.w	--sp,r8
8000243a:	48 cc       	lddpc	r12,80002468 <TransmitControl_reply_func+0x54>
8000243c:	f0 1f 00 09 	mcall	80002460 <TransmitControl_reply_func+0x4c>
		log("\n\r State: %x \n\r", ptr->State);
80002440:	0f b8       	ld.ub	r8,r7[0x3]
80002442:	1a d8       	st.w	--sp,r8
80002444:	48 ac       	lddpc	r12,8000246c <TransmitControl_reply_func+0x58>
80002446:	f0 1f 00 07 	mcall	80002460 <TransmitControl_reply_func+0x4c>
8000244a:	2f dd       	sub	sp,-12
8000244c:	e3 cd 80 80 	ldm	sp++,r7,pc
		
		//Silent_flag = 1;
	}
	else
	{
		log("TransmitControl error");
80002450:	48 8c       	lddpc	r12,80002470 <TransmitControl_reply_func+0x5c>
80002452:	f0 1f 00 04 	mcall	80002460 <TransmitControl_reply_func+0x4c>
80002456:	e3 cd 80 80 	ldm	sp++,r7,pc
8000245a:	00 00       	add	r0,r0
8000245c:	80 00       	ld.sh	r0,r0[0x0]
8000245e:	d3 54       	*unknown*
80002460:	80 00       	ld.sh	r0,r0[0x0]
80002462:	70 60       	ld.w	r0,r8[0x18]
80002464:	80 00       	ld.sh	r0,r0[0x0]
80002466:	d3 70       	acall	0x37
80002468:	80 00       	ld.sh	r0,r0[0x0]
8000246a:	d3 84       	*unknown*
8000246c:	80 00       	ld.sh	r0,r0[0x0]
8000246e:	d3 a0       	acall	0x3a
80002470:	80 00       	ld.sh	r0,r0[0x0]
80002472:	d3 b0       	acall	0x3b

80002474 <AudioRoutingControl_reply_func>:
	
}


void AudioRoutingControl_reply_func(xcmp_fragment_t * xcmp)
{
80002474:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
80002476:	19 a9       	ld.ub	r9,r12[0x2]
80002478:	30 08       	mov	r8,0
8000247a:	f0 09 18 00 	cp.b	r9,r8
8000247e:	c0 51       	brne	80002488 <AudioRoutingControl_reply_func+0x14>
	{
		log("AudioRouting OK");
80002480:	48 4c       	lddpc	r12,80002490 <AudioRoutingControl_reply_func+0x1c>
80002482:	f0 1f 00 05 	mcall	80002494 <AudioRoutingControl_reply_func+0x20>
80002486:	d8 02       	popm	pc
		//xcmp_IdleTestTone();
		//Speaker_is_unmute = 1;
	}
	else
	{
		log("AudioRouting error");
80002488:	48 4c       	lddpc	r12,80002498 <AudioRoutingControl_reply_func+0x24>
8000248a:	f0 1f 00 03 	mcall	80002494 <AudioRoutingControl_reply_func+0x20>
8000248e:	d8 02       	popm	pc
80002490:	80 00       	ld.sh	r0,r0[0x0]
80002492:	d3 c8       	*unknown*
80002494:	80 00       	ld.sh	r0,r0[0x0]
80002496:	70 60       	ld.w	r0,r8[0x18]
80002498:	80 00       	ld.sh	r0,r0[0x0]
8000249a:	d3 d8       	*unknown*

8000249c <Volume_reply_func>:
	
}


void Volume_reply_func(xcmp_fragment_t * xcmp)
{
8000249c:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	VolumeControl_reply_t *ptr = (VolumeControl_reply_t* )xcmp->u8;
800024a0:	f8 c7 ff fe 	sub	r7,r12,-2
	
		if (ptr->Result == xcmp_Res_Success)
800024a4:	0f 89       	ld.ub	r9,r7[0x0]
800024a6:	30 08       	mov	r8,0
800024a8:	f0 09 18 00 	cp.b	r9,r8
800024ac:	c1 b1       	brne	800024e2 <Volume_reply_func+0x46>
		{
			if (ptr->Function == Enable_IntelligentAudio)
800024ae:	0f b8       	ld.ub	r8,r7[0x3]
800024b0:	31 09       	mov	r9,16
800024b2:	f2 08 18 00 	cp.b	r8,r9
800024b6:	c0 f1       	brne	800024d4 <Volume_reply_func+0x38>
			{
				log("\n\r Enable_IA OK \n\r");
800024b8:	48 dc       	lddpc	r12,800024ec <Volume_reply_func+0x50>
800024ba:	f0 1f 00 0e 	mcall	800024f0 <Volume_reply_func+0x54>
				log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
800024be:	0f 99       	ld.ub	r9,r7[0x1]
800024c0:	0f a8       	ld.ub	r8,r7[0x2]
800024c2:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800024c6:	1a d8       	st.w	--sp,r8
800024c8:	48 bc       	lddpc	r12,800024f4 <Volume_reply_func+0x58>
800024ca:	f0 1f 00 0a 	mcall	800024f0 <Volume_reply_func+0x54>
800024ce:	2f fd       	sub	sp,-4
800024d0:	e3 cd 80 80 	ldm	sp++,r7,pc
	
			}
			else
			{
				
				log("\n\r VolumeControl: %x \n\r", ptr->Function);
800024d4:	1a d8       	st.w	--sp,r8
800024d6:	48 9c       	lddpc	r12,800024f8 <Volume_reply_func+0x5c>
800024d8:	f0 1f 00 06 	mcall	800024f0 <Volume_reply_func+0x54>
800024dc:	2f fd       	sub	sp,-4
800024de:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		
		else
		{
			log("\n\r Enable_IA error \n\r");
800024e2:	48 7c       	lddpc	r12,800024fc <Volume_reply_func+0x60>
800024e4:	f0 1f 00 03 	mcall	800024f0 <Volume_reply_func+0x54>
800024e8:	e3 cd 80 80 	ldm	sp++,r7,pc
800024ec:	80 00       	ld.sh	r0,r0[0x0]
800024ee:	d3 ec       	*unknown*
800024f0:	80 00       	ld.sh	r0,r0[0x0]
800024f2:	70 60       	ld.w	r0,r8[0x18]
800024f4:	80 00       	ld.sh	r0,r0[0x0]
800024f6:	d4 00       	acall	0x40
800024f8:	80 00       	ld.sh	r0,r0[0x0]
800024fa:	d4 1c       	*unknown*
800024fc:	80 00       	ld.sh	r0,r0[0x0]
800024fe:	d4 34       	*unknown*

80002500 <spk_brdcst_func>:
		log("spk error");
	}
}

void spk_brdcst_func(xcmp_fragment_t * xcmp)
{
80002500:	d4 01       	pushm	lr
	if (xcmp->u8[3] == xcmp_Res_Success)//0x0000:mute
80002502:	19 d9       	ld.ub	r9,r12[0x5]
80002504:	30 08       	mov	r8,0
80002506:	f0 09 18 00 	cp.b	r9,r8
8000250a:	c0 81       	brne	8000251a <spk_brdcst_func+0x1a>
	{
		Speaker_is_unmute =0;
8000250c:	10 99       	mov	r9,r8
8000250e:	48 78       	lddpc	r8,80002528 <spk_brdcst_func+0x28>
80002510:	b0 89       	st.b	r8[0x0],r9
		//Silent_flag = 0;
		log("spk_s_close ");
80002512:	48 7c       	lddpc	r12,8000252c <spk_brdcst_func+0x2c>
80002514:	f0 1f 00 07 	mcall	80002530 <spk_brdcst_func+0x30>
80002518:	d8 02       	popm	pc
		
	}
	else
	{
		//Silent_flag = 1;
		Speaker_is_unmute = 1;
8000251a:	30 19       	mov	r9,1
8000251c:	48 38       	lddpc	r8,80002528 <spk_brdcst_func+0x28>
8000251e:	b0 89       	st.b	r8[0x0],r9
		log("spk_s_open ");	
80002520:	48 5c       	lddpc	r12,80002534 <spk_brdcst_func+0x34>
80002522:	f0 1f 00 04 	mcall	80002530 <spk_brdcst_func+0x30>
80002526:	d8 02       	popm	pc
80002528:	00 00       	add	r0,r0
8000252a:	0a 40       	or	r0,r5
8000252c:	80 00       	ld.sh	r0,r0[0x0]
8000252e:	d4 4c       	*unknown*
80002530:	80 00       	ld.sh	r0,r0[0x0]
80002532:	70 60       	ld.w	r0,r8[0x18]
80002534:	80 00       	ld.sh	r0,r0[0x0]
80002536:	d4 5c       	*unknown*

80002538 <spk_reply_func>:
			
	
}

void spk_reply_func(xcmp_fragment_t * xcmp)
{
80002538:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
8000253a:	19 a9       	ld.ub	r9,r12[0x2]
8000253c:	30 08       	mov	r8,0
8000253e:	f0 09 18 00 	cp.b	r9,r8
80002542:	c0 f1       	brne	80002560 <spk_reply_func+0x28>
	{
		
		if(xcmp->u8[4])
80002544:	19 e9       	ld.ub	r9,r12[0x6]
80002546:	f0 09 18 00 	cp.b	r9,r8
8000254a:	c0 40       	breq	80002552 <spk_reply_func+0x1a>
		{
			Speaker_is_unmute = 1;
8000254c:	30 19       	mov	r9,1
8000254e:	48 98       	lddpc	r8,80002570 <spk_reply_func+0x38>
80002550:	b0 89       	st.b	r8[0x0],r9
			
			//Silent_flag = 1;
		}
		log("spk OK -st%2x", xcmp->u8[4] );
80002552:	19 e8       	ld.ub	r8,r12[0x6]
80002554:	1a d8       	st.w	--sp,r8
80002556:	48 8c       	lddpc	r12,80002574 <spk_reply_func+0x3c>
80002558:	f0 1f 00 08 	mcall	80002578 <spk_reply_func+0x40>
8000255c:	2f fd       	sub	sp,-4
8000255e:	d8 02       	popm	pc
		
	}
	else
	{
		Speaker_is_unmute = 0;
80002560:	30 09       	mov	r9,0
80002562:	48 48       	lddpc	r8,80002570 <spk_reply_func+0x38>
80002564:	b0 89       	st.b	r8[0x0],r9
		log("spk error");
80002566:	48 6c       	lddpc	r12,8000257c <spk_reply_func+0x44>
80002568:	f0 1f 00 04 	mcall	80002578 <spk_reply_func+0x40>
8000256c:	d8 02       	popm	pc
8000256e:	00 00       	add	r0,r0
80002570:	00 00       	add	r0,r0
80002572:	0a 40       	or	r0,r5
80002574:	80 00       	ld.sh	r0,r0[0x0]
80002576:	d4 68       	*unknown*
80002578:	80 00       	ld.sh	r0,r0[0x0]
8000257a:	70 60       	ld.w	r0,r8[0x18]
8000257c:	80 00       	ld.sh	r0,r0[0x0]
8000257e:	d4 78       	*unknown*

80002580 <mic_brdcst_func>:
	
	
}

void mic_brdcst_func(xcmp_fragment_t * xcmp)
{
80002580:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_brdcast_t *ptr = (MicControl_brdcast_t* )xcmp->u8;
80002584:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r Mic_brdcst \n\r");		
	//log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
	//log("\n\r Signal_type: %x \n\r " ,  ptr->Signaling_Type);
	if (ptr->Mic_State == 0x00)
80002588:	0f a9       	ld.ub	r9,r7[0x2]
8000258a:	30 08       	mov	r8,0
8000258c:	f0 09 18 00 	cp.b	r9,r8
80002590:	c0 71       	brne	8000259e <mic_brdcst_func+0x1e>
	{
		log("\n\r Mic_Disabled \n\r");	
80002592:	48 dc       	lddpc	r12,800025c4 <mic_brdcst_func+0x44>
80002594:	f0 1f 00 0d 	mcall	800025c8 <mic_brdcst_func+0x48>
		Mic_is_Enabled = 0;
80002598:	30 09       	mov	r9,0
8000259a:	48 d8       	lddpc	r8,800025cc <mic_brdcst_func+0x4c>
8000259c:	b0 89       	st.b	r8[0x0],r9
	} 
	if(ptr->Mic_State == 0x11)
8000259e:	0f a9       	ld.ub	r9,r7[0x2]
800025a0:	31 18       	mov	r8,17
800025a2:	f0 09 18 00 	cp.b	r9,r8
800025a6:	c0 d1       	brne	800025c0 <mic_brdcst_func+0x40>
	{
		log("\n\r Mic_Enabled \n\r");
800025a8:	48 ac       	lddpc	r12,800025d0 <mic_brdcst_func+0x50>
800025aa:	f0 1f 00 08 	mcall	800025c8 <mic_brdcst_func+0x48>
		Mic_is_Enabled = 1;
800025ae:	48 89       	lddpc	r9,800025cc <mic_brdcst_func+0x4c>
800025b0:	30 18       	mov	r8,1
800025b2:	b2 88       	st.b	r9[0x0],r8
		
		if ((Mic_is_Enabled == 1) && (Call_Begin == 1))
800025b4:	13 89       	ld.ub	r9,r9[0x0]
800025b6:	f0 09 18 00 	cp.b	r9,r8
800025ba:	c0 31       	brne	800025c0 <mic_brdcst_func+0x40>
800025bc:	48 68       	lddpc	r8,800025d4 <mic_brdcst_func+0x54>
800025be:	11 88       	ld.ub	r8,r8[0x0]
800025c0:	e3 cd 80 80 	ldm	sp++,r7,pc
800025c4:	80 00       	ld.sh	r0,r0[0x0]
800025c6:	d4 84       	*unknown*
800025c8:	80 00       	ld.sh	r0,r0[0x0]
800025ca:	70 60       	ld.w	r0,r8[0x18]
800025cc:	00 00       	add	r0,r0
800025ce:	0a 5d       	eor	sp,r5
800025d0:	80 00       	ld.sh	r0,r0[0x0]
800025d2:	d4 98       	*unknown*
800025d4:	00 00       	add	r0,r0
800025d6:	0a 4e       	or	lr,r5

800025d8 <mic_reply_func>:
	
	
}

void mic_reply_func(xcmp_fragment_t * xcmp)
{
800025d8:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_reply_t *ptr = (MicControl_reply_t* )xcmp->u8;
800025dc:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Mic_reply \n\r");
800025e0:	49 ac       	lddpc	r12,80002648 <mic_reply_func+0x70>
800025e2:	f0 1f 00 1b 	mcall	8000264c <mic_reply_func+0x74>
	if (ptr->Result == 0x00)
800025e6:	0f 89       	ld.ub	r9,r7[0x0]
800025e8:	30 08       	mov	r8,0
800025ea:	f0 09 18 00 	cp.b	r9,r8
800025ee:	c2 71       	brne	8000263c <mic_reply_func+0x64>
	{
		
		if (ptr->Function == Mic_Disable)
800025f0:	0f 98       	ld.ub	r8,r7[0x1]
800025f2:	30 29       	mov	r9,2
800025f4:	f2 08 18 00 	cp.b	r8,r9
800025f8:	c1 b1       	brne	8000262e <mic_reply_func+0x56>
		{
		
			log("\n\r Mic_close_ok \n\r " );
800025fa:	49 6c       	lddpc	r12,80002650 <mic_reply_func+0x78>
800025fc:	f0 1f 00 14 	mcall	8000264c <mic_reply_func+0x74>
			log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
80002600:	0f a8       	ld.ub	r8,r7[0x2]
80002602:	1a d8       	st.w	--sp,r8
80002604:	49 4c       	lddpc	r12,80002654 <mic_reply_func+0x7c>
80002606:	f0 1f 00 12 	mcall	8000264c <mic_reply_func+0x74>
			log("\n\r Signaling_type: %x \n\r " ,  ptr->Signaling_Type);
8000260a:	0f b8       	ld.ub	r8,r7[0x3]
8000260c:	1a d8       	st.w	--sp,r8
8000260e:	49 3c       	lddpc	r12,80002658 <mic_reply_func+0x80>
80002610:	f0 1f 00 0f 	mcall	8000264c <mic_reply_func+0x74>
			log("\n\r Mic_state: %x \n\r " ,  ptr->Mic_State);
80002614:	0f c8       	ld.ub	r8,r7[0x4]
80002616:	1a d8       	st.w	--sp,r8
80002618:	49 1c       	lddpc	r12,8000265c <mic_reply_func+0x84>
8000261a:	f0 1f 00 0d 	mcall	8000264c <mic_reply_func+0x74>
			log("\n\r Gain_offset: %x \n\r " ,  ptr->Gain_Offset);
8000261e:	0f d8       	ld.ub	r8,r7[0x5]
80002620:	1a d8       	st.w	--sp,r8
80002622:	49 0c       	lddpc	r12,80002660 <mic_reply_func+0x88>
80002624:	f0 1f 00 0a 	mcall	8000264c <mic_reply_func+0x74>
80002628:	2f cd       	sub	sp,-16
8000262a:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else
		{
			log("\n\r Mic_function: %x \n\r ", ptr->Function );
8000262e:	1a d8       	st.w	--sp,r8
80002630:	48 dc       	lddpc	r12,80002664 <mic_reply_func+0x8c>
80002632:	f0 1f 00 07 	mcall	8000264c <mic_reply_func+0x74>
80002636:	2f fd       	sub	sp,-4
80002638:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else 
	{
		
	
		log("\n\r Mic error \n\r");
8000263c:	48 bc       	lddpc	r12,80002668 <mic_reply_func+0x90>
8000263e:	f0 1f 00 04 	mcall	8000264c <mic_reply_func+0x74>
80002642:	e3 cd 80 80 	ldm	sp++,r7,pc
80002646:	00 00       	add	r0,r0
80002648:	80 00       	ld.sh	r0,r0[0x0]
8000264a:	d4 ac       	*unknown*
8000264c:	80 00       	ld.sh	r0,r0[0x0]
8000264e:	70 60       	ld.w	r0,r8[0x18]
80002650:	80 00       	ld.sh	r0,r0[0x0]
80002652:	d4 bc       	*unknown*
80002654:	80 00       	ld.sh	r0,r0[0x0]
80002656:	d4 d0       	acall	0x4d
80002658:	80 00       	ld.sh	r0,r0[0x0]
8000265a:	d4 e4       	*unknown*
8000265c:	80 00       	ld.sh	r0,r0[0x0]
8000265e:	d5 00       	acall	0x50
80002660:	80 00       	ld.sh	r0,r0[0x0]
80002662:	d5 18       	*unknown*
80002664:	80 00       	ld.sh	r0,r0[0x0]
80002666:	d5 30       	acall	0x53
80002668:	80 00       	ld.sh	r0,r0[0x0]
8000266a:	d5 48       	*unknown*

8000266c <dcm_brdcst_func>:
	}
}


void dcm_brdcst_func(xcmp_fragment_t * xcmp)
{
8000266c:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	DeviceControlMode_brdcst_t *ptr = (DeviceControlMode_brdcst_t* )xcmp->u8;
80002670:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Dcm_brdcst \n\r");		
80002674:	48 bc       	lddpc	r12,800026a0 <dcm_brdcst_func+0x34>
80002676:	f0 1f 00 0c 	mcall	800026a4 <dcm_brdcst_func+0x38>
	log("\n\r Function: %x \n\r " ,  ptr->Function);
8000267a:	0f 88       	ld.ub	r8,r7[0x0]
8000267c:	1a d8       	st.w	--sp,r8
8000267e:	48 bc       	lddpc	r12,800026a8 <dcm_brdcst_func+0x3c>
80002680:	f0 1f 00 09 	mcall	800026a4 <dcm_brdcst_func+0x38>
	log("\n\r ControlType: %x \n\r " ,  ptr->ControlType);
80002684:	0f a8       	ld.ub	r8,r7[0x2]
80002686:	1a d8       	st.w	--sp,r8
80002688:	48 9c       	lddpc	r12,800026ac <dcm_brdcst_func+0x40>
8000268a:	f0 1f 00 07 	mcall	800026a4 <dcm_brdcst_func+0x38>
	log("\n\r ControlTypeSize: %x \n\r " ,  ptr->ControlTypeSize);
8000268e:	0f 98       	ld.ub	r8,r7[0x1]
80002690:	1a d8       	st.w	--sp,r8
80002692:	48 8c       	lddpc	r12,800026b0 <dcm_brdcst_func+0x44>
80002694:	f0 1f 00 04 	mcall	800026a4 <dcm_brdcst_func+0x38>
80002698:	2f dd       	sub	sp,-12
	
	
}
8000269a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000269e:	00 00       	add	r0,r0
800026a0:	80 00       	ld.sh	r0,r0[0x0]
800026a2:	d5 58       	*unknown*
800026a4:	80 00       	ld.sh	r0,r0[0x0]
800026a6:	70 60       	ld.w	r0,r8[0x18]
800026a8:	80 00       	ld.sh	r0,r0[0x0]
800026aa:	d5 6c       	*unknown*
800026ac:	80 00       	ld.sh	r0,r0[0x0]
800026ae:	d5 80       	acall	0x58
800026b0:	80 00       	ld.sh	r0,r0[0x0]
800026b2:	d5 98       	*unknown*

800026b4 <dcm_reply_func>:
		log("Tone error");
	}
}

void dcm_reply_func(xcmp_fragment_t * xcmp)
{
800026b4:	eb cd 40 80 	pushm	r7,lr
800026b8:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
800026ba:	19 a9       	ld.ub	r9,r12[0x2]
800026bc:	30 08       	mov	r8,0
800026be:	f0 09 18 00 	cp.b	r9,r8
800026c2:	c1 b1       	brne	800026f8 <dcm_reply_func+0x44>
	{
		if(xcmp->u8[1] == DCM_ENTER)
800026c4:	19 b8       	ld.ub	r8,r12[0x3]
800026c6:	30 19       	mov	r9,1
800026c8:	f2 08 18 00 	cp.b	r8,r9
800026cc:	c0 51       	brne	800026d6 <dcm_reply_func+0x22>
		{
			log("\n\r Dcm-Enter OK \n\r");
800026ce:	48 ec       	lddpc	r12,80002704 <dcm_reply_func+0x50>
800026d0:	f0 1f 00 0e 	mcall	80002708 <dcm_reply_func+0x54>
800026d4:	c0 a8       	rjmp	800026e8 <dcm_reply_func+0x34>
			
		}
		else if (xcmp->u8[1] == DCM_EXIT)
800026d6:	58 08       	cp.w	r8,0
800026d8:	c0 51       	brne	800026e2 <dcm_reply_func+0x2e>
		{
			log("\n\r Dcm-Exit OK \n\r");
800026da:	48 dc       	lddpc	r12,8000270c <dcm_reply_func+0x58>
800026dc:	f0 1f 00 0b 	mcall	80002708 <dcm_reply_func+0x54>
800026e0:	c0 48       	rjmp	800026e8 <dcm_reply_func+0x34>
		}
		else
		{
			log("\n\r Dcm-Revoke \n\r");
800026e2:	48 cc       	lddpc	r12,80002710 <dcm_reply_func+0x5c>
800026e4:	f0 1f 00 09 	mcall	80002708 <dcm_reply_func+0x54>
		}
		
		log("dcm OK-mo%X", xcmp->u8[3]);
800026e8:	0f d8       	ld.ub	r8,r7[0x5]
800026ea:	1a d8       	st.w	--sp,r8
800026ec:	48 ac       	lddpc	r12,80002714 <dcm_reply_func+0x60>
800026ee:	f0 1f 00 07 	mcall	80002708 <dcm_reply_func+0x54>
800026f2:	2f fd       	sub	sp,-4
800026f4:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		log("dcm error");
800026f8:	48 8c       	lddpc	r12,80002718 <dcm_reply_func+0x64>
800026fa:	f0 1f 00 04 	mcall	80002708 <dcm_reply_func+0x54>
800026fe:	e3 cd 80 80 	ldm	sp++,r7,pc
80002702:	00 00       	add	r0,r0
80002704:	80 00       	ld.sh	r0,r0[0x0]
80002706:	d5 b4       	*unknown*
80002708:	80 00       	ld.sh	r0,r0[0x0]
8000270a:	70 60       	ld.w	r0,r8[0x18]
8000270c:	80 00       	ld.sh	r0,r0[0x0]
8000270e:	d5 c8       	*unknown*
80002710:	80 00       	ld.sh	r0,r0[0x0]
80002712:	d5 dc       	*unknown*
80002714:	80 00       	ld.sh	r0,r0[0x0]
80002716:	d5 f0       	acall	0x5f
80002718:	80 00       	ld.sh	r0,r0[0x0]
8000271a:	d5 fc       	*unknown*

8000271c <ToneControl_reply_func>:
			//log("Device State : %d\n", ptr->Device_State);
		}
}

void ToneControl_reply_func(xcmp_fragment_t * xcmp)
{
8000271c:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
8000271e:	19 a9       	ld.ub	r9,r12[0x2]
80002720:	30 08       	mov	r8,0
80002722:	f0 09 18 00 	cp.b	r9,r8
80002726:	c0 51       	brne	80002730 <ToneControl_reply_func+0x14>
	{		
		log("Tone OK\n");
80002728:	48 4c       	lddpc	r12,80002738 <ToneControl_reply_func+0x1c>
8000272a:	f0 1f 00 05 	mcall	8000273c <ToneControl_reply_func+0x20>
8000272e:	d8 02       	popm	pc
		//fl_write("/test.txt", FILE_END, (void *)"send tone ok\r\n", sizeof("send tone ok\r\n") - 1);
	}
	else
	{
		log("Tone error");
80002730:	48 4c       	lddpc	r12,80002740 <ToneControl_reply_func+0x24>
80002732:	f0 1f 00 03 	mcall	8000273c <ToneControl_reply_func+0x20>
80002736:	d8 02       	popm	pc
80002738:	80 00       	ld.sh	r0,r0[0x0]
8000273a:	d6 08       	*unknown*
8000273c:	80 00       	ld.sh	r0,r0[0x0]
8000273e:	70 60       	ld.w	r0,r8[0x18]
80002740:	80 00       	ld.sh	r0,r0[0x0]
80002742:	d6 14       	*unknown*

80002744 <app_init>:
	//0x00,0x39


};
void app_init(void)
{	
80002744:	d4 01       	pushm	lr
	xcmp_register_app_list(the_app_list);
80002746:	49 1c       	lddpc	r12,80002788 <app_init+0x44>
80002748:	f0 1f 00 11 	mcall	8000278c <app_init+0x48>
	
	//将app_payload_rx_proc更改为PCM加密功能
	payload_init( app_payload_rx_proc , app_payload_tx_proc );
8000274c:	49 1b       	lddpc	r11,80002790 <app_init+0x4c>
8000274e:	49 2c       	lddpc	r12,80002794 <app_init+0x50>
80002750:	f0 1f 00 12 	mcall	80002798 <app_init+0x54>
	
	/* Create the mutex semaphore to guard a shared global_count.*/
	count_mutex = xSemaphoreCreateMutex();
80002754:	f0 1f 00 12 	mcall	8000279c <app_init+0x58>
80002758:	49 28       	lddpc	r8,800027a0 <app_init+0x5c>
8000275a:	91 0c       	st.w	r8[0x0],r12
	if (count_mutex == NULL)
8000275c:	70 08       	ld.w	r8,r8[0x0]
8000275e:	58 08       	cp.w	r8,0
80002760:	c0 41       	brne	80002768 <app_init+0x24>
	{
		log("Create the count_mutex semaphore failure\n");
80002762:	49 1c       	lddpc	r12,800027a4 <app_init+0x60>
80002764:	f0 1f 00 11 	mcall	800027a8 <app_init+0x64>
	}
	
	
	static portBASE_TYPE res = 0;
	 res = xTaskCreate(
80002768:	30 09       	mov	r9,0
8000276a:	1a d9       	st.w	--sp,r9
8000276c:	1a d9       	st.w	--sp,r9
8000276e:	1a d9       	st.w	--sp,r9
80002770:	30 18       	mov	r8,1
80002772:	e0 6a 03 20 	mov	r10,800
80002776:	48 eb       	lddpc	r11,800027ac <app_init+0x68>
80002778:	48 ec       	lddpc	r12,800027b0 <app_init+0x6c>
8000277a:	f0 1f 00 0f 	mcall	800027b4 <app_init+0x70>
8000277e:	48 f8       	lddpc	r8,800027b8 <app_init+0x74>
80002780:	91 0c       	st.w	r8[0x0],r12
80002782:	2f dd       	sub	sp,-12
	,  800//1024//800//384
	,  NULL
	,  1
	,  NULL );
		
}
80002784:	d8 02       	popm	pc
80002786:	00 00       	add	r0,r0
80002788:	00 00       	add	r0,r0
8000278a:	00 08       	add	r8,r0
8000278c:	80 00       	ld.sh	r0,r0[0x0]
8000278e:	3f 9c       	mov	r12,-7
80002790:	80 00       	ld.sh	r0,r0[0x0]
80002792:	20 58       	sub	r8,5
80002794:	80 00       	ld.sh	r0,r0[0x0]
80002796:	20 6c       	sub	r12,6
80002798:	80 00       	ld.sh	r0,r0[0x0]
8000279a:	2c 4c       	sub	r12,-60
8000279c:	80 00       	ld.sh	r0,r0[0x0]
8000279e:	65 28       	ld.w	r8,r2[0x48]
800027a0:	00 00       	add	r0,r0
800027a2:	0a 60       	and	r0,r5
800027a4:	80 00       	ld.sh	r0,r0[0x0]
800027a6:	d6 20       	acall	0x62
800027a8:	80 00       	ld.sh	r0,r0[0x0]
800027aa:	70 60       	ld.w	r0,r8[0x18]
800027ac:	80 00       	ld.sh	r0,r0[0x0]
800027ae:	d6 4c       	*unknown*
800027b0:	80 00       	ld.sh	r0,r0[0x0]
800027b2:	27 bc       	sub	r12,123
800027b4:	80 00       	ld.sh	r0,r0[0x0]
800027b6:	6c 9c       	ld.w	r12,r6[0x24]
800027b8:	00 00       	add	r0,r0
800027ba:	0a 58       	eor	r8,r5

800027bc <app_cfg>:
extern void xnl_send_device_master_query(void);
//extern portTickType water_value;
//extern portTickType tx_water_value;
//extern portTickType log_water_value;
static __app_Thread_(app_cfg)
{
800027bc:	d4 31       	pushm	r0-r7,lr
800027be:	21 5d       	sub	sp,84
	static  portTickType xLastWakeTime;
	const portTickType xFrequency = 4000;//2s,定时问题已经修正。2s x  2000hz = 4000
	U8 Burst_ID = 0;
	char card_id[4]={0};
	U16  * data_ptr;
	Message_Protocol_t *m_buff = (Message_Protocol_t *) pvPortMalloc(sizeof(Message_Protocol_t));
800027c0:	31 ac       	mov	r12,26
800027c2:	f0 1f 00 70 	mcall	80002980 <app_cfg+0x1c4>
	static	OB_States OB_State = OB_UNCONNECTEDWAITINGSTATUS;
	static xgflash_status_t status = XG_ERROR;
	xLastWakeTime = xTaskGetTickCount();
800027c6:	f0 1f 00 70 	mcall	80002984 <app_cfg+0x1c8>
800027ca:	4f 08       	lddpc	r8,80002988 <app_cfg+0x1cc>
800027cc:	91 0c       	st.w	r8[0x0],r12
	
	static const uint8_t test_data[8] = {0x11, 0x23, 0x33, 0x67, 0x89, 0xAB, 0xCD, 0xEF};
	char str[80];
	memset(str, 0x00, 80);
800027ce:	35 0a       	mov	r10,80
800027d0:	30 0b       	mov	r11,0
800027d2:	1a 9c       	mov	r12,sp
800027d4:	f0 1f 00 6e 	mcall	8000298c <app_cfg+0x1d0>
	
	/* 'Give' the semaphore to unblock the task. */
	 //if( xBinarySemaphore != NULL ){
		//xSemaphoreGive(xBinarySemaphore);
	 //}
	 xSemaphoreTake(xBinarySemaphore, portMAX_DELAY); 
800027d8:	4e e8       	lddpc	r8,80002990 <app_cfg+0x1d4>
800027da:	70 0c       	ld.w	r12,r8[0x0]
800027dc:	30 09       	mov	r9,0
800027de:	3f fa       	mov	r10,-1
800027e0:	12 9b       	mov	r11,r9
800027e2:	f0 1f 00 6d 	mcall	80002994 <app_cfg+0x1d8>
		
	for(;;)
	{
		switch(OB_State)
800027e6:	4e d5       	lddpc	r5,80002998 <app_cfg+0x1dc>
		{
			case OB_UNCONNECTEDWAITINGSTATUS:
			
				if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
800027e8:	4e d4       	lddpc	r4,8000299c <app_cfg+0x1e0>
					nop();
					nop();
					nop();
					/*send device_master_query to connect radio*/
					xnl_send_device_master_query();
					log("connecting...\n");
800027ea:	4e e2       	lddpc	r2,800029a0 <app_cfg+0x1e4>
					vTaskDelayUntil( &xLastWakeTime, (1000*2) / portTICK_RATE_MS  );//精确的以1000ms为周期执行。
800027ec:	4e 76       	lddpc	r6,80002988 <app_cfg+0x1cc>
800027ee:	e0 67 07 d0 	mov	r7,2000
	{
		switch(OB_State)
		{
			case OB_UNCONNECTEDWAITINGSTATUS:
			
				if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
800027f2:	4e d3       	lddpc	r3,800029a4 <app_cfg+0x1e8>
	 //}
	 xSemaphoreTake(xBinarySemaphore, portMAX_DELAY); 
		
	for(;;)
	{
		switch(OB_State)
800027f4:	6a 08       	ld.w	r8,r5[0x0]
800027f6:	58 08       	cp.w	r8,0
800027f8:	c0 50       	breq	80002802 <app_cfg+0x46>
800027fa:	58 38       	cp.w	r8,3
800027fc:	e0 81 00 bc 	brne	80002974 <app_cfg+0x1b8>
80002800:	c3 c8       	rjmp	80002878 <app_cfg+0xbc>
		{
			case OB_UNCONNECTEDWAITINGSTATUS:
			
				if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
80002802:	68 08       	ld.w	r8,r4[0x0]
80002804:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
80002808:	58 38       	cp.w	r8,3
8000280a:	c2 a1       	brne	8000285e <app_cfg+0xa2>
8000280c:	07 88       	ld.ub	r8,r3[0x0]
8000280e:	58 08       	cp.w	r8,0
80002810:	c2 71       	brne	8000285e <app_cfg+0xa2>
				{
					connect_flag=1;
80002812:	30 18       	mov	r8,1
80002814:	a6 88       	st.b	r3[0x0],r8
					xcmp_IdleTestTone(Tone_Start, Priority_Beep);//set tone to indicate connection success!!!
80002816:	30 cb       	mov	r11,12
80002818:	30 1c       	mov	r12,1
8000281a:	f0 1f 00 64 	mcall	800029a8 <app_cfg+0x1ec>
					xcmp_IdleTestTone(Tone_Start, Priority_Beep);//set tone to indicate connection success!!!
8000281e:	30 cb       	mov	r11,12
80002820:	30 1c       	mov	r12,1
80002822:	f0 1f 00 62 	mcall	800029a8 <app_cfg+0x1ec>
					OB_State = OB_WAITINGAPPTASK;
80002826:	30 38       	mov	r8,3
80002828:	8b 08       	st.w	r5[0x0],r8
					log("connect OB okay!\n");
8000282a:	4e 1c       	lddpc	r12,800029ac <app_cfg+0x1f0>
8000282c:	f0 1f 00 61 	mcall	800029b0 <app_cfg+0x1f4>
					log("XCMP_Version: %d.%d.%d.%d\n", XCMP_Version[0],  XCMP_Version[1],
													 XCMP_Version[2],  XCMP_Version[3]);
80002830:	4e 18       	lddpc	r8,800029b4 <app_cfg+0x1f8>
80002832:	11 bb       	ld.ub	r11,r8[0x3]
80002834:	11 aa       	ld.ub	r10,r8[0x2]
					connect_flag=1;
					xcmp_IdleTestTone(Tone_Start, Priority_Beep);//set tone to indicate connection success!!!
					xcmp_IdleTestTone(Tone_Start, Priority_Beep);//set tone to indicate connection success!!!
					OB_State = OB_WAITINGAPPTASK;
					log("connect OB okay!\n");
					log("XCMP_Version: %d.%d.%d.%d\n", XCMP_Version[0],  XCMP_Version[1],
80002836:	11 99       	ld.ub	r9,r8[0x1]
80002838:	11 88       	ld.ub	r8,r8[0x0]
8000283a:	1a db       	st.w	--sp,r11
8000283c:	1a da       	st.w	--sp,r10
8000283e:	1a d9       	st.w	--sp,r9
80002840:	1a d8       	st.w	--sp,r8
80002842:	4d ec       	lddpc	r12,800029b8 <app_cfg+0x1fc>
80002844:	f0 1f 00 5b 	mcall	800029b0 <app_cfg+0x1f4>
													 XCMP_Version[2],  XCMP_Version[3]);
					log("OB_Firmware_Version: %d.%d.%d\n", OB_Firmware_Version[0],  OB_Firmware_Version[1], OB_Firmware_Version[2]);							 
80002848:	30 18       	mov	r8,1
8000284a:	1a d8       	st.w	--sp,r8
8000284c:	30 08       	mov	r8,0
8000284e:	1a d8       	st.w	--sp,r8
80002850:	30 28       	mov	r8,2
80002852:	1a d8       	st.w	--sp,r8
80002854:	4d ac       	lddpc	r12,800029bc <app_cfg+0x200>
80002856:	f0 1f 00 57 	mcall	800029b0 <app_cfg+0x1f4>
	{
		switch(OB_State)
		{
			case OB_UNCONNECTEDWAITINGSTATUS:
			
				if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
8000285a:	2f 9d       	sub	sp,-28
8000285c:	c8 c8       	rjmp	80002974 <app_cfg+0x1b8>
													 XCMP_Version[2],  XCMP_Version[3]);
					log("OB_Firmware_Version: %d.%d.%d\n", OB_Firmware_Version[0],  OB_Firmware_Version[1], OB_Firmware_Version[2]);							 
				}
				else
				{
					nop();
8000285e:	d7 03       	nop
					nop();
80002860:	d7 03       	nop
					nop();
80002862:	d7 03       	nop
					/*send device_master_query to connect radio*/
					xnl_send_device_master_query();
80002864:	f0 1f 00 57 	mcall	800029c0 <app_cfg+0x204>
					log("connecting...\n");
80002868:	04 9c       	mov	r12,r2
8000286a:	f0 1f 00 52 	mcall	800029b0 <app_cfg+0x1f4>
					vTaskDelayUntil( &xLastWakeTime, (1000*2) / portTICK_RATE_MS  );//精确的以1000ms为周期执行。
8000286e:	0e 9b       	mov	r11,r7
80002870:	0c 9c       	mov	r12,r6
80002872:	f0 1f 00 55 	mcall	800029c4 <app_cfg+0x208>
80002876:	c7 f8       	rjmp	80002974 <app_cfg+0x1b8>
						
					
					//if (xSemaphoreTake(xBinarySemaphore, (1000*2) / portTICK_RATE_MS) == pdPASS)
					{
						
						if(pdPASS == xQueueReceive(xg_resend_queue, &data_ptr, (1000*2) / portTICK_RATE_MS))
80002878:	4d 48       	lddpc	r8,800029c8 <app_cfg+0x20c>
8000287a:	70 0c       	ld.w	r12,r8[0x0]
8000287c:	30 09       	mov	r9,0
8000287e:	0e 9a       	mov	r10,r7
80002880:	fa cb ff b0 	sub	r11,sp,-80
80002884:	f0 1f 00 44 	mcall	80002994 <app_cfg+0x1d8>
80002888:	58 1c       	cp.w	r12,1
8000288a:	c6 61       	brne	80002956 <app_cfg+0x19a>
						{
							if(data_ptr!=NULL){//resend message
8000288c:	41 48       	lddsp	r8,sp[0x50]
8000288e:	58 08       	cp.w	r8,0
80002890:	c6 30       	breq	80002956 <app_cfg+0x19a>
							
								log("receive Okay!\n");	
80002892:	4c fc       	lddpc	r12,800029cc <app_cfg+0x210>
80002894:	f0 1f 00 47 	mcall	800029b0 <app_cfg+0x1f4>
								xSemaphoreTake(count_mutex, portMAX_DELAY);
80002898:	4c e0       	lddpc	r0,800029d0 <app_cfg+0x214>
8000289a:	60 0c       	ld.w	r12,r0[0x0]
8000289c:	30 09       	mov	r9,0
8000289e:	3f fa       	mov	r10,-1
800028a0:	12 9b       	mov	r11,r9
800028a2:	f0 1f 00 3d 	mcall	80002994 <app_cfg+0x1d8>
								global_count--;
800028a6:	4c c1       	lddpc	r1,800029d4 <app_cfg+0x218>
800028a8:	62 08       	ld.w	r8,r1[0x0]
800028aa:	20 18       	sub	r8,1
800028ac:	83 08       	st.w	r1[0x0],r8
								xSemaphoreGive(count_mutex);
800028ae:	60 0c       	ld.w	r12,r0[0x0]
800028b0:	30 09       	mov	r9,0
800028b2:	12 9a       	mov	r10,r9
800028b4:	12 9b       	mov	r11,r9
800028b6:	f0 1f 00 49 	mcall	800029d8 <app_cfg+0x21c>
								log("global_count:%d\n", global_count);	
800028ba:	62 08       	ld.w	r8,r1[0x0]
800028bc:	1a d8       	st.w	--sp,r8
800028be:	4c 8c       	lddpc	r12,800029dc <app_cfg+0x220>
800028c0:	f0 1f 00 3c 	mcall	800029b0 <app_cfg+0x1f4>
																			
								xcmp_data_session_req(data_ptr, sizeof(Message_Protocol_t), DEST);	
800028c4:	36 4a       	mov	r10,100
800028c6:	31 ab       	mov	r11,26
800028c8:	41 5c       	lddsp	r12,sp[0x54]
800028ca:	f0 1f 00 46 	mcall	800029e0 <app_cfg+0x224>
								if(xSemaphoreTake(xBinarySemaphore, (20000*2) / portTICK_RATE_MS) ==pdFALSE)
800028ce:	4b 18       	lddpc	r8,80002990 <app_cfg+0x1d4>
800028d0:	70 0c       	ld.w	r12,r8[0x0]
800028d2:	30 09       	mov	r9,0
800028d4:	e0 6a 9c 40 	mov	r10,40000
800028d8:	12 9b       	mov	r11,r9
800028da:	f0 1f 00 2f 	mcall	80002994 <app_cfg+0x1d8>
800028de:	2f fd       	sub	sp,-4
800028e0:	58 0c       	cp.w	r12,0
800028e2:	c3 21       	brne	80002946 <app_cfg+0x18a>
								{
									
									if (xQueueSend(xg_resend_queue, &data_ptr, 0) != pdPASS)
800028e4:	4b 98       	lddpc	r8,800029c8 <app_cfg+0x20c>
800028e6:	70 0c       	ld.w	r12,r8[0x0]
800028e8:	30 09       	mov	r9,0
800028ea:	12 9a       	mov	r10,r9
800028ec:	fa cb ff b0 	sub	r11,sp,-80
800028f0:	f0 1f 00 3a 	mcall	800029d8 <app_cfg+0x21c>
800028f4:	58 1c       	cp.w	r12,1
800028f6:	c1 10       	breq	80002918 <app_cfg+0x15c>
									{
										log("xg_resend_queue: full\n" );
800028f8:	4b bc       	lddpc	r12,800029e4 <app_cfg+0x228>
800028fa:	f0 1f 00 2e 	mcall	800029b0 <app_cfg+0x1f4>
										xcmp_IdleTestTone(Tone_Start, Dispatch_Busy);//set tone to indicate queue full!!!
800028fe:	32 3b       	mov	r11,35
80002900:	30 1c       	mov	r12,1
80002902:	f0 1f 00 2a 	mcall	800029a8 <app_cfg+0x1ec>
										vTaskDelay(3000*2 / portTICK_RATE_MS);//延迟3000ms
80002906:	e0 6c 17 70 	mov	r12,6000
8000290a:	f0 1f 00 38 	mcall	800029e8 <app_cfg+0x22c>
										xcmp_IdleTestTone(Tone_Stop, Dispatch_Busy);//set tone to indicate queue full!!!
8000290e:	32 3b       	mov	r11,35
80002910:	30 0c       	mov	r12,0
80002912:	f0 1f 00 26 	mcall	800029a8 <app_cfg+0x1ec>
80002916:	c2 08       	rjmp	80002956 <app_cfg+0x19a>
									}
									else{
											
										xSemaphoreTake(count_mutex, portMAX_DELAY);
80002918:	4a e1       	lddpc	r1,800029d0 <app_cfg+0x214>
8000291a:	62 0c       	ld.w	r12,r1[0x0]
8000291c:	30 09       	mov	r9,0
8000291e:	3f fa       	mov	r10,-1
80002920:	12 9b       	mov	r11,r9
80002922:	f0 1f 00 1d 	mcall	80002994 <app_cfg+0x1d8>
										global_count++;
80002926:	4a c8       	lddpc	r8,800029d4 <app_cfg+0x218>
80002928:	70 09       	ld.w	r9,r8[0x0]
8000292a:	2f f9       	sub	r9,-1
8000292c:	91 09       	st.w	r8[0x0],r9
										xSemaphoreGive(count_mutex);
8000292e:	62 0c       	ld.w	r12,r1[0x0]
80002930:	30 09       	mov	r9,0
80002932:	12 9a       	mov	r10,r9
80002934:	12 9b       	mov	r11,r9
80002936:	f0 1f 00 29 	mcall	800029d8 <app_cfg+0x21c>
										xcmp_IdleTestTone(Tone_Start, MANDOWN_DISABLE_TONE);//set tone to indicate send-failure!!!
8000293a:	e0 6b 00 b7 	mov	r11,183
8000293e:	30 1c       	mov	r12,1
80002940:	f0 1f 00 1a 	mcall	800029a8 <app_cfg+0x1ec>
80002944:	c0 98       	rjmp	80002956 <app_cfg+0x19a>
									}
				
								}	
								else
								{
									set_message_store(data_ptr);
80002946:	4a a8       	lddpc	r8,800029ec <app_cfg+0x230>
80002948:	70 0c       	ld.w	r12,r8[0x0]
8000294a:	41 4b       	lddsp	r11,sp[0x50]
8000294c:	f0 1f 00 29 	mcall	800029f0 <app_cfg+0x234>
									log("send message\n");
80002950:	4a 9c       	lddpc	r12,800029f4 <app_cfg+0x238>
80002952:	f0 1f 00 18 	mcall	800029b0 <app_cfg+0x1f4>
							}
						
						}
					}
					
					if (0x00000003 != (bunchofrandomstatusflags & 0x00000003))//掉线
80002956:	68 08       	ld.w	r8,r4[0x0]
80002958:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
8000295c:	58 38       	cp.w	r8,3
8000295e:	c0 70       	breq	8000296c <app_cfg+0x1b0>
					{					
						OB_State = OB_UNCONNECTEDWAITINGSTATUS;
80002960:	30 08       	mov	r8,0
80002962:	8b 08       	st.w	r5[0x0],r8
						connect_flag=0;
80002964:	a6 88       	st.b	r3[0x0],r8
						log("OB disconnecting!!!\n");
80002966:	4a 5c       	lddpc	r12,800029f8 <app_cfg+0x23c>
80002968:	f0 1f 00 12 	mcall	800029b0 <app_cfg+0x1f4>
							//memset(str, 0x00, 80);
						//}
					//}
					
											
					nop();
8000296c:	d7 03       	nop
					log("app task run!\n");
8000296e:	4a 4c       	lddpc	r12,800029fc <app_cfg+0x240>
80002970:	f0 1f 00 10 	mcall	800029b0 <app_cfg+0x1f4>
			break;
			default:
			break;
				
		} //End of switch on OB_State.
		vTaskDelayUntil( &xLastWakeTime, (1000*2) / portTICK_RATE_MS  );//精确的以1000ms为周期执行。
80002974:	0e 9b       	mov	r11,r7
80002976:	0c 9c       	mov	r12,r6
80002978:	f0 1f 00 13 	mcall	800029c4 <app_cfg+0x208>
	}
8000297c:	c3 cb       	rjmp	800027f4 <app_cfg+0x38>
8000297e:	00 00       	add	r0,r0
80002980:	80 00       	ld.sh	r0,r0[0x0]
80002982:	60 d4       	ld.w	r4,r0[0x34]
80002984:	80 00       	ld.sh	r0,r0[0x0]
80002986:	69 8c       	ld.w	r12,r4[0x60]
80002988:	00 00       	add	r0,r0
8000298a:	0a 48       	or	r8,r5
8000298c:	80 00       	ld.sh	r0,r0[0x0]
8000298e:	7a 24       	ld.w	r4,sp[0x8]
80002990:	00 00       	add	r0,r0
80002992:	0b 74       	ld.ub	r4,--r5
80002994:	80 00       	ld.sh	r0,r0[0x0]
80002996:	62 1c       	ld.w	r12,r1[0x4]
80002998:	00 00       	add	r0,r0
8000299a:	0a 50       	eor	r0,r5
8000299c:	00 00       	add	r0,r0
8000299e:	0d 9c       	ld.ub	r12,r6[0x1]
800029a0:	80 00       	ld.sh	r0,r0[0x0]
800029a2:	d6 a4       	*unknown*
800029a4:	00 00       	add	r0,r0
800029a6:	0a 5c       	eor	r12,r5
800029a8:	80 00       	ld.sh	r0,r0[0x0]
800029aa:	41 34       	lddsp	r4,sp[0x4c]
800029ac:	80 00       	ld.sh	r0,r0[0x0]
800029ae:	d6 54       	*unknown*
800029b0:	80 00       	ld.sh	r0,r0[0x0]
800029b2:	70 60       	ld.w	r0,r8[0x18]
800029b4:	00 00       	add	r0,r0
800029b6:	0d 98       	ld.ub	r8,r6[0x1]
800029b8:	80 00       	ld.sh	r0,r0[0x0]
800029ba:	d6 68       	*unknown*
800029bc:	80 00       	ld.sh	r0,r0[0x0]
800029be:	d6 84       	*unknown*
800029c0:	80 00       	ld.sh	r0,r0[0x0]
800029c2:	48 e0       	lddpc	r0,800029f8 <app_cfg+0x23c>
800029c4:	80 00       	ld.sh	r0,r0[0x0]
800029c6:	6b 3c       	ld.w	r12,r5[0x4c]
800029c8:	00 00       	add	r0,r0
800029ca:	0b 6c       	ld.uh	r12,--r5
800029cc:	80 00       	ld.sh	r0,r0[0x0]
800029ce:	d6 b4       	*unknown*
800029d0:	00 00       	add	r0,r0
800029d2:	0a 60       	and	r0,r5
800029d4:	00 00       	add	r0,r0
800029d6:	0a 44       	or	r4,r5
800029d8:	80 00       	ld.sh	r0,r0[0x0]
800029da:	64 28       	ld.w	r8,r2[0x8]
800029dc:	80 00       	ld.sh	r0,r0[0x0]
800029de:	d6 c4       	*unknown*
800029e0:	80 00       	ld.sh	r0,r0[0x0]
800029e2:	3f f0       	mov	r0,-1
800029e4:	80 00       	ld.sh	r0,r0[0x0]
800029e6:	d6 d8       	*unknown*
800029e8:	80 00       	ld.sh	r0,r0[0x0]
800029ea:	6a f4       	ld.w	r4,r5[0x3c]
800029ec:	00 00       	add	r0,r0
800029ee:	0b 70       	ld.ub	r0,--r5
800029f0:	80 00       	ld.sh	r0,r0[0x0]
800029f2:	2c cc       	sub	r12,-52
800029f4:	80 00       	ld.sh	r0,r0[0x0]
800029f6:	d6 f0       	acall	0x6f
800029f8:	80 00       	ld.sh	r0,r0[0x0]
800029fa:	d7 00       	acall	0x70
800029fc:	80 00       	ld.sh	r0,r0[0x0]
800029fe:	d7 18       	*unknown*

80002a00 <Phyuserinput_brdcst_func>:
	
}


void Phyuserinput_brdcst_func(xcmp_fragment_t * xcmp)
{
80002a00:	eb cd 40 80 	pushm	r7,lr
	U8 PUI_State_Min_Value =0;
	U8 PUI_State_Max_Value =0;
	
	PUI_Source = xcmp->u8[0];
	PUI_Type = xcmp ->u8[1];
	PUI_ID = ((xcmp->u8[2]<<8) | xcmp->u8[3]);
80002a04:	19 c7       	ld.ub	r7,r12[0x4]
80002a06:	19 d8       	ld.ub	r8,r12[0x5]
80002a08:	f1 e7 10 87 	or	r7,r8,r7<<0x8
80002a0c:	5c 87       	casts.h	r7
	PUI_State = xcmp->u8[4];
	PUI_State_Min_Value = xcmp->u8[5];
	PUI_State_Max_Value = xcmp->u8[6];
	
	log("PhysicalUserInput_broadcast  \n\r"  );
80002a0e:	48 dc       	lddpc	r12,80002a40 <Phyuserinput_brdcst_func+0x40>
80002a10:	f0 1f 00 0d 	mcall	80002a44 <Phyuserinput_brdcst_func+0x44>
	
	if((PUI_ID == 0x0060) && (PUI_State = 0x02) && (connect_flag == 1)){
80002a14:	36 08       	mov	r8,96
80002a16:	f0 07 19 00 	cp.h	r7,r8
80002a1a:	c1 11       	brne	80002a3c <Phyuserinput_brdcst_func+0x3c>
80002a1c:	48 b8       	lddpc	r8,80002a48 <Phyuserinput_brdcst_func+0x48>
80002a1e:	11 89       	ld.ub	r9,r8[0x0]
80002a20:	30 18       	mov	r8,1
80002a22:	f0 09 18 00 	cp.b	r9,r8
80002a26:	c0 b1       	brne	80002a3c <Phyuserinput_brdcst_func+0x3c>
		//log("send message\n");
		xcmp_IdleTestTone(Tone_Start, Ring_Style_Tone_9);//set tone to indicate the scan!!!
80002a28:	34 5b       	mov	r11,69
80002a2a:	30 1c       	mov	r12,1
80002a2c:	f0 1f 00 08 	mcall	80002a4c <Phyuserinput_brdcst_func+0x4c>
			
		vTaskDelay(1000*2 / portTICK_RATE_MS);//延迟1000ms
80002a30:	e0 6c 07 d0 	mov	r12,2000
80002a34:	f0 1f 00 07 	mcall	80002a50 <Phyuserinput_brdcst_func+0x50>
		//delay_ms(200);
		//rfid_sendID_message();//send message	
		scan_rfid_save_message();//scan and save message	
80002a38:	f0 1f 00 07 	mcall	80002a54 <Phyuserinput_brdcst_func+0x54>
80002a3c:	e3 cd 80 80 	ldm	sp++,r7,pc
80002a40:	80 00       	ld.sh	r0,r0[0x0]
80002a42:	d7 28       	*unknown*
80002a44:	80 00       	ld.sh	r0,r0[0x0]
80002a46:	70 60       	ld.w	r0,r8[0x18]
80002a48:	00 00       	add	r0,r0
80002a4a:	0a 5c       	eor	r12,r5
80002a4c:	80 00       	ld.sh	r0,r0[0x0]
80002a4e:	41 34       	lddsp	r4,sp[0x4c]
80002a50:	80 00       	ld.sh	r0,r0[0x0]
80002a52:	6a f4       	ld.w	r4,r5[0x3c]
80002a54:	80 00       	ld.sh	r0,r0[0x0]
80002a56:	51 98       	stdsp	sp[0x64],r8

80002a58 <DataSession_brdcst_func>:
	Battery_Flag = ptr->State;

}

void DataSession_brdcst_func(xcmp_fragment_t * xcmp)
{
80002a58:	d4 21       	pushm	r4-r7,lr
80002a5a:	20 8d       	sub	sp,32
	U32 card_id =0;
	U8 i = 0;
	xgflash_status_t return_value = XG_ERROR;
	
	/*point to xcmp payload*/
	DataSession_brdcst_t *ptr = (DataSession_brdcst_t* )xcmp->u8;
80002a5c:	f8 c6 ff fe 	sub	r6,r12,-2
	
	if (ptr->State == CSBK_DATA_RX_Suc)
80002a60:	0d 88       	ld.ub	r8,r6[0x0]
80002a62:	32 49       	mov	r9,36
80002a64:	f2 08 18 00 	cp.b	r8,r9
80002a68:	c2 a1       	brne	80002abc <DataSession_brdcst_func+0x64>
	{
		
		log("\n\r CSBK_RX OK \n\r");
80002a6a:	4c ac       	lddpc	r12,80002b90 <DataSession_brdcst_func+0x138>
80002a6c:	f0 1f 00 4a 	mcall	80002b94 <DataSession_brdcst_func+0x13c>
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
80002a70:	0d a5       	ld.ub	r5,r6[0x2]
80002a72:	0d b8       	ld.ub	r8,r6[0x3]
80002a74:	f1 e5 10 85 	or	r5,r8,r5<<0x8
80002a78:	5c 85       	casts.h	r5

		log("\n\r Session_ID: %x \n\r",Session_number );
80002a7a:	0d 98       	ld.ub	r8,r6[0x1]
80002a7c:	1a d8       	st.w	--sp,r8
80002a7e:	4c 7c       	lddpc	r12,80002b98 <DataSession_brdcst_func+0x140>
80002a80:	f0 1f 00 45 	mcall	80002b94 <DataSession_brdcst_func+0x13c>
		log("\n\r paylaod_length: %d \n\r",data_length );
80002a84:	f1 d5 c0 10 	bfextu	r8,r5,0x0,0x10
80002a88:	1a d8       	st.w	--sp,r8
80002a8a:	4c 5c       	lddpc	r12,80002b9c <DataSession_brdcst_func+0x144>
80002a8c:	f0 1f 00 42 	mcall	80002b94 <DataSession_brdcst_func+0x13c>
		for(i=0; i<data_length; i++)
80002a90:	2f ed       	sub	sp,-8
80002a92:	58 05       	cp.w	r5,0
80002a94:	e0 80 00 7b 	breq	80002b8a <DataSession_brdcst_func+0x132>
80002a98:	30 07       	mov	r7,0
		{
			
			//log("\n\r payload[%d]: %X \n\r", i, xcmp->u8[4+i]);
			log("\n\r payload[%d]: %X \n\r", i, ptr->DataPayload.DataPayload[i]);
80002a9a:	4c 24       	lddpc	r4,80002ba0 <DataSession_brdcst_func+0x148>
80002a9c:	ec 07 00 08 	add	r8,r6,r7
80002aa0:	11 c8       	ld.ub	r8,r8[0x4]
80002aa2:	1a d8       	st.w	--sp,r8
80002aa4:	1a d7       	st.w	--sp,r7
80002aa6:	08 9c       	mov	r12,r4
80002aa8:	f0 1f 00 3b 	mcall	80002b94 <DataSession_brdcst_func+0x13c>
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);

		log("\n\r Session_ID: %x \n\r",Session_number );
		log("\n\r paylaod_length: %d \n\r",data_length );
		for(i=0; i<data_length; i++)
80002aac:	2f f7       	sub	r7,-1
80002aae:	5c 57       	castu.b	r7
80002ab0:	2f ed       	sub	sp,-8
80002ab2:	ee 05 19 00 	cp.h	r5,r7
80002ab6:	fe 9b ff f3 	brhi	80002a9c <DataSession_brdcst_func+0x44>
80002aba:	c6 88       	rjmp	80002b8a <DataSession_brdcst_func+0x132>
	else
	{
		//log("\n\r State: 0x %X \n\r", xcmp->u8[0]);
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];				
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
		log("State: %X \n", ptr->State);
80002abc:	1a d8       	st.w	--sp,r8
80002abe:	4b ac       	lddpc	r12,80002ba4 <DataSession_brdcst_func+0x14c>
80002ac0:	f0 1f 00 35 	mcall	80002b94 <DataSession_brdcst_func+0x13c>
		if (ptr->State == DATA_SESSION_TX_Suc)
80002ac4:	0d 88       	ld.ub	r8,r6[0x0]
80002ac6:	2f fd       	sub	sp,-4
80002ac8:	30 39       	mov	r9,3
80002aca:	f2 08 18 00 	cp.b	r8,r9
80002ace:	c0 d1       	brne	80002ae8 <DataSession_brdcst_func+0x90>
		{
			log("data transmit success\n");
80002ad0:	4b 6c       	lddpc	r12,80002ba8 <DataSession_brdcst_func+0x150>
80002ad2:	f0 1f 00 31 	mcall	80002b94 <DataSession_brdcst_func+0x13c>
			vTaskDelay(1000*2 / portTICK_RATE_MS);//延迟1000ms
80002ad6:	e0 6c 07 d0 	mov	r12,2000
80002ada:	f0 1f 00 35 	mcall	80002bac <DataSession_brdcst_func+0x154>
			xcmp_IdleTestTone(Tone_Start, BT_Connection_Success_Tone);//set tone to indicate connection success!!!
80002ade:	37 7b       	mov	r11,119
80002ae0:	30 1c       	mov	r12,1
80002ae2:	f0 1f 00 34 	mcall	80002bb0 <DataSession_brdcst_func+0x158>
80002ae6:	c4 b8       	rjmp	80002b7c <DataSession_brdcst_func+0x124>
		}
		else if(ptr->State == DATA_SESSION_TX_Fail)
80002ae8:	30 49       	mov	r9,4
80002aea:	f2 08 18 00 	cp.b	r8,r9
80002aee:	c4 71       	brne	80002b7c <DataSession_brdcst_func+0x124>
		{
			Message_Protocol_t  xgmessage;
			memcpy(&xgmessage, ptr->DataPayload.DataPayload, sizeof(Message_Protocol_t));
80002af0:	31 aa       	mov	r10,26
80002af2:	ec cb ff fc 	sub	r11,r6,-4
80002af6:	fa cc ff fe 	sub	r12,sp,-2
80002afa:	f0 1f 00 2f 	mcall	80002bb4 <DataSession_brdcst_func+0x15c>

			Message_Protocol_t * myptr = get_message_store();	
80002afe:	4a f8       	lddpc	r8,80002bb8 <DataSession_brdcst_func+0x160>
80002b00:	70 0c       	ld.w	r12,r8[0x0]
80002b02:	f0 1f 00 2f 	mcall	80002bbc <DataSession_brdcst_func+0x164>
80002b06:	50 7c       	stdsp	sp[0x1c],r12
			if(NULL != myptr)
80002b08:	c3 20       	breq	80002b6c <DataSession_brdcst_func+0x114>
			{
				memcpy(myptr, &xgmessage, sizeof(Message_Protocol_t));			
80002b0a:	31 aa       	mov	r10,26
80002b0c:	fa cb ff fe 	sub	r11,sp,-2
80002b10:	f0 1f 00 29 	mcall	80002bb4 <DataSession_brdcst_func+0x15c>
				//xQueueSend(xg_resend_queue, &myptr, 0);			
				if (xQueueSend(xg_resend_queue, &myptr, 0) != pdPASS)
80002b14:	4a b8       	lddpc	r8,80002bc0 <DataSession_brdcst_func+0x168>
80002b16:	70 0c       	ld.w	r12,r8[0x0]
80002b18:	30 09       	mov	r9,0
80002b1a:	12 9a       	mov	r10,r9
80002b1c:	fa cb ff e4 	sub	r11,sp,-28
80002b20:	f0 1f 00 29 	mcall	80002bc4 <DataSession_brdcst_func+0x16c>
80002b24:	58 1c       	cp.w	r12,1
80002b26:	c1 10       	breq	80002b48 <DataSession_brdcst_func+0xf0>
				{
					log("xg_resend_queue: full\n" );
80002b28:	4a 8c       	lddpc	r12,80002bc8 <DataSession_brdcst_func+0x170>
80002b2a:	f0 1f 00 1b 	mcall	80002b94 <DataSession_brdcst_func+0x13c>
					xcmp_IdleTestTone(Tone_Start, Dispatch_Busy);//set tone to indicate queue full!!!
80002b2e:	32 3b       	mov	r11,35
80002b30:	30 1c       	mov	r12,1
80002b32:	f0 1f 00 20 	mcall	80002bb0 <DataSession_brdcst_func+0x158>
					vTaskDelay(3000*2 / portTICK_RATE_MS);//延迟3000ms
80002b36:	e0 6c 17 70 	mov	r12,6000
80002b3a:	f0 1f 00 1d 	mcall	80002bac <DataSession_brdcst_func+0x154>
					xcmp_IdleTestTone(Tone_Stop, Dispatch_Busy);//set tone to indicate queue full!!!
80002b3e:	32 3b       	mov	r11,35
80002b40:	30 0c       	mov	r12,0
80002b42:	f0 1f 00 1c 	mcall	80002bb0 <DataSession_brdcst_func+0x158>
80002b46:	c1 68       	rjmp	80002b72 <DataSession_brdcst_func+0x11a>
				}
				else{
					
					xSemaphoreTake(count_mutex, portMAX_DELAY);
80002b48:	4a 17       	lddpc	r7,80002bcc <DataSession_brdcst_func+0x174>
80002b4a:	6e 0c       	ld.w	r12,r7[0x0]
80002b4c:	30 09       	mov	r9,0
80002b4e:	3f fa       	mov	r10,-1
80002b50:	12 9b       	mov	r11,r9
80002b52:	f0 1f 00 20 	mcall	80002bd0 <DataSession_brdcst_func+0x178>
					global_count++;
80002b56:	4a 08       	lddpc	r8,80002bd4 <DataSession_brdcst_func+0x17c>
80002b58:	70 09       	ld.w	r9,r8[0x0]
80002b5a:	2f f9       	sub	r9,-1
80002b5c:	91 09       	st.w	r8[0x0],r9
					xSemaphoreGive(count_mutex);
80002b5e:	6e 0c       	ld.w	r12,r7[0x0]
80002b60:	30 09       	mov	r9,0
80002b62:	12 9a       	mov	r10,r9
80002b64:	12 9b       	mov	r11,r9
80002b66:	f0 1f 00 18 	mcall	80002bc4 <DataSession_brdcst_func+0x16c>
80002b6a:	c0 48       	rjmp	80002b72 <DataSession_brdcst_func+0x11a>
				}
			}
			else
			{
				log("myptr: err\n\r" );
80002b6c:	49 bc       	lddpc	r12,80002bd8 <DataSession_brdcst_func+0x180>
80002b6e:	f0 1f 00 0a 	mcall	80002b94 <DataSession_brdcst_func+0x13c>
			}
			xcmp_IdleTestTone(Tone_Start, MANDOWN_DISABLE_TONE);//set tone to indicate send-failure!!!
80002b72:	e0 6b 00 b7 	mov	r11,183
80002b76:	30 1c       	mov	r12,1
80002b78:	f0 1f 00 0e 	mcall	80002bb0 <DataSession_brdcst_func+0x158>
		}
		
		/* 'Give' the semaphore to unblock the task. */
		xSemaphoreGive(xBinarySemaphore);
80002b7c:	49 88       	lddpc	r8,80002bdc <DataSession_brdcst_func+0x184>
80002b7e:	70 0c       	ld.w	r12,r8[0x0]
80002b80:	30 09       	mov	r9,0
80002b82:	12 9a       	mov	r10,r9
80002b84:	12 9b       	mov	r11,r9
80002b86:	f0 1f 00 10 	mcall	80002bc4 <DataSession_brdcst_func+0x16c>
				//
		//}
		
	}
	
}
80002b8a:	2f 8d       	sub	sp,-32
80002b8c:	d8 22       	popm	r4-r7,pc
80002b8e:	00 00       	add	r0,r0
80002b90:	80 00       	ld.sh	r0,r0[0x0]
80002b92:	d7 48       	*unknown*
80002b94:	80 00       	ld.sh	r0,r0[0x0]
80002b96:	70 60       	ld.w	r0,r8[0x18]
80002b98:	80 00       	ld.sh	r0,r0[0x0]
80002b9a:	d7 5c       	*unknown*
80002b9c:	80 00       	ld.sh	r0,r0[0x0]
80002b9e:	d7 74       	*unknown*
80002ba0:	80 00       	ld.sh	r0,r0[0x0]
80002ba2:	d7 90       	acall	0x79
80002ba4:	80 00       	ld.sh	r0,r0[0x0]
80002ba6:	d7 a8       	*unknown*
80002ba8:	80 00       	ld.sh	r0,r0[0x0]
80002baa:	d7 b4       	*unknown*
80002bac:	80 00       	ld.sh	r0,r0[0x0]
80002bae:	6a f4       	ld.w	r4,r5[0x3c]
80002bb0:	80 00       	ld.sh	r0,r0[0x0]
80002bb2:	41 34       	lddsp	r4,sp[0x4c]
80002bb4:	80 00       	ld.sh	r0,r0[0x0]
80002bb6:	78 dc       	ld.w	r12,r12[0x34]
80002bb8:	00 00       	add	r0,r0
80002bba:	0b 70       	ld.ub	r0,--r5
80002bbc:	80 00       	ld.sh	r0,r0[0x0]
80002bbe:	2e 78       	sub	r8,-25
80002bc0:	00 00       	add	r0,r0
80002bc2:	0b 6c       	ld.uh	r12,--r5
80002bc4:	80 00       	ld.sh	r0,r0[0x0]
80002bc6:	64 28       	ld.w	r8,r2[0x8]
80002bc8:	80 00       	ld.sh	r0,r0[0x0]
80002bca:	d6 d8       	*unknown*
80002bcc:	00 00       	add	r0,r0
80002bce:	0a 60       	and	r0,r5
80002bd0:	80 00       	ld.sh	r0,r0[0x0]
80002bd2:	62 1c       	ld.w	r12,r1[0x4]
80002bd4:	00 00       	add	r0,r0
80002bd6:	0a 44       	or	r4,r5
80002bd8:	80 00       	ld.sh	r0,r0[0x0]
80002bda:	d7 cc       	*unknown*
80002bdc:	00 00       	add	r0,r0
80002bde:	0b 74       	ld.ub	r4,--r5

80002be0 <DeviceInitializationStatus_brdcst_func>:
//xnl_content_master_status_brdcst_t XCMP_Version;

//app func--list

void DeviceInitializationStatus_brdcst_func(xcmp_fragment_t  * xcmp)
{
80002be0:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	DeviceInitializationStatus_brdcst_t *ptr = (DeviceInitializationStatus_brdcst_t* )xcmp->u8;
80002be4:	f8 c7 ff fe 	sub	r7,r12,-2
	
	//log("DeviceInitializationStatus_brdcst...\n");
	
	memcpy(XCMP_Version, &(ptr->XCMPVersion[0]), sizeof(XCMP_Version));
80002be8:	30 4a       	mov	r10,4
80002bea:	0e 9b       	mov	r11,r7
80002bec:	48 dc       	lddpc	r12,80002c20 <DeviceInitializationStatus_brdcst_func+0x40>
80002bee:	f0 1f 00 0e 	mcall	80002c24 <DeviceInitializationStatus_brdcst_func+0x44>
	
	if (ptr->DeviceInitType == Device_Init_Complete)
80002bf2:	0f c8       	ld.ub	r8,r7[0x4]
80002bf4:	30 19       	mov	r9,1
80002bf6:	f2 08 18 00 	cp.b	r8,r9
80002bfa:	c0 71       	brne	80002c08 <DeviceInitializationStatus_brdcst_func+0x28>
	{
		bunchofrandomstatusflags |= 0x01;  //Need do nothing else.
80002bfc:	48 b8       	lddpc	r8,80002c28 <DeviceInitializationStatus_brdcst_func+0x48>
80002bfe:	70 09       	ld.w	r9,r8[0x0]
80002c00:	a1 a9       	sbr	r9,0x0
80002c02:	91 09       	st.w	r8[0x0],r9
80002c04:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else if(ptr->DeviceInitType  == Device_Init_Status)
80002c08:	58 08       	cp.w	r8,0
80002c0a:	c0 81       	brne	80002c1a <DeviceInitializationStatus_brdcst_func+0x3a>
	{
		bunchofrandomstatusflags  &= 0xFFFFFFFC; //Device Init no longer Complete.
80002c0c:	48 78       	lddpc	r8,80002c28 <DeviceInitializationStatus_brdcst_func+0x48>
80002c0e:	70 09       	ld.w	r9,r8[0x0]
80002c10:	e0 19 ff fc 	andl	r9,0xfffc
80002c14:	91 09       	st.w	r8[0x0],r9
		xcmp_DeviceInitializationStatus_request();
80002c16:	f0 1f 00 06 	mcall	80002c2c <DeviceInitializationStatus_brdcst_func+0x4c>
80002c1a:	e3 cd 80 80 	ldm	sp++,r7,pc
80002c1e:	00 00       	add	r0,r0
80002c20:	00 00       	add	r0,r0
80002c22:	0d 98       	ld.ub	r8,r6[0x1]
80002c24:	80 00       	ld.sh	r0,r0[0x0]
80002c26:	78 dc       	ld.w	r12,r12[0x34]
80002c28:	00 00       	add	r0,r0
80002c2a:	0d 9c       	ld.ub	r12,r6[0x1]
80002c2c:	80 00       	ld.sh	r0,r0[0x0]
80002c2e:	40 80       	lddsp	r0,sp[0x20]

80002c30 <CalculateBurst>:
Calls:
Called By: phy_payload_rx
*/

volatile RxAMBEBurstType CalculateBurst(U8 vf_sn)
{
80002c30:	20 1c       	sub	r12,1
80002c32:	5c 5c       	castu.b	r12
80002c34:	31 18       	mov	r8,17
80002c36:	f0 0c 18 00 	cp.b	r12,r8
80002c3a:	e0 88 00 03 	brls	80002c40 <CalculateBurst+0x10>
80002c3e:	5e fd       	retal	0
80002c40:	48 28       	lddpc	r8,80002c48 <CalculateBurst+0x18>
80002c42:	f0 0c 03 2c 	ld.w	r12,r8[r12<<0x2]
			Burst_ID = 0x00;
			return VOICE_WATING;
		
	}
	
}
80002c46:	5e fc       	retal	r12
80002c48:	80 00       	ld.sh	r0,r0[0x0]
80002c4a:	d7 dc       	*unknown*

80002c4c <payload_init>:
Calls: xTaskCreate--freertos
Called By:app_init -- app.c
*/
void payload_init(void ( *payload_rx_func)(void * ), void ( *payload_tx_func)(void * ) )
{				
	payload_rx_exec = payload_rx_func;
80002c4c:	48 38       	lddpc	r8,80002c58 <payload_init+0xc>
80002c4e:	91 0c       	st.w	r8[0x0],r12
	payload_tx_exec = payload_tx_func;
80002c50:	48 38       	lddpc	r8,80002c5c <payload_init+0x10>
80002c52:	91 0b       	st.w	r8[0x0],r11
	//,  2
	//,  NULL
	//);
	//
	
}
80002c54:	5e fc       	retal	r12
80002c56:	00 00       	add	r0,r0
80002c58:	00 00       	add	r0,r0
80002c5a:	0a 6c       	and	r12,r5
80002c5c:	00 00       	add	r0,r0
80002c5e:	0a 70       	tst	r0,r5

80002c60 <set_idle_store_isr>:
{
	xQueueSend(store, &ptr, 0);
}

void set_idle_store_isr(xQueueHandle store, void * ptr)
{
80002c60:	d4 01       	pushm	lr
80002c62:	20 2d       	sub	sp,8
80002c64:	50 0b       	stdsp	sp[0x0],r11
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002c66:	30 09       	mov	r9,0
80002c68:	fa ca ff f8 	sub	r10,sp,-8
80002c6c:	14 d9       	st.w	--r10,r9
	xQueueSendFromISR(store, &ptr, &xHigherPriorityTaskWoken);
80002c6e:	1a 9b       	mov	r11,sp
80002c70:	f0 1f 00 02 	mcall	80002c78 <set_idle_store_isr+0x18>
}
80002c74:	2f ed       	sub	sp,-8
80002c76:	d8 02       	popm	pc
80002c78:	80 00       	ld.sh	r0,r0[0x0]
80002c7a:	63 d8       	ld.w	r8,r1[0x74]

80002c7c <payload_rx>:
		//logFromISR("ss");
	}
}

static void payload_rx(void * payload)
{
80002c7c:	d4 01       	pushm	lr
    set_payload_idle_isr(payload);
80002c7e:	48 48       	lddpc	r8,80002c8c <payload_rx+0x10>
80002c80:	70 08       	ld.w	r8,r8[0x0]
80002c82:	18 9b       	mov	r11,r12
80002c84:	10 9c       	mov	r12,r8
80002c86:	f0 1f 00 03 	mcall	80002c90 <payload_rx+0x14>
	else
	{
		//logFromISR("ss");
	}
	#endif
}
80002c8a:	d8 02       	popm	pc
80002c8c:	00 00       	add	r0,r0
80002c8e:	0a a8       	st.w	r5++,r8
80002c90:	80 00       	ld.sh	r0,r0[0x0]
80002c92:	2c 60       	sub	r0,-58

80002c94 <phy_rx>:
	xQueueSendFromISR -- freertos
Called By: phy_xnl_rx
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
80002c94:	d4 01       	pushm	lr
80002c96:	20 2d       	sub	sp,8
80002c98:	50 0c       	stdsp	sp[0x0],r12
	//memcpy(xx, phy_ptr, sizeof(phy_fragment_t));
	//set_phy_idle_isr(&phy_ptr, &xHigherPriorityTaskWoken);
	
	Bool res = FALSE;
	
	if(NULL == phy_ptr)
80002c9a:	58 0c       	cp.w	r12,0
80002c9c:	c1 10       	breq	80002cbe <phy_rx+0x2a>
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
    /*variables are used to store the push result in interrupt*/
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002c9e:	30 08       	mov	r8,0
80002ca0:	50 18       	stdsp	sp[0x4],r8
	if(NULL == phy_ptr)
	{
		return;
	}
	
    U16 phy_ctrl = phy_ptr->xnl_fragment.phy_header.phy_control;
80002ca2:	98 88       	ld.uh	r8,r12[0x0]
80002ca4:	e2 18 f0 00 	andl	r8,0xf000,COH
80002ca8:	e0 48 40 00 	cp.w	r8,16384
80002cac:	c0 91       	brne	80002cbe <phy_rx+0x2a>

    if (XCMPXNL_DATA == (phy_ctrl & 0xF000))
    {
        /*push the xnl packet to queue*/
        if( pdTRUE == xQueueSendFromISR(
80002cae:	48 68       	lddpc	r8,80002cc4 <phy_rx+0x30>
80002cb0:	70 0c       	ld.w	r12,r8[0x0]
80002cb2:	30 09       	mov	r9,0
80002cb4:	fa ca ff fc 	sub	r10,sp,-4
80002cb8:	1a 9b       	mov	r11,sp
80002cba:	f0 1f 00 04 	mcall	80002cc8 <phy_rx+0x34>
		}	

    }
		
 
}
80002cbe:	2f ed       	sub	sp,-8
80002cc0:	d8 02       	popm	pc
80002cc2:	00 00       	add	r0,r0
80002cc4:	00 00       	add	r0,r0
80002cc6:	0a b4       	st.h	r5++,r4
80002cc8:	80 00       	ld.sh	r0,r0[0x0]
80002cca:	63 d8       	ld.w	r8,r1[0x74]

80002ccc <set_idle_store>:
	}
}


void set_idle_store(xQueueHandle store, void * ptr)
{
80002ccc:	eb cd 40 80 	pushm	r7,lr
80002cd0:	20 1d       	sub	sp,4
80002cd2:	fa c7 ff fc 	sub	r7,sp,-4
80002cd6:	0e db       	st.w	--r7,r11
	xQueueSend(store, &ptr, 0);
80002cd8:	30 09       	mov	r9,0
80002cda:	12 9a       	mov	r10,r9
80002cdc:	1a 9b       	mov	r11,sp
80002cde:	f0 1f 00 03 	mcall	80002ce8 <set_idle_store+0x1c>
}
80002ce2:	2f fd       	sub	sp,-4
80002ce4:	e3 cd 80 80 	ldm	sp++,r7,pc
80002ce8:	80 00       	ld.sh	r0,r0[0x0]
80002cea:	64 28       	ld.w	r8,r2[0x8]

80002cec <phy_tx>:
Calls:   
	xQueueSend -- freertos
Called By: xnl_tx -- xnl.c
*/
void phy_tx(phy_fragment_t * phy)
{	
80002cec:	d4 01       	pushm	lr
80002cee:	20 1d       	sub	sp,4
80002cf0:	50 0c       	stdsp	sp[0x0],r12
	
	//phy_fragment_t * phy_ptr = malloc(sizeof(phy_fragment_t));
	//memcpy(phy_ptr, phy, sizeof(phy_fragment_t));
	//log("\n\r T_xcmp:%4x \n\r", phy->xnl_fragment.xnl_payload.xnl_content_data_msg.xcmp_opcode);
	//log("T_xnl-opcode:%4x", xnl->xnl_header.opcode);//log:R_xnl指令	
	if(XCMPXNL_DATA == (phy_ctrl & 0xF000))
80002cf2:	98 88       	ld.uh	r8,r12[0x0]
80002cf4:	e2 18 f0 00 	andl	r8,0xf000,COH
80002cf8:	e0 48 40 00 	cp.w	r8,16384
80002cfc:	c0 d1       	brne	80002d16 <phy_tx+0x2a>
	{
		/*push the xnl packet to queue to send */
		if(NULL != phy_xnl_frame_tx)
80002cfe:	49 08       	lddpc	r8,80002d3c <phy_tx+0x50>
80002d00:	70 08       	ld.w	r8,r8[0x0]
80002d02:	58 08       	cp.w	r8,0
80002d04:	c1 a0       	breq	80002d38 <phy_tx+0x4c>
		{
			if( pdTRUE == xQueueSend(phy_xnl_frame_tx, &phy, 0))
80002d06:	48 e8       	lddpc	r8,80002d3c <phy_tx+0x50>
80002d08:	70 0c       	ld.w	r12,r8[0x0]
80002d0a:	30 09       	mov	r9,0
80002d0c:	12 9a       	mov	r10,r9
80002d0e:	1a 9b       	mov	r11,sp
80002d10:	f0 1f 00 0c 	mcall	80002d40 <phy_tx+0x54>
80002d14:	c1 28       	rjmp	80002d38 <phy_tx+0x4c>
		}
	}
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE		
	else if((SPEAKER_DATA == (phy_ctrl & 0xF000))
80002d16:	e0 48 10 00 	cp.w	r8,4096
80002d1a:	5f 0a       	sreq	r10
80002d1c:	e0 48 20 00 	cp.w	r8,8192
80002d20:	5f 09       	sreq	r9
80002d22:	f5 e9 10 09 	or	r9,r10,r9
80002d26:	c0 71       	brne	80002d34 <phy_tx+0x48>
80002d28:	e0 48 50 00 	cp.w	r8,20480
80002d2c:	c0 40       	breq	80002d34 <phy_tx+0x48>
80002d2e:	e0 48 60 00 	cp.w	r8,24576
80002d32:	c0 31       	brne	80002d38 <phy_tx+0x4c>
	    || (MIC_DATA  == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_RX == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_TX == (phy_ctrl & 0xF000))
	)
	{		
		if(NULL == phy_payload_frame_tx)
80002d34:	48 48       	lddpc	r8,80002d44 <phy_tx+0x58>
80002d36:	70 08       	ld.w	r8,r8[0x0]
	
	if(res != TRUE)
	{
		//vPortFree(phy_ptr);
	}
}
80002d38:	2f fd       	sub	sp,-4
80002d3a:	d8 02       	popm	pc
80002d3c:	00 00       	add	r0,r0
80002d3e:	0a d4       	st.w	--r5,r4
80002d40:	80 00       	ld.sh	r0,r0[0x0]
80002d42:	64 28       	ld.w	r8,r2[0x8]
80002d44:	00 00       	add	r0,r0
80002d46:	0a c8       	st.b	r5++,r8

80002d48 <get_idle_store_isr>:
		return NULL;
	}
}

void * get_idle_store_isr(xQueueHandle store)
{
80002d48:	d4 01       	pushm	lr
80002d4a:	20 2d       	sub	sp,8
	void * ptr = NULL;
80002d4c:	30 08       	mov	r8,0
80002d4e:	50 18       	stdsp	sp[0x4],r8
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002d50:	50 08       	stdsp	sp[0x0],r8
	
	if(pdTRUE == xQueueReceiveFromISR(store, &ptr, &xHigherPriorityTaskWoken))
80002d52:	1a 9a       	mov	r10,sp
80002d54:	fa cb ff fc 	sub	r11,sp,-4
80002d58:	f0 1f 00 05 	mcall	80002d6c <get_idle_store_isr+0x24>
80002d5c:	58 1c       	cp.w	r12,1
80002d5e:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80002d62:	fb fc 00 01 	ld.weq	r12,sp[0x4]
	}
	else
	{
		return NULL;
	}
}
80002d66:	2f ed       	sub	sp,-8
80002d68:	d8 02       	popm	pc
80002d6a:	00 00       	add	r0,r0
80002d6c:	80 00       	ld.sh	r0,r0[0x0]
80002d6e:	61 2c       	ld.w	r12,r0[0x48]

80002d70 <phy_tx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_tx_func( void * ssc)
{
80002d70:	eb cd 40 c0 	pushm	r6-r7,lr
80002d74:	20 1d       	sub	sp,4
80002d76:	18 97       	mov	r7,r12
    if(NULL != phy_xnl_frame_tx)
80002d78:	4b a8       	lddpc	r8,80002e60 <phy_tx_func+0xf0>
80002d7a:	70 08       	ld.w	r8,r8[0x0]
80002d7c:	58 08       	cp.w	r8,0
80002d7e:	c6 60       	breq	80002e4a <phy_tx_func+0xda>
    {
  	  	/*send ssc data in xnl frame*/
  	  	phy_xnl_tx(&(((ssc_fragment_t * )ssc)->xnl_channel));		
80002d80:	18 96       	mov	r6,r12
Called By:phy_tx_func
*/
static void phy_xnl_tx(xnl_channel_t * xnl_tx_channel)
{
	/*variables are used to store the push result in interrupt*/
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002d82:	30 08       	mov	r8,0
80002d84:	50 08       	stdsp	sp[0x0],r8
	
	static S16 phy_tx_expexted_length = 0;
	static U8 phy_tx_index = 0;
	
	/*his is the code for handling any outgoing XNL Phy message*/
	switch(phy_tx_state)
80002d86:	4b 88       	lddpc	r8,80002e64 <phy_tx_func+0xf4>
80002d88:	70 08       	ld.w	r8,r8[0x0]
80002d8a:	58 18       	cp.w	r8,1
80002d8c:	c2 60       	breq	80002dd8 <phy_tx_func+0x68>
80002d8e:	c0 43       	brcs	80002d96 <phy_tx_func+0x26>
80002d90:	58 28       	cp.w	r8,2
80002d92:	c5 c1       	brne	80002e4a <phy_tx_func+0xda>
80002d94:	c5 58       	rjmp	80002e3e <phy_tx_func+0xce>
	{
		/*Waiting for the send xnl packet*/
		case WAITING_FOR_PHY_TX:			
			if( pdTRUE == xQueueReceiveFromISR(
80002d96:	4b 38       	lddpc	r8,80002e60 <phy_tx_func+0xf0>
80002d98:	70 0c       	ld.w	r12,r8[0x0]
80002d9a:	1a 9a       	mov	r10,sp
80002d9c:	4b 3b       	lddpc	r11,80002e68 <phy_tx_func+0xf8>
80002d9e:	f0 1f 00 34 	mcall	80002e6c <phy_tx_func+0xfc>
80002da2:	58 1c       	cp.w	r12,1
80002da4:	c1 41       	brne	80002dcc <phy_tx_func+0x5c>
				  phy_xnl_frame_tx
				, &phy_ptr
				, &xHigherPriorityTaskWoken 
			))
			{								
				phy_tx_expexted_length = 
80002da6:	4b 18       	lddpc	r8,80002e68 <phy_tx_func+0xf8>
80002da8:	70 08       	ld.w	r8,r8[0x0]
80002daa:	90 08       	ld.sh	r8,r8[0x0]
80002dac:	10 9a       	mov	r10,r8
80002dae:	f5 da c0 08 	bfextu	r10,r10,0x0,0x8
80002db2:	4b 09       	lddpc	r9,80002e70 <phy_tx_func+0x100>
80002db4:	b2 0a       	st.h	r9[0x0],r10
				*/
				xnl_tx_channel->dword = 
				                   phy_ptr->xnl_fragment.phy_header.phy_control;
				
				/*Transmit 0xABCD0000 | Type/Length.*/
				xnl_tx_channel->dword |= PHYHEADER32;
80002db6:	5c 78       	castu.h	r8
80002db8:	ea 18 ab cd 	orh	r8,0xabcd
80002dbc:	8f 18       	st.w	r7[0x4],r8
				
				phy_tx_index = 1;
80002dbe:	30 19       	mov	r9,1
80002dc0:	4a d8       	lddpc	r8,80002e74 <phy_tx_func+0x104>
80002dc2:	b0 89       	st.b	r8[0x0],r9
				phy_tx_state = WRITE_NEXT_DWORD;	
80002dc4:	30 19       	mov	r9,1
80002dc6:	4a 88       	lddpc	r8,80002e64 <phy_tx_func+0xf4>
80002dc8:	91 09       	st.w	r8[0x0],r9
80002dca:	c4 08       	rjmp	80002e4a <phy_tx_func+0xda>
				/*The new transmission has started.*/
			}
			else
			{
				/*Nothing new to transmit, send an idle frame*/
				xnl_tx_channel->dword = XNL_IDLE;
80002dcc:	e0 68 5a 5a 	mov	r8,23130
80002dd0:	ea 18 ab cd 	orh	r8,0xabcd
80002dd4:	8f 18       	st.w	r7[0x4],r8
80002dd6:	c3 a8       	rjmp	80002e4a <phy_tx_func+0xda>
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80002dd8:	4a 7a       	lddpc	r10,80002e74 <phy_tx_func+0x104>
80002dda:	15 88       	ld.ub	r8,r10[0x0]
				xnl_tx_channel->dword = XNL_IDLE;
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
80002ddc:	4a 39       	lddpc	r9,80002e68 <phy_tx_func+0xf8>
80002dde:	72 09       	ld.w	r9,r9[0x0]
80002de0:	f2 08 05 19 	ld.uh	r9,r9[r8<<0x1]
80002de4:	b1 69       	lsl	r9,0x10
80002de6:	99 19       	st.w	r12[0x4],r9
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80002de8:	2f f8       	sub	r8,-1
80002dea:	5c 58       	castu.b	r8
80002dec:	b4 88       	st.b	r10[0x0],r8

			phy_tx_expexted_length -= 2;
80002dee:	4a 1b       	lddpc	r11,80002e70 <phy_tx_func+0x100>
80002df0:	96 0c       	ld.sh	r12,r11[0x0]
80002df2:	20 2c       	sub	r12,2
80002df4:	5c 8c       	casts.h	r12
80002df6:	f5 dc b0 10 	bfexts	r10,r12,0x0,0x10
80002dfa:	b6 0a       	st.h	r11[0x0],r10
			
			/*have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80002dfc:	30 0b       	mov	r11,0
80002dfe:	f6 0a 19 00 	cp.h	r10,r11
80002e02:	e0 89 00 09 	brgt	80002e14 <phy_tx_func+0xa4>
			{
				/*Must immediately send 0x00BA in Slot 4.*/
				xnl_tx_channel->dword |= PHYTERMRIGHT;
80002e06:	e8 19 00 ba 	orl	r9,0xba
80002e0a:	8f 19       	st.w	r7[0x4],r9
				
				/*Go back to waiting.*/
				phy_tx_state = WAITING_FOR_PHY_TX;
80002e0c:	30 09       	mov	r9,0
80002e0e:	49 68       	lddpc	r8,80002e64 <phy_tx_func+0xf4>
80002e10:	91 09       	st.w	r8[0x0],r9
80002e12:	c1 c8       	rjmp	80002e4a <phy_tx_func+0xda>
				break;
			}

			/*Have not broken. Transmit 2nd hWord.*/
			xnl_tx_channel->dword |=  phy_ptr->fragment_element[phy_tx_index++];
80002e14:	49 5a       	lddpc	r10,80002e68 <phy_tx_func+0xf8>
80002e16:	74 0a       	ld.w	r10,r10[0x0]
80002e18:	f4 08 05 1a 	ld.uh	r10,r10[r8<<0x1]
80002e1c:	14 49       	or	r9,r10
80002e1e:	8f 19       	st.w	r7[0x4],r9
80002e20:	2f f8       	sub	r8,-1
80002e22:	49 59       	lddpc	r9,80002e74 <phy_tx_func+0x104>
80002e24:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
80002e26:	20 2c       	sub	r12,2
80002e28:	49 28       	lddpc	r8,80002e70 <phy_tx_func+0x100>
80002e2a:	b0 0c       	st.h	r8[0x0],r12
			
			/*Have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80002e2c:	30 08       	mov	r8,0
80002e2e:	f0 0c 19 00 	cp.h	r12,r8
80002e32:	e0 89 00 0c 	brgt	80002e4a <phy_tx_func+0xda>
			{
				/*Must send 0x00BA0000 next interrupt in Slot 3&4*/
				phy_tx_state = SEND_TAILED;
80002e36:	30 29       	mov	r9,2
80002e38:	48 b8       	lddpc	r8,80002e64 <phy_tx_func+0xf4>
80002e3a:	91 09       	st.w	r8[0x0],r9
80002e3c:	c0 78       	rjmp	80002e4a <phy_tx_func+0xda>
			}
			break;

		case SEND_TAILED:
			/*send 0x00BA0000*/
			xnl_tx_channel->dword = PHYTERMLEFT;
80002e3e:	fc 18 00 ba 	movh	r8,0xba
80002e42:	99 18       	st.w	r12[0x4],r8
			
			/*Go back to waiting.*/		
			phy_tx_state = WAITING_FOR_PHY_TX;		
80002e44:	30 09       	mov	r9,0
80002e46:	48 88       	lddpc	r8,80002e64 <phy_tx_func+0xf4>
80002e48:	91 09       	st.w	r8[0x0],r9
	//#else
	///*send idle frame*/	
	//((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
	//((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
	//#endif /*end if*/
	((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
80002e4a:	e0 68 5a 5a 	mov	r8,23130
80002e4e:	ea 18 ab cd 	orh	r8,0xabcd
80002e52:	8f 28       	st.w	r7[0x8],r8
	((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
80002e54:	30 08       	mov	r8,0
80002e56:	8f 38       	st.w	r7[0xc],r8
}
80002e58:	2f fd       	sub	sp,-4
80002e5a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002e5e:	00 00       	add	r0,r0
80002e60:	00 00       	add	r0,r0
80002e62:	0a d4       	st.w	--r5,r4
80002e64:	00 00       	add	r0,r0
80002e66:	0a 94       	mov	r4,r5
80002e68:	00 00       	add	r0,r0
80002e6a:	0a a0       	st.w	r5++,r0
80002e6c:	80 00       	ld.sh	r0,r0[0x0]
80002e6e:	61 2c       	ld.w	r12,r0[0x48]
80002e70:	00 00       	add	r0,r0
80002e72:	0a bc       	st.h	r5++,r12
80002e74:	00 00       	add	r0,r0
80002e76:	0a 74       	tst	r4,r5

80002e78 <get_idle_store>:
	}//End of RxMedia Phy Handler.
}
#endif /*end if*/

void * get_idle_store(xQueueHandle store)
{
80002e78:	d4 01       	pushm	lr
80002e7a:	20 1d       	sub	sp,4
	void * ptr = NULL;
80002e7c:	30 0a       	mov	r10,0
80002e7e:	fa cb ff fc 	sub	r11,sp,-4
80002e82:	16 da       	st.w	--r11,r10

	if(pdTRUE == xQueueReceive(store, &ptr, 0))
80002e84:	14 99       	mov	r9,r10
80002e86:	1a 9b       	mov	r11,sp
80002e88:	f0 1f 00 05 	mcall	80002e9c <get_idle_store+0x24>
80002e8c:	58 1c       	cp.w	r12,1
80002e8e:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80002e92:	fb fc 00 00 	ld.weq	r12,sp[0x0]
	}
	else
	{
		return NULL;
	}
}
80002e96:	2f fd       	sub	sp,-4
80002e98:	d8 02       	popm	pc
80002e9a:	00 00       	add	r0,r0
80002e9c:	80 00       	ld.sh	r0,r0[0x0]
80002e9e:	62 1c       	ld.w	r12,r1[0x4]

80002ea0 <phy_init>:
    register_rx_tx_func -- ssc.c
	xQueueCreate -- freertos
Called By: xnl_init -- xnl.c
*/
void phy_init( void )
{
80002ea0:	d4 01       	pushm	lr
    /*register the func to send/receive ssc packet*/
    register_rx_tx_func(phy_rx_func, phy_tx_func);	
80002ea2:	48 4b       	lddpc	r11,80002eb0 <phy_init+0x10>
80002ea4:	48 4c       	lddpc	r12,80002eb4 <phy_init+0x14>
80002ea6:	f0 1f 00 05 	mcall	80002eb8 <phy_init+0x18>
	
	/*initialize the SSC*/
	ssc_init();
80002eaa:	f0 1f 00 05 	mcall	80002ebc <phy_init+0x1c>
	
	/*send device_master_query to connect radio*/
	//xnl_send_device_master_query();
	
}
80002eae:	d8 02       	popm	pc
80002eb0:	80 00       	ld.sh	r0,r0[0x0]
80002eb2:	2d 70       	sub	r0,-41
80002eb4:	80 00       	ld.sh	r0,r0[0x0]
80002eb6:	2e c0       	sub	r0,-20
80002eb8:	80 00       	ld.sh	r0,r0[0x0]
80002eba:	3f 14       	mov	r4,-15
80002ebc:	80 00       	ld.sh	r0,r0[0x0]
80002ebe:	3f 28       	mov	r8,-14

80002ec0 <phy_rx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_rx_func( void * ssc)
{    
80002ec0:	eb cd 40 e0 	pushm	r5-r7,lr
80002ec4:	18 97       	mov	r7,r12
		
	if(NULL != phy_xnl_frame_rx)
80002ec6:	fe f8 0e 7a 	ld.w	r8,pc[3706]
80002eca:	70 08       	ld.w	r8,r8[0x0]
80002ecc:	58 08       	cp.w	r8,0
80002ece:	e0 80 01 08 	breq	800030de <phy_rx_func+0x21e>
	static U16 phy_check_sum = 0;

	static phy_rx_state_t  phy_rx_state = WAITING_FOR_HEADER;
	static U32 phy_rx_count = 0;

	U32 phy_dword = xnl_rx_channel->dword;	
80002ed2:	78 16       	ld.w	r6,r12[0x4]

	phy_rx_count++;
80002ed4:	fe f8 0e 70 	ld.w	r8,pc[3696]
80002ed8:	70 09       	ld.w	r9,r8[0x0]
80002eda:	2f f9       	sub	r9,-1
80002edc:	91 09       	st.w	r8[0x0],r9
	
	/*This is the code for parsing the incoming physical message.*/
	switch (phy_rx_state)
80002ede:	fe f8 0e 6a 	ld.w	r8,pc[3690]
80002ee2:	70 08       	ld.w	r8,r8[0x0]
80002ee4:	58 18       	cp.w	r8,1
80002ee6:	e0 80 00 85 	breq	80002ff0 <phy_rx_func+0x130>
80002eea:	c0 73       	brcs	80002ef8 <phy_rx_func+0x38>
80002eec:	58 28       	cp.w	r8,2
80002eee:	c5 c0       	breq	80002fa6 <phy_rx_func+0xe6>
80002ef0:	58 38       	cp.w	r8,3
80002ef2:	e0 81 00 f6 	brne	800030de <phy_rx_func+0x21e>
80002ef6:	cd 58       	rjmp	800030a0 <phy_rx_func+0x1e0>

        /*Waiting for something. Most frequent visit.*/		
		case WAITING_FOR_HEADER:
		
			/*Ignore Idles.*/
			if (0xABCD5A5A == phy_dword)
80002ef8:	e0 6a 5a 5a 	mov	r10,23130
80002efc:	ea 1a ab cd 	orh	r10,0xabcd
80002f00:	14 36       	cp.w	r6,r10
80002f02:	e0 80 00 ee 	breq	800030de <phy_rx_func+0x21e>
			{
				break;
			}	

			/*Skip until Header.*/		
			if (0xABCD != (phy_dword >> 16))
80002f06:	ec 08 16 10 	lsr	r8,r6,0x10
80002f0a:	e0 48 ab cd 	cp.w	r8,43981
80002f0e:	e0 81 00 e8 	brne	800030de <phy_rx_func+0x21e>
			{			
				break;
			}
		
			/*Length excluding CSUM.*/
			phy_rx_expexted_length = (phy_dword & 0x000000FF) - 2;
80002f12:	eb d6 b0 10 	bfexts	r5,r6,0x0,0x10
80002f16:	f1 d5 c0 08 	bfextu	r8,r5,0x0,0x8
80002f1a:	20 28       	sub	r8,2
80002f1c:	fe f9 0e 30 	ld.w	r9,pc[3632]
80002f20:	b2 08       	st.h	r9[0x0],r8
			
			/*Discard degenerate message.*/
			if (phy_rx_expexted_length <= 0)
80002f22:	30 09       	mov	r9,0
80002f24:	f2 08 19 00 	cp.h	r8,r9
80002f28:	e0 8a 00 db 	brle	800030de <phy_rx_func+0x21e>
			{
				break;
			}
		
			phy_rx_length = 0;
80002f2c:	fe f8 0e 24 	ld.w	r8,pc[3620]
80002f30:	b0 09       	st.h	r8[0x0],r9

			phy_frame_ptr = get_xnl_idle_isr();
80002f32:	fe f8 0e 22 	ld.w	r8,pc[3618]
80002f36:	70 0c       	ld.w	r12,r8[0x0]
80002f38:	f0 1f 03 88 	mcall	80003d58 <phy_rx_func+0xe98>
80002f3c:	fe f8 0e 20 	ld.w	r8,pc[3616]
80002f40:	91 0c       	st.w	r8[0x0],r12
			if(NULL == phy_frame_ptr)
80002f42:	58 0c       	cp.w	r12,0
80002f44:	e0 80 00 cd 	breq	800030de <phy_rx_func+0x21e>
			{
				break;
			}
					
			phy_frame_ptr->fragment_element[phy_rx_length++] = phy_dword;
80002f48:	fe f8 0e 08 	ld.w	r8,pc[3592]
80002f4c:	90 09       	ld.sh	r9,r8[0x0]
80002f4e:	f8 09 0a 15 	st.h	r12[r9<<0x1],r5
80002f52:	2f f9       	sub	r9,-1
80002f54:	5c 89       	casts.h	r9
			
			/*time stamp*/
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
80002f56:	fe fa 0e 06 	ld.w	r10,pc[3590]
80002f5a:	74 0a       	ld.w	r10,r10[0x0]
80002f5c:	fe fb 0d e8 	ld.w	r11,pc[3560]
80002f60:	76 0b       	ld.w	r11,r11[0x0]
80002f62:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
80002f66:	2f f9       	sub	r9,-1
80002f68:	b0 09       	st.h	r8[0x0],r9
													(phy_rx_count) & 0x0000FFFF;
			
			/*This switch tests the fragment type, and adjusts receiver state
			accordingly.*/
			/*Check frag type*/
			switch (phy_dword & 0x00000F00)
80002f6a:	e2 16 0f 00 	andl	r6,0xf00,COH
80002f6e:	e0 46 01 00 	cp.w	r6,256
80002f72:	c0 c0       	breq	80002f8a <phy_rx_func+0xca>
80002f74:	e0 8b 00 05 	brhi	80002f7e <phy_rx_func+0xbe>
80002f78:	58 06       	cp.w	r6,0
80002f7a:	c0 80       	breq	80002f8a <phy_rx_func+0xca>
80002f7c:	c0 c8       	rjmp	80002f94 <phy_rx_func+0xd4>
80002f7e:	e0 46 02 00 	cp.w	r6,512
80002f82:	c0 40       	breq	80002f8a <phy_rx_func+0xca>
80002f84:	e0 46 03 00 	cp.w	r6,768
80002f88:	c0 61       	brne	80002f94 <phy_rx_func+0xd4>
			{
				case SINGLE_FRAGMENT:  //Only Fragment.
				case FIRST_FRAGMENT:   //First of Multi-fragment.
				case MIDDLE_FRAGMENT:  //Continuing Multi-fragment.
				case LAST_FRAGMENT:    //Last Multi-fragment.
					phy_rx_state = WAITING_CHECK_SUM;
80002f8a:	30 29       	mov	r9,2
80002f8c:	fe f8 0d bc 	ld.w	r8,pc[3516]
80002f90:	91 09       	st.w	r8[0x0],r9
80002f92:	ca 68       	rjmp	800030de <phy_rx_func+0x21e>
				break;
				default:
					set_xnl_idle_isr(phy_frame_ptr);			
80002f94:	fe f8 0d c0 	ld.w	r8,pc[3520]
80002f98:	70 0c       	ld.w	r12,r8[0x0]
80002f9a:	fe f8 0d c2 	ld.w	r8,pc[3522]
80002f9e:	70 0b       	ld.w	r11,r8[0x0]
80002fa0:	f0 1f 03 70 	mcall	80003d60 <phy_rx_func+0xea0>
80002fa4:	c9 d8       	rjmp	800030de <phy_rx_func+0x21e>
		
			/*Stores CSUM*/
			phy_check_sum  = (phy_dword & 0xFFFF0000) >> 16;
			
			/*sums in first hWord*/
			phy_check_sum += (phy_dword & 0x0000FFFF);		
80002fa6:	f5 d6 b0 10 	bfexts	r10,r6,0x0,0x10
80002faa:	b1 86       	lsr	r6,0x10
80002fac:	14 06       	add	r6,r10
80002fae:	fe f8 0d b6 	ld.w	r8,pc[3510]
80002fb2:	b0 06       	st.h	r8[0x0],r6
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
80002fb4:	fe f8 0d 9c 	ld.w	r8,pc[3484]
80002fb8:	90 09       	ld.sh	r9,r8[0x0]
80002fba:	fe fb 0d a2 	ld.w	r11,pc[3490]
80002fbe:	76 0b       	ld.w	r11,r11[0x0]
80002fc0:	f6 09 0a 1a 	st.h	r11[r9<<0x1],r10
80002fc4:	2f f9       	sub	r9,-1
80002fc6:	b0 09       	st.h	r8[0x0],r9
														 phy_dword & 0x0000FFFF;
					
			phy_rx_expexted_length -= 2;
80002fc8:	fe f9 0d 84 	ld.w	r9,pc[3460]
80002fcc:	92 08       	ld.sh	r8,r9[0x0]
80002fce:	20 28       	sub	r8,2
80002fd0:	b2 08       	st.h	r9[0x0],r8
			
			/*Normal case for greater than one byte payloads.*/
			if (phy_rx_expexted_length > 0)
80002fd2:	30 09       	mov	r9,0
80002fd4:	f2 08 19 00 	cp.h	r8,r9
80002fd8:	e0 8a 00 07 	brle	80002fe6 <phy_rx_func+0x126>
			{					  
				phy_rx_state = READING_FRAGMENT;
80002fdc:	30 19       	mov	r9,1
80002fde:	fe f8 0d 6a 	ld.w	r8,pc[3434]
80002fe2:	91 09       	st.w	r8[0x0],r9
80002fe4:	c7 d8       	rjmp	800030de <phy_rx_func+0x21e>
	    		Note that all segments must align with a 32-bit boundary and
				beginning of each XCMP/XNL payload frame must start on slot 3
				Thus, segments of odd length must append a 0x0000 at the end
				(slot 4) to ensure alignment. [9.1.3]
				*/
				phy_rx_state = WAITING_LAST_TERM;
80002fe6:	30 39       	mov	r9,3
80002fe8:	fe f8 0d 60 	ld.w	r8,pc[3424]
80002fec:	91 09       	st.w	r8[0x0],r9
80002fee:	c7 88       	rjmp	800030de <phy_rx_func+0x21e>
			}			
		
			break;

		case READING_FRAGMENT:
			phy_check_sum += (phy_dword & 0xFFFF0000) >> 16;
80002ff0:	ec 0a 14 10 	asr	r10,r6,0x10
80002ff4:	fe f8 0d 70 	ld.w	r8,pc[3440]
80002ff8:	90 09       	ld.sh	r9,r8[0x0]
80002ffa:	14 09       	add	r9,r10
80002ffc:	b0 09       	st.h	r8[0x0],r9
	
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
80002ffe:	fe f9 0d 52 	ld.w	r9,pc[3410]
80003002:	92 08       	ld.sh	r8,r9[0x0]
80003004:	fe fb 0d 58 	ld.w	r11,pc[3416]
80003008:	76 0b       	ld.w	r11,r11[0x0]
8000300a:	f6 08 0a 1a 	st.h	r11[r8<<0x1],r10
8000300e:	2f f8       	sub	r8,-1
80003010:	5c 88       	casts.h	r8
80003012:	b2 08       	st.h	r9[0x0],r8
												 (phy_dword & 0xFFFF0000) >> 16;
	
			phy_rx_expexted_length -= 2;
80003014:	fe fa 0d 38 	ld.w	r10,pc[3384]
80003018:	94 09       	ld.sh	r9,r10[0x0]
8000301a:	20 29       	sub	r9,2
8000301c:	b4 09       	st.h	r10[0x0],r9
			if (phy_rx_expexted_length <= 0)
8000301e:	30 0a       	mov	r10,0
80003020:	f4 09 19 00 	cp.h	r9,r10
80003024:	e0 89 00 20 	brgt	80003064 <phy_rx_func+0x1a4>
				Terminator should be in 2nd hWord.
				Shaoqun says useful bits not used. The packet will always end
				with $00BA. [9.1.2.8]	
				*/
				
				if ((0x000000BA == (phy_dword  & 0x0000FFFF)) 
80003028:	ed d6 c0 10 	bfextu	r6,r6,0x0,0x10
8000302c:	e0 46 00 ba 	cp.w	r6,186
80003030:	c0 d1       	brne	8000304a <phy_rx_func+0x18a>
80003032:	fe f8 0d 32 	ld.w	r8,pc[3378]
80003036:	90 09       	ld.sh	r9,r8[0x0]
80003038:	f4 09 19 00 	cp.h	r9,r10
8000303c:	c0 71       	brne	8000304a <phy_rx_func+0x18a>
					&& (phy_check_sum == 0))
				{
					phy_rx(phy_frame_ptr);
8000303e:	fe f8 0d 1e 	ld.w	r8,pc[3358]
80003042:	70 0c       	ld.w	r12,r8[0x0]
80003044:	f0 1f 03 49 	mcall	80003d68 <phy_rx_func+0xea8>
80003048:	c0 98       	rjmp	8000305a <phy_rx_func+0x19a>
				}
				else
				{
					set_xnl_idle_isr(phy_frame_ptr);
8000304a:	fe f8 0d 0a 	ld.w	r8,pc[3338]
8000304e:	70 0c       	ld.w	r12,r8[0x0]
80003050:	fe f8 0d 0c 	ld.w	r8,pc[3340]
80003054:	70 0b       	ld.w	r11,r8[0x0]
80003056:	f0 1f 03 43 	mcall	80003d60 <phy_rx_func+0xea0>
				}

				phy_rx_state = WAITING_FOR_HEADER;
8000305a:	30 09       	mov	r9,0
8000305c:	fe f8 0c ec 	ld.w	r8,pc[3308]
80003060:	91 09       	st.w	r8[0x0],r9
80003062:	c3 e8       	rjmp	800030de <phy_rx_func+0x21e>
				break;
			}
		
			/*Have not broken. 2nd hWord contains payload.*/
			phy_check_sum += (phy_dword & 0x0000FFFF);
80003064:	5c 86       	casts.h	r6
80003066:	fe f9 0c fe 	ld.w	r9,pc[3326]
8000306a:	92 0a       	ld.sh	r10,r9[0x0]
8000306c:	0c 0a       	add	r10,r6
8000306e:	b2 0a       	st.h	r9[0x0],r10
		
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
80003070:	fe f9 0c ec 	ld.w	r9,pc[3308]
80003074:	72 09       	ld.w	r9,r9[0x0]
80003076:	f2 08 0a 16 	st.h	r9[r8<<0x1],r6
8000307a:	2f f8       	sub	r8,-1
8000307c:	fe f9 0c d4 	ld.w	r9,pc[3284]
80003080:	b2 08       	st.h	r9[0x0],r8
													   (phy_dword & 0x0000FFFF);
		
			phy_rx_expexted_length -= 2;
80003082:	fe f9 0c ca 	ld.w	r9,pc[3274]
80003086:	92 08       	ld.sh	r8,r9[0x0]
80003088:	20 28       	sub	r8,2
8000308a:	b2 08       	st.h	r9[0x0],r8
			if (phy_rx_expexted_length <= 0)
8000308c:	30 09       	mov	r9,0
8000308e:	f2 08 19 00 	cp.h	r8,r9
80003092:	e0 89 00 26 	brgt	800030de <phy_rx_func+0x21e>
			{
				/*All read in. Next Word should be 0x00BA0000.*/
				phy_rx_state = WAITING_LAST_TERM;
80003096:	30 39       	mov	r9,3
80003098:	fe f8 0c b0 	ld.w	r8,pc[3248]
8000309c:	91 09       	st.w	r8[0x0],r9
8000309e:	c2 08       	rjmp	800030de <phy_rx_func+0x21e>
			}/*else, next Word contains more payload.*/
			break;

		/*Expecting last terminator 0x00BA0000.*/	
		case WAITING_LAST_TERM:			
			if ((0x00BA0000 == (phy_dword  & 0x00FF0000)) /*Expected found.*/
800030a0:	e6 16 00 ff 	andh	r6,0xff,COH
800030a4:	fc 19 00 ba 	movh	r9,0xba
800030a8:	12 36       	cp.w	r6,r9
800030aa:	c0 e1       	brne	800030c6 <phy_rx_func+0x206>
800030ac:	fe f8 0c b8 	ld.w	r8,pc[3256]
800030b0:	90 09       	ld.sh	r9,r8[0x0]
800030b2:	30 08       	mov	r8,0
800030b4:	f0 09 19 00 	cp.h	r9,r8
800030b8:	c0 71       	brne	800030c6 <phy_rx_func+0x206>
				&& (phy_check_sum == 0))/*Good checksum*/
			{
				phy_rx(phy_frame_ptr);
800030ba:	fe f8 0c a2 	ld.w	r8,pc[3234]
800030be:	70 0c       	ld.w	r12,r8[0x0]
800030c0:	f0 1f 03 2a 	mcall	80003d68 <phy_rx_func+0xea8>
800030c4:	c0 98       	rjmp	800030d6 <phy_rx_func+0x216>

			}
			else
			{
				set_xnl_idle_isr(phy_frame_ptr);
800030c6:	fe f8 0c 8e 	ld.w	r8,pc[3214]
800030ca:	70 0c       	ld.w	r12,r8[0x0]
800030cc:	fe f8 0c 90 	ld.w	r8,pc[3216]
800030d0:	70 0b       	ld.w	r11,r8[0x0]
800030d2:	f0 1f 03 24 	mcall	80003d60 <phy_rx_func+0xea0>
			}
				
			phy_rx_state = WAITING_FOR_HEADER;
800030d6:	30 09       	mov	r9,0
800030d8:	fe f8 0c 70 	ld.w	r8,pc[3184]
800030dc:	91 09       	st.w	r8[0x0],r9
	static U8 _flag = 1;//0xABCDC014时，_flag为0；
						//0xABCDC010时，_flag为1；
			
	//payload_ptr_t *AMBE_payload_ptr;		
	
	if(is_first == FALSE)
800030de:	fe f8 0c 8e 	ld.w	r8,pc[3214]
800030e2:	11 89       	ld.ub	r9,r8[0x0]
800030e4:	30 08       	mov	r8,0
800030e6:	f0 09 18 00 	cp.b	r9,r8
800030ea:	c1 31       	brne	80003110 <phy_rx_func+0x250>
	{
		payload_ptr = get_payload_idle_isr();
800030ec:	fe f6 0c 84 	ld.w	r6,pc[3204]
800030f0:	6c 0c       	ld.w	r12,r6[0x0]
800030f2:	f0 1f 03 1a 	mcall	80003d58 <phy_rx_func+0xe98>
800030f6:	fe f8 0c 7e 	ld.w	r8,pc[3198]
800030fa:	91 0c       	st.w	r8[0x0],r12
		AMBE_payload_ptr = get_payload_idle_isr();
800030fc:	6c 0c       	ld.w	r12,r6[0x0]
800030fe:	f0 1f 03 17 	mcall	80003d58 <phy_rx_func+0xe98>
80003102:	fe f8 0c 76 	ld.w	r8,pc[3190]
80003106:	91 0c       	st.w	r8[0x0],r12
		is_first = TRUE;
80003108:	30 19       	mov	r9,1
8000310a:	fe f8 0c 62 	ld.w	r8,pc[3170]
8000310e:	b0 89       	st.b	r8[0x0],r9
	}	
	
	//This is the RxMedia Phy Handler.
	switch (RxMediaState)
80003110:	fe f8 0c 6c 	ld.w	r8,pc[3180]
80003114:	70 08       	ld.w	r8,r8[0x0]
80003116:	58 28       	cp.w	r8,2
80003118:	e0 80 01 98 	breq	80003448 <phy_rx_func+0x588>
8000311c:	e0 8b 00 06 	brhi	80003128 <phy_rx_func+0x268>
80003120:	58 08       	cp.w	r8,0
80003122:	c0 b0       	breq	80003138 <phy_rx_func+0x278>
80003124:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80003128:	58 38       	cp.w	r8,3
8000312a:	e0 80 05 c5 	breq	80003cb4 <phy_rx_func+0xdf4>
8000312e:	58 48       	cp.w	r8,4
80003130:	e0 81 06 05 	brne	80003d3a <phy_rx_func+0xe7a>
80003134:	e0 8f 02 4b 	bral	800035ca <phy_rx_func+0x70a>
	{
		case WAITINGABAB:

			
			if (payload_rx_channel->dword[0] == 0xABCD5A5A)//Ignore Idles.
80003138:	6e 28       	ld.w	r8,r7[0x8]
8000313a:	e0 6a 5a 5a 	mov	r10,23130
8000313e:	ea 1a ab cd 	orh	r10,0xabcd
80003142:	14 38       	cp.w	r8,r10
80003144:	c0 71       	brne	80003152 <phy_rx_func+0x292>
			{
				m_RxBurstType = VOICE_WATING;
80003146:	30 09       	mov	r9,0
80003148:	fe f8 0c 38 	ld.w	r8,pc[3128]
8000314c:	91 09       	st.w	r8[0x0],r9
8000314e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
				//Upon receiving the idle frame, the m Rx Burst Type into an idle state in order to transmit the synchronization wait
				 break; 
			}
            
			if ((payload_rx_channel->dword[0]  & 0xFFFF0000) != 0xABCD0000)break; //Skip until Header. 
80003152:	10 99       	mov	r9,r8
80003154:	e0 19 00 00 	andl	r9,0x0
80003158:	fc 1a ab cd 	movh	r10,0xabcd
8000315c:	14 39       	cp.w	r9,r10
8000315e:	e0 81 05 ee 	brne	80003d3a <phy_rx_func+0xe7a>
			}
			//logFromISR("\n\r P: %X \n\r", payload_rx_channel->word[1]);//测试收到的数据
			
#endif
			
			RxBytesWaiting = payload_rx_channel->dword[0] & 0x000000FF;
80003162:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
80003166:	fe f9 0c 1e 	ld.w	r9,pc[3102]
8000316a:	93 08       	st.w	r9[0x0],r8
			/****Note AMBE stream protocol frame structure and the PCM frame structure is different*****/
					
			if ((payload_rx_channel->dword[0] & 0x0000F000 ) == PAYLOAD_DATA_ENH )//PAYLOAD_DATA_ENH (0x0c))
8000316c:	6e 29       	ld.w	r9,r7[0x8]
8000316e:	e2 19 f0 00 	andl	r9,0xf000,COH
80003172:	e0 49 c0 00 	cp.w	r9,49152
80003176:	e0 81 00 ce 	brne	80003312 <phy_rx_func+0x452>
			{
				AMBE_Media = 1;	
8000317a:	30 1a       	mov	r10,1
8000317c:	fe f9 0c 0c 	ld.w	r9,pc[3084]
80003180:	b2 8a       	st.b	r9[0x0],r10
				
				if (NULL== AMBE_payload_ptr){
80003182:	fe f9 0b f6 	ld.w	r9,pc[3062]
80003186:	72 09       	ld.w	r9,r9[0x0]
80003188:	58 09       	cp.w	r9,0
8000318a:	c0 71       	brne	80003198 <phy_rx_func+0x2d8>
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//测试是否有这种情况出现
8000318c:	fe fc 0c 00 	ld.w	r12,pc[3072]
80003190:	f0 1f 03 00 	mcall	80003d90 <phy_rx_func+0xed0>
80003194:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
																	
				Item_ID = payload_rx_channel->byte[5];
80003198:	ef 3a 00 0d 	ld.ub	r10,r7[13]
8000319c:	fe f9 0b f8 	ld.w	r9,pc[3064]
800031a0:	b2 8a       	st.b	r9[0x0],r10
				
				Item_Length = (payload_rx_channel->byte[4] & 0x7F);//7bits
800031a2:	ef 3b 00 0c 	ld.ub	r11,r7[12]
800031a6:	f7 db c0 07 	bfextu	r11,r11,0x0,0x7
800031aa:	fe fa 0b ee 	ld.w	r10,pc[3054]
800031ae:	95 0b       	st.w	r10[0x0],r11
								
				switch(Item_ID)
800031b0:	13 89       	ld.ub	r9,r9[0x0]
800031b2:	37 fa       	mov	r10,127
800031b4:	f4 09 18 00 	cp.b	r9,r10
800031b8:	c6 d0       	breq	80003292 <phy_rx_func+0x3d2>
800031ba:	e0 8b 00 0c 	brhi	800031d2 <phy_rx_func+0x312>
800031be:	31 2a       	mov	r10,18
800031c0:	f4 09 18 00 	cp.b	r9,r10
800031c4:	c4 20       	breq	80003248 <phy_rx_func+0x388>
800031c6:	31 3a       	mov	r10,19
800031c8:	f4 09 18 00 	cp.b	r9,r10
800031cc:	e0 81 00 83 	brne	800032d2 <phy_rx_func+0x412>
800031d0:	c5 b8       	rjmp	80003286 <phy_rx_func+0x3c6>
800031d2:	2f 09       	sub	r9,-16
800031d4:	30 1a       	mov	r10,1
800031d6:	f4 09 18 00 	cp.b	r9,r10
800031da:	e0 8b 00 7c 	brhi	800032d2 <phy_rx_func+0x412>
					//The OB know the Call begin and discard the Voice Header
					//The OB know the Call end and discard the Voice  Terminator
					case Raw_Tx_Data_HT://0xF0
					case Raw_Rx_Data_HT://0xF1
					
							if ((payload_rx_channel->byte[6] & 0xF0 )== 0x10)//header
800031de:	ef 38 00 0e 	ld.ub	r8,r7[14]
800031e2:	e2 18 00 f0 	andl	r8,0xf0,COH
800031e6:	59 08       	cp.w	r8,16
800031e8:	c0 71       	brne	800031f6 <phy_rx_func+0x336>
							{
								m_RxBurstType = VOICEHEADER;
800031ea:	30 19       	mov	r9,1
800031ec:	fe f8 0b 94 	ld.w	r8,pc[2964]
800031f0:	91 09       	st.w	r8[0x0],r9
800031f2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

							}
							else if ((payload_rx_channel->byte[6] & 0xF0) == 0x20)//Terminator
800031f6:	e0 48 00 20 	cp.w	r8,32
800031fa:	c2 11       	brne	8000323c <phy_rx_func+0x37c>
							{
								m_RxBurstType = VOICETERMINATOR;
800031fc:	30 a9       	mov	r9,10
800031fe:	fe f8 0b 82 	ld.w	r8,pc[2946]
80003202:	91 09       	st.w	r8[0x0],r9
								//AMBE-data and PCM-data is not the same. AMBE is compressed data,
								//if there was a missing portion, a clear voice is difficult to extract the data.
								//It must ensure that all the data received AMBE.
								
								//注意！！！考虑是否需要把剩余的空间置0。
								memset((AMBE_payload_ptr+ (RxAMBE_IsFillingNext8 +1)), 0x00, (512-(RxAMBE_IsFillingNext8 + 1)));
80003204:	fe f6 0b 98 	ld.w	r6,pc[2968]
80003208:	6c 08       	ld.w	r8,r6[0x0]
8000320a:	f0 0a 11 ff 	rsub	r10,r8,-1
8000320e:	fe f7 0b 6a 	ld.w	r7,pc[2922]
80003212:	2f f8       	sub	r8,-1
80003214:	6e 0c       	ld.w	r12,r7[0x0]
80003216:	f4 ca fe 00 	sub	r10,r10,-512
8000321a:	30 0b       	mov	r11,0
8000321c:	10 0c       	add	r12,r8
8000321e:	f0 1f 02 e1 	mcall	80003da0 <phy_rx_func+0xee0>
								
								RxAMBE_IsFillingNext8 = 0;
80003222:	30 08       	mov	r8,0
80003224:	8d 08       	st.w	r6[0x0],r8
								payload_rx(AMBE_payload_ptr);
80003226:	6e 0c       	ld.w	r12,r7[0x0]
80003228:	f0 1f 02 df 	mcall	80003da4 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
8000322c:	fe f8 0b 44 	ld.w	r8,pc[2884]
80003230:	70 0c       	ld.w	r12,r8[0x0]
80003232:	f0 1f 02 ca 	mcall	80003d58 <phy_rx_func+0xe98>
80003236:	8f 0c       	st.w	r7[0x0],r12
80003238:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								//logFromISR("\n\r QQ1 \n\r");
								
							}
							else//error voice
							{
								m_RxBurstType = VOICE_WATING;
8000323c:	30 09       	mov	r9,0
8000323e:	fe f8 0b 42 	ld.w	r8,pc[2882]
80003242:	91 09       	st.w	r8[0x0],r9
80003244:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;//WAITINGABAB.
					
		
					case Vocoder_Bit_Stream_Parameter://0x12
							
							if ((RxBytesWaiting -= 4) <= 0) break;
80003248:	20 48       	sub	r8,4
8000324a:	fe f9 0b 3a 	ld.w	r9,pc[2874]
8000324e:	93 08       	st.w	r9[0x0],r8
80003250:	58 08       	cp.w	r8,0
80003252:	e0 80 05 74 	breq	80003d3a <phy_rx_func+0xe7a>
					
							//Vocoder Bits Stream Parameter
							VF_SN = (payload_rx_channel->byte[7] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
80003256:	ef 3c 00 0f 	ld.ub	r12,r7[15]
8000325a:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
8000325e:	fe f8 0b 4a 	ld.w	r8,pc[2890]
80003262:	b0 8c       	st.b	r8[0x0],r12
							
							VBSP_data[0] = payload_rx_channel->word[2];
80003264:	8e 69       	ld.sh	r9,r7[0xc]
80003266:	fe f8 0b 46 	ld.w	r8,pc[2886]
8000326a:	b0 09       	st.h	r8[0x0],r9
							VBSP_data[1] = payload_rx_channel->word[3];
8000326c:	8e 79       	ld.sh	r9,r7[0xe]
8000326e:	b0 19       	st.h	r8[0x2],r9
							
							m_RxBurstType = CalculateBurst(VF_SN);
80003270:	f0 1f 02 d0 	mcall	80003db0 <phy_rx_func+0xef0>
80003274:	fe f8 0b 0c 	ld.w	r8,pc[2828]
80003278:	91 0c       	st.w	r8[0x0],r12
							
							RxMediaState = READING_AMBE_MEDIA;//Jump
8000327a:	30 49       	mov	r9,4
8000327c:	fe f8 0b 00 	ld.w	r8,pc[2816]
80003280:	91 09       	st.w	r8[0x0],r9
80003282:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							
					//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
					// or discard it to reduce payload size.	
					//This shouldn't happen, but must check.	
					case Soft_Decision_Value://0x13
						m_RxBurstType = VOICE_WATING;
80003286:	30 09       	mov	r9,0
80003288:	fe f8 0a f8 	ld.w	r8,pc[2808]
8000328c:	91 09       	st.w	r8[0x0],r9
8000328e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
					case Radio_Internal_Parameter://0x7F
							
							//logFromISR("\n\r Item_Length:%d\n\r", Item_Length);
							
							if ((RxBytesWaiting -= 4) <= 0) break;
80003292:	20 48       	sub	r8,4
80003294:	fe f9 0a f0 	ld.w	r9,pc[2800]
80003298:	93 08       	st.w	r9[0x0],r8
8000329a:	58 08       	cp.w	r8,0
8000329c:	e0 80 05 4f 	breq	80003d3a <phy_rx_func+0xe7a>
							//Radio Internal Parameter
							Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[3];
800032a0:	fe f8 0b 14 	ld.w	r8,pc[2836]
800032a4:	70 09       	ld.w	r9,r8[0x0]
800032a6:	8e 7b       	ld.sh	r11,r7[0xe]
800032a8:	fe fa 0b 10 	ld.w	r10,pc[2832]
800032ac:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
							RxData_IsFillingNext16 += 1; 
800032b0:	2f f9       	sub	r9,-1
800032b2:	91 09       	st.w	r8[0x0],r9
							Item_Length -= 2 ;
800032b4:	fe f8 0a e4 	ld.w	r8,pc[2788]
800032b8:	70 09       	ld.w	r9,r8[0x0]
800032ba:	20 29       	sub	r9,2
800032bc:	91 09       	st.w	r8[0x0],r9
							//....................................................
							m_RxBurstType = RADIOINTERNAL;
800032be:	30 29       	mov	r9,2
800032c0:	fe f8 0a c0 	ld.w	r8,pc[2752]
800032c4:	91 09       	st.w	r8[0x0],r9

							RxMediaState = READING_AMBE_AUX;//Jump
800032c6:	30 39       	mov	r9,3
800032c8:	fe f8 0a b4 	ld.w	r8,pc[2740]
800032cc:	91 09       	st.w	r8[0x0],r9
800032ce:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									
					default://0x03,0x04
						
						//((Item_ID == 0x04) || (Item_ID == 0x03) )//Unknown type data directly back hair
							//break;
							m_RxBurstType = UNSUREDATA;
800032d2:	30 3a       	mov	r10,3
800032d4:	fe f9 0a ac 	ld.w	r9,pc[2732]
800032d8:	93 0a       	st.w	r9[0x0],r10
							AMBE_HT[0] = payload_rx_channel->dword[0];
800032da:	6e 2a       	ld.w	r10,r7[0x8]
800032dc:	fe f9 0a e0 	ld.w	r9,pc[2784]
800032e0:	93 0a       	st.w	r9[0x0],r10
							AMBE_HT[1] = payload_rx_channel->dword[1];
800032e2:	6e 3a       	ld.w	r10,r7[0xc]
800032e4:	93 1a       	st.w	r9[0x4],r10
							
							if (RxBytesWaiting == 0x00000014)
800032e6:	59 48       	cp.w	r8,20
800032e8:	c0 61       	brne	800032f4 <phy_rx_func+0x434>
							{
								RxBytesWaiting = 0x18;//24 Reassigned
800032ea:	31 89       	mov	r9,24
800032ec:	fe f8 0a 98 	ld.w	r8,pc[2712]
800032f0:	91 09       	st.w	r8[0x0],r9
800032f2:	c0 a8       	rjmp	80003306 <phy_rx_func+0x446>
								//_flag =0;
								
							}
							if (RxBytesWaiting == 0x00000010)
800032f4:	fe f8 0a 90 	ld.w	r8,pc[2704]
800032f8:	70 08       	ld.w	r8,r8[0x0]
800032fa:	59 08       	cp.w	r8,16
800032fc:	c0 51       	brne	80003306 <phy_rx_func+0x446>
							{
								RxBytesWaiting = 0x10;//16 Reassigned
800032fe:	31 09       	mov	r9,16
80003300:	fe f8 0a 84 	ld.w	r8,pc[2692]
80003304:	91 09       	st.w	r8[0x0],r9
								//_flag =1;
							}
					
							RxMediaState = READING_AMBE_MEDIA;//Jump
80003306:	30 49       	mov	r9,4
80003308:	fe f8 0a 74 	ld.w	r8,pc[2676]
8000330c:	91 09       	st.w	r8[0x0],r9
8000330e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
//#if 0
			else//PCM-media-data
			{	
				//logFromISR("\n\r RX:%x \n\r", payload_rx_channel->dword[0]);
				//SPEAKER_DATA or  //MIC_DATA
				if (((payload_rx_channel->dword[0] & 0x0000F000 ) != SPEAKER_DATA ) 
80003312:	e0 49 10 00 	cp.w	r9,4096
80003316:	5f 1a       	srne	r10
80003318:	e0 49 20 00 	cp.w	r9,8192
8000331c:	5f 19       	srne	r9
8000331e:	f5 e9 00 09 	and	r9,r10,r9
80003322:	e0 81 05 0c 	brne	80003d3a <phy_rx_func+0xe7a>
					&& ((payload_rx_channel->dword[0] & 0x0000F000 ) != MIC_DATA ))break;
				
				AMBE_tx_flag = 0;
80003326:	fe fa 0a 9a 	ld.w	r10,pc[2714]
8000332a:	b4 89       	st.b	r10[0x0],r9
				AMBE_rx_flag = 0;
8000332c:	fe fa 0a 98 	ld.w	r10,pc[2712]
80003330:	b4 89       	st.b	r10[0x0],r9
				
				Item_ID = 0;//To make sure your save PCM data.
80003332:	fe fa 0a 62 	ld.w	r10,pc[2658]
80003336:	b4 89       	st.b	r10[0x0],r9
			
				if (NULL== payload_ptr){
80003338:	fe f9 0a 3c 	ld.w	r9,pc[2620]
8000333c:	72 09       	ld.w	r9,r9[0x0]
8000333e:	58 09       	cp.w	r9,0
80003340:	c0 71       	brne	8000334e <phy_rx_func+0x48e>
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//测试是否有这种情况出现
80003342:	fe fc 0a 4a 	ld.w	r12,pc[2634]
80003346:	f0 1f 02 93 	mcall	80003d90 <phy_rx_func+0xed0>
8000334a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
8000334e:	6e 2a       	ld.w	r10,r7[0x8]
80003350:	e2 1a 0f 00 	andl	r10,0xf00,COH
80003354:	58 1a       	cp.w	r10,1
80003356:	e0 8b 00 4d 	brhi	800033f0 <phy_rx_func+0x530>
				
				if ((payload_rx_channel->dword[0]  & 0x00000F00) <= 1){  //Flag type must process Array Descriptor.
				//The first word of the media access payload must be the Array descriptor length. And the
				//unit of the length is in word (16-bit). The length field itself does not count into the length.
				//When there is no array descriptor, the length must be set to zero.[9.1.4.1]
					if ((RxBytesWaiting -= 4) <= 0) break;          //Nothing beyond this Phy buffer. Keep looking for Header
8000335a:	20 48       	sub	r8,4
8000335c:	fe f9 0a 28 	ld.w	r9,pc[2600]
80003360:	93 08       	st.w	r9[0x0],r8
80003362:	58 08       	cp.w	r8,0
80003364:	e0 80 04 eb 	breq	80003d3a <phy_rx_func+0xe7a>
					ArrayDiscLength = payload_rx_channel->word[2];
80003368:	8e 68       	ld.sh	r8,r7[0xc]
8000336a:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
8000336e:	fe f9 0a 5a 	ld.w	r9,pc[2650]
80003372:	93 0a       	st.w	r9[0x0],r10
					switch (ArrayDiscLength){
80003374:	30 09       	mov	r9,0
80003376:	f2 08 19 00 	cp.h	r8,r9
8000337a:	c0 70       	breq	80003388 <phy_rx_func+0x4c8>
8000337c:	30 19       	mov	r9,1
8000337e:	f2 08 19 00 	cp.h	r8,r9
80003382:	e0 81 04 dc 	brne	80003d3a <phy_rx_func+0xe7a>
80003386:	c2 68       	rjmp	800033d2 <phy_rx_func+0x512>
						case 0:          //The usual case. Remaining word in Phy buffer is Audio.
								
							payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
80003388:	fe f8 0a 44 	ld.w	r8,pc[2628]
8000338c:	70 0a       	ld.w	r10,r8[0x0]
8000338e:	fe f9 09 e6 	ld.w	r9,pc[2534]
80003392:	72 09       	ld.w	r9,r9[0x0]
80003394:	8e 7b       	ld.sh	r11,r7[0xe]
80003396:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
							RxMedia_IsFillingNext16 += 1;
8000339a:	70 09       	ld.w	r9,r8[0x0]
8000339c:	2f f9       	sub	r9,-1
8000339e:	91 09       	st.w	r8[0x0],r9
							if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800033a0:	e0 49 00 ff 	cp.w	r9,255
800033a4:	e0 88 00 11 	brls	800033c6 <phy_rx_func+0x506>
							{
								RxMedia_IsFillingNext16 = 0;	
800033a8:	30 09       	mov	r9,0
800033aa:	91 09       	st.w	r8[0x0],r9
								payload_rx(payload_ptr);	
800033ac:	fe f7 09 c8 	ld.w	r7,pc[2504]
800033b0:	6e 0c       	ld.w	r12,r7[0x0]
800033b2:	f0 1f 02 7d 	mcall	80003da4 <phy_rx_func+0xee4>
								payload_ptr = get_payload_idle_isr();
800033b6:	fe f8 09 ba 	ld.w	r8,pc[2490]
800033ba:	70 0c       	ld.w	r12,r8[0x0]
800033bc:	f0 1f 02 67 	mcall	80003d58 <phy_rx_func+0xe98>
800033c0:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == payload_ptr){
800033c2:	e0 80 04 bc 	breq	80003d3a <phy_rx_func+0xe7a>
									break;
								}				
							}
							RxMediaState = READINGMEDIA;
800033c6:	30 29       	mov	r9,2
800033c8:	fe f8 09 b4 	ld.w	r8,pc[2484]
800033cc:	91 09       	st.w	r8[0x0],r9
800033ce:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
800033d2:	8e 79       	ld.sh	r9,r7[0xe]
800033d4:	30 38       	mov	r8,3
800033d6:	f0 09 19 00 	cp.h	r9,r8
800033da:	c0 51       	brne	800033e4 <phy_rx_func+0x524>
				
						case 1: //The next usual case.
								//In general case, add code to process single word Array descriptor.
								if (payload_rx_channel->word[3] == 0x0003)//Stream Terminator
								{
									Terminator_Flag = 1;
800033dc:	30 19       	mov	r9,1
800033de:	fe f8 09 f2 	ld.w	r8,pc[2546]
800033e2:	b0 89       	st.b	r8[0x0],r9
								else
								{
									//Terminator_Flag = 0;
								}
								
								RxMediaState = READINGMEDIA;
800033e4:	30 29       	mov	r9,2
800033e6:	fe f8 09 96 	ld.w	r8,pc[2454]
800033ea:	91 09       	st.w	r8[0x0],r9
800033ec:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
				break;
			}
		
				//Code gets here on Middle or last Fragment. No Array descriptor.
				if (RxBytesWaiting < 2) break;//This shouldn't happen, but must check.
800033f0:	58 18       	cp.w	r8,1
800033f2:	e0 88 04 a4 	brls	80003d3a <phy_rx_func+0xe7a>
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->dword[1] & 0x0000FFFF;
800033f6:	fe f8 09 d6 	ld.w	r8,pc[2518]
800033fa:	70 0a       	ld.w	r10,r8[0x0]
800033fc:	6e 3b       	ld.w	r11,r7[0xc]
800033fe:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80003402:	70 09       	ld.w	r9,r8[0x0]
80003404:	2f f9       	sub	r9,-1
80003406:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003408:	e0 49 00 ff 	cp.w	r9,255
8000340c:	e0 88 00 11 	brls	8000342e <phy_rx_func+0x56e>
				{
					RxMedia_IsFillingNext16 = 0;
80003410:	30 09       	mov	r9,0
80003412:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003414:	fe f7 09 60 	ld.w	r7,pc[2400]
80003418:	6e 0c       	ld.w	r12,r7[0x0]
8000341a:	f0 1f 02 63 	mcall	80003da4 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
8000341e:	fe f8 09 52 	ld.w	r8,pc[2386]
80003422:	70 0c       	ld.w	r12,r8[0x0]
80003424:	f0 1f 02 4d 	mcall	80003d58 <phy_rx_func+0xe98>
80003428:	8f 0c       	st.w	r7[0x0],r12
					if(NULL == payload_ptr)
8000342a:	e0 80 04 88 	breq	80003d3a <phy_rx_func+0xe7a>
					{
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0) break;  //This shouldn't happen, but must check;
8000342e:	fe f9 09 56 	ld.w	r9,pc[2390]
80003432:	72 08       	ld.w	r8,r9[0x0]
80003434:	20 28       	sub	r8,2
80003436:	93 08       	st.w	r9[0x0],r8
80003438:	e0 80 04 81 	breq	80003d3a <phy_rx_func+0xe7a>
				RxMediaState = READINGMEDIA;
8000343c:	30 29       	mov	r9,2
8000343e:	fe f8 09 3e 	ld.w	r8,pc[2366]
80003442:	91 09       	st.w	r8[0x0],r9
80003444:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
		case READINGMEDIA:
				
			/***PCM-media-data ****/
			{
				
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[0];
80003448:	fe f8 09 84 	ld.w	r8,pc[2436]
8000344c:	70 0a       	ld.w	r10,r8[0x0]
8000344e:	fe f9 09 26 	ld.w	r9,pc[2342]
80003452:	72 09       	ld.w	r9,r9[0x0]
80003454:	8e 4b       	ld.sh	r11,r7[0x8]
80003456:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;	
8000345a:	70 09       	ld.w	r9,r8[0x0]
8000345c:	2f f9       	sub	r9,-1
8000345e:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003460:	e0 49 00 ff 	cp.w	r9,255
80003464:	e0 88 00 16 	brls	80003490 <phy_rx_func+0x5d0>
				{
					RxMedia_IsFillingNext16 = 0;
80003468:	30 09       	mov	r9,0
8000346a:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
8000346c:	fe f6 09 08 	ld.w	r6,pc[2312]
80003470:	6c 0c       	ld.w	r12,r6[0x0]
80003472:	f0 1f 02 4d 	mcall	80003da4 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
80003476:	fe f8 08 fa 	ld.w	r8,pc[2298]
8000347a:	70 0c       	ld.w	r12,r8[0x0]
8000347c:	f0 1f 02 37 	mcall	80003d58 <phy_rx_func+0xe98>
80003480:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
80003482:	c0 71       	brne	80003490 <phy_rx_func+0x5d0>
					{
						RxMediaState = WAITINGABAB;
80003484:	30 09       	mov	r9,0
80003486:	fe f8 08 f6 	ld.w	r8,pc[2294]
8000348a:	91 09       	st.w	r8[0x0],r9
8000348c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0)
80003490:	fe f9 08 f4 	ld.w	r9,pc[2292]
80003494:	72 08       	ld.w	r8,r9[0x0]
80003496:	20 28       	sub	r8,2
80003498:	93 08       	st.w	r9[0x0],r8
8000349a:	c0 71       	brne	800034a8 <phy_rx_func+0x5e8>
				{
					RxMediaState = WAITINGABAB;
8000349c:	30 09       	mov	r9,0
8000349e:	fe f8 08 de 	ld.w	r8,pc[2270]
800034a2:	91 09       	st.w	r8[0x0],r9
800034a4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[1];
800034a8:	fe f8 09 24 	ld.w	r8,pc[2340]
800034ac:	70 0a       	ld.w	r10,r8[0x0]
800034ae:	fe f9 08 c6 	ld.w	r9,pc[2246]
800034b2:	72 09       	ld.w	r9,r9[0x0]
800034b4:	8e 5b       	ld.sh	r11,r7[0xa]
800034b6:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
800034ba:	70 09       	ld.w	r9,r8[0x0]
800034bc:	2f f9       	sub	r9,-1
800034be:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800034c0:	e0 49 00 ff 	cp.w	r9,255
800034c4:	e0 88 00 16 	brls	800034f0 <phy_rx_func+0x630>
				{
					RxMedia_IsFillingNext16 = 0;
800034c8:	30 09       	mov	r9,0
800034ca:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
800034cc:	fe f6 08 a8 	ld.w	r6,pc[2216]
800034d0:	6c 0c       	ld.w	r12,r6[0x0]
800034d2:	f0 1f 02 35 	mcall	80003da4 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
800034d6:	fe f8 08 9a 	ld.w	r8,pc[2202]
800034da:	70 0c       	ld.w	r12,r8[0x0]
800034dc:	f0 1f 02 1f 	mcall	80003d58 <phy_rx_func+0xe98>
800034e0:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
800034e2:	c0 71       	brne	800034f0 <phy_rx_func+0x630>
					{
						RxMediaState = WAITINGABAB;
800034e4:	30 09       	mov	r9,0
800034e6:	fe f8 08 96 	ld.w	r8,pc[2198]
800034ea:	91 09       	st.w	r8[0x0],r9
800034ec:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
800034f0:	fe f9 08 94 	ld.w	r9,pc[2196]
800034f4:	72 08       	ld.w	r8,r9[0x0]
800034f6:	20 28       	sub	r8,2
800034f8:	93 08       	st.w	r9[0x0],r8
800034fa:	c0 71       	brne	80003508 <phy_rx_func+0x648>
					RxMediaState = WAITINGABAB;
800034fc:	30 09       	mov	r9,0
800034fe:	fe f8 08 7e 	ld.w	r8,pc[2174]
80003502:	91 09       	st.w	r8[0x0],r9
80003504:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}

				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[2];
80003508:	fe f8 08 c4 	ld.w	r8,pc[2244]
8000350c:	70 0a       	ld.w	r10,r8[0x0]
8000350e:	fe f9 08 66 	ld.w	r9,pc[2150]
80003512:	72 09       	ld.w	r9,r9[0x0]
80003514:	8e 6b       	ld.sh	r11,r7[0xc]
80003516:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
8000351a:	70 09       	ld.w	r9,r8[0x0]
8000351c:	2f f9       	sub	r9,-1
8000351e:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003520:	e0 49 00 ff 	cp.w	r9,255
80003524:	e0 88 00 16 	brls	80003550 <phy_rx_func+0x690>
				{
					RxMedia_IsFillingNext16 = 0;
80003528:	30 09       	mov	r9,0
8000352a:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
8000352c:	fe f6 08 48 	ld.w	r6,pc[2120]
80003530:	6c 0c       	ld.w	r12,r6[0x0]
80003532:	f0 1f 02 1d 	mcall	80003da4 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
80003536:	fe f8 08 3a 	ld.w	r8,pc[2106]
8000353a:	70 0c       	ld.w	r12,r8[0x0]
8000353c:	f0 1f 02 07 	mcall	80003d58 <phy_rx_func+0xe98>
80003540:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
80003542:	c0 71       	brne	80003550 <phy_rx_func+0x690>
					{
						RxMediaState = WAITINGABAB;
80003544:	30 09       	mov	r9,0
80003546:	fe f8 08 36 	ld.w	r8,pc[2102]
8000354a:	91 09       	st.w	r8[0x0],r9
8000354c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
80003550:	fe f9 08 34 	ld.w	r9,pc[2100]
80003554:	72 08       	ld.w	r8,r9[0x0]
80003556:	20 28       	sub	r8,2
80003558:	93 08       	st.w	r9[0x0],r8
8000355a:	c0 71       	brne	80003568 <phy_rx_func+0x6a8>
					RxMediaState = WAITINGABAB;
8000355c:	30 09       	mov	r9,0
8000355e:	fe f8 08 1e 	ld.w	r8,pc[2078]
80003562:	91 09       	st.w	r8[0x0],r9
80003564:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
80003568:	fe f8 08 64 	ld.w	r8,pc[2148]
8000356c:	70 0a       	ld.w	r10,r8[0x0]
8000356e:	fe f9 08 06 	ld.w	r9,pc[2054]
80003572:	72 09       	ld.w	r9,r9[0x0]
80003574:	8e 7b       	ld.sh	r11,r7[0xe]
80003576:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
8000357a:	70 09       	ld.w	r9,r8[0x0]
8000357c:	2f f9       	sub	r9,-1
8000357e:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003580:	e0 49 00 ff 	cp.w	r9,255
80003584:	e0 88 00 16 	brls	800035b0 <phy_rx_func+0x6f0>
				{
					RxMedia_IsFillingNext16 = 0;
80003588:	30 09       	mov	r9,0
8000358a:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
8000358c:	fe f7 07 e8 	ld.w	r7,pc[2024]
80003590:	6e 0c       	ld.w	r12,r7[0x0]
80003592:	f0 1f 02 05 	mcall	80003da4 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
80003596:	fe f8 07 da 	ld.w	r8,pc[2010]
8000359a:	70 0c       	ld.w	r12,r8[0x0]
8000359c:	f0 1f 01 ef 	mcall	80003d58 <phy_rx_func+0xe98>
800035a0:	8f 0c       	st.w	r7[0x0],r12
					if(NULL == payload_ptr)
800035a2:	c0 71       	brne	800035b0 <phy_rx_func+0x6f0>
					{
						RxMediaState = WAITINGABAB;
800035a4:	30 09       	mov	r9,0
800035a6:	fe f8 07 d6 	ld.w	r8,pc[2006]
800035aa:	91 09       	st.w	r8[0x0],r9
800035ac:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
800035b0:	fe f9 07 d4 	ld.w	r9,pc[2004]
800035b4:	72 08       	ld.w	r8,r9[0x0]
800035b6:	20 28       	sub	r8,2
800035b8:	93 08       	st.w	r9[0x0],r8
800035ba:	e0 81 03 c0 	brne	80003d3a <phy_rx_func+0xe7a>
					RxMediaState = WAITINGABAB;
800035be:	30 09       	mov	r9,0
800035c0:	fe f8 07 bc 	ld.w	r8,pc[1980]
800035c4:	91 09       	st.w	r8[0x0],r9
800035c6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

		case READING_AMBE_MEDIA:
		
			/****AMBE-media-data ****/
		
					if ((Item_ID == Vocoder_Bit_Stream_Parameter))//PAYLOAD_DATA_ENH (0x0c))
800035ca:	fe f8 07 ca 	ld.w	r8,pc[1994]
800035ce:	11 89       	ld.ub	r9,r8[0x0]
800035d0:	31 28       	mov	r8,18
800035d2:	f0 09 18 00 	cp.b	r9,r8
800035d6:	e0 81 01 4c 	brne	8000386e <phy_rx_func+0x9ae>
					{
						Item_ID = payload_rx_channel->byte[1];
800035da:	ef 39 00 09 	ld.ub	r9,r7[9]
800035de:	fe f8 07 b6 	ld.w	r8,pc[1974]
800035e2:	b0 89       	st.b	r8[0x0],r9
						if (Item_ID == Post_Voice_Encoder_Data)//发送方的压缩类型数据
800035e4:	11 89       	ld.ub	r9,r8[0x0]
800035e6:	3f 28       	mov	r8,-14
800035e8:	f0 09 18 00 	cp.b	r9,r8
800035ec:	e0 81 01 3b 	brne	80003862 <phy_rx_func+0x9a2>
						{
							AMBE_tx_flag = 1;
800035f0:	30 19       	mov	r9,1
800035f2:	fe f8 07 ce 	ld.w	r8,pc[1998]
800035f6:	b0 89       	st.b	r8[0x0],r9
							
							RxBytesWaiting = ((payload_rx_channel->dword[0] & 0x7F000000) >>24);//Test calculations are correct; 8
800035f8:	6e 29       	ld.w	r9,r7[0x8]
800035fa:	f3 d9 c3 07 	bfextu	r9,r9,0x18,0x7
800035fe:	fe f8 07 86 	ld.w	r8,pc[1926]
80003602:	91 09       	st.w	r8[0x0],r9
							
							//For looping back to Radio
							AMBEBurst_rawdata[0] = payload_rx_channel->word[1];
80003604:	8e 59       	ld.sh	r9,r7[0xa]
80003606:	fe f8 07 ce 	ld.w	r8,pc[1998]
8000360a:	b0 09       	st.h	r8[0x0],r9
							AMBEBurst_rawdata[1] = payload_rx_channel->word[2];
8000360c:	8e 69       	ld.sh	r9,r7[0xc]
8000360e:	b0 19       	st.h	r8[0x2],r9
							AMBEBurst_rawdata[2] = payload_rx_channel->word[3];
80003610:	8e 79       	ld.sh	r9,r7[0xe]
80003612:	b0 29       	st.h	r8[0x4],r9
							
							//To be tested. Also locally stored RAW-AMBER-DATA
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//1
80003614:	fe f8 07 88 	ld.w	r8,pc[1928]
80003618:	fe f9 07 60 	ld.w	r9,pc[1888]
8000361c:	72 0a       	ld.w	r10,r9[0x0]
8000361e:	70 09       	ld.w	r9,r8[0x0]
80003620:	ef 3b 00 0a 	ld.ub	r11,r7[10]
80003624:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003628:	70 09       	ld.w	r9,r8[0x0]
8000362a:	2f f9       	sub	r9,-1
8000362c:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000362e:	e0 49 01 ff 	cp.w	r9,511
80003632:	e0 88 00 16 	brls	8000365e <phy_rx_func+0x79e>
							{
								RxAMBE_IsFillingNext8 = 0;
80003636:	30 09       	mov	r9,0
80003638:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
8000363a:	fe f6 07 3e 	ld.w	r6,pc[1854]
8000363e:	6c 0c       	ld.w	r12,r6[0x0]
80003640:	f0 1f 01 d9 	mcall	80003da4 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003644:	fe f8 07 2c 	ld.w	r8,pc[1836]
80003648:	70 0c       	ld.w	r12,r8[0x0]
8000364a:	f0 1f 01 c4 	mcall	80003d58 <phy_rx_func+0xe98>
8000364e:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003650:	c0 71       	brne	8000365e <phy_rx_func+0x79e>
								{
									RxMediaState = WAITINGABAB;
80003652:	30 09       	mov	r9,0
80003654:	fe f8 07 28 	ld.w	r8,pc[1832]
80003658:	91 09       	st.w	r8[0x0],r9
8000365a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
8000365e:	fe f9 07 26 	ld.w	r9,pc[1830]
80003662:	72 08       	ld.w	r8,r9[0x0]
80003664:	20 18       	sub	r8,1
80003666:	93 08       	st.w	r9[0x0],r8
80003668:	c0 71       	brne	80003676 <phy_rx_func+0x7b6>
								RxMediaState = WAITINGABAB;
8000366a:	30 09       	mov	r9,0
8000366c:	fe f8 07 10 	ld.w	r8,pc[1808]
80003670:	91 09       	st.w	r8[0x0],r9
80003672:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}			
							
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//2
80003676:	fe f8 07 26 	ld.w	r8,pc[1830]
8000367a:	fe f9 06 fe 	ld.w	r9,pc[1790]
8000367e:	72 0a       	ld.w	r10,r9[0x0]
80003680:	70 09       	ld.w	r9,r8[0x0]
80003682:	ef 3b 00 0b 	ld.ub	r11,r7[11]
80003686:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
8000368a:	70 09       	ld.w	r9,r8[0x0]
8000368c:	2f f9       	sub	r9,-1
8000368e:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003690:	e0 49 01 ff 	cp.w	r9,511
80003694:	e0 88 00 16 	brls	800036c0 <phy_rx_func+0x800>
							{
								RxAMBE_IsFillingNext8 = 0;
80003698:	30 09       	mov	r9,0
8000369a:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
8000369c:	fe f6 06 dc 	ld.w	r6,pc[1756]
800036a0:	6c 0c       	ld.w	r12,r6[0x0]
800036a2:	f0 1f 01 c1 	mcall	80003da4 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
800036a6:	fe f8 06 ca 	ld.w	r8,pc[1738]
800036aa:	70 0c       	ld.w	r12,r8[0x0]
800036ac:	f0 1f 01 ab 	mcall	80003d58 <phy_rx_func+0xe98>
800036b0:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
800036b2:	c0 71       	brne	800036c0 <phy_rx_func+0x800>
								{
									RxMediaState = WAITINGABAB;
800036b4:	30 09       	mov	r9,0
800036b6:	fe f8 06 c6 	ld.w	r8,pc[1734]
800036ba:	91 09       	st.w	r8[0x0],r9
800036bc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800036c0:	fe f9 06 c4 	ld.w	r9,pc[1732]
800036c4:	72 08       	ld.w	r8,r9[0x0]
800036c6:	20 18       	sub	r8,1
800036c8:	93 08       	st.w	r9[0x0],r8
800036ca:	c0 71       	brne	800036d8 <phy_rx_func+0x818>
								RxMediaState = WAITINGABAB;
800036cc:	30 09       	mov	r9,0
800036ce:	fe f8 06 ae 	ld.w	r8,pc[1710]
800036d2:	91 09       	st.w	r8[0x0],r9
800036d4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}		
						
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//3
800036d8:	fe f8 06 c4 	ld.w	r8,pc[1732]
800036dc:	fe f9 06 9c 	ld.w	r9,pc[1692]
800036e0:	72 0a       	ld.w	r10,r9[0x0]
800036e2:	70 09       	ld.w	r9,r8[0x0]
800036e4:	ef 3b 00 0c 	ld.ub	r11,r7[12]
800036e8:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
800036ec:	70 09       	ld.w	r9,r8[0x0]
800036ee:	2f f9       	sub	r9,-1
800036f0:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800036f2:	e0 49 01 ff 	cp.w	r9,511
800036f6:	e0 88 00 16 	brls	80003722 <phy_rx_func+0x862>
							{
								RxAMBE_IsFillingNext8 = 0;
800036fa:	30 09       	mov	r9,0
800036fc:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
800036fe:	fe f6 06 7a 	ld.w	r6,pc[1658]
80003702:	6c 0c       	ld.w	r12,r6[0x0]
80003704:	f0 1f 01 a8 	mcall	80003da4 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003708:	fe f8 06 68 	ld.w	r8,pc[1640]
8000370c:	70 0c       	ld.w	r12,r8[0x0]
8000370e:	f0 1f 01 93 	mcall	80003d58 <phy_rx_func+0xe98>
80003712:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003714:	c0 71       	brne	80003722 <phy_rx_func+0x862>
								{
									RxMediaState = WAITINGABAB;
80003716:	30 09       	mov	r9,0
80003718:	fe f8 06 64 	ld.w	r8,pc[1636]
8000371c:	91 09       	st.w	r8[0x0],r9
8000371e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003722:	fe f9 06 62 	ld.w	r9,pc[1634]
80003726:	72 08       	ld.w	r8,r9[0x0]
80003728:	20 18       	sub	r8,1
8000372a:	93 08       	st.w	r9[0x0],r8
8000372c:	c0 71       	brne	8000373a <phy_rx_func+0x87a>
								RxMediaState = WAITINGABAB;
8000372e:	30 09       	mov	r9,0
80003730:	fe f8 06 4c 	ld.w	r8,pc[1612]
80003734:	91 09       	st.w	r8[0x0],r9
80003736:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[5];//4
8000373a:	fe f8 06 62 	ld.w	r8,pc[1634]
8000373e:	fe f9 06 3a 	ld.w	r9,pc[1594]
80003742:	72 0a       	ld.w	r10,r9[0x0]
80003744:	70 09       	ld.w	r9,r8[0x0]
80003746:	ef 3b 00 0d 	ld.ub	r11,r7[13]
8000374a:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
8000374e:	70 09       	ld.w	r9,r8[0x0]
80003750:	2f f9       	sub	r9,-1
80003752:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003754:	e0 49 01 ff 	cp.w	r9,511
80003758:	e0 88 00 16 	brls	80003784 <phy_rx_func+0x8c4>
							{
								RxAMBE_IsFillingNext8 = 0;
8000375c:	30 09       	mov	r9,0
8000375e:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003760:	fe f6 06 18 	ld.w	r6,pc[1560]
80003764:	6c 0c       	ld.w	r12,r6[0x0]
80003766:	f0 1f 01 90 	mcall	80003da4 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
8000376a:	fe f8 06 06 	ld.w	r8,pc[1542]
8000376e:	70 0c       	ld.w	r12,r8[0x0]
80003770:	f0 1f 01 7a 	mcall	80003d58 <phy_rx_func+0xe98>
80003774:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003776:	c0 71       	brne	80003784 <phy_rx_func+0x8c4>
								{
									RxMediaState = WAITINGABAB;
80003778:	30 09       	mov	r9,0
8000377a:	fe f8 06 02 	ld.w	r8,pc[1538]
8000377e:	91 09       	st.w	r8[0x0],r9
80003780:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003784:	fe f9 06 00 	ld.w	r9,pc[1536]
80003788:	72 08       	ld.w	r8,r9[0x0]
8000378a:	20 18       	sub	r8,1
8000378c:	93 08       	st.w	r9[0x0],r8
8000378e:	c0 71       	brne	8000379c <phy_rx_func+0x8dc>
								RxMediaState = WAITINGABAB;
80003790:	30 09       	mov	r9,0
80003792:	fe f8 05 ea 	ld.w	r8,pc[1514]
80003796:	91 09       	st.w	r8[0x0],r9
80003798:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//5
8000379c:	fe f8 06 00 	ld.w	r8,pc[1536]
800037a0:	fe f9 05 d8 	ld.w	r9,pc[1496]
800037a4:	72 0a       	ld.w	r10,r9[0x0]
800037a6:	70 09       	ld.w	r9,r8[0x0]
800037a8:	ef 3b 00 0e 	ld.ub	r11,r7[14]
800037ac:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
800037b0:	70 09       	ld.w	r9,r8[0x0]
800037b2:	2f f9       	sub	r9,-1
800037b4:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800037b6:	e0 49 01 ff 	cp.w	r9,511
800037ba:	e0 88 00 16 	brls	800037e6 <phy_rx_func+0x926>
							{
								RxAMBE_IsFillingNext8 = 0;
800037be:	30 09       	mov	r9,0
800037c0:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
800037c2:	fe f6 05 b6 	ld.w	r6,pc[1462]
800037c6:	6c 0c       	ld.w	r12,r6[0x0]
800037c8:	f0 1f 01 77 	mcall	80003da4 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
800037cc:	fe f8 05 a4 	ld.w	r8,pc[1444]
800037d0:	70 0c       	ld.w	r12,r8[0x0]
800037d2:	f0 1f 01 62 	mcall	80003d58 <phy_rx_func+0xe98>
800037d6:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
800037d8:	c0 71       	brne	800037e6 <phy_rx_func+0x926>
								{
									RxMediaState = WAITINGABAB;
800037da:	30 09       	mov	r9,0
800037dc:	fe f8 05 a0 	ld.w	r8,pc[1440]
800037e0:	91 09       	st.w	r8[0x0],r9
800037e2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800037e6:	fe f9 05 9e 	ld.w	r9,pc[1438]
800037ea:	72 08       	ld.w	r8,r9[0x0]
800037ec:	20 18       	sub	r8,1
800037ee:	93 08       	st.w	r9[0x0],r8
800037f0:	c0 71       	brne	800037fe <phy_rx_func+0x93e>
								RxMediaState = WAITINGABAB;
800037f2:	30 09       	mov	r9,0
800037f4:	fe f8 05 88 	ld.w	r8,pc[1416]
800037f8:	91 09       	st.w	r8[0x0],r9
800037fa:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//6
800037fe:	fe f8 05 9e 	ld.w	r8,pc[1438]
80003802:	fe f9 05 76 	ld.w	r9,pc[1398]
80003806:	72 0a       	ld.w	r10,r9[0x0]
80003808:	70 09       	ld.w	r9,r8[0x0]
8000380a:	ef 3b 00 0f 	ld.ub	r11,r7[15]
8000380e:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003812:	70 09       	ld.w	r9,r8[0x0]
80003814:	2f f9       	sub	r9,-1
80003816:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003818:	e0 49 01 ff 	cp.w	r9,511
8000381c:	e0 88 00 16 	brls	80003848 <phy_rx_func+0x988>
							{
								RxAMBE_IsFillingNext8 = 0;
80003820:	30 09       	mov	r9,0
80003822:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003824:	fe f7 05 54 	ld.w	r7,pc[1364]
80003828:	6e 0c       	ld.w	r12,r7[0x0]
8000382a:	f0 1f 01 5f 	mcall	80003da4 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
8000382e:	fe f8 05 42 	ld.w	r8,pc[1346]
80003832:	70 0c       	ld.w	r12,r8[0x0]
80003834:	f0 1f 01 49 	mcall	80003d58 <phy_rx_func+0xe98>
80003838:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == AMBE_payload_ptr)
8000383a:	c0 71       	brne	80003848 <phy_rx_func+0x988>
								{
									RxMediaState = WAITINGABAB;
8000383c:	30 09       	mov	r9,0
8000383e:	fe f8 05 3e 	ld.w	r8,pc[1342]
80003842:	91 09       	st.w	r8[0x0],r9
80003844:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003848:	fe f9 05 3c 	ld.w	r9,pc[1340]
8000384c:	72 08       	ld.w	r8,r9[0x0]
8000384e:	20 18       	sub	r8,1
80003850:	93 08       	st.w	r9[0x0],r8
80003852:	e0 81 02 74 	brne	80003d3a <phy_rx_func+0xe7a>
								RxMediaState = WAITINGABAB;
80003856:	30 09       	mov	r9,0
80003858:	fe f8 05 24 	ld.w	r8,pc[1316]
8000385c:	91 09       	st.w	r8[0x0],r9
8000385e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							//}
							
						}
						else//error
						{
							RxMediaState = WAITINGABAB;
80003862:	30 09       	mov	r9,0
80003864:	fe f8 05 18 	ld.w	r8,pc[1304]
80003868:	91 09       	st.w	r8[0x0],r9
8000386a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
					}
					else if (Item_ID == Post_Voice_Encoder_Data)//(bit48~Pad-bits)
8000386e:	fe f8 05 26 	ld.w	r8,pc[1318]
80003872:	11 89       	ld.ub	r9,r8[0x0]
80003874:	3f 28       	mov	r8,-14
80003876:	f0 09 18 00 	cp.b	r9,r8
8000387a:	c4 31       	brne	80003900 <phy_rx_func+0xa40>
					{
					
						AMBEBurst_rawdata[3] = payload_rx_channel->word[0];//(bit48~Pad-bits)
8000387c:	8e 49       	ld.sh	r9,r7[0x8]
8000387e:	fe f8 05 56 	ld.w	r8,pc[1366]
80003882:	b0 39       	st.h	r8[0x6],r9
						//AMBE_Per_Burst_Flag = 1;
						
						//根据MOTO.bit文件数据分布，建议测试pad-bits的最后一个字节不保存。
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//7
80003884:	fe f8 05 18 	ld.w	r8,pc[1304]
80003888:	fe f9 04 f0 	ld.w	r9,pc[1264]
8000388c:	72 0a       	ld.w	r10,r9[0x0]
8000388e:	70 09       	ld.w	r9,r8[0x0]
80003890:	ef 3b 00 08 	ld.ub	r11,r7[8]
80003894:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003898:	70 09       	ld.w	r9,r8[0x0]
8000389a:	2f f9       	sub	r9,-1
8000389c:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000389e:	e0 49 01 ff 	cp.w	r9,511
800038a2:	e0 88 00 16 	brls	800038ce <phy_rx_func+0xa0e>
						{
							RxAMBE_IsFillingNext8 = 0;
800038a6:	30 09       	mov	r9,0
800038a8:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
800038aa:	fe f7 04 ce 	ld.w	r7,pc[1230]
800038ae:	6e 0c       	ld.w	r12,r7[0x0]
800038b0:	f0 1f 01 3d 	mcall	80003da4 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
800038b4:	fe f8 04 bc 	ld.w	r8,pc[1212]
800038b8:	70 0c       	ld.w	r12,r8[0x0]
800038ba:	f0 1f 01 28 	mcall	80003d58 <phy_rx_func+0xe98>
800038be:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
800038c0:	c0 71       	brne	800038ce <phy_rx_func+0xa0e>
							{
								RxMediaState = WAITINGABAB;
800038c2:	30 09       	mov	r9,0
800038c4:	fe f8 04 b8 	ld.w	r8,pc[1208]
800038c8:	91 09       	st.w	r8[0x0],r9
800038ca:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
800038ce:	fe f9 04 b6 	ld.w	r9,pc[1206]
800038d2:	72 08       	ld.w	r8,r9[0x0]
800038d4:	20 18       	sub	r8,1
800038d6:	93 08       	st.w	r9[0x0],r8
800038d8:	c0 71       	brne	800038e6 <phy_rx_func+0xa26>
							RxMediaState = WAITINGABAB;
800038da:	30 09       	mov	r9,0
800038dc:	fe f8 04 a0 	ld.w	r8,pc[1184]
800038e0:	91 09       	st.w	r8[0x0],r9
800038e2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
						if ((RxBytesWaiting -= 1) <= 0){//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
800038e6:	20 18       	sub	r8,1
800038e8:	fe f9 04 9c 	ld.w	r9,pc[1180]
800038ec:	93 08       	st.w	r9[0x0],r8
800038ee:	58 08       	cp.w	r8,0
800038f0:	e0 81 02 25 	brne	80003d3a <phy_rx_func+0xe7a>
							RxMediaState = WAITINGABAB;
800038f4:	30 09       	mov	r9,0
800038f6:	fe f8 04 86 	ld.w	r8,pc[1158]
800038fa:	91 09       	st.w	r8[0x0],r9
800038fc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
								
					}
					else if (Item_ID == Pre_Voice_Decoder_Data)//bit16~bit63
80003900:	fe f8 04 94 	ld.w	r8,pc[1172]
80003904:	11 89       	ld.ub	r9,r8[0x0]
80003906:	3f 38       	mov	r8,-13
80003908:	f0 09 18 00 	cp.b	r9,r8
8000390c:	e0 81 01 0c 	brne	80003b24 <phy_rx_func+0xc64>
					{
						//接收方的解压类型数据
						//For looping back to Radio
						AMBEBurst_rawdata[1] = payload_rx_channel->word[0];
80003910:	8e 49       	ld.sh	r9,r7[0x8]
80003912:	fe f8 04 c2 	ld.w	r8,pc[1218]
80003916:	b0 19       	st.h	r8[0x2],r9
						AMBEBurst_rawdata[2] = payload_rx_channel->word[1];
80003918:	8e 59       	ld.sh	r9,r7[0xa]
8000391a:	b0 29       	st.h	r8[0x4],r9
						AMBEBurst_rawdata[3] = payload_rx_channel->word[2];
8000391c:	8e 69       	ld.sh	r9,r7[0xc]
8000391e:	b0 39       	st.h	r8[0x6],r9
						//if((m_RxBurstType == VOICEBURST_A) && (VF_SN == 1))
						//logFromISR("\n\r Pre_rx:%X\n\r", payload_rx_channel->word[2]);
						
						//To be tested. Also locally stored RAW-AMBER-DATA
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//3
80003920:	fe f8 04 7c 	ld.w	r8,pc[1148]
80003924:	fe f9 04 54 	ld.w	r9,pc[1108]
80003928:	72 0a       	ld.w	r10,r9[0x0]
8000392a:	70 09       	ld.w	r9,r8[0x0]
8000392c:	ef 3b 00 08 	ld.ub	r11,r7[8]
80003930:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003934:	70 09       	ld.w	r9,r8[0x0]
80003936:	2f f9       	sub	r9,-1
80003938:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000393a:	e0 49 01 ff 	cp.w	r9,511
8000393e:	e0 88 00 16 	brls	8000396a <phy_rx_func+0xaaa>
						{
							RxAMBE_IsFillingNext8 = 0;
80003942:	30 09       	mov	r9,0
80003944:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003946:	fe f6 04 32 	ld.w	r6,pc[1074]
8000394a:	6c 0c       	ld.w	r12,r6[0x0]
8000394c:	f0 1f 01 16 	mcall	80003da4 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003950:	fe f8 04 20 	ld.w	r8,pc[1056]
80003954:	70 0c       	ld.w	r12,r8[0x0]
80003956:	f0 1f 01 01 	mcall	80003d58 <phy_rx_func+0xe98>
8000395a:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
8000395c:	c0 71       	brne	8000396a <phy_rx_func+0xaaa>
							{
								RxMediaState = WAITINGABAB;
8000395e:	30 09       	mov	r9,0
80003960:	fe f8 04 1c 	ld.w	r8,pc[1052]
80003964:	91 09       	st.w	r8[0x0],r9
80003966:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
8000396a:	fe f9 04 1a 	ld.w	r9,pc[1050]
8000396e:	72 08       	ld.w	r8,r9[0x0]
80003970:	20 18       	sub	r8,1
80003972:	93 08       	st.w	r9[0x0],r8
80003974:	c0 71       	brne	80003982 <phy_rx_func+0xac2>
							RxMediaState = WAITINGABAB;
80003976:	30 09       	mov	r9,0
80003978:	fe f8 04 04 	ld.w	r8,pc[1028]
8000397c:	91 09       	st.w	r8[0x0],r9
8000397e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[1];//4
80003982:	fe f8 04 1a 	ld.w	r8,pc[1050]
80003986:	fe f9 03 f2 	ld.w	r9,pc[1010]
8000398a:	72 0a       	ld.w	r10,r9[0x0]
8000398c:	70 09       	ld.w	r9,r8[0x0]
8000398e:	ef 3b 00 09 	ld.ub	r11,r7[9]
80003992:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003996:	70 09       	ld.w	r9,r8[0x0]
80003998:	2f f9       	sub	r9,-1
8000399a:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000399c:	e0 49 01 ff 	cp.w	r9,511
800039a0:	e0 88 00 16 	brls	800039cc <phy_rx_func+0xb0c>
						{
							RxAMBE_IsFillingNext8 = 0;
800039a4:	30 09       	mov	r9,0
800039a6:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
800039a8:	fe f6 03 d0 	ld.w	r6,pc[976]
800039ac:	6c 0c       	ld.w	r12,r6[0x0]
800039ae:	f0 1f 00 fe 	mcall	80003da4 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
800039b2:	fe f8 03 be 	ld.w	r8,pc[958]
800039b6:	70 0c       	ld.w	r12,r8[0x0]
800039b8:	f0 1f 00 e8 	mcall	80003d58 <phy_rx_func+0xe98>
800039bc:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
800039be:	c0 71       	brne	800039cc <phy_rx_func+0xb0c>
							{
								RxMediaState = WAITINGABAB;
800039c0:	30 09       	mov	r9,0
800039c2:	fe f8 03 ba 	ld.w	r8,pc[954]
800039c6:	91 09       	st.w	r8[0x0],r9
800039c8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
800039cc:	fe f9 03 b8 	ld.w	r9,pc[952]
800039d0:	72 08       	ld.w	r8,r9[0x0]
800039d2:	20 18       	sub	r8,1
800039d4:	93 08       	st.w	r9[0x0],r8
800039d6:	c0 71       	brne	800039e4 <phy_rx_func+0xb24>
							RxMediaState = WAITINGABAB;
800039d8:	30 09       	mov	r9,0
800039da:	fe f8 03 a2 	ld.w	r8,pc[930]
800039de:	91 09       	st.w	r8[0x0],r9
800039e0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//5
800039e4:	fe f8 03 b8 	ld.w	r8,pc[952]
800039e8:	fe f9 03 90 	ld.w	r9,pc[912]
800039ec:	72 0a       	ld.w	r10,r9[0x0]
800039ee:	70 09       	ld.w	r9,r8[0x0]
800039f0:	ef 3b 00 0a 	ld.ub	r11,r7[10]
800039f4:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
800039f8:	70 09       	ld.w	r9,r8[0x0]
800039fa:	2f f9       	sub	r9,-1
800039fc:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800039fe:	e0 49 01 ff 	cp.w	r9,511
80003a02:	e0 88 00 16 	brls	80003a2e <phy_rx_func+0xb6e>
						{
							RxAMBE_IsFillingNext8 = 0;
80003a06:	30 09       	mov	r9,0
80003a08:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003a0a:	fe f6 03 6e 	ld.w	r6,pc[878]
80003a0e:	6c 0c       	ld.w	r12,r6[0x0]
80003a10:	f0 1f 00 e5 	mcall	80003da4 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003a14:	fe f8 03 5c 	ld.w	r8,pc[860]
80003a18:	70 0c       	ld.w	r12,r8[0x0]
80003a1a:	f0 1f 00 d0 	mcall	80003d58 <phy_rx_func+0xe98>
80003a1e:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003a20:	c0 71       	brne	80003a2e <phy_rx_func+0xb6e>
							{
								RxMediaState = WAITINGABAB;
80003a22:	30 09       	mov	r9,0
80003a24:	fe f8 03 58 	ld.w	r8,pc[856]
80003a28:	91 09       	st.w	r8[0x0],r9
80003a2a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003a2e:	fe f9 03 56 	ld.w	r9,pc[854]
80003a32:	72 08       	ld.w	r8,r9[0x0]
80003a34:	20 18       	sub	r8,1
80003a36:	93 08       	st.w	r9[0x0],r8
80003a38:	c0 71       	brne	80003a46 <phy_rx_func+0xb86>
							RxMediaState = WAITINGABAB;
80003a3a:	30 09       	mov	r9,0
80003a3c:	fe f8 03 40 	ld.w	r8,pc[832]
80003a40:	91 09       	st.w	r8[0x0],r9
80003a42:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//6
80003a46:	fe f8 03 56 	ld.w	r8,pc[854]
80003a4a:	fe f9 03 2e 	ld.w	r9,pc[814]
80003a4e:	72 0a       	ld.w	r10,r9[0x0]
80003a50:	70 09       	ld.w	r9,r8[0x0]
80003a52:	ef 3b 00 0b 	ld.ub	r11,r7[11]
80003a56:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003a5a:	70 09       	ld.w	r9,r8[0x0]
80003a5c:	2f f9       	sub	r9,-1
80003a5e:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003a60:	e0 49 01 ff 	cp.w	r9,511
80003a64:	e0 88 00 16 	brls	80003a90 <phy_rx_func+0xbd0>
						{
							RxAMBE_IsFillingNext8 = 0;
80003a68:	30 09       	mov	r9,0
80003a6a:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003a6c:	fe f6 03 0c 	ld.w	r6,pc[780]
80003a70:	6c 0c       	ld.w	r12,r6[0x0]
80003a72:	f0 1f 00 cd 	mcall	80003da4 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003a76:	fe f8 02 fa 	ld.w	r8,pc[762]
80003a7a:	70 0c       	ld.w	r12,r8[0x0]
80003a7c:	f0 1f 00 b7 	mcall	80003d58 <phy_rx_func+0xe98>
80003a80:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003a82:	c0 71       	brne	80003a90 <phy_rx_func+0xbd0>
							{
								RxMediaState = WAITINGABAB;
80003a84:	30 09       	mov	r9,0
80003a86:	fe f8 02 f6 	ld.w	r8,pc[758]
80003a8a:	91 09       	st.w	r8[0x0],r9
80003a8c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003a90:	fe f9 02 f4 	ld.w	r9,pc[756]
80003a94:	72 08       	ld.w	r8,r9[0x0]
80003a96:	20 18       	sub	r8,1
80003a98:	93 08       	st.w	r9[0x0],r8
80003a9a:	c0 71       	brne	80003aa8 <phy_rx_func+0xbe8>
							RxMediaState = WAITINGABAB;
80003a9c:	30 09       	mov	r9,0
80003a9e:	fe f8 02 de 	ld.w	r8,pc[734]
80003aa2:	91 09       	st.w	r8[0x0],r9
80003aa4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//7
80003aa8:	fe f8 02 f4 	ld.w	r8,pc[756]
80003aac:	fe f9 02 cc 	ld.w	r9,pc[716]
80003ab0:	72 0a       	ld.w	r10,r9[0x0]
80003ab2:	70 09       	ld.w	r9,r8[0x0]
80003ab4:	ef 3b 00 0c 	ld.ub	r11,r7[12]
80003ab8:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003abc:	70 09       	ld.w	r9,r8[0x0]
80003abe:	2f f9       	sub	r9,-1
80003ac0:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003ac2:	e0 49 01 ff 	cp.w	r9,511
80003ac6:	e0 88 00 16 	brls	80003af2 <phy_rx_func+0xc32>
						{
							RxAMBE_IsFillingNext8 = 0;
80003aca:	30 09       	mov	r9,0
80003acc:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003ace:	fe f7 02 aa 	ld.w	r7,pc[682]
80003ad2:	6e 0c       	ld.w	r12,r7[0x0]
80003ad4:	f0 1f 00 b4 	mcall	80003da4 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003ad8:	fe f8 02 98 	ld.w	r8,pc[664]
80003adc:	70 0c       	ld.w	r12,r8[0x0]
80003ade:	f0 1f 00 9f 	mcall	80003d58 <phy_rx_func+0xe98>
80003ae2:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003ae4:	c0 71       	brne	80003af2 <phy_rx_func+0xc32>
							{
								RxMediaState = WAITINGABAB;
80003ae6:	30 09       	mov	r9,0
80003ae8:	fe f8 02 94 	ld.w	r8,pc[660]
80003aec:	91 09       	st.w	r8[0x0],r9
80003aee:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003af2:	fe f9 02 92 	ld.w	r9,pc[658]
80003af6:	72 08       	ld.w	r8,r9[0x0]
80003af8:	20 18       	sub	r8,1
80003afa:	93 08       	st.w	r9[0x0],r8
80003afc:	c0 71       	brne	80003b0a <phy_rx_func+0xc4a>
							RxMediaState = WAITINGABAB;
80003afe:	30 09       	mov	r9,0
80003b00:	fe f8 02 7c 	ld.w	r8,pc[636]
80003b04:	91 09       	st.w	r8[0x0],r9
80003b06:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
						if ((RxBytesWaiting -= 1) <= 0){
80003b0a:	20 18       	sub	r8,1
80003b0c:	fe f9 02 78 	ld.w	r9,pc[632]
80003b10:	93 08       	st.w	r9[0x0],r8
80003b12:	58 08       	cp.w	r8,0
80003b14:	e0 81 01 13 	brne	80003d3a <phy_rx_func+0xe7a>
							
							//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
							//or discard it to reduce payload size.
							
							RxMediaState = WAITINGABAB;
80003b18:	30 09       	mov	r9,0
80003b1a:	fe f8 02 62 	ld.w	r8,pc[610]
80003b1e:	91 09       	st.w	r8[0x0],r9
80003b20:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
					}
					else if ((Item_ID == 0x04)  ||  (Item_ID == 0x03))//Unknown type data directly back hair
80003b24:	fe f8 02 70 	ld.w	r8,pc[624]
80003b28:	11 89       	ld.ub	r9,r8[0x0]
80003b2a:	30 48       	mov	r8,4
80003b2c:	f0 09 18 00 	cp.b	r9,r8
80003b30:	c0 80       	breq	80003b40 <phy_rx_func+0xc80>
80003b32:	fe f8 02 62 	ld.w	r8,pc[610]
80003b36:	11 89       	ld.ub	r9,r8[0x0]
80003b38:	30 38       	mov	r8,3
80003b3a:	f0 09 18 00 	cp.b	r9,r8
80003b3e:	c1 41       	brne	80003b66 <phy_rx_func+0xca6>
					{
						AMBE_HT[0] = payload_rx_channel->dword[0];
80003b40:	6e 29       	ld.w	r9,r7[0x8]
80003b42:	fe f8 02 7a 	ld.w	r8,pc[634]
80003b46:	91 09       	st.w	r8[0x0],r9
						AMBE_HT[1] = payload_rx_channel->dword[1];				
80003b48:	6e 39       	ld.w	r9,r7[0xc]
80003b4a:	91 19       	st.w	r8[0x4],r9
						
						if ((RxBytesWaiting -= 8) <= 0)//Consider two cases 0xABCDC014 and 0xABCDC010
80003b4c:	fe f9 02 38 	ld.w	r9,pc[568]
80003b50:	72 08       	ld.w	r8,r9[0x0]
80003b52:	20 88       	sub	r8,8
80003b54:	93 08       	st.w	r9[0x0],r8
80003b56:	e0 81 00 f2 	brne	80003d3a <phy_rx_func+0xe7a>
						{
					
							RxBytesWaiting = 0;
80003b5a:	93 08       	st.w	r9[0x0],r8
							RxMediaState = WAITINGABAB;
80003b5c:	fe f9 02 20 	ld.w	r9,pc[544]
80003b60:	93 08       	st.w	r9[0x0],r8
80003b62:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
						}
						break;

					}
					else if (Item_ID == Soft_Decision_Value)
80003b66:	fe f8 02 2e 	ld.w	r8,pc[558]
80003b6a:	11 89       	ld.ub	r9,r8[0x0]
80003b6c:	31 38       	mov	r8,19
80003b6e:	f0 09 18 00 	cp.b	r9,r8
80003b72:	e0 81 00 9c 	brne	80003caa <phy_rx_func+0xdea>
					{							
						if (SDV_Index == 12)
80003b76:	fe f8 02 62 	ld.w	r8,pc[610]
80003b7a:	11 88       	ld.ub	r8,r8[0x0]
80003b7c:	30 c9       	mov	r9,12
80003b7e:	f2 08 18 00 	cp.b	r8,r9
80003b82:	e0 81 00 7b 	brne	80003c78 <phy_rx_func+0xdb8>
						{
							Soft_Decision_Data[SDV_Index]= payload_rx_channel->word[0];
80003b86:	8e 49       	ld.sh	r9,r7[0x8]
80003b88:	fe f8 02 54 	ld.w	r8,pc[596]
80003b8c:	f1 59 00 18 	st.h	r8[24],r9
							
							SDV_Index = 0;
80003b90:	30 09       	mov	r9,0
80003b92:	fe f8 02 46 	ld.w	r8,pc[582]
80003b96:	b0 89       	st.b	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003b98:	ef 39 00 0d 	ld.ub	r9,r7[13]
80003b9c:	3f 38       	mov	r8,-13
80003b9e:	f0 09 18 00 	cp.b	r9,r8
80003ba2:	c6 61       	brne	80003c6e <phy_rx_func+0xdae>
							
							SDV_Index = 0;
								
							if (payload_rx_channel->byte[5] == Pre_Voice_Decoder_Data )//0xF3
							{
									Item_ID = Pre_Voice_Decoder_Data;
80003ba4:	10 99       	mov	r9,r8
80003ba6:	4f c8       	lddpc	r8,80003d94 <phy_rx_func+0xed4>
80003ba8:	b0 89       	st.b	r8[0x0],r9
									RxBytesWaiting = (payload_rx_channel->byte[4] & 0x7F);//Test calculations are correct; 8
80003baa:	ef 39 00 0c 	ld.ub	r9,r7[12]
80003bae:	f3 d9 c0 07 	bfextu	r9,r9,0x0,0x7
80003bb2:	4f 58       	lddpc	r8,80003d84 <phy_rx_func+0xec4>
80003bb4:	91 09       	st.w	r8[0x0],r9
									AMBE_rx_flag = 1;//本地作为AMBE数据的解密方
80003bb6:	30 19       	mov	r9,1
80003bb8:	fe f8 02 0c 	ld.w	r8,pc[524]
80003bbc:	b0 89       	st.b	r8[0x0],r9
		
									AMBEBurst_rawdata[0] = payload_rx_channel->word[3];//用于解密的中间数据变量
80003bbe:	8e 79       	ld.sh	r9,r7[0xe]
80003bc0:	fe f8 02 14 	ld.w	r8,pc[532]
80003bc4:	b0 09       	st.h	r8[0x0],r9
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//1
80003bc6:	4f 68       	lddpc	r8,80003d9c <phy_rx_func+0xedc>
80003bc8:	4e c9       	lddpc	r9,80003d78 <phy_rx_func+0xeb8>
80003bca:	72 0a       	ld.w	r10,r9[0x0]
80003bcc:	70 09       	ld.w	r9,r8[0x0]
80003bce:	ef 3b 00 0e 	ld.ub	r11,r7[14]
80003bd2:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
80003bd6:	70 09       	ld.w	r9,r8[0x0]
80003bd8:	2f f9       	sub	r9,-1
80003bda:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003bdc:	e0 49 01 ff 	cp.w	r9,511
80003be0:	e0 88 00 13 	brls	80003c06 <phy_rx_func+0xd46>
									{
										RxAMBE_IsFillingNext8 = 0;
80003be4:	30 09       	mov	r9,0
80003be6:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
80003be8:	4e 46       	lddpc	r6,80003d78 <phy_rx_func+0xeb8>
80003bea:	6c 0c       	ld.w	r12,r6[0x0]
80003bec:	f0 1f 00 6e 	mcall	80003da4 <phy_rx_func+0xee4>
										AMBE_payload_ptr = get_payload_idle_isr();
80003bf0:	4e 08       	lddpc	r8,80003d70 <phy_rx_func+0xeb0>
80003bf2:	70 0c       	ld.w	r12,r8[0x0]
80003bf4:	f0 1f 00 59 	mcall	80003d58 <phy_rx_func+0xe98>
80003bf8:	8d 0c       	st.w	r6[0x0],r12
										if(NULL == AMBE_payload_ptr)
80003bfa:	c0 61       	brne	80003c06 <phy_rx_func+0xd46>
										{
											RxMediaState = WAITINGABAB;
80003bfc:	30 09       	mov	r9,0
80003bfe:	4e 08       	lddpc	r8,80003d7c <phy_rx_func+0xebc>
80003c00:	91 09       	st.w	r8[0x0],r9
80003c02:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
80003c06:	4e 09       	lddpc	r9,80003d84 <phy_rx_func+0xec4>
80003c08:	72 08       	ld.w	r8,r9[0x0]
80003c0a:	20 18       	sub	r8,1
80003c0c:	93 08       	st.w	r9[0x0],r8
80003c0e:	c0 61       	brne	80003c1a <phy_rx_func+0xd5a>
										RxMediaState = WAITINGABAB;
80003c10:	30 09       	mov	r9,0
80003c12:	4d b8       	lddpc	r8,80003d7c <phy_rx_func+0xebc>
80003c14:	91 09       	st.w	r8[0x0],r9
80003c16:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//2
80003c1a:	4e 18       	lddpc	r8,80003d9c <phy_rx_func+0xedc>
80003c1c:	4d 79       	lddpc	r9,80003d78 <phy_rx_func+0xeb8>
80003c1e:	72 0a       	ld.w	r10,r9[0x0]
80003c20:	70 09       	ld.w	r9,r8[0x0]
80003c22:	ef 3b 00 0f 	ld.ub	r11,r7[15]
80003c26:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
80003c2a:	70 09       	ld.w	r9,r8[0x0]
80003c2c:	2f f9       	sub	r9,-1
80003c2e:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003c30:	e0 49 01 ff 	cp.w	r9,511
80003c34:	e0 88 00 13 	brls	80003c5a <phy_rx_func+0xd9a>
									{
										RxAMBE_IsFillingNext8 = 0;
80003c38:	30 09       	mov	r9,0
80003c3a:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
80003c3c:	4c f7       	lddpc	r7,80003d78 <phy_rx_func+0xeb8>
80003c3e:	6e 0c       	ld.w	r12,r7[0x0]
80003c40:	f0 1f 00 59 	mcall	80003da4 <phy_rx_func+0xee4>
										AMBE_payload_ptr = get_payload_idle_isr();
80003c44:	4c b8       	lddpc	r8,80003d70 <phy_rx_func+0xeb0>
80003c46:	70 0c       	ld.w	r12,r8[0x0]
80003c48:	f0 1f 00 44 	mcall	80003d58 <phy_rx_func+0xe98>
80003c4c:	8f 0c       	st.w	r7[0x0],r12
										if(NULL == AMBE_payload_ptr)
80003c4e:	c0 61       	brne	80003c5a <phy_rx_func+0xd9a>
										{
											RxMediaState = WAITINGABAB;
80003c50:	30 09       	mov	r9,0
80003c52:	4c b8       	lddpc	r8,80003d7c <phy_rx_func+0xebc>
80003c54:	91 09       	st.w	r8[0x0],r9
80003c56:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
80003c5a:	4c b9       	lddpc	r9,80003d84 <phy_rx_func+0xec4>
80003c5c:	72 08       	ld.w	r8,r9[0x0]
80003c5e:	20 18       	sub	r8,1
80003c60:	93 08       	st.w	r9[0x0],r8
80003c62:	c6 c1       	brne	80003d3a <phy_rx_func+0xe7a>
										RxMediaState = WAITINGABAB;
80003c64:	30 09       	mov	r9,0
80003c66:	4c 68       	lddpc	r8,80003d7c <phy_rx_func+0xebc>
80003c68:	91 09       	st.w	r8[0x0],r9
80003c6a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
							}
							else
							RxMediaState = WAITINGABAB;
80003c6e:	30 09       	mov	r9,0
80003c70:	4c 38       	lddpc	r8,80003d7c <phy_rx_func+0xebc>
80003c72:	91 09       	st.w	r8[0x0],r9
80003c74:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
						}
						else
						{
									
							Soft_Decision_Data[SDV_Index]	  = payload_rx_channel->word[0];
80003c78:	8e 4a       	ld.sh	r10,r7[0x8]
80003c7a:	4d 99       	lddpc	r9,80003ddc <phy_rx_func+0xf1c>
80003c7c:	f2 08 0a 1a 	st.h	r9[r8<<0x1],r10
							Soft_Decision_Data[SDV_Index+1]	  = payload_rx_channel->word[1];
80003c80:	4d 6a       	lddpc	r10,80003dd8 <phy_rx_func+0xf18>
80003c82:	15 88       	ld.ub	r8,r10[0x0]
80003c84:	f0 cb ff ff 	sub	r11,r8,-1
80003c88:	8e 5c       	ld.sh	r12,r7[0xa]
80003c8a:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+2]	  = payload_rx_channel->word[2];
80003c8e:	f0 cb ff fe 	sub	r11,r8,-2
80003c92:	8e 6c       	ld.sh	r12,r7[0xc]
80003c94:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+3]	  = payload_rx_channel->word[3];
80003c98:	f0 cb ff fd 	sub	r11,r8,-3
80003c9c:	8e 7c       	ld.sh	r12,r7[0xe]
80003c9e:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							SDV_Index +=4;
80003ca2:	2f c8       	sub	r8,-4
80003ca4:	b4 88       	st.b	r10[0x0],r8
80003ca6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					
					else
					{
						
						RxMediaState  = WAITINGABAB;
80003caa:	30 09       	mov	r9,0
80003cac:	4b 48       	lddpc	r8,80003d7c <phy_rx_func+0xebc>
80003cae:	91 09       	st.w	r8[0x0],r9
80003cb0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
		break;//End of READING_AMBE_MEDIA.

        case READING_AMBE_AUX:
			
				Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[0];
80003cb4:	4c 08       	lddpc	r8,80003db4 <phy_rx_func+0xef4>
80003cb6:	70 09       	ld.w	r9,r8[0x0]
80003cb8:	8e 4b       	ld.sh	r11,r7[0x8]
80003cba:	4c 0a       	lddpc	r10,80003db8 <phy_rx_func+0xef8>
80003cbc:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
				RxData_IsFillingNext16 += 1;
80003cc0:	2f f9       	sub	r9,-1
80003cc2:	91 09       	st.w	r8[0x0],r9
			
				if ((Item_Length -= 2) <= 0)
80003cc4:	4b 58       	lddpc	r8,80003d98 <phy_rx_func+0xed8>
80003cc6:	70 09       	ld.w	r9,r8[0x0]
80003cc8:	20 29       	sub	r9,2
80003cca:	91 09       	st.w	r8[0x0],r9
80003ccc:	70 08       	ld.w	r8,r8[0x0]
80003cce:	58 08       	cp.w	r8,0
80003cd0:	c2 f1       	brne	80003d2e <phy_rx_func+0xe6e>
				{
					RxData_IsFillingNext16 = 0;
80003cd2:	30 09       	mov	r9,0
80003cd4:	4b 88       	lddpc	r8,80003db4 <phy_rx_func+0xef4>
80003cd6:	91 09       	st.w	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003cd8:	8e 59       	ld.sh	r9,r7[0xa]
80003cda:	fe 78 82 12 	mov	r8,-32238
80003cde:	f0 09 19 00 	cp.h	r9,r8
80003ce2:	c2 11       	brne	80003d24 <phy_rx_func+0xe64>
					{
						//Item_ID = Vocoder_Bit_Stream_Parameter;
						//Vocoder Bits Stream Parameter
						//Its value ranges from 1 to 18 for one voice superframe contains 6 voice bursts
						// and each burst contains 3 VFs.
						VF_SN = (payload_rx_channel->byte[5] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
80003ce4:	ef 3c 00 0d 	ld.ub	r12,r7[13]
80003ce8:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
80003cec:	4a f8       	lddpc	r8,80003da8 <phy_rx_func+0xee8>
80003cee:	b0 8c       	st.b	r8[0x0],r12
							
						VBSP_data[0] = payload_rx_channel->word[1];
80003cf0:	8e 59       	ld.sh	r9,r7[0xa]
80003cf2:	4a f8       	lddpc	r8,80003dac <phy_rx_func+0xeec>
80003cf4:	b0 09       	st.h	r8[0x0],r9
						VBSP_data[1] = payload_rx_channel->word[2];
80003cf6:	8e 69       	ld.sh	r9,r7[0xc]
80003cf8:	b0 19       	st.h	r8[0x2],r9
							
						m_RxBurstType = CalculateBurst(VF_SN);
80003cfa:	f0 1f 00 2e 	mcall	80003db0 <phy_rx_func+0xef0>
80003cfe:	4a 18       	lddpc	r8,80003d80 <phy_rx_func+0xec0>
80003d00:	91 0c       	st.w	r8[0x0],r12
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003d02:	ef 39 00 0f 	ld.ub	r9,r7[15]
80003d06:	31 38       	mov	r8,19
80003d08:	f0 09 18 00 	cp.b	r9,r8
80003d0c:	c0 71       	brne	80003d1a <phy_rx_func+0xe5a>
							
						m_RxBurstType = CalculateBurst(VF_SN);
						
						if (payload_rx_channel->byte[7] == Soft_Decision_Value)//0x13
						{
							Item_ID = Soft_Decision_Value;	
80003d0e:	10 99       	mov	r9,r8
80003d10:	4a 18       	lddpc	r8,80003d94 <phy_rx_func+0xed4>
80003d12:	b0 89       	st.b	r8[0x0],r9
							RxBytesWaiting = ((payload_rx_channel->dword[1] & 0x00007F00) >>24);//Test calculations are correct; 26
80003d14:	30 09       	mov	r9,0
80003d16:	49 c8       	lddpc	r8,80003d84 <phy_rx_func+0xec4>
80003d18:	91 09       	st.w	r8[0x0],r9
						else
						{//error
								RxMediaState = WAITINGABAB;//Jump
						}
							
						RxMediaState = READING_AMBE_MEDIA;//Jump
80003d1a:	30 49       	mov	r9,4
80003d1c:	49 88       	lddpc	r8,80003d7c <phy_rx_func+0xebc>
80003d1e:	91 09       	st.w	r8[0x0],r9
80003d20:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					else
					{
						RxMediaState = WAITINGABAB;//Jump
80003d24:	30 09       	mov	r9,0
80003d26:	49 68       	lddpc	r8,80003d7c <phy_rx_func+0xebc>
80003d28:	91 09       	st.w	r8[0x0],r9
80003d2a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}

				}
				else
				{//测试看看是几个字节数据
					logFromISR("\n\r Radio Internal parameter length error \n\r");
80003d2e:	4a dc       	lddpc	r12,80003de0 <phy_rx_func+0xf20>
80003d30:	f0 1f 00 18 	mcall	80003d90 <phy_rx_func+0xed0>
					RxMediaState = WAITINGABAB;//Jump
80003d34:	30 09       	mov	r9,0
80003d36:	49 28       	lddpc	r8,80003d7c <phy_rx_func+0xebc>
80003d38:	91 09       	st.w	r8[0x0],r9
80003d3a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80003d3e:	00 00       	add	r0,r0
80003d40:	00 00       	add	r0,r0
80003d42:	0a b4       	st.h	r5++,r4
80003d44:	00 00       	add	r0,r0
80003d46:	0a cc       	st.b	r5++,r12
80003d48:	00 00       	add	r0,r0
80003d4a:	0a ac       	st.w	r5++,r12
80003d4c:	00 00       	add	r0,r0
80003d4e:	0a 8e       	andn	lr,r5
80003d50:	00 00       	add	r0,r0
80003d52:	0a 7c       	tst	r12,r5
80003d54:	00 00       	add	r0,r0
80003d56:	0a a4       	st.w	r5++,r4
80003d58:	80 00       	ld.sh	r0,r0[0x0]
80003d5a:	2d 48       	sub	r8,-44
80003d5c:	00 00       	add	r0,r0
80003d5e:	0a 9c       	mov	r12,r5
80003d60:	80 00       	ld.sh	r0,r0[0x0]
80003d62:	2c 60       	sub	r0,-58
80003d64:	00 00       	add	r0,r0
80003d66:	0a b0       	st.h	r5++,r0
80003d68:	80 00       	ld.sh	r0,r0[0x0]
80003d6a:	2c 94       	sub	r4,-55
80003d6c:	00 00       	add	r0,r0
80003d6e:	0a 8d       	andn	sp,r5
80003d70:	00 00       	add	r0,r0
80003d72:	0a a8       	st.w	r5++,r8
80003d74:	00 00       	add	r0,r0
80003d76:	0a b8       	st.h	r5++,r8
80003d78:	00 00       	add	r0,r0
80003d7a:	0a 90       	mov	r0,r5
80003d7c:	00 00       	add	r0,r0
80003d7e:	0a d8       	st.w	--r5,r8
80003d80:	00 00       	add	r0,r0
80003d82:	0a c0       	st.b	r5++,r0
80003d84:	00 00       	add	r0,r0
80003d86:	0a 78       	tst	r8,r5
80003d88:	00 00       	add	r0,r0
80003d8a:	0a 54       	eor	r4,r5
80003d8c:	80 00       	ld.sh	r0,r0[0x0]
80003d8e:	d8 24       	*unknown*
80003d90:	80 00       	ld.sh	r0,r0[0x0]
80003d92:	71 ec       	ld.w	r12,r8[0x78]
80003d94:	00 00       	add	r0,r0
80003d96:	0a 8c       	andn	r12,r5
80003d98:	00 00       	add	r0,r0
80003d9a:	0a e4       	st.h	--r5,r4
80003d9c:	00 00       	add	r0,r0
80003d9e:	0a c4       	st.b	r5++,r4
80003da0:	80 00       	ld.sh	r0,r0[0x0]
80003da2:	7a 24       	ld.w	r4,sp[0x8]
80003da4:	80 00       	ld.sh	r0,r0[0x0]
80003da6:	2c 7c       	sub	r12,-57
80003da8:	00 00       	add	r0,r0
80003daa:	0a 5e       	eor	lr,r5
80003dac:	00 00       	add	r0,r0
80003dae:	1e b0       	st.h	pc++,r0
80003db0:	80 00       	ld.sh	r0,r0[0x0]
80003db2:	2c 30       	sub	r0,-61
80003db4:	00 00       	add	r0,r0
80003db6:	0a 80       	andn	r0,r5
80003db8:	00 00       	add	r0,r0
80003dba:	1d b4       	ld.ub	r4,lr[0x3]
80003dbc:	00 00       	add	r0,r0
80003dbe:	0a 84       	andn	r4,r5
80003dc0:	00 00       	add	r0,r0
80003dc2:	0a 4c       	or	r12,r5
80003dc4:	00 00       	add	r0,r0
80003dc6:	0a 42       	or	r2,r5
80003dc8:	00 00       	add	r0,r0
80003dca:	0a dc       	st.w	--r5,r12
80003dcc:	00 00       	add	r0,r0
80003dce:	0a 98       	mov	r8,r5
80003dd0:	00 00       	add	r0,r0
80003dd2:	0a 64       	and	r4,r5
80003dd4:	00 00       	add	r0,r0
80003dd6:	1d ac       	ld.ub	r12,lr[0x2]
80003dd8:	00 00       	add	r0,r0
80003dda:	0a d0       	st.w	--r5,r0
80003ddc:	00 00       	add	r0,r0
80003dde:	1e b4       	st.h	pc++,r4
80003de0:	80 00       	ld.sh	r0,r0[0x0]
80003de2:	d8 3c       	*unknown*

80003de4 <pdca_int_handler>:
    void (*phy_rx_exec)(void *)--callback function for receive SSC data 
Called By: interrupt
*/
__attribute__((__interrupt__))
static void pdca_int_handler(void)
{
80003de4:	d4 01       	pushm	lr
	//xHigherPriorityTaskWoken = pdFALSE;
	
	static U32 count=0;
	//intStartCount = Get_system_register(AVR32_COUNT);
	
	count++;
80003de6:	49 a8       	lddpc	r8,80003e4c <pdca_int_handler+0x68>
80003de8:	70 09       	ld.w	r9,r8[0x0]
80003dea:	2f f9       	sub	r9,-1
80003dec:	91 09       	st.w	r8[0x0],r9
	/*Toggle Index*/
    BufferIndex ^= 0x01;
80003dee:	49 98       	lddpc	r8,80003e50 <pdca_int_handler+0x6c>
80003df0:	11 89       	ld.ub	r9,r8[0x0]
80003df2:	ec 19 00 01 	eorl	r9,0x1
80003df6:	b0 89       	st.b	r8[0x0],r9
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);
80003df8:	11 89       	ld.ub	r9,r8[0x0]
80003dfa:	a5 69       	lsl	r9,0x4
80003dfc:	2f c9       	sub	r9,-4
80003dfe:	49 6a       	lddpc	r10,80003e54 <pdca_int_handler+0x70>
80003e00:	14 09       	add	r9,r10
	count++;
	/*Toggle Index*/
    BufferIndex ^= 0x01;
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
80003e02:	fe 7a 00 40 	mov	r10,-65472
80003e06:	95 39       	st.w	r10[0xc],r9
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80003e08:	30 39       	mov	r9,3
80003e0a:	95 49       	st.w	r10[0x10],r9

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);
80003e0c:	11 8a       	ld.ub	r10,r8[0x0]
80003e0e:	a5 6a       	lsl	r10,0x4
80003e10:	2f ca       	sub	r10,-4
80003e12:	49 28       	lddpc	r8,80003e58 <pdca_int_handler+0x74>
80003e14:	10 0a       	add	r10,r8
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
80003e16:	fe 78 00 00 	mov	r8,-65536
80003e1a:	91 3a       	st.w	r8[0xc],r10
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80003e1c:	91 49       	st.w	r8[0x10],r9
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr;
80003e1e:	70 b8       	ld.w	r8,r8[0x2c]
	
	/*receive SSC data*/
    if(phy_rx_exec != NULL)phy_rx_exec((void *)&RxBuffer[BufferIndex]);
80003e20:	48 f8       	lddpc	r8,80003e5c <pdca_int_handler+0x78>
80003e22:	70 08       	ld.w	r8,r8[0x0]
80003e24:	58 08       	cp.w	r8,0
80003e26:	c0 70       	breq	80003e34 <pdca_int_handler+0x50>
80003e28:	48 a9       	lddpc	r9,80003e50 <pdca_int_handler+0x6c>
80003e2a:	13 89       	ld.ub	r9,r9[0x0]
80003e2c:	a5 69       	lsl	r9,0x4
80003e2e:	48 bc       	lddpc	r12,80003e58 <pdca_int_handler+0x74>
80003e30:	12 0c       	add	r12,r9
80003e32:	5d 18       	icall	r8

    /*transmit SSC data*/

	if(phy_tx_exec != NULL)phy_tx_exec((void *)&TxBuffer[BufferIndex]);//phy_tx_func, phy_rx_func
80003e34:	48 b8       	lddpc	r8,80003e60 <pdca_int_handler+0x7c>
80003e36:	70 08       	ld.w	r8,r8[0x0]
80003e38:	58 08       	cp.w	r8,0
80003e3a:	c0 70       	breq	80003e48 <pdca_int_handler+0x64>
80003e3c:	48 59       	lddpc	r9,80003e50 <pdca_int_handler+0x6c>
80003e3e:	13 89       	ld.ub	r9,r9[0x0]
80003e40:	a5 69       	lsl	r9,0x4
80003e42:	48 5c       	lddpc	r12,80003e54 <pdca_int_handler+0x70>
80003e44:	12 0c       	add	r12,r9
80003e46:	5d 18       	icall	r8

	
	//intDuration = Get_system_register(AVR32_COUNT) - intStartCount;
	
	
}/*End of pdca_int_handler.*/
80003e48:	d4 02       	popm	lr
80003e4a:	d6 03       	rete
80003e4c:	00 00       	add	r0,r0
80003e4e:	0a ec       	st.h	--r5,r12
80003e50:	00 00       	add	r0,r0
80003e52:	96 d4       	ld.uh	r4,r11[0xa]
80003e54:	00 00       	add	r0,r0
80003e56:	96 fc       	ld.uh	r12,r11[0xe]
80003e58:	00 00       	add	r0,r0
80003e5a:	96 dc       	ld.uh	r12,r11[0xa]
80003e5c:	00 00       	add	r0,r0
80003e5e:	0a e8       	st.h	--r5,r8
80003e60:	00 00       	add	r0,r0
80003e62:	0a f0       	st.b	--r5,r0

80003e64 <local_start_SSC>:
void local_start_SSC(void)
{
    /*Assign GPIO to SSC.
    gpio_enable_module
    gpio_enable_module_pin*/
    AVR32_GPIO.port[1].pmr0c = 0x00000DC0;
80003e64:	fe 78 10 00 	mov	r8,-61440
80003e68:	e0 69 0d c0 	mov	r9,3520
80003e6c:	f1 49 01 18 	st.w	r8[280],r9
    AVR32_GPIO.port[1].pmr1c = 0x00000DC0;
80003e70:	f1 49 01 28 	st.w	r8[296],r9
    AVR32_GPIO.port[1].gperc = 0x00000DC0;
80003e74:	f1 49 01 08 	st.w	r8[264],r9

    /*Software reset SSC*/
    (&AVR32_SSC)->cr = AVR32_SSC_CR_SWRST_MASK;
80003e78:	fe 78 34 00 	mov	r8,-52224
80003e7c:	e0 69 80 00 	mov	r9,32768
80003e80:	91 09       	st.w	r8[0x0],r9
    (&AVR32_SSC)->cmr 
80003e82:	30 09       	mov	r9,0
80003e84:	91 19       	st.w	r8[0x4],r9
                     = AVR32_SSC_CMR_DIV_NOT_ACTIVE << AVR32_SSC_CMR_DIV_OFFSET;

    /*For Slave*/
    (&AVR32_SSC)->tcmr =
80003e86:	e0 69 04 21 	mov	r9,1057
80003e8a:	ea 19 3f 20 	orh	r9,0x3f20
80003e8e:	91 69       	st.w	r8[0x18],r9
	      32								<< AVR32_SSC_TCMR_STTDLY_OFFSET	|
	      63								<< AVR32_SSC_TCMR_PERIOD_OFFSET;


    /*For Slave*/
    (&AVR32_SSC)->tfmr = 
80003e90:	e0 69 02 9f 	mov	r9,671
80003e94:	ea 19 01 00 	orh	r9,0x100
80003e98:	91 79       	st.w	r8[0x1c],r9
	     0									<< AVR32_SSC_TFMR_FSDEN_OFFSET	|
	     1									<< AVR32_SSC_TFMR_FSEDGE_OFFSET;

	/*For Slave*/

	(&AVR32_SSC)->rcmr = 
80003e9a:	e0 6a 04 02 	mov	r10,1026
80003e9e:	ea 1a 3f 20 	orh	r10,0x3f20
80003ea2:	91 4a       	st.w	r8[0x10],r10
	     0									<< AVR32_SSC_RCMR_STOP_OFFSET	|
	     32									<< AVR32_SSC_RCMR_STTDLY_OFFSET	|
	     63									<< AVR32_SSC_RCMR_PERIOD_OFFSET;

	/*For Slave*/
	(&AVR32_SSC)->rfmr = 
80003ea4:	91 59       	st.w	r8[0x14],r9
	    1									<< AVR32_SSC_RFMR_MSBF_OFFSET	|
	    2									<< AVR32_SSC_RFMR_DATNB_OFFSET	|
	    0									<< AVR32_SSC_RFMR_FSLEN_OFFSET	|
	    AVR32_SSC_RFMR_FSOS_INPUT_ONLY		<< AVR32_SSC_RFMR_FSOS_OFFSET	|
	    1									<< AVR32_SSC_RFMR_FSEDGE_OFFSET;
}/*End of local_start_SSC.*/
80003ea6:	5e fc       	retal	r12

80003ea8 <local_start_PDC>:
Function: local_start_PDC
Description: none
Called By: void ssc_init(void) -- ssc.c
*/
void local_start_PDC(void)
{
80003ea8:	d4 01       	pushm	lr
    /*Toggle Index*/	
    BufferIndex = 1;
80003eaa:	30 19       	mov	r9,1
80003eac:	49 78       	lddpc	r8,80003f08 <local_start_PDC+0x60>
80003eae:	b0 89       	st.b	r8[0x0],r9
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
80003eb0:	fe 78 00 00 	mov	r8,-65536
80003eb4:	30 7b       	mov	r11,7
80003eb6:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
80003eb8:	70 b9       	ld.w	r9,r8[0x2c]
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
80003eba:	49 59       	lddpc	r9,80003f0c <local_start_PDC+0x64>
80003ebc:	f2 ca ff fc 	sub	r10,r9,-4
    BufferIndex = 1;
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
80003ec0:	91 0a       	st.w	r8[0x0],r10
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
80003ec2:	30 3a       	mov	r10,3
80003ec4:	91 2a       	st.w	r8[0x8],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
80003ec6:	30 1c       	mov	r12,1
80003ec8:	91 1c       	st.w	r8[0x4],r12
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
80003eca:	2e c9       	sub	r9,-20
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
80003ecc:	91 39       	st.w	r8[0xc],r9
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80003ece:	91 4a       	st.w	r8[0x10],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80003ed0:	30 2c       	mov	r12,2
80003ed2:	91 6c       	st.w	r8[0x18],r12

	TxBuffer[0].xnl_channel.dword = XNL_IDLE;
80003ed4:	48 f9       	lddpc	r9,80003f10 <local_start_PDC+0x68>
80003ed6:	e0 68 5a 5a 	mov	r8,23130
80003eda:	ea 18 ab cd 	orh	r8,0xabcd
80003ede:	93 18       	st.w	r9[0x4],r8
	TxBuffer[0].payload_channel.dword[0] = PAYLOADIDLE0;
80003ee0:	93 28       	st.w	r9[0x8],r8
	TxBuffer[0].payload_channel.dword[1] = PAYLOADIDLE1;
80003ee2:	30 0e       	mov	lr,0
80003ee4:	93 3e       	st.w	r9[0xc],lr
	TxBuffer[1].xnl_channel.dword = XNL_IDLE;
80003ee6:	93 58       	st.w	r9[0x14],r8
	TxBuffer[1].payload_channel.dword[0] = PAYLOADIDLE0;
80003ee8:	93 68       	st.w	r9[0x18],r8
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;
80003eea:	93 7e       	st.w	r9[0x1c],lr

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
80003eec:	fe 78 00 40 	mov	r8,-65472
80003ef0:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
80003ef2:	70 be       	ld.w	lr,r8[0x2c]
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
80003ef4:	f2 ce ff fc 	sub	lr,r9,-4
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
80003ef8:	91 0e       	st.w	r8[0x0],lr
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
80003efa:	91 2a       	st.w	r8[0x8],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
80003efc:	91 1b       	st.w	r8[0x4],r11
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
80003efe:	2e c9       	sub	r9,-20
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
80003f00:	91 39       	st.w	r8[0xc],r9
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80003f02:	91 4a       	st.w	r8[0x10],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80003f04:	91 6c       	st.w	r8[0x18],r12
}/*End of local_start_PDC.*/
80003f06:	d8 02       	popm	pc
80003f08:	00 00       	add	r0,r0
80003f0a:	96 d4       	ld.uh	r4,r11[0xa]
80003f0c:	00 00       	add	r0,r0
80003f0e:	96 dc       	ld.uh	r12,r11[0xa]
80003f10:	00 00       	add	r0,r0
80003f12:	96 fc       	ld.uh	r12,r11[0xe]

80003f14 <register_rx_tx_func>:
Description: register the rx function(callback function)
Called By: phy_init -- physical.c
*/
void register_rx_tx_func(void (*rx_exec)(void *),  void ( *tx_exec)(void *))
{
	 phy_rx_exec = rx_exec;
80003f14:	48 38       	lddpc	r8,80003f20 <register_rx_tx_func+0xc>
80003f16:	91 0c       	st.w	r8[0x0],r12
	 phy_tx_exec = tx_exec;//phy_tx_func, phy_rx_func
80003f18:	48 38       	lddpc	r8,80003f24 <register_rx_tx_func+0x10>
80003f1a:	91 0b       	st.w	r8[0x0],r11
	 
}/*End of register_tx_rx_func.*/
80003f1c:	5e fc       	retal	r12
80003f1e:	00 00       	add	r0,r0
80003f20:	00 00       	add	r0,r0
80003f22:	0a e8       	st.h	--r5,r8
80003f24:	00 00       	add	r0,r0
80003f26:	0a f0       	st.b	--r5,r0

80003f28 <ssc_init>:
    local_start_SSC -- ssc.c
    local_start_PDC -- ssc.c
Called By: phy_init -- physical.c
*/
void ssc_init(void)
{		
80003f28:	d4 01       	pushm	lr
    /*Set up PB01 to watch FS.*/
    AVR32_GPIO.port[1].oderc = 0x00000002;
80003f2a:	fe 78 10 00 	mov	r8,-61440
80003f2e:	30 29       	mov	r9,2
80003f30:	f1 49 01 48 	st.w	r8[328],r9
    AVR32_GPIO.port[1].gpers = 0x00000002;
80003f34:	f1 49 01 04 	st.w	r8[260],r9
	
	Disable_global_interrupt();
80003f38:	d3 03       	ssrf	0x10
	
	INTC_register_interrupt (
80003f3a:	30 3a       	mov	r10,3
80003f3c:	36 0b       	mov	r11,96
80003f3e:	49 4c       	lddpc	r12,80003f8c <ssc_init+0x64>
80003f40:	f0 1f 00 14 	mcall	80003f90 <ssc_init+0x68>
	&pdca_int_handler
	, AVR32_PDCA_IRQ_0 //PDCA_CHANNEL_SSCRX_EXAMPLE = 0
	, AVR32_INTC_INT3 //highest priority.
	);
	
	Enable_global_interrupt();
80003f44:	d5 03       	csrf	0x10
	
    /*Waits for radio to start making FSYNC.*/
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
80003f46:	fe 79 10 00 	mov	r9,-61440
80003f4a:	f2 f8 01 60 	ld.w	r8,r9[352]
80003f4e:	e2 18 00 02 	andl	r8,0x2,COH
80003f52:	cf c0       	breq	80003f4a <ssc_init+0x22>
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
80003f54:	fe 79 10 00 	mov	r9,-61440
80003f58:	f2 f8 01 60 	ld.w	r8,r9[352]
80003f5c:	e2 18 00 02 	andl	r8,0x2,COH
80003f60:	cf c1       	brne	80003f58 <ssc_init+0x30>
			
	Disable_global_interrupt(); // resume to before
80003f62:	d3 03       	ssrf	0x10
				
    /*config the SSC*/
    local_start_SSC();
80003f64:	f0 1f 00 0c 	mcall	80003f94 <ssc_init+0x6c>

    /*config the PDCA*/
    local_start_PDC();
80003f68:	f0 1f 00 0c 	mcall	80003f98 <ssc_init+0x70>
		
    /*Start the SSC Physical Layer.*/

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80003f6c:	fe 79 00 00 	mov	r9,-65536
80003f70:	30 18       	mov	r8,1
80003f72:	93 58       	st.w	r9[0x14],r8
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80003f74:	fe 7a 00 40 	mov	r10,-65472
80003f78:	95 58       	st.w	r10[0x14],r8
    (&AVR32_SSC)->cr = AVR32_SSC_CR_RXEN_MASK | AVR32_SSC_CR_TXEN_MASK;
80003f7a:	e0 6b 01 01 	mov	r11,257
80003f7e:	fe 7a 34 00 	mov	r10,-52224
80003f82:	95 0b       	st.w	r10[0x0],r11
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->ier = AVR32_PDCA_RCZ_MASK;
80003f84:	93 88       	st.w	r9[0x20],r8
															
	Enable_global_interrupt();
80003f86:	d5 03       	csrf	0x10
															
}/*End of ssc_init.*/
80003f88:	d8 02       	popm	pc
80003f8a:	00 00       	add	r0,r0
80003f8c:	80 00       	ld.sh	r0,r0[0x0]
80003f8e:	3d e4       	mov	r4,-34
80003f90:	80 00       	ld.sh	r0,r0[0x0]
80003f92:	56 38       	stdsp	sp[0x18c],r8
80003f94:	80 00       	ld.sh	r0,r0[0x0]
80003f96:	3e 64       	mov	r4,-26
80003f98:	80 00       	ld.sh	r0,r0[0x0]
80003f9a:	3e a8       	mov	r8,-22

80003f9c <xcmp_register_app_list>:
Calls: 
Called By: app_init -- app.c
*/
void xcmp_register_app_list(void * list)
{
	app_list = (app_exec_t *)list;
80003f9c:	48 28       	lddpc	r8,80003fa4 <xcmp_register_app_list+0x8>
80003f9e:	91 0c       	st.w	r8[0x0],r12
}
80003fa0:	5e fc       	retal	r12
80003fa2:	00 00       	add	r0,r0
80003fa4:	00 00       	add	r0,r0
80003fa6:	97 1c       	st.w	r11[0x4],r12

80003fa8 <xcmp_tx>:
Calls:   
	xnl_tx -- xnl.c
Called By: ...
*/
static void xcmp_tx( xcmp_fragment_t * xcmp, U8 payload_len)
{
80003fa8:	eb cd 40 80 	pushm	r7,lr
80003fac:	fa cd 01 00 	sub	sp,sp,256
80003fb0:	16 97       	mov	r7,r11
	Length :xnl length + checksum
	= checksum + xnl header + xcmp opcode + xcmp payload
	= 0x02 + 0x0C + 0x02 + xcmp payload
	= 0x10 + xcmp payload
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | ( 0x10 + payload_len);
80003fb2:	16 98       	mov	r8,r11
80003fb4:	2f 08       	sub	r8,-16
80003fb6:	af a8       	sbr	r8,0xe
80003fb8:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE; 
80003fba:	3f f8       	mov	r8,-1
80003fbc:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG;
80003fbe:	30 b9       	mov	r9,11
80003fc0:	ba 29       	st.h	sp[0x4],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;	
80003fc2:	ba 38       	st.h	sp[0x6],r8
	xnl_frame.xnl_header.destination = DEFAULT_VALUE;
80003fc4:	ba 48       	st.h	sp[0x8],r8
	xnl_frame.xnl_header.source = DEFAULT_VALUE;	
80003fc6:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80003fc8:	ba 68       	st.h	sp[0xc],r8
	
	/*insert xcmp frame data*/
	memcpy(&xnl_frame.xnl_payload.xnl_content_data_msg, xcmp, payload_len + 2);
80003fca:	f6 ca ff fe 	sub	r10,r11,-2
80003fce:	18 9b       	mov	r11,r12
80003fd0:	fa cc ff f0 	sub	r12,sp,-16
80003fd4:	f0 1f 00 05 	mcall	80003fe8 <xcmp_tx+0x40>
	xnl_frame.xnl_header.payload_length = payload_len + 2;	
80003fd8:	2f e7       	sub	r7,-2
80003fda:	ba 77       	st.h	sp[0xe],r7
	
	/* send xnl frame*/	
	xnl_tx(&xnl_frame);
80003fdc:	1a 9c       	mov	r12,sp
80003fde:	f0 1f 00 04 	mcall	80003fec <xcmp_tx+0x44>
}
80003fe2:	2c 0d       	sub	sp,-256
80003fe4:	e3 cd 80 80 	ldm	sp++,r7,pc
80003fe8:	80 00       	ld.sh	r0,r0[0x0]
80003fea:	78 dc       	ld.w	r12,r12[0x34]
80003fec:	80 00       	ld.sh	r0,r0[0x0]
80003fee:	45 c0       	lddsp	r0,sp[0x170]

80003ff0 <xcmp_data_session_req>:
Description: send data-session request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_data_session_req(void *message, U16 length, U32 dest)
{
80003ff0:	d4 21       	pushm	r4-r7,lr
80003ff2:	fa cd 00 d0 	sub	sp,sp,208
80003ff6:	18 94       	mov	r4,r12
80003ff8:	16 97       	mov	r7,r11
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
	
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
	
	if (length > 256)return -1;
80003ffa:	e0 68 01 00 	mov	r8,256
80003ffe:	f0 0b 19 00 	cp.h	r11,r8
80004002:	e0 8b 00 38 	brhi	80004072 <xcmp_data_session_req+0x82>
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
	
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
80004006:	fa c5 ff f8 	sub	r5,sp,-8
	//U8 SizeofAddress = Remote_Mototrbo_Address_Size;// 3;//可能会变化
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
8000400a:	e0 68 04 1d 	mov	r8,1053
8000400e:	ba 38       	st.h	sp[0x6],r8
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
	
	if (length > 256)return -1;
	
	ptr->Function = Single_Data_Uint;
80004010:	30 18       	mov	r8,1
80004012:	aa 88       	st.b	r5[0x0],r8
	
	ptr->DataDefinition.Data_Protocol_Version = TMP_Ver_1_1;//0x20
80004014:	32 08       	mov	r8,32
80004016:	aa 98       	st.b	r5[0x1],r8
	
	ptr->DataDefinition.Dest_Address.Remote_Address_Type = Remote_IPV4_Address;//0x02
80004018:	30 28       	mov	r8,2
8000401a:	aa a8       	st.b	r5[0x2],r8
	
	ptr->DataDefinition.Dest_Address.Remote_Address_Size = Remote_IPV4_Address_Size;//0x04
8000401c:	30 48       	mov	r8,4
8000401e:	aa b8       	st.b	r5[0x3],r8
	
	unsigned int addr = 0x0C000000 | (dest & 0x00FFFFFF);
80004020:	f5 da c0 18 	bfextu	r10,r10,0x0,0x18
80004024:	ea 1a 0c 00 	orh	r10,0xc00
80004028:	50 0a       	stdsp	sp[0x0],r10
	memcpy(ptr->DataDefinition.Dest_Address.Remote_Address, &addr, Remote_IPV4_Address_Size);
8000402a:	30 4a       	mov	r10,4
8000402c:	1a 9b       	mov	r11,sp
8000402e:	fa cc ff f4 	sub	r12,sp,-12
80004032:	f0 1f 00 12 	mcall	80004078 <xcmp_data_session_req+0x88>
	//ptr->DataDefinition.Dest_Address.Remote_Address[0] = 0x0C;//12
	//ptr->DataDefinition.Dest_Address.Remote_Address[1] = 0x00;//0
	//ptr->DataDefinition.Dest_Address.Remote_Address[2] = 0x00;//0
	//ptr->DataDefinition.Dest_Address.Remote_Address[3] = 0x02;//2
	
	ptr->DataDefinition.Dest_Address.Remote_Port_Com[0] = (Remote_Port >>8) & 0xFF;//4007
80004036:	30 f8       	mov	r8,15
80004038:	eb 68 00 08 	st.b	r5[8],r8
	ptr->DataDefinition.Dest_Address.Remote_Port_Com[1] = Remote_Port & 0xFF;//
8000403c:	3a 78       	mov	r8,-89
8000403e:	eb 68 00 09 	st.b	r5[9],r8
	
    
	ptr->DataPayload.Session_ID_Number = Session_ID;//0x00
80004042:	30 08       	mov	r8,0
80004044:	eb 68 00 0a 	st.b	r5[10],r8
	
	ptr->DataPayload.DataPayload_Length[0] =(length >> 8) & 0xFF ;//可能会变化
80004048:	0e 9a       	mov	r10,r7
8000404a:	5c 7a       	castu.h	r10
8000404c:	f4 08 16 08 	lsr	r8,r10,0x8
80004050:	eb 68 00 0b 	st.b	r5[11],r8
	ptr->DataPayload.DataPayload_Length[1] =length & 0xFF  ;//可能会变化
80004054:	0e 96       	mov	r6,r7
80004056:	eb 67 00 0c 	st.b	r5[12],r7
	
	memcpy(&(ptr->DataPayload.DataPayload[0]), message, length);
8000405a:	08 9b       	mov	r11,r4
8000405c:	fa cc ff eb 	sub	r12,sp,-21
80004060:	f0 1f 00 06 	mcall	80004078 <xcmp_data_session_req+0x88>
	
	xcmp_tx(&xcmp_farme, sizeof(DataSession_req_t) - (256 - length));
80004064:	ee cb ff f3 	sub	r11,r7,-13
80004068:	5c 5b       	castu.b	r11
8000406a:	fa cc ff fa 	sub	r12,sp,-6
8000406e:	f0 1f 00 04 	mcall	8000407c <xcmp_data_session_req+0x8c>
}
80004072:	2c cd       	sub	sp,-208
80004074:	d8 22       	popm	r4-r7,pc
80004076:	00 00       	add	r0,r0
80004078:	80 00       	ld.sh	r0,r0[0x0]
8000407a:	78 dc       	ld.w	r12,r12[0x34]
8000407c:	80 00       	ld.sh	r0,r0[0x0]
8000407e:	3f a8       	mov	r8,-6

80004080 <xcmp_DeviceInitializationStatus_request>:
Description: send device initialization status request
Calls: xcmp_tx
Called By:...
*/
void xcmp_DeviceInitializationStatus_request(void)
{
80004080:	d4 01       	pushm	lr
80004082:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
		
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_BRDCAST | DEVICE_INITIALIZATION_STATUS;
80004086:	fe 78 b4 00 	mov	r8,-19456
8000408a:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	DeviceInitializationStatus_brdcst_t * ptr 
						 = (DeviceInitializationStatus_brdcst_t *)xcmp_farme.u8;
8000408c:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*xcmp version 8.1.0.5*///版本号未正确填写，纠正
	ptr->XCMPVersion[0] = XCMP_Version[0];
80004090:	48 c9       	lddpc	r9,800040c0 <xcmp_DeviceInitializationStatus_request+0x40>
80004092:	13 8a       	ld.ub	r10,r9[0x0]
80004094:	b0 8a       	st.b	r8[0x0],r10
	ptr->XCMPVersion[1] = XCMP_Version[1];
80004096:	13 9a       	ld.ub	r10,r9[0x1]
80004098:	b0 9a       	st.b	r8[0x1],r10
	ptr->XCMPVersion[2] = XCMP_Version[2];
8000409a:	13 aa       	ld.ub	r10,r9[0x2]
8000409c:	b0 aa       	st.b	r8[0x2],r10
	ptr->XCMPVersion[3] = XCMP_Version[3];
8000409e:	13 b9       	ld.ub	r9,r9[0x3]
800040a0:	b0 b9       	st.b	r8[0x3],r9
	/*
	0x00:
	This is the message that the device sends at power up or after a reset. It 
	will give the initial status and capabilities for the device.
	*/
	ptr->DeviceInitType = 0x00;
800040a2:	30 09       	mov	r9,0
800040a4:	b0 c9       	st.b	r8[0x4],r9
	types of devices may provide a set of services to the radio system, but do 
	not have the ability to be the master.
	
	0x07:OptionBoard,3rd party Option Board-based application.
	*/
	ptr->DeviceStatusInfo.DeviceType = 0x07;
800040a6:	30 7a       	mov	r10,7
800040a8:	b0 da       	st.b	r8[0x5],r10
	
	/*Power Up Success, Device has powered up with no errors*/
	ptr->DeviceStatusInfo.DeviceStatus[0] = 0x00;
800040aa:	b0 e9       	st.b	r8[0x6],r9
	ptr->DeviceStatusInfo.DeviceStatus[1] = 0x00;
800040ac:	b0 f9       	st.b	r8[0x7],r9
	
	/*
	This number is the size of the Device Descriptor data structure with a 
	maximum size not exceeding 255 bytes.
	*/
	ptr->DeviceStatusInfo.DeviceDescriptorSize = 0x00;
800040ae:	f1 69 00 08 	st.b	r8[8],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme
800040b2:	30 9b       	mov	r11,9
800040b4:	fa cc ff fe 	sub	r12,sp,-2
800040b8:	f0 1f 00 03 	mcall	800040c4 <xcmp_DeviceInitializationStatus_request+0x44>
		, sizeof(DeviceInitializationStatus_brdcst_t) - MAX_DEVICE_DESC_SIZE);
}
800040bc:	2c dd       	sub	sp,-204
800040be:	d8 02       	popm	pc
800040c0:	00 00       	add	r0,r0
800040c2:	0d 98       	ld.ub	r8,r6[0x1]
800040c4:	80 00       	ld.sh	r0,r0[0x0]
800040c6:	3f a8       	mov	r8,-6

800040c8 <xcmp_opcode_not_supported>:
Description: register the app list
Calls: xcmp_tx
Called By:...
*/
void xcmp_opcode_not_supported( void )
{
800040c8:	d4 01       	pushm	lr
800040ca:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REPLY;
800040ce:	fe 78 80 00 	mov	r8,-32768
800040d2:	ba 18       	st.h	sp[0x2],r8
	
	/*The radio does not support this opcode.*/
	xcmp_farme.u8[0] = xcmp_Res_Opcode_Not_Supported;
800040d4:	30 38       	mov	r8,3
800040d6:	ba c8       	st.b	sp[0x4],r8
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, 1);
800040d8:	30 1b       	mov	r11,1
800040da:	fa cc ff fe 	sub	r12,sp,-2
800040de:	f0 1f 00 03 	mcall	800040e8 <xcmp_opcode_not_supported+0x20>
}
800040e2:	2c dd       	sub	sp,-204
800040e4:	d8 02       	popm	pc
800040e6:	00 00       	add	r0,r0
800040e8:	80 00       	ld.sh	r0,r0[0x0]
800040ea:	3f a8       	mov	r8,-6

800040ec <xcmp_exec_func>:
Description: Perform XCMP corresponding functions
Calls:   
Called By: xcmp_rx_process--task
*/
static void xcmp_exec_func(app_exec_t * exec, xcmp_fragment_t * xcmp)
{
800040ec:	d4 01       	pushm	lr
	/*The message types*/
	switch(xcmp->xcmp_opcode & 0xF000)
800040ee:	96 88       	ld.uh	r8,r11[0x0]
800040f0:	e2 18 f0 00 	andl	r8,0xf000,COH
800040f4:	e0 48 80 00 	cp.w	r8,32768
800040f8:	c0 f0       	breq	80004116 <xcmp_exec_func+0x2a>
800040fa:	e0 48 b0 00 	cp.w	r8,45056
800040fe:	c1 20       	breq	80004122 <xcmp_exec_func+0x36>
80004100:	58 08       	cp.w	r8,0
80004102:	c1 51       	brne	8000412c <xcmp_exec_func+0x40>
	{
		case XCMP_REQUEST:
			if(NULL != exec->xcmp_rx_req)
80004104:	78 08       	ld.w	r8,r12[0x0]
80004106:	58 08       	cp.w	r8,0
80004108:	c0 40       	breq	80004110 <xcmp_exec_func+0x24>
			{
				exec->xcmp_rx_req(xcmp);
8000410a:	16 9c       	mov	r12,r11
8000410c:	5d 18       	icall	r8
8000410e:	d8 02       	popm	pc
			}
			else 
			{
				/*No function to register the request message*/
				/*send not supported opcode to raido */
				xcmp_opcode_not_supported();
80004110:	f0 1f 00 08 	mcall	80004130 <xcmp_exec_func+0x44>
80004114:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_REPLY:		
			if(NULL != exec->xcmp_rx_reply)
80004116:	78 18       	ld.w	r8,r12[0x4]
80004118:	58 08       	cp.w	r8,0
8000411a:	c0 90       	breq	8000412c <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_reply(xcmp);
8000411c:	16 9c       	mov	r12,r11
8000411e:	5d 18       	icall	r8
80004120:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_BRDCAST:	
			if(NULL != exec->xcmp_rx_brdcst)
80004122:	78 28       	ld.w	r8,r12[0x8]
80004124:	58 08       	cp.w	r8,0
80004126:	c0 30       	breq	8000412c <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_brdcst(xcmp);
80004128:	16 9c       	mov	r12,r11
8000412a:	5d 18       	icall	r8
8000412c:	d8 02       	popm	pc
8000412e:	00 00       	add	r0,r0
80004130:	80 00       	ld.sh	r0,r0[0x0]
80004132:	40 c8       	lddsp	r8,sp[0x30]

80004134 <xcmp_IdleTestTone>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_IdleTestTone(U8 type, U16 toneID)
{
80004134:	d4 01       	pushm	lr
80004136:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | TONE_CONTROL;
8000413a:	e0 68 04 09 	mov	r8,1033
8000413e:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	ToneControl_req_t * ptr = (ToneControl_req_t *)xcmp_farme.u8;
80004140:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*Starts the specific tone*/	
	ptr->Function = type;
80004144:	b0 8c       	st.b	r8[0x0],r12
	
	/*This tone shall be sounded when radio landed on a priority channel*/
	//ptr->ToneIdentifier[0] = (Priority_Beep >> 8) & 0xFF;
	//ptr->ToneIdentifier[1] = Priority_Beep & 0xFF;
	
	ptr->ToneIdentifier[0] = (toneID >> 8) & 0xFF;
80004146:	f3 db c1 08 	bfextu	r9,r11,0x8,0x8
8000414a:	b0 99       	st.b	r8[0x1],r9
	ptr->ToneIdentifier[1] = toneID & 0xFF;	
8000414c:	b0 ab       	st.b	r8[0x2],r11
	
	/*
	The alert tone is played according to any rules for alert tones, given the 
	current volume setting. Settings for this field are 8 to 255 (0x08 ?0xFF).
	*/
	ptr->ToneVolumeControl = Current_Volume;
8000414e:	30 09       	mov	r9,0
80004150:	b0 b9       	st.b	r8[0x3],r9
	
	/*clear reserved*/
	memset(ptr->Reserved, 0, 8);
80004152:	fb 69 00 08 	st.b	sp[8],r9
80004156:	fa c8 ff f7 	sub	r8,sp,-9
8000415a:	b0 89       	st.b	r8[0x0],r9
8000415c:	fa c8 ff f6 	sub	r8,sp,-10
80004160:	b0 89       	st.b	r8[0x0],r9
80004162:	fa c8 ff f5 	sub	r8,sp,-11
80004166:	b0 89       	st.b	r8[0x0],r9
80004168:	fa c8 ff f4 	sub	r8,sp,-12
8000416c:	b0 89       	st.b	r8[0x0],r9
8000416e:	fa c8 ff f3 	sub	r8,sp,-13
80004172:	b0 89       	st.b	r8[0x0],r9
80004174:	fa c8 ff f2 	sub	r8,sp,-14
80004178:	b0 89       	st.b	r8[0x0],r9
8000417a:	fa c8 ff f1 	sub	r8,sp,-15
8000417e:	b0 89       	st.b	r8[0x0],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(ToneControl_req_t));
80004180:	30 cb       	mov	r11,12
80004182:	fa cc ff fe 	sub	r12,sp,-2
80004186:	f0 1f 00 03 	mcall	80004190 <xcmp_IdleTestTone+0x5c>
}
8000418a:	2c dd       	sub	sp,-204
8000418c:	d8 02       	popm	pc
8000418e:	00 00       	add	r0,r0
80004190:	80 00       	ld.sh	r0,r0[0x0]
80004192:	3f a8       	mov	r8,-6

80004194 <xcmp_init>:
	xQueueCreate -- freertos
	xTaskCreate -- freertos
Called By: main -- main.c
*/
void xcmp_init(void)
{
80004194:	d4 01       	pushm	lr
	/*register the xcmp function(callback function)*/
	xnl_register_xcmp_func( xcmp_rx );
80004196:	48 dc       	lddpc	r12,800041c8 <xcmp_init+0x34>
80004198:	f0 1f 00 0d 	mcall	800041cc <xcmp_init+0x38>
	
	/*initialize the queue*/
	xcmp_frame_rx = xQueueCreate(20, sizeof(xcmp_fragment_t *));
8000419c:	30 4b       	mov	r11,4
8000419e:	31 4c       	mov	r12,20
800041a0:	f0 1f 00 0c 	mcall	800041d0 <xcmp_init+0x3c>
800041a4:	48 c8       	lddpc	r8,800041d4 <xcmp_init+0x40>
800041a6:	91 0c       	st.w	r8[0x0],r12
	/*create task*/	
	/*this task is used to execute xcmp message*/
	xTaskCreate(
800041a8:	30 09       	mov	r9,0
800041aa:	1a d9       	st.w	--sp,r9
800041ac:	1a d9       	st.w	--sp,r9
800041ae:	1a d9       	st.w	--sp,r9
800041b0:	30 38       	mov	r8,3
800041b2:	e0 6a 04 00 	mov	r10,1024
800041b6:	48 9b       	lddpc	r11,800041d8 <xcmp_init+0x44>
800041b8:	48 9c       	lddpc	r12,800041dc <xcmp_init+0x48>
800041ba:	f0 1f 00 0a 	mcall	800041e0 <xcmp_init+0x4c>
	,  tskXCMP_PRIORITY
	,  NULL
	);
	
	/*initialize the xnl*/
	xnl_init();
800041be:	f0 1f 00 0a 	mcall	800041e4 <xcmp_init+0x50>
800041c2:	2f dd       	sub	sp,-12
	
}
800041c4:	d8 02       	popm	pc
800041c6:	00 00       	add	r0,r0
800041c8:	80 00       	ld.sh	r0,r0[0x0]
800041ca:	42 e4       	lddsp	r4,sp[0xb8]
800041cc:	80 00       	ld.sh	r0,r0[0x0]
800041ce:	43 30       	lddsp	r0,sp[0xcc]
800041d0:	80 00       	ld.sh	r0,r0[0x0]
800041d2:	65 80       	ld.w	r0,r2[0x60]
800041d4:	00 00       	add	r0,r0
800041d6:	0b 0c       	ld.w	r12,r5++
800041d8:	80 00       	ld.sh	r0,r0[0x0]
800041da:	d8 68       	*unknown*
800041dc:	80 00       	ld.sh	r0,r0[0x0]
800041de:	41 e8       	lddsp	r8,sp[0x78]
800041e0:	80 00       	ld.sh	r0,r0[0x0]
800041e2:	6c 9c       	ld.w	r12,r6[0x24]
800041e4:	80 00       	ld.sh	r0,r0[0x0]
800041e6:	43 68       	lddsp	r8,sp[0xd8]

800041e8 <xcmp_rx_process>:
Calls: xQueueReceive -- freerots
	xcmp_exec_func
Called By: task
*/
static void xcmp_rx_process(void * pvParameters)
{
800041e8:	d4 31       	pushm	r0-r7,lr
800041ea:	20 1d       	sub	sp,4
	xcmp_fragment_t * ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
800041ec:	4b 16       	lddpc	r6,800042b0 <xcmp_rx_process+0xc8>
800041ee:	30 05       	mov	r5,0
800041f0:	31 44       	mov	r4,20
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
800041f2:	4b 13       	lddpc	r3,800042b4 <xcmp_rx_process+0xcc>
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
					break;
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
800041f4:	4b 12       	lddpc	r2,800042b8 <xcmp_rx_process+0xd0>
						, ptr);
					break;
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
800041f6:	4b 21       	lddpc	r1,800042bc <xcmp_rx_process+0xd4>
					break;
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
800041f8:	4b 20       	lddpc	r0,800042c0 <xcmp_rx_process+0xd8>
	xcmp_fragment_t * ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
800041fa:	6c 0c       	ld.w	r12,r6[0x0]
800041fc:	0a 99       	mov	r9,r5
800041fe:	08 9a       	mov	r10,r4
80004200:	1a 9b       	mov	r11,sp
80004202:	f0 1f 00 31 	mcall	800042c4 <xcmp_rx_process+0xdc>
80004206:	58 1c       	cp.w	r12,1
80004208:	cf 91       	brne	800041fa <xcmp_rx_process+0x12>
		{									
			if(NULL == ptr)
8000420a:	40 0b       	lddsp	r11,sp[0x0]
8000420c:	58 0b       	cp.w	r11,0
8000420e:	cf 60       	breq	800041fa <xcmp_rx_process+0x12>
			
			//log("\n\r R_xcmp : %4x \n\r",ptr->xcmp_opcode);//log:R_xcmp指令	
			//static  portTickType water_value;
			//water_value = uxTaskGetStackHighWaterMark(NULL);
			//log("water_value: %d\n", water_value);			
			switch(ptr->xcmp_opcode & 0x0FFF)
80004210:	96 0a       	ld.sh	r10,r11[0x0]
80004212:	f3 da c0 10 	bfextu	r9,r10,0x0,0x10
80004216:	f1 d9 c0 0c 	bfextu	r8,r9,0x0,0xc
8000421a:	59 c8       	cp.w	r8,28
8000421c:	c1 e0       	breq	80004258 <xcmp_rx_process+0x70>
8000421e:	e0 89 00 07 	brgt	8000422c <xcmp_rx_process+0x44>
80004222:	58 e8       	cp.w	r8,14
80004224:	c0 e0       	breq	80004240 <xcmp_rx_process+0x58>
80004226:	58 f8       	cp.w	r8,15
80004228:	c2 41       	brne	80004270 <xcmp_rx_process+0x88>
8000422a:	c0 f8       	rjmp	80004248 <xcmp_rx_process+0x60>
8000422c:	e0 48 01 09 	cp.w	r8,265
80004230:	c1 80       	breq	80004260 <xcmp_rx_process+0x78>
80004232:	e0 48 01 0a 	cp.w	r8,266
80004236:	c1 90       	breq	80004268 <xcmp_rx_process+0x80>
80004238:	e0 48 00 2c 	cp.w	r8,44
8000423c:	c1 a1       	brne	80004270 <xcmp_rx_process+0x88>
8000423e:	c0 98       	rjmp	80004250 <xcmp_rx_process+0x68>
			{
				case RADIO_STATUS:				
					xcmp_exec_func(&radio_status, ptr);
80004240:	4a 2c       	lddpc	r12,800042c8 <xcmp_rx_process+0xe0>
80004242:	f0 1f 00 23 	mcall	800042cc <xcmp_rx_process+0xe4>
					break;
80004246:	c2 f8       	rjmp	800042a4 <xcmp_rx_process+0xbc>
					
				case VERSION_INFORMATION:
					xcmp_exec_func(&version_information, ptr);
80004248:	4a 2c       	lddpc	r12,800042d0 <xcmp_rx_process+0xe8>
8000424a:	f0 1f 00 21 	mcall	800042cc <xcmp_rx_process+0xe4>
					break;
8000424e:	c2 b8       	rjmp	800042a4 <xcmp_rx_process+0xbc>
					
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
80004250:	4a 1c       	lddpc	r12,800042d4 <xcmp_rx_process+0xec>
80004252:	f0 1f 00 1f 	mcall	800042cc <xcmp_rx_process+0xe4>
					break;
80004256:	c2 78       	rjmp	800042a4 <xcmp_rx_process+0xbc>
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
80004258:	04 9c       	mov	r12,r2
8000425a:	f0 1f 00 1d 	mcall	800042cc <xcmp_rx_process+0xe4>
						, ptr);
					break;
8000425e:	c2 38       	rjmp	800042a4 <xcmp_rx_process+0xbc>
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
80004260:	02 9c       	mov	r12,r1
80004262:	f0 1f 00 1b 	mcall	800042cc <xcmp_rx_process+0xe4>
					break;
80004266:	c1 f8       	rjmp	800042a4 <xcmp_rx_process+0xbc>
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
80004268:	00 9c       	mov	r12,r0
8000426a:	f0 1f 00 19 	mcall	800042cc <xcmp_rx_process+0xe4>
					break;
8000426e:	c1 b8       	rjmp	800042a4 <xcmp_rx_process+0xbc>
					
				default:
				
					/*the xcmp message not in order list*/
					/*over the length of the list*/
					if((0x0400 != (ptr->xcmp_opcode & 0x0400)) 
80004270:	12 98       	mov	r8,r9
80004272:	e2 18 04 00 	andl	r8,0x400,COH
80004276:	c0 70       	breq	80004284 <xcmp_rx_process+0x9c>
80004278:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
8000427c:	e0 48 00 68 	cp.w	r8,104
80004280:	e0 8a 00 08 	brle	80004290 <xcmp_rx_process+0xa8>
						|| (MAX_APP_FUNC <= (ptr->xcmp_opcode & 0x00FF))
					)
					{
						/*xcmp request*/
						if( XCMP_REQUEST == (ptr->xcmp_opcode & 0xF000))
80004284:	e2 19 f0 00 	andl	r9,0xf000,COH
80004288:	c0 e1       	brne	800042a4 <xcmp_rx_process+0xbc>
						{
							/*send not supported opcode to raido */
							xcmp_opcode_not_supported();
8000428a:	f0 1f 00 14 	mcall	800042d8 <xcmp_rx_process+0xf0>
8000428e:	c0 b8       	rjmp	800042a4 <xcmp_rx_process+0xbc>
						}
					}
					else
					{					
						xcmp_exec_func( &app_list[ptr->xcmp_opcode & 0x00FF]
80004290:	f9 da c0 08 	bfextu	r12,r10,0x0,0x8
80004294:	f8 0c 00 1c 	add	r12,r12,r12<<0x1
80004298:	49 19       	lddpc	r9,800042dc <xcmp_rx_process+0xf4>
8000429a:	72 08       	ld.w	r8,r9[0x0]
8000429c:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800042a0:	f0 1f 00 0b 	mcall	800042cc <xcmp_rx_process+0xe4>
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
800042a4:	66 0c       	ld.w	r12,r3[0x0]
800042a6:	40 0b       	lddsp	r11,sp[0x0]
800042a8:	f0 1f 00 0e 	mcall	800042e0 <xcmp_rx_process+0xf8>
800042ac:	ca 7b       	rjmp	800041fa <xcmp_rx_process+0x12>
800042ae:	00 00       	add	r0,r0
800042b0:	00 00       	add	r0,r0
800042b2:	0b 0c       	ld.w	r12,r5++
800042b4:	00 00       	add	r0,r0
800042b6:	0a a4       	st.w	r5++,r4
800042b8:	00 00       	add	r0,r0
800042ba:	0b 1c       	ld.sh	r12,r5++
800042bc:	00 00       	add	r0,r0
800042be:	0b 10       	ld.sh	r0,r5++
800042c0:	00 00       	add	r0,r0
800042c2:	0b 00       	ld.w	r0,r5++
800042c4:	80 00       	ld.sh	r0,r0[0x0]
800042c6:	62 1c       	ld.w	r12,r1[0x4]
800042c8:	00 00       	add	r0,r0
800042ca:	0b 34       	ld.ub	r4,r5++
800042cc:	80 00       	ld.sh	r0,r0[0x0]
800042ce:	40 ec       	lddsp	r12,sp[0x38]
800042d0:	00 00       	add	r0,r0
800042d2:	0a f4       	st.b	--r5,r4
800042d4:	00 00       	add	r0,r0
800042d6:	0b 28       	ld.uh	r8,r5++
800042d8:	80 00       	ld.sh	r0,r0[0x0]
800042da:	40 c8       	lddsp	r8,sp[0x30]
800042dc:	00 00       	add	r0,r0
800042de:	97 1c       	st.w	r11[0x4],r12
800042e0:	80 00       	ld.sh	r0,r0[0x0]
800042e2:	2c cc       	sub	r12,-52

800042e4 <xcmp_rx>:
Calls:   
	xQueueSend -- xnl.c
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
800042e4:	eb cd 40 90 	pushm	r4,r7,lr
800042e8:	20 1d       	sub	sp,4
800042ea:	fa c4 ff f0 	sub	r4,sp,-16
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
800042ee:	48 c8       	lddpc	r8,8000431c <xcmp_rx+0x38>
800042f0:	70 0c       	ld.w	r12,r8[0x0]
800042f2:	f0 1f 00 0c 	mcall	80004320 <xcmp_rx+0x3c>
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
800042f6:	c1 00       	breq	80004316 <xcmp_rx+0x32>
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
800042f8:	fa c7 ff fc 	sub	r7,sp,-4
800042fc:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
	{
		memcpy(xcmp_ptr, &xcmp, sizeof(xcmp_fragment_t));				
800042fe:	e0 6a 00 ca 	mov	r10,202
80004302:	08 9b       	mov	r11,r4
80004304:	f0 1f 00 08 	mcall	80004324 <xcmp_rx+0x40>
		xQueueSend(xcmp_frame_rx, &xcmp_ptr, 0);	
80004308:	48 88       	lddpc	r8,80004328 <xcmp_rx+0x44>
8000430a:	70 0c       	ld.w	r12,r8[0x0]
8000430c:	30 09       	mov	r9,0
8000430e:	12 9a       	mov	r10,r9
80004310:	1a 9b       	mov	r11,sp
80004312:	f0 1f 00 07 	mcall	8000432c <xcmp_rx+0x48>
	}	
}
80004316:	2f fd       	sub	sp,-4
80004318:	e3 cd 80 90 	ldm	sp++,r4,r7,pc
8000431c:	00 00       	add	r0,r0
8000431e:	0a a4       	st.w	r5++,r4
80004320:	80 00       	ld.sh	r0,r0[0x0]
80004322:	2e 78       	sub	r8,-25
80004324:	80 00       	ld.sh	r0,r0[0x0]
80004326:	78 dc       	ld.w	r12,r12[0x34]
80004328:	00 00       	add	r0,r0
8000432a:	0b 0c       	ld.w	r12,r5++
8000432c:	80 00       	ld.sh	r0,r0[0x0]
8000432e:	64 28       	ld.w	r8,r2[0x8]

80004330 <xnl_register_xcmp_func>:
Function: xnl_register_xcmp_func
Description: register the xcmp function(callback function)
*/
void xnl_register_xcmp_func( void ( *func)(xnl_content_data_msg_t))
{
	 xcmp_exec = func;
80004330:	48 28       	lddpc	r8,80004338 <xnl_register_xcmp_func+0x8>
80004332:	91 0c       	st.w	r8[0x0],r12
}
80004334:	5e fc       	retal	r12
80004336:	00 00       	add	r0,r0
80004338:	00 00       	add	r0,r0
8000433a:	0b 58       	ld.sh	r8,--r5

8000433c <xnl_get_msg_ack_func>:
Description: process while receive msg ack.
Calls:xSemaphoreGive--freertos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
8000433c:	d4 01       	pushm	lr
	
	DestinationAddress = xnl->xnl_header.destination;
	/*No timeout*/		
	 //One relationship is controlled by a state machine, only the current MSG received the ACK, 
	//then the program will clear the current MSG sending address and out of standby and will jump to the sending state.
	if (DestinationAddress == xnl_information.device_address )
8000433e:	48 88       	lddpc	r8,8000435c <xnl_get_msg_ack_func+0x20>
80004340:	90 28       	ld.sh	r8,r8[0x4]
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
	U16 DestinationAddress;
	U16 TransactionID;
	
	DestinationAddress = xnl->xnl_header.destination;
80004342:	98 49       	ld.sh	r9,r12[0x8]
80004344:	f0 09 19 00 	cp.h	r9,r8
80004348:	c0 81       	brne	80004358 <xnl_get_msg_ack_func+0x1c>
	if (DestinationAddress == xnl_information.device_address )
	{
		//The ack is for me.
		
		TransactionID = xnl->xnl_header.transaction_id;
		xSemaphoreGive(xnl_timeout_semphr);	
8000434a:	48 68       	lddpc	r8,80004360 <xnl_get_msg_ack_func+0x24>
8000434c:	70 0c       	ld.w	r12,r8[0x0]
8000434e:	30 09       	mov	r9,0
80004350:	12 9a       	mov	r10,r9
80004352:	12 9b       	mov	r11,r9
80004354:	f0 1f 00 04 	mcall	80004364 <xnl_get_msg_ack_func+0x28>
80004358:	d8 02       	popm	pc
8000435a:	00 00       	add	r0,r0
8000435c:	00 00       	add	r0,r0
8000435e:	97 20       	st.w	r11[0x8],r0
80004360:	00 00       	add	r0,r0
80004362:	0b 40       	ld.w	r0,--r5
80004364:	80 00       	ld.sh	r0,r0[0x0]
80004366:	64 28       	ld.w	r8,r2[0x8]

80004368 <xnl_init>:
	xTaskCreate--freertos
	xnl_send_device_master_query
Called By:xcmp_init -- xcmp.c
*/
void xnl_init(void)
{
80004368:	eb cd 40 e0 	pushm	r5-r7,lr
	
	xnl_information.is_connected = FALSE;
8000436c:	30 09       	mov	r9,0
8000436e:	4b 78       	lddpc	r8,80004448 <xnl_init+0xe0>
80004370:	b0 89       	st.b	r8[0x0],r9

	/*initialize the semaphore and queue*/
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
80004372:	30 0b       	mov	r11,0
80004374:	30 1c       	mov	r12,1
80004376:	f0 1f 00 36 	mcall	8000444c <xnl_init+0xe4>
8000437a:	4b 68       	lddpc	r8,80004450 <xnl_init+0xe8>
8000437c:	91 0c       	st.w	r8[0x0],r12
8000437e:	70 08       	ld.w	r8,r8[0x0]
80004380:	58 08       	cp.w	r8,0
80004382:	c0 80       	breq	80004392 <xnl_init+0x2a>
80004384:	4b 38       	lddpc	r8,80004450 <xnl_init+0xe8>
80004386:	70 0c       	ld.w	r12,r8[0x0]
80004388:	30 09       	mov	r9,0
8000438a:	12 9a       	mov	r10,r9
8000438c:	12 9b       	mov	r11,r9
8000438e:	f0 1f 00 32 	mcall	80004454 <xnl_init+0xec>
	
	xnl_frame_tx = xQueueCreate(50, sizeof(xnl_fragment_t *)); //扩大xnl_frame_tx的队列深度
80004392:	30 4b       	mov	r11,4
80004394:	33 2c       	mov	r12,50
80004396:	f0 1f 00 2e 	mcall	8000444c <xnl_init+0xe4>
8000439a:	4b 08       	lddpc	r8,80004458 <xnl_init+0xf0>
8000439c:	91 0c       	st.w	r8[0x0],r12
		
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
8000439e:	30 4b       	mov	r11,4
800043a0:	36 4c       	mov	r12,100
800043a2:	f0 1f 00 2b 	mcall	8000444c <xnl_init+0xe4>
800043a6:	4a e8       	lddpc	r8,8000445c <xnl_init+0xf4>
800043a8:	91 0c       	st.w	r8[0x0],r12
800043aa:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_XNL_STORE; i++ )
	{
		set_xnl_idle(&xnl_store[i]);
800043ac:	10 96       	mov	r6,r8
800043ae:	4a d5       	lddpc	r5,80004460 <xnl_init+0xf8>
800043b0:	6c 0c       	ld.w	r12,r6[0x0]
800043b2:	ea 07 00 0b 	add	r11,r5,r7
800043b6:	f0 1f 00 2c 	mcall	80004464 <xnl_init+0xfc>
800043ba:	ee c7 ff 00 	sub	r7,r7,-256
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
	
	xnl_frame_tx = xQueueCreate(50, sizeof(xnl_fragment_t *)); //扩大xnl_frame_tx的队列深度
		
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
	for(int i= 0; i < MAX_XNL_STORE; i++ )
800043be:	e0 47 64 00 	cp.w	r7,25600
800043c2:	cf 71       	brne	800043b0 <xnl_init+0x48>
	{
		set_xnl_idle(&xnl_store[i]);
	}
	
	/*initialize the queue to send/receive xnl packet */
	phy_xnl_frame_tx = xQueueCreate(TX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
800043c4:	30 4b       	mov	r11,4
800043c6:	31 4c       	mov	r12,20
800043c8:	f0 1f 00 21 	mcall	8000444c <xnl_init+0xe4>
800043cc:	4a 78       	lddpc	r8,80004468 <xnl_init+0x100>
800043ce:	91 0c       	st.w	r8[0x0],r12
	phy_xnl_frame_rx = xQueueCreate(RX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
800043d0:	30 4b       	mov	r11,4
800043d2:	31 4c       	mov	r12,20
800043d4:	f0 1f 00 1e 	mcall	8000444c <xnl_init+0xe4>
800043d8:	4a 58       	lddpc	r8,8000446c <xnl_init+0x104>
800043da:	91 0c       	st.w	r8[0x0],r12
	
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
800043dc:	30 4b       	mov	r11,4
800043de:	30 ac       	mov	r12,10
800043e0:	f0 1f 00 1b 	mcall	8000444c <xnl_init+0xe4>
800043e4:	4a 38       	lddpc	r8,80004470 <xnl_init+0x108>
800043e6:	91 0c       	st.w	r8[0x0],r12
800043e8:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
	{
		set_payload_idle(payload_store[i]);
800043ea:	10 96       	mov	r6,r8
800043ec:	4a 25       	lddpc	r5,80004474 <xnl_init+0x10c>
800043ee:	6c 0c       	ld.w	r12,r6[0x0]
800043f0:	ea 07 00 0b 	add	r11,r5,r7
800043f4:	f0 1f 00 1c 	mcall	80004464 <xnl_init+0xfc>
800043f8:	ee c7 fe 00 	sub	r7,r7,-512
	
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
800043fc:	e0 47 14 00 	cp.w	r7,5120
80004400:	cf 71       	brne	800043ee <xnl_init+0x86>
	
	/*initialize the queue to send/receive payload packet */
	//phy_payload_frame_tx =
	//xQueueCreate(TX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t));
	
	phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
80004402:	30 4b       	mov	r11,4
80004404:	30 5c       	mov	r12,5
80004406:	f0 1f 00 12 	mcall	8000444c <xnl_init+0xe4>
8000440a:	49 c8       	lddpc	r8,80004478 <xnl_init+0x110>
8000440c:	91 0c       	st.w	r8[0x0],r12
	
	#endif /*end if*/
		
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
8000440e:	30 07       	mov	r7,0
80004410:	1a d7       	st.w	--sp,r7
80004412:	1a d7       	st.w	--sp,r7
80004414:	1a d7       	st.w	--sp,r7
80004416:	30 38       	mov	r8,3
80004418:	0e 99       	mov	r9,r7
8000441a:	e0 6a 02 00 	mov	r10,512
8000441e:	49 8b       	lddpc	r11,8000447c <xnl_init+0x114>
80004420:	49 8c       	lddpc	r12,80004480 <xnl_init+0x118>
80004422:	f0 1f 00 19 	mcall	80004484 <xnl_init+0x11c>
	,  tskXNL_PRIORITY //+ 1
	,  NULL
	);
	
	/*this task is used to send xnl message*/
	xTaskCreate(
80004426:	1a d7       	st.w	--sp,r7
80004428:	1a d7       	st.w	--sp,r7
8000442a:	1a d7       	st.w	--sp,r7
8000442c:	30 38       	mov	r8,3
8000442e:	0e 99       	mov	r9,r7
80004430:	e0 6a 00 82 	mov	r10,130
80004434:	49 5b       	lddpc	r11,80004488 <xnl_init+0x120>
80004436:	49 6c       	lddpc	r12,8000448c <xnl_init+0x124>
80004438:	f0 1f 00 13 	mcall	80004484 <xnl_init+0x11c>
	,  tskXNL_PRIORITY//+1
	,  NULL
	);
	
	/*initialize the physical layer*/
	phy_init();
8000443c:	f0 1f 00 15 	mcall	80004490 <xnl_init+0x128>
80004440:	2f ad       	sub	sp,-24
}
80004442:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80004446:	00 00       	add	r0,r0
80004448:	00 00       	add	r0,r0
8000444a:	97 20       	st.w	r11[0x8],r0
8000444c:	80 00       	ld.sh	r0,r0[0x0]
8000444e:	65 80       	ld.w	r0,r2[0x60]
80004450:	00 00       	add	r0,r0
80004452:	0b 40       	ld.w	r0,--r5
80004454:	80 00       	ld.sh	r0,r0[0x0]
80004456:	64 28       	ld.w	r8,r2[0x8]
80004458:	00 00       	add	r0,r0
8000445a:	0b 4c       	ld.w	r12,--r5
8000445c:	00 00       	add	r0,r0
8000445e:	0a a4       	st.w	r5++,r4
80004460:	00 00       	add	r0,r0
80004462:	32 ce       	mov	lr,44
80004464:	80 00       	ld.sh	r0,r0[0x0]
80004466:	2c cc       	sub	r12,-52
80004468:	00 00       	add	r0,r0
8000446a:	0a d4       	st.w	--r5,r4
8000446c:	00 00       	add	r0,r0
8000446e:	0a b4       	st.h	r5++,r4
80004470:	00 00       	add	r0,r0
80004472:	0a a8       	st.w	r5++,r8
80004474:	00 00       	add	r0,r0
80004476:	1e ce       	st.b	pc++,lr
80004478:	00 00       	add	r0,r0
8000447a:	0a e0       	st.h	--r5,r0
8000447c:	80 00       	ld.sh	r0,r0[0x0]
8000447e:	d8 70       	acall	0x87
80004480:	80 00       	ld.sh	r0,r0[0x0]
80004482:	44 94       	lddsp	r4,sp[0x124]
80004484:	80 00       	ld.sh	r0,r0[0x0]
80004486:	6c 9c       	ld.w	r12,r6[0x24]
80004488:	80 00       	ld.sh	r0,r0[0x0]
8000448a:	d8 78       	*unknown*
8000448c:	80 00       	ld.sh	r0,r0[0x0]
8000448e:	44 f4       	lddsp	r4,sp[0x13c]
80004490:	80 00       	ld.sh	r0,r0[0x0]
80004492:	2e a0       	sub	r0,-22

80004494 <xnl_rx_process>:
Calls: 
Called By:task
*/
//portTickType water_value =0;
static void xnl_rx_process(void * pvParameters)
{
80004494:	eb cd 40 fe 	pushm	r1-r7,lr
80004498:	20 1d       	sub	sp,4
	xnl_fragment_t * xnl_ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
8000449a:	49 26       	lddpc	r6,800044e0 <xnl_rx_process+0x4c>
8000449c:	30 05       	mov	r5,0
8000449e:	3f f4       	mov	r4,-1
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
800044a0:	30 c3       	mov	r3,12
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
800044a2:	49 11       	lddpc	r1,800044e4 <xnl_rx_process+0x50>
	if(xnl->xnl_header.opcode > 0x0C)	
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
800044a4:	49 12       	lddpc	r2,800044e8 <xnl_rx_process+0x54>
	xnl_fragment_t * xnl_ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
800044a6:	6c 0c       	ld.w	r12,r6[0x0]
800044a8:	0a 99       	mov	r9,r5
800044aa:	08 9a       	mov	r10,r4
800044ac:	1a 9b       	mov	r11,sp
800044ae:	f0 1f 00 10 	mcall	800044ec <xnl_rx_process+0x58>
800044b2:	58 1c       	cp.w	r12,1
800044b4:	cf 91       	brne	800044a6 <xnl_rx_process+0x12>
		, portMAX_DELAY ))
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
800044b6:	40 0c       	lddsp	r12,sp[0x0]
800044b8:	58 0c       	cp.w	r12,0
800044ba:	cf 60       	breq	800044a6 <xnl_rx_process+0x12>
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
800044bc:	98 28       	ld.sh	r8,r12[0x4]
800044be:	e6 08 19 00 	cp.h	r8,r3
800044c2:	e0 8b 00 0a 	brhi	800044d6 <xnl_rx_process+0x42>
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
800044c6:	5c 78       	castu.h	r8
800044c8:	e4 08 03 29 	ld.w	r9,r2[r8<<0x2]
800044cc:	58 09       	cp.w	r9,0
800044ce:	c0 40       	breq	800044d6 <xnl_rx_process+0x42>
	{
		//log("\n\r R_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:R_xnl指令
		/*execute the function in list*/
		xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec(xnl);
800044d0:	e4 08 03 28 	ld.w	r8,r2[r8<<0x2]
800044d4:	5d 18       	icall	r8
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
800044d6:	62 0c       	ld.w	r12,r1[0x0]
800044d8:	40 0b       	lddsp	r11,sp[0x0]
800044da:	f0 1f 00 06 	mcall	800044f0 <xnl_rx_process+0x5c>
800044de:	ce 4b       	rjmp	800044a6 <xnl_rx_process+0x12>
800044e0:	00 00       	add	r0,r0
800044e2:	0a b4       	st.h	r5++,r4
800044e4:	00 00       	add	r0,r0
800044e6:	0a a4       	st.w	r5++,r4
800044e8:	00 00       	add	r0,r0
800044ea:	04 f4       	st.b	--r2,r4
800044ec:	80 00       	ld.sh	r0,r0[0x0]
800044ee:	62 1c       	ld.w	r12,r1[0x4]
800044f0:	80 00       	ld.sh	r0,r0[0x0]
800044f2:	2c cc       	sub	r12,-52

800044f4 <xnl_tx_process>:
	phy_tx -- physical.c
Called By: task
*/
//portTickType tx_water_value =0;
static void xnl_tx_process(void * pvParameters)
{
800044f4:	d4 31       	pushm	r0-r7,lr
	
	
	for(;;)
	{		
		//tx_water_value = uxTaskGetStackHighWaterMark(NULL);
		switch(xnl_tx_state)
800044f6:	4a a6       	lddpc	r6,8000459c <xnl_tx_process+0xa8>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
800044f8:	4a a2       	lddpc	r2,800045a0 <xnl_tx_process+0xac>
800044fa:	4a b4       	lddpc	r4,800045a4 <xnl_tx_process+0xb0>
800044fc:	30 07       	mov	r7,0
800044fe:	3f f1       	mov	r1,-1
					if(NULL == ptr)
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
80004500:	30 00       	mov	r0,0
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;				
80004502:	4a a5       	lddpc	r5,800045a8 <xnl_tx_process+0xb4>
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
80004504:	4a a3       	lddpc	r3,800045ac <xnl_tx_process+0xb8>
	
	
	for(;;)
	{		
		//tx_water_value = uxTaskGetStackHighWaterMark(NULL);
		switch(xnl_tx_state)
80004506:	6c 08       	ld.w	r8,r6[0x0]
80004508:	58 08       	cp.w	r8,0
8000450a:	c0 40       	breq	80004512 <xnl_tx_process+0x1e>
8000450c:	58 18       	cp.w	r8,1
8000450e:	cf d1       	brne	80004508 <xnl_tx_process+0x14>
80004510:	c2 48       	rjmp	80004558 <xnl_tx_process+0x64>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
80004512:	64 0c       	ld.w	r12,r2[0x0]
80004514:	0e 99       	mov	r9,r7
80004516:	02 9a       	mov	r10,r1
80004518:	08 9b       	mov	r11,r4
8000451a:	f0 1f 00 26 	mcall	800045b0 <xnl_tx_process+0xbc>
8000451e:	58 1c       	cp.w	r12,1
80004520:	cf 31       	brne	80004506 <xnl_tx_process+0x12>
					, portMAX_DELAY ))
				{				
					if(NULL == ptr)
80004522:	68 0b       	ld.w	r11,r4[0x0]
80004524:	58 0b       	cp.w	r11,0
80004526:	cf 00       	breq	80004506 <xnl_tx_process+0x12>
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
80004528:	96 28       	ld.sh	r8,r11[0x4]
8000452a:	e0 08 19 00 	cp.h	r8,r0
8000452e:	c0 71       	brne	8000453c <xnl_tx_process+0x48>
					{
						/*invalid XNL opcode*/
						set_xnl_idle(ptr);
80004530:	4a 18       	lddpc	r8,800045b4 <xnl_tx_process+0xc0>
80004532:	70 08       	ld.w	r8,r8[0x0]
80004534:	10 9c       	mov	r12,r8
80004536:	f0 1f 00 21 	mcall	800045b8 <xnl_tx_process+0xc4>
						break;
8000453a:	ce 6b       	rjmp	80004506 <xnl_tx_process+0x12>
					}
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
8000453c:	16 9c       	mov	r12,r11
8000453e:	f0 1f 00 20 	mcall	800045bc <xnl_tx_process+0xc8>
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;				
80004542:	30 18       	mov	r8,1
80004544:	8b 08       	st.w	r5[0x0],r8
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
80004546:	66 0c       	ld.w	r12,r3[0x0]
80004548:	0e 99       	mov	r9,r7
8000454a:	0e 9a       	mov	r10,r7
8000454c:	0e 9b       	mov	r11,r7
8000454e:	f0 1f 00 19 	mcall	800045b0 <xnl_tx_process+0xbc>
					xnl_tx_state = WAITING_FOR_REPLY;
80004552:	30 18       	mov	r8,1
80004554:	8d 08       	st.w	r6[0x0],r8
80004556:	cd 8b       	rjmp	80004506 <xnl_tx_process+0x12>
				}
				break;
			
			/*wait XNL reply*/			
			case WAITING_FOR_REPLY://直到回答ACK才再发送下一条data/control
				if(pdTRUE == xSemaphoreTake( xnl_timeout_semphr
80004558:	66 0c       	ld.w	r12,r3[0x0]
8000455a:	0e 99       	mov	r9,r7
8000455c:	36 4a       	mov	r10,100
8000455e:	0e 9b       	mov	r11,r7
80004560:	f0 1f 00 14 	mcall	800045b0 <xnl_tx_process+0xbc>
80004564:	58 1c       	cp.w	r12,1
80004566:	c0 81       	brne	80004576 <xnl_tx_process+0x82>
					, ( portTickType )50*2/ portTICK_RATE_MS))//按ADK文档中提示500ms一次超时,但是实际情况下程序中启用freertos的任务延时不够精准。因此根据经验需要降低延时等待的时间
				{
					/*No timeout*/
					set_xnl_idle(ptr);			
80004568:	49 38       	lddpc	r8,800045b4 <xnl_tx_process+0xc0>
8000456a:	70 0c       	ld.w	r12,r8[0x0]
8000456c:	68 0b       	ld.w	r11,r4[0x0]
8000456e:	f0 1f 00 13 	mcall	800045b8 <xnl_tx_process+0xc4>
					xnl_tx_state = WAITING_FOR_TX;
80004572:	8d 07       	st.w	r6[0x0],r7
80004574:	cc 9b       	rjmp	80004506 <xnl_tx_process+0x12>
				}
				else
				{
					/*time out*/
					if(xnl_send_times <= MIN_RESEND_TIMES)
80004576:	6a 08       	ld.w	r8,r5[0x0]
80004578:	58 38       	cp.w	r8,3
8000457a:	e0 89 00 09 	brgt	8000458c <xnl_tx_process+0x98>
					{
						/*If times smaller than A supermarket, then resend the 
						instructions*/
						phy_tx((phy_fragment_t *)ptr);
8000457e:	68 0c       	ld.w	r12,r4[0x0]
80004580:	f0 1f 00 0f 	mcall	800045bc <xnl_tx_process+0xc8>
						xnl_send_times++;
80004584:	6a 08       	ld.w	r8,r5[0x0]
80004586:	2f f8       	sub	r8,-1
80004588:	8b 08       	st.w	r5[0x0],r8
8000458a:	cb eb       	rjmp	80004506 <xnl_tx_process+0x12>
					}
					else
					{
						//can not send data, disconnected						
						//vPortFree(ptr);	
						set_xnl_idle(ptr);									
8000458c:	48 a8       	lddpc	r8,800045b4 <xnl_tx_process+0xc0>
8000458e:	70 0c       	ld.w	r12,r8[0x0]
80004590:	68 0b       	ld.w	r11,r4[0x0]
80004592:	f0 1f 00 0a 	mcall	800045b8 <xnl_tx_process+0xc4>
						xnl_tx_state = WAITING_FOR_TX;
80004596:	8d 07       	st.w	r6[0x0],r7
80004598:	cb 7b       	rjmp	80004506 <xnl_tx_process+0x12>
8000459a:	00 00       	add	r0,r0
8000459c:	00 00       	add	r0,r0
8000459e:	0b 48       	ld.w	r8,--r5
800045a0:	00 00       	add	r0,r0
800045a2:	0b 4c       	ld.w	r12,--r5
800045a4:	00 00       	add	r0,r0
800045a6:	0b 54       	ld.sh	r4,--r5
800045a8:	00 00       	add	r0,r0
800045aa:	0b 50       	ld.sh	r0,--r5
800045ac:	00 00       	add	r0,r0
800045ae:	0b 40       	ld.w	r0,--r5
800045b0:	80 00       	ld.sh	r0,r0[0x0]
800045b2:	62 1c       	ld.w	r12,r1[0x4]
800045b4:	00 00       	add	r0,r0
800045b6:	0a a4       	st.w	r5++,r4
800045b8:	80 00       	ld.sh	r0,r0[0x0]
800045ba:	2c cc       	sub	r12,-52
800045bc:	80 00       	ld.sh	r0,r0[0x0]
800045be:	2c ec       	sub	r12,-50

800045c0 <xnl_tx>:
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
{
800045c0:	eb cd 40 c0 	pushm	r6-r7,lr
800045c4:	20 1d       	sub	sp,4
800045c6:	18 96       	mov	r6,r12
	message that is sent. The same value should be used for all retries.
	*/
	static U8 flags = 0;
	
	/*If the value is DEFAULT_VALUE, the value will be modified*/
	if(DEFAULT_VALUE == xnl->xnl_header.flags)
800045c8:	98 39       	ld.sh	r9,r12[0x6]
800045ca:	3f f8       	mov	r8,-1
800045cc:	f0 09 19 00 	cp.h	r9,r8
800045d0:	c0 a1       	brne	800045e4 <xnl_tx+0x24>
	{
		xnl->xnl_header.flags =  0x0100 | ((++flags) & 0x07);
800045d2:	4a e9       	lddpc	r9,80004688 <xnl_tx+0xc8>
800045d4:	13 88       	ld.ub	r8,r9[0x0]
800045d6:	2f f8       	sub	r8,-1
800045d8:	5c 58       	castu.b	r8
800045da:	b2 88       	st.b	r9[0x0],r8
800045dc:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
800045e0:	a9 a8       	sbr	r8,0x8
800045e2:	b8 38       	st.h	r12[0x6],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.destination)
800045e4:	8c 49       	ld.sh	r9,r6[0x8]
800045e6:	3f f8       	mov	r8,-1
800045e8:	f0 09 19 00 	cp.h	r9,r8
800045ec:	c0 41       	brne	800045f4 <xnl_tx+0x34>
	{		
		/*Use actual Master address.*/
		xnl->xnl_header.destination = xnl_information.master_address;
800045ee:	4a 88       	lddpc	r8,8000468c <xnl_tx+0xcc>
800045f0:	90 18       	ld.sh	r8,r8[0x2]
800045f2:	ac 48       	st.h	r6[0x8],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.source)
800045f4:	8c 59       	ld.sh	r9,r6[0xa]
800045f6:	3f f8       	mov	r8,-1
800045f8:	f0 09 19 00 	cp.h	r9,r8
800045fc:	c0 41       	brne	80004604 <xnl_tx+0x44>
	{
		/*Use Temporary address.*/	
		xnl->xnl_header.source = xnl_information.device_address;
800045fe:	4a 48       	lddpc	r8,8000468c <xnl_tx+0xcc>
80004600:	90 28       	ld.sh	r8,r8[0x4]
80004602:	ac 58       	st.h	r6[0xa],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
80004604:	8c 69       	ld.sh	r9,r6[0xc]
80004606:	3f f8       	mov	r8,-1
80004608:	f0 09 19 00 	cp.h	r9,r8
8000460c:	c0 e1       	brne	80004628 <xnl_tx+0x68>
	{		
		xnl->xnl_header.transaction_id = 
		  ((++xnl_information.transaction_id) & 0xFF) 
8000460e:	4a 08       	lddpc	r8,8000468c <xnl_tx+0xcc>
80004610:	90 49       	ld.sh	r9,r8[0x8]
80004612:	2f f9       	sub	r9,-1
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
80004614:	b0 49       	st.h	r8[0x8],r9
		  ((++xnl_information.transaction_id) & 0xFF) 
80004616:	90 4a       	ld.sh	r10,r8[0x8]
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
80004618:	90 49       	ld.sh	r9,r8[0x8]
8000461a:	e0 19 ff 00 	andl	r9,0xff00
8000461e:	f1 da c0 08 	bfextu	r8,r10,0x0,0x8
80004622:	f3 e8 10 08 	or	r8,r9,r8
80004626:	ac 68       	st.h	r6[0xc],r8
	U16  sumScratch;
	U32  indextohWord;
	S32  hWordswithinFrag;
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
80004628:	0d 98       	ld.ub	r8,r6[0x1]
8000462a:	20 28       	sub	r8,2
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
8000462c:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
80004630:	10 0c       	add	r12,r8
80004632:	a1 5c       	asr	r12,0x1
	indextohWord = 2;
	while (hWordswithinFrag > 0)
80004634:	58 0c       	cp.w	r12,0
80004636:	e0 89 00 04 	brgt	8000463e <xnl_tx+0x7e>
8000463a:	30 09       	mov	r9,0
8000463c:	c0 d8       	rjmp	80004656 <xnl_tx+0x96>
8000463e:	ec ca ff fc 	sub	r10,r6,-4
Parameters: xnl_fragment_t * 
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
80004642:	2f ec       	sub	r12,-2
80004644:	30 09       	mov	r9,0
80004646:	30 28       	mov	r8,2
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
	{
		sumScratch += *((U16*)xnl + indextohWord);
80004648:	15 1b       	ld.sh	r11,r10++
8000464a:	f6 09 00 09 	add	r9,r11,r9
8000464e:	5c 89       	casts.h	r9
		indextohWord     += 1;
80004650:	2f f8       	sub	r8,-1
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
80004652:	18 38       	cp.w	r8,r12
80004654:	cf a1       	brne	80004648 <xnl_tx+0x88>
		  ((++xnl_information.transaction_id) & 0xFF) 
		| (xnl_information.transaction_id & 0xFF00);
	}
	
	/*count check sum */
	xnl->phy_header.check_sum = check_sum( xnl );
80004656:	5c 39       	neg	r9
80004658:	ac 19       	st.h	r6[0x2],r9
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
8000465a:	48 e8       	lddpc	r8,80004690 <xnl_tx+0xd0>
8000465c:	70 0c       	ld.w	r12,r8[0x0]
8000465e:	f0 1f 00 0e 	mcall	80004694 <xnl_tx+0xd4>
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
80004662:	c1 00       	breq	80004682 <xnl_tx+0xc2>
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
80004664:	fa c7 ff fc 	sub	r7,sp,-4
80004668:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
	{
		memcpy(ptr, xnl, sizeof(xnl_fragment_t));
8000466a:	e0 6a 01 00 	mov	r10,256
8000466e:	0c 9b       	mov	r11,r6
80004670:	f0 1f 00 0a 	mcall	80004698 <xnl_tx+0xd8>
	
		/*push to queue and send*/
		
		//log("ptr -%8x", ptr);
		
		xQueueSend(xnl_frame_tx, &ptr, 0);
80004674:	48 a8       	lddpc	r8,8000469c <xnl_tx+0xdc>
80004676:	70 0c       	ld.w	r12,r8[0x0]
80004678:	30 09       	mov	r9,0
8000467a:	12 9a       	mov	r10,r9
8000467c:	1a 9b       	mov	r11,sp
8000467e:	f0 1f 00 09 	mcall	800046a0 <xnl_tx+0xe0>
		//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
		
		//vPortFree(ptr);
	}
}
80004682:	2f fd       	sub	sp,-4
80004684:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004688:	00 00       	add	r0,r0
8000468a:	0b 44       	ld.w	r4,--r5
8000468c:	00 00       	add	r0,r0
8000468e:	97 20       	st.w	r11[0x8],r0
80004690:	00 00       	add	r0,r0
80004692:	0a a4       	st.w	r5++,r4
80004694:	80 00       	ld.sh	r0,r0[0x0]
80004696:	2e 78       	sub	r8,-25
80004698:	80 00       	ld.sh	r0,r0[0x0]
8000469a:	78 dc       	ld.w	r12,r12[0x34]
8000469c:	00 00       	add	r0,r0
8000469e:	0b 4c       	ld.w	r12,--r5
800046a0:	80 00       	ld.sh	r0,r0[0x0]
800046a2:	64 28       	ld.w	r8,r2[0x8]

800046a4 <xnl_data_msg_func>:
Description: process while receive data message.
Calls:xnl_send_msg_ack, xcmp_exec(function in xcmp)
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_data_msg_func(xnl_fragment_t * xnl)
{
800046a4:	eb cd 40 80 	pushm	r7,lr
800046a8:	fa cd 01 00 	sub	sp,sp,256
800046ac:	18 97       	mov	r7,r12
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
800046ae:	e0 68 40 0e 	mov	r8,16398
800046b2:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
800046b4:	3f f8       	mov	r8,-1
800046b6:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG_ACK;
800046b8:	30 c8       	mov	r8,12
800046ba:	ba 28       	st.h	sp[0x4],r8
	
	/*Turn around Flags.*/	
	xnl_frame.xnl_header.flags = hdr->flags;
800046bc:	98 38       	ld.sh	r8,r12[0x6]
800046be:	ba 38       	st.h	sp[0x6],r8
	
	/*ACK Destination Address is Source of XNL_Message.*/
	xnl_frame.xnl_header.destination = hdr->source;
800046c0:	98 58       	ld.sh	r8,r12[0xa]
800046c2:	ba 48       	st.h	sp[0x8],r8
	
	/*ACK Source Address is my address.*/
	xnl_frame.xnl_header.source = hdr->destination;
800046c4:	98 48       	ld.sh	r8,r12[0x8]
800046c6:	ba 58       	st.h	sp[0xa],r8
	
	/*Turn around Transaction ID.*/
	xnl_frame.xnl_header.transaction_id = hdr->transaction_id;
800046c8:	98 68       	ld.sh	r8,r12[0xc]
800046ca:	ba 68       	st.h	sp[0xc],r8
	xnl_frame.xnl_header.payload_length = 0;
800046cc:	30 08       	mov	r8,0
800046ce:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
800046d0:	1a 9c       	mov	r12,sp
800046d2:	f0 1f 00 0a 	mcall	800046f8 <xnl_data_msg_func+0x54>
	transmitter, but possibly is waiting in Queue with immediate timeout.
	 */
	xnl_send_msg_ack(&xnl->xnl_header);
	
	/*exec xcmp function*/
	xcmp_exec(xnl->xnl_payload.xnl_content_data_msg);//xcmp_rx
800046d6:	fa cd 00 cc 	sub	sp,sp,204
800046da:	e0 6a 00 ca 	mov	r10,202
800046de:	ee cb ff f0 	sub	r11,r7,-16
800046e2:	1a 9c       	mov	r12,sp
800046e4:	f0 1f 00 06 	mcall	800046fc <xnl_data_msg_func+0x58>
800046e8:	48 68       	lddpc	r8,80004700 <xnl_data_msg_func+0x5c>
800046ea:	70 08       	ld.w	r8,r8[0x0]
800046ec:	5d 18       	icall	r8
800046ee:	fa cd ff 34 	sub	sp,sp,-204
}
800046f2:	2c 0d       	sub	sp,-256
800046f4:	e3 cd 80 80 	ldm	sp++,r7,pc
800046f8:	80 00       	ld.sh	r0,r0[0x0]
800046fa:	45 c0       	lddsp	r0,sp[0x170]
800046fc:	80 00       	ld.sh	r0,r0[0x0]
800046fe:	78 dc       	ld.w	r12,r12[0x34]
80004700:	00 00       	add	r0,r0
80004702:	0b 58       	ld.sh	r8,--r5

80004704 <xnl_device_auth_reply_func>:
Description: process while receive device auth reply.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_auth_reply_func(xnl_fragment_t * xnl)
{
80004704:	d4 21       	pushm	r4-r7,lr
80004706:	fa cd 01 00 	sub	sp,sp,256
8000470a:	18 97       	mov	r7,r12
	the receiving device and will be used to authenticate the connection 
	request. 5.4.4
	*/
	//log("R_xnl-opcode:%4x", xnl->xnl_header.opcode);
	
	if(xnl_information.is_connected)
8000470c:	4c 28       	lddpc	r8,80004814 <xnl_device_auth_reply_func+0x110>
8000470e:	11 88       	ld.ub	r8,r8[0x0]
80004710:	58 08       	cp.w	r8,0
80004712:	e0 81 00 7f 	brne	80004810 <xnl_device_auth_reply_func+0x10c>
	{
		return;		
	}
	
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);
80004716:	4c 18       	lddpc	r8,80004818 <xnl_device_auth_reply_func+0x114>
80004718:	70 0c       	ld.w	r12,r8[0x0]
8000471a:	30 09       	mov	r9,0
8000471c:	12 9a       	mov	r10,r9
8000471e:	12 9b       	mov	r11,r9
80004720:	f0 1f 00 3f 	mcall	8000481c <xnl_device_auth_reply_func+0x118>

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
80004724:	ef 09 00 10 	ld.sh	r9,r7[16]
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
80004728:	4b b8       	lddpc	r8,80004814 <xnl_device_auth_reply_func+0x110>
8000472a:	b0 29       	st.h	r8[0x4],r9
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
	
	/*Get Array of values to be encrypted into an aligned 2X32bits.*/
	v_vector[0] =
8000472c:	ef 39 00 12 	ld.ub	r9,r7[18]
80004730:	ef 38 00 13 	ld.ub	r8,r7[19]
80004734:	b1 68       	lsl	r8,0x10
80004736:	f1 e9 11 89 	or	r9,r8,r9<<0x18
8000473a:	ef 38 00 15 	ld.ub	r8,r7[21]
8000473e:	f3 e8 10 08 	or	r8,r9,r8
80004742:	ef 39 00 14 	ld.ub	r9,r7[20]
80004746:	f1 e9 10 89 	or	r9,r8,r9<<0x8
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[2])<<8	  
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[3]);
	
	v_vector[1] =
8000474a:	ef 3a 00 16 	ld.ub	r10,r7[22]
8000474e:	ef 38 00 17 	ld.ub	r8,r7[23]
80004752:	b1 68       	lsl	r8,0x10
80004754:	f1 ea 11 8a 	or	r10,r8,r10<<0x18
80004758:	ef 38 00 19 	ld.ub	r8,r7[25]
8000475c:	f5 e8 10 08 	or	r8,r10,r8
80004760:	ef 3a 00 18 	ld.ub	r10,r7[24]
80004764:	f1 ea 10 88 	or	r8,r8,r10<<0x8
80004768:	30 0a       	mov	r10,0
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
8000476a:	e0 64 79 b9 	mov	r4,31161
8000476e:	ea 14 9e 37 	orh	r4,0x9e37
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
80004772:	e0 65 45 07 	mov	r5,17671
80004776:	ea 15 8a bd 	orh	r5,0x8abd
8000477a:	e0 66 f9 3d 	mov	r6,63805
8000477e:	ea 16 99 68 	orh	r6,0x9968
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
80004782:	e0 6e b8 cf 	mov	lr,47311
80004786:	ea 1e 36 83 	orh	lr,0x3683
8000478a:	e0 67 aa 1c 	mov	r7,43548
8000478e:	ea 17 9c 36 	orh	r7,0x9c36
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
80004792:	08 0a       	add	r10,r4
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
80004794:	f4 08 00 0c 	add	r12,r10,r8
80004798:	f0 0b 15 04 	lsl	r11,r8,0x4
8000479c:	0a 0b       	add	r11,r5
8000479e:	f9 eb 20 0b 	eor	r11,r12,r11
800047a2:	f0 0c 16 05 	lsr	r12,r8,0x5
800047a6:	0c 0c       	add	r12,r6
800047a8:	18 5b       	eor	r11,r12
800047aa:	16 09       	add	r9,r11
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
800047ac:	f2 0c 15 04 	lsl	r12,r9,0x4
800047b0:	1c 0c       	add	r12,lr
800047b2:	f2 0b 16 05 	lsr	r11,r9,0x5
800047b6:	0e 0b       	add	r11,r7
800047b8:	f9 eb 20 0b 	eor	r11,r12,r11
800047bc:	f2 0a 00 0c 	add	r12,r9,r10
800047c0:	18 5b       	eor	r11,r12
800047c2:	16 08       	add	r8,r11
{
	register U32 y=v[0], z=v[1], sum=0;
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
800047c4:	e0 6b 37 20 	mov	r11,14112
800047c8:	ea 1b c6 ef 	orh	r11,0xc6ef
800047cc:	16 3a       	cp.w	r10,r11
800047ce:	ce 21       	brne	80004792 <xnl_device_auth_reply_func+0x8e>
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :24 + 2(xnl length(24) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 24 + 2;
800047d0:	e0 6a 40 1a 	mov	r10,16410
800047d4:	ba 0a       	st.h	sp[0x0],r10
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
800047d6:	3f fa       	mov	r10,-1
800047d8:	ba 1a       	st.h	sp[0x2],r10
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_CONN_REQUEST;
800047da:	30 6b       	mov	r11,6
800047dc:	ba 2b       	st.h	sp[0x4],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
800047de:	ba 3a       	st.h	sp[0x6],r10
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
800047e0:	48 db       	lddpc	r11,80004814 <xnl_device_auth_reply_func+0x110>
800047e2:	96 1c       	ld.sh	r12,r11[0x2]
800047e4:	ba 4c       	st.h	sp[0x8],r12
	message here, and all will receive the same DEVICE_CONN_REPLY. Not real 
	sure what's going to happen with multiple conrol heads, etc. One suspects 
	the Rocket Scientists will eventually figure this out, and demand a 
	transaction ID based on Device Type in the XNL_DEVICE_AUTH_KEY_REQUEST.
	*/
	xnl_frame.xnl_header.source = xnl_information.device_address;
800047e6:	96 2b       	ld.sh	r11,r11[0x4]
800047e8:	ba 5b       	st.h	sp[0xa],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
800047ea:	ba 6a       	st.h	sp[0xc],r10
	
    /*his message contains 12 payload bytes*/	
	xnl_frame.xnl_header.payload_length = 0x000C;
800047ec:	30 ca       	mov	r10,12
800047ee:	ba 7a       	st.h	sp[0xe],r10
	
	/*No Preferred XNL Address*/
	xnl_frame.xnl_payload.xnl_content_device_conn_req.preferred_xnl_address = 
800047f0:	30 0a       	mov	r10,0
800047f2:	fb 5a 00 10 	st.h	sp[16],r10
	XCMP/XNL Development Specification Section 4.5.3.2.1.
	Same as in MOTOTRBO?XCMP/XNL Development Specification?
	evice_type--Option Board(0x07)
	authentication_index--Option Board(0x02)
	*/	
	xnl_frame.xnl_payload.xnl_content_device_conn_req.device_type = 0x07;
800047f6:	30 7a       	mov	r10,7
800047f8:	fb 6a 00 12 	st.b	sp[18],r10
	xnl_frame.xnl_payload.xnl_content_device_conn_req.authentication_index =
800047fc:	30 2a       	mov	r10,2
800047fe:	fb 6a 00 13 	st.b	sp[19],r10
	                                                                       0x02;
		
	//We know encrypted array happens to be aligned to 32-bit boundary.
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
80004802:	fa ca ff ec 	sub	r10,sp,-20
80004806:	95 09       	st.w	r10[0x0],r9
	                         .encrypted_authentication_value[0])) = w_vector[0];
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
80004808:	95 18       	st.w	r10[0x4],r8
	                         .encrypted_authentication_value[4])) = w_vector[1];
	
	/*send XNL message*/
	xnl_tx(&xnl_frame);
8000480a:	1a 9c       	mov	r12,sp
8000480c:	f0 1f 00 05 	mcall	80004820 <xnl_device_auth_reply_func+0x11c>
}
80004810:	2c 0d       	sub	sp,-256
80004812:	d8 22       	popm	r4-r7,pc
80004814:	00 00       	add	r0,r0
80004816:	97 20       	st.w	r11[0x8],r0
80004818:	00 00       	add	r0,r0
8000481a:	0b 40       	ld.w	r0,--r5
8000481c:	80 00       	ld.sh	r0,r0[0x0]
8000481e:	64 28       	ld.w	r8,r2[0x8]
80004820:	80 00       	ld.sh	r0,r0[0x0]
80004822:	45 c0       	lddsp	r0,sp[0x170]

80004824 <xnl_master_status_brdcst_func>:
Description: process while receive master status boardcast.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_master_status_brdcst_func(xnl_fragment_t * xnl)
{	
80004824:	eb cd 40 80 	pushm	r7,lr
80004828:	fa cd 01 00 	sub	sp,sp,256
8000482c:	18 97       	mov	r7,r12
	not an XNL_DATA_MSG has been sent out. This will indicate to a connecting 
	device that it has missed messages. The XNL header will contain the 
	master?XNL address. 5.4.1
	*/
	
	if(xnl_information.is_connected)
8000482e:	49 28       	lddpc	r8,80004874 <xnl_master_status_brdcst_func+0x50>
80004830:	11 88       	ld.ub	r8,r8[0x0]
80004832:	58 08       	cp.w	r8,0
80004834:	c1 c1       	brne	8000486c <xnl_master_status_brdcst_func+0x48>
	{
		return;	
	}
	
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);	
80004836:	49 18       	lddpc	r8,80004878 <xnl_master_status_brdcst_func+0x54>
80004838:	70 0c       	ld.w	r12,r8[0x0]
8000483a:	30 09       	mov	r9,0
8000483c:	12 9a       	mov	r10,r9
8000483e:	12 9b       	mov	r11,r9
80004840:	f0 1f 00 0f 	mcall	8000487c <xnl_master_status_brdcst_func+0x58>

	//log("xnl-ma:%4x", xnl->xnl_header.source);
	/*get the master adderss from this message*/	
	xnl_information.master_address = xnl->xnl_header.source;	
80004844:	8e 58       	ld.sh	r8,r7[0xa]
80004846:	48 c9       	lddpc	r9,80004874 <xnl_master_status_brdcst_func+0x50>
80004848:	b2 18       	st.h	r9[0x2],r8
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
8000484a:	e0 68 40 0e 	mov	r8,16398
8000484e:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004850:	3f f8       	mov	r8,-1
80004852:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_AUTH_KEY_REQUEST;
80004854:	30 4a       	mov	r10,4
80004856:	ba 2a       	st.h	sp[0x4],r10
		
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/	
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
80004858:	ba 38       	st.h	sp[0x6],r8
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
8000485a:	92 19       	ld.sh	r9,r9[0x2]
8000485c:	ba 49       	st.h	sp[0x8],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.source = DEFAULT_VALUE;
8000485e:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80004860:	ba 68       	st.h	sp[0xc],r8
		
	xnl_frame.xnl_header.payload_length = 0;
80004862:	30 08       	mov	r8,0
80004864:	ba 78       	st.h	sp[0xe],r8
	
	/*send XNL message*/	
	xnl_tx(&xnl_frame);
80004866:	1a 9c       	mov	r12,sp
80004868:	f0 1f 00 06 	mcall	80004880 <xnl_master_status_brdcst_func+0x5c>
}
8000486c:	2c 0d       	sub	sp,-256
8000486e:	e3 cd 80 80 	ldm	sp++,r7,pc
80004872:	00 00       	add	r0,r0
80004874:	00 00       	add	r0,r0
80004876:	97 20       	st.w	r11[0x8],r0
80004878:	00 00       	add	r0,r0
8000487a:	0b 40       	ld.w	r0,--r5
8000487c:	80 00       	ld.sh	r0,r0[0x0]
8000487e:	64 28       	ld.w	r8,r2[0x8]
80004880:	80 00       	ld.sh	r0,r0[0x0]
80004882:	45 c0       	lddsp	r0,sp[0x170]

80004884 <xnl_device_conn_reply_func>:
Description: process while receive device conn reply.
Calls:xSemaphoreGive--freestos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_conn_reply_func(xnl_fragment_t * xnl)
{
80004884:	eb cd 40 80 	pushm	r7,lr
80004888:	18 97       	mov	r7,r12
	transaction ID and an 8-byte encrypted value that the device can use to 
	authenticate the master. XCMP/XNL Development Guide 5.4.6
	*/
	
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);
8000488a:	49 28       	lddpc	r8,800048d0 <xnl_device_conn_reply_func+0x4c>
8000488c:	70 0c       	ld.w	r12,r8[0x0]
8000488e:	30 09       	mov	r9,0
80004890:	12 9a       	mov	r10,r9
80004892:	12 9b       	mov	r11,r9
80004894:	f0 1f 00 10 	mcall	800048d4 <xnl_device_conn_reply_func+0x50>

	/*Test result code*/
	if((xnl->xnl_payload.xnl_content_device_conn_reply.result_base & 0x0000FF00)
80004898:	ef 18 00 10 	ld.uh	r8,r7[16]
8000489c:	10 99       	mov	r9,r8
8000489e:	e2 19 ff 00 	andl	r9,0xff00,COH
800048a2:	e0 49 01 00 	cp.w	r9,256
800048a6:	c0 60       	breq	800048b2 <xnl_device_conn_reply_func+0x2e>
		/*
		Rejected. The device must retry the authentication process at this 
		point by sending out a new AUTH_KEY_REQUEST message. XCMP/XNL 
		Development Guide Section 5.2.3
		*/
		xnl_master_status_brdcst_func(xnl);			
800048a8:	0e 9c       	mov	r12,r7
800048aa:	f0 1f 00 0c 	mcall	800048d8 <xnl_device_conn_reply_func+0x54>
800048ae:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/*connection accepted*/		
		/*Record Transaction ID Base*/
		xnl_information.transaction_id =  
800048b2:	a9 68       	lsl	r8,0x8
800048b4:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
800048b8:	48 98       	lddpc	r8,800048dc <xnl_device_conn_reply_func+0x58>
800048ba:	b0 49       	st.h	r8[0x8],r9
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
800048bc:	ef 09 00 14 	ld.sh	r9,r7[20]
		xnl_information.transaction_id =  
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
800048c0:	b0 39       	st.h	r8[0x6],r9
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
800048c2:	ef 09 00 12 	ld.sh	r9,r7[18]
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
800048c6:	b0 29       	st.h	r8[0x4],r9
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
		
		/*connect finish*/
		xnl_information.is_connected = TRUE;
800048c8:	30 19       	mov	r9,1
800048ca:	b0 89       	st.b	r8[0x0],r9
800048cc:	e3 cd 80 80 	ldm	sp++,r7,pc
800048d0:	00 00       	add	r0,r0
800048d2:	0b 40       	ld.w	r0,--r5
800048d4:	80 00       	ld.sh	r0,r0[0x0]
800048d6:	64 28       	ld.w	r8,r2[0x8]
800048d8:	80 00       	ld.sh	r0,r0[0x0]
800048da:	48 24       	lddpc	r4,800048e0 <xnl_send_device_master_query>
800048dc:	00 00       	add	r0,r0
800048de:	97 20       	st.w	r11[0x8],r0

800048e0 <xnl_send_device_master_query>:
Description: send device_master_query to connect radio.
Calls:xnl_tx
Call By:xnl_init
*/
void xnl_send_device_master_query(void)
{
800048e0:	d4 01       	pushm	lr
800048e2:	fa cd 01 00 	sub	sp,sp,256
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
800048e6:	e0 68 40 0e 	mov	r8,16398
800048ea:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
800048ec:	3f f8       	mov	r8,-1
800048ee:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_MASTER_QUERY;
800048f0:	30 38       	mov	r8,3
800048f2:	ba 28       	st.h	sp[0x4],r8
	
	/*The initial value*/
	xnl_frame.xnl_header.flags = 0;
800048f4:	30 08       	mov	r8,0
800048f6:	ba 38       	st.h	sp[0x6],r8
	
	/*XNL address of the master device, if known;otherwise 0x0000*/
	xnl_frame.xnl_header.destination = 0;
800048f8:	ba 48       	st.h	sp[0x8],r8
	
	/*XNL address, if assigned; otherwise 0x0000*/
	xnl_frame.xnl_header.source = 0;
800048fa:	ba 58       	st.h	sp[0xa],r8
	
	/*No transaction ID required for this message*/
	xnl_frame.xnl_header.transaction_id = 0;
800048fc:	ba 68       	st.h	sp[0xc],r8
	
	/*This message contains no payload*/
	xnl_frame.xnl_header.payload_length = 0;
800048fe:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004900:	1a 9c       	mov	r12,sp
80004902:	f0 1f 00 03 	mcall	8000490c <xnl_send_device_master_query+0x2c>
}
80004906:	2c 0d       	sub	sp,-256
80004908:	d8 02       	popm	pc
8000490a:	00 00       	add	r0,r0
8000490c:	80 00       	ld.sh	r0,r0[0x0]
8000490e:	45 c0       	lddsp	r0,sp[0x170]

80004910 <RC522_SPI_SetSpeed>:
	//SET_SPI_CS;

}

void RC522_SPI_SetSpeed(U16 SPI_BaudRatePrescaler)
{
80004910:	d4 01       	pushm	lr
	spi->csr0 = (spi->csr0 & (U16)0x00FF) |SPI_BaudRatePrescaler;
80004912:	48 78       	lddpc	r8,8000492c <RC522_SPI_SetSpeed+0x1c>
80004914:	70 09       	ld.w	r9,r8[0x0]
80004916:	72 ca       	ld.w	r10,r9[0x30]
80004918:	5c 7c       	castu.h	r12
8000491a:	f5 da c0 08 	bfextu	r10,r10,0x0,0x8
8000491e:	f9 ea 10 0a 	or	r10,r12,r10
80004922:	93 ca       	st.w	r9[0x30],r10

	spi_enable(spi); /*!< SD_SPI enable */
80004924:	70 0c       	ld.w	r12,r8[0x0]
80004926:	f0 1f 00 03 	mcall	80004930 <RC522_SPI_SetSpeed+0x20>
		
	
}
8000492a:	d8 02       	popm	pc
8000492c:	00 00       	add	r0,r0
8000492e:	1d a8       	ld.ub	r8,lr[0x2]
80004930:	80 00       	ld.sh	r0,r0[0x0]
80004932:	59 18       	cp.w	r8,17

80004934 <RC522_SPI_SetSpeedLow>:
void RC522_SPI_SetSpeedLow(void)
{
80004934:	d4 01       	pushm	lr
	RC522_SPI_SetSpeed(0x0A00);//baudDiv=4
80004936:	e0 6c 0a 00 	mov	r12,2560
8000493a:	f0 1f 00 02 	mcall	80004940 <RC522_SPI_SetSpeedLow+0xc>
	
}
8000493e:	d8 02       	popm	pc
80004940:	80 00       	ld.sh	r0,r0[0x0]
80004942:	49 10       	lddpc	r0,80004984 <RC522_WriteByte+0x14>

80004944 <RC522_ReadByte>:
	/*!< Return the byte read from the SPI bus */
	return  temp;

}
U8 RC522_ReadByte(void)
{
80004944:	eb cd 40 c0 	pushm	r6-r7,lr
	//蹇椤昏锋芥ｅ父璇诲
	//spi_selectChip(spi, DF_SPI_PCS_0);
	
	/*!< Send the byte */

	spi_write(spi,  0xFF);
80004948:	48 76       	lddpc	r6,80004964 <RC522_ReadByte+0x20>
8000494a:	e0 6b 00 ff 	mov	r11,255
8000494e:	6c 0c       	ld.w	r12,r6[0x0]
80004950:	f0 1f 00 06 	mcall	80004968 <RC522_ReadByte+0x24>
	
	/*!< Return the byte read from the SPI bus */

	spi_read(spi, Data);
80004954:	30 07       	mov	r7,0
80004956:	0e 9b       	mov	r11,r7
80004958:	6c 0c       	ld.w	r12,r6[0x0]
8000495a:	f0 1f 00 05 	mcall	8000496c <RC522_ReadByte+0x28>
	
	//spi_unselectChip(spi, DF_SPI_PCS_0);
	
	return (U8)(*Data);
	
}
8000495e:	0f 9c       	ld.ub	r12,r7[0x1]
80004960:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004964:	00 00       	add	r0,r0
80004966:	1d a8       	ld.ub	r8,lr[0x2]
80004968:	80 00       	ld.sh	r0,r0[0x0]
8000496a:	59 1e       	cp.w	lr,17
8000496c:	80 00       	ld.sh	r0,r0[0x0]
8000496e:	59 3a       	cp.w	r10,19

80004970 <RC522_WriteByte>:


U8 rc522_init_failure =0;

U8 RC522_WriteByte(U8 Data)
{
80004970:	eb cd 40 80 	pushm	r7,lr
80004974:	20 1d       	sub	sp,4
80004976:	ba 8c       	st.b	sp[0x0],r12
	U8 temp =0;
	
	//spi_selectChip(spi, DF_SPI_PCS_0);
	
	/*!< Send the byte */
	spi_write(spi,  (U16)Data);
80004978:	48 77       	lddpc	r7,80004994 <RC522_WriteByte+0x24>
8000497a:	f7 dc c0 08 	bfextu	r11,r12,0x0,0x8
8000497e:	6e 0c       	ld.w	r12,r7[0x0]
80004980:	f0 1f 00 06 	mcall	80004998 <RC522_WriteByte+0x28>
	
	/*!< Wait to receive a byte*/

	temp = spi_read(spi, (U16*)&Data);
80004984:	1a 9b       	mov	r11,sp
80004986:	6e 0c       	ld.w	r12,r7[0x0]
80004988:	f0 1f 00 05 	mcall	8000499c <RC522_WriteByte+0x2c>
	//spi_unselectChip(spi, DF_SPI_PCS_0);
	
	/*!< Return the byte read from the SPI bus */
	return  temp;

}
8000498c:	5c 5c       	castu.b	r12
8000498e:	2f fd       	sub	sp,-4
80004990:	e3 cd 80 80 	ldm	sp++,r7,pc
80004994:	00 00       	add	r0,r0
80004996:	1d a8       	ld.ub	r8,lr[0x2]
80004998:	80 00       	ld.sh	r0,r0[0x0]
8000499a:	59 1e       	cp.w	lr,17
8000499c:	80 00       	ld.sh	r0,r0[0x0]
8000499e:	59 3a       	cp.w	r10,19

800049a0 <WriteRawRC>:
//    斤RC632瀵瀛
//拌存锛Address[IN]:瀵瀛ㄥ板
//          value[IN]:ョ
/////////////////////////////////////////////////////////////////////
void WriteRawRC(U8   Address, U8   value)
{
800049a0:	eb cd 40 e0 	pushm	r5-r7,lr
800049a4:	18 96       	mov	r6,r12
800049a6:	16 95       	mov	r5,r11
	U8   ucAddr;

	//CLR_SPI_CS;	
	spi_selectChip(spi, DF_SPI_PCS_0);
800049a8:	48 a7       	lddpc	r7,800049d0 <WriteRawRC+0x30>
800049aa:	30 0b       	mov	r11,0
800049ac:	6e 0c       	ld.w	r12,r7[0x0]
800049ae:	f0 1f 00 0a 	mcall	800049d4 <WriteRawRC+0x34>
	
	ucAddr = ((Address<<1)&0x7E);
	RC522_WriteByte(ucAddr);
800049b2:	ec 0c 15 01 	lsl	r12,r6,0x1
800049b6:	e2 1c 00 7e 	andl	r12,0x7e,COH
800049ba:	f0 1f 00 08 	mcall	800049d8 <WriteRawRC+0x38>
	RC522_WriteByte(value);
800049be:	0a 9c       	mov	r12,r5
800049c0:	f0 1f 00 06 	mcall	800049d8 <WriteRawRC+0x38>
	
	spi_unselectChip(spi, DF_SPI_PCS_0);
800049c4:	30 0b       	mov	r11,0
800049c6:	6e 0c       	ld.w	r12,r7[0x0]
800049c8:	f0 1f 00 05 	mcall	800049dc <WriteRawRC+0x3c>
	
	//SET_SPI_CS;

}
800049cc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800049d0:	00 00       	add	r0,r0
800049d2:	1d a8       	ld.ub	r8,lr[0x2]
800049d4:	80 00       	ld.sh	r0,r0[0x0]
800049d6:	5a 84       	cp.w	r4,-24
800049d8:	80 00       	ld.sh	r0,r0[0x0]
800049da:	49 70       	lddpc	r0,80004a34 <PcdReset+0x54>
800049dc:	80 00       	ld.sh	r0,r0[0x0]
800049de:	5a 44       	cp.w	r4,-28

800049e0 <PcdReset>:
/////////////////////////////////////////////////////////////////////
//    斤澶浣RC522
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdReset(void)
{
800049e0:	d4 01       	pushm	lr

	SET_RC522RST;
800049e2:	31 9c       	mov	r12,25
800049e4:	f0 1f 00 1b 	mcall	80004a50 <PcdReset+0x70>
	delay_ns(10);
800049e8:	30 ac       	mov	r12,10
800049ea:	f0 1f 00 1b 	mcall	80004a54 <PcdReset+0x74>

	CLR_RC522RST;
800049ee:	31 9c       	mov	r12,25
800049f0:	f0 1f 00 1a 	mcall	80004a58 <PcdReset+0x78>
	delay_ns(10);
800049f4:	30 ac       	mov	r12,10
800049f6:	f0 1f 00 18 	mcall	80004a54 <PcdReset+0x74>

	SET_RC522RST;
800049fa:	31 9c       	mov	r12,25
800049fc:	f0 1f 00 15 	mcall	80004a50 <PcdReset+0x70>
	delay_ns(10);
80004a00:	30 ac       	mov	r12,10
80004a02:	f0 1f 00 15 	mcall	80004a54 <PcdReset+0x74>
	WriteRawRC(CommandReg,PCD_RESETPHASE);
80004a06:	30 fb       	mov	r11,15
80004a08:	30 1c       	mov	r12,1
80004a0a:	f0 1f 00 15 	mcall	80004a5c <PcdReset+0x7c>
	WriteRawRC(CommandReg,PCD_RESETPHASE);
80004a0e:	30 fb       	mov	r11,15
80004a10:	30 1c       	mov	r12,1
80004a12:	f0 1f 00 13 	mcall	80004a5c <PcdReset+0x7c>
	delay_ns(10);
80004a16:	30 ac       	mov	r12,10
80004a18:	f0 1f 00 0f 	mcall	80004a54 <PcdReset+0x74>
	
	WriteRawRC(ModeReg,0x3D);            //Mifare￠璁锛CRC濮0x6363
80004a1c:	33 db       	mov	r11,61
80004a1e:	31 1c       	mov	r12,17
80004a20:	f0 1f 00 0f 	mcall	80004a5c <PcdReset+0x7c>
	WriteRawRC(TReloadRegL,30);
80004a24:	31 eb       	mov	r11,30
80004a26:	32 dc       	mov	r12,45
80004a28:	f0 1f 00 0d 	mcall	80004a5c <PcdReset+0x7c>
	WriteRawRC(TReloadRegH,0);
80004a2c:	30 0b       	mov	r11,0
80004a2e:	32 cc       	mov	r12,44
80004a30:	f0 1f 00 0b 	mcall	80004a5c <PcdReset+0x7c>
	WriteRawRC(TModeReg,0x8D);
80004a34:	e0 6b 00 8d 	mov	r11,141
80004a38:	32 ac       	mov	r12,42
80004a3a:	f0 1f 00 09 	mcall	80004a5c <PcdReset+0x7c>
	WriteRawRC(TPrescalerReg,0x3E);
80004a3e:	33 eb       	mov	r11,62
80004a40:	32 bc       	mov	r12,43
80004a42:	f0 1f 00 07 	mcall	80004a5c <PcdReset+0x7c>
	
	WriteRawRC(TxAutoReg,0x40);//蹇椤昏
80004a46:	34 0b       	mov	r11,64
80004a48:	31 5c       	mov	r12,21
80004a4a:	f0 1f 00 05 	mcall	80004a5c <PcdReset+0x7c>
	
	return MI_OK;
}
80004a4e:	d8 0a       	popm	pc,r12=0
80004a50:	80 00       	ld.sh	r0,r0[0x0]
80004a52:	55 fc       	stdsp	sp[0x17c],r12
80004a54:	80 00       	ld.sh	r0,r0[0x0]
80004a56:	53 9c       	stdsp	sp[0xe4],r12
80004a58:	80 00       	ld.sh	r0,r0[0x0]
80004a5a:	56 18       	stdsp	sp[0x184],r8
80004a5c:	80 00       	ld.sh	r0,r0[0x0]
80004a5e:	49 a0       	lddpc	r0,80004ac4 <Powerdown_RC522+0xc>

80004a60 <ReadRawRC>:
//    斤璇RC632瀵瀛
//拌存锛Address[IN]:瀵瀛ㄥ板
//杩    锛璇诲虹
/////////////////////////////////////////////////////////////////////
U8 ReadRawRC(U8   Address)
{
80004a60:	eb cd 40 c0 	pushm	r6-r7,lr
80004a64:	18 96       	mov	r6,r12
	U8   ucAddr;
	U8   ucResult=0;
	//CLR_SPI_CS;	
	spi_selectChip(spi, DF_SPI_PCS_0);
80004a66:	48 c7       	lddpc	r7,80004a94 <ReadRawRC+0x34>
80004a68:	30 0b       	mov	r11,0
80004a6a:	6e 0c       	ld.w	r12,r7[0x0]
80004a6c:	f0 1f 00 0b 	mcall	80004a98 <ReadRawRC+0x38>
	 
	ucAddr = ((Address<<1)&0x7E)|0x80;
	
	RC522_WriteByte(ucAddr);
80004a70:	a1 76       	lsl	r6,0x1
80004a72:	0c 9c       	mov	r12,r6
80004a74:	e2 1c 00 7e 	andl	r12,0x7e,COH
80004a78:	a7 bc       	sbr	r12,0x7
80004a7a:	f0 1f 00 09 	mcall	80004a9c <ReadRawRC+0x3c>
	ucResult = RC522_ReadByte();
80004a7e:	f0 1f 00 09 	mcall	80004aa0 <ReadRawRC+0x40>
80004a82:	18 96       	mov	r6,r12
	
	spi_unselectChip(spi, DF_SPI_PCS_0);
80004a84:	30 0b       	mov	r11,0
80004a86:	6e 0c       	ld.w	r12,r7[0x0]
80004a88:	f0 1f 00 07 	mcall	80004aa4 <ReadRawRC+0x44>
	//SET_SPI_CS;
	return ucResult;
}
80004a8c:	0c 9c       	mov	r12,r6
80004a8e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004a92:	00 00       	add	r0,r0
80004a94:	00 00       	add	r0,r0
80004a96:	1d a8       	ld.ub	r8,lr[0x2]
80004a98:	80 00       	ld.sh	r0,r0[0x0]
80004a9a:	5a 84       	cp.w	r4,-24
80004a9c:	80 00       	ld.sh	r0,r0[0x0]
80004a9e:	49 70       	lddpc	r0,80004af8 <Powerdown_RC522+0x40>
80004aa0:	80 00       	ld.sh	r0,r0[0x0]
80004aa2:	49 44       	lddpc	r4,80004af0 <Powerdown_RC522+0x38>
80004aa4:	80 00       	ld.sh	r0,r0[0x0]
80004aa6:	5a 44       	cp.w	r4,-28

80004aa8 <Wait_Wakeup_RC522>:

/////////////////////////////////////////////////////////////////////
//    斤绛寰RC522
/////////////////////////////////////////////////////////////////////
void Wait_Wakeup_RC522(void)
{
80004aa8:	d4 01       	pushm	lr
	char   tmp = 0x0;
	char   reg = CommandReg;
	
	do 
	{
		tmp = ReadRawRC(reg);
80004aaa:	30 1c       	mov	r12,1
80004aac:	f0 1f 00 02 	mcall	80004ab4 <Wait_Wakeup_RC522+0xc>
			
	//tmp = ReadRawRC(reg);
	//if((tmp & 0x10) == 0)
	//WriteRawRC(reg,tmp | PCD_POWERDOWN);  // set bit powerdown
	
}
80004ab0:	d8 02       	popm	pc
80004ab2:	00 00       	add	r0,r0
80004ab4:	80 00       	ld.sh	r0,r0[0x0]
80004ab6:	4a 60       	lddpc	r0,80004b4c <ClearBitMask+0x4>

80004ab8 <Powerdown_RC522>:
/////////////////////////////////////////////////////////////////////
//    斤浣RC522杩ヨ蒋垫ā寮
//
/////////////////////////////////////////////////////////////////////
void Powerdown_RC522(U8 act)
{
80004ab8:	eb cd 40 80 	pushm	r7,lr
80004abc:	18 97       	mov	r7,r12
	char   tmp = 0x0;
	char   reg = CommandReg;
	
	tmp = ReadRawRC(reg);
80004abe:	30 1c       	mov	r12,1
80004ac0:	f0 1f 00 0d 	mcall	80004af4 <Powerdown_RC522+0x3c>
	if(act == ENTER_POWERDOWN)//1
80004ac4:	30 18       	mov	r8,1
80004ac6:	f0 07 18 00 	cp.b	r7,r8
80004aca:	c0 91       	brne	80004adc <Powerdown_RC522+0x24>
		WriteRawRC(reg,tmp | PCD_POWERDOWN);  // set bit powerdown
80004acc:	18 9b       	mov	r11,r12
80004ace:	a5 ab       	sbr	r11,0x4
80004ad0:	5c 5b       	castu.b	r11
80004ad2:	30 1c       	mov	r12,1
80004ad4:	f0 1f 00 09 	mcall	80004af8 <Powerdown_RC522+0x40>
80004ad8:	e3 cd 80 80 	ldm	sp++,r7,pc
	else
	{
		WriteRawRC(reg,tmp | PCD_IDLE);  // wake up rc522
80004adc:	18 9b       	mov	r11,r12
80004ade:	30 1c       	mov	r12,1
80004ae0:	f0 1f 00 06 	mcall	80004af8 <Powerdown_RC522+0x40>
		delay_ns(2);
80004ae4:	30 2c       	mov	r12,2
80004ae6:	f0 1f 00 06 	mcall	80004afc <Powerdown_RC522+0x44>
		Wait_Wakeup_RC522();
80004aea:	f0 1f 00 06 	mcall	80004b00 <Powerdown_RC522+0x48>
80004aee:	e3 cd 80 80 	ldm	sp++,r7,pc
80004af2:	00 00       	add	r0,r0
80004af4:	80 00       	ld.sh	r0,r0[0x0]
80004af6:	4a 60       	lddpc	r0,80004b8c <M500PcdConfigISOType+0xc>
80004af8:	80 00       	ld.sh	r0,r0[0x0]
80004afa:	49 a0       	lddpc	r0,80004b60 <ClearBitMask+0x18>
80004afc:	80 00       	ld.sh	r0,r0[0x0]
80004afe:	53 9c       	stdsp	sp[0xe4],r12
80004b00:	80 00       	ld.sh	r0,r0[0x0]
80004b02:	4a a8       	lddpc	r8,80004ba8 <M500PcdConfigISOType+0x28>

80004b04 <SetBitMask>:
//    斤缃RC522瀵瀛ㄤ
//拌存锛reg[IN]:瀵瀛ㄥ板
//          mask[IN]:缃浣
/////////////////////////////////////////////////////////////////////
void SetBitMask(U8   reg,U8   mask)
{
80004b04:	eb cd 40 c0 	pushm	r6-r7,lr
80004b08:	18 97       	mov	r7,r12
80004b0a:	16 96       	mov	r6,r11
	char   tmp = 0x0;
	tmp = ReadRawRC(reg);
80004b0c:	f0 1f 00 05 	mcall	80004b20 <SetBitMask+0x1c>
	WriteRawRC(reg,tmp | mask);  // set bit mask
80004b10:	f9 e6 10 0b 	or	r11,r12,r6
80004b14:	5c 5b       	castu.b	r11
80004b16:	0e 9c       	mov	r12,r7
80004b18:	f0 1f 00 03 	mcall	80004b24 <SetBitMask+0x20>
}
80004b1c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004b20:	80 00       	ld.sh	r0,r0[0x0]
80004b22:	4a 60       	lddpc	r0,80004bb8 <M500PcdConfigISOType+0x38>
80004b24:	80 00       	ld.sh	r0,r0[0x0]
80004b26:	49 a0       	lddpc	r0,80004b8c <M500PcdConfigISOType+0xc>

80004b28 <PcdAntennaOn>:
/////////////////////////////////////////////////////////////////////
//寮澶╃嚎
//姣娆″ㄦ抽澶╅╁灏涔村冲1ms撮
/////////////////////////////////////////////////////////////////////
void PcdAntennaOn(void)
{
80004b28:	d4 01       	pushm	lr
	U8   i;
	i = ReadRawRC(TxControlReg);
80004b2a:	31 4c       	mov	r12,20
80004b2c:	f0 1f 00 05 	mcall	80004b40 <PcdAntennaOn+0x18>
	if (!(i & 0x03))
80004b30:	f9 dc c0 02 	bfextu	r12,r12,0x0,0x2
80004b34:	c0 51       	brne	80004b3e <PcdAntennaOn+0x16>
	{
		SetBitMask(TxControlReg, 0x03);
80004b36:	30 3b       	mov	r11,3
80004b38:	31 4c       	mov	r12,20
80004b3a:	f0 1f 00 03 	mcall	80004b44 <PcdAntennaOn+0x1c>
80004b3e:	d8 02       	popm	pc
80004b40:	80 00       	ld.sh	r0,r0[0x0]
80004b42:	4a 60       	lddpc	r0,80004bd8 <M500PcdConfigISOType+0x58>
80004b44:	80 00       	ld.sh	r0,r0[0x0]
80004b46:	4b 04       	lddpc	r4,80004c04 <rc522_init+0x14>

80004b48 <ClearBitMask>:
//    斤娓RC522瀵瀛ㄤ
//拌存锛reg[IN]:瀵瀛ㄥ板
//         mask[IN]:娓浣
/////////////////////////////////////////////////////////////////////
void ClearBitMask(U8   reg,U8   mask)
{
80004b48:	eb cd 40 c0 	pushm	r6-r7,lr
80004b4c:	18 97       	mov	r7,r12
80004b4e:	16 96       	mov	r6,r11
	  char   tmp = 0x0;
	  tmp = ReadRawRC(reg);
80004b50:	f0 1f 00 06 	mcall	80004b68 <ClearBitMask+0x20>
	  WriteRawRC(reg, tmp & ~mask);  // clear bit mask
80004b54:	5c d6       	com	r6
80004b56:	f9 e6 00 06 	and	r6,r12,r6
80004b5a:	f7 d6 c0 08 	bfextu	r11,r6,0x0,0x8
80004b5e:	0e 9c       	mov	r12,r7
80004b60:	f0 1f 00 03 	mcall	80004b6c <ClearBitMask+0x24>
	
}
80004b64:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004b68:	80 00       	ld.sh	r0,r0[0x0]
80004b6a:	4a 60       	lddpc	r0,80004c00 <rc522_init+0x10>
80004b6c:	80 00       	ld.sh	r0,r0[0x0]
80004b6e:	49 a0       	lddpc	r0,80004bd4 <M500PcdConfigISOType+0x54>

80004b70 <PcdAntennaOff>:

/////////////////////////////////////////////////////////////////////
//抽澶╃嚎
/////////////////////////////////////////////////////////////////////
void PcdAntennaOff(void)
{
80004b70:	d4 01       	pushm	lr
	ClearBitMask(TxControlReg, 0x03);
80004b72:	30 3b       	mov	r11,3
80004b74:	31 4c       	mov	r12,20
80004b76:	f0 1f 00 02 	mcall	80004b7c <PcdAntennaOff+0xc>
}
80004b7a:	d8 02       	popm	pc
80004b7c:	80 00       	ld.sh	r0,r0[0x0]
80004b7e:	4b 48       	lddpc	r8,80004c4c <rc522_init+0x5c>

80004b80 <M500PcdConfigISOType>:

//////////////////////////////////////////////////////////////////////
//璁剧疆RC632宸ヤ瑰
//////////////////////////////////////////////////////////////////////
char M500PcdConfigISOType(U8   type)
{
80004b80:	d4 01       	pushm	lr
	if (type == 'A')                     //ISO14443_A
80004b82:	34 18       	mov	r8,65
80004b84:	f0 0c 18 00 	cp.b	r12,r8
80004b88:	c0 20       	breq	80004b8c <M500PcdConfigISOType+0xc>
80004b8a:	da 0a       	popm	pc,r12=1
	{
		ClearBitMask(Status2Reg,0x08);
80004b8c:	30 8b       	mov	r11,8
80004b8e:	16 9c       	mov	r12,r11
80004b90:	f0 1f 00 14 	mcall	80004be0 <M500PcdConfigISOType+0x60>
		WriteRawRC(ModeReg,0x3D);//3F
80004b94:	33 db       	mov	r11,61
80004b96:	31 1c       	mov	r12,17
80004b98:	f0 1f 00 13 	mcall	80004be4 <M500PcdConfigISOType+0x64>
		WriteRawRC(RxSelReg,0x86);//84
80004b9c:	e0 6b 00 86 	mov	r11,134
80004ba0:	31 7c       	mov	r12,23
80004ba2:	f0 1f 00 11 	mcall	80004be4 <M500PcdConfigISOType+0x64>
		WriteRawRC(RFCfgReg,0x7F);   //4F
80004ba6:	37 fb       	mov	r11,127
80004ba8:	32 6c       	mov	r12,38
80004baa:	f0 1f 00 0f 	mcall	80004be4 <M500PcdConfigISOType+0x64>
		WriteRawRC(TReloadRegL,30);//tmoLength);// TReloadVal = 'h6a =tmoLength(dec)
80004bae:	31 eb       	mov	r11,30
80004bb0:	32 dc       	mov	r12,45
80004bb2:	f0 1f 00 0d 	mcall	80004be4 <M500PcdConfigISOType+0x64>
		WriteRawRC(TReloadRegH,0);
80004bb6:	30 0b       	mov	r11,0
80004bb8:	32 cc       	mov	r12,44
80004bba:	f0 1f 00 0b 	mcall	80004be4 <M500PcdConfigISOType+0x64>
		WriteRawRC(TModeReg,0x8D);
80004bbe:	e0 6b 00 8d 	mov	r11,141
80004bc2:	32 ac       	mov	r12,42
80004bc4:	f0 1f 00 08 	mcall	80004be4 <M500PcdConfigISOType+0x64>
		WriteRawRC(TPrescalerReg,0x3E);
80004bc8:	33 eb       	mov	r11,62
80004bca:	32 bc       	mov	r12,43
80004bcc:	f0 1f 00 06 	mcall	80004be4 <M500PcdConfigISOType+0x64>
		delay_ns(1000);
80004bd0:	e0 6c 03 e8 	mov	r12,1000
80004bd4:	f0 1f 00 05 	mcall	80004be8 <M500PcdConfigISOType+0x68>
		PcdAntennaOn();
80004bd8:	f0 1f 00 05 	mcall	80004bec <M500PcdConfigISOType+0x6c>
80004bdc:	d8 0a       	popm	pc,r12=0
80004bde:	00 00       	add	r0,r0
80004be0:	80 00       	ld.sh	r0,r0[0x0]
80004be2:	4b 48       	lddpc	r8,80004cb0 <rc522_init+0xc0>
80004be4:	80 00       	ld.sh	r0,r0[0x0]
80004be6:	49 a0       	lddpc	r0,80004c4c <rc522_init+0x5c>
80004be8:	80 00       	ld.sh	r0,r0[0x0]
80004bea:	53 9c       	stdsp	sp[0xe4],r12
80004bec:	80 00       	ld.sh	r0,r0[0x0]
80004bee:	4b 28       	lddpc	r8,80004cb4 <rc522_init+0xc4>

80004bf0 <rc522_init>:


//mfrc522 init

void rc522_init()
{
80004bf0:	eb cd 40 c0 	pushm	r6-r7,lr
80004bf4:	20 4d       	sub	sp,16
		.spck_delay   = 0,
		.trans_delay  = 0,
		.stay_act     = 1,
		.spi_mode     = 0,
		.modfdis      = 1
	};
80004bf6:	4a 38       	lddpc	r8,80004c80 <rc522_init+0x90>
80004bf8:	1a 96       	mov	r6,sp
80004bfa:	f0 ea 00 00 	ld.d	r10,r8[0]
80004bfe:	fa eb 00 00 	st.d	sp[0],r10
80004c02:	f0 e8 00 08 	ld.d	r8,r8[8]
80004c06:	fa e9 00 08 	st.d	sp[8],r8

	// Assign I/Os to SPI.
	gpio_enable_module(RC522_SPI_GPIO_MAP, sizeof(RC522_SPI_GPIO_MAP) / sizeof(RC522_SPI_GPIO_MAP[0]));
80004c0a:	30 4b       	mov	r11,4
80004c0c:	49 ec       	lddpc	r12,80004c84 <rc522_init+0x94>
80004c0e:	f0 1f 00 1f 	mcall	80004c88 <rc522_init+0x98>

	// Configure PA25 as RST pin
	gpio_enable_gpio_pin(AVR32_PIN_PA25);
80004c12:	31 9c       	mov	r12,25
80004c14:	f0 1f 00 1e 	mcall	80004c8c <rc522_init+0x9c>
	gpio_set_gpio_pin(AVR32_PIN_PA25);
80004c18:	31 9c       	mov	r12,25
80004c1a:	f0 1f 00 1e 	mcall	80004c90 <rc522_init+0xa0>

	spi = &AVR32_SPI;
80004c1e:	49 e7       	lddpc	r7,80004c94 <rc522_init+0xa4>
80004c20:	fe 7c 24 00 	mov	r12,-56320
80004c24:	8f 0c       	st.w	r7[0x0],r12

	// Initialize as master.
	spi_initMaster(spi, &spiOptions);
80004c26:	1a 9b       	mov	r11,sp
80004c28:	f0 1f 00 1c 	mcall	80004c98 <rc522_init+0xa8>

	// Set selection mode: variable_ps, pcs_decode, delay.
	spi_selectionMode(spi, 0, 0, 0);
80004c2c:	30 09       	mov	r9,0
80004c2e:	12 9a       	mov	r10,r9
80004c30:	12 9b       	mov	r11,r9
80004c32:	6e 0c       	ld.w	r12,r7[0x0]
80004c34:	f0 1f 00 1a 	mcall	80004c9c <rc522_init+0xac>

	// Enable SPI.
	spi_enable(spi);
80004c38:	6e 0c       	ld.w	r12,r7[0x0]
80004c3a:	f0 1f 00 1a 	mcall	80004ca0 <rc522_init+0xb0>

	// Initialize RC522 with SPI clock PBA.
	if (spi_setupChipReg(spi, &spiOptions, 2*12000000) != SPI_OK)
80004c3e:	e0 6a 36 00 	mov	r10,13824
80004c42:	ea 1a 01 6e 	orh	r10,0x16e
80004c46:	1a 9b       	mov	r11,sp
80004c48:	6e 0c       	ld.w	r12,r7[0x0]
80004c4a:	f0 1f 00 17 	mcall	80004ca4 <rc522_init+0xb4>
80004c4e:	c0 50       	breq	80004c58 <rc522_init+0x68>
	{
		
		rc522_init_failure = FATAL_ERROR_RC522_SPI_INIT;
80004c50:	30 29       	mov	r9,2
80004c52:	49 68       	lddpc	r8,80004ca8 <rc522_init+0xb8>
80004c54:	b0 89       	st.b	r8[0x0],r9
80004c56:	c0 38       	rjmp	80004c5c <rc522_init+0x6c>
		return;
	}
	
	RC522_SPI_SetSpeedLow();
80004c58:	f0 1f 00 15 	mcall	80004cac <rc522_init+0xbc>
void rc522_init()
{
	
	spi_init();
	
	PcdReset();
80004c5c:	f0 1f 00 15 	mcall	80004cb0 <rc522_init+0xc0>
	
	PcdAntennaOff();
80004c60:	f0 1f 00 15 	mcall	80004cb4 <rc522_init+0xc4>
	
	delay_ms(2); 
80004c64:	30 2c       	mov	r12,2
80004c66:	f0 1f 00 15 	mcall	80004cb8 <rc522_init+0xc8>
	
	PcdAntennaOn();
80004c6a:	f0 1f 00 15 	mcall	80004cbc <rc522_init+0xcc>
	
	M500PcdConfigISOType( 'A' );
80004c6e:	34 1c       	mov	r12,65
80004c70:	f0 1f 00 14 	mcall	80004cc0 <rc522_init+0xd0>
	
	Powerdown_RC522(ENTER_POWERDOWN);
80004c74:	30 1c       	mov	r12,1
80004c76:	f0 1f 00 14 	mcall	80004cc4 <rc522_init+0xd4>
	//Powerdown_RC522(ENTER_POWERDOWN);
	
	//Powerdown_RC522(WAKEUP_RC522);
	

80004c7a:	2f cd       	sub	sp,-16
80004c7c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004c80:	80 00       	ld.sh	r0,r0[0x0]
80004c82:	d8 a8       	*unknown*
80004c84:	80 00       	ld.sh	r0,r0[0x0]
80004c86:	d8 88       	*unknown*
80004c88:	80 00       	ld.sh	r0,r0[0x0]
80004c8a:	55 b4       	stdsp	sp[0x16c],r4
80004c8c:	80 00       	ld.sh	r0,r0[0x0]
80004c8e:	55 e4       	stdsp	sp[0x178],r4
80004c90:	80 00       	ld.sh	r0,r0[0x0]
80004c92:	55 fc       	stdsp	sp[0x17c],r12
80004c94:	00 00       	add	r0,r0
80004c96:	1d a8       	ld.ub	r8,lr[0x2]
80004c98:	80 00       	ld.sh	r0,r0[0x0]
80004c9a:	58 b4       	cp.w	r4,11
80004c9c:	80 00       	ld.sh	r0,r0[0x0]
80004c9e:	58 ec       	cp.w	r12,14
80004ca0:	80 00       	ld.sh	r0,r0[0x0]
80004ca2:	59 18       	cp.w	r8,17
80004ca4:	80 00       	ld.sh	r0,r0[0x0]
80004ca6:	59 5c       	cp.w	r12,21
80004ca8:	00 00       	add	r0,r0
80004caa:	0b 5c       	ld.sh	r12,--r5
80004cac:	80 00       	ld.sh	r0,r0[0x0]
80004cae:	49 34       	lddpc	r4,80004cf8 <PcdComMF522+0x30>
80004cb0:	80 00       	ld.sh	r0,r0[0x0]
80004cb2:	49 e0       	lddpc	r0,80004d28 <PcdComMF522+0x60>
80004cb4:	80 00       	ld.sh	r0,r0[0x0]
80004cb6:	4b 70       	lddpc	r0,80004d90 <PcdComMF522+0xc8>
80004cb8:	80 00       	ld.sh	r0,r0[0x0]
80004cba:	53 dc       	stdsp	sp[0xf4],r12
80004cbc:	80 00       	ld.sh	r0,r0[0x0]
80004cbe:	4b 28       	lddpc	r8,80004d84 <PcdComMF522+0xbc>
80004cc0:	80 00       	ld.sh	r0,r0[0x0]
80004cc2:	4b 80       	lddpc	r0,80004da0 <PcdComMF522+0xd8>
80004cc4:	80 00       	ld.sh	r0,r0[0x0]
80004cc6:	4a b8       	lddpc	r8,80004d70 <PcdComMF522+0xa8>

80004cc8 <PcdComMF522>:
char PcdComMF522(U8  Command,
				 U8 *pIn ,
				 U8  InLenByte,
				 U8 *pOut ,
				 U8 *pOutLenBit)
{
80004cc8:	d4 31       	pushm	r0-r7,lr
80004cca:	20 1d       	sub	sp,4
80004ccc:	18 92       	mov	r2,r12
80004cce:	16 95       	mov	r5,r11
80004cd0:	14 96       	mov	r6,r10
80004cd2:	50 09       	stdsp	sp[0x0],r9
80004cd4:	10 90       	mov	r0,r8
80004cd6:	f8 c8 00 0c 	sub	r8,r12,12
80004cda:	5c 58       	castu.b	r8
80004cdc:	30 29       	mov	r9,2
80004cde:	f2 08 18 00 	cp.b	r8,r9
80004ce2:	e0 88 00 05 	brls	80004cec <PcdComMF522+0x24>
80004ce6:	30 03       	mov	r3,0
80004ce8:	06 91       	mov	r1,r3
80004cea:	c0 78       	rjmp	80004cf8 <PcdComMF522+0x30>
80004cec:	4c f9       	lddpc	r9,80004e28 <PcdComMF522+0x160>
80004cee:	f2 08 07 01 	ld.ub	r1,r9[r8]
80004cf2:	4c f9       	lddpc	r9,80004e2c <PcdComMF522+0x164>
80004cf4:	f2 08 07 03 	ld.ub	r3,r9[r8]
		break;
		default:
		break;
	}
	
	WriteRawRC(ComIEnReg,irqEn|0x80);
80004cf8:	02 9b       	mov	r11,r1
80004cfa:	a7 bb       	sbr	r11,0x7
80004cfc:	30 2c       	mov	r12,2
80004cfe:	f0 1f 00 4d 	mcall	80004e30 <PcdComMF522+0x168>
	ClearBitMask(ComIrqReg,0x80);	//娓涓浣
80004d02:	e0 6b 00 80 	mov	r11,128
80004d06:	30 4c       	mov	r12,4
80004d08:	f0 1f 00 4b 	mcall	80004e34 <PcdComMF522+0x16c>
	WriteRawRC(CommandReg,PCD_IDLE);
80004d0c:	30 0b       	mov	r11,0
80004d0e:	30 1c       	mov	r12,1
80004d10:	f0 1f 00 48 	mcall	80004e30 <PcdComMF522+0x168>
	SetBitMask(FIFOLevelReg,0x80);	 	//娓FIFO缂瀛
80004d14:	e0 6b 00 80 	mov	r11,128
80004d18:	30 ac       	mov	r12,10
80004d1a:	f0 1f 00 48 	mcall	80004e38 <PcdComMF522+0x170>
	
	for (i=0; i<InLenByte; i++)
80004d1e:	58 06       	cp.w	r6,0
80004d20:	c0 c0       	breq	80004d38 <PcdComMF522+0x70>
80004d22:	0a 97       	mov	r7,r5
	{   
		WriteRawRC(FIFODataReg, pIn [i]);
80004d24:	30 94       	mov	r4,9
80004d26:	0f 3b       	ld.ub	r11,r7++
80004d28:	08 9c       	mov	r12,r4
80004d2a:	f0 1f 00 42 	mcall	80004e30 <PcdComMF522+0x168>
	WriteRawRC(ComIEnReg,irqEn|0x80);
	ClearBitMask(ComIrqReg,0x80);	//娓涓浣
	WriteRawRC(CommandReg,PCD_IDLE);
	SetBitMask(FIFOLevelReg,0x80);	 	//娓FIFO缂瀛
	
	for (i=0; i<InLenByte; i++)
80004d2e:	0e 98       	mov	r8,r7
80004d30:	0a 18       	sub	r8,r5
80004d32:	ec 08 19 00 	cp.h	r8,r6
80004d36:	cf 83       	brcs	80004d26 <PcdComMF522+0x5e>
	{   
		WriteRawRC(FIFODataReg, pIn [i]);
	}
	WriteRawRC(CommandReg, Command);
80004d38:	04 9b       	mov	r11,r2
80004d3a:	30 1c       	mov	r12,1
80004d3c:	f0 1f 00 3d 	mcall	80004e30 <PcdComMF522+0x168>
	
	if (Command == PCD_TRANSCEIVE)
80004d40:	30 c8       	mov	r8,12
80004d42:	f0 02 18 00 	cp.b	r2,r8
80004d46:	c0 61       	brne	80004d52 <PcdComMF522+0x8a>
	{    
		SetBitMask(BitFramingReg,0x80);  
80004d48:	e0 6b 00 80 	mov	r11,128
80004d4c:	30 dc       	mov	r12,13
80004d4e:	f0 1f 00 3b 	mcall	80004e38 <PcdComMF522+0x170>
	
	//i = 600;//规堕棰璋达浣M1℃澶х寰堕25ms
	i = 2000;
	do
	{
		n = ReadRawRC(ComIrqReg);
80004d52:	30 4c       	mov	r12,4
80004d54:	f0 1f 00 3a 	mcall	80004e3c <PcdComMF522+0x174>
80004d58:	18 97       	mov	r7,r12
80004d5a:	e0 66 07 cf 	mov	r6,1999
		i--;
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
80004d5e:	30 05       	mov	r5,0
	
	//i = 600;//规堕棰璋达浣M1℃澶х寰堕25ms
	i = 2000;
	do
	{
		n = ReadRawRC(ComIrqReg);
80004d60:	30 44       	mov	r4,4
80004d62:	c0 88       	rjmp	80004d72 <PcdComMF522+0xaa>
80004d64:	08 9c       	mov	r12,r4
80004d66:	f0 1f 00 36 	mcall	80004e3c <PcdComMF522+0x174>
80004d6a:	18 97       	mov	r7,r12
		i--;
80004d6c:	20 16       	sub	r6,1
80004d6e:	5c 86       	casts.h	r6
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
80004d70:	c0 a0       	breq	80004d84 <PcdComMF522+0xbc>
80004d72:	f1 d7 c0 01 	bfextu	r8,r7,0x0,0x1
80004d76:	c4 c1       	brne	80004e0e <PcdComMF522+0x146>
80004d78:	ef e3 00 08 	and	r8,r7,r3
80004d7c:	ea 08 18 00 	cp.b	r8,r5
80004d80:	cf 20       	breq	80004d64 <PcdComMF522+0x9c>
80004d82:	c4 68       	rjmp	80004e0e <PcdComMF522+0x146>
	ClearBitMask(BitFramingReg,0x80);
80004d84:	e0 6b 00 80 	mov	r11,128
80004d88:	30 dc       	mov	r12,13
80004d8a:	f0 1f 00 2b 	mcall	80004e34 <PcdComMF522+0x16c>
80004d8e:	30 27       	mov	r7,2
80004d90:	c3 38       	rjmp	80004df6 <PcdComMF522+0x12e>
80004d92:	02 67       	and	r7,r1
80004d94:	ef d7 c0 01 	bfextu	r7,r7,0x0,0x1
		if(!(ReadRawRC(ErrorReg)&0x1B))
		{
			status = MI_OK;
			if (n & irqEn & 0x01)
			{   status = MI_NOTAGERR;   }
			if (Command == PCD_TRANSCEIVE)
80004d98:	30 c8       	mov	r8,12
80004d9a:	f0 02 18 00 	cp.b	r2,r8
80004d9e:	c2 c1       	brne	80004df6 <PcdComMF522+0x12e>
			{
				n = ReadRawRC(FIFOLevelReg);
80004da0:	30 ac       	mov	r12,10
80004da2:	f0 1f 00 27 	mcall	80004e3c <PcdComMF522+0x174>
80004da6:	18 94       	mov	r4,r12
				lastBits = ReadRawRC(ControlReg) & 0x07;
80004da8:	30 cc       	mov	r12,12
80004daa:	f0 1f 00 25 	mcall	80004e3c <PcdComMF522+0x174>
80004dae:	f9 dc c0 03 	bfextu	r12,r12,0x0,0x3
				if (lastBits)
80004db2:	c0 70       	breq	80004dc0 <PcdComMF522+0xf8>
				{   *pOutLenBit = (n-1)*8 + lastBits;   }
80004db4:	08 98       	mov	r8,r4
80004db6:	20 18       	sub	r8,1
80004db8:	f8 08 00 3c 	add	r12,r12,r8<<0x3
80004dbc:	a0 8c       	st.b	r0[0x0],r12
80004dbe:	c0 48       	rjmp	80004dc6 <PcdComMF522+0xfe>
				else
				{   *pOutLenBit = n*8;   }
80004dc0:	e8 08 15 03 	lsl	r8,r4,0x3
80004dc4:	a0 88       	st.b	r0[0x0],r8
				if (n == 0)
80004dc6:	58 04       	cp.w	r4,0
80004dc8:	c0 61       	brne	80004dd4 <PcdComMF522+0x10c>
80004dca:	30 14       	mov	r4,1
80004dcc:	40 05       	lddsp	r5,sp[0x0]
80004dce:	0a 96       	mov	r6,r5
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
				{   pOut [i] = ReadRawRC(FIFODataReg);    }
80004dd0:	30 93       	mov	r3,9
80004dd2:	c0 98       	rjmp	80004de4 <PcdComMF522+0x11c>
				{   *pOutLenBit = n*8;   }
				if (n == 0)
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
80004dd4:	31 28       	mov	r8,18
80004dd6:	f0 04 18 00 	cp.b	r4,r8
80004dda:	f9 b4 0b 12 	movhi	r4,18
80004dde:	58 04       	cp.w	r4,0
80004de0:	cf 61       	brne	80004dcc <PcdComMF522+0x104>
80004de2:	c0 a8       	rjmp	80004df6 <PcdComMF522+0x12e>
				{   pOut [i] = ReadRawRC(FIFODataReg);    }
80004de4:	06 9c       	mov	r12,r3
80004de6:	f0 1f 00 16 	mcall	80004e3c <PcdComMF522+0x174>
80004dea:	0c cc       	st.b	r6++,r12
				{   *pOutLenBit = n*8;   }
				if (n == 0)
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
80004dec:	ec 05 01 08 	sub	r8,r6,r5
80004df0:	e8 08 19 00 	cp.h	r8,r4
80004df4:	cf 83       	brcs	80004de4 <PcdComMF522+0x11c>
		{   status = MI_ERR;   }
		
	}
	

	SetBitMask(ControlReg,0x80);           // stop timer now
80004df6:	e0 6b 00 80 	mov	r11,128
80004dfa:	30 cc       	mov	r12,12
80004dfc:	f0 1f 00 0f 	mcall	80004e38 <PcdComMF522+0x170>
	WriteRawRC(CommandReg,PCD_IDLE);
80004e00:	30 0b       	mov	r11,0
80004e02:	30 1c       	mov	r12,1
80004e04:	f0 1f 00 0b 	mcall	80004e30 <PcdComMF522+0x168>
	return status;
}
80004e08:	0e 9c       	mov	r12,r7
80004e0a:	2f fd       	sub	sp,-4
80004e0c:	d8 32       	popm	r0-r7,pc
	{
		n = ReadRawRC(ComIrqReg);
		i--;
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
	ClearBitMask(BitFramingReg,0x80);
80004e0e:	e0 6b 00 80 	mov	r11,128
80004e12:	30 dc       	mov	r12,13
80004e14:	f0 1f 00 08 	mcall	80004e34 <PcdComMF522+0x16c>

	if (i!=0)
	{
		if(!(ReadRawRC(ErrorReg)&0x1B))
80004e18:	30 6c       	mov	r12,6
80004e1a:	f0 1f 00 09 	mcall	80004e3c <PcdComMF522+0x174>
80004e1e:	e2 1c 00 1b 	andl	r12,0x1b,COH
80004e22:	cb 80       	breq	80004d92 <PcdComMF522+0xca>
80004e24:	30 27       	mov	r7,2
80004e26:	ce 8b       	rjmp	80004df6 <PcdComMF522+0x12e>
80004e28:	80 00       	ld.sh	r0,r0[0x0]
80004e2a:	d8 80       	acall	0x88
80004e2c:	80 00       	ld.sh	r0,r0[0x0]
80004e2e:	d8 84       	*unknown*
80004e30:	80 00       	ld.sh	r0,r0[0x0]
80004e32:	49 a0       	lddpc	r0,80004e98 <PcdAnticoll+0x58>
80004e34:	80 00       	ld.sh	r0,r0[0x0]
80004e36:	4b 48       	lddpc	r8,80004f04 <PcdRequest+0x40>
80004e38:	80 00       	ld.sh	r0,r0[0x0]
80004e3a:	4b 04       	lddpc	r4,80004ef8 <PcdRequest+0x34>
80004e3c:	80 00       	ld.sh	r0,r0[0x0]
80004e3e:	4a 60       	lddpc	r0,80004ed4 <PcdRequest+0x10>

80004e40 <PcdAnticoll>:
//    斤插叉
//拌存: pSnr[OUT]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdAnticoll(U8 *pSnr)
{
80004e40:	eb cd 40 c0 	pushm	r6-r7,lr
80004e44:	20 5d       	sub	sp,20
80004e46:	18 96       	mov	r6,r12
	U8   i,snr_check=0;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];
	

	ClearBitMask(Status2Reg,0x08);
80004e48:	30 8b       	mov	r11,8
80004e4a:	16 9c       	mov	r12,r11
80004e4c:	f0 1f 00 1a 	mcall	80004eb4 <PcdAnticoll+0x74>
	WriteRawRC(BitFramingReg,0x00);
80004e50:	30 0b       	mov	r11,0
80004e52:	30 dc       	mov	r12,13
80004e54:	f0 1f 00 19 	mcall	80004eb8 <PcdAnticoll+0x78>
	ClearBitMask(CollReg,0x80);
80004e58:	e0 6b 00 80 	mov	r11,128
80004e5c:	30 ec       	mov	r12,14
80004e5e:	f0 1f 00 16 	mcall	80004eb4 <PcdAnticoll+0x74>
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
80004e62:	39 38       	mov	r8,-109
80004e64:	ba 88       	st.b	sp[0x0],r8
	ucComMF522Buf[1] = 0x20;
80004e66:	32 08       	mov	r8,32
80004e68:	ba 98       	st.b	sp[0x1],r8

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,2,ucComMF522Buf,&unLen);
80004e6a:	1a 9b       	mov	r11,sp
80004e6c:	fa c8 ff ed 	sub	r8,sp,-19
80004e70:	1a 99       	mov	r9,sp
80004e72:	30 2a       	mov	r10,2
80004e74:	30 cc       	mov	r12,12
80004e76:	f0 1f 00 12 	mcall	80004ebc <PcdAnticoll+0x7c>
80004e7a:	18 97       	mov	r7,r12

	if (status == MI_OK)
80004e7c:	c1 21       	brne	80004ea0 <PcdAnticoll+0x60>
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
80004e7e:	1b 89       	ld.ub	r9,sp[0x0]
80004e80:	ac 89       	st.b	r6[0x0],r9
80004e82:	1b 98       	ld.ub	r8,sp[0x1]
80004e84:	ac 98       	st.b	r6[0x1],r8
			snr_check ^= ucComMF522Buf[i];
80004e86:	10 59       	eor	r9,r8

	if (status == MI_OK)
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
80004e88:	1b a8       	ld.ub	r8,sp[0x2]
80004e8a:	ac a8       	st.b	r6[0x2],r8
			snr_check ^= ucComMF522Buf[i];
80004e8c:	f3 e8 20 08 	eor	r8,r9,r8

	if (status == MI_OK)
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
80004e90:	1b b9       	ld.ub	r9,sp[0x3]
80004e92:	ac b9       	st.b	r6[0x3],r9
			snr_check ^= ucComMF522Buf[i];
80004e94:	12 58       	eor	r8,r9
		}
		if (snr_check != ucComMF522Buf[i])
80004e96:	1b c9       	ld.ub	r9,sp[0x4]
80004e98:	f0 09 18 00 	cp.b	r9,r8
80004e9c:	f9 b7 01 02 	movne	r7,2
		{   status = MI_ERR;    }
	}
	
	SetBitMask(CollReg,0x80);
80004ea0:	e0 6b 00 80 	mov	r11,128
80004ea4:	30 ec       	mov	r12,14
80004ea6:	f0 1f 00 07 	mcall	80004ec0 <PcdAnticoll+0x80>
	return status;
}
80004eaa:	0e 9c       	mov	r12,r7
80004eac:	2f bd       	sub	sp,-20
80004eae:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004eb2:	00 00       	add	r0,r0
80004eb4:	80 00       	ld.sh	r0,r0[0x0]
80004eb6:	4b 48       	lddpc	r8,80004f84 <CalulateCRC+0x5c>
80004eb8:	80 00       	ld.sh	r0,r0[0x0]
80004eba:	49 a0       	lddpc	r0,80004f20 <PcdRequest+0x5c>
80004ebc:	80 00       	ld.sh	r0,r0[0x0]
80004ebe:	4c c8       	lddpc	r8,80004fec <PcdSelect+0x38>
80004ec0:	80 00       	ld.sh	r0,r0[0x0]
80004ec2:	4b 04       	lddpc	r4,80004f80 <CalulateCRC+0x58>

80004ec4 <PcdRequest>:
//                0x0800 = Mifare_Pro(X)
//                0x4403 = Mifare_DESFire
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdRequest(U8   req_code,U8 *pTagType)
{
80004ec4:	eb cd 40 c0 	pushm	r6-r7,lr
80004ec8:	20 5d       	sub	sp,20
80004eca:	18 97       	mov	r7,r12
80004ecc:	16 96       	mov	r6,r11
	char   status;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];

	ClearBitMask(Status2Reg,0x08);
80004ece:	30 8b       	mov	r11,8
80004ed0:	16 9c       	mov	r12,r11
80004ed2:	f0 1f 00 12 	mcall	80004f18 <PcdRequest+0x54>
	WriteRawRC(BitFramingReg,0x07);
80004ed6:	30 7b       	mov	r11,7
80004ed8:	30 dc       	mov	r12,13
80004eda:	f0 1f 00 11 	mcall	80004f1c <PcdRequest+0x58>
	SetBitMask(TxControlReg,0x03);
80004ede:	30 3b       	mov	r11,3
80004ee0:	31 4c       	mov	r12,20
80004ee2:	f0 1f 00 10 	mcall	80004f20 <PcdRequest+0x5c>
	
	ucComMF522Buf[0] = req_code;
80004ee6:	ba 87       	st.b	sp[0x0],r7

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,1,ucComMF522Buf,&unLen);
80004ee8:	1a 9b       	mov	r11,sp
80004eea:	fa c8 ff ed 	sub	r8,sp,-19
80004eee:	1a 99       	mov	r9,sp
80004ef0:	30 1a       	mov	r10,1
80004ef2:	30 cc       	mov	r12,12
80004ef4:	f0 1f 00 0c 	mcall	80004f24 <PcdRequest+0x60>

	if ((status == MI_OK) && (unLen == 0x10))
80004ef8:	c0 c1       	brne	80004f10 <PcdRequest+0x4c>
80004efa:	31 08       	mov	r8,16
80004efc:	fb 39 00 13 	ld.ub	r9,sp[19]
80004f00:	f0 09 18 00 	cp.b	r9,r8
80004f04:	c0 61       	brne	80004f10 <PcdRequest+0x4c>
	{
		*pTagType     = ucComMF522Buf[0];
80004f06:	1b 88       	ld.ub	r8,sp[0x0]
80004f08:	ac 88       	st.b	r6[0x0],r8
		*(pTagType+1) = ucComMF522Buf[1];
80004f0a:	1b 98       	ld.ub	r8,sp[0x1]
80004f0c:	ac 98       	st.b	r6[0x1],r8
	
	ucComMF522Buf[0] = req_code;

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,1,ucComMF522Buf,&unLen);

	if ((status == MI_OK) && (unLen == 0x10))
80004f0e:	c0 28       	rjmp	80004f12 <PcdRequest+0x4e>
80004f10:	30 2c       	mov	r12,2
	}
	else
	{   status = MI_ERR;   }
	
	return status;
}
80004f12:	2f bd       	sub	sp,-20
80004f14:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004f18:	80 00       	ld.sh	r0,r0[0x0]
80004f1a:	4b 48       	lddpc	r8,80004fe8 <PcdSelect+0x34>
80004f1c:	80 00       	ld.sh	r0,r0[0x0]
80004f1e:	49 a0       	lddpc	r0,80004f84 <CalulateCRC+0x5c>
80004f20:	80 00       	ld.sh	r0,r0[0x0]
80004f22:	4b 04       	lddpc	r4,80004fe0 <PcdSelect+0x2c>
80004f24:	80 00       	ld.sh	r0,r0[0x0]
80004f26:	4c c8       	lddpc	r8,80005054 <rfid_auto_reader+0x2c>

80004f28 <CalulateCRC>:

/////////////////////////////////////////////////////////////////////
//MF522璁＄CRC16芥
/////////////////////////////////////////////////////////////////////
void CalulateCRC(U8 *pIn ,U8   len,U8 *pOut )
{
80004f28:	eb cd 40 f8 	pushm	r3-r7,lr
80004f2c:	18 95       	mov	r5,r12
80004f2e:	16 96       	mov	r6,r11
80004f30:	14 93       	mov	r3,r10
	U8   i,n;
	ClearBitMask(DivIrqReg,0x04);
80004f32:	30 4b       	mov	r11,4
80004f34:	30 5c       	mov	r12,5
80004f36:	f0 1f 00 1c 	mcall	80004fa4 <CalulateCRC+0x7c>
	WriteRawRC(CommandReg,PCD_IDLE);
80004f3a:	30 0b       	mov	r11,0
80004f3c:	30 1c       	mov	r12,1
80004f3e:	f0 1f 00 1b 	mcall	80004fa8 <CalulateCRC+0x80>
	SetBitMask(FIFOLevelReg,0x80);
80004f42:	e0 6b 00 80 	mov	r11,128
80004f46:	30 ac       	mov	r12,10
80004f48:	f0 1f 00 19 	mcall	80004fac <CalulateCRC+0x84>
	for (i=0; i<len; i++)
80004f4c:	58 06       	cp.w	r6,0
80004f4e:	c0 c0       	breq	80004f66 <CalulateCRC+0x3e>
80004f50:	0a 97       	mov	r7,r5
	{   WriteRawRC(FIFODataReg, *(pIn +i));   }
80004f52:	30 94       	mov	r4,9
80004f54:	0f 3b       	ld.ub	r11,r7++
80004f56:	08 9c       	mov	r12,r4
80004f58:	f0 1f 00 14 	mcall	80004fa8 <CalulateCRC+0x80>
{
	U8   i,n;
	ClearBitMask(DivIrqReg,0x04);
	WriteRawRC(CommandReg,PCD_IDLE);
	SetBitMask(FIFOLevelReg,0x80);
	for (i=0; i<len; i++)
80004f5c:	0e 98       	mov	r8,r7
80004f5e:	0a 18       	sub	r8,r5
80004f60:	ec 08 18 00 	cp.b	r8,r6
80004f64:	cf 83       	brcs	80004f54 <CalulateCRC+0x2c>
	{   WriteRawRC(FIFODataReg, *(pIn +i));   }
	WriteRawRC(CommandReg, PCD_CALCCRC);
80004f66:	30 3b       	mov	r11,3
80004f68:	30 1c       	mov	r12,1
80004f6a:	f0 1f 00 10 	mcall	80004fa8 <CalulateCRC+0x80>
	i = 0xFF;
	do
	{
		n = ReadRawRC(DivIrqReg);
80004f6e:	30 5c       	mov	r12,5
80004f70:	f0 1f 00 10 	mcall	80004fb0 <CalulateCRC+0x88>
80004f74:	e0 67 00 fe 	mov	r7,254
80004f78:	30 56       	mov	r6,5
80004f7a:	c0 78       	rjmp	80004f88 <CalulateCRC+0x60>
80004f7c:	0c 9c       	mov	r12,r6
80004f7e:	f0 1f 00 0d 	mcall	80004fb0 <CalulateCRC+0x88>
		i--;
80004f82:	20 17       	sub	r7,1
80004f84:	5c 57       	castu.b	r7
	}
	while ((i!=0) && !(n&0x04));
80004f86:	c0 40       	breq	80004f8e <CalulateCRC+0x66>
80004f88:	e2 1c 00 04 	andl	r12,0x4,COH
80004f8c:	cf 80       	breq	80004f7c <CalulateCRC+0x54>
	pOut [0] = ReadRawRC(CRCResultRegL);
80004f8e:	32 2c       	mov	r12,34
80004f90:	f0 1f 00 08 	mcall	80004fb0 <CalulateCRC+0x88>
80004f94:	a6 8c       	st.b	r3[0x0],r12
	pOut [1] = ReadRawRC(CRCResultRegM);
80004f96:	32 1c       	mov	r12,33
80004f98:	f0 1f 00 06 	mcall	80004fb0 <CalulateCRC+0x88>
80004f9c:	a6 9c       	st.b	r3[0x1],r12
}
80004f9e:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80004fa2:	00 00       	add	r0,r0
80004fa4:	80 00       	ld.sh	r0,r0[0x0]
80004fa6:	4b 48       	lddpc	r8,80005074 <rfid_auto_reader+0x4c>
80004fa8:	80 00       	ld.sh	r0,r0[0x0]
80004faa:	49 a0       	lddpc	r0,80005010 <PcdSelect+0x5c>
80004fac:	80 00       	ld.sh	r0,r0[0x0]
80004fae:	4b 04       	lddpc	r4,8000506c <rfid_auto_reader+0x44>
80004fb0:	80 00       	ld.sh	r0,r0[0x0]
80004fb2:	4a 60       	lddpc	r0,80005048 <rfid_auto_reader+0x20>

80004fb4 <PcdSelect>:
//    斤瀹＄
//拌存: pSnr[IN]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdSelect(U8 *pSnr)
{
80004fb4:	eb cd 40 80 	pushm	r7,lr
80004fb8:	20 5d       	sub	sp,20
	char   status;
	U8   i;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
80004fba:	39 38       	mov	r8,-109
80004fbc:	ba 88       	st.b	sp[0x0],r8
	ucComMF522Buf[1] = 0x70;
80004fbe:	37 08       	mov	r8,112
80004fc0:	ba 98       	st.b	sp[0x1],r8
	ucComMF522Buf[6] = 0;
80004fc2:	30 08       	mov	r8,0
80004fc4:	ba e8       	st.b	sp[0x6],r8
80004fc6:	fa c8 ff fe 	sub	r8,sp,-2
/////////////////////////////////////////////////////////////////////
//    斤瀹＄
//拌存: pSnr[IN]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdSelect(U8 *pSnr)
80004fca:	fa cb ff fa 	sub	r11,sp,-6
	ucComMF522Buf[0] = PICC_ANTICOLL1;
	ucComMF522Buf[1] = 0x70;
	ucComMF522Buf[6] = 0;
	for (i=0; i<4; i++)
	{
		ucComMF522Buf[i+2] = *(pSnr+i);
80004fce:	19 89       	ld.ub	r9,r12[0x0]
80004fd0:	10 c9       	st.b	r8++,r9
		ucComMF522Buf[6]  ^= *(pSnr+i);
80004fd2:	19 3a       	ld.ub	r10,r12++
80004fd4:	1b e9       	ld.ub	r9,sp[0x6]
80004fd6:	f5 e9 20 09 	eor	r9,r10,r9
80004fda:	ba e9       	st.b	sp[0x6],r9
	U8   ucComMF522Buf[MAXRLEN];
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
	ucComMF522Buf[1] = 0x70;
	ucComMF522Buf[6] = 0;
	for (i=0; i<4; i++)
80004fdc:	16 38       	cp.w	r8,r11
80004fde:	cf 81       	brne	80004fce <PcdSelect+0x1a>
	{
		ucComMF522Buf[i+2] = *(pSnr+i);
		ucComMF522Buf[6]  ^= *(pSnr+i);
	}
	CalulateCRC(ucComMF522Buf,7,&ucComMF522Buf[7]);
80004fe0:	1a 97       	mov	r7,sp
80004fe2:	fa ca ff f9 	sub	r10,sp,-7
80004fe6:	30 7b       	mov	r11,7
80004fe8:	1a 9c       	mov	r12,sp
80004fea:	f0 1f 00 0d 	mcall	8000501c <PcdSelect+0x68>
	
	ClearBitMask(Status2Reg,0x08);
80004fee:	30 8b       	mov	r11,8
80004ff0:	16 9c       	mov	r12,r11
80004ff2:	f0 1f 00 0c 	mcall	80005020 <PcdSelect+0x6c>

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,9,ucComMF522Buf,&unLen);
80004ff6:	fa c8 ff ed 	sub	r8,sp,-19
80004ffa:	1a 99       	mov	r9,sp
80004ffc:	30 9a       	mov	r10,9
80004ffe:	1a 9b       	mov	r11,sp
80005000:	30 cc       	mov	r12,12
80005002:	f0 1f 00 09 	mcall	80005024 <PcdSelect+0x70>
	
	if ((status == MI_OK) && (unLen == 0x18))
80005006:	c0 71       	brne	80005014 <PcdSelect+0x60>
80005008:	31 88       	mov	r8,24
8000500a:	fb 39 00 13 	ld.ub	r9,sp[19]
8000500e:	f0 09 18 00 	cp.b	r9,r8
80005012:	c0 20       	breq	80005016 <PcdSelect+0x62>
80005014:	30 2c       	mov	r12,2
	{   status = MI_OK;  }
	else
	{   status = MI_ERR;    }

	return status;
}
80005016:	2f bd       	sub	sp,-20
80005018:	e3 cd 80 80 	ldm	sp++,r7,pc
8000501c:	80 00       	ld.sh	r0,r0[0x0]
8000501e:	4f 28       	lddpc	r8,800051e4 <scan_rfid_save_message+0x4c>
80005020:	80 00       	ld.sh	r0,r0[0x0]
80005022:	4b 48       	lddpc	r8,800050f0 <rfid_auto_reader+0xc8>
80005024:	80 00       	ld.sh	r0,r0[0x0]
80005026:	4c c8       	lddpc	r8,80005154 <scan_patrol+0xc>

80005028 <rfid_auto_reader>:
		//
}

//娴绋锛瀵诲->插叉->->″
U8 rfid_auto_reader(void *card_id)
{
80005028:	eb cd 40 c0 	pushm	r6-r7,lr
8000502c:	18 96       	mov	r6,r12
	U8 status = MI_ERR;
	
	PcdReset();
8000502e:	f0 1f 00 37 	mcall	80005108 <rfid_auto_reader+0xe0>
//while(1){
	status=PcdRequest(PICC_REQALL,	CT);//瀵诲ぉ绾垮哄ㄩㄧ★杩＄绫诲 2瀛
80005032:	4b 7b       	lddpc	r11,8000510c <rfid_auto_reader+0xe4>
80005034:	35 2c       	mov	r12,82
80005036:	f0 1f 00 37 	mcall	80005110 <rfid_auto_reader+0xe8>
8000503a:	18 97       	mov	r7,r12
	if(status!=MI_OK) return status;
8000503c:	c6 31       	brne	80005102 <rfid_auto_reader+0xda>
	//continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
8000503e:	4b 48       	lddpc	r8,8000510c <rfid_auto_reader+0xe4>
80005040:	11 88       	ld.ub	r8,r8[0x0]
80005042:	30 49       	mov	r9,4
80005044:	f2 08 18 00 	cp.b	r8,r9
80005048:	c0 b1       	brne	8000505e <rfid_auto_reader+0x36>
8000504a:	4b 19       	lddpc	r9,8000510c <rfid_auto_reader+0xe4>
8000504c:	13 9a       	ld.ub	r10,r9[0x1]
8000504e:	30 09       	mov	r9,0
80005050:	f2 0a 18 00 	cp.b	r10,r9
80005054:	c0 51       	brne	8000505e <rfid_auto_reader+0x36>
		log("MFOne-S50\n");
80005056:	4b 0c       	lddpc	r12,80005114 <rfid_auto_reader+0xec>
80005058:	f0 1f 00 30 	mcall	80005118 <rfid_auto_reader+0xf0>
//while(1){
	status=PcdRequest(PICC_REQALL,	CT);//瀵诲ぉ绾垮哄ㄩㄧ★杩＄绫诲 2瀛
	if(status!=MI_OK) return status;
	//continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
8000505c:	c3 c8       	rjmp	800050d4 <rfid_auto_reader+0xac>
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
8000505e:	30 29       	mov	r9,2
80005060:	f2 08 18 00 	cp.b	r8,r9
80005064:	c0 b1       	brne	8000507a <rfid_auto_reader+0x52>
80005066:	4a a9       	lddpc	r9,8000510c <rfid_auto_reader+0xe4>
80005068:	13 9a       	ld.ub	r10,r9[0x1]
8000506a:	30 09       	mov	r9,0
8000506c:	f2 0a 18 00 	cp.b	r10,r9
80005070:	c0 51       	brne	8000507a <rfid_auto_reader+0x52>
		log("MFOne-S70\n");
80005072:	4a bc       	lddpc	r12,8000511c <rfid_auto_reader+0xf4>
80005074:	f0 1f 00 29 	mcall	80005118 <rfid_auto_reader+0xf0>
	if(status!=MI_OK) return status;
	//continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
80005078:	c2 e8       	rjmp	800050d4 <rfid_auto_reader+0xac>
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
8000507a:	34 49       	mov	r9,68
8000507c:	f2 08 18 00 	cp.b	r8,r9
80005080:	c0 b1       	brne	80005096 <rfid_auto_reader+0x6e>
80005082:	4a 39       	lddpc	r9,8000510c <rfid_auto_reader+0xe4>
80005084:	13 9a       	ld.ub	r10,r9[0x1]
80005086:	30 09       	mov	r9,0
80005088:	f2 0a 18 00 	cp.b	r10,r9
8000508c:	c0 51       	brne	80005096 <rfid_auto_reader+0x6e>
		log("MF-UltraLight\n");
8000508e:	4a 5c       	lddpc	r12,80005120 <rfid_auto_reader+0xf8>
80005090:	f0 1f 00 22 	mcall	80005118 <rfid_auto_reader+0xf0>
	
	if(CT[0]==0x04&&CT[1]==0x00)
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
80005094:	c2 08       	rjmp	800050d4 <rfid_auto_reader+0xac>
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
80005096:	30 89       	mov	r9,8
80005098:	f2 08 18 00 	cp.b	r8,r9
8000509c:	c0 b1       	brne	800050b2 <rfid_auto_reader+0x8a>
8000509e:	49 c9       	lddpc	r9,8000510c <rfid_auto_reader+0xe4>
800050a0:	13 9a       	ld.ub	r10,r9[0x1]
800050a2:	30 09       	mov	r9,0
800050a4:	f2 0a 18 00 	cp.b	r10,r9
800050a8:	c0 51       	brne	800050b2 <rfid_auto_reader+0x8a>
		log("MF-Pro\n");
800050aa:	49 fc       	lddpc	r12,80005124 <rfid_auto_reader+0xfc>
800050ac:	f0 1f 00 1b 	mcall	80005118 <rfid_auto_reader+0xf0>
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
800050b0:	c1 28       	rjmp	800050d4 <rfid_auto_reader+0xac>
		log("MF-Pro\n");
	else if(CT[0]==0x44&&CT[1]==0x03)
800050b2:	34 49       	mov	r9,68
800050b4:	f2 08 18 00 	cp.b	r8,r9
800050b8:	c0 b1       	brne	800050ce <rfid_auto_reader+0xa6>
800050ba:	49 58       	lddpc	r8,8000510c <rfid_auto_reader+0xe4>
800050bc:	11 99       	ld.ub	r9,r8[0x1]
800050be:	30 38       	mov	r8,3
800050c0:	f0 09 18 00 	cp.b	r9,r8
800050c4:	c0 51       	brne	800050ce <rfid_auto_reader+0xa6>
		log("MF Desire\n");
800050c6:	49 9c       	lddpc	r12,80005128 <rfid_auto_reader+0x100>
800050c8:	f0 1f 00 14 	mcall	80005118 <rfid_auto_reader+0xf0>
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
		log("MF-Pro\n");
	else if(CT[0]==0x44&&CT[1]==0x03)
800050cc:	c0 48       	rjmp	800050d4 <rfid_auto_reader+0xac>
		log("MF Desire\n");
	else
		log("Unknown\n");
800050ce:	49 8c       	lddpc	r12,8000512c <rfid_auto_reader+0x104>
800050d0:	f0 1f 00 12 	mcall	80005118 <rfid_auto_reader+0xf0>
		
	status=PcdAnticoll(SN);//插叉锛杩＄搴 4瀛
800050d4:	49 7c       	lddpc	r12,80005130 <rfid_auto_reader+0x108>
800050d6:	f0 1f 00 18 	mcall	80005134 <rfid_auto_reader+0x10c>
800050da:	18 97       	mov	r7,r12
	if(status!=MI_OK)
800050dc:	c0 60       	breq	800050e8 <rfid_auto_reader+0xc0>
	{
		xcmp_IdleTestTone(Tone_Start, Low_Battery_3);//set tone to noticy failure!!!
800050de:	34 fb       	mov	r11,79
800050e0:	30 1c       	mov	r12,1
800050e2:	f0 1f 00 16 	mcall	80005138 <rfid_auto_reader+0x110>
		return status;
800050e6:	c0 e8       	rjmp	80005102 <rfid_auto_reader+0xda>
		//continue;
	}
	
	//memcpy(MLastSelectedSnr,&RevBuffer[2],4);
	status=PcdSelect(SN);//
800050e8:	49 2c       	lddpc	r12,80005130 <rfid_auto_reader+0x108>
800050ea:	f0 1f 00 15 	mcall	8000513c <rfid_auto_reader+0x114>
800050ee:	18 97       	mov	r7,r12
	if(status!=MI_OK)return status;
800050f0:	c0 91       	brne	80005102 <rfid_auto_reader+0xda>
	//continue;
	else{//℃
			
		memcpy(card_id, SN, 4);
800050f2:	30 4a       	mov	r10,4
800050f4:	48 fb       	lddpc	r11,80005130 <rfid_auto_reader+0x108>
800050f6:	0c 9c       	mov	r12,r6
800050f8:	f0 1f 00 12 	mcall	80005140 <rfid_auto_reader+0x118>
		log("select okay\n");
800050fc:	49 2c       	lddpc	r12,80005144 <rfid_auto_reader+0x11c>
800050fe:	f0 1f 00 07 	mcall	80005118 <rfid_auto_reader+0xf0>
		return status;	
	}
	
//}
	
}
80005102:	0e 9c       	mov	r12,r7
80005104:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005108:	80 00       	ld.sh	r0,r0[0x0]
8000510a:	49 e0       	lddpc	r0,80005180 <scan_patrol+0x38>
8000510c:	00 00       	add	r0,r0
8000510e:	97 3c       	st.w	r11[0xc],r12
80005110:	80 00       	ld.sh	r0,r0[0x0]
80005112:	4e c4       	lddpc	r4,800052c0 <scan_rfid_save_message+0x128>
80005114:	80 00       	ld.sh	r0,r0[0x0]
80005116:	d8 b8       	*unknown*
80005118:	80 00       	ld.sh	r0,r0[0x0]
8000511a:	70 60       	ld.w	r0,r8[0x18]
8000511c:	80 00       	ld.sh	r0,r0[0x0]
8000511e:	d8 c4       	*unknown*
80005120:	80 00       	ld.sh	r0,r0[0x0]
80005122:	d8 d0       	acall	0x8d
80005124:	80 00       	ld.sh	r0,r0[0x0]
80005126:	d8 e0       	acall	0x8e
80005128:	80 00       	ld.sh	r0,r0[0x0]
8000512a:	d8 e8       	*unknown*
8000512c:	80 00       	ld.sh	r0,r0[0x0]
8000512e:	d8 f4       	*unknown*
80005130:	00 00       	add	r0,r0
80005132:	97 40       	st.w	r11[0x10],r0
80005134:	80 00       	ld.sh	r0,r0[0x0]
80005136:	4e 40       	lddpc	r0,800052c4 <scan_rfid_save_message+0x12c>
80005138:	80 00       	ld.sh	r0,r0[0x0]
8000513a:	41 34       	lddsp	r4,sp[0x4c]
8000513c:	80 00       	ld.sh	r0,r0[0x0]
8000513e:	4f b4       	lddpc	r4,80005328 <scan_rfid_save_message+0x190>
80005140:	80 00       	ld.sh	r0,r0[0x0]
80005142:	78 dc       	ld.w	r12,r12[0x34]
80005144:	80 00       	ld.sh	r0,r0[0x0]
80005146:	d9 00       	acall	0x90

80005148 <scan_patrol>:
	return return_err;
	
}

U8 scan_patrol(char* SN)
{
80005148:	eb cd 40 80 	pushm	r7,lr
8000514c:	18 97       	mov	r7,r12
	U8 return_err = MI_ERR;
	
	PcdReset();
8000514e:	f0 1f 00 0d 	mcall	80005180 <scan_patrol+0x38>
	Powerdown_RC522(WAKEUP_RC522);
80005152:	30 0c       	mov	r12,0
80005154:	f0 1f 00 0c 	mcall	80005184 <scan_patrol+0x3c>
	return_err = rfid_auto_reader(SN);
80005158:	0e 9c       	mov	r12,r7
8000515a:	f0 1f 00 0c 	mcall	80005188 <scan_patrol+0x40>
8000515e:	18 97       	mov	r7,r12
	Powerdown_RC522(ENTER_POWERDOWN);
80005160:	30 1c       	mov	r12,1
80005162:	f0 1f 00 09 	mcall	80005184 <scan_patrol+0x3c>
	if(return_err == 0)
80005166:	58 07       	cp.w	r7,0
80005168:	c0 51       	brne	80005172 <scan_patrol+0x2a>
		log("scan_patrol okay!\n");
8000516a:	48 9c       	lddpc	r12,8000518c <scan_patrol+0x44>
8000516c:	f0 1f 00 09 	mcall	80005190 <scan_patrol+0x48>
80005170:	c0 48       	rjmp	80005178 <scan_patrol+0x30>
	else
		log("scan_patrol err!\n");
80005172:	48 9c       	lddpc	r12,80005194 <scan_patrol+0x4c>
80005174:	f0 1f 00 07 	mcall	80005190 <scan_patrol+0x48>
		
	return return_err;

}
80005178:	0e 9c       	mov	r12,r7
8000517a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000517e:	00 00       	add	r0,r0
80005180:	80 00       	ld.sh	r0,r0[0x0]
80005182:	49 e0       	lddpc	r0,800051f8 <scan_rfid_save_message+0x60>
80005184:	80 00       	ld.sh	r0,r0[0x0]
80005186:	4a b8       	lddpc	r8,80005230 <scan_rfid_save_message+0x98>
80005188:	80 00       	ld.sh	r0,r0[0x0]
8000518a:	50 28       	stdsp	sp[0x8],r8
8000518c:	80 00       	ld.sh	r0,r0[0x0]
8000518e:	d9 10       	acall	0x91
80005190:	80 00       	ld.sh	r0,r0[0x0]
80005192:	70 60       	ld.w	r0,r8[0x18]
80005194:	80 00       	ld.sh	r0,r0[0x0]
80005196:	d9 24       	*unknown*

80005198 <scan_rfid_save_message>:
U8 scan_rfid_save_message()
{
80005198:	eb cd 40 e0 	pushm	r5-r7,lr
8000519c:	fa cd 00 8c 	sub	sp,sp,140
	U32 destination = DEST;
	static U8 start_session = 0x80;
	Message_Header_t header;
	Message_Data_t data_buffer;//22bytes
	
	memset(SN, 0x00, 10);
800051a0:	4e 9c       	lddpc	r12,80005344 <scan_rfid_save_message+0x1ac>
800051a2:	30 08       	mov	r8,0
800051a4:	30 09       	mov	r9,0
800051a6:	f8 e9 00 00 	st.d	r12[0],r8
800051aa:	30 0a       	mov	r10,0
800051ac:	b8 4a       	st.h	r12[0x8],r10
	memset(message, 0x00, 80);
800051ae:	fa e9 00 3c 	st.d	sp[60],r8
800051b2:	fa e9 00 44 	st.d	sp[68],r8
800051b6:	fa e9 00 4c 	st.d	sp[76],r8
800051ba:	fa e9 00 54 	st.d	sp[84],r8
800051be:	fa e9 00 5c 	st.d	sp[92],r8
800051c2:	fa e9 00 64 	st.d	sp[100],r8
800051c6:	fa e9 00 6c 	st.d	sp[108],r8
800051ca:	fa e9 00 74 	st.d	sp[116],r8
800051ce:	fa e9 00 7c 	st.d	sp[124],r8
800051d2:	fa e9 00 84 	st.d	sp[132],r8
	
	return_err = scan_patrol(SN);
800051d6:	f0 1f 00 5d 	mcall	80005348 <scan_rfid_save_message+0x1b0>
800051da:	18 97       	mov	r7,r12
	
	if(return_err == 0){
800051dc:	e0 81 00 a8 	brne	8000532c <scan_rfid_save_message+0x194>
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
800051e0:	4d 96       	lddpc	r6,80005344 <scan_rfid_save_message+0x1ac>
800051e2:	0d b8       	ld.ub	r8,r6[0x3]
800051e4:	1a d8       	st.w	--sp,r8
800051e6:	0d a8       	ld.ub	r8,r6[0x2]
800051e8:	1a d8       	st.w	--sp,r8
800051ea:	0d 98       	ld.ub	r8,r6[0x1]
800051ec:	1a d8       	st.w	--sp,r8
800051ee:	0d 88       	ld.ub	r8,r6[0x0]
800051f0:	1a d8       	st.w	--sp,r8
800051f2:	4d 7c       	lddpc	r12,8000534c <scan_rfid_save_message+0x1b4>
800051f4:	f0 1f 00 57 	mcall	80005350 <scan_rfid_save_message+0x1b8>
		xcmp_IdleTestTone(Tone_Start, Ring_Style_Tone_8);//set tone to indicate scan rfid success!!!
800051f8:	34 4b       	mov	r11,68
800051fa:	30 1c       	mov	r12,1
800051fc:	f0 1f 00 56 	mcall	80005354 <scan_rfid_save_message+0x1bc>
80005200:	fa c8 ff ce 	sub	r8,sp,-50
80005204:	fa c9 ff cc 	sub	r9,sp,-52
		log("scan_patrol err!\n");
		
	return return_err;

}
U8 scan_rfid_save_message()
80005208:	ec c5 ff fc 	sub	r5,r6,-4
8000520c:	2f cd       	sub	sp,-16
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, Ring_Style_Tone_8);//set tone to indicate scan rfid success!!!
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″
			
			temp = ((SN[i] & 0xF0) >> 4);//瀛楂浣
			if((temp >= 0) && (temp <= 9))data_buffer.RFID_ID[i*4] = temp+0x30;
8000520e:	30 9e       	mov	lr,9
			else
			data_buffer.RFID_ID[i*4] = ((temp - 0x0a)+0x61);
			
			data_buffer.RFID_ID[i*4+1] = 0x00;
80005210:	30 0c       	mov	r12,0
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, Ring_Style_Tone_8);//set tone to indicate scan rfid success!!!
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″
			
			temp = ((SN[i] & 0xF0) >> 4);//瀛楂浣
80005212:	0d 8a       	ld.ub	r10,r6[0x0]
80005214:	f4 0b 16 04 	lsr	r11,r10,0x4
			if((temp >= 0) && (temp <= 9))data_buffer.RFID_ID[i*4] = temp+0x30;
80005218:	fc 0b 18 00 	cp.b	r11,lr
8000521c:	f7 bb 08 d0 	subls	r11,-48
80005220:	f1 fb 8e 00 	st.bls	r8[0x0],r11
			else
			data_buffer.RFID_ID[i*4] = ((temp - 0x0a)+0x61);
80005224:	f7 bb 0b a9 	subhi	r11,-87
80005228:	f1 fb be 00 	st.bhi	r8[0x0],r11
			
			data_buffer.RFID_ID[i*4+1] = 0x00;
8000522c:	b0 9c       	st.b	r8[0x1],r12
			
			temp = (SN[i] & 0x0F);//瀛浣浣
8000522e:	f5 da c0 04 	bfextu	r10,r10,0x0,0x4
			if((temp >= 0) && (temp <= 9))data_buffer.RFID_ID[i*4+2] = temp+0x30;
80005232:	fc 0a 18 00 	cp.b	r10,lr
80005236:	f7 ba 08 d0 	subls	r10,-48
8000523a:	f3 fa 8e 00 	st.bls	r9[0x0],r10
			else
			data_buffer.RFID_ID[i*4+2] = ((temp - 0x0a)+0x61);
8000523e:	f7 ba 0b a9 	subhi	r10,-87
80005242:	f3 fa be 00 	st.bhi	r9[0x0],r10

			data_buffer.RFID_ID[i*4+3] = 0x00;
80005246:	b0 bc       	st.b	r8[0x3],r12
80005248:	2f f6       	sub	r6,-1
8000524a:	2f c8       	sub	r8,-4
8000524c:	2f c9       	sub	r9,-4
	
	if(return_err == 0){
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, Ring_Style_Tone_8);//set tone to indicate scan rfid success!!!
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″
8000524e:	0a 36       	cp.w	r6,r5
80005250:	ce 11       	brne	80005212 <scan_rfid_save_message+0x7a>
		
		//memcpy(&data_buffer.XG_Time.Year, &Current_time.Year, sizeof(DateTime_t))	;
		
		header.length = (0x0008 + sizeof(Message_Data_t));
		
		if(start_session > 0x9f)start_session = 0x80;
80005252:	4c 28       	lddpc	r8,80005358 <scan_rfid_save_message+0x1c0>
80005254:	11 89       	ld.ub	r9,r8[0x0]
80005256:	39 f8       	mov	r8,-97
80005258:	f0 09 18 00 	cp.b	r9,r8
8000525c:	e0 88 00 05 	brls	80005266 <scan_rfid_save_message+0xce>
80005260:	38 09       	mov	r9,-128
80005262:	4b e8       	lddpc	r8,80005358 <scan_rfid_save_message+0x1c0>
80005264:	b0 89       	st.b	r8[0x0],r9
		
		header.session_id = (++start_session);
80005266:	4b d8       	lddpc	r8,80005358 <scan_rfid_save_message+0x1c0>
80005268:	11 86       	ld.ub	r6,r8[0x0]
8000526a:	2f f6       	sub	r6,-1
8000526c:	b0 86       	st.b	r8[0x0],r6
		
		memcpy(&header.fixed_data[0], unsure_data, sizeof(unsure_data));
8000526e:	30 5a       	mov	r10,5
80005270:	4b bb       	lddpc	r11,8000535c <scan_rfid_save_message+0x1c4>
80005272:	fa cc ff c9 	sub	r12,sp,-55
80005276:	f0 1f 00 3b 	mcall	80005360 <scan_rfid_save_message+0x1c8>
		header.type = 0xe000;
		
		memcpy(message, &header, sizeof(Message_Header_t));//疯header版
8000527a:	31 88       	mov	r8,24
8000527c:	fb 58 00 32 	st.h	sp[50],r8
80005280:	fb 66 00 36 	st.b	sp[54],r6
80005284:	fe 78 e0 00 	mov	r8,-8192
80005288:	fb 58 00 34 	st.h	sp[52],r8
8000528c:	fa c6 ff c4 	sub	r6,sp,-60
80005290:	30 aa       	mov	r10,10
80005292:	fa cb ff ce 	sub	r11,sp,-50
80005296:	0c 9c       	mov	r12,r6
80005298:	f0 1f 00 32 	mcall	80005360 <scan_rfid_save_message+0x1c8>
		memcpy(&message[sizeof(Message_Header_t)], &data_buffer, sizeof(Message_Data_t));//疯淇″瀹规版
8000529c:	31 0a       	mov	r10,16
8000529e:	fa cb ff de 	sub	r11,sp,-34
800052a2:	fa cc ff ba 	sub	r12,sp,-70
800052a6:	f0 1f 00 2f 	mcall	80005360 <scan_rfid_save_message+0x1c8>
		
		//xcmp_data_session_req(message, (sizeof(Message_Header_t)+sizeof(Message_Data_t)), destination);
		Message_Protocol_t  xgmessage;
		memcpy(&xgmessage, message, sizeof(Message_Protocol_t));
800052aa:	31 aa       	mov	r10,26
800052ac:	0c 9b       	mov	r11,r6
800052ae:	fa cc ff fe 	sub	r12,sp,-2
800052b2:	f0 1f 00 2c 	mcall	80005360 <scan_rfid_save_message+0x1c8>

		Message_Protocol_t * myptr = get_message_store();
800052b6:	4a c8       	lddpc	r8,80005364 <scan_rfid_save_message+0x1cc>
800052b8:	70 0c       	ld.w	r12,r8[0x0]
800052ba:	f0 1f 00 2c 	mcall	80005368 <scan_rfid_save_message+0x1d0>
800052be:	50 7c       	stdsp	sp[0x1c],r12
		if(NULL != myptr)
800052c0:	c3 20       	breq	80005324 <scan_rfid_save_message+0x18c>
		{
			memcpy(myptr, &xgmessage, sizeof(Message_Protocol_t));
800052c2:	31 aa       	mov	r10,26
800052c4:	fa cb ff fe 	sub	r11,sp,-2
800052c8:	f0 1f 00 26 	mcall	80005360 <scan_rfid_save_message+0x1c8>
			if (xQueueSend(xg_resend_queue, &myptr, 0) != pdPASS)
800052cc:	4a 88       	lddpc	r8,8000536c <scan_rfid_save_message+0x1d4>
800052ce:	70 0c       	ld.w	r12,r8[0x0]
800052d0:	30 09       	mov	r9,0
800052d2:	12 9a       	mov	r10,r9
800052d4:	fa cb ff e4 	sub	r11,sp,-28
800052d8:	f0 1f 00 26 	mcall	80005370 <scan_rfid_save_message+0x1d8>
800052dc:	58 1c       	cp.w	r12,1
800052de:	c1 10       	breq	80005300 <scan_rfid_save_message+0x168>
			{
				log("xg_resend_queue: full\n" );
800052e0:	4a 5c       	lddpc	r12,80005374 <scan_rfid_save_message+0x1dc>
800052e2:	f0 1f 00 1c 	mcall	80005350 <scan_rfid_save_message+0x1b8>
				xcmp_IdleTestTone(Tone_Start, Dispatch_Busy);//set tone to indicate queue full!!!
800052e6:	32 3b       	mov	r11,35
800052e8:	30 1c       	mov	r12,1
800052ea:	f0 1f 00 1b 	mcall	80005354 <scan_rfid_save_message+0x1bc>
				vTaskDelay(3000*2 / portTICK_RATE_MS);//寤惰3000ms
800052ee:	e0 6c 17 70 	mov	r12,6000
800052f2:	f0 1f 00 22 	mcall	80005378 <scan_rfid_save_message+0x1e0>
				xcmp_IdleTestTone(Tone_Stop, Dispatch_Busy);//set tone to indicate queue full!!!
800052f6:	32 3b       	mov	r11,35
800052f8:	30 0c       	mov	r12,0
800052fa:	f0 1f 00 17 	mcall	80005354 <scan_rfid_save_message+0x1bc>
800052fe:	c1 e8       	rjmp	8000533a <scan_rfid_save_message+0x1a2>
			}
			else{
				
				xSemaphoreTake(count_mutex, portMAX_DELAY);
80005300:	49 f6       	lddpc	r6,8000537c <scan_rfid_save_message+0x1e4>
80005302:	6c 0c       	ld.w	r12,r6[0x0]
80005304:	30 09       	mov	r9,0
80005306:	3f fa       	mov	r10,-1
80005308:	12 9b       	mov	r11,r9
8000530a:	f0 1f 00 1e 	mcall	80005380 <scan_rfid_save_message+0x1e8>
				global_count++;
8000530e:	49 e8       	lddpc	r8,80005384 <scan_rfid_save_message+0x1ec>
80005310:	70 09       	ld.w	r9,r8[0x0]
80005312:	2f f9       	sub	r9,-1
80005314:	91 09       	st.w	r8[0x0],r9
				xSemaphoreGive(count_mutex);
80005316:	6c 0c       	ld.w	r12,r6[0x0]
80005318:	30 09       	mov	r9,0
8000531a:	12 9a       	mov	r10,r9
8000531c:	12 9b       	mov	r11,r9
8000531e:	f0 1f 00 15 	mcall	80005370 <scan_rfid_save_message+0x1d8>
80005322:	c0 c8       	rjmp	8000533a <scan_rfid_save_message+0x1a2>
			}

		}
		else
		{
			log("myptr: err\n\r" );
80005324:	49 9c       	lddpc	r12,80005388 <scan_rfid_save_message+0x1f0>
80005326:	f0 1f 00 0b 	mcall	80005350 <scan_rfid_save_message+0x1b8>
8000532a:	c0 88       	rjmp	8000533a <scan_rfid_save_message+0x1a2>
		}
		
	}
	else
	{
		xcmp_IdleTestTone(Tone_Start, Low_Battery_3);//set tone to indicate scan rfid failure!!!
8000532c:	34 fb       	mov	r11,79
8000532e:	30 1c       	mov	r12,1
80005330:	f0 1f 00 09 	mcall	80005354 <scan_rfid_save_message+0x1bc>
		log("no card find...\n");
80005334:	49 6c       	lddpc	r12,8000538c <scan_rfid_save_message+0x1f4>
80005336:	f0 1f 00 07 	mcall	80005350 <scan_rfid_save_message+0x1b8>
	}
	
	return return_err;
	
}
8000533a:	0e 9c       	mov	r12,r7
8000533c:	2d dd       	sub	sp,-140
8000533e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80005342:	00 00       	add	r0,r0
80005344:	00 00       	add	r0,r0
80005346:	0b 60       	ld.uh	r0,--r5
80005348:	80 00       	ld.sh	r0,r0[0x0]
8000534a:	51 48       	stdsp	sp[0x50],r8
8000534c:	80 00       	ld.sh	r0,r0[0x0]
8000534e:	d9 38       	*unknown*
80005350:	80 00       	ld.sh	r0,r0[0x0]
80005352:	70 60       	ld.w	r0,r8[0x18]
80005354:	80 00       	ld.sh	r0,r0[0x0]
80005356:	41 34       	lddsp	r4,sp[0x4c]
80005358:	00 00       	add	r0,r0
8000535a:	05 28       	ld.uh	r8,r2++
8000535c:	00 00       	add	r0,r0
8000535e:	05 2c       	ld.uh	r12,r2++
80005360:	80 00       	ld.sh	r0,r0[0x0]
80005362:	78 dc       	ld.w	r12,r12[0x34]
80005364:	00 00       	add	r0,r0
80005366:	0b 70       	ld.ub	r0,--r5
80005368:	80 00       	ld.sh	r0,r0[0x0]
8000536a:	2e 78       	sub	r8,-25
8000536c:	00 00       	add	r0,r0
8000536e:	0b 6c       	ld.uh	r12,--r5
80005370:	80 00       	ld.sh	r0,r0[0x0]
80005372:	64 28       	ld.w	r8,r2[0x8]
80005374:	80 00       	ld.sh	r0,r0[0x0]
80005376:	d6 d8       	*unknown*
80005378:	80 00       	ld.sh	r0,r0[0x0]
8000537a:	6a f4       	ld.w	r4,r5[0x3c]
8000537c:	00 00       	add	r0,r0
8000537e:	0a 60       	and	r0,r5
80005380:	80 00       	ld.sh	r0,r0[0x0]
80005382:	62 1c       	ld.w	r12,r1[0x4]
80005384:	00 00       	add	r0,r0
80005386:	0a 44       	or	r4,r5
80005388:	80 00       	ld.sh	r0,r0[0x0]
8000538a:	d7 cc       	*unknown*
8000538c:	80 00       	ld.sh	r0,r0[0x0]
8000538e:	d9 54       	*unknown*

80005390 <rfid_init>:
extern volatile U32 global_count;
extern volatile xSemaphoreHandle count_mutex;


void rfid_init()
{
80005390:	d4 01       	pushm	lr
	char card_id[4]={0};
	//tc_init();//ㄥ跺200msㄥ诲
	
	rc522_init();
80005392:	f0 1f 00 02 	mcall	80005398 <rfid_init+0x8>
	
	//if(rfid_auto_reader(card_id) == 0){
		//log("card_id : 0x%x, 0x%x, 0x%x, 0x%x\n", &card_id[0], &card_id[1], &card_id[2], &card_id[3]);	
	//}
		//
}
80005396:	d8 02       	popm	pc
80005398:	80 00       	ld.sh	r0,r0[0x0]
8000539a:	4b f0       	lddpc	r0,80005494 <local_start_pll0+0x64>

8000539c <delay_ns>:
}

void delay_ns(U32 ns)
{
	U32 i;
	for(i=0;i<ns;i++)
8000539c:	58 0c       	cp.w	r12,0
8000539e:	5e 0c       	reteq	r12
800053a0:	30 08       	mov	r8,0
	{
		nop();
800053a2:	d7 03       	nop
		nop();
800053a4:	d7 03       	nop
		nop();
800053a6:	d7 03       	nop
}

void delay_ns(U32 ns)
{
	U32 i;
	for(i=0;i<ns;i++)
800053a8:	2f f8       	sub	r8,-1
800053aa:	10 3c       	cp.w	r12,r8
800053ac:	fe 9b ff fb 	brhi	800053a2 <delay_ns+0x6>
800053b0:	5e fc       	retal	r12
800053b2:	d7 03       	nop

800053b4 <delay_us>:
		nop();
		nop();
	}
}
void delay_us(U32 us)
{
800053b4:	eb cd 40 e0 	pushm	r5-r7,lr
800053b8:	18 96       	mov	r6,r12
	for(int i =0; i<us; i++){
800053ba:	58 0c       	cp.w	r12,0
800053bc:	c0 b0       	breq	800053d2 <delay_us+0x1e>
800053be:	30 07       	mov	r7,0
		delay_ns(1000);
800053c0:	e0 65 03 e8 	mov	r5,1000
800053c4:	0a 9c       	mov	r12,r5
800053c6:	f0 1f 00 05 	mcall	800053d8 <delay_us+0x24>
		nop();
	}
}
void delay_us(U32 us)
{
	for(int i =0; i<us; i++){
800053ca:	2f f7       	sub	r7,-1
800053cc:	0e 36       	cp.w	r6,r7
800053ce:	fe 9b ff fb 	brhi	800053c4 <delay_us+0x10>
800053d2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800053d6:	00 00       	add	r0,r0
800053d8:	80 00       	ld.sh	r0,r0[0x0]
800053da:	53 9c       	stdsp	sp[0xe4],r12

800053dc <delay_ms>:
		delay_ns(1000);
	}

}
void delay_ms(U32 ms)
{
800053dc:	eb cd 40 e0 	pushm	r5-r7,lr
800053e0:	18 96       	mov	r6,r12
	for(int i =0; i<ms; i++){
800053e2:	58 0c       	cp.w	r12,0
800053e4:	c0 b0       	breq	800053fa <delay_ms+0x1e>
800053e6:	30 07       	mov	r7,0
		delay_us(1000);
800053e8:	e0 65 03 e8 	mov	r5,1000
800053ec:	0a 9c       	mov	r12,r5
800053ee:	f0 1f 00 05 	mcall	80005400 <delay_ms+0x24>
	}

}
void delay_ms(U32 ms)
{
	for(int i =0; i<ms; i++){
800053f2:	2f f7       	sub	r7,-1
800053f4:	0e 36       	cp.w	r6,r7
800053f6:	fe 9b ff fb 	brhi	800053ec <delay_ms+0x10>
800053fa:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800053fe:	00 00       	add	r0,r0
80005400:	80 00       	ld.sh	r0,r0[0x0]
80005402:	53 b4       	stdsp	sp[0xec],r4

80005404 <local_start_timer>:
//	SSC_TX_DATA_ENABLE		AVR32_TC_A0_0_0_PIN					[32 PortB Pin  0 00000001 Func 0]
//	MAKO_TX					AVR32_SSC_TX_DATA_0_PIN				[42 PortB Pin 10 00000400 Func 0]
//	MAKO_RX					AVR32_SSC_RX_DATA_0_PIN				[39 PortB Pin  7 00000080 Func 0]
//
void local_start_timer(void)
{
80005404:	d4 01       	pushm	lr
	{
		{TIMER_TC_CLK_PIN,      TIMER_TC_CLK_FUNCTION     },
		{TIMER_TC_FS_PIN,       TIMER_TC_FS_FUNCTION      },
		{TIMER_EN_CLK_PIN,      TIMER_EN_CLK_FUNCTION     }
	};
	gpio_enable_module(TC_GPIO_MAP, sizeof(TC_GPIO_MAP) / sizeof(TC_GPIO_MAP[0]));
80005406:	30 3b       	mov	r11,3
80005408:	48 8c       	lddpc	r12,80005428 <local_start_timer+0x24>
8000540a:	f0 1f 00 09 	mcall	8000542c <local_start_timer+0x28>

	(&AVR32_TC)->channel[0].cmr =
8000540e:	fe 78 38 00 	mov	r8,-51200
80005412:	e0 69 91 0d 	mov	r9,37133
80005416:	ea 19 00 52 	orh	r9,0x52
8000541a:	91 19       	st.w	r8[0x4],r9
	1                          << AVR32_TC_CLKI_OFFSET     |
	AVR32_TC_TCCLKS_XC0        << AVR32_TC_TCCLKS_OFFSET;



	(&AVR32_TC)->channel[0].ra = 32;
8000541c:	32 09       	mov	r9,32
8000541e:	91 59       	st.w	r8[0x14],r9
	(&AVR32_TC)->channel[0].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
80005420:	30 59       	mov	r9,5
80005422:	91 09       	st.w	r8[0x0],r9
}
80005424:	d8 02       	popm	pc
80005426:	00 00       	add	r0,r0
80005428:	80 00       	ld.sh	r0,r0[0x0]
8000542a:	d9 68       	*unknown*
8000542c:	80 00       	ld.sh	r0,r0[0x0]
8000542e:	55 b4       	stdsp	sp[0x16c],r4

80005430 <local_start_pll0>:
//In the SSC description, Master Clock (MCK) is the bus clock of the peripheral bus to which the
//SSC is connected. [23.6.2]
//Switch to clock Osc0 (crystal)
//start PLL0 and switch main clock to PLL0 output
void local_start_pll0(void)
{
80005430:	d4 01       	pushm	lr
	AVR32_HMATRIX.mcfg[AVR32_HMATRIX_MASTER_CPU_INSTRUCTION] = 0x1;
	
***/
	
/*****/
	pm_switch_to_osc0(&AVR32_PM, 12000000, OSC0_STARTUP);
80005432:	30 3a       	mov	r10,3
80005434:	e0 6b 1b 00 	mov	r11,6912
80005438:	ea 1b 00 b7 	orh	r11,0xb7
8000543c:	fe 7c 0c 00 	mov	r12,-62464
80005440:	f0 1f 00 19 	mcall	800054a4 <local_start_pll0+0x74>

	pm_pll_setup(&AVR32_PM,
80005444:	31 08       	mov	r8,16
80005446:	1a d8       	st.w	--sp,r8
80005448:	30 08       	mov	r8,0
8000544a:	30 19       	mov	r9,1
8000544c:	30 7a       	mov	r10,7
8000544e:	10 9b       	mov	r11,r8
80005450:	fe 7c 0c 00 	mov	r12,-62464
80005454:	f0 1f 00 15 	mcall	800054a8 <local_start_pll0+0x78>
	               0,   // use PLL0
	               7,   // MUL=7 in the formula
	               1,   // DIV=1 in the formula
	               0,   // Sel Osc0/PLL0 or Osc1/PLL1
	               16); // lockcount in main clock for the PLL wait lock
	pm_pll_set_option(&AVR32_PM, 0, //PLL number 0
80005458:	30 08       	mov	r8,0
8000545a:	30 19       	mov	r9,1
8000545c:	12 9a       	mov	r10,r9
8000545e:	10 9b       	mov	r11,r8
80005460:	fe 7c 0c 00 	mov	r12,-62464
80005464:	f0 1f 00 12 	mcall	800054ac <local_start_pll0+0x7c>
	                        1, //freq Set to 1 for VCO frequency range 80-180MHz
	                        1, //div2 Divide the PLL output frequency by 2
	                        0);//0 to enable the Wide-Bandith Mode
	pm_pll_enable(&AVR32_PM,0);
80005468:	30 0b       	mov	r11,0
8000546a:	fe 7c 0c 00 	mov	r12,-62464
8000546e:	f0 1f 00 11 	mcall	800054b0 <local_start_pll0+0x80>


	pm_wait_for_pll0_locked(&AVR32_PM);
80005472:	fe 7c 0c 00 	mov	r12,-62464
80005476:	f0 1f 00 10 	mcall	800054b4 <local_start_pll0+0x84>


	pm_cksel(&AVR32_PM, 1,  //Bus A clock divisor enable = 1
8000547a:	30 0a       	mov	r10,0
8000547c:	1a da       	st.w	--sp,r10
8000547e:	1a da       	st.w	--sp,r10
80005480:	14 98       	mov	r8,r10
80005482:	14 99       	mov	r9,r10
80005484:	30 1b       	mov	r11,1
80005486:	fe 7c 0c 00 	mov	r12,-62464
8000548a:	f0 1f 00 0c 	mcall	800054b8 <local_start_pll0+0x88>
	             0,  //B clock divisor enable = 0
	             0,  //Bus B select = 0
	             0,  //HS Bus clock divisor enable = 0
	             0); //HS Bus select = 0
				 
	flashc_set_wait_state(1);
8000548e:	30 1c       	mov	r12,1
80005490:	f0 1f 00 0b 	mcall	800054bc <local_start_pll0+0x8c>
	//AVR32_FLASHC.fcr = 0x00000040;

	pm_switch_to_clock(&AVR32_PM, AVR32_PM_MCSEL_PLL0);
80005494:	30 2b       	mov	r11,2
80005496:	fe 7c 0c 00 	mov	r12,-62464
8000549a:	f0 1f 00 0a 	mcall	800054c0 <local_start_pll0+0x90>
8000549e:	2f dd       	sub	sp,-12
/****/
}
800054a0:	d8 02       	popm	pc
800054a2:	00 00       	add	r0,r0
800054a4:	80 00       	ld.sh	r0,r0[0x0]
800054a6:	58 68       	cp.w	r8,6
800054a8:	80 00       	ld.sh	r0,r0[0x0]
800054aa:	58 0a       	cp.w	r10,0
800054ac:	80 00       	ld.sh	r0,r0[0x0]
800054ae:	58 2c       	cp.w	r12,2
800054b0:	80 00       	ld.sh	r0,r0[0x0]
800054b2:	58 46       	cp.w	r6,4
800054b4:	80 00       	ld.sh	r0,r0[0x0]
800054b6:	58 54       	cp.w	r4,5
800054b8:	80 00       	ld.sh	r0,r0[0x0]
800054ba:	57 c4       	stdsp	sp[0x1f0],r4
800054bc:	80 00       	ld.sh	r0,r0[0x0]
800054be:	55 54       	stdsp	sp[0x154],r4
800054c0:	80 00       	ld.sh	r0,r0[0x0]
800054c2:	58 5e       	cp.w	lr,5

800054c4 <xg_flashc_init>:
}


//U16	Current_total_message_count=0;
void xg_flashc_init(void)
{
800054c4:	eb cd 40 e0 	pushm	r5-r7,lr
	//{
		//log("Create the xgflash_mutex semaphore failure\n");
	//}
	//
	/* Create the binary semaphore to Synchronize other threads.*/
	vSemaphoreCreateBinary(xBinarySemaphore);
800054c8:	30 0b       	mov	r11,0
800054ca:	30 1c       	mov	r12,1
800054cc:	f0 1f 00 19 	mcall	80005530 <xg_flashc_init+0x6c>
800054d0:	49 98       	lddpc	r8,80005534 <xg_flashc_init+0x70>
800054d2:	91 0c       	st.w	r8[0x0],r12
800054d4:	70 08       	ld.w	r8,r8[0x0]
800054d6:	58 08       	cp.w	r8,0
800054d8:	c0 80       	breq	800054e8 <xg_flashc_init+0x24>
800054da:	49 78       	lddpc	r8,80005534 <xg_flashc_init+0x70>
800054dc:	70 0c       	ld.w	r12,r8[0x0]
800054de:	30 09       	mov	r9,0
800054e0:	12 9a       	mov	r10,r9
800054e2:	12 9b       	mov	r11,r9
800054e4:	f0 1f 00 15 	mcall	80005538 <xg_flashc_init+0x74>
	if (xBinarySemaphore == NULL)
800054e8:	49 38       	lddpc	r8,80005534 <xg_flashc_init+0x70>
800054ea:	70 08       	ld.w	r8,r8[0x0]
800054ec:	58 08       	cp.w	r8,0
800054ee:	c0 41       	brne	800054f6 <xg_flashc_init+0x32>
	{
		log("Create the xBinarySemaphore failure\n");
800054f0:	49 3c       	lddpc	r12,8000553c <xg_flashc_init+0x78>
800054f2:	f0 1f 00 14 	mcall	80005540 <xg_flashc_init+0x7c>
	//if (SendM_CountingSemaphore == NULL)
	//{
		//log("Create the SendM_Counting semaphore failure\n");
	//}
	//
	xg_resend_queue = xQueueCreate(300, sizeof(U32));
800054f6:	30 4b       	mov	r11,4
800054f8:	e0 6c 01 2c 	mov	r12,300
800054fc:	f0 1f 00 0d 	mcall	80005530 <xg_flashc_init+0x6c>
80005500:	49 18       	lddpc	r8,80005544 <xg_flashc_init+0x80>
80005502:	91 0c       	st.w	r8[0x0],r12
	/*initialize the queue*/
	message_storage_queue = xQueueCreate(MAX_MESSAGE_STORE, sizeof(U32));
80005504:	30 4b       	mov	r11,4
80005506:	e0 6c 01 90 	mov	r12,400
8000550a:	f0 1f 00 0a 	mcall	80005530 <xg_flashc_init+0x6c>
8000550e:	48 f8       	lddpc	r8,80005548 <xg_flashc_init+0x84>
80005510:	91 0c       	st.w	r8[0x0],r12
80005512:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_MESSAGE_STORE; i++ )
	{
		set_message_store(&message_store[i]);//push <message_store> address to the message_storage_queue;
80005514:	10 96       	mov	r6,r8
80005516:	48 e5       	lddpc	r5,8000554c <xg_flashc_init+0x88>
80005518:	6c 0c       	ld.w	r12,r6[0x0]
8000551a:	ea 07 00 0b 	add	r11,r5,r7
8000551e:	f0 1f 00 0d 	mcall	80005550 <xg_flashc_init+0x8c>
80005522:	2e 67       	sub	r7,-26
	//}
	//
	xg_resend_queue = xQueueCreate(300, sizeof(U32));
	/*initialize the queue*/
	message_storage_queue = xQueueCreate(MAX_MESSAGE_STORE, sizeof(U32));
	for(int i= 0; i < MAX_MESSAGE_STORE; i++ )
80005524:	e0 47 28 a0 	cp.w	r7,10400
80005528:	cf 81       	brne	80005518 <xg_flashc_init+0x54>
	//flashc_lock_all_regions(false);
	//xgflash_list_info_init();
	
	
	//create_xg_flash_test_task();
}
8000552a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000552e:	00 00       	add	r0,r0
80005530:	80 00       	ld.sh	r0,r0[0x0]
80005532:	65 80       	ld.w	r0,r2[0x60]
80005534:	00 00       	add	r0,r0
80005536:	0b 74       	ld.ub	r4,--r5
80005538:	80 00       	ld.sh	r0,r0[0x0]
8000553a:	64 28       	ld.w	r8,r2[0x8]
8000553c:	80 00       	ld.sh	r0,r0[0x0]
8000553e:	d9 80       	acall	0x98
80005540:	80 00       	ld.sh	r0,r0[0x0]
80005542:	70 60       	ld.w	r0,r8[0x18]
80005544:	00 00       	add	r0,r0
80005546:	0b 6c       	ld.uh	r12,--r5
80005548:	00 00       	add	r0,r0
8000554a:	0b 70       	ld.ub	r0,--r5
8000554c:	00 00       	add	r0,r0
8000554e:	97 44       	st.w	r11[0x10],r4
80005550:	80 00       	ld.sh	r0,r0[0x0]
80005552:	2c cc       	sub	r12,-52

80005554 <flashc_set_wait_state>:
}


void flashc_set_wait_state(unsigned int wait_state)
{
	u_avr32_flashc_fcr_t u_avr32_flashc_fcr = {AVR32_FLASHC.fcr};
80005554:	fe 68 14 00 	mov	r8,-125952
80005558:	70 09       	ld.w	r9,r8[0x0]
	u_avr32_flashc_fcr.FCR.fws = wait_state;
8000555a:	f3 dc d0 c1 	bfins	r9,r12,0x6,0x1
	AVR32_FLASHC.fcr = u_avr32_flashc_fcr.fcr;
8000555e:	91 09       	st.w	r8[0x0],r9
}
80005560:	5e fc       	retal	r12

80005562 <gpio_enable_module_pin>:
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80005562:	f8 08 16 05 	lsr	r8,r12,0x5
80005566:	a9 68       	lsl	r8,0x8
80005568:	e0 28 f0 00 	sub	r8,61440

	/* Enable the correct function. */
	switch (function) {
8000556c:	58 1b       	cp.w	r11,1
8000556e:	c0 d0       	breq	80005588 <gpio_enable_module_pin+0x26>
80005570:	c0 63       	brcs	8000557c <gpio_enable_module_pin+0x1a>
80005572:	58 2b       	cp.w	r11,2
80005574:	c1 00       	breq	80005594 <gpio_enable_module_pin+0x32>
80005576:	58 3b       	cp.w	r11,3
80005578:	c1 40       	breq	800055a0 <gpio_enable_module_pin+0x3e>
8000557a:	5e ff       	retal	1
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
8000557c:	30 19       	mov	r9,1
8000557e:	f2 0c 09 49 	lsl	r9,r9,r12
80005582:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80005584:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80005586:	c1 28       	rjmp	800055aa <gpio_enable_module_pin+0x48>

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80005588:	30 19       	mov	r9,1
8000558a:	f2 0c 09 49 	lsl	r9,r9,r12
8000558e:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80005590:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80005592:	c0 c8       	rjmp	800055aa <gpio_enable_module_pin+0x48>

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80005594:	30 19       	mov	r9,1
80005596:	f2 0c 09 49 	lsl	r9,r9,r12
8000559a:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
8000559c:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
8000559e:	c0 68       	rjmp	800055aa <gpio_enable_module_pin+0x48>

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
800055a0:	30 19       	mov	r9,1
800055a2:	f2 0c 09 49 	lsl	r9,r9,r12
800055a6:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
800055a8:	91 99       	st.w	r8[0x24],r9
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
800055aa:	30 19       	mov	r9,1
800055ac:	f2 0c 09 4c 	lsl	r12,r9,r12
800055b0:	91 2c       	st.w	r8[0x8],r12
800055b2:	5e fd       	retal	0

800055b4 <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
800055b4:	d4 21       	pushm	r4-r7,lr
800055b6:	18 97       	mov	r7,r12
800055b8:	16 94       	mov	r4,r11
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
800055ba:	58 0b       	cp.w	r11,0
800055bc:	c0 31       	brne	800055c2 <gpio_enable_module+0xe>
800055be:	30 05       	mov	r5,0
800055c0:	c0 d8       	rjmp	800055da <gpio_enable_module+0x26>
800055c2:	30 06       	mov	r6,0
800055c4:	0c 95       	mov	r5,r6
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
800055c6:	6e 1b       	ld.w	r11,r7[0x4]
800055c8:	6e 0c       	ld.w	r12,r7[0x0]
800055ca:	f0 1f 00 06 	mcall	800055e0 <gpio_enable_module+0x2c>
800055ce:	18 45       	or	r5,r12
		gpiomap++;
800055d0:	2f 87       	sub	r7,-8
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
800055d2:	2f f6       	sub	r6,-1
800055d4:	0c 34       	cp.w	r4,r6
800055d6:	fe 9b ff f8 	brhi	800055c6 <gpio_enable_module+0x12>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
}
800055da:	0a 9c       	mov	r12,r5
800055dc:	d8 22       	popm	r4-r7,pc
800055de:	00 00       	add	r0,r0
800055e0:	80 00       	ld.sh	r0,r0[0x0]
800055e2:	55 62       	stdsp	sp[0x158],r2

800055e4 <gpio_enable_gpio_pin>:
 *            AVR32_PWM_3_PIN for PWM channel 3 can also be used to release
 *            module pins for GPIO.
 */
void gpio_enable_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
800055e4:	f8 08 16 05 	lsr	r8,r12,0x5
800055e8:	a9 68       	lsl	r8,0x8
800055ea:	e0 28 f0 00 	sub	r8,61440
	
	gpio_port->oderc = 1 << (pin & 0x1F);
800055ee:	30 19       	mov	r9,1
800055f0:	f2 0c 09 4c 	lsl	r12,r9,r12
800055f4:	f1 4c 00 48 	st.w	r8[72],r12
	gpio_port->gpers = 1 << (pin & 0x1F);
800055f8:	91 1c       	st.w	r8[0x4],r12
}
800055fa:	5e fc       	retal	r12

800055fc <gpio_set_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_set_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
800055fc:	f8 08 16 05 	lsr	r8,r12,0x5
80005600:	a9 68       	lsl	r8,0x8
80005602:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 1. */
	gpio_port->ovrs  = 1 << (pin & 0x1F);
80005606:	30 19       	mov	r9,1
80005608:	f2 0c 09 4c 	lsl	r12,r9,r12
8000560c:	f1 4c 00 54 	st.w	r8[84],r12
	/* The GPIO output driver is enabled for that pin. */ 
	gpio_port->oders = 1 << (pin & 0x1F);
80005610:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
80005614:	91 1c       	st.w	r8[0x4],r12
}
80005616:	5e fc       	retal	r12

80005618 <gpio_clr_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_clr_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80005618:	f8 08 16 05 	lsr	r8,r12,0x5
8000561c:	a9 68       	lsl	r8,0x8
8000561e:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 0. */
	gpio_port->ovrc  = 1 << (pin & 0x1F);
80005622:	30 19       	mov	r9,1
80005624:	f2 0c 09 4c 	lsl	r12,r9,r12
80005628:	f1 4c 00 58 	st.w	r8[88],r12
	/* The GPIO output driver is enabled for that pin. */
	gpio_port->oders = 1 << (pin & 0x1F);
8000562c:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
80005630:	91 1c       	st.w	r8[0x4],r12
}
80005632:	5e fc       	retal	r12

80005634 <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
80005634:	c0 08       	rjmp	80005634 <_unhandled_interrupt>
80005636:	d7 03       	nop

80005638 <INTC_register_interrupt>:
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
80005638:	f6 08 16 05 	lsr	r8,r11,0x5

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
8000563c:	49 99       	lddpc	r9,800056a0 <INTC_register_interrupt+0x68>
8000563e:	f2 08 00 39 	add	r9,r9,r8<<0x3
80005642:	f7 db c0 05 	bfextu	r11,r11,0x0,0x5
80005646:	72 19       	ld.w	r9,r9[0x4]
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
80005648:	f2 0b 09 2c 	st.w	r9[r11<<0x2],r12
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
8000564c:	58 0a       	cp.w	r10,0
8000564e:	c0 91       	brne	80005660 <INTC_register_interrupt+0x28>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80005650:	49 59       	lddpc	r9,800056a4 <INTC_register_interrupt+0x6c>
80005652:	49 6a       	lddpc	r10,800056a8 <INTC_register_interrupt+0x70>
80005654:	12 1a       	sub	r10,r9
80005656:	fe 79 08 00 	mov	r9,-63488
8000565a:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
8000565e:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT1) {
80005660:	58 1a       	cp.w	r10,1
80005662:	c0 a1       	brne	80005676 <INTC_register_interrupt+0x3e>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
80005664:	49 09       	lddpc	r9,800056a4 <INTC_register_interrupt+0x6c>
80005666:	49 2a       	lddpc	r10,800056ac <INTC_register_interrupt+0x74>
80005668:	12 1a       	sub	r10,r9
8000566a:	bf aa       	sbr	r10,0x1e
8000566c:	fe 79 08 00 	mov	r9,-63488
80005670:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80005674:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT2) {
80005676:	58 2a       	cp.w	r10,2
80005678:	c0 a1       	brne	8000568c <INTC_register_interrupt+0x54>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
8000567a:	48 b9       	lddpc	r9,800056a4 <INTC_register_interrupt+0x6c>
8000567c:	48 da       	lddpc	r10,800056b0 <INTC_register_interrupt+0x78>
8000567e:	12 1a       	sub	r10,r9
80005680:	bf ba       	sbr	r10,0x1f
80005682:	fe 79 08 00 	mov	r9,-63488
80005686:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
8000568a:	5e fc       	retal	r12
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
8000568c:	48 69       	lddpc	r9,800056a4 <INTC_register_interrupt+0x6c>
8000568e:	48 aa       	lddpc	r10,800056b4 <INTC_register_interrupt+0x7c>
80005690:	12 1a       	sub	r10,r9
80005692:	ea 1a c0 00 	orh	r10,0xc000
80005696:	fe 79 08 00 	mov	r9,-63488
8000569a:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
8000569e:	5e fc       	retal	r12
800056a0:	80 00       	ld.sh	r0,r0[0x0]
800056a2:	d9 b8       	*unknown*
800056a4:	80 00       	ld.sh	r0,r0[0x0]
800056a6:	ce 00       	breq	80005666 <INTC_register_interrupt+0x2e>
800056a8:	80 00       	ld.sh	r0,r0[0x0]
800056aa:	cf 04       	brge	8000568a <INTC_register_interrupt+0x52>
800056ac:	80 00       	ld.sh	r0,r0[0x0]
800056ae:	cf 12       	brcc	80005690 <INTC_register_interrupt+0x58>
800056b0:	80 00       	ld.sh	r0,r0[0x0]
800056b2:	cf 20       	breq	80005696 <INTC_register_interrupt+0x5e>
800056b4:	80 00       	ld.sh	r0,r0[0x0]
800056b6:	cf 2e       	rcall	8000549a <local_start_pll0+0x6a>

800056b8 <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
800056b8:	d4 21       	pushm	r4-r7,lr
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
800056ba:	49 18       	lddpc	r8,800056fc <INTC_init_interrupts+0x44>
800056bc:	e3 b8 00 01 	mtsr	0x4,r8
800056c0:	49 0e       	lddpc	lr,80005700 <INTC_init_interrupts+0x48>
800056c2:	30 07       	mov	r7,0
800056c4:	0e 94       	mov	r4,r7
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
800056c6:	49 0c       	lddpc	r12,80005704 <INTC_init_interrupts+0x4c>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
800056c8:	49 05       	lddpc	r5,80005708 <INTC_init_interrupts+0x50>
800056ca:	10 15       	sub	r5,r8
800056cc:	fe 76 08 00 	mov	r6,-63488
800056d0:	c1 08       	rjmp	800056f0 <INTC_init_interrupts+0x38>
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
800056d2:	08 98       	mov	r8,r4
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
				._int_line_handler_table[int_req]
800056d4:	7c 1b       	ld.w	r11,lr[0x4]

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
800056d6:	7c 0a       	ld.w	r10,lr[0x0]
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
800056d8:	f6 08 09 2c 	st.w	r11[r8<<0x2],r12
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
800056dc:	2f f8       	sub	r8,-1

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
800056de:	10 3a       	cp.w	r10,r8
800056e0:	fe 9b ff fc 	brhi	800056d8 <INTC_init_interrupts+0x20>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
800056e4:	ec 07 09 25 	st.w	r6[r7<<0x2],r5
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
800056e8:	2f f7       	sub	r7,-1
800056ea:	2f 8e       	sub	lr,-8
800056ec:	59 37       	cp.w	r7,19
800056ee:	c0 50       	breq	800056f8 <INTC_init_interrupts+0x40>
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
800056f0:	7c 08       	ld.w	r8,lr[0x0]
800056f2:	58 08       	cp.w	r8,0
800056f4:	ce f1       	brne	800056d2 <INTC_init_interrupts+0x1a>
800056f6:	cf 7b       	rjmp	800056e4 <INTC_init_interrupts+0x2c>
800056f8:	d8 22       	popm	r4-r7,pc
800056fa:	00 00       	add	r0,r0
800056fc:	80 00       	ld.sh	r0,r0[0x0]
800056fe:	ce 00       	breq	800056be <INTC_init_interrupts+0x6>
80005700:	80 00       	ld.sh	r0,r0[0x0]
80005702:	d9 b8       	*unknown*
80005704:	80 00       	ld.sh	r0,r0[0x0]
80005706:	56 34       	stdsp	sp[0x18c],r4
80005708:	80 00       	ld.sh	r0,r0[0x0]
8000570a:	cf 04       	brge	800056ea <INTC_init_interrupts+0x32>

8000570c <_get_interrupt_handler>:
__int_handler _get_interrupt_handler(uint32_t int_level)
{
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
8000570c:	fe 78 08 00 	mov	r8,-63488
80005710:	e0 69 00 83 	mov	r9,131
80005714:	f2 0c 01 0c 	sub	r12,r9,r12
80005718:	f0 0c 03 29 	ld.w	r9,r8[r12<<0x2]
	uint32_t int_req = AVR32_INTC.irr[int_grp];
8000571c:	f2 ca ff c0 	sub	r10,r9,-64
80005720:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
80005724:	58 08       	cp.w	r8,0
80005726:	c0 21       	brne	8000572a <_get_interrupt_handler+0x1e>
80005728:	5e fd       	retal	0
		? _int_handler_table[int_grp]._int_line_handler_table[32
8000572a:	f0 08 12 00 	clz	r8,r8
8000572e:	48 5a       	lddpc	r10,80005740 <_get_interrupt_handler+0x34>
80005730:	f4 09 00 39 	add	r9,r10,r9<<0x3
80005734:	f0 08 11 1f 	rsub	r8,r8,31
80005738:	72 19       	ld.w	r9,r9[0x4]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
8000573a:	f2 08 03 2c 	ld.w	r12,r9[r8<<0x2]
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
8000573e:	5e fc       	retal	r12
80005740:	80 00       	ld.sh	r0,r0[0x0]
80005742:	d9 b8       	*unknown*

80005744 <pm_set_osc0_mode>:
 * \param mode Oscillator 0 mode (i.e. AVR32_PM_OSCCTRL0_MODE_x).
 */
static void pm_set_osc0_mode(volatile avr32_pm_t *pm, unsigned int mode)
{
  // Read
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
80005744:	78 a8       	ld.w	r8,r12[0x28]
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.mode = mode;
80005746:	f1 db d0 03 	bfins	r8,r11,0x0,0x3
  // Write
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
8000574a:	99 a8       	st.w	r12[0x28],r8
}
8000574c:	5e fc       	retal	r12
8000574e:	d7 03       	nop

80005750 <pm_enable_osc0_crystal>:
  pm_set_osc0_mode(pm, AVR32_PM_OSCCTRL0_MODE_EXT_CLOCK);
}


void pm_enable_osc0_crystal(volatile avr32_pm_t *pm, unsigned int fosc0)
{
80005750:	d4 01       	pushm	lr
  pm_set_osc0_mode(pm, (fosc0 <  900000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G0 :
80005752:	ec 5b bb 9f 	cp.w	r11,899999
80005756:	e0 8b 00 04 	brhi	8000575e <pm_enable_osc0_crystal+0xe>
8000575a:	30 4b       	mov	r11,4
8000575c:	c1 38       	rjmp	80005782 <pm_enable_osc0_crystal+0x32>
8000575e:	e0 68 c6 bf 	mov	r8,50879
80005762:	ea 18 00 2d 	orh	r8,0x2d
80005766:	10 3b       	cp.w	r11,r8
80005768:	e0 8b 00 04 	brhi	80005770 <pm_enable_osc0_crystal+0x20>
8000576c:	30 5b       	mov	r11,5
8000576e:	c0 a8       	rjmp	80005782 <pm_enable_osc0_crystal+0x32>
80005770:	e0 68 12 00 	mov	r8,4608
80005774:	ea 18 00 7a 	orh	r8,0x7a
80005778:	10 3b       	cp.w	r11,r8
8000577a:	f9 bb 03 06 	movlo	r11,6
8000577e:	f9 bb 02 07 	movhs	r11,7
80005782:	f0 1f 00 02 	mcall	80005788 <pm_enable_osc0_crystal+0x38>
                       (fosc0 < 3000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G1 :
                       (fosc0 < 8000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G2 :
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}
80005786:	d8 02       	popm	pc
80005788:	80 00       	ld.sh	r0,r0[0x0]
8000578a:	57 44       	stdsp	sp[0x1d0],r4

8000578c <pm_enable_clk0_no_wait>:


void pm_enable_clk0_no_wait(volatile avr32_pm_t *pm, unsigned int startup)
{
  // Read register
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
8000578c:	78 a8       	ld.w	r8,r12[0x28]
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.startup = startup;
8000578e:	f1 db d1 03 	bfins	r8,r11,0x8,0x3
  // Write back
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
80005792:	99 a8       	st.w	r12[0x28],r8

  pm->mcctrl |= AVR32_PM_MCCTRL_OSC0EN_MASK;
80005794:	78 08       	ld.w	r8,r12[0x0]
80005796:	a3 a8       	sbr	r8,0x2
80005798:	99 08       	st.w	r12[0x0],r8
}
8000579a:	5e fc       	retal	r12

8000579c <pm_wait_for_clk0_ready>:


void pm_wait_for_clk0_ready(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
8000579c:	79 58       	ld.w	r8,r12[0x54]
8000579e:	e2 18 00 80 	andl	r8,0x80,COH
800057a2:	cf d0       	breq	8000579c <pm_wait_for_clk0_ready>
}
800057a4:	5e fc       	retal	r12
800057a6:	d7 03       	nop

800057a8 <pm_enable_clk0>:
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}


void pm_enable_clk0(volatile avr32_pm_t *pm, unsigned int startup)
{
800057a8:	eb cd 40 80 	pushm	r7,lr
800057ac:	18 97       	mov	r7,r12
  pm_enable_clk0_no_wait(pm, startup);
800057ae:	f0 1f 00 04 	mcall	800057bc <pm_enable_clk0+0x14>
  pm_wait_for_clk0_ready(pm);
800057b2:	0e 9c       	mov	r12,r7
800057b4:	f0 1f 00 03 	mcall	800057c0 <pm_enable_clk0+0x18>
}
800057b8:	e3 cd 80 80 	ldm	sp++,r7,pc
800057bc:	80 00       	ld.sh	r0,r0[0x0]
800057be:	57 8c       	stdsp	sp[0x1e0],r12
800057c0:	80 00       	ld.sh	r0,r0[0x0]
800057c2:	57 9c       	stdsp	sp[0x1e4],r12

800057c4 <pm_cksel>:
              unsigned int pbasel,
              unsigned int pbbdiv,
              unsigned int pbbsel,
              unsigned int hsbdiv,
              unsigned int hsbsel)
{
800057c4:	eb cd 40 d0 	pushm	r4,r6-r7,lr
800057c8:	fa c4 ff f0 	sub	r4,sp,-16
  u_avr32_pm_cksel_t u_avr32_pm_cksel = {0};
800057cc:	30 0e       	mov	lr,0

  u_avr32_pm_cksel.CKSEL.cpusel = hsbsel;
800057ce:	09 f7       	ld.ub	r7,r4[0x7]
800057d0:	ef d7 c0 03 	bfextu	r7,r7,0x0,0x3
800057d4:	fd d7 d0 03 	bfins	lr,r7,0x0,0x3
  u_avr32_pm_cksel.CKSEL.cpudiv = hsbdiv;
800057d8:	09 b4       	ld.ub	r4,r4[0x3]
800057da:	08 96       	mov	r6,r4
800057dc:	e9 d4 c0 01 	bfextu	r4,r4,0x0,0x1
800057e0:	fd d4 d0 e1 	bfins	lr,r4,0x7,0x1
  u_avr32_pm_cksel.CKSEL.hsbsel = hsbsel;
800057e4:	fd d7 d1 03 	bfins	lr,r7,0x8,0x3
  u_avr32_pm_cksel.CKSEL.hsbdiv = hsbdiv;
800057e8:	fd d4 d1 e1 	bfins	lr,r4,0xf,0x1
  u_avr32_pm_cksel.CKSEL.pbasel = pbasel;
800057ec:	fd da d2 03 	bfins	lr,r10,0x10,0x3
  u_avr32_pm_cksel.CKSEL.pbadiv = pbadiv;
800057f0:	fd db d2 e1 	bfins	lr,r11,0x17,0x1
  u_avr32_pm_cksel.CKSEL.pbbsel = pbbsel;
800057f4:	fd d8 d3 03 	bfins	lr,r8,0x18,0x3
  u_avr32_pm_cksel.CKSEL.pbbdiv = pbbdiv;
800057f8:	fd d9 d3 e1 	bfins	lr,r9,0x1f,0x1

  pm->cksel = u_avr32_pm_cksel.cksel;
800057fc:	99 1e       	st.w	r12[0x4],lr

  // Wait for ckrdy bit and then clear it
  while (!(pm->poscsr & AVR32_PM_POSCSR_CKRDY_MASK));
800057fe:	79 58       	ld.w	r8,r12[0x54]
80005800:	e2 18 00 20 	andl	r8,0x20,COH
80005804:	cf d0       	breq	800057fe <pm_cksel+0x3a>
}
80005806:	e3 cd 80 d0 	ldm	sp++,r4,r6-r7,pc

8000580a <pm_pll_setup>:
                  unsigned int pll,
                  unsigned int mul,
                  unsigned int div,
                  unsigned int osc,
                  unsigned int lockcount)
{
8000580a:	eb cd 40 80 	pushm	r7,lr
8000580e:	40 27       	lddsp	r7,sp[0x8]
  u_avr32_pm_pll_t u_avr32_pm_pll = {0};
80005810:	30 0e       	mov	lr,0

  u_avr32_pm_pll.PLL.pllosc   = osc;
80005812:	fd d8 d0 21 	bfins	lr,r8,0x1,0x1
  u_avr32_pm_pll.PLL.plldiv   = div;
80005816:	fd d9 d1 04 	bfins	lr,r9,0x8,0x4
  u_avr32_pm_pll.PLL.pllmul   = mul;
8000581a:	fd da d2 04 	bfins	lr,r10,0x10,0x4
  u_avr32_pm_pll.PLL.pllcount = lockcount;
8000581e:	fd d7 d3 06 	bfins	lr,r7,0x18,0x6

  pm->pll[pll] = u_avr32_pm_pll.pll;
80005822:	2f 8b       	sub	r11,-8
80005824:	f8 0b 09 2e 	st.w	r12[r11<<0x2],lr
}
80005828:	e3 cd 80 80 	ldm	sp++,r7,pc

8000582c <pm_pll_set_option>:
void pm_pll_set_option(volatile avr32_pm_t *pm,
                       unsigned int pll,
                       unsigned int pll_freq,
                       unsigned int pll_div2,
                       unsigned int pll_wbwdisable)
{
8000582c:	d4 01       	pushm	lr
  u_avr32_pm_pll_t u_avr32_pm_pll = {pm->pll[pll]};
8000582e:	2f 8b       	sub	r11,-8
80005830:	f8 0b 03 2e 	ld.w	lr,r12[r11<<0x2]
  u_avr32_pm_pll.PLL.pllopt = pll_freq | (pll_div2 << 1) | (pll_wbwdisable << 2);
80005834:	f5 e9 10 19 	or	r9,r10,r9<<0x1
80005838:	f3 e8 10 28 	or	r8,r9,r8<<0x2
8000583c:	fd d8 d0 43 	bfins	lr,r8,0x2,0x3
  pm->pll[pll] = u_avr32_pm_pll.pll;
80005840:	f8 0b 09 2e 	st.w	r12[r11<<0x2],lr
}
80005844:	d8 02       	popm	pc

80005846 <pm_pll_enable>:


void pm_pll_enable(volatile avr32_pm_t *pm,
                  unsigned int pll)
{
  pm->pll[pll] |= AVR32_PM_PLLEN_MASK;
80005846:	2f 8b       	sub	r11,-8
80005848:	f8 0b 03 28 	ld.w	r8,r12[r11<<0x2]
8000584c:	a1 a8       	sbr	r8,0x0
8000584e:	f8 0b 09 28 	st.w	r12[r11<<0x2],r8
}
80005852:	5e fc       	retal	r12

80005854 <pm_wait_for_pll0_locked>:
}


void pm_wait_for_pll0_locked(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_LOCK0_MASK));
80005854:	79 58       	ld.w	r8,r12[0x54]
80005856:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000585a:	cf d0       	breq	80005854 <pm_wait_for_pll0_locked>
}
8000585c:	5e fc       	retal	r12

8000585e <pm_switch_to_clock>:


void pm_switch_to_clock(volatile avr32_pm_t *pm, unsigned long clock)
{
  // Read
  u_avr32_pm_mcctrl_t u_avr32_pm_mcctrl = {pm->mcctrl};
8000585e:	78 08       	ld.w	r8,r12[0x0]
  // Modify
  u_avr32_pm_mcctrl.MCCTRL.mcsel = clock;
80005860:	f1 db d0 02 	bfins	r8,r11,0x0,0x2
  // Write back
  pm->mcctrl = u_avr32_pm_mcctrl.mcctrl;
80005864:	99 08       	st.w	r12[0x0],r8
}
80005866:	5e fc       	retal	r12

80005868 <pm_switch_to_osc0>:


void pm_switch_to_osc0(volatile avr32_pm_t *pm, unsigned int fosc0, unsigned int startup)
{
80005868:	eb cd 40 c0 	pushm	r6-r7,lr
8000586c:	18 97       	mov	r7,r12
8000586e:	14 96       	mov	r6,r10
  pm_enable_osc0_crystal(pm, fosc0);            // Enable the Osc0 in crystal mode
80005870:	f0 1f 00 06 	mcall	80005888 <pm_switch_to_osc0+0x20>
  pm_enable_clk0(pm, startup);                  // Crystal startup time - This parameter is critical and depends on the characteristics of the crystal
80005874:	0c 9b       	mov	r11,r6
80005876:	0e 9c       	mov	r12,r7
80005878:	f0 1f 00 05 	mcall	8000588c <pm_switch_to_osc0+0x24>
  pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);  // Then switch main clock to Osc0
8000587c:	30 1b       	mov	r11,1
8000587e:	0e 9c       	mov	r12,r7
80005880:	f0 1f 00 04 	mcall	80005890 <pm_switch_to_osc0+0x28>
}
80005884:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005888:	80 00       	ld.sh	r0,r0[0x0]
8000588a:	57 50       	stdsp	sp[0x1d4],r0
8000588c:	80 00       	ld.sh	r0,r0[0x0]
8000588e:	57 a8       	stdsp	sp[0x1e8],r8
80005890:	80 00       	ld.sh	r0,r0[0x0]
80005892:	58 5e       	cp.w	lr,5

80005894 <getBaudDiv>:
xSemaphoreHandle xSPIMutex;
#endif

int16_t getBaudDiv(const uint32_t baudrate, uint32_t pb_hz)
{
	uint32_t baudDiv = div_ceil(pb_hz, baudrate);
80005894:	f8 c8 00 01 	sub	r8,r12,1
80005898:	f0 0b 00 0b 	add	r11,r8,r11
8000589c:	f6 0c 0d 0a 	divu	r10,r11,r12
800058a0:	14 9c       	mov	r12,r10

	if (baudDiv <= 0 || baudDiv > 255) {
800058a2:	f4 c8 00 01 	sub	r8,r10,1
800058a6:	e0 48 00 fe 	cp.w	r8,254
800058aa:	e0 88 00 03 	brls	800058b0 <getBaudDiv+0x1c>
800058ae:	5e fe       	retal	-1
		return -1;
	}

	return baudDiv;
800058b0:	5c 8c       	casts.h	r12
}
800058b2:	5e fc       	retal	r12

800058b4 <spi_initMaster>:
spi_status_t spi_initMaster(volatile avr32_spi_t *spi,
		const spi_options_t *options)
{
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (options->modfdis > 1) {
800058b4:	f7 39 00 0d 	ld.ub	r9,r11[13]
800058b8:	30 18       	mov	r8,1
800058ba:	f0 09 18 00 	cp.b	r9,r8
800058be:	e0 88 00 04 	brls	800058c6 <spi_initMaster+0x12>
800058c2:	30 2c       	mov	r12,2
800058c4:	5e fc       	retal	r12
		return SPI_ERROR_ARGUMENT;
	}

	/* Reset. */
	spi->cr = AVR32_SPI_CR_SWRST_MASK;
800058c6:	e0 68 00 80 	mov	r8,128
800058ca:	99 08       	st.w	r12[0x0],r8

	/* Master Mode. */
	u_avr32_spi_mr.mr = spi->mr;
800058cc:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.mstr = 1;
800058ce:	30 19       	mov	r9,1
800058d0:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_mr.MR.modfdis = options->modfdis;
800058d4:	f7 39 00 0d 	ld.ub	r9,r11[13]
800058d8:	f1 d9 d0 81 	bfins	r8,r9,0x4,0x1
	u_avr32_spi_mr.MR.llb = 0;
800058dc:	30 09       	mov	r9,0
800058de:	f1 d9 d0 e1 	bfins	r8,r9,0x7,0x1
	u_avr32_spi_mr.MR.pcs = (1 << AVR32_SPI_MR_PCS_SIZE) - 1;
800058e2:	30 fa       	mov	r10,15
800058e4:	f1 da d2 04 	bfins	r8,r10,0x10,0x4
	spi->mr = u_avr32_spi_mr.mr;
800058e8:	99 18       	st.w	r12[0x4],r8
800058ea:	5e f9       	retal	r9

800058ec <spi_selectionMode>:

spi_status_t spi_selectionMode(volatile avr32_spi_t *spi,
		uint8_t variable_ps,
		uint8_t pcs_decode,
		uint8_t delay)
{
800058ec:	d4 01       	pushm	lr
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (variable_ps > 1 ||
800058ee:	30 18       	mov	r8,1
800058f0:	f0 0b 18 00 	cp.b	r11,r8
800058f4:	5f be       	srhi	lr
800058f6:	f0 0a 18 00 	cp.b	r10,r8
800058fa:	5f b8       	srhi	r8
800058fc:	fd e8 10 08 	or	r8,lr,r8
80005900:	c0 30       	breq	80005906 <spi_selectionMode+0x1a>
80005902:	30 2c       	mov	r12,2
80005904:	d8 02       	popm	pc
			pcs_decode > 1) {
		return SPI_ERROR_ARGUMENT;
	}

	u_avr32_spi_mr.mr = spi->mr;
80005906:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.ps = variable_ps;
80005908:	f1 db d0 21 	bfins	r8,r11,0x1,0x1
	u_avr32_spi_mr.MR.pcsdec = pcs_decode;
8000590c:	f1 da d0 41 	bfins	r8,r10,0x2,0x1
	u_avr32_spi_mr.MR.dlybcs = delay;
80005910:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8
	spi->mr = u_avr32_spi_mr.mr;
80005914:	99 18       	st.w	r12[0x4],r8
80005916:	d8 0a       	popm	pc,r12=0

80005918 <spi_enable>:
	return SPI_OK;
}

void spi_enable(volatile avr32_spi_t *spi)
{
	spi->cr = AVR32_SPI_CR_SPIEN_MASK;
80005918:	30 18       	mov	r8,1
8000591a:	99 08       	st.w	r12[0x0],r8
}
8000591c:	5e fc       	retal	r12

8000591e <spi_write>:
{
	return ((spi->sr & AVR32_SPI_SR_TDRE_MASK) != 0);
}

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
8000591e:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
80005922:	c0 58       	rjmp	8000592c <spi_write+0xe>
		if (!timeout--) {
80005924:	58 08       	cp.w	r8,0
80005926:	c0 21       	brne	8000592a <spi_write+0xc>
80005928:	5e ff       	retal	1
8000592a:	20 18       	sub	r8,1

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
8000592c:	78 49       	ld.w	r9,r12[0x10]
8000592e:	e2 19 00 02 	andl	r9,0x2,COH
80005932:	cf 90       	breq	80005924 <spi_write+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	spi->tdr = data << AVR32_SPI_TDR_TD_OFFSET;
80005934:	5c 7b       	castu.h	r11
80005936:	99 3b       	st.w	r12[0xc],r11
80005938:	5e fd       	retal	0

8000593a <spi_read>:
{
	return ((spi->sr & AVR32_SPI_SR_RDRF_MASK) != 0);
}

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
8000593a:	e0 68 3a 98 	mov	r8,15000
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
8000593e:	c0 58       	rjmp	80005948 <spi_read+0xe>
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) !=
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) {
		if (!timeout--) {
80005940:	58 08       	cp.w	r8,0
80005942:	c0 21       	brne	80005946 <spi_read+0xc>
80005944:	5e ff       	retal	1
80005946:	20 18       	sub	r8,1

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
80005948:	78 49       	ld.w	r9,r12[0x10]
8000594a:	e2 19 02 01 	andl	r9,0x201,COH
8000594e:	e0 49 02 01 	cp.w	r9,513
80005952:	cf 71       	brne	80005940 <spi_read+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	*data = spi->rdr >> AVR32_SPI_RDR_RD_OFFSET;
80005954:	78 28       	ld.w	r8,r12[0x8]
80005956:	b6 08       	st.h	r11[0x0],r8
80005958:	5e fd       	retal	0
8000595a:	d7 03       	nop

8000595c <spi_setupChipReg>:
}

spi_status_t spi_setupChipReg(volatile avr32_spi_t *spi,
		const spi_options_t *options,
		uint32_t pb_hz)
{
8000595c:	eb cd 40 f8 	pushm	r3-r7,lr
80005960:	18 95       	mov	r5,r12
80005962:	16 97       	mov	r7,r11
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
80005964:	f7 36 00 0c 	ld.ub	r6,r11[12]
80005968:	30 38       	mov	r8,3
8000596a:	f0 06 18 00 	cp.b	r6,r8
8000596e:	e0 8b 00 5e 	brhi	80005a2a <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
80005972:	f7 34 00 0b 	ld.ub	r4,r11[11]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
80005976:	30 18       	mov	r8,1
80005978:	f0 04 18 00 	cp.b	r4,r8
8000597c:	e0 8b 00 57 	brhi	80005a2a <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
80005980:	f7 33 00 08 	ld.ub	r3,r11[8]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
80005984:	30 78       	mov	r8,7
80005986:	f0 03 18 00 	cp.b	r3,r8
8000598a:	e0 88 00 50 	brls	80005a2a <spi_setupChipReg+0xce>
8000598e:	31 08       	mov	r8,16
80005990:	f0 03 18 00 	cp.b	r3,r8
80005994:	e0 8b 00 4b 	brhi	80005a2a <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
		return SPI_ERROR_ARGUMENT;
	}

	int baudDiv = getBaudDiv(options->baudrate, pb_hz);
80005998:	14 9b       	mov	r11,r10
8000599a:	6e 1c       	ld.w	r12,r7[0x4]
8000599c:	f0 1f 00 26 	mcall	80005a34 <spi_setupChipReg+0xd8>

	if (baudDiv < 0) {
800059a0:	c4 55       	brlt	80005a2a <spi_setupChipReg+0xce>
		return SPI_ERROR_ARGUMENT;
	}

	/* Will use CSR0 offsets; these are the same for CSR0 to CSR3. */
	u_avr32_spi_csr.csr = 0;
800059a2:	30 08       	mov	r8,0
	u_avr32_spi_csr.CSR.cpol   = options->spi_mode >> 1;
800059a4:	ec 09 16 01 	lsr	r9,r6,0x1
800059a8:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_csr.CSR.ncpha  = (options->spi_mode & 0x1) ^ 0x1;
800059ac:	ec 16 00 01 	eorl	r6,0x1
800059b0:	f1 d6 d0 21 	bfins	r8,r6,0x1,0x1
	u_avr32_spi_csr.CSR.csaat  = options->stay_act;
800059b4:	f1 d4 d0 61 	bfins	r8,r4,0x3,0x1
	u_avr32_spi_csr.CSR.bits   = options->bits - 8;
800059b8:	20 83       	sub	r3,8
800059ba:	f1 d3 d0 84 	bfins	r8,r3,0x4,0x4
	u_avr32_spi_csr.CSR.scbr   = baudDiv;
800059be:	f1 dc d1 08 	bfins	r8,r12,0x8,0x8
	u_avr32_spi_csr.CSR.dlybs  = options->spck_delay;
800059c2:	ef 39 00 09 	ld.ub	r9,r7[9]
800059c6:	f1 d9 d2 08 	bfins	r8,r9,0x10,0x8
	u_avr32_spi_csr.CSR.dlybct = options->trans_delay;
800059ca:	ef 39 00 0a 	ld.ub	r9,r7[10]
800059ce:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8

	switch (options->reg) {
800059d2:	0f 89       	ld.ub	r9,r7[0x0]
800059d4:	30 1a       	mov	r10,1
800059d6:	f4 09 18 00 	cp.b	r9,r10
800059da:	c0 d0       	breq	800059f4 <spi_setupChipReg+0x98>
800059dc:	c0 a3       	brcs	800059f0 <spi_setupChipReg+0x94>
800059de:	30 2a       	mov	r10,2
800059e0:	f4 09 18 00 	cp.b	r9,r10
800059e4:	c0 a0       	breq	800059f8 <spi_setupChipReg+0x9c>
800059e6:	30 3a       	mov	r10,3
800059e8:	f4 09 18 00 	cp.b	r9,r10
800059ec:	c1 f1       	brne	80005a2a <spi_setupChipReg+0xce>
800059ee:	c0 78       	rjmp	800059fc <spi_setupChipReg+0xa0>
	case 0:
		spi->csr0 = u_avr32_spi_csr.csr;
800059f0:	8b c8       	st.w	r5[0x30],r8
		break;
800059f2:	c0 68       	rjmp	800059fe <spi_setupChipReg+0xa2>

	case 1:
		spi->csr1 = u_avr32_spi_csr.csr;
800059f4:	8b d8       	st.w	r5[0x34],r8
		break;
800059f6:	c0 48       	rjmp	800059fe <spi_setupChipReg+0xa2>

	case 2:
		spi->csr2 = u_avr32_spi_csr.csr;
800059f8:	8b e8       	st.w	r5[0x38],r8
		break;
800059fa:	c0 28       	rjmp	800059fe <spi_setupChipReg+0xa2>

	case 3:
		spi->csr3 = u_avr32_spi_csr.csr;
800059fc:	8b f8       	st.w	r5[0x3c],r8
	default:
		return SPI_ERROR_ARGUMENT;
	}

#ifdef FREERTOS_USED
	if (!xSPIMutex) {
800059fe:	48 f8       	lddpc	r8,80005a38 <spi_setupChipReg+0xdc>
80005a00:	70 08       	ld.w	r8,r8[0x0]
80005a02:	58 08       	cp.w	r8,0
80005a04:	c1 61       	brne	80005a30 <spi_setupChipReg+0xd4>
		/* Create the SPI mutex. */
		vSemaphoreCreateBinary(xSPIMutex);
80005a06:	30 0b       	mov	r11,0
80005a08:	30 1c       	mov	r12,1
80005a0a:	f0 1f 00 0d 	mcall	80005a3c <spi_setupChipReg+0xe0>
80005a0e:	48 b8       	lddpc	r8,80005a38 <spi_setupChipReg+0xdc>
80005a10:	91 0c       	st.w	r8[0x0],r12
80005a12:	58 0c       	cp.w	r12,0
80005a14:	c0 a0       	breq	80005a28 <spi_setupChipReg+0xcc>
80005a16:	30 09       	mov	r9,0
80005a18:	12 9a       	mov	r10,r9
80005a1a:	12 9b       	mov	r11,r9
80005a1c:	f0 1f 00 09 	mcall	80005a40 <spi_setupChipReg+0xe4>
		if (!xSPIMutex) {
80005a20:	48 68       	lddpc	r8,80005a38 <spi_setupChipReg+0xdc>
80005a22:	70 08       	ld.w	r8,r8[0x0]
80005a24:	58 08       	cp.w	r8,0
80005a26:	c0 51       	brne	80005a30 <spi_setupChipReg+0xd4>
80005a28:	c0 08       	rjmp	80005a28 <spi_setupChipReg+0xcc>
80005a2a:	30 2c       	mov	r12,2
80005a2c:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80005a30:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
80005a34:	80 00       	ld.sh	r0,r0[0x0]
80005a36:	58 94       	cp.w	r4,9
80005a38:	00 00       	add	r0,r0
80005a3a:	bf e8       	*unknown*
80005a3c:	80 00       	ld.sh	r0,r0[0x0]
80005a3e:	65 80       	ld.w	r0,r2[0x60]
80005a40:	80 00       	ld.sh	r0,r0[0x0]
80005a42:	64 28       	ld.w	r8,r2[0x8]

80005a44 <spi_unselectChip>:

	return SPI_OK;
}

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
80005a44:	d4 01       	pushm	lr
80005a46:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
80005a4a:	c0 58       	rjmp	80005a54 <spi_unselectChip+0x10>
		if (!timeout--) {
80005a4c:	58 08       	cp.w	r8,0
80005a4e:	c0 21       	brne	80005a52 <spi_unselectChip+0xe>
80005a50:	da 0a       	popm	pc,r12=1
80005a52:	20 18       	sub	r8,1

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
80005a54:	78 49       	ld.w	r9,r12[0x10]
80005a56:	e2 19 02 00 	andl	r9,0x200,COH
80005a5a:	cf 90       	breq	80005a4c <spi_unselectChip+0x8>
			return SPI_ERROR_TIMEOUT;
		}
	}

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
80005a5c:	78 18       	ld.w	r8,r12[0x4]
80005a5e:	ea 18 00 0f 	orh	r8,0xf
80005a62:	99 18       	st.w	r12[0x4],r8

	/* Last transfer, so de-assert the current NPCS if CSAAT is set. */
	spi->cr = AVR32_SPI_CR_LASTXFER_MASK;
80005a64:	fc 18 01 00 	movh	r8,0x100
80005a68:	99 08       	st.w	r12[0x0],r8

#ifdef FREERTOS_USED
	xSemaphoreGive(xSPIMutex);
80005a6a:	30 09       	mov	r9,0
80005a6c:	12 9a       	mov	r10,r9
80005a6e:	12 9b       	mov	r11,r9
80005a70:	48 38       	lddpc	r8,80005a7c <spi_unselectChip+0x38>
80005a72:	70 0c       	ld.w	r12,r8[0x0]
80005a74:	f0 1f 00 03 	mcall	80005a80 <spi_unselectChip+0x3c>
80005a78:	d8 0a       	popm	pc,r12=0
80005a7a:	00 00       	add	r0,r0
80005a7c:	00 00       	add	r0,r0
80005a7e:	bf e8       	*unknown*
80005a80:	80 00       	ld.sh	r0,r0[0x0]
80005a82:	64 28       	ld.w	r8,r2[0x8]

80005a84 <spi_selectChip>:

	return SPI_OK;
}

spi_status_t spi_selectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
80005a84:	eb cd 40 f8 	pushm	r3-r7,lr
80005a88:	18 94       	mov	r4,r12
80005a8a:	16 93       	mov	r3,r11
#ifdef FREERTOS_USED
	while (pdFALSE == xSemaphoreTake(xSPIMutex, 20)) {
80005a8c:	49 a6       	lddpc	r6,80005af4 <spi_selectChip+0x70>
80005a8e:	30 07       	mov	r7,0
80005a90:	31 45       	mov	r5,20
80005a92:	0e 99       	mov	r9,r7
80005a94:	0a 9a       	mov	r10,r5
80005a96:	0e 9b       	mov	r11,r7
80005a98:	6c 0c       	ld.w	r12,r6[0x0]
80005a9a:	f0 1f 00 18 	mcall	80005af8 <spi_selectChip+0x74>
80005a9e:	cf a0       	breq	80005a92 <spi_selectChip+0xe>
	}
#endif

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
80005aa0:	68 18       	ld.w	r8,r4[0x4]
80005aa2:	ea 18 00 0f 	orh	r8,0xf
80005aa6:	89 18       	st.w	r4[0x4],r8

	if (spi->mr & AVR32_SPI_MR_PCSDEC_MASK) {
80005aa8:	68 18       	ld.w	r8,r4[0x4]
80005aaa:	e2 18 00 04 	andl	r8,0x4,COH
80005aae:	c1 10       	breq	80005ad0 <spi_selectChip+0x4c>
		/* The signal is decoded; allow up to 15 chips. */
		if (chip > 14) {
80005ab0:	30 e8       	mov	r8,14
80005ab2:	f0 03 18 00 	cp.b	r3,r8
80005ab6:	e0 8b 00 1c 	brhi	80005aee <spi_selectChip+0x6a>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~AVR32_SPI_MR_PCS_MASK |
80005aba:	68 19       	ld.w	r9,r4[0x4]
80005abc:	e6 08 15 10 	lsl	r8,r3,0x10
80005ac0:	ea 18 ff f0 	orh	r8,0xfff0
80005ac4:	e8 18 ff ff 	orl	r8,0xffff
80005ac8:	12 68       	and	r8,r9
80005aca:	89 18       	st.w	r4[0x4],r8
80005acc:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
				(chip << AVR32_SPI_MR_PCS_OFFSET);
	} else {
		if (chip > 3) {
80005ad0:	30 38       	mov	r8,3
80005ad2:	f0 03 18 00 	cp.b	r3,r8
80005ad6:	e0 8b 00 0c 	brhi	80005aee <spi_selectChip+0x6a>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~(1 << (AVR32_SPI_MR_PCS_OFFSET + chip));
80005ada:	68 19       	ld.w	r9,r4[0x4]
80005adc:	2f 03       	sub	r3,-16
80005ade:	30 18       	mov	r8,1
80005ae0:	f0 03 09 48 	lsl	r8,r8,r3
80005ae4:	5c d8       	com	r8
80005ae6:	12 68       	and	r8,r9
80005ae8:	89 18       	st.w	r4[0x4],r8
80005aea:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
80005aee:	30 2c       	mov	r12,2
	}

	return SPI_OK;
}
80005af0:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80005af4:	00 00       	add	r0,r0
80005af6:	bf e8       	*unknown*
80005af8:	80 00       	ld.sh	r0,r0[0x0]
80005afa:	62 1c       	ld.w	r12,r1[0x4]

80005afc <usart_set_async_baudrate>:
 *
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
80005afc:	d4 01       	pushm	lr
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
80005afe:	f6 08 15 04 	lsl	r8,r11,0x4
80005b02:	14 38       	cp.w	r8,r10
80005b04:	f9 b8 08 10 	movls	r8,16
80005b08:	f9 b8 0b 08 	movhi	r8,8
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
80005b0c:	f0 0b 02 4b 	mul	r11,r8,r11
80005b10:	f6 09 16 01 	lsr	r9,r11,0x1
80005b14:	f2 0a 00 3a 	add	r10,r9,r10<<0x3
80005b18:	f4 0b 0d 0a 	divu	r10,r10,r11
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
80005b1c:	f4 09 16 03 	lsr	r9,r10,0x3
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
80005b20:	f2 cb 00 01 	sub	r11,r9,1
80005b24:	e0 4b ff fe 	cp.w	r11,65534
80005b28:	e0 88 00 03 	brls	80005b2e <usart_set_async_baudrate+0x32>
80005b2c:	da 0a       	popm	pc,r12=1
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
80005b2e:	78 1b       	ld.w	r11,r12[0x4]
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
80005b30:	e8 6e 00 00 	mov	lr,524288
80005b34:	59 08       	cp.w	r8,16
80005b36:	fc 08 17 10 	movne	r8,lr
80005b3a:	f9 b8 00 00 	moveq	r8,0
80005b3e:	e4 1b ff f7 	andh	r11,0xfff7
80005b42:	e0 1b fe cf 	andl	r11,0xfecf
80005b46:	16 48       	or	r8,r11
80005b48:	99 18       	st.w	r12[0x4],r8
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
80005b4a:	f5 da c0 03 	bfextu	r10,r10,0x0,0x3
80005b4e:	f3 ea 11 09 	or	r9,r9,r10<<0x10
80005b52:	99 89       	st.w	r12[0x20],r9
80005b54:	d8 0a       	popm	pc,r12=0

80005b56 <usart_write_char>:
 *
 * \return \c 1 if the USART Transmit Holding Register is free, otherwise \c 0.
 */
__always_inline static int usart_tx_ready(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_TXRDY_MASK) != 0;
80005b56:	78 58       	ld.w	r8,r12[0x14]
}


int usart_write_char(volatile avr32_usart_t *usart, int c)
{
  if (usart_tx_ready(usart))
80005b58:	e2 18 00 02 	andl	r8,0x2,COH
80005b5c:	c0 31       	brne	80005b62 <usart_write_char+0xc>
80005b5e:	30 2c       	mov	r12,2
80005b60:	5e fc       	retal	r12
  {
    usart->thr = (c << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
80005b62:	f7 db c0 09 	bfextu	r11,r11,0x0,0x9
80005b66:	99 7b       	st.w	r12[0x1c],r11
80005b68:	5e fd       	retal	0
80005b6a:	d7 03       	nop

80005b6c <usart_putchar>:
    return USART_TX_BUSY;
}


int usart_putchar(volatile avr32_usart_t *usart, int c)
{
80005b6c:	eb cd 40 e0 	pushm	r5-r7,lr
80005b70:	18 96       	mov	r6,r12
80005b72:	16 95       	mov	r5,r11
80005b74:	e0 67 27 0f 	mov	r7,9999
80005b78:	c0 68       	rjmp	80005b84 <usart_putchar+0x18>
  int timeout = USART_DEFAULT_TIMEOUT;

  do
  {
    if (!timeout--) return USART_FAILURE;
80005b7a:	58 07       	cp.w	r7,0
80005b7c:	c0 31       	brne	80005b82 <usart_putchar+0x16>
80005b7e:	e3 cf c0 e0 	ldm	sp++,r5-r7,pc,r12=-1
80005b82:	20 17       	sub	r7,1
  } while (usart_write_char(usart, c) != USART_SUCCESS);
80005b84:	0a 9b       	mov	r11,r5
80005b86:	0c 9c       	mov	r12,r6
80005b88:	f0 1f 00 03 	mcall	80005b94 <usart_putchar+0x28>
80005b8c:	cf 71       	brne	80005b7a <usart_putchar+0xe>

  return USART_SUCCESS;
}
80005b8e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80005b92:	00 00       	add	r0,r0
80005b94:	80 00       	ld.sh	r0,r0[0x0]
80005b96:	5b 56       	cp.w	r6,-11

80005b98 <usart_read_char>:

int usart_read_char(volatile avr32_usart_t *usart, int *c)
{
  // Check for errors: frame, parity and overrun. In RS485 mode, a parity error
  // would mean that an address char has been received.
  if (usart->csr & (AVR32_USART_CSR_OVRE_MASK |
80005b98:	78 58       	ld.w	r8,r12[0x14]
80005b9a:	e2 18 00 e0 	andl	r8,0xe0,COH
80005b9e:	c0 30       	breq	80005ba4 <usart_read_char+0xc>
80005ba0:	30 4c       	mov	r12,4
80005ba2:	5e fc       	retal	r12
 *
 * \return \c 1 if the USART Receive Holding Register is full, otherwise \c 0.
 */
__always_inline static int usart_test_hit(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_RXRDY_MASK) != 0;
80005ba4:	78 58       	ld.w	r8,r12[0x14]
                    AVR32_USART_CSR_FRAME_MASK |
                    AVR32_USART_CSR_PARE_MASK))
    return USART_RX_ERROR;

  // No error; if we really did receive a char, read it and return SUCCESS.
  if (usart_test_hit(usart))
80005ba6:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80005baa:	c0 31       	brne	80005bb0 <usart_read_char+0x18>
80005bac:	30 3c       	mov	r12,3
80005bae:	5e fc       	retal	r12
  {
    *c = (usart->rhr & AVR32_USART_RHR_RXCHR_MASK) >> AVR32_USART_RHR_RXCHR_OFFSET;
80005bb0:	78 68       	ld.w	r8,r12[0x18]
80005bb2:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
80005bb6:	97 08       	st.w	r11[0x0],r8
80005bb8:	5e fd       	retal	0
80005bba:	d7 03       	nop

80005bbc <usart_getchar>:
    return USART_RX_EMPTY;
}


int usart_getchar(volatile avr32_usart_t *usart)
{
80005bbc:	eb cd 40 c0 	pushm	r6-r7,lr
80005bc0:	20 1d       	sub	sp,4
80005bc2:	18 96       	mov	r6,r12
  int c, ret;

  while ((ret = usart_read_char(usart, &c)) == USART_RX_EMPTY);
80005bc4:	1a 97       	mov	r7,sp
80005bc6:	1a 9b       	mov	r11,sp
80005bc8:	0c 9c       	mov	r12,r6
80005bca:	f0 1f 00 07 	mcall	80005be4 <usart_getchar+0x28>
80005bce:	58 3c       	cp.w	r12,3
80005bd0:	cf b0       	breq	80005bc6 <usart_getchar+0xa>

  if (ret == USART_RX_ERROR)
80005bd2:	58 4c       	cp.w	r12,4
80005bd4:	f9 bc 00 ff 	moveq	r12,-1
    return USART_FAILURE;

  return c;
80005bd8:	fb fc 10 00 	ld.wne	r12,sp[0x0]
}
80005bdc:	2f fd       	sub	sp,-4
80005bde:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005be2:	00 00       	add	r0,r0
80005be4:	80 00       	ld.sh	r0,r0[0x0]
80005be6:	5b 98       	cp.w	r8,-7

80005be8 <usart_write_line>:


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
80005be8:	eb cd 40 c0 	pushm	r6-r7,lr
80005bec:	18 96       	mov	r6,r12
80005bee:	16 97       	mov	r7,r11
  while (*string != '\0')
80005bf0:	17 8b       	ld.ub	r11,r11[0x0]
80005bf2:	58 0b       	cp.w	r11,0
80005bf4:	c0 80       	breq	80005c04 <usart_write_line+0x1c>
    usart_putchar(usart, *string++);
80005bf6:	2f f7       	sub	r7,-1
80005bf8:	0c 9c       	mov	r12,r6
80005bfa:	f0 1f 00 04 	mcall	80005c08 <usart_write_line+0x20>
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
80005bfe:	0f 8b       	ld.ub	r11,r7[0x0]
80005c00:	58 0b       	cp.w	r11,0
80005c02:	cf a1       	brne	80005bf6 <usart_write_line+0xe>
80005c04:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005c08:	80 00       	ld.sh	r0,r0[0x0]
80005c0a:	5b 6c       	cp.w	r12,-10

80005c0c <usart_reset>:
//! @{


void usart_reset(volatile avr32_usart_t *usart)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
80005c0c:	e1 b8 00 00 	mfsr	r8,0x0

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
80005c10:	e6 18 00 01 	andh	r8,0x1,COH
80005c14:	c0 71       	brne	80005c22 <usart_reset+0x16>
80005c16:	d3 03       	ssrf	0x10
  usart->idr = 0xFFFFFFFF;
80005c18:	3f f8       	mov	r8,-1
80005c1a:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80005c1c:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();
80005c1e:	d5 03       	csrf	0x10
80005c20:	c0 48       	rjmp	80005c28 <usart_reset+0x1c>
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
  usart->idr = 0xFFFFFFFF;
80005c22:	3f f8       	mov	r8,-1
80005c24:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80005c26:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();

  // Reset mode and other registers that could cause unpredictable behavior after reset.
  usart->mr = 0;
80005c28:	30 08       	mov	r8,0
80005c2a:	99 18       	st.w	r12[0x4],r8
  usart->rtor = 0;
80005c2c:	99 98       	st.w	r12[0x24],r8
  usart->ttgr = 0;
80005c2e:	99 a8       	st.w	r12[0x28],r8

  // Shutdown TX and RX (will be re-enabled when setup has successfully completed),
  // reset status bits and turn off DTR and RTS.
  usart->cr = AVR32_USART_CR_RSTRX_MASK   |
80005c30:	ea 68 61 0c 	mov	r8,680204
80005c34:	99 08       	st.w	r12[0x0],r8
#ifndef AVR32_USART_440_H_INCLUDED
// Note: Modem Signal Management DTR-DSR-DCD-RI are not included in USART rev.440.
              AVR32_USART_CR_DTRDIS_MASK  |
#endif
              AVR32_USART_CR_RTSDIS_MASK;
}
80005c36:	5e fc       	retal	r12

80005c38 <usart_init_rs232>:


int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
{
80005c38:	eb cd 40 e0 	pushm	r5-r7,lr
80005c3c:	18 96       	mov	r6,r12
80005c3e:	16 97       	mov	r7,r11
80005c40:	14 95       	mov	r5,r10
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);
80005c42:	f0 1f 00 2f 	mcall	80005cfc <usart_init_rs232+0xc4>

  // Check input values.
  if (!opt || // Null pointer.
80005c46:	58 07       	cp.w	r7,0
80005c48:	c5 80       	breq	80005cf8 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
80005c4a:	0f c8       	ld.ub	r8,r7[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80005c4c:	30 49       	mov	r9,4
80005c4e:	f2 08 18 00 	cp.b	r8,r9
80005c52:	e0 88 00 53 	brls	80005cf8 <usart_init_rs232+0xc0>
80005c56:	30 99       	mov	r9,9
80005c58:	f2 08 18 00 	cp.b	r8,r9
80005c5c:	e0 8b 00 4e 	brhi	80005cf8 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
80005c60:	0f d9       	ld.ub	r9,r7[0x5]
80005c62:	30 78       	mov	r8,7
80005c64:	f0 09 18 00 	cp.b	r9,r8
80005c68:	e0 8b 00 48 	brhi	80005cf8 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
80005c6c:	8e 39       	ld.sh	r9,r7[0x6]
80005c6e:	e0 68 01 01 	mov	r8,257
80005c72:	f0 09 19 00 	cp.h	r9,r8
80005c76:	e0 8b 00 41 	brhi	80005cf8 <usart_init_rs232+0xc0>
      opt->channelmode > 3 ||
80005c7a:	ef 39 00 08 	ld.ub	r9,r7[8]
80005c7e:	30 38       	mov	r8,3
80005c80:	f0 09 18 00 	cp.b	r9,r8
80005c84:	e0 8b 00 3a 	brhi	80005cf8 <usart_init_rs232+0xc0>
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
80005c88:	0a 9a       	mov	r10,r5
80005c8a:	6e 0b       	ld.w	r11,r7[0x0]
80005c8c:	0c 9c       	mov	r12,r6
80005c8e:	f0 1f 00 1d 	mcall	80005d00 <usart_init_rs232+0xc8>
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80005c92:	58 1c       	cp.w	r12,1
80005c94:	c3 20       	breq	80005cf8 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
    return USART_INVALID_INPUT;

  if (opt->charlength == 9)
80005c96:	0f c8       	ld.ub	r8,r7[0x4]
80005c98:	30 99       	mov	r9,9
80005c9a:	f2 08 18 00 	cp.b	r8,r9
80005c9e:	c0 51       	brne	80005ca8 <usart_init_rs232+0x70>
  {
    // Character length set to 9 bits. MODE9 dominates CHRL.
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
80005ca0:	6c 18       	ld.w	r8,r6[0x4]
80005ca2:	b1 b8       	sbr	r8,0x11
80005ca4:	8d 18       	st.w	r6[0x4],r8
80005ca6:	c0 68       	rjmp	80005cb2 <usart_init_rs232+0x7a>
  }
  else
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
80005ca8:	6c 19       	ld.w	r9,r6[0x4]
80005caa:	20 58       	sub	r8,5
80005cac:	f3 e8 10 68 	or	r8,r9,r8<<0x6
80005cb0:	8d 18       	st.w	r6[0x4],r8
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
80005cb2:	6c 19       	ld.w	r9,r6[0x4]
80005cb4:	ef 3a 00 08 	ld.ub	r10,r7[8]
80005cb8:	0f d8       	ld.ub	r8,r7[0x5]
80005cba:	a9 78       	lsl	r8,0x9
80005cbc:	f1 ea 10 e8 	or	r8,r8,r10<<0xe
80005cc0:	12 48       	or	r8,r9
80005cc2:	8d 18       	st.w	r6[0x4],r8
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;

  if (opt->stopbits > USART_2_STOPBITS)
80005cc4:	8e 38       	ld.sh	r8,r7[0x6]
80005cc6:	30 29       	mov	r9,2
80005cc8:	f2 08 19 00 	cp.h	r8,r9
80005ccc:	e0 88 00 09 	brls	80005cde <usart_init_rs232+0xa6>
  {
    // Set two stop bits
    usart->mr |= AVR32_USART_MR_NBSTOP_2 << AVR32_USART_MR_NBSTOP_OFFSET;
80005cd0:	6c 18       	ld.w	r8,r6[0x4]
80005cd2:	ad b8       	sbr	r8,0xd
80005cd4:	8d 18       	st.w	r6[0x4],r8
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
80005cd6:	8e b8       	ld.uh	r8,r7[0x6]
80005cd8:	20 28       	sub	r8,2
80005cda:	8d a8       	st.w	r6[0x28],r8
80005cdc:	c0 68       	rjmp	80005ce8 <usart_init_rs232+0xb0>
  }
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;
80005cde:	6c 19       	ld.w	r9,r6[0x4]
80005ce0:	5c 78       	castu.h	r8
80005ce2:	f3 e8 10 c8 	or	r8,r9,r8<<0xc
80005ce6:	8d 18       	st.w	r6[0x4],r8

  // Set normal mode.
  usart->mr = (usart->mr & ~AVR32_USART_MR_MODE_MASK) |
80005ce8:	6c 18       	ld.w	r8,r6[0x4]
80005cea:	e0 18 ff f0 	andl	r8,0xfff0
80005cee:	8d 18       	st.w	r6[0x4],r8
              AVR32_USART_MR_MODE_NORMAL << AVR32_USART_MR_MODE_OFFSET;

  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
80005cf0:	35 08       	mov	r8,80
80005cf2:	8d 08       	st.w	r6[0x0],r8
80005cf4:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
80005cf8:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
80005cfc:	80 00       	ld.sh	r0,r0[0x0]
80005cfe:	5c 0c       	acr	r12
80005d00:	80 00       	ld.sh	r0,r0[0x0]
80005d02:	5a fc       	cp.w	r12,-17

80005d04 <_stext>:

  .global _stext
  .type _stext, @function
_stext:
  // Set initial stack pointer.
  lda.w   sp, _estack
80005d04:	e0 7d 80 00 	mov	sp,98304

  // Set up EVBA so interrupts can be enabled.
  lda.w   r0, _evba
  mtsr    AVR32_EVBA, r0
80005d08:	fe c0 8f 08 	sub	r0,pc,-28920

  // Enable the exception processing.
  csrf    AVR32_SR_EM_OFFSET
80005d0c:	e3 b0 00 01 	mtsr	0x4,r0

  // Load initialized data having a global lifetime from the data LMA.
  lda.w   r0, _data
  lda.w   r1, _edata
80005d10:	d5 53       	csrf	0x15
  cp      r0, r1
80005d12:	30 40       	mov	r0,4
  brhs    idata_load_loop_end
80005d14:	e0 61 0a 40 	mov	r1,2624
  lda.w   r2, _data_lma
idata_load_loop:
  ld.d    r4, r2++
80005d18:	02 30       	cp.w	r0,r1
  st.d    r0++, r4
80005d1a:	c0 62       	brcc	80005d26 <idata_load_loop_end>
  cp      r0, r1
80005d1c:	48 92       	lddpc	r2,80005d40 <udata_clear_loop_end+0x4>

80005d1e <idata_load_loop>:
  brlo    idata_load_loop
80005d1e:	a5 05       	ld.d	r4,r2++
idata_load_loop_end:

  // Clear uninitialized data having a global lifetime in the blank static storage section.
  lda.w   r0, __bss_start
80005d20:	a1 24       	st.d	r0++,r4
  lda.w   r1, _end
80005d22:	02 30       	cp.w	r0,r1
  cp      r0, r1
80005d24:	cf d3       	brcs	80005d1e <idata_load_loop>

80005d26 <idata_load_loop_end>:
  brhs    udata_clear_loop_end
80005d26:	e0 60 0a 40 	mov	r0,2624
  mov     r2, 0
  mov     r3, 0
80005d2a:	e0 61 bf f8 	mov	r1,49144
udata_clear_loop:
  st.d    r0++, r2
  cp      r0, r1
80005d2e:	02 30       	cp.w	r0,r1
  brlo    udata_clear_loop
80005d30:	c0 62       	brcc	80005d3c <udata_clear_loop_end>
  // Safety: Set the default "return" @ to the exit routine address.
  lda.w   lr, exit
#endif

  // Start the show.
  lda.w   pc, main
80005d32:	30 02       	mov	r2,0
80005d34:	30 03       	mov	r3,0

80005d36 <udata_clear_loop>:
80005d36:	a1 22       	st.d	r0++,r2
80005d38:	02 30       	cp.w	r0,r1
80005d3a:	cf e3       	brcs	80005d36 <udata_clear_loop>

80005d3c <udata_clear_loop_end>:
80005d3c:	fe cf e9 28 	sub	pc,pc,-5848
80005d40:	80 00       	ld.sh	r0,r0[0x0]
80005d42:	e2 e8 f8 c8 	ld.d	r8,r1[-1848]

80005d44 <vListInitialise>:
void vListInitialise( xList *pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
80005d44:	f8 c8 ff f8 	sub	r8,r12,-8
80005d48:	99 18       	st.w	r12[0x4],r8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
80005d4a:	3f f9       	mov	r9,-1
80005d4c:	99 29       	st.w	r12[0x8],r9

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
80005d4e:	99 38       	st.w	r12[0xc],r8
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
80005d50:	99 48       	st.w	r12[0x10],r8

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
80005d52:	30 08       	mov	r8,0
80005d54:	99 08       	st.w	r12[0x0],r8
}
80005d56:	5e fc       	retal	r12

80005d58 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
80005d58:	30 08       	mov	r8,0
80005d5a:	99 48       	st.w	r12[0x10],r8
}
80005d5c:	5e fc       	retal	r12

80005d5e <vListInsertEnd>:

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
80005d5e:	78 18       	ld.w	r8,r12[0x4]

	pxNewListItem->pxNext = pxIndex->pxNext;
80005d60:	70 19       	ld.w	r9,r8[0x4]
80005d62:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxPrevious = pxList->pxIndex;
80005d64:	78 19       	ld.w	r9,r12[0x4]
80005d66:	97 29       	st.w	r11[0x8],r9
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80005d68:	70 19       	ld.w	r9,r8[0x4]
80005d6a:	93 2b       	st.w	r9[0x8],r11
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
80005d6c:	91 1b       	st.w	r8[0x4],r11
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
80005d6e:	99 1b       	st.w	r12[0x4],r11

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80005d70:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80005d72:	78 08       	ld.w	r8,r12[0x0]
80005d74:	2f f8       	sub	r8,-1
80005d76:	99 08       	st.w	r12[0x0],r8
}
80005d78:	5e fc       	retal	r12

80005d7a <vListInsert>:
{
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
80005d7a:	76 0a       	ld.w	r10,r11[0x0]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
80005d7c:	5b fa       	cp.w	r10,-1
80005d7e:	c0 31       	brne	80005d84 <vListInsert+0xa>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
80005d80:	78 48       	ld.w	r8,r12[0x10]
80005d82:	c0 c8       	rjmp	80005d9a <vListInsert+0x20>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
80005d84:	f8 c8 ff f8 	sub	r8,r12,-8
80005d88:	70 19       	ld.w	r9,r8[0x4]
80005d8a:	72 09       	ld.w	r9,r9[0x0]
80005d8c:	12 3a       	cp.w	r10,r9
80005d8e:	c0 63       	brcs	80005d9a <vListInsert+0x20>
80005d90:	70 18       	ld.w	r8,r8[0x4]
80005d92:	70 19       	ld.w	r9,r8[0x4]
80005d94:	72 09       	ld.w	r9,r9[0x0]
80005d96:	12 3a       	cp.w	r10,r9
80005d98:	cf c2       	brcc	80005d90 <vListInsert+0x16>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
80005d9a:	70 19       	ld.w	r9,r8[0x4]
80005d9c:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80005d9e:	93 2b       	st.w	r9[0x8],r11
	pxNewListItem->pxPrevious = pxIterator;
80005da0:	97 28       	st.w	r11[0x8],r8
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
80005da2:	91 1b       	st.w	r8[0x4],r11

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80005da4:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80005da6:	78 08       	ld.w	r8,r12[0x0]
80005da8:	2f f8       	sub	r8,-1
80005daa:	99 08       	st.w	r12[0x0],r8
}
80005dac:	5e fc       	retal	r12

80005dae <vListRemove>:

void vListRemove( xListItem *pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
80005dae:	78 18       	ld.w	r8,r12[0x4]
80005db0:	78 29       	ld.w	r9,r12[0x8]
80005db2:	91 29       	st.w	r8[0x8],r9
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
80005db4:	78 28       	ld.w	r8,r12[0x8]
80005db6:	78 19       	ld.w	r9,r12[0x4]
80005db8:	91 19       	st.w	r8[0x4],r9

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
80005dba:	78 48       	ld.w	r8,r12[0x10]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
80005dbc:	70 19       	ld.w	r9,r8[0x4]
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
80005dbe:	18 39       	cp.w	r9,r12
80005dc0:	f9 f9 00 02 	ld.weq	r9,r12[0x8]
80005dc4:	f1 f9 0a 01 	st.weq	r8[0x4],r9
	}

	pxItemToRemove->pvContainer = NULL;
80005dc8:	30 09       	mov	r9,0
80005dca:	99 49       	st.w	r12[0x10],r9
	( pxList->uxNumberOfItems )--;
80005dcc:	70 09       	ld.w	r9,r8[0x0]
80005dce:	20 19       	sub	r9,1
80005dd0:	91 09       	st.w	r8[0x0],r9
}
80005dd2:	5e fc       	retal	r12

80005dd4 <pxPortInitialiseStack>:
	/* Setup the initial stack of the task.  The stack is set exactly as
	expected by the portRESTORE_CONTEXT() macro. */

	/* When the task starts, it will expect to find the function parameter in R12. */
	pxTopOfStack--;
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x08080808;					/* R8 */
80005dd4:	e0 68 08 08 	mov	r8,2056
80005dd8:	ea 18 08 08 	orh	r8,0x808
80005ddc:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x09090909;					/* R9 */
80005dde:	e0 68 09 09 	mov	r8,2313
80005de2:	ea 18 09 09 	orh	r8,0x909
80005de6:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0A0A0A0A;					/* R10 */
80005de8:	e0 68 0a 0a 	mov	r8,2570
80005dec:	ea 18 0a 0a 	orh	r8,0xa0a
80005df0:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0B0B0B0B;					/* R11 */
80005df2:	e0 68 0b 0b 	mov	r8,2827
80005df6:	ea 18 0b 0b 	orh	r8,0xb0b
80005dfa:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pvParameters;					/* R12 */
80005dfc:	18 da       	st.w	--r12,r10
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xDEADBEEF;					/* R14/LR */
80005dfe:	e0 68 be ef 	mov	r8,48879
80005e02:	ea 18 de ad 	orh	r8,0xdead
80005e06:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pxCode + portINSTRUCTION_SIZE; /* R15/PC */
80005e08:	18 db       	st.w	--r12,r11
	*pxTopOfStack-- = ( portSTACK_TYPE ) portINITIAL_SR;				/* SR */
80005e0a:	fc 18 00 40 	movh	r8,0x40
80005e0e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xFF0000FF;					/* R0 */
80005e10:	e0 68 00 ff 	mov	r8,255
80005e14:	ea 18 ff 00 	orh	r8,0xff00
80005e18:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x01010101;					/* R1 */
80005e1a:	e0 68 01 01 	mov	r8,257
80005e1e:	ea 18 01 01 	orh	r8,0x101
80005e22:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x02020202;					/* R2 */
80005e24:	e0 68 02 02 	mov	r8,514
80005e28:	ea 18 02 02 	orh	r8,0x202
80005e2c:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x03030303;					/* R3 */
80005e2e:	e0 68 03 03 	mov	r8,771
80005e32:	ea 18 03 03 	orh	r8,0x303
80005e36:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x04040404;					/* R4 */
80005e38:	e0 68 04 04 	mov	r8,1028
80005e3c:	ea 18 04 04 	orh	r8,0x404
80005e40:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x05050505;					/* R5 */
80005e42:	e0 68 05 05 	mov	r8,1285
80005e46:	ea 18 05 05 	orh	r8,0x505
80005e4a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x06060606;					/* R6 */
80005e4c:	e0 68 06 06 	mov	r8,1542
80005e50:	ea 18 06 06 	orh	r8,0x606
80005e54:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x07070707;					/* R7 */
80005e56:	e0 68 07 07 	mov	r8,1799
80005e5a:	ea 18 07 07 	orh	r8,0x707
80005e5e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack = ( portSTACK_TYPE ) portNO_CRITICAL_NESTING;			/* ulCriticalNesting */
80005e60:	30 08       	mov	r8,0
80005e62:	18 d8       	st.w	--r12,r8

	return pxTopOfStack;
}
80005e64:	5e fc       	retal	r12
80005e66:	d7 03       	nop

80005e68 <vPortEnterCritical>:
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
__attribute__((__noinline__)) void vPortEnterCritical( void )
{
	/* Disable interrupts */
	portDISABLE_INTERRUPTS();
80005e68:	d3 03       	ssrf	0x10

	/* Now interrupts are disabled ulCriticalNesting can be accessed
	 directly.  Increment ulCriticalNesting to keep a count of how many times
	 portENTER_CRITICAL() has been called. */
	ulCriticalNesting++;
80005e6a:	48 38       	lddpc	r8,80005e74 <vPortEnterCritical+0xc>
80005e6c:	70 09       	ld.w	r9,r8[0x0]
80005e6e:	2f f9       	sub	r9,-1
80005e70:	91 09       	st.w	r8[0x0],r9
}
80005e72:	5e fc       	retal	r12
80005e74:	00 00       	add	r0,r0
80005e76:	05 34       	ld.ub	r4,r2++

80005e78 <xPortStartScheduler>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
80005e78:	d4 01       	pushm	lr
	};

#endif

	/* Disable all interrupt/exception. */
	portDISABLE_INTERRUPTS();
80005e7a:	d3 03       	ssrf	0x10
		/* Start the timer/counter. */
		tc_start(tc, configTICK_TC_CHANNEL);
	}
	#else
	{
		INTC_register_interrupt(&vTick, AVR32_CORE_COMPARE_IRQ, AVR32_INTC_INT0);
80005e7c:	30 0a       	mov	r10,0
80005e7e:	14 9b       	mov	r11,r10
80005e80:	49 2c       	lddpc	r12,80005ec8 <xPortStartScheduler+0x50>
80005e82:	f0 1f 00 13 	mcall	80005ecc <xPortStartScheduler+0x54>
/* Schedule the COUNT&COMPARE match interrupt in (configCPU_CLOCK_HZ/configTICK_RATE_HZ)
clock cycles from now. */
#if( configTICK_USE_TC==0 )
	static void prvScheduleFirstTick(void)
	{
		Set_system_register(AVR32_COMPARE, configCPU_CLOCK_HZ/configTICK_RATE_HZ);//cause!!!
80005e86:	e0 68 5d c0 	mov	r8,24000
80005e8a:	e3 b8 00 43 	mtsr	0x10c,r8
		Set_system_register(AVR32_COUNT, 0);
80005e8e:	30 08       	mov	r8,0
80005e90:	e3 b8 00 42 	mtsr	0x108,r8
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();

	/* Start the first task. */
	portRESTORE_CONTEXT();
80005e94:	e0 68 0c f0 	mov	r8,3312
80005e98:	ea 18 00 00 	orh	r8,0x0
80005e9c:	70 00       	ld.w	r0,r8[0x0]
80005e9e:	60 0d       	ld.w	sp,r0[0x0]
80005ea0:	1b 00       	ld.w	r0,sp++
80005ea2:	e0 68 05 34 	mov	r8,1332
80005ea6:	ea 18 00 00 	orh	r8,0x0
80005eaa:	91 00       	st.w	r8[0x0],r0
80005eac:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005eb0:	2f ed       	sub	sp,-8
80005eb2:	e3 cd 5f 00 	ldm	sp++,r8-r12,lr
80005eb6:	fa f0 ff e0 	ld.w	r0,sp[-32]
80005eba:	e3 b0 00 00 	mtsr	0x0,r0
80005ebe:	fa f0 ff dc 	ld.w	r0,sp[-36]
80005ec2:	fa ff ff e4 	ld.w	pc,sp[-28]

	/* Should not get here! */
	return 0;
}
80005ec6:	d8 0a       	popm	pc,r12=0
80005ec8:	80 00       	ld.sh	r0,r0[0x0]
80005eca:	5f 94       	srgt	r4
80005ecc:	80 00       	ld.sh	r0,r0[0x0]
80005ece:	56 38       	stdsp	sp[0x18c],r8

80005ed0 <SCALLYield>:
/*-----------------------------------------------------------*/
__attribute__((__naked__)) void SCALLYield( void );
__attribute__((__naked__)) void SCALLYield( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_SCALL();
80005ed0:	20 6d       	sub	sp,24
80005ed2:	eb cd 00 ff 	pushm	r0-r7
80005ed6:	fa c7 ff c0 	sub	r7,sp,-64
80005eda:	ee f0 ff f8 	ld.w	r0,r7[-8]
80005ede:	ef 40 ff e0 	st.w	r7[-32],r0
80005ee2:	ee f0 ff fc 	ld.w	r0,r7[-4]
80005ee6:	ef 40 ff e4 	st.w	r7[-28],r0
80005eea:	eb c7 5f 00 	stm	--r7,r8-r12,lr
80005eee:	e0 68 05 34 	mov	r8,1332
80005ef2:	ea 18 00 00 	orh	r8,0x0
80005ef6:	70 00       	ld.w	r0,r8[0x0]
80005ef8:	1a d0       	st.w	--sp,r0
80005efa:	f0 1f 00 1a 	mcall	80005f60 <LABEL_RET_SCALL_263+0x14>
80005efe:	e0 68 0c f0 	mov	r8,3312
80005f02:	ea 18 00 00 	orh	r8,0x0
80005f06:	70 00       	ld.w	r0,r8[0x0]
80005f08:	81 0d       	st.w	r0[0x0],sp
	vTaskSwitchContext();
80005f0a:	f0 1f 00 17 	mcall	80005f64 <LABEL_RET_SCALL_263+0x18>
	portRESTORE_CONTEXT_SCALL();
80005f0e:	e0 68 0c f0 	mov	r8,3312
80005f12:	ea 18 00 00 	orh	r8,0x0
80005f16:	70 00       	ld.w	r0,r8[0x0]
80005f18:	60 0d       	ld.w	sp,r0[0x0]
80005f1a:	1b 00       	ld.w	r0,sp++
80005f1c:	e0 68 05 34 	mov	r8,1332
80005f20:	ea 18 00 00 	orh	r8,0x0
80005f24:	91 00       	st.w	r8[0x0],r0
80005f26:	fa c7 ff d8 	sub	r7,sp,-40
80005f2a:	e3 c7 5f 00 	ldm	r7++,r8-r12,lr
80005f2e:	ee f0 ff e0 	ld.w	r0,r7[-32]
80005f32:	e0 61 05 34 	mov	r1,1332
80005f36:	ea 11 00 00 	orh	r1,0x0
80005f3a:	62 02       	ld.w	r2,r1[0x0]
80005f3c:	58 02       	cp.w	r2,0
80005f3e:	c0 70       	breq	80005f4c <LABEL_RET_SCALL_263>
80005f40:	e4 c2 00 01 	sub	r2,r2,1
80005f44:	83 02       	st.w	r1[0x0],r2
80005f46:	58 02       	cp.w	r2,0
80005f48:	c0 21       	brne	80005f4c <LABEL_RET_SCALL_263>
80005f4a:	b1 c0       	cbr	r0,0x10

80005f4c <LABEL_RET_SCALL_263>:
80005f4c:	ef 40 ff f8 	st.w	r7[-8],r0
80005f50:	ee f0 ff e4 	ld.w	r0,r7[-28]
80005f54:	ef 40 ff fc 	st.w	r7[-4],r0
80005f58:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005f5c:	2f ad       	sub	sp,-24
80005f5e:	d6 13       	rets
80005f60:	80 00       	ld.sh	r0,r0[0x0]
80005f62:	5e 68       	retmi	r8
80005f64:	80 00       	ld.sh	r0,r0[0x0]
80005f66:	66 04       	ld.w	r4,r3[0x0]

80005f68 <prvClearCcInt>:
		Set_system_register(AVR32_COUNT, 0);
	}

	__attribute__((__noinline__)) static void prvClearCcInt(void)
	{
		Set_system_register(AVR32_COMPARE, Get_system_register(AVR32_COMPARE));
80005f68:	e1 b8 00 43 	mfsr	r8,0x10c
80005f6c:	e3 b8 00 43 	mtsr	0x10c,r8
	}
80005f70:	5e fc       	retal	r12
80005f72:	d7 03       	nop

80005f74 <vPortExitCritical>:
}
/*-----------------------------------------------------------*/

__attribute__((__noinline__)) void vPortExitCritical( void )
{
	if(ulCriticalNesting > portNO_CRITICAL_NESTING)
80005f74:	48 78       	lddpc	r8,80005f90 <vPortExitCritical+0x1c>
80005f76:	70 08       	ld.w	r8,r8[0x0]
80005f78:	58 08       	cp.w	r8,0
80005f7a:	5e 0c       	reteq	r12
	{
		ulCriticalNesting--;
80005f7c:	48 58       	lddpc	r8,80005f90 <vPortExitCritical+0x1c>
80005f7e:	70 09       	ld.w	r9,r8[0x0]
80005f80:	20 19       	sub	r9,1
80005f82:	91 09       	st.w	r8[0x0],r9
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
80005f84:	70 08       	ld.w	r8,r8[0x0]
80005f86:	58 08       	cp.w	r8,0
80005f88:	5e 1c       	retne	r12
		{
			/* Enable all interrupt/exception. */
			portENABLE_INTERRUPTS();
80005f8a:	d5 03       	csrf	0x10
80005f8c:	5e fc       	retal	r12
80005f8e:	00 00       	add	r0,r0
80005f90:	00 00       	add	r0,r0
80005f92:	05 34       	ld.ub	r4,r2++

80005f94 <vTick>:
/* The preemptive scheduler is defined as "naked" as the full context is saved
on entry as part of the context switch. */
__attribute__((__naked__)) static void vTick( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_OS_INT();
80005f94:	eb cd 00 ff 	pushm	r0-r7
80005f98:	e0 68 05 34 	mov	r8,1332
80005f9c:	ea 18 00 00 	orh	r8,0x0
80005fa0:	70 00       	ld.w	r0,r8[0x0]
80005fa2:	1a d0       	st.w	--sp,r0
80005fa4:	7a 90       	ld.w	r0,sp[0x24]
80005fa6:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80005faa:	58 10       	cp.w	r0,1
80005fac:	e0 8b 00 08 	brhi	80005fbc <LABEL_INT_SKIP_SAVE_CONTEXT_237>
80005fb0:	e0 68 0c f0 	mov	r8,3312
80005fb4:	ea 18 00 00 	orh	r8,0x0
80005fb8:	70 00       	ld.w	r0,r8[0x0]
80005fba:	81 0d       	st.w	r0[0x0],sp

80005fbc <LABEL_INT_SKIP_SAVE_CONTEXT_237>:
	#if( configTICK_USE_TC==1 )
		/* Clear the interrupt flag. */
		prvClearTcInt();
	#else
		/* Clear the interrupt flag. */
		prvClearCcInt();
80005fbc:	f0 1f 00 12 	mcall	80006004 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x14>
	#endif

	/* Because FreeRTOS is not supposed to run with nested interrupts, put all OS
	calls in a critical section . */
	portENTER_CRITICAL();
80005fc0:	f0 1f 00 12 	mcall	80006008 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
		vTaskIncrementTick();
80005fc4:	f0 1f 00 12 	mcall	8000600c <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x1c>
	portEXIT_CRITICAL();
80005fc8:	f0 1f 00 12 	mcall	80006010 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>

	/* Restore the context of the "elected task". */
	portRESTORE_CONTEXT_OS_INT();
80005fcc:	7a 90       	ld.w	r0,sp[0x24]
80005fce:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80005fd2:	58 10       	cp.w	r0,1
80005fd4:	e0 8b 00 0e 	brhi	80005ff0 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>
80005fd8:	f0 1f 00 0c 	mcall	80006008 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
80005fdc:	f0 1f 00 0e 	mcall	80006014 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x24>
80005fe0:	f0 1f 00 0c 	mcall	80006010 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>
80005fe4:	e0 68 0c f0 	mov	r8,3312
80005fe8:	ea 18 00 00 	orh	r8,0x0
80005fec:	70 00       	ld.w	r0,r8[0x0]
80005fee:	60 0d       	ld.w	sp,r0[0x0]

80005ff0 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>:
80005ff0:	1b 00       	ld.w	r0,sp++
80005ff2:	e0 68 05 34 	mov	r8,1332
80005ff6:	ea 18 00 00 	orh	r8,0x0
80005ffa:	91 00       	st.w	r8[0x0],r0
80005ffc:	e3 cd 00 ff 	ldm	sp++,r0-r7
80006000:	d6 03       	rete
80006002:	00 00       	add	r0,r0
80006004:	80 00       	ld.sh	r0,r0[0x0]
80006006:	5f 68       	srmi	r8
80006008:	80 00       	ld.sh	r0,r0[0x0]
8000600a:	5e 68       	retmi	r8
8000600c:	80 00       	ld.sh	r0,r0[0x0]
8000600e:	68 08       	ld.w	r8,r4[0x0]
80006010:	80 00       	ld.sh	r0,r0[0x0]
80006012:	5f 74       	srpl	r4
80006014:	80 00       	ld.sh	r0,r0[0x0]
80006016:	66 04       	ld.w	r4,r3[0x0]

80006018 <__malloc_lock>:
 * safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_lock(struct _reent *ptr);
void __malloc_lock(struct _reent *ptr)
{
80006018:	d4 01       	pushm	lr
	vTaskSuspendAll();
8000601a:	f0 1f 00 02 	mcall	80006020 <__malloc_lock+0x8>
}
8000601e:	d8 02       	popm	pc
80006020:	80 00       	ld.sh	r0,r0[0x0]
80006022:	65 f4       	ld.w	r4,r2[0x7c]

80006024 <__malloc_unlock>:
 * a safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_unlock(struct _reent *ptr);
void __malloc_unlock(struct _reent *ptr)
{
80006024:	d4 01       	pushm	lr
	xTaskResumeAll();
80006026:	f0 1f 00 02 	mcall	8000602c <__malloc_unlock+0x8>
}
8000602a:	d8 02       	popm	pc
8000602c:	80 00       	ld.sh	r0,r0[0x0]
8000602e:	69 b0       	ld.w	r0,r4[0x6c]

80006030 <_read>:
/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
{
80006030:	d4 21       	pushm	r4-r7,lr
80006032:	16 95       	mov	r5,r11
80006034:	14 96       	mov	r6,r10
  int nChars = 0;

  if (file != 0)
80006036:	58 0c       	cp.w	r12,0
80006038:	c0 30       	breq	8000603e <_read+0xe>
8000603a:	3f f7       	mov	r7,-1
8000603c:	c1 48       	rjmp	80006064 <_read+0x34>
    return -1;

  for (; len > 0; --len)
8000603e:	58 0a       	cp.w	r10,0
80006040:	e0 89 00 04 	brgt	80006048 <_read+0x18>
80006044:	30 07       	mov	r7,0
80006046:	c0 f8       	rjmp	80006064 <_read+0x34>
80006048:	30 07       	mov	r7,0
  {
    int c = usart_getchar(stdio_usart_base);
8000604a:	48 84       	lddpc	r4,80006068 <_read+0x38>
8000604c:	68 0c       	ld.w	r12,r4[0x0]
8000604e:	f0 1f 00 08 	mcall	8000606c <_read+0x3c>
    if (c < 0)
80006052:	c0 95       	brlt	80006064 <_read+0x34>
      break;

    *ptr++ = c;
80006054:	ea 07 0b 0c 	st.b	r5[r7],r12
    ++nChars;
80006058:	2f f7       	sub	r7,-1

/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
8000605a:	ec 07 01 08 	sub	r8,r6,r7
  int nChars = 0;

  if (file != 0)
    return -1;

  for (; len > 0; --len)
8000605e:	58 08       	cp.w	r8,0
80006060:	fe 99 ff f6 	brgt	8000604c <_read+0x1c>
    *ptr++ = c;
    ++nChars;
  }

  return nChars;
}
80006064:	0e 9c       	mov	r12,r7
80006066:	d8 22       	popm	r4-r7,pc
80006068:	00 00       	add	r0,r0
8000606a:	bf ec       	*unknown*
8000606c:	80 00       	ld.sh	r0,r0[0x0]
8000606e:	5b bc       	cp.w	r12,-5

80006070 <_write>:
 * 1 and 2 is stdout and stderr which goes to usart
 * 3 is framebuffer
 */
int __attribute__((weak))
_write (int file, char * ptr, int len)
{
80006070:	d4 21       	pushm	r4-r7,lr
80006072:	16 95       	mov	r5,r11
80006074:	14 96       	mov	r6,r10
  int nChars = 0;

  if ( (file != 1)
80006076:	20 1c       	sub	r12,1
80006078:	58 2c       	cp.w	r12,2
8000607a:	e0 8b 00 12 	brhi	8000609e <_write+0x2e>
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
8000607e:	58 0a       	cp.w	r10,0
80006080:	c0 31       	brne	80006086 <_write+0x16>
80006082:	30 07       	mov	r7,0
80006084:	c0 e8       	rjmp	800060a0 <_write+0x30>
80006086:	30 07       	mov	r7,0
  {
    if (usart_putchar(stdio_usart_base, *ptr++) < 0)
80006088:	48 74       	lddpc	r4,800060a4 <_write+0x34>
8000608a:	68 0c       	ld.w	r12,r4[0x0]
8000608c:	ea 07 07 0b 	ld.ub	r11,r5[r7]
80006090:	f0 1f 00 06 	mcall	800060a8 <_write+0x38>
80006094:	c0 55       	brlt	8000609e <_write+0x2e>
    {
      return -1;
    }

    ++nChars;
80006096:	2f f7       	sub	r7,-1

  if ( (file != 1)
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80006098:	0e 36       	cp.w	r6,r7
8000609a:	cf 81       	brne	8000608a <_write+0x1a>
8000609c:	c0 28       	rjmp	800060a0 <_write+0x30>
8000609e:	3f f7       	mov	r7,-1

    ++nChars;
  }

  return nChars;
}
800060a0:	0e 9c       	mov	r12,r7
800060a2:	d8 22       	popm	r4-r7,pc
800060a4:	00 00       	add	r0,r0
800060a6:	bf ec       	*unknown*
800060a8:	80 00       	ld.sh	r0,r0[0x0]
800060aa:	5b 6c       	cp.w	r12,-10

800060ac <vPortFree>:
	return pvReturn;
}
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
800060ac:	eb cd 40 80 	pushm	r7,lr
800060b0:	18 97       	mov	r7,r12
	if( pv )
800060b2:	58 0c       	cp.w	r12,0
800060b4:	c0 80       	breq	800060c4 <vPortFree+0x18>
	{
		vTaskSuspendAll();
800060b6:	f0 1f 00 05 	mcall	800060c8 <vPortFree+0x1c>
		{
			free( pv );
800060ba:	0e 9c       	mov	r12,r7
800060bc:	f0 1f 00 04 	mcall	800060cc <vPortFree+0x20>
		}
		xTaskResumeAll();
800060c0:	f0 1f 00 04 	mcall	800060d0 <vPortFree+0x24>
800060c4:	e3 cd 80 80 	ldm	sp++,r7,pc
800060c8:	80 00       	ld.sh	r0,r0[0x0]
800060ca:	65 f4       	ld.w	r4,r2[0x7c]
800060cc:	80 00       	ld.sh	r0,r0[0x0]
800060ce:	74 84       	ld.w	r4,r10[0x20]
800060d0:	80 00       	ld.sh	r0,r0[0x0]
800060d2:	69 b0       	ld.w	r0,r4[0x6c]

800060d4 <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
800060d4:	eb cd 40 80 	pushm	r7,lr
800060d8:	18 97       	mov	r7,r12
void *pvReturn;

	vTaskSuspendAll();
800060da:	f0 1f 00 06 	mcall	800060f0 <pvPortMalloc+0x1c>
	{
		pvReturn = malloc( xWantedSize );
800060de:	0e 9c       	mov	r12,r7
800060e0:	f0 1f 00 05 	mcall	800060f4 <pvPortMalloc+0x20>
800060e4:	18 97       	mov	r7,r12
	}
	xTaskResumeAll();
800060e6:	f0 1f 00 05 	mcall	800060f8 <pvPortMalloc+0x24>
		}
	}
	#endif

	return pvReturn;
}
800060ea:	0e 9c       	mov	r12,r7
800060ec:	e3 cd 80 80 	ldm	sp++,r7,pc
800060f0:	80 00       	ld.sh	r0,r0[0x0]
800060f2:	65 f4       	ld.w	r4,r2[0x7c]
800060f4:	80 00       	ld.sh	r0,r0[0x0]
800060f6:	74 94       	ld.w	r4,r10[0x24]
800060f8:	80 00       	ld.sh	r0,r0[0x0]
800060fa:	69 b0       	ld.w	r0,r4[0x6c]

800060fc <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
800060fc:	d4 01       	pushm	lr
800060fe:	16 98       	mov	r8,r11
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
80006100:	78 09       	ld.w	r9,r12[0x0]
80006102:	58 09       	cp.w	r9,0
80006104:	c1 10       	breq	80006126 <prvCopyDataFromQueue+0x2a>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
80006106:	78 3a       	ld.w	r10,r12[0xc]
80006108:	79 09       	ld.w	r9,r12[0x40]
8000610a:	f4 09 00 09 	add	r9,r10,r9
8000610e:	99 39       	st.w	r12[0xc],r9
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
80006110:	78 1a       	ld.w	r10,r12[0x4]
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
80006112:	14 39       	cp.w	r9,r10
80006114:	f9 f9 20 00 	ld.wcc	r9,r12[0x0]
80006118:	f9 f9 2a 03 	st.wcc	r12[0xc],r9
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
8000611c:	79 0a       	ld.w	r10,r12[0x40]
8000611e:	78 3b       	ld.w	r11,r12[0xc]
80006120:	10 9c       	mov	r12,r8
80006122:	f0 1f 00 02 	mcall	80006128 <prvCopyDataFromQueue+0x2c>
80006126:	d8 02       	popm	pc
80006128:	80 00       	ld.sh	r0,r0[0x0]
8000612a:	78 dc       	ld.w	r12,r12[0x34]

8000612c <xQueueReceiveFromISR>:
	}
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
8000612c:	eb cd 40 c0 	pushm	r6-r7,lr
80006130:	18 97       	mov	r7,r12
80006132:	14 96       	mov	r6,r10
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80006134:	78 e8       	ld.w	r8,r12[0x38]
80006136:	58 08       	cp.w	r8,0
80006138:	c0 31       	brne	8000613e <xQueueReceiveFromISR+0x12>
8000613a:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
8000613e:	f0 1f 00 0e 	mcall	80006174 <xQueueReceiveFromISR+0x48>
			--( pxQueue->uxMessagesWaiting );
80006142:	6e e8       	ld.w	r8,r7[0x38]
80006144:	20 18       	sub	r8,1
80006146:	8f e8       	st.w	r7[0x38],r8

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
80006148:	6f 18       	ld.w	r8,r7[0x44]
8000614a:	5b f8       	cp.w	r8,-1
8000614c:	c0 d1       	brne	80006166 <xQueueReceiveFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
8000614e:	6e 48       	ld.w	r8,r7[0x10]
80006150:	58 08       	cp.w	r8,0
80006152:	c0 f0       	breq	80006170 <xQueueReceiveFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80006154:	ee cc ff f0 	sub	r12,r7,-16
80006158:	f0 1f 00 08 	mcall	80006178 <xQueueReceiveFromISR+0x4c>
8000615c:	c0 a0       	breq	80006170 <xQueueReceiveFromISR+0x44>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
8000615e:	30 1c       	mov	r12,1
80006160:	8d 0c       	st.w	r6[0x0],r12
80006162:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
80006166:	2f f8       	sub	r8,-1
80006168:	ef 48 00 44 	st.w	r7[68],r8
8000616c:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80006170:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80006174:	80 00       	ld.sh	r0,r0[0x0]
80006176:	60 fc       	ld.w	r12,r0[0x3c]
80006178:	80 00       	ld.sh	r0,r0[0x0]
8000617a:	67 8c       	ld.w	r12,r3[0x60]

8000617c <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
8000617c:	eb cd 40 c0 	pushm	r6-r7,lr
80006180:	18 97       	mov	r7,r12

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
80006182:	f0 1f 00 23 	mcall	8000620c <prvUnlockQueue+0x90>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80006186:	6f 28       	ld.w	r8,r7[0x48]
80006188:	58 08       	cp.w	r8,0
8000618a:	e0 8a 00 18 	brle	800061ba <prvUnlockQueue+0x3e>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
8000618e:	6e 98       	ld.w	r8,r7[0x24]
80006190:	58 08       	cp.w	r8,0
80006192:	c1 40       	breq	800061ba <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80006194:	ee c6 ff dc 	sub	r6,r7,-36
80006198:	c0 48       	rjmp	800061a0 <prvUnlockQueue+0x24>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
8000619a:	6e 98       	ld.w	r8,r7[0x24]
8000619c:	58 08       	cp.w	r8,0
8000619e:	c0 e0       	breq	800061ba <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
800061a0:	0c 9c       	mov	r12,r6
800061a2:	f0 1f 00 1c 	mcall	80006210 <prvUnlockQueue+0x94>
800061a6:	c0 30       	breq	800061ac <prvUnlockQueue+0x30>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
800061a8:	f0 1f 00 1b 	mcall	80006214 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xTxLock );
800061ac:	6f 28       	ld.w	r8,r7[0x48]
800061ae:	20 18       	sub	r8,1
800061b0:	ef 48 00 48 	st.w	r7[72],r8
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
800061b4:	58 08       	cp.w	r8,0
800061b6:	fe 99 ff f2 	brgt	8000619a <prvUnlockQueue+0x1e>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
800061ba:	3f f8       	mov	r8,-1
800061bc:	ef 48 00 48 	st.w	r7[72],r8
	}
	taskEXIT_CRITICAL();
800061c0:	f0 1f 00 16 	mcall	80006218 <prvUnlockQueue+0x9c>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
800061c4:	f0 1f 00 12 	mcall	8000620c <prvUnlockQueue+0x90>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
800061c8:	6f 18       	ld.w	r8,r7[0x44]
800061ca:	58 08       	cp.w	r8,0
800061cc:	e0 8a 00 18 	brle	800061fc <prvUnlockQueue+0x80>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
800061d0:	6e 48       	ld.w	r8,r7[0x10]
800061d2:	58 08       	cp.w	r8,0
800061d4:	c1 40       	breq	800061fc <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
800061d6:	ee c6 ff f0 	sub	r6,r7,-16
800061da:	c0 48       	rjmp	800061e2 <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
800061dc:	6e 48       	ld.w	r8,r7[0x10]
800061de:	58 08       	cp.w	r8,0
800061e0:	c0 e0       	breq	800061fc <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
800061e2:	0c 9c       	mov	r12,r6
800061e4:	f0 1f 00 0b 	mcall	80006210 <prvUnlockQueue+0x94>
800061e8:	c0 30       	breq	800061ee <prvUnlockQueue+0x72>
				{
					vTaskMissedYield();
800061ea:	f0 1f 00 0b 	mcall	80006214 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xRxLock );
800061ee:	6f 18       	ld.w	r8,r7[0x44]
800061f0:	20 18       	sub	r8,1
800061f2:	ef 48 00 44 	st.w	r7[68],r8
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
800061f6:	58 08       	cp.w	r8,0
800061f8:	fe 99 ff f2 	brgt	800061dc <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
800061fc:	3f f8       	mov	r8,-1
800061fe:	ef 48 00 44 	st.w	r7[68],r8
	}
	taskEXIT_CRITICAL();
80006202:	f0 1f 00 06 	mcall	80006218 <prvUnlockQueue+0x9c>
}
80006206:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000620a:	00 00       	add	r0,r0
8000620c:	80 00       	ld.sh	r0,r0[0x0]
8000620e:	5e 68       	retmi	r8
80006210:	80 00       	ld.sh	r0,r0[0x0]
80006212:	67 8c       	ld.w	r12,r3[0x60]
80006214:	80 00       	ld.sh	r0,r0[0x0]
80006216:	66 98       	ld.w	r8,r3[0x24]
80006218:	80 00       	ld.sh	r0,r0[0x0]
8000621a:	5f 74       	srpl	r4

8000621c <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
8000621c:	d4 31       	pushm	r0-r7,lr
8000621e:	20 5d       	sub	sp,20
80006220:	18 97       	mov	r7,r12
80006222:	50 0b       	stdsp	sp[0x0],r11
80006224:	50 2a       	stdsp	sp[0x8],r10
80006226:	50 19       	stdsp	sp[0x4],r9
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80006228:	f8 c2 ff dc 	sub	r2,r12,-36
8000622c:	30 05       	mov	r5,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
8000622e:	fa c4 ff f4 	sub	r4,sp,-12
80006232:	30 10       	mov	r0,1

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
80006234:	0a 91       	mov	r1,r5

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80006236:	fa c3 ff f8 	sub	r3,sp,-8
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
8000623a:	f0 1f 00 3e 	mcall	80006330 <xQueueGenericReceive+0x114>
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
8000623e:	6e e8       	ld.w	r8,r7[0x38]
80006240:	58 08       	cp.w	r8,0
80006242:	c2 a0       	breq	80006296 <xQueueGenericReceive+0x7a>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
80006244:	6e 36       	ld.w	r6,r7[0xc]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
80006246:	40 0b       	lddsp	r11,sp[0x0]
80006248:	0e 9c       	mov	r12,r7
8000624a:	f0 1f 00 3b 	mcall	80006334 <xQueueGenericReceive+0x118>

				if( xJustPeeking == pdFALSE )
8000624e:	40 18       	lddsp	r8,sp[0x4]
80006250:	58 08       	cp.w	r8,0
80006252:	c1 51       	brne	8000627c <xQueueGenericReceive+0x60>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
80006254:	6e e8       	ld.w	r8,r7[0x38]
80006256:	20 18       	sub	r8,1
80006258:	8f e8       	st.w	r7[0x38],r8

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
8000625a:	6e 08       	ld.w	r8,r7[0x0]
8000625c:	58 08       	cp.w	r8,0
8000625e:	c0 41       	brne	80006266 <xQueueGenericReceive+0x4a>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
80006260:	f0 1f 00 36 	mcall	80006338 <xQueueGenericReceive+0x11c>
80006264:	8f 1c       	st.w	r7[0x4],r12
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80006266:	6e 48       	ld.w	r8,r7[0x10]
80006268:	58 08       	cp.w	r8,0
8000626a:	c1 20       	breq	8000628e <xQueueGenericReceive+0x72>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
8000626c:	ee cc ff f0 	sub	r12,r7,-16
80006270:	f0 1f 00 33 	mcall	8000633c <xQueueGenericReceive+0x120>
80006274:	58 1c       	cp.w	r12,1
80006276:	c0 c1       	brne	8000628e <xQueueGenericReceive+0x72>
						{
							portYIELD_WITHIN_API();
80006278:	d7 33       	scall
8000627a:	c0 a8       	rjmp	8000628e <xQueueGenericReceive+0x72>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
8000627c:	8f 36       	st.w	r7[0xc],r6

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
8000627e:	6e 98       	ld.w	r8,r7[0x24]
80006280:	58 08       	cp.w	r8,0
80006282:	c0 60       	breq	8000628e <xQueueGenericReceive+0x72>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80006284:	04 9c       	mov	r12,r2
80006286:	f0 1f 00 2e 	mcall	8000633c <xQueueGenericReceive+0x120>
8000628a:	c0 20       	breq	8000628e <xQueueGenericReceive+0x72>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
8000628c:	d7 33       	scall
						}
					}

				}

				taskEXIT_CRITICAL();
8000628e:	f0 1f 00 2d 	mcall	80006340 <xQueueGenericReceive+0x124>
80006292:	30 1c       	mov	r12,1
				return pdPASS;
80006294:	c4 c8       	rjmp	8000632c <xQueueGenericReceive+0x110>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
80006296:	40 28       	lddsp	r8,sp[0x8]
80006298:	58 08       	cp.w	r8,0
8000629a:	c0 51       	brne	800062a4 <xQueueGenericReceive+0x88>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
8000629c:	f0 1f 00 29 	mcall	80006340 <xQueueGenericReceive+0x124>
800062a0:	30 0c       	mov	r12,0
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
800062a2:	c4 58       	rjmp	8000632c <xQueueGenericReceive+0x110>
				}
				else if( xEntryTimeSet == pdFALSE )
800062a4:	58 05       	cp.w	r5,0
800062a6:	c0 51       	brne	800062b0 <xQueueGenericReceive+0x94>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
800062a8:	08 9c       	mov	r12,r4
800062aa:	f0 1f 00 27 	mcall	80006344 <xQueueGenericReceive+0x128>
800062ae:	00 95       	mov	r5,r0
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
800062b0:	f0 1f 00 24 	mcall	80006340 <xQueueGenericReceive+0x124>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
800062b4:	f0 1f 00 25 	mcall	80006348 <xQueueGenericReceive+0x12c>
		prvLockQueue( pxQueue );
800062b8:	f0 1f 00 1e 	mcall	80006330 <xQueueGenericReceive+0x114>
800062bc:	6f 18       	ld.w	r8,r7[0x44]
800062be:	5b f8       	cp.w	r8,-1
800062c0:	ef f1 0a 11 	st.weq	r7[0x44],r1
800062c4:	6f 28       	ld.w	r8,r7[0x48]
800062c6:	5b f8       	cp.w	r8,-1
800062c8:	ef f1 0a 12 	st.weq	r7[0x48],r1
800062cc:	f0 1f 00 1d 	mcall	80006340 <xQueueGenericReceive+0x124>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
800062d0:	06 9b       	mov	r11,r3
800062d2:	08 9c       	mov	r12,r4
800062d4:	f0 1f 00 1e 	mcall	8000634c <xQueueGenericReceive+0x130>
800062d8:	c2 41       	brne	80006320 <xQueueGenericReceive+0x104>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
800062da:	f0 1f 00 16 	mcall	80006330 <xQueueGenericReceive+0x114>
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
800062de:	6e e6       	ld.w	r6,r7[0x38]
	taskEXIT_CRITICAL();
800062e0:	f0 1f 00 18 	mcall	80006340 <xQueueGenericReceive+0x124>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) )
800062e4:	58 06       	cp.w	r6,0
800062e6:	c1 71       	brne	80006314 <xQueueGenericReceive+0xf8>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
800062e8:	6e 08       	ld.w	r8,r7[0x0]
800062ea:	58 08       	cp.w	r8,0
800062ec:	c0 81       	brne	800062fc <xQueueGenericReceive+0xe0>
					{
						portENTER_CRITICAL();
800062ee:	f0 1f 00 11 	mcall	80006330 <xQueueGenericReceive+0x114>
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
800062f2:	6e 1c       	ld.w	r12,r7[0x4]
800062f4:	f0 1f 00 17 	mcall	80006350 <xQueueGenericReceive+0x134>
						}
						portEXIT_CRITICAL();
800062f8:	f0 1f 00 12 	mcall	80006340 <xQueueGenericReceive+0x124>
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
800062fc:	40 2b       	lddsp	r11,sp[0x8]
800062fe:	04 9c       	mov	r12,r2
80006300:	f0 1f 00 15 	mcall	80006354 <xQueueGenericReceive+0x138>
				prvUnlockQueue( pxQueue );
80006304:	0e 9c       	mov	r12,r7
80006306:	f0 1f 00 15 	mcall	80006358 <xQueueGenericReceive+0x13c>
				if( !xTaskResumeAll() )
8000630a:	f0 1f 00 15 	mcall	8000635c <xQueueGenericReceive+0x140>
8000630e:	c9 61       	brne	8000623a <xQueueGenericReceive+0x1e>
				{
					portYIELD_WITHIN_API();
80006310:	d7 33       	scall
80006312:	c9 4b       	rjmp	8000623a <xQueueGenericReceive+0x1e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
80006314:	0e 9c       	mov	r12,r7
80006316:	f0 1f 00 11 	mcall	80006358 <xQueueGenericReceive+0x13c>
				( void ) xTaskResumeAll();
8000631a:	f0 1f 00 11 	mcall	8000635c <xQueueGenericReceive+0x140>
8000631e:	c8 eb       	rjmp	8000623a <xQueueGenericReceive+0x1e>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
80006320:	0e 9c       	mov	r12,r7
80006322:	f0 1f 00 0e 	mcall	80006358 <xQueueGenericReceive+0x13c>
			( void ) xTaskResumeAll();
80006326:	f0 1f 00 0e 	mcall	8000635c <xQueueGenericReceive+0x140>
8000632a:	30 0c       	mov	r12,0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
8000632c:	2f bd       	sub	sp,-20
8000632e:	d8 32       	popm	r0-r7,pc
80006330:	80 00       	ld.sh	r0,r0[0x0]
80006332:	5e 68       	retmi	r8
80006334:	80 00       	ld.sh	r0,r0[0x0]
80006336:	60 fc       	ld.w	r12,r0[0x3c]
80006338:	80 00       	ld.sh	r0,r0[0x0]
8000633a:	66 a4       	ld.w	r4,r3[0x28]
8000633c:	80 00       	ld.sh	r0,r0[0x0]
8000633e:	67 8c       	ld.w	r12,r3[0x60]
80006340:	80 00       	ld.sh	r0,r0[0x0]
80006342:	5f 74       	srpl	r4
80006344:	80 00       	ld.sh	r0,r0[0x0]
80006346:	66 80       	ld.w	r0,r3[0x20]
80006348:	80 00       	ld.sh	r0,r0[0x0]
8000634a:	65 f4       	ld.w	r4,r2[0x7c]
8000634c:	80 00       	ld.sh	r0,r0[0x0]
8000634e:	69 1c       	ld.w	r12,r4[0x44]
80006350:	80 00       	ld.sh	r0,r0[0x0]
80006352:	67 08       	ld.w	r8,r3[0x40]
80006354:	80 00       	ld.sh	r0,r0[0x0]
80006356:	6b bc       	ld.w	r12,r5[0x6c]
80006358:	80 00       	ld.sh	r0,r0[0x0]
8000635a:	61 7c       	ld.w	r12,r0[0x5c]
8000635c:	80 00       	ld.sh	r0,r0[0x0]
8000635e:	69 b0       	ld.w	r0,r4[0x6c]

80006360 <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
80006360:	eb cd 40 80 	pushm	r7,lr
80006364:	18 97       	mov	r7,r12
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
80006366:	79 08       	ld.w	r8,r12[0x40]
80006368:	58 08       	cp.w	r8,0
8000636a:	c0 a1       	brne	8000637e <prvCopyDataToQueue+0x1e>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
8000636c:	78 08       	ld.w	r8,r12[0x0]
8000636e:	58 08       	cp.w	r8,0
80006370:	c2 b1       	brne	800063c6 <prvCopyDataToQueue+0x66>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
80006372:	78 1c       	ld.w	r12,r12[0x4]
80006374:	f0 1f 00 17 	mcall	800063d0 <prvCopyDataToQueue+0x70>
				pxQueue->pxMutexHolder = NULL;
80006378:	30 08       	mov	r8,0
8000637a:	8f 18       	st.w	r7[0x4],r8
8000637c:	c2 58       	rjmp	800063c6 <prvCopyDataToQueue+0x66>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
8000637e:	58 0a       	cp.w	r10,0
80006380:	c1 01       	brne	800063a0 <prvCopyDataToQueue+0x40>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80006382:	10 9a       	mov	r10,r8
80006384:	78 2c       	ld.w	r12,r12[0x8]
80006386:	f0 1f 00 14 	mcall	800063d4 <prvCopyDataToQueue+0x74>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
8000638a:	6e 29       	ld.w	r9,r7[0x8]
8000638c:	6f 08       	ld.w	r8,r7[0x40]
8000638e:	f2 08 00 08 	add	r8,r9,r8
80006392:	8f 28       	st.w	r7[0x8],r8
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
80006394:	6e 19       	ld.w	r9,r7[0x4]
80006396:	12 38       	cp.w	r8,r9
80006398:	c1 73       	brcs	800063c6 <prvCopyDataToQueue+0x66>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
8000639a:	6e 08       	ld.w	r8,r7[0x0]
8000639c:	8f 28       	st.w	r7[0x8],r8
8000639e:	c1 48       	rjmp	800063c6 <prvCopyDataToQueue+0x66>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
800063a0:	10 9a       	mov	r10,r8
800063a2:	78 3c       	ld.w	r12,r12[0xc]
800063a4:	f0 1f 00 0c 	mcall	800063d4 <prvCopyDataToQueue+0x74>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
800063a8:	6f 08       	ld.w	r8,r7[0x40]
800063aa:	6e 39       	ld.w	r9,r7[0xc]
800063ac:	f2 08 01 08 	sub	r8,r9,r8
800063b0:	8f 38       	st.w	r7[0xc],r8
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
800063b2:	6e 09       	ld.w	r9,r7[0x0]
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
800063b4:	12 38       	cp.w	r8,r9
800063b6:	ef f8 30 10 	ld.wcs	r8,r7[0x40]
800063ba:	ef f9 30 01 	ld.wcs	r9,r7[0x4]
800063be:	f3 d8 e3 19 	subcs	r9,r9,r8
800063c2:	ef f9 3a 03 	st.wcs	r7[0xc],r9
		}
	}

	++( pxQueue->uxMessagesWaiting );
800063c6:	6e e8       	ld.w	r8,r7[0x38]
800063c8:	2f f8       	sub	r8,-1
800063ca:	8f e8       	st.w	r7[0x38],r8
}
800063cc:	e3 cd 80 80 	ldm	sp++,r7,pc
800063d0:	80 00       	ld.sh	r0,r0[0x0]
800063d2:	66 b0       	ld.w	r0,r3[0x2c]
800063d4:	80 00       	ld.sh	r0,r0[0x0]
800063d6:	78 dc       	ld.w	r12,r12[0x34]

800063d8 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
800063d8:	eb cd 40 c0 	pushm	r6-r7,lr
800063dc:	18 97       	mov	r7,r12
800063de:	14 96       	mov	r6,r10
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
800063e0:	78 ec       	ld.w	r12,r12[0x38]
800063e2:	6e f8       	ld.w	r8,r7[0x3c]
800063e4:	10 3c       	cp.w	r12,r8
800063e6:	c0 33       	brcs	800063ec <xQueueGenericSendFromISR+0x14>
800063e8:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
800063ec:	12 9a       	mov	r10,r9
800063ee:	0e 9c       	mov	r12,r7
800063f0:	f0 1f 00 0c 	mcall	80006420 <xQueueGenericSendFromISR+0x48>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
800063f4:	6f 28       	ld.w	r8,r7[0x48]
800063f6:	5b f8       	cp.w	r8,-1
800063f8:	c0 d1       	brne	80006412 <xQueueGenericSendFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
800063fa:	6e 98       	ld.w	r8,r7[0x24]
800063fc:	58 08       	cp.w	r8,0
800063fe:	c0 f0       	breq	8000641c <xQueueGenericSendFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80006400:	ee cc ff dc 	sub	r12,r7,-36
80006404:	f0 1f 00 08 	mcall	80006424 <xQueueGenericSendFromISR+0x4c>
80006408:	c0 a0       	breq	8000641c <xQueueGenericSendFromISR+0x44>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
8000640a:	30 1c       	mov	r12,1
8000640c:	8d 0c       	st.w	r6[0x0],r12
8000640e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
80006412:	2f f8       	sub	r8,-1
80006414:	ef 48 00 48 	st.w	r7[72],r8
80006418:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
8000641c:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80006420:	80 00       	ld.sh	r0,r0[0x0]
80006422:	63 60       	ld.w	r0,r1[0x58]
80006424:	80 00       	ld.sh	r0,r0[0x0]
80006426:	67 8c       	ld.w	r12,r3[0x60]

80006428 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
80006428:	d4 31       	pushm	r0-r7,lr
8000642a:	20 5d       	sub	sp,20
8000642c:	18 97       	mov	r7,r12
8000642e:	50 0b       	stdsp	sp[0x0],r11
80006430:	50 2a       	stdsp	sp[0x8],r10
80006432:	50 19       	stdsp	sp[0x4],r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
80006434:	f8 c0 ff f0 	sub	r0,r12,-16
80006438:	30 04       	mov	r4,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
8000643a:	fa c3 ff f4 	sub	r3,sp,-12

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
8000643e:	08 91       	mov	r1,r4

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80006440:	fa c2 ff f8 	sub	r2,sp,-8
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
80006444:	f0 1f 00 2f 	mcall	80006500 <xQueueGenericSend+0xd8>
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
80006448:	6e e9       	ld.w	r9,r7[0x38]
8000644a:	6e f8       	ld.w	r8,r7[0x3c]
8000644c:	10 39       	cp.w	r9,r8
8000644e:	c1 42       	brcc	80006476 <xQueueGenericSend+0x4e>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80006450:	40 1a       	lddsp	r10,sp[0x4]
80006452:	40 0b       	lddsp	r11,sp[0x0]
80006454:	0e 9c       	mov	r12,r7
80006456:	f0 1f 00 2c 	mcall	80006504 <xQueueGenericSend+0xdc>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
8000645a:	6e 98       	ld.w	r8,r7[0x24]
8000645c:	58 08       	cp.w	r8,0
8000645e:	c0 80       	breq	8000646e <xQueueGenericSend+0x46>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
80006460:	ee cc ff dc 	sub	r12,r7,-36
80006464:	f0 1f 00 29 	mcall	80006508 <xQueueGenericSend+0xe0>
80006468:	58 1c       	cp.w	r12,1
8000646a:	c0 21       	brne	8000646e <xQueueGenericSend+0x46>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
8000646c:	d7 33       	scall
					}
				}

				taskEXIT_CRITICAL();
8000646e:	f0 1f 00 28 	mcall	8000650c <xQueueGenericSend+0xe4>
80006472:	30 1c       	mov	r12,1

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
80006474:	c4 38       	rjmp	800064fa <xQueueGenericSend+0xd2>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
80006476:	40 28       	lddsp	r8,sp[0x8]
80006478:	58 08       	cp.w	r8,0
8000647a:	c0 51       	brne	80006484 <xQueueGenericSend+0x5c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
8000647c:	f0 1f 00 24 	mcall	8000650c <xQueueGenericSend+0xe4>
80006480:	30 0c       	mov	r12,0

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
80006482:	c3 c8       	rjmp	800064fa <xQueueGenericSend+0xd2>
				}
				else if( xEntryTimeSet == pdFALSE )
80006484:	58 04       	cp.w	r4,0
80006486:	c0 51       	brne	80006490 <xQueueGenericSend+0x68>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80006488:	06 9c       	mov	r12,r3
8000648a:	f0 1f 00 22 	mcall	80006510 <xQueueGenericSend+0xe8>
8000648e:	30 14       	mov	r4,1
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80006490:	f0 1f 00 1f 	mcall	8000650c <xQueueGenericSend+0xe4>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80006494:	f0 1f 00 20 	mcall	80006514 <xQueueGenericSend+0xec>
		prvLockQueue( pxQueue );
80006498:	f0 1f 00 1a 	mcall	80006500 <xQueueGenericSend+0xd8>
8000649c:	6f 18       	ld.w	r8,r7[0x44]
8000649e:	5b f8       	cp.w	r8,-1
800064a0:	ef f1 0a 11 	st.weq	r7[0x44],r1
800064a4:	6f 28       	ld.w	r8,r7[0x48]
800064a6:	5b f8       	cp.w	r8,-1
800064a8:	ef f1 0a 12 	st.weq	r7[0x48],r1
800064ac:	f0 1f 00 18 	mcall	8000650c <xQueueGenericSend+0xe4>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
800064b0:	04 9b       	mov	r11,r2
800064b2:	06 9c       	mov	r12,r3
800064b4:	f0 1f 00 19 	mcall	80006518 <xQueueGenericSend+0xf0>
800064b8:	c1 b1       	brne	800064ee <xQueueGenericSend+0xc6>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
800064ba:	f0 1f 00 12 	mcall	80006500 <xQueueGenericSend+0xd8>
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
800064be:	6e e5       	ld.w	r5,r7[0x38]
800064c0:	6e f6       	ld.w	r6,r7[0x3c]
	taskEXIT_CRITICAL();
800064c2:	f0 1f 00 13 	mcall	8000650c <xQueueGenericSend+0xe4>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
800064c6:	0c 35       	cp.w	r5,r6
800064c8:	c0 d1       	brne	800064e2 <xQueueGenericSend+0xba>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
800064ca:	40 2b       	lddsp	r11,sp[0x8]
800064cc:	00 9c       	mov	r12,r0
800064ce:	f0 1f 00 14 	mcall	8000651c <xQueueGenericSend+0xf4>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
800064d2:	0e 9c       	mov	r12,r7
800064d4:	f0 1f 00 13 	mcall	80006520 <xQueueGenericSend+0xf8>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
800064d8:	f0 1f 00 13 	mcall	80006524 <xQueueGenericSend+0xfc>
800064dc:	cb 41       	brne	80006444 <xQueueGenericSend+0x1c>
				{
					portYIELD_WITHIN_API();
800064de:	d7 33       	scall
800064e0:	cb 2b       	rjmp	80006444 <xQueueGenericSend+0x1c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
800064e2:	0e 9c       	mov	r12,r7
800064e4:	f0 1f 00 0f 	mcall	80006520 <xQueueGenericSend+0xf8>
				( void ) xTaskResumeAll();
800064e8:	f0 1f 00 0f 	mcall	80006524 <xQueueGenericSend+0xfc>
800064ec:	ca cb       	rjmp	80006444 <xQueueGenericSend+0x1c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
800064ee:	0e 9c       	mov	r12,r7
800064f0:	f0 1f 00 0c 	mcall	80006520 <xQueueGenericSend+0xf8>
			( void ) xTaskResumeAll();
800064f4:	f0 1f 00 0c 	mcall	80006524 <xQueueGenericSend+0xfc>
800064f8:	30 0c       	mov	r12,0
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
800064fa:	2f bd       	sub	sp,-20
800064fc:	d8 32       	popm	r0-r7,pc
800064fe:	00 00       	add	r0,r0
80006500:	80 00       	ld.sh	r0,r0[0x0]
80006502:	5e 68       	retmi	r8
80006504:	80 00       	ld.sh	r0,r0[0x0]
80006506:	63 60       	ld.w	r0,r1[0x58]
80006508:	80 00       	ld.sh	r0,r0[0x0]
8000650a:	67 8c       	ld.w	r12,r3[0x60]
8000650c:	80 00       	ld.sh	r0,r0[0x0]
8000650e:	5f 74       	srpl	r4
80006510:	80 00       	ld.sh	r0,r0[0x0]
80006512:	66 80       	ld.w	r0,r3[0x20]
80006514:	80 00       	ld.sh	r0,r0[0x0]
80006516:	65 f4       	ld.w	r4,r2[0x7c]
80006518:	80 00       	ld.sh	r0,r0[0x0]
8000651a:	69 1c       	ld.w	r12,r4[0x44]
8000651c:	80 00       	ld.sh	r0,r0[0x0]
8000651e:	6b bc       	ld.w	r12,r5[0x6c]
80006520:	80 00       	ld.sh	r0,r0[0x0]
80006522:	61 7c       	ld.w	r12,r0[0x5c]
80006524:	80 00       	ld.sh	r0,r0[0x0]
80006526:	69 b0       	ld.w	r0,r4[0x6c]

80006528 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	xQueueHandle xQueueCreateMutex( void )
	{
80006528:	eb cd 40 c0 	pushm	r6-r7,lr
	xQUEUE *pxNewQueue;

		/* Allocate the new queue structure. */
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
8000652c:	34 cc       	mov	r12,76
8000652e:	f0 1f 00 12 	mcall	80006574 <xQueueCreateMutex+0x4c>
80006532:	18 97       	mov	r7,r12
		if( pxNewQueue != NULL )
80006534:	c1 d0       	breq	8000656e <xQueueCreateMutex+0x46>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
80006536:	30 06       	mov	r6,0
80006538:	99 16       	st.w	r12[0x4],r6
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
8000653a:	99 06       	st.w	r12[0x0],r6

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
8000653c:	99 26       	st.w	r12[0x8],r6
			pxNewQueue->pcReadFrom = NULL;
8000653e:	99 36       	st.w	r12[0xc],r6

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
80006540:	99 e6       	st.w	r12[0x38],r6
			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
80006542:	30 18       	mov	r8,1
80006544:	99 f8       	st.w	r12[0x3c],r8
			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
80006546:	f9 46 00 40 	st.w	r12[64],r6
			pxNewQueue->xRxLock = queueUNLOCKED;
8000654a:	3f f8       	mov	r8,-1
8000654c:	f9 48 00 44 	st.w	r12[68],r8
			pxNewQueue->xTxLock = queueUNLOCKED;
80006550:	f9 48 00 48 	st.w	r12[72],r8

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
80006554:	2f 0c       	sub	r12,-16
80006556:	f0 1f 00 09 	mcall	80006578 <xQueueCreateMutex+0x50>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
8000655a:	ee cc ff dc 	sub	r12,r7,-36
8000655e:	f0 1f 00 07 	mcall	80006578 <xQueueCreateMutex+0x50>

			/* Start with the semaphore in the expected state. */
			xQueueGenericSend( pxNewQueue, NULL, ( portTickType ) 0U, queueSEND_TO_BACK );
80006562:	0c 99       	mov	r9,r6
80006564:	0c 9a       	mov	r10,r6
80006566:	0c 9b       	mov	r11,r6
80006568:	0e 9c       	mov	r12,r7
8000656a:	f0 1f 00 05 	mcall	8000657c <xQueueCreateMutex+0x54>
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
8000656e:	0e 9c       	mov	r12,r7
80006570:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006574:	80 00       	ld.sh	r0,r0[0x0]
80006576:	60 d4       	ld.w	r4,r0[0x34]
80006578:	80 00       	ld.sh	r0,r0[0x0]
8000657a:	5d 44       	*unknown*
8000657c:	80 00       	ld.sh	r0,r0[0x0]
8000657e:	64 28       	ld.w	r8,r2[0x8]

80006580 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
80006580:	d4 21       	pushm	r4-r7,lr
80006582:	18 97       	mov	r7,r12
80006584:	16 96       	mov	r6,r11
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
80006586:	58 0c       	cp.w	r12,0
80006588:	c2 f0       	breq	800065e6 <xQueueCreate+0x66>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
8000658a:	34 cc       	mov	r12,76
8000658c:	f0 1f 00 17 	mcall	800065e8 <xQueueCreate+0x68>
80006590:	18 95       	mov	r5,r12
		if( pxNewQueue != NULL )
80006592:	c2 a0       	breq	800065e6 <xQueueCreate+0x66>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
80006594:	ec 07 02 44 	mul	r4,r6,r7

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
80006598:	e8 cc ff ff 	sub	r12,r4,-1
8000659c:	f0 1f 00 13 	mcall	800065e8 <xQueueCreate+0x68>
800065a0:	8b 0c       	st.w	r5[0x0],r12
			if( pxNewQueue->pcHead != NULL )
800065a2:	c1 e0       	breq	800065de <xQueueCreate+0x5e>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
800065a4:	f8 04 00 04 	add	r4,r12,r4
800065a8:	8b 14       	st.w	r5[0x4],r4
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
800065aa:	30 08       	mov	r8,0
800065ac:	8b e8       	st.w	r5[0x38],r8
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
800065ae:	8b 2c       	st.w	r5[0x8],r12
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
800065b0:	ee c8 00 01 	sub	r8,r7,1
800065b4:	ad 38       	mul	r8,r6
800065b6:	10 0c       	add	r12,r8
800065b8:	8b 3c       	st.w	r5[0xc],r12
				pxNewQueue->uxLength = uxQueueLength;
800065ba:	8b f7       	st.w	r5[0x3c],r7
				pxNewQueue->uxItemSize = uxItemSize;
800065bc:	eb 46 00 40 	st.w	r5[64],r6
				pxNewQueue->xRxLock = queueUNLOCKED;
800065c0:	3f f8       	mov	r8,-1
800065c2:	eb 48 00 44 	st.w	r5[68],r8
				pxNewQueue->xTxLock = queueUNLOCKED;
800065c6:	eb 48 00 48 	st.w	r5[72],r8

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
800065ca:	ea cc ff f0 	sub	r12,r5,-16
800065ce:	f0 1f 00 08 	mcall	800065ec <xQueueCreate+0x6c>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
800065d2:	ea cc ff dc 	sub	r12,r5,-36
800065d6:	f0 1f 00 06 	mcall	800065ec <xQueueCreate+0x6c>
800065da:	0a 9c       	mov	r12,r5
800065dc:	d8 22       	popm	r4-r7,pc
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
800065de:	0a 9c       	mov	r12,r5
800065e0:	f0 1f 00 04 	mcall	800065f0 <xQueueCreate+0x70>
800065e4:	d8 2a       	popm	r4-r7,pc,r12=0
800065e6:	d8 2a       	popm	r4-r7,pc,r12=0
800065e8:	80 00       	ld.sh	r0,r0[0x0]
800065ea:	60 d4       	ld.w	r4,r0[0x34]
800065ec:	80 00       	ld.sh	r0,r0[0x0]
800065ee:	5d 44       	*unknown*
800065f0:	80 00       	ld.sh	r0,r0[0x0]
800065f2:	60 ac       	ld.w	r12,r0[0x28]

800065f4 <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
800065f4:	48 38       	lddpc	r8,80006600 <vTaskSuspendAll+0xc>
800065f6:	70 09       	ld.w	r9,r8[0x0]
800065f8:	2f f9       	sub	r9,-1
800065fa:	91 09       	st.w	r8[0x0],r9
}
800065fc:	5e fc       	retal	r12
800065fe:	00 00       	add	r0,r0
80006600:	00 00       	add	r0,r0
80006602:	0d 20       	ld.uh	r0,r6++

80006604 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
80006604:	49 a8       	lddpc	r8,8000666c <vTaskSwitchContext+0x68>
80006606:	70 08       	ld.w	r8,r8[0x0]
80006608:	58 08       	cp.w	r8,0
8000660a:	c0 b1       	brne	80006620 <vTaskSwitchContext+0x1c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
8000660c:	49 98       	lddpc	r8,80006670 <vTaskSwitchContext+0x6c>
8000660e:	70 08       	ld.w	r8,r8[0x0]
80006610:	f0 08 00 28 	add	r8,r8,r8<<0x2
80006614:	49 89       	lddpc	r9,80006674 <vTaskSwitchContext+0x70>
80006616:	f2 08 03 28 	ld.w	r8,r9[r8<<0x2]
8000661a:	58 08       	cp.w	r8,0
8000661c:	c0 60       	breq	80006628 <vTaskSwitchContext+0x24>
8000661e:	c1 18       	rjmp	80006640 <vTaskSwitchContext+0x3c>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
80006620:	30 19       	mov	r9,1
80006622:	49 68       	lddpc	r8,80006678 <vTaskSwitchContext+0x74>
80006624:	91 09       	st.w	r8[0x0],r9
80006626:	5e fc       	retal	r12

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
80006628:	49 28       	lddpc	r8,80006670 <vTaskSwitchContext+0x6c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
8000662a:	49 3a       	lddpc	r10,80006674 <vTaskSwitchContext+0x70>
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
8000662c:	70 09       	ld.w	r9,r8[0x0]
8000662e:	20 19       	sub	r9,1
80006630:	91 09       	st.w	r8[0x0],r9

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80006632:	70 09       	ld.w	r9,r8[0x0]
80006634:	f2 09 00 29 	add	r9,r9,r9<<0x2
80006638:	f4 09 03 29 	ld.w	r9,r10[r9<<0x2]
8000663c:	58 09       	cp.w	r9,0
8000663e:	cf 70       	breq	8000662c <vTaskSwitchContext+0x28>
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
80006640:	48 c8       	lddpc	r8,80006670 <vTaskSwitchContext+0x6c>
80006642:	70 08       	ld.w	r8,r8[0x0]
80006644:	f0 08 00 28 	add	r8,r8,r8<<0x2
80006648:	48 b9       	lddpc	r9,80006674 <vTaskSwitchContext+0x70>
8000664a:	f2 08 00 28 	add	r8,r9,r8<<0x2
8000664e:	70 19       	ld.w	r9,r8[0x4]
80006650:	72 19       	ld.w	r9,r9[0x4]
80006652:	91 19       	st.w	r8[0x4],r9
80006654:	f0 ca ff f8 	sub	r10,r8,-8
80006658:	14 39       	cp.w	r9,r10
8000665a:	f3 f9 00 01 	ld.weq	r9,r9[0x4]
8000665e:	f1 f9 0a 01 	st.weq	r8[0x4],r9
80006662:	70 18       	ld.w	r8,r8[0x4]
80006664:	70 39       	ld.w	r9,r8[0xc]
80006666:	48 68       	lddpc	r8,8000667c <vTaskSwitchContext+0x78>
80006668:	91 09       	st.w	r8[0x0],r9
8000666a:	5e fc       	retal	r12
8000666c:	00 00       	add	r0,r0
8000666e:	0d 20       	ld.uh	r0,r6++
80006670:	00 00       	add	r0,r0
80006672:	0d 58       	ld.sh	r8,--r6
80006674:	00 00       	add	r0,r0
80006676:	0c 3c       	cp.w	r12,r6
80006678:	00 00       	add	r0,r0
8000667a:	0d 40       	ld.w	r0,--r6
8000667c:	00 00       	add	r0,r0
8000667e:	0c f0       	st.b	--r6,r0

80006680 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
80006680:	48 48       	lddpc	r8,80006690 <vTaskSetTimeOutState+0x10>
80006682:	70 08       	ld.w	r8,r8[0x0]
80006684:	99 08       	st.w	r12[0x0],r8
	pxTimeOut->xTimeOnEntering = xTickCount;
80006686:	48 48       	lddpc	r8,80006694 <vTaskSetTimeOutState+0x14>
80006688:	70 08       	ld.w	r8,r8[0x0]
8000668a:	99 18       	st.w	r12[0x4],r8
}
8000668c:	5e fc       	retal	r12
8000668e:	00 00       	add	r0,r0
80006690:	00 00       	add	r0,r0
80006692:	0c 34       	cp.w	r4,r6
80006694:	00 00       	add	r0,r0
80006696:	0d 1c       	ld.sh	r12,r6++

80006698 <vTaskMissedYield>:
}
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
80006698:	30 19       	mov	r9,1
8000669a:	48 28       	lddpc	r8,800066a0 <vTaskMissedYield+0x8>
8000669c:	91 09       	st.w	r8[0x0],r9
}
8000669e:	5e fc       	retal	r12
800066a0:	00 00       	add	r0,r0
800066a2:	0d 40       	ld.w	r0,--r6

800066a4 <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
800066a4:	48 28       	lddpc	r8,800066ac <xTaskGetCurrentTaskHandle+0x8>
800066a6:	70 0c       	ld.w	r12,r8[0x0]

		return xReturn;
	}
800066a8:	5e fc       	retal	r12
800066aa:	00 00       	add	r0,r0
800066ac:	00 00       	add	r0,r0
800066ae:	0c f0       	st.b	--r6,r0

800066b0 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
800066b0:	eb cd 40 c0 	pushm	r6-r7,lr
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
800066b4:	58 0c       	cp.w	r12,0
800066b6:	c1 f0       	breq	800066f4 <vTaskPriorityDisinherit+0x44>

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
800066b8:	18 97       	mov	r7,r12

		if( pxMutexHolder != NULL )
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
800066ba:	78 b9       	ld.w	r9,r12[0x2c]
800066bc:	79 18       	ld.w	r8,r12[0x44]
800066be:	10 39       	cp.w	r9,r8
800066c0:	c1 a0       	breq	800066f4 <vTaskPriorityDisinherit+0x44>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
800066c2:	f8 c6 ff fc 	sub	r6,r12,-4
800066c6:	0c 9c       	mov	r12,r6
800066c8:	f0 1f 00 0c 	mcall	800066f8 <vTaskPriorityDisinherit+0x48>

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
800066cc:	6f 1c       	ld.w	r12,r7[0x44]
800066ce:	8f bc       	st.w	r7[0x2c],r12
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
800066d0:	f8 08 11 08 	rsub	r8,r12,8
800066d4:	8f 68       	st.w	r7[0x18],r8
				prvAddTaskToReadyQueue( pxTCB );
800066d6:	48 a8       	lddpc	r8,800066fc <vTaskPriorityDisinherit+0x4c>
800066d8:	70 08       	ld.w	r8,r8[0x0]
800066da:	10 3c       	cp.w	r12,r8
800066dc:	e0 88 00 04 	brls	800066e4 <vTaskPriorityDisinherit+0x34>
800066e0:	48 78       	lddpc	r8,800066fc <vTaskPriorityDisinherit+0x4c>
800066e2:	91 0c       	st.w	r8[0x0],r12
800066e4:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800066e8:	0c 9b       	mov	r11,r6
800066ea:	48 68       	lddpc	r8,80006700 <vTaskPriorityDisinherit+0x50>
800066ec:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800066f0:	f0 1f 00 05 	mcall	80006704 <vTaskPriorityDisinherit+0x54>
800066f4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800066f8:	80 00       	ld.sh	r0,r0[0x0]
800066fa:	5d ae       	*unknown*
800066fc:	00 00       	add	r0,r0
800066fe:	0d 58       	ld.sh	r8,--r6
80006700:	00 00       	add	r0,r0
80006702:	0c 3c       	cp.w	r12,r6
80006704:	80 00       	ld.sh	r0,r0[0x0]
80006706:	5d 5e       	*unknown*

80006708 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
80006708:	eb cd 40 c0 	pushm	r6-r7,lr
8000670c:	18 97       	mov	r7,r12
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
8000670e:	49 b8       	lddpc	r8,80006778 <vTaskPriorityInherit+0x70>
80006710:	70 08       	ld.w	r8,r8[0x0]
80006712:	78 b9       	ld.w	r9,r12[0x2c]
80006714:	70 b8       	ld.w	r8,r8[0x2c]
80006716:	10 39       	cp.w	r9,r8
80006718:	c2 d2       	brcc	80006772 <vTaskPriorityInherit+0x6a>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
8000671a:	49 88       	lddpc	r8,80006778 <vTaskPriorityInherit+0x70>
8000671c:	70 08       	ld.w	r8,r8[0x0]
8000671e:	70 b8       	ld.w	r8,r8[0x2c]
80006720:	f0 08 11 08 	rsub	r8,r8,8
80006724:	99 68       	st.w	r12[0x18],r8

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
80006726:	f2 09 00 28 	add	r8,r9,r9<<0x2
8000672a:	49 59       	lddpc	r9,8000677c <vTaskPriorityInherit+0x74>
8000672c:	f2 08 00 28 	add	r8,r9,r8<<0x2
80006730:	78 59       	ld.w	r9,r12[0x14]
80006732:	10 39       	cp.w	r9,r8
80006734:	c1 b1       	brne	8000676a <vTaskPriorityInherit+0x62>
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
80006736:	f8 c6 ff fc 	sub	r6,r12,-4
8000673a:	0c 9c       	mov	r12,r6
8000673c:	f0 1f 00 11 	mcall	80006780 <vTaskPriorityInherit+0x78>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
80006740:	48 e8       	lddpc	r8,80006778 <vTaskPriorityInherit+0x70>
80006742:	70 08       	ld.w	r8,r8[0x0]
80006744:	70 bc       	ld.w	r12,r8[0x2c]
80006746:	8f bc       	st.w	r7[0x2c],r12
				prvAddTaskToReadyQueue( pxTCB );
80006748:	48 f8       	lddpc	r8,80006784 <vTaskPriorityInherit+0x7c>
8000674a:	70 08       	ld.w	r8,r8[0x0]
8000674c:	10 3c       	cp.w	r12,r8
8000674e:	e0 88 00 04 	brls	80006756 <vTaskPriorityInherit+0x4e>
80006752:	48 d8       	lddpc	r8,80006784 <vTaskPriorityInherit+0x7c>
80006754:	91 0c       	st.w	r8[0x0],r12
80006756:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
8000675a:	0c 9b       	mov	r11,r6
8000675c:	48 88       	lddpc	r8,8000677c <vTaskPriorityInherit+0x74>
8000675e:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80006762:	f0 1f 00 0a 	mcall	80006788 <vTaskPriorityInherit+0x80>
80006766:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
8000676a:	48 48       	lddpc	r8,80006778 <vTaskPriorityInherit+0x70>
8000676c:	70 08       	ld.w	r8,r8[0x0]
8000676e:	70 b8       	ld.w	r8,r8[0x2c]
80006770:	99 b8       	st.w	r12[0x2c],r8
80006772:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006776:	00 00       	add	r0,r0
80006778:	00 00       	add	r0,r0
8000677a:	0c f0       	st.b	--r6,r0
8000677c:	00 00       	add	r0,r0
8000677e:	0c 3c       	cp.w	r12,r6
80006780:	80 00       	ld.sh	r0,r0[0x0]
80006782:	5d ae       	*unknown*
80006784:	00 00       	add	r0,r0
80006786:	0d 58       	ld.sh	r8,--r6
80006788:	80 00       	ld.sh	r0,r0[0x0]
8000678a:	5d 5e       	*unknown*

8000678c <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
8000678c:	eb cd 40 c0 	pushm	r6-r7,lr
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
80006790:	78 38       	ld.w	r8,r12[0xc]
80006792:	70 37       	ld.w	r7,r8[0xc]
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
80006794:	ee c6 ff e8 	sub	r6,r7,-24
80006798:	0c 9c       	mov	r12,r6
8000679a:	f0 1f 00 15 	mcall	800067ec <xTaskRemoveFromEventList+0x60>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
8000679e:	49 58       	lddpc	r8,800067f0 <xTaskRemoveFromEventList+0x64>
800067a0:	70 08       	ld.w	r8,r8[0x0]
800067a2:	58 08       	cp.w	r8,0
800067a4:	c1 71       	brne	800067d2 <xTaskRemoveFromEventList+0x46>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
800067a6:	ee c6 ff fc 	sub	r6,r7,-4
800067aa:	0c 9c       	mov	r12,r6
800067ac:	f0 1f 00 10 	mcall	800067ec <xTaskRemoveFromEventList+0x60>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
800067b0:	6e bc       	ld.w	r12,r7[0x2c]
800067b2:	49 18       	lddpc	r8,800067f4 <xTaskRemoveFromEventList+0x68>
800067b4:	70 08       	ld.w	r8,r8[0x0]
800067b6:	10 3c       	cp.w	r12,r8
800067b8:	e0 88 00 04 	brls	800067c0 <xTaskRemoveFromEventList+0x34>
800067bc:	48 e8       	lddpc	r8,800067f4 <xTaskRemoveFromEventList+0x68>
800067be:	91 0c       	st.w	r8[0x0],r12
800067c0:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800067c4:	0c 9b       	mov	r11,r6
800067c6:	48 d8       	lddpc	r8,800067f8 <xTaskRemoveFromEventList+0x6c>
800067c8:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800067cc:	f0 1f 00 0c 	mcall	800067fc <xTaskRemoveFromEventList+0x70>
800067d0:	c0 58       	rjmp	800067da <xTaskRemoveFromEventList+0x4e>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
800067d2:	0c 9b       	mov	r11,r6
800067d4:	48 bc       	lddpc	r12,80006800 <xTaskRemoveFromEventList+0x74>
800067d6:	f0 1f 00 0a 	mcall	800067fc <xTaskRemoveFromEventList+0x70>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
800067da:	48 b8       	lddpc	r8,80006804 <xTaskRemoveFromEventList+0x78>
800067dc:	70 08       	ld.w	r8,r8[0x0]
800067de:	6e b9       	ld.w	r9,r7[0x2c]
800067e0:	70 b8       	ld.w	r8,r8[0x2c]
800067e2:	10 39       	cp.w	r9,r8
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
800067e4:	5f 2c       	srhs	r12
800067e6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800067ea:	00 00       	add	r0,r0
800067ec:	80 00       	ld.sh	r0,r0[0x0]
800067ee:	5d ae       	*unknown*
800067f0:	00 00       	add	r0,r0
800067f2:	0d 20       	ld.uh	r0,r6++
800067f4:	00 00       	add	r0,r0
800067f6:	0d 58       	ld.sh	r8,--r6
800067f8:	00 00       	add	r0,r0
800067fa:	0c 3c       	cp.w	r12,r6
800067fc:	80 00       	ld.sh	r0,r0[0x0]
800067fe:	5d 5e       	*unknown*
80006800:	00 00       	add	r0,r0
80006802:	0c f4       	st.b	--r6,r4
80006804:	00 00       	add	r0,r0
80006806:	0c f0       	st.b	--r6,r0

80006808 <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
80006808:	eb cd 40 fc 	pushm	r2-r7,lr
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
8000680c:	4b 98       	lddpc	r8,800068f0 <vTaskIncrementTick+0xe8>
8000680e:	70 08       	ld.w	r8,r8[0x0]
80006810:	58 08       	cp.w	r8,0
80006812:	c6 91       	brne	800068e4 <vTaskIncrementTick+0xdc>
	{
		++xTickCount;
80006814:	4b 88       	lddpc	r8,800068f4 <vTaskIncrementTick+0xec>
80006816:	70 09       	ld.w	r9,r8[0x0]
80006818:	2f f9       	sub	r9,-1
8000681a:	91 09       	st.w	r8[0x0],r9
		if( xTickCount == ( portTickType ) 0 )
8000681c:	70 08       	ld.w	r8,r8[0x0]
8000681e:	58 08       	cp.w	r8,0
80006820:	c1 a1       	brne	80006854 <vTaskIncrementTick+0x4c>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
80006822:	4b 68       	lddpc	r8,800068f8 <vTaskIncrementTick+0xf0>
80006824:	70 0a       	ld.w	r10,r8[0x0]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
80006826:	4b 69       	lddpc	r9,800068fc <vTaskIncrementTick+0xf4>
80006828:	72 0b       	ld.w	r11,r9[0x0]
8000682a:	91 0b       	st.w	r8[0x0],r11
			pxOverflowDelayedTaskList = pxTemp;
8000682c:	93 0a       	st.w	r9[0x0],r10
			xNumOfOverflows++;
8000682e:	4b 59       	lddpc	r9,80006900 <vTaskIncrementTick+0xf8>
80006830:	72 0a       	ld.w	r10,r9[0x0]
80006832:	2f fa       	sub	r10,-1
80006834:	93 0a       	st.w	r9[0x0],r10

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
80006836:	70 08       	ld.w	r8,r8[0x0]
80006838:	70 08       	ld.w	r8,r8[0x0]
8000683a:	58 08       	cp.w	r8,0
8000683c:	c0 51       	brne	80006846 <vTaskIncrementTick+0x3e>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
8000683e:	3f f9       	mov	r9,-1
80006840:	4b 18       	lddpc	r8,80006904 <vTaskIncrementTick+0xfc>
80006842:	91 09       	st.w	r8[0x0],r9
80006844:	c0 88       	rjmp	80006854 <vTaskIncrementTick+0x4c>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
80006846:	4a d8       	lddpc	r8,800068f8 <vTaskIncrementTick+0xf0>
80006848:	70 08       	ld.w	r8,r8[0x0]
8000684a:	70 38       	ld.w	r8,r8[0xc]
8000684c:	70 38       	ld.w	r8,r8[0xc]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
8000684e:	70 19       	ld.w	r9,r8[0x4]
80006850:	4a d8       	lddpc	r8,80006904 <vTaskIncrementTick+0xfc>
80006852:	91 09       	st.w	r8[0x0],r9
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
80006854:	4a 88       	lddpc	r8,800068f4 <vTaskIncrementTick+0xec>
80006856:	70 09       	ld.w	r9,r8[0x0]
80006858:	4a b8       	lddpc	r8,80006904 <vTaskIncrementTick+0xfc>
8000685a:	70 08       	ld.w	r8,r8[0x0]
8000685c:	10 39       	cp.w	r9,r8
8000685e:	c4 73       	brcs	800068ec <vTaskIncrementTick+0xe4>
80006860:	4a 68       	lddpc	r8,800068f8 <vTaskIncrementTick+0xf0>
80006862:	70 08       	ld.w	r8,r8[0x0]
80006864:	70 08       	ld.w	r8,r8[0x0]
80006866:	58 08       	cp.w	r8,0
80006868:	c0 c0       	breq	80006880 <vTaskIncrementTick+0x78>
8000686a:	4a 48       	lddpc	r8,800068f8 <vTaskIncrementTick+0xf0>
8000686c:	70 08       	ld.w	r8,r8[0x0]
8000686e:	70 38       	ld.w	r8,r8[0xc]
80006870:	70 37       	ld.w	r7,r8[0xc]
80006872:	6e 18       	ld.w	r8,r7[0x4]
80006874:	4a 09       	lddpc	r9,800068f4 <vTaskIncrementTick+0xec>
80006876:	72 09       	ld.w	r9,r9[0x0]
80006878:	12 38       	cp.w	r8,r9
8000687a:	e0 88 00 14 	brls	800068a2 <vTaskIncrementTick+0x9a>
8000687e:	c0 e8       	rjmp	8000689a <vTaskIncrementTick+0x92>
80006880:	3f f9       	mov	r9,-1
80006882:	4a 18       	lddpc	r8,80006904 <vTaskIncrementTick+0xfc>
80006884:	91 09       	st.w	r8[0x0],r9
80006886:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
8000688a:	6a 08       	ld.w	r8,r5[0x0]
8000688c:	70 38       	ld.w	r8,r8[0xc]
8000688e:	70 37       	ld.w	r7,r8[0xc]
80006890:	6e 18       	ld.w	r8,r7[0x4]
80006892:	64 09       	ld.w	r9,r2[0x0]
80006894:	12 38       	cp.w	r8,r9
80006896:	e0 88 00 0a 	brls	800068aa <vTaskIncrementTick+0xa2>
8000689a:	49 b9       	lddpc	r9,80006904 <vTaskIncrementTick+0xfc>
8000689c:	93 08       	st.w	r9[0x0],r8
8000689e:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
800068a2:	49 a4       	lddpc	r4,80006908 <vTaskIncrementTick+0x100>
800068a4:	49 a3       	lddpc	r3,8000690c <vTaskIncrementTick+0x104>
800068a6:	49 55       	lddpc	r5,800068f8 <vTaskIncrementTick+0xf0>
800068a8:	49 32       	lddpc	r2,800068f4 <vTaskIncrementTick+0xec>
800068aa:	ee c6 ff fc 	sub	r6,r7,-4
800068ae:	0c 9c       	mov	r12,r6
800068b0:	f0 1f 00 18 	mcall	80006910 <vTaskIncrementTick+0x108>
800068b4:	6e a8       	ld.w	r8,r7[0x28]
800068b6:	58 08       	cp.w	r8,0
800068b8:	c0 50       	breq	800068c2 <vTaskIncrementTick+0xba>
800068ba:	ee cc ff e8 	sub	r12,r7,-24
800068be:	f0 1f 00 15 	mcall	80006910 <vTaskIncrementTick+0x108>
800068c2:	6e bc       	ld.w	r12,r7[0x2c]
800068c4:	68 08       	ld.w	r8,r4[0x0]
800068c6:	10 3c       	cp.w	r12,r8
800068c8:	e9 fc ba 00 	st.whi	r4[0x0],r12
800068cc:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800068d0:	0c 9b       	mov	r11,r6
800068d2:	e6 0c 00 2c 	add	r12,r3,r12<<0x2
800068d6:	f0 1f 00 10 	mcall	80006914 <vTaskIncrementTick+0x10c>
800068da:	6a 08       	ld.w	r8,r5[0x0]
800068dc:	70 08       	ld.w	r8,r8[0x0]
800068de:	58 08       	cp.w	r8,0
800068e0:	cd 51       	brne	8000688a <vTaskIncrementTick+0x82>
800068e2:	cc fb       	rjmp	80006880 <vTaskIncrementTick+0x78>
	}
	else
	{
		++uxMissedTicks;
800068e4:	48 d8       	lddpc	r8,80006918 <vTaskIncrementTick+0x110>
800068e6:	70 09       	ld.w	r9,r8[0x0]
800068e8:	2f f9       	sub	r9,-1
800068ea:	91 09       	st.w	r8[0x0],r9
800068ec:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
800068f0:	00 00       	add	r0,r0
800068f2:	0d 20       	ld.uh	r0,r6++
800068f4:	00 00       	add	r0,r0
800068f6:	0d 1c       	ld.sh	r12,r6++
800068f8:	00 00       	add	r0,r0
800068fa:	0c 28       	rsub	r8,r6
800068fc:	00 00       	add	r0,r0
800068fe:	0c 38       	cp.w	r8,r6
80006900:	00 00       	add	r0,r0
80006902:	0c 34       	cp.w	r4,r6
80006904:	00 00       	add	r0,r0
80006906:	05 38       	ld.ub	r8,r2++
80006908:	00 00       	add	r0,r0
8000690a:	0d 58       	ld.sh	r8,--r6
8000690c:	00 00       	add	r0,r0
8000690e:	0c 3c       	cp.w	r12,r6
80006910:	80 00       	ld.sh	r0,r0[0x0]
80006912:	5d ae       	*unknown*
80006914:	80 00       	ld.sh	r0,r0[0x0]
80006916:	5d 5e       	*unknown*
80006918:	00 00       	add	r0,r0
8000691a:	0c 20       	rsub	r0,r6

8000691c <xTaskCheckForTimeOut>:
	pxTimeOut->xTimeOnEntering = xTickCount;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
8000691c:	eb cd 40 c0 	pushm	r6-r7,lr
80006920:	18 97       	mov	r7,r12
80006922:	16 96       	mov	r6,r11
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
80006924:	f0 1f 00 15 	mcall	80006978 <xTaskCheckForTimeOut+0x5c>
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
80006928:	6c 08       	ld.w	r8,r6[0x0]
8000692a:	5b f8       	cp.w	r8,-1
8000692c:	c0 31       	brne	80006932 <xTaskCheckForTimeOut+0x16>
8000692e:	30 07       	mov	r7,0
80006930:	c1 f8       	rjmp	8000696e <xTaskCheckForTimeOut+0x52>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
80006932:	49 39       	lddpc	r9,8000697c <xTaskCheckForTimeOut+0x60>
80006934:	72 09       	ld.w	r9,r9[0x0]
80006936:	6e 0a       	ld.w	r10,r7[0x0]
80006938:	12 3a       	cp.w	r10,r9
8000693a:	c0 70       	breq	80006948 <xTaskCheckForTimeOut+0x2c>
8000693c:	49 19       	lddpc	r9,80006980 <xTaskCheckForTimeOut+0x64>
8000693e:	72 09       	ld.w	r9,r9[0x0]
80006940:	6e 1a       	ld.w	r10,r7[0x4]
80006942:	12 3a       	cp.w	r10,r9
80006944:	e0 88 00 14 	brls	8000696c <xTaskCheckForTimeOut+0x50>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
80006948:	48 e9       	lddpc	r9,80006980 <xTaskCheckForTimeOut+0x64>
8000694a:	72 0a       	ld.w	r10,r9[0x0]
8000694c:	6e 19       	ld.w	r9,r7[0x4]
8000694e:	12 1a       	sub	r10,r9
80006950:	14 38       	cp.w	r8,r10
80006952:	e0 88 00 0d 	brls	8000696c <xTaskCheckForTimeOut+0x50>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
80006956:	48 ba       	lddpc	r10,80006980 <xTaskCheckForTimeOut+0x64>
80006958:	74 0a       	ld.w	r10,r10[0x0]
8000695a:	14 19       	sub	r9,r10
8000695c:	f2 08 00 08 	add	r8,r9,r8
80006960:	8d 08       	st.w	r6[0x0],r8
			vTaskSetTimeOutState( pxTimeOut );
80006962:	0e 9c       	mov	r12,r7
80006964:	f0 1f 00 08 	mcall	80006984 <xTaskCheckForTimeOut+0x68>
80006968:	30 07       	mov	r7,0
8000696a:	c0 28       	rjmp	8000696e <xTaskCheckForTimeOut+0x52>
8000696c:	30 17       	mov	r7,1
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
8000696e:	f0 1f 00 07 	mcall	80006988 <xTaskCheckForTimeOut+0x6c>

	return xReturn;
}
80006972:	0e 9c       	mov	r12,r7
80006974:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006978:	80 00       	ld.sh	r0,r0[0x0]
8000697a:	5e 68       	retmi	r8
8000697c:	00 00       	add	r0,r0
8000697e:	0c 34       	cp.w	r4,r6
80006980:	00 00       	add	r0,r0
80006982:	0d 1c       	ld.sh	r12,r6++
80006984:	80 00       	ld.sh	r0,r0[0x0]
80006986:	66 80       	ld.w	r0,r3[0x20]
80006988:	80 00       	ld.sh	r0,r0[0x0]
8000698a:	5f 74       	srpl	r4

8000698c <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
8000698c:	eb cd 40 80 	pushm	r7,lr
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
80006990:	f0 1f 00 05 	mcall	800069a4 <xTaskGetTickCount+0x18>
	{
		xTicks = xTickCount;
80006994:	48 58       	lddpc	r8,800069a8 <xTaskGetTickCount+0x1c>
80006996:	70 07       	ld.w	r7,r8[0x0]
	}
	taskEXIT_CRITICAL();
80006998:	f0 1f 00 05 	mcall	800069ac <xTaskGetTickCount+0x20>

	return xTicks;
}
8000699c:	0e 9c       	mov	r12,r7
8000699e:	e3 cd 80 80 	ldm	sp++,r7,pc
800069a2:	00 00       	add	r0,r0
800069a4:	80 00       	ld.sh	r0,r0[0x0]
800069a6:	5e 68       	retmi	r8
800069a8:	00 00       	add	r0,r0
800069aa:	0d 1c       	ld.sh	r12,r6++
800069ac:	80 00       	ld.sh	r0,r0[0x0]
800069ae:	5f 74       	srpl	r4

800069b0 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
800069b0:	eb cd 40 fe 	pushm	r1-r7,lr
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
800069b4:	f0 1f 00 2c 	mcall	80006a64 <xTaskResumeAll+0xb4>
	{
		--uxSchedulerSuspended;
800069b8:	4a c8       	lddpc	r8,80006a68 <xTaskResumeAll+0xb8>
800069ba:	70 09       	ld.w	r9,r8[0x0]
800069bc:	20 19       	sub	r9,1
800069be:	91 09       	st.w	r8[0x0],r9

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
800069c0:	70 08       	ld.w	r8,r8[0x0]
800069c2:	58 08       	cp.w	r8,0
800069c4:	c4 91       	brne	80006a56 <xTaskResumeAll+0xa6>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
800069c6:	4a a8       	lddpc	r8,80006a6c <xTaskResumeAll+0xbc>
800069c8:	70 08       	ld.w	r8,r8[0x0]
800069ca:	58 08       	cp.w	r8,0
800069cc:	c4 50       	breq	80006a56 <xTaskResumeAll+0xa6>
800069ce:	30 04       	mov	r4,0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
800069d0:	4a 85       	lddpc	r5,80006a70 <xTaskResumeAll+0xc0>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
800069d2:	4a 93       	lddpc	r3,80006a74 <xTaskResumeAll+0xc4>
800069d4:	4a 92       	lddpc	r2,80006a78 <xTaskResumeAll+0xc8>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
800069d6:	4a a1       	lddpc	r1,80006a7c <xTaskResumeAll+0xcc>
800069d8:	c1 e8       	rjmp	80006a14 <xTaskResumeAll+0x64>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
800069da:	6a 38       	ld.w	r8,r5[0xc]
800069dc:	70 37       	ld.w	r7,r8[0xc]
					vListRemove( &( pxTCB->xEventListItem ) );
800069de:	ee cc ff e8 	sub	r12,r7,-24
800069e2:	f0 1f 00 28 	mcall	80006a80 <xTaskResumeAll+0xd0>
					vListRemove( &( pxTCB->xGenericListItem ) );
800069e6:	ee c6 ff fc 	sub	r6,r7,-4
800069ea:	0c 9c       	mov	r12,r6
800069ec:	f0 1f 00 25 	mcall	80006a80 <xTaskResumeAll+0xd0>
					prvAddTaskToReadyQueue( pxTCB );
800069f0:	6e bc       	ld.w	r12,r7[0x2c]
800069f2:	66 08       	ld.w	r8,r3[0x0]
800069f4:	10 3c       	cp.w	r12,r8
800069f6:	e7 fc ba 00 	st.whi	r3[0x0],r12
800069fa:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800069fe:	0c 9b       	mov	r11,r6
80006a00:	e4 0c 00 2c 	add	r12,r2,r12<<0x2
80006a04:	f0 1f 00 20 	mcall	80006a84 <xTaskResumeAll+0xd4>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80006a08:	62 08       	ld.w	r8,r1[0x0]
80006a0a:	6e b9       	ld.w	r9,r7[0x2c]
80006a0c:	70 b8       	ld.w	r8,r8[0x2c]
80006a0e:	10 39       	cp.w	r9,r8
80006a10:	f9 b4 02 01 	movhs	r4,1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80006a14:	6a 08       	ld.w	r8,r5[0x0]
80006a16:	58 08       	cp.w	r8,0
80006a18:	ce 11       	brne	800069da <xTaskResumeAll+0x2a>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80006a1a:	49 c8       	lddpc	r8,80006a88 <xTaskResumeAll+0xd8>
80006a1c:	70 08       	ld.w	r8,r8[0x0]
80006a1e:	58 08       	cp.w	r8,0
80006a20:	c0 f0       	breq	80006a3e <xTaskResumeAll+0x8e>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80006a22:	49 a8       	lddpc	r8,80006a88 <xTaskResumeAll+0xd8>
80006a24:	70 08       	ld.w	r8,r8[0x0]
80006a26:	58 08       	cp.w	r8,0
80006a28:	c1 10       	breq	80006a4a <xTaskResumeAll+0x9a>
					{
						vTaskIncrementTick();
						--uxMissedTicks;
80006a2a:	49 87       	lddpc	r7,80006a88 <xTaskResumeAll+0xd8>
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
80006a2c:	f0 1f 00 18 	mcall	80006a8c <xTaskResumeAll+0xdc>
						--uxMissedTicks;
80006a30:	6e 08       	ld.w	r8,r7[0x0]
80006a32:	20 18       	sub	r8,1
80006a34:	8f 08       	st.w	r7[0x0],r8
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80006a36:	6e 08       	ld.w	r8,r7[0x0]
80006a38:	58 08       	cp.w	r8,0
80006a3a:	cf 91       	brne	80006a2c <xTaskResumeAll+0x7c>
80006a3c:	c0 78       	rjmp	80006a4a <xTaskResumeAll+0x9a>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
80006a3e:	58 14       	cp.w	r4,1
80006a40:	c0 50       	breq	80006a4a <xTaskResumeAll+0x9a>
80006a42:	49 48       	lddpc	r8,80006a90 <xTaskResumeAll+0xe0>
80006a44:	70 08       	ld.w	r8,r8[0x0]
80006a46:	58 18       	cp.w	r8,1
80006a48:	c0 71       	brne	80006a56 <xTaskResumeAll+0xa6>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
80006a4a:	30 09       	mov	r9,0
80006a4c:	49 18       	lddpc	r8,80006a90 <xTaskResumeAll+0xe0>
80006a4e:	91 09       	st.w	r8[0x0],r9
					portYIELD_WITHIN_API();
80006a50:	d7 33       	scall
80006a52:	30 17       	mov	r7,1
80006a54:	c0 28       	rjmp	80006a58 <xTaskResumeAll+0xa8>
80006a56:	30 07       	mov	r7,0
				}
			}
		}
	}
	taskEXIT_CRITICAL();
80006a58:	f0 1f 00 0f 	mcall	80006a94 <xTaskResumeAll+0xe4>

	return xAlreadyYielded;
}
80006a5c:	0e 9c       	mov	r12,r7
80006a5e:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
80006a62:	00 00       	add	r0,r0
80006a64:	80 00       	ld.sh	r0,r0[0x0]
80006a66:	5e 68       	retmi	r8
80006a68:	00 00       	add	r0,r0
80006a6a:	0d 20       	ld.uh	r0,r6++
80006a6c:	00 00       	add	r0,r0
80006a6e:	0d 3c       	ld.ub	r12,r6++
80006a70:	00 00       	add	r0,r0
80006a72:	0c f4       	st.b	--r6,r4
80006a74:	00 00       	add	r0,r0
80006a76:	0d 58       	ld.sh	r8,--r6
80006a78:	00 00       	add	r0,r0
80006a7a:	0c 3c       	cp.w	r12,r6
80006a7c:	00 00       	add	r0,r0
80006a7e:	0c f0       	st.b	--r6,r0
80006a80:	80 00       	ld.sh	r0,r0[0x0]
80006a82:	5d ae       	*unknown*
80006a84:	80 00       	ld.sh	r0,r0[0x0]
80006a86:	5d 5e       	*unknown*
80006a88:	00 00       	add	r0,r0
80006a8a:	0c 20       	rsub	r0,r6
80006a8c:	80 00       	ld.sh	r0,r0[0x0]
80006a8e:	68 08       	ld.w	r8,r4[0x0]
80006a90:	00 00       	add	r0,r0
80006a92:	0d 40       	ld.w	r0,--r6
80006a94:	80 00       	ld.sh	r0,r0[0x0]
80006a96:	5f 74       	srpl	r4

80006a98 <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
80006a98:	eb cd 40 80 	pushm	r7,lr
80006a9c:	18 97       	mov	r7,r12
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
80006a9e:	49 08       	lddpc	r8,80006adc <prvAddCurrentTaskToDelayedList+0x44>
80006aa0:	70 08       	ld.w	r8,r8[0x0]
80006aa2:	91 1c       	st.w	r8[0x4],r12

	if( xTimeToWake < xTickCount )
80006aa4:	48 f8       	lddpc	r8,80006ae0 <prvAddCurrentTaskToDelayedList+0x48>
80006aa6:	70 08       	ld.w	r8,r8[0x0]
80006aa8:	10 3c       	cp.w	r12,r8
80006aaa:	c0 a2       	brcc	80006abe <prvAddCurrentTaskToDelayedList+0x26>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006aac:	48 c8       	lddpc	r8,80006adc <prvAddCurrentTaskToDelayedList+0x44>
80006aae:	70 0b       	ld.w	r11,r8[0x0]
80006ab0:	48 d8       	lddpc	r8,80006ae4 <prvAddCurrentTaskToDelayedList+0x4c>
80006ab2:	70 0c       	ld.w	r12,r8[0x0]
80006ab4:	2f cb       	sub	r11,-4
80006ab6:	f0 1f 00 0d 	mcall	80006ae8 <prvAddCurrentTaskToDelayedList+0x50>
80006aba:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006abe:	48 88       	lddpc	r8,80006adc <prvAddCurrentTaskToDelayedList+0x44>
80006ac0:	70 0b       	ld.w	r11,r8[0x0]
80006ac2:	48 b8       	lddpc	r8,80006aec <prvAddCurrentTaskToDelayedList+0x54>
80006ac4:	70 0c       	ld.w	r12,r8[0x0]
80006ac6:	2f cb       	sub	r11,-4
80006ac8:	f0 1f 00 08 	mcall	80006ae8 <prvAddCurrentTaskToDelayedList+0x50>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
80006acc:	48 98       	lddpc	r8,80006af0 <prvAddCurrentTaskToDelayedList+0x58>
80006ace:	70 08       	ld.w	r8,r8[0x0]
80006ad0:	10 37       	cp.w	r7,r8
80006ad2:	c0 32       	brcc	80006ad8 <prvAddCurrentTaskToDelayedList+0x40>
		{
			xNextTaskUnblockTime = xTimeToWake;
80006ad4:	48 78       	lddpc	r8,80006af0 <prvAddCurrentTaskToDelayedList+0x58>
80006ad6:	91 07       	st.w	r8[0x0],r7
80006ad8:	e3 cd 80 80 	ldm	sp++,r7,pc
80006adc:	00 00       	add	r0,r0
80006ade:	0c f0       	st.b	--r6,r0
80006ae0:	00 00       	add	r0,r0
80006ae2:	0d 1c       	ld.sh	r12,r6++
80006ae4:	00 00       	add	r0,r0
80006ae6:	0c 38       	cp.w	r8,r6
80006ae8:	80 00       	ld.sh	r0,r0[0x0]
80006aea:	5d 7a       	*unknown*
80006aec:	00 00       	add	r0,r0
80006aee:	0c 28       	rsub	r8,r6
80006af0:	00 00       	add	r0,r0
80006af2:	05 38       	ld.ub	r8,r2++

80006af4 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
80006af4:	eb cd 40 c0 	pushm	r6-r7,lr
80006af8:	18 97       	mov	r7,r12
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0 )
80006afa:	58 0c       	cp.w	r12,0
80006afc:	c1 10       	breq	80006b1e <vTaskDelay+0x2a>
		{
			vTaskSuspendAll();
80006afe:	f0 1f 00 0a 	mcall	80006b24 <vTaskDelay+0x30>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
80006b02:	48 a8       	lddpc	r8,80006b28 <vTaskDelay+0x34>
80006b04:	70 06       	ld.w	r6,r8[0x0]

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006b06:	48 a8       	lddpc	r8,80006b2c <vTaskDelay+0x38>
80006b08:	70 0c       	ld.w	r12,r8[0x0]
80006b0a:	2f cc       	sub	r12,-4
80006b0c:	f0 1f 00 09 	mcall	80006b30 <vTaskDelay+0x3c>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
80006b10:	ee 06 00 0c 	add	r12,r7,r6
80006b14:	f0 1f 00 08 	mcall	80006b34 <vTaskDelay+0x40>
			}
			xAlreadyYielded = xTaskResumeAll();
80006b18:	f0 1f 00 08 	mcall	80006b38 <vTaskDelay+0x44>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
80006b1c:	c0 21       	brne	80006b20 <vTaskDelay+0x2c>
		{
			portYIELD_WITHIN_API();
80006b1e:	d7 33       	scall
80006b20:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006b24:	80 00       	ld.sh	r0,r0[0x0]
80006b26:	65 f4       	ld.w	r4,r2[0x7c]
80006b28:	00 00       	add	r0,r0
80006b2a:	0d 1c       	ld.sh	r12,r6++
80006b2c:	00 00       	add	r0,r0
80006b2e:	0c f0       	st.b	--r6,r0
80006b30:	80 00       	ld.sh	r0,r0[0x0]
80006b32:	5d ae       	*unknown*
80006b34:	80 00       	ld.sh	r0,r0[0x0]
80006b36:	6a 98       	ld.w	r8,r5[0x24]
80006b38:	80 00       	ld.sh	r0,r0[0x0]
80006b3a:	69 b0       	ld.w	r0,r4[0x6c]

80006b3c <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
80006b3c:	eb cd 40 c0 	pushm	r6-r7,lr
80006b40:	18 96       	mov	r6,r12
80006b42:	16 97       	mov	r7,r11
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0 ) );

		vTaskSuspendAll();
80006b44:	f0 1f 00 18 	mcall	80006ba4 <vTaskDelayUntil+0x68>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
80006b48:	6c 08       	ld.w	r8,r6[0x0]
80006b4a:	10 07       	add	r7,r8

			if( xTickCount < *pxPreviousWakeTime )
80006b4c:	49 79       	lddpc	r9,80006ba8 <vTaskDelayUntil+0x6c>
80006b4e:	72 09       	ld.w	r9,r9[0x0]
80006b50:	12 38       	cp.w	r8,r9
80006b52:	e0 88 00 0c 	brls	80006b6a <vTaskDelayUntil+0x2e>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
80006b56:	0e 38       	cp.w	r8,r7
80006b58:	e0 88 00 22 	brls	80006b9c <vTaskDelayUntil+0x60>
80006b5c:	49 38       	lddpc	r8,80006ba8 <vTaskDelayUntil+0x6c>
80006b5e:	70 08       	ld.w	r8,r8[0x0]
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80006b60:	8d 07       	st.w	r6[0x0],r7

			if( xShouldDelay != pdFALSE )
80006b62:	10 37       	cp.w	r7,r8
80006b64:	e0 88 00 14 	brls	80006b8c <vTaskDelayUntil+0x50>
80006b68:	c0 a8       	rjmp	80006b7c <vTaskDelayUntil+0x40>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
80006b6a:	0e 38       	cp.w	r8,r7
80006b6c:	e0 8b 00 16 	brhi	80006b98 <vTaskDelayUntil+0x5c>
80006b70:	48 e8       	lddpc	r8,80006ba8 <vTaskDelayUntil+0x6c>
80006b72:	70 08       	ld.w	r8,r8[0x0]
80006b74:	10 37       	cp.w	r7,r8
80006b76:	e0 8b 00 11 	brhi	80006b98 <vTaskDelayUntil+0x5c>
80006b7a:	c1 18       	rjmp	80006b9c <vTaskDelayUntil+0x60>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006b7c:	48 c8       	lddpc	r8,80006bac <vTaskDelayUntil+0x70>
80006b7e:	70 0c       	ld.w	r12,r8[0x0]
80006b80:	2f cc       	sub	r12,-4
80006b82:	f0 1f 00 0c 	mcall	80006bb0 <vTaskDelayUntil+0x74>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
80006b86:	0e 9c       	mov	r12,r7
80006b88:	f0 1f 00 0b 	mcall	80006bb4 <vTaskDelayUntil+0x78>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
80006b8c:	f0 1f 00 0b 	mcall	80006bb8 <vTaskDelayUntil+0x7c>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
80006b90:	c0 81       	brne	80006ba0 <vTaskDelayUntil+0x64>
		{
			portYIELD_WITHIN_API();
80006b92:	d7 33       	scall
80006b94:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80006b98:	8d 07       	st.w	r6[0x0],r7
80006b9a:	cf 1b       	rjmp	80006b7c <vTaskDelayUntil+0x40>
80006b9c:	8d 07       	st.w	r6[0x0],r7
80006b9e:	cf 7b       	rjmp	80006b8c <vTaskDelayUntil+0x50>
80006ba0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006ba4:	80 00       	ld.sh	r0,r0[0x0]
80006ba6:	65 f4       	ld.w	r4,r2[0x7c]
80006ba8:	00 00       	add	r0,r0
80006baa:	0d 1c       	ld.sh	r12,r6++
80006bac:	00 00       	add	r0,r0
80006bae:	0c f0       	st.b	--r6,r0
80006bb0:	80 00       	ld.sh	r0,r0[0x0]
80006bb2:	5d ae       	*unknown*
80006bb4:	80 00       	ld.sh	r0,r0[0x0]
80006bb6:	6a 98       	ld.w	r8,r5[0x24]
80006bb8:	80 00       	ld.sh	r0,r0[0x0]
80006bba:	69 b0       	ld.w	r0,r4[0x6c]

80006bbc <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
80006bbc:	eb cd 40 c0 	pushm	r6-r7,lr
80006bc0:	16 96       	mov	r6,r11
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
80006bc2:	48 e7       	lddpc	r7,80006bf8 <vTaskPlaceOnEventList+0x3c>
80006bc4:	6e 0b       	ld.w	r11,r7[0x0]
80006bc6:	2e 8b       	sub	r11,-24
80006bc8:	f0 1f 00 0d 	mcall	80006bfc <vTaskPlaceOnEventList+0x40>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006bcc:	6e 0c       	ld.w	r12,r7[0x0]
80006bce:	2f cc       	sub	r12,-4
80006bd0:	f0 1f 00 0c 	mcall	80006c00 <vTaskPlaceOnEventList+0x44>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
80006bd4:	5b f6       	cp.w	r6,-1
80006bd6:	c0 81       	brne	80006be6 <vTaskPlaceOnEventList+0x2a>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006bd8:	6e 0b       	ld.w	r11,r7[0x0]
80006bda:	2f cb       	sub	r11,-4
80006bdc:	48 ac       	lddpc	r12,80006c04 <vTaskPlaceOnEventList+0x48>
80006bde:	f0 1f 00 0b 	mcall	80006c08 <vTaskPlaceOnEventList+0x4c>
80006be2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
80006be6:	48 a8       	lddpc	r8,80006c0c <vTaskPlaceOnEventList+0x50>
80006be8:	70 0c       	ld.w	r12,r8[0x0]
			prvAddCurrentTaskToDelayedList( xTimeToWake );
80006bea:	ec 0c 00 0c 	add	r12,r6,r12
80006bee:	f0 1f 00 09 	mcall	80006c10 <vTaskPlaceOnEventList+0x54>
80006bf2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006bf6:	00 00       	add	r0,r0
80006bf8:	00 00       	add	r0,r0
80006bfa:	0c f0       	st.b	--r6,r0
80006bfc:	80 00       	ld.sh	r0,r0[0x0]
80006bfe:	5d 7a       	*unknown*
80006c00:	80 00       	ld.sh	r0,r0[0x0]
80006c02:	5d ae       	*unknown*
80006c04:	00 00       	add	r0,r0
80006c06:	0d 44       	ld.w	r4,--r6
80006c08:	80 00       	ld.sh	r0,r0[0x0]
80006c0a:	5d 5e       	*unknown*
80006c0c:	00 00       	add	r0,r0
80006c0e:	0d 1c       	ld.sh	r12,r6++
80006c10:	80 00       	ld.sh	r0,r0[0x0]
80006c12:	6a 98       	ld.w	r8,r5[0x24]

80006c14 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
80006c14:	eb cd 40 f8 	pushm	r3-r7,lr
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80006c18:	49 67       	lddpc	r7,80006c70 <prvIdleTask+0x5c>
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
80006c1a:	49 74       	lddpc	r4,80006c74 <prvIdleTask+0x60>

				taskENTER_CRITICAL();
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					--uxCurrentNumberOfTasks;
80006c1c:	49 73       	lddpc	r3,80006c78 <prvIdleTask+0x64>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80006c1e:	49 85       	lddpc	r5,80006c7c <prvIdleTask+0x68>
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80006c20:	6e 08       	ld.w	r8,r7[0x0]
80006c22:	58 08       	cp.w	r8,0
80006c24:	c1 e0       	breq	80006c60 <prvIdleTask+0x4c>
		{
			vTaskSuspendAll();
80006c26:	f0 1f 00 17 	mcall	80006c80 <prvIdleTask+0x6c>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
80006c2a:	68 06       	ld.w	r6,r4[0x0]
			xTaskResumeAll();
80006c2c:	f0 1f 00 16 	mcall	80006c84 <prvIdleTask+0x70>

			if( xListIsEmpty == pdFALSE )
80006c30:	58 06       	cp.w	r6,0
80006c32:	c1 70       	breq	80006c60 <prvIdleTask+0x4c>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
80006c34:	f0 1f 00 15 	mcall	80006c88 <prvIdleTask+0x74>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
80006c38:	68 38       	ld.w	r8,r4[0xc]
80006c3a:	70 36       	ld.w	r6,r8[0xc]
					vListRemove( &( pxTCB->xGenericListItem ) );
80006c3c:	ec cc ff fc 	sub	r12,r6,-4
80006c40:	f0 1f 00 13 	mcall	80006c8c <prvIdleTask+0x78>
					--uxCurrentNumberOfTasks;
80006c44:	66 08       	ld.w	r8,r3[0x0]
80006c46:	20 18       	sub	r8,1
80006c48:	87 08       	st.w	r3[0x0],r8
					--uxTasksDeleted;
80006c4a:	6e 08       	ld.w	r8,r7[0x0]
80006c4c:	20 18       	sub	r8,1
80006c4e:	8f 08       	st.w	r7[0x0],r8
				}
				taskEXIT_CRITICAL();
80006c50:	f0 1f 00 10 	mcall	80006c90 <prvIdleTask+0x7c>

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
80006c54:	6c cc       	ld.w	r12,r6[0x30]
80006c56:	f0 1f 00 10 	mcall	80006c94 <prvIdleTask+0x80>
		vPortFree( pxTCB );
80006c5a:	0c 9c       	mov	r12,r6
80006c5c:	f0 1f 00 0e 	mcall	80006c94 <prvIdleTask+0x80>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80006c60:	6a 08       	ld.w	r8,r5[0x0]
80006c62:	58 18       	cp.w	r8,1
80006c64:	e0 88 00 03 	brls	80006c6a <prvIdleTask+0x56>
			{
				taskYIELD();
80006c68:	d7 33       	scall
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
80006c6a:	f0 1f 00 0c 	mcall	80006c98 <prvIdleTask+0x84>
		}
		#endif
	}
80006c6e:	cd 9b       	rjmp	80006c20 <prvIdleTask+0xc>
80006c70:	00 00       	add	r0,r0
80006c72:	0c 30       	cp.w	r0,r6
80006c74:	00 00       	add	r0,r0
80006c76:	0c dc       	st.w	--r6,r12
80006c78:	00 00       	add	r0,r0
80006c7a:	0d 3c       	ld.ub	r12,r6++
80006c7c:	00 00       	add	r0,r0
80006c7e:	0c 3c       	cp.w	r12,r6
80006c80:	80 00       	ld.sh	r0,r0[0x0]
80006c82:	65 f4       	ld.w	r4,r2[0x7c]
80006c84:	80 00       	ld.sh	r0,r0[0x0]
80006c86:	69 b0       	ld.w	r0,r4[0x6c]
80006c88:	80 00       	ld.sh	r0,r0[0x0]
80006c8a:	5e 68       	retmi	r8
80006c8c:	80 00       	ld.sh	r0,r0[0x0]
80006c8e:	5d ae       	*unknown*
80006c90:	80 00       	ld.sh	r0,r0[0x0]
80006c92:	5f 74       	srpl	r4
80006c94:	80 00       	ld.sh	r0,r0[0x0]
80006c96:	60 ac       	ld.w	r12,r0[0x28]
80006c98:	80 00       	ld.sh	r0,r0[0x0]
80006c9a:	20 48       	sub	r8,4

80006c9c <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
80006c9c:	d4 31       	pushm	r0-r7,lr
80006c9e:	20 1d       	sub	sp,4
80006ca0:	fa c4 ff d8 	sub	r4,sp,-40
80006ca4:	50 0c       	stdsp	sp[0x0],r12
80006ca6:	16 91       	mov	r1,r11
80006ca8:	14 97       	mov	r7,r10
80006caa:	12 90       	mov	r0,r9
80006cac:	10 93       	mov	r3,r8
80006cae:	68 02       	ld.w	r2,r4[0x0]
80006cb0:	68 16       	ld.w	r6,r4[0x4]
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
80006cb2:	34 8c       	mov	r12,72
80006cb4:	f0 1f 00 5c 	mcall	80006e24 <xTaskGenericCreate+0x188>
80006cb8:	18 95       	mov	r5,r12

	if( pxNewTCB != NULL )
80006cba:	c0 31       	brne	80006cc0 <xTaskGenericCreate+0x24>
80006cbc:	3f fc       	mov	r12,-1
80006cbe:	ca f8       	rjmp	80006e1c <xTaskGenericCreate+0x180>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80006cc0:	58 06       	cp.w	r6,0
80006cc2:	e0 81 00 af 	brne	80006e20 <xTaskGenericCreate+0x184>
80006cc6:	0e 9c       	mov	r12,r7
80006cc8:	5c 7c       	castu.h	r12
80006cca:	a3 6c       	lsl	r12,0x2
80006ccc:	f0 1f 00 56 	mcall	80006e24 <xTaskGenericCreate+0x188>
80006cd0:	18 96       	mov	r6,r12
80006cd2:	8b cc       	st.w	r5[0x30],r12

		if( pxNewTCB->pxStack == NULL )
80006cd4:	c0 61       	brne	80006ce0 <xTaskGenericCreate+0x44>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
80006cd6:	0a 9c       	mov	r12,r5
80006cd8:	f0 1f 00 54 	mcall	80006e28 <xTaskGenericCreate+0x18c>
80006cdc:	3f fc       	mov	r12,-1
80006cde:	c9 f8       	rjmp	80006e1c <xTaskGenericCreate+0x180>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
80006ce0:	5c 77       	castu.h	r7
80006ce2:	ee 0a 15 02 	lsl	r10,r7,0x2
80006ce6:	e0 6b 00 a5 	mov	r11,165
80006cea:	0c 9c       	mov	r12,r6
80006cec:	f0 1f 00 50 	mcall	80006e2c <xTaskGenericCreate+0x190>
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~portBYTE_ALIGNMENT_MASK  ) );
80006cf0:	ee c6 00 01 	sub	r6,r7,1
80006cf4:	6a c8       	ld.w	r8,r5[0x30]
80006cf6:	f0 06 00 26 	add	r6,r8,r6<<0x2
80006cfa:	e0 16 ff fc 	andl	r6,0xfffc
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
80006cfe:	31 0a       	mov	r10,16
80006d00:	02 9b       	mov	r11,r1
80006d02:	ea cc ff cc 	sub	r12,r5,-52
80006d06:	f0 1f 00 4b 	mcall	80006e30 <xTaskGenericCreate+0x194>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
80006d0a:	30 08       	mov	r8,0
80006d0c:	eb 68 00 43 	st.b	r5[67],r8
80006d10:	58 73       	cp.w	r3,7
80006d12:	e6 07 17 80 	movls	r7,r3
80006d16:	f9 b7 0b 07 	movhi	r7,7
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
80006d1a:	8b b7       	st.w	r5[0x2c],r7
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
80006d1c:	eb 47 00 44 	st.w	r5[68],r7
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
80006d20:	ea c4 ff fc 	sub	r4,r5,-4
80006d24:	08 9c       	mov	r12,r4
80006d26:	f0 1f 00 44 	mcall	80006e34 <xTaskGenericCreate+0x198>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
80006d2a:	ea cc ff e8 	sub	r12,r5,-24
80006d2e:	f0 1f 00 42 	mcall	80006e34 <xTaskGenericCreate+0x198>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
80006d32:	8b 45       	st.w	r5[0x10],r5

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
80006d34:	ee 07 11 08 	rsub	r7,r7,8
80006d38:	8b 67       	st.w	r5[0x18],r7
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
80006d3a:	8b 95       	st.w	r5[0x24],r5
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
80006d3c:	00 9a       	mov	r10,r0
80006d3e:	40 0b       	lddsp	r11,sp[0x0]
80006d40:	0c 9c       	mov	r12,r6
80006d42:	f0 1f 00 3e 	mcall	80006e38 <xTaskGenericCreate+0x19c>
80006d46:	8b 0c       	st.w	r5[0x0],r12
		if( ( void * ) pxCreatedTask != NULL )
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
80006d48:	58 02       	cp.w	r2,0
80006d4a:	e5 f5 1a 00 	st.wne	r2[0x0],r5
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
80006d4e:	f0 1f 00 3c 	mcall	80006e3c <xTaskGenericCreate+0x1a0>
		{
			uxCurrentNumberOfTasks++;
80006d52:	4b c8       	lddpc	r8,80006e40 <xTaskGenericCreate+0x1a4>
80006d54:	70 09       	ld.w	r9,r8[0x0]
80006d56:	2f f9       	sub	r9,-1
80006d58:	91 09       	st.w	r8[0x0],r9
			if( pxCurrentTCB == NULL )
80006d5a:	4b b8       	lddpc	r8,80006e44 <xTaskGenericCreate+0x1a8>
80006d5c:	70 08       	ld.w	r8,r8[0x0]
80006d5e:	58 08       	cp.w	r8,0
80006d60:	c2 61       	brne	80006dac <xTaskGenericCreate+0x110>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
80006d62:	4b 98       	lddpc	r8,80006e44 <xTaskGenericCreate+0x1a8>
80006d64:	91 05       	st.w	r8[0x0],r5

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
80006d66:	4b 78       	lddpc	r8,80006e40 <xTaskGenericCreate+0x1a4>
80006d68:	70 08       	ld.w	r8,r8[0x0]
80006d6a:	58 18       	cp.w	r8,1
80006d6c:	c2 b1       	brne	80006dc2 <xTaskGenericCreate+0x126>
80006d6e:	4b 77       	lddpc	r7,80006e48 <xTaskGenericCreate+0x1ac>

/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
80006d70:	ee c6 ff 60 	sub	r6,r7,-160
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
80006d74:	0e 9c       	mov	r12,r7
80006d76:	f0 1f 00 36 	mcall	80006e4c <xTaskGenericCreate+0x1b0>
80006d7a:	2e c7       	sub	r7,-20

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
80006d7c:	0c 37       	cp.w	r7,r6
80006d7e:	cf b1       	brne	80006d74 <xTaskGenericCreate+0xd8>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
80006d80:	4b 47       	lddpc	r7,80006e50 <xTaskGenericCreate+0x1b4>
80006d82:	0e 9c       	mov	r12,r7
80006d84:	f0 1f 00 32 	mcall	80006e4c <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
80006d88:	4b 36       	lddpc	r6,80006e54 <xTaskGenericCreate+0x1b8>
80006d8a:	0c 9c       	mov	r12,r6
80006d8c:	f0 1f 00 30 	mcall	80006e4c <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xPendingReadyList );
80006d90:	4b 2c       	lddpc	r12,80006e58 <xTaskGenericCreate+0x1bc>
80006d92:	f0 1f 00 2f 	mcall	80006e4c <xTaskGenericCreate+0x1b0>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
80006d96:	4b 2c       	lddpc	r12,80006e5c <xTaskGenericCreate+0x1c0>
80006d98:	f0 1f 00 2d 	mcall	80006e4c <xTaskGenericCreate+0x1b0>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
80006d9c:	4b 1c       	lddpc	r12,80006e60 <xTaskGenericCreate+0x1c4>
80006d9e:	f0 1f 00 2c 	mcall	80006e4c <xTaskGenericCreate+0x1b0>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
80006da2:	4b 18       	lddpc	r8,80006e64 <xTaskGenericCreate+0x1c8>
80006da4:	91 07       	st.w	r8[0x0],r7
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
80006da6:	4b 18       	lddpc	r8,80006e68 <xTaskGenericCreate+0x1cc>
80006da8:	91 06       	st.w	r8[0x0],r6
80006daa:	c0 c8       	rjmp	80006dc2 <xTaskGenericCreate+0x126>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
80006dac:	4b 08       	lddpc	r8,80006e6c <xTaskGenericCreate+0x1d0>
80006dae:	70 08       	ld.w	r8,r8[0x0]
80006db0:	58 08       	cp.w	r8,0
80006db2:	c0 81       	brne	80006dc2 <xTaskGenericCreate+0x126>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
80006db4:	4a 48       	lddpc	r8,80006e44 <xTaskGenericCreate+0x1a8>
80006db6:	70 08       	ld.w	r8,r8[0x0]
80006db8:	70 b8       	ld.w	r8,r8[0x2c]
80006dba:	10 33       	cp.w	r3,r8
80006dbc:	c0 33       	brcs	80006dc2 <xTaskGenericCreate+0x126>
					{
						pxCurrentTCB = pxNewTCB;
80006dbe:	4a 28       	lddpc	r8,80006e44 <xTaskGenericCreate+0x1a8>
80006dc0:	91 05       	st.w	r8[0x0],r5
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
80006dc2:	6a b8       	ld.w	r8,r5[0x2c]
80006dc4:	4a b9       	lddpc	r9,80006e70 <xTaskGenericCreate+0x1d4>
80006dc6:	72 09       	ld.w	r9,r9[0x0]
80006dc8:	12 38       	cp.w	r8,r9
80006dca:	e0 88 00 04 	brls	80006dd2 <xTaskGenericCreate+0x136>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
80006dce:	4a 99       	lddpc	r9,80006e70 <xTaskGenericCreate+0x1d4>
80006dd0:	93 08       	st.w	r9[0x0],r8
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
80006dd2:	4a 98       	lddpc	r8,80006e74 <xTaskGenericCreate+0x1d8>
80006dd4:	70 09       	ld.w	r9,r8[0x0]
80006dd6:	2f f9       	sub	r9,-1
80006dd8:	91 09       	st.w	r8[0x0],r9

			prvAddTaskToReadyQueue( pxNewTCB );
80006dda:	6a b8       	ld.w	r8,r5[0x2c]
80006ddc:	4a 79       	lddpc	r9,80006e78 <xTaskGenericCreate+0x1dc>
80006dde:	72 09       	ld.w	r9,r9[0x0]
80006de0:	12 38       	cp.w	r8,r9
80006de2:	e0 88 00 04 	brls	80006dea <xTaskGenericCreate+0x14e>
80006de6:	4a 59       	lddpc	r9,80006e78 <xTaskGenericCreate+0x1dc>
80006de8:	93 08       	st.w	r9[0x0],r8
80006dea:	6a bc       	ld.w	r12,r5[0x2c]
80006dec:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006df0:	08 9b       	mov	r11,r4
80006df2:	49 68       	lddpc	r8,80006e48 <xTaskGenericCreate+0x1ac>
80006df4:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80006df8:	f0 1f 00 21 	mcall	80006e7c <xTaskGenericCreate+0x1e0>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
80006dfc:	f0 1f 00 21 	mcall	80006e80 <xTaskGenericCreate+0x1e4>
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
80006e00:	49 b8       	lddpc	r8,80006e6c <xTaskGenericCreate+0x1d0>
80006e02:	70 08       	ld.w	r8,r8[0x0]
80006e04:	58 08       	cp.w	r8,0
80006e06:	c0 a0       	breq	80006e1a <xTaskGenericCreate+0x17e>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
80006e08:	48 f8       	lddpc	r8,80006e44 <xTaskGenericCreate+0x1a8>
80006e0a:	70 08       	ld.w	r8,r8[0x0]
80006e0c:	70 b8       	ld.w	r8,r8[0x2c]
80006e0e:	10 33       	cp.w	r3,r8
80006e10:	e0 88 00 05 	brls	80006e1a <xTaskGenericCreate+0x17e>
			{
				portYIELD_WITHIN_API();
80006e14:	d7 33       	scall
80006e16:	30 1c       	mov	r12,1
80006e18:	c0 28       	rjmp	80006e1c <xTaskGenericCreate+0x180>
80006e1a:	30 1c       	mov	r12,1
			}
		}
	}

	return xReturn;
}
80006e1c:	2f fd       	sub	sp,-4
80006e1e:	d8 32       	popm	r0-r7,pc
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80006e20:	99 c6       	st.w	r12[0x30],r6
80006e22:	c5 fb       	rjmp	80006ce0 <xTaskGenericCreate+0x44>
80006e24:	80 00       	ld.sh	r0,r0[0x0]
80006e26:	60 d4       	ld.w	r4,r0[0x34]
80006e28:	80 00       	ld.sh	r0,r0[0x0]
80006e2a:	60 ac       	ld.w	r12,r0[0x28]
80006e2c:	80 00       	ld.sh	r0,r0[0x0]
80006e2e:	7a 24       	ld.w	r4,sp[0x8]
80006e30:	80 00       	ld.sh	r0,r0[0x0]
80006e32:	7d 50       	ld.w	r0,lr[0x54]
80006e34:	80 00       	ld.sh	r0,r0[0x0]
80006e36:	5d 58       	*unknown*
80006e38:	80 00       	ld.sh	r0,r0[0x0]
80006e3a:	5d d4       	*unknown*
80006e3c:	80 00       	ld.sh	r0,r0[0x0]
80006e3e:	5e 68       	retmi	r8
80006e40:	00 00       	add	r0,r0
80006e42:	0d 3c       	ld.ub	r12,r6++
80006e44:	00 00       	add	r0,r0
80006e46:	0c f0       	st.b	--r6,r0
80006e48:	00 00       	add	r0,r0
80006e4a:	0c 3c       	cp.w	r12,r6
80006e4c:	80 00       	ld.sh	r0,r0[0x0]
80006e4e:	5d 44       	*unknown*
80006e50:	00 00       	add	r0,r0
80006e52:	0d 08       	ld.w	r8,r6++
80006e54:	00 00       	add	r0,r0
80006e56:	0d 24       	ld.uh	r4,r6++
80006e58:	00 00       	add	r0,r0
80006e5a:	0c f4       	st.b	--r6,r4
80006e5c:	00 00       	add	r0,r0
80006e5e:	0c dc       	st.w	--r6,r12
80006e60:	00 00       	add	r0,r0
80006e62:	0d 44       	ld.w	r4,--r6
80006e64:	00 00       	add	r0,r0
80006e66:	0c 28       	rsub	r8,r6
80006e68:	00 00       	add	r0,r0
80006e6a:	0c 38       	cp.w	r8,r6
80006e6c:	00 00       	add	r0,r0
80006e6e:	0c 2c       	rsub	r12,r6
80006e70:	00 00       	add	r0,r0
80006e72:	0c 24       	rsub	r4,r6
80006e74:	00 00       	add	r0,r0
80006e76:	0d 38       	ld.ub	r8,r6++
80006e78:	00 00       	add	r0,r0
80006e7a:	0d 58       	ld.sh	r8,--r6
80006e7c:	80 00       	ld.sh	r0,r0[0x0]
80006e7e:	5d 5e       	*unknown*
80006e80:	80 00       	ld.sh	r0,r0[0x0]
80006e82:	5f 74       	srpl	r4

80006e84 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
80006e84:	d4 01       	pushm	lr
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
80006e86:	30 09       	mov	r9,0
80006e88:	1a d9       	st.w	--sp,r9
80006e8a:	1a d9       	st.w	--sp,r9
80006e8c:	1a d9       	st.w	--sp,r9
80006e8e:	12 98       	mov	r8,r9
80006e90:	e0 6a 01 00 	mov	r10,256
80006e94:	48 9b       	lddpc	r11,80006eb8 <vTaskStartScheduler+0x34>
80006e96:	48 ac       	lddpc	r12,80006ebc <vTaskStartScheduler+0x38>
80006e98:	f0 1f 00 0a 	mcall	80006ec0 <vTaskStartScheduler+0x3c>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
80006e9c:	2f dd       	sub	sp,-12
80006e9e:	58 1c       	cp.w	r12,1
80006ea0:	c0 a1       	brne	80006eb4 <vTaskStartScheduler+0x30>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
80006ea2:	d3 03       	ssrf	0x10

		xSchedulerRunning = pdTRUE;
80006ea4:	30 19       	mov	r9,1
80006ea6:	48 88       	lddpc	r8,80006ec4 <vTaskStartScheduler+0x40>
80006ea8:	91 09       	st.w	r8[0x0],r9
		xTickCount = ( portTickType ) 0;
80006eaa:	30 09       	mov	r9,0
80006eac:	48 78       	lddpc	r8,80006ec8 <vTaskStartScheduler+0x44>
80006eae:	91 09       	st.w	r8[0x0],r9
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
80006eb0:	f0 1f 00 07 	mcall	80006ecc <vTaskStartScheduler+0x48>
80006eb4:	d8 02       	popm	pc
80006eb6:	00 00       	add	r0,r0
80006eb8:	80 00       	ld.sh	r0,r0[0x0]
80006eba:	da 50       	acall	0xa5
80006ebc:	80 00       	ld.sh	r0,r0[0x0]
80006ebe:	6c 14       	ld.w	r4,r6[0x4]
80006ec0:	80 00       	ld.sh	r0,r0[0x0]
80006ec2:	6c 9c       	ld.w	r12,r6[0x24]
80006ec4:	00 00       	add	r0,r0
80006ec6:	0c 2c       	rsub	r12,r6
80006ec8:	00 00       	add	r0,r0
80006eca:	0d 1c       	ld.sh	r12,r6++
80006ecc:	80 00       	ld.sh	r0,r0[0x0]
80006ece:	5e 78       	retpl	r8

80006ed0 <PrintChar>:
	
static void task_log(void * pvParameters);

char *  PrintChar(char c, char * str)
{
	*str++ = c;
80006ed0:	16 cc       	st.b	r11++,r12
	return str;
}
80006ed2:	5e fb       	retal	r11

80006ed4 <PrintHex>:
	
	return str;
}

char * PrintHex(int i,char len, char * str)
{
80006ed4:	eb cd 40 c0 	pushm	r6-r7,lr
80006ed8:	20 3d       	sub	sp,12
80006eda:	18 98       	mov	r8,r12
	char * p = str;
	char s[12];
	memset(s, 0 , 12);
80006edc:	30 06       	mov	r6,0
80006ede:	30 07       	mov	r7,0
80006ee0:	fa e7 00 00 	st.d	sp[0],r6
80006ee4:	30 0c       	mov	r12,0
80006ee6:	50 2c       	stdsp	sp[0x8],r12
	int cnt=0;
	
	if(i)
80006ee8:	58 08       	cp.w	r8,0
80006eea:	c1 30       	breq	80006f10 <PrintHex+0x3c>
80006eec:	18 99       	mov	r9,r12
	while(i)
	{
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
80006eee:	1a 9c       	mov	r12,sp
80006ef0:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80006ef4:	58 9e       	cp.w	lr,9
80006ef6:	e0 8a 00 04 	brle	80006efe <PrintHex+0x2a>
80006efa:	2c 9e       	sub	lr,-55
80006efc:	c0 48       	rjmp	80006f04 <PrintHex+0x30>
80006efe:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80006f02:	2d 0e       	sub	lr,-48
80006f04:	f8 09 0b 0e 	st.b	r12[r9],lr
80006f08:	2f f9       	sub	r9,-1
		i = (i >> 4 ) & 0x0FFFFFFF;
80006f0a:	a5 88       	lsr	r8,0x4
	char s[12];
	memset(s, 0 , 12);
	int cnt=0;
	
	if(i)
	while(i)
80006f0c:	cf 21       	brne	80006ef0 <PrintHex+0x1c>
80006f0e:	c0 48       	rjmp	80006f16 <PrintHex+0x42>
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
		i = (i >> 4 ) & 0x0FFFFFFF;
		//i >>= 4
	}
	else
	s[cnt++] = '0';
80006f10:	33 08       	mov	r8,48
80006f12:	ba 88       	st.b	sp[0x0],r8
80006f14:	30 19       	mov	r9,1
	
	if(len - cnt > 0 )
80006f16:	f6 09 01 08 	sub	r8,r11,r9
80006f1a:	58 08       	cp.w	r8,0
80006f1c:	e0 8a 00 13 	brle	80006f42 <PrintHex+0x6e>
	{
		char num = len - cnt;
80006f20:	12 1b       	sub	r11,r9
80006f22:	f9 db c0 08 	bfextu	r12,r11,0x0,0x8
		for(int i = 0; i < num; i++)
80006f26:	18 9e       	mov	lr,r12
80006f28:	58 0c       	cp.w	r12,0
80006f2a:	e0 8a 00 0c 	brle	80006f42 <PrintHex+0x6e>
80006f2e:	1a 9b       	mov	r11,sp
80006f30:	12 0b       	add	r11,r9
80006f32:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80006f34:	33 07       	mov	r7,48
80006f36:	16 c7       	st.b	r11++,r7
	s[cnt++] = '0';
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80006f38:	2f f8       	sub	r8,-1
80006f3a:	1c 38       	cp.w	r8,lr
80006f3c:	cf d5       	brlt	80006f36 <PrintHex+0x62>
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
80006f3e:	f8 09 00 09 	add	r9,r12,r9
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80006f42:	f2 c8 ff ff 	sub	r8,r9,-1
	s[cnt++] = '0';
	
	while(cnt>0)
80006f46:	f0 cb ff ff 	sub	r11,r8,-1
80006f4a:	58 0b       	cp.w	r11,0
80006f4c:	e0 8a 00 19 	brle	80006f7e <PrintHex+0xaa>
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80006f50:	fa cb ff f4 	sub	r11,sp,-12
80006f54:	f6 09 00 09 	add	r9,r11,r9
80006f58:	37 8b       	mov	r11,120
80006f5a:	f3 6b ff f4 	st.b	r9[-12],r11
	s[cnt++] = '0';
80006f5e:	fa c9 ff f4 	sub	r9,sp,-12
80006f62:	10 09       	add	r9,r8
80006f64:	33 0b       	mov	r11,48
80006f66:	f3 6b ff f4 	st.b	r9[-12],r11
80006f6a:	fa 08 00 08 	add	r8,sp,r8
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
80006f6e:	fa ce 00 01 	sub	lr,sp,1
80006f72:	14 99       	mov	r9,r10
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
	*p++ = s[--cnt];
80006f74:	11 8b       	ld.ub	r11,r8[0x0]
80006f76:	12 cb       	st.b	r9++,r11
80006f78:	20 18       	sub	r8,1
	}
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
80006f7a:	1c 38       	cp.w	r8,lr
80006f7c:	cf c1       	brne	80006f74 <PrintHex+0xa0>
	*p++ = s[--cnt];
		
	return str;
}
80006f7e:	14 9c       	mov	r12,r10
80006f80:	2f dd       	sub	sp,-12
80006f82:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

80006f86 <PrintDec>:
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
{
80006f86:	d4 21       	pushm	r4-r7,lr
80006f88:	20 3d       	sub	sp,12
80006f8a:	18 98       	mov	r8,r12
	char * p = str;
	
	int sign = i>=0 ? 0 : 1;
	char s[10];
	memset(s, 0 , 10);
80006f8c:	30 06       	mov	r6,0
80006f8e:	30 07       	mov	r7,0
80006f90:	fa e7 00 00 	st.d	sp[0],r6
80006f94:	30 0c       	mov	r12,0
80006f96:	ba 4c       	st.h	sp[0x8],r12
	int cnt=0;
	if(sign)
80006f98:	58 08       	cp.w	r8,0
80006f9a:	c0 35       	brlt	80006fa0 <PrintDec+0x1a>
80006f9c:	14 97       	mov	r7,r10
80006f9e:	c0 58       	rjmp	80006fa8 <PrintDec+0x22>
	{
		*p++ = '-';
80006fa0:	14 97       	mov	r7,r10
80006fa2:	32 d9       	mov	r9,45
80006fa4:	0e c9       	st.b	r7++,r9
		i = -i;
80006fa6:	5c 38       	neg	r8
	}
	
	if(i == 0 )s[cnt++] = '0';
80006fa8:	58 08       	cp.w	r8,0
80006faa:	c0 51       	brne	80006fb4 <PrintDec+0x2e>
80006fac:	33 08       	mov	r8,48
80006fae:	ba 88       	st.b	sp[0x0],r8
80006fb0:	30 1e       	mov	lr,1
80006fb2:	c2 f8       	rjmp	80007010 <PrintDec+0x8a>
	
	int ten = i%10;
80006fb4:	e0 65 66 67 	mov	r5,26215
80006fb8:	ea 15 66 66 	orh	r5,0x6666
80006fbc:	f0 05 04 44 	muls.d	r4,r8,r5
80006fc0:	ea 0c 14 02 	asr	r12,r5,0x2
80006fc4:	f0 09 14 1f 	asr	r9,r8,0x1f
80006fc8:	f8 09 01 09 	sub	r9,r12,r9
80006fcc:	f2 09 00 29 	add	r9,r9,r9<<0x2
80006fd0:	f0 09 01 19 	sub	r9,r8,r9<<0x1
80006fd4:	30 0e       	mov	lr,0
	while(i)
	{
		s[cnt] = ten+'0';
80006fd6:	1a 9c       	mov	r12,sp
		cnt++;
		i /= 10;
80006fd8:	e0 66 66 67 	mov	r6,26215
80006fdc:	ea 16 66 66 	orh	r6,0x6666
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
	{
		s[cnt] = ten+'0';
80006fe0:	2d 09       	sub	r9,-48
80006fe2:	f8 0e 0b 09 	st.b	r12[lr],r9
		cnt++;
80006fe6:	2f fe       	sub	lr,-1
		i /= 10;
80006fe8:	f0 06 04 44 	muls.d	r4,r8,r6
80006fec:	ea 09 14 02 	asr	r9,r5,0x2
80006ff0:	bf 58       	asr	r8,0x1f
80006ff2:	f2 08 01 08 	sub	r8,r9,r8
		ten = i%10;
80006ff6:	f0 06 04 44 	muls.d	r4,r8,r6
80006ffa:	ea 09 14 02 	asr	r9,r5,0x2
80006ffe:	f0 05 14 1f 	asr	r5,r8,0x1f
80007002:	0a 19       	sub	r9,r5
80007004:	f2 09 00 29 	add	r9,r9,r9<<0x2
80007008:	f0 09 01 19 	sub	r9,r8,r9<<0x1
	}
	
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
8000700c:	58 08       	cp.w	r8,0
8000700e:	ce 91       	brne	80006fe0 <PrintDec+0x5a>
		cnt++;
		i /= 10;
		ten = i%10;
	}
	
	if(len - cnt > 0 )
80007010:	f6 0e 01 08 	sub	r8,r11,lr
80007014:	58 08       	cp.w	r8,0
80007016:	e0 89 00 06 	brgt	80007022 <PrintDec+0x9c>
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
8000701a:	58 0e       	cp.w	lr,0
8000701c:	e0 89 00 14 	brgt	80007044 <PrintDec+0xbe>
80007020:	c1 d8       	rjmp	8000705a <PrintDec+0xd4>
		ten = i%10;
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
80007022:	1c 1b       	sub	r11,lr
80007024:	5c 5b       	castu.b	r11
		for(int i = 0; i < num; i++)
80007026:	16 9c       	mov	r12,r11
80007028:	58 0b       	cp.w	r11,0
8000702a:	fe 9a ff f8 	brle	8000701a <PrintDec+0x94>
8000702e:	1a 99       	mov	r9,sp
80007030:	1c 09       	add	r9,lr
80007032:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80007034:	33 06       	mov	r6,48
80007036:	12 c6       	st.b	r9++,r6
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80007038:	2f f8       	sub	r8,-1
8000703a:	18 38       	cp.w	r8,r12
8000703c:	cf d5       	brlt	80007036 <PrintDec+0xb0>
{
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
8000703e:	f6 0e 00 0e 	add	lr,r11,lr
80007042:	ce cb       	rjmp	8000701a <PrintDec+0x94>
80007044:	fa c8 ff f4 	sub	r8,sp,-12
80007048:	1c 08       	add	r8,lr
8000704a:	20 d8       	sub	r8,13
8000704c:	fa cb 00 01 	sub	r11,sp,1
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
	*p++ = s[--cnt];
80007050:	11 89       	ld.ub	r9,r8[0x0]
80007052:	0e c9       	st.b	r7++,r9
80007054:	20 18       	sub	r8,1
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80007056:	16 38       	cp.w	r8,r11
80007058:	cf c1       	brne	80007050 <PrintDec+0xca>
	*p++ = s[--cnt];
	
	return str;
}
8000705a:	14 9c       	mov	r12,r10
8000705c:	2f dd       	sub	sp,-12
8000705e:	d8 22       	popm	r4-r7,pc

80007060 <log>:
	,  NULL );
	
}

int log(char * content, ...)
{
80007060:	d4 31       	pushm	r0-r7,lr
80007062:	fa cd 02 08 	sub	sp,sp,520
80007066:	18 97       	mov	r7,r12
	
	
	char logTmp[MAX_LOG_LINE_SIZE];
	memset(logTmp, '\0', MAX_LOG_LINE_SIZE);	
80007068:	e0 6a 01 00 	mov	r10,256
8000706c:	30 0b       	mov	r11,0
8000706e:	fa cc fe f8 	sub	r12,sp,-264
80007072:	f0 1f 00 4e 	mcall	800071a8 <log+0x148>
	,  tskLOG_PRIORITY
	,  NULL );
	
}

int log(char * content, ...)
80007076:	fa c4 fd d4 	sub	r4,sp,-556
8000707a:	30 0a       	mov	r10,0
8000707c:	50 0a       	stdsp	sp[0x0],r10
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
8000707e:	fa c3 ff fc 	sub	r3,sp,-4
80007082:	e0 61 01 00 	mov	r1,256
80007086:	14 90       	mov	r0,r10
			
					if(*str == '%')
80007088:	32 52       	mov	r2,37
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
8000708a:	fa c6 fe f8 	sub	r6,sp,-264
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
8000708e:	02 9a       	mov	r10,r1
80007090:	00 9b       	mov	r11,r0
80007092:	06 9c       	mov	r12,r3
80007094:	f0 1f 00 45 	mcall	800071a8 <log+0x148>
			
					if(*str == '%')
80007098:	0f 88       	ld.ub	r8,r7[0x0]
8000709a:	e4 08 18 00 	cp.b	r8,r2
8000709e:	c5 71       	brne	8000714c <log+0xec>
					{
						static char lench = 0;
						lench =*(str + 1);
800070a0:	ee c8 ff ff 	sub	r8,r7,-1
800070a4:	11 89       	ld.ub	r9,r8[0x0]
800070a6:	4c 2a       	lddpc	r10,800071ac <log+0x14c>
800070a8:	b4 89       	st.b	r10[0x0],r9
						if((lench >= '0') &&  (lench <= '9'))
800070aa:	23 09       	sub	r9,48
800070ac:	30 9a       	mov	r10,9
800070ae:	f4 09 18 00 	cp.b	r9,r10
800070b2:	ee 08 17 b0 	movhi	r8,r7
						{
							len = *(++str) - '0';
800070b6:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
800070ba:	f7 b9 08 30 	subls	r9,48
800070be:	fb f9 8a 00 	st.wls	sp[0x0],r9
						}
						
						str++;
800070c2:	f0 c7 ff ff 	sub	r7,r8,-1
						
						switch(*(str))
800070c6:	0f 88       	ld.ub	r8,r7[0x0]
800070c8:	22 58       	sub	r8,37
800070ca:	e0 48 00 53 	cp.w	r8,83
800070ce:	e0 8b 00 31 	brhi	80007130 <log+0xd0>
800070d2:	4b 89       	lddpc	r9,800071b0 <log+0x150>
800070d4:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
						{
							case('i'):
							case('I'):
							case('d'):
							case('D'):
							x = va_arg(arg_ptr,int);
800070d8:	e8 c5 ff fc 	sub	r5,r4,-4
							strTmp = PrintDec(x, len, strTmp);
800070dc:	06 9a       	mov	r10,r3
800070de:	40 0b       	lddsp	r11,sp[0x0]
800070e0:	5c 5b       	castu.b	r11
800070e2:	68 0c       	ld.w	r12,r4[0x0]
800070e4:	f0 1f 00 34 	mcall	800071b4 <log+0x154>
							break;
800070e8:	c2 98       	rjmp	8000713a <log+0xda>
							
							case('f')://浮点数输出
							case('F'):
							//f = va_arg(arg_ptr,int);
							//strTmp = PrintDec(x, len, strTmp);
							log("I need float.");
800070ea:	4b 4c       	lddpc	r12,800071b8 <log+0x158>
800070ec:	f0 1f 00 34 	mcall	800071bc <log+0x15c>
800070f0:	08 95       	mov	r5,r4
800070f2:	06 9c       	mov	r12,r3
							break;
800070f4:	c2 38       	rjmp	8000713a <log+0xda>
							
							
							case('x'):
							case('X'):
							x = va_arg(arg_ptr,int);
800070f6:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintHex(x,len, strTmp);
800070fa:	06 9a       	mov	r10,r3
800070fc:	40 0b       	lddsp	r11,sp[0x0]
800070fe:	5c 5b       	castu.b	r11
80007100:	68 0c       	ld.w	r12,r4[0x0]
80007102:	f0 1f 00 30 	mcall	800071c0 <log+0x160>
80007106:	06 9c       	mov	r12,r3
							break;
80007108:	c1 98       	rjmp	8000713a <log+0xda>
							
							case('c'):
							case('C'):
							y = va_arg(arg_ptr,int);
8000710a:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintChar(y, strTmp);
8000710e:	06 9b       	mov	r11,r3
80007110:	09 bc       	ld.ub	r12,r4[0x3]
80007112:	f0 1f 00 2d 	mcall	800071c4 <log+0x164>
80007116:	06 9c       	mov	r12,r3
							break;
80007118:	c1 18       	rjmp	8000713a <log+0xda>
							
							case('s'):
							case('S'):
							strTmp = va_arg(arg_ptr,char*);
8000711a:	e8 c5 ff fc 	sub	r5,r4,-4
8000711e:	68 0c       	ld.w	r12,r4[0x0]
							//PrintStr(s);
							break;
80007120:	c0 d8       	rjmp	8000713a <log+0xda>
							
							case('%'):
							PrintChar('%', strTmp);
80007122:	06 9b       	mov	r11,r3
80007124:	32 5c       	mov	r12,37
80007126:	f0 1f 00 28 	mcall	800071c4 <log+0x164>
8000712a:	08 95       	mov	r5,r4
8000712c:	06 9c       	mov	r12,r3
							//PrintChar('%');
							break;
8000712e:	c0 68       	rjmp	8000713a <log+0xda>
							
							default:
							log("I need relax.");
80007130:	4a 6c       	lddpc	r12,800071c8 <log+0x168>
80007132:	f0 1f 00 23 	mcall	800071bc <log+0x15c>
80007136:	08 95       	mov	r5,r4
80007138:	06 9c       	mov	r12,r3
						}
						str++;
8000713a:	2f f7       	sub	r7,-1
						
						length = sprintf(logTmp,"%s%s",logTmp,strTmp );
8000713c:	1a dc       	st.w	--sp,r12
8000713e:	1a d6       	st.w	--sp,r6
80007140:	4a 3b       	lddpc	r11,800071cc <log+0x16c>
80007142:	0c 9c       	mov	r12,r6
80007144:	f0 1f 00 23 	mcall	800071d0 <log+0x170>
80007148:	2f ed       	sub	sp,-8
8000714a:	c0 a8       	rjmp	8000715e <log+0xfe>
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
8000714c:	2f f7       	sub	r7,-1
8000714e:	1a d8       	st.w	--sp,r8
80007150:	1a d6       	st.w	--sp,r6
80007152:	4a 1b       	lddpc	r11,800071d4 <log+0x174>
80007154:	0c 9c       	mov	r12,r6
80007156:	f0 1f 00 1f 	mcall	800071d0 <log+0x170>
8000715a:	08 95       	mov	r5,r4
8000715c:	2f ed       	sub	sp,-8
			
			
			
	}while(*str != '\0');
8000715e:	0f 89       	ld.ub	r9,r7[0x0]
80007160:	30 08       	mov	r8,0
80007162:	f0 09 18 00 	cp.b	r9,r8
80007166:	c0 30       	breq	8000716c <log+0x10c>
80007168:	0a 94       	mov	r4,r5
8000716a:	c9 2b       	rjmp	8000708e <log+0x2e>
		
		
				
	va_end(arg_ptr);
	//while(1)		
	length = sprintf(logTmp,"%s\r\n",logTmp);
8000716c:	fa c7 fe f8 	sub	r7,sp,-264
80007170:	1a d7       	st.w	--sp,r7
80007172:	49 ab       	lddpc	r11,800071d8 <log+0x178>
80007174:	0e 9c       	mov	r12,r7
80007176:	f0 1f 00 17 	mcall	800071d0 <log+0x170>
	
	char * p = pvPortMalloc(length+1);
8000717a:	5c 5c       	castu.b	r12
8000717c:	f8 c6 ff ff 	sub	r6,r12,-1
80007180:	0c 9c       	mov	r12,r6
80007182:	f0 1f 00 17 	mcall	800071dc <log+0x17c>
80007186:	54 2c       	stdsp	sp[0x108],r12
	memcpy(p, logTmp, length+1);
80007188:	0c 9a       	mov	r10,r6
8000718a:	0e 9b       	mov	r11,r7
8000718c:	f0 1f 00 15 	mcall	800071e0 <log+0x180>
	//
	//usart_write_line(EXAMPLE_USART, logTmp)
	
	xQueueSend( logQueue, &p, 5);
80007190:	30 09       	mov	r9,0
80007192:	30 5a       	mov	r10,5
80007194:	fa cb fe f8 	sub	r11,sp,-264
80007198:	49 38       	lddpc	r8,800071e4 <log+0x184>
8000719a:	70 0c       	ld.w	r12,r8[0x0]
8000719c:	f0 1f 00 13 	mcall	800071e8 <log+0x188>
800071a0:	2f fd       	sub	sp,-4
	
	
}
800071a2:	fe 3d fd f8 	sub	sp,-520
800071a6:	d8 32       	popm	r0-r7,pc
800071a8:	80 00       	ld.sh	r0,r0[0x0]
800071aa:	7a 24       	ld.w	r4,sp[0x8]
800071ac:	00 00       	add	r0,r0
800071ae:	0d 5c       	ld.sh	r12,--r6
800071b0:	80 00       	ld.sh	r0,r0[0x0]
800071b2:	da 58       	*unknown*
800071b4:	80 00       	ld.sh	r0,r0[0x0]
800071b6:	6f 86       	ld.w	r6,r7[0x60]
800071b8:	80 00       	ld.sh	r0,r0[0x0]
800071ba:	dd 04       	*unknown*
800071bc:	80 00       	ld.sh	r0,r0[0x0]
800071be:	70 60       	ld.w	r0,r8[0x18]
800071c0:	80 00       	ld.sh	r0,r0[0x0]
800071c2:	6e d4       	ld.w	r4,r7[0x34]
800071c4:	80 00       	ld.sh	r0,r0[0x0]
800071c6:	6e d0       	ld.w	r0,r7[0x34]
800071c8:	80 00       	ld.sh	r0,r0[0x0]
800071ca:	dd 14       	*unknown*
800071cc:	80 00       	ld.sh	r0,r0[0x0]
800071ce:	dd 24       	*unknown*
800071d0:	80 00       	ld.sh	r0,r0[0x0]
800071d2:	7d 14       	ld.w	r4,lr[0x44]
800071d4:	80 00       	ld.sh	r0,r0[0x0]
800071d6:	dd 2c       	*unknown*
800071d8:	80 00       	ld.sh	r0,r0[0x0]
800071da:	dd 34       	*unknown*
800071dc:	80 00       	ld.sh	r0,r0[0x0]
800071de:	60 d4       	ld.w	r4,r0[0x34]
800071e0:	80 00       	ld.sh	r0,r0[0x0]
800071e2:	78 dc       	ld.w	r12,r12[0x34]
800071e4:	00 00       	add	r0,r0
800071e6:	bf f0       	*unknown*
800071e8:	80 00       	ld.sh	r0,r0[0x0]
800071ea:	64 28       	ld.w	r8,r2[0x8]

800071ec <logFromISR>:
	
	
int logFromISR(char * content, ...)
	{
800071ec:	d4 31       	pushm	r0-r7,lr
800071ee:	fa cd 02 0c 	sub	sp,sp,524
800071f2:	18 97       	mov	r7,r12
		
		
		char logTmp[MAX_LOG_LINE_SIZE];
		memset(logTmp, '\0', MAX_LOG_LINE_SIZE);
800071f4:	e0 6a 01 00 	mov	r10,256
800071f8:	30 0b       	mov	r11,0
800071fa:	fa cc fe f4 	sub	r12,sp,-268
800071fe:	f0 1f 00 4c 	mcall	8000732c <logFromISR+0x140>
	
	
}
	
	
int logFromISR(char * content, ...)
80007202:	fa c4 fd d0 	sub	r4,sp,-560
80007206:	30 0a       	mov	r10,0
80007208:	50 0a       	stdsp	sp[0x0],r10
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
8000720a:	fa c3 ff fc 	sub	r3,sp,-4
8000720e:	e0 61 01 00 	mov	r1,256
80007212:	14 90       	mov	r0,r10
			
			if(*str == '%')
80007214:	32 52       	mov	r2,37
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
80007216:	fa c6 fe f4 	sub	r6,sp,-268
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
8000721a:	02 9a       	mov	r10,r1
8000721c:	00 9b       	mov	r11,r0
8000721e:	06 9c       	mov	r12,r3
80007220:	f0 1f 00 43 	mcall	8000732c <logFromISR+0x140>
			
			if(*str == '%')
80007224:	0f 88       	ld.ub	r8,r7[0x0]
80007226:	e4 08 18 00 	cp.b	r8,r2
8000722a:	c5 11       	brne	800072cc <logFromISR+0xe0>
			{
				static char lench = 0;
				lench =*(str + 1);
8000722c:	ee c8 ff ff 	sub	r8,r7,-1
80007230:	11 89       	ld.ub	r9,r8[0x0]
80007232:	4c 0a       	lddpc	r10,80007330 <logFromISR+0x144>
80007234:	b4 89       	st.b	r10[0x0],r9
				if((lench >= '0') &&  (lench <= '9'))
80007236:	23 09       	sub	r9,48
80007238:	30 9a       	mov	r10,9
8000723a:	f4 09 18 00 	cp.b	r9,r10
8000723e:	ee 08 17 b0 	movhi	r8,r7
				{
					len = *(++str) - '0';
80007242:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
80007246:	f7 b9 08 30 	subls	r9,48
8000724a:	fb f9 8a 00 	st.wls	sp[0x0],r9
				}
				
				str++;
8000724e:	f0 c7 ff ff 	sub	r7,r8,-1
				
				switch(*(str))
80007252:	0f 88       	ld.ub	r8,r7[0x0]
80007254:	22 58       	sub	r8,37
80007256:	e0 48 00 53 	cp.w	r8,83
8000725a:	e0 8b 00 2b 	brhi	800072b0 <logFromISR+0xc4>
8000725e:	4b 69       	lddpc	r9,80007334 <logFromISR+0x148>
80007260:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
				{
					case('d'):
					case('D'):
					x = va_arg(arg_ptr,int);
80007264:	e8 c5 ff fc 	sub	r5,r4,-4
					strTmp = PrintDec(x, len, strTmp);
80007268:	06 9a       	mov	r10,r3
8000726a:	40 0b       	lddsp	r11,sp[0x0]
8000726c:	5c 5b       	castu.b	r11
8000726e:	68 0c       	ld.w	r12,r4[0x0]
80007270:	f0 1f 00 32 	mcall	80007338 <logFromISR+0x14c>
					break;
80007274:	c2 38       	rjmp	800072ba <logFromISR+0xce>
					case('x'):
					case('X'):
					x = va_arg(arg_ptr,int);
80007276:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintHex(x,len, strTmp);
8000727a:	06 9a       	mov	r10,r3
8000727c:	40 0b       	lddsp	r11,sp[0x0]
8000727e:	5c 5b       	castu.b	r11
80007280:	68 0c       	ld.w	r12,r4[0x0]
80007282:	f0 1f 00 2f 	mcall	8000733c <logFromISR+0x150>
80007286:	06 9c       	mov	r12,r3
					break;
80007288:	c1 98       	rjmp	800072ba <logFromISR+0xce>
					case('c'):
					case('C'):
					y = va_arg(arg_ptr,int);
8000728a:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintChar(y, strTmp);
8000728e:	06 9b       	mov	r11,r3
80007290:	09 bc       	ld.ub	r12,r4[0x3]
80007292:	f0 1f 00 2c 	mcall	80007340 <logFromISR+0x154>
80007296:	06 9c       	mov	r12,r3
					break;
80007298:	c1 18       	rjmp	800072ba <logFromISR+0xce>
					case('s'):
					case('S'):
					strTmp = va_arg(arg_ptr,char*);
8000729a:	e8 c5 ff fc 	sub	r5,r4,-4
8000729e:	68 0c       	ld.w	r12,r4[0x0]
					//PrintStr(s);
					break;
800072a0:	c0 d8       	rjmp	800072ba <logFromISR+0xce>
					case('%'):
					PrintChar('%', strTmp);
800072a2:	06 9b       	mov	r11,r3
800072a4:	32 5c       	mov	r12,37
800072a6:	f0 1f 00 27 	mcall	80007340 <logFromISR+0x154>
800072aa:	08 95       	mov	r5,r4
800072ac:	06 9c       	mov	r12,r3
					//PrintChar('%');
					break;
800072ae:	c0 68       	rjmp	800072ba <logFromISR+0xce>
					default:
					log("I need relax.");
800072b0:	4a 5c       	lddpc	r12,80007344 <logFromISR+0x158>
800072b2:	f0 1f 00 26 	mcall	80007348 <logFromISR+0x15c>
800072b6:	08 95       	mov	r5,r4
800072b8:	06 9c       	mov	r12,r3
				}
				str++;
800072ba:	2f f7       	sub	r7,-1
				
				length = sprintf(logTmp,"%s%s",logTmp,strTmp );
800072bc:	1a dc       	st.w	--sp,r12
800072be:	1a d6       	st.w	--sp,r6
800072c0:	4a 3b       	lddpc	r11,8000734c <logFromISR+0x160>
800072c2:	0c 9c       	mov	r12,r6
800072c4:	f0 1f 00 23 	mcall	80007350 <logFromISR+0x164>
800072c8:	2f ed       	sub	sp,-8
800072ca:	c0 a8       	rjmp	800072de <logFromISR+0xf2>
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
800072cc:	2f f7       	sub	r7,-1
800072ce:	1a d8       	st.w	--sp,r8
800072d0:	1a d6       	st.w	--sp,r6
800072d2:	4a 1b       	lddpc	r11,80007354 <logFromISR+0x168>
800072d4:	0c 9c       	mov	r12,r6
800072d6:	f0 1f 00 1f 	mcall	80007350 <logFromISR+0x164>
800072da:	08 95       	mov	r5,r4
800072dc:	2f ed       	sub	sp,-8
			
			
			
		}while(*str != '\0');
800072de:	0f 89       	ld.ub	r9,r7[0x0]
800072e0:	30 08       	mov	r8,0
800072e2:	f0 09 18 00 	cp.b	r9,r8
800072e6:	c0 30       	breq	800072ec <logFromISR+0x100>
800072e8:	0a 94       	mov	r4,r5
800072ea:	c9 8b       	rjmp	8000721a <logFromISR+0x2e>
		
		
		
		va_end(arg_ptr);
		//while(1)
		length = sprintf(logTmp,"%s\r\n",logTmp);
800072ec:	fa c7 fe f4 	sub	r7,sp,-268
800072f0:	1a d7       	st.w	--sp,r7
800072f2:	49 ab       	lddpc	r11,80007358 <logFromISR+0x16c>
800072f4:	0e 9c       	mov	r12,r7
800072f6:	f0 1f 00 17 	mcall	80007350 <logFromISR+0x164>
		
		char * p = pvPortMalloc(length+1);
800072fa:	5c 5c       	castu.b	r12
800072fc:	f8 c6 ff ff 	sub	r6,r12,-1
80007300:	0c 9c       	mov	r12,r6
80007302:	f0 1f 00 17 	mcall	8000735c <logFromISR+0x170>
80007306:	54 3c       	stdsp	sp[0x10c],r12
		memcpy(p, logTmp, length+1);
80007308:	0c 9a       	mov	r10,r6
8000730a:	0e 9b       	mov	r11,r7
8000730c:	f0 1f 00 15 	mcall	80007360 <logFromISR+0x174>
		//
		portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80007310:	30 09       	mov	r9,0
80007312:	54 29       	stdsp	sp[0x108],r9
		
		//usart_write_line(EXAMPLE_USART, p);
		//vPortFree(p);
		xQueueSendFromISR( logQueue, &p, &xHigherPriorityTaskWoken );
80007314:	fa ca fe f8 	sub	r10,sp,-264
80007318:	fa cb fe f4 	sub	r11,sp,-268
8000731c:	49 28       	lddpc	r8,80007364 <logFromISR+0x178>
8000731e:	70 0c       	ld.w	r12,r8[0x0]
80007320:	f0 1f 00 12 	mcall	80007368 <logFromISR+0x17c>
80007324:	2f fd       	sub	sp,-4
		
		//if (xHigherPriorityTaskWoken == pdTRUE)
		//{
			////taskYIELD();
		//}
	}
80007326:	fe 3d fd f4 	sub	sp,-524
8000732a:	d8 32       	popm	r0-r7,pc
8000732c:	80 00       	ld.sh	r0,r0[0x0]
8000732e:	7a 24       	ld.w	r4,sp[0x8]
80007330:	00 00       	add	r0,r0
80007332:	0d 5d       	ld.sh	sp,--r6
80007334:	80 00       	ld.sh	r0,r0[0x0]
80007336:	db a8       	*unknown*
80007338:	80 00       	ld.sh	r0,r0[0x0]
8000733a:	6f 86       	ld.w	r6,r7[0x60]
8000733c:	80 00       	ld.sh	r0,r0[0x0]
8000733e:	6e d4       	ld.w	r4,r7[0x34]
80007340:	80 00       	ld.sh	r0,r0[0x0]
80007342:	6e d0       	ld.w	r0,r7[0x34]
80007344:	80 00       	ld.sh	r0,r0[0x0]
80007346:	dd 14       	*unknown*
80007348:	80 00       	ld.sh	r0,r0[0x0]
8000734a:	70 60       	ld.w	r0,r8[0x18]
8000734c:	80 00       	ld.sh	r0,r0[0x0]
8000734e:	dd 24       	*unknown*
80007350:	80 00       	ld.sh	r0,r0[0x0]
80007352:	7d 14       	ld.w	r4,lr[0x44]
80007354:	80 00       	ld.sh	r0,r0[0x0]
80007356:	dd 2c       	*unknown*
80007358:	80 00       	ld.sh	r0,r0[0x0]
8000735a:	dd 34       	*unknown*
8000735c:	80 00       	ld.sh	r0,r0[0x0]
8000735e:	60 d4       	ld.w	r4,r0[0x34]
80007360:	80 00       	ld.sh	r0,r0[0x0]
80007362:	78 dc       	ld.w	r12,r12[0x34]
80007364:	00 00       	add	r0,r0
80007366:	bf f0       	*unknown*
80007368:	80 00       	ld.sh	r0,r0[0x0]
8000736a:	63 d8       	ld.w	r8,r1[0x74]

8000736c <log_init>:
		
	return str;
}

void log_init(void)
{
8000736c:	d4 01       	pushm	lr
		.stopbits     = USART_1_STOPBIT,
		.channelmode  = USART_NORMAL_CHMODE
	};

	// Assign GPIO to USART.
	gpio_enable_module(USART_GPIO_MAP,
8000736e:	30 2b       	mov	r11,2
80007370:	48 fc       	lddpc	r12,800073ac <log_init+0x40>
80007372:	f0 1f 00 10 	mcall	800073b0 <log_init+0x44>
	sizeof(USART_GPIO_MAP) / sizeof(USART_GPIO_MAP[0]));

	// Initialize USART in RS232 mode.
	usart_init_rs232(EXAMPLE_USART, &USART_OPTIONS, EXAMPLE_TARGET_PBACLK_FREQ_HZ);			
80007376:	e0 6a 36 00 	mov	r10,13824
8000737a:	ea 1a 01 6e 	orh	r10,0x16e
8000737e:	48 eb       	lddpc	r11,800073b4 <log_init+0x48>
80007380:	fe 7c 18 00 	mov	r12,-59392
80007384:	f0 1f 00 0d 	mcall	800073b8 <log_init+0x4c>
			
	logQueue  = xQueueCreate(50, sizeof(char *));
80007388:	30 4b       	mov	r11,4
8000738a:	33 2c       	mov	r12,50
8000738c:	f0 1f 00 0c 	mcall	800073bc <log_init+0x50>
80007390:	48 c8       	lddpc	r8,800073c0 <log_init+0x54>
80007392:	91 0c       	st.w	r8[0x0],r12
	
	xTaskCreate(
80007394:	30 09       	mov	r9,0
80007396:	1a d9       	st.w	--sp,r9
80007398:	1a d9       	st.w	--sp,r9
8000739a:	1a d9       	st.w	--sp,r9
8000739c:	30 28       	mov	r8,2
8000739e:	36 4a       	mov	r10,100
800073a0:	48 9b       	lddpc	r11,800073c4 <log_init+0x58>
800073a2:	48 ac       	lddpc	r12,800073c8 <log_init+0x5c>
800073a4:	f0 1f 00 0a 	mcall	800073cc <log_init+0x60>
800073a8:	2f dd       	sub	sp,-12
	,  100//384
	,  NULL
	,  tskLOG_PRIORITY
	,  NULL );
	
}
800073aa:	d8 02       	popm	pc
800073ac:	80 00       	ld.sh	r0,r0[0x0]
800073ae:	dd 40       	acall	0xd4
800073b0:	80 00       	ld.sh	r0,r0[0x0]
800073b2:	55 b4       	stdsp	sp[0x16c],r4
800073b4:	80 00       	ld.sh	r0,r0[0x0]
800073b6:	dc f8       	*unknown*
800073b8:	80 00       	ld.sh	r0,r0[0x0]
800073ba:	5c 38       	neg	r8
800073bc:	80 00       	ld.sh	r0,r0[0x0]
800073be:	65 80       	ld.w	r0,r2[0x60]
800073c0:	00 00       	add	r0,r0
800073c2:	bf f0       	*unknown*
800073c4:	80 00       	ld.sh	r0,r0[0x0]
800073c6:	dd 3c       	*unknown*
800073c8:	80 00       	ld.sh	r0,r0[0x0]
800073ca:	73 d0       	ld.w	r0,r9[0x74]
800073cc:	80 00       	ld.sh	r0,r0[0x0]
800073ce:	6c 9c       	ld.w	r12,r6[0x24]

800073d0 <task_log>:
			////taskYIELD();
		//}
	}
//portTickType log_water_value =0;	
static void task_log(void * pvParameters)
{
800073d0:	eb cd 40 f8 	pushm	r3-r7,lr
800073d4:	20 1d       	sub	sp,4
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		//log_water_value = uxTaskGetStackHighWaterMark(NULL);
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
800073d6:	48 c7       	lddpc	r7,80007404 <task_log+0x34>
800073d8:	30 05       	mov	r5,0
800073da:	3f f4       	mov	r4,-1
		{
			if( NULL != str)
			{
				usart_write_line(EXAMPLE_USART, str);
800073dc:	fe 73 18 00 	mov	r3,-59392
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		//log_water_value = uxTaskGetStackHighWaterMark(NULL);
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
800073e0:	0a 99       	mov	r9,r5
800073e2:	08 9a       	mov	r10,r4
800073e4:	1a 9b       	mov	r11,sp
800073e6:	6e 0c       	ld.w	r12,r7[0x0]
800073e8:	f0 1f 00 08 	mcall	80007408 <task_log+0x38>
800073ec:	58 1c       	cp.w	r12,1
800073ee:	cf 91       	brne	800073e0 <task_log+0x10>
		{
			if( NULL != str)
800073f0:	40 0b       	lddsp	r11,sp[0x0]
800073f2:	58 0b       	cp.w	r11,0
800073f4:	cf 60       	breq	800073e0 <task_log+0x10>
			{
				usart_write_line(EXAMPLE_USART, str);
800073f6:	06 9c       	mov	r12,r3
800073f8:	f0 1f 00 05 	mcall	8000740c <task_log+0x3c>
				vPortFree(str);
800073fc:	40 0c       	lddsp	r12,sp[0x0]
800073fe:	f0 1f 00 05 	mcall	80007410 <task_log+0x40>
80007402:	ce fb       	rjmp	800073e0 <task_log+0x10>
80007404:	00 00       	add	r0,r0
80007406:	bf f0       	*unknown*
80007408:	80 00       	ld.sh	r0,r0[0x0]
8000740a:	62 1c       	ld.w	r12,r1[0x4]
8000740c:	80 00       	ld.sh	r0,r0[0x0]
8000740e:	5b e8       	cp.w	r8,-2
80007410:	80 00       	ld.sh	r0,r0[0x0]
80007412:	60 ac       	ld.w	r12,r0[0x28]

80007414 <main>:
#include "xgflash.h"
#include "app.h"


int main (void)
{
80007414:	d4 01       	pushm	lr
	
	//Force SSC_TX_DATA_ENABLE Disabled as soon as possible.
	AVR32_GPIO.port[1].ovrs  =  0x00000001;  //Value will be high.
80007416:	fe 78 10 00 	mov	r8,-61440
8000741a:	30 19       	mov	r9,1
8000741c:	f1 49 01 54 	st.w	r8[340],r9
	AVR32_GPIO.port[1].oders =  0x00000001;  //Output Driver will be Enabled.
80007420:	f1 49 01 44 	st.w	r8[324],r9
	AVR32_GPIO.port[1].gpers =  0x00000001;  //Enable as GPIO.
80007424:	f1 49 01 04 	st.w	r8[260],r9
		
	Disable_global_interrupt();
80007428:	d3 03       	ssrf	0x10
	local_start_pll0();
8000742a:	f0 1f 00 0c 	mcall	80007458 <main+0x44>
		
	INTC_init_interrupts();
8000742e:	f0 1f 00 0c 	mcall	8000745c <main+0x48>
		
	log_init();
80007432:	f0 1f 00 0c 	mcall	80007460 <main+0x4c>
	log("----start debug----");
80007436:	48 cc       	lddpc	r12,80007464 <main+0x50>
80007438:	f0 1f 00 0c 	mcall	80007468 <main+0x54>
	
	xg_flashc_init();
8000743c:	f0 1f 00 0c 	mcall	8000746c <main+0x58>
	
	rfid_init();
80007440:	f0 1f 00 0c 	mcall	80007470 <main+0x5c>
		
	app_init();
80007444:	f0 1f 00 0c 	mcall	80007474 <main+0x60>
		
	xcmp_init();
80007448:	f0 1f 00 0c 	mcall	80007478 <main+0x64>

	local_start_timer();
8000744c:	f0 1f 00 0c 	mcall	8000747c <main+0x68>
		
	vTaskStartScheduler();
80007450:	f0 1f 00 0c 	mcall	80007480 <main+0x6c>
	return 0;
	
}
80007454:	d8 0a       	popm	pc,r12=0
80007456:	00 00       	add	r0,r0
80007458:	80 00       	ld.sh	r0,r0[0x0]
8000745a:	54 30       	stdsp	sp[0x10c],r0
8000745c:	80 00       	ld.sh	r0,r0[0x0]
8000745e:	56 b8       	stdsp	sp[0x1ac],r8
80007460:	80 00       	ld.sh	r0,r0[0x0]
80007462:	73 6c       	ld.w	r12,r9[0x58]
80007464:	80 00       	ld.sh	r0,r0[0x0]
80007466:	dd 50       	acall	0xd5
80007468:	80 00       	ld.sh	r0,r0[0x0]
8000746a:	70 60       	ld.w	r0,r8[0x18]
8000746c:	80 00       	ld.sh	r0,r0[0x0]
8000746e:	54 c4       	stdsp	sp[0x130],r4
80007470:	80 00       	ld.sh	r0,r0[0x0]
80007472:	53 90       	stdsp	sp[0xe4],r0
80007474:	80 00       	ld.sh	r0,r0[0x0]
80007476:	27 44       	sub	r4,116
80007478:	80 00       	ld.sh	r0,r0[0x0]
8000747a:	41 94       	lddsp	r4,sp[0x64]
8000747c:	80 00       	ld.sh	r0,r0[0x0]
8000747e:	54 04       	stdsp	sp[0x100],r4
80007480:	80 00       	ld.sh	r0,r0[0x0]
80007482:	6e 84       	ld.w	r4,r7[0x20]

80007484 <free>:
80007484:	d4 01       	pushm	lr
80007486:	e0 68 0a 3c 	mov	r8,2620
8000748a:	18 9b       	mov	r11,r12
8000748c:	70 0c       	ld.w	r12,r8[0x0]
8000748e:	e0 a0 1e 61 	rcall	8000b150 <_free_r>
80007492:	d8 02       	popm	pc

80007494 <malloc>:
80007494:	d4 01       	pushm	lr
80007496:	e0 68 0a 3c 	mov	r8,2620
8000749a:	18 9b       	mov	r11,r12
8000749c:	70 0c       	ld.w	r12,r8[0x0]
8000749e:	c0 3c       	rcall	800074a4 <_malloc_r>
800074a0:	d8 02       	popm	pc
800074a2:	d7 03       	nop

800074a4 <_malloc_r>:
800074a4:	d4 31       	pushm	r0-r7,lr
800074a6:	f6 c8 ff f5 	sub	r8,r11,-11
800074aa:	18 95       	mov	r5,r12
800074ac:	10 97       	mov	r7,r8
800074ae:	e0 17 ff f8 	andl	r7,0xfff8
800074b2:	59 68       	cp.w	r8,22
800074b4:	f9 b7 08 10 	movls	r7,16
800074b8:	16 37       	cp.w	r7,r11
800074ba:	5f 38       	srlo	r8
800074bc:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
800074c0:	c0 50       	breq	800074ca <_malloc_r+0x26>
800074c2:	30 c8       	mov	r8,12
800074c4:	99 38       	st.w	r12[0xc],r8
800074c6:	e0 8f 01 fa 	bral	800078ba <_malloc_r+0x416>
800074ca:	fe b0 f5 a7 	rcall	80006018 <__malloc_lock>
800074ce:	e0 47 01 f7 	cp.w	r7,503
800074d2:	e0 8b 00 1d 	brhi	8000750c <_malloc_r+0x68>
800074d6:	ee 03 16 03 	lsr	r3,r7,0x3
800074da:	e0 68 05 3c 	mov	r8,1340
800074de:	f0 03 00 38 	add	r8,r8,r3<<0x3
800074e2:	70 36       	ld.w	r6,r8[0xc]
800074e4:	10 36       	cp.w	r6,r8
800074e6:	c0 61       	brne	800074f2 <_malloc_r+0x4e>
800074e8:	ec c8 ff f8 	sub	r8,r6,-8
800074ec:	70 36       	ld.w	r6,r8[0xc]
800074ee:	10 36       	cp.w	r6,r8
800074f0:	c0 c0       	breq	80007508 <_malloc_r+0x64>
800074f2:	6c 18       	ld.w	r8,r6[0x4]
800074f4:	e0 18 ff fc 	andl	r8,0xfffc
800074f8:	6c 3a       	ld.w	r10,r6[0xc]
800074fa:	ec 08 00 09 	add	r9,r6,r8
800074fe:	0a 9c       	mov	r12,r5
80007500:	6c 28       	ld.w	r8,r6[0x8]
80007502:	95 28       	st.w	r10[0x8],r8
80007504:	91 3a       	st.w	r8[0xc],r10
80007506:	c4 78       	rjmp	80007594 <_malloc_r+0xf0>
80007508:	2f e3       	sub	r3,-2
8000750a:	c4 d8       	rjmp	800075a4 <_malloc_r+0x100>
8000750c:	ee 03 16 09 	lsr	r3,r7,0x9
80007510:	c0 41       	brne	80007518 <_malloc_r+0x74>
80007512:	ee 03 16 03 	lsr	r3,r7,0x3
80007516:	c2 68       	rjmp	80007562 <_malloc_r+0xbe>
80007518:	58 43       	cp.w	r3,4
8000751a:	e0 8b 00 06 	brhi	80007526 <_malloc_r+0x82>
8000751e:	ee 03 16 06 	lsr	r3,r7,0x6
80007522:	2c 83       	sub	r3,-56
80007524:	c1 f8       	rjmp	80007562 <_malloc_r+0xbe>
80007526:	59 43       	cp.w	r3,20
80007528:	e0 8b 00 04 	brhi	80007530 <_malloc_r+0x8c>
8000752c:	2a 53       	sub	r3,-91
8000752e:	c1 a8       	rjmp	80007562 <_malloc_r+0xbe>
80007530:	e0 43 00 54 	cp.w	r3,84
80007534:	e0 8b 00 06 	brhi	80007540 <_malloc_r+0x9c>
80007538:	ee 03 16 0c 	lsr	r3,r7,0xc
8000753c:	29 23       	sub	r3,-110
8000753e:	c1 28       	rjmp	80007562 <_malloc_r+0xbe>
80007540:	e0 43 01 54 	cp.w	r3,340
80007544:	e0 8b 00 06 	brhi	80007550 <_malloc_r+0xac>
80007548:	ee 03 16 0f 	lsr	r3,r7,0xf
8000754c:	28 93       	sub	r3,-119
8000754e:	c0 a8       	rjmp	80007562 <_malloc_r+0xbe>
80007550:	e0 43 05 54 	cp.w	r3,1364
80007554:	e0 88 00 04 	brls	8000755c <_malloc_r+0xb8>
80007558:	37 e3       	mov	r3,126
8000755a:	c0 48       	rjmp	80007562 <_malloc_r+0xbe>
8000755c:	ee 03 16 12 	lsr	r3,r7,0x12
80007560:	28 43       	sub	r3,-124
80007562:	e0 6a 05 3c 	mov	r10,1340
80007566:	f4 03 00 3a 	add	r10,r10,r3<<0x3
8000756a:	74 36       	ld.w	r6,r10[0xc]
8000756c:	c1 98       	rjmp	8000759e <_malloc_r+0xfa>
8000756e:	6c 19       	ld.w	r9,r6[0x4]
80007570:	e0 19 ff fc 	andl	r9,0xfffc
80007574:	f2 07 01 0b 	sub	r11,r9,r7
80007578:	58 fb       	cp.w	r11,15
8000757a:	e0 8a 00 04 	brle	80007582 <_malloc_r+0xde>
8000757e:	20 13       	sub	r3,1
80007580:	c1 18       	rjmp	800075a2 <_malloc_r+0xfe>
80007582:	6c 38       	ld.w	r8,r6[0xc]
80007584:	58 0b       	cp.w	r11,0
80007586:	c0 b5       	brlt	8000759c <_malloc_r+0xf8>
80007588:	6c 2a       	ld.w	r10,r6[0x8]
8000758a:	ec 09 00 09 	add	r9,r6,r9
8000758e:	0a 9c       	mov	r12,r5
80007590:	91 2a       	st.w	r8[0x8],r10
80007592:	95 38       	st.w	r10[0xc],r8
80007594:	72 18       	ld.w	r8,r9[0x4]
80007596:	a1 a8       	sbr	r8,0x0
80007598:	93 18       	st.w	r9[0x4],r8
8000759a:	cb c8       	rjmp	80007712 <_malloc_r+0x26e>
8000759c:	10 96       	mov	r6,r8
8000759e:	14 36       	cp.w	r6,r10
800075a0:	ce 71       	brne	8000756e <_malloc_r+0xca>
800075a2:	2f f3       	sub	r3,-1
800075a4:	e0 6a 05 3c 	mov	r10,1340
800075a8:	f4 cc ff f8 	sub	r12,r10,-8
800075ac:	78 26       	ld.w	r6,r12[0x8]
800075ae:	18 36       	cp.w	r6,r12
800075b0:	c6 c0       	breq	80007688 <_malloc_r+0x1e4>
800075b2:	6c 19       	ld.w	r9,r6[0x4]
800075b4:	e0 19 ff fc 	andl	r9,0xfffc
800075b8:	f2 07 01 08 	sub	r8,r9,r7
800075bc:	58 f8       	cp.w	r8,15
800075be:	e0 89 00 8f 	brgt	800076dc <_malloc_r+0x238>
800075c2:	99 3c       	st.w	r12[0xc],r12
800075c4:	99 2c       	st.w	r12[0x8],r12
800075c6:	58 08       	cp.w	r8,0
800075c8:	c0 55       	brlt	800075d2 <_malloc_r+0x12e>
800075ca:	ec 09 00 09 	add	r9,r6,r9
800075ce:	0a 9c       	mov	r12,r5
800075d0:	ce 2b       	rjmp	80007594 <_malloc_r+0xf0>
800075d2:	e0 49 01 ff 	cp.w	r9,511
800075d6:	e0 8b 00 13 	brhi	800075fc <_malloc_r+0x158>
800075da:	a3 99       	lsr	r9,0x3
800075dc:	f4 09 00 38 	add	r8,r10,r9<<0x3
800075e0:	70 2b       	ld.w	r11,r8[0x8]
800075e2:	8d 38       	st.w	r6[0xc],r8
800075e4:	8d 2b       	st.w	r6[0x8],r11
800075e6:	97 36       	st.w	r11[0xc],r6
800075e8:	91 26       	st.w	r8[0x8],r6
800075ea:	a3 49       	asr	r9,0x2
800075ec:	74 18       	ld.w	r8,r10[0x4]
800075ee:	30 1b       	mov	r11,1
800075f0:	f6 09 09 49 	lsl	r9,r11,r9
800075f4:	f1 e9 10 09 	or	r9,r8,r9
800075f8:	95 19       	st.w	r10[0x4],r9
800075fa:	c4 78       	rjmp	80007688 <_malloc_r+0x1e4>
800075fc:	f2 0a 16 09 	lsr	r10,r9,0x9
80007600:	58 4a       	cp.w	r10,4
80007602:	e0 8b 00 07 	brhi	80007610 <_malloc_r+0x16c>
80007606:	f2 0a 16 06 	lsr	r10,r9,0x6
8000760a:	2c 8a       	sub	r10,-56
8000760c:	c2 08       	rjmp	8000764c <_malloc_r+0x1a8>
8000760e:	d7 03       	nop
80007610:	59 4a       	cp.w	r10,20
80007612:	e0 8b 00 04 	brhi	8000761a <_malloc_r+0x176>
80007616:	2a 5a       	sub	r10,-91
80007618:	c1 a8       	rjmp	8000764c <_malloc_r+0x1a8>
8000761a:	e0 4a 00 54 	cp.w	r10,84
8000761e:	e0 8b 00 06 	brhi	8000762a <_malloc_r+0x186>
80007622:	f2 0a 16 0c 	lsr	r10,r9,0xc
80007626:	29 2a       	sub	r10,-110
80007628:	c1 28       	rjmp	8000764c <_malloc_r+0x1a8>
8000762a:	e0 4a 01 54 	cp.w	r10,340
8000762e:	e0 8b 00 06 	brhi	8000763a <_malloc_r+0x196>
80007632:	f2 0a 16 0f 	lsr	r10,r9,0xf
80007636:	28 9a       	sub	r10,-119
80007638:	c0 a8       	rjmp	8000764c <_malloc_r+0x1a8>
8000763a:	e0 4a 05 54 	cp.w	r10,1364
8000763e:	e0 88 00 04 	brls	80007646 <_malloc_r+0x1a2>
80007642:	37 ea       	mov	r10,126
80007644:	c0 48       	rjmp	8000764c <_malloc_r+0x1a8>
80007646:	f2 0a 16 12 	lsr	r10,r9,0x12
8000764a:	28 4a       	sub	r10,-124
8000764c:	e0 6b 05 3c 	mov	r11,1340
80007650:	f6 0a 00 34 	add	r4,r11,r10<<0x3
80007654:	68 28       	ld.w	r8,r4[0x8]
80007656:	08 38       	cp.w	r8,r4
80007658:	c0 e1       	brne	80007674 <_malloc_r+0x1d0>
8000765a:	76 19       	ld.w	r9,r11[0x4]
8000765c:	a3 4a       	asr	r10,0x2
8000765e:	30 1e       	mov	lr,1
80007660:	fc 0a 09 4a 	lsl	r10,lr,r10
80007664:	f3 ea 10 0a 	or	r10,r9,r10
80007668:	10 99       	mov	r9,r8
8000766a:	97 1a       	st.w	r11[0x4],r10
8000766c:	c0 a8       	rjmp	80007680 <_malloc_r+0x1dc>
8000766e:	70 28       	ld.w	r8,r8[0x8]
80007670:	08 38       	cp.w	r8,r4
80007672:	c0 60       	breq	8000767e <_malloc_r+0x1da>
80007674:	70 1a       	ld.w	r10,r8[0x4]
80007676:	e0 1a ff fc 	andl	r10,0xfffc
8000767a:	14 39       	cp.w	r9,r10
8000767c:	cf 93       	brcs	8000766e <_malloc_r+0x1ca>
8000767e:	70 39       	ld.w	r9,r8[0xc]
80007680:	8d 39       	st.w	r6[0xc],r9
80007682:	8d 28       	st.w	r6[0x8],r8
80007684:	91 36       	st.w	r8[0xc],r6
80007686:	93 26       	st.w	r9[0x8],r6
80007688:	e6 08 14 02 	asr	r8,r3,0x2
8000768c:	30 1b       	mov	r11,1
8000768e:	e0 64 05 3c 	mov	r4,1340
80007692:	f6 08 09 4b 	lsl	r11,r11,r8
80007696:	68 18       	ld.w	r8,r4[0x4]
80007698:	10 3b       	cp.w	r11,r8
8000769a:	e0 8b 00 6b 	brhi	80007770 <_malloc_r+0x2cc>
8000769e:	f7 e8 00 09 	and	r9,r11,r8
800076a2:	c0 b1       	brne	800076b8 <_malloc_r+0x214>
800076a4:	e0 13 ff fc 	andl	r3,0xfffc
800076a8:	a1 7b       	lsl	r11,0x1
800076aa:	2f c3       	sub	r3,-4
800076ac:	c0 38       	rjmp	800076b2 <_malloc_r+0x20e>
800076ae:	2f c3       	sub	r3,-4
800076b0:	a1 7b       	lsl	r11,0x1
800076b2:	f7 e8 00 09 	and	r9,r11,r8
800076b6:	cf c0       	breq	800076ae <_malloc_r+0x20a>
800076b8:	e8 03 00 3e 	add	lr,r4,r3<<0x3
800076bc:	06 92       	mov	r2,r3
800076be:	1c 91       	mov	r1,lr
800076c0:	62 36       	ld.w	r6,r1[0xc]
800076c2:	c2 e8       	rjmp	8000771e <_malloc_r+0x27a>
800076c4:	6c 1a       	ld.w	r10,r6[0x4]
800076c6:	e0 1a ff fc 	andl	r10,0xfffc
800076ca:	f4 07 01 08 	sub	r8,r10,r7
800076ce:	58 f8       	cp.w	r8,15
800076d0:	e0 8a 00 15 	brle	800076fa <_malloc_r+0x256>
800076d4:	6c 3a       	ld.w	r10,r6[0xc]
800076d6:	6c 29       	ld.w	r9,r6[0x8]
800076d8:	95 29       	st.w	r10[0x8],r9
800076da:	93 3a       	st.w	r9[0xc],r10
800076dc:	0e 99       	mov	r9,r7
800076de:	ec 07 00 07 	add	r7,r6,r7
800076e2:	a1 a9       	sbr	r9,0x0
800076e4:	99 37       	st.w	r12[0xc],r7
800076e6:	99 27       	st.w	r12[0x8],r7
800076e8:	8d 19       	st.w	r6[0x4],r9
800076ea:	ee 08 09 08 	st.w	r7[r8],r8
800076ee:	8f 2c       	st.w	r7[0x8],r12
800076f0:	8f 3c       	st.w	r7[0xc],r12
800076f2:	a1 a8       	sbr	r8,0x0
800076f4:	0a 9c       	mov	r12,r5
800076f6:	8f 18       	st.w	r7[0x4],r8
800076f8:	c0 d8       	rjmp	80007712 <_malloc_r+0x26e>
800076fa:	6c 39       	ld.w	r9,r6[0xc]
800076fc:	58 08       	cp.w	r8,0
800076fe:	c0 f5       	brlt	8000771c <_malloc_r+0x278>
80007700:	ec 0a 00 0a 	add	r10,r6,r10
80007704:	74 18       	ld.w	r8,r10[0x4]
80007706:	a1 a8       	sbr	r8,0x0
80007708:	0a 9c       	mov	r12,r5
8000770a:	95 18       	st.w	r10[0x4],r8
8000770c:	6c 28       	ld.w	r8,r6[0x8]
8000770e:	93 28       	st.w	r9[0x8],r8
80007710:	91 39       	st.w	r8[0xc],r9
80007712:	fe b0 f4 89 	rcall	80006024 <__malloc_unlock>
80007716:	ec cc ff f8 	sub	r12,r6,-8
8000771a:	d8 32       	popm	r0-r7,pc
8000771c:	12 96       	mov	r6,r9
8000771e:	02 36       	cp.w	r6,r1
80007720:	cd 21       	brne	800076c4 <_malloc_r+0x220>
80007722:	2f f2       	sub	r2,-1
80007724:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
80007728:	c0 30       	breq	8000772e <_malloc_r+0x28a>
8000772a:	2f 81       	sub	r1,-8
8000772c:	cc ab       	rjmp	800076c0 <_malloc_r+0x21c>
8000772e:	1c 98       	mov	r8,lr
80007730:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
80007734:	c0 81       	brne	80007744 <_malloc_r+0x2a0>
80007736:	68 19       	ld.w	r9,r4[0x4]
80007738:	f6 08 11 ff 	rsub	r8,r11,-1
8000773c:	f3 e8 00 08 	and	r8,r9,r8
80007740:	89 18       	st.w	r4[0x4],r8
80007742:	c0 78       	rjmp	80007750 <_malloc_r+0x2ac>
80007744:	f0 c9 00 08 	sub	r9,r8,8
80007748:	20 13       	sub	r3,1
8000774a:	70 08       	ld.w	r8,r8[0x0]
8000774c:	12 38       	cp.w	r8,r9
8000774e:	cf 10       	breq	80007730 <_malloc_r+0x28c>
80007750:	a1 7b       	lsl	r11,0x1
80007752:	68 18       	ld.w	r8,r4[0x4]
80007754:	10 3b       	cp.w	r11,r8
80007756:	e0 8b 00 0d 	brhi	80007770 <_malloc_r+0x2cc>
8000775a:	58 0b       	cp.w	r11,0
8000775c:	c0 a0       	breq	80007770 <_malloc_r+0x2cc>
8000775e:	04 93       	mov	r3,r2
80007760:	c0 38       	rjmp	80007766 <_malloc_r+0x2c2>
80007762:	2f c3       	sub	r3,-4
80007764:	a1 7b       	lsl	r11,0x1
80007766:	f7 e8 00 09 	and	r9,r11,r8
8000776a:	ca 71       	brne	800076b8 <_malloc_r+0x214>
8000776c:	cf bb       	rjmp	80007762 <_malloc_r+0x2be>
8000776e:	d7 03       	nop
80007770:	68 23       	ld.w	r3,r4[0x8]
80007772:	66 12       	ld.w	r2,r3[0x4]
80007774:	e0 12 ff fc 	andl	r2,0xfffc
80007778:	0e 32       	cp.w	r2,r7
8000777a:	5f 39       	srlo	r9
8000777c:	e4 07 01 08 	sub	r8,r2,r7
80007780:	58 f8       	cp.w	r8,15
80007782:	5f aa       	srle	r10
80007784:	f5 e9 10 09 	or	r9,r10,r9
80007788:	e0 80 00 9a 	breq	800078bc <_malloc_r+0x418>
8000778c:	e0 68 0d 68 	mov	r8,3432
80007790:	70 01       	ld.w	r1,r8[0x0]
80007792:	e0 68 09 48 	mov	r8,2376
80007796:	2f 01       	sub	r1,-16
80007798:	70 08       	ld.w	r8,r8[0x0]
8000779a:	0e 01       	add	r1,r7
8000779c:	5b f8       	cp.w	r8,-1
8000779e:	c0 40       	breq	800077a6 <_malloc_r+0x302>
800077a0:	28 11       	sub	r1,-127
800077a2:	e0 11 ff 80 	andl	r1,0xff80
800077a6:	02 9b       	mov	r11,r1
800077a8:	0a 9c       	mov	r12,r5
800077aa:	e0 a0 02 a5 	rcall	80007cf4 <_sbrk_r>
800077ae:	18 96       	mov	r6,r12
800077b0:	5b fc       	cp.w	r12,-1
800077b2:	c7 50       	breq	8000789c <_malloc_r+0x3f8>
800077b4:	e6 02 00 08 	add	r8,r3,r2
800077b8:	10 3c       	cp.w	r12,r8
800077ba:	c0 32       	brcc	800077c0 <_malloc_r+0x31c>
800077bc:	08 33       	cp.w	r3,r4
800077be:	c6 f1       	brne	8000789c <_malloc_r+0x3f8>
800077c0:	e0 6a 0d 6c 	mov	r10,3436
800077c4:	74 09       	ld.w	r9,r10[0x0]
800077c6:	e2 09 00 09 	add	r9,r1,r9
800077ca:	95 09       	st.w	r10[0x0],r9
800077cc:	10 36       	cp.w	r6,r8
800077ce:	c0 a1       	brne	800077e2 <_malloc_r+0x33e>
800077d0:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
800077d4:	c0 71       	brne	800077e2 <_malloc_r+0x33e>
800077d6:	e2 02 00 02 	add	r2,r1,r2
800077da:	68 28       	ld.w	r8,r4[0x8]
800077dc:	a1 a2       	sbr	r2,0x0
800077de:	91 12       	st.w	r8[0x4],r2
800077e0:	c4 f8       	rjmp	8000787e <_malloc_r+0x3da>
800077e2:	e0 6a 09 48 	mov	r10,2376
800077e6:	74 0b       	ld.w	r11,r10[0x0]
800077e8:	5b fb       	cp.w	r11,-1
800077ea:	c0 31       	brne	800077f0 <_malloc_r+0x34c>
800077ec:	95 06       	st.w	r10[0x0],r6
800077ee:	c0 78       	rjmp	800077fc <_malloc_r+0x358>
800077f0:	ec 09 00 09 	add	r9,r6,r9
800077f4:	e0 6a 0d 6c 	mov	r10,3436
800077f8:	10 19       	sub	r9,r8
800077fa:	95 09       	st.w	r10[0x0],r9
800077fc:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
80007800:	f0 09 11 08 	rsub	r9,r8,8
80007804:	58 08       	cp.w	r8,0
80007806:	f2 08 17 10 	movne	r8,r9
8000780a:	ed d8 e1 06 	addne	r6,r6,r8
8000780e:	28 08       	sub	r8,-128
80007810:	ec 01 00 01 	add	r1,r6,r1
80007814:	0a 9c       	mov	r12,r5
80007816:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
8000781a:	f0 01 01 01 	sub	r1,r8,r1
8000781e:	02 9b       	mov	r11,r1
80007820:	e0 a0 02 6a 	rcall	80007cf4 <_sbrk_r>
80007824:	e0 68 0d 6c 	mov	r8,3436
80007828:	5b fc       	cp.w	r12,-1
8000782a:	ec 0c 17 00 	moveq	r12,r6
8000782e:	f9 b1 00 00 	moveq	r1,0
80007832:	70 09       	ld.w	r9,r8[0x0]
80007834:	0c 1c       	sub	r12,r6
80007836:	89 26       	st.w	r4[0x8],r6
80007838:	02 0c       	add	r12,r1
8000783a:	12 01       	add	r1,r9
8000783c:	a1 ac       	sbr	r12,0x0
8000783e:	91 01       	st.w	r8[0x0],r1
80007840:	8d 1c       	st.w	r6[0x4],r12
80007842:	08 33       	cp.w	r3,r4
80007844:	c1 d0       	breq	8000787e <_malloc_r+0x3da>
80007846:	58 f2       	cp.w	r2,15
80007848:	e0 8b 00 05 	brhi	80007852 <_malloc_r+0x3ae>
8000784c:	30 18       	mov	r8,1
8000784e:	8d 18       	st.w	r6[0x4],r8
80007850:	c2 68       	rjmp	8000789c <_malloc_r+0x3f8>
80007852:	30 59       	mov	r9,5
80007854:	20 c2       	sub	r2,12
80007856:	e0 12 ff f8 	andl	r2,0xfff8
8000785a:	e6 02 00 08 	add	r8,r3,r2
8000785e:	91 29       	st.w	r8[0x8],r9
80007860:	91 19       	st.w	r8[0x4],r9
80007862:	66 18       	ld.w	r8,r3[0x4]
80007864:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007868:	e5 e8 10 08 	or	r8,r2,r8
8000786c:	87 18       	st.w	r3[0x4],r8
8000786e:	58 f2       	cp.w	r2,15
80007870:	e0 88 00 07 	brls	8000787e <_malloc_r+0x3da>
80007874:	e6 cb ff f8 	sub	r11,r3,-8
80007878:	0a 9c       	mov	r12,r5
8000787a:	e0 a0 1c 6b 	rcall	8000b150 <_free_r>
8000787e:	e0 69 0d 64 	mov	r9,3428
80007882:	72 0a       	ld.w	r10,r9[0x0]
80007884:	e0 68 0d 6c 	mov	r8,3436
80007888:	70 08       	ld.w	r8,r8[0x0]
8000788a:	14 38       	cp.w	r8,r10
8000788c:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80007890:	e0 69 0d 60 	mov	r9,3424
80007894:	72 0a       	ld.w	r10,r9[0x0]
80007896:	14 38       	cp.w	r8,r10
80007898:	f3 f8 ba 00 	st.whi	r9[0x0],r8
8000789c:	68 28       	ld.w	r8,r4[0x8]
8000789e:	70 18       	ld.w	r8,r8[0x4]
800078a0:	e0 18 ff fc 	andl	r8,0xfffc
800078a4:	0e 38       	cp.w	r8,r7
800078a6:	5f 39       	srlo	r9
800078a8:	0e 18       	sub	r8,r7
800078aa:	58 f8       	cp.w	r8,15
800078ac:	5f aa       	srle	r10
800078ae:	f5 e9 10 09 	or	r9,r10,r9
800078b2:	c0 50       	breq	800078bc <_malloc_r+0x418>
800078b4:	0a 9c       	mov	r12,r5
800078b6:	fe b0 f3 b7 	rcall	80006024 <__malloc_unlock>
800078ba:	d8 3a       	popm	r0-r7,pc,r12=0
800078bc:	68 26       	ld.w	r6,r4[0x8]
800078be:	a1 a8       	sbr	r8,0x0
800078c0:	0e 99       	mov	r9,r7
800078c2:	a1 a9       	sbr	r9,0x0
800078c4:	8d 19       	st.w	r6[0x4],r9
800078c6:	ec 07 00 07 	add	r7,r6,r7
800078ca:	0a 9c       	mov	r12,r5
800078cc:	89 27       	st.w	r4[0x8],r7
800078ce:	8f 18       	st.w	r7[0x4],r8
800078d0:	fe b0 f3 aa 	rcall	80006024 <__malloc_unlock>
800078d4:	ec cc ff f8 	sub	r12,r6,-8
800078d8:	d8 32       	popm	r0-r7,pc
800078da:	d7 03       	nop

800078dc <memcpy>:
800078dc:	58 8a       	cp.w	r10,8
800078de:	c2 f5       	brlt	8000793c <memcpy+0x60>
800078e0:	f9 eb 10 09 	or	r9,r12,r11
800078e4:	e2 19 00 03 	andl	r9,0x3,COH
800078e8:	e0 81 00 97 	brne	80007a16 <memcpy+0x13a>
800078ec:	e0 4a 00 20 	cp.w	r10,32
800078f0:	c3 b4       	brge	80007966 <memcpy+0x8a>
800078f2:	f4 08 14 02 	asr	r8,r10,0x2
800078f6:	f0 09 11 08 	rsub	r9,r8,8
800078fa:	fe 09 00 2f 	add	pc,pc,r9<<0x2
800078fe:	76 69       	ld.w	r9,r11[0x18]
80007900:	99 69       	st.w	r12[0x18],r9
80007902:	76 59       	ld.w	r9,r11[0x14]
80007904:	99 59       	st.w	r12[0x14],r9
80007906:	76 49       	ld.w	r9,r11[0x10]
80007908:	99 49       	st.w	r12[0x10],r9
8000790a:	76 39       	ld.w	r9,r11[0xc]
8000790c:	99 39       	st.w	r12[0xc],r9
8000790e:	76 29       	ld.w	r9,r11[0x8]
80007910:	99 29       	st.w	r12[0x8],r9
80007912:	76 19       	ld.w	r9,r11[0x4]
80007914:	99 19       	st.w	r12[0x4],r9
80007916:	76 09       	ld.w	r9,r11[0x0]
80007918:	99 09       	st.w	r12[0x0],r9
8000791a:	f6 08 00 2b 	add	r11,r11,r8<<0x2
8000791e:	f8 08 00 28 	add	r8,r12,r8<<0x2
80007922:	e0 1a 00 03 	andl	r10,0x3
80007926:	f4 0a 11 04 	rsub	r10,r10,4
8000792a:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
8000792e:	17 a9       	ld.ub	r9,r11[0x2]
80007930:	b0 a9       	st.b	r8[0x2],r9
80007932:	17 99       	ld.ub	r9,r11[0x1]
80007934:	b0 99       	st.b	r8[0x1],r9
80007936:	17 89       	ld.ub	r9,r11[0x0]
80007938:	b0 89       	st.b	r8[0x0],r9
8000793a:	5e fc       	retal	r12
8000793c:	f4 0a 11 09 	rsub	r10,r10,9
80007940:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
80007944:	17 f9       	ld.ub	r9,r11[0x7]
80007946:	b8 f9       	st.b	r12[0x7],r9
80007948:	17 e9       	ld.ub	r9,r11[0x6]
8000794a:	b8 e9       	st.b	r12[0x6],r9
8000794c:	17 d9       	ld.ub	r9,r11[0x5]
8000794e:	b8 d9       	st.b	r12[0x5],r9
80007950:	17 c9       	ld.ub	r9,r11[0x4]
80007952:	b8 c9       	st.b	r12[0x4],r9
80007954:	17 b9       	ld.ub	r9,r11[0x3]
80007956:	b8 b9       	st.b	r12[0x3],r9
80007958:	17 a9       	ld.ub	r9,r11[0x2]
8000795a:	b8 a9       	st.b	r12[0x2],r9
8000795c:	17 99       	ld.ub	r9,r11[0x1]
8000795e:	b8 99       	st.b	r12[0x1],r9
80007960:	17 89       	ld.ub	r9,r11[0x0]
80007962:	b8 89       	st.b	r12[0x0],r9
80007964:	5e fc       	retal	r12
80007966:	eb cd 40 c0 	pushm	r6-r7,lr
8000796a:	18 99       	mov	r9,r12
8000796c:	22 0a       	sub	r10,32
8000796e:	b7 07       	ld.d	r6,r11++
80007970:	b3 26       	st.d	r9++,r6
80007972:	b7 07       	ld.d	r6,r11++
80007974:	b3 26       	st.d	r9++,r6
80007976:	b7 07       	ld.d	r6,r11++
80007978:	b3 26       	st.d	r9++,r6
8000797a:	b7 07       	ld.d	r6,r11++
8000797c:	b3 26       	st.d	r9++,r6
8000797e:	22 0a       	sub	r10,32
80007980:	cf 74       	brge	8000796e <memcpy+0x92>
80007982:	2f 0a       	sub	r10,-16
80007984:	c0 65       	brlt	80007990 <memcpy+0xb4>
80007986:	b7 07       	ld.d	r6,r11++
80007988:	b3 26       	st.d	r9++,r6
8000798a:	b7 07       	ld.d	r6,r11++
8000798c:	b3 26       	st.d	r9++,r6
8000798e:	21 0a       	sub	r10,16
80007990:	5c 3a       	neg	r10
80007992:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
80007996:	d7 03       	nop
80007998:	d7 03       	nop
8000799a:	f7 36 00 0e 	ld.ub	r6,r11[14]
8000799e:	f3 66 00 0e 	st.b	r9[14],r6
800079a2:	f7 36 00 0d 	ld.ub	r6,r11[13]
800079a6:	f3 66 00 0d 	st.b	r9[13],r6
800079aa:	f7 36 00 0c 	ld.ub	r6,r11[12]
800079ae:	f3 66 00 0c 	st.b	r9[12],r6
800079b2:	f7 36 00 0b 	ld.ub	r6,r11[11]
800079b6:	f3 66 00 0b 	st.b	r9[11],r6
800079ba:	f7 36 00 0a 	ld.ub	r6,r11[10]
800079be:	f3 66 00 0a 	st.b	r9[10],r6
800079c2:	f7 36 00 09 	ld.ub	r6,r11[9]
800079c6:	f3 66 00 09 	st.b	r9[9],r6
800079ca:	f7 36 00 08 	ld.ub	r6,r11[8]
800079ce:	f3 66 00 08 	st.b	r9[8],r6
800079d2:	f7 36 00 07 	ld.ub	r6,r11[7]
800079d6:	f3 66 00 07 	st.b	r9[7],r6
800079da:	f7 36 00 06 	ld.ub	r6,r11[6]
800079de:	f3 66 00 06 	st.b	r9[6],r6
800079e2:	f7 36 00 05 	ld.ub	r6,r11[5]
800079e6:	f3 66 00 05 	st.b	r9[5],r6
800079ea:	f7 36 00 04 	ld.ub	r6,r11[4]
800079ee:	f3 66 00 04 	st.b	r9[4],r6
800079f2:	f7 36 00 03 	ld.ub	r6,r11[3]
800079f6:	f3 66 00 03 	st.b	r9[3],r6
800079fa:	f7 36 00 02 	ld.ub	r6,r11[2]
800079fe:	f3 66 00 02 	st.b	r9[2],r6
80007a02:	f7 36 00 01 	ld.ub	r6,r11[1]
80007a06:	f3 66 00 01 	st.b	r9[1],r6
80007a0a:	f7 36 00 00 	ld.ub	r6,r11[0]
80007a0e:	f3 66 00 00 	st.b	r9[0],r6
80007a12:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80007a16:	20 1a       	sub	r10,1
80007a18:	f6 0a 07 09 	ld.ub	r9,r11[r10]
80007a1c:	f8 0a 0b 09 	st.b	r12[r10],r9
80007a20:	cf b1       	brne	80007a16 <memcpy+0x13a>
80007a22:	5e fc       	retal	r12

80007a24 <memset>:
80007a24:	18 98       	mov	r8,r12
80007a26:	c0 38       	rjmp	80007a2c <memset+0x8>
80007a28:	10 cb       	st.b	r8++,r11
80007a2a:	20 1a       	sub	r10,1
80007a2c:	58 0a       	cp.w	r10,0
80007a2e:	cf d1       	brne	80007a28 <memset+0x4>
80007a30:	5e fc       	retal	r12
80007a32:	d7 03       	nop

80007a34 <_realloc_r>:
80007a34:	d4 31       	pushm	r0-r7,lr
80007a36:	20 1d       	sub	sp,4
80007a38:	16 94       	mov	r4,r11
80007a3a:	18 92       	mov	r2,r12
80007a3c:	14 9b       	mov	r11,r10
80007a3e:	58 04       	cp.w	r4,0
80007a40:	c0 51       	brne	80007a4a <_realloc_r+0x16>
80007a42:	fe b0 fd 31 	rcall	800074a4 <_malloc_r>
80007a46:	18 95       	mov	r5,r12
80007a48:	c5 39       	rjmp	80007cee <_realloc_r+0x2ba>
80007a4a:	50 0a       	stdsp	sp[0x0],r10
80007a4c:	fe b0 f2 e6 	rcall	80006018 <__malloc_lock>
80007a50:	40 0b       	lddsp	r11,sp[0x0]
80007a52:	f6 c8 ff f5 	sub	r8,r11,-11
80007a56:	e8 c1 00 08 	sub	r1,r4,8
80007a5a:	10 96       	mov	r6,r8
80007a5c:	62 1c       	ld.w	r12,r1[0x4]
80007a5e:	e0 16 ff f8 	andl	r6,0xfff8
80007a62:	59 68       	cp.w	r8,22
80007a64:	f9 b6 08 10 	movls	r6,16
80007a68:	16 36       	cp.w	r6,r11
80007a6a:	5f 38       	srlo	r8
80007a6c:	f1 e6 13 f8 	or	r8,r8,r6>>0x1f
80007a70:	c0 50       	breq	80007a7a <_realloc_r+0x46>
80007a72:	30 c8       	mov	r8,12
80007a74:	30 05       	mov	r5,0
80007a76:	85 38       	st.w	r2[0xc],r8
80007a78:	c3 b9       	rjmp	80007cee <_realloc_r+0x2ba>
80007a7a:	18 90       	mov	r0,r12
80007a7c:	e0 10 ff fc 	andl	r0,0xfffc
80007a80:	0c 30       	cp.w	r0,r6
80007a82:	e0 84 01 0b 	brge	80007c98 <_realloc_r+0x264>
80007a86:	e0 68 05 3c 	mov	r8,1340
80007a8a:	e2 00 00 09 	add	r9,r1,r0
80007a8e:	70 25       	ld.w	r5,r8[0x8]
80007a90:	0a 39       	cp.w	r9,r5
80007a92:	c0 90       	breq	80007aa4 <_realloc_r+0x70>
80007a94:	72 1a       	ld.w	r10,r9[0x4]
80007a96:	a1 ca       	cbr	r10,0x0
80007a98:	f2 0a 00 0a 	add	r10,r9,r10
80007a9c:	74 1a       	ld.w	r10,r10[0x4]
80007a9e:	ed ba 00 00 	bld	r10,0x0
80007aa2:	c2 20       	breq	80007ae6 <_realloc_r+0xb2>
80007aa4:	72 1a       	ld.w	r10,r9[0x4]
80007aa6:	e0 1a ff fc 	andl	r10,0xfffc
80007aaa:	f4 00 00 03 	add	r3,r10,r0
80007aae:	0a 39       	cp.w	r9,r5
80007ab0:	c1 31       	brne	80007ad6 <_realloc_r+0xa2>
80007ab2:	ec c7 ff f0 	sub	r7,r6,-16
80007ab6:	0e 33       	cp.w	r3,r7
80007ab8:	c1 95       	brlt	80007aea <_realloc_r+0xb6>
80007aba:	e2 06 00 09 	add	r9,r1,r6
80007abe:	0c 13       	sub	r3,r6
80007ac0:	a1 a3       	sbr	r3,0x0
80007ac2:	93 13       	st.w	r9[0x4],r3
80007ac4:	91 29       	st.w	r8[0x8],r9
80007ac6:	04 9c       	mov	r12,r2
80007ac8:	62 18       	ld.w	r8,r1[0x4]
80007aca:	08 95       	mov	r5,r4
80007acc:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007ad0:	10 46       	or	r6,r8
80007ad2:	83 16       	st.w	r1[0x4],r6
80007ad4:	c0 b9       	rjmp	80007cea <_realloc_r+0x2b6>
80007ad6:	0c 33       	cp.w	r3,r6
80007ad8:	c0 95       	brlt	80007aea <_realloc_r+0xb6>
80007ada:	72 28       	ld.w	r8,r9[0x8]
80007adc:	02 97       	mov	r7,r1
80007ade:	72 39       	ld.w	r9,r9[0xc]
80007ae0:	93 28       	st.w	r9[0x8],r8
80007ae2:	91 39       	st.w	r8[0xc],r9
80007ae4:	cd c8       	rjmp	80007c9c <_realloc_r+0x268>
80007ae6:	30 0a       	mov	r10,0
80007ae8:	14 99       	mov	r9,r10
80007aea:	ed bc 00 00 	bld	r12,0x0
80007aee:	e0 80 00 95 	breq	80007c18 <_realloc_r+0x1e4>
80007af2:	62 07       	ld.w	r7,r1[0x0]
80007af4:	e2 07 01 07 	sub	r7,r1,r7
80007af8:	6e 1c       	ld.w	r12,r7[0x4]
80007afa:	e0 1c ff fc 	andl	r12,0xfffc
80007afe:	58 09       	cp.w	r9,0
80007b00:	c5 60       	breq	80007bac <_realloc_r+0x178>
80007b02:	f8 00 00 03 	add	r3,r12,r0
80007b06:	0a 39       	cp.w	r9,r5
80007b08:	c4 81       	brne	80007b98 <_realloc_r+0x164>
80007b0a:	14 03       	add	r3,r10
80007b0c:	ec c9 ff f0 	sub	r9,r6,-16
80007b10:	12 33       	cp.w	r3,r9
80007b12:	c4 d5       	brlt	80007bac <_realloc_r+0x178>
80007b14:	6e 3a       	ld.w	r10,r7[0xc]
80007b16:	6e 29       	ld.w	r9,r7[0x8]
80007b18:	95 29       	st.w	r10[0x8],r9
80007b1a:	93 3a       	st.w	r9[0xc],r10
80007b1c:	ee c5 ff f8 	sub	r5,r7,-8
80007b20:	e0 ca 00 04 	sub	r10,r0,4
80007b24:	e0 4a 00 24 	cp.w	r10,36
80007b28:	e0 8b 00 25 	brhi	80007b72 <_realloc_r+0x13e>
80007b2c:	0a 99       	mov	r9,r5
80007b2e:	59 3a       	cp.w	r10,19
80007b30:	e0 88 00 1a 	brls	80007b64 <_realloc_r+0x130>
80007b34:	09 09       	ld.w	r9,r4++
80007b36:	8b 09       	st.w	r5[0x0],r9
80007b38:	09 09       	ld.w	r9,r4++
80007b3a:	8f 39       	st.w	r7[0xc],r9
80007b3c:	ee c9 ff f0 	sub	r9,r7,-16
80007b40:	59 ba       	cp.w	r10,27
80007b42:	e0 88 00 11 	brls	80007b64 <_realloc_r+0x130>
80007b46:	09 0b       	ld.w	r11,r4++
80007b48:	93 0b       	st.w	r9[0x0],r11
80007b4a:	09 09       	ld.w	r9,r4++
80007b4c:	8f 59       	st.w	r7[0x14],r9
80007b4e:	ee c9 ff e8 	sub	r9,r7,-24
80007b52:	e0 4a 00 24 	cp.w	r10,36
80007b56:	c0 71       	brne	80007b64 <_realloc_r+0x130>
80007b58:	09 0a       	ld.w	r10,r4++
80007b5a:	93 0a       	st.w	r9[0x0],r10
80007b5c:	ee c9 ff e0 	sub	r9,r7,-32
80007b60:	09 0a       	ld.w	r10,r4++
80007b62:	8f 7a       	st.w	r7[0x1c],r10
80007b64:	09 0a       	ld.w	r10,r4++
80007b66:	12 aa       	st.w	r9++,r10
80007b68:	68 0a       	ld.w	r10,r4[0x0]
80007b6a:	93 0a       	st.w	r9[0x0],r10
80007b6c:	68 1a       	ld.w	r10,r4[0x4]
80007b6e:	93 1a       	st.w	r9[0x4],r10
80007b70:	c0 78       	rjmp	80007b7e <_realloc_r+0x14a>
80007b72:	50 08       	stdsp	sp[0x0],r8
80007b74:	08 9b       	mov	r11,r4
80007b76:	0a 9c       	mov	r12,r5
80007b78:	e0 a0 1d 8f 	rcall	8000b696 <memmove>
80007b7c:	40 08       	lddsp	r8,sp[0x0]
80007b7e:	ee 06 00 09 	add	r9,r7,r6
80007b82:	0c 13       	sub	r3,r6
80007b84:	a1 a3       	sbr	r3,0x0
80007b86:	93 13       	st.w	r9[0x4],r3
80007b88:	91 29       	st.w	r8[0x8],r9
80007b8a:	04 9c       	mov	r12,r2
80007b8c:	6e 18       	ld.w	r8,r7[0x4]
80007b8e:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007b92:	10 46       	or	r6,r8
80007b94:	8f 16       	st.w	r7[0x4],r6
80007b96:	ca a8       	rjmp	80007cea <_realloc_r+0x2b6>
80007b98:	14 03       	add	r3,r10
80007b9a:	0c 33       	cp.w	r3,r6
80007b9c:	c0 85       	brlt	80007bac <_realloc_r+0x178>
80007b9e:	72 28       	ld.w	r8,r9[0x8]
80007ba0:	72 39       	ld.w	r9,r9[0xc]
80007ba2:	93 28       	st.w	r9[0x8],r8
80007ba4:	91 39       	st.w	r8[0xc],r9
80007ba6:	6e 28       	ld.w	r8,r7[0x8]
80007ba8:	6e 39       	ld.w	r9,r7[0xc]
80007baa:	c0 78       	rjmp	80007bb8 <_realloc_r+0x184>
80007bac:	f8 00 00 03 	add	r3,r12,r0
80007bb0:	0c 33       	cp.w	r3,r6
80007bb2:	c3 35       	brlt	80007c18 <_realloc_r+0x1e4>
80007bb4:	6e 39       	ld.w	r9,r7[0xc]
80007bb6:	6e 28       	ld.w	r8,r7[0x8]
80007bb8:	93 28       	st.w	r9[0x8],r8
80007bba:	91 39       	st.w	r8[0xc],r9
80007bbc:	e0 ca 00 04 	sub	r10,r0,4
80007bc0:	ee cc ff f8 	sub	r12,r7,-8
80007bc4:	e0 4a 00 24 	cp.w	r10,36
80007bc8:	e0 8b 00 24 	brhi	80007c10 <_realloc_r+0x1dc>
80007bcc:	59 3a       	cp.w	r10,19
80007bce:	e0 88 00 1a 	brls	80007c02 <_realloc_r+0x1ce>
80007bd2:	09 08       	ld.w	r8,r4++
80007bd4:	99 08       	st.w	r12[0x0],r8
80007bd6:	09 08       	ld.w	r8,r4++
80007bd8:	8f 38       	st.w	r7[0xc],r8
80007bda:	ee cc ff f0 	sub	r12,r7,-16
80007bde:	59 ba       	cp.w	r10,27
80007be0:	e0 88 00 11 	brls	80007c02 <_realloc_r+0x1ce>
80007be4:	09 08       	ld.w	r8,r4++
80007be6:	99 08       	st.w	r12[0x0],r8
80007be8:	09 08       	ld.w	r8,r4++
80007bea:	8f 58       	st.w	r7[0x14],r8
80007bec:	ee cc ff e8 	sub	r12,r7,-24
80007bf0:	e0 4a 00 24 	cp.w	r10,36
80007bf4:	c0 71       	brne	80007c02 <_realloc_r+0x1ce>
80007bf6:	09 08       	ld.w	r8,r4++
80007bf8:	99 08       	st.w	r12[0x0],r8
80007bfa:	ee cc ff e0 	sub	r12,r7,-32
80007bfe:	09 08       	ld.w	r8,r4++
80007c00:	8f 78       	st.w	r7[0x1c],r8
80007c02:	09 08       	ld.w	r8,r4++
80007c04:	18 a8       	st.w	r12++,r8
80007c06:	68 08       	ld.w	r8,r4[0x0]
80007c08:	99 08       	st.w	r12[0x0],r8
80007c0a:	68 18       	ld.w	r8,r4[0x4]
80007c0c:	99 18       	st.w	r12[0x4],r8
80007c0e:	c4 78       	rjmp	80007c9c <_realloc_r+0x268>
80007c10:	08 9b       	mov	r11,r4
80007c12:	e0 a0 1d 42 	rcall	8000b696 <memmove>
80007c16:	c4 38       	rjmp	80007c9c <_realloc_r+0x268>
80007c18:	04 9c       	mov	r12,r2
80007c1a:	fe b0 fc 45 	rcall	800074a4 <_malloc_r>
80007c1e:	18 95       	mov	r5,r12
80007c20:	c3 a0       	breq	80007c94 <_realloc_r+0x260>
80007c22:	62 18       	ld.w	r8,r1[0x4]
80007c24:	f8 c9 00 08 	sub	r9,r12,8
80007c28:	a1 c8       	cbr	r8,0x0
80007c2a:	e2 08 00 08 	add	r8,r1,r8
80007c2e:	10 39       	cp.w	r9,r8
80007c30:	c0 71       	brne	80007c3e <_realloc_r+0x20a>
80007c32:	72 13       	ld.w	r3,r9[0x4]
80007c34:	02 97       	mov	r7,r1
80007c36:	e0 13 ff fc 	andl	r3,0xfffc
80007c3a:	00 03       	add	r3,r0
80007c3c:	c3 08       	rjmp	80007c9c <_realloc_r+0x268>
80007c3e:	e0 ca 00 04 	sub	r10,r0,4
80007c42:	e0 4a 00 24 	cp.w	r10,36
80007c46:	e0 8b 00 20 	brhi	80007c86 <_realloc_r+0x252>
80007c4a:	08 99       	mov	r9,r4
80007c4c:	18 98       	mov	r8,r12
80007c4e:	59 3a       	cp.w	r10,19
80007c50:	e0 88 00 14 	brls	80007c78 <_realloc_r+0x244>
80007c54:	13 0b       	ld.w	r11,r9++
80007c56:	10 ab       	st.w	r8++,r11
80007c58:	13 0b       	ld.w	r11,r9++
80007c5a:	10 ab       	st.w	r8++,r11
80007c5c:	59 ba       	cp.w	r10,27
80007c5e:	e0 88 00 0d 	brls	80007c78 <_realloc_r+0x244>
80007c62:	13 0b       	ld.w	r11,r9++
80007c64:	10 ab       	st.w	r8++,r11
80007c66:	13 0b       	ld.w	r11,r9++
80007c68:	10 ab       	st.w	r8++,r11
80007c6a:	e0 4a 00 24 	cp.w	r10,36
80007c6e:	c0 51       	brne	80007c78 <_realloc_r+0x244>
80007c70:	13 0a       	ld.w	r10,r9++
80007c72:	10 aa       	st.w	r8++,r10
80007c74:	13 0a       	ld.w	r10,r9++
80007c76:	10 aa       	st.w	r8++,r10
80007c78:	13 0a       	ld.w	r10,r9++
80007c7a:	10 aa       	st.w	r8++,r10
80007c7c:	72 0a       	ld.w	r10,r9[0x0]
80007c7e:	91 0a       	st.w	r8[0x0],r10
80007c80:	72 19       	ld.w	r9,r9[0x4]
80007c82:	91 19       	st.w	r8[0x4],r9
80007c84:	c0 48       	rjmp	80007c8c <_realloc_r+0x258>
80007c86:	08 9b       	mov	r11,r4
80007c88:	e0 a0 1d 07 	rcall	8000b696 <memmove>
80007c8c:	08 9b       	mov	r11,r4
80007c8e:	04 9c       	mov	r12,r2
80007c90:	e0 a0 1a 60 	rcall	8000b150 <_free_r>
80007c94:	04 9c       	mov	r12,r2
80007c96:	c2 a8       	rjmp	80007cea <_realloc_r+0x2b6>
80007c98:	00 93       	mov	r3,r0
80007c9a:	02 97       	mov	r7,r1
80007c9c:	e6 06 01 09 	sub	r9,r3,r6
80007ca0:	6e 18       	ld.w	r8,r7[0x4]
80007ca2:	58 f9       	cp.w	r9,15
80007ca4:	e0 88 00 16 	brls	80007cd0 <_realloc_r+0x29c>
80007ca8:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007cac:	ed e8 10 08 	or	r8,r6,r8
80007cb0:	8f 18       	st.w	r7[0x4],r8
80007cb2:	12 98       	mov	r8,r9
80007cb4:	a1 a8       	sbr	r8,0x0
80007cb6:	ee 06 00 0b 	add	r11,r7,r6
80007cba:	f6 09 00 09 	add	r9,r11,r9
80007cbe:	97 18       	st.w	r11[0x4],r8
80007cc0:	72 18       	ld.w	r8,r9[0x4]
80007cc2:	a1 a8       	sbr	r8,0x0
80007cc4:	2f 8b       	sub	r11,-8
80007cc6:	93 18       	st.w	r9[0x4],r8
80007cc8:	04 9c       	mov	r12,r2
80007cca:	e0 a0 1a 43 	rcall	8000b150 <_free_r>
80007cce:	c0 b8       	rjmp	80007ce4 <_realloc_r+0x2b0>
80007cd0:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007cd4:	e7 e8 10 08 	or	r8,r3,r8
80007cd8:	8f 18       	st.w	r7[0x4],r8
80007cda:	ee 03 00 03 	add	r3,r7,r3
80007cde:	66 18       	ld.w	r8,r3[0x4]
80007ce0:	a1 a8       	sbr	r8,0x0
80007ce2:	87 18       	st.w	r3[0x4],r8
80007ce4:	04 9c       	mov	r12,r2
80007ce6:	ee c5 ff f8 	sub	r5,r7,-8
80007cea:	fe b0 f1 9d 	rcall	80006024 <__malloc_unlock>
80007cee:	0a 9c       	mov	r12,r5
80007cf0:	2f fd       	sub	sp,-4
80007cf2:	d8 32       	popm	r0-r7,pc

80007cf4 <_sbrk_r>:
80007cf4:	d4 21       	pushm	r4-r7,lr
80007cf6:	30 08       	mov	r8,0
80007cf8:	18 97       	mov	r7,r12
80007cfa:	e0 66 bf f4 	mov	r6,49140
80007cfe:	16 9c       	mov	r12,r11
80007d00:	8d 08       	st.w	r6[0x0],r8
80007d02:	c8 5c       	rcall	80007e0c <_sbrk>
80007d04:	5b fc       	cp.w	r12,-1
80007d06:	c0 51       	brne	80007d10 <_sbrk_r+0x1c>
80007d08:	6c 08       	ld.w	r8,r6[0x0]
80007d0a:	58 08       	cp.w	r8,0
80007d0c:	ef f8 1a 03 	st.wne	r7[0xc],r8
80007d10:	d8 22       	popm	r4-r7,pc
80007d12:	d7 03       	nop

80007d14 <sprintf>:
80007d14:	d4 01       	pushm	lr
80007d16:	21 7d       	sub	sp,92
80007d18:	e0 68 ff ff 	mov	r8,65535
80007d1c:	ea 18 7f ff 	orh	r8,0x7fff
80007d20:	50 58       	stdsp	sp[0x14],r8
80007d22:	50 28       	stdsp	sp[0x8],r8
80007d24:	e0 68 02 08 	mov	r8,520
80007d28:	ba 68       	st.h	sp[0xc],r8
80007d2a:	3f f8       	mov	r8,-1
80007d2c:	ba 78       	st.h	sp[0xe],r8
80007d2e:	e0 68 0a 3c 	mov	r8,2620
80007d32:	50 4c       	stdsp	sp[0x10],r12
80007d34:	16 9a       	mov	r10,r11
80007d36:	50 0c       	stdsp	sp[0x0],r12
80007d38:	fa c9 ff a0 	sub	r9,sp,-96
80007d3c:	70 0c       	ld.w	r12,r8[0x0]
80007d3e:	1a 9b       	mov	r11,sp
80007d40:	e0 a0 02 1a 	rcall	80008174 <_vfprintf_r>
80007d44:	30 09       	mov	r9,0
80007d46:	40 08       	lddsp	r8,sp[0x0]
80007d48:	b0 89       	st.b	r8[0x0],r9
80007d4a:	2e 9d       	sub	sp,-92
80007d4c:	d8 02       	popm	pc
80007d4e:	d7 03       	nop

80007d50 <strncpy>:
80007d50:	30 08       	mov	r8,0
80007d52:	10 3a       	cp.w	r10,r8
80007d54:	5e 0c       	reteq	r12
80007d56:	f6 08 07 09 	ld.ub	r9,r11[r8]
80007d5a:	f8 08 0b 09 	st.b	r12[r8],r9
80007d5e:	2f f8       	sub	r8,-1
80007d60:	58 09       	cp.w	r9,0
80007d62:	cf 81       	brne	80007d52 <strncpy+0x2>
80007d64:	10 3a       	cp.w	r10,r8
80007d66:	5e 0c       	reteq	r12
80007d68:	f8 08 0b 09 	st.b	r12[r8],r9
80007d6c:	2f f8       	sub	r8,-1
80007d6e:	cf bb       	rjmp	80007d64 <strncpy+0x14>

80007d70 <_close>:
80007d70:	30 28       	mov	r8,2
80007d72:	d6 73       	breakpoint
80007d74:	3f fc       	mov	r12,-1
80007d76:	35 8b       	mov	r11,88
80007d78:	58 0c       	cp.w	r12,0
80007d7a:	5e 4c       	retge	r12
80007d7c:	e0 6a bf f4 	mov	r10,49140
80007d80:	95 0b       	st.w	r10[0x0],r11
80007d82:	5e fc       	retal	r12

80007d84 <_lseek>:
80007d84:	30 58       	mov	r8,5
80007d86:	d6 73       	breakpoint
80007d88:	3f fc       	mov	r12,-1
80007d8a:	35 8b       	mov	r11,88
80007d8c:	58 0c       	cp.w	r12,0
80007d8e:	5e 4c       	retge	r12
80007d90:	e0 6a bf f4 	mov	r10,49140
80007d94:	95 0b       	st.w	r10[0x0],r11
80007d96:	5e fc       	retal	r12

80007d98 <isatty>:
80007d98:	30 b8       	mov	r8,11
80007d9a:	d6 73       	breakpoint
80007d9c:	3f fc       	mov	r12,-1
80007d9e:	35 8b       	mov	r11,88
80007da0:	58 0c       	cp.w	r12,0
80007da2:	5e 4c       	retge	r12
80007da4:	e0 6a bf f4 	mov	r10,49140
80007da8:	95 0b       	st.w	r10[0x0],r11
80007daa:	5e fc       	retal	r12

80007dac <_fstat_host>:
80007dac:	30 98       	mov	r8,9
80007dae:	d6 73       	breakpoint
80007db0:	3f fc       	mov	r12,-1
80007db2:	35 8b       	mov	r11,88
80007db4:	58 0c       	cp.w	r12,0
80007db6:	5e 4c       	retge	r12
80007db8:	e0 6a bf f4 	mov	r10,49140
80007dbc:	95 0b       	st.w	r10[0x0],r11
80007dbe:	5e fc       	retal	r12

80007dc0 <_fstat>:
80007dc0:	d4 21       	pushm	r4-r7,lr
80007dc2:	21 0d       	sub	sp,64
80007dc4:	16 97       	mov	r7,r11
80007dc6:	1a 9b       	mov	r11,sp
80007dc8:	cf 2f       	rcall	80007dac <_fstat_host>
80007dca:	c0 34       	brge	80007dd0 <_fstat+0x10>
80007dcc:	3f fc       	mov	r12,-1
80007dce:	c1 c8       	rjmp	80007e06 <_fstat+0x46>
80007dd0:	40 08       	lddsp	r8,sp[0x0]
80007dd2:	ae 08       	st.h	r7[0x0],r8
80007dd4:	40 18       	lddsp	r8,sp[0x4]
80007dd6:	ae 18       	st.h	r7[0x2],r8
80007dd8:	40 28       	lddsp	r8,sp[0x8]
80007dda:	8f 18       	st.w	r7[0x4],r8
80007ddc:	40 38       	lddsp	r8,sp[0xc]
80007dde:	ae 48       	st.h	r7[0x8],r8
80007de0:	40 48       	lddsp	r8,sp[0x10]
80007de2:	ae 58       	st.h	r7[0xa],r8
80007de4:	40 58       	lddsp	r8,sp[0x14]
80007de6:	ae 68       	st.h	r7[0xc],r8
80007de8:	40 68       	lddsp	r8,sp[0x18]
80007dea:	ae 78       	st.h	r7[0xe],r8
80007dec:	40 88       	lddsp	r8,sp[0x20]
80007dee:	8f 48       	st.w	r7[0x10],r8
80007df0:	40 a8       	lddsp	r8,sp[0x28]
80007df2:	8f b8       	st.w	r7[0x2c],r8
80007df4:	40 c8       	lddsp	r8,sp[0x30]
80007df6:	8f c8       	st.w	r7[0x30],r8
80007df8:	40 d8       	lddsp	r8,sp[0x34]
80007dfa:	8f 58       	st.w	r7[0x14],r8
80007dfc:	40 e8       	lddsp	r8,sp[0x38]
80007dfe:	30 0c       	mov	r12,0
80007e00:	8f 78       	st.w	r7[0x1c],r8
80007e02:	40 f8       	lddsp	r8,sp[0x3c]
80007e04:	8f 98       	st.w	r7[0x24],r8
80007e06:	2f 0d       	sub	sp,-64
80007e08:	d8 22       	popm	r4-r7,pc
80007e0a:	d7 03       	nop

80007e0c <_sbrk>:
80007e0c:	d4 01       	pushm	lr
80007e0e:	e0 68 0d 94 	mov	r8,3476
80007e12:	70 09       	ld.w	r9,r8[0x0]
80007e14:	58 09       	cp.w	r9,0
80007e16:	c0 41       	brne	80007e1e <_sbrk+0x12>
80007e18:	e0 69 bf f8 	mov	r9,49144
80007e1c:	91 09       	st.w	r8[0x0],r9
80007e1e:	e0 69 0d 94 	mov	r9,3476
80007e22:	e0 7a 70 00 	mov	r10,94208
80007e26:	72 08       	ld.w	r8,r9[0x0]
80007e28:	f0 0c 00 0c 	add	r12,r8,r12
80007e2c:	14 3c       	cp.w	r12,r10
80007e2e:	e0 8b 00 04 	brhi	80007e36 <_sbrk+0x2a>
80007e32:	93 0c       	st.w	r9[0x0],r12
80007e34:	c0 68       	rjmp	80007e40 <_sbrk+0x34>
80007e36:	e0 a0 18 15 	rcall	8000ae60 <__errno>
80007e3a:	30 c8       	mov	r8,12
80007e3c:	99 08       	st.w	r12[0x0],r8
80007e3e:	3f f8       	mov	r8,-1
80007e40:	10 9c       	mov	r12,r8
80007e42:	d8 02       	popm	pc

80007e44 <get_arg>:
80007e44:	d4 31       	pushm	r0-r7,lr
80007e46:	20 8d       	sub	sp,32
80007e48:	fa c4 ff bc 	sub	r4,sp,-68
80007e4c:	50 4b       	stdsp	sp[0x10],r11
80007e4e:	68 2e       	ld.w	lr,r4[0x8]
80007e50:	50 58       	stdsp	sp[0x14],r8
80007e52:	12 96       	mov	r6,r9
80007e54:	7c 0b       	ld.w	r11,lr[0x0]
80007e56:	70 05       	ld.w	r5,r8[0x0]
80007e58:	50 6e       	stdsp	sp[0x18],lr
80007e5a:	58 0b       	cp.w	r11,0
80007e5c:	f4 0b 17 00 	moveq	r11,r10
80007e60:	68 03       	ld.w	r3,r4[0x0]
80007e62:	68 11       	ld.w	r1,r4[0x4]
80007e64:	40 49       	lddsp	r9,sp[0x10]
80007e66:	30 08       	mov	r8,0
80007e68:	c2 89       	rjmp	800080b8 <get_arg+0x274>
80007e6a:	2f fb       	sub	r11,-1
80007e6c:	32 5c       	mov	r12,37
80007e6e:	17 8a       	ld.ub	r10,r11[0x0]
80007e70:	f8 0a 18 00 	cp.b	r10,r12
80007e74:	5f 1e       	srne	lr
80007e76:	f0 0a 18 00 	cp.b	r10,r8
80007e7a:	5f 1c       	srne	r12
80007e7c:	fd ec 00 0c 	and	r12,lr,r12
80007e80:	f0 0c 18 00 	cp.b	r12,r8
80007e84:	cf 31       	brne	80007e6a <get_arg+0x26>
80007e86:	58 0a       	cp.w	r10,0
80007e88:	e0 80 01 25 	breq	800080d2 <get_arg+0x28e>
80007e8c:	30 0c       	mov	r12,0
80007e8e:	3f fa       	mov	r10,-1
80007e90:	18 90       	mov	r0,r12
80007e92:	50 3a       	stdsp	sp[0xc],r10
80007e94:	18 94       	mov	r4,r12
80007e96:	18 92       	mov	r2,r12
80007e98:	f8 0c 00 3c 	add	r12,r12,r12<<0x3
80007e9c:	16 97       	mov	r7,r11
80007e9e:	50 7c       	stdsp	sp[0x1c],r12
80007ea0:	fe cc 9e 68 	sub	r12,pc,-24984
80007ea4:	0f 3a       	ld.ub	r10,r7++
80007ea6:	f8 0a 07 0e 	ld.ub	lr,r12[r10]
80007eaa:	40 7c       	lddsp	r12,sp[0x1c]
80007eac:	1c 0c       	add	r12,lr
80007eae:	fe ce 9f 3e 	sub	lr,pc,-24770
80007eb2:	fc 0c 07 0e 	ld.ub	lr,lr[r12]
80007eb6:	20 1e       	sub	lr,1
80007eb8:	50 0e       	stdsp	sp[0x0],lr
80007eba:	fe ce 9f b6 	sub	lr,pc,-24650
80007ebe:	fc 0c 07 0c 	ld.ub	r12,lr[r12]
80007ec2:	50 7c       	stdsp	sp[0x1c],r12
80007ec4:	40 0c       	lddsp	r12,sp[0x0]
80007ec6:	58 7c       	cp.w	r12,7
80007ec8:	e0 8b 00 f1 	brhi	800080aa <get_arg+0x266>
80007ecc:	fe ce a1 68 	sub	lr,pc,-24216
80007ed0:	fc 0c 03 2f 	ld.w	pc,lr[r12<<0x2]
80007ed4:	36 8b       	mov	r11,104
80007ed6:	f6 0a 18 00 	cp.b	r10,r11
80007eda:	e0 80 00 e8 	breq	800080aa <get_arg+0x266>
80007ede:	37 1b       	mov	r11,113
80007ee0:	f6 0a 18 00 	cp.b	r10,r11
80007ee4:	c0 70       	breq	80007ef2 <get_arg+0xae>
80007ee6:	34 cb       	mov	r11,76
80007ee8:	f6 0a 18 00 	cp.b	r10,r11
80007eec:	c0 51       	brne	80007ef6 <get_arg+0xb2>
80007eee:	a3 b4       	sbr	r4,0x3
80007ef0:	cd d8       	rjmp	800080aa <get_arg+0x266>
80007ef2:	a5 b4       	sbr	r4,0x5
80007ef4:	cd b8       	rjmp	800080aa <get_arg+0x266>
80007ef6:	08 9a       	mov	r10,r4
80007ef8:	0e 9b       	mov	r11,r7
80007efa:	a5 aa       	sbr	r10,0x4
80007efc:	17 3c       	ld.ub	r12,r11++
80007efe:	a5 b4       	sbr	r4,0x5
80007f00:	36 ce       	mov	lr,108
80007f02:	fc 0c 18 00 	cp.b	r12,lr
80007f06:	e0 80 00 d3 	breq	800080ac <get_arg+0x268>
80007f0a:	14 94       	mov	r4,r10
80007f0c:	cc f8       	rjmp	800080aa <get_arg+0x266>
80007f0e:	eb d5 c0 05 	bfextu	r5,r5,0x0,0x5
80007f12:	36 7c       	mov	r12,103
80007f14:	f8 0a 18 00 	cp.b	r10,r12
80007f18:	e0 8b 00 27 	brhi	80007f66 <get_arg+0x122>
80007f1c:	36 5b       	mov	r11,101
80007f1e:	f6 0a 18 00 	cp.b	r10,r11
80007f22:	c4 82       	brcc	80007fb2 <get_arg+0x16e>
80007f24:	34 fb       	mov	r11,79
80007f26:	f6 0a 18 00 	cp.b	r10,r11
80007f2a:	c4 80       	breq	80007fba <get_arg+0x176>
80007f2c:	e0 8b 00 0c 	brhi	80007f44 <get_arg+0x100>
80007f30:	34 5b       	mov	r11,69
80007f32:	f6 0a 18 00 	cp.b	r10,r11
80007f36:	c3 e0       	breq	80007fb2 <get_arg+0x16e>
80007f38:	34 7b       	mov	r11,71
80007f3a:	f6 0a 18 00 	cp.b	r10,r11
80007f3e:	c3 a0       	breq	80007fb2 <get_arg+0x16e>
80007f40:	34 4b       	mov	r11,68
80007f42:	c0 88       	rjmp	80007f52 <get_arg+0x10e>
80007f44:	35 8b       	mov	r11,88
80007f46:	f6 0a 18 00 	cp.b	r10,r11
80007f4a:	c2 c0       	breq	80007fa2 <get_arg+0x15e>
80007f4c:	e0 8b 00 07 	brhi	80007f5a <get_arg+0x116>
80007f50:	35 5b       	mov	r11,85
80007f52:	f6 0a 18 00 	cp.b	r10,r11
80007f56:	c3 51       	brne	80007fc0 <get_arg+0x17c>
80007f58:	c3 18       	rjmp	80007fba <get_arg+0x176>
80007f5a:	36 3b       	mov	r11,99
80007f5c:	f6 0a 18 00 	cp.b	r10,r11
80007f60:	c2 f0       	breq	80007fbe <get_arg+0x17a>
80007f62:	36 4b       	mov	r11,100
80007f64:	c0 e8       	rjmp	80007f80 <get_arg+0x13c>
80007f66:	37 0b       	mov	r11,112
80007f68:	f6 0a 18 00 	cp.b	r10,r11
80007f6c:	c2 50       	breq	80007fb6 <get_arg+0x172>
80007f6e:	e0 8b 00 0d 	brhi	80007f88 <get_arg+0x144>
80007f72:	36 eb       	mov	r11,110
80007f74:	f6 0a 18 00 	cp.b	r10,r11
80007f78:	c1 f0       	breq	80007fb6 <get_arg+0x172>
80007f7a:	e0 8b 00 14 	brhi	80007fa2 <get_arg+0x15e>
80007f7e:	36 9b       	mov	r11,105
80007f80:	f6 0a 18 00 	cp.b	r10,r11
80007f84:	c1 e1       	brne	80007fc0 <get_arg+0x17c>
80007f86:	c0 e8       	rjmp	80007fa2 <get_arg+0x15e>
80007f88:	37 5b       	mov	r11,117
80007f8a:	f6 0a 18 00 	cp.b	r10,r11
80007f8e:	c0 a0       	breq	80007fa2 <get_arg+0x15e>
80007f90:	37 8b       	mov	r11,120
80007f92:	f6 0a 18 00 	cp.b	r10,r11
80007f96:	c0 60       	breq	80007fa2 <get_arg+0x15e>
80007f98:	37 3b       	mov	r11,115
80007f9a:	f6 0a 18 00 	cp.b	r10,r11
80007f9e:	c1 11       	brne	80007fc0 <get_arg+0x17c>
80007fa0:	c0 b8       	rjmp	80007fb6 <get_arg+0x172>
80007fa2:	ed b4 00 04 	bld	r4,0x4
80007fa6:	c0 a0       	breq	80007fba <get_arg+0x176>
80007fa8:	ed b4 00 05 	bld	r4,0x5
80007fac:	c0 91       	brne	80007fbe <get_arg+0x17a>
80007fae:	30 20       	mov	r0,2
80007fb0:	c0 88       	rjmp	80007fc0 <get_arg+0x17c>
80007fb2:	30 40       	mov	r0,4
80007fb4:	c0 68       	rjmp	80007fc0 <get_arg+0x17c>
80007fb6:	30 30       	mov	r0,3
80007fb8:	c0 48       	rjmp	80007fc0 <get_arg+0x17c>
80007fba:	30 10       	mov	r0,1
80007fbc:	c0 28       	rjmp	80007fc0 <get_arg+0x17c>
80007fbe:	30 00       	mov	r0,0
80007fc0:	40 3b       	lddsp	r11,sp[0xc]
80007fc2:	5b fb       	cp.w	r11,-1
80007fc4:	c0 40       	breq	80007fcc <get_arg+0x188>
80007fc6:	e2 0b 09 20 	st.w	r1[r11<<0x2],r0
80007fca:	c7 08       	rjmp	800080aa <get_arg+0x266>
80007fcc:	58 60       	cp.w	r0,6
80007fce:	e0 8b 00 6e 	brhi	800080aa <get_arg+0x266>
80007fd2:	6c 0a       	ld.w	r10,r6[0x0]
80007fd4:	ea cc ff ff 	sub	r12,r5,-1
80007fd8:	fe ce a2 54 	sub	lr,pc,-23980
80007fdc:	fc 00 03 2f 	ld.w	pc,lr[r0<<0x2]
80007fe0:	f4 cb ff f8 	sub	r11,r10,-8
80007fe4:	8d 0b       	st.w	r6[0x0],r11
80007fe6:	f4 ea 00 00 	ld.d	r10,r10[0]
80007fea:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80007fee:	c0 f8       	rjmp	8000800c <get_arg+0x1c8>
80007ff0:	f4 cb ff fc 	sub	r11,r10,-4
80007ff4:	8d 0b       	st.w	r6[0x0],r11
80007ff6:	74 0a       	ld.w	r10,r10[0x0]
80007ff8:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80007ffc:	c0 88       	rjmp	8000800c <get_arg+0x1c8>
80007ffe:	f4 cb ff f8 	sub	r11,r10,-8
80008002:	8d 0b       	st.w	r6[0x0],r11
80008004:	f4 ea 00 00 	ld.d	r10,r10[0]
80008008:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
8000800c:	0e 9b       	mov	r11,r7
8000800e:	18 95       	mov	r5,r12
80008010:	c4 e8       	rjmp	800080ac <get_arg+0x268>
80008012:	62 0a       	ld.w	r10,r1[0x0]
80008014:	5b fa       	cp.w	r10,-1
80008016:	c0 b1       	brne	8000802c <get_arg+0x1e8>
80008018:	50 19       	stdsp	sp[0x4],r9
8000801a:	50 28       	stdsp	sp[0x8],r8
8000801c:	e0 6a 00 80 	mov	r10,128
80008020:	30 0b       	mov	r11,0
80008022:	02 9c       	mov	r12,r1
80008024:	fe b0 fd 00 	rcall	80007a24 <memset>
80008028:	40 28       	lddsp	r8,sp[0x8]
8000802a:	40 19       	lddsp	r9,sp[0x4]
8000802c:	e4 cc 00 01 	sub	r12,r2,1
80008030:	0e 9b       	mov	r11,r7
80008032:	50 3c       	stdsp	sp[0xc],r12
80008034:	f2 0c 0c 49 	max	r9,r9,r12
80008038:	c3 a8       	rjmp	800080ac <get_arg+0x268>
8000803a:	62 0a       	ld.w	r10,r1[0x0]
8000803c:	5b fa       	cp.w	r10,-1
8000803e:	c0 b1       	brne	80008054 <get_arg+0x210>
80008040:	50 19       	stdsp	sp[0x4],r9
80008042:	50 28       	stdsp	sp[0x8],r8
80008044:	e0 6a 00 80 	mov	r10,128
80008048:	30 0b       	mov	r11,0
8000804a:	02 9c       	mov	r12,r1
8000804c:	fe b0 fc ec 	rcall	80007a24 <memset>
80008050:	40 28       	lddsp	r8,sp[0x8]
80008052:	40 19       	lddsp	r9,sp[0x4]
80008054:	20 12       	sub	r2,1
80008056:	30 0a       	mov	r10,0
80008058:	0e 9b       	mov	r11,r7
8000805a:	e2 02 09 2a 	st.w	r1[r2<<0x2],r10
8000805e:	f2 02 0c 49 	max	r9,r9,r2
80008062:	c2 58       	rjmp	800080ac <get_arg+0x268>
80008064:	16 97       	mov	r7,r11
80008066:	6c 0a       	ld.w	r10,r6[0x0]
80008068:	f4 cb ff fc 	sub	r11,r10,-4
8000806c:	8d 0b       	st.w	r6[0x0],r11
8000806e:	74 0a       	ld.w	r10,r10[0x0]
80008070:	0e 9b       	mov	r11,r7
80008072:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80008076:	2f f5       	sub	r5,-1
80008078:	c1 a8       	rjmp	800080ac <get_arg+0x268>
8000807a:	f4 c2 00 30 	sub	r2,r10,48
8000807e:	c0 68       	rjmp	8000808a <get_arg+0x246>
80008080:	e4 02 00 22 	add	r2,r2,r2<<0x2
80008084:	2f f7       	sub	r7,-1
80008086:	f4 02 00 12 	add	r2,r10,r2<<0x1
8000808a:	0f 8a       	ld.ub	r10,r7[0x0]
8000808c:	58 0a       	cp.w	r10,0
8000808e:	c0 e0       	breq	800080aa <get_arg+0x266>
80008090:	23 0a       	sub	r10,48
80008092:	58 9a       	cp.w	r10,9
80008094:	fe 98 ff f6 	brls	80008080 <get_arg+0x23c>
80008098:	c0 98       	rjmp	800080aa <get_arg+0x266>
8000809a:	2f f7       	sub	r7,-1
8000809c:	0f 8a       	ld.ub	r10,r7[0x0]
8000809e:	58 0a       	cp.w	r10,0
800080a0:	c0 50       	breq	800080aa <get_arg+0x266>
800080a2:	23 0a       	sub	r10,48
800080a4:	58 9a       	cp.w	r10,9
800080a6:	fe 98 ff fa 	brls	8000809a <get_arg+0x256>
800080aa:	0e 9b       	mov	r11,r7
800080ac:	40 7c       	lddsp	r12,sp[0x1c]
800080ae:	30 ba       	mov	r10,11
800080b0:	f4 0c 18 00 	cp.b	r12,r10
800080b4:	fe 91 fe f2 	brne	80007e98 <get_arg+0x54>
800080b8:	40 42       	lddsp	r2,sp[0x10]
800080ba:	17 8c       	ld.ub	r12,r11[0x0]
800080bc:	0a 32       	cp.w	r2,r5
800080be:	5f 4a       	srge	r10
800080c0:	f0 0c 18 00 	cp.b	r12,r8
800080c4:	5f 1c       	srne	r12
800080c6:	f9 ea 00 0a 	and	r10,r12,r10
800080ca:	f0 0a 18 00 	cp.b	r10,r8
800080ce:	fe 91 fe cf 	brne	80007e6c <get_arg+0x28>
800080d2:	30 08       	mov	r8,0
800080d4:	40 4e       	lddsp	lr,sp[0x10]
800080d6:	17 8a       	ld.ub	r10,r11[0x0]
800080d8:	e2 05 00 21 	add	r1,r1,r5<<0x2
800080dc:	f0 0a 18 00 	cp.b	r10,r8
800080e0:	fc 09 17 10 	movne	r9,lr
800080e4:	e6 05 00 38 	add	r8,r3,r5<<0x3
800080e8:	06 9e       	mov	lr,r3
800080ea:	c2 a8       	rjmp	8000813e <get_arg+0x2fa>
800080ec:	62 0a       	ld.w	r10,r1[0x0]
800080ee:	58 3a       	cp.w	r10,3
800080f0:	c1 e0       	breq	8000812c <get_arg+0x2e8>
800080f2:	e0 89 00 07 	brgt	80008100 <get_arg+0x2bc>
800080f6:	58 1a       	cp.w	r10,1
800080f8:	c1 a0       	breq	8000812c <get_arg+0x2e8>
800080fa:	58 2a       	cp.w	r10,2
800080fc:	c1 81       	brne	8000812c <get_arg+0x2e8>
800080fe:	c0 58       	rjmp	80008108 <get_arg+0x2c4>
80008100:	58 5a       	cp.w	r10,5
80008102:	c0 c0       	breq	8000811a <get_arg+0x2d6>
80008104:	c0 b5       	brlt	8000811a <get_arg+0x2d6>
80008106:	c1 38       	rjmp	8000812c <get_arg+0x2e8>
80008108:	6c 0a       	ld.w	r10,r6[0x0]
8000810a:	f4 cc ff f8 	sub	r12,r10,-8
8000810e:	8d 0c       	st.w	r6[0x0],r12
80008110:	f4 e2 00 00 	ld.d	r2,r10[0]
80008114:	f0 e3 00 00 	st.d	r8[0],r2
80008118:	c1 08       	rjmp	80008138 <get_arg+0x2f4>
8000811a:	6c 0a       	ld.w	r10,r6[0x0]
8000811c:	f4 cc ff f8 	sub	r12,r10,-8
80008120:	8d 0c       	st.w	r6[0x0],r12
80008122:	f4 e2 00 00 	ld.d	r2,r10[0]
80008126:	f0 e3 00 00 	st.d	r8[0],r2
8000812a:	c0 78       	rjmp	80008138 <get_arg+0x2f4>
8000812c:	6c 0a       	ld.w	r10,r6[0x0]
8000812e:	f4 cc ff fc 	sub	r12,r10,-4
80008132:	8d 0c       	st.w	r6[0x0],r12
80008134:	74 0a       	ld.w	r10,r10[0x0]
80008136:	91 0a       	st.w	r8[0x0],r10
80008138:	2f f5       	sub	r5,-1
8000813a:	2f 88       	sub	r8,-8
8000813c:	2f c1       	sub	r1,-4
8000813e:	12 35       	cp.w	r5,r9
80008140:	fe 9a ff d6 	brle	800080ec <get_arg+0x2a8>
80008144:	1c 93       	mov	r3,lr
80008146:	40 52       	lddsp	r2,sp[0x14]
80008148:	40 6e       	lddsp	lr,sp[0x18]
8000814a:	85 05       	st.w	r2[0x0],r5
8000814c:	9d 0b       	st.w	lr[0x0],r11
8000814e:	40 4b       	lddsp	r11,sp[0x10]
80008150:	e6 0b 00 3c 	add	r12,r3,r11<<0x3
80008154:	2f 8d       	sub	sp,-32
80008156:	d8 32       	popm	r0-r7,pc

80008158 <__sprint_r>:
80008158:	d4 21       	pushm	r4-r7,lr
8000815a:	14 97       	mov	r7,r10
8000815c:	74 28       	ld.w	r8,r10[0x8]
8000815e:	58 08       	cp.w	r8,0
80008160:	c0 41       	brne	80008168 <__sprint_r+0x10>
80008162:	95 18       	st.w	r10[0x4],r8
80008164:	10 9c       	mov	r12,r8
80008166:	d8 22       	popm	r4-r7,pc
80008168:	e0 a0 18 ba 	rcall	8000b2dc <__sfvwrite_r>
8000816c:	30 08       	mov	r8,0
8000816e:	8f 18       	st.w	r7[0x4],r8
80008170:	8f 28       	st.w	r7[0x8],r8
80008172:	d8 22       	popm	r4-r7,pc

80008174 <_vfprintf_r>:
80008174:	d4 31       	pushm	r0-r7,lr
80008176:	fa cd 06 bc 	sub	sp,sp,1724
8000817a:	51 09       	stdsp	sp[0x40],r9
8000817c:	16 91       	mov	r1,r11
8000817e:	14 97       	mov	r7,r10
80008180:	18 95       	mov	r5,r12
80008182:	e0 a0 1a 1d 	rcall	8000b5bc <_localeconv_r>
80008186:	78 0c       	ld.w	r12,r12[0x0]
80008188:	50 cc       	stdsp	sp[0x30],r12
8000818a:	58 05       	cp.w	r5,0
8000818c:	c0 70       	breq	8000819a <_vfprintf_r+0x26>
8000818e:	6a 68       	ld.w	r8,r5[0x18]
80008190:	58 08       	cp.w	r8,0
80008192:	c0 41       	brne	8000819a <_vfprintf_r+0x26>
80008194:	0a 9c       	mov	r12,r5
80008196:	e0 a0 17 43 	rcall	8000b01c <__sinit>
8000819a:	fe c8 a0 52 	sub	r8,pc,-24494
8000819e:	10 31       	cp.w	r1,r8
800081a0:	c0 31       	brne	800081a6 <_vfprintf_r+0x32>
800081a2:	6a 01       	ld.w	r1,r5[0x0]
800081a4:	c0 c8       	rjmp	800081bc <_vfprintf_r+0x48>
800081a6:	fe c8 a0 3e 	sub	r8,pc,-24514
800081aa:	10 31       	cp.w	r1,r8
800081ac:	c0 31       	brne	800081b2 <_vfprintf_r+0x3e>
800081ae:	6a 11       	ld.w	r1,r5[0x4]
800081b0:	c0 68       	rjmp	800081bc <_vfprintf_r+0x48>
800081b2:	fe c8 a0 2a 	sub	r8,pc,-24534
800081b6:	10 31       	cp.w	r1,r8
800081b8:	eb f1 00 02 	ld.weq	r1,r5[0x8]
800081bc:	82 68       	ld.sh	r8,r1[0xc]
800081be:	ed b8 00 03 	bld	r8,0x3
800081c2:	c0 41       	brne	800081ca <_vfprintf_r+0x56>
800081c4:	62 48       	ld.w	r8,r1[0x10]
800081c6:	58 08       	cp.w	r8,0
800081c8:	c0 71       	brne	800081d6 <_vfprintf_r+0x62>
800081ca:	02 9b       	mov	r11,r1
800081cc:	0a 9c       	mov	r12,r5
800081ce:	e0 a0 0f 5d 	rcall	8000a088 <__swsetup_r>
800081d2:	e0 81 0f 54 	brne	8000a07a <_vfprintf_r+0x1f06>
800081d6:	82 68       	ld.sh	r8,r1[0xc]
800081d8:	10 99       	mov	r9,r8
800081da:	e2 19 00 1a 	andl	r9,0x1a,COH
800081de:	58 a9       	cp.w	r9,10
800081e0:	c3 c1       	brne	80008258 <_vfprintf_r+0xe4>
800081e2:	82 79       	ld.sh	r9,r1[0xe]
800081e4:	30 0a       	mov	r10,0
800081e6:	f4 09 19 00 	cp.h	r9,r10
800081ea:	c3 75       	brlt	80008258 <_vfprintf_r+0xe4>
800081ec:	a1 d8       	cbr	r8,0x1
800081ee:	fb 58 05 d0 	st.h	sp[1488],r8
800081f2:	62 88       	ld.w	r8,r1[0x20]
800081f4:	fb 48 05 e4 	st.w	sp[1508],r8
800081f8:	62 a8       	ld.w	r8,r1[0x28]
800081fa:	fb 48 05 ec 	st.w	sp[1516],r8
800081fe:	fa c8 ff bc 	sub	r8,sp,-68
80008202:	fb 48 05 d4 	st.w	sp[1492],r8
80008206:	fb 48 05 c4 	st.w	sp[1476],r8
8000820a:	e0 68 04 00 	mov	r8,1024
8000820e:	fb 48 05 d8 	st.w	sp[1496],r8
80008212:	fb 48 05 cc 	st.w	sp[1484],r8
80008216:	30 08       	mov	r8,0
80008218:	fb 59 05 d2 	st.h	sp[1490],r9
8000821c:	0e 9a       	mov	r10,r7
8000821e:	41 09       	lddsp	r9,sp[0x40]
80008220:	fa c7 fa 3c 	sub	r7,sp,-1476
80008224:	fb 48 05 dc 	st.w	sp[1500],r8
80008228:	0a 9c       	mov	r12,r5
8000822a:	0e 9b       	mov	r11,r7
8000822c:	ca 4f       	rcall	80008174 <_vfprintf_r>
8000822e:	50 bc       	stdsp	sp[0x2c],r12
80008230:	c0 95       	brlt	80008242 <_vfprintf_r+0xce>
80008232:	0e 9b       	mov	r11,r7
80008234:	0a 9c       	mov	r12,r5
80008236:	e0 a0 16 1b 	rcall	8000ae6c <_fflush_r>
8000823a:	40 be       	lddsp	lr,sp[0x2c]
8000823c:	f9 be 01 ff 	movne	lr,-1
80008240:	50 be       	stdsp	sp[0x2c],lr
80008242:	fb 08 05 d0 	ld.sh	r8,sp[1488]
80008246:	ed b8 00 06 	bld	r8,0x6
8000824a:	e0 81 0f 1a 	brne	8000a07e <_vfprintf_r+0x1f0a>
8000824e:	82 68       	ld.sh	r8,r1[0xc]
80008250:	a7 a8       	sbr	r8,0x6
80008252:	a2 68       	st.h	r1[0xc],r8
80008254:	e0 8f 0f 15 	bral	8000a07e <_vfprintf_r+0x1f0a>
80008258:	30 08       	mov	r8,0
8000825a:	fb 48 06 b4 	st.w	sp[1716],r8
8000825e:	fb 48 06 90 	st.w	sp[1680],r8
80008262:	fb 48 06 8c 	st.w	sp[1676],r8
80008266:	fb 48 06 b0 	st.w	sp[1712],r8
8000826a:	30 08       	mov	r8,0
8000826c:	30 09       	mov	r9,0
8000826e:	50 a7       	stdsp	sp[0x28],r7
80008270:	50 78       	stdsp	sp[0x1c],r8
80008272:	fa c3 f9 e0 	sub	r3,sp,-1568
80008276:	3f f8       	mov	r8,-1
80008278:	50 59       	stdsp	sp[0x14],r9
8000827a:	fb 43 06 88 	st.w	sp[1672],r3
8000827e:	fb 48 05 44 	st.w	sp[1348],r8
80008282:	12 9c       	mov	r12,r9
80008284:	50 69       	stdsp	sp[0x18],r9
80008286:	50 d9       	stdsp	sp[0x34],r9
80008288:	50 e9       	stdsp	sp[0x38],r9
8000828a:	50 b9       	stdsp	sp[0x2c],r9
8000828c:	12 97       	mov	r7,r9
8000828e:	0a 94       	mov	r4,r5
80008290:	40 a2       	lddsp	r2,sp[0x28]
80008292:	32 5a       	mov	r10,37
80008294:	30 08       	mov	r8,0
80008296:	c0 28       	rjmp	8000829a <_vfprintf_r+0x126>
80008298:	2f f2       	sub	r2,-1
8000829a:	05 89       	ld.ub	r9,r2[0x0]
8000829c:	f0 09 18 00 	cp.b	r9,r8
800082a0:	5f 1b       	srne	r11
800082a2:	f4 09 18 00 	cp.b	r9,r10
800082a6:	5f 19       	srne	r9
800082a8:	f3 eb 00 0b 	and	r11,r9,r11
800082ac:	f0 0b 18 00 	cp.b	r11,r8
800082b0:	cf 41       	brne	80008298 <_vfprintf_r+0x124>
800082b2:	40 ab       	lddsp	r11,sp[0x28]
800082b4:	e4 0b 01 06 	sub	r6,r2,r11
800082b8:	c1 e0       	breq	800082f4 <_vfprintf_r+0x180>
800082ba:	fa f8 06 90 	ld.w	r8,sp[1680]
800082be:	0c 08       	add	r8,r6
800082c0:	87 0b       	st.w	r3[0x0],r11
800082c2:	fb 48 06 90 	st.w	sp[1680],r8
800082c6:	87 16       	st.w	r3[0x4],r6
800082c8:	fa f8 06 8c 	ld.w	r8,sp[1676]
800082cc:	2f f8       	sub	r8,-1
800082ce:	fb 48 06 8c 	st.w	sp[1676],r8
800082d2:	58 78       	cp.w	r8,7
800082d4:	e0 89 00 04 	brgt	800082dc <_vfprintf_r+0x168>
800082d8:	2f 83       	sub	r3,-8
800082da:	c0 a8       	rjmp	800082ee <_vfprintf_r+0x17a>
800082dc:	fa ca f9 78 	sub	r10,sp,-1672
800082e0:	02 9b       	mov	r11,r1
800082e2:	08 9c       	mov	r12,r4
800082e4:	c3 af       	rcall	80008158 <__sprint_r>
800082e6:	e0 81 0e c6 	brne	8000a072 <_vfprintf_r+0x1efe>
800082ea:	fa c3 f9 e0 	sub	r3,sp,-1568
800082ee:	40 ba       	lddsp	r10,sp[0x2c]
800082f0:	0c 0a       	add	r10,r6
800082f2:	50 ba       	stdsp	sp[0x2c],r10
800082f4:	05 89       	ld.ub	r9,r2[0x0]
800082f6:	30 08       	mov	r8,0
800082f8:	f0 09 18 00 	cp.b	r9,r8
800082fc:	e0 80 0e aa 	breq	8000a050 <_vfprintf_r+0x1edc>
80008300:	30 09       	mov	r9,0
80008302:	fb 68 06 bb 	st.b	sp[1723],r8
80008306:	0e 96       	mov	r6,r7
80008308:	e4 c8 ff ff 	sub	r8,r2,-1
8000830c:	3f fe       	mov	lr,-1
8000830e:	50 93       	stdsp	sp[0x24],r3
80008310:	50 41       	stdsp	sp[0x10],r1
80008312:	0e 93       	mov	r3,r7
80008314:	04 91       	mov	r1,r2
80008316:	50 89       	stdsp	sp[0x20],r9
80008318:	50 a8       	stdsp	sp[0x28],r8
8000831a:	50 2e       	stdsp	sp[0x8],lr
8000831c:	50 39       	stdsp	sp[0xc],r9
8000831e:	12 95       	mov	r5,r9
80008320:	12 90       	mov	r0,r9
80008322:	10 97       	mov	r7,r8
80008324:	08 92       	mov	r2,r4
80008326:	c0 78       	rjmp	80008334 <_vfprintf_r+0x1c0>
80008328:	3f fc       	mov	r12,-1
8000832a:	08 97       	mov	r7,r4
8000832c:	50 2c       	stdsp	sp[0x8],r12
8000832e:	c0 38       	rjmp	80008334 <_vfprintf_r+0x1c0>
80008330:	30 0b       	mov	r11,0
80008332:	50 3b       	stdsp	sp[0xc],r11
80008334:	0f 38       	ld.ub	r8,r7++
80008336:	c0 28       	rjmp	8000833a <_vfprintf_r+0x1c6>
80008338:	12 90       	mov	r0,r9
8000833a:	f0 c9 00 20 	sub	r9,r8,32
8000833e:	e0 49 00 58 	cp.w	r9,88
80008342:	e0 8b 0a 30 	brhi	800097a2 <_vfprintf_r+0x162e>
80008346:	fe ca a5 a6 	sub	r10,pc,-23130
8000834a:	f4 09 03 2f 	ld.w	pc,r10[r9<<0x2]
8000834e:	50 a7       	stdsp	sp[0x28],r7
80008350:	50 80       	stdsp	sp[0x20],r0
80008352:	0c 97       	mov	r7,r6
80008354:	04 94       	mov	r4,r2
80008356:	06 96       	mov	r6,r3
80008358:	02 92       	mov	r2,r1
8000835a:	fe c9 a3 7e 	sub	r9,pc,-23682
8000835e:	40 93       	lddsp	r3,sp[0x24]
80008360:	10 90       	mov	r0,r8
80008362:	40 41       	lddsp	r1,sp[0x10]
80008364:	50 d9       	stdsp	sp[0x34],r9
80008366:	e0 8f 08 8e 	bral	80009482 <_vfprintf_r+0x130e>
8000836a:	30 08       	mov	r8,0
8000836c:	fb 39 06 bb 	ld.ub	r9,sp[1723]
80008370:	f0 09 18 00 	cp.b	r9,r8
80008374:	ce 01       	brne	80008334 <_vfprintf_r+0x1c0>
80008376:	32 08       	mov	r8,32
80008378:	c6 e8       	rjmp	80008454 <_vfprintf_r+0x2e0>
8000837a:	a1 a5       	sbr	r5,0x0
8000837c:	cd cb       	rjmp	80008334 <_vfprintf_r+0x1c0>
8000837e:	0f 89       	ld.ub	r9,r7[0x0]
80008380:	f2 c8 00 30 	sub	r8,r9,48
80008384:	58 98       	cp.w	r8,9
80008386:	e0 8b 00 1d 	brhi	800083c0 <_vfprintf_r+0x24c>
8000838a:	ee c8 ff ff 	sub	r8,r7,-1
8000838e:	30 0b       	mov	r11,0
80008390:	23 09       	sub	r9,48
80008392:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
80008396:	f2 0b 00 1b 	add	r11,r9,r11<<0x1
8000839a:	11 39       	ld.ub	r9,r8++
8000839c:	f2 ca 00 30 	sub	r10,r9,48
800083a0:	58 9a       	cp.w	r10,9
800083a2:	fe 98 ff f7 	brls	80008390 <_vfprintf_r+0x21c>
800083a6:	e0 49 00 24 	cp.w	r9,36
800083aa:	cc 31       	brne	80008330 <_vfprintf_r+0x1bc>
800083ac:	e0 4b 00 20 	cp.w	r11,32
800083b0:	e0 89 0e 60 	brgt	8000a070 <_vfprintf_r+0x1efc>
800083b4:	20 1b       	sub	r11,1
800083b6:	fa f9 06 b4 	ld.w	r9,sp[1716]
800083ba:	12 3b       	cp.w	r11,r9
800083bc:	c0 95       	brlt	800083ce <_vfprintf_r+0x25a>
800083be:	c1 08       	rjmp	800083de <_vfprintf_r+0x26a>
800083c0:	fa f9 06 b4 	ld.w	r9,sp[1716]
800083c4:	ec ca ff ff 	sub	r10,r6,-1
800083c8:	12 36       	cp.w	r6,r9
800083ca:	c1 f5       	brlt	80008408 <_vfprintf_r+0x294>
800083cc:	c2 68       	rjmp	80008418 <_vfprintf_r+0x2a4>
800083ce:	fa ce f9 44 	sub	lr,sp,-1724
800083d2:	10 97       	mov	r7,r8
800083d4:	fc 0b 00 3b 	add	r11,lr,r11<<0x3
800083d8:	f6 f0 fd 88 	ld.w	r0,r11[-632]
800083dc:	c3 58       	rjmp	80008446 <_vfprintf_r+0x2d2>
800083de:	10 97       	mov	r7,r8
800083e0:	fa c8 f9 50 	sub	r8,sp,-1712
800083e4:	1a d8       	st.w	--sp,r8
800083e6:	fa c8 fa b8 	sub	r8,sp,-1352
800083ea:	1a d8       	st.w	--sp,r8
800083ec:	fa c8 fb b4 	sub	r8,sp,-1100
800083f0:	02 9a       	mov	r10,r1
800083f2:	1a d8       	st.w	--sp,r8
800083f4:	04 9c       	mov	r12,r2
800083f6:	fa c8 f9 40 	sub	r8,sp,-1728
800083fa:	fa c9 ff b4 	sub	r9,sp,-76
800083fe:	fe b0 fd 23 	rcall	80007e44 <get_arg>
80008402:	2f dd       	sub	sp,-12
80008404:	78 00       	ld.w	r0,r12[0x0]
80008406:	c2 08       	rjmp	80008446 <_vfprintf_r+0x2d2>
80008408:	fa cc f9 44 	sub	r12,sp,-1724
8000840c:	14 96       	mov	r6,r10
8000840e:	f8 03 00 38 	add	r8,r12,r3<<0x3
80008412:	f0 f0 fd 88 	ld.w	r0,r8[-632]
80008416:	c1 88       	rjmp	80008446 <_vfprintf_r+0x2d2>
80008418:	41 08       	lddsp	r8,sp[0x40]
8000841a:	59 f9       	cp.w	r9,31
8000841c:	e0 89 00 11 	brgt	8000843e <_vfprintf_r+0x2ca>
80008420:	f0 cb ff fc 	sub	r11,r8,-4
80008424:	51 0b       	stdsp	sp[0x40],r11
80008426:	70 00       	ld.w	r0,r8[0x0]
80008428:	fa cb f9 44 	sub	r11,sp,-1724
8000842c:	f6 09 00 38 	add	r8,r11,r9<<0x3
80008430:	f1 40 fd 88 	st.w	r8[-632],r0
80008434:	2f f9       	sub	r9,-1
80008436:	14 96       	mov	r6,r10
80008438:	fb 49 06 b4 	st.w	sp[1716],r9
8000843c:	c0 58       	rjmp	80008446 <_vfprintf_r+0x2d2>
8000843e:	70 00       	ld.w	r0,r8[0x0]
80008440:	14 96       	mov	r6,r10
80008442:	2f c8       	sub	r8,-4
80008444:	51 08       	stdsp	sp[0x40],r8
80008446:	58 00       	cp.w	r0,0
80008448:	fe 94 ff 76 	brge	80008334 <_vfprintf_r+0x1c0>
8000844c:	5c 30       	neg	r0
8000844e:	a3 a5       	sbr	r5,0x2
80008450:	c7 2b       	rjmp	80008334 <_vfprintf_r+0x1c0>
80008452:	32 b8       	mov	r8,43
80008454:	fb 68 06 bb 	st.b	sp[1723],r8
80008458:	c6 eb       	rjmp	80008334 <_vfprintf_r+0x1c0>
8000845a:	0f 38       	ld.ub	r8,r7++
8000845c:	e0 48 00 2a 	cp.w	r8,42
80008460:	c0 30       	breq	80008466 <_vfprintf_r+0x2f2>
80008462:	30 09       	mov	r9,0
80008464:	c7 98       	rjmp	80008556 <_vfprintf_r+0x3e2>
80008466:	0f 88       	ld.ub	r8,r7[0x0]
80008468:	f0 c9 00 30 	sub	r9,r8,48
8000846c:	58 99       	cp.w	r9,9
8000846e:	e0 8b 00 1f 	brhi	800084ac <_vfprintf_r+0x338>
80008472:	ee c4 ff ff 	sub	r4,r7,-1
80008476:	30 0b       	mov	r11,0
80008478:	23 08       	sub	r8,48
8000847a:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
8000847e:	f0 0b 00 1b 	add	r11,r8,r11<<0x1
80008482:	09 38       	ld.ub	r8,r4++
80008484:	f0 c9 00 30 	sub	r9,r8,48
80008488:	58 99       	cp.w	r9,9
8000848a:	fe 98 ff f7 	brls	80008478 <_vfprintf_r+0x304>
8000848e:	e0 48 00 24 	cp.w	r8,36
80008492:	fe 91 ff 4f 	brne	80008330 <_vfprintf_r+0x1bc>
80008496:	e0 4b 00 20 	cp.w	r11,32
8000849a:	e0 89 0d eb 	brgt	8000a070 <_vfprintf_r+0x1efc>
8000849e:	20 1b       	sub	r11,1
800084a0:	fa f8 06 b4 	ld.w	r8,sp[1716]
800084a4:	10 3b       	cp.w	r11,r8
800084a6:	c0 a5       	brlt	800084ba <_vfprintf_r+0x346>
800084a8:	c1 18       	rjmp	800084ca <_vfprintf_r+0x356>
800084aa:	d7 03       	nop
800084ac:	fa fa 06 b4 	ld.w	r10,sp[1716]
800084b0:	ec c9 ff ff 	sub	r9,r6,-1
800084b4:	14 36       	cp.w	r6,r10
800084b6:	c1 f5       	brlt	800084f4 <_vfprintf_r+0x380>
800084b8:	c2 88       	rjmp	80008508 <_vfprintf_r+0x394>
800084ba:	fa ca f9 44 	sub	r10,sp,-1724
800084be:	f4 0b 00 3b 	add	r11,r10,r11<<0x3
800084c2:	f6 fb fd 88 	ld.w	r11,r11[-632]
800084c6:	50 2b       	stdsp	sp[0x8],r11
800084c8:	c3 c8       	rjmp	80008540 <_vfprintf_r+0x3cc>
800084ca:	fa c8 f9 50 	sub	r8,sp,-1712
800084ce:	1a d8       	st.w	--sp,r8
800084d0:	fa c8 fa b8 	sub	r8,sp,-1352
800084d4:	1a d8       	st.w	--sp,r8
800084d6:	fa c8 fb b4 	sub	r8,sp,-1100
800084da:	02 9a       	mov	r10,r1
800084dc:	1a d8       	st.w	--sp,r8
800084de:	04 9c       	mov	r12,r2
800084e0:	fa c8 f9 40 	sub	r8,sp,-1728
800084e4:	fa c9 ff b4 	sub	r9,sp,-76
800084e8:	fe b0 fc ae 	rcall	80007e44 <get_arg>
800084ec:	2f dd       	sub	sp,-12
800084ee:	78 0c       	ld.w	r12,r12[0x0]
800084f0:	50 2c       	stdsp	sp[0x8],r12
800084f2:	c2 78       	rjmp	80008540 <_vfprintf_r+0x3cc>
800084f4:	12 96       	mov	r6,r9
800084f6:	0e 94       	mov	r4,r7
800084f8:	fa c9 f9 44 	sub	r9,sp,-1724
800084fc:	f2 03 00 38 	add	r8,r9,r3<<0x3
80008500:	f0 f8 fd 88 	ld.w	r8,r8[-632]
80008504:	50 28       	stdsp	sp[0x8],r8
80008506:	c1 d8       	rjmp	80008540 <_vfprintf_r+0x3cc>
80008508:	41 08       	lddsp	r8,sp[0x40]
8000850a:	59 fa       	cp.w	r10,31
8000850c:	e0 89 00 14 	brgt	80008534 <_vfprintf_r+0x3c0>
80008510:	f0 cb ff fc 	sub	r11,r8,-4
80008514:	70 08       	ld.w	r8,r8[0x0]
80008516:	51 0b       	stdsp	sp[0x40],r11
80008518:	50 28       	stdsp	sp[0x8],r8
8000851a:	fa c6 f9 44 	sub	r6,sp,-1724
8000851e:	40 2e       	lddsp	lr,sp[0x8]
80008520:	ec 0a 00 38 	add	r8,r6,r10<<0x3
80008524:	f1 4e fd 88 	st.w	r8[-632],lr
80008528:	2f fa       	sub	r10,-1
8000852a:	0e 94       	mov	r4,r7
8000852c:	fb 4a 06 b4 	st.w	sp[1716],r10
80008530:	12 96       	mov	r6,r9
80008532:	c0 78       	rjmp	80008540 <_vfprintf_r+0x3cc>
80008534:	70 0c       	ld.w	r12,r8[0x0]
80008536:	0e 94       	mov	r4,r7
80008538:	2f c8       	sub	r8,-4
8000853a:	50 2c       	stdsp	sp[0x8],r12
8000853c:	12 96       	mov	r6,r9
8000853e:	51 08       	stdsp	sp[0x40],r8
80008540:	40 2b       	lddsp	r11,sp[0x8]
80008542:	58 0b       	cp.w	r11,0
80008544:	fe 95 fe f2 	brlt	80008328 <_vfprintf_r+0x1b4>
80008548:	08 97       	mov	r7,r4
8000854a:	cf 5a       	rjmp	80008334 <_vfprintf_r+0x1c0>
8000854c:	f2 09 00 29 	add	r9,r9,r9<<0x2
80008550:	0f 38       	ld.ub	r8,r7++
80008552:	f4 09 00 19 	add	r9,r10,r9<<0x1
80008556:	f0 ca 00 30 	sub	r10,r8,48
8000855a:	58 9a       	cp.w	r10,9
8000855c:	fe 98 ff f8 	brls	8000854c <_vfprintf_r+0x3d8>
80008560:	3f fa       	mov	r10,-1
80008562:	f2 0a 0c 49 	max	r9,r9,r10
80008566:	50 29       	stdsp	sp[0x8],r9
80008568:	ce 9a       	rjmp	8000833a <_vfprintf_r+0x1c6>
8000856a:	a7 b5       	sbr	r5,0x7
8000856c:	ce 4a       	rjmp	80008334 <_vfprintf_r+0x1c0>
8000856e:	30 09       	mov	r9,0
80008570:	23 08       	sub	r8,48
80008572:	f2 09 00 29 	add	r9,r9,r9<<0x2
80008576:	f0 09 00 19 	add	r9,r8,r9<<0x1
8000857a:	0f 38       	ld.ub	r8,r7++
8000857c:	f0 ca 00 30 	sub	r10,r8,48
80008580:	58 9a       	cp.w	r10,9
80008582:	fe 98 ff f7 	brls	80008570 <_vfprintf_r+0x3fc>
80008586:	e0 48 00 24 	cp.w	r8,36
8000858a:	fe 91 fe d7 	brne	80008338 <_vfprintf_r+0x1c4>
8000858e:	e0 49 00 20 	cp.w	r9,32
80008592:	e0 89 0d 6f 	brgt	8000a070 <_vfprintf_r+0x1efc>
80008596:	f2 c3 00 01 	sub	r3,r9,1
8000859a:	30 19       	mov	r9,1
8000859c:	50 39       	stdsp	sp[0xc],r9
8000859e:	cc ba       	rjmp	80008334 <_vfprintf_r+0x1c0>
800085a0:	a3 b5       	sbr	r5,0x3
800085a2:	cc 9a       	rjmp	80008334 <_vfprintf_r+0x1c0>
800085a4:	a7 a5       	sbr	r5,0x6
800085a6:	cc 7a       	rjmp	80008334 <_vfprintf_r+0x1c0>
800085a8:	0a 98       	mov	r8,r5
800085aa:	a5 b5       	sbr	r5,0x5
800085ac:	a5 a8       	sbr	r8,0x4
800085ae:	0f 89       	ld.ub	r9,r7[0x0]
800085b0:	36 ce       	mov	lr,108
800085b2:	fc 09 18 00 	cp.b	r9,lr
800085b6:	f7 b7 00 ff 	subeq	r7,-1
800085ba:	f0 05 17 10 	movne	r5,r8
800085be:	cb ba       	rjmp	80008334 <_vfprintf_r+0x1c0>
800085c0:	a5 b5       	sbr	r5,0x5
800085c2:	cb 9a       	rjmp	80008334 <_vfprintf_r+0x1c0>
800085c4:	50 a7       	stdsp	sp[0x28],r7
800085c6:	50 80       	stdsp	sp[0x20],r0
800085c8:	0c 97       	mov	r7,r6
800085ca:	10 90       	mov	r0,r8
800085cc:	06 96       	mov	r6,r3
800085ce:	04 94       	mov	r4,r2
800085d0:	40 93       	lddsp	r3,sp[0x24]
800085d2:	02 92       	mov	r2,r1
800085d4:	0e 99       	mov	r9,r7
800085d6:	40 41       	lddsp	r1,sp[0x10]
800085d8:	fa f8 06 b4 	ld.w	r8,sp[1716]
800085dc:	40 3c       	lddsp	r12,sp[0xc]
800085de:	58 0c       	cp.w	r12,0
800085e0:	c1 d0       	breq	8000861a <_vfprintf_r+0x4a6>
800085e2:	10 36       	cp.w	r6,r8
800085e4:	c0 64       	brge	800085f0 <_vfprintf_r+0x47c>
800085e6:	fa cb f9 44 	sub	r11,sp,-1724
800085ea:	f6 06 00 36 	add	r6,r11,r6<<0x3
800085ee:	c1 d8       	rjmp	80008628 <_vfprintf_r+0x4b4>
800085f0:	fa c8 f9 50 	sub	r8,sp,-1712
800085f4:	1a d8       	st.w	--sp,r8
800085f6:	fa c8 fa b8 	sub	r8,sp,-1352
800085fa:	1a d8       	st.w	--sp,r8
800085fc:	fa c8 fb b4 	sub	r8,sp,-1100
80008600:	1a d8       	st.w	--sp,r8
80008602:	fa c8 f9 40 	sub	r8,sp,-1728
80008606:	fa c9 ff b4 	sub	r9,sp,-76
8000860a:	04 9a       	mov	r10,r2
8000860c:	0c 9b       	mov	r11,r6
8000860e:	08 9c       	mov	r12,r4
80008610:	fe b0 fc 1a 	rcall	80007e44 <get_arg>
80008614:	2f dd       	sub	sp,-12
80008616:	19 b8       	ld.ub	r8,r12[0x3]
80008618:	c2 28       	rjmp	8000865c <_vfprintf_r+0x4e8>
8000861a:	2f f7       	sub	r7,-1
8000861c:	10 39       	cp.w	r9,r8
8000861e:	c0 84       	brge	8000862e <_vfprintf_r+0x4ba>
80008620:	fa ca f9 44 	sub	r10,sp,-1724
80008624:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008628:	ed 38 fd 8b 	ld.ub	r8,r6[-629]
8000862c:	c1 88       	rjmp	8000865c <_vfprintf_r+0x4e8>
8000862e:	41 09       	lddsp	r9,sp[0x40]
80008630:	59 f8       	cp.w	r8,31
80008632:	e0 89 00 12 	brgt	80008656 <_vfprintf_r+0x4e2>
80008636:	f2 ca ff fc 	sub	r10,r9,-4
8000863a:	51 0a       	stdsp	sp[0x40],r10
8000863c:	72 09       	ld.w	r9,r9[0x0]
8000863e:	fa c6 f9 44 	sub	r6,sp,-1724
80008642:	ec 08 00 3a 	add	r10,r6,r8<<0x3
80008646:	2f f8       	sub	r8,-1
80008648:	f5 49 fd 88 	st.w	r10[-632],r9
8000864c:	fb 48 06 b4 	st.w	sp[1716],r8
80008650:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
80008654:	c0 48       	rjmp	8000865c <_vfprintf_r+0x4e8>
80008656:	13 b8       	ld.ub	r8,r9[0x3]
80008658:	2f c9       	sub	r9,-4
8000865a:	51 09       	stdsp	sp[0x40],r9
8000865c:	fb 68 06 60 	st.b	sp[1632],r8
80008660:	30 0e       	mov	lr,0
80008662:	30 08       	mov	r8,0
80008664:	30 12       	mov	r2,1
80008666:	fb 68 06 bb 	st.b	sp[1723],r8
8000866a:	50 2e       	stdsp	sp[0x8],lr
8000866c:	e0 8f 08 ad 	bral	800097c6 <_vfprintf_r+0x1652>
80008670:	50 a7       	stdsp	sp[0x28],r7
80008672:	50 80       	stdsp	sp[0x20],r0
80008674:	0c 97       	mov	r7,r6
80008676:	04 94       	mov	r4,r2
80008678:	06 96       	mov	r6,r3
8000867a:	02 92       	mov	r2,r1
8000867c:	40 93       	lddsp	r3,sp[0x24]
8000867e:	10 90       	mov	r0,r8
80008680:	40 41       	lddsp	r1,sp[0x10]
80008682:	a5 a5       	sbr	r5,0x4
80008684:	c0 a8       	rjmp	80008698 <_vfprintf_r+0x524>
80008686:	50 a7       	stdsp	sp[0x28],r7
80008688:	50 80       	stdsp	sp[0x20],r0
8000868a:	0c 97       	mov	r7,r6
8000868c:	04 94       	mov	r4,r2
8000868e:	06 96       	mov	r6,r3
80008690:	02 92       	mov	r2,r1
80008692:	40 93       	lddsp	r3,sp[0x24]
80008694:	10 90       	mov	r0,r8
80008696:	40 41       	lddsp	r1,sp[0x10]
80008698:	ed b5 00 05 	bld	r5,0x5
8000869c:	c5 11       	brne	8000873e <_vfprintf_r+0x5ca>
8000869e:	fa f8 06 b4 	ld.w	r8,sp[1716]
800086a2:	40 3c       	lddsp	r12,sp[0xc]
800086a4:	58 0c       	cp.w	r12,0
800086a6:	c1 e0       	breq	800086e2 <_vfprintf_r+0x56e>
800086a8:	10 36       	cp.w	r6,r8
800086aa:	c0 64       	brge	800086b6 <_vfprintf_r+0x542>
800086ac:	fa cb f9 44 	sub	r11,sp,-1724
800086b0:	f6 06 00 36 	add	r6,r11,r6<<0x3
800086b4:	c2 08       	rjmp	800086f4 <_vfprintf_r+0x580>
800086b6:	fa c8 f9 50 	sub	r8,sp,-1712
800086ba:	1a d8       	st.w	--sp,r8
800086bc:	fa c8 fa b8 	sub	r8,sp,-1352
800086c0:	0c 9b       	mov	r11,r6
800086c2:	1a d8       	st.w	--sp,r8
800086c4:	fa c8 fb b4 	sub	r8,sp,-1100
800086c8:	1a d8       	st.w	--sp,r8
800086ca:	fa c9 ff b4 	sub	r9,sp,-76
800086ce:	fa c8 f9 40 	sub	r8,sp,-1728
800086d2:	04 9a       	mov	r10,r2
800086d4:	08 9c       	mov	r12,r4
800086d6:	fe b0 fb b7 	rcall	80007e44 <get_arg>
800086da:	2f dd       	sub	sp,-12
800086dc:	78 1b       	ld.w	r11,r12[0x4]
800086de:	78 09       	ld.w	r9,r12[0x0]
800086e0:	c2 b8       	rjmp	80008736 <_vfprintf_r+0x5c2>
800086e2:	ee ca ff ff 	sub	r10,r7,-1
800086e6:	10 37       	cp.w	r7,r8
800086e8:	c0 b4       	brge	800086fe <_vfprintf_r+0x58a>
800086ea:	fa c9 f9 44 	sub	r9,sp,-1724
800086ee:	14 97       	mov	r7,r10
800086f0:	f2 06 00 36 	add	r6,r9,r6<<0x3
800086f4:	ec fb fd 8c 	ld.w	r11,r6[-628]
800086f8:	ec f9 fd 88 	ld.w	r9,r6[-632]
800086fc:	c1 d8       	rjmp	80008736 <_vfprintf_r+0x5c2>
800086fe:	41 09       	lddsp	r9,sp[0x40]
80008700:	59 f8       	cp.w	r8,31
80008702:	e0 89 00 14 	brgt	8000872a <_vfprintf_r+0x5b6>
80008706:	f2 cb ff f8 	sub	r11,r9,-8
8000870a:	51 0b       	stdsp	sp[0x40],r11
8000870c:	fa c6 f9 44 	sub	r6,sp,-1724
80008710:	72 1b       	ld.w	r11,r9[0x4]
80008712:	ec 08 00 3c 	add	r12,r6,r8<<0x3
80008716:	72 09       	ld.w	r9,r9[0x0]
80008718:	f9 4b fd 8c 	st.w	r12[-628],r11
8000871c:	f9 49 fd 88 	st.w	r12[-632],r9
80008720:	2f f8       	sub	r8,-1
80008722:	14 97       	mov	r7,r10
80008724:	fb 48 06 b4 	st.w	sp[1716],r8
80008728:	c0 78       	rjmp	80008736 <_vfprintf_r+0x5c2>
8000872a:	f2 c8 ff f8 	sub	r8,r9,-8
8000872e:	72 1b       	ld.w	r11,r9[0x4]
80008730:	14 97       	mov	r7,r10
80008732:	51 08       	stdsp	sp[0x40],r8
80008734:	72 09       	ld.w	r9,r9[0x0]
80008736:	16 98       	mov	r8,r11
80008738:	fa e9 00 00 	st.d	sp[0],r8
8000873c:	ca e8       	rjmp	80008898 <_vfprintf_r+0x724>
8000873e:	ed b5 00 04 	bld	r5,0x4
80008742:	c1 71       	brne	80008770 <_vfprintf_r+0x5fc>
80008744:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008748:	40 3e       	lddsp	lr,sp[0xc]
8000874a:	58 0e       	cp.w	lr,0
8000874c:	c0 80       	breq	8000875c <_vfprintf_r+0x5e8>
8000874e:	10 36       	cp.w	r6,r8
80008750:	c6 94       	brge	80008822 <_vfprintf_r+0x6ae>
80008752:	fa cc f9 44 	sub	r12,sp,-1724
80008756:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000875a:	c8 28       	rjmp	8000885e <_vfprintf_r+0x6ea>
8000875c:	ee ca ff ff 	sub	r10,r7,-1
80008760:	10 37       	cp.w	r7,r8
80008762:	e0 84 00 81 	brge	80008864 <_vfprintf_r+0x6f0>
80008766:	fa cb f9 44 	sub	r11,sp,-1724
8000876a:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000876e:	c7 78       	rjmp	8000885c <_vfprintf_r+0x6e8>
80008770:	ed b5 00 06 	bld	r5,0x6
80008774:	c4 b1       	brne	8000880a <_vfprintf_r+0x696>
80008776:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000877a:	40 3c       	lddsp	r12,sp[0xc]
8000877c:	58 0c       	cp.w	r12,0
8000877e:	c1 d0       	breq	800087b8 <_vfprintf_r+0x644>
80008780:	10 36       	cp.w	r6,r8
80008782:	c0 64       	brge	8000878e <_vfprintf_r+0x61a>
80008784:	fa cb f9 44 	sub	r11,sp,-1724
80008788:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000878c:	c1 f8       	rjmp	800087ca <_vfprintf_r+0x656>
8000878e:	fa c8 f9 50 	sub	r8,sp,-1712
80008792:	1a d8       	st.w	--sp,r8
80008794:	fa c8 fa b8 	sub	r8,sp,-1352
80008798:	1a d8       	st.w	--sp,r8
8000879a:	fa c8 fb b4 	sub	r8,sp,-1100
8000879e:	1a d8       	st.w	--sp,r8
800087a0:	fa c8 f9 40 	sub	r8,sp,-1728
800087a4:	fa c9 ff b4 	sub	r9,sp,-76
800087a8:	04 9a       	mov	r10,r2
800087aa:	0c 9b       	mov	r11,r6
800087ac:	08 9c       	mov	r12,r4
800087ae:	fe b0 fb 4b 	rcall	80007e44 <get_arg>
800087b2:	2f dd       	sub	sp,-12
800087b4:	98 18       	ld.sh	r8,r12[0x2]
800087b6:	c2 68       	rjmp	80008802 <_vfprintf_r+0x68e>
800087b8:	ee ca ff ff 	sub	r10,r7,-1
800087bc:	10 37       	cp.w	r7,r8
800087be:	c0 94       	brge	800087d0 <_vfprintf_r+0x65c>
800087c0:	fa c9 f9 44 	sub	r9,sp,-1724
800087c4:	14 97       	mov	r7,r10
800087c6:	f2 06 00 36 	add	r6,r9,r6<<0x3
800087ca:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
800087ce:	c1 a8       	rjmp	80008802 <_vfprintf_r+0x68e>
800087d0:	41 09       	lddsp	r9,sp[0x40]
800087d2:	59 f8       	cp.w	r8,31
800087d4:	e0 89 00 13 	brgt	800087fa <_vfprintf_r+0x686>
800087d8:	f2 cb ff fc 	sub	r11,r9,-4
800087dc:	51 0b       	stdsp	sp[0x40],r11
800087de:	72 09       	ld.w	r9,r9[0x0]
800087e0:	fa c6 f9 44 	sub	r6,sp,-1724
800087e4:	ec 08 00 3b 	add	r11,r6,r8<<0x3
800087e8:	2f f8       	sub	r8,-1
800087ea:	f7 49 fd 88 	st.w	r11[-632],r9
800087ee:	fb 48 06 b4 	st.w	sp[1716],r8
800087f2:	14 97       	mov	r7,r10
800087f4:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
800087f8:	c0 58       	rjmp	80008802 <_vfprintf_r+0x68e>
800087fa:	92 18       	ld.sh	r8,r9[0x2]
800087fc:	14 97       	mov	r7,r10
800087fe:	2f c9       	sub	r9,-4
80008800:	51 09       	stdsp	sp[0x40],r9
80008802:	50 18       	stdsp	sp[0x4],r8
80008804:	bf 58       	asr	r8,0x1f
80008806:	50 08       	stdsp	sp[0x0],r8
80008808:	c4 88       	rjmp	80008898 <_vfprintf_r+0x724>
8000880a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000880e:	40 3c       	lddsp	r12,sp[0xc]
80008810:	58 0c       	cp.w	r12,0
80008812:	c1 d0       	breq	8000884c <_vfprintf_r+0x6d8>
80008814:	10 36       	cp.w	r6,r8
80008816:	c0 64       	brge	80008822 <_vfprintf_r+0x6ae>
80008818:	fa cb f9 44 	sub	r11,sp,-1724
8000881c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008820:	c1 f8       	rjmp	8000885e <_vfprintf_r+0x6ea>
80008822:	fa c8 f9 50 	sub	r8,sp,-1712
80008826:	1a d8       	st.w	--sp,r8
80008828:	fa c8 fa b8 	sub	r8,sp,-1352
8000882c:	0c 9b       	mov	r11,r6
8000882e:	1a d8       	st.w	--sp,r8
80008830:	fa c8 fb b4 	sub	r8,sp,-1100
80008834:	04 9a       	mov	r10,r2
80008836:	1a d8       	st.w	--sp,r8
80008838:	08 9c       	mov	r12,r4
8000883a:	fa c8 f9 40 	sub	r8,sp,-1728
8000883e:	fa c9 ff b4 	sub	r9,sp,-76
80008842:	fe b0 fb 01 	rcall	80007e44 <get_arg>
80008846:	2f dd       	sub	sp,-12
80008848:	78 0b       	ld.w	r11,r12[0x0]
8000884a:	c2 48       	rjmp	80008892 <_vfprintf_r+0x71e>
8000884c:	ee ca ff ff 	sub	r10,r7,-1
80008850:	10 37       	cp.w	r7,r8
80008852:	c0 94       	brge	80008864 <_vfprintf_r+0x6f0>
80008854:	fa c9 f9 44 	sub	r9,sp,-1724
80008858:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000885c:	14 97       	mov	r7,r10
8000885e:	ec fb fd 88 	ld.w	r11,r6[-632]
80008862:	c1 88       	rjmp	80008892 <_vfprintf_r+0x71e>
80008864:	41 09       	lddsp	r9,sp[0x40]
80008866:	59 f8       	cp.w	r8,31
80008868:	e0 89 00 11 	brgt	8000888a <_vfprintf_r+0x716>
8000886c:	f2 cb ff fc 	sub	r11,r9,-4
80008870:	51 0b       	stdsp	sp[0x40],r11
80008872:	fa c6 f9 44 	sub	r6,sp,-1724
80008876:	72 0b       	ld.w	r11,r9[0x0]
80008878:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000887c:	f3 4b fd 88 	st.w	r9[-632],r11
80008880:	2f f8       	sub	r8,-1
80008882:	14 97       	mov	r7,r10
80008884:	fb 48 06 b4 	st.w	sp[1716],r8
80008888:	c0 58       	rjmp	80008892 <_vfprintf_r+0x71e>
8000888a:	72 0b       	ld.w	r11,r9[0x0]
8000888c:	14 97       	mov	r7,r10
8000888e:	2f c9       	sub	r9,-4
80008890:	51 09       	stdsp	sp[0x40],r9
80008892:	50 1b       	stdsp	sp[0x4],r11
80008894:	bf 5b       	asr	r11,0x1f
80008896:	50 0b       	stdsp	sp[0x0],r11
80008898:	fa ea 00 00 	ld.d	r10,sp[0]
8000889c:	58 0a       	cp.w	r10,0
8000889e:	5c 2b       	cpc	r11
800088a0:	c0 e4       	brge	800088bc <_vfprintf_r+0x748>
800088a2:	30 08       	mov	r8,0
800088a4:	fa ea 00 00 	ld.d	r10,sp[0]
800088a8:	30 09       	mov	r9,0
800088aa:	f0 0a 01 0a 	sub	r10,r8,r10
800088ae:	f2 0b 01 4b 	sbc	r11,r9,r11
800088b2:	32 d8       	mov	r8,45
800088b4:	fa eb 00 00 	st.d	sp[0],r10
800088b8:	fb 68 06 bb 	st.b	sp[1723],r8
800088bc:	30 18       	mov	r8,1
800088be:	e0 8f 06 fa 	bral	800096b2 <_vfprintf_r+0x153e>
800088c2:	50 a7       	stdsp	sp[0x28],r7
800088c4:	50 80       	stdsp	sp[0x20],r0
800088c6:	0c 97       	mov	r7,r6
800088c8:	04 94       	mov	r4,r2
800088ca:	06 96       	mov	r6,r3
800088cc:	02 92       	mov	r2,r1
800088ce:	40 93       	lddsp	r3,sp[0x24]
800088d0:	10 90       	mov	r0,r8
800088d2:	40 41       	lddsp	r1,sp[0x10]
800088d4:	0e 99       	mov	r9,r7
800088d6:	ed b5 00 03 	bld	r5,0x3
800088da:	c4 11       	brne	8000895c <_vfprintf_r+0x7e8>
800088dc:	fa f8 06 b4 	ld.w	r8,sp[1716]
800088e0:	40 3a       	lddsp	r10,sp[0xc]
800088e2:	58 0a       	cp.w	r10,0
800088e4:	c1 90       	breq	80008916 <_vfprintf_r+0x7a2>
800088e6:	10 36       	cp.w	r6,r8
800088e8:	c6 45       	brlt	800089b0 <_vfprintf_r+0x83c>
800088ea:	fa c8 f9 50 	sub	r8,sp,-1712
800088ee:	1a d8       	st.w	--sp,r8
800088f0:	fa c8 fa b8 	sub	r8,sp,-1352
800088f4:	1a d8       	st.w	--sp,r8
800088f6:	fa c8 fb b4 	sub	r8,sp,-1100
800088fa:	0c 9b       	mov	r11,r6
800088fc:	1a d8       	st.w	--sp,r8
800088fe:	04 9a       	mov	r10,r2
80008900:	fa c8 f9 40 	sub	r8,sp,-1728
80008904:	fa c9 ff b4 	sub	r9,sp,-76
80008908:	08 9c       	mov	r12,r4
8000890a:	fe b0 fa 9d 	rcall	80007e44 <get_arg>
8000890e:	2f dd       	sub	sp,-12
80008910:	78 16       	ld.w	r6,r12[0x4]
80008912:	50 76       	stdsp	sp[0x1c],r6
80008914:	c4 88       	rjmp	800089a4 <_vfprintf_r+0x830>
80008916:	2f f7       	sub	r7,-1
80008918:	10 39       	cp.w	r9,r8
8000891a:	c0 c4       	brge	80008932 <_vfprintf_r+0x7be>
8000891c:	fa ce f9 44 	sub	lr,sp,-1724
80008920:	fc 06 00 36 	add	r6,lr,r6<<0x3
80008924:	ec fc fd 8c 	ld.w	r12,r6[-628]
80008928:	50 7c       	stdsp	sp[0x1c],r12
8000892a:	ec f6 fd 88 	ld.w	r6,r6[-632]
8000892e:	50 56       	stdsp	sp[0x14],r6
80008930:	c6 68       	rjmp	800089fc <_vfprintf_r+0x888>
80008932:	41 09       	lddsp	r9,sp[0x40]
80008934:	59 f8       	cp.w	r8,31
80008936:	e0 89 00 10 	brgt	80008956 <_vfprintf_r+0x7e2>
8000893a:	f2 ca ff f8 	sub	r10,r9,-8
8000893e:	72 1b       	ld.w	r11,r9[0x4]
80008940:	51 0a       	stdsp	sp[0x40],r10
80008942:	72 09       	ld.w	r9,r9[0x0]
80008944:	fa ca f9 44 	sub	r10,sp,-1724
80008948:	50 7b       	stdsp	sp[0x1c],r11
8000894a:	50 59       	stdsp	sp[0x14],r9
8000894c:	f4 08 00 39 	add	r9,r10,r8<<0x3
80008950:	40 5b       	lddsp	r11,sp[0x14]
80008952:	40 7a       	lddsp	r10,sp[0x1c]
80008954:	c4 78       	rjmp	800089e2 <_vfprintf_r+0x86e>
80008956:	72 18       	ld.w	r8,r9[0x4]
80008958:	50 78       	stdsp	sp[0x1c],r8
8000895a:	c4 c8       	rjmp	800089f2 <_vfprintf_r+0x87e>
8000895c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008960:	40 3e       	lddsp	lr,sp[0xc]
80008962:	58 0e       	cp.w	lr,0
80008964:	c2 30       	breq	800089aa <_vfprintf_r+0x836>
80008966:	10 36       	cp.w	r6,r8
80008968:	c0 94       	brge	8000897a <_vfprintf_r+0x806>
8000896a:	fa cc f9 44 	sub	r12,sp,-1724
8000896e:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008972:	ec fb fd 8c 	ld.w	r11,r6[-628]
80008976:	50 7b       	stdsp	sp[0x1c],r11
80008978:	cd 9b       	rjmp	8000892a <_vfprintf_r+0x7b6>
8000897a:	fa c8 f9 50 	sub	r8,sp,-1712
8000897e:	1a d8       	st.w	--sp,r8
80008980:	fa c8 fa b8 	sub	r8,sp,-1352
80008984:	04 9a       	mov	r10,r2
80008986:	1a d8       	st.w	--sp,r8
80008988:	fa c8 fb b4 	sub	r8,sp,-1100
8000898c:	0c 9b       	mov	r11,r6
8000898e:	1a d8       	st.w	--sp,r8
80008990:	08 9c       	mov	r12,r4
80008992:	fa c8 f9 40 	sub	r8,sp,-1728
80008996:	fa c9 ff b4 	sub	r9,sp,-76
8000899a:	fe b0 fa 55 	rcall	80007e44 <get_arg>
8000899e:	2f dd       	sub	sp,-12
800089a0:	78 1a       	ld.w	r10,r12[0x4]
800089a2:	50 7a       	stdsp	sp[0x1c],r10
800089a4:	78 0c       	ld.w	r12,r12[0x0]
800089a6:	50 5c       	stdsp	sp[0x14],r12
800089a8:	c2 a8       	rjmp	800089fc <_vfprintf_r+0x888>
800089aa:	2f f7       	sub	r7,-1
800089ac:	10 39       	cp.w	r9,r8
800089ae:	c0 94       	brge	800089c0 <_vfprintf_r+0x84c>
800089b0:	fa c9 f9 44 	sub	r9,sp,-1724
800089b4:	f2 06 00 36 	add	r6,r9,r6<<0x3
800089b8:	ec f8 fd 8c 	ld.w	r8,r6[-628]
800089bc:	50 78       	stdsp	sp[0x1c],r8
800089be:	cb 6b       	rjmp	8000892a <_vfprintf_r+0x7b6>
800089c0:	41 09       	lddsp	r9,sp[0x40]
800089c2:	59 f8       	cp.w	r8,31
800089c4:	e0 89 00 15 	brgt	800089ee <_vfprintf_r+0x87a>
800089c8:	f2 ca ff f8 	sub	r10,r9,-8
800089cc:	72 16       	ld.w	r6,r9[0x4]
800089ce:	72 09       	ld.w	r9,r9[0x0]
800089d0:	51 0a       	stdsp	sp[0x40],r10
800089d2:	50 59       	stdsp	sp[0x14],r9
800089d4:	fa ce f9 44 	sub	lr,sp,-1724
800089d8:	50 76       	stdsp	sp[0x1c],r6
800089da:	fc 08 00 39 	add	r9,lr,r8<<0x3
800089de:	40 5b       	lddsp	r11,sp[0x14]
800089e0:	0c 9a       	mov	r10,r6
800089e2:	f2 eb fd 88 	st.d	r9[-632],r10
800089e6:	2f f8       	sub	r8,-1
800089e8:	fb 48 06 b4 	st.w	sp[1716],r8
800089ec:	c0 88       	rjmp	800089fc <_vfprintf_r+0x888>
800089ee:	72 1c       	ld.w	r12,r9[0x4]
800089f0:	50 7c       	stdsp	sp[0x1c],r12
800089f2:	f2 c8 ff f8 	sub	r8,r9,-8
800089f6:	51 08       	stdsp	sp[0x40],r8
800089f8:	72 09       	ld.w	r9,r9[0x0]
800089fa:	50 59       	stdsp	sp[0x14],r9
800089fc:	40 5b       	lddsp	r11,sp[0x14]
800089fe:	40 7a       	lddsp	r10,sp[0x1c]
80008a00:	e0 a0 19 54 	rcall	8000bca8 <__isinfd>
80008a04:	18 96       	mov	r6,r12
80008a06:	c1 70       	breq	80008a34 <_vfprintf_r+0x8c0>
80008a08:	30 08       	mov	r8,0
80008a0a:	30 09       	mov	r9,0
80008a0c:	40 5b       	lddsp	r11,sp[0x14]
80008a0e:	40 7a       	lddsp	r10,sp[0x1c]
80008a10:	e0 a0 1d b4 	rcall	8000c578 <__avr32_f64_cmp_lt>
80008a14:	c0 40       	breq	80008a1c <_vfprintf_r+0x8a8>
80008a16:	32 d8       	mov	r8,45
80008a18:	fb 68 06 bb 	st.b	sp[1723],r8
80008a1c:	fe c8 aa 2c 	sub	r8,pc,-21972
80008a20:	fe c6 aa 2c 	sub	r6,pc,-21972
80008a24:	a7 d5       	cbr	r5,0x7
80008a26:	e0 40 00 47 	cp.w	r0,71
80008a2a:	f0 06 17 a0 	movle	r6,r8
80008a2e:	30 32       	mov	r2,3
80008a30:	e0 8f 06 ce 	bral	800097cc <_vfprintf_r+0x1658>
80008a34:	40 5b       	lddsp	r11,sp[0x14]
80008a36:	40 7a       	lddsp	r10,sp[0x1c]
80008a38:	e0 a0 19 4d 	rcall	8000bcd2 <__isnand>
80008a3c:	c0 e0       	breq	80008a58 <_vfprintf_r+0x8e4>
80008a3e:	50 26       	stdsp	sp[0x8],r6
80008a40:	fe c8 aa 48 	sub	r8,pc,-21944
80008a44:	fe c6 aa 48 	sub	r6,pc,-21944
80008a48:	a7 d5       	cbr	r5,0x7
80008a4a:	e0 40 00 47 	cp.w	r0,71
80008a4e:	f0 06 17 a0 	movle	r6,r8
80008a52:	30 32       	mov	r2,3
80008a54:	e0 8f 06 c2 	bral	800097d8 <_vfprintf_r+0x1664>
80008a58:	40 2a       	lddsp	r10,sp[0x8]
80008a5a:	5b fa       	cp.w	r10,-1
80008a5c:	c0 41       	brne	80008a64 <_vfprintf_r+0x8f0>
80008a5e:	30 69       	mov	r9,6
80008a60:	50 29       	stdsp	sp[0x8],r9
80008a62:	c1 18       	rjmp	80008a84 <_vfprintf_r+0x910>
80008a64:	e0 40 00 47 	cp.w	r0,71
80008a68:	5f 09       	sreq	r9
80008a6a:	e0 40 00 67 	cp.w	r0,103
80008a6e:	5f 08       	sreq	r8
80008a70:	f3 e8 10 08 	or	r8,r9,r8
80008a74:	f8 08 18 00 	cp.b	r8,r12
80008a78:	c0 60       	breq	80008a84 <_vfprintf_r+0x910>
80008a7a:	40 28       	lddsp	r8,sp[0x8]
80008a7c:	58 08       	cp.w	r8,0
80008a7e:	f9 b8 00 01 	moveq	r8,1
80008a82:	50 28       	stdsp	sp[0x8],r8
80008a84:	40 78       	lddsp	r8,sp[0x1c]
80008a86:	40 59       	lddsp	r9,sp[0x14]
80008a88:	fa e9 06 94 	st.d	sp[1684],r8
80008a8c:	a9 a5       	sbr	r5,0x8
80008a8e:	fa f8 06 94 	ld.w	r8,sp[1684]
80008a92:	58 08       	cp.w	r8,0
80008a94:	c0 65       	brlt	80008aa0 <_vfprintf_r+0x92c>
80008a96:	40 5e       	lddsp	lr,sp[0x14]
80008a98:	30 0c       	mov	r12,0
80008a9a:	50 6e       	stdsp	sp[0x18],lr
80008a9c:	50 9c       	stdsp	sp[0x24],r12
80008a9e:	c0 78       	rjmp	80008aac <_vfprintf_r+0x938>
80008aa0:	40 5b       	lddsp	r11,sp[0x14]
80008aa2:	32 da       	mov	r10,45
80008aa4:	ee 1b 80 00 	eorh	r11,0x8000
80008aa8:	50 9a       	stdsp	sp[0x24],r10
80008aaa:	50 6b       	stdsp	sp[0x18],r11
80008aac:	e0 40 00 46 	cp.w	r0,70
80008ab0:	5f 09       	sreq	r9
80008ab2:	e0 40 00 66 	cp.w	r0,102
80008ab6:	5f 08       	sreq	r8
80008ab8:	f3 e8 10 08 	or	r8,r9,r8
80008abc:	50 48       	stdsp	sp[0x10],r8
80008abe:	c0 40       	breq	80008ac6 <_vfprintf_r+0x952>
80008ac0:	40 22       	lddsp	r2,sp[0x8]
80008ac2:	30 39       	mov	r9,3
80008ac4:	c1 08       	rjmp	80008ae4 <_vfprintf_r+0x970>
80008ac6:	e0 40 00 45 	cp.w	r0,69
80008aca:	5f 09       	sreq	r9
80008acc:	e0 40 00 65 	cp.w	r0,101
80008ad0:	5f 08       	sreq	r8
80008ad2:	40 22       	lddsp	r2,sp[0x8]
80008ad4:	10 49       	or	r9,r8
80008ad6:	2f f2       	sub	r2,-1
80008ad8:	40 46       	lddsp	r6,sp[0x10]
80008ada:	ec 09 18 00 	cp.b	r9,r6
80008ade:	fb f2 00 02 	ld.weq	r2,sp[0x8]
80008ae2:	30 29       	mov	r9,2
80008ae4:	fa c8 f9 5c 	sub	r8,sp,-1700
80008ae8:	1a d8       	st.w	--sp,r8
80008aea:	fa c8 f9 54 	sub	r8,sp,-1708
80008aee:	1a d8       	st.w	--sp,r8
80008af0:	fa c8 f9 4c 	sub	r8,sp,-1716
80008af4:	08 9c       	mov	r12,r4
80008af6:	1a d8       	st.w	--sp,r8
80008af8:	04 98       	mov	r8,r2
80008afa:	40 9b       	lddsp	r11,sp[0x24]
80008afc:	40 aa       	lddsp	r10,sp[0x28]
80008afe:	e0 a0 0b c3 	rcall	8000a284 <_dtoa_r>
80008b02:	e0 40 00 47 	cp.w	r0,71
80008b06:	5f 19       	srne	r9
80008b08:	e0 40 00 67 	cp.w	r0,103
80008b0c:	5f 18       	srne	r8
80008b0e:	18 96       	mov	r6,r12
80008b10:	2f dd       	sub	sp,-12
80008b12:	f3 e8 00 08 	and	r8,r9,r8
80008b16:	c0 41       	brne	80008b1e <_vfprintf_r+0x9aa>
80008b18:	ed b5 00 00 	bld	r5,0x0
80008b1c:	c3 01       	brne	80008b7c <_vfprintf_r+0xa08>
80008b1e:	ec 02 00 0e 	add	lr,r6,r2
80008b22:	50 3e       	stdsp	sp[0xc],lr
80008b24:	40 4c       	lddsp	r12,sp[0x10]
80008b26:	58 0c       	cp.w	r12,0
80008b28:	c1 50       	breq	80008b52 <_vfprintf_r+0x9de>
80008b2a:	0d 89       	ld.ub	r9,r6[0x0]
80008b2c:	33 08       	mov	r8,48
80008b2e:	f0 09 18 00 	cp.b	r9,r8
80008b32:	c0 b1       	brne	80008b48 <_vfprintf_r+0x9d4>
80008b34:	30 08       	mov	r8,0
80008b36:	30 09       	mov	r9,0
80008b38:	40 6b       	lddsp	r11,sp[0x18]
80008b3a:	40 7a       	lddsp	r10,sp[0x1c]
80008b3c:	e0 a0 1c d7 	rcall	8000c4ea <__avr32_f64_cmp_eq>
80008b40:	fb b2 00 01 	rsubeq	r2,1
80008b44:	fb f2 0b ab 	st.weq	sp[0x6ac],r2
80008b48:	40 3b       	lddsp	r11,sp[0xc]
80008b4a:	fa f8 06 ac 	ld.w	r8,sp[1708]
80008b4e:	10 0b       	add	r11,r8
80008b50:	50 3b       	stdsp	sp[0xc],r11
80008b52:	40 6b       	lddsp	r11,sp[0x18]
80008b54:	30 08       	mov	r8,0
80008b56:	30 09       	mov	r9,0
80008b58:	40 7a       	lddsp	r10,sp[0x1c]
80008b5a:	e0 a0 1c c8 	rcall	8000c4ea <__avr32_f64_cmp_eq>
80008b5e:	c0 90       	breq	80008b70 <_vfprintf_r+0x9fc>
80008b60:	40 3a       	lddsp	r10,sp[0xc]
80008b62:	fb 4a 06 a4 	st.w	sp[1700],r10
80008b66:	c0 58       	rjmp	80008b70 <_vfprintf_r+0x9fc>
80008b68:	10 c9       	st.b	r8++,r9
80008b6a:	fb 48 06 a4 	st.w	sp[1700],r8
80008b6e:	c0 28       	rjmp	80008b72 <_vfprintf_r+0x9fe>
80008b70:	33 09       	mov	r9,48
80008b72:	fa f8 06 a4 	ld.w	r8,sp[1700]
80008b76:	40 3e       	lddsp	lr,sp[0xc]
80008b78:	1c 38       	cp.w	r8,lr
80008b7a:	cf 73       	brcs	80008b68 <_vfprintf_r+0x9f4>
80008b7c:	e0 40 00 47 	cp.w	r0,71
80008b80:	5f 09       	sreq	r9
80008b82:	e0 40 00 67 	cp.w	r0,103
80008b86:	5f 08       	sreq	r8
80008b88:	f3 e8 10 08 	or	r8,r9,r8
80008b8c:	fa f9 06 a4 	ld.w	r9,sp[1700]
80008b90:	0c 19       	sub	r9,r6
80008b92:	50 69       	stdsp	sp[0x18],r9
80008b94:	58 08       	cp.w	r8,0
80008b96:	c0 b0       	breq	80008bac <_vfprintf_r+0xa38>
80008b98:	fa f8 06 ac 	ld.w	r8,sp[1708]
80008b9c:	5b d8       	cp.w	r8,-3
80008b9e:	c0 55       	brlt	80008ba8 <_vfprintf_r+0xa34>
80008ba0:	40 2c       	lddsp	r12,sp[0x8]
80008ba2:	18 38       	cp.w	r8,r12
80008ba4:	e0 8a 00 6a 	brle	80008c78 <_vfprintf_r+0xb04>
80008ba8:	20 20       	sub	r0,2
80008baa:	c0 58       	rjmp	80008bb4 <_vfprintf_r+0xa40>
80008bac:	e0 40 00 65 	cp.w	r0,101
80008bb0:	e0 89 00 46 	brgt	80008c3c <_vfprintf_r+0xac8>
80008bb4:	fa fb 06 ac 	ld.w	r11,sp[1708]
80008bb8:	fb 60 06 9c 	st.b	sp[1692],r0
80008bbc:	20 1b       	sub	r11,1
80008bbe:	fb 4b 06 ac 	st.w	sp[1708],r11
80008bc2:	c0 47       	brpl	80008bca <_vfprintf_r+0xa56>
80008bc4:	5c 3b       	neg	r11
80008bc6:	32 d8       	mov	r8,45
80008bc8:	c0 28       	rjmp	80008bcc <_vfprintf_r+0xa58>
80008bca:	32 b8       	mov	r8,43
80008bcc:	fb 68 06 9d 	st.b	sp[1693],r8
80008bd0:	58 9b       	cp.w	r11,9
80008bd2:	e0 8a 00 1d 	brle	80008c0c <_vfprintf_r+0xa98>
80008bd6:	fa c9 fa 35 	sub	r9,sp,-1483
80008bda:	30 aa       	mov	r10,10
80008bdc:	12 98       	mov	r8,r9
80008bde:	0e 9c       	mov	r12,r7
80008be0:	0c 92       	mov	r2,r6
80008be2:	f6 0a 0c 06 	divs	r6,r11,r10
80008be6:	0e 9b       	mov	r11,r7
80008be8:	2d 0b       	sub	r11,-48
80008bea:	10 fb       	st.b	--r8,r11
80008bec:	0c 9b       	mov	r11,r6
80008bee:	58 96       	cp.w	r6,9
80008bf0:	fe 99 ff f9 	brgt	80008be2 <_vfprintf_r+0xa6e>
80008bf4:	2d 0b       	sub	r11,-48
80008bf6:	18 97       	mov	r7,r12
80008bf8:	04 96       	mov	r6,r2
80008bfa:	10 fb       	st.b	--r8,r11
80008bfc:	fa ca f9 62 	sub	r10,sp,-1694
80008c00:	c0 38       	rjmp	80008c06 <_vfprintf_r+0xa92>
80008c02:	11 3b       	ld.ub	r11,r8++
80008c04:	14 cb       	st.b	r10++,r11
80008c06:	12 38       	cp.w	r8,r9
80008c08:	cf d3       	brcs	80008c02 <_vfprintf_r+0xa8e>
80008c0a:	c0 98       	rjmp	80008c1c <_vfprintf_r+0xaa8>
80008c0c:	2d 0b       	sub	r11,-48
80008c0e:	33 08       	mov	r8,48
80008c10:	fb 6b 06 9f 	st.b	sp[1695],r11
80008c14:	fb 68 06 9e 	st.b	sp[1694],r8
80008c18:	fa ca f9 60 	sub	r10,sp,-1696
80008c1c:	fa c8 f9 64 	sub	r8,sp,-1692
80008c20:	f4 08 01 08 	sub	r8,r10,r8
80008c24:	50 e8       	stdsp	sp[0x38],r8
80008c26:	10 92       	mov	r2,r8
80008c28:	40 6b       	lddsp	r11,sp[0x18]
80008c2a:	16 02       	add	r2,r11
80008c2c:	58 1b       	cp.w	r11,1
80008c2e:	e0 89 00 05 	brgt	80008c38 <_vfprintf_r+0xac4>
80008c32:	ed b5 00 00 	bld	r5,0x0
80008c36:	c3 51       	brne	80008ca0 <_vfprintf_r+0xb2c>
80008c38:	2f f2       	sub	r2,-1
80008c3a:	c3 38       	rjmp	80008ca0 <_vfprintf_r+0xb2c>
80008c3c:	e0 40 00 66 	cp.w	r0,102
80008c40:	c1 c1       	brne	80008c78 <_vfprintf_r+0xb04>
80008c42:	fa f2 06 ac 	ld.w	r2,sp[1708]
80008c46:	58 02       	cp.w	r2,0
80008c48:	e0 8a 00 0c 	brle	80008c60 <_vfprintf_r+0xaec>
80008c4c:	40 2a       	lddsp	r10,sp[0x8]
80008c4e:	58 0a       	cp.w	r10,0
80008c50:	c0 41       	brne	80008c58 <_vfprintf_r+0xae4>
80008c52:	ed b5 00 00 	bld	r5,0x0
80008c56:	c2 51       	brne	80008ca0 <_vfprintf_r+0xb2c>
80008c58:	2f f2       	sub	r2,-1
80008c5a:	40 29       	lddsp	r9,sp[0x8]
80008c5c:	12 02       	add	r2,r9
80008c5e:	c0 b8       	rjmp	80008c74 <_vfprintf_r+0xb00>
80008c60:	40 28       	lddsp	r8,sp[0x8]
80008c62:	58 08       	cp.w	r8,0
80008c64:	c0 61       	brne	80008c70 <_vfprintf_r+0xafc>
80008c66:	ed b5 00 00 	bld	r5,0x0
80008c6a:	c0 30       	breq	80008c70 <_vfprintf_r+0xafc>
80008c6c:	30 12       	mov	r2,1
80008c6e:	c1 98       	rjmp	80008ca0 <_vfprintf_r+0xb2c>
80008c70:	40 22       	lddsp	r2,sp[0x8]
80008c72:	2f e2       	sub	r2,-2
80008c74:	36 60       	mov	r0,102
80008c76:	c1 58       	rjmp	80008ca0 <_vfprintf_r+0xb2c>
80008c78:	fa f2 06 ac 	ld.w	r2,sp[1708]
80008c7c:	40 6e       	lddsp	lr,sp[0x18]
80008c7e:	1c 32       	cp.w	r2,lr
80008c80:	c0 65       	brlt	80008c8c <_vfprintf_r+0xb18>
80008c82:	ed b5 00 00 	bld	r5,0x0
80008c86:	f7 b2 00 ff 	subeq	r2,-1
80008c8a:	c0 a8       	rjmp	80008c9e <_vfprintf_r+0xb2a>
80008c8c:	e4 08 11 02 	rsub	r8,r2,2
80008c90:	40 6c       	lddsp	r12,sp[0x18]
80008c92:	58 02       	cp.w	r2,0
80008c94:	f0 02 17 a0 	movle	r2,r8
80008c98:	f9 b2 09 01 	movgt	r2,1
80008c9c:	18 02       	add	r2,r12
80008c9e:	36 70       	mov	r0,103
80008ca0:	40 9b       	lddsp	r11,sp[0x24]
80008ca2:	58 0b       	cp.w	r11,0
80008ca4:	e0 80 05 94 	breq	800097cc <_vfprintf_r+0x1658>
80008ca8:	32 d8       	mov	r8,45
80008caa:	fb 68 06 bb 	st.b	sp[1723],r8
80008cae:	e0 8f 05 93 	bral	800097d4 <_vfprintf_r+0x1660>
80008cb2:	50 a7       	stdsp	sp[0x28],r7
80008cb4:	04 94       	mov	r4,r2
80008cb6:	0c 97       	mov	r7,r6
80008cb8:	02 92       	mov	r2,r1
80008cba:	06 96       	mov	r6,r3
80008cbc:	40 41       	lddsp	r1,sp[0x10]
80008cbe:	40 93       	lddsp	r3,sp[0x24]
80008cc0:	0e 99       	mov	r9,r7
80008cc2:	ed b5 00 05 	bld	r5,0x5
80008cc6:	c4 81       	brne	80008d56 <_vfprintf_r+0xbe2>
80008cc8:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008ccc:	40 3e       	lddsp	lr,sp[0xc]
80008cce:	58 0e       	cp.w	lr,0
80008cd0:	c1 d0       	breq	80008d0a <_vfprintf_r+0xb96>
80008cd2:	10 36       	cp.w	r6,r8
80008cd4:	c0 64       	brge	80008ce0 <_vfprintf_r+0xb6c>
80008cd6:	fa cc f9 44 	sub	r12,sp,-1724
80008cda:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008cde:	c1 d8       	rjmp	80008d18 <_vfprintf_r+0xba4>
80008ce0:	fa c8 f9 50 	sub	r8,sp,-1712
80008ce4:	1a d8       	st.w	--sp,r8
80008ce6:	fa c8 fa b8 	sub	r8,sp,-1352
80008cea:	04 9a       	mov	r10,r2
80008cec:	1a d8       	st.w	--sp,r8
80008cee:	fa c8 fb b4 	sub	r8,sp,-1100
80008cf2:	0c 9b       	mov	r11,r6
80008cf4:	1a d8       	st.w	--sp,r8
80008cf6:	08 9c       	mov	r12,r4
80008cf8:	fa c8 f9 40 	sub	r8,sp,-1728
80008cfc:	fa c9 ff b4 	sub	r9,sp,-76
80008d00:	fe b0 f8 a2 	rcall	80007e44 <get_arg>
80008d04:	2f dd       	sub	sp,-12
80008d06:	78 0a       	ld.w	r10,r12[0x0]
80008d08:	c2 08       	rjmp	80008d48 <_vfprintf_r+0xbd4>
80008d0a:	2f f7       	sub	r7,-1
80008d0c:	10 39       	cp.w	r9,r8
80008d0e:	c0 84       	brge	80008d1e <_vfprintf_r+0xbaa>
80008d10:	fa cb f9 44 	sub	r11,sp,-1724
80008d14:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008d18:	ec fa fd 88 	ld.w	r10,r6[-632]
80008d1c:	c1 68       	rjmp	80008d48 <_vfprintf_r+0xbd4>
80008d1e:	41 09       	lddsp	r9,sp[0x40]
80008d20:	59 f8       	cp.w	r8,31
80008d22:	e0 89 00 10 	brgt	80008d42 <_vfprintf_r+0xbce>
80008d26:	f2 ca ff fc 	sub	r10,r9,-4
80008d2a:	51 0a       	stdsp	sp[0x40],r10
80008d2c:	fa c6 f9 44 	sub	r6,sp,-1724
80008d30:	72 0a       	ld.w	r10,r9[0x0]
80008d32:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008d36:	f3 4a fd 88 	st.w	r9[-632],r10
80008d3a:	2f f8       	sub	r8,-1
80008d3c:	fb 48 06 b4 	st.w	sp[1716],r8
80008d40:	c0 48       	rjmp	80008d48 <_vfprintf_r+0xbd4>
80008d42:	72 0a       	ld.w	r10,r9[0x0]
80008d44:	2f c9       	sub	r9,-4
80008d46:	51 09       	stdsp	sp[0x40],r9
80008d48:	40 be       	lddsp	lr,sp[0x2c]
80008d4a:	1c 98       	mov	r8,lr
80008d4c:	95 1e       	st.w	r10[0x4],lr
80008d4e:	bf 58       	asr	r8,0x1f
80008d50:	95 08       	st.w	r10[0x0],r8
80008d52:	fe 9f fa 9f 	bral	80008290 <_vfprintf_r+0x11c>
80008d56:	ed b5 00 04 	bld	r5,0x4
80008d5a:	c4 80       	breq	80008dea <_vfprintf_r+0xc76>
80008d5c:	e2 15 00 40 	andl	r5,0x40,COH
80008d60:	c4 50       	breq	80008dea <_vfprintf_r+0xc76>
80008d62:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008d66:	40 3c       	lddsp	r12,sp[0xc]
80008d68:	58 0c       	cp.w	r12,0
80008d6a:	c1 d0       	breq	80008da4 <_vfprintf_r+0xc30>
80008d6c:	10 36       	cp.w	r6,r8
80008d6e:	c0 64       	brge	80008d7a <_vfprintf_r+0xc06>
80008d70:	fa cb f9 44 	sub	r11,sp,-1724
80008d74:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008d78:	c1 d8       	rjmp	80008db2 <_vfprintf_r+0xc3e>
80008d7a:	fa c8 f9 50 	sub	r8,sp,-1712
80008d7e:	1a d8       	st.w	--sp,r8
80008d80:	fa c8 fa b8 	sub	r8,sp,-1352
80008d84:	04 9a       	mov	r10,r2
80008d86:	1a d8       	st.w	--sp,r8
80008d88:	fa c8 fb b4 	sub	r8,sp,-1100
80008d8c:	0c 9b       	mov	r11,r6
80008d8e:	1a d8       	st.w	--sp,r8
80008d90:	08 9c       	mov	r12,r4
80008d92:	fa c8 f9 40 	sub	r8,sp,-1728
80008d96:	fa c9 ff b4 	sub	r9,sp,-76
80008d9a:	fe b0 f8 55 	rcall	80007e44 <get_arg>
80008d9e:	2f dd       	sub	sp,-12
80008da0:	78 0a       	ld.w	r10,r12[0x0]
80008da2:	c2 08       	rjmp	80008de2 <_vfprintf_r+0xc6e>
80008da4:	2f f7       	sub	r7,-1
80008da6:	10 39       	cp.w	r9,r8
80008da8:	c0 84       	brge	80008db8 <_vfprintf_r+0xc44>
80008daa:	fa ca f9 44 	sub	r10,sp,-1724
80008dae:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008db2:	ec fa fd 88 	ld.w	r10,r6[-632]
80008db6:	c1 68       	rjmp	80008de2 <_vfprintf_r+0xc6e>
80008db8:	41 09       	lddsp	r9,sp[0x40]
80008dba:	59 f8       	cp.w	r8,31
80008dbc:	e0 89 00 10 	brgt	80008ddc <_vfprintf_r+0xc68>
80008dc0:	f2 ca ff fc 	sub	r10,r9,-4
80008dc4:	51 0a       	stdsp	sp[0x40],r10
80008dc6:	fa c6 f9 44 	sub	r6,sp,-1724
80008dca:	72 0a       	ld.w	r10,r9[0x0]
80008dcc:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008dd0:	f3 4a fd 88 	st.w	r9[-632],r10
80008dd4:	2f f8       	sub	r8,-1
80008dd6:	fb 48 06 b4 	st.w	sp[1716],r8
80008dda:	c0 48       	rjmp	80008de2 <_vfprintf_r+0xc6e>
80008ddc:	72 0a       	ld.w	r10,r9[0x0]
80008dde:	2f c9       	sub	r9,-4
80008de0:	51 09       	stdsp	sp[0x40],r9
80008de2:	40 be       	lddsp	lr,sp[0x2c]
80008de4:	b4 0e       	st.h	r10[0x0],lr
80008de6:	fe 9f fa 55 	bral	80008290 <_vfprintf_r+0x11c>
80008dea:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008dee:	40 3c       	lddsp	r12,sp[0xc]
80008df0:	58 0c       	cp.w	r12,0
80008df2:	c1 d0       	breq	80008e2c <_vfprintf_r+0xcb8>
80008df4:	10 36       	cp.w	r6,r8
80008df6:	c0 64       	brge	80008e02 <_vfprintf_r+0xc8e>
80008df8:	fa cb f9 44 	sub	r11,sp,-1724
80008dfc:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008e00:	c1 d8       	rjmp	80008e3a <_vfprintf_r+0xcc6>
80008e02:	fa c8 f9 50 	sub	r8,sp,-1712
80008e06:	1a d8       	st.w	--sp,r8
80008e08:	fa c8 fa b8 	sub	r8,sp,-1352
80008e0c:	04 9a       	mov	r10,r2
80008e0e:	1a d8       	st.w	--sp,r8
80008e10:	fa c8 fb b4 	sub	r8,sp,-1100
80008e14:	0c 9b       	mov	r11,r6
80008e16:	1a d8       	st.w	--sp,r8
80008e18:	08 9c       	mov	r12,r4
80008e1a:	fa c8 f9 40 	sub	r8,sp,-1728
80008e1e:	fa c9 ff b4 	sub	r9,sp,-76
80008e22:	fe b0 f8 11 	rcall	80007e44 <get_arg>
80008e26:	2f dd       	sub	sp,-12
80008e28:	78 0a       	ld.w	r10,r12[0x0]
80008e2a:	c2 08       	rjmp	80008e6a <_vfprintf_r+0xcf6>
80008e2c:	2f f7       	sub	r7,-1
80008e2e:	10 39       	cp.w	r9,r8
80008e30:	c0 84       	brge	80008e40 <_vfprintf_r+0xccc>
80008e32:	fa ca f9 44 	sub	r10,sp,-1724
80008e36:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008e3a:	ec fa fd 88 	ld.w	r10,r6[-632]
80008e3e:	c1 68       	rjmp	80008e6a <_vfprintf_r+0xcf6>
80008e40:	41 09       	lddsp	r9,sp[0x40]
80008e42:	59 f8       	cp.w	r8,31
80008e44:	e0 89 00 10 	brgt	80008e64 <_vfprintf_r+0xcf0>
80008e48:	f2 ca ff fc 	sub	r10,r9,-4
80008e4c:	51 0a       	stdsp	sp[0x40],r10
80008e4e:	fa c6 f9 44 	sub	r6,sp,-1724
80008e52:	72 0a       	ld.w	r10,r9[0x0]
80008e54:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008e58:	f3 4a fd 88 	st.w	r9[-632],r10
80008e5c:	2f f8       	sub	r8,-1
80008e5e:	fb 48 06 b4 	st.w	sp[1716],r8
80008e62:	c0 48       	rjmp	80008e6a <_vfprintf_r+0xcf6>
80008e64:	72 0a       	ld.w	r10,r9[0x0]
80008e66:	2f c9       	sub	r9,-4
80008e68:	51 09       	stdsp	sp[0x40],r9
80008e6a:	40 be       	lddsp	lr,sp[0x2c]
80008e6c:	95 0e       	st.w	r10[0x0],lr
80008e6e:	fe 9f fa 11 	bral	80008290 <_vfprintf_r+0x11c>
80008e72:	50 a7       	stdsp	sp[0x28],r7
80008e74:	50 80       	stdsp	sp[0x20],r0
80008e76:	0c 97       	mov	r7,r6
80008e78:	04 94       	mov	r4,r2
80008e7a:	06 96       	mov	r6,r3
80008e7c:	02 92       	mov	r2,r1
80008e7e:	40 93       	lddsp	r3,sp[0x24]
80008e80:	10 90       	mov	r0,r8
80008e82:	40 41       	lddsp	r1,sp[0x10]
80008e84:	a5 a5       	sbr	r5,0x4
80008e86:	c0 a8       	rjmp	80008e9a <_vfprintf_r+0xd26>
80008e88:	50 a7       	stdsp	sp[0x28],r7
80008e8a:	50 80       	stdsp	sp[0x20],r0
80008e8c:	0c 97       	mov	r7,r6
80008e8e:	04 94       	mov	r4,r2
80008e90:	06 96       	mov	r6,r3
80008e92:	02 92       	mov	r2,r1
80008e94:	40 93       	lddsp	r3,sp[0x24]
80008e96:	10 90       	mov	r0,r8
80008e98:	40 41       	lddsp	r1,sp[0x10]
80008e9a:	ed b5 00 05 	bld	r5,0x5
80008e9e:	c5 d1       	brne	80008f58 <_vfprintf_r+0xde4>
80008ea0:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008ea4:	40 3c       	lddsp	r12,sp[0xc]
80008ea6:	58 0c       	cp.w	r12,0
80008ea8:	c2 60       	breq	80008ef4 <_vfprintf_r+0xd80>
80008eaa:	10 36       	cp.w	r6,r8
80008eac:	c0 a4       	brge	80008ec0 <_vfprintf_r+0xd4c>
80008eae:	fa cb f9 44 	sub	r11,sp,-1724
80008eb2:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008eb6:	ec e8 fd 88 	ld.d	r8,r6[-632]
80008eba:	fa e9 00 00 	st.d	sp[0],r8
80008ebe:	c1 88       	rjmp	80008eee <_vfprintf_r+0xd7a>
80008ec0:	fa c8 f9 50 	sub	r8,sp,-1712
80008ec4:	1a d8       	st.w	--sp,r8
80008ec6:	fa c8 fa b8 	sub	r8,sp,-1352
80008eca:	04 9a       	mov	r10,r2
80008ecc:	1a d8       	st.w	--sp,r8
80008ece:	0c 9b       	mov	r11,r6
80008ed0:	fa c8 fb b4 	sub	r8,sp,-1100
80008ed4:	08 9c       	mov	r12,r4
80008ed6:	1a d8       	st.w	--sp,r8
80008ed8:	fa c8 f9 40 	sub	r8,sp,-1728
80008edc:	fa c9 ff b4 	sub	r9,sp,-76
80008ee0:	fe b0 f7 b2 	rcall	80007e44 <get_arg>
80008ee4:	2f dd       	sub	sp,-12
80008ee6:	f8 ea 00 00 	ld.d	r10,r12[0]
80008eea:	fa eb 00 00 	st.d	sp[0],r10
80008eee:	30 08       	mov	r8,0
80008ef0:	e0 8f 03 de 	bral	800096ac <_vfprintf_r+0x1538>
80008ef4:	ee ca ff ff 	sub	r10,r7,-1
80008ef8:	10 37       	cp.w	r7,r8
80008efa:	c0 b4       	brge	80008f10 <_vfprintf_r+0xd9c>
80008efc:	fa c9 f9 44 	sub	r9,sp,-1724
80008f00:	14 97       	mov	r7,r10
80008f02:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008f06:	ec ea fd 88 	ld.d	r10,r6[-632]
80008f0a:	fa eb 00 00 	st.d	sp[0],r10
80008f0e:	c1 88       	rjmp	80008f3e <_vfprintf_r+0xdca>
80008f10:	41 09       	lddsp	r9,sp[0x40]
80008f12:	59 f8       	cp.w	r8,31
80008f14:	e0 89 00 18 	brgt	80008f44 <_vfprintf_r+0xdd0>
80008f18:	f2 e6 00 00 	ld.d	r6,r9[0]
80008f1c:	f2 cb ff f8 	sub	r11,r9,-8
80008f20:	fa e7 00 00 	st.d	sp[0],r6
80008f24:	51 0b       	stdsp	sp[0x40],r11
80008f26:	fa c6 f9 44 	sub	r6,sp,-1724
80008f2a:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008f2e:	fa e6 00 00 	ld.d	r6,sp[0]
80008f32:	f2 e7 fd 88 	st.d	r9[-632],r6
80008f36:	2f f8       	sub	r8,-1
80008f38:	14 97       	mov	r7,r10
80008f3a:	fb 48 06 b4 	st.w	sp[1716],r8
80008f3e:	40 38       	lddsp	r8,sp[0xc]
80008f40:	e0 8f 03 b6 	bral	800096ac <_vfprintf_r+0x1538>
80008f44:	f2 e6 00 00 	ld.d	r6,r9[0]
80008f48:	40 38       	lddsp	r8,sp[0xc]
80008f4a:	fa e7 00 00 	st.d	sp[0],r6
80008f4e:	2f 89       	sub	r9,-8
80008f50:	14 97       	mov	r7,r10
80008f52:	51 09       	stdsp	sp[0x40],r9
80008f54:	e0 8f 03 ac 	bral	800096ac <_vfprintf_r+0x1538>
80008f58:	ed b5 00 04 	bld	r5,0x4
80008f5c:	c1 61       	brne	80008f88 <_vfprintf_r+0xe14>
80008f5e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008f62:	40 3e       	lddsp	lr,sp[0xc]
80008f64:	58 0e       	cp.w	lr,0
80008f66:	c0 80       	breq	80008f76 <_vfprintf_r+0xe02>
80008f68:	10 36       	cp.w	r6,r8
80008f6a:	c6 74       	brge	80009038 <_vfprintf_r+0xec4>
80008f6c:	fa cc f9 44 	sub	r12,sp,-1724
80008f70:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008f74:	c8 08       	rjmp	80009074 <_vfprintf_r+0xf00>
80008f76:	ee ca ff ff 	sub	r10,r7,-1
80008f7a:	10 37       	cp.w	r7,r8
80008f7c:	c7 f4       	brge	8000907a <_vfprintf_r+0xf06>
80008f7e:	fa cb f9 44 	sub	r11,sp,-1724
80008f82:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008f86:	c7 68       	rjmp	80009072 <_vfprintf_r+0xefe>
80008f88:	ed b5 00 06 	bld	r5,0x6
80008f8c:	c4 a1       	brne	80009020 <_vfprintf_r+0xeac>
80008f8e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008f92:	40 3c       	lddsp	r12,sp[0xc]
80008f94:	58 0c       	cp.w	r12,0
80008f96:	c1 d0       	breq	80008fd0 <_vfprintf_r+0xe5c>
80008f98:	10 36       	cp.w	r6,r8
80008f9a:	c0 64       	brge	80008fa6 <_vfprintf_r+0xe32>
80008f9c:	fa cb f9 44 	sub	r11,sp,-1724
80008fa0:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008fa4:	c1 f8       	rjmp	80008fe2 <_vfprintf_r+0xe6e>
80008fa6:	fa c8 f9 50 	sub	r8,sp,-1712
80008faa:	1a d8       	st.w	--sp,r8
80008fac:	fa c8 fa b8 	sub	r8,sp,-1352
80008fb0:	1a d8       	st.w	--sp,r8
80008fb2:	fa c8 fb b4 	sub	r8,sp,-1100
80008fb6:	1a d8       	st.w	--sp,r8
80008fb8:	fa c8 f9 40 	sub	r8,sp,-1728
80008fbc:	fa c9 ff b4 	sub	r9,sp,-76
80008fc0:	04 9a       	mov	r10,r2
80008fc2:	0c 9b       	mov	r11,r6
80008fc4:	08 9c       	mov	r12,r4
80008fc6:	fe b0 f7 3f 	rcall	80007e44 <get_arg>
80008fca:	2f dd       	sub	sp,-12
80008fcc:	98 18       	ld.sh	r8,r12[0x2]
80008fce:	c2 68       	rjmp	8000901a <_vfprintf_r+0xea6>
80008fd0:	ee ca ff ff 	sub	r10,r7,-1
80008fd4:	10 37       	cp.w	r7,r8
80008fd6:	c0 94       	brge	80008fe8 <_vfprintf_r+0xe74>
80008fd8:	fa c9 f9 44 	sub	r9,sp,-1724
80008fdc:	14 97       	mov	r7,r10
80008fde:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008fe2:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80008fe6:	c1 a8       	rjmp	8000901a <_vfprintf_r+0xea6>
80008fe8:	41 09       	lddsp	r9,sp[0x40]
80008fea:	59 f8       	cp.w	r8,31
80008fec:	e0 89 00 13 	brgt	80009012 <_vfprintf_r+0xe9e>
80008ff0:	f2 cb ff fc 	sub	r11,r9,-4
80008ff4:	51 0b       	stdsp	sp[0x40],r11
80008ff6:	72 09       	ld.w	r9,r9[0x0]
80008ff8:	fa c6 f9 44 	sub	r6,sp,-1724
80008ffc:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80009000:	2f f8       	sub	r8,-1
80009002:	f7 49 fd 88 	st.w	r11[-632],r9
80009006:	fb 48 06 b4 	st.w	sp[1716],r8
8000900a:	14 97       	mov	r7,r10
8000900c:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80009010:	c0 58       	rjmp	8000901a <_vfprintf_r+0xea6>
80009012:	92 18       	ld.sh	r8,r9[0x2]
80009014:	14 97       	mov	r7,r10
80009016:	2f c9       	sub	r9,-4
80009018:	51 09       	stdsp	sp[0x40],r9
8000901a:	5c 78       	castu.h	r8
8000901c:	50 18       	stdsp	sp[0x4],r8
8000901e:	c4 68       	rjmp	800090aa <_vfprintf_r+0xf36>
80009020:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009024:	40 3c       	lddsp	r12,sp[0xc]
80009026:	58 0c       	cp.w	r12,0
80009028:	c1 d0       	breq	80009062 <_vfprintf_r+0xeee>
8000902a:	10 36       	cp.w	r6,r8
8000902c:	c0 64       	brge	80009038 <_vfprintf_r+0xec4>
8000902e:	fa cb f9 44 	sub	r11,sp,-1724
80009032:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009036:	c1 f8       	rjmp	80009074 <_vfprintf_r+0xf00>
80009038:	fa c8 f9 50 	sub	r8,sp,-1712
8000903c:	1a d8       	st.w	--sp,r8
8000903e:	fa c8 fa b8 	sub	r8,sp,-1352
80009042:	0c 9b       	mov	r11,r6
80009044:	1a d8       	st.w	--sp,r8
80009046:	fa c8 fb b4 	sub	r8,sp,-1100
8000904a:	04 9a       	mov	r10,r2
8000904c:	1a d8       	st.w	--sp,r8
8000904e:	08 9c       	mov	r12,r4
80009050:	fa c8 f9 40 	sub	r8,sp,-1728
80009054:	fa c9 ff b4 	sub	r9,sp,-76
80009058:	fe b0 f6 f6 	rcall	80007e44 <get_arg>
8000905c:	2f dd       	sub	sp,-12
8000905e:	78 0b       	ld.w	r11,r12[0x0]
80009060:	c2 48       	rjmp	800090a8 <_vfprintf_r+0xf34>
80009062:	ee ca ff ff 	sub	r10,r7,-1
80009066:	10 37       	cp.w	r7,r8
80009068:	c0 94       	brge	8000907a <_vfprintf_r+0xf06>
8000906a:	fa c9 f9 44 	sub	r9,sp,-1724
8000906e:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009072:	14 97       	mov	r7,r10
80009074:	ec fb fd 88 	ld.w	r11,r6[-632]
80009078:	c1 88       	rjmp	800090a8 <_vfprintf_r+0xf34>
8000907a:	41 09       	lddsp	r9,sp[0x40]
8000907c:	59 f8       	cp.w	r8,31
8000907e:	e0 89 00 11 	brgt	800090a0 <_vfprintf_r+0xf2c>
80009082:	f2 cb ff fc 	sub	r11,r9,-4
80009086:	51 0b       	stdsp	sp[0x40],r11
80009088:	fa c6 f9 44 	sub	r6,sp,-1724
8000908c:	72 0b       	ld.w	r11,r9[0x0]
8000908e:	ec 08 00 39 	add	r9,r6,r8<<0x3
80009092:	f3 4b fd 88 	st.w	r9[-632],r11
80009096:	2f f8       	sub	r8,-1
80009098:	14 97       	mov	r7,r10
8000909a:	fb 48 06 b4 	st.w	sp[1716],r8
8000909e:	c0 58       	rjmp	800090a8 <_vfprintf_r+0xf34>
800090a0:	72 0b       	ld.w	r11,r9[0x0]
800090a2:	14 97       	mov	r7,r10
800090a4:	2f c9       	sub	r9,-4
800090a6:	51 09       	stdsp	sp[0x40],r9
800090a8:	50 1b       	stdsp	sp[0x4],r11
800090aa:	30 0e       	mov	lr,0
800090ac:	50 0e       	stdsp	sp[0x0],lr
800090ae:	1c 98       	mov	r8,lr
800090b0:	e0 8f 02 fe 	bral	800096ac <_vfprintf_r+0x1538>
800090b4:	50 a7       	stdsp	sp[0x28],r7
800090b6:	50 80       	stdsp	sp[0x20],r0
800090b8:	0c 97       	mov	r7,r6
800090ba:	04 94       	mov	r4,r2
800090bc:	06 96       	mov	r6,r3
800090be:	02 92       	mov	r2,r1
800090c0:	40 93       	lddsp	r3,sp[0x24]
800090c2:	40 41       	lddsp	r1,sp[0x10]
800090c4:	0e 99       	mov	r9,r7
800090c6:	fa f8 06 b4 	ld.w	r8,sp[1716]
800090ca:	40 3c       	lddsp	r12,sp[0xc]
800090cc:	58 0c       	cp.w	r12,0
800090ce:	c1 d0       	breq	80009108 <_vfprintf_r+0xf94>
800090d0:	10 36       	cp.w	r6,r8
800090d2:	c0 64       	brge	800090de <_vfprintf_r+0xf6a>
800090d4:	fa cb f9 44 	sub	r11,sp,-1724
800090d8:	f6 06 00 36 	add	r6,r11,r6<<0x3
800090dc:	c1 d8       	rjmp	80009116 <_vfprintf_r+0xfa2>
800090de:	fa c8 f9 50 	sub	r8,sp,-1712
800090e2:	1a d8       	st.w	--sp,r8
800090e4:	fa c8 fa b8 	sub	r8,sp,-1352
800090e8:	1a d8       	st.w	--sp,r8
800090ea:	fa c8 fb b4 	sub	r8,sp,-1100
800090ee:	1a d8       	st.w	--sp,r8
800090f0:	fa c9 ff b4 	sub	r9,sp,-76
800090f4:	fa c8 f9 40 	sub	r8,sp,-1728
800090f8:	04 9a       	mov	r10,r2
800090fa:	0c 9b       	mov	r11,r6
800090fc:	08 9c       	mov	r12,r4
800090fe:	fe b0 f6 a3 	rcall	80007e44 <get_arg>
80009102:	2f dd       	sub	sp,-12
80009104:	78 09       	ld.w	r9,r12[0x0]
80009106:	c2 18       	rjmp	80009148 <_vfprintf_r+0xfd4>
80009108:	2f f7       	sub	r7,-1
8000910a:	10 39       	cp.w	r9,r8
8000910c:	c0 84       	brge	8000911c <_vfprintf_r+0xfa8>
8000910e:	fa ca f9 44 	sub	r10,sp,-1724
80009112:	f4 06 00 36 	add	r6,r10,r6<<0x3
80009116:	ec f9 fd 88 	ld.w	r9,r6[-632]
8000911a:	c1 78       	rjmp	80009148 <_vfprintf_r+0xfd4>
8000911c:	41 09       	lddsp	r9,sp[0x40]
8000911e:	59 f8       	cp.w	r8,31
80009120:	e0 89 00 10 	brgt	80009140 <_vfprintf_r+0xfcc>
80009124:	f2 ca ff fc 	sub	r10,r9,-4
80009128:	51 0a       	stdsp	sp[0x40],r10
8000912a:	fa c6 f9 44 	sub	r6,sp,-1724
8000912e:	72 09       	ld.w	r9,r9[0x0]
80009130:	ec 08 00 3a 	add	r10,r6,r8<<0x3
80009134:	f5 49 fd 88 	st.w	r10[-632],r9
80009138:	2f f8       	sub	r8,-1
8000913a:	fb 48 06 b4 	st.w	sp[1716],r8
8000913e:	c0 58       	rjmp	80009148 <_vfprintf_r+0xfd4>
80009140:	f2 c8 ff fc 	sub	r8,r9,-4
80009144:	51 08       	stdsp	sp[0x40],r8
80009146:	72 09       	ld.w	r9,r9[0x0]
80009148:	33 08       	mov	r8,48
8000914a:	fb 68 06 b8 	st.b	sp[1720],r8
8000914e:	37 88       	mov	r8,120
80009150:	30 0e       	mov	lr,0
80009152:	fb 68 06 b9 	st.b	sp[1721],r8
80009156:	fe cc b1 56 	sub	r12,pc,-20138
8000915a:	50 19       	stdsp	sp[0x4],r9
8000915c:	a1 b5       	sbr	r5,0x1
8000915e:	50 0e       	stdsp	sp[0x0],lr
80009160:	50 dc       	stdsp	sp[0x34],r12
80009162:	30 28       	mov	r8,2
80009164:	37 80       	mov	r0,120
80009166:	e0 8f 02 a3 	bral	800096ac <_vfprintf_r+0x1538>
8000916a:	50 a7       	stdsp	sp[0x28],r7
8000916c:	50 80       	stdsp	sp[0x20],r0
8000916e:	10 90       	mov	r0,r8
80009170:	30 08       	mov	r8,0
80009172:	fb 68 06 bb 	st.b	sp[1723],r8
80009176:	0c 97       	mov	r7,r6
80009178:	04 94       	mov	r4,r2
8000917a:	06 96       	mov	r6,r3
8000917c:	02 92       	mov	r2,r1
8000917e:	40 93       	lddsp	r3,sp[0x24]
80009180:	40 41       	lddsp	r1,sp[0x10]
80009182:	0e 99       	mov	r9,r7
80009184:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009188:	40 3b       	lddsp	r11,sp[0xc]
8000918a:	58 0b       	cp.w	r11,0
8000918c:	c1 d0       	breq	800091c6 <_vfprintf_r+0x1052>
8000918e:	10 36       	cp.w	r6,r8
80009190:	c0 64       	brge	8000919c <_vfprintf_r+0x1028>
80009192:	fa ca f9 44 	sub	r10,sp,-1724
80009196:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000919a:	c1 d8       	rjmp	800091d4 <_vfprintf_r+0x1060>
8000919c:	fa c8 f9 50 	sub	r8,sp,-1712
800091a0:	1a d8       	st.w	--sp,r8
800091a2:	fa c8 fa b8 	sub	r8,sp,-1352
800091a6:	1a d8       	st.w	--sp,r8
800091a8:	fa c8 fb b4 	sub	r8,sp,-1100
800091ac:	0c 9b       	mov	r11,r6
800091ae:	1a d8       	st.w	--sp,r8
800091b0:	04 9a       	mov	r10,r2
800091b2:	fa c8 f9 40 	sub	r8,sp,-1728
800091b6:	fa c9 ff b4 	sub	r9,sp,-76
800091ba:	08 9c       	mov	r12,r4
800091bc:	fe b0 f6 44 	rcall	80007e44 <get_arg>
800091c0:	2f dd       	sub	sp,-12
800091c2:	78 06       	ld.w	r6,r12[0x0]
800091c4:	c2 08       	rjmp	80009204 <_vfprintf_r+0x1090>
800091c6:	2f f7       	sub	r7,-1
800091c8:	10 39       	cp.w	r9,r8
800091ca:	c0 84       	brge	800091da <_vfprintf_r+0x1066>
800091cc:	fa c9 f9 44 	sub	r9,sp,-1724
800091d0:	f2 06 00 36 	add	r6,r9,r6<<0x3
800091d4:	ec f6 fd 88 	ld.w	r6,r6[-632]
800091d8:	c1 68       	rjmp	80009204 <_vfprintf_r+0x1090>
800091da:	41 09       	lddsp	r9,sp[0x40]
800091dc:	59 f8       	cp.w	r8,31
800091de:	e0 89 00 10 	brgt	800091fe <_vfprintf_r+0x108a>
800091e2:	f2 ca ff fc 	sub	r10,r9,-4
800091e6:	51 0a       	stdsp	sp[0x40],r10
800091e8:	72 06       	ld.w	r6,r9[0x0]
800091ea:	fa ce f9 44 	sub	lr,sp,-1724
800091ee:	fc 08 00 39 	add	r9,lr,r8<<0x3
800091f2:	f3 46 fd 88 	st.w	r9[-632],r6
800091f6:	2f f8       	sub	r8,-1
800091f8:	fb 48 06 b4 	st.w	sp[1716],r8
800091fc:	c0 48       	rjmp	80009204 <_vfprintf_r+0x1090>
800091fe:	72 06       	ld.w	r6,r9[0x0]
80009200:	2f c9       	sub	r9,-4
80009202:	51 09       	stdsp	sp[0x40],r9
80009204:	40 2c       	lddsp	r12,sp[0x8]
80009206:	58 0c       	cp.w	r12,0
80009208:	c1 05       	brlt	80009228 <_vfprintf_r+0x10b4>
8000920a:	18 9a       	mov	r10,r12
8000920c:	30 0b       	mov	r11,0
8000920e:	0c 9c       	mov	r12,r6
80009210:	e0 a0 12 38 	rcall	8000b680 <memchr>
80009214:	e0 80 02 df 	breq	800097d2 <_vfprintf_r+0x165e>
80009218:	f8 06 01 02 	sub	r2,r12,r6
8000921c:	40 2b       	lddsp	r11,sp[0x8]
8000921e:	16 32       	cp.w	r2,r11
80009220:	e0 89 02 d9 	brgt	800097d2 <_vfprintf_r+0x165e>
80009224:	e0 8f 02 d4 	bral	800097cc <_vfprintf_r+0x1658>
80009228:	30 0a       	mov	r10,0
8000922a:	0c 9c       	mov	r12,r6
8000922c:	50 2a       	stdsp	sp[0x8],r10
8000922e:	e0 a0 15 99 	rcall	8000bd60 <strlen>
80009232:	18 92       	mov	r2,r12
80009234:	e0 8f 02 d2 	bral	800097d8 <_vfprintf_r+0x1664>
80009238:	50 a7       	stdsp	sp[0x28],r7
8000923a:	50 80       	stdsp	sp[0x20],r0
8000923c:	0c 97       	mov	r7,r6
8000923e:	04 94       	mov	r4,r2
80009240:	06 96       	mov	r6,r3
80009242:	02 92       	mov	r2,r1
80009244:	40 93       	lddsp	r3,sp[0x24]
80009246:	10 90       	mov	r0,r8
80009248:	40 41       	lddsp	r1,sp[0x10]
8000924a:	a5 a5       	sbr	r5,0x4
8000924c:	c0 a8       	rjmp	80009260 <_vfprintf_r+0x10ec>
8000924e:	50 a7       	stdsp	sp[0x28],r7
80009250:	50 80       	stdsp	sp[0x20],r0
80009252:	0c 97       	mov	r7,r6
80009254:	04 94       	mov	r4,r2
80009256:	06 96       	mov	r6,r3
80009258:	02 92       	mov	r2,r1
8000925a:	40 93       	lddsp	r3,sp[0x24]
8000925c:	10 90       	mov	r0,r8
8000925e:	40 41       	lddsp	r1,sp[0x10]
80009260:	ed b5 00 05 	bld	r5,0x5
80009264:	c5 61       	brne	80009310 <_vfprintf_r+0x119c>
80009266:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000926a:	40 39       	lddsp	r9,sp[0xc]
8000926c:	58 09       	cp.w	r9,0
8000926e:	c2 10       	breq	800092b0 <_vfprintf_r+0x113c>
80009270:	10 36       	cp.w	r6,r8
80009272:	c0 74       	brge	80009280 <_vfprintf_r+0x110c>
80009274:	fa c8 f9 44 	sub	r8,sp,-1724
80009278:	f0 06 00 36 	add	r6,r8,r6<<0x3
8000927c:	c2 38       	rjmp	800092c2 <_vfprintf_r+0x114e>
8000927e:	d7 03       	nop
80009280:	fa c8 f9 50 	sub	r8,sp,-1712
80009284:	1a d8       	st.w	--sp,r8
80009286:	fa c8 fa b8 	sub	r8,sp,-1352
8000928a:	1a d8       	st.w	--sp,r8
8000928c:	fa c8 fb b4 	sub	r8,sp,-1100
80009290:	1a d8       	st.w	--sp,r8
80009292:	fa c8 f9 40 	sub	r8,sp,-1728
80009296:	fa c9 ff b4 	sub	r9,sp,-76
8000929a:	04 9a       	mov	r10,r2
8000929c:	0c 9b       	mov	r11,r6
8000929e:	08 9c       	mov	r12,r4
800092a0:	fe b0 f5 d2 	rcall	80007e44 <get_arg>
800092a4:	2f dd       	sub	sp,-12
800092a6:	f8 e8 00 00 	ld.d	r8,r12[0]
800092aa:	fa e9 00 00 	st.d	sp[0],r8
800092ae:	c2 e8       	rjmp	8000930a <_vfprintf_r+0x1196>
800092b0:	ee ca ff ff 	sub	r10,r7,-1
800092b4:	10 37       	cp.w	r7,r8
800092b6:	c0 b4       	brge	800092cc <_vfprintf_r+0x1158>
800092b8:	fa c8 f9 44 	sub	r8,sp,-1724
800092bc:	14 97       	mov	r7,r10
800092be:	f0 06 00 36 	add	r6,r8,r6<<0x3
800092c2:	ec ea fd 88 	ld.d	r10,r6[-632]
800092c6:	fa eb 00 00 	st.d	sp[0],r10
800092ca:	c2 08       	rjmp	8000930a <_vfprintf_r+0x1196>
800092cc:	41 09       	lddsp	r9,sp[0x40]
800092ce:	59 f8       	cp.w	r8,31
800092d0:	e0 89 00 16 	brgt	800092fc <_vfprintf_r+0x1188>
800092d4:	f2 e6 00 00 	ld.d	r6,r9[0]
800092d8:	f2 cb ff f8 	sub	r11,r9,-8
800092dc:	fa e7 00 00 	st.d	sp[0],r6
800092e0:	51 0b       	stdsp	sp[0x40],r11
800092e2:	fa c6 f9 44 	sub	r6,sp,-1724
800092e6:	ec 08 00 39 	add	r9,r6,r8<<0x3
800092ea:	fa e6 00 00 	ld.d	r6,sp[0]
800092ee:	f2 e7 fd 88 	st.d	r9[-632],r6
800092f2:	2f f8       	sub	r8,-1
800092f4:	14 97       	mov	r7,r10
800092f6:	fb 48 06 b4 	st.w	sp[1716],r8
800092fa:	c0 88       	rjmp	8000930a <_vfprintf_r+0x1196>
800092fc:	f2 e6 00 00 	ld.d	r6,r9[0]
80009300:	2f 89       	sub	r9,-8
80009302:	fa e7 00 00 	st.d	sp[0],r6
80009306:	51 09       	stdsp	sp[0x40],r9
80009308:	14 97       	mov	r7,r10
8000930a:	30 18       	mov	r8,1
8000930c:	e0 8f 01 d0 	bral	800096ac <_vfprintf_r+0x1538>
80009310:	ed b5 00 04 	bld	r5,0x4
80009314:	c1 61       	brne	80009340 <_vfprintf_r+0x11cc>
80009316:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000931a:	40 3e       	lddsp	lr,sp[0xc]
8000931c:	58 0e       	cp.w	lr,0
8000931e:	c0 80       	breq	8000932e <_vfprintf_r+0x11ba>
80009320:	10 36       	cp.w	r6,r8
80009322:	c6 74       	brge	800093f0 <_vfprintf_r+0x127c>
80009324:	fa cc f9 44 	sub	r12,sp,-1724
80009328:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000932c:	c8 08       	rjmp	8000942c <_vfprintf_r+0x12b8>
8000932e:	ee ca ff ff 	sub	r10,r7,-1
80009332:	10 37       	cp.w	r7,r8
80009334:	c7 f4       	brge	80009432 <_vfprintf_r+0x12be>
80009336:	fa cb f9 44 	sub	r11,sp,-1724
8000933a:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000933e:	c7 68       	rjmp	8000942a <_vfprintf_r+0x12b6>
80009340:	ed b5 00 06 	bld	r5,0x6
80009344:	c4 a1       	brne	800093d8 <_vfprintf_r+0x1264>
80009346:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000934a:	40 3c       	lddsp	r12,sp[0xc]
8000934c:	58 0c       	cp.w	r12,0
8000934e:	c1 d0       	breq	80009388 <_vfprintf_r+0x1214>
80009350:	10 36       	cp.w	r6,r8
80009352:	c0 64       	brge	8000935e <_vfprintf_r+0x11ea>
80009354:	fa cb f9 44 	sub	r11,sp,-1724
80009358:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000935c:	c1 f8       	rjmp	8000939a <_vfprintf_r+0x1226>
8000935e:	fa c8 f9 50 	sub	r8,sp,-1712
80009362:	1a d8       	st.w	--sp,r8
80009364:	fa c8 fa b8 	sub	r8,sp,-1352
80009368:	1a d8       	st.w	--sp,r8
8000936a:	fa c8 fb b4 	sub	r8,sp,-1100
8000936e:	1a d8       	st.w	--sp,r8
80009370:	fa c8 f9 40 	sub	r8,sp,-1728
80009374:	fa c9 ff b4 	sub	r9,sp,-76
80009378:	04 9a       	mov	r10,r2
8000937a:	0c 9b       	mov	r11,r6
8000937c:	08 9c       	mov	r12,r4
8000937e:	fe b0 f5 63 	rcall	80007e44 <get_arg>
80009382:	2f dd       	sub	sp,-12
80009384:	98 18       	ld.sh	r8,r12[0x2]
80009386:	c2 68       	rjmp	800093d2 <_vfprintf_r+0x125e>
80009388:	ee ca ff ff 	sub	r10,r7,-1
8000938c:	10 37       	cp.w	r7,r8
8000938e:	c0 94       	brge	800093a0 <_vfprintf_r+0x122c>
80009390:	fa c9 f9 44 	sub	r9,sp,-1724
80009394:	14 97       	mov	r7,r10
80009396:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000939a:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000939e:	c1 a8       	rjmp	800093d2 <_vfprintf_r+0x125e>
800093a0:	41 09       	lddsp	r9,sp[0x40]
800093a2:	59 f8       	cp.w	r8,31
800093a4:	e0 89 00 13 	brgt	800093ca <_vfprintf_r+0x1256>
800093a8:	f2 cb ff fc 	sub	r11,r9,-4
800093ac:	51 0b       	stdsp	sp[0x40],r11
800093ae:	72 09       	ld.w	r9,r9[0x0]
800093b0:	fa c6 f9 44 	sub	r6,sp,-1724
800093b4:	ec 08 00 3b 	add	r11,r6,r8<<0x3
800093b8:	2f f8       	sub	r8,-1
800093ba:	f7 49 fd 88 	st.w	r11[-632],r9
800093be:	fb 48 06 b4 	st.w	sp[1716],r8
800093c2:	14 97       	mov	r7,r10
800093c4:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
800093c8:	c0 58       	rjmp	800093d2 <_vfprintf_r+0x125e>
800093ca:	92 18       	ld.sh	r8,r9[0x2]
800093cc:	14 97       	mov	r7,r10
800093ce:	2f c9       	sub	r9,-4
800093d0:	51 09       	stdsp	sp[0x40],r9
800093d2:	5c 78       	castu.h	r8
800093d4:	50 18       	stdsp	sp[0x4],r8
800093d6:	c4 68       	rjmp	80009462 <_vfprintf_r+0x12ee>
800093d8:	fa f8 06 b4 	ld.w	r8,sp[1716]
800093dc:	40 3c       	lddsp	r12,sp[0xc]
800093de:	58 0c       	cp.w	r12,0
800093e0:	c1 d0       	breq	8000941a <_vfprintf_r+0x12a6>
800093e2:	10 36       	cp.w	r6,r8
800093e4:	c0 64       	brge	800093f0 <_vfprintf_r+0x127c>
800093e6:	fa cb f9 44 	sub	r11,sp,-1724
800093ea:	f6 06 00 36 	add	r6,r11,r6<<0x3
800093ee:	c1 f8       	rjmp	8000942c <_vfprintf_r+0x12b8>
800093f0:	fa c8 f9 50 	sub	r8,sp,-1712
800093f4:	1a d8       	st.w	--sp,r8
800093f6:	fa c8 fa b8 	sub	r8,sp,-1352
800093fa:	0c 9b       	mov	r11,r6
800093fc:	1a d8       	st.w	--sp,r8
800093fe:	fa c8 fb b4 	sub	r8,sp,-1100
80009402:	04 9a       	mov	r10,r2
80009404:	1a d8       	st.w	--sp,r8
80009406:	08 9c       	mov	r12,r4
80009408:	fa c8 f9 40 	sub	r8,sp,-1728
8000940c:	fa c9 ff b4 	sub	r9,sp,-76
80009410:	fe b0 f5 1a 	rcall	80007e44 <get_arg>
80009414:	2f dd       	sub	sp,-12
80009416:	78 0b       	ld.w	r11,r12[0x0]
80009418:	c2 48       	rjmp	80009460 <_vfprintf_r+0x12ec>
8000941a:	ee ca ff ff 	sub	r10,r7,-1
8000941e:	10 37       	cp.w	r7,r8
80009420:	c0 94       	brge	80009432 <_vfprintf_r+0x12be>
80009422:	fa c9 f9 44 	sub	r9,sp,-1724
80009426:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000942a:	14 97       	mov	r7,r10
8000942c:	ec fb fd 88 	ld.w	r11,r6[-632]
80009430:	c1 88       	rjmp	80009460 <_vfprintf_r+0x12ec>
80009432:	41 09       	lddsp	r9,sp[0x40]
80009434:	59 f8       	cp.w	r8,31
80009436:	e0 89 00 11 	brgt	80009458 <_vfprintf_r+0x12e4>
8000943a:	f2 cb ff fc 	sub	r11,r9,-4
8000943e:	51 0b       	stdsp	sp[0x40],r11
80009440:	fa c6 f9 44 	sub	r6,sp,-1724
80009444:	72 0b       	ld.w	r11,r9[0x0]
80009446:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000944a:	f3 4b fd 88 	st.w	r9[-632],r11
8000944e:	2f f8       	sub	r8,-1
80009450:	14 97       	mov	r7,r10
80009452:	fb 48 06 b4 	st.w	sp[1716],r8
80009456:	c0 58       	rjmp	80009460 <_vfprintf_r+0x12ec>
80009458:	72 0b       	ld.w	r11,r9[0x0]
8000945a:	14 97       	mov	r7,r10
8000945c:	2f c9       	sub	r9,-4
8000945e:	51 09       	stdsp	sp[0x40],r9
80009460:	50 1b       	stdsp	sp[0x4],r11
80009462:	30 0e       	mov	lr,0
80009464:	30 18       	mov	r8,1
80009466:	50 0e       	stdsp	sp[0x0],lr
80009468:	c2 29       	rjmp	800096ac <_vfprintf_r+0x1538>
8000946a:	50 a7       	stdsp	sp[0x28],r7
8000946c:	50 80       	stdsp	sp[0x20],r0
8000946e:	0c 97       	mov	r7,r6
80009470:	04 94       	mov	r4,r2
80009472:	06 96       	mov	r6,r3
80009474:	02 92       	mov	r2,r1
80009476:	fe cc b4 76 	sub	r12,pc,-19338
8000947a:	40 93       	lddsp	r3,sp[0x24]
8000947c:	10 90       	mov	r0,r8
8000947e:	40 41       	lddsp	r1,sp[0x10]
80009480:	50 dc       	stdsp	sp[0x34],r12
80009482:	ed b5 00 05 	bld	r5,0x5
80009486:	c5 51       	brne	80009530 <_vfprintf_r+0x13bc>
80009488:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000948c:	40 3b       	lddsp	r11,sp[0xc]
8000948e:	58 0b       	cp.w	r11,0
80009490:	c2 20       	breq	800094d4 <_vfprintf_r+0x1360>
80009492:	10 36       	cp.w	r6,r8
80009494:	c0 a4       	brge	800094a8 <_vfprintf_r+0x1334>
80009496:	fa ca f9 44 	sub	r10,sp,-1724
8000949a:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000949e:	ec e8 fd 88 	ld.d	r8,r6[-632]
800094a2:	fa e9 00 00 	st.d	sp[0],r8
800094a6:	cf 28       	rjmp	8000968a <_vfprintf_r+0x1516>
800094a8:	fa c8 f9 50 	sub	r8,sp,-1712
800094ac:	1a d8       	st.w	--sp,r8
800094ae:	fa c8 fa b8 	sub	r8,sp,-1352
800094b2:	04 9a       	mov	r10,r2
800094b4:	1a d8       	st.w	--sp,r8
800094b6:	0c 9b       	mov	r11,r6
800094b8:	fa c8 fb b4 	sub	r8,sp,-1100
800094bc:	08 9c       	mov	r12,r4
800094be:	1a d8       	st.w	--sp,r8
800094c0:	fa c8 f9 40 	sub	r8,sp,-1728
800094c4:	fa c9 ff b4 	sub	r9,sp,-76
800094c8:	fe b0 f4 be 	rcall	80007e44 <get_arg>
800094cc:	2f dd       	sub	sp,-12
800094ce:	f8 ea 00 00 	ld.d	r10,r12[0]
800094d2:	c0 c8       	rjmp	800094ea <_vfprintf_r+0x1376>
800094d4:	ee ca ff ff 	sub	r10,r7,-1
800094d8:	10 37       	cp.w	r7,r8
800094da:	c0 b4       	brge	800094f0 <_vfprintf_r+0x137c>
800094dc:	fa c9 f9 44 	sub	r9,sp,-1724
800094e0:	14 97       	mov	r7,r10
800094e2:	f2 06 00 36 	add	r6,r9,r6<<0x3
800094e6:	ec ea fd 88 	ld.d	r10,r6[-632]
800094ea:	fa eb 00 00 	st.d	sp[0],r10
800094ee:	cc e8       	rjmp	8000968a <_vfprintf_r+0x1516>
800094f0:	41 09       	lddsp	r9,sp[0x40]
800094f2:	59 f8       	cp.w	r8,31
800094f4:	e0 89 00 16 	brgt	80009520 <_vfprintf_r+0x13ac>
800094f8:	f2 e6 00 00 	ld.d	r6,r9[0]
800094fc:	f2 cb ff f8 	sub	r11,r9,-8
80009500:	fa e7 00 00 	st.d	sp[0],r6
80009504:	51 0b       	stdsp	sp[0x40],r11
80009506:	fa c6 f9 44 	sub	r6,sp,-1724
8000950a:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000950e:	fa e6 00 00 	ld.d	r6,sp[0]
80009512:	f2 e7 fd 88 	st.d	r9[-632],r6
80009516:	2f f8       	sub	r8,-1
80009518:	14 97       	mov	r7,r10
8000951a:	fb 48 06 b4 	st.w	sp[1716],r8
8000951e:	cb 68       	rjmp	8000968a <_vfprintf_r+0x1516>
80009520:	f2 e6 00 00 	ld.d	r6,r9[0]
80009524:	2f 89       	sub	r9,-8
80009526:	fa e7 00 00 	st.d	sp[0],r6
8000952a:	51 09       	stdsp	sp[0x40],r9
8000952c:	14 97       	mov	r7,r10
8000952e:	ca e8       	rjmp	8000968a <_vfprintf_r+0x1516>
80009530:	ed b5 00 04 	bld	r5,0x4
80009534:	c1 71       	brne	80009562 <_vfprintf_r+0x13ee>
80009536:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000953a:	40 3e       	lddsp	lr,sp[0xc]
8000953c:	58 0e       	cp.w	lr,0
8000953e:	c0 80       	breq	8000954e <_vfprintf_r+0x13da>
80009540:	10 36       	cp.w	r6,r8
80009542:	c6 94       	brge	80009614 <_vfprintf_r+0x14a0>
80009544:	fa cc f9 44 	sub	r12,sp,-1724
80009548:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000954c:	c8 28       	rjmp	80009650 <_vfprintf_r+0x14dc>
8000954e:	ee ca ff ff 	sub	r10,r7,-1
80009552:	10 37       	cp.w	r7,r8
80009554:	e0 84 00 81 	brge	80009656 <_vfprintf_r+0x14e2>
80009558:	fa cb f9 44 	sub	r11,sp,-1724
8000955c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009560:	c7 78       	rjmp	8000964e <_vfprintf_r+0x14da>
80009562:	ed b5 00 06 	bld	r5,0x6
80009566:	c4 b1       	brne	800095fc <_vfprintf_r+0x1488>
80009568:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000956c:	40 3c       	lddsp	r12,sp[0xc]
8000956e:	58 0c       	cp.w	r12,0
80009570:	c1 d0       	breq	800095aa <_vfprintf_r+0x1436>
80009572:	10 36       	cp.w	r6,r8
80009574:	c0 64       	brge	80009580 <_vfprintf_r+0x140c>
80009576:	fa cb f9 44 	sub	r11,sp,-1724
8000957a:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000957e:	c1 f8       	rjmp	800095bc <_vfprintf_r+0x1448>
80009580:	fa c8 f9 50 	sub	r8,sp,-1712
80009584:	1a d8       	st.w	--sp,r8
80009586:	fa c8 fa b8 	sub	r8,sp,-1352
8000958a:	1a d8       	st.w	--sp,r8
8000958c:	fa c8 fb b4 	sub	r8,sp,-1100
80009590:	1a d8       	st.w	--sp,r8
80009592:	fa c8 f9 40 	sub	r8,sp,-1728
80009596:	fa c9 ff b4 	sub	r9,sp,-76
8000959a:	04 9a       	mov	r10,r2
8000959c:	0c 9b       	mov	r11,r6
8000959e:	08 9c       	mov	r12,r4
800095a0:	fe b0 f4 52 	rcall	80007e44 <get_arg>
800095a4:	2f dd       	sub	sp,-12
800095a6:	98 18       	ld.sh	r8,r12[0x2]
800095a8:	c2 78       	rjmp	800095f6 <_vfprintf_r+0x1482>
800095aa:	ee ca ff ff 	sub	r10,r7,-1
800095ae:	10 37       	cp.w	r7,r8
800095b0:	c0 a4       	brge	800095c4 <_vfprintf_r+0x1450>
800095b2:	fa c9 f9 44 	sub	r9,sp,-1724
800095b6:	14 97       	mov	r7,r10
800095b8:	f2 06 00 36 	add	r6,r9,r6<<0x3
800095bc:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
800095c0:	c1 b8       	rjmp	800095f6 <_vfprintf_r+0x1482>
800095c2:	d7 03       	nop
800095c4:	41 09       	lddsp	r9,sp[0x40]
800095c6:	59 f8       	cp.w	r8,31
800095c8:	e0 89 00 13 	brgt	800095ee <_vfprintf_r+0x147a>
800095cc:	f2 cb ff fc 	sub	r11,r9,-4
800095d0:	51 0b       	stdsp	sp[0x40],r11
800095d2:	72 09       	ld.w	r9,r9[0x0]
800095d4:	fa c6 f9 44 	sub	r6,sp,-1724
800095d8:	ec 08 00 3b 	add	r11,r6,r8<<0x3
800095dc:	2f f8       	sub	r8,-1
800095de:	f7 49 fd 88 	st.w	r11[-632],r9
800095e2:	fb 48 06 b4 	st.w	sp[1716],r8
800095e6:	14 97       	mov	r7,r10
800095e8:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
800095ec:	c0 58       	rjmp	800095f6 <_vfprintf_r+0x1482>
800095ee:	92 18       	ld.sh	r8,r9[0x2]
800095f0:	14 97       	mov	r7,r10
800095f2:	2f c9       	sub	r9,-4
800095f4:	51 09       	stdsp	sp[0x40],r9
800095f6:	5c 78       	castu.h	r8
800095f8:	50 18       	stdsp	sp[0x4],r8
800095fa:	c4 68       	rjmp	80009686 <_vfprintf_r+0x1512>
800095fc:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009600:	40 3c       	lddsp	r12,sp[0xc]
80009602:	58 0c       	cp.w	r12,0
80009604:	c1 d0       	breq	8000963e <_vfprintf_r+0x14ca>
80009606:	10 36       	cp.w	r6,r8
80009608:	c0 64       	brge	80009614 <_vfprintf_r+0x14a0>
8000960a:	fa cb f9 44 	sub	r11,sp,-1724
8000960e:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009612:	c1 f8       	rjmp	80009650 <_vfprintf_r+0x14dc>
80009614:	fa c8 f9 50 	sub	r8,sp,-1712
80009618:	1a d8       	st.w	--sp,r8
8000961a:	fa c8 fa b8 	sub	r8,sp,-1352
8000961e:	0c 9b       	mov	r11,r6
80009620:	1a d8       	st.w	--sp,r8
80009622:	fa c8 fb b4 	sub	r8,sp,-1100
80009626:	04 9a       	mov	r10,r2
80009628:	1a d8       	st.w	--sp,r8
8000962a:	08 9c       	mov	r12,r4
8000962c:	fa c8 f9 40 	sub	r8,sp,-1728
80009630:	fa c9 ff b4 	sub	r9,sp,-76
80009634:	fe b0 f4 08 	rcall	80007e44 <get_arg>
80009638:	2f dd       	sub	sp,-12
8000963a:	78 0b       	ld.w	r11,r12[0x0]
8000963c:	c2 48       	rjmp	80009684 <_vfprintf_r+0x1510>
8000963e:	ee ca ff ff 	sub	r10,r7,-1
80009642:	10 37       	cp.w	r7,r8
80009644:	c0 94       	brge	80009656 <_vfprintf_r+0x14e2>
80009646:	fa c9 f9 44 	sub	r9,sp,-1724
8000964a:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000964e:	14 97       	mov	r7,r10
80009650:	ec fb fd 88 	ld.w	r11,r6[-632]
80009654:	c1 88       	rjmp	80009684 <_vfprintf_r+0x1510>
80009656:	41 09       	lddsp	r9,sp[0x40]
80009658:	59 f8       	cp.w	r8,31
8000965a:	e0 89 00 11 	brgt	8000967c <_vfprintf_r+0x1508>
8000965e:	f2 cb ff fc 	sub	r11,r9,-4
80009662:	51 0b       	stdsp	sp[0x40],r11
80009664:	fa c6 f9 44 	sub	r6,sp,-1724
80009668:	72 0b       	ld.w	r11,r9[0x0]
8000966a:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000966e:	f3 4b fd 88 	st.w	r9[-632],r11
80009672:	2f f8       	sub	r8,-1
80009674:	14 97       	mov	r7,r10
80009676:	fb 48 06 b4 	st.w	sp[1716],r8
8000967a:	c0 58       	rjmp	80009684 <_vfprintf_r+0x1510>
8000967c:	72 0b       	ld.w	r11,r9[0x0]
8000967e:	14 97       	mov	r7,r10
80009680:	2f c9       	sub	r9,-4
80009682:	51 09       	stdsp	sp[0x40],r9
80009684:	50 1b       	stdsp	sp[0x4],r11
80009686:	30 0e       	mov	lr,0
80009688:	50 0e       	stdsp	sp[0x0],lr
8000968a:	40 08       	lddsp	r8,sp[0x0]
8000968c:	40 1c       	lddsp	r12,sp[0x4]
8000968e:	18 48       	or	r8,r12
80009690:	5f 19       	srne	r9
80009692:	0a 98       	mov	r8,r5
80009694:	eb e9 00 09 	and	r9,r5,r9
80009698:	a1 b8       	sbr	r8,0x1
8000969a:	58 09       	cp.w	r9,0
8000969c:	c0 70       	breq	800096aa <_vfprintf_r+0x1536>
8000969e:	10 95       	mov	r5,r8
800096a0:	fb 60 06 b9 	st.b	sp[1721],r0
800096a4:	33 08       	mov	r8,48
800096a6:	fb 68 06 b8 	st.b	sp[1720],r8
800096aa:	30 28       	mov	r8,2
800096ac:	30 09       	mov	r9,0
800096ae:	fb 69 06 bb 	st.b	sp[1723],r9
800096b2:	0a 99       	mov	r9,r5
800096b4:	a7 d9       	cbr	r9,0x7
800096b6:	40 2b       	lddsp	r11,sp[0x8]
800096b8:	40 16       	lddsp	r6,sp[0x4]
800096ba:	58 0b       	cp.w	r11,0
800096bc:	5f 1a       	srne	r10
800096be:	f2 05 17 40 	movge	r5,r9
800096c2:	fa c2 f9 78 	sub	r2,sp,-1672
800096c6:	40 09       	lddsp	r9,sp[0x0]
800096c8:	0c 49       	or	r9,r6
800096ca:	5f 19       	srne	r9
800096cc:	f5 e9 10 09 	or	r9,r10,r9
800096d0:	c5 c0       	breq	80009788 <_vfprintf_r+0x1614>
800096d2:	30 19       	mov	r9,1
800096d4:	f2 08 18 00 	cp.b	r8,r9
800096d8:	c0 60       	breq	800096e4 <_vfprintf_r+0x1570>
800096da:	30 29       	mov	r9,2
800096dc:	f2 08 18 00 	cp.b	r8,r9
800096e0:	c0 41       	brne	800096e8 <_vfprintf_r+0x1574>
800096e2:	c3 c8       	rjmp	8000975a <_vfprintf_r+0x15e6>
800096e4:	04 96       	mov	r6,r2
800096e6:	c3 08       	rjmp	80009746 <_vfprintf_r+0x15d2>
800096e8:	04 96       	mov	r6,r2
800096ea:	fa e8 00 00 	ld.d	r8,sp[0]
800096ee:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
800096f2:	2d 0a       	sub	r10,-48
800096f4:	0c fa       	st.b	--r6,r10
800096f6:	f0 0b 16 03 	lsr	r11,r8,0x3
800096fa:	f2 0c 16 03 	lsr	r12,r9,0x3
800096fe:	f7 e9 11 db 	or	r11,r11,r9<<0x1d
80009702:	18 99       	mov	r9,r12
80009704:	16 98       	mov	r8,r11
80009706:	58 08       	cp.w	r8,0
80009708:	5c 29       	cpc	r9
8000970a:	cf 21       	brne	800096ee <_vfprintf_r+0x157a>
8000970c:	fa e9 00 00 	st.d	sp[0],r8
80009710:	ed b5 00 00 	bld	r5,0x0
80009714:	c4 51       	brne	8000979e <_vfprintf_r+0x162a>
80009716:	33 09       	mov	r9,48
80009718:	f2 0a 18 00 	cp.b	r10,r9
8000971c:	c4 10       	breq	8000979e <_vfprintf_r+0x162a>
8000971e:	0c f9       	st.b	--r6,r9
80009720:	c3 f8       	rjmp	8000979e <_vfprintf_r+0x162a>
80009722:	fa ea 00 00 	ld.d	r10,sp[0]
80009726:	30 a8       	mov	r8,10
80009728:	30 09       	mov	r9,0
8000972a:	e0 a0 1a 19 	rcall	8000cb5c <__avr32_umod64>
8000972e:	30 a8       	mov	r8,10
80009730:	2d 0a       	sub	r10,-48
80009732:	30 09       	mov	r9,0
80009734:	ac 8a       	st.b	r6[0x0],r10
80009736:	fa ea 00 00 	ld.d	r10,sp[0]
8000973a:	e0 a0 18 df 	rcall	8000c8f8 <__avr32_udiv64>
8000973e:	16 99       	mov	r9,r11
80009740:	14 98       	mov	r8,r10
80009742:	fa e9 00 00 	st.d	sp[0],r8
80009746:	20 16       	sub	r6,1
80009748:	fa ea 00 00 	ld.d	r10,sp[0]
8000974c:	58 9a       	cp.w	r10,9
8000974e:	5c 2b       	cpc	r11
80009750:	fe 9b ff e9 	brhi	80009722 <_vfprintf_r+0x15ae>
80009754:	1b f8       	ld.ub	r8,sp[0x7]
80009756:	2d 08       	sub	r8,-48
80009758:	c2 08       	rjmp	80009798 <_vfprintf_r+0x1624>
8000975a:	04 96       	mov	r6,r2
8000975c:	fa e8 00 00 	ld.d	r8,sp[0]
80009760:	f5 d8 c0 04 	bfextu	r10,r8,0x0,0x4
80009764:	40 de       	lddsp	lr,sp[0x34]
80009766:	fc 0a 07 0a 	ld.ub	r10,lr[r10]
8000976a:	0c fa       	st.b	--r6,r10
8000976c:	f2 0b 16 04 	lsr	r11,r9,0x4
80009770:	f0 0a 16 04 	lsr	r10,r8,0x4
80009774:	f5 e9 11 ca 	or	r10,r10,r9<<0x1c
80009778:	16 99       	mov	r9,r11
8000977a:	14 98       	mov	r8,r10
8000977c:	58 08       	cp.w	r8,0
8000977e:	5c 29       	cpc	r9
80009780:	cf 01       	brne	80009760 <_vfprintf_r+0x15ec>
80009782:	fa e9 00 00 	st.d	sp[0],r8
80009786:	c0 c8       	rjmp	8000979e <_vfprintf_r+0x162a>
80009788:	58 08       	cp.w	r8,0
8000978a:	c0 91       	brne	8000979c <_vfprintf_r+0x1628>
8000978c:	ed b5 00 00 	bld	r5,0x0
80009790:	c0 61       	brne	8000979c <_vfprintf_r+0x1628>
80009792:	fa c6 f9 79 	sub	r6,sp,-1671
80009796:	33 08       	mov	r8,48
80009798:	ac 88       	st.b	r6[0x0],r8
8000979a:	c0 28       	rjmp	8000979e <_vfprintf_r+0x162a>
8000979c:	04 96       	mov	r6,r2
8000979e:	0c 12       	sub	r2,r6
800097a0:	c1 c8       	rjmp	800097d8 <_vfprintf_r+0x1664>
800097a2:	50 a7       	stdsp	sp[0x28],r7
800097a4:	50 80       	stdsp	sp[0x20],r0
800097a6:	40 93       	lddsp	r3,sp[0x24]
800097a8:	0c 97       	mov	r7,r6
800097aa:	10 90       	mov	r0,r8
800097ac:	04 94       	mov	r4,r2
800097ae:	40 41       	lddsp	r1,sp[0x10]
800097b0:	58 08       	cp.w	r8,0
800097b2:	e0 80 04 4f 	breq	8000a050 <_vfprintf_r+0x1edc>
800097b6:	fb 68 06 60 	st.b	sp[1632],r8
800097ba:	30 0c       	mov	r12,0
800097bc:	30 08       	mov	r8,0
800097be:	30 12       	mov	r2,1
800097c0:	fb 68 06 bb 	st.b	sp[1723],r8
800097c4:	50 2c       	stdsp	sp[0x8],r12
800097c6:	fa c6 f9 a0 	sub	r6,sp,-1632
800097ca:	c0 78       	rjmp	800097d8 <_vfprintf_r+0x1664>
800097cc:	30 0b       	mov	r11,0
800097ce:	50 2b       	stdsp	sp[0x8],r11
800097d0:	c0 48       	rjmp	800097d8 <_vfprintf_r+0x1664>
800097d2:	40 22       	lddsp	r2,sp[0x8]
800097d4:	30 0a       	mov	r10,0
800097d6:	50 2a       	stdsp	sp[0x8],r10
800097d8:	40 29       	lddsp	r9,sp[0x8]
800097da:	e4 09 0c 49 	max	r9,r2,r9
800097de:	fb 38 06 bb 	ld.ub	r8,sp[1723]
800097e2:	50 39       	stdsp	sp[0xc],r9
800097e4:	0a 9e       	mov	lr,r5
800097e6:	30 09       	mov	r9,0
800097e8:	e2 1e 00 02 	andl	lr,0x2,COH
800097ec:	f2 08 18 00 	cp.b	r8,r9
800097f0:	fb f8 10 03 	ld.wne	r8,sp[0xc]
800097f4:	f7 b8 01 ff 	subne	r8,-1
800097f8:	fb f8 1a 03 	st.wne	sp[0xc],r8
800097fc:	0a 9b       	mov	r11,r5
800097fe:	58 0e       	cp.w	lr,0
80009800:	fb fc 10 03 	ld.wne	r12,sp[0xc]
80009804:	f7 bc 01 fe 	subne	r12,-2
80009808:	fb fc 1a 03 	st.wne	sp[0xc],r12
8000980c:	e2 1b 00 84 	andl	r11,0x84,COH
80009810:	50 fe       	stdsp	sp[0x3c],lr
80009812:	50 9b       	stdsp	sp[0x24],r11
80009814:	c4 71       	brne	800098a2 <_vfprintf_r+0x172e>
80009816:	40 8a       	lddsp	r10,sp[0x20]
80009818:	40 39       	lddsp	r9,sp[0xc]
8000981a:	12 1a       	sub	r10,r9
8000981c:	50 4a       	stdsp	sp[0x10],r10
8000981e:	58 0a       	cp.w	r10,0
80009820:	e0 89 00 20 	brgt	80009860 <_vfprintf_r+0x16ec>
80009824:	c3 f8       	rjmp	800098a2 <_vfprintf_r+0x172e>
80009826:	2f 09       	sub	r9,-16
80009828:	2f f8       	sub	r8,-1
8000982a:	fe ce b8 12 	sub	lr,pc,-18414
8000982e:	31 0c       	mov	r12,16
80009830:	fb 49 06 90 	st.w	sp[1680],r9
80009834:	87 0e       	st.w	r3[0x0],lr
80009836:	87 1c       	st.w	r3[0x4],r12
80009838:	fb 48 06 8c 	st.w	sp[1676],r8
8000983c:	58 78       	cp.w	r8,7
8000983e:	e0 89 00 04 	brgt	80009846 <_vfprintf_r+0x16d2>
80009842:	2f 83       	sub	r3,-8
80009844:	c0 b8       	rjmp	8000985a <_vfprintf_r+0x16e6>
80009846:	fa ca f9 78 	sub	r10,sp,-1672
8000984a:	02 9b       	mov	r11,r1
8000984c:	08 9c       	mov	r12,r4
8000984e:	fe b0 f4 85 	rcall	80008158 <__sprint_r>
80009852:	e0 81 04 10 	brne	8000a072 <_vfprintf_r+0x1efe>
80009856:	fa c3 f9 e0 	sub	r3,sp,-1568
8000985a:	40 4b       	lddsp	r11,sp[0x10]
8000985c:	21 0b       	sub	r11,16
8000985e:	50 4b       	stdsp	sp[0x10],r11
80009860:	fa f9 06 90 	ld.w	r9,sp[1680]
80009864:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009868:	fe ca b8 50 	sub	r10,pc,-18352
8000986c:	40 4e       	lddsp	lr,sp[0x10]
8000986e:	59 0e       	cp.w	lr,16
80009870:	fe 99 ff db 	brgt	80009826 <_vfprintf_r+0x16b2>
80009874:	1c 09       	add	r9,lr
80009876:	2f f8       	sub	r8,-1
80009878:	87 0a       	st.w	r3[0x0],r10
8000987a:	fb 49 06 90 	st.w	sp[1680],r9
8000987e:	87 1e       	st.w	r3[0x4],lr
80009880:	fb 48 06 8c 	st.w	sp[1676],r8
80009884:	58 78       	cp.w	r8,7
80009886:	e0 89 00 04 	brgt	8000988e <_vfprintf_r+0x171a>
8000988a:	2f 83       	sub	r3,-8
8000988c:	c0 b8       	rjmp	800098a2 <_vfprintf_r+0x172e>
8000988e:	fa ca f9 78 	sub	r10,sp,-1672
80009892:	02 9b       	mov	r11,r1
80009894:	08 9c       	mov	r12,r4
80009896:	fe b0 f4 61 	rcall	80008158 <__sprint_r>
8000989a:	e0 81 03 ec 	brne	8000a072 <_vfprintf_r+0x1efe>
8000989e:	fa c3 f9 e0 	sub	r3,sp,-1568
800098a2:	30 09       	mov	r9,0
800098a4:	fb 38 06 bb 	ld.ub	r8,sp[1723]
800098a8:	f2 08 18 00 	cp.b	r8,r9
800098ac:	c1 f0       	breq	800098ea <_vfprintf_r+0x1776>
800098ae:	fa f8 06 90 	ld.w	r8,sp[1680]
800098b2:	fa c9 f9 45 	sub	r9,sp,-1723
800098b6:	2f f8       	sub	r8,-1
800098b8:	87 09       	st.w	r3[0x0],r9
800098ba:	fb 48 06 90 	st.w	sp[1680],r8
800098be:	30 19       	mov	r9,1
800098c0:	fa f8 06 8c 	ld.w	r8,sp[1676]
800098c4:	87 19       	st.w	r3[0x4],r9
800098c6:	2f f8       	sub	r8,-1
800098c8:	fb 48 06 8c 	st.w	sp[1676],r8
800098cc:	58 78       	cp.w	r8,7
800098ce:	e0 89 00 04 	brgt	800098d6 <_vfprintf_r+0x1762>
800098d2:	2f 83       	sub	r3,-8
800098d4:	c0 b8       	rjmp	800098ea <_vfprintf_r+0x1776>
800098d6:	fa ca f9 78 	sub	r10,sp,-1672
800098da:	02 9b       	mov	r11,r1
800098dc:	08 9c       	mov	r12,r4
800098de:	fe b0 f4 3d 	rcall	80008158 <__sprint_r>
800098e2:	e0 81 03 c8 	brne	8000a072 <_vfprintf_r+0x1efe>
800098e6:	fa c3 f9 e0 	sub	r3,sp,-1568
800098ea:	40 fc       	lddsp	r12,sp[0x3c]
800098ec:	58 0c       	cp.w	r12,0
800098ee:	c1 f0       	breq	8000992c <_vfprintf_r+0x17b8>
800098f0:	fa f8 06 90 	ld.w	r8,sp[1680]
800098f4:	fa c9 f9 48 	sub	r9,sp,-1720
800098f8:	2f e8       	sub	r8,-2
800098fa:	87 09       	st.w	r3[0x0],r9
800098fc:	fb 48 06 90 	st.w	sp[1680],r8
80009900:	30 29       	mov	r9,2
80009902:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009906:	87 19       	st.w	r3[0x4],r9
80009908:	2f f8       	sub	r8,-1
8000990a:	fb 48 06 8c 	st.w	sp[1676],r8
8000990e:	58 78       	cp.w	r8,7
80009910:	e0 89 00 04 	brgt	80009918 <_vfprintf_r+0x17a4>
80009914:	2f 83       	sub	r3,-8
80009916:	c0 b8       	rjmp	8000992c <_vfprintf_r+0x17b8>
80009918:	fa ca f9 78 	sub	r10,sp,-1672
8000991c:	02 9b       	mov	r11,r1
8000991e:	08 9c       	mov	r12,r4
80009920:	fe b0 f4 1c 	rcall	80008158 <__sprint_r>
80009924:	e0 81 03 a7 	brne	8000a072 <_vfprintf_r+0x1efe>
80009928:	fa c3 f9 e0 	sub	r3,sp,-1568
8000992c:	40 9b       	lddsp	r11,sp[0x24]
8000992e:	e0 4b 00 80 	cp.w	r11,128
80009932:	c4 71       	brne	800099c0 <_vfprintf_r+0x184c>
80009934:	40 8a       	lddsp	r10,sp[0x20]
80009936:	40 39       	lddsp	r9,sp[0xc]
80009938:	12 1a       	sub	r10,r9
8000993a:	50 4a       	stdsp	sp[0x10],r10
8000993c:	58 0a       	cp.w	r10,0
8000993e:	e0 89 00 20 	brgt	8000997e <_vfprintf_r+0x180a>
80009942:	c3 f8       	rjmp	800099c0 <_vfprintf_r+0x184c>
80009944:	2f 09       	sub	r9,-16
80009946:	2f f8       	sub	r8,-1
80009948:	fe ce b9 20 	sub	lr,pc,-18144
8000994c:	31 0c       	mov	r12,16
8000994e:	fb 49 06 90 	st.w	sp[1680],r9
80009952:	87 0e       	st.w	r3[0x0],lr
80009954:	87 1c       	st.w	r3[0x4],r12
80009956:	fb 48 06 8c 	st.w	sp[1676],r8
8000995a:	58 78       	cp.w	r8,7
8000995c:	e0 89 00 04 	brgt	80009964 <_vfprintf_r+0x17f0>
80009960:	2f 83       	sub	r3,-8
80009962:	c0 b8       	rjmp	80009978 <_vfprintf_r+0x1804>
80009964:	fa ca f9 78 	sub	r10,sp,-1672
80009968:	02 9b       	mov	r11,r1
8000996a:	08 9c       	mov	r12,r4
8000996c:	fe b0 f3 f6 	rcall	80008158 <__sprint_r>
80009970:	e0 81 03 81 	brne	8000a072 <_vfprintf_r+0x1efe>
80009974:	fa c3 f9 e0 	sub	r3,sp,-1568
80009978:	40 4b       	lddsp	r11,sp[0x10]
8000997a:	21 0b       	sub	r11,16
8000997c:	50 4b       	stdsp	sp[0x10],r11
8000997e:	fa f9 06 90 	ld.w	r9,sp[1680]
80009982:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009986:	fe ca b9 5e 	sub	r10,pc,-18082
8000998a:	40 4e       	lddsp	lr,sp[0x10]
8000998c:	59 0e       	cp.w	lr,16
8000998e:	fe 99 ff db 	brgt	80009944 <_vfprintf_r+0x17d0>
80009992:	1c 09       	add	r9,lr
80009994:	2f f8       	sub	r8,-1
80009996:	87 0a       	st.w	r3[0x0],r10
80009998:	fb 49 06 90 	st.w	sp[1680],r9
8000999c:	87 1e       	st.w	r3[0x4],lr
8000999e:	fb 48 06 8c 	st.w	sp[1676],r8
800099a2:	58 78       	cp.w	r8,7
800099a4:	e0 89 00 04 	brgt	800099ac <_vfprintf_r+0x1838>
800099a8:	2f 83       	sub	r3,-8
800099aa:	c0 b8       	rjmp	800099c0 <_vfprintf_r+0x184c>
800099ac:	fa ca f9 78 	sub	r10,sp,-1672
800099b0:	02 9b       	mov	r11,r1
800099b2:	08 9c       	mov	r12,r4
800099b4:	fe b0 f3 d2 	rcall	80008158 <__sprint_r>
800099b8:	e0 81 03 5d 	brne	8000a072 <_vfprintf_r+0x1efe>
800099bc:	fa c3 f9 e0 	sub	r3,sp,-1568
800099c0:	40 2c       	lddsp	r12,sp[0x8]
800099c2:	04 1c       	sub	r12,r2
800099c4:	50 2c       	stdsp	sp[0x8],r12
800099c6:	58 0c       	cp.w	r12,0
800099c8:	e0 89 00 20 	brgt	80009a08 <_vfprintf_r+0x1894>
800099cc:	c3 f8       	rjmp	80009a4a <_vfprintf_r+0x18d6>
800099ce:	2f 09       	sub	r9,-16
800099d0:	2f f8       	sub	r8,-1
800099d2:	fe cb b9 aa 	sub	r11,pc,-18006
800099d6:	31 0a       	mov	r10,16
800099d8:	fb 49 06 90 	st.w	sp[1680],r9
800099dc:	87 0b       	st.w	r3[0x0],r11
800099de:	87 1a       	st.w	r3[0x4],r10
800099e0:	fb 48 06 8c 	st.w	sp[1676],r8
800099e4:	58 78       	cp.w	r8,7
800099e6:	e0 89 00 04 	brgt	800099ee <_vfprintf_r+0x187a>
800099ea:	2f 83       	sub	r3,-8
800099ec:	c0 b8       	rjmp	80009a02 <_vfprintf_r+0x188e>
800099ee:	fa ca f9 78 	sub	r10,sp,-1672
800099f2:	02 9b       	mov	r11,r1
800099f4:	08 9c       	mov	r12,r4
800099f6:	fe b0 f3 b1 	rcall	80008158 <__sprint_r>
800099fa:	e0 81 03 3c 	brne	8000a072 <_vfprintf_r+0x1efe>
800099fe:	fa c3 f9 e0 	sub	r3,sp,-1568
80009a02:	40 29       	lddsp	r9,sp[0x8]
80009a04:	21 09       	sub	r9,16
80009a06:	50 29       	stdsp	sp[0x8],r9
80009a08:	fa f9 06 90 	ld.w	r9,sp[1680]
80009a0c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009a10:	fe ca b9 e8 	sub	r10,pc,-17944
80009a14:	40 2e       	lddsp	lr,sp[0x8]
80009a16:	59 0e       	cp.w	lr,16
80009a18:	fe 99 ff db 	brgt	800099ce <_vfprintf_r+0x185a>
80009a1c:	1c 09       	add	r9,lr
80009a1e:	2f f8       	sub	r8,-1
80009a20:	87 0a       	st.w	r3[0x0],r10
80009a22:	fb 49 06 90 	st.w	sp[1680],r9
80009a26:	87 1e       	st.w	r3[0x4],lr
80009a28:	fb 48 06 8c 	st.w	sp[1676],r8
80009a2c:	58 78       	cp.w	r8,7
80009a2e:	e0 89 00 04 	brgt	80009a36 <_vfprintf_r+0x18c2>
80009a32:	2f 83       	sub	r3,-8
80009a34:	c0 b8       	rjmp	80009a4a <_vfprintf_r+0x18d6>
80009a36:	fa ca f9 78 	sub	r10,sp,-1672
80009a3a:	02 9b       	mov	r11,r1
80009a3c:	08 9c       	mov	r12,r4
80009a3e:	fe b0 f3 8d 	rcall	80008158 <__sprint_r>
80009a42:	e0 81 03 18 	brne	8000a072 <_vfprintf_r+0x1efe>
80009a46:	fa c3 f9 e0 	sub	r3,sp,-1568
80009a4a:	ed b5 00 08 	bld	r5,0x8
80009a4e:	c0 b0       	breq	80009a64 <_vfprintf_r+0x18f0>
80009a50:	fa f8 06 90 	ld.w	r8,sp[1680]
80009a54:	87 12       	st.w	r3[0x4],r2
80009a56:	87 06       	st.w	r3[0x0],r6
80009a58:	f0 02 00 02 	add	r2,r8,r2
80009a5c:	fb 42 06 90 	st.w	sp[1680],r2
80009a60:	e0 8f 01 d4 	bral	80009e08 <_vfprintf_r+0x1c94>
80009a64:	e0 40 00 65 	cp.w	r0,101
80009a68:	e0 8a 01 d6 	brle	80009e14 <_vfprintf_r+0x1ca0>
80009a6c:	30 08       	mov	r8,0
80009a6e:	30 09       	mov	r9,0
80009a70:	40 5b       	lddsp	r11,sp[0x14]
80009a72:	40 7a       	lddsp	r10,sp[0x1c]
80009a74:	e0 a0 15 3b 	rcall	8000c4ea <__avr32_f64_cmp_eq>
80009a78:	c7 90       	breq	80009b6a <_vfprintf_r+0x19f6>
80009a7a:	fa f8 06 90 	ld.w	r8,sp[1680]
80009a7e:	fe c9 ba 6a 	sub	r9,pc,-17814
80009a82:	2f f8       	sub	r8,-1
80009a84:	87 09       	st.w	r3[0x0],r9
80009a86:	fb 48 06 90 	st.w	sp[1680],r8
80009a8a:	30 19       	mov	r9,1
80009a8c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009a90:	87 19       	st.w	r3[0x4],r9
80009a92:	2f f8       	sub	r8,-1
80009a94:	fb 48 06 8c 	st.w	sp[1676],r8
80009a98:	58 78       	cp.w	r8,7
80009a9a:	e0 89 00 05 	brgt	80009aa4 <_vfprintf_r+0x1930>
80009a9e:	2f 83       	sub	r3,-8
80009aa0:	c0 c8       	rjmp	80009ab8 <_vfprintf_r+0x1944>
80009aa2:	d7 03       	nop
80009aa4:	fa ca f9 78 	sub	r10,sp,-1672
80009aa8:	02 9b       	mov	r11,r1
80009aaa:	08 9c       	mov	r12,r4
80009aac:	fe b0 f3 56 	rcall	80008158 <__sprint_r>
80009ab0:	e0 81 02 e1 	brne	8000a072 <_vfprintf_r+0x1efe>
80009ab4:	fa c3 f9 e0 	sub	r3,sp,-1568
80009ab8:	fa f8 06 ac 	ld.w	r8,sp[1708]
80009abc:	40 6c       	lddsp	r12,sp[0x18]
80009abe:	18 38       	cp.w	r8,r12
80009ac0:	c0 55       	brlt	80009aca <_vfprintf_r+0x1956>
80009ac2:	ed b5 00 00 	bld	r5,0x0
80009ac6:	e0 81 02 6b 	brne	80009f9c <_vfprintf_r+0x1e28>
80009aca:	fa f8 06 90 	ld.w	r8,sp[1680]
80009ace:	2f f8       	sub	r8,-1
80009ad0:	40 cb       	lddsp	r11,sp[0x30]
80009ad2:	fb 48 06 90 	st.w	sp[1680],r8
80009ad6:	30 19       	mov	r9,1
80009ad8:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009adc:	87 0b       	st.w	r3[0x0],r11
80009ade:	2f f8       	sub	r8,-1
80009ae0:	87 19       	st.w	r3[0x4],r9
80009ae2:	fb 48 06 8c 	st.w	sp[1676],r8
80009ae6:	58 78       	cp.w	r8,7
80009ae8:	e0 89 00 04 	brgt	80009af0 <_vfprintf_r+0x197c>
80009aec:	2f 83       	sub	r3,-8
80009aee:	c0 b8       	rjmp	80009b04 <_vfprintf_r+0x1990>
80009af0:	fa ca f9 78 	sub	r10,sp,-1672
80009af4:	02 9b       	mov	r11,r1
80009af6:	08 9c       	mov	r12,r4
80009af8:	fe b0 f3 30 	rcall	80008158 <__sprint_r>
80009afc:	e0 81 02 bb 	brne	8000a072 <_vfprintf_r+0x1efe>
80009b00:	fa c3 f9 e0 	sub	r3,sp,-1568
80009b04:	40 66       	lddsp	r6,sp[0x18]
80009b06:	20 16       	sub	r6,1
80009b08:	58 06       	cp.w	r6,0
80009b0a:	e0 89 00 1d 	brgt	80009b44 <_vfprintf_r+0x19d0>
80009b0e:	e0 8f 02 47 	bral	80009f9c <_vfprintf_r+0x1e28>
80009b12:	2f 09       	sub	r9,-16
80009b14:	2f f8       	sub	r8,-1
80009b16:	fb 49 06 90 	st.w	sp[1680],r9
80009b1a:	87 02       	st.w	r3[0x0],r2
80009b1c:	87 10       	st.w	r3[0x4],r0
80009b1e:	fb 48 06 8c 	st.w	sp[1676],r8
80009b22:	58 78       	cp.w	r8,7
80009b24:	e0 89 00 04 	brgt	80009b2c <_vfprintf_r+0x19b8>
80009b28:	2f 83       	sub	r3,-8
80009b2a:	c0 b8       	rjmp	80009b40 <_vfprintf_r+0x19cc>
80009b2c:	fa ca f9 78 	sub	r10,sp,-1672
80009b30:	02 9b       	mov	r11,r1
80009b32:	08 9c       	mov	r12,r4
80009b34:	fe b0 f3 12 	rcall	80008158 <__sprint_r>
80009b38:	e0 81 02 9d 	brne	8000a072 <_vfprintf_r+0x1efe>
80009b3c:	fa c3 f9 e0 	sub	r3,sp,-1568
80009b40:	21 06       	sub	r6,16
80009b42:	c0 48       	rjmp	80009b4a <_vfprintf_r+0x19d6>
80009b44:	fe c2 bb 1c 	sub	r2,pc,-17636
80009b48:	31 00       	mov	r0,16
80009b4a:	fa f9 06 90 	ld.w	r9,sp[1680]
80009b4e:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009b52:	fe ca bb 2a 	sub	r10,pc,-17622
80009b56:	59 06       	cp.w	r6,16
80009b58:	fe 99 ff dd 	brgt	80009b12 <_vfprintf_r+0x199e>
80009b5c:	0c 09       	add	r9,r6
80009b5e:	87 0a       	st.w	r3[0x0],r10
80009b60:	fb 49 06 90 	st.w	sp[1680],r9
80009b64:	2f f8       	sub	r8,-1
80009b66:	87 16       	st.w	r3[0x4],r6
80009b68:	c5 39       	rjmp	80009e0e <_vfprintf_r+0x1c9a>
80009b6a:	fa fa 06 ac 	ld.w	r10,sp[1708]
80009b6e:	58 0a       	cp.w	r10,0
80009b70:	e0 89 00 92 	brgt	80009c94 <_vfprintf_r+0x1b20>
80009b74:	fa f8 06 90 	ld.w	r8,sp[1680]
80009b78:	fe c9 bb 64 	sub	r9,pc,-17564
80009b7c:	2f f8       	sub	r8,-1
80009b7e:	87 09       	st.w	r3[0x0],r9
80009b80:	fb 48 06 90 	st.w	sp[1680],r8
80009b84:	30 19       	mov	r9,1
80009b86:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009b8a:	87 19       	st.w	r3[0x4],r9
80009b8c:	2f f8       	sub	r8,-1
80009b8e:	fb 48 06 8c 	st.w	sp[1676],r8
80009b92:	58 78       	cp.w	r8,7
80009b94:	e0 89 00 04 	brgt	80009b9c <_vfprintf_r+0x1a28>
80009b98:	2f 83       	sub	r3,-8
80009b9a:	c0 b8       	rjmp	80009bb0 <_vfprintf_r+0x1a3c>
80009b9c:	fa ca f9 78 	sub	r10,sp,-1672
80009ba0:	02 9b       	mov	r11,r1
80009ba2:	08 9c       	mov	r12,r4
80009ba4:	fe b0 f2 da 	rcall	80008158 <__sprint_r>
80009ba8:	e0 81 02 65 	brne	8000a072 <_vfprintf_r+0x1efe>
80009bac:	fa c3 f9 e0 	sub	r3,sp,-1568
80009bb0:	fa f8 06 ac 	ld.w	r8,sp[1708]
80009bb4:	58 08       	cp.w	r8,0
80009bb6:	c0 81       	brne	80009bc6 <_vfprintf_r+0x1a52>
80009bb8:	40 6a       	lddsp	r10,sp[0x18]
80009bba:	58 0a       	cp.w	r10,0
80009bbc:	c0 51       	brne	80009bc6 <_vfprintf_r+0x1a52>
80009bbe:	ed b5 00 00 	bld	r5,0x0
80009bc2:	e0 81 01 ed 	brne	80009f9c <_vfprintf_r+0x1e28>
80009bc6:	40 c9       	lddsp	r9,sp[0x30]
80009bc8:	fa f8 06 90 	ld.w	r8,sp[1680]
80009bcc:	2f f8       	sub	r8,-1
80009bce:	87 09       	st.w	r3[0x0],r9
80009bd0:	fb 48 06 90 	st.w	sp[1680],r8
80009bd4:	30 19       	mov	r9,1
80009bd6:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009bda:	87 19       	st.w	r3[0x4],r9
80009bdc:	2f f8       	sub	r8,-1
80009bde:	fb 48 06 8c 	st.w	sp[1676],r8
80009be2:	58 78       	cp.w	r8,7
80009be4:	e0 89 00 04 	brgt	80009bec <_vfprintf_r+0x1a78>
80009be8:	2f 83       	sub	r3,-8
80009bea:	c0 b8       	rjmp	80009c00 <_vfprintf_r+0x1a8c>
80009bec:	fa ca f9 78 	sub	r10,sp,-1672
80009bf0:	02 9b       	mov	r11,r1
80009bf2:	08 9c       	mov	r12,r4
80009bf4:	fe b0 f2 b2 	rcall	80008158 <__sprint_r>
80009bf8:	e0 81 02 3d 	brne	8000a072 <_vfprintf_r+0x1efe>
80009bfc:	fa c3 f9 e0 	sub	r3,sp,-1568
80009c00:	fa f2 06 ac 	ld.w	r2,sp[1708]
80009c04:	5c 32       	neg	r2
80009c06:	58 02       	cp.w	r2,0
80009c08:	e0 89 00 1d 	brgt	80009c42 <_vfprintf_r+0x1ace>
80009c0c:	c3 d8       	rjmp	80009c86 <_vfprintf_r+0x1b12>
80009c0e:	2f 09       	sub	r9,-16
80009c10:	2f f8       	sub	r8,-1
80009c12:	31 0e       	mov	lr,16
80009c14:	fb 49 06 90 	st.w	sp[1680],r9
80009c18:	87 00       	st.w	r3[0x0],r0
80009c1a:	87 1e       	st.w	r3[0x4],lr
80009c1c:	fb 48 06 8c 	st.w	sp[1676],r8
80009c20:	58 78       	cp.w	r8,7
80009c22:	e0 89 00 04 	brgt	80009c2a <_vfprintf_r+0x1ab6>
80009c26:	2f 83       	sub	r3,-8
80009c28:	c0 b8       	rjmp	80009c3e <_vfprintf_r+0x1aca>
80009c2a:	fa ca f9 78 	sub	r10,sp,-1672
80009c2e:	02 9b       	mov	r11,r1
80009c30:	08 9c       	mov	r12,r4
80009c32:	fe b0 f2 93 	rcall	80008158 <__sprint_r>
80009c36:	e0 81 02 1e 	brne	8000a072 <_vfprintf_r+0x1efe>
80009c3a:	fa c3 f9 e0 	sub	r3,sp,-1568
80009c3e:	21 02       	sub	r2,16
80009c40:	c0 38       	rjmp	80009c46 <_vfprintf_r+0x1ad2>
80009c42:	fe c0 bc 1a 	sub	r0,pc,-17382
80009c46:	fa f9 06 90 	ld.w	r9,sp[1680]
80009c4a:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009c4e:	fe ca bc 26 	sub	r10,pc,-17370
80009c52:	59 02       	cp.w	r2,16
80009c54:	fe 99 ff dd 	brgt	80009c0e <_vfprintf_r+0x1a9a>
80009c58:	04 09       	add	r9,r2
80009c5a:	2f f8       	sub	r8,-1
80009c5c:	87 0a       	st.w	r3[0x0],r10
80009c5e:	fb 49 06 90 	st.w	sp[1680],r9
80009c62:	87 12       	st.w	r3[0x4],r2
80009c64:	fb 48 06 8c 	st.w	sp[1676],r8
80009c68:	58 78       	cp.w	r8,7
80009c6a:	e0 89 00 04 	brgt	80009c72 <_vfprintf_r+0x1afe>
80009c6e:	2f 83       	sub	r3,-8
80009c70:	c0 b8       	rjmp	80009c86 <_vfprintf_r+0x1b12>
80009c72:	fa ca f9 78 	sub	r10,sp,-1672
80009c76:	02 9b       	mov	r11,r1
80009c78:	08 9c       	mov	r12,r4
80009c7a:	fe b0 f2 6f 	rcall	80008158 <__sprint_r>
80009c7e:	e0 81 01 fa 	brne	8000a072 <_vfprintf_r+0x1efe>
80009c82:	fa c3 f9 e0 	sub	r3,sp,-1568
80009c86:	40 6c       	lddsp	r12,sp[0x18]
80009c88:	fa f8 06 90 	ld.w	r8,sp[1680]
80009c8c:	87 06       	st.w	r3[0x0],r6
80009c8e:	87 1c       	st.w	r3[0x4],r12
80009c90:	18 08       	add	r8,r12
80009c92:	cb 98       	rjmp	80009e04 <_vfprintf_r+0x1c90>
80009c94:	fa f9 06 90 	ld.w	r9,sp[1680]
80009c98:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009c9c:	40 6b       	lddsp	r11,sp[0x18]
80009c9e:	16 3a       	cp.w	r10,r11
80009ca0:	c6 f5       	brlt	80009d7e <_vfprintf_r+0x1c0a>
80009ca2:	16 09       	add	r9,r11
80009ca4:	2f f8       	sub	r8,-1
80009ca6:	87 06       	st.w	r3[0x0],r6
80009ca8:	fb 49 06 90 	st.w	sp[1680],r9
80009cac:	87 1b       	st.w	r3[0x4],r11
80009cae:	fb 48 06 8c 	st.w	sp[1676],r8
80009cb2:	58 78       	cp.w	r8,7
80009cb4:	e0 89 00 04 	brgt	80009cbc <_vfprintf_r+0x1b48>
80009cb8:	2f 83       	sub	r3,-8
80009cba:	c0 b8       	rjmp	80009cd0 <_vfprintf_r+0x1b5c>
80009cbc:	fa ca f9 78 	sub	r10,sp,-1672
80009cc0:	02 9b       	mov	r11,r1
80009cc2:	08 9c       	mov	r12,r4
80009cc4:	fe b0 f2 4a 	rcall	80008158 <__sprint_r>
80009cc8:	e0 81 01 d5 	brne	8000a072 <_vfprintf_r+0x1efe>
80009ccc:	fa c3 f9 e0 	sub	r3,sp,-1568
80009cd0:	fa f6 06 ac 	ld.w	r6,sp[1708]
80009cd4:	40 6a       	lddsp	r10,sp[0x18]
80009cd6:	14 16       	sub	r6,r10
80009cd8:	58 06       	cp.w	r6,0
80009cda:	e0 89 00 1c 	brgt	80009d12 <_vfprintf_r+0x1b9e>
80009cde:	c3 d8       	rjmp	80009d58 <_vfprintf_r+0x1be4>
80009ce0:	2f 09       	sub	r9,-16
80009ce2:	2f f8       	sub	r8,-1
80009ce4:	fb 49 06 90 	st.w	sp[1680],r9
80009ce8:	87 02       	st.w	r3[0x0],r2
80009cea:	87 10       	st.w	r3[0x4],r0
80009cec:	fb 48 06 8c 	st.w	sp[1676],r8
80009cf0:	58 78       	cp.w	r8,7
80009cf2:	e0 89 00 04 	brgt	80009cfa <_vfprintf_r+0x1b86>
80009cf6:	2f 83       	sub	r3,-8
80009cf8:	c0 b8       	rjmp	80009d0e <_vfprintf_r+0x1b9a>
80009cfa:	fa ca f9 78 	sub	r10,sp,-1672
80009cfe:	02 9b       	mov	r11,r1
80009d00:	08 9c       	mov	r12,r4
80009d02:	fe b0 f2 2b 	rcall	80008158 <__sprint_r>
80009d06:	e0 81 01 b6 	brne	8000a072 <_vfprintf_r+0x1efe>
80009d0a:	fa c3 f9 e0 	sub	r3,sp,-1568
80009d0e:	21 06       	sub	r6,16
80009d10:	c0 48       	rjmp	80009d18 <_vfprintf_r+0x1ba4>
80009d12:	fe c2 bc ea 	sub	r2,pc,-17174
80009d16:	31 00       	mov	r0,16
80009d18:	fa f9 06 90 	ld.w	r9,sp[1680]
80009d1c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009d20:	fe ca bc f8 	sub	r10,pc,-17160
80009d24:	59 06       	cp.w	r6,16
80009d26:	fe 99 ff dd 	brgt	80009ce0 <_vfprintf_r+0x1b6c>
80009d2a:	0c 09       	add	r9,r6
80009d2c:	2f f8       	sub	r8,-1
80009d2e:	87 0a       	st.w	r3[0x0],r10
80009d30:	fb 49 06 90 	st.w	sp[1680],r9
80009d34:	87 16       	st.w	r3[0x4],r6
80009d36:	fb 48 06 8c 	st.w	sp[1676],r8
80009d3a:	58 78       	cp.w	r8,7
80009d3c:	e0 89 00 04 	brgt	80009d44 <_vfprintf_r+0x1bd0>
80009d40:	2f 83       	sub	r3,-8
80009d42:	c0 b8       	rjmp	80009d58 <_vfprintf_r+0x1be4>
80009d44:	fa ca f9 78 	sub	r10,sp,-1672
80009d48:	02 9b       	mov	r11,r1
80009d4a:	08 9c       	mov	r12,r4
80009d4c:	fe b0 f2 06 	rcall	80008158 <__sprint_r>
80009d50:	e0 81 01 91 	brne	8000a072 <_vfprintf_r+0x1efe>
80009d54:	fa c3 f9 e0 	sub	r3,sp,-1568
80009d58:	ed b5 00 00 	bld	r5,0x0
80009d5c:	e0 81 01 20 	brne	80009f9c <_vfprintf_r+0x1e28>
80009d60:	40 c9       	lddsp	r9,sp[0x30]
80009d62:	fa f8 06 90 	ld.w	r8,sp[1680]
80009d66:	2f f8       	sub	r8,-1
80009d68:	87 09       	st.w	r3[0x0],r9
80009d6a:	fb 48 06 90 	st.w	sp[1680],r8
80009d6e:	30 19       	mov	r9,1
80009d70:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009d74:	87 19       	st.w	r3[0x4],r9
80009d76:	2f f8       	sub	r8,-1
80009d78:	fb 48 06 8c 	st.w	sp[1676],r8
80009d7c:	c0 29       	rjmp	80009f80 <_vfprintf_r+0x1e0c>
80009d7e:	14 09       	add	r9,r10
80009d80:	2f f8       	sub	r8,-1
80009d82:	fb 49 06 90 	st.w	sp[1680],r9
80009d86:	87 06       	st.w	r3[0x0],r6
80009d88:	87 1a       	st.w	r3[0x4],r10
80009d8a:	fb 48 06 8c 	st.w	sp[1676],r8
80009d8e:	58 78       	cp.w	r8,7
80009d90:	e0 89 00 04 	brgt	80009d98 <_vfprintf_r+0x1c24>
80009d94:	2f 83       	sub	r3,-8
80009d96:	c0 b8       	rjmp	80009dac <_vfprintf_r+0x1c38>
80009d98:	fa ca f9 78 	sub	r10,sp,-1672
80009d9c:	02 9b       	mov	r11,r1
80009d9e:	08 9c       	mov	r12,r4
80009da0:	fe b0 f1 dc 	rcall	80008158 <__sprint_r>
80009da4:	e0 81 01 67 	brne	8000a072 <_vfprintf_r+0x1efe>
80009da8:	fa c3 f9 e0 	sub	r3,sp,-1568
80009dac:	40 c8       	lddsp	r8,sp[0x30]
80009dae:	87 08       	st.w	r3[0x0],r8
80009db0:	fa f8 06 90 	ld.w	r8,sp[1680]
80009db4:	2f f8       	sub	r8,-1
80009db6:	30 19       	mov	r9,1
80009db8:	fb 48 06 90 	st.w	sp[1680],r8
80009dbc:	87 19       	st.w	r3[0x4],r9
80009dbe:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009dc2:	2f f8       	sub	r8,-1
80009dc4:	fb 48 06 8c 	st.w	sp[1676],r8
80009dc8:	fa f2 06 ac 	ld.w	r2,sp[1708]
80009dcc:	58 78       	cp.w	r8,7
80009dce:	e0 89 00 04 	brgt	80009dd6 <_vfprintf_r+0x1c62>
80009dd2:	2f 83       	sub	r3,-8
80009dd4:	c0 b8       	rjmp	80009dea <_vfprintf_r+0x1c76>
80009dd6:	fa ca f9 78 	sub	r10,sp,-1672
80009dda:	02 9b       	mov	r11,r1
80009ddc:	08 9c       	mov	r12,r4
80009dde:	fe b0 f1 bd 	rcall	80008158 <__sprint_r>
80009de2:	e0 81 01 48 	brne	8000a072 <_vfprintf_r+0x1efe>
80009de6:	fa c3 f9 e0 	sub	r3,sp,-1568
80009dea:	04 06       	add	r6,r2
80009dec:	fa f8 06 ac 	ld.w	r8,sp[1708]
80009df0:	87 06       	st.w	r3[0x0],r6
80009df2:	fa f9 06 90 	ld.w	r9,sp[1680]
80009df6:	40 66       	lddsp	r6,sp[0x18]
80009df8:	40 6e       	lddsp	lr,sp[0x18]
80009dfa:	10 16       	sub	r6,r8
80009dfc:	f2 08 01 08 	sub	r8,r9,r8
80009e00:	87 16       	st.w	r3[0x4],r6
80009e02:	1c 08       	add	r8,lr
80009e04:	fb 48 06 90 	st.w	sp[1680],r8
80009e08:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009e0c:	2f f8       	sub	r8,-1
80009e0e:	fb 48 06 8c 	st.w	sp[1676],r8
80009e12:	cb 78       	rjmp	80009f80 <_vfprintf_r+0x1e0c>
80009e14:	40 6c       	lddsp	r12,sp[0x18]
80009e16:	58 1c       	cp.w	r12,1
80009e18:	e0 89 00 06 	brgt	80009e24 <_vfprintf_r+0x1cb0>
80009e1c:	ed b5 00 00 	bld	r5,0x0
80009e20:	e0 81 00 85 	brne	80009f2a <_vfprintf_r+0x1db6>
80009e24:	fa f8 06 90 	ld.w	r8,sp[1680]
80009e28:	2f f8       	sub	r8,-1
80009e2a:	30 19       	mov	r9,1
80009e2c:	fb 48 06 90 	st.w	sp[1680],r8
80009e30:	87 06       	st.w	r3[0x0],r6
80009e32:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009e36:	87 19       	st.w	r3[0x4],r9
80009e38:	2f f8       	sub	r8,-1
80009e3a:	fb 48 06 8c 	st.w	sp[1676],r8
80009e3e:	58 78       	cp.w	r8,7
80009e40:	e0 89 00 04 	brgt	80009e48 <_vfprintf_r+0x1cd4>
80009e44:	2f 83       	sub	r3,-8
80009e46:	c0 b8       	rjmp	80009e5c <_vfprintf_r+0x1ce8>
80009e48:	fa ca f9 78 	sub	r10,sp,-1672
80009e4c:	02 9b       	mov	r11,r1
80009e4e:	08 9c       	mov	r12,r4
80009e50:	fe b0 f1 84 	rcall	80008158 <__sprint_r>
80009e54:	e0 81 01 0f 	brne	8000a072 <_vfprintf_r+0x1efe>
80009e58:	fa c3 f9 e0 	sub	r3,sp,-1568
80009e5c:	fa f8 06 90 	ld.w	r8,sp[1680]
80009e60:	2f f8       	sub	r8,-1
80009e62:	40 cb       	lddsp	r11,sp[0x30]
80009e64:	fb 48 06 90 	st.w	sp[1680],r8
80009e68:	30 19       	mov	r9,1
80009e6a:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009e6e:	87 0b       	st.w	r3[0x0],r11
80009e70:	2f f8       	sub	r8,-1
80009e72:	87 19       	st.w	r3[0x4],r9
80009e74:	fb 48 06 8c 	st.w	sp[1676],r8
80009e78:	58 78       	cp.w	r8,7
80009e7a:	e0 89 00 05 	brgt	80009e84 <_vfprintf_r+0x1d10>
80009e7e:	2f 83       	sub	r3,-8
80009e80:	c0 c8       	rjmp	80009e98 <_vfprintf_r+0x1d24>
80009e82:	d7 03       	nop
80009e84:	fa ca f9 78 	sub	r10,sp,-1672
80009e88:	02 9b       	mov	r11,r1
80009e8a:	08 9c       	mov	r12,r4
80009e8c:	fe b0 f1 66 	rcall	80008158 <__sprint_r>
80009e90:	e0 81 00 f1 	brne	8000a072 <_vfprintf_r+0x1efe>
80009e94:	fa c3 f9 e0 	sub	r3,sp,-1568
80009e98:	30 08       	mov	r8,0
80009e9a:	30 09       	mov	r9,0
80009e9c:	40 5b       	lddsp	r11,sp[0x14]
80009e9e:	40 7a       	lddsp	r10,sp[0x1c]
80009ea0:	e0 a0 13 25 	rcall	8000c4ea <__avr32_f64_cmp_eq>
80009ea4:	40 68       	lddsp	r8,sp[0x18]
80009ea6:	20 18       	sub	r8,1
80009ea8:	58 0c       	cp.w	r12,0
80009eaa:	c0 d1       	brne	80009ec4 <_vfprintf_r+0x1d50>
80009eac:	2f f6       	sub	r6,-1
80009eae:	87 18       	st.w	r3[0x4],r8
80009eb0:	87 06       	st.w	r3[0x0],r6
80009eb2:	fa f6 06 90 	ld.w	r6,sp[1680]
80009eb6:	10 06       	add	r6,r8
80009eb8:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009ebc:	fb 46 06 90 	st.w	sp[1680],r6
80009ec0:	2f f8       	sub	r8,-1
80009ec2:	c3 18       	rjmp	80009f24 <_vfprintf_r+0x1db0>
80009ec4:	10 96       	mov	r6,r8
80009ec6:	58 08       	cp.w	r8,0
80009ec8:	e0 89 00 1c 	brgt	80009f00 <_vfprintf_r+0x1d8c>
80009ecc:	c4 b8       	rjmp	80009f62 <_vfprintf_r+0x1dee>
80009ece:	2f 09       	sub	r9,-16
80009ed0:	2f f8       	sub	r8,-1
80009ed2:	fb 49 06 90 	st.w	sp[1680],r9
80009ed6:	87 02       	st.w	r3[0x0],r2
80009ed8:	87 10       	st.w	r3[0x4],r0
80009eda:	fb 48 06 8c 	st.w	sp[1676],r8
80009ede:	58 78       	cp.w	r8,7
80009ee0:	e0 89 00 04 	brgt	80009ee8 <_vfprintf_r+0x1d74>
80009ee4:	2f 83       	sub	r3,-8
80009ee6:	c0 b8       	rjmp	80009efc <_vfprintf_r+0x1d88>
80009ee8:	fa ca f9 78 	sub	r10,sp,-1672
80009eec:	02 9b       	mov	r11,r1
80009eee:	08 9c       	mov	r12,r4
80009ef0:	fe b0 f1 34 	rcall	80008158 <__sprint_r>
80009ef4:	e0 81 00 bf 	brne	8000a072 <_vfprintf_r+0x1efe>
80009ef8:	fa c3 f9 e0 	sub	r3,sp,-1568
80009efc:	21 06       	sub	r6,16
80009efe:	c0 48       	rjmp	80009f06 <_vfprintf_r+0x1d92>
80009f00:	fe c2 be d8 	sub	r2,pc,-16680
80009f04:	31 00       	mov	r0,16
80009f06:	fa f9 06 90 	ld.w	r9,sp[1680]
80009f0a:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009f0e:	fe ca be e6 	sub	r10,pc,-16666
80009f12:	59 06       	cp.w	r6,16
80009f14:	fe 99 ff dd 	brgt	80009ece <_vfprintf_r+0x1d5a>
80009f18:	0c 09       	add	r9,r6
80009f1a:	87 0a       	st.w	r3[0x0],r10
80009f1c:	fb 49 06 90 	st.w	sp[1680],r9
80009f20:	2f f8       	sub	r8,-1
80009f22:	87 16       	st.w	r3[0x4],r6
80009f24:	fb 48 06 8c 	st.w	sp[1676],r8
80009f28:	c0 e8       	rjmp	80009f44 <_vfprintf_r+0x1dd0>
80009f2a:	fa f8 06 90 	ld.w	r8,sp[1680]
80009f2e:	2f f8       	sub	r8,-1
80009f30:	30 19       	mov	r9,1
80009f32:	fb 48 06 90 	st.w	sp[1680],r8
80009f36:	87 06       	st.w	r3[0x0],r6
80009f38:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009f3c:	87 19       	st.w	r3[0x4],r9
80009f3e:	2f f8       	sub	r8,-1
80009f40:	fb 48 06 8c 	st.w	sp[1676],r8
80009f44:	58 78       	cp.w	r8,7
80009f46:	e0 89 00 04 	brgt	80009f4e <_vfprintf_r+0x1dda>
80009f4a:	2f 83       	sub	r3,-8
80009f4c:	c0 b8       	rjmp	80009f62 <_vfprintf_r+0x1dee>
80009f4e:	fa ca f9 78 	sub	r10,sp,-1672
80009f52:	02 9b       	mov	r11,r1
80009f54:	08 9c       	mov	r12,r4
80009f56:	fe b0 f1 01 	rcall	80008158 <__sprint_r>
80009f5a:	e0 81 00 8c 	brne	8000a072 <_vfprintf_r+0x1efe>
80009f5e:	fa c3 f9 e0 	sub	r3,sp,-1568
80009f62:	40 ea       	lddsp	r10,sp[0x38]
80009f64:	fa f8 06 90 	ld.w	r8,sp[1680]
80009f68:	14 08       	add	r8,r10
80009f6a:	fa c9 f9 64 	sub	r9,sp,-1692
80009f6e:	fb 48 06 90 	st.w	sp[1680],r8
80009f72:	87 1a       	st.w	r3[0x4],r10
80009f74:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009f78:	87 09       	st.w	r3[0x0],r9
80009f7a:	2f f8       	sub	r8,-1
80009f7c:	fb 48 06 8c 	st.w	sp[1676],r8
80009f80:	58 78       	cp.w	r8,7
80009f82:	e0 89 00 04 	brgt	80009f8a <_vfprintf_r+0x1e16>
80009f86:	2f 83       	sub	r3,-8
80009f88:	c0 a8       	rjmp	80009f9c <_vfprintf_r+0x1e28>
80009f8a:	fa ca f9 78 	sub	r10,sp,-1672
80009f8e:	02 9b       	mov	r11,r1
80009f90:	08 9c       	mov	r12,r4
80009f92:	fe b0 f0 e3 	rcall	80008158 <__sprint_r>
80009f96:	c6 e1       	brne	8000a072 <_vfprintf_r+0x1efe>
80009f98:	fa c3 f9 e0 	sub	r3,sp,-1568
80009f9c:	e2 15 00 04 	andl	r5,0x4,COH
80009fa0:	c3 f0       	breq	8000a01e <_vfprintf_r+0x1eaa>
80009fa2:	40 86       	lddsp	r6,sp[0x20]
80009fa4:	40 39       	lddsp	r9,sp[0xc]
80009fa6:	12 16       	sub	r6,r9
80009fa8:	58 06       	cp.w	r6,0
80009faa:	e0 89 00 1a 	brgt	80009fde <_vfprintf_r+0x1e6a>
80009fae:	c3 88       	rjmp	8000a01e <_vfprintf_r+0x1eaa>
80009fb0:	2f 09       	sub	r9,-16
80009fb2:	2f f8       	sub	r8,-1
80009fb4:	fb 49 06 90 	st.w	sp[1680],r9
80009fb8:	87 05       	st.w	r3[0x0],r5
80009fba:	87 12       	st.w	r3[0x4],r2
80009fbc:	fb 48 06 8c 	st.w	sp[1676],r8
80009fc0:	58 78       	cp.w	r8,7
80009fc2:	e0 89 00 04 	brgt	80009fca <_vfprintf_r+0x1e56>
80009fc6:	2f 83       	sub	r3,-8
80009fc8:	c0 98       	rjmp	80009fda <_vfprintf_r+0x1e66>
80009fca:	00 9a       	mov	r10,r0
80009fcc:	02 9b       	mov	r11,r1
80009fce:	08 9c       	mov	r12,r4
80009fd0:	fe b0 f0 c4 	rcall	80008158 <__sprint_r>
80009fd4:	c4 f1       	brne	8000a072 <_vfprintf_r+0x1efe>
80009fd6:	fa c3 f9 e0 	sub	r3,sp,-1568
80009fda:	21 06       	sub	r6,16
80009fdc:	c0 68       	rjmp	80009fe8 <_vfprintf_r+0x1e74>
80009fde:	fe c5 bf c6 	sub	r5,pc,-16442
80009fe2:	31 02       	mov	r2,16
80009fe4:	fa c0 f9 78 	sub	r0,sp,-1672
80009fe8:	fa f9 06 90 	ld.w	r9,sp[1680]
80009fec:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009ff0:	fe ca bf d8 	sub	r10,pc,-16424
80009ff4:	59 06       	cp.w	r6,16
80009ff6:	fe 99 ff dd 	brgt	80009fb0 <_vfprintf_r+0x1e3c>
80009ffa:	0c 09       	add	r9,r6
80009ffc:	2f f8       	sub	r8,-1
80009ffe:	87 0a       	st.w	r3[0x0],r10
8000a000:	87 16       	st.w	r3[0x4],r6
8000a002:	fb 49 06 90 	st.w	sp[1680],r9
8000a006:	fb 48 06 8c 	st.w	sp[1676],r8
8000a00a:	58 78       	cp.w	r8,7
8000a00c:	e0 8a 00 09 	brle	8000a01e <_vfprintf_r+0x1eaa>
8000a010:	fa ca f9 78 	sub	r10,sp,-1672
8000a014:	02 9b       	mov	r11,r1
8000a016:	08 9c       	mov	r12,r4
8000a018:	fe b0 f0 a0 	rcall	80008158 <__sprint_r>
8000a01c:	c2 b1       	brne	8000a072 <_vfprintf_r+0x1efe>
8000a01e:	40 bc       	lddsp	r12,sp[0x2c]
8000a020:	40 36       	lddsp	r6,sp[0xc]
8000a022:	40 8e       	lddsp	lr,sp[0x20]
8000a024:	ec 0e 0c 48 	max	r8,r6,lr
8000a028:	10 0c       	add	r12,r8
8000a02a:	50 bc       	stdsp	sp[0x2c],r12
8000a02c:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a030:	58 08       	cp.w	r8,0
8000a032:	c0 80       	breq	8000a042 <_vfprintf_r+0x1ece>
8000a034:	fa ca f9 78 	sub	r10,sp,-1672
8000a038:	02 9b       	mov	r11,r1
8000a03a:	08 9c       	mov	r12,r4
8000a03c:	fe b0 f0 8e 	rcall	80008158 <__sprint_r>
8000a040:	c1 91       	brne	8000a072 <_vfprintf_r+0x1efe>
8000a042:	30 0b       	mov	r11,0
8000a044:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a048:	fb 4b 06 8c 	st.w	sp[1676],r11
8000a04c:	fe 9f f1 22 	bral	80008290 <_vfprintf_r+0x11c>
8000a050:	08 95       	mov	r5,r4
8000a052:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a056:	58 08       	cp.w	r8,0
8000a058:	c0 80       	breq	8000a068 <_vfprintf_r+0x1ef4>
8000a05a:	08 9c       	mov	r12,r4
8000a05c:	fa ca f9 78 	sub	r10,sp,-1672
8000a060:	02 9b       	mov	r11,r1
8000a062:	fe b0 f0 7b 	rcall	80008158 <__sprint_r>
8000a066:	c0 61       	brne	8000a072 <_vfprintf_r+0x1efe>
8000a068:	30 08       	mov	r8,0
8000a06a:	fb 48 06 8c 	st.w	sp[1676],r8
8000a06e:	c0 28       	rjmp	8000a072 <_vfprintf_r+0x1efe>
8000a070:	40 41       	lddsp	r1,sp[0x10]
8000a072:	82 68       	ld.sh	r8,r1[0xc]
8000a074:	ed b8 00 06 	bld	r8,0x6
8000a078:	c0 31       	brne	8000a07e <_vfprintf_r+0x1f0a>
8000a07a:	3f fa       	mov	r10,-1
8000a07c:	50 ba       	stdsp	sp[0x2c],r10
8000a07e:	40 bc       	lddsp	r12,sp[0x2c]
8000a080:	fe 3d f9 44 	sub	sp,-1724
8000a084:	d8 32       	popm	r0-r7,pc
8000a086:	d7 03       	nop

8000a088 <__swsetup_r>:
8000a088:	d4 21       	pushm	r4-r7,lr
8000a08a:	e0 68 0a 3c 	mov	r8,2620
8000a08e:	18 96       	mov	r6,r12
8000a090:	16 97       	mov	r7,r11
8000a092:	70 0c       	ld.w	r12,r8[0x0]
8000a094:	58 0c       	cp.w	r12,0
8000a096:	c0 60       	breq	8000a0a2 <__swsetup_r+0x1a>
8000a098:	78 68       	ld.w	r8,r12[0x18]
8000a09a:	58 08       	cp.w	r8,0
8000a09c:	c0 31       	brne	8000a0a2 <__swsetup_r+0x1a>
8000a09e:	e0 a0 07 bf 	rcall	8000b01c <__sinit>
8000a0a2:	fe c8 bf 5a 	sub	r8,pc,-16550
8000a0a6:	10 37       	cp.w	r7,r8
8000a0a8:	c0 61       	brne	8000a0b4 <__swsetup_r+0x2c>
8000a0aa:	e0 68 0a 3c 	mov	r8,2620
8000a0ae:	70 08       	ld.w	r8,r8[0x0]
8000a0b0:	70 07       	ld.w	r7,r8[0x0]
8000a0b2:	c1 28       	rjmp	8000a0d6 <__swsetup_r+0x4e>
8000a0b4:	fe c8 bf 4c 	sub	r8,pc,-16564
8000a0b8:	10 37       	cp.w	r7,r8
8000a0ba:	c0 61       	brne	8000a0c6 <__swsetup_r+0x3e>
8000a0bc:	e0 68 0a 3c 	mov	r8,2620
8000a0c0:	70 08       	ld.w	r8,r8[0x0]
8000a0c2:	70 17       	ld.w	r7,r8[0x4]
8000a0c4:	c0 98       	rjmp	8000a0d6 <__swsetup_r+0x4e>
8000a0c6:	fe c8 bf 3e 	sub	r8,pc,-16578
8000a0ca:	10 37       	cp.w	r7,r8
8000a0cc:	c0 51       	brne	8000a0d6 <__swsetup_r+0x4e>
8000a0ce:	e0 68 0a 3c 	mov	r8,2620
8000a0d2:	70 08       	ld.w	r8,r8[0x0]
8000a0d4:	70 27       	ld.w	r7,r8[0x8]
8000a0d6:	8e 68       	ld.sh	r8,r7[0xc]
8000a0d8:	ed b8 00 03 	bld	r8,0x3
8000a0dc:	c1 e0       	breq	8000a118 <__swsetup_r+0x90>
8000a0de:	ed b8 00 04 	bld	r8,0x4
8000a0e2:	c3 e1       	brne	8000a15e <__swsetup_r+0xd6>
8000a0e4:	ed b8 00 02 	bld	r8,0x2
8000a0e8:	c1 51       	brne	8000a112 <__swsetup_r+0x8a>
8000a0ea:	6e db       	ld.w	r11,r7[0x34]
8000a0ec:	58 0b       	cp.w	r11,0
8000a0ee:	c0 a0       	breq	8000a102 <__swsetup_r+0x7a>
8000a0f0:	ee c8 ff bc 	sub	r8,r7,-68
8000a0f4:	10 3b       	cp.w	r11,r8
8000a0f6:	c0 40       	breq	8000a0fe <__swsetup_r+0x76>
8000a0f8:	0c 9c       	mov	r12,r6
8000a0fa:	e0 a0 08 2b 	rcall	8000b150 <_free_r>
8000a0fe:	30 08       	mov	r8,0
8000a100:	8f d8       	st.w	r7[0x34],r8
8000a102:	8e 68       	ld.sh	r8,r7[0xc]
8000a104:	e0 18 ff db 	andl	r8,0xffdb
8000a108:	ae 68       	st.h	r7[0xc],r8
8000a10a:	30 08       	mov	r8,0
8000a10c:	8f 18       	st.w	r7[0x4],r8
8000a10e:	6e 48       	ld.w	r8,r7[0x10]
8000a110:	8f 08       	st.w	r7[0x0],r8
8000a112:	8e 68       	ld.sh	r8,r7[0xc]
8000a114:	a3 b8       	sbr	r8,0x3
8000a116:	ae 68       	st.h	r7[0xc],r8
8000a118:	6e 48       	ld.w	r8,r7[0x10]
8000a11a:	58 08       	cp.w	r8,0
8000a11c:	c0 b1       	brne	8000a132 <__swsetup_r+0xaa>
8000a11e:	8e 68       	ld.sh	r8,r7[0xc]
8000a120:	e2 18 02 80 	andl	r8,0x280,COH
8000a124:	e0 48 02 00 	cp.w	r8,512
8000a128:	c0 50       	breq	8000a132 <__swsetup_r+0xaa>
8000a12a:	0c 9c       	mov	r12,r6
8000a12c:	0e 9b       	mov	r11,r7
8000a12e:	e0 a0 0a 4b 	rcall	8000b5c4 <__smakebuf_r>
8000a132:	8e 69       	ld.sh	r9,r7[0xc]
8000a134:	f1 d9 c0 01 	bfextu	r8,r9,0x0,0x1
8000a138:	c0 70       	breq	8000a146 <__swsetup_r+0xbe>
8000a13a:	30 08       	mov	r8,0
8000a13c:	8f 28       	st.w	r7[0x8],r8
8000a13e:	6e 58       	ld.w	r8,r7[0x14]
8000a140:	5c 38       	neg	r8
8000a142:	8f 68       	st.w	r7[0x18],r8
8000a144:	c0 68       	rjmp	8000a150 <__swsetup_r+0xc8>
8000a146:	ed b9 00 01 	bld	r9,0x1
8000a14a:	ef f8 10 05 	ld.wne	r8,r7[0x14]
8000a14e:	8f 28       	st.w	r7[0x8],r8
8000a150:	6e 48       	ld.w	r8,r7[0x10]
8000a152:	58 08       	cp.w	r8,0
8000a154:	c0 61       	brne	8000a160 <__swsetup_r+0xd8>
8000a156:	8e 68       	ld.sh	r8,r7[0xc]
8000a158:	ed b8 00 07 	bld	r8,0x7
8000a15c:	c0 21       	brne	8000a160 <__swsetup_r+0xd8>
8000a15e:	dc 2a       	popm	r4-r7,pc,r12=-1
8000a160:	d8 2a       	popm	r4-r7,pc,r12=0
8000a162:	d7 03       	nop

8000a164 <quorem>:
8000a164:	d4 31       	pushm	r0-r7,lr
8000a166:	20 2d       	sub	sp,8
8000a168:	18 97       	mov	r7,r12
8000a16a:	78 48       	ld.w	r8,r12[0x10]
8000a16c:	76 46       	ld.w	r6,r11[0x10]
8000a16e:	0c 38       	cp.w	r8,r6
8000a170:	c0 34       	brge	8000a176 <quorem+0x12>
8000a172:	30 0c       	mov	r12,0
8000a174:	c8 58       	rjmp	8000a27e <quorem+0x11a>
8000a176:	ec c2 ff fc 	sub	r2,r6,-4
8000a17a:	f6 c3 ff ec 	sub	r3,r11,-20
8000a17e:	f6 02 03 29 	ld.w	r9,r11[r2<<0x2]
8000a182:	f8 02 03 2c 	ld.w	r12,r12[r2<<0x2]
8000a186:	2f f9       	sub	r9,-1
8000a188:	20 16       	sub	r6,1
8000a18a:	f8 09 0d 08 	divu	r8,r12,r9
8000a18e:	f6 02 00 22 	add	r2,r11,r2<<0x2
8000a192:	ee c4 ff ec 	sub	r4,r7,-20
8000a196:	10 95       	mov	r5,r8
8000a198:	58 08       	cp.w	r8,0
8000a19a:	c4 10       	breq	8000a21c <quorem+0xb8>
8000a19c:	30 09       	mov	r9,0
8000a19e:	06 9a       	mov	r10,r3
8000a1a0:	08 98       	mov	r8,r4
8000a1a2:	12 91       	mov	r1,r9
8000a1a4:	50 0b       	stdsp	sp[0x0],r11
8000a1a6:	70 0e       	ld.w	lr,r8[0x0]
8000a1a8:	b1 8e       	lsr	lr,0x10
8000a1aa:	50 1e       	stdsp	sp[0x4],lr
8000a1ac:	15 0e       	ld.w	lr,r10++
8000a1ae:	fc 00 16 10 	lsr	r0,lr,0x10
8000a1b2:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000a1b6:	ea 0e 03 41 	mac	r1,r5,lr
8000a1ba:	fd d1 c0 10 	bfextu	lr,r1,0x0,0x10
8000a1be:	b1 81       	lsr	r1,0x10
8000a1c0:	40 1b       	lddsp	r11,sp[0x4]
8000a1c2:	ea 00 02 40 	mul	r0,r5,r0
8000a1c6:	e2 00 00 00 	add	r0,r1,r0
8000a1ca:	e3 d0 c0 10 	bfextu	r1,r0,0x0,0x10
8000a1ce:	02 1b       	sub	r11,r1
8000a1d0:	50 1b       	stdsp	sp[0x4],r11
8000a1d2:	70 0b       	ld.w	r11,r8[0x0]
8000a1d4:	e3 db c0 10 	bfextu	r1,r11,0x0,0x10
8000a1d8:	02 09       	add	r9,r1
8000a1da:	f2 0e 01 0e 	sub	lr,r9,lr
8000a1de:	b0 1e       	st.h	r8[0x2],lr
8000a1e0:	fc 09 14 10 	asr	r9,lr,0x10
8000a1e4:	40 1e       	lddsp	lr,sp[0x4]
8000a1e6:	fc 09 00 09 	add	r9,lr,r9
8000a1ea:	b0 09       	st.h	r8[0x0],r9
8000a1ec:	e0 01 16 10 	lsr	r1,r0,0x10
8000a1f0:	2f c8       	sub	r8,-4
8000a1f2:	b1 49       	asr	r9,0x10
8000a1f4:	04 3a       	cp.w	r10,r2
8000a1f6:	fe 98 ff d8 	brls	8000a1a6 <quorem+0x42>
8000a1fa:	40 0b       	lddsp	r11,sp[0x0]
8000a1fc:	58 0c       	cp.w	r12,0
8000a1fe:	c0 f1       	brne	8000a21c <quorem+0xb8>
8000a200:	ec c8 ff fb 	sub	r8,r6,-5
8000a204:	ee 08 00 28 	add	r8,r7,r8<<0x2
8000a208:	c0 28       	rjmp	8000a20c <quorem+0xa8>
8000a20a:	20 16       	sub	r6,1
8000a20c:	20 48       	sub	r8,4
8000a20e:	08 38       	cp.w	r8,r4
8000a210:	e0 88 00 05 	brls	8000a21a <quorem+0xb6>
8000a214:	70 09       	ld.w	r9,r8[0x0]
8000a216:	58 09       	cp.w	r9,0
8000a218:	cf 90       	breq	8000a20a <quorem+0xa6>
8000a21a:	8f 46       	st.w	r7[0x10],r6
8000a21c:	0e 9c       	mov	r12,r7
8000a21e:	e0 a0 0a d2 	rcall	8000b7c2 <__mcmp>
8000a222:	c2 d5       	brlt	8000a27c <quorem+0x118>
8000a224:	2f f5       	sub	r5,-1
8000a226:	08 98       	mov	r8,r4
8000a228:	30 09       	mov	r9,0
8000a22a:	07 0b       	ld.w	r11,r3++
8000a22c:	f6 0a 16 10 	lsr	r10,r11,0x10
8000a230:	70 0c       	ld.w	r12,r8[0x0]
8000a232:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000a236:	f8 0e 16 10 	lsr	lr,r12,0x10
8000a23a:	14 1e       	sub	lr,r10
8000a23c:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000a240:	16 1a       	sub	r10,r11
8000a242:	12 0a       	add	r10,r9
8000a244:	b0 1a       	st.h	r8[0x2],r10
8000a246:	b1 4a       	asr	r10,0x10
8000a248:	fc 0a 00 09 	add	r9,lr,r10
8000a24c:	b0 09       	st.h	r8[0x0],r9
8000a24e:	2f c8       	sub	r8,-4
8000a250:	b1 49       	asr	r9,0x10
8000a252:	04 33       	cp.w	r3,r2
8000a254:	fe 98 ff eb 	brls	8000a22a <quorem+0xc6>
8000a258:	ec c8 ff fb 	sub	r8,r6,-5
8000a25c:	ee 08 03 29 	ld.w	r9,r7[r8<<0x2]
8000a260:	58 09       	cp.w	r9,0
8000a262:	c0 d1       	brne	8000a27c <quorem+0x118>
8000a264:	ee 08 00 28 	add	r8,r7,r8<<0x2
8000a268:	c0 28       	rjmp	8000a26c <quorem+0x108>
8000a26a:	20 16       	sub	r6,1
8000a26c:	20 48       	sub	r8,4
8000a26e:	08 38       	cp.w	r8,r4
8000a270:	e0 88 00 05 	brls	8000a27a <quorem+0x116>
8000a274:	70 09       	ld.w	r9,r8[0x0]
8000a276:	58 09       	cp.w	r9,0
8000a278:	cf 90       	breq	8000a26a <quorem+0x106>
8000a27a:	8f 46       	st.w	r7[0x10],r6
8000a27c:	0a 9c       	mov	r12,r5
8000a27e:	2f ed       	sub	sp,-8
8000a280:	d8 32       	popm	r0-r7,pc
8000a282:	d7 03       	nop

8000a284 <_dtoa_r>:
8000a284:	d4 31       	pushm	r0-r7,lr
8000a286:	21 ad       	sub	sp,104
8000a288:	fa c4 ff 74 	sub	r4,sp,-140
8000a28c:	18 97       	mov	r7,r12
8000a28e:	16 95       	mov	r5,r11
8000a290:	68 2c       	ld.w	r12,r4[0x8]
8000a292:	50 c9       	stdsp	sp[0x30],r9
8000a294:	68 16       	ld.w	r6,r4[0x4]
8000a296:	68 09       	ld.w	r9,r4[0x0]
8000a298:	50 e8       	stdsp	sp[0x38],r8
8000a29a:	14 94       	mov	r4,r10
8000a29c:	51 2c       	stdsp	sp[0x48],r12
8000a29e:	fa e5 00 08 	st.d	sp[8],r4
8000a2a2:	51 59       	stdsp	sp[0x54],r9
8000a2a4:	6e 95       	ld.w	r5,r7[0x24]
8000a2a6:	58 05       	cp.w	r5,0
8000a2a8:	c0 91       	brne	8000a2ba <_dtoa_r+0x36>
8000a2aa:	31 0c       	mov	r12,16
8000a2ac:	fe b0 e8 f4 	rcall	80007494 <malloc>
8000a2b0:	99 35       	st.w	r12[0xc],r5
8000a2b2:	8f 9c       	st.w	r7[0x24],r12
8000a2b4:	99 15       	st.w	r12[0x4],r5
8000a2b6:	99 25       	st.w	r12[0x8],r5
8000a2b8:	99 05       	st.w	r12[0x0],r5
8000a2ba:	6e 99       	ld.w	r9,r7[0x24]
8000a2bc:	72 08       	ld.w	r8,r9[0x0]
8000a2be:	58 08       	cp.w	r8,0
8000a2c0:	c0 f0       	breq	8000a2de <_dtoa_r+0x5a>
8000a2c2:	72 1a       	ld.w	r10,r9[0x4]
8000a2c4:	91 1a       	st.w	r8[0x4],r10
8000a2c6:	30 1a       	mov	r10,1
8000a2c8:	72 19       	ld.w	r9,r9[0x4]
8000a2ca:	f4 09 09 49 	lsl	r9,r10,r9
8000a2ce:	10 9b       	mov	r11,r8
8000a2d0:	91 29       	st.w	r8[0x8],r9
8000a2d2:	0e 9c       	mov	r12,r7
8000a2d4:	e0 a0 0a 90 	rcall	8000b7f4 <_Bfree>
8000a2d8:	6e 98       	ld.w	r8,r7[0x24]
8000a2da:	30 09       	mov	r9,0
8000a2dc:	91 09       	st.w	r8[0x0],r9
8000a2de:	40 28       	lddsp	r8,sp[0x8]
8000a2e0:	10 94       	mov	r4,r8
8000a2e2:	58 08       	cp.w	r8,0
8000a2e4:	c0 64       	brge	8000a2f0 <_dtoa_r+0x6c>
8000a2e6:	f1 d8 c0 1f 	bfextu	r8,r8,0x0,0x1f
8000a2ea:	50 28       	stdsp	sp[0x8],r8
8000a2ec:	30 18       	mov	r8,1
8000a2ee:	c0 28       	rjmp	8000a2f2 <_dtoa_r+0x6e>
8000a2f0:	30 08       	mov	r8,0
8000a2f2:	8d 08       	st.w	r6[0x0],r8
8000a2f4:	fc 1c 7f f0 	movh	r12,0x7ff0
8000a2f8:	40 26       	lddsp	r6,sp[0x8]
8000a2fa:	0c 98       	mov	r8,r6
8000a2fc:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000a300:	18 38       	cp.w	r8,r12
8000a302:	c2 01       	brne	8000a342 <_dtoa_r+0xbe>
8000a304:	e0 68 27 0f 	mov	r8,9999
8000a308:	41 5b       	lddsp	r11,sp[0x54]
8000a30a:	97 08       	st.w	r11[0x0],r8
8000a30c:	40 3a       	lddsp	r10,sp[0xc]
8000a30e:	58 0a       	cp.w	r10,0
8000a310:	c0 71       	brne	8000a31e <_dtoa_r+0x9a>
8000a312:	ed d6 c0 14 	bfextu	r6,r6,0x0,0x14
8000a316:	c0 41       	brne	8000a31e <_dtoa_r+0x9a>
8000a318:	fe cc c1 e0 	sub	r12,pc,-15904
8000a31c:	c0 38       	rjmp	8000a322 <_dtoa_r+0x9e>
8000a31e:	fe cc c1 da 	sub	r12,pc,-15910
8000a322:	41 29       	lddsp	r9,sp[0x48]
8000a324:	58 09       	cp.w	r9,0
8000a326:	e0 80 05 9a 	breq	8000ae5a <_dtoa_r+0xbd6>
8000a32a:	f8 c8 ff fd 	sub	r8,r12,-3
8000a32e:	f8 c9 ff f8 	sub	r9,r12,-8
8000a332:	11 8b       	ld.ub	r11,r8[0x0]
8000a334:	30 0a       	mov	r10,0
8000a336:	41 25       	lddsp	r5,sp[0x48]
8000a338:	f4 0b 18 00 	cp.b	r11,r10
8000a33c:	f2 08 17 10 	movne	r8,r9
8000a340:	c1 68       	rjmp	8000a36c <_dtoa_r+0xe8>
8000a342:	fa ea 00 08 	ld.d	r10,sp[8]
8000a346:	30 08       	mov	r8,0
8000a348:	fa eb 00 3c 	st.d	sp[60],r10
8000a34c:	30 09       	mov	r9,0
8000a34e:	e0 a0 10 ce 	rcall	8000c4ea <__avr32_f64_cmp_eq>
8000a352:	c1 00       	breq	8000a372 <_dtoa_r+0xee>
8000a354:	30 18       	mov	r8,1
8000a356:	41 5a       	lddsp	r10,sp[0x54]
8000a358:	95 08       	st.w	r10[0x0],r8
8000a35a:	fe cc c3 46 	sub	r12,pc,-15546
8000a35e:	41 29       	lddsp	r9,sp[0x48]
8000a360:	f8 08 00 08 	add	r8,r12,r8
8000a364:	58 09       	cp.w	r9,0
8000a366:	e0 80 05 7a 	breq	8000ae5a <_dtoa_r+0xbd6>
8000a36a:	12 95       	mov	r5,r9
8000a36c:	8b 08       	st.w	r5[0x0],r8
8000a36e:	e0 8f 05 76 	bral	8000ae5a <_dtoa_r+0xbd6>
8000a372:	fa c8 ff 9c 	sub	r8,sp,-100
8000a376:	fa c9 ff a0 	sub	r9,sp,-96
8000a37a:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a37e:	0e 9c       	mov	r12,r7
8000a380:	eb d6 c2 8b 	bfextu	r5,r6,0x14,0xb
8000a384:	e0 a0 0a 8a 	rcall	8000b898 <__d2b>
8000a388:	18 93       	mov	r3,r12
8000a38a:	58 05       	cp.w	r5,0
8000a38c:	c0 d0       	breq	8000a3a6 <_dtoa_r+0x122>
8000a38e:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a392:	30 04       	mov	r4,0
8000a394:	f1 db c0 14 	bfextu	r8,r11,0x0,0x14
8000a398:	ea c5 03 ff 	sub	r5,r5,1023
8000a39c:	10 9b       	mov	r11,r8
8000a39e:	51 74       	stdsp	sp[0x5c],r4
8000a3a0:	ea 1b 3f f0 	orh	r11,0x3ff0
8000a3a4:	c2 58       	rjmp	8000a3ee <_dtoa_r+0x16a>
8000a3a6:	41 88       	lddsp	r8,sp[0x60]
8000a3a8:	41 9c       	lddsp	r12,sp[0x64]
8000a3aa:	10 0c       	add	r12,r8
8000a3ac:	f8 c5 fb ce 	sub	r5,r12,-1074
8000a3b0:	e0 45 00 20 	cp.w	r5,32
8000a3b4:	e0 8a 00 0e 	brle	8000a3d0 <_dtoa_r+0x14c>
8000a3b8:	f8 cc fb ee 	sub	r12,r12,-1042
8000a3bc:	40 3b       	lddsp	r11,sp[0xc]
8000a3be:	ea 08 11 40 	rsub	r8,r5,64
8000a3c2:	f6 0c 0a 4c 	lsr	r12,r11,r12
8000a3c6:	ec 08 09 46 	lsl	r6,r6,r8
8000a3ca:	0c 4c       	or	r12,r6
8000a3cc:	c0 78       	rjmp	8000a3da <_dtoa_r+0x156>
8000a3ce:	d7 03       	nop
8000a3d0:	ea 0c 11 20 	rsub	r12,r5,32
8000a3d4:	40 3a       	lddsp	r10,sp[0xc]
8000a3d6:	f4 0c 09 4c 	lsl	r12,r10,r12
8000a3da:	e0 a0 10 14 	rcall	8000c402 <__avr32_u32_to_f64>
8000a3de:	fc 18 fe 10 	movh	r8,0xfe10
8000a3e2:	30 19       	mov	r9,1
8000a3e4:	ea c5 04 33 	sub	r5,r5,1075
8000a3e8:	f0 0b 00 0b 	add	r11,r8,r11
8000a3ec:	51 79       	stdsp	sp[0x5c],r9
8000a3ee:	30 08       	mov	r8,0
8000a3f0:	fc 19 3f f8 	movh	r9,0x3ff8
8000a3f4:	e0 a0 0e 9c 	rcall	8000c12c <__avr32_f64_sub>
8000a3f8:	e0 68 43 61 	mov	r8,17249
8000a3fc:	ea 18 63 6f 	orh	r8,0x636f
8000a400:	e0 69 87 a7 	mov	r9,34727
8000a404:	ea 19 3f d2 	orh	r9,0x3fd2
8000a408:	e0 a0 0d a6 	rcall	8000bf54 <__avr32_f64_mul>
8000a40c:	e0 68 c8 b3 	mov	r8,51379
8000a410:	ea 18 8b 60 	orh	r8,0x8b60
8000a414:	e0 69 8a 28 	mov	r9,35368
8000a418:	ea 19 3f c6 	orh	r9,0x3fc6
8000a41c:	e0 a0 0f 56 	rcall	8000c2c8 <__avr32_f64_add>
8000a420:	0a 9c       	mov	r12,r5
8000a422:	14 90       	mov	r0,r10
8000a424:	16 91       	mov	r1,r11
8000a426:	e0 a0 0f f2 	rcall	8000c40a <__avr32_s32_to_f64>
8000a42a:	e0 68 79 fb 	mov	r8,31227
8000a42e:	ea 18 50 9f 	orh	r8,0x509f
8000a432:	e0 69 44 13 	mov	r9,17427
8000a436:	ea 19 3f d3 	orh	r9,0x3fd3
8000a43a:	e0 a0 0d 8d 	rcall	8000bf54 <__avr32_f64_mul>
8000a43e:	14 98       	mov	r8,r10
8000a440:	16 99       	mov	r9,r11
8000a442:	00 9a       	mov	r10,r0
8000a444:	02 9b       	mov	r11,r1
8000a446:	e0 a0 0f 41 	rcall	8000c2c8 <__avr32_f64_add>
8000a44a:	14 90       	mov	r0,r10
8000a44c:	16 91       	mov	r1,r11
8000a44e:	e0 a0 0f c7 	rcall	8000c3dc <__avr32_f64_to_s32>
8000a452:	30 08       	mov	r8,0
8000a454:	18 96       	mov	r6,r12
8000a456:	30 09       	mov	r9,0
8000a458:	00 9a       	mov	r10,r0
8000a45a:	02 9b       	mov	r11,r1
8000a45c:	e0 a0 10 8e 	rcall	8000c578 <__avr32_f64_cmp_lt>
8000a460:	c0 c0       	breq	8000a478 <_dtoa_r+0x1f4>
8000a462:	0c 9c       	mov	r12,r6
8000a464:	e0 a0 0f d3 	rcall	8000c40a <__avr32_s32_to_f64>
8000a468:	14 98       	mov	r8,r10
8000a46a:	16 99       	mov	r9,r11
8000a46c:	00 9a       	mov	r10,r0
8000a46e:	02 9b       	mov	r11,r1
8000a470:	e0 a0 10 3d 	rcall	8000c4ea <__avr32_f64_cmp_eq>
8000a474:	f7 b6 00 01 	subeq	r6,1
8000a478:	59 66       	cp.w	r6,22
8000a47a:	e0 88 00 05 	brls	8000a484 <_dtoa_r+0x200>
8000a47e:	30 18       	mov	r8,1
8000a480:	51 48       	stdsp	sp[0x50],r8
8000a482:	c1 38       	rjmp	8000a4a8 <_dtoa_r+0x224>
8000a484:	fe c8 c2 8c 	sub	r8,pc,-15732
8000a488:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a48c:	f0 06 02 38 	ld.d	r8,r8[r6<<0x3]
8000a490:	e0 a0 10 74 	rcall	8000c578 <__avr32_f64_cmp_lt>
8000a494:	f9 b4 00 00 	moveq	r4,0
8000a498:	fb f4 0a 14 	st.weq	sp[0x50],r4
8000a49c:	f7 b6 01 01 	subne	r6,1
8000a4a0:	f9 bc 01 00 	movne	r12,0
8000a4a4:	fb fc 1a 14 	st.wne	sp[0x50],r12
8000a4a8:	41 90       	lddsp	r0,sp[0x64]
8000a4aa:	20 10       	sub	r0,1
8000a4ac:	0a 10       	sub	r0,r5
8000a4ae:	c0 46       	brmi	8000a4b6 <_dtoa_r+0x232>
8000a4b0:	50 40       	stdsp	sp[0x10],r0
8000a4b2:	30 00       	mov	r0,0
8000a4b4:	c0 48       	rjmp	8000a4bc <_dtoa_r+0x238>
8000a4b6:	30 0b       	mov	r11,0
8000a4b8:	5c 30       	neg	r0
8000a4ba:	50 4b       	stdsp	sp[0x10],r11
8000a4bc:	ec 02 11 00 	rsub	r2,r6,0
8000a4c0:	58 06       	cp.w	r6,0
8000a4c2:	fb fa 40 04 	ld.wge	r10,sp[0x10]
8000a4c6:	f5 d6 e4 0a 	addge	r10,r10,r6
8000a4ca:	fb fa 4a 04 	st.wge	sp[0x10],r10
8000a4ce:	fb f6 4a 11 	st.wge	sp[0x44],r6
8000a4d2:	f9 b2 04 00 	movge	r2,0
8000a4d6:	e1 d6 e5 10 	sublt	r0,r0,r6
8000a4da:	f9 b9 05 00 	movlt	r9,0
8000a4de:	fb f9 5a 11 	st.wlt	sp[0x44],r9
8000a4e2:	40 c8       	lddsp	r8,sp[0x30]
8000a4e4:	58 98       	cp.w	r8,9
8000a4e6:	e0 8b 00 20 	brhi	8000a526 <_dtoa_r+0x2a2>
8000a4ea:	58 58       	cp.w	r8,5
8000a4ec:	f9 b4 0a 01 	movle	r4,1
8000a4f0:	fb f5 90 0c 	ld.wgt	r5,sp[0x30]
8000a4f4:	f7 b5 09 04 	subgt	r5,4
8000a4f8:	fb f5 9a 0c 	st.wgt	sp[0x30],r5
8000a4fc:	f9 b4 09 00 	movgt	r4,0
8000a500:	40 cc       	lddsp	r12,sp[0x30]
8000a502:	58 3c       	cp.w	r12,3
8000a504:	c2 d0       	breq	8000a55e <_dtoa_r+0x2da>
8000a506:	e0 89 00 05 	brgt	8000a510 <_dtoa_r+0x28c>
8000a50a:	58 2c       	cp.w	r12,2
8000a50c:	c1 01       	brne	8000a52c <_dtoa_r+0x2a8>
8000a50e:	c1 88       	rjmp	8000a53e <_dtoa_r+0x2ba>
8000a510:	40 cb       	lddsp	r11,sp[0x30]
8000a512:	58 4b       	cp.w	r11,4
8000a514:	c0 60       	breq	8000a520 <_dtoa_r+0x29c>
8000a516:	58 5b       	cp.w	r11,5
8000a518:	c0 a1       	brne	8000a52c <_dtoa_r+0x2a8>
8000a51a:	30 1a       	mov	r10,1
8000a51c:	50 da       	stdsp	sp[0x34],r10
8000a51e:	c2 28       	rjmp	8000a562 <_dtoa_r+0x2de>
8000a520:	30 19       	mov	r9,1
8000a522:	50 d9       	stdsp	sp[0x34],r9
8000a524:	c0 f8       	rjmp	8000a542 <_dtoa_r+0x2be>
8000a526:	30 08       	mov	r8,0
8000a528:	30 14       	mov	r4,1
8000a52a:	50 c8       	stdsp	sp[0x30],r8
8000a52c:	3f f5       	mov	r5,-1
8000a52e:	30 1c       	mov	r12,1
8000a530:	30 0b       	mov	r11,0
8000a532:	50 95       	stdsp	sp[0x24],r5
8000a534:	50 dc       	stdsp	sp[0x34],r12
8000a536:	0a 91       	mov	r1,r5
8000a538:	31 28       	mov	r8,18
8000a53a:	50 eb       	stdsp	sp[0x38],r11
8000a53c:	c2 08       	rjmp	8000a57c <_dtoa_r+0x2f8>
8000a53e:	30 0a       	mov	r10,0
8000a540:	50 da       	stdsp	sp[0x34],r10
8000a542:	40 e9       	lddsp	r9,sp[0x38]
8000a544:	58 09       	cp.w	r9,0
8000a546:	e0 89 00 07 	brgt	8000a554 <_dtoa_r+0x2d0>
8000a54a:	30 18       	mov	r8,1
8000a54c:	50 98       	stdsp	sp[0x24],r8
8000a54e:	10 91       	mov	r1,r8
8000a550:	50 e8       	stdsp	sp[0x38],r8
8000a552:	c1 58       	rjmp	8000a57c <_dtoa_r+0x2f8>
8000a554:	40 e5       	lddsp	r5,sp[0x38]
8000a556:	50 95       	stdsp	sp[0x24],r5
8000a558:	0a 91       	mov	r1,r5
8000a55a:	0a 98       	mov	r8,r5
8000a55c:	c1 08       	rjmp	8000a57c <_dtoa_r+0x2f8>
8000a55e:	30 0c       	mov	r12,0
8000a560:	50 dc       	stdsp	sp[0x34],r12
8000a562:	40 eb       	lddsp	r11,sp[0x38]
8000a564:	ec 0b 00 0b 	add	r11,r6,r11
8000a568:	50 9b       	stdsp	sp[0x24],r11
8000a56a:	16 98       	mov	r8,r11
8000a56c:	2f f8       	sub	r8,-1
8000a56e:	58 08       	cp.w	r8,0
8000a570:	e0 89 00 05 	brgt	8000a57a <_dtoa_r+0x2f6>
8000a574:	10 91       	mov	r1,r8
8000a576:	30 18       	mov	r8,1
8000a578:	c0 28       	rjmp	8000a57c <_dtoa_r+0x2f8>
8000a57a:	10 91       	mov	r1,r8
8000a57c:	30 09       	mov	r9,0
8000a57e:	6e 9a       	ld.w	r10,r7[0x24]
8000a580:	95 19       	st.w	r10[0x4],r9
8000a582:	30 49       	mov	r9,4
8000a584:	c0 68       	rjmp	8000a590 <_dtoa_r+0x30c>
8000a586:	d7 03       	nop
8000a588:	6a 1a       	ld.w	r10,r5[0x4]
8000a58a:	a1 79       	lsl	r9,0x1
8000a58c:	2f fa       	sub	r10,-1
8000a58e:	8b 1a       	st.w	r5[0x4],r10
8000a590:	6e 95       	ld.w	r5,r7[0x24]
8000a592:	f2 ca ff ec 	sub	r10,r9,-20
8000a596:	10 3a       	cp.w	r10,r8
8000a598:	fe 98 ff f8 	brls	8000a588 <_dtoa_r+0x304>
8000a59c:	6a 1b       	ld.w	r11,r5[0x4]
8000a59e:	0e 9c       	mov	r12,r7
8000a5a0:	e0 a0 09 44 	rcall	8000b828 <_Balloc>
8000a5a4:	58 e1       	cp.w	r1,14
8000a5a6:	5f 88       	srls	r8
8000a5a8:	8b 0c       	st.w	r5[0x0],r12
8000a5aa:	f1 e4 00 04 	and	r4,r8,r4
8000a5ae:	6e 98       	ld.w	r8,r7[0x24]
8000a5b0:	70 08       	ld.w	r8,r8[0x0]
8000a5b2:	50 88       	stdsp	sp[0x20],r8
8000a5b4:	e0 80 01 82 	breq	8000a8b8 <_dtoa_r+0x634>
8000a5b8:	58 06       	cp.w	r6,0
8000a5ba:	e0 8a 00 43 	brle	8000a640 <_dtoa_r+0x3bc>
8000a5be:	f3 d6 c0 04 	bfextu	r9,r6,0x0,0x4
8000a5c2:	fe c8 c3 ca 	sub	r8,pc,-15414
8000a5c6:	f0 09 02 34 	ld.d	r4,r8[r9<<0x3]
8000a5ca:	fa e5 00 18 	st.d	sp[24],r4
8000a5ce:	ec 04 14 04 	asr	r4,r6,0x4
8000a5d2:	ed b4 00 04 	bld	r4,0x4
8000a5d6:	c0 30       	breq	8000a5dc <_dtoa_r+0x358>
8000a5d8:	30 25       	mov	r5,2
8000a5da:	c1 08       	rjmp	8000a5fa <_dtoa_r+0x376>
8000a5dc:	fe c8 c3 1c 	sub	r8,pc,-15588
8000a5e0:	f0 e8 00 20 	ld.d	r8,r8[32]
8000a5e4:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a5e8:	e9 d4 c0 04 	bfextu	r4,r4,0x0,0x4
8000a5ec:	e0 a0 0f fa 	rcall	8000c5e0 <__avr32_f64_div>
8000a5f0:	30 35       	mov	r5,3
8000a5f2:	14 98       	mov	r8,r10
8000a5f4:	16 99       	mov	r9,r11
8000a5f6:	fa e9 00 08 	st.d	sp[8],r8
8000a5fa:	fe cc c3 3a 	sub	r12,pc,-15558
8000a5fe:	50 a3       	stdsp	sp[0x28],r3
8000a600:	0c 93       	mov	r3,r6
8000a602:	18 96       	mov	r6,r12
8000a604:	c0 f8       	rjmp	8000a622 <_dtoa_r+0x39e>
8000a606:	fa ea 00 18 	ld.d	r10,sp[24]
8000a60a:	ed b4 00 00 	bld	r4,0x0
8000a60e:	c0 81       	brne	8000a61e <_dtoa_r+0x39a>
8000a610:	ec e8 00 00 	ld.d	r8,r6[0]
8000a614:	2f f5       	sub	r5,-1
8000a616:	e0 a0 0c 9f 	rcall	8000bf54 <__avr32_f64_mul>
8000a61a:	fa eb 00 18 	st.d	sp[24],r10
8000a61e:	a1 54       	asr	r4,0x1
8000a620:	2f 86       	sub	r6,-8
8000a622:	58 04       	cp.w	r4,0
8000a624:	cf 11       	brne	8000a606 <_dtoa_r+0x382>
8000a626:	fa e8 00 18 	ld.d	r8,sp[24]
8000a62a:	fa ea 00 08 	ld.d	r10,sp[8]
8000a62e:	06 96       	mov	r6,r3
8000a630:	e0 a0 0f d8 	rcall	8000c5e0 <__avr32_f64_div>
8000a634:	40 a3       	lddsp	r3,sp[0x28]
8000a636:	14 98       	mov	r8,r10
8000a638:	16 99       	mov	r9,r11
8000a63a:	fa e9 00 08 	st.d	sp[8],r8
8000a63e:	c2 f8       	rjmp	8000a69c <_dtoa_r+0x418>
8000a640:	ec 08 11 00 	rsub	r8,r6,0
8000a644:	c0 31       	brne	8000a64a <_dtoa_r+0x3c6>
8000a646:	30 25       	mov	r5,2
8000a648:	c2 a8       	rjmp	8000a69c <_dtoa_r+0x418>
8000a64a:	fe cc c3 8a 	sub	r12,pc,-15478
8000a64e:	f0 04 14 04 	asr	r4,r8,0x4
8000a652:	50 1c       	stdsp	sp[0x4],r12
8000a654:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
8000a658:	fe c9 c4 60 	sub	r9,pc,-15264
8000a65c:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a660:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000a664:	e0 a0 0c 78 	rcall	8000bf54 <__avr32_f64_mul>
8000a668:	40 1c       	lddsp	r12,sp[0x4]
8000a66a:	50 63       	stdsp	sp[0x18],r3
8000a66c:	30 25       	mov	r5,2
8000a66e:	0c 93       	mov	r3,r6
8000a670:	fa eb 00 08 	st.d	sp[8],r10
8000a674:	18 96       	mov	r6,r12
8000a676:	c0 f8       	rjmp	8000a694 <_dtoa_r+0x410>
8000a678:	fa ea 00 08 	ld.d	r10,sp[8]
8000a67c:	ed b4 00 00 	bld	r4,0x0
8000a680:	c0 81       	brne	8000a690 <_dtoa_r+0x40c>
8000a682:	ec e8 00 00 	ld.d	r8,r6[0]
8000a686:	2f f5       	sub	r5,-1
8000a688:	e0 a0 0c 66 	rcall	8000bf54 <__avr32_f64_mul>
8000a68c:	fa eb 00 08 	st.d	sp[8],r10
8000a690:	a1 54       	asr	r4,0x1
8000a692:	2f 86       	sub	r6,-8
8000a694:	58 04       	cp.w	r4,0
8000a696:	cf 11       	brne	8000a678 <_dtoa_r+0x3f4>
8000a698:	06 96       	mov	r6,r3
8000a69a:	40 63       	lddsp	r3,sp[0x18]
8000a69c:	41 4a       	lddsp	r10,sp[0x50]
8000a69e:	58 0a       	cp.w	r10,0
8000a6a0:	c2 a0       	breq	8000a6f4 <_dtoa_r+0x470>
8000a6a2:	fa e8 00 08 	ld.d	r8,sp[8]
8000a6a6:	58 01       	cp.w	r1,0
8000a6a8:	5f 94       	srgt	r4
8000a6aa:	fa e9 00 18 	st.d	sp[24],r8
8000a6ae:	30 08       	mov	r8,0
8000a6b0:	fc 19 3f f0 	movh	r9,0x3ff0
8000a6b4:	fa ea 00 18 	ld.d	r10,sp[24]
8000a6b8:	e0 a0 0f 60 	rcall	8000c578 <__avr32_f64_cmp_lt>
8000a6bc:	f9 bc 00 00 	moveq	r12,0
8000a6c0:	f9 bc 01 01 	movne	r12,1
8000a6c4:	e9 ec 00 0c 	and	r12,r4,r12
8000a6c8:	c1 60       	breq	8000a6f4 <_dtoa_r+0x470>
8000a6ca:	40 98       	lddsp	r8,sp[0x24]
8000a6cc:	58 08       	cp.w	r8,0
8000a6ce:	e0 8a 00 f1 	brle	8000a8b0 <_dtoa_r+0x62c>
8000a6d2:	30 08       	mov	r8,0
8000a6d4:	fc 19 40 24 	movh	r9,0x4024
8000a6d8:	ec c4 00 01 	sub	r4,r6,1
8000a6dc:	fa ea 00 18 	ld.d	r10,sp[24]
8000a6e0:	2f f5       	sub	r5,-1
8000a6e2:	50 64       	stdsp	sp[0x18],r4
8000a6e4:	e0 a0 0c 38 	rcall	8000bf54 <__avr32_f64_mul>
8000a6e8:	40 94       	lddsp	r4,sp[0x24]
8000a6ea:	14 98       	mov	r8,r10
8000a6ec:	16 99       	mov	r9,r11
8000a6ee:	fa e9 00 08 	st.d	sp[8],r8
8000a6f2:	c0 38       	rjmp	8000a6f8 <_dtoa_r+0x474>
8000a6f4:	50 66       	stdsp	sp[0x18],r6
8000a6f6:	02 94       	mov	r4,r1
8000a6f8:	0a 9c       	mov	r12,r5
8000a6fa:	e0 a0 0e 88 	rcall	8000c40a <__avr32_s32_to_f64>
8000a6fe:	fa e8 00 08 	ld.d	r8,sp[8]
8000a702:	e0 a0 0c 29 	rcall	8000bf54 <__avr32_f64_mul>
8000a706:	30 08       	mov	r8,0
8000a708:	fc 19 40 1c 	movh	r9,0x401c
8000a70c:	e0 a0 0d de 	rcall	8000c2c8 <__avr32_f64_add>
8000a710:	14 98       	mov	r8,r10
8000a712:	16 99       	mov	r9,r11
8000a714:	fa e9 00 28 	st.d	sp[40],r8
8000a718:	fc 18 fc c0 	movh	r8,0xfcc0
8000a71c:	40 a5       	lddsp	r5,sp[0x28]
8000a71e:	10 05       	add	r5,r8
8000a720:	50 a5       	stdsp	sp[0x28],r5
8000a722:	58 04       	cp.w	r4,0
8000a724:	c2 11       	brne	8000a766 <_dtoa_r+0x4e2>
8000a726:	fa ea 00 08 	ld.d	r10,sp[8]
8000a72a:	30 08       	mov	r8,0
8000a72c:	fc 19 40 14 	movh	r9,0x4014
8000a730:	e0 a0 0c fe 	rcall	8000c12c <__avr32_f64_sub>
8000a734:	40 bc       	lddsp	r12,sp[0x2c]
8000a736:	fa eb 00 08 	st.d	sp[8],r10
8000a73a:	14 98       	mov	r8,r10
8000a73c:	16 99       	mov	r9,r11
8000a73e:	18 9a       	mov	r10,r12
8000a740:	0a 9b       	mov	r11,r5
8000a742:	e0 a0 0f 1b 	rcall	8000c578 <__avr32_f64_cmp_lt>
8000a746:	e0 81 02 54 	brne	8000abee <_dtoa_r+0x96a>
8000a74a:	0a 98       	mov	r8,r5
8000a74c:	40 b9       	lddsp	r9,sp[0x2c]
8000a74e:	ee 18 80 00 	eorh	r8,0x8000
8000a752:	fa ea 00 08 	ld.d	r10,sp[8]
8000a756:	10 95       	mov	r5,r8
8000a758:	12 98       	mov	r8,r9
8000a75a:	0a 99       	mov	r9,r5
8000a75c:	e0 a0 0f 0e 	rcall	8000c578 <__avr32_f64_cmp_lt>
8000a760:	e0 81 02 3e 	brne	8000abdc <_dtoa_r+0x958>
8000a764:	ca 68       	rjmp	8000a8b0 <_dtoa_r+0x62c>
8000a766:	fe c9 c5 6e 	sub	r9,pc,-14994
8000a76a:	e8 c8 00 01 	sub	r8,r4,1
8000a76e:	40 d5       	lddsp	r5,sp[0x34]
8000a770:	58 05       	cp.w	r5,0
8000a772:	c4 f0       	breq	8000a810 <_dtoa_r+0x58c>
8000a774:	30 0c       	mov	r12,0
8000a776:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000a77a:	51 3c       	stdsp	sp[0x4c],r12
8000a77c:	30 0a       	mov	r10,0
8000a77e:	fc 1b 3f e0 	movh	r11,0x3fe0
8000a782:	e0 a0 0f 2f 	rcall	8000c5e0 <__avr32_f64_div>
8000a786:	fa e8 00 28 	ld.d	r8,sp[40]
8000a78a:	40 85       	lddsp	r5,sp[0x20]
8000a78c:	e0 a0 0c d0 	rcall	8000c12c <__avr32_f64_sub>
8000a790:	fa eb 00 28 	st.d	sp[40],r10
8000a794:	fa ea 00 08 	ld.d	r10,sp[8]
8000a798:	e0 a0 0e 22 	rcall	8000c3dc <__avr32_f64_to_s32>
8000a79c:	51 6c       	stdsp	sp[0x58],r12
8000a79e:	e0 a0 0e 36 	rcall	8000c40a <__avr32_s32_to_f64>
8000a7a2:	14 98       	mov	r8,r10
8000a7a4:	16 99       	mov	r9,r11
8000a7a6:	fa ea 00 08 	ld.d	r10,sp[8]
8000a7aa:	e0 a0 0c c1 	rcall	8000c12c <__avr32_f64_sub>
8000a7ae:	fa eb 00 08 	st.d	sp[8],r10
8000a7b2:	41 68       	lddsp	r8,sp[0x58]
8000a7b4:	2d 08       	sub	r8,-48
8000a7b6:	0a c8       	st.b	r5++,r8
8000a7b8:	41 39       	lddsp	r9,sp[0x4c]
8000a7ba:	2f f9       	sub	r9,-1
8000a7bc:	51 39       	stdsp	sp[0x4c],r9
8000a7be:	fa e8 00 28 	ld.d	r8,sp[40]
8000a7c2:	e0 a0 0e db 	rcall	8000c578 <__avr32_f64_cmp_lt>
8000a7c6:	e0 81 03 39 	brne	8000ae38 <_dtoa_r+0xbb4>
8000a7ca:	fa e8 00 08 	ld.d	r8,sp[8]
8000a7ce:	30 0a       	mov	r10,0
8000a7d0:	fc 1b 3f f0 	movh	r11,0x3ff0
8000a7d4:	e0 a0 0c ac 	rcall	8000c12c <__avr32_f64_sub>
8000a7d8:	fa e8 00 28 	ld.d	r8,sp[40]
8000a7dc:	e0 a0 0e ce 	rcall	8000c578 <__avr32_f64_cmp_lt>
8000a7e0:	fa ea 00 28 	ld.d	r10,sp[40]
8000a7e4:	30 08       	mov	r8,0
8000a7e6:	fc 19 40 24 	movh	r9,0x4024
8000a7ea:	e0 81 00 da 	brne	8000a99e <_dtoa_r+0x71a>
8000a7ee:	41 3c       	lddsp	r12,sp[0x4c]
8000a7f0:	08 3c       	cp.w	r12,r4
8000a7f2:	c5 f4       	brge	8000a8b0 <_dtoa_r+0x62c>
8000a7f4:	e0 a0 0b b0 	rcall	8000bf54 <__avr32_f64_mul>
8000a7f8:	30 08       	mov	r8,0
8000a7fa:	fa eb 00 28 	st.d	sp[40],r10
8000a7fe:	fc 19 40 24 	movh	r9,0x4024
8000a802:	fa ea 00 08 	ld.d	r10,sp[8]
8000a806:	e0 a0 0b a7 	rcall	8000bf54 <__avr32_f64_mul>
8000a80a:	fa eb 00 08 	st.d	sp[8],r10
8000a80e:	cc 3b       	rjmp	8000a794 <_dtoa_r+0x510>
8000a810:	40 85       	lddsp	r5,sp[0x20]
8000a812:	08 05       	add	r5,r4
8000a814:	f2 08 02 3a 	ld.d	r10,r9[r8<<0x3]
8000a818:	51 35       	stdsp	sp[0x4c],r5
8000a81a:	fa e8 00 28 	ld.d	r8,sp[40]
8000a81e:	40 85       	lddsp	r5,sp[0x20]
8000a820:	e0 a0 0b 9a 	rcall	8000bf54 <__avr32_f64_mul>
8000a824:	fa eb 00 28 	st.d	sp[40],r10
8000a828:	fa ea 00 08 	ld.d	r10,sp[8]
8000a82c:	e0 a0 0d d8 	rcall	8000c3dc <__avr32_f64_to_s32>
8000a830:	51 6c       	stdsp	sp[0x58],r12
8000a832:	e0 a0 0d ec 	rcall	8000c40a <__avr32_s32_to_f64>
8000a836:	14 98       	mov	r8,r10
8000a838:	16 99       	mov	r9,r11
8000a83a:	fa ea 00 08 	ld.d	r10,sp[8]
8000a83e:	e0 a0 0c 77 	rcall	8000c12c <__avr32_f64_sub>
8000a842:	fa eb 00 08 	st.d	sp[8],r10
8000a846:	41 68       	lddsp	r8,sp[0x58]
8000a848:	2d 08       	sub	r8,-48
8000a84a:	0a c8       	st.b	r5++,r8
8000a84c:	41 3c       	lddsp	r12,sp[0x4c]
8000a84e:	18 35       	cp.w	r5,r12
8000a850:	c2 81       	brne	8000a8a0 <_dtoa_r+0x61c>
8000a852:	30 08       	mov	r8,0
8000a854:	fc 19 3f e0 	movh	r9,0x3fe0
8000a858:	fa ea 00 28 	ld.d	r10,sp[40]
8000a85c:	e0 a0 0d 36 	rcall	8000c2c8 <__avr32_f64_add>
8000a860:	40 85       	lddsp	r5,sp[0x20]
8000a862:	fa e8 00 08 	ld.d	r8,sp[8]
8000a866:	08 05       	add	r5,r4
8000a868:	e0 a0 0e 88 	rcall	8000c578 <__avr32_f64_cmp_lt>
8000a86c:	e0 81 00 99 	brne	8000a99e <_dtoa_r+0x71a>
8000a870:	fa e8 00 28 	ld.d	r8,sp[40]
8000a874:	30 0a       	mov	r10,0
8000a876:	fc 1b 3f e0 	movh	r11,0x3fe0
8000a87a:	e0 a0 0c 59 	rcall	8000c12c <__avr32_f64_sub>
8000a87e:	14 98       	mov	r8,r10
8000a880:	16 99       	mov	r9,r11
8000a882:	fa ea 00 08 	ld.d	r10,sp[8]
8000a886:	e0 a0 0e 79 	rcall	8000c578 <__avr32_f64_cmp_lt>
8000a88a:	c1 30       	breq	8000a8b0 <_dtoa_r+0x62c>
8000a88c:	33 09       	mov	r9,48
8000a88e:	0a 98       	mov	r8,r5
8000a890:	11 7a       	ld.ub	r10,--r8
8000a892:	f2 0a 18 00 	cp.b	r10,r9
8000a896:	e0 81 02 d1 	brne	8000ae38 <_dtoa_r+0xbb4>
8000a89a:	10 95       	mov	r5,r8
8000a89c:	cf 9b       	rjmp	8000a88e <_dtoa_r+0x60a>
8000a89e:	d7 03       	nop
8000a8a0:	30 08       	mov	r8,0
8000a8a2:	fc 19 40 24 	movh	r9,0x4024
8000a8a6:	e0 a0 0b 57 	rcall	8000bf54 <__avr32_f64_mul>
8000a8aa:	fa eb 00 08 	st.d	sp[8],r10
8000a8ae:	cb db       	rjmp	8000a828 <_dtoa_r+0x5a4>
8000a8b0:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a8b4:	fa eb 00 08 	st.d	sp[8],r10
8000a8b8:	58 e6       	cp.w	r6,14
8000a8ba:	5f ab       	srle	r11
8000a8bc:	41 8a       	lddsp	r10,sp[0x60]
8000a8be:	30 08       	mov	r8,0
8000a8c0:	f4 09 11 ff 	rsub	r9,r10,-1
8000a8c4:	f7 e9 03 f9 	and	r9,r11,r9>>0x1f
8000a8c8:	f0 09 18 00 	cp.b	r9,r8
8000a8cc:	e0 80 00 82 	breq	8000a9d0 <_dtoa_r+0x74c>
8000a8d0:	40 ea       	lddsp	r10,sp[0x38]
8000a8d2:	58 01       	cp.w	r1,0
8000a8d4:	5f a9       	srle	r9
8000a8d6:	f3 ea 03 f9 	and	r9,r9,r10>>0x1f
8000a8da:	fe ca c6 e2 	sub	r10,pc,-14622
8000a8de:	f4 06 02 34 	ld.d	r4,r10[r6<<0x3]
8000a8e2:	fa e5 00 10 	st.d	sp[16],r4
8000a8e6:	f0 09 18 00 	cp.b	r9,r8
8000a8ea:	c1 40       	breq	8000a912 <_dtoa_r+0x68e>
8000a8ec:	58 01       	cp.w	r1,0
8000a8ee:	e0 81 01 77 	brne	8000abdc <_dtoa_r+0x958>
8000a8f2:	30 08       	mov	r8,0
8000a8f4:	fc 19 40 14 	movh	r9,0x4014
8000a8f8:	08 9a       	mov	r10,r4
8000a8fa:	0a 9b       	mov	r11,r5
8000a8fc:	e0 a0 0b 2c 	rcall	8000bf54 <__avr32_f64_mul>
8000a900:	fa e8 00 08 	ld.d	r8,sp[8]
8000a904:	e0 a0 0e 06 	rcall	8000c510 <__avr32_f64_cmp_ge>
8000a908:	e0 81 01 6a 	brne	8000abdc <_dtoa_r+0x958>
8000a90c:	02 92       	mov	r2,r1
8000a90e:	e0 8f 01 72 	bral	8000abf2 <_dtoa_r+0x96e>
8000a912:	40 85       	lddsp	r5,sp[0x20]
8000a914:	30 14       	mov	r4,1
8000a916:	fa e8 00 10 	ld.d	r8,sp[16]
8000a91a:	fa ea 00 08 	ld.d	r10,sp[8]
8000a91e:	e0 a0 0e 61 	rcall	8000c5e0 <__avr32_f64_div>
8000a922:	e0 a0 0d 5d 	rcall	8000c3dc <__avr32_f64_to_s32>
8000a926:	18 92       	mov	r2,r12
8000a928:	e0 a0 0d 71 	rcall	8000c40a <__avr32_s32_to_f64>
8000a92c:	fa e8 00 10 	ld.d	r8,sp[16]
8000a930:	e0 a0 0b 12 	rcall	8000bf54 <__avr32_f64_mul>
8000a934:	14 98       	mov	r8,r10
8000a936:	16 99       	mov	r9,r11
8000a938:	fa ea 00 08 	ld.d	r10,sp[8]
8000a93c:	e0 a0 0b f8 	rcall	8000c12c <__avr32_f64_sub>
8000a940:	fa eb 00 08 	st.d	sp[8],r10
8000a944:	e4 c8 ff d0 	sub	r8,r2,-48
8000a948:	0a c8       	st.b	r5++,r8
8000a94a:	fc 19 40 24 	movh	r9,0x4024
8000a94e:	30 08       	mov	r8,0
8000a950:	02 34       	cp.w	r4,r1
8000a952:	c3 31       	brne	8000a9b8 <_dtoa_r+0x734>
8000a954:	fa e8 00 08 	ld.d	r8,sp[8]
8000a958:	e0 a0 0c b8 	rcall	8000c2c8 <__avr32_f64_add>
8000a95c:	16 91       	mov	r1,r11
8000a95e:	14 90       	mov	r0,r10
8000a960:	14 98       	mov	r8,r10
8000a962:	02 99       	mov	r9,r1
8000a964:	fa ea 00 10 	ld.d	r10,sp[16]
8000a968:	e0 a0 0e 08 	rcall	8000c578 <__avr32_f64_cmp_lt>
8000a96c:	c1 a1       	brne	8000a9a0 <_dtoa_r+0x71c>
8000a96e:	fa e8 00 10 	ld.d	r8,sp[16]
8000a972:	00 9a       	mov	r10,r0
8000a974:	02 9b       	mov	r11,r1
8000a976:	e0 a0 0d ba 	rcall	8000c4ea <__avr32_f64_cmp_eq>
8000a97a:	e0 80 02 5e 	breq	8000ae36 <_dtoa_r+0xbb2>
8000a97e:	e5 d2 c0 01 	bfextu	r2,r2,0x0,0x1
8000a982:	c0 f1       	brne	8000a9a0 <_dtoa_r+0x71c>
8000a984:	e0 8f 02 59 	bral	8000ae36 <_dtoa_r+0xbb2>
8000a988:	40 8a       	lddsp	r10,sp[0x20]
8000a98a:	14 38       	cp.w	r8,r10
8000a98c:	c0 30       	breq	8000a992 <_dtoa_r+0x70e>
8000a98e:	10 95       	mov	r5,r8
8000a990:	c0 98       	rjmp	8000a9a2 <_dtoa_r+0x71e>
8000a992:	33 08       	mov	r8,48
8000a994:	40 89       	lddsp	r9,sp[0x20]
8000a996:	2f f6       	sub	r6,-1
8000a998:	b2 88       	st.b	r9[0x0],r8
8000a99a:	40 88       	lddsp	r8,sp[0x20]
8000a99c:	c0 88       	rjmp	8000a9ac <_dtoa_r+0x728>
8000a99e:	40 66       	lddsp	r6,sp[0x18]
8000a9a0:	33 99       	mov	r9,57
8000a9a2:	0a 98       	mov	r8,r5
8000a9a4:	11 7a       	ld.ub	r10,--r8
8000a9a6:	f2 0a 18 00 	cp.b	r10,r9
8000a9aa:	ce f0       	breq	8000a988 <_dtoa_r+0x704>
8000a9ac:	50 66       	stdsp	sp[0x18],r6
8000a9ae:	11 89       	ld.ub	r9,r8[0x0]
8000a9b0:	2f f9       	sub	r9,-1
8000a9b2:	b0 89       	st.b	r8[0x0],r9
8000a9b4:	e0 8f 02 42 	bral	8000ae38 <_dtoa_r+0xbb4>
8000a9b8:	e0 a0 0a ce 	rcall	8000bf54 <__avr32_f64_mul>
8000a9bc:	2f f4       	sub	r4,-1
8000a9be:	fa eb 00 08 	st.d	sp[8],r10
8000a9c2:	30 08       	mov	r8,0
8000a9c4:	30 09       	mov	r9,0
8000a9c6:	e0 a0 0d 92 	rcall	8000c4ea <__avr32_f64_cmp_eq>
8000a9ca:	ca 60       	breq	8000a916 <_dtoa_r+0x692>
8000a9cc:	e0 8f 02 35 	bral	8000ae36 <_dtoa_r+0xbb2>
8000a9d0:	40 d8       	lddsp	r8,sp[0x34]
8000a9d2:	58 08       	cp.w	r8,0
8000a9d4:	c0 51       	brne	8000a9de <_dtoa_r+0x75a>
8000a9d6:	04 98       	mov	r8,r2
8000a9d8:	00 95       	mov	r5,r0
8000a9da:	40 d4       	lddsp	r4,sp[0x34]
8000a9dc:	c3 78       	rjmp	8000aa4a <_dtoa_r+0x7c6>
8000a9de:	40 c5       	lddsp	r5,sp[0x30]
8000a9e0:	58 15       	cp.w	r5,1
8000a9e2:	e0 89 00 0f 	brgt	8000aa00 <_dtoa_r+0x77c>
8000a9e6:	41 74       	lddsp	r4,sp[0x5c]
8000a9e8:	58 04       	cp.w	r4,0
8000a9ea:	c0 40       	breq	8000a9f2 <_dtoa_r+0x76e>
8000a9ec:	f4 c9 fb cd 	sub	r9,r10,-1075
8000a9f0:	c0 48       	rjmp	8000a9f8 <_dtoa_r+0x774>
8000a9f2:	41 99       	lddsp	r9,sp[0x64]
8000a9f4:	f2 09 11 36 	rsub	r9,r9,54
8000a9f8:	04 98       	mov	r8,r2
8000a9fa:	00 95       	mov	r5,r0
8000a9fc:	c1 c8       	rjmp	8000aa34 <_dtoa_r+0x7b0>
8000a9fe:	d7 03       	nop
8000aa00:	e2 c8 00 01 	sub	r8,r1,1
8000aa04:	58 01       	cp.w	r1,0
8000aa06:	e0 05 17 40 	movge	r5,r0
8000aa0a:	e2 09 17 40 	movge	r9,r1
8000aa0e:	e1 d1 e5 15 	sublt	r5,r0,r1
8000aa12:	f9 b9 05 00 	movlt	r9,0
8000aa16:	10 32       	cp.w	r2,r8
8000aa18:	e5 d8 e4 18 	subge	r8,r2,r8
8000aa1c:	f1 d2 e5 18 	sublt	r8,r8,r2
8000aa20:	e5 d8 e5 02 	addlt	r2,r2,r8
8000aa24:	fb fc 50 11 	ld.wlt	r12,sp[0x44]
8000aa28:	f9 d8 e5 0c 	addlt	r12,r12,r8
8000aa2c:	fb fc 5a 11 	st.wlt	sp[0x44],r12
8000aa30:	f9 b8 05 00 	movlt	r8,0
8000aa34:	40 4b       	lddsp	r11,sp[0x10]
8000aa36:	12 0b       	add	r11,r9
8000aa38:	50 08       	stdsp	sp[0x0],r8
8000aa3a:	50 4b       	stdsp	sp[0x10],r11
8000aa3c:	12 00       	add	r0,r9
8000aa3e:	30 1b       	mov	r11,1
8000aa40:	0e 9c       	mov	r12,r7
8000aa42:	e0 a0 08 a7 	rcall	8000bb90 <__i2b>
8000aa46:	40 08       	lddsp	r8,sp[0x0]
8000aa48:	18 94       	mov	r4,r12
8000aa4a:	40 4a       	lddsp	r10,sp[0x10]
8000aa4c:	58 05       	cp.w	r5,0
8000aa4e:	5f 99       	srgt	r9
8000aa50:	58 0a       	cp.w	r10,0
8000aa52:	5f 9a       	srgt	r10
8000aa54:	f5 e9 00 09 	and	r9,r10,r9
8000aa58:	c0 80       	breq	8000aa68 <_dtoa_r+0x7e4>
8000aa5a:	40 4c       	lddsp	r12,sp[0x10]
8000aa5c:	f8 05 0d 49 	min	r9,r12,r5
8000aa60:	12 1c       	sub	r12,r9
8000aa62:	12 10       	sub	r0,r9
8000aa64:	50 4c       	stdsp	sp[0x10],r12
8000aa66:	12 15       	sub	r5,r9
8000aa68:	58 02       	cp.w	r2,0
8000aa6a:	e0 8a 00 27 	brle	8000aab8 <_dtoa_r+0x834>
8000aa6e:	40 db       	lddsp	r11,sp[0x34]
8000aa70:	58 0b       	cp.w	r11,0
8000aa72:	c1 d0       	breq	8000aaac <_dtoa_r+0x828>
8000aa74:	58 08       	cp.w	r8,0
8000aa76:	e0 8a 00 17 	brle	8000aaa4 <_dtoa_r+0x820>
8000aa7a:	10 9a       	mov	r10,r8
8000aa7c:	50 08       	stdsp	sp[0x0],r8
8000aa7e:	08 9b       	mov	r11,r4
8000aa80:	0e 9c       	mov	r12,r7
8000aa82:	e0 a0 08 cd 	rcall	8000bc1c <__pow5mult>
8000aa86:	06 9a       	mov	r10,r3
8000aa88:	18 9b       	mov	r11,r12
8000aa8a:	18 94       	mov	r4,r12
8000aa8c:	0e 9c       	mov	r12,r7
8000aa8e:	e0 a0 08 01 	rcall	8000ba90 <__multiply>
8000aa92:	18 99       	mov	r9,r12
8000aa94:	06 9b       	mov	r11,r3
8000aa96:	50 19       	stdsp	sp[0x4],r9
8000aa98:	0e 9c       	mov	r12,r7
8000aa9a:	e0 a0 06 ad 	rcall	8000b7f4 <_Bfree>
8000aa9e:	40 19       	lddsp	r9,sp[0x4]
8000aaa0:	40 08       	lddsp	r8,sp[0x0]
8000aaa2:	12 93       	mov	r3,r9
8000aaa4:	e4 08 01 0a 	sub	r10,r2,r8
8000aaa8:	c0 80       	breq	8000aab8 <_dtoa_r+0x834>
8000aaaa:	c0 28       	rjmp	8000aaae <_dtoa_r+0x82a>
8000aaac:	04 9a       	mov	r10,r2
8000aaae:	06 9b       	mov	r11,r3
8000aab0:	0e 9c       	mov	r12,r7
8000aab2:	e0 a0 08 b5 	rcall	8000bc1c <__pow5mult>
8000aab6:	18 93       	mov	r3,r12
8000aab8:	30 1b       	mov	r11,1
8000aaba:	0e 9c       	mov	r12,r7
8000aabc:	e0 a0 08 6a 	rcall	8000bb90 <__i2b>
8000aac0:	41 1a       	lddsp	r10,sp[0x44]
8000aac2:	18 92       	mov	r2,r12
8000aac4:	58 0a       	cp.w	r10,0
8000aac6:	e0 8a 00 07 	brle	8000aad4 <_dtoa_r+0x850>
8000aaca:	18 9b       	mov	r11,r12
8000aacc:	0e 9c       	mov	r12,r7
8000aace:	e0 a0 08 a7 	rcall	8000bc1c <__pow5mult>
8000aad2:	18 92       	mov	r2,r12
8000aad4:	40 c9       	lddsp	r9,sp[0x30]
8000aad6:	58 19       	cp.w	r9,1
8000aad8:	e0 89 00 14 	brgt	8000ab00 <_dtoa_r+0x87c>
8000aadc:	40 38       	lddsp	r8,sp[0xc]
8000aade:	58 08       	cp.w	r8,0
8000aae0:	c1 01       	brne	8000ab00 <_dtoa_r+0x87c>
8000aae2:	40 29       	lddsp	r9,sp[0x8]
8000aae4:	f1 d9 c0 14 	bfextu	r8,r9,0x0,0x14
8000aae8:	c0 c1       	brne	8000ab00 <_dtoa_r+0x87c>
8000aaea:	12 98       	mov	r8,r9
8000aaec:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000aaf0:	c0 80       	breq	8000ab00 <_dtoa_r+0x87c>
8000aaf2:	40 4c       	lddsp	r12,sp[0x10]
8000aaf4:	30 1b       	mov	r11,1
8000aaf6:	2f fc       	sub	r12,-1
8000aaf8:	2f f0       	sub	r0,-1
8000aafa:	50 4c       	stdsp	sp[0x10],r12
8000aafc:	50 6b       	stdsp	sp[0x18],r11
8000aafe:	c0 38       	rjmp	8000ab04 <_dtoa_r+0x880>
8000ab00:	30 0a       	mov	r10,0
8000ab02:	50 6a       	stdsp	sp[0x18],r10
8000ab04:	41 19       	lddsp	r9,sp[0x44]
8000ab06:	58 09       	cp.w	r9,0
8000ab08:	c0 31       	brne	8000ab0e <_dtoa_r+0x88a>
8000ab0a:	30 1c       	mov	r12,1
8000ab0c:	c0 98       	rjmp	8000ab1e <_dtoa_r+0x89a>
8000ab0e:	64 48       	ld.w	r8,r2[0x10]
8000ab10:	2f c8       	sub	r8,-4
8000ab12:	e4 08 03 2c 	ld.w	r12,r2[r8<<0x2]
8000ab16:	e0 a0 05 df 	rcall	8000b6d4 <__hi0bits>
8000ab1a:	f8 0c 11 20 	rsub	r12,r12,32
8000ab1e:	40 4b       	lddsp	r11,sp[0x10]
8000ab20:	f8 0b 00 08 	add	r8,r12,r11
8000ab24:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000ab28:	c0 c0       	breq	8000ab40 <_dtoa_r+0x8bc>
8000ab2a:	f0 08 11 20 	rsub	r8,r8,32
8000ab2e:	58 48       	cp.w	r8,4
8000ab30:	e0 8a 00 06 	brle	8000ab3c <_dtoa_r+0x8b8>
8000ab34:	20 48       	sub	r8,4
8000ab36:	10 0b       	add	r11,r8
8000ab38:	50 4b       	stdsp	sp[0x10],r11
8000ab3a:	c0 78       	rjmp	8000ab48 <_dtoa_r+0x8c4>
8000ab3c:	58 48       	cp.w	r8,4
8000ab3e:	c0 70       	breq	8000ab4c <_dtoa_r+0x8c8>
8000ab40:	40 4a       	lddsp	r10,sp[0x10]
8000ab42:	2e 48       	sub	r8,-28
8000ab44:	10 0a       	add	r10,r8
8000ab46:	50 4a       	stdsp	sp[0x10],r10
8000ab48:	10 00       	add	r0,r8
8000ab4a:	10 05       	add	r5,r8
8000ab4c:	58 00       	cp.w	r0,0
8000ab4e:	e0 8a 00 08 	brle	8000ab5e <_dtoa_r+0x8da>
8000ab52:	06 9b       	mov	r11,r3
8000ab54:	00 9a       	mov	r10,r0
8000ab56:	0e 9c       	mov	r12,r7
8000ab58:	e0 a0 07 58 	rcall	8000ba08 <__lshift>
8000ab5c:	18 93       	mov	r3,r12
8000ab5e:	40 49       	lddsp	r9,sp[0x10]
8000ab60:	58 09       	cp.w	r9,0
8000ab62:	e0 8a 00 08 	brle	8000ab72 <_dtoa_r+0x8ee>
8000ab66:	04 9b       	mov	r11,r2
8000ab68:	12 9a       	mov	r10,r9
8000ab6a:	0e 9c       	mov	r12,r7
8000ab6c:	e0 a0 07 4e 	rcall	8000ba08 <__lshift>
8000ab70:	18 92       	mov	r2,r12
8000ab72:	41 48       	lddsp	r8,sp[0x50]
8000ab74:	58 08       	cp.w	r8,0
8000ab76:	c1 b0       	breq	8000abac <_dtoa_r+0x928>
8000ab78:	04 9b       	mov	r11,r2
8000ab7a:	06 9c       	mov	r12,r3
8000ab7c:	e0 a0 06 23 	rcall	8000b7c2 <__mcmp>
8000ab80:	c1 64       	brge	8000abac <_dtoa_r+0x928>
8000ab82:	06 9b       	mov	r11,r3
8000ab84:	30 09       	mov	r9,0
8000ab86:	30 aa       	mov	r10,10
8000ab88:	0e 9c       	mov	r12,r7
8000ab8a:	e0 a0 08 0b 	rcall	8000bba0 <__multadd>
8000ab8e:	20 16       	sub	r6,1
8000ab90:	18 93       	mov	r3,r12
8000ab92:	40 dc       	lddsp	r12,sp[0x34]
8000ab94:	58 0c       	cp.w	r12,0
8000ab96:	c0 31       	brne	8000ab9c <_dtoa_r+0x918>
8000ab98:	40 91       	lddsp	r1,sp[0x24]
8000ab9a:	c0 98       	rjmp	8000abac <_dtoa_r+0x928>
8000ab9c:	08 9b       	mov	r11,r4
8000ab9e:	40 91       	lddsp	r1,sp[0x24]
8000aba0:	30 09       	mov	r9,0
8000aba2:	30 aa       	mov	r10,10
8000aba4:	0e 9c       	mov	r12,r7
8000aba6:	e0 a0 07 fd 	rcall	8000bba0 <__multadd>
8000abaa:	18 94       	mov	r4,r12
8000abac:	58 01       	cp.w	r1,0
8000abae:	5f a9       	srle	r9
8000abb0:	40 cb       	lddsp	r11,sp[0x30]
8000abb2:	58 2b       	cp.w	r11,2
8000abb4:	5f 98       	srgt	r8
8000abb6:	f3 e8 00 08 	and	r8,r9,r8
8000abba:	c2 50       	breq	8000ac04 <_dtoa_r+0x980>
8000abbc:	58 01       	cp.w	r1,0
8000abbe:	c1 11       	brne	8000abe0 <_dtoa_r+0x95c>
8000abc0:	04 9b       	mov	r11,r2
8000abc2:	02 99       	mov	r9,r1
8000abc4:	30 5a       	mov	r10,5
8000abc6:	0e 9c       	mov	r12,r7
8000abc8:	e0 a0 07 ec 	rcall	8000bba0 <__multadd>
8000abcc:	18 92       	mov	r2,r12
8000abce:	18 9b       	mov	r11,r12
8000abd0:	06 9c       	mov	r12,r3
8000abd2:	e0 a0 05 f8 	rcall	8000b7c2 <__mcmp>
8000abd6:	e0 89 00 0f 	brgt	8000abf4 <_dtoa_r+0x970>
8000abda:	c0 38       	rjmp	8000abe0 <_dtoa_r+0x95c>
8000abdc:	30 02       	mov	r2,0
8000abde:	04 94       	mov	r4,r2
8000abe0:	40 ea       	lddsp	r10,sp[0x38]
8000abe2:	30 09       	mov	r9,0
8000abe4:	5c da       	com	r10
8000abe6:	40 85       	lddsp	r5,sp[0x20]
8000abe8:	50 6a       	stdsp	sp[0x18],r10
8000abea:	50 49       	stdsp	sp[0x10],r9
8000abec:	c0 f9       	rjmp	8000ae0a <_dtoa_r+0xb86>
8000abee:	08 92       	mov	r2,r4
8000abf0:	40 66       	lddsp	r6,sp[0x18]
8000abf2:	04 94       	mov	r4,r2
8000abf4:	2f f6       	sub	r6,-1
8000abf6:	50 66       	stdsp	sp[0x18],r6
8000abf8:	33 18       	mov	r8,49
8000abfa:	40 85       	lddsp	r5,sp[0x20]
8000abfc:	0a c8       	st.b	r5++,r8
8000abfe:	30 08       	mov	r8,0
8000ac00:	50 48       	stdsp	sp[0x10],r8
8000ac02:	c0 49       	rjmp	8000ae0a <_dtoa_r+0xb86>
8000ac04:	40 dc       	lddsp	r12,sp[0x34]
8000ac06:	58 0c       	cp.w	r12,0
8000ac08:	e0 80 00 b5 	breq	8000ad72 <_dtoa_r+0xaee>
8000ac0c:	58 05       	cp.w	r5,0
8000ac0e:	e0 8a 00 08 	brle	8000ac1e <_dtoa_r+0x99a>
8000ac12:	08 9b       	mov	r11,r4
8000ac14:	0a 9a       	mov	r10,r5
8000ac16:	0e 9c       	mov	r12,r7
8000ac18:	e0 a0 06 f8 	rcall	8000ba08 <__lshift>
8000ac1c:	18 94       	mov	r4,r12
8000ac1e:	40 6b       	lddsp	r11,sp[0x18]
8000ac20:	58 0b       	cp.w	r11,0
8000ac22:	c0 31       	brne	8000ac28 <_dtoa_r+0x9a4>
8000ac24:	08 9c       	mov	r12,r4
8000ac26:	c1 38       	rjmp	8000ac4c <_dtoa_r+0x9c8>
8000ac28:	68 1b       	ld.w	r11,r4[0x4]
8000ac2a:	0e 9c       	mov	r12,r7
8000ac2c:	e0 a0 05 fe 	rcall	8000b828 <_Balloc>
8000ac30:	68 4a       	ld.w	r10,r4[0x10]
8000ac32:	18 95       	mov	r5,r12
8000ac34:	e8 cb ff f4 	sub	r11,r4,-12
8000ac38:	2f ea       	sub	r10,-2
8000ac3a:	2f 4c       	sub	r12,-12
8000ac3c:	a3 6a       	lsl	r10,0x2
8000ac3e:	fe b0 e6 4f 	rcall	800078dc <memcpy>
8000ac42:	0a 9b       	mov	r11,r5
8000ac44:	30 1a       	mov	r10,1
8000ac46:	0e 9c       	mov	r12,r7
8000ac48:	e0 a0 06 e0 	rcall	8000ba08 <__lshift>
8000ac4c:	50 44       	stdsp	sp[0x10],r4
8000ac4e:	40 3a       	lddsp	r10,sp[0xc]
8000ac50:	30 19       	mov	r9,1
8000ac52:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
8000ac56:	18 94       	mov	r4,r12
8000ac58:	50 da       	stdsp	sp[0x34],r10
8000ac5a:	40 85       	lddsp	r5,sp[0x20]
8000ac5c:	50 99       	stdsp	sp[0x24],r9
8000ac5e:	50 26       	stdsp	sp[0x8],r6
8000ac60:	50 e1       	stdsp	sp[0x38],r1
8000ac62:	04 9b       	mov	r11,r2
8000ac64:	06 9c       	mov	r12,r3
8000ac66:	fe b0 fa 7f 	rcall	8000a164 <quorem>
8000ac6a:	40 4b       	lddsp	r11,sp[0x10]
8000ac6c:	f8 c0 ff d0 	sub	r0,r12,-48
8000ac70:	06 9c       	mov	r12,r3
8000ac72:	e0 a0 05 a8 	rcall	8000b7c2 <__mcmp>
8000ac76:	08 9a       	mov	r10,r4
8000ac78:	50 6c       	stdsp	sp[0x18],r12
8000ac7a:	04 9b       	mov	r11,r2
8000ac7c:	0e 9c       	mov	r12,r7
8000ac7e:	e0 a0 06 5d 	rcall	8000b938 <__mdiff>
8000ac82:	18 91       	mov	r1,r12
8000ac84:	78 38       	ld.w	r8,r12[0xc]
8000ac86:	58 08       	cp.w	r8,0
8000ac88:	c0 30       	breq	8000ac8e <_dtoa_r+0xa0a>
8000ac8a:	30 16       	mov	r6,1
8000ac8c:	c0 68       	rjmp	8000ac98 <_dtoa_r+0xa14>
8000ac8e:	18 9b       	mov	r11,r12
8000ac90:	06 9c       	mov	r12,r3
8000ac92:	e0 a0 05 98 	rcall	8000b7c2 <__mcmp>
8000ac96:	18 96       	mov	r6,r12
8000ac98:	0e 9c       	mov	r12,r7
8000ac9a:	02 9b       	mov	r11,r1
8000ac9c:	e0 a0 05 ac 	rcall	8000b7f4 <_Bfree>
8000aca0:	40 cc       	lddsp	r12,sp[0x30]
8000aca2:	ed ec 10 08 	or	r8,r6,r12
8000aca6:	c0 d1       	brne	8000acc0 <_dtoa_r+0xa3c>
8000aca8:	40 db       	lddsp	r11,sp[0x34]
8000acaa:	58 0b       	cp.w	r11,0
8000acac:	c0 a1       	brne	8000acc0 <_dtoa_r+0xa3c>
8000acae:	40 26       	lddsp	r6,sp[0x8]
8000acb0:	e0 40 00 39 	cp.w	r0,57
8000acb4:	c3 00       	breq	8000ad14 <_dtoa_r+0xa90>
8000acb6:	40 6a       	lddsp	r10,sp[0x18]
8000acb8:	58 0a       	cp.w	r10,0
8000acba:	e0 89 00 24 	brgt	8000ad02 <_dtoa_r+0xa7e>
8000acbe:	c2 f8       	rjmp	8000ad1c <_dtoa_r+0xa98>
8000acc0:	40 69       	lddsp	r9,sp[0x18]
8000acc2:	58 09       	cp.w	r9,0
8000acc4:	c0 85       	brlt	8000acd4 <_dtoa_r+0xa50>
8000acc6:	12 98       	mov	r8,r9
8000acc8:	40 cc       	lddsp	r12,sp[0x30]
8000acca:	18 48       	or	r8,r12
8000accc:	c1 d1       	brne	8000ad06 <_dtoa_r+0xa82>
8000acce:	40 db       	lddsp	r11,sp[0x34]
8000acd0:	58 0b       	cp.w	r11,0
8000acd2:	c1 a1       	brne	8000ad06 <_dtoa_r+0xa82>
8000acd4:	0c 99       	mov	r9,r6
8000acd6:	40 26       	lddsp	r6,sp[0x8]
8000acd8:	58 09       	cp.w	r9,0
8000acda:	e0 8a 00 21 	brle	8000ad1c <_dtoa_r+0xa98>
8000acde:	06 9b       	mov	r11,r3
8000ace0:	30 1a       	mov	r10,1
8000ace2:	0e 9c       	mov	r12,r7
8000ace4:	e0 a0 06 92 	rcall	8000ba08 <__lshift>
8000ace8:	04 9b       	mov	r11,r2
8000acea:	18 93       	mov	r3,r12
8000acec:	e0 a0 05 6b 	rcall	8000b7c2 <__mcmp>
8000acf0:	e0 89 00 06 	brgt	8000acfc <_dtoa_r+0xa78>
8000acf4:	c1 41       	brne	8000ad1c <_dtoa_r+0xa98>
8000acf6:	ed b0 00 00 	bld	r0,0x0
8000acfa:	c1 11       	brne	8000ad1c <_dtoa_r+0xa98>
8000acfc:	e0 40 00 39 	cp.w	r0,57
8000ad00:	c0 a0       	breq	8000ad14 <_dtoa_r+0xa90>
8000ad02:	2f f0       	sub	r0,-1
8000ad04:	c0 c8       	rjmp	8000ad1c <_dtoa_r+0xa98>
8000ad06:	58 06       	cp.w	r6,0
8000ad08:	e0 8a 00 0c 	brle	8000ad20 <_dtoa_r+0xa9c>
8000ad0c:	40 26       	lddsp	r6,sp[0x8]
8000ad0e:	e0 40 00 39 	cp.w	r0,57
8000ad12:	c0 41       	brne	8000ad1a <_dtoa_r+0xa96>
8000ad14:	33 98       	mov	r8,57
8000ad16:	0a c8       	st.b	r5++,r8
8000ad18:	c6 78       	rjmp	8000ade6 <_dtoa_r+0xb62>
8000ad1a:	2f f0       	sub	r0,-1
8000ad1c:	0a c0       	st.b	r5++,r0
8000ad1e:	c7 58       	rjmp	8000ae08 <_dtoa_r+0xb84>
8000ad20:	0a c0       	st.b	r5++,r0
8000ad22:	40 9a       	lddsp	r10,sp[0x24]
8000ad24:	40 e9       	lddsp	r9,sp[0x38]
8000ad26:	12 3a       	cp.w	r10,r9
8000ad28:	c4 30       	breq	8000adae <_dtoa_r+0xb2a>
8000ad2a:	06 9b       	mov	r11,r3
8000ad2c:	30 09       	mov	r9,0
8000ad2e:	30 aa       	mov	r10,10
8000ad30:	0e 9c       	mov	r12,r7
8000ad32:	e0 a0 07 37 	rcall	8000bba0 <__multadd>
8000ad36:	40 48       	lddsp	r8,sp[0x10]
8000ad38:	18 93       	mov	r3,r12
8000ad3a:	08 38       	cp.w	r8,r4
8000ad3c:	c0 91       	brne	8000ad4e <_dtoa_r+0xaca>
8000ad3e:	10 9b       	mov	r11,r8
8000ad40:	30 09       	mov	r9,0
8000ad42:	30 aa       	mov	r10,10
8000ad44:	0e 9c       	mov	r12,r7
8000ad46:	e0 a0 07 2d 	rcall	8000bba0 <__multadd>
8000ad4a:	50 4c       	stdsp	sp[0x10],r12
8000ad4c:	c0 e8       	rjmp	8000ad68 <_dtoa_r+0xae4>
8000ad4e:	40 4b       	lddsp	r11,sp[0x10]
8000ad50:	30 09       	mov	r9,0
8000ad52:	30 aa       	mov	r10,10
8000ad54:	0e 9c       	mov	r12,r7
8000ad56:	e0 a0 07 25 	rcall	8000bba0 <__multadd>
8000ad5a:	08 9b       	mov	r11,r4
8000ad5c:	50 4c       	stdsp	sp[0x10],r12
8000ad5e:	30 09       	mov	r9,0
8000ad60:	30 aa       	mov	r10,10
8000ad62:	0e 9c       	mov	r12,r7
8000ad64:	e0 a0 07 1e 	rcall	8000bba0 <__multadd>
8000ad68:	18 94       	mov	r4,r12
8000ad6a:	40 9c       	lddsp	r12,sp[0x24]
8000ad6c:	2f fc       	sub	r12,-1
8000ad6e:	50 9c       	stdsp	sp[0x24],r12
8000ad70:	c7 9b       	rjmp	8000ac62 <_dtoa_r+0x9de>
8000ad72:	30 18       	mov	r8,1
8000ad74:	06 90       	mov	r0,r3
8000ad76:	40 85       	lddsp	r5,sp[0x20]
8000ad78:	08 93       	mov	r3,r4
8000ad7a:	0c 94       	mov	r4,r6
8000ad7c:	10 96       	mov	r6,r8
8000ad7e:	04 9b       	mov	r11,r2
8000ad80:	00 9c       	mov	r12,r0
8000ad82:	fe b0 f9 f1 	rcall	8000a164 <quorem>
8000ad86:	2d 0c       	sub	r12,-48
8000ad88:	0a cc       	st.b	r5++,r12
8000ad8a:	02 36       	cp.w	r6,r1
8000ad8c:	c0 a4       	brge	8000ada0 <_dtoa_r+0xb1c>
8000ad8e:	00 9b       	mov	r11,r0
8000ad90:	30 09       	mov	r9,0
8000ad92:	30 aa       	mov	r10,10
8000ad94:	0e 9c       	mov	r12,r7
8000ad96:	2f f6       	sub	r6,-1
8000ad98:	e0 a0 07 04 	rcall	8000bba0 <__multadd>
8000ad9c:	18 90       	mov	r0,r12
8000ad9e:	cf 0b       	rjmp	8000ad7e <_dtoa_r+0xafa>
8000ada0:	08 96       	mov	r6,r4
8000ada2:	30 0b       	mov	r11,0
8000ada4:	06 94       	mov	r4,r3
8000ada6:	50 4b       	stdsp	sp[0x10],r11
8000ada8:	00 93       	mov	r3,r0
8000adaa:	18 90       	mov	r0,r12
8000adac:	c0 28       	rjmp	8000adb0 <_dtoa_r+0xb2c>
8000adae:	40 26       	lddsp	r6,sp[0x8]
8000adb0:	06 9b       	mov	r11,r3
8000adb2:	30 1a       	mov	r10,1
8000adb4:	0e 9c       	mov	r12,r7
8000adb6:	e0 a0 06 29 	rcall	8000ba08 <__lshift>
8000adba:	04 9b       	mov	r11,r2
8000adbc:	18 93       	mov	r3,r12
8000adbe:	e0 a0 05 02 	rcall	8000b7c2 <__mcmp>
8000adc2:	e0 89 00 12 	brgt	8000ade6 <_dtoa_r+0xb62>
8000adc6:	c1 b1       	brne	8000adfc <_dtoa_r+0xb78>
8000adc8:	e1 d0 c0 01 	bfextu	r0,r0,0x0,0x1
8000adcc:	c0 d1       	brne	8000ade6 <_dtoa_r+0xb62>
8000adce:	c1 78       	rjmp	8000adfc <_dtoa_r+0xb78>
8000add0:	40 89       	lddsp	r9,sp[0x20]
8000add2:	12 38       	cp.w	r8,r9
8000add4:	c0 30       	breq	8000adda <_dtoa_r+0xb56>
8000add6:	10 95       	mov	r5,r8
8000add8:	c0 88       	rjmp	8000ade8 <_dtoa_r+0xb64>
8000adda:	2f f6       	sub	r6,-1
8000addc:	50 66       	stdsp	sp[0x18],r6
8000adde:	33 18       	mov	r8,49
8000ade0:	40 8c       	lddsp	r12,sp[0x20]
8000ade2:	b8 88       	st.b	r12[0x0],r8
8000ade4:	c1 38       	rjmp	8000ae0a <_dtoa_r+0xb86>
8000ade6:	33 9a       	mov	r10,57
8000ade8:	0a 98       	mov	r8,r5
8000adea:	11 79       	ld.ub	r9,--r8
8000adec:	f4 09 18 00 	cp.b	r9,r10
8000adf0:	cf 00       	breq	8000add0 <_dtoa_r+0xb4c>
8000adf2:	2f f9       	sub	r9,-1
8000adf4:	b0 89       	st.b	r8[0x0],r9
8000adf6:	c0 98       	rjmp	8000ae08 <_dtoa_r+0xb84>
8000adf8:	10 95       	mov	r5,r8
8000adfa:	c0 28       	rjmp	8000adfe <_dtoa_r+0xb7a>
8000adfc:	33 09       	mov	r9,48
8000adfe:	0a 98       	mov	r8,r5
8000ae00:	11 7a       	ld.ub	r10,--r8
8000ae02:	f2 0a 18 00 	cp.b	r10,r9
8000ae06:	cf 90       	breq	8000adf8 <_dtoa_r+0xb74>
8000ae08:	50 66       	stdsp	sp[0x18],r6
8000ae0a:	04 9b       	mov	r11,r2
8000ae0c:	0e 9c       	mov	r12,r7
8000ae0e:	e0 a0 04 f3 	rcall	8000b7f4 <_Bfree>
8000ae12:	58 04       	cp.w	r4,0
8000ae14:	c1 20       	breq	8000ae38 <_dtoa_r+0xbb4>
8000ae16:	40 4b       	lddsp	r11,sp[0x10]
8000ae18:	08 3b       	cp.w	r11,r4
8000ae1a:	5f 19       	srne	r9
8000ae1c:	58 0b       	cp.w	r11,0
8000ae1e:	5f 18       	srne	r8
8000ae20:	f3 e8 00 08 	and	r8,r9,r8
8000ae24:	c0 40       	breq	8000ae2c <_dtoa_r+0xba8>
8000ae26:	0e 9c       	mov	r12,r7
8000ae28:	e0 a0 04 e6 	rcall	8000b7f4 <_Bfree>
8000ae2c:	08 9b       	mov	r11,r4
8000ae2e:	0e 9c       	mov	r12,r7
8000ae30:	e0 a0 04 e2 	rcall	8000b7f4 <_Bfree>
8000ae34:	c0 28       	rjmp	8000ae38 <_dtoa_r+0xbb4>
8000ae36:	50 66       	stdsp	sp[0x18],r6
8000ae38:	0e 9c       	mov	r12,r7
8000ae3a:	06 9b       	mov	r11,r3
8000ae3c:	e0 a0 04 dc 	rcall	8000b7f4 <_Bfree>
8000ae40:	30 08       	mov	r8,0
8000ae42:	aa 88       	st.b	r5[0x0],r8
8000ae44:	40 68       	lddsp	r8,sp[0x18]
8000ae46:	41 5a       	lddsp	r10,sp[0x54]
8000ae48:	2f f8       	sub	r8,-1
8000ae4a:	41 29       	lddsp	r9,sp[0x48]
8000ae4c:	95 08       	st.w	r10[0x0],r8
8000ae4e:	40 8c       	lddsp	r12,sp[0x20]
8000ae50:	58 09       	cp.w	r9,0
8000ae52:	fb f8 10 12 	ld.wne	r8,sp[0x48]
8000ae56:	f1 f5 1a 00 	st.wne	r8[0x0],r5
8000ae5a:	2e 6d       	sub	sp,-104
8000ae5c:	d8 32       	popm	r0-r7,pc
8000ae5e:	d7 03       	nop

8000ae60 <__errno>:
8000ae60:	e0 68 0a 3c 	mov	r8,2620
8000ae64:	70 0c       	ld.w	r12,r8[0x0]
8000ae66:	2f 4c       	sub	r12,-12
8000ae68:	5e fc       	retal	r12
8000ae6a:	d7 03       	nop

8000ae6c <_fflush_r>:
8000ae6c:	d4 21       	pushm	r4-r7,lr
8000ae6e:	16 97       	mov	r7,r11
8000ae70:	18 96       	mov	r6,r12
8000ae72:	76 48       	ld.w	r8,r11[0x10]
8000ae74:	58 08       	cp.w	r8,0
8000ae76:	c7 f0       	breq	8000af74 <_fflush_r+0x108>
8000ae78:	58 0c       	cp.w	r12,0
8000ae7a:	c0 50       	breq	8000ae84 <_fflush_r+0x18>
8000ae7c:	78 68       	ld.w	r8,r12[0x18]
8000ae7e:	58 08       	cp.w	r8,0
8000ae80:	c0 21       	brne	8000ae84 <_fflush_r+0x18>
8000ae82:	cc dc       	rcall	8000b01c <__sinit>
8000ae84:	fe c8 cd 3c 	sub	r8,pc,-12996
8000ae88:	10 37       	cp.w	r7,r8
8000ae8a:	c0 31       	brne	8000ae90 <_fflush_r+0x24>
8000ae8c:	6c 07       	ld.w	r7,r6[0x0]
8000ae8e:	c0 c8       	rjmp	8000aea6 <_fflush_r+0x3a>
8000ae90:	fe c8 cd 28 	sub	r8,pc,-13016
8000ae94:	10 37       	cp.w	r7,r8
8000ae96:	c0 31       	brne	8000ae9c <_fflush_r+0x30>
8000ae98:	6c 17       	ld.w	r7,r6[0x4]
8000ae9a:	c0 68       	rjmp	8000aea6 <_fflush_r+0x3a>
8000ae9c:	fe c8 cd 14 	sub	r8,pc,-13036
8000aea0:	10 37       	cp.w	r7,r8
8000aea2:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000aea6:	8e 6a       	ld.sh	r10,r7[0xc]
8000aea8:	14 98       	mov	r8,r10
8000aeaa:	ed ba 00 03 	bld	r10,0x3
8000aeae:	c4 20       	breq	8000af32 <_fflush_r+0xc6>
8000aeb0:	ab ba       	sbr	r10,0xb
8000aeb2:	ae 6a       	st.h	r7[0xc],r10
8000aeb4:	6e 18       	ld.w	r8,r7[0x4]
8000aeb6:	58 08       	cp.w	r8,0
8000aeb8:	e0 89 00 06 	brgt	8000aec4 <_fflush_r+0x58>
8000aebc:	6f 08       	ld.w	r8,r7[0x40]
8000aebe:	58 08       	cp.w	r8,0
8000aec0:	e0 8a 00 5a 	brle	8000af74 <_fflush_r+0x108>
8000aec4:	6e b8       	ld.w	r8,r7[0x2c]
8000aec6:	58 08       	cp.w	r8,0
8000aec8:	c5 60       	breq	8000af74 <_fflush_r+0x108>
8000aeca:	e2 1a 10 00 	andl	r10,0x1000,COH
8000aece:	c0 30       	breq	8000aed4 <_fflush_r+0x68>
8000aed0:	6f 55       	ld.w	r5,r7[0x54]
8000aed2:	c0 f8       	rjmp	8000aef0 <_fflush_r+0x84>
8000aed4:	30 19       	mov	r9,1
8000aed6:	6e 8b       	ld.w	r11,r7[0x20]
8000aed8:	0c 9c       	mov	r12,r6
8000aeda:	5d 18       	icall	r8
8000aedc:	18 95       	mov	r5,r12
8000aede:	5b fc       	cp.w	r12,-1
8000aee0:	c0 81       	brne	8000aef0 <_fflush_r+0x84>
8000aee2:	6c 38       	ld.w	r8,r6[0xc]
8000aee4:	59 d8       	cp.w	r8,29
8000aee6:	c4 70       	breq	8000af74 <_fflush_r+0x108>
8000aee8:	8e 68       	ld.sh	r8,r7[0xc]
8000aeea:	a7 a8       	sbr	r8,0x6
8000aeec:	ae 68       	st.h	r7[0xc],r8
8000aeee:	d8 22       	popm	r4-r7,pc
8000aef0:	8e 68       	ld.sh	r8,r7[0xc]
8000aef2:	ed b8 00 02 	bld	r8,0x2
8000aef6:	c0 91       	brne	8000af08 <_fflush_r+0x9c>
8000aef8:	6e 18       	ld.w	r8,r7[0x4]
8000aefa:	10 15       	sub	r5,r8
8000aefc:	6e d8       	ld.w	r8,r7[0x34]
8000aefe:	58 08       	cp.w	r8,0
8000af00:	ef f8 10 10 	ld.wne	r8,r7[0x40]
8000af04:	eb d8 e1 15 	subne	r5,r5,r8
8000af08:	6e b8       	ld.w	r8,r7[0x2c]
8000af0a:	0c 9c       	mov	r12,r6
8000af0c:	30 09       	mov	r9,0
8000af0e:	0a 9a       	mov	r10,r5
8000af10:	6e 8b       	ld.w	r11,r7[0x20]
8000af12:	5d 18       	icall	r8
8000af14:	8e 68       	ld.sh	r8,r7[0xc]
8000af16:	0a 3c       	cp.w	r12,r5
8000af18:	c2 61       	brne	8000af64 <_fflush_r+0xf8>
8000af1a:	ab d8       	cbr	r8,0xb
8000af1c:	30 0c       	mov	r12,0
8000af1e:	6e 49       	ld.w	r9,r7[0x10]
8000af20:	ae 68       	st.h	r7[0xc],r8
8000af22:	8f 1c       	st.w	r7[0x4],r12
8000af24:	8f 09       	st.w	r7[0x0],r9
8000af26:	ed b8 00 0c 	bld	r8,0xc
8000af2a:	c2 51       	brne	8000af74 <_fflush_r+0x108>
8000af2c:	ef 45 00 54 	st.w	r7[84],r5
8000af30:	d8 22       	popm	r4-r7,pc
8000af32:	6e 45       	ld.w	r5,r7[0x10]
8000af34:	58 05       	cp.w	r5,0
8000af36:	c1 f0       	breq	8000af74 <_fflush_r+0x108>
8000af38:	6e 04       	ld.w	r4,r7[0x0]
8000af3a:	f5 da c0 02 	bfextu	r10,r10,0x0,0x2
8000af3e:	8f 05       	st.w	r7[0x0],r5
8000af40:	f9 b8 01 00 	movne	r8,0
8000af44:	ef f8 00 05 	ld.weq	r8,r7[0x14]
8000af48:	0a 14       	sub	r4,r5
8000af4a:	8f 28       	st.w	r7[0x8],r8
8000af4c:	c1 18       	rjmp	8000af6e <_fflush_r+0x102>
8000af4e:	08 99       	mov	r9,r4
8000af50:	0a 9a       	mov	r10,r5
8000af52:	6e a8       	ld.w	r8,r7[0x28]
8000af54:	6e 8b       	ld.w	r11,r7[0x20]
8000af56:	0c 9c       	mov	r12,r6
8000af58:	5d 18       	icall	r8
8000af5a:	18 14       	sub	r4,r12
8000af5c:	58 0c       	cp.w	r12,0
8000af5e:	e0 89 00 07 	brgt	8000af6c <_fflush_r+0x100>
8000af62:	8e 68       	ld.sh	r8,r7[0xc]
8000af64:	a7 a8       	sbr	r8,0x6
8000af66:	3f fc       	mov	r12,-1
8000af68:	ae 68       	st.h	r7[0xc],r8
8000af6a:	d8 22       	popm	r4-r7,pc
8000af6c:	18 05       	add	r5,r12
8000af6e:	58 04       	cp.w	r4,0
8000af70:	fe 99 ff ef 	brgt	8000af4e <_fflush_r+0xe2>
8000af74:	d8 2a       	popm	r4-r7,pc,r12=0
8000af76:	d7 03       	nop

8000af78 <__sfp_lock_acquire>:
8000af78:	5e fc       	retal	r12

8000af7a <__sfp_lock_release>:
8000af7a:	5e fc       	retal	r12

8000af7c <_cleanup_r>:
8000af7c:	d4 01       	pushm	lr
8000af7e:	fe cb f0 ae 	sub	r11,pc,-3922
8000af82:	e0 a0 02 f7 	rcall	8000b570 <_fwalk>
8000af86:	d8 02       	popm	pc

8000af88 <__sfmoreglue>:
8000af88:	d4 21       	pushm	r4-r7,lr
8000af8a:	16 95       	mov	r5,r11
8000af8c:	f6 06 10 5c 	mul	r6,r11,92
8000af90:	ec cb ff f4 	sub	r11,r6,-12
8000af94:	fe b0 e2 88 	rcall	800074a4 <_malloc_r>
8000af98:	18 97       	mov	r7,r12
8000af9a:	c0 90       	breq	8000afac <__sfmoreglue+0x24>
8000af9c:	99 15       	st.w	r12[0x4],r5
8000af9e:	30 0b       	mov	r11,0
8000afa0:	2f 4c       	sub	r12,-12
8000afa2:	0c 9a       	mov	r10,r6
8000afa4:	8f 2c       	st.w	r7[0x8],r12
8000afa6:	8f 0b       	st.w	r7[0x0],r11
8000afa8:	fe b0 e5 3e 	rcall	80007a24 <memset>
8000afac:	0e 9c       	mov	r12,r7
8000afae:	d8 22       	popm	r4-r7,pc

8000afb0 <__sfp>:
8000afb0:	d4 21       	pushm	r4-r7,lr
8000afb2:	fe c8 ce 06 	sub	r8,pc,-12794
8000afb6:	18 96       	mov	r6,r12
8000afb8:	70 07       	ld.w	r7,r8[0x0]
8000afba:	6e 68       	ld.w	r8,r7[0x18]
8000afbc:	58 08       	cp.w	r8,0
8000afbe:	c0 31       	brne	8000afc4 <__sfp+0x14>
8000afc0:	0e 9c       	mov	r12,r7
8000afc2:	c2 dc       	rcall	8000b01c <__sinit>
8000afc4:	ee c7 ff 28 	sub	r7,r7,-216
8000afc8:	30 05       	mov	r5,0
8000afca:	6e 2c       	ld.w	r12,r7[0x8]
8000afcc:	6e 18       	ld.w	r8,r7[0x4]
8000afce:	c0 68       	rjmp	8000afda <__sfp+0x2a>
8000afd0:	98 69       	ld.sh	r9,r12[0xc]
8000afd2:	ea 09 19 00 	cp.h	r9,r5
8000afd6:	c1 10       	breq	8000aff8 <__sfp+0x48>
8000afd8:	2a 4c       	sub	r12,-92
8000afda:	20 18       	sub	r8,1
8000afdc:	cf a7       	brpl	8000afd0 <__sfp+0x20>
8000afde:	6e 08       	ld.w	r8,r7[0x0]
8000afe0:	58 08       	cp.w	r8,0
8000afe2:	c0 61       	brne	8000afee <__sfp+0x3e>
8000afe4:	30 4b       	mov	r11,4
8000afe6:	0c 9c       	mov	r12,r6
8000afe8:	cd 0f       	rcall	8000af88 <__sfmoreglue>
8000afea:	8f 0c       	st.w	r7[0x0],r12
8000afec:	c0 30       	breq	8000aff2 <__sfp+0x42>
8000afee:	6e 07       	ld.w	r7,r7[0x0]
8000aff0:	ce db       	rjmp	8000afca <__sfp+0x1a>
8000aff2:	30 c8       	mov	r8,12
8000aff4:	8d 38       	st.w	r6[0xc],r8
8000aff6:	d8 22       	popm	r4-r7,pc
8000aff8:	30 08       	mov	r8,0
8000affa:	f9 48 00 4c 	st.w	r12[76],r8
8000affe:	99 08       	st.w	r12[0x0],r8
8000b000:	99 28       	st.w	r12[0x8],r8
8000b002:	99 18       	st.w	r12[0x4],r8
8000b004:	99 48       	st.w	r12[0x10],r8
8000b006:	99 58       	st.w	r12[0x14],r8
8000b008:	99 68       	st.w	r12[0x18],r8
8000b00a:	99 d8       	st.w	r12[0x34],r8
8000b00c:	99 e8       	st.w	r12[0x38],r8
8000b00e:	f9 48 00 48 	st.w	r12[72],r8
8000b012:	3f f8       	mov	r8,-1
8000b014:	b8 78       	st.h	r12[0xe],r8
8000b016:	30 18       	mov	r8,1
8000b018:	b8 68       	st.h	r12[0xc],r8
8000b01a:	d8 22       	popm	r4-r7,pc

8000b01c <__sinit>:
8000b01c:	d4 21       	pushm	r4-r7,lr
8000b01e:	18 96       	mov	r6,r12
8000b020:	78 67       	ld.w	r7,r12[0x18]
8000b022:	58 07       	cp.w	r7,0
8000b024:	c4 91       	brne	8000b0b6 <__sinit+0x9a>
8000b026:	fe c8 00 aa 	sub	r8,pc,170
8000b02a:	30 15       	mov	r5,1
8000b02c:	99 a8       	st.w	r12[0x28],r8
8000b02e:	f9 47 00 d8 	st.w	r12[216],r7
8000b032:	f9 47 00 dc 	st.w	r12[220],r7
8000b036:	f9 47 00 e0 	st.w	r12[224],r7
8000b03a:	99 65       	st.w	r12[0x18],r5
8000b03c:	cb af       	rcall	8000afb0 <__sfp>
8000b03e:	8d 0c       	st.w	r6[0x0],r12
8000b040:	0c 9c       	mov	r12,r6
8000b042:	cb 7f       	rcall	8000afb0 <__sfp>
8000b044:	8d 1c       	st.w	r6[0x4],r12
8000b046:	0c 9c       	mov	r12,r6
8000b048:	cb 4f       	rcall	8000afb0 <__sfp>
8000b04a:	6c 09       	ld.w	r9,r6[0x0]
8000b04c:	30 48       	mov	r8,4
8000b04e:	93 07       	st.w	r9[0x0],r7
8000b050:	b2 68       	st.h	r9[0xc],r8
8000b052:	93 17       	st.w	r9[0x4],r7
8000b054:	93 27       	st.w	r9[0x8],r7
8000b056:	6c 18       	ld.w	r8,r6[0x4]
8000b058:	b2 77       	st.h	r9[0xe],r7
8000b05a:	93 47       	st.w	r9[0x10],r7
8000b05c:	93 57       	st.w	r9[0x14],r7
8000b05e:	93 67       	st.w	r9[0x18],r7
8000b060:	93 89       	st.w	r9[0x20],r9
8000b062:	91 07       	st.w	r8[0x0],r7
8000b064:	91 17       	st.w	r8[0x4],r7
8000b066:	91 27       	st.w	r8[0x8],r7
8000b068:	fe ce f3 24 	sub	lr,pc,-3292
8000b06c:	fe cb f3 54 	sub	r11,pc,-3244
8000b070:	93 9e       	st.w	r9[0x24],lr
8000b072:	93 ab       	st.w	r9[0x28],r11
8000b074:	fe ca f3 7c 	sub	r10,pc,-3204
8000b078:	fe c4 f3 88 	sub	r4,pc,-3192
8000b07c:	93 ba       	st.w	r9[0x2c],r10
8000b07e:	93 c4       	st.w	r9[0x30],r4
8000b080:	30 99       	mov	r9,9
8000b082:	b0 69       	st.h	r8[0xc],r9
8000b084:	b0 75       	st.h	r8[0xe],r5
8000b086:	91 c4       	st.w	r8[0x30],r4
8000b088:	91 47       	st.w	r8[0x10],r7
8000b08a:	91 57       	st.w	r8[0x14],r7
8000b08c:	91 67       	st.w	r8[0x18],r7
8000b08e:	91 88       	st.w	r8[0x20],r8
8000b090:	91 9e       	st.w	r8[0x24],lr
8000b092:	91 ab       	st.w	r8[0x28],r11
8000b094:	91 ba       	st.w	r8[0x2c],r10
8000b096:	8d 2c       	st.w	r6[0x8],r12
8000b098:	31 28       	mov	r8,18
8000b09a:	99 07       	st.w	r12[0x0],r7
8000b09c:	b8 68       	st.h	r12[0xc],r8
8000b09e:	99 17       	st.w	r12[0x4],r7
8000b0a0:	99 27       	st.w	r12[0x8],r7
8000b0a2:	30 28       	mov	r8,2
8000b0a4:	b8 78       	st.h	r12[0xe],r8
8000b0a6:	99 c4       	st.w	r12[0x30],r4
8000b0a8:	99 67       	st.w	r12[0x18],r7
8000b0aa:	99 9e       	st.w	r12[0x24],lr
8000b0ac:	99 ab       	st.w	r12[0x28],r11
8000b0ae:	99 ba       	st.w	r12[0x2c],r10
8000b0b0:	99 47       	st.w	r12[0x10],r7
8000b0b2:	99 57       	st.w	r12[0x14],r7
8000b0b4:	99 8c       	st.w	r12[0x20],r12
8000b0b6:	d8 22       	popm	r4-r7,pc

8000b0b8 <_malloc_trim_r>:
8000b0b8:	d4 21       	pushm	r4-r7,lr
8000b0ba:	16 95       	mov	r5,r11
8000b0bc:	18 97       	mov	r7,r12
8000b0be:	fe b0 d7 ad 	rcall	80006018 <__malloc_lock>
8000b0c2:	e0 64 05 3c 	mov	r4,1340
8000b0c6:	68 28       	ld.w	r8,r4[0x8]
8000b0c8:	70 16       	ld.w	r6,r8[0x4]
8000b0ca:	e0 16 ff fc 	andl	r6,0xfffc
8000b0ce:	ec c8 ff 91 	sub	r8,r6,-111
8000b0d2:	f0 05 01 05 	sub	r5,r8,r5
8000b0d6:	e0 15 ff 80 	andl	r5,0xff80
8000b0da:	ea c5 00 80 	sub	r5,r5,128
8000b0de:	e0 45 00 7f 	cp.w	r5,127
8000b0e2:	e0 8a 00 25 	brle	8000b12c <_malloc_trim_r+0x74>
8000b0e6:	30 0b       	mov	r11,0
8000b0e8:	0e 9c       	mov	r12,r7
8000b0ea:	fe b0 e6 05 	rcall	80007cf4 <_sbrk_r>
8000b0ee:	68 28       	ld.w	r8,r4[0x8]
8000b0f0:	0c 08       	add	r8,r6
8000b0f2:	10 3c       	cp.w	r12,r8
8000b0f4:	c1 c1       	brne	8000b12c <_malloc_trim_r+0x74>
8000b0f6:	ea 0b 11 00 	rsub	r11,r5,0
8000b0fa:	0e 9c       	mov	r12,r7
8000b0fc:	fe b0 e5 fc 	rcall	80007cf4 <_sbrk_r>
8000b100:	5b fc       	cp.w	r12,-1
8000b102:	c1 91       	brne	8000b134 <_malloc_trim_r+0x7c>
8000b104:	30 0b       	mov	r11,0
8000b106:	0e 9c       	mov	r12,r7
8000b108:	fe b0 e5 f6 	rcall	80007cf4 <_sbrk_r>
8000b10c:	68 28       	ld.w	r8,r4[0x8]
8000b10e:	f8 08 01 09 	sub	r9,r12,r8
8000b112:	58 f9       	cp.w	r9,15
8000b114:	e0 8a 00 0c 	brle	8000b12c <_malloc_trim_r+0x74>
8000b118:	a1 a9       	sbr	r9,0x0
8000b11a:	91 19       	st.w	r8[0x4],r9
8000b11c:	e0 68 09 48 	mov	r8,2376
8000b120:	70 09       	ld.w	r9,r8[0x0]
8000b122:	e0 68 0d 6c 	mov	r8,3436
8000b126:	f8 09 01 09 	sub	r9,r12,r9
8000b12a:	91 09       	st.w	r8[0x0],r9
8000b12c:	0e 9c       	mov	r12,r7
8000b12e:	fe b0 d7 7b 	rcall	80006024 <__malloc_unlock>
8000b132:	d8 2a       	popm	r4-r7,pc,r12=0
8000b134:	68 28       	ld.w	r8,r4[0x8]
8000b136:	0a 16       	sub	r6,r5
8000b138:	a1 a6       	sbr	r6,0x0
8000b13a:	91 16       	st.w	r8[0x4],r6
8000b13c:	e0 68 0d 6c 	mov	r8,3436
8000b140:	70 09       	ld.w	r9,r8[0x0]
8000b142:	0a 19       	sub	r9,r5
8000b144:	0e 9c       	mov	r12,r7
8000b146:	91 09       	st.w	r8[0x0],r9
8000b148:	fe b0 d7 6e 	rcall	80006024 <__malloc_unlock>
8000b14c:	da 2a       	popm	r4-r7,pc,r12=1
8000b14e:	d7 03       	nop

8000b150 <_free_r>:
8000b150:	d4 21       	pushm	r4-r7,lr
8000b152:	16 96       	mov	r6,r11
8000b154:	18 97       	mov	r7,r12
8000b156:	58 0b       	cp.w	r11,0
8000b158:	e0 80 00 c0 	breq	8000b2d8 <_free_r+0x188>
8000b15c:	fe b0 d7 5e 	rcall	80006018 <__malloc_lock>
8000b160:	20 86       	sub	r6,8
8000b162:	e0 6a 05 3c 	mov	r10,1340
8000b166:	6c 18       	ld.w	r8,r6[0x4]
8000b168:	74 2e       	ld.w	lr,r10[0x8]
8000b16a:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
8000b16e:	a1 c8       	cbr	r8,0x0
8000b170:	ec 08 00 09 	add	r9,r6,r8
8000b174:	72 1b       	ld.w	r11,r9[0x4]
8000b176:	e0 1b ff fc 	andl	r11,0xfffc
8000b17a:	1c 39       	cp.w	r9,lr
8000b17c:	c1 e1       	brne	8000b1b8 <_free_r+0x68>
8000b17e:	f6 08 00 08 	add	r8,r11,r8
8000b182:	58 0c       	cp.w	r12,0
8000b184:	c0 81       	brne	8000b194 <_free_r+0x44>
8000b186:	6c 09       	ld.w	r9,r6[0x0]
8000b188:	12 16       	sub	r6,r9
8000b18a:	12 08       	add	r8,r9
8000b18c:	6c 3b       	ld.w	r11,r6[0xc]
8000b18e:	6c 29       	ld.w	r9,r6[0x8]
8000b190:	97 29       	st.w	r11[0x8],r9
8000b192:	93 3b       	st.w	r9[0xc],r11
8000b194:	10 99       	mov	r9,r8
8000b196:	95 26       	st.w	r10[0x8],r6
8000b198:	a1 a9       	sbr	r9,0x0
8000b19a:	8d 19       	st.w	r6[0x4],r9
8000b19c:	e0 69 09 44 	mov	r9,2372
8000b1a0:	72 09       	ld.w	r9,r9[0x0]
8000b1a2:	12 38       	cp.w	r8,r9
8000b1a4:	c0 63       	brcs	8000b1b0 <_free_r+0x60>
8000b1a6:	e0 68 0d 68 	mov	r8,3432
8000b1aa:	0e 9c       	mov	r12,r7
8000b1ac:	70 0b       	ld.w	r11,r8[0x0]
8000b1ae:	c8 5f       	rcall	8000b0b8 <_malloc_trim_r>
8000b1b0:	0e 9c       	mov	r12,r7
8000b1b2:	fe b0 d7 39 	rcall	80006024 <__malloc_unlock>
8000b1b6:	d8 22       	popm	r4-r7,pc
8000b1b8:	93 1b       	st.w	r9[0x4],r11
8000b1ba:	58 0c       	cp.w	r12,0
8000b1bc:	c0 30       	breq	8000b1c2 <_free_r+0x72>
8000b1be:	30 0c       	mov	r12,0
8000b1c0:	c1 08       	rjmp	8000b1e0 <_free_r+0x90>
8000b1c2:	6c 0e       	ld.w	lr,r6[0x0]
8000b1c4:	f4 c5 ff f8 	sub	r5,r10,-8
8000b1c8:	1c 16       	sub	r6,lr
8000b1ca:	1c 08       	add	r8,lr
8000b1cc:	6c 2e       	ld.w	lr,r6[0x8]
8000b1ce:	0a 3e       	cp.w	lr,r5
8000b1d0:	f9 bc 00 01 	moveq	r12,1
8000b1d4:	ed f5 10 03 	ld.wne	r5,r6[0xc]
8000b1d8:	eb fe 1a 02 	st.wne	r5[0x8],lr
8000b1dc:	fd f5 1a 03 	st.wne	lr[0xc],r5
8000b1e0:	f2 0b 00 0e 	add	lr,r9,r11
8000b1e4:	7c 1e       	ld.w	lr,lr[0x4]
8000b1e6:	ed be 00 00 	bld	lr,0x0
8000b1ea:	c1 40       	breq	8000b212 <_free_r+0xc2>
8000b1ec:	16 08       	add	r8,r11
8000b1ee:	58 0c       	cp.w	r12,0
8000b1f0:	c0 d1       	brne	8000b20a <_free_r+0xba>
8000b1f2:	e0 6e 05 3c 	mov	lr,1340
8000b1f6:	72 2b       	ld.w	r11,r9[0x8]
8000b1f8:	2f 8e       	sub	lr,-8
8000b1fa:	1c 3b       	cp.w	r11,lr
8000b1fc:	c0 71       	brne	8000b20a <_free_r+0xba>
8000b1fe:	97 36       	st.w	r11[0xc],r6
8000b200:	97 26       	st.w	r11[0x8],r6
8000b202:	8d 2b       	st.w	r6[0x8],r11
8000b204:	8d 3b       	st.w	r6[0xc],r11
8000b206:	30 1c       	mov	r12,1
8000b208:	c0 58       	rjmp	8000b212 <_free_r+0xc2>
8000b20a:	72 2b       	ld.w	r11,r9[0x8]
8000b20c:	72 39       	ld.w	r9,r9[0xc]
8000b20e:	93 2b       	st.w	r9[0x8],r11
8000b210:	97 39       	st.w	r11[0xc],r9
8000b212:	10 99       	mov	r9,r8
8000b214:	ec 08 09 08 	st.w	r6[r8],r8
8000b218:	a1 a9       	sbr	r9,0x0
8000b21a:	8d 19       	st.w	r6[0x4],r9
8000b21c:	58 0c       	cp.w	r12,0
8000b21e:	c5 a1       	brne	8000b2d2 <_free_r+0x182>
8000b220:	e0 48 01 ff 	cp.w	r8,511
8000b224:	e0 8b 00 13 	brhi	8000b24a <_free_r+0xfa>
8000b228:	a3 98       	lsr	r8,0x3
8000b22a:	f4 08 00 39 	add	r9,r10,r8<<0x3
8000b22e:	72 2b       	ld.w	r11,r9[0x8]
8000b230:	8d 39       	st.w	r6[0xc],r9
8000b232:	8d 2b       	st.w	r6[0x8],r11
8000b234:	97 36       	st.w	r11[0xc],r6
8000b236:	93 26       	st.w	r9[0x8],r6
8000b238:	a3 48       	asr	r8,0x2
8000b23a:	74 19       	ld.w	r9,r10[0x4]
8000b23c:	30 1b       	mov	r11,1
8000b23e:	f6 08 09 48 	lsl	r8,r11,r8
8000b242:	f3 e8 10 08 	or	r8,r9,r8
8000b246:	95 18       	st.w	r10[0x4],r8
8000b248:	c4 58       	rjmp	8000b2d2 <_free_r+0x182>
8000b24a:	f0 0b 16 09 	lsr	r11,r8,0x9
8000b24e:	58 4b       	cp.w	r11,4
8000b250:	e0 8b 00 06 	brhi	8000b25c <_free_r+0x10c>
8000b254:	f0 0b 16 06 	lsr	r11,r8,0x6
8000b258:	2c 8b       	sub	r11,-56
8000b25a:	c2 08       	rjmp	8000b29a <_free_r+0x14a>
8000b25c:	59 4b       	cp.w	r11,20
8000b25e:	e0 8b 00 04 	brhi	8000b266 <_free_r+0x116>
8000b262:	2a 5b       	sub	r11,-91
8000b264:	c1 b8       	rjmp	8000b29a <_free_r+0x14a>
8000b266:	e0 4b 00 54 	cp.w	r11,84
8000b26a:	e0 8b 00 06 	brhi	8000b276 <_free_r+0x126>
8000b26e:	f0 0b 16 0c 	lsr	r11,r8,0xc
8000b272:	29 2b       	sub	r11,-110
8000b274:	c1 38       	rjmp	8000b29a <_free_r+0x14a>
8000b276:	e0 4b 01 54 	cp.w	r11,340
8000b27a:	e0 8b 00 06 	brhi	8000b286 <_free_r+0x136>
8000b27e:	f0 0b 16 0f 	lsr	r11,r8,0xf
8000b282:	28 9b       	sub	r11,-119
8000b284:	c0 b8       	rjmp	8000b29a <_free_r+0x14a>
8000b286:	e0 4b 05 54 	cp.w	r11,1364
8000b28a:	e0 88 00 05 	brls	8000b294 <_free_r+0x144>
8000b28e:	37 eb       	mov	r11,126
8000b290:	c0 58       	rjmp	8000b29a <_free_r+0x14a>
8000b292:	d7 03       	nop
8000b294:	f0 0b 16 12 	lsr	r11,r8,0x12
8000b298:	28 4b       	sub	r11,-124
8000b29a:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
8000b29e:	78 29       	ld.w	r9,r12[0x8]
8000b2a0:	18 39       	cp.w	r9,r12
8000b2a2:	c0 e1       	brne	8000b2be <_free_r+0x16e>
8000b2a4:	74 18       	ld.w	r8,r10[0x4]
8000b2a6:	a3 4b       	asr	r11,0x2
8000b2a8:	30 1c       	mov	r12,1
8000b2aa:	f8 0b 09 4b 	lsl	r11,r12,r11
8000b2ae:	f1 eb 10 0b 	or	r11,r8,r11
8000b2b2:	12 98       	mov	r8,r9
8000b2b4:	95 1b       	st.w	r10[0x4],r11
8000b2b6:	c0 a8       	rjmp	8000b2ca <_free_r+0x17a>
8000b2b8:	72 29       	ld.w	r9,r9[0x8]
8000b2ba:	18 39       	cp.w	r9,r12
8000b2bc:	c0 60       	breq	8000b2c8 <_free_r+0x178>
8000b2be:	72 1a       	ld.w	r10,r9[0x4]
8000b2c0:	e0 1a ff fc 	andl	r10,0xfffc
8000b2c4:	14 38       	cp.w	r8,r10
8000b2c6:	cf 93       	brcs	8000b2b8 <_free_r+0x168>
8000b2c8:	72 38       	ld.w	r8,r9[0xc]
8000b2ca:	8d 38       	st.w	r6[0xc],r8
8000b2cc:	8d 29       	st.w	r6[0x8],r9
8000b2ce:	93 36       	st.w	r9[0xc],r6
8000b2d0:	91 26       	st.w	r8[0x8],r6
8000b2d2:	0e 9c       	mov	r12,r7
8000b2d4:	fe b0 d6 a8 	rcall	80006024 <__malloc_unlock>
8000b2d8:	d8 22       	popm	r4-r7,pc
8000b2da:	d7 03       	nop

8000b2dc <__sfvwrite_r>:
8000b2dc:	d4 31       	pushm	r0-r7,lr
8000b2de:	20 3d       	sub	sp,12
8000b2e0:	14 94       	mov	r4,r10
8000b2e2:	18 95       	mov	r5,r12
8000b2e4:	16 97       	mov	r7,r11
8000b2e6:	74 28       	ld.w	r8,r10[0x8]
8000b2e8:	58 08       	cp.w	r8,0
8000b2ea:	e0 80 01 40 	breq	8000b56a <__sfvwrite_r+0x28e>
8000b2ee:	96 68       	ld.sh	r8,r11[0xc]
8000b2f0:	ed b8 00 03 	bld	r8,0x3
8000b2f4:	c0 41       	brne	8000b2fc <__sfvwrite_r+0x20>
8000b2f6:	76 48       	ld.w	r8,r11[0x10]
8000b2f8:	58 08       	cp.w	r8,0
8000b2fa:	c0 c1       	brne	8000b312 <__sfvwrite_r+0x36>
8000b2fc:	0e 9b       	mov	r11,r7
8000b2fe:	0a 9c       	mov	r12,r5
8000b300:	fe b0 f6 c4 	rcall	8000a088 <__swsetup_r>
8000b304:	c0 70       	breq	8000b312 <__sfvwrite_r+0x36>
8000b306:	8e 68       	ld.sh	r8,r7[0xc]
8000b308:	a7 a8       	sbr	r8,0x6
8000b30a:	ae 68       	st.h	r7[0xc],r8
8000b30c:	30 98       	mov	r8,9
8000b30e:	8b 38       	st.w	r5[0xc],r8
8000b310:	c2 b9       	rjmp	8000b566 <__sfvwrite_r+0x28a>
8000b312:	8e 63       	ld.sh	r3,r7[0xc]
8000b314:	68 00       	ld.w	r0,r4[0x0]
8000b316:	06 96       	mov	r6,r3
8000b318:	e2 16 00 02 	andl	r6,0x2,COH
8000b31c:	c2 10       	breq	8000b35e <__sfvwrite_r+0x82>
8000b31e:	30 03       	mov	r3,0
8000b320:	e0 62 04 00 	mov	r2,1024
8000b324:	06 96       	mov	r6,r3
8000b326:	c0 48       	rjmp	8000b32e <__sfvwrite_r+0x52>
8000b328:	60 03       	ld.w	r3,r0[0x0]
8000b32a:	60 16       	ld.w	r6,r0[0x4]
8000b32c:	2f 80       	sub	r0,-8
8000b32e:	58 06       	cp.w	r6,0
8000b330:	cf c0       	breq	8000b328 <__sfvwrite_r+0x4c>
8000b332:	e0 46 04 00 	cp.w	r6,1024
8000b336:	ec 09 17 80 	movls	r9,r6
8000b33a:	e4 09 17 b0 	movhi	r9,r2
8000b33e:	06 9a       	mov	r10,r3
8000b340:	6e a8       	ld.w	r8,r7[0x28]
8000b342:	6e 8b       	ld.w	r11,r7[0x20]
8000b344:	0a 9c       	mov	r12,r5
8000b346:	5d 18       	icall	r8
8000b348:	18 16       	sub	r6,r12
8000b34a:	58 0c       	cp.w	r12,0
8000b34c:	e0 8a 01 0a 	brle	8000b560 <__sfvwrite_r+0x284>
8000b350:	68 28       	ld.w	r8,r4[0x8]
8000b352:	18 18       	sub	r8,r12
8000b354:	89 28       	st.w	r4[0x8],r8
8000b356:	e0 80 01 0a 	breq	8000b56a <__sfvwrite_r+0x28e>
8000b35a:	18 03       	add	r3,r12
8000b35c:	ce 9b       	rjmp	8000b32e <__sfvwrite_r+0x52>
8000b35e:	e7 d3 c0 01 	bfextu	r3,r3,0x0,0x1
8000b362:	c0 70       	breq	8000b370 <__sfvwrite_r+0x94>
8000b364:	50 06       	stdsp	sp[0x0],r6
8000b366:	0c 93       	mov	r3,r6
8000b368:	0c 91       	mov	r1,r6
8000b36a:	50 15       	stdsp	sp[0x4],r5
8000b36c:	08 92       	mov	r2,r4
8000b36e:	c9 c8       	rjmp	8000b4a6 <__sfvwrite_r+0x1ca>
8000b370:	06 96       	mov	r6,r3
8000b372:	08 91       	mov	r1,r4
8000b374:	c0 48       	rjmp	8000b37c <__sfvwrite_r+0xa0>
8000b376:	60 03       	ld.w	r3,r0[0x0]
8000b378:	60 16       	ld.w	r6,r0[0x4]
8000b37a:	2f 80       	sub	r0,-8
8000b37c:	58 06       	cp.w	r6,0
8000b37e:	cf c0       	breq	8000b376 <__sfvwrite_r+0x9a>
8000b380:	8e 68       	ld.sh	r8,r7[0xc]
8000b382:	6e 24       	ld.w	r4,r7[0x8]
8000b384:	10 99       	mov	r9,r8
8000b386:	e2 19 02 00 	andl	r9,0x200,COH
8000b38a:	c5 50       	breq	8000b434 <__sfvwrite_r+0x158>
8000b38c:	08 36       	cp.w	r6,r4
8000b38e:	c4 43       	brcs	8000b416 <__sfvwrite_r+0x13a>
8000b390:	10 99       	mov	r9,r8
8000b392:	e2 19 04 80 	andl	r9,0x480,COH
8000b396:	c4 00       	breq	8000b416 <__sfvwrite_r+0x13a>
8000b398:	6e 4b       	ld.w	r11,r7[0x10]
8000b39a:	6e 09       	ld.w	r9,r7[0x0]
8000b39c:	16 19       	sub	r9,r11
8000b39e:	50 09       	stdsp	sp[0x0],r9
8000b3a0:	6e 59       	ld.w	r9,r7[0x14]
8000b3a2:	10 9c       	mov	r12,r8
8000b3a4:	f2 09 00 1a 	add	r10,r9,r9<<0x1
8000b3a8:	30 28       	mov	r8,2
8000b3aa:	f4 08 0c 08 	divs	r8,r10,r8
8000b3ae:	fa e9 00 04 	st.d	sp[4],r8
8000b3b2:	10 94       	mov	r4,r8
8000b3b4:	40 09       	lddsp	r9,sp[0x0]
8000b3b6:	e2 1c 04 00 	andl	r12,0x400,COH
8000b3ba:	2f f9       	sub	r9,-1
8000b3bc:	0c 09       	add	r9,r6
8000b3be:	12 38       	cp.w	r8,r9
8000b3c0:	f2 04 17 30 	movlo	r4,r9
8000b3c4:	58 0c       	cp.w	r12,0
8000b3c6:	c1 10       	breq	8000b3e8 <__sfvwrite_r+0x10c>
8000b3c8:	08 9b       	mov	r11,r4
8000b3ca:	0a 9c       	mov	r12,r5
8000b3cc:	fe b0 e0 6c 	rcall	800074a4 <_malloc_r>
8000b3d0:	18 92       	mov	r2,r12
8000b3d2:	c1 40       	breq	8000b3fa <__sfvwrite_r+0x11e>
8000b3d4:	40 0a       	lddsp	r10,sp[0x0]
8000b3d6:	6e 4b       	ld.w	r11,r7[0x10]
8000b3d8:	fe b0 e2 82 	rcall	800078dc <memcpy>
8000b3dc:	8e 68       	ld.sh	r8,r7[0xc]
8000b3de:	e0 18 fb 7f 	andl	r8,0xfb7f
8000b3e2:	a7 b8       	sbr	r8,0x7
8000b3e4:	ae 68       	st.h	r7[0xc],r8
8000b3e6:	c0 d8       	rjmp	8000b400 <__sfvwrite_r+0x124>
8000b3e8:	08 9a       	mov	r10,r4
8000b3ea:	0a 9c       	mov	r12,r5
8000b3ec:	fe b0 e3 24 	rcall	80007a34 <_realloc_r>
8000b3f0:	18 92       	mov	r2,r12
8000b3f2:	c0 71       	brne	8000b400 <__sfvwrite_r+0x124>
8000b3f4:	6e 4b       	ld.w	r11,r7[0x10]
8000b3f6:	0a 9c       	mov	r12,r5
8000b3f8:	ca ce       	rcall	8000b150 <_free_r>
8000b3fa:	30 c8       	mov	r8,12
8000b3fc:	8b 38       	st.w	r5[0xc],r8
8000b3fe:	cb 18       	rjmp	8000b560 <__sfvwrite_r+0x284>
8000b400:	40 0a       	lddsp	r10,sp[0x0]
8000b402:	40 09       	lddsp	r9,sp[0x0]
8000b404:	e8 0a 01 0a 	sub	r10,r4,r10
8000b408:	e4 09 00 08 	add	r8,r2,r9
8000b40c:	8f 54       	st.w	r7[0x14],r4
8000b40e:	8f 2a       	st.w	r7[0x8],r10
8000b410:	8f 08       	st.w	r7[0x0],r8
8000b412:	8f 42       	st.w	r7[0x10],r2
8000b414:	0c 94       	mov	r4,r6
8000b416:	08 36       	cp.w	r6,r4
8000b418:	ec 04 17 30 	movlo	r4,r6
8000b41c:	06 9b       	mov	r11,r3
8000b41e:	08 9a       	mov	r10,r4
8000b420:	6e 0c       	ld.w	r12,r7[0x0]
8000b422:	c3 ad       	rcall	8000b696 <memmove>
8000b424:	6e 08       	ld.w	r8,r7[0x0]
8000b426:	08 08       	add	r8,r4
8000b428:	8f 08       	st.w	r7[0x0],r8
8000b42a:	6e 28       	ld.w	r8,r7[0x8]
8000b42c:	08 18       	sub	r8,r4
8000b42e:	0c 94       	mov	r4,r6
8000b430:	8f 28       	st.w	r7[0x8],r8
8000b432:	c2 e8       	rjmp	8000b48e <__sfvwrite_r+0x1b2>
8000b434:	08 36       	cp.w	r6,r4
8000b436:	5f ba       	srhi	r10
8000b438:	6e 0c       	ld.w	r12,r7[0x0]
8000b43a:	6e 48       	ld.w	r8,r7[0x10]
8000b43c:	10 3c       	cp.w	r12,r8
8000b43e:	5f b8       	srhi	r8
8000b440:	f5 e8 00 08 	and	r8,r10,r8
8000b444:	f2 08 18 00 	cp.b	r8,r9
8000b448:	c0 d0       	breq	8000b462 <__sfvwrite_r+0x186>
8000b44a:	06 9b       	mov	r11,r3
8000b44c:	08 9a       	mov	r10,r4
8000b44e:	c2 4d       	rcall	8000b696 <memmove>
8000b450:	6e 08       	ld.w	r8,r7[0x0]
8000b452:	08 08       	add	r8,r4
8000b454:	0e 9b       	mov	r11,r7
8000b456:	8f 08       	st.w	r7[0x0],r8
8000b458:	0a 9c       	mov	r12,r5
8000b45a:	fe b0 fd 09 	rcall	8000ae6c <_fflush_r>
8000b45e:	c1 80       	breq	8000b48e <__sfvwrite_r+0x1b2>
8000b460:	c8 08       	rjmp	8000b560 <__sfvwrite_r+0x284>
8000b462:	6e 59       	ld.w	r9,r7[0x14]
8000b464:	12 36       	cp.w	r6,r9
8000b466:	c0 a3       	brcs	8000b47a <__sfvwrite_r+0x19e>
8000b468:	6e a8       	ld.w	r8,r7[0x28]
8000b46a:	06 9a       	mov	r10,r3
8000b46c:	6e 8b       	ld.w	r11,r7[0x20]
8000b46e:	0a 9c       	mov	r12,r5
8000b470:	5d 18       	icall	r8
8000b472:	18 94       	mov	r4,r12
8000b474:	e0 89 00 0d 	brgt	8000b48e <__sfvwrite_r+0x1b2>
8000b478:	c7 48       	rjmp	8000b560 <__sfvwrite_r+0x284>
8000b47a:	0c 9a       	mov	r10,r6
8000b47c:	06 9b       	mov	r11,r3
8000b47e:	c0 cd       	rcall	8000b696 <memmove>
8000b480:	6e 08       	ld.w	r8,r7[0x0]
8000b482:	0c 08       	add	r8,r6
8000b484:	0c 94       	mov	r4,r6
8000b486:	8f 08       	st.w	r7[0x0],r8
8000b488:	6e 28       	ld.w	r8,r7[0x8]
8000b48a:	0c 18       	sub	r8,r6
8000b48c:	8f 28       	st.w	r7[0x8],r8
8000b48e:	62 28       	ld.w	r8,r1[0x8]
8000b490:	08 18       	sub	r8,r4
8000b492:	83 28       	st.w	r1[0x8],r8
8000b494:	c6 b0       	breq	8000b56a <__sfvwrite_r+0x28e>
8000b496:	08 16       	sub	r6,r4
8000b498:	08 03       	add	r3,r4
8000b49a:	c7 1b       	rjmp	8000b37c <__sfvwrite_r+0xa0>
8000b49c:	60 03       	ld.w	r3,r0[0x0]
8000b49e:	60 11       	ld.w	r1,r0[0x4]
8000b4a0:	30 08       	mov	r8,0
8000b4a2:	2f 80       	sub	r0,-8
8000b4a4:	50 08       	stdsp	sp[0x0],r8
8000b4a6:	58 01       	cp.w	r1,0
8000b4a8:	cf a0       	breq	8000b49c <__sfvwrite_r+0x1c0>
8000b4aa:	40 0a       	lddsp	r10,sp[0x0]
8000b4ac:	58 0a       	cp.w	r10,0
8000b4ae:	c1 41       	brne	8000b4d6 <__sfvwrite_r+0x1fa>
8000b4b0:	e2 c6 ff ff 	sub	r6,r1,-1
8000b4b4:	02 9a       	mov	r10,r1
8000b4b6:	30 ab       	mov	r11,10
8000b4b8:	06 9c       	mov	r12,r3
8000b4ba:	ce 3c       	rcall	8000b680 <memchr>
8000b4bc:	f8 c8 ff ff 	sub	r8,r12,-1
8000b4c0:	58 0c       	cp.w	r12,0
8000b4c2:	f1 d3 e1 16 	subne	r6,r8,r3
8000b4c6:	f9 b9 01 01 	movne	r9,1
8000b4ca:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000b4ce:	f9 b8 00 01 	moveq	r8,1
8000b4d2:	fb f8 0a 00 	st.weq	sp[0x0],r8
8000b4d6:	02 36       	cp.w	r6,r1
8000b4d8:	ec 04 17 80 	movls	r4,r6
8000b4dc:	e2 04 17 b0 	movhi	r4,r1
8000b4e0:	6e 59       	ld.w	r9,r7[0x14]
8000b4e2:	6e 25       	ld.w	r5,r7[0x8]
8000b4e4:	f2 05 00 05 	add	r5,r9,r5
8000b4e8:	0a 34       	cp.w	r4,r5
8000b4ea:	5f 9a       	srgt	r10
8000b4ec:	6e 0c       	ld.w	r12,r7[0x0]
8000b4ee:	6e 48       	ld.w	r8,r7[0x10]
8000b4f0:	10 3c       	cp.w	r12,r8
8000b4f2:	5f b8       	srhi	r8
8000b4f4:	f5 e8 00 08 	and	r8,r10,r8
8000b4f8:	30 0a       	mov	r10,0
8000b4fa:	f4 08 18 00 	cp.b	r8,r10
8000b4fe:	c0 d0       	breq	8000b518 <__sfvwrite_r+0x23c>
8000b500:	06 9b       	mov	r11,r3
8000b502:	0a 9a       	mov	r10,r5
8000b504:	cc 9c       	rcall	8000b696 <memmove>
8000b506:	6e 08       	ld.w	r8,r7[0x0]
8000b508:	0a 08       	add	r8,r5
8000b50a:	0e 9b       	mov	r11,r7
8000b50c:	8f 08       	st.w	r7[0x0],r8
8000b50e:	40 1c       	lddsp	r12,sp[0x4]
8000b510:	fe b0 fc ae 	rcall	8000ae6c <_fflush_r>
8000b514:	c1 70       	breq	8000b542 <__sfvwrite_r+0x266>
8000b516:	c2 58       	rjmp	8000b560 <__sfvwrite_r+0x284>
8000b518:	12 34       	cp.w	r4,r9
8000b51a:	c0 a5       	brlt	8000b52e <__sfvwrite_r+0x252>
8000b51c:	6e a8       	ld.w	r8,r7[0x28]
8000b51e:	06 9a       	mov	r10,r3
8000b520:	6e 8b       	ld.w	r11,r7[0x20]
8000b522:	40 1c       	lddsp	r12,sp[0x4]
8000b524:	5d 18       	icall	r8
8000b526:	18 95       	mov	r5,r12
8000b528:	e0 89 00 0d 	brgt	8000b542 <__sfvwrite_r+0x266>
8000b52c:	c1 a8       	rjmp	8000b560 <__sfvwrite_r+0x284>
8000b52e:	08 9a       	mov	r10,r4
8000b530:	06 9b       	mov	r11,r3
8000b532:	cb 2c       	rcall	8000b696 <memmove>
8000b534:	6e 08       	ld.w	r8,r7[0x0]
8000b536:	08 08       	add	r8,r4
8000b538:	08 95       	mov	r5,r4
8000b53a:	8f 08       	st.w	r7[0x0],r8
8000b53c:	6e 28       	ld.w	r8,r7[0x8]
8000b53e:	08 18       	sub	r8,r4
8000b540:	8f 28       	st.w	r7[0x8],r8
8000b542:	0a 16       	sub	r6,r5
8000b544:	c0 71       	brne	8000b552 <__sfvwrite_r+0x276>
8000b546:	0e 9b       	mov	r11,r7
8000b548:	40 1c       	lddsp	r12,sp[0x4]
8000b54a:	fe b0 fc 91 	rcall	8000ae6c <_fflush_r>
8000b54e:	c0 91       	brne	8000b560 <__sfvwrite_r+0x284>
8000b550:	50 06       	stdsp	sp[0x0],r6
8000b552:	64 28       	ld.w	r8,r2[0x8]
8000b554:	0a 18       	sub	r8,r5
8000b556:	85 28       	st.w	r2[0x8],r8
8000b558:	c0 90       	breq	8000b56a <__sfvwrite_r+0x28e>
8000b55a:	0a 11       	sub	r1,r5
8000b55c:	0a 03       	add	r3,r5
8000b55e:	ca 4b       	rjmp	8000b4a6 <__sfvwrite_r+0x1ca>
8000b560:	8e 68       	ld.sh	r8,r7[0xc]
8000b562:	a7 a8       	sbr	r8,0x6
8000b564:	ae 68       	st.h	r7[0xc],r8
8000b566:	3f fc       	mov	r12,-1
8000b568:	c0 28       	rjmp	8000b56c <__sfvwrite_r+0x290>
8000b56a:	30 0c       	mov	r12,0
8000b56c:	2f dd       	sub	sp,-12
8000b56e:	d8 32       	popm	r0-r7,pc

8000b570 <_fwalk>:
8000b570:	d4 31       	pushm	r0-r7,lr
8000b572:	30 05       	mov	r5,0
8000b574:	16 91       	mov	r1,r11
8000b576:	f8 c7 ff 28 	sub	r7,r12,-216
8000b57a:	0a 92       	mov	r2,r5
8000b57c:	fe b0 fc fe 	rcall	8000af78 <__sfp_lock_acquire>
8000b580:	3f f3       	mov	r3,-1
8000b582:	c1 68       	rjmp	8000b5ae <_fwalk+0x3e>
8000b584:	6e 26       	ld.w	r6,r7[0x8]
8000b586:	6e 14       	ld.w	r4,r7[0x4]
8000b588:	2f 46       	sub	r6,-12
8000b58a:	c0 c8       	rjmp	8000b5a2 <_fwalk+0x32>
8000b58c:	8c 08       	ld.sh	r8,r6[0x0]
8000b58e:	e4 08 19 00 	cp.h	r8,r2
8000b592:	c0 70       	breq	8000b5a0 <_fwalk+0x30>
8000b594:	8c 18       	ld.sh	r8,r6[0x2]
8000b596:	e6 08 19 00 	cp.h	r8,r3
8000b59a:	c0 30       	breq	8000b5a0 <_fwalk+0x30>
8000b59c:	5d 11       	icall	r1
8000b59e:	18 45       	or	r5,r12
8000b5a0:	2a 46       	sub	r6,-92
8000b5a2:	20 14       	sub	r4,1
8000b5a4:	ec cc 00 0c 	sub	r12,r6,12
8000b5a8:	58 04       	cp.w	r4,0
8000b5aa:	cf 14       	brge	8000b58c <_fwalk+0x1c>
8000b5ac:	6e 07       	ld.w	r7,r7[0x0]
8000b5ae:	58 07       	cp.w	r7,0
8000b5b0:	ce a1       	brne	8000b584 <_fwalk+0x14>
8000b5b2:	fe b0 fc e4 	rcall	8000af7a <__sfp_lock_release>
8000b5b6:	0a 9c       	mov	r12,r5
8000b5b8:	d8 32       	popm	r0-r7,pc
8000b5ba:	d7 03       	nop

8000b5bc <_localeconv_r>:
8000b5bc:	fe cc d4 0c 	sub	r12,pc,-11252
8000b5c0:	5e fc       	retal	r12
8000b5c2:	d7 03       	nop

8000b5c4 <__smakebuf_r>:
8000b5c4:	d4 21       	pushm	r4-r7,lr
8000b5c6:	20 fd       	sub	sp,60
8000b5c8:	96 68       	ld.sh	r8,r11[0xc]
8000b5ca:	16 97       	mov	r7,r11
8000b5cc:	18 96       	mov	r6,r12
8000b5ce:	e2 18 00 02 	andl	r8,0x2,COH
8000b5d2:	c3 d1       	brne	8000b64c <__smakebuf_r+0x88>
8000b5d4:	96 7b       	ld.sh	r11,r11[0xe]
8000b5d6:	f0 0b 19 00 	cp.h	r11,r8
8000b5da:	c0 55       	brlt	8000b5e4 <__smakebuf_r+0x20>
8000b5dc:	1a 9a       	mov	r10,sp
8000b5de:	e0 a0 04 81 	rcall	8000bee0 <_fstat_r>
8000b5e2:	c0 f4       	brge	8000b600 <__smakebuf_r+0x3c>
8000b5e4:	8e 65       	ld.sh	r5,r7[0xc]
8000b5e6:	0a 98       	mov	r8,r5
8000b5e8:	ab b8       	sbr	r8,0xb
8000b5ea:	e2 15 00 80 	andl	r5,0x80,COH
8000b5ee:	ae 68       	st.h	r7[0xc],r8
8000b5f0:	30 04       	mov	r4,0
8000b5f2:	e0 68 04 00 	mov	r8,1024
8000b5f6:	f9 b5 01 40 	movne	r5,64
8000b5fa:	f0 05 17 00 	moveq	r5,r8
8000b5fe:	c1 c8       	rjmp	8000b636 <__smakebuf_r+0x72>
8000b600:	40 18       	lddsp	r8,sp[0x4]
8000b602:	e2 18 f0 00 	andl	r8,0xf000,COH
8000b606:	e0 48 20 00 	cp.w	r8,8192
8000b60a:	5f 04       	sreq	r4
8000b60c:	e0 48 80 00 	cp.w	r8,32768
8000b610:	c0 e1       	brne	8000b62c <__smakebuf_r+0x68>
8000b612:	6e b9       	ld.w	r9,r7[0x2c]
8000b614:	fe c8 f9 1c 	sub	r8,pc,-1764
8000b618:	10 39       	cp.w	r9,r8
8000b61a:	c0 91       	brne	8000b62c <__smakebuf_r+0x68>
8000b61c:	8e 68       	ld.sh	r8,r7[0xc]
8000b61e:	e0 65 04 00 	mov	r5,1024
8000b622:	ab a8       	sbr	r8,0xa
8000b624:	ef 45 00 50 	st.w	r7[80],r5
8000b628:	ae 68       	st.h	r7[0xc],r8
8000b62a:	c0 68       	rjmp	8000b636 <__smakebuf_r+0x72>
8000b62c:	8e 68       	ld.sh	r8,r7[0xc]
8000b62e:	e0 65 04 00 	mov	r5,1024
8000b632:	ab b8       	sbr	r8,0xb
8000b634:	ae 68       	st.h	r7[0xc],r8
8000b636:	0a 9b       	mov	r11,r5
8000b638:	0c 9c       	mov	r12,r6
8000b63a:	fe b0 df 35 	rcall	800074a4 <_malloc_r>
8000b63e:	8e 68       	ld.sh	r8,r7[0xc]
8000b640:	c0 d1       	brne	8000b65a <__smakebuf_r+0x96>
8000b642:	ed b8 00 09 	bld	r8,0x9
8000b646:	c1 b0       	breq	8000b67c <__smakebuf_r+0xb8>
8000b648:	a1 b8       	sbr	r8,0x1
8000b64a:	ae 68       	st.h	r7[0xc],r8
8000b64c:	ee c8 ff b9 	sub	r8,r7,-71
8000b650:	8f 48       	st.w	r7[0x10],r8
8000b652:	8f 08       	st.w	r7[0x0],r8
8000b654:	30 18       	mov	r8,1
8000b656:	8f 58       	st.w	r7[0x14],r8
8000b658:	c1 28       	rjmp	8000b67c <__smakebuf_r+0xb8>
8000b65a:	a7 b8       	sbr	r8,0x7
8000b65c:	8f 4c       	st.w	r7[0x10],r12
8000b65e:	ae 68       	st.h	r7[0xc],r8
8000b660:	8f 55       	st.w	r7[0x14],r5
8000b662:	fe c8 06 e6 	sub	r8,pc,1766
8000b666:	8f 0c       	st.w	r7[0x0],r12
8000b668:	8d a8       	st.w	r6[0x28],r8
8000b66a:	58 04       	cp.w	r4,0
8000b66c:	c0 80       	breq	8000b67c <__smakebuf_r+0xb8>
8000b66e:	8e 7c       	ld.sh	r12,r7[0xe]
8000b670:	fe b0 e3 94 	rcall	80007d98 <isatty>
8000b674:	c0 40       	breq	8000b67c <__smakebuf_r+0xb8>
8000b676:	8e 68       	ld.sh	r8,r7[0xc]
8000b678:	a1 a8       	sbr	r8,0x0
8000b67a:	ae 68       	st.h	r7[0xc],r8
8000b67c:	2f 1d       	sub	sp,-60
8000b67e:	d8 22       	popm	r4-r7,pc

8000b680 <memchr>:
8000b680:	f7 db c0 08 	bfextu	r11,r11,0x0,0x8
8000b684:	c0 68       	rjmp	8000b690 <memchr+0x10>
8000b686:	20 1a       	sub	r10,1
8000b688:	19 88       	ld.ub	r8,r12[0x0]
8000b68a:	16 38       	cp.w	r8,r11
8000b68c:	5e 0c       	reteq	r12
8000b68e:	2f fc       	sub	r12,-1
8000b690:	58 0a       	cp.w	r10,0
8000b692:	cf a1       	brne	8000b686 <memchr+0x6>
8000b694:	5e fa       	retal	r10

8000b696 <memmove>:
8000b696:	d4 01       	pushm	lr
8000b698:	18 3b       	cp.w	r11,r12
8000b69a:	c1 92       	brcc	8000b6cc <memmove+0x36>
8000b69c:	f6 0a 00 09 	add	r9,r11,r10
8000b6a0:	12 3c       	cp.w	r12,r9
8000b6a2:	c1 52       	brcc	8000b6cc <memmove+0x36>
8000b6a4:	f8 0a 00 0b 	add	r11,r12,r10
8000b6a8:	30 08       	mov	r8,0
8000b6aa:	c0 68       	rjmp	8000b6b6 <memmove+0x20>
8000b6ac:	f2 08 07 0e 	ld.ub	lr,r9[r8]
8000b6b0:	20 1a       	sub	r10,1
8000b6b2:	f6 08 0b 0e 	st.b	r11[r8],lr
8000b6b6:	20 18       	sub	r8,1
8000b6b8:	58 0a       	cp.w	r10,0
8000b6ba:	cf 91       	brne	8000b6ac <memmove+0x16>
8000b6bc:	d8 02       	popm	pc
8000b6be:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000b6c2:	20 1a       	sub	r10,1
8000b6c4:	f8 08 0b 09 	st.b	r12[r8],r9
8000b6c8:	2f f8       	sub	r8,-1
8000b6ca:	c0 28       	rjmp	8000b6ce <memmove+0x38>
8000b6cc:	30 08       	mov	r8,0
8000b6ce:	58 0a       	cp.w	r10,0
8000b6d0:	cf 71       	brne	8000b6be <memmove+0x28>
8000b6d2:	d8 02       	popm	pc

8000b6d4 <__hi0bits>:
8000b6d4:	18 98       	mov	r8,r12
8000b6d6:	e0 1c 00 00 	andl	r12,0x0
8000b6da:	f0 09 15 10 	lsl	r9,r8,0x10
8000b6de:	58 0c       	cp.w	r12,0
8000b6e0:	f2 08 17 00 	moveq	r8,r9
8000b6e4:	f9 bc 00 10 	moveq	r12,16
8000b6e8:	f9 bc 01 00 	movne	r12,0
8000b6ec:	10 9a       	mov	r10,r8
8000b6ee:	f0 09 15 08 	lsl	r9,r8,0x8
8000b6f2:	e6 1a ff 00 	andh	r10,0xff00,COH
8000b6f6:	f7 bc 00 f8 	subeq	r12,-8
8000b6fa:	f2 08 17 00 	moveq	r8,r9
8000b6fe:	10 9a       	mov	r10,r8
8000b700:	f0 09 15 04 	lsl	r9,r8,0x4
8000b704:	e6 1a f0 00 	andh	r10,0xf000,COH
8000b708:	f7 bc 00 fc 	subeq	r12,-4
8000b70c:	f2 08 17 00 	moveq	r8,r9
8000b710:	10 9a       	mov	r10,r8
8000b712:	f0 09 15 02 	lsl	r9,r8,0x2
8000b716:	e6 1a c0 00 	andh	r10,0xc000,COH
8000b71a:	f7 bc 00 fe 	subeq	r12,-2
8000b71e:	f2 08 17 00 	moveq	r8,r9
8000b722:	58 08       	cp.w	r8,0
8000b724:	5e 5c       	retlt	r12
8000b726:	ed b8 00 1e 	bld	r8,0x1e
8000b72a:	f9 bc 01 20 	movne	r12,32
8000b72e:	f7 bc 00 ff 	subeq	r12,-1
8000b732:	5e fc       	retal	r12

8000b734 <__lo0bits>:
8000b734:	18 99       	mov	r9,r12
8000b736:	78 08       	ld.w	r8,r12[0x0]
8000b738:	f9 d8 c0 03 	bfextu	r12,r8,0x0,0x3
8000b73c:	c1 50       	breq	8000b766 <__lo0bits+0x32>
8000b73e:	ed b8 00 00 	bld	r8,0x0
8000b742:	c0 21       	brne	8000b746 <__lo0bits+0x12>
8000b744:	5e fd       	retal	0
8000b746:	10 9b       	mov	r11,r8
8000b748:	f0 0a 16 01 	lsr	r10,r8,0x1
8000b74c:	e2 1b 00 02 	andl	r11,0x2,COH
8000b750:	a3 88       	lsr	r8,0x2
8000b752:	58 0b       	cp.w	r11,0
8000b754:	f3 fa 1a 00 	st.wne	r9[0x0],r10
8000b758:	f9 bc 01 01 	movne	r12,1
8000b75c:	f3 f8 0a 00 	st.weq	r9[0x0],r8
8000b760:	f9 bc 00 02 	moveq	r12,2
8000b764:	5e fc       	retal	r12
8000b766:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
8000b76a:	f0 0b 16 10 	lsr	r11,r8,0x10
8000b76e:	58 0a       	cp.w	r10,0
8000b770:	f6 08 17 00 	moveq	r8,r11
8000b774:	f9 bc 00 10 	moveq	r12,16
8000b778:	f7 d8 c0 08 	bfextu	r11,r8,0x0,0x8
8000b77c:	f0 0a 16 08 	lsr	r10,r8,0x8
8000b780:	58 0b       	cp.w	r11,0
8000b782:	f7 bc 00 f8 	subeq	r12,-8
8000b786:	f4 08 17 00 	moveq	r8,r10
8000b78a:	f7 d8 c0 04 	bfextu	r11,r8,0x0,0x4
8000b78e:	f0 0a 16 04 	lsr	r10,r8,0x4
8000b792:	58 0b       	cp.w	r11,0
8000b794:	f7 bc 00 fc 	subeq	r12,-4
8000b798:	f4 08 17 00 	moveq	r8,r10
8000b79c:	f7 d8 c0 02 	bfextu	r11,r8,0x0,0x2
8000b7a0:	f0 0a 16 02 	lsr	r10,r8,0x2
8000b7a4:	58 0b       	cp.w	r11,0
8000b7a6:	f7 bc 00 fe 	subeq	r12,-2
8000b7aa:	f4 08 17 00 	moveq	r8,r10
8000b7ae:	ed b8 00 00 	bld	r8,0x0
8000b7b2:	c0 60       	breq	8000b7be <__lo0bits+0x8a>
8000b7b4:	a1 98       	lsr	r8,0x1
8000b7b6:	c0 31       	brne	8000b7bc <__lo0bits+0x88>
8000b7b8:	32 0c       	mov	r12,32
8000b7ba:	5e fc       	retal	r12
8000b7bc:	2f fc       	sub	r12,-1
8000b7be:	93 08       	st.w	r9[0x0],r8
8000b7c0:	5e fc       	retal	r12

8000b7c2 <__mcmp>:
8000b7c2:	d4 01       	pushm	lr
8000b7c4:	18 98       	mov	r8,r12
8000b7c6:	76 49       	ld.w	r9,r11[0x10]
8000b7c8:	78 4c       	ld.w	r12,r12[0x10]
8000b7ca:	12 1c       	sub	r12,r9
8000b7cc:	c1 31       	brne	8000b7f2 <__mcmp+0x30>
8000b7ce:	2f b9       	sub	r9,-5
8000b7d0:	a3 69       	lsl	r9,0x2
8000b7d2:	12 0b       	add	r11,r9
8000b7d4:	f0 09 00 09 	add	r9,r8,r9
8000b7d8:	2e c8       	sub	r8,-20
8000b7da:	13 4e       	ld.w	lr,--r9
8000b7dc:	17 4a       	ld.w	r10,--r11
8000b7de:	14 3e       	cp.w	lr,r10
8000b7e0:	c0 60       	breq	8000b7ec <__mcmp+0x2a>
8000b7e2:	f9 bc 03 ff 	movlo	r12,-1
8000b7e6:	f9 bc 02 01 	movhs	r12,1
8000b7ea:	d8 02       	popm	pc
8000b7ec:	10 39       	cp.w	r9,r8
8000b7ee:	fe 9b ff f6 	brhi	8000b7da <__mcmp+0x18>
8000b7f2:	d8 02       	popm	pc

8000b7f4 <_Bfree>:
8000b7f4:	d4 21       	pushm	r4-r7,lr
8000b7f6:	18 97       	mov	r7,r12
8000b7f8:	16 95       	mov	r5,r11
8000b7fa:	78 96       	ld.w	r6,r12[0x24]
8000b7fc:	58 06       	cp.w	r6,0
8000b7fe:	c0 91       	brne	8000b810 <_Bfree+0x1c>
8000b800:	31 0c       	mov	r12,16
8000b802:	fe b0 de 49 	rcall	80007494 <malloc>
8000b806:	99 36       	st.w	r12[0xc],r6
8000b808:	8f 9c       	st.w	r7[0x24],r12
8000b80a:	99 16       	st.w	r12[0x4],r6
8000b80c:	99 26       	st.w	r12[0x8],r6
8000b80e:	99 06       	st.w	r12[0x0],r6
8000b810:	58 05       	cp.w	r5,0
8000b812:	c0 90       	breq	8000b824 <_Bfree+0x30>
8000b814:	6a 19       	ld.w	r9,r5[0x4]
8000b816:	6e 98       	ld.w	r8,r7[0x24]
8000b818:	70 38       	ld.w	r8,r8[0xc]
8000b81a:	f0 09 03 2a 	ld.w	r10,r8[r9<<0x2]
8000b81e:	8b 0a       	st.w	r5[0x0],r10
8000b820:	f0 09 09 25 	st.w	r8[r9<<0x2],r5
8000b824:	d8 22       	popm	r4-r7,pc
8000b826:	d7 03       	nop

8000b828 <_Balloc>:
8000b828:	d4 21       	pushm	r4-r7,lr
8000b82a:	18 97       	mov	r7,r12
8000b82c:	16 96       	mov	r6,r11
8000b82e:	78 95       	ld.w	r5,r12[0x24]
8000b830:	58 05       	cp.w	r5,0
8000b832:	c0 91       	brne	8000b844 <_Balloc+0x1c>
8000b834:	31 0c       	mov	r12,16
8000b836:	fe b0 de 2f 	rcall	80007494 <malloc>
8000b83a:	99 35       	st.w	r12[0xc],r5
8000b83c:	8f 9c       	st.w	r7[0x24],r12
8000b83e:	99 15       	st.w	r12[0x4],r5
8000b840:	99 25       	st.w	r12[0x8],r5
8000b842:	99 05       	st.w	r12[0x0],r5
8000b844:	6e 95       	ld.w	r5,r7[0x24]
8000b846:	6a 38       	ld.w	r8,r5[0xc]
8000b848:	58 08       	cp.w	r8,0
8000b84a:	c0 b1       	brne	8000b860 <_Balloc+0x38>
8000b84c:	31 0a       	mov	r10,16
8000b84e:	30 4b       	mov	r11,4
8000b850:	0e 9c       	mov	r12,r7
8000b852:	e0 a0 02 a7 	rcall	8000bda0 <_calloc_r>
8000b856:	8b 3c       	st.w	r5[0xc],r12
8000b858:	6e 98       	ld.w	r8,r7[0x24]
8000b85a:	70 3c       	ld.w	r12,r8[0xc]
8000b85c:	58 0c       	cp.w	r12,0
8000b85e:	c1 b0       	breq	8000b894 <_Balloc+0x6c>
8000b860:	6e 98       	ld.w	r8,r7[0x24]
8000b862:	70 38       	ld.w	r8,r8[0xc]
8000b864:	f0 06 00 28 	add	r8,r8,r6<<0x2
8000b868:	70 0c       	ld.w	r12,r8[0x0]
8000b86a:	58 0c       	cp.w	r12,0
8000b86c:	c0 40       	breq	8000b874 <_Balloc+0x4c>
8000b86e:	78 09       	ld.w	r9,r12[0x0]
8000b870:	91 09       	st.w	r8[0x0],r9
8000b872:	c0 e8       	rjmp	8000b88e <_Balloc+0x66>
8000b874:	0e 9c       	mov	r12,r7
8000b876:	30 17       	mov	r7,1
8000b878:	0e 9b       	mov	r11,r7
8000b87a:	ee 06 09 47 	lsl	r7,r7,r6
8000b87e:	ee ca ff fb 	sub	r10,r7,-5
8000b882:	a3 6a       	lsl	r10,0x2
8000b884:	e0 a0 02 8e 	rcall	8000bda0 <_calloc_r>
8000b888:	c0 60       	breq	8000b894 <_Balloc+0x6c>
8000b88a:	99 16       	st.w	r12[0x4],r6
8000b88c:	99 27       	st.w	r12[0x8],r7
8000b88e:	30 08       	mov	r8,0
8000b890:	99 38       	st.w	r12[0xc],r8
8000b892:	99 48       	st.w	r12[0x10],r8
8000b894:	d8 22       	popm	r4-r7,pc
8000b896:	d7 03       	nop

8000b898 <__d2b>:
8000b898:	d4 31       	pushm	r0-r7,lr
8000b89a:	20 2d       	sub	sp,8
8000b89c:	16 93       	mov	r3,r11
8000b89e:	12 96       	mov	r6,r9
8000b8a0:	10 95       	mov	r5,r8
8000b8a2:	14 92       	mov	r2,r10
8000b8a4:	30 1b       	mov	r11,1
8000b8a6:	cc 1f       	rcall	8000b828 <_Balloc>
8000b8a8:	f3 d3 c0 14 	bfextu	r9,r3,0x0,0x14
8000b8ac:	50 09       	stdsp	sp[0x0],r9
8000b8ae:	f1 d3 c0 1f 	bfextu	r8,r3,0x0,0x1f
8000b8b2:	b5 a9       	sbr	r9,0x14
8000b8b4:	f0 01 16 14 	lsr	r1,r8,0x14
8000b8b8:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000b8bc:	18 94       	mov	r4,r12
8000b8be:	58 02       	cp.w	r2,0
8000b8c0:	c1 d0       	breq	8000b8fa <__d2b+0x62>
8000b8c2:	fa cc ff f8 	sub	r12,sp,-8
8000b8c6:	18 d2       	st.w	--r12,r2
8000b8c8:	c3 6f       	rcall	8000b734 <__lo0bits>
8000b8ca:	40 18       	lddsp	r8,sp[0x4]
8000b8cc:	c0 d0       	breq	8000b8e6 <__d2b+0x4e>
8000b8ce:	40 09       	lddsp	r9,sp[0x0]
8000b8d0:	f8 0a 11 20 	rsub	r10,r12,32
8000b8d4:	f2 0a 09 4a 	lsl	r10,r9,r10
8000b8d8:	f5 e8 10 08 	or	r8,r10,r8
8000b8dc:	89 58       	st.w	r4[0x14],r8
8000b8de:	f2 0c 0a 49 	lsr	r9,r9,r12
8000b8e2:	50 09       	stdsp	sp[0x0],r9
8000b8e4:	c0 28       	rjmp	8000b8e8 <__d2b+0x50>
8000b8e6:	89 58       	st.w	r4[0x14],r8
8000b8e8:	40 08       	lddsp	r8,sp[0x0]
8000b8ea:	58 08       	cp.w	r8,0
8000b8ec:	f9 b3 01 02 	movne	r3,2
8000b8f0:	f9 b3 00 01 	moveq	r3,1
8000b8f4:	89 68       	st.w	r4[0x18],r8
8000b8f6:	89 43       	st.w	r4[0x10],r3
8000b8f8:	c0 88       	rjmp	8000b908 <__d2b+0x70>
8000b8fa:	1a 9c       	mov	r12,sp
8000b8fc:	c1 cf       	rcall	8000b734 <__lo0bits>
8000b8fe:	30 13       	mov	r3,1
8000b900:	40 08       	lddsp	r8,sp[0x0]
8000b902:	2e 0c       	sub	r12,-32
8000b904:	89 43       	st.w	r4[0x10],r3
8000b906:	89 58       	st.w	r4[0x14],r8
8000b908:	58 01       	cp.w	r1,0
8000b90a:	c0 90       	breq	8000b91c <__d2b+0x84>
8000b90c:	e2 c1 04 33 	sub	r1,r1,1075
8000b910:	18 01       	add	r1,r12
8000b912:	8d 01       	st.w	r6[0x0],r1
8000b914:	f8 0c 11 35 	rsub	r12,r12,53
8000b918:	8b 0c       	st.w	r5[0x0],r12
8000b91a:	c0 c8       	rjmp	8000b932 <__d2b+0x9a>
8000b91c:	e6 c8 ff fc 	sub	r8,r3,-4
8000b920:	f8 cc 04 32 	sub	r12,r12,1074
8000b924:	a5 73       	lsl	r3,0x5
8000b926:	8d 0c       	st.w	r6[0x0],r12
8000b928:	e8 08 03 2c 	ld.w	r12,r4[r8<<0x2]
8000b92c:	cd 4e       	rcall	8000b6d4 <__hi0bits>
8000b92e:	18 13       	sub	r3,r12
8000b930:	8b 03       	st.w	r5[0x0],r3
8000b932:	08 9c       	mov	r12,r4
8000b934:	2f ed       	sub	sp,-8
8000b936:	d8 32       	popm	r0-r7,pc

8000b938 <__mdiff>:
8000b938:	d4 31       	pushm	r0-r7,lr
8000b93a:	74 48       	ld.w	r8,r10[0x10]
8000b93c:	76 45       	ld.w	r5,r11[0x10]
8000b93e:	16 97       	mov	r7,r11
8000b940:	14 96       	mov	r6,r10
8000b942:	10 15       	sub	r5,r8
8000b944:	c1 31       	brne	8000b96a <__mdiff+0x32>
8000b946:	2f b8       	sub	r8,-5
8000b948:	ee ce ff ec 	sub	lr,r7,-20
8000b94c:	a3 68       	lsl	r8,0x2
8000b94e:	f4 08 00 0b 	add	r11,r10,r8
8000b952:	ee 08 00 08 	add	r8,r7,r8
8000b956:	11 4a       	ld.w	r10,--r8
8000b958:	17 49       	ld.w	r9,--r11
8000b95a:	12 3a       	cp.w	r10,r9
8000b95c:	c0 30       	breq	8000b962 <__mdiff+0x2a>
8000b95e:	c0 e2       	brcc	8000b97a <__mdiff+0x42>
8000b960:	c0 78       	rjmp	8000b96e <__mdiff+0x36>
8000b962:	1c 38       	cp.w	r8,lr
8000b964:	fe 9b ff f9 	brhi	8000b956 <__mdiff+0x1e>
8000b968:	c4 98       	rjmp	8000b9fa <__mdiff+0xc2>
8000b96a:	58 05       	cp.w	r5,0
8000b96c:	c0 64       	brge	8000b978 <__mdiff+0x40>
8000b96e:	0e 98       	mov	r8,r7
8000b970:	30 15       	mov	r5,1
8000b972:	0c 97       	mov	r7,r6
8000b974:	10 96       	mov	r6,r8
8000b976:	c0 28       	rjmp	8000b97a <__mdiff+0x42>
8000b978:	30 05       	mov	r5,0
8000b97a:	6e 1b       	ld.w	r11,r7[0x4]
8000b97c:	c5 6f       	rcall	8000b828 <_Balloc>
8000b97e:	6e 49       	ld.w	r9,r7[0x10]
8000b980:	6c 44       	ld.w	r4,r6[0x10]
8000b982:	99 35       	st.w	r12[0xc],r5
8000b984:	2f b4       	sub	r4,-5
8000b986:	f2 c5 ff fb 	sub	r5,r9,-5
8000b98a:	ec 04 00 24 	add	r4,r6,r4<<0x2
8000b98e:	ee 05 00 25 	add	r5,r7,r5<<0x2
8000b992:	2e c6       	sub	r6,-20
8000b994:	2e c7       	sub	r7,-20
8000b996:	f8 c8 ff ec 	sub	r8,r12,-20
8000b99a:	30 0a       	mov	r10,0
8000b99c:	0f 0e       	ld.w	lr,r7++
8000b99e:	0d 0b       	ld.w	r11,r6++
8000b9a0:	fc 02 16 10 	lsr	r2,lr,0x10
8000b9a4:	f6 03 16 10 	lsr	r3,r11,0x10
8000b9a8:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000b9ac:	e4 03 01 03 	sub	r3,r2,r3
8000b9b0:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000b9b4:	fc 0b 01 0b 	sub	r11,lr,r11
8000b9b8:	f6 0a 00 0a 	add	r10,r11,r10
8000b9bc:	b0 1a       	st.h	r8[0x2],r10
8000b9be:	b1 4a       	asr	r10,0x10
8000b9c0:	e6 0a 00 0a 	add	r10,r3,r10
8000b9c4:	b0 0a       	st.h	r8[0x0],r10
8000b9c6:	2f c8       	sub	r8,-4
8000b9c8:	b1 4a       	asr	r10,0x10
8000b9ca:	08 36       	cp.w	r6,r4
8000b9cc:	ce 83       	brcs	8000b99c <__mdiff+0x64>
8000b9ce:	c0 d8       	rjmp	8000b9e8 <__mdiff+0xb0>
8000b9d0:	0f 0b       	ld.w	r11,r7++
8000b9d2:	f6 0e 16 10 	lsr	lr,r11,0x10
8000b9d6:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000b9da:	16 0a       	add	r10,r11
8000b9dc:	b0 1a       	st.h	r8[0x2],r10
8000b9de:	b1 4a       	asr	r10,0x10
8000b9e0:	1c 0a       	add	r10,lr
8000b9e2:	b0 0a       	st.h	r8[0x0],r10
8000b9e4:	2f c8       	sub	r8,-4
8000b9e6:	b1 4a       	asr	r10,0x10
8000b9e8:	0a 37       	cp.w	r7,r5
8000b9ea:	cf 33       	brcs	8000b9d0 <__mdiff+0x98>
8000b9ec:	c0 28       	rjmp	8000b9f0 <__mdiff+0xb8>
8000b9ee:	20 19       	sub	r9,1
8000b9f0:	11 4a       	ld.w	r10,--r8
8000b9f2:	58 0a       	cp.w	r10,0
8000b9f4:	cf d0       	breq	8000b9ee <__mdiff+0xb6>
8000b9f6:	99 49       	st.w	r12[0x10],r9
8000b9f8:	d8 32       	popm	r0-r7,pc
8000b9fa:	30 0b       	mov	r11,0
8000b9fc:	c1 6f       	rcall	8000b828 <_Balloc>
8000b9fe:	30 18       	mov	r8,1
8000ba00:	99 48       	st.w	r12[0x10],r8
8000ba02:	30 08       	mov	r8,0
8000ba04:	99 58       	st.w	r12[0x14],r8
8000ba06:	d8 32       	popm	r0-r7,pc

8000ba08 <__lshift>:
8000ba08:	d4 31       	pushm	r0-r7,lr
8000ba0a:	16 97       	mov	r7,r11
8000ba0c:	76 46       	ld.w	r6,r11[0x10]
8000ba0e:	f4 02 14 05 	asr	r2,r10,0x5
8000ba12:	2f f6       	sub	r6,-1
8000ba14:	14 93       	mov	r3,r10
8000ba16:	18 94       	mov	r4,r12
8000ba18:	04 06       	add	r6,r2
8000ba1a:	76 1b       	ld.w	r11,r11[0x4]
8000ba1c:	6e 28       	ld.w	r8,r7[0x8]
8000ba1e:	c0 38       	rjmp	8000ba24 <__lshift+0x1c>
8000ba20:	2f fb       	sub	r11,-1
8000ba22:	a1 78       	lsl	r8,0x1
8000ba24:	10 36       	cp.w	r6,r8
8000ba26:	fe 99 ff fd 	brgt	8000ba20 <__lshift+0x18>
8000ba2a:	08 9c       	mov	r12,r4
8000ba2c:	cf ee       	rcall	8000b828 <_Balloc>
8000ba2e:	30 09       	mov	r9,0
8000ba30:	18 95       	mov	r5,r12
8000ba32:	f8 c8 ff ec 	sub	r8,r12,-20
8000ba36:	12 9a       	mov	r10,r9
8000ba38:	c0 38       	rjmp	8000ba3e <__lshift+0x36>
8000ba3a:	10 aa       	st.w	r8++,r10
8000ba3c:	2f f9       	sub	r9,-1
8000ba3e:	04 39       	cp.w	r9,r2
8000ba40:	cf d5       	brlt	8000ba3a <__lshift+0x32>
8000ba42:	6e 4b       	ld.w	r11,r7[0x10]
8000ba44:	e7 d3 c0 05 	bfextu	r3,r3,0x0,0x5
8000ba48:	2f bb       	sub	r11,-5
8000ba4a:	ee c9 ff ec 	sub	r9,r7,-20
8000ba4e:	ee 0b 00 2b 	add	r11,r7,r11<<0x2
8000ba52:	58 03       	cp.w	r3,0
8000ba54:	c1 30       	breq	8000ba7a <__lshift+0x72>
8000ba56:	e6 0c 11 20 	rsub	r12,r3,32
8000ba5a:	30 0a       	mov	r10,0
8000ba5c:	72 02       	ld.w	r2,r9[0x0]
8000ba5e:	e4 03 09 42 	lsl	r2,r2,r3
8000ba62:	04 4a       	or	r10,r2
8000ba64:	10 aa       	st.w	r8++,r10
8000ba66:	13 0a       	ld.w	r10,r9++
8000ba68:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000ba6c:	16 39       	cp.w	r9,r11
8000ba6e:	cf 73       	brcs	8000ba5c <__lshift+0x54>
8000ba70:	91 0a       	st.w	r8[0x0],r10
8000ba72:	58 0a       	cp.w	r10,0
8000ba74:	c0 70       	breq	8000ba82 <__lshift+0x7a>
8000ba76:	2f f6       	sub	r6,-1
8000ba78:	c0 58       	rjmp	8000ba82 <__lshift+0x7a>
8000ba7a:	13 0a       	ld.w	r10,r9++
8000ba7c:	10 aa       	st.w	r8++,r10
8000ba7e:	16 39       	cp.w	r9,r11
8000ba80:	cf d3       	brcs	8000ba7a <__lshift+0x72>
8000ba82:	08 9c       	mov	r12,r4
8000ba84:	20 16       	sub	r6,1
8000ba86:	0e 9b       	mov	r11,r7
8000ba88:	8b 46       	st.w	r5[0x10],r6
8000ba8a:	cb 5e       	rcall	8000b7f4 <_Bfree>
8000ba8c:	0a 9c       	mov	r12,r5
8000ba8e:	d8 32       	popm	r0-r7,pc

8000ba90 <__multiply>:
8000ba90:	d4 31       	pushm	r0-r7,lr
8000ba92:	20 2d       	sub	sp,8
8000ba94:	76 49       	ld.w	r9,r11[0x10]
8000ba96:	74 48       	ld.w	r8,r10[0x10]
8000ba98:	16 96       	mov	r6,r11
8000ba9a:	14 95       	mov	r5,r10
8000ba9c:	10 39       	cp.w	r9,r8
8000ba9e:	ec 08 17 50 	movlt	r8,r6
8000baa2:	ea 06 17 50 	movlt	r6,r5
8000baa6:	f0 05 17 50 	movlt	r5,r8
8000baaa:	6c 28       	ld.w	r8,r6[0x8]
8000baac:	76 43       	ld.w	r3,r11[0x10]
8000baae:	74 42       	ld.w	r2,r10[0x10]
8000bab0:	76 1b       	ld.w	r11,r11[0x4]
8000bab2:	e4 03 00 07 	add	r7,r2,r3
8000bab6:	10 37       	cp.w	r7,r8
8000bab8:	f7 bb 09 ff 	subgt	r11,-1
8000babc:	cb 6e       	rcall	8000b828 <_Balloc>
8000babe:	ee c4 ff fb 	sub	r4,r7,-5
8000bac2:	f8 c9 ff ec 	sub	r9,r12,-20
8000bac6:	f8 04 00 24 	add	r4,r12,r4<<0x2
8000baca:	30 0a       	mov	r10,0
8000bacc:	12 98       	mov	r8,r9
8000bace:	c0 28       	rjmp	8000bad2 <__multiply+0x42>
8000bad0:	10 aa       	st.w	r8++,r10
8000bad2:	08 38       	cp.w	r8,r4
8000bad4:	cf e3       	brcs	8000bad0 <__multiply+0x40>
8000bad6:	2f b3       	sub	r3,-5
8000bad8:	2f b2       	sub	r2,-5
8000bada:	ec 03 00 23 	add	r3,r6,r3<<0x2
8000bade:	ea 02 00 22 	add	r2,r5,r2<<0x2
8000bae2:	ec cb ff ec 	sub	r11,r6,-20
8000bae6:	50 12       	stdsp	sp[0x4],r2
8000bae8:	ea ca ff ec 	sub	r10,r5,-20
8000baec:	c4 48       	rjmp	8000bb74 <__multiply+0xe4>
8000baee:	94 95       	ld.uh	r5,r10[0x2]
8000baf0:	58 05       	cp.w	r5,0
8000baf2:	c2 00       	breq	8000bb32 <__multiply+0xa2>
8000baf4:	12 98       	mov	r8,r9
8000baf6:	16 96       	mov	r6,r11
8000baf8:	30 0e       	mov	lr,0
8000bafa:	50 09       	stdsp	sp[0x0],r9
8000bafc:	0d 02       	ld.w	r2,r6++
8000bafe:	e4 00 16 10 	lsr	r0,r2,0x10
8000bb02:	70 01       	ld.w	r1,r8[0x0]
8000bb04:	70 09       	ld.w	r9,r8[0x0]
8000bb06:	b1 81       	lsr	r1,0x10
8000bb08:	e5 d2 c0 10 	bfextu	r2,r2,0x0,0x10
8000bb0c:	e0 05 03 41 	mac	r1,r0,r5
8000bb10:	ab 32       	mul	r2,r5
8000bb12:	e1 d9 c0 10 	bfextu	r0,r9,0x0,0x10
8000bb16:	00 02       	add	r2,r0
8000bb18:	e4 0e 00 0e 	add	lr,r2,lr
8000bb1c:	b0 1e       	st.h	r8[0x2],lr
8000bb1e:	b1 8e       	lsr	lr,0x10
8000bb20:	1c 01       	add	r1,lr
8000bb22:	b0 01       	st.h	r8[0x0],r1
8000bb24:	e2 0e 16 10 	lsr	lr,r1,0x10
8000bb28:	2f c8       	sub	r8,-4
8000bb2a:	06 36       	cp.w	r6,r3
8000bb2c:	ce 83       	brcs	8000bafc <__multiply+0x6c>
8000bb2e:	40 09       	lddsp	r9,sp[0x0]
8000bb30:	91 0e       	st.w	r8[0x0],lr
8000bb32:	94 86       	ld.uh	r6,r10[0x0]
8000bb34:	58 06       	cp.w	r6,0
8000bb36:	c1 d0       	breq	8000bb70 <__multiply+0xe0>
8000bb38:	72 02       	ld.w	r2,r9[0x0]
8000bb3a:	12 98       	mov	r8,r9
8000bb3c:	16 9e       	mov	lr,r11
8000bb3e:	30 05       	mov	r5,0
8000bb40:	b0 12       	st.h	r8[0x2],r2
8000bb42:	1d 01       	ld.w	r1,lr++
8000bb44:	90 82       	ld.uh	r2,r8[0x0]
8000bb46:	e1 d1 c0 10 	bfextu	r0,r1,0x0,0x10
8000bb4a:	ad 30       	mul	r0,r6
8000bb4c:	e0 02 00 02 	add	r2,r0,r2
8000bb50:	e4 05 00 05 	add	r5,r2,r5
8000bb54:	b0 05       	st.h	r8[0x0],r5
8000bb56:	b1 85       	lsr	r5,0x10
8000bb58:	b1 81       	lsr	r1,0x10
8000bb5a:	2f c8       	sub	r8,-4
8000bb5c:	ad 31       	mul	r1,r6
8000bb5e:	90 92       	ld.uh	r2,r8[0x2]
8000bb60:	e2 02 00 02 	add	r2,r1,r2
8000bb64:	0a 02       	add	r2,r5
8000bb66:	e4 05 16 10 	lsr	r5,r2,0x10
8000bb6a:	06 3e       	cp.w	lr,r3
8000bb6c:	ce a3       	brcs	8000bb40 <__multiply+0xb0>
8000bb6e:	91 02       	st.w	r8[0x0],r2
8000bb70:	2f ca       	sub	r10,-4
8000bb72:	2f c9       	sub	r9,-4
8000bb74:	40 18       	lddsp	r8,sp[0x4]
8000bb76:	10 3a       	cp.w	r10,r8
8000bb78:	cb b3       	brcs	8000baee <__multiply+0x5e>
8000bb7a:	c0 28       	rjmp	8000bb7e <__multiply+0xee>
8000bb7c:	20 17       	sub	r7,1
8000bb7e:	58 07       	cp.w	r7,0
8000bb80:	e0 8a 00 05 	brle	8000bb8a <__multiply+0xfa>
8000bb84:	09 48       	ld.w	r8,--r4
8000bb86:	58 08       	cp.w	r8,0
8000bb88:	cf a0       	breq	8000bb7c <__multiply+0xec>
8000bb8a:	99 47       	st.w	r12[0x10],r7
8000bb8c:	2f ed       	sub	sp,-8
8000bb8e:	d8 32       	popm	r0-r7,pc

8000bb90 <__i2b>:
8000bb90:	d4 21       	pushm	r4-r7,lr
8000bb92:	16 97       	mov	r7,r11
8000bb94:	30 1b       	mov	r11,1
8000bb96:	c4 9e       	rcall	8000b828 <_Balloc>
8000bb98:	30 19       	mov	r9,1
8000bb9a:	99 57       	st.w	r12[0x14],r7
8000bb9c:	99 49       	st.w	r12[0x10],r9
8000bb9e:	d8 22       	popm	r4-r7,pc

8000bba0 <__multadd>:
8000bba0:	d4 31       	pushm	r0-r7,lr
8000bba2:	30 08       	mov	r8,0
8000bba4:	12 95       	mov	r5,r9
8000bba6:	16 97       	mov	r7,r11
8000bba8:	18 96       	mov	r6,r12
8000bbaa:	76 44       	ld.w	r4,r11[0x10]
8000bbac:	f6 c9 ff ec 	sub	r9,r11,-20
8000bbb0:	72 0b       	ld.w	r11,r9[0x0]
8000bbb2:	f6 0c 16 10 	lsr	r12,r11,0x10
8000bbb6:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000bbba:	f4 0c 02 4c 	mul	r12,r10,r12
8000bbbe:	f4 0b 03 45 	mac	r5,r10,r11
8000bbc2:	f7 d5 c0 10 	bfextu	r11,r5,0x0,0x10
8000bbc6:	b1 85       	lsr	r5,0x10
8000bbc8:	18 05       	add	r5,r12
8000bbca:	ea 0c 15 10 	lsl	r12,r5,0x10
8000bbce:	f8 0b 00 0b 	add	r11,r12,r11
8000bbd2:	12 ab       	st.w	r9++,r11
8000bbd4:	2f f8       	sub	r8,-1
8000bbd6:	b1 85       	lsr	r5,0x10
8000bbd8:	08 38       	cp.w	r8,r4
8000bbda:	ce b5       	brlt	8000bbb0 <__multadd+0x10>
8000bbdc:	58 05       	cp.w	r5,0
8000bbde:	c1 c0       	breq	8000bc16 <__multadd+0x76>
8000bbe0:	6e 28       	ld.w	r8,r7[0x8]
8000bbe2:	10 34       	cp.w	r4,r8
8000bbe4:	c1 35       	brlt	8000bc0a <__multadd+0x6a>
8000bbe6:	6e 1b       	ld.w	r11,r7[0x4]
8000bbe8:	0c 9c       	mov	r12,r6
8000bbea:	2f fb       	sub	r11,-1
8000bbec:	c1 ee       	rcall	8000b828 <_Balloc>
8000bbee:	6e 4a       	ld.w	r10,r7[0x10]
8000bbf0:	ee cb ff f4 	sub	r11,r7,-12
8000bbf4:	18 93       	mov	r3,r12
8000bbf6:	2f ea       	sub	r10,-2
8000bbf8:	2f 4c       	sub	r12,-12
8000bbfa:	a3 6a       	lsl	r10,0x2
8000bbfc:	fe b0 de 70 	rcall	800078dc <memcpy>
8000bc00:	0e 9b       	mov	r11,r7
8000bc02:	0c 9c       	mov	r12,r6
8000bc04:	fe b0 fd f8 	rcall	8000b7f4 <_Bfree>
8000bc08:	06 97       	mov	r7,r3
8000bc0a:	e8 c8 ff ff 	sub	r8,r4,-1
8000bc0e:	2f b4       	sub	r4,-5
8000bc10:	8f 48       	st.w	r7[0x10],r8
8000bc12:	ee 04 09 25 	st.w	r7[r4<<0x2],r5
8000bc16:	0e 9c       	mov	r12,r7
8000bc18:	d8 32       	popm	r0-r7,pc
8000bc1a:	d7 03       	nop

8000bc1c <__pow5mult>:
8000bc1c:	d4 31       	pushm	r0-r7,lr
8000bc1e:	14 96       	mov	r6,r10
8000bc20:	18 97       	mov	r7,r12
8000bc22:	16 94       	mov	r4,r11
8000bc24:	f1 da c0 02 	bfextu	r8,r10,0x0,0x2
8000bc28:	c0 90       	breq	8000bc3a <__pow5mult+0x1e>
8000bc2a:	20 18       	sub	r8,1
8000bc2c:	fe c9 da 40 	sub	r9,pc,-9664
8000bc30:	f2 08 03 2a 	ld.w	r10,r9[r8<<0x2]
8000bc34:	30 09       	mov	r9,0
8000bc36:	cb 5f       	rcall	8000bba0 <__multadd>
8000bc38:	18 94       	mov	r4,r12
8000bc3a:	a3 46       	asr	r6,0x2
8000bc3c:	c3 40       	breq	8000bca4 <__pow5mult+0x88>
8000bc3e:	6e 95       	ld.w	r5,r7[0x24]
8000bc40:	58 05       	cp.w	r5,0
8000bc42:	c0 91       	brne	8000bc54 <__pow5mult+0x38>
8000bc44:	31 0c       	mov	r12,16
8000bc46:	fe b0 dc 27 	rcall	80007494 <malloc>
8000bc4a:	99 35       	st.w	r12[0xc],r5
8000bc4c:	8f 9c       	st.w	r7[0x24],r12
8000bc4e:	99 15       	st.w	r12[0x4],r5
8000bc50:	99 25       	st.w	r12[0x8],r5
8000bc52:	99 05       	st.w	r12[0x0],r5
8000bc54:	6e 93       	ld.w	r3,r7[0x24]
8000bc56:	66 25       	ld.w	r5,r3[0x8]
8000bc58:	58 05       	cp.w	r5,0
8000bc5a:	c0 c1       	brne	8000bc72 <__pow5mult+0x56>
8000bc5c:	e0 6b 02 71 	mov	r11,625
8000bc60:	0e 9c       	mov	r12,r7
8000bc62:	c9 7f       	rcall	8000bb90 <__i2b>
8000bc64:	87 2c       	st.w	r3[0x8],r12
8000bc66:	30 08       	mov	r8,0
8000bc68:	18 95       	mov	r5,r12
8000bc6a:	99 08       	st.w	r12[0x0],r8
8000bc6c:	c0 38       	rjmp	8000bc72 <__pow5mult+0x56>
8000bc6e:	06 9c       	mov	r12,r3
8000bc70:	18 95       	mov	r5,r12
8000bc72:	ed b6 00 00 	bld	r6,0x0
8000bc76:	c0 b1       	brne	8000bc8c <__pow5mult+0x70>
8000bc78:	08 9b       	mov	r11,r4
8000bc7a:	0a 9a       	mov	r10,r5
8000bc7c:	0e 9c       	mov	r12,r7
8000bc7e:	c0 9f       	rcall	8000ba90 <__multiply>
8000bc80:	08 9b       	mov	r11,r4
8000bc82:	18 93       	mov	r3,r12
8000bc84:	0e 9c       	mov	r12,r7
8000bc86:	06 94       	mov	r4,r3
8000bc88:	fe b0 fd b6 	rcall	8000b7f4 <_Bfree>
8000bc8c:	a1 56       	asr	r6,0x1
8000bc8e:	c0 b0       	breq	8000bca4 <__pow5mult+0x88>
8000bc90:	6a 03       	ld.w	r3,r5[0x0]
8000bc92:	58 03       	cp.w	r3,0
8000bc94:	ce d1       	brne	8000bc6e <__pow5mult+0x52>
8000bc96:	0a 9a       	mov	r10,r5
8000bc98:	0a 9b       	mov	r11,r5
8000bc9a:	0e 9c       	mov	r12,r7
8000bc9c:	cf ae       	rcall	8000ba90 <__multiply>
8000bc9e:	8b 0c       	st.w	r5[0x0],r12
8000bca0:	99 03       	st.w	r12[0x0],r3
8000bca2:	ce 7b       	rjmp	8000bc70 <__pow5mult+0x54>
8000bca4:	08 9c       	mov	r12,r4
8000bca6:	d8 32       	popm	r0-r7,pc

8000bca8 <__isinfd>:
8000bca8:	14 98       	mov	r8,r10
8000bcaa:	fc 19 7f f0 	movh	r9,0x7ff0
8000bcae:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000bcb2:	f0 0b 11 00 	rsub	r11,r8,0
8000bcb6:	f7 e8 10 08 	or	r8,r11,r8
8000bcba:	f5 e8 13 f8 	or	r8,r10,r8>>0x1f
8000bcbe:	f2 08 01 08 	sub	r8,r9,r8
8000bcc2:	f0 0c 11 00 	rsub	r12,r8,0
8000bcc6:	f9 e8 10 08 	or	r8,r12,r8
8000bcca:	f0 0c 14 1f 	asr	r12,r8,0x1f
8000bcce:	2f fc       	sub	r12,-1
8000bcd0:	5e fc       	retal	r12

8000bcd2 <__isnand>:
8000bcd2:	14 98       	mov	r8,r10
8000bcd4:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000bcd8:	f0 0c 11 00 	rsub	r12,r8,0
8000bcdc:	10 4c       	or	r12,r8
8000bcde:	fc 18 7f f0 	movh	r8,0x7ff0
8000bce2:	f5 ec 13 fc 	or	r12,r10,r12>>0x1f
8000bce6:	f0 0c 01 0c 	sub	r12,r8,r12
8000bcea:	bf 9c       	lsr	r12,0x1f
8000bcec:	5e fc       	retal	r12
8000bcee:	d7 03       	nop

8000bcf0 <__sclose>:
8000bcf0:	d4 01       	pushm	lr
8000bcf2:	96 7b       	ld.sh	r11,r11[0xe]
8000bcf4:	c8 2c       	rcall	8000bdf8 <_close_r>
8000bcf6:	d8 02       	popm	pc

8000bcf8 <__sseek>:
8000bcf8:	d4 21       	pushm	r4-r7,lr
8000bcfa:	16 97       	mov	r7,r11
8000bcfc:	96 7b       	ld.sh	r11,r11[0xe]
8000bcfe:	c0 3d       	rcall	8000bf04 <_lseek_r>
8000bd00:	8e 68       	ld.sh	r8,r7[0xc]
8000bd02:	10 99       	mov	r9,r8
8000bd04:	ad c8       	cbr	r8,0xc
8000bd06:	ad a9       	sbr	r9,0xc
8000bd08:	5b fc       	cp.w	r12,-1
8000bd0a:	ef f8 0c 06 	st.heq	r7[0xc],r8
8000bd0e:	ef f9 1c 06 	st.hne	r7[0xc],r9
8000bd12:	ef fc 1a 15 	st.wne	r7[0x54],r12
8000bd16:	d8 22       	popm	r4-r7,pc

8000bd18 <__swrite>:
8000bd18:	d4 21       	pushm	r4-r7,lr
8000bd1a:	96 68       	ld.sh	r8,r11[0xc]
8000bd1c:	16 97       	mov	r7,r11
8000bd1e:	14 95       	mov	r5,r10
8000bd20:	12 94       	mov	r4,r9
8000bd22:	e2 18 01 00 	andl	r8,0x100,COH
8000bd26:	18 96       	mov	r6,r12
8000bd28:	c0 50       	breq	8000bd32 <__swrite+0x1a>
8000bd2a:	30 29       	mov	r9,2
8000bd2c:	30 0a       	mov	r10,0
8000bd2e:	96 7b       	ld.sh	r11,r11[0xe]
8000bd30:	ce ac       	rcall	8000bf04 <_lseek_r>
8000bd32:	8e 68       	ld.sh	r8,r7[0xc]
8000bd34:	ad c8       	cbr	r8,0xc
8000bd36:	08 99       	mov	r9,r4
8000bd38:	0a 9a       	mov	r10,r5
8000bd3a:	8e 7b       	ld.sh	r11,r7[0xe]
8000bd3c:	0c 9c       	mov	r12,r6
8000bd3e:	ae 68       	st.h	r7[0xc],r8
8000bd40:	c1 cc       	rcall	8000bd78 <_write_r>
8000bd42:	d8 22       	popm	r4-r7,pc

8000bd44 <__sread>:
8000bd44:	d4 21       	pushm	r4-r7,lr
8000bd46:	16 97       	mov	r7,r11
8000bd48:	96 7b       	ld.sh	r11,r11[0xe]
8000bd4a:	cf 1c       	rcall	8000bf2c <_read_r>
8000bd4c:	c0 65       	brlt	8000bd58 <__sread+0x14>
8000bd4e:	6f 58       	ld.w	r8,r7[0x54]
8000bd50:	18 08       	add	r8,r12
8000bd52:	ef 48 00 54 	st.w	r7[84],r8
8000bd56:	d8 22       	popm	r4-r7,pc
8000bd58:	8e 68       	ld.sh	r8,r7[0xc]
8000bd5a:	ad c8       	cbr	r8,0xc
8000bd5c:	ae 68       	st.h	r7[0xc],r8
8000bd5e:	d8 22       	popm	r4-r7,pc

8000bd60 <strlen>:
8000bd60:	30 09       	mov	r9,0
8000bd62:	18 98       	mov	r8,r12
8000bd64:	c0 28       	rjmp	8000bd68 <strlen+0x8>
8000bd66:	2f f8       	sub	r8,-1
8000bd68:	11 8a       	ld.ub	r10,r8[0x0]
8000bd6a:	f2 0a 18 00 	cp.b	r10,r9
8000bd6e:	cf c1       	brne	8000bd66 <strlen+0x6>
8000bd70:	f0 0c 01 0c 	sub	r12,r8,r12
8000bd74:	5e fc       	retal	r12
8000bd76:	d7 03       	nop

8000bd78 <_write_r>:
8000bd78:	d4 21       	pushm	r4-r7,lr
8000bd7a:	16 98       	mov	r8,r11
8000bd7c:	18 97       	mov	r7,r12
8000bd7e:	10 9c       	mov	r12,r8
8000bd80:	30 08       	mov	r8,0
8000bd82:	14 9b       	mov	r11,r10
8000bd84:	e0 66 bf f4 	mov	r6,49140
8000bd88:	12 9a       	mov	r10,r9
8000bd8a:	8d 08       	st.w	r6[0x0],r8
8000bd8c:	fe b0 d1 72 	rcall	80006070 <_write>
8000bd90:	5b fc       	cp.w	r12,-1
8000bd92:	c0 51       	brne	8000bd9c <_write_r+0x24>
8000bd94:	6c 08       	ld.w	r8,r6[0x0]
8000bd96:	58 08       	cp.w	r8,0
8000bd98:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000bd9c:	d8 22       	popm	r4-r7,pc
8000bd9e:	d7 03       	nop

8000bda0 <_calloc_r>:
8000bda0:	d4 21       	pushm	r4-r7,lr
8000bda2:	f4 0b 02 4b 	mul	r11,r10,r11
8000bda6:	fe b0 db 7f 	rcall	800074a4 <_malloc_r>
8000bdaa:	18 97       	mov	r7,r12
8000bdac:	c2 30       	breq	8000bdf2 <_calloc_r+0x52>
8000bdae:	f8 fa ff fc 	ld.w	r10,r12[-4]
8000bdb2:	e0 1a ff fc 	andl	r10,0xfffc
8000bdb6:	20 4a       	sub	r10,4
8000bdb8:	e0 4a 00 24 	cp.w	r10,36
8000bdbc:	e0 8b 00 18 	brhi	8000bdec <_calloc_r+0x4c>
8000bdc0:	18 98       	mov	r8,r12
8000bdc2:	59 3a       	cp.w	r10,19
8000bdc4:	e0 88 00 0f 	brls	8000bde2 <_calloc_r+0x42>
8000bdc8:	30 09       	mov	r9,0
8000bdca:	10 a9       	st.w	r8++,r9
8000bdcc:	10 a9       	st.w	r8++,r9
8000bdce:	59 ba       	cp.w	r10,27
8000bdd0:	e0 88 00 09 	brls	8000bde2 <_calloc_r+0x42>
8000bdd4:	10 a9       	st.w	r8++,r9
8000bdd6:	10 a9       	st.w	r8++,r9
8000bdd8:	e0 4a 00 24 	cp.w	r10,36
8000bddc:	c0 31       	brne	8000bde2 <_calloc_r+0x42>
8000bdde:	10 a9       	st.w	r8++,r9
8000bde0:	10 a9       	st.w	r8++,r9
8000bde2:	30 09       	mov	r9,0
8000bde4:	10 a9       	st.w	r8++,r9
8000bde6:	91 19       	st.w	r8[0x4],r9
8000bde8:	91 09       	st.w	r8[0x0],r9
8000bdea:	c0 48       	rjmp	8000bdf2 <_calloc_r+0x52>
8000bdec:	30 0b       	mov	r11,0
8000bdee:	fe b0 de 1b 	rcall	80007a24 <memset>
8000bdf2:	0e 9c       	mov	r12,r7
8000bdf4:	d8 22       	popm	r4-r7,pc
8000bdf6:	d7 03       	nop

8000bdf8 <_close_r>:
8000bdf8:	d4 21       	pushm	r4-r7,lr
8000bdfa:	30 08       	mov	r8,0
8000bdfc:	18 97       	mov	r7,r12
8000bdfe:	e0 66 bf f4 	mov	r6,49140
8000be02:	16 9c       	mov	r12,r11
8000be04:	8d 08       	st.w	r6[0x0],r8
8000be06:	fe b0 df b5 	rcall	80007d70 <_close>
8000be0a:	5b fc       	cp.w	r12,-1
8000be0c:	c0 51       	brne	8000be16 <_close_r+0x1e>
8000be0e:	6c 08       	ld.w	r8,r6[0x0]
8000be10:	58 08       	cp.w	r8,0
8000be12:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000be16:	d8 22       	popm	r4-r7,pc

8000be18 <_fclose_r>:
8000be18:	d4 21       	pushm	r4-r7,lr
8000be1a:	18 96       	mov	r6,r12
8000be1c:	16 97       	mov	r7,r11
8000be1e:	58 0b       	cp.w	r11,0
8000be20:	c0 31       	brne	8000be26 <_fclose_r+0xe>
8000be22:	16 95       	mov	r5,r11
8000be24:	c5 38       	rjmp	8000beca <_fclose_r+0xb2>
8000be26:	fe b0 f8 a9 	rcall	8000af78 <__sfp_lock_acquire>
8000be2a:	58 06       	cp.w	r6,0
8000be2c:	c0 70       	breq	8000be3a <_fclose_r+0x22>
8000be2e:	6c 68       	ld.w	r8,r6[0x18]
8000be30:	58 08       	cp.w	r8,0
8000be32:	c0 41       	brne	8000be3a <_fclose_r+0x22>
8000be34:	0c 9c       	mov	r12,r6
8000be36:	fe b0 f8 f3 	rcall	8000b01c <__sinit>
8000be3a:	fe c8 dc f2 	sub	r8,pc,-8974
8000be3e:	10 37       	cp.w	r7,r8
8000be40:	c0 31       	brne	8000be46 <_fclose_r+0x2e>
8000be42:	6c 07       	ld.w	r7,r6[0x0]
8000be44:	c0 c8       	rjmp	8000be5c <_fclose_r+0x44>
8000be46:	fe c8 dc de 	sub	r8,pc,-8994
8000be4a:	10 37       	cp.w	r7,r8
8000be4c:	c0 31       	brne	8000be52 <_fclose_r+0x3a>
8000be4e:	6c 17       	ld.w	r7,r6[0x4]
8000be50:	c0 68       	rjmp	8000be5c <_fclose_r+0x44>
8000be52:	fe c8 dc ca 	sub	r8,pc,-9014
8000be56:	10 37       	cp.w	r7,r8
8000be58:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000be5c:	8e 69       	ld.sh	r9,r7[0xc]
8000be5e:	30 08       	mov	r8,0
8000be60:	f0 09 19 00 	cp.h	r9,r8
8000be64:	c0 51       	brne	8000be6e <_fclose_r+0x56>
8000be66:	fe b0 f8 8a 	rcall	8000af7a <__sfp_lock_release>
8000be6a:	30 05       	mov	r5,0
8000be6c:	c2 f8       	rjmp	8000beca <_fclose_r+0xb2>
8000be6e:	0e 9b       	mov	r11,r7
8000be70:	0c 9c       	mov	r12,r6
8000be72:	fe b0 f7 fd 	rcall	8000ae6c <_fflush_r>
8000be76:	6e c8       	ld.w	r8,r7[0x30]
8000be78:	18 95       	mov	r5,r12
8000be7a:	58 08       	cp.w	r8,0
8000be7c:	c0 60       	breq	8000be88 <_fclose_r+0x70>
8000be7e:	6e 8b       	ld.w	r11,r7[0x20]
8000be80:	0c 9c       	mov	r12,r6
8000be82:	5d 18       	icall	r8
8000be84:	f9 b5 05 ff 	movlt	r5,-1
8000be88:	8e 68       	ld.sh	r8,r7[0xc]
8000be8a:	ed b8 00 07 	bld	r8,0x7
8000be8e:	c0 51       	brne	8000be98 <_fclose_r+0x80>
8000be90:	6e 4b       	ld.w	r11,r7[0x10]
8000be92:	0c 9c       	mov	r12,r6
8000be94:	fe b0 f9 5e 	rcall	8000b150 <_free_r>
8000be98:	6e db       	ld.w	r11,r7[0x34]
8000be9a:	58 0b       	cp.w	r11,0
8000be9c:	c0 a0       	breq	8000beb0 <_fclose_r+0x98>
8000be9e:	ee c8 ff bc 	sub	r8,r7,-68
8000bea2:	10 3b       	cp.w	r11,r8
8000bea4:	c0 40       	breq	8000beac <_fclose_r+0x94>
8000bea6:	0c 9c       	mov	r12,r6
8000bea8:	fe b0 f9 54 	rcall	8000b150 <_free_r>
8000beac:	30 08       	mov	r8,0
8000beae:	8f d8       	st.w	r7[0x34],r8
8000beb0:	6f 2b       	ld.w	r11,r7[0x48]
8000beb2:	58 0b       	cp.w	r11,0
8000beb4:	c0 70       	breq	8000bec2 <_fclose_r+0xaa>
8000beb6:	0c 9c       	mov	r12,r6
8000beb8:	fe b0 f9 4c 	rcall	8000b150 <_free_r>
8000bebc:	30 08       	mov	r8,0
8000bebe:	ef 48 00 48 	st.w	r7[72],r8
8000bec2:	30 08       	mov	r8,0
8000bec4:	ae 68       	st.h	r7[0xc],r8
8000bec6:	fe b0 f8 5a 	rcall	8000af7a <__sfp_lock_release>
8000beca:	0a 9c       	mov	r12,r5
8000becc:	d8 22       	popm	r4-r7,pc
8000bece:	d7 03       	nop

8000bed0 <fclose>:
8000bed0:	d4 01       	pushm	lr
8000bed2:	e0 68 0a 3c 	mov	r8,2620
8000bed6:	18 9b       	mov	r11,r12
8000bed8:	70 0c       	ld.w	r12,r8[0x0]
8000beda:	c9 ff       	rcall	8000be18 <_fclose_r>
8000bedc:	d8 02       	popm	pc
8000bede:	d7 03       	nop

8000bee0 <_fstat_r>:
8000bee0:	d4 21       	pushm	r4-r7,lr
8000bee2:	16 98       	mov	r8,r11
8000bee4:	18 97       	mov	r7,r12
8000bee6:	10 9c       	mov	r12,r8
8000bee8:	30 08       	mov	r8,0
8000beea:	e0 66 bf f4 	mov	r6,49140
8000beee:	14 9b       	mov	r11,r10
8000bef0:	8d 08       	st.w	r6[0x0],r8
8000bef2:	fe b0 df 67 	rcall	80007dc0 <_fstat>
8000bef6:	5b fc       	cp.w	r12,-1
8000bef8:	c0 51       	brne	8000bf02 <_fstat_r+0x22>
8000befa:	6c 08       	ld.w	r8,r6[0x0]
8000befc:	58 08       	cp.w	r8,0
8000befe:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000bf02:	d8 22       	popm	r4-r7,pc

8000bf04 <_lseek_r>:
8000bf04:	d4 21       	pushm	r4-r7,lr
8000bf06:	16 98       	mov	r8,r11
8000bf08:	18 97       	mov	r7,r12
8000bf0a:	10 9c       	mov	r12,r8
8000bf0c:	30 08       	mov	r8,0
8000bf0e:	14 9b       	mov	r11,r10
8000bf10:	e0 66 bf f4 	mov	r6,49140
8000bf14:	12 9a       	mov	r10,r9
8000bf16:	8d 08       	st.w	r6[0x0],r8
8000bf18:	fe b0 df 36 	rcall	80007d84 <_lseek>
8000bf1c:	5b fc       	cp.w	r12,-1
8000bf1e:	c0 51       	brne	8000bf28 <_lseek_r+0x24>
8000bf20:	6c 08       	ld.w	r8,r6[0x0]
8000bf22:	58 08       	cp.w	r8,0
8000bf24:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000bf28:	d8 22       	popm	r4-r7,pc
8000bf2a:	d7 03       	nop

8000bf2c <_read_r>:
8000bf2c:	d4 21       	pushm	r4-r7,lr
8000bf2e:	16 98       	mov	r8,r11
8000bf30:	18 97       	mov	r7,r12
8000bf32:	10 9c       	mov	r12,r8
8000bf34:	30 08       	mov	r8,0
8000bf36:	14 9b       	mov	r11,r10
8000bf38:	e0 66 bf f4 	mov	r6,49140
8000bf3c:	12 9a       	mov	r10,r9
8000bf3e:	8d 08       	st.w	r6[0x0],r8
8000bf40:	fe b0 d0 78 	rcall	80006030 <_read>
8000bf44:	5b fc       	cp.w	r12,-1
8000bf46:	c0 51       	brne	8000bf50 <_read_r+0x24>
8000bf48:	6c 08       	ld.w	r8,r6[0x0]
8000bf4a:	58 08       	cp.w	r8,0
8000bf4c:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000bf50:	d8 22       	popm	r4-r7,pc
8000bf52:	d7 03       	nop

8000bf54 <__avr32_f64_mul>:
8000bf54:	f5 eb 10 1c 	or	r12,r10,r11<<0x1
8000bf58:	e0 80 00 dc 	breq	8000c110 <__avr32_f64_mul_op1_zero>
8000bf5c:	d4 21       	pushm	r4-r7,lr
8000bf5e:	f7 e9 20 0e 	eor	lr,r11,r9
8000bf62:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000bf66:	30 15       	mov	r5,1
8000bf68:	c4 30       	breq	8000bfee <__avr32_f64_mul_op1_subnormal>
8000bf6a:	ab 6b       	lsl	r11,0xa
8000bf6c:	f7 ea 13 6b 	or	r11,r11,r10>>0x16
8000bf70:	ab 6a       	lsl	r10,0xa
8000bf72:	f7 d5 d3 c2 	bfins	r11,r5,0x1e,0x2
8000bf76:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000bf7a:	c5 c0       	breq	8000c032 <__avr32_f64_mul_op2_subnormal>
8000bf7c:	a1 78       	lsl	r8,0x1
8000bf7e:	5c f9       	rol	r9
8000bf80:	f3 d5 d2 ab 	bfins	r9,r5,0x15,0xb
8000bf84:	e0 47 07 ff 	cp.w	r7,2047
8000bf88:	c7 70       	breq	8000c076 <__avr32_f64_mul_op_nan_or_inf>
8000bf8a:	e0 46 07 ff 	cp.w	r6,2047
8000bf8e:	c7 40       	breq	8000c076 <__avr32_f64_mul_op_nan_or_inf>
8000bf90:	ee 06 00 0c 	add	r12,r7,r6
8000bf94:	e0 2c 03 fe 	sub	r12,1022
8000bf98:	f6 08 06 44 	mulu.d	r4,r11,r8
8000bf9c:	f4 09 07 44 	macu.d	r4,r10,r9
8000bfa0:	f4 08 06 46 	mulu.d	r6,r10,r8
8000bfa4:	f6 09 06 4a 	mulu.d	r10,r11,r9
8000bfa8:	08 07       	add	r7,r4
8000bfaa:	f4 05 00 4a 	adc	r10,r10,r5
8000bfae:	5c 0b       	acr	r11
8000bfb0:	ed bb 00 14 	bld	r11,0x14
8000bfb4:	c0 50       	breq	8000bfbe <__avr32_f64_mul+0x6a>
8000bfb6:	a1 77       	lsl	r7,0x1
8000bfb8:	5c fa       	rol	r10
8000bfba:	5c fb       	rol	r11
8000bfbc:	20 1c       	sub	r12,1
8000bfbe:	58 0c       	cp.w	r12,0
8000bfc0:	e0 8a 00 6f 	brle	8000c09e <__avr32_f64_mul_res_subnormal>
8000bfc4:	e0 4c 07 ff 	cp.w	r12,2047
8000bfc8:	e0 84 00 9c 	brge	8000c100 <__avr32_f64_mul_res_inf>
8000bfcc:	f7 dc d2 8b 	bfins	r11,r12,0x14,0xb
8000bfd0:	ed ea 11 f6 	or	r6,r6,r10<<0x1f
8000bfd4:	ef e6 12 17 	or	r7,r7,r6>>0x1
8000bfd8:	ee 17 80 00 	eorh	r7,0x8000
8000bfdc:	f1 b7 04 20 	satu	r7,0x1
8000bfe0:	0e 0a       	add	r10,r7
8000bfe2:	5c 0b       	acr	r11
8000bfe4:	ed be 00 1f 	bld	lr,0x1f
8000bfe8:	ef bb 00 1f 	bst	r11,0x1f
8000bfec:	d8 22       	popm	r4-r7,pc

8000bfee <__avr32_f64_mul_op1_subnormal>:
8000bfee:	e4 1b 00 0f 	andh	r11,0xf
8000bff2:	f4 0c 12 00 	clz	r12,r10
8000bff6:	f6 06 12 00 	clz	r6,r11
8000bffa:	f7 bc 03 e1 	sublo	r12,-31
8000bffe:	f8 06 17 30 	movlo	r6,r12
8000c002:	f7 b6 02 01 	subhs	r6,1
8000c006:	e0 46 00 20 	cp.w	r6,32
8000c00a:	c0 d4       	brge	8000c024 <__avr32_f64_mul_op1_subnormal+0x36>
8000c00c:	ec 0c 11 20 	rsub	r12,r6,32
8000c010:	f6 06 09 4b 	lsl	r11,r11,r6
8000c014:	f4 0c 0a 4c 	lsr	r12,r10,r12
8000c018:	18 4b       	or	r11,r12
8000c01a:	f4 06 09 4a 	lsl	r10,r10,r6
8000c01e:	20 b6       	sub	r6,11
8000c020:	0c 17       	sub	r7,r6
8000c022:	ca ab       	rjmp	8000bf76 <__avr32_f64_mul+0x22>
8000c024:	f4 06 09 4b 	lsl	r11,r10,r6
8000c028:	c6 40       	breq	8000c0f0 <__avr32_f64_mul_res_zero>
8000c02a:	30 0a       	mov	r10,0
8000c02c:	20 b6       	sub	r6,11
8000c02e:	0c 17       	sub	r7,r6
8000c030:	ca 3b       	rjmp	8000bf76 <__avr32_f64_mul+0x22>

8000c032 <__avr32_f64_mul_op2_subnormal>:
8000c032:	e4 19 00 0f 	andh	r9,0xf
8000c036:	f0 0c 12 00 	clz	r12,r8
8000c03a:	f2 05 12 00 	clz	r5,r9
8000c03e:	f7 bc 03 ea 	sublo	r12,-22
8000c042:	f8 05 17 30 	movlo	r5,r12
8000c046:	f7 b5 02 0a 	subhs	r5,10
8000c04a:	e0 45 00 20 	cp.w	r5,32
8000c04e:	c0 d4       	brge	8000c068 <__avr32_f64_mul_op2_subnormal+0x36>
8000c050:	ea 0c 11 20 	rsub	r12,r5,32
8000c054:	f2 05 09 49 	lsl	r9,r9,r5
8000c058:	f0 0c 0a 4c 	lsr	r12,r8,r12
8000c05c:	18 49       	or	r9,r12
8000c05e:	f0 05 09 48 	lsl	r8,r8,r5
8000c062:	20 25       	sub	r5,2
8000c064:	0a 16       	sub	r6,r5
8000c066:	c8 fb       	rjmp	8000bf84 <__avr32_f64_mul+0x30>
8000c068:	f0 05 09 49 	lsl	r9,r8,r5
8000c06c:	c4 20       	breq	8000c0f0 <__avr32_f64_mul_res_zero>
8000c06e:	30 08       	mov	r8,0
8000c070:	20 25       	sub	r5,2
8000c072:	0a 16       	sub	r6,r5
8000c074:	c8 8b       	rjmp	8000bf84 <__avr32_f64_mul+0x30>

8000c076 <__avr32_f64_mul_op_nan_or_inf>:
8000c076:	e4 19 00 0f 	andh	r9,0xf
8000c07a:	e4 1b 00 0f 	andh	r11,0xf
8000c07e:	14 4b       	or	r11,r10
8000c080:	10 49       	or	r9,r8
8000c082:	e0 47 07 ff 	cp.w	r7,2047
8000c086:	c0 91       	brne	8000c098 <__avr32_f64_mul_op1_not_naninf>
8000c088:	58 0b       	cp.w	r11,0
8000c08a:	c3 81       	brne	8000c0fa <__avr32_f64_mul_res_nan>
8000c08c:	e0 46 07 ff 	cp.w	r6,2047
8000c090:	c3 81       	brne	8000c100 <__avr32_f64_mul_res_inf>
8000c092:	58 09       	cp.w	r9,0
8000c094:	c3 60       	breq	8000c100 <__avr32_f64_mul_res_inf>
8000c096:	c3 28       	rjmp	8000c0fa <__avr32_f64_mul_res_nan>

8000c098 <__avr32_f64_mul_op1_not_naninf>:
8000c098:	58 09       	cp.w	r9,0
8000c09a:	c3 30       	breq	8000c100 <__avr32_f64_mul_res_inf>
8000c09c:	c2 f8       	rjmp	8000c0fa <__avr32_f64_mul_res_nan>

8000c09e <__avr32_f64_mul_res_subnormal>:
8000c09e:	5c 3c       	neg	r12
8000c0a0:	2f fc       	sub	r12,-1
8000c0a2:	f1 bc 04 c0 	satu	r12,0x6
8000c0a6:	e0 4c 00 20 	cp.w	r12,32
8000c0aa:	c1 14       	brge	8000c0cc <__avr32_f64_mul_res_subnormal+0x2e>
8000c0ac:	f8 08 11 20 	rsub	r8,r12,32
8000c0b0:	0e 46       	or	r6,r7
8000c0b2:	ee 0c 0a 47 	lsr	r7,r7,r12
8000c0b6:	f4 08 09 49 	lsl	r9,r10,r8
8000c0ba:	12 47       	or	r7,r9
8000c0bc:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000c0c0:	f6 08 09 49 	lsl	r9,r11,r8
8000c0c4:	12 4a       	or	r10,r9
8000c0c6:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000c0ca:	c8 3b       	rjmp	8000bfd0 <__avr32_f64_mul+0x7c>
8000c0cc:	f8 08 11 20 	rsub	r8,r12,32
8000c0d0:	f9 b9 00 00 	moveq	r9,0
8000c0d4:	c0 30       	breq	8000c0da <__avr32_f64_mul_res_subnormal+0x3c>
8000c0d6:	f6 08 09 49 	lsl	r9,r11,r8
8000c0da:	0e 46       	or	r6,r7
8000c0dc:	ed ea 10 16 	or	r6,r6,r10<<0x1
8000c0e0:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000c0e4:	f3 ea 10 07 	or	r7,r9,r10
8000c0e8:	f6 0c 0a 4a 	lsr	r10,r11,r12
8000c0ec:	30 0b       	mov	r11,0
8000c0ee:	c7 1b       	rjmp	8000bfd0 <__avr32_f64_mul+0x7c>

8000c0f0 <__avr32_f64_mul_res_zero>:
8000c0f0:	1c 9b       	mov	r11,lr
8000c0f2:	e6 1b 80 00 	andh	r11,0x8000,COH
8000c0f6:	30 0a       	mov	r10,0
8000c0f8:	d8 22       	popm	r4-r7,pc

8000c0fa <__avr32_f64_mul_res_nan>:
8000c0fa:	3f fb       	mov	r11,-1
8000c0fc:	3f fa       	mov	r10,-1
8000c0fe:	d8 22       	popm	r4-r7,pc

8000c100 <__avr32_f64_mul_res_inf>:
8000c100:	f0 6b 00 00 	mov	r11,-1048576
8000c104:	ed be 00 1f 	bld	lr,0x1f
8000c108:	ef bb 00 1f 	bst	r11,0x1f
8000c10c:	30 0a       	mov	r10,0
8000c10e:	d8 22       	popm	r4-r7,pc

8000c110 <__avr32_f64_mul_op1_zero>:
8000c110:	f7 e9 20 0b 	eor	r11,r11,r9
8000c114:	e6 1b 80 00 	andh	r11,0x8000,COH
8000c118:	f9 d9 c2 8b 	bfextu	r12,r9,0x14,0xb
8000c11c:	e0 4c 07 ff 	cp.w	r12,2047
8000c120:	5e 1c       	retne	r12
8000c122:	3f fa       	mov	r10,-1
8000c124:	3f fb       	mov	r11,-1
8000c126:	5e fc       	retal	r12

8000c128 <__avr32_f64_sub_from_add>:
8000c128:	ee 19 80 00 	eorh	r9,0x8000

8000c12c <__avr32_f64_sub>:
8000c12c:	f7 e9 20 0c 	eor	r12,r11,r9
8000c130:	e0 86 00 ca 	brmi	8000c2c4 <__avr32_f64_add_from_sub>
8000c134:	eb cd 40 e0 	pushm	r5-r7,lr
8000c138:	16 9c       	mov	r12,r11
8000c13a:	e6 1c 80 00 	andh	r12,0x8000,COH
8000c13e:	bf db       	cbr	r11,0x1f
8000c140:	bf d9       	cbr	r9,0x1f
8000c142:	10 3a       	cp.w	r10,r8
8000c144:	f2 0b 13 00 	cpc	r11,r9
8000c148:	c0 92       	brcc	8000c15a <__avr32_f64_sub+0x2e>
8000c14a:	16 97       	mov	r7,r11
8000c14c:	12 9b       	mov	r11,r9
8000c14e:	0e 99       	mov	r9,r7
8000c150:	14 97       	mov	r7,r10
8000c152:	10 9a       	mov	r10,r8
8000c154:	0e 98       	mov	r8,r7
8000c156:	ee 1c 80 00 	eorh	r12,0x8000
8000c15a:	f6 07 16 14 	lsr	r7,r11,0x14
8000c15e:	ab 7b       	lsl	r11,0xb
8000c160:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000c164:	ab 7a       	lsl	r10,0xb
8000c166:	bf bb       	sbr	r11,0x1f
8000c168:	f2 06 16 14 	lsr	r6,r9,0x14
8000c16c:	c4 40       	breq	8000c1f4 <__avr32_f64_sub_opL_subnormal>
8000c16e:	ab 79       	lsl	r9,0xb
8000c170:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000c174:	ab 78       	lsl	r8,0xb
8000c176:	bf b9       	sbr	r9,0x1f

8000c178 <__avr32_f64_sub_opL_subnormal_done>:
8000c178:	e0 47 07 ff 	cp.w	r7,2047
8000c17c:	c4 f0       	breq	8000c21a <__avr32_f64_sub_opH_nan_or_inf>
8000c17e:	0e 26       	rsub	r6,r7
8000c180:	c1 20       	breq	8000c1a4 <__avr32_f64_sub_shift_done>
8000c182:	ec 05 11 20 	rsub	r5,r6,32
8000c186:	e0 46 00 20 	cp.w	r6,32
8000c18a:	c7 c2       	brcc	8000c282 <__avr32_f64_sub_longshift>
8000c18c:	f0 05 09 4e 	lsl	lr,r8,r5
8000c190:	f2 05 09 45 	lsl	r5,r9,r5
8000c194:	f0 06 0a 48 	lsr	r8,r8,r6
8000c198:	f2 06 0a 49 	lsr	r9,r9,r6
8000c19c:	0a 48       	or	r8,r5
8000c19e:	58 0e       	cp.w	lr,0
8000c1a0:	5f 1e       	srne	lr
8000c1a2:	1c 48       	or	r8,lr

8000c1a4 <__avr32_f64_sub_shift_done>:
8000c1a4:	10 1a       	sub	r10,r8
8000c1a6:	f6 09 01 4b 	sbc	r11,r11,r9
8000c1aa:	f6 06 12 00 	clz	r6,r11
8000c1ae:	c0 e0       	breq	8000c1ca <__avr32_f64_sub_longnormalize_done>
8000c1b0:	c7 83       	brcs	8000c2a0 <__avr32_f64_sub_longnormalize>
8000c1b2:	ec 0e 11 20 	rsub	lr,r6,32
8000c1b6:	f6 06 09 4b 	lsl	r11,r11,r6
8000c1ba:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000c1be:	1c 4b       	or	r11,lr
8000c1c0:	f4 06 09 4a 	lsl	r10,r10,r6
8000c1c4:	0c 17       	sub	r7,r6
8000c1c6:	e0 8a 00 39 	brle	8000c238 <__avr32_f64_sub_subnormal_result>

8000c1ca <__avr32_f64_sub_longnormalize_done>:
8000c1ca:	f4 09 15 15 	lsl	r9,r10,0x15
8000c1ce:	ab 9a       	lsr	r10,0xb
8000c1d0:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000c1d4:	ab 9b       	lsr	r11,0xb
8000c1d6:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000c1da:	18 4b       	or	r11,r12

8000c1dc <__avr32_f64_sub_round>:
8000c1dc:	fc 17 80 00 	movh	r7,0x8000
8000c1e0:	ed ba 00 00 	bld	r10,0x0
8000c1e4:	f7 b7 01 ff 	subne	r7,-1
8000c1e8:	0e 39       	cp.w	r9,r7
8000c1ea:	5f 29       	srhs	r9
8000c1ec:	12 0a       	add	r10,r9
8000c1ee:	5c 0b       	acr	r11
8000c1f0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c1f4 <__avr32_f64_sub_opL_subnormal>:
8000c1f4:	ab 79       	lsl	r9,0xb
8000c1f6:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000c1fa:	ab 78       	lsl	r8,0xb
8000c1fc:	f3 e8 10 0e 	or	lr,r9,r8
8000c200:	f9 b6 01 01 	movne	r6,1
8000c204:	ee 0e 11 00 	rsub	lr,r7,0
8000c208:	f9 b7 00 01 	moveq	r7,1
8000c20c:	ef bb 00 1f 	bst	r11,0x1f
8000c210:	f7 ea 10 0e 	or	lr,r11,r10
8000c214:	f9 b7 00 00 	moveq	r7,0
8000c218:	cb 0b       	rjmp	8000c178 <__avr32_f64_sub_opL_subnormal_done>

8000c21a <__avr32_f64_sub_opH_nan_or_inf>:
8000c21a:	bf db       	cbr	r11,0x1f
8000c21c:	f7 ea 10 0e 	or	lr,r11,r10
8000c220:	c0 81       	brne	8000c230 <__avr32_f64_sub_return_nan>
8000c222:	e0 46 07 ff 	cp.w	r6,2047
8000c226:	c0 50       	breq	8000c230 <__avr32_f64_sub_return_nan>
8000c228:	f9 e7 11 4b 	or	r11,r12,r7<<0x14
8000c22c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c230 <__avr32_f64_sub_return_nan>:
8000c230:	3f fa       	mov	r10,-1
8000c232:	3f fb       	mov	r11,-1
8000c234:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c238 <__avr32_f64_sub_subnormal_result>:
8000c238:	5c 37       	neg	r7
8000c23a:	2f f7       	sub	r7,-1
8000c23c:	f1 b7 04 c0 	satu	r7,0x6
8000c240:	e0 47 00 20 	cp.w	r7,32
8000c244:	c1 14       	brge	8000c266 <__avr32_f64_sub_subnormal_result+0x2e>
8000c246:	ee 08 11 20 	rsub	r8,r7,32
8000c24a:	f4 08 09 49 	lsl	r9,r10,r8
8000c24e:	5f 16       	srne	r6
8000c250:	f4 07 0a 4a 	lsr	r10,r10,r7
8000c254:	0c 4a       	or	r10,r6
8000c256:	f6 08 09 49 	lsl	r9,r11,r8
8000c25a:	f5 e9 10 0a 	or	r10,r10,r9
8000c25e:	f4 07 0a 4b 	lsr	r11,r10,r7
8000c262:	30 07       	mov	r7,0
8000c264:	cb 3b       	rjmp	8000c1ca <__avr32_f64_sub_longnormalize_done>
8000c266:	ee 08 11 40 	rsub	r8,r7,64
8000c26a:	f6 08 09 49 	lsl	r9,r11,r8
8000c26e:	14 49       	or	r9,r10
8000c270:	5f 16       	srne	r6
8000c272:	f6 07 0a 4a 	lsr	r10,r11,r7
8000c276:	0c 4a       	or	r10,r6
8000c278:	30 0b       	mov	r11,0
8000c27a:	30 07       	mov	r7,0
8000c27c:	ca 7b       	rjmp	8000c1ca <__avr32_f64_sub_longnormalize_done>
8000c27e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c282 <__avr32_f64_sub_longshift>:
8000c282:	f1 b6 04 c0 	satu	r6,0x6
8000c286:	f0 0e 17 00 	moveq	lr,r8
8000c28a:	c0 40       	breq	8000c292 <__avr32_f64_sub_longshift+0x10>
8000c28c:	f2 05 09 4e 	lsl	lr,r9,r5
8000c290:	10 4e       	or	lr,r8
8000c292:	f2 06 0a 48 	lsr	r8,r9,r6
8000c296:	30 09       	mov	r9,0
8000c298:	58 0e       	cp.w	lr,0
8000c29a:	5f 1e       	srne	lr
8000c29c:	1c 48       	or	r8,lr
8000c29e:	c8 3b       	rjmp	8000c1a4 <__avr32_f64_sub_shift_done>

8000c2a0 <__avr32_f64_sub_longnormalize>:
8000c2a0:	f4 06 12 00 	clz	r6,r10
8000c2a4:	f9 b7 03 00 	movlo	r7,0
8000c2a8:	f9 b6 03 00 	movlo	r6,0
8000c2ac:	f9 bc 03 00 	movlo	r12,0
8000c2b0:	f7 b6 02 e0 	subhs	r6,-32
8000c2b4:	f4 06 09 4b 	lsl	r11,r10,r6
8000c2b8:	30 0a       	mov	r10,0
8000c2ba:	0c 17       	sub	r7,r6
8000c2bc:	fe 9a ff be 	brle	8000c238 <__avr32_f64_sub_subnormal_result>
8000c2c0:	c8 5b       	rjmp	8000c1ca <__avr32_f64_sub_longnormalize_done>
8000c2c2:	d7 03       	nop

8000c2c4 <__avr32_f64_add_from_sub>:
8000c2c4:	ee 19 80 00 	eorh	r9,0x8000

8000c2c8 <__avr32_f64_add>:
8000c2c8:	f7 e9 20 0c 	eor	r12,r11,r9
8000c2cc:	fe 96 ff 2e 	brmi	8000c128 <__avr32_f64_sub_from_add>
8000c2d0:	eb cd 40 e0 	pushm	r5-r7,lr
8000c2d4:	16 9c       	mov	r12,r11
8000c2d6:	e6 1c 80 00 	andh	r12,0x8000,COH
8000c2da:	bf db       	cbr	r11,0x1f
8000c2dc:	bf d9       	cbr	r9,0x1f
8000c2de:	12 3b       	cp.w	r11,r9
8000c2e0:	c0 72       	brcc	8000c2ee <__avr32_f64_add+0x26>
8000c2e2:	16 97       	mov	r7,r11
8000c2e4:	12 9b       	mov	r11,r9
8000c2e6:	0e 99       	mov	r9,r7
8000c2e8:	14 97       	mov	r7,r10
8000c2ea:	10 9a       	mov	r10,r8
8000c2ec:	0e 98       	mov	r8,r7
8000c2ee:	30 0e       	mov	lr,0
8000c2f0:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000c2f4:	f7 db c0 14 	bfextu	r11,r11,0x0,0x14
8000c2f8:	b5 ab       	sbr	r11,0x14
8000c2fa:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000c2fe:	c6 20       	breq	8000c3c2 <__avr32_f64_add_op2_subnormal>
8000c300:	f3 d9 c0 14 	bfextu	r9,r9,0x0,0x14
8000c304:	b5 a9       	sbr	r9,0x14
8000c306:	e0 47 07 ff 	cp.w	r7,2047
8000c30a:	c2 80       	breq	8000c35a <__avr32_f64_add_opH_nan_or_inf>
8000c30c:	0e 26       	rsub	r6,r7
8000c30e:	c1 20       	breq	8000c332 <__avr32_f64_add_shift_done>
8000c310:	e0 46 00 36 	cp.w	r6,54
8000c314:	c1 52       	brcc	8000c33e <__avr32_f64_add_res_of_done>
8000c316:	ec 05 11 20 	rsub	r5,r6,32
8000c31a:	e0 46 00 20 	cp.w	r6,32
8000c31e:	c3 52       	brcc	8000c388 <__avr32_f64_add_longshift>
8000c320:	f0 05 09 4e 	lsl	lr,r8,r5
8000c324:	f2 05 09 45 	lsl	r5,r9,r5
8000c328:	f0 06 0a 48 	lsr	r8,r8,r6
8000c32c:	f2 06 0a 49 	lsr	r9,r9,r6
8000c330:	0a 48       	or	r8,r5

8000c332 <__avr32_f64_add_shift_done>:
8000c332:	10 0a       	add	r10,r8
8000c334:	f6 09 00 4b 	adc	r11,r11,r9
8000c338:	ed bb 00 15 	bld	r11,0x15
8000c33c:	c3 40       	breq	8000c3a4 <__avr32_f64_add_res_of>

8000c33e <__avr32_f64_add_res_of_done>:
8000c33e:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000c342:	18 4b       	or	r11,r12

8000c344 <__avr32_f64_add_round>:
8000c344:	f9 da c0 01 	bfextu	r12,r10,0x0,0x1
8000c348:	18 4e       	or	lr,r12
8000c34a:	ee 1e 80 00 	eorh	lr,0x8000
8000c34e:	f1 be 04 20 	satu	lr,0x1
8000c352:	1c 0a       	add	r10,lr
8000c354:	5c 0b       	acr	r11
8000c356:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c35a <__avr32_f64_add_opH_nan_or_inf>:
8000c35a:	b5 cb       	cbr	r11,0x14
8000c35c:	f7 ea 10 0e 	or	lr,r11,r10
8000c360:	c1 01       	brne	8000c380 <__avr32_f64_add_return_nan>
8000c362:	e0 46 07 ff 	cp.w	r6,2047
8000c366:	c0 30       	breq	8000c36c <__avr32_f64_add_opL_nan_or_inf>
8000c368:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c36c <__avr32_f64_add_opL_nan_or_inf>:
8000c36c:	b5 c9       	cbr	r9,0x14
8000c36e:	f3 e8 10 0e 	or	lr,r9,r8
8000c372:	c0 71       	brne	8000c380 <__avr32_f64_add_return_nan>
8000c374:	30 0a       	mov	r10,0
8000c376:	fc 1b 7f f0 	movh	r11,0x7ff0
8000c37a:	18 4b       	or	r11,r12
8000c37c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c380 <__avr32_f64_add_return_nan>:
8000c380:	3f fa       	mov	r10,-1
8000c382:	3f fb       	mov	r11,-1
8000c384:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c388 <__avr32_f64_add_longshift>:
8000c388:	f1 b6 04 c0 	satu	r6,0x6
8000c38c:	f0 0e 17 00 	moveq	lr,r8
8000c390:	c0 60       	breq	8000c39c <__avr32_f64_add_longshift+0x14>
8000c392:	f2 05 09 4e 	lsl	lr,r9,r5
8000c396:	58 08       	cp.w	r8,0
8000c398:	5f 18       	srne	r8
8000c39a:	10 4e       	or	lr,r8
8000c39c:	f2 06 0a 48 	lsr	r8,r9,r6
8000c3a0:	30 09       	mov	r9,0
8000c3a2:	cc 8b       	rjmp	8000c332 <__avr32_f64_add_shift_done>

8000c3a4 <__avr32_f64_add_res_of>:
8000c3a4:	fd ee 10 1e 	or	lr,lr,lr<<0x1
8000c3a8:	a1 9b       	lsr	r11,0x1
8000c3aa:	5d 0a       	ror	r10
8000c3ac:	5d 0e       	ror	lr
8000c3ae:	2f f7       	sub	r7,-1
8000c3b0:	e0 47 07 ff 	cp.w	r7,2047
8000c3b4:	f9 ba 00 00 	moveq	r10,0
8000c3b8:	f9 bb 00 00 	moveq	r11,0
8000c3bc:	f9 be 00 00 	moveq	lr,0
8000c3c0:	cb fb       	rjmp	8000c33e <__avr32_f64_add_res_of_done>

8000c3c2 <__avr32_f64_add_op2_subnormal>:
8000c3c2:	30 16       	mov	r6,1
8000c3c4:	58 07       	cp.w	r7,0
8000c3c6:	ca 01       	brne	8000c306 <__avr32_f64_add+0x3e>
8000c3c8:	b5 cb       	cbr	r11,0x14
8000c3ca:	10 0a       	add	r10,r8
8000c3cc:	f6 09 00 4b 	adc	r11,r11,r9
8000c3d0:	18 4b       	or	r11,r12
8000c3d2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000c3d6:	d7 03       	nop

8000c3d8 <__avr32_f64_to_u32>:
8000c3d8:	58 0b       	cp.w	r11,0
8000c3da:	5e 6d       	retmi	0

8000c3dc <__avr32_f64_to_s32>:
8000c3dc:	f6 0c 15 01 	lsl	r12,r11,0x1
8000c3e0:	b5 9c       	lsr	r12,0x15
8000c3e2:	e0 2c 03 ff 	sub	r12,1023
8000c3e6:	5e 3d       	retlo	0
8000c3e8:	f8 0c 11 1f 	rsub	r12,r12,31
8000c3ec:	16 99       	mov	r9,r11
8000c3ee:	ab 7b       	lsl	r11,0xb
8000c3f0:	bf bb       	sbr	r11,0x1f
8000c3f2:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000c3f6:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000c3fa:	a1 79       	lsl	r9,0x1
8000c3fc:	5e 2b       	reths	r11
8000c3fe:	5c 3b       	neg	r11
8000c400:	5e fb       	retal	r11

8000c402 <__avr32_u32_to_f64>:
8000c402:	f8 cb 00 00 	sub	r11,r12,0
8000c406:	30 0c       	mov	r12,0
8000c408:	c0 38       	rjmp	8000c40e <__avr32_s32_to_f64+0x4>

8000c40a <__avr32_s32_to_f64>:
8000c40a:	18 9b       	mov	r11,r12
8000c40c:	5c 4b       	abs	r11
8000c40e:	30 0a       	mov	r10,0
8000c410:	5e 0b       	reteq	r11
8000c412:	d4 01       	pushm	lr
8000c414:	e0 69 04 1e 	mov	r9,1054
8000c418:	f6 08 12 00 	clz	r8,r11
8000c41c:	c1 70       	breq	8000c44a <__avr32_s32_to_f64+0x40>
8000c41e:	c0 c3       	brcs	8000c436 <__avr32_s32_to_f64+0x2c>
8000c420:	f0 0e 11 20 	rsub	lr,r8,32
8000c424:	f6 08 09 4b 	lsl	r11,r11,r8
8000c428:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000c42c:	1c 4b       	or	r11,lr
8000c42e:	f4 08 09 4a 	lsl	r10,r10,r8
8000c432:	10 19       	sub	r9,r8
8000c434:	c0 b8       	rjmp	8000c44a <__avr32_s32_to_f64+0x40>
8000c436:	f4 08 12 00 	clz	r8,r10
8000c43a:	f9 b8 03 00 	movlo	r8,0
8000c43e:	f7 b8 02 e0 	subhs	r8,-32
8000c442:	f4 08 09 4b 	lsl	r11,r10,r8
8000c446:	30 0a       	mov	r10,0
8000c448:	10 19       	sub	r9,r8
8000c44a:	58 09       	cp.w	r9,0
8000c44c:	e0 89 00 30 	brgt	8000c4ac <__avr32_s32_to_f64+0xa2>
8000c450:	5c 39       	neg	r9
8000c452:	2f f9       	sub	r9,-1
8000c454:	e0 49 00 36 	cp.w	r9,54
8000c458:	c0 43       	brcs	8000c460 <__avr32_s32_to_f64+0x56>
8000c45a:	30 0b       	mov	r11,0
8000c45c:	30 0a       	mov	r10,0
8000c45e:	c2 68       	rjmp	8000c4aa <__avr32_s32_to_f64+0xa0>
8000c460:	2f 69       	sub	r9,-10
8000c462:	f2 08 11 20 	rsub	r8,r9,32
8000c466:	e0 49 00 20 	cp.w	r9,32
8000c46a:	c0 b2       	brcc	8000c480 <__avr32_s32_to_f64+0x76>
8000c46c:	f4 08 09 4e 	lsl	lr,r10,r8
8000c470:	f6 08 09 48 	lsl	r8,r11,r8
8000c474:	f4 09 0a 4a 	lsr	r10,r10,r9
8000c478:	f6 09 0a 4b 	lsr	r11,r11,r9
8000c47c:	10 4b       	or	r11,r8
8000c47e:	c0 88       	rjmp	8000c48e <__avr32_s32_to_f64+0x84>
8000c480:	f6 08 09 4e 	lsl	lr,r11,r8
8000c484:	14 4e       	or	lr,r10
8000c486:	16 9a       	mov	r10,r11
8000c488:	30 0b       	mov	r11,0
8000c48a:	f4 09 0a 4a 	lsr	r10,r10,r9
8000c48e:	ed ba 00 00 	bld	r10,0x0
8000c492:	c0 92       	brcc	8000c4a4 <__avr32_s32_to_f64+0x9a>
8000c494:	1c 7e       	tst	lr,lr
8000c496:	c0 41       	brne	8000c49e <__avr32_s32_to_f64+0x94>
8000c498:	ed ba 00 01 	bld	r10,0x1
8000c49c:	c0 42       	brcc	8000c4a4 <__avr32_s32_to_f64+0x9a>
8000c49e:	2f fa       	sub	r10,-1
8000c4a0:	f7 bb 02 ff 	subhs	r11,-1
8000c4a4:	5c fc       	rol	r12
8000c4a6:	5d 0b       	ror	r11
8000c4a8:	5d 0a       	ror	r10
8000c4aa:	d8 02       	popm	pc
8000c4ac:	e0 68 03 ff 	mov	r8,1023
8000c4b0:	ed ba 00 0b 	bld	r10,0xb
8000c4b4:	f7 b8 00 ff 	subeq	r8,-1
8000c4b8:	10 0a       	add	r10,r8
8000c4ba:	5c 0b       	acr	r11
8000c4bc:	f7 b9 03 fe 	sublo	r9,-2
8000c4c0:	e0 49 07 ff 	cp.w	r9,2047
8000c4c4:	c0 55       	brlt	8000c4ce <__avr32_s32_to_f64+0xc4>
8000c4c6:	30 0a       	mov	r10,0
8000c4c8:	fc 1b ff e0 	movh	r11,0xffe0
8000c4cc:	c0 c8       	rjmp	8000c4e4 <__floatsidf_return_op1>
8000c4ce:	ed bb 00 1f 	bld	r11,0x1f
8000c4d2:	f7 b9 01 01 	subne	r9,1
8000c4d6:	ab 9a       	lsr	r10,0xb
8000c4d8:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000c4dc:	a1 7b       	lsl	r11,0x1
8000c4de:	ab 9b       	lsr	r11,0xb
8000c4e0:	f7 e9 11 5b 	or	r11,r11,r9<<0x15

8000c4e4 <__floatsidf_return_op1>:
8000c4e4:	a1 7c       	lsl	r12,0x1
8000c4e6:	5d 0b       	ror	r11
8000c4e8:	d8 02       	popm	pc

8000c4ea <__avr32_f64_cmp_eq>:
8000c4ea:	10 3a       	cp.w	r10,r8
8000c4ec:	f2 0b 13 00 	cpc	r11,r9
8000c4f0:	c0 80       	breq	8000c500 <__avr32_f64_cmp_eq+0x16>
8000c4f2:	a1 7b       	lsl	r11,0x1
8000c4f4:	a1 79       	lsl	r9,0x1
8000c4f6:	14 4b       	or	r11,r10
8000c4f8:	12 4b       	or	r11,r9
8000c4fa:	10 4b       	or	r11,r8
8000c4fc:	5e 0f       	reteq	1
8000c4fe:	5e fd       	retal	0
8000c500:	a1 7b       	lsl	r11,0x1
8000c502:	fc 1c ff e0 	movh	r12,0xffe0
8000c506:	58 0a       	cp.w	r10,0
8000c508:	f8 0b 13 00 	cpc	r11,r12
8000c50c:	5e 8f       	retls	1
8000c50e:	5e fd       	retal	0

8000c510 <__avr32_f64_cmp_ge>:
8000c510:	1a de       	st.w	--sp,lr
8000c512:	1a d7       	st.w	--sp,r7
8000c514:	a1 7b       	lsl	r11,0x1
8000c516:	5f 3c       	srlo	r12
8000c518:	a1 79       	lsl	r9,0x1
8000c51a:	5f 37       	srlo	r7
8000c51c:	5c fc       	rol	r12
8000c51e:	fc 1e ff e0 	movh	lr,0xffe0
8000c522:	58 0a       	cp.w	r10,0
8000c524:	fc 0b 13 00 	cpc	r11,lr
8000c528:	e0 8b 00 1d 	brhi	8000c562 <__avr32_f64_cmp_ge+0x52>
8000c52c:	58 08       	cp.w	r8,0
8000c52e:	fc 09 13 00 	cpc	r9,lr
8000c532:	e0 8b 00 18 	brhi	8000c562 <__avr32_f64_cmp_ge+0x52>
8000c536:	58 0b       	cp.w	r11,0
8000c538:	f5 ba 00 00 	subfeq	r10,0
8000c53c:	c1 50       	breq	8000c566 <__avr32_f64_cmp_ge+0x56>
8000c53e:	1b 07       	ld.w	r7,sp++
8000c540:	1b 0e       	ld.w	lr,sp++
8000c542:	58 3c       	cp.w	r12,3
8000c544:	c0 a0       	breq	8000c558 <__avr32_f64_cmp_ge+0x48>
8000c546:	58 1c       	cp.w	r12,1
8000c548:	c0 33       	brcs	8000c54e <__avr32_f64_cmp_ge+0x3e>
8000c54a:	5e 0f       	reteq	1
8000c54c:	5e 1d       	retne	0
8000c54e:	10 3a       	cp.w	r10,r8
8000c550:	f2 0b 13 00 	cpc	r11,r9
8000c554:	5e 2f       	reths	1
8000c556:	5e 3d       	retlo	0
8000c558:	14 38       	cp.w	r8,r10
8000c55a:	f6 09 13 00 	cpc	r9,r11
8000c55e:	5e 2f       	reths	1
8000c560:	5e 3d       	retlo	0
8000c562:	1b 07       	ld.w	r7,sp++
8000c564:	d8 0a       	popm	pc,r12=0
8000c566:	58 17       	cp.w	r7,1
8000c568:	5f 0c       	sreq	r12
8000c56a:	58 09       	cp.w	r9,0
8000c56c:	f5 b8 00 00 	subfeq	r8,0
8000c570:	1b 07       	ld.w	r7,sp++
8000c572:	1b 0e       	ld.w	lr,sp++
8000c574:	5e 0f       	reteq	1
8000c576:	5e fc       	retal	r12

8000c578 <__avr32_f64_cmp_lt>:
8000c578:	1a de       	st.w	--sp,lr
8000c57a:	1a d7       	st.w	--sp,r7
8000c57c:	a1 7b       	lsl	r11,0x1
8000c57e:	5f 3c       	srlo	r12
8000c580:	a1 79       	lsl	r9,0x1
8000c582:	5f 37       	srlo	r7
8000c584:	5c fc       	rol	r12
8000c586:	fc 1e ff e0 	movh	lr,0xffe0
8000c58a:	58 0a       	cp.w	r10,0
8000c58c:	fc 0b 13 00 	cpc	r11,lr
8000c590:	e0 8b 00 1d 	brhi	8000c5ca <__avr32_f64_cmp_lt+0x52>
8000c594:	58 08       	cp.w	r8,0
8000c596:	fc 09 13 00 	cpc	r9,lr
8000c59a:	e0 8b 00 18 	brhi	8000c5ca <__avr32_f64_cmp_lt+0x52>
8000c59e:	58 0b       	cp.w	r11,0
8000c5a0:	f5 ba 00 00 	subfeq	r10,0
8000c5a4:	c1 50       	breq	8000c5ce <__avr32_f64_cmp_lt+0x56>
8000c5a6:	1b 07       	ld.w	r7,sp++
8000c5a8:	1b 0e       	ld.w	lr,sp++
8000c5aa:	58 3c       	cp.w	r12,3
8000c5ac:	c0 a0       	breq	8000c5c0 <__avr32_f64_cmp_lt+0x48>
8000c5ae:	58 1c       	cp.w	r12,1
8000c5b0:	c0 33       	brcs	8000c5b6 <__avr32_f64_cmp_lt+0x3e>
8000c5b2:	5e 0d       	reteq	0
8000c5b4:	5e 1f       	retne	1
8000c5b6:	10 3a       	cp.w	r10,r8
8000c5b8:	f2 0b 13 00 	cpc	r11,r9
8000c5bc:	5e 2d       	reths	0
8000c5be:	5e 3f       	retlo	1
8000c5c0:	14 38       	cp.w	r8,r10
8000c5c2:	f6 09 13 00 	cpc	r9,r11
8000c5c6:	5e 2d       	reths	0
8000c5c8:	5e 3f       	retlo	1
8000c5ca:	1b 07       	ld.w	r7,sp++
8000c5cc:	d8 0a       	popm	pc,r12=0
8000c5ce:	58 17       	cp.w	r7,1
8000c5d0:	5f 1c       	srne	r12
8000c5d2:	58 09       	cp.w	r9,0
8000c5d4:	f5 b8 00 00 	subfeq	r8,0
8000c5d8:	1b 07       	ld.w	r7,sp++
8000c5da:	1b 0e       	ld.w	lr,sp++
8000c5dc:	5e 0d       	reteq	0
8000c5de:	5e fc       	retal	r12

8000c5e0 <__avr32_f64_div>:
8000c5e0:	eb cd 40 ff 	pushm	r0-r7,lr
8000c5e4:	f7 e9 20 0e 	eor	lr,r11,r9
8000c5e8:	f6 07 16 14 	lsr	r7,r11,0x14
8000c5ec:	a9 7b       	lsl	r11,0x9
8000c5ee:	f7 ea 13 7b 	or	r11,r11,r10>>0x17
8000c5f2:	a9 7a       	lsl	r10,0x9
8000c5f4:	bd bb       	sbr	r11,0x1d
8000c5f6:	e4 1b 3f ff 	andh	r11,0x3fff
8000c5fa:	ab d7       	cbr	r7,0xb
8000c5fc:	e0 80 00 cc 	breq	8000c794 <__avr32_f64_div_round_subnormal+0x54>
8000c600:	e0 47 07 ff 	cp.w	r7,2047
8000c604:	e0 84 00 b5 	brge	8000c76e <__avr32_f64_div_round_subnormal+0x2e>
8000c608:	f2 06 16 14 	lsr	r6,r9,0x14
8000c60c:	a9 79       	lsl	r9,0x9
8000c60e:	f3 e8 13 79 	or	r9,r9,r8>>0x17
8000c612:	a9 78       	lsl	r8,0x9
8000c614:	bd b9       	sbr	r9,0x1d
8000c616:	e4 19 3f ff 	andh	r9,0x3fff
8000c61a:	ab d6       	cbr	r6,0xb
8000c61c:	e0 80 00 e2 	breq	8000c7e0 <__avr32_f64_div_round_subnormal+0xa0>
8000c620:	e0 46 07 ff 	cp.w	r6,2047
8000c624:	e0 84 00 b2 	brge	8000c788 <__avr32_f64_div_round_subnormal+0x48>
8000c628:	0c 17       	sub	r7,r6
8000c62a:	fe 37 fc 01 	sub	r7,-1023
8000c62e:	fc 1c 80 00 	movh	r12,0x8000
8000c632:	f8 03 16 01 	lsr	r3,r12,0x1
8000c636:	e9 d9 c3 62 	bfextu	r4,r9,0x1b,0x2
8000c63a:	5c d4       	com	r4
8000c63c:	e7 d4 d3 82 	bfins	r3,r4,0x1c,0x2
8000c640:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c644:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000c648:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c64c:	ea 03 15 02 	lsl	r3,r5,0x2
8000c650:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c654:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000c658:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c65c:	ea 03 15 02 	lsl	r3,r5,0x2
8000c660:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c664:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000c668:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c66c:	ea 03 15 02 	lsl	r3,r5,0x2
8000c670:	e6 08 06 40 	mulu.d	r0,r3,r8
8000c674:	e4 09 07 40 	macu.d	r0,r2,r9
8000c678:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c67c:	02 04       	add	r4,r1
8000c67e:	5c 05       	acr	r5
8000c680:	a3 65       	lsl	r5,0x2
8000c682:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000c686:	a3 64       	lsl	r4,0x2
8000c688:	5c 34       	neg	r4
8000c68a:	f8 05 01 45 	sbc	r5,r12,r5
8000c68e:	e6 04 06 40 	mulu.d	r0,r3,r4
8000c692:	e4 05 07 40 	macu.d	r0,r2,r5
8000c696:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c69a:	02 04       	add	r4,r1
8000c69c:	5c 05       	acr	r5
8000c69e:	ea 03 15 02 	lsl	r3,r5,0x2
8000c6a2:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000c6a6:	e8 02 15 02 	lsl	r2,r4,0x2
8000c6aa:	e6 08 06 40 	mulu.d	r0,r3,r8
8000c6ae:	e4 09 07 40 	macu.d	r0,r2,r9
8000c6b2:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c6b6:	02 04       	add	r4,r1
8000c6b8:	5c 05       	acr	r5
8000c6ba:	a3 65       	lsl	r5,0x2
8000c6bc:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000c6c0:	a3 64       	lsl	r4,0x2
8000c6c2:	5c 34       	neg	r4
8000c6c4:	f8 05 01 45 	sbc	r5,r12,r5
8000c6c8:	e6 04 06 40 	mulu.d	r0,r3,r4
8000c6cc:	e4 05 07 40 	macu.d	r0,r2,r5
8000c6d0:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c6d4:	02 04       	add	r4,r1
8000c6d6:	5c 05       	acr	r5
8000c6d8:	ea 03 15 02 	lsl	r3,r5,0x2
8000c6dc:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000c6e0:	e8 02 15 02 	lsl	r2,r4,0x2
8000c6e4:	e6 0a 06 40 	mulu.d	r0,r3,r10
8000c6e8:	e4 0b 07 40 	macu.d	r0,r2,r11
8000c6ec:	e6 0b 06 42 	mulu.d	r2,r3,r11
8000c6f0:	02 02       	add	r2,r1
8000c6f2:	5c 03       	acr	r3
8000c6f4:	ed b3 00 1c 	bld	r3,0x1c
8000c6f8:	c0 90       	breq	8000c70a <__avr32_f64_div+0x12a>
8000c6fa:	a1 72       	lsl	r2,0x1
8000c6fc:	5c f3       	rol	r3
8000c6fe:	20 17       	sub	r7,1
8000c700:	a3 9a       	lsr	r10,0x3
8000c702:	f5 eb 11 da 	or	r10,r10,r11<<0x1d
8000c706:	a3 9b       	lsr	r11,0x3
8000c708:	c0 58       	rjmp	8000c712 <__avr32_f64_div+0x132>
8000c70a:	a5 8a       	lsr	r10,0x4
8000c70c:	f5 eb 11 ca 	or	r10,r10,r11<<0x1c
8000c710:	a5 8b       	lsr	r11,0x4
8000c712:	58 07       	cp.w	r7,0
8000c714:	e0 8a 00 8b 	brle	8000c82a <__avr32_f64_div_res_subnormal>
8000c718:	e0 12 ff 00 	andl	r2,0xff00
8000c71c:	e8 12 00 80 	orl	r2,0x80
8000c720:	e6 08 06 40 	mulu.d	r0,r3,r8
8000c724:	e4 09 07 40 	macu.d	r0,r2,r9
8000c728:	e4 08 06 44 	mulu.d	r4,r2,r8
8000c72c:	e6 09 06 48 	mulu.d	r8,r3,r9
8000c730:	00 05       	add	r5,r0
8000c732:	f0 01 00 48 	adc	r8,r8,r1
8000c736:	5c 09       	acr	r9
8000c738:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000c73c:	58 04       	cp.w	r4,0
8000c73e:	5c 25       	cpc	r5

8000c740 <__avr32_f64_div_round_subnormal>:
8000c740:	f4 08 13 00 	cpc	r8,r10
8000c744:	f6 09 13 00 	cpc	r9,r11
8000c748:	5f 36       	srlo	r6
8000c74a:	f8 06 17 00 	moveq	r6,r12
8000c74e:	e4 0a 16 08 	lsr	r10,r2,0x8
8000c752:	f5 e3 11 8a 	or	r10,r10,r3<<0x18
8000c756:	e6 0b 16 08 	lsr	r11,r3,0x8
8000c75a:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000c75e:	ed be 00 1f 	bld	lr,0x1f
8000c762:	ef bb 00 1f 	bst	r11,0x1f
8000c766:	0c 0a       	add	r10,r6
8000c768:	5c 0b       	acr	r11
8000c76a:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000c76e:	e4 1b 00 0f 	andh	r11,0xf
8000c772:	14 4b       	or	r11,r10
8000c774:	e0 81 00 a7 	brne	8000c8c2 <__avr32_f64_div_res_subnormal+0x98>
8000c778:	f2 06 16 14 	lsr	r6,r9,0x14
8000c77c:	ab d6       	cbr	r6,0xb
8000c77e:	e0 46 07 ff 	cp.w	r6,2047
8000c782:	e0 81 00 a4 	brne	8000c8ca <__avr32_f64_div_res_subnormal+0xa0>
8000c786:	c9 e8       	rjmp	8000c8c2 <__avr32_f64_div_res_subnormal+0x98>
8000c788:	e4 19 00 0f 	andh	r9,0xf
8000c78c:	10 49       	or	r9,r8
8000c78e:	e0 81 00 9a 	brne	8000c8c2 <__avr32_f64_div_res_subnormal+0x98>
8000c792:	c9 28       	rjmp	8000c8b6 <__avr32_f64_div_res_subnormal+0x8c>
8000c794:	a3 7b       	lsl	r11,0x3
8000c796:	f7 ea 13 db 	or	r11,r11,r10>>0x1d
8000c79a:	a3 7a       	lsl	r10,0x3
8000c79c:	f5 eb 10 04 	or	r4,r10,r11
8000c7a0:	e0 80 00 a0 	breq	8000c8e0 <__avr32_f64_div_op1_zero>
8000c7a4:	f6 04 12 00 	clz	r4,r11
8000c7a8:	c1 70       	breq	8000c7d6 <__avr32_f64_div_round_subnormal+0x96>
8000c7aa:	c0 c3       	brcs	8000c7c2 <__avr32_f64_div_round_subnormal+0x82>
8000c7ac:	e8 05 11 20 	rsub	r5,r4,32
8000c7b0:	f6 04 09 4b 	lsl	r11,r11,r4
8000c7b4:	f4 05 0a 45 	lsr	r5,r10,r5
8000c7b8:	0a 4b       	or	r11,r5
8000c7ba:	f4 04 09 4a 	lsl	r10,r10,r4
8000c7be:	08 17       	sub	r7,r4
8000c7c0:	c0 b8       	rjmp	8000c7d6 <__avr32_f64_div_round_subnormal+0x96>
8000c7c2:	f4 04 12 00 	clz	r4,r10
8000c7c6:	f9 b4 03 00 	movlo	r4,0
8000c7ca:	f7 b4 02 e0 	subhs	r4,-32
8000c7ce:	f4 04 09 4b 	lsl	r11,r10,r4
8000c7d2:	30 0a       	mov	r10,0
8000c7d4:	08 17       	sub	r7,r4
8000c7d6:	a3 8a       	lsr	r10,0x2
8000c7d8:	f5 eb 11 ea 	or	r10,r10,r11<<0x1e
8000c7dc:	a3 8b       	lsr	r11,0x2
8000c7de:	c1 1b       	rjmp	8000c600 <__avr32_f64_div+0x20>
8000c7e0:	a3 79       	lsl	r9,0x3
8000c7e2:	f3 e8 13 d9 	or	r9,r9,r8>>0x1d
8000c7e6:	a3 78       	lsl	r8,0x3
8000c7e8:	f3 e8 10 04 	or	r4,r9,r8
8000c7ec:	c6 f0       	breq	8000c8ca <__avr32_f64_div_res_subnormal+0xa0>
8000c7ee:	f2 04 12 00 	clz	r4,r9
8000c7f2:	c1 70       	breq	8000c820 <__avr32_f64_div_round_subnormal+0xe0>
8000c7f4:	c0 c3       	brcs	8000c80c <__avr32_f64_div_round_subnormal+0xcc>
8000c7f6:	e8 05 11 20 	rsub	r5,r4,32
8000c7fa:	f2 04 09 49 	lsl	r9,r9,r4
8000c7fe:	f0 05 0a 45 	lsr	r5,r8,r5
8000c802:	0a 49       	or	r9,r5
8000c804:	f0 04 09 48 	lsl	r8,r8,r4
8000c808:	08 16       	sub	r6,r4
8000c80a:	c0 b8       	rjmp	8000c820 <__avr32_f64_div_round_subnormal+0xe0>
8000c80c:	f0 04 12 00 	clz	r4,r8
8000c810:	f9 b4 03 00 	movlo	r4,0
8000c814:	f7 b4 02 e0 	subhs	r4,-32
8000c818:	f0 04 09 49 	lsl	r9,r8,r4
8000c81c:	30 08       	mov	r8,0
8000c81e:	08 16       	sub	r6,r4
8000c820:	a3 88       	lsr	r8,0x2
8000c822:	f1 e9 11 e8 	or	r8,r8,r9<<0x1e
8000c826:	a3 89       	lsr	r9,0x2
8000c828:	cf ca       	rjmp	8000c620 <__avr32_f64_div+0x40>

8000c82a <__avr32_f64_div_res_subnormal>:
8000c82a:	5c 37       	neg	r7
8000c82c:	2f f7       	sub	r7,-1
8000c82e:	f1 b7 04 c0 	satu	r7,0x6
8000c832:	e0 47 00 20 	cp.w	r7,32
8000c836:	c1 54       	brge	8000c860 <__avr32_f64_div_res_subnormal+0x36>
8000c838:	ee 06 11 20 	rsub	r6,r7,32
8000c83c:	e4 07 0a 42 	lsr	r2,r2,r7
8000c840:	e6 06 09 4c 	lsl	r12,r3,r6
8000c844:	18 42       	or	r2,r12
8000c846:	e6 07 0a 43 	lsr	r3,r3,r7
8000c84a:	f4 06 09 41 	lsl	r1,r10,r6
8000c84e:	f4 07 0a 4a 	lsr	r10,r10,r7
8000c852:	f6 06 09 4c 	lsl	r12,r11,r6
8000c856:	18 4a       	or	r10,r12
8000c858:	f6 07 0a 4b 	lsr	r11,r11,r7
8000c85c:	30 00       	mov	r0,0
8000c85e:	c1 58       	rjmp	8000c888 <__avr32_f64_div_res_subnormal+0x5e>
8000c860:	ee 06 11 20 	rsub	r6,r7,32
8000c864:	f9 b0 00 00 	moveq	r0,0
8000c868:	f9 bc 00 00 	moveq	r12,0
8000c86c:	c0 50       	breq	8000c876 <__avr32_f64_div_res_subnormal+0x4c>
8000c86e:	f4 06 09 40 	lsl	r0,r10,r6
8000c872:	f6 06 09 4c 	lsl	r12,r11,r6
8000c876:	e6 07 0a 42 	lsr	r2,r3,r7
8000c87a:	30 03       	mov	r3,0
8000c87c:	f4 07 0a 41 	lsr	r1,r10,r7
8000c880:	18 41       	or	r1,r12
8000c882:	f6 07 0a 4a 	lsr	r10,r11,r7
8000c886:	30 0b       	mov	r11,0
8000c888:	e0 12 ff 00 	andl	r2,0xff00
8000c88c:	e8 12 00 80 	orl	r2,0x80
8000c890:	e6 08 06 46 	mulu.d	r6,r3,r8
8000c894:	e4 09 07 46 	macu.d	r6,r2,r9
8000c898:	e4 08 06 44 	mulu.d	r4,r2,r8
8000c89c:	e6 09 06 48 	mulu.d	r8,r3,r9
8000c8a0:	0c 05       	add	r5,r6
8000c8a2:	f0 07 00 48 	adc	r8,r8,r7
8000c8a6:	5c 09       	acr	r9
8000c8a8:	30 07       	mov	r7,0
8000c8aa:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000c8ae:	00 34       	cp.w	r4,r0
8000c8b0:	e2 05 13 00 	cpc	r5,r1
8000c8b4:	c4 6b       	rjmp	8000c740 <__avr32_f64_div_round_subnormal>
8000c8b6:	1c 9b       	mov	r11,lr
8000c8b8:	e6 1b 80 00 	andh	r11,0x8000,COH
8000c8bc:	30 0a       	mov	r10,0
8000c8be:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000c8c2:	3f fb       	mov	r11,-1
8000c8c4:	30 0a       	mov	r10,0
8000c8c6:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000c8ca:	f5 eb 10 04 	or	r4,r10,r11
8000c8ce:	c0 90       	breq	8000c8e0 <__avr32_f64_div_op1_zero>
8000c8d0:	1c 9b       	mov	r11,lr
8000c8d2:	e6 1b 80 00 	andh	r11,0x8000,COH
8000c8d6:	ea 1b 7f f0 	orh	r11,0x7ff0
8000c8da:	30 0a       	mov	r10,0
8000c8dc:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc

8000c8e0 <__avr32_f64_div_op1_zero>:
8000c8e0:	f1 e9 10 15 	or	r5,r8,r9<<0x1
8000c8e4:	ce f0       	breq	8000c8c2 <__avr32_f64_div_res_subnormal+0x98>
8000c8e6:	e9 d9 c2 8b 	bfextu	r4,r9,0x14,0xb
8000c8ea:	e0 44 07 ff 	cp.w	r4,2047
8000c8ee:	ce 41       	brne	8000c8b6 <__avr32_f64_div_res_subnormal+0x8c>
8000c8f0:	f1 e9 10 c5 	or	r5,r8,r9<<0xc
8000c8f4:	ce 10       	breq	8000c8b6 <__avr32_f64_div_res_subnormal+0x8c>
8000c8f6:	ce 6b       	rjmp	8000c8c2 <__avr32_f64_div_res_subnormal+0x98>

8000c8f8 <__avr32_udiv64>:
8000c8f8:	d4 31       	pushm	r0-r7,lr
8000c8fa:	1a 97       	mov	r7,sp
8000c8fc:	20 3d       	sub	sp,12
8000c8fe:	10 9c       	mov	r12,r8
8000c900:	12 9e       	mov	lr,r9
8000c902:	14 93       	mov	r3,r10
8000c904:	58 09       	cp.w	r9,0
8000c906:	e0 81 00 bd 	brne	8000ca80 <__avr32_udiv64+0x188>
8000c90a:	16 38       	cp.w	r8,r11
8000c90c:	e0 88 00 40 	brls	8000c98c <__avr32_udiv64+0x94>
8000c910:	f0 08 12 00 	clz	r8,r8
8000c914:	c0 d0       	breq	8000c92e <__avr32_udiv64+0x36>
8000c916:	f6 08 09 4b 	lsl	r11,r11,r8
8000c91a:	f0 09 11 20 	rsub	r9,r8,32
8000c91e:	f8 08 09 4c 	lsl	r12,r12,r8
8000c922:	f4 09 0a 49 	lsr	r9,r10,r9
8000c926:	f4 08 09 43 	lsl	r3,r10,r8
8000c92a:	f3 eb 10 0b 	or	r11,r9,r11
8000c92e:	f8 0e 16 10 	lsr	lr,r12,0x10
8000c932:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000c936:	f6 0e 0d 00 	divu	r0,r11,lr
8000c93a:	e6 0b 16 10 	lsr	r11,r3,0x10
8000c93e:	00 99       	mov	r9,r0
8000c940:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c944:	e0 0a 02 48 	mul	r8,r0,r10
8000c948:	10 3b       	cp.w	r11,r8
8000c94a:	c0 a2       	brcc	8000c95e <__avr32_udiv64+0x66>
8000c94c:	20 19       	sub	r9,1
8000c94e:	18 0b       	add	r11,r12
8000c950:	18 3b       	cp.w	r11,r12
8000c952:	c0 63       	brcs	8000c95e <__avr32_udiv64+0x66>
8000c954:	10 3b       	cp.w	r11,r8
8000c956:	f7 b9 03 01 	sublo	r9,1
8000c95a:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c95e:	f6 08 01 01 	sub	r1,r11,r8
8000c962:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000c966:	e2 0e 0d 00 	divu	r0,r1,lr
8000c96a:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000c96e:	00 98       	mov	r8,r0
8000c970:	e0 0a 02 4a 	mul	r10,r0,r10
8000c974:	14 33       	cp.w	r3,r10
8000c976:	c0 82       	brcc	8000c986 <__avr32_udiv64+0x8e>
8000c978:	20 18       	sub	r8,1
8000c97a:	18 03       	add	r3,r12
8000c97c:	18 33       	cp.w	r3,r12
8000c97e:	c0 43       	brcs	8000c986 <__avr32_udiv64+0x8e>
8000c980:	14 33       	cp.w	r3,r10
8000c982:	f7 b8 03 01 	sublo	r8,1
8000c986:	f1 e9 11 08 	or	r8,r8,r9<<0x10
8000c98a:	cd f8       	rjmp	8000cb48 <__avr32_udiv64+0x250>
8000c98c:	58 08       	cp.w	r8,0
8000c98e:	c0 51       	brne	8000c998 <__avr32_udiv64+0xa0>
8000c990:	30 19       	mov	r9,1
8000c992:	f2 08 0d 08 	divu	r8,r9,r8
8000c996:	10 9c       	mov	r12,r8
8000c998:	f8 06 12 00 	clz	r6,r12
8000c99c:	c0 41       	brne	8000c9a4 <__avr32_udiv64+0xac>
8000c99e:	18 1b       	sub	r11,r12
8000c9a0:	30 19       	mov	r9,1
8000c9a2:	c4 08       	rjmp	8000ca22 <__avr32_udiv64+0x12a>
8000c9a4:	ec 01 11 20 	rsub	r1,r6,32
8000c9a8:	f4 01 0a 49 	lsr	r9,r10,r1
8000c9ac:	f8 06 09 4c 	lsl	r12,r12,r6
8000c9b0:	f6 06 09 48 	lsl	r8,r11,r6
8000c9b4:	f6 01 0a 41 	lsr	r1,r11,r1
8000c9b8:	f3 e8 10 08 	or	r8,r9,r8
8000c9bc:	f8 03 16 10 	lsr	r3,r12,0x10
8000c9c0:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000c9c4:	e2 03 0d 00 	divu	r0,r1,r3
8000c9c8:	f0 0b 16 10 	lsr	r11,r8,0x10
8000c9cc:	00 9e       	mov	lr,r0
8000c9ce:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c9d2:	e0 05 02 49 	mul	r9,r0,r5
8000c9d6:	12 3b       	cp.w	r11,r9
8000c9d8:	c0 a2       	brcc	8000c9ec <__avr32_udiv64+0xf4>
8000c9da:	20 1e       	sub	lr,1
8000c9dc:	18 0b       	add	r11,r12
8000c9de:	18 3b       	cp.w	r11,r12
8000c9e0:	c0 63       	brcs	8000c9ec <__avr32_udiv64+0xf4>
8000c9e2:	12 3b       	cp.w	r11,r9
8000c9e4:	f7 be 03 01 	sublo	lr,1
8000c9e8:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c9ec:	12 1b       	sub	r11,r9
8000c9ee:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
8000c9f2:	f6 03 0d 02 	divu	r2,r11,r3
8000c9f6:	f1 e3 11 08 	or	r8,r8,r3<<0x10
8000c9fa:	04 99       	mov	r9,r2
8000c9fc:	e4 05 02 4b 	mul	r11,r2,r5
8000ca00:	16 38       	cp.w	r8,r11
8000ca02:	c0 a2       	brcc	8000ca16 <__avr32_udiv64+0x11e>
8000ca04:	20 19       	sub	r9,1
8000ca06:	18 08       	add	r8,r12
8000ca08:	18 38       	cp.w	r8,r12
8000ca0a:	c0 63       	brcs	8000ca16 <__avr32_udiv64+0x11e>
8000ca0c:	16 38       	cp.w	r8,r11
8000ca0e:	f7 b9 03 01 	sublo	r9,1
8000ca12:	f1 dc e3 08 	addcs	r8,r8,r12
8000ca16:	f4 06 09 43 	lsl	r3,r10,r6
8000ca1a:	f0 0b 01 0b 	sub	r11,r8,r11
8000ca1e:	f3 ee 11 09 	or	r9,r9,lr<<0x10
8000ca22:	f8 06 16 10 	lsr	r6,r12,0x10
8000ca26:	fd dc c0 10 	bfextu	lr,r12,0x0,0x10
8000ca2a:	f6 06 0d 00 	divu	r0,r11,r6
8000ca2e:	e6 0b 16 10 	lsr	r11,r3,0x10
8000ca32:	00 9a       	mov	r10,r0
8000ca34:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000ca38:	e0 0e 02 48 	mul	r8,r0,lr
8000ca3c:	10 3b       	cp.w	r11,r8
8000ca3e:	c0 a2       	brcc	8000ca52 <__avr32_udiv64+0x15a>
8000ca40:	20 1a       	sub	r10,1
8000ca42:	18 0b       	add	r11,r12
8000ca44:	18 3b       	cp.w	r11,r12
8000ca46:	c0 63       	brcs	8000ca52 <__avr32_udiv64+0x15a>
8000ca48:	10 3b       	cp.w	r11,r8
8000ca4a:	f7 ba 03 01 	sublo	r10,1
8000ca4e:	f7 dc e3 0b 	addcs	r11,r11,r12
8000ca52:	f6 08 01 01 	sub	r1,r11,r8
8000ca56:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000ca5a:	e2 06 0d 00 	divu	r0,r1,r6
8000ca5e:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000ca62:	00 98       	mov	r8,r0
8000ca64:	e0 0e 02 4b 	mul	r11,r0,lr
8000ca68:	16 33       	cp.w	r3,r11
8000ca6a:	c0 82       	brcc	8000ca7a <__avr32_udiv64+0x182>
8000ca6c:	20 18       	sub	r8,1
8000ca6e:	18 03       	add	r3,r12
8000ca70:	18 33       	cp.w	r3,r12
8000ca72:	c0 43       	brcs	8000ca7a <__avr32_udiv64+0x182>
8000ca74:	16 33       	cp.w	r3,r11
8000ca76:	f7 b8 03 01 	sublo	r8,1
8000ca7a:	f1 ea 11 08 	or	r8,r8,r10<<0x10
8000ca7e:	c6 98       	rjmp	8000cb50 <__avr32_udiv64+0x258>
8000ca80:	16 39       	cp.w	r9,r11
8000ca82:	e0 8b 00 65 	brhi	8000cb4c <__avr32_udiv64+0x254>
8000ca86:	f2 09 12 00 	clz	r9,r9
8000ca8a:	c0 b1       	brne	8000caa0 <__avr32_udiv64+0x1a8>
8000ca8c:	10 3a       	cp.w	r10,r8
8000ca8e:	5f 2a       	srhs	r10
8000ca90:	1c 3b       	cp.w	r11,lr
8000ca92:	5f b8       	srhi	r8
8000ca94:	10 4a       	or	r10,r8
8000ca96:	f2 0a 18 00 	cp.b	r10,r9
8000ca9a:	c5 90       	breq	8000cb4c <__avr32_udiv64+0x254>
8000ca9c:	30 18       	mov	r8,1
8000ca9e:	c5 98       	rjmp	8000cb50 <__avr32_udiv64+0x258>
8000caa0:	f0 09 09 46 	lsl	r6,r8,r9
8000caa4:	f2 03 11 20 	rsub	r3,r9,32
8000caa8:	fc 09 09 4e 	lsl	lr,lr,r9
8000caac:	f0 03 0a 48 	lsr	r8,r8,r3
8000cab0:	f6 09 09 4c 	lsl	r12,r11,r9
8000cab4:	f4 03 0a 42 	lsr	r2,r10,r3
8000cab8:	ef 46 ff f4 	st.w	r7[-12],r6
8000cabc:	f6 03 0a 43 	lsr	r3,r11,r3
8000cac0:	18 42       	or	r2,r12
8000cac2:	f1 ee 10 0c 	or	r12,r8,lr
8000cac6:	f8 01 16 10 	lsr	r1,r12,0x10
8000caca:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000cace:	e6 01 0d 04 	divu	r4,r3,r1
8000cad2:	e4 03 16 10 	lsr	r3,r2,0x10
8000cad6:	08 9e       	mov	lr,r4
8000cad8:	e7 e5 11 03 	or	r3,r3,r5<<0x10
8000cadc:	e8 06 02 48 	mul	r8,r4,r6
8000cae0:	10 33       	cp.w	r3,r8
8000cae2:	c0 a2       	brcc	8000caf6 <__avr32_udiv64+0x1fe>
8000cae4:	20 1e       	sub	lr,1
8000cae6:	18 03       	add	r3,r12
8000cae8:	18 33       	cp.w	r3,r12
8000caea:	c0 63       	brcs	8000caf6 <__avr32_udiv64+0x1fe>
8000caec:	10 33       	cp.w	r3,r8
8000caee:	f7 be 03 01 	sublo	lr,1
8000caf2:	e7 dc e3 03 	addcs	r3,r3,r12
8000caf6:	10 13       	sub	r3,r8
8000caf8:	f7 d2 c0 10 	bfextu	r11,r2,0x0,0x10
8000cafc:	e6 01 0d 00 	divu	r0,r3,r1
8000cb00:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000cb04:	00 98       	mov	r8,r0
8000cb06:	e0 06 02 46 	mul	r6,r0,r6
8000cb0a:	0c 3b       	cp.w	r11,r6
8000cb0c:	c0 a2       	brcc	8000cb20 <__avr32_udiv64+0x228>
8000cb0e:	20 18       	sub	r8,1
8000cb10:	18 0b       	add	r11,r12
8000cb12:	18 3b       	cp.w	r11,r12
8000cb14:	c0 63       	brcs	8000cb20 <__avr32_udiv64+0x228>
8000cb16:	0c 3b       	cp.w	r11,r6
8000cb18:	f7 dc e3 0b 	addcs	r11,r11,r12
8000cb1c:	f7 b8 03 01 	sublo	r8,1
8000cb20:	f1 ee 11 08 	or	r8,r8,lr<<0x10
8000cb24:	ee f4 ff f4 	ld.w	r4,r7[-12]
8000cb28:	0c 1b       	sub	r11,r6
8000cb2a:	f0 04 06 42 	mulu.d	r2,r8,r4
8000cb2e:	06 95       	mov	r5,r3
8000cb30:	16 35       	cp.w	r5,r11
8000cb32:	e0 8b 00 0a 	brhi	8000cb46 <__avr32_udiv64+0x24e>
8000cb36:	5f 0b       	sreq	r11
8000cb38:	f4 09 09 49 	lsl	r9,r10,r9
8000cb3c:	12 32       	cp.w	r2,r9
8000cb3e:	5f b9       	srhi	r9
8000cb40:	f7 e9 00 09 	and	r9,r11,r9
8000cb44:	c0 60       	breq	8000cb50 <__avr32_udiv64+0x258>
8000cb46:	20 18       	sub	r8,1
8000cb48:	30 09       	mov	r9,0
8000cb4a:	c0 38       	rjmp	8000cb50 <__avr32_udiv64+0x258>
8000cb4c:	30 09       	mov	r9,0
8000cb4e:	12 98       	mov	r8,r9
8000cb50:	10 9a       	mov	r10,r8
8000cb52:	12 93       	mov	r3,r9
8000cb54:	10 92       	mov	r2,r8
8000cb56:	12 9b       	mov	r11,r9
8000cb58:	2f dd       	sub	sp,-12
8000cb5a:	d8 32       	popm	r0-r7,pc

8000cb5c <__avr32_umod64>:
8000cb5c:	d4 31       	pushm	r0-r7,lr
8000cb5e:	1a 97       	mov	r7,sp
8000cb60:	20 3d       	sub	sp,12
8000cb62:	10 9c       	mov	r12,r8
8000cb64:	12 95       	mov	r5,r9
8000cb66:	14 9e       	mov	lr,r10
8000cb68:	16 91       	mov	r1,r11
8000cb6a:	16 96       	mov	r6,r11
8000cb6c:	58 09       	cp.w	r9,0
8000cb6e:	e0 81 00 81 	brne	8000cc70 <__avr32_umod64+0x114>
8000cb72:	16 38       	cp.w	r8,r11
8000cb74:	e0 88 00 12 	brls	8000cb98 <__avr32_umod64+0x3c>
8000cb78:	f0 08 12 00 	clz	r8,r8
8000cb7c:	c4 e0       	breq	8000cc18 <__avr32_umod64+0xbc>
8000cb7e:	f6 08 09 46 	lsl	r6,r11,r8
8000cb82:	f8 08 09 4c 	lsl	r12,r12,r8
8000cb86:	f0 0b 11 20 	rsub	r11,r8,32
8000cb8a:	f4 08 09 4e 	lsl	lr,r10,r8
8000cb8e:	f4 0b 0a 4b 	lsr	r11,r10,r11
8000cb92:	f7 e6 10 06 	or	r6,r11,r6
8000cb96:	c4 18       	rjmp	8000cc18 <__avr32_umod64+0xbc>
8000cb98:	58 08       	cp.w	r8,0
8000cb9a:	c0 51       	brne	8000cba4 <__avr32_umod64+0x48>
8000cb9c:	30 19       	mov	r9,1
8000cb9e:	f2 08 0d 08 	divu	r8,r9,r8
8000cba2:	10 9c       	mov	r12,r8
8000cba4:	f8 08 12 00 	clz	r8,r12
8000cba8:	c0 31       	brne	8000cbae <__avr32_umod64+0x52>
8000cbaa:	18 16       	sub	r6,r12
8000cbac:	c3 68       	rjmp	8000cc18 <__avr32_umod64+0xbc>
8000cbae:	f0 03 11 20 	rsub	r3,r8,32
8000cbb2:	f4 03 0a 4b 	lsr	r11,r10,r3
8000cbb6:	f8 08 09 4c 	lsl	r12,r12,r8
8000cbba:	ec 08 09 49 	lsl	r9,r6,r8
8000cbbe:	ec 03 0a 43 	lsr	r3,r6,r3
8000cbc2:	f7 e9 10 09 	or	r9,r11,r9
8000cbc6:	f8 05 16 10 	lsr	r5,r12,0x10
8000cbca:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000cbce:	e6 05 0d 02 	divu	r2,r3,r5
8000cbd2:	f2 0e 16 10 	lsr	lr,r9,0x10
8000cbd6:	ec 02 02 4b 	mul	r11,r6,r2
8000cbda:	fd e3 11 0e 	or	lr,lr,r3<<0x10
8000cbde:	16 3e       	cp.w	lr,r11
8000cbe0:	c0 72       	brcc	8000cbee <__avr32_umod64+0x92>
8000cbe2:	18 0e       	add	lr,r12
8000cbe4:	18 3e       	cp.w	lr,r12
8000cbe6:	c0 43       	brcs	8000cbee <__avr32_umod64+0x92>
8000cbe8:	16 3e       	cp.w	lr,r11
8000cbea:	fd dc e3 0e 	addcs	lr,lr,r12
8000cbee:	fc 0b 01 03 	sub	r3,lr,r11
8000cbf2:	f3 d9 c0 10 	bfextu	r9,r9,0x0,0x10
8000cbf6:	e6 05 0d 02 	divu	r2,r3,r5
8000cbfa:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000cbfe:	a5 36       	mul	r6,r2
8000cc00:	0c 39       	cp.w	r9,r6
8000cc02:	c0 72       	brcc	8000cc10 <__avr32_umod64+0xb4>
8000cc04:	18 09       	add	r9,r12
8000cc06:	18 39       	cp.w	r9,r12
8000cc08:	c0 43       	brcs	8000cc10 <__avr32_umod64+0xb4>
8000cc0a:	0c 39       	cp.w	r9,r6
8000cc0c:	f3 dc e3 09 	addcs	r9,r9,r12
8000cc10:	f2 06 01 06 	sub	r6,r9,r6
8000cc14:	f4 08 09 4e 	lsl	lr,r10,r8
8000cc18:	f8 0a 16 10 	lsr	r10,r12,0x10
8000cc1c:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000cc20:	ec 0a 0d 02 	divu	r2,r6,r10
8000cc24:	fc 09 16 10 	lsr	r9,lr,0x10
8000cc28:	ea 02 02 4b 	mul	r11,r5,r2
8000cc2c:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000cc30:	16 39       	cp.w	r9,r11
8000cc32:	c0 72       	brcc	8000cc40 <__avr32_umod64+0xe4>
8000cc34:	18 09       	add	r9,r12
8000cc36:	18 39       	cp.w	r9,r12
8000cc38:	c0 43       	brcs	8000cc40 <__avr32_umod64+0xe4>
8000cc3a:	16 39       	cp.w	r9,r11
8000cc3c:	f3 dc e3 09 	addcs	r9,r9,r12
8000cc40:	f2 0b 01 0b 	sub	r11,r9,r11
8000cc44:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000cc48:	f6 0a 0d 0a 	divu	r10,r11,r10
8000cc4c:	fd eb 11 0e 	or	lr,lr,r11<<0x10
8000cc50:	ea 0a 02 4a 	mul	r10,r5,r10
8000cc54:	14 3e       	cp.w	lr,r10
8000cc56:	c0 72       	brcc	8000cc64 <__avr32_umod64+0x108>
8000cc58:	18 0e       	add	lr,r12
8000cc5a:	18 3e       	cp.w	lr,r12
8000cc5c:	c0 43       	brcs	8000cc64 <__avr32_umod64+0x108>
8000cc5e:	14 3e       	cp.w	lr,r10
8000cc60:	fd dc e3 0e 	addcs	lr,lr,r12
8000cc64:	fc 0a 01 0a 	sub	r10,lr,r10
8000cc68:	30 0b       	mov	r11,0
8000cc6a:	f4 08 0a 4a 	lsr	r10,r10,r8
8000cc6e:	c7 b8       	rjmp	8000cd64 <__avr32_umod64+0x208>
8000cc70:	16 39       	cp.w	r9,r11
8000cc72:	e0 8b 00 79 	brhi	8000cd64 <__avr32_umod64+0x208>
8000cc76:	f2 09 12 00 	clz	r9,r9
8000cc7a:	c1 21       	brne	8000cc9e <__avr32_umod64+0x142>
8000cc7c:	10 3a       	cp.w	r10,r8
8000cc7e:	5f 2b       	srhs	r11
8000cc80:	0a 31       	cp.w	r1,r5
8000cc82:	5f ba       	srhi	r10
8000cc84:	f7 ea 10 0a 	or	r10,r11,r10
8000cc88:	f2 0a 18 00 	cp.b	r10,r9
8000cc8c:	c0 60       	breq	8000cc98 <__avr32_umod64+0x13c>
8000cc8e:	fc 08 01 0c 	sub	r12,lr,r8
8000cc92:	e2 05 01 46 	sbc	r6,r1,r5
8000cc96:	18 9e       	mov	lr,r12
8000cc98:	0c 9b       	mov	r11,r6
8000cc9a:	1c 9a       	mov	r10,lr
8000cc9c:	c6 48       	rjmp	8000cd64 <__avr32_umod64+0x208>
8000cc9e:	ea 09 09 4c 	lsl	r12,r5,r9
8000cca2:	f2 06 11 20 	rsub	r6,r9,32
8000cca6:	f6 09 09 4b 	lsl	r11,r11,r9
8000ccaa:	f0 09 09 42 	lsl	r2,r8,r9
8000ccae:	ef 46 ff f4 	st.w	r7[-12],r6
8000ccb2:	f0 06 0a 48 	lsr	r8,r8,r6
8000ccb6:	18 48       	or	r8,r12
8000ccb8:	e2 06 0a 4c 	lsr	r12,r1,r6
8000ccbc:	f4 09 09 43 	lsl	r3,r10,r9
8000ccc0:	fd d8 c0 10 	bfextu	lr,r8,0x0,0x10
8000ccc4:	f4 06 0a 4a 	lsr	r10,r10,r6
8000ccc8:	16 4a       	or	r10,r11
8000ccca:	f0 0b 16 10 	lsr	r11,r8,0x10
8000ccce:	f8 0b 0d 04 	divu	r4,r12,r11
8000ccd2:	f4 0c 16 10 	lsr	r12,r10,0x10
8000ccd6:	08 91       	mov	r1,r4
8000ccd8:	f9 e5 11 0c 	or	r12,r12,r5<<0x10
8000ccdc:	e8 0e 02 46 	mul	r6,r4,lr
8000cce0:	0c 3c       	cp.w	r12,r6
8000cce2:	c0 a2       	brcc	8000ccf6 <__avr32_umod64+0x19a>
8000cce4:	20 11       	sub	r1,1
8000cce6:	10 0c       	add	r12,r8
8000cce8:	10 3c       	cp.w	r12,r8
8000ccea:	c0 63       	brcs	8000ccf6 <__avr32_umod64+0x19a>
8000ccec:	0c 3c       	cp.w	r12,r6
8000ccee:	f7 b1 03 01 	sublo	r1,1
8000ccf2:	f9 d8 e3 0c 	addcs	r12,r12,r8
8000ccf6:	0c 1c       	sub	r12,r6
8000ccf8:	f5 da c0 10 	bfextu	r10,r10,0x0,0x10
8000ccfc:	f8 0b 0d 04 	divu	r4,r12,r11
8000cd00:	f5 e5 11 0b 	or	r11,r10,r5<<0x10
8000cd04:	08 96       	mov	r6,r4
8000cd06:	e8 0e 02 4e 	mul	lr,r4,lr
8000cd0a:	1c 3b       	cp.w	r11,lr
8000cd0c:	c0 a2       	brcc	8000cd20 <__avr32_umod64+0x1c4>
8000cd0e:	20 16       	sub	r6,1
8000cd10:	10 0b       	add	r11,r8
8000cd12:	10 3b       	cp.w	r11,r8
8000cd14:	c0 63       	brcs	8000cd20 <__avr32_umod64+0x1c4>
8000cd16:	1c 3b       	cp.w	r11,lr
8000cd18:	f7 b6 03 01 	sublo	r6,1
8000cd1c:	f7 d8 e3 0b 	addcs	r11,r11,r8
8000cd20:	ed e1 11 01 	or	r1,r6,r1<<0x10
8000cd24:	1c 1b       	sub	r11,lr
8000cd26:	e2 02 06 40 	mulu.d	r0,r1,r2
8000cd2a:	00 9e       	mov	lr,r0
8000cd2c:	02 9c       	mov	r12,r1
8000cd2e:	16 3c       	cp.w	r12,r11
8000cd30:	e0 8b 00 08 	brhi	8000cd40 <__avr32_umod64+0x1e4>
8000cd34:	5f 06       	sreq	r6
8000cd36:	06 30       	cp.w	r0,r3
8000cd38:	5f ba       	srhi	r10
8000cd3a:	ed ea 00 0a 	and	r10,r6,r10
8000cd3e:	c0 60       	breq	8000cd4a <__avr32_umod64+0x1ee>
8000cd40:	fc 02 01 04 	sub	r4,lr,r2
8000cd44:	f8 08 01 4c 	sbc	r12,r12,r8
8000cd48:	08 9e       	mov	lr,r4
8000cd4a:	e6 0e 01 0a 	sub	r10,r3,lr
8000cd4e:	f6 0c 01 4c 	sbc	r12,r11,r12
8000cd52:	ee f1 ff f4 	ld.w	r1,r7[-12]
8000cd56:	f8 09 0a 4b 	lsr	r11,r12,r9
8000cd5a:	f4 09 0a 4a 	lsr	r10,r10,r9
8000cd5e:	f8 01 09 4c 	lsl	r12,r12,r1
8000cd62:	18 4a       	or	r10,r12
8000cd64:	2f dd       	sub	sp,-12
8000cd66:	d8 32       	popm	r0-r7,pc

Disassembly of section .exception:

8000ce00 <_evba>:
_evba:

        .org  0x000
        // Unrecoverable Exception.
_handle_Unrecoverable_Exception:
        rjmp $
8000ce00:	c0 08       	rjmp	8000ce00 <_evba>
	...

8000ce04 <_handle_TLB_Multiple_Hit>:

        .org  0x004
        // TLB Multiple Hit: UNUSED IN AVR32UC.
_handle_TLB_Multiple_Hit:
        rjmp $
8000ce04:	c0 08       	rjmp	8000ce04 <_handle_TLB_Multiple_Hit>
	...

8000ce08 <_handle_Bus_Error_Data_Fetch>:

        .org  0x008
        // Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
        rjmp $
8000ce08:	c0 08       	rjmp	8000ce08 <_handle_Bus_Error_Data_Fetch>
	...

8000ce0c <_handle_Bus_Error_Instruction_Fetch>:

        .org  0x00C
         // Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
        rjmp $
8000ce0c:	c0 08       	rjmp	8000ce0c <_handle_Bus_Error_Instruction_Fetch>
	...

8000ce10 <_handle_NMI>:

        .org  0x010
        // NMI.
_handle_NMI:
        rjmp $
8000ce10:	c0 08       	rjmp	8000ce10 <_handle_NMI>
	...

8000ce14 <_handle_Instruction_Address>:

        .org  0x014
        // Instruction Address.
_handle_Instruction_Address:
        rjmp $
8000ce14:	c0 08       	rjmp	8000ce14 <_handle_Instruction_Address>
	...

8000ce18 <_handle_ITLB_Protection>:

        .org  0x018
        // ITLB Protection.
_handle_ITLB_Protection:
        rjmp $
8000ce18:	c0 08       	rjmp	8000ce18 <_handle_ITLB_Protection>
	...

8000ce1c <_handle_Breakpoint>:

        .org  0x01C
        // Breakpoint.
_handle_Breakpoint:
        rjmp $
8000ce1c:	c0 08       	rjmp	8000ce1c <_handle_Breakpoint>
	...

8000ce20 <_handle_Illegal_Opcode>:

        .org  0x020
        // Illegal Opcode.
_handle_Illegal_Opcode:
        rjmp $
8000ce20:	c0 08       	rjmp	8000ce20 <_handle_Illegal_Opcode>
	...

8000ce24 <_handle_Unimplemented_Instruction>:

        .org  0x024
        // Unimplemented Instruction.
_handle_Unimplemented_Instruction:
        rjmp $
8000ce24:	c0 08       	rjmp	8000ce24 <_handle_Unimplemented_Instruction>
	...

8000ce28 <_handle_Privilege_Violation>:

        .org  0x028
        // Privilege Violation.
_handle_Privilege_Violation:
        rjmp $
8000ce28:	c0 08       	rjmp	8000ce28 <_handle_Privilege_Violation>
	...

8000ce2c <_handle_Floating_Point>:

        .org  0x02C
        // Floating-Point: UNUSED IN AVR32UC.
_handle_Floating_Point:
        rjmp $
8000ce2c:	c0 08       	rjmp	8000ce2c <_handle_Floating_Point>
	...

8000ce30 <_handle_Coprocessor_Absent>:

        .org  0x030
        // Coprocessor Absent: UNUSED IN AVR32UC.
_handle_Coprocessor_Absent:
        rjmp $
8000ce30:	c0 08       	rjmp	8000ce30 <_handle_Coprocessor_Absent>
	...

8000ce34 <_handle_Data_Address_Read>:

        .org  0x034
        // Data Address (Read).
_handle_Data_Address_Read:
        rjmp $
8000ce34:	c0 08       	rjmp	8000ce34 <_handle_Data_Address_Read>
	...

8000ce38 <_handle_Data_Address_Write>:

        .org  0x038
        // Data Address (Write).
_handle_Data_Address_Write:
        rjmp $
8000ce38:	c0 08       	rjmp	8000ce38 <_handle_Data_Address_Write>
	...

8000ce3c <_handle_DTLB_Protection_Read>:

        .org  0x03C
        // DTLB Protection (Read).
_handle_DTLB_Protection_Read:
        rjmp $
8000ce3c:	c0 08       	rjmp	8000ce3c <_handle_DTLB_Protection_Read>
	...

8000ce40 <_handle_DTLB_Protection_Write>:

        .org  0x040
        // DTLB Protection (Write).
_handle_DTLB_Protection_Write:
        rjmp $
8000ce40:	c0 08       	rjmp	8000ce40 <_handle_DTLB_Protection_Write>
	...

8000ce44 <_handle_DTLB_Modified>:

        .org  0x044
        // DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
        rjmp $
8000ce44:	c0 08       	rjmp	8000ce44 <_handle_DTLB_Modified>
	...

8000ce50 <_handle_ITLB_Miss>:

        .org  0x050
        // ITLB Miss: UNUSED IN AVR32UC.
_handle_ITLB_Miss:
        rjmp $
8000ce50:	c0 08       	rjmp	8000ce50 <_handle_ITLB_Miss>
	...

8000ce60 <_handle_DTLB_Miss_Read>:

        .org  0x060
        // DTLB Miss (Read): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Read:
        rjmp $
8000ce60:	c0 08       	rjmp	8000ce60 <_handle_DTLB_Miss_Read>
	...

8000ce70 <_handle_DTLB_Miss_Write>:

        .org  0x070
        // DTLB Miss (Write): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Write:
        rjmp $
8000ce70:	c0 08       	rjmp	8000ce70 <_handle_DTLB_Miss_Write>
	...

8000cf00 <_handle_Supervisor_Call>:

        .org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	lda.w   pc, SCALLYield
8000cf00:	fe cf 70 30 	sub	pc,pc,28720

8000cf04 <_int0>:
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
	rete
.endr
8000cf04:	30 0c       	mov	r12,0
8000cf06:	fe b0 c4 03 	rcall	8000570c <_get_interrupt_handler>
8000cf0a:	58 0c       	cp.w	r12,0
8000cf0c:	f8 0f 17 10 	movne	pc,r12
8000cf10:	d6 03       	rete

8000cf12 <_int1>:
8000cf12:	30 1c       	mov	r12,1
8000cf14:	fe b0 c3 fc 	rcall	8000570c <_get_interrupt_handler>
8000cf18:	58 0c       	cp.w	r12,0
8000cf1a:	f8 0f 17 10 	movne	pc,r12
8000cf1e:	d6 03       	rete

8000cf20 <_int2>:
8000cf20:	30 2c       	mov	r12,2
8000cf22:	fe b0 c3 f5 	rcall	8000570c <_get_interrupt_handler>
8000cf26:	58 0c       	cp.w	r12,0
8000cf28:	f8 0f 17 10 	movne	pc,r12
8000cf2c:	d6 03       	rete

8000cf2e <_int3>:
8000cf2e:	30 3c       	mov	r12,3
8000cf30:	fe b0 c3 ee 	rcall	8000570c <_get_interrupt_handler>
8000cf34:	58 0c       	cp.w	r12,0
8000cf36:	f8 0f 17 10 	movne	pc,r12
8000cf3a:	d6 03       	rete

8000cf3c <ipr_val>:
8000cf3c:	00 00 01 04 40 00 01 12 80 00 01 20 c0 00 01 2e     ....@...... ....
8000cf4c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cf5c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cf6c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cf7c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cf8c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cf9c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cfac:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cfbc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cfcc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cfdc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cfec:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cffc:	d7 03 d7 03                                         ....
