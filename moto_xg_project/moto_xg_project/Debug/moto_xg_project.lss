
moto_xg_project.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00002004  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         0000ab38  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .exception    00000200  8000cc00  8000cc00  0000d000  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       00001174  8000ce00  8000ce00  0000d200  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .dalign       00000004  8000df74  8000df74  0000e374  2**0
                  ALLOC
  6 .data         00000a3c  00000004  8000df78  0000e404  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .bss          000046f0  00000a40  8000e9b4  0000ee40  2**2
                  ALLOC
  8 .comment      00000030  00000000  00000000  0000ee40  2**0
                  CONTENTS, READONLY
  9 .debug_aranges 000014b0  00000000  00000000  0000ee70  2**3
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_pubnames 00002dde  00000000  00000000  00010320  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_info   0002c0d2  00000000  00000000  000130fe  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_abbrev 0000716a  00000000  00000000  0003f1d0  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_line   0000cda0  00000000  00000000  0004633a  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_frame  000036b8  00000000  00000000  000530dc  2**2
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_str    000076c6  00000000  00000000  00056794  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_loc    0000e3e0  00000000  00000000  0005de5a  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .stack        00001000  00017000  00017000  00000400  2**0
                  ALLOC
 18 .debug_ranges 00001578  00000000  00000000  0006c240  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_trampoline>:

  .global _trampoline
  .type _trampoline, @function
_trampoline:
  // Jump to program start.
  rjmp    program_start
80000000:	e0 8f 10 00 	bral	80002000 <program_start>
	...

80002000 <program_start>:

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002000:	fe cf c4 d4 	sub	pc,pc,-15148

Disassembly of section .text:

80002004 <DeviceManagement_brdcst_func>:
80002004:	19 a9       	ld.ub	r9,r12[0x2]
80002006:	30 18       	mov	r8,1
		U8 temp = 0;
		temp  = xcmp->u8[1] << 8;
		temp |= xcmp->u8[2];
		//if (temp == theXNL_Ctrlr.XNL_DeviceLogicalAddress)
		{
			if (xcmp->u8[0] == 0x01)
80002008:	f0 09 18 00 	cp.b	r9,r8
8000200c:	c0 61       	brne	80002018 <DeviceManagement_brdcst_func+0x14>
			{
				bunchofrandomstatusflags |= 0x00000002;
8000200e:	48 68       	lddpc	r8,80002024 <DeviceManagement_brdcst_func+0x20>
80002010:	70 09       	ld.w	r9,r8[0x0]
80002012:	a1 b9       	sbr	r9,0x1
80002014:	91 09       	st.w	r8[0x0],r9
80002016:	5e fc       	retal	r12
			}
			else
			{
				bunchofrandomstatusflags &= 0xFFFFFFFD;
80002018:	48 38       	lddpc	r8,80002024 <DeviceManagement_brdcst_func+0x20>
8000201a:	70 09       	ld.w	r9,r8[0x0]
8000201c:	a1 d9       	cbr	r9,0x1
8000201e:	91 09       	st.w	r8[0x0],r9
80002020:	5e fc       	retal	r12
80002022:	00 00       	add	r0,r0
80002024:	00 00       	add	r0,r0
80002026:	0d 80       	ld.ub	r0,r6[0x0]

80002028 <Volume_brdcst_func>:
	//log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
	
	//log("\n\r Audio_Parameter: %x \n\r", ptr->Audio_Parameter);
	
	
}
80002028:	5e fc       	retal	r12

8000202a <AudioRoutingControl_brdcst_func>:
	//
	//log("\n\r Audio-Function: %x \n\r", xcmp->u8[3+j*2-1]);
	
	
	
}
8000202a:	5e fc       	retal	r12

8000202c <vApplicationIdleHook>:
}

void vApplicationIdleHook( void )
{
	/* This hook function does nothing but increment a counter. */
	ulIdleCycleCount++;
8000202c:	48 38       	lddpc	r8,80002038 <vApplicationIdleHook+0xc>
8000202e:	70 09       	ld.w	r9,r8[0x0]
80002030:	2f f9       	sub	r9,-1
80002032:	91 09       	st.w	r8[0x0],r9
	
}
80002034:	5e fc       	retal	r12
80002036:	00 00       	add	r0,r0
80002038:	00 00       	add	r0,r0
8000203a:	0a 58       	eor	r8,r5

8000203c <app_init>:
	//0x00,0x39


};
void app_init(void)
{	
8000203c:	d4 01       	pushm	lr
	xcmp_register_app_list(the_app_list);
8000203e:	48 cc       	lddpc	r12,8000206c <app_init+0x30>
80002040:	f0 1f 00 0c 	mcall	80002070 <app_init+0x34>
	
	//将app_payload_rx_proc更改为PCM加密功能
	payload_init( app_payload_rx_proc , app_payload_tx_proc );
80002044:	48 cb       	lddpc	r11,80002074 <app_init+0x38>
80002046:	48 dc       	lddpc	r12,80002078 <app_init+0x3c>
80002048:	f0 1f 00 0d 	mcall	8000207c <app_init+0x40>
	
	static portBASE_TYPE res = 0;
	 res = xTaskCreate(
8000204c:	30 09       	mov	r9,0
8000204e:	1a d9       	st.w	--sp,r9
80002050:	1a d9       	st.w	--sp,r9
80002052:	1a d9       	st.w	--sp,r9
80002054:	30 18       	mov	r8,1
80002056:	e0 6a 01 80 	mov	r10,384
8000205a:	48 ab       	lddpc	r11,80002080 <app_init+0x44>
8000205c:	48 ac       	lddpc	r12,80002084 <app_init+0x48>
8000205e:	f0 1f 00 0b 	mcall	80002088 <app_init+0x4c>
80002062:	48 b8       	lddpc	r8,8000208c <app_init+0x50>
80002064:	91 0c       	st.w	r8[0x0],r12
80002066:	2f dd       	sub	sp,-12
	,  384
	,  NULL
	,  1
	,  NULL );
	
}
80002068:	d8 02       	popm	pc
8000206a:	00 00       	add	r0,r0
8000206c:	00 00       	add	r0,r0
8000206e:	00 04       	add	r4,r0
80002070:	80 00       	ld.sh	r0,r0[0x0]
80002072:	3f b0       	mov	r0,-5
80002074:	80 00       	ld.sh	r0,r0[0x0]
80002076:	21 04       	sub	r4,16
80002078:	80 00       	ld.sh	r0,r0[0x0]
8000207a:	21 18       	sub	r8,17
8000207c:	80 00       	ld.sh	r0,r0[0x0]
8000207e:	2b b0       	sub	r0,-69
80002080:	80 00       	ld.sh	r0,r0[0x0]
80002082:	ce 00       	breq	80002042 <app_init+0x6>
80002084:	80 00       	ld.sh	r0,r0[0x0]
80002086:	20 90       	sub	r0,9
80002088:	80 00       	ld.sh	r0,r0[0x0]
8000208a:	6a 6c       	ld.w	r12,r5[0x18]
8000208c:	00 00       	add	r0,r0
8000208e:	0a 50       	eor	r0,r5

80002090 <app_cfg>:

extern  char AudioData[];
extern U32 tc_tick;

static __app_Thread_(app_cfg)
{
80002090:	d4 31       	pushm	r0-r7,lr
	static  portTickType xLastWakeTime;
	const portTickType xFrequency = 4000;//2s,定时问题已经修正。2s x  2000hz = 4000
	U8 Burst_ID = 0;
	char card_id[4]={0};
	
	 xLastWakeTime = xTaskGetTickCount();
80002092:	f0 1f 00 17 	mcall	800020ec <app_cfg+0x5c>
80002096:	49 78       	lddpc	r8,800020f0 <app_cfg+0x60>
80002098:	91 0c       	st.w	r8[0x0],r12
		
	for(;;)
	{
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
8000209a:	49 76       	lddpc	r6,800020f4 <app_cfg+0x64>
		{	
			connect_flag=1;	
			xcmp_IdleTestTone(Tone_Start, Priority_Beep);//set tone to indicate connection success!!!

		}
		else if(connect_flag)
8000209c:	49 77       	lddpc	r7,800020f8 <app_cfg+0x68>
		else
		{
			nop();
			nop();
			nop();
			xcmp_IdleTestTone(Tone_Start, Bad_Key_Chirp);//set tone to indicate connection failure!!!
8000209e:	30 62       	mov	r2,6
800020a0:	30 13       	mov	r3,1
		
	for(;;)
	{
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
		{	
			connect_flag=1;	
800020a2:	30 11       	mov	r1,1
			xcmp_IdleTestTone(Tone_Start, Priority_Beep);//set tone to indicate connection success!!!
800020a4:	30 c0       	mov	r0,12
			
		//}
		//vTaskDelay(300*2 / portTICK_RATE_MS);//延迟300ms
		//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
		
		vTaskDelayUntil( &xLastWakeTime, (2000*2) / portTICK_RATE_MS  );//精确的以1000ms为周期执行。
800020a6:	10 95       	mov	r5,r8
800020a8:	e0 64 0f a0 	mov	r4,4000
	
	 xLastWakeTime = xTaskGetTickCount();
		
	for(;;)
	{
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
800020ac:	6c 08       	ld.w	r8,r6[0x0]
800020ae:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
800020b2:	58 38       	cp.w	r8,3
800020b4:	c0 a1       	brne	800020c8 <app_cfg+0x38>
800020b6:	0f 88       	ld.ub	r8,r7[0x0]
800020b8:	58 08       	cp.w	r8,0
800020ba:	c0 71       	brne	800020c8 <app_cfg+0x38>
		{	
			connect_flag=1;	
800020bc:	ae 81       	st.b	r7[0x0],r1
			xcmp_IdleTestTone(Tone_Start, Priority_Beep);//set tone to indicate connection success!!!
800020be:	00 9b       	mov	r11,r0
800020c0:	06 9c       	mov	r12,r3
800020c2:	f0 1f 00 0f 	mcall	800020fc <app_cfg+0x6c>
	
	 xLastWakeTime = xTaskGetTickCount();
		
	for(;;)
	{
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
800020c6:	c0 d8       	rjmp	800020e0 <app_cfg+0x50>
		{	
			connect_flag=1;	
			xcmp_IdleTestTone(Tone_Start, Priority_Beep);//set tone to indicate connection success!!!

		}
		else if(connect_flag)
800020c8:	0f 88       	ld.ub	r8,r7[0x0]
800020ca:	58 08       	cp.w	r8,0
800020cc:	c0 30       	breq	800020d2 <app_cfg+0x42>
				//}
				//else
				//{
					//log("no find card...\n");
				//}
				nop();
800020ce:	d7 03       	nop
800020d0:	c0 88       	rjmp	800020e0 <app_cfg+0x50>
				
		}
		else
		{
			nop();
800020d2:	d7 03       	nop
			nop();
800020d4:	d7 03       	nop
			nop();
800020d6:	d7 03       	nop
			xcmp_IdleTestTone(Tone_Start, Bad_Key_Chirp);//set tone to indicate connection failure!!!
800020d8:	04 9b       	mov	r11,r2
800020da:	06 9c       	mov	r12,r3
800020dc:	f0 1f 00 08 	mcall	800020fc <app_cfg+0x6c>
			
		//}
		//vTaskDelay(300*2 / portTICK_RATE_MS);//延迟300ms
		//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
		
		vTaskDelayUntil( &xLastWakeTime, (2000*2) / portTICK_RATE_MS  );//精确的以1000ms为周期执行。
800020e0:	08 9b       	mov	r11,r4
800020e2:	0a 9c       	mov	r12,r5
800020e4:	f0 1f 00 07 	mcall	80002100 <app_cfg+0x70>
	}
800020e8:	ce 2b       	rjmp	800020ac <app_cfg+0x1c>
800020ea:	00 00       	add	r0,r0
800020ec:	80 00       	ld.sh	r0,r0[0x0]
800020ee:	67 5c       	ld.w	r12,r3[0x54]
800020f0:	00 00       	add	r0,r0
800020f2:	0a 48       	or	r8,r5
800020f4:	00 00       	add	r0,r0
800020f6:	0d 80       	ld.ub	r0,r6[0x0]
800020f8:	00 00       	add	r0,r0
800020fa:	0a 4c       	or	r12,r5
800020fc:	80 00       	ld.sh	r0,r0[0x0]
800020fe:	41 3c       	lddsp	r12,sp[0x4c]
80002100:	80 00       	ld.sh	r0,r0[0x0]
80002102:	69 0c       	ld.w	r12,r4[0x40]

80002104 <app_payload_tx_proc>:

}


static void app_payload_tx_proc(void  * payload)
{
80002104:	d4 01       	pushm	lr
  log("R");
80002106:	48 3c       	lddpc	r12,80002110 <app_payload_tx_proc+0xc>
80002108:	f0 1f 00 03 	mcall	80002114 <app_payload_tx_proc+0x10>
  //
  //
  //set_payload_idle(payload);


}
8000210c:	d8 02       	popm	pc
8000210e:	00 00       	add	r0,r0
80002110:	80 00       	ld.sh	r0,r0[0x0]
80002112:	ce 08       	rjmp	800022d2 <ButtonConfig_brdcst_func+0xaa>
80002114:	80 00       	ld.sh	r0,r0[0x0]
80002116:	6e 30       	ld.w	r0,r7[0xc]

80002118 <app_payload_rx_proc>:
	}
}


static void app_payload_rx_proc(void  * payload)
{
80002118:	d4 01       	pushm	lr
	static  U8 times_counter = 0;
	
	times_counter++;
8000211a:	48 99       	lddpc	r9,8000213c <app_payload_rx_proc+0x24>
8000211c:	13 88       	ld.ub	r8,r9[0x0]
8000211e:	2f f8       	sub	r8,-1
80002120:	b2 88       	st.b	r9[0x0],r8
	if (times_counter == 3)
80002122:	30 39       	mov	r9,3
80002124:	f2 08 18 00 	cp.b	r8,r9
80002128:	c0 71       	brne	80002136 <app_payload_rx_proc+0x1e>
	{
		times_counter = 0 ;
8000212a:	30 09       	mov	r9,0
8000212c:	48 48       	lddpc	r8,8000213c <app_payload_rx_proc+0x24>
8000212e:	b0 89       	st.b	r8[0x0],r9
		log("\n\r w: \n\r");
80002130:	48 4c       	lddpc	r12,80002140 <app_payload_rx_proc+0x28>
80002132:	f0 1f 00 05 	mcall	80002144 <app_payload_rx_proc+0x2c>
	}
	//log("\n\r w: \n\r");
	if (AMBE_tx_flag)//本地发送方的mic录音
80002136:	48 58       	lddpc	r8,80002148 <app_payload_rx_proc+0x30>
80002138:	11 88       	ld.ub	r8,r8[0x0]
	}
	
	//payload_fragment_t * ptr = (payload_fragment_t *)payload;
	//set_payload_idle(payload);

}
8000213a:	d8 02       	popm	pc
8000213c:	00 00       	add	r0,r0
8000213e:	0a 55       	eor	r5,r5
80002140:	80 00       	ld.sh	r0,r0[0x0]
80002142:	ce 0c       	rcall	80002302 <ButtonConfig_brdcst_func+0xda>
80002144:	80 00       	ld.sh	r0,r0[0x0]
80002146:	6e 30       	ld.w	r0,r7[0xc]
80002148:	00 00       	add	r0,r0
8000214a:	0a 43       	or	r3,r5

8000214c <FD_brdcst_func>:
	
	
}

void FD_brdcst_func(xcmp_fragment_t * xcmp)
{
8000214c:	d4 01       	pushm	lr
	
	
	log("\n\r Forward Data Broadcast \n\r");
8000214e:	48 3c       	lddpc	r12,80002158 <FD_brdcst_func+0xc>
80002150:	f0 1f 00 03 	mcall	8000215c <FD_brdcst_func+0x10>
	
}
80002154:	d8 02       	popm	pc
80002156:	00 00       	add	r0,r0
80002158:	80 00       	ld.sh	r0,r0[0x0]
8000215a:	ce 18       	rjmp	8000231c <ButtonConfig_reply_func+0x18>
8000215c:	80 00       	ld.sh	r0,r0[0x0]
8000215e:	6e 30       	ld.w	r0,r7[0xc]

80002160 <FD_reply_func>:
	
	
}

void FD_reply_func(xcmp_fragment_t * xcmp)
{
80002160:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Reply \n\r");
80002162:	48 3c       	lddpc	r12,8000216c <FD_reply_func+0xc>
80002164:	f0 1f 00 03 	mcall	80002170 <FD_reply_func+0x10>
	
	
}
80002168:	d8 02       	popm	pc
8000216a:	00 00       	add	r0,r0
8000216c:	80 00       	ld.sh	r0,r0[0x0]
8000216e:	ce 38       	rjmp	80002334 <ButtonConfig_reply_func+0x30>
80002170:	80 00       	ld.sh	r0,r0[0x0]
80002172:	6e 30       	ld.w	r0,r7[0xc]

80002174 <FD_request_func>:
}



void FD_request_func(xcmp_fragment_t * xcmp)
{
80002174:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Request \n\r");
80002176:	48 3c       	lddpc	r12,80002180 <FD_request_func+0xc>
80002178:	f0 1f 00 03 	mcall	80002184 <FD_request_func+0x10>
	
	
}
8000217c:	d8 02       	popm	pc
8000217e:	00 00       	add	r0,r0
80002180:	80 00       	ld.sh	r0,r0[0x0]
80002182:	ce 54       	brge	8000214c <FD_brdcst_func>
80002184:	80 00       	ld.sh	r0,r0[0x0]
80002186:	6e 30       	ld.w	r0,r7[0xc]

80002188 <EnOB_brdcst_func>:
	
	
}

void EnOB_brdcst_func(xcmp_fragment_t * xcmp)
{
80002188:	d4 01       	pushm	lr
	
	
	log("\n\r En_OB Broadcast \n\r");
8000218a:	48 3c       	lddpc	r12,80002194 <EnOB_brdcst_func+0xc>
8000218c:	f0 1f 00 03 	mcall	80002198 <EnOB_brdcst_func+0x10>
}
80002190:	d8 02       	popm	pc
80002192:	00 00       	add	r0,r0
80002194:	80 00       	ld.sh	r0,r0[0x0]
80002196:	ce 70       	breq	80002164 <FD_reply_func+0x4>
80002198:	80 00       	ld.sh	r0,r0[0x0]
8000219a:	6e 30       	ld.w	r0,r7[0xc]

8000219c <EnOB_reply_func>:
}



void EnOB_reply_func(xcmp_fragment_t * xcmp)
{
8000219c:	eb cd 40 80 	pushm	r7,lr
800021a0:	18 97       	mov	r7,r12
		/*point to xcmp payload*/
	//En_OB_Control_reply_t *ptr = (En_OB_Control_reply_t* )xcmp->u8;
	//log("\n\r Xcmp_opcode: %x \n\r", xcmp->xcmp_opcode);
	
	if (xcmp->u8[0]== xcmp_Res_Success)
800021a2:	19 a9       	ld.ub	r9,r12[0x2]
800021a4:	30 08       	mov	r8,0
800021a6:	f0 09 18 00 	cp.b	r9,r8
800021aa:	c1 91       	brne	800021dc <EnOB_reply_func+0x40>
	{
		if (xcmp->u8[1] == EN_OB_Enter)
800021ac:	19 b8       	ld.ub	r8,r12[0x3]
800021ae:	30 19       	mov	r9,1
800021b0:	f2 08 18 00 	cp.b	r8,r9
800021b4:	c0 61       	brne	800021c0 <EnOB_reply_func+0x24>
		{
		
			log("\n\r En_OB_Enter OK \n\r");
800021b6:	49 0c       	lddpc	r12,800021f4 <EnOB_reply_func+0x58>
800021b8:	f0 1f 00 10 	mcall	800021f8 <EnOB_reply_func+0x5c>
800021bc:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else if (xcmp->u8[1] == EN_OB_Exit )
800021c0:	58 08       	cp.w	r8,0
800021c2:	c0 61       	brne	800021ce <EnOB_reply_func+0x32>
		{
			log("\n\r En_OB_Exit OK \n\r");
800021c4:	48 ec       	lddpc	r12,800021fc <EnOB_reply_func+0x60>
800021c6:	f0 1f 00 0d 	mcall	800021f8 <EnOB_reply_func+0x5c>
800021ca:	e3 cd 80 80 	ldm	sp++,r7,pc
		}
		else
		{
			
			log("\n\r En_OB_Control: %x \n\r", xcmp->u8[1]);
800021ce:	1a d8       	st.w	--sp,r8
800021d0:	48 cc       	lddpc	r12,80002200 <EnOB_reply_func+0x64>
800021d2:	f0 1f 00 0a 	mcall	800021f8 <EnOB_reply_func+0x5c>
800021d6:	2f fd       	sub	sp,-4
800021d8:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r En_OB_Control error \n\r");
800021dc:	48 ac       	lddpc	r12,80002204 <EnOB_reply_func+0x68>
800021de:	f0 1f 00 07 	mcall	800021f8 <EnOB_reply_func+0x5c>
		log("\n\r En_OB_result: %x \n\r", xcmp->u8[0]);
800021e2:	0f a8       	ld.ub	r8,r7[0x2]
800021e4:	1a d8       	st.w	--sp,r8
800021e6:	48 9c       	lddpc	r12,80002208 <EnOB_reply_func+0x6c>
800021e8:	f0 1f 00 04 	mcall	800021f8 <EnOB_reply_func+0x5c>
800021ec:	2f fd       	sub	sp,-4
800021ee:	e3 cd 80 80 	ldm	sp++,r7,pc
800021f2:	00 00       	add	r0,r0
800021f4:	80 00       	ld.sh	r0,r0[0x0]
800021f6:	ce 88       	rjmp	800023c6 <DataSession_brdcst_func+0x7e>
800021f8:	80 00       	ld.sh	r0,r0[0x0]
800021fa:	6e 30       	ld.w	r0,r7[0xc]
800021fc:	80 00       	ld.sh	r0,r0[0x0]
800021fe:	ce a0       	breq	800021d2 <EnOB_reply_func+0x36>
80002200:	80 00       	ld.sh	r0,r0[0x0]
80002202:	ce b4       	brge	800021d8 <EnOB_reply_func+0x3c>
80002204:	80 00       	ld.sh	r0,r0[0x0]
80002206:	ce cc       	rcall	800023de <DataSession_brdcst_func+0x96>
80002208:	80 00       	ld.sh	r0,r0[0x0]
8000220a:	ce e8       	rjmp	800023e6 <DataSession_brdcst_func+0x9e>

8000220c <SingleDetection_brdcst_func>:
	
}


void SingleDetection_brdcst_func(xcmp_fragment_t * xcmp)
{
8000220c:	d4 01       	pushm	lr
	if (xcmp->u8[0] == 0x11)
8000220e:	19 a9       	ld.ub	r9,r12[0x2]
80002210:	31 18       	mov	r8,17
80002212:	f0 09 18 00 	cp.b	r9,r8
80002216:	c0 41       	brne	8000221e <SingleDetection_brdcst_func+0x12>
	{
		log("\n\r DMR_CSBK OK \n\r");
80002218:	48 2c       	lddpc	r12,80002220 <SingleDetection_brdcst_func+0x14>
8000221a:	f0 1f 00 03 	mcall	80002224 <SingleDetection_brdcst_func+0x18>
8000221e:	d8 02       	popm	pc
80002220:	80 00       	ld.sh	r0,r0[0x0]
80002222:	cf 00       	breq	80002202 <EnOB_reply_func+0x66>
80002224:	80 00       	ld.sh	r0,r0[0x0]
80002226:	6e 30       	ld.w	r0,r7[0xc]

80002228 <ButtonConfig_brdcst_func>:
	
}


void ButtonConfig_brdcst_func(xcmp_fragment_t * xcmp)
{
80002228:	d4 31       	pushm	r0-r7,lr
	U8 Num_Button =0;
	U8 i = 0 ;
	/*point to xcmp payload*/
	ButtonConfig_brdcst_t  *ptr = (ButtonConfig_brdcst_t* )xcmp->u8;
8000222a:	f8 c7 ff fe 	sub	r7,r12,-2
	
	Num_Button = ptr->NumOfButtons;
8000222e:	0f 95       	ld.ub	r5,r7[0x1]
	
	log("\n\r ButtonConfig_broadcast  \n\r"  );
80002230:	4a bc       	lddpc	r12,800022dc <ButtonConfig_brdcst_func+0xb4>
80002232:	f0 1f 00 2c 	mcall	800022e0 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r Function: %X \n\r" , ptr->Function );
80002236:	0f 88       	ld.ub	r8,r7[0x0]
80002238:	1a d8       	st.w	--sp,r8
8000223a:	4a bc       	lddpc	r12,800022e4 <ButtonConfig_brdcst_func+0xbc>
8000223c:	f0 1f 00 29 	mcall	800022e0 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
80002240:	1a d5       	st.w	--sp,r5
80002242:	4a ac       	lddpc	r12,800022e8 <ButtonConfig_brdcst_func+0xc0>
80002244:	f0 1f 00 27 	mcall	800022e0 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
80002248:	0f a8       	ld.ub	r8,r7[0x2]
8000224a:	1a d8       	st.w	--sp,r8
8000224c:	4a 8c       	lddpc	r12,800022ec <ButtonConfig_brdcst_func+0xc4>
8000224e:	f0 1f 00 25 	mcall	800022e0 <ButtonConfig_brdcst_func+0xb8>
	
	for (i; i<Num_Button; i++)
80002252:	2f dd       	sub	sp,-12
80002254:	58 05       	cp.w	r5,0
80002256:	c4 10       	breq	800022d8 <ButtonConfig_brdcst_func+0xb0>
80002258:	30 06       	mov	r6,0
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
8000225a:	4a 64       	lddpc	r4,800022f0 <ButtonConfig_brdcst_func+0xc8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
8000225c:	4a 63       	lddpc	r3,800022f4 <ButtonConfig_brdcst_func+0xcc>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
8000225e:	4a 72       	lddpc	r2,800022f8 <ButtonConfig_brdcst_func+0xd0>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
80002260:	4a 71       	lddpc	r1,800022fc <ButtonConfig_brdcst_func+0xd4>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
80002262:	4a 80       	lddpc	r0,80002300 <ButtonConfig_brdcst_func+0xd8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
80002264:	0f b9       	ld.ub	r9,r7[0x3]
80002266:	0f c8       	ld.ub	r8,r7[0x4]
80002268:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000226c:	1a d8       	st.w	--sp,r8
8000226e:	1a d6       	st.w	--sp,r6
80002270:	08 9c       	mov	r12,r4
80002272:	f0 1f 00 1c 	mcall	800022e0 <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
80002276:	0f d9       	ld.ub	r9,r7[0x5]
80002278:	0f e8       	ld.ub	r8,r7[0x6]
8000227a:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000227e:	1a d8       	st.w	--sp,r8
80002280:	1a d6       	st.w	--sp,r6
80002282:	06 9c       	mov	r12,r3
80002284:	f0 1f 00 17 	mcall	800022e0 <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
80002288:	0f f9       	ld.ub	r9,r7[0x7]
8000228a:	ef 38 00 08 	ld.ub	r8,r7[8]
8000228e:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002292:	1a d8       	st.w	--sp,r8
80002294:	1a d6       	st.w	--sp,r6
80002296:	04 9c       	mov	r12,r2
80002298:	f0 1f 00 12 	mcall	800022e0 <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
8000229c:	ef 39 00 09 	ld.ub	r9,r7[9]
800022a0:	ef 38 00 0a 	ld.ub	r8,r7[10]
800022a4:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800022a8:	1a d8       	st.w	--sp,r8
800022aa:	1a d6       	st.w	--sp,r6
800022ac:	02 9c       	mov	r12,r1
800022ae:	f0 1f 00 0d 	mcall	800022e0 <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
800022b2:	2f 8d       	sub	sp,-32
800022b4:	ef 39 00 0b 	ld.ub	r9,r7[11]
800022b8:	ef 38 00 0c 	ld.ub	r8,r7[12]
800022bc:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800022c0:	1a d8       	st.w	--sp,r8
800022c2:	1a d6       	st.w	--sp,r6
800022c4:	00 9c       	mov	r12,r0
800022c6:	f0 1f 00 07 	mcall	800022e0 <ButtonConfig_brdcst_func+0xb8>
800022ca:	2f f6       	sub	r6,-1
800022cc:	2f 67       	sub	r7,-10
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
800022ce:	2f ed       	sub	sp,-8
800022d0:	ec 05 18 00 	cp.b	r5,r6
800022d4:	fe 9b ff c8 	brhi	80002264 <ButtonConfig_brdcst_func+0x3c>
800022d8:	d8 32       	popm	r0-r7,pc
800022da:	00 00       	add	r0,r0
800022dc:	80 00       	ld.sh	r0,r0[0x0]
800022de:	cf 14       	brge	800022c0 <ButtonConfig_brdcst_func+0x98>
800022e0:	80 00       	ld.sh	r0,r0[0x0]
800022e2:	6e 30       	ld.w	r0,r7[0xc]
800022e4:	80 00       	ld.sh	r0,r0[0x0]
800022e6:	cf 34       	brge	800022cc <ButtonConfig_brdcst_func+0xa4>
800022e8:	80 00       	ld.sh	r0,r0[0x0]
800022ea:	cf 48       	rjmp	800024d2 <CallControl_brdcst_func+0x42>
800022ec:	80 00       	ld.sh	r0,r0[0x0]
800022ee:	cf 60       	breq	800022da <ButtonConfig_brdcst_func+0xb2>
800022f0:	80 00       	ld.sh	r0,r0[0x0]
800022f2:	cf 80       	breq	800022e2 <ButtonConfig_brdcst_func+0xba>
800022f4:	80 00       	ld.sh	r0,r0[0x0]
800022f6:	cf a8       	rjmp	800024ea <TransmitControl_brdcst_func+0x16>
800022f8:	80 00       	ld.sh	r0,r0[0x0]
800022fa:	cf d0       	breq	800022f4 <ButtonConfig_brdcst_func+0xcc>
800022fc:	80 00       	ld.sh	r0,r0[0x0]
800022fe:	cf f4       	brge	800022fc <ButtonConfig_brdcst_func+0xd4>
80002300:	80 00       	ld.sh	r0,r0[0x0]
80002302:	d0 1c       	*unknown*

80002304 <ButtonConfig_reply_func>:
	}
	
}

void ButtonConfig_reply_func(xcmp_fragment_t * xcmp)
{
80002304:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	ButtonConfig_reply_t *ptr = (ButtonConfig_reply_t* )(xcmp->u8);
80002308:	f8 c7 ff fe 	sub	r7,r12,-2
	if (ptr->Result == xcmp_Res_Success)
8000230c:	0f 89       	ld.ub	r9,r7[0x0]
8000230e:	30 08       	mov	r8,0
80002310:	f0 09 18 00 	cp.b	r9,r8
80002314:	c0 c1       	brne	8000232c <ButtonConfig_reply_func+0x28>
	{
		log("\n\r Button_Config OK \n\r");
80002316:	48 9c       	lddpc	r12,80002338 <ButtonConfig_reply_func+0x34>
80002318:	f0 1f 00 09 	mcall	8000233c <ButtonConfig_reply_func+0x38>
		
		log("\n\r Function: %X \n\r" , ptr->Function );
8000231c:	0f 98       	ld.ub	r8,r7[0x1]
8000231e:	1a d8       	st.w	--sp,r8
80002320:	48 8c       	lddpc	r12,80002340 <ButtonConfig_reply_func+0x3c>
80002322:	f0 1f 00 07 	mcall	8000233c <ButtonConfig_reply_func+0x38>
80002326:	2f fd       	sub	sp,-4
80002328:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r Button_Request error \n\r");
8000232c:	48 6c       	lddpc	r12,80002344 <ButtonConfig_reply_func+0x40>
8000232e:	f0 1f 00 04 	mcall	8000233c <ButtonConfig_reply_func+0x38>
80002332:	e3 cd 80 80 	ldm	sp++,r7,pc
80002336:	00 00       	add	r0,r0
80002338:	80 00       	ld.sh	r0,r0[0x0]
8000233a:	d0 40       	acall	0x4
8000233c:	80 00       	ld.sh	r0,r0[0x0]
8000233e:	6e 30       	ld.w	r0,r7[0xc]
80002340:	80 00       	ld.sh	r0,r0[0x0]
80002342:	cf 34       	brge	80002328 <ButtonConfig_reply_func+0x24>
80002344:	80 00       	ld.sh	r0,r0[0x0]
80002346:	d0 58       	*unknown*

80002348 <DataSession_brdcst_func>:
	}
	
}

void DataSession_brdcst_func(xcmp_fragment_t * xcmp)
{
80002348:	d4 21       	pushm	r4-r7,lr
	U8 Session_number = 0;
	U16 data_length = 0;
	U8 i = 0;
	/*point to xcmp payload*/
	DataSession_brdcst_t *ptr = (DataSession_brdcst_t* )xcmp->u8;
8000234a:	f8 c6 ff fe 	sub	r6,r12,-2

	if (ptr->State == CSBK_DATA_RX_Suc)
8000234e:	0d 88       	ld.ub	r8,r6[0x0]
80002350:	32 49       	mov	r9,36
80002352:	f2 08 18 00 	cp.b	r8,r9
80002356:	c2 91       	brne	800023a8 <DataSession_brdcst_func+0x60>
	{
		
		log("\n\r CSBK_RX OK \n\r");
80002358:	4a 7c       	lddpc	r12,800023f4 <DataSession_brdcst_func+0xac>
8000235a:	f0 1f 00 28 	mcall	800023f8 <DataSession_brdcst_func+0xb0>
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
8000235e:	0d a5       	ld.ub	r5,r6[0x2]
80002360:	0d b8       	ld.ub	r8,r6[0x3]
80002362:	f1 e5 10 85 	or	r5,r8,r5<<0x8
80002366:	5c 85       	casts.h	r5

		log("\n\r Session_ID: %x \n\r",Session_number );
80002368:	0d 98       	ld.ub	r8,r6[0x1]
8000236a:	1a d8       	st.w	--sp,r8
8000236c:	4a 4c       	lddpc	r12,800023fc <DataSession_brdcst_func+0xb4>
8000236e:	f0 1f 00 23 	mcall	800023f8 <DataSession_brdcst_func+0xb0>
		log("\n\r paylaod_length: %d \n\r",data_length );
80002372:	f1 d5 c0 10 	bfextu	r8,r5,0x0,0x10
80002376:	1a d8       	st.w	--sp,r8
80002378:	4a 2c       	lddpc	r12,80002400 <DataSession_brdcst_func+0xb8>
8000237a:	f0 1f 00 20 	mcall	800023f8 <DataSession_brdcst_func+0xb0>
		for(i=0; i<data_length; i++)
8000237e:	2f ed       	sub	sp,-8
80002380:	58 05       	cp.w	r5,0
80002382:	c3 70       	breq	800023f0 <DataSession_brdcst_func+0xa8>
80002384:	30 07       	mov	r7,0
		{
			
			//log("\n\r payload[%d]: %X \n\r", i, xcmp->u8[4+i]);
			log("\n\r payload[%d]: %X \n\r", i, ptr->DataPayload.DataPayload[i]);
80002386:	4a 04       	lddpc	r4,80002404 <DataSession_brdcst_func+0xbc>
80002388:	ec 07 00 08 	add	r8,r6,r7
8000238c:	11 c8       	ld.ub	r8,r8[0x4]
8000238e:	1a d8       	st.w	--sp,r8
80002390:	1a d7       	st.w	--sp,r7
80002392:	08 9c       	mov	r12,r4
80002394:	f0 1f 00 19 	mcall	800023f8 <DataSession_brdcst_func+0xb0>
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);

		log("\n\r Session_ID: %x \n\r",Session_number );
		log("\n\r paylaod_length: %d \n\r",data_length );
		for(i=0; i<data_length; i++)
80002398:	2f f7       	sub	r7,-1
8000239a:	5c 57       	castu.b	r7
8000239c:	2f ed       	sub	sp,-8
8000239e:	ee 05 19 00 	cp.h	r5,r7
800023a2:	fe 9b ff f3 	brhi	80002388 <DataSession_brdcst_func+0x40>
800023a6:	d8 22       	popm	r4-r7,pc
		
	}
	else
	{
		//log("\n\r State: 0x %X \n\r", xcmp->u8[0]);
		log("State: %X \n", ptr->State);
800023a8:	1a d8       	st.w	--sp,r8
800023aa:	49 8c       	lddpc	r12,80002408 <DataSession_brdcst_func+0xc0>
800023ac:	f0 1f 00 13 	mcall	800023f8 <DataSession_brdcst_func+0xb0>
		if (ptr->State == DATA_SESSION_TX_Suc)
800023b0:	0d 88       	ld.ub	r8,r6[0x0]
800023b2:	2f fd       	sub	sp,-4
800023b4:	30 39       	mov	r9,3
800023b6:	f2 08 18 00 	cp.b	r8,r9
800023ba:	c0 51       	brne	800023c4 <DataSession_brdcst_func+0x7c>
		{
			log("data transmit success\n");
800023bc:	49 4c       	lddpc	r12,8000240c <DataSession_brdcst_func+0xc4>
800023be:	f0 1f 00 0f 	mcall	800023f8 <DataSession_brdcst_func+0xb0>
800023c2:	c0 88       	rjmp	800023d2 <DataSession_brdcst_func+0x8a>
		}
		else if(ptr->State == DATA_SESSION_TX_Fail)
800023c4:	30 49       	mov	r9,4
800023c6:	f2 08 18 00 	cp.b	r8,r9
800023ca:	c0 41       	brne	800023d2 <DataSession_brdcst_func+0x8a>
		{
			log("data transmit failure\n");
800023cc:	49 1c       	lddpc	r12,80002410 <DataSession_brdcst_func+0xc8>
800023ce:	f0 1f 00 0b 	mcall	800023f8 <DataSession_brdcst_func+0xb0>
			//xcmp_IdleTestTone(Tone_Start, BT_Disconnecting_Success_Tone);//set tone to indicate send-failure!!!
		}
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];
			
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
800023d2:	0d a7       	ld.ub	r7,r6[0x2]
800023d4:	0d b8       	ld.ub	r8,r6[0x3]
800023d6:	f1 e7 10 87 	or	r7,r8,r7<<0x8

		log("\n\r Session_ID: %x \n\r",Session_number );
800023da:	0d 98       	ld.ub	r8,r6[0x1]
800023dc:	1a d8       	st.w	--sp,r8
800023de:	48 8c       	lddpc	r12,800023fc <DataSession_brdcst_func+0xb4>
800023e0:	f0 1f 00 06 	mcall	800023f8 <DataSession_brdcst_func+0xb0>
		log("\n\r paylaod_length: %d \n\r",data_length );
800023e4:	5c 77       	castu.h	r7
800023e6:	1a d7       	st.w	--sp,r7
800023e8:	48 6c       	lddpc	r12,80002400 <DataSession_brdcst_func+0xb8>
800023ea:	f0 1f 00 04 	mcall	800023f8 <DataSession_brdcst_func+0xb0>
800023ee:	2f ed       	sub	sp,-8
800023f0:	d8 22       	popm	r4-r7,pc
800023f2:	00 00       	add	r0,r0
800023f4:	80 00       	ld.sh	r0,r0[0x0]
800023f6:	d0 74       	*unknown*
800023f8:	80 00       	ld.sh	r0,r0[0x0]
800023fa:	6e 30       	ld.w	r0,r7[0xc]
800023fc:	80 00       	ld.sh	r0,r0[0x0]
800023fe:	d0 88       	*unknown*
80002400:	80 00       	ld.sh	r0,r0[0x0]
80002402:	d0 a0       	acall	0xa
80002404:	80 00       	ld.sh	r0,r0[0x0]
80002406:	d0 bc       	*unknown*
80002408:	80 00       	ld.sh	r0,r0[0x0]
8000240a:	d0 d4       	*unknown*
8000240c:	80 00       	ld.sh	r0,r0[0x0]
8000240e:	d0 e0       	acall	0xe
80002410:	80 00       	ld.sh	r0,r0[0x0]
80002412:	d0 f8       	*unknown*

80002414 <DataSession_reply_func>:
	
	
}

void DataSession_reply_func(xcmp_fragment_t * xcmp)
{
80002414:	eb cd 40 80 	pushm	r7,lr
80002418:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
8000241a:	19 a9       	ld.ub	r9,r12[0x2]
8000241c:	30 08       	mov	r8,0
8000241e:	f0 09 18 00 	cp.b	r9,r8
80002422:	c1 11       	brne	80002444 <DataSession_reply_func+0x30>
	{
		log("DATArep OK \n");
80002424:	49 3c       	lddpc	r12,80002470 <DataSession_reply_func+0x5c>
80002426:	f0 1f 00 14 	mcall	80002474 <DataSession_reply_func+0x60>
		log("Func: %X \n", xcmp->u8[1]);
8000242a:	0f b8       	ld.ub	r8,r7[0x3]
8000242c:	1a d8       	st.w	--sp,r8
8000242e:	49 3c       	lddpc	r12,80002478 <DataSession_reply_func+0x64>
80002430:	f0 1f 00 11 	mcall	80002474 <DataSession_reply_func+0x60>
		log("ID: %X \n", xcmp->u8[2]);
80002434:	0f c8       	ld.ub	r8,r7[0x4]
80002436:	1a d8       	st.w	--sp,r8
80002438:	49 1c       	lddpc	r12,8000247c <DataSession_reply_func+0x68>
8000243a:	f0 1f 00 0f 	mcall	80002474 <DataSession_reply_func+0x60>
8000243e:	2f ed       	sub	sp,-8
80002440:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	else
	{	
		log("DATArep error \n");
80002444:	48 fc       	lddpc	r12,80002480 <DataSession_reply_func+0x6c>
80002446:	f0 1f 00 0c 	mcall	80002474 <DataSession_reply_func+0x60>
		log("Result:  %X \n", xcmp->u8[0]);
8000244a:	0f a8       	ld.ub	r8,r7[0x2]
8000244c:	1a d8       	st.w	--sp,r8
8000244e:	48 ec       	lddpc	r12,80002484 <DataSession_reply_func+0x70>
80002450:	f0 1f 00 09 	mcall	80002474 <DataSession_reply_func+0x60>
		log("Func:  %X \n", xcmp->u8[1]);
80002454:	0f b8       	ld.ub	r8,r7[0x3]
80002456:	1a d8       	st.w	--sp,r8
80002458:	48 cc       	lddpc	r12,80002488 <DataSession_reply_func+0x74>
8000245a:	f0 1f 00 07 	mcall	80002474 <DataSession_reply_func+0x60>
		log("ID:  %X \n", xcmp->u8[2]);
8000245e:	0f c8       	ld.ub	r8,r7[0x4]
80002460:	1a d8       	st.w	--sp,r8
80002462:	48 bc       	lddpc	r12,8000248c <DataSession_reply_func+0x78>
80002464:	f0 1f 00 04 	mcall	80002474 <DataSession_reply_func+0x60>
80002468:	2f dd       	sub	sp,-12
8000246a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000246e:	00 00       	add	r0,r0
80002470:	80 00       	ld.sh	r0,r0[0x0]
80002472:	d1 10       	acall	0x11
80002474:	80 00       	ld.sh	r0,r0[0x0]
80002476:	6e 30       	ld.w	r0,r7[0xc]
80002478:	80 00       	ld.sh	r0,r0[0x0]
8000247a:	d1 20       	acall	0x12
8000247c:	80 00       	ld.sh	r0,r0[0x0]
8000247e:	d1 2c       	*unknown*
80002480:	80 00       	ld.sh	r0,r0[0x0]
80002482:	d1 38       	*unknown*
80002484:	80 00       	ld.sh	r0,r0[0x0]
80002486:	d1 48       	*unknown*
80002488:	80 00       	ld.sh	r0,r0[0x0]
8000248a:	d1 58       	*unknown*
8000248c:	80 00       	ld.sh	r0,r0[0x0]
8000248e:	d1 64       	*unknown*

80002490 <CallControl_brdcst_func>:
	
}


void CallControl_brdcst_func(xcmp_fragment_t * xcmp)
{
80002490:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	CallControl_brdcst_t *ptr = (CallControl_brdcst_t* )xcmp->u8;
80002494:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  CallControl brst \n\r ");
	//log("\n\r  Call_type: %x \n\r ", ptr->Calltype );
	log("\n\r  Call_state: %x \n\r ", ptr->Callstate );
80002498:	0f 98       	ld.ub	r8,r7[0x1]
8000249a:	1a d8       	st.w	--sp,r8
8000249c:	48 bc       	lddpc	r12,800024c8 <CallControl_brdcst_func+0x38>
8000249e:	f0 1f 00 0c 	mcall	800024cc <CallControl_brdcst_func+0x3c>
	if (ptr->Callstate == Call_Ended)//0x03
800024a2:	2f fd       	sub	sp,-4
800024a4:	0f 99       	ld.ub	r9,r7[0x1]
800024a6:	30 38       	mov	r8,3
800024a8:	f0 09 18 00 	cp.b	r9,r8
800024ac:	c0 41       	brne	800024b4 <CallControl_brdcst_func+0x24>
	{
		//恢复正常语音路径通道
		//xcmp_audio_route_revert();
		Call_Begin = 0;
800024ae:	30 09       	mov	r9,0
800024b0:	48 88       	lddpc	r8,800024d0 <CallControl_brdcst_func+0x40>
800024b2:	b0 89       	st.b	r8[0x0],r9
		
	}
	
	if (ptr->Callstate == Call_Initiated)//0x04
800024b4:	0f 99       	ld.ub	r9,r7[0x1]
800024b6:	30 48       	mov	r8,4
800024b8:	f0 09 18 00 	cp.b	r9,r8
800024bc:	c0 41       	brne	800024c4 <CallControl_brdcst_func+0x34>
	{
		Call_Begin = 1;
800024be:	30 19       	mov	r9,1
800024c0:	48 48       	lddpc	r8,800024d0 <CallControl_brdcst_func+0x40>
800024c2:	b0 89       	st.b	r8[0x0],r9
800024c4:	e3 cd 80 80 	ldm	sp++,r7,pc
800024c8:	80 00       	ld.sh	r0,r0[0x0]
800024ca:	d1 70       	acall	0x17
800024cc:	80 00       	ld.sh	r0,r0[0x0]
800024ce:	6e 30       	ld.w	r0,r7[0xc]
800024d0:	00 00       	add	r0,r0
800024d2:	0a 45       	or	r5,r5

800024d4 <TransmitControl_brdcst_func>:

}


void TransmitControl_brdcst_func(xcmp_fragment_t * xcmp)
{
800024d4:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	TransmitControl_brdcast_t *ptr = (TransmitControl_brdcast_t* )xcmp->u8;
800024d8:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  TransmitControl broadcast \n\r ");
	//log("\n\r  Mode_Of_Operation: %x \n\r ", ptr->Mode_Of_Operation );
	if (ptr->State == 0x00)
800024dc:	0f 99       	ld.ub	r9,r7[0x1]
800024de:	30 08       	mov	r8,0
800024e0:	f0 09 18 00 	cp.b	r9,r8
800024e4:	c0 71       	brne	800024f2 <TransmitControl_brdcst_func+0x1e>
	{
		log("\n\r  Standby-Receive \n\r ");
800024e6:	48 ac       	lddpc	r12,8000250c <TransmitControl_brdcst_func+0x38>
800024e8:	f0 1f 00 0a 	mcall	80002510 <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 0;
800024ec:	30 09       	mov	r9,0
800024ee:	48 a8       	lddpc	r8,80002514 <TransmitControl_brdcst_func+0x40>
800024f0:	b0 89       	st.b	r8[0x0],r9
	}
	if (ptr->State == 0x01)
800024f2:	0f 99       	ld.ub	r9,r7[0x1]
800024f4:	30 18       	mov	r8,1
800024f6:	f0 09 18 00 	cp.b	r9,r8
800024fa:	c0 71       	brne	80002508 <TransmitControl_brdcst_func+0x34>
	{
		log("\n\r  Transmit \n\r ");
800024fc:	48 7c       	lddpc	r12,80002518 <TransmitControl_brdcst_func+0x44>
800024fe:	f0 1f 00 05 	mcall	80002510 <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 1;
80002502:	30 19       	mov	r9,1
80002504:	48 48       	lddpc	r8,80002514 <TransmitControl_brdcst_func+0x40>
80002506:	b0 89       	st.b	r8[0x0],r9
80002508:	e3 cd 80 80 	ldm	sp++,r7,pc
8000250c:	80 00       	ld.sh	r0,r0[0x0]
8000250e:	d1 88       	*unknown*
80002510:	80 00       	ld.sh	r0,r0[0x0]
80002512:	6e 30       	ld.w	r0,r7[0xc]
80002514:	00 00       	add	r0,r0
80002516:	0a 44       	or	r4,r5
80002518:	80 00       	ld.sh	r0,r0[0x0]
8000251a:	d1 a0       	acall	0x1a

8000251c <TransmitControl_reply_func>:




void TransmitControl_reply_func(xcmp_fragment_t * xcmp)
{
8000251c:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	TransmitControl_reply_t *ptr = (TransmitControl_reply_t* )xcmp->u8;
80002520:	f8 c7 ff fe 	sub	r7,r12,-2
	
	if (ptr->Result == xcmp_Res_Success)
80002524:	0f 89       	ld.ub	r9,r7[0x0]
80002526:	30 08       	mov	r8,0
80002528:	f0 09 18 00 	cp.b	r9,r8
8000252c:	c1 61       	brne	80002558 <TransmitControl_reply_func+0x3c>
	{
		
		log("\n\r  TransmitControl OK \n\r ");
8000252e:	48 ec       	lddpc	r12,80002564 <TransmitControl_reply_func+0x48>
80002530:	f0 1f 00 0e 	mcall	80002568 <TransmitControl_reply_func+0x4c>
		log("\n\r Function: %x \n\r", ptr->Function);
80002534:	0f 98       	ld.ub	r8,r7[0x1]
80002536:	1a d8       	st.w	--sp,r8
80002538:	48 dc       	lddpc	r12,8000256c <TransmitControl_reply_func+0x50>
8000253a:	f0 1f 00 0c 	mcall	80002568 <TransmitControl_reply_func+0x4c>
		log("\n\r Mode of Operation: %x \n\r", ptr->Mode_Of_Operation);
8000253e:	0f a8       	ld.ub	r8,r7[0x2]
80002540:	1a d8       	st.w	--sp,r8
80002542:	48 cc       	lddpc	r12,80002570 <TransmitControl_reply_func+0x54>
80002544:	f0 1f 00 09 	mcall	80002568 <TransmitControl_reply_func+0x4c>
		log("\n\r State: %x \n\r", ptr->State);
80002548:	0f b8       	ld.ub	r8,r7[0x3]
8000254a:	1a d8       	st.w	--sp,r8
8000254c:	48 ac       	lddpc	r12,80002574 <TransmitControl_reply_func+0x58>
8000254e:	f0 1f 00 07 	mcall	80002568 <TransmitControl_reply_func+0x4c>
80002552:	2f dd       	sub	sp,-12
80002554:	e3 cd 80 80 	ldm	sp++,r7,pc
		
		//Silent_flag = 1;
	}
	else
	{
		log("TransmitControl error");
80002558:	48 8c       	lddpc	r12,80002578 <TransmitControl_reply_func+0x5c>
8000255a:	f0 1f 00 04 	mcall	80002568 <TransmitControl_reply_func+0x4c>
8000255e:	e3 cd 80 80 	ldm	sp++,r7,pc
80002562:	00 00       	add	r0,r0
80002564:	80 00       	ld.sh	r0,r0[0x0]
80002566:	d1 b4       	*unknown*
80002568:	80 00       	ld.sh	r0,r0[0x0]
8000256a:	6e 30       	ld.w	r0,r7[0xc]
8000256c:	80 00       	ld.sh	r0,r0[0x0]
8000256e:	d1 d0       	acall	0x1d
80002570:	80 00       	ld.sh	r0,r0[0x0]
80002572:	d1 e4       	*unknown*
80002574:	80 00       	ld.sh	r0,r0[0x0]
80002576:	d2 00       	acall	0x20
80002578:	80 00       	ld.sh	r0,r0[0x0]
8000257a:	d2 10       	acall	0x21

8000257c <AudioRoutingControl_reply_func>:
	
}


void AudioRoutingControl_reply_func(xcmp_fragment_t * xcmp)
{
8000257c:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
8000257e:	19 a9       	ld.ub	r9,r12[0x2]
80002580:	30 08       	mov	r8,0
80002582:	f0 09 18 00 	cp.b	r9,r8
80002586:	c0 51       	brne	80002590 <AudioRoutingControl_reply_func+0x14>
	{
		log("AudioRouting OK");
80002588:	48 4c       	lddpc	r12,80002598 <AudioRoutingControl_reply_func+0x1c>
8000258a:	f0 1f 00 05 	mcall	8000259c <AudioRoutingControl_reply_func+0x20>
8000258e:	d8 02       	popm	pc
		//xcmp_IdleTestTone();
		//Speaker_is_unmute = 1;
	}
	else
	{
		log("AudioRouting error");
80002590:	48 4c       	lddpc	r12,800025a0 <AudioRoutingControl_reply_func+0x24>
80002592:	f0 1f 00 03 	mcall	8000259c <AudioRoutingControl_reply_func+0x20>
80002596:	d8 02       	popm	pc
80002598:	80 00       	ld.sh	r0,r0[0x0]
8000259a:	d2 28       	*unknown*
8000259c:	80 00       	ld.sh	r0,r0[0x0]
8000259e:	6e 30       	ld.w	r0,r7[0xc]
800025a0:	80 00       	ld.sh	r0,r0[0x0]
800025a2:	d2 38       	*unknown*

800025a4 <Volume_reply_func>:
	
}


void Volume_reply_func(xcmp_fragment_t * xcmp)
{
800025a4:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	VolumeControl_reply_t *ptr = (VolumeControl_reply_t* )xcmp->u8;
800025a8:	f8 c7 ff fe 	sub	r7,r12,-2
	
		if (ptr->Result == xcmp_Res_Success)
800025ac:	0f 89       	ld.ub	r9,r7[0x0]
800025ae:	30 08       	mov	r8,0
800025b0:	f0 09 18 00 	cp.b	r9,r8
800025b4:	c1 b1       	brne	800025ea <Volume_reply_func+0x46>
		{
			if (ptr->Function == Enable_IntelligentAudio)
800025b6:	0f b8       	ld.ub	r8,r7[0x3]
800025b8:	31 09       	mov	r9,16
800025ba:	f2 08 18 00 	cp.b	r8,r9
800025be:	c0 f1       	brne	800025dc <Volume_reply_func+0x38>
			{
				log("\n\r Enable_IA OK \n\r");
800025c0:	48 dc       	lddpc	r12,800025f4 <Volume_reply_func+0x50>
800025c2:	f0 1f 00 0e 	mcall	800025f8 <Volume_reply_func+0x54>
				log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
800025c6:	0f 99       	ld.ub	r9,r7[0x1]
800025c8:	0f a8       	ld.ub	r8,r7[0x2]
800025ca:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800025ce:	1a d8       	st.w	--sp,r8
800025d0:	48 bc       	lddpc	r12,800025fc <Volume_reply_func+0x58>
800025d2:	f0 1f 00 0a 	mcall	800025f8 <Volume_reply_func+0x54>
800025d6:	2f fd       	sub	sp,-4
800025d8:	e3 cd 80 80 	ldm	sp++,r7,pc
	
			}
			else
			{
				
				log("\n\r VolumeControl: %x \n\r", ptr->Function);
800025dc:	1a d8       	st.w	--sp,r8
800025de:	48 9c       	lddpc	r12,80002600 <Volume_reply_func+0x5c>
800025e0:	f0 1f 00 06 	mcall	800025f8 <Volume_reply_func+0x54>
800025e4:	2f fd       	sub	sp,-4
800025e6:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		
		else
		{
			log("\n\r Enable_IA error \n\r");
800025ea:	48 7c       	lddpc	r12,80002604 <Volume_reply_func+0x60>
800025ec:	f0 1f 00 03 	mcall	800025f8 <Volume_reply_func+0x54>
800025f0:	e3 cd 80 80 	ldm	sp++,r7,pc
800025f4:	80 00       	ld.sh	r0,r0[0x0]
800025f6:	d2 4c       	*unknown*
800025f8:	80 00       	ld.sh	r0,r0[0x0]
800025fa:	6e 30       	ld.w	r0,r7[0xc]
800025fc:	80 00       	ld.sh	r0,r0[0x0]
800025fe:	d2 60       	acall	0x26
80002600:	80 00       	ld.sh	r0,r0[0x0]
80002602:	d2 7c       	*unknown*
80002604:	80 00       	ld.sh	r0,r0[0x0]
80002606:	d2 94       	*unknown*

80002608 <spk_brdcst_func>:
		log("spk error");
	}
}

void spk_brdcst_func(xcmp_fragment_t * xcmp)
{
80002608:	d4 01       	pushm	lr
	if (xcmp->u8[3] == xcmp_Res_Success)//0x0000:mute
8000260a:	19 d9       	ld.ub	r9,r12[0x5]
8000260c:	30 08       	mov	r8,0
8000260e:	f0 09 18 00 	cp.b	r9,r8
80002612:	c0 81       	brne	80002622 <spk_brdcst_func+0x1a>
	{
		Speaker_is_unmute =0;
80002614:	10 99       	mov	r9,r8
80002616:	48 78       	lddpc	r8,80002630 <spk_brdcst_func+0x28>
80002618:	b0 89       	st.b	r8[0x0],r9
		//Silent_flag = 0;
		log("spk_s_close ");
8000261a:	48 7c       	lddpc	r12,80002634 <spk_brdcst_func+0x2c>
8000261c:	f0 1f 00 07 	mcall	80002638 <spk_brdcst_func+0x30>
80002620:	d8 02       	popm	pc
		
	}
	else
	{
		//Silent_flag = 1;
		Speaker_is_unmute = 1;
80002622:	30 19       	mov	r9,1
80002624:	48 38       	lddpc	r8,80002630 <spk_brdcst_func+0x28>
80002626:	b0 89       	st.b	r8[0x0],r9
		log("spk_s_open ");	
80002628:	48 5c       	lddpc	r12,8000263c <spk_brdcst_func+0x34>
8000262a:	f0 1f 00 04 	mcall	80002638 <spk_brdcst_func+0x30>
8000262e:	d8 02       	popm	pc
80002630:	00 00       	add	r0,r0
80002632:	0a 40       	or	r0,r5
80002634:	80 00       	ld.sh	r0,r0[0x0]
80002636:	d2 ac       	*unknown*
80002638:	80 00       	ld.sh	r0,r0[0x0]
8000263a:	6e 30       	ld.w	r0,r7[0xc]
8000263c:	80 00       	ld.sh	r0,r0[0x0]
8000263e:	d2 bc       	*unknown*

80002640 <spk_reply_func>:
			
	
}

void spk_reply_func(xcmp_fragment_t * xcmp)
{
80002640:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
80002642:	19 a9       	ld.ub	r9,r12[0x2]
80002644:	30 08       	mov	r8,0
80002646:	f0 09 18 00 	cp.b	r9,r8
8000264a:	c0 f1       	brne	80002668 <spk_reply_func+0x28>
	{
		
		if(xcmp->u8[4])
8000264c:	19 e9       	ld.ub	r9,r12[0x6]
8000264e:	f0 09 18 00 	cp.b	r9,r8
80002652:	c0 40       	breq	8000265a <spk_reply_func+0x1a>
		{
			Speaker_is_unmute = 1;
80002654:	30 19       	mov	r9,1
80002656:	48 98       	lddpc	r8,80002678 <spk_reply_func+0x38>
80002658:	b0 89       	st.b	r8[0x0],r9
			
			//Silent_flag = 1;
		}
		log("spk OK -st%2x", xcmp->u8[4] );
8000265a:	19 e8       	ld.ub	r8,r12[0x6]
8000265c:	1a d8       	st.w	--sp,r8
8000265e:	48 8c       	lddpc	r12,8000267c <spk_reply_func+0x3c>
80002660:	f0 1f 00 08 	mcall	80002680 <spk_reply_func+0x40>
80002664:	2f fd       	sub	sp,-4
80002666:	d8 02       	popm	pc
		
	}
	else
	{
		Speaker_is_unmute = 0;
80002668:	30 09       	mov	r9,0
8000266a:	48 48       	lddpc	r8,80002678 <spk_reply_func+0x38>
8000266c:	b0 89       	st.b	r8[0x0],r9
		log("spk error");
8000266e:	48 6c       	lddpc	r12,80002684 <spk_reply_func+0x44>
80002670:	f0 1f 00 04 	mcall	80002680 <spk_reply_func+0x40>
80002674:	d8 02       	popm	pc
80002676:	00 00       	add	r0,r0
80002678:	00 00       	add	r0,r0
8000267a:	0a 40       	or	r0,r5
8000267c:	80 00       	ld.sh	r0,r0[0x0]
8000267e:	d2 c8       	*unknown*
80002680:	80 00       	ld.sh	r0,r0[0x0]
80002682:	6e 30       	ld.w	r0,r7[0xc]
80002684:	80 00       	ld.sh	r0,r0[0x0]
80002686:	d2 d8       	*unknown*

80002688 <mic_brdcst_func>:
	
	
}

void mic_brdcst_func(xcmp_fragment_t * xcmp)
{
80002688:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_brdcast_t *ptr = (MicControl_brdcast_t* )xcmp->u8;
8000268c:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r Mic_brdcst \n\r");		
	//log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
	//log("\n\r Signal_type: %x \n\r " ,  ptr->Signaling_Type);
	if (ptr->Mic_State == 0x00)
80002690:	0f a9       	ld.ub	r9,r7[0x2]
80002692:	30 08       	mov	r8,0
80002694:	f0 09 18 00 	cp.b	r9,r8
80002698:	c0 71       	brne	800026a6 <mic_brdcst_func+0x1e>
	{
		log("\n\r Mic_Disabled \n\r");	
8000269a:	48 dc       	lddpc	r12,800026cc <mic_brdcst_func+0x44>
8000269c:	f0 1f 00 0d 	mcall	800026d0 <mic_brdcst_func+0x48>
		Mic_is_Enabled = 0;
800026a0:	30 09       	mov	r9,0
800026a2:	48 d8       	lddpc	r8,800026d4 <mic_brdcst_func+0x4c>
800026a4:	b0 89       	st.b	r8[0x0],r9
	} 
	if(ptr->Mic_State == 0x11)
800026a6:	0f a9       	ld.ub	r9,r7[0x2]
800026a8:	31 18       	mov	r8,17
800026aa:	f0 09 18 00 	cp.b	r9,r8
800026ae:	c0 d1       	brne	800026c8 <mic_brdcst_func+0x40>
	{
		log("\n\r Mic_Enabled \n\r");
800026b0:	48 ac       	lddpc	r12,800026d8 <mic_brdcst_func+0x50>
800026b2:	f0 1f 00 08 	mcall	800026d0 <mic_brdcst_func+0x48>
		Mic_is_Enabled = 1;
800026b6:	48 89       	lddpc	r9,800026d4 <mic_brdcst_func+0x4c>
800026b8:	30 18       	mov	r8,1
800026ba:	b2 88       	st.b	r9[0x0],r8
		
		if ((Mic_is_Enabled == 1) && (Call_Begin == 1))
800026bc:	13 89       	ld.ub	r9,r9[0x0]
800026be:	f0 09 18 00 	cp.b	r9,r8
800026c2:	c0 31       	brne	800026c8 <mic_brdcst_func+0x40>
800026c4:	48 68       	lddpc	r8,800026dc <mic_brdcst_func+0x54>
800026c6:	11 88       	ld.ub	r8,r8[0x0]
800026c8:	e3 cd 80 80 	ldm	sp++,r7,pc
800026cc:	80 00       	ld.sh	r0,r0[0x0]
800026ce:	d2 e4       	*unknown*
800026d0:	80 00       	ld.sh	r0,r0[0x0]
800026d2:	6e 30       	ld.w	r0,r7[0xc]
800026d4:	00 00       	add	r0,r0
800026d6:	0a 54       	eor	r4,r5
800026d8:	80 00       	ld.sh	r0,r0[0x0]
800026da:	d2 f8       	*unknown*
800026dc:	00 00       	add	r0,r0
800026de:	0a 45       	or	r5,r5

800026e0 <mic_reply_func>:
	
	
}

void mic_reply_func(xcmp_fragment_t * xcmp)
{
800026e0:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_reply_t *ptr = (MicControl_reply_t* )xcmp->u8;
800026e4:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Mic_reply \n\r");
800026e8:	49 ac       	lddpc	r12,80002750 <mic_reply_func+0x70>
800026ea:	f0 1f 00 1b 	mcall	80002754 <mic_reply_func+0x74>
	if (ptr->Result == 0x00)
800026ee:	0f 89       	ld.ub	r9,r7[0x0]
800026f0:	30 08       	mov	r8,0
800026f2:	f0 09 18 00 	cp.b	r9,r8
800026f6:	c2 71       	brne	80002744 <mic_reply_func+0x64>
	{
		
		if (ptr->Function == Mic_Disable)
800026f8:	0f 98       	ld.ub	r8,r7[0x1]
800026fa:	30 29       	mov	r9,2
800026fc:	f2 08 18 00 	cp.b	r8,r9
80002700:	c1 b1       	brne	80002736 <mic_reply_func+0x56>
		{
		
			log("\n\r Mic_close_ok \n\r " );
80002702:	49 6c       	lddpc	r12,80002758 <mic_reply_func+0x78>
80002704:	f0 1f 00 14 	mcall	80002754 <mic_reply_func+0x74>
			log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
80002708:	0f a8       	ld.ub	r8,r7[0x2]
8000270a:	1a d8       	st.w	--sp,r8
8000270c:	49 4c       	lddpc	r12,8000275c <mic_reply_func+0x7c>
8000270e:	f0 1f 00 12 	mcall	80002754 <mic_reply_func+0x74>
			log("\n\r Signaling_type: %x \n\r " ,  ptr->Signaling_Type);
80002712:	0f b8       	ld.ub	r8,r7[0x3]
80002714:	1a d8       	st.w	--sp,r8
80002716:	49 3c       	lddpc	r12,80002760 <mic_reply_func+0x80>
80002718:	f0 1f 00 0f 	mcall	80002754 <mic_reply_func+0x74>
			log("\n\r Mic_state: %x \n\r " ,  ptr->Mic_State);
8000271c:	0f c8       	ld.ub	r8,r7[0x4]
8000271e:	1a d8       	st.w	--sp,r8
80002720:	49 1c       	lddpc	r12,80002764 <mic_reply_func+0x84>
80002722:	f0 1f 00 0d 	mcall	80002754 <mic_reply_func+0x74>
			log("\n\r Gain_offset: %x \n\r " ,  ptr->Gain_Offset);
80002726:	0f d8       	ld.ub	r8,r7[0x5]
80002728:	1a d8       	st.w	--sp,r8
8000272a:	49 0c       	lddpc	r12,80002768 <mic_reply_func+0x88>
8000272c:	f0 1f 00 0a 	mcall	80002754 <mic_reply_func+0x74>
80002730:	2f cd       	sub	sp,-16
80002732:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else
		{
			log("\n\r Mic_function: %x \n\r ", ptr->Function );
80002736:	1a d8       	st.w	--sp,r8
80002738:	48 dc       	lddpc	r12,8000276c <mic_reply_func+0x8c>
8000273a:	f0 1f 00 07 	mcall	80002754 <mic_reply_func+0x74>
8000273e:	2f fd       	sub	sp,-4
80002740:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else 
	{
		
	
		log("\n\r Mic error \n\r");
80002744:	48 bc       	lddpc	r12,80002770 <mic_reply_func+0x90>
80002746:	f0 1f 00 04 	mcall	80002754 <mic_reply_func+0x74>
8000274a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000274e:	00 00       	add	r0,r0
80002750:	80 00       	ld.sh	r0,r0[0x0]
80002752:	d3 0c       	*unknown*
80002754:	80 00       	ld.sh	r0,r0[0x0]
80002756:	6e 30       	ld.w	r0,r7[0xc]
80002758:	80 00       	ld.sh	r0,r0[0x0]
8000275a:	d3 1c       	*unknown*
8000275c:	80 00       	ld.sh	r0,r0[0x0]
8000275e:	d3 30       	acall	0x33
80002760:	80 00       	ld.sh	r0,r0[0x0]
80002762:	d3 44       	*unknown*
80002764:	80 00       	ld.sh	r0,r0[0x0]
80002766:	d3 60       	acall	0x36
80002768:	80 00       	ld.sh	r0,r0[0x0]
8000276a:	d3 78       	*unknown*
8000276c:	80 00       	ld.sh	r0,r0[0x0]
8000276e:	d3 90       	acall	0x39
80002770:	80 00       	ld.sh	r0,r0[0x0]
80002772:	d3 a8       	*unknown*

80002774 <dcm_brdcst_func>:
	}
}


void dcm_brdcst_func(xcmp_fragment_t * xcmp)
{
80002774:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	DeviceControlMode_brdcst_t *ptr = (DeviceControlMode_brdcst_t* )xcmp->u8;
80002778:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Dcm_brdcst \n\r");		
8000277c:	48 bc       	lddpc	r12,800027a8 <dcm_brdcst_func+0x34>
8000277e:	f0 1f 00 0c 	mcall	800027ac <dcm_brdcst_func+0x38>
	log("\n\r Function: %x \n\r " ,  ptr->Function);
80002782:	0f 88       	ld.ub	r8,r7[0x0]
80002784:	1a d8       	st.w	--sp,r8
80002786:	48 bc       	lddpc	r12,800027b0 <dcm_brdcst_func+0x3c>
80002788:	f0 1f 00 09 	mcall	800027ac <dcm_brdcst_func+0x38>
	log("\n\r ControlType: %x \n\r " ,  ptr->ControlType);
8000278c:	0f a8       	ld.ub	r8,r7[0x2]
8000278e:	1a d8       	st.w	--sp,r8
80002790:	48 9c       	lddpc	r12,800027b4 <dcm_brdcst_func+0x40>
80002792:	f0 1f 00 07 	mcall	800027ac <dcm_brdcst_func+0x38>
	log("\n\r ControlTypeSize: %x \n\r " ,  ptr->ControlTypeSize);
80002796:	0f 98       	ld.ub	r8,r7[0x1]
80002798:	1a d8       	st.w	--sp,r8
8000279a:	48 8c       	lddpc	r12,800027b8 <dcm_brdcst_func+0x44>
8000279c:	f0 1f 00 04 	mcall	800027ac <dcm_brdcst_func+0x38>
800027a0:	2f dd       	sub	sp,-12
	
	
}
800027a2:	e3 cd 80 80 	ldm	sp++,r7,pc
800027a6:	00 00       	add	r0,r0
800027a8:	80 00       	ld.sh	r0,r0[0x0]
800027aa:	d3 b8       	*unknown*
800027ac:	80 00       	ld.sh	r0,r0[0x0]
800027ae:	6e 30       	ld.w	r0,r7[0xc]
800027b0:	80 00       	ld.sh	r0,r0[0x0]
800027b2:	d3 cc       	*unknown*
800027b4:	80 00       	ld.sh	r0,r0[0x0]
800027b6:	d3 e0       	acall	0x3e
800027b8:	80 00       	ld.sh	r0,r0[0x0]
800027ba:	d3 f8       	*unknown*

800027bc <dcm_reply_func>:
		log("Tone error");
	}
}

void dcm_reply_func(xcmp_fragment_t * xcmp)
{
800027bc:	eb cd 40 80 	pushm	r7,lr
800027c0:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
800027c2:	19 a9       	ld.ub	r9,r12[0x2]
800027c4:	30 08       	mov	r8,0
800027c6:	f0 09 18 00 	cp.b	r9,r8
800027ca:	c1 b1       	brne	80002800 <dcm_reply_func+0x44>
	{
		if(xcmp->u8[1] == DCM_ENTER)
800027cc:	19 b8       	ld.ub	r8,r12[0x3]
800027ce:	30 19       	mov	r9,1
800027d0:	f2 08 18 00 	cp.b	r8,r9
800027d4:	c0 51       	brne	800027de <dcm_reply_func+0x22>
		{
			log("\n\r Dcm-Enter OK \n\r");
800027d6:	48 ec       	lddpc	r12,8000280c <dcm_reply_func+0x50>
800027d8:	f0 1f 00 0e 	mcall	80002810 <dcm_reply_func+0x54>
800027dc:	c0 a8       	rjmp	800027f0 <dcm_reply_func+0x34>
			
		}
		else if (xcmp->u8[1] == DCM_EXIT)
800027de:	58 08       	cp.w	r8,0
800027e0:	c0 51       	brne	800027ea <dcm_reply_func+0x2e>
		{
			log("\n\r Dcm-Exit OK \n\r");
800027e2:	48 dc       	lddpc	r12,80002814 <dcm_reply_func+0x58>
800027e4:	f0 1f 00 0b 	mcall	80002810 <dcm_reply_func+0x54>
800027e8:	c0 48       	rjmp	800027f0 <dcm_reply_func+0x34>
		}
		else
		{
			log("\n\r Dcm-Revoke \n\r");
800027ea:	48 cc       	lddpc	r12,80002818 <dcm_reply_func+0x5c>
800027ec:	f0 1f 00 09 	mcall	80002810 <dcm_reply_func+0x54>
		}
		
		log("dcm OK-mo%X", xcmp->u8[3]);
800027f0:	0f d8       	ld.ub	r8,r7[0x5]
800027f2:	1a d8       	st.w	--sp,r8
800027f4:	48 ac       	lddpc	r12,8000281c <dcm_reply_func+0x60>
800027f6:	f0 1f 00 07 	mcall	80002810 <dcm_reply_func+0x54>
800027fa:	2f fd       	sub	sp,-4
800027fc:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		log("dcm error");
80002800:	48 8c       	lddpc	r12,80002820 <dcm_reply_func+0x64>
80002802:	f0 1f 00 04 	mcall	80002810 <dcm_reply_func+0x54>
80002806:	e3 cd 80 80 	ldm	sp++,r7,pc
8000280a:	00 00       	add	r0,r0
8000280c:	80 00       	ld.sh	r0,r0[0x0]
8000280e:	d4 14       	*unknown*
80002810:	80 00       	ld.sh	r0,r0[0x0]
80002812:	6e 30       	ld.w	r0,r7[0xc]
80002814:	80 00       	ld.sh	r0,r0[0x0]
80002816:	d4 28       	*unknown*
80002818:	80 00       	ld.sh	r0,r0[0x0]
8000281a:	d4 3c       	*unknown*
8000281c:	80 00       	ld.sh	r0,r0[0x0]
8000281e:	d4 50       	acall	0x45
80002820:	80 00       	ld.sh	r0,r0[0x0]
80002822:	d4 5c       	*unknown*

80002824 <ToneControl_reply_func>:
			}
		}
}

void ToneControl_reply_func(xcmp_fragment_t * xcmp)
{
80002824:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
80002826:	19 a9       	ld.ub	r9,r12[0x2]
80002828:	30 08       	mov	r8,0
8000282a:	f0 09 18 00 	cp.b	r9,r8
8000282e:	c0 51       	brne	80002838 <ToneControl_reply_func+0x14>
	{		
		log("Tone OK\n");
80002830:	48 4c       	lddpc	r12,80002840 <ToneControl_reply_func+0x1c>
80002832:	f0 1f 00 05 	mcall	80002844 <ToneControl_reply_func+0x20>
80002836:	d8 02       	popm	pc
		//fl_write("/test.txt", FILE_END, (void *)"send tone ok\r\n", sizeof("send tone ok\r\n") - 1);
	}
	else
	{
		log("Tone error");
80002838:	48 4c       	lddpc	r12,80002848 <ToneControl_reply_func+0x24>
8000283a:	f0 1f 00 03 	mcall	80002844 <ToneControl_reply_func+0x20>
8000283e:	d8 02       	popm	pc
80002840:	80 00       	ld.sh	r0,r0[0x0]
80002842:	d4 68       	*unknown*
80002844:	80 00       	ld.sh	r0,r0[0x0]
80002846:	6e 30       	ld.w	r0,r7[0xc]
80002848:	80 00       	ld.sh	r0,r0[0x0]
8000284a:	d4 74       	*unknown*

8000284c <Phyuserinput_brdcst_func>:
	
}


void Phyuserinput_brdcst_func(xcmp_fragment_t * xcmp)
{
8000284c:	eb cd 40 80 	pushm	r7,lr
	U8 PUI_State_Min_Value =0;
	U8 PUI_State_Max_Value =0;
	
	PUI_Source = xcmp->u8[0];
	PUI_Type = xcmp ->u8[1];
	PUI_ID = ((xcmp->u8[2]<<8) | xcmp->u8[3]);
80002850:	19 c7       	ld.ub	r7,r12[0x4]
80002852:	19 d8       	ld.ub	r8,r12[0x5]
80002854:	f1 e7 10 87 	or	r7,r8,r7<<0x8
80002858:	5c 87       	casts.h	r7
	PUI_State = xcmp->u8[4];
	PUI_State_Min_Value = xcmp->u8[5];
	PUI_State_Max_Value = xcmp->u8[6];
	
	log("PhysicalUserInput_broadcast  \n\r"  );
8000285a:	48 dc       	lddpc	r12,8000288c <Phyuserinput_brdcst_func+0x40>
8000285c:	f0 1f 00 0d 	mcall	80002890 <Phyuserinput_brdcst_func+0x44>
	
	if((PUI_ID == 0x0060) && (PUI_State = 0x02) && (connect_flag == 1)){
80002860:	36 08       	mov	r8,96
80002862:	f0 07 19 00 	cp.h	r7,r8
80002866:	c1 11       	brne	80002888 <Phyuserinput_brdcst_func+0x3c>
80002868:	48 b8       	lddpc	r8,80002894 <Phyuserinput_brdcst_func+0x48>
8000286a:	11 89       	ld.ub	r9,r8[0x0]
8000286c:	30 18       	mov	r8,1
8000286e:	f0 09 18 00 	cp.b	r9,r8
80002872:	c0 b1       	brne	80002888 <Phyuserinput_brdcst_func+0x3c>
		//log("send message\n");
		xcmp_IdleTestTone(Tone_Start, ACK_Received_Tone);//set tone to indicate the scan!!!
80002874:	31 4b       	mov	r11,20
80002876:	30 1c       	mov	r12,1
80002878:	f0 1f 00 08 	mcall	80002898 <Phyuserinput_brdcst_func+0x4c>
			
		vTaskDelay(400*2 / portTICK_RATE_MS);//延迟400ms
8000287c:	e0 6c 03 20 	mov	r12,800
80002880:	f0 1f 00 07 	mcall	8000289c <Phyuserinput_brdcst_func+0x50>
		//delay_ms(200);
		rfid_sendID_message();//send message		
80002884:	f0 1f 00 07 	mcall	800028a0 <Phyuserinput_brdcst_func+0x54>
80002888:	e3 cd 80 80 	ldm	sp++,r7,pc
8000288c:	80 00       	ld.sh	r0,r0[0x0]
8000288e:	d4 80       	acall	0x48
80002890:	80 00       	ld.sh	r0,r0[0x0]
80002892:	6e 30       	ld.w	r0,r7[0xc]
80002894:	00 00       	add	r0,r0
80002896:	0a 4c       	or	r12,r5
80002898:	80 00       	ld.sh	r0,r0[0x0]
8000289a:	41 3c       	lddsp	r12,sp[0x4c]
8000289c:	80 00       	ld.sh	r0,r0[0x0]
8000289e:	68 c4       	ld.w	r4,r4[0x30]
800028a0:	80 00       	ld.sh	r0,r0[0x0]
800028a2:	51 10       	stdsp	sp[0x44],r0

800028a4 <DeviceInitializationStatus_brdcst_func>:
static void app_payload_tx_proc(void  * payload);

//app func--list

void DeviceInitializationStatus_brdcst_func(xcmp_fragment_t  * xcmp)
{
800028a4:	d4 01       	pushm	lr
	if (xcmp->u8[4] == 0x01)
800028a6:	19 e8       	ld.ub	r8,r12[0x6]
800028a8:	30 19       	mov	r9,1
800028aa:	f2 08 18 00 	cp.b	r8,r9
800028ae:	c0 61       	brne	800028ba <DeviceInitializationStatus_brdcst_func+0x16>
	{
		bunchofrandomstatusflags |= 0x01;  //Need do nothing else.
800028b0:	48 98       	lddpc	r8,800028d4 <DeviceInitializationStatus_brdcst_func+0x30>
800028b2:	70 09       	ld.w	r9,r8[0x0]
800028b4:	a1 a9       	sbr	r9,0x0
800028b6:	91 09       	st.w	r8[0x0],r9
800028b8:	d8 02       	popm	pc
	}
	else if(xcmp->u8[4] != 0x02)
800028ba:	30 29       	mov	r9,2
800028bc:	f2 08 18 00 	cp.b	r8,r9
800028c0:	c0 80       	breq	800028d0 <DeviceInitializationStatus_brdcst_func+0x2c>
	{
		bunchofrandomstatusflags  &= 0xFFFFFFFC; //Device Init no longer Complete.
800028c2:	48 58       	lddpc	r8,800028d4 <DeviceInitializationStatus_brdcst_func+0x30>
800028c4:	70 09       	ld.w	r9,r8[0x0]
800028c6:	e0 19 ff fc 	andl	r9,0xfffc
800028ca:	91 09       	st.w	r8[0x0],r9
		xcmp_DeviceInitializationStatus_request();
800028cc:	f0 1f 00 03 	mcall	800028d8 <DeviceInitializationStatus_brdcst_func+0x34>
800028d0:	d8 02       	popm	pc
800028d2:	00 00       	add	r0,r0
800028d4:	00 00       	add	r0,r0
800028d6:	0d 80       	ld.ub	r0,r6[0x0]
800028d8:	80 00       	ld.sh	r0,r0[0x0]
800028da:	40 90       	lddsp	r0,sp[0x24]

800028dc <RTC_ENcodeTime>:
	RTC_Test();	

}

U32 RTC_ENcodeTime(DateTime *DT)
{
800028dc:	eb cd 40 fc 	pushm	r2-r7,lr
	    U8 T,K;
	    U32 T32,TimeData=0;
	    for(T=0,K=0;T<DT->Year;T++){                    //累加年份
800028e0:	19 8e       	ld.ub	lr,r12[0x0]
800028e2:	58 0e       	cp.w	lr,0
800028e4:	c0 41       	brne	800028ec <RTC_ENcodeTime+0x10>
800028e6:	30 0a       	mov	r10,0
800028e8:	14 99       	mov	r9,r10
800028ea:	c1 78       	rjmp	80002918 <RTC_ENcodeTime+0x3c>
800028ec:	30 09       	mov	r9,0
800028ee:	12 98       	mov	r8,r9
		    K=T&0x03;
		    TimeData+=K?31536000:31622400;
800028f0:	e0 66 33 80 	mov	r6,13184
800028f4:	ea 16 01 e1 	orh	r6,0x1e1
800028f8:	e0 67 85 00 	mov	r7,34048
800028fc:	ea 17 01 e2 	orh	r7,0x1e2
U32 RTC_ENcodeTime(DateTime *DT)
{
	    U8 T,K;
	    U32 T32,TimeData=0;
	    for(T=0,K=0;T<DT->Year;T++){                    //累加年份
		    K=T&0x03;
80002900:	f5 d8 c0 02 	bfextu	r10,r8,0x0,0x2
		    TimeData+=K?31536000:31622400;
80002904:	ec 0b 17 10 	movne	r11,r6
80002908:	ee 0b 17 00 	moveq	r11,r7
8000290c:	16 09       	add	r9,r11

U32 RTC_ENcodeTime(DateTime *DT)
{
	    U8 T,K;
	    U32 T32,TimeData=0;
	    for(T=0,K=0;T<DT->Year;T++){                    //累加年份
8000290e:	2f f8       	sub	r8,-1
80002910:	5c 58       	castu.b	r8
80002912:	fc 08 18 00 	cp.b	r8,lr
80002916:	cf 53       	brcs	80002900 <RTC_ENcodeTime+0x24>
		    K=T&0x03;
		    TimeData+=K?31536000:31622400;
	    }
	    for(T=1;T<DT->Month;T++){
80002918:	19 97       	ld.ub	r7,r12[0x1]
8000291a:	30 18       	mov	r8,1
8000291c:	0e 9e       	mov	lr,r7
8000291e:	f0 07 18 00 	cp.b	r7,r8
80002922:	e0 88 00 31 	brls	80002984 <RTC_ENcodeTime+0xa8>
80002926:	30 0b       	mov	r11,0
80002928:	30 18       	mov	r8,1
		    if(T!=2){                        //统计平月
8000292a:	30 26       	mov	r6,2
			    T32=((T+(T>>3))&0x01)?2678400:2592000;
		    }else T32=K?2419200:2505600;                //统计闰月
8000292c:	e0 6e 3b 80 	mov	lr,15232
80002930:	ea 1e 00 26 	orh	lr,0x26
80002934:	e0 63 ea 00 	mov	r3,59904
80002938:	ea 13 00 24 	orh	r3,0x24
8000293c:	16 3a       	cp.w	r10,r11
8000293e:	fc 03 17 00 	moveq	r3,lr
		    K=T&0x03;
		    TimeData+=K?31536000:31622400;
	    }
	    for(T=1;T<DT->Month;T++){
		    if(T!=2){                        //统计平月
			    T32=((T+(T>>3))&0x01)?2678400:2592000;
80002942:	e0 64 de 80 	mov	r4,56960
80002946:	ea 14 00 28 	orh	r4,0x28
8000294a:	e0 65 8d 00 	mov	r5,36096
8000294e:	ea 15 00 27 	orh	r5,0x27
	    for(T=0,K=0;T<DT->Year;T++){                    //累加年份
		    K=T&0x03;
		    TimeData+=K?31536000:31622400;
	    }
	    for(T=1;T<DT->Month;T++){
		    if(T!=2){                        //统计平月
80002952:	ec 08 18 00 	cp.b	r8,r6
80002956:	c0 e0       	breq	80002972 <RTC_ENcodeTime+0x96>
			    T32=((T+(T>>3))&0x01)?2678400:2592000;
80002958:	f6 c2 ff ff 	sub	r2,r11,-1
8000295c:	f0 0e 16 03 	lsr	lr,r8,0x3
80002960:	e4 0e 00 0e 	add	lr,r2,lr
80002964:	fd de c0 01 	bfextu	lr,lr,0x0,0x1
80002968:	e8 0e 17 10 	movne	lr,r4
8000296c:	ea 0e 17 00 	moveq	lr,r5
80002970:	c0 28       	rjmp	80002974 <RTC_ENcodeTime+0x98>
		    }else T32=K?2419200:2505600;                //统计闰月
80002972:	06 9e       	mov	lr,r3
		    TimeData+=T32;
80002974:	1c 09       	add	r9,lr
	    U32 T32,TimeData=0;
	    for(T=0,K=0;T<DT->Year;T++){                    //累加年份
		    K=T&0x03;
		    TimeData+=K?31536000:31622400;
	    }
	    for(T=1;T<DT->Month;T++){
80002976:	2f f8       	sub	r8,-1
80002978:	5c 58       	castu.b	r8
8000297a:	2f fb       	sub	r11,-1
8000297c:	0e 9e       	mov	lr,r7
8000297e:	ee 08 18 00 	cp.b	r8,r7
80002982:	ce 81       	brne	80002952 <RTC_ENcodeTime+0x76>
		    if(T!=2){                        //统计平月
			    T32=((T+(T>>3))&0x01)?2678400:2592000;
		    }else T32=K?2419200:2505600;                //统计闰月
		    TimeData+=T32;
	    }
	    T32=DT->Day-1;TimeData+=T32*86400;                //统计天
80002984:	19 ba       	ld.ub	r10,r12[0x3]
80002986:	e0 68 0e 10 	mov	r8,3600
8000298a:	b1 3a       	mul	r10,r8
8000298c:	19 c8       	ld.ub	r8,r12[0x4]
8000298e:	f0 0b 15 04 	lsl	r11,r8,0x4
80002992:	f6 08 01 08 	sub	r8,r11,r8
80002996:	f4 08 00 28 	add	r8,r10,r8<<0x2
	    T32=DT->Hour;TimeData+=T32*3600;                //统计时
8000299a:	19 da       	ld.ub	r10,r12[0x5]
8000299c:	14 08       	add	r8,r10
	    T32=DT->Minute;TimeData+=T32*60;                //统计分
8000299e:	19 aa       	ld.ub	r10,r12[0x2]
800029a0:	20 1a       	sub	r10,1
800029a2:	e0 7b 51 80 	mov	r11,86400
800029a6:	b7 3a       	mul	r10,r11
800029a8:	f0 0a 00 0c 	add	r12,r8,r10
	    TimeData+=DT->Second;                        //统计秒
	    return TimeData;
	
}
800029ac:	12 0c       	add	r12,r9
800029ae:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc

800029b2 <RTC_DecodeTime>:

void RTC_DecodeTime(U32 TimeData, DateTime *DT)
{
800029b2:	eb cd 40 c0 	pushm	r6-r7,lr
	    U8 T,K;
	    U32 T16,K16;
	    K16=TimeData%86400;                    //分离时/分/秒
800029b6:	e0 69 45 07 	mov	r9,17671
800029ba:	ea 19 c2 2e 	orh	r9,0xc22e
800029be:	f8 09 06 48 	mulu.d	r8,r12,r9
800029c2:	f2 0e 16 10 	lsr	lr,r9,0x10
800029c6:	e0 7a 51 80 	mov	r10,86400
800029ca:	b5 3e       	mul	lr,r10
800029cc:	f8 0e 01 0e 	sub	lr,r12,lr
	    T16=TimeData/86400;                    //分离年/月/日
800029d0:	b1 89       	lsr	r9,0x10
	    DT->Second=K16%60;                    //计算秒
800029d2:	e0 68 88 89 	mov	r8,34953
800029d6:	ea 18 88 88 	orh	r8,0x8888
800029da:	fc 08 06 46 	mulu.d	r6,lr,r8
800029de:	0e 9a       	mov	r10,r7
800029e0:	a5 9a       	lsr	r10,0x5
800029e2:	f4 0c 15 04 	lsl	r12,r10,0x4
800029e6:	14 1c       	sub	r12,r10
800029e8:	fc 0c 01 2e 	sub	lr,lr,r12<<0x2
800029ec:	b6 de       	st.b	r11[0x5],lr
	    K16/=60;DT->Minute=K16%60;                //计算分
800029ee:	f4 08 06 46 	mulu.d	r6,r10,r8
800029f2:	0e 98       	mov	r8,r7
800029f4:	a5 98       	lsr	r8,0x5
800029f6:	f0 0c 15 04 	lsl	r12,r8,0x4
800029fa:	10 1c       	sub	r12,r8
800029fc:	f4 0c 01 2a 	sub	r10,r10,r12<<0x2
80002a00:	b6 ca       	st.b	r11[0x4],r10
	    K16/=60;DT->Hour=K16%24;                //计算时
80002a02:	e0 67 aa ab 	mov	r7,43691
80002a06:	ea 17 aa aa 	orh	r7,0xaaaa
80002a0a:	f0 07 06 46 	mulu.d	r6,r8,r7
80002a0e:	0e 9a       	mov	r10,r7
80002a10:	a5 8a       	lsr	r10,0x4
80002a12:	f4 0a 00 1a 	add	r10,r10,r10<<0x1
80002a16:	f0 0a 01 38 	sub	r8,r8,r10<<0x3
80002a1a:	b6 b8       	st.b	r11[0x3],r8
80002a1c:	30 08       	mov	r8,0
	    for(K16=0,T=0;T<150;T++){                //按天累计年份
		    K16=(T&0x03)?365:366;                //统计闰年
80002a1e:	e0 67 01 6d 	mov	r7,365
80002a22:	e0 6e 01 6e 	mov	lr,366
	    U32 T16,K16;
	    K16=TimeData%86400;                    //分离时/分/秒
	    T16=TimeData/86400;                    //分离年/月/日
	    DT->Second=K16%60;                    //计算秒
	    K16/=60;DT->Minute=K16%60;                //计算分
	    K16/=60;DT->Hour=K16%24;                //计算时
80002a26:	f9 d8 c0 08 	bfextu	r12,r8,0x0,0x8
	    for(K16=0,T=0;T<150;T++){                //按天累计年份
		    K16=(T&0x03)?365:366;                //统计闰年
80002a2a:	f5 d8 c0 02 	bfextu	r10,r8,0x0,0x2
80002a2e:	ee 0a 17 10 	movne	r10,r7
80002a32:	fc 0a 17 00 	moveq	r10,lr
		    if(T16<K16){K16-=337;break;}            //计算当年二月份天数
80002a36:	12 3a       	cp.w	r10,r9
80002a38:	e0 88 00 05 	brls	80002a42 <RTC_DecodeTime+0x90>
80002a3c:	f4 ca 01 51 	sub	r10,r10,337
80002a40:	c0 88       	rjmp	80002a50 <RTC_DecodeTime+0x9e>
		    else T16-=K16;                    //减掉年份
80002a42:	14 19       	sub	r9,r10
80002a44:	2f fc       	sub	r12,-1
80002a46:	5c 5c       	castu.b	r12
80002a48:	2f f8       	sub	r8,-1
	    K16=TimeData%86400;                    //分离时/分/秒
	    T16=TimeData/86400;                    //分离年/月/日
	    DT->Second=K16%60;                    //计算秒
	    K16/=60;DT->Minute=K16%60;                //计算分
	    K16/=60;DT->Hour=K16%24;                //计算时
	    for(K16=0,T=0;T<150;T++){                //按天累计年份
80002a4a:	e0 48 00 96 	cp.w	r8,150
80002a4e:	ce c1       	brne	80002a26 <RTC_DecodeTime+0x74>
		    K16=(T&0x03)?365:366;                //统计闰年
		    if(T16<K16){K16-=337;break;}            //计算当年二月份天数
		    else T16-=K16;                    //减掉年份
	    }
	    DT->Year=T;                        //计算得到相对年份
80002a50:	b6 8c       	st.b	r11[0x0],r12
80002a52:	30 18       	mov	r8,1
	    for(T=1;T<13;T++){
		    K=(T==2)?K16:(((T+(T>>3))&0x01)+30);        //统计当月天数
80002a54:	30 2e       	mov	lr,2
80002a56:	5c 5a       	castu.b	r10
		    K16=(T&0x03)?365:366;                //统计闰年
		    if(T16<K16){K16-=337;break;}            //计算当年二月份天数
		    else T16-=K16;                    //减掉年份
	    }
	    DT->Year=T;                        //计算得到相对年份
	    for(T=1;T<13;T++){
80002a58:	30 d7       	mov	r7,13
		    K=(T==2)?K16:(((T+(T>>3))&0x01)+30);        //统计当月天数
80002a5a:	fc 08 18 00 	cp.b	r8,lr
80002a5e:	c0 90       	breq	80002a70 <RTC_DecodeTime+0xbe>
80002a60:	f0 0c 16 03 	lsr	r12,r8,0x3
80002a64:	10 0c       	add	r12,r8
80002a66:	f9 dc c0 01 	bfextu	r12,r12,0x0,0x1
80002a6a:	2e 2c       	sub	r12,-30
80002a6c:	5c 5c       	castu.b	r12
80002a6e:	c0 28       	rjmp	80002a72 <RTC_DecodeTime+0xc0>
80002a70:	14 9c       	mov	r12,r10
		    if(T16>=K)T16-=K;                //减掉当前月
80002a72:	12 3c       	cp.w	r12,r9
80002a74:	e0 8b 00 08 	brhi	80002a84 <RTC_DecodeTime+0xd2>
80002a78:	18 19       	sub	r9,r12
		    K16=(T&0x03)?365:366;                //统计闰年
		    if(T16<K16){K16-=337;break;}            //计算当年二月份天数
		    else T16-=K16;                    //减掉年份
	    }
	    DT->Year=T;                        //计算得到相对年份
	    for(T=1;T<13;T++){
80002a7a:	2f f8       	sub	r8,-1
80002a7c:	5c 58       	castu.b	r8
80002a7e:	ee 08 18 00 	cp.b	r8,r7
80002a82:	ce c1       	brne	80002a5a <RTC_DecodeTime+0xa8>
		    K=(T==2)?K16:(((T+(T>>3))&0x01)+30);        //统计当月天数
		    if(T16>=K)T16-=K;                //减掉当前月
		    else break;
	    }
	    DT->Month=T;                        //计算得到当年中的月份
80002a84:	b6 98       	st.b	r11[0x1],r8
	    DT->Day=T16+1;                        //计算得到当年中的天
80002a86:	2f f9       	sub	r9,-1
80002a88:	b6 a9       	st.b	r11[0x2],r9

}
80002a8a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002a8e:	d7 03       	nop

80002a90 <RTC_Test>:
  return &str[i];
}


void RTC_Test()
{
80002a90:	d4 01       	pushm	lr
	
	Current_time.Year	= 12;
80002a92:	48 ac       	lddpc	r12,80002ab8 <RTC_Test+0x28>
80002a94:	30 c8       	mov	r8,12
80002a96:	b8 88       	st.b	r12[0x0],r8
	Current_time.Month	= 03;
80002a98:	30 38       	mov	r8,3
80002a9a:	b8 98       	st.b	r12[0x1],r8
	Current_time.Day	= 24;
80002a9c:	31 88       	mov	r8,24
80002a9e:	b8 a8       	st.b	r12[0x2],r8
	Current_time.Hour	= 22;
80002aa0:	31 68       	mov	r8,22
80002aa2:	b8 b8       	st.b	r12[0x3],r8
	Current_time.Minute	= 15;
80002aa4:	30 f8       	mov	r8,15
80002aa6:	b8 c8       	st.b	r12[0x4],r8
	Current_time.Second = 30;
80002aa8:	31 e8       	mov	r8,30
80002aaa:	b8 d8       	st.b	r12[0x5],r8
	
	Time_scale = RTC_ENcodeTime(&Current_time);
80002aac:	f0 1f 00 04 	mcall	80002abc <RTC_Test+0x2c>
80002ab0:	48 48       	lddpc	r8,80002ac0 <RTC_Test+0x30>
80002ab2:	91 0c       	st.w	r8[0x0],r12
	
	Enable_global_interrupt();
80002ab4:	d5 03       	csrf	0x10
	

}
80002ab6:	d8 02       	popm	pc
80002ab8:	00 00       	add	r0,r0
80002aba:	1d 88       	ld.ub	r8,lr[0x0]
80002abc:	80 00       	ld.sh	r0,r0[0x0]
80002abe:	28 dc       	sub	r12,-115
80002ac0:	00 00       	add	r0,r0
80002ac2:	1d 90       	ld.ub	r0,lr[0x1]

80002ac4 <xg_rtc_init>:



void xg_rtc_init(void)
{
80002ac4:	d4 01       	pushm	lr
	
	  // Disable all interrupts. */
	  Disable_global_interrupt();
80002ac6:	d3 03       	ssrf	0x10
	  
	  // Register the RTC interrupt handler to the interrupt controller.
	  INTC_register_interrupt(&rtc_irq, AVR32_RTC_IRQ, AVR32_INTC_INT0);
80002ac8:	30 0a       	mov	r10,0
80002aca:	32 8b       	mov	r11,40
80002acc:	48 fc       	lddpc	r12,80002b08 <xg_rtc_init+0x44>
80002ace:	f0 1f 00 10 	mcall	80002b0c <xg_rtc_init+0x48>

	  // Initialize the RTC
	  if (!rtc_init(&AVR32_RTC, RTC_OSC_RC, RTC_PSEL_RC_1_76HZ))
80002ad2:	30 fa       	mov	r10,15
80002ad4:	30 0b       	mov	r11,0
80002ad6:	fe 7c 0d 00 	mov	r12,-62208
80002ada:	f0 1f 00 0e 	mcall	80002b10 <xg_rtc_init+0x4c>
80002ade:	c0 41       	brne	80002ae6 <xg_rtc_init+0x22>
	  //if (!rtc_init(&AVR32_RTC, RTC_OSC_32KHZ, RTC_PSEL_32KHZ_1HZ))
	  {
		  log("Error initializing the RTC\r\n");
80002ae0:	48 dc       	lddpc	r12,80002b14 <xg_rtc_init+0x50>
80002ae2:	f0 1f 00 0e 	mcall	80002b18 <xg_rtc_init+0x54>
	  }
	  // Set top value to 0 to generate an interrupt every seconds */
	  rtc_set_top_value(&AVR32_RTC, 0);
80002ae6:	30 0b       	mov	r11,0
80002ae8:	fe 7c 0d 00 	mov	r12,-62208
80002aec:	f0 1f 00 0c 	mcall	80002b1c <xg_rtc_init+0x58>
	  // Enable the interrupts
	  rtc_enable_interrupt(&AVR32_RTC);
80002af0:	fe 7c 0d 00 	mov	r12,-62208
80002af4:	f0 1f 00 0b 	mcall	80002b20 <xg_rtc_init+0x5c>
	  // Enable the RTC
	  rtc_enable(&AVR32_RTC);
80002af8:	fe 7c 0d 00 	mov	r12,-62208
80002afc:	f0 1f 00 0a 	mcall	80002b24 <xg_rtc_init+0x60>

	  // Enable global interrupts
	  //Enable_global_interrupt();
	  
	RTC_Test();	
80002b00:	f0 1f 00 0a 	mcall	80002b28 <xg_rtc_init+0x64>

}
80002b04:	d8 02       	popm	pc
80002b06:	00 00       	add	r0,r0
80002b08:	80 00       	ld.sh	r0,r0[0x0]
80002b0a:	2b 2c       	sub	r12,-78
80002b0c:	80 00       	ld.sh	r0,r0[0x0]
80002b0e:	54 40       	stdsp	sp[0x110],r0
80002b10:	80 00       	ld.sh	r0,r0[0x0]
80002b12:	56 3c       	stdsp	sp[0x18c],r12
80002b14:	80 00       	ld.sh	r0,r0[0x0]
80002b16:	d4 a0       	acall	0x4a
80002b18:	80 00       	ld.sh	r0,r0[0x0]
80002b1a:	6e 30       	ld.w	r0,r7[0xc]
80002b1c:	80 00       	ld.sh	r0,r0[0x0]
80002b1e:	55 f8       	stdsp	sp[0x17c],r8
80002b20:	80 00       	ld.sh	r0,r0[0x0]
80002b22:	55 f0       	stdsp	sp[0x17c],r0
80002b24:	80 00       	ld.sh	r0,r0[0x0]
80002b26:	55 cc       	stdsp	sp[0x170],r12
80002b28:	80 00       	ld.sh	r0,r0[0x0]
80002b2a:	2a 90       	sub	r0,-87

80002b2c <rtc_irq>:
/* RTC Interrupt  */
#pragma handler = AVR32_RTC_IRQ_GROUP, 1
__interrupt
#endif
void rtc_irq(void)
{
80002b2c:	d4 01       	pushm	lr
	// Increment the minutes counter
	sec++;
80002b2e:	49 49       	lddpc	r9,80002b7c <rtc_irq+0x50>
80002b30:	72 08       	ld.w	r8,r9[0x0]
80002b32:	2f f8       	sub	r8,-1
80002b34:	93 08       	st.w	r9[0x0],r8
	
	Time_scale++;
80002b36:	49 39       	lddpc	r9,80002b80 <rtc_irq+0x54>
80002b38:	72 0a       	ld.w	r10,r9[0x0]
80002b3a:	2f fa       	sub	r10,-1
80002b3c:	93 0a       	st.w	r9[0x0],r10
	
	
	if(sec%5==0){
80002b3e:	e0 6b 66 67 	mov	r11,26215
80002b42:	ea 1b 66 66 	orh	r11,0x6666
80002b46:	f0 0b 04 4a 	muls.d	r10,r8,r11
80002b4a:	f6 09 14 01 	asr	r9,r11,0x1
80002b4e:	f0 0a 14 1f 	asr	r10,r8,0x1f
80002b52:	14 19       	sub	r9,r10
80002b54:	f2 09 00 29 	add	r9,r9,r9<<0x2
80002b58:	12 18       	sub	r8,r9
80002b5a:	c0 71       	brne	80002b68 <rtc_irq+0x3c>
			
		nop();
80002b5c:	d7 03       	nop
		RTC_DecodeTime(Time_scale, &Current_time);
80002b5e:	48 98       	lddpc	r8,80002b80 <rtc_irq+0x54>
80002b60:	70 0c       	ld.w	r12,r8[0x0]
80002b62:	48 9b       	lddpc	r11,80002b84 <rtc_irq+0x58>
80002b64:	f0 1f 00 09 	mcall	80002b88 <rtc_irq+0x5c>
	}

	// clear the interrupt flag
	rtc_clear_interrupt(&AVR32_RTC);
80002b68:	fe 7c 0d 00 	mov	r12,-62208
80002b6c:	f0 1f 00 08 	mcall	80002b8c <rtc_irq+0x60>

	// specify that an interrupt has been raised
	print_sec = 1;
80002b70:	30 19       	mov	r9,1
80002b72:	48 88       	lddpc	r8,80002b90 <rtc_irq+0x64>
80002b74:	91 09       	st.w	r8[0x0],r9
}
80002b76:	d4 02       	popm	lr
80002b78:	d6 03       	rete
80002b7a:	00 00       	add	r0,r0
80002b7c:	00 00       	add	r0,r0
80002b7e:	0a 5c       	eor	r12,r5
80002b80:	00 00       	add	r0,r0
80002b82:	1d 90       	ld.ub	r0,lr[0x1]
80002b84:	00 00       	add	r0,r0
80002b86:	1d 88       	ld.ub	r8,lr[0x0]
80002b88:	80 00       	ld.sh	r0,r0[0x0]
80002b8a:	29 b2       	sub	r2,-101
80002b8c:	80 00       	ld.sh	r0,r0[0x0]
80002b8e:	56 1c       	stdsp	sp[0x184],r12
80002b90:	00 00       	add	r0,r0
80002b92:	04 f0       	st.b	--r2,r0

80002b94 <CalculateBurst>:
Calls:
Called By: phy_payload_rx
*/

volatile RxAMBEBurstType CalculateBurst(U8 vf_sn)
{
80002b94:	20 1c       	sub	r12,1
80002b96:	5c 5c       	castu.b	r12
80002b98:	31 18       	mov	r8,17
80002b9a:	f0 0c 18 00 	cp.b	r12,r8
80002b9e:	e0 88 00 03 	brls	80002ba4 <CalculateBurst+0x10>
80002ba2:	5e fd       	retal	0
80002ba4:	48 28       	lddpc	r8,80002bac <CalculateBurst+0x18>
80002ba6:	f0 0c 03 2c 	ld.w	r12,r8[r12<<0x2]
			Burst_ID = 0x00;
			return VOICE_WATING;
		
	}
	
}
80002baa:	5e fc       	retal	r12
80002bac:	80 00       	ld.sh	r0,r0[0x0]
80002bae:	d4 c0       	acall	0x4c

80002bb0 <payload_init>:
	Create the corresponding task;
Calls: xTaskCreate--freertos
Called By:app_init -- app.c
*/
void payload_init(void ( *payload_rx_func)(void * ), void ( *payload_tx_func)(void * ) )
{				
80002bb0:	d4 01       	pushm	lr
	payload_rx_exec = payload_rx_func;
80002bb2:	48 98       	lddpc	r8,80002bd4 <payload_init+0x24>
80002bb4:	91 0c       	st.w	r8[0x0],r12
	payload_tx_exec = payload_tx_func;
80002bb6:	48 98       	lddpc	r8,80002bd8 <payload_init+0x28>
80002bb8:	91 0b       	st.w	r8[0x0],r11
	
	
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
80002bba:	30 09       	mov	r9,0
80002bbc:	1a d9       	st.w	--sp,r9
80002bbe:	1a d9       	st.w	--sp,r9
80002bc0:	1a d9       	st.w	--sp,r9
80002bc2:	30 28       	mov	r8,2
80002bc4:	e0 6a 04 00 	mov	r10,1024
80002bc8:	48 5b       	lddpc	r11,80002bdc <payload_init+0x2c>
80002bca:	48 6c       	lddpc	r12,80002be0 <payload_init+0x30>
80002bcc:	f0 1f 00 06 	mcall	80002be4 <payload_init+0x34>
80002bd0:	2f dd       	sub	sp,-12
	//,  2
	//,  NULL
	//);
	//
	
}
80002bd2:	d8 02       	popm	pc
80002bd4:	00 00       	add	r0,r0
80002bd6:	0a 60       	and	r0,r5
80002bd8:	00 00       	add	r0,r0
80002bda:	0a 64       	and	r4,r5
80002bdc:	80 00       	ld.sh	r0,r0[0x0]
80002bde:	d5 08       	*unknown*
80002be0:	80 00       	ld.sh	r0,r0[0x0]
80002be2:	2b e8       	sub	r8,-66
80002be4:	80 00       	ld.sh	r0,r0[0x0]
80002be6:	6a 6c       	ld.w	r12,r5[0x18]

80002be8 <payload_rx_process>:
Description: Receive the payload
Calls:
Called By:task
*/
static void payload_rx_process(void * pvParameters)
{
80002be8:	eb cd 40 f8 	pushm	r3-r7,lr
80002bec:	20 1d       	sub	sp,4
	/*To store the elements in the queue*/
	U16  * payload_ptr;
		
	if(NULL ==   phy_payload_frame_rx)
80002bee:	48 e8       	lddpc	r8,80002c24 <payload_rx_process+0x3c>
80002bf0:	70 08       	ld.w	r8,r8[0x0]
80002bf2:	58 08       	cp.w	r8,0
80002bf4:	c0 71       	brne	80002c02 <payload_rx_process+0x1a>
	{
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
80002bf6:	30 4b       	mov	r11,4
80002bf8:	30 5c       	mov	r12,5
80002bfa:	f0 1f 00 0c 	mcall	80002c28 <payload_rx_process+0x40>
80002bfe:	48 a8       	lddpc	r8,80002c24 <payload_rx_process+0x3c>
80002c00:	91 0c       	st.w	r8[0x0],r12
	}
	
	for(;;)
	{
		if(pdTRUE == xQueueReceive( phy_payload_frame_rx, &payload_ptr,portMAX_DELAY ))
80002c02:	48 96       	lddpc	r6,80002c24 <payload_rx_process+0x3c>
80002c04:	30 05       	mov	r5,0
80002c06:	3f f4       	mov	r4,-1
		{			
			payload_rx_exec(payload_ptr);//app_payload_rx_proc();
80002c08:	48 93       	lddpc	r3,80002c2c <payload_rx_process+0x44>
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
	}
	
	for(;;)
	{
		if(pdTRUE == xQueueReceive( phy_payload_frame_rx, &payload_ptr,portMAX_DELAY ))
80002c0a:	6c 0c       	ld.w	r12,r6[0x0]
80002c0c:	0a 99       	mov	r9,r5
80002c0e:	08 9a       	mov	r10,r4
80002c10:	1a 9b       	mov	r11,sp
80002c12:	f0 1f 00 08 	mcall	80002c30 <payload_rx_process+0x48>
80002c16:	58 1c       	cp.w	r12,1
80002c18:	cf 91       	brne	80002c0a <payload_rx_process+0x22>
		{			
			payload_rx_exec(payload_ptr);//app_payload_rx_proc();
80002c1a:	66 08       	ld.w	r8,r3[0x0]
80002c1c:	40 0c       	lddsp	r12,sp[0x0]
80002c1e:	5d 18       	icall	r8
80002c20:	cf 5b       	rjmp	80002c0a <payload_rx_process+0x22>
80002c22:	00 00       	add	r0,r0
80002c24:	00 00       	add	r0,r0
80002c26:	0a 90       	mov	r0,r5
80002c28:	80 00       	ld.sh	r0,r0[0x0]
80002c2a:	63 50       	ld.w	r0,r1[0x54]
80002c2c:	00 00       	add	r0,r0
80002c2e:	0a 60       	and	r0,r5
80002c30:	80 00       	ld.sh	r0,r0[0x0]
80002c32:	60 44       	ld.w	r4,r0[0x10]

80002c34 <set_idle_store_isr>:
{
	xQueueSend(store, &ptr, 0);
}

void set_idle_store_isr(xQueueHandle store, void * ptr)
{
80002c34:	d4 01       	pushm	lr
80002c36:	20 2d       	sub	sp,8
80002c38:	50 0b       	stdsp	sp[0x0],r11
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002c3a:	30 09       	mov	r9,0
80002c3c:	fa ca ff f8 	sub	r10,sp,-8
80002c40:	14 d9       	st.w	--r10,r9
	xQueueSendFromISR(store, &ptr, &xHigherPriorityTaskWoken);
80002c42:	1a 9b       	mov	r11,sp
80002c44:	f0 1f 00 02 	mcall	80002c4c <set_idle_store_isr+0x18>
}
80002c48:	2f ed       	sub	sp,-8
80002c4a:	d8 02       	popm	pc
80002c4c:	80 00       	ld.sh	r0,r0[0x0]
80002c4e:	62 00       	ld.w	r0,r1[0x0]

80002c50 <phy_rx>:
	xQueueSendFromISR -- freertos
Called By: phy_xnl_rx
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
80002c50:	d4 01       	pushm	lr
80002c52:	20 2d       	sub	sp,8
80002c54:	50 0c       	stdsp	sp[0x0],r12
	//memcpy(xx, phy_ptr, sizeof(phy_fragment_t));
	//set_phy_idle_isr(&phy_ptr, &xHigherPriorityTaskWoken);
	
	Bool res = FALSE;
	
	if(NULL == phy_ptr)
80002c56:	58 0c       	cp.w	r12,0
80002c58:	c1 10       	breq	80002c7a <phy_rx+0x2a>
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
    /*variables are used to store the push result in interrupt*/
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002c5a:	30 08       	mov	r8,0
80002c5c:	50 18       	stdsp	sp[0x4],r8
	if(NULL == phy_ptr)
	{
		return;
	}
	
    U16 phy_ctrl = phy_ptr->xnl_fragment.phy_header.phy_control;
80002c5e:	98 88       	ld.uh	r8,r12[0x0]
80002c60:	e2 18 f0 00 	andl	r8,0xf000,COH
80002c64:	e0 48 40 00 	cp.w	r8,16384
80002c68:	c0 91       	brne	80002c7a <phy_rx+0x2a>

    if (XCMPXNL_DATA == (phy_ctrl & 0xF000))
    {
        /*push the xnl packet to queue*/
        if( pdTRUE == xQueueSendFromISR(
80002c6a:	48 68       	lddpc	r8,80002c80 <phy_rx+0x30>
80002c6c:	70 0c       	ld.w	r12,r8[0x0]
80002c6e:	30 09       	mov	r9,0
80002c70:	fa ca ff fc 	sub	r10,sp,-4
80002c74:	1a 9b       	mov	r11,sp
80002c76:	f0 1f 00 04 	mcall	80002c84 <phy_rx+0x34>
		}	

    }
		
 
}
80002c7a:	2f ed       	sub	sp,-8
80002c7c:	d8 02       	popm	pc
80002c7e:	00 00       	add	r0,r0
80002c80:	00 00       	add	r0,r0
80002c82:	0a bc       	st.h	r5++,r12
80002c84:	80 00       	ld.sh	r0,r0[0x0]
80002c86:	62 00       	ld.w	r0,r1[0x0]

80002c88 <set_idle_store>:
	}
}


void set_idle_store(xQueueHandle store, void * ptr)
{
80002c88:	eb cd 40 80 	pushm	r7,lr
80002c8c:	20 1d       	sub	sp,4
80002c8e:	fa c7 ff fc 	sub	r7,sp,-4
80002c92:	0e db       	st.w	--r7,r11
	xQueueSend(store, &ptr, 0);
80002c94:	30 09       	mov	r9,0
80002c96:	12 9a       	mov	r10,r9
80002c98:	1a 9b       	mov	r11,sp
80002c9a:	f0 1f 00 03 	mcall	80002ca4 <set_idle_store+0x1c>
}
80002c9e:	2f fd       	sub	sp,-4
80002ca0:	e3 cd 80 80 	ldm	sp++,r7,pc
80002ca4:	80 00       	ld.sh	r0,r0[0x0]
80002ca6:	62 50       	ld.w	r0,r1[0x14]

80002ca8 <phy_tx>:
Calls:   
	xQueueSend -- freertos
Called By: xnl_tx -- xnl.c
*/
void phy_tx(phy_fragment_t * phy)
{	
80002ca8:	d4 01       	pushm	lr
80002caa:	20 1d       	sub	sp,4
80002cac:	50 0c       	stdsp	sp[0x0],r12
	
	//phy_fragment_t * phy_ptr = malloc(sizeof(phy_fragment_t));
	//memcpy(phy_ptr, phy, sizeof(phy_fragment_t));
	//log("\n\r T_xcmp:%4x \n\r", phy->xnl_fragment.xnl_payload.xnl_content_data_msg.xcmp_opcode);
	//log("T_xnl-opcode:%4x", xnl->xnl_header.opcode);//log:R_xnl指令	
	if(XCMPXNL_DATA == (phy_ctrl & 0xF000))
80002cae:	98 88       	ld.uh	r8,r12[0x0]
80002cb0:	e2 18 f0 00 	andl	r8,0xf000,COH
80002cb4:	e0 48 40 00 	cp.w	r8,16384
80002cb8:	c0 d1       	brne	80002cd2 <phy_tx+0x2a>
	{
		/*push the xnl packet to queue to send */
		if(NULL != phy_xnl_frame_tx)
80002cba:	49 08       	lddpc	r8,80002cf8 <phy_tx+0x50>
80002cbc:	70 08       	ld.w	r8,r8[0x0]
80002cbe:	58 08       	cp.w	r8,0
80002cc0:	c1 a0       	breq	80002cf4 <phy_tx+0x4c>
		{
			if( pdTRUE == xQueueSend(phy_xnl_frame_tx, &phy, 0))
80002cc2:	48 e8       	lddpc	r8,80002cf8 <phy_tx+0x50>
80002cc4:	70 0c       	ld.w	r12,r8[0x0]
80002cc6:	30 09       	mov	r9,0
80002cc8:	12 9a       	mov	r10,r9
80002cca:	1a 9b       	mov	r11,sp
80002ccc:	f0 1f 00 0c 	mcall	80002cfc <phy_tx+0x54>
80002cd0:	c1 28       	rjmp	80002cf4 <phy_tx+0x4c>
		}
	}
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE		
	else if((SPEAKER_DATA == (phy_ctrl & 0xF000))
80002cd2:	e0 48 10 00 	cp.w	r8,4096
80002cd6:	5f 0a       	sreq	r10
80002cd8:	e0 48 20 00 	cp.w	r8,8192
80002cdc:	5f 09       	sreq	r9
80002cde:	f5 e9 10 09 	or	r9,r10,r9
80002ce2:	c0 71       	brne	80002cf0 <phy_tx+0x48>
80002ce4:	e0 48 50 00 	cp.w	r8,20480
80002ce8:	c0 40       	breq	80002cf0 <phy_tx+0x48>
80002cea:	e0 48 60 00 	cp.w	r8,24576
80002cee:	c0 31       	brne	80002cf4 <phy_tx+0x4c>
	    || (MIC_DATA  == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_RX == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_TX == (phy_ctrl & 0xF000))
	)
	{		
		if(NULL == phy_payload_frame_tx)
80002cf0:	48 48       	lddpc	r8,80002d00 <phy_tx+0x58>
80002cf2:	70 08       	ld.w	r8,r8[0x0]
	
	if(res != TRUE)
	{
		//vPortFree(phy_ptr);
	}
}
80002cf4:	2f fd       	sub	sp,-4
80002cf6:	d8 02       	popm	pc
80002cf8:	00 00       	add	r0,r0
80002cfa:	0a c8       	st.b	r5++,r8
80002cfc:	80 00       	ld.sh	r0,r0[0x0]
80002cfe:	62 50       	ld.w	r0,r1[0x14]
80002d00:	00 00       	add	r0,r0
80002d02:	0a b0       	st.h	r5++,r0

80002d04 <get_idle_store_isr>:
		return NULL;
	}
}

void * get_idle_store_isr(xQueueHandle store)
{
80002d04:	d4 01       	pushm	lr
80002d06:	20 2d       	sub	sp,8
	void * ptr = NULL;
80002d08:	30 08       	mov	r8,0
80002d0a:	50 18       	stdsp	sp[0x4],r8
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002d0c:	50 08       	stdsp	sp[0x0],r8
	
	if(pdTRUE == xQueueReceiveFromISR(store, &ptr, &xHigherPriorityTaskWoken))
80002d0e:	1a 9a       	mov	r10,sp
80002d10:	fa cb ff fc 	sub	r11,sp,-4
80002d14:	f0 1f 00 05 	mcall	80002d28 <get_idle_store_isr+0x24>
80002d18:	58 1c       	cp.w	r12,1
80002d1a:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80002d1e:	fb fc 00 01 	ld.weq	r12,sp[0x4]
	}
	else
	{
		return NULL;
	}
}
80002d22:	2f ed       	sub	sp,-8
80002d24:	d8 02       	popm	pc
80002d26:	00 00       	add	r0,r0
80002d28:	80 00       	ld.sh	r0,r0[0x0]
80002d2a:	5f 54       	srlt	r4

80002d2c <phy_tx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_tx_func( void * ssc)
{
80002d2c:	eb cd 40 c0 	pushm	r6-r7,lr
80002d30:	20 1d       	sub	sp,4
80002d32:	18 97       	mov	r7,r12
    if(NULL != phy_xnl_frame_tx)
80002d34:	4b a8       	lddpc	r8,80002e1c <phy_tx_func+0xf0>
80002d36:	70 08       	ld.w	r8,r8[0x0]
80002d38:	58 08       	cp.w	r8,0
80002d3a:	c6 60       	breq	80002e06 <phy_tx_func+0xda>
    {
  	  	/*send ssc data in xnl frame*/
  	  	phy_xnl_tx(&(((ssc_fragment_t * )ssc)->xnl_channel));		
80002d3c:	18 96       	mov	r6,r12
Called By:phy_tx_func
*/
static void phy_xnl_tx(xnl_channel_t * xnl_tx_channel)
{
	/*variables are used to store the push result in interrupt*/
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002d3e:	30 08       	mov	r8,0
80002d40:	50 08       	stdsp	sp[0x0],r8
	
	static S16 phy_tx_expexted_length = 0;
	static U8 phy_tx_index = 0;
	
	/*his is the code for handling any outgoing XNL Phy message*/
	switch(phy_tx_state)
80002d42:	4b 88       	lddpc	r8,80002e20 <phy_tx_func+0xf4>
80002d44:	70 08       	ld.w	r8,r8[0x0]
80002d46:	58 18       	cp.w	r8,1
80002d48:	c2 60       	breq	80002d94 <phy_tx_func+0x68>
80002d4a:	c0 43       	brcs	80002d52 <phy_tx_func+0x26>
80002d4c:	58 28       	cp.w	r8,2
80002d4e:	c5 c1       	brne	80002e06 <phy_tx_func+0xda>
80002d50:	c5 58       	rjmp	80002dfa <phy_tx_func+0xce>
	{
		/*Waiting for the send xnl packet*/
		case WAITING_FOR_PHY_TX:			
			if( pdTRUE == xQueueReceiveFromISR(
80002d52:	4b 38       	lddpc	r8,80002e1c <phy_tx_func+0xf0>
80002d54:	70 0c       	ld.w	r12,r8[0x0]
80002d56:	1a 9a       	mov	r10,sp
80002d58:	4b 3b       	lddpc	r11,80002e24 <phy_tx_func+0xf8>
80002d5a:	f0 1f 00 34 	mcall	80002e28 <phy_tx_func+0xfc>
80002d5e:	58 1c       	cp.w	r12,1
80002d60:	c1 41       	brne	80002d88 <phy_tx_func+0x5c>
				  phy_xnl_frame_tx
				, &phy_ptr
				, &xHigherPriorityTaskWoken 
			))
			{								
				phy_tx_expexted_length = 
80002d62:	4b 18       	lddpc	r8,80002e24 <phy_tx_func+0xf8>
80002d64:	70 08       	ld.w	r8,r8[0x0]
80002d66:	90 08       	ld.sh	r8,r8[0x0]
80002d68:	10 9a       	mov	r10,r8
80002d6a:	f5 da c0 08 	bfextu	r10,r10,0x0,0x8
80002d6e:	4b 09       	lddpc	r9,80002e2c <phy_tx_func+0x100>
80002d70:	b2 0a       	st.h	r9[0x0],r10
				*/
				xnl_tx_channel->dword = 
				                   phy_ptr->xnl_fragment.phy_header.phy_control;
				
				/*Transmit 0xABCD0000 | Type/Length.*/
				xnl_tx_channel->dword |= PHYHEADER32;
80002d72:	5c 78       	castu.h	r8
80002d74:	ea 18 ab cd 	orh	r8,0xabcd
80002d78:	8f 18       	st.w	r7[0x4],r8
				
				phy_tx_index = 1;
80002d7a:	30 19       	mov	r9,1
80002d7c:	4a d8       	lddpc	r8,80002e30 <phy_tx_func+0x104>
80002d7e:	b0 89       	st.b	r8[0x0],r9
				phy_tx_state = WRITE_NEXT_DWORD;	
80002d80:	30 19       	mov	r9,1
80002d82:	4a 88       	lddpc	r8,80002e20 <phy_tx_func+0xf4>
80002d84:	91 09       	st.w	r8[0x0],r9
80002d86:	c4 08       	rjmp	80002e06 <phy_tx_func+0xda>
				/*The new transmission has started.*/
			}
			else
			{
				/*Nothing new to transmit, send an idle frame*/
				xnl_tx_channel->dword = XNL_IDLE;
80002d88:	e0 68 5a 5a 	mov	r8,23130
80002d8c:	ea 18 ab cd 	orh	r8,0xabcd
80002d90:	8f 18       	st.w	r7[0x4],r8
80002d92:	c3 a8       	rjmp	80002e06 <phy_tx_func+0xda>
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80002d94:	4a 7a       	lddpc	r10,80002e30 <phy_tx_func+0x104>
80002d96:	15 88       	ld.ub	r8,r10[0x0]
				xnl_tx_channel->dword = XNL_IDLE;
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
80002d98:	4a 39       	lddpc	r9,80002e24 <phy_tx_func+0xf8>
80002d9a:	72 09       	ld.w	r9,r9[0x0]
80002d9c:	f2 08 05 19 	ld.uh	r9,r9[r8<<0x1]
80002da0:	b1 69       	lsl	r9,0x10
80002da2:	99 19       	st.w	r12[0x4],r9
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80002da4:	2f f8       	sub	r8,-1
80002da6:	5c 58       	castu.b	r8
80002da8:	b4 88       	st.b	r10[0x0],r8

			phy_tx_expexted_length -= 2;
80002daa:	4a 1b       	lddpc	r11,80002e2c <phy_tx_func+0x100>
80002dac:	96 0c       	ld.sh	r12,r11[0x0]
80002dae:	20 2c       	sub	r12,2
80002db0:	5c 8c       	casts.h	r12
80002db2:	f5 dc b0 10 	bfexts	r10,r12,0x0,0x10
80002db6:	b6 0a       	st.h	r11[0x0],r10
			
			/*have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80002db8:	30 0b       	mov	r11,0
80002dba:	f6 0a 19 00 	cp.h	r10,r11
80002dbe:	e0 89 00 09 	brgt	80002dd0 <phy_tx_func+0xa4>
			{
				/*Must immediately send 0x00BA in Slot 4.*/
				xnl_tx_channel->dword |= PHYTERMRIGHT;
80002dc2:	e8 19 00 ba 	orl	r9,0xba
80002dc6:	8f 19       	st.w	r7[0x4],r9
				
				/*Go back to waiting.*/
				phy_tx_state = WAITING_FOR_PHY_TX;
80002dc8:	30 09       	mov	r9,0
80002dca:	49 68       	lddpc	r8,80002e20 <phy_tx_func+0xf4>
80002dcc:	91 09       	st.w	r8[0x0],r9
80002dce:	c1 c8       	rjmp	80002e06 <phy_tx_func+0xda>
				break;
			}

			/*Have not broken. Transmit 2nd hWord.*/
			xnl_tx_channel->dword |=  phy_ptr->fragment_element[phy_tx_index++];
80002dd0:	49 5a       	lddpc	r10,80002e24 <phy_tx_func+0xf8>
80002dd2:	74 0a       	ld.w	r10,r10[0x0]
80002dd4:	f4 08 05 1a 	ld.uh	r10,r10[r8<<0x1]
80002dd8:	14 49       	or	r9,r10
80002dda:	8f 19       	st.w	r7[0x4],r9
80002ddc:	2f f8       	sub	r8,-1
80002dde:	49 59       	lddpc	r9,80002e30 <phy_tx_func+0x104>
80002de0:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
80002de2:	20 2c       	sub	r12,2
80002de4:	49 28       	lddpc	r8,80002e2c <phy_tx_func+0x100>
80002de6:	b0 0c       	st.h	r8[0x0],r12
			
			/*Have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80002de8:	30 08       	mov	r8,0
80002dea:	f0 0c 19 00 	cp.h	r12,r8
80002dee:	e0 89 00 0c 	brgt	80002e06 <phy_tx_func+0xda>
			{
				/*Must send 0x00BA0000 next interrupt in Slot 3&4*/
				phy_tx_state = SEND_TAILED;
80002df2:	30 29       	mov	r9,2
80002df4:	48 b8       	lddpc	r8,80002e20 <phy_tx_func+0xf4>
80002df6:	91 09       	st.w	r8[0x0],r9
80002df8:	c0 78       	rjmp	80002e06 <phy_tx_func+0xda>
			}
			break;

		case SEND_TAILED:
			/*send 0x00BA0000*/
			xnl_tx_channel->dword = PHYTERMLEFT;
80002dfa:	fc 18 00 ba 	movh	r8,0xba
80002dfe:	99 18       	st.w	r12[0x4],r8
			
			/*Go back to waiting.*/		
			phy_tx_state = WAITING_FOR_PHY_TX;		
80002e00:	30 09       	mov	r9,0
80002e02:	48 88       	lddpc	r8,80002e20 <phy_tx_func+0xf4>
80002e04:	91 09       	st.w	r8[0x0],r9
	//#else
	///*send idle frame*/	
	//((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
	//((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
	//#endif /*end if*/
	((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
80002e06:	e0 68 5a 5a 	mov	r8,23130
80002e0a:	ea 18 ab cd 	orh	r8,0xabcd
80002e0e:	8f 28       	st.w	r7[0x8],r8
	((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
80002e10:	30 08       	mov	r8,0
80002e12:	8f 38       	st.w	r7[0xc],r8
}
80002e14:	2f fd       	sub	sp,-4
80002e16:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002e1a:	00 00       	add	r0,r0
80002e1c:	00 00       	add	r0,r0
80002e1e:	0a c8       	st.b	r5++,r8
80002e20:	00 00       	add	r0,r0
80002e22:	0a 84       	andn	r4,r5
80002e24:	00 00       	add	r0,r0
80002e26:	0a d0       	st.w	--r5,r0
80002e28:	80 00       	ld.sh	r0,r0[0x0]
80002e2a:	5f 54       	srlt	r4
80002e2c:	00 00       	add	r0,r0
80002e2e:	0a ac       	st.w	r5++,r12
80002e30:	00 00       	add	r0,r0
80002e32:	0a 68       	and	r8,r5

80002e34 <get_idle_store>:
	}//End of RxMedia Phy Handler.
}
#endif /*end if*/

void * get_idle_store(xQueueHandle store)
{
80002e34:	d4 01       	pushm	lr
80002e36:	20 1d       	sub	sp,4
	void * ptr = NULL;
80002e38:	30 0a       	mov	r10,0
80002e3a:	fa cb ff fc 	sub	r11,sp,-4
80002e3e:	16 da       	st.w	--r11,r10

	if(pdTRUE == xQueueReceive(store, &ptr, 0))
80002e40:	14 99       	mov	r9,r10
80002e42:	1a 9b       	mov	r11,sp
80002e44:	f0 1f 00 05 	mcall	80002e58 <get_idle_store+0x24>
80002e48:	58 1c       	cp.w	r12,1
80002e4a:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80002e4e:	fb fc 00 00 	ld.weq	r12,sp[0x0]
	}
	else
	{
		return NULL;
	}
}
80002e52:	2f fd       	sub	sp,-4
80002e54:	d8 02       	popm	pc
80002e56:	00 00       	add	r0,r0
80002e58:	80 00       	ld.sh	r0,r0[0x0]
80002e5a:	60 44       	ld.w	r4,r0[0x10]

80002e5c <phy_init>:
    register_rx_tx_func -- ssc.c
	xQueueCreate -- freertos
Called By: xnl_init -- xnl.c
*/
void phy_init( void )
{
80002e5c:	d4 01       	pushm	lr
    /*register the func to send/receive ssc packet*/
    register_rx_tx_func(phy_rx_func, phy_tx_func);	
80002e5e:	48 5b       	lddpc	r11,80002e70 <phy_init+0x14>
80002e60:	48 5c       	lddpc	r12,80002e74 <phy_init+0x18>
80002e62:	f0 1f 00 06 	mcall	80002e78 <phy_init+0x1c>
	
	/*initialize the SSC*/
	ssc_init();
80002e66:	f0 1f 00 06 	mcall	80002e7c <phy_init+0x20>
	
	/*send device_master_query to connect radio*/
	xnl_send_device_master_query();
80002e6a:	f0 1f 00 06 	mcall	80002e80 <phy_init+0x24>
	
}
80002e6e:	d8 02       	popm	pc
80002e70:	80 00       	ld.sh	r0,r0[0x0]
80002e72:	2d 2c       	sub	r12,-46
80002e74:	80 00       	ld.sh	r0,r0[0x0]
80002e76:	2e e4       	sub	r4,-18
80002e78:	80 00       	ld.sh	r0,r0[0x0]
80002e7a:	3f 2c       	mov	r12,-14
80002e7c:	80 00       	ld.sh	r0,r0[0x0]
80002e7e:	3f 40       	mov	r0,-12
80002e80:	80 00       	ld.sh	r0,r0[0x0]
80002e82:	48 e8       	lddpc	r8,80002eb8 <payload_rx+0x34>

80002e84 <payload_rx>:
		//logFromISR("ss");
	}
}

static void payload_rx(void * payload)
{
80002e84:	d4 01       	pushm	lr
80002e86:	20 2d       	sub	sp,8
80002e88:	50 0c       	stdsp	sp[0x0],r12
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002e8a:	30 08       	mov	r8,0
80002e8c:	50 18       	stdsp	sp[0x4],r8
	
	if(NULL == phy_payload_frame_rx)
80002e8e:	48 f8       	lddpc	r8,80002ec8 <payload_rx+0x44>
80002e90:	70 08       	ld.w	r8,r8[0x0]
80002e92:	58 08       	cp.w	r8,0
80002e94:	c0 71       	brne	80002ea2 <payload_rx+0x1e>
	{
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));		
80002e96:	30 4b       	mov	r11,4
80002e98:	30 5c       	mov	r12,5
80002e9a:	f0 1f 00 0d 	mcall	80002ecc <payload_rx+0x48>
80002e9e:	48 b8       	lddpc	r8,80002ec8 <payload_rx+0x44>
80002ea0:	91 0c       	st.w	r8[0x0],r12
	}

	if(errQUEUE_FULL == xQueueSendFromISR(phy_payload_frame_rx, &payload, &xHigherPriorityTaskWoken))
80002ea2:	48 a8       	lddpc	r8,80002ec8 <payload_rx+0x44>
80002ea4:	70 0c       	ld.w	r12,r8[0x0]
80002ea6:	30 09       	mov	r9,0
80002ea8:	fa ca ff fc 	sub	r10,sp,-4
80002eac:	1a 9b       	mov	r11,sp
80002eae:	f0 1f 00 09 	mcall	80002ed0 <payload_rx+0x4c>
80002eb2:	c0 91       	brne	80002ec4 <payload_rx+0x40>
	{
		
		set_payload_idle_isr(payload);
80002eb4:	48 88       	lddpc	r8,80002ed4 <payload_rx+0x50>
80002eb6:	70 0c       	ld.w	r12,r8[0x0]
80002eb8:	40 0b       	lddsp	r11,sp[0x0]
80002eba:	f0 1f 00 08 	mcall	80002ed8 <payload_rx+0x54>
		logFromISR("mm");
80002ebe:	48 8c       	lddpc	r12,80002edc <payload_rx+0x58>
80002ec0:	f0 1f 00 08 	mcall	80002ee0 <payload_rx+0x5c>
	}
	else
	{
		//logFromISR("ss");
	}
}
80002ec4:	2f ed       	sub	sp,-8
80002ec6:	d8 02       	popm	pc
80002ec8:	00 00       	add	r0,r0
80002eca:	0a 90       	mov	r0,r5
80002ecc:	80 00       	ld.sh	r0,r0[0x0]
80002ece:	63 50       	ld.w	r0,r1[0x54]
80002ed0:	80 00       	ld.sh	r0,r0[0x0]
80002ed2:	62 00       	ld.w	r0,r1[0x0]
80002ed4:	00 00       	add	r0,r0
80002ed6:	0a 74       	tst	r4,r5
80002ed8:	80 00       	ld.sh	r0,r0[0x0]
80002eda:	2c 34       	sub	r4,-61
80002edc:	80 00       	ld.sh	r0,r0[0x0]
80002ede:	d5 14       	*unknown*
80002ee0:	80 00       	ld.sh	r0,r0[0x0]
80002ee2:	6f bc       	ld.w	r12,r7[0x6c]

80002ee4 <phy_rx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_rx_func( void * ssc)
{    
80002ee4:	eb cd 40 e0 	pushm	r5-r7,lr
80002ee8:	18 97       	mov	r7,r12
		
	if(NULL != phy_xnl_frame_rx)
80002eea:	fe f8 0e 7a 	ld.w	r8,pc[3706]
80002eee:	70 08       	ld.w	r8,r8[0x0]
80002ef0:	58 08       	cp.w	r8,0
80002ef2:	e0 80 01 08 	breq	80003102 <phy_rx_func+0x21e>
	static U16 phy_check_sum = 0;

	static phy_rx_state_t  phy_rx_state = WAITING_FOR_HEADER;
	static U32 phy_rx_count = 0;

	U32 phy_dword = xnl_rx_channel->dword;	
80002ef6:	78 16       	ld.w	r6,r12[0x4]

	phy_rx_count++;
80002ef8:	fe f8 0e 70 	ld.w	r8,pc[3696]
80002efc:	70 09       	ld.w	r9,r8[0x0]
80002efe:	2f f9       	sub	r9,-1
80002f00:	91 09       	st.w	r8[0x0],r9
	
	/*This is the code for parsing the incoming physical message.*/
	switch (phy_rx_state)
80002f02:	fe f8 0e 6a 	ld.w	r8,pc[3690]
80002f06:	70 08       	ld.w	r8,r8[0x0]
80002f08:	58 18       	cp.w	r8,1
80002f0a:	e0 80 00 85 	breq	80003014 <phy_rx_func+0x130>
80002f0e:	c0 73       	brcs	80002f1c <phy_rx_func+0x38>
80002f10:	58 28       	cp.w	r8,2
80002f12:	c5 c0       	breq	80002fca <phy_rx_func+0xe6>
80002f14:	58 38       	cp.w	r8,3
80002f16:	e0 81 00 f6 	brne	80003102 <phy_rx_func+0x21e>
80002f1a:	cd 58       	rjmp	800030c4 <phy_rx_func+0x1e0>

        /*Waiting for something. Most frequent visit.*/		
		case WAITING_FOR_HEADER:
		
			/*Ignore Idles.*/
			if (0xABCD5A5A == phy_dword)
80002f1c:	e0 6a 5a 5a 	mov	r10,23130
80002f20:	ea 1a ab cd 	orh	r10,0xabcd
80002f24:	14 36       	cp.w	r6,r10
80002f26:	e0 80 00 ee 	breq	80003102 <phy_rx_func+0x21e>
			{
				break;
			}	

			/*Skip until Header.*/		
			if (0xABCD != (phy_dword >> 16))
80002f2a:	ec 08 16 10 	lsr	r8,r6,0x10
80002f2e:	e0 48 ab cd 	cp.w	r8,43981
80002f32:	e0 81 00 e8 	brne	80003102 <phy_rx_func+0x21e>
			{			
				break;
			}
		
			/*Length excluding CSUM.*/
			phy_rx_expexted_length = (phy_dword & 0x000000FF) - 2;
80002f36:	eb d6 b0 10 	bfexts	r5,r6,0x0,0x10
80002f3a:	f1 d5 c0 08 	bfextu	r8,r5,0x0,0x8
80002f3e:	20 28       	sub	r8,2
80002f40:	fe f9 0e 30 	ld.w	r9,pc[3632]
80002f44:	b2 08       	st.h	r9[0x0],r8
			
			/*Discard degenerate message.*/
			if (phy_rx_expexted_length <= 0)
80002f46:	30 09       	mov	r9,0
80002f48:	f2 08 19 00 	cp.h	r8,r9
80002f4c:	e0 8a 00 db 	brle	80003102 <phy_rx_func+0x21e>
			{
				break;
			}
		
			phy_rx_length = 0;
80002f50:	fe f8 0e 24 	ld.w	r8,pc[3620]
80002f54:	b0 09       	st.h	r8[0x0],r9

			phy_frame_ptr = get_xnl_idle_isr();
80002f56:	fe f8 0e 22 	ld.w	r8,pc[3618]
80002f5a:	70 0c       	ld.w	r12,r8[0x0]
80002f5c:	f0 1f 03 88 	mcall	80003d7c <phy_rx_func+0xe98>
80002f60:	fe f8 0e 20 	ld.w	r8,pc[3616]
80002f64:	91 0c       	st.w	r8[0x0],r12
			if(NULL == phy_frame_ptr)
80002f66:	58 0c       	cp.w	r12,0
80002f68:	e0 80 00 cd 	breq	80003102 <phy_rx_func+0x21e>
			{
				break;
			}
					
			phy_frame_ptr->fragment_element[phy_rx_length++] = phy_dword;
80002f6c:	fe f8 0e 08 	ld.w	r8,pc[3592]
80002f70:	90 09       	ld.sh	r9,r8[0x0]
80002f72:	f8 09 0a 15 	st.h	r12[r9<<0x1],r5
80002f76:	2f f9       	sub	r9,-1
80002f78:	5c 89       	casts.h	r9
			
			/*time stamp*/
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
80002f7a:	fe fa 0e 06 	ld.w	r10,pc[3590]
80002f7e:	74 0a       	ld.w	r10,r10[0x0]
80002f80:	fe fb 0d e8 	ld.w	r11,pc[3560]
80002f84:	76 0b       	ld.w	r11,r11[0x0]
80002f86:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
80002f8a:	2f f9       	sub	r9,-1
80002f8c:	b0 09       	st.h	r8[0x0],r9
													(phy_rx_count) & 0x0000FFFF;
			
			/*This switch tests the fragment type, and adjusts receiver state
			accordingly.*/
			/*Check frag type*/
			switch (phy_dword & 0x00000F00)
80002f8e:	e2 16 0f 00 	andl	r6,0xf00,COH
80002f92:	e0 46 01 00 	cp.w	r6,256
80002f96:	c0 c0       	breq	80002fae <phy_rx_func+0xca>
80002f98:	e0 8b 00 05 	brhi	80002fa2 <phy_rx_func+0xbe>
80002f9c:	58 06       	cp.w	r6,0
80002f9e:	c0 80       	breq	80002fae <phy_rx_func+0xca>
80002fa0:	c0 c8       	rjmp	80002fb8 <phy_rx_func+0xd4>
80002fa2:	e0 46 02 00 	cp.w	r6,512
80002fa6:	c0 40       	breq	80002fae <phy_rx_func+0xca>
80002fa8:	e0 46 03 00 	cp.w	r6,768
80002fac:	c0 61       	brne	80002fb8 <phy_rx_func+0xd4>
			{
				case SINGLE_FRAGMENT:  //Only Fragment.
				case FIRST_FRAGMENT:   //First of Multi-fragment.
				case MIDDLE_FRAGMENT:  //Continuing Multi-fragment.
				case LAST_FRAGMENT:    //Last Multi-fragment.
					phy_rx_state = WAITING_CHECK_SUM;
80002fae:	30 29       	mov	r9,2
80002fb0:	fe f8 0d bc 	ld.w	r8,pc[3516]
80002fb4:	91 09       	st.w	r8[0x0],r9
80002fb6:	ca 68       	rjmp	80003102 <phy_rx_func+0x21e>
				break;
				default:
					set_xnl_idle_isr(phy_frame_ptr);			
80002fb8:	fe f8 0d c0 	ld.w	r8,pc[3520]
80002fbc:	70 0c       	ld.w	r12,r8[0x0]
80002fbe:	fe f8 0d c2 	ld.w	r8,pc[3522]
80002fc2:	70 0b       	ld.w	r11,r8[0x0]
80002fc4:	f0 1f 03 70 	mcall	80003d84 <phy_rx_func+0xea0>
80002fc8:	c9 d8       	rjmp	80003102 <phy_rx_func+0x21e>
		
			/*Stores CSUM*/
			phy_check_sum  = (phy_dword & 0xFFFF0000) >> 16;
			
			/*sums in first hWord*/
			phy_check_sum += (phy_dword & 0x0000FFFF);		
80002fca:	f5 d6 b0 10 	bfexts	r10,r6,0x0,0x10
80002fce:	b1 86       	lsr	r6,0x10
80002fd0:	14 06       	add	r6,r10
80002fd2:	fe f8 0d b6 	ld.w	r8,pc[3510]
80002fd6:	b0 06       	st.h	r8[0x0],r6
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
80002fd8:	fe f8 0d 9c 	ld.w	r8,pc[3484]
80002fdc:	90 09       	ld.sh	r9,r8[0x0]
80002fde:	fe fb 0d a2 	ld.w	r11,pc[3490]
80002fe2:	76 0b       	ld.w	r11,r11[0x0]
80002fe4:	f6 09 0a 1a 	st.h	r11[r9<<0x1],r10
80002fe8:	2f f9       	sub	r9,-1
80002fea:	b0 09       	st.h	r8[0x0],r9
														 phy_dword & 0x0000FFFF;
					
			phy_rx_expexted_length -= 2;
80002fec:	fe f9 0d 84 	ld.w	r9,pc[3460]
80002ff0:	92 08       	ld.sh	r8,r9[0x0]
80002ff2:	20 28       	sub	r8,2
80002ff4:	b2 08       	st.h	r9[0x0],r8
			
			/*Normal case for greater than one byte payloads.*/
			if (phy_rx_expexted_length > 0)
80002ff6:	30 09       	mov	r9,0
80002ff8:	f2 08 19 00 	cp.h	r8,r9
80002ffc:	e0 8a 00 07 	brle	8000300a <phy_rx_func+0x126>
			{					  
				phy_rx_state = READING_FRAGMENT;
80003000:	30 19       	mov	r9,1
80003002:	fe f8 0d 6a 	ld.w	r8,pc[3434]
80003006:	91 09       	st.w	r8[0x0],r9
80003008:	c7 d8       	rjmp	80003102 <phy_rx_func+0x21e>
	    		Note that all segments must align with a 32-bit boundary and
				beginning of each XCMP/XNL payload frame must start on slot 3
				Thus, segments of odd length must append a 0x0000 at the end
				(slot 4) to ensure alignment. [9.1.3]
				*/
				phy_rx_state = WAITING_LAST_TERM;
8000300a:	30 39       	mov	r9,3
8000300c:	fe f8 0d 60 	ld.w	r8,pc[3424]
80003010:	91 09       	st.w	r8[0x0],r9
80003012:	c7 88       	rjmp	80003102 <phy_rx_func+0x21e>
			}			
		
			break;

		case READING_FRAGMENT:
			phy_check_sum += (phy_dword & 0xFFFF0000) >> 16;
80003014:	ec 0a 14 10 	asr	r10,r6,0x10
80003018:	fe f8 0d 70 	ld.w	r8,pc[3440]
8000301c:	90 09       	ld.sh	r9,r8[0x0]
8000301e:	14 09       	add	r9,r10
80003020:	b0 09       	st.h	r8[0x0],r9
	
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
80003022:	fe f9 0d 52 	ld.w	r9,pc[3410]
80003026:	92 08       	ld.sh	r8,r9[0x0]
80003028:	fe fb 0d 58 	ld.w	r11,pc[3416]
8000302c:	76 0b       	ld.w	r11,r11[0x0]
8000302e:	f6 08 0a 1a 	st.h	r11[r8<<0x1],r10
80003032:	2f f8       	sub	r8,-1
80003034:	5c 88       	casts.h	r8
80003036:	b2 08       	st.h	r9[0x0],r8
												 (phy_dword & 0xFFFF0000) >> 16;
	
			phy_rx_expexted_length -= 2;
80003038:	fe fa 0d 38 	ld.w	r10,pc[3384]
8000303c:	94 09       	ld.sh	r9,r10[0x0]
8000303e:	20 29       	sub	r9,2
80003040:	b4 09       	st.h	r10[0x0],r9
			if (phy_rx_expexted_length <= 0)
80003042:	30 0a       	mov	r10,0
80003044:	f4 09 19 00 	cp.h	r9,r10
80003048:	e0 89 00 20 	brgt	80003088 <phy_rx_func+0x1a4>
				Terminator should be in 2nd hWord.
				Shaoqun says useful bits not used. The packet will always end
				with $00BA. [9.1.2.8]	
				*/
				
				if ((0x000000BA == (phy_dword  & 0x0000FFFF)) 
8000304c:	ed d6 c0 10 	bfextu	r6,r6,0x0,0x10
80003050:	e0 46 00 ba 	cp.w	r6,186
80003054:	c0 d1       	brne	8000306e <phy_rx_func+0x18a>
80003056:	fe f8 0d 32 	ld.w	r8,pc[3378]
8000305a:	90 09       	ld.sh	r9,r8[0x0]
8000305c:	f4 09 19 00 	cp.h	r9,r10
80003060:	c0 71       	brne	8000306e <phy_rx_func+0x18a>
					&& (phy_check_sum == 0))
				{
					phy_rx(phy_frame_ptr);
80003062:	fe f8 0d 1e 	ld.w	r8,pc[3358]
80003066:	70 0c       	ld.w	r12,r8[0x0]
80003068:	f0 1f 03 49 	mcall	80003d8c <phy_rx_func+0xea8>
8000306c:	c0 98       	rjmp	8000307e <phy_rx_func+0x19a>
				}
				else
				{
					set_xnl_idle_isr(phy_frame_ptr);
8000306e:	fe f8 0d 0a 	ld.w	r8,pc[3338]
80003072:	70 0c       	ld.w	r12,r8[0x0]
80003074:	fe f8 0d 0c 	ld.w	r8,pc[3340]
80003078:	70 0b       	ld.w	r11,r8[0x0]
8000307a:	f0 1f 03 43 	mcall	80003d84 <phy_rx_func+0xea0>
				}

				phy_rx_state = WAITING_FOR_HEADER;
8000307e:	30 09       	mov	r9,0
80003080:	fe f8 0c ec 	ld.w	r8,pc[3308]
80003084:	91 09       	st.w	r8[0x0],r9
80003086:	c3 e8       	rjmp	80003102 <phy_rx_func+0x21e>
				break;
			}
		
			/*Have not broken. 2nd hWord contains payload.*/
			phy_check_sum += (phy_dword & 0x0000FFFF);
80003088:	5c 86       	casts.h	r6
8000308a:	fe f9 0c fe 	ld.w	r9,pc[3326]
8000308e:	92 0a       	ld.sh	r10,r9[0x0]
80003090:	0c 0a       	add	r10,r6
80003092:	b2 0a       	st.h	r9[0x0],r10
		
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
80003094:	fe f9 0c ec 	ld.w	r9,pc[3308]
80003098:	72 09       	ld.w	r9,r9[0x0]
8000309a:	f2 08 0a 16 	st.h	r9[r8<<0x1],r6
8000309e:	2f f8       	sub	r8,-1
800030a0:	fe f9 0c d4 	ld.w	r9,pc[3284]
800030a4:	b2 08       	st.h	r9[0x0],r8
													   (phy_dword & 0x0000FFFF);
		
			phy_rx_expexted_length -= 2;
800030a6:	fe f9 0c ca 	ld.w	r9,pc[3274]
800030aa:	92 08       	ld.sh	r8,r9[0x0]
800030ac:	20 28       	sub	r8,2
800030ae:	b2 08       	st.h	r9[0x0],r8
			if (phy_rx_expexted_length <= 0)
800030b0:	30 09       	mov	r9,0
800030b2:	f2 08 19 00 	cp.h	r8,r9
800030b6:	e0 89 00 26 	brgt	80003102 <phy_rx_func+0x21e>
			{
				/*All read in. Next Word should be 0x00BA0000.*/
				phy_rx_state = WAITING_LAST_TERM;
800030ba:	30 39       	mov	r9,3
800030bc:	fe f8 0c b0 	ld.w	r8,pc[3248]
800030c0:	91 09       	st.w	r8[0x0],r9
800030c2:	c2 08       	rjmp	80003102 <phy_rx_func+0x21e>
			}/*else, next Word contains more payload.*/
			break;

		/*Expecting last terminator 0x00BA0000.*/	
		case WAITING_LAST_TERM:			
			if ((0x00BA0000 == (phy_dword  & 0x00FF0000)) /*Expected found.*/
800030c4:	e6 16 00 ff 	andh	r6,0xff,COH
800030c8:	fc 19 00 ba 	movh	r9,0xba
800030cc:	12 36       	cp.w	r6,r9
800030ce:	c0 e1       	brne	800030ea <phy_rx_func+0x206>
800030d0:	fe f8 0c b8 	ld.w	r8,pc[3256]
800030d4:	90 09       	ld.sh	r9,r8[0x0]
800030d6:	30 08       	mov	r8,0
800030d8:	f0 09 19 00 	cp.h	r9,r8
800030dc:	c0 71       	brne	800030ea <phy_rx_func+0x206>
				&& (phy_check_sum == 0))/*Good checksum*/
			{
				phy_rx(phy_frame_ptr);
800030de:	fe f8 0c a2 	ld.w	r8,pc[3234]
800030e2:	70 0c       	ld.w	r12,r8[0x0]
800030e4:	f0 1f 03 2a 	mcall	80003d8c <phy_rx_func+0xea8>
800030e8:	c0 98       	rjmp	800030fa <phy_rx_func+0x216>

			}
			else
			{
				set_xnl_idle_isr(phy_frame_ptr);
800030ea:	fe f8 0c 8e 	ld.w	r8,pc[3214]
800030ee:	70 0c       	ld.w	r12,r8[0x0]
800030f0:	fe f8 0c 90 	ld.w	r8,pc[3216]
800030f4:	70 0b       	ld.w	r11,r8[0x0]
800030f6:	f0 1f 03 24 	mcall	80003d84 <phy_rx_func+0xea0>
			}
				
			phy_rx_state = WAITING_FOR_HEADER;
800030fa:	30 09       	mov	r9,0
800030fc:	fe f8 0c 70 	ld.w	r8,pc[3184]
80003100:	91 09       	st.w	r8[0x0],r9
	static U8 _flag = 1;//0xABCDC014时，_flag为0；
						//0xABCDC010时，_flag为1；
			
	//payload_ptr_t *AMBE_payload_ptr;		
	
	if(is_first == FALSE)
80003102:	fe f8 0c 8e 	ld.w	r8,pc[3214]
80003106:	11 89       	ld.ub	r9,r8[0x0]
80003108:	30 08       	mov	r8,0
8000310a:	f0 09 18 00 	cp.b	r9,r8
8000310e:	c1 31       	brne	80003134 <phy_rx_func+0x250>
	{
		payload_ptr = get_payload_idle_isr();
80003110:	fe f6 0c 84 	ld.w	r6,pc[3204]
80003114:	6c 0c       	ld.w	r12,r6[0x0]
80003116:	f0 1f 03 1a 	mcall	80003d7c <phy_rx_func+0xe98>
8000311a:	fe f8 0c 7e 	ld.w	r8,pc[3198]
8000311e:	91 0c       	st.w	r8[0x0],r12
		AMBE_payload_ptr = get_payload_idle_isr();
80003120:	6c 0c       	ld.w	r12,r6[0x0]
80003122:	f0 1f 03 17 	mcall	80003d7c <phy_rx_func+0xe98>
80003126:	fe f8 0c 76 	ld.w	r8,pc[3190]
8000312a:	91 0c       	st.w	r8[0x0],r12
		is_first = TRUE;
8000312c:	30 19       	mov	r9,1
8000312e:	fe f8 0c 62 	ld.w	r8,pc[3170]
80003132:	b0 89       	st.b	r8[0x0],r9
	}	
	
	//This is the RxMedia Phy Handler.
	switch (RxMediaState)
80003134:	fe f8 0c 6c 	ld.w	r8,pc[3180]
80003138:	70 08       	ld.w	r8,r8[0x0]
8000313a:	58 28       	cp.w	r8,2
8000313c:	e0 80 01 98 	breq	8000346c <phy_rx_func+0x588>
80003140:	e0 8b 00 06 	brhi	8000314c <phy_rx_func+0x268>
80003144:	58 08       	cp.w	r8,0
80003146:	c0 b0       	breq	8000315c <phy_rx_func+0x278>
80003148:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000314c:	58 38       	cp.w	r8,3
8000314e:	e0 80 05 c5 	breq	80003cd8 <phy_rx_func+0xdf4>
80003152:	58 48       	cp.w	r8,4
80003154:	e0 81 06 05 	brne	80003d5e <phy_rx_func+0xe7a>
80003158:	e0 8f 02 4b 	bral	800035ee <phy_rx_func+0x70a>
	{
		case WAITINGABAB:

			
			if (payload_rx_channel->dword[0] == 0xABCD5A5A)//Ignore Idles.
8000315c:	6e 28       	ld.w	r8,r7[0x8]
8000315e:	e0 6a 5a 5a 	mov	r10,23130
80003162:	ea 1a ab cd 	orh	r10,0xabcd
80003166:	14 38       	cp.w	r8,r10
80003168:	c0 71       	brne	80003176 <phy_rx_func+0x292>
			{
				m_RxBurstType = VOICE_WATING;
8000316a:	30 09       	mov	r9,0
8000316c:	fe f8 0c 38 	ld.w	r8,pc[3128]
80003170:	91 09       	st.w	r8[0x0],r9
80003172:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
				//Upon receiving the idle frame, the m Rx Burst Type into an idle state in order to transmit the synchronization wait
				 break; 
			}
            
			if ((payload_rx_channel->dword[0]  & 0xFFFF0000) != 0xABCD0000)break; //Skip until Header. 
80003176:	10 99       	mov	r9,r8
80003178:	e0 19 00 00 	andl	r9,0x0
8000317c:	fc 1a ab cd 	movh	r10,0xabcd
80003180:	14 39       	cp.w	r9,r10
80003182:	e0 81 05 ee 	brne	80003d5e <phy_rx_func+0xe7a>
			}
			//logFromISR("\n\r P: %X \n\r", payload_rx_channel->word[1]);//测试收到的数据
			
#endif
			
			RxBytesWaiting = payload_rx_channel->dword[0] & 0x000000FF;
80003186:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
8000318a:	fe f9 0c 1e 	ld.w	r9,pc[3102]
8000318e:	93 08       	st.w	r9[0x0],r8
			/****Note AMBE stream protocol frame structure and the PCM frame structure is different*****/
					
			if ((payload_rx_channel->dword[0] & 0x0000F000 ) == PAYLOAD_DATA_ENH )//PAYLOAD_DATA_ENH (0x0c))
80003190:	6e 29       	ld.w	r9,r7[0x8]
80003192:	e2 19 f0 00 	andl	r9,0xf000,COH
80003196:	e0 49 c0 00 	cp.w	r9,49152
8000319a:	e0 81 00 ce 	brne	80003336 <phy_rx_func+0x452>
			{
				AMBE_Media = 1;	
8000319e:	30 1a       	mov	r10,1
800031a0:	fe f9 0c 0c 	ld.w	r9,pc[3084]
800031a4:	b2 8a       	st.b	r9[0x0],r10
				
				if (NULL== AMBE_payload_ptr){
800031a6:	fe f9 0b f6 	ld.w	r9,pc[3062]
800031aa:	72 09       	ld.w	r9,r9[0x0]
800031ac:	58 09       	cp.w	r9,0
800031ae:	c0 71       	brne	800031bc <phy_rx_func+0x2d8>
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//测试是否有这种情况出现
800031b0:	fe fc 0c 00 	ld.w	r12,pc[3072]
800031b4:	f0 1f 03 00 	mcall	80003db4 <phy_rx_func+0xed0>
800031b8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
																	
				Item_ID = payload_rx_channel->byte[5];
800031bc:	ef 3a 00 0d 	ld.ub	r10,r7[13]
800031c0:	fe f9 0b f8 	ld.w	r9,pc[3064]
800031c4:	b2 8a       	st.b	r9[0x0],r10
				
				Item_Length = (payload_rx_channel->byte[4] & 0x7F);//7bits
800031c6:	ef 3b 00 0c 	ld.ub	r11,r7[12]
800031ca:	f7 db c0 07 	bfextu	r11,r11,0x0,0x7
800031ce:	fe fa 0b ee 	ld.w	r10,pc[3054]
800031d2:	95 0b       	st.w	r10[0x0],r11
								
				switch(Item_ID)
800031d4:	13 89       	ld.ub	r9,r9[0x0]
800031d6:	37 fa       	mov	r10,127
800031d8:	f4 09 18 00 	cp.b	r9,r10
800031dc:	c6 d0       	breq	800032b6 <phy_rx_func+0x3d2>
800031de:	e0 8b 00 0c 	brhi	800031f6 <phy_rx_func+0x312>
800031e2:	31 2a       	mov	r10,18
800031e4:	f4 09 18 00 	cp.b	r9,r10
800031e8:	c4 20       	breq	8000326c <phy_rx_func+0x388>
800031ea:	31 3a       	mov	r10,19
800031ec:	f4 09 18 00 	cp.b	r9,r10
800031f0:	e0 81 00 83 	brne	800032f6 <phy_rx_func+0x412>
800031f4:	c5 b8       	rjmp	800032aa <phy_rx_func+0x3c6>
800031f6:	2f 09       	sub	r9,-16
800031f8:	30 1a       	mov	r10,1
800031fa:	f4 09 18 00 	cp.b	r9,r10
800031fe:	e0 8b 00 7c 	brhi	800032f6 <phy_rx_func+0x412>
					//The OB know the Call begin and discard the Voice Header
					//The OB know the Call end and discard the Voice  Terminator
					case Raw_Tx_Data_HT://0xF0
					case Raw_Rx_Data_HT://0xF1
					
							if ((payload_rx_channel->byte[6] & 0xF0 )== 0x10)//header
80003202:	ef 38 00 0e 	ld.ub	r8,r7[14]
80003206:	e2 18 00 f0 	andl	r8,0xf0,COH
8000320a:	59 08       	cp.w	r8,16
8000320c:	c0 71       	brne	8000321a <phy_rx_func+0x336>
							{
								m_RxBurstType = VOICEHEADER;
8000320e:	30 19       	mov	r9,1
80003210:	fe f8 0b 94 	ld.w	r8,pc[2964]
80003214:	91 09       	st.w	r8[0x0],r9
80003216:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

							}
							else if ((payload_rx_channel->byte[6] & 0xF0) == 0x20)//Terminator
8000321a:	e0 48 00 20 	cp.w	r8,32
8000321e:	c2 11       	brne	80003260 <phy_rx_func+0x37c>
							{
								m_RxBurstType = VOICETERMINATOR;
80003220:	30 a9       	mov	r9,10
80003222:	fe f8 0b 82 	ld.w	r8,pc[2946]
80003226:	91 09       	st.w	r8[0x0],r9
								//AMBE-data and PCM-data is not the same. AMBE is compressed data,
								//if there was a missing portion, a clear voice is difficult to extract the data.
								//It must ensure that all the data received AMBE.
								
								//注意！！！考虑是否需要把剩余的空间置0。
								memset((AMBE_payload_ptr+ (RxAMBE_IsFillingNext8 +1)), 0x00, (512-(RxAMBE_IsFillingNext8 + 1)));
80003228:	fe f6 0b 98 	ld.w	r6,pc[2968]
8000322c:	6c 08       	ld.w	r8,r6[0x0]
8000322e:	f0 0a 11 ff 	rsub	r10,r8,-1
80003232:	fe f7 0b 6a 	ld.w	r7,pc[2922]
80003236:	2f f8       	sub	r8,-1
80003238:	6e 0c       	ld.w	r12,r7[0x0]
8000323a:	f4 ca fe 00 	sub	r10,r10,-512
8000323e:	30 0b       	mov	r11,0
80003240:	10 0c       	add	r12,r8
80003242:	f0 1f 02 e1 	mcall	80003dc4 <phy_rx_func+0xee0>
								
								RxAMBE_IsFillingNext8 = 0;
80003246:	30 08       	mov	r8,0
80003248:	8d 08       	st.w	r6[0x0],r8
								payload_rx(AMBE_payload_ptr);
8000324a:	6e 0c       	ld.w	r12,r7[0x0]
8000324c:	f0 1f 02 df 	mcall	80003dc8 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003250:	fe f8 0b 44 	ld.w	r8,pc[2884]
80003254:	70 0c       	ld.w	r12,r8[0x0]
80003256:	f0 1f 02 ca 	mcall	80003d7c <phy_rx_func+0xe98>
8000325a:	8f 0c       	st.w	r7[0x0],r12
8000325c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								//logFromISR("\n\r QQ1 \n\r");
								
							}
							else//error voice
							{
								m_RxBurstType = VOICE_WATING;
80003260:	30 09       	mov	r9,0
80003262:	fe f8 0b 42 	ld.w	r8,pc[2882]
80003266:	91 09       	st.w	r8[0x0],r9
80003268:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;//WAITINGABAB.
					
		
					case Vocoder_Bit_Stream_Parameter://0x12
							
							if ((RxBytesWaiting -= 4) <= 0) break;
8000326c:	20 48       	sub	r8,4
8000326e:	fe f9 0b 3a 	ld.w	r9,pc[2874]
80003272:	93 08       	st.w	r9[0x0],r8
80003274:	58 08       	cp.w	r8,0
80003276:	e0 80 05 74 	breq	80003d5e <phy_rx_func+0xe7a>
					
							//Vocoder Bits Stream Parameter
							VF_SN = (payload_rx_channel->byte[7] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
8000327a:	ef 3c 00 0f 	ld.ub	r12,r7[15]
8000327e:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
80003282:	fe f8 0b 4a 	ld.w	r8,pc[2890]
80003286:	b0 8c       	st.b	r8[0x0],r12
							
							VBSP_data[0] = payload_rx_channel->word[2];
80003288:	8e 69       	ld.sh	r9,r7[0xc]
8000328a:	fe f8 0b 46 	ld.w	r8,pc[2886]
8000328e:	b0 09       	st.h	r8[0x0],r9
							VBSP_data[1] = payload_rx_channel->word[3];
80003290:	8e 79       	ld.sh	r9,r7[0xe]
80003292:	b0 19       	st.h	r8[0x2],r9
							
							m_RxBurstType = CalculateBurst(VF_SN);
80003294:	f0 1f 02 d0 	mcall	80003dd4 <phy_rx_func+0xef0>
80003298:	fe f8 0b 0c 	ld.w	r8,pc[2828]
8000329c:	91 0c       	st.w	r8[0x0],r12
							
							RxMediaState = READING_AMBE_MEDIA;//Jump
8000329e:	30 49       	mov	r9,4
800032a0:	fe f8 0b 00 	ld.w	r8,pc[2816]
800032a4:	91 09       	st.w	r8[0x0],r9
800032a6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							
					//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
					// or discard it to reduce payload size.	
					//This shouldn't happen, but must check.	
					case Soft_Decision_Value://0x13
						m_RxBurstType = VOICE_WATING;
800032aa:	30 09       	mov	r9,0
800032ac:	fe f8 0a f8 	ld.w	r8,pc[2808]
800032b0:	91 09       	st.w	r8[0x0],r9
800032b2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
					case Radio_Internal_Parameter://0x7F
							
							//logFromISR("\n\r Item_Length:%d\n\r", Item_Length);
							
							if ((RxBytesWaiting -= 4) <= 0) break;
800032b6:	20 48       	sub	r8,4
800032b8:	fe f9 0a f0 	ld.w	r9,pc[2800]
800032bc:	93 08       	st.w	r9[0x0],r8
800032be:	58 08       	cp.w	r8,0
800032c0:	e0 80 05 4f 	breq	80003d5e <phy_rx_func+0xe7a>
							//Radio Internal Parameter
							Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[3];
800032c4:	fe f8 0b 14 	ld.w	r8,pc[2836]
800032c8:	70 09       	ld.w	r9,r8[0x0]
800032ca:	8e 7b       	ld.sh	r11,r7[0xe]
800032cc:	fe fa 0b 10 	ld.w	r10,pc[2832]
800032d0:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
							RxData_IsFillingNext16 += 1; 
800032d4:	2f f9       	sub	r9,-1
800032d6:	91 09       	st.w	r8[0x0],r9
							Item_Length -= 2 ;
800032d8:	fe f8 0a e4 	ld.w	r8,pc[2788]
800032dc:	70 09       	ld.w	r9,r8[0x0]
800032de:	20 29       	sub	r9,2
800032e0:	91 09       	st.w	r8[0x0],r9
							//....................................................
							m_RxBurstType = RADIOINTERNAL;
800032e2:	30 29       	mov	r9,2
800032e4:	fe f8 0a c0 	ld.w	r8,pc[2752]
800032e8:	91 09       	st.w	r8[0x0],r9

							RxMediaState = READING_AMBE_AUX;//Jump
800032ea:	30 39       	mov	r9,3
800032ec:	fe f8 0a b4 	ld.w	r8,pc[2740]
800032f0:	91 09       	st.w	r8[0x0],r9
800032f2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									
					default://0x03,0x04
						
						//((Item_ID == 0x04) || (Item_ID == 0x03) )//Unknown type data directly back hair
							//break;
							m_RxBurstType = UNSUREDATA;
800032f6:	30 3a       	mov	r10,3
800032f8:	fe f9 0a ac 	ld.w	r9,pc[2732]
800032fc:	93 0a       	st.w	r9[0x0],r10
							AMBE_HT[0] = payload_rx_channel->dword[0];
800032fe:	6e 2a       	ld.w	r10,r7[0x8]
80003300:	fe f9 0a e0 	ld.w	r9,pc[2784]
80003304:	93 0a       	st.w	r9[0x0],r10
							AMBE_HT[1] = payload_rx_channel->dword[1];
80003306:	6e 3a       	ld.w	r10,r7[0xc]
80003308:	93 1a       	st.w	r9[0x4],r10
							
							if (RxBytesWaiting == 0x00000014)
8000330a:	59 48       	cp.w	r8,20
8000330c:	c0 61       	brne	80003318 <phy_rx_func+0x434>
							{
								RxBytesWaiting = 0x18;//24 Reassigned
8000330e:	31 89       	mov	r9,24
80003310:	fe f8 0a 98 	ld.w	r8,pc[2712]
80003314:	91 09       	st.w	r8[0x0],r9
80003316:	c0 a8       	rjmp	8000332a <phy_rx_func+0x446>
								//_flag =0;
								
							}
							if (RxBytesWaiting == 0x00000010)
80003318:	fe f8 0a 90 	ld.w	r8,pc[2704]
8000331c:	70 08       	ld.w	r8,r8[0x0]
8000331e:	59 08       	cp.w	r8,16
80003320:	c0 51       	brne	8000332a <phy_rx_func+0x446>
							{
								RxBytesWaiting = 0x10;//16 Reassigned
80003322:	31 09       	mov	r9,16
80003324:	fe f8 0a 84 	ld.w	r8,pc[2692]
80003328:	91 09       	st.w	r8[0x0],r9
								//_flag =1;
							}
					
							RxMediaState = READING_AMBE_MEDIA;//Jump
8000332a:	30 49       	mov	r9,4
8000332c:	fe f8 0a 74 	ld.w	r8,pc[2676]
80003330:	91 09       	st.w	r8[0x0],r9
80003332:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
//#if 0
			else//PCM-media-data
			{	
				//logFromISR("\n\r RX:%x \n\r", payload_rx_channel->dword[0]);
				//SPEAKER_DATA or  //MIC_DATA
				if (((payload_rx_channel->dword[0] & 0x0000F000 ) != SPEAKER_DATA ) 
80003336:	e0 49 10 00 	cp.w	r9,4096
8000333a:	5f 1a       	srne	r10
8000333c:	e0 49 20 00 	cp.w	r9,8192
80003340:	5f 19       	srne	r9
80003342:	f5 e9 00 09 	and	r9,r10,r9
80003346:	e0 81 05 0c 	brne	80003d5e <phy_rx_func+0xe7a>
					&& ((payload_rx_channel->dword[0] & 0x0000F000 ) != MIC_DATA ))break;
				
				AMBE_tx_flag = 0;
8000334a:	fe fa 0a 9a 	ld.w	r10,pc[2714]
8000334e:	b4 89       	st.b	r10[0x0],r9
				AMBE_rx_flag = 0;
80003350:	fe fa 0a 98 	ld.w	r10,pc[2712]
80003354:	b4 89       	st.b	r10[0x0],r9
				
				Item_ID = 0;//To make sure your save PCM data.
80003356:	fe fa 0a 62 	ld.w	r10,pc[2658]
8000335a:	b4 89       	st.b	r10[0x0],r9
			
				if (NULL== payload_ptr){
8000335c:	fe f9 0a 3c 	ld.w	r9,pc[2620]
80003360:	72 09       	ld.w	r9,r9[0x0]
80003362:	58 09       	cp.w	r9,0
80003364:	c0 71       	brne	80003372 <phy_rx_func+0x48e>
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//测试是否有这种情况出现
80003366:	fe fc 0a 4a 	ld.w	r12,pc[2634]
8000336a:	f0 1f 02 93 	mcall	80003db4 <phy_rx_func+0xed0>
8000336e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003372:	6e 2a       	ld.w	r10,r7[0x8]
80003374:	e2 1a 0f 00 	andl	r10,0xf00,COH
80003378:	58 1a       	cp.w	r10,1
8000337a:	e0 8b 00 4d 	brhi	80003414 <phy_rx_func+0x530>
				
				if ((payload_rx_channel->dword[0]  & 0x00000F00) <= 1){  //Flag type must process Array Descriptor.
				//The first word of the media access payload must be the Array descriptor length. And the
				//unit of the length is in word (16-bit). The length field itself does not count into the length.
				//When there is no array descriptor, the length must be set to zero.[9.1.4.1]
					if ((RxBytesWaiting -= 4) <= 0) break;          //Nothing beyond this Phy buffer. Keep looking for Header
8000337e:	20 48       	sub	r8,4
80003380:	fe f9 0a 28 	ld.w	r9,pc[2600]
80003384:	93 08       	st.w	r9[0x0],r8
80003386:	58 08       	cp.w	r8,0
80003388:	e0 80 04 eb 	breq	80003d5e <phy_rx_func+0xe7a>
					ArrayDiscLength = payload_rx_channel->word[2];
8000338c:	8e 68       	ld.sh	r8,r7[0xc]
8000338e:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
80003392:	fe f9 0a 5a 	ld.w	r9,pc[2650]
80003396:	93 0a       	st.w	r9[0x0],r10
					switch (ArrayDiscLength){
80003398:	30 09       	mov	r9,0
8000339a:	f2 08 19 00 	cp.h	r8,r9
8000339e:	c0 70       	breq	800033ac <phy_rx_func+0x4c8>
800033a0:	30 19       	mov	r9,1
800033a2:	f2 08 19 00 	cp.h	r8,r9
800033a6:	e0 81 04 dc 	brne	80003d5e <phy_rx_func+0xe7a>
800033aa:	c2 68       	rjmp	800033f6 <phy_rx_func+0x512>
						case 0:          //The usual case. Remaining word in Phy buffer is Audio.
								
							payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
800033ac:	fe f8 0a 44 	ld.w	r8,pc[2628]
800033b0:	70 0a       	ld.w	r10,r8[0x0]
800033b2:	fe f9 09 e6 	ld.w	r9,pc[2534]
800033b6:	72 09       	ld.w	r9,r9[0x0]
800033b8:	8e 7b       	ld.sh	r11,r7[0xe]
800033ba:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
							RxMedia_IsFillingNext16 += 1;
800033be:	70 09       	ld.w	r9,r8[0x0]
800033c0:	2f f9       	sub	r9,-1
800033c2:	91 09       	st.w	r8[0x0],r9
							if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800033c4:	e0 49 00 ff 	cp.w	r9,255
800033c8:	e0 88 00 11 	brls	800033ea <phy_rx_func+0x506>
							{
								RxMedia_IsFillingNext16 = 0;	
800033cc:	30 09       	mov	r9,0
800033ce:	91 09       	st.w	r8[0x0],r9
								payload_rx(payload_ptr);	
800033d0:	fe f7 09 c8 	ld.w	r7,pc[2504]
800033d4:	6e 0c       	ld.w	r12,r7[0x0]
800033d6:	f0 1f 02 7d 	mcall	80003dc8 <phy_rx_func+0xee4>
								payload_ptr = get_payload_idle_isr();
800033da:	fe f8 09 ba 	ld.w	r8,pc[2490]
800033de:	70 0c       	ld.w	r12,r8[0x0]
800033e0:	f0 1f 02 67 	mcall	80003d7c <phy_rx_func+0xe98>
800033e4:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == payload_ptr){
800033e6:	e0 80 04 bc 	breq	80003d5e <phy_rx_func+0xe7a>
									break;
								}				
							}
							RxMediaState = READINGMEDIA;
800033ea:	30 29       	mov	r9,2
800033ec:	fe f8 09 b4 	ld.w	r8,pc[2484]
800033f0:	91 09       	st.w	r8[0x0],r9
800033f2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
800033f6:	8e 79       	ld.sh	r9,r7[0xe]
800033f8:	30 38       	mov	r8,3
800033fa:	f0 09 19 00 	cp.h	r9,r8
800033fe:	c0 51       	brne	80003408 <phy_rx_func+0x524>
				
						case 1: //The next usual case.
								//In general case, add code to process single word Array descriptor.
								if (payload_rx_channel->word[3] == 0x0003)//Stream Terminator
								{
									Terminator_Flag = 1;
80003400:	30 19       	mov	r9,1
80003402:	fe f8 09 f2 	ld.w	r8,pc[2546]
80003406:	b0 89       	st.b	r8[0x0],r9
								else
								{
									//Terminator_Flag = 0;
								}
								
								RxMediaState = READINGMEDIA;
80003408:	30 29       	mov	r9,2
8000340a:	fe f8 09 96 	ld.w	r8,pc[2454]
8000340e:	91 09       	st.w	r8[0x0],r9
80003410:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
				break;
			}
		
				//Code gets here on Middle or last Fragment. No Array descriptor.
				if (RxBytesWaiting < 2) break;//This shouldn't happen, but must check.
80003414:	58 18       	cp.w	r8,1
80003416:	e0 88 04 a4 	brls	80003d5e <phy_rx_func+0xe7a>
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->dword[1] & 0x0000FFFF;
8000341a:	fe f8 09 d6 	ld.w	r8,pc[2518]
8000341e:	70 0a       	ld.w	r10,r8[0x0]
80003420:	6e 3b       	ld.w	r11,r7[0xc]
80003422:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80003426:	70 09       	ld.w	r9,r8[0x0]
80003428:	2f f9       	sub	r9,-1
8000342a:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
8000342c:	e0 49 00 ff 	cp.w	r9,255
80003430:	e0 88 00 11 	brls	80003452 <phy_rx_func+0x56e>
				{
					RxMedia_IsFillingNext16 = 0;
80003434:	30 09       	mov	r9,0
80003436:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003438:	fe f7 09 60 	ld.w	r7,pc[2400]
8000343c:	6e 0c       	ld.w	r12,r7[0x0]
8000343e:	f0 1f 02 63 	mcall	80003dc8 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
80003442:	fe f8 09 52 	ld.w	r8,pc[2386]
80003446:	70 0c       	ld.w	r12,r8[0x0]
80003448:	f0 1f 02 4d 	mcall	80003d7c <phy_rx_func+0xe98>
8000344c:	8f 0c       	st.w	r7[0x0],r12
					if(NULL == payload_ptr)
8000344e:	e0 80 04 88 	breq	80003d5e <phy_rx_func+0xe7a>
					{
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0) break;  //This shouldn't happen, but must check;
80003452:	fe f9 09 56 	ld.w	r9,pc[2390]
80003456:	72 08       	ld.w	r8,r9[0x0]
80003458:	20 28       	sub	r8,2
8000345a:	93 08       	st.w	r9[0x0],r8
8000345c:	e0 80 04 81 	breq	80003d5e <phy_rx_func+0xe7a>
				RxMediaState = READINGMEDIA;
80003460:	30 29       	mov	r9,2
80003462:	fe f8 09 3e 	ld.w	r8,pc[2366]
80003466:	91 09       	st.w	r8[0x0],r9
80003468:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
		case READINGMEDIA:
				
			/***PCM-media-data ****/
			{
				
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[0];
8000346c:	fe f8 09 84 	ld.w	r8,pc[2436]
80003470:	70 0a       	ld.w	r10,r8[0x0]
80003472:	fe f9 09 26 	ld.w	r9,pc[2342]
80003476:	72 09       	ld.w	r9,r9[0x0]
80003478:	8e 4b       	ld.sh	r11,r7[0x8]
8000347a:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;	
8000347e:	70 09       	ld.w	r9,r8[0x0]
80003480:	2f f9       	sub	r9,-1
80003482:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003484:	e0 49 00 ff 	cp.w	r9,255
80003488:	e0 88 00 16 	brls	800034b4 <phy_rx_func+0x5d0>
				{
					RxMedia_IsFillingNext16 = 0;
8000348c:	30 09       	mov	r9,0
8000348e:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003490:	fe f6 09 08 	ld.w	r6,pc[2312]
80003494:	6c 0c       	ld.w	r12,r6[0x0]
80003496:	f0 1f 02 4d 	mcall	80003dc8 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
8000349a:	fe f8 08 fa 	ld.w	r8,pc[2298]
8000349e:	70 0c       	ld.w	r12,r8[0x0]
800034a0:	f0 1f 02 37 	mcall	80003d7c <phy_rx_func+0xe98>
800034a4:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
800034a6:	c0 71       	brne	800034b4 <phy_rx_func+0x5d0>
					{
						RxMediaState = WAITINGABAB;
800034a8:	30 09       	mov	r9,0
800034aa:	fe f8 08 f6 	ld.w	r8,pc[2294]
800034ae:	91 09       	st.w	r8[0x0],r9
800034b0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0)
800034b4:	fe f9 08 f4 	ld.w	r9,pc[2292]
800034b8:	72 08       	ld.w	r8,r9[0x0]
800034ba:	20 28       	sub	r8,2
800034bc:	93 08       	st.w	r9[0x0],r8
800034be:	c0 71       	brne	800034cc <phy_rx_func+0x5e8>
				{
					RxMediaState = WAITINGABAB;
800034c0:	30 09       	mov	r9,0
800034c2:	fe f8 08 de 	ld.w	r8,pc[2270]
800034c6:	91 09       	st.w	r8[0x0],r9
800034c8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[1];
800034cc:	fe f8 09 24 	ld.w	r8,pc[2340]
800034d0:	70 0a       	ld.w	r10,r8[0x0]
800034d2:	fe f9 08 c6 	ld.w	r9,pc[2246]
800034d6:	72 09       	ld.w	r9,r9[0x0]
800034d8:	8e 5b       	ld.sh	r11,r7[0xa]
800034da:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
800034de:	70 09       	ld.w	r9,r8[0x0]
800034e0:	2f f9       	sub	r9,-1
800034e2:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800034e4:	e0 49 00 ff 	cp.w	r9,255
800034e8:	e0 88 00 16 	brls	80003514 <phy_rx_func+0x630>
				{
					RxMedia_IsFillingNext16 = 0;
800034ec:	30 09       	mov	r9,0
800034ee:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
800034f0:	fe f6 08 a8 	ld.w	r6,pc[2216]
800034f4:	6c 0c       	ld.w	r12,r6[0x0]
800034f6:	f0 1f 02 35 	mcall	80003dc8 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
800034fa:	fe f8 08 9a 	ld.w	r8,pc[2202]
800034fe:	70 0c       	ld.w	r12,r8[0x0]
80003500:	f0 1f 02 1f 	mcall	80003d7c <phy_rx_func+0xe98>
80003504:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
80003506:	c0 71       	brne	80003514 <phy_rx_func+0x630>
					{
						RxMediaState = WAITINGABAB;
80003508:	30 09       	mov	r9,0
8000350a:	fe f8 08 96 	ld.w	r8,pc[2198]
8000350e:	91 09       	st.w	r8[0x0],r9
80003510:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
80003514:	fe f9 08 94 	ld.w	r9,pc[2196]
80003518:	72 08       	ld.w	r8,r9[0x0]
8000351a:	20 28       	sub	r8,2
8000351c:	93 08       	st.w	r9[0x0],r8
8000351e:	c0 71       	brne	8000352c <phy_rx_func+0x648>
					RxMediaState = WAITINGABAB;
80003520:	30 09       	mov	r9,0
80003522:	fe f8 08 7e 	ld.w	r8,pc[2174]
80003526:	91 09       	st.w	r8[0x0],r9
80003528:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}

				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[2];
8000352c:	fe f8 08 c4 	ld.w	r8,pc[2244]
80003530:	70 0a       	ld.w	r10,r8[0x0]
80003532:	fe f9 08 66 	ld.w	r9,pc[2150]
80003536:	72 09       	ld.w	r9,r9[0x0]
80003538:	8e 6b       	ld.sh	r11,r7[0xc]
8000353a:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
8000353e:	70 09       	ld.w	r9,r8[0x0]
80003540:	2f f9       	sub	r9,-1
80003542:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003544:	e0 49 00 ff 	cp.w	r9,255
80003548:	e0 88 00 16 	brls	80003574 <phy_rx_func+0x690>
				{
					RxMedia_IsFillingNext16 = 0;
8000354c:	30 09       	mov	r9,0
8000354e:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003550:	fe f6 08 48 	ld.w	r6,pc[2120]
80003554:	6c 0c       	ld.w	r12,r6[0x0]
80003556:	f0 1f 02 1d 	mcall	80003dc8 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
8000355a:	fe f8 08 3a 	ld.w	r8,pc[2106]
8000355e:	70 0c       	ld.w	r12,r8[0x0]
80003560:	f0 1f 02 07 	mcall	80003d7c <phy_rx_func+0xe98>
80003564:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
80003566:	c0 71       	brne	80003574 <phy_rx_func+0x690>
					{
						RxMediaState = WAITINGABAB;
80003568:	30 09       	mov	r9,0
8000356a:	fe f8 08 36 	ld.w	r8,pc[2102]
8000356e:	91 09       	st.w	r8[0x0],r9
80003570:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
80003574:	fe f9 08 34 	ld.w	r9,pc[2100]
80003578:	72 08       	ld.w	r8,r9[0x0]
8000357a:	20 28       	sub	r8,2
8000357c:	93 08       	st.w	r9[0x0],r8
8000357e:	c0 71       	brne	8000358c <phy_rx_func+0x6a8>
					RxMediaState = WAITINGABAB;
80003580:	30 09       	mov	r9,0
80003582:	fe f8 08 1e 	ld.w	r8,pc[2078]
80003586:	91 09       	st.w	r8[0x0],r9
80003588:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
8000358c:	fe f8 08 64 	ld.w	r8,pc[2148]
80003590:	70 0a       	ld.w	r10,r8[0x0]
80003592:	fe f9 08 06 	ld.w	r9,pc[2054]
80003596:	72 09       	ld.w	r9,r9[0x0]
80003598:	8e 7b       	ld.sh	r11,r7[0xe]
8000359a:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
8000359e:	70 09       	ld.w	r9,r8[0x0]
800035a0:	2f f9       	sub	r9,-1
800035a2:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800035a4:	e0 49 00 ff 	cp.w	r9,255
800035a8:	e0 88 00 16 	brls	800035d4 <phy_rx_func+0x6f0>
				{
					RxMedia_IsFillingNext16 = 0;
800035ac:	30 09       	mov	r9,0
800035ae:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
800035b0:	fe f7 07 e8 	ld.w	r7,pc[2024]
800035b4:	6e 0c       	ld.w	r12,r7[0x0]
800035b6:	f0 1f 02 05 	mcall	80003dc8 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
800035ba:	fe f8 07 da 	ld.w	r8,pc[2010]
800035be:	70 0c       	ld.w	r12,r8[0x0]
800035c0:	f0 1f 01 ef 	mcall	80003d7c <phy_rx_func+0xe98>
800035c4:	8f 0c       	st.w	r7[0x0],r12
					if(NULL == payload_ptr)
800035c6:	c0 71       	brne	800035d4 <phy_rx_func+0x6f0>
					{
						RxMediaState = WAITINGABAB;
800035c8:	30 09       	mov	r9,0
800035ca:	fe f8 07 d6 	ld.w	r8,pc[2006]
800035ce:	91 09       	st.w	r8[0x0],r9
800035d0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
800035d4:	fe f9 07 d4 	ld.w	r9,pc[2004]
800035d8:	72 08       	ld.w	r8,r9[0x0]
800035da:	20 28       	sub	r8,2
800035dc:	93 08       	st.w	r9[0x0],r8
800035de:	e0 81 03 c0 	brne	80003d5e <phy_rx_func+0xe7a>
					RxMediaState = WAITINGABAB;
800035e2:	30 09       	mov	r9,0
800035e4:	fe f8 07 bc 	ld.w	r8,pc[1980]
800035e8:	91 09       	st.w	r8[0x0],r9
800035ea:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

		case READING_AMBE_MEDIA:
		
			/****AMBE-media-data ****/
		
					if ((Item_ID == Vocoder_Bit_Stream_Parameter))//PAYLOAD_DATA_ENH (0x0c))
800035ee:	fe f8 07 ca 	ld.w	r8,pc[1994]
800035f2:	11 89       	ld.ub	r9,r8[0x0]
800035f4:	31 28       	mov	r8,18
800035f6:	f0 09 18 00 	cp.b	r9,r8
800035fa:	e0 81 01 4c 	brne	80003892 <phy_rx_func+0x9ae>
					{
						Item_ID = payload_rx_channel->byte[1];
800035fe:	ef 39 00 09 	ld.ub	r9,r7[9]
80003602:	fe f8 07 b6 	ld.w	r8,pc[1974]
80003606:	b0 89       	st.b	r8[0x0],r9
						if (Item_ID == Post_Voice_Encoder_Data)//发送方的压缩类型数据
80003608:	11 89       	ld.ub	r9,r8[0x0]
8000360a:	3f 28       	mov	r8,-14
8000360c:	f0 09 18 00 	cp.b	r9,r8
80003610:	e0 81 01 3b 	brne	80003886 <phy_rx_func+0x9a2>
						{
							AMBE_tx_flag = 1;
80003614:	30 19       	mov	r9,1
80003616:	fe f8 07 ce 	ld.w	r8,pc[1998]
8000361a:	b0 89       	st.b	r8[0x0],r9
							
							RxBytesWaiting = ((payload_rx_channel->dword[0] & 0x7F000000) >>24);//Test calculations are correct; 8
8000361c:	6e 29       	ld.w	r9,r7[0x8]
8000361e:	f3 d9 c3 07 	bfextu	r9,r9,0x18,0x7
80003622:	fe f8 07 86 	ld.w	r8,pc[1926]
80003626:	91 09       	st.w	r8[0x0],r9
							
							//For looping back to Radio
							AMBEBurst_rawdata[0] = payload_rx_channel->word[1];
80003628:	8e 59       	ld.sh	r9,r7[0xa]
8000362a:	fe f8 07 ce 	ld.w	r8,pc[1998]
8000362e:	b0 09       	st.h	r8[0x0],r9
							AMBEBurst_rawdata[1] = payload_rx_channel->word[2];
80003630:	8e 69       	ld.sh	r9,r7[0xc]
80003632:	b0 19       	st.h	r8[0x2],r9
							AMBEBurst_rawdata[2] = payload_rx_channel->word[3];
80003634:	8e 79       	ld.sh	r9,r7[0xe]
80003636:	b0 29       	st.h	r8[0x4],r9
							
							//To be tested. Also locally stored RAW-AMBER-DATA
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//1
80003638:	fe f8 07 88 	ld.w	r8,pc[1928]
8000363c:	fe f9 07 60 	ld.w	r9,pc[1888]
80003640:	72 0a       	ld.w	r10,r9[0x0]
80003642:	70 09       	ld.w	r9,r8[0x0]
80003644:	ef 3b 00 0a 	ld.ub	r11,r7[10]
80003648:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
8000364c:	70 09       	ld.w	r9,r8[0x0]
8000364e:	2f f9       	sub	r9,-1
80003650:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003652:	e0 49 01 ff 	cp.w	r9,511
80003656:	e0 88 00 16 	brls	80003682 <phy_rx_func+0x79e>
							{
								RxAMBE_IsFillingNext8 = 0;
8000365a:	30 09       	mov	r9,0
8000365c:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
8000365e:	fe f6 07 3e 	ld.w	r6,pc[1854]
80003662:	6c 0c       	ld.w	r12,r6[0x0]
80003664:	f0 1f 01 d9 	mcall	80003dc8 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003668:	fe f8 07 2c 	ld.w	r8,pc[1836]
8000366c:	70 0c       	ld.w	r12,r8[0x0]
8000366e:	f0 1f 01 c4 	mcall	80003d7c <phy_rx_func+0xe98>
80003672:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003674:	c0 71       	brne	80003682 <phy_rx_func+0x79e>
								{
									RxMediaState = WAITINGABAB;
80003676:	30 09       	mov	r9,0
80003678:	fe f8 07 28 	ld.w	r8,pc[1832]
8000367c:	91 09       	st.w	r8[0x0],r9
8000367e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003682:	fe f9 07 26 	ld.w	r9,pc[1830]
80003686:	72 08       	ld.w	r8,r9[0x0]
80003688:	20 18       	sub	r8,1
8000368a:	93 08       	st.w	r9[0x0],r8
8000368c:	c0 71       	brne	8000369a <phy_rx_func+0x7b6>
								RxMediaState = WAITINGABAB;
8000368e:	30 09       	mov	r9,0
80003690:	fe f8 07 10 	ld.w	r8,pc[1808]
80003694:	91 09       	st.w	r8[0x0],r9
80003696:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}			
							
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//2
8000369a:	fe f8 07 26 	ld.w	r8,pc[1830]
8000369e:	fe f9 06 fe 	ld.w	r9,pc[1790]
800036a2:	72 0a       	ld.w	r10,r9[0x0]
800036a4:	70 09       	ld.w	r9,r8[0x0]
800036a6:	ef 3b 00 0b 	ld.ub	r11,r7[11]
800036aa:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
800036ae:	70 09       	ld.w	r9,r8[0x0]
800036b0:	2f f9       	sub	r9,-1
800036b2:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800036b4:	e0 49 01 ff 	cp.w	r9,511
800036b8:	e0 88 00 16 	brls	800036e4 <phy_rx_func+0x800>
							{
								RxAMBE_IsFillingNext8 = 0;
800036bc:	30 09       	mov	r9,0
800036be:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
800036c0:	fe f6 06 dc 	ld.w	r6,pc[1756]
800036c4:	6c 0c       	ld.w	r12,r6[0x0]
800036c6:	f0 1f 01 c1 	mcall	80003dc8 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
800036ca:	fe f8 06 ca 	ld.w	r8,pc[1738]
800036ce:	70 0c       	ld.w	r12,r8[0x0]
800036d0:	f0 1f 01 ab 	mcall	80003d7c <phy_rx_func+0xe98>
800036d4:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
800036d6:	c0 71       	brne	800036e4 <phy_rx_func+0x800>
								{
									RxMediaState = WAITINGABAB;
800036d8:	30 09       	mov	r9,0
800036da:	fe f8 06 c6 	ld.w	r8,pc[1734]
800036de:	91 09       	st.w	r8[0x0],r9
800036e0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800036e4:	fe f9 06 c4 	ld.w	r9,pc[1732]
800036e8:	72 08       	ld.w	r8,r9[0x0]
800036ea:	20 18       	sub	r8,1
800036ec:	93 08       	st.w	r9[0x0],r8
800036ee:	c0 71       	brne	800036fc <phy_rx_func+0x818>
								RxMediaState = WAITINGABAB;
800036f0:	30 09       	mov	r9,0
800036f2:	fe f8 06 ae 	ld.w	r8,pc[1710]
800036f6:	91 09       	st.w	r8[0x0],r9
800036f8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}		
						
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//3
800036fc:	fe f8 06 c4 	ld.w	r8,pc[1732]
80003700:	fe f9 06 9c 	ld.w	r9,pc[1692]
80003704:	72 0a       	ld.w	r10,r9[0x0]
80003706:	70 09       	ld.w	r9,r8[0x0]
80003708:	ef 3b 00 0c 	ld.ub	r11,r7[12]
8000370c:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003710:	70 09       	ld.w	r9,r8[0x0]
80003712:	2f f9       	sub	r9,-1
80003714:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003716:	e0 49 01 ff 	cp.w	r9,511
8000371a:	e0 88 00 16 	brls	80003746 <phy_rx_func+0x862>
							{
								RxAMBE_IsFillingNext8 = 0;
8000371e:	30 09       	mov	r9,0
80003720:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003722:	fe f6 06 7a 	ld.w	r6,pc[1658]
80003726:	6c 0c       	ld.w	r12,r6[0x0]
80003728:	f0 1f 01 a8 	mcall	80003dc8 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
8000372c:	fe f8 06 68 	ld.w	r8,pc[1640]
80003730:	70 0c       	ld.w	r12,r8[0x0]
80003732:	f0 1f 01 93 	mcall	80003d7c <phy_rx_func+0xe98>
80003736:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003738:	c0 71       	brne	80003746 <phy_rx_func+0x862>
								{
									RxMediaState = WAITINGABAB;
8000373a:	30 09       	mov	r9,0
8000373c:	fe f8 06 64 	ld.w	r8,pc[1636]
80003740:	91 09       	st.w	r8[0x0],r9
80003742:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003746:	fe f9 06 62 	ld.w	r9,pc[1634]
8000374a:	72 08       	ld.w	r8,r9[0x0]
8000374c:	20 18       	sub	r8,1
8000374e:	93 08       	st.w	r9[0x0],r8
80003750:	c0 71       	brne	8000375e <phy_rx_func+0x87a>
								RxMediaState = WAITINGABAB;
80003752:	30 09       	mov	r9,0
80003754:	fe f8 06 4c 	ld.w	r8,pc[1612]
80003758:	91 09       	st.w	r8[0x0],r9
8000375a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[5];//4
8000375e:	fe f8 06 62 	ld.w	r8,pc[1634]
80003762:	fe f9 06 3a 	ld.w	r9,pc[1594]
80003766:	72 0a       	ld.w	r10,r9[0x0]
80003768:	70 09       	ld.w	r9,r8[0x0]
8000376a:	ef 3b 00 0d 	ld.ub	r11,r7[13]
8000376e:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003772:	70 09       	ld.w	r9,r8[0x0]
80003774:	2f f9       	sub	r9,-1
80003776:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003778:	e0 49 01 ff 	cp.w	r9,511
8000377c:	e0 88 00 16 	brls	800037a8 <phy_rx_func+0x8c4>
							{
								RxAMBE_IsFillingNext8 = 0;
80003780:	30 09       	mov	r9,0
80003782:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003784:	fe f6 06 18 	ld.w	r6,pc[1560]
80003788:	6c 0c       	ld.w	r12,r6[0x0]
8000378a:	f0 1f 01 90 	mcall	80003dc8 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
8000378e:	fe f8 06 06 	ld.w	r8,pc[1542]
80003792:	70 0c       	ld.w	r12,r8[0x0]
80003794:	f0 1f 01 7a 	mcall	80003d7c <phy_rx_func+0xe98>
80003798:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
8000379a:	c0 71       	brne	800037a8 <phy_rx_func+0x8c4>
								{
									RxMediaState = WAITINGABAB;
8000379c:	30 09       	mov	r9,0
8000379e:	fe f8 06 02 	ld.w	r8,pc[1538]
800037a2:	91 09       	st.w	r8[0x0],r9
800037a4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800037a8:	fe f9 06 00 	ld.w	r9,pc[1536]
800037ac:	72 08       	ld.w	r8,r9[0x0]
800037ae:	20 18       	sub	r8,1
800037b0:	93 08       	st.w	r9[0x0],r8
800037b2:	c0 71       	brne	800037c0 <phy_rx_func+0x8dc>
								RxMediaState = WAITINGABAB;
800037b4:	30 09       	mov	r9,0
800037b6:	fe f8 05 ea 	ld.w	r8,pc[1514]
800037ba:	91 09       	st.w	r8[0x0],r9
800037bc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//5
800037c0:	fe f8 06 00 	ld.w	r8,pc[1536]
800037c4:	fe f9 05 d8 	ld.w	r9,pc[1496]
800037c8:	72 0a       	ld.w	r10,r9[0x0]
800037ca:	70 09       	ld.w	r9,r8[0x0]
800037cc:	ef 3b 00 0e 	ld.ub	r11,r7[14]
800037d0:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
800037d4:	70 09       	ld.w	r9,r8[0x0]
800037d6:	2f f9       	sub	r9,-1
800037d8:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800037da:	e0 49 01 ff 	cp.w	r9,511
800037de:	e0 88 00 16 	brls	8000380a <phy_rx_func+0x926>
							{
								RxAMBE_IsFillingNext8 = 0;
800037e2:	30 09       	mov	r9,0
800037e4:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
800037e6:	fe f6 05 b6 	ld.w	r6,pc[1462]
800037ea:	6c 0c       	ld.w	r12,r6[0x0]
800037ec:	f0 1f 01 77 	mcall	80003dc8 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
800037f0:	fe f8 05 a4 	ld.w	r8,pc[1444]
800037f4:	70 0c       	ld.w	r12,r8[0x0]
800037f6:	f0 1f 01 62 	mcall	80003d7c <phy_rx_func+0xe98>
800037fa:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
800037fc:	c0 71       	brne	8000380a <phy_rx_func+0x926>
								{
									RxMediaState = WAITINGABAB;
800037fe:	30 09       	mov	r9,0
80003800:	fe f8 05 a0 	ld.w	r8,pc[1440]
80003804:	91 09       	st.w	r8[0x0],r9
80003806:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
8000380a:	fe f9 05 9e 	ld.w	r9,pc[1438]
8000380e:	72 08       	ld.w	r8,r9[0x0]
80003810:	20 18       	sub	r8,1
80003812:	93 08       	st.w	r9[0x0],r8
80003814:	c0 71       	brne	80003822 <phy_rx_func+0x93e>
								RxMediaState = WAITINGABAB;
80003816:	30 09       	mov	r9,0
80003818:	fe f8 05 88 	ld.w	r8,pc[1416]
8000381c:	91 09       	st.w	r8[0x0],r9
8000381e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//6
80003822:	fe f8 05 9e 	ld.w	r8,pc[1438]
80003826:	fe f9 05 76 	ld.w	r9,pc[1398]
8000382a:	72 0a       	ld.w	r10,r9[0x0]
8000382c:	70 09       	ld.w	r9,r8[0x0]
8000382e:	ef 3b 00 0f 	ld.ub	r11,r7[15]
80003832:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003836:	70 09       	ld.w	r9,r8[0x0]
80003838:	2f f9       	sub	r9,-1
8000383a:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000383c:	e0 49 01 ff 	cp.w	r9,511
80003840:	e0 88 00 16 	brls	8000386c <phy_rx_func+0x988>
							{
								RxAMBE_IsFillingNext8 = 0;
80003844:	30 09       	mov	r9,0
80003846:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003848:	fe f7 05 54 	ld.w	r7,pc[1364]
8000384c:	6e 0c       	ld.w	r12,r7[0x0]
8000384e:	f0 1f 01 5f 	mcall	80003dc8 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003852:	fe f8 05 42 	ld.w	r8,pc[1346]
80003856:	70 0c       	ld.w	r12,r8[0x0]
80003858:	f0 1f 01 49 	mcall	80003d7c <phy_rx_func+0xe98>
8000385c:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == AMBE_payload_ptr)
8000385e:	c0 71       	brne	8000386c <phy_rx_func+0x988>
								{
									RxMediaState = WAITINGABAB;
80003860:	30 09       	mov	r9,0
80003862:	fe f8 05 3e 	ld.w	r8,pc[1342]
80003866:	91 09       	st.w	r8[0x0],r9
80003868:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
8000386c:	fe f9 05 3c 	ld.w	r9,pc[1340]
80003870:	72 08       	ld.w	r8,r9[0x0]
80003872:	20 18       	sub	r8,1
80003874:	93 08       	st.w	r9[0x0],r8
80003876:	e0 81 02 74 	brne	80003d5e <phy_rx_func+0xe7a>
								RxMediaState = WAITINGABAB;
8000387a:	30 09       	mov	r9,0
8000387c:	fe f8 05 24 	ld.w	r8,pc[1316]
80003880:	91 09       	st.w	r8[0x0],r9
80003882:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							//}
							
						}
						else//error
						{
							RxMediaState = WAITINGABAB;
80003886:	30 09       	mov	r9,0
80003888:	fe f8 05 18 	ld.w	r8,pc[1304]
8000388c:	91 09       	st.w	r8[0x0],r9
8000388e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
					}
					else if (Item_ID == Post_Voice_Encoder_Data)//(bit48~Pad-bits)
80003892:	fe f8 05 26 	ld.w	r8,pc[1318]
80003896:	11 89       	ld.ub	r9,r8[0x0]
80003898:	3f 28       	mov	r8,-14
8000389a:	f0 09 18 00 	cp.b	r9,r8
8000389e:	c4 31       	brne	80003924 <phy_rx_func+0xa40>
					{
					
						AMBEBurst_rawdata[3] = payload_rx_channel->word[0];//(bit48~Pad-bits)
800038a0:	8e 49       	ld.sh	r9,r7[0x8]
800038a2:	fe f8 05 56 	ld.w	r8,pc[1366]
800038a6:	b0 39       	st.h	r8[0x6],r9
						//AMBE_Per_Burst_Flag = 1;
						
						//根据MOTO.bit文件数据分布，建议测试pad-bits的最后一个字节不保存。
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//7
800038a8:	fe f8 05 18 	ld.w	r8,pc[1304]
800038ac:	fe f9 04 f0 	ld.w	r9,pc[1264]
800038b0:	72 0a       	ld.w	r10,r9[0x0]
800038b2:	70 09       	ld.w	r9,r8[0x0]
800038b4:	ef 3b 00 08 	ld.ub	r11,r7[8]
800038b8:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
800038bc:	70 09       	ld.w	r9,r8[0x0]
800038be:	2f f9       	sub	r9,-1
800038c0:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800038c2:	e0 49 01 ff 	cp.w	r9,511
800038c6:	e0 88 00 16 	brls	800038f2 <phy_rx_func+0xa0e>
						{
							RxAMBE_IsFillingNext8 = 0;
800038ca:	30 09       	mov	r9,0
800038cc:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
800038ce:	fe f7 04 ce 	ld.w	r7,pc[1230]
800038d2:	6e 0c       	ld.w	r12,r7[0x0]
800038d4:	f0 1f 01 3d 	mcall	80003dc8 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
800038d8:	fe f8 04 bc 	ld.w	r8,pc[1212]
800038dc:	70 0c       	ld.w	r12,r8[0x0]
800038de:	f0 1f 01 28 	mcall	80003d7c <phy_rx_func+0xe98>
800038e2:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
800038e4:	c0 71       	brne	800038f2 <phy_rx_func+0xa0e>
							{
								RxMediaState = WAITINGABAB;
800038e6:	30 09       	mov	r9,0
800038e8:	fe f8 04 b8 	ld.w	r8,pc[1208]
800038ec:	91 09       	st.w	r8[0x0],r9
800038ee:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
800038f2:	fe f9 04 b6 	ld.w	r9,pc[1206]
800038f6:	72 08       	ld.w	r8,r9[0x0]
800038f8:	20 18       	sub	r8,1
800038fa:	93 08       	st.w	r9[0x0],r8
800038fc:	c0 71       	brne	8000390a <phy_rx_func+0xa26>
							RxMediaState = WAITINGABAB;
800038fe:	30 09       	mov	r9,0
80003900:	fe f8 04 a0 	ld.w	r8,pc[1184]
80003904:	91 09       	st.w	r8[0x0],r9
80003906:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
						if ((RxBytesWaiting -= 1) <= 0){//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
8000390a:	20 18       	sub	r8,1
8000390c:	fe f9 04 9c 	ld.w	r9,pc[1180]
80003910:	93 08       	st.w	r9[0x0],r8
80003912:	58 08       	cp.w	r8,0
80003914:	e0 81 02 25 	brne	80003d5e <phy_rx_func+0xe7a>
							RxMediaState = WAITINGABAB;
80003918:	30 09       	mov	r9,0
8000391a:	fe f8 04 86 	ld.w	r8,pc[1158]
8000391e:	91 09       	st.w	r8[0x0],r9
80003920:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
								
					}
					else if (Item_ID == Pre_Voice_Decoder_Data)//bit16~bit63
80003924:	fe f8 04 94 	ld.w	r8,pc[1172]
80003928:	11 89       	ld.ub	r9,r8[0x0]
8000392a:	3f 38       	mov	r8,-13
8000392c:	f0 09 18 00 	cp.b	r9,r8
80003930:	e0 81 01 0c 	brne	80003b48 <phy_rx_func+0xc64>
					{
						//接收方的解压类型数据
						//For looping back to Radio
						AMBEBurst_rawdata[1] = payload_rx_channel->word[0];
80003934:	8e 49       	ld.sh	r9,r7[0x8]
80003936:	fe f8 04 c2 	ld.w	r8,pc[1218]
8000393a:	b0 19       	st.h	r8[0x2],r9
						AMBEBurst_rawdata[2] = payload_rx_channel->word[1];
8000393c:	8e 59       	ld.sh	r9,r7[0xa]
8000393e:	b0 29       	st.h	r8[0x4],r9
						AMBEBurst_rawdata[3] = payload_rx_channel->word[2];
80003940:	8e 69       	ld.sh	r9,r7[0xc]
80003942:	b0 39       	st.h	r8[0x6],r9
						//if((m_RxBurstType == VOICEBURST_A) && (VF_SN == 1))
						//logFromISR("\n\r Pre_rx:%X\n\r", payload_rx_channel->word[2]);
						
						//To be tested. Also locally stored RAW-AMBER-DATA
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//3
80003944:	fe f8 04 7c 	ld.w	r8,pc[1148]
80003948:	fe f9 04 54 	ld.w	r9,pc[1108]
8000394c:	72 0a       	ld.w	r10,r9[0x0]
8000394e:	70 09       	ld.w	r9,r8[0x0]
80003950:	ef 3b 00 08 	ld.ub	r11,r7[8]
80003954:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003958:	70 09       	ld.w	r9,r8[0x0]
8000395a:	2f f9       	sub	r9,-1
8000395c:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000395e:	e0 49 01 ff 	cp.w	r9,511
80003962:	e0 88 00 16 	brls	8000398e <phy_rx_func+0xaaa>
						{
							RxAMBE_IsFillingNext8 = 0;
80003966:	30 09       	mov	r9,0
80003968:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
8000396a:	fe f6 04 32 	ld.w	r6,pc[1074]
8000396e:	6c 0c       	ld.w	r12,r6[0x0]
80003970:	f0 1f 01 16 	mcall	80003dc8 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003974:	fe f8 04 20 	ld.w	r8,pc[1056]
80003978:	70 0c       	ld.w	r12,r8[0x0]
8000397a:	f0 1f 01 01 	mcall	80003d7c <phy_rx_func+0xe98>
8000397e:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003980:	c0 71       	brne	8000398e <phy_rx_func+0xaaa>
							{
								RxMediaState = WAITINGABAB;
80003982:	30 09       	mov	r9,0
80003984:	fe f8 04 1c 	ld.w	r8,pc[1052]
80003988:	91 09       	st.w	r8[0x0],r9
8000398a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
8000398e:	fe f9 04 1a 	ld.w	r9,pc[1050]
80003992:	72 08       	ld.w	r8,r9[0x0]
80003994:	20 18       	sub	r8,1
80003996:	93 08       	st.w	r9[0x0],r8
80003998:	c0 71       	brne	800039a6 <phy_rx_func+0xac2>
							RxMediaState = WAITINGABAB;
8000399a:	30 09       	mov	r9,0
8000399c:	fe f8 04 04 	ld.w	r8,pc[1028]
800039a0:	91 09       	st.w	r8[0x0],r9
800039a2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[1];//4
800039a6:	fe f8 04 1a 	ld.w	r8,pc[1050]
800039aa:	fe f9 03 f2 	ld.w	r9,pc[1010]
800039ae:	72 0a       	ld.w	r10,r9[0x0]
800039b0:	70 09       	ld.w	r9,r8[0x0]
800039b2:	ef 3b 00 09 	ld.ub	r11,r7[9]
800039b6:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
800039ba:	70 09       	ld.w	r9,r8[0x0]
800039bc:	2f f9       	sub	r9,-1
800039be:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800039c0:	e0 49 01 ff 	cp.w	r9,511
800039c4:	e0 88 00 16 	brls	800039f0 <phy_rx_func+0xb0c>
						{
							RxAMBE_IsFillingNext8 = 0;
800039c8:	30 09       	mov	r9,0
800039ca:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
800039cc:	fe f6 03 d0 	ld.w	r6,pc[976]
800039d0:	6c 0c       	ld.w	r12,r6[0x0]
800039d2:	f0 1f 00 fe 	mcall	80003dc8 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
800039d6:	fe f8 03 be 	ld.w	r8,pc[958]
800039da:	70 0c       	ld.w	r12,r8[0x0]
800039dc:	f0 1f 00 e8 	mcall	80003d7c <phy_rx_func+0xe98>
800039e0:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
800039e2:	c0 71       	brne	800039f0 <phy_rx_func+0xb0c>
							{
								RxMediaState = WAITINGABAB;
800039e4:	30 09       	mov	r9,0
800039e6:	fe f8 03 ba 	ld.w	r8,pc[954]
800039ea:	91 09       	st.w	r8[0x0],r9
800039ec:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
800039f0:	fe f9 03 b8 	ld.w	r9,pc[952]
800039f4:	72 08       	ld.w	r8,r9[0x0]
800039f6:	20 18       	sub	r8,1
800039f8:	93 08       	st.w	r9[0x0],r8
800039fa:	c0 71       	brne	80003a08 <phy_rx_func+0xb24>
							RxMediaState = WAITINGABAB;
800039fc:	30 09       	mov	r9,0
800039fe:	fe f8 03 a2 	ld.w	r8,pc[930]
80003a02:	91 09       	st.w	r8[0x0],r9
80003a04:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//5
80003a08:	fe f8 03 b8 	ld.w	r8,pc[952]
80003a0c:	fe f9 03 90 	ld.w	r9,pc[912]
80003a10:	72 0a       	ld.w	r10,r9[0x0]
80003a12:	70 09       	ld.w	r9,r8[0x0]
80003a14:	ef 3b 00 0a 	ld.ub	r11,r7[10]
80003a18:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003a1c:	70 09       	ld.w	r9,r8[0x0]
80003a1e:	2f f9       	sub	r9,-1
80003a20:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003a22:	e0 49 01 ff 	cp.w	r9,511
80003a26:	e0 88 00 16 	brls	80003a52 <phy_rx_func+0xb6e>
						{
							RxAMBE_IsFillingNext8 = 0;
80003a2a:	30 09       	mov	r9,0
80003a2c:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003a2e:	fe f6 03 6e 	ld.w	r6,pc[878]
80003a32:	6c 0c       	ld.w	r12,r6[0x0]
80003a34:	f0 1f 00 e5 	mcall	80003dc8 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003a38:	fe f8 03 5c 	ld.w	r8,pc[860]
80003a3c:	70 0c       	ld.w	r12,r8[0x0]
80003a3e:	f0 1f 00 d0 	mcall	80003d7c <phy_rx_func+0xe98>
80003a42:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003a44:	c0 71       	brne	80003a52 <phy_rx_func+0xb6e>
							{
								RxMediaState = WAITINGABAB;
80003a46:	30 09       	mov	r9,0
80003a48:	fe f8 03 58 	ld.w	r8,pc[856]
80003a4c:	91 09       	st.w	r8[0x0],r9
80003a4e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003a52:	fe f9 03 56 	ld.w	r9,pc[854]
80003a56:	72 08       	ld.w	r8,r9[0x0]
80003a58:	20 18       	sub	r8,1
80003a5a:	93 08       	st.w	r9[0x0],r8
80003a5c:	c0 71       	brne	80003a6a <phy_rx_func+0xb86>
							RxMediaState = WAITINGABAB;
80003a5e:	30 09       	mov	r9,0
80003a60:	fe f8 03 40 	ld.w	r8,pc[832]
80003a64:	91 09       	st.w	r8[0x0],r9
80003a66:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//6
80003a6a:	fe f8 03 56 	ld.w	r8,pc[854]
80003a6e:	fe f9 03 2e 	ld.w	r9,pc[814]
80003a72:	72 0a       	ld.w	r10,r9[0x0]
80003a74:	70 09       	ld.w	r9,r8[0x0]
80003a76:	ef 3b 00 0b 	ld.ub	r11,r7[11]
80003a7a:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003a7e:	70 09       	ld.w	r9,r8[0x0]
80003a80:	2f f9       	sub	r9,-1
80003a82:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003a84:	e0 49 01 ff 	cp.w	r9,511
80003a88:	e0 88 00 16 	brls	80003ab4 <phy_rx_func+0xbd0>
						{
							RxAMBE_IsFillingNext8 = 0;
80003a8c:	30 09       	mov	r9,0
80003a8e:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003a90:	fe f6 03 0c 	ld.w	r6,pc[780]
80003a94:	6c 0c       	ld.w	r12,r6[0x0]
80003a96:	f0 1f 00 cd 	mcall	80003dc8 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003a9a:	fe f8 02 fa 	ld.w	r8,pc[762]
80003a9e:	70 0c       	ld.w	r12,r8[0x0]
80003aa0:	f0 1f 00 b7 	mcall	80003d7c <phy_rx_func+0xe98>
80003aa4:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003aa6:	c0 71       	brne	80003ab4 <phy_rx_func+0xbd0>
							{
								RxMediaState = WAITINGABAB;
80003aa8:	30 09       	mov	r9,0
80003aaa:	fe f8 02 f6 	ld.w	r8,pc[758]
80003aae:	91 09       	st.w	r8[0x0],r9
80003ab0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003ab4:	fe f9 02 f4 	ld.w	r9,pc[756]
80003ab8:	72 08       	ld.w	r8,r9[0x0]
80003aba:	20 18       	sub	r8,1
80003abc:	93 08       	st.w	r9[0x0],r8
80003abe:	c0 71       	brne	80003acc <phy_rx_func+0xbe8>
							RxMediaState = WAITINGABAB;
80003ac0:	30 09       	mov	r9,0
80003ac2:	fe f8 02 de 	ld.w	r8,pc[734]
80003ac6:	91 09       	st.w	r8[0x0],r9
80003ac8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//7
80003acc:	fe f8 02 f4 	ld.w	r8,pc[756]
80003ad0:	fe f9 02 cc 	ld.w	r9,pc[716]
80003ad4:	72 0a       	ld.w	r10,r9[0x0]
80003ad6:	70 09       	ld.w	r9,r8[0x0]
80003ad8:	ef 3b 00 0c 	ld.ub	r11,r7[12]
80003adc:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003ae0:	70 09       	ld.w	r9,r8[0x0]
80003ae2:	2f f9       	sub	r9,-1
80003ae4:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003ae6:	e0 49 01 ff 	cp.w	r9,511
80003aea:	e0 88 00 16 	brls	80003b16 <phy_rx_func+0xc32>
						{
							RxAMBE_IsFillingNext8 = 0;
80003aee:	30 09       	mov	r9,0
80003af0:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003af2:	fe f7 02 aa 	ld.w	r7,pc[682]
80003af6:	6e 0c       	ld.w	r12,r7[0x0]
80003af8:	f0 1f 00 b4 	mcall	80003dc8 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003afc:	fe f8 02 98 	ld.w	r8,pc[664]
80003b00:	70 0c       	ld.w	r12,r8[0x0]
80003b02:	f0 1f 00 9f 	mcall	80003d7c <phy_rx_func+0xe98>
80003b06:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003b08:	c0 71       	brne	80003b16 <phy_rx_func+0xc32>
							{
								RxMediaState = WAITINGABAB;
80003b0a:	30 09       	mov	r9,0
80003b0c:	fe f8 02 94 	ld.w	r8,pc[660]
80003b10:	91 09       	st.w	r8[0x0],r9
80003b12:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003b16:	fe f9 02 92 	ld.w	r9,pc[658]
80003b1a:	72 08       	ld.w	r8,r9[0x0]
80003b1c:	20 18       	sub	r8,1
80003b1e:	93 08       	st.w	r9[0x0],r8
80003b20:	c0 71       	brne	80003b2e <phy_rx_func+0xc4a>
							RxMediaState = WAITINGABAB;
80003b22:	30 09       	mov	r9,0
80003b24:	fe f8 02 7c 	ld.w	r8,pc[636]
80003b28:	91 09       	st.w	r8[0x0],r9
80003b2a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
						if ((RxBytesWaiting -= 1) <= 0){
80003b2e:	20 18       	sub	r8,1
80003b30:	fe f9 02 78 	ld.w	r9,pc[632]
80003b34:	93 08       	st.w	r9[0x0],r8
80003b36:	58 08       	cp.w	r8,0
80003b38:	e0 81 01 13 	brne	80003d5e <phy_rx_func+0xe7a>
							
							//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
							//or discard it to reduce payload size.
							
							RxMediaState = WAITINGABAB;
80003b3c:	30 09       	mov	r9,0
80003b3e:	fe f8 02 62 	ld.w	r8,pc[610]
80003b42:	91 09       	st.w	r8[0x0],r9
80003b44:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
					}
					else if ((Item_ID == 0x04)  ||  (Item_ID == 0x03))//Unknown type data directly back hair
80003b48:	fe f8 02 70 	ld.w	r8,pc[624]
80003b4c:	11 89       	ld.ub	r9,r8[0x0]
80003b4e:	30 48       	mov	r8,4
80003b50:	f0 09 18 00 	cp.b	r9,r8
80003b54:	c0 80       	breq	80003b64 <phy_rx_func+0xc80>
80003b56:	fe f8 02 62 	ld.w	r8,pc[610]
80003b5a:	11 89       	ld.ub	r9,r8[0x0]
80003b5c:	30 38       	mov	r8,3
80003b5e:	f0 09 18 00 	cp.b	r9,r8
80003b62:	c1 41       	brne	80003b8a <phy_rx_func+0xca6>
					{
						AMBE_HT[0] = payload_rx_channel->dword[0];
80003b64:	6e 29       	ld.w	r9,r7[0x8]
80003b66:	fe f8 02 7a 	ld.w	r8,pc[634]
80003b6a:	91 09       	st.w	r8[0x0],r9
						AMBE_HT[1] = payload_rx_channel->dword[1];				
80003b6c:	6e 39       	ld.w	r9,r7[0xc]
80003b6e:	91 19       	st.w	r8[0x4],r9
						
						if ((RxBytesWaiting -= 8) <= 0)//Consider two cases 0xABCDC014 and 0xABCDC010
80003b70:	fe f9 02 38 	ld.w	r9,pc[568]
80003b74:	72 08       	ld.w	r8,r9[0x0]
80003b76:	20 88       	sub	r8,8
80003b78:	93 08       	st.w	r9[0x0],r8
80003b7a:	e0 81 00 f2 	brne	80003d5e <phy_rx_func+0xe7a>
						{
					
							RxBytesWaiting = 0;
80003b7e:	93 08       	st.w	r9[0x0],r8
							RxMediaState = WAITINGABAB;
80003b80:	fe f9 02 20 	ld.w	r9,pc[544]
80003b84:	93 08       	st.w	r9[0x0],r8
80003b86:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
						}
						break;

					}
					else if (Item_ID == Soft_Decision_Value)
80003b8a:	fe f8 02 2e 	ld.w	r8,pc[558]
80003b8e:	11 89       	ld.ub	r9,r8[0x0]
80003b90:	31 38       	mov	r8,19
80003b92:	f0 09 18 00 	cp.b	r9,r8
80003b96:	e0 81 00 9c 	brne	80003cce <phy_rx_func+0xdea>
					{							
						if (SDV_Index == 12)
80003b9a:	fe f8 02 62 	ld.w	r8,pc[610]
80003b9e:	11 88       	ld.ub	r8,r8[0x0]
80003ba0:	30 c9       	mov	r9,12
80003ba2:	f2 08 18 00 	cp.b	r8,r9
80003ba6:	e0 81 00 7b 	brne	80003c9c <phy_rx_func+0xdb8>
						{
							Soft_Decision_Data[SDV_Index]= payload_rx_channel->word[0];
80003baa:	8e 49       	ld.sh	r9,r7[0x8]
80003bac:	fe f8 02 54 	ld.w	r8,pc[596]
80003bb0:	f1 59 00 18 	st.h	r8[24],r9
							
							SDV_Index = 0;
80003bb4:	30 09       	mov	r9,0
80003bb6:	fe f8 02 46 	ld.w	r8,pc[582]
80003bba:	b0 89       	st.b	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003bbc:	ef 39 00 0d 	ld.ub	r9,r7[13]
80003bc0:	3f 38       	mov	r8,-13
80003bc2:	f0 09 18 00 	cp.b	r9,r8
80003bc6:	c6 61       	brne	80003c92 <phy_rx_func+0xdae>
							
							SDV_Index = 0;
								
							if (payload_rx_channel->byte[5] == Pre_Voice_Decoder_Data )//0xF3
							{
									Item_ID = Pre_Voice_Decoder_Data;
80003bc8:	10 99       	mov	r9,r8
80003bca:	4f c8       	lddpc	r8,80003db8 <phy_rx_func+0xed4>
80003bcc:	b0 89       	st.b	r8[0x0],r9
									RxBytesWaiting = (payload_rx_channel->byte[4] & 0x7F);//Test calculations are correct; 8
80003bce:	ef 39 00 0c 	ld.ub	r9,r7[12]
80003bd2:	f3 d9 c0 07 	bfextu	r9,r9,0x0,0x7
80003bd6:	4f 58       	lddpc	r8,80003da8 <phy_rx_func+0xec4>
80003bd8:	91 09       	st.w	r8[0x0],r9
									AMBE_rx_flag = 1;//本地作为AMBE数据的解密方
80003bda:	30 19       	mov	r9,1
80003bdc:	fe f8 02 0c 	ld.w	r8,pc[524]
80003be0:	b0 89       	st.b	r8[0x0],r9
		
									AMBEBurst_rawdata[0] = payload_rx_channel->word[3];//用于解密的中间数据变量
80003be2:	8e 79       	ld.sh	r9,r7[0xe]
80003be4:	fe f8 02 14 	ld.w	r8,pc[532]
80003be8:	b0 09       	st.h	r8[0x0],r9
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//1
80003bea:	4f 68       	lddpc	r8,80003dc0 <phy_rx_func+0xedc>
80003bec:	4e c9       	lddpc	r9,80003d9c <phy_rx_func+0xeb8>
80003bee:	72 0a       	ld.w	r10,r9[0x0]
80003bf0:	70 09       	ld.w	r9,r8[0x0]
80003bf2:	ef 3b 00 0e 	ld.ub	r11,r7[14]
80003bf6:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
80003bfa:	70 09       	ld.w	r9,r8[0x0]
80003bfc:	2f f9       	sub	r9,-1
80003bfe:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003c00:	e0 49 01 ff 	cp.w	r9,511
80003c04:	e0 88 00 13 	brls	80003c2a <phy_rx_func+0xd46>
									{
										RxAMBE_IsFillingNext8 = 0;
80003c08:	30 09       	mov	r9,0
80003c0a:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
80003c0c:	4e 46       	lddpc	r6,80003d9c <phy_rx_func+0xeb8>
80003c0e:	6c 0c       	ld.w	r12,r6[0x0]
80003c10:	f0 1f 00 6e 	mcall	80003dc8 <phy_rx_func+0xee4>
										AMBE_payload_ptr = get_payload_idle_isr();
80003c14:	4e 08       	lddpc	r8,80003d94 <phy_rx_func+0xeb0>
80003c16:	70 0c       	ld.w	r12,r8[0x0]
80003c18:	f0 1f 00 59 	mcall	80003d7c <phy_rx_func+0xe98>
80003c1c:	8d 0c       	st.w	r6[0x0],r12
										if(NULL == AMBE_payload_ptr)
80003c1e:	c0 61       	brne	80003c2a <phy_rx_func+0xd46>
										{
											RxMediaState = WAITINGABAB;
80003c20:	30 09       	mov	r9,0
80003c22:	4e 08       	lddpc	r8,80003da0 <phy_rx_func+0xebc>
80003c24:	91 09       	st.w	r8[0x0],r9
80003c26:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
80003c2a:	4e 09       	lddpc	r9,80003da8 <phy_rx_func+0xec4>
80003c2c:	72 08       	ld.w	r8,r9[0x0]
80003c2e:	20 18       	sub	r8,1
80003c30:	93 08       	st.w	r9[0x0],r8
80003c32:	c0 61       	brne	80003c3e <phy_rx_func+0xd5a>
										RxMediaState = WAITINGABAB;
80003c34:	30 09       	mov	r9,0
80003c36:	4d b8       	lddpc	r8,80003da0 <phy_rx_func+0xebc>
80003c38:	91 09       	st.w	r8[0x0],r9
80003c3a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//2
80003c3e:	4e 18       	lddpc	r8,80003dc0 <phy_rx_func+0xedc>
80003c40:	4d 79       	lddpc	r9,80003d9c <phy_rx_func+0xeb8>
80003c42:	72 0a       	ld.w	r10,r9[0x0]
80003c44:	70 09       	ld.w	r9,r8[0x0]
80003c46:	ef 3b 00 0f 	ld.ub	r11,r7[15]
80003c4a:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
80003c4e:	70 09       	ld.w	r9,r8[0x0]
80003c50:	2f f9       	sub	r9,-1
80003c52:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003c54:	e0 49 01 ff 	cp.w	r9,511
80003c58:	e0 88 00 13 	brls	80003c7e <phy_rx_func+0xd9a>
									{
										RxAMBE_IsFillingNext8 = 0;
80003c5c:	30 09       	mov	r9,0
80003c5e:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
80003c60:	4c f7       	lddpc	r7,80003d9c <phy_rx_func+0xeb8>
80003c62:	6e 0c       	ld.w	r12,r7[0x0]
80003c64:	f0 1f 00 59 	mcall	80003dc8 <phy_rx_func+0xee4>
										AMBE_payload_ptr = get_payload_idle_isr();
80003c68:	4c b8       	lddpc	r8,80003d94 <phy_rx_func+0xeb0>
80003c6a:	70 0c       	ld.w	r12,r8[0x0]
80003c6c:	f0 1f 00 44 	mcall	80003d7c <phy_rx_func+0xe98>
80003c70:	8f 0c       	st.w	r7[0x0],r12
										if(NULL == AMBE_payload_ptr)
80003c72:	c0 61       	brne	80003c7e <phy_rx_func+0xd9a>
										{
											RxMediaState = WAITINGABAB;
80003c74:	30 09       	mov	r9,0
80003c76:	4c b8       	lddpc	r8,80003da0 <phy_rx_func+0xebc>
80003c78:	91 09       	st.w	r8[0x0],r9
80003c7a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
80003c7e:	4c b9       	lddpc	r9,80003da8 <phy_rx_func+0xec4>
80003c80:	72 08       	ld.w	r8,r9[0x0]
80003c82:	20 18       	sub	r8,1
80003c84:	93 08       	st.w	r9[0x0],r8
80003c86:	c6 c1       	brne	80003d5e <phy_rx_func+0xe7a>
										RxMediaState = WAITINGABAB;
80003c88:	30 09       	mov	r9,0
80003c8a:	4c 68       	lddpc	r8,80003da0 <phy_rx_func+0xebc>
80003c8c:	91 09       	st.w	r8[0x0],r9
80003c8e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
							}
							else
							RxMediaState = WAITINGABAB;
80003c92:	30 09       	mov	r9,0
80003c94:	4c 38       	lddpc	r8,80003da0 <phy_rx_func+0xebc>
80003c96:	91 09       	st.w	r8[0x0],r9
80003c98:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
						}
						else
						{
									
							Soft_Decision_Data[SDV_Index]	  = payload_rx_channel->word[0];
80003c9c:	8e 4a       	ld.sh	r10,r7[0x8]
80003c9e:	4d 99       	lddpc	r9,80003e00 <phy_rx_func+0xf1c>
80003ca0:	f2 08 0a 1a 	st.h	r9[r8<<0x1],r10
							Soft_Decision_Data[SDV_Index+1]	  = payload_rx_channel->word[1];
80003ca4:	4d 6a       	lddpc	r10,80003dfc <phy_rx_func+0xf18>
80003ca6:	15 88       	ld.ub	r8,r10[0x0]
80003ca8:	f0 cb ff ff 	sub	r11,r8,-1
80003cac:	8e 5c       	ld.sh	r12,r7[0xa]
80003cae:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+2]	  = payload_rx_channel->word[2];
80003cb2:	f0 cb ff fe 	sub	r11,r8,-2
80003cb6:	8e 6c       	ld.sh	r12,r7[0xc]
80003cb8:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+3]	  = payload_rx_channel->word[3];
80003cbc:	f0 cb ff fd 	sub	r11,r8,-3
80003cc0:	8e 7c       	ld.sh	r12,r7[0xe]
80003cc2:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							SDV_Index +=4;
80003cc6:	2f c8       	sub	r8,-4
80003cc8:	b4 88       	st.b	r10[0x0],r8
80003cca:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					
					else
					{
						
						RxMediaState  = WAITINGABAB;
80003cce:	30 09       	mov	r9,0
80003cd0:	4b 48       	lddpc	r8,80003da0 <phy_rx_func+0xebc>
80003cd2:	91 09       	st.w	r8[0x0],r9
80003cd4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
		break;//End of READING_AMBE_MEDIA.

        case READING_AMBE_AUX:
			
				Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[0];
80003cd8:	4c 08       	lddpc	r8,80003dd8 <phy_rx_func+0xef4>
80003cda:	70 09       	ld.w	r9,r8[0x0]
80003cdc:	8e 4b       	ld.sh	r11,r7[0x8]
80003cde:	4c 0a       	lddpc	r10,80003ddc <phy_rx_func+0xef8>
80003ce0:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
				RxData_IsFillingNext16 += 1;
80003ce4:	2f f9       	sub	r9,-1
80003ce6:	91 09       	st.w	r8[0x0],r9
			
				if ((Item_Length -= 2) <= 0)
80003ce8:	4b 58       	lddpc	r8,80003dbc <phy_rx_func+0xed8>
80003cea:	70 09       	ld.w	r9,r8[0x0]
80003cec:	20 29       	sub	r9,2
80003cee:	91 09       	st.w	r8[0x0],r9
80003cf0:	70 08       	ld.w	r8,r8[0x0]
80003cf2:	58 08       	cp.w	r8,0
80003cf4:	c2 f1       	brne	80003d52 <phy_rx_func+0xe6e>
				{
					RxData_IsFillingNext16 = 0;
80003cf6:	30 09       	mov	r9,0
80003cf8:	4b 88       	lddpc	r8,80003dd8 <phy_rx_func+0xef4>
80003cfa:	91 09       	st.w	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003cfc:	8e 59       	ld.sh	r9,r7[0xa]
80003cfe:	fe 78 82 12 	mov	r8,-32238
80003d02:	f0 09 19 00 	cp.h	r9,r8
80003d06:	c2 11       	brne	80003d48 <phy_rx_func+0xe64>
					{
						//Item_ID = Vocoder_Bit_Stream_Parameter;
						//Vocoder Bits Stream Parameter
						//Its value ranges from 1 to 18 for one voice superframe contains 6 voice bursts
						// and each burst contains 3 VFs.
						VF_SN = (payload_rx_channel->byte[5] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
80003d08:	ef 3c 00 0d 	ld.ub	r12,r7[13]
80003d0c:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
80003d10:	4a f8       	lddpc	r8,80003dcc <phy_rx_func+0xee8>
80003d12:	b0 8c       	st.b	r8[0x0],r12
							
						VBSP_data[0] = payload_rx_channel->word[1];
80003d14:	8e 59       	ld.sh	r9,r7[0xa]
80003d16:	4a f8       	lddpc	r8,80003dd0 <phy_rx_func+0xeec>
80003d18:	b0 09       	st.h	r8[0x0],r9
						VBSP_data[1] = payload_rx_channel->word[2];
80003d1a:	8e 69       	ld.sh	r9,r7[0xc]
80003d1c:	b0 19       	st.h	r8[0x2],r9
							
						m_RxBurstType = CalculateBurst(VF_SN);
80003d1e:	f0 1f 00 2e 	mcall	80003dd4 <phy_rx_func+0xef0>
80003d22:	4a 18       	lddpc	r8,80003da4 <phy_rx_func+0xec0>
80003d24:	91 0c       	st.w	r8[0x0],r12
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003d26:	ef 39 00 0f 	ld.ub	r9,r7[15]
80003d2a:	31 38       	mov	r8,19
80003d2c:	f0 09 18 00 	cp.b	r9,r8
80003d30:	c0 71       	brne	80003d3e <phy_rx_func+0xe5a>
							
						m_RxBurstType = CalculateBurst(VF_SN);
						
						if (payload_rx_channel->byte[7] == Soft_Decision_Value)//0x13
						{
							Item_ID = Soft_Decision_Value;	
80003d32:	10 99       	mov	r9,r8
80003d34:	4a 18       	lddpc	r8,80003db8 <phy_rx_func+0xed4>
80003d36:	b0 89       	st.b	r8[0x0],r9
							RxBytesWaiting = ((payload_rx_channel->dword[1] & 0x00007F00) >>24);//Test calculations are correct; 26
80003d38:	30 09       	mov	r9,0
80003d3a:	49 c8       	lddpc	r8,80003da8 <phy_rx_func+0xec4>
80003d3c:	91 09       	st.w	r8[0x0],r9
						else
						{//error
								RxMediaState = WAITINGABAB;//Jump
						}
							
						RxMediaState = READING_AMBE_MEDIA;//Jump
80003d3e:	30 49       	mov	r9,4
80003d40:	49 88       	lddpc	r8,80003da0 <phy_rx_func+0xebc>
80003d42:	91 09       	st.w	r8[0x0],r9
80003d44:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					else
					{
						RxMediaState = WAITINGABAB;//Jump
80003d48:	30 09       	mov	r9,0
80003d4a:	49 68       	lddpc	r8,80003da0 <phy_rx_func+0xebc>
80003d4c:	91 09       	st.w	r8[0x0],r9
80003d4e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}

				}
				else
				{//测试看看是几个字节数据
					logFromISR("\n\r Radio Internal parameter length error \n\r");
80003d52:	4a dc       	lddpc	r12,80003e04 <phy_rx_func+0xf20>
80003d54:	f0 1f 00 18 	mcall	80003db4 <phy_rx_func+0xed0>
					RxMediaState = WAITINGABAB;//Jump
80003d58:	30 09       	mov	r9,0
80003d5a:	49 28       	lddpc	r8,80003da0 <phy_rx_func+0xebc>
80003d5c:	91 09       	st.w	r8[0x0],r9
80003d5e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80003d62:	00 00       	add	r0,r0
80003d64:	00 00       	add	r0,r0
80003d66:	0a bc       	st.h	r5++,r12
80003d68:	00 00       	add	r0,r0
80003d6a:	0a c0       	st.b	r5++,r0
80003d6c:	00 00       	add	r0,r0
80003d6e:	0a a4       	st.w	r5++,r4
80003d70:	00 00       	add	r0,r0
80003d72:	0a 80       	andn	r0,r5
80003d74:	00 00       	add	r0,r0
80003d76:	0a 78       	tst	r8,r5
80003d78:	00 00       	add	r0,r0
80003d7a:	0a b8       	st.h	r5++,r8
80003d7c:	80 00       	ld.sh	r0,r0[0x0]
80003d7e:	2d 04       	sub	r4,-48
80003d80:	00 00       	add	r0,r0
80003d82:	0a 8c       	andn	r12,r5
80003d84:	80 00       	ld.sh	r0,r0[0x0]
80003d86:	2c 34       	sub	r4,-61
80003d88:	00 00       	add	r0,r0
80003d8a:	0a 70       	tst	r0,r5
80003d8c:	80 00       	ld.sh	r0,r0[0x0]
80003d8e:	2c 50       	sub	r0,-59
80003d90:	00 00       	add	r0,r0
80003d92:	0a 89       	andn	r9,r5
80003d94:	00 00       	add	r0,r0
80003d96:	0a 74       	tst	r4,r5
80003d98:	00 00       	add	r0,r0
80003d9a:	0a a0       	st.w	r5++,r0
80003d9c:	00 00       	add	r0,r0
80003d9e:	0a 98       	mov	r8,r5
80003da0:	00 00       	add	r0,r0
80003da2:	0a d4       	st.w	--r5,r4
80003da4:	00 00       	add	r0,r0
80003da6:	0a 6c       	and	r12,r5
80003da8:	00 00       	add	r0,r0
80003daa:	0a 7c       	tst	r12,r5
80003dac:	00 00       	add	r0,r0
80003dae:	0a 46       	or	r6,r5
80003db0:	80 00       	ld.sh	r0,r0[0x0]
80003db2:	d5 18       	*unknown*
80003db4:	80 00       	ld.sh	r0,r0[0x0]
80003db6:	6f bc       	ld.w	r12,r7[0x6c]
80003db8:	00 00       	add	r0,r0
80003dba:	0a 88       	andn	r8,r5
80003dbc:	00 00       	add	r0,r0
80003dbe:	0a 94       	mov	r4,r5
80003dc0:	00 00       	add	r0,r0
80003dc2:	0a a8       	st.w	r5++,r8
80003dc4:	80 00       	ld.sh	r0,r0[0x0]
80003dc6:	77 f8       	ld.w	r8,r11[0x7c]
80003dc8:	80 00       	ld.sh	r0,r0[0x0]
80003dca:	2e 84       	sub	r4,-24
80003dcc:	00 00       	add	r0,r0
80003dce:	0a 42       	or	r2,r5
80003dd0:	00 00       	add	r0,r0
80003dd2:	1e 98       	mov	r8,pc
80003dd4:	80 00       	ld.sh	r0,r0[0x0]
80003dd6:	2b 94       	sub	r4,-71
80003dd8:	00 00       	add	r0,r0
80003dda:	0a c4       	st.b	r5++,r4
80003ddc:	00 00       	add	r0,r0
80003dde:	1d 9c       	ld.ub	r12,lr[0x1]
80003de0:	00 00       	add	r0,r0
80003de2:	0a d8       	st.w	--r5,r8
80003de4:	00 00       	add	r0,r0
80003de6:	0a 43       	or	r3,r5
80003de8:	00 00       	add	r0,r0
80003dea:	0a 41       	or	r1,r5
80003dec:	00 00       	add	r0,r0
80003dee:	0a b4       	st.h	r5++,r4
80003df0:	00 00       	add	r0,r0
80003df2:	0a 9c       	mov	r12,r5
80003df4:	00 00       	add	r0,r0
80003df6:	0a 56       	eor	r6,r5
80003df8:	00 00       	add	r0,r0
80003dfa:	1d 94       	ld.ub	r4,lr[0x1]
80003dfc:	00 00       	add	r0,r0
80003dfe:	0a cc       	st.b	r5++,r12
80003e00:	00 00       	add	r0,r0
80003e02:	1e 9c       	mov	r12,pc
80003e04:	80 00       	ld.sh	r0,r0[0x0]
80003e06:	d5 30       	acall	0x53

80003e08 <pdca_int_handler>:
    void (*phy_rx_exec)(void *)--callback function for receive SSC data 
Called By: interrupt
*/
__attribute__((__interrupt__))
static void pdca_int_handler(void)
{
80003e08:	d4 01       	pushm	lr
    
	//intStartCount = Get_system_register(AVR32_COUNT);
	
	/*Toggle Index*/
    BufferIndex ^= 0x01;
80003e0a:	49 88       	lddpc	r8,80003e68 <pdca_int_handler+0x60>
80003e0c:	11 89       	ld.ub	r9,r8[0x0]
80003e0e:	ec 19 00 01 	eorl	r9,0x1
80003e12:	b0 89       	st.b	r8[0x0],r9
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);
80003e14:	11 89       	ld.ub	r9,r8[0x0]
80003e16:	a5 69       	lsl	r9,0x4
80003e18:	2f c9       	sub	r9,-4
80003e1a:	49 5a       	lddpc	r10,80003e6c <pdca_int_handler+0x64>
80003e1c:	14 09       	add	r9,r10
	
	/*Toggle Index*/
    BufferIndex ^= 0x01;
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
80003e1e:	fe 7a 00 40 	mov	r10,-65472
80003e22:	95 39       	st.w	r10[0xc],r9
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80003e24:	30 39       	mov	r9,3
80003e26:	95 49       	st.w	r10[0x10],r9

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);
80003e28:	11 8a       	ld.ub	r10,r8[0x0]
80003e2a:	a5 6a       	lsl	r10,0x4
80003e2c:	2f ca       	sub	r10,-4
80003e2e:	49 18       	lddpc	r8,80003e70 <pdca_int_handler+0x68>
80003e30:	10 0a       	add	r10,r8
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
80003e32:	fe 78 00 00 	mov	r8,-65536
80003e36:	91 3a       	st.w	r8[0xc],r10
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80003e38:	91 49       	st.w	r8[0x10],r9
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr;
80003e3a:	70 b8       	ld.w	r8,r8[0x2c]
	
	/*receive SSC data*/
    if(phy_rx_exec != NULL)phy_rx_exec((void *)&RxBuffer[BufferIndex]);
80003e3c:	48 e8       	lddpc	r8,80003e74 <pdca_int_handler+0x6c>
80003e3e:	70 08       	ld.w	r8,r8[0x0]
80003e40:	58 08       	cp.w	r8,0
80003e42:	c0 70       	breq	80003e50 <pdca_int_handler+0x48>
80003e44:	48 99       	lddpc	r9,80003e68 <pdca_int_handler+0x60>
80003e46:	13 89       	ld.ub	r9,r9[0x0]
80003e48:	a5 69       	lsl	r9,0x4
80003e4a:	48 ac       	lddpc	r12,80003e70 <pdca_int_handler+0x68>
80003e4c:	12 0c       	add	r12,r9
80003e4e:	5d 18       	icall	r8

    /*transmit SSC data*/

	if(phy_tx_exec != NULL)phy_tx_exec((void *)&TxBuffer[BufferIndex]);//phy_tx_func, phy_rx_func
80003e50:	48 a8       	lddpc	r8,80003e78 <pdca_int_handler+0x70>
80003e52:	70 08       	ld.w	r8,r8[0x0]
80003e54:	58 08       	cp.w	r8,0
80003e56:	c0 70       	breq	80003e64 <pdca_int_handler+0x5c>
80003e58:	48 49       	lddpc	r9,80003e68 <pdca_int_handler+0x60>
80003e5a:	13 89       	ld.ub	r9,r9[0x0]
80003e5c:	a5 69       	lsl	r9,0x4
80003e5e:	48 4c       	lddpc	r12,80003e6c <pdca_int_handler+0x64>
80003e60:	12 0c       	add	r12,r9
80003e62:	5d 18       	icall	r8

	
	//intDuration = Get_system_register(AVR32_COUNT) - intStartCount;
	
	
}/*End of pdca_int_handler.*/
80003e64:	d4 02       	popm	lr
80003e66:	d6 03       	rete
80003e68:	00 00       	add	r0,r0
80003e6a:	50 bc       	stdsp	sp[0x2c],r12
80003e6c:	00 00       	add	r0,r0
80003e6e:	50 e4       	stdsp	sp[0x38],r4
80003e70:	00 00       	add	r0,r0
80003e72:	50 c4       	stdsp	sp[0x30],r4
80003e74:	00 00       	add	r0,r0
80003e76:	0a e0       	st.h	--r5,r0
80003e78:	00 00       	add	r0,r0
80003e7a:	0a e4       	st.h	--r5,r4

80003e7c <local_start_SSC>:
void local_start_SSC(void)
{
    /*Assign GPIO to SSC.
    gpio_enable_module
    gpio_enable_module_pin*/
    AVR32_GPIO.port[1].pmr0c = 0x00000DC0;
80003e7c:	fe 78 10 00 	mov	r8,-61440
80003e80:	e0 69 0d c0 	mov	r9,3520
80003e84:	f1 49 01 18 	st.w	r8[280],r9
    AVR32_GPIO.port[1].pmr1c = 0x00000DC0;
80003e88:	f1 49 01 28 	st.w	r8[296],r9
    AVR32_GPIO.port[1].gperc = 0x00000DC0;
80003e8c:	f1 49 01 08 	st.w	r8[264],r9

    /*Software reset SSC*/
    (&AVR32_SSC)->cr = AVR32_SSC_CR_SWRST_MASK;
80003e90:	fe 78 34 00 	mov	r8,-52224
80003e94:	e0 69 80 00 	mov	r9,32768
80003e98:	91 09       	st.w	r8[0x0],r9
    (&AVR32_SSC)->cmr 
80003e9a:	30 09       	mov	r9,0
80003e9c:	91 19       	st.w	r8[0x4],r9
                     = AVR32_SSC_CMR_DIV_NOT_ACTIVE << AVR32_SSC_CMR_DIV_OFFSET;

    /*For Slave*/
    (&AVR32_SSC)->tcmr =
80003e9e:	e0 69 04 21 	mov	r9,1057
80003ea2:	ea 19 3f 20 	orh	r9,0x3f20
80003ea6:	91 69       	st.w	r8[0x18],r9
	      32								<< AVR32_SSC_TCMR_STTDLY_OFFSET	|
	      63								<< AVR32_SSC_TCMR_PERIOD_OFFSET;


    /*For Slave*/
    (&AVR32_SSC)->tfmr = 
80003ea8:	e0 69 02 9f 	mov	r9,671
80003eac:	ea 19 01 00 	orh	r9,0x100
80003eb0:	91 79       	st.w	r8[0x1c],r9
	     0									<< AVR32_SSC_TFMR_FSDEN_OFFSET	|
	     1									<< AVR32_SSC_TFMR_FSEDGE_OFFSET;

	/*For Slave*/

	(&AVR32_SSC)->rcmr = 
80003eb2:	e0 6a 04 02 	mov	r10,1026
80003eb6:	ea 1a 3f 20 	orh	r10,0x3f20
80003eba:	91 4a       	st.w	r8[0x10],r10
	     0									<< AVR32_SSC_RCMR_STOP_OFFSET	|
	     32									<< AVR32_SSC_RCMR_STTDLY_OFFSET	|
	     63									<< AVR32_SSC_RCMR_PERIOD_OFFSET;

	/*For Slave*/
	(&AVR32_SSC)->rfmr = 
80003ebc:	91 59       	st.w	r8[0x14],r9
	    1									<< AVR32_SSC_RFMR_MSBF_OFFSET	|
	    2									<< AVR32_SSC_RFMR_DATNB_OFFSET	|
	    0									<< AVR32_SSC_RFMR_FSLEN_OFFSET	|
	    AVR32_SSC_RFMR_FSOS_INPUT_ONLY		<< AVR32_SSC_RFMR_FSOS_OFFSET	|
	    1									<< AVR32_SSC_RFMR_FSEDGE_OFFSET;
}/*End of local_start_SSC.*/
80003ebe:	5e fc       	retal	r12

80003ec0 <local_start_PDC>:
Function: local_start_PDC
Description: none
Called By: void ssc_init(void) -- ssc.c
*/
void local_start_PDC(void)
{
80003ec0:	d4 01       	pushm	lr
    /*Toggle Index*/	
    BufferIndex = 1;
80003ec2:	30 19       	mov	r9,1
80003ec4:	49 78       	lddpc	r8,80003f20 <local_start_PDC+0x60>
80003ec6:	b0 89       	st.b	r8[0x0],r9
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
80003ec8:	fe 78 00 00 	mov	r8,-65536
80003ecc:	30 7b       	mov	r11,7
80003ece:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
80003ed0:	70 b9       	ld.w	r9,r8[0x2c]
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
80003ed2:	49 59       	lddpc	r9,80003f24 <local_start_PDC+0x64>
80003ed4:	f2 ca ff fc 	sub	r10,r9,-4
    BufferIndex = 1;
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
80003ed8:	91 0a       	st.w	r8[0x0],r10
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
80003eda:	30 3a       	mov	r10,3
80003edc:	91 2a       	st.w	r8[0x8],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
80003ede:	30 1c       	mov	r12,1
80003ee0:	91 1c       	st.w	r8[0x4],r12
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
80003ee2:	2e c9       	sub	r9,-20
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
80003ee4:	91 39       	st.w	r8[0xc],r9
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80003ee6:	91 4a       	st.w	r8[0x10],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80003ee8:	30 2c       	mov	r12,2
80003eea:	91 6c       	st.w	r8[0x18],r12

	TxBuffer[0].xnl_channel.dword = XNL_IDLE;
80003eec:	48 f9       	lddpc	r9,80003f28 <local_start_PDC+0x68>
80003eee:	e0 68 5a 5a 	mov	r8,23130
80003ef2:	ea 18 ab cd 	orh	r8,0xabcd
80003ef6:	93 18       	st.w	r9[0x4],r8
	TxBuffer[0].payload_channel.dword[0] = PAYLOADIDLE0;
80003ef8:	93 28       	st.w	r9[0x8],r8
	TxBuffer[0].payload_channel.dword[1] = PAYLOADIDLE1;
80003efa:	30 0e       	mov	lr,0
80003efc:	93 3e       	st.w	r9[0xc],lr
	TxBuffer[1].xnl_channel.dword = XNL_IDLE;
80003efe:	93 58       	st.w	r9[0x14],r8
	TxBuffer[1].payload_channel.dword[0] = PAYLOADIDLE0;
80003f00:	93 68       	st.w	r9[0x18],r8
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;
80003f02:	93 7e       	st.w	r9[0x1c],lr

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
80003f04:	fe 78 00 40 	mov	r8,-65472
80003f08:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
80003f0a:	70 be       	ld.w	lr,r8[0x2c]
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
80003f0c:	f2 ce ff fc 	sub	lr,r9,-4
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
80003f10:	91 0e       	st.w	r8[0x0],lr
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
80003f12:	91 2a       	st.w	r8[0x8],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
80003f14:	91 1b       	st.w	r8[0x4],r11
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
80003f16:	2e c9       	sub	r9,-20
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
80003f18:	91 39       	st.w	r8[0xc],r9
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80003f1a:	91 4a       	st.w	r8[0x10],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80003f1c:	91 6c       	st.w	r8[0x18],r12
}/*End of local_start_PDC.*/
80003f1e:	d8 02       	popm	pc
80003f20:	00 00       	add	r0,r0
80003f22:	50 bc       	stdsp	sp[0x2c],r12
80003f24:	00 00       	add	r0,r0
80003f26:	50 c4       	stdsp	sp[0x30],r4
80003f28:	00 00       	add	r0,r0
80003f2a:	50 e4       	stdsp	sp[0x38],r4

80003f2c <register_rx_tx_func>:
Description: register the rx function(callback function)
Called By: phy_init -- physical.c
*/
void register_rx_tx_func(void (*rx_exec)(void *),  void ( *tx_exec)(void *))
{
	 phy_rx_exec = rx_exec;
80003f2c:	48 38       	lddpc	r8,80003f38 <register_rx_tx_func+0xc>
80003f2e:	91 0c       	st.w	r8[0x0],r12
	 phy_tx_exec = tx_exec;//phy_tx_func, phy_rx_func
80003f30:	48 38       	lddpc	r8,80003f3c <register_rx_tx_func+0x10>
80003f32:	91 0b       	st.w	r8[0x0],r11
	 
}/*End of register_tx_rx_func.*/
80003f34:	5e fc       	retal	r12
80003f36:	00 00       	add	r0,r0
80003f38:	00 00       	add	r0,r0
80003f3a:	0a e0       	st.h	--r5,r0
80003f3c:	00 00       	add	r0,r0
80003f3e:	0a e4       	st.h	--r5,r4

80003f40 <ssc_init>:
    local_start_SSC -- ssc.c
    local_start_PDC -- ssc.c
Called By: phy_init -- physical.c
*/
void ssc_init(void)
{		
80003f40:	d4 01       	pushm	lr
    /*Set up PB01 to watch FS.*/
    AVR32_GPIO.port[1].oderc = 0x00000002;
80003f42:	fe 78 10 00 	mov	r8,-61440
80003f46:	30 29       	mov	r9,2
80003f48:	f1 49 01 48 	st.w	r8[328],r9
    AVR32_GPIO.port[1].gpers = 0x00000002;
80003f4c:	f1 49 01 04 	st.w	r8[260],r9
	
	INTC_register_interrupt (
80003f50:	30 3a       	mov	r10,3
80003f52:	36 0b       	mov	r11,96
80003f54:	49 3c       	lddpc	r12,80003fa0 <ssc_init+0x60>
80003f56:	f0 1f 00 14 	mcall	80003fa4 <ssc_init+0x64>
	&pdca_int_handler
	, AVR32_PDCA_IRQ_0
	, AVR32_INTC_INT3
	);
	
	Enable_global_interrupt();
80003f5a:	d5 03       	csrf	0x10
	
    /*Waits for radio to start making FSYNC.*/
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
80003f5c:	fe 79 10 00 	mov	r9,-61440
80003f60:	f2 f8 01 60 	ld.w	r8,r9[352]
80003f64:	e2 18 00 02 	andl	r8,0x2,COH
80003f68:	cf c0       	breq	80003f60 <ssc_init+0x20>
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
80003f6a:	fe 79 10 00 	mov	r9,-61440
80003f6e:	f2 f8 01 60 	ld.w	r8,r9[352]
80003f72:	e2 18 00 02 	andl	r8,0x2,COH
80003f76:	cf c1       	brne	80003f6e <ssc_init+0x2e>
			
	Disable_global_interrupt(); // resume to before
80003f78:	d3 03       	ssrf	0x10
				
    /*config the SSC*/
    local_start_SSC();
80003f7a:	f0 1f 00 0c 	mcall	80003fa8 <ssc_init+0x68>

    /*config the PDCA*/
    local_start_PDC();
80003f7e:	f0 1f 00 0c 	mcall	80003fac <ssc_init+0x6c>
		
    /*Start the SSC Physical Layer.*/

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80003f82:	fe 79 00 00 	mov	r9,-65536
80003f86:	30 18       	mov	r8,1
80003f88:	93 58       	st.w	r9[0x14],r8
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80003f8a:	fe 7a 00 40 	mov	r10,-65472
80003f8e:	95 58       	st.w	r10[0x14],r8
    (&AVR32_SSC)->cr = AVR32_SSC_CR_RXEN_MASK | AVR32_SSC_CR_TXEN_MASK;
80003f90:	e0 6b 01 01 	mov	r11,257
80003f94:	fe 7a 34 00 	mov	r10,-52224
80003f98:	95 0b       	st.w	r10[0x0],r11
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->ier = AVR32_PDCA_RCZ_MASK;
80003f9a:	93 88       	st.w	r9[0x20],r8
															
	Enable_global_interrupt();
80003f9c:	d5 03       	csrf	0x10
															
}/*End of ssc_init.*/
80003f9e:	d8 02       	popm	pc
80003fa0:	80 00       	ld.sh	r0,r0[0x0]
80003fa2:	3e 08       	mov	r8,-32
80003fa4:	80 00       	ld.sh	r0,r0[0x0]
80003fa6:	54 40       	stdsp	sp[0x110],r0
80003fa8:	80 00       	ld.sh	r0,r0[0x0]
80003faa:	3e 7c       	mov	r12,-25
80003fac:	80 00       	ld.sh	r0,r0[0x0]
80003fae:	3e c0       	mov	r0,-20

80003fb0 <xcmp_register_app_list>:
Calls: 
Called By: app_init -- app.c
*/
void xcmp_register_app_list(void * list)
{
	app_list = (app_exec_t *)list;
80003fb0:	48 28       	lddpc	r8,80003fb8 <xcmp_register_app_list+0x8>
80003fb2:	91 0c       	st.w	r8[0x0],r12
}
80003fb4:	5e fc       	retal	r12
80003fb6:	00 00       	add	r0,r0
80003fb8:	00 00       	add	r0,r0
80003fba:	51 04       	stdsp	sp[0x40],r4

80003fbc <xcmp_tx>:
Calls:   
	xnl_tx -- xnl.c
Called By: ...
*/
static void xcmp_tx( xcmp_fragment_t * xcmp, U8 payload_len)
{
80003fbc:	eb cd 40 80 	pushm	r7,lr
80003fc0:	fa cd 01 00 	sub	sp,sp,256
80003fc4:	16 97       	mov	r7,r11
	Length :xnl length + checksum
	= checksum + xnl header + xcmp opcode + xcmp payload
	= 0x02 + 0x0C + 0x02 + xcmp payload
	= 0x10 + xcmp payload
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | ( 0x10 + payload_len);
80003fc6:	16 98       	mov	r8,r11
80003fc8:	2f 08       	sub	r8,-16
80003fca:	af a8       	sbr	r8,0xe
80003fcc:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE; 
80003fce:	3f f8       	mov	r8,-1
80003fd0:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG;
80003fd2:	30 b9       	mov	r9,11
80003fd4:	ba 29       	st.h	sp[0x4],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;	
80003fd6:	ba 38       	st.h	sp[0x6],r8
	xnl_frame.xnl_header.destination = DEFAULT_VALUE;
80003fd8:	ba 48       	st.h	sp[0x8],r8
	xnl_frame.xnl_header.source = DEFAULT_VALUE;	
80003fda:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80003fdc:	ba 68       	st.h	sp[0xc],r8
	
	/*insert xcmp frame data*/
	memcpy(&xnl_frame.xnl_payload.xnl_content_data_msg, xcmp, payload_len + 2);
80003fde:	f6 ca ff fe 	sub	r10,r11,-2
80003fe2:	18 9b       	mov	r11,r12
80003fe4:	fa cc ff f0 	sub	r12,sp,-16
80003fe8:	f0 1f 00 05 	mcall	80003ffc <xcmp_tx+0x40>
	xnl_frame.xnl_header.payload_length = payload_len + 2;	
80003fec:	2f e7       	sub	r7,-2
80003fee:	ba 77       	st.h	sp[0xe],r7
	
	/* send xnl frame*/	
	xnl_tx(&xnl_frame);
80003ff0:	1a 9c       	mov	r12,sp
80003ff2:	f0 1f 00 04 	mcall	80004000 <xcmp_tx+0x44>
}
80003ff6:	2c 0d       	sub	sp,-256
80003ff8:	e3 cd 80 80 	ldm	sp++,r7,pc
80003ffc:	80 00       	ld.sh	r0,r0[0x0]
80003ffe:	76 b0       	ld.w	r0,r11[0x2c]
80004000:	80 00       	ld.sh	r0,r0[0x0]
80004002:	45 c8       	lddsp	r8,sp[0x170]

80004004 <xcmp_data_session_req>:
Description: send data-session request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_data_session_req(void *message, U16 length, U8 dest)
{
80004004:	d4 21       	pushm	r4-r7,lr
80004006:	fa cd 00 d0 	sub	sp,sp,208
8000400a:	18 94       	mov	r4,r12
8000400c:	16 97       	mov	r7,r11
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
	
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
	
	if (length > 256)return -1;
8000400e:	e0 68 01 00 	mov	r8,256
80004012:	f0 0b 19 00 	cp.h	r11,r8
80004016:	e0 8b 00 36 	brhi	80004082 <xcmp_data_session_req+0x7e>
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
	
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
8000401a:	fa c5 ff f8 	sub	r5,sp,-8
	//U8 SizeofAddress = Remote_Mototrbo_Address_Size;// 3;//可能会变化
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
8000401e:	e0 68 04 1d 	mov	r8,1053
80004022:	ba 38       	st.h	sp[0x6],r8
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
	
	if (length > 256)return -1;
	
	ptr->Function = Single_Data_Uint;
80004024:	30 18       	mov	r8,1
80004026:	aa 88       	st.b	r5[0x0],r8
	
	ptr->DataDefinition.Data_Protocol_Version = TMP_Ver_1_1;//0x20
80004028:	32 08       	mov	r8,32
8000402a:	aa 98       	st.b	r5[0x1],r8
	
	ptr->DataDefinition.Dest_Address.Remote_Address_Type = Remote_IPV4_Address;//0x02
8000402c:	30 28       	mov	r8,2
8000402e:	aa a8       	st.b	r5[0x2],r8
	
	ptr->DataDefinition.Dest_Address.Remote_Address_Size = Remote_IPV4_Address_Size;//0x04
80004030:	30 48       	mov	r8,4
80004032:	aa b8       	st.b	r5[0x3],r8
	
	unsigned int addr = 0x0C000000 | (dest & 0x00FFFFFF);
80004034:	ea 1a 0c 00 	orh	r10,0xc00
80004038:	50 0a       	stdsp	sp[0x0],r10
	memcpy(ptr->DataDefinition.Dest_Address.Remote_Address, &addr, Remote_IPV4_Address_Size);
8000403a:	30 4a       	mov	r10,4
8000403c:	1a 9b       	mov	r11,sp
8000403e:	fa cc ff f4 	sub	r12,sp,-12
80004042:	f0 1f 00 12 	mcall	80004088 <xcmp_data_session_req+0x84>
	//ptr->DataDefinition.Dest_Address.Remote_Address[0] = 0x0C;//12
	//ptr->DataDefinition.Dest_Address.Remote_Address[1] = 0x00;//0
	//ptr->DataDefinition.Dest_Address.Remote_Address[2] = 0x00;//0
	//ptr->DataDefinition.Dest_Address.Remote_Address[3] = 0x02;//2
	
	ptr->DataDefinition.Dest_Address.Remote_Port_Com[0] = (Remote_Port >>8) & 0xFF;//4007
80004046:	30 f8       	mov	r8,15
80004048:	eb 68 00 08 	st.b	r5[8],r8
	ptr->DataDefinition.Dest_Address.Remote_Port_Com[1] = Remote_Port & 0xFF;//
8000404c:	3a 78       	mov	r8,-89
8000404e:	eb 68 00 09 	st.b	r5[9],r8
	
    
	ptr->DataPayload.Session_ID_Number = Session_ID;//0x00
80004052:	30 08       	mov	r8,0
80004054:	eb 68 00 0a 	st.b	r5[10],r8
	
	ptr->DataPayload.DataPayload_Length[0] =(length >> 8) & 0xFF ;//可能会变化
80004058:	0e 9a       	mov	r10,r7
8000405a:	5c 7a       	castu.h	r10
8000405c:	f4 08 16 08 	lsr	r8,r10,0x8
80004060:	eb 68 00 0b 	st.b	r5[11],r8
	ptr->DataPayload.DataPayload_Length[1] =length & 0xFF  ;//可能会变化
80004064:	0e 96       	mov	r6,r7
80004066:	eb 67 00 0c 	st.b	r5[12],r7
	
	memcpy(&(ptr->DataPayload.DataPayload[0]), message, length);
8000406a:	08 9b       	mov	r11,r4
8000406c:	fa cc ff eb 	sub	r12,sp,-21
80004070:	f0 1f 00 06 	mcall	80004088 <xcmp_data_session_req+0x84>
	
	xcmp_tx(&xcmp_farme, sizeof(DataSession_req_t) - (256 - length));
80004074:	ee cb ff f3 	sub	r11,r7,-13
80004078:	5c 5b       	castu.b	r11
8000407a:	fa cc ff fa 	sub	r12,sp,-6
8000407e:	f0 1f 00 04 	mcall	8000408c <xcmp_data_session_req+0x88>
}
80004082:	2c cd       	sub	sp,-208
80004084:	d8 22       	popm	r4-r7,pc
80004086:	00 00       	add	r0,r0
80004088:	80 00       	ld.sh	r0,r0[0x0]
8000408a:	76 b0       	ld.w	r0,r11[0x2c]
8000408c:	80 00       	ld.sh	r0,r0[0x0]
8000408e:	3f bc       	mov	r12,-5

80004090 <xcmp_DeviceInitializationStatus_request>:
Description: send device initialization status request
Calls: xcmp_tx
Called By:...
*/
void xcmp_DeviceInitializationStatus_request(void)
{
80004090:	d4 01       	pushm	lr
80004092:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
		
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_BRDCAST | DEVICE_INITIALIZATION_STATUS;
80004096:	fe 78 b4 00 	mov	r8,-19456
8000409a:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	DeviceInitializationStatus_brdcst_t * ptr 
						 = (DeviceInitializationStatus_brdcst_t *)xcmp_farme.u8;
8000409c:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*xcmp version 8.1.0.5*///版本号未正确填写，纠正
	ptr->XCMPVersion[0] = 0x08;
800040a0:	30 89       	mov	r9,8
800040a2:	b0 89       	st.b	r8[0x0],r9
	ptr->XCMPVersion[1] = 0x01;
800040a4:	30 19       	mov	r9,1
800040a6:	b0 99       	st.b	r8[0x1],r9
	ptr->XCMPVersion[2] = 0x00;
800040a8:	30 09       	mov	r9,0
800040aa:	b0 a9       	st.b	r8[0x2],r9
	ptr->XCMPVersion[3] = 0x05;
800040ac:	30 5a       	mov	r10,5
800040ae:	b0 ba       	st.b	r8[0x3],r10
	/*
	0x00:
	This is the message that the device sends at power up or after a reset. It 
	will give the initial status and capabilities for the device.
	*/
	ptr->DeviceInitType = 0x00;
800040b0:	b0 c9       	st.b	r8[0x4],r9
	types of devices may provide a set of services to the radio system, but do 
	not have the ability to be the master.
	
	0x07:OptionBoard,3rd party Option Board-based application.
	*/
	ptr->DeviceStatusInfo.DeviceType = 0x07;
800040b2:	30 7a       	mov	r10,7
800040b4:	b0 da       	st.b	r8[0x5],r10
	
	/*Power Up Success, Device has powered up with no errors*/
	ptr->DeviceStatusInfo.DeviceStatus[0] = 0x00;
800040b6:	b0 e9       	st.b	r8[0x6],r9
	ptr->DeviceStatusInfo.DeviceStatus[1] = 0x00;
800040b8:	b0 f9       	st.b	r8[0x7],r9
	
	/*
	This number is the size of the Device Descriptor data structure with a 
	maximum size not exceeding 255 bytes.
	*/
	ptr->DeviceStatusInfo.DeviceDescriptorSize = 0x00;
800040ba:	f1 69 00 08 	st.b	r8[8],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme
800040be:	30 9b       	mov	r11,9
800040c0:	fa cc ff fe 	sub	r12,sp,-2
800040c4:	f0 1f 00 02 	mcall	800040cc <xcmp_DeviceInitializationStatus_request+0x3c>
		, sizeof(DeviceInitializationStatus_brdcst_t) - MAX_DEVICE_DESC_SIZE);
}
800040c8:	2c dd       	sub	sp,-204
800040ca:	d8 02       	popm	pc
800040cc:	80 00       	ld.sh	r0,r0[0x0]
800040ce:	3f bc       	mov	r12,-5

800040d0 <xcmp_opcode_not_supported>:
Description: register the app list
Calls: xcmp_tx
Called By:...
*/
void xcmp_opcode_not_supported( void )
{
800040d0:	d4 01       	pushm	lr
800040d2:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REPLY;
800040d6:	fe 78 80 00 	mov	r8,-32768
800040da:	ba 18       	st.h	sp[0x2],r8
	
	/*The radio does not support this opcode.*/
	xcmp_farme.u8[0] = xcmp_Res_Opcode_Not_Supported;
800040dc:	30 38       	mov	r8,3
800040de:	ba c8       	st.b	sp[0x4],r8
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, 1);
800040e0:	30 1b       	mov	r11,1
800040e2:	fa cc ff fe 	sub	r12,sp,-2
800040e6:	f0 1f 00 03 	mcall	800040f0 <xcmp_opcode_not_supported+0x20>
}
800040ea:	2c dd       	sub	sp,-204
800040ec:	d8 02       	popm	pc
800040ee:	00 00       	add	r0,r0
800040f0:	80 00       	ld.sh	r0,r0[0x0]
800040f2:	3f bc       	mov	r12,-5

800040f4 <xcmp_exec_func>:
Description: Perform XCMP corresponding functions
Calls:   
Called By: xcmp_rx_process--task
*/
static void xcmp_exec_func(app_exec_t * exec, xcmp_fragment_t * xcmp)
{
800040f4:	d4 01       	pushm	lr
	/*The message types*/
	switch(xcmp->xcmp_opcode & 0xF000)
800040f6:	96 88       	ld.uh	r8,r11[0x0]
800040f8:	e2 18 f0 00 	andl	r8,0xf000,COH
800040fc:	e0 48 80 00 	cp.w	r8,32768
80004100:	c0 f0       	breq	8000411e <xcmp_exec_func+0x2a>
80004102:	e0 48 b0 00 	cp.w	r8,45056
80004106:	c1 20       	breq	8000412a <xcmp_exec_func+0x36>
80004108:	58 08       	cp.w	r8,0
8000410a:	c1 51       	brne	80004134 <xcmp_exec_func+0x40>
	{
		case XCMP_REQUEST:
			if(NULL != exec->xcmp_rx_req)
8000410c:	78 08       	ld.w	r8,r12[0x0]
8000410e:	58 08       	cp.w	r8,0
80004110:	c0 40       	breq	80004118 <xcmp_exec_func+0x24>
			{
				exec->xcmp_rx_req(xcmp);
80004112:	16 9c       	mov	r12,r11
80004114:	5d 18       	icall	r8
80004116:	d8 02       	popm	pc
			}
			else 
			{
				/*No function to register the request message*/
				/*send not supported opcode to raido */
				xcmp_opcode_not_supported();
80004118:	f0 1f 00 08 	mcall	80004138 <xcmp_exec_func+0x44>
8000411c:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_REPLY:		
			if(NULL != exec->xcmp_rx_reply)
8000411e:	78 18       	ld.w	r8,r12[0x4]
80004120:	58 08       	cp.w	r8,0
80004122:	c0 90       	breq	80004134 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_reply(xcmp);
80004124:	16 9c       	mov	r12,r11
80004126:	5d 18       	icall	r8
80004128:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_BRDCAST:	
			if(NULL != exec->xcmp_rx_brdcst)
8000412a:	78 28       	ld.w	r8,r12[0x8]
8000412c:	58 08       	cp.w	r8,0
8000412e:	c0 30       	breq	80004134 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_brdcst(xcmp);
80004130:	16 9c       	mov	r12,r11
80004132:	5d 18       	icall	r8
80004134:	d8 02       	popm	pc
80004136:	00 00       	add	r0,r0
80004138:	80 00       	ld.sh	r0,r0[0x0]
8000413a:	40 d0       	lddsp	r0,sp[0x34]

8000413c <xcmp_IdleTestTone>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_IdleTestTone(U8 type, U16 toneID)
{
8000413c:	d4 01       	pushm	lr
8000413e:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | TONE_CONTROL;
80004142:	e0 68 04 09 	mov	r8,1033
80004146:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	ToneControl_req_t * ptr = (ToneControl_req_t *)xcmp_farme.u8;
80004148:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*Starts the specific tone*/	
	ptr->Function = type;
8000414c:	b0 8c       	st.b	r8[0x0],r12
	
	/*This tone shall be sounded when radio landed on a priority channel*/
	//ptr->ToneIdentifier[0] = (Priority_Beep >> 8) & 0xFF;
	//ptr->ToneIdentifier[1] = Priority_Beep & 0xFF;
	
	ptr->ToneIdentifier[0] = (toneID >> 8) & 0xFF;
8000414e:	f3 db c1 08 	bfextu	r9,r11,0x8,0x8
80004152:	b0 99       	st.b	r8[0x1],r9
	ptr->ToneIdentifier[1] = toneID & 0xFF;	
80004154:	b0 ab       	st.b	r8[0x2],r11
	
	/*
	The alert tone is played according to any rules for alert tones, given the 
	current volume setting. Settings for this field are 8 to 255 (0x08 ?0xFF).
	*/
	ptr->ToneVolumeControl = Current_Volume;
80004156:	30 09       	mov	r9,0
80004158:	b0 b9       	st.b	r8[0x3],r9
	
	/*clear reserved*/
	memset(ptr->Reserved, 0, 8);
8000415a:	fb 69 00 08 	st.b	sp[8],r9
8000415e:	fa c8 ff f7 	sub	r8,sp,-9
80004162:	b0 89       	st.b	r8[0x0],r9
80004164:	fa c8 ff f6 	sub	r8,sp,-10
80004168:	b0 89       	st.b	r8[0x0],r9
8000416a:	fa c8 ff f5 	sub	r8,sp,-11
8000416e:	b0 89       	st.b	r8[0x0],r9
80004170:	fa c8 ff f4 	sub	r8,sp,-12
80004174:	b0 89       	st.b	r8[0x0],r9
80004176:	fa c8 ff f3 	sub	r8,sp,-13
8000417a:	b0 89       	st.b	r8[0x0],r9
8000417c:	fa c8 ff f2 	sub	r8,sp,-14
80004180:	b0 89       	st.b	r8[0x0],r9
80004182:	fa c8 ff f1 	sub	r8,sp,-15
80004186:	b0 89       	st.b	r8[0x0],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(ToneControl_req_t));
80004188:	30 cb       	mov	r11,12
8000418a:	fa cc ff fe 	sub	r12,sp,-2
8000418e:	f0 1f 00 03 	mcall	80004198 <xcmp_IdleTestTone+0x5c>
}
80004192:	2c dd       	sub	sp,-204
80004194:	d8 02       	popm	pc
80004196:	00 00       	add	r0,r0
80004198:	80 00       	ld.sh	r0,r0[0x0]
8000419a:	3f bc       	mov	r12,-5

8000419c <xcmp_init>:
	xQueueCreate -- freertos
	xTaskCreate -- freertos
Called By: main -- main.c
*/
void xcmp_init(void)
{
8000419c:	d4 01       	pushm	lr
	/*register the xcmp function(callback function)*/
	xnl_register_xcmp_func( xcmp_rx );
8000419e:	48 dc       	lddpc	r12,800041d0 <xcmp_init+0x34>
800041a0:	f0 1f 00 0d 	mcall	800041d4 <xcmp_init+0x38>
	
	/*initialize the queue*/
	xcmp_frame_rx = xQueueCreate(20, sizeof(xcmp_fragment_t *));
800041a4:	30 4b       	mov	r11,4
800041a6:	31 4c       	mov	r12,20
800041a8:	f0 1f 00 0c 	mcall	800041d8 <xcmp_init+0x3c>
800041ac:	48 c8       	lddpc	r8,800041dc <xcmp_init+0x40>
800041ae:	91 0c       	st.w	r8[0x0],r12
	/*create task*/	
	/*this task is used to execute xcmp message*/
	xTaskCreate(
800041b0:	30 09       	mov	r9,0
800041b2:	1a d9       	st.w	--sp,r9
800041b4:	1a d9       	st.w	--sp,r9
800041b6:	1a d9       	st.w	--sp,r9
800041b8:	30 38       	mov	r8,3
800041ba:	e0 6a 01 80 	mov	r10,384
800041be:	48 9b       	lddpc	r11,800041e0 <xcmp_init+0x44>
800041c0:	48 9c       	lddpc	r12,800041e4 <xcmp_init+0x48>
800041c2:	f0 1f 00 0a 	mcall	800041e8 <xcmp_init+0x4c>
	,  tskXCMP_PRIORITY
	,  NULL
	);
	
	/*initialize the xnl*/
	xnl_init();
800041c6:	f0 1f 00 0a 	mcall	800041ec <xcmp_init+0x50>
800041ca:	2f dd       	sub	sp,-12
	
}
800041cc:	d8 02       	popm	pc
800041ce:	00 00       	add	r0,r0
800041d0:	80 00       	ld.sh	r0,r0[0x0]
800041d2:	42 ec       	lddsp	r12,sp[0xb8]
800041d4:	80 00       	ld.sh	r0,r0[0x0]
800041d6:	43 38       	lddsp	r8,sp[0xcc]
800041d8:	80 00       	ld.sh	r0,r0[0x0]
800041da:	63 50       	ld.w	r0,r1[0x54]
800041dc:	00 00       	add	r0,r0
800041de:	0b 00       	ld.w	r0,r5++
800041e0:	80 00       	ld.sh	r0,r0[0x0]
800041e2:	d5 5c       	*unknown*
800041e4:	80 00       	ld.sh	r0,r0[0x0]
800041e6:	41 f0       	lddsp	r0,sp[0x7c]
800041e8:	80 00       	ld.sh	r0,r0[0x0]
800041ea:	6a 6c       	ld.w	r12,r5[0x18]
800041ec:	80 00       	ld.sh	r0,r0[0x0]
800041ee:	43 70       	lddsp	r0,sp[0xdc]

800041f0 <xcmp_rx_process>:
Calls: xQueueReceive -- freerots
	xcmp_exec_func
Called By: task
*/
static void xcmp_rx_process(void * pvParameters)
{
800041f0:	d4 31       	pushm	r0-r7,lr
800041f2:	20 1d       	sub	sp,4
	xcmp_fragment_t xcmp;
	xcmp_fragment_t * ptr;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
800041f4:	4b 16       	lddpc	r6,800042b8 <xcmp_rx_process+0xc8>
800041f6:	30 05       	mov	r5,0
800041f8:	31 44       	mov	r4,20
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
800041fa:	4b 13       	lddpc	r3,800042bc <xcmp_rx_process+0xcc>
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
					break;
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
800041fc:	4b 12       	lddpc	r2,800042c0 <xcmp_rx_process+0xd0>
						, ptr);
					break;
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
800041fe:	4b 21       	lddpc	r1,800042c4 <xcmp_rx_process+0xd4>
					break;
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
80004200:	4b 20       	lddpc	r0,800042c8 <xcmp_rx_process+0xd8>
	xcmp_fragment_t xcmp;
	xcmp_fragment_t * ptr;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
80004202:	6c 0c       	ld.w	r12,r6[0x0]
80004204:	0a 99       	mov	r9,r5
80004206:	08 9a       	mov	r10,r4
80004208:	1a 9b       	mov	r11,sp
8000420a:	f0 1f 00 31 	mcall	800042cc <xcmp_rx_process+0xdc>
8000420e:	58 1c       	cp.w	r12,1
80004210:	cf 91       	brne	80004202 <xcmp_rx_process+0x12>
		{									
			if(NULL == ptr)
80004212:	40 0b       	lddsp	r11,sp[0x0]
80004214:	58 0b       	cp.w	r11,0
80004216:	cf 60       	breq	80004202 <xcmp_rx_process+0x12>
				continue;
			}
			
			//log("\n\r R_xcmp : %4x \n\r",ptr->xcmp_opcode);//log:R_xcmp指令	
						
			switch(ptr->xcmp_opcode & 0x0FFF)
80004218:	96 0a       	ld.sh	r10,r11[0x0]
8000421a:	f3 da c0 10 	bfextu	r9,r10,0x0,0x10
8000421e:	f1 d9 c0 0c 	bfextu	r8,r9,0x0,0xc
80004222:	59 c8       	cp.w	r8,28
80004224:	c1 e0       	breq	80004260 <xcmp_rx_process+0x70>
80004226:	e0 89 00 07 	brgt	80004234 <xcmp_rx_process+0x44>
8000422a:	58 e8       	cp.w	r8,14
8000422c:	c0 e0       	breq	80004248 <xcmp_rx_process+0x58>
8000422e:	58 f8       	cp.w	r8,15
80004230:	c2 41       	brne	80004278 <xcmp_rx_process+0x88>
80004232:	c0 f8       	rjmp	80004250 <xcmp_rx_process+0x60>
80004234:	e0 48 01 09 	cp.w	r8,265
80004238:	c1 80       	breq	80004268 <xcmp_rx_process+0x78>
8000423a:	e0 48 01 0a 	cp.w	r8,266
8000423e:	c1 90       	breq	80004270 <xcmp_rx_process+0x80>
80004240:	e0 48 00 2c 	cp.w	r8,44
80004244:	c1 a1       	brne	80004278 <xcmp_rx_process+0x88>
80004246:	c0 98       	rjmp	80004258 <xcmp_rx_process+0x68>
			{
				case RADIO_STATUS:				
					xcmp_exec_func(&radio_status, ptr);
80004248:	4a 2c       	lddpc	r12,800042d0 <xcmp_rx_process+0xe0>
8000424a:	f0 1f 00 23 	mcall	800042d4 <xcmp_rx_process+0xe4>
					break;
8000424e:	c2 f8       	rjmp	800042ac <xcmp_rx_process+0xbc>
					
				case VERSION_INFORMATION:
					xcmp_exec_func(&version_information, ptr);
80004250:	4a 2c       	lddpc	r12,800042d8 <xcmp_rx_process+0xe8>
80004252:	f0 1f 00 21 	mcall	800042d4 <xcmp_rx_process+0xe4>
					break;
80004256:	c2 b8       	rjmp	800042ac <xcmp_rx_process+0xbc>
					
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
80004258:	4a 1c       	lddpc	r12,800042dc <xcmp_rx_process+0xec>
8000425a:	f0 1f 00 1f 	mcall	800042d4 <xcmp_rx_process+0xe4>
					break;
8000425e:	c2 78       	rjmp	800042ac <xcmp_rx_process+0xbc>
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
80004260:	04 9c       	mov	r12,r2
80004262:	f0 1f 00 1d 	mcall	800042d4 <xcmp_rx_process+0xe4>
						, ptr);
					break;
80004266:	c2 38       	rjmp	800042ac <xcmp_rx_process+0xbc>
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
80004268:	02 9c       	mov	r12,r1
8000426a:	f0 1f 00 1b 	mcall	800042d4 <xcmp_rx_process+0xe4>
					break;
8000426e:	c1 f8       	rjmp	800042ac <xcmp_rx_process+0xbc>
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
80004270:	00 9c       	mov	r12,r0
80004272:	f0 1f 00 19 	mcall	800042d4 <xcmp_rx_process+0xe4>
					break;
80004276:	c1 b8       	rjmp	800042ac <xcmp_rx_process+0xbc>
					
				default:
				
					/*the xcmp message not in order list*/
					/*over the length of the list*/
					if((0x0400 != (ptr->xcmp_opcode & 0x0400)) 
80004278:	12 98       	mov	r8,r9
8000427a:	e2 18 04 00 	andl	r8,0x400,COH
8000427e:	c0 70       	breq	8000428c <xcmp_rx_process+0x9c>
80004280:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
80004284:	e0 48 00 68 	cp.w	r8,104
80004288:	e0 8a 00 08 	brle	80004298 <xcmp_rx_process+0xa8>
						|| (MAX_APP_FUNC <= (ptr->xcmp_opcode & 0x00FF))
					)
					{
						/*xcmp request*/
						if( XCMP_REQUEST == (ptr->xcmp_opcode & 0xF000))
8000428c:	e2 19 f0 00 	andl	r9,0xf000,COH
80004290:	c0 e1       	brne	800042ac <xcmp_rx_process+0xbc>
						{
							/*send not supported opcode to raido */
							xcmp_opcode_not_supported();
80004292:	f0 1f 00 14 	mcall	800042e0 <xcmp_rx_process+0xf0>
80004296:	c0 b8       	rjmp	800042ac <xcmp_rx_process+0xbc>
						}
					}
					else
					{					
						xcmp_exec_func( &app_list[ptr->xcmp_opcode & 0x00FF]
80004298:	f9 da c0 08 	bfextu	r12,r10,0x0,0x8
8000429c:	f8 0c 00 1c 	add	r12,r12,r12<<0x1
800042a0:	49 19       	lddpc	r9,800042e4 <xcmp_rx_process+0xf4>
800042a2:	72 08       	ld.w	r8,r9[0x0]
800042a4:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800042a8:	f0 1f 00 0b 	mcall	800042d4 <xcmp_rx_process+0xe4>
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
800042ac:	66 0c       	ld.w	r12,r3[0x0]
800042ae:	40 0b       	lddsp	r11,sp[0x0]
800042b0:	f0 1f 00 0e 	mcall	800042e8 <xcmp_rx_process+0xf8>
800042b4:	ca 7b       	rjmp	80004202 <xcmp_rx_process+0x12>
800042b6:	00 00       	add	r0,r0
800042b8:	00 00       	add	r0,r0
800042ba:	0b 00       	ld.w	r0,r5++
800042bc:	00 00       	add	r0,r0
800042be:	0a b8       	st.h	r5++,r8
800042c0:	00 00       	add	r0,r0
800042c2:	0b 10       	ld.sh	r0,r5++
800042c4:	00 00       	add	r0,r0
800042c6:	0b 04       	ld.w	r4,r5++
800042c8:	00 00       	add	r0,r0
800042ca:	0a f4       	st.b	--r5,r4
800042cc:	80 00       	ld.sh	r0,r0[0x0]
800042ce:	60 44       	ld.w	r4,r0[0x10]
800042d0:	00 00       	add	r0,r0
800042d2:	0b 28       	ld.uh	r8,r5++
800042d4:	80 00       	ld.sh	r0,r0[0x0]
800042d6:	40 f4       	lddsp	r4,sp[0x3c]
800042d8:	00 00       	add	r0,r0
800042da:	0a e8       	st.h	--r5,r8
800042dc:	00 00       	add	r0,r0
800042de:	0b 1c       	ld.sh	r12,r5++
800042e0:	80 00       	ld.sh	r0,r0[0x0]
800042e2:	40 d0       	lddsp	r0,sp[0x34]
800042e4:	00 00       	add	r0,r0
800042e6:	51 04       	stdsp	sp[0x40],r4
800042e8:	80 00       	ld.sh	r0,r0[0x0]
800042ea:	2c 88       	sub	r8,-56

800042ec <xcmp_rx>:
Calls:   
	xQueueSend -- xnl.c
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
800042ec:	eb cd 40 90 	pushm	r4,r7,lr
800042f0:	20 1d       	sub	sp,4
800042f2:	fa c4 ff f0 	sub	r4,sp,-16
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
800042f6:	48 c8       	lddpc	r8,80004324 <xcmp_rx+0x38>
800042f8:	70 0c       	ld.w	r12,r8[0x0]
800042fa:	f0 1f 00 0c 	mcall	80004328 <xcmp_rx+0x3c>
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
800042fe:	c1 00       	breq	8000431e <xcmp_rx+0x32>
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
80004300:	fa c7 ff fc 	sub	r7,sp,-4
80004304:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
	{
		memcpy(xcmp_ptr, &xcmp, sizeof(xcmp_fragment_t));				
80004306:	e0 6a 00 ca 	mov	r10,202
8000430a:	08 9b       	mov	r11,r4
8000430c:	f0 1f 00 08 	mcall	8000432c <xcmp_rx+0x40>
		xQueueSend(xcmp_frame_rx, &xcmp_ptr, 0);	
80004310:	48 88       	lddpc	r8,80004330 <xcmp_rx+0x44>
80004312:	70 0c       	ld.w	r12,r8[0x0]
80004314:	30 09       	mov	r9,0
80004316:	12 9a       	mov	r10,r9
80004318:	1a 9b       	mov	r11,sp
8000431a:	f0 1f 00 07 	mcall	80004334 <xcmp_rx+0x48>
	}	
}
8000431e:	2f fd       	sub	sp,-4
80004320:	e3 cd 80 90 	ldm	sp++,r4,r7,pc
80004324:	00 00       	add	r0,r0
80004326:	0a b8       	st.h	r5++,r8
80004328:	80 00       	ld.sh	r0,r0[0x0]
8000432a:	2e 34       	sub	r4,-29
8000432c:	80 00       	ld.sh	r0,r0[0x0]
8000432e:	76 b0       	ld.w	r0,r11[0x2c]
80004330:	00 00       	add	r0,r0
80004332:	0b 00       	ld.w	r0,r5++
80004334:	80 00       	ld.sh	r0,r0[0x0]
80004336:	62 50       	ld.w	r0,r1[0x14]

80004338 <xnl_register_xcmp_func>:
Function: xnl_register_xcmp_func
Description: register the xcmp function(callback function)
*/
void xnl_register_xcmp_func( void ( *func)(xnl_content_data_msg_t))
{
	 xcmp_exec = func;
80004338:	48 28       	lddpc	r8,80004340 <xnl_register_xcmp_func+0x8>
8000433a:	91 0c       	st.w	r8[0x0],r12
}
8000433c:	5e fc       	retal	r12
8000433e:	00 00       	add	r0,r0
80004340:	00 00       	add	r0,r0
80004342:	0b 58       	ld.sh	r8,--r5

80004344 <xnl_get_msg_ack_func>:
Description: process while receive msg ack.
Calls:xSemaphoreGive--freertos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
80004344:	d4 01       	pushm	lr
	
	DestinationAddress = xnl->xnl_header.destination;
	/*No timeout*/		
	 //One relationship is controlled by a state machine, only the current MSG received the ACK, 
	//then the program will clear the current MSG sending address and out of standby and will jump to the sending state.
	if (DestinationAddress == xnl_information.device_address )
80004346:	48 88       	lddpc	r8,80004364 <xnl_get_msg_ack_func+0x20>
80004348:	90 28       	ld.sh	r8,r8[0x4]
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
	U16 DestinationAddress;
	U16 TransactionID;
	
	DestinationAddress = xnl->xnl_header.destination;
8000434a:	98 49       	ld.sh	r9,r12[0x8]
8000434c:	f0 09 19 00 	cp.h	r9,r8
80004350:	c0 81       	brne	80004360 <xnl_get_msg_ack_func+0x1c>
	if (DestinationAddress == xnl_information.device_address )
	{
		//The ack is for me.
		
		TransactionID = xnl->xnl_header.transaction_id;
		xSemaphoreGive(xnl_timeout_semphr);	
80004352:	48 68       	lddpc	r8,80004368 <xnl_get_msg_ack_func+0x24>
80004354:	70 0c       	ld.w	r12,r8[0x0]
80004356:	30 09       	mov	r9,0
80004358:	12 9a       	mov	r10,r9
8000435a:	12 9b       	mov	r11,r9
8000435c:	f0 1f 00 04 	mcall	8000436c <xnl_get_msg_ack_func+0x28>
80004360:	d8 02       	popm	pc
80004362:	00 00       	add	r0,r0
80004364:	00 00       	add	r0,r0
80004366:	0b 38       	ld.ub	r8,r5++
80004368:	00 00       	add	r0,r0
8000436a:	0b 34       	ld.ub	r4,r5++
8000436c:	80 00       	ld.sh	r0,r0[0x0]
8000436e:	62 50       	ld.w	r0,r1[0x14]

80004370 <xnl_init>:
	xTaskCreate--freertos
	xnl_send_device_master_query
Called By:xcmp_init -- xcmp.c
*/
void xnl_init(void)
{
80004370:	eb cd 40 e0 	pushm	r5-r7,lr
	
	xnl_information.is_connected = FALSE;
80004374:	30 09       	mov	r9,0
80004376:	4b 78       	lddpc	r8,80004450 <xnl_init+0xe0>
80004378:	b0 89       	st.b	r8[0x0],r9

	/*initialize the semaphore and queue*/
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
8000437a:	30 0b       	mov	r11,0
8000437c:	30 1c       	mov	r12,1
8000437e:	f0 1f 00 36 	mcall	80004454 <xnl_init+0xe4>
80004382:	4b 68       	lddpc	r8,80004458 <xnl_init+0xe8>
80004384:	91 0c       	st.w	r8[0x0],r12
80004386:	70 08       	ld.w	r8,r8[0x0]
80004388:	58 08       	cp.w	r8,0
8000438a:	c0 80       	breq	8000439a <xnl_init+0x2a>
8000438c:	4b 38       	lddpc	r8,80004458 <xnl_init+0xe8>
8000438e:	70 0c       	ld.w	r12,r8[0x0]
80004390:	30 09       	mov	r9,0
80004392:	12 9a       	mov	r10,r9
80004394:	12 9b       	mov	r11,r9
80004396:	f0 1f 00 32 	mcall	8000445c <xnl_init+0xec>
	
	xnl_frame_tx = xQueueCreate(20, sizeof(xnl_fragment_t *)); //扩大xnl_frame_tx的队列深度
8000439a:	30 4b       	mov	r11,4
8000439c:	31 4c       	mov	r12,20
8000439e:	f0 1f 00 2e 	mcall	80004454 <xnl_init+0xe4>
800043a2:	4b 08       	lddpc	r8,80004460 <xnl_init+0xf0>
800043a4:	91 0c       	st.w	r8[0x0],r12
		
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
800043a6:	30 4b       	mov	r11,4
800043a8:	31 ec       	mov	r12,30
800043aa:	f0 1f 00 2b 	mcall	80004454 <xnl_init+0xe4>
800043ae:	4a e8       	lddpc	r8,80004464 <xnl_init+0xf4>
800043b0:	91 0c       	st.w	r8[0x0],r12
800043b2:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_XNL_STORE; i++ )
	{
		set_xnl_idle(&xnl_store[i]);
800043b4:	10 96       	mov	r6,r8
800043b6:	4a d5       	lddpc	r5,80004468 <xnl_init+0xf8>
800043b8:	6c 0c       	ld.w	r12,r6[0x0]
800043ba:	ea 07 00 0b 	add	r11,r5,r7
800043be:	f0 1f 00 2c 	mcall	8000446c <xnl_init+0xfc>
800043c2:	ee c7 ff 00 	sub	r7,r7,-256
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
	
	xnl_frame_tx = xQueueCreate(20, sizeof(xnl_fragment_t *)); //扩大xnl_frame_tx的队列深度
		
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
	for(int i= 0; i < MAX_XNL_STORE; i++ )
800043c6:	e0 47 1e 00 	cp.w	r7,7680
800043ca:	cf 71       	brne	800043b8 <xnl_init+0x48>
	{
		set_xnl_idle(&xnl_store[i]);
	}
	
	/*initialize the queue to send/receive xnl packet */
	phy_xnl_frame_tx = xQueueCreate(TX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
800043cc:	30 4b       	mov	r11,4
800043ce:	31 4c       	mov	r12,20
800043d0:	f0 1f 00 21 	mcall	80004454 <xnl_init+0xe4>
800043d4:	4a 78       	lddpc	r8,80004470 <xnl_init+0x100>
800043d6:	91 0c       	st.w	r8[0x0],r12
	phy_xnl_frame_rx = xQueueCreate(RX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
800043d8:	30 4b       	mov	r11,4
800043da:	30 ac       	mov	r12,10
800043dc:	f0 1f 00 1e 	mcall	80004454 <xnl_init+0xe4>
800043e0:	4a 58       	lddpc	r8,80004474 <xnl_init+0x104>
800043e2:	91 0c       	st.w	r8[0x0],r12
	
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
800043e4:	30 4b       	mov	r11,4
800043e6:	30 ac       	mov	r12,10
800043e8:	f0 1f 00 1b 	mcall	80004454 <xnl_init+0xe4>
800043ec:	4a 38       	lddpc	r8,80004478 <xnl_init+0x108>
800043ee:	91 0c       	st.w	r8[0x0],r12
800043f0:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
	{
		set_payload_idle(payload_store[i]);
800043f2:	10 96       	mov	r6,r8
800043f4:	4a 25       	lddpc	r5,8000447c <xnl_init+0x10c>
800043f6:	6c 0c       	ld.w	r12,r6[0x0]
800043f8:	ea 07 00 0b 	add	r11,r5,r7
800043fc:	f0 1f 00 1c 	mcall	8000446c <xnl_init+0xfc>
80004400:	ee c7 fe 00 	sub	r7,r7,-512
	
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
80004404:	e0 47 14 00 	cp.w	r7,5120
80004408:	cf 71       	brne	800043f6 <xnl_init+0x86>
	
	/*initialize the queue to send/receive payload packet */
	//phy_payload_frame_tx =
	//xQueueCreate(TX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t));
	
	phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
8000440a:	30 4b       	mov	r11,4
8000440c:	30 5c       	mov	r12,5
8000440e:	f0 1f 00 12 	mcall	80004454 <xnl_init+0xe4>
80004412:	49 c8       	lddpc	r8,80004480 <xnl_init+0x110>
80004414:	91 0c       	st.w	r8[0x0],r12
	
	#endif /*end if*/
		
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
80004416:	30 07       	mov	r7,0
80004418:	1a d7       	st.w	--sp,r7
8000441a:	1a d7       	st.w	--sp,r7
8000441c:	1a d7       	st.w	--sp,r7
8000441e:	30 38       	mov	r8,3
80004420:	0e 99       	mov	r9,r7
80004422:	e0 6a 02 00 	mov	r10,512
80004426:	49 8b       	lddpc	r11,80004484 <xnl_init+0x114>
80004428:	49 8c       	lddpc	r12,80004488 <xnl_init+0x118>
8000442a:	f0 1f 00 19 	mcall	8000448c <xnl_init+0x11c>
	,  tskXNL_PRIORITY //+ 1
	,  NULL
	);
	
	/*this task is used to send xnl message*/
	xTaskCreate(
8000442e:	1a d7       	st.w	--sp,r7
80004430:	1a d7       	st.w	--sp,r7
80004432:	1a d7       	st.w	--sp,r7
80004434:	30 38       	mov	r8,3
80004436:	0e 99       	mov	r9,r7
80004438:	e0 6a 03 20 	mov	r10,800
8000443c:	49 5b       	lddpc	r11,80004490 <xnl_init+0x120>
8000443e:	49 6c       	lddpc	r12,80004494 <xnl_init+0x124>
80004440:	f0 1f 00 13 	mcall	8000448c <xnl_init+0x11c>
	,  tskXNL_PRIORITY//+1
	,  NULL
	);
	
	/*initialize the physical layer*/
	phy_init();
80004444:	f0 1f 00 15 	mcall	80004498 <xnl_init+0x128>
80004448:	2f ad       	sub	sp,-24
}
8000444a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000444e:	00 00       	add	r0,r0
80004450:	00 00       	add	r0,r0
80004452:	0b 38       	ld.ub	r8,r5++
80004454:	80 00       	ld.sh	r0,r0[0x0]
80004456:	63 50       	ld.w	r0,r1[0x54]
80004458:	00 00       	add	r0,r0
8000445a:	0b 34       	ld.ub	r4,r5++
8000445c:	80 00       	ld.sh	r0,r0[0x0]
8000445e:	62 50       	ld.w	r0,r1[0x14]
80004460:	00 00       	add	r0,r0
80004462:	0b 44       	ld.w	r4,--r5
80004464:	00 00       	add	r0,r0
80004466:	0a b8       	st.h	r5++,r8
80004468:	00 00       	add	r0,r0
8000446a:	32 b6       	mov	r6,43
8000446c:	80 00       	ld.sh	r0,r0[0x0]
8000446e:	2c 88       	sub	r8,-56
80004470:	00 00       	add	r0,r0
80004472:	0a c8       	st.b	r5++,r8
80004474:	00 00       	add	r0,r0
80004476:	0a bc       	st.h	r5++,r12
80004478:	00 00       	add	r0,r0
8000447a:	0a 74       	tst	r4,r5
8000447c:	00 00       	add	r0,r0
8000447e:	1e b6       	st.h	pc++,r6
80004480:	00 00       	add	r0,r0
80004482:	0a 90       	mov	r0,r5
80004484:	80 00       	ld.sh	r0,r0[0x0]
80004486:	d5 64       	*unknown*
80004488:	80 00       	ld.sh	r0,r0[0x0]
8000448a:	44 9c       	lddsp	r12,sp[0x124]
8000448c:	80 00       	ld.sh	r0,r0[0x0]
8000448e:	6a 6c       	ld.w	r12,r5[0x18]
80004490:	80 00       	ld.sh	r0,r0[0x0]
80004492:	ce 00       	breq	80004452 <xnl_init+0xe2>
80004494:	80 00       	ld.sh	r0,r0[0x0]
80004496:	44 fc       	lddsp	r12,sp[0x13c]
80004498:	80 00       	ld.sh	r0,r0[0x0]
8000449a:	2e 5c       	sub	r12,-27

8000449c <xnl_rx_process>:
Description: Receive the XNL
Calls: 
Called By:task
*/
static void xnl_rx_process(void * pvParameters)
{
8000449c:	eb cd 40 fe 	pushm	r1-r7,lr
800044a0:	20 1d       	sub	sp,4
	/*To ptr the elements in the queue*/
	xnl_fragment_t * xnl_ptr;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
800044a2:	49 26       	lddpc	r6,800044e8 <xnl_rx_process+0x4c>
800044a4:	30 05       	mov	r5,0
800044a6:	3f f4       	mov	r4,-1
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
800044a8:	30 c3       	mov	r3,12
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
800044aa:	49 11       	lddpc	r1,800044ec <xnl_rx_process+0x50>
	if(xnl->xnl_header.opcode > 0x0C)	
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
800044ac:	49 12       	lddpc	r2,800044f0 <xnl_rx_process+0x54>
	/*To ptr the elements in the queue*/
	xnl_fragment_t * xnl_ptr;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
800044ae:	6c 0c       	ld.w	r12,r6[0x0]
800044b0:	0a 99       	mov	r9,r5
800044b2:	08 9a       	mov	r10,r4
800044b4:	1a 9b       	mov	r11,sp
800044b6:	f0 1f 00 10 	mcall	800044f4 <xnl_rx_process+0x58>
800044ba:	58 1c       	cp.w	r12,1
800044bc:	cf 91       	brne	800044ae <xnl_rx_process+0x12>
		, portMAX_DELAY ))
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
800044be:	40 0c       	lddsp	r12,sp[0x0]
800044c0:	58 0c       	cp.w	r12,0
800044c2:	cf 60       	breq	800044ae <xnl_rx_process+0x12>
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
800044c4:	98 28       	ld.sh	r8,r12[0x4]
800044c6:	e6 08 19 00 	cp.h	r8,r3
800044ca:	e0 8b 00 0a 	brhi	800044de <xnl_rx_process+0x42>
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
800044ce:	5c 78       	castu.h	r8
800044d0:	e4 08 03 29 	ld.w	r9,r2[r8<<0x2]
800044d4:	58 09       	cp.w	r9,0
800044d6:	c0 40       	breq	800044de <xnl_rx_process+0x42>
	{
		//log("\n\r R_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:R_xnl指令
		/*execute the function in list*/
		xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec(xnl);
800044d8:	e4 08 03 28 	ld.w	r8,r2[r8<<0x2]
800044dc:	5d 18       	icall	r8
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
800044de:	62 0c       	ld.w	r12,r1[0x0]
800044e0:	40 0b       	lddsp	r11,sp[0x0]
800044e2:	f0 1f 00 06 	mcall	800044f8 <xnl_rx_process+0x5c>
800044e6:	ce 4b       	rjmp	800044ae <xnl_rx_process+0x12>
800044e8:	00 00       	add	r0,r0
800044ea:	0a bc       	st.h	r5++,r12
800044ec:	00 00       	add	r0,r0
800044ee:	0a b8       	st.h	r5++,r8
800044f0:	00 00       	add	r0,r0
800044f2:	04 f4       	st.b	--r2,r4
800044f4:	80 00       	ld.sh	r0,r0[0x0]
800044f6:	60 44       	ld.w	r4,r0[0x10]
800044f8:	80 00       	ld.sh	r0,r0[0x0]
800044fa:	2c 88       	sub	r8,-56

800044fc <xnl_tx_process>:
	xSemaphoreTake--freertos 
	phy_tx -- physical.c
Called By: task
*/
static void xnl_tx_process(void * pvParameters)
{
800044fc:	d4 31       	pushm	r0-r7,lr
	static  xnl_fragment_t * ptr;//是否可以修缮为静态变量？请关注
	
	
	for(;;)
	{		
		switch(xnl_tx_state)
800044fe:	4a a6       	lddpc	r6,800045a4 <xnl_tx_process+0xa8>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
80004500:	4a a2       	lddpc	r2,800045a8 <xnl_tx_process+0xac>
80004502:	4a b4       	lddpc	r4,800045ac <xnl_tx_process+0xb0>
80004504:	30 07       	mov	r7,0
80004506:	3f f1       	mov	r1,-1
					if(NULL == ptr)
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
80004508:	30 00       	mov	r0,0
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;				
8000450a:	4a a5       	lddpc	r5,800045b0 <xnl_tx_process+0xb4>
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
8000450c:	4a a3       	lddpc	r3,800045b4 <xnl_tx_process+0xb8>
	static  xnl_fragment_t * ptr;//是否可以修缮为静态变量？请关注
	
	
	for(;;)
	{		
		switch(xnl_tx_state)
8000450e:	6c 08       	ld.w	r8,r6[0x0]
80004510:	58 08       	cp.w	r8,0
80004512:	c0 40       	breq	8000451a <xnl_tx_process+0x1e>
80004514:	58 18       	cp.w	r8,1
80004516:	cf d1       	brne	80004510 <xnl_tx_process+0x14>
80004518:	c2 48       	rjmp	80004560 <xnl_tx_process+0x64>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
8000451a:	64 0c       	ld.w	r12,r2[0x0]
8000451c:	0e 99       	mov	r9,r7
8000451e:	02 9a       	mov	r10,r1
80004520:	08 9b       	mov	r11,r4
80004522:	f0 1f 00 26 	mcall	800045b8 <xnl_tx_process+0xbc>
80004526:	58 1c       	cp.w	r12,1
80004528:	cf 31       	brne	8000450e <xnl_tx_process+0x12>
					, portMAX_DELAY ))
				{				
					if(NULL == ptr)
8000452a:	68 0b       	ld.w	r11,r4[0x0]
8000452c:	58 0b       	cp.w	r11,0
8000452e:	cf 00       	breq	8000450e <xnl_tx_process+0x12>
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
80004530:	96 28       	ld.sh	r8,r11[0x4]
80004532:	e0 08 19 00 	cp.h	r8,r0
80004536:	c0 71       	brne	80004544 <xnl_tx_process+0x48>
					{
						/*invalid XNL opcode*/
						set_xnl_idle(ptr);
80004538:	4a 18       	lddpc	r8,800045bc <xnl_tx_process+0xc0>
8000453a:	70 08       	ld.w	r8,r8[0x0]
8000453c:	10 9c       	mov	r12,r8
8000453e:	f0 1f 00 21 	mcall	800045c0 <xnl_tx_process+0xc4>
						break;
80004542:	ce 6b       	rjmp	8000450e <xnl_tx_process+0x12>
					}
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
80004544:	16 9c       	mov	r12,r11
80004546:	f0 1f 00 20 	mcall	800045c4 <xnl_tx_process+0xc8>
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;				
8000454a:	30 18       	mov	r8,1
8000454c:	8b 08       	st.w	r5[0x0],r8
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
8000454e:	66 0c       	ld.w	r12,r3[0x0]
80004550:	0e 99       	mov	r9,r7
80004552:	0e 9a       	mov	r10,r7
80004554:	0e 9b       	mov	r11,r7
80004556:	f0 1f 00 19 	mcall	800045b8 <xnl_tx_process+0xbc>
					xnl_tx_state = WAITING_FOR_REPLY;
8000455a:	30 18       	mov	r8,1
8000455c:	8d 08       	st.w	r6[0x0],r8
8000455e:	cd 8b       	rjmp	8000450e <xnl_tx_process+0x12>
				}
				break;
			
			/*wait XNL reply*/			
			case WAITING_FOR_REPLY://直到回答ACK才再发送下一条data/control
				if(pdTRUE == xSemaphoreTake( xnl_timeout_semphr
80004560:	66 0c       	ld.w	r12,r3[0x0]
80004562:	0e 99       	mov	r9,r7
80004564:	36 4a       	mov	r10,100
80004566:	0e 9b       	mov	r11,r7
80004568:	f0 1f 00 14 	mcall	800045b8 <xnl_tx_process+0xbc>
8000456c:	58 1c       	cp.w	r12,1
8000456e:	c0 81       	brne	8000457e <xnl_tx_process+0x82>
					, ( portTickType )50*2/ portTICK_RATE_MS))//按ADK文档中提示500ms一次超时,但是实际情况下程序中启用freertos的任务延时不够精准。因此根据经验需要降低延时等待的时间
				{
					/*No timeout*/
					set_xnl_idle(ptr);			
80004570:	49 38       	lddpc	r8,800045bc <xnl_tx_process+0xc0>
80004572:	70 0c       	ld.w	r12,r8[0x0]
80004574:	68 0b       	ld.w	r11,r4[0x0]
80004576:	f0 1f 00 13 	mcall	800045c0 <xnl_tx_process+0xc4>
					xnl_tx_state = WAITING_FOR_TX;
8000457a:	8d 07       	st.w	r6[0x0],r7
8000457c:	cc 9b       	rjmp	8000450e <xnl_tx_process+0x12>
				}
				else
				{
					/*time out*/
					if(xnl_send_times <= MIN_RESEND_TIMES)
8000457e:	6a 08       	ld.w	r8,r5[0x0]
80004580:	58 38       	cp.w	r8,3
80004582:	e0 89 00 09 	brgt	80004594 <xnl_tx_process+0x98>
					{
						/*If times smaller than A supermarket, then resend the 
						instructions*/
						phy_tx((phy_fragment_t *)ptr);
80004586:	68 0c       	ld.w	r12,r4[0x0]
80004588:	f0 1f 00 0f 	mcall	800045c4 <xnl_tx_process+0xc8>
						xnl_send_times++;
8000458c:	6a 08       	ld.w	r8,r5[0x0]
8000458e:	2f f8       	sub	r8,-1
80004590:	8b 08       	st.w	r5[0x0],r8
80004592:	cb eb       	rjmp	8000450e <xnl_tx_process+0x12>
					}
					else
					{
						//can not send data, disconnected						
						//vPortFree(ptr);	
						set_xnl_idle(ptr);									
80004594:	48 a8       	lddpc	r8,800045bc <xnl_tx_process+0xc0>
80004596:	70 0c       	ld.w	r12,r8[0x0]
80004598:	68 0b       	ld.w	r11,r4[0x0]
8000459a:	f0 1f 00 0a 	mcall	800045c0 <xnl_tx_process+0xc4>
						xnl_tx_state = WAITING_FOR_TX;
8000459e:	8d 07       	st.w	r6[0x0],r7
800045a0:	cb 7b       	rjmp	8000450e <xnl_tx_process+0x12>
800045a2:	00 00       	add	r0,r0
800045a4:	00 00       	add	r0,r0
800045a6:	0b 54       	ld.sh	r4,--r5
800045a8:	00 00       	add	r0,r0
800045aa:	0b 44       	ld.w	r4,--r5
800045ac:	00 00       	add	r0,r0
800045ae:	0b 4c       	ld.w	r12,--r5
800045b0:	00 00       	add	r0,r0
800045b2:	0b 48       	ld.w	r8,--r5
800045b4:	00 00       	add	r0,r0
800045b6:	0b 34       	ld.ub	r4,r5++
800045b8:	80 00       	ld.sh	r0,r0[0x0]
800045ba:	60 44       	ld.w	r4,r0[0x10]
800045bc:	00 00       	add	r0,r0
800045be:	0a b8       	st.h	r5++,r8
800045c0:	80 00       	ld.sh	r0,r0[0x0]
800045c2:	2c 88       	sub	r8,-56
800045c4:	80 00       	ld.sh	r0,r0[0x0]
800045c6:	2c a8       	sub	r8,-54

800045c8 <xnl_tx>:
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
{
800045c8:	eb cd 40 c0 	pushm	r6-r7,lr
800045cc:	20 1d       	sub	sp,4
800045ce:	18 96       	mov	r6,r12
	message that is sent. The same value should be used for all retries.
	*/
	static U8 flags = 0;
	
	/*If the value is DEFAULT_VALUE, the value will be modified*/
	if(DEFAULT_VALUE == xnl->xnl_header.flags)
800045d0:	98 39       	ld.sh	r9,r12[0x6]
800045d2:	3f f8       	mov	r8,-1
800045d4:	f0 09 19 00 	cp.h	r9,r8
800045d8:	c0 a1       	brne	800045ec <xnl_tx+0x24>
	{
		xnl->xnl_header.flags =  0x0100 | ((++flags) & 0x07);
800045da:	4a e9       	lddpc	r9,80004690 <xnl_tx+0xc8>
800045dc:	13 88       	ld.ub	r8,r9[0x0]
800045de:	2f f8       	sub	r8,-1
800045e0:	5c 58       	castu.b	r8
800045e2:	b2 88       	st.b	r9[0x0],r8
800045e4:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
800045e8:	a9 a8       	sbr	r8,0x8
800045ea:	b8 38       	st.h	r12[0x6],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.destination)
800045ec:	8c 49       	ld.sh	r9,r6[0x8]
800045ee:	3f f8       	mov	r8,-1
800045f0:	f0 09 19 00 	cp.h	r9,r8
800045f4:	c0 41       	brne	800045fc <xnl_tx+0x34>
	{		
		/*Use actual Master address.*/
		xnl->xnl_header.destination = xnl_information.master_address;
800045f6:	4a 88       	lddpc	r8,80004694 <xnl_tx+0xcc>
800045f8:	90 18       	ld.sh	r8,r8[0x2]
800045fa:	ac 48       	st.h	r6[0x8],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.source)
800045fc:	8c 59       	ld.sh	r9,r6[0xa]
800045fe:	3f f8       	mov	r8,-1
80004600:	f0 09 19 00 	cp.h	r9,r8
80004604:	c0 41       	brne	8000460c <xnl_tx+0x44>
	{
		/*Use Temporary address.*/	
		xnl->xnl_header.source = xnl_information.device_address;
80004606:	4a 48       	lddpc	r8,80004694 <xnl_tx+0xcc>
80004608:	90 28       	ld.sh	r8,r8[0x4]
8000460a:	ac 58       	st.h	r6[0xa],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
8000460c:	8c 69       	ld.sh	r9,r6[0xc]
8000460e:	3f f8       	mov	r8,-1
80004610:	f0 09 19 00 	cp.h	r9,r8
80004614:	c0 e1       	brne	80004630 <xnl_tx+0x68>
	{		
		xnl->xnl_header.transaction_id = 
		  ((++xnl_information.transaction_id) & 0xFF) 
80004616:	4a 08       	lddpc	r8,80004694 <xnl_tx+0xcc>
80004618:	90 49       	ld.sh	r9,r8[0x8]
8000461a:	2f f9       	sub	r9,-1
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
8000461c:	b0 49       	st.h	r8[0x8],r9
		  ((++xnl_information.transaction_id) & 0xFF) 
8000461e:	90 4a       	ld.sh	r10,r8[0x8]
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
80004620:	90 49       	ld.sh	r9,r8[0x8]
80004622:	e0 19 ff 00 	andl	r9,0xff00
80004626:	f1 da c0 08 	bfextu	r8,r10,0x0,0x8
8000462a:	f3 e8 10 08 	or	r8,r9,r8
8000462e:	ac 68       	st.h	r6[0xc],r8
	U16  sumScratch;
	U32  indextohWord;
	S32  hWordswithinFrag;
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
80004630:	0d 98       	ld.ub	r8,r6[0x1]
80004632:	20 28       	sub	r8,2
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
80004634:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
80004638:	10 0c       	add	r12,r8
8000463a:	a1 5c       	asr	r12,0x1
	indextohWord = 2;
	while (hWordswithinFrag > 0)
8000463c:	58 0c       	cp.w	r12,0
8000463e:	e0 89 00 04 	brgt	80004646 <xnl_tx+0x7e>
80004642:	30 09       	mov	r9,0
80004644:	c0 d8       	rjmp	8000465e <xnl_tx+0x96>
80004646:	ec ca ff fc 	sub	r10,r6,-4
Parameters: xnl_fragment_t * 
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
8000464a:	2f ec       	sub	r12,-2
8000464c:	30 09       	mov	r9,0
8000464e:	30 28       	mov	r8,2
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
	{
		sumScratch += *((U16*)xnl + indextohWord);
80004650:	15 1b       	ld.sh	r11,r10++
80004652:	f6 09 00 09 	add	r9,r11,r9
80004656:	5c 89       	casts.h	r9
		indextohWord     += 1;
80004658:	2f f8       	sub	r8,-1
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
8000465a:	18 38       	cp.w	r8,r12
8000465c:	cf a1       	brne	80004650 <xnl_tx+0x88>
		  ((++xnl_information.transaction_id) & 0xFF) 
		| (xnl_information.transaction_id & 0xFF00);
	}
	
	/*count check sum */
	xnl->phy_header.check_sum = check_sum( xnl );
8000465e:	5c 39       	neg	r9
80004660:	ac 19       	st.h	r6[0x2],r9
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
80004662:	48 e8       	lddpc	r8,80004698 <xnl_tx+0xd0>
80004664:	70 0c       	ld.w	r12,r8[0x0]
80004666:	f0 1f 00 0e 	mcall	8000469c <xnl_tx+0xd4>
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
8000466a:	c1 00       	breq	8000468a <xnl_tx+0xc2>
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
8000466c:	fa c7 ff fc 	sub	r7,sp,-4
80004670:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
	{
		memcpy(ptr, xnl, sizeof(xnl_fragment_t));
80004672:	e0 6a 01 00 	mov	r10,256
80004676:	0c 9b       	mov	r11,r6
80004678:	f0 1f 00 0a 	mcall	800046a0 <xnl_tx+0xd8>
	
		/*push to queue and send*/
		
		//log("ptr -%8x", ptr);
		
		xQueueSend(xnl_frame_tx, &ptr, 0);
8000467c:	48 a8       	lddpc	r8,800046a4 <xnl_tx+0xdc>
8000467e:	70 0c       	ld.w	r12,r8[0x0]
80004680:	30 09       	mov	r9,0
80004682:	12 9a       	mov	r10,r9
80004684:	1a 9b       	mov	r11,sp
80004686:	f0 1f 00 09 	mcall	800046a8 <xnl_tx+0xe0>
		//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
		
		//vPortFree(ptr);
	}
}
8000468a:	2f fd       	sub	sp,-4
8000468c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004690:	00 00       	add	r0,r0
80004692:	0b 50       	ld.sh	r0,--r5
80004694:	00 00       	add	r0,r0
80004696:	0b 38       	ld.ub	r8,r5++
80004698:	00 00       	add	r0,r0
8000469a:	0a b8       	st.h	r5++,r8
8000469c:	80 00       	ld.sh	r0,r0[0x0]
8000469e:	2e 34       	sub	r4,-29
800046a0:	80 00       	ld.sh	r0,r0[0x0]
800046a2:	76 b0       	ld.w	r0,r11[0x2c]
800046a4:	00 00       	add	r0,r0
800046a6:	0b 44       	ld.w	r4,--r5
800046a8:	80 00       	ld.sh	r0,r0[0x0]
800046aa:	62 50       	ld.w	r0,r1[0x14]

800046ac <xnl_data_msg_func>:
Description: process while receive data message.
Calls:xnl_send_msg_ack, xcmp_exec(function in xcmp)
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_data_msg_func(xnl_fragment_t * xnl)
{
800046ac:	eb cd 40 80 	pushm	r7,lr
800046b0:	fa cd 01 00 	sub	sp,sp,256
800046b4:	18 97       	mov	r7,r12
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
800046b6:	e0 68 40 0e 	mov	r8,16398
800046ba:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
800046bc:	3f f8       	mov	r8,-1
800046be:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG_ACK;
800046c0:	30 c8       	mov	r8,12
800046c2:	ba 28       	st.h	sp[0x4],r8
	
	/*Turn around Flags.*/	
	xnl_frame.xnl_header.flags = hdr->flags;
800046c4:	98 38       	ld.sh	r8,r12[0x6]
800046c6:	ba 38       	st.h	sp[0x6],r8
	
	/*ACK Destination Address is Source of XNL_Message.*/
	xnl_frame.xnl_header.destination = hdr->source;
800046c8:	98 58       	ld.sh	r8,r12[0xa]
800046ca:	ba 48       	st.h	sp[0x8],r8
	
	/*ACK Source Address is my address.*/
	xnl_frame.xnl_header.source = hdr->destination;
800046cc:	98 48       	ld.sh	r8,r12[0x8]
800046ce:	ba 58       	st.h	sp[0xa],r8
	
	/*Turn around Transaction ID.*/
	xnl_frame.xnl_header.transaction_id = hdr->transaction_id;
800046d0:	98 68       	ld.sh	r8,r12[0xc]
800046d2:	ba 68       	st.h	sp[0xc],r8
	xnl_frame.xnl_header.payload_length = 0;
800046d4:	30 08       	mov	r8,0
800046d6:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
800046d8:	1a 9c       	mov	r12,sp
800046da:	f0 1f 00 0a 	mcall	80004700 <xnl_data_msg_func+0x54>
	transmitter, but possibly is waiting in Queue with immediate timeout.
	 */
	xnl_send_msg_ack(&xnl->xnl_header);
	
	/*exec xcmp function*/
	xcmp_exec(xnl->xnl_payload.xnl_content_data_msg);//xcmp_rx
800046de:	fa cd 00 cc 	sub	sp,sp,204
800046e2:	e0 6a 00 ca 	mov	r10,202
800046e6:	ee cb ff f0 	sub	r11,r7,-16
800046ea:	1a 9c       	mov	r12,sp
800046ec:	f0 1f 00 06 	mcall	80004704 <xnl_data_msg_func+0x58>
800046f0:	48 68       	lddpc	r8,80004708 <xnl_data_msg_func+0x5c>
800046f2:	70 08       	ld.w	r8,r8[0x0]
800046f4:	5d 18       	icall	r8
800046f6:	fa cd ff 34 	sub	sp,sp,-204
}
800046fa:	2c 0d       	sub	sp,-256
800046fc:	e3 cd 80 80 	ldm	sp++,r7,pc
80004700:	80 00       	ld.sh	r0,r0[0x0]
80004702:	45 c8       	lddsp	r8,sp[0x170]
80004704:	80 00       	ld.sh	r0,r0[0x0]
80004706:	76 b0       	ld.w	r0,r11[0x2c]
80004708:	00 00       	add	r0,r0
8000470a:	0b 58       	ld.sh	r8,--r5

8000470c <xnl_device_auth_reply_func>:
Description: process while receive device auth reply.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_auth_reply_func(xnl_fragment_t * xnl)
{
8000470c:	d4 21       	pushm	r4-r7,lr
8000470e:	fa cd 01 00 	sub	sp,sp,256
80004712:	18 97       	mov	r7,r12
	the receiving device and will be used to authenticate the connection 
	request. 5.4.4
	*/
	//log("R_xnl-opcode:%4x", xnl->xnl_header.opcode);
	
	if(xnl_information.is_connected)
80004714:	4c 28       	lddpc	r8,8000481c <xnl_device_auth_reply_func+0x110>
80004716:	11 88       	ld.ub	r8,r8[0x0]
80004718:	58 08       	cp.w	r8,0
8000471a:	e0 81 00 7f 	brne	80004818 <xnl_device_auth_reply_func+0x10c>
	{
		return;		
	}
	
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);
8000471e:	4c 18       	lddpc	r8,80004820 <xnl_device_auth_reply_func+0x114>
80004720:	70 0c       	ld.w	r12,r8[0x0]
80004722:	30 09       	mov	r9,0
80004724:	12 9a       	mov	r10,r9
80004726:	12 9b       	mov	r11,r9
80004728:	f0 1f 00 3f 	mcall	80004824 <xnl_device_auth_reply_func+0x118>

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
8000472c:	ef 09 00 10 	ld.sh	r9,r7[16]
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
80004730:	4b b8       	lddpc	r8,8000481c <xnl_device_auth_reply_func+0x110>
80004732:	b0 29       	st.h	r8[0x4],r9
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
	
	/*Get Array of values to be encrypted into an aligned 2X32bits.*/
	v_vector[0] =
80004734:	ef 39 00 12 	ld.ub	r9,r7[18]
80004738:	ef 38 00 13 	ld.ub	r8,r7[19]
8000473c:	b1 68       	lsl	r8,0x10
8000473e:	f1 e9 11 89 	or	r9,r8,r9<<0x18
80004742:	ef 38 00 15 	ld.ub	r8,r7[21]
80004746:	f3 e8 10 08 	or	r8,r9,r8
8000474a:	ef 39 00 14 	ld.ub	r9,r7[20]
8000474e:	f1 e9 10 89 	or	r9,r8,r9<<0x8
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[2])<<8	  
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[3]);
	
	v_vector[1] =
80004752:	ef 3a 00 16 	ld.ub	r10,r7[22]
80004756:	ef 38 00 17 	ld.ub	r8,r7[23]
8000475a:	b1 68       	lsl	r8,0x10
8000475c:	f1 ea 11 8a 	or	r10,r8,r10<<0x18
80004760:	ef 38 00 19 	ld.ub	r8,r7[25]
80004764:	f5 e8 10 08 	or	r8,r10,r8
80004768:	ef 3a 00 18 	ld.ub	r10,r7[24]
8000476c:	f1 ea 10 88 	or	r8,r8,r10<<0x8
80004770:	30 0a       	mov	r10,0
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
80004772:	e0 64 79 b9 	mov	r4,31161
80004776:	ea 14 9e 37 	orh	r4,0x9e37
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
8000477a:	e0 65 45 07 	mov	r5,17671
8000477e:	ea 15 8a bd 	orh	r5,0x8abd
80004782:	e0 66 f9 3d 	mov	r6,63805
80004786:	ea 16 99 68 	orh	r6,0x9968
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
8000478a:	e0 6e b8 cf 	mov	lr,47311
8000478e:	ea 1e 36 83 	orh	lr,0x3683
80004792:	e0 67 aa 1c 	mov	r7,43548
80004796:	ea 17 9c 36 	orh	r7,0x9c36
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
8000479a:	08 0a       	add	r10,r4
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
8000479c:	f4 08 00 0c 	add	r12,r10,r8
800047a0:	f0 0b 15 04 	lsl	r11,r8,0x4
800047a4:	0a 0b       	add	r11,r5
800047a6:	f9 eb 20 0b 	eor	r11,r12,r11
800047aa:	f0 0c 16 05 	lsr	r12,r8,0x5
800047ae:	0c 0c       	add	r12,r6
800047b0:	18 5b       	eor	r11,r12
800047b2:	16 09       	add	r9,r11
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
800047b4:	f2 0c 15 04 	lsl	r12,r9,0x4
800047b8:	1c 0c       	add	r12,lr
800047ba:	f2 0b 16 05 	lsr	r11,r9,0x5
800047be:	0e 0b       	add	r11,r7
800047c0:	f9 eb 20 0b 	eor	r11,r12,r11
800047c4:	f2 0a 00 0c 	add	r12,r9,r10
800047c8:	18 5b       	eor	r11,r12
800047ca:	16 08       	add	r8,r11
{
	register U32 y=v[0], z=v[1], sum=0;
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
800047cc:	e0 6b 37 20 	mov	r11,14112
800047d0:	ea 1b c6 ef 	orh	r11,0xc6ef
800047d4:	16 3a       	cp.w	r10,r11
800047d6:	ce 21       	brne	8000479a <xnl_device_auth_reply_func+0x8e>
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :24 + 2(xnl length(24) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 24 + 2;
800047d8:	e0 6a 40 1a 	mov	r10,16410
800047dc:	ba 0a       	st.h	sp[0x0],r10
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
800047de:	3f fa       	mov	r10,-1
800047e0:	ba 1a       	st.h	sp[0x2],r10
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_CONN_REQUEST;
800047e2:	30 6b       	mov	r11,6
800047e4:	ba 2b       	st.h	sp[0x4],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
800047e6:	ba 3a       	st.h	sp[0x6],r10
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
800047e8:	48 db       	lddpc	r11,8000481c <xnl_device_auth_reply_func+0x110>
800047ea:	96 1c       	ld.sh	r12,r11[0x2]
800047ec:	ba 4c       	st.h	sp[0x8],r12
	message here, and all will receive the same DEVICE_CONN_REPLY. Not real 
	sure what's going to happen with multiple conrol heads, etc. One suspects 
	the Rocket Scientists will eventually figure this out, and demand a 
	transaction ID based on Device Type in the XNL_DEVICE_AUTH_KEY_REQUEST.
	*/
	xnl_frame.xnl_header.source = xnl_information.device_address;
800047ee:	96 2b       	ld.sh	r11,r11[0x4]
800047f0:	ba 5b       	st.h	sp[0xa],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
800047f2:	ba 6a       	st.h	sp[0xc],r10
	
    /*his message contains 12 payload bytes*/	
	xnl_frame.xnl_header.payload_length = 0x000C;
800047f4:	30 ca       	mov	r10,12
800047f6:	ba 7a       	st.h	sp[0xe],r10
	
	/*No Preferred XNL Address*/
	xnl_frame.xnl_payload.xnl_content_device_conn_req.preferred_xnl_address = 
800047f8:	30 0a       	mov	r10,0
800047fa:	fb 5a 00 10 	st.h	sp[16],r10
	XCMP/XNL Development Specification Section 4.5.3.2.1.
	Same as in MOTOTRBO?XCMP/XNL Development Specification?
	evice_type--Option Board(0x07)
	authentication_index--Option Board(0x02)
	*/	
	xnl_frame.xnl_payload.xnl_content_device_conn_req.device_type = 0x07;
800047fe:	30 7a       	mov	r10,7
80004800:	fb 6a 00 12 	st.b	sp[18],r10
	xnl_frame.xnl_payload.xnl_content_device_conn_req.authentication_index =
80004804:	30 2a       	mov	r10,2
80004806:	fb 6a 00 13 	st.b	sp[19],r10
	                                                                       0x02;
		
	//We know encrypted array happens to be aligned to 32-bit boundary.
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
8000480a:	fa ca ff ec 	sub	r10,sp,-20
8000480e:	95 09       	st.w	r10[0x0],r9
	                         .encrypted_authentication_value[0])) = w_vector[0];
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
80004810:	95 18       	st.w	r10[0x4],r8
	                         .encrypted_authentication_value[4])) = w_vector[1];
	
	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004812:	1a 9c       	mov	r12,sp
80004814:	f0 1f 00 05 	mcall	80004828 <xnl_device_auth_reply_func+0x11c>
}
80004818:	2c 0d       	sub	sp,-256
8000481a:	d8 22       	popm	r4-r7,pc
8000481c:	00 00       	add	r0,r0
8000481e:	0b 38       	ld.ub	r8,r5++
80004820:	00 00       	add	r0,r0
80004822:	0b 34       	ld.ub	r4,r5++
80004824:	80 00       	ld.sh	r0,r0[0x0]
80004826:	62 50       	ld.w	r0,r1[0x14]
80004828:	80 00       	ld.sh	r0,r0[0x0]
8000482a:	45 c8       	lddsp	r8,sp[0x170]

8000482c <xnl_master_status_brdcst_func>:
Description: process while receive master status boardcast.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_master_status_brdcst_func(xnl_fragment_t * xnl)
{	
8000482c:	eb cd 40 80 	pushm	r7,lr
80004830:	fa cd 01 00 	sub	sp,sp,256
80004834:	18 97       	mov	r7,r12
	not an XNL_DATA_MSG has been sent out. This will indicate to a connecting 
	device that it has missed messages. The XNL header will contain the 
	master?XNL address. 5.4.1
	*/
	
	if(xnl_information.is_connected)
80004836:	49 28       	lddpc	r8,8000487c <xnl_master_status_brdcst_func+0x50>
80004838:	11 88       	ld.ub	r8,r8[0x0]
8000483a:	58 08       	cp.w	r8,0
8000483c:	c1 c1       	brne	80004874 <xnl_master_status_brdcst_func+0x48>
	{
		return;	
	}
		
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);	
8000483e:	49 18       	lddpc	r8,80004880 <xnl_master_status_brdcst_func+0x54>
80004840:	70 0c       	ld.w	r12,r8[0x0]
80004842:	30 09       	mov	r9,0
80004844:	12 9a       	mov	r10,r9
80004846:	12 9b       	mov	r11,r9
80004848:	f0 1f 00 0f 	mcall	80004884 <xnl_master_status_brdcst_func+0x58>

	//log("xnl-ma:%4x", xnl->xnl_header.source);
	/*get the master adderss from this message*/	
	xnl_information.master_address = xnl->xnl_header.source;	
8000484c:	8e 58       	ld.sh	r8,r7[0xa]
8000484e:	48 c9       	lddpc	r9,8000487c <xnl_master_status_brdcst_func+0x50>
80004850:	b2 18       	st.h	r9[0x2],r8
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80004852:	e0 68 40 0e 	mov	r8,16398
80004856:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004858:	3f f8       	mov	r8,-1
8000485a:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_AUTH_KEY_REQUEST;
8000485c:	30 4a       	mov	r10,4
8000485e:	ba 2a       	st.h	sp[0x4],r10
		
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/	
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
80004860:	ba 38       	st.h	sp[0x6],r8
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
80004862:	92 19       	ld.sh	r9,r9[0x2]
80004864:	ba 49       	st.h	sp[0x8],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.source = DEFAULT_VALUE;
80004866:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80004868:	ba 68       	st.h	sp[0xc],r8
		
	xnl_frame.xnl_header.payload_length = 0;
8000486a:	30 08       	mov	r8,0
8000486c:	ba 78       	st.h	sp[0xe],r8
	
	/*send XNL message*/	
	xnl_tx(&xnl_frame);
8000486e:	1a 9c       	mov	r12,sp
80004870:	f0 1f 00 06 	mcall	80004888 <xnl_master_status_brdcst_func+0x5c>
}
80004874:	2c 0d       	sub	sp,-256
80004876:	e3 cd 80 80 	ldm	sp++,r7,pc
8000487a:	00 00       	add	r0,r0
8000487c:	00 00       	add	r0,r0
8000487e:	0b 38       	ld.ub	r8,r5++
80004880:	00 00       	add	r0,r0
80004882:	0b 34       	ld.ub	r4,r5++
80004884:	80 00       	ld.sh	r0,r0[0x0]
80004886:	62 50       	ld.w	r0,r1[0x14]
80004888:	80 00       	ld.sh	r0,r0[0x0]
8000488a:	45 c8       	lddsp	r8,sp[0x170]

8000488c <xnl_device_conn_reply_func>:
Description: process while receive device conn reply.
Calls:xSemaphoreGive--freestos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_conn_reply_func(xnl_fragment_t * xnl)
{
8000488c:	eb cd 40 80 	pushm	r7,lr
80004890:	18 97       	mov	r7,r12
	transaction ID and an 8-byte encrypted value that the device can use to 
	authenticate the master. XCMP/XNL Development Guide 5.4.6
	*/
	
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);
80004892:	49 28       	lddpc	r8,800048d8 <xnl_device_conn_reply_func+0x4c>
80004894:	70 0c       	ld.w	r12,r8[0x0]
80004896:	30 09       	mov	r9,0
80004898:	12 9a       	mov	r10,r9
8000489a:	12 9b       	mov	r11,r9
8000489c:	f0 1f 00 10 	mcall	800048dc <xnl_device_conn_reply_func+0x50>

	/*Test result code*/
	if((xnl->xnl_payload.xnl_content_device_conn_reply.result_base & 0x0000FF00)
800048a0:	ef 18 00 10 	ld.uh	r8,r7[16]
800048a4:	10 99       	mov	r9,r8
800048a6:	e2 19 ff 00 	andl	r9,0xff00,COH
800048aa:	e0 49 01 00 	cp.w	r9,256
800048ae:	c0 60       	breq	800048ba <xnl_device_conn_reply_func+0x2e>
		/*
		Rejected. The device must retry the authentication process at this 
		point by sending out a new AUTH_KEY_REQUEST message. XCMP/XNL 
		Development Guide Section 5.2.3
		*/
		xnl_master_status_brdcst_func(xnl);			
800048b0:	0e 9c       	mov	r12,r7
800048b2:	f0 1f 00 0c 	mcall	800048e0 <xnl_device_conn_reply_func+0x54>
800048b6:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/*connection accepted*/		
		/*Record Transaction ID Base*/
		xnl_information.transaction_id =  
800048ba:	a9 68       	lsl	r8,0x8
800048bc:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
800048c0:	48 98       	lddpc	r8,800048e4 <xnl_device_conn_reply_func+0x58>
800048c2:	b0 49       	st.h	r8[0x8],r9
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
800048c4:	ef 09 00 14 	ld.sh	r9,r7[20]
		xnl_information.transaction_id =  
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
800048c8:	b0 39       	st.h	r8[0x6],r9
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
800048ca:	ef 09 00 12 	ld.sh	r9,r7[18]
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
800048ce:	b0 29       	st.h	r8[0x4],r9
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
		
		/*connect finish*/
		xnl_information.is_connected = TRUE;
800048d0:	30 19       	mov	r9,1
800048d2:	b0 89       	st.b	r8[0x0],r9
800048d4:	e3 cd 80 80 	ldm	sp++,r7,pc
800048d8:	00 00       	add	r0,r0
800048da:	0b 34       	ld.ub	r4,r5++
800048dc:	80 00       	ld.sh	r0,r0[0x0]
800048de:	62 50       	ld.w	r0,r1[0x14]
800048e0:	80 00       	ld.sh	r0,r0[0x0]
800048e2:	48 2c       	lddpc	r12,800048e8 <xnl_send_device_master_query>
800048e4:	00 00       	add	r0,r0
800048e6:	0b 38       	ld.ub	r8,r5++

800048e8 <xnl_send_device_master_query>:
Description: send device_master_query to connect radio.
Calls:xnl_tx
Call By:xnl_init
*/
void xnl_send_device_master_query(void)
{
800048e8:	d4 01       	pushm	lr
800048ea:	fa cd 01 00 	sub	sp,sp,256
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
800048ee:	e0 68 40 0e 	mov	r8,16398
800048f2:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
800048f4:	3f f8       	mov	r8,-1
800048f6:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_MASTER_QUERY;
800048f8:	30 38       	mov	r8,3
800048fa:	ba 28       	st.h	sp[0x4],r8
	
	/*The initial value*/
	xnl_frame.xnl_header.flags = 0;
800048fc:	30 08       	mov	r8,0
800048fe:	ba 38       	st.h	sp[0x6],r8
	
	/*XNL address of the master device, if known;otherwise 0x0000*/
	xnl_frame.xnl_header.destination = 0;
80004900:	ba 48       	st.h	sp[0x8],r8
	
	/*XNL address, if assigned; otherwise 0x0000*/
	xnl_frame.xnl_header.source = 0;
80004902:	ba 58       	st.h	sp[0xa],r8
	
	/*No transaction ID required for this message*/
	xnl_frame.xnl_header.transaction_id = 0;
80004904:	ba 68       	st.h	sp[0xc],r8
	
	/*This message contains no payload*/
	xnl_frame.xnl_header.payload_length = 0;
80004906:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004908:	1a 9c       	mov	r12,sp
8000490a:	f0 1f 00 03 	mcall	80004914 <xnl_send_device_master_query+0x2c>
}
8000490e:	2c 0d       	sub	sp,-256
80004910:	d8 02       	popm	pc
80004912:	00 00       	add	r0,r0
80004914:	80 00       	ld.sh	r0,r0[0x0]
80004916:	45 c8       	lddsp	r8,sp[0x170]

80004918 <RC522_SPI_SetSpeed>:
	SET_SPI_CS;

}

void RC522_SPI_SetSpeed(U16 SPI_BaudRatePrescaler)
{
80004918:	d4 01       	pushm	lr
	spi->csr0 = (spi->csr0 & (U16)0x00FF) |SPI_BaudRatePrescaler;
8000491a:	48 78       	lddpc	r8,80004934 <RC522_SPI_SetSpeed+0x1c>
8000491c:	70 09       	ld.w	r9,r8[0x0]
8000491e:	72 ca       	ld.w	r10,r9[0x30]
80004920:	5c 7c       	castu.h	r12
80004922:	f5 da c0 08 	bfextu	r10,r10,0x0,0x8
80004926:	f9 ea 10 0a 	or	r10,r12,r10
8000492a:	93 ca       	st.w	r9[0x30],r10

	spi_enable(spi); /*!< SD_SPI enable */
8000492c:	70 0c       	ld.w	r12,r8[0x0]
8000492e:	f0 1f 00 03 	mcall	80004938 <RC522_SPI_SetSpeed+0x20>
		
	
}
80004932:	d8 02       	popm	pc
80004934:	00 00       	add	r0,r0
80004936:	1d 84       	ld.ub	r4,lr[0x0]
80004938:	80 00       	ld.sh	r0,r0[0x0]
8000493a:	57 40       	stdsp	sp[0x1d0],r0

8000493c <RC522_SPI_SetSpeedLow>:
void RC522_SPI_SetSpeedLow(void)
{
8000493c:	d4 01       	pushm	lr
	RC522_SPI_SetSpeed(0x0400);//baudDiv=4
8000493e:	e0 6c 04 00 	mov	r12,1024
80004942:	f0 1f 00 02 	mcall	80004948 <RC522_SPI_SetSpeedLow+0xc>
	
}
80004946:	d8 02       	popm	pc
80004948:	80 00       	ld.sh	r0,r0[0x0]
8000494a:	49 18       	lddpc	r8,8000498c <RC522_ReadByte+0x40>

8000494c <RC522_ReadByte>:
	/*!< Return the byte read from the SPI bus */
	return  temp;

}
U8 RC522_ReadByte(void)
{
8000494c:	eb cd 40 c0 	pushm	r6-r7,lr
	U16 *Data ;

	//蹇椤昏锋芥ｅ父璇诲
	spi_selectChip(spi, DF_SPI_PCS_0);
80004950:	48 b7       	lddpc	r7,8000497c <RC522_ReadByte+0x30>
80004952:	30 0b       	mov	r11,0
80004954:	6e 0c       	ld.w	r12,r7[0x0]
80004956:	f0 1f 00 0b 	mcall	80004980 <RC522_ReadByte+0x34>
	
	/*!< Send the byte */

	spi_write(spi,  0xFF);
8000495a:	e0 6b 00 ff 	mov	r11,255
8000495e:	6e 0c       	ld.w	r12,r7[0x0]
80004960:	f0 1f 00 09 	mcall	80004984 <RC522_ReadByte+0x38>
	
	/*!< Return the byte read from the SPI bus */

	spi_read(spi, Data);
80004964:	30 06       	mov	r6,0
80004966:	0c 9b       	mov	r11,r6
80004968:	6e 0c       	ld.w	r12,r7[0x0]
8000496a:	f0 1f 00 08 	mcall	80004988 <RC522_ReadByte+0x3c>

	/*!< Return the shifted data */
	
	spi_unselectChip(spi, DF_SPI_PCS_0);
8000496e:	0c 9b       	mov	r11,r6
80004970:	6e 0c       	ld.w	r12,r7[0x0]
80004972:	f0 1f 00 07 	mcall	8000498c <RC522_ReadByte+0x40>
	
	return (U8)(*Data);
	
}
80004976:	0d 9c       	ld.ub	r12,r6[0x1]
80004978:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000497c:	00 00       	add	r0,r0
8000497e:	1d 84       	ld.ub	r4,lr[0x0]
80004980:	80 00       	ld.sh	r0,r0[0x0]
80004982:	58 ac       	cp.w	r12,10
80004984:	80 00       	ld.sh	r0,r0[0x0]
80004986:	57 46       	stdsp	sp[0x1d0],r6
80004988:	80 00       	ld.sh	r0,r0[0x0]
8000498a:	57 62       	stdsp	sp[0x1d8],r2
8000498c:	80 00       	ld.sh	r0,r0[0x0]
8000498e:	58 6c       	cp.w	r12,6

80004990 <RC522_WriteByte>:


U8 rc522_init_failure =0;

U8 RC522_WriteByte(U8 Data)
{
80004990:	eb cd 40 c0 	pushm	r6-r7,lr
80004994:	20 1d       	sub	sp,4
80004996:	ba 8c       	st.b	sp[0x0],r12
	U8 temp =0;
	
	spi_selectChip(spi, DF_SPI_PCS_0);
80004998:	48 c7       	lddpc	r7,800049c8 <RC522_WriteByte+0x38>
8000499a:	30 0b       	mov	r11,0
8000499c:	6e 0c       	ld.w	r12,r7[0x0]
8000499e:	f0 1f 00 0c 	mcall	800049cc <RC522_WriteByte+0x3c>
	
	/*!< Send the byte */
	spi_write(spi,  (U16)Data);
800049a2:	1b 8b       	ld.ub	r11,sp[0x0]
800049a4:	6e 0c       	ld.w	r12,r7[0x0]
800049a6:	f0 1f 00 0b 	mcall	800049d0 <RC522_WriteByte+0x40>
	
	/*!< Wait to receive a byte*/

	temp = spi_read(spi, (U16*)&Data);
800049aa:	1a 9b       	mov	r11,sp
800049ac:	6e 0c       	ld.w	r12,r7[0x0]
800049ae:	f0 1f 00 0a 	mcall	800049d4 <RC522_WriteByte+0x44>
800049b2:	18 96       	mov	r6,r12
	
	spi_unselectChip(spi, DF_SPI_PCS_0);
800049b4:	30 0b       	mov	r11,0
800049b6:	6e 0c       	ld.w	r12,r7[0x0]
800049b8:	f0 1f 00 08 	mcall	800049d8 <RC522_WriteByte+0x48>
	
	/*!< Return the byte read from the SPI bus */
	return  temp;

}
800049bc:	f9 d6 c0 08 	bfextu	r12,r6,0x0,0x8
800049c0:	2f fd       	sub	sp,-4
800049c2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800049c6:	00 00       	add	r0,r0
800049c8:	00 00       	add	r0,r0
800049ca:	1d 84       	ld.ub	r4,lr[0x0]
800049cc:	80 00       	ld.sh	r0,r0[0x0]
800049ce:	58 ac       	cp.w	r12,10
800049d0:	80 00       	ld.sh	r0,r0[0x0]
800049d2:	57 46       	stdsp	sp[0x1d0],r6
800049d4:	80 00       	ld.sh	r0,r0[0x0]
800049d6:	57 62       	stdsp	sp[0x1d8],r2
800049d8:	80 00       	ld.sh	r0,r0[0x0]
800049da:	58 6c       	cp.w	r12,6

800049dc <WriteRawRC>:
//    斤RC632瀵瀛
//拌存锛Address[IN]:瀵瀛ㄥ板
//          value[IN]:ョ
/////////////////////////////////////////////////////////////////////
void WriteRawRC(U8   Address, U8   value)
{
800049dc:	eb cd 40 c0 	pushm	r6-r7,lr
800049e0:	18 96       	mov	r6,r12
800049e2:	16 97       	mov	r7,r11
	U8   ucAddr;

	CLR_SPI_CS;	
800049e4:	31 8c       	mov	r12,24
800049e6:	f0 1f 00 09 	mcall	80004a08 <WriteRawRC+0x2c>
	
	ucAddr = ((Address<<1)&0x7E);
	RC522_WriteByte(ucAddr);
800049ea:	ec 0c 15 01 	lsl	r12,r6,0x1
800049ee:	e2 1c 00 7e 	andl	r12,0x7e,COH
800049f2:	f0 1f 00 07 	mcall	80004a0c <WriteRawRC+0x30>
	RC522_WriteByte(value);
800049f6:	0e 9c       	mov	r12,r7
800049f8:	f0 1f 00 05 	mcall	80004a0c <WriteRawRC+0x30>
	
	SET_SPI_CS;
800049fc:	31 8c       	mov	r12,24
800049fe:	f0 1f 00 05 	mcall	80004a10 <WriteRawRC+0x34>

}
80004a02:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004a06:	00 00       	add	r0,r0
80004a08:	80 00       	ld.sh	r0,r0[0x0]
80004a0a:	54 20       	stdsp	sp[0x108],r0
80004a0c:	80 00       	ld.sh	r0,r0[0x0]
80004a0e:	49 90       	lddpc	r0,80004a70 <PcdReset+0x5c>
80004a10:	80 00       	ld.sh	r0,r0[0x0]
80004a12:	54 04       	stdsp	sp[0x100],r4

80004a14 <PcdReset>:
/////////////////////////////////////////////////////////////////////
//    斤澶浣RC522
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdReset(void)
{
80004a14:	d4 01       	pushm	lr

	SET_RC522RST;
80004a16:	31 9c       	mov	r12,25
80004a18:	f0 1f 00 1b 	mcall	80004a84 <PcdReset+0x70>
	delay_ns(10);
80004a1c:	30 ac       	mov	r12,10
80004a1e:	f0 1f 00 1b 	mcall	80004a88 <PcdReset+0x74>

	CLR_RC522RST;
80004a22:	31 9c       	mov	r12,25
80004a24:	f0 1f 00 1a 	mcall	80004a8c <PcdReset+0x78>
	delay_ns(10);
80004a28:	30 ac       	mov	r12,10
80004a2a:	f0 1f 00 18 	mcall	80004a88 <PcdReset+0x74>

	SET_RC522RST;
80004a2e:	31 9c       	mov	r12,25
80004a30:	f0 1f 00 15 	mcall	80004a84 <PcdReset+0x70>
	delay_ns(10);
80004a34:	30 ac       	mov	r12,10
80004a36:	f0 1f 00 15 	mcall	80004a88 <PcdReset+0x74>
	WriteRawRC(CommandReg,PCD_RESETPHASE);
80004a3a:	30 fb       	mov	r11,15
80004a3c:	30 1c       	mov	r12,1
80004a3e:	f0 1f 00 15 	mcall	80004a90 <PcdReset+0x7c>
	WriteRawRC(CommandReg,PCD_RESETPHASE);
80004a42:	30 fb       	mov	r11,15
80004a44:	30 1c       	mov	r12,1
80004a46:	f0 1f 00 13 	mcall	80004a90 <PcdReset+0x7c>
	delay_ns(10);
80004a4a:	30 ac       	mov	r12,10
80004a4c:	f0 1f 00 0f 	mcall	80004a88 <PcdReset+0x74>
	
	WriteRawRC(ModeReg,0x3D);            //Mifare￠璁锛CRC濮0x6363
80004a50:	33 db       	mov	r11,61
80004a52:	31 1c       	mov	r12,17
80004a54:	f0 1f 00 0f 	mcall	80004a90 <PcdReset+0x7c>
	WriteRawRC(TReloadRegL,30);
80004a58:	31 eb       	mov	r11,30
80004a5a:	32 dc       	mov	r12,45
80004a5c:	f0 1f 00 0d 	mcall	80004a90 <PcdReset+0x7c>
	WriteRawRC(TReloadRegH,0);
80004a60:	30 0b       	mov	r11,0
80004a62:	32 cc       	mov	r12,44
80004a64:	f0 1f 00 0b 	mcall	80004a90 <PcdReset+0x7c>
	WriteRawRC(TModeReg,0x8D);
80004a68:	e0 6b 00 8d 	mov	r11,141
80004a6c:	32 ac       	mov	r12,42
80004a6e:	f0 1f 00 09 	mcall	80004a90 <PcdReset+0x7c>
	WriteRawRC(TPrescalerReg,0x3E);
80004a72:	33 eb       	mov	r11,62
80004a74:	32 bc       	mov	r12,43
80004a76:	f0 1f 00 07 	mcall	80004a90 <PcdReset+0x7c>
	
	WriteRawRC(TxAutoReg,0x40);//蹇椤昏
80004a7a:	34 0b       	mov	r11,64
80004a7c:	31 5c       	mov	r12,21
80004a7e:	f0 1f 00 05 	mcall	80004a90 <PcdReset+0x7c>
	
	return MI_OK;
}
80004a82:	d8 0a       	popm	pc,r12=0
80004a84:	80 00       	ld.sh	r0,r0[0x0]
80004a86:	54 04       	stdsp	sp[0x100],r4
80004a88:	80 00       	ld.sh	r0,r0[0x0]
80004a8a:	52 d4       	stdsp	sp[0xb4],r4
80004a8c:	80 00       	ld.sh	r0,r0[0x0]
80004a8e:	54 20       	stdsp	sp[0x108],r0
80004a90:	80 00       	ld.sh	r0,r0[0x0]
80004a92:	49 dc       	lddpc	r12,80004b04 <PcdAntennaOn+0xc>

80004a94 <ReadRawRC>:
//    斤璇RC632瀵瀛
//拌存锛Address[IN]:瀵瀛ㄥ板
//杩    锛璇诲虹
/////////////////////////////////////////////////////////////////////
U8 ReadRawRC(U8   Address)
{
80004a94:	eb cd 40 80 	pushm	r7,lr
80004a98:	18 97       	mov	r7,r12
	U8   ucAddr;
	U8   ucResult=0;
	CLR_SPI_CS;	
80004a9a:	31 8c       	mov	r12,24
80004a9c:	f0 1f 00 0a 	mcall	80004ac4 <ReadRawRC+0x30>
	 
	ucAddr = ((Address<<1)&0x7E)|0x80;
	
	RC522_WriteByte(ucAddr);
80004aa0:	ee 08 15 01 	lsl	r8,r7,0x1
80004aa4:	10 9c       	mov	r12,r8
80004aa6:	e2 1c 00 7e 	andl	r12,0x7e,COH
80004aaa:	a7 bc       	sbr	r12,0x7
80004aac:	f0 1f 00 07 	mcall	80004ac8 <ReadRawRC+0x34>
	ucResult = RC522_ReadByte();
80004ab0:	f0 1f 00 07 	mcall	80004acc <ReadRawRC+0x38>
80004ab4:	18 97       	mov	r7,r12
	
	SET_SPI_CS;
80004ab6:	31 8c       	mov	r12,24
80004ab8:	f0 1f 00 06 	mcall	80004ad0 <ReadRawRC+0x3c>
	return ucResult;
}
80004abc:	0e 9c       	mov	r12,r7
80004abe:	e3 cd 80 80 	ldm	sp++,r7,pc
80004ac2:	00 00       	add	r0,r0
80004ac4:	80 00       	ld.sh	r0,r0[0x0]
80004ac6:	54 20       	stdsp	sp[0x108],r0
80004ac8:	80 00       	ld.sh	r0,r0[0x0]
80004aca:	49 90       	lddpc	r0,80004b2c <ClearBitMask+0x14>
80004acc:	80 00       	ld.sh	r0,r0[0x0]
80004ace:	49 4c       	lddpc	r12,80004b1c <ClearBitMask+0x4>
80004ad0:	80 00       	ld.sh	r0,r0[0x0]
80004ad2:	54 04       	stdsp	sp[0x100],r4

80004ad4 <SetBitMask>:
//    斤缃RC522瀵瀛ㄤ
//拌存锛reg[IN]:瀵瀛ㄥ板
//          mask[IN]:缃浣
/////////////////////////////////////////////////////////////////////
void SetBitMask(U8   reg,U8   mask)
{
80004ad4:	eb cd 40 c0 	pushm	r6-r7,lr
80004ad8:	18 97       	mov	r7,r12
80004ada:	16 96       	mov	r6,r11
	char   tmp = 0x0;
	tmp = ReadRawRC(reg);
80004adc:	f0 1f 00 05 	mcall	80004af0 <SetBitMask+0x1c>
	WriteRawRC(reg,tmp | mask);  // set bit mask
80004ae0:	f9 e6 10 0b 	or	r11,r12,r6
80004ae4:	5c 5b       	castu.b	r11
80004ae6:	0e 9c       	mov	r12,r7
80004ae8:	f0 1f 00 03 	mcall	80004af4 <SetBitMask+0x20>
}
80004aec:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004af0:	80 00       	ld.sh	r0,r0[0x0]
80004af2:	4a 94       	lddpc	r4,80004b94 <M500PcdConfigISOType+0x44>
80004af4:	80 00       	ld.sh	r0,r0[0x0]
80004af6:	49 dc       	lddpc	r12,80004b68 <M500PcdConfigISOType+0x18>

80004af8 <PcdAntennaOn>:
/////////////////////////////////////////////////////////////////////
//寮澶╃嚎
//姣娆″ㄦ抽澶╅╁灏涔村冲1ms撮
/////////////////////////////////////////////////////////////////////
void PcdAntennaOn(void)
{
80004af8:	d4 01       	pushm	lr
	U8   i;
	i = ReadRawRC(TxControlReg);
80004afa:	31 4c       	mov	r12,20
80004afc:	f0 1f 00 05 	mcall	80004b10 <PcdAntennaOn+0x18>
	if (!(i & 0x03))
80004b00:	f9 dc c0 02 	bfextu	r12,r12,0x0,0x2
80004b04:	c0 51       	brne	80004b0e <PcdAntennaOn+0x16>
	{
		SetBitMask(TxControlReg, 0x03);
80004b06:	30 3b       	mov	r11,3
80004b08:	31 4c       	mov	r12,20
80004b0a:	f0 1f 00 03 	mcall	80004b14 <PcdAntennaOn+0x1c>
80004b0e:	d8 02       	popm	pc
80004b10:	80 00       	ld.sh	r0,r0[0x0]
80004b12:	4a 94       	lddpc	r4,80004bb4 <M500PcdConfigISOType+0x64>
80004b14:	80 00       	ld.sh	r0,r0[0x0]
80004b16:	4a d4       	lddpc	r4,80004bc8 <rc522_init+0x8>

80004b18 <ClearBitMask>:
//    斤娓RC522瀵瀛ㄤ
//拌存锛reg[IN]:瀵瀛ㄥ板
//         mask[IN]:娓浣
/////////////////////////////////////////////////////////////////////
void ClearBitMask(U8   reg,U8   mask)
{
80004b18:	eb cd 40 c0 	pushm	r6-r7,lr
80004b1c:	18 97       	mov	r7,r12
80004b1e:	16 96       	mov	r6,r11
	  char   tmp = 0x0;
	  tmp = ReadRawRC(reg);
80004b20:	f0 1f 00 06 	mcall	80004b38 <ClearBitMask+0x20>
	  WriteRawRC(reg, tmp & ~mask);  // clear bit mask
80004b24:	5c d6       	com	r6
80004b26:	f9 e6 00 06 	and	r6,r12,r6
80004b2a:	f7 d6 c0 08 	bfextu	r11,r6,0x0,0x8
80004b2e:	0e 9c       	mov	r12,r7
80004b30:	f0 1f 00 03 	mcall	80004b3c <ClearBitMask+0x24>
	
}
80004b34:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004b38:	80 00       	ld.sh	r0,r0[0x0]
80004b3a:	4a 94       	lddpc	r4,80004bdc <rc522_init+0x1c>
80004b3c:	80 00       	ld.sh	r0,r0[0x0]
80004b3e:	49 dc       	lddpc	r12,80004bb0 <M500PcdConfigISOType+0x60>

80004b40 <PcdAntennaOff>:

/////////////////////////////////////////////////////////////////////
//抽澶╃嚎
/////////////////////////////////////////////////////////////////////
void PcdAntennaOff(void)
{
80004b40:	d4 01       	pushm	lr
	ClearBitMask(TxControlReg, 0x03);
80004b42:	30 3b       	mov	r11,3
80004b44:	31 4c       	mov	r12,20
80004b46:	f0 1f 00 02 	mcall	80004b4c <PcdAntennaOff+0xc>
}
80004b4a:	d8 02       	popm	pc
80004b4c:	80 00       	ld.sh	r0,r0[0x0]
80004b4e:	4b 18       	lddpc	r8,80004c10 <rc522_init+0x50>

80004b50 <M500PcdConfigISOType>:

//////////////////////////////////////////////////////////////////////
//璁剧疆RC632宸ヤ瑰
//////////////////////////////////////////////////////////////////////
char M500PcdConfigISOType(U8   type)
{
80004b50:	d4 01       	pushm	lr
	if (type == 'A')                     //ISO14443_A
80004b52:	34 18       	mov	r8,65
80004b54:	f0 0c 18 00 	cp.b	r12,r8
80004b58:	c0 20       	breq	80004b5c <M500PcdConfigISOType+0xc>
80004b5a:	da 0a       	popm	pc,r12=1
	{
		ClearBitMask(Status2Reg,0x08);
80004b5c:	30 8b       	mov	r11,8
80004b5e:	16 9c       	mov	r12,r11
80004b60:	f0 1f 00 14 	mcall	80004bb0 <M500PcdConfigISOType+0x60>
		WriteRawRC(ModeReg,0x3D);//3F
80004b64:	33 db       	mov	r11,61
80004b66:	31 1c       	mov	r12,17
80004b68:	f0 1f 00 13 	mcall	80004bb4 <M500PcdConfigISOType+0x64>
		WriteRawRC(RxSelReg,0x86);//84
80004b6c:	e0 6b 00 86 	mov	r11,134
80004b70:	31 7c       	mov	r12,23
80004b72:	f0 1f 00 11 	mcall	80004bb4 <M500PcdConfigISOType+0x64>
		WriteRawRC(RFCfgReg,0x7F);   //4F
80004b76:	37 fb       	mov	r11,127
80004b78:	32 6c       	mov	r12,38
80004b7a:	f0 1f 00 0f 	mcall	80004bb4 <M500PcdConfigISOType+0x64>
		WriteRawRC(TReloadRegL,30);//tmoLength);// TReloadVal = 'h6a =tmoLength(dec)
80004b7e:	31 eb       	mov	r11,30
80004b80:	32 dc       	mov	r12,45
80004b82:	f0 1f 00 0d 	mcall	80004bb4 <M500PcdConfigISOType+0x64>
		WriteRawRC(TReloadRegH,0);
80004b86:	30 0b       	mov	r11,0
80004b88:	32 cc       	mov	r12,44
80004b8a:	f0 1f 00 0b 	mcall	80004bb4 <M500PcdConfigISOType+0x64>
		WriteRawRC(TModeReg,0x8D);
80004b8e:	e0 6b 00 8d 	mov	r11,141
80004b92:	32 ac       	mov	r12,42
80004b94:	f0 1f 00 08 	mcall	80004bb4 <M500PcdConfigISOType+0x64>
		WriteRawRC(TPrescalerReg,0x3E);
80004b98:	33 eb       	mov	r11,62
80004b9a:	32 bc       	mov	r12,43
80004b9c:	f0 1f 00 06 	mcall	80004bb4 <M500PcdConfigISOType+0x64>
		delay_ns(1000);
80004ba0:	e0 6c 03 e8 	mov	r12,1000
80004ba4:	f0 1f 00 05 	mcall	80004bb8 <M500PcdConfigISOType+0x68>
		PcdAntennaOn();
80004ba8:	f0 1f 00 05 	mcall	80004bbc <M500PcdConfigISOType+0x6c>
80004bac:	d8 0a       	popm	pc,r12=0
80004bae:	00 00       	add	r0,r0
80004bb0:	80 00       	ld.sh	r0,r0[0x0]
80004bb2:	4b 18       	lddpc	r8,80004c74 <rc522_init+0xb4>
80004bb4:	80 00       	ld.sh	r0,r0[0x0]
80004bb6:	49 dc       	lddpc	r12,80004c28 <rc522_init+0x68>
80004bb8:	80 00       	ld.sh	r0,r0[0x0]
80004bba:	52 d4       	stdsp	sp[0xb4],r4
80004bbc:	80 00       	ld.sh	r0,r0[0x0]
80004bbe:	4a f8       	lddpc	r8,80004c78 <rc522_init+0xb8>

80004bc0 <rc522_init>:


//mfrc522 init

void rc522_init()
{
80004bc0:	eb cd 40 c0 	pushm	r6-r7,lr
80004bc4:	20 4d       	sub	sp,16
		.spck_delay   = 0,
		.trans_delay  = 0,
		.stay_act     = 1,
		.spi_mode     = 0,
		.modfdis      = 1
	};
80004bc6:	4a 28       	lddpc	r8,80004c4c <rc522_init+0x8c>
80004bc8:	1a 96       	mov	r6,sp
80004bca:	f0 ea 00 00 	ld.d	r10,r8[0]
80004bce:	fa eb 00 00 	st.d	sp[0],r10
80004bd2:	f0 e8 00 08 	ld.d	r8,r8[8]
80004bd6:	fa e9 00 08 	st.d	sp[8],r8

	// Assign I/Os to SPI.
	gpio_enable_module(RC522_SPI_GPIO_MAP, sizeof(RC522_SPI_GPIO_MAP) / sizeof(RC522_SPI_GPIO_MAP[0]));
80004bda:	30 4b       	mov	r11,4
80004bdc:	49 dc       	lddpc	r12,80004c50 <rc522_init+0x90>
80004bde:	f0 1f 00 1e 	mcall	80004c54 <rc522_init+0x94>

	// Configure PA25 as RST pin
	gpio_enable_gpio_pin(AVR32_PIN_PA25);
80004be2:	31 9c       	mov	r12,25
80004be4:	f0 1f 00 1d 	mcall	80004c58 <rc522_init+0x98>
	gpio_set_gpio_pin(AVR32_PIN_PA25);
80004be8:	31 9c       	mov	r12,25
80004bea:	f0 1f 00 1d 	mcall	80004c5c <rc522_init+0x9c>
	
	//gpio_enable_gpio_pin(AVR32_PIN_PA24);

	spi = &AVR32_SPI;
80004bee:	49 d7       	lddpc	r7,80004c60 <rc522_init+0xa0>
80004bf0:	fe 7c 24 00 	mov	r12,-56320
80004bf4:	8f 0c       	st.w	r7[0x0],r12

	// Initialize as master.
	spi_initMaster(spi, &spiOptions);
80004bf6:	1a 9b       	mov	r11,sp
80004bf8:	f0 1f 00 1b 	mcall	80004c64 <rc522_init+0xa4>

	// Set selection mode: variable_ps, pcs_decode, delay.
	spi_selectionMode(spi, 0, 0, 0);
80004bfc:	30 09       	mov	r9,0
80004bfe:	12 9a       	mov	r10,r9
80004c00:	12 9b       	mov	r11,r9
80004c02:	6e 0c       	ld.w	r12,r7[0x0]
80004c04:	f0 1f 00 19 	mcall	80004c68 <rc522_init+0xa8>

	// Enable SPI.
	spi_enable(spi);
80004c08:	6e 0c       	ld.w	r12,r7[0x0]
80004c0a:	f0 1f 00 19 	mcall	80004c6c <rc522_init+0xac>

	// Initialize RC522 with SPI clock PBA.
	if (spi_setupChipReg(spi, &spiOptions, 2*12000000) != SPI_OK)
80004c0e:	e0 6a 36 00 	mov	r10,13824
80004c12:	ea 1a 01 6e 	orh	r10,0x16e
80004c16:	1a 9b       	mov	r11,sp
80004c18:	6e 0c       	ld.w	r12,r7[0x0]
80004c1a:	f0 1f 00 16 	mcall	80004c70 <rc522_init+0xb0>
80004c1e:	c0 50       	breq	80004c28 <rc522_init+0x68>
	{
		
		rc522_init_failure = FATAL_ERROR_RC522_SPI_INIT;
80004c20:	30 29       	mov	r9,2
80004c22:	49 58       	lddpc	r8,80004c74 <rc522_init+0xb4>
80004c24:	b0 89       	st.b	r8[0x0],r9
80004c26:	c0 38       	rjmp	80004c2c <rc522_init+0x6c>
		return;
	}
	
	RC522_SPI_SetSpeedLow();
80004c28:	f0 1f 00 14 	mcall	80004c78 <rc522_init+0xb8>
void rc522_init()
{
	
	spi_init();
	
	PcdReset();
80004c2c:	f0 1f 00 14 	mcall	80004c7c <rc522_init+0xbc>
	
	PcdAntennaOff();
80004c30:	f0 1f 00 14 	mcall	80004c80 <rc522_init+0xc0>
	
	delay_ms(2); 
80004c34:	30 2c       	mov	r12,2
80004c36:	f0 1f 00 14 	mcall	80004c84 <rc522_init+0xc4>
	
	PcdAntennaOn();
80004c3a:	f0 1f 00 14 	mcall	80004c88 <rc522_init+0xc8>
	
	M500PcdConfigISOType( 'A' );
80004c3e:	34 1c       	mov	r12,65
80004c40:	f0 1f 00 13 	mcall	80004c8c <rc522_init+0xcc>
	

80004c44:	2f cd       	sub	sp,-16
80004c46:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004c4a:	00 00       	add	r0,r0
80004c4c:	80 00       	ld.sh	r0,r0[0x0]
80004c4e:	d5 94       	*unknown*
80004c50:	80 00       	ld.sh	r0,r0[0x0]
80004c52:	d5 6c       	*unknown*
80004c54:	80 00       	ld.sh	r0,r0[0x0]
80004c56:	53 bc       	stdsp	sp[0xec],r12
80004c58:	80 00       	ld.sh	r0,r0[0x0]
80004c5a:	53 ec       	stdsp	sp[0xf8],r12
80004c5c:	80 00       	ld.sh	r0,r0[0x0]
80004c5e:	54 04       	stdsp	sp[0x100],r4
80004c60:	00 00       	add	r0,r0
80004c62:	1d 84       	ld.ub	r4,lr[0x0]
80004c64:	80 00       	ld.sh	r0,r0[0x0]
80004c66:	56 dc       	stdsp	sp[0x1b4],r12
80004c68:	80 00       	ld.sh	r0,r0[0x0]
80004c6a:	57 14       	stdsp	sp[0x1c4],r4
80004c6c:	80 00       	ld.sh	r0,r0[0x0]
80004c6e:	57 40       	stdsp	sp[0x1d0],r0
80004c70:	80 00       	ld.sh	r0,r0[0x0]
80004c72:	57 84       	stdsp	sp[0x1e0],r4
80004c74:	00 00       	add	r0,r0
80004c76:	0b 5c       	ld.sh	r12,--r5
80004c78:	80 00       	ld.sh	r0,r0[0x0]
80004c7a:	49 3c       	lddpc	r12,80004cc4 <PcdComMF522+0x34>
80004c7c:	80 00       	ld.sh	r0,r0[0x0]
80004c7e:	4a 14       	lddpc	r4,80004d00 <PcdComMF522+0x70>
80004c80:	80 00       	ld.sh	r0,r0[0x0]
80004c82:	4b 40       	lddpc	r0,80004d50 <PcdComMF522+0xc0>
80004c84:	80 00       	ld.sh	r0,r0[0x0]
80004c86:	53 14       	stdsp	sp[0xc4],r4
80004c88:	80 00       	ld.sh	r0,r0[0x0]
80004c8a:	4a f8       	lddpc	r8,80004d44 <PcdComMF522+0xb4>
80004c8c:	80 00       	ld.sh	r0,r0[0x0]
80004c8e:	4b 50       	lddpc	r0,80004d60 <PcdComMF522+0xd0>

80004c90 <PcdComMF522>:
char PcdComMF522(U8  Command,
				 U8 *pIn ,
				 U8  InLenByte,
				 U8 *pOut ,
				 U8 *pOutLenBit)
{
80004c90:	d4 31       	pushm	r0-r7,lr
80004c92:	20 1d       	sub	sp,4
80004c94:	18 92       	mov	r2,r12
80004c96:	16 95       	mov	r5,r11
80004c98:	14 96       	mov	r6,r10
80004c9a:	50 09       	stdsp	sp[0x0],r9
80004c9c:	10 90       	mov	r0,r8
80004c9e:	f8 c8 00 0c 	sub	r8,r12,12
80004ca2:	5c 58       	castu.b	r8
80004ca4:	30 29       	mov	r9,2
80004ca6:	f2 08 18 00 	cp.b	r8,r9
80004caa:	e0 88 00 05 	brls	80004cb4 <PcdComMF522+0x24>
80004cae:	30 03       	mov	r3,0
80004cb0:	06 91       	mov	r1,r3
80004cb2:	c0 78       	rjmp	80004cc0 <PcdComMF522+0x30>
80004cb4:	4c f9       	lddpc	r9,80004df0 <PcdComMF522+0x160>
80004cb6:	f2 08 07 01 	ld.ub	r1,r9[r8]
80004cba:	4c f9       	lddpc	r9,80004df4 <PcdComMF522+0x164>
80004cbc:	f2 08 07 03 	ld.ub	r3,r9[r8]
		break;
		default:
		break;
	}
	
	WriteRawRC(ComIEnReg,irqEn|0x80);
80004cc0:	02 9b       	mov	r11,r1
80004cc2:	a7 bb       	sbr	r11,0x7
80004cc4:	30 2c       	mov	r12,2
80004cc6:	f0 1f 00 4d 	mcall	80004df8 <PcdComMF522+0x168>
	ClearBitMask(ComIrqReg,0x80);	//娓涓浣
80004cca:	e0 6b 00 80 	mov	r11,128
80004cce:	30 4c       	mov	r12,4
80004cd0:	f0 1f 00 4b 	mcall	80004dfc <PcdComMF522+0x16c>
	WriteRawRC(CommandReg,PCD_IDLE);
80004cd4:	30 0b       	mov	r11,0
80004cd6:	30 1c       	mov	r12,1
80004cd8:	f0 1f 00 48 	mcall	80004df8 <PcdComMF522+0x168>
	SetBitMask(FIFOLevelReg,0x80);	 	//娓FIFO缂瀛
80004cdc:	e0 6b 00 80 	mov	r11,128
80004ce0:	30 ac       	mov	r12,10
80004ce2:	f0 1f 00 48 	mcall	80004e00 <PcdComMF522+0x170>
	
	for (i=0; i<InLenByte; i++)
80004ce6:	58 06       	cp.w	r6,0
80004ce8:	c0 c0       	breq	80004d00 <PcdComMF522+0x70>
80004cea:	0a 97       	mov	r7,r5
	{   
		WriteRawRC(FIFODataReg, pIn [i]);
80004cec:	30 94       	mov	r4,9
80004cee:	0f 3b       	ld.ub	r11,r7++
80004cf0:	08 9c       	mov	r12,r4
80004cf2:	f0 1f 00 42 	mcall	80004df8 <PcdComMF522+0x168>
	WriteRawRC(ComIEnReg,irqEn|0x80);
	ClearBitMask(ComIrqReg,0x80);	//娓涓浣
	WriteRawRC(CommandReg,PCD_IDLE);
	SetBitMask(FIFOLevelReg,0x80);	 	//娓FIFO缂瀛
	
	for (i=0; i<InLenByte; i++)
80004cf6:	0e 98       	mov	r8,r7
80004cf8:	0a 18       	sub	r8,r5
80004cfa:	ec 08 19 00 	cp.h	r8,r6
80004cfe:	cf 83       	brcs	80004cee <PcdComMF522+0x5e>
	{   
		WriteRawRC(FIFODataReg, pIn [i]);
	}
	WriteRawRC(CommandReg, Command);
80004d00:	04 9b       	mov	r11,r2
80004d02:	30 1c       	mov	r12,1
80004d04:	f0 1f 00 3d 	mcall	80004df8 <PcdComMF522+0x168>
	
	if (Command == PCD_TRANSCEIVE)
80004d08:	30 c8       	mov	r8,12
80004d0a:	f0 02 18 00 	cp.b	r2,r8
80004d0e:	c0 61       	brne	80004d1a <PcdComMF522+0x8a>
	{    
		SetBitMask(BitFramingReg,0x80);  
80004d10:	e0 6b 00 80 	mov	r11,128
80004d14:	30 dc       	mov	r12,13
80004d16:	f0 1f 00 3b 	mcall	80004e00 <PcdComMF522+0x170>
	
	//i = 600;//规堕棰璋达浣M1℃澶х寰堕25ms
	i = 2000;
	do
	{
		n = ReadRawRC(ComIrqReg);
80004d1a:	30 4c       	mov	r12,4
80004d1c:	f0 1f 00 3a 	mcall	80004e04 <PcdComMF522+0x174>
80004d20:	18 97       	mov	r7,r12
80004d22:	e0 66 07 cf 	mov	r6,1999
		i--;
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
80004d26:	30 05       	mov	r5,0
	
	//i = 600;//规堕棰璋达浣M1℃澶х寰堕25ms
	i = 2000;
	do
	{
		n = ReadRawRC(ComIrqReg);
80004d28:	30 44       	mov	r4,4
80004d2a:	c0 88       	rjmp	80004d3a <PcdComMF522+0xaa>
80004d2c:	08 9c       	mov	r12,r4
80004d2e:	f0 1f 00 36 	mcall	80004e04 <PcdComMF522+0x174>
80004d32:	18 97       	mov	r7,r12
		i--;
80004d34:	20 16       	sub	r6,1
80004d36:	5c 86       	casts.h	r6
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
80004d38:	c0 a0       	breq	80004d4c <PcdComMF522+0xbc>
80004d3a:	f1 d7 c0 01 	bfextu	r8,r7,0x0,0x1
80004d3e:	c4 c1       	brne	80004dd6 <PcdComMF522+0x146>
80004d40:	ef e3 00 08 	and	r8,r7,r3
80004d44:	ea 08 18 00 	cp.b	r8,r5
80004d48:	cf 20       	breq	80004d2c <PcdComMF522+0x9c>
80004d4a:	c4 68       	rjmp	80004dd6 <PcdComMF522+0x146>
	ClearBitMask(BitFramingReg,0x80);
80004d4c:	e0 6b 00 80 	mov	r11,128
80004d50:	30 dc       	mov	r12,13
80004d52:	f0 1f 00 2b 	mcall	80004dfc <PcdComMF522+0x16c>
80004d56:	30 27       	mov	r7,2
80004d58:	c3 38       	rjmp	80004dbe <PcdComMF522+0x12e>
80004d5a:	02 67       	and	r7,r1
80004d5c:	ef d7 c0 01 	bfextu	r7,r7,0x0,0x1
		if(!(ReadRawRC(ErrorReg)&0x1B))
		{
			status = MI_OK;
			if (n & irqEn & 0x01)
			{   status = MI_NOTAGERR;   }
			if (Command == PCD_TRANSCEIVE)
80004d60:	30 c8       	mov	r8,12
80004d62:	f0 02 18 00 	cp.b	r2,r8
80004d66:	c2 c1       	brne	80004dbe <PcdComMF522+0x12e>
			{
				n = ReadRawRC(FIFOLevelReg);
80004d68:	30 ac       	mov	r12,10
80004d6a:	f0 1f 00 27 	mcall	80004e04 <PcdComMF522+0x174>
80004d6e:	18 94       	mov	r4,r12
				lastBits = ReadRawRC(ControlReg) & 0x07;
80004d70:	30 cc       	mov	r12,12
80004d72:	f0 1f 00 25 	mcall	80004e04 <PcdComMF522+0x174>
80004d76:	f9 dc c0 03 	bfextu	r12,r12,0x0,0x3
				if (lastBits)
80004d7a:	c0 70       	breq	80004d88 <PcdComMF522+0xf8>
				{   *pOutLenBit = (n-1)*8 + lastBits;   }
80004d7c:	08 98       	mov	r8,r4
80004d7e:	20 18       	sub	r8,1
80004d80:	f8 08 00 3c 	add	r12,r12,r8<<0x3
80004d84:	a0 8c       	st.b	r0[0x0],r12
80004d86:	c0 48       	rjmp	80004d8e <PcdComMF522+0xfe>
				else
				{   *pOutLenBit = n*8;   }
80004d88:	e8 08 15 03 	lsl	r8,r4,0x3
80004d8c:	a0 88       	st.b	r0[0x0],r8
				if (n == 0)
80004d8e:	58 04       	cp.w	r4,0
80004d90:	c0 61       	brne	80004d9c <PcdComMF522+0x10c>
80004d92:	30 14       	mov	r4,1
80004d94:	40 05       	lddsp	r5,sp[0x0]
80004d96:	0a 96       	mov	r6,r5
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
				{   pOut [i] = ReadRawRC(FIFODataReg);    }
80004d98:	30 93       	mov	r3,9
80004d9a:	c0 98       	rjmp	80004dac <PcdComMF522+0x11c>
				{   *pOutLenBit = n*8;   }
				if (n == 0)
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
80004d9c:	31 28       	mov	r8,18
80004d9e:	f0 04 18 00 	cp.b	r4,r8
80004da2:	f9 b4 0b 12 	movhi	r4,18
80004da6:	58 04       	cp.w	r4,0
80004da8:	cf 61       	brne	80004d94 <PcdComMF522+0x104>
80004daa:	c0 a8       	rjmp	80004dbe <PcdComMF522+0x12e>
				{   pOut [i] = ReadRawRC(FIFODataReg);    }
80004dac:	06 9c       	mov	r12,r3
80004dae:	f0 1f 00 16 	mcall	80004e04 <PcdComMF522+0x174>
80004db2:	0c cc       	st.b	r6++,r12
				{   *pOutLenBit = n*8;   }
				if (n == 0)
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
80004db4:	ec 05 01 08 	sub	r8,r6,r5
80004db8:	e8 08 19 00 	cp.h	r8,r4
80004dbc:	cf 83       	brcs	80004dac <PcdComMF522+0x11c>
		{   status = MI_ERR;   }
		
	}
	

	SetBitMask(ControlReg,0x80);           // stop timer now
80004dbe:	e0 6b 00 80 	mov	r11,128
80004dc2:	30 cc       	mov	r12,12
80004dc4:	f0 1f 00 0f 	mcall	80004e00 <PcdComMF522+0x170>
	WriteRawRC(CommandReg,PCD_IDLE);
80004dc8:	30 0b       	mov	r11,0
80004dca:	30 1c       	mov	r12,1
80004dcc:	f0 1f 00 0b 	mcall	80004df8 <PcdComMF522+0x168>
	return status;
}
80004dd0:	0e 9c       	mov	r12,r7
80004dd2:	2f fd       	sub	sp,-4
80004dd4:	d8 32       	popm	r0-r7,pc
	{
		n = ReadRawRC(ComIrqReg);
		i--;
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
	ClearBitMask(BitFramingReg,0x80);
80004dd6:	e0 6b 00 80 	mov	r11,128
80004dda:	30 dc       	mov	r12,13
80004ddc:	f0 1f 00 08 	mcall	80004dfc <PcdComMF522+0x16c>

	if (i!=0)
	{
		if(!(ReadRawRC(ErrorReg)&0x1B))
80004de0:	30 6c       	mov	r12,6
80004de2:	f0 1f 00 09 	mcall	80004e04 <PcdComMF522+0x174>
80004de6:	e2 1c 00 1b 	andl	r12,0x1b,COH
80004dea:	cb 80       	breq	80004d5a <PcdComMF522+0xca>
80004dec:	30 27       	mov	r7,2
80004dee:	ce 8b       	rjmp	80004dbe <PcdComMF522+0x12e>
80004df0:	80 00       	ld.sh	r0,r0[0x0]
80004df2:	d5 8c       	*unknown*
80004df4:	80 00       	ld.sh	r0,r0[0x0]
80004df6:	d5 90       	acall	0x59
80004df8:	80 00       	ld.sh	r0,r0[0x0]
80004dfa:	49 dc       	lddpc	r12,80004e6c <PcdAnticoll+0x64>
80004dfc:	80 00       	ld.sh	r0,r0[0x0]
80004dfe:	4b 18       	lddpc	r8,80004ec0 <PcdRequest+0x34>
80004e00:	80 00       	ld.sh	r0,r0[0x0]
80004e02:	4a d4       	lddpc	r4,80004eb4 <PcdRequest+0x28>
80004e04:	80 00       	ld.sh	r0,r0[0x0]
80004e06:	4a 94       	lddpc	r4,80004ea8 <PcdRequest+0x1c>

80004e08 <PcdAnticoll>:
//    斤插叉
//拌存: pSnr[OUT]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdAnticoll(U8 *pSnr)
{
80004e08:	eb cd 40 c0 	pushm	r6-r7,lr
80004e0c:	20 5d       	sub	sp,20
80004e0e:	18 96       	mov	r6,r12
	U8   i,snr_check=0;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];
	

	ClearBitMask(Status2Reg,0x08);
80004e10:	30 8b       	mov	r11,8
80004e12:	16 9c       	mov	r12,r11
80004e14:	f0 1f 00 1a 	mcall	80004e7c <PcdAnticoll+0x74>
	WriteRawRC(BitFramingReg,0x00);
80004e18:	30 0b       	mov	r11,0
80004e1a:	30 dc       	mov	r12,13
80004e1c:	f0 1f 00 19 	mcall	80004e80 <PcdAnticoll+0x78>
	ClearBitMask(CollReg,0x80);
80004e20:	e0 6b 00 80 	mov	r11,128
80004e24:	30 ec       	mov	r12,14
80004e26:	f0 1f 00 16 	mcall	80004e7c <PcdAnticoll+0x74>
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
80004e2a:	39 38       	mov	r8,-109
80004e2c:	ba 88       	st.b	sp[0x0],r8
	ucComMF522Buf[1] = 0x20;
80004e2e:	32 08       	mov	r8,32
80004e30:	ba 98       	st.b	sp[0x1],r8

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,2,ucComMF522Buf,&unLen);
80004e32:	1a 9b       	mov	r11,sp
80004e34:	fa c8 ff ed 	sub	r8,sp,-19
80004e38:	1a 99       	mov	r9,sp
80004e3a:	30 2a       	mov	r10,2
80004e3c:	30 cc       	mov	r12,12
80004e3e:	f0 1f 00 12 	mcall	80004e84 <PcdAnticoll+0x7c>
80004e42:	18 97       	mov	r7,r12

	if (status == MI_OK)
80004e44:	c1 21       	brne	80004e68 <PcdAnticoll+0x60>
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
80004e46:	1b 89       	ld.ub	r9,sp[0x0]
80004e48:	ac 89       	st.b	r6[0x0],r9
80004e4a:	1b 98       	ld.ub	r8,sp[0x1]
80004e4c:	ac 98       	st.b	r6[0x1],r8
			snr_check ^= ucComMF522Buf[i];
80004e4e:	10 59       	eor	r9,r8

	if (status == MI_OK)
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
80004e50:	1b a8       	ld.ub	r8,sp[0x2]
80004e52:	ac a8       	st.b	r6[0x2],r8
			snr_check ^= ucComMF522Buf[i];
80004e54:	f3 e8 20 08 	eor	r8,r9,r8

	if (status == MI_OK)
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
80004e58:	1b b9       	ld.ub	r9,sp[0x3]
80004e5a:	ac b9       	st.b	r6[0x3],r9
			snr_check ^= ucComMF522Buf[i];
80004e5c:	12 58       	eor	r8,r9
		}
		if (snr_check != ucComMF522Buf[i])
80004e5e:	1b c9       	ld.ub	r9,sp[0x4]
80004e60:	f0 09 18 00 	cp.b	r9,r8
80004e64:	f9 b7 01 02 	movne	r7,2
		{   status = MI_ERR;    }
	}
	
	SetBitMask(CollReg,0x80);
80004e68:	e0 6b 00 80 	mov	r11,128
80004e6c:	30 ec       	mov	r12,14
80004e6e:	f0 1f 00 07 	mcall	80004e88 <PcdAnticoll+0x80>
	return status;
}
80004e72:	0e 9c       	mov	r12,r7
80004e74:	2f bd       	sub	sp,-20
80004e76:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004e7a:	00 00       	add	r0,r0
80004e7c:	80 00       	ld.sh	r0,r0[0x0]
80004e7e:	4b 18       	lddpc	r8,80004f40 <CalulateCRC+0x50>
80004e80:	80 00       	ld.sh	r0,r0[0x0]
80004e82:	49 dc       	lddpc	r12,80004ef4 <CalulateCRC+0x4>
80004e84:	80 00       	ld.sh	r0,r0[0x0]
80004e86:	4c 90       	lddpc	r0,80004fa8 <PcdSelect+0x2c>
80004e88:	80 00       	ld.sh	r0,r0[0x0]
80004e8a:	4a d4       	lddpc	r4,80004f3c <CalulateCRC+0x4c>

80004e8c <PcdRequest>:
//                0x0800 = Mifare_Pro(X)
//                0x4403 = Mifare_DESFire
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdRequest(U8   req_code,U8 *pTagType)
{
80004e8c:	eb cd 40 c0 	pushm	r6-r7,lr
80004e90:	20 5d       	sub	sp,20
80004e92:	18 97       	mov	r7,r12
80004e94:	16 96       	mov	r6,r11
	char   status;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];

	ClearBitMask(Status2Reg,0x08);
80004e96:	30 8b       	mov	r11,8
80004e98:	16 9c       	mov	r12,r11
80004e9a:	f0 1f 00 12 	mcall	80004ee0 <PcdRequest+0x54>
	WriteRawRC(BitFramingReg,0x07);
80004e9e:	30 7b       	mov	r11,7
80004ea0:	30 dc       	mov	r12,13
80004ea2:	f0 1f 00 11 	mcall	80004ee4 <PcdRequest+0x58>
	SetBitMask(TxControlReg,0x03);
80004ea6:	30 3b       	mov	r11,3
80004ea8:	31 4c       	mov	r12,20
80004eaa:	f0 1f 00 10 	mcall	80004ee8 <PcdRequest+0x5c>
	
	ucComMF522Buf[0] = req_code;
80004eae:	ba 87       	st.b	sp[0x0],r7

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,1,ucComMF522Buf,&unLen);
80004eb0:	1a 9b       	mov	r11,sp
80004eb2:	fa c8 ff ed 	sub	r8,sp,-19
80004eb6:	1a 99       	mov	r9,sp
80004eb8:	30 1a       	mov	r10,1
80004eba:	30 cc       	mov	r12,12
80004ebc:	f0 1f 00 0c 	mcall	80004eec <PcdRequest+0x60>

	if ((status == MI_OK) && (unLen == 0x10))
80004ec0:	c0 c1       	brne	80004ed8 <PcdRequest+0x4c>
80004ec2:	31 08       	mov	r8,16
80004ec4:	fb 39 00 13 	ld.ub	r9,sp[19]
80004ec8:	f0 09 18 00 	cp.b	r9,r8
80004ecc:	c0 61       	brne	80004ed8 <PcdRequest+0x4c>
	{
		*pTagType     = ucComMF522Buf[0];
80004ece:	1b 88       	ld.ub	r8,sp[0x0]
80004ed0:	ac 88       	st.b	r6[0x0],r8
		*(pTagType+1) = ucComMF522Buf[1];
80004ed2:	1b 98       	ld.ub	r8,sp[0x1]
80004ed4:	ac 98       	st.b	r6[0x1],r8
	
	ucComMF522Buf[0] = req_code;

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,1,ucComMF522Buf,&unLen);

	if ((status == MI_OK) && (unLen == 0x10))
80004ed6:	c0 28       	rjmp	80004eda <PcdRequest+0x4e>
80004ed8:	30 2c       	mov	r12,2
	}
	else
	{   status = MI_ERR;   }
	
	return status;
}
80004eda:	2f bd       	sub	sp,-20
80004edc:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004ee0:	80 00       	ld.sh	r0,r0[0x0]
80004ee2:	4b 18       	lddpc	r8,80004fa4 <PcdSelect+0x28>
80004ee4:	80 00       	ld.sh	r0,r0[0x0]
80004ee6:	49 dc       	lddpc	r12,80004f58 <CalulateCRC+0x68>
80004ee8:	80 00       	ld.sh	r0,r0[0x0]
80004eea:	4a d4       	lddpc	r4,80004f9c <PcdSelect+0x20>
80004eec:	80 00       	ld.sh	r0,r0[0x0]
80004eee:	4c 90       	lddpc	r0,80005010 <rfid_auto_reader+0x20>

80004ef0 <CalulateCRC>:

/////////////////////////////////////////////////////////////////////
//MF522璁＄CRC16芥
/////////////////////////////////////////////////////////////////////
void CalulateCRC(U8 *pIn ,U8   len,U8 *pOut )
{
80004ef0:	eb cd 40 f8 	pushm	r3-r7,lr
80004ef4:	18 95       	mov	r5,r12
80004ef6:	16 96       	mov	r6,r11
80004ef8:	14 93       	mov	r3,r10
	U8   i,n;
	ClearBitMask(DivIrqReg,0x04);
80004efa:	30 4b       	mov	r11,4
80004efc:	30 5c       	mov	r12,5
80004efe:	f0 1f 00 1c 	mcall	80004f6c <CalulateCRC+0x7c>
	WriteRawRC(CommandReg,PCD_IDLE);
80004f02:	30 0b       	mov	r11,0
80004f04:	30 1c       	mov	r12,1
80004f06:	f0 1f 00 1b 	mcall	80004f70 <CalulateCRC+0x80>
	SetBitMask(FIFOLevelReg,0x80);
80004f0a:	e0 6b 00 80 	mov	r11,128
80004f0e:	30 ac       	mov	r12,10
80004f10:	f0 1f 00 19 	mcall	80004f74 <CalulateCRC+0x84>
	for (i=0; i<len; i++)
80004f14:	58 06       	cp.w	r6,0
80004f16:	c0 c0       	breq	80004f2e <CalulateCRC+0x3e>
80004f18:	0a 97       	mov	r7,r5
	{   WriteRawRC(FIFODataReg, *(pIn +i));   }
80004f1a:	30 94       	mov	r4,9
80004f1c:	0f 3b       	ld.ub	r11,r7++
80004f1e:	08 9c       	mov	r12,r4
80004f20:	f0 1f 00 14 	mcall	80004f70 <CalulateCRC+0x80>
{
	U8   i,n;
	ClearBitMask(DivIrqReg,0x04);
	WriteRawRC(CommandReg,PCD_IDLE);
	SetBitMask(FIFOLevelReg,0x80);
	for (i=0; i<len; i++)
80004f24:	0e 98       	mov	r8,r7
80004f26:	0a 18       	sub	r8,r5
80004f28:	ec 08 18 00 	cp.b	r8,r6
80004f2c:	cf 83       	brcs	80004f1c <CalulateCRC+0x2c>
	{   WriteRawRC(FIFODataReg, *(pIn +i));   }
	WriteRawRC(CommandReg, PCD_CALCCRC);
80004f2e:	30 3b       	mov	r11,3
80004f30:	30 1c       	mov	r12,1
80004f32:	f0 1f 00 10 	mcall	80004f70 <CalulateCRC+0x80>
	i = 0xFF;
	do
	{
		n = ReadRawRC(DivIrqReg);
80004f36:	30 5c       	mov	r12,5
80004f38:	f0 1f 00 10 	mcall	80004f78 <CalulateCRC+0x88>
80004f3c:	e0 67 00 fe 	mov	r7,254
80004f40:	30 56       	mov	r6,5
80004f42:	c0 78       	rjmp	80004f50 <CalulateCRC+0x60>
80004f44:	0c 9c       	mov	r12,r6
80004f46:	f0 1f 00 0d 	mcall	80004f78 <CalulateCRC+0x88>
		i--;
80004f4a:	20 17       	sub	r7,1
80004f4c:	5c 57       	castu.b	r7
	}
	while ((i!=0) && !(n&0x04));
80004f4e:	c0 40       	breq	80004f56 <CalulateCRC+0x66>
80004f50:	e2 1c 00 04 	andl	r12,0x4,COH
80004f54:	cf 80       	breq	80004f44 <CalulateCRC+0x54>
	pOut [0] = ReadRawRC(CRCResultRegL);
80004f56:	32 2c       	mov	r12,34
80004f58:	f0 1f 00 08 	mcall	80004f78 <CalulateCRC+0x88>
80004f5c:	a6 8c       	st.b	r3[0x0],r12
	pOut [1] = ReadRawRC(CRCResultRegM);
80004f5e:	32 1c       	mov	r12,33
80004f60:	f0 1f 00 06 	mcall	80004f78 <CalulateCRC+0x88>
80004f64:	a6 9c       	st.b	r3[0x1],r12
}
80004f66:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80004f6a:	00 00       	add	r0,r0
80004f6c:	80 00       	ld.sh	r0,r0[0x0]
80004f6e:	4b 18       	lddpc	r8,80005030 <rfid_auto_reader+0x40>
80004f70:	80 00       	ld.sh	r0,r0[0x0]
80004f72:	49 dc       	lddpc	r12,80004fe4 <PcdSelect+0x68>
80004f74:	80 00       	ld.sh	r0,r0[0x0]
80004f76:	4a d4       	lddpc	r4,80005028 <rfid_auto_reader+0x38>
80004f78:	80 00       	ld.sh	r0,r0[0x0]
80004f7a:	4a 94       	lddpc	r4,8000501c <rfid_auto_reader+0x2c>

80004f7c <PcdSelect>:
//    斤瀹＄
//拌存: pSnr[IN]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdSelect(U8 *pSnr)
{
80004f7c:	eb cd 40 80 	pushm	r7,lr
80004f80:	20 5d       	sub	sp,20
	char   status;
	U8   i;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
80004f82:	39 38       	mov	r8,-109
80004f84:	ba 88       	st.b	sp[0x0],r8
	ucComMF522Buf[1] = 0x70;
80004f86:	37 08       	mov	r8,112
80004f88:	ba 98       	st.b	sp[0x1],r8
	ucComMF522Buf[6] = 0;
80004f8a:	30 08       	mov	r8,0
80004f8c:	ba e8       	st.b	sp[0x6],r8
80004f8e:	fa c8 ff fe 	sub	r8,sp,-2
/////////////////////////////////////////////////////////////////////
//    斤瀹＄
//拌存: pSnr[IN]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdSelect(U8 *pSnr)
80004f92:	fa cb ff fa 	sub	r11,sp,-6
	ucComMF522Buf[0] = PICC_ANTICOLL1;
	ucComMF522Buf[1] = 0x70;
	ucComMF522Buf[6] = 0;
	for (i=0; i<4; i++)
	{
		ucComMF522Buf[i+2] = *(pSnr+i);
80004f96:	19 89       	ld.ub	r9,r12[0x0]
80004f98:	10 c9       	st.b	r8++,r9
		ucComMF522Buf[6]  ^= *(pSnr+i);
80004f9a:	19 3a       	ld.ub	r10,r12++
80004f9c:	1b e9       	ld.ub	r9,sp[0x6]
80004f9e:	f5 e9 20 09 	eor	r9,r10,r9
80004fa2:	ba e9       	st.b	sp[0x6],r9
	U8   ucComMF522Buf[MAXRLEN];
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
	ucComMF522Buf[1] = 0x70;
	ucComMF522Buf[6] = 0;
	for (i=0; i<4; i++)
80004fa4:	16 38       	cp.w	r8,r11
80004fa6:	cf 81       	brne	80004f96 <PcdSelect+0x1a>
	{
		ucComMF522Buf[i+2] = *(pSnr+i);
		ucComMF522Buf[6]  ^= *(pSnr+i);
	}
	CalulateCRC(ucComMF522Buf,7,&ucComMF522Buf[7]);
80004fa8:	1a 97       	mov	r7,sp
80004faa:	fa ca ff f9 	sub	r10,sp,-7
80004fae:	30 7b       	mov	r11,7
80004fb0:	1a 9c       	mov	r12,sp
80004fb2:	f0 1f 00 0d 	mcall	80004fe4 <PcdSelect+0x68>
	
	ClearBitMask(Status2Reg,0x08);
80004fb6:	30 8b       	mov	r11,8
80004fb8:	16 9c       	mov	r12,r11
80004fba:	f0 1f 00 0c 	mcall	80004fe8 <PcdSelect+0x6c>

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,9,ucComMF522Buf,&unLen);
80004fbe:	fa c8 ff ed 	sub	r8,sp,-19
80004fc2:	1a 99       	mov	r9,sp
80004fc4:	30 9a       	mov	r10,9
80004fc6:	1a 9b       	mov	r11,sp
80004fc8:	30 cc       	mov	r12,12
80004fca:	f0 1f 00 09 	mcall	80004fec <PcdSelect+0x70>
	
	if ((status == MI_OK) && (unLen == 0x18))
80004fce:	c0 71       	brne	80004fdc <PcdSelect+0x60>
80004fd0:	31 88       	mov	r8,24
80004fd2:	fb 39 00 13 	ld.ub	r9,sp[19]
80004fd6:	f0 09 18 00 	cp.b	r9,r8
80004fda:	c0 20       	breq	80004fde <PcdSelect+0x62>
80004fdc:	30 2c       	mov	r12,2
	{   status = MI_OK;  }
	else
	{   status = MI_ERR;    }

	return status;
}
80004fde:	2f bd       	sub	sp,-20
80004fe0:	e3 cd 80 80 	ldm	sp++,r7,pc
80004fe4:	80 00       	ld.sh	r0,r0[0x0]
80004fe6:	4e f0       	lddpc	r0,800051a0 <rfid_sendID_message+0x90>
80004fe8:	80 00       	ld.sh	r0,r0[0x0]
80004fea:	4b 18       	lddpc	r8,800050ac <rfid_auto_reader+0xbc>
80004fec:	80 00       	ld.sh	r0,r0[0x0]
80004fee:	4c 90       	lddpc	r0,80005110 <rfid_sendID_message>

80004ff0 <rfid_auto_reader>:
		
}

//娴绋锛瀵诲->插叉->->″
U8 rfid_auto_reader(void *card_id)
{
80004ff0:	eb cd 40 c0 	pushm	r6-r7,lr
80004ff4:	18 96       	mov	r6,r12
	U8 status = MI_ERR;
	
	PcdReset();
80004ff6:	f0 1f 00 37 	mcall	800050d0 <rfid_auto_reader+0xe0>
//while(1){
	status=PcdRequest(PICC_REQALL,	CT);//瀵诲ぉ绾垮哄ㄩㄧ★杩＄绫诲 2瀛
80004ffa:	4b 7b       	lddpc	r11,800050d4 <rfid_auto_reader+0xe4>
80004ffc:	35 2c       	mov	r12,82
80004ffe:	f0 1f 00 37 	mcall	800050d8 <rfid_auto_reader+0xe8>
80005002:	18 97       	mov	r7,r12
	if(status!=MI_OK) return status;
80005004:	c6 31       	brne	800050ca <rfid_auto_reader+0xda>
	//continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
80005006:	4b 48       	lddpc	r8,800050d4 <rfid_auto_reader+0xe4>
80005008:	11 88       	ld.ub	r8,r8[0x0]
8000500a:	30 49       	mov	r9,4
8000500c:	f2 08 18 00 	cp.b	r8,r9
80005010:	c0 b1       	brne	80005026 <rfid_auto_reader+0x36>
80005012:	4b 19       	lddpc	r9,800050d4 <rfid_auto_reader+0xe4>
80005014:	13 9a       	ld.ub	r10,r9[0x1]
80005016:	30 09       	mov	r9,0
80005018:	f2 0a 18 00 	cp.b	r10,r9
8000501c:	c0 51       	brne	80005026 <rfid_auto_reader+0x36>
		log("MFOne-S50\n");
8000501e:	4b 0c       	lddpc	r12,800050dc <rfid_auto_reader+0xec>
80005020:	f0 1f 00 30 	mcall	800050e0 <rfid_auto_reader+0xf0>
//while(1){
	status=PcdRequest(PICC_REQALL,	CT);//瀵诲ぉ绾垮哄ㄩㄧ★杩＄绫诲 2瀛
	if(status!=MI_OK) return status;
	//continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
80005024:	c3 c8       	rjmp	8000509c <rfid_auto_reader+0xac>
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
80005026:	30 29       	mov	r9,2
80005028:	f2 08 18 00 	cp.b	r8,r9
8000502c:	c0 b1       	brne	80005042 <rfid_auto_reader+0x52>
8000502e:	4a a9       	lddpc	r9,800050d4 <rfid_auto_reader+0xe4>
80005030:	13 9a       	ld.ub	r10,r9[0x1]
80005032:	30 09       	mov	r9,0
80005034:	f2 0a 18 00 	cp.b	r10,r9
80005038:	c0 51       	brne	80005042 <rfid_auto_reader+0x52>
		log("MFOne-S70\n");
8000503a:	4a bc       	lddpc	r12,800050e4 <rfid_auto_reader+0xf4>
8000503c:	f0 1f 00 29 	mcall	800050e0 <rfid_auto_reader+0xf0>
	if(status!=MI_OK) return status;
	//continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
80005040:	c2 e8       	rjmp	8000509c <rfid_auto_reader+0xac>
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
80005042:	34 49       	mov	r9,68
80005044:	f2 08 18 00 	cp.b	r8,r9
80005048:	c0 b1       	brne	8000505e <rfid_auto_reader+0x6e>
8000504a:	4a 39       	lddpc	r9,800050d4 <rfid_auto_reader+0xe4>
8000504c:	13 9a       	ld.ub	r10,r9[0x1]
8000504e:	30 09       	mov	r9,0
80005050:	f2 0a 18 00 	cp.b	r10,r9
80005054:	c0 51       	brne	8000505e <rfid_auto_reader+0x6e>
		log("MF-UltraLight\n");
80005056:	4a 5c       	lddpc	r12,800050e8 <rfid_auto_reader+0xf8>
80005058:	f0 1f 00 22 	mcall	800050e0 <rfid_auto_reader+0xf0>
	
	if(CT[0]==0x04&&CT[1]==0x00)
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
8000505c:	c2 08       	rjmp	8000509c <rfid_auto_reader+0xac>
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
8000505e:	30 89       	mov	r9,8
80005060:	f2 08 18 00 	cp.b	r8,r9
80005064:	c0 b1       	brne	8000507a <rfid_auto_reader+0x8a>
80005066:	49 c9       	lddpc	r9,800050d4 <rfid_auto_reader+0xe4>
80005068:	13 9a       	ld.ub	r10,r9[0x1]
8000506a:	30 09       	mov	r9,0
8000506c:	f2 0a 18 00 	cp.b	r10,r9
80005070:	c0 51       	brne	8000507a <rfid_auto_reader+0x8a>
		log("MF-Pro\n");
80005072:	49 fc       	lddpc	r12,800050ec <rfid_auto_reader+0xfc>
80005074:	f0 1f 00 1b 	mcall	800050e0 <rfid_auto_reader+0xf0>
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
80005078:	c1 28       	rjmp	8000509c <rfid_auto_reader+0xac>
		log("MF-Pro\n");
	else if(CT[0]==0x44&&CT[1]==0x03)
8000507a:	34 49       	mov	r9,68
8000507c:	f2 08 18 00 	cp.b	r8,r9
80005080:	c0 b1       	brne	80005096 <rfid_auto_reader+0xa6>
80005082:	49 58       	lddpc	r8,800050d4 <rfid_auto_reader+0xe4>
80005084:	11 99       	ld.ub	r9,r8[0x1]
80005086:	30 38       	mov	r8,3
80005088:	f0 09 18 00 	cp.b	r9,r8
8000508c:	c0 51       	brne	80005096 <rfid_auto_reader+0xa6>
		log("MF Desire\n");
8000508e:	49 9c       	lddpc	r12,800050f0 <rfid_auto_reader+0x100>
80005090:	f0 1f 00 14 	mcall	800050e0 <rfid_auto_reader+0xf0>
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
		log("MF-Pro\n");
	else if(CT[0]==0x44&&CT[1]==0x03)
80005094:	c0 48       	rjmp	8000509c <rfid_auto_reader+0xac>
		log("MF Desire\n");
	else
		log("Unknown\n");
80005096:	49 8c       	lddpc	r12,800050f4 <rfid_auto_reader+0x104>
80005098:	f0 1f 00 12 	mcall	800050e0 <rfid_auto_reader+0xf0>
		
	status=PcdAnticoll(SN);//插叉锛杩＄搴 4瀛
8000509c:	49 7c       	lddpc	r12,800050f8 <rfid_auto_reader+0x108>
8000509e:	f0 1f 00 18 	mcall	800050fc <rfid_auto_reader+0x10c>
800050a2:	18 97       	mov	r7,r12
	if(status!=MI_OK)
800050a4:	c0 60       	breq	800050b0 <rfid_auto_reader+0xc0>
	{
		xcmp_IdleTestTone(Tone_Start, BT_Disconnecting_Success_Tone);//set tone to noticy failure!!!
800050a6:	37 8b       	mov	r11,120
800050a8:	30 1c       	mov	r12,1
800050aa:	f0 1f 00 16 	mcall	80005100 <rfid_auto_reader+0x110>
		return status;
800050ae:	c0 e8       	rjmp	800050ca <rfid_auto_reader+0xda>
	}
	//continue;
	
	//memcpy(MLastSelectedSnr,&RevBuffer[2],4);
	status=PcdSelect(SN);//
800050b0:	49 2c       	lddpc	r12,800050f8 <rfid_auto_reader+0x108>
800050b2:	f0 1f 00 15 	mcall	80005104 <rfid_auto_reader+0x114>
800050b6:	18 97       	mov	r7,r12
	if(status!=MI_OK)return status;
800050b8:	c0 91       	brne	800050ca <rfid_auto_reader+0xda>
	//continue;
	else{//℃
			
		memcpy(card_id, SN, 4);
800050ba:	30 4a       	mov	r10,4
800050bc:	48 fb       	lddpc	r11,800050f8 <rfid_auto_reader+0x108>
800050be:	0c 9c       	mov	r12,r6
800050c0:	f0 1f 00 12 	mcall	80005108 <rfid_auto_reader+0x118>
		log("select okay\n");
800050c4:	49 2c       	lddpc	r12,8000510c <rfid_auto_reader+0x11c>
800050c6:	f0 1f 00 07 	mcall	800050e0 <rfid_auto_reader+0xf0>
		return status;	
	}
	
//}
	
}
800050ca:	0e 9c       	mov	r12,r7
800050cc:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800050d0:	80 00       	ld.sh	r0,r0[0x0]
800050d2:	4a 14       	lddpc	r4,80005154 <rfid_sendID_message+0x44>
800050d4:	00 00       	add	r0,r0
800050d6:	51 18       	stdsp	sp[0x44],r8
800050d8:	80 00       	ld.sh	r0,r0[0x0]
800050da:	4e 8c       	lddpc	r12,80005278 <rfid_init>
800050dc:	80 00       	ld.sh	r0,r0[0x0]
800050de:	d5 a4       	*unknown*
800050e0:	80 00       	ld.sh	r0,r0[0x0]
800050e2:	6e 30       	ld.w	r0,r7[0xc]
800050e4:	80 00       	ld.sh	r0,r0[0x0]
800050e6:	d5 b0       	acall	0x5b
800050e8:	80 00       	ld.sh	r0,r0[0x0]
800050ea:	d5 bc       	*unknown*
800050ec:	80 00       	ld.sh	r0,r0[0x0]
800050ee:	d5 cc       	*unknown*
800050f0:	80 00       	ld.sh	r0,r0[0x0]
800050f2:	d5 d4       	*unknown*
800050f4:	80 00       	ld.sh	r0,r0[0x0]
800050f6:	d5 e0       	acall	0x5e
800050f8:	00 00       	add	r0,r0
800050fa:	51 1c       	stdsp	sp[0x44],r12
800050fc:	80 00       	ld.sh	r0,r0[0x0]
800050fe:	4e 08       	lddpc	r8,8000527c <rfid_init+0x4>
80005100:	80 00       	ld.sh	r0,r0[0x0]
80005102:	41 3c       	lddsp	r12,sp[0x4c]
80005104:	80 00       	ld.sh	r0,r0[0x0]
80005106:	4f 7c       	lddpc	r12,800052e0 <delay_ns+0xc>
80005108:	80 00       	ld.sh	r0,r0[0x0]
8000510a:	76 b0       	ld.w	r0,r11[0x2c]
8000510c:	80 00       	ld.sh	r0,r0[0x0]
8000510e:	d5 ec       	*unknown*

80005110 <rfid_sendID_message>:


U8 rfid_sendID_message()
{
80005110:	eb cd 40 e0 	pushm	r5-r7,lr
80005114:	21 ed       	sub	sp,120
	U8 temp =0;
	U8 destination = DEST;
	static U8 start_session = 0x80;
	Message_Header_t header;
	
	memset(data_buffer, 0x00, 16);
80005116:	fa ca ff a4 	sub	r10,sp,-92
8000511a:	30 08       	mov	r8,0
8000511c:	30 09       	mov	r9,0
8000511e:	f4 e9 00 00 	st.d	r10[0],r8
80005122:	f4 e9 00 08 	st.d	r10[8],r8
	memset(SN, 0x00, 10);
80005126:	fa cc ff 94 	sub	r12,sp,-108
8000512a:	f8 e9 00 00 	st.d	r12[0],r8
8000512e:	30 0a       	mov	r10,0
80005130:	b8 4a       	st.h	r12[0x8],r10
	memset(message, 0x00, 80);
80005132:	fa e9 00 0c 	st.d	sp[12],r8
80005136:	fa e9 00 14 	st.d	sp[20],r8
8000513a:	fa e9 00 1c 	st.d	sp[28],r8
8000513e:	fa e9 00 24 	st.d	sp[36],r8
80005142:	fa e9 00 2c 	st.d	sp[44],r8
80005146:	fa e9 00 34 	st.d	sp[52],r8
8000514a:	fa e9 00 3c 	st.d	sp[60],r8
8000514e:	fa e9 00 44 	st.d	sp[68],r8
80005152:	fa e9 00 4c 	st.d	sp[76],r8
80005156:	fa e9 00 54 	st.d	sp[84],r8

	return_err = rfid_auto_reader(SN);
8000515a:	f0 1f 00 3f 	mcall	80005254 <rfid_sendID_message+0x144>
8000515e:	18 97       	mov	r7,r12
	
	if(return_err == 0){
80005160:	c6 e1       	brne	8000523c <rfid_sendID_message+0x12c>
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
80005162:	fb 38 00 6f 	ld.ub	r8,sp[111]
80005166:	1a d8       	st.w	--sp,r8
80005168:	fb 38 00 72 	ld.ub	r8,sp[114]
8000516c:	1a d8       	st.w	--sp,r8
8000516e:	fb 38 00 75 	ld.ub	r8,sp[117]
80005172:	1a d8       	st.w	--sp,r8
80005174:	fb 38 00 78 	ld.ub	r8,sp[120]
80005178:	1a d8       	st.w	--sp,r8
8000517a:	4b 8c       	lddpc	r12,80005258 <rfid_sendID_message+0x148>
8000517c:	f0 1f 00 38 	mcall	8000525c <rfid_sendID_message+0x14c>
		xcmp_IdleTestTone(Tone_Start, BT_Connection_Success_Tone);//set tone to indicate scan rfid success!!!		 
80005180:	37 7b       	mov	r11,119
80005182:	30 1c       	mov	r12,1
80005184:	f0 1f 00 37 	mcall	80005260 <rfid_sendID_message+0x150>
80005188:	fa c9 ff 84 	sub	r9,sp,-124
8000518c:	fa c8 ff 94 	sub	r8,sp,-108
80005190:	fa ca ff 92 	sub	r10,sp,-110
//}
	
}


U8 rfid_sendID_message()
80005194:	fa c5 ff 80 	sub	r5,sp,-128
80005198:	2f cd       	sub	sp,-16
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, BT_Connection_Success_Tone);//set tone to indicate scan rfid success!!!		 
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″	
		
			 temp = ((SN[i] & 0xF0) >> 4);//瀛楂浣
			 if((temp >= 0) && (temp <= 9))data_buffer[i*4] = temp+0x30;
8000519a:	30 9e       	mov	lr,9
			 else 
				data_buffer[i*4] = ((temp - 0x0a)+0x61);
			
			 data_buffer[i*4+1] = 0x00; 
8000519c:	30 06       	mov	r6,0
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, BT_Connection_Success_Tone);//set tone to indicate scan rfid success!!!		 
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″	
		
			 temp = ((SN[i] & 0xF0) >> 4);//瀛楂浣
8000519e:	13 8b       	ld.ub	r11,r9[0x0]
800051a0:	f6 0c 16 04 	lsr	r12,r11,0x4
			 if((temp >= 0) && (temp <= 9))data_buffer[i*4] = temp+0x30;
800051a4:	fc 0c 18 00 	cp.b	r12,lr
800051a8:	f7 bc 08 d0 	subls	r12,-48
800051ac:	f1 fc 8e 00 	st.bls	r8[0x0],r12
			 else 
				data_buffer[i*4] = ((temp - 0x0a)+0x61);
800051b0:	f7 bc 0b a9 	subhi	r12,-87
800051b4:	f1 fc be 00 	st.bhi	r8[0x0],r12
			
			 data_buffer[i*4+1] = 0x00; 
800051b8:	b0 96       	st.b	r8[0x1],r6
		 
			 temp = (SN[i] & 0x0F);//瀛浣浣
800051ba:	f7 db c0 04 	bfextu	r11,r11,0x0,0x4
			 if((temp >= 0) && (temp <= 9))data_buffer[i*4+2] = temp+0x30;
800051be:	fc 0b 18 00 	cp.b	r11,lr
800051c2:	f7 bb 08 d0 	subls	r11,-48
800051c6:	f5 fb 8e 00 	st.bls	r10[0x0],r11
			 else
				data_buffer[i*4+2] = ((temp - 0x0a)+0x61);
800051ca:	f7 bb 0b a9 	subhi	r11,-87
800051ce:	f5 fb be 00 	st.bhi	r10[0x0],r11

		 
			 data_buffer[i*4+3] = 0x00; 
800051d2:	b0 b6       	st.b	r8[0x3],r6
800051d4:	2f f9       	sub	r9,-1
800051d6:	2f c8       	sub	r8,-4
800051d8:	2f ca       	sub	r10,-4
	
	if(return_err == 0){
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, BT_Connection_Success_Tone);//set tone to indicate scan rfid success!!!		 
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″	
800051da:	0a 39       	cp.w	r9,r5
800051dc:	ce 11       	brne	8000519e <rfid_sendID_message+0x8e>
			 data_buffer[i*4+3] = 0x00; 
		}
	
		header.length = (0x0008 + sizeof(data_buffer));
	
		if(start_session > 0x9f)start_session = 0x80;
800051de:	4a 28       	lddpc	r8,80005264 <rfid_sendID_message+0x154>
800051e0:	11 89       	ld.ub	r9,r8[0x0]
800051e2:	39 f8       	mov	r8,-97
800051e4:	f0 09 18 00 	cp.b	r9,r8
800051e8:	e0 88 00 05 	brls	800051f2 <rfid_sendID_message+0xe2>
800051ec:	38 09       	mov	r9,-128
800051ee:	49 e8       	lddpc	r8,80005264 <rfid_sendID_message+0x154>
800051f0:	b0 89       	st.b	r8[0x0],r9
	
		header.session_id = (++start_session);
800051f2:	49 d8       	lddpc	r8,80005264 <rfid_sendID_message+0x154>
800051f4:	11 86       	ld.ub	r6,r8[0x0]
800051f6:	2f f6       	sub	r6,-1
800051f8:	b0 86       	st.b	r8[0x0],r6
	
		memcpy(&header.fixed_data[0], unsure_data, sizeof(unsure_data));
800051fa:	30 5a       	mov	r10,5
800051fc:	49 bb       	lddpc	r11,80005268 <rfid_sendID_message+0x158>
800051fe:	fa cc ff f9 	sub	r12,sp,-7
80005202:	f0 1f 00 1b 	mcall	8000526c <rfid_sendID_message+0x15c>
		header.type = 0xe000;
	
		memcpy(message, &header, sizeof(Message_Header_t));//疯header版
80005206:	31 88       	mov	r8,24
80005208:	ba 18       	st.h	sp[0x2],r8
8000520a:	ba e6       	st.b	sp[0x6],r6
8000520c:	fe 78 e0 00 	mov	r8,-8192
80005210:	ba 28       	st.h	sp[0x4],r8
80005212:	fa c6 ff f4 	sub	r6,sp,-12
80005216:	30 aa       	mov	r10,10
80005218:	fa cb ff fe 	sub	r11,sp,-2
8000521c:	0c 9c       	mov	r12,r6
8000521e:	f0 1f 00 14 	mcall	8000526c <rfid_sendID_message+0x15c>
		memcpy(&message[sizeof(Message_Header_t)], data_buffer, sizeof(data_buffer));//疯淇″瀹规版
80005222:	31 0a       	mov	r10,16
80005224:	fa cb ff a4 	sub	r11,sp,-92
80005228:	fa cc ff ea 	sub	r12,sp,-22
8000522c:	f0 1f 00 10 	mcall	8000526c <rfid_sendID_message+0x15c>
	
		xcmp_data_session_req(message, (sizeof(Message_Header_t)+sizeof(data_buffer)), destination);
80005230:	30 9a       	mov	r10,9
80005232:	31 ab       	mov	r11,26
80005234:	0c 9c       	mov	r12,r6
80005236:	f0 1f 00 0f 	mcall	80005270 <rfid_sendID_message+0x160>
8000523a:	c0 88       	rjmp	8000524a <rfid_sendID_message+0x13a>
		
	}
	else
	{
		xcmp_IdleTestTone(Tone_Start, BT_Disconnecting_Success_Tone);//set tone to indicate scan rfid failure!!!
8000523c:	37 8b       	mov	r11,120
8000523e:	30 1c       	mov	r12,1
80005240:	f0 1f 00 08 	mcall	80005260 <rfid_sendID_message+0x150>
		log("no card find...\n");
80005244:	48 cc       	lddpc	r12,80005274 <rfid_sendID_message+0x164>
80005246:	f0 1f 00 06 	mcall	8000525c <rfid_sendID_message+0x14c>
	}
	
	return return_err;
	
}
8000524a:	0e 9c       	mov	r12,r7
8000524c:	2e 2d       	sub	sp,-120
8000524e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80005252:	00 00       	add	r0,r0
80005254:	80 00       	ld.sh	r0,r0[0x0]
80005256:	4f f0       	lddpc	r0,80005450 <INTC_register_interrupt+0x10>
80005258:	80 00       	ld.sh	r0,r0[0x0]
8000525a:	d5 fc       	*unknown*
8000525c:	80 00       	ld.sh	r0,r0[0x0]
8000525e:	6e 30       	ld.w	r0,r7[0xc]
80005260:	80 00       	ld.sh	r0,r0[0x0]
80005262:	41 3c       	lddsp	r12,sp[0x4c]
80005264:	00 00       	add	r0,r0
80005266:	05 30       	ld.ub	r0,r2++
80005268:	00 00       	add	r0,r0
8000526a:	05 28       	ld.uh	r8,r2++
8000526c:	80 00       	ld.sh	r0,r0[0x0]
8000526e:	76 b0       	ld.w	r0,r11[0x2c]
80005270:	80 00       	ld.sh	r0,r0[0x0]
80005272:	40 04       	lddsp	r4,sp[0x0]
80005274:	80 00       	ld.sh	r0,r0[0x0]
80005276:	d6 18       	*unknown*

80005278 <rfid_init>:
U8 RFID[16];			//瀛RFID
U8 unsure_data[5]={0x04, 0x0d, 0x00, 0x0a, 0x00};


void rfid_init()
{
80005278:	d4 01       	pushm	lr
	char card_id[4]={0};
	//tc_init();//ㄥ跺200msㄥ诲
	
	rc522_init();
8000527a:	f0 1f 00 02 	mcall	80005280 <rfid_init+0x8>
	
	//if(rfid_auto_reader(card_id) == 0){
		//log("card_id : 0x%x, 0x%x, 0x%x, 0x%x\n", &card_id[0], &card_id[1], &card_id[2], &card_id[3]);	
	//}
		
}
8000527e:	d8 02       	popm	pc
80005280:	80 00       	ld.sh	r0,r0[0x0]
80005282:	4b c0       	lddpc	r0,80005370 <gpio_enable_module_pin+0x8>

80005284 <local_start_pll0>:
	//pm_switch_to_osc0(pm, 12000000, 3);
	//    pm_enable_osc0_crystal(pm, 12000000);
	//         pm_set_osc0_mode(pm,AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);  0x00000007
	//    pm_enable_clk0(pm, 3);
	//         pm_enable_clk0_no_wait(pm, 3);
	(&AVR32_PM)->oscctrl0 = 0x00000307;
80005284:	fe 78 0c 00 	mov	r8,-62464
80005288:	e0 69 03 07 	mov	r9,775
8000528c:	91 a9       	st.w	r8[0x28],r9
	(&AVR32_PM)->mcctrl   = 0x00000004;
8000528e:	30 49       	mov	r9,4
80005290:	91 09       	st.w	r8[0x0],r9
	//         pm_wait_for_clk0_ready(pm);
	while (!((&AVR32_PM)->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
80005292:	71 59       	ld.w	r9,r8[0x54]
80005294:	e2 19 00 80 	andl	r9,0x80,COH
80005298:	cf d0       	breq	80005292 <local_start_pll0+0xe>
	//    pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);
	(&AVR32_PM)->mcctrl   = 0x00000005;
8000529a:	fe 78 0c 00 	mov	r8,-62464
8000529e:	30 59       	mov	r9,5
800052a0:	91 09       	st.w	r8[0x0],r9
	//pm_pll_set_option(pm, 0, //PLL number 0
	//                        1, //freq Set to 1 for VCO frequency range 80-180MHz
	//                        1, //div2 Divide the PLL output frequency by 2
	//                        0);//0 to enable the Wide-Bandith Mode
	//pm_pll_enable(pm,0);
	(&AVR32_PM)->pll[0] = 0x1007010D;
800052a2:	e0 69 01 0d 	mov	r9,269
800052a6:	ea 19 10 07 	orh	r9,0x1007
800052aa:	91 89       	st.w	r8[0x20],r9


	//pm_wait_for_pll0_locked(pm);
	while (!((&AVR32_PM)->poscsr & AVR32_PM_POSCSR_LOCK0_MASK));
800052ac:	71 59       	ld.w	r9,r8[0x54]
800052ae:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
800052b2:	cf d0       	breq	800052ac <local_start_pll0+0x28>
	//             0,  //Bus A select = 0 (PBA clock = 48MHz/2 = 24MHz).
	//             0,  //B clock divisor enable = 0
	//             0,  //Bus B select = 0
	//             0,  //HS Bus clock divisor enable = 0
	//             0); //HS Bus select = 0
	(&AVR32_PM)->cksel = 0x00800000;
800052b4:	fe 78 0c 00 	mov	r8,-62464
800052b8:	fc 19 00 80 	movh	r9,0x80
800052bc:	91 19       	st.w	r8[0x4],r9

	//flashc_set_wait_state(1);
	AVR32_FLASHC.fcr = 0x00000040;
800052be:	34 0a       	mov	r10,64
800052c0:	fe 69 14 00 	mov	r9,-125952
800052c4:	93 0a       	st.w	r9[0x0],r10

	//pm_switch_to_clock(pm, AVR32_PM_MCSEL_PLL0);
	(&AVR32_PM)->mcctrl   = 0x00000006;
800052c6:	30 69       	mov	r9,6
800052c8:	91 09       	st.w	r8[0x0],r9


	AVR32_HMATRIX.mcfg[AVR32_HMATRIX_MASTER_CPU_INSTRUCTION] = 0x1;
800052ca:	30 19       	mov	r9,1
800052cc:	fe 68 10 00 	mov	r8,-126976
800052d0:	91 19       	st.w	r8[0x4],r9
	flashc_set_wait_state(1);
	//AVR32_FLASHC.fcr = 0x00000040;

	pm_switch_to_clock(&AVR32_PM, AVR32_PM_MCSEL_PLL0);
****/
}
800052d2:	5e fc       	retal	r12

800052d4 <delay_ns>:
}

void delay_ns(U32 ns)
{
	U32 i;
	for(i=0;i<ns;i++)
800052d4:	58 0c       	cp.w	r12,0
800052d6:	5e 0c       	reteq	r12
800052d8:	30 08       	mov	r8,0
	{
		nop();
800052da:	d7 03       	nop
		nop();
800052dc:	d7 03       	nop
		nop();
800052de:	d7 03       	nop
}

void delay_ns(U32 ns)
{
	U32 i;
	for(i=0;i<ns;i++)
800052e0:	2f f8       	sub	r8,-1
800052e2:	10 3c       	cp.w	r12,r8
800052e4:	fe 9b ff fb 	brhi	800052da <delay_ns+0x6>
800052e8:	5e fc       	retal	r12
800052ea:	d7 03       	nop

800052ec <delay_us>:
		nop();
		nop();
	}
}
void delay_us(U32 us)
{
800052ec:	eb cd 40 e0 	pushm	r5-r7,lr
800052f0:	18 96       	mov	r6,r12
	for(int i =0; i<us; i++){
800052f2:	58 0c       	cp.w	r12,0
800052f4:	c0 b0       	breq	8000530a <delay_us+0x1e>
800052f6:	30 07       	mov	r7,0
		delay_ns(1000);
800052f8:	e0 65 03 e8 	mov	r5,1000
800052fc:	0a 9c       	mov	r12,r5
800052fe:	f0 1f 00 05 	mcall	80005310 <delay_us+0x24>
		nop();
	}
}
void delay_us(U32 us)
{
	for(int i =0; i<us; i++){
80005302:	2f f7       	sub	r7,-1
80005304:	0e 36       	cp.w	r6,r7
80005306:	fe 9b ff fb 	brhi	800052fc <delay_us+0x10>
8000530a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000530e:	00 00       	add	r0,r0
80005310:	80 00       	ld.sh	r0,r0[0x0]
80005312:	52 d4       	stdsp	sp[0xb4],r4

80005314 <delay_ms>:
		delay_ns(1000);
	}

}
void delay_ms(U32 ms)
{
80005314:	eb cd 40 e0 	pushm	r5-r7,lr
80005318:	18 96       	mov	r6,r12
	for(int i =0; i<ms; i++){
8000531a:	58 0c       	cp.w	r12,0
8000531c:	c0 b0       	breq	80005332 <delay_ms+0x1e>
8000531e:	30 07       	mov	r7,0
		delay_us(1000);
80005320:	e0 65 03 e8 	mov	r5,1000
80005324:	0a 9c       	mov	r12,r5
80005326:	f0 1f 00 05 	mcall	80005338 <delay_ms+0x24>
	}

}
void delay_ms(U32 ms)
{
	for(int i =0; i<ms; i++){
8000532a:	2f f7       	sub	r7,-1
8000532c:	0e 36       	cp.w	r6,r7
8000532e:	fe 9b ff fb 	brhi	80005324 <delay_ms+0x10>
80005332:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80005336:	00 00       	add	r0,r0
80005338:	80 00       	ld.sh	r0,r0[0x0]
8000533a:	52 ec       	stdsp	sp[0xb8],r12

8000533c <local_start_timer>:
//	SSC_TX_DATA_ENABLE		AVR32_TC_A0_0_0_PIN					[32 PortB Pin  0 00000001 Func 0]
//	MAKO_TX					AVR32_SSC_TX_DATA_0_PIN				[42 PortB Pin 10 00000400 Func 0]
//	MAKO_RX					AVR32_SSC_RX_DATA_0_PIN				[39 PortB Pin  7 00000080 Func 0]
//
void local_start_timer(void)
{
8000533c:	d4 01       	pushm	lr
	{
		{TIMER_TC_CLK_PIN,      TIMER_TC_CLK_FUNCTION     },
		{TIMER_TC_FS_PIN,       TIMER_TC_FS_FUNCTION      },
		{TIMER_EN_CLK_PIN,      TIMER_EN_CLK_FUNCTION     }
	};
	gpio_enable_module(TC_GPIO_MAP, sizeof(TC_GPIO_MAP) / sizeof(TC_GPIO_MAP[0]));
8000533e:	30 3b       	mov	r11,3
80005340:	48 8c       	lddpc	r12,80005360 <local_start_timer+0x24>
80005342:	f0 1f 00 09 	mcall	80005364 <local_start_timer+0x28>

	(&AVR32_TC)->channel[0].cmr =
80005346:	fe 78 38 00 	mov	r8,-51200
8000534a:	e0 69 91 0d 	mov	r9,37133
8000534e:	ea 19 00 52 	orh	r9,0x52
80005352:	91 19       	st.w	r8[0x4],r9
	1                          << AVR32_TC_CLKI_OFFSET     |
	AVR32_TC_TCCLKS_XC0        << AVR32_TC_TCCLKS_OFFSET;



	(&AVR32_TC)->channel[0].ra = 32;
80005354:	32 09       	mov	r9,32
80005356:	91 59       	st.w	r8[0x14],r9
	(&AVR32_TC)->channel[0].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
80005358:	30 59       	mov	r9,5
8000535a:	91 09       	st.w	r8[0x0],r9
}
8000535c:	d8 02       	popm	pc
8000535e:	00 00       	add	r0,r0
80005360:	80 00       	ld.sh	r0,r0[0x0]
80005362:	d6 2c       	*unknown*
80005364:	80 00       	ld.sh	r0,r0[0x0]
80005366:	53 bc       	stdsp	sp[0xec],r12

80005368 <gpio_enable_module_pin>:
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80005368:	f8 08 16 05 	lsr	r8,r12,0x5
8000536c:	a9 68       	lsl	r8,0x8
8000536e:	e0 28 f0 00 	sub	r8,61440

	/* Enable the correct function. */
	switch (function) {
80005372:	58 1b       	cp.w	r11,1
80005374:	c0 d0       	breq	8000538e <gpio_enable_module_pin+0x26>
80005376:	c0 63       	brcs	80005382 <gpio_enable_module_pin+0x1a>
80005378:	58 2b       	cp.w	r11,2
8000537a:	c1 00       	breq	8000539a <gpio_enable_module_pin+0x32>
8000537c:	58 3b       	cp.w	r11,3
8000537e:	c1 40       	breq	800053a6 <gpio_enable_module_pin+0x3e>
80005380:	5e ff       	retal	1
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80005382:	30 19       	mov	r9,1
80005384:	f2 0c 09 49 	lsl	r9,r9,r12
80005388:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
8000538a:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
8000538c:	c1 28       	rjmp	800053b0 <gpio_enable_module_pin+0x48>

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
8000538e:	30 19       	mov	r9,1
80005390:	f2 0c 09 49 	lsl	r9,r9,r12
80005394:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80005396:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80005398:	c0 c8       	rjmp	800053b0 <gpio_enable_module_pin+0x48>

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
8000539a:	30 19       	mov	r9,1
8000539c:	f2 0c 09 49 	lsl	r9,r9,r12
800053a0:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
800053a2:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
800053a4:	c0 68       	rjmp	800053b0 <gpio_enable_module_pin+0x48>

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
800053a6:	30 19       	mov	r9,1
800053a8:	f2 0c 09 49 	lsl	r9,r9,r12
800053ac:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
800053ae:	91 99       	st.w	r8[0x24],r9
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
800053b0:	30 19       	mov	r9,1
800053b2:	f2 0c 09 4c 	lsl	r12,r9,r12
800053b6:	91 2c       	st.w	r8[0x8],r12
800053b8:	5e fd       	retal	0
800053ba:	d7 03       	nop

800053bc <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
800053bc:	d4 21       	pushm	r4-r7,lr
800053be:	18 97       	mov	r7,r12
800053c0:	16 94       	mov	r4,r11
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
800053c2:	58 0b       	cp.w	r11,0
800053c4:	c0 31       	brne	800053ca <gpio_enable_module+0xe>
800053c6:	30 05       	mov	r5,0
800053c8:	c0 d8       	rjmp	800053e2 <gpio_enable_module+0x26>
800053ca:	30 06       	mov	r6,0
800053cc:	0c 95       	mov	r5,r6
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
800053ce:	6e 1b       	ld.w	r11,r7[0x4]
800053d0:	6e 0c       	ld.w	r12,r7[0x0]
800053d2:	f0 1f 00 06 	mcall	800053e8 <gpio_enable_module+0x2c>
800053d6:	18 45       	or	r5,r12
		gpiomap++;
800053d8:	2f 87       	sub	r7,-8
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
800053da:	2f f6       	sub	r6,-1
800053dc:	0c 34       	cp.w	r4,r6
800053de:	fe 9b ff f8 	brhi	800053ce <gpio_enable_module+0x12>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
}
800053e2:	0a 9c       	mov	r12,r5
800053e4:	d8 22       	popm	r4-r7,pc
800053e6:	00 00       	add	r0,r0
800053e8:	80 00       	ld.sh	r0,r0[0x0]
800053ea:	53 68       	stdsp	sp[0xd8],r8

800053ec <gpio_enable_gpio_pin>:
 *            AVR32_PWM_3_PIN for PWM channel 3 can also be used to release
 *            module pins for GPIO.
 */
void gpio_enable_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
800053ec:	f8 08 16 05 	lsr	r8,r12,0x5
800053f0:	a9 68       	lsl	r8,0x8
800053f2:	e0 28 f0 00 	sub	r8,61440
	
	gpio_port->oderc = 1 << (pin & 0x1F);
800053f6:	30 19       	mov	r9,1
800053f8:	f2 0c 09 4c 	lsl	r12,r9,r12
800053fc:	f1 4c 00 48 	st.w	r8[72],r12
	gpio_port->gpers = 1 << (pin & 0x1F);
80005400:	91 1c       	st.w	r8[0x4],r12
}
80005402:	5e fc       	retal	r12

80005404 <gpio_set_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_set_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80005404:	f8 08 16 05 	lsr	r8,r12,0x5
80005408:	a9 68       	lsl	r8,0x8
8000540a:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 1. */
	gpio_port->ovrs  = 1 << (pin & 0x1F);
8000540e:	30 19       	mov	r9,1
80005410:	f2 0c 09 4c 	lsl	r12,r9,r12
80005414:	f1 4c 00 54 	st.w	r8[84],r12
	/* The GPIO output driver is enabled for that pin. */ 
	gpio_port->oders = 1 << (pin & 0x1F);
80005418:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
8000541c:	91 1c       	st.w	r8[0x4],r12
}
8000541e:	5e fc       	retal	r12

80005420 <gpio_clr_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_clr_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80005420:	f8 08 16 05 	lsr	r8,r12,0x5
80005424:	a9 68       	lsl	r8,0x8
80005426:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 0. */
	gpio_port->ovrc  = 1 << (pin & 0x1F);
8000542a:	30 19       	mov	r9,1
8000542c:	f2 0c 09 4c 	lsl	r12,r9,r12
80005430:	f1 4c 00 58 	st.w	r8[88],r12
	/* The GPIO output driver is enabled for that pin. */
	gpio_port->oders = 1 << (pin & 0x1F);
80005434:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
80005438:	91 1c       	st.w	r8[0x4],r12
}
8000543a:	5e fc       	retal	r12

8000543c <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
8000543c:	c0 08       	rjmp	8000543c <_unhandled_interrupt>
8000543e:	d7 03       	nop

80005440 <INTC_register_interrupt>:
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
80005440:	f6 08 16 05 	lsr	r8,r11,0x5

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
80005444:	49 99       	lddpc	r9,800054a8 <INTC_register_interrupt+0x68>
80005446:	f2 08 00 39 	add	r9,r9,r8<<0x3
8000544a:	f7 db c0 05 	bfextu	r11,r11,0x0,0x5
8000544e:	72 19       	ld.w	r9,r9[0x4]
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
80005450:	f2 0b 09 2c 	st.w	r9[r11<<0x2],r12
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
80005454:	58 0a       	cp.w	r10,0
80005456:	c0 91       	brne	80005468 <INTC_register_interrupt+0x28>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80005458:	49 59       	lddpc	r9,800054ac <INTC_register_interrupt+0x6c>
8000545a:	49 6a       	lddpc	r10,800054b0 <INTC_register_interrupt+0x70>
8000545c:	12 1a       	sub	r10,r9
8000545e:	fe 79 08 00 	mov	r9,-63488
80005462:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80005466:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT1) {
80005468:	58 1a       	cp.w	r10,1
8000546a:	c0 a1       	brne	8000547e <INTC_register_interrupt+0x3e>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
8000546c:	49 09       	lddpc	r9,800054ac <INTC_register_interrupt+0x6c>
8000546e:	49 2a       	lddpc	r10,800054b4 <INTC_register_interrupt+0x74>
80005470:	12 1a       	sub	r10,r9
80005472:	bf aa       	sbr	r10,0x1e
80005474:	fe 79 08 00 	mov	r9,-63488
80005478:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
8000547c:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT2) {
8000547e:	58 2a       	cp.w	r10,2
80005480:	c0 a1       	brne	80005494 <INTC_register_interrupt+0x54>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
80005482:	48 b9       	lddpc	r9,800054ac <INTC_register_interrupt+0x6c>
80005484:	48 da       	lddpc	r10,800054b8 <INTC_register_interrupt+0x78>
80005486:	12 1a       	sub	r10,r9
80005488:	bf ba       	sbr	r10,0x1f
8000548a:	fe 79 08 00 	mov	r9,-63488
8000548e:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80005492:	5e fc       	retal	r12
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
80005494:	48 69       	lddpc	r9,800054ac <INTC_register_interrupt+0x6c>
80005496:	48 aa       	lddpc	r10,800054bc <INTC_register_interrupt+0x7c>
80005498:	12 1a       	sub	r10,r9
8000549a:	ea 1a c0 00 	orh	r10,0xc000
8000549e:	fe 79 08 00 	mov	r9,-63488
800054a2:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800054a6:	5e fc       	retal	r12
800054a8:	80 00       	ld.sh	r0,r0[0x0]
800054aa:	d6 44       	*unknown*
800054ac:	80 00       	ld.sh	r0,r0[0x0]
800054ae:	cc 00       	breq	8000542e <gpio_clr_gpio_pin+0xe>
800054b0:	80 00       	ld.sh	r0,r0[0x0]
800054b2:	cd 04       	brge	80005452 <INTC_register_interrupt+0x12>
800054b4:	80 00       	ld.sh	r0,r0[0x0]
800054b6:	cd 12       	brcc	80005458 <INTC_register_interrupt+0x18>
800054b8:	80 00       	ld.sh	r0,r0[0x0]
800054ba:	cd 20       	breq	8000545e <INTC_register_interrupt+0x1e>
800054bc:	80 00       	ld.sh	r0,r0[0x0]
800054be:	cd 2e       	rcall	80005262 <rfid_sendID_message+0x152>

800054c0 <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
800054c0:	d4 21       	pushm	r4-r7,lr
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
800054c2:	49 18       	lddpc	r8,80005504 <INTC_init_interrupts+0x44>
800054c4:	e3 b8 00 01 	mtsr	0x4,r8
800054c8:	49 0e       	lddpc	lr,80005508 <INTC_init_interrupts+0x48>
800054ca:	30 07       	mov	r7,0
800054cc:	0e 94       	mov	r4,r7
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
800054ce:	49 0c       	lddpc	r12,8000550c <INTC_init_interrupts+0x4c>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
800054d0:	49 05       	lddpc	r5,80005510 <INTC_init_interrupts+0x50>
800054d2:	10 15       	sub	r5,r8
800054d4:	fe 76 08 00 	mov	r6,-63488
800054d8:	c1 08       	rjmp	800054f8 <INTC_init_interrupts+0x38>
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
800054da:	08 98       	mov	r8,r4
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
				._int_line_handler_table[int_req]
800054dc:	7c 1b       	ld.w	r11,lr[0x4]

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
800054de:	7c 0a       	ld.w	r10,lr[0x0]
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
800054e0:	f6 08 09 2c 	st.w	r11[r8<<0x2],r12
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
800054e4:	2f f8       	sub	r8,-1

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
800054e6:	10 3a       	cp.w	r10,r8
800054e8:	fe 9b ff fc 	brhi	800054e0 <INTC_init_interrupts+0x20>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
800054ec:	ec 07 09 25 	st.w	r6[r7<<0x2],r5
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
800054f0:	2f f7       	sub	r7,-1
800054f2:	2f 8e       	sub	lr,-8
800054f4:	59 37       	cp.w	r7,19
800054f6:	c0 50       	breq	80005500 <INTC_init_interrupts+0x40>
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
800054f8:	7c 08       	ld.w	r8,lr[0x0]
800054fa:	58 08       	cp.w	r8,0
800054fc:	ce f1       	brne	800054da <INTC_init_interrupts+0x1a>
800054fe:	cf 7b       	rjmp	800054ec <INTC_init_interrupts+0x2c>
80005500:	d8 22       	popm	r4-r7,pc
80005502:	00 00       	add	r0,r0
80005504:	80 00       	ld.sh	r0,r0[0x0]
80005506:	cc 00       	breq	80005486 <INTC_register_interrupt+0x46>
80005508:	80 00       	ld.sh	r0,r0[0x0]
8000550a:	d6 44       	*unknown*
8000550c:	80 00       	ld.sh	r0,r0[0x0]
8000550e:	54 3c       	stdsp	sp[0x10c],r12
80005510:	80 00       	ld.sh	r0,r0[0x0]
80005512:	cd 04       	brge	800054b2 <INTC_register_interrupt+0x72>

80005514 <_get_interrupt_handler>:
__int_handler _get_interrupt_handler(uint32_t int_level)
{
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
80005514:	fe 78 08 00 	mov	r8,-63488
80005518:	e0 69 00 83 	mov	r9,131
8000551c:	f2 0c 01 0c 	sub	r12,r9,r12
80005520:	f0 0c 03 29 	ld.w	r9,r8[r12<<0x2]
	uint32_t int_req = AVR32_INTC.irr[int_grp];
80005524:	f2 ca ff c0 	sub	r10,r9,-64
80005528:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
8000552c:	58 08       	cp.w	r8,0
8000552e:	c0 21       	brne	80005532 <_get_interrupt_handler+0x1e>
80005530:	5e fd       	retal	0
		? _int_handler_table[int_grp]._int_line_handler_table[32
80005532:	f0 08 12 00 	clz	r8,r8
80005536:	48 5a       	lddpc	r10,80005548 <_get_interrupt_handler+0x34>
80005538:	f4 09 00 39 	add	r9,r10,r9<<0x3
8000553c:	f0 08 11 1f 	rsub	r8,r8,31
80005540:	72 19       	ld.w	r9,r9[0x4]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
80005542:	f2 08 03 2c 	ld.w	r12,r9[r8<<0x2]
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
80005546:	5e fc       	retal	r12
80005548:	80 00       	ld.sh	r0,r0[0x0]
8000554a:	d6 44       	*unknown*

8000554c <pm_set_osc32_mode>:
 * \param mode 32-kHz oscillator mode (i.e. AVR32_PM_OSCCTRL32_MODE_x).
 */
static void pm_set_osc32_mode(volatile avr32_pm_t *pm, unsigned int mode)
{
  // Read
  u_avr32_pm_oscctrl32_t u_avr32_pm_oscctrl32 = {pm->oscctrl32};
8000554c:	78 c8       	ld.w	r8,r12[0x30]
  // Modify
  u_avr32_pm_oscctrl32.OSCCTRL32.mode = mode;
8000554e:	f1 db d1 03 	bfins	r8,r11,0x8,0x3
  // Write
  pm->oscctrl32 = u_avr32_pm_oscctrl32.oscctrl32;
80005552:	99 c8       	st.w	r12[0x30],r8
}
80005554:	5e fc       	retal	r12
80005556:	d7 03       	nop

80005558 <pm_enable_osc32_crystal>:
  pm_set_osc32_mode(pm, AVR32_PM_OSCCTRL32_MODE_EXT_CLOCK);
}


void pm_enable_osc32_crystal(volatile avr32_pm_t *pm)
{
80005558:	d4 01       	pushm	lr
  pm_set_osc32_mode(pm, AVR32_PM_OSCCTRL32_MODE_CRYSTAL);
8000555a:	30 1b       	mov	r11,1
8000555c:	f0 1f 00 02 	mcall	80005564 <pm_enable_osc32_crystal+0xc>
}
80005560:	d8 02       	popm	pc
80005562:	00 00       	add	r0,r0
80005564:	80 00       	ld.sh	r0,r0[0x0]
80005566:	55 4c       	stdsp	sp[0x150],r12

80005568 <pm_enable_clk32_no_wait>:


void pm_enable_clk32_no_wait(volatile avr32_pm_t *pm, unsigned int startup)
{
  // Read register
  u_avr32_pm_oscctrl32_t u_avr32_pm_oscctrl32 = {pm->oscctrl32};
80005568:	78 c8       	ld.w	r8,r12[0x30]
  // Modify
  u_avr32_pm_oscctrl32.OSCCTRL32.osc32en = 1;
8000556a:	30 19       	mov	r9,1
8000556c:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
  u_avr32_pm_oscctrl32.OSCCTRL32.startup = startup;
80005570:	f1 db d2 03 	bfins	r8,r11,0x10,0x3
  // Write back
  pm->oscctrl32 = u_avr32_pm_oscctrl32.oscctrl32;
80005574:	99 c8       	st.w	r12[0x30],r8
}
80005576:	5e fc       	retal	r12

80005578 <pm_wait_for_clk32_ready>:


void pm_wait_for_clk32_ready(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_OSC32RDY_MASK));
80005578:	79 58       	ld.w	r8,r12[0x54]
8000557a:	e2 18 02 00 	andl	r8,0x200,COH
8000557e:	cf d0       	breq	80005578 <pm_wait_for_clk32_ready>
}
80005580:	5e fc       	retal	r12
80005582:	d7 03       	nop

80005584 <pm_enable_clk32>:
  pm_set_osc32_mode(pm, AVR32_PM_OSCCTRL32_MODE_CRYSTAL);
}


void pm_enable_clk32(volatile avr32_pm_t *pm, unsigned int startup)
{
80005584:	eb cd 40 80 	pushm	r7,lr
80005588:	18 97       	mov	r7,r12
  pm_enable_clk32_no_wait(pm, startup);
8000558a:	f0 1f 00 04 	mcall	80005598 <pm_enable_clk32+0x14>
  pm_wait_for_clk32_ready(pm);
8000558e:	0e 9c       	mov	r12,r7
80005590:	f0 1f 00 03 	mcall	8000559c <pm_enable_clk32+0x18>
}
80005594:	e3 cd 80 80 	ldm	sp++,r7,pc
80005598:	80 00       	ld.sh	r0,r0[0x0]
8000559a:	55 68       	stdsp	sp[0x158],r8
8000559c:	80 00       	ld.sh	r0,r0[0x0]
8000559e:	55 78       	stdsp	sp[0x15c],r8

800055a0 <rtc_is_busy>:
#include "rtc.h"


int rtc_is_busy(volatile avr32_rtc_t *rtc)
{
  return (rtc->ctrl & AVR32_RTC_CTRL_BUSY_MASK) != 0;
800055a0:	78 0c       	ld.w	r12,r12[0x0]
}
800055a2:	f9 dc c0 81 	bfextu	r12,r12,0x4,0x1
800055a6:	5e fc       	retal	r12

800055a8 <rtc_set_value>:
  return 1;
}


void rtc_set_value(volatile avr32_rtc_t *rtc, unsigned long val)
{
800055a8:	eb cd 40 c0 	pushm	r6-r7,lr
800055ac:	18 97       	mov	r7,r12
800055ae:	16 96       	mov	r6,r11
  // Wait until we can write into the VAL register
  while (rtc_is_busy(rtc));
800055b0:	0e 9c       	mov	r12,r7
800055b2:	f0 1f 00 06 	mcall	800055c8 <rtc_set_value+0x20>
800055b6:	cf d1       	brne	800055b0 <rtc_set_value+0x8>
  // Set the new val value
  rtc->val = val;
800055b8:	8f 16       	st.w	r7[0x4],r6
  // Wait until write is done
  while (rtc_is_busy(rtc));
800055ba:	0e 9c       	mov	r12,r7
800055bc:	f0 1f 00 03 	mcall	800055c8 <rtc_set_value+0x20>
800055c0:	cf d1       	brne	800055ba <rtc_set_value+0x12>
}
800055c2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800055c6:	00 00       	add	r0,r0
800055c8:	80 00       	ld.sh	r0,r0[0x0]
800055ca:	55 a0       	stdsp	sp[0x168],r0

800055cc <rtc_enable>:
  while (rtc_is_busy(rtc));
}


void rtc_enable(volatile avr32_rtc_t *rtc)
{
800055cc:	eb cd 40 80 	pushm	r7,lr
800055d0:	18 97       	mov	r7,r12
  // Wait until the rtc CTRL register is up-to-date
  while (rtc_is_busy(rtc));
800055d2:	0e 9c       	mov	r12,r7
800055d4:	f0 1f 00 06 	mcall	800055ec <rtc_enable+0x20>
800055d8:	cf d1       	brne	800055d2 <rtc_enable+0x6>
  // Enable the RTC
  rtc->ctrl |= AVR32_RTC_CTRL_EN_MASK;
800055da:	6e 08       	ld.w	r8,r7[0x0]
800055dc:	a1 a8       	sbr	r8,0x0
800055de:	8f 08       	st.w	r7[0x0],r8
  // Wait until write is done
  while (rtc_is_busy(rtc));
800055e0:	0e 9c       	mov	r12,r7
800055e2:	f0 1f 00 03 	mcall	800055ec <rtc_enable+0x20>
800055e6:	cf d1       	brne	800055e0 <rtc_enable+0x14>
}
800055e8:	e3 cd 80 80 	ldm	sp++,r7,pc
800055ec:	80 00       	ld.sh	r0,r0[0x0]
800055ee:	55 a0       	stdsp	sp[0x168],r0

800055f0 <rtc_enable_interrupt>:
}


void rtc_enable_interrupt(volatile avr32_rtc_t *rtc)
{
  rtc->ier = AVR32_RTC_IER_TOPI_MASK;
800055f0:	30 18       	mov	r8,1
800055f2:	99 48       	st.w	r12[0x10],r8
}
800055f4:	5e fc       	retal	r12
800055f6:	d7 03       	nop

800055f8 <rtc_set_top_value>:
  if (global_interrupt_enabled) cpu_irq_enable();
}


void rtc_set_top_value(volatile avr32_rtc_t *rtc, unsigned long top)
{
800055f8:	eb cd 40 c0 	pushm	r6-r7,lr
800055fc:	18 97       	mov	r7,r12
800055fe:	16 96       	mov	r6,r11
  // Wait until we can write into the VAL register
  while (rtc_is_busy(rtc));
80005600:	0e 9c       	mov	r12,r7
80005602:	f0 1f 00 06 	mcall	80005618 <rtc_set_top_value+0x20>
80005606:	cf d1       	brne	80005600 <rtc_set_top_value+0x8>
  // Set the new val value
  rtc->top = top;
80005608:	8f 26       	st.w	r7[0x8],r6
  // Wait until write is done
  while (rtc_is_busy(rtc));
8000560a:	0e 9c       	mov	r12,r7
8000560c:	f0 1f 00 03 	mcall	80005618 <rtc_set_top_value+0x20>
80005610:	cf d1       	brne	8000560a <rtc_set_top_value+0x12>
}
80005612:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005616:	00 00       	add	r0,r0
80005618:	80 00       	ld.sh	r0,r0[0x0]
8000561a:	55 a0       	stdsp	sp[0x168],r0

8000561c <rtc_clear_interrupt>:
}


void rtc_clear_interrupt(volatile avr32_rtc_t *rtc)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
8000561c:	e1 b8 00 00 	mfsr	r8,0x0

  if (global_interrupt_enabled) cpu_irq_disable();
80005620:	e6 18 00 01 	andh	r8,0x1,COH
80005624:	c0 71       	brne	80005632 <rtc_clear_interrupt+0x16>
80005626:	d3 03       	ssrf	0x10
  rtc->icr = AVR32_RTC_ICR_TOPI_MASK;
80005628:	30 18       	mov	r8,1
8000562a:	99 88       	st.w	r12[0x20],r8
  rtc->isr;
8000562c:	78 78       	ld.w	r8,r12[0x1c]
  if (global_interrupt_enabled) cpu_irq_enable();
8000562e:	d5 03       	csrf	0x10
80005630:	5e fc       	retal	r12
void rtc_clear_interrupt(volatile avr32_rtc_t *rtc)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  if (global_interrupt_enabled) cpu_irq_disable();
  rtc->icr = AVR32_RTC_ICR_TOPI_MASK;
80005632:	30 18       	mov	r8,1
80005634:	99 88       	st.w	r12[0x20],r8
  rtc->isr;
80005636:	78 78       	ld.w	r8,r12[0x1c]
80005638:	5e fc       	retal	r12
8000563a:	d7 03       	nop

8000563c <rtc_init>:
  return (rtc->ctrl & AVR32_RTC_CTRL_BUSY_MASK) != 0;
}


int rtc_init(volatile avr32_rtc_t *rtc, unsigned char osc_type, unsigned char psel)
{
8000563c:	eb cd 40 e0 	pushm	r5-r7,lr
80005640:	18 97       	mov	r7,r12
80005642:	16 96       	mov	r6,r11
80005644:	14 95       	mov	r5,r10
  // If exit, it means that the configuration has not been set correctly
  if (osc_type > (1 << AVR32_RTC_CTRL_CLK32_SIZE) - 1 ||
80005646:	30 18       	mov	r8,1
80005648:	f0 0b 18 00 	cp.b	r11,r8
8000564c:	5f b9       	srhi	r9
8000564e:	30 f8       	mov	r8,15
80005650:	f0 0a 18 00 	cp.b	r10,r8
80005654:	5f b8       	srhi	r8
80005656:	f3 e8 10 08 	or	r8,r9,r8
8000565a:	c0 30       	breq	80005660 <rtc_init+0x24>
8000565c:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
      psel > (1 << AVR32_RTC_CTRL_PSEL_SIZE) - 1)
    return 0;

  // If we use the 32-kHz oscillator, we have to enable it first
  if (osc_type == RTC_OSC_32KHZ)
80005660:	30 18       	mov	r8,1
80005662:	f0 0b 18 00 	cp.b	r11,r8
80005666:	c0 a1       	brne	8000567a <rtc_init+0x3e>
  {
    // Select the 32-kHz oscillator crystal
    pm_enable_osc32_crystal(&AVR32_PM);
80005668:	fe 7c 0c 00 	mov	r12,-62464
8000566c:	f0 1f 00 0f 	mcall	800056a8 <rtc_init+0x6c>
    // Enable the 32-kHz clock and wait until the osc32 clock is ready.
    pm_enable_clk32(&AVR32_PM, AVR32_PM_OSCCTRL32_STARTUP_0_RCOSC);
80005670:	30 0b       	mov	r11,0
80005672:	fe 7c 0c 00 	mov	r12,-62464
80005676:	f0 1f 00 0e 	mcall	800056ac <rtc_init+0x70>
  }

  // Wait until the rtc accepts writes to the CTRL register
  while (rtc_is_busy(rtc));
8000567a:	0e 9c       	mov	r12,r7
8000567c:	f0 1f 00 0d 	mcall	800056b0 <rtc_init+0x74>
80005680:	cf d1       	brne	8000567a <rtc_init+0x3e>

  // Set the new RTC configuration
  rtc->ctrl = osc_type << AVR32_RTC_CTRL_CLK32_OFFSET |
80005682:	a3 76       	lsl	r6,0x3
80005684:	b1 a6       	sbr	r6,0x10
80005686:	ed e5 10 85 	or	r5,r6,r5<<0x8
8000568a:	8f 05       	st.w	r7[0x0],r5
              psel << AVR32_RTC_CTRL_PSEL_OFFSET |
              AVR32_RTC_CTRL_CLKEN_MASK;

  // Wait until write is done
  while (rtc_is_busy(rtc));
8000568c:	0e 9c       	mov	r12,r7
8000568e:	f0 1f 00 09 	mcall	800056b0 <rtc_init+0x74>
80005692:	cf d1       	brne	8000568c <rtc_init+0x50>

  // Set the counter value to 0
  rtc_set_value(rtc, 0x00000000);
80005694:	30 0b       	mov	r11,0
80005696:	0e 9c       	mov	r12,r7
80005698:	f0 1f 00 07 	mcall	800056b4 <rtc_init+0x78>
  // Set the top value to 0xFFFFFFFF
  rtc_set_top_value(rtc, 0xFFFFFFFF);
8000569c:	3f fb       	mov	r11,-1
8000569e:	0e 9c       	mov	r12,r7
800056a0:	f0 1f 00 06 	mcall	800056b8 <rtc_init+0x7c>
800056a4:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
800056a8:	80 00       	ld.sh	r0,r0[0x0]
800056aa:	55 58       	stdsp	sp[0x154],r8
800056ac:	80 00       	ld.sh	r0,r0[0x0]
800056ae:	55 84       	stdsp	sp[0x160],r4
800056b0:	80 00       	ld.sh	r0,r0[0x0]
800056b2:	55 a0       	stdsp	sp[0x168],r0
800056b4:	80 00       	ld.sh	r0,r0[0x0]
800056b6:	55 a8       	stdsp	sp[0x168],r8
800056b8:	80 00       	ld.sh	r0,r0[0x0]
800056ba:	55 f8       	stdsp	sp[0x17c],r8

800056bc <getBaudDiv>:
xSemaphoreHandle xSPIMutex;
#endif

int16_t getBaudDiv(const uint32_t baudrate, uint32_t pb_hz)
{
	uint32_t baudDiv = div_ceil(pb_hz, baudrate);
800056bc:	f8 c8 00 01 	sub	r8,r12,1
800056c0:	f0 0b 00 0b 	add	r11,r8,r11
800056c4:	f6 0c 0d 0a 	divu	r10,r11,r12
800056c8:	14 9c       	mov	r12,r10

	if (baudDiv <= 0 || baudDiv > 255) {
800056ca:	f4 c8 00 01 	sub	r8,r10,1
800056ce:	e0 48 00 fe 	cp.w	r8,254
800056d2:	e0 88 00 03 	brls	800056d8 <getBaudDiv+0x1c>
800056d6:	5e fe       	retal	-1
		return -1;
	}

	return baudDiv;
800056d8:	5c 8c       	casts.h	r12
}
800056da:	5e fc       	retal	r12

800056dc <spi_initMaster>:
spi_status_t spi_initMaster(volatile avr32_spi_t *spi,
		const spi_options_t *options)
{
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (options->modfdis > 1) {
800056dc:	f7 39 00 0d 	ld.ub	r9,r11[13]
800056e0:	30 18       	mov	r8,1
800056e2:	f0 09 18 00 	cp.b	r9,r8
800056e6:	e0 88 00 04 	brls	800056ee <spi_initMaster+0x12>
800056ea:	30 2c       	mov	r12,2
800056ec:	5e fc       	retal	r12
		return SPI_ERROR_ARGUMENT;
	}

	/* Reset. */
	spi->cr = AVR32_SPI_CR_SWRST_MASK;
800056ee:	e0 68 00 80 	mov	r8,128
800056f2:	99 08       	st.w	r12[0x0],r8

	/* Master Mode. */
	u_avr32_spi_mr.mr = spi->mr;
800056f4:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.mstr = 1;
800056f6:	30 19       	mov	r9,1
800056f8:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_mr.MR.modfdis = options->modfdis;
800056fc:	f7 39 00 0d 	ld.ub	r9,r11[13]
80005700:	f1 d9 d0 81 	bfins	r8,r9,0x4,0x1
	u_avr32_spi_mr.MR.llb = 0;
80005704:	30 09       	mov	r9,0
80005706:	f1 d9 d0 e1 	bfins	r8,r9,0x7,0x1
	u_avr32_spi_mr.MR.pcs = (1 << AVR32_SPI_MR_PCS_SIZE) - 1;
8000570a:	30 fa       	mov	r10,15
8000570c:	f1 da d2 04 	bfins	r8,r10,0x10,0x4
	spi->mr = u_avr32_spi_mr.mr;
80005710:	99 18       	st.w	r12[0x4],r8
80005712:	5e f9       	retal	r9

80005714 <spi_selectionMode>:

spi_status_t spi_selectionMode(volatile avr32_spi_t *spi,
		uint8_t variable_ps,
		uint8_t pcs_decode,
		uint8_t delay)
{
80005714:	d4 01       	pushm	lr
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (variable_ps > 1 ||
80005716:	30 18       	mov	r8,1
80005718:	f0 0b 18 00 	cp.b	r11,r8
8000571c:	5f be       	srhi	lr
8000571e:	f0 0a 18 00 	cp.b	r10,r8
80005722:	5f b8       	srhi	r8
80005724:	fd e8 10 08 	or	r8,lr,r8
80005728:	c0 30       	breq	8000572e <spi_selectionMode+0x1a>
8000572a:	30 2c       	mov	r12,2
8000572c:	d8 02       	popm	pc
			pcs_decode > 1) {
		return SPI_ERROR_ARGUMENT;
	}

	u_avr32_spi_mr.mr = spi->mr;
8000572e:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.ps = variable_ps;
80005730:	f1 db d0 21 	bfins	r8,r11,0x1,0x1
	u_avr32_spi_mr.MR.pcsdec = pcs_decode;
80005734:	f1 da d0 41 	bfins	r8,r10,0x2,0x1
	u_avr32_spi_mr.MR.dlybcs = delay;
80005738:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8
	spi->mr = u_avr32_spi_mr.mr;
8000573c:	99 18       	st.w	r12[0x4],r8
8000573e:	d8 0a       	popm	pc,r12=0

80005740 <spi_enable>:
	return SPI_OK;
}

void spi_enable(volatile avr32_spi_t *spi)
{
	spi->cr = AVR32_SPI_CR_SPIEN_MASK;
80005740:	30 18       	mov	r8,1
80005742:	99 08       	st.w	r12[0x0],r8
}
80005744:	5e fc       	retal	r12

80005746 <spi_write>:
{
	return ((spi->sr & AVR32_SPI_SR_TDRE_MASK) != 0);
}

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
80005746:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
8000574a:	c0 58       	rjmp	80005754 <spi_write+0xe>
		if (!timeout--) {
8000574c:	58 08       	cp.w	r8,0
8000574e:	c0 21       	brne	80005752 <spi_write+0xc>
80005750:	5e ff       	retal	1
80005752:	20 18       	sub	r8,1

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
80005754:	78 49       	ld.w	r9,r12[0x10]
80005756:	e2 19 00 02 	andl	r9,0x2,COH
8000575a:	cf 90       	breq	8000574c <spi_write+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	spi->tdr = data << AVR32_SPI_TDR_TD_OFFSET;
8000575c:	5c 7b       	castu.h	r11
8000575e:	99 3b       	st.w	r12[0xc],r11
80005760:	5e fd       	retal	0

80005762 <spi_read>:
{
	return ((spi->sr & AVR32_SPI_SR_RDRF_MASK) != 0);
}

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
80005762:	e0 68 3a 98 	mov	r8,15000
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
80005766:	c0 58       	rjmp	80005770 <spi_read+0xe>
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) !=
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) {
		if (!timeout--) {
80005768:	58 08       	cp.w	r8,0
8000576a:	c0 21       	brne	8000576e <spi_read+0xc>
8000576c:	5e ff       	retal	1
8000576e:	20 18       	sub	r8,1

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
80005770:	78 49       	ld.w	r9,r12[0x10]
80005772:	e2 19 02 01 	andl	r9,0x201,COH
80005776:	e0 49 02 01 	cp.w	r9,513
8000577a:	cf 71       	brne	80005768 <spi_read+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	*data = spi->rdr >> AVR32_SPI_RDR_RD_OFFSET;
8000577c:	78 28       	ld.w	r8,r12[0x8]
8000577e:	b6 08       	st.h	r11[0x0],r8
80005780:	5e fd       	retal	0
80005782:	d7 03       	nop

80005784 <spi_setupChipReg>:
}

spi_status_t spi_setupChipReg(volatile avr32_spi_t *spi,
		const spi_options_t *options,
		uint32_t pb_hz)
{
80005784:	eb cd 40 f8 	pushm	r3-r7,lr
80005788:	18 95       	mov	r5,r12
8000578a:	16 97       	mov	r7,r11
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
8000578c:	f7 36 00 0c 	ld.ub	r6,r11[12]
80005790:	30 38       	mov	r8,3
80005792:	f0 06 18 00 	cp.b	r6,r8
80005796:	e0 8b 00 5e 	brhi	80005852 <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
8000579a:	f7 34 00 0b 	ld.ub	r4,r11[11]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
8000579e:	30 18       	mov	r8,1
800057a0:	f0 04 18 00 	cp.b	r4,r8
800057a4:	e0 8b 00 57 	brhi	80005852 <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
800057a8:	f7 33 00 08 	ld.ub	r3,r11[8]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
800057ac:	30 78       	mov	r8,7
800057ae:	f0 03 18 00 	cp.b	r3,r8
800057b2:	e0 88 00 50 	brls	80005852 <spi_setupChipReg+0xce>
800057b6:	31 08       	mov	r8,16
800057b8:	f0 03 18 00 	cp.b	r3,r8
800057bc:	e0 8b 00 4b 	brhi	80005852 <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
		return SPI_ERROR_ARGUMENT;
	}

	int baudDiv = getBaudDiv(options->baudrate, pb_hz);
800057c0:	14 9b       	mov	r11,r10
800057c2:	6e 1c       	ld.w	r12,r7[0x4]
800057c4:	f0 1f 00 26 	mcall	8000585c <spi_setupChipReg+0xd8>

	if (baudDiv < 0) {
800057c8:	c4 55       	brlt	80005852 <spi_setupChipReg+0xce>
		return SPI_ERROR_ARGUMENT;
	}

	/* Will use CSR0 offsets; these are the same for CSR0 to CSR3. */
	u_avr32_spi_csr.csr = 0;
800057ca:	30 08       	mov	r8,0
	u_avr32_spi_csr.CSR.cpol   = options->spi_mode >> 1;
800057cc:	ec 09 16 01 	lsr	r9,r6,0x1
800057d0:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_csr.CSR.ncpha  = (options->spi_mode & 0x1) ^ 0x1;
800057d4:	ec 16 00 01 	eorl	r6,0x1
800057d8:	f1 d6 d0 21 	bfins	r8,r6,0x1,0x1
	u_avr32_spi_csr.CSR.csaat  = options->stay_act;
800057dc:	f1 d4 d0 61 	bfins	r8,r4,0x3,0x1
	u_avr32_spi_csr.CSR.bits   = options->bits - 8;
800057e0:	20 83       	sub	r3,8
800057e2:	f1 d3 d0 84 	bfins	r8,r3,0x4,0x4
	u_avr32_spi_csr.CSR.scbr   = baudDiv;
800057e6:	f1 dc d1 08 	bfins	r8,r12,0x8,0x8
	u_avr32_spi_csr.CSR.dlybs  = options->spck_delay;
800057ea:	ef 39 00 09 	ld.ub	r9,r7[9]
800057ee:	f1 d9 d2 08 	bfins	r8,r9,0x10,0x8
	u_avr32_spi_csr.CSR.dlybct = options->trans_delay;
800057f2:	ef 39 00 0a 	ld.ub	r9,r7[10]
800057f6:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8

	switch (options->reg) {
800057fa:	0f 89       	ld.ub	r9,r7[0x0]
800057fc:	30 1a       	mov	r10,1
800057fe:	f4 09 18 00 	cp.b	r9,r10
80005802:	c0 d0       	breq	8000581c <spi_setupChipReg+0x98>
80005804:	c0 a3       	brcs	80005818 <spi_setupChipReg+0x94>
80005806:	30 2a       	mov	r10,2
80005808:	f4 09 18 00 	cp.b	r9,r10
8000580c:	c0 a0       	breq	80005820 <spi_setupChipReg+0x9c>
8000580e:	30 3a       	mov	r10,3
80005810:	f4 09 18 00 	cp.b	r9,r10
80005814:	c1 f1       	brne	80005852 <spi_setupChipReg+0xce>
80005816:	c0 78       	rjmp	80005824 <spi_setupChipReg+0xa0>
	case 0:
		spi->csr0 = u_avr32_spi_csr.csr;
80005818:	8b c8       	st.w	r5[0x30],r8
		break;
8000581a:	c0 68       	rjmp	80005826 <spi_setupChipReg+0xa2>

	case 1:
		spi->csr1 = u_avr32_spi_csr.csr;
8000581c:	8b d8       	st.w	r5[0x34],r8
		break;
8000581e:	c0 48       	rjmp	80005826 <spi_setupChipReg+0xa2>

	case 2:
		spi->csr2 = u_avr32_spi_csr.csr;
80005820:	8b e8       	st.w	r5[0x38],r8
		break;
80005822:	c0 28       	rjmp	80005826 <spi_setupChipReg+0xa2>

	case 3:
		spi->csr3 = u_avr32_spi_csr.csr;
80005824:	8b f8       	st.w	r5[0x3c],r8
	default:
		return SPI_ERROR_ARGUMENT;
	}

#ifdef FREERTOS_USED
	if (!xSPIMutex) {
80005826:	48 f8       	lddpc	r8,80005860 <spi_setupChipReg+0xdc>
80005828:	70 08       	ld.w	r8,r8[0x0]
8000582a:	58 08       	cp.w	r8,0
8000582c:	c1 61       	brne	80005858 <spi_setupChipReg+0xd4>
		/* Create the SPI mutex. */
		vSemaphoreCreateBinary(xSPIMutex);
8000582e:	30 0b       	mov	r11,0
80005830:	30 1c       	mov	r12,1
80005832:	f0 1f 00 0d 	mcall	80005864 <spi_setupChipReg+0xe0>
80005836:	48 b8       	lddpc	r8,80005860 <spi_setupChipReg+0xdc>
80005838:	91 0c       	st.w	r8[0x0],r12
8000583a:	58 0c       	cp.w	r12,0
8000583c:	c0 a0       	breq	80005850 <spi_setupChipReg+0xcc>
8000583e:	30 09       	mov	r9,0
80005840:	12 9a       	mov	r10,r9
80005842:	12 9b       	mov	r11,r9
80005844:	f0 1f 00 09 	mcall	80005868 <spi_setupChipReg+0xe4>
		if (!xSPIMutex) {
80005848:	48 68       	lddpc	r8,80005860 <spi_setupChipReg+0xdc>
8000584a:	70 08       	ld.w	r8,r8[0x0]
8000584c:	58 08       	cp.w	r8,0
8000584e:	c0 51       	brne	80005858 <spi_setupChipReg+0xd4>
80005850:	c0 08       	rjmp	80005850 <spi_setupChipReg+0xcc>
80005852:	30 2c       	mov	r12,2
80005854:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80005858:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
8000585c:	80 00       	ld.sh	r0,r0[0x0]
8000585e:	56 bc       	stdsp	sp[0x1ac],r12
80005860:	00 00       	add	r0,r0
80005862:	51 20       	stdsp	sp[0x48],r0
80005864:	80 00       	ld.sh	r0,r0[0x0]
80005866:	63 50       	ld.w	r0,r1[0x54]
80005868:	80 00       	ld.sh	r0,r0[0x0]
8000586a:	62 50       	ld.w	r0,r1[0x14]

8000586c <spi_unselectChip>:

	return SPI_OK;
}

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
8000586c:	d4 01       	pushm	lr
8000586e:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
80005872:	c0 58       	rjmp	8000587c <spi_unselectChip+0x10>
		if (!timeout--) {
80005874:	58 08       	cp.w	r8,0
80005876:	c0 21       	brne	8000587a <spi_unselectChip+0xe>
80005878:	da 0a       	popm	pc,r12=1
8000587a:	20 18       	sub	r8,1

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
8000587c:	78 49       	ld.w	r9,r12[0x10]
8000587e:	e2 19 02 00 	andl	r9,0x200,COH
80005882:	cf 90       	breq	80005874 <spi_unselectChip+0x8>
			return SPI_ERROR_TIMEOUT;
		}
	}

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
80005884:	78 18       	ld.w	r8,r12[0x4]
80005886:	ea 18 00 0f 	orh	r8,0xf
8000588a:	99 18       	st.w	r12[0x4],r8

	/* Last transfer, so de-assert the current NPCS if CSAAT is set. */
	spi->cr = AVR32_SPI_CR_LASTXFER_MASK;
8000588c:	fc 18 01 00 	movh	r8,0x100
80005890:	99 08       	st.w	r12[0x0],r8

#ifdef FREERTOS_USED
	xSemaphoreGive(xSPIMutex);
80005892:	30 09       	mov	r9,0
80005894:	12 9a       	mov	r10,r9
80005896:	12 9b       	mov	r11,r9
80005898:	48 38       	lddpc	r8,800058a4 <spi_unselectChip+0x38>
8000589a:	70 0c       	ld.w	r12,r8[0x0]
8000589c:	f0 1f 00 03 	mcall	800058a8 <spi_unselectChip+0x3c>
800058a0:	d8 0a       	popm	pc,r12=0
800058a2:	00 00       	add	r0,r0
800058a4:	00 00       	add	r0,r0
800058a6:	51 20       	stdsp	sp[0x48],r0
800058a8:	80 00       	ld.sh	r0,r0[0x0]
800058aa:	62 50       	ld.w	r0,r1[0x14]

800058ac <spi_selectChip>:

	return SPI_OK;
}

spi_status_t spi_selectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
800058ac:	eb cd 40 f8 	pushm	r3-r7,lr
800058b0:	18 94       	mov	r4,r12
800058b2:	16 93       	mov	r3,r11
#ifdef FREERTOS_USED
	while (pdFALSE == xSemaphoreTake(xSPIMutex, 20)) {
800058b4:	49 a6       	lddpc	r6,8000591c <spi_selectChip+0x70>
800058b6:	30 07       	mov	r7,0
800058b8:	31 45       	mov	r5,20
800058ba:	0e 99       	mov	r9,r7
800058bc:	0a 9a       	mov	r10,r5
800058be:	0e 9b       	mov	r11,r7
800058c0:	6c 0c       	ld.w	r12,r6[0x0]
800058c2:	f0 1f 00 18 	mcall	80005920 <spi_selectChip+0x74>
800058c6:	cf a0       	breq	800058ba <spi_selectChip+0xe>
	}
#endif

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
800058c8:	68 18       	ld.w	r8,r4[0x4]
800058ca:	ea 18 00 0f 	orh	r8,0xf
800058ce:	89 18       	st.w	r4[0x4],r8

	if (spi->mr & AVR32_SPI_MR_PCSDEC_MASK) {
800058d0:	68 18       	ld.w	r8,r4[0x4]
800058d2:	e2 18 00 04 	andl	r8,0x4,COH
800058d6:	c1 10       	breq	800058f8 <spi_selectChip+0x4c>
		/* The signal is decoded; allow up to 15 chips. */
		if (chip > 14) {
800058d8:	30 e8       	mov	r8,14
800058da:	f0 03 18 00 	cp.b	r3,r8
800058de:	e0 8b 00 1c 	brhi	80005916 <spi_selectChip+0x6a>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~AVR32_SPI_MR_PCS_MASK |
800058e2:	68 19       	ld.w	r9,r4[0x4]
800058e4:	e6 08 15 10 	lsl	r8,r3,0x10
800058e8:	ea 18 ff f0 	orh	r8,0xfff0
800058ec:	e8 18 ff ff 	orl	r8,0xffff
800058f0:	12 68       	and	r8,r9
800058f2:	89 18       	st.w	r4[0x4],r8
800058f4:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
				(chip << AVR32_SPI_MR_PCS_OFFSET);
	} else {
		if (chip > 3) {
800058f8:	30 38       	mov	r8,3
800058fa:	f0 03 18 00 	cp.b	r3,r8
800058fe:	e0 8b 00 0c 	brhi	80005916 <spi_selectChip+0x6a>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~(1 << (AVR32_SPI_MR_PCS_OFFSET + chip));
80005902:	68 19       	ld.w	r9,r4[0x4]
80005904:	2f 03       	sub	r3,-16
80005906:	30 18       	mov	r8,1
80005908:	f0 03 09 48 	lsl	r8,r8,r3
8000590c:	5c d8       	com	r8
8000590e:	12 68       	and	r8,r9
80005910:	89 18       	st.w	r4[0x4],r8
80005912:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
80005916:	30 2c       	mov	r12,2
	}

	return SPI_OK;
}
80005918:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
8000591c:	00 00       	add	r0,r0
8000591e:	51 20       	stdsp	sp[0x48],r0
80005920:	80 00       	ld.sh	r0,r0[0x0]
80005922:	60 44       	ld.w	r4,r0[0x10]

80005924 <usart_set_async_baudrate>:
 *
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
80005924:	d4 01       	pushm	lr
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
80005926:	f6 08 15 04 	lsl	r8,r11,0x4
8000592a:	14 38       	cp.w	r8,r10
8000592c:	f9 b8 08 10 	movls	r8,16
80005930:	f9 b8 0b 08 	movhi	r8,8
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
80005934:	f0 0b 02 4b 	mul	r11,r8,r11
80005938:	f6 09 16 01 	lsr	r9,r11,0x1
8000593c:	f2 0a 00 3a 	add	r10,r9,r10<<0x3
80005940:	f4 0b 0d 0a 	divu	r10,r10,r11
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
80005944:	f4 09 16 03 	lsr	r9,r10,0x3
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
80005948:	f2 cb 00 01 	sub	r11,r9,1
8000594c:	e0 4b ff fe 	cp.w	r11,65534
80005950:	e0 88 00 03 	brls	80005956 <usart_set_async_baudrate+0x32>
80005954:	da 0a       	popm	pc,r12=1
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
80005956:	78 1b       	ld.w	r11,r12[0x4]
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
80005958:	e8 6e 00 00 	mov	lr,524288
8000595c:	59 08       	cp.w	r8,16
8000595e:	fc 08 17 10 	movne	r8,lr
80005962:	f9 b8 00 00 	moveq	r8,0
80005966:	e4 1b ff f7 	andh	r11,0xfff7
8000596a:	e0 1b fe cf 	andl	r11,0xfecf
8000596e:	16 48       	or	r8,r11
80005970:	99 18       	st.w	r12[0x4],r8
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
80005972:	f5 da c0 03 	bfextu	r10,r10,0x0,0x3
80005976:	f3 ea 11 09 	or	r9,r9,r10<<0x10
8000597a:	99 89       	st.w	r12[0x20],r9
8000597c:	d8 0a       	popm	pc,r12=0

8000597e <usart_write_char>:
 *
 * \return \c 1 if the USART Transmit Holding Register is free, otherwise \c 0.
 */
__always_inline static int usart_tx_ready(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_TXRDY_MASK) != 0;
8000597e:	78 58       	ld.w	r8,r12[0x14]
}


int usart_write_char(volatile avr32_usart_t *usart, int c)
{
  if (usart_tx_ready(usart))
80005980:	e2 18 00 02 	andl	r8,0x2,COH
80005984:	c0 31       	brne	8000598a <usart_write_char+0xc>
80005986:	30 2c       	mov	r12,2
80005988:	5e fc       	retal	r12
  {
    usart->thr = (c << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
8000598a:	f7 db c0 09 	bfextu	r11,r11,0x0,0x9
8000598e:	99 7b       	st.w	r12[0x1c],r11
80005990:	5e fd       	retal	0
80005992:	d7 03       	nop

80005994 <usart_putchar>:
    return USART_TX_BUSY;
}


int usart_putchar(volatile avr32_usart_t *usart, int c)
{
80005994:	eb cd 40 e0 	pushm	r5-r7,lr
80005998:	18 96       	mov	r6,r12
8000599a:	16 95       	mov	r5,r11
8000599c:	e0 67 27 0f 	mov	r7,9999
800059a0:	c0 68       	rjmp	800059ac <usart_putchar+0x18>
  int timeout = USART_DEFAULT_TIMEOUT;

  do
  {
    if (!timeout--) return USART_FAILURE;
800059a2:	58 07       	cp.w	r7,0
800059a4:	c0 31       	brne	800059aa <usart_putchar+0x16>
800059a6:	e3 cf c0 e0 	ldm	sp++,r5-r7,pc,r12=-1
800059aa:	20 17       	sub	r7,1
  } while (usart_write_char(usart, c) != USART_SUCCESS);
800059ac:	0a 9b       	mov	r11,r5
800059ae:	0c 9c       	mov	r12,r6
800059b0:	f0 1f 00 03 	mcall	800059bc <usart_putchar+0x28>
800059b4:	cf 71       	brne	800059a2 <usart_putchar+0xe>

  return USART_SUCCESS;
}
800059b6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800059ba:	00 00       	add	r0,r0
800059bc:	80 00       	ld.sh	r0,r0[0x0]
800059be:	59 7e       	cp.w	lr,23

800059c0 <usart_read_char>:

int usart_read_char(volatile avr32_usart_t *usart, int *c)
{
  // Check for errors: frame, parity and overrun. In RS485 mode, a parity error
  // would mean that an address char has been received.
  if (usart->csr & (AVR32_USART_CSR_OVRE_MASK |
800059c0:	78 58       	ld.w	r8,r12[0x14]
800059c2:	e2 18 00 e0 	andl	r8,0xe0,COH
800059c6:	c0 30       	breq	800059cc <usart_read_char+0xc>
800059c8:	30 4c       	mov	r12,4
800059ca:	5e fc       	retal	r12
 *
 * \return \c 1 if the USART Receive Holding Register is full, otherwise \c 0.
 */
__always_inline static int usart_test_hit(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_RXRDY_MASK) != 0;
800059cc:	78 58       	ld.w	r8,r12[0x14]
                    AVR32_USART_CSR_FRAME_MASK |
                    AVR32_USART_CSR_PARE_MASK))
    return USART_RX_ERROR;

  // No error; if we really did receive a char, read it and return SUCCESS.
  if (usart_test_hit(usart))
800059ce:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800059d2:	c0 31       	brne	800059d8 <usart_read_char+0x18>
800059d4:	30 3c       	mov	r12,3
800059d6:	5e fc       	retal	r12
  {
    *c = (usart->rhr & AVR32_USART_RHR_RXCHR_MASK) >> AVR32_USART_RHR_RXCHR_OFFSET;
800059d8:	78 68       	ld.w	r8,r12[0x18]
800059da:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
800059de:	97 08       	st.w	r11[0x0],r8
800059e0:	5e fd       	retal	0
800059e2:	d7 03       	nop

800059e4 <usart_getchar>:
    return USART_RX_EMPTY;
}


int usart_getchar(volatile avr32_usart_t *usart)
{
800059e4:	eb cd 40 c0 	pushm	r6-r7,lr
800059e8:	20 1d       	sub	sp,4
800059ea:	18 96       	mov	r6,r12
  int c, ret;

  while ((ret = usart_read_char(usart, &c)) == USART_RX_EMPTY);
800059ec:	1a 97       	mov	r7,sp
800059ee:	1a 9b       	mov	r11,sp
800059f0:	0c 9c       	mov	r12,r6
800059f2:	f0 1f 00 07 	mcall	80005a0c <usart_getchar+0x28>
800059f6:	58 3c       	cp.w	r12,3
800059f8:	cf b0       	breq	800059ee <usart_getchar+0xa>

  if (ret == USART_RX_ERROR)
800059fa:	58 4c       	cp.w	r12,4
800059fc:	f9 bc 00 ff 	moveq	r12,-1
    return USART_FAILURE;

  return c;
80005a00:	fb fc 10 00 	ld.wne	r12,sp[0x0]
}
80005a04:	2f fd       	sub	sp,-4
80005a06:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005a0a:	00 00       	add	r0,r0
80005a0c:	80 00       	ld.sh	r0,r0[0x0]
80005a0e:	59 c0       	cp.w	r0,28

80005a10 <usart_write_line>:


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
80005a10:	eb cd 40 c0 	pushm	r6-r7,lr
80005a14:	18 96       	mov	r6,r12
80005a16:	16 97       	mov	r7,r11
  while (*string != '\0')
80005a18:	17 8b       	ld.ub	r11,r11[0x0]
80005a1a:	58 0b       	cp.w	r11,0
80005a1c:	c0 80       	breq	80005a2c <usart_write_line+0x1c>
    usart_putchar(usart, *string++);
80005a1e:	2f f7       	sub	r7,-1
80005a20:	0c 9c       	mov	r12,r6
80005a22:	f0 1f 00 04 	mcall	80005a30 <usart_write_line+0x20>
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
80005a26:	0f 8b       	ld.ub	r11,r7[0x0]
80005a28:	58 0b       	cp.w	r11,0
80005a2a:	cf a1       	brne	80005a1e <usart_write_line+0xe>
80005a2c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005a30:	80 00       	ld.sh	r0,r0[0x0]
80005a32:	59 94       	cp.w	r4,25

80005a34 <usart_reset>:
//! @{


void usart_reset(volatile avr32_usart_t *usart)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
80005a34:	e1 b8 00 00 	mfsr	r8,0x0

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
80005a38:	e6 18 00 01 	andh	r8,0x1,COH
80005a3c:	c0 71       	brne	80005a4a <usart_reset+0x16>
80005a3e:	d3 03       	ssrf	0x10
  usart->idr = 0xFFFFFFFF;
80005a40:	3f f8       	mov	r8,-1
80005a42:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80005a44:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();
80005a46:	d5 03       	csrf	0x10
80005a48:	c0 48       	rjmp	80005a50 <usart_reset+0x1c>
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
  usart->idr = 0xFFFFFFFF;
80005a4a:	3f f8       	mov	r8,-1
80005a4c:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80005a4e:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();

  // Reset mode and other registers that could cause unpredictable behavior after reset.
  usart->mr = 0;
80005a50:	30 08       	mov	r8,0
80005a52:	99 18       	st.w	r12[0x4],r8
  usart->rtor = 0;
80005a54:	99 98       	st.w	r12[0x24],r8
  usart->ttgr = 0;
80005a56:	99 a8       	st.w	r12[0x28],r8

  // Shutdown TX and RX (will be re-enabled when setup has successfully completed),
  // reset status bits and turn off DTR and RTS.
  usart->cr = AVR32_USART_CR_RSTRX_MASK   |
80005a58:	ea 68 61 0c 	mov	r8,680204
80005a5c:	99 08       	st.w	r12[0x0],r8
#ifndef AVR32_USART_440_H_INCLUDED
// Note: Modem Signal Management DTR-DSR-DCD-RI are not included in USART rev.440.
              AVR32_USART_CR_DTRDIS_MASK  |
#endif
              AVR32_USART_CR_RTSDIS_MASK;
}
80005a5e:	5e fc       	retal	r12

80005a60 <usart_init_rs232>:


int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
{
80005a60:	eb cd 40 e0 	pushm	r5-r7,lr
80005a64:	18 96       	mov	r6,r12
80005a66:	16 97       	mov	r7,r11
80005a68:	14 95       	mov	r5,r10
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);
80005a6a:	f0 1f 00 2f 	mcall	80005b24 <usart_init_rs232+0xc4>

  // Check input values.
  if (!opt || // Null pointer.
80005a6e:	58 07       	cp.w	r7,0
80005a70:	c5 80       	breq	80005b20 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
80005a72:	0f c8       	ld.ub	r8,r7[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80005a74:	30 49       	mov	r9,4
80005a76:	f2 08 18 00 	cp.b	r8,r9
80005a7a:	e0 88 00 53 	brls	80005b20 <usart_init_rs232+0xc0>
80005a7e:	30 99       	mov	r9,9
80005a80:	f2 08 18 00 	cp.b	r8,r9
80005a84:	e0 8b 00 4e 	brhi	80005b20 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
80005a88:	0f d9       	ld.ub	r9,r7[0x5]
80005a8a:	30 78       	mov	r8,7
80005a8c:	f0 09 18 00 	cp.b	r9,r8
80005a90:	e0 8b 00 48 	brhi	80005b20 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
80005a94:	8e 39       	ld.sh	r9,r7[0x6]
80005a96:	e0 68 01 01 	mov	r8,257
80005a9a:	f0 09 19 00 	cp.h	r9,r8
80005a9e:	e0 8b 00 41 	brhi	80005b20 <usart_init_rs232+0xc0>
      opt->channelmode > 3 ||
80005aa2:	ef 39 00 08 	ld.ub	r9,r7[8]
80005aa6:	30 38       	mov	r8,3
80005aa8:	f0 09 18 00 	cp.b	r9,r8
80005aac:	e0 8b 00 3a 	brhi	80005b20 <usart_init_rs232+0xc0>
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
80005ab0:	0a 9a       	mov	r10,r5
80005ab2:	6e 0b       	ld.w	r11,r7[0x0]
80005ab4:	0c 9c       	mov	r12,r6
80005ab6:	f0 1f 00 1d 	mcall	80005b28 <usart_init_rs232+0xc8>
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80005aba:	58 1c       	cp.w	r12,1
80005abc:	c3 20       	breq	80005b20 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
    return USART_INVALID_INPUT;

  if (opt->charlength == 9)
80005abe:	0f c8       	ld.ub	r8,r7[0x4]
80005ac0:	30 99       	mov	r9,9
80005ac2:	f2 08 18 00 	cp.b	r8,r9
80005ac6:	c0 51       	brne	80005ad0 <usart_init_rs232+0x70>
  {
    // Character length set to 9 bits. MODE9 dominates CHRL.
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
80005ac8:	6c 18       	ld.w	r8,r6[0x4]
80005aca:	b1 b8       	sbr	r8,0x11
80005acc:	8d 18       	st.w	r6[0x4],r8
80005ace:	c0 68       	rjmp	80005ada <usart_init_rs232+0x7a>
  }
  else
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
80005ad0:	6c 19       	ld.w	r9,r6[0x4]
80005ad2:	20 58       	sub	r8,5
80005ad4:	f3 e8 10 68 	or	r8,r9,r8<<0x6
80005ad8:	8d 18       	st.w	r6[0x4],r8
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
80005ada:	6c 19       	ld.w	r9,r6[0x4]
80005adc:	ef 3a 00 08 	ld.ub	r10,r7[8]
80005ae0:	0f d8       	ld.ub	r8,r7[0x5]
80005ae2:	a9 78       	lsl	r8,0x9
80005ae4:	f1 ea 10 e8 	or	r8,r8,r10<<0xe
80005ae8:	12 48       	or	r8,r9
80005aea:	8d 18       	st.w	r6[0x4],r8
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;

  if (opt->stopbits > USART_2_STOPBITS)
80005aec:	8e 38       	ld.sh	r8,r7[0x6]
80005aee:	30 29       	mov	r9,2
80005af0:	f2 08 19 00 	cp.h	r8,r9
80005af4:	e0 88 00 09 	brls	80005b06 <usart_init_rs232+0xa6>
  {
    // Set two stop bits
    usart->mr |= AVR32_USART_MR_NBSTOP_2 << AVR32_USART_MR_NBSTOP_OFFSET;
80005af8:	6c 18       	ld.w	r8,r6[0x4]
80005afa:	ad b8       	sbr	r8,0xd
80005afc:	8d 18       	st.w	r6[0x4],r8
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
80005afe:	8e b8       	ld.uh	r8,r7[0x6]
80005b00:	20 28       	sub	r8,2
80005b02:	8d a8       	st.w	r6[0x28],r8
80005b04:	c0 68       	rjmp	80005b10 <usart_init_rs232+0xb0>
  }
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;
80005b06:	6c 19       	ld.w	r9,r6[0x4]
80005b08:	5c 78       	castu.h	r8
80005b0a:	f3 e8 10 c8 	or	r8,r9,r8<<0xc
80005b0e:	8d 18       	st.w	r6[0x4],r8

  // Set normal mode.
  usart->mr = (usart->mr & ~AVR32_USART_MR_MODE_MASK) |
80005b10:	6c 18       	ld.w	r8,r6[0x4]
80005b12:	e0 18 ff f0 	andl	r8,0xfff0
80005b16:	8d 18       	st.w	r6[0x4],r8
              AVR32_USART_MR_MODE_NORMAL << AVR32_USART_MR_MODE_OFFSET;

  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
80005b18:	35 08       	mov	r8,80
80005b1a:	8d 08       	st.w	r6[0x0],r8
80005b1c:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
80005b20:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
80005b24:	80 00       	ld.sh	r0,r0[0x0]
80005b26:	5a 34       	cp.w	r4,-29
80005b28:	80 00       	ld.sh	r0,r0[0x0]
80005b2a:	59 24       	cp.w	r4,18

80005b2c <_stext>:

  .global _stext
  .type _stext, @function
_stext:
  // Set initial stack pointer.
  lda.w   sp, _estack
80005b2c:	e0 7d 80 00 	mov	sp,98304

  // Set up EVBA so interrupts can be enabled.
  lda.w   r0, _evba
  mtsr    AVR32_EVBA, r0
80005b30:	fe c0 8f 30 	sub	r0,pc,-28880

  // Enable the exception processing.
  csrf    AVR32_SR_EM_OFFSET
80005b34:	e3 b0 00 01 	mtsr	0x4,r0

  // Load initialized data having a global lifetime from the data LMA.
  lda.w   r0, _data
  lda.w   r1, _edata
80005b38:	d5 53       	csrf	0x15
  cp      r0, r1
80005b3a:	30 40       	mov	r0,4
  brhs    idata_load_loop_end
80005b3c:	e0 61 0a 40 	mov	r1,2624
  lda.w   r2, _data_lma
idata_load_loop:
  ld.d    r4, r2++
80005b40:	02 30       	cp.w	r0,r1
  st.d    r0++, r4
80005b42:	c0 62       	brcc	80005b4e <idata_load_loop_end>
  cp      r0, r1
80005b44:	48 92       	lddpc	r2,80005b68 <udata_clear_loop_end+0x4>

80005b46 <idata_load_loop>:
  brlo    idata_load_loop
80005b46:	a5 05       	ld.d	r4,r2++
idata_load_loop_end:

  // Clear uninitialized data having a global lifetime in the blank static storage section.
  lda.w   r0, __bss_start
80005b48:	a1 24       	st.d	r0++,r4
  lda.w   r1, _end
80005b4a:	02 30       	cp.w	r0,r1
  cp      r0, r1
80005b4c:	cf d3       	brcs	80005b46 <idata_load_loop>

80005b4e <idata_load_loop_end>:
  brhs    udata_clear_loop_end
80005b4e:	e0 60 0a 40 	mov	r0,2624
  mov     r2, 0
  mov     r3, 0
80005b52:	e0 61 51 30 	mov	r1,20784
udata_clear_loop:
  st.d    r0++, r2
  cp      r0, r1
80005b56:	02 30       	cp.w	r0,r1
  brlo    udata_clear_loop
80005b58:	c0 62       	brcc	80005b64 <udata_clear_loop_end>
  // Safety: Set the default "return" @ to the exit routine address.
  lda.w   lr, exit
#endif

  // Start the show.
  lda.w   pc, main
80005b5a:	30 02       	mov	r2,0
80005b5c:	30 03       	mov	r3,0

80005b5e <udata_clear_loop>:
80005b5e:	a1 22       	st.d	r0++,r2
80005b60:	02 30       	cp.w	r0,r1
80005b62:	cf e3       	brcs	80005b5e <udata_clear_loop>

80005b64 <udata_clear_loop_end>:
80005b64:	fe cf e9 7c 	sub	pc,pc,-5764
80005b68:	80 00       	ld.sh	r0,r0[0x0]
80005b6a:	df 78       	*unknown*

80005b6c <vListInitialise>:
void vListInitialise( xList *pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
80005b6c:	f8 c8 ff f8 	sub	r8,r12,-8
80005b70:	99 18       	st.w	r12[0x4],r8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
80005b72:	3f f9       	mov	r9,-1
80005b74:	99 29       	st.w	r12[0x8],r9

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
80005b76:	99 38       	st.w	r12[0xc],r8
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
80005b78:	99 48       	st.w	r12[0x10],r8

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
80005b7a:	30 08       	mov	r8,0
80005b7c:	99 08       	st.w	r12[0x0],r8
}
80005b7e:	5e fc       	retal	r12

80005b80 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
80005b80:	30 08       	mov	r8,0
80005b82:	99 48       	st.w	r12[0x10],r8
}
80005b84:	5e fc       	retal	r12

80005b86 <vListInsertEnd>:

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
80005b86:	78 18       	ld.w	r8,r12[0x4]

	pxNewListItem->pxNext = pxIndex->pxNext;
80005b88:	70 19       	ld.w	r9,r8[0x4]
80005b8a:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxPrevious = pxList->pxIndex;
80005b8c:	78 19       	ld.w	r9,r12[0x4]
80005b8e:	97 29       	st.w	r11[0x8],r9
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80005b90:	70 19       	ld.w	r9,r8[0x4]
80005b92:	93 2b       	st.w	r9[0x8],r11
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
80005b94:	91 1b       	st.w	r8[0x4],r11
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
80005b96:	99 1b       	st.w	r12[0x4],r11

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80005b98:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80005b9a:	78 08       	ld.w	r8,r12[0x0]
80005b9c:	2f f8       	sub	r8,-1
80005b9e:	99 08       	st.w	r12[0x0],r8
}
80005ba0:	5e fc       	retal	r12

80005ba2 <vListInsert>:
{
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
80005ba2:	76 0a       	ld.w	r10,r11[0x0]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
80005ba4:	5b fa       	cp.w	r10,-1
80005ba6:	c0 31       	brne	80005bac <vListInsert+0xa>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
80005ba8:	78 48       	ld.w	r8,r12[0x10]
80005baa:	c0 c8       	rjmp	80005bc2 <vListInsert+0x20>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
80005bac:	f8 c8 ff f8 	sub	r8,r12,-8
80005bb0:	70 19       	ld.w	r9,r8[0x4]
80005bb2:	72 09       	ld.w	r9,r9[0x0]
80005bb4:	12 3a       	cp.w	r10,r9
80005bb6:	c0 63       	brcs	80005bc2 <vListInsert+0x20>
80005bb8:	70 18       	ld.w	r8,r8[0x4]
80005bba:	70 19       	ld.w	r9,r8[0x4]
80005bbc:	72 09       	ld.w	r9,r9[0x0]
80005bbe:	12 3a       	cp.w	r10,r9
80005bc0:	cf c2       	brcc	80005bb8 <vListInsert+0x16>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
80005bc2:	70 19       	ld.w	r9,r8[0x4]
80005bc4:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80005bc6:	93 2b       	st.w	r9[0x8],r11
	pxNewListItem->pxPrevious = pxIterator;
80005bc8:	97 28       	st.w	r11[0x8],r8
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
80005bca:	91 1b       	st.w	r8[0x4],r11

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80005bcc:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80005bce:	78 08       	ld.w	r8,r12[0x0]
80005bd0:	2f f8       	sub	r8,-1
80005bd2:	99 08       	st.w	r12[0x0],r8
}
80005bd4:	5e fc       	retal	r12

80005bd6 <vListRemove>:

void vListRemove( xListItem *pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
80005bd6:	78 18       	ld.w	r8,r12[0x4]
80005bd8:	78 29       	ld.w	r9,r12[0x8]
80005bda:	91 29       	st.w	r8[0x8],r9
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
80005bdc:	78 28       	ld.w	r8,r12[0x8]
80005bde:	78 19       	ld.w	r9,r12[0x4]
80005be0:	91 19       	st.w	r8[0x4],r9

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
80005be2:	78 48       	ld.w	r8,r12[0x10]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
80005be4:	70 19       	ld.w	r9,r8[0x4]
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
80005be6:	18 39       	cp.w	r9,r12
80005be8:	f9 f9 00 02 	ld.weq	r9,r12[0x8]
80005bec:	f1 f9 0a 01 	st.weq	r8[0x4],r9
	}

	pxItemToRemove->pvContainer = NULL;
80005bf0:	30 09       	mov	r9,0
80005bf2:	99 49       	st.w	r12[0x10],r9
	( pxList->uxNumberOfItems )--;
80005bf4:	70 09       	ld.w	r9,r8[0x0]
80005bf6:	20 19       	sub	r9,1
80005bf8:	91 09       	st.w	r8[0x0],r9
}
80005bfa:	5e fc       	retal	r12

80005bfc <pxPortInitialiseStack>:
	/* Setup the initial stack of the task.  The stack is set exactly as
	expected by the portRESTORE_CONTEXT() macro. */

	/* When the task starts, it will expect to find the function parameter in R12. */
	pxTopOfStack--;
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x08080808;					/* R8 */
80005bfc:	e0 68 08 08 	mov	r8,2056
80005c00:	ea 18 08 08 	orh	r8,0x808
80005c04:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x09090909;					/* R9 */
80005c06:	e0 68 09 09 	mov	r8,2313
80005c0a:	ea 18 09 09 	orh	r8,0x909
80005c0e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0A0A0A0A;					/* R10 */
80005c10:	e0 68 0a 0a 	mov	r8,2570
80005c14:	ea 18 0a 0a 	orh	r8,0xa0a
80005c18:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0B0B0B0B;					/* R11 */
80005c1a:	e0 68 0b 0b 	mov	r8,2827
80005c1e:	ea 18 0b 0b 	orh	r8,0xb0b
80005c22:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pvParameters;					/* R12 */
80005c24:	18 da       	st.w	--r12,r10
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xDEADBEEF;					/* R14/LR */
80005c26:	e0 68 be ef 	mov	r8,48879
80005c2a:	ea 18 de ad 	orh	r8,0xdead
80005c2e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pxCode + portINSTRUCTION_SIZE; /* R15/PC */
80005c30:	18 db       	st.w	--r12,r11
	*pxTopOfStack-- = ( portSTACK_TYPE ) portINITIAL_SR;				/* SR */
80005c32:	fc 18 00 40 	movh	r8,0x40
80005c36:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xFF0000FF;					/* R0 */
80005c38:	e0 68 00 ff 	mov	r8,255
80005c3c:	ea 18 ff 00 	orh	r8,0xff00
80005c40:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x01010101;					/* R1 */
80005c42:	e0 68 01 01 	mov	r8,257
80005c46:	ea 18 01 01 	orh	r8,0x101
80005c4a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x02020202;					/* R2 */
80005c4c:	e0 68 02 02 	mov	r8,514
80005c50:	ea 18 02 02 	orh	r8,0x202
80005c54:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x03030303;					/* R3 */
80005c56:	e0 68 03 03 	mov	r8,771
80005c5a:	ea 18 03 03 	orh	r8,0x303
80005c5e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x04040404;					/* R4 */
80005c60:	e0 68 04 04 	mov	r8,1028
80005c64:	ea 18 04 04 	orh	r8,0x404
80005c68:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x05050505;					/* R5 */
80005c6a:	e0 68 05 05 	mov	r8,1285
80005c6e:	ea 18 05 05 	orh	r8,0x505
80005c72:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x06060606;					/* R6 */
80005c74:	e0 68 06 06 	mov	r8,1542
80005c78:	ea 18 06 06 	orh	r8,0x606
80005c7c:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x07070707;					/* R7 */
80005c7e:	e0 68 07 07 	mov	r8,1799
80005c82:	ea 18 07 07 	orh	r8,0x707
80005c86:	18 d8       	st.w	--r12,r8
	*pxTopOfStack = ( portSTACK_TYPE ) portNO_CRITICAL_NESTING;			/* ulCriticalNesting */
80005c88:	30 08       	mov	r8,0
80005c8a:	18 d8       	st.w	--r12,r8

	return pxTopOfStack;
}
80005c8c:	5e fc       	retal	r12
80005c8e:	d7 03       	nop

80005c90 <vPortEnterCritical>:
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
__attribute__((__noinline__)) void vPortEnterCritical( void )
{
	/* Disable interrupts */
	portDISABLE_INTERRUPTS();
80005c90:	d3 03       	ssrf	0x10

	/* Now interrupts are disabled ulCriticalNesting can be accessed
	 directly.  Increment ulCriticalNesting to keep a count of how many times
	 portENTER_CRITICAL() has been called. */
	ulCriticalNesting++;
80005c92:	48 38       	lddpc	r8,80005c9c <vPortEnterCritical+0xc>
80005c94:	70 09       	ld.w	r9,r8[0x0]
80005c96:	2f f9       	sub	r9,-1
80005c98:	91 09       	st.w	r8[0x0],r9
}
80005c9a:	5e fc       	retal	r12
80005c9c:	00 00       	add	r0,r0
80005c9e:	05 34       	ld.ub	r4,r2++

80005ca0 <xPortStartScheduler>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
80005ca0:	d4 01       	pushm	lr
	};

#endif

	/* Disable all interrupt/exception. */
	portDISABLE_INTERRUPTS();
80005ca2:	d3 03       	ssrf	0x10
		/* Start the timer/counter. */
		tc_start(tc, configTICK_TC_CHANNEL);
	}
	#else
	{
		INTC_register_interrupt(&vTick, AVR32_CORE_COMPARE_IRQ, AVR32_INTC_INT0);
80005ca4:	30 0a       	mov	r10,0
80005ca6:	14 9b       	mov	r11,r10
80005ca8:	49 2c       	lddpc	r12,80005cf0 <xPortStartScheduler+0x50>
80005caa:	f0 1f 00 13 	mcall	80005cf4 <xPortStartScheduler+0x54>
/* Schedule the COUNT&COMPARE match interrupt in (configCPU_CLOCK_HZ/configTICK_RATE_HZ)
clock cycles from now. */
#if( configTICK_USE_TC==0 )
	static void prvScheduleFirstTick(void)
	{
		Set_system_register(AVR32_COMPARE, configCPU_CLOCK_HZ/configTICK_RATE_HZ);//cause!!!
80005cae:	e0 68 5d c0 	mov	r8,24000
80005cb2:	e3 b8 00 43 	mtsr	0x10c,r8
		Set_system_register(AVR32_COUNT, 0);
80005cb6:	30 08       	mov	r8,0
80005cb8:	e3 b8 00 42 	mtsr	0x108,r8
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();

	/* Start the first task. */
	portRESTORE_CONTEXT();
80005cbc:	e0 68 0c d8 	mov	r8,3288
80005cc0:	ea 18 00 00 	orh	r8,0x0
80005cc4:	70 00       	ld.w	r0,r8[0x0]
80005cc6:	60 0d       	ld.w	sp,r0[0x0]
80005cc8:	1b 00       	ld.w	r0,sp++
80005cca:	e0 68 05 34 	mov	r8,1332
80005cce:	ea 18 00 00 	orh	r8,0x0
80005cd2:	91 00       	st.w	r8[0x0],r0
80005cd4:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005cd8:	2f ed       	sub	sp,-8
80005cda:	e3 cd 5f 00 	ldm	sp++,r8-r12,lr
80005cde:	fa f0 ff e0 	ld.w	r0,sp[-32]
80005ce2:	e3 b0 00 00 	mtsr	0x0,r0
80005ce6:	fa f0 ff dc 	ld.w	r0,sp[-36]
80005cea:	fa ff ff e4 	ld.w	pc,sp[-28]

	/* Should not get here! */
	return 0;
}
80005cee:	d8 0a       	popm	pc,r12=0
80005cf0:	80 00       	ld.sh	r0,r0[0x0]
80005cf2:	5d bc       	*unknown*
80005cf4:	80 00       	ld.sh	r0,r0[0x0]
80005cf6:	54 40       	stdsp	sp[0x110],r0

80005cf8 <SCALLYield>:
/*-----------------------------------------------------------*/
__attribute__((__naked__)) void SCALLYield( void );
__attribute__((__naked__)) void SCALLYield( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_SCALL();
80005cf8:	20 6d       	sub	sp,24
80005cfa:	eb cd 00 ff 	pushm	r0-r7
80005cfe:	fa c7 ff c0 	sub	r7,sp,-64
80005d02:	ee f0 ff f8 	ld.w	r0,r7[-8]
80005d06:	ef 40 ff e0 	st.w	r7[-32],r0
80005d0a:	ee f0 ff fc 	ld.w	r0,r7[-4]
80005d0e:	ef 40 ff e4 	st.w	r7[-28],r0
80005d12:	eb c7 5f 00 	stm	--r7,r8-r12,lr
80005d16:	e0 68 05 34 	mov	r8,1332
80005d1a:	ea 18 00 00 	orh	r8,0x0
80005d1e:	70 00       	ld.w	r0,r8[0x0]
80005d20:	1a d0       	st.w	--sp,r0
80005d22:	f0 1f 00 1a 	mcall	80005d88 <LABEL_RET_SCALL_263+0x14>
80005d26:	e0 68 0c d8 	mov	r8,3288
80005d2a:	ea 18 00 00 	orh	r8,0x0
80005d2e:	70 00       	ld.w	r0,r8[0x0]
80005d30:	81 0d       	st.w	r0[0x0],sp
	vTaskSwitchContext();
80005d32:	f0 1f 00 17 	mcall	80005d8c <LABEL_RET_SCALL_263+0x18>
	portRESTORE_CONTEXT_SCALL();
80005d36:	e0 68 0c d8 	mov	r8,3288
80005d3a:	ea 18 00 00 	orh	r8,0x0
80005d3e:	70 00       	ld.w	r0,r8[0x0]
80005d40:	60 0d       	ld.w	sp,r0[0x0]
80005d42:	1b 00       	ld.w	r0,sp++
80005d44:	e0 68 05 34 	mov	r8,1332
80005d48:	ea 18 00 00 	orh	r8,0x0
80005d4c:	91 00       	st.w	r8[0x0],r0
80005d4e:	fa c7 ff d8 	sub	r7,sp,-40
80005d52:	e3 c7 5f 00 	ldm	r7++,r8-r12,lr
80005d56:	ee f0 ff e0 	ld.w	r0,r7[-32]
80005d5a:	e0 61 05 34 	mov	r1,1332
80005d5e:	ea 11 00 00 	orh	r1,0x0
80005d62:	62 02       	ld.w	r2,r1[0x0]
80005d64:	58 02       	cp.w	r2,0
80005d66:	c0 70       	breq	80005d74 <LABEL_RET_SCALL_263>
80005d68:	e4 c2 00 01 	sub	r2,r2,1
80005d6c:	83 02       	st.w	r1[0x0],r2
80005d6e:	58 02       	cp.w	r2,0
80005d70:	c0 21       	brne	80005d74 <LABEL_RET_SCALL_263>
80005d72:	b1 c0       	cbr	r0,0x10

80005d74 <LABEL_RET_SCALL_263>:
80005d74:	ef 40 ff f8 	st.w	r7[-8],r0
80005d78:	ee f0 ff e4 	ld.w	r0,r7[-28]
80005d7c:	ef 40 ff fc 	st.w	r7[-4],r0
80005d80:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005d84:	2f ad       	sub	sp,-24
80005d86:	d6 13       	rets
80005d88:	80 00       	ld.sh	r0,r0[0x0]
80005d8a:	5c 90       	brev	r0
80005d8c:	80 00       	ld.sh	r0,r0[0x0]
80005d8e:	63 d4       	ld.w	r4,r1[0x74]

80005d90 <prvClearCcInt>:
		Set_system_register(AVR32_COUNT, 0);
	}

	__attribute__((__noinline__)) static void prvClearCcInt(void)
	{
		Set_system_register(AVR32_COMPARE, Get_system_register(AVR32_COMPARE));
80005d90:	e1 b8 00 43 	mfsr	r8,0x10c
80005d94:	e3 b8 00 43 	mtsr	0x10c,r8
	}
80005d98:	5e fc       	retal	r12
80005d9a:	d7 03       	nop

80005d9c <vPortExitCritical>:
}
/*-----------------------------------------------------------*/

__attribute__((__noinline__)) void vPortExitCritical( void )
{
	if(ulCriticalNesting > portNO_CRITICAL_NESTING)
80005d9c:	48 78       	lddpc	r8,80005db8 <vPortExitCritical+0x1c>
80005d9e:	70 08       	ld.w	r8,r8[0x0]
80005da0:	58 08       	cp.w	r8,0
80005da2:	5e 0c       	reteq	r12
	{
		ulCriticalNesting--;
80005da4:	48 58       	lddpc	r8,80005db8 <vPortExitCritical+0x1c>
80005da6:	70 09       	ld.w	r9,r8[0x0]
80005da8:	20 19       	sub	r9,1
80005daa:	91 09       	st.w	r8[0x0],r9
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
80005dac:	70 08       	ld.w	r8,r8[0x0]
80005dae:	58 08       	cp.w	r8,0
80005db0:	5e 1c       	retne	r12
		{
			/* Enable all interrupt/exception. */
			portENABLE_INTERRUPTS();
80005db2:	d5 03       	csrf	0x10
80005db4:	5e fc       	retal	r12
80005db6:	00 00       	add	r0,r0
80005db8:	00 00       	add	r0,r0
80005dba:	05 34       	ld.ub	r4,r2++

80005dbc <vTick>:
/* The preemptive scheduler is defined as "naked" as the full context is saved
on entry as part of the context switch. */
__attribute__((__naked__)) static void vTick( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_OS_INT();
80005dbc:	eb cd 00 ff 	pushm	r0-r7
80005dc0:	e0 68 05 34 	mov	r8,1332
80005dc4:	ea 18 00 00 	orh	r8,0x0
80005dc8:	70 00       	ld.w	r0,r8[0x0]
80005dca:	1a d0       	st.w	--sp,r0
80005dcc:	7a 90       	ld.w	r0,sp[0x24]
80005dce:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80005dd2:	58 10       	cp.w	r0,1
80005dd4:	e0 8b 00 08 	brhi	80005de4 <LABEL_INT_SKIP_SAVE_CONTEXT_237>
80005dd8:	e0 68 0c d8 	mov	r8,3288
80005ddc:	ea 18 00 00 	orh	r8,0x0
80005de0:	70 00       	ld.w	r0,r8[0x0]
80005de2:	81 0d       	st.w	r0[0x0],sp

80005de4 <LABEL_INT_SKIP_SAVE_CONTEXT_237>:
	#if( configTICK_USE_TC==1 )
		/* Clear the interrupt flag. */
		prvClearTcInt();
	#else
		/* Clear the interrupt flag. */
		prvClearCcInt();
80005de4:	f0 1f 00 12 	mcall	80005e2c <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x14>
	#endif

	/* Because FreeRTOS is not supposed to run with nested interrupts, put all OS
	calls in a critical section . */
	portENTER_CRITICAL();
80005de8:	f0 1f 00 12 	mcall	80005e30 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
		vTaskIncrementTick();
80005dec:	f0 1f 00 12 	mcall	80005e34 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x1c>
	portEXIT_CRITICAL();
80005df0:	f0 1f 00 12 	mcall	80005e38 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>

	/* Restore the context of the "elected task". */
	portRESTORE_CONTEXT_OS_INT();
80005df4:	7a 90       	ld.w	r0,sp[0x24]
80005df6:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80005dfa:	58 10       	cp.w	r0,1
80005dfc:	e0 8b 00 0e 	brhi	80005e18 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>
80005e00:	f0 1f 00 0c 	mcall	80005e30 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
80005e04:	f0 1f 00 0e 	mcall	80005e3c <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x24>
80005e08:	f0 1f 00 0c 	mcall	80005e38 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>
80005e0c:	e0 68 0c d8 	mov	r8,3288
80005e10:	ea 18 00 00 	orh	r8,0x0
80005e14:	70 00       	ld.w	r0,r8[0x0]
80005e16:	60 0d       	ld.w	sp,r0[0x0]

80005e18 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>:
80005e18:	1b 00       	ld.w	r0,sp++
80005e1a:	e0 68 05 34 	mov	r8,1332
80005e1e:	ea 18 00 00 	orh	r8,0x0
80005e22:	91 00       	st.w	r8[0x0],r0
80005e24:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005e28:	d6 03       	rete
80005e2a:	00 00       	add	r0,r0
80005e2c:	80 00       	ld.sh	r0,r0[0x0]
80005e2e:	5d 90       	*unknown*
80005e30:	80 00       	ld.sh	r0,r0[0x0]
80005e32:	5c 90       	brev	r0
80005e34:	80 00       	ld.sh	r0,r0[0x0]
80005e36:	65 d8       	ld.w	r8,r2[0x74]
80005e38:	80 00       	ld.sh	r0,r0[0x0]
80005e3a:	5d 9c       	*unknown*
80005e3c:	80 00       	ld.sh	r0,r0[0x0]
80005e3e:	63 d4       	ld.w	r4,r1[0x74]

80005e40 <__malloc_lock>:
 * safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_lock(struct _reent *ptr);
void __malloc_lock(struct _reent *ptr)
{
80005e40:	d4 01       	pushm	lr
	vTaskSuspendAll();
80005e42:	f0 1f 00 02 	mcall	80005e48 <__malloc_lock+0x8>
}
80005e46:	d8 02       	popm	pc
80005e48:	80 00       	ld.sh	r0,r0[0x0]
80005e4a:	63 c4       	ld.w	r4,r1[0x70]

80005e4c <__malloc_unlock>:
 * a safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_unlock(struct _reent *ptr);
void __malloc_unlock(struct _reent *ptr)
{
80005e4c:	d4 01       	pushm	lr
	xTaskResumeAll();
80005e4e:	f0 1f 00 02 	mcall	80005e54 <__malloc_unlock+0x8>
}
80005e52:	d8 02       	popm	pc
80005e54:	80 00       	ld.sh	r0,r0[0x0]
80005e56:	67 80       	ld.w	r0,r3[0x60]

80005e58 <_read>:
/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
{
80005e58:	d4 21       	pushm	r4-r7,lr
80005e5a:	16 95       	mov	r5,r11
80005e5c:	14 96       	mov	r6,r10
  int nChars = 0;

  if (file != 0)
80005e5e:	58 0c       	cp.w	r12,0
80005e60:	c0 30       	breq	80005e66 <_read+0xe>
80005e62:	3f f7       	mov	r7,-1
80005e64:	c1 48       	rjmp	80005e8c <_read+0x34>
    return -1;

  for (; len > 0; --len)
80005e66:	58 0a       	cp.w	r10,0
80005e68:	e0 89 00 04 	brgt	80005e70 <_read+0x18>
80005e6c:	30 07       	mov	r7,0
80005e6e:	c0 f8       	rjmp	80005e8c <_read+0x34>
80005e70:	30 07       	mov	r7,0
  {
    int c = usart_getchar(stdio_usart_base);
80005e72:	48 84       	lddpc	r4,80005e90 <_read+0x38>
80005e74:	68 0c       	ld.w	r12,r4[0x0]
80005e76:	f0 1f 00 08 	mcall	80005e94 <_read+0x3c>
    if (c < 0)
80005e7a:	c0 95       	brlt	80005e8c <_read+0x34>
      break;

    *ptr++ = c;
80005e7c:	ea 07 0b 0c 	st.b	r5[r7],r12
    ++nChars;
80005e80:	2f f7       	sub	r7,-1

/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
80005e82:	ec 07 01 08 	sub	r8,r6,r7
  int nChars = 0;

  if (file != 0)
    return -1;

  for (; len > 0; --len)
80005e86:	58 08       	cp.w	r8,0
80005e88:	fe 99 ff f6 	brgt	80005e74 <_read+0x1c>
    *ptr++ = c;
    ++nChars;
  }

  return nChars;
}
80005e8c:	0e 9c       	mov	r12,r7
80005e8e:	d8 22       	popm	r4-r7,pc
80005e90:	00 00       	add	r0,r0
80005e92:	51 24       	stdsp	sp[0x48],r4
80005e94:	80 00       	ld.sh	r0,r0[0x0]
80005e96:	59 e4       	cp.w	r4,30

80005e98 <_write>:
 * 1 and 2 is stdout and stderr which goes to usart
 * 3 is framebuffer
 */
int __attribute__((weak))
_write (int file, char * ptr, int len)
{
80005e98:	d4 21       	pushm	r4-r7,lr
80005e9a:	16 95       	mov	r5,r11
80005e9c:	14 96       	mov	r6,r10
  int nChars = 0;

  if ( (file != 1)
80005e9e:	20 1c       	sub	r12,1
80005ea0:	58 2c       	cp.w	r12,2
80005ea2:	e0 8b 00 12 	brhi	80005ec6 <_write+0x2e>
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80005ea6:	58 0a       	cp.w	r10,0
80005ea8:	c0 31       	brne	80005eae <_write+0x16>
80005eaa:	30 07       	mov	r7,0
80005eac:	c0 e8       	rjmp	80005ec8 <_write+0x30>
80005eae:	30 07       	mov	r7,0
  {
    if (usart_putchar(stdio_usart_base, *ptr++) < 0)
80005eb0:	48 74       	lddpc	r4,80005ecc <_write+0x34>
80005eb2:	68 0c       	ld.w	r12,r4[0x0]
80005eb4:	ea 07 07 0b 	ld.ub	r11,r5[r7]
80005eb8:	f0 1f 00 06 	mcall	80005ed0 <_write+0x38>
80005ebc:	c0 55       	brlt	80005ec6 <_write+0x2e>
    {
      return -1;
    }

    ++nChars;
80005ebe:	2f f7       	sub	r7,-1

  if ( (file != 1)
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80005ec0:	0e 36       	cp.w	r6,r7
80005ec2:	cf 81       	brne	80005eb2 <_write+0x1a>
80005ec4:	c0 28       	rjmp	80005ec8 <_write+0x30>
80005ec6:	3f f7       	mov	r7,-1

    ++nChars;
  }

  return nChars;
}
80005ec8:	0e 9c       	mov	r12,r7
80005eca:	d8 22       	popm	r4-r7,pc
80005ecc:	00 00       	add	r0,r0
80005ece:	51 24       	stdsp	sp[0x48],r4
80005ed0:	80 00       	ld.sh	r0,r0[0x0]
80005ed2:	59 94       	cp.w	r4,25

80005ed4 <vPortFree>:
	return pvReturn;
}
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
80005ed4:	eb cd 40 80 	pushm	r7,lr
80005ed8:	18 97       	mov	r7,r12
	if( pv )
80005eda:	58 0c       	cp.w	r12,0
80005edc:	c0 80       	breq	80005eec <vPortFree+0x18>
	{
		vTaskSuspendAll();
80005ede:	f0 1f 00 05 	mcall	80005ef0 <vPortFree+0x1c>
		{
			free( pv );
80005ee2:	0e 9c       	mov	r12,r7
80005ee4:	f0 1f 00 04 	mcall	80005ef4 <vPortFree+0x20>
		}
		xTaskResumeAll();
80005ee8:	f0 1f 00 04 	mcall	80005ef8 <vPortFree+0x24>
80005eec:	e3 cd 80 80 	ldm	sp++,r7,pc
80005ef0:	80 00       	ld.sh	r0,r0[0x0]
80005ef2:	63 c4       	ld.w	r4,r1[0x70]
80005ef4:	80 00       	ld.sh	r0,r0[0x0]
80005ef6:	72 58       	ld.w	r8,r9[0x14]
80005ef8:	80 00       	ld.sh	r0,r0[0x0]
80005efa:	67 80       	ld.w	r0,r3[0x60]

80005efc <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
80005efc:	eb cd 40 80 	pushm	r7,lr
80005f00:	18 97       	mov	r7,r12
void *pvReturn;

	vTaskSuspendAll();
80005f02:	f0 1f 00 06 	mcall	80005f18 <pvPortMalloc+0x1c>
	{
		pvReturn = malloc( xWantedSize );
80005f06:	0e 9c       	mov	r12,r7
80005f08:	f0 1f 00 05 	mcall	80005f1c <pvPortMalloc+0x20>
80005f0c:	18 97       	mov	r7,r12
	}
	xTaskResumeAll();
80005f0e:	f0 1f 00 05 	mcall	80005f20 <pvPortMalloc+0x24>
		}
	}
	#endif

	return pvReturn;
}
80005f12:	0e 9c       	mov	r12,r7
80005f14:	e3 cd 80 80 	ldm	sp++,r7,pc
80005f18:	80 00       	ld.sh	r0,r0[0x0]
80005f1a:	63 c4       	ld.w	r4,r1[0x70]
80005f1c:	80 00       	ld.sh	r0,r0[0x0]
80005f1e:	72 68       	ld.w	r8,r9[0x18]
80005f20:	80 00       	ld.sh	r0,r0[0x0]
80005f22:	67 80       	ld.w	r0,r3[0x60]

80005f24 <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
80005f24:	d4 01       	pushm	lr
80005f26:	16 98       	mov	r8,r11
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
80005f28:	78 09       	ld.w	r9,r12[0x0]
80005f2a:	58 09       	cp.w	r9,0
80005f2c:	c1 10       	breq	80005f4e <prvCopyDataFromQueue+0x2a>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
80005f2e:	78 3a       	ld.w	r10,r12[0xc]
80005f30:	79 09       	ld.w	r9,r12[0x40]
80005f32:	f4 09 00 09 	add	r9,r10,r9
80005f36:	99 39       	st.w	r12[0xc],r9
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
80005f38:	78 1a       	ld.w	r10,r12[0x4]
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
80005f3a:	14 39       	cp.w	r9,r10
80005f3c:	f9 f9 20 00 	ld.wcc	r9,r12[0x0]
80005f40:	f9 f9 2a 03 	st.wcc	r12[0xc],r9
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
80005f44:	79 0a       	ld.w	r10,r12[0x40]
80005f46:	78 3b       	ld.w	r11,r12[0xc]
80005f48:	10 9c       	mov	r12,r8
80005f4a:	f0 1f 00 02 	mcall	80005f50 <prvCopyDataFromQueue+0x2c>
80005f4e:	d8 02       	popm	pc
80005f50:	80 00       	ld.sh	r0,r0[0x0]
80005f52:	76 b0       	ld.w	r0,r11[0x2c]

80005f54 <xQueueReceiveFromISR>:
	}
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
80005f54:	eb cd 40 c0 	pushm	r6-r7,lr
80005f58:	18 97       	mov	r7,r12
80005f5a:	14 96       	mov	r6,r10
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80005f5c:	78 e8       	ld.w	r8,r12[0x38]
80005f5e:	58 08       	cp.w	r8,0
80005f60:	c0 31       	brne	80005f66 <xQueueReceiveFromISR+0x12>
80005f62:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
80005f66:	f0 1f 00 0e 	mcall	80005f9c <xQueueReceiveFromISR+0x48>
			--( pxQueue->uxMessagesWaiting );
80005f6a:	6e e8       	ld.w	r8,r7[0x38]
80005f6c:	20 18       	sub	r8,1
80005f6e:	8f e8       	st.w	r7[0x38],r8

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
80005f70:	6f 18       	ld.w	r8,r7[0x44]
80005f72:	5b f8       	cp.w	r8,-1
80005f74:	c0 d1       	brne	80005f8e <xQueueReceiveFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80005f76:	6e 48       	ld.w	r8,r7[0x10]
80005f78:	58 08       	cp.w	r8,0
80005f7a:	c0 f0       	breq	80005f98 <xQueueReceiveFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80005f7c:	ee cc ff f0 	sub	r12,r7,-16
80005f80:	f0 1f 00 08 	mcall	80005fa0 <xQueueReceiveFromISR+0x4c>
80005f84:	c0 a0       	breq	80005f98 <xQueueReceiveFromISR+0x44>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
80005f86:	30 1c       	mov	r12,1
80005f88:	8d 0c       	st.w	r6[0x0],r12
80005f8a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
80005f8e:	2f f8       	sub	r8,-1
80005f90:	ef 48 00 44 	st.w	r7[68],r8
80005f94:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80005f98:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80005f9c:	80 00       	ld.sh	r0,r0[0x0]
80005f9e:	5f 24       	srhs	r4
80005fa0:	80 00       	ld.sh	r0,r0[0x0]
80005fa2:	65 5c       	ld.w	r12,r2[0x54]

80005fa4 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
80005fa4:	eb cd 40 c0 	pushm	r6-r7,lr
80005fa8:	18 97       	mov	r7,r12

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
80005faa:	f0 1f 00 23 	mcall	80006034 <prvUnlockQueue+0x90>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80005fae:	6f 28       	ld.w	r8,r7[0x48]
80005fb0:	58 08       	cp.w	r8,0
80005fb2:	e0 8a 00 18 	brle	80005fe2 <prvUnlockQueue+0x3e>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005fb6:	6e 98       	ld.w	r8,r7[0x24]
80005fb8:	58 08       	cp.w	r8,0
80005fba:	c1 40       	breq	80005fe2 <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80005fbc:	ee c6 ff dc 	sub	r6,r7,-36
80005fc0:	c0 48       	rjmp	80005fc8 <prvUnlockQueue+0x24>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005fc2:	6e 98       	ld.w	r8,r7[0x24]
80005fc4:	58 08       	cp.w	r8,0
80005fc6:	c0 e0       	breq	80005fe2 <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80005fc8:	0c 9c       	mov	r12,r6
80005fca:	f0 1f 00 1c 	mcall	80006038 <prvUnlockQueue+0x94>
80005fce:	c0 30       	breq	80005fd4 <prvUnlockQueue+0x30>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
80005fd0:	f0 1f 00 1b 	mcall	8000603c <prvUnlockQueue+0x98>
				}

				--( pxQueue->xTxLock );
80005fd4:	6f 28       	ld.w	r8,r7[0x48]
80005fd6:	20 18       	sub	r8,1
80005fd8:	ef 48 00 48 	st.w	r7[72],r8
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80005fdc:	58 08       	cp.w	r8,0
80005fde:	fe 99 ff f2 	brgt	80005fc2 <prvUnlockQueue+0x1e>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
80005fe2:	3f f8       	mov	r8,-1
80005fe4:	ef 48 00 48 	st.w	r7[72],r8
	}
	taskEXIT_CRITICAL();
80005fe8:	f0 1f 00 16 	mcall	80006040 <prvUnlockQueue+0x9c>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
80005fec:	f0 1f 00 12 	mcall	80006034 <prvUnlockQueue+0x90>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
80005ff0:	6f 18       	ld.w	r8,r7[0x44]
80005ff2:	58 08       	cp.w	r8,0
80005ff4:	e0 8a 00 18 	brle	80006024 <prvUnlockQueue+0x80>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80005ff8:	6e 48       	ld.w	r8,r7[0x10]
80005ffa:	58 08       	cp.w	r8,0
80005ffc:	c1 40       	breq	80006024 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80005ffe:	ee c6 ff f0 	sub	r6,r7,-16
80006002:	c0 48       	rjmp	8000600a <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80006004:	6e 48       	ld.w	r8,r7[0x10]
80006006:	58 08       	cp.w	r8,0
80006008:	c0 e0       	breq	80006024 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
8000600a:	0c 9c       	mov	r12,r6
8000600c:	f0 1f 00 0b 	mcall	80006038 <prvUnlockQueue+0x94>
80006010:	c0 30       	breq	80006016 <prvUnlockQueue+0x72>
				{
					vTaskMissedYield();
80006012:	f0 1f 00 0b 	mcall	8000603c <prvUnlockQueue+0x98>
				}

				--( pxQueue->xRxLock );
80006016:	6f 18       	ld.w	r8,r7[0x44]
80006018:	20 18       	sub	r8,1
8000601a:	ef 48 00 44 	st.w	r7[68],r8
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
8000601e:	58 08       	cp.w	r8,0
80006020:	fe 99 ff f2 	brgt	80006004 <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
80006024:	3f f8       	mov	r8,-1
80006026:	ef 48 00 44 	st.w	r7[68],r8
	}
	taskEXIT_CRITICAL();
8000602a:	f0 1f 00 06 	mcall	80006040 <prvUnlockQueue+0x9c>
}
8000602e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006032:	00 00       	add	r0,r0
80006034:	80 00       	ld.sh	r0,r0[0x0]
80006036:	5c 90       	brev	r0
80006038:	80 00       	ld.sh	r0,r0[0x0]
8000603a:	65 5c       	ld.w	r12,r2[0x54]
8000603c:	80 00       	ld.sh	r0,r0[0x0]
8000603e:	64 68       	ld.w	r8,r2[0x18]
80006040:	80 00       	ld.sh	r0,r0[0x0]
80006042:	5d 9c       	*unknown*

80006044 <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
80006044:	d4 31       	pushm	r0-r7,lr
80006046:	20 5d       	sub	sp,20
80006048:	18 97       	mov	r7,r12
8000604a:	50 0b       	stdsp	sp[0x0],r11
8000604c:	50 2a       	stdsp	sp[0x8],r10
8000604e:	50 19       	stdsp	sp[0x4],r9
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80006050:	f8 c2 ff dc 	sub	r2,r12,-36
80006054:	30 05       	mov	r5,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80006056:	fa c4 ff f4 	sub	r4,sp,-12
8000605a:	30 10       	mov	r0,1

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
8000605c:	0a 91       	mov	r1,r5

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
8000605e:	fa c3 ff f8 	sub	r3,sp,-8
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
80006062:	f0 1f 00 3e 	mcall	80006158 <xQueueGenericReceive+0x114>
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80006066:	6e e8       	ld.w	r8,r7[0x38]
80006068:	58 08       	cp.w	r8,0
8000606a:	c2 a0       	breq	800060be <xQueueGenericReceive+0x7a>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
8000606c:	6e 36       	ld.w	r6,r7[0xc]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
8000606e:	40 0b       	lddsp	r11,sp[0x0]
80006070:	0e 9c       	mov	r12,r7
80006072:	f0 1f 00 3b 	mcall	8000615c <xQueueGenericReceive+0x118>

				if( xJustPeeking == pdFALSE )
80006076:	40 18       	lddsp	r8,sp[0x4]
80006078:	58 08       	cp.w	r8,0
8000607a:	c1 51       	brne	800060a4 <xQueueGenericReceive+0x60>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
8000607c:	6e e8       	ld.w	r8,r7[0x38]
8000607e:	20 18       	sub	r8,1
80006080:	8f e8       	st.w	r7[0x38],r8

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80006082:	6e 08       	ld.w	r8,r7[0x0]
80006084:	58 08       	cp.w	r8,0
80006086:	c0 41       	brne	8000608e <xQueueGenericReceive+0x4a>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
80006088:	f0 1f 00 36 	mcall	80006160 <xQueueGenericReceive+0x11c>
8000608c:	8f 1c       	st.w	r7[0x4],r12
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
8000608e:	6e 48       	ld.w	r8,r7[0x10]
80006090:	58 08       	cp.w	r8,0
80006092:	c1 20       	breq	800060b6 <xQueueGenericReceive+0x72>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
80006094:	ee cc ff f0 	sub	r12,r7,-16
80006098:	f0 1f 00 33 	mcall	80006164 <xQueueGenericReceive+0x120>
8000609c:	58 1c       	cp.w	r12,1
8000609e:	c0 c1       	brne	800060b6 <xQueueGenericReceive+0x72>
						{
							portYIELD_WITHIN_API();
800060a0:	d7 33       	scall
800060a2:	c0 a8       	rjmp	800060b6 <xQueueGenericReceive+0x72>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
800060a4:	8f 36       	st.w	r7[0xc],r6

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
800060a6:	6e 98       	ld.w	r8,r7[0x24]
800060a8:	58 08       	cp.w	r8,0
800060aa:	c0 60       	breq	800060b6 <xQueueGenericReceive+0x72>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
800060ac:	04 9c       	mov	r12,r2
800060ae:	f0 1f 00 2e 	mcall	80006164 <xQueueGenericReceive+0x120>
800060b2:	c0 20       	breq	800060b6 <xQueueGenericReceive+0x72>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
800060b4:	d7 33       	scall
						}
					}

				}

				taskEXIT_CRITICAL();
800060b6:	f0 1f 00 2d 	mcall	80006168 <xQueueGenericReceive+0x124>
800060ba:	30 1c       	mov	r12,1
				return pdPASS;
800060bc:	c4 c8       	rjmp	80006154 <xQueueGenericReceive+0x110>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
800060be:	40 28       	lddsp	r8,sp[0x8]
800060c0:	58 08       	cp.w	r8,0
800060c2:	c0 51       	brne	800060cc <xQueueGenericReceive+0x88>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
800060c4:	f0 1f 00 29 	mcall	80006168 <xQueueGenericReceive+0x124>
800060c8:	30 0c       	mov	r12,0
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
800060ca:	c4 58       	rjmp	80006154 <xQueueGenericReceive+0x110>
				}
				else if( xEntryTimeSet == pdFALSE )
800060cc:	58 05       	cp.w	r5,0
800060ce:	c0 51       	brne	800060d8 <xQueueGenericReceive+0x94>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
800060d0:	08 9c       	mov	r12,r4
800060d2:	f0 1f 00 27 	mcall	8000616c <xQueueGenericReceive+0x128>
800060d6:	00 95       	mov	r5,r0
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
800060d8:	f0 1f 00 24 	mcall	80006168 <xQueueGenericReceive+0x124>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
800060dc:	f0 1f 00 25 	mcall	80006170 <xQueueGenericReceive+0x12c>
		prvLockQueue( pxQueue );
800060e0:	f0 1f 00 1e 	mcall	80006158 <xQueueGenericReceive+0x114>
800060e4:	6f 18       	ld.w	r8,r7[0x44]
800060e6:	5b f8       	cp.w	r8,-1
800060e8:	ef f1 0a 11 	st.weq	r7[0x44],r1
800060ec:	6f 28       	ld.w	r8,r7[0x48]
800060ee:	5b f8       	cp.w	r8,-1
800060f0:	ef f1 0a 12 	st.weq	r7[0x48],r1
800060f4:	f0 1f 00 1d 	mcall	80006168 <xQueueGenericReceive+0x124>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
800060f8:	06 9b       	mov	r11,r3
800060fa:	08 9c       	mov	r12,r4
800060fc:	f0 1f 00 1e 	mcall	80006174 <xQueueGenericReceive+0x130>
80006100:	c2 41       	brne	80006148 <xQueueGenericReceive+0x104>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
80006102:	f0 1f 00 16 	mcall	80006158 <xQueueGenericReceive+0x114>
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
80006106:	6e e6       	ld.w	r6,r7[0x38]
	taskEXIT_CRITICAL();
80006108:	f0 1f 00 18 	mcall	80006168 <xQueueGenericReceive+0x124>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) )
8000610c:	58 06       	cp.w	r6,0
8000610e:	c1 71       	brne	8000613c <xQueueGenericReceive+0xf8>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80006110:	6e 08       	ld.w	r8,r7[0x0]
80006112:	58 08       	cp.w	r8,0
80006114:	c0 81       	brne	80006124 <xQueueGenericReceive+0xe0>
					{
						portENTER_CRITICAL();
80006116:	f0 1f 00 11 	mcall	80006158 <xQueueGenericReceive+0x114>
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
8000611a:	6e 1c       	ld.w	r12,r7[0x4]
8000611c:	f0 1f 00 17 	mcall	80006178 <xQueueGenericReceive+0x134>
						}
						portEXIT_CRITICAL();
80006120:	f0 1f 00 12 	mcall	80006168 <xQueueGenericReceive+0x124>
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80006124:	40 2b       	lddsp	r11,sp[0x8]
80006126:	04 9c       	mov	r12,r2
80006128:	f0 1f 00 15 	mcall	8000617c <xQueueGenericReceive+0x138>
				prvUnlockQueue( pxQueue );
8000612c:	0e 9c       	mov	r12,r7
8000612e:	f0 1f 00 15 	mcall	80006180 <xQueueGenericReceive+0x13c>
				if( !xTaskResumeAll() )
80006132:	f0 1f 00 15 	mcall	80006184 <xQueueGenericReceive+0x140>
80006136:	c9 61       	brne	80006062 <xQueueGenericReceive+0x1e>
				{
					portYIELD_WITHIN_API();
80006138:	d7 33       	scall
8000613a:	c9 4b       	rjmp	80006062 <xQueueGenericReceive+0x1e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
8000613c:	0e 9c       	mov	r12,r7
8000613e:	f0 1f 00 11 	mcall	80006180 <xQueueGenericReceive+0x13c>
				( void ) xTaskResumeAll();
80006142:	f0 1f 00 11 	mcall	80006184 <xQueueGenericReceive+0x140>
80006146:	c8 eb       	rjmp	80006062 <xQueueGenericReceive+0x1e>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
80006148:	0e 9c       	mov	r12,r7
8000614a:	f0 1f 00 0e 	mcall	80006180 <xQueueGenericReceive+0x13c>
			( void ) xTaskResumeAll();
8000614e:	f0 1f 00 0e 	mcall	80006184 <xQueueGenericReceive+0x140>
80006152:	30 0c       	mov	r12,0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
80006154:	2f bd       	sub	sp,-20
80006156:	d8 32       	popm	r0-r7,pc
80006158:	80 00       	ld.sh	r0,r0[0x0]
8000615a:	5c 90       	brev	r0
8000615c:	80 00       	ld.sh	r0,r0[0x0]
8000615e:	5f 24       	srhs	r4
80006160:	80 00       	ld.sh	r0,r0[0x0]
80006162:	64 74       	ld.w	r4,r2[0x1c]
80006164:	80 00       	ld.sh	r0,r0[0x0]
80006166:	65 5c       	ld.w	r12,r2[0x54]
80006168:	80 00       	ld.sh	r0,r0[0x0]
8000616a:	5d 9c       	*unknown*
8000616c:	80 00       	ld.sh	r0,r0[0x0]
8000616e:	64 50       	ld.w	r0,r2[0x14]
80006170:	80 00       	ld.sh	r0,r0[0x0]
80006172:	63 c4       	ld.w	r4,r1[0x70]
80006174:	80 00       	ld.sh	r0,r0[0x0]
80006176:	66 ec       	ld.w	r12,r3[0x38]
80006178:	80 00       	ld.sh	r0,r0[0x0]
8000617a:	64 d8       	ld.w	r8,r2[0x34]
8000617c:	80 00       	ld.sh	r0,r0[0x0]
8000617e:	69 8c       	ld.w	r12,r4[0x60]
80006180:	80 00       	ld.sh	r0,r0[0x0]
80006182:	5f a4       	srle	r4
80006184:	80 00       	ld.sh	r0,r0[0x0]
80006186:	67 80       	ld.w	r0,r3[0x60]

80006188 <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
80006188:	eb cd 40 80 	pushm	r7,lr
8000618c:	18 97       	mov	r7,r12
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
8000618e:	79 08       	ld.w	r8,r12[0x40]
80006190:	58 08       	cp.w	r8,0
80006192:	c0 a1       	brne	800061a6 <prvCopyDataToQueue+0x1e>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80006194:	78 08       	ld.w	r8,r12[0x0]
80006196:	58 08       	cp.w	r8,0
80006198:	c2 b1       	brne	800061ee <prvCopyDataToQueue+0x66>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
8000619a:	78 1c       	ld.w	r12,r12[0x4]
8000619c:	f0 1f 00 17 	mcall	800061f8 <prvCopyDataToQueue+0x70>
				pxQueue->pxMutexHolder = NULL;
800061a0:	30 08       	mov	r8,0
800061a2:	8f 18       	st.w	r7[0x4],r8
800061a4:	c2 58       	rjmp	800061ee <prvCopyDataToQueue+0x66>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
800061a6:	58 0a       	cp.w	r10,0
800061a8:	c1 01       	brne	800061c8 <prvCopyDataToQueue+0x40>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
800061aa:	10 9a       	mov	r10,r8
800061ac:	78 2c       	ld.w	r12,r12[0x8]
800061ae:	f0 1f 00 14 	mcall	800061fc <prvCopyDataToQueue+0x74>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
800061b2:	6e 29       	ld.w	r9,r7[0x8]
800061b4:	6f 08       	ld.w	r8,r7[0x40]
800061b6:	f2 08 00 08 	add	r8,r9,r8
800061ba:	8f 28       	st.w	r7[0x8],r8
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
800061bc:	6e 19       	ld.w	r9,r7[0x4]
800061be:	12 38       	cp.w	r8,r9
800061c0:	c1 73       	brcs	800061ee <prvCopyDataToQueue+0x66>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
800061c2:	6e 08       	ld.w	r8,r7[0x0]
800061c4:	8f 28       	st.w	r7[0x8],r8
800061c6:	c1 48       	rjmp	800061ee <prvCopyDataToQueue+0x66>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
800061c8:	10 9a       	mov	r10,r8
800061ca:	78 3c       	ld.w	r12,r12[0xc]
800061cc:	f0 1f 00 0c 	mcall	800061fc <prvCopyDataToQueue+0x74>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
800061d0:	6f 08       	ld.w	r8,r7[0x40]
800061d2:	6e 39       	ld.w	r9,r7[0xc]
800061d4:	f2 08 01 08 	sub	r8,r9,r8
800061d8:	8f 38       	st.w	r7[0xc],r8
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
800061da:	6e 09       	ld.w	r9,r7[0x0]
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
800061dc:	12 38       	cp.w	r8,r9
800061de:	ef f8 30 10 	ld.wcs	r8,r7[0x40]
800061e2:	ef f9 30 01 	ld.wcs	r9,r7[0x4]
800061e6:	f3 d8 e3 19 	subcs	r9,r9,r8
800061ea:	ef f9 3a 03 	st.wcs	r7[0xc],r9
		}
	}

	++( pxQueue->uxMessagesWaiting );
800061ee:	6e e8       	ld.w	r8,r7[0x38]
800061f0:	2f f8       	sub	r8,-1
800061f2:	8f e8       	st.w	r7[0x38],r8
}
800061f4:	e3 cd 80 80 	ldm	sp++,r7,pc
800061f8:	80 00       	ld.sh	r0,r0[0x0]
800061fa:	64 80       	ld.w	r0,r2[0x20]
800061fc:	80 00       	ld.sh	r0,r0[0x0]
800061fe:	76 b0       	ld.w	r0,r11[0x2c]

80006200 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
80006200:	eb cd 40 c0 	pushm	r6-r7,lr
80006204:	18 97       	mov	r7,r12
80006206:	14 96       	mov	r6,r10
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
80006208:	78 ec       	ld.w	r12,r12[0x38]
8000620a:	6e f8       	ld.w	r8,r7[0x3c]
8000620c:	10 3c       	cp.w	r12,r8
8000620e:	c0 33       	brcs	80006214 <xQueueGenericSendFromISR+0x14>
80006210:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80006214:	12 9a       	mov	r10,r9
80006216:	0e 9c       	mov	r12,r7
80006218:	f0 1f 00 0c 	mcall	80006248 <xQueueGenericSendFromISR+0x48>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
8000621c:	6f 28       	ld.w	r8,r7[0x48]
8000621e:	5b f8       	cp.w	r8,-1
80006220:	c0 d1       	brne	8000623a <xQueueGenericSendFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80006222:	6e 98       	ld.w	r8,r7[0x24]
80006224:	58 08       	cp.w	r8,0
80006226:	c0 f0       	breq	80006244 <xQueueGenericSendFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80006228:	ee cc ff dc 	sub	r12,r7,-36
8000622c:	f0 1f 00 08 	mcall	8000624c <xQueueGenericSendFromISR+0x4c>
80006230:	c0 a0       	breq	80006244 <xQueueGenericSendFromISR+0x44>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
80006232:	30 1c       	mov	r12,1
80006234:	8d 0c       	st.w	r6[0x0],r12
80006236:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
8000623a:	2f f8       	sub	r8,-1
8000623c:	ef 48 00 48 	st.w	r7[72],r8
80006240:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80006244:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80006248:	80 00       	ld.sh	r0,r0[0x0]
8000624a:	61 88       	ld.w	r8,r0[0x60]
8000624c:	80 00       	ld.sh	r0,r0[0x0]
8000624e:	65 5c       	ld.w	r12,r2[0x54]

80006250 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
80006250:	d4 31       	pushm	r0-r7,lr
80006252:	20 5d       	sub	sp,20
80006254:	18 97       	mov	r7,r12
80006256:	50 0b       	stdsp	sp[0x0],r11
80006258:	50 2a       	stdsp	sp[0x8],r10
8000625a:	50 19       	stdsp	sp[0x4],r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
8000625c:	f8 c0 ff f0 	sub	r0,r12,-16
80006260:	30 04       	mov	r4,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80006262:	fa c3 ff f4 	sub	r3,sp,-12

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
80006266:	08 91       	mov	r1,r4

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80006268:	fa c2 ff f8 	sub	r2,sp,-8
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
8000626c:	f0 1f 00 2f 	mcall	80006328 <xQueueGenericSend+0xd8>
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
80006270:	6e e9       	ld.w	r9,r7[0x38]
80006272:	6e f8       	ld.w	r8,r7[0x3c]
80006274:	10 39       	cp.w	r9,r8
80006276:	c1 42       	brcc	8000629e <xQueueGenericSend+0x4e>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80006278:	40 1a       	lddsp	r10,sp[0x4]
8000627a:	40 0b       	lddsp	r11,sp[0x0]
8000627c:	0e 9c       	mov	r12,r7
8000627e:	f0 1f 00 2c 	mcall	8000632c <xQueueGenericSend+0xdc>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80006282:	6e 98       	ld.w	r8,r7[0x24]
80006284:	58 08       	cp.w	r8,0
80006286:	c0 80       	breq	80006296 <xQueueGenericSend+0x46>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
80006288:	ee cc ff dc 	sub	r12,r7,-36
8000628c:	f0 1f 00 29 	mcall	80006330 <xQueueGenericSend+0xe0>
80006290:	58 1c       	cp.w	r12,1
80006292:	c0 21       	brne	80006296 <xQueueGenericSend+0x46>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
80006294:	d7 33       	scall
					}
				}

				taskEXIT_CRITICAL();
80006296:	f0 1f 00 28 	mcall	80006334 <xQueueGenericSend+0xe4>
8000629a:	30 1c       	mov	r12,1

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
8000629c:	c4 38       	rjmp	80006322 <xQueueGenericSend+0xd2>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
8000629e:	40 28       	lddsp	r8,sp[0x8]
800062a0:	58 08       	cp.w	r8,0
800062a2:	c0 51       	brne	800062ac <xQueueGenericSend+0x5c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
800062a4:	f0 1f 00 24 	mcall	80006334 <xQueueGenericSend+0xe4>
800062a8:	30 0c       	mov	r12,0

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
800062aa:	c3 c8       	rjmp	80006322 <xQueueGenericSend+0xd2>
				}
				else if( xEntryTimeSet == pdFALSE )
800062ac:	58 04       	cp.w	r4,0
800062ae:	c0 51       	brne	800062b8 <xQueueGenericSend+0x68>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
800062b0:	06 9c       	mov	r12,r3
800062b2:	f0 1f 00 22 	mcall	80006338 <xQueueGenericSend+0xe8>
800062b6:	30 14       	mov	r4,1
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
800062b8:	f0 1f 00 1f 	mcall	80006334 <xQueueGenericSend+0xe4>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
800062bc:	f0 1f 00 20 	mcall	8000633c <xQueueGenericSend+0xec>
		prvLockQueue( pxQueue );
800062c0:	f0 1f 00 1a 	mcall	80006328 <xQueueGenericSend+0xd8>
800062c4:	6f 18       	ld.w	r8,r7[0x44]
800062c6:	5b f8       	cp.w	r8,-1
800062c8:	ef f1 0a 11 	st.weq	r7[0x44],r1
800062cc:	6f 28       	ld.w	r8,r7[0x48]
800062ce:	5b f8       	cp.w	r8,-1
800062d0:	ef f1 0a 12 	st.weq	r7[0x48],r1
800062d4:	f0 1f 00 18 	mcall	80006334 <xQueueGenericSend+0xe4>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
800062d8:	04 9b       	mov	r11,r2
800062da:	06 9c       	mov	r12,r3
800062dc:	f0 1f 00 19 	mcall	80006340 <xQueueGenericSend+0xf0>
800062e0:	c1 b1       	brne	80006316 <xQueueGenericSend+0xc6>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
800062e2:	f0 1f 00 12 	mcall	80006328 <xQueueGenericSend+0xd8>
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
800062e6:	6e e5       	ld.w	r5,r7[0x38]
800062e8:	6e f6       	ld.w	r6,r7[0x3c]
	taskEXIT_CRITICAL();
800062ea:	f0 1f 00 13 	mcall	80006334 <xQueueGenericSend+0xe4>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
800062ee:	0c 35       	cp.w	r5,r6
800062f0:	c0 d1       	brne	8000630a <xQueueGenericSend+0xba>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
800062f2:	40 2b       	lddsp	r11,sp[0x8]
800062f4:	00 9c       	mov	r12,r0
800062f6:	f0 1f 00 14 	mcall	80006344 <xQueueGenericSend+0xf4>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
800062fa:	0e 9c       	mov	r12,r7
800062fc:	f0 1f 00 13 	mcall	80006348 <xQueueGenericSend+0xf8>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
80006300:	f0 1f 00 13 	mcall	8000634c <xQueueGenericSend+0xfc>
80006304:	cb 41       	brne	8000626c <xQueueGenericSend+0x1c>
				{
					portYIELD_WITHIN_API();
80006306:	d7 33       	scall
80006308:	cb 2b       	rjmp	8000626c <xQueueGenericSend+0x1c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
8000630a:	0e 9c       	mov	r12,r7
8000630c:	f0 1f 00 0f 	mcall	80006348 <xQueueGenericSend+0xf8>
				( void ) xTaskResumeAll();
80006310:	f0 1f 00 0f 	mcall	8000634c <xQueueGenericSend+0xfc>
80006314:	ca cb       	rjmp	8000626c <xQueueGenericSend+0x1c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
80006316:	0e 9c       	mov	r12,r7
80006318:	f0 1f 00 0c 	mcall	80006348 <xQueueGenericSend+0xf8>
			( void ) xTaskResumeAll();
8000631c:	f0 1f 00 0c 	mcall	8000634c <xQueueGenericSend+0xfc>
80006320:	30 0c       	mov	r12,0
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
80006322:	2f bd       	sub	sp,-20
80006324:	d8 32       	popm	r0-r7,pc
80006326:	00 00       	add	r0,r0
80006328:	80 00       	ld.sh	r0,r0[0x0]
8000632a:	5c 90       	brev	r0
8000632c:	80 00       	ld.sh	r0,r0[0x0]
8000632e:	61 88       	ld.w	r8,r0[0x60]
80006330:	80 00       	ld.sh	r0,r0[0x0]
80006332:	65 5c       	ld.w	r12,r2[0x54]
80006334:	80 00       	ld.sh	r0,r0[0x0]
80006336:	5d 9c       	*unknown*
80006338:	80 00       	ld.sh	r0,r0[0x0]
8000633a:	64 50       	ld.w	r0,r2[0x14]
8000633c:	80 00       	ld.sh	r0,r0[0x0]
8000633e:	63 c4       	ld.w	r4,r1[0x70]
80006340:	80 00       	ld.sh	r0,r0[0x0]
80006342:	66 ec       	ld.w	r12,r3[0x38]
80006344:	80 00       	ld.sh	r0,r0[0x0]
80006346:	69 8c       	ld.w	r12,r4[0x60]
80006348:	80 00       	ld.sh	r0,r0[0x0]
8000634a:	5f a4       	srle	r4
8000634c:	80 00       	ld.sh	r0,r0[0x0]
8000634e:	67 80       	ld.w	r0,r3[0x60]

80006350 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
80006350:	d4 21       	pushm	r4-r7,lr
80006352:	18 97       	mov	r7,r12
80006354:	16 96       	mov	r6,r11
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
80006356:	58 0c       	cp.w	r12,0
80006358:	c2 f0       	breq	800063b6 <xQueueCreate+0x66>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
8000635a:	34 cc       	mov	r12,76
8000635c:	f0 1f 00 17 	mcall	800063b8 <xQueueCreate+0x68>
80006360:	18 95       	mov	r5,r12
		if( pxNewQueue != NULL )
80006362:	c2 a0       	breq	800063b6 <xQueueCreate+0x66>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
80006364:	ec 07 02 44 	mul	r4,r6,r7

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
80006368:	e8 cc ff ff 	sub	r12,r4,-1
8000636c:	f0 1f 00 13 	mcall	800063b8 <xQueueCreate+0x68>
80006370:	8b 0c       	st.w	r5[0x0],r12
			if( pxNewQueue->pcHead != NULL )
80006372:	c1 e0       	breq	800063ae <xQueueCreate+0x5e>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
80006374:	f8 04 00 04 	add	r4,r12,r4
80006378:	8b 14       	st.w	r5[0x4],r4
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
8000637a:	30 08       	mov	r8,0
8000637c:	8b e8       	st.w	r5[0x38],r8
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
8000637e:	8b 2c       	st.w	r5[0x8],r12
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
80006380:	ee c8 00 01 	sub	r8,r7,1
80006384:	ad 38       	mul	r8,r6
80006386:	10 0c       	add	r12,r8
80006388:	8b 3c       	st.w	r5[0xc],r12
				pxNewQueue->uxLength = uxQueueLength;
8000638a:	8b f7       	st.w	r5[0x3c],r7
				pxNewQueue->uxItemSize = uxItemSize;
8000638c:	eb 46 00 40 	st.w	r5[64],r6
				pxNewQueue->xRxLock = queueUNLOCKED;
80006390:	3f f8       	mov	r8,-1
80006392:	eb 48 00 44 	st.w	r5[68],r8
				pxNewQueue->xTxLock = queueUNLOCKED;
80006396:	eb 48 00 48 	st.w	r5[72],r8

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
8000639a:	ea cc ff f0 	sub	r12,r5,-16
8000639e:	f0 1f 00 08 	mcall	800063bc <xQueueCreate+0x6c>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
800063a2:	ea cc ff dc 	sub	r12,r5,-36
800063a6:	f0 1f 00 06 	mcall	800063bc <xQueueCreate+0x6c>
800063aa:	0a 9c       	mov	r12,r5
800063ac:	d8 22       	popm	r4-r7,pc
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
800063ae:	0a 9c       	mov	r12,r5
800063b0:	f0 1f 00 04 	mcall	800063c0 <xQueueCreate+0x70>
800063b4:	d8 2a       	popm	r4-r7,pc,r12=0
800063b6:	d8 2a       	popm	r4-r7,pc,r12=0
800063b8:	80 00       	ld.sh	r0,r0[0x0]
800063ba:	5e fc       	retal	r12
800063bc:	80 00       	ld.sh	r0,r0[0x0]
800063be:	5b 6c       	cp.w	r12,-10
800063c0:	80 00       	ld.sh	r0,r0[0x0]
800063c2:	5e d4       	retvc	r4

800063c4 <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
800063c4:	48 38       	lddpc	r8,800063d0 <vTaskSuspendAll+0xc>
800063c6:	70 09       	ld.w	r9,r8[0x0]
800063c8:	2f f9       	sub	r9,-1
800063ca:	91 09       	st.w	r8[0x0],r9
}
800063cc:	5e fc       	retal	r12
800063ce:	00 00       	add	r0,r0
800063d0:	00 00       	add	r0,r0
800063d2:	0d 08       	ld.w	r8,r6++

800063d4 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
800063d4:	49 a8       	lddpc	r8,8000643c <vTaskSwitchContext+0x68>
800063d6:	70 08       	ld.w	r8,r8[0x0]
800063d8:	58 08       	cp.w	r8,0
800063da:	c0 b1       	brne	800063f0 <vTaskSwitchContext+0x1c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
800063dc:	49 98       	lddpc	r8,80006440 <vTaskSwitchContext+0x6c>
800063de:	70 08       	ld.w	r8,r8[0x0]
800063e0:	f0 08 00 28 	add	r8,r8,r8<<0x2
800063e4:	49 89       	lddpc	r9,80006444 <vTaskSwitchContext+0x70>
800063e6:	f2 08 03 28 	ld.w	r8,r9[r8<<0x2]
800063ea:	58 08       	cp.w	r8,0
800063ec:	c0 60       	breq	800063f8 <vTaskSwitchContext+0x24>
800063ee:	c1 18       	rjmp	80006410 <vTaskSwitchContext+0x3c>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
800063f0:	30 19       	mov	r9,1
800063f2:	49 68       	lddpc	r8,80006448 <vTaskSwitchContext+0x74>
800063f4:	91 09       	st.w	r8[0x0],r9
800063f6:	5e fc       	retal	r12

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
800063f8:	49 28       	lddpc	r8,80006440 <vTaskSwitchContext+0x6c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
800063fa:	49 3a       	lddpc	r10,80006444 <vTaskSwitchContext+0x70>
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
800063fc:	70 09       	ld.w	r9,r8[0x0]
800063fe:	20 19       	sub	r9,1
80006400:	91 09       	st.w	r8[0x0],r9

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80006402:	70 09       	ld.w	r9,r8[0x0]
80006404:	f2 09 00 29 	add	r9,r9,r9<<0x2
80006408:	f4 09 03 29 	ld.w	r9,r10[r9<<0x2]
8000640c:	58 09       	cp.w	r9,0
8000640e:	cf 70       	breq	800063fc <vTaskSwitchContext+0x28>
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
80006410:	48 c8       	lddpc	r8,80006440 <vTaskSwitchContext+0x6c>
80006412:	70 08       	ld.w	r8,r8[0x0]
80006414:	f0 08 00 28 	add	r8,r8,r8<<0x2
80006418:	48 b9       	lddpc	r9,80006444 <vTaskSwitchContext+0x70>
8000641a:	f2 08 00 28 	add	r8,r9,r8<<0x2
8000641e:	70 19       	ld.w	r9,r8[0x4]
80006420:	72 19       	ld.w	r9,r9[0x4]
80006422:	91 19       	st.w	r8[0x4],r9
80006424:	f0 ca ff f8 	sub	r10,r8,-8
80006428:	14 39       	cp.w	r9,r10
8000642a:	f3 f9 00 01 	ld.weq	r9,r9[0x4]
8000642e:	f1 f9 0a 01 	st.weq	r8[0x4],r9
80006432:	70 18       	ld.w	r8,r8[0x4]
80006434:	70 39       	ld.w	r9,r8[0xc]
80006436:	48 68       	lddpc	r8,8000644c <vTaskSwitchContext+0x78>
80006438:	91 09       	st.w	r8[0x0],r9
8000643a:	5e fc       	retal	r12
8000643c:	00 00       	add	r0,r0
8000643e:	0d 08       	ld.w	r8,r6++
80006440:	00 00       	add	r0,r0
80006442:	0d 40       	ld.w	r0,--r6
80006444:	00 00       	add	r0,r0
80006446:	0c 24       	rsub	r4,r6
80006448:	00 00       	add	r0,r0
8000644a:	0d 28       	ld.uh	r8,r6++
8000644c:	00 00       	add	r0,r0
8000644e:	0c d8       	st.w	--r6,r8

80006450 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
80006450:	48 48       	lddpc	r8,80006460 <vTaskSetTimeOutState+0x10>
80006452:	70 08       	ld.w	r8,r8[0x0]
80006454:	99 08       	st.w	r12[0x0],r8
	pxTimeOut->xTimeOnEntering = xTickCount;
80006456:	48 48       	lddpc	r8,80006464 <vTaskSetTimeOutState+0x14>
80006458:	70 08       	ld.w	r8,r8[0x0]
8000645a:	99 18       	st.w	r12[0x4],r8
}
8000645c:	5e fc       	retal	r12
8000645e:	00 00       	add	r0,r0
80006460:	00 00       	add	r0,r0
80006462:	0c 1c       	sub	r12,r6
80006464:	00 00       	add	r0,r0
80006466:	0d 04       	ld.w	r4,r6++

80006468 <vTaskMissedYield>:
}
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
80006468:	30 19       	mov	r9,1
8000646a:	48 28       	lddpc	r8,80006470 <vTaskMissedYield+0x8>
8000646c:	91 09       	st.w	r8[0x0],r9
}
8000646e:	5e fc       	retal	r12
80006470:	00 00       	add	r0,r0
80006472:	0d 28       	ld.uh	r8,r6++

80006474 <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
80006474:	48 28       	lddpc	r8,8000647c <xTaskGetCurrentTaskHandle+0x8>
80006476:	70 0c       	ld.w	r12,r8[0x0]

		return xReturn;
	}
80006478:	5e fc       	retal	r12
8000647a:	00 00       	add	r0,r0
8000647c:	00 00       	add	r0,r0
8000647e:	0c d8       	st.w	--r6,r8

80006480 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
80006480:	eb cd 40 c0 	pushm	r6-r7,lr
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
80006484:	58 0c       	cp.w	r12,0
80006486:	c1 f0       	breq	800064c4 <vTaskPriorityDisinherit+0x44>

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
80006488:	18 97       	mov	r7,r12

		if( pxMutexHolder != NULL )
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
8000648a:	78 b9       	ld.w	r9,r12[0x2c]
8000648c:	79 18       	ld.w	r8,r12[0x44]
8000648e:	10 39       	cp.w	r9,r8
80006490:	c1 a0       	breq	800064c4 <vTaskPriorityDisinherit+0x44>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
80006492:	f8 c6 ff fc 	sub	r6,r12,-4
80006496:	0c 9c       	mov	r12,r6
80006498:	f0 1f 00 0c 	mcall	800064c8 <vTaskPriorityDisinherit+0x48>

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
8000649c:	6f 1c       	ld.w	r12,r7[0x44]
8000649e:	8f bc       	st.w	r7[0x2c],r12
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
800064a0:	f8 08 11 08 	rsub	r8,r12,8
800064a4:	8f 68       	st.w	r7[0x18],r8
				prvAddTaskToReadyQueue( pxTCB );
800064a6:	48 a8       	lddpc	r8,800064cc <vTaskPriorityDisinherit+0x4c>
800064a8:	70 08       	ld.w	r8,r8[0x0]
800064aa:	10 3c       	cp.w	r12,r8
800064ac:	e0 88 00 04 	brls	800064b4 <vTaskPriorityDisinherit+0x34>
800064b0:	48 78       	lddpc	r8,800064cc <vTaskPriorityDisinherit+0x4c>
800064b2:	91 0c       	st.w	r8[0x0],r12
800064b4:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800064b8:	0c 9b       	mov	r11,r6
800064ba:	48 68       	lddpc	r8,800064d0 <vTaskPriorityDisinherit+0x50>
800064bc:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800064c0:	f0 1f 00 05 	mcall	800064d4 <vTaskPriorityDisinherit+0x54>
800064c4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800064c8:	80 00       	ld.sh	r0,r0[0x0]
800064ca:	5b d6       	cp.w	r6,-3
800064cc:	00 00       	add	r0,r0
800064ce:	0d 40       	ld.w	r0,--r6
800064d0:	00 00       	add	r0,r0
800064d2:	0c 24       	rsub	r4,r6
800064d4:	80 00       	ld.sh	r0,r0[0x0]
800064d6:	5b 86       	cp.w	r6,-8

800064d8 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
800064d8:	eb cd 40 c0 	pushm	r6-r7,lr
800064dc:	18 97       	mov	r7,r12
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
800064de:	49 b8       	lddpc	r8,80006548 <vTaskPriorityInherit+0x70>
800064e0:	70 08       	ld.w	r8,r8[0x0]
800064e2:	78 b9       	ld.w	r9,r12[0x2c]
800064e4:	70 b8       	ld.w	r8,r8[0x2c]
800064e6:	10 39       	cp.w	r9,r8
800064e8:	c2 d2       	brcc	80006542 <vTaskPriorityInherit+0x6a>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
800064ea:	49 88       	lddpc	r8,80006548 <vTaskPriorityInherit+0x70>
800064ec:	70 08       	ld.w	r8,r8[0x0]
800064ee:	70 b8       	ld.w	r8,r8[0x2c]
800064f0:	f0 08 11 08 	rsub	r8,r8,8
800064f4:	99 68       	st.w	r12[0x18],r8

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
800064f6:	f2 09 00 28 	add	r8,r9,r9<<0x2
800064fa:	49 59       	lddpc	r9,8000654c <vTaskPriorityInherit+0x74>
800064fc:	f2 08 00 28 	add	r8,r9,r8<<0x2
80006500:	78 59       	ld.w	r9,r12[0x14]
80006502:	10 39       	cp.w	r9,r8
80006504:	c1 b1       	brne	8000653a <vTaskPriorityInherit+0x62>
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
80006506:	f8 c6 ff fc 	sub	r6,r12,-4
8000650a:	0c 9c       	mov	r12,r6
8000650c:	f0 1f 00 11 	mcall	80006550 <vTaskPriorityInherit+0x78>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
80006510:	48 e8       	lddpc	r8,80006548 <vTaskPriorityInherit+0x70>
80006512:	70 08       	ld.w	r8,r8[0x0]
80006514:	70 bc       	ld.w	r12,r8[0x2c]
80006516:	8f bc       	st.w	r7[0x2c],r12
				prvAddTaskToReadyQueue( pxTCB );
80006518:	48 f8       	lddpc	r8,80006554 <vTaskPriorityInherit+0x7c>
8000651a:	70 08       	ld.w	r8,r8[0x0]
8000651c:	10 3c       	cp.w	r12,r8
8000651e:	e0 88 00 04 	brls	80006526 <vTaskPriorityInherit+0x4e>
80006522:	48 d8       	lddpc	r8,80006554 <vTaskPriorityInherit+0x7c>
80006524:	91 0c       	st.w	r8[0x0],r12
80006526:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
8000652a:	0c 9b       	mov	r11,r6
8000652c:	48 88       	lddpc	r8,8000654c <vTaskPriorityInherit+0x74>
8000652e:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80006532:	f0 1f 00 0a 	mcall	80006558 <vTaskPriorityInherit+0x80>
80006536:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
8000653a:	48 48       	lddpc	r8,80006548 <vTaskPriorityInherit+0x70>
8000653c:	70 08       	ld.w	r8,r8[0x0]
8000653e:	70 b8       	ld.w	r8,r8[0x2c]
80006540:	99 b8       	st.w	r12[0x2c],r8
80006542:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006546:	00 00       	add	r0,r0
80006548:	00 00       	add	r0,r0
8000654a:	0c d8       	st.w	--r6,r8
8000654c:	00 00       	add	r0,r0
8000654e:	0c 24       	rsub	r4,r6
80006550:	80 00       	ld.sh	r0,r0[0x0]
80006552:	5b d6       	cp.w	r6,-3
80006554:	00 00       	add	r0,r0
80006556:	0d 40       	ld.w	r0,--r6
80006558:	80 00       	ld.sh	r0,r0[0x0]
8000655a:	5b 86       	cp.w	r6,-8

8000655c <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
8000655c:	eb cd 40 c0 	pushm	r6-r7,lr
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
80006560:	78 38       	ld.w	r8,r12[0xc]
80006562:	70 37       	ld.w	r7,r8[0xc]
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
80006564:	ee c6 ff e8 	sub	r6,r7,-24
80006568:	0c 9c       	mov	r12,r6
8000656a:	f0 1f 00 15 	mcall	800065bc <xTaskRemoveFromEventList+0x60>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
8000656e:	49 58       	lddpc	r8,800065c0 <xTaskRemoveFromEventList+0x64>
80006570:	70 08       	ld.w	r8,r8[0x0]
80006572:	58 08       	cp.w	r8,0
80006574:	c1 71       	brne	800065a2 <xTaskRemoveFromEventList+0x46>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
80006576:	ee c6 ff fc 	sub	r6,r7,-4
8000657a:	0c 9c       	mov	r12,r6
8000657c:	f0 1f 00 10 	mcall	800065bc <xTaskRemoveFromEventList+0x60>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
80006580:	6e bc       	ld.w	r12,r7[0x2c]
80006582:	49 18       	lddpc	r8,800065c4 <xTaskRemoveFromEventList+0x68>
80006584:	70 08       	ld.w	r8,r8[0x0]
80006586:	10 3c       	cp.w	r12,r8
80006588:	e0 88 00 04 	brls	80006590 <xTaskRemoveFromEventList+0x34>
8000658c:	48 e8       	lddpc	r8,800065c4 <xTaskRemoveFromEventList+0x68>
8000658e:	91 0c       	st.w	r8[0x0],r12
80006590:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006594:	0c 9b       	mov	r11,r6
80006596:	48 d8       	lddpc	r8,800065c8 <xTaskRemoveFromEventList+0x6c>
80006598:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
8000659c:	f0 1f 00 0c 	mcall	800065cc <xTaskRemoveFromEventList+0x70>
800065a0:	c0 58       	rjmp	800065aa <xTaskRemoveFromEventList+0x4e>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
800065a2:	0c 9b       	mov	r11,r6
800065a4:	48 bc       	lddpc	r12,800065d0 <xTaskRemoveFromEventList+0x74>
800065a6:	f0 1f 00 0a 	mcall	800065cc <xTaskRemoveFromEventList+0x70>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
800065aa:	48 b8       	lddpc	r8,800065d4 <xTaskRemoveFromEventList+0x78>
800065ac:	70 08       	ld.w	r8,r8[0x0]
800065ae:	6e b9       	ld.w	r9,r7[0x2c]
800065b0:	70 b8       	ld.w	r8,r8[0x2c]
800065b2:	10 39       	cp.w	r9,r8
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
800065b4:	5f 2c       	srhs	r12
800065b6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800065ba:	00 00       	add	r0,r0
800065bc:	80 00       	ld.sh	r0,r0[0x0]
800065be:	5b d6       	cp.w	r6,-3
800065c0:	00 00       	add	r0,r0
800065c2:	0d 08       	ld.w	r8,r6++
800065c4:	00 00       	add	r0,r0
800065c6:	0d 40       	ld.w	r0,--r6
800065c8:	00 00       	add	r0,r0
800065ca:	0c 24       	rsub	r4,r6
800065cc:	80 00       	ld.sh	r0,r0[0x0]
800065ce:	5b 86       	cp.w	r6,-8
800065d0:	00 00       	add	r0,r0
800065d2:	0c dc       	st.w	--r6,r12
800065d4:	00 00       	add	r0,r0
800065d6:	0c d8       	st.w	--r6,r8

800065d8 <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
800065d8:	eb cd 40 fc 	pushm	r2-r7,lr
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
800065dc:	4b 98       	lddpc	r8,800066c0 <vTaskIncrementTick+0xe8>
800065de:	70 08       	ld.w	r8,r8[0x0]
800065e0:	58 08       	cp.w	r8,0
800065e2:	c6 91       	brne	800066b4 <vTaskIncrementTick+0xdc>
	{
		++xTickCount;
800065e4:	4b 88       	lddpc	r8,800066c4 <vTaskIncrementTick+0xec>
800065e6:	70 09       	ld.w	r9,r8[0x0]
800065e8:	2f f9       	sub	r9,-1
800065ea:	91 09       	st.w	r8[0x0],r9
		if( xTickCount == ( portTickType ) 0 )
800065ec:	70 08       	ld.w	r8,r8[0x0]
800065ee:	58 08       	cp.w	r8,0
800065f0:	c1 a1       	brne	80006624 <vTaskIncrementTick+0x4c>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
800065f2:	4b 68       	lddpc	r8,800066c8 <vTaskIncrementTick+0xf0>
800065f4:	70 0a       	ld.w	r10,r8[0x0]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
800065f6:	4b 69       	lddpc	r9,800066cc <vTaskIncrementTick+0xf4>
800065f8:	72 0b       	ld.w	r11,r9[0x0]
800065fa:	91 0b       	st.w	r8[0x0],r11
			pxOverflowDelayedTaskList = pxTemp;
800065fc:	93 0a       	st.w	r9[0x0],r10
			xNumOfOverflows++;
800065fe:	4b 59       	lddpc	r9,800066d0 <vTaskIncrementTick+0xf8>
80006600:	72 0a       	ld.w	r10,r9[0x0]
80006602:	2f fa       	sub	r10,-1
80006604:	93 0a       	st.w	r9[0x0],r10

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
80006606:	70 08       	ld.w	r8,r8[0x0]
80006608:	70 08       	ld.w	r8,r8[0x0]
8000660a:	58 08       	cp.w	r8,0
8000660c:	c0 51       	brne	80006616 <vTaskIncrementTick+0x3e>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
8000660e:	3f f9       	mov	r9,-1
80006610:	4b 18       	lddpc	r8,800066d4 <vTaskIncrementTick+0xfc>
80006612:	91 09       	st.w	r8[0x0],r9
80006614:	c0 88       	rjmp	80006624 <vTaskIncrementTick+0x4c>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
80006616:	4a d8       	lddpc	r8,800066c8 <vTaskIncrementTick+0xf0>
80006618:	70 08       	ld.w	r8,r8[0x0]
8000661a:	70 38       	ld.w	r8,r8[0xc]
8000661c:	70 38       	ld.w	r8,r8[0xc]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
8000661e:	70 19       	ld.w	r9,r8[0x4]
80006620:	4a d8       	lddpc	r8,800066d4 <vTaskIncrementTick+0xfc>
80006622:	91 09       	st.w	r8[0x0],r9
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
80006624:	4a 88       	lddpc	r8,800066c4 <vTaskIncrementTick+0xec>
80006626:	70 09       	ld.w	r9,r8[0x0]
80006628:	4a b8       	lddpc	r8,800066d4 <vTaskIncrementTick+0xfc>
8000662a:	70 08       	ld.w	r8,r8[0x0]
8000662c:	10 39       	cp.w	r9,r8
8000662e:	c4 73       	brcs	800066bc <vTaskIncrementTick+0xe4>
80006630:	4a 68       	lddpc	r8,800066c8 <vTaskIncrementTick+0xf0>
80006632:	70 08       	ld.w	r8,r8[0x0]
80006634:	70 08       	ld.w	r8,r8[0x0]
80006636:	58 08       	cp.w	r8,0
80006638:	c0 c0       	breq	80006650 <vTaskIncrementTick+0x78>
8000663a:	4a 48       	lddpc	r8,800066c8 <vTaskIncrementTick+0xf0>
8000663c:	70 08       	ld.w	r8,r8[0x0]
8000663e:	70 38       	ld.w	r8,r8[0xc]
80006640:	70 37       	ld.w	r7,r8[0xc]
80006642:	6e 18       	ld.w	r8,r7[0x4]
80006644:	4a 09       	lddpc	r9,800066c4 <vTaskIncrementTick+0xec>
80006646:	72 09       	ld.w	r9,r9[0x0]
80006648:	12 38       	cp.w	r8,r9
8000664a:	e0 88 00 14 	brls	80006672 <vTaskIncrementTick+0x9a>
8000664e:	c0 e8       	rjmp	8000666a <vTaskIncrementTick+0x92>
80006650:	3f f9       	mov	r9,-1
80006652:	4a 18       	lddpc	r8,800066d4 <vTaskIncrementTick+0xfc>
80006654:	91 09       	st.w	r8[0x0],r9
80006656:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
8000665a:	6a 08       	ld.w	r8,r5[0x0]
8000665c:	70 38       	ld.w	r8,r8[0xc]
8000665e:	70 37       	ld.w	r7,r8[0xc]
80006660:	6e 18       	ld.w	r8,r7[0x4]
80006662:	64 09       	ld.w	r9,r2[0x0]
80006664:	12 38       	cp.w	r8,r9
80006666:	e0 88 00 0a 	brls	8000667a <vTaskIncrementTick+0xa2>
8000666a:	49 b9       	lddpc	r9,800066d4 <vTaskIncrementTick+0xfc>
8000666c:	93 08       	st.w	r9[0x0],r8
8000666e:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80006672:	49 a4       	lddpc	r4,800066d8 <vTaskIncrementTick+0x100>
80006674:	49 a3       	lddpc	r3,800066dc <vTaskIncrementTick+0x104>
80006676:	49 55       	lddpc	r5,800066c8 <vTaskIncrementTick+0xf0>
80006678:	49 32       	lddpc	r2,800066c4 <vTaskIncrementTick+0xec>
8000667a:	ee c6 ff fc 	sub	r6,r7,-4
8000667e:	0c 9c       	mov	r12,r6
80006680:	f0 1f 00 18 	mcall	800066e0 <vTaskIncrementTick+0x108>
80006684:	6e a8       	ld.w	r8,r7[0x28]
80006686:	58 08       	cp.w	r8,0
80006688:	c0 50       	breq	80006692 <vTaskIncrementTick+0xba>
8000668a:	ee cc ff e8 	sub	r12,r7,-24
8000668e:	f0 1f 00 15 	mcall	800066e0 <vTaskIncrementTick+0x108>
80006692:	6e bc       	ld.w	r12,r7[0x2c]
80006694:	68 08       	ld.w	r8,r4[0x0]
80006696:	10 3c       	cp.w	r12,r8
80006698:	e9 fc ba 00 	st.whi	r4[0x0],r12
8000669c:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800066a0:	0c 9b       	mov	r11,r6
800066a2:	e6 0c 00 2c 	add	r12,r3,r12<<0x2
800066a6:	f0 1f 00 10 	mcall	800066e4 <vTaskIncrementTick+0x10c>
800066aa:	6a 08       	ld.w	r8,r5[0x0]
800066ac:	70 08       	ld.w	r8,r8[0x0]
800066ae:	58 08       	cp.w	r8,0
800066b0:	cd 51       	brne	8000665a <vTaskIncrementTick+0x82>
800066b2:	cc fb       	rjmp	80006650 <vTaskIncrementTick+0x78>
	}
	else
	{
		++uxMissedTicks;
800066b4:	48 d8       	lddpc	r8,800066e8 <vTaskIncrementTick+0x110>
800066b6:	70 09       	ld.w	r9,r8[0x0]
800066b8:	2f f9       	sub	r9,-1
800066ba:	91 09       	st.w	r8[0x0],r9
800066bc:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
800066c0:	00 00       	add	r0,r0
800066c2:	0d 08       	ld.w	r8,r6++
800066c4:	00 00       	add	r0,r0
800066c6:	0d 04       	ld.w	r4,r6++
800066c8:	00 00       	add	r0,r0
800066ca:	0c 10       	sub	r0,r6
800066cc:	00 00       	add	r0,r0
800066ce:	0c 20       	rsub	r0,r6
800066d0:	00 00       	add	r0,r0
800066d2:	0c 1c       	sub	r12,r6
800066d4:	00 00       	add	r0,r0
800066d6:	05 38       	ld.ub	r8,r2++
800066d8:	00 00       	add	r0,r0
800066da:	0d 40       	ld.w	r0,--r6
800066dc:	00 00       	add	r0,r0
800066de:	0c 24       	rsub	r4,r6
800066e0:	80 00       	ld.sh	r0,r0[0x0]
800066e2:	5b d6       	cp.w	r6,-3
800066e4:	80 00       	ld.sh	r0,r0[0x0]
800066e6:	5b 86       	cp.w	r6,-8
800066e8:	00 00       	add	r0,r0
800066ea:	0c 08       	add	r8,r6

800066ec <xTaskCheckForTimeOut>:
	pxTimeOut->xTimeOnEntering = xTickCount;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
800066ec:	eb cd 40 c0 	pushm	r6-r7,lr
800066f0:	18 97       	mov	r7,r12
800066f2:	16 96       	mov	r6,r11
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
800066f4:	f0 1f 00 15 	mcall	80006748 <xTaskCheckForTimeOut+0x5c>
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
800066f8:	6c 08       	ld.w	r8,r6[0x0]
800066fa:	5b f8       	cp.w	r8,-1
800066fc:	c0 31       	brne	80006702 <xTaskCheckForTimeOut+0x16>
800066fe:	30 07       	mov	r7,0
80006700:	c1 f8       	rjmp	8000673e <xTaskCheckForTimeOut+0x52>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
80006702:	49 39       	lddpc	r9,8000674c <xTaskCheckForTimeOut+0x60>
80006704:	72 09       	ld.w	r9,r9[0x0]
80006706:	6e 0a       	ld.w	r10,r7[0x0]
80006708:	12 3a       	cp.w	r10,r9
8000670a:	c0 70       	breq	80006718 <xTaskCheckForTimeOut+0x2c>
8000670c:	49 19       	lddpc	r9,80006750 <xTaskCheckForTimeOut+0x64>
8000670e:	72 09       	ld.w	r9,r9[0x0]
80006710:	6e 1a       	ld.w	r10,r7[0x4]
80006712:	12 3a       	cp.w	r10,r9
80006714:	e0 88 00 14 	brls	8000673c <xTaskCheckForTimeOut+0x50>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
80006718:	48 e9       	lddpc	r9,80006750 <xTaskCheckForTimeOut+0x64>
8000671a:	72 0a       	ld.w	r10,r9[0x0]
8000671c:	6e 19       	ld.w	r9,r7[0x4]
8000671e:	12 1a       	sub	r10,r9
80006720:	14 38       	cp.w	r8,r10
80006722:	e0 88 00 0d 	brls	8000673c <xTaskCheckForTimeOut+0x50>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
80006726:	48 ba       	lddpc	r10,80006750 <xTaskCheckForTimeOut+0x64>
80006728:	74 0a       	ld.w	r10,r10[0x0]
8000672a:	14 19       	sub	r9,r10
8000672c:	f2 08 00 08 	add	r8,r9,r8
80006730:	8d 08       	st.w	r6[0x0],r8
			vTaskSetTimeOutState( pxTimeOut );
80006732:	0e 9c       	mov	r12,r7
80006734:	f0 1f 00 08 	mcall	80006754 <xTaskCheckForTimeOut+0x68>
80006738:	30 07       	mov	r7,0
8000673a:	c0 28       	rjmp	8000673e <xTaskCheckForTimeOut+0x52>
8000673c:	30 17       	mov	r7,1
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
8000673e:	f0 1f 00 07 	mcall	80006758 <xTaskCheckForTimeOut+0x6c>

	return xReturn;
}
80006742:	0e 9c       	mov	r12,r7
80006744:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006748:	80 00       	ld.sh	r0,r0[0x0]
8000674a:	5c 90       	brev	r0
8000674c:	00 00       	add	r0,r0
8000674e:	0c 1c       	sub	r12,r6
80006750:	00 00       	add	r0,r0
80006752:	0d 04       	ld.w	r4,r6++
80006754:	80 00       	ld.sh	r0,r0[0x0]
80006756:	64 50       	ld.w	r0,r2[0x14]
80006758:	80 00       	ld.sh	r0,r0[0x0]
8000675a:	5d 9c       	*unknown*

8000675c <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
8000675c:	eb cd 40 80 	pushm	r7,lr
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
80006760:	f0 1f 00 05 	mcall	80006774 <xTaskGetTickCount+0x18>
	{
		xTicks = xTickCount;
80006764:	48 58       	lddpc	r8,80006778 <xTaskGetTickCount+0x1c>
80006766:	70 07       	ld.w	r7,r8[0x0]
	}
	taskEXIT_CRITICAL();
80006768:	f0 1f 00 05 	mcall	8000677c <xTaskGetTickCount+0x20>

	return xTicks;
}
8000676c:	0e 9c       	mov	r12,r7
8000676e:	e3 cd 80 80 	ldm	sp++,r7,pc
80006772:	00 00       	add	r0,r0
80006774:	80 00       	ld.sh	r0,r0[0x0]
80006776:	5c 90       	brev	r0
80006778:	00 00       	add	r0,r0
8000677a:	0d 04       	ld.w	r4,r6++
8000677c:	80 00       	ld.sh	r0,r0[0x0]
8000677e:	5d 9c       	*unknown*

80006780 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
80006780:	eb cd 40 fe 	pushm	r1-r7,lr
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
80006784:	f0 1f 00 2c 	mcall	80006834 <xTaskResumeAll+0xb4>
	{
		--uxSchedulerSuspended;
80006788:	4a c8       	lddpc	r8,80006838 <xTaskResumeAll+0xb8>
8000678a:	70 09       	ld.w	r9,r8[0x0]
8000678c:	20 19       	sub	r9,1
8000678e:	91 09       	st.w	r8[0x0],r9

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80006790:	70 08       	ld.w	r8,r8[0x0]
80006792:	58 08       	cp.w	r8,0
80006794:	c4 91       	brne	80006826 <xTaskResumeAll+0xa6>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
80006796:	4a a8       	lddpc	r8,8000683c <xTaskResumeAll+0xbc>
80006798:	70 08       	ld.w	r8,r8[0x0]
8000679a:	58 08       	cp.w	r8,0
8000679c:	c4 50       	breq	80006826 <xTaskResumeAll+0xa6>
8000679e:	30 04       	mov	r4,0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
800067a0:	4a 85       	lddpc	r5,80006840 <xTaskResumeAll+0xc0>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
800067a2:	4a 93       	lddpc	r3,80006844 <xTaskResumeAll+0xc4>
800067a4:	4a 92       	lddpc	r2,80006848 <xTaskResumeAll+0xc8>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
800067a6:	4a a1       	lddpc	r1,8000684c <xTaskResumeAll+0xcc>
800067a8:	c1 e8       	rjmp	800067e4 <xTaskResumeAll+0x64>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
800067aa:	6a 38       	ld.w	r8,r5[0xc]
800067ac:	70 37       	ld.w	r7,r8[0xc]
					vListRemove( &( pxTCB->xEventListItem ) );
800067ae:	ee cc ff e8 	sub	r12,r7,-24
800067b2:	f0 1f 00 28 	mcall	80006850 <xTaskResumeAll+0xd0>
					vListRemove( &( pxTCB->xGenericListItem ) );
800067b6:	ee c6 ff fc 	sub	r6,r7,-4
800067ba:	0c 9c       	mov	r12,r6
800067bc:	f0 1f 00 25 	mcall	80006850 <xTaskResumeAll+0xd0>
					prvAddTaskToReadyQueue( pxTCB );
800067c0:	6e bc       	ld.w	r12,r7[0x2c]
800067c2:	66 08       	ld.w	r8,r3[0x0]
800067c4:	10 3c       	cp.w	r12,r8
800067c6:	e7 fc ba 00 	st.whi	r3[0x0],r12
800067ca:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800067ce:	0c 9b       	mov	r11,r6
800067d0:	e4 0c 00 2c 	add	r12,r2,r12<<0x2
800067d4:	f0 1f 00 20 	mcall	80006854 <xTaskResumeAll+0xd4>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
800067d8:	62 08       	ld.w	r8,r1[0x0]
800067da:	6e b9       	ld.w	r9,r7[0x2c]
800067dc:	70 b8       	ld.w	r8,r8[0x2c]
800067de:	10 39       	cp.w	r9,r8
800067e0:	f9 b4 02 01 	movhs	r4,1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
800067e4:	6a 08       	ld.w	r8,r5[0x0]
800067e6:	58 08       	cp.w	r8,0
800067e8:	ce 11       	brne	800067aa <xTaskResumeAll+0x2a>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
800067ea:	49 c8       	lddpc	r8,80006858 <xTaskResumeAll+0xd8>
800067ec:	70 08       	ld.w	r8,r8[0x0]
800067ee:	58 08       	cp.w	r8,0
800067f0:	c0 f0       	breq	8000680e <xTaskResumeAll+0x8e>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
800067f2:	49 a8       	lddpc	r8,80006858 <xTaskResumeAll+0xd8>
800067f4:	70 08       	ld.w	r8,r8[0x0]
800067f6:	58 08       	cp.w	r8,0
800067f8:	c1 10       	breq	8000681a <xTaskResumeAll+0x9a>
					{
						vTaskIncrementTick();
						--uxMissedTicks;
800067fa:	49 87       	lddpc	r7,80006858 <xTaskResumeAll+0xd8>
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
800067fc:	f0 1f 00 18 	mcall	8000685c <xTaskResumeAll+0xdc>
						--uxMissedTicks;
80006800:	6e 08       	ld.w	r8,r7[0x0]
80006802:	20 18       	sub	r8,1
80006804:	8f 08       	st.w	r7[0x0],r8
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80006806:	6e 08       	ld.w	r8,r7[0x0]
80006808:	58 08       	cp.w	r8,0
8000680a:	cf 91       	brne	800067fc <xTaskResumeAll+0x7c>
8000680c:	c0 78       	rjmp	8000681a <xTaskResumeAll+0x9a>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
8000680e:	58 14       	cp.w	r4,1
80006810:	c0 50       	breq	8000681a <xTaskResumeAll+0x9a>
80006812:	49 48       	lddpc	r8,80006860 <xTaskResumeAll+0xe0>
80006814:	70 08       	ld.w	r8,r8[0x0]
80006816:	58 18       	cp.w	r8,1
80006818:	c0 71       	brne	80006826 <xTaskResumeAll+0xa6>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
8000681a:	30 09       	mov	r9,0
8000681c:	49 18       	lddpc	r8,80006860 <xTaskResumeAll+0xe0>
8000681e:	91 09       	st.w	r8[0x0],r9
					portYIELD_WITHIN_API();
80006820:	d7 33       	scall
80006822:	30 17       	mov	r7,1
80006824:	c0 28       	rjmp	80006828 <xTaskResumeAll+0xa8>
80006826:	30 07       	mov	r7,0
				}
			}
		}
	}
	taskEXIT_CRITICAL();
80006828:	f0 1f 00 0f 	mcall	80006864 <xTaskResumeAll+0xe4>

	return xAlreadyYielded;
}
8000682c:	0e 9c       	mov	r12,r7
8000682e:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
80006832:	00 00       	add	r0,r0
80006834:	80 00       	ld.sh	r0,r0[0x0]
80006836:	5c 90       	brev	r0
80006838:	00 00       	add	r0,r0
8000683a:	0d 08       	ld.w	r8,r6++
8000683c:	00 00       	add	r0,r0
8000683e:	0d 24       	ld.uh	r4,r6++
80006840:	00 00       	add	r0,r0
80006842:	0c dc       	st.w	--r6,r12
80006844:	00 00       	add	r0,r0
80006846:	0d 40       	ld.w	r0,--r6
80006848:	00 00       	add	r0,r0
8000684a:	0c 24       	rsub	r4,r6
8000684c:	00 00       	add	r0,r0
8000684e:	0c d8       	st.w	--r6,r8
80006850:	80 00       	ld.sh	r0,r0[0x0]
80006852:	5b d6       	cp.w	r6,-3
80006854:	80 00       	ld.sh	r0,r0[0x0]
80006856:	5b 86       	cp.w	r6,-8
80006858:	00 00       	add	r0,r0
8000685a:	0c 08       	add	r8,r6
8000685c:	80 00       	ld.sh	r0,r0[0x0]
8000685e:	65 d8       	ld.w	r8,r2[0x74]
80006860:	00 00       	add	r0,r0
80006862:	0d 28       	ld.uh	r8,r6++
80006864:	80 00       	ld.sh	r0,r0[0x0]
80006866:	5d 9c       	*unknown*

80006868 <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
80006868:	eb cd 40 80 	pushm	r7,lr
8000686c:	18 97       	mov	r7,r12
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
8000686e:	49 08       	lddpc	r8,800068ac <prvAddCurrentTaskToDelayedList+0x44>
80006870:	70 08       	ld.w	r8,r8[0x0]
80006872:	91 1c       	st.w	r8[0x4],r12

	if( xTimeToWake < xTickCount )
80006874:	48 f8       	lddpc	r8,800068b0 <prvAddCurrentTaskToDelayedList+0x48>
80006876:	70 08       	ld.w	r8,r8[0x0]
80006878:	10 3c       	cp.w	r12,r8
8000687a:	c0 a2       	brcc	8000688e <prvAddCurrentTaskToDelayedList+0x26>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
8000687c:	48 c8       	lddpc	r8,800068ac <prvAddCurrentTaskToDelayedList+0x44>
8000687e:	70 0b       	ld.w	r11,r8[0x0]
80006880:	48 d8       	lddpc	r8,800068b4 <prvAddCurrentTaskToDelayedList+0x4c>
80006882:	70 0c       	ld.w	r12,r8[0x0]
80006884:	2f cb       	sub	r11,-4
80006886:	f0 1f 00 0d 	mcall	800068b8 <prvAddCurrentTaskToDelayedList+0x50>
8000688a:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
8000688e:	48 88       	lddpc	r8,800068ac <prvAddCurrentTaskToDelayedList+0x44>
80006890:	70 0b       	ld.w	r11,r8[0x0]
80006892:	48 b8       	lddpc	r8,800068bc <prvAddCurrentTaskToDelayedList+0x54>
80006894:	70 0c       	ld.w	r12,r8[0x0]
80006896:	2f cb       	sub	r11,-4
80006898:	f0 1f 00 08 	mcall	800068b8 <prvAddCurrentTaskToDelayedList+0x50>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
8000689c:	48 98       	lddpc	r8,800068c0 <prvAddCurrentTaskToDelayedList+0x58>
8000689e:	70 08       	ld.w	r8,r8[0x0]
800068a0:	10 37       	cp.w	r7,r8
800068a2:	c0 32       	brcc	800068a8 <prvAddCurrentTaskToDelayedList+0x40>
		{
			xNextTaskUnblockTime = xTimeToWake;
800068a4:	48 78       	lddpc	r8,800068c0 <prvAddCurrentTaskToDelayedList+0x58>
800068a6:	91 07       	st.w	r8[0x0],r7
800068a8:	e3 cd 80 80 	ldm	sp++,r7,pc
800068ac:	00 00       	add	r0,r0
800068ae:	0c d8       	st.w	--r6,r8
800068b0:	00 00       	add	r0,r0
800068b2:	0d 04       	ld.w	r4,r6++
800068b4:	00 00       	add	r0,r0
800068b6:	0c 20       	rsub	r0,r6
800068b8:	80 00       	ld.sh	r0,r0[0x0]
800068ba:	5b a2       	cp.w	r2,-6
800068bc:	00 00       	add	r0,r0
800068be:	0c 10       	sub	r0,r6
800068c0:	00 00       	add	r0,r0
800068c2:	05 38       	ld.ub	r8,r2++

800068c4 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
800068c4:	eb cd 40 c0 	pushm	r6-r7,lr
800068c8:	18 97       	mov	r7,r12
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0 )
800068ca:	58 0c       	cp.w	r12,0
800068cc:	c1 10       	breq	800068ee <vTaskDelay+0x2a>
		{
			vTaskSuspendAll();
800068ce:	f0 1f 00 0a 	mcall	800068f4 <vTaskDelay+0x30>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
800068d2:	48 a8       	lddpc	r8,800068f8 <vTaskDelay+0x34>
800068d4:	70 06       	ld.w	r6,r8[0x0]

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800068d6:	48 a8       	lddpc	r8,800068fc <vTaskDelay+0x38>
800068d8:	70 0c       	ld.w	r12,r8[0x0]
800068da:	2f cc       	sub	r12,-4
800068dc:	f0 1f 00 09 	mcall	80006900 <vTaskDelay+0x3c>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
800068e0:	ee 06 00 0c 	add	r12,r7,r6
800068e4:	f0 1f 00 08 	mcall	80006904 <vTaskDelay+0x40>
			}
			xAlreadyYielded = xTaskResumeAll();
800068e8:	f0 1f 00 08 	mcall	80006908 <vTaskDelay+0x44>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
800068ec:	c0 21       	brne	800068f0 <vTaskDelay+0x2c>
		{
			portYIELD_WITHIN_API();
800068ee:	d7 33       	scall
800068f0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800068f4:	80 00       	ld.sh	r0,r0[0x0]
800068f6:	63 c4       	ld.w	r4,r1[0x70]
800068f8:	00 00       	add	r0,r0
800068fa:	0d 04       	ld.w	r4,r6++
800068fc:	00 00       	add	r0,r0
800068fe:	0c d8       	st.w	--r6,r8
80006900:	80 00       	ld.sh	r0,r0[0x0]
80006902:	5b d6       	cp.w	r6,-3
80006904:	80 00       	ld.sh	r0,r0[0x0]
80006906:	68 68       	ld.w	r8,r4[0x18]
80006908:	80 00       	ld.sh	r0,r0[0x0]
8000690a:	67 80       	ld.w	r0,r3[0x60]

8000690c <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
8000690c:	eb cd 40 c0 	pushm	r6-r7,lr
80006910:	18 96       	mov	r6,r12
80006912:	16 97       	mov	r7,r11
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0 ) );

		vTaskSuspendAll();
80006914:	f0 1f 00 18 	mcall	80006974 <vTaskDelayUntil+0x68>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
80006918:	6c 08       	ld.w	r8,r6[0x0]
8000691a:	10 07       	add	r7,r8

			if( xTickCount < *pxPreviousWakeTime )
8000691c:	49 79       	lddpc	r9,80006978 <vTaskDelayUntil+0x6c>
8000691e:	72 09       	ld.w	r9,r9[0x0]
80006920:	12 38       	cp.w	r8,r9
80006922:	e0 88 00 0c 	brls	8000693a <vTaskDelayUntil+0x2e>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
80006926:	0e 38       	cp.w	r8,r7
80006928:	e0 88 00 22 	brls	8000696c <vTaskDelayUntil+0x60>
8000692c:	49 38       	lddpc	r8,80006978 <vTaskDelayUntil+0x6c>
8000692e:	70 08       	ld.w	r8,r8[0x0]
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80006930:	8d 07       	st.w	r6[0x0],r7

			if( xShouldDelay != pdFALSE )
80006932:	10 37       	cp.w	r7,r8
80006934:	e0 88 00 14 	brls	8000695c <vTaskDelayUntil+0x50>
80006938:	c0 a8       	rjmp	8000694c <vTaskDelayUntil+0x40>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
8000693a:	0e 38       	cp.w	r8,r7
8000693c:	e0 8b 00 16 	brhi	80006968 <vTaskDelayUntil+0x5c>
80006940:	48 e8       	lddpc	r8,80006978 <vTaskDelayUntil+0x6c>
80006942:	70 08       	ld.w	r8,r8[0x0]
80006944:	10 37       	cp.w	r7,r8
80006946:	e0 8b 00 11 	brhi	80006968 <vTaskDelayUntil+0x5c>
8000694a:	c1 18       	rjmp	8000696c <vTaskDelayUntil+0x60>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
8000694c:	48 c8       	lddpc	r8,8000697c <vTaskDelayUntil+0x70>
8000694e:	70 0c       	ld.w	r12,r8[0x0]
80006950:	2f cc       	sub	r12,-4
80006952:	f0 1f 00 0c 	mcall	80006980 <vTaskDelayUntil+0x74>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
80006956:	0e 9c       	mov	r12,r7
80006958:	f0 1f 00 0b 	mcall	80006984 <vTaskDelayUntil+0x78>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
8000695c:	f0 1f 00 0b 	mcall	80006988 <vTaskDelayUntil+0x7c>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
80006960:	c0 81       	brne	80006970 <vTaskDelayUntil+0x64>
		{
			portYIELD_WITHIN_API();
80006962:	d7 33       	scall
80006964:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80006968:	8d 07       	st.w	r6[0x0],r7
8000696a:	cf 1b       	rjmp	8000694c <vTaskDelayUntil+0x40>
8000696c:	8d 07       	st.w	r6[0x0],r7
8000696e:	cf 7b       	rjmp	8000695c <vTaskDelayUntil+0x50>
80006970:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006974:	80 00       	ld.sh	r0,r0[0x0]
80006976:	63 c4       	ld.w	r4,r1[0x70]
80006978:	00 00       	add	r0,r0
8000697a:	0d 04       	ld.w	r4,r6++
8000697c:	00 00       	add	r0,r0
8000697e:	0c d8       	st.w	--r6,r8
80006980:	80 00       	ld.sh	r0,r0[0x0]
80006982:	5b d6       	cp.w	r6,-3
80006984:	80 00       	ld.sh	r0,r0[0x0]
80006986:	68 68       	ld.w	r8,r4[0x18]
80006988:	80 00       	ld.sh	r0,r0[0x0]
8000698a:	67 80       	ld.w	r0,r3[0x60]

8000698c <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
8000698c:	eb cd 40 c0 	pushm	r6-r7,lr
80006990:	16 96       	mov	r6,r11
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
80006992:	48 e7       	lddpc	r7,800069c8 <vTaskPlaceOnEventList+0x3c>
80006994:	6e 0b       	ld.w	r11,r7[0x0]
80006996:	2e 8b       	sub	r11,-24
80006998:	f0 1f 00 0d 	mcall	800069cc <vTaskPlaceOnEventList+0x40>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
8000699c:	6e 0c       	ld.w	r12,r7[0x0]
8000699e:	2f cc       	sub	r12,-4
800069a0:	f0 1f 00 0c 	mcall	800069d0 <vTaskPlaceOnEventList+0x44>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
800069a4:	5b f6       	cp.w	r6,-1
800069a6:	c0 81       	brne	800069b6 <vTaskPlaceOnEventList+0x2a>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800069a8:	6e 0b       	ld.w	r11,r7[0x0]
800069aa:	2f cb       	sub	r11,-4
800069ac:	48 ac       	lddpc	r12,800069d4 <vTaskPlaceOnEventList+0x48>
800069ae:	f0 1f 00 0b 	mcall	800069d8 <vTaskPlaceOnEventList+0x4c>
800069b2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
800069b6:	48 a8       	lddpc	r8,800069dc <vTaskPlaceOnEventList+0x50>
800069b8:	70 0c       	ld.w	r12,r8[0x0]
			prvAddCurrentTaskToDelayedList( xTimeToWake );
800069ba:	ec 0c 00 0c 	add	r12,r6,r12
800069be:	f0 1f 00 09 	mcall	800069e0 <vTaskPlaceOnEventList+0x54>
800069c2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800069c6:	00 00       	add	r0,r0
800069c8:	00 00       	add	r0,r0
800069ca:	0c d8       	st.w	--r6,r8
800069cc:	80 00       	ld.sh	r0,r0[0x0]
800069ce:	5b a2       	cp.w	r2,-6
800069d0:	80 00       	ld.sh	r0,r0[0x0]
800069d2:	5b d6       	cp.w	r6,-3
800069d4:	00 00       	add	r0,r0
800069d6:	0d 2c       	ld.uh	r12,r6++
800069d8:	80 00       	ld.sh	r0,r0[0x0]
800069da:	5b 86       	cp.w	r6,-8
800069dc:	00 00       	add	r0,r0
800069de:	0d 04       	ld.w	r4,r6++
800069e0:	80 00       	ld.sh	r0,r0[0x0]
800069e2:	68 68       	ld.w	r8,r4[0x18]

800069e4 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
800069e4:	eb cd 40 f8 	pushm	r3-r7,lr
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
800069e8:	49 67       	lddpc	r7,80006a40 <prvIdleTask+0x5c>
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
800069ea:	49 74       	lddpc	r4,80006a44 <prvIdleTask+0x60>

				taskENTER_CRITICAL();
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					--uxCurrentNumberOfTasks;
800069ec:	49 73       	lddpc	r3,80006a48 <prvIdleTask+0x64>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
800069ee:	49 85       	lddpc	r5,80006a4c <prvIdleTask+0x68>
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
800069f0:	6e 08       	ld.w	r8,r7[0x0]
800069f2:	58 08       	cp.w	r8,0
800069f4:	c1 e0       	breq	80006a30 <prvIdleTask+0x4c>
		{
			vTaskSuspendAll();
800069f6:	f0 1f 00 17 	mcall	80006a50 <prvIdleTask+0x6c>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
800069fa:	68 06       	ld.w	r6,r4[0x0]
			xTaskResumeAll();
800069fc:	f0 1f 00 16 	mcall	80006a54 <prvIdleTask+0x70>

			if( xListIsEmpty == pdFALSE )
80006a00:	58 06       	cp.w	r6,0
80006a02:	c1 70       	breq	80006a30 <prvIdleTask+0x4c>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
80006a04:	f0 1f 00 15 	mcall	80006a58 <prvIdleTask+0x74>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
80006a08:	68 38       	ld.w	r8,r4[0xc]
80006a0a:	70 36       	ld.w	r6,r8[0xc]
					vListRemove( &( pxTCB->xGenericListItem ) );
80006a0c:	ec cc ff fc 	sub	r12,r6,-4
80006a10:	f0 1f 00 13 	mcall	80006a5c <prvIdleTask+0x78>
					--uxCurrentNumberOfTasks;
80006a14:	66 08       	ld.w	r8,r3[0x0]
80006a16:	20 18       	sub	r8,1
80006a18:	87 08       	st.w	r3[0x0],r8
					--uxTasksDeleted;
80006a1a:	6e 08       	ld.w	r8,r7[0x0]
80006a1c:	20 18       	sub	r8,1
80006a1e:	8f 08       	st.w	r7[0x0],r8
				}
				taskEXIT_CRITICAL();
80006a20:	f0 1f 00 10 	mcall	80006a60 <prvIdleTask+0x7c>

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
80006a24:	6c cc       	ld.w	r12,r6[0x30]
80006a26:	f0 1f 00 10 	mcall	80006a64 <prvIdleTask+0x80>
		vPortFree( pxTCB );
80006a2a:	0c 9c       	mov	r12,r6
80006a2c:	f0 1f 00 0e 	mcall	80006a64 <prvIdleTask+0x80>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80006a30:	6a 08       	ld.w	r8,r5[0x0]
80006a32:	58 18       	cp.w	r8,1
80006a34:	e0 88 00 03 	brls	80006a3a <prvIdleTask+0x56>
			{
				taskYIELD();
80006a38:	d7 33       	scall
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
80006a3a:	f0 1f 00 0c 	mcall	80006a68 <prvIdleTask+0x84>
		}
		#endif
	}
80006a3e:	cd 9b       	rjmp	800069f0 <prvIdleTask+0xc>
80006a40:	00 00       	add	r0,r0
80006a42:	0c 18       	sub	r8,r6
80006a44:	00 00       	add	r0,r0
80006a46:	0c c4       	st.b	r6++,r4
80006a48:	00 00       	add	r0,r0
80006a4a:	0d 24       	ld.uh	r4,r6++
80006a4c:	00 00       	add	r0,r0
80006a4e:	0c 24       	rsub	r4,r6
80006a50:	80 00       	ld.sh	r0,r0[0x0]
80006a52:	63 c4       	ld.w	r4,r1[0x70]
80006a54:	80 00       	ld.sh	r0,r0[0x0]
80006a56:	67 80       	ld.w	r0,r3[0x60]
80006a58:	80 00       	ld.sh	r0,r0[0x0]
80006a5a:	5c 90       	brev	r0
80006a5c:	80 00       	ld.sh	r0,r0[0x0]
80006a5e:	5b d6       	cp.w	r6,-3
80006a60:	80 00       	ld.sh	r0,r0[0x0]
80006a62:	5d 9c       	*unknown*
80006a64:	80 00       	ld.sh	r0,r0[0x0]
80006a66:	5e d4       	retvc	r4
80006a68:	80 00       	ld.sh	r0,r0[0x0]
80006a6a:	20 2c       	sub	r12,2

80006a6c <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
80006a6c:	d4 31       	pushm	r0-r7,lr
80006a6e:	20 1d       	sub	sp,4
80006a70:	fa c4 ff d8 	sub	r4,sp,-40
80006a74:	50 0c       	stdsp	sp[0x0],r12
80006a76:	16 91       	mov	r1,r11
80006a78:	14 97       	mov	r7,r10
80006a7a:	12 90       	mov	r0,r9
80006a7c:	10 93       	mov	r3,r8
80006a7e:	68 02       	ld.w	r2,r4[0x0]
80006a80:	68 16       	ld.w	r6,r4[0x4]
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
80006a82:	34 8c       	mov	r12,72
80006a84:	f0 1f 00 5c 	mcall	80006bf4 <xTaskGenericCreate+0x188>
80006a88:	18 95       	mov	r5,r12

	if( pxNewTCB != NULL )
80006a8a:	c0 31       	brne	80006a90 <xTaskGenericCreate+0x24>
80006a8c:	3f fc       	mov	r12,-1
80006a8e:	ca f8       	rjmp	80006bec <xTaskGenericCreate+0x180>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80006a90:	58 06       	cp.w	r6,0
80006a92:	e0 81 00 af 	brne	80006bf0 <xTaskGenericCreate+0x184>
80006a96:	0e 9c       	mov	r12,r7
80006a98:	5c 7c       	castu.h	r12
80006a9a:	a3 6c       	lsl	r12,0x2
80006a9c:	f0 1f 00 56 	mcall	80006bf4 <xTaskGenericCreate+0x188>
80006aa0:	18 96       	mov	r6,r12
80006aa2:	8b cc       	st.w	r5[0x30],r12

		if( pxNewTCB->pxStack == NULL )
80006aa4:	c0 61       	brne	80006ab0 <xTaskGenericCreate+0x44>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
80006aa6:	0a 9c       	mov	r12,r5
80006aa8:	f0 1f 00 54 	mcall	80006bf8 <xTaskGenericCreate+0x18c>
80006aac:	3f fc       	mov	r12,-1
80006aae:	c9 f8       	rjmp	80006bec <xTaskGenericCreate+0x180>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
80006ab0:	5c 77       	castu.h	r7
80006ab2:	ee 0a 15 02 	lsl	r10,r7,0x2
80006ab6:	e0 6b 00 a5 	mov	r11,165
80006aba:	0c 9c       	mov	r12,r6
80006abc:	f0 1f 00 50 	mcall	80006bfc <xTaskGenericCreate+0x190>
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~portBYTE_ALIGNMENT_MASK  ) );
80006ac0:	ee c6 00 01 	sub	r6,r7,1
80006ac4:	6a c8       	ld.w	r8,r5[0x30]
80006ac6:	f0 06 00 26 	add	r6,r8,r6<<0x2
80006aca:	e0 16 ff fc 	andl	r6,0xfffc
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
80006ace:	31 0a       	mov	r10,16
80006ad0:	02 9b       	mov	r11,r1
80006ad2:	ea cc ff cc 	sub	r12,r5,-52
80006ad6:	f0 1f 00 4b 	mcall	80006c00 <xTaskGenericCreate+0x194>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
80006ada:	30 08       	mov	r8,0
80006adc:	eb 68 00 43 	st.b	r5[67],r8
80006ae0:	58 73       	cp.w	r3,7
80006ae2:	e6 07 17 80 	movls	r7,r3
80006ae6:	f9 b7 0b 07 	movhi	r7,7
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
80006aea:	8b b7       	st.w	r5[0x2c],r7
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
80006aec:	eb 47 00 44 	st.w	r5[68],r7
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
80006af0:	ea c4 ff fc 	sub	r4,r5,-4
80006af4:	08 9c       	mov	r12,r4
80006af6:	f0 1f 00 44 	mcall	80006c04 <xTaskGenericCreate+0x198>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
80006afa:	ea cc ff e8 	sub	r12,r5,-24
80006afe:	f0 1f 00 42 	mcall	80006c04 <xTaskGenericCreate+0x198>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
80006b02:	8b 45       	st.w	r5[0x10],r5

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
80006b04:	ee 07 11 08 	rsub	r7,r7,8
80006b08:	8b 67       	st.w	r5[0x18],r7
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
80006b0a:	8b 95       	st.w	r5[0x24],r5
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
80006b0c:	00 9a       	mov	r10,r0
80006b0e:	40 0b       	lddsp	r11,sp[0x0]
80006b10:	0c 9c       	mov	r12,r6
80006b12:	f0 1f 00 3e 	mcall	80006c08 <xTaskGenericCreate+0x19c>
80006b16:	8b 0c       	st.w	r5[0x0],r12
		if( ( void * ) pxCreatedTask != NULL )
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
80006b18:	58 02       	cp.w	r2,0
80006b1a:	e5 f5 1a 00 	st.wne	r2[0x0],r5
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
80006b1e:	f0 1f 00 3c 	mcall	80006c0c <xTaskGenericCreate+0x1a0>
		{
			uxCurrentNumberOfTasks++;
80006b22:	4b c8       	lddpc	r8,80006c10 <xTaskGenericCreate+0x1a4>
80006b24:	70 09       	ld.w	r9,r8[0x0]
80006b26:	2f f9       	sub	r9,-1
80006b28:	91 09       	st.w	r8[0x0],r9
			if( pxCurrentTCB == NULL )
80006b2a:	4b b8       	lddpc	r8,80006c14 <xTaskGenericCreate+0x1a8>
80006b2c:	70 08       	ld.w	r8,r8[0x0]
80006b2e:	58 08       	cp.w	r8,0
80006b30:	c2 61       	brne	80006b7c <xTaskGenericCreate+0x110>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
80006b32:	4b 98       	lddpc	r8,80006c14 <xTaskGenericCreate+0x1a8>
80006b34:	91 05       	st.w	r8[0x0],r5

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
80006b36:	4b 78       	lddpc	r8,80006c10 <xTaskGenericCreate+0x1a4>
80006b38:	70 08       	ld.w	r8,r8[0x0]
80006b3a:	58 18       	cp.w	r8,1
80006b3c:	c2 b1       	brne	80006b92 <xTaskGenericCreate+0x126>
80006b3e:	4b 77       	lddpc	r7,80006c18 <xTaskGenericCreate+0x1ac>

/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
80006b40:	ee c6 ff 60 	sub	r6,r7,-160
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
80006b44:	0e 9c       	mov	r12,r7
80006b46:	f0 1f 00 36 	mcall	80006c1c <xTaskGenericCreate+0x1b0>
80006b4a:	2e c7       	sub	r7,-20

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
80006b4c:	0c 37       	cp.w	r7,r6
80006b4e:	cf b1       	brne	80006b44 <xTaskGenericCreate+0xd8>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
80006b50:	4b 47       	lddpc	r7,80006c20 <xTaskGenericCreate+0x1b4>
80006b52:	0e 9c       	mov	r12,r7
80006b54:	f0 1f 00 32 	mcall	80006c1c <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
80006b58:	4b 36       	lddpc	r6,80006c24 <xTaskGenericCreate+0x1b8>
80006b5a:	0c 9c       	mov	r12,r6
80006b5c:	f0 1f 00 30 	mcall	80006c1c <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xPendingReadyList );
80006b60:	4b 2c       	lddpc	r12,80006c28 <xTaskGenericCreate+0x1bc>
80006b62:	f0 1f 00 2f 	mcall	80006c1c <xTaskGenericCreate+0x1b0>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
80006b66:	4b 2c       	lddpc	r12,80006c2c <xTaskGenericCreate+0x1c0>
80006b68:	f0 1f 00 2d 	mcall	80006c1c <xTaskGenericCreate+0x1b0>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
80006b6c:	4b 1c       	lddpc	r12,80006c30 <xTaskGenericCreate+0x1c4>
80006b6e:	f0 1f 00 2c 	mcall	80006c1c <xTaskGenericCreate+0x1b0>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
80006b72:	4b 18       	lddpc	r8,80006c34 <xTaskGenericCreate+0x1c8>
80006b74:	91 07       	st.w	r8[0x0],r7
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
80006b76:	4b 18       	lddpc	r8,80006c38 <xTaskGenericCreate+0x1cc>
80006b78:	91 06       	st.w	r8[0x0],r6
80006b7a:	c0 c8       	rjmp	80006b92 <xTaskGenericCreate+0x126>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
80006b7c:	4b 08       	lddpc	r8,80006c3c <xTaskGenericCreate+0x1d0>
80006b7e:	70 08       	ld.w	r8,r8[0x0]
80006b80:	58 08       	cp.w	r8,0
80006b82:	c0 81       	brne	80006b92 <xTaskGenericCreate+0x126>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
80006b84:	4a 48       	lddpc	r8,80006c14 <xTaskGenericCreate+0x1a8>
80006b86:	70 08       	ld.w	r8,r8[0x0]
80006b88:	70 b8       	ld.w	r8,r8[0x2c]
80006b8a:	10 33       	cp.w	r3,r8
80006b8c:	c0 33       	brcs	80006b92 <xTaskGenericCreate+0x126>
					{
						pxCurrentTCB = pxNewTCB;
80006b8e:	4a 28       	lddpc	r8,80006c14 <xTaskGenericCreate+0x1a8>
80006b90:	91 05       	st.w	r8[0x0],r5
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
80006b92:	6a b8       	ld.w	r8,r5[0x2c]
80006b94:	4a b9       	lddpc	r9,80006c40 <xTaskGenericCreate+0x1d4>
80006b96:	72 09       	ld.w	r9,r9[0x0]
80006b98:	12 38       	cp.w	r8,r9
80006b9a:	e0 88 00 04 	brls	80006ba2 <xTaskGenericCreate+0x136>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
80006b9e:	4a 99       	lddpc	r9,80006c40 <xTaskGenericCreate+0x1d4>
80006ba0:	93 08       	st.w	r9[0x0],r8
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
80006ba2:	4a 98       	lddpc	r8,80006c44 <xTaskGenericCreate+0x1d8>
80006ba4:	70 09       	ld.w	r9,r8[0x0]
80006ba6:	2f f9       	sub	r9,-1
80006ba8:	91 09       	st.w	r8[0x0],r9

			prvAddTaskToReadyQueue( pxNewTCB );
80006baa:	6a b8       	ld.w	r8,r5[0x2c]
80006bac:	4a 79       	lddpc	r9,80006c48 <xTaskGenericCreate+0x1dc>
80006bae:	72 09       	ld.w	r9,r9[0x0]
80006bb0:	12 38       	cp.w	r8,r9
80006bb2:	e0 88 00 04 	brls	80006bba <xTaskGenericCreate+0x14e>
80006bb6:	4a 59       	lddpc	r9,80006c48 <xTaskGenericCreate+0x1dc>
80006bb8:	93 08       	st.w	r9[0x0],r8
80006bba:	6a bc       	ld.w	r12,r5[0x2c]
80006bbc:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006bc0:	08 9b       	mov	r11,r4
80006bc2:	49 68       	lddpc	r8,80006c18 <xTaskGenericCreate+0x1ac>
80006bc4:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80006bc8:	f0 1f 00 21 	mcall	80006c4c <xTaskGenericCreate+0x1e0>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
80006bcc:	f0 1f 00 21 	mcall	80006c50 <xTaskGenericCreate+0x1e4>
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
80006bd0:	49 b8       	lddpc	r8,80006c3c <xTaskGenericCreate+0x1d0>
80006bd2:	70 08       	ld.w	r8,r8[0x0]
80006bd4:	58 08       	cp.w	r8,0
80006bd6:	c0 a0       	breq	80006bea <xTaskGenericCreate+0x17e>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
80006bd8:	48 f8       	lddpc	r8,80006c14 <xTaskGenericCreate+0x1a8>
80006bda:	70 08       	ld.w	r8,r8[0x0]
80006bdc:	70 b8       	ld.w	r8,r8[0x2c]
80006bde:	10 33       	cp.w	r3,r8
80006be0:	e0 88 00 05 	brls	80006bea <xTaskGenericCreate+0x17e>
			{
				portYIELD_WITHIN_API();
80006be4:	d7 33       	scall
80006be6:	30 1c       	mov	r12,1
80006be8:	c0 28       	rjmp	80006bec <xTaskGenericCreate+0x180>
80006bea:	30 1c       	mov	r12,1
			}
		}
	}

	return xReturn;
}
80006bec:	2f fd       	sub	sp,-4
80006bee:	d8 32       	popm	r0-r7,pc
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80006bf0:	99 c6       	st.w	r12[0x30],r6
80006bf2:	c5 fb       	rjmp	80006ab0 <xTaskGenericCreate+0x44>
80006bf4:	80 00       	ld.sh	r0,r0[0x0]
80006bf6:	5e fc       	retal	r12
80006bf8:	80 00       	ld.sh	r0,r0[0x0]
80006bfa:	5e d4       	retvc	r4
80006bfc:	80 00       	ld.sh	r0,r0[0x0]
80006bfe:	77 f8       	ld.w	r8,r11[0x7c]
80006c00:	80 00       	ld.sh	r0,r0[0x0]
80006c02:	7b 24       	ld.w	r4,sp[0x48]
80006c04:	80 00       	ld.sh	r0,r0[0x0]
80006c06:	5b 80       	cp.w	r0,-8
80006c08:	80 00       	ld.sh	r0,r0[0x0]
80006c0a:	5b fc       	cp.w	r12,-1
80006c0c:	80 00       	ld.sh	r0,r0[0x0]
80006c0e:	5c 90       	brev	r0
80006c10:	00 00       	add	r0,r0
80006c12:	0d 24       	ld.uh	r4,r6++
80006c14:	00 00       	add	r0,r0
80006c16:	0c d8       	st.w	--r6,r8
80006c18:	00 00       	add	r0,r0
80006c1a:	0c 24       	rsub	r4,r6
80006c1c:	80 00       	ld.sh	r0,r0[0x0]
80006c1e:	5b 6c       	cp.w	r12,-10
80006c20:	00 00       	add	r0,r0
80006c22:	0c f0       	st.b	--r6,r0
80006c24:	00 00       	add	r0,r0
80006c26:	0d 0c       	ld.w	r12,r6++
80006c28:	00 00       	add	r0,r0
80006c2a:	0c dc       	st.w	--r6,r12
80006c2c:	00 00       	add	r0,r0
80006c2e:	0c c4       	st.b	r6++,r4
80006c30:	00 00       	add	r0,r0
80006c32:	0d 2c       	ld.uh	r12,r6++
80006c34:	00 00       	add	r0,r0
80006c36:	0c 10       	sub	r0,r6
80006c38:	00 00       	add	r0,r0
80006c3a:	0c 20       	rsub	r0,r6
80006c3c:	00 00       	add	r0,r0
80006c3e:	0c 14       	sub	r4,r6
80006c40:	00 00       	add	r0,r0
80006c42:	0c 0c       	add	r12,r6
80006c44:	00 00       	add	r0,r0
80006c46:	0d 20       	ld.uh	r0,r6++
80006c48:	00 00       	add	r0,r0
80006c4a:	0d 40       	ld.w	r0,--r6
80006c4c:	80 00       	ld.sh	r0,r0[0x0]
80006c4e:	5b 86       	cp.w	r6,-8
80006c50:	80 00       	ld.sh	r0,r0[0x0]
80006c52:	5d 9c       	*unknown*

80006c54 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
80006c54:	d4 01       	pushm	lr
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
80006c56:	30 09       	mov	r9,0
80006c58:	1a d9       	st.w	--sp,r9
80006c5a:	1a d9       	st.w	--sp,r9
80006c5c:	1a d9       	st.w	--sp,r9
80006c5e:	12 98       	mov	r8,r9
80006c60:	e0 6a 01 00 	mov	r10,256
80006c64:	48 9b       	lddpc	r11,80006c88 <vTaskStartScheduler+0x34>
80006c66:	48 ac       	lddpc	r12,80006c8c <vTaskStartScheduler+0x38>
80006c68:	f0 1f 00 0a 	mcall	80006c90 <vTaskStartScheduler+0x3c>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
80006c6c:	2f dd       	sub	sp,-12
80006c6e:	58 1c       	cp.w	r12,1
80006c70:	c0 a1       	brne	80006c84 <vTaskStartScheduler+0x30>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
80006c72:	d3 03       	ssrf	0x10

		xSchedulerRunning = pdTRUE;
80006c74:	30 19       	mov	r9,1
80006c76:	48 88       	lddpc	r8,80006c94 <vTaskStartScheduler+0x40>
80006c78:	91 09       	st.w	r8[0x0],r9
		xTickCount = ( portTickType ) 0;
80006c7a:	30 09       	mov	r9,0
80006c7c:	48 78       	lddpc	r8,80006c98 <vTaskStartScheduler+0x44>
80006c7e:	91 09       	st.w	r8[0x0],r9
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
80006c80:	f0 1f 00 07 	mcall	80006c9c <vTaskStartScheduler+0x48>
80006c84:	d8 02       	popm	pc
80006c86:	00 00       	add	r0,r0
80006c88:	80 00       	ld.sh	r0,r0[0x0]
80006c8a:	d6 dc       	*unknown*
80006c8c:	80 00       	ld.sh	r0,r0[0x0]
80006c8e:	69 e4       	ld.w	r4,r4[0x78]
80006c90:	80 00       	ld.sh	r0,r0[0x0]
80006c92:	6a 6c       	ld.w	r12,r5[0x18]
80006c94:	00 00       	add	r0,r0
80006c96:	0c 14       	sub	r4,r6
80006c98:	00 00       	add	r0,r0
80006c9a:	0d 04       	ld.w	r4,r6++
80006c9c:	80 00       	ld.sh	r0,r0[0x0]
80006c9e:	5c a0       	swap.h	r0

80006ca0 <PrintChar>:
	
static void task_log(void * pvParameters);

char *  PrintChar(char c, char * str)
{
	*str++ = c;
80006ca0:	16 cc       	st.b	r11++,r12
	return str;
}
80006ca2:	5e fb       	retal	r11

80006ca4 <PrintHex>:
	
	return str;
}

char * PrintHex(int i,char len, char * str)
{
80006ca4:	eb cd 40 c0 	pushm	r6-r7,lr
80006ca8:	20 3d       	sub	sp,12
80006caa:	18 98       	mov	r8,r12
	char * p = str;
	char s[12];
	memset(s, 0 , 12);
80006cac:	30 06       	mov	r6,0
80006cae:	30 07       	mov	r7,0
80006cb0:	fa e7 00 00 	st.d	sp[0],r6
80006cb4:	30 0c       	mov	r12,0
80006cb6:	50 2c       	stdsp	sp[0x8],r12
	int cnt=0;
	
	if(i)
80006cb8:	58 08       	cp.w	r8,0
80006cba:	c1 30       	breq	80006ce0 <PrintHex+0x3c>
80006cbc:	18 99       	mov	r9,r12
	while(i)
	{
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
80006cbe:	1a 9c       	mov	r12,sp
80006cc0:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80006cc4:	58 9e       	cp.w	lr,9
80006cc6:	e0 8a 00 04 	brle	80006cce <PrintHex+0x2a>
80006cca:	2c 9e       	sub	lr,-55
80006ccc:	c0 48       	rjmp	80006cd4 <PrintHex+0x30>
80006cce:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80006cd2:	2d 0e       	sub	lr,-48
80006cd4:	f8 09 0b 0e 	st.b	r12[r9],lr
80006cd8:	2f f9       	sub	r9,-1
		i = (i >> 4 ) & 0x0FFFFFFF;
80006cda:	a5 88       	lsr	r8,0x4
	char s[12];
	memset(s, 0 , 12);
	int cnt=0;
	
	if(i)
	while(i)
80006cdc:	cf 21       	brne	80006cc0 <PrintHex+0x1c>
80006cde:	c0 48       	rjmp	80006ce6 <PrintHex+0x42>
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
		i = (i >> 4 ) & 0x0FFFFFFF;
		//i >>= 4
	}
	else
	s[cnt++] = '0';
80006ce0:	33 08       	mov	r8,48
80006ce2:	ba 88       	st.b	sp[0x0],r8
80006ce4:	30 19       	mov	r9,1
	
	if(len - cnt > 0 )
80006ce6:	f6 09 01 08 	sub	r8,r11,r9
80006cea:	58 08       	cp.w	r8,0
80006cec:	e0 8a 00 13 	brle	80006d12 <PrintHex+0x6e>
	{
		char num = len - cnt;
80006cf0:	12 1b       	sub	r11,r9
80006cf2:	f9 db c0 08 	bfextu	r12,r11,0x0,0x8
		for(int i = 0; i < num; i++)
80006cf6:	18 9e       	mov	lr,r12
80006cf8:	58 0c       	cp.w	r12,0
80006cfa:	e0 8a 00 0c 	brle	80006d12 <PrintHex+0x6e>
80006cfe:	1a 9b       	mov	r11,sp
80006d00:	12 0b       	add	r11,r9
80006d02:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80006d04:	33 07       	mov	r7,48
80006d06:	16 c7       	st.b	r11++,r7
	s[cnt++] = '0';
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80006d08:	2f f8       	sub	r8,-1
80006d0a:	1c 38       	cp.w	r8,lr
80006d0c:	cf d5       	brlt	80006d06 <PrintHex+0x62>
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
80006d0e:	f8 09 00 09 	add	r9,r12,r9
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80006d12:	f2 c8 ff ff 	sub	r8,r9,-1
	s[cnt++] = '0';
	
	while(cnt>0)
80006d16:	f0 cb ff ff 	sub	r11,r8,-1
80006d1a:	58 0b       	cp.w	r11,0
80006d1c:	e0 8a 00 19 	brle	80006d4e <PrintHex+0xaa>
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80006d20:	fa cb ff f4 	sub	r11,sp,-12
80006d24:	f6 09 00 09 	add	r9,r11,r9
80006d28:	37 8b       	mov	r11,120
80006d2a:	f3 6b ff f4 	st.b	r9[-12],r11
	s[cnt++] = '0';
80006d2e:	fa c9 ff f4 	sub	r9,sp,-12
80006d32:	10 09       	add	r9,r8
80006d34:	33 0b       	mov	r11,48
80006d36:	f3 6b ff f4 	st.b	r9[-12],r11
80006d3a:	fa 08 00 08 	add	r8,sp,r8
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
80006d3e:	fa ce 00 01 	sub	lr,sp,1
80006d42:	14 99       	mov	r9,r10
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
	*p++ = s[--cnt];
80006d44:	11 8b       	ld.ub	r11,r8[0x0]
80006d46:	12 cb       	st.b	r9++,r11
80006d48:	20 18       	sub	r8,1
	}
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
80006d4a:	1c 38       	cp.w	r8,lr
80006d4c:	cf c1       	brne	80006d44 <PrintHex+0xa0>
	*p++ = s[--cnt];
		
	return str;
}
80006d4e:	14 9c       	mov	r12,r10
80006d50:	2f dd       	sub	sp,-12
80006d52:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

80006d56 <PrintDec>:
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
{
80006d56:	d4 21       	pushm	r4-r7,lr
80006d58:	20 3d       	sub	sp,12
80006d5a:	18 98       	mov	r8,r12
	char * p = str;
	
	int sign = i>=0 ? 0 : 1;
	char s[10];
	memset(s, 0 , 10);
80006d5c:	30 06       	mov	r6,0
80006d5e:	30 07       	mov	r7,0
80006d60:	fa e7 00 00 	st.d	sp[0],r6
80006d64:	30 0c       	mov	r12,0
80006d66:	ba 4c       	st.h	sp[0x8],r12
	int cnt=0;
	if(sign)
80006d68:	58 08       	cp.w	r8,0
80006d6a:	c0 35       	brlt	80006d70 <PrintDec+0x1a>
80006d6c:	14 97       	mov	r7,r10
80006d6e:	c0 58       	rjmp	80006d78 <PrintDec+0x22>
	{
		*p++ = '-';
80006d70:	14 97       	mov	r7,r10
80006d72:	32 d9       	mov	r9,45
80006d74:	0e c9       	st.b	r7++,r9
		i = -i;
80006d76:	5c 38       	neg	r8
	}
	
	if(i == 0 )s[cnt++] = '0';
80006d78:	58 08       	cp.w	r8,0
80006d7a:	c0 51       	brne	80006d84 <PrintDec+0x2e>
80006d7c:	33 08       	mov	r8,48
80006d7e:	ba 88       	st.b	sp[0x0],r8
80006d80:	30 1e       	mov	lr,1
80006d82:	c2 f8       	rjmp	80006de0 <PrintDec+0x8a>
	
	int ten = i%10;
80006d84:	e0 65 66 67 	mov	r5,26215
80006d88:	ea 15 66 66 	orh	r5,0x6666
80006d8c:	f0 05 04 44 	muls.d	r4,r8,r5
80006d90:	ea 0c 14 02 	asr	r12,r5,0x2
80006d94:	f0 09 14 1f 	asr	r9,r8,0x1f
80006d98:	f8 09 01 09 	sub	r9,r12,r9
80006d9c:	f2 09 00 29 	add	r9,r9,r9<<0x2
80006da0:	f0 09 01 19 	sub	r9,r8,r9<<0x1
80006da4:	30 0e       	mov	lr,0
	while(i)
	{
		s[cnt] = ten+'0';
80006da6:	1a 9c       	mov	r12,sp
		cnt++;
		i /= 10;
80006da8:	e0 66 66 67 	mov	r6,26215
80006dac:	ea 16 66 66 	orh	r6,0x6666
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
	{
		s[cnt] = ten+'0';
80006db0:	2d 09       	sub	r9,-48
80006db2:	f8 0e 0b 09 	st.b	r12[lr],r9
		cnt++;
80006db6:	2f fe       	sub	lr,-1
		i /= 10;
80006db8:	f0 06 04 44 	muls.d	r4,r8,r6
80006dbc:	ea 09 14 02 	asr	r9,r5,0x2
80006dc0:	bf 58       	asr	r8,0x1f
80006dc2:	f2 08 01 08 	sub	r8,r9,r8
		ten = i%10;
80006dc6:	f0 06 04 44 	muls.d	r4,r8,r6
80006dca:	ea 09 14 02 	asr	r9,r5,0x2
80006dce:	f0 05 14 1f 	asr	r5,r8,0x1f
80006dd2:	0a 19       	sub	r9,r5
80006dd4:	f2 09 00 29 	add	r9,r9,r9<<0x2
80006dd8:	f0 09 01 19 	sub	r9,r8,r9<<0x1
	}
	
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
80006ddc:	58 08       	cp.w	r8,0
80006dde:	ce 91       	brne	80006db0 <PrintDec+0x5a>
		cnt++;
		i /= 10;
		ten = i%10;
	}
	
	if(len - cnt > 0 )
80006de0:	f6 0e 01 08 	sub	r8,r11,lr
80006de4:	58 08       	cp.w	r8,0
80006de6:	e0 89 00 06 	brgt	80006df2 <PrintDec+0x9c>
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80006dea:	58 0e       	cp.w	lr,0
80006dec:	e0 89 00 14 	brgt	80006e14 <PrintDec+0xbe>
80006df0:	c1 d8       	rjmp	80006e2a <PrintDec+0xd4>
		ten = i%10;
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
80006df2:	1c 1b       	sub	r11,lr
80006df4:	5c 5b       	castu.b	r11
		for(int i = 0; i < num; i++)
80006df6:	16 9c       	mov	r12,r11
80006df8:	58 0b       	cp.w	r11,0
80006dfa:	fe 9a ff f8 	brle	80006dea <PrintDec+0x94>
80006dfe:	1a 99       	mov	r9,sp
80006e00:	1c 09       	add	r9,lr
80006e02:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80006e04:	33 06       	mov	r6,48
80006e06:	12 c6       	st.b	r9++,r6
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80006e08:	2f f8       	sub	r8,-1
80006e0a:	18 38       	cp.w	r8,r12
80006e0c:	cf d5       	brlt	80006e06 <PrintDec+0xb0>
{
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
80006e0e:	f6 0e 00 0e 	add	lr,r11,lr
80006e12:	ce cb       	rjmp	80006dea <PrintDec+0x94>
80006e14:	fa c8 ff f4 	sub	r8,sp,-12
80006e18:	1c 08       	add	r8,lr
80006e1a:	20 d8       	sub	r8,13
80006e1c:	fa cb 00 01 	sub	r11,sp,1
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
	*p++ = s[--cnt];
80006e20:	11 89       	ld.ub	r9,r8[0x0]
80006e22:	0e c9       	st.b	r7++,r9
80006e24:	20 18       	sub	r8,1
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80006e26:	16 38       	cp.w	r8,r11
80006e28:	cf c1       	brne	80006e20 <PrintDec+0xca>
	*p++ = s[--cnt];
	
	return str;
}
80006e2a:	14 9c       	mov	r12,r10
80006e2c:	2f dd       	sub	sp,-12
80006e2e:	d8 22       	popm	r4-r7,pc

80006e30 <log>:
	,  NULL );
	
}

int log(char * content, ...)
{
80006e30:	d4 31       	pushm	r0-r7,lr
80006e32:	fa cd 02 08 	sub	sp,sp,520
80006e36:	18 97       	mov	r7,r12
	
	
	char logTmp[MAX_LOG_LINE_SIZE];
	memset(logTmp, '\0', MAX_LOG_LINE_SIZE);	
80006e38:	e0 6a 01 00 	mov	r10,256
80006e3c:	30 0b       	mov	r11,0
80006e3e:	fa cc fe f8 	sub	r12,sp,-264
80006e42:	f0 1f 00 4e 	mcall	80006f78 <log+0x148>
	,  tskLOG_PRIORITY
	,  NULL );
	
}

int log(char * content, ...)
80006e46:	fa c4 fd d4 	sub	r4,sp,-556
80006e4a:	30 0a       	mov	r10,0
80006e4c:	50 0a       	stdsp	sp[0x0],r10
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80006e4e:	fa c3 ff fc 	sub	r3,sp,-4
80006e52:	e0 61 01 00 	mov	r1,256
80006e56:	14 90       	mov	r0,r10
			
					if(*str == '%')
80006e58:	32 52       	mov	r2,37
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
80006e5a:	fa c6 fe f8 	sub	r6,sp,-264
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80006e5e:	02 9a       	mov	r10,r1
80006e60:	00 9b       	mov	r11,r0
80006e62:	06 9c       	mov	r12,r3
80006e64:	f0 1f 00 45 	mcall	80006f78 <log+0x148>
			
					if(*str == '%')
80006e68:	0f 88       	ld.ub	r8,r7[0x0]
80006e6a:	e4 08 18 00 	cp.b	r8,r2
80006e6e:	c5 71       	brne	80006f1c <log+0xec>
					{
						static char lench = 0;
						lench =*(str + 1);
80006e70:	ee c8 ff ff 	sub	r8,r7,-1
80006e74:	11 89       	ld.ub	r9,r8[0x0]
80006e76:	4c 2a       	lddpc	r10,80006f7c <log+0x14c>
80006e78:	b4 89       	st.b	r10[0x0],r9
						if((lench >= '0') &&  (lench <= '9'))
80006e7a:	23 09       	sub	r9,48
80006e7c:	30 9a       	mov	r10,9
80006e7e:	f4 09 18 00 	cp.b	r9,r10
80006e82:	ee 08 17 b0 	movhi	r8,r7
						{
							len = *(++str) - '0';
80006e86:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
80006e8a:	f7 b9 08 30 	subls	r9,48
80006e8e:	fb f9 8a 00 	st.wls	sp[0x0],r9
						}
						
						str++;
80006e92:	f0 c7 ff ff 	sub	r7,r8,-1
						
						switch(*(str))
80006e96:	0f 88       	ld.ub	r8,r7[0x0]
80006e98:	22 58       	sub	r8,37
80006e9a:	e0 48 00 53 	cp.w	r8,83
80006e9e:	e0 8b 00 31 	brhi	80006f00 <log+0xd0>
80006ea2:	4b 89       	lddpc	r9,80006f80 <log+0x150>
80006ea4:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
						{
							case('i'):
							case('I'):
							case('d'):
							case('D'):
							x = va_arg(arg_ptr,int);
80006ea8:	e8 c5 ff fc 	sub	r5,r4,-4
							strTmp = PrintDec(x, len, strTmp);
80006eac:	06 9a       	mov	r10,r3
80006eae:	40 0b       	lddsp	r11,sp[0x0]
80006eb0:	5c 5b       	castu.b	r11
80006eb2:	68 0c       	ld.w	r12,r4[0x0]
80006eb4:	f0 1f 00 34 	mcall	80006f84 <log+0x154>
							break;
80006eb8:	c2 98       	rjmp	80006f0a <log+0xda>
							
							case('f')://浮点数输出
							case('F'):
							//f = va_arg(arg_ptr,int);
							//strTmp = PrintDec(x, len, strTmp);
							log("I need float.");
80006eba:	4b 4c       	lddpc	r12,80006f88 <log+0x158>
80006ebc:	f0 1f 00 34 	mcall	80006f8c <log+0x15c>
80006ec0:	08 95       	mov	r5,r4
80006ec2:	06 9c       	mov	r12,r3
							break;
80006ec4:	c2 38       	rjmp	80006f0a <log+0xda>
							
							
							case('x'):
							case('X'):
							x = va_arg(arg_ptr,int);
80006ec6:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintHex(x,len, strTmp);
80006eca:	06 9a       	mov	r10,r3
80006ecc:	40 0b       	lddsp	r11,sp[0x0]
80006ece:	5c 5b       	castu.b	r11
80006ed0:	68 0c       	ld.w	r12,r4[0x0]
80006ed2:	f0 1f 00 30 	mcall	80006f90 <log+0x160>
80006ed6:	06 9c       	mov	r12,r3
							break;
80006ed8:	c1 98       	rjmp	80006f0a <log+0xda>
							
							case('c'):
							case('C'):
							y = va_arg(arg_ptr,int);
80006eda:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintChar(y, strTmp);
80006ede:	06 9b       	mov	r11,r3
80006ee0:	09 bc       	ld.ub	r12,r4[0x3]
80006ee2:	f0 1f 00 2d 	mcall	80006f94 <log+0x164>
80006ee6:	06 9c       	mov	r12,r3
							break;
80006ee8:	c1 18       	rjmp	80006f0a <log+0xda>
							
							case('s'):
							case('S'):
							strTmp = va_arg(arg_ptr,char*);
80006eea:	e8 c5 ff fc 	sub	r5,r4,-4
80006eee:	68 0c       	ld.w	r12,r4[0x0]
							//PrintStr(s);
							break;
80006ef0:	c0 d8       	rjmp	80006f0a <log+0xda>
							
							case('%'):
							PrintChar('%', strTmp);
80006ef2:	06 9b       	mov	r11,r3
80006ef4:	32 5c       	mov	r12,37
80006ef6:	f0 1f 00 28 	mcall	80006f94 <log+0x164>
80006efa:	08 95       	mov	r5,r4
80006efc:	06 9c       	mov	r12,r3
							//PrintChar('%');
							break;
80006efe:	c0 68       	rjmp	80006f0a <log+0xda>
							
							default:
							log("I need relax.");
80006f00:	4a 6c       	lddpc	r12,80006f98 <log+0x168>
80006f02:	f0 1f 00 23 	mcall	80006f8c <log+0x15c>
80006f06:	08 95       	mov	r5,r4
80006f08:	06 9c       	mov	r12,r3
						}
						str++;
80006f0a:	2f f7       	sub	r7,-1
						
						length = sprintf(logTmp,"%s%s",logTmp,strTmp );
80006f0c:	1a dc       	st.w	--sp,r12
80006f0e:	1a d6       	st.w	--sp,r6
80006f10:	4a 3b       	lddpc	r11,80006f9c <log+0x16c>
80006f12:	0c 9c       	mov	r12,r6
80006f14:	f0 1f 00 23 	mcall	80006fa0 <log+0x170>
80006f18:	2f ed       	sub	sp,-8
80006f1a:	c0 a8       	rjmp	80006f2e <log+0xfe>
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
80006f1c:	2f f7       	sub	r7,-1
80006f1e:	1a d8       	st.w	--sp,r8
80006f20:	1a d6       	st.w	--sp,r6
80006f22:	4a 1b       	lddpc	r11,80006fa4 <log+0x174>
80006f24:	0c 9c       	mov	r12,r6
80006f26:	f0 1f 00 1f 	mcall	80006fa0 <log+0x170>
80006f2a:	08 95       	mov	r5,r4
80006f2c:	2f ed       	sub	sp,-8
			
			
			
	}while(*str != '\0');
80006f2e:	0f 89       	ld.ub	r9,r7[0x0]
80006f30:	30 08       	mov	r8,0
80006f32:	f0 09 18 00 	cp.b	r9,r8
80006f36:	c0 30       	breq	80006f3c <log+0x10c>
80006f38:	0a 94       	mov	r4,r5
80006f3a:	c9 2b       	rjmp	80006e5e <log+0x2e>
		
		
				
	va_end(arg_ptr);
	//while(1)		
	length = sprintf(logTmp,"%s\r\n",logTmp);
80006f3c:	fa c7 fe f8 	sub	r7,sp,-264
80006f40:	1a d7       	st.w	--sp,r7
80006f42:	49 ab       	lddpc	r11,80006fa8 <log+0x178>
80006f44:	0e 9c       	mov	r12,r7
80006f46:	f0 1f 00 17 	mcall	80006fa0 <log+0x170>
	
	char * p = pvPortMalloc(length+1);
80006f4a:	5c 5c       	castu.b	r12
80006f4c:	f8 c6 ff ff 	sub	r6,r12,-1
80006f50:	0c 9c       	mov	r12,r6
80006f52:	f0 1f 00 17 	mcall	80006fac <log+0x17c>
80006f56:	54 2c       	stdsp	sp[0x108],r12
	memcpy(p, logTmp, length+1);
80006f58:	0c 9a       	mov	r10,r6
80006f5a:	0e 9b       	mov	r11,r7
80006f5c:	f0 1f 00 15 	mcall	80006fb0 <log+0x180>
	//
	//usart_write_line(EXAMPLE_USART, logTmp)
	
	xQueueSend( logQueue, &p, 5);
80006f60:	30 09       	mov	r9,0
80006f62:	30 5a       	mov	r10,5
80006f64:	fa cb fe f8 	sub	r11,sp,-264
80006f68:	49 38       	lddpc	r8,80006fb4 <log+0x184>
80006f6a:	70 0c       	ld.w	r12,r8[0x0]
80006f6c:	f0 1f 00 13 	mcall	80006fb8 <log+0x188>
80006f70:	2f fd       	sub	sp,-4
	
	
}
80006f72:	fe 3d fd f8 	sub	sp,-520
80006f76:	d8 32       	popm	r0-r7,pc
80006f78:	80 00       	ld.sh	r0,r0[0x0]
80006f7a:	77 f8       	ld.w	r8,r11[0x7c]
80006f7c:	00 00       	add	r0,r0
80006f7e:	0d 44       	ld.w	r4,--r6
80006f80:	80 00       	ld.sh	r0,r0[0x0]
80006f82:	d6 e4       	*unknown*
80006f84:	80 00       	ld.sh	r0,r0[0x0]
80006f86:	6d 56       	ld.w	r6,r6[0x54]
80006f88:	80 00       	ld.sh	r0,r0[0x0]
80006f8a:	d9 90       	acall	0x99
80006f8c:	80 00       	ld.sh	r0,r0[0x0]
80006f8e:	6e 30       	ld.w	r0,r7[0xc]
80006f90:	80 00       	ld.sh	r0,r0[0x0]
80006f92:	6c a4       	ld.w	r4,r6[0x28]
80006f94:	80 00       	ld.sh	r0,r0[0x0]
80006f96:	6c a0       	ld.w	r0,r6[0x28]
80006f98:	80 00       	ld.sh	r0,r0[0x0]
80006f9a:	d9 a0       	acall	0x9a
80006f9c:	80 00       	ld.sh	r0,r0[0x0]
80006f9e:	d9 b0       	acall	0x9b
80006fa0:	80 00       	ld.sh	r0,r0[0x0]
80006fa2:	7a e8       	ld.w	r8,sp[0x38]
80006fa4:	80 00       	ld.sh	r0,r0[0x0]
80006fa6:	d9 b8       	*unknown*
80006fa8:	80 00       	ld.sh	r0,r0[0x0]
80006faa:	d9 c0       	acall	0x9c
80006fac:	80 00       	ld.sh	r0,r0[0x0]
80006fae:	5e fc       	retal	r12
80006fb0:	80 00       	ld.sh	r0,r0[0x0]
80006fb2:	76 b0       	ld.w	r0,r11[0x2c]
80006fb4:	00 00       	add	r0,r0
80006fb6:	51 28       	stdsp	sp[0x48],r8
80006fb8:	80 00       	ld.sh	r0,r0[0x0]
80006fba:	62 50       	ld.w	r0,r1[0x14]

80006fbc <logFromISR>:
	
	
int logFromISR(char * content, ...)
	{
80006fbc:	d4 31       	pushm	r0-r7,lr
80006fbe:	fa cd 02 0c 	sub	sp,sp,524
80006fc2:	18 97       	mov	r7,r12
		
		
		char logTmp[MAX_LOG_LINE_SIZE];
		memset(logTmp, '\0', MAX_LOG_LINE_SIZE);
80006fc4:	e0 6a 01 00 	mov	r10,256
80006fc8:	30 0b       	mov	r11,0
80006fca:	fa cc fe f4 	sub	r12,sp,-268
80006fce:	f0 1f 00 4c 	mcall	800070fc <logFromISR+0x140>
	
	
}
	
	
int logFromISR(char * content, ...)
80006fd2:	fa c4 fd d0 	sub	r4,sp,-560
80006fd6:	30 0a       	mov	r10,0
80006fd8:	50 0a       	stdsp	sp[0x0],r10
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80006fda:	fa c3 ff fc 	sub	r3,sp,-4
80006fde:	e0 61 01 00 	mov	r1,256
80006fe2:	14 90       	mov	r0,r10
			
			if(*str == '%')
80006fe4:	32 52       	mov	r2,37
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
80006fe6:	fa c6 fe f4 	sub	r6,sp,-268
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80006fea:	02 9a       	mov	r10,r1
80006fec:	00 9b       	mov	r11,r0
80006fee:	06 9c       	mov	r12,r3
80006ff0:	f0 1f 00 43 	mcall	800070fc <logFromISR+0x140>
			
			if(*str == '%')
80006ff4:	0f 88       	ld.ub	r8,r7[0x0]
80006ff6:	e4 08 18 00 	cp.b	r8,r2
80006ffa:	c5 11       	brne	8000709c <logFromISR+0xe0>
			{
				static char lench = 0;
				lench =*(str + 1);
80006ffc:	ee c8 ff ff 	sub	r8,r7,-1
80007000:	11 89       	ld.ub	r9,r8[0x0]
80007002:	4c 0a       	lddpc	r10,80007100 <logFromISR+0x144>
80007004:	b4 89       	st.b	r10[0x0],r9
				if((lench >= '0') &&  (lench <= '9'))
80007006:	23 09       	sub	r9,48
80007008:	30 9a       	mov	r10,9
8000700a:	f4 09 18 00 	cp.b	r9,r10
8000700e:	ee 08 17 b0 	movhi	r8,r7
				{
					len = *(++str) - '0';
80007012:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
80007016:	f7 b9 08 30 	subls	r9,48
8000701a:	fb f9 8a 00 	st.wls	sp[0x0],r9
				}
				
				str++;
8000701e:	f0 c7 ff ff 	sub	r7,r8,-1
				
				switch(*(str))
80007022:	0f 88       	ld.ub	r8,r7[0x0]
80007024:	22 58       	sub	r8,37
80007026:	e0 48 00 53 	cp.w	r8,83
8000702a:	e0 8b 00 2b 	brhi	80007080 <logFromISR+0xc4>
8000702e:	4b 69       	lddpc	r9,80007104 <logFromISR+0x148>
80007030:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
				{
					case('d'):
					case('D'):
					x = va_arg(arg_ptr,int);
80007034:	e8 c5 ff fc 	sub	r5,r4,-4
					strTmp = PrintDec(x, len, strTmp);
80007038:	06 9a       	mov	r10,r3
8000703a:	40 0b       	lddsp	r11,sp[0x0]
8000703c:	5c 5b       	castu.b	r11
8000703e:	68 0c       	ld.w	r12,r4[0x0]
80007040:	f0 1f 00 32 	mcall	80007108 <logFromISR+0x14c>
					break;
80007044:	c2 38       	rjmp	8000708a <logFromISR+0xce>
					case('x'):
					case('X'):
					x = va_arg(arg_ptr,int);
80007046:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintHex(x,len, strTmp);
8000704a:	06 9a       	mov	r10,r3
8000704c:	40 0b       	lddsp	r11,sp[0x0]
8000704e:	5c 5b       	castu.b	r11
80007050:	68 0c       	ld.w	r12,r4[0x0]
80007052:	f0 1f 00 2f 	mcall	8000710c <logFromISR+0x150>
80007056:	06 9c       	mov	r12,r3
					break;
80007058:	c1 98       	rjmp	8000708a <logFromISR+0xce>
					case('c'):
					case('C'):
					y = va_arg(arg_ptr,int);
8000705a:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintChar(y, strTmp);
8000705e:	06 9b       	mov	r11,r3
80007060:	09 bc       	ld.ub	r12,r4[0x3]
80007062:	f0 1f 00 2c 	mcall	80007110 <logFromISR+0x154>
80007066:	06 9c       	mov	r12,r3
					break;
80007068:	c1 18       	rjmp	8000708a <logFromISR+0xce>
					case('s'):
					case('S'):
					strTmp = va_arg(arg_ptr,char*);
8000706a:	e8 c5 ff fc 	sub	r5,r4,-4
8000706e:	68 0c       	ld.w	r12,r4[0x0]
					//PrintStr(s);
					break;
80007070:	c0 d8       	rjmp	8000708a <logFromISR+0xce>
					case('%'):
					PrintChar('%', strTmp);
80007072:	06 9b       	mov	r11,r3
80007074:	32 5c       	mov	r12,37
80007076:	f0 1f 00 27 	mcall	80007110 <logFromISR+0x154>
8000707a:	08 95       	mov	r5,r4
8000707c:	06 9c       	mov	r12,r3
					//PrintChar('%');
					break;
8000707e:	c0 68       	rjmp	8000708a <logFromISR+0xce>
					default:
					log("I need relax.");
80007080:	4a 5c       	lddpc	r12,80007114 <logFromISR+0x158>
80007082:	f0 1f 00 26 	mcall	80007118 <logFromISR+0x15c>
80007086:	08 95       	mov	r5,r4
80007088:	06 9c       	mov	r12,r3
				}
				str++;
8000708a:	2f f7       	sub	r7,-1
				
				length = sprintf(logTmp,"%s%s",logTmp,strTmp );
8000708c:	1a dc       	st.w	--sp,r12
8000708e:	1a d6       	st.w	--sp,r6
80007090:	4a 3b       	lddpc	r11,8000711c <logFromISR+0x160>
80007092:	0c 9c       	mov	r12,r6
80007094:	f0 1f 00 23 	mcall	80007120 <logFromISR+0x164>
80007098:	2f ed       	sub	sp,-8
8000709a:	c0 a8       	rjmp	800070ae <logFromISR+0xf2>
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
8000709c:	2f f7       	sub	r7,-1
8000709e:	1a d8       	st.w	--sp,r8
800070a0:	1a d6       	st.w	--sp,r6
800070a2:	4a 1b       	lddpc	r11,80007124 <logFromISR+0x168>
800070a4:	0c 9c       	mov	r12,r6
800070a6:	f0 1f 00 1f 	mcall	80007120 <logFromISR+0x164>
800070aa:	08 95       	mov	r5,r4
800070ac:	2f ed       	sub	sp,-8
			
			
			
		}while(*str != '\0');
800070ae:	0f 89       	ld.ub	r9,r7[0x0]
800070b0:	30 08       	mov	r8,0
800070b2:	f0 09 18 00 	cp.b	r9,r8
800070b6:	c0 30       	breq	800070bc <logFromISR+0x100>
800070b8:	0a 94       	mov	r4,r5
800070ba:	c9 8b       	rjmp	80006fea <logFromISR+0x2e>
		
		
		
		va_end(arg_ptr);
		//while(1)
		length = sprintf(logTmp,"%s\r\n",logTmp);
800070bc:	fa c7 fe f4 	sub	r7,sp,-268
800070c0:	1a d7       	st.w	--sp,r7
800070c2:	49 ab       	lddpc	r11,80007128 <logFromISR+0x16c>
800070c4:	0e 9c       	mov	r12,r7
800070c6:	f0 1f 00 17 	mcall	80007120 <logFromISR+0x164>
		
		char * p = pvPortMalloc(length+1);
800070ca:	5c 5c       	castu.b	r12
800070cc:	f8 c6 ff ff 	sub	r6,r12,-1
800070d0:	0c 9c       	mov	r12,r6
800070d2:	f0 1f 00 17 	mcall	8000712c <logFromISR+0x170>
800070d6:	54 3c       	stdsp	sp[0x10c],r12
		memcpy(p, logTmp, length+1);
800070d8:	0c 9a       	mov	r10,r6
800070da:	0e 9b       	mov	r11,r7
800070dc:	f0 1f 00 15 	mcall	80007130 <logFromISR+0x174>
		//
		portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
800070e0:	30 09       	mov	r9,0
800070e2:	54 29       	stdsp	sp[0x108],r9
		
		//usart_write_line(EXAMPLE_USART, p);
		//vPortFree(p);
		xQueueSendFromISR( logQueue, &p, &xHigherPriorityTaskWoken );
800070e4:	fa ca fe f8 	sub	r10,sp,-264
800070e8:	fa cb fe f4 	sub	r11,sp,-268
800070ec:	49 28       	lddpc	r8,80007134 <logFromISR+0x178>
800070ee:	70 0c       	ld.w	r12,r8[0x0]
800070f0:	f0 1f 00 12 	mcall	80007138 <logFromISR+0x17c>
800070f4:	2f fd       	sub	sp,-4
		
		//if (xHigherPriorityTaskWoken == pdTRUE)
		//{
			////taskYIELD();
		//}
	}
800070f6:	fe 3d fd f4 	sub	sp,-524
800070fa:	d8 32       	popm	r0-r7,pc
800070fc:	80 00       	ld.sh	r0,r0[0x0]
800070fe:	77 f8       	ld.w	r8,r11[0x7c]
80007100:	00 00       	add	r0,r0
80007102:	0d 45       	ld.w	r5,--r6
80007104:	80 00       	ld.sh	r0,r0[0x0]
80007106:	d8 34       	*unknown*
80007108:	80 00       	ld.sh	r0,r0[0x0]
8000710a:	6d 56       	ld.w	r6,r6[0x54]
8000710c:	80 00       	ld.sh	r0,r0[0x0]
8000710e:	6c a4       	ld.w	r4,r6[0x28]
80007110:	80 00       	ld.sh	r0,r0[0x0]
80007112:	6c a0       	ld.w	r0,r6[0x28]
80007114:	80 00       	ld.sh	r0,r0[0x0]
80007116:	d9 a0       	acall	0x9a
80007118:	80 00       	ld.sh	r0,r0[0x0]
8000711a:	6e 30       	ld.w	r0,r7[0xc]
8000711c:	80 00       	ld.sh	r0,r0[0x0]
8000711e:	d9 b0       	acall	0x9b
80007120:	80 00       	ld.sh	r0,r0[0x0]
80007122:	7a e8       	ld.w	r8,sp[0x38]
80007124:	80 00       	ld.sh	r0,r0[0x0]
80007126:	d9 b8       	*unknown*
80007128:	80 00       	ld.sh	r0,r0[0x0]
8000712a:	d9 c0       	acall	0x9c
8000712c:	80 00       	ld.sh	r0,r0[0x0]
8000712e:	5e fc       	retal	r12
80007130:	80 00       	ld.sh	r0,r0[0x0]
80007132:	76 b0       	ld.w	r0,r11[0x2c]
80007134:	00 00       	add	r0,r0
80007136:	51 28       	stdsp	sp[0x48],r8
80007138:	80 00       	ld.sh	r0,r0[0x0]
8000713a:	62 00       	ld.w	r0,r1[0x0]

8000713c <log_init>:
		
	return str;
}

void log_init(void)
{
8000713c:	d4 01       	pushm	lr
		.stopbits     = USART_1_STOPBIT,
		.channelmode  = USART_NORMAL_CHMODE
	};

	// Assign GPIO to USART.
	gpio_enable_module(USART_GPIO_MAP,
8000713e:	30 2b       	mov	r11,2
80007140:	49 0c       	lddpc	r12,80007180 <log_init+0x44>
80007142:	f0 1f 00 11 	mcall	80007184 <log_init+0x48>
	sizeof(USART_GPIO_MAP) / sizeof(USART_GPIO_MAP[0]));

	// Initialize USART in RS232 mode.
	usart_init_rs232(EXAMPLE_USART, &USART_OPTIONS, EXAMPLE_TARGET_PBACLK_FREQ_HZ);			
80007146:	e0 6a 36 00 	mov	r10,13824
8000714a:	ea 1a 01 6e 	orh	r10,0x16e
8000714e:	48 fb       	lddpc	r11,80007188 <log_init+0x4c>
80007150:	fe 7c 18 00 	mov	r12,-59392
80007154:	f0 1f 00 0e 	mcall	8000718c <log_init+0x50>
			
	logQueue  = xQueueCreate(50, sizeof(char *));
80007158:	30 4b       	mov	r11,4
8000715a:	33 2c       	mov	r12,50
8000715c:	f0 1f 00 0d 	mcall	80007190 <log_init+0x54>
80007160:	48 d8       	lddpc	r8,80007194 <log_init+0x58>
80007162:	91 0c       	st.w	r8[0x0],r12
	
	xTaskCreate(
80007164:	30 09       	mov	r9,0
80007166:	1a d9       	st.w	--sp,r9
80007168:	1a d9       	st.w	--sp,r9
8000716a:	1a d9       	st.w	--sp,r9
8000716c:	30 28       	mov	r8,2
8000716e:	e0 6a 01 80 	mov	r10,384
80007172:	48 ab       	lddpc	r11,80007198 <log_init+0x5c>
80007174:	48 ac       	lddpc	r12,8000719c <log_init+0x60>
80007176:	f0 1f 00 0b 	mcall	800071a0 <log_init+0x64>
8000717a:	2f dd       	sub	sp,-12
	,  384
	,  NULL
	,  tskLOG_PRIORITY
	,  NULL );
	
}
8000717c:	d8 02       	popm	pc
8000717e:	00 00       	add	r0,r0
80007180:	80 00       	ld.sh	r0,r0[0x0]
80007182:	d9 cc       	*unknown*
80007184:	80 00       	ld.sh	r0,r0[0x0]
80007186:	53 bc       	stdsp	sp[0xec],r12
80007188:	80 00       	ld.sh	r0,r0[0x0]
8000718a:	d9 84       	*unknown*
8000718c:	80 00       	ld.sh	r0,r0[0x0]
8000718e:	5a 60       	cp.w	r0,-26
80007190:	80 00       	ld.sh	r0,r0[0x0]
80007192:	63 50       	ld.w	r0,r1[0x54]
80007194:	00 00       	add	r0,r0
80007196:	51 28       	stdsp	sp[0x48],r8
80007198:	80 00       	ld.sh	r0,r0[0x0]
8000719a:	d9 c8       	*unknown*
8000719c:	80 00       	ld.sh	r0,r0[0x0]
8000719e:	71 a4       	ld.w	r4,r8[0x68]
800071a0:	80 00       	ld.sh	r0,r0[0x0]
800071a2:	6a 6c       	ld.w	r12,r5[0x18]

800071a4 <task_log>:
			////taskYIELD();
		//}
	}
	
static void task_log(void * pvParameters)
{
800071a4:	eb cd 40 f8 	pushm	r3-r7,lr
800071a8:	20 1d       	sub	sp,4
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
800071aa:	48 c7       	lddpc	r7,800071d8 <task_log+0x34>
800071ac:	30 05       	mov	r5,0
800071ae:	3f f4       	mov	r4,-1
		{
			if( NULL != str)
			{
				usart_write_line(EXAMPLE_USART, str);
800071b0:	fe 73 18 00 	mov	r3,-59392
{
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
800071b4:	0a 99       	mov	r9,r5
800071b6:	08 9a       	mov	r10,r4
800071b8:	1a 9b       	mov	r11,sp
800071ba:	6e 0c       	ld.w	r12,r7[0x0]
800071bc:	f0 1f 00 08 	mcall	800071dc <task_log+0x38>
800071c0:	58 1c       	cp.w	r12,1
800071c2:	cf 91       	brne	800071b4 <task_log+0x10>
		{
			if( NULL != str)
800071c4:	40 0b       	lddsp	r11,sp[0x0]
800071c6:	58 0b       	cp.w	r11,0
800071c8:	cf 60       	breq	800071b4 <task_log+0x10>
			{
				usart_write_line(EXAMPLE_USART, str);
800071ca:	06 9c       	mov	r12,r3
800071cc:	f0 1f 00 05 	mcall	800071e0 <task_log+0x3c>
				vPortFree(str);
800071d0:	40 0c       	lddsp	r12,sp[0x0]
800071d2:	f0 1f 00 05 	mcall	800071e4 <task_log+0x40>
800071d6:	ce fb       	rjmp	800071b4 <task_log+0x10>
800071d8:	00 00       	add	r0,r0
800071da:	51 28       	stdsp	sp[0x48],r8
800071dc:	80 00       	ld.sh	r0,r0[0x0]
800071de:	60 44       	ld.w	r4,r0[0x10]
800071e0:	80 00       	ld.sh	r0,r0[0x0]
800071e2:	5a 10       	cp.w	r0,-31
800071e4:	80 00       	ld.sh	r0,r0[0x0]
800071e6:	5e d4       	retvc	r4

800071e8 <main>:
#include "xgrtc.h"
#include "app.h"


int main (void)
{
800071e8:	d4 01       	pushm	lr
	
	//Force SSC_TX_DATA_ENABLE Disabled as soon as possible.
	AVR32_GPIO.port[1].ovrs  =  0x00000001;  //Value will be high.
800071ea:	fe 78 10 00 	mov	r8,-61440
800071ee:	30 19       	mov	r9,1
800071f0:	f1 49 01 54 	st.w	r8[340],r9
	AVR32_GPIO.port[1].oders =  0x00000001;  //Output Driver will be Enabled.
800071f4:	f1 49 01 44 	st.w	r8[324],r9
	AVR32_GPIO.port[1].gpers =  0x00000001;  //Enable as GPIO.
800071f8:	f1 49 01 04 	st.w	r8[260],r9
		
	Disable_global_interrupt();
800071fc:	d3 03       	ssrf	0x10
	local_start_pll0();
800071fe:	f0 1f 00 0c 	mcall	8000722c <main+0x44>
		
	INTC_init_interrupts();
80007202:	f0 1f 00 0c 	mcall	80007230 <main+0x48>
		
	log_init();
80007206:	f0 1f 00 0c 	mcall	80007234 <main+0x4c>
	log("----start debug----");
8000720a:	48 cc       	lddpc	r12,80007238 <main+0x50>
8000720c:	f0 1f 00 0c 	mcall	8000723c <main+0x54>
		
	//voc_init();

	//tc_init();
	
	rfid_init();
80007210:	f0 1f 00 0c 	mcall	80007240 <main+0x58>
		
	app_init();
80007214:	f0 1f 00 0c 	mcall	80007244 <main+0x5c>
		
	xcmp_init();
80007218:	f0 1f 00 0c 	mcall	80007248 <main+0x60>

	local_start_timer();
8000721c:	f0 1f 00 0c 	mcall	8000724c <main+0x64>
	
	xg_rtc_init();
80007220:	f0 1f 00 0c 	mcall	80007250 <main+0x68>
		
	vTaskStartScheduler();
80007224:	f0 1f 00 0c 	mcall	80007254 <main+0x6c>
	return 0;
	
}
80007228:	d8 0a       	popm	pc,r12=0
8000722a:	00 00       	add	r0,r0
8000722c:	80 00       	ld.sh	r0,r0[0x0]
8000722e:	52 84       	stdsp	sp[0xa0],r4
80007230:	80 00       	ld.sh	r0,r0[0x0]
80007232:	54 c0       	stdsp	sp[0x130],r0
80007234:	80 00       	ld.sh	r0,r0[0x0]
80007236:	71 3c       	ld.w	r12,r8[0x4c]
80007238:	80 00       	ld.sh	r0,r0[0x0]
8000723a:	d9 dc       	*unknown*
8000723c:	80 00       	ld.sh	r0,r0[0x0]
8000723e:	6e 30       	ld.w	r0,r7[0xc]
80007240:	80 00       	ld.sh	r0,r0[0x0]
80007242:	52 78       	stdsp	sp[0x9c],r8
80007244:	80 00       	ld.sh	r0,r0[0x0]
80007246:	20 3c       	sub	r12,3
80007248:	80 00       	ld.sh	r0,r0[0x0]
8000724a:	41 9c       	lddsp	r12,sp[0x64]
8000724c:	80 00       	ld.sh	r0,r0[0x0]
8000724e:	53 3c       	stdsp	sp[0xcc],r12
80007250:	80 00       	ld.sh	r0,r0[0x0]
80007252:	2a c4       	sub	r4,-84
80007254:	80 00       	ld.sh	r0,r0[0x0]
80007256:	6c 54       	ld.w	r4,r6[0x14]

80007258 <free>:
80007258:	d4 01       	pushm	lr
8000725a:	e0 68 0a 3c 	mov	r8,2620
8000725e:	18 9b       	mov	r11,r12
80007260:	70 0c       	ld.w	r12,r8[0x0]
80007262:	e0 a0 1e 61 	rcall	8000af24 <_free_r>
80007266:	d8 02       	popm	pc

80007268 <malloc>:
80007268:	d4 01       	pushm	lr
8000726a:	e0 68 0a 3c 	mov	r8,2620
8000726e:	18 9b       	mov	r11,r12
80007270:	70 0c       	ld.w	r12,r8[0x0]
80007272:	c0 3c       	rcall	80007278 <_malloc_r>
80007274:	d8 02       	popm	pc
80007276:	d7 03       	nop

80007278 <_malloc_r>:
80007278:	d4 31       	pushm	r0-r7,lr
8000727a:	f6 c8 ff f5 	sub	r8,r11,-11
8000727e:	18 95       	mov	r5,r12
80007280:	10 97       	mov	r7,r8
80007282:	e0 17 ff f8 	andl	r7,0xfff8
80007286:	59 68       	cp.w	r8,22
80007288:	f9 b7 08 10 	movls	r7,16
8000728c:	16 37       	cp.w	r7,r11
8000728e:	5f 38       	srlo	r8
80007290:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
80007294:	c0 50       	breq	8000729e <_malloc_r+0x26>
80007296:	30 c8       	mov	r8,12
80007298:	99 38       	st.w	r12[0xc],r8
8000729a:	e0 8f 01 fa 	bral	8000768e <_malloc_r+0x416>
8000729e:	fe b0 f5 d1 	rcall	80005e40 <__malloc_lock>
800072a2:	e0 47 01 f7 	cp.w	r7,503
800072a6:	e0 8b 00 1d 	brhi	800072e0 <_malloc_r+0x68>
800072aa:	ee 03 16 03 	lsr	r3,r7,0x3
800072ae:	e0 68 05 3c 	mov	r8,1340
800072b2:	f0 03 00 38 	add	r8,r8,r3<<0x3
800072b6:	70 36       	ld.w	r6,r8[0xc]
800072b8:	10 36       	cp.w	r6,r8
800072ba:	c0 61       	brne	800072c6 <_malloc_r+0x4e>
800072bc:	ec c8 ff f8 	sub	r8,r6,-8
800072c0:	70 36       	ld.w	r6,r8[0xc]
800072c2:	10 36       	cp.w	r6,r8
800072c4:	c0 c0       	breq	800072dc <_malloc_r+0x64>
800072c6:	6c 18       	ld.w	r8,r6[0x4]
800072c8:	e0 18 ff fc 	andl	r8,0xfffc
800072cc:	6c 3a       	ld.w	r10,r6[0xc]
800072ce:	ec 08 00 09 	add	r9,r6,r8
800072d2:	0a 9c       	mov	r12,r5
800072d4:	6c 28       	ld.w	r8,r6[0x8]
800072d6:	95 28       	st.w	r10[0x8],r8
800072d8:	91 3a       	st.w	r8[0xc],r10
800072da:	c4 78       	rjmp	80007368 <_malloc_r+0xf0>
800072dc:	2f e3       	sub	r3,-2
800072de:	c4 d8       	rjmp	80007378 <_malloc_r+0x100>
800072e0:	ee 03 16 09 	lsr	r3,r7,0x9
800072e4:	c0 41       	brne	800072ec <_malloc_r+0x74>
800072e6:	ee 03 16 03 	lsr	r3,r7,0x3
800072ea:	c2 68       	rjmp	80007336 <_malloc_r+0xbe>
800072ec:	58 43       	cp.w	r3,4
800072ee:	e0 8b 00 06 	brhi	800072fa <_malloc_r+0x82>
800072f2:	ee 03 16 06 	lsr	r3,r7,0x6
800072f6:	2c 83       	sub	r3,-56
800072f8:	c1 f8       	rjmp	80007336 <_malloc_r+0xbe>
800072fa:	59 43       	cp.w	r3,20
800072fc:	e0 8b 00 04 	brhi	80007304 <_malloc_r+0x8c>
80007300:	2a 53       	sub	r3,-91
80007302:	c1 a8       	rjmp	80007336 <_malloc_r+0xbe>
80007304:	e0 43 00 54 	cp.w	r3,84
80007308:	e0 8b 00 06 	brhi	80007314 <_malloc_r+0x9c>
8000730c:	ee 03 16 0c 	lsr	r3,r7,0xc
80007310:	29 23       	sub	r3,-110
80007312:	c1 28       	rjmp	80007336 <_malloc_r+0xbe>
80007314:	e0 43 01 54 	cp.w	r3,340
80007318:	e0 8b 00 06 	brhi	80007324 <_malloc_r+0xac>
8000731c:	ee 03 16 0f 	lsr	r3,r7,0xf
80007320:	28 93       	sub	r3,-119
80007322:	c0 a8       	rjmp	80007336 <_malloc_r+0xbe>
80007324:	e0 43 05 54 	cp.w	r3,1364
80007328:	e0 88 00 04 	brls	80007330 <_malloc_r+0xb8>
8000732c:	37 e3       	mov	r3,126
8000732e:	c0 48       	rjmp	80007336 <_malloc_r+0xbe>
80007330:	ee 03 16 12 	lsr	r3,r7,0x12
80007334:	28 43       	sub	r3,-124
80007336:	e0 6a 05 3c 	mov	r10,1340
8000733a:	f4 03 00 3a 	add	r10,r10,r3<<0x3
8000733e:	74 36       	ld.w	r6,r10[0xc]
80007340:	c1 98       	rjmp	80007372 <_malloc_r+0xfa>
80007342:	6c 19       	ld.w	r9,r6[0x4]
80007344:	e0 19 ff fc 	andl	r9,0xfffc
80007348:	f2 07 01 0b 	sub	r11,r9,r7
8000734c:	58 fb       	cp.w	r11,15
8000734e:	e0 8a 00 04 	brle	80007356 <_malloc_r+0xde>
80007352:	20 13       	sub	r3,1
80007354:	c1 18       	rjmp	80007376 <_malloc_r+0xfe>
80007356:	6c 38       	ld.w	r8,r6[0xc]
80007358:	58 0b       	cp.w	r11,0
8000735a:	c0 b5       	brlt	80007370 <_malloc_r+0xf8>
8000735c:	6c 2a       	ld.w	r10,r6[0x8]
8000735e:	ec 09 00 09 	add	r9,r6,r9
80007362:	0a 9c       	mov	r12,r5
80007364:	91 2a       	st.w	r8[0x8],r10
80007366:	95 38       	st.w	r10[0xc],r8
80007368:	72 18       	ld.w	r8,r9[0x4]
8000736a:	a1 a8       	sbr	r8,0x0
8000736c:	93 18       	st.w	r9[0x4],r8
8000736e:	cb c8       	rjmp	800074e6 <_malloc_r+0x26e>
80007370:	10 96       	mov	r6,r8
80007372:	14 36       	cp.w	r6,r10
80007374:	ce 71       	brne	80007342 <_malloc_r+0xca>
80007376:	2f f3       	sub	r3,-1
80007378:	e0 6a 05 3c 	mov	r10,1340
8000737c:	f4 cc ff f8 	sub	r12,r10,-8
80007380:	78 26       	ld.w	r6,r12[0x8]
80007382:	18 36       	cp.w	r6,r12
80007384:	c6 c0       	breq	8000745c <_malloc_r+0x1e4>
80007386:	6c 19       	ld.w	r9,r6[0x4]
80007388:	e0 19 ff fc 	andl	r9,0xfffc
8000738c:	f2 07 01 08 	sub	r8,r9,r7
80007390:	58 f8       	cp.w	r8,15
80007392:	e0 89 00 8f 	brgt	800074b0 <_malloc_r+0x238>
80007396:	99 3c       	st.w	r12[0xc],r12
80007398:	99 2c       	st.w	r12[0x8],r12
8000739a:	58 08       	cp.w	r8,0
8000739c:	c0 55       	brlt	800073a6 <_malloc_r+0x12e>
8000739e:	ec 09 00 09 	add	r9,r6,r9
800073a2:	0a 9c       	mov	r12,r5
800073a4:	ce 2b       	rjmp	80007368 <_malloc_r+0xf0>
800073a6:	e0 49 01 ff 	cp.w	r9,511
800073aa:	e0 8b 00 13 	brhi	800073d0 <_malloc_r+0x158>
800073ae:	a3 99       	lsr	r9,0x3
800073b0:	f4 09 00 38 	add	r8,r10,r9<<0x3
800073b4:	70 2b       	ld.w	r11,r8[0x8]
800073b6:	8d 38       	st.w	r6[0xc],r8
800073b8:	8d 2b       	st.w	r6[0x8],r11
800073ba:	97 36       	st.w	r11[0xc],r6
800073bc:	91 26       	st.w	r8[0x8],r6
800073be:	a3 49       	asr	r9,0x2
800073c0:	74 18       	ld.w	r8,r10[0x4]
800073c2:	30 1b       	mov	r11,1
800073c4:	f6 09 09 49 	lsl	r9,r11,r9
800073c8:	f1 e9 10 09 	or	r9,r8,r9
800073cc:	95 19       	st.w	r10[0x4],r9
800073ce:	c4 78       	rjmp	8000745c <_malloc_r+0x1e4>
800073d0:	f2 0a 16 09 	lsr	r10,r9,0x9
800073d4:	58 4a       	cp.w	r10,4
800073d6:	e0 8b 00 07 	brhi	800073e4 <_malloc_r+0x16c>
800073da:	f2 0a 16 06 	lsr	r10,r9,0x6
800073de:	2c 8a       	sub	r10,-56
800073e0:	c2 08       	rjmp	80007420 <_malloc_r+0x1a8>
800073e2:	d7 03       	nop
800073e4:	59 4a       	cp.w	r10,20
800073e6:	e0 8b 00 04 	brhi	800073ee <_malloc_r+0x176>
800073ea:	2a 5a       	sub	r10,-91
800073ec:	c1 a8       	rjmp	80007420 <_malloc_r+0x1a8>
800073ee:	e0 4a 00 54 	cp.w	r10,84
800073f2:	e0 8b 00 06 	brhi	800073fe <_malloc_r+0x186>
800073f6:	f2 0a 16 0c 	lsr	r10,r9,0xc
800073fa:	29 2a       	sub	r10,-110
800073fc:	c1 28       	rjmp	80007420 <_malloc_r+0x1a8>
800073fe:	e0 4a 01 54 	cp.w	r10,340
80007402:	e0 8b 00 06 	brhi	8000740e <_malloc_r+0x196>
80007406:	f2 0a 16 0f 	lsr	r10,r9,0xf
8000740a:	28 9a       	sub	r10,-119
8000740c:	c0 a8       	rjmp	80007420 <_malloc_r+0x1a8>
8000740e:	e0 4a 05 54 	cp.w	r10,1364
80007412:	e0 88 00 04 	brls	8000741a <_malloc_r+0x1a2>
80007416:	37 ea       	mov	r10,126
80007418:	c0 48       	rjmp	80007420 <_malloc_r+0x1a8>
8000741a:	f2 0a 16 12 	lsr	r10,r9,0x12
8000741e:	28 4a       	sub	r10,-124
80007420:	e0 6b 05 3c 	mov	r11,1340
80007424:	f6 0a 00 34 	add	r4,r11,r10<<0x3
80007428:	68 28       	ld.w	r8,r4[0x8]
8000742a:	08 38       	cp.w	r8,r4
8000742c:	c0 e1       	brne	80007448 <_malloc_r+0x1d0>
8000742e:	76 19       	ld.w	r9,r11[0x4]
80007430:	a3 4a       	asr	r10,0x2
80007432:	30 1e       	mov	lr,1
80007434:	fc 0a 09 4a 	lsl	r10,lr,r10
80007438:	f3 ea 10 0a 	or	r10,r9,r10
8000743c:	10 99       	mov	r9,r8
8000743e:	97 1a       	st.w	r11[0x4],r10
80007440:	c0 a8       	rjmp	80007454 <_malloc_r+0x1dc>
80007442:	70 28       	ld.w	r8,r8[0x8]
80007444:	08 38       	cp.w	r8,r4
80007446:	c0 60       	breq	80007452 <_malloc_r+0x1da>
80007448:	70 1a       	ld.w	r10,r8[0x4]
8000744a:	e0 1a ff fc 	andl	r10,0xfffc
8000744e:	14 39       	cp.w	r9,r10
80007450:	cf 93       	brcs	80007442 <_malloc_r+0x1ca>
80007452:	70 39       	ld.w	r9,r8[0xc]
80007454:	8d 39       	st.w	r6[0xc],r9
80007456:	8d 28       	st.w	r6[0x8],r8
80007458:	91 36       	st.w	r8[0xc],r6
8000745a:	93 26       	st.w	r9[0x8],r6
8000745c:	e6 08 14 02 	asr	r8,r3,0x2
80007460:	30 1b       	mov	r11,1
80007462:	e0 64 05 3c 	mov	r4,1340
80007466:	f6 08 09 4b 	lsl	r11,r11,r8
8000746a:	68 18       	ld.w	r8,r4[0x4]
8000746c:	10 3b       	cp.w	r11,r8
8000746e:	e0 8b 00 6b 	brhi	80007544 <_malloc_r+0x2cc>
80007472:	f7 e8 00 09 	and	r9,r11,r8
80007476:	c0 b1       	brne	8000748c <_malloc_r+0x214>
80007478:	e0 13 ff fc 	andl	r3,0xfffc
8000747c:	a1 7b       	lsl	r11,0x1
8000747e:	2f c3       	sub	r3,-4
80007480:	c0 38       	rjmp	80007486 <_malloc_r+0x20e>
80007482:	2f c3       	sub	r3,-4
80007484:	a1 7b       	lsl	r11,0x1
80007486:	f7 e8 00 09 	and	r9,r11,r8
8000748a:	cf c0       	breq	80007482 <_malloc_r+0x20a>
8000748c:	e8 03 00 3e 	add	lr,r4,r3<<0x3
80007490:	06 92       	mov	r2,r3
80007492:	1c 91       	mov	r1,lr
80007494:	62 36       	ld.w	r6,r1[0xc]
80007496:	c2 e8       	rjmp	800074f2 <_malloc_r+0x27a>
80007498:	6c 1a       	ld.w	r10,r6[0x4]
8000749a:	e0 1a ff fc 	andl	r10,0xfffc
8000749e:	f4 07 01 08 	sub	r8,r10,r7
800074a2:	58 f8       	cp.w	r8,15
800074a4:	e0 8a 00 15 	brle	800074ce <_malloc_r+0x256>
800074a8:	6c 3a       	ld.w	r10,r6[0xc]
800074aa:	6c 29       	ld.w	r9,r6[0x8]
800074ac:	95 29       	st.w	r10[0x8],r9
800074ae:	93 3a       	st.w	r9[0xc],r10
800074b0:	0e 99       	mov	r9,r7
800074b2:	ec 07 00 07 	add	r7,r6,r7
800074b6:	a1 a9       	sbr	r9,0x0
800074b8:	99 37       	st.w	r12[0xc],r7
800074ba:	99 27       	st.w	r12[0x8],r7
800074bc:	8d 19       	st.w	r6[0x4],r9
800074be:	ee 08 09 08 	st.w	r7[r8],r8
800074c2:	8f 2c       	st.w	r7[0x8],r12
800074c4:	8f 3c       	st.w	r7[0xc],r12
800074c6:	a1 a8       	sbr	r8,0x0
800074c8:	0a 9c       	mov	r12,r5
800074ca:	8f 18       	st.w	r7[0x4],r8
800074cc:	c0 d8       	rjmp	800074e6 <_malloc_r+0x26e>
800074ce:	6c 39       	ld.w	r9,r6[0xc]
800074d0:	58 08       	cp.w	r8,0
800074d2:	c0 f5       	brlt	800074f0 <_malloc_r+0x278>
800074d4:	ec 0a 00 0a 	add	r10,r6,r10
800074d8:	74 18       	ld.w	r8,r10[0x4]
800074da:	a1 a8       	sbr	r8,0x0
800074dc:	0a 9c       	mov	r12,r5
800074de:	95 18       	st.w	r10[0x4],r8
800074e0:	6c 28       	ld.w	r8,r6[0x8]
800074e2:	93 28       	st.w	r9[0x8],r8
800074e4:	91 39       	st.w	r8[0xc],r9
800074e6:	fe b0 f4 b3 	rcall	80005e4c <__malloc_unlock>
800074ea:	ec cc ff f8 	sub	r12,r6,-8
800074ee:	d8 32       	popm	r0-r7,pc
800074f0:	12 96       	mov	r6,r9
800074f2:	02 36       	cp.w	r6,r1
800074f4:	cd 21       	brne	80007498 <_malloc_r+0x220>
800074f6:	2f f2       	sub	r2,-1
800074f8:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
800074fc:	c0 30       	breq	80007502 <_malloc_r+0x28a>
800074fe:	2f 81       	sub	r1,-8
80007500:	cc ab       	rjmp	80007494 <_malloc_r+0x21c>
80007502:	1c 98       	mov	r8,lr
80007504:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
80007508:	c0 81       	brne	80007518 <_malloc_r+0x2a0>
8000750a:	68 19       	ld.w	r9,r4[0x4]
8000750c:	f6 08 11 ff 	rsub	r8,r11,-1
80007510:	f3 e8 00 08 	and	r8,r9,r8
80007514:	89 18       	st.w	r4[0x4],r8
80007516:	c0 78       	rjmp	80007524 <_malloc_r+0x2ac>
80007518:	f0 c9 00 08 	sub	r9,r8,8
8000751c:	20 13       	sub	r3,1
8000751e:	70 08       	ld.w	r8,r8[0x0]
80007520:	12 38       	cp.w	r8,r9
80007522:	cf 10       	breq	80007504 <_malloc_r+0x28c>
80007524:	a1 7b       	lsl	r11,0x1
80007526:	68 18       	ld.w	r8,r4[0x4]
80007528:	10 3b       	cp.w	r11,r8
8000752a:	e0 8b 00 0d 	brhi	80007544 <_malloc_r+0x2cc>
8000752e:	58 0b       	cp.w	r11,0
80007530:	c0 a0       	breq	80007544 <_malloc_r+0x2cc>
80007532:	04 93       	mov	r3,r2
80007534:	c0 38       	rjmp	8000753a <_malloc_r+0x2c2>
80007536:	2f c3       	sub	r3,-4
80007538:	a1 7b       	lsl	r11,0x1
8000753a:	f7 e8 00 09 	and	r9,r11,r8
8000753e:	ca 71       	brne	8000748c <_malloc_r+0x214>
80007540:	cf bb       	rjmp	80007536 <_malloc_r+0x2be>
80007542:	d7 03       	nop
80007544:	68 23       	ld.w	r3,r4[0x8]
80007546:	66 12       	ld.w	r2,r3[0x4]
80007548:	e0 12 ff fc 	andl	r2,0xfffc
8000754c:	0e 32       	cp.w	r2,r7
8000754e:	5f 39       	srlo	r9
80007550:	e4 07 01 08 	sub	r8,r2,r7
80007554:	58 f8       	cp.w	r8,15
80007556:	5f aa       	srle	r10
80007558:	f5 e9 10 09 	or	r9,r10,r9
8000755c:	e0 80 00 9a 	breq	80007690 <_malloc_r+0x418>
80007560:	e0 68 0d 50 	mov	r8,3408
80007564:	70 01       	ld.w	r1,r8[0x0]
80007566:	e0 68 09 48 	mov	r8,2376
8000756a:	2f 01       	sub	r1,-16
8000756c:	70 08       	ld.w	r8,r8[0x0]
8000756e:	0e 01       	add	r1,r7
80007570:	5b f8       	cp.w	r8,-1
80007572:	c0 40       	breq	8000757a <_malloc_r+0x302>
80007574:	28 11       	sub	r1,-127
80007576:	e0 11 ff 80 	andl	r1,0xff80
8000757a:	02 9b       	mov	r11,r1
8000757c:	0a 9c       	mov	r12,r5
8000757e:	e0 a0 02 a5 	rcall	80007ac8 <_sbrk_r>
80007582:	18 96       	mov	r6,r12
80007584:	5b fc       	cp.w	r12,-1
80007586:	c7 50       	breq	80007670 <_malloc_r+0x3f8>
80007588:	e6 02 00 08 	add	r8,r3,r2
8000758c:	10 3c       	cp.w	r12,r8
8000758e:	c0 32       	brcc	80007594 <_malloc_r+0x31c>
80007590:	08 33       	cp.w	r3,r4
80007592:	c6 f1       	brne	80007670 <_malloc_r+0x3f8>
80007594:	e0 6a 0d 54 	mov	r10,3412
80007598:	74 09       	ld.w	r9,r10[0x0]
8000759a:	e2 09 00 09 	add	r9,r1,r9
8000759e:	95 09       	st.w	r10[0x0],r9
800075a0:	10 36       	cp.w	r6,r8
800075a2:	c0 a1       	brne	800075b6 <_malloc_r+0x33e>
800075a4:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
800075a8:	c0 71       	brne	800075b6 <_malloc_r+0x33e>
800075aa:	e2 02 00 02 	add	r2,r1,r2
800075ae:	68 28       	ld.w	r8,r4[0x8]
800075b0:	a1 a2       	sbr	r2,0x0
800075b2:	91 12       	st.w	r8[0x4],r2
800075b4:	c4 f8       	rjmp	80007652 <_malloc_r+0x3da>
800075b6:	e0 6a 09 48 	mov	r10,2376
800075ba:	74 0b       	ld.w	r11,r10[0x0]
800075bc:	5b fb       	cp.w	r11,-1
800075be:	c0 31       	brne	800075c4 <_malloc_r+0x34c>
800075c0:	95 06       	st.w	r10[0x0],r6
800075c2:	c0 78       	rjmp	800075d0 <_malloc_r+0x358>
800075c4:	ec 09 00 09 	add	r9,r6,r9
800075c8:	e0 6a 0d 54 	mov	r10,3412
800075cc:	10 19       	sub	r9,r8
800075ce:	95 09       	st.w	r10[0x0],r9
800075d0:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
800075d4:	f0 09 11 08 	rsub	r9,r8,8
800075d8:	58 08       	cp.w	r8,0
800075da:	f2 08 17 10 	movne	r8,r9
800075de:	ed d8 e1 06 	addne	r6,r6,r8
800075e2:	28 08       	sub	r8,-128
800075e4:	ec 01 00 01 	add	r1,r6,r1
800075e8:	0a 9c       	mov	r12,r5
800075ea:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
800075ee:	f0 01 01 01 	sub	r1,r8,r1
800075f2:	02 9b       	mov	r11,r1
800075f4:	e0 a0 02 6a 	rcall	80007ac8 <_sbrk_r>
800075f8:	e0 68 0d 54 	mov	r8,3412
800075fc:	5b fc       	cp.w	r12,-1
800075fe:	ec 0c 17 00 	moveq	r12,r6
80007602:	f9 b1 00 00 	moveq	r1,0
80007606:	70 09       	ld.w	r9,r8[0x0]
80007608:	0c 1c       	sub	r12,r6
8000760a:	89 26       	st.w	r4[0x8],r6
8000760c:	02 0c       	add	r12,r1
8000760e:	12 01       	add	r1,r9
80007610:	a1 ac       	sbr	r12,0x0
80007612:	91 01       	st.w	r8[0x0],r1
80007614:	8d 1c       	st.w	r6[0x4],r12
80007616:	08 33       	cp.w	r3,r4
80007618:	c1 d0       	breq	80007652 <_malloc_r+0x3da>
8000761a:	58 f2       	cp.w	r2,15
8000761c:	e0 8b 00 05 	brhi	80007626 <_malloc_r+0x3ae>
80007620:	30 18       	mov	r8,1
80007622:	8d 18       	st.w	r6[0x4],r8
80007624:	c2 68       	rjmp	80007670 <_malloc_r+0x3f8>
80007626:	30 59       	mov	r9,5
80007628:	20 c2       	sub	r2,12
8000762a:	e0 12 ff f8 	andl	r2,0xfff8
8000762e:	e6 02 00 08 	add	r8,r3,r2
80007632:	91 29       	st.w	r8[0x8],r9
80007634:	91 19       	st.w	r8[0x4],r9
80007636:	66 18       	ld.w	r8,r3[0x4]
80007638:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000763c:	e5 e8 10 08 	or	r8,r2,r8
80007640:	87 18       	st.w	r3[0x4],r8
80007642:	58 f2       	cp.w	r2,15
80007644:	e0 88 00 07 	brls	80007652 <_malloc_r+0x3da>
80007648:	e6 cb ff f8 	sub	r11,r3,-8
8000764c:	0a 9c       	mov	r12,r5
8000764e:	e0 a0 1c 6b 	rcall	8000af24 <_free_r>
80007652:	e0 69 0d 4c 	mov	r9,3404
80007656:	72 0a       	ld.w	r10,r9[0x0]
80007658:	e0 68 0d 54 	mov	r8,3412
8000765c:	70 08       	ld.w	r8,r8[0x0]
8000765e:	14 38       	cp.w	r8,r10
80007660:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80007664:	e0 69 0d 48 	mov	r9,3400
80007668:	72 0a       	ld.w	r10,r9[0x0]
8000766a:	14 38       	cp.w	r8,r10
8000766c:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80007670:	68 28       	ld.w	r8,r4[0x8]
80007672:	70 18       	ld.w	r8,r8[0x4]
80007674:	e0 18 ff fc 	andl	r8,0xfffc
80007678:	0e 38       	cp.w	r8,r7
8000767a:	5f 39       	srlo	r9
8000767c:	0e 18       	sub	r8,r7
8000767e:	58 f8       	cp.w	r8,15
80007680:	5f aa       	srle	r10
80007682:	f5 e9 10 09 	or	r9,r10,r9
80007686:	c0 50       	breq	80007690 <_malloc_r+0x418>
80007688:	0a 9c       	mov	r12,r5
8000768a:	fe b0 f3 e1 	rcall	80005e4c <__malloc_unlock>
8000768e:	d8 3a       	popm	r0-r7,pc,r12=0
80007690:	68 26       	ld.w	r6,r4[0x8]
80007692:	a1 a8       	sbr	r8,0x0
80007694:	0e 99       	mov	r9,r7
80007696:	a1 a9       	sbr	r9,0x0
80007698:	8d 19       	st.w	r6[0x4],r9
8000769a:	ec 07 00 07 	add	r7,r6,r7
8000769e:	0a 9c       	mov	r12,r5
800076a0:	89 27       	st.w	r4[0x8],r7
800076a2:	8f 18       	st.w	r7[0x4],r8
800076a4:	fe b0 f3 d4 	rcall	80005e4c <__malloc_unlock>
800076a8:	ec cc ff f8 	sub	r12,r6,-8
800076ac:	d8 32       	popm	r0-r7,pc
800076ae:	d7 03       	nop

800076b0 <memcpy>:
800076b0:	58 8a       	cp.w	r10,8
800076b2:	c2 f5       	brlt	80007710 <memcpy+0x60>
800076b4:	f9 eb 10 09 	or	r9,r12,r11
800076b8:	e2 19 00 03 	andl	r9,0x3,COH
800076bc:	e0 81 00 97 	brne	800077ea <memcpy+0x13a>
800076c0:	e0 4a 00 20 	cp.w	r10,32
800076c4:	c3 b4       	brge	8000773a <memcpy+0x8a>
800076c6:	f4 08 14 02 	asr	r8,r10,0x2
800076ca:	f0 09 11 08 	rsub	r9,r8,8
800076ce:	fe 09 00 2f 	add	pc,pc,r9<<0x2
800076d2:	76 69       	ld.w	r9,r11[0x18]
800076d4:	99 69       	st.w	r12[0x18],r9
800076d6:	76 59       	ld.w	r9,r11[0x14]
800076d8:	99 59       	st.w	r12[0x14],r9
800076da:	76 49       	ld.w	r9,r11[0x10]
800076dc:	99 49       	st.w	r12[0x10],r9
800076de:	76 39       	ld.w	r9,r11[0xc]
800076e0:	99 39       	st.w	r12[0xc],r9
800076e2:	76 29       	ld.w	r9,r11[0x8]
800076e4:	99 29       	st.w	r12[0x8],r9
800076e6:	76 19       	ld.w	r9,r11[0x4]
800076e8:	99 19       	st.w	r12[0x4],r9
800076ea:	76 09       	ld.w	r9,r11[0x0]
800076ec:	99 09       	st.w	r12[0x0],r9
800076ee:	f6 08 00 2b 	add	r11,r11,r8<<0x2
800076f2:	f8 08 00 28 	add	r8,r12,r8<<0x2
800076f6:	e0 1a 00 03 	andl	r10,0x3
800076fa:	f4 0a 11 04 	rsub	r10,r10,4
800076fe:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
80007702:	17 a9       	ld.ub	r9,r11[0x2]
80007704:	b0 a9       	st.b	r8[0x2],r9
80007706:	17 99       	ld.ub	r9,r11[0x1]
80007708:	b0 99       	st.b	r8[0x1],r9
8000770a:	17 89       	ld.ub	r9,r11[0x0]
8000770c:	b0 89       	st.b	r8[0x0],r9
8000770e:	5e fc       	retal	r12
80007710:	f4 0a 11 09 	rsub	r10,r10,9
80007714:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
80007718:	17 f9       	ld.ub	r9,r11[0x7]
8000771a:	b8 f9       	st.b	r12[0x7],r9
8000771c:	17 e9       	ld.ub	r9,r11[0x6]
8000771e:	b8 e9       	st.b	r12[0x6],r9
80007720:	17 d9       	ld.ub	r9,r11[0x5]
80007722:	b8 d9       	st.b	r12[0x5],r9
80007724:	17 c9       	ld.ub	r9,r11[0x4]
80007726:	b8 c9       	st.b	r12[0x4],r9
80007728:	17 b9       	ld.ub	r9,r11[0x3]
8000772a:	b8 b9       	st.b	r12[0x3],r9
8000772c:	17 a9       	ld.ub	r9,r11[0x2]
8000772e:	b8 a9       	st.b	r12[0x2],r9
80007730:	17 99       	ld.ub	r9,r11[0x1]
80007732:	b8 99       	st.b	r12[0x1],r9
80007734:	17 89       	ld.ub	r9,r11[0x0]
80007736:	b8 89       	st.b	r12[0x0],r9
80007738:	5e fc       	retal	r12
8000773a:	eb cd 40 c0 	pushm	r6-r7,lr
8000773e:	18 99       	mov	r9,r12
80007740:	22 0a       	sub	r10,32
80007742:	b7 07       	ld.d	r6,r11++
80007744:	b3 26       	st.d	r9++,r6
80007746:	b7 07       	ld.d	r6,r11++
80007748:	b3 26       	st.d	r9++,r6
8000774a:	b7 07       	ld.d	r6,r11++
8000774c:	b3 26       	st.d	r9++,r6
8000774e:	b7 07       	ld.d	r6,r11++
80007750:	b3 26       	st.d	r9++,r6
80007752:	22 0a       	sub	r10,32
80007754:	cf 74       	brge	80007742 <memcpy+0x92>
80007756:	2f 0a       	sub	r10,-16
80007758:	c0 65       	brlt	80007764 <memcpy+0xb4>
8000775a:	b7 07       	ld.d	r6,r11++
8000775c:	b3 26       	st.d	r9++,r6
8000775e:	b7 07       	ld.d	r6,r11++
80007760:	b3 26       	st.d	r9++,r6
80007762:	21 0a       	sub	r10,16
80007764:	5c 3a       	neg	r10
80007766:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
8000776a:	d7 03       	nop
8000776c:	d7 03       	nop
8000776e:	f7 36 00 0e 	ld.ub	r6,r11[14]
80007772:	f3 66 00 0e 	st.b	r9[14],r6
80007776:	f7 36 00 0d 	ld.ub	r6,r11[13]
8000777a:	f3 66 00 0d 	st.b	r9[13],r6
8000777e:	f7 36 00 0c 	ld.ub	r6,r11[12]
80007782:	f3 66 00 0c 	st.b	r9[12],r6
80007786:	f7 36 00 0b 	ld.ub	r6,r11[11]
8000778a:	f3 66 00 0b 	st.b	r9[11],r6
8000778e:	f7 36 00 0a 	ld.ub	r6,r11[10]
80007792:	f3 66 00 0a 	st.b	r9[10],r6
80007796:	f7 36 00 09 	ld.ub	r6,r11[9]
8000779a:	f3 66 00 09 	st.b	r9[9],r6
8000779e:	f7 36 00 08 	ld.ub	r6,r11[8]
800077a2:	f3 66 00 08 	st.b	r9[8],r6
800077a6:	f7 36 00 07 	ld.ub	r6,r11[7]
800077aa:	f3 66 00 07 	st.b	r9[7],r6
800077ae:	f7 36 00 06 	ld.ub	r6,r11[6]
800077b2:	f3 66 00 06 	st.b	r9[6],r6
800077b6:	f7 36 00 05 	ld.ub	r6,r11[5]
800077ba:	f3 66 00 05 	st.b	r9[5],r6
800077be:	f7 36 00 04 	ld.ub	r6,r11[4]
800077c2:	f3 66 00 04 	st.b	r9[4],r6
800077c6:	f7 36 00 03 	ld.ub	r6,r11[3]
800077ca:	f3 66 00 03 	st.b	r9[3],r6
800077ce:	f7 36 00 02 	ld.ub	r6,r11[2]
800077d2:	f3 66 00 02 	st.b	r9[2],r6
800077d6:	f7 36 00 01 	ld.ub	r6,r11[1]
800077da:	f3 66 00 01 	st.b	r9[1],r6
800077de:	f7 36 00 00 	ld.ub	r6,r11[0]
800077e2:	f3 66 00 00 	st.b	r9[0],r6
800077e6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800077ea:	20 1a       	sub	r10,1
800077ec:	f6 0a 07 09 	ld.ub	r9,r11[r10]
800077f0:	f8 0a 0b 09 	st.b	r12[r10],r9
800077f4:	cf b1       	brne	800077ea <memcpy+0x13a>
800077f6:	5e fc       	retal	r12

800077f8 <memset>:
800077f8:	18 98       	mov	r8,r12
800077fa:	c0 38       	rjmp	80007800 <memset+0x8>
800077fc:	10 cb       	st.b	r8++,r11
800077fe:	20 1a       	sub	r10,1
80007800:	58 0a       	cp.w	r10,0
80007802:	cf d1       	brne	800077fc <memset+0x4>
80007804:	5e fc       	retal	r12
80007806:	d7 03       	nop

80007808 <_realloc_r>:
80007808:	d4 31       	pushm	r0-r7,lr
8000780a:	20 1d       	sub	sp,4
8000780c:	16 94       	mov	r4,r11
8000780e:	18 92       	mov	r2,r12
80007810:	14 9b       	mov	r11,r10
80007812:	58 04       	cp.w	r4,0
80007814:	c0 51       	brne	8000781e <_realloc_r+0x16>
80007816:	fe b0 fd 31 	rcall	80007278 <_malloc_r>
8000781a:	18 95       	mov	r5,r12
8000781c:	c5 39       	rjmp	80007ac2 <_realloc_r+0x2ba>
8000781e:	50 0a       	stdsp	sp[0x0],r10
80007820:	fe b0 f3 10 	rcall	80005e40 <__malloc_lock>
80007824:	40 0b       	lddsp	r11,sp[0x0]
80007826:	f6 c8 ff f5 	sub	r8,r11,-11
8000782a:	e8 c1 00 08 	sub	r1,r4,8
8000782e:	10 96       	mov	r6,r8
80007830:	62 1c       	ld.w	r12,r1[0x4]
80007832:	e0 16 ff f8 	andl	r6,0xfff8
80007836:	59 68       	cp.w	r8,22
80007838:	f9 b6 08 10 	movls	r6,16
8000783c:	16 36       	cp.w	r6,r11
8000783e:	5f 38       	srlo	r8
80007840:	f1 e6 13 f8 	or	r8,r8,r6>>0x1f
80007844:	c0 50       	breq	8000784e <_realloc_r+0x46>
80007846:	30 c8       	mov	r8,12
80007848:	30 05       	mov	r5,0
8000784a:	85 38       	st.w	r2[0xc],r8
8000784c:	c3 b9       	rjmp	80007ac2 <_realloc_r+0x2ba>
8000784e:	18 90       	mov	r0,r12
80007850:	e0 10 ff fc 	andl	r0,0xfffc
80007854:	0c 30       	cp.w	r0,r6
80007856:	e0 84 01 0b 	brge	80007a6c <_realloc_r+0x264>
8000785a:	e0 68 05 3c 	mov	r8,1340
8000785e:	e2 00 00 09 	add	r9,r1,r0
80007862:	70 25       	ld.w	r5,r8[0x8]
80007864:	0a 39       	cp.w	r9,r5
80007866:	c0 90       	breq	80007878 <_realloc_r+0x70>
80007868:	72 1a       	ld.w	r10,r9[0x4]
8000786a:	a1 ca       	cbr	r10,0x0
8000786c:	f2 0a 00 0a 	add	r10,r9,r10
80007870:	74 1a       	ld.w	r10,r10[0x4]
80007872:	ed ba 00 00 	bld	r10,0x0
80007876:	c2 20       	breq	800078ba <_realloc_r+0xb2>
80007878:	72 1a       	ld.w	r10,r9[0x4]
8000787a:	e0 1a ff fc 	andl	r10,0xfffc
8000787e:	f4 00 00 03 	add	r3,r10,r0
80007882:	0a 39       	cp.w	r9,r5
80007884:	c1 31       	brne	800078aa <_realloc_r+0xa2>
80007886:	ec c7 ff f0 	sub	r7,r6,-16
8000788a:	0e 33       	cp.w	r3,r7
8000788c:	c1 95       	brlt	800078be <_realloc_r+0xb6>
8000788e:	e2 06 00 09 	add	r9,r1,r6
80007892:	0c 13       	sub	r3,r6
80007894:	a1 a3       	sbr	r3,0x0
80007896:	93 13       	st.w	r9[0x4],r3
80007898:	91 29       	st.w	r8[0x8],r9
8000789a:	04 9c       	mov	r12,r2
8000789c:	62 18       	ld.w	r8,r1[0x4]
8000789e:	08 95       	mov	r5,r4
800078a0:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800078a4:	10 46       	or	r6,r8
800078a6:	83 16       	st.w	r1[0x4],r6
800078a8:	c0 b9       	rjmp	80007abe <_realloc_r+0x2b6>
800078aa:	0c 33       	cp.w	r3,r6
800078ac:	c0 95       	brlt	800078be <_realloc_r+0xb6>
800078ae:	72 28       	ld.w	r8,r9[0x8]
800078b0:	02 97       	mov	r7,r1
800078b2:	72 39       	ld.w	r9,r9[0xc]
800078b4:	93 28       	st.w	r9[0x8],r8
800078b6:	91 39       	st.w	r8[0xc],r9
800078b8:	cd c8       	rjmp	80007a70 <_realloc_r+0x268>
800078ba:	30 0a       	mov	r10,0
800078bc:	14 99       	mov	r9,r10
800078be:	ed bc 00 00 	bld	r12,0x0
800078c2:	e0 80 00 95 	breq	800079ec <_realloc_r+0x1e4>
800078c6:	62 07       	ld.w	r7,r1[0x0]
800078c8:	e2 07 01 07 	sub	r7,r1,r7
800078cc:	6e 1c       	ld.w	r12,r7[0x4]
800078ce:	e0 1c ff fc 	andl	r12,0xfffc
800078d2:	58 09       	cp.w	r9,0
800078d4:	c5 60       	breq	80007980 <_realloc_r+0x178>
800078d6:	f8 00 00 03 	add	r3,r12,r0
800078da:	0a 39       	cp.w	r9,r5
800078dc:	c4 81       	brne	8000796c <_realloc_r+0x164>
800078de:	14 03       	add	r3,r10
800078e0:	ec c9 ff f0 	sub	r9,r6,-16
800078e4:	12 33       	cp.w	r3,r9
800078e6:	c4 d5       	brlt	80007980 <_realloc_r+0x178>
800078e8:	6e 3a       	ld.w	r10,r7[0xc]
800078ea:	6e 29       	ld.w	r9,r7[0x8]
800078ec:	95 29       	st.w	r10[0x8],r9
800078ee:	93 3a       	st.w	r9[0xc],r10
800078f0:	ee c5 ff f8 	sub	r5,r7,-8
800078f4:	e0 ca 00 04 	sub	r10,r0,4
800078f8:	e0 4a 00 24 	cp.w	r10,36
800078fc:	e0 8b 00 25 	brhi	80007946 <_realloc_r+0x13e>
80007900:	0a 99       	mov	r9,r5
80007902:	59 3a       	cp.w	r10,19
80007904:	e0 88 00 1a 	brls	80007938 <_realloc_r+0x130>
80007908:	09 09       	ld.w	r9,r4++
8000790a:	8b 09       	st.w	r5[0x0],r9
8000790c:	09 09       	ld.w	r9,r4++
8000790e:	8f 39       	st.w	r7[0xc],r9
80007910:	ee c9 ff f0 	sub	r9,r7,-16
80007914:	59 ba       	cp.w	r10,27
80007916:	e0 88 00 11 	brls	80007938 <_realloc_r+0x130>
8000791a:	09 0b       	ld.w	r11,r4++
8000791c:	93 0b       	st.w	r9[0x0],r11
8000791e:	09 09       	ld.w	r9,r4++
80007920:	8f 59       	st.w	r7[0x14],r9
80007922:	ee c9 ff e8 	sub	r9,r7,-24
80007926:	e0 4a 00 24 	cp.w	r10,36
8000792a:	c0 71       	brne	80007938 <_realloc_r+0x130>
8000792c:	09 0a       	ld.w	r10,r4++
8000792e:	93 0a       	st.w	r9[0x0],r10
80007930:	ee c9 ff e0 	sub	r9,r7,-32
80007934:	09 0a       	ld.w	r10,r4++
80007936:	8f 7a       	st.w	r7[0x1c],r10
80007938:	09 0a       	ld.w	r10,r4++
8000793a:	12 aa       	st.w	r9++,r10
8000793c:	68 0a       	ld.w	r10,r4[0x0]
8000793e:	93 0a       	st.w	r9[0x0],r10
80007940:	68 1a       	ld.w	r10,r4[0x4]
80007942:	93 1a       	st.w	r9[0x4],r10
80007944:	c0 78       	rjmp	80007952 <_realloc_r+0x14a>
80007946:	50 08       	stdsp	sp[0x0],r8
80007948:	08 9b       	mov	r11,r4
8000794a:	0a 9c       	mov	r12,r5
8000794c:	e0 a0 1d 8f 	rcall	8000b46a <memmove>
80007950:	40 08       	lddsp	r8,sp[0x0]
80007952:	ee 06 00 09 	add	r9,r7,r6
80007956:	0c 13       	sub	r3,r6
80007958:	a1 a3       	sbr	r3,0x0
8000795a:	93 13       	st.w	r9[0x4],r3
8000795c:	91 29       	st.w	r8[0x8],r9
8000795e:	04 9c       	mov	r12,r2
80007960:	6e 18       	ld.w	r8,r7[0x4]
80007962:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007966:	10 46       	or	r6,r8
80007968:	8f 16       	st.w	r7[0x4],r6
8000796a:	ca a8       	rjmp	80007abe <_realloc_r+0x2b6>
8000796c:	14 03       	add	r3,r10
8000796e:	0c 33       	cp.w	r3,r6
80007970:	c0 85       	brlt	80007980 <_realloc_r+0x178>
80007972:	72 28       	ld.w	r8,r9[0x8]
80007974:	72 39       	ld.w	r9,r9[0xc]
80007976:	93 28       	st.w	r9[0x8],r8
80007978:	91 39       	st.w	r8[0xc],r9
8000797a:	6e 28       	ld.w	r8,r7[0x8]
8000797c:	6e 39       	ld.w	r9,r7[0xc]
8000797e:	c0 78       	rjmp	8000798c <_realloc_r+0x184>
80007980:	f8 00 00 03 	add	r3,r12,r0
80007984:	0c 33       	cp.w	r3,r6
80007986:	c3 35       	brlt	800079ec <_realloc_r+0x1e4>
80007988:	6e 39       	ld.w	r9,r7[0xc]
8000798a:	6e 28       	ld.w	r8,r7[0x8]
8000798c:	93 28       	st.w	r9[0x8],r8
8000798e:	91 39       	st.w	r8[0xc],r9
80007990:	e0 ca 00 04 	sub	r10,r0,4
80007994:	ee cc ff f8 	sub	r12,r7,-8
80007998:	e0 4a 00 24 	cp.w	r10,36
8000799c:	e0 8b 00 24 	brhi	800079e4 <_realloc_r+0x1dc>
800079a0:	59 3a       	cp.w	r10,19
800079a2:	e0 88 00 1a 	brls	800079d6 <_realloc_r+0x1ce>
800079a6:	09 08       	ld.w	r8,r4++
800079a8:	99 08       	st.w	r12[0x0],r8
800079aa:	09 08       	ld.w	r8,r4++
800079ac:	8f 38       	st.w	r7[0xc],r8
800079ae:	ee cc ff f0 	sub	r12,r7,-16
800079b2:	59 ba       	cp.w	r10,27
800079b4:	e0 88 00 11 	brls	800079d6 <_realloc_r+0x1ce>
800079b8:	09 08       	ld.w	r8,r4++
800079ba:	99 08       	st.w	r12[0x0],r8
800079bc:	09 08       	ld.w	r8,r4++
800079be:	8f 58       	st.w	r7[0x14],r8
800079c0:	ee cc ff e8 	sub	r12,r7,-24
800079c4:	e0 4a 00 24 	cp.w	r10,36
800079c8:	c0 71       	brne	800079d6 <_realloc_r+0x1ce>
800079ca:	09 08       	ld.w	r8,r4++
800079cc:	99 08       	st.w	r12[0x0],r8
800079ce:	ee cc ff e0 	sub	r12,r7,-32
800079d2:	09 08       	ld.w	r8,r4++
800079d4:	8f 78       	st.w	r7[0x1c],r8
800079d6:	09 08       	ld.w	r8,r4++
800079d8:	18 a8       	st.w	r12++,r8
800079da:	68 08       	ld.w	r8,r4[0x0]
800079dc:	99 08       	st.w	r12[0x0],r8
800079de:	68 18       	ld.w	r8,r4[0x4]
800079e0:	99 18       	st.w	r12[0x4],r8
800079e2:	c4 78       	rjmp	80007a70 <_realloc_r+0x268>
800079e4:	08 9b       	mov	r11,r4
800079e6:	e0 a0 1d 42 	rcall	8000b46a <memmove>
800079ea:	c4 38       	rjmp	80007a70 <_realloc_r+0x268>
800079ec:	04 9c       	mov	r12,r2
800079ee:	fe b0 fc 45 	rcall	80007278 <_malloc_r>
800079f2:	18 95       	mov	r5,r12
800079f4:	c3 a0       	breq	80007a68 <_realloc_r+0x260>
800079f6:	62 18       	ld.w	r8,r1[0x4]
800079f8:	f8 c9 00 08 	sub	r9,r12,8
800079fc:	a1 c8       	cbr	r8,0x0
800079fe:	e2 08 00 08 	add	r8,r1,r8
80007a02:	10 39       	cp.w	r9,r8
80007a04:	c0 71       	brne	80007a12 <_realloc_r+0x20a>
80007a06:	72 13       	ld.w	r3,r9[0x4]
80007a08:	02 97       	mov	r7,r1
80007a0a:	e0 13 ff fc 	andl	r3,0xfffc
80007a0e:	00 03       	add	r3,r0
80007a10:	c3 08       	rjmp	80007a70 <_realloc_r+0x268>
80007a12:	e0 ca 00 04 	sub	r10,r0,4
80007a16:	e0 4a 00 24 	cp.w	r10,36
80007a1a:	e0 8b 00 20 	brhi	80007a5a <_realloc_r+0x252>
80007a1e:	08 99       	mov	r9,r4
80007a20:	18 98       	mov	r8,r12
80007a22:	59 3a       	cp.w	r10,19
80007a24:	e0 88 00 14 	brls	80007a4c <_realloc_r+0x244>
80007a28:	13 0b       	ld.w	r11,r9++
80007a2a:	10 ab       	st.w	r8++,r11
80007a2c:	13 0b       	ld.w	r11,r9++
80007a2e:	10 ab       	st.w	r8++,r11
80007a30:	59 ba       	cp.w	r10,27
80007a32:	e0 88 00 0d 	brls	80007a4c <_realloc_r+0x244>
80007a36:	13 0b       	ld.w	r11,r9++
80007a38:	10 ab       	st.w	r8++,r11
80007a3a:	13 0b       	ld.w	r11,r9++
80007a3c:	10 ab       	st.w	r8++,r11
80007a3e:	e0 4a 00 24 	cp.w	r10,36
80007a42:	c0 51       	brne	80007a4c <_realloc_r+0x244>
80007a44:	13 0a       	ld.w	r10,r9++
80007a46:	10 aa       	st.w	r8++,r10
80007a48:	13 0a       	ld.w	r10,r9++
80007a4a:	10 aa       	st.w	r8++,r10
80007a4c:	13 0a       	ld.w	r10,r9++
80007a4e:	10 aa       	st.w	r8++,r10
80007a50:	72 0a       	ld.w	r10,r9[0x0]
80007a52:	91 0a       	st.w	r8[0x0],r10
80007a54:	72 19       	ld.w	r9,r9[0x4]
80007a56:	91 19       	st.w	r8[0x4],r9
80007a58:	c0 48       	rjmp	80007a60 <_realloc_r+0x258>
80007a5a:	08 9b       	mov	r11,r4
80007a5c:	e0 a0 1d 07 	rcall	8000b46a <memmove>
80007a60:	08 9b       	mov	r11,r4
80007a62:	04 9c       	mov	r12,r2
80007a64:	e0 a0 1a 60 	rcall	8000af24 <_free_r>
80007a68:	04 9c       	mov	r12,r2
80007a6a:	c2 a8       	rjmp	80007abe <_realloc_r+0x2b6>
80007a6c:	00 93       	mov	r3,r0
80007a6e:	02 97       	mov	r7,r1
80007a70:	e6 06 01 09 	sub	r9,r3,r6
80007a74:	6e 18       	ld.w	r8,r7[0x4]
80007a76:	58 f9       	cp.w	r9,15
80007a78:	e0 88 00 16 	brls	80007aa4 <_realloc_r+0x29c>
80007a7c:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007a80:	ed e8 10 08 	or	r8,r6,r8
80007a84:	8f 18       	st.w	r7[0x4],r8
80007a86:	12 98       	mov	r8,r9
80007a88:	a1 a8       	sbr	r8,0x0
80007a8a:	ee 06 00 0b 	add	r11,r7,r6
80007a8e:	f6 09 00 09 	add	r9,r11,r9
80007a92:	97 18       	st.w	r11[0x4],r8
80007a94:	72 18       	ld.w	r8,r9[0x4]
80007a96:	a1 a8       	sbr	r8,0x0
80007a98:	2f 8b       	sub	r11,-8
80007a9a:	93 18       	st.w	r9[0x4],r8
80007a9c:	04 9c       	mov	r12,r2
80007a9e:	e0 a0 1a 43 	rcall	8000af24 <_free_r>
80007aa2:	c0 b8       	rjmp	80007ab8 <_realloc_r+0x2b0>
80007aa4:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007aa8:	e7 e8 10 08 	or	r8,r3,r8
80007aac:	8f 18       	st.w	r7[0x4],r8
80007aae:	ee 03 00 03 	add	r3,r7,r3
80007ab2:	66 18       	ld.w	r8,r3[0x4]
80007ab4:	a1 a8       	sbr	r8,0x0
80007ab6:	87 18       	st.w	r3[0x4],r8
80007ab8:	04 9c       	mov	r12,r2
80007aba:	ee c5 ff f8 	sub	r5,r7,-8
80007abe:	fe b0 f1 c7 	rcall	80005e4c <__malloc_unlock>
80007ac2:	0a 9c       	mov	r12,r5
80007ac4:	2f fd       	sub	sp,-4
80007ac6:	d8 32       	popm	r0-r7,pc

80007ac8 <_sbrk_r>:
80007ac8:	d4 21       	pushm	r4-r7,lr
80007aca:	30 08       	mov	r8,0
80007acc:	18 97       	mov	r7,r12
80007ace:	e0 66 51 2c 	mov	r6,20780
80007ad2:	16 9c       	mov	r12,r11
80007ad4:	8d 08       	st.w	r6[0x0],r8
80007ad6:	c8 5c       	rcall	80007be0 <_sbrk>
80007ad8:	5b fc       	cp.w	r12,-1
80007ada:	c0 51       	brne	80007ae4 <_sbrk_r+0x1c>
80007adc:	6c 08       	ld.w	r8,r6[0x0]
80007ade:	58 08       	cp.w	r8,0
80007ae0:	ef f8 1a 03 	st.wne	r7[0xc],r8
80007ae4:	d8 22       	popm	r4-r7,pc
80007ae6:	d7 03       	nop

80007ae8 <sprintf>:
80007ae8:	d4 01       	pushm	lr
80007aea:	21 7d       	sub	sp,92
80007aec:	e0 68 ff ff 	mov	r8,65535
80007af0:	ea 18 7f ff 	orh	r8,0x7fff
80007af4:	50 58       	stdsp	sp[0x14],r8
80007af6:	50 28       	stdsp	sp[0x8],r8
80007af8:	e0 68 02 08 	mov	r8,520
80007afc:	ba 68       	st.h	sp[0xc],r8
80007afe:	3f f8       	mov	r8,-1
80007b00:	ba 78       	st.h	sp[0xe],r8
80007b02:	e0 68 0a 3c 	mov	r8,2620
80007b06:	50 4c       	stdsp	sp[0x10],r12
80007b08:	16 9a       	mov	r10,r11
80007b0a:	50 0c       	stdsp	sp[0x0],r12
80007b0c:	fa c9 ff a0 	sub	r9,sp,-96
80007b10:	70 0c       	ld.w	r12,r8[0x0]
80007b12:	1a 9b       	mov	r11,sp
80007b14:	e0 a0 02 1a 	rcall	80007f48 <_vfprintf_r>
80007b18:	30 09       	mov	r9,0
80007b1a:	40 08       	lddsp	r8,sp[0x0]
80007b1c:	b0 89       	st.b	r8[0x0],r9
80007b1e:	2e 9d       	sub	sp,-92
80007b20:	d8 02       	popm	pc
80007b22:	d7 03       	nop

80007b24 <strncpy>:
80007b24:	30 08       	mov	r8,0
80007b26:	10 3a       	cp.w	r10,r8
80007b28:	5e 0c       	reteq	r12
80007b2a:	f6 08 07 09 	ld.ub	r9,r11[r8]
80007b2e:	f8 08 0b 09 	st.b	r12[r8],r9
80007b32:	2f f8       	sub	r8,-1
80007b34:	58 09       	cp.w	r9,0
80007b36:	cf 81       	brne	80007b26 <strncpy+0x2>
80007b38:	10 3a       	cp.w	r10,r8
80007b3a:	5e 0c       	reteq	r12
80007b3c:	f8 08 0b 09 	st.b	r12[r8],r9
80007b40:	2f f8       	sub	r8,-1
80007b42:	cf bb       	rjmp	80007b38 <strncpy+0x14>

80007b44 <_close>:
80007b44:	30 28       	mov	r8,2
80007b46:	d6 73       	breakpoint
80007b48:	3f fc       	mov	r12,-1
80007b4a:	35 8b       	mov	r11,88
80007b4c:	58 0c       	cp.w	r12,0
80007b4e:	5e 4c       	retge	r12
80007b50:	e0 6a 51 2c 	mov	r10,20780
80007b54:	95 0b       	st.w	r10[0x0],r11
80007b56:	5e fc       	retal	r12

80007b58 <_lseek>:
80007b58:	30 58       	mov	r8,5
80007b5a:	d6 73       	breakpoint
80007b5c:	3f fc       	mov	r12,-1
80007b5e:	35 8b       	mov	r11,88
80007b60:	58 0c       	cp.w	r12,0
80007b62:	5e 4c       	retge	r12
80007b64:	e0 6a 51 2c 	mov	r10,20780
80007b68:	95 0b       	st.w	r10[0x0],r11
80007b6a:	5e fc       	retal	r12

80007b6c <isatty>:
80007b6c:	30 b8       	mov	r8,11
80007b6e:	d6 73       	breakpoint
80007b70:	3f fc       	mov	r12,-1
80007b72:	35 8b       	mov	r11,88
80007b74:	58 0c       	cp.w	r12,0
80007b76:	5e 4c       	retge	r12
80007b78:	e0 6a 51 2c 	mov	r10,20780
80007b7c:	95 0b       	st.w	r10[0x0],r11
80007b7e:	5e fc       	retal	r12

80007b80 <_fstat_host>:
80007b80:	30 98       	mov	r8,9
80007b82:	d6 73       	breakpoint
80007b84:	3f fc       	mov	r12,-1
80007b86:	35 8b       	mov	r11,88
80007b88:	58 0c       	cp.w	r12,0
80007b8a:	5e 4c       	retge	r12
80007b8c:	e0 6a 51 2c 	mov	r10,20780
80007b90:	95 0b       	st.w	r10[0x0],r11
80007b92:	5e fc       	retal	r12

80007b94 <_fstat>:
80007b94:	d4 21       	pushm	r4-r7,lr
80007b96:	21 0d       	sub	sp,64
80007b98:	16 97       	mov	r7,r11
80007b9a:	1a 9b       	mov	r11,sp
80007b9c:	cf 2f       	rcall	80007b80 <_fstat_host>
80007b9e:	c0 34       	brge	80007ba4 <_fstat+0x10>
80007ba0:	3f fc       	mov	r12,-1
80007ba2:	c1 c8       	rjmp	80007bda <_fstat+0x46>
80007ba4:	40 08       	lddsp	r8,sp[0x0]
80007ba6:	ae 08       	st.h	r7[0x0],r8
80007ba8:	40 18       	lddsp	r8,sp[0x4]
80007baa:	ae 18       	st.h	r7[0x2],r8
80007bac:	40 28       	lddsp	r8,sp[0x8]
80007bae:	8f 18       	st.w	r7[0x4],r8
80007bb0:	40 38       	lddsp	r8,sp[0xc]
80007bb2:	ae 48       	st.h	r7[0x8],r8
80007bb4:	40 48       	lddsp	r8,sp[0x10]
80007bb6:	ae 58       	st.h	r7[0xa],r8
80007bb8:	40 58       	lddsp	r8,sp[0x14]
80007bba:	ae 68       	st.h	r7[0xc],r8
80007bbc:	40 68       	lddsp	r8,sp[0x18]
80007bbe:	ae 78       	st.h	r7[0xe],r8
80007bc0:	40 88       	lddsp	r8,sp[0x20]
80007bc2:	8f 48       	st.w	r7[0x10],r8
80007bc4:	40 a8       	lddsp	r8,sp[0x28]
80007bc6:	8f b8       	st.w	r7[0x2c],r8
80007bc8:	40 c8       	lddsp	r8,sp[0x30]
80007bca:	8f c8       	st.w	r7[0x30],r8
80007bcc:	40 d8       	lddsp	r8,sp[0x34]
80007bce:	8f 58       	st.w	r7[0x14],r8
80007bd0:	40 e8       	lddsp	r8,sp[0x38]
80007bd2:	30 0c       	mov	r12,0
80007bd4:	8f 78       	st.w	r7[0x1c],r8
80007bd6:	40 f8       	lddsp	r8,sp[0x3c]
80007bd8:	8f 98       	st.w	r7[0x24],r8
80007bda:	2f 0d       	sub	sp,-64
80007bdc:	d8 22       	popm	r4-r7,pc
80007bde:	d7 03       	nop

80007be0 <_sbrk>:
80007be0:	d4 01       	pushm	lr
80007be2:	e0 68 0d 7c 	mov	r8,3452
80007be6:	70 09       	ld.w	r9,r8[0x0]
80007be8:	58 09       	cp.w	r9,0
80007bea:	c0 41       	brne	80007bf2 <_sbrk+0x12>
80007bec:	e0 69 51 30 	mov	r9,20784
80007bf0:	91 09       	st.w	r8[0x0],r9
80007bf2:	e0 69 0d 7c 	mov	r9,3452
80007bf6:	e0 7a 70 00 	mov	r10,94208
80007bfa:	72 08       	ld.w	r8,r9[0x0]
80007bfc:	f0 0c 00 0c 	add	r12,r8,r12
80007c00:	14 3c       	cp.w	r12,r10
80007c02:	e0 8b 00 04 	brhi	80007c0a <_sbrk+0x2a>
80007c06:	93 0c       	st.w	r9[0x0],r12
80007c08:	c0 68       	rjmp	80007c14 <_sbrk+0x34>
80007c0a:	e0 a0 18 15 	rcall	8000ac34 <__errno>
80007c0e:	30 c8       	mov	r8,12
80007c10:	99 08       	st.w	r12[0x0],r8
80007c12:	3f f8       	mov	r8,-1
80007c14:	10 9c       	mov	r12,r8
80007c16:	d8 02       	popm	pc

80007c18 <get_arg>:
80007c18:	d4 31       	pushm	r0-r7,lr
80007c1a:	20 8d       	sub	sp,32
80007c1c:	fa c4 ff bc 	sub	r4,sp,-68
80007c20:	50 4b       	stdsp	sp[0x10],r11
80007c22:	68 2e       	ld.w	lr,r4[0x8]
80007c24:	50 58       	stdsp	sp[0x14],r8
80007c26:	12 96       	mov	r6,r9
80007c28:	7c 0b       	ld.w	r11,lr[0x0]
80007c2a:	70 05       	ld.w	r5,r8[0x0]
80007c2c:	50 6e       	stdsp	sp[0x18],lr
80007c2e:	58 0b       	cp.w	r11,0
80007c30:	f4 0b 17 00 	moveq	r11,r10
80007c34:	68 03       	ld.w	r3,r4[0x0]
80007c36:	68 11       	ld.w	r1,r4[0x4]
80007c38:	40 49       	lddsp	r9,sp[0x10]
80007c3a:	30 08       	mov	r8,0
80007c3c:	c2 89       	rjmp	80007e8c <get_arg+0x274>
80007c3e:	2f fb       	sub	r11,-1
80007c40:	32 5c       	mov	r12,37
80007c42:	17 8a       	ld.ub	r10,r11[0x0]
80007c44:	f8 0a 18 00 	cp.b	r10,r12
80007c48:	5f 1e       	srne	lr
80007c4a:	f0 0a 18 00 	cp.b	r10,r8
80007c4e:	5f 1c       	srne	r12
80007c50:	fd ec 00 0c 	and	r12,lr,r12
80007c54:	f0 0c 18 00 	cp.b	r12,r8
80007c58:	cf 31       	brne	80007c3e <get_arg+0x26>
80007c5a:	58 0a       	cp.w	r10,0
80007c5c:	e0 80 01 25 	breq	80007ea6 <get_arg+0x28e>
80007c60:	30 0c       	mov	r12,0
80007c62:	3f fa       	mov	r10,-1
80007c64:	18 90       	mov	r0,r12
80007c66:	50 3a       	stdsp	sp[0xc],r10
80007c68:	18 94       	mov	r4,r12
80007c6a:	18 92       	mov	r2,r12
80007c6c:	f8 0c 00 3c 	add	r12,r12,r12<<0x3
80007c70:	16 97       	mov	r7,r11
80007c72:	50 7c       	stdsp	sp[0x1c],r12
80007c74:	fe cc 9f b0 	sub	r12,pc,-24656
80007c78:	0f 3a       	ld.ub	r10,r7++
80007c7a:	f8 0a 07 0e 	ld.ub	lr,r12[r10]
80007c7e:	40 7c       	lddsp	r12,sp[0x1c]
80007c80:	1c 0c       	add	r12,lr
80007c82:	fe ce a0 86 	sub	lr,pc,-24442
80007c86:	fc 0c 07 0e 	ld.ub	lr,lr[r12]
80007c8a:	20 1e       	sub	lr,1
80007c8c:	50 0e       	stdsp	sp[0x0],lr
80007c8e:	fe ce a0 fe 	sub	lr,pc,-24322
80007c92:	fc 0c 07 0c 	ld.ub	r12,lr[r12]
80007c96:	50 7c       	stdsp	sp[0x1c],r12
80007c98:	40 0c       	lddsp	r12,sp[0x0]
80007c9a:	58 7c       	cp.w	r12,7
80007c9c:	e0 8b 00 f1 	brhi	80007e7e <get_arg+0x266>
80007ca0:	fe ce a2 b0 	sub	lr,pc,-23888
80007ca4:	fc 0c 03 2f 	ld.w	pc,lr[r12<<0x2]
80007ca8:	36 8b       	mov	r11,104
80007caa:	f6 0a 18 00 	cp.b	r10,r11
80007cae:	e0 80 00 e8 	breq	80007e7e <get_arg+0x266>
80007cb2:	37 1b       	mov	r11,113
80007cb4:	f6 0a 18 00 	cp.b	r10,r11
80007cb8:	c0 70       	breq	80007cc6 <get_arg+0xae>
80007cba:	34 cb       	mov	r11,76
80007cbc:	f6 0a 18 00 	cp.b	r10,r11
80007cc0:	c0 51       	brne	80007cca <get_arg+0xb2>
80007cc2:	a3 b4       	sbr	r4,0x3
80007cc4:	cd d8       	rjmp	80007e7e <get_arg+0x266>
80007cc6:	a5 b4       	sbr	r4,0x5
80007cc8:	cd b8       	rjmp	80007e7e <get_arg+0x266>
80007cca:	08 9a       	mov	r10,r4
80007ccc:	0e 9b       	mov	r11,r7
80007cce:	a5 aa       	sbr	r10,0x4
80007cd0:	17 3c       	ld.ub	r12,r11++
80007cd2:	a5 b4       	sbr	r4,0x5
80007cd4:	36 ce       	mov	lr,108
80007cd6:	fc 0c 18 00 	cp.b	r12,lr
80007cda:	e0 80 00 d3 	breq	80007e80 <get_arg+0x268>
80007cde:	14 94       	mov	r4,r10
80007ce0:	cc f8       	rjmp	80007e7e <get_arg+0x266>
80007ce2:	eb d5 c0 05 	bfextu	r5,r5,0x0,0x5
80007ce6:	36 7c       	mov	r12,103
80007ce8:	f8 0a 18 00 	cp.b	r10,r12
80007cec:	e0 8b 00 27 	brhi	80007d3a <get_arg+0x122>
80007cf0:	36 5b       	mov	r11,101
80007cf2:	f6 0a 18 00 	cp.b	r10,r11
80007cf6:	c4 82       	brcc	80007d86 <get_arg+0x16e>
80007cf8:	34 fb       	mov	r11,79
80007cfa:	f6 0a 18 00 	cp.b	r10,r11
80007cfe:	c4 80       	breq	80007d8e <get_arg+0x176>
80007d00:	e0 8b 00 0c 	brhi	80007d18 <get_arg+0x100>
80007d04:	34 5b       	mov	r11,69
80007d06:	f6 0a 18 00 	cp.b	r10,r11
80007d0a:	c3 e0       	breq	80007d86 <get_arg+0x16e>
80007d0c:	34 7b       	mov	r11,71
80007d0e:	f6 0a 18 00 	cp.b	r10,r11
80007d12:	c3 a0       	breq	80007d86 <get_arg+0x16e>
80007d14:	34 4b       	mov	r11,68
80007d16:	c0 88       	rjmp	80007d26 <get_arg+0x10e>
80007d18:	35 8b       	mov	r11,88
80007d1a:	f6 0a 18 00 	cp.b	r10,r11
80007d1e:	c2 c0       	breq	80007d76 <get_arg+0x15e>
80007d20:	e0 8b 00 07 	brhi	80007d2e <get_arg+0x116>
80007d24:	35 5b       	mov	r11,85
80007d26:	f6 0a 18 00 	cp.b	r10,r11
80007d2a:	c3 51       	brne	80007d94 <get_arg+0x17c>
80007d2c:	c3 18       	rjmp	80007d8e <get_arg+0x176>
80007d2e:	36 3b       	mov	r11,99
80007d30:	f6 0a 18 00 	cp.b	r10,r11
80007d34:	c2 f0       	breq	80007d92 <get_arg+0x17a>
80007d36:	36 4b       	mov	r11,100
80007d38:	c0 e8       	rjmp	80007d54 <get_arg+0x13c>
80007d3a:	37 0b       	mov	r11,112
80007d3c:	f6 0a 18 00 	cp.b	r10,r11
80007d40:	c2 50       	breq	80007d8a <get_arg+0x172>
80007d42:	e0 8b 00 0d 	brhi	80007d5c <get_arg+0x144>
80007d46:	36 eb       	mov	r11,110
80007d48:	f6 0a 18 00 	cp.b	r10,r11
80007d4c:	c1 f0       	breq	80007d8a <get_arg+0x172>
80007d4e:	e0 8b 00 14 	brhi	80007d76 <get_arg+0x15e>
80007d52:	36 9b       	mov	r11,105
80007d54:	f6 0a 18 00 	cp.b	r10,r11
80007d58:	c1 e1       	brne	80007d94 <get_arg+0x17c>
80007d5a:	c0 e8       	rjmp	80007d76 <get_arg+0x15e>
80007d5c:	37 5b       	mov	r11,117
80007d5e:	f6 0a 18 00 	cp.b	r10,r11
80007d62:	c0 a0       	breq	80007d76 <get_arg+0x15e>
80007d64:	37 8b       	mov	r11,120
80007d66:	f6 0a 18 00 	cp.b	r10,r11
80007d6a:	c0 60       	breq	80007d76 <get_arg+0x15e>
80007d6c:	37 3b       	mov	r11,115
80007d6e:	f6 0a 18 00 	cp.b	r10,r11
80007d72:	c1 11       	brne	80007d94 <get_arg+0x17c>
80007d74:	c0 b8       	rjmp	80007d8a <get_arg+0x172>
80007d76:	ed b4 00 04 	bld	r4,0x4
80007d7a:	c0 a0       	breq	80007d8e <get_arg+0x176>
80007d7c:	ed b4 00 05 	bld	r4,0x5
80007d80:	c0 91       	brne	80007d92 <get_arg+0x17a>
80007d82:	30 20       	mov	r0,2
80007d84:	c0 88       	rjmp	80007d94 <get_arg+0x17c>
80007d86:	30 40       	mov	r0,4
80007d88:	c0 68       	rjmp	80007d94 <get_arg+0x17c>
80007d8a:	30 30       	mov	r0,3
80007d8c:	c0 48       	rjmp	80007d94 <get_arg+0x17c>
80007d8e:	30 10       	mov	r0,1
80007d90:	c0 28       	rjmp	80007d94 <get_arg+0x17c>
80007d92:	30 00       	mov	r0,0
80007d94:	40 3b       	lddsp	r11,sp[0xc]
80007d96:	5b fb       	cp.w	r11,-1
80007d98:	c0 40       	breq	80007da0 <get_arg+0x188>
80007d9a:	e2 0b 09 20 	st.w	r1[r11<<0x2],r0
80007d9e:	c7 08       	rjmp	80007e7e <get_arg+0x266>
80007da0:	58 60       	cp.w	r0,6
80007da2:	e0 8b 00 6e 	brhi	80007e7e <get_arg+0x266>
80007da6:	6c 0a       	ld.w	r10,r6[0x0]
80007da8:	ea cc ff ff 	sub	r12,r5,-1
80007dac:	fe ce a3 9c 	sub	lr,pc,-23652
80007db0:	fc 00 03 2f 	ld.w	pc,lr[r0<<0x2]
80007db4:	f4 cb ff f8 	sub	r11,r10,-8
80007db8:	8d 0b       	st.w	r6[0x0],r11
80007dba:	f4 ea 00 00 	ld.d	r10,r10[0]
80007dbe:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80007dc2:	c0 f8       	rjmp	80007de0 <get_arg+0x1c8>
80007dc4:	f4 cb ff fc 	sub	r11,r10,-4
80007dc8:	8d 0b       	st.w	r6[0x0],r11
80007dca:	74 0a       	ld.w	r10,r10[0x0]
80007dcc:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80007dd0:	c0 88       	rjmp	80007de0 <get_arg+0x1c8>
80007dd2:	f4 cb ff f8 	sub	r11,r10,-8
80007dd6:	8d 0b       	st.w	r6[0x0],r11
80007dd8:	f4 ea 00 00 	ld.d	r10,r10[0]
80007ddc:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80007de0:	0e 9b       	mov	r11,r7
80007de2:	18 95       	mov	r5,r12
80007de4:	c4 e8       	rjmp	80007e80 <get_arg+0x268>
80007de6:	62 0a       	ld.w	r10,r1[0x0]
80007de8:	5b fa       	cp.w	r10,-1
80007dea:	c0 b1       	brne	80007e00 <get_arg+0x1e8>
80007dec:	50 19       	stdsp	sp[0x4],r9
80007dee:	50 28       	stdsp	sp[0x8],r8
80007df0:	e0 6a 00 80 	mov	r10,128
80007df4:	30 0b       	mov	r11,0
80007df6:	02 9c       	mov	r12,r1
80007df8:	fe b0 fd 00 	rcall	800077f8 <memset>
80007dfc:	40 28       	lddsp	r8,sp[0x8]
80007dfe:	40 19       	lddsp	r9,sp[0x4]
80007e00:	e4 cc 00 01 	sub	r12,r2,1
80007e04:	0e 9b       	mov	r11,r7
80007e06:	50 3c       	stdsp	sp[0xc],r12
80007e08:	f2 0c 0c 49 	max	r9,r9,r12
80007e0c:	c3 a8       	rjmp	80007e80 <get_arg+0x268>
80007e0e:	62 0a       	ld.w	r10,r1[0x0]
80007e10:	5b fa       	cp.w	r10,-1
80007e12:	c0 b1       	brne	80007e28 <get_arg+0x210>
80007e14:	50 19       	stdsp	sp[0x4],r9
80007e16:	50 28       	stdsp	sp[0x8],r8
80007e18:	e0 6a 00 80 	mov	r10,128
80007e1c:	30 0b       	mov	r11,0
80007e1e:	02 9c       	mov	r12,r1
80007e20:	fe b0 fc ec 	rcall	800077f8 <memset>
80007e24:	40 28       	lddsp	r8,sp[0x8]
80007e26:	40 19       	lddsp	r9,sp[0x4]
80007e28:	20 12       	sub	r2,1
80007e2a:	30 0a       	mov	r10,0
80007e2c:	0e 9b       	mov	r11,r7
80007e2e:	e2 02 09 2a 	st.w	r1[r2<<0x2],r10
80007e32:	f2 02 0c 49 	max	r9,r9,r2
80007e36:	c2 58       	rjmp	80007e80 <get_arg+0x268>
80007e38:	16 97       	mov	r7,r11
80007e3a:	6c 0a       	ld.w	r10,r6[0x0]
80007e3c:	f4 cb ff fc 	sub	r11,r10,-4
80007e40:	8d 0b       	st.w	r6[0x0],r11
80007e42:	74 0a       	ld.w	r10,r10[0x0]
80007e44:	0e 9b       	mov	r11,r7
80007e46:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80007e4a:	2f f5       	sub	r5,-1
80007e4c:	c1 a8       	rjmp	80007e80 <get_arg+0x268>
80007e4e:	f4 c2 00 30 	sub	r2,r10,48
80007e52:	c0 68       	rjmp	80007e5e <get_arg+0x246>
80007e54:	e4 02 00 22 	add	r2,r2,r2<<0x2
80007e58:	2f f7       	sub	r7,-1
80007e5a:	f4 02 00 12 	add	r2,r10,r2<<0x1
80007e5e:	0f 8a       	ld.ub	r10,r7[0x0]
80007e60:	58 0a       	cp.w	r10,0
80007e62:	c0 e0       	breq	80007e7e <get_arg+0x266>
80007e64:	23 0a       	sub	r10,48
80007e66:	58 9a       	cp.w	r10,9
80007e68:	fe 98 ff f6 	brls	80007e54 <get_arg+0x23c>
80007e6c:	c0 98       	rjmp	80007e7e <get_arg+0x266>
80007e6e:	2f f7       	sub	r7,-1
80007e70:	0f 8a       	ld.ub	r10,r7[0x0]
80007e72:	58 0a       	cp.w	r10,0
80007e74:	c0 50       	breq	80007e7e <get_arg+0x266>
80007e76:	23 0a       	sub	r10,48
80007e78:	58 9a       	cp.w	r10,9
80007e7a:	fe 98 ff fa 	brls	80007e6e <get_arg+0x256>
80007e7e:	0e 9b       	mov	r11,r7
80007e80:	40 7c       	lddsp	r12,sp[0x1c]
80007e82:	30 ba       	mov	r10,11
80007e84:	f4 0c 18 00 	cp.b	r12,r10
80007e88:	fe 91 fe f2 	brne	80007c6c <get_arg+0x54>
80007e8c:	40 42       	lddsp	r2,sp[0x10]
80007e8e:	17 8c       	ld.ub	r12,r11[0x0]
80007e90:	0a 32       	cp.w	r2,r5
80007e92:	5f 4a       	srge	r10
80007e94:	f0 0c 18 00 	cp.b	r12,r8
80007e98:	5f 1c       	srne	r12
80007e9a:	f9 ea 00 0a 	and	r10,r12,r10
80007e9e:	f0 0a 18 00 	cp.b	r10,r8
80007ea2:	fe 91 fe cf 	brne	80007c40 <get_arg+0x28>
80007ea6:	30 08       	mov	r8,0
80007ea8:	40 4e       	lddsp	lr,sp[0x10]
80007eaa:	17 8a       	ld.ub	r10,r11[0x0]
80007eac:	e2 05 00 21 	add	r1,r1,r5<<0x2
80007eb0:	f0 0a 18 00 	cp.b	r10,r8
80007eb4:	fc 09 17 10 	movne	r9,lr
80007eb8:	e6 05 00 38 	add	r8,r3,r5<<0x3
80007ebc:	06 9e       	mov	lr,r3
80007ebe:	c2 a8       	rjmp	80007f12 <get_arg+0x2fa>
80007ec0:	62 0a       	ld.w	r10,r1[0x0]
80007ec2:	58 3a       	cp.w	r10,3
80007ec4:	c1 e0       	breq	80007f00 <get_arg+0x2e8>
80007ec6:	e0 89 00 07 	brgt	80007ed4 <get_arg+0x2bc>
80007eca:	58 1a       	cp.w	r10,1
80007ecc:	c1 a0       	breq	80007f00 <get_arg+0x2e8>
80007ece:	58 2a       	cp.w	r10,2
80007ed0:	c1 81       	brne	80007f00 <get_arg+0x2e8>
80007ed2:	c0 58       	rjmp	80007edc <get_arg+0x2c4>
80007ed4:	58 5a       	cp.w	r10,5
80007ed6:	c0 c0       	breq	80007eee <get_arg+0x2d6>
80007ed8:	c0 b5       	brlt	80007eee <get_arg+0x2d6>
80007eda:	c1 38       	rjmp	80007f00 <get_arg+0x2e8>
80007edc:	6c 0a       	ld.w	r10,r6[0x0]
80007ede:	f4 cc ff f8 	sub	r12,r10,-8
80007ee2:	8d 0c       	st.w	r6[0x0],r12
80007ee4:	f4 e2 00 00 	ld.d	r2,r10[0]
80007ee8:	f0 e3 00 00 	st.d	r8[0],r2
80007eec:	c1 08       	rjmp	80007f0c <get_arg+0x2f4>
80007eee:	6c 0a       	ld.w	r10,r6[0x0]
80007ef0:	f4 cc ff f8 	sub	r12,r10,-8
80007ef4:	8d 0c       	st.w	r6[0x0],r12
80007ef6:	f4 e2 00 00 	ld.d	r2,r10[0]
80007efa:	f0 e3 00 00 	st.d	r8[0],r2
80007efe:	c0 78       	rjmp	80007f0c <get_arg+0x2f4>
80007f00:	6c 0a       	ld.w	r10,r6[0x0]
80007f02:	f4 cc ff fc 	sub	r12,r10,-4
80007f06:	8d 0c       	st.w	r6[0x0],r12
80007f08:	74 0a       	ld.w	r10,r10[0x0]
80007f0a:	91 0a       	st.w	r8[0x0],r10
80007f0c:	2f f5       	sub	r5,-1
80007f0e:	2f 88       	sub	r8,-8
80007f10:	2f c1       	sub	r1,-4
80007f12:	12 35       	cp.w	r5,r9
80007f14:	fe 9a ff d6 	brle	80007ec0 <get_arg+0x2a8>
80007f18:	1c 93       	mov	r3,lr
80007f1a:	40 52       	lddsp	r2,sp[0x14]
80007f1c:	40 6e       	lddsp	lr,sp[0x18]
80007f1e:	85 05       	st.w	r2[0x0],r5
80007f20:	9d 0b       	st.w	lr[0x0],r11
80007f22:	40 4b       	lddsp	r11,sp[0x10]
80007f24:	e6 0b 00 3c 	add	r12,r3,r11<<0x3
80007f28:	2f 8d       	sub	sp,-32
80007f2a:	d8 32       	popm	r0-r7,pc

80007f2c <__sprint_r>:
80007f2c:	d4 21       	pushm	r4-r7,lr
80007f2e:	14 97       	mov	r7,r10
80007f30:	74 28       	ld.w	r8,r10[0x8]
80007f32:	58 08       	cp.w	r8,0
80007f34:	c0 41       	brne	80007f3c <__sprint_r+0x10>
80007f36:	95 18       	st.w	r10[0x4],r8
80007f38:	10 9c       	mov	r12,r8
80007f3a:	d8 22       	popm	r4-r7,pc
80007f3c:	e0 a0 18 ba 	rcall	8000b0b0 <__sfvwrite_r>
80007f40:	30 08       	mov	r8,0
80007f42:	8f 18       	st.w	r7[0x4],r8
80007f44:	8f 28       	st.w	r7[0x8],r8
80007f46:	d8 22       	popm	r4-r7,pc

80007f48 <_vfprintf_r>:
80007f48:	d4 31       	pushm	r0-r7,lr
80007f4a:	fa cd 06 bc 	sub	sp,sp,1724
80007f4e:	51 09       	stdsp	sp[0x40],r9
80007f50:	16 91       	mov	r1,r11
80007f52:	14 97       	mov	r7,r10
80007f54:	18 95       	mov	r5,r12
80007f56:	e0 a0 1a 1d 	rcall	8000b390 <_localeconv_r>
80007f5a:	78 0c       	ld.w	r12,r12[0x0]
80007f5c:	50 cc       	stdsp	sp[0x30],r12
80007f5e:	58 05       	cp.w	r5,0
80007f60:	c0 70       	breq	80007f6e <_vfprintf_r+0x26>
80007f62:	6a 68       	ld.w	r8,r5[0x18]
80007f64:	58 08       	cp.w	r8,0
80007f66:	c0 41       	brne	80007f6e <_vfprintf_r+0x26>
80007f68:	0a 9c       	mov	r12,r5
80007f6a:	e0 a0 17 43 	rcall	8000adf0 <__sinit>
80007f6e:	fe c8 a1 9a 	sub	r8,pc,-24166
80007f72:	10 31       	cp.w	r1,r8
80007f74:	c0 31       	brne	80007f7a <_vfprintf_r+0x32>
80007f76:	6a 01       	ld.w	r1,r5[0x0]
80007f78:	c0 c8       	rjmp	80007f90 <_vfprintf_r+0x48>
80007f7a:	fe c8 a1 86 	sub	r8,pc,-24186
80007f7e:	10 31       	cp.w	r1,r8
80007f80:	c0 31       	brne	80007f86 <_vfprintf_r+0x3e>
80007f82:	6a 11       	ld.w	r1,r5[0x4]
80007f84:	c0 68       	rjmp	80007f90 <_vfprintf_r+0x48>
80007f86:	fe c8 a1 72 	sub	r8,pc,-24206
80007f8a:	10 31       	cp.w	r1,r8
80007f8c:	eb f1 00 02 	ld.weq	r1,r5[0x8]
80007f90:	82 68       	ld.sh	r8,r1[0xc]
80007f92:	ed b8 00 03 	bld	r8,0x3
80007f96:	c0 41       	brne	80007f9e <_vfprintf_r+0x56>
80007f98:	62 48       	ld.w	r8,r1[0x10]
80007f9a:	58 08       	cp.w	r8,0
80007f9c:	c0 71       	brne	80007faa <_vfprintf_r+0x62>
80007f9e:	02 9b       	mov	r11,r1
80007fa0:	0a 9c       	mov	r12,r5
80007fa2:	e0 a0 0f 5d 	rcall	80009e5c <__swsetup_r>
80007fa6:	e0 81 0f 54 	brne	80009e4e <_vfprintf_r+0x1f06>
80007faa:	82 68       	ld.sh	r8,r1[0xc]
80007fac:	10 99       	mov	r9,r8
80007fae:	e2 19 00 1a 	andl	r9,0x1a,COH
80007fb2:	58 a9       	cp.w	r9,10
80007fb4:	c3 c1       	brne	8000802c <_vfprintf_r+0xe4>
80007fb6:	82 79       	ld.sh	r9,r1[0xe]
80007fb8:	30 0a       	mov	r10,0
80007fba:	f4 09 19 00 	cp.h	r9,r10
80007fbe:	c3 75       	brlt	8000802c <_vfprintf_r+0xe4>
80007fc0:	a1 d8       	cbr	r8,0x1
80007fc2:	fb 58 05 d0 	st.h	sp[1488],r8
80007fc6:	62 88       	ld.w	r8,r1[0x20]
80007fc8:	fb 48 05 e4 	st.w	sp[1508],r8
80007fcc:	62 a8       	ld.w	r8,r1[0x28]
80007fce:	fb 48 05 ec 	st.w	sp[1516],r8
80007fd2:	fa c8 ff bc 	sub	r8,sp,-68
80007fd6:	fb 48 05 d4 	st.w	sp[1492],r8
80007fda:	fb 48 05 c4 	st.w	sp[1476],r8
80007fde:	e0 68 04 00 	mov	r8,1024
80007fe2:	fb 48 05 d8 	st.w	sp[1496],r8
80007fe6:	fb 48 05 cc 	st.w	sp[1484],r8
80007fea:	30 08       	mov	r8,0
80007fec:	fb 59 05 d2 	st.h	sp[1490],r9
80007ff0:	0e 9a       	mov	r10,r7
80007ff2:	41 09       	lddsp	r9,sp[0x40]
80007ff4:	fa c7 fa 3c 	sub	r7,sp,-1476
80007ff8:	fb 48 05 dc 	st.w	sp[1500],r8
80007ffc:	0a 9c       	mov	r12,r5
80007ffe:	0e 9b       	mov	r11,r7
80008000:	ca 4f       	rcall	80007f48 <_vfprintf_r>
80008002:	50 bc       	stdsp	sp[0x2c],r12
80008004:	c0 95       	brlt	80008016 <_vfprintf_r+0xce>
80008006:	0e 9b       	mov	r11,r7
80008008:	0a 9c       	mov	r12,r5
8000800a:	e0 a0 16 1b 	rcall	8000ac40 <_fflush_r>
8000800e:	40 be       	lddsp	lr,sp[0x2c]
80008010:	f9 be 01 ff 	movne	lr,-1
80008014:	50 be       	stdsp	sp[0x2c],lr
80008016:	fb 08 05 d0 	ld.sh	r8,sp[1488]
8000801a:	ed b8 00 06 	bld	r8,0x6
8000801e:	e0 81 0f 1a 	brne	80009e52 <_vfprintf_r+0x1f0a>
80008022:	82 68       	ld.sh	r8,r1[0xc]
80008024:	a7 a8       	sbr	r8,0x6
80008026:	a2 68       	st.h	r1[0xc],r8
80008028:	e0 8f 0f 15 	bral	80009e52 <_vfprintf_r+0x1f0a>
8000802c:	30 08       	mov	r8,0
8000802e:	fb 48 06 b4 	st.w	sp[1716],r8
80008032:	fb 48 06 90 	st.w	sp[1680],r8
80008036:	fb 48 06 8c 	st.w	sp[1676],r8
8000803a:	fb 48 06 b0 	st.w	sp[1712],r8
8000803e:	30 08       	mov	r8,0
80008040:	30 09       	mov	r9,0
80008042:	50 a7       	stdsp	sp[0x28],r7
80008044:	50 78       	stdsp	sp[0x1c],r8
80008046:	fa c3 f9 e0 	sub	r3,sp,-1568
8000804a:	3f f8       	mov	r8,-1
8000804c:	50 59       	stdsp	sp[0x14],r9
8000804e:	fb 43 06 88 	st.w	sp[1672],r3
80008052:	fb 48 05 44 	st.w	sp[1348],r8
80008056:	12 9c       	mov	r12,r9
80008058:	50 69       	stdsp	sp[0x18],r9
8000805a:	50 d9       	stdsp	sp[0x34],r9
8000805c:	50 e9       	stdsp	sp[0x38],r9
8000805e:	50 b9       	stdsp	sp[0x2c],r9
80008060:	12 97       	mov	r7,r9
80008062:	0a 94       	mov	r4,r5
80008064:	40 a2       	lddsp	r2,sp[0x28]
80008066:	32 5a       	mov	r10,37
80008068:	30 08       	mov	r8,0
8000806a:	c0 28       	rjmp	8000806e <_vfprintf_r+0x126>
8000806c:	2f f2       	sub	r2,-1
8000806e:	05 89       	ld.ub	r9,r2[0x0]
80008070:	f0 09 18 00 	cp.b	r9,r8
80008074:	5f 1b       	srne	r11
80008076:	f4 09 18 00 	cp.b	r9,r10
8000807a:	5f 19       	srne	r9
8000807c:	f3 eb 00 0b 	and	r11,r9,r11
80008080:	f0 0b 18 00 	cp.b	r11,r8
80008084:	cf 41       	brne	8000806c <_vfprintf_r+0x124>
80008086:	40 ab       	lddsp	r11,sp[0x28]
80008088:	e4 0b 01 06 	sub	r6,r2,r11
8000808c:	c1 e0       	breq	800080c8 <_vfprintf_r+0x180>
8000808e:	fa f8 06 90 	ld.w	r8,sp[1680]
80008092:	0c 08       	add	r8,r6
80008094:	87 0b       	st.w	r3[0x0],r11
80008096:	fb 48 06 90 	st.w	sp[1680],r8
8000809a:	87 16       	st.w	r3[0x4],r6
8000809c:	fa f8 06 8c 	ld.w	r8,sp[1676]
800080a0:	2f f8       	sub	r8,-1
800080a2:	fb 48 06 8c 	st.w	sp[1676],r8
800080a6:	58 78       	cp.w	r8,7
800080a8:	e0 89 00 04 	brgt	800080b0 <_vfprintf_r+0x168>
800080ac:	2f 83       	sub	r3,-8
800080ae:	c0 a8       	rjmp	800080c2 <_vfprintf_r+0x17a>
800080b0:	fa ca f9 78 	sub	r10,sp,-1672
800080b4:	02 9b       	mov	r11,r1
800080b6:	08 9c       	mov	r12,r4
800080b8:	c3 af       	rcall	80007f2c <__sprint_r>
800080ba:	e0 81 0e c6 	brne	80009e46 <_vfprintf_r+0x1efe>
800080be:	fa c3 f9 e0 	sub	r3,sp,-1568
800080c2:	40 ba       	lddsp	r10,sp[0x2c]
800080c4:	0c 0a       	add	r10,r6
800080c6:	50 ba       	stdsp	sp[0x2c],r10
800080c8:	05 89       	ld.ub	r9,r2[0x0]
800080ca:	30 08       	mov	r8,0
800080cc:	f0 09 18 00 	cp.b	r9,r8
800080d0:	e0 80 0e aa 	breq	80009e24 <_vfprintf_r+0x1edc>
800080d4:	30 09       	mov	r9,0
800080d6:	fb 68 06 bb 	st.b	sp[1723],r8
800080da:	0e 96       	mov	r6,r7
800080dc:	e4 c8 ff ff 	sub	r8,r2,-1
800080e0:	3f fe       	mov	lr,-1
800080e2:	50 93       	stdsp	sp[0x24],r3
800080e4:	50 41       	stdsp	sp[0x10],r1
800080e6:	0e 93       	mov	r3,r7
800080e8:	04 91       	mov	r1,r2
800080ea:	50 89       	stdsp	sp[0x20],r9
800080ec:	50 a8       	stdsp	sp[0x28],r8
800080ee:	50 2e       	stdsp	sp[0x8],lr
800080f0:	50 39       	stdsp	sp[0xc],r9
800080f2:	12 95       	mov	r5,r9
800080f4:	12 90       	mov	r0,r9
800080f6:	10 97       	mov	r7,r8
800080f8:	08 92       	mov	r2,r4
800080fa:	c0 78       	rjmp	80008108 <_vfprintf_r+0x1c0>
800080fc:	3f fc       	mov	r12,-1
800080fe:	08 97       	mov	r7,r4
80008100:	50 2c       	stdsp	sp[0x8],r12
80008102:	c0 38       	rjmp	80008108 <_vfprintf_r+0x1c0>
80008104:	30 0b       	mov	r11,0
80008106:	50 3b       	stdsp	sp[0xc],r11
80008108:	0f 38       	ld.ub	r8,r7++
8000810a:	c0 28       	rjmp	8000810e <_vfprintf_r+0x1c6>
8000810c:	12 90       	mov	r0,r9
8000810e:	f0 c9 00 20 	sub	r9,r8,32
80008112:	e0 49 00 58 	cp.w	r9,88
80008116:	e0 8b 0a 30 	brhi	80009576 <_vfprintf_r+0x162e>
8000811a:	fe ca a6 ee 	sub	r10,pc,-22802
8000811e:	f4 09 03 2f 	ld.w	pc,r10[r9<<0x2]
80008122:	50 a7       	stdsp	sp[0x28],r7
80008124:	50 80       	stdsp	sp[0x20],r0
80008126:	0c 97       	mov	r7,r6
80008128:	04 94       	mov	r4,r2
8000812a:	06 96       	mov	r6,r3
8000812c:	02 92       	mov	r2,r1
8000812e:	fe c9 a4 c6 	sub	r9,pc,-23354
80008132:	40 93       	lddsp	r3,sp[0x24]
80008134:	10 90       	mov	r0,r8
80008136:	40 41       	lddsp	r1,sp[0x10]
80008138:	50 d9       	stdsp	sp[0x34],r9
8000813a:	e0 8f 08 8e 	bral	80009256 <_vfprintf_r+0x130e>
8000813e:	30 08       	mov	r8,0
80008140:	fb 39 06 bb 	ld.ub	r9,sp[1723]
80008144:	f0 09 18 00 	cp.b	r9,r8
80008148:	ce 01       	brne	80008108 <_vfprintf_r+0x1c0>
8000814a:	32 08       	mov	r8,32
8000814c:	c6 e8       	rjmp	80008228 <_vfprintf_r+0x2e0>
8000814e:	a1 a5       	sbr	r5,0x0
80008150:	cd cb       	rjmp	80008108 <_vfprintf_r+0x1c0>
80008152:	0f 89       	ld.ub	r9,r7[0x0]
80008154:	f2 c8 00 30 	sub	r8,r9,48
80008158:	58 98       	cp.w	r8,9
8000815a:	e0 8b 00 1d 	brhi	80008194 <_vfprintf_r+0x24c>
8000815e:	ee c8 ff ff 	sub	r8,r7,-1
80008162:	30 0b       	mov	r11,0
80008164:	23 09       	sub	r9,48
80008166:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
8000816a:	f2 0b 00 1b 	add	r11,r9,r11<<0x1
8000816e:	11 39       	ld.ub	r9,r8++
80008170:	f2 ca 00 30 	sub	r10,r9,48
80008174:	58 9a       	cp.w	r10,9
80008176:	fe 98 ff f7 	brls	80008164 <_vfprintf_r+0x21c>
8000817a:	e0 49 00 24 	cp.w	r9,36
8000817e:	cc 31       	brne	80008104 <_vfprintf_r+0x1bc>
80008180:	e0 4b 00 20 	cp.w	r11,32
80008184:	e0 89 0e 60 	brgt	80009e44 <_vfprintf_r+0x1efc>
80008188:	20 1b       	sub	r11,1
8000818a:	fa f9 06 b4 	ld.w	r9,sp[1716]
8000818e:	12 3b       	cp.w	r11,r9
80008190:	c0 95       	brlt	800081a2 <_vfprintf_r+0x25a>
80008192:	c1 08       	rjmp	800081b2 <_vfprintf_r+0x26a>
80008194:	fa f9 06 b4 	ld.w	r9,sp[1716]
80008198:	ec ca ff ff 	sub	r10,r6,-1
8000819c:	12 36       	cp.w	r6,r9
8000819e:	c1 f5       	brlt	800081dc <_vfprintf_r+0x294>
800081a0:	c2 68       	rjmp	800081ec <_vfprintf_r+0x2a4>
800081a2:	fa ce f9 44 	sub	lr,sp,-1724
800081a6:	10 97       	mov	r7,r8
800081a8:	fc 0b 00 3b 	add	r11,lr,r11<<0x3
800081ac:	f6 f0 fd 88 	ld.w	r0,r11[-632]
800081b0:	c3 58       	rjmp	8000821a <_vfprintf_r+0x2d2>
800081b2:	10 97       	mov	r7,r8
800081b4:	fa c8 f9 50 	sub	r8,sp,-1712
800081b8:	1a d8       	st.w	--sp,r8
800081ba:	fa c8 fa b8 	sub	r8,sp,-1352
800081be:	1a d8       	st.w	--sp,r8
800081c0:	fa c8 fb b4 	sub	r8,sp,-1100
800081c4:	02 9a       	mov	r10,r1
800081c6:	1a d8       	st.w	--sp,r8
800081c8:	04 9c       	mov	r12,r2
800081ca:	fa c8 f9 40 	sub	r8,sp,-1728
800081ce:	fa c9 ff b4 	sub	r9,sp,-76
800081d2:	fe b0 fd 23 	rcall	80007c18 <get_arg>
800081d6:	2f dd       	sub	sp,-12
800081d8:	78 00       	ld.w	r0,r12[0x0]
800081da:	c2 08       	rjmp	8000821a <_vfprintf_r+0x2d2>
800081dc:	fa cc f9 44 	sub	r12,sp,-1724
800081e0:	14 96       	mov	r6,r10
800081e2:	f8 03 00 38 	add	r8,r12,r3<<0x3
800081e6:	f0 f0 fd 88 	ld.w	r0,r8[-632]
800081ea:	c1 88       	rjmp	8000821a <_vfprintf_r+0x2d2>
800081ec:	41 08       	lddsp	r8,sp[0x40]
800081ee:	59 f9       	cp.w	r9,31
800081f0:	e0 89 00 11 	brgt	80008212 <_vfprintf_r+0x2ca>
800081f4:	f0 cb ff fc 	sub	r11,r8,-4
800081f8:	51 0b       	stdsp	sp[0x40],r11
800081fa:	70 00       	ld.w	r0,r8[0x0]
800081fc:	fa cb f9 44 	sub	r11,sp,-1724
80008200:	f6 09 00 38 	add	r8,r11,r9<<0x3
80008204:	f1 40 fd 88 	st.w	r8[-632],r0
80008208:	2f f9       	sub	r9,-1
8000820a:	14 96       	mov	r6,r10
8000820c:	fb 49 06 b4 	st.w	sp[1716],r9
80008210:	c0 58       	rjmp	8000821a <_vfprintf_r+0x2d2>
80008212:	70 00       	ld.w	r0,r8[0x0]
80008214:	14 96       	mov	r6,r10
80008216:	2f c8       	sub	r8,-4
80008218:	51 08       	stdsp	sp[0x40],r8
8000821a:	58 00       	cp.w	r0,0
8000821c:	fe 94 ff 76 	brge	80008108 <_vfprintf_r+0x1c0>
80008220:	5c 30       	neg	r0
80008222:	a3 a5       	sbr	r5,0x2
80008224:	c7 2b       	rjmp	80008108 <_vfprintf_r+0x1c0>
80008226:	32 b8       	mov	r8,43
80008228:	fb 68 06 bb 	st.b	sp[1723],r8
8000822c:	c6 eb       	rjmp	80008108 <_vfprintf_r+0x1c0>
8000822e:	0f 38       	ld.ub	r8,r7++
80008230:	e0 48 00 2a 	cp.w	r8,42
80008234:	c0 30       	breq	8000823a <_vfprintf_r+0x2f2>
80008236:	30 09       	mov	r9,0
80008238:	c7 98       	rjmp	8000832a <_vfprintf_r+0x3e2>
8000823a:	0f 88       	ld.ub	r8,r7[0x0]
8000823c:	f0 c9 00 30 	sub	r9,r8,48
80008240:	58 99       	cp.w	r9,9
80008242:	e0 8b 00 1f 	brhi	80008280 <_vfprintf_r+0x338>
80008246:	ee c4 ff ff 	sub	r4,r7,-1
8000824a:	30 0b       	mov	r11,0
8000824c:	23 08       	sub	r8,48
8000824e:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
80008252:	f0 0b 00 1b 	add	r11,r8,r11<<0x1
80008256:	09 38       	ld.ub	r8,r4++
80008258:	f0 c9 00 30 	sub	r9,r8,48
8000825c:	58 99       	cp.w	r9,9
8000825e:	fe 98 ff f7 	brls	8000824c <_vfprintf_r+0x304>
80008262:	e0 48 00 24 	cp.w	r8,36
80008266:	fe 91 ff 4f 	brne	80008104 <_vfprintf_r+0x1bc>
8000826a:	e0 4b 00 20 	cp.w	r11,32
8000826e:	e0 89 0d eb 	brgt	80009e44 <_vfprintf_r+0x1efc>
80008272:	20 1b       	sub	r11,1
80008274:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008278:	10 3b       	cp.w	r11,r8
8000827a:	c0 a5       	brlt	8000828e <_vfprintf_r+0x346>
8000827c:	c1 18       	rjmp	8000829e <_vfprintf_r+0x356>
8000827e:	d7 03       	nop
80008280:	fa fa 06 b4 	ld.w	r10,sp[1716]
80008284:	ec c9 ff ff 	sub	r9,r6,-1
80008288:	14 36       	cp.w	r6,r10
8000828a:	c1 f5       	brlt	800082c8 <_vfprintf_r+0x380>
8000828c:	c2 88       	rjmp	800082dc <_vfprintf_r+0x394>
8000828e:	fa ca f9 44 	sub	r10,sp,-1724
80008292:	f4 0b 00 3b 	add	r11,r10,r11<<0x3
80008296:	f6 fb fd 88 	ld.w	r11,r11[-632]
8000829a:	50 2b       	stdsp	sp[0x8],r11
8000829c:	c3 c8       	rjmp	80008314 <_vfprintf_r+0x3cc>
8000829e:	fa c8 f9 50 	sub	r8,sp,-1712
800082a2:	1a d8       	st.w	--sp,r8
800082a4:	fa c8 fa b8 	sub	r8,sp,-1352
800082a8:	1a d8       	st.w	--sp,r8
800082aa:	fa c8 fb b4 	sub	r8,sp,-1100
800082ae:	02 9a       	mov	r10,r1
800082b0:	1a d8       	st.w	--sp,r8
800082b2:	04 9c       	mov	r12,r2
800082b4:	fa c8 f9 40 	sub	r8,sp,-1728
800082b8:	fa c9 ff b4 	sub	r9,sp,-76
800082bc:	fe b0 fc ae 	rcall	80007c18 <get_arg>
800082c0:	2f dd       	sub	sp,-12
800082c2:	78 0c       	ld.w	r12,r12[0x0]
800082c4:	50 2c       	stdsp	sp[0x8],r12
800082c6:	c2 78       	rjmp	80008314 <_vfprintf_r+0x3cc>
800082c8:	12 96       	mov	r6,r9
800082ca:	0e 94       	mov	r4,r7
800082cc:	fa c9 f9 44 	sub	r9,sp,-1724
800082d0:	f2 03 00 38 	add	r8,r9,r3<<0x3
800082d4:	f0 f8 fd 88 	ld.w	r8,r8[-632]
800082d8:	50 28       	stdsp	sp[0x8],r8
800082da:	c1 d8       	rjmp	80008314 <_vfprintf_r+0x3cc>
800082dc:	41 08       	lddsp	r8,sp[0x40]
800082de:	59 fa       	cp.w	r10,31
800082e0:	e0 89 00 14 	brgt	80008308 <_vfprintf_r+0x3c0>
800082e4:	f0 cb ff fc 	sub	r11,r8,-4
800082e8:	70 08       	ld.w	r8,r8[0x0]
800082ea:	51 0b       	stdsp	sp[0x40],r11
800082ec:	50 28       	stdsp	sp[0x8],r8
800082ee:	fa c6 f9 44 	sub	r6,sp,-1724
800082f2:	40 2e       	lddsp	lr,sp[0x8]
800082f4:	ec 0a 00 38 	add	r8,r6,r10<<0x3
800082f8:	f1 4e fd 88 	st.w	r8[-632],lr
800082fc:	2f fa       	sub	r10,-1
800082fe:	0e 94       	mov	r4,r7
80008300:	fb 4a 06 b4 	st.w	sp[1716],r10
80008304:	12 96       	mov	r6,r9
80008306:	c0 78       	rjmp	80008314 <_vfprintf_r+0x3cc>
80008308:	70 0c       	ld.w	r12,r8[0x0]
8000830a:	0e 94       	mov	r4,r7
8000830c:	2f c8       	sub	r8,-4
8000830e:	50 2c       	stdsp	sp[0x8],r12
80008310:	12 96       	mov	r6,r9
80008312:	51 08       	stdsp	sp[0x40],r8
80008314:	40 2b       	lddsp	r11,sp[0x8]
80008316:	58 0b       	cp.w	r11,0
80008318:	fe 95 fe f2 	brlt	800080fc <_vfprintf_r+0x1b4>
8000831c:	08 97       	mov	r7,r4
8000831e:	cf 5a       	rjmp	80008108 <_vfprintf_r+0x1c0>
80008320:	f2 09 00 29 	add	r9,r9,r9<<0x2
80008324:	0f 38       	ld.ub	r8,r7++
80008326:	f4 09 00 19 	add	r9,r10,r9<<0x1
8000832a:	f0 ca 00 30 	sub	r10,r8,48
8000832e:	58 9a       	cp.w	r10,9
80008330:	fe 98 ff f8 	brls	80008320 <_vfprintf_r+0x3d8>
80008334:	3f fa       	mov	r10,-1
80008336:	f2 0a 0c 49 	max	r9,r9,r10
8000833a:	50 29       	stdsp	sp[0x8],r9
8000833c:	ce 9a       	rjmp	8000810e <_vfprintf_r+0x1c6>
8000833e:	a7 b5       	sbr	r5,0x7
80008340:	ce 4a       	rjmp	80008108 <_vfprintf_r+0x1c0>
80008342:	30 09       	mov	r9,0
80008344:	23 08       	sub	r8,48
80008346:	f2 09 00 29 	add	r9,r9,r9<<0x2
8000834a:	f0 09 00 19 	add	r9,r8,r9<<0x1
8000834e:	0f 38       	ld.ub	r8,r7++
80008350:	f0 ca 00 30 	sub	r10,r8,48
80008354:	58 9a       	cp.w	r10,9
80008356:	fe 98 ff f7 	brls	80008344 <_vfprintf_r+0x3fc>
8000835a:	e0 48 00 24 	cp.w	r8,36
8000835e:	fe 91 fe d7 	brne	8000810c <_vfprintf_r+0x1c4>
80008362:	e0 49 00 20 	cp.w	r9,32
80008366:	e0 89 0d 6f 	brgt	80009e44 <_vfprintf_r+0x1efc>
8000836a:	f2 c3 00 01 	sub	r3,r9,1
8000836e:	30 19       	mov	r9,1
80008370:	50 39       	stdsp	sp[0xc],r9
80008372:	cc ba       	rjmp	80008108 <_vfprintf_r+0x1c0>
80008374:	a3 b5       	sbr	r5,0x3
80008376:	cc 9a       	rjmp	80008108 <_vfprintf_r+0x1c0>
80008378:	a7 a5       	sbr	r5,0x6
8000837a:	cc 7a       	rjmp	80008108 <_vfprintf_r+0x1c0>
8000837c:	0a 98       	mov	r8,r5
8000837e:	a5 b5       	sbr	r5,0x5
80008380:	a5 a8       	sbr	r8,0x4
80008382:	0f 89       	ld.ub	r9,r7[0x0]
80008384:	36 ce       	mov	lr,108
80008386:	fc 09 18 00 	cp.b	r9,lr
8000838a:	f7 b7 00 ff 	subeq	r7,-1
8000838e:	f0 05 17 10 	movne	r5,r8
80008392:	cb ba       	rjmp	80008108 <_vfprintf_r+0x1c0>
80008394:	a5 b5       	sbr	r5,0x5
80008396:	cb 9a       	rjmp	80008108 <_vfprintf_r+0x1c0>
80008398:	50 a7       	stdsp	sp[0x28],r7
8000839a:	50 80       	stdsp	sp[0x20],r0
8000839c:	0c 97       	mov	r7,r6
8000839e:	10 90       	mov	r0,r8
800083a0:	06 96       	mov	r6,r3
800083a2:	04 94       	mov	r4,r2
800083a4:	40 93       	lddsp	r3,sp[0x24]
800083a6:	02 92       	mov	r2,r1
800083a8:	0e 99       	mov	r9,r7
800083aa:	40 41       	lddsp	r1,sp[0x10]
800083ac:	fa f8 06 b4 	ld.w	r8,sp[1716]
800083b0:	40 3c       	lddsp	r12,sp[0xc]
800083b2:	58 0c       	cp.w	r12,0
800083b4:	c1 d0       	breq	800083ee <_vfprintf_r+0x4a6>
800083b6:	10 36       	cp.w	r6,r8
800083b8:	c0 64       	brge	800083c4 <_vfprintf_r+0x47c>
800083ba:	fa cb f9 44 	sub	r11,sp,-1724
800083be:	f6 06 00 36 	add	r6,r11,r6<<0x3
800083c2:	c1 d8       	rjmp	800083fc <_vfprintf_r+0x4b4>
800083c4:	fa c8 f9 50 	sub	r8,sp,-1712
800083c8:	1a d8       	st.w	--sp,r8
800083ca:	fa c8 fa b8 	sub	r8,sp,-1352
800083ce:	1a d8       	st.w	--sp,r8
800083d0:	fa c8 fb b4 	sub	r8,sp,-1100
800083d4:	1a d8       	st.w	--sp,r8
800083d6:	fa c8 f9 40 	sub	r8,sp,-1728
800083da:	fa c9 ff b4 	sub	r9,sp,-76
800083de:	04 9a       	mov	r10,r2
800083e0:	0c 9b       	mov	r11,r6
800083e2:	08 9c       	mov	r12,r4
800083e4:	fe b0 fc 1a 	rcall	80007c18 <get_arg>
800083e8:	2f dd       	sub	sp,-12
800083ea:	19 b8       	ld.ub	r8,r12[0x3]
800083ec:	c2 28       	rjmp	80008430 <_vfprintf_r+0x4e8>
800083ee:	2f f7       	sub	r7,-1
800083f0:	10 39       	cp.w	r9,r8
800083f2:	c0 84       	brge	80008402 <_vfprintf_r+0x4ba>
800083f4:	fa ca f9 44 	sub	r10,sp,-1724
800083f8:	f4 06 00 36 	add	r6,r10,r6<<0x3
800083fc:	ed 38 fd 8b 	ld.ub	r8,r6[-629]
80008400:	c1 88       	rjmp	80008430 <_vfprintf_r+0x4e8>
80008402:	41 09       	lddsp	r9,sp[0x40]
80008404:	59 f8       	cp.w	r8,31
80008406:	e0 89 00 12 	brgt	8000842a <_vfprintf_r+0x4e2>
8000840a:	f2 ca ff fc 	sub	r10,r9,-4
8000840e:	51 0a       	stdsp	sp[0x40],r10
80008410:	72 09       	ld.w	r9,r9[0x0]
80008412:	fa c6 f9 44 	sub	r6,sp,-1724
80008416:	ec 08 00 3a 	add	r10,r6,r8<<0x3
8000841a:	2f f8       	sub	r8,-1
8000841c:	f5 49 fd 88 	st.w	r10[-632],r9
80008420:	fb 48 06 b4 	st.w	sp[1716],r8
80008424:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
80008428:	c0 48       	rjmp	80008430 <_vfprintf_r+0x4e8>
8000842a:	13 b8       	ld.ub	r8,r9[0x3]
8000842c:	2f c9       	sub	r9,-4
8000842e:	51 09       	stdsp	sp[0x40],r9
80008430:	fb 68 06 60 	st.b	sp[1632],r8
80008434:	30 0e       	mov	lr,0
80008436:	30 08       	mov	r8,0
80008438:	30 12       	mov	r2,1
8000843a:	fb 68 06 bb 	st.b	sp[1723],r8
8000843e:	50 2e       	stdsp	sp[0x8],lr
80008440:	e0 8f 08 ad 	bral	8000959a <_vfprintf_r+0x1652>
80008444:	50 a7       	stdsp	sp[0x28],r7
80008446:	50 80       	stdsp	sp[0x20],r0
80008448:	0c 97       	mov	r7,r6
8000844a:	04 94       	mov	r4,r2
8000844c:	06 96       	mov	r6,r3
8000844e:	02 92       	mov	r2,r1
80008450:	40 93       	lddsp	r3,sp[0x24]
80008452:	10 90       	mov	r0,r8
80008454:	40 41       	lddsp	r1,sp[0x10]
80008456:	a5 a5       	sbr	r5,0x4
80008458:	c0 a8       	rjmp	8000846c <_vfprintf_r+0x524>
8000845a:	50 a7       	stdsp	sp[0x28],r7
8000845c:	50 80       	stdsp	sp[0x20],r0
8000845e:	0c 97       	mov	r7,r6
80008460:	04 94       	mov	r4,r2
80008462:	06 96       	mov	r6,r3
80008464:	02 92       	mov	r2,r1
80008466:	40 93       	lddsp	r3,sp[0x24]
80008468:	10 90       	mov	r0,r8
8000846a:	40 41       	lddsp	r1,sp[0x10]
8000846c:	ed b5 00 05 	bld	r5,0x5
80008470:	c5 11       	brne	80008512 <_vfprintf_r+0x5ca>
80008472:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008476:	40 3c       	lddsp	r12,sp[0xc]
80008478:	58 0c       	cp.w	r12,0
8000847a:	c1 e0       	breq	800084b6 <_vfprintf_r+0x56e>
8000847c:	10 36       	cp.w	r6,r8
8000847e:	c0 64       	brge	8000848a <_vfprintf_r+0x542>
80008480:	fa cb f9 44 	sub	r11,sp,-1724
80008484:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008488:	c2 08       	rjmp	800084c8 <_vfprintf_r+0x580>
8000848a:	fa c8 f9 50 	sub	r8,sp,-1712
8000848e:	1a d8       	st.w	--sp,r8
80008490:	fa c8 fa b8 	sub	r8,sp,-1352
80008494:	0c 9b       	mov	r11,r6
80008496:	1a d8       	st.w	--sp,r8
80008498:	fa c8 fb b4 	sub	r8,sp,-1100
8000849c:	1a d8       	st.w	--sp,r8
8000849e:	fa c9 ff b4 	sub	r9,sp,-76
800084a2:	fa c8 f9 40 	sub	r8,sp,-1728
800084a6:	04 9a       	mov	r10,r2
800084a8:	08 9c       	mov	r12,r4
800084aa:	fe b0 fb b7 	rcall	80007c18 <get_arg>
800084ae:	2f dd       	sub	sp,-12
800084b0:	78 1b       	ld.w	r11,r12[0x4]
800084b2:	78 09       	ld.w	r9,r12[0x0]
800084b4:	c2 b8       	rjmp	8000850a <_vfprintf_r+0x5c2>
800084b6:	ee ca ff ff 	sub	r10,r7,-1
800084ba:	10 37       	cp.w	r7,r8
800084bc:	c0 b4       	brge	800084d2 <_vfprintf_r+0x58a>
800084be:	fa c9 f9 44 	sub	r9,sp,-1724
800084c2:	14 97       	mov	r7,r10
800084c4:	f2 06 00 36 	add	r6,r9,r6<<0x3
800084c8:	ec fb fd 8c 	ld.w	r11,r6[-628]
800084cc:	ec f9 fd 88 	ld.w	r9,r6[-632]
800084d0:	c1 d8       	rjmp	8000850a <_vfprintf_r+0x5c2>
800084d2:	41 09       	lddsp	r9,sp[0x40]
800084d4:	59 f8       	cp.w	r8,31
800084d6:	e0 89 00 14 	brgt	800084fe <_vfprintf_r+0x5b6>
800084da:	f2 cb ff f8 	sub	r11,r9,-8
800084de:	51 0b       	stdsp	sp[0x40],r11
800084e0:	fa c6 f9 44 	sub	r6,sp,-1724
800084e4:	72 1b       	ld.w	r11,r9[0x4]
800084e6:	ec 08 00 3c 	add	r12,r6,r8<<0x3
800084ea:	72 09       	ld.w	r9,r9[0x0]
800084ec:	f9 4b fd 8c 	st.w	r12[-628],r11
800084f0:	f9 49 fd 88 	st.w	r12[-632],r9
800084f4:	2f f8       	sub	r8,-1
800084f6:	14 97       	mov	r7,r10
800084f8:	fb 48 06 b4 	st.w	sp[1716],r8
800084fc:	c0 78       	rjmp	8000850a <_vfprintf_r+0x5c2>
800084fe:	f2 c8 ff f8 	sub	r8,r9,-8
80008502:	72 1b       	ld.w	r11,r9[0x4]
80008504:	14 97       	mov	r7,r10
80008506:	51 08       	stdsp	sp[0x40],r8
80008508:	72 09       	ld.w	r9,r9[0x0]
8000850a:	16 98       	mov	r8,r11
8000850c:	fa e9 00 00 	st.d	sp[0],r8
80008510:	ca e8       	rjmp	8000866c <_vfprintf_r+0x724>
80008512:	ed b5 00 04 	bld	r5,0x4
80008516:	c1 71       	brne	80008544 <_vfprintf_r+0x5fc>
80008518:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000851c:	40 3e       	lddsp	lr,sp[0xc]
8000851e:	58 0e       	cp.w	lr,0
80008520:	c0 80       	breq	80008530 <_vfprintf_r+0x5e8>
80008522:	10 36       	cp.w	r6,r8
80008524:	c6 94       	brge	800085f6 <_vfprintf_r+0x6ae>
80008526:	fa cc f9 44 	sub	r12,sp,-1724
8000852a:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000852e:	c8 28       	rjmp	80008632 <_vfprintf_r+0x6ea>
80008530:	ee ca ff ff 	sub	r10,r7,-1
80008534:	10 37       	cp.w	r7,r8
80008536:	e0 84 00 81 	brge	80008638 <_vfprintf_r+0x6f0>
8000853a:	fa cb f9 44 	sub	r11,sp,-1724
8000853e:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008542:	c7 78       	rjmp	80008630 <_vfprintf_r+0x6e8>
80008544:	ed b5 00 06 	bld	r5,0x6
80008548:	c4 b1       	brne	800085de <_vfprintf_r+0x696>
8000854a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000854e:	40 3c       	lddsp	r12,sp[0xc]
80008550:	58 0c       	cp.w	r12,0
80008552:	c1 d0       	breq	8000858c <_vfprintf_r+0x644>
80008554:	10 36       	cp.w	r6,r8
80008556:	c0 64       	brge	80008562 <_vfprintf_r+0x61a>
80008558:	fa cb f9 44 	sub	r11,sp,-1724
8000855c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008560:	c1 f8       	rjmp	8000859e <_vfprintf_r+0x656>
80008562:	fa c8 f9 50 	sub	r8,sp,-1712
80008566:	1a d8       	st.w	--sp,r8
80008568:	fa c8 fa b8 	sub	r8,sp,-1352
8000856c:	1a d8       	st.w	--sp,r8
8000856e:	fa c8 fb b4 	sub	r8,sp,-1100
80008572:	1a d8       	st.w	--sp,r8
80008574:	fa c8 f9 40 	sub	r8,sp,-1728
80008578:	fa c9 ff b4 	sub	r9,sp,-76
8000857c:	04 9a       	mov	r10,r2
8000857e:	0c 9b       	mov	r11,r6
80008580:	08 9c       	mov	r12,r4
80008582:	fe b0 fb 4b 	rcall	80007c18 <get_arg>
80008586:	2f dd       	sub	sp,-12
80008588:	98 18       	ld.sh	r8,r12[0x2]
8000858a:	c2 68       	rjmp	800085d6 <_vfprintf_r+0x68e>
8000858c:	ee ca ff ff 	sub	r10,r7,-1
80008590:	10 37       	cp.w	r7,r8
80008592:	c0 94       	brge	800085a4 <_vfprintf_r+0x65c>
80008594:	fa c9 f9 44 	sub	r9,sp,-1724
80008598:	14 97       	mov	r7,r10
8000859a:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000859e:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
800085a2:	c1 a8       	rjmp	800085d6 <_vfprintf_r+0x68e>
800085a4:	41 09       	lddsp	r9,sp[0x40]
800085a6:	59 f8       	cp.w	r8,31
800085a8:	e0 89 00 13 	brgt	800085ce <_vfprintf_r+0x686>
800085ac:	f2 cb ff fc 	sub	r11,r9,-4
800085b0:	51 0b       	stdsp	sp[0x40],r11
800085b2:	72 09       	ld.w	r9,r9[0x0]
800085b4:	fa c6 f9 44 	sub	r6,sp,-1724
800085b8:	ec 08 00 3b 	add	r11,r6,r8<<0x3
800085bc:	2f f8       	sub	r8,-1
800085be:	f7 49 fd 88 	st.w	r11[-632],r9
800085c2:	fb 48 06 b4 	st.w	sp[1716],r8
800085c6:	14 97       	mov	r7,r10
800085c8:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
800085cc:	c0 58       	rjmp	800085d6 <_vfprintf_r+0x68e>
800085ce:	92 18       	ld.sh	r8,r9[0x2]
800085d0:	14 97       	mov	r7,r10
800085d2:	2f c9       	sub	r9,-4
800085d4:	51 09       	stdsp	sp[0x40],r9
800085d6:	50 18       	stdsp	sp[0x4],r8
800085d8:	bf 58       	asr	r8,0x1f
800085da:	50 08       	stdsp	sp[0x0],r8
800085dc:	c4 88       	rjmp	8000866c <_vfprintf_r+0x724>
800085de:	fa f8 06 b4 	ld.w	r8,sp[1716]
800085e2:	40 3c       	lddsp	r12,sp[0xc]
800085e4:	58 0c       	cp.w	r12,0
800085e6:	c1 d0       	breq	80008620 <_vfprintf_r+0x6d8>
800085e8:	10 36       	cp.w	r6,r8
800085ea:	c0 64       	brge	800085f6 <_vfprintf_r+0x6ae>
800085ec:	fa cb f9 44 	sub	r11,sp,-1724
800085f0:	f6 06 00 36 	add	r6,r11,r6<<0x3
800085f4:	c1 f8       	rjmp	80008632 <_vfprintf_r+0x6ea>
800085f6:	fa c8 f9 50 	sub	r8,sp,-1712
800085fa:	1a d8       	st.w	--sp,r8
800085fc:	fa c8 fa b8 	sub	r8,sp,-1352
80008600:	0c 9b       	mov	r11,r6
80008602:	1a d8       	st.w	--sp,r8
80008604:	fa c8 fb b4 	sub	r8,sp,-1100
80008608:	04 9a       	mov	r10,r2
8000860a:	1a d8       	st.w	--sp,r8
8000860c:	08 9c       	mov	r12,r4
8000860e:	fa c8 f9 40 	sub	r8,sp,-1728
80008612:	fa c9 ff b4 	sub	r9,sp,-76
80008616:	fe b0 fb 01 	rcall	80007c18 <get_arg>
8000861a:	2f dd       	sub	sp,-12
8000861c:	78 0b       	ld.w	r11,r12[0x0]
8000861e:	c2 48       	rjmp	80008666 <_vfprintf_r+0x71e>
80008620:	ee ca ff ff 	sub	r10,r7,-1
80008624:	10 37       	cp.w	r7,r8
80008626:	c0 94       	brge	80008638 <_vfprintf_r+0x6f0>
80008628:	fa c9 f9 44 	sub	r9,sp,-1724
8000862c:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008630:	14 97       	mov	r7,r10
80008632:	ec fb fd 88 	ld.w	r11,r6[-632]
80008636:	c1 88       	rjmp	80008666 <_vfprintf_r+0x71e>
80008638:	41 09       	lddsp	r9,sp[0x40]
8000863a:	59 f8       	cp.w	r8,31
8000863c:	e0 89 00 11 	brgt	8000865e <_vfprintf_r+0x716>
80008640:	f2 cb ff fc 	sub	r11,r9,-4
80008644:	51 0b       	stdsp	sp[0x40],r11
80008646:	fa c6 f9 44 	sub	r6,sp,-1724
8000864a:	72 0b       	ld.w	r11,r9[0x0]
8000864c:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008650:	f3 4b fd 88 	st.w	r9[-632],r11
80008654:	2f f8       	sub	r8,-1
80008656:	14 97       	mov	r7,r10
80008658:	fb 48 06 b4 	st.w	sp[1716],r8
8000865c:	c0 58       	rjmp	80008666 <_vfprintf_r+0x71e>
8000865e:	72 0b       	ld.w	r11,r9[0x0]
80008660:	14 97       	mov	r7,r10
80008662:	2f c9       	sub	r9,-4
80008664:	51 09       	stdsp	sp[0x40],r9
80008666:	50 1b       	stdsp	sp[0x4],r11
80008668:	bf 5b       	asr	r11,0x1f
8000866a:	50 0b       	stdsp	sp[0x0],r11
8000866c:	fa ea 00 00 	ld.d	r10,sp[0]
80008670:	58 0a       	cp.w	r10,0
80008672:	5c 2b       	cpc	r11
80008674:	c0 e4       	brge	80008690 <_vfprintf_r+0x748>
80008676:	30 08       	mov	r8,0
80008678:	fa ea 00 00 	ld.d	r10,sp[0]
8000867c:	30 09       	mov	r9,0
8000867e:	f0 0a 01 0a 	sub	r10,r8,r10
80008682:	f2 0b 01 4b 	sbc	r11,r9,r11
80008686:	32 d8       	mov	r8,45
80008688:	fa eb 00 00 	st.d	sp[0],r10
8000868c:	fb 68 06 bb 	st.b	sp[1723],r8
80008690:	30 18       	mov	r8,1
80008692:	e0 8f 06 fa 	bral	80009486 <_vfprintf_r+0x153e>
80008696:	50 a7       	stdsp	sp[0x28],r7
80008698:	50 80       	stdsp	sp[0x20],r0
8000869a:	0c 97       	mov	r7,r6
8000869c:	04 94       	mov	r4,r2
8000869e:	06 96       	mov	r6,r3
800086a0:	02 92       	mov	r2,r1
800086a2:	40 93       	lddsp	r3,sp[0x24]
800086a4:	10 90       	mov	r0,r8
800086a6:	40 41       	lddsp	r1,sp[0x10]
800086a8:	0e 99       	mov	r9,r7
800086aa:	ed b5 00 03 	bld	r5,0x3
800086ae:	c4 11       	brne	80008730 <_vfprintf_r+0x7e8>
800086b0:	fa f8 06 b4 	ld.w	r8,sp[1716]
800086b4:	40 3a       	lddsp	r10,sp[0xc]
800086b6:	58 0a       	cp.w	r10,0
800086b8:	c1 90       	breq	800086ea <_vfprintf_r+0x7a2>
800086ba:	10 36       	cp.w	r6,r8
800086bc:	c6 45       	brlt	80008784 <_vfprintf_r+0x83c>
800086be:	fa c8 f9 50 	sub	r8,sp,-1712
800086c2:	1a d8       	st.w	--sp,r8
800086c4:	fa c8 fa b8 	sub	r8,sp,-1352
800086c8:	1a d8       	st.w	--sp,r8
800086ca:	fa c8 fb b4 	sub	r8,sp,-1100
800086ce:	0c 9b       	mov	r11,r6
800086d0:	1a d8       	st.w	--sp,r8
800086d2:	04 9a       	mov	r10,r2
800086d4:	fa c8 f9 40 	sub	r8,sp,-1728
800086d8:	fa c9 ff b4 	sub	r9,sp,-76
800086dc:	08 9c       	mov	r12,r4
800086de:	fe b0 fa 9d 	rcall	80007c18 <get_arg>
800086e2:	2f dd       	sub	sp,-12
800086e4:	78 16       	ld.w	r6,r12[0x4]
800086e6:	50 76       	stdsp	sp[0x1c],r6
800086e8:	c4 88       	rjmp	80008778 <_vfprintf_r+0x830>
800086ea:	2f f7       	sub	r7,-1
800086ec:	10 39       	cp.w	r9,r8
800086ee:	c0 c4       	brge	80008706 <_vfprintf_r+0x7be>
800086f0:	fa ce f9 44 	sub	lr,sp,-1724
800086f4:	fc 06 00 36 	add	r6,lr,r6<<0x3
800086f8:	ec fc fd 8c 	ld.w	r12,r6[-628]
800086fc:	50 7c       	stdsp	sp[0x1c],r12
800086fe:	ec f6 fd 88 	ld.w	r6,r6[-632]
80008702:	50 56       	stdsp	sp[0x14],r6
80008704:	c6 68       	rjmp	800087d0 <_vfprintf_r+0x888>
80008706:	41 09       	lddsp	r9,sp[0x40]
80008708:	59 f8       	cp.w	r8,31
8000870a:	e0 89 00 10 	brgt	8000872a <_vfprintf_r+0x7e2>
8000870e:	f2 ca ff f8 	sub	r10,r9,-8
80008712:	72 1b       	ld.w	r11,r9[0x4]
80008714:	51 0a       	stdsp	sp[0x40],r10
80008716:	72 09       	ld.w	r9,r9[0x0]
80008718:	fa ca f9 44 	sub	r10,sp,-1724
8000871c:	50 7b       	stdsp	sp[0x1c],r11
8000871e:	50 59       	stdsp	sp[0x14],r9
80008720:	f4 08 00 39 	add	r9,r10,r8<<0x3
80008724:	40 5b       	lddsp	r11,sp[0x14]
80008726:	40 7a       	lddsp	r10,sp[0x1c]
80008728:	c4 78       	rjmp	800087b6 <_vfprintf_r+0x86e>
8000872a:	72 18       	ld.w	r8,r9[0x4]
8000872c:	50 78       	stdsp	sp[0x1c],r8
8000872e:	c4 c8       	rjmp	800087c6 <_vfprintf_r+0x87e>
80008730:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008734:	40 3e       	lddsp	lr,sp[0xc]
80008736:	58 0e       	cp.w	lr,0
80008738:	c2 30       	breq	8000877e <_vfprintf_r+0x836>
8000873a:	10 36       	cp.w	r6,r8
8000873c:	c0 94       	brge	8000874e <_vfprintf_r+0x806>
8000873e:	fa cc f9 44 	sub	r12,sp,-1724
80008742:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008746:	ec fb fd 8c 	ld.w	r11,r6[-628]
8000874a:	50 7b       	stdsp	sp[0x1c],r11
8000874c:	cd 9b       	rjmp	800086fe <_vfprintf_r+0x7b6>
8000874e:	fa c8 f9 50 	sub	r8,sp,-1712
80008752:	1a d8       	st.w	--sp,r8
80008754:	fa c8 fa b8 	sub	r8,sp,-1352
80008758:	04 9a       	mov	r10,r2
8000875a:	1a d8       	st.w	--sp,r8
8000875c:	fa c8 fb b4 	sub	r8,sp,-1100
80008760:	0c 9b       	mov	r11,r6
80008762:	1a d8       	st.w	--sp,r8
80008764:	08 9c       	mov	r12,r4
80008766:	fa c8 f9 40 	sub	r8,sp,-1728
8000876a:	fa c9 ff b4 	sub	r9,sp,-76
8000876e:	fe b0 fa 55 	rcall	80007c18 <get_arg>
80008772:	2f dd       	sub	sp,-12
80008774:	78 1a       	ld.w	r10,r12[0x4]
80008776:	50 7a       	stdsp	sp[0x1c],r10
80008778:	78 0c       	ld.w	r12,r12[0x0]
8000877a:	50 5c       	stdsp	sp[0x14],r12
8000877c:	c2 a8       	rjmp	800087d0 <_vfprintf_r+0x888>
8000877e:	2f f7       	sub	r7,-1
80008780:	10 39       	cp.w	r9,r8
80008782:	c0 94       	brge	80008794 <_vfprintf_r+0x84c>
80008784:	fa c9 f9 44 	sub	r9,sp,-1724
80008788:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000878c:	ec f8 fd 8c 	ld.w	r8,r6[-628]
80008790:	50 78       	stdsp	sp[0x1c],r8
80008792:	cb 6b       	rjmp	800086fe <_vfprintf_r+0x7b6>
80008794:	41 09       	lddsp	r9,sp[0x40]
80008796:	59 f8       	cp.w	r8,31
80008798:	e0 89 00 15 	brgt	800087c2 <_vfprintf_r+0x87a>
8000879c:	f2 ca ff f8 	sub	r10,r9,-8
800087a0:	72 16       	ld.w	r6,r9[0x4]
800087a2:	72 09       	ld.w	r9,r9[0x0]
800087a4:	51 0a       	stdsp	sp[0x40],r10
800087a6:	50 59       	stdsp	sp[0x14],r9
800087a8:	fa ce f9 44 	sub	lr,sp,-1724
800087ac:	50 76       	stdsp	sp[0x1c],r6
800087ae:	fc 08 00 39 	add	r9,lr,r8<<0x3
800087b2:	40 5b       	lddsp	r11,sp[0x14]
800087b4:	0c 9a       	mov	r10,r6
800087b6:	f2 eb fd 88 	st.d	r9[-632],r10
800087ba:	2f f8       	sub	r8,-1
800087bc:	fb 48 06 b4 	st.w	sp[1716],r8
800087c0:	c0 88       	rjmp	800087d0 <_vfprintf_r+0x888>
800087c2:	72 1c       	ld.w	r12,r9[0x4]
800087c4:	50 7c       	stdsp	sp[0x1c],r12
800087c6:	f2 c8 ff f8 	sub	r8,r9,-8
800087ca:	51 08       	stdsp	sp[0x40],r8
800087cc:	72 09       	ld.w	r9,r9[0x0]
800087ce:	50 59       	stdsp	sp[0x14],r9
800087d0:	40 5b       	lddsp	r11,sp[0x14]
800087d2:	40 7a       	lddsp	r10,sp[0x1c]
800087d4:	e0 a0 19 54 	rcall	8000ba7c <__isinfd>
800087d8:	18 96       	mov	r6,r12
800087da:	c1 70       	breq	80008808 <_vfprintf_r+0x8c0>
800087dc:	30 08       	mov	r8,0
800087de:	30 09       	mov	r9,0
800087e0:	40 5b       	lddsp	r11,sp[0x14]
800087e2:	40 7a       	lddsp	r10,sp[0x1c]
800087e4:	e0 a0 1d b4 	rcall	8000c34c <__avr32_f64_cmp_lt>
800087e8:	c0 40       	breq	800087f0 <_vfprintf_r+0x8a8>
800087ea:	32 d8       	mov	r8,45
800087ec:	fb 68 06 bb 	st.b	sp[1723],r8
800087f0:	fe c8 ab 74 	sub	r8,pc,-21644
800087f4:	fe c6 ab 74 	sub	r6,pc,-21644
800087f8:	a7 d5       	cbr	r5,0x7
800087fa:	e0 40 00 47 	cp.w	r0,71
800087fe:	f0 06 17 a0 	movle	r6,r8
80008802:	30 32       	mov	r2,3
80008804:	e0 8f 06 ce 	bral	800095a0 <_vfprintf_r+0x1658>
80008808:	40 5b       	lddsp	r11,sp[0x14]
8000880a:	40 7a       	lddsp	r10,sp[0x1c]
8000880c:	e0 a0 19 4d 	rcall	8000baa6 <__isnand>
80008810:	c0 e0       	breq	8000882c <_vfprintf_r+0x8e4>
80008812:	50 26       	stdsp	sp[0x8],r6
80008814:	fe c8 ab 90 	sub	r8,pc,-21616
80008818:	fe c6 ab 90 	sub	r6,pc,-21616
8000881c:	a7 d5       	cbr	r5,0x7
8000881e:	e0 40 00 47 	cp.w	r0,71
80008822:	f0 06 17 a0 	movle	r6,r8
80008826:	30 32       	mov	r2,3
80008828:	e0 8f 06 c2 	bral	800095ac <_vfprintf_r+0x1664>
8000882c:	40 2a       	lddsp	r10,sp[0x8]
8000882e:	5b fa       	cp.w	r10,-1
80008830:	c0 41       	brne	80008838 <_vfprintf_r+0x8f0>
80008832:	30 69       	mov	r9,6
80008834:	50 29       	stdsp	sp[0x8],r9
80008836:	c1 18       	rjmp	80008858 <_vfprintf_r+0x910>
80008838:	e0 40 00 47 	cp.w	r0,71
8000883c:	5f 09       	sreq	r9
8000883e:	e0 40 00 67 	cp.w	r0,103
80008842:	5f 08       	sreq	r8
80008844:	f3 e8 10 08 	or	r8,r9,r8
80008848:	f8 08 18 00 	cp.b	r8,r12
8000884c:	c0 60       	breq	80008858 <_vfprintf_r+0x910>
8000884e:	40 28       	lddsp	r8,sp[0x8]
80008850:	58 08       	cp.w	r8,0
80008852:	f9 b8 00 01 	moveq	r8,1
80008856:	50 28       	stdsp	sp[0x8],r8
80008858:	40 78       	lddsp	r8,sp[0x1c]
8000885a:	40 59       	lddsp	r9,sp[0x14]
8000885c:	fa e9 06 94 	st.d	sp[1684],r8
80008860:	a9 a5       	sbr	r5,0x8
80008862:	fa f8 06 94 	ld.w	r8,sp[1684]
80008866:	58 08       	cp.w	r8,0
80008868:	c0 65       	brlt	80008874 <_vfprintf_r+0x92c>
8000886a:	40 5e       	lddsp	lr,sp[0x14]
8000886c:	30 0c       	mov	r12,0
8000886e:	50 6e       	stdsp	sp[0x18],lr
80008870:	50 9c       	stdsp	sp[0x24],r12
80008872:	c0 78       	rjmp	80008880 <_vfprintf_r+0x938>
80008874:	40 5b       	lddsp	r11,sp[0x14]
80008876:	32 da       	mov	r10,45
80008878:	ee 1b 80 00 	eorh	r11,0x8000
8000887c:	50 9a       	stdsp	sp[0x24],r10
8000887e:	50 6b       	stdsp	sp[0x18],r11
80008880:	e0 40 00 46 	cp.w	r0,70
80008884:	5f 09       	sreq	r9
80008886:	e0 40 00 66 	cp.w	r0,102
8000888a:	5f 08       	sreq	r8
8000888c:	f3 e8 10 08 	or	r8,r9,r8
80008890:	50 48       	stdsp	sp[0x10],r8
80008892:	c0 40       	breq	8000889a <_vfprintf_r+0x952>
80008894:	40 22       	lddsp	r2,sp[0x8]
80008896:	30 39       	mov	r9,3
80008898:	c1 08       	rjmp	800088b8 <_vfprintf_r+0x970>
8000889a:	e0 40 00 45 	cp.w	r0,69
8000889e:	5f 09       	sreq	r9
800088a0:	e0 40 00 65 	cp.w	r0,101
800088a4:	5f 08       	sreq	r8
800088a6:	40 22       	lddsp	r2,sp[0x8]
800088a8:	10 49       	or	r9,r8
800088aa:	2f f2       	sub	r2,-1
800088ac:	40 46       	lddsp	r6,sp[0x10]
800088ae:	ec 09 18 00 	cp.b	r9,r6
800088b2:	fb f2 00 02 	ld.weq	r2,sp[0x8]
800088b6:	30 29       	mov	r9,2
800088b8:	fa c8 f9 5c 	sub	r8,sp,-1700
800088bc:	1a d8       	st.w	--sp,r8
800088be:	fa c8 f9 54 	sub	r8,sp,-1708
800088c2:	1a d8       	st.w	--sp,r8
800088c4:	fa c8 f9 4c 	sub	r8,sp,-1716
800088c8:	08 9c       	mov	r12,r4
800088ca:	1a d8       	st.w	--sp,r8
800088cc:	04 98       	mov	r8,r2
800088ce:	40 9b       	lddsp	r11,sp[0x24]
800088d0:	40 aa       	lddsp	r10,sp[0x28]
800088d2:	e0 a0 0b c3 	rcall	8000a058 <_dtoa_r>
800088d6:	e0 40 00 47 	cp.w	r0,71
800088da:	5f 19       	srne	r9
800088dc:	e0 40 00 67 	cp.w	r0,103
800088e0:	5f 18       	srne	r8
800088e2:	18 96       	mov	r6,r12
800088e4:	2f dd       	sub	sp,-12
800088e6:	f3 e8 00 08 	and	r8,r9,r8
800088ea:	c0 41       	brne	800088f2 <_vfprintf_r+0x9aa>
800088ec:	ed b5 00 00 	bld	r5,0x0
800088f0:	c3 01       	brne	80008950 <_vfprintf_r+0xa08>
800088f2:	ec 02 00 0e 	add	lr,r6,r2
800088f6:	50 3e       	stdsp	sp[0xc],lr
800088f8:	40 4c       	lddsp	r12,sp[0x10]
800088fa:	58 0c       	cp.w	r12,0
800088fc:	c1 50       	breq	80008926 <_vfprintf_r+0x9de>
800088fe:	0d 89       	ld.ub	r9,r6[0x0]
80008900:	33 08       	mov	r8,48
80008902:	f0 09 18 00 	cp.b	r9,r8
80008906:	c0 b1       	brne	8000891c <_vfprintf_r+0x9d4>
80008908:	30 08       	mov	r8,0
8000890a:	30 09       	mov	r9,0
8000890c:	40 6b       	lddsp	r11,sp[0x18]
8000890e:	40 7a       	lddsp	r10,sp[0x1c]
80008910:	e0 a0 1c d7 	rcall	8000c2be <__avr32_f64_cmp_eq>
80008914:	fb b2 00 01 	rsubeq	r2,1
80008918:	fb f2 0b ab 	st.weq	sp[0x6ac],r2
8000891c:	40 3b       	lddsp	r11,sp[0xc]
8000891e:	fa f8 06 ac 	ld.w	r8,sp[1708]
80008922:	10 0b       	add	r11,r8
80008924:	50 3b       	stdsp	sp[0xc],r11
80008926:	40 6b       	lddsp	r11,sp[0x18]
80008928:	30 08       	mov	r8,0
8000892a:	30 09       	mov	r9,0
8000892c:	40 7a       	lddsp	r10,sp[0x1c]
8000892e:	e0 a0 1c c8 	rcall	8000c2be <__avr32_f64_cmp_eq>
80008932:	c0 90       	breq	80008944 <_vfprintf_r+0x9fc>
80008934:	40 3a       	lddsp	r10,sp[0xc]
80008936:	fb 4a 06 a4 	st.w	sp[1700],r10
8000893a:	c0 58       	rjmp	80008944 <_vfprintf_r+0x9fc>
8000893c:	10 c9       	st.b	r8++,r9
8000893e:	fb 48 06 a4 	st.w	sp[1700],r8
80008942:	c0 28       	rjmp	80008946 <_vfprintf_r+0x9fe>
80008944:	33 09       	mov	r9,48
80008946:	fa f8 06 a4 	ld.w	r8,sp[1700]
8000894a:	40 3e       	lddsp	lr,sp[0xc]
8000894c:	1c 38       	cp.w	r8,lr
8000894e:	cf 73       	brcs	8000893c <_vfprintf_r+0x9f4>
80008950:	e0 40 00 47 	cp.w	r0,71
80008954:	5f 09       	sreq	r9
80008956:	e0 40 00 67 	cp.w	r0,103
8000895a:	5f 08       	sreq	r8
8000895c:	f3 e8 10 08 	or	r8,r9,r8
80008960:	fa f9 06 a4 	ld.w	r9,sp[1700]
80008964:	0c 19       	sub	r9,r6
80008966:	50 69       	stdsp	sp[0x18],r9
80008968:	58 08       	cp.w	r8,0
8000896a:	c0 b0       	breq	80008980 <_vfprintf_r+0xa38>
8000896c:	fa f8 06 ac 	ld.w	r8,sp[1708]
80008970:	5b d8       	cp.w	r8,-3
80008972:	c0 55       	brlt	8000897c <_vfprintf_r+0xa34>
80008974:	40 2c       	lddsp	r12,sp[0x8]
80008976:	18 38       	cp.w	r8,r12
80008978:	e0 8a 00 6a 	brle	80008a4c <_vfprintf_r+0xb04>
8000897c:	20 20       	sub	r0,2
8000897e:	c0 58       	rjmp	80008988 <_vfprintf_r+0xa40>
80008980:	e0 40 00 65 	cp.w	r0,101
80008984:	e0 89 00 46 	brgt	80008a10 <_vfprintf_r+0xac8>
80008988:	fa fb 06 ac 	ld.w	r11,sp[1708]
8000898c:	fb 60 06 9c 	st.b	sp[1692],r0
80008990:	20 1b       	sub	r11,1
80008992:	fb 4b 06 ac 	st.w	sp[1708],r11
80008996:	c0 47       	brpl	8000899e <_vfprintf_r+0xa56>
80008998:	5c 3b       	neg	r11
8000899a:	32 d8       	mov	r8,45
8000899c:	c0 28       	rjmp	800089a0 <_vfprintf_r+0xa58>
8000899e:	32 b8       	mov	r8,43
800089a0:	fb 68 06 9d 	st.b	sp[1693],r8
800089a4:	58 9b       	cp.w	r11,9
800089a6:	e0 8a 00 1d 	brle	800089e0 <_vfprintf_r+0xa98>
800089aa:	fa c9 fa 35 	sub	r9,sp,-1483
800089ae:	30 aa       	mov	r10,10
800089b0:	12 98       	mov	r8,r9
800089b2:	0e 9c       	mov	r12,r7
800089b4:	0c 92       	mov	r2,r6
800089b6:	f6 0a 0c 06 	divs	r6,r11,r10
800089ba:	0e 9b       	mov	r11,r7
800089bc:	2d 0b       	sub	r11,-48
800089be:	10 fb       	st.b	--r8,r11
800089c0:	0c 9b       	mov	r11,r6
800089c2:	58 96       	cp.w	r6,9
800089c4:	fe 99 ff f9 	brgt	800089b6 <_vfprintf_r+0xa6e>
800089c8:	2d 0b       	sub	r11,-48
800089ca:	18 97       	mov	r7,r12
800089cc:	04 96       	mov	r6,r2
800089ce:	10 fb       	st.b	--r8,r11
800089d0:	fa ca f9 62 	sub	r10,sp,-1694
800089d4:	c0 38       	rjmp	800089da <_vfprintf_r+0xa92>
800089d6:	11 3b       	ld.ub	r11,r8++
800089d8:	14 cb       	st.b	r10++,r11
800089da:	12 38       	cp.w	r8,r9
800089dc:	cf d3       	brcs	800089d6 <_vfprintf_r+0xa8e>
800089de:	c0 98       	rjmp	800089f0 <_vfprintf_r+0xaa8>
800089e0:	2d 0b       	sub	r11,-48
800089e2:	33 08       	mov	r8,48
800089e4:	fb 6b 06 9f 	st.b	sp[1695],r11
800089e8:	fb 68 06 9e 	st.b	sp[1694],r8
800089ec:	fa ca f9 60 	sub	r10,sp,-1696
800089f0:	fa c8 f9 64 	sub	r8,sp,-1692
800089f4:	f4 08 01 08 	sub	r8,r10,r8
800089f8:	50 e8       	stdsp	sp[0x38],r8
800089fa:	10 92       	mov	r2,r8
800089fc:	40 6b       	lddsp	r11,sp[0x18]
800089fe:	16 02       	add	r2,r11
80008a00:	58 1b       	cp.w	r11,1
80008a02:	e0 89 00 05 	brgt	80008a0c <_vfprintf_r+0xac4>
80008a06:	ed b5 00 00 	bld	r5,0x0
80008a0a:	c3 51       	brne	80008a74 <_vfprintf_r+0xb2c>
80008a0c:	2f f2       	sub	r2,-1
80008a0e:	c3 38       	rjmp	80008a74 <_vfprintf_r+0xb2c>
80008a10:	e0 40 00 66 	cp.w	r0,102
80008a14:	c1 c1       	brne	80008a4c <_vfprintf_r+0xb04>
80008a16:	fa f2 06 ac 	ld.w	r2,sp[1708]
80008a1a:	58 02       	cp.w	r2,0
80008a1c:	e0 8a 00 0c 	brle	80008a34 <_vfprintf_r+0xaec>
80008a20:	40 2a       	lddsp	r10,sp[0x8]
80008a22:	58 0a       	cp.w	r10,0
80008a24:	c0 41       	brne	80008a2c <_vfprintf_r+0xae4>
80008a26:	ed b5 00 00 	bld	r5,0x0
80008a2a:	c2 51       	brne	80008a74 <_vfprintf_r+0xb2c>
80008a2c:	2f f2       	sub	r2,-1
80008a2e:	40 29       	lddsp	r9,sp[0x8]
80008a30:	12 02       	add	r2,r9
80008a32:	c0 b8       	rjmp	80008a48 <_vfprintf_r+0xb00>
80008a34:	40 28       	lddsp	r8,sp[0x8]
80008a36:	58 08       	cp.w	r8,0
80008a38:	c0 61       	brne	80008a44 <_vfprintf_r+0xafc>
80008a3a:	ed b5 00 00 	bld	r5,0x0
80008a3e:	c0 30       	breq	80008a44 <_vfprintf_r+0xafc>
80008a40:	30 12       	mov	r2,1
80008a42:	c1 98       	rjmp	80008a74 <_vfprintf_r+0xb2c>
80008a44:	40 22       	lddsp	r2,sp[0x8]
80008a46:	2f e2       	sub	r2,-2
80008a48:	36 60       	mov	r0,102
80008a4a:	c1 58       	rjmp	80008a74 <_vfprintf_r+0xb2c>
80008a4c:	fa f2 06 ac 	ld.w	r2,sp[1708]
80008a50:	40 6e       	lddsp	lr,sp[0x18]
80008a52:	1c 32       	cp.w	r2,lr
80008a54:	c0 65       	brlt	80008a60 <_vfprintf_r+0xb18>
80008a56:	ed b5 00 00 	bld	r5,0x0
80008a5a:	f7 b2 00 ff 	subeq	r2,-1
80008a5e:	c0 a8       	rjmp	80008a72 <_vfprintf_r+0xb2a>
80008a60:	e4 08 11 02 	rsub	r8,r2,2
80008a64:	40 6c       	lddsp	r12,sp[0x18]
80008a66:	58 02       	cp.w	r2,0
80008a68:	f0 02 17 a0 	movle	r2,r8
80008a6c:	f9 b2 09 01 	movgt	r2,1
80008a70:	18 02       	add	r2,r12
80008a72:	36 70       	mov	r0,103
80008a74:	40 9b       	lddsp	r11,sp[0x24]
80008a76:	58 0b       	cp.w	r11,0
80008a78:	e0 80 05 94 	breq	800095a0 <_vfprintf_r+0x1658>
80008a7c:	32 d8       	mov	r8,45
80008a7e:	fb 68 06 bb 	st.b	sp[1723],r8
80008a82:	e0 8f 05 93 	bral	800095a8 <_vfprintf_r+0x1660>
80008a86:	50 a7       	stdsp	sp[0x28],r7
80008a88:	04 94       	mov	r4,r2
80008a8a:	0c 97       	mov	r7,r6
80008a8c:	02 92       	mov	r2,r1
80008a8e:	06 96       	mov	r6,r3
80008a90:	40 41       	lddsp	r1,sp[0x10]
80008a92:	40 93       	lddsp	r3,sp[0x24]
80008a94:	0e 99       	mov	r9,r7
80008a96:	ed b5 00 05 	bld	r5,0x5
80008a9a:	c4 81       	brne	80008b2a <_vfprintf_r+0xbe2>
80008a9c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008aa0:	40 3e       	lddsp	lr,sp[0xc]
80008aa2:	58 0e       	cp.w	lr,0
80008aa4:	c1 d0       	breq	80008ade <_vfprintf_r+0xb96>
80008aa6:	10 36       	cp.w	r6,r8
80008aa8:	c0 64       	brge	80008ab4 <_vfprintf_r+0xb6c>
80008aaa:	fa cc f9 44 	sub	r12,sp,-1724
80008aae:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008ab2:	c1 d8       	rjmp	80008aec <_vfprintf_r+0xba4>
80008ab4:	fa c8 f9 50 	sub	r8,sp,-1712
80008ab8:	1a d8       	st.w	--sp,r8
80008aba:	fa c8 fa b8 	sub	r8,sp,-1352
80008abe:	04 9a       	mov	r10,r2
80008ac0:	1a d8       	st.w	--sp,r8
80008ac2:	fa c8 fb b4 	sub	r8,sp,-1100
80008ac6:	0c 9b       	mov	r11,r6
80008ac8:	1a d8       	st.w	--sp,r8
80008aca:	08 9c       	mov	r12,r4
80008acc:	fa c8 f9 40 	sub	r8,sp,-1728
80008ad0:	fa c9 ff b4 	sub	r9,sp,-76
80008ad4:	fe b0 f8 a2 	rcall	80007c18 <get_arg>
80008ad8:	2f dd       	sub	sp,-12
80008ada:	78 0a       	ld.w	r10,r12[0x0]
80008adc:	c2 08       	rjmp	80008b1c <_vfprintf_r+0xbd4>
80008ade:	2f f7       	sub	r7,-1
80008ae0:	10 39       	cp.w	r9,r8
80008ae2:	c0 84       	brge	80008af2 <_vfprintf_r+0xbaa>
80008ae4:	fa cb f9 44 	sub	r11,sp,-1724
80008ae8:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008aec:	ec fa fd 88 	ld.w	r10,r6[-632]
80008af0:	c1 68       	rjmp	80008b1c <_vfprintf_r+0xbd4>
80008af2:	41 09       	lddsp	r9,sp[0x40]
80008af4:	59 f8       	cp.w	r8,31
80008af6:	e0 89 00 10 	brgt	80008b16 <_vfprintf_r+0xbce>
80008afa:	f2 ca ff fc 	sub	r10,r9,-4
80008afe:	51 0a       	stdsp	sp[0x40],r10
80008b00:	fa c6 f9 44 	sub	r6,sp,-1724
80008b04:	72 0a       	ld.w	r10,r9[0x0]
80008b06:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008b0a:	f3 4a fd 88 	st.w	r9[-632],r10
80008b0e:	2f f8       	sub	r8,-1
80008b10:	fb 48 06 b4 	st.w	sp[1716],r8
80008b14:	c0 48       	rjmp	80008b1c <_vfprintf_r+0xbd4>
80008b16:	72 0a       	ld.w	r10,r9[0x0]
80008b18:	2f c9       	sub	r9,-4
80008b1a:	51 09       	stdsp	sp[0x40],r9
80008b1c:	40 be       	lddsp	lr,sp[0x2c]
80008b1e:	1c 98       	mov	r8,lr
80008b20:	95 1e       	st.w	r10[0x4],lr
80008b22:	bf 58       	asr	r8,0x1f
80008b24:	95 08       	st.w	r10[0x0],r8
80008b26:	fe 9f fa 9f 	bral	80008064 <_vfprintf_r+0x11c>
80008b2a:	ed b5 00 04 	bld	r5,0x4
80008b2e:	c4 80       	breq	80008bbe <_vfprintf_r+0xc76>
80008b30:	e2 15 00 40 	andl	r5,0x40,COH
80008b34:	c4 50       	breq	80008bbe <_vfprintf_r+0xc76>
80008b36:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008b3a:	40 3c       	lddsp	r12,sp[0xc]
80008b3c:	58 0c       	cp.w	r12,0
80008b3e:	c1 d0       	breq	80008b78 <_vfprintf_r+0xc30>
80008b40:	10 36       	cp.w	r6,r8
80008b42:	c0 64       	brge	80008b4e <_vfprintf_r+0xc06>
80008b44:	fa cb f9 44 	sub	r11,sp,-1724
80008b48:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008b4c:	c1 d8       	rjmp	80008b86 <_vfprintf_r+0xc3e>
80008b4e:	fa c8 f9 50 	sub	r8,sp,-1712
80008b52:	1a d8       	st.w	--sp,r8
80008b54:	fa c8 fa b8 	sub	r8,sp,-1352
80008b58:	04 9a       	mov	r10,r2
80008b5a:	1a d8       	st.w	--sp,r8
80008b5c:	fa c8 fb b4 	sub	r8,sp,-1100
80008b60:	0c 9b       	mov	r11,r6
80008b62:	1a d8       	st.w	--sp,r8
80008b64:	08 9c       	mov	r12,r4
80008b66:	fa c8 f9 40 	sub	r8,sp,-1728
80008b6a:	fa c9 ff b4 	sub	r9,sp,-76
80008b6e:	fe b0 f8 55 	rcall	80007c18 <get_arg>
80008b72:	2f dd       	sub	sp,-12
80008b74:	78 0a       	ld.w	r10,r12[0x0]
80008b76:	c2 08       	rjmp	80008bb6 <_vfprintf_r+0xc6e>
80008b78:	2f f7       	sub	r7,-1
80008b7a:	10 39       	cp.w	r9,r8
80008b7c:	c0 84       	brge	80008b8c <_vfprintf_r+0xc44>
80008b7e:	fa ca f9 44 	sub	r10,sp,-1724
80008b82:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008b86:	ec fa fd 88 	ld.w	r10,r6[-632]
80008b8a:	c1 68       	rjmp	80008bb6 <_vfprintf_r+0xc6e>
80008b8c:	41 09       	lddsp	r9,sp[0x40]
80008b8e:	59 f8       	cp.w	r8,31
80008b90:	e0 89 00 10 	brgt	80008bb0 <_vfprintf_r+0xc68>
80008b94:	f2 ca ff fc 	sub	r10,r9,-4
80008b98:	51 0a       	stdsp	sp[0x40],r10
80008b9a:	fa c6 f9 44 	sub	r6,sp,-1724
80008b9e:	72 0a       	ld.w	r10,r9[0x0]
80008ba0:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008ba4:	f3 4a fd 88 	st.w	r9[-632],r10
80008ba8:	2f f8       	sub	r8,-1
80008baa:	fb 48 06 b4 	st.w	sp[1716],r8
80008bae:	c0 48       	rjmp	80008bb6 <_vfprintf_r+0xc6e>
80008bb0:	72 0a       	ld.w	r10,r9[0x0]
80008bb2:	2f c9       	sub	r9,-4
80008bb4:	51 09       	stdsp	sp[0x40],r9
80008bb6:	40 be       	lddsp	lr,sp[0x2c]
80008bb8:	b4 0e       	st.h	r10[0x0],lr
80008bba:	fe 9f fa 55 	bral	80008064 <_vfprintf_r+0x11c>
80008bbe:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008bc2:	40 3c       	lddsp	r12,sp[0xc]
80008bc4:	58 0c       	cp.w	r12,0
80008bc6:	c1 d0       	breq	80008c00 <_vfprintf_r+0xcb8>
80008bc8:	10 36       	cp.w	r6,r8
80008bca:	c0 64       	brge	80008bd6 <_vfprintf_r+0xc8e>
80008bcc:	fa cb f9 44 	sub	r11,sp,-1724
80008bd0:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008bd4:	c1 d8       	rjmp	80008c0e <_vfprintf_r+0xcc6>
80008bd6:	fa c8 f9 50 	sub	r8,sp,-1712
80008bda:	1a d8       	st.w	--sp,r8
80008bdc:	fa c8 fa b8 	sub	r8,sp,-1352
80008be0:	04 9a       	mov	r10,r2
80008be2:	1a d8       	st.w	--sp,r8
80008be4:	fa c8 fb b4 	sub	r8,sp,-1100
80008be8:	0c 9b       	mov	r11,r6
80008bea:	1a d8       	st.w	--sp,r8
80008bec:	08 9c       	mov	r12,r4
80008bee:	fa c8 f9 40 	sub	r8,sp,-1728
80008bf2:	fa c9 ff b4 	sub	r9,sp,-76
80008bf6:	fe b0 f8 11 	rcall	80007c18 <get_arg>
80008bfa:	2f dd       	sub	sp,-12
80008bfc:	78 0a       	ld.w	r10,r12[0x0]
80008bfe:	c2 08       	rjmp	80008c3e <_vfprintf_r+0xcf6>
80008c00:	2f f7       	sub	r7,-1
80008c02:	10 39       	cp.w	r9,r8
80008c04:	c0 84       	brge	80008c14 <_vfprintf_r+0xccc>
80008c06:	fa ca f9 44 	sub	r10,sp,-1724
80008c0a:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008c0e:	ec fa fd 88 	ld.w	r10,r6[-632]
80008c12:	c1 68       	rjmp	80008c3e <_vfprintf_r+0xcf6>
80008c14:	41 09       	lddsp	r9,sp[0x40]
80008c16:	59 f8       	cp.w	r8,31
80008c18:	e0 89 00 10 	brgt	80008c38 <_vfprintf_r+0xcf0>
80008c1c:	f2 ca ff fc 	sub	r10,r9,-4
80008c20:	51 0a       	stdsp	sp[0x40],r10
80008c22:	fa c6 f9 44 	sub	r6,sp,-1724
80008c26:	72 0a       	ld.w	r10,r9[0x0]
80008c28:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008c2c:	f3 4a fd 88 	st.w	r9[-632],r10
80008c30:	2f f8       	sub	r8,-1
80008c32:	fb 48 06 b4 	st.w	sp[1716],r8
80008c36:	c0 48       	rjmp	80008c3e <_vfprintf_r+0xcf6>
80008c38:	72 0a       	ld.w	r10,r9[0x0]
80008c3a:	2f c9       	sub	r9,-4
80008c3c:	51 09       	stdsp	sp[0x40],r9
80008c3e:	40 be       	lddsp	lr,sp[0x2c]
80008c40:	95 0e       	st.w	r10[0x0],lr
80008c42:	fe 9f fa 11 	bral	80008064 <_vfprintf_r+0x11c>
80008c46:	50 a7       	stdsp	sp[0x28],r7
80008c48:	50 80       	stdsp	sp[0x20],r0
80008c4a:	0c 97       	mov	r7,r6
80008c4c:	04 94       	mov	r4,r2
80008c4e:	06 96       	mov	r6,r3
80008c50:	02 92       	mov	r2,r1
80008c52:	40 93       	lddsp	r3,sp[0x24]
80008c54:	10 90       	mov	r0,r8
80008c56:	40 41       	lddsp	r1,sp[0x10]
80008c58:	a5 a5       	sbr	r5,0x4
80008c5a:	c0 a8       	rjmp	80008c6e <_vfprintf_r+0xd26>
80008c5c:	50 a7       	stdsp	sp[0x28],r7
80008c5e:	50 80       	stdsp	sp[0x20],r0
80008c60:	0c 97       	mov	r7,r6
80008c62:	04 94       	mov	r4,r2
80008c64:	06 96       	mov	r6,r3
80008c66:	02 92       	mov	r2,r1
80008c68:	40 93       	lddsp	r3,sp[0x24]
80008c6a:	10 90       	mov	r0,r8
80008c6c:	40 41       	lddsp	r1,sp[0x10]
80008c6e:	ed b5 00 05 	bld	r5,0x5
80008c72:	c5 d1       	brne	80008d2c <_vfprintf_r+0xde4>
80008c74:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008c78:	40 3c       	lddsp	r12,sp[0xc]
80008c7a:	58 0c       	cp.w	r12,0
80008c7c:	c2 60       	breq	80008cc8 <_vfprintf_r+0xd80>
80008c7e:	10 36       	cp.w	r6,r8
80008c80:	c0 a4       	brge	80008c94 <_vfprintf_r+0xd4c>
80008c82:	fa cb f9 44 	sub	r11,sp,-1724
80008c86:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008c8a:	ec e8 fd 88 	ld.d	r8,r6[-632]
80008c8e:	fa e9 00 00 	st.d	sp[0],r8
80008c92:	c1 88       	rjmp	80008cc2 <_vfprintf_r+0xd7a>
80008c94:	fa c8 f9 50 	sub	r8,sp,-1712
80008c98:	1a d8       	st.w	--sp,r8
80008c9a:	fa c8 fa b8 	sub	r8,sp,-1352
80008c9e:	04 9a       	mov	r10,r2
80008ca0:	1a d8       	st.w	--sp,r8
80008ca2:	0c 9b       	mov	r11,r6
80008ca4:	fa c8 fb b4 	sub	r8,sp,-1100
80008ca8:	08 9c       	mov	r12,r4
80008caa:	1a d8       	st.w	--sp,r8
80008cac:	fa c8 f9 40 	sub	r8,sp,-1728
80008cb0:	fa c9 ff b4 	sub	r9,sp,-76
80008cb4:	fe b0 f7 b2 	rcall	80007c18 <get_arg>
80008cb8:	2f dd       	sub	sp,-12
80008cba:	f8 ea 00 00 	ld.d	r10,r12[0]
80008cbe:	fa eb 00 00 	st.d	sp[0],r10
80008cc2:	30 08       	mov	r8,0
80008cc4:	e0 8f 03 de 	bral	80009480 <_vfprintf_r+0x1538>
80008cc8:	ee ca ff ff 	sub	r10,r7,-1
80008ccc:	10 37       	cp.w	r7,r8
80008cce:	c0 b4       	brge	80008ce4 <_vfprintf_r+0xd9c>
80008cd0:	fa c9 f9 44 	sub	r9,sp,-1724
80008cd4:	14 97       	mov	r7,r10
80008cd6:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008cda:	ec ea fd 88 	ld.d	r10,r6[-632]
80008cde:	fa eb 00 00 	st.d	sp[0],r10
80008ce2:	c1 88       	rjmp	80008d12 <_vfprintf_r+0xdca>
80008ce4:	41 09       	lddsp	r9,sp[0x40]
80008ce6:	59 f8       	cp.w	r8,31
80008ce8:	e0 89 00 18 	brgt	80008d18 <_vfprintf_r+0xdd0>
80008cec:	f2 e6 00 00 	ld.d	r6,r9[0]
80008cf0:	f2 cb ff f8 	sub	r11,r9,-8
80008cf4:	fa e7 00 00 	st.d	sp[0],r6
80008cf8:	51 0b       	stdsp	sp[0x40],r11
80008cfa:	fa c6 f9 44 	sub	r6,sp,-1724
80008cfe:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008d02:	fa e6 00 00 	ld.d	r6,sp[0]
80008d06:	f2 e7 fd 88 	st.d	r9[-632],r6
80008d0a:	2f f8       	sub	r8,-1
80008d0c:	14 97       	mov	r7,r10
80008d0e:	fb 48 06 b4 	st.w	sp[1716],r8
80008d12:	40 38       	lddsp	r8,sp[0xc]
80008d14:	e0 8f 03 b6 	bral	80009480 <_vfprintf_r+0x1538>
80008d18:	f2 e6 00 00 	ld.d	r6,r9[0]
80008d1c:	40 38       	lddsp	r8,sp[0xc]
80008d1e:	fa e7 00 00 	st.d	sp[0],r6
80008d22:	2f 89       	sub	r9,-8
80008d24:	14 97       	mov	r7,r10
80008d26:	51 09       	stdsp	sp[0x40],r9
80008d28:	e0 8f 03 ac 	bral	80009480 <_vfprintf_r+0x1538>
80008d2c:	ed b5 00 04 	bld	r5,0x4
80008d30:	c1 61       	brne	80008d5c <_vfprintf_r+0xe14>
80008d32:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008d36:	40 3e       	lddsp	lr,sp[0xc]
80008d38:	58 0e       	cp.w	lr,0
80008d3a:	c0 80       	breq	80008d4a <_vfprintf_r+0xe02>
80008d3c:	10 36       	cp.w	r6,r8
80008d3e:	c6 74       	brge	80008e0c <_vfprintf_r+0xec4>
80008d40:	fa cc f9 44 	sub	r12,sp,-1724
80008d44:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008d48:	c8 08       	rjmp	80008e48 <_vfprintf_r+0xf00>
80008d4a:	ee ca ff ff 	sub	r10,r7,-1
80008d4e:	10 37       	cp.w	r7,r8
80008d50:	c7 f4       	brge	80008e4e <_vfprintf_r+0xf06>
80008d52:	fa cb f9 44 	sub	r11,sp,-1724
80008d56:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008d5a:	c7 68       	rjmp	80008e46 <_vfprintf_r+0xefe>
80008d5c:	ed b5 00 06 	bld	r5,0x6
80008d60:	c4 a1       	brne	80008df4 <_vfprintf_r+0xeac>
80008d62:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008d66:	40 3c       	lddsp	r12,sp[0xc]
80008d68:	58 0c       	cp.w	r12,0
80008d6a:	c1 d0       	breq	80008da4 <_vfprintf_r+0xe5c>
80008d6c:	10 36       	cp.w	r6,r8
80008d6e:	c0 64       	brge	80008d7a <_vfprintf_r+0xe32>
80008d70:	fa cb f9 44 	sub	r11,sp,-1724
80008d74:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008d78:	c1 f8       	rjmp	80008db6 <_vfprintf_r+0xe6e>
80008d7a:	fa c8 f9 50 	sub	r8,sp,-1712
80008d7e:	1a d8       	st.w	--sp,r8
80008d80:	fa c8 fa b8 	sub	r8,sp,-1352
80008d84:	1a d8       	st.w	--sp,r8
80008d86:	fa c8 fb b4 	sub	r8,sp,-1100
80008d8a:	1a d8       	st.w	--sp,r8
80008d8c:	fa c8 f9 40 	sub	r8,sp,-1728
80008d90:	fa c9 ff b4 	sub	r9,sp,-76
80008d94:	04 9a       	mov	r10,r2
80008d96:	0c 9b       	mov	r11,r6
80008d98:	08 9c       	mov	r12,r4
80008d9a:	fe b0 f7 3f 	rcall	80007c18 <get_arg>
80008d9e:	2f dd       	sub	sp,-12
80008da0:	98 18       	ld.sh	r8,r12[0x2]
80008da2:	c2 68       	rjmp	80008dee <_vfprintf_r+0xea6>
80008da4:	ee ca ff ff 	sub	r10,r7,-1
80008da8:	10 37       	cp.w	r7,r8
80008daa:	c0 94       	brge	80008dbc <_vfprintf_r+0xe74>
80008dac:	fa c9 f9 44 	sub	r9,sp,-1724
80008db0:	14 97       	mov	r7,r10
80008db2:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008db6:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80008dba:	c1 a8       	rjmp	80008dee <_vfprintf_r+0xea6>
80008dbc:	41 09       	lddsp	r9,sp[0x40]
80008dbe:	59 f8       	cp.w	r8,31
80008dc0:	e0 89 00 13 	brgt	80008de6 <_vfprintf_r+0xe9e>
80008dc4:	f2 cb ff fc 	sub	r11,r9,-4
80008dc8:	51 0b       	stdsp	sp[0x40],r11
80008dca:	72 09       	ld.w	r9,r9[0x0]
80008dcc:	fa c6 f9 44 	sub	r6,sp,-1724
80008dd0:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80008dd4:	2f f8       	sub	r8,-1
80008dd6:	f7 49 fd 88 	st.w	r11[-632],r9
80008dda:	fb 48 06 b4 	st.w	sp[1716],r8
80008dde:	14 97       	mov	r7,r10
80008de0:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80008de4:	c0 58       	rjmp	80008dee <_vfprintf_r+0xea6>
80008de6:	92 18       	ld.sh	r8,r9[0x2]
80008de8:	14 97       	mov	r7,r10
80008dea:	2f c9       	sub	r9,-4
80008dec:	51 09       	stdsp	sp[0x40],r9
80008dee:	5c 78       	castu.h	r8
80008df0:	50 18       	stdsp	sp[0x4],r8
80008df2:	c4 68       	rjmp	80008e7e <_vfprintf_r+0xf36>
80008df4:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008df8:	40 3c       	lddsp	r12,sp[0xc]
80008dfa:	58 0c       	cp.w	r12,0
80008dfc:	c1 d0       	breq	80008e36 <_vfprintf_r+0xeee>
80008dfe:	10 36       	cp.w	r6,r8
80008e00:	c0 64       	brge	80008e0c <_vfprintf_r+0xec4>
80008e02:	fa cb f9 44 	sub	r11,sp,-1724
80008e06:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008e0a:	c1 f8       	rjmp	80008e48 <_vfprintf_r+0xf00>
80008e0c:	fa c8 f9 50 	sub	r8,sp,-1712
80008e10:	1a d8       	st.w	--sp,r8
80008e12:	fa c8 fa b8 	sub	r8,sp,-1352
80008e16:	0c 9b       	mov	r11,r6
80008e18:	1a d8       	st.w	--sp,r8
80008e1a:	fa c8 fb b4 	sub	r8,sp,-1100
80008e1e:	04 9a       	mov	r10,r2
80008e20:	1a d8       	st.w	--sp,r8
80008e22:	08 9c       	mov	r12,r4
80008e24:	fa c8 f9 40 	sub	r8,sp,-1728
80008e28:	fa c9 ff b4 	sub	r9,sp,-76
80008e2c:	fe b0 f6 f6 	rcall	80007c18 <get_arg>
80008e30:	2f dd       	sub	sp,-12
80008e32:	78 0b       	ld.w	r11,r12[0x0]
80008e34:	c2 48       	rjmp	80008e7c <_vfprintf_r+0xf34>
80008e36:	ee ca ff ff 	sub	r10,r7,-1
80008e3a:	10 37       	cp.w	r7,r8
80008e3c:	c0 94       	brge	80008e4e <_vfprintf_r+0xf06>
80008e3e:	fa c9 f9 44 	sub	r9,sp,-1724
80008e42:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008e46:	14 97       	mov	r7,r10
80008e48:	ec fb fd 88 	ld.w	r11,r6[-632]
80008e4c:	c1 88       	rjmp	80008e7c <_vfprintf_r+0xf34>
80008e4e:	41 09       	lddsp	r9,sp[0x40]
80008e50:	59 f8       	cp.w	r8,31
80008e52:	e0 89 00 11 	brgt	80008e74 <_vfprintf_r+0xf2c>
80008e56:	f2 cb ff fc 	sub	r11,r9,-4
80008e5a:	51 0b       	stdsp	sp[0x40],r11
80008e5c:	fa c6 f9 44 	sub	r6,sp,-1724
80008e60:	72 0b       	ld.w	r11,r9[0x0]
80008e62:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008e66:	f3 4b fd 88 	st.w	r9[-632],r11
80008e6a:	2f f8       	sub	r8,-1
80008e6c:	14 97       	mov	r7,r10
80008e6e:	fb 48 06 b4 	st.w	sp[1716],r8
80008e72:	c0 58       	rjmp	80008e7c <_vfprintf_r+0xf34>
80008e74:	72 0b       	ld.w	r11,r9[0x0]
80008e76:	14 97       	mov	r7,r10
80008e78:	2f c9       	sub	r9,-4
80008e7a:	51 09       	stdsp	sp[0x40],r9
80008e7c:	50 1b       	stdsp	sp[0x4],r11
80008e7e:	30 0e       	mov	lr,0
80008e80:	50 0e       	stdsp	sp[0x0],lr
80008e82:	1c 98       	mov	r8,lr
80008e84:	e0 8f 02 fe 	bral	80009480 <_vfprintf_r+0x1538>
80008e88:	50 a7       	stdsp	sp[0x28],r7
80008e8a:	50 80       	stdsp	sp[0x20],r0
80008e8c:	0c 97       	mov	r7,r6
80008e8e:	04 94       	mov	r4,r2
80008e90:	06 96       	mov	r6,r3
80008e92:	02 92       	mov	r2,r1
80008e94:	40 93       	lddsp	r3,sp[0x24]
80008e96:	40 41       	lddsp	r1,sp[0x10]
80008e98:	0e 99       	mov	r9,r7
80008e9a:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008e9e:	40 3c       	lddsp	r12,sp[0xc]
80008ea0:	58 0c       	cp.w	r12,0
80008ea2:	c1 d0       	breq	80008edc <_vfprintf_r+0xf94>
80008ea4:	10 36       	cp.w	r6,r8
80008ea6:	c0 64       	brge	80008eb2 <_vfprintf_r+0xf6a>
80008ea8:	fa cb f9 44 	sub	r11,sp,-1724
80008eac:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008eb0:	c1 d8       	rjmp	80008eea <_vfprintf_r+0xfa2>
80008eb2:	fa c8 f9 50 	sub	r8,sp,-1712
80008eb6:	1a d8       	st.w	--sp,r8
80008eb8:	fa c8 fa b8 	sub	r8,sp,-1352
80008ebc:	1a d8       	st.w	--sp,r8
80008ebe:	fa c8 fb b4 	sub	r8,sp,-1100
80008ec2:	1a d8       	st.w	--sp,r8
80008ec4:	fa c9 ff b4 	sub	r9,sp,-76
80008ec8:	fa c8 f9 40 	sub	r8,sp,-1728
80008ecc:	04 9a       	mov	r10,r2
80008ece:	0c 9b       	mov	r11,r6
80008ed0:	08 9c       	mov	r12,r4
80008ed2:	fe b0 f6 a3 	rcall	80007c18 <get_arg>
80008ed6:	2f dd       	sub	sp,-12
80008ed8:	78 09       	ld.w	r9,r12[0x0]
80008eda:	c2 18       	rjmp	80008f1c <_vfprintf_r+0xfd4>
80008edc:	2f f7       	sub	r7,-1
80008ede:	10 39       	cp.w	r9,r8
80008ee0:	c0 84       	brge	80008ef0 <_vfprintf_r+0xfa8>
80008ee2:	fa ca f9 44 	sub	r10,sp,-1724
80008ee6:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008eea:	ec f9 fd 88 	ld.w	r9,r6[-632]
80008eee:	c1 78       	rjmp	80008f1c <_vfprintf_r+0xfd4>
80008ef0:	41 09       	lddsp	r9,sp[0x40]
80008ef2:	59 f8       	cp.w	r8,31
80008ef4:	e0 89 00 10 	brgt	80008f14 <_vfprintf_r+0xfcc>
80008ef8:	f2 ca ff fc 	sub	r10,r9,-4
80008efc:	51 0a       	stdsp	sp[0x40],r10
80008efe:	fa c6 f9 44 	sub	r6,sp,-1724
80008f02:	72 09       	ld.w	r9,r9[0x0]
80008f04:	ec 08 00 3a 	add	r10,r6,r8<<0x3
80008f08:	f5 49 fd 88 	st.w	r10[-632],r9
80008f0c:	2f f8       	sub	r8,-1
80008f0e:	fb 48 06 b4 	st.w	sp[1716],r8
80008f12:	c0 58       	rjmp	80008f1c <_vfprintf_r+0xfd4>
80008f14:	f2 c8 ff fc 	sub	r8,r9,-4
80008f18:	51 08       	stdsp	sp[0x40],r8
80008f1a:	72 09       	ld.w	r9,r9[0x0]
80008f1c:	33 08       	mov	r8,48
80008f1e:	fb 68 06 b8 	st.b	sp[1720],r8
80008f22:	37 88       	mov	r8,120
80008f24:	30 0e       	mov	lr,0
80008f26:	fb 68 06 b9 	st.b	sp[1721],r8
80008f2a:	fe cc b2 9e 	sub	r12,pc,-19810
80008f2e:	50 19       	stdsp	sp[0x4],r9
80008f30:	a1 b5       	sbr	r5,0x1
80008f32:	50 0e       	stdsp	sp[0x0],lr
80008f34:	50 dc       	stdsp	sp[0x34],r12
80008f36:	30 28       	mov	r8,2
80008f38:	37 80       	mov	r0,120
80008f3a:	e0 8f 02 a3 	bral	80009480 <_vfprintf_r+0x1538>
80008f3e:	50 a7       	stdsp	sp[0x28],r7
80008f40:	50 80       	stdsp	sp[0x20],r0
80008f42:	10 90       	mov	r0,r8
80008f44:	30 08       	mov	r8,0
80008f46:	fb 68 06 bb 	st.b	sp[1723],r8
80008f4a:	0c 97       	mov	r7,r6
80008f4c:	04 94       	mov	r4,r2
80008f4e:	06 96       	mov	r6,r3
80008f50:	02 92       	mov	r2,r1
80008f52:	40 93       	lddsp	r3,sp[0x24]
80008f54:	40 41       	lddsp	r1,sp[0x10]
80008f56:	0e 99       	mov	r9,r7
80008f58:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008f5c:	40 3b       	lddsp	r11,sp[0xc]
80008f5e:	58 0b       	cp.w	r11,0
80008f60:	c1 d0       	breq	80008f9a <_vfprintf_r+0x1052>
80008f62:	10 36       	cp.w	r6,r8
80008f64:	c0 64       	brge	80008f70 <_vfprintf_r+0x1028>
80008f66:	fa ca f9 44 	sub	r10,sp,-1724
80008f6a:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008f6e:	c1 d8       	rjmp	80008fa8 <_vfprintf_r+0x1060>
80008f70:	fa c8 f9 50 	sub	r8,sp,-1712
80008f74:	1a d8       	st.w	--sp,r8
80008f76:	fa c8 fa b8 	sub	r8,sp,-1352
80008f7a:	1a d8       	st.w	--sp,r8
80008f7c:	fa c8 fb b4 	sub	r8,sp,-1100
80008f80:	0c 9b       	mov	r11,r6
80008f82:	1a d8       	st.w	--sp,r8
80008f84:	04 9a       	mov	r10,r2
80008f86:	fa c8 f9 40 	sub	r8,sp,-1728
80008f8a:	fa c9 ff b4 	sub	r9,sp,-76
80008f8e:	08 9c       	mov	r12,r4
80008f90:	fe b0 f6 44 	rcall	80007c18 <get_arg>
80008f94:	2f dd       	sub	sp,-12
80008f96:	78 06       	ld.w	r6,r12[0x0]
80008f98:	c2 08       	rjmp	80008fd8 <_vfprintf_r+0x1090>
80008f9a:	2f f7       	sub	r7,-1
80008f9c:	10 39       	cp.w	r9,r8
80008f9e:	c0 84       	brge	80008fae <_vfprintf_r+0x1066>
80008fa0:	fa c9 f9 44 	sub	r9,sp,-1724
80008fa4:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008fa8:	ec f6 fd 88 	ld.w	r6,r6[-632]
80008fac:	c1 68       	rjmp	80008fd8 <_vfprintf_r+0x1090>
80008fae:	41 09       	lddsp	r9,sp[0x40]
80008fb0:	59 f8       	cp.w	r8,31
80008fb2:	e0 89 00 10 	brgt	80008fd2 <_vfprintf_r+0x108a>
80008fb6:	f2 ca ff fc 	sub	r10,r9,-4
80008fba:	51 0a       	stdsp	sp[0x40],r10
80008fbc:	72 06       	ld.w	r6,r9[0x0]
80008fbe:	fa ce f9 44 	sub	lr,sp,-1724
80008fc2:	fc 08 00 39 	add	r9,lr,r8<<0x3
80008fc6:	f3 46 fd 88 	st.w	r9[-632],r6
80008fca:	2f f8       	sub	r8,-1
80008fcc:	fb 48 06 b4 	st.w	sp[1716],r8
80008fd0:	c0 48       	rjmp	80008fd8 <_vfprintf_r+0x1090>
80008fd2:	72 06       	ld.w	r6,r9[0x0]
80008fd4:	2f c9       	sub	r9,-4
80008fd6:	51 09       	stdsp	sp[0x40],r9
80008fd8:	40 2c       	lddsp	r12,sp[0x8]
80008fda:	58 0c       	cp.w	r12,0
80008fdc:	c1 05       	brlt	80008ffc <_vfprintf_r+0x10b4>
80008fde:	18 9a       	mov	r10,r12
80008fe0:	30 0b       	mov	r11,0
80008fe2:	0c 9c       	mov	r12,r6
80008fe4:	e0 a0 12 38 	rcall	8000b454 <memchr>
80008fe8:	e0 80 02 df 	breq	800095a6 <_vfprintf_r+0x165e>
80008fec:	f8 06 01 02 	sub	r2,r12,r6
80008ff0:	40 2b       	lddsp	r11,sp[0x8]
80008ff2:	16 32       	cp.w	r2,r11
80008ff4:	e0 89 02 d9 	brgt	800095a6 <_vfprintf_r+0x165e>
80008ff8:	e0 8f 02 d4 	bral	800095a0 <_vfprintf_r+0x1658>
80008ffc:	30 0a       	mov	r10,0
80008ffe:	0c 9c       	mov	r12,r6
80009000:	50 2a       	stdsp	sp[0x8],r10
80009002:	e0 a0 15 99 	rcall	8000bb34 <strlen>
80009006:	18 92       	mov	r2,r12
80009008:	e0 8f 02 d2 	bral	800095ac <_vfprintf_r+0x1664>
8000900c:	50 a7       	stdsp	sp[0x28],r7
8000900e:	50 80       	stdsp	sp[0x20],r0
80009010:	0c 97       	mov	r7,r6
80009012:	04 94       	mov	r4,r2
80009014:	06 96       	mov	r6,r3
80009016:	02 92       	mov	r2,r1
80009018:	40 93       	lddsp	r3,sp[0x24]
8000901a:	10 90       	mov	r0,r8
8000901c:	40 41       	lddsp	r1,sp[0x10]
8000901e:	a5 a5       	sbr	r5,0x4
80009020:	c0 a8       	rjmp	80009034 <_vfprintf_r+0x10ec>
80009022:	50 a7       	stdsp	sp[0x28],r7
80009024:	50 80       	stdsp	sp[0x20],r0
80009026:	0c 97       	mov	r7,r6
80009028:	04 94       	mov	r4,r2
8000902a:	06 96       	mov	r6,r3
8000902c:	02 92       	mov	r2,r1
8000902e:	40 93       	lddsp	r3,sp[0x24]
80009030:	10 90       	mov	r0,r8
80009032:	40 41       	lddsp	r1,sp[0x10]
80009034:	ed b5 00 05 	bld	r5,0x5
80009038:	c5 61       	brne	800090e4 <_vfprintf_r+0x119c>
8000903a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000903e:	40 39       	lddsp	r9,sp[0xc]
80009040:	58 09       	cp.w	r9,0
80009042:	c2 10       	breq	80009084 <_vfprintf_r+0x113c>
80009044:	10 36       	cp.w	r6,r8
80009046:	c0 74       	brge	80009054 <_vfprintf_r+0x110c>
80009048:	fa c8 f9 44 	sub	r8,sp,-1724
8000904c:	f0 06 00 36 	add	r6,r8,r6<<0x3
80009050:	c2 38       	rjmp	80009096 <_vfprintf_r+0x114e>
80009052:	d7 03       	nop
80009054:	fa c8 f9 50 	sub	r8,sp,-1712
80009058:	1a d8       	st.w	--sp,r8
8000905a:	fa c8 fa b8 	sub	r8,sp,-1352
8000905e:	1a d8       	st.w	--sp,r8
80009060:	fa c8 fb b4 	sub	r8,sp,-1100
80009064:	1a d8       	st.w	--sp,r8
80009066:	fa c8 f9 40 	sub	r8,sp,-1728
8000906a:	fa c9 ff b4 	sub	r9,sp,-76
8000906e:	04 9a       	mov	r10,r2
80009070:	0c 9b       	mov	r11,r6
80009072:	08 9c       	mov	r12,r4
80009074:	fe b0 f5 d2 	rcall	80007c18 <get_arg>
80009078:	2f dd       	sub	sp,-12
8000907a:	f8 e8 00 00 	ld.d	r8,r12[0]
8000907e:	fa e9 00 00 	st.d	sp[0],r8
80009082:	c2 e8       	rjmp	800090de <_vfprintf_r+0x1196>
80009084:	ee ca ff ff 	sub	r10,r7,-1
80009088:	10 37       	cp.w	r7,r8
8000908a:	c0 b4       	brge	800090a0 <_vfprintf_r+0x1158>
8000908c:	fa c8 f9 44 	sub	r8,sp,-1724
80009090:	14 97       	mov	r7,r10
80009092:	f0 06 00 36 	add	r6,r8,r6<<0x3
80009096:	ec ea fd 88 	ld.d	r10,r6[-632]
8000909a:	fa eb 00 00 	st.d	sp[0],r10
8000909e:	c2 08       	rjmp	800090de <_vfprintf_r+0x1196>
800090a0:	41 09       	lddsp	r9,sp[0x40]
800090a2:	59 f8       	cp.w	r8,31
800090a4:	e0 89 00 16 	brgt	800090d0 <_vfprintf_r+0x1188>
800090a8:	f2 e6 00 00 	ld.d	r6,r9[0]
800090ac:	f2 cb ff f8 	sub	r11,r9,-8
800090b0:	fa e7 00 00 	st.d	sp[0],r6
800090b4:	51 0b       	stdsp	sp[0x40],r11
800090b6:	fa c6 f9 44 	sub	r6,sp,-1724
800090ba:	ec 08 00 39 	add	r9,r6,r8<<0x3
800090be:	fa e6 00 00 	ld.d	r6,sp[0]
800090c2:	f2 e7 fd 88 	st.d	r9[-632],r6
800090c6:	2f f8       	sub	r8,-1
800090c8:	14 97       	mov	r7,r10
800090ca:	fb 48 06 b4 	st.w	sp[1716],r8
800090ce:	c0 88       	rjmp	800090de <_vfprintf_r+0x1196>
800090d0:	f2 e6 00 00 	ld.d	r6,r9[0]
800090d4:	2f 89       	sub	r9,-8
800090d6:	fa e7 00 00 	st.d	sp[0],r6
800090da:	51 09       	stdsp	sp[0x40],r9
800090dc:	14 97       	mov	r7,r10
800090de:	30 18       	mov	r8,1
800090e0:	e0 8f 01 d0 	bral	80009480 <_vfprintf_r+0x1538>
800090e4:	ed b5 00 04 	bld	r5,0x4
800090e8:	c1 61       	brne	80009114 <_vfprintf_r+0x11cc>
800090ea:	fa f8 06 b4 	ld.w	r8,sp[1716]
800090ee:	40 3e       	lddsp	lr,sp[0xc]
800090f0:	58 0e       	cp.w	lr,0
800090f2:	c0 80       	breq	80009102 <_vfprintf_r+0x11ba>
800090f4:	10 36       	cp.w	r6,r8
800090f6:	c6 74       	brge	800091c4 <_vfprintf_r+0x127c>
800090f8:	fa cc f9 44 	sub	r12,sp,-1724
800090fc:	f8 06 00 36 	add	r6,r12,r6<<0x3
80009100:	c8 08       	rjmp	80009200 <_vfprintf_r+0x12b8>
80009102:	ee ca ff ff 	sub	r10,r7,-1
80009106:	10 37       	cp.w	r7,r8
80009108:	c7 f4       	brge	80009206 <_vfprintf_r+0x12be>
8000910a:	fa cb f9 44 	sub	r11,sp,-1724
8000910e:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009112:	c7 68       	rjmp	800091fe <_vfprintf_r+0x12b6>
80009114:	ed b5 00 06 	bld	r5,0x6
80009118:	c4 a1       	brne	800091ac <_vfprintf_r+0x1264>
8000911a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000911e:	40 3c       	lddsp	r12,sp[0xc]
80009120:	58 0c       	cp.w	r12,0
80009122:	c1 d0       	breq	8000915c <_vfprintf_r+0x1214>
80009124:	10 36       	cp.w	r6,r8
80009126:	c0 64       	brge	80009132 <_vfprintf_r+0x11ea>
80009128:	fa cb f9 44 	sub	r11,sp,-1724
8000912c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009130:	c1 f8       	rjmp	8000916e <_vfprintf_r+0x1226>
80009132:	fa c8 f9 50 	sub	r8,sp,-1712
80009136:	1a d8       	st.w	--sp,r8
80009138:	fa c8 fa b8 	sub	r8,sp,-1352
8000913c:	1a d8       	st.w	--sp,r8
8000913e:	fa c8 fb b4 	sub	r8,sp,-1100
80009142:	1a d8       	st.w	--sp,r8
80009144:	fa c8 f9 40 	sub	r8,sp,-1728
80009148:	fa c9 ff b4 	sub	r9,sp,-76
8000914c:	04 9a       	mov	r10,r2
8000914e:	0c 9b       	mov	r11,r6
80009150:	08 9c       	mov	r12,r4
80009152:	fe b0 f5 63 	rcall	80007c18 <get_arg>
80009156:	2f dd       	sub	sp,-12
80009158:	98 18       	ld.sh	r8,r12[0x2]
8000915a:	c2 68       	rjmp	800091a6 <_vfprintf_r+0x125e>
8000915c:	ee ca ff ff 	sub	r10,r7,-1
80009160:	10 37       	cp.w	r7,r8
80009162:	c0 94       	brge	80009174 <_vfprintf_r+0x122c>
80009164:	fa c9 f9 44 	sub	r9,sp,-1724
80009168:	14 97       	mov	r7,r10
8000916a:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000916e:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80009172:	c1 a8       	rjmp	800091a6 <_vfprintf_r+0x125e>
80009174:	41 09       	lddsp	r9,sp[0x40]
80009176:	59 f8       	cp.w	r8,31
80009178:	e0 89 00 13 	brgt	8000919e <_vfprintf_r+0x1256>
8000917c:	f2 cb ff fc 	sub	r11,r9,-4
80009180:	51 0b       	stdsp	sp[0x40],r11
80009182:	72 09       	ld.w	r9,r9[0x0]
80009184:	fa c6 f9 44 	sub	r6,sp,-1724
80009188:	ec 08 00 3b 	add	r11,r6,r8<<0x3
8000918c:	2f f8       	sub	r8,-1
8000918e:	f7 49 fd 88 	st.w	r11[-632],r9
80009192:	fb 48 06 b4 	st.w	sp[1716],r8
80009196:	14 97       	mov	r7,r10
80009198:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
8000919c:	c0 58       	rjmp	800091a6 <_vfprintf_r+0x125e>
8000919e:	92 18       	ld.sh	r8,r9[0x2]
800091a0:	14 97       	mov	r7,r10
800091a2:	2f c9       	sub	r9,-4
800091a4:	51 09       	stdsp	sp[0x40],r9
800091a6:	5c 78       	castu.h	r8
800091a8:	50 18       	stdsp	sp[0x4],r8
800091aa:	c4 68       	rjmp	80009236 <_vfprintf_r+0x12ee>
800091ac:	fa f8 06 b4 	ld.w	r8,sp[1716]
800091b0:	40 3c       	lddsp	r12,sp[0xc]
800091b2:	58 0c       	cp.w	r12,0
800091b4:	c1 d0       	breq	800091ee <_vfprintf_r+0x12a6>
800091b6:	10 36       	cp.w	r6,r8
800091b8:	c0 64       	brge	800091c4 <_vfprintf_r+0x127c>
800091ba:	fa cb f9 44 	sub	r11,sp,-1724
800091be:	f6 06 00 36 	add	r6,r11,r6<<0x3
800091c2:	c1 f8       	rjmp	80009200 <_vfprintf_r+0x12b8>
800091c4:	fa c8 f9 50 	sub	r8,sp,-1712
800091c8:	1a d8       	st.w	--sp,r8
800091ca:	fa c8 fa b8 	sub	r8,sp,-1352
800091ce:	0c 9b       	mov	r11,r6
800091d0:	1a d8       	st.w	--sp,r8
800091d2:	fa c8 fb b4 	sub	r8,sp,-1100
800091d6:	04 9a       	mov	r10,r2
800091d8:	1a d8       	st.w	--sp,r8
800091da:	08 9c       	mov	r12,r4
800091dc:	fa c8 f9 40 	sub	r8,sp,-1728
800091e0:	fa c9 ff b4 	sub	r9,sp,-76
800091e4:	fe b0 f5 1a 	rcall	80007c18 <get_arg>
800091e8:	2f dd       	sub	sp,-12
800091ea:	78 0b       	ld.w	r11,r12[0x0]
800091ec:	c2 48       	rjmp	80009234 <_vfprintf_r+0x12ec>
800091ee:	ee ca ff ff 	sub	r10,r7,-1
800091f2:	10 37       	cp.w	r7,r8
800091f4:	c0 94       	brge	80009206 <_vfprintf_r+0x12be>
800091f6:	fa c9 f9 44 	sub	r9,sp,-1724
800091fa:	f2 06 00 36 	add	r6,r9,r6<<0x3
800091fe:	14 97       	mov	r7,r10
80009200:	ec fb fd 88 	ld.w	r11,r6[-632]
80009204:	c1 88       	rjmp	80009234 <_vfprintf_r+0x12ec>
80009206:	41 09       	lddsp	r9,sp[0x40]
80009208:	59 f8       	cp.w	r8,31
8000920a:	e0 89 00 11 	brgt	8000922c <_vfprintf_r+0x12e4>
8000920e:	f2 cb ff fc 	sub	r11,r9,-4
80009212:	51 0b       	stdsp	sp[0x40],r11
80009214:	fa c6 f9 44 	sub	r6,sp,-1724
80009218:	72 0b       	ld.w	r11,r9[0x0]
8000921a:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000921e:	f3 4b fd 88 	st.w	r9[-632],r11
80009222:	2f f8       	sub	r8,-1
80009224:	14 97       	mov	r7,r10
80009226:	fb 48 06 b4 	st.w	sp[1716],r8
8000922a:	c0 58       	rjmp	80009234 <_vfprintf_r+0x12ec>
8000922c:	72 0b       	ld.w	r11,r9[0x0]
8000922e:	14 97       	mov	r7,r10
80009230:	2f c9       	sub	r9,-4
80009232:	51 09       	stdsp	sp[0x40],r9
80009234:	50 1b       	stdsp	sp[0x4],r11
80009236:	30 0e       	mov	lr,0
80009238:	30 18       	mov	r8,1
8000923a:	50 0e       	stdsp	sp[0x0],lr
8000923c:	c2 29       	rjmp	80009480 <_vfprintf_r+0x1538>
8000923e:	50 a7       	stdsp	sp[0x28],r7
80009240:	50 80       	stdsp	sp[0x20],r0
80009242:	0c 97       	mov	r7,r6
80009244:	04 94       	mov	r4,r2
80009246:	06 96       	mov	r6,r3
80009248:	02 92       	mov	r2,r1
8000924a:	fe cc b5 be 	sub	r12,pc,-19010
8000924e:	40 93       	lddsp	r3,sp[0x24]
80009250:	10 90       	mov	r0,r8
80009252:	40 41       	lddsp	r1,sp[0x10]
80009254:	50 dc       	stdsp	sp[0x34],r12
80009256:	ed b5 00 05 	bld	r5,0x5
8000925a:	c5 51       	brne	80009304 <_vfprintf_r+0x13bc>
8000925c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009260:	40 3b       	lddsp	r11,sp[0xc]
80009262:	58 0b       	cp.w	r11,0
80009264:	c2 20       	breq	800092a8 <_vfprintf_r+0x1360>
80009266:	10 36       	cp.w	r6,r8
80009268:	c0 a4       	brge	8000927c <_vfprintf_r+0x1334>
8000926a:	fa ca f9 44 	sub	r10,sp,-1724
8000926e:	f4 06 00 36 	add	r6,r10,r6<<0x3
80009272:	ec e8 fd 88 	ld.d	r8,r6[-632]
80009276:	fa e9 00 00 	st.d	sp[0],r8
8000927a:	cf 28       	rjmp	8000945e <_vfprintf_r+0x1516>
8000927c:	fa c8 f9 50 	sub	r8,sp,-1712
80009280:	1a d8       	st.w	--sp,r8
80009282:	fa c8 fa b8 	sub	r8,sp,-1352
80009286:	04 9a       	mov	r10,r2
80009288:	1a d8       	st.w	--sp,r8
8000928a:	0c 9b       	mov	r11,r6
8000928c:	fa c8 fb b4 	sub	r8,sp,-1100
80009290:	08 9c       	mov	r12,r4
80009292:	1a d8       	st.w	--sp,r8
80009294:	fa c8 f9 40 	sub	r8,sp,-1728
80009298:	fa c9 ff b4 	sub	r9,sp,-76
8000929c:	fe b0 f4 be 	rcall	80007c18 <get_arg>
800092a0:	2f dd       	sub	sp,-12
800092a2:	f8 ea 00 00 	ld.d	r10,r12[0]
800092a6:	c0 c8       	rjmp	800092be <_vfprintf_r+0x1376>
800092a8:	ee ca ff ff 	sub	r10,r7,-1
800092ac:	10 37       	cp.w	r7,r8
800092ae:	c0 b4       	brge	800092c4 <_vfprintf_r+0x137c>
800092b0:	fa c9 f9 44 	sub	r9,sp,-1724
800092b4:	14 97       	mov	r7,r10
800092b6:	f2 06 00 36 	add	r6,r9,r6<<0x3
800092ba:	ec ea fd 88 	ld.d	r10,r6[-632]
800092be:	fa eb 00 00 	st.d	sp[0],r10
800092c2:	cc e8       	rjmp	8000945e <_vfprintf_r+0x1516>
800092c4:	41 09       	lddsp	r9,sp[0x40]
800092c6:	59 f8       	cp.w	r8,31
800092c8:	e0 89 00 16 	brgt	800092f4 <_vfprintf_r+0x13ac>
800092cc:	f2 e6 00 00 	ld.d	r6,r9[0]
800092d0:	f2 cb ff f8 	sub	r11,r9,-8
800092d4:	fa e7 00 00 	st.d	sp[0],r6
800092d8:	51 0b       	stdsp	sp[0x40],r11
800092da:	fa c6 f9 44 	sub	r6,sp,-1724
800092de:	ec 08 00 39 	add	r9,r6,r8<<0x3
800092e2:	fa e6 00 00 	ld.d	r6,sp[0]
800092e6:	f2 e7 fd 88 	st.d	r9[-632],r6
800092ea:	2f f8       	sub	r8,-1
800092ec:	14 97       	mov	r7,r10
800092ee:	fb 48 06 b4 	st.w	sp[1716],r8
800092f2:	cb 68       	rjmp	8000945e <_vfprintf_r+0x1516>
800092f4:	f2 e6 00 00 	ld.d	r6,r9[0]
800092f8:	2f 89       	sub	r9,-8
800092fa:	fa e7 00 00 	st.d	sp[0],r6
800092fe:	51 09       	stdsp	sp[0x40],r9
80009300:	14 97       	mov	r7,r10
80009302:	ca e8       	rjmp	8000945e <_vfprintf_r+0x1516>
80009304:	ed b5 00 04 	bld	r5,0x4
80009308:	c1 71       	brne	80009336 <_vfprintf_r+0x13ee>
8000930a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000930e:	40 3e       	lddsp	lr,sp[0xc]
80009310:	58 0e       	cp.w	lr,0
80009312:	c0 80       	breq	80009322 <_vfprintf_r+0x13da>
80009314:	10 36       	cp.w	r6,r8
80009316:	c6 94       	brge	800093e8 <_vfprintf_r+0x14a0>
80009318:	fa cc f9 44 	sub	r12,sp,-1724
8000931c:	f8 06 00 36 	add	r6,r12,r6<<0x3
80009320:	c8 28       	rjmp	80009424 <_vfprintf_r+0x14dc>
80009322:	ee ca ff ff 	sub	r10,r7,-1
80009326:	10 37       	cp.w	r7,r8
80009328:	e0 84 00 81 	brge	8000942a <_vfprintf_r+0x14e2>
8000932c:	fa cb f9 44 	sub	r11,sp,-1724
80009330:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009334:	c7 78       	rjmp	80009422 <_vfprintf_r+0x14da>
80009336:	ed b5 00 06 	bld	r5,0x6
8000933a:	c4 b1       	brne	800093d0 <_vfprintf_r+0x1488>
8000933c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009340:	40 3c       	lddsp	r12,sp[0xc]
80009342:	58 0c       	cp.w	r12,0
80009344:	c1 d0       	breq	8000937e <_vfprintf_r+0x1436>
80009346:	10 36       	cp.w	r6,r8
80009348:	c0 64       	brge	80009354 <_vfprintf_r+0x140c>
8000934a:	fa cb f9 44 	sub	r11,sp,-1724
8000934e:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009352:	c1 f8       	rjmp	80009390 <_vfprintf_r+0x1448>
80009354:	fa c8 f9 50 	sub	r8,sp,-1712
80009358:	1a d8       	st.w	--sp,r8
8000935a:	fa c8 fa b8 	sub	r8,sp,-1352
8000935e:	1a d8       	st.w	--sp,r8
80009360:	fa c8 fb b4 	sub	r8,sp,-1100
80009364:	1a d8       	st.w	--sp,r8
80009366:	fa c8 f9 40 	sub	r8,sp,-1728
8000936a:	fa c9 ff b4 	sub	r9,sp,-76
8000936e:	04 9a       	mov	r10,r2
80009370:	0c 9b       	mov	r11,r6
80009372:	08 9c       	mov	r12,r4
80009374:	fe b0 f4 52 	rcall	80007c18 <get_arg>
80009378:	2f dd       	sub	sp,-12
8000937a:	98 18       	ld.sh	r8,r12[0x2]
8000937c:	c2 78       	rjmp	800093ca <_vfprintf_r+0x1482>
8000937e:	ee ca ff ff 	sub	r10,r7,-1
80009382:	10 37       	cp.w	r7,r8
80009384:	c0 a4       	brge	80009398 <_vfprintf_r+0x1450>
80009386:	fa c9 f9 44 	sub	r9,sp,-1724
8000938a:	14 97       	mov	r7,r10
8000938c:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009390:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80009394:	c1 b8       	rjmp	800093ca <_vfprintf_r+0x1482>
80009396:	d7 03       	nop
80009398:	41 09       	lddsp	r9,sp[0x40]
8000939a:	59 f8       	cp.w	r8,31
8000939c:	e0 89 00 13 	brgt	800093c2 <_vfprintf_r+0x147a>
800093a0:	f2 cb ff fc 	sub	r11,r9,-4
800093a4:	51 0b       	stdsp	sp[0x40],r11
800093a6:	72 09       	ld.w	r9,r9[0x0]
800093a8:	fa c6 f9 44 	sub	r6,sp,-1724
800093ac:	ec 08 00 3b 	add	r11,r6,r8<<0x3
800093b0:	2f f8       	sub	r8,-1
800093b2:	f7 49 fd 88 	st.w	r11[-632],r9
800093b6:	fb 48 06 b4 	st.w	sp[1716],r8
800093ba:	14 97       	mov	r7,r10
800093bc:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
800093c0:	c0 58       	rjmp	800093ca <_vfprintf_r+0x1482>
800093c2:	92 18       	ld.sh	r8,r9[0x2]
800093c4:	14 97       	mov	r7,r10
800093c6:	2f c9       	sub	r9,-4
800093c8:	51 09       	stdsp	sp[0x40],r9
800093ca:	5c 78       	castu.h	r8
800093cc:	50 18       	stdsp	sp[0x4],r8
800093ce:	c4 68       	rjmp	8000945a <_vfprintf_r+0x1512>
800093d0:	fa f8 06 b4 	ld.w	r8,sp[1716]
800093d4:	40 3c       	lddsp	r12,sp[0xc]
800093d6:	58 0c       	cp.w	r12,0
800093d8:	c1 d0       	breq	80009412 <_vfprintf_r+0x14ca>
800093da:	10 36       	cp.w	r6,r8
800093dc:	c0 64       	brge	800093e8 <_vfprintf_r+0x14a0>
800093de:	fa cb f9 44 	sub	r11,sp,-1724
800093e2:	f6 06 00 36 	add	r6,r11,r6<<0x3
800093e6:	c1 f8       	rjmp	80009424 <_vfprintf_r+0x14dc>
800093e8:	fa c8 f9 50 	sub	r8,sp,-1712
800093ec:	1a d8       	st.w	--sp,r8
800093ee:	fa c8 fa b8 	sub	r8,sp,-1352
800093f2:	0c 9b       	mov	r11,r6
800093f4:	1a d8       	st.w	--sp,r8
800093f6:	fa c8 fb b4 	sub	r8,sp,-1100
800093fa:	04 9a       	mov	r10,r2
800093fc:	1a d8       	st.w	--sp,r8
800093fe:	08 9c       	mov	r12,r4
80009400:	fa c8 f9 40 	sub	r8,sp,-1728
80009404:	fa c9 ff b4 	sub	r9,sp,-76
80009408:	fe b0 f4 08 	rcall	80007c18 <get_arg>
8000940c:	2f dd       	sub	sp,-12
8000940e:	78 0b       	ld.w	r11,r12[0x0]
80009410:	c2 48       	rjmp	80009458 <_vfprintf_r+0x1510>
80009412:	ee ca ff ff 	sub	r10,r7,-1
80009416:	10 37       	cp.w	r7,r8
80009418:	c0 94       	brge	8000942a <_vfprintf_r+0x14e2>
8000941a:	fa c9 f9 44 	sub	r9,sp,-1724
8000941e:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009422:	14 97       	mov	r7,r10
80009424:	ec fb fd 88 	ld.w	r11,r6[-632]
80009428:	c1 88       	rjmp	80009458 <_vfprintf_r+0x1510>
8000942a:	41 09       	lddsp	r9,sp[0x40]
8000942c:	59 f8       	cp.w	r8,31
8000942e:	e0 89 00 11 	brgt	80009450 <_vfprintf_r+0x1508>
80009432:	f2 cb ff fc 	sub	r11,r9,-4
80009436:	51 0b       	stdsp	sp[0x40],r11
80009438:	fa c6 f9 44 	sub	r6,sp,-1724
8000943c:	72 0b       	ld.w	r11,r9[0x0]
8000943e:	ec 08 00 39 	add	r9,r6,r8<<0x3
80009442:	f3 4b fd 88 	st.w	r9[-632],r11
80009446:	2f f8       	sub	r8,-1
80009448:	14 97       	mov	r7,r10
8000944a:	fb 48 06 b4 	st.w	sp[1716],r8
8000944e:	c0 58       	rjmp	80009458 <_vfprintf_r+0x1510>
80009450:	72 0b       	ld.w	r11,r9[0x0]
80009452:	14 97       	mov	r7,r10
80009454:	2f c9       	sub	r9,-4
80009456:	51 09       	stdsp	sp[0x40],r9
80009458:	50 1b       	stdsp	sp[0x4],r11
8000945a:	30 0e       	mov	lr,0
8000945c:	50 0e       	stdsp	sp[0x0],lr
8000945e:	40 08       	lddsp	r8,sp[0x0]
80009460:	40 1c       	lddsp	r12,sp[0x4]
80009462:	18 48       	or	r8,r12
80009464:	5f 19       	srne	r9
80009466:	0a 98       	mov	r8,r5
80009468:	eb e9 00 09 	and	r9,r5,r9
8000946c:	a1 b8       	sbr	r8,0x1
8000946e:	58 09       	cp.w	r9,0
80009470:	c0 70       	breq	8000947e <_vfprintf_r+0x1536>
80009472:	10 95       	mov	r5,r8
80009474:	fb 60 06 b9 	st.b	sp[1721],r0
80009478:	33 08       	mov	r8,48
8000947a:	fb 68 06 b8 	st.b	sp[1720],r8
8000947e:	30 28       	mov	r8,2
80009480:	30 09       	mov	r9,0
80009482:	fb 69 06 bb 	st.b	sp[1723],r9
80009486:	0a 99       	mov	r9,r5
80009488:	a7 d9       	cbr	r9,0x7
8000948a:	40 2b       	lddsp	r11,sp[0x8]
8000948c:	40 16       	lddsp	r6,sp[0x4]
8000948e:	58 0b       	cp.w	r11,0
80009490:	5f 1a       	srne	r10
80009492:	f2 05 17 40 	movge	r5,r9
80009496:	fa c2 f9 78 	sub	r2,sp,-1672
8000949a:	40 09       	lddsp	r9,sp[0x0]
8000949c:	0c 49       	or	r9,r6
8000949e:	5f 19       	srne	r9
800094a0:	f5 e9 10 09 	or	r9,r10,r9
800094a4:	c5 c0       	breq	8000955c <_vfprintf_r+0x1614>
800094a6:	30 19       	mov	r9,1
800094a8:	f2 08 18 00 	cp.b	r8,r9
800094ac:	c0 60       	breq	800094b8 <_vfprintf_r+0x1570>
800094ae:	30 29       	mov	r9,2
800094b0:	f2 08 18 00 	cp.b	r8,r9
800094b4:	c0 41       	brne	800094bc <_vfprintf_r+0x1574>
800094b6:	c3 c8       	rjmp	8000952e <_vfprintf_r+0x15e6>
800094b8:	04 96       	mov	r6,r2
800094ba:	c3 08       	rjmp	8000951a <_vfprintf_r+0x15d2>
800094bc:	04 96       	mov	r6,r2
800094be:	fa e8 00 00 	ld.d	r8,sp[0]
800094c2:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
800094c6:	2d 0a       	sub	r10,-48
800094c8:	0c fa       	st.b	--r6,r10
800094ca:	f0 0b 16 03 	lsr	r11,r8,0x3
800094ce:	f2 0c 16 03 	lsr	r12,r9,0x3
800094d2:	f7 e9 11 db 	or	r11,r11,r9<<0x1d
800094d6:	18 99       	mov	r9,r12
800094d8:	16 98       	mov	r8,r11
800094da:	58 08       	cp.w	r8,0
800094dc:	5c 29       	cpc	r9
800094de:	cf 21       	brne	800094c2 <_vfprintf_r+0x157a>
800094e0:	fa e9 00 00 	st.d	sp[0],r8
800094e4:	ed b5 00 00 	bld	r5,0x0
800094e8:	c4 51       	brne	80009572 <_vfprintf_r+0x162a>
800094ea:	33 09       	mov	r9,48
800094ec:	f2 0a 18 00 	cp.b	r10,r9
800094f0:	c4 10       	breq	80009572 <_vfprintf_r+0x162a>
800094f2:	0c f9       	st.b	--r6,r9
800094f4:	c3 f8       	rjmp	80009572 <_vfprintf_r+0x162a>
800094f6:	fa ea 00 00 	ld.d	r10,sp[0]
800094fa:	30 a8       	mov	r8,10
800094fc:	30 09       	mov	r9,0
800094fe:	e0 a0 1a 19 	rcall	8000c930 <__avr32_umod64>
80009502:	30 a8       	mov	r8,10
80009504:	2d 0a       	sub	r10,-48
80009506:	30 09       	mov	r9,0
80009508:	ac 8a       	st.b	r6[0x0],r10
8000950a:	fa ea 00 00 	ld.d	r10,sp[0]
8000950e:	e0 a0 18 df 	rcall	8000c6cc <__avr32_udiv64>
80009512:	16 99       	mov	r9,r11
80009514:	14 98       	mov	r8,r10
80009516:	fa e9 00 00 	st.d	sp[0],r8
8000951a:	20 16       	sub	r6,1
8000951c:	fa ea 00 00 	ld.d	r10,sp[0]
80009520:	58 9a       	cp.w	r10,9
80009522:	5c 2b       	cpc	r11
80009524:	fe 9b ff e9 	brhi	800094f6 <_vfprintf_r+0x15ae>
80009528:	1b f8       	ld.ub	r8,sp[0x7]
8000952a:	2d 08       	sub	r8,-48
8000952c:	c2 08       	rjmp	8000956c <_vfprintf_r+0x1624>
8000952e:	04 96       	mov	r6,r2
80009530:	fa e8 00 00 	ld.d	r8,sp[0]
80009534:	f5 d8 c0 04 	bfextu	r10,r8,0x0,0x4
80009538:	40 de       	lddsp	lr,sp[0x34]
8000953a:	fc 0a 07 0a 	ld.ub	r10,lr[r10]
8000953e:	0c fa       	st.b	--r6,r10
80009540:	f2 0b 16 04 	lsr	r11,r9,0x4
80009544:	f0 0a 16 04 	lsr	r10,r8,0x4
80009548:	f5 e9 11 ca 	or	r10,r10,r9<<0x1c
8000954c:	16 99       	mov	r9,r11
8000954e:	14 98       	mov	r8,r10
80009550:	58 08       	cp.w	r8,0
80009552:	5c 29       	cpc	r9
80009554:	cf 01       	brne	80009534 <_vfprintf_r+0x15ec>
80009556:	fa e9 00 00 	st.d	sp[0],r8
8000955a:	c0 c8       	rjmp	80009572 <_vfprintf_r+0x162a>
8000955c:	58 08       	cp.w	r8,0
8000955e:	c0 91       	brne	80009570 <_vfprintf_r+0x1628>
80009560:	ed b5 00 00 	bld	r5,0x0
80009564:	c0 61       	brne	80009570 <_vfprintf_r+0x1628>
80009566:	fa c6 f9 79 	sub	r6,sp,-1671
8000956a:	33 08       	mov	r8,48
8000956c:	ac 88       	st.b	r6[0x0],r8
8000956e:	c0 28       	rjmp	80009572 <_vfprintf_r+0x162a>
80009570:	04 96       	mov	r6,r2
80009572:	0c 12       	sub	r2,r6
80009574:	c1 c8       	rjmp	800095ac <_vfprintf_r+0x1664>
80009576:	50 a7       	stdsp	sp[0x28],r7
80009578:	50 80       	stdsp	sp[0x20],r0
8000957a:	40 93       	lddsp	r3,sp[0x24]
8000957c:	0c 97       	mov	r7,r6
8000957e:	10 90       	mov	r0,r8
80009580:	04 94       	mov	r4,r2
80009582:	40 41       	lddsp	r1,sp[0x10]
80009584:	58 08       	cp.w	r8,0
80009586:	e0 80 04 4f 	breq	80009e24 <_vfprintf_r+0x1edc>
8000958a:	fb 68 06 60 	st.b	sp[1632],r8
8000958e:	30 0c       	mov	r12,0
80009590:	30 08       	mov	r8,0
80009592:	30 12       	mov	r2,1
80009594:	fb 68 06 bb 	st.b	sp[1723],r8
80009598:	50 2c       	stdsp	sp[0x8],r12
8000959a:	fa c6 f9 a0 	sub	r6,sp,-1632
8000959e:	c0 78       	rjmp	800095ac <_vfprintf_r+0x1664>
800095a0:	30 0b       	mov	r11,0
800095a2:	50 2b       	stdsp	sp[0x8],r11
800095a4:	c0 48       	rjmp	800095ac <_vfprintf_r+0x1664>
800095a6:	40 22       	lddsp	r2,sp[0x8]
800095a8:	30 0a       	mov	r10,0
800095aa:	50 2a       	stdsp	sp[0x8],r10
800095ac:	40 29       	lddsp	r9,sp[0x8]
800095ae:	e4 09 0c 49 	max	r9,r2,r9
800095b2:	fb 38 06 bb 	ld.ub	r8,sp[1723]
800095b6:	50 39       	stdsp	sp[0xc],r9
800095b8:	0a 9e       	mov	lr,r5
800095ba:	30 09       	mov	r9,0
800095bc:	e2 1e 00 02 	andl	lr,0x2,COH
800095c0:	f2 08 18 00 	cp.b	r8,r9
800095c4:	fb f8 10 03 	ld.wne	r8,sp[0xc]
800095c8:	f7 b8 01 ff 	subne	r8,-1
800095cc:	fb f8 1a 03 	st.wne	sp[0xc],r8
800095d0:	0a 9b       	mov	r11,r5
800095d2:	58 0e       	cp.w	lr,0
800095d4:	fb fc 10 03 	ld.wne	r12,sp[0xc]
800095d8:	f7 bc 01 fe 	subne	r12,-2
800095dc:	fb fc 1a 03 	st.wne	sp[0xc],r12
800095e0:	e2 1b 00 84 	andl	r11,0x84,COH
800095e4:	50 fe       	stdsp	sp[0x3c],lr
800095e6:	50 9b       	stdsp	sp[0x24],r11
800095e8:	c4 71       	brne	80009676 <_vfprintf_r+0x172e>
800095ea:	40 8a       	lddsp	r10,sp[0x20]
800095ec:	40 39       	lddsp	r9,sp[0xc]
800095ee:	12 1a       	sub	r10,r9
800095f0:	50 4a       	stdsp	sp[0x10],r10
800095f2:	58 0a       	cp.w	r10,0
800095f4:	e0 89 00 20 	brgt	80009634 <_vfprintf_r+0x16ec>
800095f8:	c3 f8       	rjmp	80009676 <_vfprintf_r+0x172e>
800095fa:	2f 09       	sub	r9,-16
800095fc:	2f f8       	sub	r8,-1
800095fe:	fe ce b9 5a 	sub	lr,pc,-18086
80009602:	31 0c       	mov	r12,16
80009604:	fb 49 06 90 	st.w	sp[1680],r9
80009608:	87 0e       	st.w	r3[0x0],lr
8000960a:	87 1c       	st.w	r3[0x4],r12
8000960c:	fb 48 06 8c 	st.w	sp[1676],r8
80009610:	58 78       	cp.w	r8,7
80009612:	e0 89 00 04 	brgt	8000961a <_vfprintf_r+0x16d2>
80009616:	2f 83       	sub	r3,-8
80009618:	c0 b8       	rjmp	8000962e <_vfprintf_r+0x16e6>
8000961a:	fa ca f9 78 	sub	r10,sp,-1672
8000961e:	02 9b       	mov	r11,r1
80009620:	08 9c       	mov	r12,r4
80009622:	fe b0 f4 85 	rcall	80007f2c <__sprint_r>
80009626:	e0 81 04 10 	brne	80009e46 <_vfprintf_r+0x1efe>
8000962a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000962e:	40 4b       	lddsp	r11,sp[0x10]
80009630:	21 0b       	sub	r11,16
80009632:	50 4b       	stdsp	sp[0x10],r11
80009634:	fa f9 06 90 	ld.w	r9,sp[1680]
80009638:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000963c:	fe ca b9 98 	sub	r10,pc,-18024
80009640:	40 4e       	lddsp	lr,sp[0x10]
80009642:	59 0e       	cp.w	lr,16
80009644:	fe 99 ff db 	brgt	800095fa <_vfprintf_r+0x16b2>
80009648:	1c 09       	add	r9,lr
8000964a:	2f f8       	sub	r8,-1
8000964c:	87 0a       	st.w	r3[0x0],r10
8000964e:	fb 49 06 90 	st.w	sp[1680],r9
80009652:	87 1e       	st.w	r3[0x4],lr
80009654:	fb 48 06 8c 	st.w	sp[1676],r8
80009658:	58 78       	cp.w	r8,7
8000965a:	e0 89 00 04 	brgt	80009662 <_vfprintf_r+0x171a>
8000965e:	2f 83       	sub	r3,-8
80009660:	c0 b8       	rjmp	80009676 <_vfprintf_r+0x172e>
80009662:	fa ca f9 78 	sub	r10,sp,-1672
80009666:	02 9b       	mov	r11,r1
80009668:	08 9c       	mov	r12,r4
8000966a:	fe b0 f4 61 	rcall	80007f2c <__sprint_r>
8000966e:	e0 81 03 ec 	brne	80009e46 <_vfprintf_r+0x1efe>
80009672:	fa c3 f9 e0 	sub	r3,sp,-1568
80009676:	30 09       	mov	r9,0
80009678:	fb 38 06 bb 	ld.ub	r8,sp[1723]
8000967c:	f2 08 18 00 	cp.b	r8,r9
80009680:	c1 f0       	breq	800096be <_vfprintf_r+0x1776>
80009682:	fa f8 06 90 	ld.w	r8,sp[1680]
80009686:	fa c9 f9 45 	sub	r9,sp,-1723
8000968a:	2f f8       	sub	r8,-1
8000968c:	87 09       	st.w	r3[0x0],r9
8000968e:	fb 48 06 90 	st.w	sp[1680],r8
80009692:	30 19       	mov	r9,1
80009694:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009698:	87 19       	st.w	r3[0x4],r9
8000969a:	2f f8       	sub	r8,-1
8000969c:	fb 48 06 8c 	st.w	sp[1676],r8
800096a0:	58 78       	cp.w	r8,7
800096a2:	e0 89 00 04 	brgt	800096aa <_vfprintf_r+0x1762>
800096a6:	2f 83       	sub	r3,-8
800096a8:	c0 b8       	rjmp	800096be <_vfprintf_r+0x1776>
800096aa:	fa ca f9 78 	sub	r10,sp,-1672
800096ae:	02 9b       	mov	r11,r1
800096b0:	08 9c       	mov	r12,r4
800096b2:	fe b0 f4 3d 	rcall	80007f2c <__sprint_r>
800096b6:	e0 81 03 c8 	brne	80009e46 <_vfprintf_r+0x1efe>
800096ba:	fa c3 f9 e0 	sub	r3,sp,-1568
800096be:	40 fc       	lddsp	r12,sp[0x3c]
800096c0:	58 0c       	cp.w	r12,0
800096c2:	c1 f0       	breq	80009700 <_vfprintf_r+0x17b8>
800096c4:	fa f8 06 90 	ld.w	r8,sp[1680]
800096c8:	fa c9 f9 48 	sub	r9,sp,-1720
800096cc:	2f e8       	sub	r8,-2
800096ce:	87 09       	st.w	r3[0x0],r9
800096d0:	fb 48 06 90 	st.w	sp[1680],r8
800096d4:	30 29       	mov	r9,2
800096d6:	fa f8 06 8c 	ld.w	r8,sp[1676]
800096da:	87 19       	st.w	r3[0x4],r9
800096dc:	2f f8       	sub	r8,-1
800096de:	fb 48 06 8c 	st.w	sp[1676],r8
800096e2:	58 78       	cp.w	r8,7
800096e4:	e0 89 00 04 	brgt	800096ec <_vfprintf_r+0x17a4>
800096e8:	2f 83       	sub	r3,-8
800096ea:	c0 b8       	rjmp	80009700 <_vfprintf_r+0x17b8>
800096ec:	fa ca f9 78 	sub	r10,sp,-1672
800096f0:	02 9b       	mov	r11,r1
800096f2:	08 9c       	mov	r12,r4
800096f4:	fe b0 f4 1c 	rcall	80007f2c <__sprint_r>
800096f8:	e0 81 03 a7 	brne	80009e46 <_vfprintf_r+0x1efe>
800096fc:	fa c3 f9 e0 	sub	r3,sp,-1568
80009700:	40 9b       	lddsp	r11,sp[0x24]
80009702:	e0 4b 00 80 	cp.w	r11,128
80009706:	c4 71       	brne	80009794 <_vfprintf_r+0x184c>
80009708:	40 8a       	lddsp	r10,sp[0x20]
8000970a:	40 39       	lddsp	r9,sp[0xc]
8000970c:	12 1a       	sub	r10,r9
8000970e:	50 4a       	stdsp	sp[0x10],r10
80009710:	58 0a       	cp.w	r10,0
80009712:	e0 89 00 20 	brgt	80009752 <_vfprintf_r+0x180a>
80009716:	c3 f8       	rjmp	80009794 <_vfprintf_r+0x184c>
80009718:	2f 09       	sub	r9,-16
8000971a:	2f f8       	sub	r8,-1
8000971c:	fe ce ba 68 	sub	lr,pc,-17816
80009720:	31 0c       	mov	r12,16
80009722:	fb 49 06 90 	st.w	sp[1680],r9
80009726:	87 0e       	st.w	r3[0x0],lr
80009728:	87 1c       	st.w	r3[0x4],r12
8000972a:	fb 48 06 8c 	st.w	sp[1676],r8
8000972e:	58 78       	cp.w	r8,7
80009730:	e0 89 00 04 	brgt	80009738 <_vfprintf_r+0x17f0>
80009734:	2f 83       	sub	r3,-8
80009736:	c0 b8       	rjmp	8000974c <_vfprintf_r+0x1804>
80009738:	fa ca f9 78 	sub	r10,sp,-1672
8000973c:	02 9b       	mov	r11,r1
8000973e:	08 9c       	mov	r12,r4
80009740:	fe b0 f3 f6 	rcall	80007f2c <__sprint_r>
80009744:	e0 81 03 81 	brne	80009e46 <_vfprintf_r+0x1efe>
80009748:	fa c3 f9 e0 	sub	r3,sp,-1568
8000974c:	40 4b       	lddsp	r11,sp[0x10]
8000974e:	21 0b       	sub	r11,16
80009750:	50 4b       	stdsp	sp[0x10],r11
80009752:	fa f9 06 90 	ld.w	r9,sp[1680]
80009756:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000975a:	fe ca ba a6 	sub	r10,pc,-17754
8000975e:	40 4e       	lddsp	lr,sp[0x10]
80009760:	59 0e       	cp.w	lr,16
80009762:	fe 99 ff db 	brgt	80009718 <_vfprintf_r+0x17d0>
80009766:	1c 09       	add	r9,lr
80009768:	2f f8       	sub	r8,-1
8000976a:	87 0a       	st.w	r3[0x0],r10
8000976c:	fb 49 06 90 	st.w	sp[1680],r9
80009770:	87 1e       	st.w	r3[0x4],lr
80009772:	fb 48 06 8c 	st.w	sp[1676],r8
80009776:	58 78       	cp.w	r8,7
80009778:	e0 89 00 04 	brgt	80009780 <_vfprintf_r+0x1838>
8000977c:	2f 83       	sub	r3,-8
8000977e:	c0 b8       	rjmp	80009794 <_vfprintf_r+0x184c>
80009780:	fa ca f9 78 	sub	r10,sp,-1672
80009784:	02 9b       	mov	r11,r1
80009786:	08 9c       	mov	r12,r4
80009788:	fe b0 f3 d2 	rcall	80007f2c <__sprint_r>
8000978c:	e0 81 03 5d 	brne	80009e46 <_vfprintf_r+0x1efe>
80009790:	fa c3 f9 e0 	sub	r3,sp,-1568
80009794:	40 2c       	lddsp	r12,sp[0x8]
80009796:	04 1c       	sub	r12,r2
80009798:	50 2c       	stdsp	sp[0x8],r12
8000979a:	58 0c       	cp.w	r12,0
8000979c:	e0 89 00 20 	brgt	800097dc <_vfprintf_r+0x1894>
800097a0:	c3 f8       	rjmp	8000981e <_vfprintf_r+0x18d6>
800097a2:	2f 09       	sub	r9,-16
800097a4:	2f f8       	sub	r8,-1
800097a6:	fe cb ba f2 	sub	r11,pc,-17678
800097aa:	31 0a       	mov	r10,16
800097ac:	fb 49 06 90 	st.w	sp[1680],r9
800097b0:	87 0b       	st.w	r3[0x0],r11
800097b2:	87 1a       	st.w	r3[0x4],r10
800097b4:	fb 48 06 8c 	st.w	sp[1676],r8
800097b8:	58 78       	cp.w	r8,7
800097ba:	e0 89 00 04 	brgt	800097c2 <_vfprintf_r+0x187a>
800097be:	2f 83       	sub	r3,-8
800097c0:	c0 b8       	rjmp	800097d6 <_vfprintf_r+0x188e>
800097c2:	fa ca f9 78 	sub	r10,sp,-1672
800097c6:	02 9b       	mov	r11,r1
800097c8:	08 9c       	mov	r12,r4
800097ca:	fe b0 f3 b1 	rcall	80007f2c <__sprint_r>
800097ce:	e0 81 03 3c 	brne	80009e46 <_vfprintf_r+0x1efe>
800097d2:	fa c3 f9 e0 	sub	r3,sp,-1568
800097d6:	40 29       	lddsp	r9,sp[0x8]
800097d8:	21 09       	sub	r9,16
800097da:	50 29       	stdsp	sp[0x8],r9
800097dc:	fa f9 06 90 	ld.w	r9,sp[1680]
800097e0:	fa f8 06 8c 	ld.w	r8,sp[1676]
800097e4:	fe ca bb 30 	sub	r10,pc,-17616
800097e8:	40 2e       	lddsp	lr,sp[0x8]
800097ea:	59 0e       	cp.w	lr,16
800097ec:	fe 99 ff db 	brgt	800097a2 <_vfprintf_r+0x185a>
800097f0:	1c 09       	add	r9,lr
800097f2:	2f f8       	sub	r8,-1
800097f4:	87 0a       	st.w	r3[0x0],r10
800097f6:	fb 49 06 90 	st.w	sp[1680],r9
800097fa:	87 1e       	st.w	r3[0x4],lr
800097fc:	fb 48 06 8c 	st.w	sp[1676],r8
80009800:	58 78       	cp.w	r8,7
80009802:	e0 89 00 04 	brgt	8000980a <_vfprintf_r+0x18c2>
80009806:	2f 83       	sub	r3,-8
80009808:	c0 b8       	rjmp	8000981e <_vfprintf_r+0x18d6>
8000980a:	fa ca f9 78 	sub	r10,sp,-1672
8000980e:	02 9b       	mov	r11,r1
80009810:	08 9c       	mov	r12,r4
80009812:	fe b0 f3 8d 	rcall	80007f2c <__sprint_r>
80009816:	e0 81 03 18 	brne	80009e46 <_vfprintf_r+0x1efe>
8000981a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000981e:	ed b5 00 08 	bld	r5,0x8
80009822:	c0 b0       	breq	80009838 <_vfprintf_r+0x18f0>
80009824:	fa f8 06 90 	ld.w	r8,sp[1680]
80009828:	87 12       	st.w	r3[0x4],r2
8000982a:	87 06       	st.w	r3[0x0],r6
8000982c:	f0 02 00 02 	add	r2,r8,r2
80009830:	fb 42 06 90 	st.w	sp[1680],r2
80009834:	e0 8f 01 d4 	bral	80009bdc <_vfprintf_r+0x1c94>
80009838:	e0 40 00 65 	cp.w	r0,101
8000983c:	e0 8a 01 d6 	brle	80009be8 <_vfprintf_r+0x1ca0>
80009840:	30 08       	mov	r8,0
80009842:	30 09       	mov	r9,0
80009844:	40 5b       	lddsp	r11,sp[0x14]
80009846:	40 7a       	lddsp	r10,sp[0x1c]
80009848:	e0 a0 15 3b 	rcall	8000c2be <__avr32_f64_cmp_eq>
8000984c:	c7 90       	breq	8000993e <_vfprintf_r+0x19f6>
8000984e:	fa f8 06 90 	ld.w	r8,sp[1680]
80009852:	fe c9 bb b2 	sub	r9,pc,-17486
80009856:	2f f8       	sub	r8,-1
80009858:	87 09       	st.w	r3[0x0],r9
8000985a:	fb 48 06 90 	st.w	sp[1680],r8
8000985e:	30 19       	mov	r9,1
80009860:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009864:	87 19       	st.w	r3[0x4],r9
80009866:	2f f8       	sub	r8,-1
80009868:	fb 48 06 8c 	st.w	sp[1676],r8
8000986c:	58 78       	cp.w	r8,7
8000986e:	e0 89 00 05 	brgt	80009878 <_vfprintf_r+0x1930>
80009872:	2f 83       	sub	r3,-8
80009874:	c0 c8       	rjmp	8000988c <_vfprintf_r+0x1944>
80009876:	d7 03       	nop
80009878:	fa ca f9 78 	sub	r10,sp,-1672
8000987c:	02 9b       	mov	r11,r1
8000987e:	08 9c       	mov	r12,r4
80009880:	fe b0 f3 56 	rcall	80007f2c <__sprint_r>
80009884:	e0 81 02 e1 	brne	80009e46 <_vfprintf_r+0x1efe>
80009888:	fa c3 f9 e0 	sub	r3,sp,-1568
8000988c:	fa f8 06 ac 	ld.w	r8,sp[1708]
80009890:	40 6c       	lddsp	r12,sp[0x18]
80009892:	18 38       	cp.w	r8,r12
80009894:	c0 55       	brlt	8000989e <_vfprintf_r+0x1956>
80009896:	ed b5 00 00 	bld	r5,0x0
8000989a:	e0 81 02 6b 	brne	80009d70 <_vfprintf_r+0x1e28>
8000989e:	fa f8 06 90 	ld.w	r8,sp[1680]
800098a2:	2f f8       	sub	r8,-1
800098a4:	40 cb       	lddsp	r11,sp[0x30]
800098a6:	fb 48 06 90 	st.w	sp[1680],r8
800098aa:	30 19       	mov	r9,1
800098ac:	fa f8 06 8c 	ld.w	r8,sp[1676]
800098b0:	87 0b       	st.w	r3[0x0],r11
800098b2:	2f f8       	sub	r8,-1
800098b4:	87 19       	st.w	r3[0x4],r9
800098b6:	fb 48 06 8c 	st.w	sp[1676],r8
800098ba:	58 78       	cp.w	r8,7
800098bc:	e0 89 00 04 	brgt	800098c4 <_vfprintf_r+0x197c>
800098c0:	2f 83       	sub	r3,-8
800098c2:	c0 b8       	rjmp	800098d8 <_vfprintf_r+0x1990>
800098c4:	fa ca f9 78 	sub	r10,sp,-1672
800098c8:	02 9b       	mov	r11,r1
800098ca:	08 9c       	mov	r12,r4
800098cc:	fe b0 f3 30 	rcall	80007f2c <__sprint_r>
800098d0:	e0 81 02 bb 	brne	80009e46 <_vfprintf_r+0x1efe>
800098d4:	fa c3 f9 e0 	sub	r3,sp,-1568
800098d8:	40 66       	lddsp	r6,sp[0x18]
800098da:	20 16       	sub	r6,1
800098dc:	58 06       	cp.w	r6,0
800098de:	e0 89 00 1d 	brgt	80009918 <_vfprintf_r+0x19d0>
800098e2:	e0 8f 02 47 	bral	80009d70 <_vfprintf_r+0x1e28>
800098e6:	2f 09       	sub	r9,-16
800098e8:	2f f8       	sub	r8,-1
800098ea:	fb 49 06 90 	st.w	sp[1680],r9
800098ee:	87 02       	st.w	r3[0x0],r2
800098f0:	87 10       	st.w	r3[0x4],r0
800098f2:	fb 48 06 8c 	st.w	sp[1676],r8
800098f6:	58 78       	cp.w	r8,7
800098f8:	e0 89 00 04 	brgt	80009900 <_vfprintf_r+0x19b8>
800098fc:	2f 83       	sub	r3,-8
800098fe:	c0 b8       	rjmp	80009914 <_vfprintf_r+0x19cc>
80009900:	fa ca f9 78 	sub	r10,sp,-1672
80009904:	02 9b       	mov	r11,r1
80009906:	08 9c       	mov	r12,r4
80009908:	fe b0 f3 12 	rcall	80007f2c <__sprint_r>
8000990c:	e0 81 02 9d 	brne	80009e46 <_vfprintf_r+0x1efe>
80009910:	fa c3 f9 e0 	sub	r3,sp,-1568
80009914:	21 06       	sub	r6,16
80009916:	c0 48       	rjmp	8000991e <_vfprintf_r+0x19d6>
80009918:	fe c2 bc 64 	sub	r2,pc,-17308
8000991c:	31 00       	mov	r0,16
8000991e:	fa f9 06 90 	ld.w	r9,sp[1680]
80009922:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009926:	fe ca bc 72 	sub	r10,pc,-17294
8000992a:	59 06       	cp.w	r6,16
8000992c:	fe 99 ff dd 	brgt	800098e6 <_vfprintf_r+0x199e>
80009930:	0c 09       	add	r9,r6
80009932:	87 0a       	st.w	r3[0x0],r10
80009934:	fb 49 06 90 	st.w	sp[1680],r9
80009938:	2f f8       	sub	r8,-1
8000993a:	87 16       	st.w	r3[0x4],r6
8000993c:	c5 39       	rjmp	80009be2 <_vfprintf_r+0x1c9a>
8000993e:	fa fa 06 ac 	ld.w	r10,sp[1708]
80009942:	58 0a       	cp.w	r10,0
80009944:	e0 89 00 92 	brgt	80009a68 <_vfprintf_r+0x1b20>
80009948:	fa f8 06 90 	ld.w	r8,sp[1680]
8000994c:	fe c9 bc ac 	sub	r9,pc,-17236
80009950:	2f f8       	sub	r8,-1
80009952:	87 09       	st.w	r3[0x0],r9
80009954:	fb 48 06 90 	st.w	sp[1680],r8
80009958:	30 19       	mov	r9,1
8000995a:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000995e:	87 19       	st.w	r3[0x4],r9
80009960:	2f f8       	sub	r8,-1
80009962:	fb 48 06 8c 	st.w	sp[1676],r8
80009966:	58 78       	cp.w	r8,7
80009968:	e0 89 00 04 	brgt	80009970 <_vfprintf_r+0x1a28>
8000996c:	2f 83       	sub	r3,-8
8000996e:	c0 b8       	rjmp	80009984 <_vfprintf_r+0x1a3c>
80009970:	fa ca f9 78 	sub	r10,sp,-1672
80009974:	02 9b       	mov	r11,r1
80009976:	08 9c       	mov	r12,r4
80009978:	fe b0 f2 da 	rcall	80007f2c <__sprint_r>
8000997c:	e0 81 02 65 	brne	80009e46 <_vfprintf_r+0x1efe>
80009980:	fa c3 f9 e0 	sub	r3,sp,-1568
80009984:	fa f8 06 ac 	ld.w	r8,sp[1708]
80009988:	58 08       	cp.w	r8,0
8000998a:	c0 81       	brne	8000999a <_vfprintf_r+0x1a52>
8000998c:	40 6a       	lddsp	r10,sp[0x18]
8000998e:	58 0a       	cp.w	r10,0
80009990:	c0 51       	brne	8000999a <_vfprintf_r+0x1a52>
80009992:	ed b5 00 00 	bld	r5,0x0
80009996:	e0 81 01 ed 	brne	80009d70 <_vfprintf_r+0x1e28>
8000999a:	40 c9       	lddsp	r9,sp[0x30]
8000999c:	fa f8 06 90 	ld.w	r8,sp[1680]
800099a0:	2f f8       	sub	r8,-1
800099a2:	87 09       	st.w	r3[0x0],r9
800099a4:	fb 48 06 90 	st.w	sp[1680],r8
800099a8:	30 19       	mov	r9,1
800099aa:	fa f8 06 8c 	ld.w	r8,sp[1676]
800099ae:	87 19       	st.w	r3[0x4],r9
800099b0:	2f f8       	sub	r8,-1
800099b2:	fb 48 06 8c 	st.w	sp[1676],r8
800099b6:	58 78       	cp.w	r8,7
800099b8:	e0 89 00 04 	brgt	800099c0 <_vfprintf_r+0x1a78>
800099bc:	2f 83       	sub	r3,-8
800099be:	c0 b8       	rjmp	800099d4 <_vfprintf_r+0x1a8c>
800099c0:	fa ca f9 78 	sub	r10,sp,-1672
800099c4:	02 9b       	mov	r11,r1
800099c6:	08 9c       	mov	r12,r4
800099c8:	fe b0 f2 b2 	rcall	80007f2c <__sprint_r>
800099cc:	e0 81 02 3d 	brne	80009e46 <_vfprintf_r+0x1efe>
800099d0:	fa c3 f9 e0 	sub	r3,sp,-1568
800099d4:	fa f2 06 ac 	ld.w	r2,sp[1708]
800099d8:	5c 32       	neg	r2
800099da:	58 02       	cp.w	r2,0
800099dc:	e0 89 00 1d 	brgt	80009a16 <_vfprintf_r+0x1ace>
800099e0:	c3 d8       	rjmp	80009a5a <_vfprintf_r+0x1b12>
800099e2:	2f 09       	sub	r9,-16
800099e4:	2f f8       	sub	r8,-1
800099e6:	31 0e       	mov	lr,16
800099e8:	fb 49 06 90 	st.w	sp[1680],r9
800099ec:	87 00       	st.w	r3[0x0],r0
800099ee:	87 1e       	st.w	r3[0x4],lr
800099f0:	fb 48 06 8c 	st.w	sp[1676],r8
800099f4:	58 78       	cp.w	r8,7
800099f6:	e0 89 00 04 	brgt	800099fe <_vfprintf_r+0x1ab6>
800099fa:	2f 83       	sub	r3,-8
800099fc:	c0 b8       	rjmp	80009a12 <_vfprintf_r+0x1aca>
800099fe:	fa ca f9 78 	sub	r10,sp,-1672
80009a02:	02 9b       	mov	r11,r1
80009a04:	08 9c       	mov	r12,r4
80009a06:	fe b0 f2 93 	rcall	80007f2c <__sprint_r>
80009a0a:	e0 81 02 1e 	brne	80009e46 <_vfprintf_r+0x1efe>
80009a0e:	fa c3 f9 e0 	sub	r3,sp,-1568
80009a12:	21 02       	sub	r2,16
80009a14:	c0 38       	rjmp	80009a1a <_vfprintf_r+0x1ad2>
80009a16:	fe c0 bd 62 	sub	r0,pc,-17054
80009a1a:	fa f9 06 90 	ld.w	r9,sp[1680]
80009a1e:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009a22:	fe ca bd 6e 	sub	r10,pc,-17042
80009a26:	59 02       	cp.w	r2,16
80009a28:	fe 99 ff dd 	brgt	800099e2 <_vfprintf_r+0x1a9a>
80009a2c:	04 09       	add	r9,r2
80009a2e:	2f f8       	sub	r8,-1
80009a30:	87 0a       	st.w	r3[0x0],r10
80009a32:	fb 49 06 90 	st.w	sp[1680],r9
80009a36:	87 12       	st.w	r3[0x4],r2
80009a38:	fb 48 06 8c 	st.w	sp[1676],r8
80009a3c:	58 78       	cp.w	r8,7
80009a3e:	e0 89 00 04 	brgt	80009a46 <_vfprintf_r+0x1afe>
80009a42:	2f 83       	sub	r3,-8
80009a44:	c0 b8       	rjmp	80009a5a <_vfprintf_r+0x1b12>
80009a46:	fa ca f9 78 	sub	r10,sp,-1672
80009a4a:	02 9b       	mov	r11,r1
80009a4c:	08 9c       	mov	r12,r4
80009a4e:	fe b0 f2 6f 	rcall	80007f2c <__sprint_r>
80009a52:	e0 81 01 fa 	brne	80009e46 <_vfprintf_r+0x1efe>
80009a56:	fa c3 f9 e0 	sub	r3,sp,-1568
80009a5a:	40 6c       	lddsp	r12,sp[0x18]
80009a5c:	fa f8 06 90 	ld.w	r8,sp[1680]
80009a60:	87 06       	st.w	r3[0x0],r6
80009a62:	87 1c       	st.w	r3[0x4],r12
80009a64:	18 08       	add	r8,r12
80009a66:	cb 98       	rjmp	80009bd8 <_vfprintf_r+0x1c90>
80009a68:	fa f9 06 90 	ld.w	r9,sp[1680]
80009a6c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009a70:	40 6b       	lddsp	r11,sp[0x18]
80009a72:	16 3a       	cp.w	r10,r11
80009a74:	c6 f5       	brlt	80009b52 <_vfprintf_r+0x1c0a>
80009a76:	16 09       	add	r9,r11
80009a78:	2f f8       	sub	r8,-1
80009a7a:	87 06       	st.w	r3[0x0],r6
80009a7c:	fb 49 06 90 	st.w	sp[1680],r9
80009a80:	87 1b       	st.w	r3[0x4],r11
80009a82:	fb 48 06 8c 	st.w	sp[1676],r8
80009a86:	58 78       	cp.w	r8,7
80009a88:	e0 89 00 04 	brgt	80009a90 <_vfprintf_r+0x1b48>
80009a8c:	2f 83       	sub	r3,-8
80009a8e:	c0 b8       	rjmp	80009aa4 <_vfprintf_r+0x1b5c>
80009a90:	fa ca f9 78 	sub	r10,sp,-1672
80009a94:	02 9b       	mov	r11,r1
80009a96:	08 9c       	mov	r12,r4
80009a98:	fe b0 f2 4a 	rcall	80007f2c <__sprint_r>
80009a9c:	e0 81 01 d5 	brne	80009e46 <_vfprintf_r+0x1efe>
80009aa0:	fa c3 f9 e0 	sub	r3,sp,-1568
80009aa4:	fa f6 06 ac 	ld.w	r6,sp[1708]
80009aa8:	40 6a       	lddsp	r10,sp[0x18]
80009aaa:	14 16       	sub	r6,r10
80009aac:	58 06       	cp.w	r6,0
80009aae:	e0 89 00 1c 	brgt	80009ae6 <_vfprintf_r+0x1b9e>
80009ab2:	c3 d8       	rjmp	80009b2c <_vfprintf_r+0x1be4>
80009ab4:	2f 09       	sub	r9,-16
80009ab6:	2f f8       	sub	r8,-1
80009ab8:	fb 49 06 90 	st.w	sp[1680],r9
80009abc:	87 02       	st.w	r3[0x0],r2
80009abe:	87 10       	st.w	r3[0x4],r0
80009ac0:	fb 48 06 8c 	st.w	sp[1676],r8
80009ac4:	58 78       	cp.w	r8,7
80009ac6:	e0 89 00 04 	brgt	80009ace <_vfprintf_r+0x1b86>
80009aca:	2f 83       	sub	r3,-8
80009acc:	c0 b8       	rjmp	80009ae2 <_vfprintf_r+0x1b9a>
80009ace:	fa ca f9 78 	sub	r10,sp,-1672
80009ad2:	02 9b       	mov	r11,r1
80009ad4:	08 9c       	mov	r12,r4
80009ad6:	fe b0 f2 2b 	rcall	80007f2c <__sprint_r>
80009ada:	e0 81 01 b6 	brne	80009e46 <_vfprintf_r+0x1efe>
80009ade:	fa c3 f9 e0 	sub	r3,sp,-1568
80009ae2:	21 06       	sub	r6,16
80009ae4:	c0 48       	rjmp	80009aec <_vfprintf_r+0x1ba4>
80009ae6:	fe c2 be 32 	sub	r2,pc,-16846
80009aea:	31 00       	mov	r0,16
80009aec:	fa f9 06 90 	ld.w	r9,sp[1680]
80009af0:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009af4:	fe ca be 40 	sub	r10,pc,-16832
80009af8:	59 06       	cp.w	r6,16
80009afa:	fe 99 ff dd 	brgt	80009ab4 <_vfprintf_r+0x1b6c>
80009afe:	0c 09       	add	r9,r6
80009b00:	2f f8       	sub	r8,-1
80009b02:	87 0a       	st.w	r3[0x0],r10
80009b04:	fb 49 06 90 	st.w	sp[1680],r9
80009b08:	87 16       	st.w	r3[0x4],r6
80009b0a:	fb 48 06 8c 	st.w	sp[1676],r8
80009b0e:	58 78       	cp.w	r8,7
80009b10:	e0 89 00 04 	brgt	80009b18 <_vfprintf_r+0x1bd0>
80009b14:	2f 83       	sub	r3,-8
80009b16:	c0 b8       	rjmp	80009b2c <_vfprintf_r+0x1be4>
80009b18:	fa ca f9 78 	sub	r10,sp,-1672
80009b1c:	02 9b       	mov	r11,r1
80009b1e:	08 9c       	mov	r12,r4
80009b20:	fe b0 f2 06 	rcall	80007f2c <__sprint_r>
80009b24:	e0 81 01 91 	brne	80009e46 <_vfprintf_r+0x1efe>
80009b28:	fa c3 f9 e0 	sub	r3,sp,-1568
80009b2c:	ed b5 00 00 	bld	r5,0x0
80009b30:	e0 81 01 20 	brne	80009d70 <_vfprintf_r+0x1e28>
80009b34:	40 c9       	lddsp	r9,sp[0x30]
80009b36:	fa f8 06 90 	ld.w	r8,sp[1680]
80009b3a:	2f f8       	sub	r8,-1
80009b3c:	87 09       	st.w	r3[0x0],r9
80009b3e:	fb 48 06 90 	st.w	sp[1680],r8
80009b42:	30 19       	mov	r9,1
80009b44:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009b48:	87 19       	st.w	r3[0x4],r9
80009b4a:	2f f8       	sub	r8,-1
80009b4c:	fb 48 06 8c 	st.w	sp[1676],r8
80009b50:	c0 29       	rjmp	80009d54 <_vfprintf_r+0x1e0c>
80009b52:	14 09       	add	r9,r10
80009b54:	2f f8       	sub	r8,-1
80009b56:	fb 49 06 90 	st.w	sp[1680],r9
80009b5a:	87 06       	st.w	r3[0x0],r6
80009b5c:	87 1a       	st.w	r3[0x4],r10
80009b5e:	fb 48 06 8c 	st.w	sp[1676],r8
80009b62:	58 78       	cp.w	r8,7
80009b64:	e0 89 00 04 	brgt	80009b6c <_vfprintf_r+0x1c24>
80009b68:	2f 83       	sub	r3,-8
80009b6a:	c0 b8       	rjmp	80009b80 <_vfprintf_r+0x1c38>
80009b6c:	fa ca f9 78 	sub	r10,sp,-1672
80009b70:	02 9b       	mov	r11,r1
80009b72:	08 9c       	mov	r12,r4
80009b74:	fe b0 f1 dc 	rcall	80007f2c <__sprint_r>
80009b78:	e0 81 01 67 	brne	80009e46 <_vfprintf_r+0x1efe>
80009b7c:	fa c3 f9 e0 	sub	r3,sp,-1568
80009b80:	40 c8       	lddsp	r8,sp[0x30]
80009b82:	87 08       	st.w	r3[0x0],r8
80009b84:	fa f8 06 90 	ld.w	r8,sp[1680]
80009b88:	2f f8       	sub	r8,-1
80009b8a:	30 19       	mov	r9,1
80009b8c:	fb 48 06 90 	st.w	sp[1680],r8
80009b90:	87 19       	st.w	r3[0x4],r9
80009b92:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009b96:	2f f8       	sub	r8,-1
80009b98:	fb 48 06 8c 	st.w	sp[1676],r8
80009b9c:	fa f2 06 ac 	ld.w	r2,sp[1708]
80009ba0:	58 78       	cp.w	r8,7
80009ba2:	e0 89 00 04 	brgt	80009baa <_vfprintf_r+0x1c62>
80009ba6:	2f 83       	sub	r3,-8
80009ba8:	c0 b8       	rjmp	80009bbe <_vfprintf_r+0x1c76>
80009baa:	fa ca f9 78 	sub	r10,sp,-1672
80009bae:	02 9b       	mov	r11,r1
80009bb0:	08 9c       	mov	r12,r4
80009bb2:	fe b0 f1 bd 	rcall	80007f2c <__sprint_r>
80009bb6:	e0 81 01 48 	brne	80009e46 <_vfprintf_r+0x1efe>
80009bba:	fa c3 f9 e0 	sub	r3,sp,-1568
80009bbe:	04 06       	add	r6,r2
80009bc0:	fa f8 06 ac 	ld.w	r8,sp[1708]
80009bc4:	87 06       	st.w	r3[0x0],r6
80009bc6:	fa f9 06 90 	ld.w	r9,sp[1680]
80009bca:	40 66       	lddsp	r6,sp[0x18]
80009bcc:	40 6e       	lddsp	lr,sp[0x18]
80009bce:	10 16       	sub	r6,r8
80009bd0:	f2 08 01 08 	sub	r8,r9,r8
80009bd4:	87 16       	st.w	r3[0x4],r6
80009bd6:	1c 08       	add	r8,lr
80009bd8:	fb 48 06 90 	st.w	sp[1680],r8
80009bdc:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009be0:	2f f8       	sub	r8,-1
80009be2:	fb 48 06 8c 	st.w	sp[1676],r8
80009be6:	cb 78       	rjmp	80009d54 <_vfprintf_r+0x1e0c>
80009be8:	40 6c       	lddsp	r12,sp[0x18]
80009bea:	58 1c       	cp.w	r12,1
80009bec:	e0 89 00 06 	brgt	80009bf8 <_vfprintf_r+0x1cb0>
80009bf0:	ed b5 00 00 	bld	r5,0x0
80009bf4:	e0 81 00 85 	brne	80009cfe <_vfprintf_r+0x1db6>
80009bf8:	fa f8 06 90 	ld.w	r8,sp[1680]
80009bfc:	2f f8       	sub	r8,-1
80009bfe:	30 19       	mov	r9,1
80009c00:	fb 48 06 90 	st.w	sp[1680],r8
80009c04:	87 06       	st.w	r3[0x0],r6
80009c06:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009c0a:	87 19       	st.w	r3[0x4],r9
80009c0c:	2f f8       	sub	r8,-1
80009c0e:	fb 48 06 8c 	st.w	sp[1676],r8
80009c12:	58 78       	cp.w	r8,7
80009c14:	e0 89 00 04 	brgt	80009c1c <_vfprintf_r+0x1cd4>
80009c18:	2f 83       	sub	r3,-8
80009c1a:	c0 b8       	rjmp	80009c30 <_vfprintf_r+0x1ce8>
80009c1c:	fa ca f9 78 	sub	r10,sp,-1672
80009c20:	02 9b       	mov	r11,r1
80009c22:	08 9c       	mov	r12,r4
80009c24:	fe b0 f1 84 	rcall	80007f2c <__sprint_r>
80009c28:	e0 81 01 0f 	brne	80009e46 <_vfprintf_r+0x1efe>
80009c2c:	fa c3 f9 e0 	sub	r3,sp,-1568
80009c30:	fa f8 06 90 	ld.w	r8,sp[1680]
80009c34:	2f f8       	sub	r8,-1
80009c36:	40 cb       	lddsp	r11,sp[0x30]
80009c38:	fb 48 06 90 	st.w	sp[1680],r8
80009c3c:	30 19       	mov	r9,1
80009c3e:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009c42:	87 0b       	st.w	r3[0x0],r11
80009c44:	2f f8       	sub	r8,-1
80009c46:	87 19       	st.w	r3[0x4],r9
80009c48:	fb 48 06 8c 	st.w	sp[1676],r8
80009c4c:	58 78       	cp.w	r8,7
80009c4e:	e0 89 00 05 	brgt	80009c58 <_vfprintf_r+0x1d10>
80009c52:	2f 83       	sub	r3,-8
80009c54:	c0 c8       	rjmp	80009c6c <_vfprintf_r+0x1d24>
80009c56:	d7 03       	nop
80009c58:	fa ca f9 78 	sub	r10,sp,-1672
80009c5c:	02 9b       	mov	r11,r1
80009c5e:	08 9c       	mov	r12,r4
80009c60:	fe b0 f1 66 	rcall	80007f2c <__sprint_r>
80009c64:	e0 81 00 f1 	brne	80009e46 <_vfprintf_r+0x1efe>
80009c68:	fa c3 f9 e0 	sub	r3,sp,-1568
80009c6c:	30 08       	mov	r8,0
80009c6e:	30 09       	mov	r9,0
80009c70:	40 5b       	lddsp	r11,sp[0x14]
80009c72:	40 7a       	lddsp	r10,sp[0x1c]
80009c74:	e0 a0 13 25 	rcall	8000c2be <__avr32_f64_cmp_eq>
80009c78:	40 68       	lddsp	r8,sp[0x18]
80009c7a:	20 18       	sub	r8,1
80009c7c:	58 0c       	cp.w	r12,0
80009c7e:	c0 d1       	brne	80009c98 <_vfprintf_r+0x1d50>
80009c80:	2f f6       	sub	r6,-1
80009c82:	87 18       	st.w	r3[0x4],r8
80009c84:	87 06       	st.w	r3[0x0],r6
80009c86:	fa f6 06 90 	ld.w	r6,sp[1680]
80009c8a:	10 06       	add	r6,r8
80009c8c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009c90:	fb 46 06 90 	st.w	sp[1680],r6
80009c94:	2f f8       	sub	r8,-1
80009c96:	c3 18       	rjmp	80009cf8 <_vfprintf_r+0x1db0>
80009c98:	10 96       	mov	r6,r8
80009c9a:	58 08       	cp.w	r8,0
80009c9c:	e0 89 00 1c 	brgt	80009cd4 <_vfprintf_r+0x1d8c>
80009ca0:	c4 b8       	rjmp	80009d36 <_vfprintf_r+0x1dee>
80009ca2:	2f 09       	sub	r9,-16
80009ca4:	2f f8       	sub	r8,-1
80009ca6:	fb 49 06 90 	st.w	sp[1680],r9
80009caa:	87 02       	st.w	r3[0x0],r2
80009cac:	87 10       	st.w	r3[0x4],r0
80009cae:	fb 48 06 8c 	st.w	sp[1676],r8
80009cb2:	58 78       	cp.w	r8,7
80009cb4:	e0 89 00 04 	brgt	80009cbc <_vfprintf_r+0x1d74>
80009cb8:	2f 83       	sub	r3,-8
80009cba:	c0 b8       	rjmp	80009cd0 <_vfprintf_r+0x1d88>
80009cbc:	fa ca f9 78 	sub	r10,sp,-1672
80009cc0:	02 9b       	mov	r11,r1
80009cc2:	08 9c       	mov	r12,r4
80009cc4:	fe b0 f1 34 	rcall	80007f2c <__sprint_r>
80009cc8:	e0 81 00 bf 	brne	80009e46 <_vfprintf_r+0x1efe>
80009ccc:	fa c3 f9 e0 	sub	r3,sp,-1568
80009cd0:	21 06       	sub	r6,16
80009cd2:	c0 48       	rjmp	80009cda <_vfprintf_r+0x1d92>
80009cd4:	fe c2 c0 20 	sub	r2,pc,-16352
80009cd8:	31 00       	mov	r0,16
80009cda:	fa f9 06 90 	ld.w	r9,sp[1680]
80009cde:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009ce2:	fe ca c0 2e 	sub	r10,pc,-16338
80009ce6:	59 06       	cp.w	r6,16
80009ce8:	fe 99 ff dd 	brgt	80009ca2 <_vfprintf_r+0x1d5a>
80009cec:	0c 09       	add	r9,r6
80009cee:	87 0a       	st.w	r3[0x0],r10
80009cf0:	fb 49 06 90 	st.w	sp[1680],r9
80009cf4:	2f f8       	sub	r8,-1
80009cf6:	87 16       	st.w	r3[0x4],r6
80009cf8:	fb 48 06 8c 	st.w	sp[1676],r8
80009cfc:	c0 e8       	rjmp	80009d18 <_vfprintf_r+0x1dd0>
80009cfe:	fa f8 06 90 	ld.w	r8,sp[1680]
80009d02:	2f f8       	sub	r8,-1
80009d04:	30 19       	mov	r9,1
80009d06:	fb 48 06 90 	st.w	sp[1680],r8
80009d0a:	87 06       	st.w	r3[0x0],r6
80009d0c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009d10:	87 19       	st.w	r3[0x4],r9
80009d12:	2f f8       	sub	r8,-1
80009d14:	fb 48 06 8c 	st.w	sp[1676],r8
80009d18:	58 78       	cp.w	r8,7
80009d1a:	e0 89 00 04 	brgt	80009d22 <_vfprintf_r+0x1dda>
80009d1e:	2f 83       	sub	r3,-8
80009d20:	c0 b8       	rjmp	80009d36 <_vfprintf_r+0x1dee>
80009d22:	fa ca f9 78 	sub	r10,sp,-1672
80009d26:	02 9b       	mov	r11,r1
80009d28:	08 9c       	mov	r12,r4
80009d2a:	fe b0 f1 01 	rcall	80007f2c <__sprint_r>
80009d2e:	e0 81 00 8c 	brne	80009e46 <_vfprintf_r+0x1efe>
80009d32:	fa c3 f9 e0 	sub	r3,sp,-1568
80009d36:	40 ea       	lddsp	r10,sp[0x38]
80009d38:	fa f8 06 90 	ld.w	r8,sp[1680]
80009d3c:	14 08       	add	r8,r10
80009d3e:	fa c9 f9 64 	sub	r9,sp,-1692
80009d42:	fb 48 06 90 	st.w	sp[1680],r8
80009d46:	87 1a       	st.w	r3[0x4],r10
80009d48:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009d4c:	87 09       	st.w	r3[0x0],r9
80009d4e:	2f f8       	sub	r8,-1
80009d50:	fb 48 06 8c 	st.w	sp[1676],r8
80009d54:	58 78       	cp.w	r8,7
80009d56:	e0 89 00 04 	brgt	80009d5e <_vfprintf_r+0x1e16>
80009d5a:	2f 83       	sub	r3,-8
80009d5c:	c0 a8       	rjmp	80009d70 <_vfprintf_r+0x1e28>
80009d5e:	fa ca f9 78 	sub	r10,sp,-1672
80009d62:	02 9b       	mov	r11,r1
80009d64:	08 9c       	mov	r12,r4
80009d66:	fe b0 f0 e3 	rcall	80007f2c <__sprint_r>
80009d6a:	c6 e1       	brne	80009e46 <_vfprintf_r+0x1efe>
80009d6c:	fa c3 f9 e0 	sub	r3,sp,-1568
80009d70:	e2 15 00 04 	andl	r5,0x4,COH
80009d74:	c3 f0       	breq	80009df2 <_vfprintf_r+0x1eaa>
80009d76:	40 86       	lddsp	r6,sp[0x20]
80009d78:	40 39       	lddsp	r9,sp[0xc]
80009d7a:	12 16       	sub	r6,r9
80009d7c:	58 06       	cp.w	r6,0
80009d7e:	e0 89 00 1a 	brgt	80009db2 <_vfprintf_r+0x1e6a>
80009d82:	c3 88       	rjmp	80009df2 <_vfprintf_r+0x1eaa>
80009d84:	2f 09       	sub	r9,-16
80009d86:	2f f8       	sub	r8,-1
80009d88:	fb 49 06 90 	st.w	sp[1680],r9
80009d8c:	87 05       	st.w	r3[0x0],r5
80009d8e:	87 12       	st.w	r3[0x4],r2
80009d90:	fb 48 06 8c 	st.w	sp[1676],r8
80009d94:	58 78       	cp.w	r8,7
80009d96:	e0 89 00 04 	brgt	80009d9e <_vfprintf_r+0x1e56>
80009d9a:	2f 83       	sub	r3,-8
80009d9c:	c0 98       	rjmp	80009dae <_vfprintf_r+0x1e66>
80009d9e:	00 9a       	mov	r10,r0
80009da0:	02 9b       	mov	r11,r1
80009da2:	08 9c       	mov	r12,r4
80009da4:	fe b0 f0 c4 	rcall	80007f2c <__sprint_r>
80009da8:	c4 f1       	brne	80009e46 <_vfprintf_r+0x1efe>
80009daa:	fa c3 f9 e0 	sub	r3,sp,-1568
80009dae:	21 06       	sub	r6,16
80009db0:	c0 68       	rjmp	80009dbc <_vfprintf_r+0x1e74>
80009db2:	fe c5 c1 0e 	sub	r5,pc,-16114
80009db6:	31 02       	mov	r2,16
80009db8:	fa c0 f9 78 	sub	r0,sp,-1672
80009dbc:	fa f9 06 90 	ld.w	r9,sp[1680]
80009dc0:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009dc4:	fe ca c1 20 	sub	r10,pc,-16096
80009dc8:	59 06       	cp.w	r6,16
80009dca:	fe 99 ff dd 	brgt	80009d84 <_vfprintf_r+0x1e3c>
80009dce:	0c 09       	add	r9,r6
80009dd0:	2f f8       	sub	r8,-1
80009dd2:	87 0a       	st.w	r3[0x0],r10
80009dd4:	87 16       	st.w	r3[0x4],r6
80009dd6:	fb 49 06 90 	st.w	sp[1680],r9
80009dda:	fb 48 06 8c 	st.w	sp[1676],r8
80009dde:	58 78       	cp.w	r8,7
80009de0:	e0 8a 00 09 	brle	80009df2 <_vfprintf_r+0x1eaa>
80009de4:	fa ca f9 78 	sub	r10,sp,-1672
80009de8:	02 9b       	mov	r11,r1
80009dea:	08 9c       	mov	r12,r4
80009dec:	fe b0 f0 a0 	rcall	80007f2c <__sprint_r>
80009df0:	c2 b1       	brne	80009e46 <_vfprintf_r+0x1efe>
80009df2:	40 bc       	lddsp	r12,sp[0x2c]
80009df4:	40 36       	lddsp	r6,sp[0xc]
80009df6:	40 8e       	lddsp	lr,sp[0x20]
80009df8:	ec 0e 0c 48 	max	r8,r6,lr
80009dfc:	10 0c       	add	r12,r8
80009dfe:	50 bc       	stdsp	sp[0x2c],r12
80009e00:	fa f8 06 90 	ld.w	r8,sp[1680]
80009e04:	58 08       	cp.w	r8,0
80009e06:	c0 80       	breq	80009e16 <_vfprintf_r+0x1ece>
80009e08:	fa ca f9 78 	sub	r10,sp,-1672
80009e0c:	02 9b       	mov	r11,r1
80009e0e:	08 9c       	mov	r12,r4
80009e10:	fe b0 f0 8e 	rcall	80007f2c <__sprint_r>
80009e14:	c1 91       	brne	80009e46 <_vfprintf_r+0x1efe>
80009e16:	30 0b       	mov	r11,0
80009e18:	fa c3 f9 e0 	sub	r3,sp,-1568
80009e1c:	fb 4b 06 8c 	st.w	sp[1676],r11
80009e20:	fe 9f f1 22 	bral	80008064 <_vfprintf_r+0x11c>
80009e24:	08 95       	mov	r5,r4
80009e26:	fa f8 06 90 	ld.w	r8,sp[1680]
80009e2a:	58 08       	cp.w	r8,0
80009e2c:	c0 80       	breq	80009e3c <_vfprintf_r+0x1ef4>
80009e2e:	08 9c       	mov	r12,r4
80009e30:	fa ca f9 78 	sub	r10,sp,-1672
80009e34:	02 9b       	mov	r11,r1
80009e36:	fe b0 f0 7b 	rcall	80007f2c <__sprint_r>
80009e3a:	c0 61       	brne	80009e46 <_vfprintf_r+0x1efe>
80009e3c:	30 08       	mov	r8,0
80009e3e:	fb 48 06 8c 	st.w	sp[1676],r8
80009e42:	c0 28       	rjmp	80009e46 <_vfprintf_r+0x1efe>
80009e44:	40 41       	lddsp	r1,sp[0x10]
80009e46:	82 68       	ld.sh	r8,r1[0xc]
80009e48:	ed b8 00 06 	bld	r8,0x6
80009e4c:	c0 31       	brne	80009e52 <_vfprintf_r+0x1f0a>
80009e4e:	3f fa       	mov	r10,-1
80009e50:	50 ba       	stdsp	sp[0x2c],r10
80009e52:	40 bc       	lddsp	r12,sp[0x2c]
80009e54:	fe 3d f9 44 	sub	sp,-1724
80009e58:	d8 32       	popm	r0-r7,pc
80009e5a:	d7 03       	nop

80009e5c <__swsetup_r>:
80009e5c:	d4 21       	pushm	r4-r7,lr
80009e5e:	e0 68 0a 3c 	mov	r8,2620
80009e62:	18 96       	mov	r6,r12
80009e64:	16 97       	mov	r7,r11
80009e66:	70 0c       	ld.w	r12,r8[0x0]
80009e68:	58 0c       	cp.w	r12,0
80009e6a:	c0 60       	breq	80009e76 <__swsetup_r+0x1a>
80009e6c:	78 68       	ld.w	r8,r12[0x18]
80009e6e:	58 08       	cp.w	r8,0
80009e70:	c0 31       	brne	80009e76 <__swsetup_r+0x1a>
80009e72:	e0 a0 07 bf 	rcall	8000adf0 <__sinit>
80009e76:	fe c8 c0 a2 	sub	r8,pc,-16222
80009e7a:	10 37       	cp.w	r7,r8
80009e7c:	c0 61       	brne	80009e88 <__swsetup_r+0x2c>
80009e7e:	e0 68 0a 3c 	mov	r8,2620
80009e82:	70 08       	ld.w	r8,r8[0x0]
80009e84:	70 07       	ld.w	r7,r8[0x0]
80009e86:	c1 28       	rjmp	80009eaa <__swsetup_r+0x4e>
80009e88:	fe c8 c0 94 	sub	r8,pc,-16236
80009e8c:	10 37       	cp.w	r7,r8
80009e8e:	c0 61       	brne	80009e9a <__swsetup_r+0x3e>
80009e90:	e0 68 0a 3c 	mov	r8,2620
80009e94:	70 08       	ld.w	r8,r8[0x0]
80009e96:	70 17       	ld.w	r7,r8[0x4]
80009e98:	c0 98       	rjmp	80009eaa <__swsetup_r+0x4e>
80009e9a:	fe c8 c0 86 	sub	r8,pc,-16250
80009e9e:	10 37       	cp.w	r7,r8
80009ea0:	c0 51       	brne	80009eaa <__swsetup_r+0x4e>
80009ea2:	e0 68 0a 3c 	mov	r8,2620
80009ea6:	70 08       	ld.w	r8,r8[0x0]
80009ea8:	70 27       	ld.w	r7,r8[0x8]
80009eaa:	8e 68       	ld.sh	r8,r7[0xc]
80009eac:	ed b8 00 03 	bld	r8,0x3
80009eb0:	c1 e0       	breq	80009eec <__swsetup_r+0x90>
80009eb2:	ed b8 00 04 	bld	r8,0x4
80009eb6:	c3 e1       	brne	80009f32 <__swsetup_r+0xd6>
80009eb8:	ed b8 00 02 	bld	r8,0x2
80009ebc:	c1 51       	brne	80009ee6 <__swsetup_r+0x8a>
80009ebe:	6e db       	ld.w	r11,r7[0x34]
80009ec0:	58 0b       	cp.w	r11,0
80009ec2:	c0 a0       	breq	80009ed6 <__swsetup_r+0x7a>
80009ec4:	ee c8 ff bc 	sub	r8,r7,-68
80009ec8:	10 3b       	cp.w	r11,r8
80009eca:	c0 40       	breq	80009ed2 <__swsetup_r+0x76>
80009ecc:	0c 9c       	mov	r12,r6
80009ece:	e0 a0 08 2b 	rcall	8000af24 <_free_r>
80009ed2:	30 08       	mov	r8,0
80009ed4:	8f d8       	st.w	r7[0x34],r8
80009ed6:	8e 68       	ld.sh	r8,r7[0xc]
80009ed8:	e0 18 ff db 	andl	r8,0xffdb
80009edc:	ae 68       	st.h	r7[0xc],r8
80009ede:	30 08       	mov	r8,0
80009ee0:	8f 18       	st.w	r7[0x4],r8
80009ee2:	6e 48       	ld.w	r8,r7[0x10]
80009ee4:	8f 08       	st.w	r7[0x0],r8
80009ee6:	8e 68       	ld.sh	r8,r7[0xc]
80009ee8:	a3 b8       	sbr	r8,0x3
80009eea:	ae 68       	st.h	r7[0xc],r8
80009eec:	6e 48       	ld.w	r8,r7[0x10]
80009eee:	58 08       	cp.w	r8,0
80009ef0:	c0 b1       	brne	80009f06 <__swsetup_r+0xaa>
80009ef2:	8e 68       	ld.sh	r8,r7[0xc]
80009ef4:	e2 18 02 80 	andl	r8,0x280,COH
80009ef8:	e0 48 02 00 	cp.w	r8,512
80009efc:	c0 50       	breq	80009f06 <__swsetup_r+0xaa>
80009efe:	0c 9c       	mov	r12,r6
80009f00:	0e 9b       	mov	r11,r7
80009f02:	e0 a0 0a 4b 	rcall	8000b398 <__smakebuf_r>
80009f06:	8e 69       	ld.sh	r9,r7[0xc]
80009f08:	f1 d9 c0 01 	bfextu	r8,r9,0x0,0x1
80009f0c:	c0 70       	breq	80009f1a <__swsetup_r+0xbe>
80009f0e:	30 08       	mov	r8,0
80009f10:	8f 28       	st.w	r7[0x8],r8
80009f12:	6e 58       	ld.w	r8,r7[0x14]
80009f14:	5c 38       	neg	r8
80009f16:	8f 68       	st.w	r7[0x18],r8
80009f18:	c0 68       	rjmp	80009f24 <__swsetup_r+0xc8>
80009f1a:	ed b9 00 01 	bld	r9,0x1
80009f1e:	ef f8 10 05 	ld.wne	r8,r7[0x14]
80009f22:	8f 28       	st.w	r7[0x8],r8
80009f24:	6e 48       	ld.w	r8,r7[0x10]
80009f26:	58 08       	cp.w	r8,0
80009f28:	c0 61       	brne	80009f34 <__swsetup_r+0xd8>
80009f2a:	8e 68       	ld.sh	r8,r7[0xc]
80009f2c:	ed b8 00 07 	bld	r8,0x7
80009f30:	c0 21       	brne	80009f34 <__swsetup_r+0xd8>
80009f32:	dc 2a       	popm	r4-r7,pc,r12=-1
80009f34:	d8 2a       	popm	r4-r7,pc,r12=0
80009f36:	d7 03       	nop

80009f38 <quorem>:
80009f38:	d4 31       	pushm	r0-r7,lr
80009f3a:	20 2d       	sub	sp,8
80009f3c:	18 97       	mov	r7,r12
80009f3e:	78 48       	ld.w	r8,r12[0x10]
80009f40:	76 46       	ld.w	r6,r11[0x10]
80009f42:	0c 38       	cp.w	r8,r6
80009f44:	c0 34       	brge	80009f4a <quorem+0x12>
80009f46:	30 0c       	mov	r12,0
80009f48:	c8 58       	rjmp	8000a052 <quorem+0x11a>
80009f4a:	ec c2 ff fc 	sub	r2,r6,-4
80009f4e:	f6 c3 ff ec 	sub	r3,r11,-20
80009f52:	f6 02 03 29 	ld.w	r9,r11[r2<<0x2]
80009f56:	f8 02 03 2c 	ld.w	r12,r12[r2<<0x2]
80009f5a:	2f f9       	sub	r9,-1
80009f5c:	20 16       	sub	r6,1
80009f5e:	f8 09 0d 08 	divu	r8,r12,r9
80009f62:	f6 02 00 22 	add	r2,r11,r2<<0x2
80009f66:	ee c4 ff ec 	sub	r4,r7,-20
80009f6a:	10 95       	mov	r5,r8
80009f6c:	58 08       	cp.w	r8,0
80009f6e:	c4 10       	breq	80009ff0 <quorem+0xb8>
80009f70:	30 09       	mov	r9,0
80009f72:	06 9a       	mov	r10,r3
80009f74:	08 98       	mov	r8,r4
80009f76:	12 91       	mov	r1,r9
80009f78:	50 0b       	stdsp	sp[0x0],r11
80009f7a:	70 0e       	ld.w	lr,r8[0x0]
80009f7c:	b1 8e       	lsr	lr,0x10
80009f7e:	50 1e       	stdsp	sp[0x4],lr
80009f80:	15 0e       	ld.w	lr,r10++
80009f82:	fc 00 16 10 	lsr	r0,lr,0x10
80009f86:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
80009f8a:	ea 0e 03 41 	mac	r1,r5,lr
80009f8e:	fd d1 c0 10 	bfextu	lr,r1,0x0,0x10
80009f92:	b1 81       	lsr	r1,0x10
80009f94:	40 1b       	lddsp	r11,sp[0x4]
80009f96:	ea 00 02 40 	mul	r0,r5,r0
80009f9a:	e2 00 00 00 	add	r0,r1,r0
80009f9e:	e3 d0 c0 10 	bfextu	r1,r0,0x0,0x10
80009fa2:	02 1b       	sub	r11,r1
80009fa4:	50 1b       	stdsp	sp[0x4],r11
80009fa6:	70 0b       	ld.w	r11,r8[0x0]
80009fa8:	e3 db c0 10 	bfextu	r1,r11,0x0,0x10
80009fac:	02 09       	add	r9,r1
80009fae:	f2 0e 01 0e 	sub	lr,r9,lr
80009fb2:	b0 1e       	st.h	r8[0x2],lr
80009fb4:	fc 09 14 10 	asr	r9,lr,0x10
80009fb8:	40 1e       	lddsp	lr,sp[0x4]
80009fba:	fc 09 00 09 	add	r9,lr,r9
80009fbe:	b0 09       	st.h	r8[0x0],r9
80009fc0:	e0 01 16 10 	lsr	r1,r0,0x10
80009fc4:	2f c8       	sub	r8,-4
80009fc6:	b1 49       	asr	r9,0x10
80009fc8:	04 3a       	cp.w	r10,r2
80009fca:	fe 98 ff d8 	brls	80009f7a <quorem+0x42>
80009fce:	40 0b       	lddsp	r11,sp[0x0]
80009fd0:	58 0c       	cp.w	r12,0
80009fd2:	c0 f1       	brne	80009ff0 <quorem+0xb8>
80009fd4:	ec c8 ff fb 	sub	r8,r6,-5
80009fd8:	ee 08 00 28 	add	r8,r7,r8<<0x2
80009fdc:	c0 28       	rjmp	80009fe0 <quorem+0xa8>
80009fde:	20 16       	sub	r6,1
80009fe0:	20 48       	sub	r8,4
80009fe2:	08 38       	cp.w	r8,r4
80009fe4:	e0 88 00 05 	brls	80009fee <quorem+0xb6>
80009fe8:	70 09       	ld.w	r9,r8[0x0]
80009fea:	58 09       	cp.w	r9,0
80009fec:	cf 90       	breq	80009fde <quorem+0xa6>
80009fee:	8f 46       	st.w	r7[0x10],r6
80009ff0:	0e 9c       	mov	r12,r7
80009ff2:	e0 a0 0a d2 	rcall	8000b596 <__mcmp>
80009ff6:	c2 d5       	brlt	8000a050 <quorem+0x118>
80009ff8:	2f f5       	sub	r5,-1
80009ffa:	08 98       	mov	r8,r4
80009ffc:	30 09       	mov	r9,0
80009ffe:	07 0b       	ld.w	r11,r3++
8000a000:	f6 0a 16 10 	lsr	r10,r11,0x10
8000a004:	70 0c       	ld.w	r12,r8[0x0]
8000a006:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000a00a:	f8 0e 16 10 	lsr	lr,r12,0x10
8000a00e:	14 1e       	sub	lr,r10
8000a010:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000a014:	16 1a       	sub	r10,r11
8000a016:	12 0a       	add	r10,r9
8000a018:	b0 1a       	st.h	r8[0x2],r10
8000a01a:	b1 4a       	asr	r10,0x10
8000a01c:	fc 0a 00 09 	add	r9,lr,r10
8000a020:	b0 09       	st.h	r8[0x0],r9
8000a022:	2f c8       	sub	r8,-4
8000a024:	b1 49       	asr	r9,0x10
8000a026:	04 33       	cp.w	r3,r2
8000a028:	fe 98 ff eb 	brls	80009ffe <quorem+0xc6>
8000a02c:	ec c8 ff fb 	sub	r8,r6,-5
8000a030:	ee 08 03 29 	ld.w	r9,r7[r8<<0x2]
8000a034:	58 09       	cp.w	r9,0
8000a036:	c0 d1       	brne	8000a050 <quorem+0x118>
8000a038:	ee 08 00 28 	add	r8,r7,r8<<0x2
8000a03c:	c0 28       	rjmp	8000a040 <quorem+0x108>
8000a03e:	20 16       	sub	r6,1
8000a040:	20 48       	sub	r8,4
8000a042:	08 38       	cp.w	r8,r4
8000a044:	e0 88 00 05 	brls	8000a04e <quorem+0x116>
8000a048:	70 09       	ld.w	r9,r8[0x0]
8000a04a:	58 09       	cp.w	r9,0
8000a04c:	cf 90       	breq	8000a03e <quorem+0x106>
8000a04e:	8f 46       	st.w	r7[0x10],r6
8000a050:	0a 9c       	mov	r12,r5
8000a052:	2f ed       	sub	sp,-8
8000a054:	d8 32       	popm	r0-r7,pc
8000a056:	d7 03       	nop

8000a058 <_dtoa_r>:
8000a058:	d4 31       	pushm	r0-r7,lr
8000a05a:	21 ad       	sub	sp,104
8000a05c:	fa c4 ff 74 	sub	r4,sp,-140
8000a060:	18 97       	mov	r7,r12
8000a062:	16 95       	mov	r5,r11
8000a064:	68 2c       	ld.w	r12,r4[0x8]
8000a066:	50 c9       	stdsp	sp[0x30],r9
8000a068:	68 16       	ld.w	r6,r4[0x4]
8000a06a:	68 09       	ld.w	r9,r4[0x0]
8000a06c:	50 e8       	stdsp	sp[0x38],r8
8000a06e:	14 94       	mov	r4,r10
8000a070:	51 2c       	stdsp	sp[0x48],r12
8000a072:	fa e5 00 08 	st.d	sp[8],r4
8000a076:	51 59       	stdsp	sp[0x54],r9
8000a078:	6e 95       	ld.w	r5,r7[0x24]
8000a07a:	58 05       	cp.w	r5,0
8000a07c:	c0 91       	brne	8000a08e <_dtoa_r+0x36>
8000a07e:	31 0c       	mov	r12,16
8000a080:	fe b0 e8 f4 	rcall	80007268 <malloc>
8000a084:	99 35       	st.w	r12[0xc],r5
8000a086:	8f 9c       	st.w	r7[0x24],r12
8000a088:	99 15       	st.w	r12[0x4],r5
8000a08a:	99 25       	st.w	r12[0x8],r5
8000a08c:	99 05       	st.w	r12[0x0],r5
8000a08e:	6e 99       	ld.w	r9,r7[0x24]
8000a090:	72 08       	ld.w	r8,r9[0x0]
8000a092:	58 08       	cp.w	r8,0
8000a094:	c0 f0       	breq	8000a0b2 <_dtoa_r+0x5a>
8000a096:	72 1a       	ld.w	r10,r9[0x4]
8000a098:	91 1a       	st.w	r8[0x4],r10
8000a09a:	30 1a       	mov	r10,1
8000a09c:	72 19       	ld.w	r9,r9[0x4]
8000a09e:	f4 09 09 49 	lsl	r9,r10,r9
8000a0a2:	10 9b       	mov	r11,r8
8000a0a4:	91 29       	st.w	r8[0x8],r9
8000a0a6:	0e 9c       	mov	r12,r7
8000a0a8:	e0 a0 0a 90 	rcall	8000b5c8 <_Bfree>
8000a0ac:	6e 98       	ld.w	r8,r7[0x24]
8000a0ae:	30 09       	mov	r9,0
8000a0b0:	91 09       	st.w	r8[0x0],r9
8000a0b2:	40 28       	lddsp	r8,sp[0x8]
8000a0b4:	10 94       	mov	r4,r8
8000a0b6:	58 08       	cp.w	r8,0
8000a0b8:	c0 64       	brge	8000a0c4 <_dtoa_r+0x6c>
8000a0ba:	f1 d8 c0 1f 	bfextu	r8,r8,0x0,0x1f
8000a0be:	50 28       	stdsp	sp[0x8],r8
8000a0c0:	30 18       	mov	r8,1
8000a0c2:	c0 28       	rjmp	8000a0c6 <_dtoa_r+0x6e>
8000a0c4:	30 08       	mov	r8,0
8000a0c6:	8d 08       	st.w	r6[0x0],r8
8000a0c8:	fc 1c 7f f0 	movh	r12,0x7ff0
8000a0cc:	40 26       	lddsp	r6,sp[0x8]
8000a0ce:	0c 98       	mov	r8,r6
8000a0d0:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000a0d4:	18 38       	cp.w	r8,r12
8000a0d6:	c2 01       	brne	8000a116 <_dtoa_r+0xbe>
8000a0d8:	e0 68 27 0f 	mov	r8,9999
8000a0dc:	41 5b       	lddsp	r11,sp[0x54]
8000a0de:	97 08       	st.w	r11[0x0],r8
8000a0e0:	40 3a       	lddsp	r10,sp[0xc]
8000a0e2:	58 0a       	cp.w	r10,0
8000a0e4:	c0 71       	brne	8000a0f2 <_dtoa_r+0x9a>
8000a0e6:	ed d6 c0 14 	bfextu	r6,r6,0x0,0x14
8000a0ea:	c0 41       	brne	8000a0f2 <_dtoa_r+0x9a>
8000a0ec:	fe cc c3 28 	sub	r12,pc,-15576
8000a0f0:	c0 38       	rjmp	8000a0f6 <_dtoa_r+0x9e>
8000a0f2:	fe cc c3 22 	sub	r12,pc,-15582
8000a0f6:	41 29       	lddsp	r9,sp[0x48]
8000a0f8:	58 09       	cp.w	r9,0
8000a0fa:	e0 80 05 9a 	breq	8000ac2e <_dtoa_r+0xbd6>
8000a0fe:	f8 c8 ff fd 	sub	r8,r12,-3
8000a102:	f8 c9 ff f8 	sub	r9,r12,-8
8000a106:	11 8b       	ld.ub	r11,r8[0x0]
8000a108:	30 0a       	mov	r10,0
8000a10a:	41 25       	lddsp	r5,sp[0x48]
8000a10c:	f4 0b 18 00 	cp.b	r11,r10
8000a110:	f2 08 17 10 	movne	r8,r9
8000a114:	c1 68       	rjmp	8000a140 <_dtoa_r+0xe8>
8000a116:	fa ea 00 08 	ld.d	r10,sp[8]
8000a11a:	30 08       	mov	r8,0
8000a11c:	fa eb 00 3c 	st.d	sp[60],r10
8000a120:	30 09       	mov	r9,0
8000a122:	e0 a0 10 ce 	rcall	8000c2be <__avr32_f64_cmp_eq>
8000a126:	c1 00       	breq	8000a146 <_dtoa_r+0xee>
8000a128:	30 18       	mov	r8,1
8000a12a:	41 5a       	lddsp	r10,sp[0x54]
8000a12c:	95 08       	st.w	r10[0x0],r8
8000a12e:	fe cc c4 8e 	sub	r12,pc,-15218
8000a132:	41 29       	lddsp	r9,sp[0x48]
8000a134:	f8 08 00 08 	add	r8,r12,r8
8000a138:	58 09       	cp.w	r9,0
8000a13a:	e0 80 05 7a 	breq	8000ac2e <_dtoa_r+0xbd6>
8000a13e:	12 95       	mov	r5,r9
8000a140:	8b 08       	st.w	r5[0x0],r8
8000a142:	e0 8f 05 76 	bral	8000ac2e <_dtoa_r+0xbd6>
8000a146:	fa c8 ff 9c 	sub	r8,sp,-100
8000a14a:	fa c9 ff a0 	sub	r9,sp,-96
8000a14e:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a152:	0e 9c       	mov	r12,r7
8000a154:	eb d6 c2 8b 	bfextu	r5,r6,0x14,0xb
8000a158:	e0 a0 0a 8a 	rcall	8000b66c <__d2b>
8000a15c:	18 93       	mov	r3,r12
8000a15e:	58 05       	cp.w	r5,0
8000a160:	c0 d0       	breq	8000a17a <_dtoa_r+0x122>
8000a162:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a166:	30 04       	mov	r4,0
8000a168:	f1 db c0 14 	bfextu	r8,r11,0x0,0x14
8000a16c:	ea c5 03 ff 	sub	r5,r5,1023
8000a170:	10 9b       	mov	r11,r8
8000a172:	51 74       	stdsp	sp[0x5c],r4
8000a174:	ea 1b 3f f0 	orh	r11,0x3ff0
8000a178:	c2 58       	rjmp	8000a1c2 <_dtoa_r+0x16a>
8000a17a:	41 88       	lddsp	r8,sp[0x60]
8000a17c:	41 9c       	lddsp	r12,sp[0x64]
8000a17e:	10 0c       	add	r12,r8
8000a180:	f8 c5 fb ce 	sub	r5,r12,-1074
8000a184:	e0 45 00 20 	cp.w	r5,32
8000a188:	e0 8a 00 0e 	brle	8000a1a4 <_dtoa_r+0x14c>
8000a18c:	f8 cc fb ee 	sub	r12,r12,-1042
8000a190:	40 3b       	lddsp	r11,sp[0xc]
8000a192:	ea 08 11 40 	rsub	r8,r5,64
8000a196:	f6 0c 0a 4c 	lsr	r12,r11,r12
8000a19a:	ec 08 09 46 	lsl	r6,r6,r8
8000a19e:	0c 4c       	or	r12,r6
8000a1a0:	c0 78       	rjmp	8000a1ae <_dtoa_r+0x156>
8000a1a2:	d7 03       	nop
8000a1a4:	ea 0c 11 20 	rsub	r12,r5,32
8000a1a8:	40 3a       	lddsp	r10,sp[0xc]
8000a1aa:	f4 0c 09 4c 	lsl	r12,r10,r12
8000a1ae:	e0 a0 10 14 	rcall	8000c1d6 <__avr32_u32_to_f64>
8000a1b2:	fc 18 fe 10 	movh	r8,0xfe10
8000a1b6:	30 19       	mov	r9,1
8000a1b8:	ea c5 04 33 	sub	r5,r5,1075
8000a1bc:	f0 0b 00 0b 	add	r11,r8,r11
8000a1c0:	51 79       	stdsp	sp[0x5c],r9
8000a1c2:	30 08       	mov	r8,0
8000a1c4:	fc 19 3f f8 	movh	r9,0x3ff8
8000a1c8:	e0 a0 0e 9c 	rcall	8000bf00 <__avr32_f64_sub>
8000a1cc:	e0 68 43 61 	mov	r8,17249
8000a1d0:	ea 18 63 6f 	orh	r8,0x636f
8000a1d4:	e0 69 87 a7 	mov	r9,34727
8000a1d8:	ea 19 3f d2 	orh	r9,0x3fd2
8000a1dc:	e0 a0 0d a6 	rcall	8000bd28 <__avr32_f64_mul>
8000a1e0:	e0 68 c8 b3 	mov	r8,51379
8000a1e4:	ea 18 8b 60 	orh	r8,0x8b60
8000a1e8:	e0 69 8a 28 	mov	r9,35368
8000a1ec:	ea 19 3f c6 	orh	r9,0x3fc6
8000a1f0:	e0 a0 0f 56 	rcall	8000c09c <__avr32_f64_add>
8000a1f4:	0a 9c       	mov	r12,r5
8000a1f6:	14 90       	mov	r0,r10
8000a1f8:	16 91       	mov	r1,r11
8000a1fa:	e0 a0 0f f2 	rcall	8000c1de <__avr32_s32_to_f64>
8000a1fe:	e0 68 79 fb 	mov	r8,31227
8000a202:	ea 18 50 9f 	orh	r8,0x509f
8000a206:	e0 69 44 13 	mov	r9,17427
8000a20a:	ea 19 3f d3 	orh	r9,0x3fd3
8000a20e:	e0 a0 0d 8d 	rcall	8000bd28 <__avr32_f64_mul>
8000a212:	14 98       	mov	r8,r10
8000a214:	16 99       	mov	r9,r11
8000a216:	00 9a       	mov	r10,r0
8000a218:	02 9b       	mov	r11,r1
8000a21a:	e0 a0 0f 41 	rcall	8000c09c <__avr32_f64_add>
8000a21e:	14 90       	mov	r0,r10
8000a220:	16 91       	mov	r1,r11
8000a222:	e0 a0 0f c7 	rcall	8000c1b0 <__avr32_f64_to_s32>
8000a226:	30 08       	mov	r8,0
8000a228:	18 96       	mov	r6,r12
8000a22a:	30 09       	mov	r9,0
8000a22c:	00 9a       	mov	r10,r0
8000a22e:	02 9b       	mov	r11,r1
8000a230:	e0 a0 10 8e 	rcall	8000c34c <__avr32_f64_cmp_lt>
8000a234:	c0 c0       	breq	8000a24c <_dtoa_r+0x1f4>
8000a236:	0c 9c       	mov	r12,r6
8000a238:	e0 a0 0f d3 	rcall	8000c1de <__avr32_s32_to_f64>
8000a23c:	14 98       	mov	r8,r10
8000a23e:	16 99       	mov	r9,r11
8000a240:	00 9a       	mov	r10,r0
8000a242:	02 9b       	mov	r11,r1
8000a244:	e0 a0 10 3d 	rcall	8000c2be <__avr32_f64_cmp_eq>
8000a248:	f7 b6 00 01 	subeq	r6,1
8000a24c:	59 66       	cp.w	r6,22
8000a24e:	e0 88 00 05 	brls	8000a258 <_dtoa_r+0x200>
8000a252:	30 18       	mov	r8,1
8000a254:	51 48       	stdsp	sp[0x50],r8
8000a256:	c1 38       	rjmp	8000a27c <_dtoa_r+0x224>
8000a258:	fe c8 c3 d4 	sub	r8,pc,-15404
8000a25c:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a260:	f0 06 02 38 	ld.d	r8,r8[r6<<0x3]
8000a264:	e0 a0 10 74 	rcall	8000c34c <__avr32_f64_cmp_lt>
8000a268:	f9 b4 00 00 	moveq	r4,0
8000a26c:	fb f4 0a 14 	st.weq	sp[0x50],r4
8000a270:	f7 b6 01 01 	subne	r6,1
8000a274:	f9 bc 01 00 	movne	r12,0
8000a278:	fb fc 1a 14 	st.wne	sp[0x50],r12
8000a27c:	41 90       	lddsp	r0,sp[0x64]
8000a27e:	20 10       	sub	r0,1
8000a280:	0a 10       	sub	r0,r5
8000a282:	c0 46       	brmi	8000a28a <_dtoa_r+0x232>
8000a284:	50 40       	stdsp	sp[0x10],r0
8000a286:	30 00       	mov	r0,0
8000a288:	c0 48       	rjmp	8000a290 <_dtoa_r+0x238>
8000a28a:	30 0b       	mov	r11,0
8000a28c:	5c 30       	neg	r0
8000a28e:	50 4b       	stdsp	sp[0x10],r11
8000a290:	ec 02 11 00 	rsub	r2,r6,0
8000a294:	58 06       	cp.w	r6,0
8000a296:	fb fa 40 04 	ld.wge	r10,sp[0x10]
8000a29a:	f5 d6 e4 0a 	addge	r10,r10,r6
8000a29e:	fb fa 4a 04 	st.wge	sp[0x10],r10
8000a2a2:	fb f6 4a 11 	st.wge	sp[0x44],r6
8000a2a6:	f9 b2 04 00 	movge	r2,0
8000a2aa:	e1 d6 e5 10 	sublt	r0,r0,r6
8000a2ae:	f9 b9 05 00 	movlt	r9,0
8000a2b2:	fb f9 5a 11 	st.wlt	sp[0x44],r9
8000a2b6:	40 c8       	lddsp	r8,sp[0x30]
8000a2b8:	58 98       	cp.w	r8,9
8000a2ba:	e0 8b 00 20 	brhi	8000a2fa <_dtoa_r+0x2a2>
8000a2be:	58 58       	cp.w	r8,5
8000a2c0:	f9 b4 0a 01 	movle	r4,1
8000a2c4:	fb f5 90 0c 	ld.wgt	r5,sp[0x30]
8000a2c8:	f7 b5 09 04 	subgt	r5,4
8000a2cc:	fb f5 9a 0c 	st.wgt	sp[0x30],r5
8000a2d0:	f9 b4 09 00 	movgt	r4,0
8000a2d4:	40 cc       	lddsp	r12,sp[0x30]
8000a2d6:	58 3c       	cp.w	r12,3
8000a2d8:	c2 d0       	breq	8000a332 <_dtoa_r+0x2da>
8000a2da:	e0 89 00 05 	brgt	8000a2e4 <_dtoa_r+0x28c>
8000a2de:	58 2c       	cp.w	r12,2
8000a2e0:	c1 01       	brne	8000a300 <_dtoa_r+0x2a8>
8000a2e2:	c1 88       	rjmp	8000a312 <_dtoa_r+0x2ba>
8000a2e4:	40 cb       	lddsp	r11,sp[0x30]
8000a2e6:	58 4b       	cp.w	r11,4
8000a2e8:	c0 60       	breq	8000a2f4 <_dtoa_r+0x29c>
8000a2ea:	58 5b       	cp.w	r11,5
8000a2ec:	c0 a1       	brne	8000a300 <_dtoa_r+0x2a8>
8000a2ee:	30 1a       	mov	r10,1
8000a2f0:	50 da       	stdsp	sp[0x34],r10
8000a2f2:	c2 28       	rjmp	8000a336 <_dtoa_r+0x2de>
8000a2f4:	30 19       	mov	r9,1
8000a2f6:	50 d9       	stdsp	sp[0x34],r9
8000a2f8:	c0 f8       	rjmp	8000a316 <_dtoa_r+0x2be>
8000a2fa:	30 08       	mov	r8,0
8000a2fc:	30 14       	mov	r4,1
8000a2fe:	50 c8       	stdsp	sp[0x30],r8
8000a300:	3f f5       	mov	r5,-1
8000a302:	30 1c       	mov	r12,1
8000a304:	30 0b       	mov	r11,0
8000a306:	50 95       	stdsp	sp[0x24],r5
8000a308:	50 dc       	stdsp	sp[0x34],r12
8000a30a:	0a 91       	mov	r1,r5
8000a30c:	31 28       	mov	r8,18
8000a30e:	50 eb       	stdsp	sp[0x38],r11
8000a310:	c2 08       	rjmp	8000a350 <_dtoa_r+0x2f8>
8000a312:	30 0a       	mov	r10,0
8000a314:	50 da       	stdsp	sp[0x34],r10
8000a316:	40 e9       	lddsp	r9,sp[0x38]
8000a318:	58 09       	cp.w	r9,0
8000a31a:	e0 89 00 07 	brgt	8000a328 <_dtoa_r+0x2d0>
8000a31e:	30 18       	mov	r8,1
8000a320:	50 98       	stdsp	sp[0x24],r8
8000a322:	10 91       	mov	r1,r8
8000a324:	50 e8       	stdsp	sp[0x38],r8
8000a326:	c1 58       	rjmp	8000a350 <_dtoa_r+0x2f8>
8000a328:	40 e5       	lddsp	r5,sp[0x38]
8000a32a:	50 95       	stdsp	sp[0x24],r5
8000a32c:	0a 91       	mov	r1,r5
8000a32e:	0a 98       	mov	r8,r5
8000a330:	c1 08       	rjmp	8000a350 <_dtoa_r+0x2f8>
8000a332:	30 0c       	mov	r12,0
8000a334:	50 dc       	stdsp	sp[0x34],r12
8000a336:	40 eb       	lddsp	r11,sp[0x38]
8000a338:	ec 0b 00 0b 	add	r11,r6,r11
8000a33c:	50 9b       	stdsp	sp[0x24],r11
8000a33e:	16 98       	mov	r8,r11
8000a340:	2f f8       	sub	r8,-1
8000a342:	58 08       	cp.w	r8,0
8000a344:	e0 89 00 05 	brgt	8000a34e <_dtoa_r+0x2f6>
8000a348:	10 91       	mov	r1,r8
8000a34a:	30 18       	mov	r8,1
8000a34c:	c0 28       	rjmp	8000a350 <_dtoa_r+0x2f8>
8000a34e:	10 91       	mov	r1,r8
8000a350:	30 09       	mov	r9,0
8000a352:	6e 9a       	ld.w	r10,r7[0x24]
8000a354:	95 19       	st.w	r10[0x4],r9
8000a356:	30 49       	mov	r9,4
8000a358:	c0 68       	rjmp	8000a364 <_dtoa_r+0x30c>
8000a35a:	d7 03       	nop
8000a35c:	6a 1a       	ld.w	r10,r5[0x4]
8000a35e:	a1 79       	lsl	r9,0x1
8000a360:	2f fa       	sub	r10,-1
8000a362:	8b 1a       	st.w	r5[0x4],r10
8000a364:	6e 95       	ld.w	r5,r7[0x24]
8000a366:	f2 ca ff ec 	sub	r10,r9,-20
8000a36a:	10 3a       	cp.w	r10,r8
8000a36c:	fe 98 ff f8 	brls	8000a35c <_dtoa_r+0x304>
8000a370:	6a 1b       	ld.w	r11,r5[0x4]
8000a372:	0e 9c       	mov	r12,r7
8000a374:	e0 a0 09 44 	rcall	8000b5fc <_Balloc>
8000a378:	58 e1       	cp.w	r1,14
8000a37a:	5f 88       	srls	r8
8000a37c:	8b 0c       	st.w	r5[0x0],r12
8000a37e:	f1 e4 00 04 	and	r4,r8,r4
8000a382:	6e 98       	ld.w	r8,r7[0x24]
8000a384:	70 08       	ld.w	r8,r8[0x0]
8000a386:	50 88       	stdsp	sp[0x20],r8
8000a388:	e0 80 01 82 	breq	8000a68c <_dtoa_r+0x634>
8000a38c:	58 06       	cp.w	r6,0
8000a38e:	e0 8a 00 43 	brle	8000a414 <_dtoa_r+0x3bc>
8000a392:	f3 d6 c0 04 	bfextu	r9,r6,0x0,0x4
8000a396:	fe c8 c5 12 	sub	r8,pc,-15086
8000a39a:	f0 09 02 34 	ld.d	r4,r8[r9<<0x3]
8000a39e:	fa e5 00 18 	st.d	sp[24],r4
8000a3a2:	ec 04 14 04 	asr	r4,r6,0x4
8000a3a6:	ed b4 00 04 	bld	r4,0x4
8000a3aa:	c0 30       	breq	8000a3b0 <_dtoa_r+0x358>
8000a3ac:	30 25       	mov	r5,2
8000a3ae:	c1 08       	rjmp	8000a3ce <_dtoa_r+0x376>
8000a3b0:	fe c8 c4 64 	sub	r8,pc,-15260
8000a3b4:	f0 e8 00 20 	ld.d	r8,r8[32]
8000a3b8:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a3bc:	e9 d4 c0 04 	bfextu	r4,r4,0x0,0x4
8000a3c0:	e0 a0 0f fa 	rcall	8000c3b4 <__avr32_f64_div>
8000a3c4:	30 35       	mov	r5,3
8000a3c6:	14 98       	mov	r8,r10
8000a3c8:	16 99       	mov	r9,r11
8000a3ca:	fa e9 00 08 	st.d	sp[8],r8
8000a3ce:	fe cc c4 82 	sub	r12,pc,-15230
8000a3d2:	50 a3       	stdsp	sp[0x28],r3
8000a3d4:	0c 93       	mov	r3,r6
8000a3d6:	18 96       	mov	r6,r12
8000a3d8:	c0 f8       	rjmp	8000a3f6 <_dtoa_r+0x39e>
8000a3da:	fa ea 00 18 	ld.d	r10,sp[24]
8000a3de:	ed b4 00 00 	bld	r4,0x0
8000a3e2:	c0 81       	brne	8000a3f2 <_dtoa_r+0x39a>
8000a3e4:	ec e8 00 00 	ld.d	r8,r6[0]
8000a3e8:	2f f5       	sub	r5,-1
8000a3ea:	e0 a0 0c 9f 	rcall	8000bd28 <__avr32_f64_mul>
8000a3ee:	fa eb 00 18 	st.d	sp[24],r10
8000a3f2:	a1 54       	asr	r4,0x1
8000a3f4:	2f 86       	sub	r6,-8
8000a3f6:	58 04       	cp.w	r4,0
8000a3f8:	cf 11       	brne	8000a3da <_dtoa_r+0x382>
8000a3fa:	fa e8 00 18 	ld.d	r8,sp[24]
8000a3fe:	fa ea 00 08 	ld.d	r10,sp[8]
8000a402:	06 96       	mov	r6,r3
8000a404:	e0 a0 0f d8 	rcall	8000c3b4 <__avr32_f64_div>
8000a408:	40 a3       	lddsp	r3,sp[0x28]
8000a40a:	14 98       	mov	r8,r10
8000a40c:	16 99       	mov	r9,r11
8000a40e:	fa e9 00 08 	st.d	sp[8],r8
8000a412:	c2 f8       	rjmp	8000a470 <_dtoa_r+0x418>
8000a414:	ec 08 11 00 	rsub	r8,r6,0
8000a418:	c0 31       	brne	8000a41e <_dtoa_r+0x3c6>
8000a41a:	30 25       	mov	r5,2
8000a41c:	c2 a8       	rjmp	8000a470 <_dtoa_r+0x418>
8000a41e:	fe cc c4 d2 	sub	r12,pc,-15150
8000a422:	f0 04 14 04 	asr	r4,r8,0x4
8000a426:	50 1c       	stdsp	sp[0x4],r12
8000a428:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
8000a42c:	fe c9 c5 a8 	sub	r9,pc,-14936
8000a430:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a434:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000a438:	e0 a0 0c 78 	rcall	8000bd28 <__avr32_f64_mul>
8000a43c:	40 1c       	lddsp	r12,sp[0x4]
8000a43e:	50 63       	stdsp	sp[0x18],r3
8000a440:	30 25       	mov	r5,2
8000a442:	0c 93       	mov	r3,r6
8000a444:	fa eb 00 08 	st.d	sp[8],r10
8000a448:	18 96       	mov	r6,r12
8000a44a:	c0 f8       	rjmp	8000a468 <_dtoa_r+0x410>
8000a44c:	fa ea 00 08 	ld.d	r10,sp[8]
8000a450:	ed b4 00 00 	bld	r4,0x0
8000a454:	c0 81       	brne	8000a464 <_dtoa_r+0x40c>
8000a456:	ec e8 00 00 	ld.d	r8,r6[0]
8000a45a:	2f f5       	sub	r5,-1
8000a45c:	e0 a0 0c 66 	rcall	8000bd28 <__avr32_f64_mul>
8000a460:	fa eb 00 08 	st.d	sp[8],r10
8000a464:	a1 54       	asr	r4,0x1
8000a466:	2f 86       	sub	r6,-8
8000a468:	58 04       	cp.w	r4,0
8000a46a:	cf 11       	brne	8000a44c <_dtoa_r+0x3f4>
8000a46c:	06 96       	mov	r6,r3
8000a46e:	40 63       	lddsp	r3,sp[0x18]
8000a470:	41 4a       	lddsp	r10,sp[0x50]
8000a472:	58 0a       	cp.w	r10,0
8000a474:	c2 a0       	breq	8000a4c8 <_dtoa_r+0x470>
8000a476:	fa e8 00 08 	ld.d	r8,sp[8]
8000a47a:	58 01       	cp.w	r1,0
8000a47c:	5f 94       	srgt	r4
8000a47e:	fa e9 00 18 	st.d	sp[24],r8
8000a482:	30 08       	mov	r8,0
8000a484:	fc 19 3f f0 	movh	r9,0x3ff0
8000a488:	fa ea 00 18 	ld.d	r10,sp[24]
8000a48c:	e0 a0 0f 60 	rcall	8000c34c <__avr32_f64_cmp_lt>
8000a490:	f9 bc 00 00 	moveq	r12,0
8000a494:	f9 bc 01 01 	movne	r12,1
8000a498:	e9 ec 00 0c 	and	r12,r4,r12
8000a49c:	c1 60       	breq	8000a4c8 <_dtoa_r+0x470>
8000a49e:	40 98       	lddsp	r8,sp[0x24]
8000a4a0:	58 08       	cp.w	r8,0
8000a4a2:	e0 8a 00 f1 	brle	8000a684 <_dtoa_r+0x62c>
8000a4a6:	30 08       	mov	r8,0
8000a4a8:	fc 19 40 24 	movh	r9,0x4024
8000a4ac:	ec c4 00 01 	sub	r4,r6,1
8000a4b0:	fa ea 00 18 	ld.d	r10,sp[24]
8000a4b4:	2f f5       	sub	r5,-1
8000a4b6:	50 64       	stdsp	sp[0x18],r4
8000a4b8:	e0 a0 0c 38 	rcall	8000bd28 <__avr32_f64_mul>
8000a4bc:	40 94       	lddsp	r4,sp[0x24]
8000a4be:	14 98       	mov	r8,r10
8000a4c0:	16 99       	mov	r9,r11
8000a4c2:	fa e9 00 08 	st.d	sp[8],r8
8000a4c6:	c0 38       	rjmp	8000a4cc <_dtoa_r+0x474>
8000a4c8:	50 66       	stdsp	sp[0x18],r6
8000a4ca:	02 94       	mov	r4,r1
8000a4cc:	0a 9c       	mov	r12,r5
8000a4ce:	e0 a0 0e 88 	rcall	8000c1de <__avr32_s32_to_f64>
8000a4d2:	fa e8 00 08 	ld.d	r8,sp[8]
8000a4d6:	e0 a0 0c 29 	rcall	8000bd28 <__avr32_f64_mul>
8000a4da:	30 08       	mov	r8,0
8000a4dc:	fc 19 40 1c 	movh	r9,0x401c
8000a4e0:	e0 a0 0d de 	rcall	8000c09c <__avr32_f64_add>
8000a4e4:	14 98       	mov	r8,r10
8000a4e6:	16 99       	mov	r9,r11
8000a4e8:	fa e9 00 28 	st.d	sp[40],r8
8000a4ec:	fc 18 fc c0 	movh	r8,0xfcc0
8000a4f0:	40 a5       	lddsp	r5,sp[0x28]
8000a4f2:	10 05       	add	r5,r8
8000a4f4:	50 a5       	stdsp	sp[0x28],r5
8000a4f6:	58 04       	cp.w	r4,0
8000a4f8:	c2 11       	brne	8000a53a <_dtoa_r+0x4e2>
8000a4fa:	fa ea 00 08 	ld.d	r10,sp[8]
8000a4fe:	30 08       	mov	r8,0
8000a500:	fc 19 40 14 	movh	r9,0x4014
8000a504:	e0 a0 0c fe 	rcall	8000bf00 <__avr32_f64_sub>
8000a508:	40 bc       	lddsp	r12,sp[0x2c]
8000a50a:	fa eb 00 08 	st.d	sp[8],r10
8000a50e:	14 98       	mov	r8,r10
8000a510:	16 99       	mov	r9,r11
8000a512:	18 9a       	mov	r10,r12
8000a514:	0a 9b       	mov	r11,r5
8000a516:	e0 a0 0f 1b 	rcall	8000c34c <__avr32_f64_cmp_lt>
8000a51a:	e0 81 02 54 	brne	8000a9c2 <_dtoa_r+0x96a>
8000a51e:	0a 98       	mov	r8,r5
8000a520:	40 b9       	lddsp	r9,sp[0x2c]
8000a522:	ee 18 80 00 	eorh	r8,0x8000
8000a526:	fa ea 00 08 	ld.d	r10,sp[8]
8000a52a:	10 95       	mov	r5,r8
8000a52c:	12 98       	mov	r8,r9
8000a52e:	0a 99       	mov	r9,r5
8000a530:	e0 a0 0f 0e 	rcall	8000c34c <__avr32_f64_cmp_lt>
8000a534:	e0 81 02 3e 	brne	8000a9b0 <_dtoa_r+0x958>
8000a538:	ca 68       	rjmp	8000a684 <_dtoa_r+0x62c>
8000a53a:	fe c9 c6 b6 	sub	r9,pc,-14666
8000a53e:	e8 c8 00 01 	sub	r8,r4,1
8000a542:	40 d5       	lddsp	r5,sp[0x34]
8000a544:	58 05       	cp.w	r5,0
8000a546:	c4 f0       	breq	8000a5e4 <_dtoa_r+0x58c>
8000a548:	30 0c       	mov	r12,0
8000a54a:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000a54e:	51 3c       	stdsp	sp[0x4c],r12
8000a550:	30 0a       	mov	r10,0
8000a552:	fc 1b 3f e0 	movh	r11,0x3fe0
8000a556:	e0 a0 0f 2f 	rcall	8000c3b4 <__avr32_f64_div>
8000a55a:	fa e8 00 28 	ld.d	r8,sp[40]
8000a55e:	40 85       	lddsp	r5,sp[0x20]
8000a560:	e0 a0 0c d0 	rcall	8000bf00 <__avr32_f64_sub>
8000a564:	fa eb 00 28 	st.d	sp[40],r10
8000a568:	fa ea 00 08 	ld.d	r10,sp[8]
8000a56c:	e0 a0 0e 22 	rcall	8000c1b0 <__avr32_f64_to_s32>
8000a570:	51 6c       	stdsp	sp[0x58],r12
8000a572:	e0 a0 0e 36 	rcall	8000c1de <__avr32_s32_to_f64>
8000a576:	14 98       	mov	r8,r10
8000a578:	16 99       	mov	r9,r11
8000a57a:	fa ea 00 08 	ld.d	r10,sp[8]
8000a57e:	e0 a0 0c c1 	rcall	8000bf00 <__avr32_f64_sub>
8000a582:	fa eb 00 08 	st.d	sp[8],r10
8000a586:	41 68       	lddsp	r8,sp[0x58]
8000a588:	2d 08       	sub	r8,-48
8000a58a:	0a c8       	st.b	r5++,r8
8000a58c:	41 39       	lddsp	r9,sp[0x4c]
8000a58e:	2f f9       	sub	r9,-1
8000a590:	51 39       	stdsp	sp[0x4c],r9
8000a592:	fa e8 00 28 	ld.d	r8,sp[40]
8000a596:	e0 a0 0e db 	rcall	8000c34c <__avr32_f64_cmp_lt>
8000a59a:	e0 81 03 39 	brne	8000ac0c <_dtoa_r+0xbb4>
8000a59e:	fa e8 00 08 	ld.d	r8,sp[8]
8000a5a2:	30 0a       	mov	r10,0
8000a5a4:	fc 1b 3f f0 	movh	r11,0x3ff0
8000a5a8:	e0 a0 0c ac 	rcall	8000bf00 <__avr32_f64_sub>
8000a5ac:	fa e8 00 28 	ld.d	r8,sp[40]
8000a5b0:	e0 a0 0e ce 	rcall	8000c34c <__avr32_f64_cmp_lt>
8000a5b4:	fa ea 00 28 	ld.d	r10,sp[40]
8000a5b8:	30 08       	mov	r8,0
8000a5ba:	fc 19 40 24 	movh	r9,0x4024
8000a5be:	e0 81 00 da 	brne	8000a772 <_dtoa_r+0x71a>
8000a5c2:	41 3c       	lddsp	r12,sp[0x4c]
8000a5c4:	08 3c       	cp.w	r12,r4
8000a5c6:	c5 f4       	brge	8000a684 <_dtoa_r+0x62c>
8000a5c8:	e0 a0 0b b0 	rcall	8000bd28 <__avr32_f64_mul>
8000a5cc:	30 08       	mov	r8,0
8000a5ce:	fa eb 00 28 	st.d	sp[40],r10
8000a5d2:	fc 19 40 24 	movh	r9,0x4024
8000a5d6:	fa ea 00 08 	ld.d	r10,sp[8]
8000a5da:	e0 a0 0b a7 	rcall	8000bd28 <__avr32_f64_mul>
8000a5de:	fa eb 00 08 	st.d	sp[8],r10
8000a5e2:	cc 3b       	rjmp	8000a568 <_dtoa_r+0x510>
8000a5e4:	40 85       	lddsp	r5,sp[0x20]
8000a5e6:	08 05       	add	r5,r4
8000a5e8:	f2 08 02 3a 	ld.d	r10,r9[r8<<0x3]
8000a5ec:	51 35       	stdsp	sp[0x4c],r5
8000a5ee:	fa e8 00 28 	ld.d	r8,sp[40]
8000a5f2:	40 85       	lddsp	r5,sp[0x20]
8000a5f4:	e0 a0 0b 9a 	rcall	8000bd28 <__avr32_f64_mul>
8000a5f8:	fa eb 00 28 	st.d	sp[40],r10
8000a5fc:	fa ea 00 08 	ld.d	r10,sp[8]
8000a600:	e0 a0 0d d8 	rcall	8000c1b0 <__avr32_f64_to_s32>
8000a604:	51 6c       	stdsp	sp[0x58],r12
8000a606:	e0 a0 0d ec 	rcall	8000c1de <__avr32_s32_to_f64>
8000a60a:	14 98       	mov	r8,r10
8000a60c:	16 99       	mov	r9,r11
8000a60e:	fa ea 00 08 	ld.d	r10,sp[8]
8000a612:	e0 a0 0c 77 	rcall	8000bf00 <__avr32_f64_sub>
8000a616:	fa eb 00 08 	st.d	sp[8],r10
8000a61a:	41 68       	lddsp	r8,sp[0x58]
8000a61c:	2d 08       	sub	r8,-48
8000a61e:	0a c8       	st.b	r5++,r8
8000a620:	41 3c       	lddsp	r12,sp[0x4c]
8000a622:	18 35       	cp.w	r5,r12
8000a624:	c2 81       	brne	8000a674 <_dtoa_r+0x61c>
8000a626:	30 08       	mov	r8,0
8000a628:	fc 19 3f e0 	movh	r9,0x3fe0
8000a62c:	fa ea 00 28 	ld.d	r10,sp[40]
8000a630:	e0 a0 0d 36 	rcall	8000c09c <__avr32_f64_add>
8000a634:	40 85       	lddsp	r5,sp[0x20]
8000a636:	fa e8 00 08 	ld.d	r8,sp[8]
8000a63a:	08 05       	add	r5,r4
8000a63c:	e0 a0 0e 88 	rcall	8000c34c <__avr32_f64_cmp_lt>
8000a640:	e0 81 00 99 	brne	8000a772 <_dtoa_r+0x71a>
8000a644:	fa e8 00 28 	ld.d	r8,sp[40]
8000a648:	30 0a       	mov	r10,0
8000a64a:	fc 1b 3f e0 	movh	r11,0x3fe0
8000a64e:	e0 a0 0c 59 	rcall	8000bf00 <__avr32_f64_sub>
8000a652:	14 98       	mov	r8,r10
8000a654:	16 99       	mov	r9,r11
8000a656:	fa ea 00 08 	ld.d	r10,sp[8]
8000a65a:	e0 a0 0e 79 	rcall	8000c34c <__avr32_f64_cmp_lt>
8000a65e:	c1 30       	breq	8000a684 <_dtoa_r+0x62c>
8000a660:	33 09       	mov	r9,48
8000a662:	0a 98       	mov	r8,r5
8000a664:	11 7a       	ld.ub	r10,--r8
8000a666:	f2 0a 18 00 	cp.b	r10,r9
8000a66a:	e0 81 02 d1 	brne	8000ac0c <_dtoa_r+0xbb4>
8000a66e:	10 95       	mov	r5,r8
8000a670:	cf 9b       	rjmp	8000a662 <_dtoa_r+0x60a>
8000a672:	d7 03       	nop
8000a674:	30 08       	mov	r8,0
8000a676:	fc 19 40 24 	movh	r9,0x4024
8000a67a:	e0 a0 0b 57 	rcall	8000bd28 <__avr32_f64_mul>
8000a67e:	fa eb 00 08 	st.d	sp[8],r10
8000a682:	cb db       	rjmp	8000a5fc <_dtoa_r+0x5a4>
8000a684:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a688:	fa eb 00 08 	st.d	sp[8],r10
8000a68c:	58 e6       	cp.w	r6,14
8000a68e:	5f ab       	srle	r11
8000a690:	41 8a       	lddsp	r10,sp[0x60]
8000a692:	30 08       	mov	r8,0
8000a694:	f4 09 11 ff 	rsub	r9,r10,-1
8000a698:	f7 e9 03 f9 	and	r9,r11,r9>>0x1f
8000a69c:	f0 09 18 00 	cp.b	r9,r8
8000a6a0:	e0 80 00 82 	breq	8000a7a4 <_dtoa_r+0x74c>
8000a6a4:	40 ea       	lddsp	r10,sp[0x38]
8000a6a6:	58 01       	cp.w	r1,0
8000a6a8:	5f a9       	srle	r9
8000a6aa:	f3 ea 03 f9 	and	r9,r9,r10>>0x1f
8000a6ae:	fe ca c8 2a 	sub	r10,pc,-14294
8000a6b2:	f4 06 02 34 	ld.d	r4,r10[r6<<0x3]
8000a6b6:	fa e5 00 10 	st.d	sp[16],r4
8000a6ba:	f0 09 18 00 	cp.b	r9,r8
8000a6be:	c1 40       	breq	8000a6e6 <_dtoa_r+0x68e>
8000a6c0:	58 01       	cp.w	r1,0
8000a6c2:	e0 81 01 77 	brne	8000a9b0 <_dtoa_r+0x958>
8000a6c6:	30 08       	mov	r8,0
8000a6c8:	fc 19 40 14 	movh	r9,0x4014
8000a6cc:	08 9a       	mov	r10,r4
8000a6ce:	0a 9b       	mov	r11,r5
8000a6d0:	e0 a0 0b 2c 	rcall	8000bd28 <__avr32_f64_mul>
8000a6d4:	fa e8 00 08 	ld.d	r8,sp[8]
8000a6d8:	e0 a0 0e 06 	rcall	8000c2e4 <__avr32_f64_cmp_ge>
8000a6dc:	e0 81 01 6a 	brne	8000a9b0 <_dtoa_r+0x958>
8000a6e0:	02 92       	mov	r2,r1
8000a6e2:	e0 8f 01 72 	bral	8000a9c6 <_dtoa_r+0x96e>
8000a6e6:	40 85       	lddsp	r5,sp[0x20]
8000a6e8:	30 14       	mov	r4,1
8000a6ea:	fa e8 00 10 	ld.d	r8,sp[16]
8000a6ee:	fa ea 00 08 	ld.d	r10,sp[8]
8000a6f2:	e0 a0 0e 61 	rcall	8000c3b4 <__avr32_f64_div>
8000a6f6:	e0 a0 0d 5d 	rcall	8000c1b0 <__avr32_f64_to_s32>
8000a6fa:	18 92       	mov	r2,r12
8000a6fc:	e0 a0 0d 71 	rcall	8000c1de <__avr32_s32_to_f64>
8000a700:	fa e8 00 10 	ld.d	r8,sp[16]
8000a704:	e0 a0 0b 12 	rcall	8000bd28 <__avr32_f64_mul>
8000a708:	14 98       	mov	r8,r10
8000a70a:	16 99       	mov	r9,r11
8000a70c:	fa ea 00 08 	ld.d	r10,sp[8]
8000a710:	e0 a0 0b f8 	rcall	8000bf00 <__avr32_f64_sub>
8000a714:	fa eb 00 08 	st.d	sp[8],r10
8000a718:	e4 c8 ff d0 	sub	r8,r2,-48
8000a71c:	0a c8       	st.b	r5++,r8
8000a71e:	fc 19 40 24 	movh	r9,0x4024
8000a722:	30 08       	mov	r8,0
8000a724:	02 34       	cp.w	r4,r1
8000a726:	c3 31       	brne	8000a78c <_dtoa_r+0x734>
8000a728:	fa e8 00 08 	ld.d	r8,sp[8]
8000a72c:	e0 a0 0c b8 	rcall	8000c09c <__avr32_f64_add>
8000a730:	16 91       	mov	r1,r11
8000a732:	14 90       	mov	r0,r10
8000a734:	14 98       	mov	r8,r10
8000a736:	02 99       	mov	r9,r1
8000a738:	fa ea 00 10 	ld.d	r10,sp[16]
8000a73c:	e0 a0 0e 08 	rcall	8000c34c <__avr32_f64_cmp_lt>
8000a740:	c1 a1       	brne	8000a774 <_dtoa_r+0x71c>
8000a742:	fa e8 00 10 	ld.d	r8,sp[16]
8000a746:	00 9a       	mov	r10,r0
8000a748:	02 9b       	mov	r11,r1
8000a74a:	e0 a0 0d ba 	rcall	8000c2be <__avr32_f64_cmp_eq>
8000a74e:	e0 80 02 5e 	breq	8000ac0a <_dtoa_r+0xbb2>
8000a752:	e5 d2 c0 01 	bfextu	r2,r2,0x0,0x1
8000a756:	c0 f1       	brne	8000a774 <_dtoa_r+0x71c>
8000a758:	e0 8f 02 59 	bral	8000ac0a <_dtoa_r+0xbb2>
8000a75c:	40 8a       	lddsp	r10,sp[0x20]
8000a75e:	14 38       	cp.w	r8,r10
8000a760:	c0 30       	breq	8000a766 <_dtoa_r+0x70e>
8000a762:	10 95       	mov	r5,r8
8000a764:	c0 98       	rjmp	8000a776 <_dtoa_r+0x71e>
8000a766:	33 08       	mov	r8,48
8000a768:	40 89       	lddsp	r9,sp[0x20]
8000a76a:	2f f6       	sub	r6,-1
8000a76c:	b2 88       	st.b	r9[0x0],r8
8000a76e:	40 88       	lddsp	r8,sp[0x20]
8000a770:	c0 88       	rjmp	8000a780 <_dtoa_r+0x728>
8000a772:	40 66       	lddsp	r6,sp[0x18]
8000a774:	33 99       	mov	r9,57
8000a776:	0a 98       	mov	r8,r5
8000a778:	11 7a       	ld.ub	r10,--r8
8000a77a:	f2 0a 18 00 	cp.b	r10,r9
8000a77e:	ce f0       	breq	8000a75c <_dtoa_r+0x704>
8000a780:	50 66       	stdsp	sp[0x18],r6
8000a782:	11 89       	ld.ub	r9,r8[0x0]
8000a784:	2f f9       	sub	r9,-1
8000a786:	b0 89       	st.b	r8[0x0],r9
8000a788:	e0 8f 02 42 	bral	8000ac0c <_dtoa_r+0xbb4>
8000a78c:	e0 a0 0a ce 	rcall	8000bd28 <__avr32_f64_mul>
8000a790:	2f f4       	sub	r4,-1
8000a792:	fa eb 00 08 	st.d	sp[8],r10
8000a796:	30 08       	mov	r8,0
8000a798:	30 09       	mov	r9,0
8000a79a:	e0 a0 0d 92 	rcall	8000c2be <__avr32_f64_cmp_eq>
8000a79e:	ca 60       	breq	8000a6ea <_dtoa_r+0x692>
8000a7a0:	e0 8f 02 35 	bral	8000ac0a <_dtoa_r+0xbb2>
8000a7a4:	40 d8       	lddsp	r8,sp[0x34]
8000a7a6:	58 08       	cp.w	r8,0
8000a7a8:	c0 51       	brne	8000a7b2 <_dtoa_r+0x75a>
8000a7aa:	04 98       	mov	r8,r2
8000a7ac:	00 95       	mov	r5,r0
8000a7ae:	40 d4       	lddsp	r4,sp[0x34]
8000a7b0:	c3 78       	rjmp	8000a81e <_dtoa_r+0x7c6>
8000a7b2:	40 c5       	lddsp	r5,sp[0x30]
8000a7b4:	58 15       	cp.w	r5,1
8000a7b6:	e0 89 00 0f 	brgt	8000a7d4 <_dtoa_r+0x77c>
8000a7ba:	41 74       	lddsp	r4,sp[0x5c]
8000a7bc:	58 04       	cp.w	r4,0
8000a7be:	c0 40       	breq	8000a7c6 <_dtoa_r+0x76e>
8000a7c0:	f4 c9 fb cd 	sub	r9,r10,-1075
8000a7c4:	c0 48       	rjmp	8000a7cc <_dtoa_r+0x774>
8000a7c6:	41 99       	lddsp	r9,sp[0x64]
8000a7c8:	f2 09 11 36 	rsub	r9,r9,54
8000a7cc:	04 98       	mov	r8,r2
8000a7ce:	00 95       	mov	r5,r0
8000a7d0:	c1 c8       	rjmp	8000a808 <_dtoa_r+0x7b0>
8000a7d2:	d7 03       	nop
8000a7d4:	e2 c8 00 01 	sub	r8,r1,1
8000a7d8:	58 01       	cp.w	r1,0
8000a7da:	e0 05 17 40 	movge	r5,r0
8000a7de:	e2 09 17 40 	movge	r9,r1
8000a7e2:	e1 d1 e5 15 	sublt	r5,r0,r1
8000a7e6:	f9 b9 05 00 	movlt	r9,0
8000a7ea:	10 32       	cp.w	r2,r8
8000a7ec:	e5 d8 e4 18 	subge	r8,r2,r8
8000a7f0:	f1 d2 e5 18 	sublt	r8,r8,r2
8000a7f4:	e5 d8 e5 02 	addlt	r2,r2,r8
8000a7f8:	fb fc 50 11 	ld.wlt	r12,sp[0x44]
8000a7fc:	f9 d8 e5 0c 	addlt	r12,r12,r8
8000a800:	fb fc 5a 11 	st.wlt	sp[0x44],r12
8000a804:	f9 b8 05 00 	movlt	r8,0
8000a808:	40 4b       	lddsp	r11,sp[0x10]
8000a80a:	12 0b       	add	r11,r9
8000a80c:	50 08       	stdsp	sp[0x0],r8
8000a80e:	50 4b       	stdsp	sp[0x10],r11
8000a810:	12 00       	add	r0,r9
8000a812:	30 1b       	mov	r11,1
8000a814:	0e 9c       	mov	r12,r7
8000a816:	e0 a0 08 a7 	rcall	8000b964 <__i2b>
8000a81a:	40 08       	lddsp	r8,sp[0x0]
8000a81c:	18 94       	mov	r4,r12
8000a81e:	40 4a       	lddsp	r10,sp[0x10]
8000a820:	58 05       	cp.w	r5,0
8000a822:	5f 99       	srgt	r9
8000a824:	58 0a       	cp.w	r10,0
8000a826:	5f 9a       	srgt	r10
8000a828:	f5 e9 00 09 	and	r9,r10,r9
8000a82c:	c0 80       	breq	8000a83c <_dtoa_r+0x7e4>
8000a82e:	40 4c       	lddsp	r12,sp[0x10]
8000a830:	f8 05 0d 49 	min	r9,r12,r5
8000a834:	12 1c       	sub	r12,r9
8000a836:	12 10       	sub	r0,r9
8000a838:	50 4c       	stdsp	sp[0x10],r12
8000a83a:	12 15       	sub	r5,r9
8000a83c:	58 02       	cp.w	r2,0
8000a83e:	e0 8a 00 27 	brle	8000a88c <_dtoa_r+0x834>
8000a842:	40 db       	lddsp	r11,sp[0x34]
8000a844:	58 0b       	cp.w	r11,0
8000a846:	c1 d0       	breq	8000a880 <_dtoa_r+0x828>
8000a848:	58 08       	cp.w	r8,0
8000a84a:	e0 8a 00 17 	brle	8000a878 <_dtoa_r+0x820>
8000a84e:	10 9a       	mov	r10,r8
8000a850:	50 08       	stdsp	sp[0x0],r8
8000a852:	08 9b       	mov	r11,r4
8000a854:	0e 9c       	mov	r12,r7
8000a856:	e0 a0 08 cd 	rcall	8000b9f0 <__pow5mult>
8000a85a:	06 9a       	mov	r10,r3
8000a85c:	18 9b       	mov	r11,r12
8000a85e:	18 94       	mov	r4,r12
8000a860:	0e 9c       	mov	r12,r7
8000a862:	e0 a0 08 01 	rcall	8000b864 <__multiply>
8000a866:	18 99       	mov	r9,r12
8000a868:	06 9b       	mov	r11,r3
8000a86a:	50 19       	stdsp	sp[0x4],r9
8000a86c:	0e 9c       	mov	r12,r7
8000a86e:	e0 a0 06 ad 	rcall	8000b5c8 <_Bfree>
8000a872:	40 19       	lddsp	r9,sp[0x4]
8000a874:	40 08       	lddsp	r8,sp[0x0]
8000a876:	12 93       	mov	r3,r9
8000a878:	e4 08 01 0a 	sub	r10,r2,r8
8000a87c:	c0 80       	breq	8000a88c <_dtoa_r+0x834>
8000a87e:	c0 28       	rjmp	8000a882 <_dtoa_r+0x82a>
8000a880:	04 9a       	mov	r10,r2
8000a882:	06 9b       	mov	r11,r3
8000a884:	0e 9c       	mov	r12,r7
8000a886:	e0 a0 08 b5 	rcall	8000b9f0 <__pow5mult>
8000a88a:	18 93       	mov	r3,r12
8000a88c:	30 1b       	mov	r11,1
8000a88e:	0e 9c       	mov	r12,r7
8000a890:	e0 a0 08 6a 	rcall	8000b964 <__i2b>
8000a894:	41 1a       	lddsp	r10,sp[0x44]
8000a896:	18 92       	mov	r2,r12
8000a898:	58 0a       	cp.w	r10,0
8000a89a:	e0 8a 00 07 	brle	8000a8a8 <_dtoa_r+0x850>
8000a89e:	18 9b       	mov	r11,r12
8000a8a0:	0e 9c       	mov	r12,r7
8000a8a2:	e0 a0 08 a7 	rcall	8000b9f0 <__pow5mult>
8000a8a6:	18 92       	mov	r2,r12
8000a8a8:	40 c9       	lddsp	r9,sp[0x30]
8000a8aa:	58 19       	cp.w	r9,1
8000a8ac:	e0 89 00 14 	brgt	8000a8d4 <_dtoa_r+0x87c>
8000a8b0:	40 38       	lddsp	r8,sp[0xc]
8000a8b2:	58 08       	cp.w	r8,0
8000a8b4:	c1 01       	brne	8000a8d4 <_dtoa_r+0x87c>
8000a8b6:	40 29       	lddsp	r9,sp[0x8]
8000a8b8:	f1 d9 c0 14 	bfextu	r8,r9,0x0,0x14
8000a8bc:	c0 c1       	brne	8000a8d4 <_dtoa_r+0x87c>
8000a8be:	12 98       	mov	r8,r9
8000a8c0:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000a8c4:	c0 80       	breq	8000a8d4 <_dtoa_r+0x87c>
8000a8c6:	40 4c       	lddsp	r12,sp[0x10]
8000a8c8:	30 1b       	mov	r11,1
8000a8ca:	2f fc       	sub	r12,-1
8000a8cc:	2f f0       	sub	r0,-1
8000a8ce:	50 4c       	stdsp	sp[0x10],r12
8000a8d0:	50 6b       	stdsp	sp[0x18],r11
8000a8d2:	c0 38       	rjmp	8000a8d8 <_dtoa_r+0x880>
8000a8d4:	30 0a       	mov	r10,0
8000a8d6:	50 6a       	stdsp	sp[0x18],r10
8000a8d8:	41 19       	lddsp	r9,sp[0x44]
8000a8da:	58 09       	cp.w	r9,0
8000a8dc:	c0 31       	brne	8000a8e2 <_dtoa_r+0x88a>
8000a8de:	30 1c       	mov	r12,1
8000a8e0:	c0 98       	rjmp	8000a8f2 <_dtoa_r+0x89a>
8000a8e2:	64 48       	ld.w	r8,r2[0x10]
8000a8e4:	2f c8       	sub	r8,-4
8000a8e6:	e4 08 03 2c 	ld.w	r12,r2[r8<<0x2]
8000a8ea:	e0 a0 05 df 	rcall	8000b4a8 <__hi0bits>
8000a8ee:	f8 0c 11 20 	rsub	r12,r12,32
8000a8f2:	40 4b       	lddsp	r11,sp[0x10]
8000a8f4:	f8 0b 00 08 	add	r8,r12,r11
8000a8f8:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000a8fc:	c0 c0       	breq	8000a914 <_dtoa_r+0x8bc>
8000a8fe:	f0 08 11 20 	rsub	r8,r8,32
8000a902:	58 48       	cp.w	r8,4
8000a904:	e0 8a 00 06 	brle	8000a910 <_dtoa_r+0x8b8>
8000a908:	20 48       	sub	r8,4
8000a90a:	10 0b       	add	r11,r8
8000a90c:	50 4b       	stdsp	sp[0x10],r11
8000a90e:	c0 78       	rjmp	8000a91c <_dtoa_r+0x8c4>
8000a910:	58 48       	cp.w	r8,4
8000a912:	c0 70       	breq	8000a920 <_dtoa_r+0x8c8>
8000a914:	40 4a       	lddsp	r10,sp[0x10]
8000a916:	2e 48       	sub	r8,-28
8000a918:	10 0a       	add	r10,r8
8000a91a:	50 4a       	stdsp	sp[0x10],r10
8000a91c:	10 00       	add	r0,r8
8000a91e:	10 05       	add	r5,r8
8000a920:	58 00       	cp.w	r0,0
8000a922:	e0 8a 00 08 	brle	8000a932 <_dtoa_r+0x8da>
8000a926:	06 9b       	mov	r11,r3
8000a928:	00 9a       	mov	r10,r0
8000a92a:	0e 9c       	mov	r12,r7
8000a92c:	e0 a0 07 58 	rcall	8000b7dc <__lshift>
8000a930:	18 93       	mov	r3,r12
8000a932:	40 49       	lddsp	r9,sp[0x10]
8000a934:	58 09       	cp.w	r9,0
8000a936:	e0 8a 00 08 	brle	8000a946 <_dtoa_r+0x8ee>
8000a93a:	04 9b       	mov	r11,r2
8000a93c:	12 9a       	mov	r10,r9
8000a93e:	0e 9c       	mov	r12,r7
8000a940:	e0 a0 07 4e 	rcall	8000b7dc <__lshift>
8000a944:	18 92       	mov	r2,r12
8000a946:	41 48       	lddsp	r8,sp[0x50]
8000a948:	58 08       	cp.w	r8,0
8000a94a:	c1 b0       	breq	8000a980 <_dtoa_r+0x928>
8000a94c:	04 9b       	mov	r11,r2
8000a94e:	06 9c       	mov	r12,r3
8000a950:	e0 a0 06 23 	rcall	8000b596 <__mcmp>
8000a954:	c1 64       	brge	8000a980 <_dtoa_r+0x928>
8000a956:	06 9b       	mov	r11,r3
8000a958:	30 09       	mov	r9,0
8000a95a:	30 aa       	mov	r10,10
8000a95c:	0e 9c       	mov	r12,r7
8000a95e:	e0 a0 08 0b 	rcall	8000b974 <__multadd>
8000a962:	20 16       	sub	r6,1
8000a964:	18 93       	mov	r3,r12
8000a966:	40 dc       	lddsp	r12,sp[0x34]
8000a968:	58 0c       	cp.w	r12,0
8000a96a:	c0 31       	brne	8000a970 <_dtoa_r+0x918>
8000a96c:	40 91       	lddsp	r1,sp[0x24]
8000a96e:	c0 98       	rjmp	8000a980 <_dtoa_r+0x928>
8000a970:	08 9b       	mov	r11,r4
8000a972:	40 91       	lddsp	r1,sp[0x24]
8000a974:	30 09       	mov	r9,0
8000a976:	30 aa       	mov	r10,10
8000a978:	0e 9c       	mov	r12,r7
8000a97a:	e0 a0 07 fd 	rcall	8000b974 <__multadd>
8000a97e:	18 94       	mov	r4,r12
8000a980:	58 01       	cp.w	r1,0
8000a982:	5f a9       	srle	r9
8000a984:	40 cb       	lddsp	r11,sp[0x30]
8000a986:	58 2b       	cp.w	r11,2
8000a988:	5f 98       	srgt	r8
8000a98a:	f3 e8 00 08 	and	r8,r9,r8
8000a98e:	c2 50       	breq	8000a9d8 <_dtoa_r+0x980>
8000a990:	58 01       	cp.w	r1,0
8000a992:	c1 11       	brne	8000a9b4 <_dtoa_r+0x95c>
8000a994:	04 9b       	mov	r11,r2
8000a996:	02 99       	mov	r9,r1
8000a998:	30 5a       	mov	r10,5
8000a99a:	0e 9c       	mov	r12,r7
8000a99c:	e0 a0 07 ec 	rcall	8000b974 <__multadd>
8000a9a0:	18 92       	mov	r2,r12
8000a9a2:	18 9b       	mov	r11,r12
8000a9a4:	06 9c       	mov	r12,r3
8000a9a6:	e0 a0 05 f8 	rcall	8000b596 <__mcmp>
8000a9aa:	e0 89 00 0f 	brgt	8000a9c8 <_dtoa_r+0x970>
8000a9ae:	c0 38       	rjmp	8000a9b4 <_dtoa_r+0x95c>
8000a9b0:	30 02       	mov	r2,0
8000a9b2:	04 94       	mov	r4,r2
8000a9b4:	40 ea       	lddsp	r10,sp[0x38]
8000a9b6:	30 09       	mov	r9,0
8000a9b8:	5c da       	com	r10
8000a9ba:	40 85       	lddsp	r5,sp[0x20]
8000a9bc:	50 6a       	stdsp	sp[0x18],r10
8000a9be:	50 49       	stdsp	sp[0x10],r9
8000a9c0:	c0 f9       	rjmp	8000abde <_dtoa_r+0xb86>
8000a9c2:	08 92       	mov	r2,r4
8000a9c4:	40 66       	lddsp	r6,sp[0x18]
8000a9c6:	04 94       	mov	r4,r2
8000a9c8:	2f f6       	sub	r6,-1
8000a9ca:	50 66       	stdsp	sp[0x18],r6
8000a9cc:	33 18       	mov	r8,49
8000a9ce:	40 85       	lddsp	r5,sp[0x20]
8000a9d0:	0a c8       	st.b	r5++,r8
8000a9d2:	30 08       	mov	r8,0
8000a9d4:	50 48       	stdsp	sp[0x10],r8
8000a9d6:	c0 49       	rjmp	8000abde <_dtoa_r+0xb86>
8000a9d8:	40 dc       	lddsp	r12,sp[0x34]
8000a9da:	58 0c       	cp.w	r12,0
8000a9dc:	e0 80 00 b5 	breq	8000ab46 <_dtoa_r+0xaee>
8000a9e0:	58 05       	cp.w	r5,0
8000a9e2:	e0 8a 00 08 	brle	8000a9f2 <_dtoa_r+0x99a>
8000a9e6:	08 9b       	mov	r11,r4
8000a9e8:	0a 9a       	mov	r10,r5
8000a9ea:	0e 9c       	mov	r12,r7
8000a9ec:	e0 a0 06 f8 	rcall	8000b7dc <__lshift>
8000a9f0:	18 94       	mov	r4,r12
8000a9f2:	40 6b       	lddsp	r11,sp[0x18]
8000a9f4:	58 0b       	cp.w	r11,0
8000a9f6:	c0 31       	brne	8000a9fc <_dtoa_r+0x9a4>
8000a9f8:	08 9c       	mov	r12,r4
8000a9fa:	c1 38       	rjmp	8000aa20 <_dtoa_r+0x9c8>
8000a9fc:	68 1b       	ld.w	r11,r4[0x4]
8000a9fe:	0e 9c       	mov	r12,r7
8000aa00:	e0 a0 05 fe 	rcall	8000b5fc <_Balloc>
8000aa04:	68 4a       	ld.w	r10,r4[0x10]
8000aa06:	18 95       	mov	r5,r12
8000aa08:	e8 cb ff f4 	sub	r11,r4,-12
8000aa0c:	2f ea       	sub	r10,-2
8000aa0e:	2f 4c       	sub	r12,-12
8000aa10:	a3 6a       	lsl	r10,0x2
8000aa12:	fe b0 e6 4f 	rcall	800076b0 <memcpy>
8000aa16:	0a 9b       	mov	r11,r5
8000aa18:	30 1a       	mov	r10,1
8000aa1a:	0e 9c       	mov	r12,r7
8000aa1c:	e0 a0 06 e0 	rcall	8000b7dc <__lshift>
8000aa20:	50 44       	stdsp	sp[0x10],r4
8000aa22:	40 3a       	lddsp	r10,sp[0xc]
8000aa24:	30 19       	mov	r9,1
8000aa26:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
8000aa2a:	18 94       	mov	r4,r12
8000aa2c:	50 da       	stdsp	sp[0x34],r10
8000aa2e:	40 85       	lddsp	r5,sp[0x20]
8000aa30:	50 99       	stdsp	sp[0x24],r9
8000aa32:	50 26       	stdsp	sp[0x8],r6
8000aa34:	50 e1       	stdsp	sp[0x38],r1
8000aa36:	04 9b       	mov	r11,r2
8000aa38:	06 9c       	mov	r12,r3
8000aa3a:	fe b0 fa 7f 	rcall	80009f38 <quorem>
8000aa3e:	40 4b       	lddsp	r11,sp[0x10]
8000aa40:	f8 c0 ff d0 	sub	r0,r12,-48
8000aa44:	06 9c       	mov	r12,r3
8000aa46:	e0 a0 05 a8 	rcall	8000b596 <__mcmp>
8000aa4a:	08 9a       	mov	r10,r4
8000aa4c:	50 6c       	stdsp	sp[0x18],r12
8000aa4e:	04 9b       	mov	r11,r2
8000aa50:	0e 9c       	mov	r12,r7
8000aa52:	e0 a0 06 5d 	rcall	8000b70c <__mdiff>
8000aa56:	18 91       	mov	r1,r12
8000aa58:	78 38       	ld.w	r8,r12[0xc]
8000aa5a:	58 08       	cp.w	r8,0
8000aa5c:	c0 30       	breq	8000aa62 <_dtoa_r+0xa0a>
8000aa5e:	30 16       	mov	r6,1
8000aa60:	c0 68       	rjmp	8000aa6c <_dtoa_r+0xa14>
8000aa62:	18 9b       	mov	r11,r12
8000aa64:	06 9c       	mov	r12,r3
8000aa66:	e0 a0 05 98 	rcall	8000b596 <__mcmp>
8000aa6a:	18 96       	mov	r6,r12
8000aa6c:	0e 9c       	mov	r12,r7
8000aa6e:	02 9b       	mov	r11,r1
8000aa70:	e0 a0 05 ac 	rcall	8000b5c8 <_Bfree>
8000aa74:	40 cc       	lddsp	r12,sp[0x30]
8000aa76:	ed ec 10 08 	or	r8,r6,r12
8000aa7a:	c0 d1       	brne	8000aa94 <_dtoa_r+0xa3c>
8000aa7c:	40 db       	lddsp	r11,sp[0x34]
8000aa7e:	58 0b       	cp.w	r11,0
8000aa80:	c0 a1       	brne	8000aa94 <_dtoa_r+0xa3c>
8000aa82:	40 26       	lddsp	r6,sp[0x8]
8000aa84:	e0 40 00 39 	cp.w	r0,57
8000aa88:	c3 00       	breq	8000aae8 <_dtoa_r+0xa90>
8000aa8a:	40 6a       	lddsp	r10,sp[0x18]
8000aa8c:	58 0a       	cp.w	r10,0
8000aa8e:	e0 89 00 24 	brgt	8000aad6 <_dtoa_r+0xa7e>
8000aa92:	c2 f8       	rjmp	8000aaf0 <_dtoa_r+0xa98>
8000aa94:	40 69       	lddsp	r9,sp[0x18]
8000aa96:	58 09       	cp.w	r9,0
8000aa98:	c0 85       	brlt	8000aaa8 <_dtoa_r+0xa50>
8000aa9a:	12 98       	mov	r8,r9
8000aa9c:	40 cc       	lddsp	r12,sp[0x30]
8000aa9e:	18 48       	or	r8,r12
8000aaa0:	c1 d1       	brne	8000aada <_dtoa_r+0xa82>
8000aaa2:	40 db       	lddsp	r11,sp[0x34]
8000aaa4:	58 0b       	cp.w	r11,0
8000aaa6:	c1 a1       	brne	8000aada <_dtoa_r+0xa82>
8000aaa8:	0c 99       	mov	r9,r6
8000aaaa:	40 26       	lddsp	r6,sp[0x8]
8000aaac:	58 09       	cp.w	r9,0
8000aaae:	e0 8a 00 21 	brle	8000aaf0 <_dtoa_r+0xa98>
8000aab2:	06 9b       	mov	r11,r3
8000aab4:	30 1a       	mov	r10,1
8000aab6:	0e 9c       	mov	r12,r7
8000aab8:	e0 a0 06 92 	rcall	8000b7dc <__lshift>
8000aabc:	04 9b       	mov	r11,r2
8000aabe:	18 93       	mov	r3,r12
8000aac0:	e0 a0 05 6b 	rcall	8000b596 <__mcmp>
8000aac4:	e0 89 00 06 	brgt	8000aad0 <_dtoa_r+0xa78>
8000aac8:	c1 41       	brne	8000aaf0 <_dtoa_r+0xa98>
8000aaca:	ed b0 00 00 	bld	r0,0x0
8000aace:	c1 11       	brne	8000aaf0 <_dtoa_r+0xa98>
8000aad0:	e0 40 00 39 	cp.w	r0,57
8000aad4:	c0 a0       	breq	8000aae8 <_dtoa_r+0xa90>
8000aad6:	2f f0       	sub	r0,-1
8000aad8:	c0 c8       	rjmp	8000aaf0 <_dtoa_r+0xa98>
8000aada:	58 06       	cp.w	r6,0
8000aadc:	e0 8a 00 0c 	brle	8000aaf4 <_dtoa_r+0xa9c>
8000aae0:	40 26       	lddsp	r6,sp[0x8]
8000aae2:	e0 40 00 39 	cp.w	r0,57
8000aae6:	c0 41       	brne	8000aaee <_dtoa_r+0xa96>
8000aae8:	33 98       	mov	r8,57
8000aaea:	0a c8       	st.b	r5++,r8
8000aaec:	c6 78       	rjmp	8000abba <_dtoa_r+0xb62>
8000aaee:	2f f0       	sub	r0,-1
8000aaf0:	0a c0       	st.b	r5++,r0
8000aaf2:	c7 58       	rjmp	8000abdc <_dtoa_r+0xb84>
8000aaf4:	0a c0       	st.b	r5++,r0
8000aaf6:	40 9a       	lddsp	r10,sp[0x24]
8000aaf8:	40 e9       	lddsp	r9,sp[0x38]
8000aafa:	12 3a       	cp.w	r10,r9
8000aafc:	c4 30       	breq	8000ab82 <_dtoa_r+0xb2a>
8000aafe:	06 9b       	mov	r11,r3
8000ab00:	30 09       	mov	r9,0
8000ab02:	30 aa       	mov	r10,10
8000ab04:	0e 9c       	mov	r12,r7
8000ab06:	e0 a0 07 37 	rcall	8000b974 <__multadd>
8000ab0a:	40 48       	lddsp	r8,sp[0x10]
8000ab0c:	18 93       	mov	r3,r12
8000ab0e:	08 38       	cp.w	r8,r4
8000ab10:	c0 91       	brne	8000ab22 <_dtoa_r+0xaca>
8000ab12:	10 9b       	mov	r11,r8
8000ab14:	30 09       	mov	r9,0
8000ab16:	30 aa       	mov	r10,10
8000ab18:	0e 9c       	mov	r12,r7
8000ab1a:	e0 a0 07 2d 	rcall	8000b974 <__multadd>
8000ab1e:	50 4c       	stdsp	sp[0x10],r12
8000ab20:	c0 e8       	rjmp	8000ab3c <_dtoa_r+0xae4>
8000ab22:	40 4b       	lddsp	r11,sp[0x10]
8000ab24:	30 09       	mov	r9,0
8000ab26:	30 aa       	mov	r10,10
8000ab28:	0e 9c       	mov	r12,r7
8000ab2a:	e0 a0 07 25 	rcall	8000b974 <__multadd>
8000ab2e:	08 9b       	mov	r11,r4
8000ab30:	50 4c       	stdsp	sp[0x10],r12
8000ab32:	30 09       	mov	r9,0
8000ab34:	30 aa       	mov	r10,10
8000ab36:	0e 9c       	mov	r12,r7
8000ab38:	e0 a0 07 1e 	rcall	8000b974 <__multadd>
8000ab3c:	18 94       	mov	r4,r12
8000ab3e:	40 9c       	lddsp	r12,sp[0x24]
8000ab40:	2f fc       	sub	r12,-1
8000ab42:	50 9c       	stdsp	sp[0x24],r12
8000ab44:	c7 9b       	rjmp	8000aa36 <_dtoa_r+0x9de>
8000ab46:	30 18       	mov	r8,1
8000ab48:	06 90       	mov	r0,r3
8000ab4a:	40 85       	lddsp	r5,sp[0x20]
8000ab4c:	08 93       	mov	r3,r4
8000ab4e:	0c 94       	mov	r4,r6
8000ab50:	10 96       	mov	r6,r8
8000ab52:	04 9b       	mov	r11,r2
8000ab54:	00 9c       	mov	r12,r0
8000ab56:	fe b0 f9 f1 	rcall	80009f38 <quorem>
8000ab5a:	2d 0c       	sub	r12,-48
8000ab5c:	0a cc       	st.b	r5++,r12
8000ab5e:	02 36       	cp.w	r6,r1
8000ab60:	c0 a4       	brge	8000ab74 <_dtoa_r+0xb1c>
8000ab62:	00 9b       	mov	r11,r0
8000ab64:	30 09       	mov	r9,0
8000ab66:	30 aa       	mov	r10,10
8000ab68:	0e 9c       	mov	r12,r7
8000ab6a:	2f f6       	sub	r6,-1
8000ab6c:	e0 a0 07 04 	rcall	8000b974 <__multadd>
8000ab70:	18 90       	mov	r0,r12
8000ab72:	cf 0b       	rjmp	8000ab52 <_dtoa_r+0xafa>
8000ab74:	08 96       	mov	r6,r4
8000ab76:	30 0b       	mov	r11,0
8000ab78:	06 94       	mov	r4,r3
8000ab7a:	50 4b       	stdsp	sp[0x10],r11
8000ab7c:	00 93       	mov	r3,r0
8000ab7e:	18 90       	mov	r0,r12
8000ab80:	c0 28       	rjmp	8000ab84 <_dtoa_r+0xb2c>
8000ab82:	40 26       	lddsp	r6,sp[0x8]
8000ab84:	06 9b       	mov	r11,r3
8000ab86:	30 1a       	mov	r10,1
8000ab88:	0e 9c       	mov	r12,r7
8000ab8a:	e0 a0 06 29 	rcall	8000b7dc <__lshift>
8000ab8e:	04 9b       	mov	r11,r2
8000ab90:	18 93       	mov	r3,r12
8000ab92:	e0 a0 05 02 	rcall	8000b596 <__mcmp>
8000ab96:	e0 89 00 12 	brgt	8000abba <_dtoa_r+0xb62>
8000ab9a:	c1 b1       	brne	8000abd0 <_dtoa_r+0xb78>
8000ab9c:	e1 d0 c0 01 	bfextu	r0,r0,0x0,0x1
8000aba0:	c0 d1       	brne	8000abba <_dtoa_r+0xb62>
8000aba2:	c1 78       	rjmp	8000abd0 <_dtoa_r+0xb78>
8000aba4:	40 89       	lddsp	r9,sp[0x20]
8000aba6:	12 38       	cp.w	r8,r9
8000aba8:	c0 30       	breq	8000abae <_dtoa_r+0xb56>
8000abaa:	10 95       	mov	r5,r8
8000abac:	c0 88       	rjmp	8000abbc <_dtoa_r+0xb64>
8000abae:	2f f6       	sub	r6,-1
8000abb0:	50 66       	stdsp	sp[0x18],r6
8000abb2:	33 18       	mov	r8,49
8000abb4:	40 8c       	lddsp	r12,sp[0x20]
8000abb6:	b8 88       	st.b	r12[0x0],r8
8000abb8:	c1 38       	rjmp	8000abde <_dtoa_r+0xb86>
8000abba:	33 9a       	mov	r10,57
8000abbc:	0a 98       	mov	r8,r5
8000abbe:	11 79       	ld.ub	r9,--r8
8000abc0:	f4 09 18 00 	cp.b	r9,r10
8000abc4:	cf 00       	breq	8000aba4 <_dtoa_r+0xb4c>
8000abc6:	2f f9       	sub	r9,-1
8000abc8:	b0 89       	st.b	r8[0x0],r9
8000abca:	c0 98       	rjmp	8000abdc <_dtoa_r+0xb84>
8000abcc:	10 95       	mov	r5,r8
8000abce:	c0 28       	rjmp	8000abd2 <_dtoa_r+0xb7a>
8000abd0:	33 09       	mov	r9,48
8000abd2:	0a 98       	mov	r8,r5
8000abd4:	11 7a       	ld.ub	r10,--r8
8000abd6:	f2 0a 18 00 	cp.b	r10,r9
8000abda:	cf 90       	breq	8000abcc <_dtoa_r+0xb74>
8000abdc:	50 66       	stdsp	sp[0x18],r6
8000abde:	04 9b       	mov	r11,r2
8000abe0:	0e 9c       	mov	r12,r7
8000abe2:	e0 a0 04 f3 	rcall	8000b5c8 <_Bfree>
8000abe6:	58 04       	cp.w	r4,0
8000abe8:	c1 20       	breq	8000ac0c <_dtoa_r+0xbb4>
8000abea:	40 4b       	lddsp	r11,sp[0x10]
8000abec:	08 3b       	cp.w	r11,r4
8000abee:	5f 19       	srne	r9
8000abf0:	58 0b       	cp.w	r11,0
8000abf2:	5f 18       	srne	r8
8000abf4:	f3 e8 00 08 	and	r8,r9,r8
8000abf8:	c0 40       	breq	8000ac00 <_dtoa_r+0xba8>
8000abfa:	0e 9c       	mov	r12,r7
8000abfc:	e0 a0 04 e6 	rcall	8000b5c8 <_Bfree>
8000ac00:	08 9b       	mov	r11,r4
8000ac02:	0e 9c       	mov	r12,r7
8000ac04:	e0 a0 04 e2 	rcall	8000b5c8 <_Bfree>
8000ac08:	c0 28       	rjmp	8000ac0c <_dtoa_r+0xbb4>
8000ac0a:	50 66       	stdsp	sp[0x18],r6
8000ac0c:	0e 9c       	mov	r12,r7
8000ac0e:	06 9b       	mov	r11,r3
8000ac10:	e0 a0 04 dc 	rcall	8000b5c8 <_Bfree>
8000ac14:	30 08       	mov	r8,0
8000ac16:	aa 88       	st.b	r5[0x0],r8
8000ac18:	40 68       	lddsp	r8,sp[0x18]
8000ac1a:	41 5a       	lddsp	r10,sp[0x54]
8000ac1c:	2f f8       	sub	r8,-1
8000ac1e:	41 29       	lddsp	r9,sp[0x48]
8000ac20:	95 08       	st.w	r10[0x0],r8
8000ac22:	40 8c       	lddsp	r12,sp[0x20]
8000ac24:	58 09       	cp.w	r9,0
8000ac26:	fb f8 10 12 	ld.wne	r8,sp[0x48]
8000ac2a:	f1 f5 1a 00 	st.wne	r8[0x0],r5
8000ac2e:	2e 6d       	sub	sp,-104
8000ac30:	d8 32       	popm	r0-r7,pc
8000ac32:	d7 03       	nop

8000ac34 <__errno>:
8000ac34:	e0 68 0a 3c 	mov	r8,2620
8000ac38:	70 0c       	ld.w	r12,r8[0x0]
8000ac3a:	2f 4c       	sub	r12,-12
8000ac3c:	5e fc       	retal	r12
8000ac3e:	d7 03       	nop

8000ac40 <_fflush_r>:
8000ac40:	d4 21       	pushm	r4-r7,lr
8000ac42:	16 97       	mov	r7,r11
8000ac44:	18 96       	mov	r6,r12
8000ac46:	76 48       	ld.w	r8,r11[0x10]
8000ac48:	58 08       	cp.w	r8,0
8000ac4a:	c7 f0       	breq	8000ad48 <_fflush_r+0x108>
8000ac4c:	58 0c       	cp.w	r12,0
8000ac4e:	c0 50       	breq	8000ac58 <_fflush_r+0x18>
8000ac50:	78 68       	ld.w	r8,r12[0x18]
8000ac52:	58 08       	cp.w	r8,0
8000ac54:	c0 21       	brne	8000ac58 <_fflush_r+0x18>
8000ac56:	cc dc       	rcall	8000adf0 <__sinit>
8000ac58:	fe c8 ce 84 	sub	r8,pc,-12668
8000ac5c:	10 37       	cp.w	r7,r8
8000ac5e:	c0 31       	brne	8000ac64 <_fflush_r+0x24>
8000ac60:	6c 07       	ld.w	r7,r6[0x0]
8000ac62:	c0 c8       	rjmp	8000ac7a <_fflush_r+0x3a>
8000ac64:	fe c8 ce 70 	sub	r8,pc,-12688
8000ac68:	10 37       	cp.w	r7,r8
8000ac6a:	c0 31       	brne	8000ac70 <_fflush_r+0x30>
8000ac6c:	6c 17       	ld.w	r7,r6[0x4]
8000ac6e:	c0 68       	rjmp	8000ac7a <_fflush_r+0x3a>
8000ac70:	fe c8 ce 5c 	sub	r8,pc,-12708
8000ac74:	10 37       	cp.w	r7,r8
8000ac76:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000ac7a:	8e 6a       	ld.sh	r10,r7[0xc]
8000ac7c:	14 98       	mov	r8,r10
8000ac7e:	ed ba 00 03 	bld	r10,0x3
8000ac82:	c4 20       	breq	8000ad06 <_fflush_r+0xc6>
8000ac84:	ab ba       	sbr	r10,0xb
8000ac86:	ae 6a       	st.h	r7[0xc],r10
8000ac88:	6e 18       	ld.w	r8,r7[0x4]
8000ac8a:	58 08       	cp.w	r8,0
8000ac8c:	e0 89 00 06 	brgt	8000ac98 <_fflush_r+0x58>
8000ac90:	6f 08       	ld.w	r8,r7[0x40]
8000ac92:	58 08       	cp.w	r8,0
8000ac94:	e0 8a 00 5a 	brle	8000ad48 <_fflush_r+0x108>
8000ac98:	6e b8       	ld.w	r8,r7[0x2c]
8000ac9a:	58 08       	cp.w	r8,0
8000ac9c:	c5 60       	breq	8000ad48 <_fflush_r+0x108>
8000ac9e:	e2 1a 10 00 	andl	r10,0x1000,COH
8000aca2:	c0 30       	breq	8000aca8 <_fflush_r+0x68>
8000aca4:	6f 55       	ld.w	r5,r7[0x54]
8000aca6:	c0 f8       	rjmp	8000acc4 <_fflush_r+0x84>
8000aca8:	30 19       	mov	r9,1
8000acaa:	6e 8b       	ld.w	r11,r7[0x20]
8000acac:	0c 9c       	mov	r12,r6
8000acae:	5d 18       	icall	r8
8000acb0:	18 95       	mov	r5,r12
8000acb2:	5b fc       	cp.w	r12,-1
8000acb4:	c0 81       	brne	8000acc4 <_fflush_r+0x84>
8000acb6:	6c 38       	ld.w	r8,r6[0xc]
8000acb8:	59 d8       	cp.w	r8,29
8000acba:	c4 70       	breq	8000ad48 <_fflush_r+0x108>
8000acbc:	8e 68       	ld.sh	r8,r7[0xc]
8000acbe:	a7 a8       	sbr	r8,0x6
8000acc0:	ae 68       	st.h	r7[0xc],r8
8000acc2:	d8 22       	popm	r4-r7,pc
8000acc4:	8e 68       	ld.sh	r8,r7[0xc]
8000acc6:	ed b8 00 02 	bld	r8,0x2
8000acca:	c0 91       	brne	8000acdc <_fflush_r+0x9c>
8000accc:	6e 18       	ld.w	r8,r7[0x4]
8000acce:	10 15       	sub	r5,r8
8000acd0:	6e d8       	ld.w	r8,r7[0x34]
8000acd2:	58 08       	cp.w	r8,0
8000acd4:	ef f8 10 10 	ld.wne	r8,r7[0x40]
8000acd8:	eb d8 e1 15 	subne	r5,r5,r8
8000acdc:	6e b8       	ld.w	r8,r7[0x2c]
8000acde:	0c 9c       	mov	r12,r6
8000ace0:	30 09       	mov	r9,0
8000ace2:	0a 9a       	mov	r10,r5
8000ace4:	6e 8b       	ld.w	r11,r7[0x20]
8000ace6:	5d 18       	icall	r8
8000ace8:	8e 68       	ld.sh	r8,r7[0xc]
8000acea:	0a 3c       	cp.w	r12,r5
8000acec:	c2 61       	brne	8000ad38 <_fflush_r+0xf8>
8000acee:	ab d8       	cbr	r8,0xb
8000acf0:	30 0c       	mov	r12,0
8000acf2:	6e 49       	ld.w	r9,r7[0x10]
8000acf4:	ae 68       	st.h	r7[0xc],r8
8000acf6:	8f 1c       	st.w	r7[0x4],r12
8000acf8:	8f 09       	st.w	r7[0x0],r9
8000acfa:	ed b8 00 0c 	bld	r8,0xc
8000acfe:	c2 51       	brne	8000ad48 <_fflush_r+0x108>
8000ad00:	ef 45 00 54 	st.w	r7[84],r5
8000ad04:	d8 22       	popm	r4-r7,pc
8000ad06:	6e 45       	ld.w	r5,r7[0x10]
8000ad08:	58 05       	cp.w	r5,0
8000ad0a:	c1 f0       	breq	8000ad48 <_fflush_r+0x108>
8000ad0c:	6e 04       	ld.w	r4,r7[0x0]
8000ad0e:	f5 da c0 02 	bfextu	r10,r10,0x0,0x2
8000ad12:	8f 05       	st.w	r7[0x0],r5
8000ad14:	f9 b8 01 00 	movne	r8,0
8000ad18:	ef f8 00 05 	ld.weq	r8,r7[0x14]
8000ad1c:	0a 14       	sub	r4,r5
8000ad1e:	8f 28       	st.w	r7[0x8],r8
8000ad20:	c1 18       	rjmp	8000ad42 <_fflush_r+0x102>
8000ad22:	08 99       	mov	r9,r4
8000ad24:	0a 9a       	mov	r10,r5
8000ad26:	6e a8       	ld.w	r8,r7[0x28]
8000ad28:	6e 8b       	ld.w	r11,r7[0x20]
8000ad2a:	0c 9c       	mov	r12,r6
8000ad2c:	5d 18       	icall	r8
8000ad2e:	18 14       	sub	r4,r12
8000ad30:	58 0c       	cp.w	r12,0
8000ad32:	e0 89 00 07 	brgt	8000ad40 <_fflush_r+0x100>
8000ad36:	8e 68       	ld.sh	r8,r7[0xc]
8000ad38:	a7 a8       	sbr	r8,0x6
8000ad3a:	3f fc       	mov	r12,-1
8000ad3c:	ae 68       	st.h	r7[0xc],r8
8000ad3e:	d8 22       	popm	r4-r7,pc
8000ad40:	18 05       	add	r5,r12
8000ad42:	58 04       	cp.w	r4,0
8000ad44:	fe 99 ff ef 	brgt	8000ad22 <_fflush_r+0xe2>
8000ad48:	d8 2a       	popm	r4-r7,pc,r12=0
8000ad4a:	d7 03       	nop

8000ad4c <__sfp_lock_acquire>:
8000ad4c:	5e fc       	retal	r12

8000ad4e <__sfp_lock_release>:
8000ad4e:	5e fc       	retal	r12

8000ad50 <_cleanup_r>:
8000ad50:	d4 01       	pushm	lr
8000ad52:	fe cb f0 ae 	sub	r11,pc,-3922
8000ad56:	e0 a0 02 f7 	rcall	8000b344 <_fwalk>
8000ad5a:	d8 02       	popm	pc

8000ad5c <__sfmoreglue>:
8000ad5c:	d4 21       	pushm	r4-r7,lr
8000ad5e:	16 95       	mov	r5,r11
8000ad60:	f6 06 10 5c 	mul	r6,r11,92
8000ad64:	ec cb ff f4 	sub	r11,r6,-12
8000ad68:	fe b0 e2 88 	rcall	80007278 <_malloc_r>
8000ad6c:	18 97       	mov	r7,r12
8000ad6e:	c0 90       	breq	8000ad80 <__sfmoreglue+0x24>
8000ad70:	99 15       	st.w	r12[0x4],r5
8000ad72:	30 0b       	mov	r11,0
8000ad74:	2f 4c       	sub	r12,-12
8000ad76:	0c 9a       	mov	r10,r6
8000ad78:	8f 2c       	st.w	r7[0x8],r12
8000ad7a:	8f 0b       	st.w	r7[0x0],r11
8000ad7c:	fe b0 e5 3e 	rcall	800077f8 <memset>
8000ad80:	0e 9c       	mov	r12,r7
8000ad82:	d8 22       	popm	r4-r7,pc

8000ad84 <__sfp>:
8000ad84:	d4 21       	pushm	r4-r7,lr
8000ad86:	fe c8 cf 4e 	sub	r8,pc,-12466
8000ad8a:	18 96       	mov	r6,r12
8000ad8c:	70 07       	ld.w	r7,r8[0x0]
8000ad8e:	6e 68       	ld.w	r8,r7[0x18]
8000ad90:	58 08       	cp.w	r8,0
8000ad92:	c0 31       	brne	8000ad98 <__sfp+0x14>
8000ad94:	0e 9c       	mov	r12,r7
8000ad96:	c2 dc       	rcall	8000adf0 <__sinit>
8000ad98:	ee c7 ff 28 	sub	r7,r7,-216
8000ad9c:	30 05       	mov	r5,0
8000ad9e:	6e 2c       	ld.w	r12,r7[0x8]
8000ada0:	6e 18       	ld.w	r8,r7[0x4]
8000ada2:	c0 68       	rjmp	8000adae <__sfp+0x2a>
8000ada4:	98 69       	ld.sh	r9,r12[0xc]
8000ada6:	ea 09 19 00 	cp.h	r9,r5
8000adaa:	c1 10       	breq	8000adcc <__sfp+0x48>
8000adac:	2a 4c       	sub	r12,-92
8000adae:	20 18       	sub	r8,1
8000adb0:	cf a7       	brpl	8000ada4 <__sfp+0x20>
8000adb2:	6e 08       	ld.w	r8,r7[0x0]
8000adb4:	58 08       	cp.w	r8,0
8000adb6:	c0 61       	brne	8000adc2 <__sfp+0x3e>
8000adb8:	30 4b       	mov	r11,4
8000adba:	0c 9c       	mov	r12,r6
8000adbc:	cd 0f       	rcall	8000ad5c <__sfmoreglue>
8000adbe:	8f 0c       	st.w	r7[0x0],r12
8000adc0:	c0 30       	breq	8000adc6 <__sfp+0x42>
8000adc2:	6e 07       	ld.w	r7,r7[0x0]
8000adc4:	ce db       	rjmp	8000ad9e <__sfp+0x1a>
8000adc6:	30 c8       	mov	r8,12
8000adc8:	8d 38       	st.w	r6[0xc],r8
8000adca:	d8 22       	popm	r4-r7,pc
8000adcc:	30 08       	mov	r8,0
8000adce:	f9 48 00 4c 	st.w	r12[76],r8
8000add2:	99 08       	st.w	r12[0x0],r8
8000add4:	99 28       	st.w	r12[0x8],r8
8000add6:	99 18       	st.w	r12[0x4],r8
8000add8:	99 48       	st.w	r12[0x10],r8
8000adda:	99 58       	st.w	r12[0x14],r8
8000addc:	99 68       	st.w	r12[0x18],r8
8000adde:	99 d8       	st.w	r12[0x34],r8
8000ade0:	99 e8       	st.w	r12[0x38],r8
8000ade2:	f9 48 00 48 	st.w	r12[72],r8
8000ade6:	3f f8       	mov	r8,-1
8000ade8:	b8 78       	st.h	r12[0xe],r8
8000adea:	30 18       	mov	r8,1
8000adec:	b8 68       	st.h	r12[0xc],r8
8000adee:	d8 22       	popm	r4-r7,pc

8000adf0 <__sinit>:
8000adf0:	d4 21       	pushm	r4-r7,lr
8000adf2:	18 96       	mov	r6,r12
8000adf4:	78 67       	ld.w	r7,r12[0x18]
8000adf6:	58 07       	cp.w	r7,0
8000adf8:	c4 91       	brne	8000ae8a <__sinit+0x9a>
8000adfa:	fe c8 00 aa 	sub	r8,pc,170
8000adfe:	30 15       	mov	r5,1
8000ae00:	99 a8       	st.w	r12[0x28],r8
8000ae02:	f9 47 00 d8 	st.w	r12[216],r7
8000ae06:	f9 47 00 dc 	st.w	r12[220],r7
8000ae0a:	f9 47 00 e0 	st.w	r12[224],r7
8000ae0e:	99 65       	st.w	r12[0x18],r5
8000ae10:	cb af       	rcall	8000ad84 <__sfp>
8000ae12:	8d 0c       	st.w	r6[0x0],r12
8000ae14:	0c 9c       	mov	r12,r6
8000ae16:	cb 7f       	rcall	8000ad84 <__sfp>
8000ae18:	8d 1c       	st.w	r6[0x4],r12
8000ae1a:	0c 9c       	mov	r12,r6
8000ae1c:	cb 4f       	rcall	8000ad84 <__sfp>
8000ae1e:	6c 09       	ld.w	r9,r6[0x0]
8000ae20:	30 48       	mov	r8,4
8000ae22:	93 07       	st.w	r9[0x0],r7
8000ae24:	b2 68       	st.h	r9[0xc],r8
8000ae26:	93 17       	st.w	r9[0x4],r7
8000ae28:	93 27       	st.w	r9[0x8],r7
8000ae2a:	6c 18       	ld.w	r8,r6[0x4]
8000ae2c:	b2 77       	st.h	r9[0xe],r7
8000ae2e:	93 47       	st.w	r9[0x10],r7
8000ae30:	93 57       	st.w	r9[0x14],r7
8000ae32:	93 67       	st.w	r9[0x18],r7
8000ae34:	93 89       	st.w	r9[0x20],r9
8000ae36:	91 07       	st.w	r8[0x0],r7
8000ae38:	91 17       	st.w	r8[0x4],r7
8000ae3a:	91 27       	st.w	r8[0x8],r7
8000ae3c:	fe ce f3 24 	sub	lr,pc,-3292
8000ae40:	fe cb f3 54 	sub	r11,pc,-3244
8000ae44:	93 9e       	st.w	r9[0x24],lr
8000ae46:	93 ab       	st.w	r9[0x28],r11
8000ae48:	fe ca f3 7c 	sub	r10,pc,-3204
8000ae4c:	fe c4 f3 88 	sub	r4,pc,-3192
8000ae50:	93 ba       	st.w	r9[0x2c],r10
8000ae52:	93 c4       	st.w	r9[0x30],r4
8000ae54:	30 99       	mov	r9,9
8000ae56:	b0 69       	st.h	r8[0xc],r9
8000ae58:	b0 75       	st.h	r8[0xe],r5
8000ae5a:	91 c4       	st.w	r8[0x30],r4
8000ae5c:	91 47       	st.w	r8[0x10],r7
8000ae5e:	91 57       	st.w	r8[0x14],r7
8000ae60:	91 67       	st.w	r8[0x18],r7
8000ae62:	91 88       	st.w	r8[0x20],r8
8000ae64:	91 9e       	st.w	r8[0x24],lr
8000ae66:	91 ab       	st.w	r8[0x28],r11
8000ae68:	91 ba       	st.w	r8[0x2c],r10
8000ae6a:	8d 2c       	st.w	r6[0x8],r12
8000ae6c:	31 28       	mov	r8,18
8000ae6e:	99 07       	st.w	r12[0x0],r7
8000ae70:	b8 68       	st.h	r12[0xc],r8
8000ae72:	99 17       	st.w	r12[0x4],r7
8000ae74:	99 27       	st.w	r12[0x8],r7
8000ae76:	30 28       	mov	r8,2
8000ae78:	b8 78       	st.h	r12[0xe],r8
8000ae7a:	99 c4       	st.w	r12[0x30],r4
8000ae7c:	99 67       	st.w	r12[0x18],r7
8000ae7e:	99 9e       	st.w	r12[0x24],lr
8000ae80:	99 ab       	st.w	r12[0x28],r11
8000ae82:	99 ba       	st.w	r12[0x2c],r10
8000ae84:	99 47       	st.w	r12[0x10],r7
8000ae86:	99 57       	st.w	r12[0x14],r7
8000ae88:	99 8c       	st.w	r12[0x20],r12
8000ae8a:	d8 22       	popm	r4-r7,pc

8000ae8c <_malloc_trim_r>:
8000ae8c:	d4 21       	pushm	r4-r7,lr
8000ae8e:	16 95       	mov	r5,r11
8000ae90:	18 97       	mov	r7,r12
8000ae92:	fe b0 d7 d7 	rcall	80005e40 <__malloc_lock>
8000ae96:	e0 64 05 3c 	mov	r4,1340
8000ae9a:	68 28       	ld.w	r8,r4[0x8]
8000ae9c:	70 16       	ld.w	r6,r8[0x4]
8000ae9e:	e0 16 ff fc 	andl	r6,0xfffc
8000aea2:	ec c8 ff 91 	sub	r8,r6,-111
8000aea6:	f0 05 01 05 	sub	r5,r8,r5
8000aeaa:	e0 15 ff 80 	andl	r5,0xff80
8000aeae:	ea c5 00 80 	sub	r5,r5,128
8000aeb2:	e0 45 00 7f 	cp.w	r5,127
8000aeb6:	e0 8a 00 25 	brle	8000af00 <_malloc_trim_r+0x74>
8000aeba:	30 0b       	mov	r11,0
8000aebc:	0e 9c       	mov	r12,r7
8000aebe:	fe b0 e6 05 	rcall	80007ac8 <_sbrk_r>
8000aec2:	68 28       	ld.w	r8,r4[0x8]
8000aec4:	0c 08       	add	r8,r6
8000aec6:	10 3c       	cp.w	r12,r8
8000aec8:	c1 c1       	brne	8000af00 <_malloc_trim_r+0x74>
8000aeca:	ea 0b 11 00 	rsub	r11,r5,0
8000aece:	0e 9c       	mov	r12,r7
8000aed0:	fe b0 e5 fc 	rcall	80007ac8 <_sbrk_r>
8000aed4:	5b fc       	cp.w	r12,-1
8000aed6:	c1 91       	brne	8000af08 <_malloc_trim_r+0x7c>
8000aed8:	30 0b       	mov	r11,0
8000aeda:	0e 9c       	mov	r12,r7
8000aedc:	fe b0 e5 f6 	rcall	80007ac8 <_sbrk_r>
8000aee0:	68 28       	ld.w	r8,r4[0x8]
8000aee2:	f8 08 01 09 	sub	r9,r12,r8
8000aee6:	58 f9       	cp.w	r9,15
8000aee8:	e0 8a 00 0c 	brle	8000af00 <_malloc_trim_r+0x74>
8000aeec:	a1 a9       	sbr	r9,0x0
8000aeee:	91 19       	st.w	r8[0x4],r9
8000aef0:	e0 68 09 48 	mov	r8,2376
8000aef4:	70 09       	ld.w	r9,r8[0x0]
8000aef6:	e0 68 0d 54 	mov	r8,3412
8000aefa:	f8 09 01 09 	sub	r9,r12,r9
8000aefe:	91 09       	st.w	r8[0x0],r9
8000af00:	0e 9c       	mov	r12,r7
8000af02:	fe b0 d7 a5 	rcall	80005e4c <__malloc_unlock>
8000af06:	d8 2a       	popm	r4-r7,pc,r12=0
8000af08:	68 28       	ld.w	r8,r4[0x8]
8000af0a:	0a 16       	sub	r6,r5
8000af0c:	a1 a6       	sbr	r6,0x0
8000af0e:	91 16       	st.w	r8[0x4],r6
8000af10:	e0 68 0d 54 	mov	r8,3412
8000af14:	70 09       	ld.w	r9,r8[0x0]
8000af16:	0a 19       	sub	r9,r5
8000af18:	0e 9c       	mov	r12,r7
8000af1a:	91 09       	st.w	r8[0x0],r9
8000af1c:	fe b0 d7 98 	rcall	80005e4c <__malloc_unlock>
8000af20:	da 2a       	popm	r4-r7,pc,r12=1
8000af22:	d7 03       	nop

8000af24 <_free_r>:
8000af24:	d4 21       	pushm	r4-r7,lr
8000af26:	16 96       	mov	r6,r11
8000af28:	18 97       	mov	r7,r12
8000af2a:	58 0b       	cp.w	r11,0
8000af2c:	e0 80 00 c0 	breq	8000b0ac <_free_r+0x188>
8000af30:	fe b0 d7 88 	rcall	80005e40 <__malloc_lock>
8000af34:	20 86       	sub	r6,8
8000af36:	e0 6a 05 3c 	mov	r10,1340
8000af3a:	6c 18       	ld.w	r8,r6[0x4]
8000af3c:	74 2e       	ld.w	lr,r10[0x8]
8000af3e:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
8000af42:	a1 c8       	cbr	r8,0x0
8000af44:	ec 08 00 09 	add	r9,r6,r8
8000af48:	72 1b       	ld.w	r11,r9[0x4]
8000af4a:	e0 1b ff fc 	andl	r11,0xfffc
8000af4e:	1c 39       	cp.w	r9,lr
8000af50:	c1 e1       	brne	8000af8c <_free_r+0x68>
8000af52:	f6 08 00 08 	add	r8,r11,r8
8000af56:	58 0c       	cp.w	r12,0
8000af58:	c0 81       	brne	8000af68 <_free_r+0x44>
8000af5a:	6c 09       	ld.w	r9,r6[0x0]
8000af5c:	12 16       	sub	r6,r9
8000af5e:	12 08       	add	r8,r9
8000af60:	6c 3b       	ld.w	r11,r6[0xc]
8000af62:	6c 29       	ld.w	r9,r6[0x8]
8000af64:	97 29       	st.w	r11[0x8],r9
8000af66:	93 3b       	st.w	r9[0xc],r11
8000af68:	10 99       	mov	r9,r8
8000af6a:	95 26       	st.w	r10[0x8],r6
8000af6c:	a1 a9       	sbr	r9,0x0
8000af6e:	8d 19       	st.w	r6[0x4],r9
8000af70:	e0 69 09 44 	mov	r9,2372
8000af74:	72 09       	ld.w	r9,r9[0x0]
8000af76:	12 38       	cp.w	r8,r9
8000af78:	c0 63       	brcs	8000af84 <_free_r+0x60>
8000af7a:	e0 68 0d 50 	mov	r8,3408
8000af7e:	0e 9c       	mov	r12,r7
8000af80:	70 0b       	ld.w	r11,r8[0x0]
8000af82:	c8 5f       	rcall	8000ae8c <_malloc_trim_r>
8000af84:	0e 9c       	mov	r12,r7
8000af86:	fe b0 d7 63 	rcall	80005e4c <__malloc_unlock>
8000af8a:	d8 22       	popm	r4-r7,pc
8000af8c:	93 1b       	st.w	r9[0x4],r11
8000af8e:	58 0c       	cp.w	r12,0
8000af90:	c0 30       	breq	8000af96 <_free_r+0x72>
8000af92:	30 0c       	mov	r12,0
8000af94:	c1 08       	rjmp	8000afb4 <_free_r+0x90>
8000af96:	6c 0e       	ld.w	lr,r6[0x0]
8000af98:	f4 c5 ff f8 	sub	r5,r10,-8
8000af9c:	1c 16       	sub	r6,lr
8000af9e:	1c 08       	add	r8,lr
8000afa0:	6c 2e       	ld.w	lr,r6[0x8]
8000afa2:	0a 3e       	cp.w	lr,r5
8000afa4:	f9 bc 00 01 	moveq	r12,1
8000afa8:	ed f5 10 03 	ld.wne	r5,r6[0xc]
8000afac:	eb fe 1a 02 	st.wne	r5[0x8],lr
8000afb0:	fd f5 1a 03 	st.wne	lr[0xc],r5
8000afb4:	f2 0b 00 0e 	add	lr,r9,r11
8000afb8:	7c 1e       	ld.w	lr,lr[0x4]
8000afba:	ed be 00 00 	bld	lr,0x0
8000afbe:	c1 40       	breq	8000afe6 <_free_r+0xc2>
8000afc0:	16 08       	add	r8,r11
8000afc2:	58 0c       	cp.w	r12,0
8000afc4:	c0 d1       	brne	8000afde <_free_r+0xba>
8000afc6:	e0 6e 05 3c 	mov	lr,1340
8000afca:	72 2b       	ld.w	r11,r9[0x8]
8000afcc:	2f 8e       	sub	lr,-8
8000afce:	1c 3b       	cp.w	r11,lr
8000afd0:	c0 71       	brne	8000afde <_free_r+0xba>
8000afd2:	97 36       	st.w	r11[0xc],r6
8000afd4:	97 26       	st.w	r11[0x8],r6
8000afd6:	8d 2b       	st.w	r6[0x8],r11
8000afd8:	8d 3b       	st.w	r6[0xc],r11
8000afda:	30 1c       	mov	r12,1
8000afdc:	c0 58       	rjmp	8000afe6 <_free_r+0xc2>
8000afde:	72 2b       	ld.w	r11,r9[0x8]
8000afe0:	72 39       	ld.w	r9,r9[0xc]
8000afe2:	93 2b       	st.w	r9[0x8],r11
8000afe4:	97 39       	st.w	r11[0xc],r9
8000afe6:	10 99       	mov	r9,r8
8000afe8:	ec 08 09 08 	st.w	r6[r8],r8
8000afec:	a1 a9       	sbr	r9,0x0
8000afee:	8d 19       	st.w	r6[0x4],r9
8000aff0:	58 0c       	cp.w	r12,0
8000aff2:	c5 a1       	brne	8000b0a6 <_free_r+0x182>
8000aff4:	e0 48 01 ff 	cp.w	r8,511
8000aff8:	e0 8b 00 13 	brhi	8000b01e <_free_r+0xfa>
8000affc:	a3 98       	lsr	r8,0x3
8000affe:	f4 08 00 39 	add	r9,r10,r8<<0x3
8000b002:	72 2b       	ld.w	r11,r9[0x8]
8000b004:	8d 39       	st.w	r6[0xc],r9
8000b006:	8d 2b       	st.w	r6[0x8],r11
8000b008:	97 36       	st.w	r11[0xc],r6
8000b00a:	93 26       	st.w	r9[0x8],r6
8000b00c:	a3 48       	asr	r8,0x2
8000b00e:	74 19       	ld.w	r9,r10[0x4]
8000b010:	30 1b       	mov	r11,1
8000b012:	f6 08 09 48 	lsl	r8,r11,r8
8000b016:	f3 e8 10 08 	or	r8,r9,r8
8000b01a:	95 18       	st.w	r10[0x4],r8
8000b01c:	c4 58       	rjmp	8000b0a6 <_free_r+0x182>
8000b01e:	f0 0b 16 09 	lsr	r11,r8,0x9
8000b022:	58 4b       	cp.w	r11,4
8000b024:	e0 8b 00 06 	brhi	8000b030 <_free_r+0x10c>
8000b028:	f0 0b 16 06 	lsr	r11,r8,0x6
8000b02c:	2c 8b       	sub	r11,-56
8000b02e:	c2 08       	rjmp	8000b06e <_free_r+0x14a>
8000b030:	59 4b       	cp.w	r11,20
8000b032:	e0 8b 00 04 	brhi	8000b03a <_free_r+0x116>
8000b036:	2a 5b       	sub	r11,-91
8000b038:	c1 b8       	rjmp	8000b06e <_free_r+0x14a>
8000b03a:	e0 4b 00 54 	cp.w	r11,84
8000b03e:	e0 8b 00 06 	brhi	8000b04a <_free_r+0x126>
8000b042:	f0 0b 16 0c 	lsr	r11,r8,0xc
8000b046:	29 2b       	sub	r11,-110
8000b048:	c1 38       	rjmp	8000b06e <_free_r+0x14a>
8000b04a:	e0 4b 01 54 	cp.w	r11,340
8000b04e:	e0 8b 00 06 	brhi	8000b05a <_free_r+0x136>
8000b052:	f0 0b 16 0f 	lsr	r11,r8,0xf
8000b056:	28 9b       	sub	r11,-119
8000b058:	c0 b8       	rjmp	8000b06e <_free_r+0x14a>
8000b05a:	e0 4b 05 54 	cp.w	r11,1364
8000b05e:	e0 88 00 05 	brls	8000b068 <_free_r+0x144>
8000b062:	37 eb       	mov	r11,126
8000b064:	c0 58       	rjmp	8000b06e <_free_r+0x14a>
8000b066:	d7 03       	nop
8000b068:	f0 0b 16 12 	lsr	r11,r8,0x12
8000b06c:	28 4b       	sub	r11,-124
8000b06e:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
8000b072:	78 29       	ld.w	r9,r12[0x8]
8000b074:	18 39       	cp.w	r9,r12
8000b076:	c0 e1       	brne	8000b092 <_free_r+0x16e>
8000b078:	74 18       	ld.w	r8,r10[0x4]
8000b07a:	a3 4b       	asr	r11,0x2
8000b07c:	30 1c       	mov	r12,1
8000b07e:	f8 0b 09 4b 	lsl	r11,r12,r11
8000b082:	f1 eb 10 0b 	or	r11,r8,r11
8000b086:	12 98       	mov	r8,r9
8000b088:	95 1b       	st.w	r10[0x4],r11
8000b08a:	c0 a8       	rjmp	8000b09e <_free_r+0x17a>
8000b08c:	72 29       	ld.w	r9,r9[0x8]
8000b08e:	18 39       	cp.w	r9,r12
8000b090:	c0 60       	breq	8000b09c <_free_r+0x178>
8000b092:	72 1a       	ld.w	r10,r9[0x4]
8000b094:	e0 1a ff fc 	andl	r10,0xfffc
8000b098:	14 38       	cp.w	r8,r10
8000b09a:	cf 93       	brcs	8000b08c <_free_r+0x168>
8000b09c:	72 38       	ld.w	r8,r9[0xc]
8000b09e:	8d 38       	st.w	r6[0xc],r8
8000b0a0:	8d 29       	st.w	r6[0x8],r9
8000b0a2:	93 36       	st.w	r9[0xc],r6
8000b0a4:	91 26       	st.w	r8[0x8],r6
8000b0a6:	0e 9c       	mov	r12,r7
8000b0a8:	fe b0 d6 d2 	rcall	80005e4c <__malloc_unlock>
8000b0ac:	d8 22       	popm	r4-r7,pc
8000b0ae:	d7 03       	nop

8000b0b0 <__sfvwrite_r>:
8000b0b0:	d4 31       	pushm	r0-r7,lr
8000b0b2:	20 3d       	sub	sp,12
8000b0b4:	14 94       	mov	r4,r10
8000b0b6:	18 95       	mov	r5,r12
8000b0b8:	16 97       	mov	r7,r11
8000b0ba:	74 28       	ld.w	r8,r10[0x8]
8000b0bc:	58 08       	cp.w	r8,0
8000b0be:	e0 80 01 40 	breq	8000b33e <__sfvwrite_r+0x28e>
8000b0c2:	96 68       	ld.sh	r8,r11[0xc]
8000b0c4:	ed b8 00 03 	bld	r8,0x3
8000b0c8:	c0 41       	brne	8000b0d0 <__sfvwrite_r+0x20>
8000b0ca:	76 48       	ld.w	r8,r11[0x10]
8000b0cc:	58 08       	cp.w	r8,0
8000b0ce:	c0 c1       	brne	8000b0e6 <__sfvwrite_r+0x36>
8000b0d0:	0e 9b       	mov	r11,r7
8000b0d2:	0a 9c       	mov	r12,r5
8000b0d4:	fe b0 f6 c4 	rcall	80009e5c <__swsetup_r>
8000b0d8:	c0 70       	breq	8000b0e6 <__sfvwrite_r+0x36>
8000b0da:	8e 68       	ld.sh	r8,r7[0xc]
8000b0dc:	a7 a8       	sbr	r8,0x6
8000b0de:	ae 68       	st.h	r7[0xc],r8
8000b0e0:	30 98       	mov	r8,9
8000b0e2:	8b 38       	st.w	r5[0xc],r8
8000b0e4:	c2 b9       	rjmp	8000b33a <__sfvwrite_r+0x28a>
8000b0e6:	8e 63       	ld.sh	r3,r7[0xc]
8000b0e8:	68 00       	ld.w	r0,r4[0x0]
8000b0ea:	06 96       	mov	r6,r3
8000b0ec:	e2 16 00 02 	andl	r6,0x2,COH
8000b0f0:	c2 10       	breq	8000b132 <__sfvwrite_r+0x82>
8000b0f2:	30 03       	mov	r3,0
8000b0f4:	e0 62 04 00 	mov	r2,1024
8000b0f8:	06 96       	mov	r6,r3
8000b0fa:	c0 48       	rjmp	8000b102 <__sfvwrite_r+0x52>
8000b0fc:	60 03       	ld.w	r3,r0[0x0]
8000b0fe:	60 16       	ld.w	r6,r0[0x4]
8000b100:	2f 80       	sub	r0,-8
8000b102:	58 06       	cp.w	r6,0
8000b104:	cf c0       	breq	8000b0fc <__sfvwrite_r+0x4c>
8000b106:	e0 46 04 00 	cp.w	r6,1024
8000b10a:	ec 09 17 80 	movls	r9,r6
8000b10e:	e4 09 17 b0 	movhi	r9,r2
8000b112:	06 9a       	mov	r10,r3
8000b114:	6e a8       	ld.w	r8,r7[0x28]
8000b116:	6e 8b       	ld.w	r11,r7[0x20]
8000b118:	0a 9c       	mov	r12,r5
8000b11a:	5d 18       	icall	r8
8000b11c:	18 16       	sub	r6,r12
8000b11e:	58 0c       	cp.w	r12,0
8000b120:	e0 8a 01 0a 	brle	8000b334 <__sfvwrite_r+0x284>
8000b124:	68 28       	ld.w	r8,r4[0x8]
8000b126:	18 18       	sub	r8,r12
8000b128:	89 28       	st.w	r4[0x8],r8
8000b12a:	e0 80 01 0a 	breq	8000b33e <__sfvwrite_r+0x28e>
8000b12e:	18 03       	add	r3,r12
8000b130:	ce 9b       	rjmp	8000b102 <__sfvwrite_r+0x52>
8000b132:	e7 d3 c0 01 	bfextu	r3,r3,0x0,0x1
8000b136:	c0 70       	breq	8000b144 <__sfvwrite_r+0x94>
8000b138:	50 06       	stdsp	sp[0x0],r6
8000b13a:	0c 93       	mov	r3,r6
8000b13c:	0c 91       	mov	r1,r6
8000b13e:	50 15       	stdsp	sp[0x4],r5
8000b140:	08 92       	mov	r2,r4
8000b142:	c9 c8       	rjmp	8000b27a <__sfvwrite_r+0x1ca>
8000b144:	06 96       	mov	r6,r3
8000b146:	08 91       	mov	r1,r4
8000b148:	c0 48       	rjmp	8000b150 <__sfvwrite_r+0xa0>
8000b14a:	60 03       	ld.w	r3,r0[0x0]
8000b14c:	60 16       	ld.w	r6,r0[0x4]
8000b14e:	2f 80       	sub	r0,-8
8000b150:	58 06       	cp.w	r6,0
8000b152:	cf c0       	breq	8000b14a <__sfvwrite_r+0x9a>
8000b154:	8e 68       	ld.sh	r8,r7[0xc]
8000b156:	6e 24       	ld.w	r4,r7[0x8]
8000b158:	10 99       	mov	r9,r8
8000b15a:	e2 19 02 00 	andl	r9,0x200,COH
8000b15e:	c5 50       	breq	8000b208 <__sfvwrite_r+0x158>
8000b160:	08 36       	cp.w	r6,r4
8000b162:	c4 43       	brcs	8000b1ea <__sfvwrite_r+0x13a>
8000b164:	10 99       	mov	r9,r8
8000b166:	e2 19 04 80 	andl	r9,0x480,COH
8000b16a:	c4 00       	breq	8000b1ea <__sfvwrite_r+0x13a>
8000b16c:	6e 4b       	ld.w	r11,r7[0x10]
8000b16e:	6e 09       	ld.w	r9,r7[0x0]
8000b170:	16 19       	sub	r9,r11
8000b172:	50 09       	stdsp	sp[0x0],r9
8000b174:	6e 59       	ld.w	r9,r7[0x14]
8000b176:	10 9c       	mov	r12,r8
8000b178:	f2 09 00 1a 	add	r10,r9,r9<<0x1
8000b17c:	30 28       	mov	r8,2
8000b17e:	f4 08 0c 08 	divs	r8,r10,r8
8000b182:	fa e9 00 04 	st.d	sp[4],r8
8000b186:	10 94       	mov	r4,r8
8000b188:	40 09       	lddsp	r9,sp[0x0]
8000b18a:	e2 1c 04 00 	andl	r12,0x400,COH
8000b18e:	2f f9       	sub	r9,-1
8000b190:	0c 09       	add	r9,r6
8000b192:	12 38       	cp.w	r8,r9
8000b194:	f2 04 17 30 	movlo	r4,r9
8000b198:	58 0c       	cp.w	r12,0
8000b19a:	c1 10       	breq	8000b1bc <__sfvwrite_r+0x10c>
8000b19c:	08 9b       	mov	r11,r4
8000b19e:	0a 9c       	mov	r12,r5
8000b1a0:	fe b0 e0 6c 	rcall	80007278 <_malloc_r>
8000b1a4:	18 92       	mov	r2,r12
8000b1a6:	c1 40       	breq	8000b1ce <__sfvwrite_r+0x11e>
8000b1a8:	40 0a       	lddsp	r10,sp[0x0]
8000b1aa:	6e 4b       	ld.w	r11,r7[0x10]
8000b1ac:	fe b0 e2 82 	rcall	800076b0 <memcpy>
8000b1b0:	8e 68       	ld.sh	r8,r7[0xc]
8000b1b2:	e0 18 fb 7f 	andl	r8,0xfb7f
8000b1b6:	a7 b8       	sbr	r8,0x7
8000b1b8:	ae 68       	st.h	r7[0xc],r8
8000b1ba:	c0 d8       	rjmp	8000b1d4 <__sfvwrite_r+0x124>
8000b1bc:	08 9a       	mov	r10,r4
8000b1be:	0a 9c       	mov	r12,r5
8000b1c0:	fe b0 e3 24 	rcall	80007808 <_realloc_r>
8000b1c4:	18 92       	mov	r2,r12
8000b1c6:	c0 71       	brne	8000b1d4 <__sfvwrite_r+0x124>
8000b1c8:	6e 4b       	ld.w	r11,r7[0x10]
8000b1ca:	0a 9c       	mov	r12,r5
8000b1cc:	ca ce       	rcall	8000af24 <_free_r>
8000b1ce:	30 c8       	mov	r8,12
8000b1d0:	8b 38       	st.w	r5[0xc],r8
8000b1d2:	cb 18       	rjmp	8000b334 <__sfvwrite_r+0x284>
8000b1d4:	40 0a       	lddsp	r10,sp[0x0]
8000b1d6:	40 09       	lddsp	r9,sp[0x0]
8000b1d8:	e8 0a 01 0a 	sub	r10,r4,r10
8000b1dc:	e4 09 00 08 	add	r8,r2,r9
8000b1e0:	8f 54       	st.w	r7[0x14],r4
8000b1e2:	8f 2a       	st.w	r7[0x8],r10
8000b1e4:	8f 08       	st.w	r7[0x0],r8
8000b1e6:	8f 42       	st.w	r7[0x10],r2
8000b1e8:	0c 94       	mov	r4,r6
8000b1ea:	08 36       	cp.w	r6,r4
8000b1ec:	ec 04 17 30 	movlo	r4,r6
8000b1f0:	06 9b       	mov	r11,r3
8000b1f2:	08 9a       	mov	r10,r4
8000b1f4:	6e 0c       	ld.w	r12,r7[0x0]
8000b1f6:	c3 ad       	rcall	8000b46a <memmove>
8000b1f8:	6e 08       	ld.w	r8,r7[0x0]
8000b1fa:	08 08       	add	r8,r4
8000b1fc:	8f 08       	st.w	r7[0x0],r8
8000b1fe:	6e 28       	ld.w	r8,r7[0x8]
8000b200:	08 18       	sub	r8,r4
8000b202:	0c 94       	mov	r4,r6
8000b204:	8f 28       	st.w	r7[0x8],r8
8000b206:	c2 e8       	rjmp	8000b262 <__sfvwrite_r+0x1b2>
8000b208:	08 36       	cp.w	r6,r4
8000b20a:	5f ba       	srhi	r10
8000b20c:	6e 0c       	ld.w	r12,r7[0x0]
8000b20e:	6e 48       	ld.w	r8,r7[0x10]
8000b210:	10 3c       	cp.w	r12,r8
8000b212:	5f b8       	srhi	r8
8000b214:	f5 e8 00 08 	and	r8,r10,r8
8000b218:	f2 08 18 00 	cp.b	r8,r9
8000b21c:	c0 d0       	breq	8000b236 <__sfvwrite_r+0x186>
8000b21e:	06 9b       	mov	r11,r3
8000b220:	08 9a       	mov	r10,r4
8000b222:	c2 4d       	rcall	8000b46a <memmove>
8000b224:	6e 08       	ld.w	r8,r7[0x0]
8000b226:	08 08       	add	r8,r4
8000b228:	0e 9b       	mov	r11,r7
8000b22a:	8f 08       	st.w	r7[0x0],r8
8000b22c:	0a 9c       	mov	r12,r5
8000b22e:	fe b0 fd 09 	rcall	8000ac40 <_fflush_r>
8000b232:	c1 80       	breq	8000b262 <__sfvwrite_r+0x1b2>
8000b234:	c8 08       	rjmp	8000b334 <__sfvwrite_r+0x284>
8000b236:	6e 59       	ld.w	r9,r7[0x14]
8000b238:	12 36       	cp.w	r6,r9
8000b23a:	c0 a3       	brcs	8000b24e <__sfvwrite_r+0x19e>
8000b23c:	6e a8       	ld.w	r8,r7[0x28]
8000b23e:	06 9a       	mov	r10,r3
8000b240:	6e 8b       	ld.w	r11,r7[0x20]
8000b242:	0a 9c       	mov	r12,r5
8000b244:	5d 18       	icall	r8
8000b246:	18 94       	mov	r4,r12
8000b248:	e0 89 00 0d 	brgt	8000b262 <__sfvwrite_r+0x1b2>
8000b24c:	c7 48       	rjmp	8000b334 <__sfvwrite_r+0x284>
8000b24e:	0c 9a       	mov	r10,r6
8000b250:	06 9b       	mov	r11,r3
8000b252:	c0 cd       	rcall	8000b46a <memmove>
8000b254:	6e 08       	ld.w	r8,r7[0x0]
8000b256:	0c 08       	add	r8,r6
8000b258:	0c 94       	mov	r4,r6
8000b25a:	8f 08       	st.w	r7[0x0],r8
8000b25c:	6e 28       	ld.w	r8,r7[0x8]
8000b25e:	0c 18       	sub	r8,r6
8000b260:	8f 28       	st.w	r7[0x8],r8
8000b262:	62 28       	ld.w	r8,r1[0x8]
8000b264:	08 18       	sub	r8,r4
8000b266:	83 28       	st.w	r1[0x8],r8
8000b268:	c6 b0       	breq	8000b33e <__sfvwrite_r+0x28e>
8000b26a:	08 16       	sub	r6,r4
8000b26c:	08 03       	add	r3,r4
8000b26e:	c7 1b       	rjmp	8000b150 <__sfvwrite_r+0xa0>
8000b270:	60 03       	ld.w	r3,r0[0x0]
8000b272:	60 11       	ld.w	r1,r0[0x4]
8000b274:	30 08       	mov	r8,0
8000b276:	2f 80       	sub	r0,-8
8000b278:	50 08       	stdsp	sp[0x0],r8
8000b27a:	58 01       	cp.w	r1,0
8000b27c:	cf a0       	breq	8000b270 <__sfvwrite_r+0x1c0>
8000b27e:	40 0a       	lddsp	r10,sp[0x0]
8000b280:	58 0a       	cp.w	r10,0
8000b282:	c1 41       	brne	8000b2aa <__sfvwrite_r+0x1fa>
8000b284:	e2 c6 ff ff 	sub	r6,r1,-1
8000b288:	02 9a       	mov	r10,r1
8000b28a:	30 ab       	mov	r11,10
8000b28c:	06 9c       	mov	r12,r3
8000b28e:	ce 3c       	rcall	8000b454 <memchr>
8000b290:	f8 c8 ff ff 	sub	r8,r12,-1
8000b294:	58 0c       	cp.w	r12,0
8000b296:	f1 d3 e1 16 	subne	r6,r8,r3
8000b29a:	f9 b9 01 01 	movne	r9,1
8000b29e:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000b2a2:	f9 b8 00 01 	moveq	r8,1
8000b2a6:	fb f8 0a 00 	st.weq	sp[0x0],r8
8000b2aa:	02 36       	cp.w	r6,r1
8000b2ac:	ec 04 17 80 	movls	r4,r6
8000b2b0:	e2 04 17 b0 	movhi	r4,r1
8000b2b4:	6e 59       	ld.w	r9,r7[0x14]
8000b2b6:	6e 25       	ld.w	r5,r7[0x8]
8000b2b8:	f2 05 00 05 	add	r5,r9,r5
8000b2bc:	0a 34       	cp.w	r4,r5
8000b2be:	5f 9a       	srgt	r10
8000b2c0:	6e 0c       	ld.w	r12,r7[0x0]
8000b2c2:	6e 48       	ld.w	r8,r7[0x10]
8000b2c4:	10 3c       	cp.w	r12,r8
8000b2c6:	5f b8       	srhi	r8
8000b2c8:	f5 e8 00 08 	and	r8,r10,r8
8000b2cc:	30 0a       	mov	r10,0
8000b2ce:	f4 08 18 00 	cp.b	r8,r10
8000b2d2:	c0 d0       	breq	8000b2ec <__sfvwrite_r+0x23c>
8000b2d4:	06 9b       	mov	r11,r3
8000b2d6:	0a 9a       	mov	r10,r5
8000b2d8:	cc 9c       	rcall	8000b46a <memmove>
8000b2da:	6e 08       	ld.w	r8,r7[0x0]
8000b2dc:	0a 08       	add	r8,r5
8000b2de:	0e 9b       	mov	r11,r7
8000b2e0:	8f 08       	st.w	r7[0x0],r8
8000b2e2:	40 1c       	lddsp	r12,sp[0x4]
8000b2e4:	fe b0 fc ae 	rcall	8000ac40 <_fflush_r>
8000b2e8:	c1 70       	breq	8000b316 <__sfvwrite_r+0x266>
8000b2ea:	c2 58       	rjmp	8000b334 <__sfvwrite_r+0x284>
8000b2ec:	12 34       	cp.w	r4,r9
8000b2ee:	c0 a5       	brlt	8000b302 <__sfvwrite_r+0x252>
8000b2f0:	6e a8       	ld.w	r8,r7[0x28]
8000b2f2:	06 9a       	mov	r10,r3
8000b2f4:	6e 8b       	ld.w	r11,r7[0x20]
8000b2f6:	40 1c       	lddsp	r12,sp[0x4]
8000b2f8:	5d 18       	icall	r8
8000b2fa:	18 95       	mov	r5,r12
8000b2fc:	e0 89 00 0d 	brgt	8000b316 <__sfvwrite_r+0x266>
8000b300:	c1 a8       	rjmp	8000b334 <__sfvwrite_r+0x284>
8000b302:	08 9a       	mov	r10,r4
8000b304:	06 9b       	mov	r11,r3
8000b306:	cb 2c       	rcall	8000b46a <memmove>
8000b308:	6e 08       	ld.w	r8,r7[0x0]
8000b30a:	08 08       	add	r8,r4
8000b30c:	08 95       	mov	r5,r4
8000b30e:	8f 08       	st.w	r7[0x0],r8
8000b310:	6e 28       	ld.w	r8,r7[0x8]
8000b312:	08 18       	sub	r8,r4
8000b314:	8f 28       	st.w	r7[0x8],r8
8000b316:	0a 16       	sub	r6,r5
8000b318:	c0 71       	brne	8000b326 <__sfvwrite_r+0x276>
8000b31a:	0e 9b       	mov	r11,r7
8000b31c:	40 1c       	lddsp	r12,sp[0x4]
8000b31e:	fe b0 fc 91 	rcall	8000ac40 <_fflush_r>
8000b322:	c0 91       	brne	8000b334 <__sfvwrite_r+0x284>
8000b324:	50 06       	stdsp	sp[0x0],r6
8000b326:	64 28       	ld.w	r8,r2[0x8]
8000b328:	0a 18       	sub	r8,r5
8000b32a:	85 28       	st.w	r2[0x8],r8
8000b32c:	c0 90       	breq	8000b33e <__sfvwrite_r+0x28e>
8000b32e:	0a 11       	sub	r1,r5
8000b330:	0a 03       	add	r3,r5
8000b332:	ca 4b       	rjmp	8000b27a <__sfvwrite_r+0x1ca>
8000b334:	8e 68       	ld.sh	r8,r7[0xc]
8000b336:	a7 a8       	sbr	r8,0x6
8000b338:	ae 68       	st.h	r7[0xc],r8
8000b33a:	3f fc       	mov	r12,-1
8000b33c:	c0 28       	rjmp	8000b340 <__sfvwrite_r+0x290>
8000b33e:	30 0c       	mov	r12,0
8000b340:	2f dd       	sub	sp,-12
8000b342:	d8 32       	popm	r0-r7,pc

8000b344 <_fwalk>:
8000b344:	d4 31       	pushm	r0-r7,lr
8000b346:	30 05       	mov	r5,0
8000b348:	16 91       	mov	r1,r11
8000b34a:	f8 c7 ff 28 	sub	r7,r12,-216
8000b34e:	0a 92       	mov	r2,r5
8000b350:	fe b0 fc fe 	rcall	8000ad4c <__sfp_lock_acquire>
8000b354:	3f f3       	mov	r3,-1
8000b356:	c1 68       	rjmp	8000b382 <_fwalk+0x3e>
8000b358:	6e 26       	ld.w	r6,r7[0x8]
8000b35a:	6e 14       	ld.w	r4,r7[0x4]
8000b35c:	2f 46       	sub	r6,-12
8000b35e:	c0 c8       	rjmp	8000b376 <_fwalk+0x32>
8000b360:	8c 08       	ld.sh	r8,r6[0x0]
8000b362:	e4 08 19 00 	cp.h	r8,r2
8000b366:	c0 70       	breq	8000b374 <_fwalk+0x30>
8000b368:	8c 18       	ld.sh	r8,r6[0x2]
8000b36a:	e6 08 19 00 	cp.h	r8,r3
8000b36e:	c0 30       	breq	8000b374 <_fwalk+0x30>
8000b370:	5d 11       	icall	r1
8000b372:	18 45       	or	r5,r12
8000b374:	2a 46       	sub	r6,-92
8000b376:	20 14       	sub	r4,1
8000b378:	ec cc 00 0c 	sub	r12,r6,12
8000b37c:	58 04       	cp.w	r4,0
8000b37e:	cf 14       	brge	8000b360 <_fwalk+0x1c>
8000b380:	6e 07       	ld.w	r7,r7[0x0]
8000b382:	58 07       	cp.w	r7,0
8000b384:	ce a1       	brne	8000b358 <_fwalk+0x14>
8000b386:	fe b0 fc e4 	rcall	8000ad4e <__sfp_lock_release>
8000b38a:	0a 9c       	mov	r12,r5
8000b38c:	d8 32       	popm	r0-r7,pc
8000b38e:	d7 03       	nop

8000b390 <_localeconv_r>:
8000b390:	fe cc d5 54 	sub	r12,pc,-10924
8000b394:	5e fc       	retal	r12
8000b396:	d7 03       	nop

8000b398 <__smakebuf_r>:
8000b398:	d4 21       	pushm	r4-r7,lr
8000b39a:	20 fd       	sub	sp,60
8000b39c:	96 68       	ld.sh	r8,r11[0xc]
8000b39e:	16 97       	mov	r7,r11
8000b3a0:	18 96       	mov	r6,r12
8000b3a2:	e2 18 00 02 	andl	r8,0x2,COH
8000b3a6:	c3 d1       	brne	8000b420 <__smakebuf_r+0x88>
8000b3a8:	96 7b       	ld.sh	r11,r11[0xe]
8000b3aa:	f0 0b 19 00 	cp.h	r11,r8
8000b3ae:	c0 55       	brlt	8000b3b8 <__smakebuf_r+0x20>
8000b3b0:	1a 9a       	mov	r10,sp
8000b3b2:	e0 a0 04 81 	rcall	8000bcb4 <_fstat_r>
8000b3b6:	c0 f4       	brge	8000b3d4 <__smakebuf_r+0x3c>
8000b3b8:	8e 65       	ld.sh	r5,r7[0xc]
8000b3ba:	0a 98       	mov	r8,r5
8000b3bc:	ab b8       	sbr	r8,0xb
8000b3be:	e2 15 00 80 	andl	r5,0x80,COH
8000b3c2:	ae 68       	st.h	r7[0xc],r8
8000b3c4:	30 04       	mov	r4,0
8000b3c6:	e0 68 04 00 	mov	r8,1024
8000b3ca:	f9 b5 01 40 	movne	r5,64
8000b3ce:	f0 05 17 00 	moveq	r5,r8
8000b3d2:	c1 c8       	rjmp	8000b40a <__smakebuf_r+0x72>
8000b3d4:	40 18       	lddsp	r8,sp[0x4]
8000b3d6:	e2 18 f0 00 	andl	r8,0xf000,COH
8000b3da:	e0 48 20 00 	cp.w	r8,8192
8000b3de:	5f 04       	sreq	r4
8000b3e0:	e0 48 80 00 	cp.w	r8,32768
8000b3e4:	c0 e1       	brne	8000b400 <__smakebuf_r+0x68>
8000b3e6:	6e b9       	ld.w	r9,r7[0x2c]
8000b3e8:	fe c8 f9 1c 	sub	r8,pc,-1764
8000b3ec:	10 39       	cp.w	r9,r8
8000b3ee:	c0 91       	brne	8000b400 <__smakebuf_r+0x68>
8000b3f0:	8e 68       	ld.sh	r8,r7[0xc]
8000b3f2:	e0 65 04 00 	mov	r5,1024
8000b3f6:	ab a8       	sbr	r8,0xa
8000b3f8:	ef 45 00 50 	st.w	r7[80],r5
8000b3fc:	ae 68       	st.h	r7[0xc],r8
8000b3fe:	c0 68       	rjmp	8000b40a <__smakebuf_r+0x72>
8000b400:	8e 68       	ld.sh	r8,r7[0xc]
8000b402:	e0 65 04 00 	mov	r5,1024
8000b406:	ab b8       	sbr	r8,0xb
8000b408:	ae 68       	st.h	r7[0xc],r8
8000b40a:	0a 9b       	mov	r11,r5
8000b40c:	0c 9c       	mov	r12,r6
8000b40e:	fe b0 df 35 	rcall	80007278 <_malloc_r>
8000b412:	8e 68       	ld.sh	r8,r7[0xc]
8000b414:	c0 d1       	brne	8000b42e <__smakebuf_r+0x96>
8000b416:	ed b8 00 09 	bld	r8,0x9
8000b41a:	c1 b0       	breq	8000b450 <__smakebuf_r+0xb8>
8000b41c:	a1 b8       	sbr	r8,0x1
8000b41e:	ae 68       	st.h	r7[0xc],r8
8000b420:	ee c8 ff b9 	sub	r8,r7,-71
8000b424:	8f 48       	st.w	r7[0x10],r8
8000b426:	8f 08       	st.w	r7[0x0],r8
8000b428:	30 18       	mov	r8,1
8000b42a:	8f 58       	st.w	r7[0x14],r8
8000b42c:	c1 28       	rjmp	8000b450 <__smakebuf_r+0xb8>
8000b42e:	a7 b8       	sbr	r8,0x7
8000b430:	8f 4c       	st.w	r7[0x10],r12
8000b432:	ae 68       	st.h	r7[0xc],r8
8000b434:	8f 55       	st.w	r7[0x14],r5
8000b436:	fe c8 06 e6 	sub	r8,pc,1766
8000b43a:	8f 0c       	st.w	r7[0x0],r12
8000b43c:	8d a8       	st.w	r6[0x28],r8
8000b43e:	58 04       	cp.w	r4,0
8000b440:	c0 80       	breq	8000b450 <__smakebuf_r+0xb8>
8000b442:	8e 7c       	ld.sh	r12,r7[0xe]
8000b444:	fe b0 e3 94 	rcall	80007b6c <isatty>
8000b448:	c0 40       	breq	8000b450 <__smakebuf_r+0xb8>
8000b44a:	8e 68       	ld.sh	r8,r7[0xc]
8000b44c:	a1 a8       	sbr	r8,0x0
8000b44e:	ae 68       	st.h	r7[0xc],r8
8000b450:	2f 1d       	sub	sp,-60
8000b452:	d8 22       	popm	r4-r7,pc

8000b454 <memchr>:
8000b454:	f7 db c0 08 	bfextu	r11,r11,0x0,0x8
8000b458:	c0 68       	rjmp	8000b464 <memchr+0x10>
8000b45a:	20 1a       	sub	r10,1
8000b45c:	19 88       	ld.ub	r8,r12[0x0]
8000b45e:	16 38       	cp.w	r8,r11
8000b460:	5e 0c       	reteq	r12
8000b462:	2f fc       	sub	r12,-1
8000b464:	58 0a       	cp.w	r10,0
8000b466:	cf a1       	brne	8000b45a <memchr+0x6>
8000b468:	5e fa       	retal	r10

8000b46a <memmove>:
8000b46a:	d4 01       	pushm	lr
8000b46c:	18 3b       	cp.w	r11,r12
8000b46e:	c1 92       	brcc	8000b4a0 <memmove+0x36>
8000b470:	f6 0a 00 09 	add	r9,r11,r10
8000b474:	12 3c       	cp.w	r12,r9
8000b476:	c1 52       	brcc	8000b4a0 <memmove+0x36>
8000b478:	f8 0a 00 0b 	add	r11,r12,r10
8000b47c:	30 08       	mov	r8,0
8000b47e:	c0 68       	rjmp	8000b48a <memmove+0x20>
8000b480:	f2 08 07 0e 	ld.ub	lr,r9[r8]
8000b484:	20 1a       	sub	r10,1
8000b486:	f6 08 0b 0e 	st.b	r11[r8],lr
8000b48a:	20 18       	sub	r8,1
8000b48c:	58 0a       	cp.w	r10,0
8000b48e:	cf 91       	brne	8000b480 <memmove+0x16>
8000b490:	d8 02       	popm	pc
8000b492:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000b496:	20 1a       	sub	r10,1
8000b498:	f8 08 0b 09 	st.b	r12[r8],r9
8000b49c:	2f f8       	sub	r8,-1
8000b49e:	c0 28       	rjmp	8000b4a2 <memmove+0x38>
8000b4a0:	30 08       	mov	r8,0
8000b4a2:	58 0a       	cp.w	r10,0
8000b4a4:	cf 71       	brne	8000b492 <memmove+0x28>
8000b4a6:	d8 02       	popm	pc

8000b4a8 <__hi0bits>:
8000b4a8:	18 98       	mov	r8,r12
8000b4aa:	e0 1c 00 00 	andl	r12,0x0
8000b4ae:	f0 09 15 10 	lsl	r9,r8,0x10
8000b4b2:	58 0c       	cp.w	r12,0
8000b4b4:	f2 08 17 00 	moveq	r8,r9
8000b4b8:	f9 bc 00 10 	moveq	r12,16
8000b4bc:	f9 bc 01 00 	movne	r12,0
8000b4c0:	10 9a       	mov	r10,r8
8000b4c2:	f0 09 15 08 	lsl	r9,r8,0x8
8000b4c6:	e6 1a ff 00 	andh	r10,0xff00,COH
8000b4ca:	f7 bc 00 f8 	subeq	r12,-8
8000b4ce:	f2 08 17 00 	moveq	r8,r9
8000b4d2:	10 9a       	mov	r10,r8
8000b4d4:	f0 09 15 04 	lsl	r9,r8,0x4
8000b4d8:	e6 1a f0 00 	andh	r10,0xf000,COH
8000b4dc:	f7 bc 00 fc 	subeq	r12,-4
8000b4e0:	f2 08 17 00 	moveq	r8,r9
8000b4e4:	10 9a       	mov	r10,r8
8000b4e6:	f0 09 15 02 	lsl	r9,r8,0x2
8000b4ea:	e6 1a c0 00 	andh	r10,0xc000,COH
8000b4ee:	f7 bc 00 fe 	subeq	r12,-2
8000b4f2:	f2 08 17 00 	moveq	r8,r9
8000b4f6:	58 08       	cp.w	r8,0
8000b4f8:	5e 5c       	retlt	r12
8000b4fa:	ed b8 00 1e 	bld	r8,0x1e
8000b4fe:	f9 bc 01 20 	movne	r12,32
8000b502:	f7 bc 00 ff 	subeq	r12,-1
8000b506:	5e fc       	retal	r12

8000b508 <__lo0bits>:
8000b508:	18 99       	mov	r9,r12
8000b50a:	78 08       	ld.w	r8,r12[0x0]
8000b50c:	f9 d8 c0 03 	bfextu	r12,r8,0x0,0x3
8000b510:	c1 50       	breq	8000b53a <__lo0bits+0x32>
8000b512:	ed b8 00 00 	bld	r8,0x0
8000b516:	c0 21       	brne	8000b51a <__lo0bits+0x12>
8000b518:	5e fd       	retal	0
8000b51a:	10 9b       	mov	r11,r8
8000b51c:	f0 0a 16 01 	lsr	r10,r8,0x1
8000b520:	e2 1b 00 02 	andl	r11,0x2,COH
8000b524:	a3 88       	lsr	r8,0x2
8000b526:	58 0b       	cp.w	r11,0
8000b528:	f3 fa 1a 00 	st.wne	r9[0x0],r10
8000b52c:	f9 bc 01 01 	movne	r12,1
8000b530:	f3 f8 0a 00 	st.weq	r9[0x0],r8
8000b534:	f9 bc 00 02 	moveq	r12,2
8000b538:	5e fc       	retal	r12
8000b53a:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
8000b53e:	f0 0b 16 10 	lsr	r11,r8,0x10
8000b542:	58 0a       	cp.w	r10,0
8000b544:	f6 08 17 00 	moveq	r8,r11
8000b548:	f9 bc 00 10 	moveq	r12,16
8000b54c:	f7 d8 c0 08 	bfextu	r11,r8,0x0,0x8
8000b550:	f0 0a 16 08 	lsr	r10,r8,0x8
8000b554:	58 0b       	cp.w	r11,0
8000b556:	f7 bc 00 f8 	subeq	r12,-8
8000b55a:	f4 08 17 00 	moveq	r8,r10
8000b55e:	f7 d8 c0 04 	bfextu	r11,r8,0x0,0x4
8000b562:	f0 0a 16 04 	lsr	r10,r8,0x4
8000b566:	58 0b       	cp.w	r11,0
8000b568:	f7 bc 00 fc 	subeq	r12,-4
8000b56c:	f4 08 17 00 	moveq	r8,r10
8000b570:	f7 d8 c0 02 	bfextu	r11,r8,0x0,0x2
8000b574:	f0 0a 16 02 	lsr	r10,r8,0x2
8000b578:	58 0b       	cp.w	r11,0
8000b57a:	f7 bc 00 fe 	subeq	r12,-2
8000b57e:	f4 08 17 00 	moveq	r8,r10
8000b582:	ed b8 00 00 	bld	r8,0x0
8000b586:	c0 60       	breq	8000b592 <__lo0bits+0x8a>
8000b588:	a1 98       	lsr	r8,0x1
8000b58a:	c0 31       	brne	8000b590 <__lo0bits+0x88>
8000b58c:	32 0c       	mov	r12,32
8000b58e:	5e fc       	retal	r12
8000b590:	2f fc       	sub	r12,-1
8000b592:	93 08       	st.w	r9[0x0],r8
8000b594:	5e fc       	retal	r12

8000b596 <__mcmp>:
8000b596:	d4 01       	pushm	lr
8000b598:	18 98       	mov	r8,r12
8000b59a:	76 49       	ld.w	r9,r11[0x10]
8000b59c:	78 4c       	ld.w	r12,r12[0x10]
8000b59e:	12 1c       	sub	r12,r9
8000b5a0:	c1 31       	brne	8000b5c6 <__mcmp+0x30>
8000b5a2:	2f b9       	sub	r9,-5
8000b5a4:	a3 69       	lsl	r9,0x2
8000b5a6:	12 0b       	add	r11,r9
8000b5a8:	f0 09 00 09 	add	r9,r8,r9
8000b5ac:	2e c8       	sub	r8,-20
8000b5ae:	13 4e       	ld.w	lr,--r9
8000b5b0:	17 4a       	ld.w	r10,--r11
8000b5b2:	14 3e       	cp.w	lr,r10
8000b5b4:	c0 60       	breq	8000b5c0 <__mcmp+0x2a>
8000b5b6:	f9 bc 03 ff 	movlo	r12,-1
8000b5ba:	f9 bc 02 01 	movhs	r12,1
8000b5be:	d8 02       	popm	pc
8000b5c0:	10 39       	cp.w	r9,r8
8000b5c2:	fe 9b ff f6 	brhi	8000b5ae <__mcmp+0x18>
8000b5c6:	d8 02       	popm	pc

8000b5c8 <_Bfree>:
8000b5c8:	d4 21       	pushm	r4-r7,lr
8000b5ca:	18 97       	mov	r7,r12
8000b5cc:	16 95       	mov	r5,r11
8000b5ce:	78 96       	ld.w	r6,r12[0x24]
8000b5d0:	58 06       	cp.w	r6,0
8000b5d2:	c0 91       	brne	8000b5e4 <_Bfree+0x1c>
8000b5d4:	31 0c       	mov	r12,16
8000b5d6:	fe b0 de 49 	rcall	80007268 <malloc>
8000b5da:	99 36       	st.w	r12[0xc],r6
8000b5dc:	8f 9c       	st.w	r7[0x24],r12
8000b5de:	99 16       	st.w	r12[0x4],r6
8000b5e0:	99 26       	st.w	r12[0x8],r6
8000b5e2:	99 06       	st.w	r12[0x0],r6
8000b5e4:	58 05       	cp.w	r5,0
8000b5e6:	c0 90       	breq	8000b5f8 <_Bfree+0x30>
8000b5e8:	6a 19       	ld.w	r9,r5[0x4]
8000b5ea:	6e 98       	ld.w	r8,r7[0x24]
8000b5ec:	70 38       	ld.w	r8,r8[0xc]
8000b5ee:	f0 09 03 2a 	ld.w	r10,r8[r9<<0x2]
8000b5f2:	8b 0a       	st.w	r5[0x0],r10
8000b5f4:	f0 09 09 25 	st.w	r8[r9<<0x2],r5
8000b5f8:	d8 22       	popm	r4-r7,pc
8000b5fa:	d7 03       	nop

8000b5fc <_Balloc>:
8000b5fc:	d4 21       	pushm	r4-r7,lr
8000b5fe:	18 97       	mov	r7,r12
8000b600:	16 96       	mov	r6,r11
8000b602:	78 95       	ld.w	r5,r12[0x24]
8000b604:	58 05       	cp.w	r5,0
8000b606:	c0 91       	brne	8000b618 <_Balloc+0x1c>
8000b608:	31 0c       	mov	r12,16
8000b60a:	fe b0 de 2f 	rcall	80007268 <malloc>
8000b60e:	99 35       	st.w	r12[0xc],r5
8000b610:	8f 9c       	st.w	r7[0x24],r12
8000b612:	99 15       	st.w	r12[0x4],r5
8000b614:	99 25       	st.w	r12[0x8],r5
8000b616:	99 05       	st.w	r12[0x0],r5
8000b618:	6e 95       	ld.w	r5,r7[0x24]
8000b61a:	6a 38       	ld.w	r8,r5[0xc]
8000b61c:	58 08       	cp.w	r8,0
8000b61e:	c0 b1       	brne	8000b634 <_Balloc+0x38>
8000b620:	31 0a       	mov	r10,16
8000b622:	30 4b       	mov	r11,4
8000b624:	0e 9c       	mov	r12,r7
8000b626:	e0 a0 02 a7 	rcall	8000bb74 <_calloc_r>
8000b62a:	8b 3c       	st.w	r5[0xc],r12
8000b62c:	6e 98       	ld.w	r8,r7[0x24]
8000b62e:	70 3c       	ld.w	r12,r8[0xc]
8000b630:	58 0c       	cp.w	r12,0
8000b632:	c1 b0       	breq	8000b668 <_Balloc+0x6c>
8000b634:	6e 98       	ld.w	r8,r7[0x24]
8000b636:	70 38       	ld.w	r8,r8[0xc]
8000b638:	f0 06 00 28 	add	r8,r8,r6<<0x2
8000b63c:	70 0c       	ld.w	r12,r8[0x0]
8000b63e:	58 0c       	cp.w	r12,0
8000b640:	c0 40       	breq	8000b648 <_Balloc+0x4c>
8000b642:	78 09       	ld.w	r9,r12[0x0]
8000b644:	91 09       	st.w	r8[0x0],r9
8000b646:	c0 e8       	rjmp	8000b662 <_Balloc+0x66>
8000b648:	0e 9c       	mov	r12,r7
8000b64a:	30 17       	mov	r7,1
8000b64c:	0e 9b       	mov	r11,r7
8000b64e:	ee 06 09 47 	lsl	r7,r7,r6
8000b652:	ee ca ff fb 	sub	r10,r7,-5
8000b656:	a3 6a       	lsl	r10,0x2
8000b658:	e0 a0 02 8e 	rcall	8000bb74 <_calloc_r>
8000b65c:	c0 60       	breq	8000b668 <_Balloc+0x6c>
8000b65e:	99 16       	st.w	r12[0x4],r6
8000b660:	99 27       	st.w	r12[0x8],r7
8000b662:	30 08       	mov	r8,0
8000b664:	99 38       	st.w	r12[0xc],r8
8000b666:	99 48       	st.w	r12[0x10],r8
8000b668:	d8 22       	popm	r4-r7,pc
8000b66a:	d7 03       	nop

8000b66c <__d2b>:
8000b66c:	d4 31       	pushm	r0-r7,lr
8000b66e:	20 2d       	sub	sp,8
8000b670:	16 93       	mov	r3,r11
8000b672:	12 96       	mov	r6,r9
8000b674:	10 95       	mov	r5,r8
8000b676:	14 92       	mov	r2,r10
8000b678:	30 1b       	mov	r11,1
8000b67a:	cc 1f       	rcall	8000b5fc <_Balloc>
8000b67c:	f3 d3 c0 14 	bfextu	r9,r3,0x0,0x14
8000b680:	50 09       	stdsp	sp[0x0],r9
8000b682:	f1 d3 c0 1f 	bfextu	r8,r3,0x0,0x1f
8000b686:	b5 a9       	sbr	r9,0x14
8000b688:	f0 01 16 14 	lsr	r1,r8,0x14
8000b68c:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000b690:	18 94       	mov	r4,r12
8000b692:	58 02       	cp.w	r2,0
8000b694:	c1 d0       	breq	8000b6ce <__d2b+0x62>
8000b696:	fa cc ff f8 	sub	r12,sp,-8
8000b69a:	18 d2       	st.w	--r12,r2
8000b69c:	c3 6f       	rcall	8000b508 <__lo0bits>
8000b69e:	40 18       	lddsp	r8,sp[0x4]
8000b6a0:	c0 d0       	breq	8000b6ba <__d2b+0x4e>
8000b6a2:	40 09       	lddsp	r9,sp[0x0]
8000b6a4:	f8 0a 11 20 	rsub	r10,r12,32
8000b6a8:	f2 0a 09 4a 	lsl	r10,r9,r10
8000b6ac:	f5 e8 10 08 	or	r8,r10,r8
8000b6b0:	89 58       	st.w	r4[0x14],r8
8000b6b2:	f2 0c 0a 49 	lsr	r9,r9,r12
8000b6b6:	50 09       	stdsp	sp[0x0],r9
8000b6b8:	c0 28       	rjmp	8000b6bc <__d2b+0x50>
8000b6ba:	89 58       	st.w	r4[0x14],r8
8000b6bc:	40 08       	lddsp	r8,sp[0x0]
8000b6be:	58 08       	cp.w	r8,0
8000b6c0:	f9 b3 01 02 	movne	r3,2
8000b6c4:	f9 b3 00 01 	moveq	r3,1
8000b6c8:	89 68       	st.w	r4[0x18],r8
8000b6ca:	89 43       	st.w	r4[0x10],r3
8000b6cc:	c0 88       	rjmp	8000b6dc <__d2b+0x70>
8000b6ce:	1a 9c       	mov	r12,sp
8000b6d0:	c1 cf       	rcall	8000b508 <__lo0bits>
8000b6d2:	30 13       	mov	r3,1
8000b6d4:	40 08       	lddsp	r8,sp[0x0]
8000b6d6:	2e 0c       	sub	r12,-32
8000b6d8:	89 43       	st.w	r4[0x10],r3
8000b6da:	89 58       	st.w	r4[0x14],r8
8000b6dc:	58 01       	cp.w	r1,0
8000b6de:	c0 90       	breq	8000b6f0 <__d2b+0x84>
8000b6e0:	e2 c1 04 33 	sub	r1,r1,1075
8000b6e4:	18 01       	add	r1,r12
8000b6e6:	8d 01       	st.w	r6[0x0],r1
8000b6e8:	f8 0c 11 35 	rsub	r12,r12,53
8000b6ec:	8b 0c       	st.w	r5[0x0],r12
8000b6ee:	c0 c8       	rjmp	8000b706 <__d2b+0x9a>
8000b6f0:	e6 c8 ff fc 	sub	r8,r3,-4
8000b6f4:	f8 cc 04 32 	sub	r12,r12,1074
8000b6f8:	a5 73       	lsl	r3,0x5
8000b6fa:	8d 0c       	st.w	r6[0x0],r12
8000b6fc:	e8 08 03 2c 	ld.w	r12,r4[r8<<0x2]
8000b700:	cd 4e       	rcall	8000b4a8 <__hi0bits>
8000b702:	18 13       	sub	r3,r12
8000b704:	8b 03       	st.w	r5[0x0],r3
8000b706:	08 9c       	mov	r12,r4
8000b708:	2f ed       	sub	sp,-8
8000b70a:	d8 32       	popm	r0-r7,pc

8000b70c <__mdiff>:
8000b70c:	d4 31       	pushm	r0-r7,lr
8000b70e:	74 48       	ld.w	r8,r10[0x10]
8000b710:	76 45       	ld.w	r5,r11[0x10]
8000b712:	16 97       	mov	r7,r11
8000b714:	14 96       	mov	r6,r10
8000b716:	10 15       	sub	r5,r8
8000b718:	c1 31       	brne	8000b73e <__mdiff+0x32>
8000b71a:	2f b8       	sub	r8,-5
8000b71c:	ee ce ff ec 	sub	lr,r7,-20
8000b720:	a3 68       	lsl	r8,0x2
8000b722:	f4 08 00 0b 	add	r11,r10,r8
8000b726:	ee 08 00 08 	add	r8,r7,r8
8000b72a:	11 4a       	ld.w	r10,--r8
8000b72c:	17 49       	ld.w	r9,--r11
8000b72e:	12 3a       	cp.w	r10,r9
8000b730:	c0 30       	breq	8000b736 <__mdiff+0x2a>
8000b732:	c0 e2       	brcc	8000b74e <__mdiff+0x42>
8000b734:	c0 78       	rjmp	8000b742 <__mdiff+0x36>
8000b736:	1c 38       	cp.w	r8,lr
8000b738:	fe 9b ff f9 	brhi	8000b72a <__mdiff+0x1e>
8000b73c:	c4 98       	rjmp	8000b7ce <__mdiff+0xc2>
8000b73e:	58 05       	cp.w	r5,0
8000b740:	c0 64       	brge	8000b74c <__mdiff+0x40>
8000b742:	0e 98       	mov	r8,r7
8000b744:	30 15       	mov	r5,1
8000b746:	0c 97       	mov	r7,r6
8000b748:	10 96       	mov	r6,r8
8000b74a:	c0 28       	rjmp	8000b74e <__mdiff+0x42>
8000b74c:	30 05       	mov	r5,0
8000b74e:	6e 1b       	ld.w	r11,r7[0x4]
8000b750:	c5 6f       	rcall	8000b5fc <_Balloc>
8000b752:	6e 49       	ld.w	r9,r7[0x10]
8000b754:	6c 44       	ld.w	r4,r6[0x10]
8000b756:	99 35       	st.w	r12[0xc],r5
8000b758:	2f b4       	sub	r4,-5
8000b75a:	f2 c5 ff fb 	sub	r5,r9,-5
8000b75e:	ec 04 00 24 	add	r4,r6,r4<<0x2
8000b762:	ee 05 00 25 	add	r5,r7,r5<<0x2
8000b766:	2e c6       	sub	r6,-20
8000b768:	2e c7       	sub	r7,-20
8000b76a:	f8 c8 ff ec 	sub	r8,r12,-20
8000b76e:	30 0a       	mov	r10,0
8000b770:	0f 0e       	ld.w	lr,r7++
8000b772:	0d 0b       	ld.w	r11,r6++
8000b774:	fc 02 16 10 	lsr	r2,lr,0x10
8000b778:	f6 03 16 10 	lsr	r3,r11,0x10
8000b77c:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000b780:	e4 03 01 03 	sub	r3,r2,r3
8000b784:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000b788:	fc 0b 01 0b 	sub	r11,lr,r11
8000b78c:	f6 0a 00 0a 	add	r10,r11,r10
8000b790:	b0 1a       	st.h	r8[0x2],r10
8000b792:	b1 4a       	asr	r10,0x10
8000b794:	e6 0a 00 0a 	add	r10,r3,r10
8000b798:	b0 0a       	st.h	r8[0x0],r10
8000b79a:	2f c8       	sub	r8,-4
8000b79c:	b1 4a       	asr	r10,0x10
8000b79e:	08 36       	cp.w	r6,r4
8000b7a0:	ce 83       	brcs	8000b770 <__mdiff+0x64>
8000b7a2:	c0 d8       	rjmp	8000b7bc <__mdiff+0xb0>
8000b7a4:	0f 0b       	ld.w	r11,r7++
8000b7a6:	f6 0e 16 10 	lsr	lr,r11,0x10
8000b7aa:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000b7ae:	16 0a       	add	r10,r11
8000b7b0:	b0 1a       	st.h	r8[0x2],r10
8000b7b2:	b1 4a       	asr	r10,0x10
8000b7b4:	1c 0a       	add	r10,lr
8000b7b6:	b0 0a       	st.h	r8[0x0],r10
8000b7b8:	2f c8       	sub	r8,-4
8000b7ba:	b1 4a       	asr	r10,0x10
8000b7bc:	0a 37       	cp.w	r7,r5
8000b7be:	cf 33       	brcs	8000b7a4 <__mdiff+0x98>
8000b7c0:	c0 28       	rjmp	8000b7c4 <__mdiff+0xb8>
8000b7c2:	20 19       	sub	r9,1
8000b7c4:	11 4a       	ld.w	r10,--r8
8000b7c6:	58 0a       	cp.w	r10,0
8000b7c8:	cf d0       	breq	8000b7c2 <__mdiff+0xb6>
8000b7ca:	99 49       	st.w	r12[0x10],r9
8000b7cc:	d8 32       	popm	r0-r7,pc
8000b7ce:	30 0b       	mov	r11,0
8000b7d0:	c1 6f       	rcall	8000b5fc <_Balloc>
8000b7d2:	30 18       	mov	r8,1
8000b7d4:	99 48       	st.w	r12[0x10],r8
8000b7d6:	30 08       	mov	r8,0
8000b7d8:	99 58       	st.w	r12[0x14],r8
8000b7da:	d8 32       	popm	r0-r7,pc

8000b7dc <__lshift>:
8000b7dc:	d4 31       	pushm	r0-r7,lr
8000b7de:	16 97       	mov	r7,r11
8000b7e0:	76 46       	ld.w	r6,r11[0x10]
8000b7e2:	f4 02 14 05 	asr	r2,r10,0x5
8000b7e6:	2f f6       	sub	r6,-1
8000b7e8:	14 93       	mov	r3,r10
8000b7ea:	18 94       	mov	r4,r12
8000b7ec:	04 06       	add	r6,r2
8000b7ee:	76 1b       	ld.w	r11,r11[0x4]
8000b7f0:	6e 28       	ld.w	r8,r7[0x8]
8000b7f2:	c0 38       	rjmp	8000b7f8 <__lshift+0x1c>
8000b7f4:	2f fb       	sub	r11,-1
8000b7f6:	a1 78       	lsl	r8,0x1
8000b7f8:	10 36       	cp.w	r6,r8
8000b7fa:	fe 99 ff fd 	brgt	8000b7f4 <__lshift+0x18>
8000b7fe:	08 9c       	mov	r12,r4
8000b800:	cf ee       	rcall	8000b5fc <_Balloc>
8000b802:	30 09       	mov	r9,0
8000b804:	18 95       	mov	r5,r12
8000b806:	f8 c8 ff ec 	sub	r8,r12,-20
8000b80a:	12 9a       	mov	r10,r9
8000b80c:	c0 38       	rjmp	8000b812 <__lshift+0x36>
8000b80e:	10 aa       	st.w	r8++,r10
8000b810:	2f f9       	sub	r9,-1
8000b812:	04 39       	cp.w	r9,r2
8000b814:	cf d5       	brlt	8000b80e <__lshift+0x32>
8000b816:	6e 4b       	ld.w	r11,r7[0x10]
8000b818:	e7 d3 c0 05 	bfextu	r3,r3,0x0,0x5
8000b81c:	2f bb       	sub	r11,-5
8000b81e:	ee c9 ff ec 	sub	r9,r7,-20
8000b822:	ee 0b 00 2b 	add	r11,r7,r11<<0x2
8000b826:	58 03       	cp.w	r3,0
8000b828:	c1 30       	breq	8000b84e <__lshift+0x72>
8000b82a:	e6 0c 11 20 	rsub	r12,r3,32
8000b82e:	30 0a       	mov	r10,0
8000b830:	72 02       	ld.w	r2,r9[0x0]
8000b832:	e4 03 09 42 	lsl	r2,r2,r3
8000b836:	04 4a       	or	r10,r2
8000b838:	10 aa       	st.w	r8++,r10
8000b83a:	13 0a       	ld.w	r10,r9++
8000b83c:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000b840:	16 39       	cp.w	r9,r11
8000b842:	cf 73       	brcs	8000b830 <__lshift+0x54>
8000b844:	91 0a       	st.w	r8[0x0],r10
8000b846:	58 0a       	cp.w	r10,0
8000b848:	c0 70       	breq	8000b856 <__lshift+0x7a>
8000b84a:	2f f6       	sub	r6,-1
8000b84c:	c0 58       	rjmp	8000b856 <__lshift+0x7a>
8000b84e:	13 0a       	ld.w	r10,r9++
8000b850:	10 aa       	st.w	r8++,r10
8000b852:	16 39       	cp.w	r9,r11
8000b854:	cf d3       	brcs	8000b84e <__lshift+0x72>
8000b856:	08 9c       	mov	r12,r4
8000b858:	20 16       	sub	r6,1
8000b85a:	0e 9b       	mov	r11,r7
8000b85c:	8b 46       	st.w	r5[0x10],r6
8000b85e:	cb 5e       	rcall	8000b5c8 <_Bfree>
8000b860:	0a 9c       	mov	r12,r5
8000b862:	d8 32       	popm	r0-r7,pc

8000b864 <__multiply>:
8000b864:	d4 31       	pushm	r0-r7,lr
8000b866:	20 2d       	sub	sp,8
8000b868:	76 49       	ld.w	r9,r11[0x10]
8000b86a:	74 48       	ld.w	r8,r10[0x10]
8000b86c:	16 96       	mov	r6,r11
8000b86e:	14 95       	mov	r5,r10
8000b870:	10 39       	cp.w	r9,r8
8000b872:	ec 08 17 50 	movlt	r8,r6
8000b876:	ea 06 17 50 	movlt	r6,r5
8000b87a:	f0 05 17 50 	movlt	r5,r8
8000b87e:	6c 28       	ld.w	r8,r6[0x8]
8000b880:	76 43       	ld.w	r3,r11[0x10]
8000b882:	74 42       	ld.w	r2,r10[0x10]
8000b884:	76 1b       	ld.w	r11,r11[0x4]
8000b886:	e4 03 00 07 	add	r7,r2,r3
8000b88a:	10 37       	cp.w	r7,r8
8000b88c:	f7 bb 09 ff 	subgt	r11,-1
8000b890:	cb 6e       	rcall	8000b5fc <_Balloc>
8000b892:	ee c4 ff fb 	sub	r4,r7,-5
8000b896:	f8 c9 ff ec 	sub	r9,r12,-20
8000b89a:	f8 04 00 24 	add	r4,r12,r4<<0x2
8000b89e:	30 0a       	mov	r10,0
8000b8a0:	12 98       	mov	r8,r9
8000b8a2:	c0 28       	rjmp	8000b8a6 <__multiply+0x42>
8000b8a4:	10 aa       	st.w	r8++,r10
8000b8a6:	08 38       	cp.w	r8,r4
8000b8a8:	cf e3       	brcs	8000b8a4 <__multiply+0x40>
8000b8aa:	2f b3       	sub	r3,-5
8000b8ac:	2f b2       	sub	r2,-5
8000b8ae:	ec 03 00 23 	add	r3,r6,r3<<0x2
8000b8b2:	ea 02 00 22 	add	r2,r5,r2<<0x2
8000b8b6:	ec cb ff ec 	sub	r11,r6,-20
8000b8ba:	50 12       	stdsp	sp[0x4],r2
8000b8bc:	ea ca ff ec 	sub	r10,r5,-20
8000b8c0:	c4 48       	rjmp	8000b948 <__multiply+0xe4>
8000b8c2:	94 95       	ld.uh	r5,r10[0x2]
8000b8c4:	58 05       	cp.w	r5,0
8000b8c6:	c2 00       	breq	8000b906 <__multiply+0xa2>
8000b8c8:	12 98       	mov	r8,r9
8000b8ca:	16 96       	mov	r6,r11
8000b8cc:	30 0e       	mov	lr,0
8000b8ce:	50 09       	stdsp	sp[0x0],r9
8000b8d0:	0d 02       	ld.w	r2,r6++
8000b8d2:	e4 00 16 10 	lsr	r0,r2,0x10
8000b8d6:	70 01       	ld.w	r1,r8[0x0]
8000b8d8:	70 09       	ld.w	r9,r8[0x0]
8000b8da:	b1 81       	lsr	r1,0x10
8000b8dc:	e5 d2 c0 10 	bfextu	r2,r2,0x0,0x10
8000b8e0:	e0 05 03 41 	mac	r1,r0,r5
8000b8e4:	ab 32       	mul	r2,r5
8000b8e6:	e1 d9 c0 10 	bfextu	r0,r9,0x0,0x10
8000b8ea:	00 02       	add	r2,r0
8000b8ec:	e4 0e 00 0e 	add	lr,r2,lr
8000b8f0:	b0 1e       	st.h	r8[0x2],lr
8000b8f2:	b1 8e       	lsr	lr,0x10
8000b8f4:	1c 01       	add	r1,lr
8000b8f6:	b0 01       	st.h	r8[0x0],r1
8000b8f8:	e2 0e 16 10 	lsr	lr,r1,0x10
8000b8fc:	2f c8       	sub	r8,-4
8000b8fe:	06 36       	cp.w	r6,r3
8000b900:	ce 83       	brcs	8000b8d0 <__multiply+0x6c>
8000b902:	40 09       	lddsp	r9,sp[0x0]
8000b904:	91 0e       	st.w	r8[0x0],lr
8000b906:	94 86       	ld.uh	r6,r10[0x0]
8000b908:	58 06       	cp.w	r6,0
8000b90a:	c1 d0       	breq	8000b944 <__multiply+0xe0>
8000b90c:	72 02       	ld.w	r2,r9[0x0]
8000b90e:	12 98       	mov	r8,r9
8000b910:	16 9e       	mov	lr,r11
8000b912:	30 05       	mov	r5,0
8000b914:	b0 12       	st.h	r8[0x2],r2
8000b916:	1d 01       	ld.w	r1,lr++
8000b918:	90 82       	ld.uh	r2,r8[0x0]
8000b91a:	e1 d1 c0 10 	bfextu	r0,r1,0x0,0x10
8000b91e:	ad 30       	mul	r0,r6
8000b920:	e0 02 00 02 	add	r2,r0,r2
8000b924:	e4 05 00 05 	add	r5,r2,r5
8000b928:	b0 05       	st.h	r8[0x0],r5
8000b92a:	b1 85       	lsr	r5,0x10
8000b92c:	b1 81       	lsr	r1,0x10
8000b92e:	2f c8       	sub	r8,-4
8000b930:	ad 31       	mul	r1,r6
8000b932:	90 92       	ld.uh	r2,r8[0x2]
8000b934:	e2 02 00 02 	add	r2,r1,r2
8000b938:	0a 02       	add	r2,r5
8000b93a:	e4 05 16 10 	lsr	r5,r2,0x10
8000b93e:	06 3e       	cp.w	lr,r3
8000b940:	ce a3       	brcs	8000b914 <__multiply+0xb0>
8000b942:	91 02       	st.w	r8[0x0],r2
8000b944:	2f ca       	sub	r10,-4
8000b946:	2f c9       	sub	r9,-4
8000b948:	40 18       	lddsp	r8,sp[0x4]
8000b94a:	10 3a       	cp.w	r10,r8
8000b94c:	cb b3       	brcs	8000b8c2 <__multiply+0x5e>
8000b94e:	c0 28       	rjmp	8000b952 <__multiply+0xee>
8000b950:	20 17       	sub	r7,1
8000b952:	58 07       	cp.w	r7,0
8000b954:	e0 8a 00 05 	brle	8000b95e <__multiply+0xfa>
8000b958:	09 48       	ld.w	r8,--r4
8000b95a:	58 08       	cp.w	r8,0
8000b95c:	cf a0       	breq	8000b950 <__multiply+0xec>
8000b95e:	99 47       	st.w	r12[0x10],r7
8000b960:	2f ed       	sub	sp,-8
8000b962:	d8 32       	popm	r0-r7,pc

8000b964 <__i2b>:
8000b964:	d4 21       	pushm	r4-r7,lr
8000b966:	16 97       	mov	r7,r11
8000b968:	30 1b       	mov	r11,1
8000b96a:	c4 9e       	rcall	8000b5fc <_Balloc>
8000b96c:	30 19       	mov	r9,1
8000b96e:	99 57       	st.w	r12[0x14],r7
8000b970:	99 49       	st.w	r12[0x10],r9
8000b972:	d8 22       	popm	r4-r7,pc

8000b974 <__multadd>:
8000b974:	d4 31       	pushm	r0-r7,lr
8000b976:	30 08       	mov	r8,0
8000b978:	12 95       	mov	r5,r9
8000b97a:	16 97       	mov	r7,r11
8000b97c:	18 96       	mov	r6,r12
8000b97e:	76 44       	ld.w	r4,r11[0x10]
8000b980:	f6 c9 ff ec 	sub	r9,r11,-20
8000b984:	72 0b       	ld.w	r11,r9[0x0]
8000b986:	f6 0c 16 10 	lsr	r12,r11,0x10
8000b98a:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000b98e:	f4 0c 02 4c 	mul	r12,r10,r12
8000b992:	f4 0b 03 45 	mac	r5,r10,r11
8000b996:	f7 d5 c0 10 	bfextu	r11,r5,0x0,0x10
8000b99a:	b1 85       	lsr	r5,0x10
8000b99c:	18 05       	add	r5,r12
8000b99e:	ea 0c 15 10 	lsl	r12,r5,0x10
8000b9a2:	f8 0b 00 0b 	add	r11,r12,r11
8000b9a6:	12 ab       	st.w	r9++,r11
8000b9a8:	2f f8       	sub	r8,-1
8000b9aa:	b1 85       	lsr	r5,0x10
8000b9ac:	08 38       	cp.w	r8,r4
8000b9ae:	ce b5       	brlt	8000b984 <__multadd+0x10>
8000b9b0:	58 05       	cp.w	r5,0
8000b9b2:	c1 c0       	breq	8000b9ea <__multadd+0x76>
8000b9b4:	6e 28       	ld.w	r8,r7[0x8]
8000b9b6:	10 34       	cp.w	r4,r8
8000b9b8:	c1 35       	brlt	8000b9de <__multadd+0x6a>
8000b9ba:	6e 1b       	ld.w	r11,r7[0x4]
8000b9bc:	0c 9c       	mov	r12,r6
8000b9be:	2f fb       	sub	r11,-1
8000b9c0:	c1 ee       	rcall	8000b5fc <_Balloc>
8000b9c2:	6e 4a       	ld.w	r10,r7[0x10]
8000b9c4:	ee cb ff f4 	sub	r11,r7,-12
8000b9c8:	18 93       	mov	r3,r12
8000b9ca:	2f ea       	sub	r10,-2
8000b9cc:	2f 4c       	sub	r12,-12
8000b9ce:	a3 6a       	lsl	r10,0x2
8000b9d0:	fe b0 de 70 	rcall	800076b0 <memcpy>
8000b9d4:	0e 9b       	mov	r11,r7
8000b9d6:	0c 9c       	mov	r12,r6
8000b9d8:	fe b0 fd f8 	rcall	8000b5c8 <_Bfree>
8000b9dc:	06 97       	mov	r7,r3
8000b9de:	e8 c8 ff ff 	sub	r8,r4,-1
8000b9e2:	2f b4       	sub	r4,-5
8000b9e4:	8f 48       	st.w	r7[0x10],r8
8000b9e6:	ee 04 09 25 	st.w	r7[r4<<0x2],r5
8000b9ea:	0e 9c       	mov	r12,r7
8000b9ec:	d8 32       	popm	r0-r7,pc
8000b9ee:	d7 03       	nop

8000b9f0 <__pow5mult>:
8000b9f0:	d4 31       	pushm	r0-r7,lr
8000b9f2:	14 96       	mov	r6,r10
8000b9f4:	18 97       	mov	r7,r12
8000b9f6:	16 94       	mov	r4,r11
8000b9f8:	f1 da c0 02 	bfextu	r8,r10,0x0,0x2
8000b9fc:	c0 90       	breq	8000ba0e <__pow5mult+0x1e>
8000b9fe:	20 18       	sub	r8,1
8000ba00:	fe c9 db 88 	sub	r9,pc,-9336
8000ba04:	f2 08 03 2a 	ld.w	r10,r9[r8<<0x2]
8000ba08:	30 09       	mov	r9,0
8000ba0a:	cb 5f       	rcall	8000b974 <__multadd>
8000ba0c:	18 94       	mov	r4,r12
8000ba0e:	a3 46       	asr	r6,0x2
8000ba10:	c3 40       	breq	8000ba78 <__pow5mult+0x88>
8000ba12:	6e 95       	ld.w	r5,r7[0x24]
8000ba14:	58 05       	cp.w	r5,0
8000ba16:	c0 91       	brne	8000ba28 <__pow5mult+0x38>
8000ba18:	31 0c       	mov	r12,16
8000ba1a:	fe b0 dc 27 	rcall	80007268 <malloc>
8000ba1e:	99 35       	st.w	r12[0xc],r5
8000ba20:	8f 9c       	st.w	r7[0x24],r12
8000ba22:	99 15       	st.w	r12[0x4],r5
8000ba24:	99 25       	st.w	r12[0x8],r5
8000ba26:	99 05       	st.w	r12[0x0],r5
8000ba28:	6e 93       	ld.w	r3,r7[0x24]
8000ba2a:	66 25       	ld.w	r5,r3[0x8]
8000ba2c:	58 05       	cp.w	r5,0
8000ba2e:	c0 c1       	brne	8000ba46 <__pow5mult+0x56>
8000ba30:	e0 6b 02 71 	mov	r11,625
8000ba34:	0e 9c       	mov	r12,r7
8000ba36:	c9 7f       	rcall	8000b964 <__i2b>
8000ba38:	87 2c       	st.w	r3[0x8],r12
8000ba3a:	30 08       	mov	r8,0
8000ba3c:	18 95       	mov	r5,r12
8000ba3e:	99 08       	st.w	r12[0x0],r8
8000ba40:	c0 38       	rjmp	8000ba46 <__pow5mult+0x56>
8000ba42:	06 9c       	mov	r12,r3
8000ba44:	18 95       	mov	r5,r12
8000ba46:	ed b6 00 00 	bld	r6,0x0
8000ba4a:	c0 b1       	brne	8000ba60 <__pow5mult+0x70>
8000ba4c:	08 9b       	mov	r11,r4
8000ba4e:	0a 9a       	mov	r10,r5
8000ba50:	0e 9c       	mov	r12,r7
8000ba52:	c0 9f       	rcall	8000b864 <__multiply>
8000ba54:	08 9b       	mov	r11,r4
8000ba56:	18 93       	mov	r3,r12
8000ba58:	0e 9c       	mov	r12,r7
8000ba5a:	06 94       	mov	r4,r3
8000ba5c:	fe b0 fd b6 	rcall	8000b5c8 <_Bfree>
8000ba60:	a1 56       	asr	r6,0x1
8000ba62:	c0 b0       	breq	8000ba78 <__pow5mult+0x88>
8000ba64:	6a 03       	ld.w	r3,r5[0x0]
8000ba66:	58 03       	cp.w	r3,0
8000ba68:	ce d1       	brne	8000ba42 <__pow5mult+0x52>
8000ba6a:	0a 9a       	mov	r10,r5
8000ba6c:	0a 9b       	mov	r11,r5
8000ba6e:	0e 9c       	mov	r12,r7
8000ba70:	cf ae       	rcall	8000b864 <__multiply>
8000ba72:	8b 0c       	st.w	r5[0x0],r12
8000ba74:	99 03       	st.w	r12[0x0],r3
8000ba76:	ce 7b       	rjmp	8000ba44 <__pow5mult+0x54>
8000ba78:	08 9c       	mov	r12,r4
8000ba7a:	d8 32       	popm	r0-r7,pc

8000ba7c <__isinfd>:
8000ba7c:	14 98       	mov	r8,r10
8000ba7e:	fc 19 7f f0 	movh	r9,0x7ff0
8000ba82:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000ba86:	f0 0b 11 00 	rsub	r11,r8,0
8000ba8a:	f7 e8 10 08 	or	r8,r11,r8
8000ba8e:	f5 e8 13 f8 	or	r8,r10,r8>>0x1f
8000ba92:	f2 08 01 08 	sub	r8,r9,r8
8000ba96:	f0 0c 11 00 	rsub	r12,r8,0
8000ba9a:	f9 e8 10 08 	or	r8,r12,r8
8000ba9e:	f0 0c 14 1f 	asr	r12,r8,0x1f
8000baa2:	2f fc       	sub	r12,-1
8000baa4:	5e fc       	retal	r12

8000baa6 <__isnand>:
8000baa6:	14 98       	mov	r8,r10
8000baa8:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000baac:	f0 0c 11 00 	rsub	r12,r8,0
8000bab0:	10 4c       	or	r12,r8
8000bab2:	fc 18 7f f0 	movh	r8,0x7ff0
8000bab6:	f5 ec 13 fc 	or	r12,r10,r12>>0x1f
8000baba:	f0 0c 01 0c 	sub	r12,r8,r12
8000babe:	bf 9c       	lsr	r12,0x1f
8000bac0:	5e fc       	retal	r12
8000bac2:	d7 03       	nop

8000bac4 <__sclose>:
8000bac4:	d4 01       	pushm	lr
8000bac6:	96 7b       	ld.sh	r11,r11[0xe]
8000bac8:	c8 2c       	rcall	8000bbcc <_close_r>
8000baca:	d8 02       	popm	pc

8000bacc <__sseek>:
8000bacc:	d4 21       	pushm	r4-r7,lr
8000bace:	16 97       	mov	r7,r11
8000bad0:	96 7b       	ld.sh	r11,r11[0xe]
8000bad2:	c0 3d       	rcall	8000bcd8 <_lseek_r>
8000bad4:	8e 68       	ld.sh	r8,r7[0xc]
8000bad6:	10 99       	mov	r9,r8
8000bad8:	ad c8       	cbr	r8,0xc
8000bada:	ad a9       	sbr	r9,0xc
8000badc:	5b fc       	cp.w	r12,-1
8000bade:	ef f8 0c 06 	st.heq	r7[0xc],r8
8000bae2:	ef f9 1c 06 	st.hne	r7[0xc],r9
8000bae6:	ef fc 1a 15 	st.wne	r7[0x54],r12
8000baea:	d8 22       	popm	r4-r7,pc

8000baec <__swrite>:
8000baec:	d4 21       	pushm	r4-r7,lr
8000baee:	96 68       	ld.sh	r8,r11[0xc]
8000baf0:	16 97       	mov	r7,r11
8000baf2:	14 95       	mov	r5,r10
8000baf4:	12 94       	mov	r4,r9
8000baf6:	e2 18 01 00 	andl	r8,0x100,COH
8000bafa:	18 96       	mov	r6,r12
8000bafc:	c0 50       	breq	8000bb06 <__swrite+0x1a>
8000bafe:	30 29       	mov	r9,2
8000bb00:	30 0a       	mov	r10,0
8000bb02:	96 7b       	ld.sh	r11,r11[0xe]
8000bb04:	ce ac       	rcall	8000bcd8 <_lseek_r>
8000bb06:	8e 68       	ld.sh	r8,r7[0xc]
8000bb08:	ad c8       	cbr	r8,0xc
8000bb0a:	08 99       	mov	r9,r4
8000bb0c:	0a 9a       	mov	r10,r5
8000bb0e:	8e 7b       	ld.sh	r11,r7[0xe]
8000bb10:	0c 9c       	mov	r12,r6
8000bb12:	ae 68       	st.h	r7[0xc],r8
8000bb14:	c1 cc       	rcall	8000bb4c <_write_r>
8000bb16:	d8 22       	popm	r4-r7,pc

8000bb18 <__sread>:
8000bb18:	d4 21       	pushm	r4-r7,lr
8000bb1a:	16 97       	mov	r7,r11
8000bb1c:	96 7b       	ld.sh	r11,r11[0xe]
8000bb1e:	cf 1c       	rcall	8000bd00 <_read_r>
8000bb20:	c0 65       	brlt	8000bb2c <__sread+0x14>
8000bb22:	6f 58       	ld.w	r8,r7[0x54]
8000bb24:	18 08       	add	r8,r12
8000bb26:	ef 48 00 54 	st.w	r7[84],r8
8000bb2a:	d8 22       	popm	r4-r7,pc
8000bb2c:	8e 68       	ld.sh	r8,r7[0xc]
8000bb2e:	ad c8       	cbr	r8,0xc
8000bb30:	ae 68       	st.h	r7[0xc],r8
8000bb32:	d8 22       	popm	r4-r7,pc

8000bb34 <strlen>:
8000bb34:	30 09       	mov	r9,0
8000bb36:	18 98       	mov	r8,r12
8000bb38:	c0 28       	rjmp	8000bb3c <strlen+0x8>
8000bb3a:	2f f8       	sub	r8,-1
8000bb3c:	11 8a       	ld.ub	r10,r8[0x0]
8000bb3e:	f2 0a 18 00 	cp.b	r10,r9
8000bb42:	cf c1       	brne	8000bb3a <strlen+0x6>
8000bb44:	f0 0c 01 0c 	sub	r12,r8,r12
8000bb48:	5e fc       	retal	r12
8000bb4a:	d7 03       	nop

8000bb4c <_write_r>:
8000bb4c:	d4 21       	pushm	r4-r7,lr
8000bb4e:	16 98       	mov	r8,r11
8000bb50:	18 97       	mov	r7,r12
8000bb52:	10 9c       	mov	r12,r8
8000bb54:	30 08       	mov	r8,0
8000bb56:	14 9b       	mov	r11,r10
8000bb58:	e0 66 51 2c 	mov	r6,20780
8000bb5c:	12 9a       	mov	r10,r9
8000bb5e:	8d 08       	st.w	r6[0x0],r8
8000bb60:	fe b0 d1 9c 	rcall	80005e98 <_write>
8000bb64:	5b fc       	cp.w	r12,-1
8000bb66:	c0 51       	brne	8000bb70 <_write_r+0x24>
8000bb68:	6c 08       	ld.w	r8,r6[0x0]
8000bb6a:	58 08       	cp.w	r8,0
8000bb6c:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000bb70:	d8 22       	popm	r4-r7,pc
8000bb72:	d7 03       	nop

8000bb74 <_calloc_r>:
8000bb74:	d4 21       	pushm	r4-r7,lr
8000bb76:	f4 0b 02 4b 	mul	r11,r10,r11
8000bb7a:	fe b0 db 7f 	rcall	80007278 <_malloc_r>
8000bb7e:	18 97       	mov	r7,r12
8000bb80:	c2 30       	breq	8000bbc6 <_calloc_r+0x52>
8000bb82:	f8 fa ff fc 	ld.w	r10,r12[-4]
8000bb86:	e0 1a ff fc 	andl	r10,0xfffc
8000bb8a:	20 4a       	sub	r10,4
8000bb8c:	e0 4a 00 24 	cp.w	r10,36
8000bb90:	e0 8b 00 18 	brhi	8000bbc0 <_calloc_r+0x4c>
8000bb94:	18 98       	mov	r8,r12
8000bb96:	59 3a       	cp.w	r10,19
8000bb98:	e0 88 00 0f 	brls	8000bbb6 <_calloc_r+0x42>
8000bb9c:	30 09       	mov	r9,0
8000bb9e:	10 a9       	st.w	r8++,r9
8000bba0:	10 a9       	st.w	r8++,r9
8000bba2:	59 ba       	cp.w	r10,27
8000bba4:	e0 88 00 09 	brls	8000bbb6 <_calloc_r+0x42>
8000bba8:	10 a9       	st.w	r8++,r9
8000bbaa:	10 a9       	st.w	r8++,r9
8000bbac:	e0 4a 00 24 	cp.w	r10,36
8000bbb0:	c0 31       	brne	8000bbb6 <_calloc_r+0x42>
8000bbb2:	10 a9       	st.w	r8++,r9
8000bbb4:	10 a9       	st.w	r8++,r9
8000bbb6:	30 09       	mov	r9,0
8000bbb8:	10 a9       	st.w	r8++,r9
8000bbba:	91 19       	st.w	r8[0x4],r9
8000bbbc:	91 09       	st.w	r8[0x0],r9
8000bbbe:	c0 48       	rjmp	8000bbc6 <_calloc_r+0x52>
8000bbc0:	30 0b       	mov	r11,0
8000bbc2:	fe b0 de 1b 	rcall	800077f8 <memset>
8000bbc6:	0e 9c       	mov	r12,r7
8000bbc8:	d8 22       	popm	r4-r7,pc
8000bbca:	d7 03       	nop

8000bbcc <_close_r>:
8000bbcc:	d4 21       	pushm	r4-r7,lr
8000bbce:	30 08       	mov	r8,0
8000bbd0:	18 97       	mov	r7,r12
8000bbd2:	e0 66 51 2c 	mov	r6,20780
8000bbd6:	16 9c       	mov	r12,r11
8000bbd8:	8d 08       	st.w	r6[0x0],r8
8000bbda:	fe b0 df b5 	rcall	80007b44 <_close>
8000bbde:	5b fc       	cp.w	r12,-1
8000bbe0:	c0 51       	brne	8000bbea <_close_r+0x1e>
8000bbe2:	6c 08       	ld.w	r8,r6[0x0]
8000bbe4:	58 08       	cp.w	r8,0
8000bbe6:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000bbea:	d8 22       	popm	r4-r7,pc

8000bbec <_fclose_r>:
8000bbec:	d4 21       	pushm	r4-r7,lr
8000bbee:	18 96       	mov	r6,r12
8000bbf0:	16 97       	mov	r7,r11
8000bbf2:	58 0b       	cp.w	r11,0
8000bbf4:	c0 31       	brne	8000bbfa <_fclose_r+0xe>
8000bbf6:	16 95       	mov	r5,r11
8000bbf8:	c5 38       	rjmp	8000bc9e <_fclose_r+0xb2>
8000bbfa:	fe b0 f8 a9 	rcall	8000ad4c <__sfp_lock_acquire>
8000bbfe:	58 06       	cp.w	r6,0
8000bc00:	c0 70       	breq	8000bc0e <_fclose_r+0x22>
8000bc02:	6c 68       	ld.w	r8,r6[0x18]
8000bc04:	58 08       	cp.w	r8,0
8000bc06:	c0 41       	brne	8000bc0e <_fclose_r+0x22>
8000bc08:	0c 9c       	mov	r12,r6
8000bc0a:	fe b0 f8 f3 	rcall	8000adf0 <__sinit>
8000bc0e:	fe c8 de 3a 	sub	r8,pc,-8646
8000bc12:	10 37       	cp.w	r7,r8
8000bc14:	c0 31       	brne	8000bc1a <_fclose_r+0x2e>
8000bc16:	6c 07       	ld.w	r7,r6[0x0]
8000bc18:	c0 c8       	rjmp	8000bc30 <_fclose_r+0x44>
8000bc1a:	fe c8 de 26 	sub	r8,pc,-8666
8000bc1e:	10 37       	cp.w	r7,r8
8000bc20:	c0 31       	brne	8000bc26 <_fclose_r+0x3a>
8000bc22:	6c 17       	ld.w	r7,r6[0x4]
8000bc24:	c0 68       	rjmp	8000bc30 <_fclose_r+0x44>
8000bc26:	fe c8 de 12 	sub	r8,pc,-8686
8000bc2a:	10 37       	cp.w	r7,r8
8000bc2c:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000bc30:	8e 69       	ld.sh	r9,r7[0xc]
8000bc32:	30 08       	mov	r8,0
8000bc34:	f0 09 19 00 	cp.h	r9,r8
8000bc38:	c0 51       	brne	8000bc42 <_fclose_r+0x56>
8000bc3a:	fe b0 f8 8a 	rcall	8000ad4e <__sfp_lock_release>
8000bc3e:	30 05       	mov	r5,0
8000bc40:	c2 f8       	rjmp	8000bc9e <_fclose_r+0xb2>
8000bc42:	0e 9b       	mov	r11,r7
8000bc44:	0c 9c       	mov	r12,r6
8000bc46:	fe b0 f7 fd 	rcall	8000ac40 <_fflush_r>
8000bc4a:	6e c8       	ld.w	r8,r7[0x30]
8000bc4c:	18 95       	mov	r5,r12
8000bc4e:	58 08       	cp.w	r8,0
8000bc50:	c0 60       	breq	8000bc5c <_fclose_r+0x70>
8000bc52:	6e 8b       	ld.w	r11,r7[0x20]
8000bc54:	0c 9c       	mov	r12,r6
8000bc56:	5d 18       	icall	r8
8000bc58:	f9 b5 05 ff 	movlt	r5,-1
8000bc5c:	8e 68       	ld.sh	r8,r7[0xc]
8000bc5e:	ed b8 00 07 	bld	r8,0x7
8000bc62:	c0 51       	brne	8000bc6c <_fclose_r+0x80>
8000bc64:	6e 4b       	ld.w	r11,r7[0x10]
8000bc66:	0c 9c       	mov	r12,r6
8000bc68:	fe b0 f9 5e 	rcall	8000af24 <_free_r>
8000bc6c:	6e db       	ld.w	r11,r7[0x34]
8000bc6e:	58 0b       	cp.w	r11,0
8000bc70:	c0 a0       	breq	8000bc84 <_fclose_r+0x98>
8000bc72:	ee c8 ff bc 	sub	r8,r7,-68
8000bc76:	10 3b       	cp.w	r11,r8
8000bc78:	c0 40       	breq	8000bc80 <_fclose_r+0x94>
8000bc7a:	0c 9c       	mov	r12,r6
8000bc7c:	fe b0 f9 54 	rcall	8000af24 <_free_r>
8000bc80:	30 08       	mov	r8,0
8000bc82:	8f d8       	st.w	r7[0x34],r8
8000bc84:	6f 2b       	ld.w	r11,r7[0x48]
8000bc86:	58 0b       	cp.w	r11,0
8000bc88:	c0 70       	breq	8000bc96 <_fclose_r+0xaa>
8000bc8a:	0c 9c       	mov	r12,r6
8000bc8c:	fe b0 f9 4c 	rcall	8000af24 <_free_r>
8000bc90:	30 08       	mov	r8,0
8000bc92:	ef 48 00 48 	st.w	r7[72],r8
8000bc96:	30 08       	mov	r8,0
8000bc98:	ae 68       	st.h	r7[0xc],r8
8000bc9a:	fe b0 f8 5a 	rcall	8000ad4e <__sfp_lock_release>
8000bc9e:	0a 9c       	mov	r12,r5
8000bca0:	d8 22       	popm	r4-r7,pc
8000bca2:	d7 03       	nop

8000bca4 <fclose>:
8000bca4:	d4 01       	pushm	lr
8000bca6:	e0 68 0a 3c 	mov	r8,2620
8000bcaa:	18 9b       	mov	r11,r12
8000bcac:	70 0c       	ld.w	r12,r8[0x0]
8000bcae:	c9 ff       	rcall	8000bbec <_fclose_r>
8000bcb0:	d8 02       	popm	pc
8000bcb2:	d7 03       	nop

8000bcb4 <_fstat_r>:
8000bcb4:	d4 21       	pushm	r4-r7,lr
8000bcb6:	16 98       	mov	r8,r11
8000bcb8:	18 97       	mov	r7,r12
8000bcba:	10 9c       	mov	r12,r8
8000bcbc:	30 08       	mov	r8,0
8000bcbe:	e0 66 51 2c 	mov	r6,20780
8000bcc2:	14 9b       	mov	r11,r10
8000bcc4:	8d 08       	st.w	r6[0x0],r8
8000bcc6:	fe b0 df 67 	rcall	80007b94 <_fstat>
8000bcca:	5b fc       	cp.w	r12,-1
8000bccc:	c0 51       	brne	8000bcd6 <_fstat_r+0x22>
8000bcce:	6c 08       	ld.w	r8,r6[0x0]
8000bcd0:	58 08       	cp.w	r8,0
8000bcd2:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000bcd6:	d8 22       	popm	r4-r7,pc

8000bcd8 <_lseek_r>:
8000bcd8:	d4 21       	pushm	r4-r7,lr
8000bcda:	16 98       	mov	r8,r11
8000bcdc:	18 97       	mov	r7,r12
8000bcde:	10 9c       	mov	r12,r8
8000bce0:	30 08       	mov	r8,0
8000bce2:	14 9b       	mov	r11,r10
8000bce4:	e0 66 51 2c 	mov	r6,20780
8000bce8:	12 9a       	mov	r10,r9
8000bcea:	8d 08       	st.w	r6[0x0],r8
8000bcec:	fe b0 df 36 	rcall	80007b58 <_lseek>
8000bcf0:	5b fc       	cp.w	r12,-1
8000bcf2:	c0 51       	brne	8000bcfc <_lseek_r+0x24>
8000bcf4:	6c 08       	ld.w	r8,r6[0x0]
8000bcf6:	58 08       	cp.w	r8,0
8000bcf8:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000bcfc:	d8 22       	popm	r4-r7,pc
8000bcfe:	d7 03       	nop

8000bd00 <_read_r>:
8000bd00:	d4 21       	pushm	r4-r7,lr
8000bd02:	16 98       	mov	r8,r11
8000bd04:	18 97       	mov	r7,r12
8000bd06:	10 9c       	mov	r12,r8
8000bd08:	30 08       	mov	r8,0
8000bd0a:	14 9b       	mov	r11,r10
8000bd0c:	e0 66 51 2c 	mov	r6,20780
8000bd10:	12 9a       	mov	r10,r9
8000bd12:	8d 08       	st.w	r6[0x0],r8
8000bd14:	fe b0 d0 a2 	rcall	80005e58 <_read>
8000bd18:	5b fc       	cp.w	r12,-1
8000bd1a:	c0 51       	brne	8000bd24 <_read_r+0x24>
8000bd1c:	6c 08       	ld.w	r8,r6[0x0]
8000bd1e:	58 08       	cp.w	r8,0
8000bd20:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000bd24:	d8 22       	popm	r4-r7,pc
8000bd26:	d7 03       	nop

8000bd28 <__avr32_f64_mul>:
8000bd28:	f5 eb 10 1c 	or	r12,r10,r11<<0x1
8000bd2c:	e0 80 00 dc 	breq	8000bee4 <__avr32_f64_mul_op1_zero>
8000bd30:	d4 21       	pushm	r4-r7,lr
8000bd32:	f7 e9 20 0e 	eor	lr,r11,r9
8000bd36:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000bd3a:	30 15       	mov	r5,1
8000bd3c:	c4 30       	breq	8000bdc2 <__avr32_f64_mul_op1_subnormal>
8000bd3e:	ab 6b       	lsl	r11,0xa
8000bd40:	f7 ea 13 6b 	or	r11,r11,r10>>0x16
8000bd44:	ab 6a       	lsl	r10,0xa
8000bd46:	f7 d5 d3 c2 	bfins	r11,r5,0x1e,0x2
8000bd4a:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000bd4e:	c5 c0       	breq	8000be06 <__avr32_f64_mul_op2_subnormal>
8000bd50:	a1 78       	lsl	r8,0x1
8000bd52:	5c f9       	rol	r9
8000bd54:	f3 d5 d2 ab 	bfins	r9,r5,0x15,0xb
8000bd58:	e0 47 07 ff 	cp.w	r7,2047
8000bd5c:	c7 70       	breq	8000be4a <__avr32_f64_mul_op_nan_or_inf>
8000bd5e:	e0 46 07 ff 	cp.w	r6,2047
8000bd62:	c7 40       	breq	8000be4a <__avr32_f64_mul_op_nan_or_inf>
8000bd64:	ee 06 00 0c 	add	r12,r7,r6
8000bd68:	e0 2c 03 fe 	sub	r12,1022
8000bd6c:	f6 08 06 44 	mulu.d	r4,r11,r8
8000bd70:	f4 09 07 44 	macu.d	r4,r10,r9
8000bd74:	f4 08 06 46 	mulu.d	r6,r10,r8
8000bd78:	f6 09 06 4a 	mulu.d	r10,r11,r9
8000bd7c:	08 07       	add	r7,r4
8000bd7e:	f4 05 00 4a 	adc	r10,r10,r5
8000bd82:	5c 0b       	acr	r11
8000bd84:	ed bb 00 14 	bld	r11,0x14
8000bd88:	c0 50       	breq	8000bd92 <__avr32_f64_mul+0x6a>
8000bd8a:	a1 77       	lsl	r7,0x1
8000bd8c:	5c fa       	rol	r10
8000bd8e:	5c fb       	rol	r11
8000bd90:	20 1c       	sub	r12,1
8000bd92:	58 0c       	cp.w	r12,0
8000bd94:	e0 8a 00 6f 	brle	8000be72 <__avr32_f64_mul_res_subnormal>
8000bd98:	e0 4c 07 ff 	cp.w	r12,2047
8000bd9c:	e0 84 00 9c 	brge	8000bed4 <__avr32_f64_mul_res_inf>
8000bda0:	f7 dc d2 8b 	bfins	r11,r12,0x14,0xb
8000bda4:	ed ea 11 f6 	or	r6,r6,r10<<0x1f
8000bda8:	ef e6 12 17 	or	r7,r7,r6>>0x1
8000bdac:	ee 17 80 00 	eorh	r7,0x8000
8000bdb0:	f1 b7 04 20 	satu	r7,0x1
8000bdb4:	0e 0a       	add	r10,r7
8000bdb6:	5c 0b       	acr	r11
8000bdb8:	ed be 00 1f 	bld	lr,0x1f
8000bdbc:	ef bb 00 1f 	bst	r11,0x1f
8000bdc0:	d8 22       	popm	r4-r7,pc

8000bdc2 <__avr32_f64_mul_op1_subnormal>:
8000bdc2:	e4 1b 00 0f 	andh	r11,0xf
8000bdc6:	f4 0c 12 00 	clz	r12,r10
8000bdca:	f6 06 12 00 	clz	r6,r11
8000bdce:	f7 bc 03 e1 	sublo	r12,-31
8000bdd2:	f8 06 17 30 	movlo	r6,r12
8000bdd6:	f7 b6 02 01 	subhs	r6,1
8000bdda:	e0 46 00 20 	cp.w	r6,32
8000bdde:	c0 d4       	brge	8000bdf8 <__avr32_f64_mul_op1_subnormal+0x36>
8000bde0:	ec 0c 11 20 	rsub	r12,r6,32
8000bde4:	f6 06 09 4b 	lsl	r11,r11,r6
8000bde8:	f4 0c 0a 4c 	lsr	r12,r10,r12
8000bdec:	18 4b       	or	r11,r12
8000bdee:	f4 06 09 4a 	lsl	r10,r10,r6
8000bdf2:	20 b6       	sub	r6,11
8000bdf4:	0c 17       	sub	r7,r6
8000bdf6:	ca ab       	rjmp	8000bd4a <__avr32_f64_mul+0x22>
8000bdf8:	f4 06 09 4b 	lsl	r11,r10,r6
8000bdfc:	c6 40       	breq	8000bec4 <__avr32_f64_mul_res_zero>
8000bdfe:	30 0a       	mov	r10,0
8000be00:	20 b6       	sub	r6,11
8000be02:	0c 17       	sub	r7,r6
8000be04:	ca 3b       	rjmp	8000bd4a <__avr32_f64_mul+0x22>

8000be06 <__avr32_f64_mul_op2_subnormal>:
8000be06:	e4 19 00 0f 	andh	r9,0xf
8000be0a:	f0 0c 12 00 	clz	r12,r8
8000be0e:	f2 05 12 00 	clz	r5,r9
8000be12:	f7 bc 03 ea 	sublo	r12,-22
8000be16:	f8 05 17 30 	movlo	r5,r12
8000be1a:	f7 b5 02 0a 	subhs	r5,10
8000be1e:	e0 45 00 20 	cp.w	r5,32
8000be22:	c0 d4       	brge	8000be3c <__avr32_f64_mul_op2_subnormal+0x36>
8000be24:	ea 0c 11 20 	rsub	r12,r5,32
8000be28:	f2 05 09 49 	lsl	r9,r9,r5
8000be2c:	f0 0c 0a 4c 	lsr	r12,r8,r12
8000be30:	18 49       	or	r9,r12
8000be32:	f0 05 09 48 	lsl	r8,r8,r5
8000be36:	20 25       	sub	r5,2
8000be38:	0a 16       	sub	r6,r5
8000be3a:	c8 fb       	rjmp	8000bd58 <__avr32_f64_mul+0x30>
8000be3c:	f0 05 09 49 	lsl	r9,r8,r5
8000be40:	c4 20       	breq	8000bec4 <__avr32_f64_mul_res_zero>
8000be42:	30 08       	mov	r8,0
8000be44:	20 25       	sub	r5,2
8000be46:	0a 16       	sub	r6,r5
8000be48:	c8 8b       	rjmp	8000bd58 <__avr32_f64_mul+0x30>

8000be4a <__avr32_f64_mul_op_nan_or_inf>:
8000be4a:	e4 19 00 0f 	andh	r9,0xf
8000be4e:	e4 1b 00 0f 	andh	r11,0xf
8000be52:	14 4b       	or	r11,r10
8000be54:	10 49       	or	r9,r8
8000be56:	e0 47 07 ff 	cp.w	r7,2047
8000be5a:	c0 91       	brne	8000be6c <__avr32_f64_mul_op1_not_naninf>
8000be5c:	58 0b       	cp.w	r11,0
8000be5e:	c3 81       	brne	8000bece <__avr32_f64_mul_res_nan>
8000be60:	e0 46 07 ff 	cp.w	r6,2047
8000be64:	c3 81       	brne	8000bed4 <__avr32_f64_mul_res_inf>
8000be66:	58 09       	cp.w	r9,0
8000be68:	c3 60       	breq	8000bed4 <__avr32_f64_mul_res_inf>
8000be6a:	c3 28       	rjmp	8000bece <__avr32_f64_mul_res_nan>

8000be6c <__avr32_f64_mul_op1_not_naninf>:
8000be6c:	58 09       	cp.w	r9,0
8000be6e:	c3 30       	breq	8000bed4 <__avr32_f64_mul_res_inf>
8000be70:	c2 f8       	rjmp	8000bece <__avr32_f64_mul_res_nan>

8000be72 <__avr32_f64_mul_res_subnormal>:
8000be72:	5c 3c       	neg	r12
8000be74:	2f fc       	sub	r12,-1
8000be76:	f1 bc 04 c0 	satu	r12,0x6
8000be7a:	e0 4c 00 20 	cp.w	r12,32
8000be7e:	c1 14       	brge	8000bea0 <__avr32_f64_mul_res_subnormal+0x2e>
8000be80:	f8 08 11 20 	rsub	r8,r12,32
8000be84:	0e 46       	or	r6,r7
8000be86:	ee 0c 0a 47 	lsr	r7,r7,r12
8000be8a:	f4 08 09 49 	lsl	r9,r10,r8
8000be8e:	12 47       	or	r7,r9
8000be90:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000be94:	f6 08 09 49 	lsl	r9,r11,r8
8000be98:	12 4a       	or	r10,r9
8000be9a:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000be9e:	c8 3b       	rjmp	8000bda4 <__avr32_f64_mul+0x7c>
8000bea0:	f8 08 11 20 	rsub	r8,r12,32
8000bea4:	f9 b9 00 00 	moveq	r9,0
8000bea8:	c0 30       	breq	8000beae <__avr32_f64_mul_res_subnormal+0x3c>
8000beaa:	f6 08 09 49 	lsl	r9,r11,r8
8000beae:	0e 46       	or	r6,r7
8000beb0:	ed ea 10 16 	or	r6,r6,r10<<0x1
8000beb4:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000beb8:	f3 ea 10 07 	or	r7,r9,r10
8000bebc:	f6 0c 0a 4a 	lsr	r10,r11,r12
8000bec0:	30 0b       	mov	r11,0
8000bec2:	c7 1b       	rjmp	8000bda4 <__avr32_f64_mul+0x7c>

8000bec4 <__avr32_f64_mul_res_zero>:
8000bec4:	1c 9b       	mov	r11,lr
8000bec6:	e6 1b 80 00 	andh	r11,0x8000,COH
8000beca:	30 0a       	mov	r10,0
8000becc:	d8 22       	popm	r4-r7,pc

8000bece <__avr32_f64_mul_res_nan>:
8000bece:	3f fb       	mov	r11,-1
8000bed0:	3f fa       	mov	r10,-1
8000bed2:	d8 22       	popm	r4-r7,pc

8000bed4 <__avr32_f64_mul_res_inf>:
8000bed4:	f0 6b 00 00 	mov	r11,-1048576
8000bed8:	ed be 00 1f 	bld	lr,0x1f
8000bedc:	ef bb 00 1f 	bst	r11,0x1f
8000bee0:	30 0a       	mov	r10,0
8000bee2:	d8 22       	popm	r4-r7,pc

8000bee4 <__avr32_f64_mul_op1_zero>:
8000bee4:	f7 e9 20 0b 	eor	r11,r11,r9
8000bee8:	e6 1b 80 00 	andh	r11,0x8000,COH
8000beec:	f9 d9 c2 8b 	bfextu	r12,r9,0x14,0xb
8000bef0:	e0 4c 07 ff 	cp.w	r12,2047
8000bef4:	5e 1c       	retne	r12
8000bef6:	3f fa       	mov	r10,-1
8000bef8:	3f fb       	mov	r11,-1
8000befa:	5e fc       	retal	r12

8000befc <__avr32_f64_sub_from_add>:
8000befc:	ee 19 80 00 	eorh	r9,0x8000

8000bf00 <__avr32_f64_sub>:
8000bf00:	f7 e9 20 0c 	eor	r12,r11,r9
8000bf04:	e0 86 00 ca 	brmi	8000c098 <__avr32_f64_add_from_sub>
8000bf08:	eb cd 40 e0 	pushm	r5-r7,lr
8000bf0c:	16 9c       	mov	r12,r11
8000bf0e:	e6 1c 80 00 	andh	r12,0x8000,COH
8000bf12:	bf db       	cbr	r11,0x1f
8000bf14:	bf d9       	cbr	r9,0x1f
8000bf16:	10 3a       	cp.w	r10,r8
8000bf18:	f2 0b 13 00 	cpc	r11,r9
8000bf1c:	c0 92       	brcc	8000bf2e <__avr32_f64_sub+0x2e>
8000bf1e:	16 97       	mov	r7,r11
8000bf20:	12 9b       	mov	r11,r9
8000bf22:	0e 99       	mov	r9,r7
8000bf24:	14 97       	mov	r7,r10
8000bf26:	10 9a       	mov	r10,r8
8000bf28:	0e 98       	mov	r8,r7
8000bf2a:	ee 1c 80 00 	eorh	r12,0x8000
8000bf2e:	f6 07 16 14 	lsr	r7,r11,0x14
8000bf32:	ab 7b       	lsl	r11,0xb
8000bf34:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000bf38:	ab 7a       	lsl	r10,0xb
8000bf3a:	bf bb       	sbr	r11,0x1f
8000bf3c:	f2 06 16 14 	lsr	r6,r9,0x14
8000bf40:	c4 40       	breq	8000bfc8 <__avr32_f64_sub_opL_subnormal>
8000bf42:	ab 79       	lsl	r9,0xb
8000bf44:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000bf48:	ab 78       	lsl	r8,0xb
8000bf4a:	bf b9       	sbr	r9,0x1f

8000bf4c <__avr32_f64_sub_opL_subnormal_done>:
8000bf4c:	e0 47 07 ff 	cp.w	r7,2047
8000bf50:	c4 f0       	breq	8000bfee <__avr32_f64_sub_opH_nan_or_inf>
8000bf52:	0e 26       	rsub	r6,r7
8000bf54:	c1 20       	breq	8000bf78 <__avr32_f64_sub_shift_done>
8000bf56:	ec 05 11 20 	rsub	r5,r6,32
8000bf5a:	e0 46 00 20 	cp.w	r6,32
8000bf5e:	c7 c2       	brcc	8000c056 <__avr32_f64_sub_longshift>
8000bf60:	f0 05 09 4e 	lsl	lr,r8,r5
8000bf64:	f2 05 09 45 	lsl	r5,r9,r5
8000bf68:	f0 06 0a 48 	lsr	r8,r8,r6
8000bf6c:	f2 06 0a 49 	lsr	r9,r9,r6
8000bf70:	0a 48       	or	r8,r5
8000bf72:	58 0e       	cp.w	lr,0
8000bf74:	5f 1e       	srne	lr
8000bf76:	1c 48       	or	r8,lr

8000bf78 <__avr32_f64_sub_shift_done>:
8000bf78:	10 1a       	sub	r10,r8
8000bf7a:	f6 09 01 4b 	sbc	r11,r11,r9
8000bf7e:	f6 06 12 00 	clz	r6,r11
8000bf82:	c0 e0       	breq	8000bf9e <__avr32_f64_sub_longnormalize_done>
8000bf84:	c7 83       	brcs	8000c074 <__avr32_f64_sub_longnormalize>
8000bf86:	ec 0e 11 20 	rsub	lr,r6,32
8000bf8a:	f6 06 09 4b 	lsl	r11,r11,r6
8000bf8e:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000bf92:	1c 4b       	or	r11,lr
8000bf94:	f4 06 09 4a 	lsl	r10,r10,r6
8000bf98:	0c 17       	sub	r7,r6
8000bf9a:	e0 8a 00 39 	brle	8000c00c <__avr32_f64_sub_subnormal_result>

8000bf9e <__avr32_f64_sub_longnormalize_done>:
8000bf9e:	f4 09 15 15 	lsl	r9,r10,0x15
8000bfa2:	ab 9a       	lsr	r10,0xb
8000bfa4:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000bfa8:	ab 9b       	lsr	r11,0xb
8000bfaa:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000bfae:	18 4b       	or	r11,r12

8000bfb0 <__avr32_f64_sub_round>:
8000bfb0:	fc 17 80 00 	movh	r7,0x8000
8000bfb4:	ed ba 00 00 	bld	r10,0x0
8000bfb8:	f7 b7 01 ff 	subne	r7,-1
8000bfbc:	0e 39       	cp.w	r9,r7
8000bfbe:	5f 29       	srhs	r9
8000bfc0:	12 0a       	add	r10,r9
8000bfc2:	5c 0b       	acr	r11
8000bfc4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bfc8 <__avr32_f64_sub_opL_subnormal>:
8000bfc8:	ab 79       	lsl	r9,0xb
8000bfca:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000bfce:	ab 78       	lsl	r8,0xb
8000bfd0:	f3 e8 10 0e 	or	lr,r9,r8
8000bfd4:	f9 b6 01 01 	movne	r6,1
8000bfd8:	ee 0e 11 00 	rsub	lr,r7,0
8000bfdc:	f9 b7 00 01 	moveq	r7,1
8000bfe0:	ef bb 00 1f 	bst	r11,0x1f
8000bfe4:	f7 ea 10 0e 	or	lr,r11,r10
8000bfe8:	f9 b7 00 00 	moveq	r7,0
8000bfec:	cb 0b       	rjmp	8000bf4c <__avr32_f64_sub_opL_subnormal_done>

8000bfee <__avr32_f64_sub_opH_nan_or_inf>:
8000bfee:	bf db       	cbr	r11,0x1f
8000bff0:	f7 ea 10 0e 	or	lr,r11,r10
8000bff4:	c0 81       	brne	8000c004 <__avr32_f64_sub_return_nan>
8000bff6:	e0 46 07 ff 	cp.w	r6,2047
8000bffa:	c0 50       	breq	8000c004 <__avr32_f64_sub_return_nan>
8000bffc:	f9 e7 11 4b 	or	r11,r12,r7<<0x14
8000c000:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c004 <__avr32_f64_sub_return_nan>:
8000c004:	3f fa       	mov	r10,-1
8000c006:	3f fb       	mov	r11,-1
8000c008:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c00c <__avr32_f64_sub_subnormal_result>:
8000c00c:	5c 37       	neg	r7
8000c00e:	2f f7       	sub	r7,-1
8000c010:	f1 b7 04 c0 	satu	r7,0x6
8000c014:	e0 47 00 20 	cp.w	r7,32
8000c018:	c1 14       	brge	8000c03a <__avr32_f64_sub_subnormal_result+0x2e>
8000c01a:	ee 08 11 20 	rsub	r8,r7,32
8000c01e:	f4 08 09 49 	lsl	r9,r10,r8
8000c022:	5f 16       	srne	r6
8000c024:	f4 07 0a 4a 	lsr	r10,r10,r7
8000c028:	0c 4a       	or	r10,r6
8000c02a:	f6 08 09 49 	lsl	r9,r11,r8
8000c02e:	f5 e9 10 0a 	or	r10,r10,r9
8000c032:	f4 07 0a 4b 	lsr	r11,r10,r7
8000c036:	30 07       	mov	r7,0
8000c038:	cb 3b       	rjmp	8000bf9e <__avr32_f64_sub_longnormalize_done>
8000c03a:	ee 08 11 40 	rsub	r8,r7,64
8000c03e:	f6 08 09 49 	lsl	r9,r11,r8
8000c042:	14 49       	or	r9,r10
8000c044:	5f 16       	srne	r6
8000c046:	f6 07 0a 4a 	lsr	r10,r11,r7
8000c04a:	0c 4a       	or	r10,r6
8000c04c:	30 0b       	mov	r11,0
8000c04e:	30 07       	mov	r7,0
8000c050:	ca 7b       	rjmp	8000bf9e <__avr32_f64_sub_longnormalize_done>
8000c052:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c056 <__avr32_f64_sub_longshift>:
8000c056:	f1 b6 04 c0 	satu	r6,0x6
8000c05a:	f0 0e 17 00 	moveq	lr,r8
8000c05e:	c0 40       	breq	8000c066 <__avr32_f64_sub_longshift+0x10>
8000c060:	f2 05 09 4e 	lsl	lr,r9,r5
8000c064:	10 4e       	or	lr,r8
8000c066:	f2 06 0a 48 	lsr	r8,r9,r6
8000c06a:	30 09       	mov	r9,0
8000c06c:	58 0e       	cp.w	lr,0
8000c06e:	5f 1e       	srne	lr
8000c070:	1c 48       	or	r8,lr
8000c072:	c8 3b       	rjmp	8000bf78 <__avr32_f64_sub_shift_done>

8000c074 <__avr32_f64_sub_longnormalize>:
8000c074:	f4 06 12 00 	clz	r6,r10
8000c078:	f9 b7 03 00 	movlo	r7,0
8000c07c:	f9 b6 03 00 	movlo	r6,0
8000c080:	f9 bc 03 00 	movlo	r12,0
8000c084:	f7 b6 02 e0 	subhs	r6,-32
8000c088:	f4 06 09 4b 	lsl	r11,r10,r6
8000c08c:	30 0a       	mov	r10,0
8000c08e:	0c 17       	sub	r7,r6
8000c090:	fe 9a ff be 	brle	8000c00c <__avr32_f64_sub_subnormal_result>
8000c094:	c8 5b       	rjmp	8000bf9e <__avr32_f64_sub_longnormalize_done>
8000c096:	d7 03       	nop

8000c098 <__avr32_f64_add_from_sub>:
8000c098:	ee 19 80 00 	eorh	r9,0x8000

8000c09c <__avr32_f64_add>:
8000c09c:	f7 e9 20 0c 	eor	r12,r11,r9
8000c0a0:	fe 96 ff 2e 	brmi	8000befc <__avr32_f64_sub_from_add>
8000c0a4:	eb cd 40 e0 	pushm	r5-r7,lr
8000c0a8:	16 9c       	mov	r12,r11
8000c0aa:	e6 1c 80 00 	andh	r12,0x8000,COH
8000c0ae:	bf db       	cbr	r11,0x1f
8000c0b0:	bf d9       	cbr	r9,0x1f
8000c0b2:	12 3b       	cp.w	r11,r9
8000c0b4:	c0 72       	brcc	8000c0c2 <__avr32_f64_add+0x26>
8000c0b6:	16 97       	mov	r7,r11
8000c0b8:	12 9b       	mov	r11,r9
8000c0ba:	0e 99       	mov	r9,r7
8000c0bc:	14 97       	mov	r7,r10
8000c0be:	10 9a       	mov	r10,r8
8000c0c0:	0e 98       	mov	r8,r7
8000c0c2:	30 0e       	mov	lr,0
8000c0c4:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000c0c8:	f7 db c0 14 	bfextu	r11,r11,0x0,0x14
8000c0cc:	b5 ab       	sbr	r11,0x14
8000c0ce:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000c0d2:	c6 20       	breq	8000c196 <__avr32_f64_add_op2_subnormal>
8000c0d4:	f3 d9 c0 14 	bfextu	r9,r9,0x0,0x14
8000c0d8:	b5 a9       	sbr	r9,0x14
8000c0da:	e0 47 07 ff 	cp.w	r7,2047
8000c0de:	c2 80       	breq	8000c12e <__avr32_f64_add_opH_nan_or_inf>
8000c0e0:	0e 26       	rsub	r6,r7
8000c0e2:	c1 20       	breq	8000c106 <__avr32_f64_add_shift_done>
8000c0e4:	e0 46 00 36 	cp.w	r6,54
8000c0e8:	c1 52       	brcc	8000c112 <__avr32_f64_add_res_of_done>
8000c0ea:	ec 05 11 20 	rsub	r5,r6,32
8000c0ee:	e0 46 00 20 	cp.w	r6,32
8000c0f2:	c3 52       	brcc	8000c15c <__avr32_f64_add_longshift>
8000c0f4:	f0 05 09 4e 	lsl	lr,r8,r5
8000c0f8:	f2 05 09 45 	lsl	r5,r9,r5
8000c0fc:	f0 06 0a 48 	lsr	r8,r8,r6
8000c100:	f2 06 0a 49 	lsr	r9,r9,r6
8000c104:	0a 48       	or	r8,r5

8000c106 <__avr32_f64_add_shift_done>:
8000c106:	10 0a       	add	r10,r8
8000c108:	f6 09 00 4b 	adc	r11,r11,r9
8000c10c:	ed bb 00 15 	bld	r11,0x15
8000c110:	c3 40       	breq	8000c178 <__avr32_f64_add_res_of>

8000c112 <__avr32_f64_add_res_of_done>:
8000c112:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000c116:	18 4b       	or	r11,r12

8000c118 <__avr32_f64_add_round>:
8000c118:	f9 da c0 01 	bfextu	r12,r10,0x0,0x1
8000c11c:	18 4e       	or	lr,r12
8000c11e:	ee 1e 80 00 	eorh	lr,0x8000
8000c122:	f1 be 04 20 	satu	lr,0x1
8000c126:	1c 0a       	add	r10,lr
8000c128:	5c 0b       	acr	r11
8000c12a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c12e <__avr32_f64_add_opH_nan_or_inf>:
8000c12e:	b5 cb       	cbr	r11,0x14
8000c130:	f7 ea 10 0e 	or	lr,r11,r10
8000c134:	c1 01       	brne	8000c154 <__avr32_f64_add_return_nan>
8000c136:	e0 46 07 ff 	cp.w	r6,2047
8000c13a:	c0 30       	breq	8000c140 <__avr32_f64_add_opL_nan_or_inf>
8000c13c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c140 <__avr32_f64_add_opL_nan_or_inf>:
8000c140:	b5 c9       	cbr	r9,0x14
8000c142:	f3 e8 10 0e 	or	lr,r9,r8
8000c146:	c0 71       	brne	8000c154 <__avr32_f64_add_return_nan>
8000c148:	30 0a       	mov	r10,0
8000c14a:	fc 1b 7f f0 	movh	r11,0x7ff0
8000c14e:	18 4b       	or	r11,r12
8000c150:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c154 <__avr32_f64_add_return_nan>:
8000c154:	3f fa       	mov	r10,-1
8000c156:	3f fb       	mov	r11,-1
8000c158:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c15c <__avr32_f64_add_longshift>:
8000c15c:	f1 b6 04 c0 	satu	r6,0x6
8000c160:	f0 0e 17 00 	moveq	lr,r8
8000c164:	c0 60       	breq	8000c170 <__avr32_f64_add_longshift+0x14>
8000c166:	f2 05 09 4e 	lsl	lr,r9,r5
8000c16a:	58 08       	cp.w	r8,0
8000c16c:	5f 18       	srne	r8
8000c16e:	10 4e       	or	lr,r8
8000c170:	f2 06 0a 48 	lsr	r8,r9,r6
8000c174:	30 09       	mov	r9,0
8000c176:	cc 8b       	rjmp	8000c106 <__avr32_f64_add_shift_done>

8000c178 <__avr32_f64_add_res_of>:
8000c178:	fd ee 10 1e 	or	lr,lr,lr<<0x1
8000c17c:	a1 9b       	lsr	r11,0x1
8000c17e:	5d 0a       	ror	r10
8000c180:	5d 0e       	ror	lr
8000c182:	2f f7       	sub	r7,-1
8000c184:	e0 47 07 ff 	cp.w	r7,2047
8000c188:	f9 ba 00 00 	moveq	r10,0
8000c18c:	f9 bb 00 00 	moveq	r11,0
8000c190:	f9 be 00 00 	moveq	lr,0
8000c194:	cb fb       	rjmp	8000c112 <__avr32_f64_add_res_of_done>

8000c196 <__avr32_f64_add_op2_subnormal>:
8000c196:	30 16       	mov	r6,1
8000c198:	58 07       	cp.w	r7,0
8000c19a:	ca 01       	brne	8000c0da <__avr32_f64_add+0x3e>
8000c19c:	b5 cb       	cbr	r11,0x14
8000c19e:	10 0a       	add	r10,r8
8000c1a0:	f6 09 00 4b 	adc	r11,r11,r9
8000c1a4:	18 4b       	or	r11,r12
8000c1a6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000c1aa:	d7 03       	nop

8000c1ac <__avr32_f64_to_u32>:
8000c1ac:	58 0b       	cp.w	r11,0
8000c1ae:	5e 6d       	retmi	0

8000c1b0 <__avr32_f64_to_s32>:
8000c1b0:	f6 0c 15 01 	lsl	r12,r11,0x1
8000c1b4:	b5 9c       	lsr	r12,0x15
8000c1b6:	e0 2c 03 ff 	sub	r12,1023
8000c1ba:	5e 3d       	retlo	0
8000c1bc:	f8 0c 11 1f 	rsub	r12,r12,31
8000c1c0:	16 99       	mov	r9,r11
8000c1c2:	ab 7b       	lsl	r11,0xb
8000c1c4:	bf bb       	sbr	r11,0x1f
8000c1c6:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000c1ca:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000c1ce:	a1 79       	lsl	r9,0x1
8000c1d0:	5e 2b       	reths	r11
8000c1d2:	5c 3b       	neg	r11
8000c1d4:	5e fb       	retal	r11

8000c1d6 <__avr32_u32_to_f64>:
8000c1d6:	f8 cb 00 00 	sub	r11,r12,0
8000c1da:	30 0c       	mov	r12,0
8000c1dc:	c0 38       	rjmp	8000c1e2 <__avr32_s32_to_f64+0x4>

8000c1de <__avr32_s32_to_f64>:
8000c1de:	18 9b       	mov	r11,r12
8000c1e0:	5c 4b       	abs	r11
8000c1e2:	30 0a       	mov	r10,0
8000c1e4:	5e 0b       	reteq	r11
8000c1e6:	d4 01       	pushm	lr
8000c1e8:	e0 69 04 1e 	mov	r9,1054
8000c1ec:	f6 08 12 00 	clz	r8,r11
8000c1f0:	c1 70       	breq	8000c21e <__avr32_s32_to_f64+0x40>
8000c1f2:	c0 c3       	brcs	8000c20a <__avr32_s32_to_f64+0x2c>
8000c1f4:	f0 0e 11 20 	rsub	lr,r8,32
8000c1f8:	f6 08 09 4b 	lsl	r11,r11,r8
8000c1fc:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000c200:	1c 4b       	or	r11,lr
8000c202:	f4 08 09 4a 	lsl	r10,r10,r8
8000c206:	10 19       	sub	r9,r8
8000c208:	c0 b8       	rjmp	8000c21e <__avr32_s32_to_f64+0x40>
8000c20a:	f4 08 12 00 	clz	r8,r10
8000c20e:	f9 b8 03 00 	movlo	r8,0
8000c212:	f7 b8 02 e0 	subhs	r8,-32
8000c216:	f4 08 09 4b 	lsl	r11,r10,r8
8000c21a:	30 0a       	mov	r10,0
8000c21c:	10 19       	sub	r9,r8
8000c21e:	58 09       	cp.w	r9,0
8000c220:	e0 89 00 30 	brgt	8000c280 <__avr32_s32_to_f64+0xa2>
8000c224:	5c 39       	neg	r9
8000c226:	2f f9       	sub	r9,-1
8000c228:	e0 49 00 36 	cp.w	r9,54
8000c22c:	c0 43       	brcs	8000c234 <__avr32_s32_to_f64+0x56>
8000c22e:	30 0b       	mov	r11,0
8000c230:	30 0a       	mov	r10,0
8000c232:	c2 68       	rjmp	8000c27e <__avr32_s32_to_f64+0xa0>
8000c234:	2f 69       	sub	r9,-10
8000c236:	f2 08 11 20 	rsub	r8,r9,32
8000c23a:	e0 49 00 20 	cp.w	r9,32
8000c23e:	c0 b2       	brcc	8000c254 <__avr32_s32_to_f64+0x76>
8000c240:	f4 08 09 4e 	lsl	lr,r10,r8
8000c244:	f6 08 09 48 	lsl	r8,r11,r8
8000c248:	f4 09 0a 4a 	lsr	r10,r10,r9
8000c24c:	f6 09 0a 4b 	lsr	r11,r11,r9
8000c250:	10 4b       	or	r11,r8
8000c252:	c0 88       	rjmp	8000c262 <__avr32_s32_to_f64+0x84>
8000c254:	f6 08 09 4e 	lsl	lr,r11,r8
8000c258:	14 4e       	or	lr,r10
8000c25a:	16 9a       	mov	r10,r11
8000c25c:	30 0b       	mov	r11,0
8000c25e:	f4 09 0a 4a 	lsr	r10,r10,r9
8000c262:	ed ba 00 00 	bld	r10,0x0
8000c266:	c0 92       	brcc	8000c278 <__avr32_s32_to_f64+0x9a>
8000c268:	1c 7e       	tst	lr,lr
8000c26a:	c0 41       	brne	8000c272 <__avr32_s32_to_f64+0x94>
8000c26c:	ed ba 00 01 	bld	r10,0x1
8000c270:	c0 42       	brcc	8000c278 <__avr32_s32_to_f64+0x9a>
8000c272:	2f fa       	sub	r10,-1
8000c274:	f7 bb 02 ff 	subhs	r11,-1
8000c278:	5c fc       	rol	r12
8000c27a:	5d 0b       	ror	r11
8000c27c:	5d 0a       	ror	r10
8000c27e:	d8 02       	popm	pc
8000c280:	e0 68 03 ff 	mov	r8,1023
8000c284:	ed ba 00 0b 	bld	r10,0xb
8000c288:	f7 b8 00 ff 	subeq	r8,-1
8000c28c:	10 0a       	add	r10,r8
8000c28e:	5c 0b       	acr	r11
8000c290:	f7 b9 03 fe 	sublo	r9,-2
8000c294:	e0 49 07 ff 	cp.w	r9,2047
8000c298:	c0 55       	brlt	8000c2a2 <__avr32_s32_to_f64+0xc4>
8000c29a:	30 0a       	mov	r10,0
8000c29c:	fc 1b ff e0 	movh	r11,0xffe0
8000c2a0:	c0 c8       	rjmp	8000c2b8 <__floatsidf_return_op1>
8000c2a2:	ed bb 00 1f 	bld	r11,0x1f
8000c2a6:	f7 b9 01 01 	subne	r9,1
8000c2aa:	ab 9a       	lsr	r10,0xb
8000c2ac:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000c2b0:	a1 7b       	lsl	r11,0x1
8000c2b2:	ab 9b       	lsr	r11,0xb
8000c2b4:	f7 e9 11 5b 	or	r11,r11,r9<<0x15

8000c2b8 <__floatsidf_return_op1>:
8000c2b8:	a1 7c       	lsl	r12,0x1
8000c2ba:	5d 0b       	ror	r11
8000c2bc:	d8 02       	popm	pc

8000c2be <__avr32_f64_cmp_eq>:
8000c2be:	10 3a       	cp.w	r10,r8
8000c2c0:	f2 0b 13 00 	cpc	r11,r9
8000c2c4:	c0 80       	breq	8000c2d4 <__avr32_f64_cmp_eq+0x16>
8000c2c6:	a1 7b       	lsl	r11,0x1
8000c2c8:	a1 79       	lsl	r9,0x1
8000c2ca:	14 4b       	or	r11,r10
8000c2cc:	12 4b       	or	r11,r9
8000c2ce:	10 4b       	or	r11,r8
8000c2d0:	5e 0f       	reteq	1
8000c2d2:	5e fd       	retal	0
8000c2d4:	a1 7b       	lsl	r11,0x1
8000c2d6:	fc 1c ff e0 	movh	r12,0xffe0
8000c2da:	58 0a       	cp.w	r10,0
8000c2dc:	f8 0b 13 00 	cpc	r11,r12
8000c2e0:	5e 8f       	retls	1
8000c2e2:	5e fd       	retal	0

8000c2e4 <__avr32_f64_cmp_ge>:
8000c2e4:	1a de       	st.w	--sp,lr
8000c2e6:	1a d7       	st.w	--sp,r7
8000c2e8:	a1 7b       	lsl	r11,0x1
8000c2ea:	5f 3c       	srlo	r12
8000c2ec:	a1 79       	lsl	r9,0x1
8000c2ee:	5f 37       	srlo	r7
8000c2f0:	5c fc       	rol	r12
8000c2f2:	fc 1e ff e0 	movh	lr,0xffe0
8000c2f6:	58 0a       	cp.w	r10,0
8000c2f8:	fc 0b 13 00 	cpc	r11,lr
8000c2fc:	e0 8b 00 1d 	brhi	8000c336 <__avr32_f64_cmp_ge+0x52>
8000c300:	58 08       	cp.w	r8,0
8000c302:	fc 09 13 00 	cpc	r9,lr
8000c306:	e0 8b 00 18 	brhi	8000c336 <__avr32_f64_cmp_ge+0x52>
8000c30a:	58 0b       	cp.w	r11,0
8000c30c:	f5 ba 00 00 	subfeq	r10,0
8000c310:	c1 50       	breq	8000c33a <__avr32_f64_cmp_ge+0x56>
8000c312:	1b 07       	ld.w	r7,sp++
8000c314:	1b 0e       	ld.w	lr,sp++
8000c316:	58 3c       	cp.w	r12,3
8000c318:	c0 a0       	breq	8000c32c <__avr32_f64_cmp_ge+0x48>
8000c31a:	58 1c       	cp.w	r12,1
8000c31c:	c0 33       	brcs	8000c322 <__avr32_f64_cmp_ge+0x3e>
8000c31e:	5e 0f       	reteq	1
8000c320:	5e 1d       	retne	0
8000c322:	10 3a       	cp.w	r10,r8
8000c324:	f2 0b 13 00 	cpc	r11,r9
8000c328:	5e 2f       	reths	1
8000c32a:	5e 3d       	retlo	0
8000c32c:	14 38       	cp.w	r8,r10
8000c32e:	f6 09 13 00 	cpc	r9,r11
8000c332:	5e 2f       	reths	1
8000c334:	5e 3d       	retlo	0
8000c336:	1b 07       	ld.w	r7,sp++
8000c338:	d8 0a       	popm	pc,r12=0
8000c33a:	58 17       	cp.w	r7,1
8000c33c:	5f 0c       	sreq	r12
8000c33e:	58 09       	cp.w	r9,0
8000c340:	f5 b8 00 00 	subfeq	r8,0
8000c344:	1b 07       	ld.w	r7,sp++
8000c346:	1b 0e       	ld.w	lr,sp++
8000c348:	5e 0f       	reteq	1
8000c34a:	5e fc       	retal	r12

8000c34c <__avr32_f64_cmp_lt>:
8000c34c:	1a de       	st.w	--sp,lr
8000c34e:	1a d7       	st.w	--sp,r7
8000c350:	a1 7b       	lsl	r11,0x1
8000c352:	5f 3c       	srlo	r12
8000c354:	a1 79       	lsl	r9,0x1
8000c356:	5f 37       	srlo	r7
8000c358:	5c fc       	rol	r12
8000c35a:	fc 1e ff e0 	movh	lr,0xffe0
8000c35e:	58 0a       	cp.w	r10,0
8000c360:	fc 0b 13 00 	cpc	r11,lr
8000c364:	e0 8b 00 1d 	brhi	8000c39e <__avr32_f64_cmp_lt+0x52>
8000c368:	58 08       	cp.w	r8,0
8000c36a:	fc 09 13 00 	cpc	r9,lr
8000c36e:	e0 8b 00 18 	brhi	8000c39e <__avr32_f64_cmp_lt+0x52>
8000c372:	58 0b       	cp.w	r11,0
8000c374:	f5 ba 00 00 	subfeq	r10,0
8000c378:	c1 50       	breq	8000c3a2 <__avr32_f64_cmp_lt+0x56>
8000c37a:	1b 07       	ld.w	r7,sp++
8000c37c:	1b 0e       	ld.w	lr,sp++
8000c37e:	58 3c       	cp.w	r12,3
8000c380:	c0 a0       	breq	8000c394 <__avr32_f64_cmp_lt+0x48>
8000c382:	58 1c       	cp.w	r12,1
8000c384:	c0 33       	brcs	8000c38a <__avr32_f64_cmp_lt+0x3e>
8000c386:	5e 0d       	reteq	0
8000c388:	5e 1f       	retne	1
8000c38a:	10 3a       	cp.w	r10,r8
8000c38c:	f2 0b 13 00 	cpc	r11,r9
8000c390:	5e 2d       	reths	0
8000c392:	5e 3f       	retlo	1
8000c394:	14 38       	cp.w	r8,r10
8000c396:	f6 09 13 00 	cpc	r9,r11
8000c39a:	5e 2d       	reths	0
8000c39c:	5e 3f       	retlo	1
8000c39e:	1b 07       	ld.w	r7,sp++
8000c3a0:	d8 0a       	popm	pc,r12=0
8000c3a2:	58 17       	cp.w	r7,1
8000c3a4:	5f 1c       	srne	r12
8000c3a6:	58 09       	cp.w	r9,0
8000c3a8:	f5 b8 00 00 	subfeq	r8,0
8000c3ac:	1b 07       	ld.w	r7,sp++
8000c3ae:	1b 0e       	ld.w	lr,sp++
8000c3b0:	5e 0d       	reteq	0
8000c3b2:	5e fc       	retal	r12

8000c3b4 <__avr32_f64_div>:
8000c3b4:	eb cd 40 ff 	pushm	r0-r7,lr
8000c3b8:	f7 e9 20 0e 	eor	lr,r11,r9
8000c3bc:	f6 07 16 14 	lsr	r7,r11,0x14
8000c3c0:	a9 7b       	lsl	r11,0x9
8000c3c2:	f7 ea 13 7b 	or	r11,r11,r10>>0x17
8000c3c6:	a9 7a       	lsl	r10,0x9
8000c3c8:	bd bb       	sbr	r11,0x1d
8000c3ca:	e4 1b 3f ff 	andh	r11,0x3fff
8000c3ce:	ab d7       	cbr	r7,0xb
8000c3d0:	e0 80 00 cc 	breq	8000c568 <__avr32_f64_div_round_subnormal+0x54>
8000c3d4:	e0 47 07 ff 	cp.w	r7,2047
8000c3d8:	e0 84 00 b5 	brge	8000c542 <__avr32_f64_div_round_subnormal+0x2e>
8000c3dc:	f2 06 16 14 	lsr	r6,r9,0x14
8000c3e0:	a9 79       	lsl	r9,0x9
8000c3e2:	f3 e8 13 79 	or	r9,r9,r8>>0x17
8000c3e6:	a9 78       	lsl	r8,0x9
8000c3e8:	bd b9       	sbr	r9,0x1d
8000c3ea:	e4 19 3f ff 	andh	r9,0x3fff
8000c3ee:	ab d6       	cbr	r6,0xb
8000c3f0:	e0 80 00 e2 	breq	8000c5b4 <__avr32_f64_div_round_subnormal+0xa0>
8000c3f4:	e0 46 07 ff 	cp.w	r6,2047
8000c3f8:	e0 84 00 b2 	brge	8000c55c <__avr32_f64_div_round_subnormal+0x48>
8000c3fc:	0c 17       	sub	r7,r6
8000c3fe:	fe 37 fc 01 	sub	r7,-1023
8000c402:	fc 1c 80 00 	movh	r12,0x8000
8000c406:	f8 03 16 01 	lsr	r3,r12,0x1
8000c40a:	e9 d9 c3 62 	bfextu	r4,r9,0x1b,0x2
8000c40e:	5c d4       	com	r4
8000c410:	e7 d4 d3 82 	bfins	r3,r4,0x1c,0x2
8000c414:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c418:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000c41c:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c420:	ea 03 15 02 	lsl	r3,r5,0x2
8000c424:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c428:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000c42c:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c430:	ea 03 15 02 	lsl	r3,r5,0x2
8000c434:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c438:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000c43c:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c440:	ea 03 15 02 	lsl	r3,r5,0x2
8000c444:	e6 08 06 40 	mulu.d	r0,r3,r8
8000c448:	e4 09 07 40 	macu.d	r0,r2,r9
8000c44c:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c450:	02 04       	add	r4,r1
8000c452:	5c 05       	acr	r5
8000c454:	a3 65       	lsl	r5,0x2
8000c456:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000c45a:	a3 64       	lsl	r4,0x2
8000c45c:	5c 34       	neg	r4
8000c45e:	f8 05 01 45 	sbc	r5,r12,r5
8000c462:	e6 04 06 40 	mulu.d	r0,r3,r4
8000c466:	e4 05 07 40 	macu.d	r0,r2,r5
8000c46a:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c46e:	02 04       	add	r4,r1
8000c470:	5c 05       	acr	r5
8000c472:	ea 03 15 02 	lsl	r3,r5,0x2
8000c476:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000c47a:	e8 02 15 02 	lsl	r2,r4,0x2
8000c47e:	e6 08 06 40 	mulu.d	r0,r3,r8
8000c482:	e4 09 07 40 	macu.d	r0,r2,r9
8000c486:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c48a:	02 04       	add	r4,r1
8000c48c:	5c 05       	acr	r5
8000c48e:	a3 65       	lsl	r5,0x2
8000c490:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000c494:	a3 64       	lsl	r4,0x2
8000c496:	5c 34       	neg	r4
8000c498:	f8 05 01 45 	sbc	r5,r12,r5
8000c49c:	e6 04 06 40 	mulu.d	r0,r3,r4
8000c4a0:	e4 05 07 40 	macu.d	r0,r2,r5
8000c4a4:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c4a8:	02 04       	add	r4,r1
8000c4aa:	5c 05       	acr	r5
8000c4ac:	ea 03 15 02 	lsl	r3,r5,0x2
8000c4b0:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000c4b4:	e8 02 15 02 	lsl	r2,r4,0x2
8000c4b8:	e6 0a 06 40 	mulu.d	r0,r3,r10
8000c4bc:	e4 0b 07 40 	macu.d	r0,r2,r11
8000c4c0:	e6 0b 06 42 	mulu.d	r2,r3,r11
8000c4c4:	02 02       	add	r2,r1
8000c4c6:	5c 03       	acr	r3
8000c4c8:	ed b3 00 1c 	bld	r3,0x1c
8000c4cc:	c0 90       	breq	8000c4de <__avr32_f64_div+0x12a>
8000c4ce:	a1 72       	lsl	r2,0x1
8000c4d0:	5c f3       	rol	r3
8000c4d2:	20 17       	sub	r7,1
8000c4d4:	a3 9a       	lsr	r10,0x3
8000c4d6:	f5 eb 11 da 	or	r10,r10,r11<<0x1d
8000c4da:	a3 9b       	lsr	r11,0x3
8000c4dc:	c0 58       	rjmp	8000c4e6 <__avr32_f64_div+0x132>
8000c4de:	a5 8a       	lsr	r10,0x4
8000c4e0:	f5 eb 11 ca 	or	r10,r10,r11<<0x1c
8000c4e4:	a5 8b       	lsr	r11,0x4
8000c4e6:	58 07       	cp.w	r7,0
8000c4e8:	e0 8a 00 8b 	brle	8000c5fe <__avr32_f64_div_res_subnormal>
8000c4ec:	e0 12 ff 00 	andl	r2,0xff00
8000c4f0:	e8 12 00 80 	orl	r2,0x80
8000c4f4:	e6 08 06 40 	mulu.d	r0,r3,r8
8000c4f8:	e4 09 07 40 	macu.d	r0,r2,r9
8000c4fc:	e4 08 06 44 	mulu.d	r4,r2,r8
8000c500:	e6 09 06 48 	mulu.d	r8,r3,r9
8000c504:	00 05       	add	r5,r0
8000c506:	f0 01 00 48 	adc	r8,r8,r1
8000c50a:	5c 09       	acr	r9
8000c50c:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000c510:	58 04       	cp.w	r4,0
8000c512:	5c 25       	cpc	r5

8000c514 <__avr32_f64_div_round_subnormal>:
8000c514:	f4 08 13 00 	cpc	r8,r10
8000c518:	f6 09 13 00 	cpc	r9,r11
8000c51c:	5f 36       	srlo	r6
8000c51e:	f8 06 17 00 	moveq	r6,r12
8000c522:	e4 0a 16 08 	lsr	r10,r2,0x8
8000c526:	f5 e3 11 8a 	or	r10,r10,r3<<0x18
8000c52a:	e6 0b 16 08 	lsr	r11,r3,0x8
8000c52e:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000c532:	ed be 00 1f 	bld	lr,0x1f
8000c536:	ef bb 00 1f 	bst	r11,0x1f
8000c53a:	0c 0a       	add	r10,r6
8000c53c:	5c 0b       	acr	r11
8000c53e:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000c542:	e4 1b 00 0f 	andh	r11,0xf
8000c546:	14 4b       	or	r11,r10
8000c548:	e0 81 00 a7 	brne	8000c696 <__avr32_f64_div_res_subnormal+0x98>
8000c54c:	f2 06 16 14 	lsr	r6,r9,0x14
8000c550:	ab d6       	cbr	r6,0xb
8000c552:	e0 46 07 ff 	cp.w	r6,2047
8000c556:	e0 81 00 a4 	brne	8000c69e <__avr32_f64_div_res_subnormal+0xa0>
8000c55a:	c9 e8       	rjmp	8000c696 <__avr32_f64_div_res_subnormal+0x98>
8000c55c:	e4 19 00 0f 	andh	r9,0xf
8000c560:	10 49       	or	r9,r8
8000c562:	e0 81 00 9a 	brne	8000c696 <__avr32_f64_div_res_subnormal+0x98>
8000c566:	c9 28       	rjmp	8000c68a <__avr32_f64_div_res_subnormal+0x8c>
8000c568:	a3 7b       	lsl	r11,0x3
8000c56a:	f7 ea 13 db 	or	r11,r11,r10>>0x1d
8000c56e:	a3 7a       	lsl	r10,0x3
8000c570:	f5 eb 10 04 	or	r4,r10,r11
8000c574:	e0 80 00 a0 	breq	8000c6b4 <__avr32_f64_div_op1_zero>
8000c578:	f6 04 12 00 	clz	r4,r11
8000c57c:	c1 70       	breq	8000c5aa <__avr32_f64_div_round_subnormal+0x96>
8000c57e:	c0 c3       	brcs	8000c596 <__avr32_f64_div_round_subnormal+0x82>
8000c580:	e8 05 11 20 	rsub	r5,r4,32
8000c584:	f6 04 09 4b 	lsl	r11,r11,r4
8000c588:	f4 05 0a 45 	lsr	r5,r10,r5
8000c58c:	0a 4b       	or	r11,r5
8000c58e:	f4 04 09 4a 	lsl	r10,r10,r4
8000c592:	08 17       	sub	r7,r4
8000c594:	c0 b8       	rjmp	8000c5aa <__avr32_f64_div_round_subnormal+0x96>
8000c596:	f4 04 12 00 	clz	r4,r10
8000c59a:	f9 b4 03 00 	movlo	r4,0
8000c59e:	f7 b4 02 e0 	subhs	r4,-32
8000c5a2:	f4 04 09 4b 	lsl	r11,r10,r4
8000c5a6:	30 0a       	mov	r10,0
8000c5a8:	08 17       	sub	r7,r4
8000c5aa:	a3 8a       	lsr	r10,0x2
8000c5ac:	f5 eb 11 ea 	or	r10,r10,r11<<0x1e
8000c5b0:	a3 8b       	lsr	r11,0x2
8000c5b2:	c1 1b       	rjmp	8000c3d4 <__avr32_f64_div+0x20>
8000c5b4:	a3 79       	lsl	r9,0x3
8000c5b6:	f3 e8 13 d9 	or	r9,r9,r8>>0x1d
8000c5ba:	a3 78       	lsl	r8,0x3
8000c5bc:	f3 e8 10 04 	or	r4,r9,r8
8000c5c0:	c6 f0       	breq	8000c69e <__avr32_f64_div_res_subnormal+0xa0>
8000c5c2:	f2 04 12 00 	clz	r4,r9
8000c5c6:	c1 70       	breq	8000c5f4 <__avr32_f64_div_round_subnormal+0xe0>
8000c5c8:	c0 c3       	brcs	8000c5e0 <__avr32_f64_div_round_subnormal+0xcc>
8000c5ca:	e8 05 11 20 	rsub	r5,r4,32
8000c5ce:	f2 04 09 49 	lsl	r9,r9,r4
8000c5d2:	f0 05 0a 45 	lsr	r5,r8,r5
8000c5d6:	0a 49       	or	r9,r5
8000c5d8:	f0 04 09 48 	lsl	r8,r8,r4
8000c5dc:	08 16       	sub	r6,r4
8000c5de:	c0 b8       	rjmp	8000c5f4 <__avr32_f64_div_round_subnormal+0xe0>
8000c5e0:	f0 04 12 00 	clz	r4,r8
8000c5e4:	f9 b4 03 00 	movlo	r4,0
8000c5e8:	f7 b4 02 e0 	subhs	r4,-32
8000c5ec:	f0 04 09 49 	lsl	r9,r8,r4
8000c5f0:	30 08       	mov	r8,0
8000c5f2:	08 16       	sub	r6,r4
8000c5f4:	a3 88       	lsr	r8,0x2
8000c5f6:	f1 e9 11 e8 	or	r8,r8,r9<<0x1e
8000c5fa:	a3 89       	lsr	r9,0x2
8000c5fc:	cf ca       	rjmp	8000c3f4 <__avr32_f64_div+0x40>

8000c5fe <__avr32_f64_div_res_subnormal>:
8000c5fe:	5c 37       	neg	r7
8000c600:	2f f7       	sub	r7,-1
8000c602:	f1 b7 04 c0 	satu	r7,0x6
8000c606:	e0 47 00 20 	cp.w	r7,32
8000c60a:	c1 54       	brge	8000c634 <__avr32_f64_div_res_subnormal+0x36>
8000c60c:	ee 06 11 20 	rsub	r6,r7,32
8000c610:	e4 07 0a 42 	lsr	r2,r2,r7
8000c614:	e6 06 09 4c 	lsl	r12,r3,r6
8000c618:	18 42       	or	r2,r12
8000c61a:	e6 07 0a 43 	lsr	r3,r3,r7
8000c61e:	f4 06 09 41 	lsl	r1,r10,r6
8000c622:	f4 07 0a 4a 	lsr	r10,r10,r7
8000c626:	f6 06 09 4c 	lsl	r12,r11,r6
8000c62a:	18 4a       	or	r10,r12
8000c62c:	f6 07 0a 4b 	lsr	r11,r11,r7
8000c630:	30 00       	mov	r0,0
8000c632:	c1 58       	rjmp	8000c65c <__avr32_f64_div_res_subnormal+0x5e>
8000c634:	ee 06 11 20 	rsub	r6,r7,32
8000c638:	f9 b0 00 00 	moveq	r0,0
8000c63c:	f9 bc 00 00 	moveq	r12,0
8000c640:	c0 50       	breq	8000c64a <__avr32_f64_div_res_subnormal+0x4c>
8000c642:	f4 06 09 40 	lsl	r0,r10,r6
8000c646:	f6 06 09 4c 	lsl	r12,r11,r6
8000c64a:	e6 07 0a 42 	lsr	r2,r3,r7
8000c64e:	30 03       	mov	r3,0
8000c650:	f4 07 0a 41 	lsr	r1,r10,r7
8000c654:	18 41       	or	r1,r12
8000c656:	f6 07 0a 4a 	lsr	r10,r11,r7
8000c65a:	30 0b       	mov	r11,0
8000c65c:	e0 12 ff 00 	andl	r2,0xff00
8000c660:	e8 12 00 80 	orl	r2,0x80
8000c664:	e6 08 06 46 	mulu.d	r6,r3,r8
8000c668:	e4 09 07 46 	macu.d	r6,r2,r9
8000c66c:	e4 08 06 44 	mulu.d	r4,r2,r8
8000c670:	e6 09 06 48 	mulu.d	r8,r3,r9
8000c674:	0c 05       	add	r5,r6
8000c676:	f0 07 00 48 	adc	r8,r8,r7
8000c67a:	5c 09       	acr	r9
8000c67c:	30 07       	mov	r7,0
8000c67e:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000c682:	00 34       	cp.w	r4,r0
8000c684:	e2 05 13 00 	cpc	r5,r1
8000c688:	c4 6b       	rjmp	8000c514 <__avr32_f64_div_round_subnormal>
8000c68a:	1c 9b       	mov	r11,lr
8000c68c:	e6 1b 80 00 	andh	r11,0x8000,COH
8000c690:	30 0a       	mov	r10,0
8000c692:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000c696:	3f fb       	mov	r11,-1
8000c698:	30 0a       	mov	r10,0
8000c69a:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000c69e:	f5 eb 10 04 	or	r4,r10,r11
8000c6a2:	c0 90       	breq	8000c6b4 <__avr32_f64_div_op1_zero>
8000c6a4:	1c 9b       	mov	r11,lr
8000c6a6:	e6 1b 80 00 	andh	r11,0x8000,COH
8000c6aa:	ea 1b 7f f0 	orh	r11,0x7ff0
8000c6ae:	30 0a       	mov	r10,0
8000c6b0:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc

8000c6b4 <__avr32_f64_div_op1_zero>:
8000c6b4:	f1 e9 10 15 	or	r5,r8,r9<<0x1
8000c6b8:	ce f0       	breq	8000c696 <__avr32_f64_div_res_subnormal+0x98>
8000c6ba:	e9 d9 c2 8b 	bfextu	r4,r9,0x14,0xb
8000c6be:	e0 44 07 ff 	cp.w	r4,2047
8000c6c2:	ce 41       	brne	8000c68a <__avr32_f64_div_res_subnormal+0x8c>
8000c6c4:	f1 e9 10 c5 	or	r5,r8,r9<<0xc
8000c6c8:	ce 10       	breq	8000c68a <__avr32_f64_div_res_subnormal+0x8c>
8000c6ca:	ce 6b       	rjmp	8000c696 <__avr32_f64_div_res_subnormal+0x98>

8000c6cc <__avr32_udiv64>:
8000c6cc:	d4 31       	pushm	r0-r7,lr
8000c6ce:	1a 97       	mov	r7,sp
8000c6d0:	20 3d       	sub	sp,12
8000c6d2:	10 9c       	mov	r12,r8
8000c6d4:	12 9e       	mov	lr,r9
8000c6d6:	14 93       	mov	r3,r10
8000c6d8:	58 09       	cp.w	r9,0
8000c6da:	e0 81 00 bd 	brne	8000c854 <__avr32_udiv64+0x188>
8000c6de:	16 38       	cp.w	r8,r11
8000c6e0:	e0 88 00 40 	brls	8000c760 <__avr32_udiv64+0x94>
8000c6e4:	f0 08 12 00 	clz	r8,r8
8000c6e8:	c0 d0       	breq	8000c702 <__avr32_udiv64+0x36>
8000c6ea:	f6 08 09 4b 	lsl	r11,r11,r8
8000c6ee:	f0 09 11 20 	rsub	r9,r8,32
8000c6f2:	f8 08 09 4c 	lsl	r12,r12,r8
8000c6f6:	f4 09 0a 49 	lsr	r9,r10,r9
8000c6fa:	f4 08 09 43 	lsl	r3,r10,r8
8000c6fe:	f3 eb 10 0b 	or	r11,r9,r11
8000c702:	f8 0e 16 10 	lsr	lr,r12,0x10
8000c706:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000c70a:	f6 0e 0d 00 	divu	r0,r11,lr
8000c70e:	e6 0b 16 10 	lsr	r11,r3,0x10
8000c712:	00 99       	mov	r9,r0
8000c714:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c718:	e0 0a 02 48 	mul	r8,r0,r10
8000c71c:	10 3b       	cp.w	r11,r8
8000c71e:	c0 a2       	brcc	8000c732 <__avr32_udiv64+0x66>
8000c720:	20 19       	sub	r9,1
8000c722:	18 0b       	add	r11,r12
8000c724:	18 3b       	cp.w	r11,r12
8000c726:	c0 63       	brcs	8000c732 <__avr32_udiv64+0x66>
8000c728:	10 3b       	cp.w	r11,r8
8000c72a:	f7 b9 03 01 	sublo	r9,1
8000c72e:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c732:	f6 08 01 01 	sub	r1,r11,r8
8000c736:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000c73a:	e2 0e 0d 00 	divu	r0,r1,lr
8000c73e:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000c742:	00 98       	mov	r8,r0
8000c744:	e0 0a 02 4a 	mul	r10,r0,r10
8000c748:	14 33       	cp.w	r3,r10
8000c74a:	c0 82       	brcc	8000c75a <__avr32_udiv64+0x8e>
8000c74c:	20 18       	sub	r8,1
8000c74e:	18 03       	add	r3,r12
8000c750:	18 33       	cp.w	r3,r12
8000c752:	c0 43       	brcs	8000c75a <__avr32_udiv64+0x8e>
8000c754:	14 33       	cp.w	r3,r10
8000c756:	f7 b8 03 01 	sublo	r8,1
8000c75a:	f1 e9 11 08 	or	r8,r8,r9<<0x10
8000c75e:	cd f8       	rjmp	8000c91c <__avr32_udiv64+0x250>
8000c760:	58 08       	cp.w	r8,0
8000c762:	c0 51       	brne	8000c76c <__avr32_udiv64+0xa0>
8000c764:	30 19       	mov	r9,1
8000c766:	f2 08 0d 08 	divu	r8,r9,r8
8000c76a:	10 9c       	mov	r12,r8
8000c76c:	f8 06 12 00 	clz	r6,r12
8000c770:	c0 41       	brne	8000c778 <__avr32_udiv64+0xac>
8000c772:	18 1b       	sub	r11,r12
8000c774:	30 19       	mov	r9,1
8000c776:	c4 08       	rjmp	8000c7f6 <__avr32_udiv64+0x12a>
8000c778:	ec 01 11 20 	rsub	r1,r6,32
8000c77c:	f4 01 0a 49 	lsr	r9,r10,r1
8000c780:	f8 06 09 4c 	lsl	r12,r12,r6
8000c784:	f6 06 09 48 	lsl	r8,r11,r6
8000c788:	f6 01 0a 41 	lsr	r1,r11,r1
8000c78c:	f3 e8 10 08 	or	r8,r9,r8
8000c790:	f8 03 16 10 	lsr	r3,r12,0x10
8000c794:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000c798:	e2 03 0d 00 	divu	r0,r1,r3
8000c79c:	f0 0b 16 10 	lsr	r11,r8,0x10
8000c7a0:	00 9e       	mov	lr,r0
8000c7a2:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c7a6:	e0 05 02 49 	mul	r9,r0,r5
8000c7aa:	12 3b       	cp.w	r11,r9
8000c7ac:	c0 a2       	brcc	8000c7c0 <__avr32_udiv64+0xf4>
8000c7ae:	20 1e       	sub	lr,1
8000c7b0:	18 0b       	add	r11,r12
8000c7b2:	18 3b       	cp.w	r11,r12
8000c7b4:	c0 63       	brcs	8000c7c0 <__avr32_udiv64+0xf4>
8000c7b6:	12 3b       	cp.w	r11,r9
8000c7b8:	f7 be 03 01 	sublo	lr,1
8000c7bc:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c7c0:	12 1b       	sub	r11,r9
8000c7c2:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
8000c7c6:	f6 03 0d 02 	divu	r2,r11,r3
8000c7ca:	f1 e3 11 08 	or	r8,r8,r3<<0x10
8000c7ce:	04 99       	mov	r9,r2
8000c7d0:	e4 05 02 4b 	mul	r11,r2,r5
8000c7d4:	16 38       	cp.w	r8,r11
8000c7d6:	c0 a2       	brcc	8000c7ea <__avr32_udiv64+0x11e>
8000c7d8:	20 19       	sub	r9,1
8000c7da:	18 08       	add	r8,r12
8000c7dc:	18 38       	cp.w	r8,r12
8000c7de:	c0 63       	brcs	8000c7ea <__avr32_udiv64+0x11e>
8000c7e0:	16 38       	cp.w	r8,r11
8000c7e2:	f7 b9 03 01 	sublo	r9,1
8000c7e6:	f1 dc e3 08 	addcs	r8,r8,r12
8000c7ea:	f4 06 09 43 	lsl	r3,r10,r6
8000c7ee:	f0 0b 01 0b 	sub	r11,r8,r11
8000c7f2:	f3 ee 11 09 	or	r9,r9,lr<<0x10
8000c7f6:	f8 06 16 10 	lsr	r6,r12,0x10
8000c7fa:	fd dc c0 10 	bfextu	lr,r12,0x0,0x10
8000c7fe:	f6 06 0d 00 	divu	r0,r11,r6
8000c802:	e6 0b 16 10 	lsr	r11,r3,0x10
8000c806:	00 9a       	mov	r10,r0
8000c808:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c80c:	e0 0e 02 48 	mul	r8,r0,lr
8000c810:	10 3b       	cp.w	r11,r8
8000c812:	c0 a2       	brcc	8000c826 <__avr32_udiv64+0x15a>
8000c814:	20 1a       	sub	r10,1
8000c816:	18 0b       	add	r11,r12
8000c818:	18 3b       	cp.w	r11,r12
8000c81a:	c0 63       	brcs	8000c826 <__avr32_udiv64+0x15a>
8000c81c:	10 3b       	cp.w	r11,r8
8000c81e:	f7 ba 03 01 	sublo	r10,1
8000c822:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c826:	f6 08 01 01 	sub	r1,r11,r8
8000c82a:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000c82e:	e2 06 0d 00 	divu	r0,r1,r6
8000c832:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000c836:	00 98       	mov	r8,r0
8000c838:	e0 0e 02 4b 	mul	r11,r0,lr
8000c83c:	16 33       	cp.w	r3,r11
8000c83e:	c0 82       	brcc	8000c84e <__avr32_udiv64+0x182>
8000c840:	20 18       	sub	r8,1
8000c842:	18 03       	add	r3,r12
8000c844:	18 33       	cp.w	r3,r12
8000c846:	c0 43       	brcs	8000c84e <__avr32_udiv64+0x182>
8000c848:	16 33       	cp.w	r3,r11
8000c84a:	f7 b8 03 01 	sublo	r8,1
8000c84e:	f1 ea 11 08 	or	r8,r8,r10<<0x10
8000c852:	c6 98       	rjmp	8000c924 <__avr32_udiv64+0x258>
8000c854:	16 39       	cp.w	r9,r11
8000c856:	e0 8b 00 65 	brhi	8000c920 <__avr32_udiv64+0x254>
8000c85a:	f2 09 12 00 	clz	r9,r9
8000c85e:	c0 b1       	brne	8000c874 <__avr32_udiv64+0x1a8>
8000c860:	10 3a       	cp.w	r10,r8
8000c862:	5f 2a       	srhs	r10
8000c864:	1c 3b       	cp.w	r11,lr
8000c866:	5f b8       	srhi	r8
8000c868:	10 4a       	or	r10,r8
8000c86a:	f2 0a 18 00 	cp.b	r10,r9
8000c86e:	c5 90       	breq	8000c920 <__avr32_udiv64+0x254>
8000c870:	30 18       	mov	r8,1
8000c872:	c5 98       	rjmp	8000c924 <__avr32_udiv64+0x258>
8000c874:	f0 09 09 46 	lsl	r6,r8,r9
8000c878:	f2 03 11 20 	rsub	r3,r9,32
8000c87c:	fc 09 09 4e 	lsl	lr,lr,r9
8000c880:	f0 03 0a 48 	lsr	r8,r8,r3
8000c884:	f6 09 09 4c 	lsl	r12,r11,r9
8000c888:	f4 03 0a 42 	lsr	r2,r10,r3
8000c88c:	ef 46 ff f4 	st.w	r7[-12],r6
8000c890:	f6 03 0a 43 	lsr	r3,r11,r3
8000c894:	18 42       	or	r2,r12
8000c896:	f1 ee 10 0c 	or	r12,r8,lr
8000c89a:	f8 01 16 10 	lsr	r1,r12,0x10
8000c89e:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000c8a2:	e6 01 0d 04 	divu	r4,r3,r1
8000c8a6:	e4 03 16 10 	lsr	r3,r2,0x10
8000c8aa:	08 9e       	mov	lr,r4
8000c8ac:	e7 e5 11 03 	or	r3,r3,r5<<0x10
8000c8b0:	e8 06 02 48 	mul	r8,r4,r6
8000c8b4:	10 33       	cp.w	r3,r8
8000c8b6:	c0 a2       	brcc	8000c8ca <__avr32_udiv64+0x1fe>
8000c8b8:	20 1e       	sub	lr,1
8000c8ba:	18 03       	add	r3,r12
8000c8bc:	18 33       	cp.w	r3,r12
8000c8be:	c0 63       	brcs	8000c8ca <__avr32_udiv64+0x1fe>
8000c8c0:	10 33       	cp.w	r3,r8
8000c8c2:	f7 be 03 01 	sublo	lr,1
8000c8c6:	e7 dc e3 03 	addcs	r3,r3,r12
8000c8ca:	10 13       	sub	r3,r8
8000c8cc:	f7 d2 c0 10 	bfextu	r11,r2,0x0,0x10
8000c8d0:	e6 01 0d 00 	divu	r0,r3,r1
8000c8d4:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c8d8:	00 98       	mov	r8,r0
8000c8da:	e0 06 02 46 	mul	r6,r0,r6
8000c8de:	0c 3b       	cp.w	r11,r6
8000c8e0:	c0 a2       	brcc	8000c8f4 <__avr32_udiv64+0x228>
8000c8e2:	20 18       	sub	r8,1
8000c8e4:	18 0b       	add	r11,r12
8000c8e6:	18 3b       	cp.w	r11,r12
8000c8e8:	c0 63       	brcs	8000c8f4 <__avr32_udiv64+0x228>
8000c8ea:	0c 3b       	cp.w	r11,r6
8000c8ec:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c8f0:	f7 b8 03 01 	sublo	r8,1
8000c8f4:	f1 ee 11 08 	or	r8,r8,lr<<0x10
8000c8f8:	ee f4 ff f4 	ld.w	r4,r7[-12]
8000c8fc:	0c 1b       	sub	r11,r6
8000c8fe:	f0 04 06 42 	mulu.d	r2,r8,r4
8000c902:	06 95       	mov	r5,r3
8000c904:	16 35       	cp.w	r5,r11
8000c906:	e0 8b 00 0a 	brhi	8000c91a <__avr32_udiv64+0x24e>
8000c90a:	5f 0b       	sreq	r11
8000c90c:	f4 09 09 49 	lsl	r9,r10,r9
8000c910:	12 32       	cp.w	r2,r9
8000c912:	5f b9       	srhi	r9
8000c914:	f7 e9 00 09 	and	r9,r11,r9
8000c918:	c0 60       	breq	8000c924 <__avr32_udiv64+0x258>
8000c91a:	20 18       	sub	r8,1
8000c91c:	30 09       	mov	r9,0
8000c91e:	c0 38       	rjmp	8000c924 <__avr32_udiv64+0x258>
8000c920:	30 09       	mov	r9,0
8000c922:	12 98       	mov	r8,r9
8000c924:	10 9a       	mov	r10,r8
8000c926:	12 93       	mov	r3,r9
8000c928:	10 92       	mov	r2,r8
8000c92a:	12 9b       	mov	r11,r9
8000c92c:	2f dd       	sub	sp,-12
8000c92e:	d8 32       	popm	r0-r7,pc

8000c930 <__avr32_umod64>:
8000c930:	d4 31       	pushm	r0-r7,lr
8000c932:	1a 97       	mov	r7,sp
8000c934:	20 3d       	sub	sp,12
8000c936:	10 9c       	mov	r12,r8
8000c938:	12 95       	mov	r5,r9
8000c93a:	14 9e       	mov	lr,r10
8000c93c:	16 91       	mov	r1,r11
8000c93e:	16 96       	mov	r6,r11
8000c940:	58 09       	cp.w	r9,0
8000c942:	e0 81 00 81 	brne	8000ca44 <__avr32_umod64+0x114>
8000c946:	16 38       	cp.w	r8,r11
8000c948:	e0 88 00 12 	brls	8000c96c <__avr32_umod64+0x3c>
8000c94c:	f0 08 12 00 	clz	r8,r8
8000c950:	c4 e0       	breq	8000c9ec <__avr32_umod64+0xbc>
8000c952:	f6 08 09 46 	lsl	r6,r11,r8
8000c956:	f8 08 09 4c 	lsl	r12,r12,r8
8000c95a:	f0 0b 11 20 	rsub	r11,r8,32
8000c95e:	f4 08 09 4e 	lsl	lr,r10,r8
8000c962:	f4 0b 0a 4b 	lsr	r11,r10,r11
8000c966:	f7 e6 10 06 	or	r6,r11,r6
8000c96a:	c4 18       	rjmp	8000c9ec <__avr32_umod64+0xbc>
8000c96c:	58 08       	cp.w	r8,0
8000c96e:	c0 51       	brne	8000c978 <__avr32_umod64+0x48>
8000c970:	30 19       	mov	r9,1
8000c972:	f2 08 0d 08 	divu	r8,r9,r8
8000c976:	10 9c       	mov	r12,r8
8000c978:	f8 08 12 00 	clz	r8,r12
8000c97c:	c0 31       	brne	8000c982 <__avr32_umod64+0x52>
8000c97e:	18 16       	sub	r6,r12
8000c980:	c3 68       	rjmp	8000c9ec <__avr32_umod64+0xbc>
8000c982:	f0 03 11 20 	rsub	r3,r8,32
8000c986:	f4 03 0a 4b 	lsr	r11,r10,r3
8000c98a:	f8 08 09 4c 	lsl	r12,r12,r8
8000c98e:	ec 08 09 49 	lsl	r9,r6,r8
8000c992:	ec 03 0a 43 	lsr	r3,r6,r3
8000c996:	f7 e9 10 09 	or	r9,r11,r9
8000c99a:	f8 05 16 10 	lsr	r5,r12,0x10
8000c99e:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000c9a2:	e6 05 0d 02 	divu	r2,r3,r5
8000c9a6:	f2 0e 16 10 	lsr	lr,r9,0x10
8000c9aa:	ec 02 02 4b 	mul	r11,r6,r2
8000c9ae:	fd e3 11 0e 	or	lr,lr,r3<<0x10
8000c9b2:	16 3e       	cp.w	lr,r11
8000c9b4:	c0 72       	brcc	8000c9c2 <__avr32_umod64+0x92>
8000c9b6:	18 0e       	add	lr,r12
8000c9b8:	18 3e       	cp.w	lr,r12
8000c9ba:	c0 43       	brcs	8000c9c2 <__avr32_umod64+0x92>
8000c9bc:	16 3e       	cp.w	lr,r11
8000c9be:	fd dc e3 0e 	addcs	lr,lr,r12
8000c9c2:	fc 0b 01 03 	sub	r3,lr,r11
8000c9c6:	f3 d9 c0 10 	bfextu	r9,r9,0x0,0x10
8000c9ca:	e6 05 0d 02 	divu	r2,r3,r5
8000c9ce:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000c9d2:	a5 36       	mul	r6,r2
8000c9d4:	0c 39       	cp.w	r9,r6
8000c9d6:	c0 72       	brcc	8000c9e4 <__avr32_umod64+0xb4>
8000c9d8:	18 09       	add	r9,r12
8000c9da:	18 39       	cp.w	r9,r12
8000c9dc:	c0 43       	brcs	8000c9e4 <__avr32_umod64+0xb4>
8000c9de:	0c 39       	cp.w	r9,r6
8000c9e0:	f3 dc e3 09 	addcs	r9,r9,r12
8000c9e4:	f2 06 01 06 	sub	r6,r9,r6
8000c9e8:	f4 08 09 4e 	lsl	lr,r10,r8
8000c9ec:	f8 0a 16 10 	lsr	r10,r12,0x10
8000c9f0:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000c9f4:	ec 0a 0d 02 	divu	r2,r6,r10
8000c9f8:	fc 09 16 10 	lsr	r9,lr,0x10
8000c9fc:	ea 02 02 4b 	mul	r11,r5,r2
8000ca00:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000ca04:	16 39       	cp.w	r9,r11
8000ca06:	c0 72       	brcc	8000ca14 <__avr32_umod64+0xe4>
8000ca08:	18 09       	add	r9,r12
8000ca0a:	18 39       	cp.w	r9,r12
8000ca0c:	c0 43       	brcs	8000ca14 <__avr32_umod64+0xe4>
8000ca0e:	16 39       	cp.w	r9,r11
8000ca10:	f3 dc e3 09 	addcs	r9,r9,r12
8000ca14:	f2 0b 01 0b 	sub	r11,r9,r11
8000ca18:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000ca1c:	f6 0a 0d 0a 	divu	r10,r11,r10
8000ca20:	fd eb 11 0e 	or	lr,lr,r11<<0x10
8000ca24:	ea 0a 02 4a 	mul	r10,r5,r10
8000ca28:	14 3e       	cp.w	lr,r10
8000ca2a:	c0 72       	brcc	8000ca38 <__avr32_umod64+0x108>
8000ca2c:	18 0e       	add	lr,r12
8000ca2e:	18 3e       	cp.w	lr,r12
8000ca30:	c0 43       	brcs	8000ca38 <__avr32_umod64+0x108>
8000ca32:	14 3e       	cp.w	lr,r10
8000ca34:	fd dc e3 0e 	addcs	lr,lr,r12
8000ca38:	fc 0a 01 0a 	sub	r10,lr,r10
8000ca3c:	30 0b       	mov	r11,0
8000ca3e:	f4 08 0a 4a 	lsr	r10,r10,r8
8000ca42:	c7 b8       	rjmp	8000cb38 <__avr32_umod64+0x208>
8000ca44:	16 39       	cp.w	r9,r11
8000ca46:	e0 8b 00 79 	brhi	8000cb38 <__avr32_umod64+0x208>
8000ca4a:	f2 09 12 00 	clz	r9,r9
8000ca4e:	c1 21       	brne	8000ca72 <__avr32_umod64+0x142>
8000ca50:	10 3a       	cp.w	r10,r8
8000ca52:	5f 2b       	srhs	r11
8000ca54:	0a 31       	cp.w	r1,r5
8000ca56:	5f ba       	srhi	r10
8000ca58:	f7 ea 10 0a 	or	r10,r11,r10
8000ca5c:	f2 0a 18 00 	cp.b	r10,r9
8000ca60:	c0 60       	breq	8000ca6c <__avr32_umod64+0x13c>
8000ca62:	fc 08 01 0c 	sub	r12,lr,r8
8000ca66:	e2 05 01 46 	sbc	r6,r1,r5
8000ca6a:	18 9e       	mov	lr,r12
8000ca6c:	0c 9b       	mov	r11,r6
8000ca6e:	1c 9a       	mov	r10,lr
8000ca70:	c6 48       	rjmp	8000cb38 <__avr32_umod64+0x208>
8000ca72:	ea 09 09 4c 	lsl	r12,r5,r9
8000ca76:	f2 06 11 20 	rsub	r6,r9,32
8000ca7a:	f6 09 09 4b 	lsl	r11,r11,r9
8000ca7e:	f0 09 09 42 	lsl	r2,r8,r9
8000ca82:	ef 46 ff f4 	st.w	r7[-12],r6
8000ca86:	f0 06 0a 48 	lsr	r8,r8,r6
8000ca8a:	18 48       	or	r8,r12
8000ca8c:	e2 06 0a 4c 	lsr	r12,r1,r6
8000ca90:	f4 09 09 43 	lsl	r3,r10,r9
8000ca94:	fd d8 c0 10 	bfextu	lr,r8,0x0,0x10
8000ca98:	f4 06 0a 4a 	lsr	r10,r10,r6
8000ca9c:	16 4a       	or	r10,r11
8000ca9e:	f0 0b 16 10 	lsr	r11,r8,0x10
8000caa2:	f8 0b 0d 04 	divu	r4,r12,r11
8000caa6:	f4 0c 16 10 	lsr	r12,r10,0x10
8000caaa:	08 91       	mov	r1,r4
8000caac:	f9 e5 11 0c 	or	r12,r12,r5<<0x10
8000cab0:	e8 0e 02 46 	mul	r6,r4,lr
8000cab4:	0c 3c       	cp.w	r12,r6
8000cab6:	c0 a2       	brcc	8000caca <__avr32_umod64+0x19a>
8000cab8:	20 11       	sub	r1,1
8000caba:	10 0c       	add	r12,r8
8000cabc:	10 3c       	cp.w	r12,r8
8000cabe:	c0 63       	brcs	8000caca <__avr32_umod64+0x19a>
8000cac0:	0c 3c       	cp.w	r12,r6
8000cac2:	f7 b1 03 01 	sublo	r1,1
8000cac6:	f9 d8 e3 0c 	addcs	r12,r12,r8
8000caca:	0c 1c       	sub	r12,r6
8000cacc:	f5 da c0 10 	bfextu	r10,r10,0x0,0x10
8000cad0:	f8 0b 0d 04 	divu	r4,r12,r11
8000cad4:	f5 e5 11 0b 	or	r11,r10,r5<<0x10
8000cad8:	08 96       	mov	r6,r4
8000cada:	e8 0e 02 4e 	mul	lr,r4,lr
8000cade:	1c 3b       	cp.w	r11,lr
8000cae0:	c0 a2       	brcc	8000caf4 <__avr32_umod64+0x1c4>
8000cae2:	20 16       	sub	r6,1
8000cae4:	10 0b       	add	r11,r8
8000cae6:	10 3b       	cp.w	r11,r8
8000cae8:	c0 63       	brcs	8000caf4 <__avr32_umod64+0x1c4>
8000caea:	1c 3b       	cp.w	r11,lr
8000caec:	f7 b6 03 01 	sublo	r6,1
8000caf0:	f7 d8 e3 0b 	addcs	r11,r11,r8
8000caf4:	ed e1 11 01 	or	r1,r6,r1<<0x10
8000caf8:	1c 1b       	sub	r11,lr
8000cafa:	e2 02 06 40 	mulu.d	r0,r1,r2
8000cafe:	00 9e       	mov	lr,r0
8000cb00:	02 9c       	mov	r12,r1
8000cb02:	16 3c       	cp.w	r12,r11
8000cb04:	e0 8b 00 08 	brhi	8000cb14 <__avr32_umod64+0x1e4>
8000cb08:	5f 06       	sreq	r6
8000cb0a:	06 30       	cp.w	r0,r3
8000cb0c:	5f ba       	srhi	r10
8000cb0e:	ed ea 00 0a 	and	r10,r6,r10
8000cb12:	c0 60       	breq	8000cb1e <__avr32_umod64+0x1ee>
8000cb14:	fc 02 01 04 	sub	r4,lr,r2
8000cb18:	f8 08 01 4c 	sbc	r12,r12,r8
8000cb1c:	08 9e       	mov	lr,r4
8000cb1e:	e6 0e 01 0a 	sub	r10,r3,lr
8000cb22:	f6 0c 01 4c 	sbc	r12,r11,r12
8000cb26:	ee f1 ff f4 	ld.w	r1,r7[-12]
8000cb2a:	f8 09 0a 4b 	lsr	r11,r12,r9
8000cb2e:	f4 09 0a 4a 	lsr	r10,r10,r9
8000cb32:	f8 01 09 4c 	lsl	r12,r12,r1
8000cb36:	18 4a       	or	r10,r12
8000cb38:	2f dd       	sub	sp,-12
8000cb3a:	d8 32       	popm	r0-r7,pc

Disassembly of section .exception:

8000cc00 <_evba>:
_evba:

        .org  0x000
        // Unrecoverable Exception.
_handle_Unrecoverable_Exception:
        rjmp $
8000cc00:	c0 08       	rjmp	8000cc00 <_evba>
	...

8000cc04 <_handle_TLB_Multiple_Hit>:

        .org  0x004
        // TLB Multiple Hit: UNUSED IN AVR32UC.
_handle_TLB_Multiple_Hit:
        rjmp $
8000cc04:	c0 08       	rjmp	8000cc04 <_handle_TLB_Multiple_Hit>
	...

8000cc08 <_handle_Bus_Error_Data_Fetch>:

        .org  0x008
        // Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
        rjmp $
8000cc08:	c0 08       	rjmp	8000cc08 <_handle_Bus_Error_Data_Fetch>
	...

8000cc0c <_handle_Bus_Error_Instruction_Fetch>:

        .org  0x00C
         // Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
        rjmp $
8000cc0c:	c0 08       	rjmp	8000cc0c <_handle_Bus_Error_Instruction_Fetch>
	...

8000cc10 <_handle_NMI>:

        .org  0x010
        // NMI.
_handle_NMI:
        rjmp $
8000cc10:	c0 08       	rjmp	8000cc10 <_handle_NMI>
	...

8000cc14 <_handle_Instruction_Address>:

        .org  0x014
        // Instruction Address.
_handle_Instruction_Address:
        rjmp $
8000cc14:	c0 08       	rjmp	8000cc14 <_handle_Instruction_Address>
	...

8000cc18 <_handle_ITLB_Protection>:

        .org  0x018
        // ITLB Protection.
_handle_ITLB_Protection:
        rjmp $
8000cc18:	c0 08       	rjmp	8000cc18 <_handle_ITLB_Protection>
	...

8000cc1c <_handle_Breakpoint>:

        .org  0x01C
        // Breakpoint.
_handle_Breakpoint:
        rjmp $
8000cc1c:	c0 08       	rjmp	8000cc1c <_handle_Breakpoint>
	...

8000cc20 <_handle_Illegal_Opcode>:

        .org  0x020
        // Illegal Opcode.
_handle_Illegal_Opcode:
        rjmp $
8000cc20:	c0 08       	rjmp	8000cc20 <_handle_Illegal_Opcode>
	...

8000cc24 <_handle_Unimplemented_Instruction>:

        .org  0x024
        // Unimplemented Instruction.
_handle_Unimplemented_Instruction:
        rjmp $
8000cc24:	c0 08       	rjmp	8000cc24 <_handle_Unimplemented_Instruction>
	...

8000cc28 <_handle_Privilege_Violation>:

        .org  0x028
        // Privilege Violation.
_handle_Privilege_Violation:
        rjmp $
8000cc28:	c0 08       	rjmp	8000cc28 <_handle_Privilege_Violation>
	...

8000cc2c <_handle_Floating_Point>:

        .org  0x02C
        // Floating-Point: UNUSED IN AVR32UC.
_handle_Floating_Point:
        rjmp $
8000cc2c:	c0 08       	rjmp	8000cc2c <_handle_Floating_Point>
	...

8000cc30 <_handle_Coprocessor_Absent>:

        .org  0x030
        // Coprocessor Absent: UNUSED IN AVR32UC.
_handle_Coprocessor_Absent:
        rjmp $
8000cc30:	c0 08       	rjmp	8000cc30 <_handle_Coprocessor_Absent>
	...

8000cc34 <_handle_Data_Address_Read>:

        .org  0x034
        // Data Address (Read).
_handle_Data_Address_Read:
        rjmp $
8000cc34:	c0 08       	rjmp	8000cc34 <_handle_Data_Address_Read>
	...

8000cc38 <_handle_Data_Address_Write>:

        .org  0x038
        // Data Address (Write).
_handle_Data_Address_Write:
        rjmp $
8000cc38:	c0 08       	rjmp	8000cc38 <_handle_Data_Address_Write>
	...

8000cc3c <_handle_DTLB_Protection_Read>:

        .org  0x03C
        // DTLB Protection (Read).
_handle_DTLB_Protection_Read:
        rjmp $
8000cc3c:	c0 08       	rjmp	8000cc3c <_handle_DTLB_Protection_Read>
	...

8000cc40 <_handle_DTLB_Protection_Write>:

        .org  0x040
        // DTLB Protection (Write).
_handle_DTLB_Protection_Write:
        rjmp $
8000cc40:	c0 08       	rjmp	8000cc40 <_handle_DTLB_Protection_Write>
	...

8000cc44 <_handle_DTLB_Modified>:

        .org  0x044
        // DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
        rjmp $
8000cc44:	c0 08       	rjmp	8000cc44 <_handle_DTLB_Modified>
	...

8000cc50 <_handle_ITLB_Miss>:

        .org  0x050
        // ITLB Miss: UNUSED IN AVR32UC.
_handle_ITLB_Miss:
        rjmp $
8000cc50:	c0 08       	rjmp	8000cc50 <_handle_ITLB_Miss>
	...

8000cc60 <_handle_DTLB_Miss_Read>:

        .org  0x060
        // DTLB Miss (Read): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Read:
        rjmp $
8000cc60:	c0 08       	rjmp	8000cc60 <_handle_DTLB_Miss_Read>
	...

8000cc70 <_handle_DTLB_Miss_Write>:

        .org  0x070
        // DTLB Miss (Write): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Write:
        rjmp $
8000cc70:	c0 08       	rjmp	8000cc70 <_handle_DTLB_Miss_Write>
	...

8000cd00 <_handle_Supervisor_Call>:

        .org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	lda.w   pc, SCALLYield
8000cd00:	fe cf 70 08 	sub	pc,pc,28680

8000cd04 <_int0>:
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
	rete
.endr
8000cd04:	30 0c       	mov	r12,0
8000cd06:	fe b0 c4 07 	rcall	80005514 <_get_interrupt_handler>
8000cd0a:	58 0c       	cp.w	r12,0
8000cd0c:	f8 0f 17 10 	movne	pc,r12
8000cd10:	d6 03       	rete

8000cd12 <_int1>:
8000cd12:	30 1c       	mov	r12,1
8000cd14:	fe b0 c4 00 	rcall	80005514 <_get_interrupt_handler>
8000cd18:	58 0c       	cp.w	r12,0
8000cd1a:	f8 0f 17 10 	movne	pc,r12
8000cd1e:	d6 03       	rete

8000cd20 <_int2>:
8000cd20:	30 2c       	mov	r12,2
8000cd22:	fe b0 c3 f9 	rcall	80005514 <_get_interrupt_handler>
8000cd26:	58 0c       	cp.w	r12,0
8000cd28:	f8 0f 17 10 	movne	pc,r12
8000cd2c:	d6 03       	rete

8000cd2e <_int3>:
8000cd2e:	30 3c       	mov	r12,3
8000cd30:	fe b0 c3 f2 	rcall	80005514 <_get_interrupt_handler>
8000cd34:	58 0c       	cp.w	r12,0
8000cd36:	f8 0f 17 10 	movne	pc,r12
8000cd3a:	d6 03       	rete

8000cd3c <ipr_val>:
8000cd3c:	00 00 01 04 40 00 01 12 80 00 01 20 c0 00 01 2e     ....@...... ....
8000cd4c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cd5c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cd6c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cd7c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cd8c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cd9c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cdac:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cdbc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cdcc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cddc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cdec:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cdfc:	d7 03 d7 03                                         ....
