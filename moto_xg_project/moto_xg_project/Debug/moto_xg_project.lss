
moto_xg_project.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00002004  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         0000ad4c  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .exception    00000200  8000ce00  8000ce00  0000d200  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       000012c8  8000d000  8000d000  0000d400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .data         00000a3c  00000004  8000e2c8  0000e804  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .bss          0000b5c0  00000a40  8000ed04  0000f240  2**2
                  ALLOC
  7 .comment      00000030  00000000  00000000  0000f240  2**0
                  CONTENTS, READONLY
  8 .debug_aranges 00001688  00000000  00000000  0000f270  2**3
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_pubnames 00003666  00000000  00000000  000108f8  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_info   0002c6c2  00000000  00000000  00013f5e  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_abbrev 000072bb  00000000  00000000  00040620  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   0000d462  00000000  00000000  000478db  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_frame  00003d2c  00000000  00000000  00054d40  2**2
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    00008010  00000000  00000000  00058a6c  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_loc    0000f3d1  00000000  00000000  00060a7c  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .stack        00001000  00017000  00017000  00000400  2**0
                  ALLOC
 17 .debug_ranges 00001750  00000000  00000000  0006fe50  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_trampoline>:

  .global _trampoline
  .type _trampoline, @function
_trampoline:
  // Jump to program start.
  rjmp    program_start
80000000:	e0 8f 10 00 	bral	80002000 <program_start>
	...

80002000 <program_start>:
	   // rjmp    program_start

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002000:	fe cf c3 14 	sub	pc,pc,-15596

Disassembly of section .text:

80002004 <DeviceManagement_brdcst_func>:
80002004:	f8 c8 ff fe 	sub	r8,r12,-2
void DeviceManagement_brdcst_func(xcmp_fragment_t * xcmp)
{
		U16 temp = 0;
		/*point to xcmp payload*/
		DeviceManagement_brdcast_t *ptr = (DeviceManagement_brdcast_t* )xcmp->u8;
		temp  = ptr->Device_Type << 8;
80002008:	f1 2a 00 01 	ld.sb	r10,r8[1]
		//log("DeviceManagement_brdcst...\n");
		//log("temp: %x\n", temp);
		//log("xnl_information.logical_address: %x\n", xnl_information.logical_address);
		//temp  = xcmp->u8[1] << 8;
		//temp |= xcmp->u8[2];
		if (temp == xnl_information.logical_address)
8000200c:	48 c9       	lddpc	r9,8000203c <DeviceManagement_brdcst_func+0x38>
8000200e:	92 39       	ld.sh	r9,r9[0x6]
{
		U16 temp = 0;
		/*point to xcmp payload*/
		DeviceManagement_brdcast_t *ptr = (DeviceManagement_brdcast_t* )xcmp->u8;
		temp  = ptr->Device_Type << 8;
		temp |= ptr->XCMP_Device_ID;
80002010:	11 a8       	ld.ub	r8,r8[0x2]
80002012:	f1 ea 10 88 	or	r8,r8,r10<<0x8
80002016:	f0 09 19 00 	cp.h	r9,r8
8000201a:	5e 1c       	retne	r12
		//log("xnl_information.logical_address: %x\n", xnl_information.logical_address);
		//temp  = xcmp->u8[1] << 8;
		//temp |= xcmp->u8[2];
		if (temp == xnl_information.logical_address)
		{
			if (xcmp->u8[0] == 0x01)
8000201c:	19 a9       	ld.ub	r9,r12[0x2]
8000201e:	30 18       	mov	r8,1
80002020:	f0 09 18 00 	cp.b	r9,r8
80002024:	c0 61       	brne	80002030 <DeviceManagement_brdcst_func+0x2c>
			//if(ptr->Function == Start)
			{
				//Enable Option Board
				bunchofrandomstatusflags |= 0x00000002;
80002026:	48 78       	lddpc	r8,80002040 <DeviceManagement_brdcst_func+0x3c>
80002028:	70 09       	ld.w	r9,r8[0x0]
8000202a:	a1 b9       	sbr	r9,0x1
8000202c:	91 09       	st.w	r8[0x0],r9
8000202e:	5e fc       	retal	r12
			}
			else
			{
				//Disable Option Board.
				//log("Device State : %d\n", );
				bunchofrandomstatusflags &= 0xFFFFFFFD;
80002030:	48 48       	lddpc	r8,80002040 <DeviceManagement_brdcst_func+0x3c>
80002032:	70 09       	ld.w	r9,r8[0x0]
80002034:	a1 d9       	cbr	r9,0x1
80002036:	91 09       	st.w	r8[0x0],r9
80002038:	5e fc       	retal	r12
8000203a:	00 00       	add	r0,r0
8000203c:	00 00       	add	r0,r0
8000203e:	97 24       	st.w	r11[0x8],r4
80002040:	00 00       	add	r0,r0
80002042:	0d a0       	ld.ub	r0,r6[0x2]

80002044 <Volume_brdcst_func>:
	//log("Attenuator_Number: %x \n",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
	
	//log("Audio_Parameter: %x \n", ptr->Audio_Parameter);
	
	
}
80002044:	5e fc       	retal	r12

80002046 <AudioRoutingControl_brdcst_func>:
	//
	//log("\n\r Audio-Function: %x \n\r", xcmp->u8[3+j*2-1]);
	
	
	
}
80002046:	5e fc       	retal	r12

80002048 <vApplicationIdleHook>:
}

void vApplicationIdleHook( void )
{
	/* This hook function does nothing but increment a counter. */
	ulIdleCycleCount++;
80002048:	48 38       	lddpc	r8,80002054 <vApplicationIdleHook+0xc>
8000204a:	70 09       	ld.w	r9,r8[0x0]
8000204c:	2f f9       	sub	r9,-1
8000204e:	91 09       	st.w	r8[0x0],r9
	
}
80002050:	5e fc       	retal	r12
80002052:	00 00       	add	r0,r0
80002054:	00 00       	add	r0,r0
80002056:	0a 6c       	and	r12,r5

80002058 <app_payload_tx_proc>:

}


static void app_payload_tx_proc(void  * payload)
{
80002058:	d4 01       	pushm	lr
  log("R");
8000205a:	48 3c       	lddpc	r12,80002064 <app_payload_tx_proc+0xc>
8000205c:	f0 1f 00 03 	mcall	80002068 <app_payload_tx_proc+0x10>
  //
  //
  //set_payload_idle(payload);


}
80002060:	d8 02       	popm	pc
80002062:	00 00       	add	r0,r0
80002064:	80 00       	ld.sh	r0,r0[0x0]
80002066:	d0 00       	acall	0x0
80002068:	80 00       	ld.sh	r0,r0[0x0]
8000206a:	70 48       	ld.w	r8,r8[0x10]

8000206c <app_payload_rx_proc>:
	}
}


static void app_payload_rx_proc(void  * payload)
{
8000206c:	d4 01       	pushm	lr
	static  U8 times_counter = 0;
	
	times_counter++;
8000206e:	48 99       	lddpc	r9,80002090 <app_payload_rx_proc+0x24>
80002070:	13 88       	ld.ub	r8,r9[0x0]
80002072:	2f f8       	sub	r8,-1
80002074:	b2 88       	st.b	r9[0x0],r8
	if (times_counter == 3)
80002076:	30 39       	mov	r9,3
80002078:	f2 08 18 00 	cp.b	r8,r9
8000207c:	c0 71       	brne	8000208a <app_payload_rx_proc+0x1e>
	{
		times_counter = 0 ;
8000207e:	30 09       	mov	r9,0
80002080:	48 48       	lddpc	r8,80002090 <app_payload_rx_proc+0x24>
80002082:	b0 89       	st.b	r8[0x0],r9
		log("\n\r w: \n\r");
80002084:	48 4c       	lddpc	r12,80002094 <app_payload_rx_proc+0x28>
80002086:	f0 1f 00 05 	mcall	80002098 <app_payload_rx_proc+0x2c>
	}
	//log("\n\r w: \n\r");
	if (AMBE_tx_flag)//本地发送方的mic录音
8000208a:	48 58       	lddpc	r8,8000209c <app_payload_rx_proc+0x30>
8000208c:	11 88       	ld.ub	r8,r8[0x0]
	}
	
	//payload_fragment_t * ptr = (payload_fragment_t *)payload;
	//set_payload_idle(payload);

}
8000208e:	d8 02       	popm	pc
80002090:	00 00       	add	r0,r0
80002092:	0a 58       	eor	r8,r5
80002094:	80 00       	ld.sh	r0,r0[0x0]
80002096:	d0 04       	*unknown*
80002098:	80 00       	ld.sh	r0,r0[0x0]
8000209a:	70 48       	ld.w	r8,r8[0x10]
8000209c:	00 00       	add	r0,r0
8000209e:	0a 48       	or	r8,r5

800020a0 <FD_brdcst_func>:
	
	
}

void FD_brdcst_func(xcmp_fragment_t * xcmp)
{
800020a0:	d4 01       	pushm	lr
	
	
	log("\n\r Forward Data Broadcast \n\r");
800020a2:	48 3c       	lddpc	r12,800020ac <FD_brdcst_func+0xc>
800020a4:	f0 1f 00 03 	mcall	800020b0 <FD_brdcst_func+0x10>
	
}
800020a8:	d8 02       	popm	pc
800020aa:	00 00       	add	r0,r0
800020ac:	80 00       	ld.sh	r0,r0[0x0]
800020ae:	d0 10       	acall	0x1
800020b0:	80 00       	ld.sh	r0,r0[0x0]
800020b2:	70 48       	ld.w	r8,r8[0x10]

800020b4 <FD_reply_func>:
	
	
}

void FD_reply_func(xcmp_fragment_t * xcmp)
{
800020b4:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Reply \n\r");
800020b6:	48 3c       	lddpc	r12,800020c0 <FD_reply_func+0xc>
800020b8:	f0 1f 00 03 	mcall	800020c4 <FD_reply_func+0x10>
	
	
}
800020bc:	d8 02       	popm	pc
800020be:	00 00       	add	r0,r0
800020c0:	80 00       	ld.sh	r0,r0[0x0]
800020c2:	d0 30       	acall	0x3
800020c4:	80 00       	ld.sh	r0,r0[0x0]
800020c6:	70 48       	ld.w	r8,r8[0x10]

800020c8 <FD_request_func>:
}



void FD_request_func(xcmp_fragment_t * xcmp)
{
800020c8:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Request \n\r");
800020ca:	48 3c       	lddpc	r12,800020d4 <FD_request_func+0xc>
800020cc:	f0 1f 00 03 	mcall	800020d8 <FD_request_func+0x10>
	
	
}
800020d0:	d8 02       	popm	pc
800020d2:	00 00       	add	r0,r0
800020d4:	80 00       	ld.sh	r0,r0[0x0]
800020d6:	d0 4c       	*unknown*
800020d8:	80 00       	ld.sh	r0,r0[0x0]
800020da:	70 48       	ld.w	r8,r8[0x10]

800020dc <EnOB_brdcst_func>:
	
	
}

void EnOB_brdcst_func(xcmp_fragment_t * xcmp)
{
800020dc:	d4 01       	pushm	lr
	
	
	log("\n\r En_OB Broadcast \n\r");
800020de:	48 3c       	lddpc	r12,800020e8 <EnOB_brdcst_func+0xc>
800020e0:	f0 1f 00 03 	mcall	800020ec <EnOB_brdcst_func+0x10>
}
800020e4:	d8 02       	popm	pc
800020e6:	00 00       	add	r0,r0
800020e8:	80 00       	ld.sh	r0,r0[0x0]
800020ea:	d0 68       	*unknown*
800020ec:	80 00       	ld.sh	r0,r0[0x0]
800020ee:	70 48       	ld.w	r8,r8[0x10]

800020f0 <EnOB_reply_func>:
}



void EnOB_reply_func(xcmp_fragment_t * xcmp)
{
800020f0:	eb cd 40 80 	pushm	r7,lr
800020f4:	18 97       	mov	r7,r12
		/*point to xcmp payload*/
	//En_OB_Control_reply_t *ptr = (En_OB_Control_reply_t* )xcmp->u8;
	//log("\n\r Xcmp_opcode: %x \n\r", xcmp->xcmp_opcode);
	
	if (xcmp->u8[0]== xcmp_Res_Success)
800020f6:	19 a9       	ld.ub	r9,r12[0x2]
800020f8:	30 08       	mov	r8,0
800020fa:	f0 09 18 00 	cp.b	r9,r8
800020fe:	c1 91       	brne	80002130 <EnOB_reply_func+0x40>
	{
		if (xcmp->u8[1] == EN_OB_Enter)
80002100:	19 b8       	ld.ub	r8,r12[0x3]
80002102:	30 19       	mov	r9,1
80002104:	f2 08 18 00 	cp.b	r8,r9
80002108:	c0 61       	brne	80002114 <EnOB_reply_func+0x24>
		{
		
			log("\n\r En_OB_Enter OK \n\r");
8000210a:	49 0c       	lddpc	r12,80002148 <EnOB_reply_func+0x58>
8000210c:	f0 1f 00 10 	mcall	8000214c <EnOB_reply_func+0x5c>
80002110:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else if (xcmp->u8[1] == EN_OB_Exit )
80002114:	58 08       	cp.w	r8,0
80002116:	c0 61       	brne	80002122 <EnOB_reply_func+0x32>
		{
			log("\n\r En_OB_Exit OK \n\r");
80002118:	48 ec       	lddpc	r12,80002150 <EnOB_reply_func+0x60>
8000211a:	f0 1f 00 0d 	mcall	8000214c <EnOB_reply_func+0x5c>
8000211e:	e3 cd 80 80 	ldm	sp++,r7,pc
		}
		else
		{
			
			log("\n\r En_OB_Control: %x \n\r", xcmp->u8[1]);
80002122:	1a d8       	st.w	--sp,r8
80002124:	48 cc       	lddpc	r12,80002154 <EnOB_reply_func+0x64>
80002126:	f0 1f 00 0a 	mcall	8000214c <EnOB_reply_func+0x5c>
8000212a:	2f fd       	sub	sp,-4
8000212c:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r En_OB_Control error \n\r");
80002130:	48 ac       	lddpc	r12,80002158 <EnOB_reply_func+0x68>
80002132:	f0 1f 00 07 	mcall	8000214c <EnOB_reply_func+0x5c>
		log("\n\r En_OB_result: %x \n\r", xcmp->u8[0]);
80002136:	0f a8       	ld.ub	r8,r7[0x2]
80002138:	1a d8       	st.w	--sp,r8
8000213a:	48 9c       	lddpc	r12,8000215c <EnOB_reply_func+0x6c>
8000213c:	f0 1f 00 04 	mcall	8000214c <EnOB_reply_func+0x5c>
80002140:	2f fd       	sub	sp,-4
80002142:	e3 cd 80 80 	ldm	sp++,r7,pc
80002146:	00 00       	add	r0,r0
80002148:	80 00       	ld.sh	r0,r0[0x0]
8000214a:	d0 80       	acall	0x8
8000214c:	80 00       	ld.sh	r0,r0[0x0]
8000214e:	70 48       	ld.w	r8,r8[0x10]
80002150:	80 00       	ld.sh	r0,r0[0x0]
80002152:	d0 98       	*unknown*
80002154:	80 00       	ld.sh	r0,r0[0x0]
80002156:	d0 ac       	*unknown*
80002158:	80 00       	ld.sh	r0,r0[0x0]
8000215a:	d0 c4       	*unknown*
8000215c:	80 00       	ld.sh	r0,r0[0x0]
8000215e:	d0 e0       	acall	0xe

80002160 <SingleDetection_brdcst_func>:
	
}


void SingleDetection_brdcst_func(xcmp_fragment_t * xcmp)
{
80002160:	eb cd 40 80 	pushm	r7,lr
80002164:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == 0x11)
80002166:	19 a9       	ld.ub	r9,r12[0x2]
80002168:	31 18       	mov	r8,17
8000216a:	f0 09 18 00 	cp.b	r9,r8
8000216e:	c0 91       	brne	80002180 <SingleDetection_brdcst_func+0x20>
	{
		log("\n\r DMR_CSBK OK \n\r");
80002170:	48 ac       	lddpc	r12,80002198 <SingleDetection_brdcst_func+0x38>
80002172:	f0 1f 00 0b 	mcall	8000219c <SingleDetection_brdcst_func+0x3c>
		get_time_okay = TRUE;
80002176:	30 19       	mov	r9,1
80002178:	48 a8       	lddpc	r8,800021a0 <SingleDetection_brdcst_func+0x40>
8000217a:	b0 89       	st.b	r8[0x0],r9
8000217c:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	//if(xcmp->u8[1] == 0x11)
	else
	{
		log("SIGBRCST error\n");
80002180:	48 9c       	lddpc	r12,800021a4 <SingleDetection_brdcst_func+0x44>
80002182:	f0 1f 00 07 	mcall	8000219c <SingleDetection_brdcst_func+0x3c>
		log("\Signal_type: %X \n\r", xcmp->u8[0] );
80002186:	0f a8       	ld.ub	r8,r7[0x2]
80002188:	1a d8       	st.w	--sp,r8
8000218a:	48 8c       	lddpc	r12,800021a8 <SingleDetection_brdcst_func+0x48>
8000218c:	f0 1f 00 04 	mcall	8000219c <SingleDetection_brdcst_func+0x3c>
80002190:	2f fd       	sub	sp,-4
80002192:	e3 cd 80 80 	ldm	sp++,r7,pc
80002196:	00 00       	add	r0,r0
80002198:	80 00       	ld.sh	r0,r0[0x0]
8000219a:	d0 f8       	*unknown*
8000219c:	80 00       	ld.sh	r0,r0[0x0]
8000219e:	70 48       	ld.w	r8,r8[0x10]
800021a0:	00 00       	add	r0,r0
800021a2:	00 04       	add	r4,r0
800021a4:	80 00       	ld.sh	r0,r0[0x0]
800021a6:	d1 0c       	*unknown*
800021a8:	80 00       	ld.sh	r0,r0[0x0]
800021aa:	d1 1c       	*unknown*

800021ac <ButtonConfig_brdcst_func>:
	
}


void ButtonConfig_brdcst_func(xcmp_fragment_t * xcmp)
{
800021ac:	d4 31       	pushm	r0-r7,lr
	U8 Num_Button =0;
	U8 i = 0 ;
	/*point to xcmp payload*/
	ButtonConfig_brdcst_t  *ptr = (ButtonConfig_brdcst_t* )xcmp->u8;
800021ae:	f8 c7 ff fe 	sub	r7,r12,-2
	
	Num_Button = ptr->NumOfButtons;
800021b2:	0f 95       	ld.ub	r5,r7[0x1]
	
	log("\n\r ButtonConfig_broadcast  \n\r"  );
800021b4:	4a bc       	lddpc	r12,80002260 <ButtonConfig_brdcst_func+0xb4>
800021b6:	f0 1f 00 2c 	mcall	80002264 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r Function: %X \n\r" , ptr->Function );
800021ba:	0f 88       	ld.ub	r8,r7[0x0]
800021bc:	1a d8       	st.w	--sp,r8
800021be:	4a bc       	lddpc	r12,80002268 <ButtonConfig_brdcst_func+0xbc>
800021c0:	f0 1f 00 29 	mcall	80002264 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
800021c4:	1a d5       	st.w	--sp,r5
800021c6:	4a ac       	lddpc	r12,8000226c <ButtonConfig_brdcst_func+0xc0>
800021c8:	f0 1f 00 27 	mcall	80002264 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
800021cc:	0f a8       	ld.ub	r8,r7[0x2]
800021ce:	1a d8       	st.w	--sp,r8
800021d0:	4a 8c       	lddpc	r12,80002270 <ButtonConfig_brdcst_func+0xc4>
800021d2:	f0 1f 00 25 	mcall	80002264 <ButtonConfig_brdcst_func+0xb8>
	
	for (i; i<Num_Button; i++)
800021d6:	2f dd       	sub	sp,-12
800021d8:	58 05       	cp.w	r5,0
800021da:	c4 10       	breq	8000225c <ButtonConfig_brdcst_func+0xb0>
800021dc:	30 06       	mov	r6,0
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
800021de:	4a 64       	lddpc	r4,80002274 <ButtonConfig_brdcst_func+0xc8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
800021e0:	4a 63       	lddpc	r3,80002278 <ButtonConfig_brdcst_func+0xcc>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
800021e2:	4a 72       	lddpc	r2,8000227c <ButtonConfig_brdcst_func+0xd0>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
800021e4:	4a 71       	lddpc	r1,80002280 <ButtonConfig_brdcst_func+0xd4>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
800021e6:	4a 80       	lddpc	r0,80002284 <ButtonConfig_brdcst_func+0xd8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
800021e8:	0f b9       	ld.ub	r9,r7[0x3]
800021ea:	0f c8       	ld.ub	r8,r7[0x4]
800021ec:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800021f0:	1a d8       	st.w	--sp,r8
800021f2:	1a d6       	st.w	--sp,r6
800021f4:	08 9c       	mov	r12,r4
800021f6:	f0 1f 00 1c 	mcall	80002264 <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
800021fa:	0f d9       	ld.ub	r9,r7[0x5]
800021fc:	0f e8       	ld.ub	r8,r7[0x6]
800021fe:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002202:	1a d8       	st.w	--sp,r8
80002204:	1a d6       	st.w	--sp,r6
80002206:	06 9c       	mov	r12,r3
80002208:	f0 1f 00 17 	mcall	80002264 <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
8000220c:	0f f9       	ld.ub	r9,r7[0x7]
8000220e:	ef 38 00 08 	ld.ub	r8,r7[8]
80002212:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002216:	1a d8       	st.w	--sp,r8
80002218:	1a d6       	st.w	--sp,r6
8000221a:	04 9c       	mov	r12,r2
8000221c:	f0 1f 00 12 	mcall	80002264 <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
80002220:	ef 39 00 09 	ld.ub	r9,r7[9]
80002224:	ef 38 00 0a 	ld.ub	r8,r7[10]
80002228:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000222c:	1a d8       	st.w	--sp,r8
8000222e:	1a d6       	st.w	--sp,r6
80002230:	02 9c       	mov	r12,r1
80002232:	f0 1f 00 0d 	mcall	80002264 <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
80002236:	2f 8d       	sub	sp,-32
80002238:	ef 39 00 0b 	ld.ub	r9,r7[11]
8000223c:	ef 38 00 0c 	ld.ub	r8,r7[12]
80002240:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002244:	1a d8       	st.w	--sp,r8
80002246:	1a d6       	st.w	--sp,r6
80002248:	00 9c       	mov	r12,r0
8000224a:	f0 1f 00 07 	mcall	80002264 <ButtonConfig_brdcst_func+0xb8>
8000224e:	2f f6       	sub	r6,-1
80002250:	2f 67       	sub	r7,-10
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
80002252:	2f ed       	sub	sp,-8
80002254:	ec 05 18 00 	cp.b	r5,r6
80002258:	fe 9b ff c8 	brhi	800021e8 <ButtonConfig_brdcst_func+0x3c>
8000225c:	d8 32       	popm	r0-r7,pc
8000225e:	00 00       	add	r0,r0
80002260:	80 00       	ld.sh	r0,r0[0x0]
80002262:	d1 30       	acall	0x13
80002264:	80 00       	ld.sh	r0,r0[0x0]
80002266:	70 48       	ld.w	r8,r8[0x10]
80002268:	80 00       	ld.sh	r0,r0[0x0]
8000226a:	d1 50       	acall	0x15
8000226c:	80 00       	ld.sh	r0,r0[0x0]
8000226e:	d1 64       	*unknown*
80002270:	80 00       	ld.sh	r0,r0[0x0]
80002272:	d1 7c       	*unknown*
80002274:	80 00       	ld.sh	r0,r0[0x0]
80002276:	d1 9c       	*unknown*
80002278:	80 00       	ld.sh	r0,r0[0x0]
8000227a:	d1 c4       	*unknown*
8000227c:	80 00       	ld.sh	r0,r0[0x0]
8000227e:	d1 ec       	*unknown*
80002280:	80 00       	ld.sh	r0,r0[0x0]
80002282:	d2 10       	acall	0x21
80002284:	80 00       	ld.sh	r0,r0[0x0]
80002286:	d2 38       	*unknown*

80002288 <ButtonConfig_reply_func>:
	}
	
}

void ButtonConfig_reply_func(xcmp_fragment_t * xcmp)
{
80002288:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	ButtonConfig_reply_t *ptr = (ButtonConfig_reply_t* )(xcmp->u8);
8000228c:	f8 c7 ff fe 	sub	r7,r12,-2
	if (ptr->Result == xcmp_Res_Success)
80002290:	0f 89       	ld.ub	r9,r7[0x0]
80002292:	30 08       	mov	r8,0
80002294:	f0 09 18 00 	cp.b	r9,r8
80002298:	c0 c1       	brne	800022b0 <ButtonConfig_reply_func+0x28>
	{
		log("\n\r Button_Config OK \n\r");
8000229a:	48 9c       	lddpc	r12,800022bc <ButtonConfig_reply_func+0x34>
8000229c:	f0 1f 00 09 	mcall	800022c0 <ButtonConfig_reply_func+0x38>
		
		log("\n\r Function: %X \n\r" , ptr->Function );
800022a0:	0f 98       	ld.ub	r8,r7[0x1]
800022a2:	1a d8       	st.w	--sp,r8
800022a4:	48 8c       	lddpc	r12,800022c4 <ButtonConfig_reply_func+0x3c>
800022a6:	f0 1f 00 07 	mcall	800022c0 <ButtonConfig_reply_func+0x38>
800022aa:	2f fd       	sub	sp,-4
800022ac:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r Button_Request error \n\r");
800022b0:	48 6c       	lddpc	r12,800022c8 <ButtonConfig_reply_func+0x40>
800022b2:	f0 1f 00 04 	mcall	800022c0 <ButtonConfig_reply_func+0x38>
800022b6:	e3 cd 80 80 	ldm	sp++,r7,pc
800022ba:	00 00       	add	r0,r0
800022bc:	80 00       	ld.sh	r0,r0[0x0]
800022be:	d2 5c       	*unknown*
800022c0:	80 00       	ld.sh	r0,r0[0x0]
800022c2:	70 48       	ld.w	r8,r8[0x10]
800022c4:	80 00       	ld.sh	r0,r0[0x0]
800022c6:	d1 50       	acall	0x15
800022c8:	80 00       	ld.sh	r0,r0[0x0]
800022ca:	d2 74       	*unknown*

800022cc <BatteryLevel_brdcst_func>:
	
}


void BatteryLevel_brdcst_func(xcmp_fragment_t * xcmp)
{
800022cc:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	BatteryLevel_brdcast_t *ptr = (BatteryLevel_brdcast_t* )(xcmp->u8);
800022d0:	f8 c7 ff fe 	sub	r7,r12,-2
	if(ptr->State == Battery_Okay)
800022d4:	0f 89       	ld.ub	r9,r7[0x0]
800022d6:	30 08       	mov	r8,0
800022d8:	f0 09 18 00 	cp.b	r9,r8
800022dc:	c0 40       	breq	800022e4 <BatteryLevel_brdcst_func+0x18>
		;//log("\n Battery Okay\n");
	else
		log("\n Battery Low !!!\n");
800022de:	48 5c       	lddpc	r12,800022f0 <BatteryLevel_brdcst_func+0x24>
800022e0:	f0 1f 00 05 	mcall	800022f4 <BatteryLevel_brdcst_func+0x28>
		
	//log("\n Battery charge: %X \n" , ptr->Charge);
	//log("\n Battery voltage: %X \n" , ptr->Voltage);
	
	Battery_Flag = ptr->State;
800022e4:	0f 89       	ld.ub	r9,r7[0x0]
800022e6:	48 58       	lddpc	r8,800022f8 <BatteryLevel_brdcst_func+0x2c>
800022e8:	b0 89       	st.b	r8[0x0],r9

}
800022ea:	e3 cd 80 80 	ldm	sp++,r7,pc
800022ee:	00 00       	add	r0,r0
800022f0:	80 00       	ld.sh	r0,r0[0x0]
800022f2:	d2 90       	acall	0x29
800022f4:	80 00       	ld.sh	r0,r0[0x0]
800022f6:	70 48       	ld.w	r8,r8[0x10]
800022f8:	00 00       	add	r0,r0
800022fa:	0a 41       	or	r1,r5

800022fc <ShutDown_brdcst_func>:
		log("ID:  %X \n", xcmp->u8[2]);
	}
	
}
void ShutDown_brdcst_func(xcmp_fragment_t * xcmp)
{
800022fc:	d4 01       	pushm	lr
	if (xcmp->u8[0] == Shut_Down_Device)
800022fe:	19 a8       	ld.ub	r8,r12[0x2]
80002300:	30 19       	mov	r9,1
80002302:	f2 08 18 00 	cp.b	r8,r9
80002306:	c0 51       	brne	80002310 <ShutDown_brdcst_func+0x14>
	{
		log("Shut_Down_Device \n");
80002308:	48 6c       	lddpc	r12,80002320 <ShutDown_brdcst_func+0x24>
8000230a:	f0 1f 00 07 	mcall	80002324 <ShutDown_brdcst_func+0x28>
8000230e:	d8 02       	popm	pc
		
	}
	else if(xcmp->u8[0] == Reset_Device)
80002310:	30 29       	mov	r9,2
80002312:	f2 08 18 00 	cp.b	r8,r9
80002316:	c0 41       	brne	8000231e <ShutDown_brdcst_func+0x22>
	{
		log("Reset_Device \n");
80002318:	48 4c       	lddpc	r12,80002328 <ShutDown_brdcst_func+0x2c>
8000231a:	f0 1f 00 03 	mcall	80002324 <ShutDown_brdcst_func+0x28>
8000231e:	d8 02       	popm	pc
80002320:	80 00       	ld.sh	r0,r0[0x0]
80002322:	d2 a4       	*unknown*
80002324:	80 00       	ld.sh	r0,r0[0x0]
80002326:	70 48       	ld.w	r8,r8[0x10]
80002328:	80 00       	ld.sh	r0,r0[0x0]
8000232a:	d2 b8       	*unknown*

8000232c <DataSession_reply_func>:
	
	
}

void DataSession_reply_func(xcmp_fragment_t * xcmp)
{
8000232c:	eb cd 40 80 	pushm	r7,lr
80002330:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
80002332:	19 a9       	ld.ub	r9,r12[0x2]
80002334:	30 08       	mov	r8,0
80002336:	f0 09 18 00 	cp.b	r9,r8
8000233a:	c0 61       	brne	80002346 <DataSession_reply_func+0x1a>
	{
		log("DATArep OK \n");
8000233c:	48 dc       	lddpc	r12,80002370 <DataSession_reply_func+0x44>
8000233e:	f0 1f 00 0e 	mcall	80002374 <DataSession_reply_func+0x48>
80002342:	e3 cd 80 80 	ldm	sp++,r7,pc
		//log("ID: %X \n", xcmp->u8[2]);
		
	}
	else
	{	
		log("DATArep error \n");
80002346:	48 dc       	lddpc	r12,80002378 <DataSession_reply_func+0x4c>
80002348:	f0 1f 00 0b 	mcall	80002374 <DataSession_reply_func+0x48>
		log("Result:  %X \n", xcmp->u8[0]);
8000234c:	0f a8       	ld.ub	r8,r7[0x2]
8000234e:	1a d8       	st.w	--sp,r8
80002350:	48 bc       	lddpc	r12,8000237c <DataSession_reply_func+0x50>
80002352:	f0 1f 00 09 	mcall	80002374 <DataSession_reply_func+0x48>
		log("Func:  %X \n", xcmp->u8[1]);
80002356:	0f b8       	ld.ub	r8,r7[0x3]
80002358:	1a d8       	st.w	--sp,r8
8000235a:	48 ac       	lddpc	r12,80002380 <DataSession_reply_func+0x54>
8000235c:	f0 1f 00 06 	mcall	80002374 <DataSession_reply_func+0x48>
		log("ID:  %X \n", xcmp->u8[2]);
80002360:	0f c8       	ld.ub	r8,r7[0x4]
80002362:	1a d8       	st.w	--sp,r8
80002364:	48 8c       	lddpc	r12,80002384 <DataSession_reply_func+0x58>
80002366:	f0 1f 00 04 	mcall	80002374 <DataSession_reply_func+0x48>
8000236a:	2f dd       	sub	sp,-12
8000236c:	e3 cd 80 80 	ldm	sp++,r7,pc
80002370:	80 00       	ld.sh	r0,r0[0x0]
80002372:	d2 c8       	*unknown*
80002374:	80 00       	ld.sh	r0,r0[0x0]
80002376:	70 48       	ld.w	r8,r8[0x10]
80002378:	80 00       	ld.sh	r0,r0[0x0]
8000237a:	d2 d8       	*unknown*
8000237c:	80 00       	ld.sh	r0,r0[0x0]
8000237e:	d2 e8       	*unknown*
80002380:	80 00       	ld.sh	r0,r0[0x0]
80002382:	d2 f8       	*unknown*
80002384:	80 00       	ld.sh	r0,r0[0x0]
80002386:	d3 04       	*unknown*

80002388 <CallControl_brdcst_func>:
	
}


void CallControl_brdcst_func(xcmp_fragment_t * xcmp)
{
80002388:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	CallControl_brdcst_t *ptr = (CallControl_brdcst_t* )xcmp->u8;
8000238c:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  CallControl brst \n\r ");
	//log("\n\r  Call_type: %x \n\r ", ptr->Calltype );
	log("\n\r  Call_state: %x \n\r ", ptr->Callstate );
80002390:	0f 98       	ld.ub	r8,r7[0x1]
80002392:	1a d8       	st.w	--sp,r8
80002394:	48 bc       	lddpc	r12,800023c0 <CallControl_brdcst_func+0x38>
80002396:	f0 1f 00 0c 	mcall	800023c4 <CallControl_brdcst_func+0x3c>
	if (ptr->Callstate == Call_Ended)//0x03
8000239a:	2f fd       	sub	sp,-4
8000239c:	0f 99       	ld.ub	r9,r7[0x1]
8000239e:	30 38       	mov	r8,3
800023a0:	f0 09 18 00 	cp.b	r9,r8
800023a4:	c0 41       	brne	800023ac <CallControl_brdcst_func+0x24>
	{
		//恢复正常语音路径通道
		//xcmp_audio_route_revert();
		Call_Begin = 0;
800023a6:	30 09       	mov	r9,0
800023a8:	48 88       	lddpc	r8,800023c8 <CallControl_brdcst_func+0x40>
800023aa:	b0 89       	st.b	r8[0x0],r9
		
	}
	
	if (ptr->Callstate == Call_Initiated)//0x04
800023ac:	0f 99       	ld.ub	r9,r7[0x1]
800023ae:	30 48       	mov	r8,4
800023b0:	f0 09 18 00 	cp.b	r9,r8
800023b4:	c0 41       	brne	800023bc <CallControl_brdcst_func+0x34>
	{
		Call_Begin = 1;
800023b6:	30 19       	mov	r9,1
800023b8:	48 48       	lddpc	r8,800023c8 <CallControl_brdcst_func+0x40>
800023ba:	b0 89       	st.b	r8[0x0],r9
800023bc:	e3 cd 80 80 	ldm	sp++,r7,pc
800023c0:	80 00       	ld.sh	r0,r0[0x0]
800023c2:	d3 10       	acall	0x31
800023c4:	80 00       	ld.sh	r0,r0[0x0]
800023c6:	70 48       	ld.w	r8,r8[0x10]
800023c8:	00 00       	add	r0,r0
800023ca:	0a 4a       	or	r10,r5

800023cc <TransmitControl_brdcst_func>:

}


void TransmitControl_brdcst_func(xcmp_fragment_t * xcmp)
{
800023cc:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	TransmitControl_brdcast_t *ptr = (TransmitControl_brdcast_t* )xcmp->u8;
800023d0:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  TransmitControl broadcast \n\r ");
	//log("\n\r  Mode_Of_Operation: %x \n\r ", ptr->Mode_Of_Operation );
	if (ptr->State == 0x00)
800023d4:	0f 99       	ld.ub	r9,r7[0x1]
800023d6:	30 08       	mov	r8,0
800023d8:	f0 09 18 00 	cp.b	r9,r8
800023dc:	c0 71       	brne	800023ea <TransmitControl_brdcst_func+0x1e>
	{
		log("\n\r  Standby-Receive \n\r ");
800023de:	48 ac       	lddpc	r12,80002404 <TransmitControl_brdcst_func+0x38>
800023e0:	f0 1f 00 0a 	mcall	80002408 <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 0;
800023e4:	30 09       	mov	r9,0
800023e6:	48 a8       	lddpc	r8,8000240c <TransmitControl_brdcst_func+0x40>
800023e8:	b0 89       	st.b	r8[0x0],r9
	}
	if (ptr->State == 0x01)
800023ea:	0f 99       	ld.ub	r9,r7[0x1]
800023ec:	30 18       	mov	r8,1
800023ee:	f0 09 18 00 	cp.b	r9,r8
800023f2:	c0 71       	brne	80002400 <TransmitControl_brdcst_func+0x34>
	{
		log("\n\r  Transmit \n\r ");
800023f4:	48 7c       	lddpc	r12,80002410 <TransmitControl_brdcst_func+0x44>
800023f6:	f0 1f 00 05 	mcall	80002408 <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 1;
800023fa:	30 19       	mov	r9,1
800023fc:	48 48       	lddpc	r8,8000240c <TransmitControl_brdcst_func+0x40>
800023fe:	b0 89       	st.b	r8[0x0],r9
80002400:	e3 cd 80 80 	ldm	sp++,r7,pc
80002404:	80 00       	ld.sh	r0,r0[0x0]
80002406:	d3 28       	*unknown*
80002408:	80 00       	ld.sh	r0,r0[0x0]
8000240a:	70 48       	ld.w	r8,r8[0x10]
8000240c:	00 00       	add	r0,r0
8000240e:	0a 49       	or	r9,r5
80002410:	80 00       	ld.sh	r0,r0[0x0]
80002412:	d3 40       	acall	0x34

80002414 <TransmitControl_reply_func>:




void TransmitControl_reply_func(xcmp_fragment_t * xcmp)
{
80002414:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	TransmitControl_reply_t *ptr = (TransmitControl_reply_t* )xcmp->u8;
80002418:	f8 c7 ff fe 	sub	r7,r12,-2
	
	if (ptr->Result == xcmp_Res_Success)
8000241c:	0f 89       	ld.ub	r9,r7[0x0]
8000241e:	30 08       	mov	r8,0
80002420:	f0 09 18 00 	cp.b	r9,r8
80002424:	c1 61       	brne	80002450 <TransmitControl_reply_func+0x3c>
	{
		
		log("\n\r  TransmitControl OK \n\r ");
80002426:	48 ec       	lddpc	r12,8000245c <TransmitControl_reply_func+0x48>
80002428:	f0 1f 00 0e 	mcall	80002460 <TransmitControl_reply_func+0x4c>
		log("\n\r Function: %x \n\r", ptr->Function);
8000242c:	0f 98       	ld.ub	r8,r7[0x1]
8000242e:	1a d8       	st.w	--sp,r8
80002430:	48 dc       	lddpc	r12,80002464 <TransmitControl_reply_func+0x50>
80002432:	f0 1f 00 0c 	mcall	80002460 <TransmitControl_reply_func+0x4c>
		log("\n\r Mode of Operation: %x \n\r", ptr->Mode_Of_Operation);
80002436:	0f a8       	ld.ub	r8,r7[0x2]
80002438:	1a d8       	st.w	--sp,r8
8000243a:	48 cc       	lddpc	r12,80002468 <TransmitControl_reply_func+0x54>
8000243c:	f0 1f 00 09 	mcall	80002460 <TransmitControl_reply_func+0x4c>
		log("\n\r State: %x \n\r", ptr->State);
80002440:	0f b8       	ld.ub	r8,r7[0x3]
80002442:	1a d8       	st.w	--sp,r8
80002444:	48 ac       	lddpc	r12,8000246c <TransmitControl_reply_func+0x58>
80002446:	f0 1f 00 07 	mcall	80002460 <TransmitControl_reply_func+0x4c>
8000244a:	2f dd       	sub	sp,-12
8000244c:	e3 cd 80 80 	ldm	sp++,r7,pc
		
		//Silent_flag = 1;
	}
	else
	{
		log("TransmitControl error");
80002450:	48 8c       	lddpc	r12,80002470 <TransmitControl_reply_func+0x5c>
80002452:	f0 1f 00 04 	mcall	80002460 <TransmitControl_reply_func+0x4c>
80002456:	e3 cd 80 80 	ldm	sp++,r7,pc
8000245a:	00 00       	add	r0,r0
8000245c:	80 00       	ld.sh	r0,r0[0x0]
8000245e:	d3 54       	*unknown*
80002460:	80 00       	ld.sh	r0,r0[0x0]
80002462:	70 48       	ld.w	r8,r8[0x10]
80002464:	80 00       	ld.sh	r0,r0[0x0]
80002466:	d3 70       	acall	0x37
80002468:	80 00       	ld.sh	r0,r0[0x0]
8000246a:	d3 84       	*unknown*
8000246c:	80 00       	ld.sh	r0,r0[0x0]
8000246e:	d3 a0       	acall	0x3a
80002470:	80 00       	ld.sh	r0,r0[0x0]
80002472:	d3 b0       	acall	0x3b

80002474 <AudioRoutingControl_reply_func>:
	
}


void AudioRoutingControl_reply_func(xcmp_fragment_t * xcmp)
{
80002474:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
80002476:	19 a9       	ld.ub	r9,r12[0x2]
80002478:	30 08       	mov	r8,0
8000247a:	f0 09 18 00 	cp.b	r9,r8
8000247e:	c0 51       	brne	80002488 <AudioRoutingControl_reply_func+0x14>
	{
		log("AudioRouting OK");
80002480:	48 4c       	lddpc	r12,80002490 <AudioRoutingControl_reply_func+0x1c>
80002482:	f0 1f 00 05 	mcall	80002494 <AudioRoutingControl_reply_func+0x20>
80002486:	d8 02       	popm	pc
		//xcmp_IdleTestTone();
		//Speaker_is_unmute = 1;
	}
	else
	{
		log("AudioRouting error");
80002488:	48 4c       	lddpc	r12,80002498 <AudioRoutingControl_reply_func+0x24>
8000248a:	f0 1f 00 03 	mcall	80002494 <AudioRoutingControl_reply_func+0x20>
8000248e:	d8 02       	popm	pc
80002490:	80 00       	ld.sh	r0,r0[0x0]
80002492:	d3 c8       	*unknown*
80002494:	80 00       	ld.sh	r0,r0[0x0]
80002496:	70 48       	ld.w	r8,r8[0x10]
80002498:	80 00       	ld.sh	r0,r0[0x0]
8000249a:	d3 d8       	*unknown*

8000249c <Volume_reply_func>:
	
}


void Volume_reply_func(xcmp_fragment_t * xcmp)
{
8000249c:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	VolumeControl_reply_t *ptr = (VolumeControl_reply_t* )xcmp->u8;
800024a0:	f8 c7 ff fe 	sub	r7,r12,-2
	
		if (ptr->Result == xcmp_Res_Success)
800024a4:	0f 89       	ld.ub	r9,r7[0x0]
800024a6:	30 08       	mov	r8,0
800024a8:	f0 09 18 00 	cp.b	r9,r8
800024ac:	c1 b1       	brne	800024e2 <Volume_reply_func+0x46>
		{
			if (ptr->Function == Enable_IntelligentAudio)
800024ae:	0f b8       	ld.ub	r8,r7[0x3]
800024b0:	31 09       	mov	r9,16
800024b2:	f2 08 18 00 	cp.b	r8,r9
800024b6:	c0 f1       	brne	800024d4 <Volume_reply_func+0x38>
			{
				log("\n\r Enable_IA OK \n\r");
800024b8:	48 dc       	lddpc	r12,800024ec <Volume_reply_func+0x50>
800024ba:	f0 1f 00 0e 	mcall	800024f0 <Volume_reply_func+0x54>
				log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
800024be:	0f 99       	ld.ub	r9,r7[0x1]
800024c0:	0f a8       	ld.ub	r8,r7[0x2]
800024c2:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800024c6:	1a d8       	st.w	--sp,r8
800024c8:	48 bc       	lddpc	r12,800024f4 <Volume_reply_func+0x58>
800024ca:	f0 1f 00 0a 	mcall	800024f0 <Volume_reply_func+0x54>
800024ce:	2f fd       	sub	sp,-4
800024d0:	e3 cd 80 80 	ldm	sp++,r7,pc
	
			}
			else
			{
				
				log("\n\r VolumeControl: %x \n\r", ptr->Function);
800024d4:	1a d8       	st.w	--sp,r8
800024d6:	48 9c       	lddpc	r12,800024f8 <Volume_reply_func+0x5c>
800024d8:	f0 1f 00 06 	mcall	800024f0 <Volume_reply_func+0x54>
800024dc:	2f fd       	sub	sp,-4
800024de:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		
		else
		{
			log("\n\r Enable_IA error \n\r");
800024e2:	48 7c       	lddpc	r12,800024fc <Volume_reply_func+0x60>
800024e4:	f0 1f 00 03 	mcall	800024f0 <Volume_reply_func+0x54>
800024e8:	e3 cd 80 80 	ldm	sp++,r7,pc
800024ec:	80 00       	ld.sh	r0,r0[0x0]
800024ee:	d3 ec       	*unknown*
800024f0:	80 00       	ld.sh	r0,r0[0x0]
800024f2:	70 48       	ld.w	r8,r8[0x10]
800024f4:	80 00       	ld.sh	r0,r0[0x0]
800024f6:	d4 00       	acall	0x40
800024f8:	80 00       	ld.sh	r0,r0[0x0]
800024fa:	d4 1c       	*unknown*
800024fc:	80 00       	ld.sh	r0,r0[0x0]
800024fe:	d4 34       	*unknown*

80002500 <spk_brdcst_func>:
		log("spk error");
	}
}

void spk_brdcst_func(xcmp_fragment_t * xcmp)
{
80002500:	d4 01       	pushm	lr
	if (xcmp->u8[3] == xcmp_Res_Success)//0x0000:mute
80002502:	19 d9       	ld.ub	r9,r12[0x5]
80002504:	30 08       	mov	r8,0
80002506:	f0 09 18 00 	cp.b	r9,r8
8000250a:	c0 81       	brne	8000251a <spk_brdcst_func+0x1a>
	{
		Speaker_is_unmute =0;
8000250c:	10 99       	mov	r9,r8
8000250e:	48 78       	lddpc	r8,80002528 <spk_brdcst_func+0x28>
80002510:	b0 89       	st.b	r8[0x0],r9
		//Silent_flag = 0;
		log("spk_s_close ");
80002512:	48 7c       	lddpc	r12,8000252c <spk_brdcst_func+0x2c>
80002514:	f0 1f 00 07 	mcall	80002530 <spk_brdcst_func+0x30>
80002518:	d8 02       	popm	pc
		
	}
	else
	{
		//Silent_flag = 1;
		Speaker_is_unmute = 1;
8000251a:	30 19       	mov	r9,1
8000251c:	48 38       	lddpc	r8,80002528 <spk_brdcst_func+0x28>
8000251e:	b0 89       	st.b	r8[0x0],r9
		log("spk_s_open ");	
80002520:	48 5c       	lddpc	r12,80002534 <spk_brdcst_func+0x34>
80002522:	f0 1f 00 04 	mcall	80002530 <spk_brdcst_func+0x30>
80002526:	d8 02       	popm	pc
80002528:	00 00       	add	r0,r0
8000252a:	0a 40       	or	r0,r5
8000252c:	80 00       	ld.sh	r0,r0[0x0]
8000252e:	d4 4c       	*unknown*
80002530:	80 00       	ld.sh	r0,r0[0x0]
80002532:	70 48       	ld.w	r8,r8[0x10]
80002534:	80 00       	ld.sh	r0,r0[0x0]
80002536:	d4 5c       	*unknown*

80002538 <spk_reply_func>:
			
	
}

void spk_reply_func(xcmp_fragment_t * xcmp)
{
80002538:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
8000253a:	19 a9       	ld.ub	r9,r12[0x2]
8000253c:	30 08       	mov	r8,0
8000253e:	f0 09 18 00 	cp.b	r9,r8
80002542:	c0 f1       	brne	80002560 <spk_reply_func+0x28>
	{
		
		if(xcmp->u8[4])
80002544:	19 e9       	ld.ub	r9,r12[0x6]
80002546:	f0 09 18 00 	cp.b	r9,r8
8000254a:	c0 40       	breq	80002552 <spk_reply_func+0x1a>
		{
			Speaker_is_unmute = 1;
8000254c:	30 19       	mov	r9,1
8000254e:	48 98       	lddpc	r8,80002570 <spk_reply_func+0x38>
80002550:	b0 89       	st.b	r8[0x0],r9
			
			//Silent_flag = 1;
		}
		log("spk OK -st%2x", xcmp->u8[4] );
80002552:	19 e8       	ld.ub	r8,r12[0x6]
80002554:	1a d8       	st.w	--sp,r8
80002556:	48 8c       	lddpc	r12,80002574 <spk_reply_func+0x3c>
80002558:	f0 1f 00 08 	mcall	80002578 <spk_reply_func+0x40>
8000255c:	2f fd       	sub	sp,-4
8000255e:	d8 02       	popm	pc
		
	}
	else
	{
		Speaker_is_unmute = 0;
80002560:	30 09       	mov	r9,0
80002562:	48 48       	lddpc	r8,80002570 <spk_reply_func+0x38>
80002564:	b0 89       	st.b	r8[0x0],r9
		log("spk error");
80002566:	48 6c       	lddpc	r12,8000257c <spk_reply_func+0x44>
80002568:	f0 1f 00 04 	mcall	80002578 <spk_reply_func+0x40>
8000256c:	d8 02       	popm	pc
8000256e:	00 00       	add	r0,r0
80002570:	00 00       	add	r0,r0
80002572:	0a 40       	or	r0,r5
80002574:	80 00       	ld.sh	r0,r0[0x0]
80002576:	d4 68       	*unknown*
80002578:	80 00       	ld.sh	r0,r0[0x0]
8000257a:	70 48       	ld.w	r8,r8[0x10]
8000257c:	80 00       	ld.sh	r0,r0[0x0]
8000257e:	d4 78       	*unknown*

80002580 <mic_brdcst_func>:
	
	
}

void mic_brdcst_func(xcmp_fragment_t * xcmp)
{
80002580:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_brdcast_t *ptr = (MicControl_brdcast_t* )xcmp->u8;
80002584:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r Mic_brdcst \n\r");		
	//log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
	//log("\n\r Signal_type: %x \n\r " ,  ptr->Signaling_Type);
	if (ptr->Mic_State == 0x00)
80002588:	0f a9       	ld.ub	r9,r7[0x2]
8000258a:	30 08       	mov	r8,0
8000258c:	f0 09 18 00 	cp.b	r9,r8
80002590:	c0 71       	brne	8000259e <mic_brdcst_func+0x1e>
	{
		log("\n\r Mic_Disabled \n\r");	
80002592:	48 dc       	lddpc	r12,800025c4 <mic_brdcst_func+0x44>
80002594:	f0 1f 00 0d 	mcall	800025c8 <mic_brdcst_func+0x48>
		Mic_is_Enabled = 0;
80002598:	30 09       	mov	r9,0
8000259a:	48 d8       	lddpc	r8,800025cc <mic_brdcst_func+0x4c>
8000259c:	b0 89       	st.b	r8[0x0],r9
	} 
	if(ptr->Mic_State == 0x11)
8000259e:	0f a9       	ld.ub	r9,r7[0x2]
800025a0:	31 18       	mov	r8,17
800025a2:	f0 09 18 00 	cp.b	r9,r8
800025a6:	c0 d1       	brne	800025c0 <mic_brdcst_func+0x40>
	{
		log("\n\r Mic_Enabled \n\r");
800025a8:	48 ac       	lddpc	r12,800025d0 <mic_brdcst_func+0x50>
800025aa:	f0 1f 00 08 	mcall	800025c8 <mic_brdcst_func+0x48>
		Mic_is_Enabled = 1;
800025ae:	48 89       	lddpc	r9,800025cc <mic_brdcst_func+0x4c>
800025b0:	30 18       	mov	r8,1
800025b2:	b2 88       	st.b	r9[0x0],r8
		
		if ((Mic_is_Enabled == 1) && (Call_Begin == 1))
800025b4:	13 89       	ld.ub	r9,r9[0x0]
800025b6:	f0 09 18 00 	cp.b	r9,r8
800025ba:	c0 31       	brne	800025c0 <mic_brdcst_func+0x40>
800025bc:	48 68       	lddpc	r8,800025d4 <mic_brdcst_func+0x54>
800025be:	11 88       	ld.ub	r8,r8[0x0]
800025c0:	e3 cd 80 80 	ldm	sp++,r7,pc
800025c4:	80 00       	ld.sh	r0,r0[0x0]
800025c6:	d4 84       	*unknown*
800025c8:	80 00       	ld.sh	r0,r0[0x0]
800025ca:	70 48       	ld.w	r8,r8[0x10]
800025cc:	00 00       	add	r0,r0
800025ce:	0a 61       	and	r1,r5
800025d0:	80 00       	ld.sh	r0,r0[0x0]
800025d2:	d4 98       	*unknown*
800025d4:	00 00       	add	r0,r0
800025d6:	0a 4a       	or	r10,r5

800025d8 <mic_reply_func>:
	
	
}

void mic_reply_func(xcmp_fragment_t * xcmp)
{
800025d8:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_reply_t *ptr = (MicControl_reply_t* )xcmp->u8;
800025dc:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Mic_reply \n\r");
800025e0:	49 ac       	lddpc	r12,80002648 <mic_reply_func+0x70>
800025e2:	f0 1f 00 1b 	mcall	8000264c <mic_reply_func+0x74>
	if (ptr->Result == 0x00)
800025e6:	0f 89       	ld.ub	r9,r7[0x0]
800025e8:	30 08       	mov	r8,0
800025ea:	f0 09 18 00 	cp.b	r9,r8
800025ee:	c2 71       	brne	8000263c <mic_reply_func+0x64>
	{
		
		if (ptr->Function == Mic_Disable)
800025f0:	0f 98       	ld.ub	r8,r7[0x1]
800025f2:	30 29       	mov	r9,2
800025f4:	f2 08 18 00 	cp.b	r8,r9
800025f8:	c1 b1       	brne	8000262e <mic_reply_func+0x56>
		{
		
			log("\n\r Mic_close_ok \n\r " );
800025fa:	49 6c       	lddpc	r12,80002650 <mic_reply_func+0x78>
800025fc:	f0 1f 00 14 	mcall	8000264c <mic_reply_func+0x74>
			log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
80002600:	0f a8       	ld.ub	r8,r7[0x2]
80002602:	1a d8       	st.w	--sp,r8
80002604:	49 4c       	lddpc	r12,80002654 <mic_reply_func+0x7c>
80002606:	f0 1f 00 12 	mcall	8000264c <mic_reply_func+0x74>
			log("\n\r Signaling_type: %x \n\r " ,  ptr->Signaling_Type);
8000260a:	0f b8       	ld.ub	r8,r7[0x3]
8000260c:	1a d8       	st.w	--sp,r8
8000260e:	49 3c       	lddpc	r12,80002658 <mic_reply_func+0x80>
80002610:	f0 1f 00 0f 	mcall	8000264c <mic_reply_func+0x74>
			log("\n\r Mic_state: %x \n\r " ,  ptr->Mic_State);
80002614:	0f c8       	ld.ub	r8,r7[0x4]
80002616:	1a d8       	st.w	--sp,r8
80002618:	49 1c       	lddpc	r12,8000265c <mic_reply_func+0x84>
8000261a:	f0 1f 00 0d 	mcall	8000264c <mic_reply_func+0x74>
			log("\n\r Gain_offset: %x \n\r " ,  ptr->Gain_Offset);
8000261e:	0f d8       	ld.ub	r8,r7[0x5]
80002620:	1a d8       	st.w	--sp,r8
80002622:	49 0c       	lddpc	r12,80002660 <mic_reply_func+0x88>
80002624:	f0 1f 00 0a 	mcall	8000264c <mic_reply_func+0x74>
80002628:	2f cd       	sub	sp,-16
8000262a:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else
		{
			log("\n\r Mic_function: %x \n\r ", ptr->Function );
8000262e:	1a d8       	st.w	--sp,r8
80002630:	48 dc       	lddpc	r12,80002664 <mic_reply_func+0x8c>
80002632:	f0 1f 00 07 	mcall	8000264c <mic_reply_func+0x74>
80002636:	2f fd       	sub	sp,-4
80002638:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else 
	{
		
	
		log("\n\r Mic error \n\r");
8000263c:	48 bc       	lddpc	r12,80002668 <mic_reply_func+0x90>
8000263e:	f0 1f 00 04 	mcall	8000264c <mic_reply_func+0x74>
80002642:	e3 cd 80 80 	ldm	sp++,r7,pc
80002646:	00 00       	add	r0,r0
80002648:	80 00       	ld.sh	r0,r0[0x0]
8000264a:	d4 ac       	*unknown*
8000264c:	80 00       	ld.sh	r0,r0[0x0]
8000264e:	70 48       	ld.w	r8,r8[0x10]
80002650:	80 00       	ld.sh	r0,r0[0x0]
80002652:	d4 bc       	*unknown*
80002654:	80 00       	ld.sh	r0,r0[0x0]
80002656:	d4 d0       	acall	0x4d
80002658:	80 00       	ld.sh	r0,r0[0x0]
8000265a:	d4 e4       	*unknown*
8000265c:	80 00       	ld.sh	r0,r0[0x0]
8000265e:	d5 00       	acall	0x50
80002660:	80 00       	ld.sh	r0,r0[0x0]
80002662:	d5 18       	*unknown*
80002664:	80 00       	ld.sh	r0,r0[0x0]
80002666:	d5 30       	acall	0x53
80002668:	80 00       	ld.sh	r0,r0[0x0]
8000266a:	d5 48       	*unknown*

8000266c <dcm_brdcst_func>:
	}
}


void dcm_brdcst_func(xcmp_fragment_t * xcmp)
{
8000266c:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	DeviceControlMode_brdcst_t *ptr = (DeviceControlMode_brdcst_t* )xcmp->u8;
80002670:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Dcm_brdcst \n\r");		
80002674:	48 bc       	lddpc	r12,800026a0 <dcm_brdcst_func+0x34>
80002676:	f0 1f 00 0c 	mcall	800026a4 <dcm_brdcst_func+0x38>
	log("\n\r Function: %x \n\r " ,  ptr->Function);
8000267a:	0f 88       	ld.ub	r8,r7[0x0]
8000267c:	1a d8       	st.w	--sp,r8
8000267e:	48 bc       	lddpc	r12,800026a8 <dcm_brdcst_func+0x3c>
80002680:	f0 1f 00 09 	mcall	800026a4 <dcm_brdcst_func+0x38>
	log("\n\r ControlType: %x \n\r " ,  ptr->ControlType);
80002684:	0f a8       	ld.ub	r8,r7[0x2]
80002686:	1a d8       	st.w	--sp,r8
80002688:	48 9c       	lddpc	r12,800026ac <dcm_brdcst_func+0x40>
8000268a:	f0 1f 00 07 	mcall	800026a4 <dcm_brdcst_func+0x38>
	log("\n\r ControlTypeSize: %x \n\r " ,  ptr->ControlTypeSize);
8000268e:	0f 98       	ld.ub	r8,r7[0x1]
80002690:	1a d8       	st.w	--sp,r8
80002692:	48 8c       	lddpc	r12,800026b0 <dcm_brdcst_func+0x44>
80002694:	f0 1f 00 04 	mcall	800026a4 <dcm_brdcst_func+0x38>
80002698:	2f dd       	sub	sp,-12
	
	
}
8000269a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000269e:	00 00       	add	r0,r0
800026a0:	80 00       	ld.sh	r0,r0[0x0]
800026a2:	d5 58       	*unknown*
800026a4:	80 00       	ld.sh	r0,r0[0x0]
800026a6:	70 48       	ld.w	r8,r8[0x10]
800026a8:	80 00       	ld.sh	r0,r0[0x0]
800026aa:	d5 6c       	*unknown*
800026ac:	80 00       	ld.sh	r0,r0[0x0]
800026ae:	d5 80       	acall	0x58
800026b0:	80 00       	ld.sh	r0,r0[0x0]
800026b2:	d5 98       	*unknown*

800026b4 <dcm_reply_func>:
		log("Tone error");
	}
}

void dcm_reply_func(xcmp_fragment_t * xcmp)
{
800026b4:	eb cd 40 80 	pushm	r7,lr
800026b8:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
800026ba:	19 a9       	ld.ub	r9,r12[0x2]
800026bc:	30 08       	mov	r8,0
800026be:	f0 09 18 00 	cp.b	r9,r8
800026c2:	c1 b1       	brne	800026f8 <dcm_reply_func+0x44>
	{
		if(xcmp->u8[1] == DCM_ENTER)
800026c4:	19 b8       	ld.ub	r8,r12[0x3]
800026c6:	30 19       	mov	r9,1
800026c8:	f2 08 18 00 	cp.b	r8,r9
800026cc:	c0 51       	brne	800026d6 <dcm_reply_func+0x22>
		{
			log("\n\r Dcm-Enter OK \n\r");
800026ce:	48 ec       	lddpc	r12,80002704 <dcm_reply_func+0x50>
800026d0:	f0 1f 00 0e 	mcall	80002708 <dcm_reply_func+0x54>
800026d4:	c0 a8       	rjmp	800026e8 <dcm_reply_func+0x34>
			
		}
		else if (xcmp->u8[1] == DCM_EXIT)
800026d6:	58 08       	cp.w	r8,0
800026d8:	c0 51       	brne	800026e2 <dcm_reply_func+0x2e>
		{
			log("\n\r Dcm-Exit OK \n\r");
800026da:	48 dc       	lddpc	r12,8000270c <dcm_reply_func+0x58>
800026dc:	f0 1f 00 0b 	mcall	80002708 <dcm_reply_func+0x54>
800026e0:	c0 48       	rjmp	800026e8 <dcm_reply_func+0x34>
		}
		else
		{
			log("\n\r Dcm-Revoke \n\r");
800026e2:	48 cc       	lddpc	r12,80002710 <dcm_reply_func+0x5c>
800026e4:	f0 1f 00 09 	mcall	80002708 <dcm_reply_func+0x54>
		}
		
		log("dcm OK-mo%X", xcmp->u8[3]);
800026e8:	0f d8       	ld.ub	r8,r7[0x5]
800026ea:	1a d8       	st.w	--sp,r8
800026ec:	48 ac       	lddpc	r12,80002714 <dcm_reply_func+0x60>
800026ee:	f0 1f 00 07 	mcall	80002708 <dcm_reply_func+0x54>
800026f2:	2f fd       	sub	sp,-4
800026f4:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		log("dcm error");
800026f8:	48 8c       	lddpc	r12,80002718 <dcm_reply_func+0x64>
800026fa:	f0 1f 00 04 	mcall	80002708 <dcm_reply_func+0x54>
800026fe:	e3 cd 80 80 	ldm	sp++,r7,pc
80002702:	00 00       	add	r0,r0
80002704:	80 00       	ld.sh	r0,r0[0x0]
80002706:	d5 b4       	*unknown*
80002708:	80 00       	ld.sh	r0,r0[0x0]
8000270a:	70 48       	ld.w	r8,r8[0x10]
8000270c:	80 00       	ld.sh	r0,r0[0x0]
8000270e:	d5 c8       	*unknown*
80002710:	80 00       	ld.sh	r0,r0[0x0]
80002712:	d5 dc       	*unknown*
80002714:	80 00       	ld.sh	r0,r0[0x0]
80002716:	d5 f0       	acall	0x5f
80002718:	80 00       	ld.sh	r0,r0[0x0]
8000271a:	d5 fc       	*unknown*

8000271c <ToneControl_reply_func>:
			//log("Device State : %d\n", ptr->Device_State);
		}
}

void ToneControl_reply_func(xcmp_fragment_t * xcmp)
{
8000271c:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
8000271e:	19 a9       	ld.ub	r9,r12[0x2]
80002720:	30 08       	mov	r8,0
80002722:	f0 09 18 00 	cp.b	r9,r8
80002726:	c0 51       	brne	80002730 <ToneControl_reply_func+0x14>
	{		
		log("Tone OK\n");
80002728:	48 4c       	lddpc	r12,80002738 <ToneControl_reply_func+0x1c>
8000272a:	f0 1f 00 05 	mcall	8000273c <ToneControl_reply_func+0x20>
8000272e:	d8 02       	popm	pc
		//fl_write("/test.txt", FILE_END, (void *)"send tone ok\r\n", sizeof("send tone ok\r\n") - 1);
	}
	else
	{
		log("Tone error");
80002730:	48 4c       	lddpc	r12,80002740 <ToneControl_reply_func+0x24>
80002732:	f0 1f 00 03 	mcall	8000273c <ToneControl_reply_func+0x20>
80002736:	d8 02       	popm	pc
80002738:	80 00       	ld.sh	r0,r0[0x0]
8000273a:	d6 08       	*unknown*
8000273c:	80 00       	ld.sh	r0,r0[0x0]
8000273e:	70 48       	ld.w	r8,r8[0x10]
80002740:	80 00       	ld.sh	r0,r0[0x0]
80002742:	d6 14       	*unknown*

80002744 <app_init>:
	//0x00,0x39


};
void app_init(void)
{	
80002744:	d4 01       	pushm	lr
	xcmp_register_app_list(the_app_list);
80002746:	49 1c       	lddpc	r12,80002788 <app_init+0x44>
80002748:	f0 1f 00 11 	mcall	8000278c <app_init+0x48>
	
	//将app_payload_rx_proc更改为PCM加密功能
	payload_init( app_payload_rx_proc , app_payload_tx_proc );
8000274c:	49 1b       	lddpc	r11,80002790 <app_init+0x4c>
8000274e:	49 2c       	lddpc	r12,80002794 <app_init+0x50>
80002750:	f0 1f 00 12 	mcall	80002798 <app_init+0x54>
	
	/* Create the mutex semaphore to guard a shared global_count.*/
	count_mutex = xSemaphoreCreateMutex();
80002754:	f0 1f 00 12 	mcall	8000279c <app_init+0x58>
80002758:	49 28       	lddpc	r8,800027a0 <app_init+0x5c>
8000275a:	91 0c       	st.w	r8[0x0],r12
	if (count_mutex == NULL)
8000275c:	70 08       	ld.w	r8,r8[0x0]
8000275e:	58 08       	cp.w	r8,0
80002760:	c0 41       	brne	80002768 <app_init+0x24>
	{
		log("Create the count_mutex semaphore failure\n");
80002762:	49 1c       	lddpc	r12,800027a4 <app_init+0x60>
80002764:	f0 1f 00 11 	mcall	800027a8 <app_init+0x64>
	}
	
	
	static portBASE_TYPE res = 0;
	 res = xTaskCreate(
80002768:	30 09       	mov	r9,0
8000276a:	1a d9       	st.w	--sp,r9
8000276c:	1a d9       	st.w	--sp,r9
8000276e:	1a d9       	st.w	--sp,r9
80002770:	30 18       	mov	r8,1
80002772:	e0 6a 03 20 	mov	r10,800
80002776:	48 eb       	lddpc	r11,800027ac <app_init+0x68>
80002778:	48 ec       	lddpc	r12,800027b0 <app_init+0x6c>
8000277a:	f0 1f 00 0f 	mcall	800027b4 <app_init+0x70>
8000277e:	48 f8       	lddpc	r8,800027b8 <app_init+0x74>
80002780:	91 0c       	st.w	r8[0x0],r12
80002782:	2f dd       	sub	sp,-12
	,  800//1024//800//384
	,  NULL
	,  1
	,  NULL );
		
}
80002784:	d8 02       	popm	pc
80002786:	00 00       	add	r0,r0
80002788:	00 00       	add	r0,r0
8000278a:	00 08       	add	r8,r0
8000278c:	80 00       	ld.sh	r0,r0[0x0]
8000278e:	3f 84       	mov	r4,-8
80002790:	80 00       	ld.sh	r0,r0[0x0]
80002792:	20 58       	sub	r8,5
80002794:	80 00       	ld.sh	r0,r0[0x0]
80002796:	20 6c       	sub	r12,6
80002798:	80 00       	ld.sh	r0,r0[0x0]
8000279a:	2c 34       	sub	r4,-61
8000279c:	80 00       	ld.sh	r0,r0[0x0]
8000279e:	65 10       	ld.w	r0,r2[0x44]
800027a0:	00 00       	add	r0,r0
800027a2:	0a 64       	and	r4,r5
800027a4:	80 00       	ld.sh	r0,r0[0x0]
800027a6:	d6 20       	acall	0x62
800027a8:	80 00       	ld.sh	r0,r0[0x0]
800027aa:	70 48       	ld.w	r8,r8[0x10]
800027ac:	80 00       	ld.sh	r0,r0[0x0]
800027ae:	d6 4c       	*unknown*
800027b0:	80 00       	ld.sh	r0,r0[0x0]
800027b2:	27 bc       	sub	r12,123
800027b4:	80 00       	ld.sh	r0,r0[0x0]
800027b6:	6c 84       	ld.w	r4,r6[0x20]
800027b8:	00 00       	add	r0,r0
800027ba:	0a 54       	eor	r4,r5

800027bc <app_cfg>:
extern void xnl_send_device_master_query(void);
//extern portTickType water_value;
//extern portTickType tx_water_value;
//extern portTickType log_water_value;
static __app_Thread_(app_cfg)
{
800027bc:	d4 31       	pushm	r0-r7,lr
800027be:	21 5d       	sub	sp,84
	static  portTickType xLastWakeTime;
	const portTickType xFrequency = 4000;//2s,定时问题已经修正。2s x  2000hz = 4000
	U8 Burst_ID = 0;
	char card_id[4]={0};
	U16  * data_ptr;
	Message_Protocol_t *m_buff = (Message_Protocol_t *) pvPortMalloc(sizeof(Message_Protocol_t));
800027c0:	31 ac       	mov	r12,26
800027c2:	f0 1f 00 6b 	mcall	8000296c <app_cfg+0x1b0>
	static	OB_States OB_State = OB_UNCONNECTEDWAITINGSTATUS;
	static xgflash_status_t status = XG_ERROR;
	xLastWakeTime = xTaskGetTickCount();
800027c6:	f0 1f 00 6b 	mcall	80002970 <app_cfg+0x1b4>
800027ca:	4e b8       	lddpc	r8,80002974 <app_cfg+0x1b8>
800027cc:	91 0c       	st.w	r8[0x0],r12
	
	static const uint8_t test_data[8] = {0x11, 0x23, 0x33, 0x67, 0x89, 0xAB, 0xCD, 0xEF};
	char str[80];
	memset(str, 0x00, 80);
800027ce:	35 0a       	mov	r10,80
800027d0:	30 0b       	mov	r11,0
800027d2:	1a 9c       	mov	r12,sp
800027d4:	f0 1f 00 69 	mcall	80002978 <app_cfg+0x1bc>
	
	/* 'Give' the semaphore to unblock the task. */
	 //if( xBinarySemaphore != NULL ){
		//xSemaphoreGive(xBinarySemaphore);
	 //}
	 xSemaphoreTake(xBinarySemaphore, portMAX_DELAY); 
800027d8:	4e 98       	lddpc	r8,8000297c <app_cfg+0x1c0>
800027da:	70 0c       	ld.w	r12,r8[0x0]
800027dc:	30 09       	mov	r9,0
800027de:	3f fa       	mov	r10,-1
800027e0:	12 9b       	mov	r11,r9
800027e2:	f0 1f 00 68 	mcall	80002980 <app_cfg+0x1c4>
		
	for(;;)
	{
		switch(OB_State)
800027e6:	4e 85       	lddpc	r5,80002984 <app_cfg+0x1c8>
		{
			case OB_UNCONNECTEDWAITINGSTATUS:
			
				if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
800027e8:	4e 84       	lddpc	r4,80002988 <app_cfg+0x1cc>
					nop();
					nop();
					nop();
					/*send device_master_query to connect radio*/
					xnl_send_device_master_query();
					log("connecting...\n");
800027ea:	4e 92       	lddpc	r2,8000298c <app_cfg+0x1d0>
					vTaskDelayUntil( &xLastWakeTime, (1000*2) / portTICK_RATE_MS  );//精确的以1000ms为周期执行。
800027ec:	4e 26       	lddpc	r6,80002974 <app_cfg+0x1b8>
800027ee:	e0 67 07 d0 	mov	r7,2000
	{
		switch(OB_State)
		{
			case OB_UNCONNECTEDWAITINGSTATUS:
			
				if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
800027f2:	4e 83       	lddpc	r3,80002990 <app_cfg+0x1d4>
	 //}
	 xSemaphoreTake(xBinarySemaphore, portMAX_DELAY); 
		
	for(;;)
	{
		switch(OB_State)
800027f4:	6a 08       	ld.w	r8,r5[0x0]
800027f6:	58 08       	cp.w	r8,0
800027f8:	c0 50       	breq	80002802 <app_cfg+0x46>
800027fa:	58 38       	cp.w	r8,3
800027fc:	e0 81 00 b3 	brne	80002962 <app_cfg+0x1a6>
80002800:	c3 38       	rjmp	80002866 <app_cfg+0xaa>
		{
			case OB_UNCONNECTEDWAITINGSTATUS:
			
				if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
80002802:	68 08       	ld.w	r8,r4[0x0]
80002804:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
80002808:	58 38       	cp.w	r8,3
8000280a:	c2 11       	brne	8000284c <app_cfg+0x90>
8000280c:	07 88       	ld.ub	r8,r3[0x0]
8000280e:	58 08       	cp.w	r8,0
80002810:	c1 e1       	brne	8000284c <app_cfg+0x90>
				{
					connect_flag=1;
80002812:	30 18       	mov	r8,1
80002814:	a6 88       	st.b	r3[0x0],r8
					xcmp_IdleTestTone(Tone_Start, Priority_Beep);//set tone to indicate connection success!!!
80002816:	30 cb       	mov	r11,12
80002818:	30 1c       	mov	r12,1
8000281a:	f0 1f 00 5f 	mcall	80002994 <app_cfg+0x1d8>
					xcmp_IdleTestTone(Tone_Start, Priority_Beep);//set tone to indicate connection success!!!
8000281e:	30 cb       	mov	r11,12
80002820:	30 1c       	mov	r12,1
80002822:	f0 1f 00 5d 	mcall	80002994 <app_cfg+0x1d8>
					OB_State = OB_WAITINGAPPTASK;
80002826:	30 38       	mov	r8,3
80002828:	8b 08       	st.w	r5[0x0],r8
					log("connect OB okay!\n");
8000282a:	4d cc       	lddpc	r12,80002998 <app_cfg+0x1dc>
8000282c:	f0 1f 00 5c 	mcall	8000299c <app_cfg+0x1e0>
					log("XCMP_Version: %d.%d.%d.%d\n", XCMP_Version[0],  XCMP_Version[1],
													 XCMP_Version[2],  XCMP_Version[3]);
80002830:	4d c8       	lddpc	r8,800029a0 <app_cfg+0x1e4>
80002832:	11 bb       	ld.ub	r11,r8[0x3]
80002834:	11 aa       	ld.ub	r10,r8[0x2]
					connect_flag=1;
					xcmp_IdleTestTone(Tone_Start, Priority_Beep);//set tone to indicate connection success!!!
					xcmp_IdleTestTone(Tone_Start, Priority_Beep);//set tone to indicate connection success!!!
					OB_State = OB_WAITINGAPPTASK;
					log("connect OB okay!\n");
					log("XCMP_Version: %d.%d.%d.%d\n", XCMP_Version[0],  XCMP_Version[1],
80002836:	11 99       	ld.ub	r9,r8[0x1]
80002838:	11 88       	ld.ub	r8,r8[0x0]
8000283a:	1a db       	st.w	--sp,r11
8000283c:	1a da       	st.w	--sp,r10
8000283e:	1a d9       	st.w	--sp,r9
80002840:	1a d8       	st.w	--sp,r8
80002842:	4d 9c       	lddpc	r12,800029a4 <app_cfg+0x1e8>
80002844:	f0 1f 00 56 	mcall	8000299c <app_cfg+0x1e0>
	{
		switch(OB_State)
		{
			case OB_UNCONNECTEDWAITINGSTATUS:
			
				if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
80002848:	2f cd       	sub	sp,-16
8000284a:	c8 c8       	rjmp	80002962 <app_cfg+0x1a6>
					log("XCMP_Version: %d.%d.%d.%d\n", XCMP_Version[0],  XCMP_Version[1],
													 XCMP_Version[2],  XCMP_Version[3]);
				}
				else
				{
					nop();
8000284c:	d7 03       	nop
					nop();
8000284e:	d7 03       	nop
					nop();
80002850:	d7 03       	nop
					/*send device_master_query to connect radio*/
					xnl_send_device_master_query();
80002852:	f0 1f 00 56 	mcall	800029a8 <app_cfg+0x1ec>
					log("connecting...\n");
80002856:	04 9c       	mov	r12,r2
80002858:	f0 1f 00 51 	mcall	8000299c <app_cfg+0x1e0>
					vTaskDelayUntil( &xLastWakeTime, (1000*2) / portTICK_RATE_MS  );//精确的以1000ms为周期执行。
8000285c:	0e 9b       	mov	r11,r7
8000285e:	0c 9c       	mov	r12,r6
80002860:	f0 1f 00 53 	mcall	800029ac <app_cfg+0x1f0>
80002864:	c7 f8       	rjmp	80002962 <app_cfg+0x1a6>
						
					
					//if (xSemaphoreTake(xBinarySemaphore, (1000*2) / portTICK_RATE_MS) == pdPASS)
					{
						
						if(pdPASS == xQueueReceive(xg_resend_queue, &data_ptr, (1000*2) / portTICK_RATE_MS))
80002866:	4d 38       	lddpc	r8,800029b0 <app_cfg+0x1f4>
80002868:	70 0c       	ld.w	r12,r8[0x0]
8000286a:	30 09       	mov	r9,0
8000286c:	0e 9a       	mov	r10,r7
8000286e:	fa cb ff b0 	sub	r11,sp,-80
80002872:	f0 1f 00 44 	mcall	80002980 <app_cfg+0x1c4>
80002876:	58 1c       	cp.w	r12,1
80002878:	c6 61       	brne	80002944 <app_cfg+0x188>
						{
							if(data_ptr!=NULL){//resend message
8000287a:	41 48       	lddsp	r8,sp[0x50]
8000287c:	58 08       	cp.w	r8,0
8000287e:	c6 30       	breq	80002944 <app_cfg+0x188>
							
								log("receive Okay!\n");	
80002880:	4c dc       	lddpc	r12,800029b4 <app_cfg+0x1f8>
80002882:	f0 1f 00 47 	mcall	8000299c <app_cfg+0x1e0>
								xSemaphoreTake(count_mutex, portMAX_DELAY);
80002886:	4c d0       	lddpc	r0,800029b8 <app_cfg+0x1fc>
80002888:	60 0c       	ld.w	r12,r0[0x0]
8000288a:	30 09       	mov	r9,0
8000288c:	3f fa       	mov	r10,-1
8000288e:	12 9b       	mov	r11,r9
80002890:	f0 1f 00 3c 	mcall	80002980 <app_cfg+0x1c4>
								global_count--;
80002894:	4c a1       	lddpc	r1,800029bc <app_cfg+0x200>
80002896:	62 08       	ld.w	r8,r1[0x0]
80002898:	20 18       	sub	r8,1
8000289a:	83 08       	st.w	r1[0x0],r8
								xSemaphoreGive(count_mutex);
8000289c:	60 0c       	ld.w	r12,r0[0x0]
8000289e:	30 09       	mov	r9,0
800028a0:	12 9a       	mov	r10,r9
800028a2:	12 9b       	mov	r11,r9
800028a4:	f0 1f 00 47 	mcall	800029c0 <app_cfg+0x204>
								log("global_count:%d\n", global_count);	
800028a8:	62 08       	ld.w	r8,r1[0x0]
800028aa:	1a d8       	st.w	--sp,r8
800028ac:	4c 6c       	lddpc	r12,800029c4 <app_cfg+0x208>
800028ae:	f0 1f 00 3c 	mcall	8000299c <app_cfg+0x1e0>
																			
								xcmp_data_session_req(data_ptr, sizeof(Message_Protocol_t), DEST);	
800028b2:	36 4a       	mov	r10,100
800028b4:	31 ab       	mov	r11,26
800028b6:	41 5c       	lddsp	r12,sp[0x54]
800028b8:	f0 1f 00 44 	mcall	800029c8 <app_cfg+0x20c>
								if(xSemaphoreTake(xBinarySemaphore, (20000*2) / portTICK_RATE_MS) ==pdFALSE)
800028bc:	4b 08       	lddpc	r8,8000297c <app_cfg+0x1c0>
800028be:	70 0c       	ld.w	r12,r8[0x0]
800028c0:	30 09       	mov	r9,0
800028c2:	e0 6a 9c 40 	mov	r10,40000
800028c6:	12 9b       	mov	r11,r9
800028c8:	f0 1f 00 2e 	mcall	80002980 <app_cfg+0x1c4>
800028cc:	2f fd       	sub	sp,-4
800028ce:	58 0c       	cp.w	r12,0
800028d0:	c3 21       	brne	80002934 <app_cfg+0x178>
								{
									
									if (xQueueSend(xg_resend_queue, &data_ptr, 0) != pdPASS)
800028d2:	4b 88       	lddpc	r8,800029b0 <app_cfg+0x1f4>
800028d4:	70 0c       	ld.w	r12,r8[0x0]
800028d6:	30 09       	mov	r9,0
800028d8:	12 9a       	mov	r10,r9
800028da:	fa cb ff b0 	sub	r11,sp,-80
800028de:	f0 1f 00 39 	mcall	800029c0 <app_cfg+0x204>
800028e2:	58 1c       	cp.w	r12,1
800028e4:	c1 10       	breq	80002906 <app_cfg+0x14a>
									{
										log("xg_resend_queue: full\n" );
800028e6:	4b ac       	lddpc	r12,800029cc <app_cfg+0x210>
800028e8:	f0 1f 00 2d 	mcall	8000299c <app_cfg+0x1e0>
										xcmp_IdleTestTone(Tone_Start, Dispatch_Busy);//set tone to indicate queue full!!!
800028ec:	32 3b       	mov	r11,35
800028ee:	30 1c       	mov	r12,1
800028f0:	f0 1f 00 29 	mcall	80002994 <app_cfg+0x1d8>
										vTaskDelay(3000*2 / portTICK_RATE_MS);//延迟3000ms
800028f4:	e0 6c 17 70 	mov	r12,6000
800028f8:	f0 1f 00 36 	mcall	800029d0 <app_cfg+0x214>
										xcmp_IdleTestTone(Tone_Stop, Dispatch_Busy);//set tone to indicate queue full!!!
800028fc:	32 3b       	mov	r11,35
800028fe:	30 0c       	mov	r12,0
80002900:	f0 1f 00 25 	mcall	80002994 <app_cfg+0x1d8>
80002904:	c2 08       	rjmp	80002944 <app_cfg+0x188>
									}
									else{
											
										xSemaphoreTake(count_mutex, portMAX_DELAY);
80002906:	4a d1       	lddpc	r1,800029b8 <app_cfg+0x1fc>
80002908:	62 0c       	ld.w	r12,r1[0x0]
8000290a:	30 09       	mov	r9,0
8000290c:	3f fa       	mov	r10,-1
8000290e:	12 9b       	mov	r11,r9
80002910:	f0 1f 00 1c 	mcall	80002980 <app_cfg+0x1c4>
										global_count++;
80002914:	4a a8       	lddpc	r8,800029bc <app_cfg+0x200>
80002916:	70 09       	ld.w	r9,r8[0x0]
80002918:	2f f9       	sub	r9,-1
8000291a:	91 09       	st.w	r8[0x0],r9
										xSemaphoreGive(count_mutex);
8000291c:	62 0c       	ld.w	r12,r1[0x0]
8000291e:	30 09       	mov	r9,0
80002920:	12 9a       	mov	r10,r9
80002922:	12 9b       	mov	r11,r9
80002924:	f0 1f 00 27 	mcall	800029c0 <app_cfg+0x204>
										xcmp_IdleTestTone(Tone_Start, MANDOWN_DISABLE_TONE);//set tone to indicate send-failure!!!
80002928:	e0 6b 00 b7 	mov	r11,183
8000292c:	30 1c       	mov	r12,1
8000292e:	f0 1f 00 1a 	mcall	80002994 <app_cfg+0x1d8>
80002932:	c0 98       	rjmp	80002944 <app_cfg+0x188>
									}
				
								}	
								else
								{
									set_message_store(data_ptr);
80002934:	4a 88       	lddpc	r8,800029d4 <app_cfg+0x218>
80002936:	70 0c       	ld.w	r12,r8[0x0]
80002938:	41 4b       	lddsp	r11,sp[0x50]
8000293a:	f0 1f 00 28 	mcall	800029d8 <app_cfg+0x21c>
									log("send message\n");
8000293e:	4a 8c       	lddpc	r12,800029dc <app_cfg+0x220>
80002940:	f0 1f 00 17 	mcall	8000299c <app_cfg+0x1e0>
							}
						
						}
					}
					
					if (0x00000003 != (bunchofrandomstatusflags & 0x00000003))//掉线
80002944:	68 08       	ld.w	r8,r4[0x0]
80002946:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
8000294a:	58 38       	cp.w	r8,3
8000294c:	c0 70       	breq	8000295a <app_cfg+0x19e>
					{					
						OB_State = OB_UNCONNECTEDWAITINGSTATUS;
8000294e:	30 08       	mov	r8,0
80002950:	8b 08       	st.w	r5[0x0],r8
						connect_flag=0;
80002952:	a6 88       	st.b	r3[0x0],r8
						log("OB disconnecting!!!\n");
80002954:	4a 3c       	lddpc	r12,800029e0 <app_cfg+0x224>
80002956:	f0 1f 00 12 	mcall	8000299c <app_cfg+0x1e0>
							//memset(str, 0x00, 80);
						//}
					//}
					
											
					nop();
8000295a:	d7 03       	nop
					log("app task run!\n");
8000295c:	4a 2c       	lddpc	r12,800029e4 <app_cfg+0x228>
8000295e:	f0 1f 00 10 	mcall	8000299c <app_cfg+0x1e0>
			break;
			default:
			break;
				
		} //End of switch on OB_State.
		vTaskDelayUntil( &xLastWakeTime, (1000*2) / portTICK_RATE_MS  );//精确的以1000ms为周期执行。
80002962:	0e 9b       	mov	r11,r7
80002964:	0c 9c       	mov	r12,r6
80002966:	f0 1f 00 12 	mcall	800029ac <app_cfg+0x1f0>
	}
8000296a:	c4 5b       	rjmp	800027f4 <app_cfg+0x38>
8000296c:	80 00       	ld.sh	r0,r0[0x0]
8000296e:	60 bc       	ld.w	r12,r0[0x2c]
80002970:	80 00       	ld.sh	r0,r0[0x0]
80002972:	69 74       	ld.w	r4,r4[0x5c]
80002974:	00 00       	add	r0,r0
80002976:	0a 5c       	eor	r12,r5
80002978:	80 00       	ld.sh	r0,r0[0x0]
8000297a:	7a 0c       	ld.w	r12,sp[0x0]
8000297c:	00 00       	add	r0,r0
8000297e:	0b 78       	ld.ub	r8,--r5
80002980:	80 00       	ld.sh	r0,r0[0x0]
80002982:	62 04       	ld.w	r4,r1[0x0]
80002984:	00 00       	add	r0,r0
80002986:	0a 4c       	or	r12,r5
80002988:	00 00       	add	r0,r0
8000298a:	0d a0       	ld.ub	r0,r6[0x2]
8000298c:	80 00       	ld.sh	r0,r0[0x0]
8000298e:	d6 84       	*unknown*
80002990:	00 00       	add	r0,r0
80002992:	0a 60       	and	r0,r5
80002994:	80 00       	ld.sh	r0,r0[0x0]
80002996:	41 1c       	lddsp	r12,sp[0x44]
80002998:	80 00       	ld.sh	r0,r0[0x0]
8000299a:	d6 54       	*unknown*
8000299c:	80 00       	ld.sh	r0,r0[0x0]
8000299e:	70 48       	ld.w	r8,r8[0x10]
800029a0:	00 00       	add	r0,r0
800029a2:	0d 9c       	ld.ub	r12,r6[0x1]
800029a4:	80 00       	ld.sh	r0,r0[0x0]
800029a6:	d6 68       	*unknown*
800029a8:	80 00       	ld.sh	r0,r0[0x0]
800029aa:	48 c8       	lddpc	r8,800029d8 <app_cfg+0x21c>
800029ac:	80 00       	ld.sh	r0,r0[0x0]
800029ae:	6b 24       	ld.w	r4,r5[0x48]
800029b0:	00 00       	add	r0,r0
800029b2:	0b 70       	ld.ub	r0,--r5
800029b4:	80 00       	ld.sh	r0,r0[0x0]
800029b6:	d6 94       	*unknown*
800029b8:	00 00       	add	r0,r0
800029ba:	0a 64       	and	r4,r5
800029bc:	00 00       	add	r0,r0
800029be:	0a 44       	or	r4,r5
800029c0:	80 00       	ld.sh	r0,r0[0x0]
800029c2:	64 10       	ld.w	r0,r2[0x4]
800029c4:	80 00       	ld.sh	r0,r0[0x0]
800029c6:	d6 a4       	*unknown*
800029c8:	80 00       	ld.sh	r0,r0[0x0]
800029ca:	3f d8       	mov	r8,-3
800029cc:	80 00       	ld.sh	r0,r0[0x0]
800029ce:	d6 b8       	*unknown*
800029d0:	80 00       	ld.sh	r0,r0[0x0]
800029d2:	6a dc       	ld.w	r12,r5[0x34]
800029d4:	00 00       	add	r0,r0
800029d6:	0b 74       	ld.ub	r4,--r5
800029d8:	80 00       	ld.sh	r0,r0[0x0]
800029da:	2c b4       	sub	r4,-53
800029dc:	80 00       	ld.sh	r0,r0[0x0]
800029de:	d6 d0       	acall	0x6d
800029e0:	80 00       	ld.sh	r0,r0[0x0]
800029e2:	d6 e0       	acall	0x6e
800029e4:	80 00       	ld.sh	r0,r0[0x0]
800029e6:	d6 f8       	*unknown*

800029e8 <Phyuserinput_brdcst_func>:
	
}


void Phyuserinput_brdcst_func(xcmp_fragment_t * xcmp)
{
800029e8:	eb cd 40 80 	pushm	r7,lr
	U8 PUI_State_Min_Value =0;
	U8 PUI_State_Max_Value =0;
	
	PUI_Source = xcmp->u8[0];
	PUI_Type = xcmp ->u8[1];
	PUI_ID = ((xcmp->u8[2]<<8) | xcmp->u8[3]);
800029ec:	19 c7       	ld.ub	r7,r12[0x4]
800029ee:	19 d8       	ld.ub	r8,r12[0x5]
800029f0:	f1 e7 10 87 	or	r7,r8,r7<<0x8
800029f4:	5c 87       	casts.h	r7
	PUI_State = xcmp->u8[4];
	PUI_State_Min_Value = xcmp->u8[5];
	PUI_State_Max_Value = xcmp->u8[6];
	
	log("PhysicalUserInput_broadcast  \n\r"  );
800029f6:	48 dc       	lddpc	r12,80002a28 <Phyuserinput_brdcst_func+0x40>
800029f8:	f0 1f 00 0d 	mcall	80002a2c <Phyuserinput_brdcst_func+0x44>
	
	if((PUI_ID == 0x0060) && (PUI_State = 0x02) && (connect_flag == 1)){
800029fc:	36 08       	mov	r8,96
800029fe:	f0 07 19 00 	cp.h	r7,r8
80002a02:	c1 11       	brne	80002a24 <Phyuserinput_brdcst_func+0x3c>
80002a04:	48 b8       	lddpc	r8,80002a30 <Phyuserinput_brdcst_func+0x48>
80002a06:	11 89       	ld.ub	r9,r8[0x0]
80002a08:	30 18       	mov	r8,1
80002a0a:	f0 09 18 00 	cp.b	r9,r8
80002a0e:	c0 b1       	brne	80002a24 <Phyuserinput_brdcst_func+0x3c>
		//log("send message\n");
		xcmp_IdleTestTone(Tone_Start, Ring_Style_Tone_9);//set tone to indicate the scan!!!
80002a10:	34 5b       	mov	r11,69
80002a12:	30 1c       	mov	r12,1
80002a14:	f0 1f 00 08 	mcall	80002a34 <Phyuserinput_brdcst_func+0x4c>
			
		vTaskDelay(1000*2 / portTICK_RATE_MS);//延迟1000ms
80002a18:	e0 6c 07 d0 	mov	r12,2000
80002a1c:	f0 1f 00 07 	mcall	80002a38 <Phyuserinput_brdcst_func+0x50>
		//delay_ms(200);
		//rfid_sendID_message();//send message	
		scan_rfid_save_message();//scan and save message	
80002a20:	f0 1f 00 07 	mcall	80002a3c <Phyuserinput_brdcst_func+0x54>
80002a24:	e3 cd 80 80 	ldm	sp++,r7,pc
80002a28:	80 00       	ld.sh	r0,r0[0x0]
80002a2a:	d7 08       	*unknown*
80002a2c:	80 00       	ld.sh	r0,r0[0x0]
80002a2e:	70 48       	ld.w	r8,r8[0x10]
80002a30:	00 00       	add	r0,r0
80002a32:	0a 60       	and	r0,r5
80002a34:	80 00       	ld.sh	r0,r0[0x0]
80002a36:	41 1c       	lddsp	r12,sp[0x44]
80002a38:	80 00       	ld.sh	r0,r0[0x0]
80002a3a:	6a dc       	ld.w	r12,r5[0x34]
80002a3c:	80 00       	ld.sh	r0,r0[0x0]
80002a3e:	51 80       	stdsp	sp[0x60],r0

80002a40 <DataSession_brdcst_func>:
	Battery_Flag = ptr->State;

}

void DataSession_brdcst_func(xcmp_fragment_t * xcmp)
{
80002a40:	d4 21       	pushm	r4-r7,lr
80002a42:	20 8d       	sub	sp,32
	U32 card_id =0;
	U8 i = 0;
	xgflash_status_t return_value = XG_ERROR;
	
	/*point to xcmp payload*/
	DataSession_brdcst_t *ptr = (DataSession_brdcst_t* )xcmp->u8;
80002a44:	f8 c6 ff fe 	sub	r6,r12,-2
	
	if (ptr->State == CSBK_DATA_RX_Suc)
80002a48:	0d 88       	ld.ub	r8,r6[0x0]
80002a4a:	32 49       	mov	r9,36
80002a4c:	f2 08 18 00 	cp.b	r8,r9
80002a50:	c2 a1       	brne	80002aa4 <DataSession_brdcst_func+0x64>
	{
		
		log("\n\r CSBK_RX OK \n\r");
80002a52:	4c ac       	lddpc	r12,80002b78 <DataSession_brdcst_func+0x138>
80002a54:	f0 1f 00 4a 	mcall	80002b7c <DataSession_brdcst_func+0x13c>
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
80002a58:	0d a5       	ld.ub	r5,r6[0x2]
80002a5a:	0d b8       	ld.ub	r8,r6[0x3]
80002a5c:	f1 e5 10 85 	or	r5,r8,r5<<0x8
80002a60:	5c 85       	casts.h	r5

		log("\n\r Session_ID: %x \n\r",Session_number );
80002a62:	0d 98       	ld.ub	r8,r6[0x1]
80002a64:	1a d8       	st.w	--sp,r8
80002a66:	4c 7c       	lddpc	r12,80002b80 <DataSession_brdcst_func+0x140>
80002a68:	f0 1f 00 45 	mcall	80002b7c <DataSession_brdcst_func+0x13c>
		log("\n\r paylaod_length: %d \n\r",data_length );
80002a6c:	f1 d5 c0 10 	bfextu	r8,r5,0x0,0x10
80002a70:	1a d8       	st.w	--sp,r8
80002a72:	4c 5c       	lddpc	r12,80002b84 <DataSession_brdcst_func+0x144>
80002a74:	f0 1f 00 42 	mcall	80002b7c <DataSession_brdcst_func+0x13c>
		for(i=0; i<data_length; i++)
80002a78:	2f ed       	sub	sp,-8
80002a7a:	58 05       	cp.w	r5,0
80002a7c:	e0 80 00 7b 	breq	80002b72 <DataSession_brdcst_func+0x132>
80002a80:	30 07       	mov	r7,0
		{
			
			//log("\n\r payload[%d]: %X \n\r", i, xcmp->u8[4+i]);
			log("\n\r payload[%d]: %X \n\r", i, ptr->DataPayload.DataPayload[i]);
80002a82:	4c 24       	lddpc	r4,80002b88 <DataSession_brdcst_func+0x148>
80002a84:	ec 07 00 08 	add	r8,r6,r7
80002a88:	11 c8       	ld.ub	r8,r8[0x4]
80002a8a:	1a d8       	st.w	--sp,r8
80002a8c:	1a d7       	st.w	--sp,r7
80002a8e:	08 9c       	mov	r12,r4
80002a90:	f0 1f 00 3b 	mcall	80002b7c <DataSession_brdcst_func+0x13c>
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);

		log("\n\r Session_ID: %x \n\r",Session_number );
		log("\n\r paylaod_length: %d \n\r",data_length );
		for(i=0; i<data_length; i++)
80002a94:	2f f7       	sub	r7,-1
80002a96:	5c 57       	castu.b	r7
80002a98:	2f ed       	sub	sp,-8
80002a9a:	ee 05 19 00 	cp.h	r5,r7
80002a9e:	fe 9b ff f3 	brhi	80002a84 <DataSession_brdcst_func+0x44>
80002aa2:	c6 88       	rjmp	80002b72 <DataSession_brdcst_func+0x132>
	else
	{
		//log("\n\r State: 0x %X \n\r", xcmp->u8[0]);
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];				
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
		log("State: %X \n", ptr->State);
80002aa4:	1a d8       	st.w	--sp,r8
80002aa6:	4b ac       	lddpc	r12,80002b8c <DataSession_brdcst_func+0x14c>
80002aa8:	f0 1f 00 35 	mcall	80002b7c <DataSession_brdcst_func+0x13c>
		if (ptr->State == DATA_SESSION_TX_Suc)
80002aac:	0d 88       	ld.ub	r8,r6[0x0]
80002aae:	2f fd       	sub	sp,-4
80002ab0:	30 39       	mov	r9,3
80002ab2:	f2 08 18 00 	cp.b	r8,r9
80002ab6:	c0 d1       	brne	80002ad0 <DataSession_brdcst_func+0x90>
		{
			log("data transmit success\n");
80002ab8:	4b 6c       	lddpc	r12,80002b90 <DataSession_brdcst_func+0x150>
80002aba:	f0 1f 00 31 	mcall	80002b7c <DataSession_brdcst_func+0x13c>
			vTaskDelay(1000*2 / portTICK_RATE_MS);//延迟1000ms
80002abe:	e0 6c 07 d0 	mov	r12,2000
80002ac2:	f0 1f 00 35 	mcall	80002b94 <DataSession_brdcst_func+0x154>
			xcmp_IdleTestTone(Tone_Start, BT_Connection_Success_Tone);//set tone to indicate connection success!!!
80002ac6:	37 7b       	mov	r11,119
80002ac8:	30 1c       	mov	r12,1
80002aca:	f0 1f 00 34 	mcall	80002b98 <DataSession_brdcst_func+0x158>
80002ace:	c4 b8       	rjmp	80002b64 <DataSession_brdcst_func+0x124>
		}
		else if(ptr->State == DATA_SESSION_TX_Fail)
80002ad0:	30 49       	mov	r9,4
80002ad2:	f2 08 18 00 	cp.b	r8,r9
80002ad6:	c4 71       	brne	80002b64 <DataSession_brdcst_func+0x124>
		{
			Message_Protocol_t  xgmessage;
			memcpy(&xgmessage, ptr->DataPayload.DataPayload, sizeof(Message_Protocol_t));
80002ad8:	31 aa       	mov	r10,26
80002ada:	ec cb ff fc 	sub	r11,r6,-4
80002ade:	fa cc ff fe 	sub	r12,sp,-2
80002ae2:	f0 1f 00 2f 	mcall	80002b9c <DataSession_brdcst_func+0x15c>

			Message_Protocol_t * myptr = get_message_store();	
80002ae6:	4a f8       	lddpc	r8,80002ba0 <DataSession_brdcst_func+0x160>
80002ae8:	70 0c       	ld.w	r12,r8[0x0]
80002aea:	f0 1f 00 2f 	mcall	80002ba4 <DataSession_brdcst_func+0x164>
80002aee:	50 7c       	stdsp	sp[0x1c],r12
			if(NULL != myptr)
80002af0:	c3 20       	breq	80002b54 <DataSession_brdcst_func+0x114>
			{
				memcpy(myptr, &xgmessage, sizeof(Message_Protocol_t));			
80002af2:	31 aa       	mov	r10,26
80002af4:	fa cb ff fe 	sub	r11,sp,-2
80002af8:	f0 1f 00 29 	mcall	80002b9c <DataSession_brdcst_func+0x15c>
				//xQueueSend(xg_resend_queue, &myptr, 0);			
				if (xQueueSend(xg_resend_queue, &myptr, 0) != pdPASS)
80002afc:	4a b8       	lddpc	r8,80002ba8 <DataSession_brdcst_func+0x168>
80002afe:	70 0c       	ld.w	r12,r8[0x0]
80002b00:	30 09       	mov	r9,0
80002b02:	12 9a       	mov	r10,r9
80002b04:	fa cb ff e4 	sub	r11,sp,-28
80002b08:	f0 1f 00 29 	mcall	80002bac <DataSession_brdcst_func+0x16c>
80002b0c:	58 1c       	cp.w	r12,1
80002b0e:	c1 10       	breq	80002b30 <DataSession_brdcst_func+0xf0>
				{
					log("xg_resend_queue: full\n" );
80002b10:	4a 8c       	lddpc	r12,80002bb0 <DataSession_brdcst_func+0x170>
80002b12:	f0 1f 00 1b 	mcall	80002b7c <DataSession_brdcst_func+0x13c>
					xcmp_IdleTestTone(Tone_Start, Dispatch_Busy);//set tone to indicate queue full!!!
80002b16:	32 3b       	mov	r11,35
80002b18:	30 1c       	mov	r12,1
80002b1a:	f0 1f 00 20 	mcall	80002b98 <DataSession_brdcst_func+0x158>
					vTaskDelay(3000*2 / portTICK_RATE_MS);//延迟3000ms
80002b1e:	e0 6c 17 70 	mov	r12,6000
80002b22:	f0 1f 00 1d 	mcall	80002b94 <DataSession_brdcst_func+0x154>
					xcmp_IdleTestTone(Tone_Stop, Dispatch_Busy);//set tone to indicate queue full!!!
80002b26:	32 3b       	mov	r11,35
80002b28:	30 0c       	mov	r12,0
80002b2a:	f0 1f 00 1c 	mcall	80002b98 <DataSession_brdcst_func+0x158>
80002b2e:	c1 68       	rjmp	80002b5a <DataSession_brdcst_func+0x11a>
				}
				else{
					
					xSemaphoreTake(count_mutex, portMAX_DELAY);
80002b30:	4a 17       	lddpc	r7,80002bb4 <DataSession_brdcst_func+0x174>
80002b32:	6e 0c       	ld.w	r12,r7[0x0]
80002b34:	30 09       	mov	r9,0
80002b36:	3f fa       	mov	r10,-1
80002b38:	12 9b       	mov	r11,r9
80002b3a:	f0 1f 00 20 	mcall	80002bb8 <DataSession_brdcst_func+0x178>
					global_count++;
80002b3e:	4a 08       	lddpc	r8,80002bbc <DataSession_brdcst_func+0x17c>
80002b40:	70 09       	ld.w	r9,r8[0x0]
80002b42:	2f f9       	sub	r9,-1
80002b44:	91 09       	st.w	r8[0x0],r9
					xSemaphoreGive(count_mutex);
80002b46:	6e 0c       	ld.w	r12,r7[0x0]
80002b48:	30 09       	mov	r9,0
80002b4a:	12 9a       	mov	r10,r9
80002b4c:	12 9b       	mov	r11,r9
80002b4e:	f0 1f 00 18 	mcall	80002bac <DataSession_brdcst_func+0x16c>
80002b52:	c0 48       	rjmp	80002b5a <DataSession_brdcst_func+0x11a>
				}
			}
			else
			{
				log("myptr: err\n\r" );
80002b54:	49 bc       	lddpc	r12,80002bc0 <DataSession_brdcst_func+0x180>
80002b56:	f0 1f 00 0a 	mcall	80002b7c <DataSession_brdcst_func+0x13c>
			}
			xcmp_IdleTestTone(Tone_Start, MANDOWN_DISABLE_TONE);//set tone to indicate send-failure!!!
80002b5a:	e0 6b 00 b7 	mov	r11,183
80002b5e:	30 1c       	mov	r12,1
80002b60:	f0 1f 00 0e 	mcall	80002b98 <DataSession_brdcst_func+0x158>
		}
		
		/* 'Give' the semaphore to unblock the task. */
		xSemaphoreGive(xBinarySemaphore);
80002b64:	49 88       	lddpc	r8,80002bc4 <DataSession_brdcst_func+0x184>
80002b66:	70 0c       	ld.w	r12,r8[0x0]
80002b68:	30 09       	mov	r9,0
80002b6a:	12 9a       	mov	r10,r9
80002b6c:	12 9b       	mov	r11,r9
80002b6e:	f0 1f 00 10 	mcall	80002bac <DataSession_brdcst_func+0x16c>
				//
		//}
		
	}
	
}
80002b72:	2f 8d       	sub	sp,-32
80002b74:	d8 22       	popm	r4-r7,pc
80002b76:	00 00       	add	r0,r0
80002b78:	80 00       	ld.sh	r0,r0[0x0]
80002b7a:	d7 28       	*unknown*
80002b7c:	80 00       	ld.sh	r0,r0[0x0]
80002b7e:	70 48       	ld.w	r8,r8[0x10]
80002b80:	80 00       	ld.sh	r0,r0[0x0]
80002b82:	d7 3c       	*unknown*
80002b84:	80 00       	ld.sh	r0,r0[0x0]
80002b86:	d7 54       	*unknown*
80002b88:	80 00       	ld.sh	r0,r0[0x0]
80002b8a:	d7 70       	acall	0x77
80002b8c:	80 00       	ld.sh	r0,r0[0x0]
80002b8e:	d7 88       	*unknown*
80002b90:	80 00       	ld.sh	r0,r0[0x0]
80002b92:	d7 94       	*unknown*
80002b94:	80 00       	ld.sh	r0,r0[0x0]
80002b96:	6a dc       	ld.w	r12,r5[0x34]
80002b98:	80 00       	ld.sh	r0,r0[0x0]
80002b9a:	41 1c       	lddsp	r12,sp[0x44]
80002b9c:	80 00       	ld.sh	r0,r0[0x0]
80002b9e:	78 c4       	ld.w	r4,r12[0x30]
80002ba0:	00 00       	add	r0,r0
80002ba2:	0b 74       	ld.ub	r4,--r5
80002ba4:	80 00       	ld.sh	r0,r0[0x0]
80002ba6:	2e 60       	sub	r0,-26
80002ba8:	00 00       	add	r0,r0
80002baa:	0b 70       	ld.ub	r0,--r5
80002bac:	80 00       	ld.sh	r0,r0[0x0]
80002bae:	64 10       	ld.w	r0,r2[0x4]
80002bb0:	80 00       	ld.sh	r0,r0[0x0]
80002bb2:	d6 b8       	*unknown*
80002bb4:	00 00       	add	r0,r0
80002bb6:	0a 64       	and	r4,r5
80002bb8:	80 00       	ld.sh	r0,r0[0x0]
80002bba:	62 04       	ld.w	r4,r1[0x0]
80002bbc:	00 00       	add	r0,r0
80002bbe:	0a 44       	or	r4,r5
80002bc0:	80 00       	ld.sh	r0,r0[0x0]
80002bc2:	d7 ac       	*unknown*
80002bc4:	00 00       	add	r0,r0
80002bc6:	0b 78       	ld.ub	r8,--r5

80002bc8 <DeviceInitializationStatus_brdcst_func>:
//xnl_content_master_status_brdcst_t XCMP_Version;

//app func--list

void DeviceInitializationStatus_brdcst_func(xcmp_fragment_t  * xcmp)
{
80002bc8:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	DeviceInitializationStatus_brdcst_t *ptr = (DeviceInitializationStatus_brdcst_t* )xcmp->u8;
80002bcc:	f8 c7 ff fe 	sub	r7,r12,-2
	
	//log("DeviceInitializationStatus_brdcst...\n");
	
	memcpy(XCMP_Version, &(ptr->XCMPVersion[0]), sizeof(XCMP_Version));
80002bd0:	30 4a       	mov	r10,4
80002bd2:	0e 9b       	mov	r11,r7
80002bd4:	48 dc       	lddpc	r12,80002c08 <DeviceInitializationStatus_brdcst_func+0x40>
80002bd6:	f0 1f 00 0e 	mcall	80002c0c <DeviceInitializationStatus_brdcst_func+0x44>
	
	if (ptr->DeviceInitType == Device_Init_Complete)
80002bda:	0f c8       	ld.ub	r8,r7[0x4]
80002bdc:	30 19       	mov	r9,1
80002bde:	f2 08 18 00 	cp.b	r8,r9
80002be2:	c0 71       	brne	80002bf0 <DeviceInitializationStatus_brdcst_func+0x28>
	{
		bunchofrandomstatusflags |= 0x01;  //Need do nothing else.
80002be4:	48 b8       	lddpc	r8,80002c10 <DeviceInitializationStatus_brdcst_func+0x48>
80002be6:	70 09       	ld.w	r9,r8[0x0]
80002be8:	a1 a9       	sbr	r9,0x0
80002bea:	91 09       	st.w	r8[0x0],r9
80002bec:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else if(ptr->DeviceInitType  == Device_Init_Status)
80002bf0:	58 08       	cp.w	r8,0
80002bf2:	c0 81       	brne	80002c02 <DeviceInitializationStatus_brdcst_func+0x3a>
	{
		bunchofrandomstatusflags  &= 0xFFFFFFFC; //Device Init no longer Complete.
80002bf4:	48 78       	lddpc	r8,80002c10 <DeviceInitializationStatus_brdcst_func+0x48>
80002bf6:	70 09       	ld.w	r9,r8[0x0]
80002bf8:	e0 19 ff fc 	andl	r9,0xfffc
80002bfc:	91 09       	st.w	r8[0x0],r9
		xcmp_DeviceInitializationStatus_request();
80002bfe:	f0 1f 00 06 	mcall	80002c14 <DeviceInitializationStatus_brdcst_func+0x4c>
80002c02:	e3 cd 80 80 	ldm	sp++,r7,pc
80002c06:	00 00       	add	r0,r0
80002c08:	00 00       	add	r0,r0
80002c0a:	0d 9c       	ld.ub	r12,r6[0x1]
80002c0c:	80 00       	ld.sh	r0,r0[0x0]
80002c0e:	78 c4       	ld.w	r4,r12[0x30]
80002c10:	00 00       	add	r0,r0
80002c12:	0d a0       	ld.ub	r0,r6[0x2]
80002c14:	80 00       	ld.sh	r0,r0[0x0]
80002c16:	40 68       	lddsp	r8,sp[0x18]

80002c18 <CalculateBurst>:
Calls:
Called By: phy_payload_rx
*/

volatile RxAMBEBurstType CalculateBurst(U8 vf_sn)
{
80002c18:	20 1c       	sub	r12,1
80002c1a:	5c 5c       	castu.b	r12
80002c1c:	31 18       	mov	r8,17
80002c1e:	f0 0c 18 00 	cp.b	r12,r8
80002c22:	e0 88 00 03 	brls	80002c28 <CalculateBurst+0x10>
80002c26:	5e fd       	retal	0
80002c28:	48 28       	lddpc	r8,80002c30 <CalculateBurst+0x18>
80002c2a:	f0 0c 03 2c 	ld.w	r12,r8[r12<<0x2]
			Burst_ID = 0x00;
			return VOICE_WATING;
		
	}
	
}
80002c2e:	5e fc       	retal	r12
80002c30:	80 00       	ld.sh	r0,r0[0x0]
80002c32:	d7 bc       	*unknown*

80002c34 <payload_init>:
Calls: xTaskCreate--freertos
Called By:app_init -- app.c
*/
void payload_init(void ( *payload_rx_func)(void * ), void ( *payload_tx_func)(void * ) )
{				
	payload_rx_exec = payload_rx_func;
80002c34:	48 38       	lddpc	r8,80002c40 <payload_init+0xc>
80002c36:	91 0c       	st.w	r8[0x0],r12
	payload_tx_exec = payload_tx_func;
80002c38:	48 38       	lddpc	r8,80002c44 <payload_init+0x10>
80002c3a:	91 0b       	st.w	r8[0x0],r11
	//,  2
	//,  NULL
	//);
	//
	
}
80002c3c:	5e fc       	retal	r12
80002c3e:	00 00       	add	r0,r0
80002c40:	00 00       	add	r0,r0
80002c42:	0a 70       	tst	r0,r5
80002c44:	00 00       	add	r0,r0
80002c46:	0a 74       	tst	r4,r5

80002c48 <set_idle_store_isr>:
{
	xQueueSend(store, &ptr, 0);
}

void set_idle_store_isr(xQueueHandle store, void * ptr)
{
80002c48:	d4 01       	pushm	lr
80002c4a:	20 2d       	sub	sp,8
80002c4c:	50 0b       	stdsp	sp[0x0],r11
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002c4e:	30 09       	mov	r9,0
80002c50:	fa ca ff f8 	sub	r10,sp,-8
80002c54:	14 d9       	st.w	--r10,r9
	xQueueSendFromISR(store, &ptr, &xHigherPriorityTaskWoken);
80002c56:	1a 9b       	mov	r11,sp
80002c58:	f0 1f 00 02 	mcall	80002c60 <set_idle_store_isr+0x18>
}
80002c5c:	2f ed       	sub	sp,-8
80002c5e:	d8 02       	popm	pc
80002c60:	80 00       	ld.sh	r0,r0[0x0]
80002c62:	63 c0       	ld.w	r0,r1[0x70]

80002c64 <payload_rx>:
		//logFromISR("ss");
	}
}

static void payload_rx(void * payload)
{
80002c64:	d4 01       	pushm	lr
    set_payload_idle_isr(payload);
80002c66:	48 48       	lddpc	r8,80002c74 <payload_rx+0x10>
80002c68:	70 08       	ld.w	r8,r8[0x0]
80002c6a:	18 9b       	mov	r11,r12
80002c6c:	10 9c       	mov	r12,r8
80002c6e:	f0 1f 00 03 	mcall	80002c78 <payload_rx+0x14>
	else
	{
		//logFromISR("ss");
	}
	#endif
}
80002c72:	d8 02       	popm	pc
80002c74:	00 00       	add	r0,r0
80002c76:	0a ac       	st.w	r5++,r12
80002c78:	80 00       	ld.sh	r0,r0[0x0]
80002c7a:	2c 48       	sub	r8,-60

80002c7c <phy_rx>:
	xQueueSendFromISR -- freertos
Called By: phy_xnl_rx
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
80002c7c:	d4 01       	pushm	lr
80002c7e:	20 2d       	sub	sp,8
80002c80:	50 0c       	stdsp	sp[0x0],r12
	//memcpy(xx, phy_ptr, sizeof(phy_fragment_t));
	//set_phy_idle_isr(&phy_ptr, &xHigherPriorityTaskWoken);
	
	Bool res = FALSE;
	
	if(NULL == phy_ptr)
80002c82:	58 0c       	cp.w	r12,0
80002c84:	c1 10       	breq	80002ca6 <phy_rx+0x2a>
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
    /*variables are used to store the push result in interrupt*/
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002c86:	30 08       	mov	r8,0
80002c88:	50 18       	stdsp	sp[0x4],r8
	if(NULL == phy_ptr)
	{
		return;
	}
	
    U16 phy_ctrl = phy_ptr->xnl_fragment.phy_header.phy_control;
80002c8a:	98 88       	ld.uh	r8,r12[0x0]
80002c8c:	e2 18 f0 00 	andl	r8,0xf000,COH
80002c90:	e0 48 40 00 	cp.w	r8,16384
80002c94:	c0 91       	brne	80002ca6 <phy_rx+0x2a>

    if (XCMPXNL_DATA == (phy_ctrl & 0xF000))
    {
        /*push the xnl packet to queue*/
        if( pdTRUE == xQueueSendFromISR(
80002c96:	48 68       	lddpc	r8,80002cac <phy_rx+0x30>
80002c98:	70 0c       	ld.w	r12,r8[0x0]
80002c9a:	30 09       	mov	r9,0
80002c9c:	fa ca ff fc 	sub	r10,sp,-4
80002ca0:	1a 9b       	mov	r11,sp
80002ca2:	f0 1f 00 04 	mcall	80002cb0 <phy_rx+0x34>
		}	

    }
		
 
}
80002ca6:	2f ed       	sub	sp,-8
80002ca8:	d8 02       	popm	pc
80002caa:	00 00       	add	r0,r0
80002cac:	00 00       	add	r0,r0
80002cae:	0a b8       	st.h	r5++,r8
80002cb0:	80 00       	ld.sh	r0,r0[0x0]
80002cb2:	63 c0       	ld.w	r0,r1[0x70]

80002cb4 <set_idle_store>:
	}
}


void set_idle_store(xQueueHandle store, void * ptr)
{
80002cb4:	eb cd 40 80 	pushm	r7,lr
80002cb8:	20 1d       	sub	sp,4
80002cba:	fa c7 ff fc 	sub	r7,sp,-4
80002cbe:	0e db       	st.w	--r7,r11
	xQueueSend(store, &ptr, 0);
80002cc0:	30 09       	mov	r9,0
80002cc2:	12 9a       	mov	r10,r9
80002cc4:	1a 9b       	mov	r11,sp
80002cc6:	f0 1f 00 03 	mcall	80002cd0 <set_idle_store+0x1c>
}
80002cca:	2f fd       	sub	sp,-4
80002ccc:	e3 cd 80 80 	ldm	sp++,r7,pc
80002cd0:	80 00       	ld.sh	r0,r0[0x0]
80002cd2:	64 10       	ld.w	r0,r2[0x4]

80002cd4 <phy_tx>:
Calls:   
	xQueueSend -- freertos
Called By: xnl_tx -- xnl.c
*/
void phy_tx(phy_fragment_t * phy)
{	
80002cd4:	d4 01       	pushm	lr
80002cd6:	20 1d       	sub	sp,4
80002cd8:	50 0c       	stdsp	sp[0x0],r12
	
	//phy_fragment_t * phy_ptr = malloc(sizeof(phy_fragment_t));
	//memcpy(phy_ptr, phy, sizeof(phy_fragment_t));
	//log("\n\r T_xcmp:%4x \n\r", phy->xnl_fragment.xnl_payload.xnl_content_data_msg.xcmp_opcode);
	//log("T_xnl-opcode:%4x", xnl->xnl_header.opcode);//log:R_xnl指令	
	if(XCMPXNL_DATA == (phy_ctrl & 0xF000))
80002cda:	98 88       	ld.uh	r8,r12[0x0]
80002cdc:	e2 18 f0 00 	andl	r8,0xf000,COH
80002ce0:	e0 48 40 00 	cp.w	r8,16384
80002ce4:	c0 d1       	brne	80002cfe <phy_tx+0x2a>
	{
		/*push the xnl packet to queue to send */
		if(NULL != phy_xnl_frame_tx)
80002ce6:	49 08       	lddpc	r8,80002d24 <phy_tx+0x50>
80002ce8:	70 08       	ld.w	r8,r8[0x0]
80002cea:	58 08       	cp.w	r8,0
80002cec:	c1 a0       	breq	80002d20 <phy_tx+0x4c>
		{
			if( pdTRUE == xQueueSend(phy_xnl_frame_tx, &phy, 0))
80002cee:	48 e8       	lddpc	r8,80002d24 <phy_tx+0x50>
80002cf0:	70 0c       	ld.w	r12,r8[0x0]
80002cf2:	30 09       	mov	r9,0
80002cf4:	12 9a       	mov	r10,r9
80002cf6:	1a 9b       	mov	r11,sp
80002cf8:	f0 1f 00 0c 	mcall	80002d28 <phy_tx+0x54>
80002cfc:	c1 28       	rjmp	80002d20 <phy_tx+0x4c>
		}
	}
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE		
	else if((SPEAKER_DATA == (phy_ctrl & 0xF000))
80002cfe:	e0 48 10 00 	cp.w	r8,4096
80002d02:	5f 0a       	sreq	r10
80002d04:	e0 48 20 00 	cp.w	r8,8192
80002d08:	5f 09       	sreq	r9
80002d0a:	f5 e9 10 09 	or	r9,r10,r9
80002d0e:	c0 71       	brne	80002d1c <phy_tx+0x48>
80002d10:	e0 48 50 00 	cp.w	r8,20480
80002d14:	c0 40       	breq	80002d1c <phy_tx+0x48>
80002d16:	e0 48 60 00 	cp.w	r8,24576
80002d1a:	c0 31       	brne	80002d20 <phy_tx+0x4c>
	    || (MIC_DATA  == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_RX == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_TX == (phy_ctrl & 0xF000))
	)
	{		
		if(NULL == phy_payload_frame_tx)
80002d1c:	48 48       	lddpc	r8,80002d2c <phy_tx+0x58>
80002d1e:	70 08       	ld.w	r8,r8[0x0]
	
	if(res != TRUE)
	{
		//vPortFree(phy_ptr);
	}
}
80002d20:	2f fd       	sub	sp,-4
80002d22:	d8 02       	popm	pc
80002d24:	00 00       	add	r0,r0
80002d26:	0a d8       	st.w	--r5,r8
80002d28:	80 00       	ld.sh	r0,r0[0x0]
80002d2a:	64 10       	ld.w	r0,r2[0x4]
80002d2c:	00 00       	add	r0,r0
80002d2e:	0a cc       	st.b	r5++,r12

80002d30 <get_idle_store_isr>:
		return NULL;
	}
}

void * get_idle_store_isr(xQueueHandle store)
{
80002d30:	d4 01       	pushm	lr
80002d32:	20 2d       	sub	sp,8
	void * ptr = NULL;
80002d34:	30 08       	mov	r8,0
80002d36:	50 18       	stdsp	sp[0x4],r8
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002d38:	50 08       	stdsp	sp[0x0],r8
	
	if(pdTRUE == xQueueReceiveFromISR(store, &ptr, &xHigherPriorityTaskWoken))
80002d3a:	1a 9a       	mov	r10,sp
80002d3c:	fa cb ff fc 	sub	r11,sp,-4
80002d40:	f0 1f 00 05 	mcall	80002d54 <get_idle_store_isr+0x24>
80002d44:	58 1c       	cp.w	r12,1
80002d46:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80002d4a:	fb fc 00 01 	ld.weq	r12,sp[0x4]
	}
	else
	{
		return NULL;
	}
}
80002d4e:	2f ed       	sub	sp,-8
80002d50:	d8 02       	popm	pc
80002d52:	00 00       	add	r0,r0
80002d54:	80 00       	ld.sh	r0,r0[0x0]
80002d56:	61 14       	ld.w	r4,r0[0x44]

80002d58 <phy_tx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_tx_func( void * ssc)
{
80002d58:	eb cd 40 c0 	pushm	r6-r7,lr
80002d5c:	20 1d       	sub	sp,4
80002d5e:	18 97       	mov	r7,r12
    if(NULL != phy_xnl_frame_tx)
80002d60:	4b a8       	lddpc	r8,80002e48 <phy_tx_func+0xf0>
80002d62:	70 08       	ld.w	r8,r8[0x0]
80002d64:	58 08       	cp.w	r8,0
80002d66:	c6 60       	breq	80002e32 <phy_tx_func+0xda>
    {
  	  	/*send ssc data in xnl frame*/
  	  	phy_xnl_tx(&(((ssc_fragment_t * )ssc)->xnl_channel));		
80002d68:	18 96       	mov	r6,r12
Called By:phy_tx_func
*/
static void phy_xnl_tx(xnl_channel_t * xnl_tx_channel)
{
	/*variables are used to store the push result in interrupt*/
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002d6a:	30 08       	mov	r8,0
80002d6c:	50 08       	stdsp	sp[0x0],r8
	
	static S16 phy_tx_expexted_length = 0;
	static U8 phy_tx_index = 0;
	
	/*his is the code for handling any outgoing XNL Phy message*/
	switch(phy_tx_state)
80002d6e:	4b 88       	lddpc	r8,80002e4c <phy_tx_func+0xf4>
80002d70:	70 08       	ld.w	r8,r8[0x0]
80002d72:	58 18       	cp.w	r8,1
80002d74:	c2 60       	breq	80002dc0 <phy_tx_func+0x68>
80002d76:	c0 43       	brcs	80002d7e <phy_tx_func+0x26>
80002d78:	58 28       	cp.w	r8,2
80002d7a:	c5 c1       	brne	80002e32 <phy_tx_func+0xda>
80002d7c:	c5 58       	rjmp	80002e26 <phy_tx_func+0xce>
	{
		/*Waiting for the send xnl packet*/
		case WAITING_FOR_PHY_TX:			
			if( pdTRUE == xQueueReceiveFromISR(
80002d7e:	4b 38       	lddpc	r8,80002e48 <phy_tx_func+0xf0>
80002d80:	70 0c       	ld.w	r12,r8[0x0]
80002d82:	1a 9a       	mov	r10,sp
80002d84:	4b 3b       	lddpc	r11,80002e50 <phy_tx_func+0xf8>
80002d86:	f0 1f 00 34 	mcall	80002e54 <phy_tx_func+0xfc>
80002d8a:	58 1c       	cp.w	r12,1
80002d8c:	c1 41       	brne	80002db4 <phy_tx_func+0x5c>
				  phy_xnl_frame_tx
				, &phy_ptr
				, &xHigherPriorityTaskWoken 
			))
			{								
				phy_tx_expexted_length = 
80002d8e:	4b 18       	lddpc	r8,80002e50 <phy_tx_func+0xf8>
80002d90:	70 08       	ld.w	r8,r8[0x0]
80002d92:	90 08       	ld.sh	r8,r8[0x0]
80002d94:	10 9a       	mov	r10,r8
80002d96:	f5 da c0 08 	bfextu	r10,r10,0x0,0x8
80002d9a:	4b 09       	lddpc	r9,80002e58 <phy_tx_func+0x100>
80002d9c:	b2 0a       	st.h	r9[0x0],r10
				*/
				xnl_tx_channel->dword = 
				                   phy_ptr->xnl_fragment.phy_header.phy_control;
				
				/*Transmit 0xABCD0000 | Type/Length.*/
				xnl_tx_channel->dword |= PHYHEADER32;
80002d9e:	5c 78       	castu.h	r8
80002da0:	ea 18 ab cd 	orh	r8,0xabcd
80002da4:	8f 18       	st.w	r7[0x4],r8
				
				phy_tx_index = 1;
80002da6:	30 19       	mov	r9,1
80002da8:	4a d8       	lddpc	r8,80002e5c <phy_tx_func+0x104>
80002daa:	b0 89       	st.b	r8[0x0],r9
				phy_tx_state = WRITE_NEXT_DWORD;	
80002dac:	30 19       	mov	r9,1
80002dae:	4a 88       	lddpc	r8,80002e4c <phy_tx_func+0xf4>
80002db0:	91 09       	st.w	r8[0x0],r9
80002db2:	c4 08       	rjmp	80002e32 <phy_tx_func+0xda>
				/*The new transmission has started.*/
			}
			else
			{
				/*Nothing new to transmit, send an idle frame*/
				xnl_tx_channel->dword = XNL_IDLE;
80002db4:	e0 68 5a 5a 	mov	r8,23130
80002db8:	ea 18 ab cd 	orh	r8,0xabcd
80002dbc:	8f 18       	st.w	r7[0x4],r8
80002dbe:	c3 a8       	rjmp	80002e32 <phy_tx_func+0xda>
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80002dc0:	4a 7a       	lddpc	r10,80002e5c <phy_tx_func+0x104>
80002dc2:	15 88       	ld.ub	r8,r10[0x0]
				xnl_tx_channel->dword = XNL_IDLE;
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
80002dc4:	4a 39       	lddpc	r9,80002e50 <phy_tx_func+0xf8>
80002dc6:	72 09       	ld.w	r9,r9[0x0]
80002dc8:	f2 08 05 19 	ld.uh	r9,r9[r8<<0x1]
80002dcc:	b1 69       	lsl	r9,0x10
80002dce:	99 19       	st.w	r12[0x4],r9
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80002dd0:	2f f8       	sub	r8,-1
80002dd2:	5c 58       	castu.b	r8
80002dd4:	b4 88       	st.b	r10[0x0],r8

			phy_tx_expexted_length -= 2;
80002dd6:	4a 1b       	lddpc	r11,80002e58 <phy_tx_func+0x100>
80002dd8:	96 0c       	ld.sh	r12,r11[0x0]
80002dda:	20 2c       	sub	r12,2
80002ddc:	5c 8c       	casts.h	r12
80002dde:	f5 dc b0 10 	bfexts	r10,r12,0x0,0x10
80002de2:	b6 0a       	st.h	r11[0x0],r10
			
			/*have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80002de4:	30 0b       	mov	r11,0
80002de6:	f6 0a 19 00 	cp.h	r10,r11
80002dea:	e0 89 00 09 	brgt	80002dfc <phy_tx_func+0xa4>
			{
				/*Must immediately send 0x00BA in Slot 4.*/
				xnl_tx_channel->dword |= PHYTERMRIGHT;
80002dee:	e8 19 00 ba 	orl	r9,0xba
80002df2:	8f 19       	st.w	r7[0x4],r9
				
				/*Go back to waiting.*/
				phy_tx_state = WAITING_FOR_PHY_TX;
80002df4:	30 09       	mov	r9,0
80002df6:	49 68       	lddpc	r8,80002e4c <phy_tx_func+0xf4>
80002df8:	91 09       	st.w	r8[0x0],r9
80002dfa:	c1 c8       	rjmp	80002e32 <phy_tx_func+0xda>
				break;
			}

			/*Have not broken. Transmit 2nd hWord.*/
			xnl_tx_channel->dword |=  phy_ptr->fragment_element[phy_tx_index++];
80002dfc:	49 5a       	lddpc	r10,80002e50 <phy_tx_func+0xf8>
80002dfe:	74 0a       	ld.w	r10,r10[0x0]
80002e00:	f4 08 05 1a 	ld.uh	r10,r10[r8<<0x1]
80002e04:	14 49       	or	r9,r10
80002e06:	8f 19       	st.w	r7[0x4],r9
80002e08:	2f f8       	sub	r8,-1
80002e0a:	49 59       	lddpc	r9,80002e5c <phy_tx_func+0x104>
80002e0c:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
80002e0e:	20 2c       	sub	r12,2
80002e10:	49 28       	lddpc	r8,80002e58 <phy_tx_func+0x100>
80002e12:	b0 0c       	st.h	r8[0x0],r12
			
			/*Have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80002e14:	30 08       	mov	r8,0
80002e16:	f0 0c 19 00 	cp.h	r12,r8
80002e1a:	e0 89 00 0c 	brgt	80002e32 <phy_tx_func+0xda>
			{
				/*Must send 0x00BA0000 next interrupt in Slot 3&4*/
				phy_tx_state = SEND_TAILED;
80002e1e:	30 29       	mov	r9,2
80002e20:	48 b8       	lddpc	r8,80002e4c <phy_tx_func+0xf4>
80002e22:	91 09       	st.w	r8[0x0],r9
80002e24:	c0 78       	rjmp	80002e32 <phy_tx_func+0xda>
			}
			break;

		case SEND_TAILED:
			/*send 0x00BA0000*/
			xnl_tx_channel->dword = PHYTERMLEFT;
80002e26:	fc 18 00 ba 	movh	r8,0xba
80002e2a:	99 18       	st.w	r12[0x4],r8
			
			/*Go back to waiting.*/		
			phy_tx_state = WAITING_FOR_PHY_TX;		
80002e2c:	30 09       	mov	r9,0
80002e2e:	48 88       	lddpc	r8,80002e4c <phy_tx_func+0xf4>
80002e30:	91 09       	st.w	r8[0x0],r9
	//#else
	///*send idle frame*/	
	//((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
	//((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
	//#endif /*end if*/
	((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
80002e32:	e0 68 5a 5a 	mov	r8,23130
80002e36:	ea 18 ab cd 	orh	r8,0xabcd
80002e3a:	8f 28       	st.w	r7[0x8],r8
	((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
80002e3c:	30 08       	mov	r8,0
80002e3e:	8f 38       	st.w	r7[0xc],r8
}
80002e40:	2f fd       	sub	sp,-4
80002e42:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002e46:	00 00       	add	r0,r0
80002e48:	00 00       	add	r0,r0
80002e4a:	0a d8       	st.w	--r5,r8
80002e4c:	00 00       	add	r0,r0
80002e4e:	0a 98       	mov	r8,r5
80002e50:	00 00       	add	r0,r0
80002e52:	0a a4       	st.w	r5++,r4
80002e54:	80 00       	ld.sh	r0,r0[0x0]
80002e56:	61 14       	ld.w	r4,r0[0x44]
80002e58:	00 00       	add	r0,r0
80002e5a:	0a c0       	st.b	r5++,r0
80002e5c:	00 00       	add	r0,r0
80002e5e:	0a 78       	tst	r8,r5

80002e60 <get_idle_store>:
	}//End of RxMedia Phy Handler.
}
#endif /*end if*/

void * get_idle_store(xQueueHandle store)
{
80002e60:	d4 01       	pushm	lr
80002e62:	20 1d       	sub	sp,4
	void * ptr = NULL;
80002e64:	30 0a       	mov	r10,0
80002e66:	fa cb ff fc 	sub	r11,sp,-4
80002e6a:	16 da       	st.w	--r11,r10

	if(pdTRUE == xQueueReceive(store, &ptr, 0))
80002e6c:	14 99       	mov	r9,r10
80002e6e:	1a 9b       	mov	r11,sp
80002e70:	f0 1f 00 05 	mcall	80002e84 <get_idle_store+0x24>
80002e74:	58 1c       	cp.w	r12,1
80002e76:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80002e7a:	fb fc 00 00 	ld.weq	r12,sp[0x0]
	}
	else
	{
		return NULL;
	}
}
80002e7e:	2f fd       	sub	sp,-4
80002e80:	d8 02       	popm	pc
80002e82:	00 00       	add	r0,r0
80002e84:	80 00       	ld.sh	r0,r0[0x0]
80002e86:	62 04       	ld.w	r4,r1[0x0]

80002e88 <phy_init>:
    register_rx_tx_func -- ssc.c
	xQueueCreate -- freertos
Called By: xnl_init -- xnl.c
*/
void phy_init( void )
{
80002e88:	d4 01       	pushm	lr
    /*register the func to send/receive ssc packet*/
    register_rx_tx_func(phy_rx_func, phy_tx_func);	
80002e8a:	48 4b       	lddpc	r11,80002e98 <phy_init+0x10>
80002e8c:	48 4c       	lddpc	r12,80002e9c <phy_init+0x14>
80002e8e:	f0 1f 00 05 	mcall	80002ea0 <phy_init+0x18>
	
	/*initialize the SSC*/
	ssc_init();
80002e92:	f0 1f 00 05 	mcall	80002ea4 <phy_init+0x1c>
	
	/*send device_master_query to connect radio*/
	//xnl_send_device_master_query();
	
}
80002e96:	d8 02       	popm	pc
80002e98:	80 00       	ld.sh	r0,r0[0x0]
80002e9a:	2d 58       	sub	r8,-43
80002e9c:	80 00       	ld.sh	r0,r0[0x0]
80002e9e:	2e a8       	sub	r8,-22
80002ea0:	80 00       	ld.sh	r0,r0[0x0]
80002ea2:	3e fc       	mov	r12,-17
80002ea4:	80 00       	ld.sh	r0,r0[0x0]
80002ea6:	3f 10       	mov	r0,-15

80002ea8 <phy_rx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_rx_func( void * ssc)
{    
80002ea8:	eb cd 40 e0 	pushm	r5-r7,lr
80002eac:	18 97       	mov	r7,r12
		
	if(NULL != phy_xnl_frame_rx)
80002eae:	fe f8 0e 7a 	ld.w	r8,pc[3706]
80002eb2:	70 08       	ld.w	r8,r8[0x0]
80002eb4:	58 08       	cp.w	r8,0
80002eb6:	e0 80 01 08 	breq	800030c6 <phy_rx_func+0x21e>
	static U16 phy_check_sum = 0;

	static phy_rx_state_t  phy_rx_state = WAITING_FOR_HEADER;
	static U32 phy_rx_count = 0;

	U32 phy_dword = xnl_rx_channel->dword;	
80002eba:	78 16       	ld.w	r6,r12[0x4]

	phy_rx_count++;
80002ebc:	fe f8 0e 70 	ld.w	r8,pc[3696]
80002ec0:	70 09       	ld.w	r9,r8[0x0]
80002ec2:	2f f9       	sub	r9,-1
80002ec4:	91 09       	st.w	r8[0x0],r9
	
	/*This is the code for parsing the incoming physical message.*/
	switch (phy_rx_state)
80002ec6:	fe f8 0e 6a 	ld.w	r8,pc[3690]
80002eca:	70 08       	ld.w	r8,r8[0x0]
80002ecc:	58 18       	cp.w	r8,1
80002ece:	e0 80 00 85 	breq	80002fd8 <phy_rx_func+0x130>
80002ed2:	c0 73       	brcs	80002ee0 <phy_rx_func+0x38>
80002ed4:	58 28       	cp.w	r8,2
80002ed6:	c5 c0       	breq	80002f8e <phy_rx_func+0xe6>
80002ed8:	58 38       	cp.w	r8,3
80002eda:	e0 81 00 f6 	brne	800030c6 <phy_rx_func+0x21e>
80002ede:	cd 58       	rjmp	80003088 <phy_rx_func+0x1e0>

        /*Waiting for something. Most frequent visit.*/		
		case WAITING_FOR_HEADER:
		
			/*Ignore Idles.*/
			if (0xABCD5A5A == phy_dword)
80002ee0:	e0 6a 5a 5a 	mov	r10,23130
80002ee4:	ea 1a ab cd 	orh	r10,0xabcd
80002ee8:	14 36       	cp.w	r6,r10
80002eea:	e0 80 00 ee 	breq	800030c6 <phy_rx_func+0x21e>
			{
				break;
			}	

			/*Skip until Header.*/		
			if (0xABCD != (phy_dword >> 16))
80002eee:	ec 08 16 10 	lsr	r8,r6,0x10
80002ef2:	e0 48 ab cd 	cp.w	r8,43981
80002ef6:	e0 81 00 e8 	brne	800030c6 <phy_rx_func+0x21e>
			{			
				break;
			}
		
			/*Length excluding CSUM.*/
			phy_rx_expexted_length = (phy_dword & 0x000000FF) - 2;
80002efa:	eb d6 b0 10 	bfexts	r5,r6,0x0,0x10
80002efe:	f1 d5 c0 08 	bfextu	r8,r5,0x0,0x8
80002f02:	20 28       	sub	r8,2
80002f04:	fe f9 0e 30 	ld.w	r9,pc[3632]
80002f08:	b2 08       	st.h	r9[0x0],r8
			
			/*Discard degenerate message.*/
			if (phy_rx_expexted_length <= 0)
80002f0a:	30 09       	mov	r9,0
80002f0c:	f2 08 19 00 	cp.h	r8,r9
80002f10:	e0 8a 00 db 	brle	800030c6 <phy_rx_func+0x21e>
			{
				break;
			}
		
			phy_rx_length = 0;
80002f14:	fe f8 0e 24 	ld.w	r8,pc[3620]
80002f18:	b0 09       	st.h	r8[0x0],r9

			phy_frame_ptr = get_xnl_idle_isr();
80002f1a:	fe f8 0e 22 	ld.w	r8,pc[3618]
80002f1e:	70 0c       	ld.w	r12,r8[0x0]
80002f20:	f0 1f 03 88 	mcall	80003d40 <phy_rx_func+0xe98>
80002f24:	fe f8 0e 20 	ld.w	r8,pc[3616]
80002f28:	91 0c       	st.w	r8[0x0],r12
			if(NULL == phy_frame_ptr)
80002f2a:	58 0c       	cp.w	r12,0
80002f2c:	e0 80 00 cd 	breq	800030c6 <phy_rx_func+0x21e>
			{
				break;
			}
					
			phy_frame_ptr->fragment_element[phy_rx_length++] = phy_dword;
80002f30:	fe f8 0e 08 	ld.w	r8,pc[3592]
80002f34:	90 09       	ld.sh	r9,r8[0x0]
80002f36:	f8 09 0a 15 	st.h	r12[r9<<0x1],r5
80002f3a:	2f f9       	sub	r9,-1
80002f3c:	5c 89       	casts.h	r9
			
			/*time stamp*/
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
80002f3e:	fe fa 0e 06 	ld.w	r10,pc[3590]
80002f42:	74 0a       	ld.w	r10,r10[0x0]
80002f44:	fe fb 0d e8 	ld.w	r11,pc[3560]
80002f48:	76 0b       	ld.w	r11,r11[0x0]
80002f4a:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
80002f4e:	2f f9       	sub	r9,-1
80002f50:	b0 09       	st.h	r8[0x0],r9
													(phy_rx_count) & 0x0000FFFF;
			
			/*This switch tests the fragment type, and adjusts receiver state
			accordingly.*/
			/*Check frag type*/
			switch (phy_dword & 0x00000F00)
80002f52:	e2 16 0f 00 	andl	r6,0xf00,COH
80002f56:	e0 46 01 00 	cp.w	r6,256
80002f5a:	c0 c0       	breq	80002f72 <phy_rx_func+0xca>
80002f5c:	e0 8b 00 05 	brhi	80002f66 <phy_rx_func+0xbe>
80002f60:	58 06       	cp.w	r6,0
80002f62:	c0 80       	breq	80002f72 <phy_rx_func+0xca>
80002f64:	c0 c8       	rjmp	80002f7c <phy_rx_func+0xd4>
80002f66:	e0 46 02 00 	cp.w	r6,512
80002f6a:	c0 40       	breq	80002f72 <phy_rx_func+0xca>
80002f6c:	e0 46 03 00 	cp.w	r6,768
80002f70:	c0 61       	brne	80002f7c <phy_rx_func+0xd4>
			{
				case SINGLE_FRAGMENT:  //Only Fragment.
				case FIRST_FRAGMENT:   //First of Multi-fragment.
				case MIDDLE_FRAGMENT:  //Continuing Multi-fragment.
				case LAST_FRAGMENT:    //Last Multi-fragment.
					phy_rx_state = WAITING_CHECK_SUM;
80002f72:	30 29       	mov	r9,2
80002f74:	fe f8 0d bc 	ld.w	r8,pc[3516]
80002f78:	91 09       	st.w	r8[0x0],r9
80002f7a:	ca 68       	rjmp	800030c6 <phy_rx_func+0x21e>
				break;
				default:
					set_xnl_idle_isr(phy_frame_ptr);			
80002f7c:	fe f8 0d c0 	ld.w	r8,pc[3520]
80002f80:	70 0c       	ld.w	r12,r8[0x0]
80002f82:	fe f8 0d c2 	ld.w	r8,pc[3522]
80002f86:	70 0b       	ld.w	r11,r8[0x0]
80002f88:	f0 1f 03 70 	mcall	80003d48 <phy_rx_func+0xea0>
80002f8c:	c9 d8       	rjmp	800030c6 <phy_rx_func+0x21e>
		
			/*Stores CSUM*/
			phy_check_sum  = (phy_dword & 0xFFFF0000) >> 16;
			
			/*sums in first hWord*/
			phy_check_sum += (phy_dword & 0x0000FFFF);		
80002f8e:	f5 d6 b0 10 	bfexts	r10,r6,0x0,0x10
80002f92:	b1 86       	lsr	r6,0x10
80002f94:	14 06       	add	r6,r10
80002f96:	fe f8 0d b6 	ld.w	r8,pc[3510]
80002f9a:	b0 06       	st.h	r8[0x0],r6
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
80002f9c:	fe f8 0d 9c 	ld.w	r8,pc[3484]
80002fa0:	90 09       	ld.sh	r9,r8[0x0]
80002fa2:	fe fb 0d a2 	ld.w	r11,pc[3490]
80002fa6:	76 0b       	ld.w	r11,r11[0x0]
80002fa8:	f6 09 0a 1a 	st.h	r11[r9<<0x1],r10
80002fac:	2f f9       	sub	r9,-1
80002fae:	b0 09       	st.h	r8[0x0],r9
														 phy_dword & 0x0000FFFF;
					
			phy_rx_expexted_length -= 2;
80002fb0:	fe f9 0d 84 	ld.w	r9,pc[3460]
80002fb4:	92 08       	ld.sh	r8,r9[0x0]
80002fb6:	20 28       	sub	r8,2
80002fb8:	b2 08       	st.h	r9[0x0],r8
			
			/*Normal case for greater than one byte payloads.*/
			if (phy_rx_expexted_length > 0)
80002fba:	30 09       	mov	r9,0
80002fbc:	f2 08 19 00 	cp.h	r8,r9
80002fc0:	e0 8a 00 07 	brle	80002fce <phy_rx_func+0x126>
			{					  
				phy_rx_state = READING_FRAGMENT;
80002fc4:	30 19       	mov	r9,1
80002fc6:	fe f8 0d 6a 	ld.w	r8,pc[3434]
80002fca:	91 09       	st.w	r8[0x0],r9
80002fcc:	c7 d8       	rjmp	800030c6 <phy_rx_func+0x21e>
	    		Note that all segments must align with a 32-bit boundary and
				beginning of each XCMP/XNL payload frame must start on slot 3
				Thus, segments of odd length must append a 0x0000 at the end
				(slot 4) to ensure alignment. [9.1.3]
				*/
				phy_rx_state = WAITING_LAST_TERM;
80002fce:	30 39       	mov	r9,3
80002fd0:	fe f8 0d 60 	ld.w	r8,pc[3424]
80002fd4:	91 09       	st.w	r8[0x0],r9
80002fd6:	c7 88       	rjmp	800030c6 <phy_rx_func+0x21e>
			}			
		
			break;

		case READING_FRAGMENT:
			phy_check_sum += (phy_dword & 0xFFFF0000) >> 16;
80002fd8:	ec 0a 14 10 	asr	r10,r6,0x10
80002fdc:	fe f8 0d 70 	ld.w	r8,pc[3440]
80002fe0:	90 09       	ld.sh	r9,r8[0x0]
80002fe2:	14 09       	add	r9,r10
80002fe4:	b0 09       	st.h	r8[0x0],r9
	
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
80002fe6:	fe f9 0d 52 	ld.w	r9,pc[3410]
80002fea:	92 08       	ld.sh	r8,r9[0x0]
80002fec:	fe fb 0d 58 	ld.w	r11,pc[3416]
80002ff0:	76 0b       	ld.w	r11,r11[0x0]
80002ff2:	f6 08 0a 1a 	st.h	r11[r8<<0x1],r10
80002ff6:	2f f8       	sub	r8,-1
80002ff8:	5c 88       	casts.h	r8
80002ffa:	b2 08       	st.h	r9[0x0],r8
												 (phy_dword & 0xFFFF0000) >> 16;
	
			phy_rx_expexted_length -= 2;
80002ffc:	fe fa 0d 38 	ld.w	r10,pc[3384]
80003000:	94 09       	ld.sh	r9,r10[0x0]
80003002:	20 29       	sub	r9,2
80003004:	b4 09       	st.h	r10[0x0],r9
			if (phy_rx_expexted_length <= 0)
80003006:	30 0a       	mov	r10,0
80003008:	f4 09 19 00 	cp.h	r9,r10
8000300c:	e0 89 00 20 	brgt	8000304c <phy_rx_func+0x1a4>
				Terminator should be in 2nd hWord.
				Shaoqun says useful bits not used. The packet will always end
				with $00BA. [9.1.2.8]	
				*/
				
				if ((0x000000BA == (phy_dword  & 0x0000FFFF)) 
80003010:	ed d6 c0 10 	bfextu	r6,r6,0x0,0x10
80003014:	e0 46 00 ba 	cp.w	r6,186
80003018:	c0 d1       	brne	80003032 <phy_rx_func+0x18a>
8000301a:	fe f8 0d 32 	ld.w	r8,pc[3378]
8000301e:	90 09       	ld.sh	r9,r8[0x0]
80003020:	f4 09 19 00 	cp.h	r9,r10
80003024:	c0 71       	brne	80003032 <phy_rx_func+0x18a>
					&& (phy_check_sum == 0))
				{
					phy_rx(phy_frame_ptr);
80003026:	fe f8 0d 1e 	ld.w	r8,pc[3358]
8000302a:	70 0c       	ld.w	r12,r8[0x0]
8000302c:	f0 1f 03 49 	mcall	80003d50 <phy_rx_func+0xea8>
80003030:	c0 98       	rjmp	80003042 <phy_rx_func+0x19a>
				}
				else
				{
					set_xnl_idle_isr(phy_frame_ptr);
80003032:	fe f8 0d 0a 	ld.w	r8,pc[3338]
80003036:	70 0c       	ld.w	r12,r8[0x0]
80003038:	fe f8 0d 0c 	ld.w	r8,pc[3340]
8000303c:	70 0b       	ld.w	r11,r8[0x0]
8000303e:	f0 1f 03 43 	mcall	80003d48 <phy_rx_func+0xea0>
				}

				phy_rx_state = WAITING_FOR_HEADER;
80003042:	30 09       	mov	r9,0
80003044:	fe f8 0c ec 	ld.w	r8,pc[3308]
80003048:	91 09       	st.w	r8[0x0],r9
8000304a:	c3 e8       	rjmp	800030c6 <phy_rx_func+0x21e>
				break;
			}
		
			/*Have not broken. 2nd hWord contains payload.*/
			phy_check_sum += (phy_dword & 0x0000FFFF);
8000304c:	5c 86       	casts.h	r6
8000304e:	fe f9 0c fe 	ld.w	r9,pc[3326]
80003052:	92 0a       	ld.sh	r10,r9[0x0]
80003054:	0c 0a       	add	r10,r6
80003056:	b2 0a       	st.h	r9[0x0],r10
		
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
80003058:	fe f9 0c ec 	ld.w	r9,pc[3308]
8000305c:	72 09       	ld.w	r9,r9[0x0]
8000305e:	f2 08 0a 16 	st.h	r9[r8<<0x1],r6
80003062:	2f f8       	sub	r8,-1
80003064:	fe f9 0c d4 	ld.w	r9,pc[3284]
80003068:	b2 08       	st.h	r9[0x0],r8
													   (phy_dword & 0x0000FFFF);
		
			phy_rx_expexted_length -= 2;
8000306a:	fe f9 0c ca 	ld.w	r9,pc[3274]
8000306e:	92 08       	ld.sh	r8,r9[0x0]
80003070:	20 28       	sub	r8,2
80003072:	b2 08       	st.h	r9[0x0],r8
			if (phy_rx_expexted_length <= 0)
80003074:	30 09       	mov	r9,0
80003076:	f2 08 19 00 	cp.h	r8,r9
8000307a:	e0 89 00 26 	brgt	800030c6 <phy_rx_func+0x21e>
			{
				/*All read in. Next Word should be 0x00BA0000.*/
				phy_rx_state = WAITING_LAST_TERM;
8000307e:	30 39       	mov	r9,3
80003080:	fe f8 0c b0 	ld.w	r8,pc[3248]
80003084:	91 09       	st.w	r8[0x0],r9
80003086:	c2 08       	rjmp	800030c6 <phy_rx_func+0x21e>
			}/*else, next Word contains more payload.*/
			break;

		/*Expecting last terminator 0x00BA0000.*/	
		case WAITING_LAST_TERM:			
			if ((0x00BA0000 == (phy_dword  & 0x00FF0000)) /*Expected found.*/
80003088:	e6 16 00 ff 	andh	r6,0xff,COH
8000308c:	fc 19 00 ba 	movh	r9,0xba
80003090:	12 36       	cp.w	r6,r9
80003092:	c0 e1       	brne	800030ae <phy_rx_func+0x206>
80003094:	fe f8 0c b8 	ld.w	r8,pc[3256]
80003098:	90 09       	ld.sh	r9,r8[0x0]
8000309a:	30 08       	mov	r8,0
8000309c:	f0 09 19 00 	cp.h	r9,r8
800030a0:	c0 71       	brne	800030ae <phy_rx_func+0x206>
				&& (phy_check_sum == 0))/*Good checksum*/
			{
				phy_rx(phy_frame_ptr);
800030a2:	fe f8 0c a2 	ld.w	r8,pc[3234]
800030a6:	70 0c       	ld.w	r12,r8[0x0]
800030a8:	f0 1f 03 2a 	mcall	80003d50 <phy_rx_func+0xea8>
800030ac:	c0 98       	rjmp	800030be <phy_rx_func+0x216>

			}
			else
			{
				set_xnl_idle_isr(phy_frame_ptr);
800030ae:	fe f8 0c 8e 	ld.w	r8,pc[3214]
800030b2:	70 0c       	ld.w	r12,r8[0x0]
800030b4:	fe f8 0c 90 	ld.w	r8,pc[3216]
800030b8:	70 0b       	ld.w	r11,r8[0x0]
800030ba:	f0 1f 03 24 	mcall	80003d48 <phy_rx_func+0xea0>
			}
				
			phy_rx_state = WAITING_FOR_HEADER;
800030be:	30 09       	mov	r9,0
800030c0:	fe f8 0c 70 	ld.w	r8,pc[3184]
800030c4:	91 09       	st.w	r8[0x0],r9
	static U8 _flag = 1;//0xABCDC014时，_flag为0；
						//0xABCDC010时，_flag为1；
			
	//payload_ptr_t *AMBE_payload_ptr;		
	
	if(is_first == FALSE)
800030c6:	fe f8 0c 8e 	ld.w	r8,pc[3214]
800030ca:	11 89       	ld.ub	r9,r8[0x0]
800030cc:	30 08       	mov	r8,0
800030ce:	f0 09 18 00 	cp.b	r9,r8
800030d2:	c1 31       	brne	800030f8 <phy_rx_func+0x250>
	{
		payload_ptr = get_payload_idle_isr();
800030d4:	fe f6 0c 84 	ld.w	r6,pc[3204]
800030d8:	6c 0c       	ld.w	r12,r6[0x0]
800030da:	f0 1f 03 1a 	mcall	80003d40 <phy_rx_func+0xe98>
800030de:	fe f8 0c 7e 	ld.w	r8,pc[3198]
800030e2:	91 0c       	st.w	r8[0x0],r12
		AMBE_payload_ptr = get_payload_idle_isr();
800030e4:	6c 0c       	ld.w	r12,r6[0x0]
800030e6:	f0 1f 03 17 	mcall	80003d40 <phy_rx_func+0xe98>
800030ea:	fe f8 0c 76 	ld.w	r8,pc[3190]
800030ee:	91 0c       	st.w	r8[0x0],r12
		is_first = TRUE;
800030f0:	30 19       	mov	r9,1
800030f2:	fe f8 0c 62 	ld.w	r8,pc[3170]
800030f6:	b0 89       	st.b	r8[0x0],r9
	}	
	
	//This is the RxMedia Phy Handler.
	switch (RxMediaState)
800030f8:	fe f8 0c 6c 	ld.w	r8,pc[3180]
800030fc:	70 08       	ld.w	r8,r8[0x0]
800030fe:	58 28       	cp.w	r8,2
80003100:	e0 80 01 98 	breq	80003430 <phy_rx_func+0x588>
80003104:	e0 8b 00 06 	brhi	80003110 <phy_rx_func+0x268>
80003108:	58 08       	cp.w	r8,0
8000310a:	c0 b0       	breq	80003120 <phy_rx_func+0x278>
8000310c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80003110:	58 38       	cp.w	r8,3
80003112:	e0 80 05 c5 	breq	80003c9c <phy_rx_func+0xdf4>
80003116:	58 48       	cp.w	r8,4
80003118:	e0 81 06 05 	brne	80003d22 <phy_rx_func+0xe7a>
8000311c:	e0 8f 02 4b 	bral	800035b2 <phy_rx_func+0x70a>
	{
		case WAITINGABAB:

			
			if (payload_rx_channel->dword[0] == 0xABCD5A5A)//Ignore Idles.
80003120:	6e 28       	ld.w	r8,r7[0x8]
80003122:	e0 6a 5a 5a 	mov	r10,23130
80003126:	ea 1a ab cd 	orh	r10,0xabcd
8000312a:	14 38       	cp.w	r8,r10
8000312c:	c0 71       	brne	8000313a <phy_rx_func+0x292>
			{
				m_RxBurstType = VOICE_WATING;
8000312e:	30 09       	mov	r9,0
80003130:	fe f8 0c 38 	ld.w	r8,pc[3128]
80003134:	91 09       	st.w	r8[0x0],r9
80003136:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
				//Upon receiving the idle frame, the m Rx Burst Type into an idle state in order to transmit the synchronization wait
				 break; 
			}
            
			if ((payload_rx_channel->dword[0]  & 0xFFFF0000) != 0xABCD0000)break; //Skip until Header. 
8000313a:	10 99       	mov	r9,r8
8000313c:	e0 19 00 00 	andl	r9,0x0
80003140:	fc 1a ab cd 	movh	r10,0xabcd
80003144:	14 39       	cp.w	r9,r10
80003146:	e0 81 05 ee 	brne	80003d22 <phy_rx_func+0xe7a>
			}
			//logFromISR("\n\r P: %X \n\r", payload_rx_channel->word[1]);//测试收到的数据
			
#endif
			
			RxBytesWaiting = payload_rx_channel->dword[0] & 0x000000FF;
8000314a:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
8000314e:	fe f9 0c 1e 	ld.w	r9,pc[3102]
80003152:	93 08       	st.w	r9[0x0],r8
			/****Note AMBE stream protocol frame structure and the PCM frame structure is different*****/
					
			if ((payload_rx_channel->dword[0] & 0x0000F000 ) == PAYLOAD_DATA_ENH )//PAYLOAD_DATA_ENH (0x0c))
80003154:	6e 29       	ld.w	r9,r7[0x8]
80003156:	e2 19 f0 00 	andl	r9,0xf000,COH
8000315a:	e0 49 c0 00 	cp.w	r9,49152
8000315e:	e0 81 00 ce 	brne	800032fa <phy_rx_func+0x452>
			{
				AMBE_Media = 1;	
80003162:	30 1a       	mov	r10,1
80003164:	fe f9 0c 0c 	ld.w	r9,pc[3084]
80003168:	b2 8a       	st.b	r9[0x0],r10
				
				if (NULL== AMBE_payload_ptr){
8000316a:	fe f9 0b f6 	ld.w	r9,pc[3062]
8000316e:	72 09       	ld.w	r9,r9[0x0]
80003170:	58 09       	cp.w	r9,0
80003172:	c0 71       	brne	80003180 <phy_rx_func+0x2d8>
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//测试是否有这种情况出现
80003174:	fe fc 0c 00 	ld.w	r12,pc[3072]
80003178:	f0 1f 03 00 	mcall	80003d78 <phy_rx_func+0xed0>
8000317c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
																	
				Item_ID = payload_rx_channel->byte[5];
80003180:	ef 3a 00 0d 	ld.ub	r10,r7[13]
80003184:	fe f9 0b f8 	ld.w	r9,pc[3064]
80003188:	b2 8a       	st.b	r9[0x0],r10
				
				Item_Length = (payload_rx_channel->byte[4] & 0x7F);//7bits
8000318a:	ef 3b 00 0c 	ld.ub	r11,r7[12]
8000318e:	f7 db c0 07 	bfextu	r11,r11,0x0,0x7
80003192:	fe fa 0b ee 	ld.w	r10,pc[3054]
80003196:	95 0b       	st.w	r10[0x0],r11
								
				switch(Item_ID)
80003198:	13 89       	ld.ub	r9,r9[0x0]
8000319a:	37 fa       	mov	r10,127
8000319c:	f4 09 18 00 	cp.b	r9,r10
800031a0:	c6 d0       	breq	8000327a <phy_rx_func+0x3d2>
800031a2:	e0 8b 00 0c 	brhi	800031ba <phy_rx_func+0x312>
800031a6:	31 2a       	mov	r10,18
800031a8:	f4 09 18 00 	cp.b	r9,r10
800031ac:	c4 20       	breq	80003230 <phy_rx_func+0x388>
800031ae:	31 3a       	mov	r10,19
800031b0:	f4 09 18 00 	cp.b	r9,r10
800031b4:	e0 81 00 83 	brne	800032ba <phy_rx_func+0x412>
800031b8:	c5 b8       	rjmp	8000326e <phy_rx_func+0x3c6>
800031ba:	2f 09       	sub	r9,-16
800031bc:	30 1a       	mov	r10,1
800031be:	f4 09 18 00 	cp.b	r9,r10
800031c2:	e0 8b 00 7c 	brhi	800032ba <phy_rx_func+0x412>
					//The OB know the Call begin and discard the Voice Header
					//The OB know the Call end and discard the Voice  Terminator
					case Raw_Tx_Data_HT://0xF0
					case Raw_Rx_Data_HT://0xF1
					
							if ((payload_rx_channel->byte[6] & 0xF0 )== 0x10)//header
800031c6:	ef 38 00 0e 	ld.ub	r8,r7[14]
800031ca:	e2 18 00 f0 	andl	r8,0xf0,COH
800031ce:	59 08       	cp.w	r8,16
800031d0:	c0 71       	brne	800031de <phy_rx_func+0x336>
							{
								m_RxBurstType = VOICEHEADER;
800031d2:	30 19       	mov	r9,1
800031d4:	fe f8 0b 94 	ld.w	r8,pc[2964]
800031d8:	91 09       	st.w	r8[0x0],r9
800031da:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

							}
							else if ((payload_rx_channel->byte[6] & 0xF0) == 0x20)//Terminator
800031de:	e0 48 00 20 	cp.w	r8,32
800031e2:	c2 11       	brne	80003224 <phy_rx_func+0x37c>
							{
								m_RxBurstType = VOICETERMINATOR;
800031e4:	30 a9       	mov	r9,10
800031e6:	fe f8 0b 82 	ld.w	r8,pc[2946]
800031ea:	91 09       	st.w	r8[0x0],r9
								//AMBE-data and PCM-data is not the same. AMBE is compressed data,
								//if there was a missing portion, a clear voice is difficult to extract the data.
								//It must ensure that all the data received AMBE.
								
								//注意！！！考虑是否需要把剩余的空间置0。
								memset((AMBE_payload_ptr+ (RxAMBE_IsFillingNext8 +1)), 0x00, (512-(RxAMBE_IsFillingNext8 + 1)));
800031ec:	fe f6 0b 98 	ld.w	r6,pc[2968]
800031f0:	6c 08       	ld.w	r8,r6[0x0]
800031f2:	f0 0a 11 ff 	rsub	r10,r8,-1
800031f6:	fe f7 0b 6a 	ld.w	r7,pc[2922]
800031fa:	2f f8       	sub	r8,-1
800031fc:	6e 0c       	ld.w	r12,r7[0x0]
800031fe:	f4 ca fe 00 	sub	r10,r10,-512
80003202:	30 0b       	mov	r11,0
80003204:	10 0c       	add	r12,r8
80003206:	f0 1f 02 e1 	mcall	80003d88 <phy_rx_func+0xee0>
								
								RxAMBE_IsFillingNext8 = 0;
8000320a:	30 08       	mov	r8,0
8000320c:	8d 08       	st.w	r6[0x0],r8
								payload_rx(AMBE_payload_ptr);
8000320e:	6e 0c       	ld.w	r12,r7[0x0]
80003210:	f0 1f 02 df 	mcall	80003d8c <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003214:	fe f8 0b 44 	ld.w	r8,pc[2884]
80003218:	70 0c       	ld.w	r12,r8[0x0]
8000321a:	f0 1f 02 ca 	mcall	80003d40 <phy_rx_func+0xe98>
8000321e:	8f 0c       	st.w	r7[0x0],r12
80003220:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								//logFromISR("\n\r QQ1 \n\r");
								
							}
							else//error voice
							{
								m_RxBurstType = VOICE_WATING;
80003224:	30 09       	mov	r9,0
80003226:	fe f8 0b 42 	ld.w	r8,pc[2882]
8000322a:	91 09       	st.w	r8[0x0],r9
8000322c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;//WAITINGABAB.
					
		
					case Vocoder_Bit_Stream_Parameter://0x12
							
							if ((RxBytesWaiting -= 4) <= 0) break;
80003230:	20 48       	sub	r8,4
80003232:	fe f9 0b 3a 	ld.w	r9,pc[2874]
80003236:	93 08       	st.w	r9[0x0],r8
80003238:	58 08       	cp.w	r8,0
8000323a:	e0 80 05 74 	breq	80003d22 <phy_rx_func+0xe7a>
					
							//Vocoder Bits Stream Parameter
							VF_SN = (payload_rx_channel->byte[7] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
8000323e:	ef 3c 00 0f 	ld.ub	r12,r7[15]
80003242:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
80003246:	fe f8 0b 4a 	ld.w	r8,pc[2890]
8000324a:	b0 8c       	st.b	r8[0x0],r12
							
							VBSP_data[0] = payload_rx_channel->word[2];
8000324c:	8e 69       	ld.sh	r9,r7[0xc]
8000324e:	fe f8 0b 46 	ld.w	r8,pc[2886]
80003252:	b0 09       	st.h	r8[0x0],r9
							VBSP_data[1] = payload_rx_channel->word[3];
80003254:	8e 79       	ld.sh	r9,r7[0xe]
80003256:	b0 19       	st.h	r8[0x2],r9
							
							m_RxBurstType = CalculateBurst(VF_SN);
80003258:	f0 1f 02 d0 	mcall	80003d98 <phy_rx_func+0xef0>
8000325c:	fe f8 0b 0c 	ld.w	r8,pc[2828]
80003260:	91 0c       	st.w	r8[0x0],r12
							
							RxMediaState = READING_AMBE_MEDIA;//Jump
80003262:	30 49       	mov	r9,4
80003264:	fe f8 0b 00 	ld.w	r8,pc[2816]
80003268:	91 09       	st.w	r8[0x0],r9
8000326a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							
					//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
					// or discard it to reduce payload size.	
					//This shouldn't happen, but must check.	
					case Soft_Decision_Value://0x13
						m_RxBurstType = VOICE_WATING;
8000326e:	30 09       	mov	r9,0
80003270:	fe f8 0a f8 	ld.w	r8,pc[2808]
80003274:	91 09       	st.w	r8[0x0],r9
80003276:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
					case Radio_Internal_Parameter://0x7F
							
							//logFromISR("\n\r Item_Length:%d\n\r", Item_Length);
							
							if ((RxBytesWaiting -= 4) <= 0) break;
8000327a:	20 48       	sub	r8,4
8000327c:	fe f9 0a f0 	ld.w	r9,pc[2800]
80003280:	93 08       	st.w	r9[0x0],r8
80003282:	58 08       	cp.w	r8,0
80003284:	e0 80 05 4f 	breq	80003d22 <phy_rx_func+0xe7a>
							//Radio Internal Parameter
							Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[3];
80003288:	fe f8 0b 14 	ld.w	r8,pc[2836]
8000328c:	70 09       	ld.w	r9,r8[0x0]
8000328e:	8e 7b       	ld.sh	r11,r7[0xe]
80003290:	fe fa 0b 10 	ld.w	r10,pc[2832]
80003294:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
							RxData_IsFillingNext16 += 1; 
80003298:	2f f9       	sub	r9,-1
8000329a:	91 09       	st.w	r8[0x0],r9
							Item_Length -= 2 ;
8000329c:	fe f8 0a e4 	ld.w	r8,pc[2788]
800032a0:	70 09       	ld.w	r9,r8[0x0]
800032a2:	20 29       	sub	r9,2
800032a4:	91 09       	st.w	r8[0x0],r9
							//....................................................
							m_RxBurstType = RADIOINTERNAL;
800032a6:	30 29       	mov	r9,2
800032a8:	fe f8 0a c0 	ld.w	r8,pc[2752]
800032ac:	91 09       	st.w	r8[0x0],r9

							RxMediaState = READING_AMBE_AUX;//Jump
800032ae:	30 39       	mov	r9,3
800032b0:	fe f8 0a b4 	ld.w	r8,pc[2740]
800032b4:	91 09       	st.w	r8[0x0],r9
800032b6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									
					default://0x03,0x04
						
						//((Item_ID == 0x04) || (Item_ID == 0x03) )//Unknown type data directly back hair
							//break;
							m_RxBurstType = UNSUREDATA;
800032ba:	30 3a       	mov	r10,3
800032bc:	fe f9 0a ac 	ld.w	r9,pc[2732]
800032c0:	93 0a       	st.w	r9[0x0],r10
							AMBE_HT[0] = payload_rx_channel->dword[0];
800032c2:	6e 2a       	ld.w	r10,r7[0x8]
800032c4:	fe f9 0a e0 	ld.w	r9,pc[2784]
800032c8:	93 0a       	st.w	r9[0x0],r10
							AMBE_HT[1] = payload_rx_channel->dword[1];
800032ca:	6e 3a       	ld.w	r10,r7[0xc]
800032cc:	93 1a       	st.w	r9[0x4],r10
							
							if (RxBytesWaiting == 0x00000014)
800032ce:	59 48       	cp.w	r8,20
800032d0:	c0 61       	brne	800032dc <phy_rx_func+0x434>
							{
								RxBytesWaiting = 0x18;//24 Reassigned
800032d2:	31 89       	mov	r9,24
800032d4:	fe f8 0a 98 	ld.w	r8,pc[2712]
800032d8:	91 09       	st.w	r8[0x0],r9
800032da:	c0 a8       	rjmp	800032ee <phy_rx_func+0x446>
								//_flag =0;
								
							}
							if (RxBytesWaiting == 0x00000010)
800032dc:	fe f8 0a 90 	ld.w	r8,pc[2704]
800032e0:	70 08       	ld.w	r8,r8[0x0]
800032e2:	59 08       	cp.w	r8,16
800032e4:	c0 51       	brne	800032ee <phy_rx_func+0x446>
							{
								RxBytesWaiting = 0x10;//16 Reassigned
800032e6:	31 09       	mov	r9,16
800032e8:	fe f8 0a 84 	ld.w	r8,pc[2692]
800032ec:	91 09       	st.w	r8[0x0],r9
								//_flag =1;
							}
					
							RxMediaState = READING_AMBE_MEDIA;//Jump
800032ee:	30 49       	mov	r9,4
800032f0:	fe f8 0a 74 	ld.w	r8,pc[2676]
800032f4:	91 09       	st.w	r8[0x0],r9
800032f6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
//#if 0
			else//PCM-media-data
			{	
				//logFromISR("\n\r RX:%x \n\r", payload_rx_channel->dword[0]);
				//SPEAKER_DATA or  //MIC_DATA
				if (((payload_rx_channel->dword[0] & 0x0000F000 ) != SPEAKER_DATA ) 
800032fa:	e0 49 10 00 	cp.w	r9,4096
800032fe:	5f 1a       	srne	r10
80003300:	e0 49 20 00 	cp.w	r9,8192
80003304:	5f 19       	srne	r9
80003306:	f5 e9 00 09 	and	r9,r10,r9
8000330a:	e0 81 05 0c 	brne	80003d22 <phy_rx_func+0xe7a>
					&& ((payload_rx_channel->dword[0] & 0x0000F000 ) != MIC_DATA ))break;
				
				AMBE_tx_flag = 0;
8000330e:	fe fa 0a 9a 	ld.w	r10,pc[2714]
80003312:	b4 89       	st.b	r10[0x0],r9
				AMBE_rx_flag = 0;
80003314:	fe fa 0a 98 	ld.w	r10,pc[2712]
80003318:	b4 89       	st.b	r10[0x0],r9
				
				Item_ID = 0;//To make sure your save PCM data.
8000331a:	fe fa 0a 62 	ld.w	r10,pc[2658]
8000331e:	b4 89       	st.b	r10[0x0],r9
			
				if (NULL== payload_ptr){
80003320:	fe f9 0a 3c 	ld.w	r9,pc[2620]
80003324:	72 09       	ld.w	r9,r9[0x0]
80003326:	58 09       	cp.w	r9,0
80003328:	c0 71       	brne	80003336 <phy_rx_func+0x48e>
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//测试是否有这种情况出现
8000332a:	fe fc 0a 4a 	ld.w	r12,pc[2634]
8000332e:	f0 1f 02 93 	mcall	80003d78 <phy_rx_func+0xed0>
80003332:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003336:	6e 2a       	ld.w	r10,r7[0x8]
80003338:	e2 1a 0f 00 	andl	r10,0xf00,COH
8000333c:	58 1a       	cp.w	r10,1
8000333e:	e0 8b 00 4d 	brhi	800033d8 <phy_rx_func+0x530>
				
				if ((payload_rx_channel->dword[0]  & 0x00000F00) <= 1){  //Flag type must process Array Descriptor.
				//The first word of the media access payload must be the Array descriptor length. And the
				//unit of the length is in word (16-bit). The length field itself does not count into the length.
				//When there is no array descriptor, the length must be set to zero.[9.1.4.1]
					if ((RxBytesWaiting -= 4) <= 0) break;          //Nothing beyond this Phy buffer. Keep looking for Header
80003342:	20 48       	sub	r8,4
80003344:	fe f9 0a 28 	ld.w	r9,pc[2600]
80003348:	93 08       	st.w	r9[0x0],r8
8000334a:	58 08       	cp.w	r8,0
8000334c:	e0 80 04 eb 	breq	80003d22 <phy_rx_func+0xe7a>
					ArrayDiscLength = payload_rx_channel->word[2];
80003350:	8e 68       	ld.sh	r8,r7[0xc]
80003352:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
80003356:	fe f9 0a 5a 	ld.w	r9,pc[2650]
8000335a:	93 0a       	st.w	r9[0x0],r10
					switch (ArrayDiscLength){
8000335c:	30 09       	mov	r9,0
8000335e:	f2 08 19 00 	cp.h	r8,r9
80003362:	c0 70       	breq	80003370 <phy_rx_func+0x4c8>
80003364:	30 19       	mov	r9,1
80003366:	f2 08 19 00 	cp.h	r8,r9
8000336a:	e0 81 04 dc 	brne	80003d22 <phy_rx_func+0xe7a>
8000336e:	c2 68       	rjmp	800033ba <phy_rx_func+0x512>
						case 0:          //The usual case. Remaining word in Phy buffer is Audio.
								
							payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
80003370:	fe f8 0a 44 	ld.w	r8,pc[2628]
80003374:	70 0a       	ld.w	r10,r8[0x0]
80003376:	fe f9 09 e6 	ld.w	r9,pc[2534]
8000337a:	72 09       	ld.w	r9,r9[0x0]
8000337c:	8e 7b       	ld.sh	r11,r7[0xe]
8000337e:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
							RxMedia_IsFillingNext16 += 1;
80003382:	70 09       	ld.w	r9,r8[0x0]
80003384:	2f f9       	sub	r9,-1
80003386:	91 09       	st.w	r8[0x0],r9
							if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003388:	e0 49 00 ff 	cp.w	r9,255
8000338c:	e0 88 00 11 	brls	800033ae <phy_rx_func+0x506>
							{
								RxMedia_IsFillingNext16 = 0;	
80003390:	30 09       	mov	r9,0
80003392:	91 09       	st.w	r8[0x0],r9
								payload_rx(payload_ptr);	
80003394:	fe f7 09 c8 	ld.w	r7,pc[2504]
80003398:	6e 0c       	ld.w	r12,r7[0x0]
8000339a:	f0 1f 02 7d 	mcall	80003d8c <phy_rx_func+0xee4>
								payload_ptr = get_payload_idle_isr();
8000339e:	fe f8 09 ba 	ld.w	r8,pc[2490]
800033a2:	70 0c       	ld.w	r12,r8[0x0]
800033a4:	f0 1f 02 67 	mcall	80003d40 <phy_rx_func+0xe98>
800033a8:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == payload_ptr){
800033aa:	e0 80 04 bc 	breq	80003d22 <phy_rx_func+0xe7a>
									break;
								}				
							}
							RxMediaState = READINGMEDIA;
800033ae:	30 29       	mov	r9,2
800033b0:	fe f8 09 b4 	ld.w	r8,pc[2484]
800033b4:	91 09       	st.w	r8[0x0],r9
800033b6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
800033ba:	8e 79       	ld.sh	r9,r7[0xe]
800033bc:	30 38       	mov	r8,3
800033be:	f0 09 19 00 	cp.h	r9,r8
800033c2:	c0 51       	brne	800033cc <phy_rx_func+0x524>
				
						case 1: //The next usual case.
								//In general case, add code to process single word Array descriptor.
								if (payload_rx_channel->word[3] == 0x0003)//Stream Terminator
								{
									Terminator_Flag = 1;
800033c4:	30 19       	mov	r9,1
800033c6:	fe f8 09 f2 	ld.w	r8,pc[2546]
800033ca:	b0 89       	st.b	r8[0x0],r9
								else
								{
									//Terminator_Flag = 0;
								}
								
								RxMediaState = READINGMEDIA;
800033cc:	30 29       	mov	r9,2
800033ce:	fe f8 09 96 	ld.w	r8,pc[2454]
800033d2:	91 09       	st.w	r8[0x0],r9
800033d4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
				break;
			}
		
				//Code gets here on Middle or last Fragment. No Array descriptor.
				if (RxBytesWaiting < 2) break;//This shouldn't happen, but must check.
800033d8:	58 18       	cp.w	r8,1
800033da:	e0 88 04 a4 	brls	80003d22 <phy_rx_func+0xe7a>
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->dword[1] & 0x0000FFFF;
800033de:	fe f8 09 d6 	ld.w	r8,pc[2518]
800033e2:	70 0a       	ld.w	r10,r8[0x0]
800033e4:	6e 3b       	ld.w	r11,r7[0xc]
800033e6:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
800033ea:	70 09       	ld.w	r9,r8[0x0]
800033ec:	2f f9       	sub	r9,-1
800033ee:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800033f0:	e0 49 00 ff 	cp.w	r9,255
800033f4:	e0 88 00 11 	brls	80003416 <phy_rx_func+0x56e>
				{
					RxMedia_IsFillingNext16 = 0;
800033f8:	30 09       	mov	r9,0
800033fa:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
800033fc:	fe f7 09 60 	ld.w	r7,pc[2400]
80003400:	6e 0c       	ld.w	r12,r7[0x0]
80003402:	f0 1f 02 63 	mcall	80003d8c <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
80003406:	fe f8 09 52 	ld.w	r8,pc[2386]
8000340a:	70 0c       	ld.w	r12,r8[0x0]
8000340c:	f0 1f 02 4d 	mcall	80003d40 <phy_rx_func+0xe98>
80003410:	8f 0c       	st.w	r7[0x0],r12
					if(NULL == payload_ptr)
80003412:	e0 80 04 88 	breq	80003d22 <phy_rx_func+0xe7a>
					{
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0) break;  //This shouldn't happen, but must check;
80003416:	fe f9 09 56 	ld.w	r9,pc[2390]
8000341a:	72 08       	ld.w	r8,r9[0x0]
8000341c:	20 28       	sub	r8,2
8000341e:	93 08       	st.w	r9[0x0],r8
80003420:	e0 80 04 81 	breq	80003d22 <phy_rx_func+0xe7a>
				RxMediaState = READINGMEDIA;
80003424:	30 29       	mov	r9,2
80003426:	fe f8 09 3e 	ld.w	r8,pc[2366]
8000342a:	91 09       	st.w	r8[0x0],r9
8000342c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
		case READINGMEDIA:
				
			/***PCM-media-data ****/
			{
				
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[0];
80003430:	fe f8 09 84 	ld.w	r8,pc[2436]
80003434:	70 0a       	ld.w	r10,r8[0x0]
80003436:	fe f9 09 26 	ld.w	r9,pc[2342]
8000343a:	72 09       	ld.w	r9,r9[0x0]
8000343c:	8e 4b       	ld.sh	r11,r7[0x8]
8000343e:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;	
80003442:	70 09       	ld.w	r9,r8[0x0]
80003444:	2f f9       	sub	r9,-1
80003446:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003448:	e0 49 00 ff 	cp.w	r9,255
8000344c:	e0 88 00 16 	brls	80003478 <phy_rx_func+0x5d0>
				{
					RxMedia_IsFillingNext16 = 0;
80003450:	30 09       	mov	r9,0
80003452:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003454:	fe f6 09 08 	ld.w	r6,pc[2312]
80003458:	6c 0c       	ld.w	r12,r6[0x0]
8000345a:	f0 1f 02 4d 	mcall	80003d8c <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
8000345e:	fe f8 08 fa 	ld.w	r8,pc[2298]
80003462:	70 0c       	ld.w	r12,r8[0x0]
80003464:	f0 1f 02 37 	mcall	80003d40 <phy_rx_func+0xe98>
80003468:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
8000346a:	c0 71       	brne	80003478 <phy_rx_func+0x5d0>
					{
						RxMediaState = WAITINGABAB;
8000346c:	30 09       	mov	r9,0
8000346e:	fe f8 08 f6 	ld.w	r8,pc[2294]
80003472:	91 09       	st.w	r8[0x0],r9
80003474:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0)
80003478:	fe f9 08 f4 	ld.w	r9,pc[2292]
8000347c:	72 08       	ld.w	r8,r9[0x0]
8000347e:	20 28       	sub	r8,2
80003480:	93 08       	st.w	r9[0x0],r8
80003482:	c0 71       	brne	80003490 <phy_rx_func+0x5e8>
				{
					RxMediaState = WAITINGABAB;
80003484:	30 09       	mov	r9,0
80003486:	fe f8 08 de 	ld.w	r8,pc[2270]
8000348a:	91 09       	st.w	r8[0x0],r9
8000348c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[1];
80003490:	fe f8 09 24 	ld.w	r8,pc[2340]
80003494:	70 0a       	ld.w	r10,r8[0x0]
80003496:	fe f9 08 c6 	ld.w	r9,pc[2246]
8000349a:	72 09       	ld.w	r9,r9[0x0]
8000349c:	8e 5b       	ld.sh	r11,r7[0xa]
8000349e:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
800034a2:	70 09       	ld.w	r9,r8[0x0]
800034a4:	2f f9       	sub	r9,-1
800034a6:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800034a8:	e0 49 00 ff 	cp.w	r9,255
800034ac:	e0 88 00 16 	brls	800034d8 <phy_rx_func+0x630>
				{
					RxMedia_IsFillingNext16 = 0;
800034b0:	30 09       	mov	r9,0
800034b2:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
800034b4:	fe f6 08 a8 	ld.w	r6,pc[2216]
800034b8:	6c 0c       	ld.w	r12,r6[0x0]
800034ba:	f0 1f 02 35 	mcall	80003d8c <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
800034be:	fe f8 08 9a 	ld.w	r8,pc[2202]
800034c2:	70 0c       	ld.w	r12,r8[0x0]
800034c4:	f0 1f 02 1f 	mcall	80003d40 <phy_rx_func+0xe98>
800034c8:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
800034ca:	c0 71       	brne	800034d8 <phy_rx_func+0x630>
					{
						RxMediaState = WAITINGABAB;
800034cc:	30 09       	mov	r9,0
800034ce:	fe f8 08 96 	ld.w	r8,pc[2198]
800034d2:	91 09       	st.w	r8[0x0],r9
800034d4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
800034d8:	fe f9 08 94 	ld.w	r9,pc[2196]
800034dc:	72 08       	ld.w	r8,r9[0x0]
800034de:	20 28       	sub	r8,2
800034e0:	93 08       	st.w	r9[0x0],r8
800034e2:	c0 71       	brne	800034f0 <phy_rx_func+0x648>
					RxMediaState = WAITINGABAB;
800034e4:	30 09       	mov	r9,0
800034e6:	fe f8 08 7e 	ld.w	r8,pc[2174]
800034ea:	91 09       	st.w	r8[0x0],r9
800034ec:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}

				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[2];
800034f0:	fe f8 08 c4 	ld.w	r8,pc[2244]
800034f4:	70 0a       	ld.w	r10,r8[0x0]
800034f6:	fe f9 08 66 	ld.w	r9,pc[2150]
800034fa:	72 09       	ld.w	r9,r9[0x0]
800034fc:	8e 6b       	ld.sh	r11,r7[0xc]
800034fe:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80003502:	70 09       	ld.w	r9,r8[0x0]
80003504:	2f f9       	sub	r9,-1
80003506:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003508:	e0 49 00 ff 	cp.w	r9,255
8000350c:	e0 88 00 16 	brls	80003538 <phy_rx_func+0x690>
				{
					RxMedia_IsFillingNext16 = 0;
80003510:	30 09       	mov	r9,0
80003512:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003514:	fe f6 08 48 	ld.w	r6,pc[2120]
80003518:	6c 0c       	ld.w	r12,r6[0x0]
8000351a:	f0 1f 02 1d 	mcall	80003d8c <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
8000351e:	fe f8 08 3a 	ld.w	r8,pc[2106]
80003522:	70 0c       	ld.w	r12,r8[0x0]
80003524:	f0 1f 02 07 	mcall	80003d40 <phy_rx_func+0xe98>
80003528:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
8000352a:	c0 71       	brne	80003538 <phy_rx_func+0x690>
					{
						RxMediaState = WAITINGABAB;
8000352c:	30 09       	mov	r9,0
8000352e:	fe f8 08 36 	ld.w	r8,pc[2102]
80003532:	91 09       	st.w	r8[0x0],r9
80003534:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
80003538:	fe f9 08 34 	ld.w	r9,pc[2100]
8000353c:	72 08       	ld.w	r8,r9[0x0]
8000353e:	20 28       	sub	r8,2
80003540:	93 08       	st.w	r9[0x0],r8
80003542:	c0 71       	brne	80003550 <phy_rx_func+0x6a8>
					RxMediaState = WAITINGABAB;
80003544:	30 09       	mov	r9,0
80003546:	fe f8 08 1e 	ld.w	r8,pc[2078]
8000354a:	91 09       	st.w	r8[0x0],r9
8000354c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
80003550:	fe f8 08 64 	ld.w	r8,pc[2148]
80003554:	70 0a       	ld.w	r10,r8[0x0]
80003556:	fe f9 08 06 	ld.w	r9,pc[2054]
8000355a:	72 09       	ld.w	r9,r9[0x0]
8000355c:	8e 7b       	ld.sh	r11,r7[0xe]
8000355e:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80003562:	70 09       	ld.w	r9,r8[0x0]
80003564:	2f f9       	sub	r9,-1
80003566:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003568:	e0 49 00 ff 	cp.w	r9,255
8000356c:	e0 88 00 16 	brls	80003598 <phy_rx_func+0x6f0>
				{
					RxMedia_IsFillingNext16 = 0;
80003570:	30 09       	mov	r9,0
80003572:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003574:	fe f7 07 e8 	ld.w	r7,pc[2024]
80003578:	6e 0c       	ld.w	r12,r7[0x0]
8000357a:	f0 1f 02 05 	mcall	80003d8c <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
8000357e:	fe f8 07 da 	ld.w	r8,pc[2010]
80003582:	70 0c       	ld.w	r12,r8[0x0]
80003584:	f0 1f 01 ef 	mcall	80003d40 <phy_rx_func+0xe98>
80003588:	8f 0c       	st.w	r7[0x0],r12
					if(NULL == payload_ptr)
8000358a:	c0 71       	brne	80003598 <phy_rx_func+0x6f0>
					{
						RxMediaState = WAITINGABAB;
8000358c:	30 09       	mov	r9,0
8000358e:	fe f8 07 d6 	ld.w	r8,pc[2006]
80003592:	91 09       	st.w	r8[0x0],r9
80003594:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
80003598:	fe f9 07 d4 	ld.w	r9,pc[2004]
8000359c:	72 08       	ld.w	r8,r9[0x0]
8000359e:	20 28       	sub	r8,2
800035a0:	93 08       	st.w	r9[0x0],r8
800035a2:	e0 81 03 c0 	brne	80003d22 <phy_rx_func+0xe7a>
					RxMediaState = WAITINGABAB;
800035a6:	30 09       	mov	r9,0
800035a8:	fe f8 07 bc 	ld.w	r8,pc[1980]
800035ac:	91 09       	st.w	r8[0x0],r9
800035ae:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

		case READING_AMBE_MEDIA:
		
			/****AMBE-media-data ****/
		
					if ((Item_ID == Vocoder_Bit_Stream_Parameter))//PAYLOAD_DATA_ENH (0x0c))
800035b2:	fe f8 07 ca 	ld.w	r8,pc[1994]
800035b6:	11 89       	ld.ub	r9,r8[0x0]
800035b8:	31 28       	mov	r8,18
800035ba:	f0 09 18 00 	cp.b	r9,r8
800035be:	e0 81 01 4c 	brne	80003856 <phy_rx_func+0x9ae>
					{
						Item_ID = payload_rx_channel->byte[1];
800035c2:	ef 39 00 09 	ld.ub	r9,r7[9]
800035c6:	fe f8 07 b6 	ld.w	r8,pc[1974]
800035ca:	b0 89       	st.b	r8[0x0],r9
						if (Item_ID == Post_Voice_Encoder_Data)//发送方的压缩类型数据
800035cc:	11 89       	ld.ub	r9,r8[0x0]
800035ce:	3f 28       	mov	r8,-14
800035d0:	f0 09 18 00 	cp.b	r9,r8
800035d4:	e0 81 01 3b 	brne	8000384a <phy_rx_func+0x9a2>
						{
							AMBE_tx_flag = 1;
800035d8:	30 19       	mov	r9,1
800035da:	fe f8 07 ce 	ld.w	r8,pc[1998]
800035de:	b0 89       	st.b	r8[0x0],r9
							
							RxBytesWaiting = ((payload_rx_channel->dword[0] & 0x7F000000) >>24);//Test calculations are correct; 8
800035e0:	6e 29       	ld.w	r9,r7[0x8]
800035e2:	f3 d9 c3 07 	bfextu	r9,r9,0x18,0x7
800035e6:	fe f8 07 86 	ld.w	r8,pc[1926]
800035ea:	91 09       	st.w	r8[0x0],r9
							
							//For looping back to Radio
							AMBEBurst_rawdata[0] = payload_rx_channel->word[1];
800035ec:	8e 59       	ld.sh	r9,r7[0xa]
800035ee:	fe f8 07 ce 	ld.w	r8,pc[1998]
800035f2:	b0 09       	st.h	r8[0x0],r9
							AMBEBurst_rawdata[1] = payload_rx_channel->word[2];
800035f4:	8e 69       	ld.sh	r9,r7[0xc]
800035f6:	b0 19       	st.h	r8[0x2],r9
							AMBEBurst_rawdata[2] = payload_rx_channel->word[3];
800035f8:	8e 79       	ld.sh	r9,r7[0xe]
800035fa:	b0 29       	st.h	r8[0x4],r9
							
							//To be tested. Also locally stored RAW-AMBER-DATA
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//1
800035fc:	fe f8 07 88 	ld.w	r8,pc[1928]
80003600:	fe f9 07 60 	ld.w	r9,pc[1888]
80003604:	72 0a       	ld.w	r10,r9[0x0]
80003606:	70 09       	ld.w	r9,r8[0x0]
80003608:	ef 3b 00 0a 	ld.ub	r11,r7[10]
8000360c:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003610:	70 09       	ld.w	r9,r8[0x0]
80003612:	2f f9       	sub	r9,-1
80003614:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003616:	e0 49 01 ff 	cp.w	r9,511
8000361a:	e0 88 00 16 	brls	80003646 <phy_rx_func+0x79e>
							{
								RxAMBE_IsFillingNext8 = 0;
8000361e:	30 09       	mov	r9,0
80003620:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003622:	fe f6 07 3e 	ld.w	r6,pc[1854]
80003626:	6c 0c       	ld.w	r12,r6[0x0]
80003628:	f0 1f 01 d9 	mcall	80003d8c <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
8000362c:	fe f8 07 2c 	ld.w	r8,pc[1836]
80003630:	70 0c       	ld.w	r12,r8[0x0]
80003632:	f0 1f 01 c4 	mcall	80003d40 <phy_rx_func+0xe98>
80003636:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003638:	c0 71       	brne	80003646 <phy_rx_func+0x79e>
								{
									RxMediaState = WAITINGABAB;
8000363a:	30 09       	mov	r9,0
8000363c:	fe f8 07 28 	ld.w	r8,pc[1832]
80003640:	91 09       	st.w	r8[0x0],r9
80003642:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003646:	fe f9 07 26 	ld.w	r9,pc[1830]
8000364a:	72 08       	ld.w	r8,r9[0x0]
8000364c:	20 18       	sub	r8,1
8000364e:	93 08       	st.w	r9[0x0],r8
80003650:	c0 71       	brne	8000365e <phy_rx_func+0x7b6>
								RxMediaState = WAITINGABAB;
80003652:	30 09       	mov	r9,0
80003654:	fe f8 07 10 	ld.w	r8,pc[1808]
80003658:	91 09       	st.w	r8[0x0],r9
8000365a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}			
							
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//2
8000365e:	fe f8 07 26 	ld.w	r8,pc[1830]
80003662:	fe f9 06 fe 	ld.w	r9,pc[1790]
80003666:	72 0a       	ld.w	r10,r9[0x0]
80003668:	70 09       	ld.w	r9,r8[0x0]
8000366a:	ef 3b 00 0b 	ld.ub	r11,r7[11]
8000366e:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003672:	70 09       	ld.w	r9,r8[0x0]
80003674:	2f f9       	sub	r9,-1
80003676:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003678:	e0 49 01 ff 	cp.w	r9,511
8000367c:	e0 88 00 16 	brls	800036a8 <phy_rx_func+0x800>
							{
								RxAMBE_IsFillingNext8 = 0;
80003680:	30 09       	mov	r9,0
80003682:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003684:	fe f6 06 dc 	ld.w	r6,pc[1756]
80003688:	6c 0c       	ld.w	r12,r6[0x0]
8000368a:	f0 1f 01 c1 	mcall	80003d8c <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
8000368e:	fe f8 06 ca 	ld.w	r8,pc[1738]
80003692:	70 0c       	ld.w	r12,r8[0x0]
80003694:	f0 1f 01 ab 	mcall	80003d40 <phy_rx_func+0xe98>
80003698:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
8000369a:	c0 71       	brne	800036a8 <phy_rx_func+0x800>
								{
									RxMediaState = WAITINGABAB;
8000369c:	30 09       	mov	r9,0
8000369e:	fe f8 06 c6 	ld.w	r8,pc[1734]
800036a2:	91 09       	st.w	r8[0x0],r9
800036a4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800036a8:	fe f9 06 c4 	ld.w	r9,pc[1732]
800036ac:	72 08       	ld.w	r8,r9[0x0]
800036ae:	20 18       	sub	r8,1
800036b0:	93 08       	st.w	r9[0x0],r8
800036b2:	c0 71       	brne	800036c0 <phy_rx_func+0x818>
								RxMediaState = WAITINGABAB;
800036b4:	30 09       	mov	r9,0
800036b6:	fe f8 06 ae 	ld.w	r8,pc[1710]
800036ba:	91 09       	st.w	r8[0x0],r9
800036bc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}		
						
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//3
800036c0:	fe f8 06 c4 	ld.w	r8,pc[1732]
800036c4:	fe f9 06 9c 	ld.w	r9,pc[1692]
800036c8:	72 0a       	ld.w	r10,r9[0x0]
800036ca:	70 09       	ld.w	r9,r8[0x0]
800036cc:	ef 3b 00 0c 	ld.ub	r11,r7[12]
800036d0:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
800036d4:	70 09       	ld.w	r9,r8[0x0]
800036d6:	2f f9       	sub	r9,-1
800036d8:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800036da:	e0 49 01 ff 	cp.w	r9,511
800036de:	e0 88 00 16 	brls	8000370a <phy_rx_func+0x862>
							{
								RxAMBE_IsFillingNext8 = 0;
800036e2:	30 09       	mov	r9,0
800036e4:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
800036e6:	fe f6 06 7a 	ld.w	r6,pc[1658]
800036ea:	6c 0c       	ld.w	r12,r6[0x0]
800036ec:	f0 1f 01 a8 	mcall	80003d8c <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
800036f0:	fe f8 06 68 	ld.w	r8,pc[1640]
800036f4:	70 0c       	ld.w	r12,r8[0x0]
800036f6:	f0 1f 01 93 	mcall	80003d40 <phy_rx_func+0xe98>
800036fa:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
800036fc:	c0 71       	brne	8000370a <phy_rx_func+0x862>
								{
									RxMediaState = WAITINGABAB;
800036fe:	30 09       	mov	r9,0
80003700:	fe f8 06 64 	ld.w	r8,pc[1636]
80003704:	91 09       	st.w	r8[0x0],r9
80003706:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
8000370a:	fe f9 06 62 	ld.w	r9,pc[1634]
8000370e:	72 08       	ld.w	r8,r9[0x0]
80003710:	20 18       	sub	r8,1
80003712:	93 08       	st.w	r9[0x0],r8
80003714:	c0 71       	brne	80003722 <phy_rx_func+0x87a>
								RxMediaState = WAITINGABAB;
80003716:	30 09       	mov	r9,0
80003718:	fe f8 06 4c 	ld.w	r8,pc[1612]
8000371c:	91 09       	st.w	r8[0x0],r9
8000371e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[5];//4
80003722:	fe f8 06 62 	ld.w	r8,pc[1634]
80003726:	fe f9 06 3a 	ld.w	r9,pc[1594]
8000372a:	72 0a       	ld.w	r10,r9[0x0]
8000372c:	70 09       	ld.w	r9,r8[0x0]
8000372e:	ef 3b 00 0d 	ld.ub	r11,r7[13]
80003732:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003736:	70 09       	ld.w	r9,r8[0x0]
80003738:	2f f9       	sub	r9,-1
8000373a:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000373c:	e0 49 01 ff 	cp.w	r9,511
80003740:	e0 88 00 16 	brls	8000376c <phy_rx_func+0x8c4>
							{
								RxAMBE_IsFillingNext8 = 0;
80003744:	30 09       	mov	r9,0
80003746:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003748:	fe f6 06 18 	ld.w	r6,pc[1560]
8000374c:	6c 0c       	ld.w	r12,r6[0x0]
8000374e:	f0 1f 01 90 	mcall	80003d8c <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003752:	fe f8 06 06 	ld.w	r8,pc[1542]
80003756:	70 0c       	ld.w	r12,r8[0x0]
80003758:	f0 1f 01 7a 	mcall	80003d40 <phy_rx_func+0xe98>
8000375c:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
8000375e:	c0 71       	brne	8000376c <phy_rx_func+0x8c4>
								{
									RxMediaState = WAITINGABAB;
80003760:	30 09       	mov	r9,0
80003762:	fe f8 06 02 	ld.w	r8,pc[1538]
80003766:	91 09       	st.w	r8[0x0],r9
80003768:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
8000376c:	fe f9 06 00 	ld.w	r9,pc[1536]
80003770:	72 08       	ld.w	r8,r9[0x0]
80003772:	20 18       	sub	r8,1
80003774:	93 08       	st.w	r9[0x0],r8
80003776:	c0 71       	brne	80003784 <phy_rx_func+0x8dc>
								RxMediaState = WAITINGABAB;
80003778:	30 09       	mov	r9,0
8000377a:	fe f8 05 ea 	ld.w	r8,pc[1514]
8000377e:	91 09       	st.w	r8[0x0],r9
80003780:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//5
80003784:	fe f8 06 00 	ld.w	r8,pc[1536]
80003788:	fe f9 05 d8 	ld.w	r9,pc[1496]
8000378c:	72 0a       	ld.w	r10,r9[0x0]
8000378e:	70 09       	ld.w	r9,r8[0x0]
80003790:	ef 3b 00 0e 	ld.ub	r11,r7[14]
80003794:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003798:	70 09       	ld.w	r9,r8[0x0]
8000379a:	2f f9       	sub	r9,-1
8000379c:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000379e:	e0 49 01 ff 	cp.w	r9,511
800037a2:	e0 88 00 16 	brls	800037ce <phy_rx_func+0x926>
							{
								RxAMBE_IsFillingNext8 = 0;
800037a6:	30 09       	mov	r9,0
800037a8:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
800037aa:	fe f6 05 b6 	ld.w	r6,pc[1462]
800037ae:	6c 0c       	ld.w	r12,r6[0x0]
800037b0:	f0 1f 01 77 	mcall	80003d8c <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
800037b4:	fe f8 05 a4 	ld.w	r8,pc[1444]
800037b8:	70 0c       	ld.w	r12,r8[0x0]
800037ba:	f0 1f 01 62 	mcall	80003d40 <phy_rx_func+0xe98>
800037be:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
800037c0:	c0 71       	brne	800037ce <phy_rx_func+0x926>
								{
									RxMediaState = WAITINGABAB;
800037c2:	30 09       	mov	r9,0
800037c4:	fe f8 05 a0 	ld.w	r8,pc[1440]
800037c8:	91 09       	st.w	r8[0x0],r9
800037ca:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800037ce:	fe f9 05 9e 	ld.w	r9,pc[1438]
800037d2:	72 08       	ld.w	r8,r9[0x0]
800037d4:	20 18       	sub	r8,1
800037d6:	93 08       	st.w	r9[0x0],r8
800037d8:	c0 71       	brne	800037e6 <phy_rx_func+0x93e>
								RxMediaState = WAITINGABAB;
800037da:	30 09       	mov	r9,0
800037dc:	fe f8 05 88 	ld.w	r8,pc[1416]
800037e0:	91 09       	st.w	r8[0x0],r9
800037e2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//6
800037e6:	fe f8 05 9e 	ld.w	r8,pc[1438]
800037ea:	fe f9 05 76 	ld.w	r9,pc[1398]
800037ee:	72 0a       	ld.w	r10,r9[0x0]
800037f0:	70 09       	ld.w	r9,r8[0x0]
800037f2:	ef 3b 00 0f 	ld.ub	r11,r7[15]
800037f6:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
800037fa:	70 09       	ld.w	r9,r8[0x0]
800037fc:	2f f9       	sub	r9,-1
800037fe:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003800:	e0 49 01 ff 	cp.w	r9,511
80003804:	e0 88 00 16 	brls	80003830 <phy_rx_func+0x988>
							{
								RxAMBE_IsFillingNext8 = 0;
80003808:	30 09       	mov	r9,0
8000380a:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
8000380c:	fe f7 05 54 	ld.w	r7,pc[1364]
80003810:	6e 0c       	ld.w	r12,r7[0x0]
80003812:	f0 1f 01 5f 	mcall	80003d8c <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003816:	fe f8 05 42 	ld.w	r8,pc[1346]
8000381a:	70 0c       	ld.w	r12,r8[0x0]
8000381c:	f0 1f 01 49 	mcall	80003d40 <phy_rx_func+0xe98>
80003820:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003822:	c0 71       	brne	80003830 <phy_rx_func+0x988>
								{
									RxMediaState = WAITINGABAB;
80003824:	30 09       	mov	r9,0
80003826:	fe f8 05 3e 	ld.w	r8,pc[1342]
8000382a:	91 09       	st.w	r8[0x0],r9
8000382c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003830:	fe f9 05 3c 	ld.w	r9,pc[1340]
80003834:	72 08       	ld.w	r8,r9[0x0]
80003836:	20 18       	sub	r8,1
80003838:	93 08       	st.w	r9[0x0],r8
8000383a:	e0 81 02 74 	brne	80003d22 <phy_rx_func+0xe7a>
								RxMediaState = WAITINGABAB;
8000383e:	30 09       	mov	r9,0
80003840:	fe f8 05 24 	ld.w	r8,pc[1316]
80003844:	91 09       	st.w	r8[0x0],r9
80003846:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							//}
							
						}
						else//error
						{
							RxMediaState = WAITINGABAB;
8000384a:	30 09       	mov	r9,0
8000384c:	fe f8 05 18 	ld.w	r8,pc[1304]
80003850:	91 09       	st.w	r8[0x0],r9
80003852:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
					}
					else if (Item_ID == Post_Voice_Encoder_Data)//(bit48~Pad-bits)
80003856:	fe f8 05 26 	ld.w	r8,pc[1318]
8000385a:	11 89       	ld.ub	r9,r8[0x0]
8000385c:	3f 28       	mov	r8,-14
8000385e:	f0 09 18 00 	cp.b	r9,r8
80003862:	c4 31       	brne	800038e8 <phy_rx_func+0xa40>
					{
					
						AMBEBurst_rawdata[3] = payload_rx_channel->word[0];//(bit48~Pad-bits)
80003864:	8e 49       	ld.sh	r9,r7[0x8]
80003866:	fe f8 05 56 	ld.w	r8,pc[1366]
8000386a:	b0 39       	st.h	r8[0x6],r9
						//AMBE_Per_Burst_Flag = 1;
						
						//根据MOTO.bit文件数据分布，建议测试pad-bits的最后一个字节不保存。
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//7
8000386c:	fe f8 05 18 	ld.w	r8,pc[1304]
80003870:	fe f9 04 f0 	ld.w	r9,pc[1264]
80003874:	72 0a       	ld.w	r10,r9[0x0]
80003876:	70 09       	ld.w	r9,r8[0x0]
80003878:	ef 3b 00 08 	ld.ub	r11,r7[8]
8000387c:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003880:	70 09       	ld.w	r9,r8[0x0]
80003882:	2f f9       	sub	r9,-1
80003884:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003886:	e0 49 01 ff 	cp.w	r9,511
8000388a:	e0 88 00 16 	brls	800038b6 <phy_rx_func+0xa0e>
						{
							RxAMBE_IsFillingNext8 = 0;
8000388e:	30 09       	mov	r9,0
80003890:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003892:	fe f7 04 ce 	ld.w	r7,pc[1230]
80003896:	6e 0c       	ld.w	r12,r7[0x0]
80003898:	f0 1f 01 3d 	mcall	80003d8c <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
8000389c:	fe f8 04 bc 	ld.w	r8,pc[1212]
800038a0:	70 0c       	ld.w	r12,r8[0x0]
800038a2:	f0 1f 01 28 	mcall	80003d40 <phy_rx_func+0xe98>
800038a6:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
800038a8:	c0 71       	brne	800038b6 <phy_rx_func+0xa0e>
							{
								RxMediaState = WAITINGABAB;
800038aa:	30 09       	mov	r9,0
800038ac:	fe f8 04 b8 	ld.w	r8,pc[1208]
800038b0:	91 09       	st.w	r8[0x0],r9
800038b2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
800038b6:	fe f9 04 b6 	ld.w	r9,pc[1206]
800038ba:	72 08       	ld.w	r8,r9[0x0]
800038bc:	20 18       	sub	r8,1
800038be:	93 08       	st.w	r9[0x0],r8
800038c0:	c0 71       	brne	800038ce <phy_rx_func+0xa26>
							RxMediaState = WAITINGABAB;
800038c2:	30 09       	mov	r9,0
800038c4:	fe f8 04 a0 	ld.w	r8,pc[1184]
800038c8:	91 09       	st.w	r8[0x0],r9
800038ca:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
						if ((RxBytesWaiting -= 1) <= 0){//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
800038ce:	20 18       	sub	r8,1
800038d0:	fe f9 04 9c 	ld.w	r9,pc[1180]
800038d4:	93 08       	st.w	r9[0x0],r8
800038d6:	58 08       	cp.w	r8,0
800038d8:	e0 81 02 25 	brne	80003d22 <phy_rx_func+0xe7a>
							RxMediaState = WAITINGABAB;
800038dc:	30 09       	mov	r9,0
800038de:	fe f8 04 86 	ld.w	r8,pc[1158]
800038e2:	91 09       	st.w	r8[0x0],r9
800038e4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
								
					}
					else if (Item_ID == Pre_Voice_Decoder_Data)//bit16~bit63
800038e8:	fe f8 04 94 	ld.w	r8,pc[1172]
800038ec:	11 89       	ld.ub	r9,r8[0x0]
800038ee:	3f 38       	mov	r8,-13
800038f0:	f0 09 18 00 	cp.b	r9,r8
800038f4:	e0 81 01 0c 	brne	80003b0c <phy_rx_func+0xc64>
					{
						//接收方的解压类型数据
						//For looping back to Radio
						AMBEBurst_rawdata[1] = payload_rx_channel->word[0];
800038f8:	8e 49       	ld.sh	r9,r7[0x8]
800038fa:	fe f8 04 c2 	ld.w	r8,pc[1218]
800038fe:	b0 19       	st.h	r8[0x2],r9
						AMBEBurst_rawdata[2] = payload_rx_channel->word[1];
80003900:	8e 59       	ld.sh	r9,r7[0xa]
80003902:	b0 29       	st.h	r8[0x4],r9
						AMBEBurst_rawdata[3] = payload_rx_channel->word[2];
80003904:	8e 69       	ld.sh	r9,r7[0xc]
80003906:	b0 39       	st.h	r8[0x6],r9
						//if((m_RxBurstType == VOICEBURST_A) && (VF_SN == 1))
						//logFromISR("\n\r Pre_rx:%X\n\r", payload_rx_channel->word[2]);
						
						//To be tested. Also locally stored RAW-AMBER-DATA
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//3
80003908:	fe f8 04 7c 	ld.w	r8,pc[1148]
8000390c:	fe f9 04 54 	ld.w	r9,pc[1108]
80003910:	72 0a       	ld.w	r10,r9[0x0]
80003912:	70 09       	ld.w	r9,r8[0x0]
80003914:	ef 3b 00 08 	ld.ub	r11,r7[8]
80003918:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
8000391c:	70 09       	ld.w	r9,r8[0x0]
8000391e:	2f f9       	sub	r9,-1
80003920:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003922:	e0 49 01 ff 	cp.w	r9,511
80003926:	e0 88 00 16 	brls	80003952 <phy_rx_func+0xaaa>
						{
							RxAMBE_IsFillingNext8 = 0;
8000392a:	30 09       	mov	r9,0
8000392c:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
8000392e:	fe f6 04 32 	ld.w	r6,pc[1074]
80003932:	6c 0c       	ld.w	r12,r6[0x0]
80003934:	f0 1f 01 16 	mcall	80003d8c <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003938:	fe f8 04 20 	ld.w	r8,pc[1056]
8000393c:	70 0c       	ld.w	r12,r8[0x0]
8000393e:	f0 1f 01 01 	mcall	80003d40 <phy_rx_func+0xe98>
80003942:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003944:	c0 71       	brne	80003952 <phy_rx_func+0xaaa>
							{
								RxMediaState = WAITINGABAB;
80003946:	30 09       	mov	r9,0
80003948:	fe f8 04 1c 	ld.w	r8,pc[1052]
8000394c:	91 09       	st.w	r8[0x0],r9
8000394e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003952:	fe f9 04 1a 	ld.w	r9,pc[1050]
80003956:	72 08       	ld.w	r8,r9[0x0]
80003958:	20 18       	sub	r8,1
8000395a:	93 08       	st.w	r9[0x0],r8
8000395c:	c0 71       	brne	8000396a <phy_rx_func+0xac2>
							RxMediaState = WAITINGABAB;
8000395e:	30 09       	mov	r9,0
80003960:	fe f8 04 04 	ld.w	r8,pc[1028]
80003964:	91 09       	st.w	r8[0x0],r9
80003966:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[1];//4
8000396a:	fe f8 04 1a 	ld.w	r8,pc[1050]
8000396e:	fe f9 03 f2 	ld.w	r9,pc[1010]
80003972:	72 0a       	ld.w	r10,r9[0x0]
80003974:	70 09       	ld.w	r9,r8[0x0]
80003976:	ef 3b 00 09 	ld.ub	r11,r7[9]
8000397a:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
8000397e:	70 09       	ld.w	r9,r8[0x0]
80003980:	2f f9       	sub	r9,-1
80003982:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003984:	e0 49 01 ff 	cp.w	r9,511
80003988:	e0 88 00 16 	brls	800039b4 <phy_rx_func+0xb0c>
						{
							RxAMBE_IsFillingNext8 = 0;
8000398c:	30 09       	mov	r9,0
8000398e:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003990:	fe f6 03 d0 	ld.w	r6,pc[976]
80003994:	6c 0c       	ld.w	r12,r6[0x0]
80003996:	f0 1f 00 fe 	mcall	80003d8c <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
8000399a:	fe f8 03 be 	ld.w	r8,pc[958]
8000399e:	70 0c       	ld.w	r12,r8[0x0]
800039a0:	f0 1f 00 e8 	mcall	80003d40 <phy_rx_func+0xe98>
800039a4:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
800039a6:	c0 71       	brne	800039b4 <phy_rx_func+0xb0c>
							{
								RxMediaState = WAITINGABAB;
800039a8:	30 09       	mov	r9,0
800039aa:	fe f8 03 ba 	ld.w	r8,pc[954]
800039ae:	91 09       	st.w	r8[0x0],r9
800039b0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
800039b4:	fe f9 03 b8 	ld.w	r9,pc[952]
800039b8:	72 08       	ld.w	r8,r9[0x0]
800039ba:	20 18       	sub	r8,1
800039bc:	93 08       	st.w	r9[0x0],r8
800039be:	c0 71       	brne	800039cc <phy_rx_func+0xb24>
							RxMediaState = WAITINGABAB;
800039c0:	30 09       	mov	r9,0
800039c2:	fe f8 03 a2 	ld.w	r8,pc[930]
800039c6:	91 09       	st.w	r8[0x0],r9
800039c8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//5
800039cc:	fe f8 03 b8 	ld.w	r8,pc[952]
800039d0:	fe f9 03 90 	ld.w	r9,pc[912]
800039d4:	72 0a       	ld.w	r10,r9[0x0]
800039d6:	70 09       	ld.w	r9,r8[0x0]
800039d8:	ef 3b 00 0a 	ld.ub	r11,r7[10]
800039dc:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
800039e0:	70 09       	ld.w	r9,r8[0x0]
800039e2:	2f f9       	sub	r9,-1
800039e4:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800039e6:	e0 49 01 ff 	cp.w	r9,511
800039ea:	e0 88 00 16 	brls	80003a16 <phy_rx_func+0xb6e>
						{
							RxAMBE_IsFillingNext8 = 0;
800039ee:	30 09       	mov	r9,0
800039f0:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
800039f2:	fe f6 03 6e 	ld.w	r6,pc[878]
800039f6:	6c 0c       	ld.w	r12,r6[0x0]
800039f8:	f0 1f 00 e5 	mcall	80003d8c <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
800039fc:	fe f8 03 5c 	ld.w	r8,pc[860]
80003a00:	70 0c       	ld.w	r12,r8[0x0]
80003a02:	f0 1f 00 d0 	mcall	80003d40 <phy_rx_func+0xe98>
80003a06:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003a08:	c0 71       	brne	80003a16 <phy_rx_func+0xb6e>
							{
								RxMediaState = WAITINGABAB;
80003a0a:	30 09       	mov	r9,0
80003a0c:	fe f8 03 58 	ld.w	r8,pc[856]
80003a10:	91 09       	st.w	r8[0x0],r9
80003a12:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003a16:	fe f9 03 56 	ld.w	r9,pc[854]
80003a1a:	72 08       	ld.w	r8,r9[0x0]
80003a1c:	20 18       	sub	r8,1
80003a1e:	93 08       	st.w	r9[0x0],r8
80003a20:	c0 71       	brne	80003a2e <phy_rx_func+0xb86>
							RxMediaState = WAITINGABAB;
80003a22:	30 09       	mov	r9,0
80003a24:	fe f8 03 40 	ld.w	r8,pc[832]
80003a28:	91 09       	st.w	r8[0x0],r9
80003a2a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//6
80003a2e:	fe f8 03 56 	ld.w	r8,pc[854]
80003a32:	fe f9 03 2e 	ld.w	r9,pc[814]
80003a36:	72 0a       	ld.w	r10,r9[0x0]
80003a38:	70 09       	ld.w	r9,r8[0x0]
80003a3a:	ef 3b 00 0b 	ld.ub	r11,r7[11]
80003a3e:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003a42:	70 09       	ld.w	r9,r8[0x0]
80003a44:	2f f9       	sub	r9,-1
80003a46:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003a48:	e0 49 01 ff 	cp.w	r9,511
80003a4c:	e0 88 00 16 	brls	80003a78 <phy_rx_func+0xbd0>
						{
							RxAMBE_IsFillingNext8 = 0;
80003a50:	30 09       	mov	r9,0
80003a52:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003a54:	fe f6 03 0c 	ld.w	r6,pc[780]
80003a58:	6c 0c       	ld.w	r12,r6[0x0]
80003a5a:	f0 1f 00 cd 	mcall	80003d8c <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003a5e:	fe f8 02 fa 	ld.w	r8,pc[762]
80003a62:	70 0c       	ld.w	r12,r8[0x0]
80003a64:	f0 1f 00 b7 	mcall	80003d40 <phy_rx_func+0xe98>
80003a68:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003a6a:	c0 71       	brne	80003a78 <phy_rx_func+0xbd0>
							{
								RxMediaState = WAITINGABAB;
80003a6c:	30 09       	mov	r9,0
80003a6e:	fe f8 02 f6 	ld.w	r8,pc[758]
80003a72:	91 09       	st.w	r8[0x0],r9
80003a74:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003a78:	fe f9 02 f4 	ld.w	r9,pc[756]
80003a7c:	72 08       	ld.w	r8,r9[0x0]
80003a7e:	20 18       	sub	r8,1
80003a80:	93 08       	st.w	r9[0x0],r8
80003a82:	c0 71       	brne	80003a90 <phy_rx_func+0xbe8>
							RxMediaState = WAITINGABAB;
80003a84:	30 09       	mov	r9,0
80003a86:	fe f8 02 de 	ld.w	r8,pc[734]
80003a8a:	91 09       	st.w	r8[0x0],r9
80003a8c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//7
80003a90:	fe f8 02 f4 	ld.w	r8,pc[756]
80003a94:	fe f9 02 cc 	ld.w	r9,pc[716]
80003a98:	72 0a       	ld.w	r10,r9[0x0]
80003a9a:	70 09       	ld.w	r9,r8[0x0]
80003a9c:	ef 3b 00 0c 	ld.ub	r11,r7[12]
80003aa0:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003aa4:	70 09       	ld.w	r9,r8[0x0]
80003aa6:	2f f9       	sub	r9,-1
80003aa8:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003aaa:	e0 49 01 ff 	cp.w	r9,511
80003aae:	e0 88 00 16 	brls	80003ada <phy_rx_func+0xc32>
						{
							RxAMBE_IsFillingNext8 = 0;
80003ab2:	30 09       	mov	r9,0
80003ab4:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003ab6:	fe f7 02 aa 	ld.w	r7,pc[682]
80003aba:	6e 0c       	ld.w	r12,r7[0x0]
80003abc:	f0 1f 00 b4 	mcall	80003d8c <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003ac0:	fe f8 02 98 	ld.w	r8,pc[664]
80003ac4:	70 0c       	ld.w	r12,r8[0x0]
80003ac6:	f0 1f 00 9f 	mcall	80003d40 <phy_rx_func+0xe98>
80003aca:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003acc:	c0 71       	brne	80003ada <phy_rx_func+0xc32>
							{
								RxMediaState = WAITINGABAB;
80003ace:	30 09       	mov	r9,0
80003ad0:	fe f8 02 94 	ld.w	r8,pc[660]
80003ad4:	91 09       	st.w	r8[0x0],r9
80003ad6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003ada:	fe f9 02 92 	ld.w	r9,pc[658]
80003ade:	72 08       	ld.w	r8,r9[0x0]
80003ae0:	20 18       	sub	r8,1
80003ae2:	93 08       	st.w	r9[0x0],r8
80003ae4:	c0 71       	brne	80003af2 <phy_rx_func+0xc4a>
							RxMediaState = WAITINGABAB;
80003ae6:	30 09       	mov	r9,0
80003ae8:	fe f8 02 7c 	ld.w	r8,pc[636]
80003aec:	91 09       	st.w	r8[0x0],r9
80003aee:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
						if ((RxBytesWaiting -= 1) <= 0){
80003af2:	20 18       	sub	r8,1
80003af4:	fe f9 02 78 	ld.w	r9,pc[632]
80003af8:	93 08       	st.w	r9[0x0],r8
80003afa:	58 08       	cp.w	r8,0
80003afc:	e0 81 01 13 	brne	80003d22 <phy_rx_func+0xe7a>
							
							//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
							//or discard it to reduce payload size.
							
							RxMediaState = WAITINGABAB;
80003b00:	30 09       	mov	r9,0
80003b02:	fe f8 02 62 	ld.w	r8,pc[610]
80003b06:	91 09       	st.w	r8[0x0],r9
80003b08:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
					}
					else if ((Item_ID == 0x04)  ||  (Item_ID == 0x03))//Unknown type data directly back hair
80003b0c:	fe f8 02 70 	ld.w	r8,pc[624]
80003b10:	11 89       	ld.ub	r9,r8[0x0]
80003b12:	30 48       	mov	r8,4
80003b14:	f0 09 18 00 	cp.b	r9,r8
80003b18:	c0 80       	breq	80003b28 <phy_rx_func+0xc80>
80003b1a:	fe f8 02 62 	ld.w	r8,pc[610]
80003b1e:	11 89       	ld.ub	r9,r8[0x0]
80003b20:	30 38       	mov	r8,3
80003b22:	f0 09 18 00 	cp.b	r9,r8
80003b26:	c1 41       	brne	80003b4e <phy_rx_func+0xca6>
					{
						AMBE_HT[0] = payload_rx_channel->dword[0];
80003b28:	6e 29       	ld.w	r9,r7[0x8]
80003b2a:	fe f8 02 7a 	ld.w	r8,pc[634]
80003b2e:	91 09       	st.w	r8[0x0],r9
						AMBE_HT[1] = payload_rx_channel->dword[1];				
80003b30:	6e 39       	ld.w	r9,r7[0xc]
80003b32:	91 19       	st.w	r8[0x4],r9
						
						if ((RxBytesWaiting -= 8) <= 0)//Consider two cases 0xABCDC014 and 0xABCDC010
80003b34:	fe f9 02 38 	ld.w	r9,pc[568]
80003b38:	72 08       	ld.w	r8,r9[0x0]
80003b3a:	20 88       	sub	r8,8
80003b3c:	93 08       	st.w	r9[0x0],r8
80003b3e:	e0 81 00 f2 	brne	80003d22 <phy_rx_func+0xe7a>
						{
					
							RxBytesWaiting = 0;
80003b42:	93 08       	st.w	r9[0x0],r8
							RxMediaState = WAITINGABAB;
80003b44:	fe f9 02 20 	ld.w	r9,pc[544]
80003b48:	93 08       	st.w	r9[0x0],r8
80003b4a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
						}
						break;

					}
					else if (Item_ID == Soft_Decision_Value)
80003b4e:	fe f8 02 2e 	ld.w	r8,pc[558]
80003b52:	11 89       	ld.ub	r9,r8[0x0]
80003b54:	31 38       	mov	r8,19
80003b56:	f0 09 18 00 	cp.b	r9,r8
80003b5a:	e0 81 00 9c 	brne	80003c92 <phy_rx_func+0xdea>
					{							
						if (SDV_Index == 12)
80003b5e:	fe f8 02 62 	ld.w	r8,pc[610]
80003b62:	11 88       	ld.ub	r8,r8[0x0]
80003b64:	30 c9       	mov	r9,12
80003b66:	f2 08 18 00 	cp.b	r8,r9
80003b6a:	e0 81 00 7b 	brne	80003c60 <phy_rx_func+0xdb8>
						{
							Soft_Decision_Data[SDV_Index]= payload_rx_channel->word[0];
80003b6e:	8e 49       	ld.sh	r9,r7[0x8]
80003b70:	fe f8 02 54 	ld.w	r8,pc[596]
80003b74:	f1 59 00 18 	st.h	r8[24],r9
							
							SDV_Index = 0;
80003b78:	30 09       	mov	r9,0
80003b7a:	fe f8 02 46 	ld.w	r8,pc[582]
80003b7e:	b0 89       	st.b	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003b80:	ef 39 00 0d 	ld.ub	r9,r7[13]
80003b84:	3f 38       	mov	r8,-13
80003b86:	f0 09 18 00 	cp.b	r9,r8
80003b8a:	c6 61       	brne	80003c56 <phy_rx_func+0xdae>
							
							SDV_Index = 0;
								
							if (payload_rx_channel->byte[5] == Pre_Voice_Decoder_Data )//0xF3
							{
									Item_ID = Pre_Voice_Decoder_Data;
80003b8c:	10 99       	mov	r9,r8
80003b8e:	4f c8       	lddpc	r8,80003d7c <phy_rx_func+0xed4>
80003b90:	b0 89       	st.b	r8[0x0],r9
									RxBytesWaiting = (payload_rx_channel->byte[4] & 0x7F);//Test calculations are correct; 8
80003b92:	ef 39 00 0c 	ld.ub	r9,r7[12]
80003b96:	f3 d9 c0 07 	bfextu	r9,r9,0x0,0x7
80003b9a:	4f 58       	lddpc	r8,80003d6c <phy_rx_func+0xec4>
80003b9c:	91 09       	st.w	r8[0x0],r9
									AMBE_rx_flag = 1;//本地作为AMBE数据的解密方
80003b9e:	30 19       	mov	r9,1
80003ba0:	fe f8 02 0c 	ld.w	r8,pc[524]
80003ba4:	b0 89       	st.b	r8[0x0],r9
		
									AMBEBurst_rawdata[0] = payload_rx_channel->word[3];//用于解密的中间数据变量
80003ba6:	8e 79       	ld.sh	r9,r7[0xe]
80003ba8:	fe f8 02 14 	ld.w	r8,pc[532]
80003bac:	b0 09       	st.h	r8[0x0],r9
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//1
80003bae:	4f 68       	lddpc	r8,80003d84 <phy_rx_func+0xedc>
80003bb0:	4e c9       	lddpc	r9,80003d60 <phy_rx_func+0xeb8>
80003bb2:	72 0a       	ld.w	r10,r9[0x0]
80003bb4:	70 09       	ld.w	r9,r8[0x0]
80003bb6:	ef 3b 00 0e 	ld.ub	r11,r7[14]
80003bba:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
80003bbe:	70 09       	ld.w	r9,r8[0x0]
80003bc0:	2f f9       	sub	r9,-1
80003bc2:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003bc4:	e0 49 01 ff 	cp.w	r9,511
80003bc8:	e0 88 00 13 	brls	80003bee <phy_rx_func+0xd46>
									{
										RxAMBE_IsFillingNext8 = 0;
80003bcc:	30 09       	mov	r9,0
80003bce:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
80003bd0:	4e 46       	lddpc	r6,80003d60 <phy_rx_func+0xeb8>
80003bd2:	6c 0c       	ld.w	r12,r6[0x0]
80003bd4:	f0 1f 00 6e 	mcall	80003d8c <phy_rx_func+0xee4>
										AMBE_payload_ptr = get_payload_idle_isr();
80003bd8:	4e 08       	lddpc	r8,80003d58 <phy_rx_func+0xeb0>
80003bda:	70 0c       	ld.w	r12,r8[0x0]
80003bdc:	f0 1f 00 59 	mcall	80003d40 <phy_rx_func+0xe98>
80003be0:	8d 0c       	st.w	r6[0x0],r12
										if(NULL == AMBE_payload_ptr)
80003be2:	c0 61       	brne	80003bee <phy_rx_func+0xd46>
										{
											RxMediaState = WAITINGABAB;
80003be4:	30 09       	mov	r9,0
80003be6:	4e 08       	lddpc	r8,80003d64 <phy_rx_func+0xebc>
80003be8:	91 09       	st.w	r8[0x0],r9
80003bea:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
80003bee:	4e 09       	lddpc	r9,80003d6c <phy_rx_func+0xec4>
80003bf0:	72 08       	ld.w	r8,r9[0x0]
80003bf2:	20 18       	sub	r8,1
80003bf4:	93 08       	st.w	r9[0x0],r8
80003bf6:	c0 61       	brne	80003c02 <phy_rx_func+0xd5a>
										RxMediaState = WAITINGABAB;
80003bf8:	30 09       	mov	r9,0
80003bfa:	4d b8       	lddpc	r8,80003d64 <phy_rx_func+0xebc>
80003bfc:	91 09       	st.w	r8[0x0],r9
80003bfe:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//2
80003c02:	4e 18       	lddpc	r8,80003d84 <phy_rx_func+0xedc>
80003c04:	4d 79       	lddpc	r9,80003d60 <phy_rx_func+0xeb8>
80003c06:	72 0a       	ld.w	r10,r9[0x0]
80003c08:	70 09       	ld.w	r9,r8[0x0]
80003c0a:	ef 3b 00 0f 	ld.ub	r11,r7[15]
80003c0e:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
80003c12:	70 09       	ld.w	r9,r8[0x0]
80003c14:	2f f9       	sub	r9,-1
80003c16:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003c18:	e0 49 01 ff 	cp.w	r9,511
80003c1c:	e0 88 00 13 	brls	80003c42 <phy_rx_func+0xd9a>
									{
										RxAMBE_IsFillingNext8 = 0;
80003c20:	30 09       	mov	r9,0
80003c22:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
80003c24:	4c f7       	lddpc	r7,80003d60 <phy_rx_func+0xeb8>
80003c26:	6e 0c       	ld.w	r12,r7[0x0]
80003c28:	f0 1f 00 59 	mcall	80003d8c <phy_rx_func+0xee4>
										AMBE_payload_ptr = get_payload_idle_isr();
80003c2c:	4c b8       	lddpc	r8,80003d58 <phy_rx_func+0xeb0>
80003c2e:	70 0c       	ld.w	r12,r8[0x0]
80003c30:	f0 1f 00 44 	mcall	80003d40 <phy_rx_func+0xe98>
80003c34:	8f 0c       	st.w	r7[0x0],r12
										if(NULL == AMBE_payload_ptr)
80003c36:	c0 61       	brne	80003c42 <phy_rx_func+0xd9a>
										{
											RxMediaState = WAITINGABAB;
80003c38:	30 09       	mov	r9,0
80003c3a:	4c b8       	lddpc	r8,80003d64 <phy_rx_func+0xebc>
80003c3c:	91 09       	st.w	r8[0x0],r9
80003c3e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
80003c42:	4c b9       	lddpc	r9,80003d6c <phy_rx_func+0xec4>
80003c44:	72 08       	ld.w	r8,r9[0x0]
80003c46:	20 18       	sub	r8,1
80003c48:	93 08       	st.w	r9[0x0],r8
80003c4a:	c6 c1       	brne	80003d22 <phy_rx_func+0xe7a>
										RxMediaState = WAITINGABAB;
80003c4c:	30 09       	mov	r9,0
80003c4e:	4c 68       	lddpc	r8,80003d64 <phy_rx_func+0xebc>
80003c50:	91 09       	st.w	r8[0x0],r9
80003c52:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
							}
							else
							RxMediaState = WAITINGABAB;
80003c56:	30 09       	mov	r9,0
80003c58:	4c 38       	lddpc	r8,80003d64 <phy_rx_func+0xebc>
80003c5a:	91 09       	st.w	r8[0x0],r9
80003c5c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
						}
						else
						{
									
							Soft_Decision_Data[SDV_Index]	  = payload_rx_channel->word[0];
80003c60:	8e 4a       	ld.sh	r10,r7[0x8]
80003c62:	4d 99       	lddpc	r9,80003dc4 <phy_rx_func+0xf1c>
80003c64:	f2 08 0a 1a 	st.h	r9[r8<<0x1],r10
							Soft_Decision_Data[SDV_Index+1]	  = payload_rx_channel->word[1];
80003c68:	4d 6a       	lddpc	r10,80003dc0 <phy_rx_func+0xf18>
80003c6a:	15 88       	ld.ub	r8,r10[0x0]
80003c6c:	f0 cb ff ff 	sub	r11,r8,-1
80003c70:	8e 5c       	ld.sh	r12,r7[0xa]
80003c72:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+2]	  = payload_rx_channel->word[2];
80003c76:	f0 cb ff fe 	sub	r11,r8,-2
80003c7a:	8e 6c       	ld.sh	r12,r7[0xc]
80003c7c:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+3]	  = payload_rx_channel->word[3];
80003c80:	f0 cb ff fd 	sub	r11,r8,-3
80003c84:	8e 7c       	ld.sh	r12,r7[0xe]
80003c86:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							SDV_Index +=4;
80003c8a:	2f c8       	sub	r8,-4
80003c8c:	b4 88       	st.b	r10[0x0],r8
80003c8e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					
					else
					{
						
						RxMediaState  = WAITINGABAB;
80003c92:	30 09       	mov	r9,0
80003c94:	4b 48       	lddpc	r8,80003d64 <phy_rx_func+0xebc>
80003c96:	91 09       	st.w	r8[0x0],r9
80003c98:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
		break;//End of READING_AMBE_MEDIA.

        case READING_AMBE_AUX:
			
				Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[0];
80003c9c:	4c 08       	lddpc	r8,80003d9c <phy_rx_func+0xef4>
80003c9e:	70 09       	ld.w	r9,r8[0x0]
80003ca0:	8e 4b       	ld.sh	r11,r7[0x8]
80003ca2:	4c 0a       	lddpc	r10,80003da0 <phy_rx_func+0xef8>
80003ca4:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
				RxData_IsFillingNext16 += 1;
80003ca8:	2f f9       	sub	r9,-1
80003caa:	91 09       	st.w	r8[0x0],r9
			
				if ((Item_Length -= 2) <= 0)
80003cac:	4b 58       	lddpc	r8,80003d80 <phy_rx_func+0xed8>
80003cae:	70 09       	ld.w	r9,r8[0x0]
80003cb0:	20 29       	sub	r9,2
80003cb2:	91 09       	st.w	r8[0x0],r9
80003cb4:	70 08       	ld.w	r8,r8[0x0]
80003cb6:	58 08       	cp.w	r8,0
80003cb8:	c2 f1       	brne	80003d16 <phy_rx_func+0xe6e>
				{
					RxData_IsFillingNext16 = 0;
80003cba:	30 09       	mov	r9,0
80003cbc:	4b 88       	lddpc	r8,80003d9c <phy_rx_func+0xef4>
80003cbe:	91 09       	st.w	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003cc0:	8e 59       	ld.sh	r9,r7[0xa]
80003cc2:	fe 78 82 12 	mov	r8,-32238
80003cc6:	f0 09 19 00 	cp.h	r9,r8
80003cca:	c2 11       	brne	80003d0c <phy_rx_func+0xe64>
					{
						//Item_ID = Vocoder_Bit_Stream_Parameter;
						//Vocoder Bits Stream Parameter
						//Its value ranges from 1 to 18 for one voice superframe contains 6 voice bursts
						// and each burst contains 3 VFs.
						VF_SN = (payload_rx_channel->byte[5] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
80003ccc:	ef 3c 00 0d 	ld.ub	r12,r7[13]
80003cd0:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
80003cd4:	4a f8       	lddpc	r8,80003d90 <phy_rx_func+0xee8>
80003cd6:	b0 8c       	st.b	r8[0x0],r12
							
						VBSP_data[0] = payload_rx_channel->word[1];
80003cd8:	8e 59       	ld.sh	r9,r7[0xa]
80003cda:	4a f8       	lddpc	r8,80003d94 <phy_rx_func+0xeec>
80003cdc:	b0 09       	st.h	r8[0x0],r9
						VBSP_data[1] = payload_rx_channel->word[2];
80003cde:	8e 69       	ld.sh	r9,r7[0xc]
80003ce0:	b0 19       	st.h	r8[0x2],r9
							
						m_RxBurstType = CalculateBurst(VF_SN);
80003ce2:	f0 1f 00 2e 	mcall	80003d98 <phy_rx_func+0xef0>
80003ce6:	4a 18       	lddpc	r8,80003d68 <phy_rx_func+0xec0>
80003ce8:	91 0c       	st.w	r8[0x0],r12
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003cea:	ef 39 00 0f 	ld.ub	r9,r7[15]
80003cee:	31 38       	mov	r8,19
80003cf0:	f0 09 18 00 	cp.b	r9,r8
80003cf4:	c0 71       	brne	80003d02 <phy_rx_func+0xe5a>
							
						m_RxBurstType = CalculateBurst(VF_SN);
						
						if (payload_rx_channel->byte[7] == Soft_Decision_Value)//0x13
						{
							Item_ID = Soft_Decision_Value;	
80003cf6:	10 99       	mov	r9,r8
80003cf8:	4a 18       	lddpc	r8,80003d7c <phy_rx_func+0xed4>
80003cfa:	b0 89       	st.b	r8[0x0],r9
							RxBytesWaiting = ((payload_rx_channel->dword[1] & 0x00007F00) >>24);//Test calculations are correct; 26
80003cfc:	30 09       	mov	r9,0
80003cfe:	49 c8       	lddpc	r8,80003d6c <phy_rx_func+0xec4>
80003d00:	91 09       	st.w	r8[0x0],r9
						else
						{//error
								RxMediaState = WAITINGABAB;//Jump
						}
							
						RxMediaState = READING_AMBE_MEDIA;//Jump
80003d02:	30 49       	mov	r9,4
80003d04:	49 88       	lddpc	r8,80003d64 <phy_rx_func+0xebc>
80003d06:	91 09       	st.w	r8[0x0],r9
80003d08:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					else
					{
						RxMediaState = WAITINGABAB;//Jump
80003d0c:	30 09       	mov	r9,0
80003d0e:	49 68       	lddpc	r8,80003d64 <phy_rx_func+0xebc>
80003d10:	91 09       	st.w	r8[0x0],r9
80003d12:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}

				}
				else
				{//测试看看是几个字节数据
					logFromISR("\n\r Radio Internal parameter length error \n\r");
80003d16:	4a dc       	lddpc	r12,80003dc8 <phy_rx_func+0xf20>
80003d18:	f0 1f 00 18 	mcall	80003d78 <phy_rx_func+0xed0>
					RxMediaState = WAITINGABAB;//Jump
80003d1c:	30 09       	mov	r9,0
80003d1e:	49 28       	lddpc	r8,80003d64 <phy_rx_func+0xebc>
80003d20:	91 09       	st.w	r8[0x0],r9
80003d22:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80003d26:	00 00       	add	r0,r0
80003d28:	00 00       	add	r0,r0
80003d2a:	0a b8       	st.h	r5++,r8
80003d2c:	00 00       	add	r0,r0
80003d2e:	0a d0       	st.w	--r5,r0
80003d30:	00 00       	add	r0,r0
80003d32:	0a b0       	st.h	r5++,r0
80003d34:	00 00       	add	r0,r0
80003d36:	0a 92       	mov	r2,r5
80003d38:	00 00       	add	r0,r0
80003d3a:	0a 80       	andn	r0,r5
80003d3c:	00 00       	add	r0,r0
80003d3e:	0a a8       	st.w	r5++,r8
80003d40:	80 00       	ld.sh	r0,r0[0x0]
80003d42:	2d 30       	sub	r0,-45
80003d44:	00 00       	add	r0,r0
80003d46:	0a a0       	st.w	r5++,r0
80003d48:	80 00       	ld.sh	r0,r0[0x0]
80003d4a:	2c 48       	sub	r8,-60
80003d4c:	00 00       	add	r0,r0
80003d4e:	0a b4       	st.h	r5++,r4
80003d50:	80 00       	ld.sh	r0,r0[0x0]
80003d52:	2c 7c       	sub	r12,-57
80003d54:	00 00       	add	r0,r0
80003d56:	0a 91       	mov	r1,r5
80003d58:	00 00       	add	r0,r0
80003d5a:	0a ac       	st.w	r5++,r12
80003d5c:	00 00       	add	r0,r0
80003d5e:	0a bc       	st.h	r5++,r12
80003d60:	00 00       	add	r0,r0
80003d62:	0a 94       	mov	r4,r5
80003d64:	00 00       	add	r0,r0
80003d66:	0a dc       	st.w	--r5,r12
80003d68:	00 00       	add	r0,r0
80003d6a:	0a c4       	st.b	r5++,r4
80003d6c:	00 00       	add	r0,r0
80003d6e:	0a 7c       	tst	r12,r5
80003d70:	00 00       	add	r0,r0
80003d72:	0a 50       	eor	r0,r5
80003d74:	80 00       	ld.sh	r0,r0[0x0]
80003d76:	d8 04       	*unknown*
80003d78:	80 00       	ld.sh	r0,r0[0x0]
80003d7a:	71 d4       	ld.w	r4,r8[0x74]
80003d7c:	00 00       	add	r0,r0
80003d7e:	0a 90       	mov	r0,r5
80003d80:	00 00       	add	r0,r0
80003d82:	0a e8       	st.h	--r5,r8
80003d84:	00 00       	add	r0,r0
80003d86:	0a c8       	st.b	r5++,r8
80003d88:	80 00       	ld.sh	r0,r0[0x0]
80003d8a:	7a 0c       	ld.w	r12,sp[0x0]
80003d8c:	80 00       	ld.sh	r0,r0[0x0]
80003d8e:	2c 64       	sub	r4,-58
80003d90:	00 00       	add	r0,r0
80003d92:	0a 62       	and	r2,r5
80003d94:	00 00       	add	r0,r0
80003d96:	1e b4       	st.h	pc++,r4
80003d98:	80 00       	ld.sh	r0,r0[0x0]
80003d9a:	2c 18       	sub	r8,-63
80003d9c:	00 00       	add	r0,r0
80003d9e:	0a 84       	andn	r4,r5
80003da0:	00 00       	add	r0,r0
80003da2:	1d b8       	ld.ub	r8,lr[0x3]
80003da4:	00 00       	add	r0,r0
80003da6:	0a 88       	andn	r8,r5
80003da8:	00 00       	add	r0,r0
80003daa:	0a 48       	or	r8,r5
80003dac:	00 00       	add	r0,r0
80003dae:	0a 42       	or	r2,r5
80003db0:	00 00       	add	r0,r0
80003db2:	0a e0       	st.h	--r5,r0
80003db4:	00 00       	add	r0,r0
80003db6:	0a 9c       	mov	r12,r5
80003db8:	00 00       	add	r0,r0
80003dba:	0a 68       	and	r8,r5
80003dbc:	00 00       	add	r0,r0
80003dbe:	1d b0       	ld.ub	r0,lr[0x3]
80003dc0:	00 00       	add	r0,r0
80003dc2:	0a d4       	st.w	--r5,r4
80003dc4:	00 00       	add	r0,r0
80003dc6:	1e b8       	st.h	pc++,r8
80003dc8:	80 00       	ld.sh	r0,r0[0x0]
80003dca:	d8 1c       	*unknown*

80003dcc <pdca_int_handler>:
    void (*phy_rx_exec)(void *)--callback function for receive SSC data 
Called By: interrupt
*/
__attribute__((__interrupt__))
static void pdca_int_handler(void)
{
80003dcc:	d4 01       	pushm	lr
	//xHigherPriorityTaskWoken = pdFALSE;
	
	static U32 count=0;
	//intStartCount = Get_system_register(AVR32_COUNT);
	
	count++;
80003dce:	49 a8       	lddpc	r8,80003e34 <pdca_int_handler+0x68>
80003dd0:	70 09       	ld.w	r9,r8[0x0]
80003dd2:	2f f9       	sub	r9,-1
80003dd4:	91 09       	st.w	r8[0x0],r9
	/*Toggle Index*/
    BufferIndex ^= 0x01;
80003dd6:	49 98       	lddpc	r8,80003e38 <pdca_int_handler+0x6c>
80003dd8:	11 89       	ld.ub	r9,r8[0x0]
80003dda:	ec 19 00 01 	eorl	r9,0x1
80003dde:	b0 89       	st.b	r8[0x0],r9
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);
80003de0:	11 89       	ld.ub	r9,r8[0x0]
80003de2:	a5 69       	lsl	r9,0x4
80003de4:	2f c9       	sub	r9,-4
80003de6:	49 6a       	lddpc	r10,80003e3c <pdca_int_handler+0x70>
80003de8:	14 09       	add	r9,r10
	count++;
	/*Toggle Index*/
    BufferIndex ^= 0x01;
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
80003dea:	fe 7a 00 40 	mov	r10,-65472
80003dee:	95 39       	st.w	r10[0xc],r9
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80003df0:	30 39       	mov	r9,3
80003df2:	95 49       	st.w	r10[0x10],r9

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);
80003df4:	11 8a       	ld.ub	r10,r8[0x0]
80003df6:	a5 6a       	lsl	r10,0x4
80003df8:	2f ca       	sub	r10,-4
80003dfa:	49 28       	lddpc	r8,80003e40 <pdca_int_handler+0x74>
80003dfc:	10 0a       	add	r10,r8
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
80003dfe:	fe 78 00 00 	mov	r8,-65536
80003e02:	91 3a       	st.w	r8[0xc],r10
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80003e04:	91 49       	st.w	r8[0x10],r9
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr;
80003e06:	70 b8       	ld.w	r8,r8[0x2c]
	
	/*receive SSC data*/
    if(phy_rx_exec != NULL)phy_rx_exec((void *)&RxBuffer[BufferIndex]);
80003e08:	48 f8       	lddpc	r8,80003e44 <pdca_int_handler+0x78>
80003e0a:	70 08       	ld.w	r8,r8[0x0]
80003e0c:	58 08       	cp.w	r8,0
80003e0e:	c0 70       	breq	80003e1c <pdca_int_handler+0x50>
80003e10:	48 a9       	lddpc	r9,80003e38 <pdca_int_handler+0x6c>
80003e12:	13 89       	ld.ub	r9,r9[0x0]
80003e14:	a5 69       	lsl	r9,0x4
80003e16:	48 bc       	lddpc	r12,80003e40 <pdca_int_handler+0x74>
80003e18:	12 0c       	add	r12,r9
80003e1a:	5d 18       	icall	r8

    /*transmit SSC data*/

	if(phy_tx_exec != NULL)phy_tx_exec((void *)&TxBuffer[BufferIndex]);//phy_tx_func, phy_rx_func
80003e1c:	48 b8       	lddpc	r8,80003e48 <pdca_int_handler+0x7c>
80003e1e:	70 08       	ld.w	r8,r8[0x0]
80003e20:	58 08       	cp.w	r8,0
80003e22:	c0 70       	breq	80003e30 <pdca_int_handler+0x64>
80003e24:	48 59       	lddpc	r9,80003e38 <pdca_int_handler+0x6c>
80003e26:	13 89       	ld.ub	r9,r9[0x0]
80003e28:	a5 69       	lsl	r9,0x4
80003e2a:	48 5c       	lddpc	r12,80003e3c <pdca_int_handler+0x70>
80003e2c:	12 0c       	add	r12,r9
80003e2e:	5d 18       	icall	r8

	
	//intDuration = Get_system_register(AVR32_COUNT) - intStartCount;
	
	
}/*End of pdca_int_handler.*/
80003e30:	d4 02       	popm	lr
80003e32:	d6 03       	rete
80003e34:	00 00       	add	r0,r0
80003e36:	0a f0       	st.b	--r5,r0
80003e38:	00 00       	add	r0,r0
80003e3a:	96 d8       	ld.uh	r8,r11[0xa]
80003e3c:	00 00       	add	r0,r0
80003e3e:	97 00       	st.w	r11[0x0],r0
80003e40:	00 00       	add	r0,r0
80003e42:	96 e0       	ld.uh	r0,r11[0xc]
80003e44:	00 00       	add	r0,r0
80003e46:	0a ec       	st.h	--r5,r12
80003e48:	00 00       	add	r0,r0
80003e4a:	0a f4       	st.b	--r5,r4

80003e4c <local_start_SSC>:
void local_start_SSC(void)
{
    /*Assign GPIO to SSC.
    gpio_enable_module
    gpio_enable_module_pin*/
    AVR32_GPIO.port[1].pmr0c = 0x00000DC0;
80003e4c:	fe 78 10 00 	mov	r8,-61440
80003e50:	e0 69 0d c0 	mov	r9,3520
80003e54:	f1 49 01 18 	st.w	r8[280],r9
    AVR32_GPIO.port[1].pmr1c = 0x00000DC0;
80003e58:	f1 49 01 28 	st.w	r8[296],r9
    AVR32_GPIO.port[1].gperc = 0x00000DC0;
80003e5c:	f1 49 01 08 	st.w	r8[264],r9

    /*Software reset SSC*/
    (&AVR32_SSC)->cr = AVR32_SSC_CR_SWRST_MASK;
80003e60:	fe 78 34 00 	mov	r8,-52224
80003e64:	e0 69 80 00 	mov	r9,32768
80003e68:	91 09       	st.w	r8[0x0],r9
    (&AVR32_SSC)->cmr 
80003e6a:	30 09       	mov	r9,0
80003e6c:	91 19       	st.w	r8[0x4],r9
                     = AVR32_SSC_CMR_DIV_NOT_ACTIVE << AVR32_SSC_CMR_DIV_OFFSET;

    /*For Slave*/
    (&AVR32_SSC)->tcmr =
80003e6e:	e0 69 04 21 	mov	r9,1057
80003e72:	ea 19 3f 20 	orh	r9,0x3f20
80003e76:	91 69       	st.w	r8[0x18],r9
	      32								<< AVR32_SSC_TCMR_STTDLY_OFFSET	|
	      63								<< AVR32_SSC_TCMR_PERIOD_OFFSET;


    /*For Slave*/
    (&AVR32_SSC)->tfmr = 
80003e78:	e0 69 02 9f 	mov	r9,671
80003e7c:	ea 19 01 00 	orh	r9,0x100
80003e80:	91 79       	st.w	r8[0x1c],r9
	     0									<< AVR32_SSC_TFMR_FSDEN_OFFSET	|
	     1									<< AVR32_SSC_TFMR_FSEDGE_OFFSET;

	/*For Slave*/

	(&AVR32_SSC)->rcmr = 
80003e82:	e0 6a 04 02 	mov	r10,1026
80003e86:	ea 1a 3f 20 	orh	r10,0x3f20
80003e8a:	91 4a       	st.w	r8[0x10],r10
	     0									<< AVR32_SSC_RCMR_STOP_OFFSET	|
	     32									<< AVR32_SSC_RCMR_STTDLY_OFFSET	|
	     63									<< AVR32_SSC_RCMR_PERIOD_OFFSET;

	/*For Slave*/
	(&AVR32_SSC)->rfmr = 
80003e8c:	91 59       	st.w	r8[0x14],r9
	    1									<< AVR32_SSC_RFMR_MSBF_OFFSET	|
	    2									<< AVR32_SSC_RFMR_DATNB_OFFSET	|
	    0									<< AVR32_SSC_RFMR_FSLEN_OFFSET	|
	    AVR32_SSC_RFMR_FSOS_INPUT_ONLY		<< AVR32_SSC_RFMR_FSOS_OFFSET	|
	    1									<< AVR32_SSC_RFMR_FSEDGE_OFFSET;
}/*End of local_start_SSC.*/
80003e8e:	5e fc       	retal	r12

80003e90 <local_start_PDC>:
Function: local_start_PDC
Description: none
Called By: void ssc_init(void) -- ssc.c
*/
void local_start_PDC(void)
{
80003e90:	d4 01       	pushm	lr
    /*Toggle Index*/	
    BufferIndex = 1;
80003e92:	30 19       	mov	r9,1
80003e94:	49 78       	lddpc	r8,80003ef0 <local_start_PDC+0x60>
80003e96:	b0 89       	st.b	r8[0x0],r9
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
80003e98:	fe 78 00 00 	mov	r8,-65536
80003e9c:	30 7b       	mov	r11,7
80003e9e:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
80003ea0:	70 b9       	ld.w	r9,r8[0x2c]
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
80003ea2:	49 59       	lddpc	r9,80003ef4 <local_start_PDC+0x64>
80003ea4:	f2 ca ff fc 	sub	r10,r9,-4
    BufferIndex = 1;
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
80003ea8:	91 0a       	st.w	r8[0x0],r10
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
80003eaa:	30 3a       	mov	r10,3
80003eac:	91 2a       	st.w	r8[0x8],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
80003eae:	30 1c       	mov	r12,1
80003eb0:	91 1c       	st.w	r8[0x4],r12
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
80003eb2:	2e c9       	sub	r9,-20
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
80003eb4:	91 39       	st.w	r8[0xc],r9
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80003eb6:	91 4a       	st.w	r8[0x10],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80003eb8:	30 2c       	mov	r12,2
80003eba:	91 6c       	st.w	r8[0x18],r12

	TxBuffer[0].xnl_channel.dword = XNL_IDLE;
80003ebc:	48 f9       	lddpc	r9,80003ef8 <local_start_PDC+0x68>
80003ebe:	e0 68 5a 5a 	mov	r8,23130
80003ec2:	ea 18 ab cd 	orh	r8,0xabcd
80003ec6:	93 18       	st.w	r9[0x4],r8
	TxBuffer[0].payload_channel.dword[0] = PAYLOADIDLE0;
80003ec8:	93 28       	st.w	r9[0x8],r8
	TxBuffer[0].payload_channel.dword[1] = PAYLOADIDLE1;
80003eca:	30 0e       	mov	lr,0
80003ecc:	93 3e       	st.w	r9[0xc],lr
	TxBuffer[1].xnl_channel.dword = XNL_IDLE;
80003ece:	93 58       	st.w	r9[0x14],r8
	TxBuffer[1].payload_channel.dword[0] = PAYLOADIDLE0;
80003ed0:	93 68       	st.w	r9[0x18],r8
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;
80003ed2:	93 7e       	st.w	r9[0x1c],lr

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
80003ed4:	fe 78 00 40 	mov	r8,-65472
80003ed8:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
80003eda:	70 be       	ld.w	lr,r8[0x2c]
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
80003edc:	f2 ce ff fc 	sub	lr,r9,-4
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
80003ee0:	91 0e       	st.w	r8[0x0],lr
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
80003ee2:	91 2a       	st.w	r8[0x8],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
80003ee4:	91 1b       	st.w	r8[0x4],r11
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
80003ee6:	2e c9       	sub	r9,-20
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
80003ee8:	91 39       	st.w	r8[0xc],r9
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80003eea:	91 4a       	st.w	r8[0x10],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80003eec:	91 6c       	st.w	r8[0x18],r12
}/*End of local_start_PDC.*/
80003eee:	d8 02       	popm	pc
80003ef0:	00 00       	add	r0,r0
80003ef2:	96 d8       	ld.uh	r8,r11[0xa]
80003ef4:	00 00       	add	r0,r0
80003ef6:	96 e0       	ld.uh	r0,r11[0xc]
80003ef8:	00 00       	add	r0,r0
80003efa:	97 00       	st.w	r11[0x0],r0

80003efc <register_rx_tx_func>:
Description: register the rx function(callback function)
Called By: phy_init -- physical.c
*/
void register_rx_tx_func(void (*rx_exec)(void *),  void ( *tx_exec)(void *))
{
	 phy_rx_exec = rx_exec;
80003efc:	48 38       	lddpc	r8,80003f08 <register_rx_tx_func+0xc>
80003efe:	91 0c       	st.w	r8[0x0],r12
	 phy_tx_exec = tx_exec;//phy_tx_func, phy_rx_func
80003f00:	48 38       	lddpc	r8,80003f0c <register_rx_tx_func+0x10>
80003f02:	91 0b       	st.w	r8[0x0],r11
	 
}/*End of register_tx_rx_func.*/
80003f04:	5e fc       	retal	r12
80003f06:	00 00       	add	r0,r0
80003f08:	00 00       	add	r0,r0
80003f0a:	0a ec       	st.h	--r5,r12
80003f0c:	00 00       	add	r0,r0
80003f0e:	0a f4       	st.b	--r5,r4

80003f10 <ssc_init>:
    local_start_SSC -- ssc.c
    local_start_PDC -- ssc.c
Called By: phy_init -- physical.c
*/
void ssc_init(void)
{		
80003f10:	d4 01       	pushm	lr
    /*Set up PB01 to watch FS.*/
    AVR32_GPIO.port[1].oderc = 0x00000002;
80003f12:	fe 78 10 00 	mov	r8,-61440
80003f16:	30 29       	mov	r9,2
80003f18:	f1 49 01 48 	st.w	r8[328],r9
    AVR32_GPIO.port[1].gpers = 0x00000002;
80003f1c:	f1 49 01 04 	st.w	r8[260],r9
	
	Disable_global_interrupt();
80003f20:	d3 03       	ssrf	0x10
	
	INTC_register_interrupt (
80003f22:	30 3a       	mov	r10,3
80003f24:	36 0b       	mov	r11,96
80003f26:	49 4c       	lddpc	r12,80003f74 <ssc_init+0x64>
80003f28:	f0 1f 00 14 	mcall	80003f78 <ssc_init+0x68>
	&pdca_int_handler
	, AVR32_PDCA_IRQ_0 //PDCA_CHANNEL_SSCRX_EXAMPLE = 0
	, AVR32_INTC_INT3 //highest priority.
	);
	
	Enable_global_interrupt();
80003f2c:	d5 03       	csrf	0x10
	
    /*Waits for radio to start making FSYNC.*/
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
80003f2e:	fe 79 10 00 	mov	r9,-61440
80003f32:	f2 f8 01 60 	ld.w	r8,r9[352]
80003f36:	e2 18 00 02 	andl	r8,0x2,COH
80003f3a:	cf c0       	breq	80003f32 <ssc_init+0x22>
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
80003f3c:	fe 79 10 00 	mov	r9,-61440
80003f40:	f2 f8 01 60 	ld.w	r8,r9[352]
80003f44:	e2 18 00 02 	andl	r8,0x2,COH
80003f48:	cf c1       	brne	80003f40 <ssc_init+0x30>
			
	Disable_global_interrupt(); // resume to before
80003f4a:	d3 03       	ssrf	0x10
				
    /*config the SSC*/
    local_start_SSC();
80003f4c:	f0 1f 00 0c 	mcall	80003f7c <ssc_init+0x6c>

    /*config the PDCA*/
    local_start_PDC();
80003f50:	f0 1f 00 0c 	mcall	80003f80 <ssc_init+0x70>
		
    /*Start the SSC Physical Layer.*/

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80003f54:	fe 79 00 00 	mov	r9,-65536
80003f58:	30 18       	mov	r8,1
80003f5a:	93 58       	st.w	r9[0x14],r8
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80003f5c:	fe 7a 00 40 	mov	r10,-65472
80003f60:	95 58       	st.w	r10[0x14],r8
    (&AVR32_SSC)->cr = AVR32_SSC_CR_RXEN_MASK | AVR32_SSC_CR_TXEN_MASK;
80003f62:	e0 6b 01 01 	mov	r11,257
80003f66:	fe 7a 34 00 	mov	r10,-52224
80003f6a:	95 0b       	st.w	r10[0x0],r11
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->ier = AVR32_PDCA_RCZ_MASK;
80003f6c:	93 88       	st.w	r9[0x20],r8
															
	Enable_global_interrupt();
80003f6e:	d5 03       	csrf	0x10
															
}/*End of ssc_init.*/
80003f70:	d8 02       	popm	pc
80003f72:	00 00       	add	r0,r0
80003f74:	80 00       	ld.sh	r0,r0[0x0]
80003f76:	3d cc       	mov	r12,-36
80003f78:	80 00       	ld.sh	r0,r0[0x0]
80003f7a:	56 20       	stdsp	sp[0x188],r0
80003f7c:	80 00       	ld.sh	r0,r0[0x0]
80003f7e:	3e 4c       	mov	r12,-28
80003f80:	80 00       	ld.sh	r0,r0[0x0]
80003f82:	3e 90       	mov	r0,-23

80003f84 <xcmp_register_app_list>:
Calls: 
Called By: app_init -- app.c
*/
void xcmp_register_app_list(void * list)
{
	app_list = (app_exec_t *)list;
80003f84:	48 28       	lddpc	r8,80003f8c <xcmp_register_app_list+0x8>
80003f86:	91 0c       	st.w	r8[0x0],r12
}
80003f88:	5e fc       	retal	r12
80003f8a:	00 00       	add	r0,r0
80003f8c:	00 00       	add	r0,r0
80003f8e:	97 20       	st.w	r11[0x8],r0

80003f90 <xcmp_tx>:
Calls:   
	xnl_tx -- xnl.c
Called By: ...
*/
static void xcmp_tx( xcmp_fragment_t * xcmp, U8 payload_len)
{
80003f90:	eb cd 40 80 	pushm	r7,lr
80003f94:	fa cd 01 00 	sub	sp,sp,256
80003f98:	16 97       	mov	r7,r11
	Length :xnl length + checksum
	= checksum + xnl header + xcmp opcode + xcmp payload
	= 0x02 + 0x0C + 0x02 + xcmp payload
	= 0x10 + xcmp payload
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | ( 0x10 + payload_len);
80003f9a:	16 98       	mov	r8,r11
80003f9c:	2f 08       	sub	r8,-16
80003f9e:	af a8       	sbr	r8,0xe
80003fa0:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE; 
80003fa2:	3f f8       	mov	r8,-1
80003fa4:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG;
80003fa6:	30 b9       	mov	r9,11
80003fa8:	ba 29       	st.h	sp[0x4],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;	
80003faa:	ba 38       	st.h	sp[0x6],r8
	xnl_frame.xnl_header.destination = DEFAULT_VALUE;
80003fac:	ba 48       	st.h	sp[0x8],r8
	xnl_frame.xnl_header.source = DEFAULT_VALUE;	
80003fae:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80003fb0:	ba 68       	st.h	sp[0xc],r8
	
	/*insert xcmp frame data*/
	memcpy(&xnl_frame.xnl_payload.xnl_content_data_msg, xcmp, payload_len + 2);
80003fb2:	f6 ca ff fe 	sub	r10,r11,-2
80003fb6:	18 9b       	mov	r11,r12
80003fb8:	fa cc ff f0 	sub	r12,sp,-16
80003fbc:	f0 1f 00 05 	mcall	80003fd0 <xcmp_tx+0x40>
	xnl_frame.xnl_header.payload_length = payload_len + 2;	
80003fc0:	2f e7       	sub	r7,-2
80003fc2:	ba 77       	st.h	sp[0xe],r7
	
	/* send xnl frame*/	
	xnl_tx(&xnl_frame);
80003fc4:	1a 9c       	mov	r12,sp
80003fc6:	f0 1f 00 04 	mcall	80003fd4 <xcmp_tx+0x44>
}
80003fca:	2c 0d       	sub	sp,-256
80003fcc:	e3 cd 80 80 	ldm	sp++,r7,pc
80003fd0:	80 00       	ld.sh	r0,r0[0x0]
80003fd2:	78 c4       	ld.w	r4,r12[0x30]
80003fd4:	80 00       	ld.sh	r0,r0[0x0]
80003fd6:	45 a8       	lddsp	r8,sp[0x168]

80003fd8 <xcmp_data_session_req>:
Description: send data-session request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_data_session_req(void *message, U16 length, U32 dest)
{
80003fd8:	d4 21       	pushm	r4-r7,lr
80003fda:	fa cd 00 d0 	sub	sp,sp,208
80003fde:	18 94       	mov	r4,r12
80003fe0:	16 97       	mov	r7,r11
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
	
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
	
	if (length > 256)return -1;
80003fe2:	e0 68 01 00 	mov	r8,256
80003fe6:	f0 0b 19 00 	cp.h	r11,r8
80003fea:	e0 8b 00 38 	brhi	8000405a <xcmp_data_session_req+0x82>
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
	
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
80003fee:	fa c5 ff f8 	sub	r5,sp,-8
	//U8 SizeofAddress = Remote_Mototrbo_Address_Size;// 3;//可能会变化
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
80003ff2:	e0 68 04 1d 	mov	r8,1053
80003ff6:	ba 38       	st.h	sp[0x6],r8
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
	
	if (length > 256)return -1;
	
	ptr->Function = Single_Data_Uint;
80003ff8:	30 18       	mov	r8,1
80003ffa:	aa 88       	st.b	r5[0x0],r8
	
	ptr->DataDefinition.Data_Protocol_Version = TMP_Ver_1_1;//0x20
80003ffc:	32 08       	mov	r8,32
80003ffe:	aa 98       	st.b	r5[0x1],r8
	
	ptr->DataDefinition.Dest_Address.Remote_Address_Type = Remote_IPV4_Address;//0x02
80004000:	30 28       	mov	r8,2
80004002:	aa a8       	st.b	r5[0x2],r8
	
	ptr->DataDefinition.Dest_Address.Remote_Address_Size = Remote_IPV4_Address_Size;//0x04
80004004:	30 48       	mov	r8,4
80004006:	aa b8       	st.b	r5[0x3],r8
	
	unsigned int addr = 0x0C000000 | (dest & 0x00FFFFFF);
80004008:	f5 da c0 18 	bfextu	r10,r10,0x0,0x18
8000400c:	ea 1a 0c 00 	orh	r10,0xc00
80004010:	50 0a       	stdsp	sp[0x0],r10
	memcpy(ptr->DataDefinition.Dest_Address.Remote_Address, &addr, Remote_IPV4_Address_Size);
80004012:	30 4a       	mov	r10,4
80004014:	1a 9b       	mov	r11,sp
80004016:	fa cc ff f4 	sub	r12,sp,-12
8000401a:	f0 1f 00 12 	mcall	80004060 <xcmp_data_session_req+0x88>
	//ptr->DataDefinition.Dest_Address.Remote_Address[0] = 0x0C;//12
	//ptr->DataDefinition.Dest_Address.Remote_Address[1] = 0x00;//0
	//ptr->DataDefinition.Dest_Address.Remote_Address[2] = 0x00;//0
	//ptr->DataDefinition.Dest_Address.Remote_Address[3] = 0x02;//2
	
	ptr->DataDefinition.Dest_Address.Remote_Port_Com[0] = (Remote_Port >>8) & 0xFF;//4007
8000401e:	30 f8       	mov	r8,15
80004020:	eb 68 00 08 	st.b	r5[8],r8
	ptr->DataDefinition.Dest_Address.Remote_Port_Com[1] = Remote_Port & 0xFF;//
80004024:	3a 78       	mov	r8,-89
80004026:	eb 68 00 09 	st.b	r5[9],r8
	
    
	ptr->DataPayload.Session_ID_Number = Session_ID;//0x00
8000402a:	30 08       	mov	r8,0
8000402c:	eb 68 00 0a 	st.b	r5[10],r8
	
	ptr->DataPayload.DataPayload_Length[0] =(length >> 8) & 0xFF ;//可能会变化
80004030:	0e 9a       	mov	r10,r7
80004032:	5c 7a       	castu.h	r10
80004034:	f4 08 16 08 	lsr	r8,r10,0x8
80004038:	eb 68 00 0b 	st.b	r5[11],r8
	ptr->DataPayload.DataPayload_Length[1] =length & 0xFF  ;//可能会变化
8000403c:	0e 96       	mov	r6,r7
8000403e:	eb 67 00 0c 	st.b	r5[12],r7
	
	memcpy(&(ptr->DataPayload.DataPayload[0]), message, length);
80004042:	08 9b       	mov	r11,r4
80004044:	fa cc ff eb 	sub	r12,sp,-21
80004048:	f0 1f 00 06 	mcall	80004060 <xcmp_data_session_req+0x88>
	
	xcmp_tx(&xcmp_farme, sizeof(DataSession_req_t) - (256 - length));
8000404c:	ee cb ff f3 	sub	r11,r7,-13
80004050:	5c 5b       	castu.b	r11
80004052:	fa cc ff fa 	sub	r12,sp,-6
80004056:	f0 1f 00 04 	mcall	80004064 <xcmp_data_session_req+0x8c>
}
8000405a:	2c cd       	sub	sp,-208
8000405c:	d8 22       	popm	r4-r7,pc
8000405e:	00 00       	add	r0,r0
80004060:	80 00       	ld.sh	r0,r0[0x0]
80004062:	78 c4       	ld.w	r4,r12[0x30]
80004064:	80 00       	ld.sh	r0,r0[0x0]
80004066:	3f 90       	mov	r0,-7

80004068 <xcmp_DeviceInitializationStatus_request>:
Description: send device initialization status request
Calls: xcmp_tx
Called By:...
*/
void xcmp_DeviceInitializationStatus_request(void)
{
80004068:	d4 01       	pushm	lr
8000406a:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
		
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_BRDCAST | DEVICE_INITIALIZATION_STATUS;
8000406e:	fe 78 b4 00 	mov	r8,-19456
80004072:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	DeviceInitializationStatus_brdcst_t * ptr 
						 = (DeviceInitializationStatus_brdcst_t *)xcmp_farme.u8;
80004074:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*xcmp version 8.1.0.5*///版本号未正确填写，纠正
	ptr->XCMPVersion[0] = XCMP_Version[0];
80004078:	48 c9       	lddpc	r9,800040a8 <xcmp_DeviceInitializationStatus_request+0x40>
8000407a:	13 8a       	ld.ub	r10,r9[0x0]
8000407c:	b0 8a       	st.b	r8[0x0],r10
	ptr->XCMPVersion[1] = XCMP_Version[1];
8000407e:	13 9a       	ld.ub	r10,r9[0x1]
80004080:	b0 9a       	st.b	r8[0x1],r10
	ptr->XCMPVersion[2] = XCMP_Version[2];
80004082:	13 aa       	ld.ub	r10,r9[0x2]
80004084:	b0 aa       	st.b	r8[0x2],r10
	ptr->XCMPVersion[3] = XCMP_Version[3];
80004086:	13 b9       	ld.ub	r9,r9[0x3]
80004088:	b0 b9       	st.b	r8[0x3],r9
	/*
	0x00:
	This is the message that the device sends at power up or after a reset. It 
	will give the initial status and capabilities for the device.
	*/
	ptr->DeviceInitType = 0x00;
8000408a:	30 09       	mov	r9,0
8000408c:	b0 c9       	st.b	r8[0x4],r9
	types of devices may provide a set of services to the radio system, but do 
	not have the ability to be the master.
	
	0x07:OptionBoard,3rd party Option Board-based application.
	*/
	ptr->DeviceStatusInfo.DeviceType = 0x07;
8000408e:	30 7a       	mov	r10,7
80004090:	b0 da       	st.b	r8[0x5],r10
	
	/*Power Up Success, Device has powered up with no errors*/
	ptr->DeviceStatusInfo.DeviceStatus[0] = 0x00;
80004092:	b0 e9       	st.b	r8[0x6],r9
	ptr->DeviceStatusInfo.DeviceStatus[1] = 0x00;
80004094:	b0 f9       	st.b	r8[0x7],r9
	
	/*
	This number is the size of the Device Descriptor data structure with a 
	maximum size not exceeding 255 bytes.
	*/
	ptr->DeviceStatusInfo.DeviceDescriptorSize = 0x00;
80004096:	f1 69 00 08 	st.b	r8[8],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme
8000409a:	30 9b       	mov	r11,9
8000409c:	fa cc ff fe 	sub	r12,sp,-2
800040a0:	f0 1f 00 03 	mcall	800040ac <xcmp_DeviceInitializationStatus_request+0x44>
		, sizeof(DeviceInitializationStatus_brdcst_t) - MAX_DEVICE_DESC_SIZE);
}
800040a4:	2c dd       	sub	sp,-204
800040a6:	d8 02       	popm	pc
800040a8:	00 00       	add	r0,r0
800040aa:	0d 9c       	ld.ub	r12,r6[0x1]
800040ac:	80 00       	ld.sh	r0,r0[0x0]
800040ae:	3f 90       	mov	r0,-7

800040b0 <xcmp_opcode_not_supported>:
Description: register the app list
Calls: xcmp_tx
Called By:...
*/
void xcmp_opcode_not_supported( void )
{
800040b0:	d4 01       	pushm	lr
800040b2:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REPLY;
800040b6:	fe 78 80 00 	mov	r8,-32768
800040ba:	ba 18       	st.h	sp[0x2],r8
	
	/*The radio does not support this opcode.*/
	xcmp_farme.u8[0] = xcmp_Res_Opcode_Not_Supported;
800040bc:	30 38       	mov	r8,3
800040be:	ba c8       	st.b	sp[0x4],r8
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, 1);
800040c0:	30 1b       	mov	r11,1
800040c2:	fa cc ff fe 	sub	r12,sp,-2
800040c6:	f0 1f 00 03 	mcall	800040d0 <xcmp_opcode_not_supported+0x20>
}
800040ca:	2c dd       	sub	sp,-204
800040cc:	d8 02       	popm	pc
800040ce:	00 00       	add	r0,r0
800040d0:	80 00       	ld.sh	r0,r0[0x0]
800040d2:	3f 90       	mov	r0,-7

800040d4 <xcmp_exec_func>:
Description: Perform XCMP corresponding functions
Calls:   
Called By: xcmp_rx_process--task
*/
static void xcmp_exec_func(app_exec_t * exec, xcmp_fragment_t * xcmp)
{
800040d4:	d4 01       	pushm	lr
	/*The message types*/
	switch(xcmp->xcmp_opcode & 0xF000)
800040d6:	96 88       	ld.uh	r8,r11[0x0]
800040d8:	e2 18 f0 00 	andl	r8,0xf000,COH
800040dc:	e0 48 80 00 	cp.w	r8,32768
800040e0:	c0 f0       	breq	800040fe <xcmp_exec_func+0x2a>
800040e2:	e0 48 b0 00 	cp.w	r8,45056
800040e6:	c1 20       	breq	8000410a <xcmp_exec_func+0x36>
800040e8:	58 08       	cp.w	r8,0
800040ea:	c1 51       	brne	80004114 <xcmp_exec_func+0x40>
	{
		case XCMP_REQUEST:
			if(NULL != exec->xcmp_rx_req)
800040ec:	78 08       	ld.w	r8,r12[0x0]
800040ee:	58 08       	cp.w	r8,0
800040f0:	c0 40       	breq	800040f8 <xcmp_exec_func+0x24>
			{
				exec->xcmp_rx_req(xcmp);
800040f2:	16 9c       	mov	r12,r11
800040f4:	5d 18       	icall	r8
800040f6:	d8 02       	popm	pc
			}
			else 
			{
				/*No function to register the request message*/
				/*send not supported opcode to raido */
				xcmp_opcode_not_supported();
800040f8:	f0 1f 00 08 	mcall	80004118 <xcmp_exec_func+0x44>
800040fc:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_REPLY:		
			if(NULL != exec->xcmp_rx_reply)
800040fe:	78 18       	ld.w	r8,r12[0x4]
80004100:	58 08       	cp.w	r8,0
80004102:	c0 90       	breq	80004114 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_reply(xcmp);
80004104:	16 9c       	mov	r12,r11
80004106:	5d 18       	icall	r8
80004108:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_BRDCAST:	
			if(NULL != exec->xcmp_rx_brdcst)
8000410a:	78 28       	ld.w	r8,r12[0x8]
8000410c:	58 08       	cp.w	r8,0
8000410e:	c0 30       	breq	80004114 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_brdcst(xcmp);
80004110:	16 9c       	mov	r12,r11
80004112:	5d 18       	icall	r8
80004114:	d8 02       	popm	pc
80004116:	00 00       	add	r0,r0
80004118:	80 00       	ld.sh	r0,r0[0x0]
8000411a:	40 b0       	lddsp	r0,sp[0x2c]

8000411c <xcmp_IdleTestTone>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_IdleTestTone(U8 type, U16 toneID)
{
8000411c:	d4 01       	pushm	lr
8000411e:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | TONE_CONTROL;
80004122:	e0 68 04 09 	mov	r8,1033
80004126:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	ToneControl_req_t * ptr = (ToneControl_req_t *)xcmp_farme.u8;
80004128:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*Starts the specific tone*/	
	ptr->Function = type;
8000412c:	b0 8c       	st.b	r8[0x0],r12
	
	/*This tone shall be sounded when radio landed on a priority channel*/
	//ptr->ToneIdentifier[0] = (Priority_Beep >> 8) & 0xFF;
	//ptr->ToneIdentifier[1] = Priority_Beep & 0xFF;
	
	ptr->ToneIdentifier[0] = (toneID >> 8) & 0xFF;
8000412e:	f3 db c1 08 	bfextu	r9,r11,0x8,0x8
80004132:	b0 99       	st.b	r8[0x1],r9
	ptr->ToneIdentifier[1] = toneID & 0xFF;	
80004134:	b0 ab       	st.b	r8[0x2],r11
	
	/*
	The alert tone is played according to any rules for alert tones, given the 
	current volume setting. Settings for this field are 8 to 255 (0x08 ?0xFF).
	*/
	ptr->ToneVolumeControl = Current_Volume;
80004136:	30 09       	mov	r9,0
80004138:	b0 b9       	st.b	r8[0x3],r9
	
	/*clear reserved*/
	memset(ptr->Reserved, 0, 8);
8000413a:	fb 69 00 08 	st.b	sp[8],r9
8000413e:	fa c8 ff f7 	sub	r8,sp,-9
80004142:	b0 89       	st.b	r8[0x0],r9
80004144:	fa c8 ff f6 	sub	r8,sp,-10
80004148:	b0 89       	st.b	r8[0x0],r9
8000414a:	fa c8 ff f5 	sub	r8,sp,-11
8000414e:	b0 89       	st.b	r8[0x0],r9
80004150:	fa c8 ff f4 	sub	r8,sp,-12
80004154:	b0 89       	st.b	r8[0x0],r9
80004156:	fa c8 ff f3 	sub	r8,sp,-13
8000415a:	b0 89       	st.b	r8[0x0],r9
8000415c:	fa c8 ff f2 	sub	r8,sp,-14
80004160:	b0 89       	st.b	r8[0x0],r9
80004162:	fa c8 ff f1 	sub	r8,sp,-15
80004166:	b0 89       	st.b	r8[0x0],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(ToneControl_req_t));
80004168:	30 cb       	mov	r11,12
8000416a:	fa cc ff fe 	sub	r12,sp,-2
8000416e:	f0 1f 00 03 	mcall	80004178 <xcmp_IdleTestTone+0x5c>
}
80004172:	2c dd       	sub	sp,-204
80004174:	d8 02       	popm	pc
80004176:	00 00       	add	r0,r0
80004178:	80 00       	ld.sh	r0,r0[0x0]
8000417a:	3f 90       	mov	r0,-7

8000417c <xcmp_init>:
	xQueueCreate -- freertos
	xTaskCreate -- freertos
Called By: main -- main.c
*/
void xcmp_init(void)
{
8000417c:	d4 01       	pushm	lr
	/*register the xcmp function(callback function)*/
	xnl_register_xcmp_func( xcmp_rx );
8000417e:	48 dc       	lddpc	r12,800041b0 <xcmp_init+0x34>
80004180:	f0 1f 00 0d 	mcall	800041b4 <xcmp_init+0x38>
	
	/*initialize the queue*/
	xcmp_frame_rx = xQueueCreate(20, sizeof(xcmp_fragment_t *));
80004184:	30 4b       	mov	r11,4
80004186:	31 4c       	mov	r12,20
80004188:	f0 1f 00 0c 	mcall	800041b8 <xcmp_init+0x3c>
8000418c:	48 c8       	lddpc	r8,800041bc <xcmp_init+0x40>
8000418e:	91 0c       	st.w	r8[0x0],r12
	/*create task*/	
	/*this task is used to execute xcmp message*/
	xTaskCreate(
80004190:	30 09       	mov	r9,0
80004192:	1a d9       	st.w	--sp,r9
80004194:	1a d9       	st.w	--sp,r9
80004196:	1a d9       	st.w	--sp,r9
80004198:	30 38       	mov	r8,3
8000419a:	e0 6a 04 00 	mov	r10,1024
8000419e:	48 9b       	lddpc	r11,800041c0 <xcmp_init+0x44>
800041a0:	48 9c       	lddpc	r12,800041c4 <xcmp_init+0x48>
800041a2:	f0 1f 00 0a 	mcall	800041c8 <xcmp_init+0x4c>
	,  tskXCMP_PRIORITY
	,  NULL
	);
	
	/*initialize the xnl*/
	xnl_init();
800041a6:	f0 1f 00 0a 	mcall	800041cc <xcmp_init+0x50>
800041aa:	2f dd       	sub	sp,-12
	
}
800041ac:	d8 02       	popm	pc
800041ae:	00 00       	add	r0,r0
800041b0:	80 00       	ld.sh	r0,r0[0x0]
800041b2:	42 cc       	lddsp	r12,sp[0xb0]
800041b4:	80 00       	ld.sh	r0,r0[0x0]
800041b6:	43 18       	lddsp	r8,sp[0xc4]
800041b8:	80 00       	ld.sh	r0,r0[0x0]
800041ba:	65 68       	ld.w	r8,r2[0x58]
800041bc:	00 00       	add	r0,r0
800041be:	0b 10       	ld.sh	r0,r5++
800041c0:	80 00       	ld.sh	r0,r0[0x0]
800041c2:	d8 48       	*unknown*
800041c4:	80 00       	ld.sh	r0,r0[0x0]
800041c6:	41 d0       	lddsp	r0,sp[0x74]
800041c8:	80 00       	ld.sh	r0,r0[0x0]
800041ca:	6c 84       	ld.w	r4,r6[0x20]
800041cc:	80 00       	ld.sh	r0,r0[0x0]
800041ce:	43 50       	lddsp	r0,sp[0xd4]

800041d0 <xcmp_rx_process>:
Calls: xQueueReceive -- freerots
	xcmp_exec_func
Called By: task
*/
static void xcmp_rx_process(void * pvParameters)
{
800041d0:	d4 31       	pushm	r0-r7,lr
800041d2:	20 1d       	sub	sp,4
	xcmp_fragment_t * ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
800041d4:	4b 16       	lddpc	r6,80004298 <xcmp_rx_process+0xc8>
800041d6:	30 05       	mov	r5,0
800041d8:	31 44       	mov	r4,20
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
800041da:	4b 13       	lddpc	r3,8000429c <xcmp_rx_process+0xcc>
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
					break;
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
800041dc:	4b 12       	lddpc	r2,800042a0 <xcmp_rx_process+0xd0>
						, ptr);
					break;
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
800041de:	4b 21       	lddpc	r1,800042a4 <xcmp_rx_process+0xd4>
					break;
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
800041e0:	4b 20       	lddpc	r0,800042a8 <xcmp_rx_process+0xd8>
	xcmp_fragment_t * ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
800041e2:	6c 0c       	ld.w	r12,r6[0x0]
800041e4:	0a 99       	mov	r9,r5
800041e6:	08 9a       	mov	r10,r4
800041e8:	1a 9b       	mov	r11,sp
800041ea:	f0 1f 00 31 	mcall	800042ac <xcmp_rx_process+0xdc>
800041ee:	58 1c       	cp.w	r12,1
800041f0:	cf 91       	brne	800041e2 <xcmp_rx_process+0x12>
		{									
			if(NULL == ptr)
800041f2:	40 0b       	lddsp	r11,sp[0x0]
800041f4:	58 0b       	cp.w	r11,0
800041f6:	cf 60       	breq	800041e2 <xcmp_rx_process+0x12>
			
			//log("\n\r R_xcmp : %4x \n\r",ptr->xcmp_opcode);//log:R_xcmp指令	
			//static  portTickType water_value;
			//water_value = uxTaskGetStackHighWaterMark(NULL);
			//log("water_value: %d\n", water_value);			
			switch(ptr->xcmp_opcode & 0x0FFF)
800041f8:	96 0a       	ld.sh	r10,r11[0x0]
800041fa:	f3 da c0 10 	bfextu	r9,r10,0x0,0x10
800041fe:	f1 d9 c0 0c 	bfextu	r8,r9,0x0,0xc
80004202:	59 c8       	cp.w	r8,28
80004204:	c1 e0       	breq	80004240 <xcmp_rx_process+0x70>
80004206:	e0 89 00 07 	brgt	80004214 <xcmp_rx_process+0x44>
8000420a:	58 e8       	cp.w	r8,14
8000420c:	c0 e0       	breq	80004228 <xcmp_rx_process+0x58>
8000420e:	58 f8       	cp.w	r8,15
80004210:	c2 41       	brne	80004258 <xcmp_rx_process+0x88>
80004212:	c0 f8       	rjmp	80004230 <xcmp_rx_process+0x60>
80004214:	e0 48 01 09 	cp.w	r8,265
80004218:	c1 80       	breq	80004248 <xcmp_rx_process+0x78>
8000421a:	e0 48 01 0a 	cp.w	r8,266
8000421e:	c1 90       	breq	80004250 <xcmp_rx_process+0x80>
80004220:	e0 48 00 2c 	cp.w	r8,44
80004224:	c1 a1       	brne	80004258 <xcmp_rx_process+0x88>
80004226:	c0 98       	rjmp	80004238 <xcmp_rx_process+0x68>
			{
				case RADIO_STATUS:				
					xcmp_exec_func(&radio_status, ptr);
80004228:	4a 2c       	lddpc	r12,800042b0 <xcmp_rx_process+0xe0>
8000422a:	f0 1f 00 23 	mcall	800042b4 <xcmp_rx_process+0xe4>
					break;
8000422e:	c2 f8       	rjmp	8000428c <xcmp_rx_process+0xbc>
					
				case VERSION_INFORMATION:
					xcmp_exec_func(&version_information, ptr);
80004230:	4a 2c       	lddpc	r12,800042b8 <xcmp_rx_process+0xe8>
80004232:	f0 1f 00 21 	mcall	800042b4 <xcmp_rx_process+0xe4>
					break;
80004236:	c2 b8       	rjmp	8000428c <xcmp_rx_process+0xbc>
					
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
80004238:	4a 1c       	lddpc	r12,800042bc <xcmp_rx_process+0xec>
8000423a:	f0 1f 00 1f 	mcall	800042b4 <xcmp_rx_process+0xe4>
					break;
8000423e:	c2 78       	rjmp	8000428c <xcmp_rx_process+0xbc>
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
80004240:	04 9c       	mov	r12,r2
80004242:	f0 1f 00 1d 	mcall	800042b4 <xcmp_rx_process+0xe4>
						, ptr);
					break;
80004246:	c2 38       	rjmp	8000428c <xcmp_rx_process+0xbc>
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
80004248:	02 9c       	mov	r12,r1
8000424a:	f0 1f 00 1b 	mcall	800042b4 <xcmp_rx_process+0xe4>
					break;
8000424e:	c1 f8       	rjmp	8000428c <xcmp_rx_process+0xbc>
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
80004250:	00 9c       	mov	r12,r0
80004252:	f0 1f 00 19 	mcall	800042b4 <xcmp_rx_process+0xe4>
					break;
80004256:	c1 b8       	rjmp	8000428c <xcmp_rx_process+0xbc>
					
				default:
				
					/*the xcmp message not in order list*/
					/*over the length of the list*/
					if((0x0400 != (ptr->xcmp_opcode & 0x0400)) 
80004258:	12 98       	mov	r8,r9
8000425a:	e2 18 04 00 	andl	r8,0x400,COH
8000425e:	c0 70       	breq	8000426c <xcmp_rx_process+0x9c>
80004260:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
80004264:	e0 48 00 68 	cp.w	r8,104
80004268:	e0 8a 00 08 	brle	80004278 <xcmp_rx_process+0xa8>
						|| (MAX_APP_FUNC <= (ptr->xcmp_opcode & 0x00FF))
					)
					{
						/*xcmp request*/
						if( XCMP_REQUEST == (ptr->xcmp_opcode & 0xF000))
8000426c:	e2 19 f0 00 	andl	r9,0xf000,COH
80004270:	c0 e1       	brne	8000428c <xcmp_rx_process+0xbc>
						{
							/*send not supported opcode to raido */
							xcmp_opcode_not_supported();
80004272:	f0 1f 00 14 	mcall	800042c0 <xcmp_rx_process+0xf0>
80004276:	c0 b8       	rjmp	8000428c <xcmp_rx_process+0xbc>
						}
					}
					else
					{					
						xcmp_exec_func( &app_list[ptr->xcmp_opcode & 0x00FF]
80004278:	f9 da c0 08 	bfextu	r12,r10,0x0,0x8
8000427c:	f8 0c 00 1c 	add	r12,r12,r12<<0x1
80004280:	49 19       	lddpc	r9,800042c4 <xcmp_rx_process+0xf4>
80004282:	72 08       	ld.w	r8,r9[0x0]
80004284:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80004288:	f0 1f 00 0b 	mcall	800042b4 <xcmp_rx_process+0xe4>
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
8000428c:	66 0c       	ld.w	r12,r3[0x0]
8000428e:	40 0b       	lddsp	r11,sp[0x0]
80004290:	f0 1f 00 0e 	mcall	800042c8 <xcmp_rx_process+0xf8>
80004294:	ca 7b       	rjmp	800041e2 <xcmp_rx_process+0x12>
80004296:	00 00       	add	r0,r0
80004298:	00 00       	add	r0,r0
8000429a:	0b 10       	ld.sh	r0,r5++
8000429c:	00 00       	add	r0,r0
8000429e:	0a a8       	st.w	r5++,r8
800042a0:	00 00       	add	r0,r0
800042a2:	0b 20       	ld.uh	r0,r5++
800042a4:	00 00       	add	r0,r0
800042a6:	0b 14       	ld.sh	r4,r5++
800042a8:	00 00       	add	r0,r0
800042aa:	0b 04       	ld.w	r4,r5++
800042ac:	80 00       	ld.sh	r0,r0[0x0]
800042ae:	62 04       	ld.w	r4,r1[0x0]
800042b0:	00 00       	add	r0,r0
800042b2:	0b 38       	ld.ub	r8,r5++
800042b4:	80 00       	ld.sh	r0,r0[0x0]
800042b6:	40 d4       	lddsp	r4,sp[0x34]
800042b8:	00 00       	add	r0,r0
800042ba:	0a f8       	st.b	--r5,r8
800042bc:	00 00       	add	r0,r0
800042be:	0b 2c       	ld.uh	r12,r5++
800042c0:	80 00       	ld.sh	r0,r0[0x0]
800042c2:	40 b0       	lddsp	r0,sp[0x2c]
800042c4:	00 00       	add	r0,r0
800042c6:	97 20       	st.w	r11[0x8],r0
800042c8:	80 00       	ld.sh	r0,r0[0x0]
800042ca:	2c b4       	sub	r4,-53

800042cc <xcmp_rx>:
Calls:   
	xQueueSend -- xnl.c
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
800042cc:	eb cd 40 90 	pushm	r4,r7,lr
800042d0:	20 1d       	sub	sp,4
800042d2:	fa c4 ff f0 	sub	r4,sp,-16
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
800042d6:	48 c8       	lddpc	r8,80004304 <xcmp_rx+0x38>
800042d8:	70 0c       	ld.w	r12,r8[0x0]
800042da:	f0 1f 00 0c 	mcall	80004308 <xcmp_rx+0x3c>
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
800042de:	c1 00       	breq	800042fe <xcmp_rx+0x32>
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
800042e0:	fa c7 ff fc 	sub	r7,sp,-4
800042e4:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
	{
		memcpy(xcmp_ptr, &xcmp, sizeof(xcmp_fragment_t));				
800042e6:	e0 6a 00 ca 	mov	r10,202
800042ea:	08 9b       	mov	r11,r4
800042ec:	f0 1f 00 08 	mcall	8000430c <xcmp_rx+0x40>
		xQueueSend(xcmp_frame_rx, &xcmp_ptr, 0);	
800042f0:	48 88       	lddpc	r8,80004310 <xcmp_rx+0x44>
800042f2:	70 0c       	ld.w	r12,r8[0x0]
800042f4:	30 09       	mov	r9,0
800042f6:	12 9a       	mov	r10,r9
800042f8:	1a 9b       	mov	r11,sp
800042fa:	f0 1f 00 07 	mcall	80004314 <xcmp_rx+0x48>
	}	
}
800042fe:	2f fd       	sub	sp,-4
80004300:	e3 cd 80 90 	ldm	sp++,r4,r7,pc
80004304:	00 00       	add	r0,r0
80004306:	0a a8       	st.w	r5++,r8
80004308:	80 00       	ld.sh	r0,r0[0x0]
8000430a:	2e 60       	sub	r0,-26
8000430c:	80 00       	ld.sh	r0,r0[0x0]
8000430e:	78 c4       	ld.w	r4,r12[0x30]
80004310:	00 00       	add	r0,r0
80004312:	0b 10       	ld.sh	r0,r5++
80004314:	80 00       	ld.sh	r0,r0[0x0]
80004316:	64 10       	ld.w	r0,r2[0x4]

80004318 <xnl_register_xcmp_func>:
Function: xnl_register_xcmp_func
Description: register the xcmp function(callback function)
*/
void xnl_register_xcmp_func( void ( *func)(xnl_content_data_msg_t))
{
	 xcmp_exec = func;
80004318:	48 28       	lddpc	r8,80004320 <xnl_register_xcmp_func+0x8>
8000431a:	91 0c       	st.w	r8[0x0],r12
}
8000431c:	5e fc       	retal	r12
8000431e:	00 00       	add	r0,r0
80004320:	00 00       	add	r0,r0
80004322:	0b 5c       	ld.sh	r12,--r5

80004324 <xnl_get_msg_ack_func>:
Description: process while receive msg ack.
Calls:xSemaphoreGive--freertos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
80004324:	d4 01       	pushm	lr
	
	DestinationAddress = xnl->xnl_header.destination;
	/*No timeout*/		
	 //One relationship is controlled by a state machine, only the current MSG received the ACK, 
	//then the program will clear the current MSG sending address and out of standby and will jump to the sending state.
	if (DestinationAddress == xnl_information.device_address )
80004326:	48 88       	lddpc	r8,80004344 <xnl_get_msg_ack_func+0x20>
80004328:	90 28       	ld.sh	r8,r8[0x4]
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
	U16 DestinationAddress;
	U16 TransactionID;
	
	DestinationAddress = xnl->xnl_header.destination;
8000432a:	98 49       	ld.sh	r9,r12[0x8]
8000432c:	f0 09 19 00 	cp.h	r9,r8
80004330:	c0 81       	brne	80004340 <xnl_get_msg_ack_func+0x1c>
	if (DestinationAddress == xnl_information.device_address )
	{
		//The ack is for me.
		
		TransactionID = xnl->xnl_header.transaction_id;
		xSemaphoreGive(xnl_timeout_semphr);	
80004332:	48 68       	lddpc	r8,80004348 <xnl_get_msg_ack_func+0x24>
80004334:	70 0c       	ld.w	r12,r8[0x0]
80004336:	30 09       	mov	r9,0
80004338:	12 9a       	mov	r10,r9
8000433a:	12 9b       	mov	r11,r9
8000433c:	f0 1f 00 04 	mcall	8000434c <xnl_get_msg_ack_func+0x28>
80004340:	d8 02       	popm	pc
80004342:	00 00       	add	r0,r0
80004344:	00 00       	add	r0,r0
80004346:	97 24       	st.w	r11[0x8],r4
80004348:	00 00       	add	r0,r0
8000434a:	0b 44       	ld.w	r4,--r5
8000434c:	80 00       	ld.sh	r0,r0[0x0]
8000434e:	64 10       	ld.w	r0,r2[0x4]

80004350 <xnl_init>:
	xTaskCreate--freertos
	xnl_send_device_master_query
Called By:xcmp_init -- xcmp.c
*/
void xnl_init(void)
{
80004350:	eb cd 40 e0 	pushm	r5-r7,lr
	
	xnl_information.is_connected = FALSE;
80004354:	30 09       	mov	r9,0
80004356:	4b 78       	lddpc	r8,80004430 <xnl_init+0xe0>
80004358:	b0 89       	st.b	r8[0x0],r9

	/*initialize the semaphore and queue*/
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
8000435a:	30 0b       	mov	r11,0
8000435c:	30 1c       	mov	r12,1
8000435e:	f0 1f 00 36 	mcall	80004434 <xnl_init+0xe4>
80004362:	4b 68       	lddpc	r8,80004438 <xnl_init+0xe8>
80004364:	91 0c       	st.w	r8[0x0],r12
80004366:	70 08       	ld.w	r8,r8[0x0]
80004368:	58 08       	cp.w	r8,0
8000436a:	c0 80       	breq	8000437a <xnl_init+0x2a>
8000436c:	4b 38       	lddpc	r8,80004438 <xnl_init+0xe8>
8000436e:	70 0c       	ld.w	r12,r8[0x0]
80004370:	30 09       	mov	r9,0
80004372:	12 9a       	mov	r10,r9
80004374:	12 9b       	mov	r11,r9
80004376:	f0 1f 00 32 	mcall	8000443c <xnl_init+0xec>
	
	xnl_frame_tx = xQueueCreate(50, sizeof(xnl_fragment_t *)); //扩大xnl_frame_tx的队列深度
8000437a:	30 4b       	mov	r11,4
8000437c:	33 2c       	mov	r12,50
8000437e:	f0 1f 00 2e 	mcall	80004434 <xnl_init+0xe4>
80004382:	4b 08       	lddpc	r8,80004440 <xnl_init+0xf0>
80004384:	91 0c       	st.w	r8[0x0],r12
		
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
80004386:	30 4b       	mov	r11,4
80004388:	36 4c       	mov	r12,100
8000438a:	f0 1f 00 2b 	mcall	80004434 <xnl_init+0xe4>
8000438e:	4a e8       	lddpc	r8,80004444 <xnl_init+0xf4>
80004390:	91 0c       	st.w	r8[0x0],r12
80004392:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_XNL_STORE; i++ )
	{
		set_xnl_idle(&xnl_store[i]);
80004394:	10 96       	mov	r6,r8
80004396:	4a d5       	lddpc	r5,80004448 <xnl_init+0xf8>
80004398:	6c 0c       	ld.w	r12,r6[0x0]
8000439a:	ea 07 00 0b 	add	r11,r5,r7
8000439e:	f0 1f 00 2c 	mcall	8000444c <xnl_init+0xfc>
800043a2:	ee c7 ff 00 	sub	r7,r7,-256
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
	
	xnl_frame_tx = xQueueCreate(50, sizeof(xnl_fragment_t *)); //扩大xnl_frame_tx的队列深度
		
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
	for(int i= 0; i < MAX_XNL_STORE; i++ )
800043a6:	e0 47 64 00 	cp.w	r7,25600
800043aa:	cf 71       	brne	80004398 <xnl_init+0x48>
	{
		set_xnl_idle(&xnl_store[i]);
	}
	
	/*initialize the queue to send/receive xnl packet */
	phy_xnl_frame_tx = xQueueCreate(TX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
800043ac:	30 4b       	mov	r11,4
800043ae:	31 4c       	mov	r12,20
800043b0:	f0 1f 00 21 	mcall	80004434 <xnl_init+0xe4>
800043b4:	4a 78       	lddpc	r8,80004450 <xnl_init+0x100>
800043b6:	91 0c       	st.w	r8[0x0],r12
	phy_xnl_frame_rx = xQueueCreate(RX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
800043b8:	30 4b       	mov	r11,4
800043ba:	31 4c       	mov	r12,20
800043bc:	f0 1f 00 1e 	mcall	80004434 <xnl_init+0xe4>
800043c0:	4a 58       	lddpc	r8,80004454 <xnl_init+0x104>
800043c2:	91 0c       	st.w	r8[0x0],r12
	
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
800043c4:	30 4b       	mov	r11,4
800043c6:	30 ac       	mov	r12,10
800043c8:	f0 1f 00 1b 	mcall	80004434 <xnl_init+0xe4>
800043cc:	4a 38       	lddpc	r8,80004458 <xnl_init+0x108>
800043ce:	91 0c       	st.w	r8[0x0],r12
800043d0:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
	{
		set_payload_idle(payload_store[i]);
800043d2:	10 96       	mov	r6,r8
800043d4:	4a 25       	lddpc	r5,8000445c <xnl_init+0x10c>
800043d6:	6c 0c       	ld.w	r12,r6[0x0]
800043d8:	ea 07 00 0b 	add	r11,r5,r7
800043dc:	f0 1f 00 1c 	mcall	8000444c <xnl_init+0xfc>
800043e0:	ee c7 fe 00 	sub	r7,r7,-512
	
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
800043e4:	e0 47 14 00 	cp.w	r7,5120
800043e8:	cf 71       	brne	800043d6 <xnl_init+0x86>
	
	/*initialize the queue to send/receive payload packet */
	//phy_payload_frame_tx =
	//xQueueCreate(TX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t));
	
	phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
800043ea:	30 4b       	mov	r11,4
800043ec:	30 5c       	mov	r12,5
800043ee:	f0 1f 00 12 	mcall	80004434 <xnl_init+0xe4>
800043f2:	49 c8       	lddpc	r8,80004460 <xnl_init+0x110>
800043f4:	91 0c       	st.w	r8[0x0],r12
	
	#endif /*end if*/
		
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
800043f6:	30 07       	mov	r7,0
800043f8:	1a d7       	st.w	--sp,r7
800043fa:	1a d7       	st.w	--sp,r7
800043fc:	1a d7       	st.w	--sp,r7
800043fe:	30 38       	mov	r8,3
80004400:	0e 99       	mov	r9,r7
80004402:	e0 6a 02 00 	mov	r10,512
80004406:	49 8b       	lddpc	r11,80004464 <xnl_init+0x114>
80004408:	49 8c       	lddpc	r12,80004468 <xnl_init+0x118>
8000440a:	f0 1f 00 19 	mcall	8000446c <xnl_init+0x11c>
	,  tskXNL_PRIORITY //+ 1
	,  NULL
	);
	
	/*this task is used to send xnl message*/
	xTaskCreate(
8000440e:	1a d7       	st.w	--sp,r7
80004410:	1a d7       	st.w	--sp,r7
80004412:	1a d7       	st.w	--sp,r7
80004414:	30 38       	mov	r8,3
80004416:	0e 99       	mov	r9,r7
80004418:	e0 6a 00 82 	mov	r10,130
8000441c:	49 5b       	lddpc	r11,80004470 <xnl_init+0x120>
8000441e:	49 6c       	lddpc	r12,80004474 <xnl_init+0x124>
80004420:	f0 1f 00 13 	mcall	8000446c <xnl_init+0x11c>
	,  tskXNL_PRIORITY//+1
	,  NULL
	);
	
	/*initialize the physical layer*/
	phy_init();
80004424:	f0 1f 00 15 	mcall	80004478 <xnl_init+0x128>
80004428:	2f ad       	sub	sp,-24
}
8000442a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000442e:	00 00       	add	r0,r0
80004430:	00 00       	add	r0,r0
80004432:	97 24       	st.w	r11[0x8],r4
80004434:	80 00       	ld.sh	r0,r0[0x0]
80004436:	65 68       	ld.w	r8,r2[0x58]
80004438:	00 00       	add	r0,r0
8000443a:	0b 44       	ld.w	r4,--r5
8000443c:	80 00       	ld.sh	r0,r0[0x0]
8000443e:	64 10       	ld.w	r0,r2[0x4]
80004440:	00 00       	add	r0,r0
80004442:	0b 50       	ld.sh	r0,--r5
80004444:	00 00       	add	r0,r0
80004446:	0a a8       	st.w	r5++,r8
80004448:	00 00       	add	r0,r0
8000444a:	32 d2       	mov	r2,45
8000444c:	80 00       	ld.sh	r0,r0[0x0]
8000444e:	2c b4       	sub	r4,-53
80004450:	00 00       	add	r0,r0
80004452:	0a d8       	st.w	--r5,r8
80004454:	00 00       	add	r0,r0
80004456:	0a b8       	st.h	r5++,r8
80004458:	00 00       	add	r0,r0
8000445a:	0a ac       	st.w	r5++,r12
8000445c:	00 00       	add	r0,r0
8000445e:	1e d2       	st.w	--pc,r2
80004460:	00 00       	add	r0,r0
80004462:	0a e4       	st.h	--r5,r4
80004464:	80 00       	ld.sh	r0,r0[0x0]
80004466:	d8 50       	acall	0x85
80004468:	80 00       	ld.sh	r0,r0[0x0]
8000446a:	44 7c       	lddsp	r12,sp[0x11c]
8000446c:	80 00       	ld.sh	r0,r0[0x0]
8000446e:	6c 84       	ld.w	r4,r6[0x20]
80004470:	80 00       	ld.sh	r0,r0[0x0]
80004472:	d8 58       	*unknown*
80004474:	80 00       	ld.sh	r0,r0[0x0]
80004476:	44 dc       	lddsp	r12,sp[0x134]
80004478:	80 00       	ld.sh	r0,r0[0x0]
8000447a:	2e 88       	sub	r8,-24

8000447c <xnl_rx_process>:
Calls: 
Called By:task
*/
//portTickType water_value =0;
static void xnl_rx_process(void * pvParameters)
{
8000447c:	eb cd 40 fe 	pushm	r1-r7,lr
80004480:	20 1d       	sub	sp,4
	xnl_fragment_t * xnl_ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
80004482:	49 26       	lddpc	r6,800044c8 <xnl_rx_process+0x4c>
80004484:	30 05       	mov	r5,0
80004486:	3f f4       	mov	r4,-1
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
80004488:	30 c3       	mov	r3,12
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
8000448a:	49 11       	lddpc	r1,800044cc <xnl_rx_process+0x50>
	if(xnl->xnl_header.opcode > 0x0C)	
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
8000448c:	49 12       	lddpc	r2,800044d0 <xnl_rx_process+0x54>
	xnl_fragment_t * xnl_ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
8000448e:	6c 0c       	ld.w	r12,r6[0x0]
80004490:	0a 99       	mov	r9,r5
80004492:	08 9a       	mov	r10,r4
80004494:	1a 9b       	mov	r11,sp
80004496:	f0 1f 00 10 	mcall	800044d4 <xnl_rx_process+0x58>
8000449a:	58 1c       	cp.w	r12,1
8000449c:	cf 91       	brne	8000448e <xnl_rx_process+0x12>
		, portMAX_DELAY ))
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
8000449e:	40 0c       	lddsp	r12,sp[0x0]
800044a0:	58 0c       	cp.w	r12,0
800044a2:	cf 60       	breq	8000448e <xnl_rx_process+0x12>
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
800044a4:	98 28       	ld.sh	r8,r12[0x4]
800044a6:	e6 08 19 00 	cp.h	r8,r3
800044aa:	e0 8b 00 0a 	brhi	800044be <xnl_rx_process+0x42>
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
800044ae:	5c 78       	castu.h	r8
800044b0:	e4 08 03 29 	ld.w	r9,r2[r8<<0x2]
800044b4:	58 09       	cp.w	r9,0
800044b6:	c0 40       	breq	800044be <xnl_rx_process+0x42>
	{
		//log("\n\r R_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:R_xnl指令
		/*execute the function in list*/
		xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec(xnl);
800044b8:	e4 08 03 28 	ld.w	r8,r2[r8<<0x2]
800044bc:	5d 18       	icall	r8
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
800044be:	62 0c       	ld.w	r12,r1[0x0]
800044c0:	40 0b       	lddsp	r11,sp[0x0]
800044c2:	f0 1f 00 06 	mcall	800044d8 <xnl_rx_process+0x5c>
800044c6:	ce 4b       	rjmp	8000448e <xnl_rx_process+0x12>
800044c8:	00 00       	add	r0,r0
800044ca:	0a b8       	st.h	r5++,r8
800044cc:	00 00       	add	r0,r0
800044ce:	0a a8       	st.w	r5++,r8
800044d0:	00 00       	add	r0,r0
800044d2:	04 f4       	st.b	--r2,r4
800044d4:	80 00       	ld.sh	r0,r0[0x0]
800044d6:	62 04       	ld.w	r4,r1[0x0]
800044d8:	80 00       	ld.sh	r0,r0[0x0]
800044da:	2c b4       	sub	r4,-53

800044dc <xnl_tx_process>:
	phy_tx -- physical.c
Called By: task
*/
//portTickType tx_water_value =0;
static void xnl_tx_process(void * pvParameters)
{
800044dc:	d4 31       	pushm	r0-r7,lr
	
	
	for(;;)
	{		
		//tx_water_value = uxTaskGetStackHighWaterMark(NULL);
		switch(xnl_tx_state)
800044de:	4a a6       	lddpc	r6,80004584 <xnl_tx_process+0xa8>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
800044e0:	4a a2       	lddpc	r2,80004588 <xnl_tx_process+0xac>
800044e2:	4a b4       	lddpc	r4,8000458c <xnl_tx_process+0xb0>
800044e4:	30 07       	mov	r7,0
800044e6:	3f f1       	mov	r1,-1
					if(NULL == ptr)
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
800044e8:	30 00       	mov	r0,0
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;				
800044ea:	4a a5       	lddpc	r5,80004590 <xnl_tx_process+0xb4>
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
800044ec:	4a a3       	lddpc	r3,80004594 <xnl_tx_process+0xb8>
	
	
	for(;;)
	{		
		//tx_water_value = uxTaskGetStackHighWaterMark(NULL);
		switch(xnl_tx_state)
800044ee:	6c 08       	ld.w	r8,r6[0x0]
800044f0:	58 08       	cp.w	r8,0
800044f2:	c0 40       	breq	800044fa <xnl_tx_process+0x1e>
800044f4:	58 18       	cp.w	r8,1
800044f6:	cf d1       	brne	800044f0 <xnl_tx_process+0x14>
800044f8:	c2 48       	rjmp	80004540 <xnl_tx_process+0x64>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
800044fa:	64 0c       	ld.w	r12,r2[0x0]
800044fc:	0e 99       	mov	r9,r7
800044fe:	02 9a       	mov	r10,r1
80004500:	08 9b       	mov	r11,r4
80004502:	f0 1f 00 26 	mcall	80004598 <xnl_tx_process+0xbc>
80004506:	58 1c       	cp.w	r12,1
80004508:	cf 31       	brne	800044ee <xnl_tx_process+0x12>
					, portMAX_DELAY ))
				{				
					if(NULL == ptr)
8000450a:	68 0b       	ld.w	r11,r4[0x0]
8000450c:	58 0b       	cp.w	r11,0
8000450e:	cf 00       	breq	800044ee <xnl_tx_process+0x12>
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
80004510:	96 28       	ld.sh	r8,r11[0x4]
80004512:	e0 08 19 00 	cp.h	r8,r0
80004516:	c0 71       	brne	80004524 <xnl_tx_process+0x48>
					{
						/*invalid XNL opcode*/
						set_xnl_idle(ptr);
80004518:	4a 18       	lddpc	r8,8000459c <xnl_tx_process+0xc0>
8000451a:	70 08       	ld.w	r8,r8[0x0]
8000451c:	10 9c       	mov	r12,r8
8000451e:	f0 1f 00 21 	mcall	800045a0 <xnl_tx_process+0xc4>
						break;
80004522:	ce 6b       	rjmp	800044ee <xnl_tx_process+0x12>
					}
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
80004524:	16 9c       	mov	r12,r11
80004526:	f0 1f 00 20 	mcall	800045a4 <xnl_tx_process+0xc8>
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;				
8000452a:	30 18       	mov	r8,1
8000452c:	8b 08       	st.w	r5[0x0],r8
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
8000452e:	66 0c       	ld.w	r12,r3[0x0]
80004530:	0e 99       	mov	r9,r7
80004532:	0e 9a       	mov	r10,r7
80004534:	0e 9b       	mov	r11,r7
80004536:	f0 1f 00 19 	mcall	80004598 <xnl_tx_process+0xbc>
					xnl_tx_state = WAITING_FOR_REPLY;
8000453a:	30 18       	mov	r8,1
8000453c:	8d 08       	st.w	r6[0x0],r8
8000453e:	cd 8b       	rjmp	800044ee <xnl_tx_process+0x12>
				}
				break;
			
			/*wait XNL reply*/			
			case WAITING_FOR_REPLY://直到回答ACK才再发送下一条data/control
				if(pdTRUE == xSemaphoreTake( xnl_timeout_semphr
80004540:	66 0c       	ld.w	r12,r3[0x0]
80004542:	0e 99       	mov	r9,r7
80004544:	36 4a       	mov	r10,100
80004546:	0e 9b       	mov	r11,r7
80004548:	f0 1f 00 14 	mcall	80004598 <xnl_tx_process+0xbc>
8000454c:	58 1c       	cp.w	r12,1
8000454e:	c0 81       	brne	8000455e <xnl_tx_process+0x82>
					, ( portTickType )50*2/ portTICK_RATE_MS))//按ADK文档中提示500ms一次超时,但是实际情况下程序中启用freertos的任务延时不够精准。因此根据经验需要降低延时等待的时间
				{
					/*No timeout*/
					set_xnl_idle(ptr);			
80004550:	49 38       	lddpc	r8,8000459c <xnl_tx_process+0xc0>
80004552:	70 0c       	ld.w	r12,r8[0x0]
80004554:	68 0b       	ld.w	r11,r4[0x0]
80004556:	f0 1f 00 13 	mcall	800045a0 <xnl_tx_process+0xc4>
					xnl_tx_state = WAITING_FOR_TX;
8000455a:	8d 07       	st.w	r6[0x0],r7
8000455c:	cc 9b       	rjmp	800044ee <xnl_tx_process+0x12>
				}
				else
				{
					/*time out*/
					if(xnl_send_times <= MIN_RESEND_TIMES)
8000455e:	6a 08       	ld.w	r8,r5[0x0]
80004560:	58 38       	cp.w	r8,3
80004562:	e0 89 00 09 	brgt	80004574 <xnl_tx_process+0x98>
					{
						/*If times smaller than A supermarket, then resend the 
						instructions*/
						phy_tx((phy_fragment_t *)ptr);
80004566:	68 0c       	ld.w	r12,r4[0x0]
80004568:	f0 1f 00 0f 	mcall	800045a4 <xnl_tx_process+0xc8>
						xnl_send_times++;
8000456c:	6a 08       	ld.w	r8,r5[0x0]
8000456e:	2f f8       	sub	r8,-1
80004570:	8b 08       	st.w	r5[0x0],r8
80004572:	cb eb       	rjmp	800044ee <xnl_tx_process+0x12>
					}
					else
					{
						//can not send data, disconnected						
						//vPortFree(ptr);	
						set_xnl_idle(ptr);									
80004574:	48 a8       	lddpc	r8,8000459c <xnl_tx_process+0xc0>
80004576:	70 0c       	ld.w	r12,r8[0x0]
80004578:	68 0b       	ld.w	r11,r4[0x0]
8000457a:	f0 1f 00 0a 	mcall	800045a0 <xnl_tx_process+0xc4>
						xnl_tx_state = WAITING_FOR_TX;
8000457e:	8d 07       	st.w	r6[0x0],r7
80004580:	cb 7b       	rjmp	800044ee <xnl_tx_process+0x12>
80004582:	00 00       	add	r0,r0
80004584:	00 00       	add	r0,r0
80004586:	0b 4c       	ld.w	r12,--r5
80004588:	00 00       	add	r0,r0
8000458a:	0b 50       	ld.sh	r0,--r5
8000458c:	00 00       	add	r0,r0
8000458e:	0b 58       	ld.sh	r8,--r5
80004590:	00 00       	add	r0,r0
80004592:	0b 54       	ld.sh	r4,--r5
80004594:	00 00       	add	r0,r0
80004596:	0b 44       	ld.w	r4,--r5
80004598:	80 00       	ld.sh	r0,r0[0x0]
8000459a:	62 04       	ld.w	r4,r1[0x0]
8000459c:	00 00       	add	r0,r0
8000459e:	0a a8       	st.w	r5++,r8
800045a0:	80 00       	ld.sh	r0,r0[0x0]
800045a2:	2c b4       	sub	r4,-53
800045a4:	80 00       	ld.sh	r0,r0[0x0]
800045a6:	2c d4       	sub	r4,-51

800045a8 <xnl_tx>:
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
{
800045a8:	eb cd 40 c0 	pushm	r6-r7,lr
800045ac:	20 1d       	sub	sp,4
800045ae:	18 96       	mov	r6,r12
	message that is sent. The same value should be used for all retries.
	*/
	static U8 flags = 0;
	
	/*If the value is DEFAULT_VALUE, the value will be modified*/
	if(DEFAULT_VALUE == xnl->xnl_header.flags)
800045b0:	98 39       	ld.sh	r9,r12[0x6]
800045b2:	3f f8       	mov	r8,-1
800045b4:	f0 09 19 00 	cp.h	r9,r8
800045b8:	c0 a1       	brne	800045cc <xnl_tx+0x24>
	{
		xnl->xnl_header.flags =  0x0100 | ((++flags) & 0x07);
800045ba:	4a e9       	lddpc	r9,80004670 <xnl_tx+0xc8>
800045bc:	13 88       	ld.ub	r8,r9[0x0]
800045be:	2f f8       	sub	r8,-1
800045c0:	5c 58       	castu.b	r8
800045c2:	b2 88       	st.b	r9[0x0],r8
800045c4:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
800045c8:	a9 a8       	sbr	r8,0x8
800045ca:	b8 38       	st.h	r12[0x6],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.destination)
800045cc:	8c 49       	ld.sh	r9,r6[0x8]
800045ce:	3f f8       	mov	r8,-1
800045d0:	f0 09 19 00 	cp.h	r9,r8
800045d4:	c0 41       	brne	800045dc <xnl_tx+0x34>
	{		
		/*Use actual Master address.*/
		xnl->xnl_header.destination = xnl_information.master_address;
800045d6:	4a 88       	lddpc	r8,80004674 <xnl_tx+0xcc>
800045d8:	90 18       	ld.sh	r8,r8[0x2]
800045da:	ac 48       	st.h	r6[0x8],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.source)
800045dc:	8c 59       	ld.sh	r9,r6[0xa]
800045de:	3f f8       	mov	r8,-1
800045e0:	f0 09 19 00 	cp.h	r9,r8
800045e4:	c0 41       	brne	800045ec <xnl_tx+0x44>
	{
		/*Use Temporary address.*/	
		xnl->xnl_header.source = xnl_information.device_address;
800045e6:	4a 48       	lddpc	r8,80004674 <xnl_tx+0xcc>
800045e8:	90 28       	ld.sh	r8,r8[0x4]
800045ea:	ac 58       	st.h	r6[0xa],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
800045ec:	8c 69       	ld.sh	r9,r6[0xc]
800045ee:	3f f8       	mov	r8,-1
800045f0:	f0 09 19 00 	cp.h	r9,r8
800045f4:	c0 e1       	brne	80004610 <xnl_tx+0x68>
	{		
		xnl->xnl_header.transaction_id = 
		  ((++xnl_information.transaction_id) & 0xFF) 
800045f6:	4a 08       	lddpc	r8,80004674 <xnl_tx+0xcc>
800045f8:	90 49       	ld.sh	r9,r8[0x8]
800045fa:	2f f9       	sub	r9,-1
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
800045fc:	b0 49       	st.h	r8[0x8],r9
		  ((++xnl_information.transaction_id) & 0xFF) 
800045fe:	90 4a       	ld.sh	r10,r8[0x8]
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
80004600:	90 49       	ld.sh	r9,r8[0x8]
80004602:	e0 19 ff 00 	andl	r9,0xff00
80004606:	f1 da c0 08 	bfextu	r8,r10,0x0,0x8
8000460a:	f3 e8 10 08 	or	r8,r9,r8
8000460e:	ac 68       	st.h	r6[0xc],r8
	U16  sumScratch;
	U32  indextohWord;
	S32  hWordswithinFrag;
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
80004610:	0d 98       	ld.ub	r8,r6[0x1]
80004612:	20 28       	sub	r8,2
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
80004614:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
80004618:	10 0c       	add	r12,r8
8000461a:	a1 5c       	asr	r12,0x1
	indextohWord = 2;
	while (hWordswithinFrag > 0)
8000461c:	58 0c       	cp.w	r12,0
8000461e:	e0 89 00 04 	brgt	80004626 <xnl_tx+0x7e>
80004622:	30 09       	mov	r9,0
80004624:	c0 d8       	rjmp	8000463e <xnl_tx+0x96>
80004626:	ec ca ff fc 	sub	r10,r6,-4
Parameters: xnl_fragment_t * 
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
8000462a:	2f ec       	sub	r12,-2
8000462c:	30 09       	mov	r9,0
8000462e:	30 28       	mov	r8,2
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
	{
		sumScratch += *((U16*)xnl + indextohWord);
80004630:	15 1b       	ld.sh	r11,r10++
80004632:	f6 09 00 09 	add	r9,r11,r9
80004636:	5c 89       	casts.h	r9
		indextohWord     += 1;
80004638:	2f f8       	sub	r8,-1
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
8000463a:	18 38       	cp.w	r8,r12
8000463c:	cf a1       	brne	80004630 <xnl_tx+0x88>
		  ((++xnl_information.transaction_id) & 0xFF) 
		| (xnl_information.transaction_id & 0xFF00);
	}
	
	/*count check sum */
	xnl->phy_header.check_sum = check_sum( xnl );
8000463e:	5c 39       	neg	r9
80004640:	ac 19       	st.h	r6[0x2],r9
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
80004642:	48 e8       	lddpc	r8,80004678 <xnl_tx+0xd0>
80004644:	70 0c       	ld.w	r12,r8[0x0]
80004646:	f0 1f 00 0e 	mcall	8000467c <xnl_tx+0xd4>
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
8000464a:	c1 00       	breq	8000466a <xnl_tx+0xc2>
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
8000464c:	fa c7 ff fc 	sub	r7,sp,-4
80004650:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
	{
		memcpy(ptr, xnl, sizeof(xnl_fragment_t));
80004652:	e0 6a 01 00 	mov	r10,256
80004656:	0c 9b       	mov	r11,r6
80004658:	f0 1f 00 0a 	mcall	80004680 <xnl_tx+0xd8>
	
		/*push to queue and send*/
		
		//log("ptr -%8x", ptr);
		
		xQueueSend(xnl_frame_tx, &ptr, 0);
8000465c:	48 a8       	lddpc	r8,80004684 <xnl_tx+0xdc>
8000465e:	70 0c       	ld.w	r12,r8[0x0]
80004660:	30 09       	mov	r9,0
80004662:	12 9a       	mov	r10,r9
80004664:	1a 9b       	mov	r11,sp
80004666:	f0 1f 00 09 	mcall	80004688 <xnl_tx+0xe0>
		//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
		
		//vPortFree(ptr);
	}
}
8000466a:	2f fd       	sub	sp,-4
8000466c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004670:	00 00       	add	r0,r0
80004672:	0b 48       	ld.w	r8,--r5
80004674:	00 00       	add	r0,r0
80004676:	97 24       	st.w	r11[0x8],r4
80004678:	00 00       	add	r0,r0
8000467a:	0a a8       	st.w	r5++,r8
8000467c:	80 00       	ld.sh	r0,r0[0x0]
8000467e:	2e 60       	sub	r0,-26
80004680:	80 00       	ld.sh	r0,r0[0x0]
80004682:	78 c4       	ld.w	r4,r12[0x30]
80004684:	00 00       	add	r0,r0
80004686:	0b 50       	ld.sh	r0,--r5
80004688:	80 00       	ld.sh	r0,r0[0x0]
8000468a:	64 10       	ld.w	r0,r2[0x4]

8000468c <xnl_data_msg_func>:
Description: process while receive data message.
Calls:xnl_send_msg_ack, xcmp_exec(function in xcmp)
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_data_msg_func(xnl_fragment_t * xnl)
{
8000468c:	eb cd 40 80 	pushm	r7,lr
80004690:	fa cd 01 00 	sub	sp,sp,256
80004694:	18 97       	mov	r7,r12
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80004696:	e0 68 40 0e 	mov	r8,16398
8000469a:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
8000469c:	3f f8       	mov	r8,-1
8000469e:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG_ACK;
800046a0:	30 c8       	mov	r8,12
800046a2:	ba 28       	st.h	sp[0x4],r8
	
	/*Turn around Flags.*/	
	xnl_frame.xnl_header.flags = hdr->flags;
800046a4:	98 38       	ld.sh	r8,r12[0x6]
800046a6:	ba 38       	st.h	sp[0x6],r8
	
	/*ACK Destination Address is Source of XNL_Message.*/
	xnl_frame.xnl_header.destination = hdr->source;
800046a8:	98 58       	ld.sh	r8,r12[0xa]
800046aa:	ba 48       	st.h	sp[0x8],r8
	
	/*ACK Source Address is my address.*/
	xnl_frame.xnl_header.source = hdr->destination;
800046ac:	98 48       	ld.sh	r8,r12[0x8]
800046ae:	ba 58       	st.h	sp[0xa],r8
	
	/*Turn around Transaction ID.*/
	xnl_frame.xnl_header.transaction_id = hdr->transaction_id;
800046b0:	98 68       	ld.sh	r8,r12[0xc]
800046b2:	ba 68       	st.h	sp[0xc],r8
	xnl_frame.xnl_header.payload_length = 0;
800046b4:	30 08       	mov	r8,0
800046b6:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
800046b8:	1a 9c       	mov	r12,sp
800046ba:	f0 1f 00 0a 	mcall	800046e0 <xnl_data_msg_func+0x54>
	transmitter, but possibly is waiting in Queue with immediate timeout.
	 */
	xnl_send_msg_ack(&xnl->xnl_header);
	
	/*exec xcmp function*/
	xcmp_exec(xnl->xnl_payload.xnl_content_data_msg);//xcmp_rx
800046be:	fa cd 00 cc 	sub	sp,sp,204
800046c2:	e0 6a 00 ca 	mov	r10,202
800046c6:	ee cb ff f0 	sub	r11,r7,-16
800046ca:	1a 9c       	mov	r12,sp
800046cc:	f0 1f 00 06 	mcall	800046e4 <xnl_data_msg_func+0x58>
800046d0:	48 68       	lddpc	r8,800046e8 <xnl_data_msg_func+0x5c>
800046d2:	70 08       	ld.w	r8,r8[0x0]
800046d4:	5d 18       	icall	r8
800046d6:	fa cd ff 34 	sub	sp,sp,-204
}
800046da:	2c 0d       	sub	sp,-256
800046dc:	e3 cd 80 80 	ldm	sp++,r7,pc
800046e0:	80 00       	ld.sh	r0,r0[0x0]
800046e2:	45 a8       	lddsp	r8,sp[0x168]
800046e4:	80 00       	ld.sh	r0,r0[0x0]
800046e6:	78 c4       	ld.w	r4,r12[0x30]
800046e8:	00 00       	add	r0,r0
800046ea:	0b 5c       	ld.sh	r12,--r5

800046ec <xnl_device_auth_reply_func>:
Description: process while receive device auth reply.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_auth_reply_func(xnl_fragment_t * xnl)
{
800046ec:	d4 21       	pushm	r4-r7,lr
800046ee:	fa cd 01 00 	sub	sp,sp,256
800046f2:	18 97       	mov	r7,r12
	the receiving device and will be used to authenticate the connection 
	request. 5.4.4
	*/
	//log("R_xnl-opcode:%4x", xnl->xnl_header.opcode);
	
	if(xnl_information.is_connected)
800046f4:	4c 28       	lddpc	r8,800047fc <xnl_device_auth_reply_func+0x110>
800046f6:	11 88       	ld.ub	r8,r8[0x0]
800046f8:	58 08       	cp.w	r8,0
800046fa:	e0 81 00 7f 	brne	800047f8 <xnl_device_auth_reply_func+0x10c>
	{
		return;		
	}
	
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);
800046fe:	4c 18       	lddpc	r8,80004800 <xnl_device_auth_reply_func+0x114>
80004700:	70 0c       	ld.w	r12,r8[0x0]
80004702:	30 09       	mov	r9,0
80004704:	12 9a       	mov	r10,r9
80004706:	12 9b       	mov	r11,r9
80004708:	f0 1f 00 3f 	mcall	80004804 <xnl_device_auth_reply_func+0x118>

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
8000470c:	ef 09 00 10 	ld.sh	r9,r7[16]
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
80004710:	4b b8       	lddpc	r8,800047fc <xnl_device_auth_reply_func+0x110>
80004712:	b0 29       	st.h	r8[0x4],r9
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
	
	/*Get Array of values to be encrypted into an aligned 2X32bits.*/
	v_vector[0] =
80004714:	ef 39 00 12 	ld.ub	r9,r7[18]
80004718:	ef 38 00 13 	ld.ub	r8,r7[19]
8000471c:	b1 68       	lsl	r8,0x10
8000471e:	f1 e9 11 89 	or	r9,r8,r9<<0x18
80004722:	ef 38 00 15 	ld.ub	r8,r7[21]
80004726:	f3 e8 10 08 	or	r8,r9,r8
8000472a:	ef 39 00 14 	ld.ub	r9,r7[20]
8000472e:	f1 e9 10 89 	or	r9,r8,r9<<0x8
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[2])<<8	  
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[3]);
	
	v_vector[1] =
80004732:	ef 3a 00 16 	ld.ub	r10,r7[22]
80004736:	ef 38 00 17 	ld.ub	r8,r7[23]
8000473a:	b1 68       	lsl	r8,0x10
8000473c:	f1 ea 11 8a 	or	r10,r8,r10<<0x18
80004740:	ef 38 00 19 	ld.ub	r8,r7[25]
80004744:	f5 e8 10 08 	or	r8,r10,r8
80004748:	ef 3a 00 18 	ld.ub	r10,r7[24]
8000474c:	f1 ea 10 88 	or	r8,r8,r10<<0x8
80004750:	30 0a       	mov	r10,0
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
80004752:	e0 64 79 b9 	mov	r4,31161
80004756:	ea 14 9e 37 	orh	r4,0x9e37
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
8000475a:	e0 65 45 07 	mov	r5,17671
8000475e:	ea 15 8a bd 	orh	r5,0x8abd
80004762:	e0 66 f9 3d 	mov	r6,63805
80004766:	ea 16 99 68 	orh	r6,0x9968
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
8000476a:	e0 6e b8 cf 	mov	lr,47311
8000476e:	ea 1e 36 83 	orh	lr,0x3683
80004772:	e0 67 aa 1c 	mov	r7,43548
80004776:	ea 17 9c 36 	orh	r7,0x9c36
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
8000477a:	08 0a       	add	r10,r4
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
8000477c:	f4 08 00 0c 	add	r12,r10,r8
80004780:	f0 0b 15 04 	lsl	r11,r8,0x4
80004784:	0a 0b       	add	r11,r5
80004786:	f9 eb 20 0b 	eor	r11,r12,r11
8000478a:	f0 0c 16 05 	lsr	r12,r8,0x5
8000478e:	0c 0c       	add	r12,r6
80004790:	18 5b       	eor	r11,r12
80004792:	16 09       	add	r9,r11
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
80004794:	f2 0c 15 04 	lsl	r12,r9,0x4
80004798:	1c 0c       	add	r12,lr
8000479a:	f2 0b 16 05 	lsr	r11,r9,0x5
8000479e:	0e 0b       	add	r11,r7
800047a0:	f9 eb 20 0b 	eor	r11,r12,r11
800047a4:	f2 0a 00 0c 	add	r12,r9,r10
800047a8:	18 5b       	eor	r11,r12
800047aa:	16 08       	add	r8,r11
{
	register U32 y=v[0], z=v[1], sum=0;
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
800047ac:	e0 6b 37 20 	mov	r11,14112
800047b0:	ea 1b c6 ef 	orh	r11,0xc6ef
800047b4:	16 3a       	cp.w	r10,r11
800047b6:	ce 21       	brne	8000477a <xnl_device_auth_reply_func+0x8e>
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :24 + 2(xnl length(24) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 24 + 2;
800047b8:	e0 6a 40 1a 	mov	r10,16410
800047bc:	ba 0a       	st.h	sp[0x0],r10
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
800047be:	3f fa       	mov	r10,-1
800047c0:	ba 1a       	st.h	sp[0x2],r10
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_CONN_REQUEST;
800047c2:	30 6b       	mov	r11,6
800047c4:	ba 2b       	st.h	sp[0x4],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
800047c6:	ba 3a       	st.h	sp[0x6],r10
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
800047c8:	48 db       	lddpc	r11,800047fc <xnl_device_auth_reply_func+0x110>
800047ca:	96 1c       	ld.sh	r12,r11[0x2]
800047cc:	ba 4c       	st.h	sp[0x8],r12
	message here, and all will receive the same DEVICE_CONN_REPLY. Not real 
	sure what's going to happen with multiple conrol heads, etc. One suspects 
	the Rocket Scientists will eventually figure this out, and demand a 
	transaction ID based on Device Type in the XNL_DEVICE_AUTH_KEY_REQUEST.
	*/
	xnl_frame.xnl_header.source = xnl_information.device_address;
800047ce:	96 2b       	ld.sh	r11,r11[0x4]
800047d0:	ba 5b       	st.h	sp[0xa],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
800047d2:	ba 6a       	st.h	sp[0xc],r10
	
    /*his message contains 12 payload bytes*/	
	xnl_frame.xnl_header.payload_length = 0x000C;
800047d4:	30 ca       	mov	r10,12
800047d6:	ba 7a       	st.h	sp[0xe],r10
	
	/*No Preferred XNL Address*/
	xnl_frame.xnl_payload.xnl_content_device_conn_req.preferred_xnl_address = 
800047d8:	30 0a       	mov	r10,0
800047da:	fb 5a 00 10 	st.h	sp[16],r10
	XCMP/XNL Development Specification Section 4.5.3.2.1.
	Same as in MOTOTRBO?XCMP/XNL Development Specification?
	evice_type--Option Board(0x07)
	authentication_index--Option Board(0x02)
	*/	
	xnl_frame.xnl_payload.xnl_content_device_conn_req.device_type = 0x07;
800047de:	30 7a       	mov	r10,7
800047e0:	fb 6a 00 12 	st.b	sp[18],r10
	xnl_frame.xnl_payload.xnl_content_device_conn_req.authentication_index =
800047e4:	30 2a       	mov	r10,2
800047e6:	fb 6a 00 13 	st.b	sp[19],r10
	                                                                       0x02;
		
	//We know encrypted array happens to be aligned to 32-bit boundary.
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
800047ea:	fa ca ff ec 	sub	r10,sp,-20
800047ee:	95 09       	st.w	r10[0x0],r9
	                         .encrypted_authentication_value[0])) = w_vector[0];
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
800047f0:	95 18       	st.w	r10[0x4],r8
	                         .encrypted_authentication_value[4])) = w_vector[1];
	
	/*send XNL message*/
	xnl_tx(&xnl_frame);
800047f2:	1a 9c       	mov	r12,sp
800047f4:	f0 1f 00 05 	mcall	80004808 <xnl_device_auth_reply_func+0x11c>
}
800047f8:	2c 0d       	sub	sp,-256
800047fa:	d8 22       	popm	r4-r7,pc
800047fc:	00 00       	add	r0,r0
800047fe:	97 24       	st.w	r11[0x8],r4
80004800:	00 00       	add	r0,r0
80004802:	0b 44       	ld.w	r4,--r5
80004804:	80 00       	ld.sh	r0,r0[0x0]
80004806:	64 10       	ld.w	r0,r2[0x4]
80004808:	80 00       	ld.sh	r0,r0[0x0]
8000480a:	45 a8       	lddsp	r8,sp[0x168]

8000480c <xnl_master_status_brdcst_func>:
Description: process while receive master status boardcast.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_master_status_brdcst_func(xnl_fragment_t * xnl)
{	
8000480c:	eb cd 40 80 	pushm	r7,lr
80004810:	fa cd 01 00 	sub	sp,sp,256
80004814:	18 97       	mov	r7,r12
	not an XNL_DATA_MSG has been sent out. This will indicate to a connecting 
	device that it has missed messages. The XNL header will contain the 
	master?XNL address. 5.4.1
	*/
	
	if(xnl_information.is_connected)
80004816:	49 28       	lddpc	r8,8000485c <xnl_master_status_brdcst_func+0x50>
80004818:	11 88       	ld.ub	r8,r8[0x0]
8000481a:	58 08       	cp.w	r8,0
8000481c:	c1 c1       	brne	80004854 <xnl_master_status_brdcst_func+0x48>
	{
		return;	
	}
	
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);	
8000481e:	49 18       	lddpc	r8,80004860 <xnl_master_status_brdcst_func+0x54>
80004820:	70 0c       	ld.w	r12,r8[0x0]
80004822:	30 09       	mov	r9,0
80004824:	12 9a       	mov	r10,r9
80004826:	12 9b       	mov	r11,r9
80004828:	f0 1f 00 0f 	mcall	80004864 <xnl_master_status_brdcst_func+0x58>

	//log("xnl-ma:%4x", xnl->xnl_header.source);
	/*get the master adderss from this message*/	
	xnl_information.master_address = xnl->xnl_header.source;	
8000482c:	8e 58       	ld.sh	r8,r7[0xa]
8000482e:	48 c9       	lddpc	r9,8000485c <xnl_master_status_brdcst_func+0x50>
80004830:	b2 18       	st.h	r9[0x2],r8
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80004832:	e0 68 40 0e 	mov	r8,16398
80004836:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004838:	3f f8       	mov	r8,-1
8000483a:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_AUTH_KEY_REQUEST;
8000483c:	30 4a       	mov	r10,4
8000483e:	ba 2a       	st.h	sp[0x4],r10
		
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/	
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
80004840:	ba 38       	st.h	sp[0x6],r8
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
80004842:	92 19       	ld.sh	r9,r9[0x2]
80004844:	ba 49       	st.h	sp[0x8],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.source = DEFAULT_VALUE;
80004846:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80004848:	ba 68       	st.h	sp[0xc],r8
		
	xnl_frame.xnl_header.payload_length = 0;
8000484a:	30 08       	mov	r8,0
8000484c:	ba 78       	st.h	sp[0xe],r8
	
	/*send XNL message*/	
	xnl_tx(&xnl_frame);
8000484e:	1a 9c       	mov	r12,sp
80004850:	f0 1f 00 06 	mcall	80004868 <xnl_master_status_brdcst_func+0x5c>
}
80004854:	2c 0d       	sub	sp,-256
80004856:	e3 cd 80 80 	ldm	sp++,r7,pc
8000485a:	00 00       	add	r0,r0
8000485c:	00 00       	add	r0,r0
8000485e:	97 24       	st.w	r11[0x8],r4
80004860:	00 00       	add	r0,r0
80004862:	0b 44       	ld.w	r4,--r5
80004864:	80 00       	ld.sh	r0,r0[0x0]
80004866:	64 10       	ld.w	r0,r2[0x4]
80004868:	80 00       	ld.sh	r0,r0[0x0]
8000486a:	45 a8       	lddsp	r8,sp[0x168]

8000486c <xnl_device_conn_reply_func>:
Description: process while receive device conn reply.
Calls:xSemaphoreGive--freestos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_conn_reply_func(xnl_fragment_t * xnl)
{
8000486c:	eb cd 40 80 	pushm	r7,lr
80004870:	18 97       	mov	r7,r12
	transaction ID and an 8-byte encrypted value that the device can use to 
	authenticate the master. XCMP/XNL Development Guide 5.4.6
	*/
	
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);
80004872:	49 28       	lddpc	r8,800048b8 <xnl_device_conn_reply_func+0x4c>
80004874:	70 0c       	ld.w	r12,r8[0x0]
80004876:	30 09       	mov	r9,0
80004878:	12 9a       	mov	r10,r9
8000487a:	12 9b       	mov	r11,r9
8000487c:	f0 1f 00 10 	mcall	800048bc <xnl_device_conn_reply_func+0x50>

	/*Test result code*/
	if((xnl->xnl_payload.xnl_content_device_conn_reply.result_base & 0x0000FF00)
80004880:	ef 18 00 10 	ld.uh	r8,r7[16]
80004884:	10 99       	mov	r9,r8
80004886:	e2 19 ff 00 	andl	r9,0xff00,COH
8000488a:	e0 49 01 00 	cp.w	r9,256
8000488e:	c0 60       	breq	8000489a <xnl_device_conn_reply_func+0x2e>
		/*
		Rejected. The device must retry the authentication process at this 
		point by sending out a new AUTH_KEY_REQUEST message. XCMP/XNL 
		Development Guide Section 5.2.3
		*/
		xnl_master_status_brdcst_func(xnl);			
80004890:	0e 9c       	mov	r12,r7
80004892:	f0 1f 00 0c 	mcall	800048c0 <xnl_device_conn_reply_func+0x54>
80004896:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/*connection accepted*/		
		/*Record Transaction ID Base*/
		xnl_information.transaction_id =  
8000489a:	a9 68       	lsl	r8,0x8
8000489c:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
800048a0:	48 98       	lddpc	r8,800048c4 <xnl_device_conn_reply_func+0x58>
800048a2:	b0 49       	st.h	r8[0x8],r9
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
800048a4:	ef 09 00 14 	ld.sh	r9,r7[20]
		xnl_information.transaction_id =  
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
800048a8:	b0 39       	st.h	r8[0x6],r9
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
800048aa:	ef 09 00 12 	ld.sh	r9,r7[18]
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
800048ae:	b0 29       	st.h	r8[0x4],r9
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
		
		/*connect finish*/
		xnl_information.is_connected = TRUE;
800048b0:	30 19       	mov	r9,1
800048b2:	b0 89       	st.b	r8[0x0],r9
800048b4:	e3 cd 80 80 	ldm	sp++,r7,pc
800048b8:	00 00       	add	r0,r0
800048ba:	0b 44       	ld.w	r4,--r5
800048bc:	80 00       	ld.sh	r0,r0[0x0]
800048be:	64 10       	ld.w	r0,r2[0x4]
800048c0:	80 00       	ld.sh	r0,r0[0x0]
800048c2:	48 0c       	lddpc	r12,800048c0 <xnl_device_conn_reply_func+0x54>
800048c4:	00 00       	add	r0,r0
800048c6:	97 24       	st.w	r11[0x8],r4

800048c8 <xnl_send_device_master_query>:
Description: send device_master_query to connect radio.
Calls:xnl_tx
Call By:xnl_init
*/
void xnl_send_device_master_query(void)
{
800048c8:	d4 01       	pushm	lr
800048ca:	fa cd 01 00 	sub	sp,sp,256
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
800048ce:	e0 68 40 0e 	mov	r8,16398
800048d2:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
800048d4:	3f f8       	mov	r8,-1
800048d6:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_MASTER_QUERY;
800048d8:	30 38       	mov	r8,3
800048da:	ba 28       	st.h	sp[0x4],r8
	
	/*The initial value*/
	xnl_frame.xnl_header.flags = 0;
800048dc:	30 08       	mov	r8,0
800048de:	ba 38       	st.h	sp[0x6],r8
	
	/*XNL address of the master device, if known;otherwise 0x0000*/
	xnl_frame.xnl_header.destination = 0;
800048e0:	ba 48       	st.h	sp[0x8],r8
	
	/*XNL address, if assigned; otherwise 0x0000*/
	xnl_frame.xnl_header.source = 0;
800048e2:	ba 58       	st.h	sp[0xa],r8
	
	/*No transaction ID required for this message*/
	xnl_frame.xnl_header.transaction_id = 0;
800048e4:	ba 68       	st.h	sp[0xc],r8
	
	/*This message contains no payload*/
	xnl_frame.xnl_header.payload_length = 0;
800048e6:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
800048e8:	1a 9c       	mov	r12,sp
800048ea:	f0 1f 00 03 	mcall	800048f4 <xnl_send_device_master_query+0x2c>
}
800048ee:	2c 0d       	sub	sp,-256
800048f0:	d8 02       	popm	pc
800048f2:	00 00       	add	r0,r0
800048f4:	80 00       	ld.sh	r0,r0[0x0]
800048f6:	45 a8       	lddsp	r8,sp[0x168]

800048f8 <RC522_SPI_SetSpeed>:
	//SET_SPI_CS;

}

void RC522_SPI_SetSpeed(U16 SPI_BaudRatePrescaler)
{
800048f8:	d4 01       	pushm	lr
	spi->csr0 = (spi->csr0 & (U16)0x00FF) |SPI_BaudRatePrescaler;
800048fa:	48 78       	lddpc	r8,80004914 <RC522_SPI_SetSpeed+0x1c>
800048fc:	70 09       	ld.w	r9,r8[0x0]
800048fe:	72 ca       	ld.w	r10,r9[0x30]
80004900:	5c 7c       	castu.h	r12
80004902:	f5 da c0 08 	bfextu	r10,r10,0x0,0x8
80004906:	f9 ea 10 0a 	or	r10,r12,r10
8000490a:	93 ca       	st.w	r9[0x30],r10

	spi_enable(spi); /*!< SD_SPI enable */
8000490c:	70 0c       	ld.w	r12,r8[0x0]
8000490e:	f0 1f 00 03 	mcall	80004918 <RC522_SPI_SetSpeed+0x20>
		
	
}
80004912:	d8 02       	popm	pc
80004914:	00 00       	add	r0,r0
80004916:	1d ac       	ld.ub	r12,lr[0x2]
80004918:	80 00       	ld.sh	r0,r0[0x0]
8000491a:	59 00       	cp.w	r0,16

8000491c <RC522_SPI_SetSpeedLow>:
void RC522_SPI_SetSpeedLow(void)
{
8000491c:	d4 01       	pushm	lr
	RC522_SPI_SetSpeed(0x0A00);//baudDiv=4
8000491e:	e0 6c 0a 00 	mov	r12,2560
80004922:	f0 1f 00 02 	mcall	80004928 <RC522_SPI_SetSpeedLow+0xc>
	
}
80004926:	d8 02       	popm	pc
80004928:	80 00       	ld.sh	r0,r0[0x0]
8000492a:	48 f8       	lddpc	r8,80004964 <RC522_WriteByte+0xc>

8000492c <RC522_ReadByte>:
	/*!< Return the byte read from the SPI bus */
	return  temp;

}
U8 RC522_ReadByte(void)
{
8000492c:	eb cd 40 c0 	pushm	r6-r7,lr
	//蹇椤昏锋芥ｅ父璇诲
	//spi_selectChip(spi, DF_SPI_PCS_0);
	
	/*!< Send the byte */

	spi_write(spi,  0xFF);
80004930:	48 76       	lddpc	r6,8000494c <RC522_ReadByte+0x20>
80004932:	e0 6b 00 ff 	mov	r11,255
80004936:	6c 0c       	ld.w	r12,r6[0x0]
80004938:	f0 1f 00 06 	mcall	80004950 <RC522_ReadByte+0x24>
	
	/*!< Return the byte read from the SPI bus */

	spi_read(spi, Data);
8000493c:	30 07       	mov	r7,0
8000493e:	0e 9b       	mov	r11,r7
80004940:	6c 0c       	ld.w	r12,r6[0x0]
80004942:	f0 1f 00 05 	mcall	80004954 <RC522_ReadByte+0x28>
	
	//spi_unselectChip(spi, DF_SPI_PCS_0);
	
	return (U8)(*Data);
	
}
80004946:	0f 9c       	ld.ub	r12,r7[0x1]
80004948:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000494c:	00 00       	add	r0,r0
8000494e:	1d ac       	ld.ub	r12,lr[0x2]
80004950:	80 00       	ld.sh	r0,r0[0x0]
80004952:	59 06       	cp.w	r6,16
80004954:	80 00       	ld.sh	r0,r0[0x0]
80004956:	59 22       	cp.w	r2,18

80004958 <RC522_WriteByte>:


U8 rc522_init_failure =0;

U8 RC522_WriteByte(U8 Data)
{
80004958:	eb cd 40 80 	pushm	r7,lr
8000495c:	20 1d       	sub	sp,4
8000495e:	ba 8c       	st.b	sp[0x0],r12
	U8 temp =0;
	
	//spi_selectChip(spi, DF_SPI_PCS_0);
	
	/*!< Send the byte */
	spi_write(spi,  (U16)Data);
80004960:	48 77       	lddpc	r7,8000497c <RC522_WriteByte+0x24>
80004962:	f7 dc c0 08 	bfextu	r11,r12,0x0,0x8
80004966:	6e 0c       	ld.w	r12,r7[0x0]
80004968:	f0 1f 00 06 	mcall	80004980 <RC522_WriteByte+0x28>
	
	/*!< Wait to receive a byte*/

	temp = spi_read(spi, (U16*)&Data);
8000496c:	1a 9b       	mov	r11,sp
8000496e:	6e 0c       	ld.w	r12,r7[0x0]
80004970:	f0 1f 00 05 	mcall	80004984 <RC522_WriteByte+0x2c>
	//spi_unselectChip(spi, DF_SPI_PCS_0);
	
	/*!< Return the byte read from the SPI bus */
	return  temp;

}
80004974:	5c 5c       	castu.b	r12
80004976:	2f fd       	sub	sp,-4
80004978:	e3 cd 80 80 	ldm	sp++,r7,pc
8000497c:	00 00       	add	r0,r0
8000497e:	1d ac       	ld.ub	r12,lr[0x2]
80004980:	80 00       	ld.sh	r0,r0[0x0]
80004982:	59 06       	cp.w	r6,16
80004984:	80 00       	ld.sh	r0,r0[0x0]
80004986:	59 22       	cp.w	r2,18

80004988 <WriteRawRC>:
//    斤RC632瀵瀛
//拌存锛Address[IN]:瀵瀛ㄥ板
//          value[IN]:ョ
/////////////////////////////////////////////////////////////////////
void WriteRawRC(U8   Address, U8   value)
{
80004988:	eb cd 40 e0 	pushm	r5-r7,lr
8000498c:	18 96       	mov	r6,r12
8000498e:	16 95       	mov	r5,r11
	U8   ucAddr;

	//CLR_SPI_CS;	
	spi_selectChip(spi, DF_SPI_PCS_0);
80004990:	48 a7       	lddpc	r7,800049b8 <WriteRawRC+0x30>
80004992:	30 0b       	mov	r11,0
80004994:	6e 0c       	ld.w	r12,r7[0x0]
80004996:	f0 1f 00 0a 	mcall	800049bc <WriteRawRC+0x34>
	
	ucAddr = ((Address<<1)&0x7E);
	RC522_WriteByte(ucAddr);
8000499a:	ec 0c 15 01 	lsl	r12,r6,0x1
8000499e:	e2 1c 00 7e 	andl	r12,0x7e,COH
800049a2:	f0 1f 00 08 	mcall	800049c0 <WriteRawRC+0x38>
	RC522_WriteByte(value);
800049a6:	0a 9c       	mov	r12,r5
800049a8:	f0 1f 00 06 	mcall	800049c0 <WriteRawRC+0x38>
	
	spi_unselectChip(spi, DF_SPI_PCS_0);
800049ac:	30 0b       	mov	r11,0
800049ae:	6e 0c       	ld.w	r12,r7[0x0]
800049b0:	f0 1f 00 05 	mcall	800049c4 <WriteRawRC+0x3c>
	
	//SET_SPI_CS;

}
800049b4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800049b8:	00 00       	add	r0,r0
800049ba:	1d ac       	ld.ub	r12,lr[0x2]
800049bc:	80 00       	ld.sh	r0,r0[0x0]
800049be:	5a 6c       	cp.w	r12,-26
800049c0:	80 00       	ld.sh	r0,r0[0x0]
800049c2:	49 58       	lddpc	r8,80004a14 <PcdReset+0x4c>
800049c4:	80 00       	ld.sh	r0,r0[0x0]
800049c6:	5a 2c       	cp.w	r12,-30

800049c8 <PcdReset>:
/////////////////////////////////////////////////////////////////////
//    斤澶浣RC522
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdReset(void)
{
800049c8:	d4 01       	pushm	lr

	SET_RC522RST;
800049ca:	31 9c       	mov	r12,25
800049cc:	f0 1f 00 1b 	mcall	80004a38 <PcdReset+0x70>
	delay_ns(10);
800049d0:	30 ac       	mov	r12,10
800049d2:	f0 1f 00 1b 	mcall	80004a3c <PcdReset+0x74>

	CLR_RC522RST;
800049d6:	31 9c       	mov	r12,25
800049d8:	f0 1f 00 1a 	mcall	80004a40 <PcdReset+0x78>
	delay_ns(10);
800049dc:	30 ac       	mov	r12,10
800049de:	f0 1f 00 18 	mcall	80004a3c <PcdReset+0x74>

	SET_RC522RST;
800049e2:	31 9c       	mov	r12,25
800049e4:	f0 1f 00 15 	mcall	80004a38 <PcdReset+0x70>
	delay_ns(10);
800049e8:	30 ac       	mov	r12,10
800049ea:	f0 1f 00 15 	mcall	80004a3c <PcdReset+0x74>
	WriteRawRC(CommandReg,PCD_RESETPHASE);
800049ee:	30 fb       	mov	r11,15
800049f0:	30 1c       	mov	r12,1
800049f2:	f0 1f 00 15 	mcall	80004a44 <PcdReset+0x7c>
	WriteRawRC(CommandReg,PCD_RESETPHASE);
800049f6:	30 fb       	mov	r11,15
800049f8:	30 1c       	mov	r12,1
800049fa:	f0 1f 00 13 	mcall	80004a44 <PcdReset+0x7c>
	delay_ns(10);
800049fe:	30 ac       	mov	r12,10
80004a00:	f0 1f 00 0f 	mcall	80004a3c <PcdReset+0x74>
	
	WriteRawRC(ModeReg,0x3D);            //Mifare￠璁锛CRC濮0x6363
80004a04:	33 db       	mov	r11,61
80004a06:	31 1c       	mov	r12,17
80004a08:	f0 1f 00 0f 	mcall	80004a44 <PcdReset+0x7c>
	WriteRawRC(TReloadRegL,30);
80004a0c:	31 eb       	mov	r11,30
80004a0e:	32 dc       	mov	r12,45
80004a10:	f0 1f 00 0d 	mcall	80004a44 <PcdReset+0x7c>
	WriteRawRC(TReloadRegH,0);
80004a14:	30 0b       	mov	r11,0
80004a16:	32 cc       	mov	r12,44
80004a18:	f0 1f 00 0b 	mcall	80004a44 <PcdReset+0x7c>
	WriteRawRC(TModeReg,0x8D);
80004a1c:	e0 6b 00 8d 	mov	r11,141
80004a20:	32 ac       	mov	r12,42
80004a22:	f0 1f 00 09 	mcall	80004a44 <PcdReset+0x7c>
	WriteRawRC(TPrescalerReg,0x3E);
80004a26:	33 eb       	mov	r11,62
80004a28:	32 bc       	mov	r12,43
80004a2a:	f0 1f 00 07 	mcall	80004a44 <PcdReset+0x7c>
	
	WriteRawRC(TxAutoReg,0x40);//蹇椤昏
80004a2e:	34 0b       	mov	r11,64
80004a30:	31 5c       	mov	r12,21
80004a32:	f0 1f 00 05 	mcall	80004a44 <PcdReset+0x7c>
	
	return MI_OK;
}
80004a36:	d8 0a       	popm	pc,r12=0
80004a38:	80 00       	ld.sh	r0,r0[0x0]
80004a3a:	55 e4       	stdsp	sp[0x178],r4
80004a3c:	80 00       	ld.sh	r0,r0[0x0]
80004a3e:	53 84       	stdsp	sp[0xe0],r4
80004a40:	80 00       	ld.sh	r0,r0[0x0]
80004a42:	56 00       	stdsp	sp[0x180],r0
80004a44:	80 00       	ld.sh	r0,r0[0x0]
80004a46:	49 88       	lddpc	r8,80004aa4 <Powerdown_RC522+0x4>

80004a48 <ReadRawRC>:
//    斤璇RC632瀵瀛
//拌存锛Address[IN]:瀵瀛ㄥ板
//杩    锛璇诲虹
/////////////////////////////////////////////////////////////////////
U8 ReadRawRC(U8   Address)
{
80004a48:	eb cd 40 c0 	pushm	r6-r7,lr
80004a4c:	18 96       	mov	r6,r12
	U8   ucAddr;
	U8   ucResult=0;
	//CLR_SPI_CS;	
	spi_selectChip(spi, DF_SPI_PCS_0);
80004a4e:	48 c7       	lddpc	r7,80004a7c <ReadRawRC+0x34>
80004a50:	30 0b       	mov	r11,0
80004a52:	6e 0c       	ld.w	r12,r7[0x0]
80004a54:	f0 1f 00 0b 	mcall	80004a80 <ReadRawRC+0x38>
	 
	ucAddr = ((Address<<1)&0x7E)|0x80;
	
	RC522_WriteByte(ucAddr);
80004a58:	a1 76       	lsl	r6,0x1
80004a5a:	0c 9c       	mov	r12,r6
80004a5c:	e2 1c 00 7e 	andl	r12,0x7e,COH
80004a60:	a7 bc       	sbr	r12,0x7
80004a62:	f0 1f 00 09 	mcall	80004a84 <ReadRawRC+0x3c>
	ucResult = RC522_ReadByte();
80004a66:	f0 1f 00 09 	mcall	80004a88 <ReadRawRC+0x40>
80004a6a:	18 96       	mov	r6,r12
	
	spi_unselectChip(spi, DF_SPI_PCS_0);
80004a6c:	30 0b       	mov	r11,0
80004a6e:	6e 0c       	ld.w	r12,r7[0x0]
80004a70:	f0 1f 00 07 	mcall	80004a8c <ReadRawRC+0x44>
	//SET_SPI_CS;
	return ucResult;
}
80004a74:	0c 9c       	mov	r12,r6
80004a76:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004a7a:	00 00       	add	r0,r0
80004a7c:	00 00       	add	r0,r0
80004a7e:	1d ac       	ld.ub	r12,lr[0x2]
80004a80:	80 00       	ld.sh	r0,r0[0x0]
80004a82:	5a 6c       	cp.w	r12,-26
80004a84:	80 00       	ld.sh	r0,r0[0x0]
80004a86:	49 58       	lddpc	r8,80004ad8 <Powerdown_RC522+0x38>
80004a88:	80 00       	ld.sh	r0,r0[0x0]
80004a8a:	49 2c       	lddpc	r12,80004ad0 <Powerdown_RC522+0x30>
80004a8c:	80 00       	ld.sh	r0,r0[0x0]
80004a8e:	5a 2c       	cp.w	r12,-30

80004a90 <Wait_Wakeup_RC522>:

/////////////////////////////////////////////////////////////////////
//    斤绛寰RC522
/////////////////////////////////////////////////////////////////////
void Wait_Wakeup_RC522(void)
{
80004a90:	d4 01       	pushm	lr
	char   tmp = 0x0;
	char   reg = CommandReg;
	
	do 
	{
		tmp = ReadRawRC(reg);
80004a92:	30 1c       	mov	r12,1
80004a94:	f0 1f 00 02 	mcall	80004a9c <Wait_Wakeup_RC522+0xc>
			
	//tmp = ReadRawRC(reg);
	//if((tmp & 0x10) == 0)
	//WriteRawRC(reg,tmp | PCD_POWERDOWN);  // set bit powerdown
	
}
80004a98:	d8 02       	popm	pc
80004a9a:	00 00       	add	r0,r0
80004a9c:	80 00       	ld.sh	r0,r0[0x0]
80004a9e:	4a 48       	lddpc	r8,80004b2c <PcdAntennaOn+0x1c>

80004aa0 <Powerdown_RC522>:
/////////////////////////////////////////////////////////////////////
//    斤浣RC522杩ヨ蒋垫ā寮
//
/////////////////////////////////////////////////////////////////////
void Powerdown_RC522(U8 act)
{
80004aa0:	eb cd 40 80 	pushm	r7,lr
80004aa4:	18 97       	mov	r7,r12
	char   tmp = 0x0;
	char   reg = CommandReg;
	
	tmp = ReadRawRC(reg);
80004aa6:	30 1c       	mov	r12,1
80004aa8:	f0 1f 00 0d 	mcall	80004adc <Powerdown_RC522+0x3c>
	if(act == ENTER_POWERDOWN)//1
80004aac:	30 18       	mov	r8,1
80004aae:	f0 07 18 00 	cp.b	r7,r8
80004ab2:	c0 91       	brne	80004ac4 <Powerdown_RC522+0x24>
		WriteRawRC(reg,tmp | PCD_POWERDOWN);  // set bit powerdown
80004ab4:	18 9b       	mov	r11,r12
80004ab6:	a5 ab       	sbr	r11,0x4
80004ab8:	5c 5b       	castu.b	r11
80004aba:	30 1c       	mov	r12,1
80004abc:	f0 1f 00 09 	mcall	80004ae0 <Powerdown_RC522+0x40>
80004ac0:	e3 cd 80 80 	ldm	sp++,r7,pc
	else
	{
		WriteRawRC(reg,tmp | PCD_IDLE);  // wake up rc522
80004ac4:	18 9b       	mov	r11,r12
80004ac6:	30 1c       	mov	r12,1
80004ac8:	f0 1f 00 06 	mcall	80004ae0 <Powerdown_RC522+0x40>
		delay_ns(2);
80004acc:	30 2c       	mov	r12,2
80004ace:	f0 1f 00 06 	mcall	80004ae4 <Powerdown_RC522+0x44>
		Wait_Wakeup_RC522();
80004ad2:	f0 1f 00 06 	mcall	80004ae8 <Powerdown_RC522+0x48>
80004ad6:	e3 cd 80 80 	ldm	sp++,r7,pc
80004ada:	00 00       	add	r0,r0
80004adc:	80 00       	ld.sh	r0,r0[0x0]
80004ade:	4a 48       	lddpc	r8,80004b6c <M500PcdConfigISOType+0x4>
80004ae0:	80 00       	ld.sh	r0,r0[0x0]
80004ae2:	49 88       	lddpc	r8,80004b40 <ClearBitMask+0x10>
80004ae4:	80 00       	ld.sh	r0,r0[0x0]
80004ae6:	53 84       	stdsp	sp[0xe0],r4
80004ae8:	80 00       	ld.sh	r0,r0[0x0]
80004aea:	4a 90       	lddpc	r0,80004b8c <M500PcdConfigISOType+0x24>

80004aec <SetBitMask>:
//    斤缃RC522瀵瀛ㄤ
//拌存锛reg[IN]:瀵瀛ㄥ板
//          mask[IN]:缃浣
/////////////////////////////////////////////////////////////////////
void SetBitMask(U8   reg,U8   mask)
{
80004aec:	eb cd 40 c0 	pushm	r6-r7,lr
80004af0:	18 97       	mov	r7,r12
80004af2:	16 96       	mov	r6,r11
	char   tmp = 0x0;
	tmp = ReadRawRC(reg);
80004af4:	f0 1f 00 05 	mcall	80004b08 <SetBitMask+0x1c>
	WriteRawRC(reg,tmp | mask);  // set bit mask
80004af8:	f9 e6 10 0b 	or	r11,r12,r6
80004afc:	5c 5b       	castu.b	r11
80004afe:	0e 9c       	mov	r12,r7
80004b00:	f0 1f 00 03 	mcall	80004b0c <SetBitMask+0x20>
}
80004b04:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004b08:	80 00       	ld.sh	r0,r0[0x0]
80004b0a:	4a 48       	lddpc	r8,80004b98 <M500PcdConfigISOType+0x30>
80004b0c:	80 00       	ld.sh	r0,r0[0x0]
80004b0e:	49 88       	lddpc	r8,80004b6c <M500PcdConfigISOType+0x4>

80004b10 <PcdAntennaOn>:
/////////////////////////////////////////////////////////////////////
//寮澶╃嚎
//姣娆″ㄦ抽澶╅╁灏涔村冲1ms撮
/////////////////////////////////////////////////////////////////////
void PcdAntennaOn(void)
{
80004b10:	d4 01       	pushm	lr
	U8   i;
	i = ReadRawRC(TxControlReg);
80004b12:	31 4c       	mov	r12,20
80004b14:	f0 1f 00 05 	mcall	80004b28 <PcdAntennaOn+0x18>
	if (!(i & 0x03))
80004b18:	f9 dc c0 02 	bfextu	r12,r12,0x0,0x2
80004b1c:	c0 51       	brne	80004b26 <PcdAntennaOn+0x16>
	{
		SetBitMask(TxControlReg, 0x03);
80004b1e:	30 3b       	mov	r11,3
80004b20:	31 4c       	mov	r12,20
80004b22:	f0 1f 00 03 	mcall	80004b2c <PcdAntennaOn+0x1c>
80004b26:	d8 02       	popm	pc
80004b28:	80 00       	ld.sh	r0,r0[0x0]
80004b2a:	4a 48       	lddpc	r8,80004bb8 <M500PcdConfigISOType+0x50>
80004b2c:	80 00       	ld.sh	r0,r0[0x0]
80004b2e:	4a ec       	lddpc	r12,80004be4 <rc522_init+0xc>

80004b30 <ClearBitMask>:
//    斤娓RC522瀵瀛ㄤ
//拌存锛reg[IN]:瀵瀛ㄥ板
//         mask[IN]:娓浣
/////////////////////////////////////////////////////////////////////
void ClearBitMask(U8   reg,U8   mask)
{
80004b30:	eb cd 40 c0 	pushm	r6-r7,lr
80004b34:	18 97       	mov	r7,r12
80004b36:	16 96       	mov	r6,r11
	  char   tmp = 0x0;
	  tmp = ReadRawRC(reg);
80004b38:	f0 1f 00 06 	mcall	80004b50 <ClearBitMask+0x20>
	  WriteRawRC(reg, tmp & ~mask);  // clear bit mask
80004b3c:	5c d6       	com	r6
80004b3e:	f9 e6 00 06 	and	r6,r12,r6
80004b42:	f7 d6 c0 08 	bfextu	r11,r6,0x0,0x8
80004b46:	0e 9c       	mov	r12,r7
80004b48:	f0 1f 00 03 	mcall	80004b54 <ClearBitMask+0x24>
	
}
80004b4c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004b50:	80 00       	ld.sh	r0,r0[0x0]
80004b52:	4a 48       	lddpc	r8,80004be0 <rc522_init+0x8>
80004b54:	80 00       	ld.sh	r0,r0[0x0]
80004b56:	49 88       	lddpc	r8,80004bb4 <M500PcdConfigISOType+0x4c>

80004b58 <PcdAntennaOff>:

/////////////////////////////////////////////////////////////////////
//抽澶╃嚎
/////////////////////////////////////////////////////////////////////
void PcdAntennaOff(void)
{
80004b58:	d4 01       	pushm	lr
	ClearBitMask(TxControlReg, 0x03);
80004b5a:	30 3b       	mov	r11,3
80004b5c:	31 4c       	mov	r12,20
80004b5e:	f0 1f 00 02 	mcall	80004b64 <PcdAntennaOff+0xc>
}
80004b62:	d8 02       	popm	pc
80004b64:	80 00       	ld.sh	r0,r0[0x0]
80004b66:	4b 30       	lddpc	r0,80004c30 <rc522_init+0x58>

80004b68 <M500PcdConfigISOType>:

//////////////////////////////////////////////////////////////////////
//璁剧疆RC632宸ヤ瑰
//////////////////////////////////////////////////////////////////////
char M500PcdConfigISOType(U8   type)
{
80004b68:	d4 01       	pushm	lr
	if (type == 'A')                     //ISO14443_A
80004b6a:	34 18       	mov	r8,65
80004b6c:	f0 0c 18 00 	cp.b	r12,r8
80004b70:	c0 20       	breq	80004b74 <M500PcdConfigISOType+0xc>
80004b72:	da 0a       	popm	pc,r12=1
	{
		ClearBitMask(Status2Reg,0x08);
80004b74:	30 8b       	mov	r11,8
80004b76:	16 9c       	mov	r12,r11
80004b78:	f0 1f 00 14 	mcall	80004bc8 <M500PcdConfigISOType+0x60>
		WriteRawRC(ModeReg,0x3D);//3F
80004b7c:	33 db       	mov	r11,61
80004b7e:	31 1c       	mov	r12,17
80004b80:	f0 1f 00 13 	mcall	80004bcc <M500PcdConfigISOType+0x64>
		WriteRawRC(RxSelReg,0x86);//84
80004b84:	e0 6b 00 86 	mov	r11,134
80004b88:	31 7c       	mov	r12,23
80004b8a:	f0 1f 00 11 	mcall	80004bcc <M500PcdConfigISOType+0x64>
		WriteRawRC(RFCfgReg,0x7F);   //4F
80004b8e:	37 fb       	mov	r11,127
80004b90:	32 6c       	mov	r12,38
80004b92:	f0 1f 00 0f 	mcall	80004bcc <M500PcdConfigISOType+0x64>
		WriteRawRC(TReloadRegL,30);//tmoLength);// TReloadVal = 'h6a =tmoLength(dec)
80004b96:	31 eb       	mov	r11,30
80004b98:	32 dc       	mov	r12,45
80004b9a:	f0 1f 00 0d 	mcall	80004bcc <M500PcdConfigISOType+0x64>
		WriteRawRC(TReloadRegH,0);
80004b9e:	30 0b       	mov	r11,0
80004ba0:	32 cc       	mov	r12,44
80004ba2:	f0 1f 00 0b 	mcall	80004bcc <M500PcdConfigISOType+0x64>
		WriteRawRC(TModeReg,0x8D);
80004ba6:	e0 6b 00 8d 	mov	r11,141
80004baa:	32 ac       	mov	r12,42
80004bac:	f0 1f 00 08 	mcall	80004bcc <M500PcdConfigISOType+0x64>
		WriteRawRC(TPrescalerReg,0x3E);
80004bb0:	33 eb       	mov	r11,62
80004bb2:	32 bc       	mov	r12,43
80004bb4:	f0 1f 00 06 	mcall	80004bcc <M500PcdConfigISOType+0x64>
		delay_ns(1000);
80004bb8:	e0 6c 03 e8 	mov	r12,1000
80004bbc:	f0 1f 00 05 	mcall	80004bd0 <M500PcdConfigISOType+0x68>
		PcdAntennaOn();
80004bc0:	f0 1f 00 05 	mcall	80004bd4 <M500PcdConfigISOType+0x6c>
80004bc4:	d8 0a       	popm	pc,r12=0
80004bc6:	00 00       	add	r0,r0
80004bc8:	80 00       	ld.sh	r0,r0[0x0]
80004bca:	4b 30       	lddpc	r0,80004c94 <rc522_init+0xbc>
80004bcc:	80 00       	ld.sh	r0,r0[0x0]
80004bce:	49 88       	lddpc	r8,80004c2c <rc522_init+0x54>
80004bd0:	80 00       	ld.sh	r0,r0[0x0]
80004bd2:	53 84       	stdsp	sp[0xe0],r4
80004bd4:	80 00       	ld.sh	r0,r0[0x0]
80004bd6:	4b 10       	lddpc	r0,80004c98 <rc522_init+0xc0>

80004bd8 <rc522_init>:


//mfrc522 init

void rc522_init()
{
80004bd8:	eb cd 40 c0 	pushm	r6-r7,lr
80004bdc:	20 4d       	sub	sp,16
		.spck_delay   = 0,
		.trans_delay  = 0,
		.stay_act     = 1,
		.spi_mode     = 0,
		.modfdis      = 1
	};
80004bde:	4a 38       	lddpc	r8,80004c68 <rc522_init+0x90>
80004be0:	1a 96       	mov	r6,sp
80004be2:	f0 ea 00 00 	ld.d	r10,r8[0]
80004be6:	fa eb 00 00 	st.d	sp[0],r10
80004bea:	f0 e8 00 08 	ld.d	r8,r8[8]
80004bee:	fa e9 00 08 	st.d	sp[8],r8

	// Assign I/Os to SPI.
	gpio_enable_module(RC522_SPI_GPIO_MAP, sizeof(RC522_SPI_GPIO_MAP) / sizeof(RC522_SPI_GPIO_MAP[0]));
80004bf2:	30 4b       	mov	r11,4
80004bf4:	49 ec       	lddpc	r12,80004c6c <rc522_init+0x94>
80004bf6:	f0 1f 00 1f 	mcall	80004c70 <rc522_init+0x98>

	// Configure PA25 as RST pin
	gpio_enable_gpio_pin(AVR32_PIN_PA25);
80004bfa:	31 9c       	mov	r12,25
80004bfc:	f0 1f 00 1e 	mcall	80004c74 <rc522_init+0x9c>
	gpio_set_gpio_pin(AVR32_PIN_PA25);
80004c00:	31 9c       	mov	r12,25
80004c02:	f0 1f 00 1e 	mcall	80004c78 <rc522_init+0xa0>

	spi = &AVR32_SPI;
80004c06:	49 e7       	lddpc	r7,80004c7c <rc522_init+0xa4>
80004c08:	fe 7c 24 00 	mov	r12,-56320
80004c0c:	8f 0c       	st.w	r7[0x0],r12

	// Initialize as master.
	spi_initMaster(spi, &spiOptions);
80004c0e:	1a 9b       	mov	r11,sp
80004c10:	f0 1f 00 1c 	mcall	80004c80 <rc522_init+0xa8>

	// Set selection mode: variable_ps, pcs_decode, delay.
	spi_selectionMode(spi, 0, 0, 0);
80004c14:	30 09       	mov	r9,0
80004c16:	12 9a       	mov	r10,r9
80004c18:	12 9b       	mov	r11,r9
80004c1a:	6e 0c       	ld.w	r12,r7[0x0]
80004c1c:	f0 1f 00 1a 	mcall	80004c84 <rc522_init+0xac>

	// Enable SPI.
	spi_enable(spi);
80004c20:	6e 0c       	ld.w	r12,r7[0x0]
80004c22:	f0 1f 00 1a 	mcall	80004c88 <rc522_init+0xb0>

	// Initialize RC522 with SPI clock PBA.
	if (spi_setupChipReg(spi, &spiOptions, 2*12000000) != SPI_OK)
80004c26:	e0 6a 36 00 	mov	r10,13824
80004c2a:	ea 1a 01 6e 	orh	r10,0x16e
80004c2e:	1a 9b       	mov	r11,sp
80004c30:	6e 0c       	ld.w	r12,r7[0x0]
80004c32:	f0 1f 00 17 	mcall	80004c8c <rc522_init+0xb4>
80004c36:	c0 50       	breq	80004c40 <rc522_init+0x68>
	{
		
		rc522_init_failure = FATAL_ERROR_RC522_SPI_INIT;
80004c38:	30 29       	mov	r9,2
80004c3a:	49 68       	lddpc	r8,80004c90 <rc522_init+0xb8>
80004c3c:	b0 89       	st.b	r8[0x0],r9
80004c3e:	c0 38       	rjmp	80004c44 <rc522_init+0x6c>
		return;
	}
	
	RC522_SPI_SetSpeedLow();
80004c40:	f0 1f 00 15 	mcall	80004c94 <rc522_init+0xbc>
void rc522_init()
{
	
	spi_init();
	
	PcdReset();
80004c44:	f0 1f 00 15 	mcall	80004c98 <rc522_init+0xc0>
	
	PcdAntennaOff();
80004c48:	f0 1f 00 15 	mcall	80004c9c <rc522_init+0xc4>
	
	delay_ms(2); 
80004c4c:	30 2c       	mov	r12,2
80004c4e:	f0 1f 00 15 	mcall	80004ca0 <rc522_init+0xc8>
	
	PcdAntennaOn();
80004c52:	f0 1f 00 15 	mcall	80004ca4 <rc522_init+0xcc>
	
	M500PcdConfigISOType( 'A' );
80004c56:	34 1c       	mov	r12,65
80004c58:	f0 1f 00 14 	mcall	80004ca8 <rc522_init+0xd0>
	
	Powerdown_RC522(ENTER_POWERDOWN);
80004c5c:	30 1c       	mov	r12,1
80004c5e:	f0 1f 00 14 	mcall	80004cac <rc522_init+0xd4>
	//Powerdown_RC522(ENTER_POWERDOWN);
	
	//Powerdown_RC522(WAKEUP_RC522);
	

80004c62:	2f cd       	sub	sp,-16
80004c64:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004c68:	80 00       	ld.sh	r0,r0[0x0]
80004c6a:	d8 88       	*unknown*
80004c6c:	80 00       	ld.sh	r0,r0[0x0]
80004c6e:	d8 68       	*unknown*
80004c70:	80 00       	ld.sh	r0,r0[0x0]
80004c72:	55 9c       	stdsp	sp[0x164],r12
80004c74:	80 00       	ld.sh	r0,r0[0x0]
80004c76:	55 cc       	stdsp	sp[0x170],r12
80004c78:	80 00       	ld.sh	r0,r0[0x0]
80004c7a:	55 e4       	stdsp	sp[0x178],r4
80004c7c:	00 00       	add	r0,r0
80004c7e:	1d ac       	ld.ub	r12,lr[0x2]
80004c80:	80 00       	ld.sh	r0,r0[0x0]
80004c82:	58 9c       	cp.w	r12,9
80004c84:	80 00       	ld.sh	r0,r0[0x0]
80004c86:	58 d4       	cp.w	r4,13
80004c88:	80 00       	ld.sh	r0,r0[0x0]
80004c8a:	59 00       	cp.w	r0,16
80004c8c:	80 00       	ld.sh	r0,r0[0x0]
80004c8e:	59 44       	cp.w	r4,20
80004c90:	00 00       	add	r0,r0
80004c92:	0b 60       	ld.uh	r0,--r5
80004c94:	80 00       	ld.sh	r0,r0[0x0]
80004c96:	49 1c       	lddpc	r12,80004cd8 <PcdComMF522+0x28>
80004c98:	80 00       	ld.sh	r0,r0[0x0]
80004c9a:	49 c8       	lddpc	r8,80004d08 <PcdComMF522+0x58>
80004c9c:	80 00       	ld.sh	r0,r0[0x0]
80004c9e:	4b 58       	lddpc	r8,80004d70 <PcdComMF522+0xc0>
80004ca0:	80 00       	ld.sh	r0,r0[0x0]
80004ca2:	53 c4       	stdsp	sp[0xf0],r4
80004ca4:	80 00       	ld.sh	r0,r0[0x0]
80004ca6:	4b 10       	lddpc	r0,80004d68 <PcdComMF522+0xb8>
80004ca8:	80 00       	ld.sh	r0,r0[0x0]
80004caa:	4b 68       	lddpc	r8,80004d80 <PcdComMF522+0xd0>
80004cac:	80 00       	ld.sh	r0,r0[0x0]
80004cae:	4a a0       	lddpc	r0,80004d54 <PcdComMF522+0xa4>

80004cb0 <PcdComMF522>:
char PcdComMF522(U8  Command,
				 U8 *pIn ,
				 U8  InLenByte,
				 U8 *pOut ,
				 U8 *pOutLenBit)
{
80004cb0:	d4 31       	pushm	r0-r7,lr
80004cb2:	20 1d       	sub	sp,4
80004cb4:	18 92       	mov	r2,r12
80004cb6:	16 95       	mov	r5,r11
80004cb8:	14 96       	mov	r6,r10
80004cba:	50 09       	stdsp	sp[0x0],r9
80004cbc:	10 90       	mov	r0,r8
80004cbe:	f8 c8 00 0c 	sub	r8,r12,12
80004cc2:	5c 58       	castu.b	r8
80004cc4:	30 29       	mov	r9,2
80004cc6:	f2 08 18 00 	cp.b	r8,r9
80004cca:	e0 88 00 05 	brls	80004cd4 <PcdComMF522+0x24>
80004cce:	30 03       	mov	r3,0
80004cd0:	06 91       	mov	r1,r3
80004cd2:	c0 78       	rjmp	80004ce0 <PcdComMF522+0x30>
80004cd4:	4c f9       	lddpc	r9,80004e10 <PcdComMF522+0x160>
80004cd6:	f2 08 07 01 	ld.ub	r1,r9[r8]
80004cda:	4c f9       	lddpc	r9,80004e14 <PcdComMF522+0x164>
80004cdc:	f2 08 07 03 	ld.ub	r3,r9[r8]
		break;
		default:
		break;
	}
	
	WriteRawRC(ComIEnReg,irqEn|0x80);
80004ce0:	02 9b       	mov	r11,r1
80004ce2:	a7 bb       	sbr	r11,0x7
80004ce4:	30 2c       	mov	r12,2
80004ce6:	f0 1f 00 4d 	mcall	80004e18 <PcdComMF522+0x168>
	ClearBitMask(ComIrqReg,0x80);	//娓涓浣
80004cea:	e0 6b 00 80 	mov	r11,128
80004cee:	30 4c       	mov	r12,4
80004cf0:	f0 1f 00 4b 	mcall	80004e1c <PcdComMF522+0x16c>
	WriteRawRC(CommandReg,PCD_IDLE);
80004cf4:	30 0b       	mov	r11,0
80004cf6:	30 1c       	mov	r12,1
80004cf8:	f0 1f 00 48 	mcall	80004e18 <PcdComMF522+0x168>
	SetBitMask(FIFOLevelReg,0x80);	 	//娓FIFO缂瀛
80004cfc:	e0 6b 00 80 	mov	r11,128
80004d00:	30 ac       	mov	r12,10
80004d02:	f0 1f 00 48 	mcall	80004e20 <PcdComMF522+0x170>
	
	for (i=0; i<InLenByte; i++)
80004d06:	58 06       	cp.w	r6,0
80004d08:	c0 c0       	breq	80004d20 <PcdComMF522+0x70>
80004d0a:	0a 97       	mov	r7,r5
	{   
		WriteRawRC(FIFODataReg, pIn [i]);
80004d0c:	30 94       	mov	r4,9
80004d0e:	0f 3b       	ld.ub	r11,r7++
80004d10:	08 9c       	mov	r12,r4
80004d12:	f0 1f 00 42 	mcall	80004e18 <PcdComMF522+0x168>
	WriteRawRC(ComIEnReg,irqEn|0x80);
	ClearBitMask(ComIrqReg,0x80);	//娓涓浣
	WriteRawRC(CommandReg,PCD_IDLE);
	SetBitMask(FIFOLevelReg,0x80);	 	//娓FIFO缂瀛
	
	for (i=0; i<InLenByte; i++)
80004d16:	0e 98       	mov	r8,r7
80004d18:	0a 18       	sub	r8,r5
80004d1a:	ec 08 19 00 	cp.h	r8,r6
80004d1e:	cf 83       	brcs	80004d0e <PcdComMF522+0x5e>
	{   
		WriteRawRC(FIFODataReg, pIn [i]);
	}
	WriteRawRC(CommandReg, Command);
80004d20:	04 9b       	mov	r11,r2
80004d22:	30 1c       	mov	r12,1
80004d24:	f0 1f 00 3d 	mcall	80004e18 <PcdComMF522+0x168>
	
	if (Command == PCD_TRANSCEIVE)
80004d28:	30 c8       	mov	r8,12
80004d2a:	f0 02 18 00 	cp.b	r2,r8
80004d2e:	c0 61       	brne	80004d3a <PcdComMF522+0x8a>
	{    
		SetBitMask(BitFramingReg,0x80);  
80004d30:	e0 6b 00 80 	mov	r11,128
80004d34:	30 dc       	mov	r12,13
80004d36:	f0 1f 00 3b 	mcall	80004e20 <PcdComMF522+0x170>
	
	//i = 600;//规堕棰璋达浣M1℃澶х寰堕25ms
	i = 2000;
	do
	{
		n = ReadRawRC(ComIrqReg);
80004d3a:	30 4c       	mov	r12,4
80004d3c:	f0 1f 00 3a 	mcall	80004e24 <PcdComMF522+0x174>
80004d40:	18 97       	mov	r7,r12
80004d42:	e0 66 07 cf 	mov	r6,1999
		i--;
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
80004d46:	30 05       	mov	r5,0
	
	//i = 600;//规堕棰璋达浣M1℃澶х寰堕25ms
	i = 2000;
	do
	{
		n = ReadRawRC(ComIrqReg);
80004d48:	30 44       	mov	r4,4
80004d4a:	c0 88       	rjmp	80004d5a <PcdComMF522+0xaa>
80004d4c:	08 9c       	mov	r12,r4
80004d4e:	f0 1f 00 36 	mcall	80004e24 <PcdComMF522+0x174>
80004d52:	18 97       	mov	r7,r12
		i--;
80004d54:	20 16       	sub	r6,1
80004d56:	5c 86       	casts.h	r6
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
80004d58:	c0 a0       	breq	80004d6c <PcdComMF522+0xbc>
80004d5a:	f1 d7 c0 01 	bfextu	r8,r7,0x0,0x1
80004d5e:	c4 c1       	brne	80004df6 <PcdComMF522+0x146>
80004d60:	ef e3 00 08 	and	r8,r7,r3
80004d64:	ea 08 18 00 	cp.b	r8,r5
80004d68:	cf 20       	breq	80004d4c <PcdComMF522+0x9c>
80004d6a:	c4 68       	rjmp	80004df6 <PcdComMF522+0x146>
	ClearBitMask(BitFramingReg,0x80);
80004d6c:	e0 6b 00 80 	mov	r11,128
80004d70:	30 dc       	mov	r12,13
80004d72:	f0 1f 00 2b 	mcall	80004e1c <PcdComMF522+0x16c>
80004d76:	30 27       	mov	r7,2
80004d78:	c3 38       	rjmp	80004dde <PcdComMF522+0x12e>
80004d7a:	02 67       	and	r7,r1
80004d7c:	ef d7 c0 01 	bfextu	r7,r7,0x0,0x1
		if(!(ReadRawRC(ErrorReg)&0x1B))
		{
			status = MI_OK;
			if (n & irqEn & 0x01)
			{   status = MI_NOTAGERR;   }
			if (Command == PCD_TRANSCEIVE)
80004d80:	30 c8       	mov	r8,12
80004d82:	f0 02 18 00 	cp.b	r2,r8
80004d86:	c2 c1       	brne	80004dde <PcdComMF522+0x12e>
			{
				n = ReadRawRC(FIFOLevelReg);
80004d88:	30 ac       	mov	r12,10
80004d8a:	f0 1f 00 27 	mcall	80004e24 <PcdComMF522+0x174>
80004d8e:	18 94       	mov	r4,r12
				lastBits = ReadRawRC(ControlReg) & 0x07;
80004d90:	30 cc       	mov	r12,12
80004d92:	f0 1f 00 25 	mcall	80004e24 <PcdComMF522+0x174>
80004d96:	f9 dc c0 03 	bfextu	r12,r12,0x0,0x3
				if (lastBits)
80004d9a:	c0 70       	breq	80004da8 <PcdComMF522+0xf8>
				{   *pOutLenBit = (n-1)*8 + lastBits;   }
80004d9c:	08 98       	mov	r8,r4
80004d9e:	20 18       	sub	r8,1
80004da0:	f8 08 00 3c 	add	r12,r12,r8<<0x3
80004da4:	a0 8c       	st.b	r0[0x0],r12
80004da6:	c0 48       	rjmp	80004dae <PcdComMF522+0xfe>
				else
				{   *pOutLenBit = n*8;   }
80004da8:	e8 08 15 03 	lsl	r8,r4,0x3
80004dac:	a0 88       	st.b	r0[0x0],r8
				if (n == 0)
80004dae:	58 04       	cp.w	r4,0
80004db0:	c0 61       	brne	80004dbc <PcdComMF522+0x10c>
80004db2:	30 14       	mov	r4,1
80004db4:	40 05       	lddsp	r5,sp[0x0]
80004db6:	0a 96       	mov	r6,r5
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
				{   pOut [i] = ReadRawRC(FIFODataReg);    }
80004db8:	30 93       	mov	r3,9
80004dba:	c0 98       	rjmp	80004dcc <PcdComMF522+0x11c>
				{   *pOutLenBit = n*8;   }
				if (n == 0)
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
80004dbc:	31 28       	mov	r8,18
80004dbe:	f0 04 18 00 	cp.b	r4,r8
80004dc2:	f9 b4 0b 12 	movhi	r4,18
80004dc6:	58 04       	cp.w	r4,0
80004dc8:	cf 61       	brne	80004db4 <PcdComMF522+0x104>
80004dca:	c0 a8       	rjmp	80004dde <PcdComMF522+0x12e>
				{   pOut [i] = ReadRawRC(FIFODataReg);    }
80004dcc:	06 9c       	mov	r12,r3
80004dce:	f0 1f 00 16 	mcall	80004e24 <PcdComMF522+0x174>
80004dd2:	0c cc       	st.b	r6++,r12
				{   *pOutLenBit = n*8;   }
				if (n == 0)
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
80004dd4:	ec 05 01 08 	sub	r8,r6,r5
80004dd8:	e8 08 19 00 	cp.h	r8,r4
80004ddc:	cf 83       	brcs	80004dcc <PcdComMF522+0x11c>
		{   status = MI_ERR;   }
		
	}
	

	SetBitMask(ControlReg,0x80);           // stop timer now
80004dde:	e0 6b 00 80 	mov	r11,128
80004de2:	30 cc       	mov	r12,12
80004de4:	f0 1f 00 0f 	mcall	80004e20 <PcdComMF522+0x170>
	WriteRawRC(CommandReg,PCD_IDLE);
80004de8:	30 0b       	mov	r11,0
80004dea:	30 1c       	mov	r12,1
80004dec:	f0 1f 00 0b 	mcall	80004e18 <PcdComMF522+0x168>
	return status;
}
80004df0:	0e 9c       	mov	r12,r7
80004df2:	2f fd       	sub	sp,-4
80004df4:	d8 32       	popm	r0-r7,pc
	{
		n = ReadRawRC(ComIrqReg);
		i--;
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
	ClearBitMask(BitFramingReg,0x80);
80004df6:	e0 6b 00 80 	mov	r11,128
80004dfa:	30 dc       	mov	r12,13
80004dfc:	f0 1f 00 08 	mcall	80004e1c <PcdComMF522+0x16c>

	if (i!=0)
	{
		if(!(ReadRawRC(ErrorReg)&0x1B))
80004e00:	30 6c       	mov	r12,6
80004e02:	f0 1f 00 09 	mcall	80004e24 <PcdComMF522+0x174>
80004e06:	e2 1c 00 1b 	andl	r12,0x1b,COH
80004e0a:	cb 80       	breq	80004d7a <PcdComMF522+0xca>
80004e0c:	30 27       	mov	r7,2
80004e0e:	ce 8b       	rjmp	80004dde <PcdComMF522+0x12e>
80004e10:	80 00       	ld.sh	r0,r0[0x0]
80004e12:	d8 60       	acall	0x86
80004e14:	80 00       	ld.sh	r0,r0[0x0]
80004e16:	d8 64       	*unknown*
80004e18:	80 00       	ld.sh	r0,r0[0x0]
80004e1a:	49 88       	lddpc	r8,80004e78 <PcdAnticoll+0x50>
80004e1c:	80 00       	ld.sh	r0,r0[0x0]
80004e1e:	4b 30       	lddpc	r0,80004ee8 <PcdRequest+0x3c>
80004e20:	80 00       	ld.sh	r0,r0[0x0]
80004e22:	4a ec       	lddpc	r12,80004ed8 <PcdRequest+0x2c>
80004e24:	80 00       	ld.sh	r0,r0[0x0]
80004e26:	4a 48       	lddpc	r8,80004eb4 <PcdRequest+0x8>

80004e28 <PcdAnticoll>:
//    斤插叉
//拌存: pSnr[OUT]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdAnticoll(U8 *pSnr)
{
80004e28:	eb cd 40 c0 	pushm	r6-r7,lr
80004e2c:	20 5d       	sub	sp,20
80004e2e:	18 96       	mov	r6,r12
	U8   i,snr_check=0;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];
	

	ClearBitMask(Status2Reg,0x08);
80004e30:	30 8b       	mov	r11,8
80004e32:	16 9c       	mov	r12,r11
80004e34:	f0 1f 00 1a 	mcall	80004e9c <PcdAnticoll+0x74>
	WriteRawRC(BitFramingReg,0x00);
80004e38:	30 0b       	mov	r11,0
80004e3a:	30 dc       	mov	r12,13
80004e3c:	f0 1f 00 19 	mcall	80004ea0 <PcdAnticoll+0x78>
	ClearBitMask(CollReg,0x80);
80004e40:	e0 6b 00 80 	mov	r11,128
80004e44:	30 ec       	mov	r12,14
80004e46:	f0 1f 00 16 	mcall	80004e9c <PcdAnticoll+0x74>
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
80004e4a:	39 38       	mov	r8,-109
80004e4c:	ba 88       	st.b	sp[0x0],r8
	ucComMF522Buf[1] = 0x20;
80004e4e:	32 08       	mov	r8,32
80004e50:	ba 98       	st.b	sp[0x1],r8

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,2,ucComMF522Buf,&unLen);
80004e52:	1a 9b       	mov	r11,sp
80004e54:	fa c8 ff ed 	sub	r8,sp,-19
80004e58:	1a 99       	mov	r9,sp
80004e5a:	30 2a       	mov	r10,2
80004e5c:	30 cc       	mov	r12,12
80004e5e:	f0 1f 00 12 	mcall	80004ea4 <PcdAnticoll+0x7c>
80004e62:	18 97       	mov	r7,r12

	if (status == MI_OK)
80004e64:	c1 21       	brne	80004e88 <PcdAnticoll+0x60>
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
80004e66:	1b 89       	ld.ub	r9,sp[0x0]
80004e68:	ac 89       	st.b	r6[0x0],r9
80004e6a:	1b 98       	ld.ub	r8,sp[0x1]
80004e6c:	ac 98       	st.b	r6[0x1],r8
			snr_check ^= ucComMF522Buf[i];
80004e6e:	10 59       	eor	r9,r8

	if (status == MI_OK)
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
80004e70:	1b a8       	ld.ub	r8,sp[0x2]
80004e72:	ac a8       	st.b	r6[0x2],r8
			snr_check ^= ucComMF522Buf[i];
80004e74:	f3 e8 20 08 	eor	r8,r9,r8

	if (status == MI_OK)
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
80004e78:	1b b9       	ld.ub	r9,sp[0x3]
80004e7a:	ac b9       	st.b	r6[0x3],r9
			snr_check ^= ucComMF522Buf[i];
80004e7c:	12 58       	eor	r8,r9
		}
		if (snr_check != ucComMF522Buf[i])
80004e7e:	1b c9       	ld.ub	r9,sp[0x4]
80004e80:	f0 09 18 00 	cp.b	r9,r8
80004e84:	f9 b7 01 02 	movne	r7,2
		{   status = MI_ERR;    }
	}
	
	SetBitMask(CollReg,0x80);
80004e88:	e0 6b 00 80 	mov	r11,128
80004e8c:	30 ec       	mov	r12,14
80004e8e:	f0 1f 00 07 	mcall	80004ea8 <PcdAnticoll+0x80>
	return status;
}
80004e92:	0e 9c       	mov	r12,r7
80004e94:	2f bd       	sub	sp,-20
80004e96:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004e9a:	00 00       	add	r0,r0
80004e9c:	80 00       	ld.sh	r0,r0[0x0]
80004e9e:	4b 30       	lddpc	r0,80004f68 <CalulateCRC+0x58>
80004ea0:	80 00       	ld.sh	r0,r0[0x0]
80004ea2:	49 88       	lddpc	r8,80004f00 <PcdRequest+0x54>
80004ea4:	80 00       	ld.sh	r0,r0[0x0]
80004ea6:	4c b0       	lddpc	r0,80004fd0 <PcdSelect+0x34>
80004ea8:	80 00       	ld.sh	r0,r0[0x0]
80004eaa:	4a ec       	lddpc	r12,80004f60 <CalulateCRC+0x50>

80004eac <PcdRequest>:
//                0x0800 = Mifare_Pro(X)
//                0x4403 = Mifare_DESFire
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdRequest(U8   req_code,U8 *pTagType)
{
80004eac:	eb cd 40 c0 	pushm	r6-r7,lr
80004eb0:	20 5d       	sub	sp,20
80004eb2:	18 97       	mov	r7,r12
80004eb4:	16 96       	mov	r6,r11
	char   status;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];

	ClearBitMask(Status2Reg,0x08);
80004eb6:	30 8b       	mov	r11,8
80004eb8:	16 9c       	mov	r12,r11
80004eba:	f0 1f 00 12 	mcall	80004f00 <PcdRequest+0x54>
	WriteRawRC(BitFramingReg,0x07);
80004ebe:	30 7b       	mov	r11,7
80004ec0:	30 dc       	mov	r12,13
80004ec2:	f0 1f 00 11 	mcall	80004f04 <PcdRequest+0x58>
	SetBitMask(TxControlReg,0x03);
80004ec6:	30 3b       	mov	r11,3
80004ec8:	31 4c       	mov	r12,20
80004eca:	f0 1f 00 10 	mcall	80004f08 <PcdRequest+0x5c>
	
	ucComMF522Buf[0] = req_code;
80004ece:	ba 87       	st.b	sp[0x0],r7

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,1,ucComMF522Buf,&unLen);
80004ed0:	1a 9b       	mov	r11,sp
80004ed2:	fa c8 ff ed 	sub	r8,sp,-19
80004ed6:	1a 99       	mov	r9,sp
80004ed8:	30 1a       	mov	r10,1
80004eda:	30 cc       	mov	r12,12
80004edc:	f0 1f 00 0c 	mcall	80004f0c <PcdRequest+0x60>

	if ((status == MI_OK) && (unLen == 0x10))
80004ee0:	c0 c1       	brne	80004ef8 <PcdRequest+0x4c>
80004ee2:	31 08       	mov	r8,16
80004ee4:	fb 39 00 13 	ld.ub	r9,sp[19]
80004ee8:	f0 09 18 00 	cp.b	r9,r8
80004eec:	c0 61       	brne	80004ef8 <PcdRequest+0x4c>
	{
		*pTagType     = ucComMF522Buf[0];
80004eee:	1b 88       	ld.ub	r8,sp[0x0]
80004ef0:	ac 88       	st.b	r6[0x0],r8
		*(pTagType+1) = ucComMF522Buf[1];
80004ef2:	1b 98       	ld.ub	r8,sp[0x1]
80004ef4:	ac 98       	st.b	r6[0x1],r8
	
	ucComMF522Buf[0] = req_code;

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,1,ucComMF522Buf,&unLen);

	if ((status == MI_OK) && (unLen == 0x10))
80004ef6:	c0 28       	rjmp	80004efa <PcdRequest+0x4e>
80004ef8:	30 2c       	mov	r12,2
	}
	else
	{   status = MI_ERR;   }
	
	return status;
}
80004efa:	2f bd       	sub	sp,-20
80004efc:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004f00:	80 00       	ld.sh	r0,r0[0x0]
80004f02:	4b 30       	lddpc	r0,80004fcc <PcdSelect+0x30>
80004f04:	80 00       	ld.sh	r0,r0[0x0]
80004f06:	49 88       	lddpc	r8,80004f64 <CalulateCRC+0x54>
80004f08:	80 00       	ld.sh	r0,r0[0x0]
80004f0a:	4a ec       	lddpc	r12,80004fc0 <PcdSelect+0x24>
80004f0c:	80 00       	ld.sh	r0,r0[0x0]
80004f0e:	4c b0       	lddpc	r0,80005038 <rfid_auto_reader+0x28>

80004f10 <CalulateCRC>:

/////////////////////////////////////////////////////////////////////
//MF522璁＄CRC16芥
/////////////////////////////////////////////////////////////////////
void CalulateCRC(U8 *pIn ,U8   len,U8 *pOut )
{
80004f10:	eb cd 40 f8 	pushm	r3-r7,lr
80004f14:	18 95       	mov	r5,r12
80004f16:	16 96       	mov	r6,r11
80004f18:	14 93       	mov	r3,r10
	U8   i,n;
	ClearBitMask(DivIrqReg,0x04);
80004f1a:	30 4b       	mov	r11,4
80004f1c:	30 5c       	mov	r12,5
80004f1e:	f0 1f 00 1c 	mcall	80004f8c <CalulateCRC+0x7c>
	WriteRawRC(CommandReg,PCD_IDLE);
80004f22:	30 0b       	mov	r11,0
80004f24:	30 1c       	mov	r12,1
80004f26:	f0 1f 00 1b 	mcall	80004f90 <CalulateCRC+0x80>
	SetBitMask(FIFOLevelReg,0x80);
80004f2a:	e0 6b 00 80 	mov	r11,128
80004f2e:	30 ac       	mov	r12,10
80004f30:	f0 1f 00 19 	mcall	80004f94 <CalulateCRC+0x84>
	for (i=0; i<len; i++)
80004f34:	58 06       	cp.w	r6,0
80004f36:	c0 c0       	breq	80004f4e <CalulateCRC+0x3e>
80004f38:	0a 97       	mov	r7,r5
	{   WriteRawRC(FIFODataReg, *(pIn +i));   }
80004f3a:	30 94       	mov	r4,9
80004f3c:	0f 3b       	ld.ub	r11,r7++
80004f3e:	08 9c       	mov	r12,r4
80004f40:	f0 1f 00 14 	mcall	80004f90 <CalulateCRC+0x80>
{
	U8   i,n;
	ClearBitMask(DivIrqReg,0x04);
	WriteRawRC(CommandReg,PCD_IDLE);
	SetBitMask(FIFOLevelReg,0x80);
	for (i=0; i<len; i++)
80004f44:	0e 98       	mov	r8,r7
80004f46:	0a 18       	sub	r8,r5
80004f48:	ec 08 18 00 	cp.b	r8,r6
80004f4c:	cf 83       	brcs	80004f3c <CalulateCRC+0x2c>
	{   WriteRawRC(FIFODataReg, *(pIn +i));   }
	WriteRawRC(CommandReg, PCD_CALCCRC);
80004f4e:	30 3b       	mov	r11,3
80004f50:	30 1c       	mov	r12,1
80004f52:	f0 1f 00 10 	mcall	80004f90 <CalulateCRC+0x80>
	i = 0xFF;
	do
	{
		n = ReadRawRC(DivIrqReg);
80004f56:	30 5c       	mov	r12,5
80004f58:	f0 1f 00 10 	mcall	80004f98 <CalulateCRC+0x88>
80004f5c:	e0 67 00 fe 	mov	r7,254
80004f60:	30 56       	mov	r6,5
80004f62:	c0 78       	rjmp	80004f70 <CalulateCRC+0x60>
80004f64:	0c 9c       	mov	r12,r6
80004f66:	f0 1f 00 0d 	mcall	80004f98 <CalulateCRC+0x88>
		i--;
80004f6a:	20 17       	sub	r7,1
80004f6c:	5c 57       	castu.b	r7
	}
	while ((i!=0) && !(n&0x04));
80004f6e:	c0 40       	breq	80004f76 <CalulateCRC+0x66>
80004f70:	e2 1c 00 04 	andl	r12,0x4,COH
80004f74:	cf 80       	breq	80004f64 <CalulateCRC+0x54>
	pOut [0] = ReadRawRC(CRCResultRegL);
80004f76:	32 2c       	mov	r12,34
80004f78:	f0 1f 00 08 	mcall	80004f98 <CalulateCRC+0x88>
80004f7c:	a6 8c       	st.b	r3[0x0],r12
	pOut [1] = ReadRawRC(CRCResultRegM);
80004f7e:	32 1c       	mov	r12,33
80004f80:	f0 1f 00 06 	mcall	80004f98 <CalulateCRC+0x88>
80004f84:	a6 9c       	st.b	r3[0x1],r12
}
80004f86:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80004f8a:	00 00       	add	r0,r0
80004f8c:	80 00       	ld.sh	r0,r0[0x0]
80004f8e:	4b 30       	lddpc	r0,80005058 <rfid_auto_reader+0x48>
80004f90:	80 00       	ld.sh	r0,r0[0x0]
80004f92:	49 88       	lddpc	r8,80004ff0 <PcdSelect+0x54>
80004f94:	80 00       	ld.sh	r0,r0[0x0]
80004f96:	4a ec       	lddpc	r12,8000504c <rfid_auto_reader+0x3c>
80004f98:	80 00       	ld.sh	r0,r0[0x0]
80004f9a:	4a 48       	lddpc	r8,80005028 <rfid_auto_reader+0x18>

80004f9c <PcdSelect>:
//    斤瀹＄
//拌存: pSnr[IN]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdSelect(U8 *pSnr)
{
80004f9c:	eb cd 40 80 	pushm	r7,lr
80004fa0:	20 5d       	sub	sp,20
	char   status;
	U8   i;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
80004fa2:	39 38       	mov	r8,-109
80004fa4:	ba 88       	st.b	sp[0x0],r8
	ucComMF522Buf[1] = 0x70;
80004fa6:	37 08       	mov	r8,112
80004fa8:	ba 98       	st.b	sp[0x1],r8
	ucComMF522Buf[6] = 0;
80004faa:	30 08       	mov	r8,0
80004fac:	ba e8       	st.b	sp[0x6],r8
80004fae:	fa c8 ff fe 	sub	r8,sp,-2
/////////////////////////////////////////////////////////////////////
//    斤瀹＄
//拌存: pSnr[IN]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdSelect(U8 *pSnr)
80004fb2:	fa cb ff fa 	sub	r11,sp,-6
	ucComMF522Buf[0] = PICC_ANTICOLL1;
	ucComMF522Buf[1] = 0x70;
	ucComMF522Buf[6] = 0;
	for (i=0; i<4; i++)
	{
		ucComMF522Buf[i+2] = *(pSnr+i);
80004fb6:	19 89       	ld.ub	r9,r12[0x0]
80004fb8:	10 c9       	st.b	r8++,r9
		ucComMF522Buf[6]  ^= *(pSnr+i);
80004fba:	19 3a       	ld.ub	r10,r12++
80004fbc:	1b e9       	ld.ub	r9,sp[0x6]
80004fbe:	f5 e9 20 09 	eor	r9,r10,r9
80004fc2:	ba e9       	st.b	sp[0x6],r9
	U8   ucComMF522Buf[MAXRLEN];
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
	ucComMF522Buf[1] = 0x70;
	ucComMF522Buf[6] = 0;
	for (i=0; i<4; i++)
80004fc4:	16 38       	cp.w	r8,r11
80004fc6:	cf 81       	brne	80004fb6 <PcdSelect+0x1a>
	{
		ucComMF522Buf[i+2] = *(pSnr+i);
		ucComMF522Buf[6]  ^= *(pSnr+i);
	}
	CalulateCRC(ucComMF522Buf,7,&ucComMF522Buf[7]);
80004fc8:	1a 97       	mov	r7,sp
80004fca:	fa ca ff f9 	sub	r10,sp,-7
80004fce:	30 7b       	mov	r11,7
80004fd0:	1a 9c       	mov	r12,sp
80004fd2:	f0 1f 00 0d 	mcall	80005004 <PcdSelect+0x68>
	
	ClearBitMask(Status2Reg,0x08);
80004fd6:	30 8b       	mov	r11,8
80004fd8:	16 9c       	mov	r12,r11
80004fda:	f0 1f 00 0c 	mcall	80005008 <PcdSelect+0x6c>

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,9,ucComMF522Buf,&unLen);
80004fde:	fa c8 ff ed 	sub	r8,sp,-19
80004fe2:	1a 99       	mov	r9,sp
80004fe4:	30 9a       	mov	r10,9
80004fe6:	1a 9b       	mov	r11,sp
80004fe8:	30 cc       	mov	r12,12
80004fea:	f0 1f 00 09 	mcall	8000500c <PcdSelect+0x70>
	
	if ((status == MI_OK) && (unLen == 0x18))
80004fee:	c0 71       	brne	80004ffc <PcdSelect+0x60>
80004ff0:	31 88       	mov	r8,24
80004ff2:	fb 39 00 13 	ld.ub	r9,sp[19]
80004ff6:	f0 09 18 00 	cp.b	r9,r8
80004ffa:	c0 20       	breq	80004ffe <PcdSelect+0x62>
80004ffc:	30 2c       	mov	r12,2
	{   status = MI_OK;  }
	else
	{   status = MI_ERR;    }

	return status;
}
80004ffe:	2f bd       	sub	sp,-20
80005000:	e3 cd 80 80 	ldm	sp++,r7,pc
80005004:	80 00       	ld.sh	r0,r0[0x0]
80005006:	4f 10       	lddpc	r0,800051c8 <scan_rfid_save_message+0x48>
80005008:	80 00       	ld.sh	r0,r0[0x0]
8000500a:	4b 30       	lddpc	r0,800050d4 <rfid_auto_reader+0xc4>
8000500c:	80 00       	ld.sh	r0,r0[0x0]
8000500e:	4c b0       	lddpc	r0,80005138 <scan_patrol+0x8>

80005010 <rfid_auto_reader>:
		//
}

//娴绋锛瀵诲->插叉->->″
U8 rfid_auto_reader(void *card_id)
{
80005010:	eb cd 40 c0 	pushm	r6-r7,lr
80005014:	18 96       	mov	r6,r12
	U8 status = MI_ERR;
	
	PcdReset();
80005016:	f0 1f 00 37 	mcall	800050f0 <rfid_auto_reader+0xe0>
//while(1){
	status=PcdRequest(PICC_REQALL,	CT);//瀵诲ぉ绾垮哄ㄩㄧ★杩＄绫诲 2瀛
8000501a:	4b 7b       	lddpc	r11,800050f4 <rfid_auto_reader+0xe4>
8000501c:	35 2c       	mov	r12,82
8000501e:	f0 1f 00 37 	mcall	800050f8 <rfid_auto_reader+0xe8>
80005022:	18 97       	mov	r7,r12
	if(status!=MI_OK) return status;
80005024:	c6 31       	brne	800050ea <rfid_auto_reader+0xda>
	//continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
80005026:	4b 48       	lddpc	r8,800050f4 <rfid_auto_reader+0xe4>
80005028:	11 88       	ld.ub	r8,r8[0x0]
8000502a:	30 49       	mov	r9,4
8000502c:	f2 08 18 00 	cp.b	r8,r9
80005030:	c0 b1       	brne	80005046 <rfid_auto_reader+0x36>
80005032:	4b 19       	lddpc	r9,800050f4 <rfid_auto_reader+0xe4>
80005034:	13 9a       	ld.ub	r10,r9[0x1]
80005036:	30 09       	mov	r9,0
80005038:	f2 0a 18 00 	cp.b	r10,r9
8000503c:	c0 51       	brne	80005046 <rfid_auto_reader+0x36>
		log("MFOne-S50\n");
8000503e:	4b 0c       	lddpc	r12,800050fc <rfid_auto_reader+0xec>
80005040:	f0 1f 00 30 	mcall	80005100 <rfid_auto_reader+0xf0>
//while(1){
	status=PcdRequest(PICC_REQALL,	CT);//瀵诲ぉ绾垮哄ㄩㄧ★杩＄绫诲 2瀛
	if(status!=MI_OK) return status;
	//continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
80005044:	c3 c8       	rjmp	800050bc <rfid_auto_reader+0xac>
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
80005046:	30 29       	mov	r9,2
80005048:	f2 08 18 00 	cp.b	r8,r9
8000504c:	c0 b1       	brne	80005062 <rfid_auto_reader+0x52>
8000504e:	4a a9       	lddpc	r9,800050f4 <rfid_auto_reader+0xe4>
80005050:	13 9a       	ld.ub	r10,r9[0x1]
80005052:	30 09       	mov	r9,0
80005054:	f2 0a 18 00 	cp.b	r10,r9
80005058:	c0 51       	brne	80005062 <rfid_auto_reader+0x52>
		log("MFOne-S70\n");
8000505a:	4a bc       	lddpc	r12,80005104 <rfid_auto_reader+0xf4>
8000505c:	f0 1f 00 29 	mcall	80005100 <rfid_auto_reader+0xf0>
	if(status!=MI_OK) return status;
	//continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
80005060:	c2 e8       	rjmp	800050bc <rfid_auto_reader+0xac>
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
80005062:	34 49       	mov	r9,68
80005064:	f2 08 18 00 	cp.b	r8,r9
80005068:	c0 b1       	brne	8000507e <rfid_auto_reader+0x6e>
8000506a:	4a 39       	lddpc	r9,800050f4 <rfid_auto_reader+0xe4>
8000506c:	13 9a       	ld.ub	r10,r9[0x1]
8000506e:	30 09       	mov	r9,0
80005070:	f2 0a 18 00 	cp.b	r10,r9
80005074:	c0 51       	brne	8000507e <rfid_auto_reader+0x6e>
		log("MF-UltraLight\n");
80005076:	4a 5c       	lddpc	r12,80005108 <rfid_auto_reader+0xf8>
80005078:	f0 1f 00 22 	mcall	80005100 <rfid_auto_reader+0xf0>
	
	if(CT[0]==0x04&&CT[1]==0x00)
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
8000507c:	c2 08       	rjmp	800050bc <rfid_auto_reader+0xac>
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
8000507e:	30 89       	mov	r9,8
80005080:	f2 08 18 00 	cp.b	r8,r9
80005084:	c0 b1       	brne	8000509a <rfid_auto_reader+0x8a>
80005086:	49 c9       	lddpc	r9,800050f4 <rfid_auto_reader+0xe4>
80005088:	13 9a       	ld.ub	r10,r9[0x1]
8000508a:	30 09       	mov	r9,0
8000508c:	f2 0a 18 00 	cp.b	r10,r9
80005090:	c0 51       	brne	8000509a <rfid_auto_reader+0x8a>
		log("MF-Pro\n");
80005092:	49 fc       	lddpc	r12,8000510c <rfid_auto_reader+0xfc>
80005094:	f0 1f 00 1b 	mcall	80005100 <rfid_auto_reader+0xf0>
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
80005098:	c1 28       	rjmp	800050bc <rfid_auto_reader+0xac>
		log("MF-Pro\n");
	else if(CT[0]==0x44&&CT[1]==0x03)
8000509a:	34 49       	mov	r9,68
8000509c:	f2 08 18 00 	cp.b	r8,r9
800050a0:	c0 b1       	brne	800050b6 <rfid_auto_reader+0xa6>
800050a2:	49 58       	lddpc	r8,800050f4 <rfid_auto_reader+0xe4>
800050a4:	11 99       	ld.ub	r9,r8[0x1]
800050a6:	30 38       	mov	r8,3
800050a8:	f0 09 18 00 	cp.b	r9,r8
800050ac:	c0 51       	brne	800050b6 <rfid_auto_reader+0xa6>
		log("MF Desire\n");
800050ae:	49 9c       	lddpc	r12,80005110 <rfid_auto_reader+0x100>
800050b0:	f0 1f 00 14 	mcall	80005100 <rfid_auto_reader+0xf0>
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
		log("MF-Pro\n");
	else if(CT[0]==0x44&&CT[1]==0x03)
800050b4:	c0 48       	rjmp	800050bc <rfid_auto_reader+0xac>
		log("MF Desire\n");
	else
		log("Unknown\n");
800050b6:	49 8c       	lddpc	r12,80005114 <rfid_auto_reader+0x104>
800050b8:	f0 1f 00 12 	mcall	80005100 <rfid_auto_reader+0xf0>
		
	status=PcdAnticoll(SN);//插叉锛杩＄搴 4瀛
800050bc:	49 7c       	lddpc	r12,80005118 <rfid_auto_reader+0x108>
800050be:	f0 1f 00 18 	mcall	8000511c <rfid_auto_reader+0x10c>
800050c2:	18 97       	mov	r7,r12
	if(status!=MI_OK)
800050c4:	c0 60       	breq	800050d0 <rfid_auto_reader+0xc0>
	{
		xcmp_IdleTestTone(Tone_Start, Low_Battery_3);//set tone to noticy failure!!!
800050c6:	34 fb       	mov	r11,79
800050c8:	30 1c       	mov	r12,1
800050ca:	f0 1f 00 16 	mcall	80005120 <rfid_auto_reader+0x110>
		return status;
800050ce:	c0 e8       	rjmp	800050ea <rfid_auto_reader+0xda>
		//continue;
	}
	
	//memcpy(MLastSelectedSnr,&RevBuffer[2],4);
	status=PcdSelect(SN);//
800050d0:	49 2c       	lddpc	r12,80005118 <rfid_auto_reader+0x108>
800050d2:	f0 1f 00 15 	mcall	80005124 <rfid_auto_reader+0x114>
800050d6:	18 97       	mov	r7,r12
	if(status!=MI_OK)return status;
800050d8:	c0 91       	brne	800050ea <rfid_auto_reader+0xda>
	//continue;
	else{//℃
			
		memcpy(card_id, SN, 4);
800050da:	30 4a       	mov	r10,4
800050dc:	48 fb       	lddpc	r11,80005118 <rfid_auto_reader+0x108>
800050de:	0c 9c       	mov	r12,r6
800050e0:	f0 1f 00 12 	mcall	80005128 <rfid_auto_reader+0x118>
		log("select okay\n");
800050e4:	49 2c       	lddpc	r12,8000512c <rfid_auto_reader+0x11c>
800050e6:	f0 1f 00 07 	mcall	80005100 <rfid_auto_reader+0xf0>
		return status;	
	}
	
//}
	
}
800050ea:	0e 9c       	mov	r12,r7
800050ec:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800050f0:	80 00       	ld.sh	r0,r0[0x0]
800050f2:	49 c8       	lddpc	r8,80005160 <scan_patrol+0x30>
800050f4:	00 00       	add	r0,r0
800050f6:	97 40       	st.w	r11[0x10],r0
800050f8:	80 00       	ld.sh	r0,r0[0x0]
800050fa:	4e ac       	lddpc	r12,800052a0 <scan_rfid_save_message+0x120>
800050fc:	80 00       	ld.sh	r0,r0[0x0]
800050fe:	d8 98       	*unknown*
80005100:	80 00       	ld.sh	r0,r0[0x0]
80005102:	70 48       	ld.w	r8,r8[0x10]
80005104:	80 00       	ld.sh	r0,r0[0x0]
80005106:	d8 a4       	*unknown*
80005108:	80 00       	ld.sh	r0,r0[0x0]
8000510a:	d8 b0       	acall	0x8b
8000510c:	80 00       	ld.sh	r0,r0[0x0]
8000510e:	d8 c0       	acall	0x8c
80005110:	80 00       	ld.sh	r0,r0[0x0]
80005112:	d8 c8       	*unknown*
80005114:	80 00       	ld.sh	r0,r0[0x0]
80005116:	d8 d4       	*unknown*
80005118:	00 00       	add	r0,r0
8000511a:	97 44       	st.w	r11[0x10],r4
8000511c:	80 00       	ld.sh	r0,r0[0x0]
8000511e:	4e 28       	lddpc	r8,800052a4 <scan_rfid_save_message+0x124>
80005120:	80 00       	ld.sh	r0,r0[0x0]
80005122:	41 1c       	lddsp	r12,sp[0x44]
80005124:	80 00       	ld.sh	r0,r0[0x0]
80005126:	4f 9c       	lddpc	r12,80005308 <scan_rfid_save_message+0x188>
80005128:	80 00       	ld.sh	r0,r0[0x0]
8000512a:	78 c4       	ld.w	r4,r12[0x30]
8000512c:	80 00       	ld.sh	r0,r0[0x0]
8000512e:	d8 e0       	acall	0x8e

80005130 <scan_patrol>:
	return return_err;
	
}

U8 scan_patrol(char* SN)
{
80005130:	eb cd 40 80 	pushm	r7,lr
80005134:	18 97       	mov	r7,r12
	U8 return_err = MI_ERR;
	
	PcdReset();
80005136:	f0 1f 00 0d 	mcall	80005168 <scan_patrol+0x38>
	Powerdown_RC522(WAKEUP_RC522);
8000513a:	30 0c       	mov	r12,0
8000513c:	f0 1f 00 0c 	mcall	8000516c <scan_patrol+0x3c>
	return_err = rfid_auto_reader(SN);
80005140:	0e 9c       	mov	r12,r7
80005142:	f0 1f 00 0c 	mcall	80005170 <scan_patrol+0x40>
80005146:	18 97       	mov	r7,r12
	Powerdown_RC522(ENTER_POWERDOWN);
80005148:	30 1c       	mov	r12,1
8000514a:	f0 1f 00 09 	mcall	8000516c <scan_patrol+0x3c>
	if(return_err == 0)
8000514e:	58 07       	cp.w	r7,0
80005150:	c0 51       	brne	8000515a <scan_patrol+0x2a>
		log("scan_patrol okay!\n");
80005152:	48 9c       	lddpc	r12,80005174 <scan_patrol+0x44>
80005154:	f0 1f 00 09 	mcall	80005178 <scan_patrol+0x48>
80005158:	c0 48       	rjmp	80005160 <scan_patrol+0x30>
	else
		log("scan_patrol err!\n");
8000515a:	48 9c       	lddpc	r12,8000517c <scan_patrol+0x4c>
8000515c:	f0 1f 00 07 	mcall	80005178 <scan_patrol+0x48>
		
	return return_err;

}
80005160:	0e 9c       	mov	r12,r7
80005162:	e3 cd 80 80 	ldm	sp++,r7,pc
80005166:	00 00       	add	r0,r0
80005168:	80 00       	ld.sh	r0,r0[0x0]
8000516a:	49 c8       	lddpc	r8,800051d8 <scan_rfid_save_message+0x58>
8000516c:	80 00       	ld.sh	r0,r0[0x0]
8000516e:	4a a0       	lddpc	r0,80005214 <scan_rfid_save_message+0x94>
80005170:	80 00       	ld.sh	r0,r0[0x0]
80005172:	50 10       	stdsp	sp[0x4],r0
80005174:	80 00       	ld.sh	r0,r0[0x0]
80005176:	d8 f0       	acall	0x8f
80005178:	80 00       	ld.sh	r0,r0[0x0]
8000517a:	70 48       	ld.w	r8,r8[0x10]
8000517c:	80 00       	ld.sh	r0,r0[0x0]
8000517e:	d9 04       	*unknown*

80005180 <scan_rfid_save_message>:
U8 scan_rfid_save_message()
{
80005180:	eb cd 40 e0 	pushm	r5-r7,lr
80005184:	fa cd 00 8c 	sub	sp,sp,140
	U32 destination = DEST;
	static U8 start_session = 0x80;
	Message_Header_t header;
	Message_Data_t data_buffer;//22bytes
	
	memset(SN, 0x00, 10);
80005188:	4e 9c       	lddpc	r12,8000532c <scan_rfid_save_message+0x1ac>
8000518a:	30 08       	mov	r8,0
8000518c:	30 09       	mov	r9,0
8000518e:	f8 e9 00 00 	st.d	r12[0],r8
80005192:	30 0a       	mov	r10,0
80005194:	b8 4a       	st.h	r12[0x8],r10
	memset(message, 0x00, 80);
80005196:	fa e9 00 3c 	st.d	sp[60],r8
8000519a:	fa e9 00 44 	st.d	sp[68],r8
8000519e:	fa e9 00 4c 	st.d	sp[76],r8
800051a2:	fa e9 00 54 	st.d	sp[84],r8
800051a6:	fa e9 00 5c 	st.d	sp[92],r8
800051aa:	fa e9 00 64 	st.d	sp[100],r8
800051ae:	fa e9 00 6c 	st.d	sp[108],r8
800051b2:	fa e9 00 74 	st.d	sp[116],r8
800051b6:	fa e9 00 7c 	st.d	sp[124],r8
800051ba:	fa e9 00 84 	st.d	sp[132],r8
	
	return_err = scan_patrol(SN);
800051be:	f0 1f 00 5d 	mcall	80005330 <scan_rfid_save_message+0x1b0>
800051c2:	18 97       	mov	r7,r12
	
	if(return_err == 0){
800051c4:	e0 81 00 a8 	brne	80005314 <scan_rfid_save_message+0x194>
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
800051c8:	4d 96       	lddpc	r6,8000532c <scan_rfid_save_message+0x1ac>
800051ca:	0d b8       	ld.ub	r8,r6[0x3]
800051cc:	1a d8       	st.w	--sp,r8
800051ce:	0d a8       	ld.ub	r8,r6[0x2]
800051d0:	1a d8       	st.w	--sp,r8
800051d2:	0d 98       	ld.ub	r8,r6[0x1]
800051d4:	1a d8       	st.w	--sp,r8
800051d6:	0d 88       	ld.ub	r8,r6[0x0]
800051d8:	1a d8       	st.w	--sp,r8
800051da:	4d 7c       	lddpc	r12,80005334 <scan_rfid_save_message+0x1b4>
800051dc:	f0 1f 00 57 	mcall	80005338 <scan_rfid_save_message+0x1b8>
		xcmp_IdleTestTone(Tone_Start, Ring_Style_Tone_8);//set tone to indicate scan rfid success!!!
800051e0:	34 4b       	mov	r11,68
800051e2:	30 1c       	mov	r12,1
800051e4:	f0 1f 00 56 	mcall	8000533c <scan_rfid_save_message+0x1bc>
800051e8:	fa c8 ff ce 	sub	r8,sp,-50
800051ec:	fa c9 ff cc 	sub	r9,sp,-52
		log("scan_patrol err!\n");
		
	return return_err;

}
U8 scan_rfid_save_message()
800051f0:	ec c5 ff fc 	sub	r5,r6,-4
800051f4:	2f cd       	sub	sp,-16
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, Ring_Style_Tone_8);//set tone to indicate scan rfid success!!!
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″
			
			temp = ((SN[i] & 0xF0) >> 4);//瀛楂浣
			if((temp >= 0) && (temp <= 9))data_buffer.RFID_ID[i*4] = temp+0x30;
800051f6:	30 9e       	mov	lr,9
			else
			data_buffer.RFID_ID[i*4] = ((temp - 0x0a)+0x61);
			
			data_buffer.RFID_ID[i*4+1] = 0x00;
800051f8:	30 0c       	mov	r12,0
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, Ring_Style_Tone_8);//set tone to indicate scan rfid success!!!
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″
			
			temp = ((SN[i] & 0xF0) >> 4);//瀛楂浣
800051fa:	0d 8a       	ld.ub	r10,r6[0x0]
800051fc:	f4 0b 16 04 	lsr	r11,r10,0x4
			if((temp >= 0) && (temp <= 9))data_buffer.RFID_ID[i*4] = temp+0x30;
80005200:	fc 0b 18 00 	cp.b	r11,lr
80005204:	f7 bb 08 d0 	subls	r11,-48
80005208:	f1 fb 8e 00 	st.bls	r8[0x0],r11
			else
			data_buffer.RFID_ID[i*4] = ((temp - 0x0a)+0x61);
8000520c:	f7 bb 0b a9 	subhi	r11,-87
80005210:	f1 fb be 00 	st.bhi	r8[0x0],r11
			
			data_buffer.RFID_ID[i*4+1] = 0x00;
80005214:	b0 9c       	st.b	r8[0x1],r12
			
			temp = (SN[i] & 0x0F);//瀛浣浣
80005216:	f5 da c0 04 	bfextu	r10,r10,0x0,0x4
			if((temp >= 0) && (temp <= 9))data_buffer.RFID_ID[i*4+2] = temp+0x30;
8000521a:	fc 0a 18 00 	cp.b	r10,lr
8000521e:	f7 ba 08 d0 	subls	r10,-48
80005222:	f3 fa 8e 00 	st.bls	r9[0x0],r10
			else
			data_buffer.RFID_ID[i*4+2] = ((temp - 0x0a)+0x61);
80005226:	f7 ba 0b a9 	subhi	r10,-87
8000522a:	f3 fa be 00 	st.bhi	r9[0x0],r10

			data_buffer.RFID_ID[i*4+3] = 0x00;
8000522e:	b0 bc       	st.b	r8[0x3],r12
80005230:	2f f6       	sub	r6,-1
80005232:	2f c8       	sub	r8,-4
80005234:	2f c9       	sub	r9,-4
	
	if(return_err == 0){
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, Ring_Style_Tone_8);//set tone to indicate scan rfid success!!!
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″
80005236:	0a 36       	cp.w	r6,r5
80005238:	ce 11       	brne	800051fa <scan_rfid_save_message+0x7a>
		
		//memcpy(&data_buffer.XG_Time.Year, &Current_time.Year, sizeof(DateTime_t))	;
		
		header.length = (0x0008 + sizeof(Message_Data_t));
		
		if(start_session > 0x9f)start_session = 0x80;
8000523a:	4c 28       	lddpc	r8,80005340 <scan_rfid_save_message+0x1c0>
8000523c:	11 89       	ld.ub	r9,r8[0x0]
8000523e:	39 f8       	mov	r8,-97
80005240:	f0 09 18 00 	cp.b	r9,r8
80005244:	e0 88 00 05 	brls	8000524e <scan_rfid_save_message+0xce>
80005248:	38 09       	mov	r9,-128
8000524a:	4b e8       	lddpc	r8,80005340 <scan_rfid_save_message+0x1c0>
8000524c:	b0 89       	st.b	r8[0x0],r9
		
		header.session_id = (++start_session);
8000524e:	4b d8       	lddpc	r8,80005340 <scan_rfid_save_message+0x1c0>
80005250:	11 86       	ld.ub	r6,r8[0x0]
80005252:	2f f6       	sub	r6,-1
80005254:	b0 86       	st.b	r8[0x0],r6
		
		memcpy(&header.fixed_data[0], unsure_data, sizeof(unsure_data));
80005256:	30 5a       	mov	r10,5
80005258:	4b bb       	lddpc	r11,80005344 <scan_rfid_save_message+0x1c4>
8000525a:	fa cc ff c9 	sub	r12,sp,-55
8000525e:	f0 1f 00 3b 	mcall	80005348 <scan_rfid_save_message+0x1c8>
		header.type = 0xe000;
		
		memcpy(message, &header, sizeof(Message_Header_t));//疯header版
80005262:	31 88       	mov	r8,24
80005264:	fb 58 00 32 	st.h	sp[50],r8
80005268:	fb 66 00 36 	st.b	sp[54],r6
8000526c:	fe 78 e0 00 	mov	r8,-8192
80005270:	fb 58 00 34 	st.h	sp[52],r8
80005274:	fa c6 ff c4 	sub	r6,sp,-60
80005278:	30 aa       	mov	r10,10
8000527a:	fa cb ff ce 	sub	r11,sp,-50
8000527e:	0c 9c       	mov	r12,r6
80005280:	f0 1f 00 32 	mcall	80005348 <scan_rfid_save_message+0x1c8>
		memcpy(&message[sizeof(Message_Header_t)], &data_buffer, sizeof(Message_Data_t));//疯淇″瀹规版
80005284:	31 0a       	mov	r10,16
80005286:	fa cb ff de 	sub	r11,sp,-34
8000528a:	fa cc ff ba 	sub	r12,sp,-70
8000528e:	f0 1f 00 2f 	mcall	80005348 <scan_rfid_save_message+0x1c8>
		
		//xcmp_data_session_req(message, (sizeof(Message_Header_t)+sizeof(Message_Data_t)), destination);
		Message_Protocol_t  xgmessage;
		memcpy(&xgmessage, message, sizeof(Message_Protocol_t));
80005292:	31 aa       	mov	r10,26
80005294:	0c 9b       	mov	r11,r6
80005296:	fa cc ff fe 	sub	r12,sp,-2
8000529a:	f0 1f 00 2c 	mcall	80005348 <scan_rfid_save_message+0x1c8>

		Message_Protocol_t * myptr = get_message_store();
8000529e:	4a c8       	lddpc	r8,8000534c <scan_rfid_save_message+0x1cc>
800052a0:	70 0c       	ld.w	r12,r8[0x0]
800052a2:	f0 1f 00 2c 	mcall	80005350 <scan_rfid_save_message+0x1d0>
800052a6:	50 7c       	stdsp	sp[0x1c],r12
		if(NULL != myptr)
800052a8:	c3 20       	breq	8000530c <scan_rfid_save_message+0x18c>
		{
			memcpy(myptr, &xgmessage, sizeof(Message_Protocol_t));
800052aa:	31 aa       	mov	r10,26
800052ac:	fa cb ff fe 	sub	r11,sp,-2
800052b0:	f0 1f 00 26 	mcall	80005348 <scan_rfid_save_message+0x1c8>
			if (xQueueSend(xg_resend_queue, &myptr, 0) != pdPASS)
800052b4:	4a 88       	lddpc	r8,80005354 <scan_rfid_save_message+0x1d4>
800052b6:	70 0c       	ld.w	r12,r8[0x0]
800052b8:	30 09       	mov	r9,0
800052ba:	12 9a       	mov	r10,r9
800052bc:	fa cb ff e4 	sub	r11,sp,-28
800052c0:	f0 1f 00 26 	mcall	80005358 <scan_rfid_save_message+0x1d8>
800052c4:	58 1c       	cp.w	r12,1
800052c6:	c1 10       	breq	800052e8 <scan_rfid_save_message+0x168>
			{
				log("xg_resend_queue: full\n" );
800052c8:	4a 5c       	lddpc	r12,8000535c <scan_rfid_save_message+0x1dc>
800052ca:	f0 1f 00 1c 	mcall	80005338 <scan_rfid_save_message+0x1b8>
				xcmp_IdleTestTone(Tone_Start, Dispatch_Busy);//set tone to indicate queue full!!!
800052ce:	32 3b       	mov	r11,35
800052d0:	30 1c       	mov	r12,1
800052d2:	f0 1f 00 1b 	mcall	8000533c <scan_rfid_save_message+0x1bc>
				vTaskDelay(3000*2 / portTICK_RATE_MS);//寤惰3000ms
800052d6:	e0 6c 17 70 	mov	r12,6000
800052da:	f0 1f 00 22 	mcall	80005360 <scan_rfid_save_message+0x1e0>
				xcmp_IdleTestTone(Tone_Stop, Dispatch_Busy);//set tone to indicate queue full!!!
800052de:	32 3b       	mov	r11,35
800052e0:	30 0c       	mov	r12,0
800052e2:	f0 1f 00 17 	mcall	8000533c <scan_rfid_save_message+0x1bc>
800052e6:	c1 e8       	rjmp	80005322 <scan_rfid_save_message+0x1a2>
			}
			else{
				
				xSemaphoreTake(count_mutex, portMAX_DELAY);
800052e8:	49 f6       	lddpc	r6,80005364 <scan_rfid_save_message+0x1e4>
800052ea:	6c 0c       	ld.w	r12,r6[0x0]
800052ec:	30 09       	mov	r9,0
800052ee:	3f fa       	mov	r10,-1
800052f0:	12 9b       	mov	r11,r9
800052f2:	f0 1f 00 1e 	mcall	80005368 <scan_rfid_save_message+0x1e8>
				global_count++;
800052f6:	49 e8       	lddpc	r8,8000536c <scan_rfid_save_message+0x1ec>
800052f8:	70 09       	ld.w	r9,r8[0x0]
800052fa:	2f f9       	sub	r9,-1
800052fc:	91 09       	st.w	r8[0x0],r9
				xSemaphoreGive(count_mutex);
800052fe:	6c 0c       	ld.w	r12,r6[0x0]
80005300:	30 09       	mov	r9,0
80005302:	12 9a       	mov	r10,r9
80005304:	12 9b       	mov	r11,r9
80005306:	f0 1f 00 15 	mcall	80005358 <scan_rfid_save_message+0x1d8>
8000530a:	c0 c8       	rjmp	80005322 <scan_rfid_save_message+0x1a2>
			}

		}
		else
		{
			log("myptr: err\n\r" );
8000530c:	49 9c       	lddpc	r12,80005370 <scan_rfid_save_message+0x1f0>
8000530e:	f0 1f 00 0b 	mcall	80005338 <scan_rfid_save_message+0x1b8>
80005312:	c0 88       	rjmp	80005322 <scan_rfid_save_message+0x1a2>
		}
		
	}
	else
	{
		xcmp_IdleTestTone(Tone_Start, Low_Battery_3);//set tone to indicate scan rfid failure!!!
80005314:	34 fb       	mov	r11,79
80005316:	30 1c       	mov	r12,1
80005318:	f0 1f 00 09 	mcall	8000533c <scan_rfid_save_message+0x1bc>
		log("no card find...\n");
8000531c:	49 6c       	lddpc	r12,80005374 <scan_rfid_save_message+0x1f4>
8000531e:	f0 1f 00 07 	mcall	80005338 <scan_rfid_save_message+0x1b8>
	}
	
	return return_err;
	
}
80005322:	0e 9c       	mov	r12,r7
80005324:	2d dd       	sub	sp,-140
80005326:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000532a:	00 00       	add	r0,r0
8000532c:	00 00       	add	r0,r0
8000532e:	0b 64       	ld.uh	r4,--r5
80005330:	80 00       	ld.sh	r0,r0[0x0]
80005332:	51 30       	stdsp	sp[0x4c],r0
80005334:	80 00       	ld.sh	r0,r0[0x0]
80005336:	d9 18       	*unknown*
80005338:	80 00       	ld.sh	r0,r0[0x0]
8000533a:	70 48       	ld.w	r8,r8[0x10]
8000533c:	80 00       	ld.sh	r0,r0[0x0]
8000533e:	41 1c       	lddsp	r12,sp[0x44]
80005340:	00 00       	add	r0,r0
80005342:	05 28       	ld.uh	r8,r2++
80005344:	00 00       	add	r0,r0
80005346:	05 2c       	ld.uh	r12,r2++
80005348:	80 00       	ld.sh	r0,r0[0x0]
8000534a:	78 c4       	ld.w	r4,r12[0x30]
8000534c:	00 00       	add	r0,r0
8000534e:	0b 74       	ld.ub	r4,--r5
80005350:	80 00       	ld.sh	r0,r0[0x0]
80005352:	2e 60       	sub	r0,-26
80005354:	00 00       	add	r0,r0
80005356:	0b 70       	ld.ub	r0,--r5
80005358:	80 00       	ld.sh	r0,r0[0x0]
8000535a:	64 10       	ld.w	r0,r2[0x4]
8000535c:	80 00       	ld.sh	r0,r0[0x0]
8000535e:	d6 b8       	*unknown*
80005360:	80 00       	ld.sh	r0,r0[0x0]
80005362:	6a dc       	ld.w	r12,r5[0x34]
80005364:	00 00       	add	r0,r0
80005366:	0a 64       	and	r4,r5
80005368:	80 00       	ld.sh	r0,r0[0x0]
8000536a:	62 04       	ld.w	r4,r1[0x0]
8000536c:	00 00       	add	r0,r0
8000536e:	0a 44       	or	r4,r5
80005370:	80 00       	ld.sh	r0,r0[0x0]
80005372:	d7 ac       	*unknown*
80005374:	80 00       	ld.sh	r0,r0[0x0]
80005376:	d9 34       	*unknown*

80005378 <rfid_init>:
extern volatile U32 global_count;
extern volatile xSemaphoreHandle count_mutex;


void rfid_init()
{
80005378:	d4 01       	pushm	lr
	char card_id[4]={0};
	//tc_init();//ㄥ跺200msㄥ诲
	
	rc522_init();
8000537a:	f0 1f 00 02 	mcall	80005380 <rfid_init+0x8>
	
	//if(rfid_auto_reader(card_id) == 0){
		//log("card_id : 0x%x, 0x%x, 0x%x, 0x%x\n", &card_id[0], &card_id[1], &card_id[2], &card_id[3]);	
	//}
		//
}
8000537e:	d8 02       	popm	pc
80005380:	80 00       	ld.sh	r0,r0[0x0]
80005382:	4b d8       	lddpc	r8,80005474 <local_start_pll0+0x5c>

80005384 <delay_ns>:
}

void delay_ns(U32 ns)
{
	U32 i;
	for(i=0;i<ns;i++)
80005384:	58 0c       	cp.w	r12,0
80005386:	5e 0c       	reteq	r12
80005388:	30 08       	mov	r8,0
	{
		nop();
8000538a:	d7 03       	nop
		nop();
8000538c:	d7 03       	nop
		nop();
8000538e:	d7 03       	nop
}

void delay_ns(U32 ns)
{
	U32 i;
	for(i=0;i<ns;i++)
80005390:	2f f8       	sub	r8,-1
80005392:	10 3c       	cp.w	r12,r8
80005394:	fe 9b ff fb 	brhi	8000538a <delay_ns+0x6>
80005398:	5e fc       	retal	r12
8000539a:	d7 03       	nop

8000539c <delay_us>:
		nop();
		nop();
	}
}
void delay_us(U32 us)
{
8000539c:	eb cd 40 e0 	pushm	r5-r7,lr
800053a0:	18 96       	mov	r6,r12
	for(int i =0; i<us; i++){
800053a2:	58 0c       	cp.w	r12,0
800053a4:	c0 b0       	breq	800053ba <delay_us+0x1e>
800053a6:	30 07       	mov	r7,0
		delay_ns(1000);
800053a8:	e0 65 03 e8 	mov	r5,1000
800053ac:	0a 9c       	mov	r12,r5
800053ae:	f0 1f 00 05 	mcall	800053c0 <delay_us+0x24>
		nop();
	}
}
void delay_us(U32 us)
{
	for(int i =0; i<us; i++){
800053b2:	2f f7       	sub	r7,-1
800053b4:	0e 36       	cp.w	r6,r7
800053b6:	fe 9b ff fb 	brhi	800053ac <delay_us+0x10>
800053ba:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800053be:	00 00       	add	r0,r0
800053c0:	80 00       	ld.sh	r0,r0[0x0]
800053c2:	53 84       	stdsp	sp[0xe0],r4

800053c4 <delay_ms>:
		delay_ns(1000);
	}

}
void delay_ms(U32 ms)
{
800053c4:	eb cd 40 e0 	pushm	r5-r7,lr
800053c8:	18 96       	mov	r6,r12
	for(int i =0; i<ms; i++){
800053ca:	58 0c       	cp.w	r12,0
800053cc:	c0 b0       	breq	800053e2 <delay_ms+0x1e>
800053ce:	30 07       	mov	r7,0
		delay_us(1000);
800053d0:	e0 65 03 e8 	mov	r5,1000
800053d4:	0a 9c       	mov	r12,r5
800053d6:	f0 1f 00 05 	mcall	800053e8 <delay_ms+0x24>
	}

}
void delay_ms(U32 ms)
{
	for(int i =0; i<ms; i++){
800053da:	2f f7       	sub	r7,-1
800053dc:	0e 36       	cp.w	r6,r7
800053de:	fe 9b ff fb 	brhi	800053d4 <delay_ms+0x10>
800053e2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800053e6:	00 00       	add	r0,r0
800053e8:	80 00       	ld.sh	r0,r0[0x0]
800053ea:	53 9c       	stdsp	sp[0xe4],r12

800053ec <local_start_timer>:
//	SSC_TX_DATA_ENABLE		AVR32_TC_A0_0_0_PIN					[32 PortB Pin  0 00000001 Func 0]
//	MAKO_TX					AVR32_SSC_TX_DATA_0_PIN				[42 PortB Pin 10 00000400 Func 0]
//	MAKO_RX					AVR32_SSC_RX_DATA_0_PIN				[39 PortB Pin  7 00000080 Func 0]
//
void local_start_timer(void)
{
800053ec:	d4 01       	pushm	lr
	{
		{TIMER_TC_CLK_PIN,      TIMER_TC_CLK_FUNCTION     },
		{TIMER_TC_FS_PIN,       TIMER_TC_FS_FUNCTION      },
		{TIMER_EN_CLK_PIN,      TIMER_EN_CLK_FUNCTION     }
	};
	gpio_enable_module(TC_GPIO_MAP, sizeof(TC_GPIO_MAP) / sizeof(TC_GPIO_MAP[0]));
800053ee:	30 3b       	mov	r11,3
800053f0:	48 8c       	lddpc	r12,80005410 <local_start_timer+0x24>
800053f2:	f0 1f 00 09 	mcall	80005414 <local_start_timer+0x28>

	(&AVR32_TC)->channel[0].cmr =
800053f6:	fe 78 38 00 	mov	r8,-51200
800053fa:	e0 69 91 0d 	mov	r9,37133
800053fe:	ea 19 00 52 	orh	r9,0x52
80005402:	91 19       	st.w	r8[0x4],r9
	1                          << AVR32_TC_CLKI_OFFSET     |
	AVR32_TC_TCCLKS_XC0        << AVR32_TC_TCCLKS_OFFSET;



	(&AVR32_TC)->channel[0].ra = 32;
80005404:	32 09       	mov	r9,32
80005406:	91 59       	st.w	r8[0x14],r9
	(&AVR32_TC)->channel[0].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
80005408:	30 59       	mov	r9,5
8000540a:	91 09       	st.w	r8[0x0],r9
}
8000540c:	d8 02       	popm	pc
8000540e:	00 00       	add	r0,r0
80005410:	80 00       	ld.sh	r0,r0[0x0]
80005412:	d9 48       	*unknown*
80005414:	80 00       	ld.sh	r0,r0[0x0]
80005416:	55 9c       	stdsp	sp[0x164],r12

80005418 <local_start_pll0>:
//In the SSC description, Master Clock (MCK) is the bus clock of the peripheral bus to which the
//SSC is connected. [23.6.2]
//Switch to clock Osc0 (crystal)
//start PLL0 and switch main clock to PLL0 output
void local_start_pll0(void)
{
80005418:	d4 01       	pushm	lr
	AVR32_HMATRIX.mcfg[AVR32_HMATRIX_MASTER_CPU_INSTRUCTION] = 0x1;
	
***/
	
/*****/
	pm_switch_to_osc0(&AVR32_PM, 12000000, OSC0_STARTUP);
8000541a:	30 3a       	mov	r10,3
8000541c:	e0 6b 1b 00 	mov	r11,6912
80005420:	ea 1b 00 b7 	orh	r11,0xb7
80005424:	fe 7c 0c 00 	mov	r12,-62464
80005428:	f0 1f 00 19 	mcall	8000548c <local_start_pll0+0x74>

	pm_pll_setup(&AVR32_PM,
8000542c:	31 08       	mov	r8,16
8000542e:	1a d8       	st.w	--sp,r8
80005430:	30 08       	mov	r8,0
80005432:	30 19       	mov	r9,1
80005434:	30 7a       	mov	r10,7
80005436:	10 9b       	mov	r11,r8
80005438:	fe 7c 0c 00 	mov	r12,-62464
8000543c:	f0 1f 00 15 	mcall	80005490 <local_start_pll0+0x78>
	               0,   // use PLL0
	               7,   // MUL=7 in the formula
	               1,   // DIV=1 in the formula
	               0,   // Sel Osc0/PLL0 or Osc1/PLL1
	               16); // lockcount in main clock for the PLL wait lock
	pm_pll_set_option(&AVR32_PM, 0, //PLL number 0
80005440:	30 08       	mov	r8,0
80005442:	30 19       	mov	r9,1
80005444:	12 9a       	mov	r10,r9
80005446:	10 9b       	mov	r11,r8
80005448:	fe 7c 0c 00 	mov	r12,-62464
8000544c:	f0 1f 00 12 	mcall	80005494 <local_start_pll0+0x7c>
	                        1, //freq Set to 1 for VCO frequency range 80-180MHz
	                        1, //div2 Divide the PLL output frequency by 2
	                        0);//0 to enable the Wide-Bandith Mode
	pm_pll_enable(&AVR32_PM,0);
80005450:	30 0b       	mov	r11,0
80005452:	fe 7c 0c 00 	mov	r12,-62464
80005456:	f0 1f 00 11 	mcall	80005498 <local_start_pll0+0x80>


	pm_wait_for_pll0_locked(&AVR32_PM);
8000545a:	fe 7c 0c 00 	mov	r12,-62464
8000545e:	f0 1f 00 10 	mcall	8000549c <local_start_pll0+0x84>


	pm_cksel(&AVR32_PM, 1,  //Bus A clock divisor enable = 1
80005462:	30 0a       	mov	r10,0
80005464:	1a da       	st.w	--sp,r10
80005466:	1a da       	st.w	--sp,r10
80005468:	14 98       	mov	r8,r10
8000546a:	14 99       	mov	r9,r10
8000546c:	30 1b       	mov	r11,1
8000546e:	fe 7c 0c 00 	mov	r12,-62464
80005472:	f0 1f 00 0c 	mcall	800054a0 <local_start_pll0+0x88>
	             0,  //B clock divisor enable = 0
	             0,  //Bus B select = 0
	             0,  //HS Bus clock divisor enable = 0
	             0); //HS Bus select = 0
				 
	flashc_set_wait_state(1);
80005476:	30 1c       	mov	r12,1
80005478:	f0 1f 00 0b 	mcall	800054a4 <local_start_pll0+0x8c>
	//AVR32_FLASHC.fcr = 0x00000040;

	pm_switch_to_clock(&AVR32_PM, AVR32_PM_MCSEL_PLL0);
8000547c:	30 2b       	mov	r11,2
8000547e:	fe 7c 0c 00 	mov	r12,-62464
80005482:	f0 1f 00 0a 	mcall	800054a8 <local_start_pll0+0x90>
80005486:	2f dd       	sub	sp,-12
/****/
}
80005488:	d8 02       	popm	pc
8000548a:	00 00       	add	r0,r0
8000548c:	80 00       	ld.sh	r0,r0[0x0]
8000548e:	58 50       	cp.w	r0,5
80005490:	80 00       	ld.sh	r0,r0[0x0]
80005492:	57 f2       	stdsp	sp[0x1fc],r2
80005494:	80 00       	ld.sh	r0,r0[0x0]
80005496:	58 14       	cp.w	r4,1
80005498:	80 00       	ld.sh	r0,r0[0x0]
8000549a:	58 2e       	cp.w	lr,2
8000549c:	80 00       	ld.sh	r0,r0[0x0]
8000549e:	58 3c       	cp.w	r12,3
800054a0:	80 00       	ld.sh	r0,r0[0x0]
800054a2:	57 ac       	stdsp	sp[0x1e8],r12
800054a4:	80 00       	ld.sh	r0,r0[0x0]
800054a6:	55 3c       	stdsp	sp[0x14c],r12
800054a8:	80 00       	ld.sh	r0,r0[0x0]
800054aa:	58 46       	cp.w	r6,4

800054ac <xg_flashc_init>:
}


//U16	Current_total_message_count=0;
void xg_flashc_init(void)
{
800054ac:	eb cd 40 e0 	pushm	r5-r7,lr
	//{
		//log("Create the xgflash_mutex semaphore failure\n");
	//}
	//
	/* Create the binary semaphore to Synchronize other threads.*/
	vSemaphoreCreateBinary(xBinarySemaphore);
800054b0:	30 0b       	mov	r11,0
800054b2:	30 1c       	mov	r12,1
800054b4:	f0 1f 00 19 	mcall	80005518 <xg_flashc_init+0x6c>
800054b8:	49 98       	lddpc	r8,8000551c <xg_flashc_init+0x70>
800054ba:	91 0c       	st.w	r8[0x0],r12
800054bc:	70 08       	ld.w	r8,r8[0x0]
800054be:	58 08       	cp.w	r8,0
800054c0:	c0 80       	breq	800054d0 <xg_flashc_init+0x24>
800054c2:	49 78       	lddpc	r8,8000551c <xg_flashc_init+0x70>
800054c4:	70 0c       	ld.w	r12,r8[0x0]
800054c6:	30 09       	mov	r9,0
800054c8:	12 9a       	mov	r10,r9
800054ca:	12 9b       	mov	r11,r9
800054cc:	f0 1f 00 15 	mcall	80005520 <xg_flashc_init+0x74>
	if (xBinarySemaphore == NULL)
800054d0:	49 38       	lddpc	r8,8000551c <xg_flashc_init+0x70>
800054d2:	70 08       	ld.w	r8,r8[0x0]
800054d4:	58 08       	cp.w	r8,0
800054d6:	c0 41       	brne	800054de <xg_flashc_init+0x32>
	{
		log("Create the xBinarySemaphore failure\n");
800054d8:	49 3c       	lddpc	r12,80005524 <xg_flashc_init+0x78>
800054da:	f0 1f 00 14 	mcall	80005528 <xg_flashc_init+0x7c>
	//if (SendM_CountingSemaphore == NULL)
	//{
		//log("Create the SendM_Counting semaphore failure\n");
	//}
	//
	xg_resend_queue = xQueueCreate(300, sizeof(U32));
800054de:	30 4b       	mov	r11,4
800054e0:	e0 6c 01 2c 	mov	r12,300
800054e4:	f0 1f 00 0d 	mcall	80005518 <xg_flashc_init+0x6c>
800054e8:	49 18       	lddpc	r8,8000552c <xg_flashc_init+0x80>
800054ea:	91 0c       	st.w	r8[0x0],r12
	/*initialize the queue*/
	message_storage_queue = xQueueCreate(MAX_MESSAGE_STORE, sizeof(U32));
800054ec:	30 4b       	mov	r11,4
800054ee:	e0 6c 01 90 	mov	r12,400
800054f2:	f0 1f 00 0a 	mcall	80005518 <xg_flashc_init+0x6c>
800054f6:	48 f8       	lddpc	r8,80005530 <xg_flashc_init+0x84>
800054f8:	91 0c       	st.w	r8[0x0],r12
800054fa:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_MESSAGE_STORE; i++ )
	{
		set_message_store(&message_store[i]);//push <message_store> address to the message_storage_queue;
800054fc:	10 96       	mov	r6,r8
800054fe:	48 e5       	lddpc	r5,80005534 <xg_flashc_init+0x88>
80005500:	6c 0c       	ld.w	r12,r6[0x0]
80005502:	ea 07 00 0b 	add	r11,r5,r7
80005506:	f0 1f 00 0d 	mcall	80005538 <xg_flashc_init+0x8c>
8000550a:	2e 67       	sub	r7,-26
	//}
	//
	xg_resend_queue = xQueueCreate(300, sizeof(U32));
	/*initialize the queue*/
	message_storage_queue = xQueueCreate(MAX_MESSAGE_STORE, sizeof(U32));
	for(int i= 0; i < MAX_MESSAGE_STORE; i++ )
8000550c:	e0 47 28 a0 	cp.w	r7,10400
80005510:	cf 81       	brne	80005500 <xg_flashc_init+0x54>
	//flashc_lock_all_regions(false);
	//xgflash_list_info_init();
	
	
	//create_xg_flash_test_task();
}
80005512:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80005516:	00 00       	add	r0,r0
80005518:	80 00       	ld.sh	r0,r0[0x0]
8000551a:	65 68       	ld.w	r8,r2[0x58]
8000551c:	00 00       	add	r0,r0
8000551e:	0b 78       	ld.ub	r8,--r5
80005520:	80 00       	ld.sh	r0,r0[0x0]
80005522:	64 10       	ld.w	r0,r2[0x4]
80005524:	80 00       	ld.sh	r0,r0[0x0]
80005526:	d9 60       	acall	0x96
80005528:	80 00       	ld.sh	r0,r0[0x0]
8000552a:	70 48       	ld.w	r8,r8[0x10]
8000552c:	00 00       	add	r0,r0
8000552e:	0b 70       	ld.ub	r0,--r5
80005530:	00 00       	add	r0,r0
80005532:	0b 74       	ld.ub	r4,--r5
80005534:	00 00       	add	r0,r0
80005536:	97 48       	st.w	r11[0x10],r8
80005538:	80 00       	ld.sh	r0,r0[0x0]
8000553a:	2c b4       	sub	r4,-53

8000553c <flashc_set_wait_state>:
}


void flashc_set_wait_state(unsigned int wait_state)
{
	u_avr32_flashc_fcr_t u_avr32_flashc_fcr = {AVR32_FLASHC.fcr};
8000553c:	fe 68 14 00 	mov	r8,-125952
80005540:	70 09       	ld.w	r9,r8[0x0]
	u_avr32_flashc_fcr.FCR.fws = wait_state;
80005542:	f3 dc d0 c1 	bfins	r9,r12,0x6,0x1
	AVR32_FLASHC.fcr = u_avr32_flashc_fcr.fcr;
80005546:	91 09       	st.w	r8[0x0],r9
}
80005548:	5e fc       	retal	r12

8000554a <gpio_enable_module_pin>:
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
8000554a:	f8 08 16 05 	lsr	r8,r12,0x5
8000554e:	a9 68       	lsl	r8,0x8
80005550:	e0 28 f0 00 	sub	r8,61440

	/* Enable the correct function. */
	switch (function) {
80005554:	58 1b       	cp.w	r11,1
80005556:	c0 d0       	breq	80005570 <gpio_enable_module_pin+0x26>
80005558:	c0 63       	brcs	80005564 <gpio_enable_module_pin+0x1a>
8000555a:	58 2b       	cp.w	r11,2
8000555c:	c1 00       	breq	8000557c <gpio_enable_module_pin+0x32>
8000555e:	58 3b       	cp.w	r11,3
80005560:	c1 40       	breq	80005588 <gpio_enable_module_pin+0x3e>
80005562:	5e ff       	retal	1
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80005564:	30 19       	mov	r9,1
80005566:	f2 0c 09 49 	lsl	r9,r9,r12
8000556a:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
8000556c:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
8000556e:	c1 28       	rjmp	80005592 <gpio_enable_module_pin+0x48>

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80005570:	30 19       	mov	r9,1
80005572:	f2 0c 09 49 	lsl	r9,r9,r12
80005576:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80005578:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
8000557a:	c0 c8       	rjmp	80005592 <gpio_enable_module_pin+0x48>

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
8000557c:	30 19       	mov	r9,1
8000557e:	f2 0c 09 49 	lsl	r9,r9,r12
80005582:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80005584:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80005586:	c0 68       	rjmp	80005592 <gpio_enable_module_pin+0x48>

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80005588:	30 19       	mov	r9,1
8000558a:	f2 0c 09 49 	lsl	r9,r9,r12
8000558e:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80005590:	91 99       	st.w	r8[0x24],r9
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
80005592:	30 19       	mov	r9,1
80005594:	f2 0c 09 4c 	lsl	r12,r9,r12
80005598:	91 2c       	st.w	r8[0x8],r12
8000559a:	5e fd       	retal	0

8000559c <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
8000559c:	d4 21       	pushm	r4-r7,lr
8000559e:	18 97       	mov	r7,r12
800055a0:	16 94       	mov	r4,r11
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
800055a2:	58 0b       	cp.w	r11,0
800055a4:	c0 31       	brne	800055aa <gpio_enable_module+0xe>
800055a6:	30 05       	mov	r5,0
800055a8:	c0 d8       	rjmp	800055c2 <gpio_enable_module+0x26>
800055aa:	30 06       	mov	r6,0
800055ac:	0c 95       	mov	r5,r6
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
800055ae:	6e 1b       	ld.w	r11,r7[0x4]
800055b0:	6e 0c       	ld.w	r12,r7[0x0]
800055b2:	f0 1f 00 06 	mcall	800055c8 <gpio_enable_module+0x2c>
800055b6:	18 45       	or	r5,r12
		gpiomap++;
800055b8:	2f 87       	sub	r7,-8
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
800055ba:	2f f6       	sub	r6,-1
800055bc:	0c 34       	cp.w	r4,r6
800055be:	fe 9b ff f8 	brhi	800055ae <gpio_enable_module+0x12>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
}
800055c2:	0a 9c       	mov	r12,r5
800055c4:	d8 22       	popm	r4-r7,pc
800055c6:	00 00       	add	r0,r0
800055c8:	80 00       	ld.sh	r0,r0[0x0]
800055ca:	55 4a       	stdsp	sp[0x150],r10

800055cc <gpio_enable_gpio_pin>:
 *            AVR32_PWM_3_PIN for PWM channel 3 can also be used to release
 *            module pins for GPIO.
 */
void gpio_enable_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
800055cc:	f8 08 16 05 	lsr	r8,r12,0x5
800055d0:	a9 68       	lsl	r8,0x8
800055d2:	e0 28 f0 00 	sub	r8,61440
	
	gpio_port->oderc = 1 << (pin & 0x1F);
800055d6:	30 19       	mov	r9,1
800055d8:	f2 0c 09 4c 	lsl	r12,r9,r12
800055dc:	f1 4c 00 48 	st.w	r8[72],r12
	gpio_port->gpers = 1 << (pin & 0x1F);
800055e0:	91 1c       	st.w	r8[0x4],r12
}
800055e2:	5e fc       	retal	r12

800055e4 <gpio_set_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_set_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
800055e4:	f8 08 16 05 	lsr	r8,r12,0x5
800055e8:	a9 68       	lsl	r8,0x8
800055ea:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 1. */
	gpio_port->ovrs  = 1 << (pin & 0x1F);
800055ee:	30 19       	mov	r9,1
800055f0:	f2 0c 09 4c 	lsl	r12,r9,r12
800055f4:	f1 4c 00 54 	st.w	r8[84],r12
	/* The GPIO output driver is enabled for that pin. */ 
	gpio_port->oders = 1 << (pin & 0x1F);
800055f8:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
800055fc:	91 1c       	st.w	r8[0x4],r12
}
800055fe:	5e fc       	retal	r12

80005600 <gpio_clr_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_clr_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80005600:	f8 08 16 05 	lsr	r8,r12,0x5
80005604:	a9 68       	lsl	r8,0x8
80005606:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 0. */
	gpio_port->ovrc  = 1 << (pin & 0x1F);
8000560a:	30 19       	mov	r9,1
8000560c:	f2 0c 09 4c 	lsl	r12,r9,r12
80005610:	f1 4c 00 58 	st.w	r8[88],r12
	/* The GPIO output driver is enabled for that pin. */
	gpio_port->oders = 1 << (pin & 0x1F);
80005614:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
80005618:	91 1c       	st.w	r8[0x4],r12
}
8000561a:	5e fc       	retal	r12

8000561c <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
8000561c:	c0 08       	rjmp	8000561c <_unhandled_interrupt>
8000561e:	d7 03       	nop

80005620 <INTC_register_interrupt>:
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
80005620:	f6 08 16 05 	lsr	r8,r11,0x5

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
80005624:	49 99       	lddpc	r9,80005688 <INTC_register_interrupt+0x68>
80005626:	f2 08 00 39 	add	r9,r9,r8<<0x3
8000562a:	f7 db c0 05 	bfextu	r11,r11,0x0,0x5
8000562e:	72 19       	ld.w	r9,r9[0x4]
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
80005630:	f2 0b 09 2c 	st.w	r9[r11<<0x2],r12
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
80005634:	58 0a       	cp.w	r10,0
80005636:	c0 91       	brne	80005648 <INTC_register_interrupt+0x28>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80005638:	49 59       	lddpc	r9,8000568c <INTC_register_interrupt+0x6c>
8000563a:	49 6a       	lddpc	r10,80005690 <INTC_register_interrupt+0x70>
8000563c:	12 1a       	sub	r10,r9
8000563e:	fe 79 08 00 	mov	r9,-63488
80005642:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80005646:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT1) {
80005648:	58 1a       	cp.w	r10,1
8000564a:	c0 a1       	brne	8000565e <INTC_register_interrupt+0x3e>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
8000564c:	49 09       	lddpc	r9,8000568c <INTC_register_interrupt+0x6c>
8000564e:	49 2a       	lddpc	r10,80005694 <INTC_register_interrupt+0x74>
80005650:	12 1a       	sub	r10,r9
80005652:	bf aa       	sbr	r10,0x1e
80005654:	fe 79 08 00 	mov	r9,-63488
80005658:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
8000565c:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT2) {
8000565e:	58 2a       	cp.w	r10,2
80005660:	c0 a1       	brne	80005674 <INTC_register_interrupt+0x54>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
80005662:	48 b9       	lddpc	r9,8000568c <INTC_register_interrupt+0x6c>
80005664:	48 da       	lddpc	r10,80005698 <INTC_register_interrupt+0x78>
80005666:	12 1a       	sub	r10,r9
80005668:	bf ba       	sbr	r10,0x1f
8000566a:	fe 79 08 00 	mov	r9,-63488
8000566e:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80005672:	5e fc       	retal	r12
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
80005674:	48 69       	lddpc	r9,8000568c <INTC_register_interrupt+0x6c>
80005676:	48 aa       	lddpc	r10,8000569c <INTC_register_interrupt+0x7c>
80005678:	12 1a       	sub	r10,r9
8000567a:	ea 1a c0 00 	orh	r10,0xc000
8000567e:	fe 79 08 00 	mov	r9,-63488
80005682:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80005686:	5e fc       	retal	r12
80005688:	80 00       	ld.sh	r0,r0[0x0]
8000568a:	d9 98       	*unknown*
8000568c:	80 00       	ld.sh	r0,r0[0x0]
8000568e:	ce 00       	breq	8000564e <INTC_register_interrupt+0x2e>
80005690:	80 00       	ld.sh	r0,r0[0x0]
80005692:	cf 04       	brge	80005672 <INTC_register_interrupt+0x52>
80005694:	80 00       	ld.sh	r0,r0[0x0]
80005696:	cf 12       	brcc	80005678 <INTC_register_interrupt+0x58>
80005698:	80 00       	ld.sh	r0,r0[0x0]
8000569a:	cf 20       	breq	8000567e <INTC_register_interrupt+0x5e>
8000569c:	80 00       	ld.sh	r0,r0[0x0]
8000569e:	cf 2e       	rcall	80005482 <local_start_pll0+0x6a>

800056a0 <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
800056a0:	d4 21       	pushm	r4-r7,lr
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
800056a2:	49 18       	lddpc	r8,800056e4 <INTC_init_interrupts+0x44>
800056a4:	e3 b8 00 01 	mtsr	0x4,r8
800056a8:	49 0e       	lddpc	lr,800056e8 <INTC_init_interrupts+0x48>
800056aa:	30 07       	mov	r7,0
800056ac:	0e 94       	mov	r4,r7
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
800056ae:	49 0c       	lddpc	r12,800056ec <INTC_init_interrupts+0x4c>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
800056b0:	49 05       	lddpc	r5,800056f0 <INTC_init_interrupts+0x50>
800056b2:	10 15       	sub	r5,r8
800056b4:	fe 76 08 00 	mov	r6,-63488
800056b8:	c1 08       	rjmp	800056d8 <INTC_init_interrupts+0x38>
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
800056ba:	08 98       	mov	r8,r4
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
				._int_line_handler_table[int_req]
800056bc:	7c 1b       	ld.w	r11,lr[0x4]

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
800056be:	7c 0a       	ld.w	r10,lr[0x0]
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
800056c0:	f6 08 09 2c 	st.w	r11[r8<<0x2],r12
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
800056c4:	2f f8       	sub	r8,-1

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
800056c6:	10 3a       	cp.w	r10,r8
800056c8:	fe 9b ff fc 	brhi	800056c0 <INTC_init_interrupts+0x20>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
800056cc:	ec 07 09 25 	st.w	r6[r7<<0x2],r5
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
800056d0:	2f f7       	sub	r7,-1
800056d2:	2f 8e       	sub	lr,-8
800056d4:	59 37       	cp.w	r7,19
800056d6:	c0 50       	breq	800056e0 <INTC_init_interrupts+0x40>
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
800056d8:	7c 08       	ld.w	r8,lr[0x0]
800056da:	58 08       	cp.w	r8,0
800056dc:	ce f1       	brne	800056ba <INTC_init_interrupts+0x1a>
800056de:	cf 7b       	rjmp	800056cc <INTC_init_interrupts+0x2c>
800056e0:	d8 22       	popm	r4-r7,pc
800056e2:	00 00       	add	r0,r0
800056e4:	80 00       	ld.sh	r0,r0[0x0]
800056e6:	ce 00       	breq	800056a6 <INTC_init_interrupts+0x6>
800056e8:	80 00       	ld.sh	r0,r0[0x0]
800056ea:	d9 98       	*unknown*
800056ec:	80 00       	ld.sh	r0,r0[0x0]
800056ee:	56 1c       	stdsp	sp[0x184],r12
800056f0:	80 00       	ld.sh	r0,r0[0x0]
800056f2:	cf 04       	brge	800056d2 <INTC_init_interrupts+0x32>

800056f4 <_get_interrupt_handler>:
__int_handler _get_interrupt_handler(uint32_t int_level)
{
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
800056f4:	fe 78 08 00 	mov	r8,-63488
800056f8:	e0 69 00 83 	mov	r9,131
800056fc:	f2 0c 01 0c 	sub	r12,r9,r12
80005700:	f0 0c 03 29 	ld.w	r9,r8[r12<<0x2]
	uint32_t int_req = AVR32_INTC.irr[int_grp];
80005704:	f2 ca ff c0 	sub	r10,r9,-64
80005708:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
8000570c:	58 08       	cp.w	r8,0
8000570e:	c0 21       	brne	80005712 <_get_interrupt_handler+0x1e>
80005710:	5e fd       	retal	0
		? _int_handler_table[int_grp]._int_line_handler_table[32
80005712:	f0 08 12 00 	clz	r8,r8
80005716:	48 5a       	lddpc	r10,80005728 <_get_interrupt_handler+0x34>
80005718:	f4 09 00 39 	add	r9,r10,r9<<0x3
8000571c:	f0 08 11 1f 	rsub	r8,r8,31
80005720:	72 19       	ld.w	r9,r9[0x4]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
80005722:	f2 08 03 2c 	ld.w	r12,r9[r8<<0x2]
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
80005726:	5e fc       	retal	r12
80005728:	80 00       	ld.sh	r0,r0[0x0]
8000572a:	d9 98       	*unknown*

8000572c <pm_set_osc0_mode>:
 * \param mode Oscillator 0 mode (i.e. AVR32_PM_OSCCTRL0_MODE_x).
 */
static void pm_set_osc0_mode(volatile avr32_pm_t *pm, unsigned int mode)
{
  // Read
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
8000572c:	78 a8       	ld.w	r8,r12[0x28]
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.mode = mode;
8000572e:	f1 db d0 03 	bfins	r8,r11,0x0,0x3
  // Write
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
80005732:	99 a8       	st.w	r12[0x28],r8
}
80005734:	5e fc       	retal	r12
80005736:	d7 03       	nop

80005738 <pm_enable_osc0_crystal>:
  pm_set_osc0_mode(pm, AVR32_PM_OSCCTRL0_MODE_EXT_CLOCK);
}


void pm_enable_osc0_crystal(volatile avr32_pm_t *pm, unsigned int fosc0)
{
80005738:	d4 01       	pushm	lr
  pm_set_osc0_mode(pm, (fosc0 <  900000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G0 :
8000573a:	ec 5b bb 9f 	cp.w	r11,899999
8000573e:	e0 8b 00 04 	brhi	80005746 <pm_enable_osc0_crystal+0xe>
80005742:	30 4b       	mov	r11,4
80005744:	c1 38       	rjmp	8000576a <pm_enable_osc0_crystal+0x32>
80005746:	e0 68 c6 bf 	mov	r8,50879
8000574a:	ea 18 00 2d 	orh	r8,0x2d
8000574e:	10 3b       	cp.w	r11,r8
80005750:	e0 8b 00 04 	brhi	80005758 <pm_enable_osc0_crystal+0x20>
80005754:	30 5b       	mov	r11,5
80005756:	c0 a8       	rjmp	8000576a <pm_enable_osc0_crystal+0x32>
80005758:	e0 68 12 00 	mov	r8,4608
8000575c:	ea 18 00 7a 	orh	r8,0x7a
80005760:	10 3b       	cp.w	r11,r8
80005762:	f9 bb 03 06 	movlo	r11,6
80005766:	f9 bb 02 07 	movhs	r11,7
8000576a:	f0 1f 00 02 	mcall	80005770 <pm_enable_osc0_crystal+0x38>
                       (fosc0 < 3000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G1 :
                       (fosc0 < 8000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G2 :
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}
8000576e:	d8 02       	popm	pc
80005770:	80 00       	ld.sh	r0,r0[0x0]
80005772:	57 2c       	stdsp	sp[0x1c8],r12

80005774 <pm_enable_clk0_no_wait>:


void pm_enable_clk0_no_wait(volatile avr32_pm_t *pm, unsigned int startup)
{
  // Read register
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
80005774:	78 a8       	ld.w	r8,r12[0x28]
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.startup = startup;
80005776:	f1 db d1 03 	bfins	r8,r11,0x8,0x3
  // Write back
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
8000577a:	99 a8       	st.w	r12[0x28],r8

  pm->mcctrl |= AVR32_PM_MCCTRL_OSC0EN_MASK;
8000577c:	78 08       	ld.w	r8,r12[0x0]
8000577e:	a3 a8       	sbr	r8,0x2
80005780:	99 08       	st.w	r12[0x0],r8
}
80005782:	5e fc       	retal	r12

80005784 <pm_wait_for_clk0_ready>:


void pm_wait_for_clk0_ready(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
80005784:	79 58       	ld.w	r8,r12[0x54]
80005786:	e2 18 00 80 	andl	r8,0x80,COH
8000578a:	cf d0       	breq	80005784 <pm_wait_for_clk0_ready>
}
8000578c:	5e fc       	retal	r12
8000578e:	d7 03       	nop

80005790 <pm_enable_clk0>:
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}


void pm_enable_clk0(volatile avr32_pm_t *pm, unsigned int startup)
{
80005790:	eb cd 40 80 	pushm	r7,lr
80005794:	18 97       	mov	r7,r12
  pm_enable_clk0_no_wait(pm, startup);
80005796:	f0 1f 00 04 	mcall	800057a4 <pm_enable_clk0+0x14>
  pm_wait_for_clk0_ready(pm);
8000579a:	0e 9c       	mov	r12,r7
8000579c:	f0 1f 00 03 	mcall	800057a8 <pm_enable_clk0+0x18>
}
800057a0:	e3 cd 80 80 	ldm	sp++,r7,pc
800057a4:	80 00       	ld.sh	r0,r0[0x0]
800057a6:	57 74       	stdsp	sp[0x1dc],r4
800057a8:	80 00       	ld.sh	r0,r0[0x0]
800057aa:	57 84       	stdsp	sp[0x1e0],r4

800057ac <pm_cksel>:
              unsigned int pbasel,
              unsigned int pbbdiv,
              unsigned int pbbsel,
              unsigned int hsbdiv,
              unsigned int hsbsel)
{
800057ac:	eb cd 40 d0 	pushm	r4,r6-r7,lr
800057b0:	fa c4 ff f0 	sub	r4,sp,-16
  u_avr32_pm_cksel_t u_avr32_pm_cksel = {0};
800057b4:	30 0e       	mov	lr,0

  u_avr32_pm_cksel.CKSEL.cpusel = hsbsel;
800057b6:	09 f7       	ld.ub	r7,r4[0x7]
800057b8:	ef d7 c0 03 	bfextu	r7,r7,0x0,0x3
800057bc:	fd d7 d0 03 	bfins	lr,r7,0x0,0x3
  u_avr32_pm_cksel.CKSEL.cpudiv = hsbdiv;
800057c0:	09 b4       	ld.ub	r4,r4[0x3]
800057c2:	08 96       	mov	r6,r4
800057c4:	e9 d4 c0 01 	bfextu	r4,r4,0x0,0x1
800057c8:	fd d4 d0 e1 	bfins	lr,r4,0x7,0x1
  u_avr32_pm_cksel.CKSEL.hsbsel = hsbsel;
800057cc:	fd d7 d1 03 	bfins	lr,r7,0x8,0x3
  u_avr32_pm_cksel.CKSEL.hsbdiv = hsbdiv;
800057d0:	fd d4 d1 e1 	bfins	lr,r4,0xf,0x1
  u_avr32_pm_cksel.CKSEL.pbasel = pbasel;
800057d4:	fd da d2 03 	bfins	lr,r10,0x10,0x3
  u_avr32_pm_cksel.CKSEL.pbadiv = pbadiv;
800057d8:	fd db d2 e1 	bfins	lr,r11,0x17,0x1
  u_avr32_pm_cksel.CKSEL.pbbsel = pbbsel;
800057dc:	fd d8 d3 03 	bfins	lr,r8,0x18,0x3
  u_avr32_pm_cksel.CKSEL.pbbdiv = pbbdiv;
800057e0:	fd d9 d3 e1 	bfins	lr,r9,0x1f,0x1

  pm->cksel = u_avr32_pm_cksel.cksel;
800057e4:	99 1e       	st.w	r12[0x4],lr

  // Wait for ckrdy bit and then clear it
  while (!(pm->poscsr & AVR32_PM_POSCSR_CKRDY_MASK));
800057e6:	79 58       	ld.w	r8,r12[0x54]
800057e8:	e2 18 00 20 	andl	r8,0x20,COH
800057ec:	cf d0       	breq	800057e6 <pm_cksel+0x3a>
}
800057ee:	e3 cd 80 d0 	ldm	sp++,r4,r6-r7,pc

800057f2 <pm_pll_setup>:
                  unsigned int pll,
                  unsigned int mul,
                  unsigned int div,
                  unsigned int osc,
                  unsigned int lockcount)
{
800057f2:	eb cd 40 80 	pushm	r7,lr
800057f6:	40 27       	lddsp	r7,sp[0x8]
  u_avr32_pm_pll_t u_avr32_pm_pll = {0};
800057f8:	30 0e       	mov	lr,0

  u_avr32_pm_pll.PLL.pllosc   = osc;
800057fa:	fd d8 d0 21 	bfins	lr,r8,0x1,0x1
  u_avr32_pm_pll.PLL.plldiv   = div;
800057fe:	fd d9 d1 04 	bfins	lr,r9,0x8,0x4
  u_avr32_pm_pll.PLL.pllmul   = mul;
80005802:	fd da d2 04 	bfins	lr,r10,0x10,0x4
  u_avr32_pm_pll.PLL.pllcount = lockcount;
80005806:	fd d7 d3 06 	bfins	lr,r7,0x18,0x6

  pm->pll[pll] = u_avr32_pm_pll.pll;
8000580a:	2f 8b       	sub	r11,-8
8000580c:	f8 0b 09 2e 	st.w	r12[r11<<0x2],lr
}
80005810:	e3 cd 80 80 	ldm	sp++,r7,pc

80005814 <pm_pll_set_option>:
void pm_pll_set_option(volatile avr32_pm_t *pm,
                       unsigned int pll,
                       unsigned int pll_freq,
                       unsigned int pll_div2,
                       unsigned int pll_wbwdisable)
{
80005814:	d4 01       	pushm	lr
  u_avr32_pm_pll_t u_avr32_pm_pll = {pm->pll[pll]};
80005816:	2f 8b       	sub	r11,-8
80005818:	f8 0b 03 2e 	ld.w	lr,r12[r11<<0x2]
  u_avr32_pm_pll.PLL.pllopt = pll_freq | (pll_div2 << 1) | (pll_wbwdisable << 2);
8000581c:	f5 e9 10 19 	or	r9,r10,r9<<0x1
80005820:	f3 e8 10 28 	or	r8,r9,r8<<0x2
80005824:	fd d8 d0 43 	bfins	lr,r8,0x2,0x3
  pm->pll[pll] = u_avr32_pm_pll.pll;
80005828:	f8 0b 09 2e 	st.w	r12[r11<<0x2],lr
}
8000582c:	d8 02       	popm	pc

8000582e <pm_pll_enable>:


void pm_pll_enable(volatile avr32_pm_t *pm,
                  unsigned int pll)
{
  pm->pll[pll] |= AVR32_PM_PLLEN_MASK;
8000582e:	2f 8b       	sub	r11,-8
80005830:	f8 0b 03 28 	ld.w	r8,r12[r11<<0x2]
80005834:	a1 a8       	sbr	r8,0x0
80005836:	f8 0b 09 28 	st.w	r12[r11<<0x2],r8
}
8000583a:	5e fc       	retal	r12

8000583c <pm_wait_for_pll0_locked>:
}


void pm_wait_for_pll0_locked(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_LOCK0_MASK));
8000583c:	79 58       	ld.w	r8,r12[0x54]
8000583e:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80005842:	cf d0       	breq	8000583c <pm_wait_for_pll0_locked>
}
80005844:	5e fc       	retal	r12

80005846 <pm_switch_to_clock>:


void pm_switch_to_clock(volatile avr32_pm_t *pm, unsigned long clock)
{
  // Read
  u_avr32_pm_mcctrl_t u_avr32_pm_mcctrl = {pm->mcctrl};
80005846:	78 08       	ld.w	r8,r12[0x0]
  // Modify
  u_avr32_pm_mcctrl.MCCTRL.mcsel = clock;
80005848:	f1 db d0 02 	bfins	r8,r11,0x0,0x2
  // Write back
  pm->mcctrl = u_avr32_pm_mcctrl.mcctrl;
8000584c:	99 08       	st.w	r12[0x0],r8
}
8000584e:	5e fc       	retal	r12

80005850 <pm_switch_to_osc0>:


void pm_switch_to_osc0(volatile avr32_pm_t *pm, unsigned int fosc0, unsigned int startup)
{
80005850:	eb cd 40 c0 	pushm	r6-r7,lr
80005854:	18 97       	mov	r7,r12
80005856:	14 96       	mov	r6,r10
  pm_enable_osc0_crystal(pm, fosc0);            // Enable the Osc0 in crystal mode
80005858:	f0 1f 00 06 	mcall	80005870 <pm_switch_to_osc0+0x20>
  pm_enable_clk0(pm, startup);                  // Crystal startup time - This parameter is critical and depends on the characteristics of the crystal
8000585c:	0c 9b       	mov	r11,r6
8000585e:	0e 9c       	mov	r12,r7
80005860:	f0 1f 00 05 	mcall	80005874 <pm_switch_to_osc0+0x24>
  pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);  // Then switch main clock to Osc0
80005864:	30 1b       	mov	r11,1
80005866:	0e 9c       	mov	r12,r7
80005868:	f0 1f 00 04 	mcall	80005878 <pm_switch_to_osc0+0x28>
}
8000586c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005870:	80 00       	ld.sh	r0,r0[0x0]
80005872:	57 38       	stdsp	sp[0x1cc],r8
80005874:	80 00       	ld.sh	r0,r0[0x0]
80005876:	57 90       	stdsp	sp[0x1e4],r0
80005878:	80 00       	ld.sh	r0,r0[0x0]
8000587a:	58 46       	cp.w	r6,4

8000587c <getBaudDiv>:
xSemaphoreHandle xSPIMutex;
#endif

int16_t getBaudDiv(const uint32_t baudrate, uint32_t pb_hz)
{
	uint32_t baudDiv = div_ceil(pb_hz, baudrate);
8000587c:	f8 c8 00 01 	sub	r8,r12,1
80005880:	f0 0b 00 0b 	add	r11,r8,r11
80005884:	f6 0c 0d 0a 	divu	r10,r11,r12
80005888:	14 9c       	mov	r12,r10

	if (baudDiv <= 0 || baudDiv > 255) {
8000588a:	f4 c8 00 01 	sub	r8,r10,1
8000588e:	e0 48 00 fe 	cp.w	r8,254
80005892:	e0 88 00 03 	brls	80005898 <getBaudDiv+0x1c>
80005896:	5e fe       	retal	-1
		return -1;
	}

	return baudDiv;
80005898:	5c 8c       	casts.h	r12
}
8000589a:	5e fc       	retal	r12

8000589c <spi_initMaster>:
spi_status_t spi_initMaster(volatile avr32_spi_t *spi,
		const spi_options_t *options)
{
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (options->modfdis > 1) {
8000589c:	f7 39 00 0d 	ld.ub	r9,r11[13]
800058a0:	30 18       	mov	r8,1
800058a2:	f0 09 18 00 	cp.b	r9,r8
800058a6:	e0 88 00 04 	brls	800058ae <spi_initMaster+0x12>
800058aa:	30 2c       	mov	r12,2
800058ac:	5e fc       	retal	r12
		return SPI_ERROR_ARGUMENT;
	}

	/* Reset. */
	spi->cr = AVR32_SPI_CR_SWRST_MASK;
800058ae:	e0 68 00 80 	mov	r8,128
800058b2:	99 08       	st.w	r12[0x0],r8

	/* Master Mode. */
	u_avr32_spi_mr.mr = spi->mr;
800058b4:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.mstr = 1;
800058b6:	30 19       	mov	r9,1
800058b8:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_mr.MR.modfdis = options->modfdis;
800058bc:	f7 39 00 0d 	ld.ub	r9,r11[13]
800058c0:	f1 d9 d0 81 	bfins	r8,r9,0x4,0x1
	u_avr32_spi_mr.MR.llb = 0;
800058c4:	30 09       	mov	r9,0
800058c6:	f1 d9 d0 e1 	bfins	r8,r9,0x7,0x1
	u_avr32_spi_mr.MR.pcs = (1 << AVR32_SPI_MR_PCS_SIZE) - 1;
800058ca:	30 fa       	mov	r10,15
800058cc:	f1 da d2 04 	bfins	r8,r10,0x10,0x4
	spi->mr = u_avr32_spi_mr.mr;
800058d0:	99 18       	st.w	r12[0x4],r8
800058d2:	5e f9       	retal	r9

800058d4 <spi_selectionMode>:

spi_status_t spi_selectionMode(volatile avr32_spi_t *spi,
		uint8_t variable_ps,
		uint8_t pcs_decode,
		uint8_t delay)
{
800058d4:	d4 01       	pushm	lr
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (variable_ps > 1 ||
800058d6:	30 18       	mov	r8,1
800058d8:	f0 0b 18 00 	cp.b	r11,r8
800058dc:	5f be       	srhi	lr
800058de:	f0 0a 18 00 	cp.b	r10,r8
800058e2:	5f b8       	srhi	r8
800058e4:	fd e8 10 08 	or	r8,lr,r8
800058e8:	c0 30       	breq	800058ee <spi_selectionMode+0x1a>
800058ea:	30 2c       	mov	r12,2
800058ec:	d8 02       	popm	pc
			pcs_decode > 1) {
		return SPI_ERROR_ARGUMENT;
	}

	u_avr32_spi_mr.mr = spi->mr;
800058ee:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.ps = variable_ps;
800058f0:	f1 db d0 21 	bfins	r8,r11,0x1,0x1
	u_avr32_spi_mr.MR.pcsdec = pcs_decode;
800058f4:	f1 da d0 41 	bfins	r8,r10,0x2,0x1
	u_avr32_spi_mr.MR.dlybcs = delay;
800058f8:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8
	spi->mr = u_avr32_spi_mr.mr;
800058fc:	99 18       	st.w	r12[0x4],r8
800058fe:	d8 0a       	popm	pc,r12=0

80005900 <spi_enable>:
	return SPI_OK;
}

void spi_enable(volatile avr32_spi_t *spi)
{
	spi->cr = AVR32_SPI_CR_SPIEN_MASK;
80005900:	30 18       	mov	r8,1
80005902:	99 08       	st.w	r12[0x0],r8
}
80005904:	5e fc       	retal	r12

80005906 <spi_write>:
{
	return ((spi->sr & AVR32_SPI_SR_TDRE_MASK) != 0);
}

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
80005906:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
8000590a:	c0 58       	rjmp	80005914 <spi_write+0xe>
		if (!timeout--) {
8000590c:	58 08       	cp.w	r8,0
8000590e:	c0 21       	brne	80005912 <spi_write+0xc>
80005910:	5e ff       	retal	1
80005912:	20 18       	sub	r8,1

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
80005914:	78 49       	ld.w	r9,r12[0x10]
80005916:	e2 19 00 02 	andl	r9,0x2,COH
8000591a:	cf 90       	breq	8000590c <spi_write+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	spi->tdr = data << AVR32_SPI_TDR_TD_OFFSET;
8000591c:	5c 7b       	castu.h	r11
8000591e:	99 3b       	st.w	r12[0xc],r11
80005920:	5e fd       	retal	0

80005922 <spi_read>:
{
	return ((spi->sr & AVR32_SPI_SR_RDRF_MASK) != 0);
}

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
80005922:	e0 68 3a 98 	mov	r8,15000
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
80005926:	c0 58       	rjmp	80005930 <spi_read+0xe>
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) !=
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) {
		if (!timeout--) {
80005928:	58 08       	cp.w	r8,0
8000592a:	c0 21       	brne	8000592e <spi_read+0xc>
8000592c:	5e ff       	retal	1
8000592e:	20 18       	sub	r8,1

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
80005930:	78 49       	ld.w	r9,r12[0x10]
80005932:	e2 19 02 01 	andl	r9,0x201,COH
80005936:	e0 49 02 01 	cp.w	r9,513
8000593a:	cf 71       	brne	80005928 <spi_read+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	*data = spi->rdr >> AVR32_SPI_RDR_RD_OFFSET;
8000593c:	78 28       	ld.w	r8,r12[0x8]
8000593e:	b6 08       	st.h	r11[0x0],r8
80005940:	5e fd       	retal	0
80005942:	d7 03       	nop

80005944 <spi_setupChipReg>:
}

spi_status_t spi_setupChipReg(volatile avr32_spi_t *spi,
		const spi_options_t *options,
		uint32_t pb_hz)
{
80005944:	eb cd 40 f8 	pushm	r3-r7,lr
80005948:	18 95       	mov	r5,r12
8000594a:	16 97       	mov	r7,r11
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
8000594c:	f7 36 00 0c 	ld.ub	r6,r11[12]
80005950:	30 38       	mov	r8,3
80005952:	f0 06 18 00 	cp.b	r6,r8
80005956:	e0 8b 00 5e 	brhi	80005a12 <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
8000595a:	f7 34 00 0b 	ld.ub	r4,r11[11]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
8000595e:	30 18       	mov	r8,1
80005960:	f0 04 18 00 	cp.b	r4,r8
80005964:	e0 8b 00 57 	brhi	80005a12 <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
80005968:	f7 33 00 08 	ld.ub	r3,r11[8]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
8000596c:	30 78       	mov	r8,7
8000596e:	f0 03 18 00 	cp.b	r3,r8
80005972:	e0 88 00 50 	brls	80005a12 <spi_setupChipReg+0xce>
80005976:	31 08       	mov	r8,16
80005978:	f0 03 18 00 	cp.b	r3,r8
8000597c:	e0 8b 00 4b 	brhi	80005a12 <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
		return SPI_ERROR_ARGUMENT;
	}

	int baudDiv = getBaudDiv(options->baudrate, pb_hz);
80005980:	14 9b       	mov	r11,r10
80005982:	6e 1c       	ld.w	r12,r7[0x4]
80005984:	f0 1f 00 26 	mcall	80005a1c <spi_setupChipReg+0xd8>

	if (baudDiv < 0) {
80005988:	c4 55       	brlt	80005a12 <spi_setupChipReg+0xce>
		return SPI_ERROR_ARGUMENT;
	}

	/* Will use CSR0 offsets; these are the same for CSR0 to CSR3. */
	u_avr32_spi_csr.csr = 0;
8000598a:	30 08       	mov	r8,0
	u_avr32_spi_csr.CSR.cpol   = options->spi_mode >> 1;
8000598c:	ec 09 16 01 	lsr	r9,r6,0x1
80005990:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_csr.CSR.ncpha  = (options->spi_mode & 0x1) ^ 0x1;
80005994:	ec 16 00 01 	eorl	r6,0x1
80005998:	f1 d6 d0 21 	bfins	r8,r6,0x1,0x1
	u_avr32_spi_csr.CSR.csaat  = options->stay_act;
8000599c:	f1 d4 d0 61 	bfins	r8,r4,0x3,0x1
	u_avr32_spi_csr.CSR.bits   = options->bits - 8;
800059a0:	20 83       	sub	r3,8
800059a2:	f1 d3 d0 84 	bfins	r8,r3,0x4,0x4
	u_avr32_spi_csr.CSR.scbr   = baudDiv;
800059a6:	f1 dc d1 08 	bfins	r8,r12,0x8,0x8
	u_avr32_spi_csr.CSR.dlybs  = options->spck_delay;
800059aa:	ef 39 00 09 	ld.ub	r9,r7[9]
800059ae:	f1 d9 d2 08 	bfins	r8,r9,0x10,0x8
	u_avr32_spi_csr.CSR.dlybct = options->trans_delay;
800059b2:	ef 39 00 0a 	ld.ub	r9,r7[10]
800059b6:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8

	switch (options->reg) {
800059ba:	0f 89       	ld.ub	r9,r7[0x0]
800059bc:	30 1a       	mov	r10,1
800059be:	f4 09 18 00 	cp.b	r9,r10
800059c2:	c0 d0       	breq	800059dc <spi_setupChipReg+0x98>
800059c4:	c0 a3       	brcs	800059d8 <spi_setupChipReg+0x94>
800059c6:	30 2a       	mov	r10,2
800059c8:	f4 09 18 00 	cp.b	r9,r10
800059cc:	c0 a0       	breq	800059e0 <spi_setupChipReg+0x9c>
800059ce:	30 3a       	mov	r10,3
800059d0:	f4 09 18 00 	cp.b	r9,r10
800059d4:	c1 f1       	brne	80005a12 <spi_setupChipReg+0xce>
800059d6:	c0 78       	rjmp	800059e4 <spi_setupChipReg+0xa0>
	case 0:
		spi->csr0 = u_avr32_spi_csr.csr;
800059d8:	8b c8       	st.w	r5[0x30],r8
		break;
800059da:	c0 68       	rjmp	800059e6 <spi_setupChipReg+0xa2>

	case 1:
		spi->csr1 = u_avr32_spi_csr.csr;
800059dc:	8b d8       	st.w	r5[0x34],r8
		break;
800059de:	c0 48       	rjmp	800059e6 <spi_setupChipReg+0xa2>

	case 2:
		spi->csr2 = u_avr32_spi_csr.csr;
800059e0:	8b e8       	st.w	r5[0x38],r8
		break;
800059e2:	c0 28       	rjmp	800059e6 <spi_setupChipReg+0xa2>

	case 3:
		spi->csr3 = u_avr32_spi_csr.csr;
800059e4:	8b f8       	st.w	r5[0x3c],r8
	default:
		return SPI_ERROR_ARGUMENT;
	}

#ifdef FREERTOS_USED
	if (!xSPIMutex) {
800059e6:	48 f8       	lddpc	r8,80005a20 <spi_setupChipReg+0xdc>
800059e8:	70 08       	ld.w	r8,r8[0x0]
800059ea:	58 08       	cp.w	r8,0
800059ec:	c1 61       	brne	80005a18 <spi_setupChipReg+0xd4>
		/* Create the SPI mutex. */
		vSemaphoreCreateBinary(xSPIMutex);
800059ee:	30 0b       	mov	r11,0
800059f0:	30 1c       	mov	r12,1
800059f2:	f0 1f 00 0d 	mcall	80005a24 <spi_setupChipReg+0xe0>
800059f6:	48 b8       	lddpc	r8,80005a20 <spi_setupChipReg+0xdc>
800059f8:	91 0c       	st.w	r8[0x0],r12
800059fa:	58 0c       	cp.w	r12,0
800059fc:	c0 a0       	breq	80005a10 <spi_setupChipReg+0xcc>
800059fe:	30 09       	mov	r9,0
80005a00:	12 9a       	mov	r10,r9
80005a02:	12 9b       	mov	r11,r9
80005a04:	f0 1f 00 09 	mcall	80005a28 <spi_setupChipReg+0xe4>
		if (!xSPIMutex) {
80005a08:	48 68       	lddpc	r8,80005a20 <spi_setupChipReg+0xdc>
80005a0a:	70 08       	ld.w	r8,r8[0x0]
80005a0c:	58 08       	cp.w	r8,0
80005a0e:	c0 51       	brne	80005a18 <spi_setupChipReg+0xd4>
80005a10:	c0 08       	rjmp	80005a10 <spi_setupChipReg+0xcc>
80005a12:	30 2c       	mov	r12,2
80005a14:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80005a18:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
80005a1c:	80 00       	ld.sh	r0,r0[0x0]
80005a1e:	58 7c       	cp.w	r12,7
80005a20:	00 00       	add	r0,r0
80005a22:	bf ec       	*unknown*
80005a24:	80 00       	ld.sh	r0,r0[0x0]
80005a26:	65 68       	ld.w	r8,r2[0x58]
80005a28:	80 00       	ld.sh	r0,r0[0x0]
80005a2a:	64 10       	ld.w	r0,r2[0x4]

80005a2c <spi_unselectChip>:

	return SPI_OK;
}

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
80005a2c:	d4 01       	pushm	lr
80005a2e:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
80005a32:	c0 58       	rjmp	80005a3c <spi_unselectChip+0x10>
		if (!timeout--) {
80005a34:	58 08       	cp.w	r8,0
80005a36:	c0 21       	brne	80005a3a <spi_unselectChip+0xe>
80005a38:	da 0a       	popm	pc,r12=1
80005a3a:	20 18       	sub	r8,1

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
80005a3c:	78 49       	ld.w	r9,r12[0x10]
80005a3e:	e2 19 02 00 	andl	r9,0x200,COH
80005a42:	cf 90       	breq	80005a34 <spi_unselectChip+0x8>
			return SPI_ERROR_TIMEOUT;
		}
	}

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
80005a44:	78 18       	ld.w	r8,r12[0x4]
80005a46:	ea 18 00 0f 	orh	r8,0xf
80005a4a:	99 18       	st.w	r12[0x4],r8

	/* Last transfer, so de-assert the current NPCS if CSAAT is set. */
	spi->cr = AVR32_SPI_CR_LASTXFER_MASK;
80005a4c:	fc 18 01 00 	movh	r8,0x100
80005a50:	99 08       	st.w	r12[0x0],r8

#ifdef FREERTOS_USED
	xSemaphoreGive(xSPIMutex);
80005a52:	30 09       	mov	r9,0
80005a54:	12 9a       	mov	r10,r9
80005a56:	12 9b       	mov	r11,r9
80005a58:	48 38       	lddpc	r8,80005a64 <spi_unselectChip+0x38>
80005a5a:	70 0c       	ld.w	r12,r8[0x0]
80005a5c:	f0 1f 00 03 	mcall	80005a68 <spi_unselectChip+0x3c>
80005a60:	d8 0a       	popm	pc,r12=0
80005a62:	00 00       	add	r0,r0
80005a64:	00 00       	add	r0,r0
80005a66:	bf ec       	*unknown*
80005a68:	80 00       	ld.sh	r0,r0[0x0]
80005a6a:	64 10       	ld.w	r0,r2[0x4]

80005a6c <spi_selectChip>:

	return SPI_OK;
}

spi_status_t spi_selectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
80005a6c:	eb cd 40 f8 	pushm	r3-r7,lr
80005a70:	18 94       	mov	r4,r12
80005a72:	16 93       	mov	r3,r11
#ifdef FREERTOS_USED
	while (pdFALSE == xSemaphoreTake(xSPIMutex, 20)) {
80005a74:	49 a6       	lddpc	r6,80005adc <spi_selectChip+0x70>
80005a76:	30 07       	mov	r7,0
80005a78:	31 45       	mov	r5,20
80005a7a:	0e 99       	mov	r9,r7
80005a7c:	0a 9a       	mov	r10,r5
80005a7e:	0e 9b       	mov	r11,r7
80005a80:	6c 0c       	ld.w	r12,r6[0x0]
80005a82:	f0 1f 00 18 	mcall	80005ae0 <spi_selectChip+0x74>
80005a86:	cf a0       	breq	80005a7a <spi_selectChip+0xe>
	}
#endif

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
80005a88:	68 18       	ld.w	r8,r4[0x4]
80005a8a:	ea 18 00 0f 	orh	r8,0xf
80005a8e:	89 18       	st.w	r4[0x4],r8

	if (spi->mr & AVR32_SPI_MR_PCSDEC_MASK) {
80005a90:	68 18       	ld.w	r8,r4[0x4]
80005a92:	e2 18 00 04 	andl	r8,0x4,COH
80005a96:	c1 10       	breq	80005ab8 <spi_selectChip+0x4c>
		/* The signal is decoded; allow up to 15 chips. */
		if (chip > 14) {
80005a98:	30 e8       	mov	r8,14
80005a9a:	f0 03 18 00 	cp.b	r3,r8
80005a9e:	e0 8b 00 1c 	brhi	80005ad6 <spi_selectChip+0x6a>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~AVR32_SPI_MR_PCS_MASK |
80005aa2:	68 19       	ld.w	r9,r4[0x4]
80005aa4:	e6 08 15 10 	lsl	r8,r3,0x10
80005aa8:	ea 18 ff f0 	orh	r8,0xfff0
80005aac:	e8 18 ff ff 	orl	r8,0xffff
80005ab0:	12 68       	and	r8,r9
80005ab2:	89 18       	st.w	r4[0x4],r8
80005ab4:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
				(chip << AVR32_SPI_MR_PCS_OFFSET);
	} else {
		if (chip > 3) {
80005ab8:	30 38       	mov	r8,3
80005aba:	f0 03 18 00 	cp.b	r3,r8
80005abe:	e0 8b 00 0c 	brhi	80005ad6 <spi_selectChip+0x6a>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~(1 << (AVR32_SPI_MR_PCS_OFFSET + chip));
80005ac2:	68 19       	ld.w	r9,r4[0x4]
80005ac4:	2f 03       	sub	r3,-16
80005ac6:	30 18       	mov	r8,1
80005ac8:	f0 03 09 48 	lsl	r8,r8,r3
80005acc:	5c d8       	com	r8
80005ace:	12 68       	and	r8,r9
80005ad0:	89 18       	st.w	r4[0x4],r8
80005ad2:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
80005ad6:	30 2c       	mov	r12,2
	}

	return SPI_OK;
}
80005ad8:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80005adc:	00 00       	add	r0,r0
80005ade:	bf ec       	*unknown*
80005ae0:	80 00       	ld.sh	r0,r0[0x0]
80005ae2:	62 04       	ld.w	r4,r1[0x0]

80005ae4 <usart_set_async_baudrate>:
 *
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
80005ae4:	d4 01       	pushm	lr
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
80005ae6:	f6 08 15 04 	lsl	r8,r11,0x4
80005aea:	14 38       	cp.w	r8,r10
80005aec:	f9 b8 08 10 	movls	r8,16
80005af0:	f9 b8 0b 08 	movhi	r8,8
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
80005af4:	f0 0b 02 4b 	mul	r11,r8,r11
80005af8:	f6 09 16 01 	lsr	r9,r11,0x1
80005afc:	f2 0a 00 3a 	add	r10,r9,r10<<0x3
80005b00:	f4 0b 0d 0a 	divu	r10,r10,r11
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
80005b04:	f4 09 16 03 	lsr	r9,r10,0x3
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
80005b08:	f2 cb 00 01 	sub	r11,r9,1
80005b0c:	e0 4b ff fe 	cp.w	r11,65534
80005b10:	e0 88 00 03 	brls	80005b16 <usart_set_async_baudrate+0x32>
80005b14:	da 0a       	popm	pc,r12=1
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
80005b16:	78 1b       	ld.w	r11,r12[0x4]
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
80005b18:	e8 6e 00 00 	mov	lr,524288
80005b1c:	59 08       	cp.w	r8,16
80005b1e:	fc 08 17 10 	movne	r8,lr
80005b22:	f9 b8 00 00 	moveq	r8,0
80005b26:	e4 1b ff f7 	andh	r11,0xfff7
80005b2a:	e0 1b fe cf 	andl	r11,0xfecf
80005b2e:	16 48       	or	r8,r11
80005b30:	99 18       	st.w	r12[0x4],r8
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
80005b32:	f5 da c0 03 	bfextu	r10,r10,0x0,0x3
80005b36:	f3 ea 11 09 	or	r9,r9,r10<<0x10
80005b3a:	99 89       	st.w	r12[0x20],r9
80005b3c:	d8 0a       	popm	pc,r12=0

80005b3e <usart_write_char>:
 *
 * \return \c 1 if the USART Transmit Holding Register is free, otherwise \c 0.
 */
__always_inline static int usart_tx_ready(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_TXRDY_MASK) != 0;
80005b3e:	78 58       	ld.w	r8,r12[0x14]
}


int usart_write_char(volatile avr32_usart_t *usart, int c)
{
  if (usart_tx_ready(usart))
80005b40:	e2 18 00 02 	andl	r8,0x2,COH
80005b44:	c0 31       	brne	80005b4a <usart_write_char+0xc>
80005b46:	30 2c       	mov	r12,2
80005b48:	5e fc       	retal	r12
  {
    usart->thr = (c << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
80005b4a:	f7 db c0 09 	bfextu	r11,r11,0x0,0x9
80005b4e:	99 7b       	st.w	r12[0x1c],r11
80005b50:	5e fd       	retal	0
80005b52:	d7 03       	nop

80005b54 <usart_putchar>:
    return USART_TX_BUSY;
}


int usart_putchar(volatile avr32_usart_t *usart, int c)
{
80005b54:	eb cd 40 e0 	pushm	r5-r7,lr
80005b58:	18 96       	mov	r6,r12
80005b5a:	16 95       	mov	r5,r11
80005b5c:	e0 67 27 0f 	mov	r7,9999
80005b60:	c0 68       	rjmp	80005b6c <usart_putchar+0x18>
  int timeout = USART_DEFAULT_TIMEOUT;

  do
  {
    if (!timeout--) return USART_FAILURE;
80005b62:	58 07       	cp.w	r7,0
80005b64:	c0 31       	brne	80005b6a <usart_putchar+0x16>
80005b66:	e3 cf c0 e0 	ldm	sp++,r5-r7,pc,r12=-1
80005b6a:	20 17       	sub	r7,1
  } while (usart_write_char(usart, c) != USART_SUCCESS);
80005b6c:	0a 9b       	mov	r11,r5
80005b6e:	0c 9c       	mov	r12,r6
80005b70:	f0 1f 00 03 	mcall	80005b7c <usart_putchar+0x28>
80005b74:	cf 71       	brne	80005b62 <usart_putchar+0xe>

  return USART_SUCCESS;
}
80005b76:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80005b7a:	00 00       	add	r0,r0
80005b7c:	80 00       	ld.sh	r0,r0[0x0]
80005b7e:	5b 3e       	cp.w	lr,-13

80005b80 <usart_read_char>:

int usart_read_char(volatile avr32_usart_t *usart, int *c)
{
  // Check for errors: frame, parity and overrun. In RS485 mode, a parity error
  // would mean that an address char has been received.
  if (usart->csr & (AVR32_USART_CSR_OVRE_MASK |
80005b80:	78 58       	ld.w	r8,r12[0x14]
80005b82:	e2 18 00 e0 	andl	r8,0xe0,COH
80005b86:	c0 30       	breq	80005b8c <usart_read_char+0xc>
80005b88:	30 4c       	mov	r12,4
80005b8a:	5e fc       	retal	r12
 *
 * \return \c 1 if the USART Receive Holding Register is full, otherwise \c 0.
 */
__always_inline static int usart_test_hit(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_RXRDY_MASK) != 0;
80005b8c:	78 58       	ld.w	r8,r12[0x14]
                    AVR32_USART_CSR_FRAME_MASK |
                    AVR32_USART_CSR_PARE_MASK))
    return USART_RX_ERROR;

  // No error; if we really did receive a char, read it and return SUCCESS.
  if (usart_test_hit(usart))
80005b8e:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80005b92:	c0 31       	brne	80005b98 <usart_read_char+0x18>
80005b94:	30 3c       	mov	r12,3
80005b96:	5e fc       	retal	r12
  {
    *c = (usart->rhr & AVR32_USART_RHR_RXCHR_MASK) >> AVR32_USART_RHR_RXCHR_OFFSET;
80005b98:	78 68       	ld.w	r8,r12[0x18]
80005b9a:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
80005b9e:	97 08       	st.w	r11[0x0],r8
80005ba0:	5e fd       	retal	0
80005ba2:	d7 03       	nop

80005ba4 <usart_getchar>:
    return USART_RX_EMPTY;
}


int usart_getchar(volatile avr32_usart_t *usart)
{
80005ba4:	eb cd 40 c0 	pushm	r6-r7,lr
80005ba8:	20 1d       	sub	sp,4
80005baa:	18 96       	mov	r6,r12
  int c, ret;

  while ((ret = usart_read_char(usart, &c)) == USART_RX_EMPTY);
80005bac:	1a 97       	mov	r7,sp
80005bae:	1a 9b       	mov	r11,sp
80005bb0:	0c 9c       	mov	r12,r6
80005bb2:	f0 1f 00 07 	mcall	80005bcc <usart_getchar+0x28>
80005bb6:	58 3c       	cp.w	r12,3
80005bb8:	cf b0       	breq	80005bae <usart_getchar+0xa>

  if (ret == USART_RX_ERROR)
80005bba:	58 4c       	cp.w	r12,4
80005bbc:	f9 bc 00 ff 	moveq	r12,-1
    return USART_FAILURE;

  return c;
80005bc0:	fb fc 10 00 	ld.wne	r12,sp[0x0]
}
80005bc4:	2f fd       	sub	sp,-4
80005bc6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005bca:	00 00       	add	r0,r0
80005bcc:	80 00       	ld.sh	r0,r0[0x0]
80005bce:	5b 80       	cp.w	r0,-8

80005bd0 <usart_write_line>:


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
80005bd0:	eb cd 40 c0 	pushm	r6-r7,lr
80005bd4:	18 96       	mov	r6,r12
80005bd6:	16 97       	mov	r7,r11
  while (*string != '\0')
80005bd8:	17 8b       	ld.ub	r11,r11[0x0]
80005bda:	58 0b       	cp.w	r11,0
80005bdc:	c0 80       	breq	80005bec <usart_write_line+0x1c>
    usart_putchar(usart, *string++);
80005bde:	2f f7       	sub	r7,-1
80005be0:	0c 9c       	mov	r12,r6
80005be2:	f0 1f 00 04 	mcall	80005bf0 <usart_write_line+0x20>
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
80005be6:	0f 8b       	ld.ub	r11,r7[0x0]
80005be8:	58 0b       	cp.w	r11,0
80005bea:	cf a1       	brne	80005bde <usart_write_line+0xe>
80005bec:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005bf0:	80 00       	ld.sh	r0,r0[0x0]
80005bf2:	5b 54       	cp.w	r4,-11

80005bf4 <usart_reset>:
//! @{


void usart_reset(volatile avr32_usart_t *usart)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
80005bf4:	e1 b8 00 00 	mfsr	r8,0x0

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
80005bf8:	e6 18 00 01 	andh	r8,0x1,COH
80005bfc:	c0 71       	brne	80005c0a <usart_reset+0x16>
80005bfe:	d3 03       	ssrf	0x10
  usart->idr = 0xFFFFFFFF;
80005c00:	3f f8       	mov	r8,-1
80005c02:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80005c04:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();
80005c06:	d5 03       	csrf	0x10
80005c08:	c0 48       	rjmp	80005c10 <usart_reset+0x1c>
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
  usart->idr = 0xFFFFFFFF;
80005c0a:	3f f8       	mov	r8,-1
80005c0c:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80005c0e:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();

  // Reset mode and other registers that could cause unpredictable behavior after reset.
  usart->mr = 0;
80005c10:	30 08       	mov	r8,0
80005c12:	99 18       	st.w	r12[0x4],r8
  usart->rtor = 0;
80005c14:	99 98       	st.w	r12[0x24],r8
  usart->ttgr = 0;
80005c16:	99 a8       	st.w	r12[0x28],r8

  // Shutdown TX and RX (will be re-enabled when setup has successfully completed),
  // reset status bits and turn off DTR and RTS.
  usart->cr = AVR32_USART_CR_RSTRX_MASK   |
80005c18:	ea 68 61 0c 	mov	r8,680204
80005c1c:	99 08       	st.w	r12[0x0],r8
#ifndef AVR32_USART_440_H_INCLUDED
// Note: Modem Signal Management DTR-DSR-DCD-RI are not included in USART rev.440.
              AVR32_USART_CR_DTRDIS_MASK  |
#endif
              AVR32_USART_CR_RTSDIS_MASK;
}
80005c1e:	5e fc       	retal	r12

80005c20 <usart_init_rs232>:


int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
{
80005c20:	eb cd 40 e0 	pushm	r5-r7,lr
80005c24:	18 96       	mov	r6,r12
80005c26:	16 97       	mov	r7,r11
80005c28:	14 95       	mov	r5,r10
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);
80005c2a:	f0 1f 00 2f 	mcall	80005ce4 <usart_init_rs232+0xc4>

  // Check input values.
  if (!opt || // Null pointer.
80005c2e:	58 07       	cp.w	r7,0
80005c30:	c5 80       	breq	80005ce0 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
80005c32:	0f c8       	ld.ub	r8,r7[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80005c34:	30 49       	mov	r9,4
80005c36:	f2 08 18 00 	cp.b	r8,r9
80005c3a:	e0 88 00 53 	brls	80005ce0 <usart_init_rs232+0xc0>
80005c3e:	30 99       	mov	r9,9
80005c40:	f2 08 18 00 	cp.b	r8,r9
80005c44:	e0 8b 00 4e 	brhi	80005ce0 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
80005c48:	0f d9       	ld.ub	r9,r7[0x5]
80005c4a:	30 78       	mov	r8,7
80005c4c:	f0 09 18 00 	cp.b	r9,r8
80005c50:	e0 8b 00 48 	brhi	80005ce0 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
80005c54:	8e 39       	ld.sh	r9,r7[0x6]
80005c56:	e0 68 01 01 	mov	r8,257
80005c5a:	f0 09 19 00 	cp.h	r9,r8
80005c5e:	e0 8b 00 41 	brhi	80005ce0 <usart_init_rs232+0xc0>
      opt->channelmode > 3 ||
80005c62:	ef 39 00 08 	ld.ub	r9,r7[8]
80005c66:	30 38       	mov	r8,3
80005c68:	f0 09 18 00 	cp.b	r9,r8
80005c6c:	e0 8b 00 3a 	brhi	80005ce0 <usart_init_rs232+0xc0>
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
80005c70:	0a 9a       	mov	r10,r5
80005c72:	6e 0b       	ld.w	r11,r7[0x0]
80005c74:	0c 9c       	mov	r12,r6
80005c76:	f0 1f 00 1d 	mcall	80005ce8 <usart_init_rs232+0xc8>
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80005c7a:	58 1c       	cp.w	r12,1
80005c7c:	c3 20       	breq	80005ce0 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
    return USART_INVALID_INPUT;

  if (opt->charlength == 9)
80005c7e:	0f c8       	ld.ub	r8,r7[0x4]
80005c80:	30 99       	mov	r9,9
80005c82:	f2 08 18 00 	cp.b	r8,r9
80005c86:	c0 51       	brne	80005c90 <usart_init_rs232+0x70>
  {
    // Character length set to 9 bits. MODE9 dominates CHRL.
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
80005c88:	6c 18       	ld.w	r8,r6[0x4]
80005c8a:	b1 b8       	sbr	r8,0x11
80005c8c:	8d 18       	st.w	r6[0x4],r8
80005c8e:	c0 68       	rjmp	80005c9a <usart_init_rs232+0x7a>
  }
  else
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
80005c90:	6c 19       	ld.w	r9,r6[0x4]
80005c92:	20 58       	sub	r8,5
80005c94:	f3 e8 10 68 	or	r8,r9,r8<<0x6
80005c98:	8d 18       	st.w	r6[0x4],r8
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
80005c9a:	6c 19       	ld.w	r9,r6[0x4]
80005c9c:	ef 3a 00 08 	ld.ub	r10,r7[8]
80005ca0:	0f d8       	ld.ub	r8,r7[0x5]
80005ca2:	a9 78       	lsl	r8,0x9
80005ca4:	f1 ea 10 e8 	or	r8,r8,r10<<0xe
80005ca8:	12 48       	or	r8,r9
80005caa:	8d 18       	st.w	r6[0x4],r8
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;

  if (opt->stopbits > USART_2_STOPBITS)
80005cac:	8e 38       	ld.sh	r8,r7[0x6]
80005cae:	30 29       	mov	r9,2
80005cb0:	f2 08 19 00 	cp.h	r8,r9
80005cb4:	e0 88 00 09 	brls	80005cc6 <usart_init_rs232+0xa6>
  {
    // Set two stop bits
    usart->mr |= AVR32_USART_MR_NBSTOP_2 << AVR32_USART_MR_NBSTOP_OFFSET;
80005cb8:	6c 18       	ld.w	r8,r6[0x4]
80005cba:	ad b8       	sbr	r8,0xd
80005cbc:	8d 18       	st.w	r6[0x4],r8
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
80005cbe:	8e b8       	ld.uh	r8,r7[0x6]
80005cc0:	20 28       	sub	r8,2
80005cc2:	8d a8       	st.w	r6[0x28],r8
80005cc4:	c0 68       	rjmp	80005cd0 <usart_init_rs232+0xb0>
  }
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;
80005cc6:	6c 19       	ld.w	r9,r6[0x4]
80005cc8:	5c 78       	castu.h	r8
80005cca:	f3 e8 10 c8 	or	r8,r9,r8<<0xc
80005cce:	8d 18       	st.w	r6[0x4],r8

  // Set normal mode.
  usart->mr = (usart->mr & ~AVR32_USART_MR_MODE_MASK) |
80005cd0:	6c 18       	ld.w	r8,r6[0x4]
80005cd2:	e0 18 ff f0 	andl	r8,0xfff0
80005cd6:	8d 18       	st.w	r6[0x4],r8
              AVR32_USART_MR_MODE_NORMAL << AVR32_USART_MR_MODE_OFFSET;

  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
80005cd8:	35 08       	mov	r8,80
80005cda:	8d 08       	st.w	r6[0x0],r8
80005cdc:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
80005ce0:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
80005ce4:	80 00       	ld.sh	r0,r0[0x0]
80005ce6:	5b f4       	cp.w	r4,-1
80005ce8:	80 00       	ld.sh	r0,r0[0x0]
80005cea:	5a e4       	cp.w	r4,-18

80005cec <_stext>:

  .global _stext
  .type _stext, @function
_stext:
  // Set initial stack pointer.
  lda.w   sp, _estack
80005cec:	e0 7d 80 00 	mov	sp,98304

  // Set up EVBA so interrupts can be enabled.
  lda.w   r0, _evba
  mtsr    AVR32_EVBA, r0
80005cf0:	fe c0 8e f0 	sub	r0,pc,-28944

  // Enable the exception processing.
  csrf    AVR32_SR_EM_OFFSET
80005cf4:	e3 b0 00 01 	mtsr	0x4,r0

  // Load initialized data having a global lifetime from the data LMA.
  lda.w   r0, _data
  lda.w   r1, _edata
80005cf8:	d5 53       	csrf	0x15
  cp      r0, r1
80005cfa:	30 40       	mov	r0,4
  brhs    idata_load_loop_end
80005cfc:	e0 61 0a 40 	mov	r1,2624
  lda.w   r2, _data_lma
idata_load_loop:
  ld.d    r4, r2++
80005d00:	02 30       	cp.w	r0,r1
  st.d    r0++, r4
80005d02:	c0 62       	brcc	80005d0e <idata_load_loop_end>
  cp      r0, r1
80005d04:	48 92       	lddpc	r2,80005d28 <udata_clear_loop_end+0x4>

80005d06 <idata_load_loop>:
  brlo    idata_load_loop
80005d06:	a5 05       	ld.d	r4,r2++
idata_load_loop_end:

  // Clear uninitialized data having a global lifetime in the blank static storage section.
  lda.w   r0, __bss_start
80005d08:	a1 24       	st.d	r0++,r4
  lda.w   r1, _end
80005d0a:	02 30       	cp.w	r0,r1
  cp      r0, r1
80005d0c:	cf d3       	brcs	80005d06 <idata_load_loop>

80005d0e <idata_load_loop_end>:
  brhs    udata_clear_loop_end
80005d0e:	e0 60 0a 40 	mov	r0,2624
  mov     r2, 0
  mov     r3, 0
80005d12:	e0 61 c0 00 	mov	r1,49152
udata_clear_loop:
  st.d    r0++, r2
  cp      r0, r1
80005d16:	02 30       	cp.w	r0,r1
  brlo    udata_clear_loop
80005d18:	c0 62       	brcc	80005d24 <udata_clear_loop_end>
  // Safety: Set the default "return" @ to the exit routine address.
  lda.w   lr, exit
#endif

  // Start the show.
  lda.w   pc, main
80005d1a:	30 02       	mov	r2,0
80005d1c:	30 03       	mov	r3,0

80005d1e <udata_clear_loop>:
80005d1e:	a1 22       	st.d	r0++,r2
80005d20:	02 30       	cp.w	r0,r1
80005d22:	cf e3       	brcs	80005d1e <udata_clear_loop>

80005d24 <udata_clear_loop_end>:
80005d24:	fe cf e9 28 	sub	pc,pc,-5848
80005d28:	80 00       	ld.sh	r0,r0[0x0]
80005d2a:	e2 c8 f8 c8 	sub	r8,r1,-1848

80005d2c <vListInitialise>:
void vListInitialise( xList *pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
80005d2c:	f8 c8 ff f8 	sub	r8,r12,-8
80005d30:	99 18       	st.w	r12[0x4],r8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
80005d32:	3f f9       	mov	r9,-1
80005d34:	99 29       	st.w	r12[0x8],r9

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
80005d36:	99 38       	st.w	r12[0xc],r8
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
80005d38:	99 48       	st.w	r12[0x10],r8

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
80005d3a:	30 08       	mov	r8,0
80005d3c:	99 08       	st.w	r12[0x0],r8
}
80005d3e:	5e fc       	retal	r12

80005d40 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
80005d40:	30 08       	mov	r8,0
80005d42:	99 48       	st.w	r12[0x10],r8
}
80005d44:	5e fc       	retal	r12

80005d46 <vListInsertEnd>:

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
80005d46:	78 18       	ld.w	r8,r12[0x4]

	pxNewListItem->pxNext = pxIndex->pxNext;
80005d48:	70 19       	ld.w	r9,r8[0x4]
80005d4a:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxPrevious = pxList->pxIndex;
80005d4c:	78 19       	ld.w	r9,r12[0x4]
80005d4e:	97 29       	st.w	r11[0x8],r9
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80005d50:	70 19       	ld.w	r9,r8[0x4]
80005d52:	93 2b       	st.w	r9[0x8],r11
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
80005d54:	91 1b       	st.w	r8[0x4],r11
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
80005d56:	99 1b       	st.w	r12[0x4],r11

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80005d58:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80005d5a:	78 08       	ld.w	r8,r12[0x0]
80005d5c:	2f f8       	sub	r8,-1
80005d5e:	99 08       	st.w	r12[0x0],r8
}
80005d60:	5e fc       	retal	r12

80005d62 <vListInsert>:
{
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
80005d62:	76 0a       	ld.w	r10,r11[0x0]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
80005d64:	5b fa       	cp.w	r10,-1
80005d66:	c0 31       	brne	80005d6c <vListInsert+0xa>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
80005d68:	78 48       	ld.w	r8,r12[0x10]
80005d6a:	c0 c8       	rjmp	80005d82 <vListInsert+0x20>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
80005d6c:	f8 c8 ff f8 	sub	r8,r12,-8
80005d70:	70 19       	ld.w	r9,r8[0x4]
80005d72:	72 09       	ld.w	r9,r9[0x0]
80005d74:	12 3a       	cp.w	r10,r9
80005d76:	c0 63       	brcs	80005d82 <vListInsert+0x20>
80005d78:	70 18       	ld.w	r8,r8[0x4]
80005d7a:	70 19       	ld.w	r9,r8[0x4]
80005d7c:	72 09       	ld.w	r9,r9[0x0]
80005d7e:	12 3a       	cp.w	r10,r9
80005d80:	cf c2       	brcc	80005d78 <vListInsert+0x16>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
80005d82:	70 19       	ld.w	r9,r8[0x4]
80005d84:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80005d86:	93 2b       	st.w	r9[0x8],r11
	pxNewListItem->pxPrevious = pxIterator;
80005d88:	97 28       	st.w	r11[0x8],r8
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
80005d8a:	91 1b       	st.w	r8[0x4],r11

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80005d8c:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80005d8e:	78 08       	ld.w	r8,r12[0x0]
80005d90:	2f f8       	sub	r8,-1
80005d92:	99 08       	st.w	r12[0x0],r8
}
80005d94:	5e fc       	retal	r12

80005d96 <vListRemove>:

void vListRemove( xListItem *pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
80005d96:	78 18       	ld.w	r8,r12[0x4]
80005d98:	78 29       	ld.w	r9,r12[0x8]
80005d9a:	91 29       	st.w	r8[0x8],r9
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
80005d9c:	78 28       	ld.w	r8,r12[0x8]
80005d9e:	78 19       	ld.w	r9,r12[0x4]
80005da0:	91 19       	st.w	r8[0x4],r9

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
80005da2:	78 48       	ld.w	r8,r12[0x10]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
80005da4:	70 19       	ld.w	r9,r8[0x4]
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
80005da6:	18 39       	cp.w	r9,r12
80005da8:	f9 f9 00 02 	ld.weq	r9,r12[0x8]
80005dac:	f1 f9 0a 01 	st.weq	r8[0x4],r9
	}

	pxItemToRemove->pvContainer = NULL;
80005db0:	30 09       	mov	r9,0
80005db2:	99 49       	st.w	r12[0x10],r9
	( pxList->uxNumberOfItems )--;
80005db4:	70 09       	ld.w	r9,r8[0x0]
80005db6:	20 19       	sub	r9,1
80005db8:	91 09       	st.w	r8[0x0],r9
}
80005dba:	5e fc       	retal	r12

80005dbc <pxPortInitialiseStack>:
	/* Setup the initial stack of the task.  The stack is set exactly as
	expected by the portRESTORE_CONTEXT() macro. */

	/* When the task starts, it will expect to find the function parameter in R12. */
	pxTopOfStack--;
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x08080808;					/* R8 */
80005dbc:	e0 68 08 08 	mov	r8,2056
80005dc0:	ea 18 08 08 	orh	r8,0x808
80005dc4:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x09090909;					/* R9 */
80005dc6:	e0 68 09 09 	mov	r8,2313
80005dca:	ea 18 09 09 	orh	r8,0x909
80005dce:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0A0A0A0A;					/* R10 */
80005dd0:	e0 68 0a 0a 	mov	r8,2570
80005dd4:	ea 18 0a 0a 	orh	r8,0xa0a
80005dd8:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0B0B0B0B;					/* R11 */
80005dda:	e0 68 0b 0b 	mov	r8,2827
80005dde:	ea 18 0b 0b 	orh	r8,0xb0b
80005de2:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pvParameters;					/* R12 */
80005de4:	18 da       	st.w	--r12,r10
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xDEADBEEF;					/* R14/LR */
80005de6:	e0 68 be ef 	mov	r8,48879
80005dea:	ea 18 de ad 	orh	r8,0xdead
80005dee:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pxCode + portINSTRUCTION_SIZE; /* R15/PC */
80005df0:	18 db       	st.w	--r12,r11
	*pxTopOfStack-- = ( portSTACK_TYPE ) portINITIAL_SR;				/* SR */
80005df2:	fc 18 00 40 	movh	r8,0x40
80005df6:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xFF0000FF;					/* R0 */
80005df8:	e0 68 00 ff 	mov	r8,255
80005dfc:	ea 18 ff 00 	orh	r8,0xff00
80005e00:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x01010101;					/* R1 */
80005e02:	e0 68 01 01 	mov	r8,257
80005e06:	ea 18 01 01 	orh	r8,0x101
80005e0a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x02020202;					/* R2 */
80005e0c:	e0 68 02 02 	mov	r8,514
80005e10:	ea 18 02 02 	orh	r8,0x202
80005e14:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x03030303;					/* R3 */
80005e16:	e0 68 03 03 	mov	r8,771
80005e1a:	ea 18 03 03 	orh	r8,0x303
80005e1e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x04040404;					/* R4 */
80005e20:	e0 68 04 04 	mov	r8,1028
80005e24:	ea 18 04 04 	orh	r8,0x404
80005e28:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x05050505;					/* R5 */
80005e2a:	e0 68 05 05 	mov	r8,1285
80005e2e:	ea 18 05 05 	orh	r8,0x505
80005e32:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x06060606;					/* R6 */
80005e34:	e0 68 06 06 	mov	r8,1542
80005e38:	ea 18 06 06 	orh	r8,0x606
80005e3c:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x07070707;					/* R7 */
80005e3e:	e0 68 07 07 	mov	r8,1799
80005e42:	ea 18 07 07 	orh	r8,0x707
80005e46:	18 d8       	st.w	--r12,r8
	*pxTopOfStack = ( portSTACK_TYPE ) portNO_CRITICAL_NESTING;			/* ulCriticalNesting */
80005e48:	30 08       	mov	r8,0
80005e4a:	18 d8       	st.w	--r12,r8

	return pxTopOfStack;
}
80005e4c:	5e fc       	retal	r12
80005e4e:	d7 03       	nop

80005e50 <vPortEnterCritical>:
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
__attribute__((__noinline__)) void vPortEnterCritical( void )
{
	/* Disable interrupts */
	portDISABLE_INTERRUPTS();
80005e50:	d3 03       	ssrf	0x10

	/* Now interrupts are disabled ulCriticalNesting can be accessed
	 directly.  Increment ulCriticalNesting to keep a count of how many times
	 portENTER_CRITICAL() has been called. */
	ulCriticalNesting++;
80005e52:	48 38       	lddpc	r8,80005e5c <vPortEnterCritical+0xc>
80005e54:	70 09       	ld.w	r9,r8[0x0]
80005e56:	2f f9       	sub	r9,-1
80005e58:	91 09       	st.w	r8[0x0],r9
}
80005e5a:	5e fc       	retal	r12
80005e5c:	00 00       	add	r0,r0
80005e5e:	05 34       	ld.ub	r4,r2++

80005e60 <xPortStartScheduler>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
80005e60:	d4 01       	pushm	lr
	};

#endif

	/* Disable all interrupt/exception. */
	portDISABLE_INTERRUPTS();
80005e62:	d3 03       	ssrf	0x10
		/* Start the timer/counter. */
		tc_start(tc, configTICK_TC_CHANNEL);
	}
	#else
	{
		INTC_register_interrupt(&vTick, AVR32_CORE_COMPARE_IRQ, AVR32_INTC_INT0);
80005e64:	30 0a       	mov	r10,0
80005e66:	14 9b       	mov	r11,r10
80005e68:	49 2c       	lddpc	r12,80005eb0 <xPortStartScheduler+0x50>
80005e6a:	f0 1f 00 13 	mcall	80005eb4 <xPortStartScheduler+0x54>
/* Schedule the COUNT&COMPARE match interrupt in (configCPU_CLOCK_HZ/configTICK_RATE_HZ)
clock cycles from now. */
#if( configTICK_USE_TC==0 )
	static void prvScheduleFirstTick(void)
	{
		Set_system_register(AVR32_COMPARE, configCPU_CLOCK_HZ/configTICK_RATE_HZ);//cause!!!
80005e6e:	e0 68 5d c0 	mov	r8,24000
80005e72:	e3 b8 00 43 	mtsr	0x10c,r8
		Set_system_register(AVR32_COUNT, 0);
80005e76:	30 08       	mov	r8,0
80005e78:	e3 b8 00 42 	mtsr	0x108,r8
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();

	/* Start the first task. */
	portRESTORE_CONTEXT();
80005e7c:	e0 68 0c f4 	mov	r8,3316
80005e80:	ea 18 00 00 	orh	r8,0x0
80005e84:	70 00       	ld.w	r0,r8[0x0]
80005e86:	60 0d       	ld.w	sp,r0[0x0]
80005e88:	1b 00       	ld.w	r0,sp++
80005e8a:	e0 68 05 34 	mov	r8,1332
80005e8e:	ea 18 00 00 	orh	r8,0x0
80005e92:	91 00       	st.w	r8[0x0],r0
80005e94:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005e98:	2f ed       	sub	sp,-8
80005e9a:	e3 cd 5f 00 	ldm	sp++,r8-r12,lr
80005e9e:	fa f0 ff e0 	ld.w	r0,sp[-32]
80005ea2:	e3 b0 00 00 	mtsr	0x0,r0
80005ea6:	fa f0 ff dc 	ld.w	r0,sp[-36]
80005eaa:	fa ff ff e4 	ld.w	pc,sp[-28]

	/* Should not get here! */
	return 0;
}
80005eae:	d8 0a       	popm	pc,r12=0
80005eb0:	80 00       	ld.sh	r0,r0[0x0]
80005eb2:	5f 7c       	srpl	r12
80005eb4:	80 00       	ld.sh	r0,r0[0x0]
80005eb6:	56 20       	stdsp	sp[0x188],r0

80005eb8 <SCALLYield>:
/*-----------------------------------------------------------*/
__attribute__((__naked__)) void SCALLYield( void );
__attribute__((__naked__)) void SCALLYield( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_SCALL();
80005eb8:	20 6d       	sub	sp,24
80005eba:	eb cd 00 ff 	pushm	r0-r7
80005ebe:	fa c7 ff c0 	sub	r7,sp,-64
80005ec2:	ee f0 ff f8 	ld.w	r0,r7[-8]
80005ec6:	ef 40 ff e0 	st.w	r7[-32],r0
80005eca:	ee f0 ff fc 	ld.w	r0,r7[-4]
80005ece:	ef 40 ff e4 	st.w	r7[-28],r0
80005ed2:	eb c7 5f 00 	stm	--r7,r8-r12,lr
80005ed6:	e0 68 05 34 	mov	r8,1332
80005eda:	ea 18 00 00 	orh	r8,0x0
80005ede:	70 00       	ld.w	r0,r8[0x0]
80005ee0:	1a d0       	st.w	--sp,r0
80005ee2:	f0 1f 00 1a 	mcall	80005f48 <LABEL_RET_SCALL_263+0x14>
80005ee6:	e0 68 0c f4 	mov	r8,3316
80005eea:	ea 18 00 00 	orh	r8,0x0
80005eee:	70 00       	ld.w	r0,r8[0x0]
80005ef0:	81 0d       	st.w	r0[0x0],sp
	vTaskSwitchContext();
80005ef2:	f0 1f 00 17 	mcall	80005f4c <LABEL_RET_SCALL_263+0x18>
	portRESTORE_CONTEXT_SCALL();
80005ef6:	e0 68 0c f4 	mov	r8,3316
80005efa:	ea 18 00 00 	orh	r8,0x0
80005efe:	70 00       	ld.w	r0,r8[0x0]
80005f00:	60 0d       	ld.w	sp,r0[0x0]
80005f02:	1b 00       	ld.w	r0,sp++
80005f04:	e0 68 05 34 	mov	r8,1332
80005f08:	ea 18 00 00 	orh	r8,0x0
80005f0c:	91 00       	st.w	r8[0x0],r0
80005f0e:	fa c7 ff d8 	sub	r7,sp,-40
80005f12:	e3 c7 5f 00 	ldm	r7++,r8-r12,lr
80005f16:	ee f0 ff e0 	ld.w	r0,r7[-32]
80005f1a:	e0 61 05 34 	mov	r1,1332
80005f1e:	ea 11 00 00 	orh	r1,0x0
80005f22:	62 02       	ld.w	r2,r1[0x0]
80005f24:	58 02       	cp.w	r2,0
80005f26:	c0 70       	breq	80005f34 <LABEL_RET_SCALL_263>
80005f28:	e4 c2 00 01 	sub	r2,r2,1
80005f2c:	83 02       	st.w	r1[0x0],r2
80005f2e:	58 02       	cp.w	r2,0
80005f30:	c0 21       	brne	80005f34 <LABEL_RET_SCALL_263>
80005f32:	b1 c0       	cbr	r0,0x10

80005f34 <LABEL_RET_SCALL_263>:
80005f34:	ef 40 ff f8 	st.w	r7[-8],r0
80005f38:	ee f0 ff e4 	ld.w	r0,r7[-28]
80005f3c:	ef 40 ff fc 	st.w	r7[-4],r0
80005f40:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005f44:	2f ad       	sub	sp,-24
80005f46:	d6 13       	rets
80005f48:	80 00       	ld.sh	r0,r0[0x0]
80005f4a:	5e 50       	retlt	r0
80005f4c:	80 00       	ld.sh	r0,r0[0x0]
80005f4e:	65 ec       	ld.w	r12,r2[0x78]

80005f50 <prvClearCcInt>:
		Set_system_register(AVR32_COUNT, 0);
	}

	__attribute__((__noinline__)) static void prvClearCcInt(void)
	{
		Set_system_register(AVR32_COMPARE, Get_system_register(AVR32_COMPARE));
80005f50:	e1 b8 00 43 	mfsr	r8,0x10c
80005f54:	e3 b8 00 43 	mtsr	0x10c,r8
	}
80005f58:	5e fc       	retal	r12
80005f5a:	d7 03       	nop

80005f5c <vPortExitCritical>:
}
/*-----------------------------------------------------------*/

__attribute__((__noinline__)) void vPortExitCritical( void )
{
	if(ulCriticalNesting > portNO_CRITICAL_NESTING)
80005f5c:	48 78       	lddpc	r8,80005f78 <vPortExitCritical+0x1c>
80005f5e:	70 08       	ld.w	r8,r8[0x0]
80005f60:	58 08       	cp.w	r8,0
80005f62:	5e 0c       	reteq	r12
	{
		ulCriticalNesting--;
80005f64:	48 58       	lddpc	r8,80005f78 <vPortExitCritical+0x1c>
80005f66:	70 09       	ld.w	r9,r8[0x0]
80005f68:	20 19       	sub	r9,1
80005f6a:	91 09       	st.w	r8[0x0],r9
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
80005f6c:	70 08       	ld.w	r8,r8[0x0]
80005f6e:	58 08       	cp.w	r8,0
80005f70:	5e 1c       	retne	r12
		{
			/* Enable all interrupt/exception. */
			portENABLE_INTERRUPTS();
80005f72:	d5 03       	csrf	0x10
80005f74:	5e fc       	retal	r12
80005f76:	00 00       	add	r0,r0
80005f78:	00 00       	add	r0,r0
80005f7a:	05 34       	ld.ub	r4,r2++

80005f7c <vTick>:
/* The preemptive scheduler is defined as "naked" as the full context is saved
on entry as part of the context switch. */
__attribute__((__naked__)) static void vTick( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_OS_INT();
80005f7c:	eb cd 00 ff 	pushm	r0-r7
80005f80:	e0 68 05 34 	mov	r8,1332
80005f84:	ea 18 00 00 	orh	r8,0x0
80005f88:	70 00       	ld.w	r0,r8[0x0]
80005f8a:	1a d0       	st.w	--sp,r0
80005f8c:	7a 90       	ld.w	r0,sp[0x24]
80005f8e:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80005f92:	58 10       	cp.w	r0,1
80005f94:	e0 8b 00 08 	brhi	80005fa4 <LABEL_INT_SKIP_SAVE_CONTEXT_237>
80005f98:	e0 68 0c f4 	mov	r8,3316
80005f9c:	ea 18 00 00 	orh	r8,0x0
80005fa0:	70 00       	ld.w	r0,r8[0x0]
80005fa2:	81 0d       	st.w	r0[0x0],sp

80005fa4 <LABEL_INT_SKIP_SAVE_CONTEXT_237>:
	#if( configTICK_USE_TC==1 )
		/* Clear the interrupt flag. */
		prvClearTcInt();
	#else
		/* Clear the interrupt flag. */
		prvClearCcInt();
80005fa4:	f0 1f 00 12 	mcall	80005fec <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x14>
	#endif

	/* Because FreeRTOS is not supposed to run with nested interrupts, put all OS
	calls in a critical section . */
	portENTER_CRITICAL();
80005fa8:	f0 1f 00 12 	mcall	80005ff0 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
		vTaskIncrementTick();
80005fac:	f0 1f 00 12 	mcall	80005ff4 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x1c>
	portEXIT_CRITICAL();
80005fb0:	f0 1f 00 12 	mcall	80005ff8 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>

	/* Restore the context of the "elected task". */
	portRESTORE_CONTEXT_OS_INT();
80005fb4:	7a 90       	ld.w	r0,sp[0x24]
80005fb6:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80005fba:	58 10       	cp.w	r0,1
80005fbc:	e0 8b 00 0e 	brhi	80005fd8 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>
80005fc0:	f0 1f 00 0c 	mcall	80005ff0 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
80005fc4:	f0 1f 00 0e 	mcall	80005ffc <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x24>
80005fc8:	f0 1f 00 0c 	mcall	80005ff8 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>
80005fcc:	e0 68 0c f4 	mov	r8,3316
80005fd0:	ea 18 00 00 	orh	r8,0x0
80005fd4:	70 00       	ld.w	r0,r8[0x0]
80005fd6:	60 0d       	ld.w	sp,r0[0x0]

80005fd8 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>:
80005fd8:	1b 00       	ld.w	r0,sp++
80005fda:	e0 68 05 34 	mov	r8,1332
80005fde:	ea 18 00 00 	orh	r8,0x0
80005fe2:	91 00       	st.w	r8[0x0],r0
80005fe4:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005fe8:	d6 03       	rete
80005fea:	00 00       	add	r0,r0
80005fec:	80 00       	ld.sh	r0,r0[0x0]
80005fee:	5f 50       	srlt	r0
80005ff0:	80 00       	ld.sh	r0,r0[0x0]
80005ff2:	5e 50       	retlt	r0
80005ff4:	80 00       	ld.sh	r0,r0[0x0]
80005ff6:	67 f0       	ld.w	r0,r3[0x7c]
80005ff8:	80 00       	ld.sh	r0,r0[0x0]
80005ffa:	5f 5c       	srlt	r12
80005ffc:	80 00       	ld.sh	r0,r0[0x0]
80005ffe:	65 ec       	ld.w	r12,r2[0x78]

80006000 <__malloc_lock>:
 * safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_lock(struct _reent *ptr);
void __malloc_lock(struct _reent *ptr)
{
80006000:	d4 01       	pushm	lr
	vTaskSuspendAll();
80006002:	f0 1f 00 02 	mcall	80006008 <__malloc_lock+0x8>
}
80006006:	d8 02       	popm	pc
80006008:	80 00       	ld.sh	r0,r0[0x0]
8000600a:	65 dc       	ld.w	r12,r2[0x74]

8000600c <__malloc_unlock>:
 * a safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_unlock(struct _reent *ptr);
void __malloc_unlock(struct _reent *ptr)
{
8000600c:	d4 01       	pushm	lr
	xTaskResumeAll();
8000600e:	f0 1f 00 02 	mcall	80006014 <__malloc_unlock+0x8>
}
80006012:	d8 02       	popm	pc
80006014:	80 00       	ld.sh	r0,r0[0x0]
80006016:	69 98       	ld.w	r8,r4[0x64]

80006018 <_read>:
/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
{
80006018:	d4 21       	pushm	r4-r7,lr
8000601a:	16 95       	mov	r5,r11
8000601c:	14 96       	mov	r6,r10
  int nChars = 0;

  if (file != 0)
8000601e:	58 0c       	cp.w	r12,0
80006020:	c0 30       	breq	80006026 <_read+0xe>
80006022:	3f f7       	mov	r7,-1
80006024:	c1 48       	rjmp	8000604c <_read+0x34>
    return -1;

  for (; len > 0; --len)
80006026:	58 0a       	cp.w	r10,0
80006028:	e0 89 00 04 	brgt	80006030 <_read+0x18>
8000602c:	30 07       	mov	r7,0
8000602e:	c0 f8       	rjmp	8000604c <_read+0x34>
80006030:	30 07       	mov	r7,0
  {
    int c = usart_getchar(stdio_usart_base);
80006032:	48 84       	lddpc	r4,80006050 <_read+0x38>
80006034:	68 0c       	ld.w	r12,r4[0x0]
80006036:	f0 1f 00 08 	mcall	80006054 <_read+0x3c>
    if (c < 0)
8000603a:	c0 95       	brlt	8000604c <_read+0x34>
      break;

    *ptr++ = c;
8000603c:	ea 07 0b 0c 	st.b	r5[r7],r12
    ++nChars;
80006040:	2f f7       	sub	r7,-1

/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
80006042:	ec 07 01 08 	sub	r8,r6,r7
  int nChars = 0;

  if (file != 0)
    return -1;

  for (; len > 0; --len)
80006046:	58 08       	cp.w	r8,0
80006048:	fe 99 ff f6 	brgt	80006034 <_read+0x1c>
    *ptr++ = c;
    ++nChars;
  }

  return nChars;
}
8000604c:	0e 9c       	mov	r12,r7
8000604e:	d8 22       	popm	r4-r7,pc
80006050:	00 00       	add	r0,r0
80006052:	bf f0       	*unknown*
80006054:	80 00       	ld.sh	r0,r0[0x0]
80006056:	5b a4       	cp.w	r4,-6

80006058 <_write>:
 * 1 and 2 is stdout and stderr which goes to usart
 * 3 is framebuffer
 */
int __attribute__((weak))
_write (int file, char * ptr, int len)
{
80006058:	d4 21       	pushm	r4-r7,lr
8000605a:	16 95       	mov	r5,r11
8000605c:	14 96       	mov	r6,r10
  int nChars = 0;

  if ( (file != 1)
8000605e:	20 1c       	sub	r12,1
80006060:	58 2c       	cp.w	r12,2
80006062:	e0 8b 00 12 	brhi	80006086 <_write+0x2e>
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80006066:	58 0a       	cp.w	r10,0
80006068:	c0 31       	brne	8000606e <_write+0x16>
8000606a:	30 07       	mov	r7,0
8000606c:	c0 e8       	rjmp	80006088 <_write+0x30>
8000606e:	30 07       	mov	r7,0
  {
    if (usart_putchar(stdio_usart_base, *ptr++) < 0)
80006070:	48 74       	lddpc	r4,8000608c <_write+0x34>
80006072:	68 0c       	ld.w	r12,r4[0x0]
80006074:	ea 07 07 0b 	ld.ub	r11,r5[r7]
80006078:	f0 1f 00 06 	mcall	80006090 <_write+0x38>
8000607c:	c0 55       	brlt	80006086 <_write+0x2e>
    {
      return -1;
    }

    ++nChars;
8000607e:	2f f7       	sub	r7,-1

  if ( (file != 1)
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80006080:	0e 36       	cp.w	r6,r7
80006082:	cf 81       	brne	80006072 <_write+0x1a>
80006084:	c0 28       	rjmp	80006088 <_write+0x30>
80006086:	3f f7       	mov	r7,-1

    ++nChars;
  }

  return nChars;
}
80006088:	0e 9c       	mov	r12,r7
8000608a:	d8 22       	popm	r4-r7,pc
8000608c:	00 00       	add	r0,r0
8000608e:	bf f0       	*unknown*
80006090:	80 00       	ld.sh	r0,r0[0x0]
80006092:	5b 54       	cp.w	r4,-11

80006094 <vPortFree>:
	return pvReturn;
}
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
80006094:	eb cd 40 80 	pushm	r7,lr
80006098:	18 97       	mov	r7,r12
	if( pv )
8000609a:	58 0c       	cp.w	r12,0
8000609c:	c0 80       	breq	800060ac <vPortFree+0x18>
	{
		vTaskSuspendAll();
8000609e:	f0 1f 00 05 	mcall	800060b0 <vPortFree+0x1c>
		{
			free( pv );
800060a2:	0e 9c       	mov	r12,r7
800060a4:	f0 1f 00 04 	mcall	800060b4 <vPortFree+0x20>
		}
		xTaskResumeAll();
800060a8:	f0 1f 00 04 	mcall	800060b8 <vPortFree+0x24>
800060ac:	e3 cd 80 80 	ldm	sp++,r7,pc
800060b0:	80 00       	ld.sh	r0,r0[0x0]
800060b2:	65 dc       	ld.w	r12,r2[0x74]
800060b4:	80 00       	ld.sh	r0,r0[0x0]
800060b6:	74 6c       	ld.w	r12,r10[0x18]
800060b8:	80 00       	ld.sh	r0,r0[0x0]
800060ba:	69 98       	ld.w	r8,r4[0x64]

800060bc <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
800060bc:	eb cd 40 80 	pushm	r7,lr
800060c0:	18 97       	mov	r7,r12
void *pvReturn;

	vTaskSuspendAll();
800060c2:	f0 1f 00 06 	mcall	800060d8 <pvPortMalloc+0x1c>
	{
		pvReturn = malloc( xWantedSize );
800060c6:	0e 9c       	mov	r12,r7
800060c8:	f0 1f 00 05 	mcall	800060dc <pvPortMalloc+0x20>
800060cc:	18 97       	mov	r7,r12
	}
	xTaskResumeAll();
800060ce:	f0 1f 00 05 	mcall	800060e0 <pvPortMalloc+0x24>
		}
	}
	#endif

	return pvReturn;
}
800060d2:	0e 9c       	mov	r12,r7
800060d4:	e3 cd 80 80 	ldm	sp++,r7,pc
800060d8:	80 00       	ld.sh	r0,r0[0x0]
800060da:	65 dc       	ld.w	r12,r2[0x74]
800060dc:	80 00       	ld.sh	r0,r0[0x0]
800060de:	74 7c       	ld.w	r12,r10[0x1c]
800060e0:	80 00       	ld.sh	r0,r0[0x0]
800060e2:	69 98       	ld.w	r8,r4[0x64]

800060e4 <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
800060e4:	d4 01       	pushm	lr
800060e6:	16 98       	mov	r8,r11
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
800060e8:	78 09       	ld.w	r9,r12[0x0]
800060ea:	58 09       	cp.w	r9,0
800060ec:	c1 10       	breq	8000610e <prvCopyDataFromQueue+0x2a>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
800060ee:	78 3a       	ld.w	r10,r12[0xc]
800060f0:	79 09       	ld.w	r9,r12[0x40]
800060f2:	f4 09 00 09 	add	r9,r10,r9
800060f6:	99 39       	st.w	r12[0xc],r9
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
800060f8:	78 1a       	ld.w	r10,r12[0x4]
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
800060fa:	14 39       	cp.w	r9,r10
800060fc:	f9 f9 20 00 	ld.wcc	r9,r12[0x0]
80006100:	f9 f9 2a 03 	st.wcc	r12[0xc],r9
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
80006104:	79 0a       	ld.w	r10,r12[0x40]
80006106:	78 3b       	ld.w	r11,r12[0xc]
80006108:	10 9c       	mov	r12,r8
8000610a:	f0 1f 00 02 	mcall	80006110 <prvCopyDataFromQueue+0x2c>
8000610e:	d8 02       	popm	pc
80006110:	80 00       	ld.sh	r0,r0[0x0]
80006112:	78 c4       	ld.w	r4,r12[0x30]

80006114 <xQueueReceiveFromISR>:
	}
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
80006114:	eb cd 40 c0 	pushm	r6-r7,lr
80006118:	18 97       	mov	r7,r12
8000611a:	14 96       	mov	r6,r10
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
8000611c:	78 e8       	ld.w	r8,r12[0x38]
8000611e:	58 08       	cp.w	r8,0
80006120:	c0 31       	brne	80006126 <xQueueReceiveFromISR+0x12>
80006122:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
80006126:	f0 1f 00 0e 	mcall	8000615c <xQueueReceiveFromISR+0x48>
			--( pxQueue->uxMessagesWaiting );
8000612a:	6e e8       	ld.w	r8,r7[0x38]
8000612c:	20 18       	sub	r8,1
8000612e:	8f e8       	st.w	r7[0x38],r8

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
80006130:	6f 18       	ld.w	r8,r7[0x44]
80006132:	5b f8       	cp.w	r8,-1
80006134:	c0 d1       	brne	8000614e <xQueueReceiveFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80006136:	6e 48       	ld.w	r8,r7[0x10]
80006138:	58 08       	cp.w	r8,0
8000613a:	c0 f0       	breq	80006158 <xQueueReceiveFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
8000613c:	ee cc ff f0 	sub	r12,r7,-16
80006140:	f0 1f 00 08 	mcall	80006160 <xQueueReceiveFromISR+0x4c>
80006144:	c0 a0       	breq	80006158 <xQueueReceiveFromISR+0x44>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
80006146:	30 1c       	mov	r12,1
80006148:	8d 0c       	st.w	r6[0x0],r12
8000614a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
8000614e:	2f f8       	sub	r8,-1
80006150:	ef 48 00 44 	st.w	r7[68],r8
80006154:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80006158:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
8000615c:	80 00       	ld.sh	r0,r0[0x0]
8000615e:	60 e4       	ld.w	r4,r0[0x38]
80006160:	80 00       	ld.sh	r0,r0[0x0]
80006162:	67 74       	ld.w	r4,r3[0x5c]

80006164 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
80006164:	eb cd 40 c0 	pushm	r6-r7,lr
80006168:	18 97       	mov	r7,r12

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
8000616a:	f0 1f 00 23 	mcall	800061f4 <prvUnlockQueue+0x90>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
8000616e:	6f 28       	ld.w	r8,r7[0x48]
80006170:	58 08       	cp.w	r8,0
80006172:	e0 8a 00 18 	brle	800061a2 <prvUnlockQueue+0x3e>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80006176:	6e 98       	ld.w	r8,r7[0x24]
80006178:	58 08       	cp.w	r8,0
8000617a:	c1 40       	breq	800061a2 <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
8000617c:	ee c6 ff dc 	sub	r6,r7,-36
80006180:	c0 48       	rjmp	80006188 <prvUnlockQueue+0x24>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80006182:	6e 98       	ld.w	r8,r7[0x24]
80006184:	58 08       	cp.w	r8,0
80006186:	c0 e0       	breq	800061a2 <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80006188:	0c 9c       	mov	r12,r6
8000618a:	f0 1f 00 1c 	mcall	800061f8 <prvUnlockQueue+0x94>
8000618e:	c0 30       	breq	80006194 <prvUnlockQueue+0x30>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
80006190:	f0 1f 00 1b 	mcall	800061fc <prvUnlockQueue+0x98>
				}

				--( pxQueue->xTxLock );
80006194:	6f 28       	ld.w	r8,r7[0x48]
80006196:	20 18       	sub	r8,1
80006198:	ef 48 00 48 	st.w	r7[72],r8
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
8000619c:	58 08       	cp.w	r8,0
8000619e:	fe 99 ff f2 	brgt	80006182 <prvUnlockQueue+0x1e>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
800061a2:	3f f8       	mov	r8,-1
800061a4:	ef 48 00 48 	st.w	r7[72],r8
	}
	taskEXIT_CRITICAL();
800061a8:	f0 1f 00 16 	mcall	80006200 <prvUnlockQueue+0x9c>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
800061ac:	f0 1f 00 12 	mcall	800061f4 <prvUnlockQueue+0x90>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
800061b0:	6f 18       	ld.w	r8,r7[0x44]
800061b2:	58 08       	cp.w	r8,0
800061b4:	e0 8a 00 18 	brle	800061e4 <prvUnlockQueue+0x80>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
800061b8:	6e 48       	ld.w	r8,r7[0x10]
800061ba:	58 08       	cp.w	r8,0
800061bc:	c1 40       	breq	800061e4 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
800061be:	ee c6 ff f0 	sub	r6,r7,-16
800061c2:	c0 48       	rjmp	800061ca <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
800061c4:	6e 48       	ld.w	r8,r7[0x10]
800061c6:	58 08       	cp.w	r8,0
800061c8:	c0 e0       	breq	800061e4 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
800061ca:	0c 9c       	mov	r12,r6
800061cc:	f0 1f 00 0b 	mcall	800061f8 <prvUnlockQueue+0x94>
800061d0:	c0 30       	breq	800061d6 <prvUnlockQueue+0x72>
				{
					vTaskMissedYield();
800061d2:	f0 1f 00 0b 	mcall	800061fc <prvUnlockQueue+0x98>
				}

				--( pxQueue->xRxLock );
800061d6:	6f 18       	ld.w	r8,r7[0x44]
800061d8:	20 18       	sub	r8,1
800061da:	ef 48 00 44 	st.w	r7[68],r8
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
800061de:	58 08       	cp.w	r8,0
800061e0:	fe 99 ff f2 	brgt	800061c4 <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
800061e4:	3f f8       	mov	r8,-1
800061e6:	ef 48 00 44 	st.w	r7[68],r8
	}
	taskEXIT_CRITICAL();
800061ea:	f0 1f 00 06 	mcall	80006200 <prvUnlockQueue+0x9c>
}
800061ee:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800061f2:	00 00       	add	r0,r0
800061f4:	80 00       	ld.sh	r0,r0[0x0]
800061f6:	5e 50       	retlt	r0
800061f8:	80 00       	ld.sh	r0,r0[0x0]
800061fa:	67 74       	ld.w	r4,r3[0x5c]
800061fc:	80 00       	ld.sh	r0,r0[0x0]
800061fe:	66 80       	ld.w	r0,r3[0x20]
80006200:	80 00       	ld.sh	r0,r0[0x0]
80006202:	5f 5c       	srlt	r12

80006204 <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
80006204:	d4 31       	pushm	r0-r7,lr
80006206:	20 5d       	sub	sp,20
80006208:	18 97       	mov	r7,r12
8000620a:	50 0b       	stdsp	sp[0x0],r11
8000620c:	50 2a       	stdsp	sp[0x8],r10
8000620e:	50 19       	stdsp	sp[0x4],r9
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80006210:	f8 c2 ff dc 	sub	r2,r12,-36
80006214:	30 05       	mov	r5,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80006216:	fa c4 ff f4 	sub	r4,sp,-12
8000621a:	30 10       	mov	r0,1

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
8000621c:	0a 91       	mov	r1,r5

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
8000621e:	fa c3 ff f8 	sub	r3,sp,-8
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
80006222:	f0 1f 00 3e 	mcall	80006318 <xQueueGenericReceive+0x114>
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80006226:	6e e8       	ld.w	r8,r7[0x38]
80006228:	58 08       	cp.w	r8,0
8000622a:	c2 a0       	breq	8000627e <xQueueGenericReceive+0x7a>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
8000622c:	6e 36       	ld.w	r6,r7[0xc]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
8000622e:	40 0b       	lddsp	r11,sp[0x0]
80006230:	0e 9c       	mov	r12,r7
80006232:	f0 1f 00 3b 	mcall	8000631c <xQueueGenericReceive+0x118>

				if( xJustPeeking == pdFALSE )
80006236:	40 18       	lddsp	r8,sp[0x4]
80006238:	58 08       	cp.w	r8,0
8000623a:	c1 51       	brne	80006264 <xQueueGenericReceive+0x60>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
8000623c:	6e e8       	ld.w	r8,r7[0x38]
8000623e:	20 18       	sub	r8,1
80006240:	8f e8       	st.w	r7[0x38],r8

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80006242:	6e 08       	ld.w	r8,r7[0x0]
80006244:	58 08       	cp.w	r8,0
80006246:	c0 41       	brne	8000624e <xQueueGenericReceive+0x4a>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
80006248:	f0 1f 00 36 	mcall	80006320 <xQueueGenericReceive+0x11c>
8000624c:	8f 1c       	st.w	r7[0x4],r12
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
8000624e:	6e 48       	ld.w	r8,r7[0x10]
80006250:	58 08       	cp.w	r8,0
80006252:	c1 20       	breq	80006276 <xQueueGenericReceive+0x72>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
80006254:	ee cc ff f0 	sub	r12,r7,-16
80006258:	f0 1f 00 33 	mcall	80006324 <xQueueGenericReceive+0x120>
8000625c:	58 1c       	cp.w	r12,1
8000625e:	c0 c1       	brne	80006276 <xQueueGenericReceive+0x72>
						{
							portYIELD_WITHIN_API();
80006260:	d7 33       	scall
80006262:	c0 a8       	rjmp	80006276 <xQueueGenericReceive+0x72>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
80006264:	8f 36       	st.w	r7[0xc],r6

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80006266:	6e 98       	ld.w	r8,r7[0x24]
80006268:	58 08       	cp.w	r8,0
8000626a:	c0 60       	breq	80006276 <xQueueGenericReceive+0x72>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
8000626c:	04 9c       	mov	r12,r2
8000626e:	f0 1f 00 2e 	mcall	80006324 <xQueueGenericReceive+0x120>
80006272:	c0 20       	breq	80006276 <xQueueGenericReceive+0x72>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
80006274:	d7 33       	scall
						}
					}

				}

				taskEXIT_CRITICAL();
80006276:	f0 1f 00 2d 	mcall	80006328 <xQueueGenericReceive+0x124>
8000627a:	30 1c       	mov	r12,1
				return pdPASS;
8000627c:	c4 c8       	rjmp	80006314 <xQueueGenericReceive+0x110>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
8000627e:	40 28       	lddsp	r8,sp[0x8]
80006280:	58 08       	cp.w	r8,0
80006282:	c0 51       	brne	8000628c <xQueueGenericReceive+0x88>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80006284:	f0 1f 00 29 	mcall	80006328 <xQueueGenericReceive+0x124>
80006288:	30 0c       	mov	r12,0
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
8000628a:	c4 58       	rjmp	80006314 <xQueueGenericReceive+0x110>
				}
				else if( xEntryTimeSet == pdFALSE )
8000628c:	58 05       	cp.w	r5,0
8000628e:	c0 51       	brne	80006298 <xQueueGenericReceive+0x94>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80006290:	08 9c       	mov	r12,r4
80006292:	f0 1f 00 27 	mcall	8000632c <xQueueGenericReceive+0x128>
80006296:	00 95       	mov	r5,r0
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80006298:	f0 1f 00 24 	mcall	80006328 <xQueueGenericReceive+0x124>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
8000629c:	f0 1f 00 25 	mcall	80006330 <xQueueGenericReceive+0x12c>
		prvLockQueue( pxQueue );
800062a0:	f0 1f 00 1e 	mcall	80006318 <xQueueGenericReceive+0x114>
800062a4:	6f 18       	ld.w	r8,r7[0x44]
800062a6:	5b f8       	cp.w	r8,-1
800062a8:	ef f1 0a 11 	st.weq	r7[0x44],r1
800062ac:	6f 28       	ld.w	r8,r7[0x48]
800062ae:	5b f8       	cp.w	r8,-1
800062b0:	ef f1 0a 12 	st.weq	r7[0x48],r1
800062b4:	f0 1f 00 1d 	mcall	80006328 <xQueueGenericReceive+0x124>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
800062b8:	06 9b       	mov	r11,r3
800062ba:	08 9c       	mov	r12,r4
800062bc:	f0 1f 00 1e 	mcall	80006334 <xQueueGenericReceive+0x130>
800062c0:	c2 41       	brne	80006308 <xQueueGenericReceive+0x104>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
800062c2:	f0 1f 00 16 	mcall	80006318 <xQueueGenericReceive+0x114>
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
800062c6:	6e e6       	ld.w	r6,r7[0x38]
	taskEXIT_CRITICAL();
800062c8:	f0 1f 00 18 	mcall	80006328 <xQueueGenericReceive+0x124>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) )
800062cc:	58 06       	cp.w	r6,0
800062ce:	c1 71       	brne	800062fc <xQueueGenericReceive+0xf8>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
800062d0:	6e 08       	ld.w	r8,r7[0x0]
800062d2:	58 08       	cp.w	r8,0
800062d4:	c0 81       	brne	800062e4 <xQueueGenericReceive+0xe0>
					{
						portENTER_CRITICAL();
800062d6:	f0 1f 00 11 	mcall	80006318 <xQueueGenericReceive+0x114>
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
800062da:	6e 1c       	ld.w	r12,r7[0x4]
800062dc:	f0 1f 00 17 	mcall	80006338 <xQueueGenericReceive+0x134>
						}
						portEXIT_CRITICAL();
800062e0:	f0 1f 00 12 	mcall	80006328 <xQueueGenericReceive+0x124>
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
800062e4:	40 2b       	lddsp	r11,sp[0x8]
800062e6:	04 9c       	mov	r12,r2
800062e8:	f0 1f 00 15 	mcall	8000633c <xQueueGenericReceive+0x138>
				prvUnlockQueue( pxQueue );
800062ec:	0e 9c       	mov	r12,r7
800062ee:	f0 1f 00 15 	mcall	80006340 <xQueueGenericReceive+0x13c>
				if( !xTaskResumeAll() )
800062f2:	f0 1f 00 15 	mcall	80006344 <xQueueGenericReceive+0x140>
800062f6:	c9 61       	brne	80006222 <xQueueGenericReceive+0x1e>
				{
					portYIELD_WITHIN_API();
800062f8:	d7 33       	scall
800062fa:	c9 4b       	rjmp	80006222 <xQueueGenericReceive+0x1e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
800062fc:	0e 9c       	mov	r12,r7
800062fe:	f0 1f 00 11 	mcall	80006340 <xQueueGenericReceive+0x13c>
				( void ) xTaskResumeAll();
80006302:	f0 1f 00 11 	mcall	80006344 <xQueueGenericReceive+0x140>
80006306:	c8 eb       	rjmp	80006222 <xQueueGenericReceive+0x1e>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
80006308:	0e 9c       	mov	r12,r7
8000630a:	f0 1f 00 0e 	mcall	80006340 <xQueueGenericReceive+0x13c>
			( void ) xTaskResumeAll();
8000630e:	f0 1f 00 0e 	mcall	80006344 <xQueueGenericReceive+0x140>
80006312:	30 0c       	mov	r12,0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
80006314:	2f bd       	sub	sp,-20
80006316:	d8 32       	popm	r0-r7,pc
80006318:	80 00       	ld.sh	r0,r0[0x0]
8000631a:	5e 50       	retlt	r0
8000631c:	80 00       	ld.sh	r0,r0[0x0]
8000631e:	60 e4       	ld.w	r4,r0[0x38]
80006320:	80 00       	ld.sh	r0,r0[0x0]
80006322:	66 8c       	ld.w	r12,r3[0x20]
80006324:	80 00       	ld.sh	r0,r0[0x0]
80006326:	67 74       	ld.w	r4,r3[0x5c]
80006328:	80 00       	ld.sh	r0,r0[0x0]
8000632a:	5f 5c       	srlt	r12
8000632c:	80 00       	ld.sh	r0,r0[0x0]
8000632e:	66 68       	ld.w	r8,r3[0x18]
80006330:	80 00       	ld.sh	r0,r0[0x0]
80006332:	65 dc       	ld.w	r12,r2[0x74]
80006334:	80 00       	ld.sh	r0,r0[0x0]
80006336:	69 04       	ld.w	r4,r4[0x40]
80006338:	80 00       	ld.sh	r0,r0[0x0]
8000633a:	66 f0       	ld.w	r0,r3[0x3c]
8000633c:	80 00       	ld.sh	r0,r0[0x0]
8000633e:	6b a4       	ld.w	r4,r5[0x68]
80006340:	80 00       	ld.sh	r0,r0[0x0]
80006342:	61 64       	ld.w	r4,r0[0x58]
80006344:	80 00       	ld.sh	r0,r0[0x0]
80006346:	69 98       	ld.w	r8,r4[0x64]

80006348 <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
80006348:	eb cd 40 80 	pushm	r7,lr
8000634c:	18 97       	mov	r7,r12
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
8000634e:	79 08       	ld.w	r8,r12[0x40]
80006350:	58 08       	cp.w	r8,0
80006352:	c0 a1       	brne	80006366 <prvCopyDataToQueue+0x1e>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80006354:	78 08       	ld.w	r8,r12[0x0]
80006356:	58 08       	cp.w	r8,0
80006358:	c2 b1       	brne	800063ae <prvCopyDataToQueue+0x66>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
8000635a:	78 1c       	ld.w	r12,r12[0x4]
8000635c:	f0 1f 00 17 	mcall	800063b8 <prvCopyDataToQueue+0x70>
				pxQueue->pxMutexHolder = NULL;
80006360:	30 08       	mov	r8,0
80006362:	8f 18       	st.w	r7[0x4],r8
80006364:	c2 58       	rjmp	800063ae <prvCopyDataToQueue+0x66>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
80006366:	58 0a       	cp.w	r10,0
80006368:	c1 01       	brne	80006388 <prvCopyDataToQueue+0x40>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
8000636a:	10 9a       	mov	r10,r8
8000636c:	78 2c       	ld.w	r12,r12[0x8]
8000636e:	f0 1f 00 14 	mcall	800063bc <prvCopyDataToQueue+0x74>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
80006372:	6e 29       	ld.w	r9,r7[0x8]
80006374:	6f 08       	ld.w	r8,r7[0x40]
80006376:	f2 08 00 08 	add	r8,r9,r8
8000637a:	8f 28       	st.w	r7[0x8],r8
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
8000637c:	6e 19       	ld.w	r9,r7[0x4]
8000637e:	12 38       	cp.w	r8,r9
80006380:	c1 73       	brcs	800063ae <prvCopyDataToQueue+0x66>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
80006382:	6e 08       	ld.w	r8,r7[0x0]
80006384:	8f 28       	st.w	r7[0x8],r8
80006386:	c1 48       	rjmp	800063ae <prvCopyDataToQueue+0x66>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80006388:	10 9a       	mov	r10,r8
8000638a:	78 3c       	ld.w	r12,r12[0xc]
8000638c:	f0 1f 00 0c 	mcall	800063bc <prvCopyDataToQueue+0x74>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
80006390:	6f 08       	ld.w	r8,r7[0x40]
80006392:	6e 39       	ld.w	r9,r7[0xc]
80006394:	f2 08 01 08 	sub	r8,r9,r8
80006398:	8f 38       	st.w	r7[0xc],r8
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
8000639a:	6e 09       	ld.w	r9,r7[0x0]
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
8000639c:	12 38       	cp.w	r8,r9
8000639e:	ef f8 30 10 	ld.wcs	r8,r7[0x40]
800063a2:	ef f9 30 01 	ld.wcs	r9,r7[0x4]
800063a6:	f3 d8 e3 19 	subcs	r9,r9,r8
800063aa:	ef f9 3a 03 	st.wcs	r7[0xc],r9
		}
	}

	++( pxQueue->uxMessagesWaiting );
800063ae:	6e e8       	ld.w	r8,r7[0x38]
800063b0:	2f f8       	sub	r8,-1
800063b2:	8f e8       	st.w	r7[0x38],r8
}
800063b4:	e3 cd 80 80 	ldm	sp++,r7,pc
800063b8:	80 00       	ld.sh	r0,r0[0x0]
800063ba:	66 98       	ld.w	r8,r3[0x24]
800063bc:	80 00       	ld.sh	r0,r0[0x0]
800063be:	78 c4       	ld.w	r4,r12[0x30]

800063c0 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
800063c0:	eb cd 40 c0 	pushm	r6-r7,lr
800063c4:	18 97       	mov	r7,r12
800063c6:	14 96       	mov	r6,r10
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
800063c8:	78 ec       	ld.w	r12,r12[0x38]
800063ca:	6e f8       	ld.w	r8,r7[0x3c]
800063cc:	10 3c       	cp.w	r12,r8
800063ce:	c0 33       	brcs	800063d4 <xQueueGenericSendFromISR+0x14>
800063d0:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
800063d4:	12 9a       	mov	r10,r9
800063d6:	0e 9c       	mov	r12,r7
800063d8:	f0 1f 00 0c 	mcall	80006408 <xQueueGenericSendFromISR+0x48>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
800063dc:	6f 28       	ld.w	r8,r7[0x48]
800063de:	5b f8       	cp.w	r8,-1
800063e0:	c0 d1       	brne	800063fa <xQueueGenericSendFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
800063e2:	6e 98       	ld.w	r8,r7[0x24]
800063e4:	58 08       	cp.w	r8,0
800063e6:	c0 f0       	breq	80006404 <xQueueGenericSendFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
800063e8:	ee cc ff dc 	sub	r12,r7,-36
800063ec:	f0 1f 00 08 	mcall	8000640c <xQueueGenericSendFromISR+0x4c>
800063f0:	c0 a0       	breq	80006404 <xQueueGenericSendFromISR+0x44>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
800063f2:	30 1c       	mov	r12,1
800063f4:	8d 0c       	st.w	r6[0x0],r12
800063f6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
800063fa:	2f f8       	sub	r8,-1
800063fc:	ef 48 00 48 	st.w	r7[72],r8
80006400:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80006404:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80006408:	80 00       	ld.sh	r0,r0[0x0]
8000640a:	63 48       	ld.w	r8,r1[0x50]
8000640c:	80 00       	ld.sh	r0,r0[0x0]
8000640e:	67 74       	ld.w	r4,r3[0x5c]

80006410 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
80006410:	d4 31       	pushm	r0-r7,lr
80006412:	20 5d       	sub	sp,20
80006414:	18 97       	mov	r7,r12
80006416:	50 0b       	stdsp	sp[0x0],r11
80006418:	50 2a       	stdsp	sp[0x8],r10
8000641a:	50 19       	stdsp	sp[0x4],r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
8000641c:	f8 c0 ff f0 	sub	r0,r12,-16
80006420:	30 04       	mov	r4,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80006422:	fa c3 ff f4 	sub	r3,sp,-12

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
80006426:	08 91       	mov	r1,r4

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80006428:	fa c2 ff f8 	sub	r2,sp,-8
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
8000642c:	f0 1f 00 2f 	mcall	800064e8 <xQueueGenericSend+0xd8>
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
80006430:	6e e9       	ld.w	r9,r7[0x38]
80006432:	6e f8       	ld.w	r8,r7[0x3c]
80006434:	10 39       	cp.w	r9,r8
80006436:	c1 42       	brcc	8000645e <xQueueGenericSend+0x4e>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80006438:	40 1a       	lddsp	r10,sp[0x4]
8000643a:	40 0b       	lddsp	r11,sp[0x0]
8000643c:	0e 9c       	mov	r12,r7
8000643e:	f0 1f 00 2c 	mcall	800064ec <xQueueGenericSend+0xdc>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80006442:	6e 98       	ld.w	r8,r7[0x24]
80006444:	58 08       	cp.w	r8,0
80006446:	c0 80       	breq	80006456 <xQueueGenericSend+0x46>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
80006448:	ee cc ff dc 	sub	r12,r7,-36
8000644c:	f0 1f 00 29 	mcall	800064f0 <xQueueGenericSend+0xe0>
80006450:	58 1c       	cp.w	r12,1
80006452:	c0 21       	brne	80006456 <xQueueGenericSend+0x46>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
80006454:	d7 33       	scall
					}
				}

				taskEXIT_CRITICAL();
80006456:	f0 1f 00 28 	mcall	800064f4 <xQueueGenericSend+0xe4>
8000645a:	30 1c       	mov	r12,1

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
8000645c:	c4 38       	rjmp	800064e2 <xQueueGenericSend+0xd2>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
8000645e:	40 28       	lddsp	r8,sp[0x8]
80006460:	58 08       	cp.w	r8,0
80006462:	c0 51       	brne	8000646c <xQueueGenericSend+0x5c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80006464:	f0 1f 00 24 	mcall	800064f4 <xQueueGenericSend+0xe4>
80006468:	30 0c       	mov	r12,0

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
8000646a:	c3 c8       	rjmp	800064e2 <xQueueGenericSend+0xd2>
				}
				else if( xEntryTimeSet == pdFALSE )
8000646c:	58 04       	cp.w	r4,0
8000646e:	c0 51       	brne	80006478 <xQueueGenericSend+0x68>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80006470:	06 9c       	mov	r12,r3
80006472:	f0 1f 00 22 	mcall	800064f8 <xQueueGenericSend+0xe8>
80006476:	30 14       	mov	r4,1
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80006478:	f0 1f 00 1f 	mcall	800064f4 <xQueueGenericSend+0xe4>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
8000647c:	f0 1f 00 20 	mcall	800064fc <xQueueGenericSend+0xec>
		prvLockQueue( pxQueue );
80006480:	f0 1f 00 1a 	mcall	800064e8 <xQueueGenericSend+0xd8>
80006484:	6f 18       	ld.w	r8,r7[0x44]
80006486:	5b f8       	cp.w	r8,-1
80006488:	ef f1 0a 11 	st.weq	r7[0x44],r1
8000648c:	6f 28       	ld.w	r8,r7[0x48]
8000648e:	5b f8       	cp.w	r8,-1
80006490:	ef f1 0a 12 	st.weq	r7[0x48],r1
80006494:	f0 1f 00 18 	mcall	800064f4 <xQueueGenericSend+0xe4>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80006498:	04 9b       	mov	r11,r2
8000649a:	06 9c       	mov	r12,r3
8000649c:	f0 1f 00 19 	mcall	80006500 <xQueueGenericSend+0xf0>
800064a0:	c1 b1       	brne	800064d6 <xQueueGenericSend+0xc6>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
800064a2:	f0 1f 00 12 	mcall	800064e8 <xQueueGenericSend+0xd8>
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
800064a6:	6e e5       	ld.w	r5,r7[0x38]
800064a8:	6e f6       	ld.w	r6,r7[0x3c]
	taskEXIT_CRITICAL();
800064aa:	f0 1f 00 13 	mcall	800064f4 <xQueueGenericSend+0xe4>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
800064ae:	0c 35       	cp.w	r5,r6
800064b0:	c0 d1       	brne	800064ca <xQueueGenericSend+0xba>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
800064b2:	40 2b       	lddsp	r11,sp[0x8]
800064b4:	00 9c       	mov	r12,r0
800064b6:	f0 1f 00 14 	mcall	80006504 <xQueueGenericSend+0xf4>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
800064ba:	0e 9c       	mov	r12,r7
800064bc:	f0 1f 00 13 	mcall	80006508 <xQueueGenericSend+0xf8>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
800064c0:	f0 1f 00 13 	mcall	8000650c <xQueueGenericSend+0xfc>
800064c4:	cb 41       	brne	8000642c <xQueueGenericSend+0x1c>
				{
					portYIELD_WITHIN_API();
800064c6:	d7 33       	scall
800064c8:	cb 2b       	rjmp	8000642c <xQueueGenericSend+0x1c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
800064ca:	0e 9c       	mov	r12,r7
800064cc:	f0 1f 00 0f 	mcall	80006508 <xQueueGenericSend+0xf8>
				( void ) xTaskResumeAll();
800064d0:	f0 1f 00 0f 	mcall	8000650c <xQueueGenericSend+0xfc>
800064d4:	ca cb       	rjmp	8000642c <xQueueGenericSend+0x1c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
800064d6:	0e 9c       	mov	r12,r7
800064d8:	f0 1f 00 0c 	mcall	80006508 <xQueueGenericSend+0xf8>
			( void ) xTaskResumeAll();
800064dc:	f0 1f 00 0c 	mcall	8000650c <xQueueGenericSend+0xfc>
800064e0:	30 0c       	mov	r12,0
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
800064e2:	2f bd       	sub	sp,-20
800064e4:	d8 32       	popm	r0-r7,pc
800064e6:	00 00       	add	r0,r0
800064e8:	80 00       	ld.sh	r0,r0[0x0]
800064ea:	5e 50       	retlt	r0
800064ec:	80 00       	ld.sh	r0,r0[0x0]
800064ee:	63 48       	ld.w	r8,r1[0x50]
800064f0:	80 00       	ld.sh	r0,r0[0x0]
800064f2:	67 74       	ld.w	r4,r3[0x5c]
800064f4:	80 00       	ld.sh	r0,r0[0x0]
800064f6:	5f 5c       	srlt	r12
800064f8:	80 00       	ld.sh	r0,r0[0x0]
800064fa:	66 68       	ld.w	r8,r3[0x18]
800064fc:	80 00       	ld.sh	r0,r0[0x0]
800064fe:	65 dc       	ld.w	r12,r2[0x74]
80006500:	80 00       	ld.sh	r0,r0[0x0]
80006502:	69 04       	ld.w	r4,r4[0x40]
80006504:	80 00       	ld.sh	r0,r0[0x0]
80006506:	6b a4       	ld.w	r4,r5[0x68]
80006508:	80 00       	ld.sh	r0,r0[0x0]
8000650a:	61 64       	ld.w	r4,r0[0x58]
8000650c:	80 00       	ld.sh	r0,r0[0x0]
8000650e:	69 98       	ld.w	r8,r4[0x64]

80006510 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	xQueueHandle xQueueCreateMutex( void )
	{
80006510:	eb cd 40 c0 	pushm	r6-r7,lr
	xQUEUE *pxNewQueue;

		/* Allocate the new queue structure. */
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
80006514:	34 cc       	mov	r12,76
80006516:	f0 1f 00 12 	mcall	8000655c <xQueueCreateMutex+0x4c>
8000651a:	18 97       	mov	r7,r12
		if( pxNewQueue != NULL )
8000651c:	c1 d0       	breq	80006556 <xQueueCreateMutex+0x46>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
8000651e:	30 06       	mov	r6,0
80006520:	99 16       	st.w	r12[0x4],r6
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
80006522:	99 06       	st.w	r12[0x0],r6

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
80006524:	99 26       	st.w	r12[0x8],r6
			pxNewQueue->pcReadFrom = NULL;
80006526:	99 36       	st.w	r12[0xc],r6

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
80006528:	99 e6       	st.w	r12[0x38],r6
			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
8000652a:	30 18       	mov	r8,1
8000652c:	99 f8       	st.w	r12[0x3c],r8
			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
8000652e:	f9 46 00 40 	st.w	r12[64],r6
			pxNewQueue->xRxLock = queueUNLOCKED;
80006532:	3f f8       	mov	r8,-1
80006534:	f9 48 00 44 	st.w	r12[68],r8
			pxNewQueue->xTxLock = queueUNLOCKED;
80006538:	f9 48 00 48 	st.w	r12[72],r8

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
8000653c:	2f 0c       	sub	r12,-16
8000653e:	f0 1f 00 09 	mcall	80006560 <xQueueCreateMutex+0x50>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
80006542:	ee cc ff dc 	sub	r12,r7,-36
80006546:	f0 1f 00 07 	mcall	80006560 <xQueueCreateMutex+0x50>

			/* Start with the semaphore in the expected state. */
			xQueueGenericSend( pxNewQueue, NULL, ( portTickType ) 0U, queueSEND_TO_BACK );
8000654a:	0c 99       	mov	r9,r6
8000654c:	0c 9a       	mov	r10,r6
8000654e:	0c 9b       	mov	r11,r6
80006550:	0e 9c       	mov	r12,r7
80006552:	f0 1f 00 05 	mcall	80006564 <xQueueCreateMutex+0x54>
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
80006556:	0e 9c       	mov	r12,r7
80006558:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000655c:	80 00       	ld.sh	r0,r0[0x0]
8000655e:	60 bc       	ld.w	r12,r0[0x2c]
80006560:	80 00       	ld.sh	r0,r0[0x0]
80006562:	5d 2c       	mustr	r12
80006564:	80 00       	ld.sh	r0,r0[0x0]
80006566:	64 10       	ld.w	r0,r2[0x4]

80006568 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
80006568:	d4 21       	pushm	r4-r7,lr
8000656a:	18 97       	mov	r7,r12
8000656c:	16 96       	mov	r6,r11
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
8000656e:	58 0c       	cp.w	r12,0
80006570:	c2 f0       	breq	800065ce <xQueueCreate+0x66>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
80006572:	34 cc       	mov	r12,76
80006574:	f0 1f 00 17 	mcall	800065d0 <xQueueCreate+0x68>
80006578:	18 95       	mov	r5,r12
		if( pxNewQueue != NULL )
8000657a:	c2 a0       	breq	800065ce <xQueueCreate+0x66>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
8000657c:	ec 07 02 44 	mul	r4,r6,r7

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
80006580:	e8 cc ff ff 	sub	r12,r4,-1
80006584:	f0 1f 00 13 	mcall	800065d0 <xQueueCreate+0x68>
80006588:	8b 0c       	st.w	r5[0x0],r12
			if( pxNewQueue->pcHead != NULL )
8000658a:	c1 e0       	breq	800065c6 <xQueueCreate+0x5e>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
8000658c:	f8 04 00 04 	add	r4,r12,r4
80006590:	8b 14       	st.w	r5[0x4],r4
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
80006592:	30 08       	mov	r8,0
80006594:	8b e8       	st.w	r5[0x38],r8
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
80006596:	8b 2c       	st.w	r5[0x8],r12
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
80006598:	ee c8 00 01 	sub	r8,r7,1
8000659c:	ad 38       	mul	r8,r6
8000659e:	10 0c       	add	r12,r8
800065a0:	8b 3c       	st.w	r5[0xc],r12
				pxNewQueue->uxLength = uxQueueLength;
800065a2:	8b f7       	st.w	r5[0x3c],r7
				pxNewQueue->uxItemSize = uxItemSize;
800065a4:	eb 46 00 40 	st.w	r5[64],r6
				pxNewQueue->xRxLock = queueUNLOCKED;
800065a8:	3f f8       	mov	r8,-1
800065aa:	eb 48 00 44 	st.w	r5[68],r8
				pxNewQueue->xTxLock = queueUNLOCKED;
800065ae:	eb 48 00 48 	st.w	r5[72],r8

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
800065b2:	ea cc ff f0 	sub	r12,r5,-16
800065b6:	f0 1f 00 08 	mcall	800065d4 <xQueueCreate+0x6c>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
800065ba:	ea cc ff dc 	sub	r12,r5,-36
800065be:	f0 1f 00 06 	mcall	800065d4 <xQueueCreate+0x6c>
800065c2:	0a 9c       	mov	r12,r5
800065c4:	d8 22       	popm	r4-r7,pc
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
800065c6:	0a 9c       	mov	r12,r5
800065c8:	f0 1f 00 04 	mcall	800065d8 <xQueueCreate+0x70>
800065cc:	d8 2a       	popm	r4-r7,pc,r12=0
800065ce:	d8 2a       	popm	r4-r7,pc,r12=0
800065d0:	80 00       	ld.sh	r0,r0[0x0]
800065d2:	60 bc       	ld.w	r12,r0[0x2c]
800065d4:	80 00       	ld.sh	r0,r0[0x0]
800065d6:	5d 2c       	mustr	r12
800065d8:	80 00       	ld.sh	r0,r0[0x0]
800065da:	60 94       	ld.w	r4,r0[0x24]

800065dc <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
800065dc:	48 38       	lddpc	r8,800065e8 <vTaskSuspendAll+0xc>
800065de:	70 09       	ld.w	r9,r8[0x0]
800065e0:	2f f9       	sub	r9,-1
800065e2:	91 09       	st.w	r8[0x0],r9
}
800065e4:	5e fc       	retal	r12
800065e6:	00 00       	add	r0,r0
800065e8:	00 00       	add	r0,r0
800065ea:	0d 24       	ld.uh	r4,r6++

800065ec <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
800065ec:	49 a8       	lddpc	r8,80006654 <vTaskSwitchContext+0x68>
800065ee:	70 08       	ld.w	r8,r8[0x0]
800065f0:	58 08       	cp.w	r8,0
800065f2:	c0 b1       	brne	80006608 <vTaskSwitchContext+0x1c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
800065f4:	49 98       	lddpc	r8,80006658 <vTaskSwitchContext+0x6c>
800065f6:	70 08       	ld.w	r8,r8[0x0]
800065f8:	f0 08 00 28 	add	r8,r8,r8<<0x2
800065fc:	49 89       	lddpc	r9,8000665c <vTaskSwitchContext+0x70>
800065fe:	f2 08 03 28 	ld.w	r8,r9[r8<<0x2]
80006602:	58 08       	cp.w	r8,0
80006604:	c0 60       	breq	80006610 <vTaskSwitchContext+0x24>
80006606:	c1 18       	rjmp	80006628 <vTaskSwitchContext+0x3c>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
80006608:	30 19       	mov	r9,1
8000660a:	49 68       	lddpc	r8,80006660 <vTaskSwitchContext+0x74>
8000660c:	91 09       	st.w	r8[0x0],r9
8000660e:	5e fc       	retal	r12

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
80006610:	49 28       	lddpc	r8,80006658 <vTaskSwitchContext+0x6c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80006612:	49 3a       	lddpc	r10,8000665c <vTaskSwitchContext+0x70>
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
80006614:	70 09       	ld.w	r9,r8[0x0]
80006616:	20 19       	sub	r9,1
80006618:	91 09       	st.w	r8[0x0],r9

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
8000661a:	70 09       	ld.w	r9,r8[0x0]
8000661c:	f2 09 00 29 	add	r9,r9,r9<<0x2
80006620:	f4 09 03 29 	ld.w	r9,r10[r9<<0x2]
80006624:	58 09       	cp.w	r9,0
80006626:	cf 70       	breq	80006614 <vTaskSwitchContext+0x28>
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
80006628:	48 c8       	lddpc	r8,80006658 <vTaskSwitchContext+0x6c>
8000662a:	70 08       	ld.w	r8,r8[0x0]
8000662c:	f0 08 00 28 	add	r8,r8,r8<<0x2
80006630:	48 b9       	lddpc	r9,8000665c <vTaskSwitchContext+0x70>
80006632:	f2 08 00 28 	add	r8,r9,r8<<0x2
80006636:	70 19       	ld.w	r9,r8[0x4]
80006638:	72 19       	ld.w	r9,r9[0x4]
8000663a:	91 19       	st.w	r8[0x4],r9
8000663c:	f0 ca ff f8 	sub	r10,r8,-8
80006640:	14 39       	cp.w	r9,r10
80006642:	f3 f9 00 01 	ld.weq	r9,r9[0x4]
80006646:	f1 f9 0a 01 	st.weq	r8[0x4],r9
8000664a:	70 18       	ld.w	r8,r8[0x4]
8000664c:	70 39       	ld.w	r9,r8[0xc]
8000664e:	48 68       	lddpc	r8,80006664 <vTaskSwitchContext+0x78>
80006650:	91 09       	st.w	r8[0x0],r9
80006652:	5e fc       	retal	r12
80006654:	00 00       	add	r0,r0
80006656:	0d 24       	ld.uh	r4,r6++
80006658:	00 00       	add	r0,r0
8000665a:	0d 5c       	ld.sh	r12,--r6
8000665c:	00 00       	add	r0,r0
8000665e:	0c 40       	or	r0,r6
80006660:	00 00       	add	r0,r0
80006662:	0d 44       	ld.w	r4,--r6
80006664:	00 00       	add	r0,r0
80006666:	0c f4       	st.b	--r6,r4

80006668 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
80006668:	48 48       	lddpc	r8,80006678 <vTaskSetTimeOutState+0x10>
8000666a:	70 08       	ld.w	r8,r8[0x0]
8000666c:	99 08       	st.w	r12[0x0],r8
	pxTimeOut->xTimeOnEntering = xTickCount;
8000666e:	48 48       	lddpc	r8,8000667c <vTaskSetTimeOutState+0x14>
80006670:	70 08       	ld.w	r8,r8[0x0]
80006672:	99 18       	st.w	r12[0x4],r8
}
80006674:	5e fc       	retal	r12
80006676:	00 00       	add	r0,r0
80006678:	00 00       	add	r0,r0
8000667a:	0c 38       	cp.w	r8,r6
8000667c:	00 00       	add	r0,r0
8000667e:	0d 20       	ld.uh	r0,r6++

80006680 <vTaskMissedYield>:
}
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
80006680:	30 19       	mov	r9,1
80006682:	48 28       	lddpc	r8,80006688 <vTaskMissedYield+0x8>
80006684:	91 09       	st.w	r8[0x0],r9
}
80006686:	5e fc       	retal	r12
80006688:	00 00       	add	r0,r0
8000668a:	0d 44       	ld.w	r4,--r6

8000668c <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
8000668c:	48 28       	lddpc	r8,80006694 <xTaskGetCurrentTaskHandle+0x8>
8000668e:	70 0c       	ld.w	r12,r8[0x0]

		return xReturn;
	}
80006690:	5e fc       	retal	r12
80006692:	00 00       	add	r0,r0
80006694:	00 00       	add	r0,r0
80006696:	0c f4       	st.b	--r6,r4

80006698 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
80006698:	eb cd 40 c0 	pushm	r6-r7,lr
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
8000669c:	58 0c       	cp.w	r12,0
8000669e:	c1 f0       	breq	800066dc <vTaskPriorityDisinherit+0x44>

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
800066a0:	18 97       	mov	r7,r12

		if( pxMutexHolder != NULL )
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
800066a2:	78 b9       	ld.w	r9,r12[0x2c]
800066a4:	79 18       	ld.w	r8,r12[0x44]
800066a6:	10 39       	cp.w	r9,r8
800066a8:	c1 a0       	breq	800066dc <vTaskPriorityDisinherit+0x44>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
800066aa:	f8 c6 ff fc 	sub	r6,r12,-4
800066ae:	0c 9c       	mov	r12,r6
800066b0:	f0 1f 00 0c 	mcall	800066e0 <vTaskPriorityDisinherit+0x48>

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
800066b4:	6f 1c       	ld.w	r12,r7[0x44]
800066b6:	8f bc       	st.w	r7[0x2c],r12
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
800066b8:	f8 08 11 08 	rsub	r8,r12,8
800066bc:	8f 68       	st.w	r7[0x18],r8
				prvAddTaskToReadyQueue( pxTCB );
800066be:	48 a8       	lddpc	r8,800066e4 <vTaskPriorityDisinherit+0x4c>
800066c0:	70 08       	ld.w	r8,r8[0x0]
800066c2:	10 3c       	cp.w	r12,r8
800066c4:	e0 88 00 04 	brls	800066cc <vTaskPriorityDisinherit+0x34>
800066c8:	48 78       	lddpc	r8,800066e4 <vTaskPriorityDisinherit+0x4c>
800066ca:	91 0c       	st.w	r8[0x0],r12
800066cc:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800066d0:	0c 9b       	mov	r11,r6
800066d2:	48 68       	lddpc	r8,800066e8 <vTaskPriorityDisinherit+0x50>
800066d4:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800066d8:	f0 1f 00 05 	mcall	800066ec <vTaskPriorityDisinherit+0x54>
800066dc:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800066e0:	80 00       	ld.sh	r0,r0[0x0]
800066e2:	5d 96       	*unknown*
800066e4:	00 00       	add	r0,r0
800066e6:	0d 5c       	ld.sh	r12,--r6
800066e8:	00 00       	add	r0,r0
800066ea:	0c 40       	or	r0,r6
800066ec:	80 00       	ld.sh	r0,r0[0x0]
800066ee:	5d 46       	*unknown*

800066f0 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
800066f0:	eb cd 40 c0 	pushm	r6-r7,lr
800066f4:	18 97       	mov	r7,r12
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
800066f6:	49 b8       	lddpc	r8,80006760 <vTaskPriorityInherit+0x70>
800066f8:	70 08       	ld.w	r8,r8[0x0]
800066fa:	78 b9       	ld.w	r9,r12[0x2c]
800066fc:	70 b8       	ld.w	r8,r8[0x2c]
800066fe:	10 39       	cp.w	r9,r8
80006700:	c2 d2       	brcc	8000675a <vTaskPriorityInherit+0x6a>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
80006702:	49 88       	lddpc	r8,80006760 <vTaskPriorityInherit+0x70>
80006704:	70 08       	ld.w	r8,r8[0x0]
80006706:	70 b8       	ld.w	r8,r8[0x2c]
80006708:	f0 08 11 08 	rsub	r8,r8,8
8000670c:	99 68       	st.w	r12[0x18],r8

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
8000670e:	f2 09 00 28 	add	r8,r9,r9<<0x2
80006712:	49 59       	lddpc	r9,80006764 <vTaskPriorityInherit+0x74>
80006714:	f2 08 00 28 	add	r8,r9,r8<<0x2
80006718:	78 59       	ld.w	r9,r12[0x14]
8000671a:	10 39       	cp.w	r9,r8
8000671c:	c1 b1       	brne	80006752 <vTaskPriorityInherit+0x62>
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
8000671e:	f8 c6 ff fc 	sub	r6,r12,-4
80006722:	0c 9c       	mov	r12,r6
80006724:	f0 1f 00 11 	mcall	80006768 <vTaskPriorityInherit+0x78>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
80006728:	48 e8       	lddpc	r8,80006760 <vTaskPriorityInherit+0x70>
8000672a:	70 08       	ld.w	r8,r8[0x0]
8000672c:	70 bc       	ld.w	r12,r8[0x2c]
8000672e:	8f bc       	st.w	r7[0x2c],r12
				prvAddTaskToReadyQueue( pxTCB );
80006730:	48 f8       	lddpc	r8,8000676c <vTaskPriorityInherit+0x7c>
80006732:	70 08       	ld.w	r8,r8[0x0]
80006734:	10 3c       	cp.w	r12,r8
80006736:	e0 88 00 04 	brls	8000673e <vTaskPriorityInherit+0x4e>
8000673a:	48 d8       	lddpc	r8,8000676c <vTaskPriorityInherit+0x7c>
8000673c:	91 0c       	st.w	r8[0x0],r12
8000673e:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006742:	0c 9b       	mov	r11,r6
80006744:	48 88       	lddpc	r8,80006764 <vTaskPriorityInherit+0x74>
80006746:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
8000674a:	f0 1f 00 0a 	mcall	80006770 <vTaskPriorityInherit+0x80>
8000674e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
80006752:	48 48       	lddpc	r8,80006760 <vTaskPriorityInherit+0x70>
80006754:	70 08       	ld.w	r8,r8[0x0]
80006756:	70 b8       	ld.w	r8,r8[0x2c]
80006758:	99 b8       	st.w	r12[0x2c],r8
8000675a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000675e:	00 00       	add	r0,r0
80006760:	00 00       	add	r0,r0
80006762:	0c f4       	st.b	--r6,r4
80006764:	00 00       	add	r0,r0
80006766:	0c 40       	or	r0,r6
80006768:	80 00       	ld.sh	r0,r0[0x0]
8000676a:	5d 96       	*unknown*
8000676c:	00 00       	add	r0,r0
8000676e:	0d 5c       	ld.sh	r12,--r6
80006770:	80 00       	ld.sh	r0,r0[0x0]
80006772:	5d 46       	*unknown*

80006774 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
80006774:	eb cd 40 c0 	pushm	r6-r7,lr
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
80006778:	78 38       	ld.w	r8,r12[0xc]
8000677a:	70 37       	ld.w	r7,r8[0xc]
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
8000677c:	ee c6 ff e8 	sub	r6,r7,-24
80006780:	0c 9c       	mov	r12,r6
80006782:	f0 1f 00 15 	mcall	800067d4 <xTaskRemoveFromEventList+0x60>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80006786:	49 58       	lddpc	r8,800067d8 <xTaskRemoveFromEventList+0x64>
80006788:	70 08       	ld.w	r8,r8[0x0]
8000678a:	58 08       	cp.w	r8,0
8000678c:	c1 71       	brne	800067ba <xTaskRemoveFromEventList+0x46>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
8000678e:	ee c6 ff fc 	sub	r6,r7,-4
80006792:	0c 9c       	mov	r12,r6
80006794:	f0 1f 00 10 	mcall	800067d4 <xTaskRemoveFromEventList+0x60>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
80006798:	6e bc       	ld.w	r12,r7[0x2c]
8000679a:	49 18       	lddpc	r8,800067dc <xTaskRemoveFromEventList+0x68>
8000679c:	70 08       	ld.w	r8,r8[0x0]
8000679e:	10 3c       	cp.w	r12,r8
800067a0:	e0 88 00 04 	brls	800067a8 <xTaskRemoveFromEventList+0x34>
800067a4:	48 e8       	lddpc	r8,800067dc <xTaskRemoveFromEventList+0x68>
800067a6:	91 0c       	st.w	r8[0x0],r12
800067a8:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800067ac:	0c 9b       	mov	r11,r6
800067ae:	48 d8       	lddpc	r8,800067e0 <xTaskRemoveFromEventList+0x6c>
800067b0:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800067b4:	f0 1f 00 0c 	mcall	800067e4 <xTaskRemoveFromEventList+0x70>
800067b8:	c0 58       	rjmp	800067c2 <xTaskRemoveFromEventList+0x4e>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
800067ba:	0c 9b       	mov	r11,r6
800067bc:	48 bc       	lddpc	r12,800067e8 <xTaskRemoveFromEventList+0x74>
800067be:	f0 1f 00 0a 	mcall	800067e4 <xTaskRemoveFromEventList+0x70>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
800067c2:	48 b8       	lddpc	r8,800067ec <xTaskRemoveFromEventList+0x78>
800067c4:	70 08       	ld.w	r8,r8[0x0]
800067c6:	6e b9       	ld.w	r9,r7[0x2c]
800067c8:	70 b8       	ld.w	r8,r8[0x2c]
800067ca:	10 39       	cp.w	r9,r8
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
800067cc:	5f 2c       	srhs	r12
800067ce:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800067d2:	00 00       	add	r0,r0
800067d4:	80 00       	ld.sh	r0,r0[0x0]
800067d6:	5d 96       	*unknown*
800067d8:	00 00       	add	r0,r0
800067da:	0d 24       	ld.uh	r4,r6++
800067dc:	00 00       	add	r0,r0
800067de:	0d 5c       	ld.sh	r12,--r6
800067e0:	00 00       	add	r0,r0
800067e2:	0c 40       	or	r0,r6
800067e4:	80 00       	ld.sh	r0,r0[0x0]
800067e6:	5d 46       	*unknown*
800067e8:	00 00       	add	r0,r0
800067ea:	0c f8       	st.b	--r6,r8
800067ec:	00 00       	add	r0,r0
800067ee:	0c f4       	st.b	--r6,r4

800067f0 <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
800067f0:	eb cd 40 fc 	pushm	r2-r7,lr
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
800067f4:	4b 98       	lddpc	r8,800068d8 <vTaskIncrementTick+0xe8>
800067f6:	70 08       	ld.w	r8,r8[0x0]
800067f8:	58 08       	cp.w	r8,0
800067fa:	c6 91       	brne	800068cc <vTaskIncrementTick+0xdc>
	{
		++xTickCount;
800067fc:	4b 88       	lddpc	r8,800068dc <vTaskIncrementTick+0xec>
800067fe:	70 09       	ld.w	r9,r8[0x0]
80006800:	2f f9       	sub	r9,-1
80006802:	91 09       	st.w	r8[0x0],r9
		if( xTickCount == ( portTickType ) 0 )
80006804:	70 08       	ld.w	r8,r8[0x0]
80006806:	58 08       	cp.w	r8,0
80006808:	c1 a1       	brne	8000683c <vTaskIncrementTick+0x4c>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
8000680a:	4b 68       	lddpc	r8,800068e0 <vTaskIncrementTick+0xf0>
8000680c:	70 0a       	ld.w	r10,r8[0x0]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
8000680e:	4b 69       	lddpc	r9,800068e4 <vTaskIncrementTick+0xf4>
80006810:	72 0b       	ld.w	r11,r9[0x0]
80006812:	91 0b       	st.w	r8[0x0],r11
			pxOverflowDelayedTaskList = pxTemp;
80006814:	93 0a       	st.w	r9[0x0],r10
			xNumOfOverflows++;
80006816:	4b 59       	lddpc	r9,800068e8 <vTaskIncrementTick+0xf8>
80006818:	72 0a       	ld.w	r10,r9[0x0]
8000681a:	2f fa       	sub	r10,-1
8000681c:	93 0a       	st.w	r9[0x0],r10

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
8000681e:	70 08       	ld.w	r8,r8[0x0]
80006820:	70 08       	ld.w	r8,r8[0x0]
80006822:	58 08       	cp.w	r8,0
80006824:	c0 51       	brne	8000682e <vTaskIncrementTick+0x3e>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
80006826:	3f f9       	mov	r9,-1
80006828:	4b 18       	lddpc	r8,800068ec <vTaskIncrementTick+0xfc>
8000682a:	91 09       	st.w	r8[0x0],r9
8000682c:	c0 88       	rjmp	8000683c <vTaskIncrementTick+0x4c>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
8000682e:	4a d8       	lddpc	r8,800068e0 <vTaskIncrementTick+0xf0>
80006830:	70 08       	ld.w	r8,r8[0x0]
80006832:	70 38       	ld.w	r8,r8[0xc]
80006834:	70 38       	ld.w	r8,r8[0xc]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
80006836:	70 19       	ld.w	r9,r8[0x4]
80006838:	4a d8       	lddpc	r8,800068ec <vTaskIncrementTick+0xfc>
8000683a:	91 09       	st.w	r8[0x0],r9
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
8000683c:	4a 88       	lddpc	r8,800068dc <vTaskIncrementTick+0xec>
8000683e:	70 09       	ld.w	r9,r8[0x0]
80006840:	4a b8       	lddpc	r8,800068ec <vTaskIncrementTick+0xfc>
80006842:	70 08       	ld.w	r8,r8[0x0]
80006844:	10 39       	cp.w	r9,r8
80006846:	c4 73       	brcs	800068d4 <vTaskIncrementTick+0xe4>
80006848:	4a 68       	lddpc	r8,800068e0 <vTaskIncrementTick+0xf0>
8000684a:	70 08       	ld.w	r8,r8[0x0]
8000684c:	70 08       	ld.w	r8,r8[0x0]
8000684e:	58 08       	cp.w	r8,0
80006850:	c0 c0       	breq	80006868 <vTaskIncrementTick+0x78>
80006852:	4a 48       	lddpc	r8,800068e0 <vTaskIncrementTick+0xf0>
80006854:	70 08       	ld.w	r8,r8[0x0]
80006856:	70 38       	ld.w	r8,r8[0xc]
80006858:	70 37       	ld.w	r7,r8[0xc]
8000685a:	6e 18       	ld.w	r8,r7[0x4]
8000685c:	4a 09       	lddpc	r9,800068dc <vTaskIncrementTick+0xec>
8000685e:	72 09       	ld.w	r9,r9[0x0]
80006860:	12 38       	cp.w	r8,r9
80006862:	e0 88 00 14 	brls	8000688a <vTaskIncrementTick+0x9a>
80006866:	c0 e8       	rjmp	80006882 <vTaskIncrementTick+0x92>
80006868:	3f f9       	mov	r9,-1
8000686a:	4a 18       	lddpc	r8,800068ec <vTaskIncrementTick+0xfc>
8000686c:	91 09       	st.w	r8[0x0],r9
8000686e:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80006872:	6a 08       	ld.w	r8,r5[0x0]
80006874:	70 38       	ld.w	r8,r8[0xc]
80006876:	70 37       	ld.w	r7,r8[0xc]
80006878:	6e 18       	ld.w	r8,r7[0x4]
8000687a:	64 09       	ld.w	r9,r2[0x0]
8000687c:	12 38       	cp.w	r8,r9
8000687e:	e0 88 00 0a 	brls	80006892 <vTaskIncrementTick+0xa2>
80006882:	49 b9       	lddpc	r9,800068ec <vTaskIncrementTick+0xfc>
80006884:	93 08       	st.w	r9[0x0],r8
80006886:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
8000688a:	49 a4       	lddpc	r4,800068f0 <vTaskIncrementTick+0x100>
8000688c:	49 a3       	lddpc	r3,800068f4 <vTaskIncrementTick+0x104>
8000688e:	49 55       	lddpc	r5,800068e0 <vTaskIncrementTick+0xf0>
80006890:	49 32       	lddpc	r2,800068dc <vTaskIncrementTick+0xec>
80006892:	ee c6 ff fc 	sub	r6,r7,-4
80006896:	0c 9c       	mov	r12,r6
80006898:	f0 1f 00 18 	mcall	800068f8 <vTaskIncrementTick+0x108>
8000689c:	6e a8       	ld.w	r8,r7[0x28]
8000689e:	58 08       	cp.w	r8,0
800068a0:	c0 50       	breq	800068aa <vTaskIncrementTick+0xba>
800068a2:	ee cc ff e8 	sub	r12,r7,-24
800068a6:	f0 1f 00 15 	mcall	800068f8 <vTaskIncrementTick+0x108>
800068aa:	6e bc       	ld.w	r12,r7[0x2c]
800068ac:	68 08       	ld.w	r8,r4[0x0]
800068ae:	10 3c       	cp.w	r12,r8
800068b0:	e9 fc ba 00 	st.whi	r4[0x0],r12
800068b4:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800068b8:	0c 9b       	mov	r11,r6
800068ba:	e6 0c 00 2c 	add	r12,r3,r12<<0x2
800068be:	f0 1f 00 10 	mcall	800068fc <vTaskIncrementTick+0x10c>
800068c2:	6a 08       	ld.w	r8,r5[0x0]
800068c4:	70 08       	ld.w	r8,r8[0x0]
800068c6:	58 08       	cp.w	r8,0
800068c8:	cd 51       	brne	80006872 <vTaskIncrementTick+0x82>
800068ca:	cc fb       	rjmp	80006868 <vTaskIncrementTick+0x78>
	}
	else
	{
		++uxMissedTicks;
800068cc:	48 d8       	lddpc	r8,80006900 <vTaskIncrementTick+0x110>
800068ce:	70 09       	ld.w	r9,r8[0x0]
800068d0:	2f f9       	sub	r9,-1
800068d2:	91 09       	st.w	r8[0x0],r9
800068d4:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
800068d8:	00 00       	add	r0,r0
800068da:	0d 24       	ld.uh	r4,r6++
800068dc:	00 00       	add	r0,r0
800068de:	0d 20       	ld.uh	r0,r6++
800068e0:	00 00       	add	r0,r0
800068e2:	0c 2c       	rsub	r12,r6
800068e4:	00 00       	add	r0,r0
800068e6:	0c 3c       	cp.w	r12,r6
800068e8:	00 00       	add	r0,r0
800068ea:	0c 38       	cp.w	r8,r6
800068ec:	00 00       	add	r0,r0
800068ee:	05 38       	ld.ub	r8,r2++
800068f0:	00 00       	add	r0,r0
800068f2:	0d 5c       	ld.sh	r12,--r6
800068f4:	00 00       	add	r0,r0
800068f6:	0c 40       	or	r0,r6
800068f8:	80 00       	ld.sh	r0,r0[0x0]
800068fa:	5d 96       	*unknown*
800068fc:	80 00       	ld.sh	r0,r0[0x0]
800068fe:	5d 46       	*unknown*
80006900:	00 00       	add	r0,r0
80006902:	0c 24       	rsub	r4,r6

80006904 <xTaskCheckForTimeOut>:
	pxTimeOut->xTimeOnEntering = xTickCount;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
80006904:	eb cd 40 c0 	pushm	r6-r7,lr
80006908:	18 97       	mov	r7,r12
8000690a:	16 96       	mov	r6,r11
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
8000690c:	f0 1f 00 15 	mcall	80006960 <xTaskCheckForTimeOut+0x5c>
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
80006910:	6c 08       	ld.w	r8,r6[0x0]
80006912:	5b f8       	cp.w	r8,-1
80006914:	c0 31       	brne	8000691a <xTaskCheckForTimeOut+0x16>
80006916:	30 07       	mov	r7,0
80006918:	c1 f8       	rjmp	80006956 <xTaskCheckForTimeOut+0x52>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
8000691a:	49 39       	lddpc	r9,80006964 <xTaskCheckForTimeOut+0x60>
8000691c:	72 09       	ld.w	r9,r9[0x0]
8000691e:	6e 0a       	ld.w	r10,r7[0x0]
80006920:	12 3a       	cp.w	r10,r9
80006922:	c0 70       	breq	80006930 <xTaskCheckForTimeOut+0x2c>
80006924:	49 19       	lddpc	r9,80006968 <xTaskCheckForTimeOut+0x64>
80006926:	72 09       	ld.w	r9,r9[0x0]
80006928:	6e 1a       	ld.w	r10,r7[0x4]
8000692a:	12 3a       	cp.w	r10,r9
8000692c:	e0 88 00 14 	brls	80006954 <xTaskCheckForTimeOut+0x50>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
80006930:	48 e9       	lddpc	r9,80006968 <xTaskCheckForTimeOut+0x64>
80006932:	72 0a       	ld.w	r10,r9[0x0]
80006934:	6e 19       	ld.w	r9,r7[0x4]
80006936:	12 1a       	sub	r10,r9
80006938:	14 38       	cp.w	r8,r10
8000693a:	e0 88 00 0d 	brls	80006954 <xTaskCheckForTimeOut+0x50>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
8000693e:	48 ba       	lddpc	r10,80006968 <xTaskCheckForTimeOut+0x64>
80006940:	74 0a       	ld.w	r10,r10[0x0]
80006942:	14 19       	sub	r9,r10
80006944:	f2 08 00 08 	add	r8,r9,r8
80006948:	8d 08       	st.w	r6[0x0],r8
			vTaskSetTimeOutState( pxTimeOut );
8000694a:	0e 9c       	mov	r12,r7
8000694c:	f0 1f 00 08 	mcall	8000696c <xTaskCheckForTimeOut+0x68>
80006950:	30 07       	mov	r7,0
80006952:	c0 28       	rjmp	80006956 <xTaskCheckForTimeOut+0x52>
80006954:	30 17       	mov	r7,1
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
80006956:	f0 1f 00 07 	mcall	80006970 <xTaskCheckForTimeOut+0x6c>

	return xReturn;
}
8000695a:	0e 9c       	mov	r12,r7
8000695c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006960:	80 00       	ld.sh	r0,r0[0x0]
80006962:	5e 50       	retlt	r0
80006964:	00 00       	add	r0,r0
80006966:	0c 38       	cp.w	r8,r6
80006968:	00 00       	add	r0,r0
8000696a:	0d 20       	ld.uh	r0,r6++
8000696c:	80 00       	ld.sh	r0,r0[0x0]
8000696e:	66 68       	ld.w	r8,r3[0x18]
80006970:	80 00       	ld.sh	r0,r0[0x0]
80006972:	5f 5c       	srlt	r12

80006974 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
80006974:	eb cd 40 80 	pushm	r7,lr
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
80006978:	f0 1f 00 05 	mcall	8000698c <xTaskGetTickCount+0x18>
	{
		xTicks = xTickCount;
8000697c:	48 58       	lddpc	r8,80006990 <xTaskGetTickCount+0x1c>
8000697e:	70 07       	ld.w	r7,r8[0x0]
	}
	taskEXIT_CRITICAL();
80006980:	f0 1f 00 05 	mcall	80006994 <xTaskGetTickCount+0x20>

	return xTicks;
}
80006984:	0e 9c       	mov	r12,r7
80006986:	e3 cd 80 80 	ldm	sp++,r7,pc
8000698a:	00 00       	add	r0,r0
8000698c:	80 00       	ld.sh	r0,r0[0x0]
8000698e:	5e 50       	retlt	r0
80006990:	00 00       	add	r0,r0
80006992:	0d 20       	ld.uh	r0,r6++
80006994:	80 00       	ld.sh	r0,r0[0x0]
80006996:	5f 5c       	srlt	r12

80006998 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
80006998:	eb cd 40 fe 	pushm	r1-r7,lr
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
8000699c:	f0 1f 00 2c 	mcall	80006a4c <xTaskResumeAll+0xb4>
	{
		--uxSchedulerSuspended;
800069a0:	4a c8       	lddpc	r8,80006a50 <xTaskResumeAll+0xb8>
800069a2:	70 09       	ld.w	r9,r8[0x0]
800069a4:	20 19       	sub	r9,1
800069a6:	91 09       	st.w	r8[0x0],r9

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
800069a8:	70 08       	ld.w	r8,r8[0x0]
800069aa:	58 08       	cp.w	r8,0
800069ac:	c4 91       	brne	80006a3e <xTaskResumeAll+0xa6>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
800069ae:	4a a8       	lddpc	r8,80006a54 <xTaskResumeAll+0xbc>
800069b0:	70 08       	ld.w	r8,r8[0x0]
800069b2:	58 08       	cp.w	r8,0
800069b4:	c4 50       	breq	80006a3e <xTaskResumeAll+0xa6>
800069b6:	30 04       	mov	r4,0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
800069b8:	4a 85       	lddpc	r5,80006a58 <xTaskResumeAll+0xc0>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
800069ba:	4a 93       	lddpc	r3,80006a5c <xTaskResumeAll+0xc4>
800069bc:	4a 92       	lddpc	r2,80006a60 <xTaskResumeAll+0xc8>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
800069be:	4a a1       	lddpc	r1,80006a64 <xTaskResumeAll+0xcc>
800069c0:	c1 e8       	rjmp	800069fc <xTaskResumeAll+0x64>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
800069c2:	6a 38       	ld.w	r8,r5[0xc]
800069c4:	70 37       	ld.w	r7,r8[0xc]
					vListRemove( &( pxTCB->xEventListItem ) );
800069c6:	ee cc ff e8 	sub	r12,r7,-24
800069ca:	f0 1f 00 28 	mcall	80006a68 <xTaskResumeAll+0xd0>
					vListRemove( &( pxTCB->xGenericListItem ) );
800069ce:	ee c6 ff fc 	sub	r6,r7,-4
800069d2:	0c 9c       	mov	r12,r6
800069d4:	f0 1f 00 25 	mcall	80006a68 <xTaskResumeAll+0xd0>
					prvAddTaskToReadyQueue( pxTCB );
800069d8:	6e bc       	ld.w	r12,r7[0x2c]
800069da:	66 08       	ld.w	r8,r3[0x0]
800069dc:	10 3c       	cp.w	r12,r8
800069de:	e7 fc ba 00 	st.whi	r3[0x0],r12
800069e2:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800069e6:	0c 9b       	mov	r11,r6
800069e8:	e4 0c 00 2c 	add	r12,r2,r12<<0x2
800069ec:	f0 1f 00 20 	mcall	80006a6c <xTaskResumeAll+0xd4>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
800069f0:	62 08       	ld.w	r8,r1[0x0]
800069f2:	6e b9       	ld.w	r9,r7[0x2c]
800069f4:	70 b8       	ld.w	r8,r8[0x2c]
800069f6:	10 39       	cp.w	r9,r8
800069f8:	f9 b4 02 01 	movhs	r4,1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
800069fc:	6a 08       	ld.w	r8,r5[0x0]
800069fe:	58 08       	cp.w	r8,0
80006a00:	ce 11       	brne	800069c2 <xTaskResumeAll+0x2a>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80006a02:	49 c8       	lddpc	r8,80006a70 <xTaskResumeAll+0xd8>
80006a04:	70 08       	ld.w	r8,r8[0x0]
80006a06:	58 08       	cp.w	r8,0
80006a08:	c0 f0       	breq	80006a26 <xTaskResumeAll+0x8e>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80006a0a:	49 a8       	lddpc	r8,80006a70 <xTaskResumeAll+0xd8>
80006a0c:	70 08       	ld.w	r8,r8[0x0]
80006a0e:	58 08       	cp.w	r8,0
80006a10:	c1 10       	breq	80006a32 <xTaskResumeAll+0x9a>
					{
						vTaskIncrementTick();
						--uxMissedTicks;
80006a12:	49 87       	lddpc	r7,80006a70 <xTaskResumeAll+0xd8>
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
80006a14:	f0 1f 00 18 	mcall	80006a74 <xTaskResumeAll+0xdc>
						--uxMissedTicks;
80006a18:	6e 08       	ld.w	r8,r7[0x0]
80006a1a:	20 18       	sub	r8,1
80006a1c:	8f 08       	st.w	r7[0x0],r8
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80006a1e:	6e 08       	ld.w	r8,r7[0x0]
80006a20:	58 08       	cp.w	r8,0
80006a22:	cf 91       	brne	80006a14 <xTaskResumeAll+0x7c>
80006a24:	c0 78       	rjmp	80006a32 <xTaskResumeAll+0x9a>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
80006a26:	58 14       	cp.w	r4,1
80006a28:	c0 50       	breq	80006a32 <xTaskResumeAll+0x9a>
80006a2a:	49 48       	lddpc	r8,80006a78 <xTaskResumeAll+0xe0>
80006a2c:	70 08       	ld.w	r8,r8[0x0]
80006a2e:	58 18       	cp.w	r8,1
80006a30:	c0 71       	brne	80006a3e <xTaskResumeAll+0xa6>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
80006a32:	30 09       	mov	r9,0
80006a34:	49 18       	lddpc	r8,80006a78 <xTaskResumeAll+0xe0>
80006a36:	91 09       	st.w	r8[0x0],r9
					portYIELD_WITHIN_API();
80006a38:	d7 33       	scall
80006a3a:	30 17       	mov	r7,1
80006a3c:	c0 28       	rjmp	80006a40 <xTaskResumeAll+0xa8>
80006a3e:	30 07       	mov	r7,0
				}
			}
		}
	}
	taskEXIT_CRITICAL();
80006a40:	f0 1f 00 0f 	mcall	80006a7c <xTaskResumeAll+0xe4>

	return xAlreadyYielded;
}
80006a44:	0e 9c       	mov	r12,r7
80006a46:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
80006a4a:	00 00       	add	r0,r0
80006a4c:	80 00       	ld.sh	r0,r0[0x0]
80006a4e:	5e 50       	retlt	r0
80006a50:	00 00       	add	r0,r0
80006a52:	0d 24       	ld.uh	r4,r6++
80006a54:	00 00       	add	r0,r0
80006a56:	0d 40       	ld.w	r0,--r6
80006a58:	00 00       	add	r0,r0
80006a5a:	0c f8       	st.b	--r6,r8
80006a5c:	00 00       	add	r0,r0
80006a5e:	0d 5c       	ld.sh	r12,--r6
80006a60:	00 00       	add	r0,r0
80006a62:	0c 40       	or	r0,r6
80006a64:	00 00       	add	r0,r0
80006a66:	0c f4       	st.b	--r6,r4
80006a68:	80 00       	ld.sh	r0,r0[0x0]
80006a6a:	5d 96       	*unknown*
80006a6c:	80 00       	ld.sh	r0,r0[0x0]
80006a6e:	5d 46       	*unknown*
80006a70:	00 00       	add	r0,r0
80006a72:	0c 24       	rsub	r4,r6
80006a74:	80 00       	ld.sh	r0,r0[0x0]
80006a76:	67 f0       	ld.w	r0,r3[0x7c]
80006a78:	00 00       	add	r0,r0
80006a7a:	0d 44       	ld.w	r4,--r6
80006a7c:	80 00       	ld.sh	r0,r0[0x0]
80006a7e:	5f 5c       	srlt	r12

80006a80 <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
80006a80:	eb cd 40 80 	pushm	r7,lr
80006a84:	18 97       	mov	r7,r12
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
80006a86:	49 08       	lddpc	r8,80006ac4 <prvAddCurrentTaskToDelayedList+0x44>
80006a88:	70 08       	ld.w	r8,r8[0x0]
80006a8a:	91 1c       	st.w	r8[0x4],r12

	if( xTimeToWake < xTickCount )
80006a8c:	48 f8       	lddpc	r8,80006ac8 <prvAddCurrentTaskToDelayedList+0x48>
80006a8e:	70 08       	ld.w	r8,r8[0x0]
80006a90:	10 3c       	cp.w	r12,r8
80006a92:	c0 a2       	brcc	80006aa6 <prvAddCurrentTaskToDelayedList+0x26>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006a94:	48 c8       	lddpc	r8,80006ac4 <prvAddCurrentTaskToDelayedList+0x44>
80006a96:	70 0b       	ld.w	r11,r8[0x0]
80006a98:	48 d8       	lddpc	r8,80006acc <prvAddCurrentTaskToDelayedList+0x4c>
80006a9a:	70 0c       	ld.w	r12,r8[0x0]
80006a9c:	2f cb       	sub	r11,-4
80006a9e:	f0 1f 00 0d 	mcall	80006ad0 <prvAddCurrentTaskToDelayedList+0x50>
80006aa2:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006aa6:	48 88       	lddpc	r8,80006ac4 <prvAddCurrentTaskToDelayedList+0x44>
80006aa8:	70 0b       	ld.w	r11,r8[0x0]
80006aaa:	48 b8       	lddpc	r8,80006ad4 <prvAddCurrentTaskToDelayedList+0x54>
80006aac:	70 0c       	ld.w	r12,r8[0x0]
80006aae:	2f cb       	sub	r11,-4
80006ab0:	f0 1f 00 08 	mcall	80006ad0 <prvAddCurrentTaskToDelayedList+0x50>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
80006ab4:	48 98       	lddpc	r8,80006ad8 <prvAddCurrentTaskToDelayedList+0x58>
80006ab6:	70 08       	ld.w	r8,r8[0x0]
80006ab8:	10 37       	cp.w	r7,r8
80006aba:	c0 32       	brcc	80006ac0 <prvAddCurrentTaskToDelayedList+0x40>
		{
			xNextTaskUnblockTime = xTimeToWake;
80006abc:	48 78       	lddpc	r8,80006ad8 <prvAddCurrentTaskToDelayedList+0x58>
80006abe:	91 07       	st.w	r8[0x0],r7
80006ac0:	e3 cd 80 80 	ldm	sp++,r7,pc
80006ac4:	00 00       	add	r0,r0
80006ac6:	0c f4       	st.b	--r6,r4
80006ac8:	00 00       	add	r0,r0
80006aca:	0d 20       	ld.uh	r0,r6++
80006acc:	00 00       	add	r0,r0
80006ace:	0c 3c       	cp.w	r12,r6
80006ad0:	80 00       	ld.sh	r0,r0[0x0]
80006ad2:	5d 62       	*unknown*
80006ad4:	00 00       	add	r0,r0
80006ad6:	0c 2c       	rsub	r12,r6
80006ad8:	00 00       	add	r0,r0
80006ada:	05 38       	ld.ub	r8,r2++

80006adc <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
80006adc:	eb cd 40 c0 	pushm	r6-r7,lr
80006ae0:	18 97       	mov	r7,r12
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0 )
80006ae2:	58 0c       	cp.w	r12,0
80006ae4:	c1 10       	breq	80006b06 <vTaskDelay+0x2a>
		{
			vTaskSuspendAll();
80006ae6:	f0 1f 00 0a 	mcall	80006b0c <vTaskDelay+0x30>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
80006aea:	48 a8       	lddpc	r8,80006b10 <vTaskDelay+0x34>
80006aec:	70 06       	ld.w	r6,r8[0x0]

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006aee:	48 a8       	lddpc	r8,80006b14 <vTaskDelay+0x38>
80006af0:	70 0c       	ld.w	r12,r8[0x0]
80006af2:	2f cc       	sub	r12,-4
80006af4:	f0 1f 00 09 	mcall	80006b18 <vTaskDelay+0x3c>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
80006af8:	ee 06 00 0c 	add	r12,r7,r6
80006afc:	f0 1f 00 08 	mcall	80006b1c <vTaskDelay+0x40>
			}
			xAlreadyYielded = xTaskResumeAll();
80006b00:	f0 1f 00 08 	mcall	80006b20 <vTaskDelay+0x44>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
80006b04:	c0 21       	brne	80006b08 <vTaskDelay+0x2c>
		{
			portYIELD_WITHIN_API();
80006b06:	d7 33       	scall
80006b08:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006b0c:	80 00       	ld.sh	r0,r0[0x0]
80006b0e:	65 dc       	ld.w	r12,r2[0x74]
80006b10:	00 00       	add	r0,r0
80006b12:	0d 20       	ld.uh	r0,r6++
80006b14:	00 00       	add	r0,r0
80006b16:	0c f4       	st.b	--r6,r4
80006b18:	80 00       	ld.sh	r0,r0[0x0]
80006b1a:	5d 96       	*unknown*
80006b1c:	80 00       	ld.sh	r0,r0[0x0]
80006b1e:	6a 80       	ld.w	r0,r5[0x20]
80006b20:	80 00       	ld.sh	r0,r0[0x0]
80006b22:	69 98       	ld.w	r8,r4[0x64]

80006b24 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
80006b24:	eb cd 40 c0 	pushm	r6-r7,lr
80006b28:	18 96       	mov	r6,r12
80006b2a:	16 97       	mov	r7,r11
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0 ) );

		vTaskSuspendAll();
80006b2c:	f0 1f 00 18 	mcall	80006b8c <vTaskDelayUntil+0x68>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
80006b30:	6c 08       	ld.w	r8,r6[0x0]
80006b32:	10 07       	add	r7,r8

			if( xTickCount < *pxPreviousWakeTime )
80006b34:	49 79       	lddpc	r9,80006b90 <vTaskDelayUntil+0x6c>
80006b36:	72 09       	ld.w	r9,r9[0x0]
80006b38:	12 38       	cp.w	r8,r9
80006b3a:	e0 88 00 0c 	brls	80006b52 <vTaskDelayUntil+0x2e>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
80006b3e:	0e 38       	cp.w	r8,r7
80006b40:	e0 88 00 22 	brls	80006b84 <vTaskDelayUntil+0x60>
80006b44:	49 38       	lddpc	r8,80006b90 <vTaskDelayUntil+0x6c>
80006b46:	70 08       	ld.w	r8,r8[0x0]
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80006b48:	8d 07       	st.w	r6[0x0],r7

			if( xShouldDelay != pdFALSE )
80006b4a:	10 37       	cp.w	r7,r8
80006b4c:	e0 88 00 14 	brls	80006b74 <vTaskDelayUntil+0x50>
80006b50:	c0 a8       	rjmp	80006b64 <vTaskDelayUntil+0x40>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
80006b52:	0e 38       	cp.w	r8,r7
80006b54:	e0 8b 00 16 	brhi	80006b80 <vTaskDelayUntil+0x5c>
80006b58:	48 e8       	lddpc	r8,80006b90 <vTaskDelayUntil+0x6c>
80006b5a:	70 08       	ld.w	r8,r8[0x0]
80006b5c:	10 37       	cp.w	r7,r8
80006b5e:	e0 8b 00 11 	brhi	80006b80 <vTaskDelayUntil+0x5c>
80006b62:	c1 18       	rjmp	80006b84 <vTaskDelayUntil+0x60>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006b64:	48 c8       	lddpc	r8,80006b94 <vTaskDelayUntil+0x70>
80006b66:	70 0c       	ld.w	r12,r8[0x0]
80006b68:	2f cc       	sub	r12,-4
80006b6a:	f0 1f 00 0c 	mcall	80006b98 <vTaskDelayUntil+0x74>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
80006b6e:	0e 9c       	mov	r12,r7
80006b70:	f0 1f 00 0b 	mcall	80006b9c <vTaskDelayUntil+0x78>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
80006b74:	f0 1f 00 0b 	mcall	80006ba0 <vTaskDelayUntil+0x7c>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
80006b78:	c0 81       	brne	80006b88 <vTaskDelayUntil+0x64>
		{
			portYIELD_WITHIN_API();
80006b7a:	d7 33       	scall
80006b7c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80006b80:	8d 07       	st.w	r6[0x0],r7
80006b82:	cf 1b       	rjmp	80006b64 <vTaskDelayUntil+0x40>
80006b84:	8d 07       	st.w	r6[0x0],r7
80006b86:	cf 7b       	rjmp	80006b74 <vTaskDelayUntil+0x50>
80006b88:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006b8c:	80 00       	ld.sh	r0,r0[0x0]
80006b8e:	65 dc       	ld.w	r12,r2[0x74]
80006b90:	00 00       	add	r0,r0
80006b92:	0d 20       	ld.uh	r0,r6++
80006b94:	00 00       	add	r0,r0
80006b96:	0c f4       	st.b	--r6,r4
80006b98:	80 00       	ld.sh	r0,r0[0x0]
80006b9a:	5d 96       	*unknown*
80006b9c:	80 00       	ld.sh	r0,r0[0x0]
80006b9e:	6a 80       	ld.w	r0,r5[0x20]
80006ba0:	80 00       	ld.sh	r0,r0[0x0]
80006ba2:	69 98       	ld.w	r8,r4[0x64]

80006ba4 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
80006ba4:	eb cd 40 c0 	pushm	r6-r7,lr
80006ba8:	16 96       	mov	r6,r11
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
80006baa:	48 e7       	lddpc	r7,80006be0 <vTaskPlaceOnEventList+0x3c>
80006bac:	6e 0b       	ld.w	r11,r7[0x0]
80006bae:	2e 8b       	sub	r11,-24
80006bb0:	f0 1f 00 0d 	mcall	80006be4 <vTaskPlaceOnEventList+0x40>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006bb4:	6e 0c       	ld.w	r12,r7[0x0]
80006bb6:	2f cc       	sub	r12,-4
80006bb8:	f0 1f 00 0c 	mcall	80006be8 <vTaskPlaceOnEventList+0x44>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
80006bbc:	5b f6       	cp.w	r6,-1
80006bbe:	c0 81       	brne	80006bce <vTaskPlaceOnEventList+0x2a>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006bc0:	6e 0b       	ld.w	r11,r7[0x0]
80006bc2:	2f cb       	sub	r11,-4
80006bc4:	48 ac       	lddpc	r12,80006bec <vTaskPlaceOnEventList+0x48>
80006bc6:	f0 1f 00 0b 	mcall	80006bf0 <vTaskPlaceOnEventList+0x4c>
80006bca:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
80006bce:	48 a8       	lddpc	r8,80006bf4 <vTaskPlaceOnEventList+0x50>
80006bd0:	70 0c       	ld.w	r12,r8[0x0]
			prvAddCurrentTaskToDelayedList( xTimeToWake );
80006bd2:	ec 0c 00 0c 	add	r12,r6,r12
80006bd6:	f0 1f 00 09 	mcall	80006bf8 <vTaskPlaceOnEventList+0x54>
80006bda:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006bde:	00 00       	add	r0,r0
80006be0:	00 00       	add	r0,r0
80006be2:	0c f4       	st.b	--r6,r4
80006be4:	80 00       	ld.sh	r0,r0[0x0]
80006be6:	5d 62       	*unknown*
80006be8:	80 00       	ld.sh	r0,r0[0x0]
80006bea:	5d 96       	*unknown*
80006bec:	00 00       	add	r0,r0
80006bee:	0d 48       	ld.w	r8,--r6
80006bf0:	80 00       	ld.sh	r0,r0[0x0]
80006bf2:	5d 46       	*unknown*
80006bf4:	00 00       	add	r0,r0
80006bf6:	0d 20       	ld.uh	r0,r6++
80006bf8:	80 00       	ld.sh	r0,r0[0x0]
80006bfa:	6a 80       	ld.w	r0,r5[0x20]

80006bfc <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
80006bfc:	eb cd 40 f8 	pushm	r3-r7,lr
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80006c00:	49 67       	lddpc	r7,80006c58 <prvIdleTask+0x5c>
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
80006c02:	49 74       	lddpc	r4,80006c5c <prvIdleTask+0x60>

				taskENTER_CRITICAL();
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					--uxCurrentNumberOfTasks;
80006c04:	49 73       	lddpc	r3,80006c60 <prvIdleTask+0x64>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80006c06:	49 85       	lddpc	r5,80006c64 <prvIdleTask+0x68>
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80006c08:	6e 08       	ld.w	r8,r7[0x0]
80006c0a:	58 08       	cp.w	r8,0
80006c0c:	c1 e0       	breq	80006c48 <prvIdleTask+0x4c>
		{
			vTaskSuspendAll();
80006c0e:	f0 1f 00 17 	mcall	80006c68 <prvIdleTask+0x6c>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
80006c12:	68 06       	ld.w	r6,r4[0x0]
			xTaskResumeAll();
80006c14:	f0 1f 00 16 	mcall	80006c6c <prvIdleTask+0x70>

			if( xListIsEmpty == pdFALSE )
80006c18:	58 06       	cp.w	r6,0
80006c1a:	c1 70       	breq	80006c48 <prvIdleTask+0x4c>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
80006c1c:	f0 1f 00 15 	mcall	80006c70 <prvIdleTask+0x74>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
80006c20:	68 38       	ld.w	r8,r4[0xc]
80006c22:	70 36       	ld.w	r6,r8[0xc]
					vListRemove( &( pxTCB->xGenericListItem ) );
80006c24:	ec cc ff fc 	sub	r12,r6,-4
80006c28:	f0 1f 00 13 	mcall	80006c74 <prvIdleTask+0x78>
					--uxCurrentNumberOfTasks;
80006c2c:	66 08       	ld.w	r8,r3[0x0]
80006c2e:	20 18       	sub	r8,1
80006c30:	87 08       	st.w	r3[0x0],r8
					--uxTasksDeleted;
80006c32:	6e 08       	ld.w	r8,r7[0x0]
80006c34:	20 18       	sub	r8,1
80006c36:	8f 08       	st.w	r7[0x0],r8
				}
				taskEXIT_CRITICAL();
80006c38:	f0 1f 00 10 	mcall	80006c78 <prvIdleTask+0x7c>

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
80006c3c:	6c cc       	ld.w	r12,r6[0x30]
80006c3e:	f0 1f 00 10 	mcall	80006c7c <prvIdleTask+0x80>
		vPortFree( pxTCB );
80006c42:	0c 9c       	mov	r12,r6
80006c44:	f0 1f 00 0e 	mcall	80006c7c <prvIdleTask+0x80>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80006c48:	6a 08       	ld.w	r8,r5[0x0]
80006c4a:	58 18       	cp.w	r8,1
80006c4c:	e0 88 00 03 	brls	80006c52 <prvIdleTask+0x56>
			{
				taskYIELD();
80006c50:	d7 33       	scall
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
80006c52:	f0 1f 00 0c 	mcall	80006c80 <prvIdleTask+0x84>
		}
		#endif
	}
80006c56:	cd 9b       	rjmp	80006c08 <prvIdleTask+0xc>
80006c58:	00 00       	add	r0,r0
80006c5a:	0c 34       	cp.w	r4,r6
80006c5c:	00 00       	add	r0,r0
80006c5e:	0c e0       	st.h	--r6,r0
80006c60:	00 00       	add	r0,r0
80006c62:	0d 40       	ld.w	r0,--r6
80006c64:	00 00       	add	r0,r0
80006c66:	0c 40       	or	r0,r6
80006c68:	80 00       	ld.sh	r0,r0[0x0]
80006c6a:	65 dc       	ld.w	r12,r2[0x74]
80006c6c:	80 00       	ld.sh	r0,r0[0x0]
80006c6e:	69 98       	ld.w	r8,r4[0x64]
80006c70:	80 00       	ld.sh	r0,r0[0x0]
80006c72:	5e 50       	retlt	r0
80006c74:	80 00       	ld.sh	r0,r0[0x0]
80006c76:	5d 96       	*unknown*
80006c78:	80 00       	ld.sh	r0,r0[0x0]
80006c7a:	5f 5c       	srlt	r12
80006c7c:	80 00       	ld.sh	r0,r0[0x0]
80006c7e:	60 94       	ld.w	r4,r0[0x24]
80006c80:	80 00       	ld.sh	r0,r0[0x0]
80006c82:	20 48       	sub	r8,4

80006c84 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
80006c84:	d4 31       	pushm	r0-r7,lr
80006c86:	20 1d       	sub	sp,4
80006c88:	fa c4 ff d8 	sub	r4,sp,-40
80006c8c:	50 0c       	stdsp	sp[0x0],r12
80006c8e:	16 91       	mov	r1,r11
80006c90:	14 97       	mov	r7,r10
80006c92:	12 90       	mov	r0,r9
80006c94:	10 93       	mov	r3,r8
80006c96:	68 02       	ld.w	r2,r4[0x0]
80006c98:	68 16       	ld.w	r6,r4[0x4]
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
80006c9a:	34 8c       	mov	r12,72
80006c9c:	f0 1f 00 5c 	mcall	80006e0c <xTaskGenericCreate+0x188>
80006ca0:	18 95       	mov	r5,r12

	if( pxNewTCB != NULL )
80006ca2:	c0 31       	brne	80006ca8 <xTaskGenericCreate+0x24>
80006ca4:	3f fc       	mov	r12,-1
80006ca6:	ca f8       	rjmp	80006e04 <xTaskGenericCreate+0x180>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80006ca8:	58 06       	cp.w	r6,0
80006caa:	e0 81 00 af 	brne	80006e08 <xTaskGenericCreate+0x184>
80006cae:	0e 9c       	mov	r12,r7
80006cb0:	5c 7c       	castu.h	r12
80006cb2:	a3 6c       	lsl	r12,0x2
80006cb4:	f0 1f 00 56 	mcall	80006e0c <xTaskGenericCreate+0x188>
80006cb8:	18 96       	mov	r6,r12
80006cba:	8b cc       	st.w	r5[0x30],r12

		if( pxNewTCB->pxStack == NULL )
80006cbc:	c0 61       	brne	80006cc8 <xTaskGenericCreate+0x44>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
80006cbe:	0a 9c       	mov	r12,r5
80006cc0:	f0 1f 00 54 	mcall	80006e10 <xTaskGenericCreate+0x18c>
80006cc4:	3f fc       	mov	r12,-1
80006cc6:	c9 f8       	rjmp	80006e04 <xTaskGenericCreate+0x180>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
80006cc8:	5c 77       	castu.h	r7
80006cca:	ee 0a 15 02 	lsl	r10,r7,0x2
80006cce:	e0 6b 00 a5 	mov	r11,165
80006cd2:	0c 9c       	mov	r12,r6
80006cd4:	f0 1f 00 50 	mcall	80006e14 <xTaskGenericCreate+0x190>
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~portBYTE_ALIGNMENT_MASK  ) );
80006cd8:	ee c6 00 01 	sub	r6,r7,1
80006cdc:	6a c8       	ld.w	r8,r5[0x30]
80006cde:	f0 06 00 26 	add	r6,r8,r6<<0x2
80006ce2:	e0 16 ff fc 	andl	r6,0xfffc
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
80006ce6:	31 0a       	mov	r10,16
80006ce8:	02 9b       	mov	r11,r1
80006cea:	ea cc ff cc 	sub	r12,r5,-52
80006cee:	f0 1f 00 4b 	mcall	80006e18 <xTaskGenericCreate+0x194>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
80006cf2:	30 08       	mov	r8,0
80006cf4:	eb 68 00 43 	st.b	r5[67],r8
80006cf8:	58 73       	cp.w	r3,7
80006cfa:	e6 07 17 80 	movls	r7,r3
80006cfe:	f9 b7 0b 07 	movhi	r7,7
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
80006d02:	8b b7       	st.w	r5[0x2c],r7
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
80006d04:	eb 47 00 44 	st.w	r5[68],r7
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
80006d08:	ea c4 ff fc 	sub	r4,r5,-4
80006d0c:	08 9c       	mov	r12,r4
80006d0e:	f0 1f 00 44 	mcall	80006e1c <xTaskGenericCreate+0x198>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
80006d12:	ea cc ff e8 	sub	r12,r5,-24
80006d16:	f0 1f 00 42 	mcall	80006e1c <xTaskGenericCreate+0x198>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
80006d1a:	8b 45       	st.w	r5[0x10],r5

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
80006d1c:	ee 07 11 08 	rsub	r7,r7,8
80006d20:	8b 67       	st.w	r5[0x18],r7
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
80006d22:	8b 95       	st.w	r5[0x24],r5
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
80006d24:	00 9a       	mov	r10,r0
80006d26:	40 0b       	lddsp	r11,sp[0x0]
80006d28:	0c 9c       	mov	r12,r6
80006d2a:	f0 1f 00 3e 	mcall	80006e20 <xTaskGenericCreate+0x19c>
80006d2e:	8b 0c       	st.w	r5[0x0],r12
		if( ( void * ) pxCreatedTask != NULL )
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
80006d30:	58 02       	cp.w	r2,0
80006d32:	e5 f5 1a 00 	st.wne	r2[0x0],r5
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
80006d36:	f0 1f 00 3c 	mcall	80006e24 <xTaskGenericCreate+0x1a0>
		{
			uxCurrentNumberOfTasks++;
80006d3a:	4b c8       	lddpc	r8,80006e28 <xTaskGenericCreate+0x1a4>
80006d3c:	70 09       	ld.w	r9,r8[0x0]
80006d3e:	2f f9       	sub	r9,-1
80006d40:	91 09       	st.w	r8[0x0],r9
			if( pxCurrentTCB == NULL )
80006d42:	4b b8       	lddpc	r8,80006e2c <xTaskGenericCreate+0x1a8>
80006d44:	70 08       	ld.w	r8,r8[0x0]
80006d46:	58 08       	cp.w	r8,0
80006d48:	c2 61       	brne	80006d94 <xTaskGenericCreate+0x110>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
80006d4a:	4b 98       	lddpc	r8,80006e2c <xTaskGenericCreate+0x1a8>
80006d4c:	91 05       	st.w	r8[0x0],r5

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
80006d4e:	4b 78       	lddpc	r8,80006e28 <xTaskGenericCreate+0x1a4>
80006d50:	70 08       	ld.w	r8,r8[0x0]
80006d52:	58 18       	cp.w	r8,1
80006d54:	c2 b1       	brne	80006daa <xTaskGenericCreate+0x126>
80006d56:	4b 77       	lddpc	r7,80006e30 <xTaskGenericCreate+0x1ac>

/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
80006d58:	ee c6 ff 60 	sub	r6,r7,-160
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
80006d5c:	0e 9c       	mov	r12,r7
80006d5e:	f0 1f 00 36 	mcall	80006e34 <xTaskGenericCreate+0x1b0>
80006d62:	2e c7       	sub	r7,-20

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
80006d64:	0c 37       	cp.w	r7,r6
80006d66:	cf b1       	brne	80006d5c <xTaskGenericCreate+0xd8>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
80006d68:	4b 47       	lddpc	r7,80006e38 <xTaskGenericCreate+0x1b4>
80006d6a:	0e 9c       	mov	r12,r7
80006d6c:	f0 1f 00 32 	mcall	80006e34 <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
80006d70:	4b 36       	lddpc	r6,80006e3c <xTaskGenericCreate+0x1b8>
80006d72:	0c 9c       	mov	r12,r6
80006d74:	f0 1f 00 30 	mcall	80006e34 <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xPendingReadyList );
80006d78:	4b 2c       	lddpc	r12,80006e40 <xTaskGenericCreate+0x1bc>
80006d7a:	f0 1f 00 2f 	mcall	80006e34 <xTaskGenericCreate+0x1b0>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
80006d7e:	4b 2c       	lddpc	r12,80006e44 <xTaskGenericCreate+0x1c0>
80006d80:	f0 1f 00 2d 	mcall	80006e34 <xTaskGenericCreate+0x1b0>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
80006d84:	4b 1c       	lddpc	r12,80006e48 <xTaskGenericCreate+0x1c4>
80006d86:	f0 1f 00 2c 	mcall	80006e34 <xTaskGenericCreate+0x1b0>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
80006d8a:	4b 18       	lddpc	r8,80006e4c <xTaskGenericCreate+0x1c8>
80006d8c:	91 07       	st.w	r8[0x0],r7
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
80006d8e:	4b 18       	lddpc	r8,80006e50 <xTaskGenericCreate+0x1cc>
80006d90:	91 06       	st.w	r8[0x0],r6
80006d92:	c0 c8       	rjmp	80006daa <xTaskGenericCreate+0x126>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
80006d94:	4b 08       	lddpc	r8,80006e54 <xTaskGenericCreate+0x1d0>
80006d96:	70 08       	ld.w	r8,r8[0x0]
80006d98:	58 08       	cp.w	r8,0
80006d9a:	c0 81       	brne	80006daa <xTaskGenericCreate+0x126>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
80006d9c:	4a 48       	lddpc	r8,80006e2c <xTaskGenericCreate+0x1a8>
80006d9e:	70 08       	ld.w	r8,r8[0x0]
80006da0:	70 b8       	ld.w	r8,r8[0x2c]
80006da2:	10 33       	cp.w	r3,r8
80006da4:	c0 33       	brcs	80006daa <xTaskGenericCreate+0x126>
					{
						pxCurrentTCB = pxNewTCB;
80006da6:	4a 28       	lddpc	r8,80006e2c <xTaskGenericCreate+0x1a8>
80006da8:	91 05       	st.w	r8[0x0],r5
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
80006daa:	6a b8       	ld.w	r8,r5[0x2c]
80006dac:	4a b9       	lddpc	r9,80006e58 <xTaskGenericCreate+0x1d4>
80006dae:	72 09       	ld.w	r9,r9[0x0]
80006db0:	12 38       	cp.w	r8,r9
80006db2:	e0 88 00 04 	brls	80006dba <xTaskGenericCreate+0x136>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
80006db6:	4a 99       	lddpc	r9,80006e58 <xTaskGenericCreate+0x1d4>
80006db8:	93 08       	st.w	r9[0x0],r8
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
80006dba:	4a 98       	lddpc	r8,80006e5c <xTaskGenericCreate+0x1d8>
80006dbc:	70 09       	ld.w	r9,r8[0x0]
80006dbe:	2f f9       	sub	r9,-1
80006dc0:	91 09       	st.w	r8[0x0],r9

			prvAddTaskToReadyQueue( pxNewTCB );
80006dc2:	6a b8       	ld.w	r8,r5[0x2c]
80006dc4:	4a 79       	lddpc	r9,80006e60 <xTaskGenericCreate+0x1dc>
80006dc6:	72 09       	ld.w	r9,r9[0x0]
80006dc8:	12 38       	cp.w	r8,r9
80006dca:	e0 88 00 04 	brls	80006dd2 <xTaskGenericCreate+0x14e>
80006dce:	4a 59       	lddpc	r9,80006e60 <xTaskGenericCreate+0x1dc>
80006dd0:	93 08       	st.w	r9[0x0],r8
80006dd2:	6a bc       	ld.w	r12,r5[0x2c]
80006dd4:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006dd8:	08 9b       	mov	r11,r4
80006dda:	49 68       	lddpc	r8,80006e30 <xTaskGenericCreate+0x1ac>
80006ddc:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80006de0:	f0 1f 00 21 	mcall	80006e64 <xTaskGenericCreate+0x1e0>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
80006de4:	f0 1f 00 21 	mcall	80006e68 <xTaskGenericCreate+0x1e4>
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
80006de8:	49 b8       	lddpc	r8,80006e54 <xTaskGenericCreate+0x1d0>
80006dea:	70 08       	ld.w	r8,r8[0x0]
80006dec:	58 08       	cp.w	r8,0
80006dee:	c0 a0       	breq	80006e02 <xTaskGenericCreate+0x17e>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
80006df0:	48 f8       	lddpc	r8,80006e2c <xTaskGenericCreate+0x1a8>
80006df2:	70 08       	ld.w	r8,r8[0x0]
80006df4:	70 b8       	ld.w	r8,r8[0x2c]
80006df6:	10 33       	cp.w	r3,r8
80006df8:	e0 88 00 05 	brls	80006e02 <xTaskGenericCreate+0x17e>
			{
				portYIELD_WITHIN_API();
80006dfc:	d7 33       	scall
80006dfe:	30 1c       	mov	r12,1
80006e00:	c0 28       	rjmp	80006e04 <xTaskGenericCreate+0x180>
80006e02:	30 1c       	mov	r12,1
			}
		}
	}

	return xReturn;
}
80006e04:	2f fd       	sub	sp,-4
80006e06:	d8 32       	popm	r0-r7,pc
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80006e08:	99 c6       	st.w	r12[0x30],r6
80006e0a:	c5 fb       	rjmp	80006cc8 <xTaskGenericCreate+0x44>
80006e0c:	80 00       	ld.sh	r0,r0[0x0]
80006e0e:	60 bc       	ld.w	r12,r0[0x2c]
80006e10:	80 00       	ld.sh	r0,r0[0x0]
80006e12:	60 94       	ld.w	r4,r0[0x24]
80006e14:	80 00       	ld.sh	r0,r0[0x0]
80006e16:	7a 0c       	ld.w	r12,sp[0x0]
80006e18:	80 00       	ld.sh	r0,r0[0x0]
80006e1a:	7d 38       	ld.w	r8,lr[0x4c]
80006e1c:	80 00       	ld.sh	r0,r0[0x0]
80006e1e:	5d 40       	*unknown*
80006e20:	80 00       	ld.sh	r0,r0[0x0]
80006e22:	5d bc       	*unknown*
80006e24:	80 00       	ld.sh	r0,r0[0x0]
80006e26:	5e 50       	retlt	r0
80006e28:	00 00       	add	r0,r0
80006e2a:	0d 40       	ld.w	r0,--r6
80006e2c:	00 00       	add	r0,r0
80006e2e:	0c f4       	st.b	--r6,r4
80006e30:	00 00       	add	r0,r0
80006e32:	0c 40       	or	r0,r6
80006e34:	80 00       	ld.sh	r0,r0[0x0]
80006e36:	5d 2c       	mustr	r12
80006e38:	00 00       	add	r0,r0
80006e3a:	0d 0c       	ld.w	r12,r6++
80006e3c:	00 00       	add	r0,r0
80006e3e:	0d 28       	ld.uh	r8,r6++
80006e40:	00 00       	add	r0,r0
80006e42:	0c f8       	st.b	--r6,r8
80006e44:	00 00       	add	r0,r0
80006e46:	0c e0       	st.h	--r6,r0
80006e48:	00 00       	add	r0,r0
80006e4a:	0d 48       	ld.w	r8,--r6
80006e4c:	00 00       	add	r0,r0
80006e4e:	0c 2c       	rsub	r12,r6
80006e50:	00 00       	add	r0,r0
80006e52:	0c 3c       	cp.w	r12,r6
80006e54:	00 00       	add	r0,r0
80006e56:	0c 30       	cp.w	r0,r6
80006e58:	00 00       	add	r0,r0
80006e5a:	0c 28       	rsub	r8,r6
80006e5c:	00 00       	add	r0,r0
80006e5e:	0d 3c       	ld.ub	r12,r6++
80006e60:	00 00       	add	r0,r0
80006e62:	0d 5c       	ld.sh	r12,--r6
80006e64:	80 00       	ld.sh	r0,r0[0x0]
80006e66:	5d 46       	*unknown*
80006e68:	80 00       	ld.sh	r0,r0[0x0]
80006e6a:	5f 5c       	srlt	r12

80006e6c <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
80006e6c:	d4 01       	pushm	lr
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
80006e6e:	30 09       	mov	r9,0
80006e70:	1a d9       	st.w	--sp,r9
80006e72:	1a d9       	st.w	--sp,r9
80006e74:	1a d9       	st.w	--sp,r9
80006e76:	12 98       	mov	r8,r9
80006e78:	e0 6a 01 00 	mov	r10,256
80006e7c:	48 9b       	lddpc	r11,80006ea0 <vTaskStartScheduler+0x34>
80006e7e:	48 ac       	lddpc	r12,80006ea4 <vTaskStartScheduler+0x38>
80006e80:	f0 1f 00 0a 	mcall	80006ea8 <vTaskStartScheduler+0x3c>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
80006e84:	2f dd       	sub	sp,-12
80006e86:	58 1c       	cp.w	r12,1
80006e88:	c0 a1       	brne	80006e9c <vTaskStartScheduler+0x30>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
80006e8a:	d3 03       	ssrf	0x10

		xSchedulerRunning = pdTRUE;
80006e8c:	30 19       	mov	r9,1
80006e8e:	48 88       	lddpc	r8,80006eac <vTaskStartScheduler+0x40>
80006e90:	91 09       	st.w	r8[0x0],r9
		xTickCount = ( portTickType ) 0;
80006e92:	30 09       	mov	r9,0
80006e94:	48 78       	lddpc	r8,80006eb0 <vTaskStartScheduler+0x44>
80006e96:	91 09       	st.w	r8[0x0],r9
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
80006e98:	f0 1f 00 07 	mcall	80006eb4 <vTaskStartScheduler+0x48>
80006e9c:	d8 02       	popm	pc
80006e9e:	00 00       	add	r0,r0
80006ea0:	80 00       	ld.sh	r0,r0[0x0]
80006ea2:	da 30       	acall	0xa3
80006ea4:	80 00       	ld.sh	r0,r0[0x0]
80006ea6:	6b fc       	ld.w	r12,r5[0x7c]
80006ea8:	80 00       	ld.sh	r0,r0[0x0]
80006eaa:	6c 84       	ld.w	r4,r6[0x20]
80006eac:	00 00       	add	r0,r0
80006eae:	0c 30       	cp.w	r0,r6
80006eb0:	00 00       	add	r0,r0
80006eb2:	0d 20       	ld.uh	r0,r6++
80006eb4:	80 00       	ld.sh	r0,r0[0x0]
80006eb6:	5e 60       	retmi	r0

80006eb8 <PrintChar>:
	
static void task_log(void * pvParameters);

char *  PrintChar(char c, char * str)
{
	*str++ = c;
80006eb8:	16 cc       	st.b	r11++,r12
	return str;
}
80006eba:	5e fb       	retal	r11

80006ebc <PrintHex>:
	
	return str;
}

char * PrintHex(int i,char len, char * str)
{
80006ebc:	eb cd 40 c0 	pushm	r6-r7,lr
80006ec0:	20 3d       	sub	sp,12
80006ec2:	18 98       	mov	r8,r12
	char * p = str;
	char s[12];
	memset(s, 0 , 12);
80006ec4:	30 06       	mov	r6,0
80006ec6:	30 07       	mov	r7,0
80006ec8:	fa e7 00 00 	st.d	sp[0],r6
80006ecc:	30 0c       	mov	r12,0
80006ece:	50 2c       	stdsp	sp[0x8],r12
	int cnt=0;
	
	if(i)
80006ed0:	58 08       	cp.w	r8,0
80006ed2:	c1 30       	breq	80006ef8 <PrintHex+0x3c>
80006ed4:	18 99       	mov	r9,r12
	while(i)
	{
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
80006ed6:	1a 9c       	mov	r12,sp
80006ed8:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80006edc:	58 9e       	cp.w	lr,9
80006ede:	e0 8a 00 04 	brle	80006ee6 <PrintHex+0x2a>
80006ee2:	2c 9e       	sub	lr,-55
80006ee4:	c0 48       	rjmp	80006eec <PrintHex+0x30>
80006ee6:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80006eea:	2d 0e       	sub	lr,-48
80006eec:	f8 09 0b 0e 	st.b	r12[r9],lr
80006ef0:	2f f9       	sub	r9,-1
		i = (i >> 4 ) & 0x0FFFFFFF;
80006ef2:	a5 88       	lsr	r8,0x4
	char s[12];
	memset(s, 0 , 12);
	int cnt=0;
	
	if(i)
	while(i)
80006ef4:	cf 21       	brne	80006ed8 <PrintHex+0x1c>
80006ef6:	c0 48       	rjmp	80006efe <PrintHex+0x42>
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
		i = (i >> 4 ) & 0x0FFFFFFF;
		//i >>= 4
	}
	else
	s[cnt++] = '0';
80006ef8:	33 08       	mov	r8,48
80006efa:	ba 88       	st.b	sp[0x0],r8
80006efc:	30 19       	mov	r9,1
	
	if(len - cnt > 0 )
80006efe:	f6 09 01 08 	sub	r8,r11,r9
80006f02:	58 08       	cp.w	r8,0
80006f04:	e0 8a 00 13 	brle	80006f2a <PrintHex+0x6e>
	{
		char num = len - cnt;
80006f08:	12 1b       	sub	r11,r9
80006f0a:	f9 db c0 08 	bfextu	r12,r11,0x0,0x8
		for(int i = 0; i < num; i++)
80006f0e:	18 9e       	mov	lr,r12
80006f10:	58 0c       	cp.w	r12,0
80006f12:	e0 8a 00 0c 	brle	80006f2a <PrintHex+0x6e>
80006f16:	1a 9b       	mov	r11,sp
80006f18:	12 0b       	add	r11,r9
80006f1a:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80006f1c:	33 07       	mov	r7,48
80006f1e:	16 c7       	st.b	r11++,r7
	s[cnt++] = '0';
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80006f20:	2f f8       	sub	r8,-1
80006f22:	1c 38       	cp.w	r8,lr
80006f24:	cf d5       	brlt	80006f1e <PrintHex+0x62>
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
80006f26:	f8 09 00 09 	add	r9,r12,r9
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80006f2a:	f2 c8 ff ff 	sub	r8,r9,-1
	s[cnt++] = '0';
	
	while(cnt>0)
80006f2e:	f0 cb ff ff 	sub	r11,r8,-1
80006f32:	58 0b       	cp.w	r11,0
80006f34:	e0 8a 00 19 	brle	80006f66 <PrintHex+0xaa>
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80006f38:	fa cb ff f4 	sub	r11,sp,-12
80006f3c:	f6 09 00 09 	add	r9,r11,r9
80006f40:	37 8b       	mov	r11,120
80006f42:	f3 6b ff f4 	st.b	r9[-12],r11
	s[cnt++] = '0';
80006f46:	fa c9 ff f4 	sub	r9,sp,-12
80006f4a:	10 09       	add	r9,r8
80006f4c:	33 0b       	mov	r11,48
80006f4e:	f3 6b ff f4 	st.b	r9[-12],r11
80006f52:	fa 08 00 08 	add	r8,sp,r8
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
80006f56:	fa ce 00 01 	sub	lr,sp,1
80006f5a:	14 99       	mov	r9,r10
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
	*p++ = s[--cnt];
80006f5c:	11 8b       	ld.ub	r11,r8[0x0]
80006f5e:	12 cb       	st.b	r9++,r11
80006f60:	20 18       	sub	r8,1
	}
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
80006f62:	1c 38       	cp.w	r8,lr
80006f64:	cf c1       	brne	80006f5c <PrintHex+0xa0>
	*p++ = s[--cnt];
		
	return str;
}
80006f66:	14 9c       	mov	r12,r10
80006f68:	2f dd       	sub	sp,-12
80006f6a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

80006f6e <PrintDec>:
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
{
80006f6e:	d4 21       	pushm	r4-r7,lr
80006f70:	20 3d       	sub	sp,12
80006f72:	18 98       	mov	r8,r12
	char * p = str;
	
	int sign = i>=0 ? 0 : 1;
	char s[10];
	memset(s, 0 , 10);
80006f74:	30 06       	mov	r6,0
80006f76:	30 07       	mov	r7,0
80006f78:	fa e7 00 00 	st.d	sp[0],r6
80006f7c:	30 0c       	mov	r12,0
80006f7e:	ba 4c       	st.h	sp[0x8],r12
	int cnt=0;
	if(sign)
80006f80:	58 08       	cp.w	r8,0
80006f82:	c0 35       	brlt	80006f88 <PrintDec+0x1a>
80006f84:	14 97       	mov	r7,r10
80006f86:	c0 58       	rjmp	80006f90 <PrintDec+0x22>
	{
		*p++ = '-';
80006f88:	14 97       	mov	r7,r10
80006f8a:	32 d9       	mov	r9,45
80006f8c:	0e c9       	st.b	r7++,r9
		i = -i;
80006f8e:	5c 38       	neg	r8
	}
	
	if(i == 0 )s[cnt++] = '0';
80006f90:	58 08       	cp.w	r8,0
80006f92:	c0 51       	brne	80006f9c <PrintDec+0x2e>
80006f94:	33 08       	mov	r8,48
80006f96:	ba 88       	st.b	sp[0x0],r8
80006f98:	30 1e       	mov	lr,1
80006f9a:	c2 f8       	rjmp	80006ff8 <PrintDec+0x8a>
	
	int ten = i%10;
80006f9c:	e0 65 66 67 	mov	r5,26215
80006fa0:	ea 15 66 66 	orh	r5,0x6666
80006fa4:	f0 05 04 44 	muls.d	r4,r8,r5
80006fa8:	ea 0c 14 02 	asr	r12,r5,0x2
80006fac:	f0 09 14 1f 	asr	r9,r8,0x1f
80006fb0:	f8 09 01 09 	sub	r9,r12,r9
80006fb4:	f2 09 00 29 	add	r9,r9,r9<<0x2
80006fb8:	f0 09 01 19 	sub	r9,r8,r9<<0x1
80006fbc:	30 0e       	mov	lr,0
	while(i)
	{
		s[cnt] = ten+'0';
80006fbe:	1a 9c       	mov	r12,sp
		cnt++;
		i /= 10;
80006fc0:	e0 66 66 67 	mov	r6,26215
80006fc4:	ea 16 66 66 	orh	r6,0x6666
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
	{
		s[cnt] = ten+'0';
80006fc8:	2d 09       	sub	r9,-48
80006fca:	f8 0e 0b 09 	st.b	r12[lr],r9
		cnt++;
80006fce:	2f fe       	sub	lr,-1
		i /= 10;
80006fd0:	f0 06 04 44 	muls.d	r4,r8,r6
80006fd4:	ea 09 14 02 	asr	r9,r5,0x2
80006fd8:	bf 58       	asr	r8,0x1f
80006fda:	f2 08 01 08 	sub	r8,r9,r8
		ten = i%10;
80006fde:	f0 06 04 44 	muls.d	r4,r8,r6
80006fe2:	ea 09 14 02 	asr	r9,r5,0x2
80006fe6:	f0 05 14 1f 	asr	r5,r8,0x1f
80006fea:	0a 19       	sub	r9,r5
80006fec:	f2 09 00 29 	add	r9,r9,r9<<0x2
80006ff0:	f0 09 01 19 	sub	r9,r8,r9<<0x1
	}
	
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
80006ff4:	58 08       	cp.w	r8,0
80006ff6:	ce 91       	brne	80006fc8 <PrintDec+0x5a>
		cnt++;
		i /= 10;
		ten = i%10;
	}
	
	if(len - cnt > 0 )
80006ff8:	f6 0e 01 08 	sub	r8,r11,lr
80006ffc:	58 08       	cp.w	r8,0
80006ffe:	e0 89 00 06 	brgt	8000700a <PrintDec+0x9c>
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80007002:	58 0e       	cp.w	lr,0
80007004:	e0 89 00 14 	brgt	8000702c <PrintDec+0xbe>
80007008:	c1 d8       	rjmp	80007042 <PrintDec+0xd4>
		ten = i%10;
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
8000700a:	1c 1b       	sub	r11,lr
8000700c:	5c 5b       	castu.b	r11
		for(int i = 0; i < num; i++)
8000700e:	16 9c       	mov	r12,r11
80007010:	58 0b       	cp.w	r11,0
80007012:	fe 9a ff f8 	brle	80007002 <PrintDec+0x94>
80007016:	1a 99       	mov	r9,sp
80007018:	1c 09       	add	r9,lr
8000701a:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
8000701c:	33 06       	mov	r6,48
8000701e:	12 c6       	st.b	r9++,r6
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80007020:	2f f8       	sub	r8,-1
80007022:	18 38       	cp.w	r8,r12
80007024:	cf d5       	brlt	8000701e <PrintDec+0xb0>
{
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
80007026:	f6 0e 00 0e 	add	lr,r11,lr
8000702a:	ce cb       	rjmp	80007002 <PrintDec+0x94>
8000702c:	fa c8 ff f4 	sub	r8,sp,-12
80007030:	1c 08       	add	r8,lr
80007032:	20 d8       	sub	r8,13
80007034:	fa cb 00 01 	sub	r11,sp,1
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
	*p++ = s[--cnt];
80007038:	11 89       	ld.ub	r9,r8[0x0]
8000703a:	0e c9       	st.b	r7++,r9
8000703c:	20 18       	sub	r8,1
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
8000703e:	16 38       	cp.w	r8,r11
80007040:	cf c1       	brne	80007038 <PrintDec+0xca>
	*p++ = s[--cnt];
	
	return str;
}
80007042:	14 9c       	mov	r12,r10
80007044:	2f dd       	sub	sp,-12
80007046:	d8 22       	popm	r4-r7,pc

80007048 <log>:
	,  NULL );
	
}

int log(char * content, ...)
{
80007048:	d4 31       	pushm	r0-r7,lr
8000704a:	fa cd 02 08 	sub	sp,sp,520
8000704e:	18 97       	mov	r7,r12
	
	
	char logTmp[MAX_LOG_LINE_SIZE];
	memset(logTmp, '\0', MAX_LOG_LINE_SIZE);	
80007050:	e0 6a 01 00 	mov	r10,256
80007054:	30 0b       	mov	r11,0
80007056:	fa cc fe f8 	sub	r12,sp,-264
8000705a:	f0 1f 00 4e 	mcall	80007190 <log+0x148>
	,  tskLOG_PRIORITY
	,  NULL );
	
}

int log(char * content, ...)
8000705e:	fa c4 fd d4 	sub	r4,sp,-556
80007062:	30 0a       	mov	r10,0
80007064:	50 0a       	stdsp	sp[0x0],r10
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80007066:	fa c3 ff fc 	sub	r3,sp,-4
8000706a:	e0 61 01 00 	mov	r1,256
8000706e:	14 90       	mov	r0,r10
			
					if(*str == '%')
80007070:	32 52       	mov	r2,37
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
80007072:	fa c6 fe f8 	sub	r6,sp,-264
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80007076:	02 9a       	mov	r10,r1
80007078:	00 9b       	mov	r11,r0
8000707a:	06 9c       	mov	r12,r3
8000707c:	f0 1f 00 45 	mcall	80007190 <log+0x148>
			
					if(*str == '%')
80007080:	0f 88       	ld.ub	r8,r7[0x0]
80007082:	e4 08 18 00 	cp.b	r8,r2
80007086:	c5 71       	brne	80007134 <log+0xec>
					{
						static char lench = 0;
						lench =*(str + 1);
80007088:	ee c8 ff ff 	sub	r8,r7,-1
8000708c:	11 89       	ld.ub	r9,r8[0x0]
8000708e:	4c 2a       	lddpc	r10,80007194 <log+0x14c>
80007090:	b4 89       	st.b	r10[0x0],r9
						if((lench >= '0') &&  (lench <= '9'))
80007092:	23 09       	sub	r9,48
80007094:	30 9a       	mov	r10,9
80007096:	f4 09 18 00 	cp.b	r9,r10
8000709a:	ee 08 17 b0 	movhi	r8,r7
						{
							len = *(++str) - '0';
8000709e:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
800070a2:	f7 b9 08 30 	subls	r9,48
800070a6:	fb f9 8a 00 	st.wls	sp[0x0],r9
						}
						
						str++;
800070aa:	f0 c7 ff ff 	sub	r7,r8,-1
						
						switch(*(str))
800070ae:	0f 88       	ld.ub	r8,r7[0x0]
800070b0:	22 58       	sub	r8,37
800070b2:	e0 48 00 53 	cp.w	r8,83
800070b6:	e0 8b 00 31 	brhi	80007118 <log+0xd0>
800070ba:	4b 89       	lddpc	r9,80007198 <log+0x150>
800070bc:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
						{
							case('i'):
							case('I'):
							case('d'):
							case('D'):
							x = va_arg(arg_ptr,int);
800070c0:	e8 c5 ff fc 	sub	r5,r4,-4
							strTmp = PrintDec(x, len, strTmp);
800070c4:	06 9a       	mov	r10,r3
800070c6:	40 0b       	lddsp	r11,sp[0x0]
800070c8:	5c 5b       	castu.b	r11
800070ca:	68 0c       	ld.w	r12,r4[0x0]
800070cc:	f0 1f 00 34 	mcall	8000719c <log+0x154>
							break;
800070d0:	c2 98       	rjmp	80007122 <log+0xda>
							
							case('f')://浮点数输出
							case('F'):
							//f = va_arg(arg_ptr,int);
							//strTmp = PrintDec(x, len, strTmp);
							log("I need float.");
800070d2:	4b 4c       	lddpc	r12,800071a0 <log+0x158>
800070d4:	f0 1f 00 34 	mcall	800071a4 <log+0x15c>
800070d8:	08 95       	mov	r5,r4
800070da:	06 9c       	mov	r12,r3
							break;
800070dc:	c2 38       	rjmp	80007122 <log+0xda>
							
							
							case('x'):
							case('X'):
							x = va_arg(arg_ptr,int);
800070de:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintHex(x,len, strTmp);
800070e2:	06 9a       	mov	r10,r3
800070e4:	40 0b       	lddsp	r11,sp[0x0]
800070e6:	5c 5b       	castu.b	r11
800070e8:	68 0c       	ld.w	r12,r4[0x0]
800070ea:	f0 1f 00 30 	mcall	800071a8 <log+0x160>
800070ee:	06 9c       	mov	r12,r3
							break;
800070f0:	c1 98       	rjmp	80007122 <log+0xda>
							
							case('c'):
							case('C'):
							y = va_arg(arg_ptr,int);
800070f2:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintChar(y, strTmp);
800070f6:	06 9b       	mov	r11,r3
800070f8:	09 bc       	ld.ub	r12,r4[0x3]
800070fa:	f0 1f 00 2d 	mcall	800071ac <log+0x164>
800070fe:	06 9c       	mov	r12,r3
							break;
80007100:	c1 18       	rjmp	80007122 <log+0xda>
							
							case('s'):
							case('S'):
							strTmp = va_arg(arg_ptr,char*);
80007102:	e8 c5 ff fc 	sub	r5,r4,-4
80007106:	68 0c       	ld.w	r12,r4[0x0]
							//PrintStr(s);
							break;
80007108:	c0 d8       	rjmp	80007122 <log+0xda>
							
							case('%'):
							PrintChar('%', strTmp);
8000710a:	06 9b       	mov	r11,r3
8000710c:	32 5c       	mov	r12,37
8000710e:	f0 1f 00 28 	mcall	800071ac <log+0x164>
80007112:	08 95       	mov	r5,r4
80007114:	06 9c       	mov	r12,r3
							//PrintChar('%');
							break;
80007116:	c0 68       	rjmp	80007122 <log+0xda>
							
							default:
							log("I need relax.");
80007118:	4a 6c       	lddpc	r12,800071b0 <log+0x168>
8000711a:	f0 1f 00 23 	mcall	800071a4 <log+0x15c>
8000711e:	08 95       	mov	r5,r4
80007120:	06 9c       	mov	r12,r3
						}
						str++;
80007122:	2f f7       	sub	r7,-1
						
						length = sprintf(logTmp,"%s%s",logTmp,strTmp );
80007124:	1a dc       	st.w	--sp,r12
80007126:	1a d6       	st.w	--sp,r6
80007128:	4a 3b       	lddpc	r11,800071b4 <log+0x16c>
8000712a:	0c 9c       	mov	r12,r6
8000712c:	f0 1f 00 23 	mcall	800071b8 <log+0x170>
80007130:	2f ed       	sub	sp,-8
80007132:	c0 a8       	rjmp	80007146 <log+0xfe>
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
80007134:	2f f7       	sub	r7,-1
80007136:	1a d8       	st.w	--sp,r8
80007138:	1a d6       	st.w	--sp,r6
8000713a:	4a 1b       	lddpc	r11,800071bc <log+0x174>
8000713c:	0c 9c       	mov	r12,r6
8000713e:	f0 1f 00 1f 	mcall	800071b8 <log+0x170>
80007142:	08 95       	mov	r5,r4
80007144:	2f ed       	sub	sp,-8
			
			
			
	}while(*str != '\0');
80007146:	0f 89       	ld.ub	r9,r7[0x0]
80007148:	30 08       	mov	r8,0
8000714a:	f0 09 18 00 	cp.b	r9,r8
8000714e:	c0 30       	breq	80007154 <log+0x10c>
80007150:	0a 94       	mov	r4,r5
80007152:	c9 2b       	rjmp	80007076 <log+0x2e>
		
		
				
	va_end(arg_ptr);
	//while(1)		
	length = sprintf(logTmp,"%s\r\n",logTmp);
80007154:	fa c7 fe f8 	sub	r7,sp,-264
80007158:	1a d7       	st.w	--sp,r7
8000715a:	49 ab       	lddpc	r11,800071c0 <log+0x178>
8000715c:	0e 9c       	mov	r12,r7
8000715e:	f0 1f 00 17 	mcall	800071b8 <log+0x170>
	
	char * p = pvPortMalloc(length+1);
80007162:	5c 5c       	castu.b	r12
80007164:	f8 c6 ff ff 	sub	r6,r12,-1
80007168:	0c 9c       	mov	r12,r6
8000716a:	f0 1f 00 17 	mcall	800071c4 <log+0x17c>
8000716e:	54 2c       	stdsp	sp[0x108],r12
	memcpy(p, logTmp, length+1);
80007170:	0c 9a       	mov	r10,r6
80007172:	0e 9b       	mov	r11,r7
80007174:	f0 1f 00 15 	mcall	800071c8 <log+0x180>
	//
	//usart_write_line(EXAMPLE_USART, logTmp)
	
	xQueueSend( logQueue, &p, 5);
80007178:	30 09       	mov	r9,0
8000717a:	30 5a       	mov	r10,5
8000717c:	fa cb fe f8 	sub	r11,sp,-264
80007180:	49 38       	lddpc	r8,800071cc <log+0x184>
80007182:	70 0c       	ld.w	r12,r8[0x0]
80007184:	f0 1f 00 13 	mcall	800071d0 <log+0x188>
80007188:	2f fd       	sub	sp,-4
	
	
}
8000718a:	fe 3d fd f8 	sub	sp,-520
8000718e:	d8 32       	popm	r0-r7,pc
80007190:	80 00       	ld.sh	r0,r0[0x0]
80007192:	7a 0c       	ld.w	r12,sp[0x0]
80007194:	00 00       	add	r0,r0
80007196:	0d 60       	ld.uh	r0,--r6
80007198:	80 00       	ld.sh	r0,r0[0x0]
8000719a:	da 38       	*unknown*
8000719c:	80 00       	ld.sh	r0,r0[0x0]
8000719e:	6f 6e       	ld.w	lr,r7[0x58]
800071a0:	80 00       	ld.sh	r0,r0[0x0]
800071a2:	dc e4       	*unknown*
800071a4:	80 00       	ld.sh	r0,r0[0x0]
800071a6:	70 48       	ld.w	r8,r8[0x10]
800071a8:	80 00       	ld.sh	r0,r0[0x0]
800071aa:	6e bc       	ld.w	r12,r7[0x2c]
800071ac:	80 00       	ld.sh	r0,r0[0x0]
800071ae:	6e b8       	ld.w	r8,r7[0x2c]
800071b0:	80 00       	ld.sh	r0,r0[0x0]
800071b2:	dc f4       	*unknown*
800071b4:	80 00       	ld.sh	r0,r0[0x0]
800071b6:	dd 04       	*unknown*
800071b8:	80 00       	ld.sh	r0,r0[0x0]
800071ba:	7c fc       	ld.w	r12,lr[0x3c]
800071bc:	80 00       	ld.sh	r0,r0[0x0]
800071be:	dd 0c       	*unknown*
800071c0:	80 00       	ld.sh	r0,r0[0x0]
800071c2:	dd 14       	*unknown*
800071c4:	80 00       	ld.sh	r0,r0[0x0]
800071c6:	60 bc       	ld.w	r12,r0[0x2c]
800071c8:	80 00       	ld.sh	r0,r0[0x0]
800071ca:	78 c4       	ld.w	r4,r12[0x30]
800071cc:	00 00       	add	r0,r0
800071ce:	bf f4       	*unknown*
800071d0:	80 00       	ld.sh	r0,r0[0x0]
800071d2:	64 10       	ld.w	r0,r2[0x4]

800071d4 <logFromISR>:
	
	
int logFromISR(char * content, ...)
	{
800071d4:	d4 31       	pushm	r0-r7,lr
800071d6:	fa cd 02 0c 	sub	sp,sp,524
800071da:	18 97       	mov	r7,r12
		
		
		char logTmp[MAX_LOG_LINE_SIZE];
		memset(logTmp, '\0', MAX_LOG_LINE_SIZE);
800071dc:	e0 6a 01 00 	mov	r10,256
800071e0:	30 0b       	mov	r11,0
800071e2:	fa cc fe f4 	sub	r12,sp,-268
800071e6:	f0 1f 00 4c 	mcall	80007314 <logFromISR+0x140>
	
	
}
	
	
int logFromISR(char * content, ...)
800071ea:	fa c4 fd d0 	sub	r4,sp,-560
800071ee:	30 0a       	mov	r10,0
800071f0:	50 0a       	stdsp	sp[0x0],r10
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
800071f2:	fa c3 ff fc 	sub	r3,sp,-4
800071f6:	e0 61 01 00 	mov	r1,256
800071fa:	14 90       	mov	r0,r10
			
			if(*str == '%')
800071fc:	32 52       	mov	r2,37
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
800071fe:	fa c6 fe f4 	sub	r6,sp,-268
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80007202:	02 9a       	mov	r10,r1
80007204:	00 9b       	mov	r11,r0
80007206:	06 9c       	mov	r12,r3
80007208:	f0 1f 00 43 	mcall	80007314 <logFromISR+0x140>
			
			if(*str == '%')
8000720c:	0f 88       	ld.ub	r8,r7[0x0]
8000720e:	e4 08 18 00 	cp.b	r8,r2
80007212:	c5 11       	brne	800072b4 <logFromISR+0xe0>
			{
				static char lench = 0;
				lench =*(str + 1);
80007214:	ee c8 ff ff 	sub	r8,r7,-1
80007218:	11 89       	ld.ub	r9,r8[0x0]
8000721a:	4c 0a       	lddpc	r10,80007318 <logFromISR+0x144>
8000721c:	b4 89       	st.b	r10[0x0],r9
				if((lench >= '0') &&  (lench <= '9'))
8000721e:	23 09       	sub	r9,48
80007220:	30 9a       	mov	r10,9
80007222:	f4 09 18 00 	cp.b	r9,r10
80007226:	ee 08 17 b0 	movhi	r8,r7
				{
					len = *(++str) - '0';
8000722a:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
8000722e:	f7 b9 08 30 	subls	r9,48
80007232:	fb f9 8a 00 	st.wls	sp[0x0],r9
				}
				
				str++;
80007236:	f0 c7 ff ff 	sub	r7,r8,-1
				
				switch(*(str))
8000723a:	0f 88       	ld.ub	r8,r7[0x0]
8000723c:	22 58       	sub	r8,37
8000723e:	e0 48 00 53 	cp.w	r8,83
80007242:	e0 8b 00 2b 	brhi	80007298 <logFromISR+0xc4>
80007246:	4b 69       	lddpc	r9,8000731c <logFromISR+0x148>
80007248:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
				{
					case('d'):
					case('D'):
					x = va_arg(arg_ptr,int);
8000724c:	e8 c5 ff fc 	sub	r5,r4,-4
					strTmp = PrintDec(x, len, strTmp);
80007250:	06 9a       	mov	r10,r3
80007252:	40 0b       	lddsp	r11,sp[0x0]
80007254:	5c 5b       	castu.b	r11
80007256:	68 0c       	ld.w	r12,r4[0x0]
80007258:	f0 1f 00 32 	mcall	80007320 <logFromISR+0x14c>
					break;
8000725c:	c2 38       	rjmp	800072a2 <logFromISR+0xce>
					case('x'):
					case('X'):
					x = va_arg(arg_ptr,int);
8000725e:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintHex(x,len, strTmp);
80007262:	06 9a       	mov	r10,r3
80007264:	40 0b       	lddsp	r11,sp[0x0]
80007266:	5c 5b       	castu.b	r11
80007268:	68 0c       	ld.w	r12,r4[0x0]
8000726a:	f0 1f 00 2f 	mcall	80007324 <logFromISR+0x150>
8000726e:	06 9c       	mov	r12,r3
					break;
80007270:	c1 98       	rjmp	800072a2 <logFromISR+0xce>
					case('c'):
					case('C'):
					y = va_arg(arg_ptr,int);
80007272:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintChar(y, strTmp);
80007276:	06 9b       	mov	r11,r3
80007278:	09 bc       	ld.ub	r12,r4[0x3]
8000727a:	f0 1f 00 2c 	mcall	80007328 <logFromISR+0x154>
8000727e:	06 9c       	mov	r12,r3
					break;
80007280:	c1 18       	rjmp	800072a2 <logFromISR+0xce>
					case('s'):
					case('S'):
					strTmp = va_arg(arg_ptr,char*);
80007282:	e8 c5 ff fc 	sub	r5,r4,-4
80007286:	68 0c       	ld.w	r12,r4[0x0]
					//PrintStr(s);
					break;
80007288:	c0 d8       	rjmp	800072a2 <logFromISR+0xce>
					case('%'):
					PrintChar('%', strTmp);
8000728a:	06 9b       	mov	r11,r3
8000728c:	32 5c       	mov	r12,37
8000728e:	f0 1f 00 27 	mcall	80007328 <logFromISR+0x154>
80007292:	08 95       	mov	r5,r4
80007294:	06 9c       	mov	r12,r3
					//PrintChar('%');
					break;
80007296:	c0 68       	rjmp	800072a2 <logFromISR+0xce>
					default:
					log("I need relax.");
80007298:	4a 5c       	lddpc	r12,8000732c <logFromISR+0x158>
8000729a:	f0 1f 00 26 	mcall	80007330 <logFromISR+0x15c>
8000729e:	08 95       	mov	r5,r4
800072a0:	06 9c       	mov	r12,r3
				}
				str++;
800072a2:	2f f7       	sub	r7,-1
				
				length = sprintf(logTmp,"%s%s",logTmp,strTmp );
800072a4:	1a dc       	st.w	--sp,r12
800072a6:	1a d6       	st.w	--sp,r6
800072a8:	4a 3b       	lddpc	r11,80007334 <logFromISR+0x160>
800072aa:	0c 9c       	mov	r12,r6
800072ac:	f0 1f 00 23 	mcall	80007338 <logFromISR+0x164>
800072b0:	2f ed       	sub	sp,-8
800072b2:	c0 a8       	rjmp	800072c6 <logFromISR+0xf2>
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
800072b4:	2f f7       	sub	r7,-1
800072b6:	1a d8       	st.w	--sp,r8
800072b8:	1a d6       	st.w	--sp,r6
800072ba:	4a 1b       	lddpc	r11,8000733c <logFromISR+0x168>
800072bc:	0c 9c       	mov	r12,r6
800072be:	f0 1f 00 1f 	mcall	80007338 <logFromISR+0x164>
800072c2:	08 95       	mov	r5,r4
800072c4:	2f ed       	sub	sp,-8
			
			
			
		}while(*str != '\0');
800072c6:	0f 89       	ld.ub	r9,r7[0x0]
800072c8:	30 08       	mov	r8,0
800072ca:	f0 09 18 00 	cp.b	r9,r8
800072ce:	c0 30       	breq	800072d4 <logFromISR+0x100>
800072d0:	0a 94       	mov	r4,r5
800072d2:	c9 8b       	rjmp	80007202 <logFromISR+0x2e>
		
		
		
		va_end(arg_ptr);
		//while(1)
		length = sprintf(logTmp,"%s\r\n",logTmp);
800072d4:	fa c7 fe f4 	sub	r7,sp,-268
800072d8:	1a d7       	st.w	--sp,r7
800072da:	49 ab       	lddpc	r11,80007340 <logFromISR+0x16c>
800072dc:	0e 9c       	mov	r12,r7
800072de:	f0 1f 00 17 	mcall	80007338 <logFromISR+0x164>
		
		char * p = pvPortMalloc(length+1);
800072e2:	5c 5c       	castu.b	r12
800072e4:	f8 c6 ff ff 	sub	r6,r12,-1
800072e8:	0c 9c       	mov	r12,r6
800072ea:	f0 1f 00 17 	mcall	80007344 <logFromISR+0x170>
800072ee:	54 3c       	stdsp	sp[0x10c],r12
		memcpy(p, logTmp, length+1);
800072f0:	0c 9a       	mov	r10,r6
800072f2:	0e 9b       	mov	r11,r7
800072f4:	f0 1f 00 15 	mcall	80007348 <logFromISR+0x174>
		//
		portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
800072f8:	30 09       	mov	r9,0
800072fa:	54 29       	stdsp	sp[0x108],r9
		
		//usart_write_line(EXAMPLE_USART, p);
		//vPortFree(p);
		xQueueSendFromISR( logQueue, &p, &xHigherPriorityTaskWoken );
800072fc:	fa ca fe f8 	sub	r10,sp,-264
80007300:	fa cb fe f4 	sub	r11,sp,-268
80007304:	49 28       	lddpc	r8,8000734c <logFromISR+0x178>
80007306:	70 0c       	ld.w	r12,r8[0x0]
80007308:	f0 1f 00 12 	mcall	80007350 <logFromISR+0x17c>
8000730c:	2f fd       	sub	sp,-4
		
		//if (xHigherPriorityTaskWoken == pdTRUE)
		//{
			////taskYIELD();
		//}
	}
8000730e:	fe 3d fd f4 	sub	sp,-524
80007312:	d8 32       	popm	r0-r7,pc
80007314:	80 00       	ld.sh	r0,r0[0x0]
80007316:	7a 0c       	ld.w	r12,sp[0x0]
80007318:	00 00       	add	r0,r0
8000731a:	0d 61       	ld.uh	r1,--r6
8000731c:	80 00       	ld.sh	r0,r0[0x0]
8000731e:	db 88       	*unknown*
80007320:	80 00       	ld.sh	r0,r0[0x0]
80007322:	6f 6e       	ld.w	lr,r7[0x58]
80007324:	80 00       	ld.sh	r0,r0[0x0]
80007326:	6e bc       	ld.w	r12,r7[0x2c]
80007328:	80 00       	ld.sh	r0,r0[0x0]
8000732a:	6e b8       	ld.w	r8,r7[0x2c]
8000732c:	80 00       	ld.sh	r0,r0[0x0]
8000732e:	dc f4       	*unknown*
80007330:	80 00       	ld.sh	r0,r0[0x0]
80007332:	70 48       	ld.w	r8,r8[0x10]
80007334:	80 00       	ld.sh	r0,r0[0x0]
80007336:	dd 04       	*unknown*
80007338:	80 00       	ld.sh	r0,r0[0x0]
8000733a:	7c fc       	ld.w	r12,lr[0x3c]
8000733c:	80 00       	ld.sh	r0,r0[0x0]
8000733e:	dd 0c       	*unknown*
80007340:	80 00       	ld.sh	r0,r0[0x0]
80007342:	dd 14       	*unknown*
80007344:	80 00       	ld.sh	r0,r0[0x0]
80007346:	60 bc       	ld.w	r12,r0[0x2c]
80007348:	80 00       	ld.sh	r0,r0[0x0]
8000734a:	78 c4       	ld.w	r4,r12[0x30]
8000734c:	00 00       	add	r0,r0
8000734e:	bf f4       	*unknown*
80007350:	80 00       	ld.sh	r0,r0[0x0]
80007352:	63 c0       	ld.w	r0,r1[0x70]

80007354 <log_init>:
		
	return str;
}

void log_init(void)
{
80007354:	d4 01       	pushm	lr
		.stopbits     = USART_1_STOPBIT,
		.channelmode  = USART_NORMAL_CHMODE
	};

	// Assign GPIO to USART.
	gpio_enable_module(USART_GPIO_MAP,
80007356:	30 2b       	mov	r11,2
80007358:	48 fc       	lddpc	r12,80007394 <log_init+0x40>
8000735a:	f0 1f 00 10 	mcall	80007398 <log_init+0x44>
	sizeof(USART_GPIO_MAP) / sizeof(USART_GPIO_MAP[0]));

	// Initialize USART in RS232 mode.
	usart_init_rs232(EXAMPLE_USART, &USART_OPTIONS, EXAMPLE_TARGET_PBACLK_FREQ_HZ);			
8000735e:	e0 6a 36 00 	mov	r10,13824
80007362:	ea 1a 01 6e 	orh	r10,0x16e
80007366:	48 eb       	lddpc	r11,8000739c <log_init+0x48>
80007368:	fe 7c 18 00 	mov	r12,-59392
8000736c:	f0 1f 00 0d 	mcall	800073a0 <log_init+0x4c>
			
	logQueue  = xQueueCreate(50, sizeof(char *));
80007370:	30 4b       	mov	r11,4
80007372:	33 2c       	mov	r12,50
80007374:	f0 1f 00 0c 	mcall	800073a4 <log_init+0x50>
80007378:	48 c8       	lddpc	r8,800073a8 <log_init+0x54>
8000737a:	91 0c       	st.w	r8[0x0],r12
	
	xTaskCreate(
8000737c:	30 09       	mov	r9,0
8000737e:	1a d9       	st.w	--sp,r9
80007380:	1a d9       	st.w	--sp,r9
80007382:	1a d9       	st.w	--sp,r9
80007384:	30 28       	mov	r8,2
80007386:	36 4a       	mov	r10,100
80007388:	48 9b       	lddpc	r11,800073ac <log_init+0x58>
8000738a:	48 ac       	lddpc	r12,800073b0 <log_init+0x5c>
8000738c:	f0 1f 00 0a 	mcall	800073b4 <log_init+0x60>
80007390:	2f dd       	sub	sp,-12
	,  100//384
	,  NULL
	,  tskLOG_PRIORITY
	,  NULL );
	
}
80007392:	d8 02       	popm	pc
80007394:	80 00       	ld.sh	r0,r0[0x0]
80007396:	dd 20       	acall	0xd2
80007398:	80 00       	ld.sh	r0,r0[0x0]
8000739a:	55 9c       	stdsp	sp[0x164],r12
8000739c:	80 00       	ld.sh	r0,r0[0x0]
8000739e:	dc d8       	*unknown*
800073a0:	80 00       	ld.sh	r0,r0[0x0]
800073a2:	5c 20       	cpc	r0
800073a4:	80 00       	ld.sh	r0,r0[0x0]
800073a6:	65 68       	ld.w	r8,r2[0x58]
800073a8:	00 00       	add	r0,r0
800073aa:	bf f4       	*unknown*
800073ac:	80 00       	ld.sh	r0,r0[0x0]
800073ae:	dd 1c       	*unknown*
800073b0:	80 00       	ld.sh	r0,r0[0x0]
800073b2:	73 b8       	ld.w	r8,r9[0x6c]
800073b4:	80 00       	ld.sh	r0,r0[0x0]
800073b6:	6c 84       	ld.w	r4,r6[0x20]

800073b8 <task_log>:
			////taskYIELD();
		//}
	}
//portTickType log_water_value =0;	
static void task_log(void * pvParameters)
{
800073b8:	eb cd 40 f8 	pushm	r3-r7,lr
800073bc:	20 1d       	sub	sp,4
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		//log_water_value = uxTaskGetStackHighWaterMark(NULL);
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
800073be:	48 c7       	lddpc	r7,800073ec <task_log+0x34>
800073c0:	30 05       	mov	r5,0
800073c2:	3f f4       	mov	r4,-1
		{
			if( NULL != str)
			{
				usart_write_line(EXAMPLE_USART, str);
800073c4:	fe 73 18 00 	mov	r3,-59392
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		//log_water_value = uxTaskGetStackHighWaterMark(NULL);
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
800073c8:	0a 99       	mov	r9,r5
800073ca:	08 9a       	mov	r10,r4
800073cc:	1a 9b       	mov	r11,sp
800073ce:	6e 0c       	ld.w	r12,r7[0x0]
800073d0:	f0 1f 00 08 	mcall	800073f0 <task_log+0x38>
800073d4:	58 1c       	cp.w	r12,1
800073d6:	cf 91       	brne	800073c8 <task_log+0x10>
		{
			if( NULL != str)
800073d8:	40 0b       	lddsp	r11,sp[0x0]
800073da:	58 0b       	cp.w	r11,0
800073dc:	cf 60       	breq	800073c8 <task_log+0x10>
			{
				usart_write_line(EXAMPLE_USART, str);
800073de:	06 9c       	mov	r12,r3
800073e0:	f0 1f 00 05 	mcall	800073f4 <task_log+0x3c>
				vPortFree(str);
800073e4:	40 0c       	lddsp	r12,sp[0x0]
800073e6:	f0 1f 00 05 	mcall	800073f8 <task_log+0x40>
800073ea:	ce fb       	rjmp	800073c8 <task_log+0x10>
800073ec:	00 00       	add	r0,r0
800073ee:	bf f4       	*unknown*
800073f0:	80 00       	ld.sh	r0,r0[0x0]
800073f2:	62 04       	ld.w	r4,r1[0x0]
800073f4:	80 00       	ld.sh	r0,r0[0x0]
800073f6:	5b d0       	cp.w	r0,-3
800073f8:	80 00       	ld.sh	r0,r0[0x0]
800073fa:	60 94       	ld.w	r4,r0[0x24]

800073fc <main>:
#include "xgflash.h"
#include "app.h"


int main (void)
{
800073fc:	d4 01       	pushm	lr
	
	//Force SSC_TX_DATA_ENABLE Disabled as soon as possible.
	AVR32_GPIO.port[1].ovrs  =  0x00000001;  //Value will be high.
800073fe:	fe 78 10 00 	mov	r8,-61440
80007402:	30 19       	mov	r9,1
80007404:	f1 49 01 54 	st.w	r8[340],r9
	AVR32_GPIO.port[1].oders =  0x00000001;  //Output Driver will be Enabled.
80007408:	f1 49 01 44 	st.w	r8[324],r9
	AVR32_GPIO.port[1].gpers =  0x00000001;  //Enable as GPIO.
8000740c:	f1 49 01 04 	st.w	r8[260],r9
		
	Disable_global_interrupt();
80007410:	d3 03       	ssrf	0x10
	local_start_pll0();
80007412:	f0 1f 00 0c 	mcall	80007440 <main+0x44>
		
	INTC_init_interrupts();
80007416:	f0 1f 00 0c 	mcall	80007444 <main+0x48>
		
	log_init();
8000741a:	f0 1f 00 0c 	mcall	80007448 <main+0x4c>
	log("----start debug----");
8000741e:	48 cc       	lddpc	r12,8000744c <main+0x50>
80007420:	f0 1f 00 0c 	mcall	80007450 <main+0x54>
	
	xg_flashc_init();
80007424:	f0 1f 00 0c 	mcall	80007454 <main+0x58>
	
	rfid_init();
80007428:	f0 1f 00 0c 	mcall	80007458 <main+0x5c>
		
	app_init();
8000742c:	f0 1f 00 0c 	mcall	8000745c <main+0x60>
		
	xcmp_init();
80007430:	f0 1f 00 0c 	mcall	80007460 <main+0x64>

	local_start_timer();
80007434:	f0 1f 00 0c 	mcall	80007464 <main+0x68>
		
	vTaskStartScheduler();
80007438:	f0 1f 00 0c 	mcall	80007468 <main+0x6c>
	return 0;
	
}
8000743c:	d8 0a       	popm	pc,r12=0
8000743e:	00 00       	add	r0,r0
80007440:	80 00       	ld.sh	r0,r0[0x0]
80007442:	54 18       	stdsp	sp[0x104],r8
80007444:	80 00       	ld.sh	r0,r0[0x0]
80007446:	56 a0       	stdsp	sp[0x1a8],r0
80007448:	80 00       	ld.sh	r0,r0[0x0]
8000744a:	73 54       	ld.w	r4,r9[0x54]
8000744c:	80 00       	ld.sh	r0,r0[0x0]
8000744e:	dd 30       	acall	0xd3
80007450:	80 00       	ld.sh	r0,r0[0x0]
80007452:	70 48       	ld.w	r8,r8[0x10]
80007454:	80 00       	ld.sh	r0,r0[0x0]
80007456:	54 ac       	stdsp	sp[0x128],r12
80007458:	80 00       	ld.sh	r0,r0[0x0]
8000745a:	53 78       	stdsp	sp[0xdc],r8
8000745c:	80 00       	ld.sh	r0,r0[0x0]
8000745e:	27 44       	sub	r4,116
80007460:	80 00       	ld.sh	r0,r0[0x0]
80007462:	41 7c       	lddsp	r12,sp[0x5c]
80007464:	80 00       	ld.sh	r0,r0[0x0]
80007466:	53 ec       	stdsp	sp[0xf8],r12
80007468:	80 00       	ld.sh	r0,r0[0x0]
8000746a:	6e 6c       	ld.w	r12,r7[0x18]

8000746c <free>:
8000746c:	d4 01       	pushm	lr
8000746e:	e0 68 0a 3c 	mov	r8,2620
80007472:	18 9b       	mov	r11,r12
80007474:	70 0c       	ld.w	r12,r8[0x0]
80007476:	e0 a0 1e 61 	rcall	8000b138 <_free_r>
8000747a:	d8 02       	popm	pc

8000747c <malloc>:
8000747c:	d4 01       	pushm	lr
8000747e:	e0 68 0a 3c 	mov	r8,2620
80007482:	18 9b       	mov	r11,r12
80007484:	70 0c       	ld.w	r12,r8[0x0]
80007486:	c0 3c       	rcall	8000748c <_malloc_r>
80007488:	d8 02       	popm	pc
8000748a:	d7 03       	nop

8000748c <_malloc_r>:
8000748c:	d4 31       	pushm	r0-r7,lr
8000748e:	f6 c8 ff f5 	sub	r8,r11,-11
80007492:	18 95       	mov	r5,r12
80007494:	10 97       	mov	r7,r8
80007496:	e0 17 ff f8 	andl	r7,0xfff8
8000749a:	59 68       	cp.w	r8,22
8000749c:	f9 b7 08 10 	movls	r7,16
800074a0:	16 37       	cp.w	r7,r11
800074a2:	5f 38       	srlo	r8
800074a4:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
800074a8:	c0 50       	breq	800074b2 <_malloc_r+0x26>
800074aa:	30 c8       	mov	r8,12
800074ac:	99 38       	st.w	r12[0xc],r8
800074ae:	e0 8f 01 fa 	bral	800078a2 <_malloc_r+0x416>
800074b2:	fe b0 f5 a7 	rcall	80006000 <__malloc_lock>
800074b6:	e0 47 01 f7 	cp.w	r7,503
800074ba:	e0 8b 00 1d 	brhi	800074f4 <_malloc_r+0x68>
800074be:	ee 03 16 03 	lsr	r3,r7,0x3
800074c2:	e0 68 05 3c 	mov	r8,1340
800074c6:	f0 03 00 38 	add	r8,r8,r3<<0x3
800074ca:	70 36       	ld.w	r6,r8[0xc]
800074cc:	10 36       	cp.w	r6,r8
800074ce:	c0 61       	brne	800074da <_malloc_r+0x4e>
800074d0:	ec c8 ff f8 	sub	r8,r6,-8
800074d4:	70 36       	ld.w	r6,r8[0xc]
800074d6:	10 36       	cp.w	r6,r8
800074d8:	c0 c0       	breq	800074f0 <_malloc_r+0x64>
800074da:	6c 18       	ld.w	r8,r6[0x4]
800074dc:	e0 18 ff fc 	andl	r8,0xfffc
800074e0:	6c 3a       	ld.w	r10,r6[0xc]
800074e2:	ec 08 00 09 	add	r9,r6,r8
800074e6:	0a 9c       	mov	r12,r5
800074e8:	6c 28       	ld.w	r8,r6[0x8]
800074ea:	95 28       	st.w	r10[0x8],r8
800074ec:	91 3a       	st.w	r8[0xc],r10
800074ee:	c4 78       	rjmp	8000757c <_malloc_r+0xf0>
800074f0:	2f e3       	sub	r3,-2
800074f2:	c4 d8       	rjmp	8000758c <_malloc_r+0x100>
800074f4:	ee 03 16 09 	lsr	r3,r7,0x9
800074f8:	c0 41       	brne	80007500 <_malloc_r+0x74>
800074fa:	ee 03 16 03 	lsr	r3,r7,0x3
800074fe:	c2 68       	rjmp	8000754a <_malloc_r+0xbe>
80007500:	58 43       	cp.w	r3,4
80007502:	e0 8b 00 06 	brhi	8000750e <_malloc_r+0x82>
80007506:	ee 03 16 06 	lsr	r3,r7,0x6
8000750a:	2c 83       	sub	r3,-56
8000750c:	c1 f8       	rjmp	8000754a <_malloc_r+0xbe>
8000750e:	59 43       	cp.w	r3,20
80007510:	e0 8b 00 04 	brhi	80007518 <_malloc_r+0x8c>
80007514:	2a 53       	sub	r3,-91
80007516:	c1 a8       	rjmp	8000754a <_malloc_r+0xbe>
80007518:	e0 43 00 54 	cp.w	r3,84
8000751c:	e0 8b 00 06 	brhi	80007528 <_malloc_r+0x9c>
80007520:	ee 03 16 0c 	lsr	r3,r7,0xc
80007524:	29 23       	sub	r3,-110
80007526:	c1 28       	rjmp	8000754a <_malloc_r+0xbe>
80007528:	e0 43 01 54 	cp.w	r3,340
8000752c:	e0 8b 00 06 	brhi	80007538 <_malloc_r+0xac>
80007530:	ee 03 16 0f 	lsr	r3,r7,0xf
80007534:	28 93       	sub	r3,-119
80007536:	c0 a8       	rjmp	8000754a <_malloc_r+0xbe>
80007538:	e0 43 05 54 	cp.w	r3,1364
8000753c:	e0 88 00 04 	brls	80007544 <_malloc_r+0xb8>
80007540:	37 e3       	mov	r3,126
80007542:	c0 48       	rjmp	8000754a <_malloc_r+0xbe>
80007544:	ee 03 16 12 	lsr	r3,r7,0x12
80007548:	28 43       	sub	r3,-124
8000754a:	e0 6a 05 3c 	mov	r10,1340
8000754e:	f4 03 00 3a 	add	r10,r10,r3<<0x3
80007552:	74 36       	ld.w	r6,r10[0xc]
80007554:	c1 98       	rjmp	80007586 <_malloc_r+0xfa>
80007556:	6c 19       	ld.w	r9,r6[0x4]
80007558:	e0 19 ff fc 	andl	r9,0xfffc
8000755c:	f2 07 01 0b 	sub	r11,r9,r7
80007560:	58 fb       	cp.w	r11,15
80007562:	e0 8a 00 04 	brle	8000756a <_malloc_r+0xde>
80007566:	20 13       	sub	r3,1
80007568:	c1 18       	rjmp	8000758a <_malloc_r+0xfe>
8000756a:	6c 38       	ld.w	r8,r6[0xc]
8000756c:	58 0b       	cp.w	r11,0
8000756e:	c0 b5       	brlt	80007584 <_malloc_r+0xf8>
80007570:	6c 2a       	ld.w	r10,r6[0x8]
80007572:	ec 09 00 09 	add	r9,r6,r9
80007576:	0a 9c       	mov	r12,r5
80007578:	91 2a       	st.w	r8[0x8],r10
8000757a:	95 38       	st.w	r10[0xc],r8
8000757c:	72 18       	ld.w	r8,r9[0x4]
8000757e:	a1 a8       	sbr	r8,0x0
80007580:	93 18       	st.w	r9[0x4],r8
80007582:	cb c8       	rjmp	800076fa <_malloc_r+0x26e>
80007584:	10 96       	mov	r6,r8
80007586:	14 36       	cp.w	r6,r10
80007588:	ce 71       	brne	80007556 <_malloc_r+0xca>
8000758a:	2f f3       	sub	r3,-1
8000758c:	e0 6a 05 3c 	mov	r10,1340
80007590:	f4 cc ff f8 	sub	r12,r10,-8
80007594:	78 26       	ld.w	r6,r12[0x8]
80007596:	18 36       	cp.w	r6,r12
80007598:	c6 c0       	breq	80007670 <_malloc_r+0x1e4>
8000759a:	6c 19       	ld.w	r9,r6[0x4]
8000759c:	e0 19 ff fc 	andl	r9,0xfffc
800075a0:	f2 07 01 08 	sub	r8,r9,r7
800075a4:	58 f8       	cp.w	r8,15
800075a6:	e0 89 00 8f 	brgt	800076c4 <_malloc_r+0x238>
800075aa:	99 3c       	st.w	r12[0xc],r12
800075ac:	99 2c       	st.w	r12[0x8],r12
800075ae:	58 08       	cp.w	r8,0
800075b0:	c0 55       	brlt	800075ba <_malloc_r+0x12e>
800075b2:	ec 09 00 09 	add	r9,r6,r9
800075b6:	0a 9c       	mov	r12,r5
800075b8:	ce 2b       	rjmp	8000757c <_malloc_r+0xf0>
800075ba:	e0 49 01 ff 	cp.w	r9,511
800075be:	e0 8b 00 13 	brhi	800075e4 <_malloc_r+0x158>
800075c2:	a3 99       	lsr	r9,0x3
800075c4:	f4 09 00 38 	add	r8,r10,r9<<0x3
800075c8:	70 2b       	ld.w	r11,r8[0x8]
800075ca:	8d 38       	st.w	r6[0xc],r8
800075cc:	8d 2b       	st.w	r6[0x8],r11
800075ce:	97 36       	st.w	r11[0xc],r6
800075d0:	91 26       	st.w	r8[0x8],r6
800075d2:	a3 49       	asr	r9,0x2
800075d4:	74 18       	ld.w	r8,r10[0x4]
800075d6:	30 1b       	mov	r11,1
800075d8:	f6 09 09 49 	lsl	r9,r11,r9
800075dc:	f1 e9 10 09 	or	r9,r8,r9
800075e0:	95 19       	st.w	r10[0x4],r9
800075e2:	c4 78       	rjmp	80007670 <_malloc_r+0x1e4>
800075e4:	f2 0a 16 09 	lsr	r10,r9,0x9
800075e8:	58 4a       	cp.w	r10,4
800075ea:	e0 8b 00 07 	brhi	800075f8 <_malloc_r+0x16c>
800075ee:	f2 0a 16 06 	lsr	r10,r9,0x6
800075f2:	2c 8a       	sub	r10,-56
800075f4:	c2 08       	rjmp	80007634 <_malloc_r+0x1a8>
800075f6:	d7 03       	nop
800075f8:	59 4a       	cp.w	r10,20
800075fa:	e0 8b 00 04 	brhi	80007602 <_malloc_r+0x176>
800075fe:	2a 5a       	sub	r10,-91
80007600:	c1 a8       	rjmp	80007634 <_malloc_r+0x1a8>
80007602:	e0 4a 00 54 	cp.w	r10,84
80007606:	e0 8b 00 06 	brhi	80007612 <_malloc_r+0x186>
8000760a:	f2 0a 16 0c 	lsr	r10,r9,0xc
8000760e:	29 2a       	sub	r10,-110
80007610:	c1 28       	rjmp	80007634 <_malloc_r+0x1a8>
80007612:	e0 4a 01 54 	cp.w	r10,340
80007616:	e0 8b 00 06 	brhi	80007622 <_malloc_r+0x196>
8000761a:	f2 0a 16 0f 	lsr	r10,r9,0xf
8000761e:	28 9a       	sub	r10,-119
80007620:	c0 a8       	rjmp	80007634 <_malloc_r+0x1a8>
80007622:	e0 4a 05 54 	cp.w	r10,1364
80007626:	e0 88 00 04 	brls	8000762e <_malloc_r+0x1a2>
8000762a:	37 ea       	mov	r10,126
8000762c:	c0 48       	rjmp	80007634 <_malloc_r+0x1a8>
8000762e:	f2 0a 16 12 	lsr	r10,r9,0x12
80007632:	28 4a       	sub	r10,-124
80007634:	e0 6b 05 3c 	mov	r11,1340
80007638:	f6 0a 00 34 	add	r4,r11,r10<<0x3
8000763c:	68 28       	ld.w	r8,r4[0x8]
8000763e:	08 38       	cp.w	r8,r4
80007640:	c0 e1       	brne	8000765c <_malloc_r+0x1d0>
80007642:	76 19       	ld.w	r9,r11[0x4]
80007644:	a3 4a       	asr	r10,0x2
80007646:	30 1e       	mov	lr,1
80007648:	fc 0a 09 4a 	lsl	r10,lr,r10
8000764c:	f3 ea 10 0a 	or	r10,r9,r10
80007650:	10 99       	mov	r9,r8
80007652:	97 1a       	st.w	r11[0x4],r10
80007654:	c0 a8       	rjmp	80007668 <_malloc_r+0x1dc>
80007656:	70 28       	ld.w	r8,r8[0x8]
80007658:	08 38       	cp.w	r8,r4
8000765a:	c0 60       	breq	80007666 <_malloc_r+0x1da>
8000765c:	70 1a       	ld.w	r10,r8[0x4]
8000765e:	e0 1a ff fc 	andl	r10,0xfffc
80007662:	14 39       	cp.w	r9,r10
80007664:	cf 93       	brcs	80007656 <_malloc_r+0x1ca>
80007666:	70 39       	ld.w	r9,r8[0xc]
80007668:	8d 39       	st.w	r6[0xc],r9
8000766a:	8d 28       	st.w	r6[0x8],r8
8000766c:	91 36       	st.w	r8[0xc],r6
8000766e:	93 26       	st.w	r9[0x8],r6
80007670:	e6 08 14 02 	asr	r8,r3,0x2
80007674:	30 1b       	mov	r11,1
80007676:	e0 64 05 3c 	mov	r4,1340
8000767a:	f6 08 09 4b 	lsl	r11,r11,r8
8000767e:	68 18       	ld.w	r8,r4[0x4]
80007680:	10 3b       	cp.w	r11,r8
80007682:	e0 8b 00 6b 	brhi	80007758 <_malloc_r+0x2cc>
80007686:	f7 e8 00 09 	and	r9,r11,r8
8000768a:	c0 b1       	brne	800076a0 <_malloc_r+0x214>
8000768c:	e0 13 ff fc 	andl	r3,0xfffc
80007690:	a1 7b       	lsl	r11,0x1
80007692:	2f c3       	sub	r3,-4
80007694:	c0 38       	rjmp	8000769a <_malloc_r+0x20e>
80007696:	2f c3       	sub	r3,-4
80007698:	a1 7b       	lsl	r11,0x1
8000769a:	f7 e8 00 09 	and	r9,r11,r8
8000769e:	cf c0       	breq	80007696 <_malloc_r+0x20a>
800076a0:	e8 03 00 3e 	add	lr,r4,r3<<0x3
800076a4:	06 92       	mov	r2,r3
800076a6:	1c 91       	mov	r1,lr
800076a8:	62 36       	ld.w	r6,r1[0xc]
800076aa:	c2 e8       	rjmp	80007706 <_malloc_r+0x27a>
800076ac:	6c 1a       	ld.w	r10,r6[0x4]
800076ae:	e0 1a ff fc 	andl	r10,0xfffc
800076b2:	f4 07 01 08 	sub	r8,r10,r7
800076b6:	58 f8       	cp.w	r8,15
800076b8:	e0 8a 00 15 	brle	800076e2 <_malloc_r+0x256>
800076bc:	6c 3a       	ld.w	r10,r6[0xc]
800076be:	6c 29       	ld.w	r9,r6[0x8]
800076c0:	95 29       	st.w	r10[0x8],r9
800076c2:	93 3a       	st.w	r9[0xc],r10
800076c4:	0e 99       	mov	r9,r7
800076c6:	ec 07 00 07 	add	r7,r6,r7
800076ca:	a1 a9       	sbr	r9,0x0
800076cc:	99 37       	st.w	r12[0xc],r7
800076ce:	99 27       	st.w	r12[0x8],r7
800076d0:	8d 19       	st.w	r6[0x4],r9
800076d2:	ee 08 09 08 	st.w	r7[r8],r8
800076d6:	8f 2c       	st.w	r7[0x8],r12
800076d8:	8f 3c       	st.w	r7[0xc],r12
800076da:	a1 a8       	sbr	r8,0x0
800076dc:	0a 9c       	mov	r12,r5
800076de:	8f 18       	st.w	r7[0x4],r8
800076e0:	c0 d8       	rjmp	800076fa <_malloc_r+0x26e>
800076e2:	6c 39       	ld.w	r9,r6[0xc]
800076e4:	58 08       	cp.w	r8,0
800076e6:	c0 f5       	brlt	80007704 <_malloc_r+0x278>
800076e8:	ec 0a 00 0a 	add	r10,r6,r10
800076ec:	74 18       	ld.w	r8,r10[0x4]
800076ee:	a1 a8       	sbr	r8,0x0
800076f0:	0a 9c       	mov	r12,r5
800076f2:	95 18       	st.w	r10[0x4],r8
800076f4:	6c 28       	ld.w	r8,r6[0x8]
800076f6:	93 28       	st.w	r9[0x8],r8
800076f8:	91 39       	st.w	r8[0xc],r9
800076fa:	fe b0 f4 89 	rcall	8000600c <__malloc_unlock>
800076fe:	ec cc ff f8 	sub	r12,r6,-8
80007702:	d8 32       	popm	r0-r7,pc
80007704:	12 96       	mov	r6,r9
80007706:	02 36       	cp.w	r6,r1
80007708:	cd 21       	brne	800076ac <_malloc_r+0x220>
8000770a:	2f f2       	sub	r2,-1
8000770c:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
80007710:	c0 30       	breq	80007716 <_malloc_r+0x28a>
80007712:	2f 81       	sub	r1,-8
80007714:	cc ab       	rjmp	800076a8 <_malloc_r+0x21c>
80007716:	1c 98       	mov	r8,lr
80007718:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
8000771c:	c0 81       	brne	8000772c <_malloc_r+0x2a0>
8000771e:	68 19       	ld.w	r9,r4[0x4]
80007720:	f6 08 11 ff 	rsub	r8,r11,-1
80007724:	f3 e8 00 08 	and	r8,r9,r8
80007728:	89 18       	st.w	r4[0x4],r8
8000772a:	c0 78       	rjmp	80007738 <_malloc_r+0x2ac>
8000772c:	f0 c9 00 08 	sub	r9,r8,8
80007730:	20 13       	sub	r3,1
80007732:	70 08       	ld.w	r8,r8[0x0]
80007734:	12 38       	cp.w	r8,r9
80007736:	cf 10       	breq	80007718 <_malloc_r+0x28c>
80007738:	a1 7b       	lsl	r11,0x1
8000773a:	68 18       	ld.w	r8,r4[0x4]
8000773c:	10 3b       	cp.w	r11,r8
8000773e:	e0 8b 00 0d 	brhi	80007758 <_malloc_r+0x2cc>
80007742:	58 0b       	cp.w	r11,0
80007744:	c0 a0       	breq	80007758 <_malloc_r+0x2cc>
80007746:	04 93       	mov	r3,r2
80007748:	c0 38       	rjmp	8000774e <_malloc_r+0x2c2>
8000774a:	2f c3       	sub	r3,-4
8000774c:	a1 7b       	lsl	r11,0x1
8000774e:	f7 e8 00 09 	and	r9,r11,r8
80007752:	ca 71       	brne	800076a0 <_malloc_r+0x214>
80007754:	cf bb       	rjmp	8000774a <_malloc_r+0x2be>
80007756:	d7 03       	nop
80007758:	68 23       	ld.w	r3,r4[0x8]
8000775a:	66 12       	ld.w	r2,r3[0x4]
8000775c:	e0 12 ff fc 	andl	r2,0xfffc
80007760:	0e 32       	cp.w	r2,r7
80007762:	5f 39       	srlo	r9
80007764:	e4 07 01 08 	sub	r8,r2,r7
80007768:	58 f8       	cp.w	r8,15
8000776a:	5f aa       	srle	r10
8000776c:	f5 e9 10 09 	or	r9,r10,r9
80007770:	e0 80 00 9a 	breq	800078a4 <_malloc_r+0x418>
80007774:	e0 68 0d 6c 	mov	r8,3436
80007778:	70 01       	ld.w	r1,r8[0x0]
8000777a:	e0 68 09 48 	mov	r8,2376
8000777e:	2f 01       	sub	r1,-16
80007780:	70 08       	ld.w	r8,r8[0x0]
80007782:	0e 01       	add	r1,r7
80007784:	5b f8       	cp.w	r8,-1
80007786:	c0 40       	breq	8000778e <_malloc_r+0x302>
80007788:	28 11       	sub	r1,-127
8000778a:	e0 11 ff 80 	andl	r1,0xff80
8000778e:	02 9b       	mov	r11,r1
80007790:	0a 9c       	mov	r12,r5
80007792:	e0 a0 02 a5 	rcall	80007cdc <_sbrk_r>
80007796:	18 96       	mov	r6,r12
80007798:	5b fc       	cp.w	r12,-1
8000779a:	c7 50       	breq	80007884 <_malloc_r+0x3f8>
8000779c:	e6 02 00 08 	add	r8,r3,r2
800077a0:	10 3c       	cp.w	r12,r8
800077a2:	c0 32       	brcc	800077a8 <_malloc_r+0x31c>
800077a4:	08 33       	cp.w	r3,r4
800077a6:	c6 f1       	brne	80007884 <_malloc_r+0x3f8>
800077a8:	e0 6a 0d 70 	mov	r10,3440
800077ac:	74 09       	ld.w	r9,r10[0x0]
800077ae:	e2 09 00 09 	add	r9,r1,r9
800077b2:	95 09       	st.w	r10[0x0],r9
800077b4:	10 36       	cp.w	r6,r8
800077b6:	c0 a1       	brne	800077ca <_malloc_r+0x33e>
800077b8:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
800077bc:	c0 71       	brne	800077ca <_malloc_r+0x33e>
800077be:	e2 02 00 02 	add	r2,r1,r2
800077c2:	68 28       	ld.w	r8,r4[0x8]
800077c4:	a1 a2       	sbr	r2,0x0
800077c6:	91 12       	st.w	r8[0x4],r2
800077c8:	c4 f8       	rjmp	80007866 <_malloc_r+0x3da>
800077ca:	e0 6a 09 48 	mov	r10,2376
800077ce:	74 0b       	ld.w	r11,r10[0x0]
800077d0:	5b fb       	cp.w	r11,-1
800077d2:	c0 31       	brne	800077d8 <_malloc_r+0x34c>
800077d4:	95 06       	st.w	r10[0x0],r6
800077d6:	c0 78       	rjmp	800077e4 <_malloc_r+0x358>
800077d8:	ec 09 00 09 	add	r9,r6,r9
800077dc:	e0 6a 0d 70 	mov	r10,3440
800077e0:	10 19       	sub	r9,r8
800077e2:	95 09       	st.w	r10[0x0],r9
800077e4:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
800077e8:	f0 09 11 08 	rsub	r9,r8,8
800077ec:	58 08       	cp.w	r8,0
800077ee:	f2 08 17 10 	movne	r8,r9
800077f2:	ed d8 e1 06 	addne	r6,r6,r8
800077f6:	28 08       	sub	r8,-128
800077f8:	ec 01 00 01 	add	r1,r6,r1
800077fc:	0a 9c       	mov	r12,r5
800077fe:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
80007802:	f0 01 01 01 	sub	r1,r8,r1
80007806:	02 9b       	mov	r11,r1
80007808:	e0 a0 02 6a 	rcall	80007cdc <_sbrk_r>
8000780c:	e0 68 0d 70 	mov	r8,3440
80007810:	5b fc       	cp.w	r12,-1
80007812:	ec 0c 17 00 	moveq	r12,r6
80007816:	f9 b1 00 00 	moveq	r1,0
8000781a:	70 09       	ld.w	r9,r8[0x0]
8000781c:	0c 1c       	sub	r12,r6
8000781e:	89 26       	st.w	r4[0x8],r6
80007820:	02 0c       	add	r12,r1
80007822:	12 01       	add	r1,r9
80007824:	a1 ac       	sbr	r12,0x0
80007826:	91 01       	st.w	r8[0x0],r1
80007828:	8d 1c       	st.w	r6[0x4],r12
8000782a:	08 33       	cp.w	r3,r4
8000782c:	c1 d0       	breq	80007866 <_malloc_r+0x3da>
8000782e:	58 f2       	cp.w	r2,15
80007830:	e0 8b 00 05 	brhi	8000783a <_malloc_r+0x3ae>
80007834:	30 18       	mov	r8,1
80007836:	8d 18       	st.w	r6[0x4],r8
80007838:	c2 68       	rjmp	80007884 <_malloc_r+0x3f8>
8000783a:	30 59       	mov	r9,5
8000783c:	20 c2       	sub	r2,12
8000783e:	e0 12 ff f8 	andl	r2,0xfff8
80007842:	e6 02 00 08 	add	r8,r3,r2
80007846:	91 29       	st.w	r8[0x8],r9
80007848:	91 19       	st.w	r8[0x4],r9
8000784a:	66 18       	ld.w	r8,r3[0x4]
8000784c:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007850:	e5 e8 10 08 	or	r8,r2,r8
80007854:	87 18       	st.w	r3[0x4],r8
80007856:	58 f2       	cp.w	r2,15
80007858:	e0 88 00 07 	brls	80007866 <_malloc_r+0x3da>
8000785c:	e6 cb ff f8 	sub	r11,r3,-8
80007860:	0a 9c       	mov	r12,r5
80007862:	e0 a0 1c 6b 	rcall	8000b138 <_free_r>
80007866:	e0 69 0d 68 	mov	r9,3432
8000786a:	72 0a       	ld.w	r10,r9[0x0]
8000786c:	e0 68 0d 70 	mov	r8,3440
80007870:	70 08       	ld.w	r8,r8[0x0]
80007872:	14 38       	cp.w	r8,r10
80007874:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80007878:	e0 69 0d 64 	mov	r9,3428
8000787c:	72 0a       	ld.w	r10,r9[0x0]
8000787e:	14 38       	cp.w	r8,r10
80007880:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80007884:	68 28       	ld.w	r8,r4[0x8]
80007886:	70 18       	ld.w	r8,r8[0x4]
80007888:	e0 18 ff fc 	andl	r8,0xfffc
8000788c:	0e 38       	cp.w	r8,r7
8000788e:	5f 39       	srlo	r9
80007890:	0e 18       	sub	r8,r7
80007892:	58 f8       	cp.w	r8,15
80007894:	5f aa       	srle	r10
80007896:	f5 e9 10 09 	or	r9,r10,r9
8000789a:	c0 50       	breq	800078a4 <_malloc_r+0x418>
8000789c:	0a 9c       	mov	r12,r5
8000789e:	fe b0 f3 b7 	rcall	8000600c <__malloc_unlock>
800078a2:	d8 3a       	popm	r0-r7,pc,r12=0
800078a4:	68 26       	ld.w	r6,r4[0x8]
800078a6:	a1 a8       	sbr	r8,0x0
800078a8:	0e 99       	mov	r9,r7
800078aa:	a1 a9       	sbr	r9,0x0
800078ac:	8d 19       	st.w	r6[0x4],r9
800078ae:	ec 07 00 07 	add	r7,r6,r7
800078b2:	0a 9c       	mov	r12,r5
800078b4:	89 27       	st.w	r4[0x8],r7
800078b6:	8f 18       	st.w	r7[0x4],r8
800078b8:	fe b0 f3 aa 	rcall	8000600c <__malloc_unlock>
800078bc:	ec cc ff f8 	sub	r12,r6,-8
800078c0:	d8 32       	popm	r0-r7,pc
800078c2:	d7 03       	nop

800078c4 <memcpy>:
800078c4:	58 8a       	cp.w	r10,8
800078c6:	c2 f5       	brlt	80007924 <memcpy+0x60>
800078c8:	f9 eb 10 09 	or	r9,r12,r11
800078cc:	e2 19 00 03 	andl	r9,0x3,COH
800078d0:	e0 81 00 97 	brne	800079fe <memcpy+0x13a>
800078d4:	e0 4a 00 20 	cp.w	r10,32
800078d8:	c3 b4       	brge	8000794e <memcpy+0x8a>
800078da:	f4 08 14 02 	asr	r8,r10,0x2
800078de:	f0 09 11 08 	rsub	r9,r8,8
800078e2:	fe 09 00 2f 	add	pc,pc,r9<<0x2
800078e6:	76 69       	ld.w	r9,r11[0x18]
800078e8:	99 69       	st.w	r12[0x18],r9
800078ea:	76 59       	ld.w	r9,r11[0x14]
800078ec:	99 59       	st.w	r12[0x14],r9
800078ee:	76 49       	ld.w	r9,r11[0x10]
800078f0:	99 49       	st.w	r12[0x10],r9
800078f2:	76 39       	ld.w	r9,r11[0xc]
800078f4:	99 39       	st.w	r12[0xc],r9
800078f6:	76 29       	ld.w	r9,r11[0x8]
800078f8:	99 29       	st.w	r12[0x8],r9
800078fa:	76 19       	ld.w	r9,r11[0x4]
800078fc:	99 19       	st.w	r12[0x4],r9
800078fe:	76 09       	ld.w	r9,r11[0x0]
80007900:	99 09       	st.w	r12[0x0],r9
80007902:	f6 08 00 2b 	add	r11,r11,r8<<0x2
80007906:	f8 08 00 28 	add	r8,r12,r8<<0x2
8000790a:	e0 1a 00 03 	andl	r10,0x3
8000790e:	f4 0a 11 04 	rsub	r10,r10,4
80007912:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
80007916:	17 a9       	ld.ub	r9,r11[0x2]
80007918:	b0 a9       	st.b	r8[0x2],r9
8000791a:	17 99       	ld.ub	r9,r11[0x1]
8000791c:	b0 99       	st.b	r8[0x1],r9
8000791e:	17 89       	ld.ub	r9,r11[0x0]
80007920:	b0 89       	st.b	r8[0x0],r9
80007922:	5e fc       	retal	r12
80007924:	f4 0a 11 09 	rsub	r10,r10,9
80007928:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
8000792c:	17 f9       	ld.ub	r9,r11[0x7]
8000792e:	b8 f9       	st.b	r12[0x7],r9
80007930:	17 e9       	ld.ub	r9,r11[0x6]
80007932:	b8 e9       	st.b	r12[0x6],r9
80007934:	17 d9       	ld.ub	r9,r11[0x5]
80007936:	b8 d9       	st.b	r12[0x5],r9
80007938:	17 c9       	ld.ub	r9,r11[0x4]
8000793a:	b8 c9       	st.b	r12[0x4],r9
8000793c:	17 b9       	ld.ub	r9,r11[0x3]
8000793e:	b8 b9       	st.b	r12[0x3],r9
80007940:	17 a9       	ld.ub	r9,r11[0x2]
80007942:	b8 a9       	st.b	r12[0x2],r9
80007944:	17 99       	ld.ub	r9,r11[0x1]
80007946:	b8 99       	st.b	r12[0x1],r9
80007948:	17 89       	ld.ub	r9,r11[0x0]
8000794a:	b8 89       	st.b	r12[0x0],r9
8000794c:	5e fc       	retal	r12
8000794e:	eb cd 40 c0 	pushm	r6-r7,lr
80007952:	18 99       	mov	r9,r12
80007954:	22 0a       	sub	r10,32
80007956:	b7 07       	ld.d	r6,r11++
80007958:	b3 26       	st.d	r9++,r6
8000795a:	b7 07       	ld.d	r6,r11++
8000795c:	b3 26       	st.d	r9++,r6
8000795e:	b7 07       	ld.d	r6,r11++
80007960:	b3 26       	st.d	r9++,r6
80007962:	b7 07       	ld.d	r6,r11++
80007964:	b3 26       	st.d	r9++,r6
80007966:	22 0a       	sub	r10,32
80007968:	cf 74       	brge	80007956 <memcpy+0x92>
8000796a:	2f 0a       	sub	r10,-16
8000796c:	c0 65       	brlt	80007978 <memcpy+0xb4>
8000796e:	b7 07       	ld.d	r6,r11++
80007970:	b3 26       	st.d	r9++,r6
80007972:	b7 07       	ld.d	r6,r11++
80007974:	b3 26       	st.d	r9++,r6
80007976:	21 0a       	sub	r10,16
80007978:	5c 3a       	neg	r10
8000797a:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
8000797e:	d7 03       	nop
80007980:	d7 03       	nop
80007982:	f7 36 00 0e 	ld.ub	r6,r11[14]
80007986:	f3 66 00 0e 	st.b	r9[14],r6
8000798a:	f7 36 00 0d 	ld.ub	r6,r11[13]
8000798e:	f3 66 00 0d 	st.b	r9[13],r6
80007992:	f7 36 00 0c 	ld.ub	r6,r11[12]
80007996:	f3 66 00 0c 	st.b	r9[12],r6
8000799a:	f7 36 00 0b 	ld.ub	r6,r11[11]
8000799e:	f3 66 00 0b 	st.b	r9[11],r6
800079a2:	f7 36 00 0a 	ld.ub	r6,r11[10]
800079a6:	f3 66 00 0a 	st.b	r9[10],r6
800079aa:	f7 36 00 09 	ld.ub	r6,r11[9]
800079ae:	f3 66 00 09 	st.b	r9[9],r6
800079b2:	f7 36 00 08 	ld.ub	r6,r11[8]
800079b6:	f3 66 00 08 	st.b	r9[8],r6
800079ba:	f7 36 00 07 	ld.ub	r6,r11[7]
800079be:	f3 66 00 07 	st.b	r9[7],r6
800079c2:	f7 36 00 06 	ld.ub	r6,r11[6]
800079c6:	f3 66 00 06 	st.b	r9[6],r6
800079ca:	f7 36 00 05 	ld.ub	r6,r11[5]
800079ce:	f3 66 00 05 	st.b	r9[5],r6
800079d2:	f7 36 00 04 	ld.ub	r6,r11[4]
800079d6:	f3 66 00 04 	st.b	r9[4],r6
800079da:	f7 36 00 03 	ld.ub	r6,r11[3]
800079de:	f3 66 00 03 	st.b	r9[3],r6
800079e2:	f7 36 00 02 	ld.ub	r6,r11[2]
800079e6:	f3 66 00 02 	st.b	r9[2],r6
800079ea:	f7 36 00 01 	ld.ub	r6,r11[1]
800079ee:	f3 66 00 01 	st.b	r9[1],r6
800079f2:	f7 36 00 00 	ld.ub	r6,r11[0]
800079f6:	f3 66 00 00 	st.b	r9[0],r6
800079fa:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800079fe:	20 1a       	sub	r10,1
80007a00:	f6 0a 07 09 	ld.ub	r9,r11[r10]
80007a04:	f8 0a 0b 09 	st.b	r12[r10],r9
80007a08:	cf b1       	brne	800079fe <memcpy+0x13a>
80007a0a:	5e fc       	retal	r12

80007a0c <memset>:
80007a0c:	18 98       	mov	r8,r12
80007a0e:	c0 38       	rjmp	80007a14 <memset+0x8>
80007a10:	10 cb       	st.b	r8++,r11
80007a12:	20 1a       	sub	r10,1
80007a14:	58 0a       	cp.w	r10,0
80007a16:	cf d1       	brne	80007a10 <memset+0x4>
80007a18:	5e fc       	retal	r12
80007a1a:	d7 03       	nop

80007a1c <_realloc_r>:
80007a1c:	d4 31       	pushm	r0-r7,lr
80007a1e:	20 1d       	sub	sp,4
80007a20:	16 94       	mov	r4,r11
80007a22:	18 92       	mov	r2,r12
80007a24:	14 9b       	mov	r11,r10
80007a26:	58 04       	cp.w	r4,0
80007a28:	c0 51       	brne	80007a32 <_realloc_r+0x16>
80007a2a:	fe b0 fd 31 	rcall	8000748c <_malloc_r>
80007a2e:	18 95       	mov	r5,r12
80007a30:	c5 39       	rjmp	80007cd6 <_realloc_r+0x2ba>
80007a32:	50 0a       	stdsp	sp[0x0],r10
80007a34:	fe b0 f2 e6 	rcall	80006000 <__malloc_lock>
80007a38:	40 0b       	lddsp	r11,sp[0x0]
80007a3a:	f6 c8 ff f5 	sub	r8,r11,-11
80007a3e:	e8 c1 00 08 	sub	r1,r4,8
80007a42:	10 96       	mov	r6,r8
80007a44:	62 1c       	ld.w	r12,r1[0x4]
80007a46:	e0 16 ff f8 	andl	r6,0xfff8
80007a4a:	59 68       	cp.w	r8,22
80007a4c:	f9 b6 08 10 	movls	r6,16
80007a50:	16 36       	cp.w	r6,r11
80007a52:	5f 38       	srlo	r8
80007a54:	f1 e6 13 f8 	or	r8,r8,r6>>0x1f
80007a58:	c0 50       	breq	80007a62 <_realloc_r+0x46>
80007a5a:	30 c8       	mov	r8,12
80007a5c:	30 05       	mov	r5,0
80007a5e:	85 38       	st.w	r2[0xc],r8
80007a60:	c3 b9       	rjmp	80007cd6 <_realloc_r+0x2ba>
80007a62:	18 90       	mov	r0,r12
80007a64:	e0 10 ff fc 	andl	r0,0xfffc
80007a68:	0c 30       	cp.w	r0,r6
80007a6a:	e0 84 01 0b 	brge	80007c80 <_realloc_r+0x264>
80007a6e:	e0 68 05 3c 	mov	r8,1340
80007a72:	e2 00 00 09 	add	r9,r1,r0
80007a76:	70 25       	ld.w	r5,r8[0x8]
80007a78:	0a 39       	cp.w	r9,r5
80007a7a:	c0 90       	breq	80007a8c <_realloc_r+0x70>
80007a7c:	72 1a       	ld.w	r10,r9[0x4]
80007a7e:	a1 ca       	cbr	r10,0x0
80007a80:	f2 0a 00 0a 	add	r10,r9,r10
80007a84:	74 1a       	ld.w	r10,r10[0x4]
80007a86:	ed ba 00 00 	bld	r10,0x0
80007a8a:	c2 20       	breq	80007ace <_realloc_r+0xb2>
80007a8c:	72 1a       	ld.w	r10,r9[0x4]
80007a8e:	e0 1a ff fc 	andl	r10,0xfffc
80007a92:	f4 00 00 03 	add	r3,r10,r0
80007a96:	0a 39       	cp.w	r9,r5
80007a98:	c1 31       	brne	80007abe <_realloc_r+0xa2>
80007a9a:	ec c7 ff f0 	sub	r7,r6,-16
80007a9e:	0e 33       	cp.w	r3,r7
80007aa0:	c1 95       	brlt	80007ad2 <_realloc_r+0xb6>
80007aa2:	e2 06 00 09 	add	r9,r1,r6
80007aa6:	0c 13       	sub	r3,r6
80007aa8:	a1 a3       	sbr	r3,0x0
80007aaa:	93 13       	st.w	r9[0x4],r3
80007aac:	91 29       	st.w	r8[0x8],r9
80007aae:	04 9c       	mov	r12,r2
80007ab0:	62 18       	ld.w	r8,r1[0x4]
80007ab2:	08 95       	mov	r5,r4
80007ab4:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007ab8:	10 46       	or	r6,r8
80007aba:	83 16       	st.w	r1[0x4],r6
80007abc:	c0 b9       	rjmp	80007cd2 <_realloc_r+0x2b6>
80007abe:	0c 33       	cp.w	r3,r6
80007ac0:	c0 95       	brlt	80007ad2 <_realloc_r+0xb6>
80007ac2:	72 28       	ld.w	r8,r9[0x8]
80007ac4:	02 97       	mov	r7,r1
80007ac6:	72 39       	ld.w	r9,r9[0xc]
80007ac8:	93 28       	st.w	r9[0x8],r8
80007aca:	91 39       	st.w	r8[0xc],r9
80007acc:	cd c8       	rjmp	80007c84 <_realloc_r+0x268>
80007ace:	30 0a       	mov	r10,0
80007ad0:	14 99       	mov	r9,r10
80007ad2:	ed bc 00 00 	bld	r12,0x0
80007ad6:	e0 80 00 95 	breq	80007c00 <_realloc_r+0x1e4>
80007ada:	62 07       	ld.w	r7,r1[0x0]
80007adc:	e2 07 01 07 	sub	r7,r1,r7
80007ae0:	6e 1c       	ld.w	r12,r7[0x4]
80007ae2:	e0 1c ff fc 	andl	r12,0xfffc
80007ae6:	58 09       	cp.w	r9,0
80007ae8:	c5 60       	breq	80007b94 <_realloc_r+0x178>
80007aea:	f8 00 00 03 	add	r3,r12,r0
80007aee:	0a 39       	cp.w	r9,r5
80007af0:	c4 81       	brne	80007b80 <_realloc_r+0x164>
80007af2:	14 03       	add	r3,r10
80007af4:	ec c9 ff f0 	sub	r9,r6,-16
80007af8:	12 33       	cp.w	r3,r9
80007afa:	c4 d5       	brlt	80007b94 <_realloc_r+0x178>
80007afc:	6e 3a       	ld.w	r10,r7[0xc]
80007afe:	6e 29       	ld.w	r9,r7[0x8]
80007b00:	95 29       	st.w	r10[0x8],r9
80007b02:	93 3a       	st.w	r9[0xc],r10
80007b04:	ee c5 ff f8 	sub	r5,r7,-8
80007b08:	e0 ca 00 04 	sub	r10,r0,4
80007b0c:	e0 4a 00 24 	cp.w	r10,36
80007b10:	e0 8b 00 25 	brhi	80007b5a <_realloc_r+0x13e>
80007b14:	0a 99       	mov	r9,r5
80007b16:	59 3a       	cp.w	r10,19
80007b18:	e0 88 00 1a 	brls	80007b4c <_realloc_r+0x130>
80007b1c:	09 09       	ld.w	r9,r4++
80007b1e:	8b 09       	st.w	r5[0x0],r9
80007b20:	09 09       	ld.w	r9,r4++
80007b22:	8f 39       	st.w	r7[0xc],r9
80007b24:	ee c9 ff f0 	sub	r9,r7,-16
80007b28:	59 ba       	cp.w	r10,27
80007b2a:	e0 88 00 11 	brls	80007b4c <_realloc_r+0x130>
80007b2e:	09 0b       	ld.w	r11,r4++
80007b30:	93 0b       	st.w	r9[0x0],r11
80007b32:	09 09       	ld.w	r9,r4++
80007b34:	8f 59       	st.w	r7[0x14],r9
80007b36:	ee c9 ff e8 	sub	r9,r7,-24
80007b3a:	e0 4a 00 24 	cp.w	r10,36
80007b3e:	c0 71       	brne	80007b4c <_realloc_r+0x130>
80007b40:	09 0a       	ld.w	r10,r4++
80007b42:	93 0a       	st.w	r9[0x0],r10
80007b44:	ee c9 ff e0 	sub	r9,r7,-32
80007b48:	09 0a       	ld.w	r10,r4++
80007b4a:	8f 7a       	st.w	r7[0x1c],r10
80007b4c:	09 0a       	ld.w	r10,r4++
80007b4e:	12 aa       	st.w	r9++,r10
80007b50:	68 0a       	ld.w	r10,r4[0x0]
80007b52:	93 0a       	st.w	r9[0x0],r10
80007b54:	68 1a       	ld.w	r10,r4[0x4]
80007b56:	93 1a       	st.w	r9[0x4],r10
80007b58:	c0 78       	rjmp	80007b66 <_realloc_r+0x14a>
80007b5a:	50 08       	stdsp	sp[0x0],r8
80007b5c:	08 9b       	mov	r11,r4
80007b5e:	0a 9c       	mov	r12,r5
80007b60:	e0 a0 1d 8f 	rcall	8000b67e <memmove>
80007b64:	40 08       	lddsp	r8,sp[0x0]
80007b66:	ee 06 00 09 	add	r9,r7,r6
80007b6a:	0c 13       	sub	r3,r6
80007b6c:	a1 a3       	sbr	r3,0x0
80007b6e:	93 13       	st.w	r9[0x4],r3
80007b70:	91 29       	st.w	r8[0x8],r9
80007b72:	04 9c       	mov	r12,r2
80007b74:	6e 18       	ld.w	r8,r7[0x4]
80007b76:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007b7a:	10 46       	or	r6,r8
80007b7c:	8f 16       	st.w	r7[0x4],r6
80007b7e:	ca a8       	rjmp	80007cd2 <_realloc_r+0x2b6>
80007b80:	14 03       	add	r3,r10
80007b82:	0c 33       	cp.w	r3,r6
80007b84:	c0 85       	brlt	80007b94 <_realloc_r+0x178>
80007b86:	72 28       	ld.w	r8,r9[0x8]
80007b88:	72 39       	ld.w	r9,r9[0xc]
80007b8a:	93 28       	st.w	r9[0x8],r8
80007b8c:	91 39       	st.w	r8[0xc],r9
80007b8e:	6e 28       	ld.w	r8,r7[0x8]
80007b90:	6e 39       	ld.w	r9,r7[0xc]
80007b92:	c0 78       	rjmp	80007ba0 <_realloc_r+0x184>
80007b94:	f8 00 00 03 	add	r3,r12,r0
80007b98:	0c 33       	cp.w	r3,r6
80007b9a:	c3 35       	brlt	80007c00 <_realloc_r+0x1e4>
80007b9c:	6e 39       	ld.w	r9,r7[0xc]
80007b9e:	6e 28       	ld.w	r8,r7[0x8]
80007ba0:	93 28       	st.w	r9[0x8],r8
80007ba2:	91 39       	st.w	r8[0xc],r9
80007ba4:	e0 ca 00 04 	sub	r10,r0,4
80007ba8:	ee cc ff f8 	sub	r12,r7,-8
80007bac:	e0 4a 00 24 	cp.w	r10,36
80007bb0:	e0 8b 00 24 	brhi	80007bf8 <_realloc_r+0x1dc>
80007bb4:	59 3a       	cp.w	r10,19
80007bb6:	e0 88 00 1a 	brls	80007bea <_realloc_r+0x1ce>
80007bba:	09 08       	ld.w	r8,r4++
80007bbc:	99 08       	st.w	r12[0x0],r8
80007bbe:	09 08       	ld.w	r8,r4++
80007bc0:	8f 38       	st.w	r7[0xc],r8
80007bc2:	ee cc ff f0 	sub	r12,r7,-16
80007bc6:	59 ba       	cp.w	r10,27
80007bc8:	e0 88 00 11 	brls	80007bea <_realloc_r+0x1ce>
80007bcc:	09 08       	ld.w	r8,r4++
80007bce:	99 08       	st.w	r12[0x0],r8
80007bd0:	09 08       	ld.w	r8,r4++
80007bd2:	8f 58       	st.w	r7[0x14],r8
80007bd4:	ee cc ff e8 	sub	r12,r7,-24
80007bd8:	e0 4a 00 24 	cp.w	r10,36
80007bdc:	c0 71       	brne	80007bea <_realloc_r+0x1ce>
80007bde:	09 08       	ld.w	r8,r4++
80007be0:	99 08       	st.w	r12[0x0],r8
80007be2:	ee cc ff e0 	sub	r12,r7,-32
80007be6:	09 08       	ld.w	r8,r4++
80007be8:	8f 78       	st.w	r7[0x1c],r8
80007bea:	09 08       	ld.w	r8,r4++
80007bec:	18 a8       	st.w	r12++,r8
80007bee:	68 08       	ld.w	r8,r4[0x0]
80007bf0:	99 08       	st.w	r12[0x0],r8
80007bf2:	68 18       	ld.w	r8,r4[0x4]
80007bf4:	99 18       	st.w	r12[0x4],r8
80007bf6:	c4 78       	rjmp	80007c84 <_realloc_r+0x268>
80007bf8:	08 9b       	mov	r11,r4
80007bfa:	e0 a0 1d 42 	rcall	8000b67e <memmove>
80007bfe:	c4 38       	rjmp	80007c84 <_realloc_r+0x268>
80007c00:	04 9c       	mov	r12,r2
80007c02:	fe b0 fc 45 	rcall	8000748c <_malloc_r>
80007c06:	18 95       	mov	r5,r12
80007c08:	c3 a0       	breq	80007c7c <_realloc_r+0x260>
80007c0a:	62 18       	ld.w	r8,r1[0x4]
80007c0c:	f8 c9 00 08 	sub	r9,r12,8
80007c10:	a1 c8       	cbr	r8,0x0
80007c12:	e2 08 00 08 	add	r8,r1,r8
80007c16:	10 39       	cp.w	r9,r8
80007c18:	c0 71       	brne	80007c26 <_realloc_r+0x20a>
80007c1a:	72 13       	ld.w	r3,r9[0x4]
80007c1c:	02 97       	mov	r7,r1
80007c1e:	e0 13 ff fc 	andl	r3,0xfffc
80007c22:	00 03       	add	r3,r0
80007c24:	c3 08       	rjmp	80007c84 <_realloc_r+0x268>
80007c26:	e0 ca 00 04 	sub	r10,r0,4
80007c2a:	e0 4a 00 24 	cp.w	r10,36
80007c2e:	e0 8b 00 20 	brhi	80007c6e <_realloc_r+0x252>
80007c32:	08 99       	mov	r9,r4
80007c34:	18 98       	mov	r8,r12
80007c36:	59 3a       	cp.w	r10,19
80007c38:	e0 88 00 14 	brls	80007c60 <_realloc_r+0x244>
80007c3c:	13 0b       	ld.w	r11,r9++
80007c3e:	10 ab       	st.w	r8++,r11
80007c40:	13 0b       	ld.w	r11,r9++
80007c42:	10 ab       	st.w	r8++,r11
80007c44:	59 ba       	cp.w	r10,27
80007c46:	e0 88 00 0d 	brls	80007c60 <_realloc_r+0x244>
80007c4a:	13 0b       	ld.w	r11,r9++
80007c4c:	10 ab       	st.w	r8++,r11
80007c4e:	13 0b       	ld.w	r11,r9++
80007c50:	10 ab       	st.w	r8++,r11
80007c52:	e0 4a 00 24 	cp.w	r10,36
80007c56:	c0 51       	brne	80007c60 <_realloc_r+0x244>
80007c58:	13 0a       	ld.w	r10,r9++
80007c5a:	10 aa       	st.w	r8++,r10
80007c5c:	13 0a       	ld.w	r10,r9++
80007c5e:	10 aa       	st.w	r8++,r10
80007c60:	13 0a       	ld.w	r10,r9++
80007c62:	10 aa       	st.w	r8++,r10
80007c64:	72 0a       	ld.w	r10,r9[0x0]
80007c66:	91 0a       	st.w	r8[0x0],r10
80007c68:	72 19       	ld.w	r9,r9[0x4]
80007c6a:	91 19       	st.w	r8[0x4],r9
80007c6c:	c0 48       	rjmp	80007c74 <_realloc_r+0x258>
80007c6e:	08 9b       	mov	r11,r4
80007c70:	e0 a0 1d 07 	rcall	8000b67e <memmove>
80007c74:	08 9b       	mov	r11,r4
80007c76:	04 9c       	mov	r12,r2
80007c78:	e0 a0 1a 60 	rcall	8000b138 <_free_r>
80007c7c:	04 9c       	mov	r12,r2
80007c7e:	c2 a8       	rjmp	80007cd2 <_realloc_r+0x2b6>
80007c80:	00 93       	mov	r3,r0
80007c82:	02 97       	mov	r7,r1
80007c84:	e6 06 01 09 	sub	r9,r3,r6
80007c88:	6e 18       	ld.w	r8,r7[0x4]
80007c8a:	58 f9       	cp.w	r9,15
80007c8c:	e0 88 00 16 	brls	80007cb8 <_realloc_r+0x29c>
80007c90:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007c94:	ed e8 10 08 	or	r8,r6,r8
80007c98:	8f 18       	st.w	r7[0x4],r8
80007c9a:	12 98       	mov	r8,r9
80007c9c:	a1 a8       	sbr	r8,0x0
80007c9e:	ee 06 00 0b 	add	r11,r7,r6
80007ca2:	f6 09 00 09 	add	r9,r11,r9
80007ca6:	97 18       	st.w	r11[0x4],r8
80007ca8:	72 18       	ld.w	r8,r9[0x4]
80007caa:	a1 a8       	sbr	r8,0x0
80007cac:	2f 8b       	sub	r11,-8
80007cae:	93 18       	st.w	r9[0x4],r8
80007cb0:	04 9c       	mov	r12,r2
80007cb2:	e0 a0 1a 43 	rcall	8000b138 <_free_r>
80007cb6:	c0 b8       	rjmp	80007ccc <_realloc_r+0x2b0>
80007cb8:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007cbc:	e7 e8 10 08 	or	r8,r3,r8
80007cc0:	8f 18       	st.w	r7[0x4],r8
80007cc2:	ee 03 00 03 	add	r3,r7,r3
80007cc6:	66 18       	ld.w	r8,r3[0x4]
80007cc8:	a1 a8       	sbr	r8,0x0
80007cca:	87 18       	st.w	r3[0x4],r8
80007ccc:	04 9c       	mov	r12,r2
80007cce:	ee c5 ff f8 	sub	r5,r7,-8
80007cd2:	fe b0 f1 9d 	rcall	8000600c <__malloc_unlock>
80007cd6:	0a 9c       	mov	r12,r5
80007cd8:	2f fd       	sub	sp,-4
80007cda:	d8 32       	popm	r0-r7,pc

80007cdc <_sbrk_r>:
80007cdc:	d4 21       	pushm	r4-r7,lr
80007cde:	30 08       	mov	r8,0
80007ce0:	18 97       	mov	r7,r12
80007ce2:	e0 66 bf f8 	mov	r6,49144
80007ce6:	16 9c       	mov	r12,r11
80007ce8:	8d 08       	st.w	r6[0x0],r8
80007cea:	c8 5c       	rcall	80007df4 <_sbrk>
80007cec:	5b fc       	cp.w	r12,-1
80007cee:	c0 51       	brne	80007cf8 <_sbrk_r+0x1c>
80007cf0:	6c 08       	ld.w	r8,r6[0x0]
80007cf2:	58 08       	cp.w	r8,0
80007cf4:	ef f8 1a 03 	st.wne	r7[0xc],r8
80007cf8:	d8 22       	popm	r4-r7,pc
80007cfa:	d7 03       	nop

80007cfc <sprintf>:
80007cfc:	d4 01       	pushm	lr
80007cfe:	21 7d       	sub	sp,92
80007d00:	e0 68 ff ff 	mov	r8,65535
80007d04:	ea 18 7f ff 	orh	r8,0x7fff
80007d08:	50 58       	stdsp	sp[0x14],r8
80007d0a:	50 28       	stdsp	sp[0x8],r8
80007d0c:	e0 68 02 08 	mov	r8,520
80007d10:	ba 68       	st.h	sp[0xc],r8
80007d12:	3f f8       	mov	r8,-1
80007d14:	ba 78       	st.h	sp[0xe],r8
80007d16:	e0 68 0a 3c 	mov	r8,2620
80007d1a:	50 4c       	stdsp	sp[0x10],r12
80007d1c:	16 9a       	mov	r10,r11
80007d1e:	50 0c       	stdsp	sp[0x0],r12
80007d20:	fa c9 ff a0 	sub	r9,sp,-96
80007d24:	70 0c       	ld.w	r12,r8[0x0]
80007d26:	1a 9b       	mov	r11,sp
80007d28:	e0 a0 02 1a 	rcall	8000815c <_vfprintf_r>
80007d2c:	30 09       	mov	r9,0
80007d2e:	40 08       	lddsp	r8,sp[0x0]
80007d30:	b0 89       	st.b	r8[0x0],r9
80007d32:	2e 9d       	sub	sp,-92
80007d34:	d8 02       	popm	pc
80007d36:	d7 03       	nop

80007d38 <strncpy>:
80007d38:	30 08       	mov	r8,0
80007d3a:	10 3a       	cp.w	r10,r8
80007d3c:	5e 0c       	reteq	r12
80007d3e:	f6 08 07 09 	ld.ub	r9,r11[r8]
80007d42:	f8 08 0b 09 	st.b	r12[r8],r9
80007d46:	2f f8       	sub	r8,-1
80007d48:	58 09       	cp.w	r9,0
80007d4a:	cf 81       	brne	80007d3a <strncpy+0x2>
80007d4c:	10 3a       	cp.w	r10,r8
80007d4e:	5e 0c       	reteq	r12
80007d50:	f8 08 0b 09 	st.b	r12[r8],r9
80007d54:	2f f8       	sub	r8,-1
80007d56:	cf bb       	rjmp	80007d4c <strncpy+0x14>

80007d58 <_close>:
80007d58:	30 28       	mov	r8,2
80007d5a:	d6 73       	breakpoint
80007d5c:	3f fc       	mov	r12,-1
80007d5e:	35 8b       	mov	r11,88
80007d60:	58 0c       	cp.w	r12,0
80007d62:	5e 4c       	retge	r12
80007d64:	e0 6a bf f8 	mov	r10,49144
80007d68:	95 0b       	st.w	r10[0x0],r11
80007d6a:	5e fc       	retal	r12

80007d6c <_lseek>:
80007d6c:	30 58       	mov	r8,5
80007d6e:	d6 73       	breakpoint
80007d70:	3f fc       	mov	r12,-1
80007d72:	35 8b       	mov	r11,88
80007d74:	58 0c       	cp.w	r12,0
80007d76:	5e 4c       	retge	r12
80007d78:	e0 6a bf f8 	mov	r10,49144
80007d7c:	95 0b       	st.w	r10[0x0],r11
80007d7e:	5e fc       	retal	r12

80007d80 <isatty>:
80007d80:	30 b8       	mov	r8,11
80007d82:	d6 73       	breakpoint
80007d84:	3f fc       	mov	r12,-1
80007d86:	35 8b       	mov	r11,88
80007d88:	58 0c       	cp.w	r12,0
80007d8a:	5e 4c       	retge	r12
80007d8c:	e0 6a bf f8 	mov	r10,49144
80007d90:	95 0b       	st.w	r10[0x0],r11
80007d92:	5e fc       	retal	r12

80007d94 <_fstat_host>:
80007d94:	30 98       	mov	r8,9
80007d96:	d6 73       	breakpoint
80007d98:	3f fc       	mov	r12,-1
80007d9a:	35 8b       	mov	r11,88
80007d9c:	58 0c       	cp.w	r12,0
80007d9e:	5e 4c       	retge	r12
80007da0:	e0 6a bf f8 	mov	r10,49144
80007da4:	95 0b       	st.w	r10[0x0],r11
80007da6:	5e fc       	retal	r12

80007da8 <_fstat>:
80007da8:	d4 21       	pushm	r4-r7,lr
80007daa:	21 0d       	sub	sp,64
80007dac:	16 97       	mov	r7,r11
80007dae:	1a 9b       	mov	r11,sp
80007db0:	cf 2f       	rcall	80007d94 <_fstat_host>
80007db2:	c0 34       	brge	80007db8 <_fstat+0x10>
80007db4:	3f fc       	mov	r12,-1
80007db6:	c1 c8       	rjmp	80007dee <_fstat+0x46>
80007db8:	40 08       	lddsp	r8,sp[0x0]
80007dba:	ae 08       	st.h	r7[0x0],r8
80007dbc:	40 18       	lddsp	r8,sp[0x4]
80007dbe:	ae 18       	st.h	r7[0x2],r8
80007dc0:	40 28       	lddsp	r8,sp[0x8]
80007dc2:	8f 18       	st.w	r7[0x4],r8
80007dc4:	40 38       	lddsp	r8,sp[0xc]
80007dc6:	ae 48       	st.h	r7[0x8],r8
80007dc8:	40 48       	lddsp	r8,sp[0x10]
80007dca:	ae 58       	st.h	r7[0xa],r8
80007dcc:	40 58       	lddsp	r8,sp[0x14]
80007dce:	ae 68       	st.h	r7[0xc],r8
80007dd0:	40 68       	lddsp	r8,sp[0x18]
80007dd2:	ae 78       	st.h	r7[0xe],r8
80007dd4:	40 88       	lddsp	r8,sp[0x20]
80007dd6:	8f 48       	st.w	r7[0x10],r8
80007dd8:	40 a8       	lddsp	r8,sp[0x28]
80007dda:	8f b8       	st.w	r7[0x2c],r8
80007ddc:	40 c8       	lddsp	r8,sp[0x30]
80007dde:	8f c8       	st.w	r7[0x30],r8
80007de0:	40 d8       	lddsp	r8,sp[0x34]
80007de2:	8f 58       	st.w	r7[0x14],r8
80007de4:	40 e8       	lddsp	r8,sp[0x38]
80007de6:	30 0c       	mov	r12,0
80007de8:	8f 78       	st.w	r7[0x1c],r8
80007dea:	40 f8       	lddsp	r8,sp[0x3c]
80007dec:	8f 98       	st.w	r7[0x24],r8
80007dee:	2f 0d       	sub	sp,-64
80007df0:	d8 22       	popm	r4-r7,pc
80007df2:	d7 03       	nop

80007df4 <_sbrk>:
80007df4:	d4 01       	pushm	lr
80007df6:	e0 68 0d 98 	mov	r8,3480
80007dfa:	70 09       	ld.w	r9,r8[0x0]
80007dfc:	58 09       	cp.w	r9,0
80007dfe:	c0 41       	brne	80007e06 <_sbrk+0x12>
80007e00:	e0 69 c0 00 	mov	r9,49152
80007e04:	91 09       	st.w	r8[0x0],r9
80007e06:	e0 69 0d 98 	mov	r9,3480
80007e0a:	e0 7a 70 00 	mov	r10,94208
80007e0e:	72 08       	ld.w	r8,r9[0x0]
80007e10:	f0 0c 00 0c 	add	r12,r8,r12
80007e14:	14 3c       	cp.w	r12,r10
80007e16:	e0 8b 00 04 	brhi	80007e1e <_sbrk+0x2a>
80007e1a:	93 0c       	st.w	r9[0x0],r12
80007e1c:	c0 68       	rjmp	80007e28 <_sbrk+0x34>
80007e1e:	e0 a0 18 15 	rcall	8000ae48 <__errno>
80007e22:	30 c8       	mov	r8,12
80007e24:	99 08       	st.w	r12[0x0],r8
80007e26:	3f f8       	mov	r8,-1
80007e28:	10 9c       	mov	r12,r8
80007e2a:	d8 02       	popm	pc

80007e2c <get_arg>:
80007e2c:	d4 31       	pushm	r0-r7,lr
80007e2e:	20 8d       	sub	sp,32
80007e30:	fa c4 ff bc 	sub	r4,sp,-68
80007e34:	50 4b       	stdsp	sp[0x10],r11
80007e36:	68 2e       	ld.w	lr,r4[0x8]
80007e38:	50 58       	stdsp	sp[0x14],r8
80007e3a:	12 96       	mov	r6,r9
80007e3c:	7c 0b       	ld.w	r11,lr[0x0]
80007e3e:	70 05       	ld.w	r5,r8[0x0]
80007e40:	50 6e       	stdsp	sp[0x18],lr
80007e42:	58 0b       	cp.w	r11,0
80007e44:	f4 0b 17 00 	moveq	r11,r10
80007e48:	68 03       	ld.w	r3,r4[0x0]
80007e4a:	68 11       	ld.w	r1,r4[0x4]
80007e4c:	40 49       	lddsp	r9,sp[0x10]
80007e4e:	30 08       	mov	r8,0
80007e50:	c2 89       	rjmp	800080a0 <get_arg+0x274>
80007e52:	2f fb       	sub	r11,-1
80007e54:	32 5c       	mov	r12,37
80007e56:	17 8a       	ld.ub	r10,r11[0x0]
80007e58:	f8 0a 18 00 	cp.b	r10,r12
80007e5c:	5f 1e       	srne	lr
80007e5e:	f0 0a 18 00 	cp.b	r10,r8
80007e62:	5f 1c       	srne	r12
80007e64:	fd ec 00 0c 	and	r12,lr,r12
80007e68:	f0 0c 18 00 	cp.b	r12,r8
80007e6c:	cf 31       	brne	80007e52 <get_arg+0x26>
80007e6e:	58 0a       	cp.w	r10,0
80007e70:	e0 80 01 25 	breq	800080ba <get_arg+0x28e>
80007e74:	30 0c       	mov	r12,0
80007e76:	3f fa       	mov	r10,-1
80007e78:	18 90       	mov	r0,r12
80007e7a:	50 3a       	stdsp	sp[0xc],r10
80007e7c:	18 94       	mov	r4,r12
80007e7e:	18 92       	mov	r2,r12
80007e80:	f8 0c 00 3c 	add	r12,r12,r12<<0x3
80007e84:	16 97       	mov	r7,r11
80007e86:	50 7c       	stdsp	sp[0x1c],r12
80007e88:	fe cc 9e 70 	sub	r12,pc,-24976
80007e8c:	0f 3a       	ld.ub	r10,r7++
80007e8e:	f8 0a 07 0e 	ld.ub	lr,r12[r10]
80007e92:	40 7c       	lddsp	r12,sp[0x1c]
80007e94:	1c 0c       	add	r12,lr
80007e96:	fe ce 9f 46 	sub	lr,pc,-24762
80007e9a:	fc 0c 07 0e 	ld.ub	lr,lr[r12]
80007e9e:	20 1e       	sub	lr,1
80007ea0:	50 0e       	stdsp	sp[0x0],lr
80007ea2:	fe ce 9f be 	sub	lr,pc,-24642
80007ea6:	fc 0c 07 0c 	ld.ub	r12,lr[r12]
80007eaa:	50 7c       	stdsp	sp[0x1c],r12
80007eac:	40 0c       	lddsp	r12,sp[0x0]
80007eae:	58 7c       	cp.w	r12,7
80007eb0:	e0 8b 00 f1 	brhi	80008092 <get_arg+0x266>
80007eb4:	fe ce a1 70 	sub	lr,pc,-24208
80007eb8:	fc 0c 03 2f 	ld.w	pc,lr[r12<<0x2]
80007ebc:	36 8b       	mov	r11,104
80007ebe:	f6 0a 18 00 	cp.b	r10,r11
80007ec2:	e0 80 00 e8 	breq	80008092 <get_arg+0x266>
80007ec6:	37 1b       	mov	r11,113
80007ec8:	f6 0a 18 00 	cp.b	r10,r11
80007ecc:	c0 70       	breq	80007eda <get_arg+0xae>
80007ece:	34 cb       	mov	r11,76
80007ed0:	f6 0a 18 00 	cp.b	r10,r11
80007ed4:	c0 51       	brne	80007ede <get_arg+0xb2>
80007ed6:	a3 b4       	sbr	r4,0x3
80007ed8:	cd d8       	rjmp	80008092 <get_arg+0x266>
80007eda:	a5 b4       	sbr	r4,0x5
80007edc:	cd b8       	rjmp	80008092 <get_arg+0x266>
80007ede:	08 9a       	mov	r10,r4
80007ee0:	0e 9b       	mov	r11,r7
80007ee2:	a5 aa       	sbr	r10,0x4
80007ee4:	17 3c       	ld.ub	r12,r11++
80007ee6:	a5 b4       	sbr	r4,0x5
80007ee8:	36 ce       	mov	lr,108
80007eea:	fc 0c 18 00 	cp.b	r12,lr
80007eee:	e0 80 00 d3 	breq	80008094 <get_arg+0x268>
80007ef2:	14 94       	mov	r4,r10
80007ef4:	cc f8       	rjmp	80008092 <get_arg+0x266>
80007ef6:	eb d5 c0 05 	bfextu	r5,r5,0x0,0x5
80007efa:	36 7c       	mov	r12,103
80007efc:	f8 0a 18 00 	cp.b	r10,r12
80007f00:	e0 8b 00 27 	brhi	80007f4e <get_arg+0x122>
80007f04:	36 5b       	mov	r11,101
80007f06:	f6 0a 18 00 	cp.b	r10,r11
80007f0a:	c4 82       	brcc	80007f9a <get_arg+0x16e>
80007f0c:	34 fb       	mov	r11,79
80007f0e:	f6 0a 18 00 	cp.b	r10,r11
80007f12:	c4 80       	breq	80007fa2 <get_arg+0x176>
80007f14:	e0 8b 00 0c 	brhi	80007f2c <get_arg+0x100>
80007f18:	34 5b       	mov	r11,69
80007f1a:	f6 0a 18 00 	cp.b	r10,r11
80007f1e:	c3 e0       	breq	80007f9a <get_arg+0x16e>
80007f20:	34 7b       	mov	r11,71
80007f22:	f6 0a 18 00 	cp.b	r10,r11
80007f26:	c3 a0       	breq	80007f9a <get_arg+0x16e>
80007f28:	34 4b       	mov	r11,68
80007f2a:	c0 88       	rjmp	80007f3a <get_arg+0x10e>
80007f2c:	35 8b       	mov	r11,88
80007f2e:	f6 0a 18 00 	cp.b	r10,r11
80007f32:	c2 c0       	breq	80007f8a <get_arg+0x15e>
80007f34:	e0 8b 00 07 	brhi	80007f42 <get_arg+0x116>
80007f38:	35 5b       	mov	r11,85
80007f3a:	f6 0a 18 00 	cp.b	r10,r11
80007f3e:	c3 51       	brne	80007fa8 <get_arg+0x17c>
80007f40:	c3 18       	rjmp	80007fa2 <get_arg+0x176>
80007f42:	36 3b       	mov	r11,99
80007f44:	f6 0a 18 00 	cp.b	r10,r11
80007f48:	c2 f0       	breq	80007fa6 <get_arg+0x17a>
80007f4a:	36 4b       	mov	r11,100
80007f4c:	c0 e8       	rjmp	80007f68 <get_arg+0x13c>
80007f4e:	37 0b       	mov	r11,112
80007f50:	f6 0a 18 00 	cp.b	r10,r11
80007f54:	c2 50       	breq	80007f9e <get_arg+0x172>
80007f56:	e0 8b 00 0d 	brhi	80007f70 <get_arg+0x144>
80007f5a:	36 eb       	mov	r11,110
80007f5c:	f6 0a 18 00 	cp.b	r10,r11
80007f60:	c1 f0       	breq	80007f9e <get_arg+0x172>
80007f62:	e0 8b 00 14 	brhi	80007f8a <get_arg+0x15e>
80007f66:	36 9b       	mov	r11,105
80007f68:	f6 0a 18 00 	cp.b	r10,r11
80007f6c:	c1 e1       	brne	80007fa8 <get_arg+0x17c>
80007f6e:	c0 e8       	rjmp	80007f8a <get_arg+0x15e>
80007f70:	37 5b       	mov	r11,117
80007f72:	f6 0a 18 00 	cp.b	r10,r11
80007f76:	c0 a0       	breq	80007f8a <get_arg+0x15e>
80007f78:	37 8b       	mov	r11,120
80007f7a:	f6 0a 18 00 	cp.b	r10,r11
80007f7e:	c0 60       	breq	80007f8a <get_arg+0x15e>
80007f80:	37 3b       	mov	r11,115
80007f82:	f6 0a 18 00 	cp.b	r10,r11
80007f86:	c1 11       	brne	80007fa8 <get_arg+0x17c>
80007f88:	c0 b8       	rjmp	80007f9e <get_arg+0x172>
80007f8a:	ed b4 00 04 	bld	r4,0x4
80007f8e:	c0 a0       	breq	80007fa2 <get_arg+0x176>
80007f90:	ed b4 00 05 	bld	r4,0x5
80007f94:	c0 91       	brne	80007fa6 <get_arg+0x17a>
80007f96:	30 20       	mov	r0,2
80007f98:	c0 88       	rjmp	80007fa8 <get_arg+0x17c>
80007f9a:	30 40       	mov	r0,4
80007f9c:	c0 68       	rjmp	80007fa8 <get_arg+0x17c>
80007f9e:	30 30       	mov	r0,3
80007fa0:	c0 48       	rjmp	80007fa8 <get_arg+0x17c>
80007fa2:	30 10       	mov	r0,1
80007fa4:	c0 28       	rjmp	80007fa8 <get_arg+0x17c>
80007fa6:	30 00       	mov	r0,0
80007fa8:	40 3b       	lddsp	r11,sp[0xc]
80007faa:	5b fb       	cp.w	r11,-1
80007fac:	c0 40       	breq	80007fb4 <get_arg+0x188>
80007fae:	e2 0b 09 20 	st.w	r1[r11<<0x2],r0
80007fb2:	c7 08       	rjmp	80008092 <get_arg+0x266>
80007fb4:	58 60       	cp.w	r0,6
80007fb6:	e0 8b 00 6e 	brhi	80008092 <get_arg+0x266>
80007fba:	6c 0a       	ld.w	r10,r6[0x0]
80007fbc:	ea cc ff ff 	sub	r12,r5,-1
80007fc0:	fe ce a2 5c 	sub	lr,pc,-23972
80007fc4:	fc 00 03 2f 	ld.w	pc,lr[r0<<0x2]
80007fc8:	f4 cb ff f8 	sub	r11,r10,-8
80007fcc:	8d 0b       	st.w	r6[0x0],r11
80007fce:	f4 ea 00 00 	ld.d	r10,r10[0]
80007fd2:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80007fd6:	c0 f8       	rjmp	80007ff4 <get_arg+0x1c8>
80007fd8:	f4 cb ff fc 	sub	r11,r10,-4
80007fdc:	8d 0b       	st.w	r6[0x0],r11
80007fde:	74 0a       	ld.w	r10,r10[0x0]
80007fe0:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80007fe4:	c0 88       	rjmp	80007ff4 <get_arg+0x1c8>
80007fe6:	f4 cb ff f8 	sub	r11,r10,-8
80007fea:	8d 0b       	st.w	r6[0x0],r11
80007fec:	f4 ea 00 00 	ld.d	r10,r10[0]
80007ff0:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80007ff4:	0e 9b       	mov	r11,r7
80007ff6:	18 95       	mov	r5,r12
80007ff8:	c4 e8       	rjmp	80008094 <get_arg+0x268>
80007ffa:	62 0a       	ld.w	r10,r1[0x0]
80007ffc:	5b fa       	cp.w	r10,-1
80007ffe:	c0 b1       	brne	80008014 <get_arg+0x1e8>
80008000:	50 19       	stdsp	sp[0x4],r9
80008002:	50 28       	stdsp	sp[0x8],r8
80008004:	e0 6a 00 80 	mov	r10,128
80008008:	30 0b       	mov	r11,0
8000800a:	02 9c       	mov	r12,r1
8000800c:	fe b0 fd 00 	rcall	80007a0c <memset>
80008010:	40 28       	lddsp	r8,sp[0x8]
80008012:	40 19       	lddsp	r9,sp[0x4]
80008014:	e4 cc 00 01 	sub	r12,r2,1
80008018:	0e 9b       	mov	r11,r7
8000801a:	50 3c       	stdsp	sp[0xc],r12
8000801c:	f2 0c 0c 49 	max	r9,r9,r12
80008020:	c3 a8       	rjmp	80008094 <get_arg+0x268>
80008022:	62 0a       	ld.w	r10,r1[0x0]
80008024:	5b fa       	cp.w	r10,-1
80008026:	c0 b1       	brne	8000803c <get_arg+0x210>
80008028:	50 19       	stdsp	sp[0x4],r9
8000802a:	50 28       	stdsp	sp[0x8],r8
8000802c:	e0 6a 00 80 	mov	r10,128
80008030:	30 0b       	mov	r11,0
80008032:	02 9c       	mov	r12,r1
80008034:	fe b0 fc ec 	rcall	80007a0c <memset>
80008038:	40 28       	lddsp	r8,sp[0x8]
8000803a:	40 19       	lddsp	r9,sp[0x4]
8000803c:	20 12       	sub	r2,1
8000803e:	30 0a       	mov	r10,0
80008040:	0e 9b       	mov	r11,r7
80008042:	e2 02 09 2a 	st.w	r1[r2<<0x2],r10
80008046:	f2 02 0c 49 	max	r9,r9,r2
8000804a:	c2 58       	rjmp	80008094 <get_arg+0x268>
8000804c:	16 97       	mov	r7,r11
8000804e:	6c 0a       	ld.w	r10,r6[0x0]
80008050:	f4 cb ff fc 	sub	r11,r10,-4
80008054:	8d 0b       	st.w	r6[0x0],r11
80008056:	74 0a       	ld.w	r10,r10[0x0]
80008058:	0e 9b       	mov	r11,r7
8000805a:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
8000805e:	2f f5       	sub	r5,-1
80008060:	c1 a8       	rjmp	80008094 <get_arg+0x268>
80008062:	f4 c2 00 30 	sub	r2,r10,48
80008066:	c0 68       	rjmp	80008072 <get_arg+0x246>
80008068:	e4 02 00 22 	add	r2,r2,r2<<0x2
8000806c:	2f f7       	sub	r7,-1
8000806e:	f4 02 00 12 	add	r2,r10,r2<<0x1
80008072:	0f 8a       	ld.ub	r10,r7[0x0]
80008074:	58 0a       	cp.w	r10,0
80008076:	c0 e0       	breq	80008092 <get_arg+0x266>
80008078:	23 0a       	sub	r10,48
8000807a:	58 9a       	cp.w	r10,9
8000807c:	fe 98 ff f6 	brls	80008068 <get_arg+0x23c>
80008080:	c0 98       	rjmp	80008092 <get_arg+0x266>
80008082:	2f f7       	sub	r7,-1
80008084:	0f 8a       	ld.ub	r10,r7[0x0]
80008086:	58 0a       	cp.w	r10,0
80008088:	c0 50       	breq	80008092 <get_arg+0x266>
8000808a:	23 0a       	sub	r10,48
8000808c:	58 9a       	cp.w	r10,9
8000808e:	fe 98 ff fa 	brls	80008082 <get_arg+0x256>
80008092:	0e 9b       	mov	r11,r7
80008094:	40 7c       	lddsp	r12,sp[0x1c]
80008096:	30 ba       	mov	r10,11
80008098:	f4 0c 18 00 	cp.b	r12,r10
8000809c:	fe 91 fe f2 	brne	80007e80 <get_arg+0x54>
800080a0:	40 42       	lddsp	r2,sp[0x10]
800080a2:	17 8c       	ld.ub	r12,r11[0x0]
800080a4:	0a 32       	cp.w	r2,r5
800080a6:	5f 4a       	srge	r10
800080a8:	f0 0c 18 00 	cp.b	r12,r8
800080ac:	5f 1c       	srne	r12
800080ae:	f9 ea 00 0a 	and	r10,r12,r10
800080b2:	f0 0a 18 00 	cp.b	r10,r8
800080b6:	fe 91 fe cf 	brne	80007e54 <get_arg+0x28>
800080ba:	30 08       	mov	r8,0
800080bc:	40 4e       	lddsp	lr,sp[0x10]
800080be:	17 8a       	ld.ub	r10,r11[0x0]
800080c0:	e2 05 00 21 	add	r1,r1,r5<<0x2
800080c4:	f0 0a 18 00 	cp.b	r10,r8
800080c8:	fc 09 17 10 	movne	r9,lr
800080cc:	e6 05 00 38 	add	r8,r3,r5<<0x3
800080d0:	06 9e       	mov	lr,r3
800080d2:	c2 a8       	rjmp	80008126 <get_arg+0x2fa>
800080d4:	62 0a       	ld.w	r10,r1[0x0]
800080d6:	58 3a       	cp.w	r10,3
800080d8:	c1 e0       	breq	80008114 <get_arg+0x2e8>
800080da:	e0 89 00 07 	brgt	800080e8 <get_arg+0x2bc>
800080de:	58 1a       	cp.w	r10,1
800080e0:	c1 a0       	breq	80008114 <get_arg+0x2e8>
800080e2:	58 2a       	cp.w	r10,2
800080e4:	c1 81       	brne	80008114 <get_arg+0x2e8>
800080e6:	c0 58       	rjmp	800080f0 <get_arg+0x2c4>
800080e8:	58 5a       	cp.w	r10,5
800080ea:	c0 c0       	breq	80008102 <get_arg+0x2d6>
800080ec:	c0 b5       	brlt	80008102 <get_arg+0x2d6>
800080ee:	c1 38       	rjmp	80008114 <get_arg+0x2e8>
800080f0:	6c 0a       	ld.w	r10,r6[0x0]
800080f2:	f4 cc ff f8 	sub	r12,r10,-8
800080f6:	8d 0c       	st.w	r6[0x0],r12
800080f8:	f4 e2 00 00 	ld.d	r2,r10[0]
800080fc:	f0 e3 00 00 	st.d	r8[0],r2
80008100:	c1 08       	rjmp	80008120 <get_arg+0x2f4>
80008102:	6c 0a       	ld.w	r10,r6[0x0]
80008104:	f4 cc ff f8 	sub	r12,r10,-8
80008108:	8d 0c       	st.w	r6[0x0],r12
8000810a:	f4 e2 00 00 	ld.d	r2,r10[0]
8000810e:	f0 e3 00 00 	st.d	r8[0],r2
80008112:	c0 78       	rjmp	80008120 <get_arg+0x2f4>
80008114:	6c 0a       	ld.w	r10,r6[0x0]
80008116:	f4 cc ff fc 	sub	r12,r10,-4
8000811a:	8d 0c       	st.w	r6[0x0],r12
8000811c:	74 0a       	ld.w	r10,r10[0x0]
8000811e:	91 0a       	st.w	r8[0x0],r10
80008120:	2f f5       	sub	r5,-1
80008122:	2f 88       	sub	r8,-8
80008124:	2f c1       	sub	r1,-4
80008126:	12 35       	cp.w	r5,r9
80008128:	fe 9a ff d6 	brle	800080d4 <get_arg+0x2a8>
8000812c:	1c 93       	mov	r3,lr
8000812e:	40 52       	lddsp	r2,sp[0x14]
80008130:	40 6e       	lddsp	lr,sp[0x18]
80008132:	85 05       	st.w	r2[0x0],r5
80008134:	9d 0b       	st.w	lr[0x0],r11
80008136:	40 4b       	lddsp	r11,sp[0x10]
80008138:	e6 0b 00 3c 	add	r12,r3,r11<<0x3
8000813c:	2f 8d       	sub	sp,-32
8000813e:	d8 32       	popm	r0-r7,pc

80008140 <__sprint_r>:
80008140:	d4 21       	pushm	r4-r7,lr
80008142:	14 97       	mov	r7,r10
80008144:	74 28       	ld.w	r8,r10[0x8]
80008146:	58 08       	cp.w	r8,0
80008148:	c0 41       	brne	80008150 <__sprint_r+0x10>
8000814a:	95 18       	st.w	r10[0x4],r8
8000814c:	10 9c       	mov	r12,r8
8000814e:	d8 22       	popm	r4-r7,pc
80008150:	e0 a0 18 ba 	rcall	8000b2c4 <__sfvwrite_r>
80008154:	30 08       	mov	r8,0
80008156:	8f 18       	st.w	r7[0x4],r8
80008158:	8f 28       	st.w	r7[0x8],r8
8000815a:	d8 22       	popm	r4-r7,pc

8000815c <_vfprintf_r>:
8000815c:	d4 31       	pushm	r0-r7,lr
8000815e:	fa cd 06 bc 	sub	sp,sp,1724
80008162:	51 09       	stdsp	sp[0x40],r9
80008164:	16 91       	mov	r1,r11
80008166:	14 97       	mov	r7,r10
80008168:	18 95       	mov	r5,r12
8000816a:	e0 a0 1a 1d 	rcall	8000b5a4 <_localeconv_r>
8000816e:	78 0c       	ld.w	r12,r12[0x0]
80008170:	50 cc       	stdsp	sp[0x30],r12
80008172:	58 05       	cp.w	r5,0
80008174:	c0 70       	breq	80008182 <_vfprintf_r+0x26>
80008176:	6a 68       	ld.w	r8,r5[0x18]
80008178:	58 08       	cp.w	r8,0
8000817a:	c0 41       	brne	80008182 <_vfprintf_r+0x26>
8000817c:	0a 9c       	mov	r12,r5
8000817e:	e0 a0 17 43 	rcall	8000b004 <__sinit>
80008182:	fe c8 a0 5a 	sub	r8,pc,-24486
80008186:	10 31       	cp.w	r1,r8
80008188:	c0 31       	brne	8000818e <_vfprintf_r+0x32>
8000818a:	6a 01       	ld.w	r1,r5[0x0]
8000818c:	c0 c8       	rjmp	800081a4 <_vfprintf_r+0x48>
8000818e:	fe c8 a0 46 	sub	r8,pc,-24506
80008192:	10 31       	cp.w	r1,r8
80008194:	c0 31       	brne	8000819a <_vfprintf_r+0x3e>
80008196:	6a 11       	ld.w	r1,r5[0x4]
80008198:	c0 68       	rjmp	800081a4 <_vfprintf_r+0x48>
8000819a:	fe c8 a0 32 	sub	r8,pc,-24526
8000819e:	10 31       	cp.w	r1,r8
800081a0:	eb f1 00 02 	ld.weq	r1,r5[0x8]
800081a4:	82 68       	ld.sh	r8,r1[0xc]
800081a6:	ed b8 00 03 	bld	r8,0x3
800081aa:	c0 41       	brne	800081b2 <_vfprintf_r+0x56>
800081ac:	62 48       	ld.w	r8,r1[0x10]
800081ae:	58 08       	cp.w	r8,0
800081b0:	c0 71       	brne	800081be <_vfprintf_r+0x62>
800081b2:	02 9b       	mov	r11,r1
800081b4:	0a 9c       	mov	r12,r5
800081b6:	e0 a0 0f 5d 	rcall	8000a070 <__swsetup_r>
800081ba:	e0 81 0f 54 	brne	8000a062 <_vfprintf_r+0x1f06>
800081be:	82 68       	ld.sh	r8,r1[0xc]
800081c0:	10 99       	mov	r9,r8
800081c2:	e2 19 00 1a 	andl	r9,0x1a,COH
800081c6:	58 a9       	cp.w	r9,10
800081c8:	c3 c1       	brne	80008240 <_vfprintf_r+0xe4>
800081ca:	82 79       	ld.sh	r9,r1[0xe]
800081cc:	30 0a       	mov	r10,0
800081ce:	f4 09 19 00 	cp.h	r9,r10
800081d2:	c3 75       	brlt	80008240 <_vfprintf_r+0xe4>
800081d4:	a1 d8       	cbr	r8,0x1
800081d6:	fb 58 05 d0 	st.h	sp[1488],r8
800081da:	62 88       	ld.w	r8,r1[0x20]
800081dc:	fb 48 05 e4 	st.w	sp[1508],r8
800081e0:	62 a8       	ld.w	r8,r1[0x28]
800081e2:	fb 48 05 ec 	st.w	sp[1516],r8
800081e6:	fa c8 ff bc 	sub	r8,sp,-68
800081ea:	fb 48 05 d4 	st.w	sp[1492],r8
800081ee:	fb 48 05 c4 	st.w	sp[1476],r8
800081f2:	e0 68 04 00 	mov	r8,1024
800081f6:	fb 48 05 d8 	st.w	sp[1496],r8
800081fa:	fb 48 05 cc 	st.w	sp[1484],r8
800081fe:	30 08       	mov	r8,0
80008200:	fb 59 05 d2 	st.h	sp[1490],r9
80008204:	0e 9a       	mov	r10,r7
80008206:	41 09       	lddsp	r9,sp[0x40]
80008208:	fa c7 fa 3c 	sub	r7,sp,-1476
8000820c:	fb 48 05 dc 	st.w	sp[1500],r8
80008210:	0a 9c       	mov	r12,r5
80008212:	0e 9b       	mov	r11,r7
80008214:	ca 4f       	rcall	8000815c <_vfprintf_r>
80008216:	50 bc       	stdsp	sp[0x2c],r12
80008218:	c0 95       	brlt	8000822a <_vfprintf_r+0xce>
8000821a:	0e 9b       	mov	r11,r7
8000821c:	0a 9c       	mov	r12,r5
8000821e:	e0 a0 16 1b 	rcall	8000ae54 <_fflush_r>
80008222:	40 be       	lddsp	lr,sp[0x2c]
80008224:	f9 be 01 ff 	movne	lr,-1
80008228:	50 be       	stdsp	sp[0x2c],lr
8000822a:	fb 08 05 d0 	ld.sh	r8,sp[1488]
8000822e:	ed b8 00 06 	bld	r8,0x6
80008232:	e0 81 0f 1a 	brne	8000a066 <_vfprintf_r+0x1f0a>
80008236:	82 68       	ld.sh	r8,r1[0xc]
80008238:	a7 a8       	sbr	r8,0x6
8000823a:	a2 68       	st.h	r1[0xc],r8
8000823c:	e0 8f 0f 15 	bral	8000a066 <_vfprintf_r+0x1f0a>
80008240:	30 08       	mov	r8,0
80008242:	fb 48 06 b4 	st.w	sp[1716],r8
80008246:	fb 48 06 90 	st.w	sp[1680],r8
8000824a:	fb 48 06 8c 	st.w	sp[1676],r8
8000824e:	fb 48 06 b0 	st.w	sp[1712],r8
80008252:	30 08       	mov	r8,0
80008254:	30 09       	mov	r9,0
80008256:	50 a7       	stdsp	sp[0x28],r7
80008258:	50 78       	stdsp	sp[0x1c],r8
8000825a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000825e:	3f f8       	mov	r8,-1
80008260:	50 59       	stdsp	sp[0x14],r9
80008262:	fb 43 06 88 	st.w	sp[1672],r3
80008266:	fb 48 05 44 	st.w	sp[1348],r8
8000826a:	12 9c       	mov	r12,r9
8000826c:	50 69       	stdsp	sp[0x18],r9
8000826e:	50 d9       	stdsp	sp[0x34],r9
80008270:	50 e9       	stdsp	sp[0x38],r9
80008272:	50 b9       	stdsp	sp[0x2c],r9
80008274:	12 97       	mov	r7,r9
80008276:	0a 94       	mov	r4,r5
80008278:	40 a2       	lddsp	r2,sp[0x28]
8000827a:	32 5a       	mov	r10,37
8000827c:	30 08       	mov	r8,0
8000827e:	c0 28       	rjmp	80008282 <_vfprintf_r+0x126>
80008280:	2f f2       	sub	r2,-1
80008282:	05 89       	ld.ub	r9,r2[0x0]
80008284:	f0 09 18 00 	cp.b	r9,r8
80008288:	5f 1b       	srne	r11
8000828a:	f4 09 18 00 	cp.b	r9,r10
8000828e:	5f 19       	srne	r9
80008290:	f3 eb 00 0b 	and	r11,r9,r11
80008294:	f0 0b 18 00 	cp.b	r11,r8
80008298:	cf 41       	brne	80008280 <_vfprintf_r+0x124>
8000829a:	40 ab       	lddsp	r11,sp[0x28]
8000829c:	e4 0b 01 06 	sub	r6,r2,r11
800082a0:	c1 e0       	breq	800082dc <_vfprintf_r+0x180>
800082a2:	fa f8 06 90 	ld.w	r8,sp[1680]
800082a6:	0c 08       	add	r8,r6
800082a8:	87 0b       	st.w	r3[0x0],r11
800082aa:	fb 48 06 90 	st.w	sp[1680],r8
800082ae:	87 16       	st.w	r3[0x4],r6
800082b0:	fa f8 06 8c 	ld.w	r8,sp[1676]
800082b4:	2f f8       	sub	r8,-1
800082b6:	fb 48 06 8c 	st.w	sp[1676],r8
800082ba:	58 78       	cp.w	r8,7
800082bc:	e0 89 00 04 	brgt	800082c4 <_vfprintf_r+0x168>
800082c0:	2f 83       	sub	r3,-8
800082c2:	c0 a8       	rjmp	800082d6 <_vfprintf_r+0x17a>
800082c4:	fa ca f9 78 	sub	r10,sp,-1672
800082c8:	02 9b       	mov	r11,r1
800082ca:	08 9c       	mov	r12,r4
800082cc:	c3 af       	rcall	80008140 <__sprint_r>
800082ce:	e0 81 0e c6 	brne	8000a05a <_vfprintf_r+0x1efe>
800082d2:	fa c3 f9 e0 	sub	r3,sp,-1568
800082d6:	40 ba       	lddsp	r10,sp[0x2c]
800082d8:	0c 0a       	add	r10,r6
800082da:	50 ba       	stdsp	sp[0x2c],r10
800082dc:	05 89       	ld.ub	r9,r2[0x0]
800082de:	30 08       	mov	r8,0
800082e0:	f0 09 18 00 	cp.b	r9,r8
800082e4:	e0 80 0e aa 	breq	8000a038 <_vfprintf_r+0x1edc>
800082e8:	30 09       	mov	r9,0
800082ea:	fb 68 06 bb 	st.b	sp[1723],r8
800082ee:	0e 96       	mov	r6,r7
800082f0:	e4 c8 ff ff 	sub	r8,r2,-1
800082f4:	3f fe       	mov	lr,-1
800082f6:	50 93       	stdsp	sp[0x24],r3
800082f8:	50 41       	stdsp	sp[0x10],r1
800082fa:	0e 93       	mov	r3,r7
800082fc:	04 91       	mov	r1,r2
800082fe:	50 89       	stdsp	sp[0x20],r9
80008300:	50 a8       	stdsp	sp[0x28],r8
80008302:	50 2e       	stdsp	sp[0x8],lr
80008304:	50 39       	stdsp	sp[0xc],r9
80008306:	12 95       	mov	r5,r9
80008308:	12 90       	mov	r0,r9
8000830a:	10 97       	mov	r7,r8
8000830c:	08 92       	mov	r2,r4
8000830e:	c0 78       	rjmp	8000831c <_vfprintf_r+0x1c0>
80008310:	3f fc       	mov	r12,-1
80008312:	08 97       	mov	r7,r4
80008314:	50 2c       	stdsp	sp[0x8],r12
80008316:	c0 38       	rjmp	8000831c <_vfprintf_r+0x1c0>
80008318:	30 0b       	mov	r11,0
8000831a:	50 3b       	stdsp	sp[0xc],r11
8000831c:	0f 38       	ld.ub	r8,r7++
8000831e:	c0 28       	rjmp	80008322 <_vfprintf_r+0x1c6>
80008320:	12 90       	mov	r0,r9
80008322:	f0 c9 00 20 	sub	r9,r8,32
80008326:	e0 49 00 58 	cp.w	r9,88
8000832a:	e0 8b 0a 30 	brhi	8000978a <_vfprintf_r+0x162e>
8000832e:	fe ca a5 ae 	sub	r10,pc,-23122
80008332:	f4 09 03 2f 	ld.w	pc,r10[r9<<0x2]
80008336:	50 a7       	stdsp	sp[0x28],r7
80008338:	50 80       	stdsp	sp[0x20],r0
8000833a:	0c 97       	mov	r7,r6
8000833c:	04 94       	mov	r4,r2
8000833e:	06 96       	mov	r6,r3
80008340:	02 92       	mov	r2,r1
80008342:	fe c9 a3 86 	sub	r9,pc,-23674
80008346:	40 93       	lddsp	r3,sp[0x24]
80008348:	10 90       	mov	r0,r8
8000834a:	40 41       	lddsp	r1,sp[0x10]
8000834c:	50 d9       	stdsp	sp[0x34],r9
8000834e:	e0 8f 08 8e 	bral	8000946a <_vfprintf_r+0x130e>
80008352:	30 08       	mov	r8,0
80008354:	fb 39 06 bb 	ld.ub	r9,sp[1723]
80008358:	f0 09 18 00 	cp.b	r9,r8
8000835c:	ce 01       	brne	8000831c <_vfprintf_r+0x1c0>
8000835e:	32 08       	mov	r8,32
80008360:	c6 e8       	rjmp	8000843c <_vfprintf_r+0x2e0>
80008362:	a1 a5       	sbr	r5,0x0
80008364:	cd cb       	rjmp	8000831c <_vfprintf_r+0x1c0>
80008366:	0f 89       	ld.ub	r9,r7[0x0]
80008368:	f2 c8 00 30 	sub	r8,r9,48
8000836c:	58 98       	cp.w	r8,9
8000836e:	e0 8b 00 1d 	brhi	800083a8 <_vfprintf_r+0x24c>
80008372:	ee c8 ff ff 	sub	r8,r7,-1
80008376:	30 0b       	mov	r11,0
80008378:	23 09       	sub	r9,48
8000837a:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
8000837e:	f2 0b 00 1b 	add	r11,r9,r11<<0x1
80008382:	11 39       	ld.ub	r9,r8++
80008384:	f2 ca 00 30 	sub	r10,r9,48
80008388:	58 9a       	cp.w	r10,9
8000838a:	fe 98 ff f7 	brls	80008378 <_vfprintf_r+0x21c>
8000838e:	e0 49 00 24 	cp.w	r9,36
80008392:	cc 31       	brne	80008318 <_vfprintf_r+0x1bc>
80008394:	e0 4b 00 20 	cp.w	r11,32
80008398:	e0 89 0e 60 	brgt	8000a058 <_vfprintf_r+0x1efc>
8000839c:	20 1b       	sub	r11,1
8000839e:	fa f9 06 b4 	ld.w	r9,sp[1716]
800083a2:	12 3b       	cp.w	r11,r9
800083a4:	c0 95       	brlt	800083b6 <_vfprintf_r+0x25a>
800083a6:	c1 08       	rjmp	800083c6 <_vfprintf_r+0x26a>
800083a8:	fa f9 06 b4 	ld.w	r9,sp[1716]
800083ac:	ec ca ff ff 	sub	r10,r6,-1
800083b0:	12 36       	cp.w	r6,r9
800083b2:	c1 f5       	brlt	800083f0 <_vfprintf_r+0x294>
800083b4:	c2 68       	rjmp	80008400 <_vfprintf_r+0x2a4>
800083b6:	fa ce f9 44 	sub	lr,sp,-1724
800083ba:	10 97       	mov	r7,r8
800083bc:	fc 0b 00 3b 	add	r11,lr,r11<<0x3
800083c0:	f6 f0 fd 88 	ld.w	r0,r11[-632]
800083c4:	c3 58       	rjmp	8000842e <_vfprintf_r+0x2d2>
800083c6:	10 97       	mov	r7,r8
800083c8:	fa c8 f9 50 	sub	r8,sp,-1712
800083cc:	1a d8       	st.w	--sp,r8
800083ce:	fa c8 fa b8 	sub	r8,sp,-1352
800083d2:	1a d8       	st.w	--sp,r8
800083d4:	fa c8 fb b4 	sub	r8,sp,-1100
800083d8:	02 9a       	mov	r10,r1
800083da:	1a d8       	st.w	--sp,r8
800083dc:	04 9c       	mov	r12,r2
800083de:	fa c8 f9 40 	sub	r8,sp,-1728
800083e2:	fa c9 ff b4 	sub	r9,sp,-76
800083e6:	fe b0 fd 23 	rcall	80007e2c <get_arg>
800083ea:	2f dd       	sub	sp,-12
800083ec:	78 00       	ld.w	r0,r12[0x0]
800083ee:	c2 08       	rjmp	8000842e <_vfprintf_r+0x2d2>
800083f0:	fa cc f9 44 	sub	r12,sp,-1724
800083f4:	14 96       	mov	r6,r10
800083f6:	f8 03 00 38 	add	r8,r12,r3<<0x3
800083fa:	f0 f0 fd 88 	ld.w	r0,r8[-632]
800083fe:	c1 88       	rjmp	8000842e <_vfprintf_r+0x2d2>
80008400:	41 08       	lddsp	r8,sp[0x40]
80008402:	59 f9       	cp.w	r9,31
80008404:	e0 89 00 11 	brgt	80008426 <_vfprintf_r+0x2ca>
80008408:	f0 cb ff fc 	sub	r11,r8,-4
8000840c:	51 0b       	stdsp	sp[0x40],r11
8000840e:	70 00       	ld.w	r0,r8[0x0]
80008410:	fa cb f9 44 	sub	r11,sp,-1724
80008414:	f6 09 00 38 	add	r8,r11,r9<<0x3
80008418:	f1 40 fd 88 	st.w	r8[-632],r0
8000841c:	2f f9       	sub	r9,-1
8000841e:	14 96       	mov	r6,r10
80008420:	fb 49 06 b4 	st.w	sp[1716],r9
80008424:	c0 58       	rjmp	8000842e <_vfprintf_r+0x2d2>
80008426:	70 00       	ld.w	r0,r8[0x0]
80008428:	14 96       	mov	r6,r10
8000842a:	2f c8       	sub	r8,-4
8000842c:	51 08       	stdsp	sp[0x40],r8
8000842e:	58 00       	cp.w	r0,0
80008430:	fe 94 ff 76 	brge	8000831c <_vfprintf_r+0x1c0>
80008434:	5c 30       	neg	r0
80008436:	a3 a5       	sbr	r5,0x2
80008438:	c7 2b       	rjmp	8000831c <_vfprintf_r+0x1c0>
8000843a:	32 b8       	mov	r8,43
8000843c:	fb 68 06 bb 	st.b	sp[1723],r8
80008440:	c6 eb       	rjmp	8000831c <_vfprintf_r+0x1c0>
80008442:	0f 38       	ld.ub	r8,r7++
80008444:	e0 48 00 2a 	cp.w	r8,42
80008448:	c0 30       	breq	8000844e <_vfprintf_r+0x2f2>
8000844a:	30 09       	mov	r9,0
8000844c:	c7 98       	rjmp	8000853e <_vfprintf_r+0x3e2>
8000844e:	0f 88       	ld.ub	r8,r7[0x0]
80008450:	f0 c9 00 30 	sub	r9,r8,48
80008454:	58 99       	cp.w	r9,9
80008456:	e0 8b 00 1f 	brhi	80008494 <_vfprintf_r+0x338>
8000845a:	ee c4 ff ff 	sub	r4,r7,-1
8000845e:	30 0b       	mov	r11,0
80008460:	23 08       	sub	r8,48
80008462:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
80008466:	f0 0b 00 1b 	add	r11,r8,r11<<0x1
8000846a:	09 38       	ld.ub	r8,r4++
8000846c:	f0 c9 00 30 	sub	r9,r8,48
80008470:	58 99       	cp.w	r9,9
80008472:	fe 98 ff f7 	brls	80008460 <_vfprintf_r+0x304>
80008476:	e0 48 00 24 	cp.w	r8,36
8000847a:	fe 91 ff 4f 	brne	80008318 <_vfprintf_r+0x1bc>
8000847e:	e0 4b 00 20 	cp.w	r11,32
80008482:	e0 89 0d eb 	brgt	8000a058 <_vfprintf_r+0x1efc>
80008486:	20 1b       	sub	r11,1
80008488:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000848c:	10 3b       	cp.w	r11,r8
8000848e:	c0 a5       	brlt	800084a2 <_vfprintf_r+0x346>
80008490:	c1 18       	rjmp	800084b2 <_vfprintf_r+0x356>
80008492:	d7 03       	nop
80008494:	fa fa 06 b4 	ld.w	r10,sp[1716]
80008498:	ec c9 ff ff 	sub	r9,r6,-1
8000849c:	14 36       	cp.w	r6,r10
8000849e:	c1 f5       	brlt	800084dc <_vfprintf_r+0x380>
800084a0:	c2 88       	rjmp	800084f0 <_vfprintf_r+0x394>
800084a2:	fa ca f9 44 	sub	r10,sp,-1724
800084a6:	f4 0b 00 3b 	add	r11,r10,r11<<0x3
800084aa:	f6 fb fd 88 	ld.w	r11,r11[-632]
800084ae:	50 2b       	stdsp	sp[0x8],r11
800084b0:	c3 c8       	rjmp	80008528 <_vfprintf_r+0x3cc>
800084b2:	fa c8 f9 50 	sub	r8,sp,-1712
800084b6:	1a d8       	st.w	--sp,r8
800084b8:	fa c8 fa b8 	sub	r8,sp,-1352
800084bc:	1a d8       	st.w	--sp,r8
800084be:	fa c8 fb b4 	sub	r8,sp,-1100
800084c2:	02 9a       	mov	r10,r1
800084c4:	1a d8       	st.w	--sp,r8
800084c6:	04 9c       	mov	r12,r2
800084c8:	fa c8 f9 40 	sub	r8,sp,-1728
800084cc:	fa c9 ff b4 	sub	r9,sp,-76
800084d0:	fe b0 fc ae 	rcall	80007e2c <get_arg>
800084d4:	2f dd       	sub	sp,-12
800084d6:	78 0c       	ld.w	r12,r12[0x0]
800084d8:	50 2c       	stdsp	sp[0x8],r12
800084da:	c2 78       	rjmp	80008528 <_vfprintf_r+0x3cc>
800084dc:	12 96       	mov	r6,r9
800084de:	0e 94       	mov	r4,r7
800084e0:	fa c9 f9 44 	sub	r9,sp,-1724
800084e4:	f2 03 00 38 	add	r8,r9,r3<<0x3
800084e8:	f0 f8 fd 88 	ld.w	r8,r8[-632]
800084ec:	50 28       	stdsp	sp[0x8],r8
800084ee:	c1 d8       	rjmp	80008528 <_vfprintf_r+0x3cc>
800084f0:	41 08       	lddsp	r8,sp[0x40]
800084f2:	59 fa       	cp.w	r10,31
800084f4:	e0 89 00 14 	brgt	8000851c <_vfprintf_r+0x3c0>
800084f8:	f0 cb ff fc 	sub	r11,r8,-4
800084fc:	70 08       	ld.w	r8,r8[0x0]
800084fe:	51 0b       	stdsp	sp[0x40],r11
80008500:	50 28       	stdsp	sp[0x8],r8
80008502:	fa c6 f9 44 	sub	r6,sp,-1724
80008506:	40 2e       	lddsp	lr,sp[0x8]
80008508:	ec 0a 00 38 	add	r8,r6,r10<<0x3
8000850c:	f1 4e fd 88 	st.w	r8[-632],lr
80008510:	2f fa       	sub	r10,-1
80008512:	0e 94       	mov	r4,r7
80008514:	fb 4a 06 b4 	st.w	sp[1716],r10
80008518:	12 96       	mov	r6,r9
8000851a:	c0 78       	rjmp	80008528 <_vfprintf_r+0x3cc>
8000851c:	70 0c       	ld.w	r12,r8[0x0]
8000851e:	0e 94       	mov	r4,r7
80008520:	2f c8       	sub	r8,-4
80008522:	50 2c       	stdsp	sp[0x8],r12
80008524:	12 96       	mov	r6,r9
80008526:	51 08       	stdsp	sp[0x40],r8
80008528:	40 2b       	lddsp	r11,sp[0x8]
8000852a:	58 0b       	cp.w	r11,0
8000852c:	fe 95 fe f2 	brlt	80008310 <_vfprintf_r+0x1b4>
80008530:	08 97       	mov	r7,r4
80008532:	cf 5a       	rjmp	8000831c <_vfprintf_r+0x1c0>
80008534:	f2 09 00 29 	add	r9,r9,r9<<0x2
80008538:	0f 38       	ld.ub	r8,r7++
8000853a:	f4 09 00 19 	add	r9,r10,r9<<0x1
8000853e:	f0 ca 00 30 	sub	r10,r8,48
80008542:	58 9a       	cp.w	r10,9
80008544:	fe 98 ff f8 	brls	80008534 <_vfprintf_r+0x3d8>
80008548:	3f fa       	mov	r10,-1
8000854a:	f2 0a 0c 49 	max	r9,r9,r10
8000854e:	50 29       	stdsp	sp[0x8],r9
80008550:	ce 9a       	rjmp	80008322 <_vfprintf_r+0x1c6>
80008552:	a7 b5       	sbr	r5,0x7
80008554:	ce 4a       	rjmp	8000831c <_vfprintf_r+0x1c0>
80008556:	30 09       	mov	r9,0
80008558:	23 08       	sub	r8,48
8000855a:	f2 09 00 29 	add	r9,r9,r9<<0x2
8000855e:	f0 09 00 19 	add	r9,r8,r9<<0x1
80008562:	0f 38       	ld.ub	r8,r7++
80008564:	f0 ca 00 30 	sub	r10,r8,48
80008568:	58 9a       	cp.w	r10,9
8000856a:	fe 98 ff f7 	brls	80008558 <_vfprintf_r+0x3fc>
8000856e:	e0 48 00 24 	cp.w	r8,36
80008572:	fe 91 fe d7 	brne	80008320 <_vfprintf_r+0x1c4>
80008576:	e0 49 00 20 	cp.w	r9,32
8000857a:	e0 89 0d 6f 	brgt	8000a058 <_vfprintf_r+0x1efc>
8000857e:	f2 c3 00 01 	sub	r3,r9,1
80008582:	30 19       	mov	r9,1
80008584:	50 39       	stdsp	sp[0xc],r9
80008586:	cc ba       	rjmp	8000831c <_vfprintf_r+0x1c0>
80008588:	a3 b5       	sbr	r5,0x3
8000858a:	cc 9a       	rjmp	8000831c <_vfprintf_r+0x1c0>
8000858c:	a7 a5       	sbr	r5,0x6
8000858e:	cc 7a       	rjmp	8000831c <_vfprintf_r+0x1c0>
80008590:	0a 98       	mov	r8,r5
80008592:	a5 b5       	sbr	r5,0x5
80008594:	a5 a8       	sbr	r8,0x4
80008596:	0f 89       	ld.ub	r9,r7[0x0]
80008598:	36 ce       	mov	lr,108
8000859a:	fc 09 18 00 	cp.b	r9,lr
8000859e:	f7 b7 00 ff 	subeq	r7,-1
800085a2:	f0 05 17 10 	movne	r5,r8
800085a6:	cb ba       	rjmp	8000831c <_vfprintf_r+0x1c0>
800085a8:	a5 b5       	sbr	r5,0x5
800085aa:	cb 9a       	rjmp	8000831c <_vfprintf_r+0x1c0>
800085ac:	50 a7       	stdsp	sp[0x28],r7
800085ae:	50 80       	stdsp	sp[0x20],r0
800085b0:	0c 97       	mov	r7,r6
800085b2:	10 90       	mov	r0,r8
800085b4:	06 96       	mov	r6,r3
800085b6:	04 94       	mov	r4,r2
800085b8:	40 93       	lddsp	r3,sp[0x24]
800085ba:	02 92       	mov	r2,r1
800085bc:	0e 99       	mov	r9,r7
800085be:	40 41       	lddsp	r1,sp[0x10]
800085c0:	fa f8 06 b4 	ld.w	r8,sp[1716]
800085c4:	40 3c       	lddsp	r12,sp[0xc]
800085c6:	58 0c       	cp.w	r12,0
800085c8:	c1 d0       	breq	80008602 <_vfprintf_r+0x4a6>
800085ca:	10 36       	cp.w	r6,r8
800085cc:	c0 64       	brge	800085d8 <_vfprintf_r+0x47c>
800085ce:	fa cb f9 44 	sub	r11,sp,-1724
800085d2:	f6 06 00 36 	add	r6,r11,r6<<0x3
800085d6:	c1 d8       	rjmp	80008610 <_vfprintf_r+0x4b4>
800085d8:	fa c8 f9 50 	sub	r8,sp,-1712
800085dc:	1a d8       	st.w	--sp,r8
800085de:	fa c8 fa b8 	sub	r8,sp,-1352
800085e2:	1a d8       	st.w	--sp,r8
800085e4:	fa c8 fb b4 	sub	r8,sp,-1100
800085e8:	1a d8       	st.w	--sp,r8
800085ea:	fa c8 f9 40 	sub	r8,sp,-1728
800085ee:	fa c9 ff b4 	sub	r9,sp,-76
800085f2:	04 9a       	mov	r10,r2
800085f4:	0c 9b       	mov	r11,r6
800085f6:	08 9c       	mov	r12,r4
800085f8:	fe b0 fc 1a 	rcall	80007e2c <get_arg>
800085fc:	2f dd       	sub	sp,-12
800085fe:	19 b8       	ld.ub	r8,r12[0x3]
80008600:	c2 28       	rjmp	80008644 <_vfprintf_r+0x4e8>
80008602:	2f f7       	sub	r7,-1
80008604:	10 39       	cp.w	r9,r8
80008606:	c0 84       	brge	80008616 <_vfprintf_r+0x4ba>
80008608:	fa ca f9 44 	sub	r10,sp,-1724
8000860c:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008610:	ed 38 fd 8b 	ld.ub	r8,r6[-629]
80008614:	c1 88       	rjmp	80008644 <_vfprintf_r+0x4e8>
80008616:	41 09       	lddsp	r9,sp[0x40]
80008618:	59 f8       	cp.w	r8,31
8000861a:	e0 89 00 12 	brgt	8000863e <_vfprintf_r+0x4e2>
8000861e:	f2 ca ff fc 	sub	r10,r9,-4
80008622:	51 0a       	stdsp	sp[0x40],r10
80008624:	72 09       	ld.w	r9,r9[0x0]
80008626:	fa c6 f9 44 	sub	r6,sp,-1724
8000862a:	ec 08 00 3a 	add	r10,r6,r8<<0x3
8000862e:	2f f8       	sub	r8,-1
80008630:	f5 49 fd 88 	st.w	r10[-632],r9
80008634:	fb 48 06 b4 	st.w	sp[1716],r8
80008638:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
8000863c:	c0 48       	rjmp	80008644 <_vfprintf_r+0x4e8>
8000863e:	13 b8       	ld.ub	r8,r9[0x3]
80008640:	2f c9       	sub	r9,-4
80008642:	51 09       	stdsp	sp[0x40],r9
80008644:	fb 68 06 60 	st.b	sp[1632],r8
80008648:	30 0e       	mov	lr,0
8000864a:	30 08       	mov	r8,0
8000864c:	30 12       	mov	r2,1
8000864e:	fb 68 06 bb 	st.b	sp[1723],r8
80008652:	50 2e       	stdsp	sp[0x8],lr
80008654:	e0 8f 08 ad 	bral	800097ae <_vfprintf_r+0x1652>
80008658:	50 a7       	stdsp	sp[0x28],r7
8000865a:	50 80       	stdsp	sp[0x20],r0
8000865c:	0c 97       	mov	r7,r6
8000865e:	04 94       	mov	r4,r2
80008660:	06 96       	mov	r6,r3
80008662:	02 92       	mov	r2,r1
80008664:	40 93       	lddsp	r3,sp[0x24]
80008666:	10 90       	mov	r0,r8
80008668:	40 41       	lddsp	r1,sp[0x10]
8000866a:	a5 a5       	sbr	r5,0x4
8000866c:	c0 a8       	rjmp	80008680 <_vfprintf_r+0x524>
8000866e:	50 a7       	stdsp	sp[0x28],r7
80008670:	50 80       	stdsp	sp[0x20],r0
80008672:	0c 97       	mov	r7,r6
80008674:	04 94       	mov	r4,r2
80008676:	06 96       	mov	r6,r3
80008678:	02 92       	mov	r2,r1
8000867a:	40 93       	lddsp	r3,sp[0x24]
8000867c:	10 90       	mov	r0,r8
8000867e:	40 41       	lddsp	r1,sp[0x10]
80008680:	ed b5 00 05 	bld	r5,0x5
80008684:	c5 11       	brne	80008726 <_vfprintf_r+0x5ca>
80008686:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000868a:	40 3c       	lddsp	r12,sp[0xc]
8000868c:	58 0c       	cp.w	r12,0
8000868e:	c1 e0       	breq	800086ca <_vfprintf_r+0x56e>
80008690:	10 36       	cp.w	r6,r8
80008692:	c0 64       	brge	8000869e <_vfprintf_r+0x542>
80008694:	fa cb f9 44 	sub	r11,sp,-1724
80008698:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000869c:	c2 08       	rjmp	800086dc <_vfprintf_r+0x580>
8000869e:	fa c8 f9 50 	sub	r8,sp,-1712
800086a2:	1a d8       	st.w	--sp,r8
800086a4:	fa c8 fa b8 	sub	r8,sp,-1352
800086a8:	0c 9b       	mov	r11,r6
800086aa:	1a d8       	st.w	--sp,r8
800086ac:	fa c8 fb b4 	sub	r8,sp,-1100
800086b0:	1a d8       	st.w	--sp,r8
800086b2:	fa c9 ff b4 	sub	r9,sp,-76
800086b6:	fa c8 f9 40 	sub	r8,sp,-1728
800086ba:	04 9a       	mov	r10,r2
800086bc:	08 9c       	mov	r12,r4
800086be:	fe b0 fb b7 	rcall	80007e2c <get_arg>
800086c2:	2f dd       	sub	sp,-12
800086c4:	78 1b       	ld.w	r11,r12[0x4]
800086c6:	78 09       	ld.w	r9,r12[0x0]
800086c8:	c2 b8       	rjmp	8000871e <_vfprintf_r+0x5c2>
800086ca:	ee ca ff ff 	sub	r10,r7,-1
800086ce:	10 37       	cp.w	r7,r8
800086d0:	c0 b4       	brge	800086e6 <_vfprintf_r+0x58a>
800086d2:	fa c9 f9 44 	sub	r9,sp,-1724
800086d6:	14 97       	mov	r7,r10
800086d8:	f2 06 00 36 	add	r6,r9,r6<<0x3
800086dc:	ec fb fd 8c 	ld.w	r11,r6[-628]
800086e0:	ec f9 fd 88 	ld.w	r9,r6[-632]
800086e4:	c1 d8       	rjmp	8000871e <_vfprintf_r+0x5c2>
800086e6:	41 09       	lddsp	r9,sp[0x40]
800086e8:	59 f8       	cp.w	r8,31
800086ea:	e0 89 00 14 	brgt	80008712 <_vfprintf_r+0x5b6>
800086ee:	f2 cb ff f8 	sub	r11,r9,-8
800086f2:	51 0b       	stdsp	sp[0x40],r11
800086f4:	fa c6 f9 44 	sub	r6,sp,-1724
800086f8:	72 1b       	ld.w	r11,r9[0x4]
800086fa:	ec 08 00 3c 	add	r12,r6,r8<<0x3
800086fe:	72 09       	ld.w	r9,r9[0x0]
80008700:	f9 4b fd 8c 	st.w	r12[-628],r11
80008704:	f9 49 fd 88 	st.w	r12[-632],r9
80008708:	2f f8       	sub	r8,-1
8000870a:	14 97       	mov	r7,r10
8000870c:	fb 48 06 b4 	st.w	sp[1716],r8
80008710:	c0 78       	rjmp	8000871e <_vfprintf_r+0x5c2>
80008712:	f2 c8 ff f8 	sub	r8,r9,-8
80008716:	72 1b       	ld.w	r11,r9[0x4]
80008718:	14 97       	mov	r7,r10
8000871a:	51 08       	stdsp	sp[0x40],r8
8000871c:	72 09       	ld.w	r9,r9[0x0]
8000871e:	16 98       	mov	r8,r11
80008720:	fa e9 00 00 	st.d	sp[0],r8
80008724:	ca e8       	rjmp	80008880 <_vfprintf_r+0x724>
80008726:	ed b5 00 04 	bld	r5,0x4
8000872a:	c1 71       	brne	80008758 <_vfprintf_r+0x5fc>
8000872c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008730:	40 3e       	lddsp	lr,sp[0xc]
80008732:	58 0e       	cp.w	lr,0
80008734:	c0 80       	breq	80008744 <_vfprintf_r+0x5e8>
80008736:	10 36       	cp.w	r6,r8
80008738:	c6 94       	brge	8000880a <_vfprintf_r+0x6ae>
8000873a:	fa cc f9 44 	sub	r12,sp,-1724
8000873e:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008742:	c8 28       	rjmp	80008846 <_vfprintf_r+0x6ea>
80008744:	ee ca ff ff 	sub	r10,r7,-1
80008748:	10 37       	cp.w	r7,r8
8000874a:	e0 84 00 81 	brge	8000884c <_vfprintf_r+0x6f0>
8000874e:	fa cb f9 44 	sub	r11,sp,-1724
80008752:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008756:	c7 78       	rjmp	80008844 <_vfprintf_r+0x6e8>
80008758:	ed b5 00 06 	bld	r5,0x6
8000875c:	c4 b1       	brne	800087f2 <_vfprintf_r+0x696>
8000875e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008762:	40 3c       	lddsp	r12,sp[0xc]
80008764:	58 0c       	cp.w	r12,0
80008766:	c1 d0       	breq	800087a0 <_vfprintf_r+0x644>
80008768:	10 36       	cp.w	r6,r8
8000876a:	c0 64       	brge	80008776 <_vfprintf_r+0x61a>
8000876c:	fa cb f9 44 	sub	r11,sp,-1724
80008770:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008774:	c1 f8       	rjmp	800087b2 <_vfprintf_r+0x656>
80008776:	fa c8 f9 50 	sub	r8,sp,-1712
8000877a:	1a d8       	st.w	--sp,r8
8000877c:	fa c8 fa b8 	sub	r8,sp,-1352
80008780:	1a d8       	st.w	--sp,r8
80008782:	fa c8 fb b4 	sub	r8,sp,-1100
80008786:	1a d8       	st.w	--sp,r8
80008788:	fa c8 f9 40 	sub	r8,sp,-1728
8000878c:	fa c9 ff b4 	sub	r9,sp,-76
80008790:	04 9a       	mov	r10,r2
80008792:	0c 9b       	mov	r11,r6
80008794:	08 9c       	mov	r12,r4
80008796:	fe b0 fb 4b 	rcall	80007e2c <get_arg>
8000879a:	2f dd       	sub	sp,-12
8000879c:	98 18       	ld.sh	r8,r12[0x2]
8000879e:	c2 68       	rjmp	800087ea <_vfprintf_r+0x68e>
800087a0:	ee ca ff ff 	sub	r10,r7,-1
800087a4:	10 37       	cp.w	r7,r8
800087a6:	c0 94       	brge	800087b8 <_vfprintf_r+0x65c>
800087a8:	fa c9 f9 44 	sub	r9,sp,-1724
800087ac:	14 97       	mov	r7,r10
800087ae:	f2 06 00 36 	add	r6,r9,r6<<0x3
800087b2:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
800087b6:	c1 a8       	rjmp	800087ea <_vfprintf_r+0x68e>
800087b8:	41 09       	lddsp	r9,sp[0x40]
800087ba:	59 f8       	cp.w	r8,31
800087bc:	e0 89 00 13 	brgt	800087e2 <_vfprintf_r+0x686>
800087c0:	f2 cb ff fc 	sub	r11,r9,-4
800087c4:	51 0b       	stdsp	sp[0x40],r11
800087c6:	72 09       	ld.w	r9,r9[0x0]
800087c8:	fa c6 f9 44 	sub	r6,sp,-1724
800087cc:	ec 08 00 3b 	add	r11,r6,r8<<0x3
800087d0:	2f f8       	sub	r8,-1
800087d2:	f7 49 fd 88 	st.w	r11[-632],r9
800087d6:	fb 48 06 b4 	st.w	sp[1716],r8
800087da:	14 97       	mov	r7,r10
800087dc:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
800087e0:	c0 58       	rjmp	800087ea <_vfprintf_r+0x68e>
800087e2:	92 18       	ld.sh	r8,r9[0x2]
800087e4:	14 97       	mov	r7,r10
800087e6:	2f c9       	sub	r9,-4
800087e8:	51 09       	stdsp	sp[0x40],r9
800087ea:	50 18       	stdsp	sp[0x4],r8
800087ec:	bf 58       	asr	r8,0x1f
800087ee:	50 08       	stdsp	sp[0x0],r8
800087f0:	c4 88       	rjmp	80008880 <_vfprintf_r+0x724>
800087f2:	fa f8 06 b4 	ld.w	r8,sp[1716]
800087f6:	40 3c       	lddsp	r12,sp[0xc]
800087f8:	58 0c       	cp.w	r12,0
800087fa:	c1 d0       	breq	80008834 <_vfprintf_r+0x6d8>
800087fc:	10 36       	cp.w	r6,r8
800087fe:	c0 64       	brge	8000880a <_vfprintf_r+0x6ae>
80008800:	fa cb f9 44 	sub	r11,sp,-1724
80008804:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008808:	c1 f8       	rjmp	80008846 <_vfprintf_r+0x6ea>
8000880a:	fa c8 f9 50 	sub	r8,sp,-1712
8000880e:	1a d8       	st.w	--sp,r8
80008810:	fa c8 fa b8 	sub	r8,sp,-1352
80008814:	0c 9b       	mov	r11,r6
80008816:	1a d8       	st.w	--sp,r8
80008818:	fa c8 fb b4 	sub	r8,sp,-1100
8000881c:	04 9a       	mov	r10,r2
8000881e:	1a d8       	st.w	--sp,r8
80008820:	08 9c       	mov	r12,r4
80008822:	fa c8 f9 40 	sub	r8,sp,-1728
80008826:	fa c9 ff b4 	sub	r9,sp,-76
8000882a:	fe b0 fb 01 	rcall	80007e2c <get_arg>
8000882e:	2f dd       	sub	sp,-12
80008830:	78 0b       	ld.w	r11,r12[0x0]
80008832:	c2 48       	rjmp	8000887a <_vfprintf_r+0x71e>
80008834:	ee ca ff ff 	sub	r10,r7,-1
80008838:	10 37       	cp.w	r7,r8
8000883a:	c0 94       	brge	8000884c <_vfprintf_r+0x6f0>
8000883c:	fa c9 f9 44 	sub	r9,sp,-1724
80008840:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008844:	14 97       	mov	r7,r10
80008846:	ec fb fd 88 	ld.w	r11,r6[-632]
8000884a:	c1 88       	rjmp	8000887a <_vfprintf_r+0x71e>
8000884c:	41 09       	lddsp	r9,sp[0x40]
8000884e:	59 f8       	cp.w	r8,31
80008850:	e0 89 00 11 	brgt	80008872 <_vfprintf_r+0x716>
80008854:	f2 cb ff fc 	sub	r11,r9,-4
80008858:	51 0b       	stdsp	sp[0x40],r11
8000885a:	fa c6 f9 44 	sub	r6,sp,-1724
8000885e:	72 0b       	ld.w	r11,r9[0x0]
80008860:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008864:	f3 4b fd 88 	st.w	r9[-632],r11
80008868:	2f f8       	sub	r8,-1
8000886a:	14 97       	mov	r7,r10
8000886c:	fb 48 06 b4 	st.w	sp[1716],r8
80008870:	c0 58       	rjmp	8000887a <_vfprintf_r+0x71e>
80008872:	72 0b       	ld.w	r11,r9[0x0]
80008874:	14 97       	mov	r7,r10
80008876:	2f c9       	sub	r9,-4
80008878:	51 09       	stdsp	sp[0x40],r9
8000887a:	50 1b       	stdsp	sp[0x4],r11
8000887c:	bf 5b       	asr	r11,0x1f
8000887e:	50 0b       	stdsp	sp[0x0],r11
80008880:	fa ea 00 00 	ld.d	r10,sp[0]
80008884:	58 0a       	cp.w	r10,0
80008886:	5c 2b       	cpc	r11
80008888:	c0 e4       	brge	800088a4 <_vfprintf_r+0x748>
8000888a:	30 08       	mov	r8,0
8000888c:	fa ea 00 00 	ld.d	r10,sp[0]
80008890:	30 09       	mov	r9,0
80008892:	f0 0a 01 0a 	sub	r10,r8,r10
80008896:	f2 0b 01 4b 	sbc	r11,r9,r11
8000889a:	32 d8       	mov	r8,45
8000889c:	fa eb 00 00 	st.d	sp[0],r10
800088a0:	fb 68 06 bb 	st.b	sp[1723],r8
800088a4:	30 18       	mov	r8,1
800088a6:	e0 8f 06 fa 	bral	8000969a <_vfprintf_r+0x153e>
800088aa:	50 a7       	stdsp	sp[0x28],r7
800088ac:	50 80       	stdsp	sp[0x20],r0
800088ae:	0c 97       	mov	r7,r6
800088b0:	04 94       	mov	r4,r2
800088b2:	06 96       	mov	r6,r3
800088b4:	02 92       	mov	r2,r1
800088b6:	40 93       	lddsp	r3,sp[0x24]
800088b8:	10 90       	mov	r0,r8
800088ba:	40 41       	lddsp	r1,sp[0x10]
800088bc:	0e 99       	mov	r9,r7
800088be:	ed b5 00 03 	bld	r5,0x3
800088c2:	c4 11       	brne	80008944 <_vfprintf_r+0x7e8>
800088c4:	fa f8 06 b4 	ld.w	r8,sp[1716]
800088c8:	40 3a       	lddsp	r10,sp[0xc]
800088ca:	58 0a       	cp.w	r10,0
800088cc:	c1 90       	breq	800088fe <_vfprintf_r+0x7a2>
800088ce:	10 36       	cp.w	r6,r8
800088d0:	c6 45       	brlt	80008998 <_vfprintf_r+0x83c>
800088d2:	fa c8 f9 50 	sub	r8,sp,-1712
800088d6:	1a d8       	st.w	--sp,r8
800088d8:	fa c8 fa b8 	sub	r8,sp,-1352
800088dc:	1a d8       	st.w	--sp,r8
800088de:	fa c8 fb b4 	sub	r8,sp,-1100
800088e2:	0c 9b       	mov	r11,r6
800088e4:	1a d8       	st.w	--sp,r8
800088e6:	04 9a       	mov	r10,r2
800088e8:	fa c8 f9 40 	sub	r8,sp,-1728
800088ec:	fa c9 ff b4 	sub	r9,sp,-76
800088f0:	08 9c       	mov	r12,r4
800088f2:	fe b0 fa 9d 	rcall	80007e2c <get_arg>
800088f6:	2f dd       	sub	sp,-12
800088f8:	78 16       	ld.w	r6,r12[0x4]
800088fa:	50 76       	stdsp	sp[0x1c],r6
800088fc:	c4 88       	rjmp	8000898c <_vfprintf_r+0x830>
800088fe:	2f f7       	sub	r7,-1
80008900:	10 39       	cp.w	r9,r8
80008902:	c0 c4       	brge	8000891a <_vfprintf_r+0x7be>
80008904:	fa ce f9 44 	sub	lr,sp,-1724
80008908:	fc 06 00 36 	add	r6,lr,r6<<0x3
8000890c:	ec fc fd 8c 	ld.w	r12,r6[-628]
80008910:	50 7c       	stdsp	sp[0x1c],r12
80008912:	ec f6 fd 88 	ld.w	r6,r6[-632]
80008916:	50 56       	stdsp	sp[0x14],r6
80008918:	c6 68       	rjmp	800089e4 <_vfprintf_r+0x888>
8000891a:	41 09       	lddsp	r9,sp[0x40]
8000891c:	59 f8       	cp.w	r8,31
8000891e:	e0 89 00 10 	brgt	8000893e <_vfprintf_r+0x7e2>
80008922:	f2 ca ff f8 	sub	r10,r9,-8
80008926:	72 1b       	ld.w	r11,r9[0x4]
80008928:	51 0a       	stdsp	sp[0x40],r10
8000892a:	72 09       	ld.w	r9,r9[0x0]
8000892c:	fa ca f9 44 	sub	r10,sp,-1724
80008930:	50 7b       	stdsp	sp[0x1c],r11
80008932:	50 59       	stdsp	sp[0x14],r9
80008934:	f4 08 00 39 	add	r9,r10,r8<<0x3
80008938:	40 5b       	lddsp	r11,sp[0x14]
8000893a:	40 7a       	lddsp	r10,sp[0x1c]
8000893c:	c4 78       	rjmp	800089ca <_vfprintf_r+0x86e>
8000893e:	72 18       	ld.w	r8,r9[0x4]
80008940:	50 78       	stdsp	sp[0x1c],r8
80008942:	c4 c8       	rjmp	800089da <_vfprintf_r+0x87e>
80008944:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008948:	40 3e       	lddsp	lr,sp[0xc]
8000894a:	58 0e       	cp.w	lr,0
8000894c:	c2 30       	breq	80008992 <_vfprintf_r+0x836>
8000894e:	10 36       	cp.w	r6,r8
80008950:	c0 94       	brge	80008962 <_vfprintf_r+0x806>
80008952:	fa cc f9 44 	sub	r12,sp,-1724
80008956:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000895a:	ec fb fd 8c 	ld.w	r11,r6[-628]
8000895e:	50 7b       	stdsp	sp[0x1c],r11
80008960:	cd 9b       	rjmp	80008912 <_vfprintf_r+0x7b6>
80008962:	fa c8 f9 50 	sub	r8,sp,-1712
80008966:	1a d8       	st.w	--sp,r8
80008968:	fa c8 fa b8 	sub	r8,sp,-1352
8000896c:	04 9a       	mov	r10,r2
8000896e:	1a d8       	st.w	--sp,r8
80008970:	fa c8 fb b4 	sub	r8,sp,-1100
80008974:	0c 9b       	mov	r11,r6
80008976:	1a d8       	st.w	--sp,r8
80008978:	08 9c       	mov	r12,r4
8000897a:	fa c8 f9 40 	sub	r8,sp,-1728
8000897e:	fa c9 ff b4 	sub	r9,sp,-76
80008982:	fe b0 fa 55 	rcall	80007e2c <get_arg>
80008986:	2f dd       	sub	sp,-12
80008988:	78 1a       	ld.w	r10,r12[0x4]
8000898a:	50 7a       	stdsp	sp[0x1c],r10
8000898c:	78 0c       	ld.w	r12,r12[0x0]
8000898e:	50 5c       	stdsp	sp[0x14],r12
80008990:	c2 a8       	rjmp	800089e4 <_vfprintf_r+0x888>
80008992:	2f f7       	sub	r7,-1
80008994:	10 39       	cp.w	r9,r8
80008996:	c0 94       	brge	800089a8 <_vfprintf_r+0x84c>
80008998:	fa c9 f9 44 	sub	r9,sp,-1724
8000899c:	f2 06 00 36 	add	r6,r9,r6<<0x3
800089a0:	ec f8 fd 8c 	ld.w	r8,r6[-628]
800089a4:	50 78       	stdsp	sp[0x1c],r8
800089a6:	cb 6b       	rjmp	80008912 <_vfprintf_r+0x7b6>
800089a8:	41 09       	lddsp	r9,sp[0x40]
800089aa:	59 f8       	cp.w	r8,31
800089ac:	e0 89 00 15 	brgt	800089d6 <_vfprintf_r+0x87a>
800089b0:	f2 ca ff f8 	sub	r10,r9,-8
800089b4:	72 16       	ld.w	r6,r9[0x4]
800089b6:	72 09       	ld.w	r9,r9[0x0]
800089b8:	51 0a       	stdsp	sp[0x40],r10
800089ba:	50 59       	stdsp	sp[0x14],r9
800089bc:	fa ce f9 44 	sub	lr,sp,-1724
800089c0:	50 76       	stdsp	sp[0x1c],r6
800089c2:	fc 08 00 39 	add	r9,lr,r8<<0x3
800089c6:	40 5b       	lddsp	r11,sp[0x14]
800089c8:	0c 9a       	mov	r10,r6
800089ca:	f2 eb fd 88 	st.d	r9[-632],r10
800089ce:	2f f8       	sub	r8,-1
800089d0:	fb 48 06 b4 	st.w	sp[1716],r8
800089d4:	c0 88       	rjmp	800089e4 <_vfprintf_r+0x888>
800089d6:	72 1c       	ld.w	r12,r9[0x4]
800089d8:	50 7c       	stdsp	sp[0x1c],r12
800089da:	f2 c8 ff f8 	sub	r8,r9,-8
800089de:	51 08       	stdsp	sp[0x40],r8
800089e0:	72 09       	ld.w	r9,r9[0x0]
800089e2:	50 59       	stdsp	sp[0x14],r9
800089e4:	40 5b       	lddsp	r11,sp[0x14]
800089e6:	40 7a       	lddsp	r10,sp[0x1c]
800089e8:	e0 a0 19 54 	rcall	8000bc90 <__isinfd>
800089ec:	18 96       	mov	r6,r12
800089ee:	c1 70       	breq	80008a1c <_vfprintf_r+0x8c0>
800089f0:	30 08       	mov	r8,0
800089f2:	30 09       	mov	r9,0
800089f4:	40 5b       	lddsp	r11,sp[0x14]
800089f6:	40 7a       	lddsp	r10,sp[0x1c]
800089f8:	e0 a0 1d b4 	rcall	8000c560 <__avr32_f64_cmp_lt>
800089fc:	c0 40       	breq	80008a04 <_vfprintf_r+0x8a8>
800089fe:	32 d8       	mov	r8,45
80008a00:	fb 68 06 bb 	st.b	sp[1723],r8
80008a04:	fe c8 aa 34 	sub	r8,pc,-21964
80008a08:	fe c6 aa 34 	sub	r6,pc,-21964
80008a0c:	a7 d5       	cbr	r5,0x7
80008a0e:	e0 40 00 47 	cp.w	r0,71
80008a12:	f0 06 17 a0 	movle	r6,r8
80008a16:	30 32       	mov	r2,3
80008a18:	e0 8f 06 ce 	bral	800097b4 <_vfprintf_r+0x1658>
80008a1c:	40 5b       	lddsp	r11,sp[0x14]
80008a1e:	40 7a       	lddsp	r10,sp[0x1c]
80008a20:	e0 a0 19 4d 	rcall	8000bcba <__isnand>
80008a24:	c0 e0       	breq	80008a40 <_vfprintf_r+0x8e4>
80008a26:	50 26       	stdsp	sp[0x8],r6
80008a28:	fe c8 aa 50 	sub	r8,pc,-21936
80008a2c:	fe c6 aa 50 	sub	r6,pc,-21936
80008a30:	a7 d5       	cbr	r5,0x7
80008a32:	e0 40 00 47 	cp.w	r0,71
80008a36:	f0 06 17 a0 	movle	r6,r8
80008a3a:	30 32       	mov	r2,3
80008a3c:	e0 8f 06 c2 	bral	800097c0 <_vfprintf_r+0x1664>
80008a40:	40 2a       	lddsp	r10,sp[0x8]
80008a42:	5b fa       	cp.w	r10,-1
80008a44:	c0 41       	brne	80008a4c <_vfprintf_r+0x8f0>
80008a46:	30 69       	mov	r9,6
80008a48:	50 29       	stdsp	sp[0x8],r9
80008a4a:	c1 18       	rjmp	80008a6c <_vfprintf_r+0x910>
80008a4c:	e0 40 00 47 	cp.w	r0,71
80008a50:	5f 09       	sreq	r9
80008a52:	e0 40 00 67 	cp.w	r0,103
80008a56:	5f 08       	sreq	r8
80008a58:	f3 e8 10 08 	or	r8,r9,r8
80008a5c:	f8 08 18 00 	cp.b	r8,r12
80008a60:	c0 60       	breq	80008a6c <_vfprintf_r+0x910>
80008a62:	40 28       	lddsp	r8,sp[0x8]
80008a64:	58 08       	cp.w	r8,0
80008a66:	f9 b8 00 01 	moveq	r8,1
80008a6a:	50 28       	stdsp	sp[0x8],r8
80008a6c:	40 78       	lddsp	r8,sp[0x1c]
80008a6e:	40 59       	lddsp	r9,sp[0x14]
80008a70:	fa e9 06 94 	st.d	sp[1684],r8
80008a74:	a9 a5       	sbr	r5,0x8
80008a76:	fa f8 06 94 	ld.w	r8,sp[1684]
80008a7a:	58 08       	cp.w	r8,0
80008a7c:	c0 65       	brlt	80008a88 <_vfprintf_r+0x92c>
80008a7e:	40 5e       	lddsp	lr,sp[0x14]
80008a80:	30 0c       	mov	r12,0
80008a82:	50 6e       	stdsp	sp[0x18],lr
80008a84:	50 9c       	stdsp	sp[0x24],r12
80008a86:	c0 78       	rjmp	80008a94 <_vfprintf_r+0x938>
80008a88:	40 5b       	lddsp	r11,sp[0x14]
80008a8a:	32 da       	mov	r10,45
80008a8c:	ee 1b 80 00 	eorh	r11,0x8000
80008a90:	50 9a       	stdsp	sp[0x24],r10
80008a92:	50 6b       	stdsp	sp[0x18],r11
80008a94:	e0 40 00 46 	cp.w	r0,70
80008a98:	5f 09       	sreq	r9
80008a9a:	e0 40 00 66 	cp.w	r0,102
80008a9e:	5f 08       	sreq	r8
80008aa0:	f3 e8 10 08 	or	r8,r9,r8
80008aa4:	50 48       	stdsp	sp[0x10],r8
80008aa6:	c0 40       	breq	80008aae <_vfprintf_r+0x952>
80008aa8:	40 22       	lddsp	r2,sp[0x8]
80008aaa:	30 39       	mov	r9,3
80008aac:	c1 08       	rjmp	80008acc <_vfprintf_r+0x970>
80008aae:	e0 40 00 45 	cp.w	r0,69
80008ab2:	5f 09       	sreq	r9
80008ab4:	e0 40 00 65 	cp.w	r0,101
80008ab8:	5f 08       	sreq	r8
80008aba:	40 22       	lddsp	r2,sp[0x8]
80008abc:	10 49       	or	r9,r8
80008abe:	2f f2       	sub	r2,-1
80008ac0:	40 46       	lddsp	r6,sp[0x10]
80008ac2:	ec 09 18 00 	cp.b	r9,r6
80008ac6:	fb f2 00 02 	ld.weq	r2,sp[0x8]
80008aca:	30 29       	mov	r9,2
80008acc:	fa c8 f9 5c 	sub	r8,sp,-1700
80008ad0:	1a d8       	st.w	--sp,r8
80008ad2:	fa c8 f9 54 	sub	r8,sp,-1708
80008ad6:	1a d8       	st.w	--sp,r8
80008ad8:	fa c8 f9 4c 	sub	r8,sp,-1716
80008adc:	08 9c       	mov	r12,r4
80008ade:	1a d8       	st.w	--sp,r8
80008ae0:	04 98       	mov	r8,r2
80008ae2:	40 9b       	lddsp	r11,sp[0x24]
80008ae4:	40 aa       	lddsp	r10,sp[0x28]
80008ae6:	e0 a0 0b c3 	rcall	8000a26c <_dtoa_r>
80008aea:	e0 40 00 47 	cp.w	r0,71
80008aee:	5f 19       	srne	r9
80008af0:	e0 40 00 67 	cp.w	r0,103
80008af4:	5f 18       	srne	r8
80008af6:	18 96       	mov	r6,r12
80008af8:	2f dd       	sub	sp,-12
80008afa:	f3 e8 00 08 	and	r8,r9,r8
80008afe:	c0 41       	brne	80008b06 <_vfprintf_r+0x9aa>
80008b00:	ed b5 00 00 	bld	r5,0x0
80008b04:	c3 01       	brne	80008b64 <_vfprintf_r+0xa08>
80008b06:	ec 02 00 0e 	add	lr,r6,r2
80008b0a:	50 3e       	stdsp	sp[0xc],lr
80008b0c:	40 4c       	lddsp	r12,sp[0x10]
80008b0e:	58 0c       	cp.w	r12,0
80008b10:	c1 50       	breq	80008b3a <_vfprintf_r+0x9de>
80008b12:	0d 89       	ld.ub	r9,r6[0x0]
80008b14:	33 08       	mov	r8,48
80008b16:	f0 09 18 00 	cp.b	r9,r8
80008b1a:	c0 b1       	brne	80008b30 <_vfprintf_r+0x9d4>
80008b1c:	30 08       	mov	r8,0
80008b1e:	30 09       	mov	r9,0
80008b20:	40 6b       	lddsp	r11,sp[0x18]
80008b22:	40 7a       	lddsp	r10,sp[0x1c]
80008b24:	e0 a0 1c d7 	rcall	8000c4d2 <__avr32_f64_cmp_eq>
80008b28:	fb b2 00 01 	rsubeq	r2,1
80008b2c:	fb f2 0b ab 	st.weq	sp[0x6ac],r2
80008b30:	40 3b       	lddsp	r11,sp[0xc]
80008b32:	fa f8 06 ac 	ld.w	r8,sp[1708]
80008b36:	10 0b       	add	r11,r8
80008b38:	50 3b       	stdsp	sp[0xc],r11
80008b3a:	40 6b       	lddsp	r11,sp[0x18]
80008b3c:	30 08       	mov	r8,0
80008b3e:	30 09       	mov	r9,0
80008b40:	40 7a       	lddsp	r10,sp[0x1c]
80008b42:	e0 a0 1c c8 	rcall	8000c4d2 <__avr32_f64_cmp_eq>
80008b46:	c0 90       	breq	80008b58 <_vfprintf_r+0x9fc>
80008b48:	40 3a       	lddsp	r10,sp[0xc]
80008b4a:	fb 4a 06 a4 	st.w	sp[1700],r10
80008b4e:	c0 58       	rjmp	80008b58 <_vfprintf_r+0x9fc>
80008b50:	10 c9       	st.b	r8++,r9
80008b52:	fb 48 06 a4 	st.w	sp[1700],r8
80008b56:	c0 28       	rjmp	80008b5a <_vfprintf_r+0x9fe>
80008b58:	33 09       	mov	r9,48
80008b5a:	fa f8 06 a4 	ld.w	r8,sp[1700]
80008b5e:	40 3e       	lddsp	lr,sp[0xc]
80008b60:	1c 38       	cp.w	r8,lr
80008b62:	cf 73       	brcs	80008b50 <_vfprintf_r+0x9f4>
80008b64:	e0 40 00 47 	cp.w	r0,71
80008b68:	5f 09       	sreq	r9
80008b6a:	e0 40 00 67 	cp.w	r0,103
80008b6e:	5f 08       	sreq	r8
80008b70:	f3 e8 10 08 	or	r8,r9,r8
80008b74:	fa f9 06 a4 	ld.w	r9,sp[1700]
80008b78:	0c 19       	sub	r9,r6
80008b7a:	50 69       	stdsp	sp[0x18],r9
80008b7c:	58 08       	cp.w	r8,0
80008b7e:	c0 b0       	breq	80008b94 <_vfprintf_r+0xa38>
80008b80:	fa f8 06 ac 	ld.w	r8,sp[1708]
80008b84:	5b d8       	cp.w	r8,-3
80008b86:	c0 55       	brlt	80008b90 <_vfprintf_r+0xa34>
80008b88:	40 2c       	lddsp	r12,sp[0x8]
80008b8a:	18 38       	cp.w	r8,r12
80008b8c:	e0 8a 00 6a 	brle	80008c60 <_vfprintf_r+0xb04>
80008b90:	20 20       	sub	r0,2
80008b92:	c0 58       	rjmp	80008b9c <_vfprintf_r+0xa40>
80008b94:	e0 40 00 65 	cp.w	r0,101
80008b98:	e0 89 00 46 	brgt	80008c24 <_vfprintf_r+0xac8>
80008b9c:	fa fb 06 ac 	ld.w	r11,sp[1708]
80008ba0:	fb 60 06 9c 	st.b	sp[1692],r0
80008ba4:	20 1b       	sub	r11,1
80008ba6:	fb 4b 06 ac 	st.w	sp[1708],r11
80008baa:	c0 47       	brpl	80008bb2 <_vfprintf_r+0xa56>
80008bac:	5c 3b       	neg	r11
80008bae:	32 d8       	mov	r8,45
80008bb0:	c0 28       	rjmp	80008bb4 <_vfprintf_r+0xa58>
80008bb2:	32 b8       	mov	r8,43
80008bb4:	fb 68 06 9d 	st.b	sp[1693],r8
80008bb8:	58 9b       	cp.w	r11,9
80008bba:	e0 8a 00 1d 	brle	80008bf4 <_vfprintf_r+0xa98>
80008bbe:	fa c9 fa 35 	sub	r9,sp,-1483
80008bc2:	30 aa       	mov	r10,10
80008bc4:	12 98       	mov	r8,r9
80008bc6:	0e 9c       	mov	r12,r7
80008bc8:	0c 92       	mov	r2,r6
80008bca:	f6 0a 0c 06 	divs	r6,r11,r10
80008bce:	0e 9b       	mov	r11,r7
80008bd0:	2d 0b       	sub	r11,-48
80008bd2:	10 fb       	st.b	--r8,r11
80008bd4:	0c 9b       	mov	r11,r6
80008bd6:	58 96       	cp.w	r6,9
80008bd8:	fe 99 ff f9 	brgt	80008bca <_vfprintf_r+0xa6e>
80008bdc:	2d 0b       	sub	r11,-48
80008bde:	18 97       	mov	r7,r12
80008be0:	04 96       	mov	r6,r2
80008be2:	10 fb       	st.b	--r8,r11
80008be4:	fa ca f9 62 	sub	r10,sp,-1694
80008be8:	c0 38       	rjmp	80008bee <_vfprintf_r+0xa92>
80008bea:	11 3b       	ld.ub	r11,r8++
80008bec:	14 cb       	st.b	r10++,r11
80008bee:	12 38       	cp.w	r8,r9
80008bf0:	cf d3       	brcs	80008bea <_vfprintf_r+0xa8e>
80008bf2:	c0 98       	rjmp	80008c04 <_vfprintf_r+0xaa8>
80008bf4:	2d 0b       	sub	r11,-48
80008bf6:	33 08       	mov	r8,48
80008bf8:	fb 6b 06 9f 	st.b	sp[1695],r11
80008bfc:	fb 68 06 9e 	st.b	sp[1694],r8
80008c00:	fa ca f9 60 	sub	r10,sp,-1696
80008c04:	fa c8 f9 64 	sub	r8,sp,-1692
80008c08:	f4 08 01 08 	sub	r8,r10,r8
80008c0c:	50 e8       	stdsp	sp[0x38],r8
80008c0e:	10 92       	mov	r2,r8
80008c10:	40 6b       	lddsp	r11,sp[0x18]
80008c12:	16 02       	add	r2,r11
80008c14:	58 1b       	cp.w	r11,1
80008c16:	e0 89 00 05 	brgt	80008c20 <_vfprintf_r+0xac4>
80008c1a:	ed b5 00 00 	bld	r5,0x0
80008c1e:	c3 51       	brne	80008c88 <_vfprintf_r+0xb2c>
80008c20:	2f f2       	sub	r2,-1
80008c22:	c3 38       	rjmp	80008c88 <_vfprintf_r+0xb2c>
80008c24:	e0 40 00 66 	cp.w	r0,102
80008c28:	c1 c1       	brne	80008c60 <_vfprintf_r+0xb04>
80008c2a:	fa f2 06 ac 	ld.w	r2,sp[1708]
80008c2e:	58 02       	cp.w	r2,0
80008c30:	e0 8a 00 0c 	brle	80008c48 <_vfprintf_r+0xaec>
80008c34:	40 2a       	lddsp	r10,sp[0x8]
80008c36:	58 0a       	cp.w	r10,0
80008c38:	c0 41       	brne	80008c40 <_vfprintf_r+0xae4>
80008c3a:	ed b5 00 00 	bld	r5,0x0
80008c3e:	c2 51       	brne	80008c88 <_vfprintf_r+0xb2c>
80008c40:	2f f2       	sub	r2,-1
80008c42:	40 29       	lddsp	r9,sp[0x8]
80008c44:	12 02       	add	r2,r9
80008c46:	c0 b8       	rjmp	80008c5c <_vfprintf_r+0xb00>
80008c48:	40 28       	lddsp	r8,sp[0x8]
80008c4a:	58 08       	cp.w	r8,0
80008c4c:	c0 61       	brne	80008c58 <_vfprintf_r+0xafc>
80008c4e:	ed b5 00 00 	bld	r5,0x0
80008c52:	c0 30       	breq	80008c58 <_vfprintf_r+0xafc>
80008c54:	30 12       	mov	r2,1
80008c56:	c1 98       	rjmp	80008c88 <_vfprintf_r+0xb2c>
80008c58:	40 22       	lddsp	r2,sp[0x8]
80008c5a:	2f e2       	sub	r2,-2
80008c5c:	36 60       	mov	r0,102
80008c5e:	c1 58       	rjmp	80008c88 <_vfprintf_r+0xb2c>
80008c60:	fa f2 06 ac 	ld.w	r2,sp[1708]
80008c64:	40 6e       	lddsp	lr,sp[0x18]
80008c66:	1c 32       	cp.w	r2,lr
80008c68:	c0 65       	brlt	80008c74 <_vfprintf_r+0xb18>
80008c6a:	ed b5 00 00 	bld	r5,0x0
80008c6e:	f7 b2 00 ff 	subeq	r2,-1
80008c72:	c0 a8       	rjmp	80008c86 <_vfprintf_r+0xb2a>
80008c74:	e4 08 11 02 	rsub	r8,r2,2
80008c78:	40 6c       	lddsp	r12,sp[0x18]
80008c7a:	58 02       	cp.w	r2,0
80008c7c:	f0 02 17 a0 	movle	r2,r8
80008c80:	f9 b2 09 01 	movgt	r2,1
80008c84:	18 02       	add	r2,r12
80008c86:	36 70       	mov	r0,103
80008c88:	40 9b       	lddsp	r11,sp[0x24]
80008c8a:	58 0b       	cp.w	r11,0
80008c8c:	e0 80 05 94 	breq	800097b4 <_vfprintf_r+0x1658>
80008c90:	32 d8       	mov	r8,45
80008c92:	fb 68 06 bb 	st.b	sp[1723],r8
80008c96:	e0 8f 05 93 	bral	800097bc <_vfprintf_r+0x1660>
80008c9a:	50 a7       	stdsp	sp[0x28],r7
80008c9c:	04 94       	mov	r4,r2
80008c9e:	0c 97       	mov	r7,r6
80008ca0:	02 92       	mov	r2,r1
80008ca2:	06 96       	mov	r6,r3
80008ca4:	40 41       	lddsp	r1,sp[0x10]
80008ca6:	40 93       	lddsp	r3,sp[0x24]
80008ca8:	0e 99       	mov	r9,r7
80008caa:	ed b5 00 05 	bld	r5,0x5
80008cae:	c4 81       	brne	80008d3e <_vfprintf_r+0xbe2>
80008cb0:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008cb4:	40 3e       	lddsp	lr,sp[0xc]
80008cb6:	58 0e       	cp.w	lr,0
80008cb8:	c1 d0       	breq	80008cf2 <_vfprintf_r+0xb96>
80008cba:	10 36       	cp.w	r6,r8
80008cbc:	c0 64       	brge	80008cc8 <_vfprintf_r+0xb6c>
80008cbe:	fa cc f9 44 	sub	r12,sp,-1724
80008cc2:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008cc6:	c1 d8       	rjmp	80008d00 <_vfprintf_r+0xba4>
80008cc8:	fa c8 f9 50 	sub	r8,sp,-1712
80008ccc:	1a d8       	st.w	--sp,r8
80008cce:	fa c8 fa b8 	sub	r8,sp,-1352
80008cd2:	04 9a       	mov	r10,r2
80008cd4:	1a d8       	st.w	--sp,r8
80008cd6:	fa c8 fb b4 	sub	r8,sp,-1100
80008cda:	0c 9b       	mov	r11,r6
80008cdc:	1a d8       	st.w	--sp,r8
80008cde:	08 9c       	mov	r12,r4
80008ce0:	fa c8 f9 40 	sub	r8,sp,-1728
80008ce4:	fa c9 ff b4 	sub	r9,sp,-76
80008ce8:	fe b0 f8 a2 	rcall	80007e2c <get_arg>
80008cec:	2f dd       	sub	sp,-12
80008cee:	78 0a       	ld.w	r10,r12[0x0]
80008cf0:	c2 08       	rjmp	80008d30 <_vfprintf_r+0xbd4>
80008cf2:	2f f7       	sub	r7,-1
80008cf4:	10 39       	cp.w	r9,r8
80008cf6:	c0 84       	brge	80008d06 <_vfprintf_r+0xbaa>
80008cf8:	fa cb f9 44 	sub	r11,sp,-1724
80008cfc:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008d00:	ec fa fd 88 	ld.w	r10,r6[-632]
80008d04:	c1 68       	rjmp	80008d30 <_vfprintf_r+0xbd4>
80008d06:	41 09       	lddsp	r9,sp[0x40]
80008d08:	59 f8       	cp.w	r8,31
80008d0a:	e0 89 00 10 	brgt	80008d2a <_vfprintf_r+0xbce>
80008d0e:	f2 ca ff fc 	sub	r10,r9,-4
80008d12:	51 0a       	stdsp	sp[0x40],r10
80008d14:	fa c6 f9 44 	sub	r6,sp,-1724
80008d18:	72 0a       	ld.w	r10,r9[0x0]
80008d1a:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008d1e:	f3 4a fd 88 	st.w	r9[-632],r10
80008d22:	2f f8       	sub	r8,-1
80008d24:	fb 48 06 b4 	st.w	sp[1716],r8
80008d28:	c0 48       	rjmp	80008d30 <_vfprintf_r+0xbd4>
80008d2a:	72 0a       	ld.w	r10,r9[0x0]
80008d2c:	2f c9       	sub	r9,-4
80008d2e:	51 09       	stdsp	sp[0x40],r9
80008d30:	40 be       	lddsp	lr,sp[0x2c]
80008d32:	1c 98       	mov	r8,lr
80008d34:	95 1e       	st.w	r10[0x4],lr
80008d36:	bf 58       	asr	r8,0x1f
80008d38:	95 08       	st.w	r10[0x0],r8
80008d3a:	fe 9f fa 9f 	bral	80008278 <_vfprintf_r+0x11c>
80008d3e:	ed b5 00 04 	bld	r5,0x4
80008d42:	c4 80       	breq	80008dd2 <_vfprintf_r+0xc76>
80008d44:	e2 15 00 40 	andl	r5,0x40,COH
80008d48:	c4 50       	breq	80008dd2 <_vfprintf_r+0xc76>
80008d4a:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008d4e:	40 3c       	lddsp	r12,sp[0xc]
80008d50:	58 0c       	cp.w	r12,0
80008d52:	c1 d0       	breq	80008d8c <_vfprintf_r+0xc30>
80008d54:	10 36       	cp.w	r6,r8
80008d56:	c0 64       	brge	80008d62 <_vfprintf_r+0xc06>
80008d58:	fa cb f9 44 	sub	r11,sp,-1724
80008d5c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008d60:	c1 d8       	rjmp	80008d9a <_vfprintf_r+0xc3e>
80008d62:	fa c8 f9 50 	sub	r8,sp,-1712
80008d66:	1a d8       	st.w	--sp,r8
80008d68:	fa c8 fa b8 	sub	r8,sp,-1352
80008d6c:	04 9a       	mov	r10,r2
80008d6e:	1a d8       	st.w	--sp,r8
80008d70:	fa c8 fb b4 	sub	r8,sp,-1100
80008d74:	0c 9b       	mov	r11,r6
80008d76:	1a d8       	st.w	--sp,r8
80008d78:	08 9c       	mov	r12,r4
80008d7a:	fa c8 f9 40 	sub	r8,sp,-1728
80008d7e:	fa c9 ff b4 	sub	r9,sp,-76
80008d82:	fe b0 f8 55 	rcall	80007e2c <get_arg>
80008d86:	2f dd       	sub	sp,-12
80008d88:	78 0a       	ld.w	r10,r12[0x0]
80008d8a:	c2 08       	rjmp	80008dca <_vfprintf_r+0xc6e>
80008d8c:	2f f7       	sub	r7,-1
80008d8e:	10 39       	cp.w	r9,r8
80008d90:	c0 84       	brge	80008da0 <_vfprintf_r+0xc44>
80008d92:	fa ca f9 44 	sub	r10,sp,-1724
80008d96:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008d9a:	ec fa fd 88 	ld.w	r10,r6[-632]
80008d9e:	c1 68       	rjmp	80008dca <_vfprintf_r+0xc6e>
80008da0:	41 09       	lddsp	r9,sp[0x40]
80008da2:	59 f8       	cp.w	r8,31
80008da4:	e0 89 00 10 	brgt	80008dc4 <_vfprintf_r+0xc68>
80008da8:	f2 ca ff fc 	sub	r10,r9,-4
80008dac:	51 0a       	stdsp	sp[0x40],r10
80008dae:	fa c6 f9 44 	sub	r6,sp,-1724
80008db2:	72 0a       	ld.w	r10,r9[0x0]
80008db4:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008db8:	f3 4a fd 88 	st.w	r9[-632],r10
80008dbc:	2f f8       	sub	r8,-1
80008dbe:	fb 48 06 b4 	st.w	sp[1716],r8
80008dc2:	c0 48       	rjmp	80008dca <_vfprintf_r+0xc6e>
80008dc4:	72 0a       	ld.w	r10,r9[0x0]
80008dc6:	2f c9       	sub	r9,-4
80008dc8:	51 09       	stdsp	sp[0x40],r9
80008dca:	40 be       	lddsp	lr,sp[0x2c]
80008dcc:	b4 0e       	st.h	r10[0x0],lr
80008dce:	fe 9f fa 55 	bral	80008278 <_vfprintf_r+0x11c>
80008dd2:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008dd6:	40 3c       	lddsp	r12,sp[0xc]
80008dd8:	58 0c       	cp.w	r12,0
80008dda:	c1 d0       	breq	80008e14 <_vfprintf_r+0xcb8>
80008ddc:	10 36       	cp.w	r6,r8
80008dde:	c0 64       	brge	80008dea <_vfprintf_r+0xc8e>
80008de0:	fa cb f9 44 	sub	r11,sp,-1724
80008de4:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008de8:	c1 d8       	rjmp	80008e22 <_vfprintf_r+0xcc6>
80008dea:	fa c8 f9 50 	sub	r8,sp,-1712
80008dee:	1a d8       	st.w	--sp,r8
80008df0:	fa c8 fa b8 	sub	r8,sp,-1352
80008df4:	04 9a       	mov	r10,r2
80008df6:	1a d8       	st.w	--sp,r8
80008df8:	fa c8 fb b4 	sub	r8,sp,-1100
80008dfc:	0c 9b       	mov	r11,r6
80008dfe:	1a d8       	st.w	--sp,r8
80008e00:	08 9c       	mov	r12,r4
80008e02:	fa c8 f9 40 	sub	r8,sp,-1728
80008e06:	fa c9 ff b4 	sub	r9,sp,-76
80008e0a:	fe b0 f8 11 	rcall	80007e2c <get_arg>
80008e0e:	2f dd       	sub	sp,-12
80008e10:	78 0a       	ld.w	r10,r12[0x0]
80008e12:	c2 08       	rjmp	80008e52 <_vfprintf_r+0xcf6>
80008e14:	2f f7       	sub	r7,-1
80008e16:	10 39       	cp.w	r9,r8
80008e18:	c0 84       	brge	80008e28 <_vfprintf_r+0xccc>
80008e1a:	fa ca f9 44 	sub	r10,sp,-1724
80008e1e:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008e22:	ec fa fd 88 	ld.w	r10,r6[-632]
80008e26:	c1 68       	rjmp	80008e52 <_vfprintf_r+0xcf6>
80008e28:	41 09       	lddsp	r9,sp[0x40]
80008e2a:	59 f8       	cp.w	r8,31
80008e2c:	e0 89 00 10 	brgt	80008e4c <_vfprintf_r+0xcf0>
80008e30:	f2 ca ff fc 	sub	r10,r9,-4
80008e34:	51 0a       	stdsp	sp[0x40],r10
80008e36:	fa c6 f9 44 	sub	r6,sp,-1724
80008e3a:	72 0a       	ld.w	r10,r9[0x0]
80008e3c:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008e40:	f3 4a fd 88 	st.w	r9[-632],r10
80008e44:	2f f8       	sub	r8,-1
80008e46:	fb 48 06 b4 	st.w	sp[1716],r8
80008e4a:	c0 48       	rjmp	80008e52 <_vfprintf_r+0xcf6>
80008e4c:	72 0a       	ld.w	r10,r9[0x0]
80008e4e:	2f c9       	sub	r9,-4
80008e50:	51 09       	stdsp	sp[0x40],r9
80008e52:	40 be       	lddsp	lr,sp[0x2c]
80008e54:	95 0e       	st.w	r10[0x0],lr
80008e56:	fe 9f fa 11 	bral	80008278 <_vfprintf_r+0x11c>
80008e5a:	50 a7       	stdsp	sp[0x28],r7
80008e5c:	50 80       	stdsp	sp[0x20],r0
80008e5e:	0c 97       	mov	r7,r6
80008e60:	04 94       	mov	r4,r2
80008e62:	06 96       	mov	r6,r3
80008e64:	02 92       	mov	r2,r1
80008e66:	40 93       	lddsp	r3,sp[0x24]
80008e68:	10 90       	mov	r0,r8
80008e6a:	40 41       	lddsp	r1,sp[0x10]
80008e6c:	a5 a5       	sbr	r5,0x4
80008e6e:	c0 a8       	rjmp	80008e82 <_vfprintf_r+0xd26>
80008e70:	50 a7       	stdsp	sp[0x28],r7
80008e72:	50 80       	stdsp	sp[0x20],r0
80008e74:	0c 97       	mov	r7,r6
80008e76:	04 94       	mov	r4,r2
80008e78:	06 96       	mov	r6,r3
80008e7a:	02 92       	mov	r2,r1
80008e7c:	40 93       	lddsp	r3,sp[0x24]
80008e7e:	10 90       	mov	r0,r8
80008e80:	40 41       	lddsp	r1,sp[0x10]
80008e82:	ed b5 00 05 	bld	r5,0x5
80008e86:	c5 d1       	brne	80008f40 <_vfprintf_r+0xde4>
80008e88:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008e8c:	40 3c       	lddsp	r12,sp[0xc]
80008e8e:	58 0c       	cp.w	r12,0
80008e90:	c2 60       	breq	80008edc <_vfprintf_r+0xd80>
80008e92:	10 36       	cp.w	r6,r8
80008e94:	c0 a4       	brge	80008ea8 <_vfprintf_r+0xd4c>
80008e96:	fa cb f9 44 	sub	r11,sp,-1724
80008e9a:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008e9e:	ec e8 fd 88 	ld.d	r8,r6[-632]
80008ea2:	fa e9 00 00 	st.d	sp[0],r8
80008ea6:	c1 88       	rjmp	80008ed6 <_vfprintf_r+0xd7a>
80008ea8:	fa c8 f9 50 	sub	r8,sp,-1712
80008eac:	1a d8       	st.w	--sp,r8
80008eae:	fa c8 fa b8 	sub	r8,sp,-1352
80008eb2:	04 9a       	mov	r10,r2
80008eb4:	1a d8       	st.w	--sp,r8
80008eb6:	0c 9b       	mov	r11,r6
80008eb8:	fa c8 fb b4 	sub	r8,sp,-1100
80008ebc:	08 9c       	mov	r12,r4
80008ebe:	1a d8       	st.w	--sp,r8
80008ec0:	fa c8 f9 40 	sub	r8,sp,-1728
80008ec4:	fa c9 ff b4 	sub	r9,sp,-76
80008ec8:	fe b0 f7 b2 	rcall	80007e2c <get_arg>
80008ecc:	2f dd       	sub	sp,-12
80008ece:	f8 ea 00 00 	ld.d	r10,r12[0]
80008ed2:	fa eb 00 00 	st.d	sp[0],r10
80008ed6:	30 08       	mov	r8,0
80008ed8:	e0 8f 03 de 	bral	80009694 <_vfprintf_r+0x1538>
80008edc:	ee ca ff ff 	sub	r10,r7,-1
80008ee0:	10 37       	cp.w	r7,r8
80008ee2:	c0 b4       	brge	80008ef8 <_vfprintf_r+0xd9c>
80008ee4:	fa c9 f9 44 	sub	r9,sp,-1724
80008ee8:	14 97       	mov	r7,r10
80008eea:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008eee:	ec ea fd 88 	ld.d	r10,r6[-632]
80008ef2:	fa eb 00 00 	st.d	sp[0],r10
80008ef6:	c1 88       	rjmp	80008f26 <_vfprintf_r+0xdca>
80008ef8:	41 09       	lddsp	r9,sp[0x40]
80008efa:	59 f8       	cp.w	r8,31
80008efc:	e0 89 00 18 	brgt	80008f2c <_vfprintf_r+0xdd0>
80008f00:	f2 e6 00 00 	ld.d	r6,r9[0]
80008f04:	f2 cb ff f8 	sub	r11,r9,-8
80008f08:	fa e7 00 00 	st.d	sp[0],r6
80008f0c:	51 0b       	stdsp	sp[0x40],r11
80008f0e:	fa c6 f9 44 	sub	r6,sp,-1724
80008f12:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008f16:	fa e6 00 00 	ld.d	r6,sp[0]
80008f1a:	f2 e7 fd 88 	st.d	r9[-632],r6
80008f1e:	2f f8       	sub	r8,-1
80008f20:	14 97       	mov	r7,r10
80008f22:	fb 48 06 b4 	st.w	sp[1716],r8
80008f26:	40 38       	lddsp	r8,sp[0xc]
80008f28:	e0 8f 03 b6 	bral	80009694 <_vfprintf_r+0x1538>
80008f2c:	f2 e6 00 00 	ld.d	r6,r9[0]
80008f30:	40 38       	lddsp	r8,sp[0xc]
80008f32:	fa e7 00 00 	st.d	sp[0],r6
80008f36:	2f 89       	sub	r9,-8
80008f38:	14 97       	mov	r7,r10
80008f3a:	51 09       	stdsp	sp[0x40],r9
80008f3c:	e0 8f 03 ac 	bral	80009694 <_vfprintf_r+0x1538>
80008f40:	ed b5 00 04 	bld	r5,0x4
80008f44:	c1 61       	brne	80008f70 <_vfprintf_r+0xe14>
80008f46:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008f4a:	40 3e       	lddsp	lr,sp[0xc]
80008f4c:	58 0e       	cp.w	lr,0
80008f4e:	c0 80       	breq	80008f5e <_vfprintf_r+0xe02>
80008f50:	10 36       	cp.w	r6,r8
80008f52:	c6 74       	brge	80009020 <_vfprintf_r+0xec4>
80008f54:	fa cc f9 44 	sub	r12,sp,-1724
80008f58:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008f5c:	c8 08       	rjmp	8000905c <_vfprintf_r+0xf00>
80008f5e:	ee ca ff ff 	sub	r10,r7,-1
80008f62:	10 37       	cp.w	r7,r8
80008f64:	c7 f4       	brge	80009062 <_vfprintf_r+0xf06>
80008f66:	fa cb f9 44 	sub	r11,sp,-1724
80008f6a:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008f6e:	c7 68       	rjmp	8000905a <_vfprintf_r+0xefe>
80008f70:	ed b5 00 06 	bld	r5,0x6
80008f74:	c4 a1       	brne	80009008 <_vfprintf_r+0xeac>
80008f76:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008f7a:	40 3c       	lddsp	r12,sp[0xc]
80008f7c:	58 0c       	cp.w	r12,0
80008f7e:	c1 d0       	breq	80008fb8 <_vfprintf_r+0xe5c>
80008f80:	10 36       	cp.w	r6,r8
80008f82:	c0 64       	brge	80008f8e <_vfprintf_r+0xe32>
80008f84:	fa cb f9 44 	sub	r11,sp,-1724
80008f88:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008f8c:	c1 f8       	rjmp	80008fca <_vfprintf_r+0xe6e>
80008f8e:	fa c8 f9 50 	sub	r8,sp,-1712
80008f92:	1a d8       	st.w	--sp,r8
80008f94:	fa c8 fa b8 	sub	r8,sp,-1352
80008f98:	1a d8       	st.w	--sp,r8
80008f9a:	fa c8 fb b4 	sub	r8,sp,-1100
80008f9e:	1a d8       	st.w	--sp,r8
80008fa0:	fa c8 f9 40 	sub	r8,sp,-1728
80008fa4:	fa c9 ff b4 	sub	r9,sp,-76
80008fa8:	04 9a       	mov	r10,r2
80008faa:	0c 9b       	mov	r11,r6
80008fac:	08 9c       	mov	r12,r4
80008fae:	fe b0 f7 3f 	rcall	80007e2c <get_arg>
80008fb2:	2f dd       	sub	sp,-12
80008fb4:	98 18       	ld.sh	r8,r12[0x2]
80008fb6:	c2 68       	rjmp	80009002 <_vfprintf_r+0xea6>
80008fb8:	ee ca ff ff 	sub	r10,r7,-1
80008fbc:	10 37       	cp.w	r7,r8
80008fbe:	c0 94       	brge	80008fd0 <_vfprintf_r+0xe74>
80008fc0:	fa c9 f9 44 	sub	r9,sp,-1724
80008fc4:	14 97       	mov	r7,r10
80008fc6:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008fca:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80008fce:	c1 a8       	rjmp	80009002 <_vfprintf_r+0xea6>
80008fd0:	41 09       	lddsp	r9,sp[0x40]
80008fd2:	59 f8       	cp.w	r8,31
80008fd4:	e0 89 00 13 	brgt	80008ffa <_vfprintf_r+0xe9e>
80008fd8:	f2 cb ff fc 	sub	r11,r9,-4
80008fdc:	51 0b       	stdsp	sp[0x40],r11
80008fde:	72 09       	ld.w	r9,r9[0x0]
80008fe0:	fa c6 f9 44 	sub	r6,sp,-1724
80008fe4:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80008fe8:	2f f8       	sub	r8,-1
80008fea:	f7 49 fd 88 	st.w	r11[-632],r9
80008fee:	fb 48 06 b4 	st.w	sp[1716],r8
80008ff2:	14 97       	mov	r7,r10
80008ff4:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80008ff8:	c0 58       	rjmp	80009002 <_vfprintf_r+0xea6>
80008ffa:	92 18       	ld.sh	r8,r9[0x2]
80008ffc:	14 97       	mov	r7,r10
80008ffe:	2f c9       	sub	r9,-4
80009000:	51 09       	stdsp	sp[0x40],r9
80009002:	5c 78       	castu.h	r8
80009004:	50 18       	stdsp	sp[0x4],r8
80009006:	c4 68       	rjmp	80009092 <_vfprintf_r+0xf36>
80009008:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000900c:	40 3c       	lddsp	r12,sp[0xc]
8000900e:	58 0c       	cp.w	r12,0
80009010:	c1 d0       	breq	8000904a <_vfprintf_r+0xeee>
80009012:	10 36       	cp.w	r6,r8
80009014:	c0 64       	brge	80009020 <_vfprintf_r+0xec4>
80009016:	fa cb f9 44 	sub	r11,sp,-1724
8000901a:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000901e:	c1 f8       	rjmp	8000905c <_vfprintf_r+0xf00>
80009020:	fa c8 f9 50 	sub	r8,sp,-1712
80009024:	1a d8       	st.w	--sp,r8
80009026:	fa c8 fa b8 	sub	r8,sp,-1352
8000902a:	0c 9b       	mov	r11,r6
8000902c:	1a d8       	st.w	--sp,r8
8000902e:	fa c8 fb b4 	sub	r8,sp,-1100
80009032:	04 9a       	mov	r10,r2
80009034:	1a d8       	st.w	--sp,r8
80009036:	08 9c       	mov	r12,r4
80009038:	fa c8 f9 40 	sub	r8,sp,-1728
8000903c:	fa c9 ff b4 	sub	r9,sp,-76
80009040:	fe b0 f6 f6 	rcall	80007e2c <get_arg>
80009044:	2f dd       	sub	sp,-12
80009046:	78 0b       	ld.w	r11,r12[0x0]
80009048:	c2 48       	rjmp	80009090 <_vfprintf_r+0xf34>
8000904a:	ee ca ff ff 	sub	r10,r7,-1
8000904e:	10 37       	cp.w	r7,r8
80009050:	c0 94       	brge	80009062 <_vfprintf_r+0xf06>
80009052:	fa c9 f9 44 	sub	r9,sp,-1724
80009056:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000905a:	14 97       	mov	r7,r10
8000905c:	ec fb fd 88 	ld.w	r11,r6[-632]
80009060:	c1 88       	rjmp	80009090 <_vfprintf_r+0xf34>
80009062:	41 09       	lddsp	r9,sp[0x40]
80009064:	59 f8       	cp.w	r8,31
80009066:	e0 89 00 11 	brgt	80009088 <_vfprintf_r+0xf2c>
8000906a:	f2 cb ff fc 	sub	r11,r9,-4
8000906e:	51 0b       	stdsp	sp[0x40],r11
80009070:	fa c6 f9 44 	sub	r6,sp,-1724
80009074:	72 0b       	ld.w	r11,r9[0x0]
80009076:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000907a:	f3 4b fd 88 	st.w	r9[-632],r11
8000907e:	2f f8       	sub	r8,-1
80009080:	14 97       	mov	r7,r10
80009082:	fb 48 06 b4 	st.w	sp[1716],r8
80009086:	c0 58       	rjmp	80009090 <_vfprintf_r+0xf34>
80009088:	72 0b       	ld.w	r11,r9[0x0]
8000908a:	14 97       	mov	r7,r10
8000908c:	2f c9       	sub	r9,-4
8000908e:	51 09       	stdsp	sp[0x40],r9
80009090:	50 1b       	stdsp	sp[0x4],r11
80009092:	30 0e       	mov	lr,0
80009094:	50 0e       	stdsp	sp[0x0],lr
80009096:	1c 98       	mov	r8,lr
80009098:	e0 8f 02 fe 	bral	80009694 <_vfprintf_r+0x1538>
8000909c:	50 a7       	stdsp	sp[0x28],r7
8000909e:	50 80       	stdsp	sp[0x20],r0
800090a0:	0c 97       	mov	r7,r6
800090a2:	04 94       	mov	r4,r2
800090a4:	06 96       	mov	r6,r3
800090a6:	02 92       	mov	r2,r1
800090a8:	40 93       	lddsp	r3,sp[0x24]
800090aa:	40 41       	lddsp	r1,sp[0x10]
800090ac:	0e 99       	mov	r9,r7
800090ae:	fa f8 06 b4 	ld.w	r8,sp[1716]
800090b2:	40 3c       	lddsp	r12,sp[0xc]
800090b4:	58 0c       	cp.w	r12,0
800090b6:	c1 d0       	breq	800090f0 <_vfprintf_r+0xf94>
800090b8:	10 36       	cp.w	r6,r8
800090ba:	c0 64       	brge	800090c6 <_vfprintf_r+0xf6a>
800090bc:	fa cb f9 44 	sub	r11,sp,-1724
800090c0:	f6 06 00 36 	add	r6,r11,r6<<0x3
800090c4:	c1 d8       	rjmp	800090fe <_vfprintf_r+0xfa2>
800090c6:	fa c8 f9 50 	sub	r8,sp,-1712
800090ca:	1a d8       	st.w	--sp,r8
800090cc:	fa c8 fa b8 	sub	r8,sp,-1352
800090d0:	1a d8       	st.w	--sp,r8
800090d2:	fa c8 fb b4 	sub	r8,sp,-1100
800090d6:	1a d8       	st.w	--sp,r8
800090d8:	fa c9 ff b4 	sub	r9,sp,-76
800090dc:	fa c8 f9 40 	sub	r8,sp,-1728
800090e0:	04 9a       	mov	r10,r2
800090e2:	0c 9b       	mov	r11,r6
800090e4:	08 9c       	mov	r12,r4
800090e6:	fe b0 f6 a3 	rcall	80007e2c <get_arg>
800090ea:	2f dd       	sub	sp,-12
800090ec:	78 09       	ld.w	r9,r12[0x0]
800090ee:	c2 18       	rjmp	80009130 <_vfprintf_r+0xfd4>
800090f0:	2f f7       	sub	r7,-1
800090f2:	10 39       	cp.w	r9,r8
800090f4:	c0 84       	brge	80009104 <_vfprintf_r+0xfa8>
800090f6:	fa ca f9 44 	sub	r10,sp,-1724
800090fa:	f4 06 00 36 	add	r6,r10,r6<<0x3
800090fe:	ec f9 fd 88 	ld.w	r9,r6[-632]
80009102:	c1 78       	rjmp	80009130 <_vfprintf_r+0xfd4>
80009104:	41 09       	lddsp	r9,sp[0x40]
80009106:	59 f8       	cp.w	r8,31
80009108:	e0 89 00 10 	brgt	80009128 <_vfprintf_r+0xfcc>
8000910c:	f2 ca ff fc 	sub	r10,r9,-4
80009110:	51 0a       	stdsp	sp[0x40],r10
80009112:	fa c6 f9 44 	sub	r6,sp,-1724
80009116:	72 09       	ld.w	r9,r9[0x0]
80009118:	ec 08 00 3a 	add	r10,r6,r8<<0x3
8000911c:	f5 49 fd 88 	st.w	r10[-632],r9
80009120:	2f f8       	sub	r8,-1
80009122:	fb 48 06 b4 	st.w	sp[1716],r8
80009126:	c0 58       	rjmp	80009130 <_vfprintf_r+0xfd4>
80009128:	f2 c8 ff fc 	sub	r8,r9,-4
8000912c:	51 08       	stdsp	sp[0x40],r8
8000912e:	72 09       	ld.w	r9,r9[0x0]
80009130:	33 08       	mov	r8,48
80009132:	fb 68 06 b8 	st.b	sp[1720],r8
80009136:	37 88       	mov	r8,120
80009138:	30 0e       	mov	lr,0
8000913a:	fb 68 06 b9 	st.b	sp[1721],r8
8000913e:	fe cc b1 5e 	sub	r12,pc,-20130
80009142:	50 19       	stdsp	sp[0x4],r9
80009144:	a1 b5       	sbr	r5,0x1
80009146:	50 0e       	stdsp	sp[0x0],lr
80009148:	50 dc       	stdsp	sp[0x34],r12
8000914a:	30 28       	mov	r8,2
8000914c:	37 80       	mov	r0,120
8000914e:	e0 8f 02 a3 	bral	80009694 <_vfprintf_r+0x1538>
80009152:	50 a7       	stdsp	sp[0x28],r7
80009154:	50 80       	stdsp	sp[0x20],r0
80009156:	10 90       	mov	r0,r8
80009158:	30 08       	mov	r8,0
8000915a:	fb 68 06 bb 	st.b	sp[1723],r8
8000915e:	0c 97       	mov	r7,r6
80009160:	04 94       	mov	r4,r2
80009162:	06 96       	mov	r6,r3
80009164:	02 92       	mov	r2,r1
80009166:	40 93       	lddsp	r3,sp[0x24]
80009168:	40 41       	lddsp	r1,sp[0x10]
8000916a:	0e 99       	mov	r9,r7
8000916c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009170:	40 3b       	lddsp	r11,sp[0xc]
80009172:	58 0b       	cp.w	r11,0
80009174:	c1 d0       	breq	800091ae <_vfprintf_r+0x1052>
80009176:	10 36       	cp.w	r6,r8
80009178:	c0 64       	brge	80009184 <_vfprintf_r+0x1028>
8000917a:	fa ca f9 44 	sub	r10,sp,-1724
8000917e:	f4 06 00 36 	add	r6,r10,r6<<0x3
80009182:	c1 d8       	rjmp	800091bc <_vfprintf_r+0x1060>
80009184:	fa c8 f9 50 	sub	r8,sp,-1712
80009188:	1a d8       	st.w	--sp,r8
8000918a:	fa c8 fa b8 	sub	r8,sp,-1352
8000918e:	1a d8       	st.w	--sp,r8
80009190:	fa c8 fb b4 	sub	r8,sp,-1100
80009194:	0c 9b       	mov	r11,r6
80009196:	1a d8       	st.w	--sp,r8
80009198:	04 9a       	mov	r10,r2
8000919a:	fa c8 f9 40 	sub	r8,sp,-1728
8000919e:	fa c9 ff b4 	sub	r9,sp,-76
800091a2:	08 9c       	mov	r12,r4
800091a4:	fe b0 f6 44 	rcall	80007e2c <get_arg>
800091a8:	2f dd       	sub	sp,-12
800091aa:	78 06       	ld.w	r6,r12[0x0]
800091ac:	c2 08       	rjmp	800091ec <_vfprintf_r+0x1090>
800091ae:	2f f7       	sub	r7,-1
800091b0:	10 39       	cp.w	r9,r8
800091b2:	c0 84       	brge	800091c2 <_vfprintf_r+0x1066>
800091b4:	fa c9 f9 44 	sub	r9,sp,-1724
800091b8:	f2 06 00 36 	add	r6,r9,r6<<0x3
800091bc:	ec f6 fd 88 	ld.w	r6,r6[-632]
800091c0:	c1 68       	rjmp	800091ec <_vfprintf_r+0x1090>
800091c2:	41 09       	lddsp	r9,sp[0x40]
800091c4:	59 f8       	cp.w	r8,31
800091c6:	e0 89 00 10 	brgt	800091e6 <_vfprintf_r+0x108a>
800091ca:	f2 ca ff fc 	sub	r10,r9,-4
800091ce:	51 0a       	stdsp	sp[0x40],r10
800091d0:	72 06       	ld.w	r6,r9[0x0]
800091d2:	fa ce f9 44 	sub	lr,sp,-1724
800091d6:	fc 08 00 39 	add	r9,lr,r8<<0x3
800091da:	f3 46 fd 88 	st.w	r9[-632],r6
800091de:	2f f8       	sub	r8,-1
800091e0:	fb 48 06 b4 	st.w	sp[1716],r8
800091e4:	c0 48       	rjmp	800091ec <_vfprintf_r+0x1090>
800091e6:	72 06       	ld.w	r6,r9[0x0]
800091e8:	2f c9       	sub	r9,-4
800091ea:	51 09       	stdsp	sp[0x40],r9
800091ec:	40 2c       	lddsp	r12,sp[0x8]
800091ee:	58 0c       	cp.w	r12,0
800091f0:	c1 05       	brlt	80009210 <_vfprintf_r+0x10b4>
800091f2:	18 9a       	mov	r10,r12
800091f4:	30 0b       	mov	r11,0
800091f6:	0c 9c       	mov	r12,r6
800091f8:	e0 a0 12 38 	rcall	8000b668 <memchr>
800091fc:	e0 80 02 df 	breq	800097ba <_vfprintf_r+0x165e>
80009200:	f8 06 01 02 	sub	r2,r12,r6
80009204:	40 2b       	lddsp	r11,sp[0x8]
80009206:	16 32       	cp.w	r2,r11
80009208:	e0 89 02 d9 	brgt	800097ba <_vfprintf_r+0x165e>
8000920c:	e0 8f 02 d4 	bral	800097b4 <_vfprintf_r+0x1658>
80009210:	30 0a       	mov	r10,0
80009212:	0c 9c       	mov	r12,r6
80009214:	50 2a       	stdsp	sp[0x8],r10
80009216:	e0 a0 15 99 	rcall	8000bd48 <strlen>
8000921a:	18 92       	mov	r2,r12
8000921c:	e0 8f 02 d2 	bral	800097c0 <_vfprintf_r+0x1664>
80009220:	50 a7       	stdsp	sp[0x28],r7
80009222:	50 80       	stdsp	sp[0x20],r0
80009224:	0c 97       	mov	r7,r6
80009226:	04 94       	mov	r4,r2
80009228:	06 96       	mov	r6,r3
8000922a:	02 92       	mov	r2,r1
8000922c:	40 93       	lddsp	r3,sp[0x24]
8000922e:	10 90       	mov	r0,r8
80009230:	40 41       	lddsp	r1,sp[0x10]
80009232:	a5 a5       	sbr	r5,0x4
80009234:	c0 a8       	rjmp	80009248 <_vfprintf_r+0x10ec>
80009236:	50 a7       	stdsp	sp[0x28],r7
80009238:	50 80       	stdsp	sp[0x20],r0
8000923a:	0c 97       	mov	r7,r6
8000923c:	04 94       	mov	r4,r2
8000923e:	06 96       	mov	r6,r3
80009240:	02 92       	mov	r2,r1
80009242:	40 93       	lddsp	r3,sp[0x24]
80009244:	10 90       	mov	r0,r8
80009246:	40 41       	lddsp	r1,sp[0x10]
80009248:	ed b5 00 05 	bld	r5,0x5
8000924c:	c5 61       	brne	800092f8 <_vfprintf_r+0x119c>
8000924e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009252:	40 39       	lddsp	r9,sp[0xc]
80009254:	58 09       	cp.w	r9,0
80009256:	c2 10       	breq	80009298 <_vfprintf_r+0x113c>
80009258:	10 36       	cp.w	r6,r8
8000925a:	c0 74       	brge	80009268 <_vfprintf_r+0x110c>
8000925c:	fa c8 f9 44 	sub	r8,sp,-1724
80009260:	f0 06 00 36 	add	r6,r8,r6<<0x3
80009264:	c2 38       	rjmp	800092aa <_vfprintf_r+0x114e>
80009266:	d7 03       	nop
80009268:	fa c8 f9 50 	sub	r8,sp,-1712
8000926c:	1a d8       	st.w	--sp,r8
8000926e:	fa c8 fa b8 	sub	r8,sp,-1352
80009272:	1a d8       	st.w	--sp,r8
80009274:	fa c8 fb b4 	sub	r8,sp,-1100
80009278:	1a d8       	st.w	--sp,r8
8000927a:	fa c8 f9 40 	sub	r8,sp,-1728
8000927e:	fa c9 ff b4 	sub	r9,sp,-76
80009282:	04 9a       	mov	r10,r2
80009284:	0c 9b       	mov	r11,r6
80009286:	08 9c       	mov	r12,r4
80009288:	fe b0 f5 d2 	rcall	80007e2c <get_arg>
8000928c:	2f dd       	sub	sp,-12
8000928e:	f8 e8 00 00 	ld.d	r8,r12[0]
80009292:	fa e9 00 00 	st.d	sp[0],r8
80009296:	c2 e8       	rjmp	800092f2 <_vfprintf_r+0x1196>
80009298:	ee ca ff ff 	sub	r10,r7,-1
8000929c:	10 37       	cp.w	r7,r8
8000929e:	c0 b4       	brge	800092b4 <_vfprintf_r+0x1158>
800092a0:	fa c8 f9 44 	sub	r8,sp,-1724
800092a4:	14 97       	mov	r7,r10
800092a6:	f0 06 00 36 	add	r6,r8,r6<<0x3
800092aa:	ec ea fd 88 	ld.d	r10,r6[-632]
800092ae:	fa eb 00 00 	st.d	sp[0],r10
800092b2:	c2 08       	rjmp	800092f2 <_vfprintf_r+0x1196>
800092b4:	41 09       	lddsp	r9,sp[0x40]
800092b6:	59 f8       	cp.w	r8,31
800092b8:	e0 89 00 16 	brgt	800092e4 <_vfprintf_r+0x1188>
800092bc:	f2 e6 00 00 	ld.d	r6,r9[0]
800092c0:	f2 cb ff f8 	sub	r11,r9,-8
800092c4:	fa e7 00 00 	st.d	sp[0],r6
800092c8:	51 0b       	stdsp	sp[0x40],r11
800092ca:	fa c6 f9 44 	sub	r6,sp,-1724
800092ce:	ec 08 00 39 	add	r9,r6,r8<<0x3
800092d2:	fa e6 00 00 	ld.d	r6,sp[0]
800092d6:	f2 e7 fd 88 	st.d	r9[-632],r6
800092da:	2f f8       	sub	r8,-1
800092dc:	14 97       	mov	r7,r10
800092de:	fb 48 06 b4 	st.w	sp[1716],r8
800092e2:	c0 88       	rjmp	800092f2 <_vfprintf_r+0x1196>
800092e4:	f2 e6 00 00 	ld.d	r6,r9[0]
800092e8:	2f 89       	sub	r9,-8
800092ea:	fa e7 00 00 	st.d	sp[0],r6
800092ee:	51 09       	stdsp	sp[0x40],r9
800092f0:	14 97       	mov	r7,r10
800092f2:	30 18       	mov	r8,1
800092f4:	e0 8f 01 d0 	bral	80009694 <_vfprintf_r+0x1538>
800092f8:	ed b5 00 04 	bld	r5,0x4
800092fc:	c1 61       	brne	80009328 <_vfprintf_r+0x11cc>
800092fe:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009302:	40 3e       	lddsp	lr,sp[0xc]
80009304:	58 0e       	cp.w	lr,0
80009306:	c0 80       	breq	80009316 <_vfprintf_r+0x11ba>
80009308:	10 36       	cp.w	r6,r8
8000930a:	c6 74       	brge	800093d8 <_vfprintf_r+0x127c>
8000930c:	fa cc f9 44 	sub	r12,sp,-1724
80009310:	f8 06 00 36 	add	r6,r12,r6<<0x3
80009314:	c8 08       	rjmp	80009414 <_vfprintf_r+0x12b8>
80009316:	ee ca ff ff 	sub	r10,r7,-1
8000931a:	10 37       	cp.w	r7,r8
8000931c:	c7 f4       	brge	8000941a <_vfprintf_r+0x12be>
8000931e:	fa cb f9 44 	sub	r11,sp,-1724
80009322:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009326:	c7 68       	rjmp	80009412 <_vfprintf_r+0x12b6>
80009328:	ed b5 00 06 	bld	r5,0x6
8000932c:	c4 a1       	brne	800093c0 <_vfprintf_r+0x1264>
8000932e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009332:	40 3c       	lddsp	r12,sp[0xc]
80009334:	58 0c       	cp.w	r12,0
80009336:	c1 d0       	breq	80009370 <_vfprintf_r+0x1214>
80009338:	10 36       	cp.w	r6,r8
8000933a:	c0 64       	brge	80009346 <_vfprintf_r+0x11ea>
8000933c:	fa cb f9 44 	sub	r11,sp,-1724
80009340:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009344:	c1 f8       	rjmp	80009382 <_vfprintf_r+0x1226>
80009346:	fa c8 f9 50 	sub	r8,sp,-1712
8000934a:	1a d8       	st.w	--sp,r8
8000934c:	fa c8 fa b8 	sub	r8,sp,-1352
80009350:	1a d8       	st.w	--sp,r8
80009352:	fa c8 fb b4 	sub	r8,sp,-1100
80009356:	1a d8       	st.w	--sp,r8
80009358:	fa c8 f9 40 	sub	r8,sp,-1728
8000935c:	fa c9 ff b4 	sub	r9,sp,-76
80009360:	04 9a       	mov	r10,r2
80009362:	0c 9b       	mov	r11,r6
80009364:	08 9c       	mov	r12,r4
80009366:	fe b0 f5 63 	rcall	80007e2c <get_arg>
8000936a:	2f dd       	sub	sp,-12
8000936c:	98 18       	ld.sh	r8,r12[0x2]
8000936e:	c2 68       	rjmp	800093ba <_vfprintf_r+0x125e>
80009370:	ee ca ff ff 	sub	r10,r7,-1
80009374:	10 37       	cp.w	r7,r8
80009376:	c0 94       	brge	80009388 <_vfprintf_r+0x122c>
80009378:	fa c9 f9 44 	sub	r9,sp,-1724
8000937c:	14 97       	mov	r7,r10
8000937e:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009382:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80009386:	c1 a8       	rjmp	800093ba <_vfprintf_r+0x125e>
80009388:	41 09       	lddsp	r9,sp[0x40]
8000938a:	59 f8       	cp.w	r8,31
8000938c:	e0 89 00 13 	brgt	800093b2 <_vfprintf_r+0x1256>
80009390:	f2 cb ff fc 	sub	r11,r9,-4
80009394:	51 0b       	stdsp	sp[0x40],r11
80009396:	72 09       	ld.w	r9,r9[0x0]
80009398:	fa c6 f9 44 	sub	r6,sp,-1724
8000939c:	ec 08 00 3b 	add	r11,r6,r8<<0x3
800093a0:	2f f8       	sub	r8,-1
800093a2:	f7 49 fd 88 	st.w	r11[-632],r9
800093a6:	fb 48 06 b4 	st.w	sp[1716],r8
800093aa:	14 97       	mov	r7,r10
800093ac:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
800093b0:	c0 58       	rjmp	800093ba <_vfprintf_r+0x125e>
800093b2:	92 18       	ld.sh	r8,r9[0x2]
800093b4:	14 97       	mov	r7,r10
800093b6:	2f c9       	sub	r9,-4
800093b8:	51 09       	stdsp	sp[0x40],r9
800093ba:	5c 78       	castu.h	r8
800093bc:	50 18       	stdsp	sp[0x4],r8
800093be:	c4 68       	rjmp	8000944a <_vfprintf_r+0x12ee>
800093c0:	fa f8 06 b4 	ld.w	r8,sp[1716]
800093c4:	40 3c       	lddsp	r12,sp[0xc]
800093c6:	58 0c       	cp.w	r12,0
800093c8:	c1 d0       	breq	80009402 <_vfprintf_r+0x12a6>
800093ca:	10 36       	cp.w	r6,r8
800093cc:	c0 64       	brge	800093d8 <_vfprintf_r+0x127c>
800093ce:	fa cb f9 44 	sub	r11,sp,-1724
800093d2:	f6 06 00 36 	add	r6,r11,r6<<0x3
800093d6:	c1 f8       	rjmp	80009414 <_vfprintf_r+0x12b8>
800093d8:	fa c8 f9 50 	sub	r8,sp,-1712
800093dc:	1a d8       	st.w	--sp,r8
800093de:	fa c8 fa b8 	sub	r8,sp,-1352
800093e2:	0c 9b       	mov	r11,r6
800093e4:	1a d8       	st.w	--sp,r8
800093e6:	fa c8 fb b4 	sub	r8,sp,-1100
800093ea:	04 9a       	mov	r10,r2
800093ec:	1a d8       	st.w	--sp,r8
800093ee:	08 9c       	mov	r12,r4
800093f0:	fa c8 f9 40 	sub	r8,sp,-1728
800093f4:	fa c9 ff b4 	sub	r9,sp,-76
800093f8:	fe b0 f5 1a 	rcall	80007e2c <get_arg>
800093fc:	2f dd       	sub	sp,-12
800093fe:	78 0b       	ld.w	r11,r12[0x0]
80009400:	c2 48       	rjmp	80009448 <_vfprintf_r+0x12ec>
80009402:	ee ca ff ff 	sub	r10,r7,-1
80009406:	10 37       	cp.w	r7,r8
80009408:	c0 94       	brge	8000941a <_vfprintf_r+0x12be>
8000940a:	fa c9 f9 44 	sub	r9,sp,-1724
8000940e:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009412:	14 97       	mov	r7,r10
80009414:	ec fb fd 88 	ld.w	r11,r6[-632]
80009418:	c1 88       	rjmp	80009448 <_vfprintf_r+0x12ec>
8000941a:	41 09       	lddsp	r9,sp[0x40]
8000941c:	59 f8       	cp.w	r8,31
8000941e:	e0 89 00 11 	brgt	80009440 <_vfprintf_r+0x12e4>
80009422:	f2 cb ff fc 	sub	r11,r9,-4
80009426:	51 0b       	stdsp	sp[0x40],r11
80009428:	fa c6 f9 44 	sub	r6,sp,-1724
8000942c:	72 0b       	ld.w	r11,r9[0x0]
8000942e:	ec 08 00 39 	add	r9,r6,r8<<0x3
80009432:	f3 4b fd 88 	st.w	r9[-632],r11
80009436:	2f f8       	sub	r8,-1
80009438:	14 97       	mov	r7,r10
8000943a:	fb 48 06 b4 	st.w	sp[1716],r8
8000943e:	c0 58       	rjmp	80009448 <_vfprintf_r+0x12ec>
80009440:	72 0b       	ld.w	r11,r9[0x0]
80009442:	14 97       	mov	r7,r10
80009444:	2f c9       	sub	r9,-4
80009446:	51 09       	stdsp	sp[0x40],r9
80009448:	50 1b       	stdsp	sp[0x4],r11
8000944a:	30 0e       	mov	lr,0
8000944c:	30 18       	mov	r8,1
8000944e:	50 0e       	stdsp	sp[0x0],lr
80009450:	c2 29       	rjmp	80009694 <_vfprintf_r+0x1538>
80009452:	50 a7       	stdsp	sp[0x28],r7
80009454:	50 80       	stdsp	sp[0x20],r0
80009456:	0c 97       	mov	r7,r6
80009458:	04 94       	mov	r4,r2
8000945a:	06 96       	mov	r6,r3
8000945c:	02 92       	mov	r2,r1
8000945e:	fe cc b4 7e 	sub	r12,pc,-19330
80009462:	40 93       	lddsp	r3,sp[0x24]
80009464:	10 90       	mov	r0,r8
80009466:	40 41       	lddsp	r1,sp[0x10]
80009468:	50 dc       	stdsp	sp[0x34],r12
8000946a:	ed b5 00 05 	bld	r5,0x5
8000946e:	c5 51       	brne	80009518 <_vfprintf_r+0x13bc>
80009470:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009474:	40 3b       	lddsp	r11,sp[0xc]
80009476:	58 0b       	cp.w	r11,0
80009478:	c2 20       	breq	800094bc <_vfprintf_r+0x1360>
8000947a:	10 36       	cp.w	r6,r8
8000947c:	c0 a4       	brge	80009490 <_vfprintf_r+0x1334>
8000947e:	fa ca f9 44 	sub	r10,sp,-1724
80009482:	f4 06 00 36 	add	r6,r10,r6<<0x3
80009486:	ec e8 fd 88 	ld.d	r8,r6[-632]
8000948a:	fa e9 00 00 	st.d	sp[0],r8
8000948e:	cf 28       	rjmp	80009672 <_vfprintf_r+0x1516>
80009490:	fa c8 f9 50 	sub	r8,sp,-1712
80009494:	1a d8       	st.w	--sp,r8
80009496:	fa c8 fa b8 	sub	r8,sp,-1352
8000949a:	04 9a       	mov	r10,r2
8000949c:	1a d8       	st.w	--sp,r8
8000949e:	0c 9b       	mov	r11,r6
800094a0:	fa c8 fb b4 	sub	r8,sp,-1100
800094a4:	08 9c       	mov	r12,r4
800094a6:	1a d8       	st.w	--sp,r8
800094a8:	fa c8 f9 40 	sub	r8,sp,-1728
800094ac:	fa c9 ff b4 	sub	r9,sp,-76
800094b0:	fe b0 f4 be 	rcall	80007e2c <get_arg>
800094b4:	2f dd       	sub	sp,-12
800094b6:	f8 ea 00 00 	ld.d	r10,r12[0]
800094ba:	c0 c8       	rjmp	800094d2 <_vfprintf_r+0x1376>
800094bc:	ee ca ff ff 	sub	r10,r7,-1
800094c0:	10 37       	cp.w	r7,r8
800094c2:	c0 b4       	brge	800094d8 <_vfprintf_r+0x137c>
800094c4:	fa c9 f9 44 	sub	r9,sp,-1724
800094c8:	14 97       	mov	r7,r10
800094ca:	f2 06 00 36 	add	r6,r9,r6<<0x3
800094ce:	ec ea fd 88 	ld.d	r10,r6[-632]
800094d2:	fa eb 00 00 	st.d	sp[0],r10
800094d6:	cc e8       	rjmp	80009672 <_vfprintf_r+0x1516>
800094d8:	41 09       	lddsp	r9,sp[0x40]
800094da:	59 f8       	cp.w	r8,31
800094dc:	e0 89 00 16 	brgt	80009508 <_vfprintf_r+0x13ac>
800094e0:	f2 e6 00 00 	ld.d	r6,r9[0]
800094e4:	f2 cb ff f8 	sub	r11,r9,-8
800094e8:	fa e7 00 00 	st.d	sp[0],r6
800094ec:	51 0b       	stdsp	sp[0x40],r11
800094ee:	fa c6 f9 44 	sub	r6,sp,-1724
800094f2:	ec 08 00 39 	add	r9,r6,r8<<0x3
800094f6:	fa e6 00 00 	ld.d	r6,sp[0]
800094fa:	f2 e7 fd 88 	st.d	r9[-632],r6
800094fe:	2f f8       	sub	r8,-1
80009500:	14 97       	mov	r7,r10
80009502:	fb 48 06 b4 	st.w	sp[1716],r8
80009506:	cb 68       	rjmp	80009672 <_vfprintf_r+0x1516>
80009508:	f2 e6 00 00 	ld.d	r6,r9[0]
8000950c:	2f 89       	sub	r9,-8
8000950e:	fa e7 00 00 	st.d	sp[0],r6
80009512:	51 09       	stdsp	sp[0x40],r9
80009514:	14 97       	mov	r7,r10
80009516:	ca e8       	rjmp	80009672 <_vfprintf_r+0x1516>
80009518:	ed b5 00 04 	bld	r5,0x4
8000951c:	c1 71       	brne	8000954a <_vfprintf_r+0x13ee>
8000951e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009522:	40 3e       	lddsp	lr,sp[0xc]
80009524:	58 0e       	cp.w	lr,0
80009526:	c0 80       	breq	80009536 <_vfprintf_r+0x13da>
80009528:	10 36       	cp.w	r6,r8
8000952a:	c6 94       	brge	800095fc <_vfprintf_r+0x14a0>
8000952c:	fa cc f9 44 	sub	r12,sp,-1724
80009530:	f8 06 00 36 	add	r6,r12,r6<<0x3
80009534:	c8 28       	rjmp	80009638 <_vfprintf_r+0x14dc>
80009536:	ee ca ff ff 	sub	r10,r7,-1
8000953a:	10 37       	cp.w	r7,r8
8000953c:	e0 84 00 81 	brge	8000963e <_vfprintf_r+0x14e2>
80009540:	fa cb f9 44 	sub	r11,sp,-1724
80009544:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009548:	c7 78       	rjmp	80009636 <_vfprintf_r+0x14da>
8000954a:	ed b5 00 06 	bld	r5,0x6
8000954e:	c4 b1       	brne	800095e4 <_vfprintf_r+0x1488>
80009550:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009554:	40 3c       	lddsp	r12,sp[0xc]
80009556:	58 0c       	cp.w	r12,0
80009558:	c1 d0       	breq	80009592 <_vfprintf_r+0x1436>
8000955a:	10 36       	cp.w	r6,r8
8000955c:	c0 64       	brge	80009568 <_vfprintf_r+0x140c>
8000955e:	fa cb f9 44 	sub	r11,sp,-1724
80009562:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009566:	c1 f8       	rjmp	800095a4 <_vfprintf_r+0x1448>
80009568:	fa c8 f9 50 	sub	r8,sp,-1712
8000956c:	1a d8       	st.w	--sp,r8
8000956e:	fa c8 fa b8 	sub	r8,sp,-1352
80009572:	1a d8       	st.w	--sp,r8
80009574:	fa c8 fb b4 	sub	r8,sp,-1100
80009578:	1a d8       	st.w	--sp,r8
8000957a:	fa c8 f9 40 	sub	r8,sp,-1728
8000957e:	fa c9 ff b4 	sub	r9,sp,-76
80009582:	04 9a       	mov	r10,r2
80009584:	0c 9b       	mov	r11,r6
80009586:	08 9c       	mov	r12,r4
80009588:	fe b0 f4 52 	rcall	80007e2c <get_arg>
8000958c:	2f dd       	sub	sp,-12
8000958e:	98 18       	ld.sh	r8,r12[0x2]
80009590:	c2 78       	rjmp	800095de <_vfprintf_r+0x1482>
80009592:	ee ca ff ff 	sub	r10,r7,-1
80009596:	10 37       	cp.w	r7,r8
80009598:	c0 a4       	brge	800095ac <_vfprintf_r+0x1450>
8000959a:	fa c9 f9 44 	sub	r9,sp,-1724
8000959e:	14 97       	mov	r7,r10
800095a0:	f2 06 00 36 	add	r6,r9,r6<<0x3
800095a4:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
800095a8:	c1 b8       	rjmp	800095de <_vfprintf_r+0x1482>
800095aa:	d7 03       	nop
800095ac:	41 09       	lddsp	r9,sp[0x40]
800095ae:	59 f8       	cp.w	r8,31
800095b0:	e0 89 00 13 	brgt	800095d6 <_vfprintf_r+0x147a>
800095b4:	f2 cb ff fc 	sub	r11,r9,-4
800095b8:	51 0b       	stdsp	sp[0x40],r11
800095ba:	72 09       	ld.w	r9,r9[0x0]
800095bc:	fa c6 f9 44 	sub	r6,sp,-1724
800095c0:	ec 08 00 3b 	add	r11,r6,r8<<0x3
800095c4:	2f f8       	sub	r8,-1
800095c6:	f7 49 fd 88 	st.w	r11[-632],r9
800095ca:	fb 48 06 b4 	st.w	sp[1716],r8
800095ce:	14 97       	mov	r7,r10
800095d0:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
800095d4:	c0 58       	rjmp	800095de <_vfprintf_r+0x1482>
800095d6:	92 18       	ld.sh	r8,r9[0x2]
800095d8:	14 97       	mov	r7,r10
800095da:	2f c9       	sub	r9,-4
800095dc:	51 09       	stdsp	sp[0x40],r9
800095de:	5c 78       	castu.h	r8
800095e0:	50 18       	stdsp	sp[0x4],r8
800095e2:	c4 68       	rjmp	8000966e <_vfprintf_r+0x1512>
800095e4:	fa f8 06 b4 	ld.w	r8,sp[1716]
800095e8:	40 3c       	lddsp	r12,sp[0xc]
800095ea:	58 0c       	cp.w	r12,0
800095ec:	c1 d0       	breq	80009626 <_vfprintf_r+0x14ca>
800095ee:	10 36       	cp.w	r6,r8
800095f0:	c0 64       	brge	800095fc <_vfprintf_r+0x14a0>
800095f2:	fa cb f9 44 	sub	r11,sp,-1724
800095f6:	f6 06 00 36 	add	r6,r11,r6<<0x3
800095fa:	c1 f8       	rjmp	80009638 <_vfprintf_r+0x14dc>
800095fc:	fa c8 f9 50 	sub	r8,sp,-1712
80009600:	1a d8       	st.w	--sp,r8
80009602:	fa c8 fa b8 	sub	r8,sp,-1352
80009606:	0c 9b       	mov	r11,r6
80009608:	1a d8       	st.w	--sp,r8
8000960a:	fa c8 fb b4 	sub	r8,sp,-1100
8000960e:	04 9a       	mov	r10,r2
80009610:	1a d8       	st.w	--sp,r8
80009612:	08 9c       	mov	r12,r4
80009614:	fa c8 f9 40 	sub	r8,sp,-1728
80009618:	fa c9 ff b4 	sub	r9,sp,-76
8000961c:	fe b0 f4 08 	rcall	80007e2c <get_arg>
80009620:	2f dd       	sub	sp,-12
80009622:	78 0b       	ld.w	r11,r12[0x0]
80009624:	c2 48       	rjmp	8000966c <_vfprintf_r+0x1510>
80009626:	ee ca ff ff 	sub	r10,r7,-1
8000962a:	10 37       	cp.w	r7,r8
8000962c:	c0 94       	brge	8000963e <_vfprintf_r+0x14e2>
8000962e:	fa c9 f9 44 	sub	r9,sp,-1724
80009632:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009636:	14 97       	mov	r7,r10
80009638:	ec fb fd 88 	ld.w	r11,r6[-632]
8000963c:	c1 88       	rjmp	8000966c <_vfprintf_r+0x1510>
8000963e:	41 09       	lddsp	r9,sp[0x40]
80009640:	59 f8       	cp.w	r8,31
80009642:	e0 89 00 11 	brgt	80009664 <_vfprintf_r+0x1508>
80009646:	f2 cb ff fc 	sub	r11,r9,-4
8000964a:	51 0b       	stdsp	sp[0x40],r11
8000964c:	fa c6 f9 44 	sub	r6,sp,-1724
80009650:	72 0b       	ld.w	r11,r9[0x0]
80009652:	ec 08 00 39 	add	r9,r6,r8<<0x3
80009656:	f3 4b fd 88 	st.w	r9[-632],r11
8000965a:	2f f8       	sub	r8,-1
8000965c:	14 97       	mov	r7,r10
8000965e:	fb 48 06 b4 	st.w	sp[1716],r8
80009662:	c0 58       	rjmp	8000966c <_vfprintf_r+0x1510>
80009664:	72 0b       	ld.w	r11,r9[0x0]
80009666:	14 97       	mov	r7,r10
80009668:	2f c9       	sub	r9,-4
8000966a:	51 09       	stdsp	sp[0x40],r9
8000966c:	50 1b       	stdsp	sp[0x4],r11
8000966e:	30 0e       	mov	lr,0
80009670:	50 0e       	stdsp	sp[0x0],lr
80009672:	40 08       	lddsp	r8,sp[0x0]
80009674:	40 1c       	lddsp	r12,sp[0x4]
80009676:	18 48       	or	r8,r12
80009678:	5f 19       	srne	r9
8000967a:	0a 98       	mov	r8,r5
8000967c:	eb e9 00 09 	and	r9,r5,r9
80009680:	a1 b8       	sbr	r8,0x1
80009682:	58 09       	cp.w	r9,0
80009684:	c0 70       	breq	80009692 <_vfprintf_r+0x1536>
80009686:	10 95       	mov	r5,r8
80009688:	fb 60 06 b9 	st.b	sp[1721],r0
8000968c:	33 08       	mov	r8,48
8000968e:	fb 68 06 b8 	st.b	sp[1720],r8
80009692:	30 28       	mov	r8,2
80009694:	30 09       	mov	r9,0
80009696:	fb 69 06 bb 	st.b	sp[1723],r9
8000969a:	0a 99       	mov	r9,r5
8000969c:	a7 d9       	cbr	r9,0x7
8000969e:	40 2b       	lddsp	r11,sp[0x8]
800096a0:	40 16       	lddsp	r6,sp[0x4]
800096a2:	58 0b       	cp.w	r11,0
800096a4:	5f 1a       	srne	r10
800096a6:	f2 05 17 40 	movge	r5,r9
800096aa:	fa c2 f9 78 	sub	r2,sp,-1672
800096ae:	40 09       	lddsp	r9,sp[0x0]
800096b0:	0c 49       	or	r9,r6
800096b2:	5f 19       	srne	r9
800096b4:	f5 e9 10 09 	or	r9,r10,r9
800096b8:	c5 c0       	breq	80009770 <_vfprintf_r+0x1614>
800096ba:	30 19       	mov	r9,1
800096bc:	f2 08 18 00 	cp.b	r8,r9
800096c0:	c0 60       	breq	800096cc <_vfprintf_r+0x1570>
800096c2:	30 29       	mov	r9,2
800096c4:	f2 08 18 00 	cp.b	r8,r9
800096c8:	c0 41       	brne	800096d0 <_vfprintf_r+0x1574>
800096ca:	c3 c8       	rjmp	80009742 <_vfprintf_r+0x15e6>
800096cc:	04 96       	mov	r6,r2
800096ce:	c3 08       	rjmp	8000972e <_vfprintf_r+0x15d2>
800096d0:	04 96       	mov	r6,r2
800096d2:	fa e8 00 00 	ld.d	r8,sp[0]
800096d6:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
800096da:	2d 0a       	sub	r10,-48
800096dc:	0c fa       	st.b	--r6,r10
800096de:	f0 0b 16 03 	lsr	r11,r8,0x3
800096e2:	f2 0c 16 03 	lsr	r12,r9,0x3
800096e6:	f7 e9 11 db 	or	r11,r11,r9<<0x1d
800096ea:	18 99       	mov	r9,r12
800096ec:	16 98       	mov	r8,r11
800096ee:	58 08       	cp.w	r8,0
800096f0:	5c 29       	cpc	r9
800096f2:	cf 21       	brne	800096d6 <_vfprintf_r+0x157a>
800096f4:	fa e9 00 00 	st.d	sp[0],r8
800096f8:	ed b5 00 00 	bld	r5,0x0
800096fc:	c4 51       	brne	80009786 <_vfprintf_r+0x162a>
800096fe:	33 09       	mov	r9,48
80009700:	f2 0a 18 00 	cp.b	r10,r9
80009704:	c4 10       	breq	80009786 <_vfprintf_r+0x162a>
80009706:	0c f9       	st.b	--r6,r9
80009708:	c3 f8       	rjmp	80009786 <_vfprintf_r+0x162a>
8000970a:	fa ea 00 00 	ld.d	r10,sp[0]
8000970e:	30 a8       	mov	r8,10
80009710:	30 09       	mov	r9,0
80009712:	e0 a0 1a 19 	rcall	8000cb44 <__avr32_umod64>
80009716:	30 a8       	mov	r8,10
80009718:	2d 0a       	sub	r10,-48
8000971a:	30 09       	mov	r9,0
8000971c:	ac 8a       	st.b	r6[0x0],r10
8000971e:	fa ea 00 00 	ld.d	r10,sp[0]
80009722:	e0 a0 18 df 	rcall	8000c8e0 <__avr32_udiv64>
80009726:	16 99       	mov	r9,r11
80009728:	14 98       	mov	r8,r10
8000972a:	fa e9 00 00 	st.d	sp[0],r8
8000972e:	20 16       	sub	r6,1
80009730:	fa ea 00 00 	ld.d	r10,sp[0]
80009734:	58 9a       	cp.w	r10,9
80009736:	5c 2b       	cpc	r11
80009738:	fe 9b ff e9 	brhi	8000970a <_vfprintf_r+0x15ae>
8000973c:	1b f8       	ld.ub	r8,sp[0x7]
8000973e:	2d 08       	sub	r8,-48
80009740:	c2 08       	rjmp	80009780 <_vfprintf_r+0x1624>
80009742:	04 96       	mov	r6,r2
80009744:	fa e8 00 00 	ld.d	r8,sp[0]
80009748:	f5 d8 c0 04 	bfextu	r10,r8,0x0,0x4
8000974c:	40 de       	lddsp	lr,sp[0x34]
8000974e:	fc 0a 07 0a 	ld.ub	r10,lr[r10]
80009752:	0c fa       	st.b	--r6,r10
80009754:	f2 0b 16 04 	lsr	r11,r9,0x4
80009758:	f0 0a 16 04 	lsr	r10,r8,0x4
8000975c:	f5 e9 11 ca 	or	r10,r10,r9<<0x1c
80009760:	16 99       	mov	r9,r11
80009762:	14 98       	mov	r8,r10
80009764:	58 08       	cp.w	r8,0
80009766:	5c 29       	cpc	r9
80009768:	cf 01       	brne	80009748 <_vfprintf_r+0x15ec>
8000976a:	fa e9 00 00 	st.d	sp[0],r8
8000976e:	c0 c8       	rjmp	80009786 <_vfprintf_r+0x162a>
80009770:	58 08       	cp.w	r8,0
80009772:	c0 91       	brne	80009784 <_vfprintf_r+0x1628>
80009774:	ed b5 00 00 	bld	r5,0x0
80009778:	c0 61       	brne	80009784 <_vfprintf_r+0x1628>
8000977a:	fa c6 f9 79 	sub	r6,sp,-1671
8000977e:	33 08       	mov	r8,48
80009780:	ac 88       	st.b	r6[0x0],r8
80009782:	c0 28       	rjmp	80009786 <_vfprintf_r+0x162a>
80009784:	04 96       	mov	r6,r2
80009786:	0c 12       	sub	r2,r6
80009788:	c1 c8       	rjmp	800097c0 <_vfprintf_r+0x1664>
8000978a:	50 a7       	stdsp	sp[0x28],r7
8000978c:	50 80       	stdsp	sp[0x20],r0
8000978e:	40 93       	lddsp	r3,sp[0x24]
80009790:	0c 97       	mov	r7,r6
80009792:	10 90       	mov	r0,r8
80009794:	04 94       	mov	r4,r2
80009796:	40 41       	lddsp	r1,sp[0x10]
80009798:	58 08       	cp.w	r8,0
8000979a:	e0 80 04 4f 	breq	8000a038 <_vfprintf_r+0x1edc>
8000979e:	fb 68 06 60 	st.b	sp[1632],r8
800097a2:	30 0c       	mov	r12,0
800097a4:	30 08       	mov	r8,0
800097a6:	30 12       	mov	r2,1
800097a8:	fb 68 06 bb 	st.b	sp[1723],r8
800097ac:	50 2c       	stdsp	sp[0x8],r12
800097ae:	fa c6 f9 a0 	sub	r6,sp,-1632
800097b2:	c0 78       	rjmp	800097c0 <_vfprintf_r+0x1664>
800097b4:	30 0b       	mov	r11,0
800097b6:	50 2b       	stdsp	sp[0x8],r11
800097b8:	c0 48       	rjmp	800097c0 <_vfprintf_r+0x1664>
800097ba:	40 22       	lddsp	r2,sp[0x8]
800097bc:	30 0a       	mov	r10,0
800097be:	50 2a       	stdsp	sp[0x8],r10
800097c0:	40 29       	lddsp	r9,sp[0x8]
800097c2:	e4 09 0c 49 	max	r9,r2,r9
800097c6:	fb 38 06 bb 	ld.ub	r8,sp[1723]
800097ca:	50 39       	stdsp	sp[0xc],r9
800097cc:	0a 9e       	mov	lr,r5
800097ce:	30 09       	mov	r9,0
800097d0:	e2 1e 00 02 	andl	lr,0x2,COH
800097d4:	f2 08 18 00 	cp.b	r8,r9
800097d8:	fb f8 10 03 	ld.wne	r8,sp[0xc]
800097dc:	f7 b8 01 ff 	subne	r8,-1
800097e0:	fb f8 1a 03 	st.wne	sp[0xc],r8
800097e4:	0a 9b       	mov	r11,r5
800097e6:	58 0e       	cp.w	lr,0
800097e8:	fb fc 10 03 	ld.wne	r12,sp[0xc]
800097ec:	f7 bc 01 fe 	subne	r12,-2
800097f0:	fb fc 1a 03 	st.wne	sp[0xc],r12
800097f4:	e2 1b 00 84 	andl	r11,0x84,COH
800097f8:	50 fe       	stdsp	sp[0x3c],lr
800097fa:	50 9b       	stdsp	sp[0x24],r11
800097fc:	c4 71       	brne	8000988a <_vfprintf_r+0x172e>
800097fe:	40 8a       	lddsp	r10,sp[0x20]
80009800:	40 39       	lddsp	r9,sp[0xc]
80009802:	12 1a       	sub	r10,r9
80009804:	50 4a       	stdsp	sp[0x10],r10
80009806:	58 0a       	cp.w	r10,0
80009808:	e0 89 00 20 	brgt	80009848 <_vfprintf_r+0x16ec>
8000980c:	c3 f8       	rjmp	8000988a <_vfprintf_r+0x172e>
8000980e:	2f 09       	sub	r9,-16
80009810:	2f f8       	sub	r8,-1
80009812:	fe ce b8 1a 	sub	lr,pc,-18406
80009816:	31 0c       	mov	r12,16
80009818:	fb 49 06 90 	st.w	sp[1680],r9
8000981c:	87 0e       	st.w	r3[0x0],lr
8000981e:	87 1c       	st.w	r3[0x4],r12
80009820:	fb 48 06 8c 	st.w	sp[1676],r8
80009824:	58 78       	cp.w	r8,7
80009826:	e0 89 00 04 	brgt	8000982e <_vfprintf_r+0x16d2>
8000982a:	2f 83       	sub	r3,-8
8000982c:	c0 b8       	rjmp	80009842 <_vfprintf_r+0x16e6>
8000982e:	fa ca f9 78 	sub	r10,sp,-1672
80009832:	02 9b       	mov	r11,r1
80009834:	08 9c       	mov	r12,r4
80009836:	fe b0 f4 85 	rcall	80008140 <__sprint_r>
8000983a:	e0 81 04 10 	brne	8000a05a <_vfprintf_r+0x1efe>
8000983e:	fa c3 f9 e0 	sub	r3,sp,-1568
80009842:	40 4b       	lddsp	r11,sp[0x10]
80009844:	21 0b       	sub	r11,16
80009846:	50 4b       	stdsp	sp[0x10],r11
80009848:	fa f9 06 90 	ld.w	r9,sp[1680]
8000984c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009850:	fe ca b8 58 	sub	r10,pc,-18344
80009854:	40 4e       	lddsp	lr,sp[0x10]
80009856:	59 0e       	cp.w	lr,16
80009858:	fe 99 ff db 	brgt	8000980e <_vfprintf_r+0x16b2>
8000985c:	1c 09       	add	r9,lr
8000985e:	2f f8       	sub	r8,-1
80009860:	87 0a       	st.w	r3[0x0],r10
80009862:	fb 49 06 90 	st.w	sp[1680],r9
80009866:	87 1e       	st.w	r3[0x4],lr
80009868:	fb 48 06 8c 	st.w	sp[1676],r8
8000986c:	58 78       	cp.w	r8,7
8000986e:	e0 89 00 04 	brgt	80009876 <_vfprintf_r+0x171a>
80009872:	2f 83       	sub	r3,-8
80009874:	c0 b8       	rjmp	8000988a <_vfprintf_r+0x172e>
80009876:	fa ca f9 78 	sub	r10,sp,-1672
8000987a:	02 9b       	mov	r11,r1
8000987c:	08 9c       	mov	r12,r4
8000987e:	fe b0 f4 61 	rcall	80008140 <__sprint_r>
80009882:	e0 81 03 ec 	brne	8000a05a <_vfprintf_r+0x1efe>
80009886:	fa c3 f9 e0 	sub	r3,sp,-1568
8000988a:	30 09       	mov	r9,0
8000988c:	fb 38 06 bb 	ld.ub	r8,sp[1723]
80009890:	f2 08 18 00 	cp.b	r8,r9
80009894:	c1 f0       	breq	800098d2 <_vfprintf_r+0x1776>
80009896:	fa f8 06 90 	ld.w	r8,sp[1680]
8000989a:	fa c9 f9 45 	sub	r9,sp,-1723
8000989e:	2f f8       	sub	r8,-1
800098a0:	87 09       	st.w	r3[0x0],r9
800098a2:	fb 48 06 90 	st.w	sp[1680],r8
800098a6:	30 19       	mov	r9,1
800098a8:	fa f8 06 8c 	ld.w	r8,sp[1676]
800098ac:	87 19       	st.w	r3[0x4],r9
800098ae:	2f f8       	sub	r8,-1
800098b0:	fb 48 06 8c 	st.w	sp[1676],r8
800098b4:	58 78       	cp.w	r8,7
800098b6:	e0 89 00 04 	brgt	800098be <_vfprintf_r+0x1762>
800098ba:	2f 83       	sub	r3,-8
800098bc:	c0 b8       	rjmp	800098d2 <_vfprintf_r+0x1776>
800098be:	fa ca f9 78 	sub	r10,sp,-1672
800098c2:	02 9b       	mov	r11,r1
800098c4:	08 9c       	mov	r12,r4
800098c6:	fe b0 f4 3d 	rcall	80008140 <__sprint_r>
800098ca:	e0 81 03 c8 	brne	8000a05a <_vfprintf_r+0x1efe>
800098ce:	fa c3 f9 e0 	sub	r3,sp,-1568
800098d2:	40 fc       	lddsp	r12,sp[0x3c]
800098d4:	58 0c       	cp.w	r12,0
800098d6:	c1 f0       	breq	80009914 <_vfprintf_r+0x17b8>
800098d8:	fa f8 06 90 	ld.w	r8,sp[1680]
800098dc:	fa c9 f9 48 	sub	r9,sp,-1720
800098e0:	2f e8       	sub	r8,-2
800098e2:	87 09       	st.w	r3[0x0],r9
800098e4:	fb 48 06 90 	st.w	sp[1680],r8
800098e8:	30 29       	mov	r9,2
800098ea:	fa f8 06 8c 	ld.w	r8,sp[1676]
800098ee:	87 19       	st.w	r3[0x4],r9
800098f0:	2f f8       	sub	r8,-1
800098f2:	fb 48 06 8c 	st.w	sp[1676],r8
800098f6:	58 78       	cp.w	r8,7
800098f8:	e0 89 00 04 	brgt	80009900 <_vfprintf_r+0x17a4>
800098fc:	2f 83       	sub	r3,-8
800098fe:	c0 b8       	rjmp	80009914 <_vfprintf_r+0x17b8>
80009900:	fa ca f9 78 	sub	r10,sp,-1672
80009904:	02 9b       	mov	r11,r1
80009906:	08 9c       	mov	r12,r4
80009908:	fe b0 f4 1c 	rcall	80008140 <__sprint_r>
8000990c:	e0 81 03 a7 	brne	8000a05a <_vfprintf_r+0x1efe>
80009910:	fa c3 f9 e0 	sub	r3,sp,-1568
80009914:	40 9b       	lddsp	r11,sp[0x24]
80009916:	e0 4b 00 80 	cp.w	r11,128
8000991a:	c4 71       	brne	800099a8 <_vfprintf_r+0x184c>
8000991c:	40 8a       	lddsp	r10,sp[0x20]
8000991e:	40 39       	lddsp	r9,sp[0xc]
80009920:	12 1a       	sub	r10,r9
80009922:	50 4a       	stdsp	sp[0x10],r10
80009924:	58 0a       	cp.w	r10,0
80009926:	e0 89 00 20 	brgt	80009966 <_vfprintf_r+0x180a>
8000992a:	c3 f8       	rjmp	800099a8 <_vfprintf_r+0x184c>
8000992c:	2f 09       	sub	r9,-16
8000992e:	2f f8       	sub	r8,-1
80009930:	fe ce b9 28 	sub	lr,pc,-18136
80009934:	31 0c       	mov	r12,16
80009936:	fb 49 06 90 	st.w	sp[1680],r9
8000993a:	87 0e       	st.w	r3[0x0],lr
8000993c:	87 1c       	st.w	r3[0x4],r12
8000993e:	fb 48 06 8c 	st.w	sp[1676],r8
80009942:	58 78       	cp.w	r8,7
80009944:	e0 89 00 04 	brgt	8000994c <_vfprintf_r+0x17f0>
80009948:	2f 83       	sub	r3,-8
8000994a:	c0 b8       	rjmp	80009960 <_vfprintf_r+0x1804>
8000994c:	fa ca f9 78 	sub	r10,sp,-1672
80009950:	02 9b       	mov	r11,r1
80009952:	08 9c       	mov	r12,r4
80009954:	fe b0 f3 f6 	rcall	80008140 <__sprint_r>
80009958:	e0 81 03 81 	brne	8000a05a <_vfprintf_r+0x1efe>
8000995c:	fa c3 f9 e0 	sub	r3,sp,-1568
80009960:	40 4b       	lddsp	r11,sp[0x10]
80009962:	21 0b       	sub	r11,16
80009964:	50 4b       	stdsp	sp[0x10],r11
80009966:	fa f9 06 90 	ld.w	r9,sp[1680]
8000996a:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000996e:	fe ca b9 66 	sub	r10,pc,-18074
80009972:	40 4e       	lddsp	lr,sp[0x10]
80009974:	59 0e       	cp.w	lr,16
80009976:	fe 99 ff db 	brgt	8000992c <_vfprintf_r+0x17d0>
8000997a:	1c 09       	add	r9,lr
8000997c:	2f f8       	sub	r8,-1
8000997e:	87 0a       	st.w	r3[0x0],r10
80009980:	fb 49 06 90 	st.w	sp[1680],r9
80009984:	87 1e       	st.w	r3[0x4],lr
80009986:	fb 48 06 8c 	st.w	sp[1676],r8
8000998a:	58 78       	cp.w	r8,7
8000998c:	e0 89 00 04 	brgt	80009994 <_vfprintf_r+0x1838>
80009990:	2f 83       	sub	r3,-8
80009992:	c0 b8       	rjmp	800099a8 <_vfprintf_r+0x184c>
80009994:	fa ca f9 78 	sub	r10,sp,-1672
80009998:	02 9b       	mov	r11,r1
8000999a:	08 9c       	mov	r12,r4
8000999c:	fe b0 f3 d2 	rcall	80008140 <__sprint_r>
800099a0:	e0 81 03 5d 	brne	8000a05a <_vfprintf_r+0x1efe>
800099a4:	fa c3 f9 e0 	sub	r3,sp,-1568
800099a8:	40 2c       	lddsp	r12,sp[0x8]
800099aa:	04 1c       	sub	r12,r2
800099ac:	50 2c       	stdsp	sp[0x8],r12
800099ae:	58 0c       	cp.w	r12,0
800099b0:	e0 89 00 20 	brgt	800099f0 <_vfprintf_r+0x1894>
800099b4:	c3 f8       	rjmp	80009a32 <_vfprintf_r+0x18d6>
800099b6:	2f 09       	sub	r9,-16
800099b8:	2f f8       	sub	r8,-1
800099ba:	fe cb b9 b2 	sub	r11,pc,-17998
800099be:	31 0a       	mov	r10,16
800099c0:	fb 49 06 90 	st.w	sp[1680],r9
800099c4:	87 0b       	st.w	r3[0x0],r11
800099c6:	87 1a       	st.w	r3[0x4],r10
800099c8:	fb 48 06 8c 	st.w	sp[1676],r8
800099cc:	58 78       	cp.w	r8,7
800099ce:	e0 89 00 04 	brgt	800099d6 <_vfprintf_r+0x187a>
800099d2:	2f 83       	sub	r3,-8
800099d4:	c0 b8       	rjmp	800099ea <_vfprintf_r+0x188e>
800099d6:	fa ca f9 78 	sub	r10,sp,-1672
800099da:	02 9b       	mov	r11,r1
800099dc:	08 9c       	mov	r12,r4
800099de:	fe b0 f3 b1 	rcall	80008140 <__sprint_r>
800099e2:	e0 81 03 3c 	brne	8000a05a <_vfprintf_r+0x1efe>
800099e6:	fa c3 f9 e0 	sub	r3,sp,-1568
800099ea:	40 29       	lddsp	r9,sp[0x8]
800099ec:	21 09       	sub	r9,16
800099ee:	50 29       	stdsp	sp[0x8],r9
800099f0:	fa f9 06 90 	ld.w	r9,sp[1680]
800099f4:	fa f8 06 8c 	ld.w	r8,sp[1676]
800099f8:	fe ca b9 f0 	sub	r10,pc,-17936
800099fc:	40 2e       	lddsp	lr,sp[0x8]
800099fe:	59 0e       	cp.w	lr,16
80009a00:	fe 99 ff db 	brgt	800099b6 <_vfprintf_r+0x185a>
80009a04:	1c 09       	add	r9,lr
80009a06:	2f f8       	sub	r8,-1
80009a08:	87 0a       	st.w	r3[0x0],r10
80009a0a:	fb 49 06 90 	st.w	sp[1680],r9
80009a0e:	87 1e       	st.w	r3[0x4],lr
80009a10:	fb 48 06 8c 	st.w	sp[1676],r8
80009a14:	58 78       	cp.w	r8,7
80009a16:	e0 89 00 04 	brgt	80009a1e <_vfprintf_r+0x18c2>
80009a1a:	2f 83       	sub	r3,-8
80009a1c:	c0 b8       	rjmp	80009a32 <_vfprintf_r+0x18d6>
80009a1e:	fa ca f9 78 	sub	r10,sp,-1672
80009a22:	02 9b       	mov	r11,r1
80009a24:	08 9c       	mov	r12,r4
80009a26:	fe b0 f3 8d 	rcall	80008140 <__sprint_r>
80009a2a:	e0 81 03 18 	brne	8000a05a <_vfprintf_r+0x1efe>
80009a2e:	fa c3 f9 e0 	sub	r3,sp,-1568
80009a32:	ed b5 00 08 	bld	r5,0x8
80009a36:	c0 b0       	breq	80009a4c <_vfprintf_r+0x18f0>
80009a38:	fa f8 06 90 	ld.w	r8,sp[1680]
80009a3c:	87 12       	st.w	r3[0x4],r2
80009a3e:	87 06       	st.w	r3[0x0],r6
80009a40:	f0 02 00 02 	add	r2,r8,r2
80009a44:	fb 42 06 90 	st.w	sp[1680],r2
80009a48:	e0 8f 01 d4 	bral	80009df0 <_vfprintf_r+0x1c94>
80009a4c:	e0 40 00 65 	cp.w	r0,101
80009a50:	e0 8a 01 d6 	brle	80009dfc <_vfprintf_r+0x1ca0>
80009a54:	30 08       	mov	r8,0
80009a56:	30 09       	mov	r9,0
80009a58:	40 5b       	lddsp	r11,sp[0x14]
80009a5a:	40 7a       	lddsp	r10,sp[0x1c]
80009a5c:	e0 a0 15 3b 	rcall	8000c4d2 <__avr32_f64_cmp_eq>
80009a60:	c7 90       	breq	80009b52 <_vfprintf_r+0x19f6>
80009a62:	fa f8 06 90 	ld.w	r8,sp[1680]
80009a66:	fe c9 ba 72 	sub	r9,pc,-17806
80009a6a:	2f f8       	sub	r8,-1
80009a6c:	87 09       	st.w	r3[0x0],r9
80009a6e:	fb 48 06 90 	st.w	sp[1680],r8
80009a72:	30 19       	mov	r9,1
80009a74:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009a78:	87 19       	st.w	r3[0x4],r9
80009a7a:	2f f8       	sub	r8,-1
80009a7c:	fb 48 06 8c 	st.w	sp[1676],r8
80009a80:	58 78       	cp.w	r8,7
80009a82:	e0 89 00 05 	brgt	80009a8c <_vfprintf_r+0x1930>
80009a86:	2f 83       	sub	r3,-8
80009a88:	c0 c8       	rjmp	80009aa0 <_vfprintf_r+0x1944>
80009a8a:	d7 03       	nop
80009a8c:	fa ca f9 78 	sub	r10,sp,-1672
80009a90:	02 9b       	mov	r11,r1
80009a92:	08 9c       	mov	r12,r4
80009a94:	fe b0 f3 56 	rcall	80008140 <__sprint_r>
80009a98:	e0 81 02 e1 	brne	8000a05a <_vfprintf_r+0x1efe>
80009a9c:	fa c3 f9 e0 	sub	r3,sp,-1568
80009aa0:	fa f8 06 ac 	ld.w	r8,sp[1708]
80009aa4:	40 6c       	lddsp	r12,sp[0x18]
80009aa6:	18 38       	cp.w	r8,r12
80009aa8:	c0 55       	brlt	80009ab2 <_vfprintf_r+0x1956>
80009aaa:	ed b5 00 00 	bld	r5,0x0
80009aae:	e0 81 02 6b 	brne	80009f84 <_vfprintf_r+0x1e28>
80009ab2:	fa f8 06 90 	ld.w	r8,sp[1680]
80009ab6:	2f f8       	sub	r8,-1
80009ab8:	40 cb       	lddsp	r11,sp[0x30]
80009aba:	fb 48 06 90 	st.w	sp[1680],r8
80009abe:	30 19       	mov	r9,1
80009ac0:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009ac4:	87 0b       	st.w	r3[0x0],r11
80009ac6:	2f f8       	sub	r8,-1
80009ac8:	87 19       	st.w	r3[0x4],r9
80009aca:	fb 48 06 8c 	st.w	sp[1676],r8
80009ace:	58 78       	cp.w	r8,7
80009ad0:	e0 89 00 04 	brgt	80009ad8 <_vfprintf_r+0x197c>
80009ad4:	2f 83       	sub	r3,-8
80009ad6:	c0 b8       	rjmp	80009aec <_vfprintf_r+0x1990>
80009ad8:	fa ca f9 78 	sub	r10,sp,-1672
80009adc:	02 9b       	mov	r11,r1
80009ade:	08 9c       	mov	r12,r4
80009ae0:	fe b0 f3 30 	rcall	80008140 <__sprint_r>
80009ae4:	e0 81 02 bb 	brne	8000a05a <_vfprintf_r+0x1efe>
80009ae8:	fa c3 f9 e0 	sub	r3,sp,-1568
80009aec:	40 66       	lddsp	r6,sp[0x18]
80009aee:	20 16       	sub	r6,1
80009af0:	58 06       	cp.w	r6,0
80009af2:	e0 89 00 1d 	brgt	80009b2c <_vfprintf_r+0x19d0>
80009af6:	e0 8f 02 47 	bral	80009f84 <_vfprintf_r+0x1e28>
80009afa:	2f 09       	sub	r9,-16
80009afc:	2f f8       	sub	r8,-1
80009afe:	fb 49 06 90 	st.w	sp[1680],r9
80009b02:	87 02       	st.w	r3[0x0],r2
80009b04:	87 10       	st.w	r3[0x4],r0
80009b06:	fb 48 06 8c 	st.w	sp[1676],r8
80009b0a:	58 78       	cp.w	r8,7
80009b0c:	e0 89 00 04 	brgt	80009b14 <_vfprintf_r+0x19b8>
80009b10:	2f 83       	sub	r3,-8
80009b12:	c0 b8       	rjmp	80009b28 <_vfprintf_r+0x19cc>
80009b14:	fa ca f9 78 	sub	r10,sp,-1672
80009b18:	02 9b       	mov	r11,r1
80009b1a:	08 9c       	mov	r12,r4
80009b1c:	fe b0 f3 12 	rcall	80008140 <__sprint_r>
80009b20:	e0 81 02 9d 	brne	8000a05a <_vfprintf_r+0x1efe>
80009b24:	fa c3 f9 e0 	sub	r3,sp,-1568
80009b28:	21 06       	sub	r6,16
80009b2a:	c0 48       	rjmp	80009b32 <_vfprintf_r+0x19d6>
80009b2c:	fe c2 bb 24 	sub	r2,pc,-17628
80009b30:	31 00       	mov	r0,16
80009b32:	fa f9 06 90 	ld.w	r9,sp[1680]
80009b36:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009b3a:	fe ca bb 32 	sub	r10,pc,-17614
80009b3e:	59 06       	cp.w	r6,16
80009b40:	fe 99 ff dd 	brgt	80009afa <_vfprintf_r+0x199e>
80009b44:	0c 09       	add	r9,r6
80009b46:	87 0a       	st.w	r3[0x0],r10
80009b48:	fb 49 06 90 	st.w	sp[1680],r9
80009b4c:	2f f8       	sub	r8,-1
80009b4e:	87 16       	st.w	r3[0x4],r6
80009b50:	c5 39       	rjmp	80009df6 <_vfprintf_r+0x1c9a>
80009b52:	fa fa 06 ac 	ld.w	r10,sp[1708]
80009b56:	58 0a       	cp.w	r10,0
80009b58:	e0 89 00 92 	brgt	80009c7c <_vfprintf_r+0x1b20>
80009b5c:	fa f8 06 90 	ld.w	r8,sp[1680]
80009b60:	fe c9 bb 6c 	sub	r9,pc,-17556
80009b64:	2f f8       	sub	r8,-1
80009b66:	87 09       	st.w	r3[0x0],r9
80009b68:	fb 48 06 90 	st.w	sp[1680],r8
80009b6c:	30 19       	mov	r9,1
80009b6e:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009b72:	87 19       	st.w	r3[0x4],r9
80009b74:	2f f8       	sub	r8,-1
80009b76:	fb 48 06 8c 	st.w	sp[1676],r8
80009b7a:	58 78       	cp.w	r8,7
80009b7c:	e0 89 00 04 	brgt	80009b84 <_vfprintf_r+0x1a28>
80009b80:	2f 83       	sub	r3,-8
80009b82:	c0 b8       	rjmp	80009b98 <_vfprintf_r+0x1a3c>
80009b84:	fa ca f9 78 	sub	r10,sp,-1672
80009b88:	02 9b       	mov	r11,r1
80009b8a:	08 9c       	mov	r12,r4
80009b8c:	fe b0 f2 da 	rcall	80008140 <__sprint_r>
80009b90:	e0 81 02 65 	brne	8000a05a <_vfprintf_r+0x1efe>
80009b94:	fa c3 f9 e0 	sub	r3,sp,-1568
80009b98:	fa f8 06 ac 	ld.w	r8,sp[1708]
80009b9c:	58 08       	cp.w	r8,0
80009b9e:	c0 81       	brne	80009bae <_vfprintf_r+0x1a52>
80009ba0:	40 6a       	lddsp	r10,sp[0x18]
80009ba2:	58 0a       	cp.w	r10,0
80009ba4:	c0 51       	brne	80009bae <_vfprintf_r+0x1a52>
80009ba6:	ed b5 00 00 	bld	r5,0x0
80009baa:	e0 81 01 ed 	brne	80009f84 <_vfprintf_r+0x1e28>
80009bae:	40 c9       	lddsp	r9,sp[0x30]
80009bb0:	fa f8 06 90 	ld.w	r8,sp[1680]
80009bb4:	2f f8       	sub	r8,-1
80009bb6:	87 09       	st.w	r3[0x0],r9
80009bb8:	fb 48 06 90 	st.w	sp[1680],r8
80009bbc:	30 19       	mov	r9,1
80009bbe:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009bc2:	87 19       	st.w	r3[0x4],r9
80009bc4:	2f f8       	sub	r8,-1
80009bc6:	fb 48 06 8c 	st.w	sp[1676],r8
80009bca:	58 78       	cp.w	r8,7
80009bcc:	e0 89 00 04 	brgt	80009bd4 <_vfprintf_r+0x1a78>
80009bd0:	2f 83       	sub	r3,-8
80009bd2:	c0 b8       	rjmp	80009be8 <_vfprintf_r+0x1a8c>
80009bd4:	fa ca f9 78 	sub	r10,sp,-1672
80009bd8:	02 9b       	mov	r11,r1
80009bda:	08 9c       	mov	r12,r4
80009bdc:	fe b0 f2 b2 	rcall	80008140 <__sprint_r>
80009be0:	e0 81 02 3d 	brne	8000a05a <_vfprintf_r+0x1efe>
80009be4:	fa c3 f9 e0 	sub	r3,sp,-1568
80009be8:	fa f2 06 ac 	ld.w	r2,sp[1708]
80009bec:	5c 32       	neg	r2
80009bee:	58 02       	cp.w	r2,0
80009bf0:	e0 89 00 1d 	brgt	80009c2a <_vfprintf_r+0x1ace>
80009bf4:	c3 d8       	rjmp	80009c6e <_vfprintf_r+0x1b12>
80009bf6:	2f 09       	sub	r9,-16
80009bf8:	2f f8       	sub	r8,-1
80009bfa:	31 0e       	mov	lr,16
80009bfc:	fb 49 06 90 	st.w	sp[1680],r9
80009c00:	87 00       	st.w	r3[0x0],r0
80009c02:	87 1e       	st.w	r3[0x4],lr
80009c04:	fb 48 06 8c 	st.w	sp[1676],r8
80009c08:	58 78       	cp.w	r8,7
80009c0a:	e0 89 00 04 	brgt	80009c12 <_vfprintf_r+0x1ab6>
80009c0e:	2f 83       	sub	r3,-8
80009c10:	c0 b8       	rjmp	80009c26 <_vfprintf_r+0x1aca>
80009c12:	fa ca f9 78 	sub	r10,sp,-1672
80009c16:	02 9b       	mov	r11,r1
80009c18:	08 9c       	mov	r12,r4
80009c1a:	fe b0 f2 93 	rcall	80008140 <__sprint_r>
80009c1e:	e0 81 02 1e 	brne	8000a05a <_vfprintf_r+0x1efe>
80009c22:	fa c3 f9 e0 	sub	r3,sp,-1568
80009c26:	21 02       	sub	r2,16
80009c28:	c0 38       	rjmp	80009c2e <_vfprintf_r+0x1ad2>
80009c2a:	fe c0 bc 22 	sub	r0,pc,-17374
80009c2e:	fa f9 06 90 	ld.w	r9,sp[1680]
80009c32:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009c36:	fe ca bc 2e 	sub	r10,pc,-17362
80009c3a:	59 02       	cp.w	r2,16
80009c3c:	fe 99 ff dd 	brgt	80009bf6 <_vfprintf_r+0x1a9a>
80009c40:	04 09       	add	r9,r2
80009c42:	2f f8       	sub	r8,-1
80009c44:	87 0a       	st.w	r3[0x0],r10
80009c46:	fb 49 06 90 	st.w	sp[1680],r9
80009c4a:	87 12       	st.w	r3[0x4],r2
80009c4c:	fb 48 06 8c 	st.w	sp[1676],r8
80009c50:	58 78       	cp.w	r8,7
80009c52:	e0 89 00 04 	brgt	80009c5a <_vfprintf_r+0x1afe>
80009c56:	2f 83       	sub	r3,-8
80009c58:	c0 b8       	rjmp	80009c6e <_vfprintf_r+0x1b12>
80009c5a:	fa ca f9 78 	sub	r10,sp,-1672
80009c5e:	02 9b       	mov	r11,r1
80009c60:	08 9c       	mov	r12,r4
80009c62:	fe b0 f2 6f 	rcall	80008140 <__sprint_r>
80009c66:	e0 81 01 fa 	brne	8000a05a <_vfprintf_r+0x1efe>
80009c6a:	fa c3 f9 e0 	sub	r3,sp,-1568
80009c6e:	40 6c       	lddsp	r12,sp[0x18]
80009c70:	fa f8 06 90 	ld.w	r8,sp[1680]
80009c74:	87 06       	st.w	r3[0x0],r6
80009c76:	87 1c       	st.w	r3[0x4],r12
80009c78:	18 08       	add	r8,r12
80009c7a:	cb 98       	rjmp	80009dec <_vfprintf_r+0x1c90>
80009c7c:	fa f9 06 90 	ld.w	r9,sp[1680]
80009c80:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009c84:	40 6b       	lddsp	r11,sp[0x18]
80009c86:	16 3a       	cp.w	r10,r11
80009c88:	c6 f5       	brlt	80009d66 <_vfprintf_r+0x1c0a>
80009c8a:	16 09       	add	r9,r11
80009c8c:	2f f8       	sub	r8,-1
80009c8e:	87 06       	st.w	r3[0x0],r6
80009c90:	fb 49 06 90 	st.w	sp[1680],r9
80009c94:	87 1b       	st.w	r3[0x4],r11
80009c96:	fb 48 06 8c 	st.w	sp[1676],r8
80009c9a:	58 78       	cp.w	r8,7
80009c9c:	e0 89 00 04 	brgt	80009ca4 <_vfprintf_r+0x1b48>
80009ca0:	2f 83       	sub	r3,-8
80009ca2:	c0 b8       	rjmp	80009cb8 <_vfprintf_r+0x1b5c>
80009ca4:	fa ca f9 78 	sub	r10,sp,-1672
80009ca8:	02 9b       	mov	r11,r1
80009caa:	08 9c       	mov	r12,r4
80009cac:	fe b0 f2 4a 	rcall	80008140 <__sprint_r>
80009cb0:	e0 81 01 d5 	brne	8000a05a <_vfprintf_r+0x1efe>
80009cb4:	fa c3 f9 e0 	sub	r3,sp,-1568
80009cb8:	fa f6 06 ac 	ld.w	r6,sp[1708]
80009cbc:	40 6a       	lddsp	r10,sp[0x18]
80009cbe:	14 16       	sub	r6,r10
80009cc0:	58 06       	cp.w	r6,0
80009cc2:	e0 89 00 1c 	brgt	80009cfa <_vfprintf_r+0x1b9e>
80009cc6:	c3 d8       	rjmp	80009d40 <_vfprintf_r+0x1be4>
80009cc8:	2f 09       	sub	r9,-16
80009cca:	2f f8       	sub	r8,-1
80009ccc:	fb 49 06 90 	st.w	sp[1680],r9
80009cd0:	87 02       	st.w	r3[0x0],r2
80009cd2:	87 10       	st.w	r3[0x4],r0
80009cd4:	fb 48 06 8c 	st.w	sp[1676],r8
80009cd8:	58 78       	cp.w	r8,7
80009cda:	e0 89 00 04 	brgt	80009ce2 <_vfprintf_r+0x1b86>
80009cde:	2f 83       	sub	r3,-8
80009ce0:	c0 b8       	rjmp	80009cf6 <_vfprintf_r+0x1b9a>
80009ce2:	fa ca f9 78 	sub	r10,sp,-1672
80009ce6:	02 9b       	mov	r11,r1
80009ce8:	08 9c       	mov	r12,r4
80009cea:	fe b0 f2 2b 	rcall	80008140 <__sprint_r>
80009cee:	e0 81 01 b6 	brne	8000a05a <_vfprintf_r+0x1efe>
80009cf2:	fa c3 f9 e0 	sub	r3,sp,-1568
80009cf6:	21 06       	sub	r6,16
80009cf8:	c0 48       	rjmp	80009d00 <_vfprintf_r+0x1ba4>
80009cfa:	fe c2 bc f2 	sub	r2,pc,-17166
80009cfe:	31 00       	mov	r0,16
80009d00:	fa f9 06 90 	ld.w	r9,sp[1680]
80009d04:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009d08:	fe ca bd 00 	sub	r10,pc,-17152
80009d0c:	59 06       	cp.w	r6,16
80009d0e:	fe 99 ff dd 	brgt	80009cc8 <_vfprintf_r+0x1b6c>
80009d12:	0c 09       	add	r9,r6
80009d14:	2f f8       	sub	r8,-1
80009d16:	87 0a       	st.w	r3[0x0],r10
80009d18:	fb 49 06 90 	st.w	sp[1680],r9
80009d1c:	87 16       	st.w	r3[0x4],r6
80009d1e:	fb 48 06 8c 	st.w	sp[1676],r8
80009d22:	58 78       	cp.w	r8,7
80009d24:	e0 89 00 04 	brgt	80009d2c <_vfprintf_r+0x1bd0>
80009d28:	2f 83       	sub	r3,-8
80009d2a:	c0 b8       	rjmp	80009d40 <_vfprintf_r+0x1be4>
80009d2c:	fa ca f9 78 	sub	r10,sp,-1672
80009d30:	02 9b       	mov	r11,r1
80009d32:	08 9c       	mov	r12,r4
80009d34:	fe b0 f2 06 	rcall	80008140 <__sprint_r>
80009d38:	e0 81 01 91 	brne	8000a05a <_vfprintf_r+0x1efe>
80009d3c:	fa c3 f9 e0 	sub	r3,sp,-1568
80009d40:	ed b5 00 00 	bld	r5,0x0
80009d44:	e0 81 01 20 	brne	80009f84 <_vfprintf_r+0x1e28>
80009d48:	40 c9       	lddsp	r9,sp[0x30]
80009d4a:	fa f8 06 90 	ld.w	r8,sp[1680]
80009d4e:	2f f8       	sub	r8,-1
80009d50:	87 09       	st.w	r3[0x0],r9
80009d52:	fb 48 06 90 	st.w	sp[1680],r8
80009d56:	30 19       	mov	r9,1
80009d58:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009d5c:	87 19       	st.w	r3[0x4],r9
80009d5e:	2f f8       	sub	r8,-1
80009d60:	fb 48 06 8c 	st.w	sp[1676],r8
80009d64:	c0 29       	rjmp	80009f68 <_vfprintf_r+0x1e0c>
80009d66:	14 09       	add	r9,r10
80009d68:	2f f8       	sub	r8,-1
80009d6a:	fb 49 06 90 	st.w	sp[1680],r9
80009d6e:	87 06       	st.w	r3[0x0],r6
80009d70:	87 1a       	st.w	r3[0x4],r10
80009d72:	fb 48 06 8c 	st.w	sp[1676],r8
80009d76:	58 78       	cp.w	r8,7
80009d78:	e0 89 00 04 	brgt	80009d80 <_vfprintf_r+0x1c24>
80009d7c:	2f 83       	sub	r3,-8
80009d7e:	c0 b8       	rjmp	80009d94 <_vfprintf_r+0x1c38>
80009d80:	fa ca f9 78 	sub	r10,sp,-1672
80009d84:	02 9b       	mov	r11,r1
80009d86:	08 9c       	mov	r12,r4
80009d88:	fe b0 f1 dc 	rcall	80008140 <__sprint_r>
80009d8c:	e0 81 01 67 	brne	8000a05a <_vfprintf_r+0x1efe>
80009d90:	fa c3 f9 e0 	sub	r3,sp,-1568
80009d94:	40 c8       	lddsp	r8,sp[0x30]
80009d96:	87 08       	st.w	r3[0x0],r8
80009d98:	fa f8 06 90 	ld.w	r8,sp[1680]
80009d9c:	2f f8       	sub	r8,-1
80009d9e:	30 19       	mov	r9,1
80009da0:	fb 48 06 90 	st.w	sp[1680],r8
80009da4:	87 19       	st.w	r3[0x4],r9
80009da6:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009daa:	2f f8       	sub	r8,-1
80009dac:	fb 48 06 8c 	st.w	sp[1676],r8
80009db0:	fa f2 06 ac 	ld.w	r2,sp[1708]
80009db4:	58 78       	cp.w	r8,7
80009db6:	e0 89 00 04 	brgt	80009dbe <_vfprintf_r+0x1c62>
80009dba:	2f 83       	sub	r3,-8
80009dbc:	c0 b8       	rjmp	80009dd2 <_vfprintf_r+0x1c76>
80009dbe:	fa ca f9 78 	sub	r10,sp,-1672
80009dc2:	02 9b       	mov	r11,r1
80009dc4:	08 9c       	mov	r12,r4
80009dc6:	fe b0 f1 bd 	rcall	80008140 <__sprint_r>
80009dca:	e0 81 01 48 	brne	8000a05a <_vfprintf_r+0x1efe>
80009dce:	fa c3 f9 e0 	sub	r3,sp,-1568
80009dd2:	04 06       	add	r6,r2
80009dd4:	fa f8 06 ac 	ld.w	r8,sp[1708]
80009dd8:	87 06       	st.w	r3[0x0],r6
80009dda:	fa f9 06 90 	ld.w	r9,sp[1680]
80009dde:	40 66       	lddsp	r6,sp[0x18]
80009de0:	40 6e       	lddsp	lr,sp[0x18]
80009de2:	10 16       	sub	r6,r8
80009de4:	f2 08 01 08 	sub	r8,r9,r8
80009de8:	87 16       	st.w	r3[0x4],r6
80009dea:	1c 08       	add	r8,lr
80009dec:	fb 48 06 90 	st.w	sp[1680],r8
80009df0:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009df4:	2f f8       	sub	r8,-1
80009df6:	fb 48 06 8c 	st.w	sp[1676],r8
80009dfa:	cb 78       	rjmp	80009f68 <_vfprintf_r+0x1e0c>
80009dfc:	40 6c       	lddsp	r12,sp[0x18]
80009dfe:	58 1c       	cp.w	r12,1
80009e00:	e0 89 00 06 	brgt	80009e0c <_vfprintf_r+0x1cb0>
80009e04:	ed b5 00 00 	bld	r5,0x0
80009e08:	e0 81 00 85 	brne	80009f12 <_vfprintf_r+0x1db6>
80009e0c:	fa f8 06 90 	ld.w	r8,sp[1680]
80009e10:	2f f8       	sub	r8,-1
80009e12:	30 19       	mov	r9,1
80009e14:	fb 48 06 90 	st.w	sp[1680],r8
80009e18:	87 06       	st.w	r3[0x0],r6
80009e1a:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009e1e:	87 19       	st.w	r3[0x4],r9
80009e20:	2f f8       	sub	r8,-1
80009e22:	fb 48 06 8c 	st.w	sp[1676],r8
80009e26:	58 78       	cp.w	r8,7
80009e28:	e0 89 00 04 	brgt	80009e30 <_vfprintf_r+0x1cd4>
80009e2c:	2f 83       	sub	r3,-8
80009e2e:	c0 b8       	rjmp	80009e44 <_vfprintf_r+0x1ce8>
80009e30:	fa ca f9 78 	sub	r10,sp,-1672
80009e34:	02 9b       	mov	r11,r1
80009e36:	08 9c       	mov	r12,r4
80009e38:	fe b0 f1 84 	rcall	80008140 <__sprint_r>
80009e3c:	e0 81 01 0f 	brne	8000a05a <_vfprintf_r+0x1efe>
80009e40:	fa c3 f9 e0 	sub	r3,sp,-1568
80009e44:	fa f8 06 90 	ld.w	r8,sp[1680]
80009e48:	2f f8       	sub	r8,-1
80009e4a:	40 cb       	lddsp	r11,sp[0x30]
80009e4c:	fb 48 06 90 	st.w	sp[1680],r8
80009e50:	30 19       	mov	r9,1
80009e52:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009e56:	87 0b       	st.w	r3[0x0],r11
80009e58:	2f f8       	sub	r8,-1
80009e5a:	87 19       	st.w	r3[0x4],r9
80009e5c:	fb 48 06 8c 	st.w	sp[1676],r8
80009e60:	58 78       	cp.w	r8,7
80009e62:	e0 89 00 05 	brgt	80009e6c <_vfprintf_r+0x1d10>
80009e66:	2f 83       	sub	r3,-8
80009e68:	c0 c8       	rjmp	80009e80 <_vfprintf_r+0x1d24>
80009e6a:	d7 03       	nop
80009e6c:	fa ca f9 78 	sub	r10,sp,-1672
80009e70:	02 9b       	mov	r11,r1
80009e72:	08 9c       	mov	r12,r4
80009e74:	fe b0 f1 66 	rcall	80008140 <__sprint_r>
80009e78:	e0 81 00 f1 	brne	8000a05a <_vfprintf_r+0x1efe>
80009e7c:	fa c3 f9 e0 	sub	r3,sp,-1568
80009e80:	30 08       	mov	r8,0
80009e82:	30 09       	mov	r9,0
80009e84:	40 5b       	lddsp	r11,sp[0x14]
80009e86:	40 7a       	lddsp	r10,sp[0x1c]
80009e88:	e0 a0 13 25 	rcall	8000c4d2 <__avr32_f64_cmp_eq>
80009e8c:	40 68       	lddsp	r8,sp[0x18]
80009e8e:	20 18       	sub	r8,1
80009e90:	58 0c       	cp.w	r12,0
80009e92:	c0 d1       	brne	80009eac <_vfprintf_r+0x1d50>
80009e94:	2f f6       	sub	r6,-1
80009e96:	87 18       	st.w	r3[0x4],r8
80009e98:	87 06       	st.w	r3[0x0],r6
80009e9a:	fa f6 06 90 	ld.w	r6,sp[1680]
80009e9e:	10 06       	add	r6,r8
80009ea0:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009ea4:	fb 46 06 90 	st.w	sp[1680],r6
80009ea8:	2f f8       	sub	r8,-1
80009eaa:	c3 18       	rjmp	80009f0c <_vfprintf_r+0x1db0>
80009eac:	10 96       	mov	r6,r8
80009eae:	58 08       	cp.w	r8,0
80009eb0:	e0 89 00 1c 	brgt	80009ee8 <_vfprintf_r+0x1d8c>
80009eb4:	c4 b8       	rjmp	80009f4a <_vfprintf_r+0x1dee>
80009eb6:	2f 09       	sub	r9,-16
80009eb8:	2f f8       	sub	r8,-1
80009eba:	fb 49 06 90 	st.w	sp[1680],r9
80009ebe:	87 02       	st.w	r3[0x0],r2
80009ec0:	87 10       	st.w	r3[0x4],r0
80009ec2:	fb 48 06 8c 	st.w	sp[1676],r8
80009ec6:	58 78       	cp.w	r8,7
80009ec8:	e0 89 00 04 	brgt	80009ed0 <_vfprintf_r+0x1d74>
80009ecc:	2f 83       	sub	r3,-8
80009ece:	c0 b8       	rjmp	80009ee4 <_vfprintf_r+0x1d88>
80009ed0:	fa ca f9 78 	sub	r10,sp,-1672
80009ed4:	02 9b       	mov	r11,r1
80009ed6:	08 9c       	mov	r12,r4
80009ed8:	fe b0 f1 34 	rcall	80008140 <__sprint_r>
80009edc:	e0 81 00 bf 	brne	8000a05a <_vfprintf_r+0x1efe>
80009ee0:	fa c3 f9 e0 	sub	r3,sp,-1568
80009ee4:	21 06       	sub	r6,16
80009ee6:	c0 48       	rjmp	80009eee <_vfprintf_r+0x1d92>
80009ee8:	fe c2 be e0 	sub	r2,pc,-16672
80009eec:	31 00       	mov	r0,16
80009eee:	fa f9 06 90 	ld.w	r9,sp[1680]
80009ef2:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009ef6:	fe ca be ee 	sub	r10,pc,-16658
80009efa:	59 06       	cp.w	r6,16
80009efc:	fe 99 ff dd 	brgt	80009eb6 <_vfprintf_r+0x1d5a>
80009f00:	0c 09       	add	r9,r6
80009f02:	87 0a       	st.w	r3[0x0],r10
80009f04:	fb 49 06 90 	st.w	sp[1680],r9
80009f08:	2f f8       	sub	r8,-1
80009f0a:	87 16       	st.w	r3[0x4],r6
80009f0c:	fb 48 06 8c 	st.w	sp[1676],r8
80009f10:	c0 e8       	rjmp	80009f2c <_vfprintf_r+0x1dd0>
80009f12:	fa f8 06 90 	ld.w	r8,sp[1680]
80009f16:	2f f8       	sub	r8,-1
80009f18:	30 19       	mov	r9,1
80009f1a:	fb 48 06 90 	st.w	sp[1680],r8
80009f1e:	87 06       	st.w	r3[0x0],r6
80009f20:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009f24:	87 19       	st.w	r3[0x4],r9
80009f26:	2f f8       	sub	r8,-1
80009f28:	fb 48 06 8c 	st.w	sp[1676],r8
80009f2c:	58 78       	cp.w	r8,7
80009f2e:	e0 89 00 04 	brgt	80009f36 <_vfprintf_r+0x1dda>
80009f32:	2f 83       	sub	r3,-8
80009f34:	c0 b8       	rjmp	80009f4a <_vfprintf_r+0x1dee>
80009f36:	fa ca f9 78 	sub	r10,sp,-1672
80009f3a:	02 9b       	mov	r11,r1
80009f3c:	08 9c       	mov	r12,r4
80009f3e:	fe b0 f1 01 	rcall	80008140 <__sprint_r>
80009f42:	e0 81 00 8c 	brne	8000a05a <_vfprintf_r+0x1efe>
80009f46:	fa c3 f9 e0 	sub	r3,sp,-1568
80009f4a:	40 ea       	lddsp	r10,sp[0x38]
80009f4c:	fa f8 06 90 	ld.w	r8,sp[1680]
80009f50:	14 08       	add	r8,r10
80009f52:	fa c9 f9 64 	sub	r9,sp,-1692
80009f56:	fb 48 06 90 	st.w	sp[1680],r8
80009f5a:	87 1a       	st.w	r3[0x4],r10
80009f5c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009f60:	87 09       	st.w	r3[0x0],r9
80009f62:	2f f8       	sub	r8,-1
80009f64:	fb 48 06 8c 	st.w	sp[1676],r8
80009f68:	58 78       	cp.w	r8,7
80009f6a:	e0 89 00 04 	brgt	80009f72 <_vfprintf_r+0x1e16>
80009f6e:	2f 83       	sub	r3,-8
80009f70:	c0 a8       	rjmp	80009f84 <_vfprintf_r+0x1e28>
80009f72:	fa ca f9 78 	sub	r10,sp,-1672
80009f76:	02 9b       	mov	r11,r1
80009f78:	08 9c       	mov	r12,r4
80009f7a:	fe b0 f0 e3 	rcall	80008140 <__sprint_r>
80009f7e:	c6 e1       	brne	8000a05a <_vfprintf_r+0x1efe>
80009f80:	fa c3 f9 e0 	sub	r3,sp,-1568
80009f84:	e2 15 00 04 	andl	r5,0x4,COH
80009f88:	c3 f0       	breq	8000a006 <_vfprintf_r+0x1eaa>
80009f8a:	40 86       	lddsp	r6,sp[0x20]
80009f8c:	40 39       	lddsp	r9,sp[0xc]
80009f8e:	12 16       	sub	r6,r9
80009f90:	58 06       	cp.w	r6,0
80009f92:	e0 89 00 1a 	brgt	80009fc6 <_vfprintf_r+0x1e6a>
80009f96:	c3 88       	rjmp	8000a006 <_vfprintf_r+0x1eaa>
80009f98:	2f 09       	sub	r9,-16
80009f9a:	2f f8       	sub	r8,-1
80009f9c:	fb 49 06 90 	st.w	sp[1680],r9
80009fa0:	87 05       	st.w	r3[0x0],r5
80009fa2:	87 12       	st.w	r3[0x4],r2
80009fa4:	fb 48 06 8c 	st.w	sp[1676],r8
80009fa8:	58 78       	cp.w	r8,7
80009faa:	e0 89 00 04 	brgt	80009fb2 <_vfprintf_r+0x1e56>
80009fae:	2f 83       	sub	r3,-8
80009fb0:	c0 98       	rjmp	80009fc2 <_vfprintf_r+0x1e66>
80009fb2:	00 9a       	mov	r10,r0
80009fb4:	02 9b       	mov	r11,r1
80009fb6:	08 9c       	mov	r12,r4
80009fb8:	fe b0 f0 c4 	rcall	80008140 <__sprint_r>
80009fbc:	c4 f1       	brne	8000a05a <_vfprintf_r+0x1efe>
80009fbe:	fa c3 f9 e0 	sub	r3,sp,-1568
80009fc2:	21 06       	sub	r6,16
80009fc4:	c0 68       	rjmp	80009fd0 <_vfprintf_r+0x1e74>
80009fc6:	fe c5 bf ce 	sub	r5,pc,-16434
80009fca:	31 02       	mov	r2,16
80009fcc:	fa c0 f9 78 	sub	r0,sp,-1672
80009fd0:	fa f9 06 90 	ld.w	r9,sp[1680]
80009fd4:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009fd8:	fe ca bf e0 	sub	r10,pc,-16416
80009fdc:	59 06       	cp.w	r6,16
80009fde:	fe 99 ff dd 	brgt	80009f98 <_vfprintf_r+0x1e3c>
80009fe2:	0c 09       	add	r9,r6
80009fe4:	2f f8       	sub	r8,-1
80009fe6:	87 0a       	st.w	r3[0x0],r10
80009fe8:	87 16       	st.w	r3[0x4],r6
80009fea:	fb 49 06 90 	st.w	sp[1680],r9
80009fee:	fb 48 06 8c 	st.w	sp[1676],r8
80009ff2:	58 78       	cp.w	r8,7
80009ff4:	e0 8a 00 09 	brle	8000a006 <_vfprintf_r+0x1eaa>
80009ff8:	fa ca f9 78 	sub	r10,sp,-1672
80009ffc:	02 9b       	mov	r11,r1
80009ffe:	08 9c       	mov	r12,r4
8000a000:	fe b0 f0 a0 	rcall	80008140 <__sprint_r>
8000a004:	c2 b1       	brne	8000a05a <_vfprintf_r+0x1efe>
8000a006:	40 bc       	lddsp	r12,sp[0x2c]
8000a008:	40 36       	lddsp	r6,sp[0xc]
8000a00a:	40 8e       	lddsp	lr,sp[0x20]
8000a00c:	ec 0e 0c 48 	max	r8,r6,lr
8000a010:	10 0c       	add	r12,r8
8000a012:	50 bc       	stdsp	sp[0x2c],r12
8000a014:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a018:	58 08       	cp.w	r8,0
8000a01a:	c0 80       	breq	8000a02a <_vfprintf_r+0x1ece>
8000a01c:	fa ca f9 78 	sub	r10,sp,-1672
8000a020:	02 9b       	mov	r11,r1
8000a022:	08 9c       	mov	r12,r4
8000a024:	fe b0 f0 8e 	rcall	80008140 <__sprint_r>
8000a028:	c1 91       	brne	8000a05a <_vfprintf_r+0x1efe>
8000a02a:	30 0b       	mov	r11,0
8000a02c:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a030:	fb 4b 06 8c 	st.w	sp[1676],r11
8000a034:	fe 9f f1 22 	bral	80008278 <_vfprintf_r+0x11c>
8000a038:	08 95       	mov	r5,r4
8000a03a:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a03e:	58 08       	cp.w	r8,0
8000a040:	c0 80       	breq	8000a050 <_vfprintf_r+0x1ef4>
8000a042:	08 9c       	mov	r12,r4
8000a044:	fa ca f9 78 	sub	r10,sp,-1672
8000a048:	02 9b       	mov	r11,r1
8000a04a:	fe b0 f0 7b 	rcall	80008140 <__sprint_r>
8000a04e:	c0 61       	brne	8000a05a <_vfprintf_r+0x1efe>
8000a050:	30 08       	mov	r8,0
8000a052:	fb 48 06 8c 	st.w	sp[1676],r8
8000a056:	c0 28       	rjmp	8000a05a <_vfprintf_r+0x1efe>
8000a058:	40 41       	lddsp	r1,sp[0x10]
8000a05a:	82 68       	ld.sh	r8,r1[0xc]
8000a05c:	ed b8 00 06 	bld	r8,0x6
8000a060:	c0 31       	brne	8000a066 <_vfprintf_r+0x1f0a>
8000a062:	3f fa       	mov	r10,-1
8000a064:	50 ba       	stdsp	sp[0x2c],r10
8000a066:	40 bc       	lddsp	r12,sp[0x2c]
8000a068:	fe 3d f9 44 	sub	sp,-1724
8000a06c:	d8 32       	popm	r0-r7,pc
8000a06e:	d7 03       	nop

8000a070 <__swsetup_r>:
8000a070:	d4 21       	pushm	r4-r7,lr
8000a072:	e0 68 0a 3c 	mov	r8,2620
8000a076:	18 96       	mov	r6,r12
8000a078:	16 97       	mov	r7,r11
8000a07a:	70 0c       	ld.w	r12,r8[0x0]
8000a07c:	58 0c       	cp.w	r12,0
8000a07e:	c0 60       	breq	8000a08a <__swsetup_r+0x1a>
8000a080:	78 68       	ld.w	r8,r12[0x18]
8000a082:	58 08       	cp.w	r8,0
8000a084:	c0 31       	brne	8000a08a <__swsetup_r+0x1a>
8000a086:	e0 a0 07 bf 	rcall	8000b004 <__sinit>
8000a08a:	fe c8 bf 62 	sub	r8,pc,-16542
8000a08e:	10 37       	cp.w	r7,r8
8000a090:	c0 61       	brne	8000a09c <__swsetup_r+0x2c>
8000a092:	e0 68 0a 3c 	mov	r8,2620
8000a096:	70 08       	ld.w	r8,r8[0x0]
8000a098:	70 07       	ld.w	r7,r8[0x0]
8000a09a:	c1 28       	rjmp	8000a0be <__swsetup_r+0x4e>
8000a09c:	fe c8 bf 54 	sub	r8,pc,-16556
8000a0a0:	10 37       	cp.w	r7,r8
8000a0a2:	c0 61       	brne	8000a0ae <__swsetup_r+0x3e>
8000a0a4:	e0 68 0a 3c 	mov	r8,2620
8000a0a8:	70 08       	ld.w	r8,r8[0x0]
8000a0aa:	70 17       	ld.w	r7,r8[0x4]
8000a0ac:	c0 98       	rjmp	8000a0be <__swsetup_r+0x4e>
8000a0ae:	fe c8 bf 46 	sub	r8,pc,-16570
8000a0b2:	10 37       	cp.w	r7,r8
8000a0b4:	c0 51       	brne	8000a0be <__swsetup_r+0x4e>
8000a0b6:	e0 68 0a 3c 	mov	r8,2620
8000a0ba:	70 08       	ld.w	r8,r8[0x0]
8000a0bc:	70 27       	ld.w	r7,r8[0x8]
8000a0be:	8e 68       	ld.sh	r8,r7[0xc]
8000a0c0:	ed b8 00 03 	bld	r8,0x3
8000a0c4:	c1 e0       	breq	8000a100 <__swsetup_r+0x90>
8000a0c6:	ed b8 00 04 	bld	r8,0x4
8000a0ca:	c3 e1       	brne	8000a146 <__swsetup_r+0xd6>
8000a0cc:	ed b8 00 02 	bld	r8,0x2
8000a0d0:	c1 51       	brne	8000a0fa <__swsetup_r+0x8a>
8000a0d2:	6e db       	ld.w	r11,r7[0x34]
8000a0d4:	58 0b       	cp.w	r11,0
8000a0d6:	c0 a0       	breq	8000a0ea <__swsetup_r+0x7a>
8000a0d8:	ee c8 ff bc 	sub	r8,r7,-68
8000a0dc:	10 3b       	cp.w	r11,r8
8000a0de:	c0 40       	breq	8000a0e6 <__swsetup_r+0x76>
8000a0e0:	0c 9c       	mov	r12,r6
8000a0e2:	e0 a0 08 2b 	rcall	8000b138 <_free_r>
8000a0e6:	30 08       	mov	r8,0
8000a0e8:	8f d8       	st.w	r7[0x34],r8
8000a0ea:	8e 68       	ld.sh	r8,r7[0xc]
8000a0ec:	e0 18 ff db 	andl	r8,0xffdb
8000a0f0:	ae 68       	st.h	r7[0xc],r8
8000a0f2:	30 08       	mov	r8,0
8000a0f4:	8f 18       	st.w	r7[0x4],r8
8000a0f6:	6e 48       	ld.w	r8,r7[0x10]
8000a0f8:	8f 08       	st.w	r7[0x0],r8
8000a0fa:	8e 68       	ld.sh	r8,r7[0xc]
8000a0fc:	a3 b8       	sbr	r8,0x3
8000a0fe:	ae 68       	st.h	r7[0xc],r8
8000a100:	6e 48       	ld.w	r8,r7[0x10]
8000a102:	58 08       	cp.w	r8,0
8000a104:	c0 b1       	brne	8000a11a <__swsetup_r+0xaa>
8000a106:	8e 68       	ld.sh	r8,r7[0xc]
8000a108:	e2 18 02 80 	andl	r8,0x280,COH
8000a10c:	e0 48 02 00 	cp.w	r8,512
8000a110:	c0 50       	breq	8000a11a <__swsetup_r+0xaa>
8000a112:	0c 9c       	mov	r12,r6
8000a114:	0e 9b       	mov	r11,r7
8000a116:	e0 a0 0a 4b 	rcall	8000b5ac <__smakebuf_r>
8000a11a:	8e 69       	ld.sh	r9,r7[0xc]
8000a11c:	f1 d9 c0 01 	bfextu	r8,r9,0x0,0x1
8000a120:	c0 70       	breq	8000a12e <__swsetup_r+0xbe>
8000a122:	30 08       	mov	r8,0
8000a124:	8f 28       	st.w	r7[0x8],r8
8000a126:	6e 58       	ld.w	r8,r7[0x14]
8000a128:	5c 38       	neg	r8
8000a12a:	8f 68       	st.w	r7[0x18],r8
8000a12c:	c0 68       	rjmp	8000a138 <__swsetup_r+0xc8>
8000a12e:	ed b9 00 01 	bld	r9,0x1
8000a132:	ef f8 10 05 	ld.wne	r8,r7[0x14]
8000a136:	8f 28       	st.w	r7[0x8],r8
8000a138:	6e 48       	ld.w	r8,r7[0x10]
8000a13a:	58 08       	cp.w	r8,0
8000a13c:	c0 61       	brne	8000a148 <__swsetup_r+0xd8>
8000a13e:	8e 68       	ld.sh	r8,r7[0xc]
8000a140:	ed b8 00 07 	bld	r8,0x7
8000a144:	c0 21       	brne	8000a148 <__swsetup_r+0xd8>
8000a146:	dc 2a       	popm	r4-r7,pc,r12=-1
8000a148:	d8 2a       	popm	r4-r7,pc,r12=0
8000a14a:	d7 03       	nop

8000a14c <quorem>:
8000a14c:	d4 31       	pushm	r0-r7,lr
8000a14e:	20 2d       	sub	sp,8
8000a150:	18 97       	mov	r7,r12
8000a152:	78 48       	ld.w	r8,r12[0x10]
8000a154:	76 46       	ld.w	r6,r11[0x10]
8000a156:	0c 38       	cp.w	r8,r6
8000a158:	c0 34       	brge	8000a15e <quorem+0x12>
8000a15a:	30 0c       	mov	r12,0
8000a15c:	c8 58       	rjmp	8000a266 <quorem+0x11a>
8000a15e:	ec c2 ff fc 	sub	r2,r6,-4
8000a162:	f6 c3 ff ec 	sub	r3,r11,-20
8000a166:	f6 02 03 29 	ld.w	r9,r11[r2<<0x2]
8000a16a:	f8 02 03 2c 	ld.w	r12,r12[r2<<0x2]
8000a16e:	2f f9       	sub	r9,-1
8000a170:	20 16       	sub	r6,1
8000a172:	f8 09 0d 08 	divu	r8,r12,r9
8000a176:	f6 02 00 22 	add	r2,r11,r2<<0x2
8000a17a:	ee c4 ff ec 	sub	r4,r7,-20
8000a17e:	10 95       	mov	r5,r8
8000a180:	58 08       	cp.w	r8,0
8000a182:	c4 10       	breq	8000a204 <quorem+0xb8>
8000a184:	30 09       	mov	r9,0
8000a186:	06 9a       	mov	r10,r3
8000a188:	08 98       	mov	r8,r4
8000a18a:	12 91       	mov	r1,r9
8000a18c:	50 0b       	stdsp	sp[0x0],r11
8000a18e:	70 0e       	ld.w	lr,r8[0x0]
8000a190:	b1 8e       	lsr	lr,0x10
8000a192:	50 1e       	stdsp	sp[0x4],lr
8000a194:	15 0e       	ld.w	lr,r10++
8000a196:	fc 00 16 10 	lsr	r0,lr,0x10
8000a19a:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000a19e:	ea 0e 03 41 	mac	r1,r5,lr
8000a1a2:	fd d1 c0 10 	bfextu	lr,r1,0x0,0x10
8000a1a6:	b1 81       	lsr	r1,0x10
8000a1a8:	40 1b       	lddsp	r11,sp[0x4]
8000a1aa:	ea 00 02 40 	mul	r0,r5,r0
8000a1ae:	e2 00 00 00 	add	r0,r1,r0
8000a1b2:	e3 d0 c0 10 	bfextu	r1,r0,0x0,0x10
8000a1b6:	02 1b       	sub	r11,r1
8000a1b8:	50 1b       	stdsp	sp[0x4],r11
8000a1ba:	70 0b       	ld.w	r11,r8[0x0]
8000a1bc:	e3 db c0 10 	bfextu	r1,r11,0x0,0x10
8000a1c0:	02 09       	add	r9,r1
8000a1c2:	f2 0e 01 0e 	sub	lr,r9,lr
8000a1c6:	b0 1e       	st.h	r8[0x2],lr
8000a1c8:	fc 09 14 10 	asr	r9,lr,0x10
8000a1cc:	40 1e       	lddsp	lr,sp[0x4]
8000a1ce:	fc 09 00 09 	add	r9,lr,r9
8000a1d2:	b0 09       	st.h	r8[0x0],r9
8000a1d4:	e0 01 16 10 	lsr	r1,r0,0x10
8000a1d8:	2f c8       	sub	r8,-4
8000a1da:	b1 49       	asr	r9,0x10
8000a1dc:	04 3a       	cp.w	r10,r2
8000a1de:	fe 98 ff d8 	brls	8000a18e <quorem+0x42>
8000a1e2:	40 0b       	lddsp	r11,sp[0x0]
8000a1e4:	58 0c       	cp.w	r12,0
8000a1e6:	c0 f1       	brne	8000a204 <quorem+0xb8>
8000a1e8:	ec c8 ff fb 	sub	r8,r6,-5
8000a1ec:	ee 08 00 28 	add	r8,r7,r8<<0x2
8000a1f0:	c0 28       	rjmp	8000a1f4 <quorem+0xa8>
8000a1f2:	20 16       	sub	r6,1
8000a1f4:	20 48       	sub	r8,4
8000a1f6:	08 38       	cp.w	r8,r4
8000a1f8:	e0 88 00 05 	brls	8000a202 <quorem+0xb6>
8000a1fc:	70 09       	ld.w	r9,r8[0x0]
8000a1fe:	58 09       	cp.w	r9,0
8000a200:	cf 90       	breq	8000a1f2 <quorem+0xa6>
8000a202:	8f 46       	st.w	r7[0x10],r6
8000a204:	0e 9c       	mov	r12,r7
8000a206:	e0 a0 0a d2 	rcall	8000b7aa <__mcmp>
8000a20a:	c2 d5       	brlt	8000a264 <quorem+0x118>
8000a20c:	2f f5       	sub	r5,-1
8000a20e:	08 98       	mov	r8,r4
8000a210:	30 09       	mov	r9,0
8000a212:	07 0b       	ld.w	r11,r3++
8000a214:	f6 0a 16 10 	lsr	r10,r11,0x10
8000a218:	70 0c       	ld.w	r12,r8[0x0]
8000a21a:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000a21e:	f8 0e 16 10 	lsr	lr,r12,0x10
8000a222:	14 1e       	sub	lr,r10
8000a224:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000a228:	16 1a       	sub	r10,r11
8000a22a:	12 0a       	add	r10,r9
8000a22c:	b0 1a       	st.h	r8[0x2],r10
8000a22e:	b1 4a       	asr	r10,0x10
8000a230:	fc 0a 00 09 	add	r9,lr,r10
8000a234:	b0 09       	st.h	r8[0x0],r9
8000a236:	2f c8       	sub	r8,-4
8000a238:	b1 49       	asr	r9,0x10
8000a23a:	04 33       	cp.w	r3,r2
8000a23c:	fe 98 ff eb 	brls	8000a212 <quorem+0xc6>
8000a240:	ec c8 ff fb 	sub	r8,r6,-5
8000a244:	ee 08 03 29 	ld.w	r9,r7[r8<<0x2]
8000a248:	58 09       	cp.w	r9,0
8000a24a:	c0 d1       	brne	8000a264 <quorem+0x118>
8000a24c:	ee 08 00 28 	add	r8,r7,r8<<0x2
8000a250:	c0 28       	rjmp	8000a254 <quorem+0x108>
8000a252:	20 16       	sub	r6,1
8000a254:	20 48       	sub	r8,4
8000a256:	08 38       	cp.w	r8,r4
8000a258:	e0 88 00 05 	brls	8000a262 <quorem+0x116>
8000a25c:	70 09       	ld.w	r9,r8[0x0]
8000a25e:	58 09       	cp.w	r9,0
8000a260:	cf 90       	breq	8000a252 <quorem+0x106>
8000a262:	8f 46       	st.w	r7[0x10],r6
8000a264:	0a 9c       	mov	r12,r5
8000a266:	2f ed       	sub	sp,-8
8000a268:	d8 32       	popm	r0-r7,pc
8000a26a:	d7 03       	nop

8000a26c <_dtoa_r>:
8000a26c:	d4 31       	pushm	r0-r7,lr
8000a26e:	21 ad       	sub	sp,104
8000a270:	fa c4 ff 74 	sub	r4,sp,-140
8000a274:	18 97       	mov	r7,r12
8000a276:	16 95       	mov	r5,r11
8000a278:	68 2c       	ld.w	r12,r4[0x8]
8000a27a:	50 c9       	stdsp	sp[0x30],r9
8000a27c:	68 16       	ld.w	r6,r4[0x4]
8000a27e:	68 09       	ld.w	r9,r4[0x0]
8000a280:	50 e8       	stdsp	sp[0x38],r8
8000a282:	14 94       	mov	r4,r10
8000a284:	51 2c       	stdsp	sp[0x48],r12
8000a286:	fa e5 00 08 	st.d	sp[8],r4
8000a28a:	51 59       	stdsp	sp[0x54],r9
8000a28c:	6e 95       	ld.w	r5,r7[0x24]
8000a28e:	58 05       	cp.w	r5,0
8000a290:	c0 91       	brne	8000a2a2 <_dtoa_r+0x36>
8000a292:	31 0c       	mov	r12,16
8000a294:	fe b0 e8 f4 	rcall	8000747c <malloc>
8000a298:	99 35       	st.w	r12[0xc],r5
8000a29a:	8f 9c       	st.w	r7[0x24],r12
8000a29c:	99 15       	st.w	r12[0x4],r5
8000a29e:	99 25       	st.w	r12[0x8],r5
8000a2a0:	99 05       	st.w	r12[0x0],r5
8000a2a2:	6e 99       	ld.w	r9,r7[0x24]
8000a2a4:	72 08       	ld.w	r8,r9[0x0]
8000a2a6:	58 08       	cp.w	r8,0
8000a2a8:	c0 f0       	breq	8000a2c6 <_dtoa_r+0x5a>
8000a2aa:	72 1a       	ld.w	r10,r9[0x4]
8000a2ac:	91 1a       	st.w	r8[0x4],r10
8000a2ae:	30 1a       	mov	r10,1
8000a2b0:	72 19       	ld.w	r9,r9[0x4]
8000a2b2:	f4 09 09 49 	lsl	r9,r10,r9
8000a2b6:	10 9b       	mov	r11,r8
8000a2b8:	91 29       	st.w	r8[0x8],r9
8000a2ba:	0e 9c       	mov	r12,r7
8000a2bc:	e0 a0 0a 90 	rcall	8000b7dc <_Bfree>
8000a2c0:	6e 98       	ld.w	r8,r7[0x24]
8000a2c2:	30 09       	mov	r9,0
8000a2c4:	91 09       	st.w	r8[0x0],r9
8000a2c6:	40 28       	lddsp	r8,sp[0x8]
8000a2c8:	10 94       	mov	r4,r8
8000a2ca:	58 08       	cp.w	r8,0
8000a2cc:	c0 64       	brge	8000a2d8 <_dtoa_r+0x6c>
8000a2ce:	f1 d8 c0 1f 	bfextu	r8,r8,0x0,0x1f
8000a2d2:	50 28       	stdsp	sp[0x8],r8
8000a2d4:	30 18       	mov	r8,1
8000a2d6:	c0 28       	rjmp	8000a2da <_dtoa_r+0x6e>
8000a2d8:	30 08       	mov	r8,0
8000a2da:	8d 08       	st.w	r6[0x0],r8
8000a2dc:	fc 1c 7f f0 	movh	r12,0x7ff0
8000a2e0:	40 26       	lddsp	r6,sp[0x8]
8000a2e2:	0c 98       	mov	r8,r6
8000a2e4:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000a2e8:	18 38       	cp.w	r8,r12
8000a2ea:	c2 01       	brne	8000a32a <_dtoa_r+0xbe>
8000a2ec:	e0 68 27 0f 	mov	r8,9999
8000a2f0:	41 5b       	lddsp	r11,sp[0x54]
8000a2f2:	97 08       	st.w	r11[0x0],r8
8000a2f4:	40 3a       	lddsp	r10,sp[0xc]
8000a2f6:	58 0a       	cp.w	r10,0
8000a2f8:	c0 71       	brne	8000a306 <_dtoa_r+0x9a>
8000a2fa:	ed d6 c0 14 	bfextu	r6,r6,0x0,0x14
8000a2fe:	c0 41       	brne	8000a306 <_dtoa_r+0x9a>
8000a300:	fe cc c1 e8 	sub	r12,pc,-15896
8000a304:	c0 38       	rjmp	8000a30a <_dtoa_r+0x9e>
8000a306:	fe cc c1 e2 	sub	r12,pc,-15902
8000a30a:	41 29       	lddsp	r9,sp[0x48]
8000a30c:	58 09       	cp.w	r9,0
8000a30e:	e0 80 05 9a 	breq	8000ae42 <_dtoa_r+0xbd6>
8000a312:	f8 c8 ff fd 	sub	r8,r12,-3
8000a316:	f8 c9 ff f8 	sub	r9,r12,-8
8000a31a:	11 8b       	ld.ub	r11,r8[0x0]
8000a31c:	30 0a       	mov	r10,0
8000a31e:	41 25       	lddsp	r5,sp[0x48]
8000a320:	f4 0b 18 00 	cp.b	r11,r10
8000a324:	f2 08 17 10 	movne	r8,r9
8000a328:	c1 68       	rjmp	8000a354 <_dtoa_r+0xe8>
8000a32a:	fa ea 00 08 	ld.d	r10,sp[8]
8000a32e:	30 08       	mov	r8,0
8000a330:	fa eb 00 3c 	st.d	sp[60],r10
8000a334:	30 09       	mov	r9,0
8000a336:	e0 a0 10 ce 	rcall	8000c4d2 <__avr32_f64_cmp_eq>
8000a33a:	c1 00       	breq	8000a35a <_dtoa_r+0xee>
8000a33c:	30 18       	mov	r8,1
8000a33e:	41 5a       	lddsp	r10,sp[0x54]
8000a340:	95 08       	st.w	r10[0x0],r8
8000a342:	fe cc c3 4e 	sub	r12,pc,-15538
8000a346:	41 29       	lddsp	r9,sp[0x48]
8000a348:	f8 08 00 08 	add	r8,r12,r8
8000a34c:	58 09       	cp.w	r9,0
8000a34e:	e0 80 05 7a 	breq	8000ae42 <_dtoa_r+0xbd6>
8000a352:	12 95       	mov	r5,r9
8000a354:	8b 08       	st.w	r5[0x0],r8
8000a356:	e0 8f 05 76 	bral	8000ae42 <_dtoa_r+0xbd6>
8000a35a:	fa c8 ff 9c 	sub	r8,sp,-100
8000a35e:	fa c9 ff a0 	sub	r9,sp,-96
8000a362:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a366:	0e 9c       	mov	r12,r7
8000a368:	eb d6 c2 8b 	bfextu	r5,r6,0x14,0xb
8000a36c:	e0 a0 0a 8a 	rcall	8000b880 <__d2b>
8000a370:	18 93       	mov	r3,r12
8000a372:	58 05       	cp.w	r5,0
8000a374:	c0 d0       	breq	8000a38e <_dtoa_r+0x122>
8000a376:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a37a:	30 04       	mov	r4,0
8000a37c:	f1 db c0 14 	bfextu	r8,r11,0x0,0x14
8000a380:	ea c5 03 ff 	sub	r5,r5,1023
8000a384:	10 9b       	mov	r11,r8
8000a386:	51 74       	stdsp	sp[0x5c],r4
8000a388:	ea 1b 3f f0 	orh	r11,0x3ff0
8000a38c:	c2 58       	rjmp	8000a3d6 <_dtoa_r+0x16a>
8000a38e:	41 88       	lddsp	r8,sp[0x60]
8000a390:	41 9c       	lddsp	r12,sp[0x64]
8000a392:	10 0c       	add	r12,r8
8000a394:	f8 c5 fb ce 	sub	r5,r12,-1074
8000a398:	e0 45 00 20 	cp.w	r5,32
8000a39c:	e0 8a 00 0e 	brle	8000a3b8 <_dtoa_r+0x14c>
8000a3a0:	f8 cc fb ee 	sub	r12,r12,-1042
8000a3a4:	40 3b       	lddsp	r11,sp[0xc]
8000a3a6:	ea 08 11 40 	rsub	r8,r5,64
8000a3aa:	f6 0c 0a 4c 	lsr	r12,r11,r12
8000a3ae:	ec 08 09 46 	lsl	r6,r6,r8
8000a3b2:	0c 4c       	or	r12,r6
8000a3b4:	c0 78       	rjmp	8000a3c2 <_dtoa_r+0x156>
8000a3b6:	d7 03       	nop
8000a3b8:	ea 0c 11 20 	rsub	r12,r5,32
8000a3bc:	40 3a       	lddsp	r10,sp[0xc]
8000a3be:	f4 0c 09 4c 	lsl	r12,r10,r12
8000a3c2:	e0 a0 10 14 	rcall	8000c3ea <__avr32_u32_to_f64>
8000a3c6:	fc 18 fe 10 	movh	r8,0xfe10
8000a3ca:	30 19       	mov	r9,1
8000a3cc:	ea c5 04 33 	sub	r5,r5,1075
8000a3d0:	f0 0b 00 0b 	add	r11,r8,r11
8000a3d4:	51 79       	stdsp	sp[0x5c],r9
8000a3d6:	30 08       	mov	r8,0
8000a3d8:	fc 19 3f f8 	movh	r9,0x3ff8
8000a3dc:	e0 a0 0e 9c 	rcall	8000c114 <__avr32_f64_sub>
8000a3e0:	e0 68 43 61 	mov	r8,17249
8000a3e4:	ea 18 63 6f 	orh	r8,0x636f
8000a3e8:	e0 69 87 a7 	mov	r9,34727
8000a3ec:	ea 19 3f d2 	orh	r9,0x3fd2
8000a3f0:	e0 a0 0d a6 	rcall	8000bf3c <__avr32_f64_mul>
8000a3f4:	e0 68 c8 b3 	mov	r8,51379
8000a3f8:	ea 18 8b 60 	orh	r8,0x8b60
8000a3fc:	e0 69 8a 28 	mov	r9,35368
8000a400:	ea 19 3f c6 	orh	r9,0x3fc6
8000a404:	e0 a0 0f 56 	rcall	8000c2b0 <__avr32_f64_add>
8000a408:	0a 9c       	mov	r12,r5
8000a40a:	14 90       	mov	r0,r10
8000a40c:	16 91       	mov	r1,r11
8000a40e:	e0 a0 0f f2 	rcall	8000c3f2 <__avr32_s32_to_f64>
8000a412:	e0 68 79 fb 	mov	r8,31227
8000a416:	ea 18 50 9f 	orh	r8,0x509f
8000a41a:	e0 69 44 13 	mov	r9,17427
8000a41e:	ea 19 3f d3 	orh	r9,0x3fd3
8000a422:	e0 a0 0d 8d 	rcall	8000bf3c <__avr32_f64_mul>
8000a426:	14 98       	mov	r8,r10
8000a428:	16 99       	mov	r9,r11
8000a42a:	00 9a       	mov	r10,r0
8000a42c:	02 9b       	mov	r11,r1
8000a42e:	e0 a0 0f 41 	rcall	8000c2b0 <__avr32_f64_add>
8000a432:	14 90       	mov	r0,r10
8000a434:	16 91       	mov	r1,r11
8000a436:	e0 a0 0f c7 	rcall	8000c3c4 <__avr32_f64_to_s32>
8000a43a:	30 08       	mov	r8,0
8000a43c:	18 96       	mov	r6,r12
8000a43e:	30 09       	mov	r9,0
8000a440:	00 9a       	mov	r10,r0
8000a442:	02 9b       	mov	r11,r1
8000a444:	e0 a0 10 8e 	rcall	8000c560 <__avr32_f64_cmp_lt>
8000a448:	c0 c0       	breq	8000a460 <_dtoa_r+0x1f4>
8000a44a:	0c 9c       	mov	r12,r6
8000a44c:	e0 a0 0f d3 	rcall	8000c3f2 <__avr32_s32_to_f64>
8000a450:	14 98       	mov	r8,r10
8000a452:	16 99       	mov	r9,r11
8000a454:	00 9a       	mov	r10,r0
8000a456:	02 9b       	mov	r11,r1
8000a458:	e0 a0 10 3d 	rcall	8000c4d2 <__avr32_f64_cmp_eq>
8000a45c:	f7 b6 00 01 	subeq	r6,1
8000a460:	59 66       	cp.w	r6,22
8000a462:	e0 88 00 05 	brls	8000a46c <_dtoa_r+0x200>
8000a466:	30 18       	mov	r8,1
8000a468:	51 48       	stdsp	sp[0x50],r8
8000a46a:	c1 38       	rjmp	8000a490 <_dtoa_r+0x224>
8000a46c:	fe c8 c2 94 	sub	r8,pc,-15724
8000a470:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a474:	f0 06 02 38 	ld.d	r8,r8[r6<<0x3]
8000a478:	e0 a0 10 74 	rcall	8000c560 <__avr32_f64_cmp_lt>
8000a47c:	f9 b4 00 00 	moveq	r4,0
8000a480:	fb f4 0a 14 	st.weq	sp[0x50],r4
8000a484:	f7 b6 01 01 	subne	r6,1
8000a488:	f9 bc 01 00 	movne	r12,0
8000a48c:	fb fc 1a 14 	st.wne	sp[0x50],r12
8000a490:	41 90       	lddsp	r0,sp[0x64]
8000a492:	20 10       	sub	r0,1
8000a494:	0a 10       	sub	r0,r5
8000a496:	c0 46       	brmi	8000a49e <_dtoa_r+0x232>
8000a498:	50 40       	stdsp	sp[0x10],r0
8000a49a:	30 00       	mov	r0,0
8000a49c:	c0 48       	rjmp	8000a4a4 <_dtoa_r+0x238>
8000a49e:	30 0b       	mov	r11,0
8000a4a0:	5c 30       	neg	r0
8000a4a2:	50 4b       	stdsp	sp[0x10],r11
8000a4a4:	ec 02 11 00 	rsub	r2,r6,0
8000a4a8:	58 06       	cp.w	r6,0
8000a4aa:	fb fa 40 04 	ld.wge	r10,sp[0x10]
8000a4ae:	f5 d6 e4 0a 	addge	r10,r10,r6
8000a4b2:	fb fa 4a 04 	st.wge	sp[0x10],r10
8000a4b6:	fb f6 4a 11 	st.wge	sp[0x44],r6
8000a4ba:	f9 b2 04 00 	movge	r2,0
8000a4be:	e1 d6 e5 10 	sublt	r0,r0,r6
8000a4c2:	f9 b9 05 00 	movlt	r9,0
8000a4c6:	fb f9 5a 11 	st.wlt	sp[0x44],r9
8000a4ca:	40 c8       	lddsp	r8,sp[0x30]
8000a4cc:	58 98       	cp.w	r8,9
8000a4ce:	e0 8b 00 20 	brhi	8000a50e <_dtoa_r+0x2a2>
8000a4d2:	58 58       	cp.w	r8,5
8000a4d4:	f9 b4 0a 01 	movle	r4,1
8000a4d8:	fb f5 90 0c 	ld.wgt	r5,sp[0x30]
8000a4dc:	f7 b5 09 04 	subgt	r5,4
8000a4e0:	fb f5 9a 0c 	st.wgt	sp[0x30],r5
8000a4e4:	f9 b4 09 00 	movgt	r4,0
8000a4e8:	40 cc       	lddsp	r12,sp[0x30]
8000a4ea:	58 3c       	cp.w	r12,3
8000a4ec:	c2 d0       	breq	8000a546 <_dtoa_r+0x2da>
8000a4ee:	e0 89 00 05 	brgt	8000a4f8 <_dtoa_r+0x28c>
8000a4f2:	58 2c       	cp.w	r12,2
8000a4f4:	c1 01       	brne	8000a514 <_dtoa_r+0x2a8>
8000a4f6:	c1 88       	rjmp	8000a526 <_dtoa_r+0x2ba>
8000a4f8:	40 cb       	lddsp	r11,sp[0x30]
8000a4fa:	58 4b       	cp.w	r11,4
8000a4fc:	c0 60       	breq	8000a508 <_dtoa_r+0x29c>
8000a4fe:	58 5b       	cp.w	r11,5
8000a500:	c0 a1       	brne	8000a514 <_dtoa_r+0x2a8>
8000a502:	30 1a       	mov	r10,1
8000a504:	50 da       	stdsp	sp[0x34],r10
8000a506:	c2 28       	rjmp	8000a54a <_dtoa_r+0x2de>
8000a508:	30 19       	mov	r9,1
8000a50a:	50 d9       	stdsp	sp[0x34],r9
8000a50c:	c0 f8       	rjmp	8000a52a <_dtoa_r+0x2be>
8000a50e:	30 08       	mov	r8,0
8000a510:	30 14       	mov	r4,1
8000a512:	50 c8       	stdsp	sp[0x30],r8
8000a514:	3f f5       	mov	r5,-1
8000a516:	30 1c       	mov	r12,1
8000a518:	30 0b       	mov	r11,0
8000a51a:	50 95       	stdsp	sp[0x24],r5
8000a51c:	50 dc       	stdsp	sp[0x34],r12
8000a51e:	0a 91       	mov	r1,r5
8000a520:	31 28       	mov	r8,18
8000a522:	50 eb       	stdsp	sp[0x38],r11
8000a524:	c2 08       	rjmp	8000a564 <_dtoa_r+0x2f8>
8000a526:	30 0a       	mov	r10,0
8000a528:	50 da       	stdsp	sp[0x34],r10
8000a52a:	40 e9       	lddsp	r9,sp[0x38]
8000a52c:	58 09       	cp.w	r9,0
8000a52e:	e0 89 00 07 	brgt	8000a53c <_dtoa_r+0x2d0>
8000a532:	30 18       	mov	r8,1
8000a534:	50 98       	stdsp	sp[0x24],r8
8000a536:	10 91       	mov	r1,r8
8000a538:	50 e8       	stdsp	sp[0x38],r8
8000a53a:	c1 58       	rjmp	8000a564 <_dtoa_r+0x2f8>
8000a53c:	40 e5       	lddsp	r5,sp[0x38]
8000a53e:	50 95       	stdsp	sp[0x24],r5
8000a540:	0a 91       	mov	r1,r5
8000a542:	0a 98       	mov	r8,r5
8000a544:	c1 08       	rjmp	8000a564 <_dtoa_r+0x2f8>
8000a546:	30 0c       	mov	r12,0
8000a548:	50 dc       	stdsp	sp[0x34],r12
8000a54a:	40 eb       	lddsp	r11,sp[0x38]
8000a54c:	ec 0b 00 0b 	add	r11,r6,r11
8000a550:	50 9b       	stdsp	sp[0x24],r11
8000a552:	16 98       	mov	r8,r11
8000a554:	2f f8       	sub	r8,-1
8000a556:	58 08       	cp.w	r8,0
8000a558:	e0 89 00 05 	brgt	8000a562 <_dtoa_r+0x2f6>
8000a55c:	10 91       	mov	r1,r8
8000a55e:	30 18       	mov	r8,1
8000a560:	c0 28       	rjmp	8000a564 <_dtoa_r+0x2f8>
8000a562:	10 91       	mov	r1,r8
8000a564:	30 09       	mov	r9,0
8000a566:	6e 9a       	ld.w	r10,r7[0x24]
8000a568:	95 19       	st.w	r10[0x4],r9
8000a56a:	30 49       	mov	r9,4
8000a56c:	c0 68       	rjmp	8000a578 <_dtoa_r+0x30c>
8000a56e:	d7 03       	nop
8000a570:	6a 1a       	ld.w	r10,r5[0x4]
8000a572:	a1 79       	lsl	r9,0x1
8000a574:	2f fa       	sub	r10,-1
8000a576:	8b 1a       	st.w	r5[0x4],r10
8000a578:	6e 95       	ld.w	r5,r7[0x24]
8000a57a:	f2 ca ff ec 	sub	r10,r9,-20
8000a57e:	10 3a       	cp.w	r10,r8
8000a580:	fe 98 ff f8 	brls	8000a570 <_dtoa_r+0x304>
8000a584:	6a 1b       	ld.w	r11,r5[0x4]
8000a586:	0e 9c       	mov	r12,r7
8000a588:	e0 a0 09 44 	rcall	8000b810 <_Balloc>
8000a58c:	58 e1       	cp.w	r1,14
8000a58e:	5f 88       	srls	r8
8000a590:	8b 0c       	st.w	r5[0x0],r12
8000a592:	f1 e4 00 04 	and	r4,r8,r4
8000a596:	6e 98       	ld.w	r8,r7[0x24]
8000a598:	70 08       	ld.w	r8,r8[0x0]
8000a59a:	50 88       	stdsp	sp[0x20],r8
8000a59c:	e0 80 01 82 	breq	8000a8a0 <_dtoa_r+0x634>
8000a5a0:	58 06       	cp.w	r6,0
8000a5a2:	e0 8a 00 43 	brle	8000a628 <_dtoa_r+0x3bc>
8000a5a6:	f3 d6 c0 04 	bfextu	r9,r6,0x0,0x4
8000a5aa:	fe c8 c3 d2 	sub	r8,pc,-15406
8000a5ae:	f0 09 02 34 	ld.d	r4,r8[r9<<0x3]
8000a5b2:	fa e5 00 18 	st.d	sp[24],r4
8000a5b6:	ec 04 14 04 	asr	r4,r6,0x4
8000a5ba:	ed b4 00 04 	bld	r4,0x4
8000a5be:	c0 30       	breq	8000a5c4 <_dtoa_r+0x358>
8000a5c0:	30 25       	mov	r5,2
8000a5c2:	c1 08       	rjmp	8000a5e2 <_dtoa_r+0x376>
8000a5c4:	fe c8 c3 24 	sub	r8,pc,-15580
8000a5c8:	f0 e8 00 20 	ld.d	r8,r8[32]
8000a5cc:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a5d0:	e9 d4 c0 04 	bfextu	r4,r4,0x0,0x4
8000a5d4:	e0 a0 0f fa 	rcall	8000c5c8 <__avr32_f64_div>
8000a5d8:	30 35       	mov	r5,3
8000a5da:	14 98       	mov	r8,r10
8000a5dc:	16 99       	mov	r9,r11
8000a5de:	fa e9 00 08 	st.d	sp[8],r8
8000a5e2:	fe cc c3 42 	sub	r12,pc,-15550
8000a5e6:	50 a3       	stdsp	sp[0x28],r3
8000a5e8:	0c 93       	mov	r3,r6
8000a5ea:	18 96       	mov	r6,r12
8000a5ec:	c0 f8       	rjmp	8000a60a <_dtoa_r+0x39e>
8000a5ee:	fa ea 00 18 	ld.d	r10,sp[24]
8000a5f2:	ed b4 00 00 	bld	r4,0x0
8000a5f6:	c0 81       	brne	8000a606 <_dtoa_r+0x39a>
8000a5f8:	ec e8 00 00 	ld.d	r8,r6[0]
8000a5fc:	2f f5       	sub	r5,-1
8000a5fe:	e0 a0 0c 9f 	rcall	8000bf3c <__avr32_f64_mul>
8000a602:	fa eb 00 18 	st.d	sp[24],r10
8000a606:	a1 54       	asr	r4,0x1
8000a608:	2f 86       	sub	r6,-8
8000a60a:	58 04       	cp.w	r4,0
8000a60c:	cf 11       	brne	8000a5ee <_dtoa_r+0x382>
8000a60e:	fa e8 00 18 	ld.d	r8,sp[24]
8000a612:	fa ea 00 08 	ld.d	r10,sp[8]
8000a616:	06 96       	mov	r6,r3
8000a618:	e0 a0 0f d8 	rcall	8000c5c8 <__avr32_f64_div>
8000a61c:	40 a3       	lddsp	r3,sp[0x28]
8000a61e:	14 98       	mov	r8,r10
8000a620:	16 99       	mov	r9,r11
8000a622:	fa e9 00 08 	st.d	sp[8],r8
8000a626:	c2 f8       	rjmp	8000a684 <_dtoa_r+0x418>
8000a628:	ec 08 11 00 	rsub	r8,r6,0
8000a62c:	c0 31       	brne	8000a632 <_dtoa_r+0x3c6>
8000a62e:	30 25       	mov	r5,2
8000a630:	c2 a8       	rjmp	8000a684 <_dtoa_r+0x418>
8000a632:	fe cc c3 92 	sub	r12,pc,-15470
8000a636:	f0 04 14 04 	asr	r4,r8,0x4
8000a63a:	50 1c       	stdsp	sp[0x4],r12
8000a63c:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
8000a640:	fe c9 c4 68 	sub	r9,pc,-15256
8000a644:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a648:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000a64c:	e0 a0 0c 78 	rcall	8000bf3c <__avr32_f64_mul>
8000a650:	40 1c       	lddsp	r12,sp[0x4]
8000a652:	50 63       	stdsp	sp[0x18],r3
8000a654:	30 25       	mov	r5,2
8000a656:	0c 93       	mov	r3,r6
8000a658:	fa eb 00 08 	st.d	sp[8],r10
8000a65c:	18 96       	mov	r6,r12
8000a65e:	c0 f8       	rjmp	8000a67c <_dtoa_r+0x410>
8000a660:	fa ea 00 08 	ld.d	r10,sp[8]
8000a664:	ed b4 00 00 	bld	r4,0x0
8000a668:	c0 81       	brne	8000a678 <_dtoa_r+0x40c>
8000a66a:	ec e8 00 00 	ld.d	r8,r6[0]
8000a66e:	2f f5       	sub	r5,-1
8000a670:	e0 a0 0c 66 	rcall	8000bf3c <__avr32_f64_mul>
8000a674:	fa eb 00 08 	st.d	sp[8],r10
8000a678:	a1 54       	asr	r4,0x1
8000a67a:	2f 86       	sub	r6,-8
8000a67c:	58 04       	cp.w	r4,0
8000a67e:	cf 11       	brne	8000a660 <_dtoa_r+0x3f4>
8000a680:	06 96       	mov	r6,r3
8000a682:	40 63       	lddsp	r3,sp[0x18]
8000a684:	41 4a       	lddsp	r10,sp[0x50]
8000a686:	58 0a       	cp.w	r10,0
8000a688:	c2 a0       	breq	8000a6dc <_dtoa_r+0x470>
8000a68a:	fa e8 00 08 	ld.d	r8,sp[8]
8000a68e:	58 01       	cp.w	r1,0
8000a690:	5f 94       	srgt	r4
8000a692:	fa e9 00 18 	st.d	sp[24],r8
8000a696:	30 08       	mov	r8,0
8000a698:	fc 19 3f f0 	movh	r9,0x3ff0
8000a69c:	fa ea 00 18 	ld.d	r10,sp[24]
8000a6a0:	e0 a0 0f 60 	rcall	8000c560 <__avr32_f64_cmp_lt>
8000a6a4:	f9 bc 00 00 	moveq	r12,0
8000a6a8:	f9 bc 01 01 	movne	r12,1
8000a6ac:	e9 ec 00 0c 	and	r12,r4,r12
8000a6b0:	c1 60       	breq	8000a6dc <_dtoa_r+0x470>
8000a6b2:	40 98       	lddsp	r8,sp[0x24]
8000a6b4:	58 08       	cp.w	r8,0
8000a6b6:	e0 8a 00 f1 	brle	8000a898 <_dtoa_r+0x62c>
8000a6ba:	30 08       	mov	r8,0
8000a6bc:	fc 19 40 24 	movh	r9,0x4024
8000a6c0:	ec c4 00 01 	sub	r4,r6,1
8000a6c4:	fa ea 00 18 	ld.d	r10,sp[24]
8000a6c8:	2f f5       	sub	r5,-1
8000a6ca:	50 64       	stdsp	sp[0x18],r4
8000a6cc:	e0 a0 0c 38 	rcall	8000bf3c <__avr32_f64_mul>
8000a6d0:	40 94       	lddsp	r4,sp[0x24]
8000a6d2:	14 98       	mov	r8,r10
8000a6d4:	16 99       	mov	r9,r11
8000a6d6:	fa e9 00 08 	st.d	sp[8],r8
8000a6da:	c0 38       	rjmp	8000a6e0 <_dtoa_r+0x474>
8000a6dc:	50 66       	stdsp	sp[0x18],r6
8000a6de:	02 94       	mov	r4,r1
8000a6e0:	0a 9c       	mov	r12,r5
8000a6e2:	e0 a0 0e 88 	rcall	8000c3f2 <__avr32_s32_to_f64>
8000a6e6:	fa e8 00 08 	ld.d	r8,sp[8]
8000a6ea:	e0 a0 0c 29 	rcall	8000bf3c <__avr32_f64_mul>
8000a6ee:	30 08       	mov	r8,0
8000a6f0:	fc 19 40 1c 	movh	r9,0x401c
8000a6f4:	e0 a0 0d de 	rcall	8000c2b0 <__avr32_f64_add>
8000a6f8:	14 98       	mov	r8,r10
8000a6fa:	16 99       	mov	r9,r11
8000a6fc:	fa e9 00 28 	st.d	sp[40],r8
8000a700:	fc 18 fc c0 	movh	r8,0xfcc0
8000a704:	40 a5       	lddsp	r5,sp[0x28]
8000a706:	10 05       	add	r5,r8
8000a708:	50 a5       	stdsp	sp[0x28],r5
8000a70a:	58 04       	cp.w	r4,0
8000a70c:	c2 11       	brne	8000a74e <_dtoa_r+0x4e2>
8000a70e:	fa ea 00 08 	ld.d	r10,sp[8]
8000a712:	30 08       	mov	r8,0
8000a714:	fc 19 40 14 	movh	r9,0x4014
8000a718:	e0 a0 0c fe 	rcall	8000c114 <__avr32_f64_sub>
8000a71c:	40 bc       	lddsp	r12,sp[0x2c]
8000a71e:	fa eb 00 08 	st.d	sp[8],r10
8000a722:	14 98       	mov	r8,r10
8000a724:	16 99       	mov	r9,r11
8000a726:	18 9a       	mov	r10,r12
8000a728:	0a 9b       	mov	r11,r5
8000a72a:	e0 a0 0f 1b 	rcall	8000c560 <__avr32_f64_cmp_lt>
8000a72e:	e0 81 02 54 	brne	8000abd6 <_dtoa_r+0x96a>
8000a732:	0a 98       	mov	r8,r5
8000a734:	40 b9       	lddsp	r9,sp[0x2c]
8000a736:	ee 18 80 00 	eorh	r8,0x8000
8000a73a:	fa ea 00 08 	ld.d	r10,sp[8]
8000a73e:	10 95       	mov	r5,r8
8000a740:	12 98       	mov	r8,r9
8000a742:	0a 99       	mov	r9,r5
8000a744:	e0 a0 0f 0e 	rcall	8000c560 <__avr32_f64_cmp_lt>
8000a748:	e0 81 02 3e 	brne	8000abc4 <_dtoa_r+0x958>
8000a74c:	ca 68       	rjmp	8000a898 <_dtoa_r+0x62c>
8000a74e:	fe c9 c5 76 	sub	r9,pc,-14986
8000a752:	e8 c8 00 01 	sub	r8,r4,1
8000a756:	40 d5       	lddsp	r5,sp[0x34]
8000a758:	58 05       	cp.w	r5,0
8000a75a:	c4 f0       	breq	8000a7f8 <_dtoa_r+0x58c>
8000a75c:	30 0c       	mov	r12,0
8000a75e:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000a762:	51 3c       	stdsp	sp[0x4c],r12
8000a764:	30 0a       	mov	r10,0
8000a766:	fc 1b 3f e0 	movh	r11,0x3fe0
8000a76a:	e0 a0 0f 2f 	rcall	8000c5c8 <__avr32_f64_div>
8000a76e:	fa e8 00 28 	ld.d	r8,sp[40]
8000a772:	40 85       	lddsp	r5,sp[0x20]
8000a774:	e0 a0 0c d0 	rcall	8000c114 <__avr32_f64_sub>
8000a778:	fa eb 00 28 	st.d	sp[40],r10
8000a77c:	fa ea 00 08 	ld.d	r10,sp[8]
8000a780:	e0 a0 0e 22 	rcall	8000c3c4 <__avr32_f64_to_s32>
8000a784:	51 6c       	stdsp	sp[0x58],r12
8000a786:	e0 a0 0e 36 	rcall	8000c3f2 <__avr32_s32_to_f64>
8000a78a:	14 98       	mov	r8,r10
8000a78c:	16 99       	mov	r9,r11
8000a78e:	fa ea 00 08 	ld.d	r10,sp[8]
8000a792:	e0 a0 0c c1 	rcall	8000c114 <__avr32_f64_sub>
8000a796:	fa eb 00 08 	st.d	sp[8],r10
8000a79a:	41 68       	lddsp	r8,sp[0x58]
8000a79c:	2d 08       	sub	r8,-48
8000a79e:	0a c8       	st.b	r5++,r8
8000a7a0:	41 39       	lddsp	r9,sp[0x4c]
8000a7a2:	2f f9       	sub	r9,-1
8000a7a4:	51 39       	stdsp	sp[0x4c],r9
8000a7a6:	fa e8 00 28 	ld.d	r8,sp[40]
8000a7aa:	e0 a0 0e db 	rcall	8000c560 <__avr32_f64_cmp_lt>
8000a7ae:	e0 81 03 39 	brne	8000ae20 <_dtoa_r+0xbb4>
8000a7b2:	fa e8 00 08 	ld.d	r8,sp[8]
8000a7b6:	30 0a       	mov	r10,0
8000a7b8:	fc 1b 3f f0 	movh	r11,0x3ff0
8000a7bc:	e0 a0 0c ac 	rcall	8000c114 <__avr32_f64_sub>
8000a7c0:	fa e8 00 28 	ld.d	r8,sp[40]
8000a7c4:	e0 a0 0e ce 	rcall	8000c560 <__avr32_f64_cmp_lt>
8000a7c8:	fa ea 00 28 	ld.d	r10,sp[40]
8000a7cc:	30 08       	mov	r8,0
8000a7ce:	fc 19 40 24 	movh	r9,0x4024
8000a7d2:	e0 81 00 da 	brne	8000a986 <_dtoa_r+0x71a>
8000a7d6:	41 3c       	lddsp	r12,sp[0x4c]
8000a7d8:	08 3c       	cp.w	r12,r4
8000a7da:	c5 f4       	brge	8000a898 <_dtoa_r+0x62c>
8000a7dc:	e0 a0 0b b0 	rcall	8000bf3c <__avr32_f64_mul>
8000a7e0:	30 08       	mov	r8,0
8000a7e2:	fa eb 00 28 	st.d	sp[40],r10
8000a7e6:	fc 19 40 24 	movh	r9,0x4024
8000a7ea:	fa ea 00 08 	ld.d	r10,sp[8]
8000a7ee:	e0 a0 0b a7 	rcall	8000bf3c <__avr32_f64_mul>
8000a7f2:	fa eb 00 08 	st.d	sp[8],r10
8000a7f6:	cc 3b       	rjmp	8000a77c <_dtoa_r+0x510>
8000a7f8:	40 85       	lddsp	r5,sp[0x20]
8000a7fa:	08 05       	add	r5,r4
8000a7fc:	f2 08 02 3a 	ld.d	r10,r9[r8<<0x3]
8000a800:	51 35       	stdsp	sp[0x4c],r5
8000a802:	fa e8 00 28 	ld.d	r8,sp[40]
8000a806:	40 85       	lddsp	r5,sp[0x20]
8000a808:	e0 a0 0b 9a 	rcall	8000bf3c <__avr32_f64_mul>
8000a80c:	fa eb 00 28 	st.d	sp[40],r10
8000a810:	fa ea 00 08 	ld.d	r10,sp[8]
8000a814:	e0 a0 0d d8 	rcall	8000c3c4 <__avr32_f64_to_s32>
8000a818:	51 6c       	stdsp	sp[0x58],r12
8000a81a:	e0 a0 0d ec 	rcall	8000c3f2 <__avr32_s32_to_f64>
8000a81e:	14 98       	mov	r8,r10
8000a820:	16 99       	mov	r9,r11
8000a822:	fa ea 00 08 	ld.d	r10,sp[8]
8000a826:	e0 a0 0c 77 	rcall	8000c114 <__avr32_f64_sub>
8000a82a:	fa eb 00 08 	st.d	sp[8],r10
8000a82e:	41 68       	lddsp	r8,sp[0x58]
8000a830:	2d 08       	sub	r8,-48
8000a832:	0a c8       	st.b	r5++,r8
8000a834:	41 3c       	lddsp	r12,sp[0x4c]
8000a836:	18 35       	cp.w	r5,r12
8000a838:	c2 81       	brne	8000a888 <_dtoa_r+0x61c>
8000a83a:	30 08       	mov	r8,0
8000a83c:	fc 19 3f e0 	movh	r9,0x3fe0
8000a840:	fa ea 00 28 	ld.d	r10,sp[40]
8000a844:	e0 a0 0d 36 	rcall	8000c2b0 <__avr32_f64_add>
8000a848:	40 85       	lddsp	r5,sp[0x20]
8000a84a:	fa e8 00 08 	ld.d	r8,sp[8]
8000a84e:	08 05       	add	r5,r4
8000a850:	e0 a0 0e 88 	rcall	8000c560 <__avr32_f64_cmp_lt>
8000a854:	e0 81 00 99 	brne	8000a986 <_dtoa_r+0x71a>
8000a858:	fa e8 00 28 	ld.d	r8,sp[40]
8000a85c:	30 0a       	mov	r10,0
8000a85e:	fc 1b 3f e0 	movh	r11,0x3fe0
8000a862:	e0 a0 0c 59 	rcall	8000c114 <__avr32_f64_sub>
8000a866:	14 98       	mov	r8,r10
8000a868:	16 99       	mov	r9,r11
8000a86a:	fa ea 00 08 	ld.d	r10,sp[8]
8000a86e:	e0 a0 0e 79 	rcall	8000c560 <__avr32_f64_cmp_lt>
8000a872:	c1 30       	breq	8000a898 <_dtoa_r+0x62c>
8000a874:	33 09       	mov	r9,48
8000a876:	0a 98       	mov	r8,r5
8000a878:	11 7a       	ld.ub	r10,--r8
8000a87a:	f2 0a 18 00 	cp.b	r10,r9
8000a87e:	e0 81 02 d1 	brne	8000ae20 <_dtoa_r+0xbb4>
8000a882:	10 95       	mov	r5,r8
8000a884:	cf 9b       	rjmp	8000a876 <_dtoa_r+0x60a>
8000a886:	d7 03       	nop
8000a888:	30 08       	mov	r8,0
8000a88a:	fc 19 40 24 	movh	r9,0x4024
8000a88e:	e0 a0 0b 57 	rcall	8000bf3c <__avr32_f64_mul>
8000a892:	fa eb 00 08 	st.d	sp[8],r10
8000a896:	cb db       	rjmp	8000a810 <_dtoa_r+0x5a4>
8000a898:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a89c:	fa eb 00 08 	st.d	sp[8],r10
8000a8a0:	58 e6       	cp.w	r6,14
8000a8a2:	5f ab       	srle	r11
8000a8a4:	41 8a       	lddsp	r10,sp[0x60]
8000a8a6:	30 08       	mov	r8,0
8000a8a8:	f4 09 11 ff 	rsub	r9,r10,-1
8000a8ac:	f7 e9 03 f9 	and	r9,r11,r9>>0x1f
8000a8b0:	f0 09 18 00 	cp.b	r9,r8
8000a8b4:	e0 80 00 82 	breq	8000a9b8 <_dtoa_r+0x74c>
8000a8b8:	40 ea       	lddsp	r10,sp[0x38]
8000a8ba:	58 01       	cp.w	r1,0
8000a8bc:	5f a9       	srle	r9
8000a8be:	f3 ea 03 f9 	and	r9,r9,r10>>0x1f
8000a8c2:	fe ca c6 ea 	sub	r10,pc,-14614
8000a8c6:	f4 06 02 34 	ld.d	r4,r10[r6<<0x3]
8000a8ca:	fa e5 00 10 	st.d	sp[16],r4
8000a8ce:	f0 09 18 00 	cp.b	r9,r8
8000a8d2:	c1 40       	breq	8000a8fa <_dtoa_r+0x68e>
8000a8d4:	58 01       	cp.w	r1,0
8000a8d6:	e0 81 01 77 	brne	8000abc4 <_dtoa_r+0x958>
8000a8da:	30 08       	mov	r8,0
8000a8dc:	fc 19 40 14 	movh	r9,0x4014
8000a8e0:	08 9a       	mov	r10,r4
8000a8e2:	0a 9b       	mov	r11,r5
8000a8e4:	e0 a0 0b 2c 	rcall	8000bf3c <__avr32_f64_mul>
8000a8e8:	fa e8 00 08 	ld.d	r8,sp[8]
8000a8ec:	e0 a0 0e 06 	rcall	8000c4f8 <__avr32_f64_cmp_ge>
8000a8f0:	e0 81 01 6a 	brne	8000abc4 <_dtoa_r+0x958>
8000a8f4:	02 92       	mov	r2,r1
8000a8f6:	e0 8f 01 72 	bral	8000abda <_dtoa_r+0x96e>
8000a8fa:	40 85       	lddsp	r5,sp[0x20]
8000a8fc:	30 14       	mov	r4,1
8000a8fe:	fa e8 00 10 	ld.d	r8,sp[16]
8000a902:	fa ea 00 08 	ld.d	r10,sp[8]
8000a906:	e0 a0 0e 61 	rcall	8000c5c8 <__avr32_f64_div>
8000a90a:	e0 a0 0d 5d 	rcall	8000c3c4 <__avr32_f64_to_s32>
8000a90e:	18 92       	mov	r2,r12
8000a910:	e0 a0 0d 71 	rcall	8000c3f2 <__avr32_s32_to_f64>
8000a914:	fa e8 00 10 	ld.d	r8,sp[16]
8000a918:	e0 a0 0b 12 	rcall	8000bf3c <__avr32_f64_mul>
8000a91c:	14 98       	mov	r8,r10
8000a91e:	16 99       	mov	r9,r11
8000a920:	fa ea 00 08 	ld.d	r10,sp[8]
8000a924:	e0 a0 0b f8 	rcall	8000c114 <__avr32_f64_sub>
8000a928:	fa eb 00 08 	st.d	sp[8],r10
8000a92c:	e4 c8 ff d0 	sub	r8,r2,-48
8000a930:	0a c8       	st.b	r5++,r8
8000a932:	fc 19 40 24 	movh	r9,0x4024
8000a936:	30 08       	mov	r8,0
8000a938:	02 34       	cp.w	r4,r1
8000a93a:	c3 31       	brne	8000a9a0 <_dtoa_r+0x734>
8000a93c:	fa e8 00 08 	ld.d	r8,sp[8]
8000a940:	e0 a0 0c b8 	rcall	8000c2b0 <__avr32_f64_add>
8000a944:	16 91       	mov	r1,r11
8000a946:	14 90       	mov	r0,r10
8000a948:	14 98       	mov	r8,r10
8000a94a:	02 99       	mov	r9,r1
8000a94c:	fa ea 00 10 	ld.d	r10,sp[16]
8000a950:	e0 a0 0e 08 	rcall	8000c560 <__avr32_f64_cmp_lt>
8000a954:	c1 a1       	brne	8000a988 <_dtoa_r+0x71c>
8000a956:	fa e8 00 10 	ld.d	r8,sp[16]
8000a95a:	00 9a       	mov	r10,r0
8000a95c:	02 9b       	mov	r11,r1
8000a95e:	e0 a0 0d ba 	rcall	8000c4d2 <__avr32_f64_cmp_eq>
8000a962:	e0 80 02 5e 	breq	8000ae1e <_dtoa_r+0xbb2>
8000a966:	e5 d2 c0 01 	bfextu	r2,r2,0x0,0x1
8000a96a:	c0 f1       	brne	8000a988 <_dtoa_r+0x71c>
8000a96c:	e0 8f 02 59 	bral	8000ae1e <_dtoa_r+0xbb2>
8000a970:	40 8a       	lddsp	r10,sp[0x20]
8000a972:	14 38       	cp.w	r8,r10
8000a974:	c0 30       	breq	8000a97a <_dtoa_r+0x70e>
8000a976:	10 95       	mov	r5,r8
8000a978:	c0 98       	rjmp	8000a98a <_dtoa_r+0x71e>
8000a97a:	33 08       	mov	r8,48
8000a97c:	40 89       	lddsp	r9,sp[0x20]
8000a97e:	2f f6       	sub	r6,-1
8000a980:	b2 88       	st.b	r9[0x0],r8
8000a982:	40 88       	lddsp	r8,sp[0x20]
8000a984:	c0 88       	rjmp	8000a994 <_dtoa_r+0x728>
8000a986:	40 66       	lddsp	r6,sp[0x18]
8000a988:	33 99       	mov	r9,57
8000a98a:	0a 98       	mov	r8,r5
8000a98c:	11 7a       	ld.ub	r10,--r8
8000a98e:	f2 0a 18 00 	cp.b	r10,r9
8000a992:	ce f0       	breq	8000a970 <_dtoa_r+0x704>
8000a994:	50 66       	stdsp	sp[0x18],r6
8000a996:	11 89       	ld.ub	r9,r8[0x0]
8000a998:	2f f9       	sub	r9,-1
8000a99a:	b0 89       	st.b	r8[0x0],r9
8000a99c:	e0 8f 02 42 	bral	8000ae20 <_dtoa_r+0xbb4>
8000a9a0:	e0 a0 0a ce 	rcall	8000bf3c <__avr32_f64_mul>
8000a9a4:	2f f4       	sub	r4,-1
8000a9a6:	fa eb 00 08 	st.d	sp[8],r10
8000a9aa:	30 08       	mov	r8,0
8000a9ac:	30 09       	mov	r9,0
8000a9ae:	e0 a0 0d 92 	rcall	8000c4d2 <__avr32_f64_cmp_eq>
8000a9b2:	ca 60       	breq	8000a8fe <_dtoa_r+0x692>
8000a9b4:	e0 8f 02 35 	bral	8000ae1e <_dtoa_r+0xbb2>
8000a9b8:	40 d8       	lddsp	r8,sp[0x34]
8000a9ba:	58 08       	cp.w	r8,0
8000a9bc:	c0 51       	brne	8000a9c6 <_dtoa_r+0x75a>
8000a9be:	04 98       	mov	r8,r2
8000a9c0:	00 95       	mov	r5,r0
8000a9c2:	40 d4       	lddsp	r4,sp[0x34]
8000a9c4:	c3 78       	rjmp	8000aa32 <_dtoa_r+0x7c6>
8000a9c6:	40 c5       	lddsp	r5,sp[0x30]
8000a9c8:	58 15       	cp.w	r5,1
8000a9ca:	e0 89 00 0f 	brgt	8000a9e8 <_dtoa_r+0x77c>
8000a9ce:	41 74       	lddsp	r4,sp[0x5c]
8000a9d0:	58 04       	cp.w	r4,0
8000a9d2:	c0 40       	breq	8000a9da <_dtoa_r+0x76e>
8000a9d4:	f4 c9 fb cd 	sub	r9,r10,-1075
8000a9d8:	c0 48       	rjmp	8000a9e0 <_dtoa_r+0x774>
8000a9da:	41 99       	lddsp	r9,sp[0x64]
8000a9dc:	f2 09 11 36 	rsub	r9,r9,54
8000a9e0:	04 98       	mov	r8,r2
8000a9e2:	00 95       	mov	r5,r0
8000a9e4:	c1 c8       	rjmp	8000aa1c <_dtoa_r+0x7b0>
8000a9e6:	d7 03       	nop
8000a9e8:	e2 c8 00 01 	sub	r8,r1,1
8000a9ec:	58 01       	cp.w	r1,0
8000a9ee:	e0 05 17 40 	movge	r5,r0
8000a9f2:	e2 09 17 40 	movge	r9,r1
8000a9f6:	e1 d1 e5 15 	sublt	r5,r0,r1
8000a9fa:	f9 b9 05 00 	movlt	r9,0
8000a9fe:	10 32       	cp.w	r2,r8
8000aa00:	e5 d8 e4 18 	subge	r8,r2,r8
8000aa04:	f1 d2 e5 18 	sublt	r8,r8,r2
8000aa08:	e5 d8 e5 02 	addlt	r2,r2,r8
8000aa0c:	fb fc 50 11 	ld.wlt	r12,sp[0x44]
8000aa10:	f9 d8 e5 0c 	addlt	r12,r12,r8
8000aa14:	fb fc 5a 11 	st.wlt	sp[0x44],r12
8000aa18:	f9 b8 05 00 	movlt	r8,0
8000aa1c:	40 4b       	lddsp	r11,sp[0x10]
8000aa1e:	12 0b       	add	r11,r9
8000aa20:	50 08       	stdsp	sp[0x0],r8
8000aa22:	50 4b       	stdsp	sp[0x10],r11
8000aa24:	12 00       	add	r0,r9
8000aa26:	30 1b       	mov	r11,1
8000aa28:	0e 9c       	mov	r12,r7
8000aa2a:	e0 a0 08 a7 	rcall	8000bb78 <__i2b>
8000aa2e:	40 08       	lddsp	r8,sp[0x0]
8000aa30:	18 94       	mov	r4,r12
8000aa32:	40 4a       	lddsp	r10,sp[0x10]
8000aa34:	58 05       	cp.w	r5,0
8000aa36:	5f 99       	srgt	r9
8000aa38:	58 0a       	cp.w	r10,0
8000aa3a:	5f 9a       	srgt	r10
8000aa3c:	f5 e9 00 09 	and	r9,r10,r9
8000aa40:	c0 80       	breq	8000aa50 <_dtoa_r+0x7e4>
8000aa42:	40 4c       	lddsp	r12,sp[0x10]
8000aa44:	f8 05 0d 49 	min	r9,r12,r5
8000aa48:	12 1c       	sub	r12,r9
8000aa4a:	12 10       	sub	r0,r9
8000aa4c:	50 4c       	stdsp	sp[0x10],r12
8000aa4e:	12 15       	sub	r5,r9
8000aa50:	58 02       	cp.w	r2,0
8000aa52:	e0 8a 00 27 	brle	8000aaa0 <_dtoa_r+0x834>
8000aa56:	40 db       	lddsp	r11,sp[0x34]
8000aa58:	58 0b       	cp.w	r11,0
8000aa5a:	c1 d0       	breq	8000aa94 <_dtoa_r+0x828>
8000aa5c:	58 08       	cp.w	r8,0
8000aa5e:	e0 8a 00 17 	brle	8000aa8c <_dtoa_r+0x820>
8000aa62:	10 9a       	mov	r10,r8
8000aa64:	50 08       	stdsp	sp[0x0],r8
8000aa66:	08 9b       	mov	r11,r4
8000aa68:	0e 9c       	mov	r12,r7
8000aa6a:	e0 a0 08 cd 	rcall	8000bc04 <__pow5mult>
8000aa6e:	06 9a       	mov	r10,r3
8000aa70:	18 9b       	mov	r11,r12
8000aa72:	18 94       	mov	r4,r12
8000aa74:	0e 9c       	mov	r12,r7
8000aa76:	e0 a0 08 01 	rcall	8000ba78 <__multiply>
8000aa7a:	18 99       	mov	r9,r12
8000aa7c:	06 9b       	mov	r11,r3
8000aa7e:	50 19       	stdsp	sp[0x4],r9
8000aa80:	0e 9c       	mov	r12,r7
8000aa82:	e0 a0 06 ad 	rcall	8000b7dc <_Bfree>
8000aa86:	40 19       	lddsp	r9,sp[0x4]
8000aa88:	40 08       	lddsp	r8,sp[0x0]
8000aa8a:	12 93       	mov	r3,r9
8000aa8c:	e4 08 01 0a 	sub	r10,r2,r8
8000aa90:	c0 80       	breq	8000aaa0 <_dtoa_r+0x834>
8000aa92:	c0 28       	rjmp	8000aa96 <_dtoa_r+0x82a>
8000aa94:	04 9a       	mov	r10,r2
8000aa96:	06 9b       	mov	r11,r3
8000aa98:	0e 9c       	mov	r12,r7
8000aa9a:	e0 a0 08 b5 	rcall	8000bc04 <__pow5mult>
8000aa9e:	18 93       	mov	r3,r12
8000aaa0:	30 1b       	mov	r11,1
8000aaa2:	0e 9c       	mov	r12,r7
8000aaa4:	e0 a0 08 6a 	rcall	8000bb78 <__i2b>
8000aaa8:	41 1a       	lddsp	r10,sp[0x44]
8000aaaa:	18 92       	mov	r2,r12
8000aaac:	58 0a       	cp.w	r10,0
8000aaae:	e0 8a 00 07 	brle	8000aabc <_dtoa_r+0x850>
8000aab2:	18 9b       	mov	r11,r12
8000aab4:	0e 9c       	mov	r12,r7
8000aab6:	e0 a0 08 a7 	rcall	8000bc04 <__pow5mult>
8000aaba:	18 92       	mov	r2,r12
8000aabc:	40 c9       	lddsp	r9,sp[0x30]
8000aabe:	58 19       	cp.w	r9,1
8000aac0:	e0 89 00 14 	brgt	8000aae8 <_dtoa_r+0x87c>
8000aac4:	40 38       	lddsp	r8,sp[0xc]
8000aac6:	58 08       	cp.w	r8,0
8000aac8:	c1 01       	brne	8000aae8 <_dtoa_r+0x87c>
8000aaca:	40 29       	lddsp	r9,sp[0x8]
8000aacc:	f1 d9 c0 14 	bfextu	r8,r9,0x0,0x14
8000aad0:	c0 c1       	brne	8000aae8 <_dtoa_r+0x87c>
8000aad2:	12 98       	mov	r8,r9
8000aad4:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000aad8:	c0 80       	breq	8000aae8 <_dtoa_r+0x87c>
8000aada:	40 4c       	lddsp	r12,sp[0x10]
8000aadc:	30 1b       	mov	r11,1
8000aade:	2f fc       	sub	r12,-1
8000aae0:	2f f0       	sub	r0,-1
8000aae2:	50 4c       	stdsp	sp[0x10],r12
8000aae4:	50 6b       	stdsp	sp[0x18],r11
8000aae6:	c0 38       	rjmp	8000aaec <_dtoa_r+0x880>
8000aae8:	30 0a       	mov	r10,0
8000aaea:	50 6a       	stdsp	sp[0x18],r10
8000aaec:	41 19       	lddsp	r9,sp[0x44]
8000aaee:	58 09       	cp.w	r9,0
8000aaf0:	c0 31       	brne	8000aaf6 <_dtoa_r+0x88a>
8000aaf2:	30 1c       	mov	r12,1
8000aaf4:	c0 98       	rjmp	8000ab06 <_dtoa_r+0x89a>
8000aaf6:	64 48       	ld.w	r8,r2[0x10]
8000aaf8:	2f c8       	sub	r8,-4
8000aafa:	e4 08 03 2c 	ld.w	r12,r2[r8<<0x2]
8000aafe:	e0 a0 05 df 	rcall	8000b6bc <__hi0bits>
8000ab02:	f8 0c 11 20 	rsub	r12,r12,32
8000ab06:	40 4b       	lddsp	r11,sp[0x10]
8000ab08:	f8 0b 00 08 	add	r8,r12,r11
8000ab0c:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000ab10:	c0 c0       	breq	8000ab28 <_dtoa_r+0x8bc>
8000ab12:	f0 08 11 20 	rsub	r8,r8,32
8000ab16:	58 48       	cp.w	r8,4
8000ab18:	e0 8a 00 06 	brle	8000ab24 <_dtoa_r+0x8b8>
8000ab1c:	20 48       	sub	r8,4
8000ab1e:	10 0b       	add	r11,r8
8000ab20:	50 4b       	stdsp	sp[0x10],r11
8000ab22:	c0 78       	rjmp	8000ab30 <_dtoa_r+0x8c4>
8000ab24:	58 48       	cp.w	r8,4
8000ab26:	c0 70       	breq	8000ab34 <_dtoa_r+0x8c8>
8000ab28:	40 4a       	lddsp	r10,sp[0x10]
8000ab2a:	2e 48       	sub	r8,-28
8000ab2c:	10 0a       	add	r10,r8
8000ab2e:	50 4a       	stdsp	sp[0x10],r10
8000ab30:	10 00       	add	r0,r8
8000ab32:	10 05       	add	r5,r8
8000ab34:	58 00       	cp.w	r0,0
8000ab36:	e0 8a 00 08 	brle	8000ab46 <_dtoa_r+0x8da>
8000ab3a:	06 9b       	mov	r11,r3
8000ab3c:	00 9a       	mov	r10,r0
8000ab3e:	0e 9c       	mov	r12,r7
8000ab40:	e0 a0 07 58 	rcall	8000b9f0 <__lshift>
8000ab44:	18 93       	mov	r3,r12
8000ab46:	40 49       	lddsp	r9,sp[0x10]
8000ab48:	58 09       	cp.w	r9,0
8000ab4a:	e0 8a 00 08 	brle	8000ab5a <_dtoa_r+0x8ee>
8000ab4e:	04 9b       	mov	r11,r2
8000ab50:	12 9a       	mov	r10,r9
8000ab52:	0e 9c       	mov	r12,r7
8000ab54:	e0 a0 07 4e 	rcall	8000b9f0 <__lshift>
8000ab58:	18 92       	mov	r2,r12
8000ab5a:	41 48       	lddsp	r8,sp[0x50]
8000ab5c:	58 08       	cp.w	r8,0
8000ab5e:	c1 b0       	breq	8000ab94 <_dtoa_r+0x928>
8000ab60:	04 9b       	mov	r11,r2
8000ab62:	06 9c       	mov	r12,r3
8000ab64:	e0 a0 06 23 	rcall	8000b7aa <__mcmp>
8000ab68:	c1 64       	brge	8000ab94 <_dtoa_r+0x928>
8000ab6a:	06 9b       	mov	r11,r3
8000ab6c:	30 09       	mov	r9,0
8000ab6e:	30 aa       	mov	r10,10
8000ab70:	0e 9c       	mov	r12,r7
8000ab72:	e0 a0 08 0b 	rcall	8000bb88 <__multadd>
8000ab76:	20 16       	sub	r6,1
8000ab78:	18 93       	mov	r3,r12
8000ab7a:	40 dc       	lddsp	r12,sp[0x34]
8000ab7c:	58 0c       	cp.w	r12,0
8000ab7e:	c0 31       	brne	8000ab84 <_dtoa_r+0x918>
8000ab80:	40 91       	lddsp	r1,sp[0x24]
8000ab82:	c0 98       	rjmp	8000ab94 <_dtoa_r+0x928>
8000ab84:	08 9b       	mov	r11,r4
8000ab86:	40 91       	lddsp	r1,sp[0x24]
8000ab88:	30 09       	mov	r9,0
8000ab8a:	30 aa       	mov	r10,10
8000ab8c:	0e 9c       	mov	r12,r7
8000ab8e:	e0 a0 07 fd 	rcall	8000bb88 <__multadd>
8000ab92:	18 94       	mov	r4,r12
8000ab94:	58 01       	cp.w	r1,0
8000ab96:	5f a9       	srle	r9
8000ab98:	40 cb       	lddsp	r11,sp[0x30]
8000ab9a:	58 2b       	cp.w	r11,2
8000ab9c:	5f 98       	srgt	r8
8000ab9e:	f3 e8 00 08 	and	r8,r9,r8
8000aba2:	c2 50       	breq	8000abec <_dtoa_r+0x980>
8000aba4:	58 01       	cp.w	r1,0
8000aba6:	c1 11       	brne	8000abc8 <_dtoa_r+0x95c>
8000aba8:	04 9b       	mov	r11,r2
8000abaa:	02 99       	mov	r9,r1
8000abac:	30 5a       	mov	r10,5
8000abae:	0e 9c       	mov	r12,r7
8000abb0:	e0 a0 07 ec 	rcall	8000bb88 <__multadd>
8000abb4:	18 92       	mov	r2,r12
8000abb6:	18 9b       	mov	r11,r12
8000abb8:	06 9c       	mov	r12,r3
8000abba:	e0 a0 05 f8 	rcall	8000b7aa <__mcmp>
8000abbe:	e0 89 00 0f 	brgt	8000abdc <_dtoa_r+0x970>
8000abc2:	c0 38       	rjmp	8000abc8 <_dtoa_r+0x95c>
8000abc4:	30 02       	mov	r2,0
8000abc6:	04 94       	mov	r4,r2
8000abc8:	40 ea       	lddsp	r10,sp[0x38]
8000abca:	30 09       	mov	r9,0
8000abcc:	5c da       	com	r10
8000abce:	40 85       	lddsp	r5,sp[0x20]
8000abd0:	50 6a       	stdsp	sp[0x18],r10
8000abd2:	50 49       	stdsp	sp[0x10],r9
8000abd4:	c0 f9       	rjmp	8000adf2 <_dtoa_r+0xb86>
8000abd6:	08 92       	mov	r2,r4
8000abd8:	40 66       	lddsp	r6,sp[0x18]
8000abda:	04 94       	mov	r4,r2
8000abdc:	2f f6       	sub	r6,-1
8000abde:	50 66       	stdsp	sp[0x18],r6
8000abe0:	33 18       	mov	r8,49
8000abe2:	40 85       	lddsp	r5,sp[0x20]
8000abe4:	0a c8       	st.b	r5++,r8
8000abe6:	30 08       	mov	r8,0
8000abe8:	50 48       	stdsp	sp[0x10],r8
8000abea:	c0 49       	rjmp	8000adf2 <_dtoa_r+0xb86>
8000abec:	40 dc       	lddsp	r12,sp[0x34]
8000abee:	58 0c       	cp.w	r12,0
8000abf0:	e0 80 00 b5 	breq	8000ad5a <_dtoa_r+0xaee>
8000abf4:	58 05       	cp.w	r5,0
8000abf6:	e0 8a 00 08 	brle	8000ac06 <_dtoa_r+0x99a>
8000abfa:	08 9b       	mov	r11,r4
8000abfc:	0a 9a       	mov	r10,r5
8000abfe:	0e 9c       	mov	r12,r7
8000ac00:	e0 a0 06 f8 	rcall	8000b9f0 <__lshift>
8000ac04:	18 94       	mov	r4,r12
8000ac06:	40 6b       	lddsp	r11,sp[0x18]
8000ac08:	58 0b       	cp.w	r11,0
8000ac0a:	c0 31       	brne	8000ac10 <_dtoa_r+0x9a4>
8000ac0c:	08 9c       	mov	r12,r4
8000ac0e:	c1 38       	rjmp	8000ac34 <_dtoa_r+0x9c8>
8000ac10:	68 1b       	ld.w	r11,r4[0x4]
8000ac12:	0e 9c       	mov	r12,r7
8000ac14:	e0 a0 05 fe 	rcall	8000b810 <_Balloc>
8000ac18:	68 4a       	ld.w	r10,r4[0x10]
8000ac1a:	18 95       	mov	r5,r12
8000ac1c:	e8 cb ff f4 	sub	r11,r4,-12
8000ac20:	2f ea       	sub	r10,-2
8000ac22:	2f 4c       	sub	r12,-12
8000ac24:	a3 6a       	lsl	r10,0x2
8000ac26:	fe b0 e6 4f 	rcall	800078c4 <memcpy>
8000ac2a:	0a 9b       	mov	r11,r5
8000ac2c:	30 1a       	mov	r10,1
8000ac2e:	0e 9c       	mov	r12,r7
8000ac30:	e0 a0 06 e0 	rcall	8000b9f0 <__lshift>
8000ac34:	50 44       	stdsp	sp[0x10],r4
8000ac36:	40 3a       	lddsp	r10,sp[0xc]
8000ac38:	30 19       	mov	r9,1
8000ac3a:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
8000ac3e:	18 94       	mov	r4,r12
8000ac40:	50 da       	stdsp	sp[0x34],r10
8000ac42:	40 85       	lddsp	r5,sp[0x20]
8000ac44:	50 99       	stdsp	sp[0x24],r9
8000ac46:	50 26       	stdsp	sp[0x8],r6
8000ac48:	50 e1       	stdsp	sp[0x38],r1
8000ac4a:	04 9b       	mov	r11,r2
8000ac4c:	06 9c       	mov	r12,r3
8000ac4e:	fe b0 fa 7f 	rcall	8000a14c <quorem>
8000ac52:	40 4b       	lddsp	r11,sp[0x10]
8000ac54:	f8 c0 ff d0 	sub	r0,r12,-48
8000ac58:	06 9c       	mov	r12,r3
8000ac5a:	e0 a0 05 a8 	rcall	8000b7aa <__mcmp>
8000ac5e:	08 9a       	mov	r10,r4
8000ac60:	50 6c       	stdsp	sp[0x18],r12
8000ac62:	04 9b       	mov	r11,r2
8000ac64:	0e 9c       	mov	r12,r7
8000ac66:	e0 a0 06 5d 	rcall	8000b920 <__mdiff>
8000ac6a:	18 91       	mov	r1,r12
8000ac6c:	78 38       	ld.w	r8,r12[0xc]
8000ac6e:	58 08       	cp.w	r8,0
8000ac70:	c0 30       	breq	8000ac76 <_dtoa_r+0xa0a>
8000ac72:	30 16       	mov	r6,1
8000ac74:	c0 68       	rjmp	8000ac80 <_dtoa_r+0xa14>
8000ac76:	18 9b       	mov	r11,r12
8000ac78:	06 9c       	mov	r12,r3
8000ac7a:	e0 a0 05 98 	rcall	8000b7aa <__mcmp>
8000ac7e:	18 96       	mov	r6,r12
8000ac80:	0e 9c       	mov	r12,r7
8000ac82:	02 9b       	mov	r11,r1
8000ac84:	e0 a0 05 ac 	rcall	8000b7dc <_Bfree>
8000ac88:	40 cc       	lddsp	r12,sp[0x30]
8000ac8a:	ed ec 10 08 	or	r8,r6,r12
8000ac8e:	c0 d1       	brne	8000aca8 <_dtoa_r+0xa3c>
8000ac90:	40 db       	lddsp	r11,sp[0x34]
8000ac92:	58 0b       	cp.w	r11,0
8000ac94:	c0 a1       	brne	8000aca8 <_dtoa_r+0xa3c>
8000ac96:	40 26       	lddsp	r6,sp[0x8]
8000ac98:	e0 40 00 39 	cp.w	r0,57
8000ac9c:	c3 00       	breq	8000acfc <_dtoa_r+0xa90>
8000ac9e:	40 6a       	lddsp	r10,sp[0x18]
8000aca0:	58 0a       	cp.w	r10,0
8000aca2:	e0 89 00 24 	brgt	8000acea <_dtoa_r+0xa7e>
8000aca6:	c2 f8       	rjmp	8000ad04 <_dtoa_r+0xa98>
8000aca8:	40 69       	lddsp	r9,sp[0x18]
8000acaa:	58 09       	cp.w	r9,0
8000acac:	c0 85       	brlt	8000acbc <_dtoa_r+0xa50>
8000acae:	12 98       	mov	r8,r9
8000acb0:	40 cc       	lddsp	r12,sp[0x30]
8000acb2:	18 48       	or	r8,r12
8000acb4:	c1 d1       	brne	8000acee <_dtoa_r+0xa82>
8000acb6:	40 db       	lddsp	r11,sp[0x34]
8000acb8:	58 0b       	cp.w	r11,0
8000acba:	c1 a1       	brne	8000acee <_dtoa_r+0xa82>
8000acbc:	0c 99       	mov	r9,r6
8000acbe:	40 26       	lddsp	r6,sp[0x8]
8000acc0:	58 09       	cp.w	r9,0
8000acc2:	e0 8a 00 21 	brle	8000ad04 <_dtoa_r+0xa98>
8000acc6:	06 9b       	mov	r11,r3
8000acc8:	30 1a       	mov	r10,1
8000acca:	0e 9c       	mov	r12,r7
8000accc:	e0 a0 06 92 	rcall	8000b9f0 <__lshift>
8000acd0:	04 9b       	mov	r11,r2
8000acd2:	18 93       	mov	r3,r12
8000acd4:	e0 a0 05 6b 	rcall	8000b7aa <__mcmp>
8000acd8:	e0 89 00 06 	brgt	8000ace4 <_dtoa_r+0xa78>
8000acdc:	c1 41       	brne	8000ad04 <_dtoa_r+0xa98>
8000acde:	ed b0 00 00 	bld	r0,0x0
8000ace2:	c1 11       	brne	8000ad04 <_dtoa_r+0xa98>
8000ace4:	e0 40 00 39 	cp.w	r0,57
8000ace8:	c0 a0       	breq	8000acfc <_dtoa_r+0xa90>
8000acea:	2f f0       	sub	r0,-1
8000acec:	c0 c8       	rjmp	8000ad04 <_dtoa_r+0xa98>
8000acee:	58 06       	cp.w	r6,0
8000acf0:	e0 8a 00 0c 	brle	8000ad08 <_dtoa_r+0xa9c>
8000acf4:	40 26       	lddsp	r6,sp[0x8]
8000acf6:	e0 40 00 39 	cp.w	r0,57
8000acfa:	c0 41       	brne	8000ad02 <_dtoa_r+0xa96>
8000acfc:	33 98       	mov	r8,57
8000acfe:	0a c8       	st.b	r5++,r8
8000ad00:	c6 78       	rjmp	8000adce <_dtoa_r+0xb62>
8000ad02:	2f f0       	sub	r0,-1
8000ad04:	0a c0       	st.b	r5++,r0
8000ad06:	c7 58       	rjmp	8000adf0 <_dtoa_r+0xb84>
8000ad08:	0a c0       	st.b	r5++,r0
8000ad0a:	40 9a       	lddsp	r10,sp[0x24]
8000ad0c:	40 e9       	lddsp	r9,sp[0x38]
8000ad0e:	12 3a       	cp.w	r10,r9
8000ad10:	c4 30       	breq	8000ad96 <_dtoa_r+0xb2a>
8000ad12:	06 9b       	mov	r11,r3
8000ad14:	30 09       	mov	r9,0
8000ad16:	30 aa       	mov	r10,10
8000ad18:	0e 9c       	mov	r12,r7
8000ad1a:	e0 a0 07 37 	rcall	8000bb88 <__multadd>
8000ad1e:	40 48       	lddsp	r8,sp[0x10]
8000ad20:	18 93       	mov	r3,r12
8000ad22:	08 38       	cp.w	r8,r4
8000ad24:	c0 91       	brne	8000ad36 <_dtoa_r+0xaca>
8000ad26:	10 9b       	mov	r11,r8
8000ad28:	30 09       	mov	r9,0
8000ad2a:	30 aa       	mov	r10,10
8000ad2c:	0e 9c       	mov	r12,r7
8000ad2e:	e0 a0 07 2d 	rcall	8000bb88 <__multadd>
8000ad32:	50 4c       	stdsp	sp[0x10],r12
8000ad34:	c0 e8       	rjmp	8000ad50 <_dtoa_r+0xae4>
8000ad36:	40 4b       	lddsp	r11,sp[0x10]
8000ad38:	30 09       	mov	r9,0
8000ad3a:	30 aa       	mov	r10,10
8000ad3c:	0e 9c       	mov	r12,r7
8000ad3e:	e0 a0 07 25 	rcall	8000bb88 <__multadd>
8000ad42:	08 9b       	mov	r11,r4
8000ad44:	50 4c       	stdsp	sp[0x10],r12
8000ad46:	30 09       	mov	r9,0
8000ad48:	30 aa       	mov	r10,10
8000ad4a:	0e 9c       	mov	r12,r7
8000ad4c:	e0 a0 07 1e 	rcall	8000bb88 <__multadd>
8000ad50:	18 94       	mov	r4,r12
8000ad52:	40 9c       	lddsp	r12,sp[0x24]
8000ad54:	2f fc       	sub	r12,-1
8000ad56:	50 9c       	stdsp	sp[0x24],r12
8000ad58:	c7 9b       	rjmp	8000ac4a <_dtoa_r+0x9de>
8000ad5a:	30 18       	mov	r8,1
8000ad5c:	06 90       	mov	r0,r3
8000ad5e:	40 85       	lddsp	r5,sp[0x20]
8000ad60:	08 93       	mov	r3,r4
8000ad62:	0c 94       	mov	r4,r6
8000ad64:	10 96       	mov	r6,r8
8000ad66:	04 9b       	mov	r11,r2
8000ad68:	00 9c       	mov	r12,r0
8000ad6a:	fe b0 f9 f1 	rcall	8000a14c <quorem>
8000ad6e:	2d 0c       	sub	r12,-48
8000ad70:	0a cc       	st.b	r5++,r12
8000ad72:	02 36       	cp.w	r6,r1
8000ad74:	c0 a4       	brge	8000ad88 <_dtoa_r+0xb1c>
8000ad76:	00 9b       	mov	r11,r0
8000ad78:	30 09       	mov	r9,0
8000ad7a:	30 aa       	mov	r10,10
8000ad7c:	0e 9c       	mov	r12,r7
8000ad7e:	2f f6       	sub	r6,-1
8000ad80:	e0 a0 07 04 	rcall	8000bb88 <__multadd>
8000ad84:	18 90       	mov	r0,r12
8000ad86:	cf 0b       	rjmp	8000ad66 <_dtoa_r+0xafa>
8000ad88:	08 96       	mov	r6,r4
8000ad8a:	30 0b       	mov	r11,0
8000ad8c:	06 94       	mov	r4,r3
8000ad8e:	50 4b       	stdsp	sp[0x10],r11
8000ad90:	00 93       	mov	r3,r0
8000ad92:	18 90       	mov	r0,r12
8000ad94:	c0 28       	rjmp	8000ad98 <_dtoa_r+0xb2c>
8000ad96:	40 26       	lddsp	r6,sp[0x8]
8000ad98:	06 9b       	mov	r11,r3
8000ad9a:	30 1a       	mov	r10,1
8000ad9c:	0e 9c       	mov	r12,r7
8000ad9e:	e0 a0 06 29 	rcall	8000b9f0 <__lshift>
8000ada2:	04 9b       	mov	r11,r2
8000ada4:	18 93       	mov	r3,r12
8000ada6:	e0 a0 05 02 	rcall	8000b7aa <__mcmp>
8000adaa:	e0 89 00 12 	brgt	8000adce <_dtoa_r+0xb62>
8000adae:	c1 b1       	brne	8000ade4 <_dtoa_r+0xb78>
8000adb0:	e1 d0 c0 01 	bfextu	r0,r0,0x0,0x1
8000adb4:	c0 d1       	brne	8000adce <_dtoa_r+0xb62>
8000adb6:	c1 78       	rjmp	8000ade4 <_dtoa_r+0xb78>
8000adb8:	40 89       	lddsp	r9,sp[0x20]
8000adba:	12 38       	cp.w	r8,r9
8000adbc:	c0 30       	breq	8000adc2 <_dtoa_r+0xb56>
8000adbe:	10 95       	mov	r5,r8
8000adc0:	c0 88       	rjmp	8000add0 <_dtoa_r+0xb64>
8000adc2:	2f f6       	sub	r6,-1
8000adc4:	50 66       	stdsp	sp[0x18],r6
8000adc6:	33 18       	mov	r8,49
8000adc8:	40 8c       	lddsp	r12,sp[0x20]
8000adca:	b8 88       	st.b	r12[0x0],r8
8000adcc:	c1 38       	rjmp	8000adf2 <_dtoa_r+0xb86>
8000adce:	33 9a       	mov	r10,57
8000add0:	0a 98       	mov	r8,r5
8000add2:	11 79       	ld.ub	r9,--r8
8000add4:	f4 09 18 00 	cp.b	r9,r10
8000add8:	cf 00       	breq	8000adb8 <_dtoa_r+0xb4c>
8000adda:	2f f9       	sub	r9,-1
8000addc:	b0 89       	st.b	r8[0x0],r9
8000adde:	c0 98       	rjmp	8000adf0 <_dtoa_r+0xb84>
8000ade0:	10 95       	mov	r5,r8
8000ade2:	c0 28       	rjmp	8000ade6 <_dtoa_r+0xb7a>
8000ade4:	33 09       	mov	r9,48
8000ade6:	0a 98       	mov	r8,r5
8000ade8:	11 7a       	ld.ub	r10,--r8
8000adea:	f2 0a 18 00 	cp.b	r10,r9
8000adee:	cf 90       	breq	8000ade0 <_dtoa_r+0xb74>
8000adf0:	50 66       	stdsp	sp[0x18],r6
8000adf2:	04 9b       	mov	r11,r2
8000adf4:	0e 9c       	mov	r12,r7
8000adf6:	e0 a0 04 f3 	rcall	8000b7dc <_Bfree>
8000adfa:	58 04       	cp.w	r4,0
8000adfc:	c1 20       	breq	8000ae20 <_dtoa_r+0xbb4>
8000adfe:	40 4b       	lddsp	r11,sp[0x10]
8000ae00:	08 3b       	cp.w	r11,r4
8000ae02:	5f 19       	srne	r9
8000ae04:	58 0b       	cp.w	r11,0
8000ae06:	5f 18       	srne	r8
8000ae08:	f3 e8 00 08 	and	r8,r9,r8
8000ae0c:	c0 40       	breq	8000ae14 <_dtoa_r+0xba8>
8000ae0e:	0e 9c       	mov	r12,r7
8000ae10:	e0 a0 04 e6 	rcall	8000b7dc <_Bfree>
8000ae14:	08 9b       	mov	r11,r4
8000ae16:	0e 9c       	mov	r12,r7
8000ae18:	e0 a0 04 e2 	rcall	8000b7dc <_Bfree>
8000ae1c:	c0 28       	rjmp	8000ae20 <_dtoa_r+0xbb4>
8000ae1e:	50 66       	stdsp	sp[0x18],r6
8000ae20:	0e 9c       	mov	r12,r7
8000ae22:	06 9b       	mov	r11,r3
8000ae24:	e0 a0 04 dc 	rcall	8000b7dc <_Bfree>
8000ae28:	30 08       	mov	r8,0
8000ae2a:	aa 88       	st.b	r5[0x0],r8
8000ae2c:	40 68       	lddsp	r8,sp[0x18]
8000ae2e:	41 5a       	lddsp	r10,sp[0x54]
8000ae30:	2f f8       	sub	r8,-1
8000ae32:	41 29       	lddsp	r9,sp[0x48]
8000ae34:	95 08       	st.w	r10[0x0],r8
8000ae36:	40 8c       	lddsp	r12,sp[0x20]
8000ae38:	58 09       	cp.w	r9,0
8000ae3a:	fb f8 10 12 	ld.wne	r8,sp[0x48]
8000ae3e:	f1 f5 1a 00 	st.wne	r8[0x0],r5
8000ae42:	2e 6d       	sub	sp,-104
8000ae44:	d8 32       	popm	r0-r7,pc
8000ae46:	d7 03       	nop

8000ae48 <__errno>:
8000ae48:	e0 68 0a 3c 	mov	r8,2620
8000ae4c:	70 0c       	ld.w	r12,r8[0x0]
8000ae4e:	2f 4c       	sub	r12,-12
8000ae50:	5e fc       	retal	r12
8000ae52:	d7 03       	nop

8000ae54 <_fflush_r>:
8000ae54:	d4 21       	pushm	r4-r7,lr
8000ae56:	16 97       	mov	r7,r11
8000ae58:	18 96       	mov	r6,r12
8000ae5a:	76 48       	ld.w	r8,r11[0x10]
8000ae5c:	58 08       	cp.w	r8,0
8000ae5e:	c7 f0       	breq	8000af5c <_fflush_r+0x108>
8000ae60:	58 0c       	cp.w	r12,0
8000ae62:	c0 50       	breq	8000ae6c <_fflush_r+0x18>
8000ae64:	78 68       	ld.w	r8,r12[0x18]
8000ae66:	58 08       	cp.w	r8,0
8000ae68:	c0 21       	brne	8000ae6c <_fflush_r+0x18>
8000ae6a:	cc dc       	rcall	8000b004 <__sinit>
8000ae6c:	fe c8 cd 44 	sub	r8,pc,-12988
8000ae70:	10 37       	cp.w	r7,r8
8000ae72:	c0 31       	brne	8000ae78 <_fflush_r+0x24>
8000ae74:	6c 07       	ld.w	r7,r6[0x0]
8000ae76:	c0 c8       	rjmp	8000ae8e <_fflush_r+0x3a>
8000ae78:	fe c8 cd 30 	sub	r8,pc,-13008
8000ae7c:	10 37       	cp.w	r7,r8
8000ae7e:	c0 31       	brne	8000ae84 <_fflush_r+0x30>
8000ae80:	6c 17       	ld.w	r7,r6[0x4]
8000ae82:	c0 68       	rjmp	8000ae8e <_fflush_r+0x3a>
8000ae84:	fe c8 cd 1c 	sub	r8,pc,-13028
8000ae88:	10 37       	cp.w	r7,r8
8000ae8a:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000ae8e:	8e 6a       	ld.sh	r10,r7[0xc]
8000ae90:	14 98       	mov	r8,r10
8000ae92:	ed ba 00 03 	bld	r10,0x3
8000ae96:	c4 20       	breq	8000af1a <_fflush_r+0xc6>
8000ae98:	ab ba       	sbr	r10,0xb
8000ae9a:	ae 6a       	st.h	r7[0xc],r10
8000ae9c:	6e 18       	ld.w	r8,r7[0x4]
8000ae9e:	58 08       	cp.w	r8,0
8000aea0:	e0 89 00 06 	brgt	8000aeac <_fflush_r+0x58>
8000aea4:	6f 08       	ld.w	r8,r7[0x40]
8000aea6:	58 08       	cp.w	r8,0
8000aea8:	e0 8a 00 5a 	brle	8000af5c <_fflush_r+0x108>
8000aeac:	6e b8       	ld.w	r8,r7[0x2c]
8000aeae:	58 08       	cp.w	r8,0
8000aeb0:	c5 60       	breq	8000af5c <_fflush_r+0x108>
8000aeb2:	e2 1a 10 00 	andl	r10,0x1000,COH
8000aeb6:	c0 30       	breq	8000aebc <_fflush_r+0x68>
8000aeb8:	6f 55       	ld.w	r5,r7[0x54]
8000aeba:	c0 f8       	rjmp	8000aed8 <_fflush_r+0x84>
8000aebc:	30 19       	mov	r9,1
8000aebe:	6e 8b       	ld.w	r11,r7[0x20]
8000aec0:	0c 9c       	mov	r12,r6
8000aec2:	5d 18       	icall	r8
8000aec4:	18 95       	mov	r5,r12
8000aec6:	5b fc       	cp.w	r12,-1
8000aec8:	c0 81       	brne	8000aed8 <_fflush_r+0x84>
8000aeca:	6c 38       	ld.w	r8,r6[0xc]
8000aecc:	59 d8       	cp.w	r8,29
8000aece:	c4 70       	breq	8000af5c <_fflush_r+0x108>
8000aed0:	8e 68       	ld.sh	r8,r7[0xc]
8000aed2:	a7 a8       	sbr	r8,0x6
8000aed4:	ae 68       	st.h	r7[0xc],r8
8000aed6:	d8 22       	popm	r4-r7,pc
8000aed8:	8e 68       	ld.sh	r8,r7[0xc]
8000aeda:	ed b8 00 02 	bld	r8,0x2
8000aede:	c0 91       	brne	8000aef0 <_fflush_r+0x9c>
8000aee0:	6e 18       	ld.w	r8,r7[0x4]
8000aee2:	10 15       	sub	r5,r8
8000aee4:	6e d8       	ld.w	r8,r7[0x34]
8000aee6:	58 08       	cp.w	r8,0
8000aee8:	ef f8 10 10 	ld.wne	r8,r7[0x40]
8000aeec:	eb d8 e1 15 	subne	r5,r5,r8
8000aef0:	6e b8       	ld.w	r8,r7[0x2c]
8000aef2:	0c 9c       	mov	r12,r6
8000aef4:	30 09       	mov	r9,0
8000aef6:	0a 9a       	mov	r10,r5
8000aef8:	6e 8b       	ld.w	r11,r7[0x20]
8000aefa:	5d 18       	icall	r8
8000aefc:	8e 68       	ld.sh	r8,r7[0xc]
8000aefe:	0a 3c       	cp.w	r12,r5
8000af00:	c2 61       	brne	8000af4c <_fflush_r+0xf8>
8000af02:	ab d8       	cbr	r8,0xb
8000af04:	30 0c       	mov	r12,0
8000af06:	6e 49       	ld.w	r9,r7[0x10]
8000af08:	ae 68       	st.h	r7[0xc],r8
8000af0a:	8f 1c       	st.w	r7[0x4],r12
8000af0c:	8f 09       	st.w	r7[0x0],r9
8000af0e:	ed b8 00 0c 	bld	r8,0xc
8000af12:	c2 51       	brne	8000af5c <_fflush_r+0x108>
8000af14:	ef 45 00 54 	st.w	r7[84],r5
8000af18:	d8 22       	popm	r4-r7,pc
8000af1a:	6e 45       	ld.w	r5,r7[0x10]
8000af1c:	58 05       	cp.w	r5,0
8000af1e:	c1 f0       	breq	8000af5c <_fflush_r+0x108>
8000af20:	6e 04       	ld.w	r4,r7[0x0]
8000af22:	f5 da c0 02 	bfextu	r10,r10,0x0,0x2
8000af26:	8f 05       	st.w	r7[0x0],r5
8000af28:	f9 b8 01 00 	movne	r8,0
8000af2c:	ef f8 00 05 	ld.weq	r8,r7[0x14]
8000af30:	0a 14       	sub	r4,r5
8000af32:	8f 28       	st.w	r7[0x8],r8
8000af34:	c1 18       	rjmp	8000af56 <_fflush_r+0x102>
8000af36:	08 99       	mov	r9,r4
8000af38:	0a 9a       	mov	r10,r5
8000af3a:	6e a8       	ld.w	r8,r7[0x28]
8000af3c:	6e 8b       	ld.w	r11,r7[0x20]
8000af3e:	0c 9c       	mov	r12,r6
8000af40:	5d 18       	icall	r8
8000af42:	18 14       	sub	r4,r12
8000af44:	58 0c       	cp.w	r12,0
8000af46:	e0 89 00 07 	brgt	8000af54 <_fflush_r+0x100>
8000af4a:	8e 68       	ld.sh	r8,r7[0xc]
8000af4c:	a7 a8       	sbr	r8,0x6
8000af4e:	3f fc       	mov	r12,-1
8000af50:	ae 68       	st.h	r7[0xc],r8
8000af52:	d8 22       	popm	r4-r7,pc
8000af54:	18 05       	add	r5,r12
8000af56:	58 04       	cp.w	r4,0
8000af58:	fe 99 ff ef 	brgt	8000af36 <_fflush_r+0xe2>
8000af5c:	d8 2a       	popm	r4-r7,pc,r12=0
8000af5e:	d7 03       	nop

8000af60 <__sfp_lock_acquire>:
8000af60:	5e fc       	retal	r12

8000af62 <__sfp_lock_release>:
8000af62:	5e fc       	retal	r12

8000af64 <_cleanup_r>:
8000af64:	d4 01       	pushm	lr
8000af66:	fe cb f0 ae 	sub	r11,pc,-3922
8000af6a:	e0 a0 02 f7 	rcall	8000b558 <_fwalk>
8000af6e:	d8 02       	popm	pc

8000af70 <__sfmoreglue>:
8000af70:	d4 21       	pushm	r4-r7,lr
8000af72:	16 95       	mov	r5,r11
8000af74:	f6 06 10 5c 	mul	r6,r11,92
8000af78:	ec cb ff f4 	sub	r11,r6,-12
8000af7c:	fe b0 e2 88 	rcall	8000748c <_malloc_r>
8000af80:	18 97       	mov	r7,r12
8000af82:	c0 90       	breq	8000af94 <__sfmoreglue+0x24>
8000af84:	99 15       	st.w	r12[0x4],r5
8000af86:	30 0b       	mov	r11,0
8000af88:	2f 4c       	sub	r12,-12
8000af8a:	0c 9a       	mov	r10,r6
8000af8c:	8f 2c       	st.w	r7[0x8],r12
8000af8e:	8f 0b       	st.w	r7[0x0],r11
8000af90:	fe b0 e5 3e 	rcall	80007a0c <memset>
8000af94:	0e 9c       	mov	r12,r7
8000af96:	d8 22       	popm	r4-r7,pc

8000af98 <__sfp>:
8000af98:	d4 21       	pushm	r4-r7,lr
8000af9a:	fe c8 ce 0e 	sub	r8,pc,-12786
8000af9e:	18 96       	mov	r6,r12
8000afa0:	70 07       	ld.w	r7,r8[0x0]
8000afa2:	6e 68       	ld.w	r8,r7[0x18]
8000afa4:	58 08       	cp.w	r8,0
8000afa6:	c0 31       	brne	8000afac <__sfp+0x14>
8000afa8:	0e 9c       	mov	r12,r7
8000afaa:	c2 dc       	rcall	8000b004 <__sinit>
8000afac:	ee c7 ff 28 	sub	r7,r7,-216
8000afb0:	30 05       	mov	r5,0
8000afb2:	6e 2c       	ld.w	r12,r7[0x8]
8000afb4:	6e 18       	ld.w	r8,r7[0x4]
8000afb6:	c0 68       	rjmp	8000afc2 <__sfp+0x2a>
8000afb8:	98 69       	ld.sh	r9,r12[0xc]
8000afba:	ea 09 19 00 	cp.h	r9,r5
8000afbe:	c1 10       	breq	8000afe0 <__sfp+0x48>
8000afc0:	2a 4c       	sub	r12,-92
8000afc2:	20 18       	sub	r8,1
8000afc4:	cf a7       	brpl	8000afb8 <__sfp+0x20>
8000afc6:	6e 08       	ld.w	r8,r7[0x0]
8000afc8:	58 08       	cp.w	r8,0
8000afca:	c0 61       	brne	8000afd6 <__sfp+0x3e>
8000afcc:	30 4b       	mov	r11,4
8000afce:	0c 9c       	mov	r12,r6
8000afd0:	cd 0f       	rcall	8000af70 <__sfmoreglue>
8000afd2:	8f 0c       	st.w	r7[0x0],r12
8000afd4:	c0 30       	breq	8000afda <__sfp+0x42>
8000afd6:	6e 07       	ld.w	r7,r7[0x0]
8000afd8:	ce db       	rjmp	8000afb2 <__sfp+0x1a>
8000afda:	30 c8       	mov	r8,12
8000afdc:	8d 38       	st.w	r6[0xc],r8
8000afde:	d8 22       	popm	r4-r7,pc
8000afe0:	30 08       	mov	r8,0
8000afe2:	f9 48 00 4c 	st.w	r12[76],r8
8000afe6:	99 08       	st.w	r12[0x0],r8
8000afe8:	99 28       	st.w	r12[0x8],r8
8000afea:	99 18       	st.w	r12[0x4],r8
8000afec:	99 48       	st.w	r12[0x10],r8
8000afee:	99 58       	st.w	r12[0x14],r8
8000aff0:	99 68       	st.w	r12[0x18],r8
8000aff2:	99 d8       	st.w	r12[0x34],r8
8000aff4:	99 e8       	st.w	r12[0x38],r8
8000aff6:	f9 48 00 48 	st.w	r12[72],r8
8000affa:	3f f8       	mov	r8,-1
8000affc:	b8 78       	st.h	r12[0xe],r8
8000affe:	30 18       	mov	r8,1
8000b000:	b8 68       	st.h	r12[0xc],r8
8000b002:	d8 22       	popm	r4-r7,pc

8000b004 <__sinit>:
8000b004:	d4 21       	pushm	r4-r7,lr
8000b006:	18 96       	mov	r6,r12
8000b008:	78 67       	ld.w	r7,r12[0x18]
8000b00a:	58 07       	cp.w	r7,0
8000b00c:	c4 91       	brne	8000b09e <__sinit+0x9a>
8000b00e:	fe c8 00 aa 	sub	r8,pc,170
8000b012:	30 15       	mov	r5,1
8000b014:	99 a8       	st.w	r12[0x28],r8
8000b016:	f9 47 00 d8 	st.w	r12[216],r7
8000b01a:	f9 47 00 dc 	st.w	r12[220],r7
8000b01e:	f9 47 00 e0 	st.w	r12[224],r7
8000b022:	99 65       	st.w	r12[0x18],r5
8000b024:	cb af       	rcall	8000af98 <__sfp>
8000b026:	8d 0c       	st.w	r6[0x0],r12
8000b028:	0c 9c       	mov	r12,r6
8000b02a:	cb 7f       	rcall	8000af98 <__sfp>
8000b02c:	8d 1c       	st.w	r6[0x4],r12
8000b02e:	0c 9c       	mov	r12,r6
8000b030:	cb 4f       	rcall	8000af98 <__sfp>
8000b032:	6c 09       	ld.w	r9,r6[0x0]
8000b034:	30 48       	mov	r8,4
8000b036:	93 07       	st.w	r9[0x0],r7
8000b038:	b2 68       	st.h	r9[0xc],r8
8000b03a:	93 17       	st.w	r9[0x4],r7
8000b03c:	93 27       	st.w	r9[0x8],r7
8000b03e:	6c 18       	ld.w	r8,r6[0x4]
8000b040:	b2 77       	st.h	r9[0xe],r7
8000b042:	93 47       	st.w	r9[0x10],r7
8000b044:	93 57       	st.w	r9[0x14],r7
8000b046:	93 67       	st.w	r9[0x18],r7
8000b048:	93 89       	st.w	r9[0x20],r9
8000b04a:	91 07       	st.w	r8[0x0],r7
8000b04c:	91 17       	st.w	r8[0x4],r7
8000b04e:	91 27       	st.w	r8[0x8],r7
8000b050:	fe ce f3 24 	sub	lr,pc,-3292
8000b054:	fe cb f3 54 	sub	r11,pc,-3244
8000b058:	93 9e       	st.w	r9[0x24],lr
8000b05a:	93 ab       	st.w	r9[0x28],r11
8000b05c:	fe ca f3 7c 	sub	r10,pc,-3204
8000b060:	fe c4 f3 88 	sub	r4,pc,-3192
8000b064:	93 ba       	st.w	r9[0x2c],r10
8000b066:	93 c4       	st.w	r9[0x30],r4
8000b068:	30 99       	mov	r9,9
8000b06a:	b0 69       	st.h	r8[0xc],r9
8000b06c:	b0 75       	st.h	r8[0xe],r5
8000b06e:	91 c4       	st.w	r8[0x30],r4
8000b070:	91 47       	st.w	r8[0x10],r7
8000b072:	91 57       	st.w	r8[0x14],r7
8000b074:	91 67       	st.w	r8[0x18],r7
8000b076:	91 88       	st.w	r8[0x20],r8
8000b078:	91 9e       	st.w	r8[0x24],lr
8000b07a:	91 ab       	st.w	r8[0x28],r11
8000b07c:	91 ba       	st.w	r8[0x2c],r10
8000b07e:	8d 2c       	st.w	r6[0x8],r12
8000b080:	31 28       	mov	r8,18
8000b082:	99 07       	st.w	r12[0x0],r7
8000b084:	b8 68       	st.h	r12[0xc],r8
8000b086:	99 17       	st.w	r12[0x4],r7
8000b088:	99 27       	st.w	r12[0x8],r7
8000b08a:	30 28       	mov	r8,2
8000b08c:	b8 78       	st.h	r12[0xe],r8
8000b08e:	99 c4       	st.w	r12[0x30],r4
8000b090:	99 67       	st.w	r12[0x18],r7
8000b092:	99 9e       	st.w	r12[0x24],lr
8000b094:	99 ab       	st.w	r12[0x28],r11
8000b096:	99 ba       	st.w	r12[0x2c],r10
8000b098:	99 47       	st.w	r12[0x10],r7
8000b09a:	99 57       	st.w	r12[0x14],r7
8000b09c:	99 8c       	st.w	r12[0x20],r12
8000b09e:	d8 22       	popm	r4-r7,pc

8000b0a0 <_malloc_trim_r>:
8000b0a0:	d4 21       	pushm	r4-r7,lr
8000b0a2:	16 95       	mov	r5,r11
8000b0a4:	18 97       	mov	r7,r12
8000b0a6:	fe b0 d7 ad 	rcall	80006000 <__malloc_lock>
8000b0aa:	e0 64 05 3c 	mov	r4,1340
8000b0ae:	68 28       	ld.w	r8,r4[0x8]
8000b0b0:	70 16       	ld.w	r6,r8[0x4]
8000b0b2:	e0 16 ff fc 	andl	r6,0xfffc
8000b0b6:	ec c8 ff 91 	sub	r8,r6,-111
8000b0ba:	f0 05 01 05 	sub	r5,r8,r5
8000b0be:	e0 15 ff 80 	andl	r5,0xff80
8000b0c2:	ea c5 00 80 	sub	r5,r5,128
8000b0c6:	e0 45 00 7f 	cp.w	r5,127
8000b0ca:	e0 8a 00 25 	brle	8000b114 <_malloc_trim_r+0x74>
8000b0ce:	30 0b       	mov	r11,0
8000b0d0:	0e 9c       	mov	r12,r7
8000b0d2:	fe b0 e6 05 	rcall	80007cdc <_sbrk_r>
8000b0d6:	68 28       	ld.w	r8,r4[0x8]
8000b0d8:	0c 08       	add	r8,r6
8000b0da:	10 3c       	cp.w	r12,r8
8000b0dc:	c1 c1       	brne	8000b114 <_malloc_trim_r+0x74>
8000b0de:	ea 0b 11 00 	rsub	r11,r5,0
8000b0e2:	0e 9c       	mov	r12,r7
8000b0e4:	fe b0 e5 fc 	rcall	80007cdc <_sbrk_r>
8000b0e8:	5b fc       	cp.w	r12,-1
8000b0ea:	c1 91       	brne	8000b11c <_malloc_trim_r+0x7c>
8000b0ec:	30 0b       	mov	r11,0
8000b0ee:	0e 9c       	mov	r12,r7
8000b0f0:	fe b0 e5 f6 	rcall	80007cdc <_sbrk_r>
8000b0f4:	68 28       	ld.w	r8,r4[0x8]
8000b0f6:	f8 08 01 09 	sub	r9,r12,r8
8000b0fa:	58 f9       	cp.w	r9,15
8000b0fc:	e0 8a 00 0c 	brle	8000b114 <_malloc_trim_r+0x74>
8000b100:	a1 a9       	sbr	r9,0x0
8000b102:	91 19       	st.w	r8[0x4],r9
8000b104:	e0 68 09 48 	mov	r8,2376
8000b108:	70 09       	ld.w	r9,r8[0x0]
8000b10a:	e0 68 0d 70 	mov	r8,3440
8000b10e:	f8 09 01 09 	sub	r9,r12,r9
8000b112:	91 09       	st.w	r8[0x0],r9
8000b114:	0e 9c       	mov	r12,r7
8000b116:	fe b0 d7 7b 	rcall	8000600c <__malloc_unlock>
8000b11a:	d8 2a       	popm	r4-r7,pc,r12=0
8000b11c:	68 28       	ld.w	r8,r4[0x8]
8000b11e:	0a 16       	sub	r6,r5
8000b120:	a1 a6       	sbr	r6,0x0
8000b122:	91 16       	st.w	r8[0x4],r6
8000b124:	e0 68 0d 70 	mov	r8,3440
8000b128:	70 09       	ld.w	r9,r8[0x0]
8000b12a:	0a 19       	sub	r9,r5
8000b12c:	0e 9c       	mov	r12,r7
8000b12e:	91 09       	st.w	r8[0x0],r9
8000b130:	fe b0 d7 6e 	rcall	8000600c <__malloc_unlock>
8000b134:	da 2a       	popm	r4-r7,pc,r12=1
8000b136:	d7 03       	nop

8000b138 <_free_r>:
8000b138:	d4 21       	pushm	r4-r7,lr
8000b13a:	16 96       	mov	r6,r11
8000b13c:	18 97       	mov	r7,r12
8000b13e:	58 0b       	cp.w	r11,0
8000b140:	e0 80 00 c0 	breq	8000b2c0 <_free_r+0x188>
8000b144:	fe b0 d7 5e 	rcall	80006000 <__malloc_lock>
8000b148:	20 86       	sub	r6,8
8000b14a:	e0 6a 05 3c 	mov	r10,1340
8000b14e:	6c 18       	ld.w	r8,r6[0x4]
8000b150:	74 2e       	ld.w	lr,r10[0x8]
8000b152:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
8000b156:	a1 c8       	cbr	r8,0x0
8000b158:	ec 08 00 09 	add	r9,r6,r8
8000b15c:	72 1b       	ld.w	r11,r9[0x4]
8000b15e:	e0 1b ff fc 	andl	r11,0xfffc
8000b162:	1c 39       	cp.w	r9,lr
8000b164:	c1 e1       	brne	8000b1a0 <_free_r+0x68>
8000b166:	f6 08 00 08 	add	r8,r11,r8
8000b16a:	58 0c       	cp.w	r12,0
8000b16c:	c0 81       	brne	8000b17c <_free_r+0x44>
8000b16e:	6c 09       	ld.w	r9,r6[0x0]
8000b170:	12 16       	sub	r6,r9
8000b172:	12 08       	add	r8,r9
8000b174:	6c 3b       	ld.w	r11,r6[0xc]
8000b176:	6c 29       	ld.w	r9,r6[0x8]
8000b178:	97 29       	st.w	r11[0x8],r9
8000b17a:	93 3b       	st.w	r9[0xc],r11
8000b17c:	10 99       	mov	r9,r8
8000b17e:	95 26       	st.w	r10[0x8],r6
8000b180:	a1 a9       	sbr	r9,0x0
8000b182:	8d 19       	st.w	r6[0x4],r9
8000b184:	e0 69 09 44 	mov	r9,2372
8000b188:	72 09       	ld.w	r9,r9[0x0]
8000b18a:	12 38       	cp.w	r8,r9
8000b18c:	c0 63       	brcs	8000b198 <_free_r+0x60>
8000b18e:	e0 68 0d 6c 	mov	r8,3436
8000b192:	0e 9c       	mov	r12,r7
8000b194:	70 0b       	ld.w	r11,r8[0x0]
8000b196:	c8 5f       	rcall	8000b0a0 <_malloc_trim_r>
8000b198:	0e 9c       	mov	r12,r7
8000b19a:	fe b0 d7 39 	rcall	8000600c <__malloc_unlock>
8000b19e:	d8 22       	popm	r4-r7,pc
8000b1a0:	93 1b       	st.w	r9[0x4],r11
8000b1a2:	58 0c       	cp.w	r12,0
8000b1a4:	c0 30       	breq	8000b1aa <_free_r+0x72>
8000b1a6:	30 0c       	mov	r12,0
8000b1a8:	c1 08       	rjmp	8000b1c8 <_free_r+0x90>
8000b1aa:	6c 0e       	ld.w	lr,r6[0x0]
8000b1ac:	f4 c5 ff f8 	sub	r5,r10,-8
8000b1b0:	1c 16       	sub	r6,lr
8000b1b2:	1c 08       	add	r8,lr
8000b1b4:	6c 2e       	ld.w	lr,r6[0x8]
8000b1b6:	0a 3e       	cp.w	lr,r5
8000b1b8:	f9 bc 00 01 	moveq	r12,1
8000b1bc:	ed f5 10 03 	ld.wne	r5,r6[0xc]
8000b1c0:	eb fe 1a 02 	st.wne	r5[0x8],lr
8000b1c4:	fd f5 1a 03 	st.wne	lr[0xc],r5
8000b1c8:	f2 0b 00 0e 	add	lr,r9,r11
8000b1cc:	7c 1e       	ld.w	lr,lr[0x4]
8000b1ce:	ed be 00 00 	bld	lr,0x0
8000b1d2:	c1 40       	breq	8000b1fa <_free_r+0xc2>
8000b1d4:	16 08       	add	r8,r11
8000b1d6:	58 0c       	cp.w	r12,0
8000b1d8:	c0 d1       	brne	8000b1f2 <_free_r+0xba>
8000b1da:	e0 6e 05 3c 	mov	lr,1340
8000b1de:	72 2b       	ld.w	r11,r9[0x8]
8000b1e0:	2f 8e       	sub	lr,-8
8000b1e2:	1c 3b       	cp.w	r11,lr
8000b1e4:	c0 71       	brne	8000b1f2 <_free_r+0xba>
8000b1e6:	97 36       	st.w	r11[0xc],r6
8000b1e8:	97 26       	st.w	r11[0x8],r6
8000b1ea:	8d 2b       	st.w	r6[0x8],r11
8000b1ec:	8d 3b       	st.w	r6[0xc],r11
8000b1ee:	30 1c       	mov	r12,1
8000b1f0:	c0 58       	rjmp	8000b1fa <_free_r+0xc2>
8000b1f2:	72 2b       	ld.w	r11,r9[0x8]
8000b1f4:	72 39       	ld.w	r9,r9[0xc]
8000b1f6:	93 2b       	st.w	r9[0x8],r11
8000b1f8:	97 39       	st.w	r11[0xc],r9
8000b1fa:	10 99       	mov	r9,r8
8000b1fc:	ec 08 09 08 	st.w	r6[r8],r8
8000b200:	a1 a9       	sbr	r9,0x0
8000b202:	8d 19       	st.w	r6[0x4],r9
8000b204:	58 0c       	cp.w	r12,0
8000b206:	c5 a1       	brne	8000b2ba <_free_r+0x182>
8000b208:	e0 48 01 ff 	cp.w	r8,511
8000b20c:	e0 8b 00 13 	brhi	8000b232 <_free_r+0xfa>
8000b210:	a3 98       	lsr	r8,0x3
8000b212:	f4 08 00 39 	add	r9,r10,r8<<0x3
8000b216:	72 2b       	ld.w	r11,r9[0x8]
8000b218:	8d 39       	st.w	r6[0xc],r9
8000b21a:	8d 2b       	st.w	r6[0x8],r11
8000b21c:	97 36       	st.w	r11[0xc],r6
8000b21e:	93 26       	st.w	r9[0x8],r6
8000b220:	a3 48       	asr	r8,0x2
8000b222:	74 19       	ld.w	r9,r10[0x4]
8000b224:	30 1b       	mov	r11,1
8000b226:	f6 08 09 48 	lsl	r8,r11,r8
8000b22a:	f3 e8 10 08 	or	r8,r9,r8
8000b22e:	95 18       	st.w	r10[0x4],r8
8000b230:	c4 58       	rjmp	8000b2ba <_free_r+0x182>
8000b232:	f0 0b 16 09 	lsr	r11,r8,0x9
8000b236:	58 4b       	cp.w	r11,4
8000b238:	e0 8b 00 06 	brhi	8000b244 <_free_r+0x10c>
8000b23c:	f0 0b 16 06 	lsr	r11,r8,0x6
8000b240:	2c 8b       	sub	r11,-56
8000b242:	c2 08       	rjmp	8000b282 <_free_r+0x14a>
8000b244:	59 4b       	cp.w	r11,20
8000b246:	e0 8b 00 04 	brhi	8000b24e <_free_r+0x116>
8000b24a:	2a 5b       	sub	r11,-91
8000b24c:	c1 b8       	rjmp	8000b282 <_free_r+0x14a>
8000b24e:	e0 4b 00 54 	cp.w	r11,84
8000b252:	e0 8b 00 06 	brhi	8000b25e <_free_r+0x126>
8000b256:	f0 0b 16 0c 	lsr	r11,r8,0xc
8000b25a:	29 2b       	sub	r11,-110
8000b25c:	c1 38       	rjmp	8000b282 <_free_r+0x14a>
8000b25e:	e0 4b 01 54 	cp.w	r11,340
8000b262:	e0 8b 00 06 	brhi	8000b26e <_free_r+0x136>
8000b266:	f0 0b 16 0f 	lsr	r11,r8,0xf
8000b26a:	28 9b       	sub	r11,-119
8000b26c:	c0 b8       	rjmp	8000b282 <_free_r+0x14a>
8000b26e:	e0 4b 05 54 	cp.w	r11,1364
8000b272:	e0 88 00 05 	brls	8000b27c <_free_r+0x144>
8000b276:	37 eb       	mov	r11,126
8000b278:	c0 58       	rjmp	8000b282 <_free_r+0x14a>
8000b27a:	d7 03       	nop
8000b27c:	f0 0b 16 12 	lsr	r11,r8,0x12
8000b280:	28 4b       	sub	r11,-124
8000b282:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
8000b286:	78 29       	ld.w	r9,r12[0x8]
8000b288:	18 39       	cp.w	r9,r12
8000b28a:	c0 e1       	brne	8000b2a6 <_free_r+0x16e>
8000b28c:	74 18       	ld.w	r8,r10[0x4]
8000b28e:	a3 4b       	asr	r11,0x2
8000b290:	30 1c       	mov	r12,1
8000b292:	f8 0b 09 4b 	lsl	r11,r12,r11
8000b296:	f1 eb 10 0b 	or	r11,r8,r11
8000b29a:	12 98       	mov	r8,r9
8000b29c:	95 1b       	st.w	r10[0x4],r11
8000b29e:	c0 a8       	rjmp	8000b2b2 <_free_r+0x17a>
8000b2a0:	72 29       	ld.w	r9,r9[0x8]
8000b2a2:	18 39       	cp.w	r9,r12
8000b2a4:	c0 60       	breq	8000b2b0 <_free_r+0x178>
8000b2a6:	72 1a       	ld.w	r10,r9[0x4]
8000b2a8:	e0 1a ff fc 	andl	r10,0xfffc
8000b2ac:	14 38       	cp.w	r8,r10
8000b2ae:	cf 93       	brcs	8000b2a0 <_free_r+0x168>
8000b2b0:	72 38       	ld.w	r8,r9[0xc]
8000b2b2:	8d 38       	st.w	r6[0xc],r8
8000b2b4:	8d 29       	st.w	r6[0x8],r9
8000b2b6:	93 36       	st.w	r9[0xc],r6
8000b2b8:	91 26       	st.w	r8[0x8],r6
8000b2ba:	0e 9c       	mov	r12,r7
8000b2bc:	fe b0 d6 a8 	rcall	8000600c <__malloc_unlock>
8000b2c0:	d8 22       	popm	r4-r7,pc
8000b2c2:	d7 03       	nop

8000b2c4 <__sfvwrite_r>:
8000b2c4:	d4 31       	pushm	r0-r7,lr
8000b2c6:	20 3d       	sub	sp,12
8000b2c8:	14 94       	mov	r4,r10
8000b2ca:	18 95       	mov	r5,r12
8000b2cc:	16 97       	mov	r7,r11
8000b2ce:	74 28       	ld.w	r8,r10[0x8]
8000b2d0:	58 08       	cp.w	r8,0
8000b2d2:	e0 80 01 40 	breq	8000b552 <__sfvwrite_r+0x28e>
8000b2d6:	96 68       	ld.sh	r8,r11[0xc]
8000b2d8:	ed b8 00 03 	bld	r8,0x3
8000b2dc:	c0 41       	brne	8000b2e4 <__sfvwrite_r+0x20>
8000b2de:	76 48       	ld.w	r8,r11[0x10]
8000b2e0:	58 08       	cp.w	r8,0
8000b2e2:	c0 c1       	brne	8000b2fa <__sfvwrite_r+0x36>
8000b2e4:	0e 9b       	mov	r11,r7
8000b2e6:	0a 9c       	mov	r12,r5
8000b2e8:	fe b0 f6 c4 	rcall	8000a070 <__swsetup_r>
8000b2ec:	c0 70       	breq	8000b2fa <__sfvwrite_r+0x36>
8000b2ee:	8e 68       	ld.sh	r8,r7[0xc]
8000b2f0:	a7 a8       	sbr	r8,0x6
8000b2f2:	ae 68       	st.h	r7[0xc],r8
8000b2f4:	30 98       	mov	r8,9
8000b2f6:	8b 38       	st.w	r5[0xc],r8
8000b2f8:	c2 b9       	rjmp	8000b54e <__sfvwrite_r+0x28a>
8000b2fa:	8e 63       	ld.sh	r3,r7[0xc]
8000b2fc:	68 00       	ld.w	r0,r4[0x0]
8000b2fe:	06 96       	mov	r6,r3
8000b300:	e2 16 00 02 	andl	r6,0x2,COH
8000b304:	c2 10       	breq	8000b346 <__sfvwrite_r+0x82>
8000b306:	30 03       	mov	r3,0
8000b308:	e0 62 04 00 	mov	r2,1024
8000b30c:	06 96       	mov	r6,r3
8000b30e:	c0 48       	rjmp	8000b316 <__sfvwrite_r+0x52>
8000b310:	60 03       	ld.w	r3,r0[0x0]
8000b312:	60 16       	ld.w	r6,r0[0x4]
8000b314:	2f 80       	sub	r0,-8
8000b316:	58 06       	cp.w	r6,0
8000b318:	cf c0       	breq	8000b310 <__sfvwrite_r+0x4c>
8000b31a:	e0 46 04 00 	cp.w	r6,1024
8000b31e:	ec 09 17 80 	movls	r9,r6
8000b322:	e4 09 17 b0 	movhi	r9,r2
8000b326:	06 9a       	mov	r10,r3
8000b328:	6e a8       	ld.w	r8,r7[0x28]
8000b32a:	6e 8b       	ld.w	r11,r7[0x20]
8000b32c:	0a 9c       	mov	r12,r5
8000b32e:	5d 18       	icall	r8
8000b330:	18 16       	sub	r6,r12
8000b332:	58 0c       	cp.w	r12,0
8000b334:	e0 8a 01 0a 	brle	8000b548 <__sfvwrite_r+0x284>
8000b338:	68 28       	ld.w	r8,r4[0x8]
8000b33a:	18 18       	sub	r8,r12
8000b33c:	89 28       	st.w	r4[0x8],r8
8000b33e:	e0 80 01 0a 	breq	8000b552 <__sfvwrite_r+0x28e>
8000b342:	18 03       	add	r3,r12
8000b344:	ce 9b       	rjmp	8000b316 <__sfvwrite_r+0x52>
8000b346:	e7 d3 c0 01 	bfextu	r3,r3,0x0,0x1
8000b34a:	c0 70       	breq	8000b358 <__sfvwrite_r+0x94>
8000b34c:	50 06       	stdsp	sp[0x0],r6
8000b34e:	0c 93       	mov	r3,r6
8000b350:	0c 91       	mov	r1,r6
8000b352:	50 15       	stdsp	sp[0x4],r5
8000b354:	08 92       	mov	r2,r4
8000b356:	c9 c8       	rjmp	8000b48e <__sfvwrite_r+0x1ca>
8000b358:	06 96       	mov	r6,r3
8000b35a:	08 91       	mov	r1,r4
8000b35c:	c0 48       	rjmp	8000b364 <__sfvwrite_r+0xa0>
8000b35e:	60 03       	ld.w	r3,r0[0x0]
8000b360:	60 16       	ld.w	r6,r0[0x4]
8000b362:	2f 80       	sub	r0,-8
8000b364:	58 06       	cp.w	r6,0
8000b366:	cf c0       	breq	8000b35e <__sfvwrite_r+0x9a>
8000b368:	8e 68       	ld.sh	r8,r7[0xc]
8000b36a:	6e 24       	ld.w	r4,r7[0x8]
8000b36c:	10 99       	mov	r9,r8
8000b36e:	e2 19 02 00 	andl	r9,0x200,COH
8000b372:	c5 50       	breq	8000b41c <__sfvwrite_r+0x158>
8000b374:	08 36       	cp.w	r6,r4
8000b376:	c4 43       	brcs	8000b3fe <__sfvwrite_r+0x13a>
8000b378:	10 99       	mov	r9,r8
8000b37a:	e2 19 04 80 	andl	r9,0x480,COH
8000b37e:	c4 00       	breq	8000b3fe <__sfvwrite_r+0x13a>
8000b380:	6e 4b       	ld.w	r11,r7[0x10]
8000b382:	6e 09       	ld.w	r9,r7[0x0]
8000b384:	16 19       	sub	r9,r11
8000b386:	50 09       	stdsp	sp[0x0],r9
8000b388:	6e 59       	ld.w	r9,r7[0x14]
8000b38a:	10 9c       	mov	r12,r8
8000b38c:	f2 09 00 1a 	add	r10,r9,r9<<0x1
8000b390:	30 28       	mov	r8,2
8000b392:	f4 08 0c 08 	divs	r8,r10,r8
8000b396:	fa e9 00 04 	st.d	sp[4],r8
8000b39a:	10 94       	mov	r4,r8
8000b39c:	40 09       	lddsp	r9,sp[0x0]
8000b39e:	e2 1c 04 00 	andl	r12,0x400,COH
8000b3a2:	2f f9       	sub	r9,-1
8000b3a4:	0c 09       	add	r9,r6
8000b3a6:	12 38       	cp.w	r8,r9
8000b3a8:	f2 04 17 30 	movlo	r4,r9
8000b3ac:	58 0c       	cp.w	r12,0
8000b3ae:	c1 10       	breq	8000b3d0 <__sfvwrite_r+0x10c>
8000b3b0:	08 9b       	mov	r11,r4
8000b3b2:	0a 9c       	mov	r12,r5
8000b3b4:	fe b0 e0 6c 	rcall	8000748c <_malloc_r>
8000b3b8:	18 92       	mov	r2,r12
8000b3ba:	c1 40       	breq	8000b3e2 <__sfvwrite_r+0x11e>
8000b3bc:	40 0a       	lddsp	r10,sp[0x0]
8000b3be:	6e 4b       	ld.w	r11,r7[0x10]
8000b3c0:	fe b0 e2 82 	rcall	800078c4 <memcpy>
8000b3c4:	8e 68       	ld.sh	r8,r7[0xc]
8000b3c6:	e0 18 fb 7f 	andl	r8,0xfb7f
8000b3ca:	a7 b8       	sbr	r8,0x7
8000b3cc:	ae 68       	st.h	r7[0xc],r8
8000b3ce:	c0 d8       	rjmp	8000b3e8 <__sfvwrite_r+0x124>
8000b3d0:	08 9a       	mov	r10,r4
8000b3d2:	0a 9c       	mov	r12,r5
8000b3d4:	fe b0 e3 24 	rcall	80007a1c <_realloc_r>
8000b3d8:	18 92       	mov	r2,r12
8000b3da:	c0 71       	brne	8000b3e8 <__sfvwrite_r+0x124>
8000b3dc:	6e 4b       	ld.w	r11,r7[0x10]
8000b3de:	0a 9c       	mov	r12,r5
8000b3e0:	ca ce       	rcall	8000b138 <_free_r>
8000b3e2:	30 c8       	mov	r8,12
8000b3e4:	8b 38       	st.w	r5[0xc],r8
8000b3e6:	cb 18       	rjmp	8000b548 <__sfvwrite_r+0x284>
8000b3e8:	40 0a       	lddsp	r10,sp[0x0]
8000b3ea:	40 09       	lddsp	r9,sp[0x0]
8000b3ec:	e8 0a 01 0a 	sub	r10,r4,r10
8000b3f0:	e4 09 00 08 	add	r8,r2,r9
8000b3f4:	8f 54       	st.w	r7[0x14],r4
8000b3f6:	8f 2a       	st.w	r7[0x8],r10
8000b3f8:	8f 08       	st.w	r7[0x0],r8
8000b3fa:	8f 42       	st.w	r7[0x10],r2
8000b3fc:	0c 94       	mov	r4,r6
8000b3fe:	08 36       	cp.w	r6,r4
8000b400:	ec 04 17 30 	movlo	r4,r6
8000b404:	06 9b       	mov	r11,r3
8000b406:	08 9a       	mov	r10,r4
8000b408:	6e 0c       	ld.w	r12,r7[0x0]
8000b40a:	c3 ad       	rcall	8000b67e <memmove>
8000b40c:	6e 08       	ld.w	r8,r7[0x0]
8000b40e:	08 08       	add	r8,r4
8000b410:	8f 08       	st.w	r7[0x0],r8
8000b412:	6e 28       	ld.w	r8,r7[0x8]
8000b414:	08 18       	sub	r8,r4
8000b416:	0c 94       	mov	r4,r6
8000b418:	8f 28       	st.w	r7[0x8],r8
8000b41a:	c2 e8       	rjmp	8000b476 <__sfvwrite_r+0x1b2>
8000b41c:	08 36       	cp.w	r6,r4
8000b41e:	5f ba       	srhi	r10
8000b420:	6e 0c       	ld.w	r12,r7[0x0]
8000b422:	6e 48       	ld.w	r8,r7[0x10]
8000b424:	10 3c       	cp.w	r12,r8
8000b426:	5f b8       	srhi	r8
8000b428:	f5 e8 00 08 	and	r8,r10,r8
8000b42c:	f2 08 18 00 	cp.b	r8,r9
8000b430:	c0 d0       	breq	8000b44a <__sfvwrite_r+0x186>
8000b432:	06 9b       	mov	r11,r3
8000b434:	08 9a       	mov	r10,r4
8000b436:	c2 4d       	rcall	8000b67e <memmove>
8000b438:	6e 08       	ld.w	r8,r7[0x0]
8000b43a:	08 08       	add	r8,r4
8000b43c:	0e 9b       	mov	r11,r7
8000b43e:	8f 08       	st.w	r7[0x0],r8
8000b440:	0a 9c       	mov	r12,r5
8000b442:	fe b0 fd 09 	rcall	8000ae54 <_fflush_r>
8000b446:	c1 80       	breq	8000b476 <__sfvwrite_r+0x1b2>
8000b448:	c8 08       	rjmp	8000b548 <__sfvwrite_r+0x284>
8000b44a:	6e 59       	ld.w	r9,r7[0x14]
8000b44c:	12 36       	cp.w	r6,r9
8000b44e:	c0 a3       	brcs	8000b462 <__sfvwrite_r+0x19e>
8000b450:	6e a8       	ld.w	r8,r7[0x28]
8000b452:	06 9a       	mov	r10,r3
8000b454:	6e 8b       	ld.w	r11,r7[0x20]
8000b456:	0a 9c       	mov	r12,r5
8000b458:	5d 18       	icall	r8
8000b45a:	18 94       	mov	r4,r12
8000b45c:	e0 89 00 0d 	brgt	8000b476 <__sfvwrite_r+0x1b2>
8000b460:	c7 48       	rjmp	8000b548 <__sfvwrite_r+0x284>
8000b462:	0c 9a       	mov	r10,r6
8000b464:	06 9b       	mov	r11,r3
8000b466:	c0 cd       	rcall	8000b67e <memmove>
8000b468:	6e 08       	ld.w	r8,r7[0x0]
8000b46a:	0c 08       	add	r8,r6
8000b46c:	0c 94       	mov	r4,r6
8000b46e:	8f 08       	st.w	r7[0x0],r8
8000b470:	6e 28       	ld.w	r8,r7[0x8]
8000b472:	0c 18       	sub	r8,r6
8000b474:	8f 28       	st.w	r7[0x8],r8
8000b476:	62 28       	ld.w	r8,r1[0x8]
8000b478:	08 18       	sub	r8,r4
8000b47a:	83 28       	st.w	r1[0x8],r8
8000b47c:	c6 b0       	breq	8000b552 <__sfvwrite_r+0x28e>
8000b47e:	08 16       	sub	r6,r4
8000b480:	08 03       	add	r3,r4
8000b482:	c7 1b       	rjmp	8000b364 <__sfvwrite_r+0xa0>
8000b484:	60 03       	ld.w	r3,r0[0x0]
8000b486:	60 11       	ld.w	r1,r0[0x4]
8000b488:	30 08       	mov	r8,0
8000b48a:	2f 80       	sub	r0,-8
8000b48c:	50 08       	stdsp	sp[0x0],r8
8000b48e:	58 01       	cp.w	r1,0
8000b490:	cf a0       	breq	8000b484 <__sfvwrite_r+0x1c0>
8000b492:	40 0a       	lddsp	r10,sp[0x0]
8000b494:	58 0a       	cp.w	r10,0
8000b496:	c1 41       	brne	8000b4be <__sfvwrite_r+0x1fa>
8000b498:	e2 c6 ff ff 	sub	r6,r1,-1
8000b49c:	02 9a       	mov	r10,r1
8000b49e:	30 ab       	mov	r11,10
8000b4a0:	06 9c       	mov	r12,r3
8000b4a2:	ce 3c       	rcall	8000b668 <memchr>
8000b4a4:	f8 c8 ff ff 	sub	r8,r12,-1
8000b4a8:	58 0c       	cp.w	r12,0
8000b4aa:	f1 d3 e1 16 	subne	r6,r8,r3
8000b4ae:	f9 b9 01 01 	movne	r9,1
8000b4b2:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000b4b6:	f9 b8 00 01 	moveq	r8,1
8000b4ba:	fb f8 0a 00 	st.weq	sp[0x0],r8
8000b4be:	02 36       	cp.w	r6,r1
8000b4c0:	ec 04 17 80 	movls	r4,r6
8000b4c4:	e2 04 17 b0 	movhi	r4,r1
8000b4c8:	6e 59       	ld.w	r9,r7[0x14]
8000b4ca:	6e 25       	ld.w	r5,r7[0x8]
8000b4cc:	f2 05 00 05 	add	r5,r9,r5
8000b4d0:	0a 34       	cp.w	r4,r5
8000b4d2:	5f 9a       	srgt	r10
8000b4d4:	6e 0c       	ld.w	r12,r7[0x0]
8000b4d6:	6e 48       	ld.w	r8,r7[0x10]
8000b4d8:	10 3c       	cp.w	r12,r8
8000b4da:	5f b8       	srhi	r8
8000b4dc:	f5 e8 00 08 	and	r8,r10,r8
8000b4e0:	30 0a       	mov	r10,0
8000b4e2:	f4 08 18 00 	cp.b	r8,r10
8000b4e6:	c0 d0       	breq	8000b500 <__sfvwrite_r+0x23c>
8000b4e8:	06 9b       	mov	r11,r3
8000b4ea:	0a 9a       	mov	r10,r5
8000b4ec:	cc 9c       	rcall	8000b67e <memmove>
8000b4ee:	6e 08       	ld.w	r8,r7[0x0]
8000b4f0:	0a 08       	add	r8,r5
8000b4f2:	0e 9b       	mov	r11,r7
8000b4f4:	8f 08       	st.w	r7[0x0],r8
8000b4f6:	40 1c       	lddsp	r12,sp[0x4]
8000b4f8:	fe b0 fc ae 	rcall	8000ae54 <_fflush_r>
8000b4fc:	c1 70       	breq	8000b52a <__sfvwrite_r+0x266>
8000b4fe:	c2 58       	rjmp	8000b548 <__sfvwrite_r+0x284>
8000b500:	12 34       	cp.w	r4,r9
8000b502:	c0 a5       	brlt	8000b516 <__sfvwrite_r+0x252>
8000b504:	6e a8       	ld.w	r8,r7[0x28]
8000b506:	06 9a       	mov	r10,r3
8000b508:	6e 8b       	ld.w	r11,r7[0x20]
8000b50a:	40 1c       	lddsp	r12,sp[0x4]
8000b50c:	5d 18       	icall	r8
8000b50e:	18 95       	mov	r5,r12
8000b510:	e0 89 00 0d 	brgt	8000b52a <__sfvwrite_r+0x266>
8000b514:	c1 a8       	rjmp	8000b548 <__sfvwrite_r+0x284>
8000b516:	08 9a       	mov	r10,r4
8000b518:	06 9b       	mov	r11,r3
8000b51a:	cb 2c       	rcall	8000b67e <memmove>
8000b51c:	6e 08       	ld.w	r8,r7[0x0]
8000b51e:	08 08       	add	r8,r4
8000b520:	08 95       	mov	r5,r4
8000b522:	8f 08       	st.w	r7[0x0],r8
8000b524:	6e 28       	ld.w	r8,r7[0x8]
8000b526:	08 18       	sub	r8,r4
8000b528:	8f 28       	st.w	r7[0x8],r8
8000b52a:	0a 16       	sub	r6,r5
8000b52c:	c0 71       	brne	8000b53a <__sfvwrite_r+0x276>
8000b52e:	0e 9b       	mov	r11,r7
8000b530:	40 1c       	lddsp	r12,sp[0x4]
8000b532:	fe b0 fc 91 	rcall	8000ae54 <_fflush_r>
8000b536:	c0 91       	brne	8000b548 <__sfvwrite_r+0x284>
8000b538:	50 06       	stdsp	sp[0x0],r6
8000b53a:	64 28       	ld.w	r8,r2[0x8]
8000b53c:	0a 18       	sub	r8,r5
8000b53e:	85 28       	st.w	r2[0x8],r8
8000b540:	c0 90       	breq	8000b552 <__sfvwrite_r+0x28e>
8000b542:	0a 11       	sub	r1,r5
8000b544:	0a 03       	add	r3,r5
8000b546:	ca 4b       	rjmp	8000b48e <__sfvwrite_r+0x1ca>
8000b548:	8e 68       	ld.sh	r8,r7[0xc]
8000b54a:	a7 a8       	sbr	r8,0x6
8000b54c:	ae 68       	st.h	r7[0xc],r8
8000b54e:	3f fc       	mov	r12,-1
8000b550:	c0 28       	rjmp	8000b554 <__sfvwrite_r+0x290>
8000b552:	30 0c       	mov	r12,0
8000b554:	2f dd       	sub	sp,-12
8000b556:	d8 32       	popm	r0-r7,pc

8000b558 <_fwalk>:
8000b558:	d4 31       	pushm	r0-r7,lr
8000b55a:	30 05       	mov	r5,0
8000b55c:	16 91       	mov	r1,r11
8000b55e:	f8 c7 ff 28 	sub	r7,r12,-216
8000b562:	0a 92       	mov	r2,r5
8000b564:	fe b0 fc fe 	rcall	8000af60 <__sfp_lock_acquire>
8000b568:	3f f3       	mov	r3,-1
8000b56a:	c1 68       	rjmp	8000b596 <_fwalk+0x3e>
8000b56c:	6e 26       	ld.w	r6,r7[0x8]
8000b56e:	6e 14       	ld.w	r4,r7[0x4]
8000b570:	2f 46       	sub	r6,-12
8000b572:	c0 c8       	rjmp	8000b58a <_fwalk+0x32>
8000b574:	8c 08       	ld.sh	r8,r6[0x0]
8000b576:	e4 08 19 00 	cp.h	r8,r2
8000b57a:	c0 70       	breq	8000b588 <_fwalk+0x30>
8000b57c:	8c 18       	ld.sh	r8,r6[0x2]
8000b57e:	e6 08 19 00 	cp.h	r8,r3
8000b582:	c0 30       	breq	8000b588 <_fwalk+0x30>
8000b584:	5d 11       	icall	r1
8000b586:	18 45       	or	r5,r12
8000b588:	2a 46       	sub	r6,-92
8000b58a:	20 14       	sub	r4,1
8000b58c:	ec cc 00 0c 	sub	r12,r6,12
8000b590:	58 04       	cp.w	r4,0
8000b592:	cf 14       	brge	8000b574 <_fwalk+0x1c>
8000b594:	6e 07       	ld.w	r7,r7[0x0]
8000b596:	58 07       	cp.w	r7,0
8000b598:	ce a1       	brne	8000b56c <_fwalk+0x14>
8000b59a:	fe b0 fc e4 	rcall	8000af62 <__sfp_lock_release>
8000b59e:	0a 9c       	mov	r12,r5
8000b5a0:	d8 32       	popm	r0-r7,pc
8000b5a2:	d7 03       	nop

8000b5a4 <_localeconv_r>:
8000b5a4:	fe cc d4 14 	sub	r12,pc,-11244
8000b5a8:	5e fc       	retal	r12
8000b5aa:	d7 03       	nop

8000b5ac <__smakebuf_r>:
8000b5ac:	d4 21       	pushm	r4-r7,lr
8000b5ae:	20 fd       	sub	sp,60
8000b5b0:	96 68       	ld.sh	r8,r11[0xc]
8000b5b2:	16 97       	mov	r7,r11
8000b5b4:	18 96       	mov	r6,r12
8000b5b6:	e2 18 00 02 	andl	r8,0x2,COH
8000b5ba:	c3 d1       	brne	8000b634 <__smakebuf_r+0x88>
8000b5bc:	96 7b       	ld.sh	r11,r11[0xe]
8000b5be:	f0 0b 19 00 	cp.h	r11,r8
8000b5c2:	c0 55       	brlt	8000b5cc <__smakebuf_r+0x20>
8000b5c4:	1a 9a       	mov	r10,sp
8000b5c6:	e0 a0 04 81 	rcall	8000bec8 <_fstat_r>
8000b5ca:	c0 f4       	brge	8000b5e8 <__smakebuf_r+0x3c>
8000b5cc:	8e 65       	ld.sh	r5,r7[0xc]
8000b5ce:	0a 98       	mov	r8,r5
8000b5d0:	ab b8       	sbr	r8,0xb
8000b5d2:	e2 15 00 80 	andl	r5,0x80,COH
8000b5d6:	ae 68       	st.h	r7[0xc],r8
8000b5d8:	30 04       	mov	r4,0
8000b5da:	e0 68 04 00 	mov	r8,1024
8000b5de:	f9 b5 01 40 	movne	r5,64
8000b5e2:	f0 05 17 00 	moveq	r5,r8
8000b5e6:	c1 c8       	rjmp	8000b61e <__smakebuf_r+0x72>
8000b5e8:	40 18       	lddsp	r8,sp[0x4]
8000b5ea:	e2 18 f0 00 	andl	r8,0xf000,COH
8000b5ee:	e0 48 20 00 	cp.w	r8,8192
8000b5f2:	5f 04       	sreq	r4
8000b5f4:	e0 48 80 00 	cp.w	r8,32768
8000b5f8:	c0 e1       	brne	8000b614 <__smakebuf_r+0x68>
8000b5fa:	6e b9       	ld.w	r9,r7[0x2c]
8000b5fc:	fe c8 f9 1c 	sub	r8,pc,-1764
8000b600:	10 39       	cp.w	r9,r8
8000b602:	c0 91       	brne	8000b614 <__smakebuf_r+0x68>
8000b604:	8e 68       	ld.sh	r8,r7[0xc]
8000b606:	e0 65 04 00 	mov	r5,1024
8000b60a:	ab a8       	sbr	r8,0xa
8000b60c:	ef 45 00 50 	st.w	r7[80],r5
8000b610:	ae 68       	st.h	r7[0xc],r8
8000b612:	c0 68       	rjmp	8000b61e <__smakebuf_r+0x72>
8000b614:	8e 68       	ld.sh	r8,r7[0xc]
8000b616:	e0 65 04 00 	mov	r5,1024
8000b61a:	ab b8       	sbr	r8,0xb
8000b61c:	ae 68       	st.h	r7[0xc],r8
8000b61e:	0a 9b       	mov	r11,r5
8000b620:	0c 9c       	mov	r12,r6
8000b622:	fe b0 df 35 	rcall	8000748c <_malloc_r>
8000b626:	8e 68       	ld.sh	r8,r7[0xc]
8000b628:	c0 d1       	brne	8000b642 <__smakebuf_r+0x96>
8000b62a:	ed b8 00 09 	bld	r8,0x9
8000b62e:	c1 b0       	breq	8000b664 <__smakebuf_r+0xb8>
8000b630:	a1 b8       	sbr	r8,0x1
8000b632:	ae 68       	st.h	r7[0xc],r8
8000b634:	ee c8 ff b9 	sub	r8,r7,-71
8000b638:	8f 48       	st.w	r7[0x10],r8
8000b63a:	8f 08       	st.w	r7[0x0],r8
8000b63c:	30 18       	mov	r8,1
8000b63e:	8f 58       	st.w	r7[0x14],r8
8000b640:	c1 28       	rjmp	8000b664 <__smakebuf_r+0xb8>
8000b642:	a7 b8       	sbr	r8,0x7
8000b644:	8f 4c       	st.w	r7[0x10],r12
8000b646:	ae 68       	st.h	r7[0xc],r8
8000b648:	8f 55       	st.w	r7[0x14],r5
8000b64a:	fe c8 06 e6 	sub	r8,pc,1766
8000b64e:	8f 0c       	st.w	r7[0x0],r12
8000b650:	8d a8       	st.w	r6[0x28],r8
8000b652:	58 04       	cp.w	r4,0
8000b654:	c0 80       	breq	8000b664 <__smakebuf_r+0xb8>
8000b656:	8e 7c       	ld.sh	r12,r7[0xe]
8000b658:	fe b0 e3 94 	rcall	80007d80 <isatty>
8000b65c:	c0 40       	breq	8000b664 <__smakebuf_r+0xb8>
8000b65e:	8e 68       	ld.sh	r8,r7[0xc]
8000b660:	a1 a8       	sbr	r8,0x0
8000b662:	ae 68       	st.h	r7[0xc],r8
8000b664:	2f 1d       	sub	sp,-60
8000b666:	d8 22       	popm	r4-r7,pc

8000b668 <memchr>:
8000b668:	f7 db c0 08 	bfextu	r11,r11,0x0,0x8
8000b66c:	c0 68       	rjmp	8000b678 <memchr+0x10>
8000b66e:	20 1a       	sub	r10,1
8000b670:	19 88       	ld.ub	r8,r12[0x0]
8000b672:	16 38       	cp.w	r8,r11
8000b674:	5e 0c       	reteq	r12
8000b676:	2f fc       	sub	r12,-1
8000b678:	58 0a       	cp.w	r10,0
8000b67a:	cf a1       	brne	8000b66e <memchr+0x6>
8000b67c:	5e fa       	retal	r10

8000b67e <memmove>:
8000b67e:	d4 01       	pushm	lr
8000b680:	18 3b       	cp.w	r11,r12
8000b682:	c1 92       	brcc	8000b6b4 <memmove+0x36>
8000b684:	f6 0a 00 09 	add	r9,r11,r10
8000b688:	12 3c       	cp.w	r12,r9
8000b68a:	c1 52       	brcc	8000b6b4 <memmove+0x36>
8000b68c:	f8 0a 00 0b 	add	r11,r12,r10
8000b690:	30 08       	mov	r8,0
8000b692:	c0 68       	rjmp	8000b69e <memmove+0x20>
8000b694:	f2 08 07 0e 	ld.ub	lr,r9[r8]
8000b698:	20 1a       	sub	r10,1
8000b69a:	f6 08 0b 0e 	st.b	r11[r8],lr
8000b69e:	20 18       	sub	r8,1
8000b6a0:	58 0a       	cp.w	r10,0
8000b6a2:	cf 91       	brne	8000b694 <memmove+0x16>
8000b6a4:	d8 02       	popm	pc
8000b6a6:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000b6aa:	20 1a       	sub	r10,1
8000b6ac:	f8 08 0b 09 	st.b	r12[r8],r9
8000b6b0:	2f f8       	sub	r8,-1
8000b6b2:	c0 28       	rjmp	8000b6b6 <memmove+0x38>
8000b6b4:	30 08       	mov	r8,0
8000b6b6:	58 0a       	cp.w	r10,0
8000b6b8:	cf 71       	brne	8000b6a6 <memmove+0x28>
8000b6ba:	d8 02       	popm	pc

8000b6bc <__hi0bits>:
8000b6bc:	18 98       	mov	r8,r12
8000b6be:	e0 1c 00 00 	andl	r12,0x0
8000b6c2:	f0 09 15 10 	lsl	r9,r8,0x10
8000b6c6:	58 0c       	cp.w	r12,0
8000b6c8:	f2 08 17 00 	moveq	r8,r9
8000b6cc:	f9 bc 00 10 	moveq	r12,16
8000b6d0:	f9 bc 01 00 	movne	r12,0
8000b6d4:	10 9a       	mov	r10,r8
8000b6d6:	f0 09 15 08 	lsl	r9,r8,0x8
8000b6da:	e6 1a ff 00 	andh	r10,0xff00,COH
8000b6de:	f7 bc 00 f8 	subeq	r12,-8
8000b6e2:	f2 08 17 00 	moveq	r8,r9
8000b6e6:	10 9a       	mov	r10,r8
8000b6e8:	f0 09 15 04 	lsl	r9,r8,0x4
8000b6ec:	e6 1a f0 00 	andh	r10,0xf000,COH
8000b6f0:	f7 bc 00 fc 	subeq	r12,-4
8000b6f4:	f2 08 17 00 	moveq	r8,r9
8000b6f8:	10 9a       	mov	r10,r8
8000b6fa:	f0 09 15 02 	lsl	r9,r8,0x2
8000b6fe:	e6 1a c0 00 	andh	r10,0xc000,COH
8000b702:	f7 bc 00 fe 	subeq	r12,-2
8000b706:	f2 08 17 00 	moveq	r8,r9
8000b70a:	58 08       	cp.w	r8,0
8000b70c:	5e 5c       	retlt	r12
8000b70e:	ed b8 00 1e 	bld	r8,0x1e
8000b712:	f9 bc 01 20 	movne	r12,32
8000b716:	f7 bc 00 ff 	subeq	r12,-1
8000b71a:	5e fc       	retal	r12

8000b71c <__lo0bits>:
8000b71c:	18 99       	mov	r9,r12
8000b71e:	78 08       	ld.w	r8,r12[0x0]
8000b720:	f9 d8 c0 03 	bfextu	r12,r8,0x0,0x3
8000b724:	c1 50       	breq	8000b74e <__lo0bits+0x32>
8000b726:	ed b8 00 00 	bld	r8,0x0
8000b72a:	c0 21       	brne	8000b72e <__lo0bits+0x12>
8000b72c:	5e fd       	retal	0
8000b72e:	10 9b       	mov	r11,r8
8000b730:	f0 0a 16 01 	lsr	r10,r8,0x1
8000b734:	e2 1b 00 02 	andl	r11,0x2,COH
8000b738:	a3 88       	lsr	r8,0x2
8000b73a:	58 0b       	cp.w	r11,0
8000b73c:	f3 fa 1a 00 	st.wne	r9[0x0],r10
8000b740:	f9 bc 01 01 	movne	r12,1
8000b744:	f3 f8 0a 00 	st.weq	r9[0x0],r8
8000b748:	f9 bc 00 02 	moveq	r12,2
8000b74c:	5e fc       	retal	r12
8000b74e:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
8000b752:	f0 0b 16 10 	lsr	r11,r8,0x10
8000b756:	58 0a       	cp.w	r10,0
8000b758:	f6 08 17 00 	moveq	r8,r11
8000b75c:	f9 bc 00 10 	moveq	r12,16
8000b760:	f7 d8 c0 08 	bfextu	r11,r8,0x0,0x8
8000b764:	f0 0a 16 08 	lsr	r10,r8,0x8
8000b768:	58 0b       	cp.w	r11,0
8000b76a:	f7 bc 00 f8 	subeq	r12,-8
8000b76e:	f4 08 17 00 	moveq	r8,r10
8000b772:	f7 d8 c0 04 	bfextu	r11,r8,0x0,0x4
8000b776:	f0 0a 16 04 	lsr	r10,r8,0x4
8000b77a:	58 0b       	cp.w	r11,0
8000b77c:	f7 bc 00 fc 	subeq	r12,-4
8000b780:	f4 08 17 00 	moveq	r8,r10
8000b784:	f7 d8 c0 02 	bfextu	r11,r8,0x0,0x2
8000b788:	f0 0a 16 02 	lsr	r10,r8,0x2
8000b78c:	58 0b       	cp.w	r11,0
8000b78e:	f7 bc 00 fe 	subeq	r12,-2
8000b792:	f4 08 17 00 	moveq	r8,r10
8000b796:	ed b8 00 00 	bld	r8,0x0
8000b79a:	c0 60       	breq	8000b7a6 <__lo0bits+0x8a>
8000b79c:	a1 98       	lsr	r8,0x1
8000b79e:	c0 31       	brne	8000b7a4 <__lo0bits+0x88>
8000b7a0:	32 0c       	mov	r12,32
8000b7a2:	5e fc       	retal	r12
8000b7a4:	2f fc       	sub	r12,-1
8000b7a6:	93 08       	st.w	r9[0x0],r8
8000b7a8:	5e fc       	retal	r12

8000b7aa <__mcmp>:
8000b7aa:	d4 01       	pushm	lr
8000b7ac:	18 98       	mov	r8,r12
8000b7ae:	76 49       	ld.w	r9,r11[0x10]
8000b7b0:	78 4c       	ld.w	r12,r12[0x10]
8000b7b2:	12 1c       	sub	r12,r9
8000b7b4:	c1 31       	brne	8000b7da <__mcmp+0x30>
8000b7b6:	2f b9       	sub	r9,-5
8000b7b8:	a3 69       	lsl	r9,0x2
8000b7ba:	12 0b       	add	r11,r9
8000b7bc:	f0 09 00 09 	add	r9,r8,r9
8000b7c0:	2e c8       	sub	r8,-20
8000b7c2:	13 4e       	ld.w	lr,--r9
8000b7c4:	17 4a       	ld.w	r10,--r11
8000b7c6:	14 3e       	cp.w	lr,r10
8000b7c8:	c0 60       	breq	8000b7d4 <__mcmp+0x2a>
8000b7ca:	f9 bc 03 ff 	movlo	r12,-1
8000b7ce:	f9 bc 02 01 	movhs	r12,1
8000b7d2:	d8 02       	popm	pc
8000b7d4:	10 39       	cp.w	r9,r8
8000b7d6:	fe 9b ff f6 	brhi	8000b7c2 <__mcmp+0x18>
8000b7da:	d8 02       	popm	pc

8000b7dc <_Bfree>:
8000b7dc:	d4 21       	pushm	r4-r7,lr
8000b7de:	18 97       	mov	r7,r12
8000b7e0:	16 95       	mov	r5,r11
8000b7e2:	78 96       	ld.w	r6,r12[0x24]
8000b7e4:	58 06       	cp.w	r6,0
8000b7e6:	c0 91       	brne	8000b7f8 <_Bfree+0x1c>
8000b7e8:	31 0c       	mov	r12,16
8000b7ea:	fe b0 de 49 	rcall	8000747c <malloc>
8000b7ee:	99 36       	st.w	r12[0xc],r6
8000b7f0:	8f 9c       	st.w	r7[0x24],r12
8000b7f2:	99 16       	st.w	r12[0x4],r6
8000b7f4:	99 26       	st.w	r12[0x8],r6
8000b7f6:	99 06       	st.w	r12[0x0],r6
8000b7f8:	58 05       	cp.w	r5,0
8000b7fa:	c0 90       	breq	8000b80c <_Bfree+0x30>
8000b7fc:	6a 19       	ld.w	r9,r5[0x4]
8000b7fe:	6e 98       	ld.w	r8,r7[0x24]
8000b800:	70 38       	ld.w	r8,r8[0xc]
8000b802:	f0 09 03 2a 	ld.w	r10,r8[r9<<0x2]
8000b806:	8b 0a       	st.w	r5[0x0],r10
8000b808:	f0 09 09 25 	st.w	r8[r9<<0x2],r5
8000b80c:	d8 22       	popm	r4-r7,pc
8000b80e:	d7 03       	nop

8000b810 <_Balloc>:
8000b810:	d4 21       	pushm	r4-r7,lr
8000b812:	18 97       	mov	r7,r12
8000b814:	16 96       	mov	r6,r11
8000b816:	78 95       	ld.w	r5,r12[0x24]
8000b818:	58 05       	cp.w	r5,0
8000b81a:	c0 91       	brne	8000b82c <_Balloc+0x1c>
8000b81c:	31 0c       	mov	r12,16
8000b81e:	fe b0 de 2f 	rcall	8000747c <malloc>
8000b822:	99 35       	st.w	r12[0xc],r5
8000b824:	8f 9c       	st.w	r7[0x24],r12
8000b826:	99 15       	st.w	r12[0x4],r5
8000b828:	99 25       	st.w	r12[0x8],r5
8000b82a:	99 05       	st.w	r12[0x0],r5
8000b82c:	6e 95       	ld.w	r5,r7[0x24]
8000b82e:	6a 38       	ld.w	r8,r5[0xc]
8000b830:	58 08       	cp.w	r8,0
8000b832:	c0 b1       	brne	8000b848 <_Balloc+0x38>
8000b834:	31 0a       	mov	r10,16
8000b836:	30 4b       	mov	r11,4
8000b838:	0e 9c       	mov	r12,r7
8000b83a:	e0 a0 02 a7 	rcall	8000bd88 <_calloc_r>
8000b83e:	8b 3c       	st.w	r5[0xc],r12
8000b840:	6e 98       	ld.w	r8,r7[0x24]
8000b842:	70 3c       	ld.w	r12,r8[0xc]
8000b844:	58 0c       	cp.w	r12,0
8000b846:	c1 b0       	breq	8000b87c <_Balloc+0x6c>
8000b848:	6e 98       	ld.w	r8,r7[0x24]
8000b84a:	70 38       	ld.w	r8,r8[0xc]
8000b84c:	f0 06 00 28 	add	r8,r8,r6<<0x2
8000b850:	70 0c       	ld.w	r12,r8[0x0]
8000b852:	58 0c       	cp.w	r12,0
8000b854:	c0 40       	breq	8000b85c <_Balloc+0x4c>
8000b856:	78 09       	ld.w	r9,r12[0x0]
8000b858:	91 09       	st.w	r8[0x0],r9
8000b85a:	c0 e8       	rjmp	8000b876 <_Balloc+0x66>
8000b85c:	0e 9c       	mov	r12,r7
8000b85e:	30 17       	mov	r7,1
8000b860:	0e 9b       	mov	r11,r7
8000b862:	ee 06 09 47 	lsl	r7,r7,r6
8000b866:	ee ca ff fb 	sub	r10,r7,-5
8000b86a:	a3 6a       	lsl	r10,0x2
8000b86c:	e0 a0 02 8e 	rcall	8000bd88 <_calloc_r>
8000b870:	c0 60       	breq	8000b87c <_Balloc+0x6c>
8000b872:	99 16       	st.w	r12[0x4],r6
8000b874:	99 27       	st.w	r12[0x8],r7
8000b876:	30 08       	mov	r8,0
8000b878:	99 38       	st.w	r12[0xc],r8
8000b87a:	99 48       	st.w	r12[0x10],r8
8000b87c:	d8 22       	popm	r4-r7,pc
8000b87e:	d7 03       	nop

8000b880 <__d2b>:
8000b880:	d4 31       	pushm	r0-r7,lr
8000b882:	20 2d       	sub	sp,8
8000b884:	16 93       	mov	r3,r11
8000b886:	12 96       	mov	r6,r9
8000b888:	10 95       	mov	r5,r8
8000b88a:	14 92       	mov	r2,r10
8000b88c:	30 1b       	mov	r11,1
8000b88e:	cc 1f       	rcall	8000b810 <_Balloc>
8000b890:	f3 d3 c0 14 	bfextu	r9,r3,0x0,0x14
8000b894:	50 09       	stdsp	sp[0x0],r9
8000b896:	f1 d3 c0 1f 	bfextu	r8,r3,0x0,0x1f
8000b89a:	b5 a9       	sbr	r9,0x14
8000b89c:	f0 01 16 14 	lsr	r1,r8,0x14
8000b8a0:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000b8a4:	18 94       	mov	r4,r12
8000b8a6:	58 02       	cp.w	r2,0
8000b8a8:	c1 d0       	breq	8000b8e2 <__d2b+0x62>
8000b8aa:	fa cc ff f8 	sub	r12,sp,-8
8000b8ae:	18 d2       	st.w	--r12,r2
8000b8b0:	c3 6f       	rcall	8000b71c <__lo0bits>
8000b8b2:	40 18       	lddsp	r8,sp[0x4]
8000b8b4:	c0 d0       	breq	8000b8ce <__d2b+0x4e>
8000b8b6:	40 09       	lddsp	r9,sp[0x0]
8000b8b8:	f8 0a 11 20 	rsub	r10,r12,32
8000b8bc:	f2 0a 09 4a 	lsl	r10,r9,r10
8000b8c0:	f5 e8 10 08 	or	r8,r10,r8
8000b8c4:	89 58       	st.w	r4[0x14],r8
8000b8c6:	f2 0c 0a 49 	lsr	r9,r9,r12
8000b8ca:	50 09       	stdsp	sp[0x0],r9
8000b8cc:	c0 28       	rjmp	8000b8d0 <__d2b+0x50>
8000b8ce:	89 58       	st.w	r4[0x14],r8
8000b8d0:	40 08       	lddsp	r8,sp[0x0]
8000b8d2:	58 08       	cp.w	r8,0
8000b8d4:	f9 b3 01 02 	movne	r3,2
8000b8d8:	f9 b3 00 01 	moveq	r3,1
8000b8dc:	89 68       	st.w	r4[0x18],r8
8000b8de:	89 43       	st.w	r4[0x10],r3
8000b8e0:	c0 88       	rjmp	8000b8f0 <__d2b+0x70>
8000b8e2:	1a 9c       	mov	r12,sp
8000b8e4:	c1 cf       	rcall	8000b71c <__lo0bits>
8000b8e6:	30 13       	mov	r3,1
8000b8e8:	40 08       	lddsp	r8,sp[0x0]
8000b8ea:	2e 0c       	sub	r12,-32
8000b8ec:	89 43       	st.w	r4[0x10],r3
8000b8ee:	89 58       	st.w	r4[0x14],r8
8000b8f0:	58 01       	cp.w	r1,0
8000b8f2:	c0 90       	breq	8000b904 <__d2b+0x84>
8000b8f4:	e2 c1 04 33 	sub	r1,r1,1075
8000b8f8:	18 01       	add	r1,r12
8000b8fa:	8d 01       	st.w	r6[0x0],r1
8000b8fc:	f8 0c 11 35 	rsub	r12,r12,53
8000b900:	8b 0c       	st.w	r5[0x0],r12
8000b902:	c0 c8       	rjmp	8000b91a <__d2b+0x9a>
8000b904:	e6 c8 ff fc 	sub	r8,r3,-4
8000b908:	f8 cc 04 32 	sub	r12,r12,1074
8000b90c:	a5 73       	lsl	r3,0x5
8000b90e:	8d 0c       	st.w	r6[0x0],r12
8000b910:	e8 08 03 2c 	ld.w	r12,r4[r8<<0x2]
8000b914:	cd 4e       	rcall	8000b6bc <__hi0bits>
8000b916:	18 13       	sub	r3,r12
8000b918:	8b 03       	st.w	r5[0x0],r3
8000b91a:	08 9c       	mov	r12,r4
8000b91c:	2f ed       	sub	sp,-8
8000b91e:	d8 32       	popm	r0-r7,pc

8000b920 <__mdiff>:
8000b920:	d4 31       	pushm	r0-r7,lr
8000b922:	74 48       	ld.w	r8,r10[0x10]
8000b924:	76 45       	ld.w	r5,r11[0x10]
8000b926:	16 97       	mov	r7,r11
8000b928:	14 96       	mov	r6,r10
8000b92a:	10 15       	sub	r5,r8
8000b92c:	c1 31       	brne	8000b952 <__mdiff+0x32>
8000b92e:	2f b8       	sub	r8,-5
8000b930:	ee ce ff ec 	sub	lr,r7,-20
8000b934:	a3 68       	lsl	r8,0x2
8000b936:	f4 08 00 0b 	add	r11,r10,r8
8000b93a:	ee 08 00 08 	add	r8,r7,r8
8000b93e:	11 4a       	ld.w	r10,--r8
8000b940:	17 49       	ld.w	r9,--r11
8000b942:	12 3a       	cp.w	r10,r9
8000b944:	c0 30       	breq	8000b94a <__mdiff+0x2a>
8000b946:	c0 e2       	brcc	8000b962 <__mdiff+0x42>
8000b948:	c0 78       	rjmp	8000b956 <__mdiff+0x36>
8000b94a:	1c 38       	cp.w	r8,lr
8000b94c:	fe 9b ff f9 	brhi	8000b93e <__mdiff+0x1e>
8000b950:	c4 98       	rjmp	8000b9e2 <__mdiff+0xc2>
8000b952:	58 05       	cp.w	r5,0
8000b954:	c0 64       	brge	8000b960 <__mdiff+0x40>
8000b956:	0e 98       	mov	r8,r7
8000b958:	30 15       	mov	r5,1
8000b95a:	0c 97       	mov	r7,r6
8000b95c:	10 96       	mov	r6,r8
8000b95e:	c0 28       	rjmp	8000b962 <__mdiff+0x42>
8000b960:	30 05       	mov	r5,0
8000b962:	6e 1b       	ld.w	r11,r7[0x4]
8000b964:	c5 6f       	rcall	8000b810 <_Balloc>
8000b966:	6e 49       	ld.w	r9,r7[0x10]
8000b968:	6c 44       	ld.w	r4,r6[0x10]
8000b96a:	99 35       	st.w	r12[0xc],r5
8000b96c:	2f b4       	sub	r4,-5
8000b96e:	f2 c5 ff fb 	sub	r5,r9,-5
8000b972:	ec 04 00 24 	add	r4,r6,r4<<0x2
8000b976:	ee 05 00 25 	add	r5,r7,r5<<0x2
8000b97a:	2e c6       	sub	r6,-20
8000b97c:	2e c7       	sub	r7,-20
8000b97e:	f8 c8 ff ec 	sub	r8,r12,-20
8000b982:	30 0a       	mov	r10,0
8000b984:	0f 0e       	ld.w	lr,r7++
8000b986:	0d 0b       	ld.w	r11,r6++
8000b988:	fc 02 16 10 	lsr	r2,lr,0x10
8000b98c:	f6 03 16 10 	lsr	r3,r11,0x10
8000b990:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000b994:	e4 03 01 03 	sub	r3,r2,r3
8000b998:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000b99c:	fc 0b 01 0b 	sub	r11,lr,r11
8000b9a0:	f6 0a 00 0a 	add	r10,r11,r10
8000b9a4:	b0 1a       	st.h	r8[0x2],r10
8000b9a6:	b1 4a       	asr	r10,0x10
8000b9a8:	e6 0a 00 0a 	add	r10,r3,r10
8000b9ac:	b0 0a       	st.h	r8[0x0],r10
8000b9ae:	2f c8       	sub	r8,-4
8000b9b0:	b1 4a       	asr	r10,0x10
8000b9b2:	08 36       	cp.w	r6,r4
8000b9b4:	ce 83       	brcs	8000b984 <__mdiff+0x64>
8000b9b6:	c0 d8       	rjmp	8000b9d0 <__mdiff+0xb0>
8000b9b8:	0f 0b       	ld.w	r11,r7++
8000b9ba:	f6 0e 16 10 	lsr	lr,r11,0x10
8000b9be:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000b9c2:	16 0a       	add	r10,r11
8000b9c4:	b0 1a       	st.h	r8[0x2],r10
8000b9c6:	b1 4a       	asr	r10,0x10
8000b9c8:	1c 0a       	add	r10,lr
8000b9ca:	b0 0a       	st.h	r8[0x0],r10
8000b9cc:	2f c8       	sub	r8,-4
8000b9ce:	b1 4a       	asr	r10,0x10
8000b9d0:	0a 37       	cp.w	r7,r5
8000b9d2:	cf 33       	brcs	8000b9b8 <__mdiff+0x98>
8000b9d4:	c0 28       	rjmp	8000b9d8 <__mdiff+0xb8>
8000b9d6:	20 19       	sub	r9,1
8000b9d8:	11 4a       	ld.w	r10,--r8
8000b9da:	58 0a       	cp.w	r10,0
8000b9dc:	cf d0       	breq	8000b9d6 <__mdiff+0xb6>
8000b9de:	99 49       	st.w	r12[0x10],r9
8000b9e0:	d8 32       	popm	r0-r7,pc
8000b9e2:	30 0b       	mov	r11,0
8000b9e4:	c1 6f       	rcall	8000b810 <_Balloc>
8000b9e6:	30 18       	mov	r8,1
8000b9e8:	99 48       	st.w	r12[0x10],r8
8000b9ea:	30 08       	mov	r8,0
8000b9ec:	99 58       	st.w	r12[0x14],r8
8000b9ee:	d8 32       	popm	r0-r7,pc

8000b9f0 <__lshift>:
8000b9f0:	d4 31       	pushm	r0-r7,lr
8000b9f2:	16 97       	mov	r7,r11
8000b9f4:	76 46       	ld.w	r6,r11[0x10]
8000b9f6:	f4 02 14 05 	asr	r2,r10,0x5
8000b9fa:	2f f6       	sub	r6,-1
8000b9fc:	14 93       	mov	r3,r10
8000b9fe:	18 94       	mov	r4,r12
8000ba00:	04 06       	add	r6,r2
8000ba02:	76 1b       	ld.w	r11,r11[0x4]
8000ba04:	6e 28       	ld.w	r8,r7[0x8]
8000ba06:	c0 38       	rjmp	8000ba0c <__lshift+0x1c>
8000ba08:	2f fb       	sub	r11,-1
8000ba0a:	a1 78       	lsl	r8,0x1
8000ba0c:	10 36       	cp.w	r6,r8
8000ba0e:	fe 99 ff fd 	brgt	8000ba08 <__lshift+0x18>
8000ba12:	08 9c       	mov	r12,r4
8000ba14:	cf ee       	rcall	8000b810 <_Balloc>
8000ba16:	30 09       	mov	r9,0
8000ba18:	18 95       	mov	r5,r12
8000ba1a:	f8 c8 ff ec 	sub	r8,r12,-20
8000ba1e:	12 9a       	mov	r10,r9
8000ba20:	c0 38       	rjmp	8000ba26 <__lshift+0x36>
8000ba22:	10 aa       	st.w	r8++,r10
8000ba24:	2f f9       	sub	r9,-1
8000ba26:	04 39       	cp.w	r9,r2
8000ba28:	cf d5       	brlt	8000ba22 <__lshift+0x32>
8000ba2a:	6e 4b       	ld.w	r11,r7[0x10]
8000ba2c:	e7 d3 c0 05 	bfextu	r3,r3,0x0,0x5
8000ba30:	2f bb       	sub	r11,-5
8000ba32:	ee c9 ff ec 	sub	r9,r7,-20
8000ba36:	ee 0b 00 2b 	add	r11,r7,r11<<0x2
8000ba3a:	58 03       	cp.w	r3,0
8000ba3c:	c1 30       	breq	8000ba62 <__lshift+0x72>
8000ba3e:	e6 0c 11 20 	rsub	r12,r3,32
8000ba42:	30 0a       	mov	r10,0
8000ba44:	72 02       	ld.w	r2,r9[0x0]
8000ba46:	e4 03 09 42 	lsl	r2,r2,r3
8000ba4a:	04 4a       	or	r10,r2
8000ba4c:	10 aa       	st.w	r8++,r10
8000ba4e:	13 0a       	ld.w	r10,r9++
8000ba50:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000ba54:	16 39       	cp.w	r9,r11
8000ba56:	cf 73       	brcs	8000ba44 <__lshift+0x54>
8000ba58:	91 0a       	st.w	r8[0x0],r10
8000ba5a:	58 0a       	cp.w	r10,0
8000ba5c:	c0 70       	breq	8000ba6a <__lshift+0x7a>
8000ba5e:	2f f6       	sub	r6,-1
8000ba60:	c0 58       	rjmp	8000ba6a <__lshift+0x7a>
8000ba62:	13 0a       	ld.w	r10,r9++
8000ba64:	10 aa       	st.w	r8++,r10
8000ba66:	16 39       	cp.w	r9,r11
8000ba68:	cf d3       	brcs	8000ba62 <__lshift+0x72>
8000ba6a:	08 9c       	mov	r12,r4
8000ba6c:	20 16       	sub	r6,1
8000ba6e:	0e 9b       	mov	r11,r7
8000ba70:	8b 46       	st.w	r5[0x10],r6
8000ba72:	cb 5e       	rcall	8000b7dc <_Bfree>
8000ba74:	0a 9c       	mov	r12,r5
8000ba76:	d8 32       	popm	r0-r7,pc

8000ba78 <__multiply>:
8000ba78:	d4 31       	pushm	r0-r7,lr
8000ba7a:	20 2d       	sub	sp,8
8000ba7c:	76 49       	ld.w	r9,r11[0x10]
8000ba7e:	74 48       	ld.w	r8,r10[0x10]
8000ba80:	16 96       	mov	r6,r11
8000ba82:	14 95       	mov	r5,r10
8000ba84:	10 39       	cp.w	r9,r8
8000ba86:	ec 08 17 50 	movlt	r8,r6
8000ba8a:	ea 06 17 50 	movlt	r6,r5
8000ba8e:	f0 05 17 50 	movlt	r5,r8
8000ba92:	6c 28       	ld.w	r8,r6[0x8]
8000ba94:	76 43       	ld.w	r3,r11[0x10]
8000ba96:	74 42       	ld.w	r2,r10[0x10]
8000ba98:	76 1b       	ld.w	r11,r11[0x4]
8000ba9a:	e4 03 00 07 	add	r7,r2,r3
8000ba9e:	10 37       	cp.w	r7,r8
8000baa0:	f7 bb 09 ff 	subgt	r11,-1
8000baa4:	cb 6e       	rcall	8000b810 <_Balloc>
8000baa6:	ee c4 ff fb 	sub	r4,r7,-5
8000baaa:	f8 c9 ff ec 	sub	r9,r12,-20
8000baae:	f8 04 00 24 	add	r4,r12,r4<<0x2
8000bab2:	30 0a       	mov	r10,0
8000bab4:	12 98       	mov	r8,r9
8000bab6:	c0 28       	rjmp	8000baba <__multiply+0x42>
8000bab8:	10 aa       	st.w	r8++,r10
8000baba:	08 38       	cp.w	r8,r4
8000babc:	cf e3       	brcs	8000bab8 <__multiply+0x40>
8000babe:	2f b3       	sub	r3,-5
8000bac0:	2f b2       	sub	r2,-5
8000bac2:	ec 03 00 23 	add	r3,r6,r3<<0x2
8000bac6:	ea 02 00 22 	add	r2,r5,r2<<0x2
8000baca:	ec cb ff ec 	sub	r11,r6,-20
8000bace:	50 12       	stdsp	sp[0x4],r2
8000bad0:	ea ca ff ec 	sub	r10,r5,-20
8000bad4:	c4 48       	rjmp	8000bb5c <__multiply+0xe4>
8000bad6:	94 95       	ld.uh	r5,r10[0x2]
8000bad8:	58 05       	cp.w	r5,0
8000bada:	c2 00       	breq	8000bb1a <__multiply+0xa2>
8000badc:	12 98       	mov	r8,r9
8000bade:	16 96       	mov	r6,r11
8000bae0:	30 0e       	mov	lr,0
8000bae2:	50 09       	stdsp	sp[0x0],r9
8000bae4:	0d 02       	ld.w	r2,r6++
8000bae6:	e4 00 16 10 	lsr	r0,r2,0x10
8000baea:	70 01       	ld.w	r1,r8[0x0]
8000baec:	70 09       	ld.w	r9,r8[0x0]
8000baee:	b1 81       	lsr	r1,0x10
8000baf0:	e5 d2 c0 10 	bfextu	r2,r2,0x0,0x10
8000baf4:	e0 05 03 41 	mac	r1,r0,r5
8000baf8:	ab 32       	mul	r2,r5
8000bafa:	e1 d9 c0 10 	bfextu	r0,r9,0x0,0x10
8000bafe:	00 02       	add	r2,r0
8000bb00:	e4 0e 00 0e 	add	lr,r2,lr
8000bb04:	b0 1e       	st.h	r8[0x2],lr
8000bb06:	b1 8e       	lsr	lr,0x10
8000bb08:	1c 01       	add	r1,lr
8000bb0a:	b0 01       	st.h	r8[0x0],r1
8000bb0c:	e2 0e 16 10 	lsr	lr,r1,0x10
8000bb10:	2f c8       	sub	r8,-4
8000bb12:	06 36       	cp.w	r6,r3
8000bb14:	ce 83       	brcs	8000bae4 <__multiply+0x6c>
8000bb16:	40 09       	lddsp	r9,sp[0x0]
8000bb18:	91 0e       	st.w	r8[0x0],lr
8000bb1a:	94 86       	ld.uh	r6,r10[0x0]
8000bb1c:	58 06       	cp.w	r6,0
8000bb1e:	c1 d0       	breq	8000bb58 <__multiply+0xe0>
8000bb20:	72 02       	ld.w	r2,r9[0x0]
8000bb22:	12 98       	mov	r8,r9
8000bb24:	16 9e       	mov	lr,r11
8000bb26:	30 05       	mov	r5,0
8000bb28:	b0 12       	st.h	r8[0x2],r2
8000bb2a:	1d 01       	ld.w	r1,lr++
8000bb2c:	90 82       	ld.uh	r2,r8[0x0]
8000bb2e:	e1 d1 c0 10 	bfextu	r0,r1,0x0,0x10
8000bb32:	ad 30       	mul	r0,r6
8000bb34:	e0 02 00 02 	add	r2,r0,r2
8000bb38:	e4 05 00 05 	add	r5,r2,r5
8000bb3c:	b0 05       	st.h	r8[0x0],r5
8000bb3e:	b1 85       	lsr	r5,0x10
8000bb40:	b1 81       	lsr	r1,0x10
8000bb42:	2f c8       	sub	r8,-4
8000bb44:	ad 31       	mul	r1,r6
8000bb46:	90 92       	ld.uh	r2,r8[0x2]
8000bb48:	e2 02 00 02 	add	r2,r1,r2
8000bb4c:	0a 02       	add	r2,r5
8000bb4e:	e4 05 16 10 	lsr	r5,r2,0x10
8000bb52:	06 3e       	cp.w	lr,r3
8000bb54:	ce a3       	brcs	8000bb28 <__multiply+0xb0>
8000bb56:	91 02       	st.w	r8[0x0],r2
8000bb58:	2f ca       	sub	r10,-4
8000bb5a:	2f c9       	sub	r9,-4
8000bb5c:	40 18       	lddsp	r8,sp[0x4]
8000bb5e:	10 3a       	cp.w	r10,r8
8000bb60:	cb b3       	brcs	8000bad6 <__multiply+0x5e>
8000bb62:	c0 28       	rjmp	8000bb66 <__multiply+0xee>
8000bb64:	20 17       	sub	r7,1
8000bb66:	58 07       	cp.w	r7,0
8000bb68:	e0 8a 00 05 	brle	8000bb72 <__multiply+0xfa>
8000bb6c:	09 48       	ld.w	r8,--r4
8000bb6e:	58 08       	cp.w	r8,0
8000bb70:	cf a0       	breq	8000bb64 <__multiply+0xec>
8000bb72:	99 47       	st.w	r12[0x10],r7
8000bb74:	2f ed       	sub	sp,-8
8000bb76:	d8 32       	popm	r0-r7,pc

8000bb78 <__i2b>:
8000bb78:	d4 21       	pushm	r4-r7,lr
8000bb7a:	16 97       	mov	r7,r11
8000bb7c:	30 1b       	mov	r11,1
8000bb7e:	c4 9e       	rcall	8000b810 <_Balloc>
8000bb80:	30 19       	mov	r9,1
8000bb82:	99 57       	st.w	r12[0x14],r7
8000bb84:	99 49       	st.w	r12[0x10],r9
8000bb86:	d8 22       	popm	r4-r7,pc

8000bb88 <__multadd>:
8000bb88:	d4 31       	pushm	r0-r7,lr
8000bb8a:	30 08       	mov	r8,0
8000bb8c:	12 95       	mov	r5,r9
8000bb8e:	16 97       	mov	r7,r11
8000bb90:	18 96       	mov	r6,r12
8000bb92:	76 44       	ld.w	r4,r11[0x10]
8000bb94:	f6 c9 ff ec 	sub	r9,r11,-20
8000bb98:	72 0b       	ld.w	r11,r9[0x0]
8000bb9a:	f6 0c 16 10 	lsr	r12,r11,0x10
8000bb9e:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000bba2:	f4 0c 02 4c 	mul	r12,r10,r12
8000bba6:	f4 0b 03 45 	mac	r5,r10,r11
8000bbaa:	f7 d5 c0 10 	bfextu	r11,r5,0x0,0x10
8000bbae:	b1 85       	lsr	r5,0x10
8000bbb0:	18 05       	add	r5,r12
8000bbb2:	ea 0c 15 10 	lsl	r12,r5,0x10
8000bbb6:	f8 0b 00 0b 	add	r11,r12,r11
8000bbba:	12 ab       	st.w	r9++,r11
8000bbbc:	2f f8       	sub	r8,-1
8000bbbe:	b1 85       	lsr	r5,0x10
8000bbc0:	08 38       	cp.w	r8,r4
8000bbc2:	ce b5       	brlt	8000bb98 <__multadd+0x10>
8000bbc4:	58 05       	cp.w	r5,0
8000bbc6:	c1 c0       	breq	8000bbfe <__multadd+0x76>
8000bbc8:	6e 28       	ld.w	r8,r7[0x8]
8000bbca:	10 34       	cp.w	r4,r8
8000bbcc:	c1 35       	brlt	8000bbf2 <__multadd+0x6a>
8000bbce:	6e 1b       	ld.w	r11,r7[0x4]
8000bbd0:	0c 9c       	mov	r12,r6
8000bbd2:	2f fb       	sub	r11,-1
8000bbd4:	c1 ee       	rcall	8000b810 <_Balloc>
8000bbd6:	6e 4a       	ld.w	r10,r7[0x10]
8000bbd8:	ee cb ff f4 	sub	r11,r7,-12
8000bbdc:	18 93       	mov	r3,r12
8000bbde:	2f ea       	sub	r10,-2
8000bbe0:	2f 4c       	sub	r12,-12
8000bbe2:	a3 6a       	lsl	r10,0x2
8000bbe4:	fe b0 de 70 	rcall	800078c4 <memcpy>
8000bbe8:	0e 9b       	mov	r11,r7
8000bbea:	0c 9c       	mov	r12,r6
8000bbec:	fe b0 fd f8 	rcall	8000b7dc <_Bfree>
8000bbf0:	06 97       	mov	r7,r3
8000bbf2:	e8 c8 ff ff 	sub	r8,r4,-1
8000bbf6:	2f b4       	sub	r4,-5
8000bbf8:	8f 48       	st.w	r7[0x10],r8
8000bbfa:	ee 04 09 25 	st.w	r7[r4<<0x2],r5
8000bbfe:	0e 9c       	mov	r12,r7
8000bc00:	d8 32       	popm	r0-r7,pc
8000bc02:	d7 03       	nop

8000bc04 <__pow5mult>:
8000bc04:	d4 31       	pushm	r0-r7,lr
8000bc06:	14 96       	mov	r6,r10
8000bc08:	18 97       	mov	r7,r12
8000bc0a:	16 94       	mov	r4,r11
8000bc0c:	f1 da c0 02 	bfextu	r8,r10,0x0,0x2
8000bc10:	c0 90       	breq	8000bc22 <__pow5mult+0x1e>
8000bc12:	20 18       	sub	r8,1
8000bc14:	fe c9 da 48 	sub	r9,pc,-9656
8000bc18:	f2 08 03 2a 	ld.w	r10,r9[r8<<0x2]
8000bc1c:	30 09       	mov	r9,0
8000bc1e:	cb 5f       	rcall	8000bb88 <__multadd>
8000bc20:	18 94       	mov	r4,r12
8000bc22:	a3 46       	asr	r6,0x2
8000bc24:	c3 40       	breq	8000bc8c <__pow5mult+0x88>
8000bc26:	6e 95       	ld.w	r5,r7[0x24]
8000bc28:	58 05       	cp.w	r5,0
8000bc2a:	c0 91       	brne	8000bc3c <__pow5mult+0x38>
8000bc2c:	31 0c       	mov	r12,16
8000bc2e:	fe b0 dc 27 	rcall	8000747c <malloc>
8000bc32:	99 35       	st.w	r12[0xc],r5
8000bc34:	8f 9c       	st.w	r7[0x24],r12
8000bc36:	99 15       	st.w	r12[0x4],r5
8000bc38:	99 25       	st.w	r12[0x8],r5
8000bc3a:	99 05       	st.w	r12[0x0],r5
8000bc3c:	6e 93       	ld.w	r3,r7[0x24]
8000bc3e:	66 25       	ld.w	r5,r3[0x8]
8000bc40:	58 05       	cp.w	r5,0
8000bc42:	c0 c1       	brne	8000bc5a <__pow5mult+0x56>
8000bc44:	e0 6b 02 71 	mov	r11,625
8000bc48:	0e 9c       	mov	r12,r7
8000bc4a:	c9 7f       	rcall	8000bb78 <__i2b>
8000bc4c:	87 2c       	st.w	r3[0x8],r12
8000bc4e:	30 08       	mov	r8,0
8000bc50:	18 95       	mov	r5,r12
8000bc52:	99 08       	st.w	r12[0x0],r8
8000bc54:	c0 38       	rjmp	8000bc5a <__pow5mult+0x56>
8000bc56:	06 9c       	mov	r12,r3
8000bc58:	18 95       	mov	r5,r12
8000bc5a:	ed b6 00 00 	bld	r6,0x0
8000bc5e:	c0 b1       	brne	8000bc74 <__pow5mult+0x70>
8000bc60:	08 9b       	mov	r11,r4
8000bc62:	0a 9a       	mov	r10,r5
8000bc64:	0e 9c       	mov	r12,r7
8000bc66:	c0 9f       	rcall	8000ba78 <__multiply>
8000bc68:	08 9b       	mov	r11,r4
8000bc6a:	18 93       	mov	r3,r12
8000bc6c:	0e 9c       	mov	r12,r7
8000bc6e:	06 94       	mov	r4,r3
8000bc70:	fe b0 fd b6 	rcall	8000b7dc <_Bfree>
8000bc74:	a1 56       	asr	r6,0x1
8000bc76:	c0 b0       	breq	8000bc8c <__pow5mult+0x88>
8000bc78:	6a 03       	ld.w	r3,r5[0x0]
8000bc7a:	58 03       	cp.w	r3,0
8000bc7c:	ce d1       	brne	8000bc56 <__pow5mult+0x52>
8000bc7e:	0a 9a       	mov	r10,r5
8000bc80:	0a 9b       	mov	r11,r5
8000bc82:	0e 9c       	mov	r12,r7
8000bc84:	cf ae       	rcall	8000ba78 <__multiply>
8000bc86:	8b 0c       	st.w	r5[0x0],r12
8000bc88:	99 03       	st.w	r12[0x0],r3
8000bc8a:	ce 7b       	rjmp	8000bc58 <__pow5mult+0x54>
8000bc8c:	08 9c       	mov	r12,r4
8000bc8e:	d8 32       	popm	r0-r7,pc

8000bc90 <__isinfd>:
8000bc90:	14 98       	mov	r8,r10
8000bc92:	fc 19 7f f0 	movh	r9,0x7ff0
8000bc96:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000bc9a:	f0 0b 11 00 	rsub	r11,r8,0
8000bc9e:	f7 e8 10 08 	or	r8,r11,r8
8000bca2:	f5 e8 13 f8 	or	r8,r10,r8>>0x1f
8000bca6:	f2 08 01 08 	sub	r8,r9,r8
8000bcaa:	f0 0c 11 00 	rsub	r12,r8,0
8000bcae:	f9 e8 10 08 	or	r8,r12,r8
8000bcb2:	f0 0c 14 1f 	asr	r12,r8,0x1f
8000bcb6:	2f fc       	sub	r12,-1
8000bcb8:	5e fc       	retal	r12

8000bcba <__isnand>:
8000bcba:	14 98       	mov	r8,r10
8000bcbc:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000bcc0:	f0 0c 11 00 	rsub	r12,r8,0
8000bcc4:	10 4c       	or	r12,r8
8000bcc6:	fc 18 7f f0 	movh	r8,0x7ff0
8000bcca:	f5 ec 13 fc 	or	r12,r10,r12>>0x1f
8000bcce:	f0 0c 01 0c 	sub	r12,r8,r12
8000bcd2:	bf 9c       	lsr	r12,0x1f
8000bcd4:	5e fc       	retal	r12
8000bcd6:	d7 03       	nop

8000bcd8 <__sclose>:
8000bcd8:	d4 01       	pushm	lr
8000bcda:	96 7b       	ld.sh	r11,r11[0xe]
8000bcdc:	c8 2c       	rcall	8000bde0 <_close_r>
8000bcde:	d8 02       	popm	pc

8000bce0 <__sseek>:
8000bce0:	d4 21       	pushm	r4-r7,lr
8000bce2:	16 97       	mov	r7,r11
8000bce4:	96 7b       	ld.sh	r11,r11[0xe]
8000bce6:	c0 3d       	rcall	8000beec <_lseek_r>
8000bce8:	8e 68       	ld.sh	r8,r7[0xc]
8000bcea:	10 99       	mov	r9,r8
8000bcec:	ad c8       	cbr	r8,0xc
8000bcee:	ad a9       	sbr	r9,0xc
8000bcf0:	5b fc       	cp.w	r12,-1
8000bcf2:	ef f8 0c 06 	st.heq	r7[0xc],r8
8000bcf6:	ef f9 1c 06 	st.hne	r7[0xc],r9
8000bcfa:	ef fc 1a 15 	st.wne	r7[0x54],r12
8000bcfe:	d8 22       	popm	r4-r7,pc

8000bd00 <__swrite>:
8000bd00:	d4 21       	pushm	r4-r7,lr
8000bd02:	96 68       	ld.sh	r8,r11[0xc]
8000bd04:	16 97       	mov	r7,r11
8000bd06:	14 95       	mov	r5,r10
8000bd08:	12 94       	mov	r4,r9
8000bd0a:	e2 18 01 00 	andl	r8,0x100,COH
8000bd0e:	18 96       	mov	r6,r12
8000bd10:	c0 50       	breq	8000bd1a <__swrite+0x1a>
8000bd12:	30 29       	mov	r9,2
8000bd14:	30 0a       	mov	r10,0
8000bd16:	96 7b       	ld.sh	r11,r11[0xe]
8000bd18:	ce ac       	rcall	8000beec <_lseek_r>
8000bd1a:	8e 68       	ld.sh	r8,r7[0xc]
8000bd1c:	ad c8       	cbr	r8,0xc
8000bd1e:	08 99       	mov	r9,r4
8000bd20:	0a 9a       	mov	r10,r5
8000bd22:	8e 7b       	ld.sh	r11,r7[0xe]
8000bd24:	0c 9c       	mov	r12,r6
8000bd26:	ae 68       	st.h	r7[0xc],r8
8000bd28:	c1 cc       	rcall	8000bd60 <_write_r>
8000bd2a:	d8 22       	popm	r4-r7,pc

8000bd2c <__sread>:
8000bd2c:	d4 21       	pushm	r4-r7,lr
8000bd2e:	16 97       	mov	r7,r11
8000bd30:	96 7b       	ld.sh	r11,r11[0xe]
8000bd32:	cf 1c       	rcall	8000bf14 <_read_r>
8000bd34:	c0 65       	brlt	8000bd40 <__sread+0x14>
8000bd36:	6f 58       	ld.w	r8,r7[0x54]
8000bd38:	18 08       	add	r8,r12
8000bd3a:	ef 48 00 54 	st.w	r7[84],r8
8000bd3e:	d8 22       	popm	r4-r7,pc
8000bd40:	8e 68       	ld.sh	r8,r7[0xc]
8000bd42:	ad c8       	cbr	r8,0xc
8000bd44:	ae 68       	st.h	r7[0xc],r8
8000bd46:	d8 22       	popm	r4-r7,pc

8000bd48 <strlen>:
8000bd48:	30 09       	mov	r9,0
8000bd4a:	18 98       	mov	r8,r12
8000bd4c:	c0 28       	rjmp	8000bd50 <strlen+0x8>
8000bd4e:	2f f8       	sub	r8,-1
8000bd50:	11 8a       	ld.ub	r10,r8[0x0]
8000bd52:	f2 0a 18 00 	cp.b	r10,r9
8000bd56:	cf c1       	brne	8000bd4e <strlen+0x6>
8000bd58:	f0 0c 01 0c 	sub	r12,r8,r12
8000bd5c:	5e fc       	retal	r12
8000bd5e:	d7 03       	nop

8000bd60 <_write_r>:
8000bd60:	d4 21       	pushm	r4-r7,lr
8000bd62:	16 98       	mov	r8,r11
8000bd64:	18 97       	mov	r7,r12
8000bd66:	10 9c       	mov	r12,r8
8000bd68:	30 08       	mov	r8,0
8000bd6a:	14 9b       	mov	r11,r10
8000bd6c:	e0 66 bf f8 	mov	r6,49144
8000bd70:	12 9a       	mov	r10,r9
8000bd72:	8d 08       	st.w	r6[0x0],r8
8000bd74:	fe b0 d1 72 	rcall	80006058 <_write>
8000bd78:	5b fc       	cp.w	r12,-1
8000bd7a:	c0 51       	brne	8000bd84 <_write_r+0x24>
8000bd7c:	6c 08       	ld.w	r8,r6[0x0]
8000bd7e:	58 08       	cp.w	r8,0
8000bd80:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000bd84:	d8 22       	popm	r4-r7,pc
8000bd86:	d7 03       	nop

8000bd88 <_calloc_r>:
8000bd88:	d4 21       	pushm	r4-r7,lr
8000bd8a:	f4 0b 02 4b 	mul	r11,r10,r11
8000bd8e:	fe b0 db 7f 	rcall	8000748c <_malloc_r>
8000bd92:	18 97       	mov	r7,r12
8000bd94:	c2 30       	breq	8000bdda <_calloc_r+0x52>
8000bd96:	f8 fa ff fc 	ld.w	r10,r12[-4]
8000bd9a:	e0 1a ff fc 	andl	r10,0xfffc
8000bd9e:	20 4a       	sub	r10,4
8000bda0:	e0 4a 00 24 	cp.w	r10,36
8000bda4:	e0 8b 00 18 	brhi	8000bdd4 <_calloc_r+0x4c>
8000bda8:	18 98       	mov	r8,r12
8000bdaa:	59 3a       	cp.w	r10,19
8000bdac:	e0 88 00 0f 	brls	8000bdca <_calloc_r+0x42>
8000bdb0:	30 09       	mov	r9,0
8000bdb2:	10 a9       	st.w	r8++,r9
8000bdb4:	10 a9       	st.w	r8++,r9
8000bdb6:	59 ba       	cp.w	r10,27
8000bdb8:	e0 88 00 09 	brls	8000bdca <_calloc_r+0x42>
8000bdbc:	10 a9       	st.w	r8++,r9
8000bdbe:	10 a9       	st.w	r8++,r9
8000bdc0:	e0 4a 00 24 	cp.w	r10,36
8000bdc4:	c0 31       	brne	8000bdca <_calloc_r+0x42>
8000bdc6:	10 a9       	st.w	r8++,r9
8000bdc8:	10 a9       	st.w	r8++,r9
8000bdca:	30 09       	mov	r9,0
8000bdcc:	10 a9       	st.w	r8++,r9
8000bdce:	91 19       	st.w	r8[0x4],r9
8000bdd0:	91 09       	st.w	r8[0x0],r9
8000bdd2:	c0 48       	rjmp	8000bdda <_calloc_r+0x52>
8000bdd4:	30 0b       	mov	r11,0
8000bdd6:	fe b0 de 1b 	rcall	80007a0c <memset>
8000bdda:	0e 9c       	mov	r12,r7
8000bddc:	d8 22       	popm	r4-r7,pc
8000bdde:	d7 03       	nop

8000bde0 <_close_r>:
8000bde0:	d4 21       	pushm	r4-r7,lr
8000bde2:	30 08       	mov	r8,0
8000bde4:	18 97       	mov	r7,r12
8000bde6:	e0 66 bf f8 	mov	r6,49144
8000bdea:	16 9c       	mov	r12,r11
8000bdec:	8d 08       	st.w	r6[0x0],r8
8000bdee:	fe b0 df b5 	rcall	80007d58 <_close>
8000bdf2:	5b fc       	cp.w	r12,-1
8000bdf4:	c0 51       	brne	8000bdfe <_close_r+0x1e>
8000bdf6:	6c 08       	ld.w	r8,r6[0x0]
8000bdf8:	58 08       	cp.w	r8,0
8000bdfa:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000bdfe:	d8 22       	popm	r4-r7,pc

8000be00 <_fclose_r>:
8000be00:	d4 21       	pushm	r4-r7,lr
8000be02:	18 96       	mov	r6,r12
8000be04:	16 97       	mov	r7,r11
8000be06:	58 0b       	cp.w	r11,0
8000be08:	c0 31       	brne	8000be0e <_fclose_r+0xe>
8000be0a:	16 95       	mov	r5,r11
8000be0c:	c5 38       	rjmp	8000beb2 <_fclose_r+0xb2>
8000be0e:	fe b0 f8 a9 	rcall	8000af60 <__sfp_lock_acquire>
8000be12:	58 06       	cp.w	r6,0
8000be14:	c0 70       	breq	8000be22 <_fclose_r+0x22>
8000be16:	6c 68       	ld.w	r8,r6[0x18]
8000be18:	58 08       	cp.w	r8,0
8000be1a:	c0 41       	brne	8000be22 <_fclose_r+0x22>
8000be1c:	0c 9c       	mov	r12,r6
8000be1e:	fe b0 f8 f3 	rcall	8000b004 <__sinit>
8000be22:	fe c8 dc fa 	sub	r8,pc,-8966
8000be26:	10 37       	cp.w	r7,r8
8000be28:	c0 31       	brne	8000be2e <_fclose_r+0x2e>
8000be2a:	6c 07       	ld.w	r7,r6[0x0]
8000be2c:	c0 c8       	rjmp	8000be44 <_fclose_r+0x44>
8000be2e:	fe c8 dc e6 	sub	r8,pc,-8986
8000be32:	10 37       	cp.w	r7,r8
8000be34:	c0 31       	brne	8000be3a <_fclose_r+0x3a>
8000be36:	6c 17       	ld.w	r7,r6[0x4]
8000be38:	c0 68       	rjmp	8000be44 <_fclose_r+0x44>
8000be3a:	fe c8 dc d2 	sub	r8,pc,-9006
8000be3e:	10 37       	cp.w	r7,r8
8000be40:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000be44:	8e 69       	ld.sh	r9,r7[0xc]
8000be46:	30 08       	mov	r8,0
8000be48:	f0 09 19 00 	cp.h	r9,r8
8000be4c:	c0 51       	brne	8000be56 <_fclose_r+0x56>
8000be4e:	fe b0 f8 8a 	rcall	8000af62 <__sfp_lock_release>
8000be52:	30 05       	mov	r5,0
8000be54:	c2 f8       	rjmp	8000beb2 <_fclose_r+0xb2>
8000be56:	0e 9b       	mov	r11,r7
8000be58:	0c 9c       	mov	r12,r6
8000be5a:	fe b0 f7 fd 	rcall	8000ae54 <_fflush_r>
8000be5e:	6e c8       	ld.w	r8,r7[0x30]
8000be60:	18 95       	mov	r5,r12
8000be62:	58 08       	cp.w	r8,0
8000be64:	c0 60       	breq	8000be70 <_fclose_r+0x70>
8000be66:	6e 8b       	ld.w	r11,r7[0x20]
8000be68:	0c 9c       	mov	r12,r6
8000be6a:	5d 18       	icall	r8
8000be6c:	f9 b5 05 ff 	movlt	r5,-1
8000be70:	8e 68       	ld.sh	r8,r7[0xc]
8000be72:	ed b8 00 07 	bld	r8,0x7
8000be76:	c0 51       	brne	8000be80 <_fclose_r+0x80>
8000be78:	6e 4b       	ld.w	r11,r7[0x10]
8000be7a:	0c 9c       	mov	r12,r6
8000be7c:	fe b0 f9 5e 	rcall	8000b138 <_free_r>
8000be80:	6e db       	ld.w	r11,r7[0x34]
8000be82:	58 0b       	cp.w	r11,0
8000be84:	c0 a0       	breq	8000be98 <_fclose_r+0x98>
8000be86:	ee c8 ff bc 	sub	r8,r7,-68
8000be8a:	10 3b       	cp.w	r11,r8
8000be8c:	c0 40       	breq	8000be94 <_fclose_r+0x94>
8000be8e:	0c 9c       	mov	r12,r6
8000be90:	fe b0 f9 54 	rcall	8000b138 <_free_r>
8000be94:	30 08       	mov	r8,0
8000be96:	8f d8       	st.w	r7[0x34],r8
8000be98:	6f 2b       	ld.w	r11,r7[0x48]
8000be9a:	58 0b       	cp.w	r11,0
8000be9c:	c0 70       	breq	8000beaa <_fclose_r+0xaa>
8000be9e:	0c 9c       	mov	r12,r6
8000bea0:	fe b0 f9 4c 	rcall	8000b138 <_free_r>
8000bea4:	30 08       	mov	r8,0
8000bea6:	ef 48 00 48 	st.w	r7[72],r8
8000beaa:	30 08       	mov	r8,0
8000beac:	ae 68       	st.h	r7[0xc],r8
8000beae:	fe b0 f8 5a 	rcall	8000af62 <__sfp_lock_release>
8000beb2:	0a 9c       	mov	r12,r5
8000beb4:	d8 22       	popm	r4-r7,pc
8000beb6:	d7 03       	nop

8000beb8 <fclose>:
8000beb8:	d4 01       	pushm	lr
8000beba:	e0 68 0a 3c 	mov	r8,2620
8000bebe:	18 9b       	mov	r11,r12
8000bec0:	70 0c       	ld.w	r12,r8[0x0]
8000bec2:	c9 ff       	rcall	8000be00 <_fclose_r>
8000bec4:	d8 02       	popm	pc
8000bec6:	d7 03       	nop

8000bec8 <_fstat_r>:
8000bec8:	d4 21       	pushm	r4-r7,lr
8000beca:	16 98       	mov	r8,r11
8000becc:	18 97       	mov	r7,r12
8000bece:	10 9c       	mov	r12,r8
8000bed0:	30 08       	mov	r8,0
8000bed2:	e0 66 bf f8 	mov	r6,49144
8000bed6:	14 9b       	mov	r11,r10
8000bed8:	8d 08       	st.w	r6[0x0],r8
8000beda:	fe b0 df 67 	rcall	80007da8 <_fstat>
8000bede:	5b fc       	cp.w	r12,-1
8000bee0:	c0 51       	brne	8000beea <_fstat_r+0x22>
8000bee2:	6c 08       	ld.w	r8,r6[0x0]
8000bee4:	58 08       	cp.w	r8,0
8000bee6:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000beea:	d8 22       	popm	r4-r7,pc

8000beec <_lseek_r>:
8000beec:	d4 21       	pushm	r4-r7,lr
8000beee:	16 98       	mov	r8,r11
8000bef0:	18 97       	mov	r7,r12
8000bef2:	10 9c       	mov	r12,r8
8000bef4:	30 08       	mov	r8,0
8000bef6:	14 9b       	mov	r11,r10
8000bef8:	e0 66 bf f8 	mov	r6,49144
8000befc:	12 9a       	mov	r10,r9
8000befe:	8d 08       	st.w	r6[0x0],r8
8000bf00:	fe b0 df 36 	rcall	80007d6c <_lseek>
8000bf04:	5b fc       	cp.w	r12,-1
8000bf06:	c0 51       	brne	8000bf10 <_lseek_r+0x24>
8000bf08:	6c 08       	ld.w	r8,r6[0x0]
8000bf0a:	58 08       	cp.w	r8,0
8000bf0c:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000bf10:	d8 22       	popm	r4-r7,pc
8000bf12:	d7 03       	nop

8000bf14 <_read_r>:
8000bf14:	d4 21       	pushm	r4-r7,lr
8000bf16:	16 98       	mov	r8,r11
8000bf18:	18 97       	mov	r7,r12
8000bf1a:	10 9c       	mov	r12,r8
8000bf1c:	30 08       	mov	r8,0
8000bf1e:	14 9b       	mov	r11,r10
8000bf20:	e0 66 bf f8 	mov	r6,49144
8000bf24:	12 9a       	mov	r10,r9
8000bf26:	8d 08       	st.w	r6[0x0],r8
8000bf28:	fe b0 d0 78 	rcall	80006018 <_read>
8000bf2c:	5b fc       	cp.w	r12,-1
8000bf2e:	c0 51       	brne	8000bf38 <_read_r+0x24>
8000bf30:	6c 08       	ld.w	r8,r6[0x0]
8000bf32:	58 08       	cp.w	r8,0
8000bf34:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000bf38:	d8 22       	popm	r4-r7,pc
8000bf3a:	d7 03       	nop

8000bf3c <__avr32_f64_mul>:
8000bf3c:	f5 eb 10 1c 	or	r12,r10,r11<<0x1
8000bf40:	e0 80 00 dc 	breq	8000c0f8 <__avr32_f64_mul_op1_zero>
8000bf44:	d4 21       	pushm	r4-r7,lr
8000bf46:	f7 e9 20 0e 	eor	lr,r11,r9
8000bf4a:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000bf4e:	30 15       	mov	r5,1
8000bf50:	c4 30       	breq	8000bfd6 <__avr32_f64_mul_op1_subnormal>
8000bf52:	ab 6b       	lsl	r11,0xa
8000bf54:	f7 ea 13 6b 	or	r11,r11,r10>>0x16
8000bf58:	ab 6a       	lsl	r10,0xa
8000bf5a:	f7 d5 d3 c2 	bfins	r11,r5,0x1e,0x2
8000bf5e:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000bf62:	c5 c0       	breq	8000c01a <__avr32_f64_mul_op2_subnormal>
8000bf64:	a1 78       	lsl	r8,0x1
8000bf66:	5c f9       	rol	r9
8000bf68:	f3 d5 d2 ab 	bfins	r9,r5,0x15,0xb
8000bf6c:	e0 47 07 ff 	cp.w	r7,2047
8000bf70:	c7 70       	breq	8000c05e <__avr32_f64_mul_op_nan_or_inf>
8000bf72:	e0 46 07 ff 	cp.w	r6,2047
8000bf76:	c7 40       	breq	8000c05e <__avr32_f64_mul_op_nan_or_inf>
8000bf78:	ee 06 00 0c 	add	r12,r7,r6
8000bf7c:	e0 2c 03 fe 	sub	r12,1022
8000bf80:	f6 08 06 44 	mulu.d	r4,r11,r8
8000bf84:	f4 09 07 44 	macu.d	r4,r10,r9
8000bf88:	f4 08 06 46 	mulu.d	r6,r10,r8
8000bf8c:	f6 09 06 4a 	mulu.d	r10,r11,r9
8000bf90:	08 07       	add	r7,r4
8000bf92:	f4 05 00 4a 	adc	r10,r10,r5
8000bf96:	5c 0b       	acr	r11
8000bf98:	ed bb 00 14 	bld	r11,0x14
8000bf9c:	c0 50       	breq	8000bfa6 <__avr32_f64_mul+0x6a>
8000bf9e:	a1 77       	lsl	r7,0x1
8000bfa0:	5c fa       	rol	r10
8000bfa2:	5c fb       	rol	r11
8000bfa4:	20 1c       	sub	r12,1
8000bfa6:	58 0c       	cp.w	r12,0
8000bfa8:	e0 8a 00 6f 	brle	8000c086 <__avr32_f64_mul_res_subnormal>
8000bfac:	e0 4c 07 ff 	cp.w	r12,2047
8000bfb0:	e0 84 00 9c 	brge	8000c0e8 <__avr32_f64_mul_res_inf>
8000bfb4:	f7 dc d2 8b 	bfins	r11,r12,0x14,0xb
8000bfb8:	ed ea 11 f6 	or	r6,r6,r10<<0x1f
8000bfbc:	ef e6 12 17 	or	r7,r7,r6>>0x1
8000bfc0:	ee 17 80 00 	eorh	r7,0x8000
8000bfc4:	f1 b7 04 20 	satu	r7,0x1
8000bfc8:	0e 0a       	add	r10,r7
8000bfca:	5c 0b       	acr	r11
8000bfcc:	ed be 00 1f 	bld	lr,0x1f
8000bfd0:	ef bb 00 1f 	bst	r11,0x1f
8000bfd4:	d8 22       	popm	r4-r7,pc

8000bfd6 <__avr32_f64_mul_op1_subnormal>:
8000bfd6:	e4 1b 00 0f 	andh	r11,0xf
8000bfda:	f4 0c 12 00 	clz	r12,r10
8000bfde:	f6 06 12 00 	clz	r6,r11
8000bfe2:	f7 bc 03 e1 	sublo	r12,-31
8000bfe6:	f8 06 17 30 	movlo	r6,r12
8000bfea:	f7 b6 02 01 	subhs	r6,1
8000bfee:	e0 46 00 20 	cp.w	r6,32
8000bff2:	c0 d4       	brge	8000c00c <__avr32_f64_mul_op1_subnormal+0x36>
8000bff4:	ec 0c 11 20 	rsub	r12,r6,32
8000bff8:	f6 06 09 4b 	lsl	r11,r11,r6
8000bffc:	f4 0c 0a 4c 	lsr	r12,r10,r12
8000c000:	18 4b       	or	r11,r12
8000c002:	f4 06 09 4a 	lsl	r10,r10,r6
8000c006:	20 b6       	sub	r6,11
8000c008:	0c 17       	sub	r7,r6
8000c00a:	ca ab       	rjmp	8000bf5e <__avr32_f64_mul+0x22>
8000c00c:	f4 06 09 4b 	lsl	r11,r10,r6
8000c010:	c6 40       	breq	8000c0d8 <__avr32_f64_mul_res_zero>
8000c012:	30 0a       	mov	r10,0
8000c014:	20 b6       	sub	r6,11
8000c016:	0c 17       	sub	r7,r6
8000c018:	ca 3b       	rjmp	8000bf5e <__avr32_f64_mul+0x22>

8000c01a <__avr32_f64_mul_op2_subnormal>:
8000c01a:	e4 19 00 0f 	andh	r9,0xf
8000c01e:	f0 0c 12 00 	clz	r12,r8
8000c022:	f2 05 12 00 	clz	r5,r9
8000c026:	f7 bc 03 ea 	sublo	r12,-22
8000c02a:	f8 05 17 30 	movlo	r5,r12
8000c02e:	f7 b5 02 0a 	subhs	r5,10
8000c032:	e0 45 00 20 	cp.w	r5,32
8000c036:	c0 d4       	brge	8000c050 <__avr32_f64_mul_op2_subnormal+0x36>
8000c038:	ea 0c 11 20 	rsub	r12,r5,32
8000c03c:	f2 05 09 49 	lsl	r9,r9,r5
8000c040:	f0 0c 0a 4c 	lsr	r12,r8,r12
8000c044:	18 49       	or	r9,r12
8000c046:	f0 05 09 48 	lsl	r8,r8,r5
8000c04a:	20 25       	sub	r5,2
8000c04c:	0a 16       	sub	r6,r5
8000c04e:	c8 fb       	rjmp	8000bf6c <__avr32_f64_mul+0x30>
8000c050:	f0 05 09 49 	lsl	r9,r8,r5
8000c054:	c4 20       	breq	8000c0d8 <__avr32_f64_mul_res_zero>
8000c056:	30 08       	mov	r8,0
8000c058:	20 25       	sub	r5,2
8000c05a:	0a 16       	sub	r6,r5
8000c05c:	c8 8b       	rjmp	8000bf6c <__avr32_f64_mul+0x30>

8000c05e <__avr32_f64_mul_op_nan_or_inf>:
8000c05e:	e4 19 00 0f 	andh	r9,0xf
8000c062:	e4 1b 00 0f 	andh	r11,0xf
8000c066:	14 4b       	or	r11,r10
8000c068:	10 49       	or	r9,r8
8000c06a:	e0 47 07 ff 	cp.w	r7,2047
8000c06e:	c0 91       	brne	8000c080 <__avr32_f64_mul_op1_not_naninf>
8000c070:	58 0b       	cp.w	r11,0
8000c072:	c3 81       	brne	8000c0e2 <__avr32_f64_mul_res_nan>
8000c074:	e0 46 07 ff 	cp.w	r6,2047
8000c078:	c3 81       	brne	8000c0e8 <__avr32_f64_mul_res_inf>
8000c07a:	58 09       	cp.w	r9,0
8000c07c:	c3 60       	breq	8000c0e8 <__avr32_f64_mul_res_inf>
8000c07e:	c3 28       	rjmp	8000c0e2 <__avr32_f64_mul_res_nan>

8000c080 <__avr32_f64_mul_op1_not_naninf>:
8000c080:	58 09       	cp.w	r9,0
8000c082:	c3 30       	breq	8000c0e8 <__avr32_f64_mul_res_inf>
8000c084:	c2 f8       	rjmp	8000c0e2 <__avr32_f64_mul_res_nan>

8000c086 <__avr32_f64_mul_res_subnormal>:
8000c086:	5c 3c       	neg	r12
8000c088:	2f fc       	sub	r12,-1
8000c08a:	f1 bc 04 c0 	satu	r12,0x6
8000c08e:	e0 4c 00 20 	cp.w	r12,32
8000c092:	c1 14       	brge	8000c0b4 <__avr32_f64_mul_res_subnormal+0x2e>
8000c094:	f8 08 11 20 	rsub	r8,r12,32
8000c098:	0e 46       	or	r6,r7
8000c09a:	ee 0c 0a 47 	lsr	r7,r7,r12
8000c09e:	f4 08 09 49 	lsl	r9,r10,r8
8000c0a2:	12 47       	or	r7,r9
8000c0a4:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000c0a8:	f6 08 09 49 	lsl	r9,r11,r8
8000c0ac:	12 4a       	or	r10,r9
8000c0ae:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000c0b2:	c8 3b       	rjmp	8000bfb8 <__avr32_f64_mul+0x7c>
8000c0b4:	f8 08 11 20 	rsub	r8,r12,32
8000c0b8:	f9 b9 00 00 	moveq	r9,0
8000c0bc:	c0 30       	breq	8000c0c2 <__avr32_f64_mul_res_subnormal+0x3c>
8000c0be:	f6 08 09 49 	lsl	r9,r11,r8
8000c0c2:	0e 46       	or	r6,r7
8000c0c4:	ed ea 10 16 	or	r6,r6,r10<<0x1
8000c0c8:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000c0cc:	f3 ea 10 07 	or	r7,r9,r10
8000c0d0:	f6 0c 0a 4a 	lsr	r10,r11,r12
8000c0d4:	30 0b       	mov	r11,0
8000c0d6:	c7 1b       	rjmp	8000bfb8 <__avr32_f64_mul+0x7c>

8000c0d8 <__avr32_f64_mul_res_zero>:
8000c0d8:	1c 9b       	mov	r11,lr
8000c0da:	e6 1b 80 00 	andh	r11,0x8000,COH
8000c0de:	30 0a       	mov	r10,0
8000c0e0:	d8 22       	popm	r4-r7,pc

8000c0e2 <__avr32_f64_mul_res_nan>:
8000c0e2:	3f fb       	mov	r11,-1
8000c0e4:	3f fa       	mov	r10,-1
8000c0e6:	d8 22       	popm	r4-r7,pc

8000c0e8 <__avr32_f64_mul_res_inf>:
8000c0e8:	f0 6b 00 00 	mov	r11,-1048576
8000c0ec:	ed be 00 1f 	bld	lr,0x1f
8000c0f0:	ef bb 00 1f 	bst	r11,0x1f
8000c0f4:	30 0a       	mov	r10,0
8000c0f6:	d8 22       	popm	r4-r7,pc

8000c0f8 <__avr32_f64_mul_op1_zero>:
8000c0f8:	f7 e9 20 0b 	eor	r11,r11,r9
8000c0fc:	e6 1b 80 00 	andh	r11,0x8000,COH
8000c100:	f9 d9 c2 8b 	bfextu	r12,r9,0x14,0xb
8000c104:	e0 4c 07 ff 	cp.w	r12,2047
8000c108:	5e 1c       	retne	r12
8000c10a:	3f fa       	mov	r10,-1
8000c10c:	3f fb       	mov	r11,-1
8000c10e:	5e fc       	retal	r12

8000c110 <__avr32_f64_sub_from_add>:
8000c110:	ee 19 80 00 	eorh	r9,0x8000

8000c114 <__avr32_f64_sub>:
8000c114:	f7 e9 20 0c 	eor	r12,r11,r9
8000c118:	e0 86 00 ca 	brmi	8000c2ac <__avr32_f64_add_from_sub>
8000c11c:	eb cd 40 e0 	pushm	r5-r7,lr
8000c120:	16 9c       	mov	r12,r11
8000c122:	e6 1c 80 00 	andh	r12,0x8000,COH
8000c126:	bf db       	cbr	r11,0x1f
8000c128:	bf d9       	cbr	r9,0x1f
8000c12a:	10 3a       	cp.w	r10,r8
8000c12c:	f2 0b 13 00 	cpc	r11,r9
8000c130:	c0 92       	brcc	8000c142 <__avr32_f64_sub+0x2e>
8000c132:	16 97       	mov	r7,r11
8000c134:	12 9b       	mov	r11,r9
8000c136:	0e 99       	mov	r9,r7
8000c138:	14 97       	mov	r7,r10
8000c13a:	10 9a       	mov	r10,r8
8000c13c:	0e 98       	mov	r8,r7
8000c13e:	ee 1c 80 00 	eorh	r12,0x8000
8000c142:	f6 07 16 14 	lsr	r7,r11,0x14
8000c146:	ab 7b       	lsl	r11,0xb
8000c148:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000c14c:	ab 7a       	lsl	r10,0xb
8000c14e:	bf bb       	sbr	r11,0x1f
8000c150:	f2 06 16 14 	lsr	r6,r9,0x14
8000c154:	c4 40       	breq	8000c1dc <__avr32_f64_sub_opL_subnormal>
8000c156:	ab 79       	lsl	r9,0xb
8000c158:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000c15c:	ab 78       	lsl	r8,0xb
8000c15e:	bf b9       	sbr	r9,0x1f

8000c160 <__avr32_f64_sub_opL_subnormal_done>:
8000c160:	e0 47 07 ff 	cp.w	r7,2047
8000c164:	c4 f0       	breq	8000c202 <__avr32_f64_sub_opH_nan_or_inf>
8000c166:	0e 26       	rsub	r6,r7
8000c168:	c1 20       	breq	8000c18c <__avr32_f64_sub_shift_done>
8000c16a:	ec 05 11 20 	rsub	r5,r6,32
8000c16e:	e0 46 00 20 	cp.w	r6,32
8000c172:	c7 c2       	brcc	8000c26a <__avr32_f64_sub_longshift>
8000c174:	f0 05 09 4e 	lsl	lr,r8,r5
8000c178:	f2 05 09 45 	lsl	r5,r9,r5
8000c17c:	f0 06 0a 48 	lsr	r8,r8,r6
8000c180:	f2 06 0a 49 	lsr	r9,r9,r6
8000c184:	0a 48       	or	r8,r5
8000c186:	58 0e       	cp.w	lr,0
8000c188:	5f 1e       	srne	lr
8000c18a:	1c 48       	or	r8,lr

8000c18c <__avr32_f64_sub_shift_done>:
8000c18c:	10 1a       	sub	r10,r8
8000c18e:	f6 09 01 4b 	sbc	r11,r11,r9
8000c192:	f6 06 12 00 	clz	r6,r11
8000c196:	c0 e0       	breq	8000c1b2 <__avr32_f64_sub_longnormalize_done>
8000c198:	c7 83       	brcs	8000c288 <__avr32_f64_sub_longnormalize>
8000c19a:	ec 0e 11 20 	rsub	lr,r6,32
8000c19e:	f6 06 09 4b 	lsl	r11,r11,r6
8000c1a2:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000c1a6:	1c 4b       	or	r11,lr
8000c1a8:	f4 06 09 4a 	lsl	r10,r10,r6
8000c1ac:	0c 17       	sub	r7,r6
8000c1ae:	e0 8a 00 39 	brle	8000c220 <__avr32_f64_sub_subnormal_result>

8000c1b2 <__avr32_f64_sub_longnormalize_done>:
8000c1b2:	f4 09 15 15 	lsl	r9,r10,0x15
8000c1b6:	ab 9a       	lsr	r10,0xb
8000c1b8:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000c1bc:	ab 9b       	lsr	r11,0xb
8000c1be:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000c1c2:	18 4b       	or	r11,r12

8000c1c4 <__avr32_f64_sub_round>:
8000c1c4:	fc 17 80 00 	movh	r7,0x8000
8000c1c8:	ed ba 00 00 	bld	r10,0x0
8000c1cc:	f7 b7 01 ff 	subne	r7,-1
8000c1d0:	0e 39       	cp.w	r9,r7
8000c1d2:	5f 29       	srhs	r9
8000c1d4:	12 0a       	add	r10,r9
8000c1d6:	5c 0b       	acr	r11
8000c1d8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c1dc <__avr32_f64_sub_opL_subnormal>:
8000c1dc:	ab 79       	lsl	r9,0xb
8000c1de:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000c1e2:	ab 78       	lsl	r8,0xb
8000c1e4:	f3 e8 10 0e 	or	lr,r9,r8
8000c1e8:	f9 b6 01 01 	movne	r6,1
8000c1ec:	ee 0e 11 00 	rsub	lr,r7,0
8000c1f0:	f9 b7 00 01 	moveq	r7,1
8000c1f4:	ef bb 00 1f 	bst	r11,0x1f
8000c1f8:	f7 ea 10 0e 	or	lr,r11,r10
8000c1fc:	f9 b7 00 00 	moveq	r7,0
8000c200:	cb 0b       	rjmp	8000c160 <__avr32_f64_sub_opL_subnormal_done>

8000c202 <__avr32_f64_sub_opH_nan_or_inf>:
8000c202:	bf db       	cbr	r11,0x1f
8000c204:	f7 ea 10 0e 	or	lr,r11,r10
8000c208:	c0 81       	brne	8000c218 <__avr32_f64_sub_return_nan>
8000c20a:	e0 46 07 ff 	cp.w	r6,2047
8000c20e:	c0 50       	breq	8000c218 <__avr32_f64_sub_return_nan>
8000c210:	f9 e7 11 4b 	or	r11,r12,r7<<0x14
8000c214:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c218 <__avr32_f64_sub_return_nan>:
8000c218:	3f fa       	mov	r10,-1
8000c21a:	3f fb       	mov	r11,-1
8000c21c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c220 <__avr32_f64_sub_subnormal_result>:
8000c220:	5c 37       	neg	r7
8000c222:	2f f7       	sub	r7,-1
8000c224:	f1 b7 04 c0 	satu	r7,0x6
8000c228:	e0 47 00 20 	cp.w	r7,32
8000c22c:	c1 14       	brge	8000c24e <__avr32_f64_sub_subnormal_result+0x2e>
8000c22e:	ee 08 11 20 	rsub	r8,r7,32
8000c232:	f4 08 09 49 	lsl	r9,r10,r8
8000c236:	5f 16       	srne	r6
8000c238:	f4 07 0a 4a 	lsr	r10,r10,r7
8000c23c:	0c 4a       	or	r10,r6
8000c23e:	f6 08 09 49 	lsl	r9,r11,r8
8000c242:	f5 e9 10 0a 	or	r10,r10,r9
8000c246:	f4 07 0a 4b 	lsr	r11,r10,r7
8000c24a:	30 07       	mov	r7,0
8000c24c:	cb 3b       	rjmp	8000c1b2 <__avr32_f64_sub_longnormalize_done>
8000c24e:	ee 08 11 40 	rsub	r8,r7,64
8000c252:	f6 08 09 49 	lsl	r9,r11,r8
8000c256:	14 49       	or	r9,r10
8000c258:	5f 16       	srne	r6
8000c25a:	f6 07 0a 4a 	lsr	r10,r11,r7
8000c25e:	0c 4a       	or	r10,r6
8000c260:	30 0b       	mov	r11,0
8000c262:	30 07       	mov	r7,0
8000c264:	ca 7b       	rjmp	8000c1b2 <__avr32_f64_sub_longnormalize_done>
8000c266:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c26a <__avr32_f64_sub_longshift>:
8000c26a:	f1 b6 04 c0 	satu	r6,0x6
8000c26e:	f0 0e 17 00 	moveq	lr,r8
8000c272:	c0 40       	breq	8000c27a <__avr32_f64_sub_longshift+0x10>
8000c274:	f2 05 09 4e 	lsl	lr,r9,r5
8000c278:	10 4e       	or	lr,r8
8000c27a:	f2 06 0a 48 	lsr	r8,r9,r6
8000c27e:	30 09       	mov	r9,0
8000c280:	58 0e       	cp.w	lr,0
8000c282:	5f 1e       	srne	lr
8000c284:	1c 48       	or	r8,lr
8000c286:	c8 3b       	rjmp	8000c18c <__avr32_f64_sub_shift_done>

8000c288 <__avr32_f64_sub_longnormalize>:
8000c288:	f4 06 12 00 	clz	r6,r10
8000c28c:	f9 b7 03 00 	movlo	r7,0
8000c290:	f9 b6 03 00 	movlo	r6,0
8000c294:	f9 bc 03 00 	movlo	r12,0
8000c298:	f7 b6 02 e0 	subhs	r6,-32
8000c29c:	f4 06 09 4b 	lsl	r11,r10,r6
8000c2a0:	30 0a       	mov	r10,0
8000c2a2:	0c 17       	sub	r7,r6
8000c2a4:	fe 9a ff be 	brle	8000c220 <__avr32_f64_sub_subnormal_result>
8000c2a8:	c8 5b       	rjmp	8000c1b2 <__avr32_f64_sub_longnormalize_done>
8000c2aa:	d7 03       	nop

8000c2ac <__avr32_f64_add_from_sub>:
8000c2ac:	ee 19 80 00 	eorh	r9,0x8000

8000c2b0 <__avr32_f64_add>:
8000c2b0:	f7 e9 20 0c 	eor	r12,r11,r9
8000c2b4:	fe 96 ff 2e 	brmi	8000c110 <__avr32_f64_sub_from_add>
8000c2b8:	eb cd 40 e0 	pushm	r5-r7,lr
8000c2bc:	16 9c       	mov	r12,r11
8000c2be:	e6 1c 80 00 	andh	r12,0x8000,COH
8000c2c2:	bf db       	cbr	r11,0x1f
8000c2c4:	bf d9       	cbr	r9,0x1f
8000c2c6:	12 3b       	cp.w	r11,r9
8000c2c8:	c0 72       	brcc	8000c2d6 <__avr32_f64_add+0x26>
8000c2ca:	16 97       	mov	r7,r11
8000c2cc:	12 9b       	mov	r11,r9
8000c2ce:	0e 99       	mov	r9,r7
8000c2d0:	14 97       	mov	r7,r10
8000c2d2:	10 9a       	mov	r10,r8
8000c2d4:	0e 98       	mov	r8,r7
8000c2d6:	30 0e       	mov	lr,0
8000c2d8:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000c2dc:	f7 db c0 14 	bfextu	r11,r11,0x0,0x14
8000c2e0:	b5 ab       	sbr	r11,0x14
8000c2e2:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000c2e6:	c6 20       	breq	8000c3aa <__avr32_f64_add_op2_subnormal>
8000c2e8:	f3 d9 c0 14 	bfextu	r9,r9,0x0,0x14
8000c2ec:	b5 a9       	sbr	r9,0x14
8000c2ee:	e0 47 07 ff 	cp.w	r7,2047
8000c2f2:	c2 80       	breq	8000c342 <__avr32_f64_add_opH_nan_or_inf>
8000c2f4:	0e 26       	rsub	r6,r7
8000c2f6:	c1 20       	breq	8000c31a <__avr32_f64_add_shift_done>
8000c2f8:	e0 46 00 36 	cp.w	r6,54
8000c2fc:	c1 52       	brcc	8000c326 <__avr32_f64_add_res_of_done>
8000c2fe:	ec 05 11 20 	rsub	r5,r6,32
8000c302:	e0 46 00 20 	cp.w	r6,32
8000c306:	c3 52       	brcc	8000c370 <__avr32_f64_add_longshift>
8000c308:	f0 05 09 4e 	lsl	lr,r8,r5
8000c30c:	f2 05 09 45 	lsl	r5,r9,r5
8000c310:	f0 06 0a 48 	lsr	r8,r8,r6
8000c314:	f2 06 0a 49 	lsr	r9,r9,r6
8000c318:	0a 48       	or	r8,r5

8000c31a <__avr32_f64_add_shift_done>:
8000c31a:	10 0a       	add	r10,r8
8000c31c:	f6 09 00 4b 	adc	r11,r11,r9
8000c320:	ed bb 00 15 	bld	r11,0x15
8000c324:	c3 40       	breq	8000c38c <__avr32_f64_add_res_of>

8000c326 <__avr32_f64_add_res_of_done>:
8000c326:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000c32a:	18 4b       	or	r11,r12

8000c32c <__avr32_f64_add_round>:
8000c32c:	f9 da c0 01 	bfextu	r12,r10,0x0,0x1
8000c330:	18 4e       	or	lr,r12
8000c332:	ee 1e 80 00 	eorh	lr,0x8000
8000c336:	f1 be 04 20 	satu	lr,0x1
8000c33a:	1c 0a       	add	r10,lr
8000c33c:	5c 0b       	acr	r11
8000c33e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c342 <__avr32_f64_add_opH_nan_or_inf>:
8000c342:	b5 cb       	cbr	r11,0x14
8000c344:	f7 ea 10 0e 	or	lr,r11,r10
8000c348:	c1 01       	brne	8000c368 <__avr32_f64_add_return_nan>
8000c34a:	e0 46 07 ff 	cp.w	r6,2047
8000c34e:	c0 30       	breq	8000c354 <__avr32_f64_add_opL_nan_or_inf>
8000c350:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c354 <__avr32_f64_add_opL_nan_or_inf>:
8000c354:	b5 c9       	cbr	r9,0x14
8000c356:	f3 e8 10 0e 	or	lr,r9,r8
8000c35a:	c0 71       	brne	8000c368 <__avr32_f64_add_return_nan>
8000c35c:	30 0a       	mov	r10,0
8000c35e:	fc 1b 7f f0 	movh	r11,0x7ff0
8000c362:	18 4b       	or	r11,r12
8000c364:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c368 <__avr32_f64_add_return_nan>:
8000c368:	3f fa       	mov	r10,-1
8000c36a:	3f fb       	mov	r11,-1
8000c36c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c370 <__avr32_f64_add_longshift>:
8000c370:	f1 b6 04 c0 	satu	r6,0x6
8000c374:	f0 0e 17 00 	moveq	lr,r8
8000c378:	c0 60       	breq	8000c384 <__avr32_f64_add_longshift+0x14>
8000c37a:	f2 05 09 4e 	lsl	lr,r9,r5
8000c37e:	58 08       	cp.w	r8,0
8000c380:	5f 18       	srne	r8
8000c382:	10 4e       	or	lr,r8
8000c384:	f2 06 0a 48 	lsr	r8,r9,r6
8000c388:	30 09       	mov	r9,0
8000c38a:	cc 8b       	rjmp	8000c31a <__avr32_f64_add_shift_done>

8000c38c <__avr32_f64_add_res_of>:
8000c38c:	fd ee 10 1e 	or	lr,lr,lr<<0x1
8000c390:	a1 9b       	lsr	r11,0x1
8000c392:	5d 0a       	ror	r10
8000c394:	5d 0e       	ror	lr
8000c396:	2f f7       	sub	r7,-1
8000c398:	e0 47 07 ff 	cp.w	r7,2047
8000c39c:	f9 ba 00 00 	moveq	r10,0
8000c3a0:	f9 bb 00 00 	moveq	r11,0
8000c3a4:	f9 be 00 00 	moveq	lr,0
8000c3a8:	cb fb       	rjmp	8000c326 <__avr32_f64_add_res_of_done>

8000c3aa <__avr32_f64_add_op2_subnormal>:
8000c3aa:	30 16       	mov	r6,1
8000c3ac:	58 07       	cp.w	r7,0
8000c3ae:	ca 01       	brne	8000c2ee <__avr32_f64_add+0x3e>
8000c3b0:	b5 cb       	cbr	r11,0x14
8000c3b2:	10 0a       	add	r10,r8
8000c3b4:	f6 09 00 4b 	adc	r11,r11,r9
8000c3b8:	18 4b       	or	r11,r12
8000c3ba:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000c3be:	d7 03       	nop

8000c3c0 <__avr32_f64_to_u32>:
8000c3c0:	58 0b       	cp.w	r11,0
8000c3c2:	5e 6d       	retmi	0

8000c3c4 <__avr32_f64_to_s32>:
8000c3c4:	f6 0c 15 01 	lsl	r12,r11,0x1
8000c3c8:	b5 9c       	lsr	r12,0x15
8000c3ca:	e0 2c 03 ff 	sub	r12,1023
8000c3ce:	5e 3d       	retlo	0
8000c3d0:	f8 0c 11 1f 	rsub	r12,r12,31
8000c3d4:	16 99       	mov	r9,r11
8000c3d6:	ab 7b       	lsl	r11,0xb
8000c3d8:	bf bb       	sbr	r11,0x1f
8000c3da:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000c3de:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000c3e2:	a1 79       	lsl	r9,0x1
8000c3e4:	5e 2b       	reths	r11
8000c3e6:	5c 3b       	neg	r11
8000c3e8:	5e fb       	retal	r11

8000c3ea <__avr32_u32_to_f64>:
8000c3ea:	f8 cb 00 00 	sub	r11,r12,0
8000c3ee:	30 0c       	mov	r12,0
8000c3f0:	c0 38       	rjmp	8000c3f6 <__avr32_s32_to_f64+0x4>

8000c3f2 <__avr32_s32_to_f64>:
8000c3f2:	18 9b       	mov	r11,r12
8000c3f4:	5c 4b       	abs	r11
8000c3f6:	30 0a       	mov	r10,0
8000c3f8:	5e 0b       	reteq	r11
8000c3fa:	d4 01       	pushm	lr
8000c3fc:	e0 69 04 1e 	mov	r9,1054
8000c400:	f6 08 12 00 	clz	r8,r11
8000c404:	c1 70       	breq	8000c432 <__avr32_s32_to_f64+0x40>
8000c406:	c0 c3       	brcs	8000c41e <__avr32_s32_to_f64+0x2c>
8000c408:	f0 0e 11 20 	rsub	lr,r8,32
8000c40c:	f6 08 09 4b 	lsl	r11,r11,r8
8000c410:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000c414:	1c 4b       	or	r11,lr
8000c416:	f4 08 09 4a 	lsl	r10,r10,r8
8000c41a:	10 19       	sub	r9,r8
8000c41c:	c0 b8       	rjmp	8000c432 <__avr32_s32_to_f64+0x40>
8000c41e:	f4 08 12 00 	clz	r8,r10
8000c422:	f9 b8 03 00 	movlo	r8,0
8000c426:	f7 b8 02 e0 	subhs	r8,-32
8000c42a:	f4 08 09 4b 	lsl	r11,r10,r8
8000c42e:	30 0a       	mov	r10,0
8000c430:	10 19       	sub	r9,r8
8000c432:	58 09       	cp.w	r9,0
8000c434:	e0 89 00 30 	brgt	8000c494 <__avr32_s32_to_f64+0xa2>
8000c438:	5c 39       	neg	r9
8000c43a:	2f f9       	sub	r9,-1
8000c43c:	e0 49 00 36 	cp.w	r9,54
8000c440:	c0 43       	brcs	8000c448 <__avr32_s32_to_f64+0x56>
8000c442:	30 0b       	mov	r11,0
8000c444:	30 0a       	mov	r10,0
8000c446:	c2 68       	rjmp	8000c492 <__avr32_s32_to_f64+0xa0>
8000c448:	2f 69       	sub	r9,-10
8000c44a:	f2 08 11 20 	rsub	r8,r9,32
8000c44e:	e0 49 00 20 	cp.w	r9,32
8000c452:	c0 b2       	brcc	8000c468 <__avr32_s32_to_f64+0x76>
8000c454:	f4 08 09 4e 	lsl	lr,r10,r8
8000c458:	f6 08 09 48 	lsl	r8,r11,r8
8000c45c:	f4 09 0a 4a 	lsr	r10,r10,r9
8000c460:	f6 09 0a 4b 	lsr	r11,r11,r9
8000c464:	10 4b       	or	r11,r8
8000c466:	c0 88       	rjmp	8000c476 <__avr32_s32_to_f64+0x84>
8000c468:	f6 08 09 4e 	lsl	lr,r11,r8
8000c46c:	14 4e       	or	lr,r10
8000c46e:	16 9a       	mov	r10,r11
8000c470:	30 0b       	mov	r11,0
8000c472:	f4 09 0a 4a 	lsr	r10,r10,r9
8000c476:	ed ba 00 00 	bld	r10,0x0
8000c47a:	c0 92       	brcc	8000c48c <__avr32_s32_to_f64+0x9a>
8000c47c:	1c 7e       	tst	lr,lr
8000c47e:	c0 41       	brne	8000c486 <__avr32_s32_to_f64+0x94>
8000c480:	ed ba 00 01 	bld	r10,0x1
8000c484:	c0 42       	brcc	8000c48c <__avr32_s32_to_f64+0x9a>
8000c486:	2f fa       	sub	r10,-1
8000c488:	f7 bb 02 ff 	subhs	r11,-1
8000c48c:	5c fc       	rol	r12
8000c48e:	5d 0b       	ror	r11
8000c490:	5d 0a       	ror	r10
8000c492:	d8 02       	popm	pc
8000c494:	e0 68 03 ff 	mov	r8,1023
8000c498:	ed ba 00 0b 	bld	r10,0xb
8000c49c:	f7 b8 00 ff 	subeq	r8,-1
8000c4a0:	10 0a       	add	r10,r8
8000c4a2:	5c 0b       	acr	r11
8000c4a4:	f7 b9 03 fe 	sublo	r9,-2
8000c4a8:	e0 49 07 ff 	cp.w	r9,2047
8000c4ac:	c0 55       	brlt	8000c4b6 <__avr32_s32_to_f64+0xc4>
8000c4ae:	30 0a       	mov	r10,0
8000c4b0:	fc 1b ff e0 	movh	r11,0xffe0
8000c4b4:	c0 c8       	rjmp	8000c4cc <__floatsidf_return_op1>
8000c4b6:	ed bb 00 1f 	bld	r11,0x1f
8000c4ba:	f7 b9 01 01 	subne	r9,1
8000c4be:	ab 9a       	lsr	r10,0xb
8000c4c0:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000c4c4:	a1 7b       	lsl	r11,0x1
8000c4c6:	ab 9b       	lsr	r11,0xb
8000c4c8:	f7 e9 11 5b 	or	r11,r11,r9<<0x15

8000c4cc <__floatsidf_return_op1>:
8000c4cc:	a1 7c       	lsl	r12,0x1
8000c4ce:	5d 0b       	ror	r11
8000c4d0:	d8 02       	popm	pc

8000c4d2 <__avr32_f64_cmp_eq>:
8000c4d2:	10 3a       	cp.w	r10,r8
8000c4d4:	f2 0b 13 00 	cpc	r11,r9
8000c4d8:	c0 80       	breq	8000c4e8 <__avr32_f64_cmp_eq+0x16>
8000c4da:	a1 7b       	lsl	r11,0x1
8000c4dc:	a1 79       	lsl	r9,0x1
8000c4de:	14 4b       	or	r11,r10
8000c4e0:	12 4b       	or	r11,r9
8000c4e2:	10 4b       	or	r11,r8
8000c4e4:	5e 0f       	reteq	1
8000c4e6:	5e fd       	retal	0
8000c4e8:	a1 7b       	lsl	r11,0x1
8000c4ea:	fc 1c ff e0 	movh	r12,0xffe0
8000c4ee:	58 0a       	cp.w	r10,0
8000c4f0:	f8 0b 13 00 	cpc	r11,r12
8000c4f4:	5e 8f       	retls	1
8000c4f6:	5e fd       	retal	0

8000c4f8 <__avr32_f64_cmp_ge>:
8000c4f8:	1a de       	st.w	--sp,lr
8000c4fa:	1a d7       	st.w	--sp,r7
8000c4fc:	a1 7b       	lsl	r11,0x1
8000c4fe:	5f 3c       	srlo	r12
8000c500:	a1 79       	lsl	r9,0x1
8000c502:	5f 37       	srlo	r7
8000c504:	5c fc       	rol	r12
8000c506:	fc 1e ff e0 	movh	lr,0xffe0
8000c50a:	58 0a       	cp.w	r10,0
8000c50c:	fc 0b 13 00 	cpc	r11,lr
8000c510:	e0 8b 00 1d 	brhi	8000c54a <__avr32_f64_cmp_ge+0x52>
8000c514:	58 08       	cp.w	r8,0
8000c516:	fc 09 13 00 	cpc	r9,lr
8000c51a:	e0 8b 00 18 	brhi	8000c54a <__avr32_f64_cmp_ge+0x52>
8000c51e:	58 0b       	cp.w	r11,0
8000c520:	f5 ba 00 00 	subfeq	r10,0
8000c524:	c1 50       	breq	8000c54e <__avr32_f64_cmp_ge+0x56>
8000c526:	1b 07       	ld.w	r7,sp++
8000c528:	1b 0e       	ld.w	lr,sp++
8000c52a:	58 3c       	cp.w	r12,3
8000c52c:	c0 a0       	breq	8000c540 <__avr32_f64_cmp_ge+0x48>
8000c52e:	58 1c       	cp.w	r12,1
8000c530:	c0 33       	brcs	8000c536 <__avr32_f64_cmp_ge+0x3e>
8000c532:	5e 0f       	reteq	1
8000c534:	5e 1d       	retne	0
8000c536:	10 3a       	cp.w	r10,r8
8000c538:	f2 0b 13 00 	cpc	r11,r9
8000c53c:	5e 2f       	reths	1
8000c53e:	5e 3d       	retlo	0
8000c540:	14 38       	cp.w	r8,r10
8000c542:	f6 09 13 00 	cpc	r9,r11
8000c546:	5e 2f       	reths	1
8000c548:	5e 3d       	retlo	0
8000c54a:	1b 07       	ld.w	r7,sp++
8000c54c:	d8 0a       	popm	pc,r12=0
8000c54e:	58 17       	cp.w	r7,1
8000c550:	5f 0c       	sreq	r12
8000c552:	58 09       	cp.w	r9,0
8000c554:	f5 b8 00 00 	subfeq	r8,0
8000c558:	1b 07       	ld.w	r7,sp++
8000c55a:	1b 0e       	ld.w	lr,sp++
8000c55c:	5e 0f       	reteq	1
8000c55e:	5e fc       	retal	r12

8000c560 <__avr32_f64_cmp_lt>:
8000c560:	1a de       	st.w	--sp,lr
8000c562:	1a d7       	st.w	--sp,r7
8000c564:	a1 7b       	lsl	r11,0x1
8000c566:	5f 3c       	srlo	r12
8000c568:	a1 79       	lsl	r9,0x1
8000c56a:	5f 37       	srlo	r7
8000c56c:	5c fc       	rol	r12
8000c56e:	fc 1e ff e0 	movh	lr,0xffe0
8000c572:	58 0a       	cp.w	r10,0
8000c574:	fc 0b 13 00 	cpc	r11,lr
8000c578:	e0 8b 00 1d 	brhi	8000c5b2 <__avr32_f64_cmp_lt+0x52>
8000c57c:	58 08       	cp.w	r8,0
8000c57e:	fc 09 13 00 	cpc	r9,lr
8000c582:	e0 8b 00 18 	brhi	8000c5b2 <__avr32_f64_cmp_lt+0x52>
8000c586:	58 0b       	cp.w	r11,0
8000c588:	f5 ba 00 00 	subfeq	r10,0
8000c58c:	c1 50       	breq	8000c5b6 <__avr32_f64_cmp_lt+0x56>
8000c58e:	1b 07       	ld.w	r7,sp++
8000c590:	1b 0e       	ld.w	lr,sp++
8000c592:	58 3c       	cp.w	r12,3
8000c594:	c0 a0       	breq	8000c5a8 <__avr32_f64_cmp_lt+0x48>
8000c596:	58 1c       	cp.w	r12,1
8000c598:	c0 33       	brcs	8000c59e <__avr32_f64_cmp_lt+0x3e>
8000c59a:	5e 0d       	reteq	0
8000c59c:	5e 1f       	retne	1
8000c59e:	10 3a       	cp.w	r10,r8
8000c5a0:	f2 0b 13 00 	cpc	r11,r9
8000c5a4:	5e 2d       	reths	0
8000c5a6:	5e 3f       	retlo	1
8000c5a8:	14 38       	cp.w	r8,r10
8000c5aa:	f6 09 13 00 	cpc	r9,r11
8000c5ae:	5e 2d       	reths	0
8000c5b0:	5e 3f       	retlo	1
8000c5b2:	1b 07       	ld.w	r7,sp++
8000c5b4:	d8 0a       	popm	pc,r12=0
8000c5b6:	58 17       	cp.w	r7,1
8000c5b8:	5f 1c       	srne	r12
8000c5ba:	58 09       	cp.w	r9,0
8000c5bc:	f5 b8 00 00 	subfeq	r8,0
8000c5c0:	1b 07       	ld.w	r7,sp++
8000c5c2:	1b 0e       	ld.w	lr,sp++
8000c5c4:	5e 0d       	reteq	0
8000c5c6:	5e fc       	retal	r12

8000c5c8 <__avr32_f64_div>:
8000c5c8:	eb cd 40 ff 	pushm	r0-r7,lr
8000c5cc:	f7 e9 20 0e 	eor	lr,r11,r9
8000c5d0:	f6 07 16 14 	lsr	r7,r11,0x14
8000c5d4:	a9 7b       	lsl	r11,0x9
8000c5d6:	f7 ea 13 7b 	or	r11,r11,r10>>0x17
8000c5da:	a9 7a       	lsl	r10,0x9
8000c5dc:	bd bb       	sbr	r11,0x1d
8000c5de:	e4 1b 3f ff 	andh	r11,0x3fff
8000c5e2:	ab d7       	cbr	r7,0xb
8000c5e4:	e0 80 00 cc 	breq	8000c77c <__avr32_f64_div_round_subnormal+0x54>
8000c5e8:	e0 47 07 ff 	cp.w	r7,2047
8000c5ec:	e0 84 00 b5 	brge	8000c756 <__avr32_f64_div_round_subnormal+0x2e>
8000c5f0:	f2 06 16 14 	lsr	r6,r9,0x14
8000c5f4:	a9 79       	lsl	r9,0x9
8000c5f6:	f3 e8 13 79 	or	r9,r9,r8>>0x17
8000c5fa:	a9 78       	lsl	r8,0x9
8000c5fc:	bd b9       	sbr	r9,0x1d
8000c5fe:	e4 19 3f ff 	andh	r9,0x3fff
8000c602:	ab d6       	cbr	r6,0xb
8000c604:	e0 80 00 e2 	breq	8000c7c8 <__avr32_f64_div_round_subnormal+0xa0>
8000c608:	e0 46 07 ff 	cp.w	r6,2047
8000c60c:	e0 84 00 b2 	brge	8000c770 <__avr32_f64_div_round_subnormal+0x48>
8000c610:	0c 17       	sub	r7,r6
8000c612:	fe 37 fc 01 	sub	r7,-1023
8000c616:	fc 1c 80 00 	movh	r12,0x8000
8000c61a:	f8 03 16 01 	lsr	r3,r12,0x1
8000c61e:	e9 d9 c3 62 	bfextu	r4,r9,0x1b,0x2
8000c622:	5c d4       	com	r4
8000c624:	e7 d4 d3 82 	bfins	r3,r4,0x1c,0x2
8000c628:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c62c:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000c630:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c634:	ea 03 15 02 	lsl	r3,r5,0x2
8000c638:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c63c:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000c640:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c644:	ea 03 15 02 	lsl	r3,r5,0x2
8000c648:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c64c:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000c650:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c654:	ea 03 15 02 	lsl	r3,r5,0x2
8000c658:	e6 08 06 40 	mulu.d	r0,r3,r8
8000c65c:	e4 09 07 40 	macu.d	r0,r2,r9
8000c660:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c664:	02 04       	add	r4,r1
8000c666:	5c 05       	acr	r5
8000c668:	a3 65       	lsl	r5,0x2
8000c66a:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000c66e:	a3 64       	lsl	r4,0x2
8000c670:	5c 34       	neg	r4
8000c672:	f8 05 01 45 	sbc	r5,r12,r5
8000c676:	e6 04 06 40 	mulu.d	r0,r3,r4
8000c67a:	e4 05 07 40 	macu.d	r0,r2,r5
8000c67e:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c682:	02 04       	add	r4,r1
8000c684:	5c 05       	acr	r5
8000c686:	ea 03 15 02 	lsl	r3,r5,0x2
8000c68a:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000c68e:	e8 02 15 02 	lsl	r2,r4,0x2
8000c692:	e6 08 06 40 	mulu.d	r0,r3,r8
8000c696:	e4 09 07 40 	macu.d	r0,r2,r9
8000c69a:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c69e:	02 04       	add	r4,r1
8000c6a0:	5c 05       	acr	r5
8000c6a2:	a3 65       	lsl	r5,0x2
8000c6a4:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000c6a8:	a3 64       	lsl	r4,0x2
8000c6aa:	5c 34       	neg	r4
8000c6ac:	f8 05 01 45 	sbc	r5,r12,r5
8000c6b0:	e6 04 06 40 	mulu.d	r0,r3,r4
8000c6b4:	e4 05 07 40 	macu.d	r0,r2,r5
8000c6b8:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c6bc:	02 04       	add	r4,r1
8000c6be:	5c 05       	acr	r5
8000c6c0:	ea 03 15 02 	lsl	r3,r5,0x2
8000c6c4:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000c6c8:	e8 02 15 02 	lsl	r2,r4,0x2
8000c6cc:	e6 0a 06 40 	mulu.d	r0,r3,r10
8000c6d0:	e4 0b 07 40 	macu.d	r0,r2,r11
8000c6d4:	e6 0b 06 42 	mulu.d	r2,r3,r11
8000c6d8:	02 02       	add	r2,r1
8000c6da:	5c 03       	acr	r3
8000c6dc:	ed b3 00 1c 	bld	r3,0x1c
8000c6e0:	c0 90       	breq	8000c6f2 <__avr32_f64_div+0x12a>
8000c6e2:	a1 72       	lsl	r2,0x1
8000c6e4:	5c f3       	rol	r3
8000c6e6:	20 17       	sub	r7,1
8000c6e8:	a3 9a       	lsr	r10,0x3
8000c6ea:	f5 eb 11 da 	or	r10,r10,r11<<0x1d
8000c6ee:	a3 9b       	lsr	r11,0x3
8000c6f0:	c0 58       	rjmp	8000c6fa <__avr32_f64_div+0x132>
8000c6f2:	a5 8a       	lsr	r10,0x4
8000c6f4:	f5 eb 11 ca 	or	r10,r10,r11<<0x1c
8000c6f8:	a5 8b       	lsr	r11,0x4
8000c6fa:	58 07       	cp.w	r7,0
8000c6fc:	e0 8a 00 8b 	brle	8000c812 <__avr32_f64_div_res_subnormal>
8000c700:	e0 12 ff 00 	andl	r2,0xff00
8000c704:	e8 12 00 80 	orl	r2,0x80
8000c708:	e6 08 06 40 	mulu.d	r0,r3,r8
8000c70c:	e4 09 07 40 	macu.d	r0,r2,r9
8000c710:	e4 08 06 44 	mulu.d	r4,r2,r8
8000c714:	e6 09 06 48 	mulu.d	r8,r3,r9
8000c718:	00 05       	add	r5,r0
8000c71a:	f0 01 00 48 	adc	r8,r8,r1
8000c71e:	5c 09       	acr	r9
8000c720:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000c724:	58 04       	cp.w	r4,0
8000c726:	5c 25       	cpc	r5

8000c728 <__avr32_f64_div_round_subnormal>:
8000c728:	f4 08 13 00 	cpc	r8,r10
8000c72c:	f6 09 13 00 	cpc	r9,r11
8000c730:	5f 36       	srlo	r6
8000c732:	f8 06 17 00 	moveq	r6,r12
8000c736:	e4 0a 16 08 	lsr	r10,r2,0x8
8000c73a:	f5 e3 11 8a 	or	r10,r10,r3<<0x18
8000c73e:	e6 0b 16 08 	lsr	r11,r3,0x8
8000c742:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000c746:	ed be 00 1f 	bld	lr,0x1f
8000c74a:	ef bb 00 1f 	bst	r11,0x1f
8000c74e:	0c 0a       	add	r10,r6
8000c750:	5c 0b       	acr	r11
8000c752:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000c756:	e4 1b 00 0f 	andh	r11,0xf
8000c75a:	14 4b       	or	r11,r10
8000c75c:	e0 81 00 a7 	brne	8000c8aa <__avr32_f64_div_res_subnormal+0x98>
8000c760:	f2 06 16 14 	lsr	r6,r9,0x14
8000c764:	ab d6       	cbr	r6,0xb
8000c766:	e0 46 07 ff 	cp.w	r6,2047
8000c76a:	e0 81 00 a4 	brne	8000c8b2 <__avr32_f64_div_res_subnormal+0xa0>
8000c76e:	c9 e8       	rjmp	8000c8aa <__avr32_f64_div_res_subnormal+0x98>
8000c770:	e4 19 00 0f 	andh	r9,0xf
8000c774:	10 49       	or	r9,r8
8000c776:	e0 81 00 9a 	brne	8000c8aa <__avr32_f64_div_res_subnormal+0x98>
8000c77a:	c9 28       	rjmp	8000c89e <__avr32_f64_div_res_subnormal+0x8c>
8000c77c:	a3 7b       	lsl	r11,0x3
8000c77e:	f7 ea 13 db 	or	r11,r11,r10>>0x1d
8000c782:	a3 7a       	lsl	r10,0x3
8000c784:	f5 eb 10 04 	or	r4,r10,r11
8000c788:	e0 80 00 a0 	breq	8000c8c8 <__avr32_f64_div_op1_zero>
8000c78c:	f6 04 12 00 	clz	r4,r11
8000c790:	c1 70       	breq	8000c7be <__avr32_f64_div_round_subnormal+0x96>
8000c792:	c0 c3       	brcs	8000c7aa <__avr32_f64_div_round_subnormal+0x82>
8000c794:	e8 05 11 20 	rsub	r5,r4,32
8000c798:	f6 04 09 4b 	lsl	r11,r11,r4
8000c79c:	f4 05 0a 45 	lsr	r5,r10,r5
8000c7a0:	0a 4b       	or	r11,r5
8000c7a2:	f4 04 09 4a 	lsl	r10,r10,r4
8000c7a6:	08 17       	sub	r7,r4
8000c7a8:	c0 b8       	rjmp	8000c7be <__avr32_f64_div_round_subnormal+0x96>
8000c7aa:	f4 04 12 00 	clz	r4,r10
8000c7ae:	f9 b4 03 00 	movlo	r4,0
8000c7b2:	f7 b4 02 e0 	subhs	r4,-32
8000c7b6:	f4 04 09 4b 	lsl	r11,r10,r4
8000c7ba:	30 0a       	mov	r10,0
8000c7bc:	08 17       	sub	r7,r4
8000c7be:	a3 8a       	lsr	r10,0x2
8000c7c0:	f5 eb 11 ea 	or	r10,r10,r11<<0x1e
8000c7c4:	a3 8b       	lsr	r11,0x2
8000c7c6:	c1 1b       	rjmp	8000c5e8 <__avr32_f64_div+0x20>
8000c7c8:	a3 79       	lsl	r9,0x3
8000c7ca:	f3 e8 13 d9 	or	r9,r9,r8>>0x1d
8000c7ce:	a3 78       	lsl	r8,0x3
8000c7d0:	f3 e8 10 04 	or	r4,r9,r8
8000c7d4:	c6 f0       	breq	8000c8b2 <__avr32_f64_div_res_subnormal+0xa0>
8000c7d6:	f2 04 12 00 	clz	r4,r9
8000c7da:	c1 70       	breq	8000c808 <__avr32_f64_div_round_subnormal+0xe0>
8000c7dc:	c0 c3       	brcs	8000c7f4 <__avr32_f64_div_round_subnormal+0xcc>
8000c7de:	e8 05 11 20 	rsub	r5,r4,32
8000c7e2:	f2 04 09 49 	lsl	r9,r9,r4
8000c7e6:	f0 05 0a 45 	lsr	r5,r8,r5
8000c7ea:	0a 49       	or	r9,r5
8000c7ec:	f0 04 09 48 	lsl	r8,r8,r4
8000c7f0:	08 16       	sub	r6,r4
8000c7f2:	c0 b8       	rjmp	8000c808 <__avr32_f64_div_round_subnormal+0xe0>
8000c7f4:	f0 04 12 00 	clz	r4,r8
8000c7f8:	f9 b4 03 00 	movlo	r4,0
8000c7fc:	f7 b4 02 e0 	subhs	r4,-32
8000c800:	f0 04 09 49 	lsl	r9,r8,r4
8000c804:	30 08       	mov	r8,0
8000c806:	08 16       	sub	r6,r4
8000c808:	a3 88       	lsr	r8,0x2
8000c80a:	f1 e9 11 e8 	or	r8,r8,r9<<0x1e
8000c80e:	a3 89       	lsr	r9,0x2
8000c810:	cf ca       	rjmp	8000c608 <__avr32_f64_div+0x40>

8000c812 <__avr32_f64_div_res_subnormal>:
8000c812:	5c 37       	neg	r7
8000c814:	2f f7       	sub	r7,-1
8000c816:	f1 b7 04 c0 	satu	r7,0x6
8000c81a:	e0 47 00 20 	cp.w	r7,32
8000c81e:	c1 54       	brge	8000c848 <__avr32_f64_div_res_subnormal+0x36>
8000c820:	ee 06 11 20 	rsub	r6,r7,32
8000c824:	e4 07 0a 42 	lsr	r2,r2,r7
8000c828:	e6 06 09 4c 	lsl	r12,r3,r6
8000c82c:	18 42       	or	r2,r12
8000c82e:	e6 07 0a 43 	lsr	r3,r3,r7
8000c832:	f4 06 09 41 	lsl	r1,r10,r6
8000c836:	f4 07 0a 4a 	lsr	r10,r10,r7
8000c83a:	f6 06 09 4c 	lsl	r12,r11,r6
8000c83e:	18 4a       	or	r10,r12
8000c840:	f6 07 0a 4b 	lsr	r11,r11,r7
8000c844:	30 00       	mov	r0,0
8000c846:	c1 58       	rjmp	8000c870 <__avr32_f64_div_res_subnormal+0x5e>
8000c848:	ee 06 11 20 	rsub	r6,r7,32
8000c84c:	f9 b0 00 00 	moveq	r0,0
8000c850:	f9 bc 00 00 	moveq	r12,0
8000c854:	c0 50       	breq	8000c85e <__avr32_f64_div_res_subnormal+0x4c>
8000c856:	f4 06 09 40 	lsl	r0,r10,r6
8000c85a:	f6 06 09 4c 	lsl	r12,r11,r6
8000c85e:	e6 07 0a 42 	lsr	r2,r3,r7
8000c862:	30 03       	mov	r3,0
8000c864:	f4 07 0a 41 	lsr	r1,r10,r7
8000c868:	18 41       	or	r1,r12
8000c86a:	f6 07 0a 4a 	lsr	r10,r11,r7
8000c86e:	30 0b       	mov	r11,0
8000c870:	e0 12 ff 00 	andl	r2,0xff00
8000c874:	e8 12 00 80 	orl	r2,0x80
8000c878:	e6 08 06 46 	mulu.d	r6,r3,r8
8000c87c:	e4 09 07 46 	macu.d	r6,r2,r9
8000c880:	e4 08 06 44 	mulu.d	r4,r2,r8
8000c884:	e6 09 06 48 	mulu.d	r8,r3,r9
8000c888:	0c 05       	add	r5,r6
8000c88a:	f0 07 00 48 	adc	r8,r8,r7
8000c88e:	5c 09       	acr	r9
8000c890:	30 07       	mov	r7,0
8000c892:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000c896:	00 34       	cp.w	r4,r0
8000c898:	e2 05 13 00 	cpc	r5,r1
8000c89c:	c4 6b       	rjmp	8000c728 <__avr32_f64_div_round_subnormal>
8000c89e:	1c 9b       	mov	r11,lr
8000c8a0:	e6 1b 80 00 	andh	r11,0x8000,COH
8000c8a4:	30 0a       	mov	r10,0
8000c8a6:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000c8aa:	3f fb       	mov	r11,-1
8000c8ac:	30 0a       	mov	r10,0
8000c8ae:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000c8b2:	f5 eb 10 04 	or	r4,r10,r11
8000c8b6:	c0 90       	breq	8000c8c8 <__avr32_f64_div_op1_zero>
8000c8b8:	1c 9b       	mov	r11,lr
8000c8ba:	e6 1b 80 00 	andh	r11,0x8000,COH
8000c8be:	ea 1b 7f f0 	orh	r11,0x7ff0
8000c8c2:	30 0a       	mov	r10,0
8000c8c4:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc

8000c8c8 <__avr32_f64_div_op1_zero>:
8000c8c8:	f1 e9 10 15 	or	r5,r8,r9<<0x1
8000c8cc:	ce f0       	breq	8000c8aa <__avr32_f64_div_res_subnormal+0x98>
8000c8ce:	e9 d9 c2 8b 	bfextu	r4,r9,0x14,0xb
8000c8d2:	e0 44 07 ff 	cp.w	r4,2047
8000c8d6:	ce 41       	brne	8000c89e <__avr32_f64_div_res_subnormal+0x8c>
8000c8d8:	f1 e9 10 c5 	or	r5,r8,r9<<0xc
8000c8dc:	ce 10       	breq	8000c89e <__avr32_f64_div_res_subnormal+0x8c>
8000c8de:	ce 6b       	rjmp	8000c8aa <__avr32_f64_div_res_subnormal+0x98>

8000c8e0 <__avr32_udiv64>:
8000c8e0:	d4 31       	pushm	r0-r7,lr
8000c8e2:	1a 97       	mov	r7,sp
8000c8e4:	20 3d       	sub	sp,12
8000c8e6:	10 9c       	mov	r12,r8
8000c8e8:	12 9e       	mov	lr,r9
8000c8ea:	14 93       	mov	r3,r10
8000c8ec:	58 09       	cp.w	r9,0
8000c8ee:	e0 81 00 bd 	brne	8000ca68 <__avr32_udiv64+0x188>
8000c8f2:	16 38       	cp.w	r8,r11
8000c8f4:	e0 88 00 40 	brls	8000c974 <__avr32_udiv64+0x94>
8000c8f8:	f0 08 12 00 	clz	r8,r8
8000c8fc:	c0 d0       	breq	8000c916 <__avr32_udiv64+0x36>
8000c8fe:	f6 08 09 4b 	lsl	r11,r11,r8
8000c902:	f0 09 11 20 	rsub	r9,r8,32
8000c906:	f8 08 09 4c 	lsl	r12,r12,r8
8000c90a:	f4 09 0a 49 	lsr	r9,r10,r9
8000c90e:	f4 08 09 43 	lsl	r3,r10,r8
8000c912:	f3 eb 10 0b 	or	r11,r9,r11
8000c916:	f8 0e 16 10 	lsr	lr,r12,0x10
8000c91a:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000c91e:	f6 0e 0d 00 	divu	r0,r11,lr
8000c922:	e6 0b 16 10 	lsr	r11,r3,0x10
8000c926:	00 99       	mov	r9,r0
8000c928:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c92c:	e0 0a 02 48 	mul	r8,r0,r10
8000c930:	10 3b       	cp.w	r11,r8
8000c932:	c0 a2       	brcc	8000c946 <__avr32_udiv64+0x66>
8000c934:	20 19       	sub	r9,1
8000c936:	18 0b       	add	r11,r12
8000c938:	18 3b       	cp.w	r11,r12
8000c93a:	c0 63       	brcs	8000c946 <__avr32_udiv64+0x66>
8000c93c:	10 3b       	cp.w	r11,r8
8000c93e:	f7 b9 03 01 	sublo	r9,1
8000c942:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c946:	f6 08 01 01 	sub	r1,r11,r8
8000c94a:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000c94e:	e2 0e 0d 00 	divu	r0,r1,lr
8000c952:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000c956:	00 98       	mov	r8,r0
8000c958:	e0 0a 02 4a 	mul	r10,r0,r10
8000c95c:	14 33       	cp.w	r3,r10
8000c95e:	c0 82       	brcc	8000c96e <__avr32_udiv64+0x8e>
8000c960:	20 18       	sub	r8,1
8000c962:	18 03       	add	r3,r12
8000c964:	18 33       	cp.w	r3,r12
8000c966:	c0 43       	brcs	8000c96e <__avr32_udiv64+0x8e>
8000c968:	14 33       	cp.w	r3,r10
8000c96a:	f7 b8 03 01 	sublo	r8,1
8000c96e:	f1 e9 11 08 	or	r8,r8,r9<<0x10
8000c972:	cd f8       	rjmp	8000cb30 <__avr32_udiv64+0x250>
8000c974:	58 08       	cp.w	r8,0
8000c976:	c0 51       	brne	8000c980 <__avr32_udiv64+0xa0>
8000c978:	30 19       	mov	r9,1
8000c97a:	f2 08 0d 08 	divu	r8,r9,r8
8000c97e:	10 9c       	mov	r12,r8
8000c980:	f8 06 12 00 	clz	r6,r12
8000c984:	c0 41       	brne	8000c98c <__avr32_udiv64+0xac>
8000c986:	18 1b       	sub	r11,r12
8000c988:	30 19       	mov	r9,1
8000c98a:	c4 08       	rjmp	8000ca0a <__avr32_udiv64+0x12a>
8000c98c:	ec 01 11 20 	rsub	r1,r6,32
8000c990:	f4 01 0a 49 	lsr	r9,r10,r1
8000c994:	f8 06 09 4c 	lsl	r12,r12,r6
8000c998:	f6 06 09 48 	lsl	r8,r11,r6
8000c99c:	f6 01 0a 41 	lsr	r1,r11,r1
8000c9a0:	f3 e8 10 08 	or	r8,r9,r8
8000c9a4:	f8 03 16 10 	lsr	r3,r12,0x10
8000c9a8:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000c9ac:	e2 03 0d 00 	divu	r0,r1,r3
8000c9b0:	f0 0b 16 10 	lsr	r11,r8,0x10
8000c9b4:	00 9e       	mov	lr,r0
8000c9b6:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c9ba:	e0 05 02 49 	mul	r9,r0,r5
8000c9be:	12 3b       	cp.w	r11,r9
8000c9c0:	c0 a2       	brcc	8000c9d4 <__avr32_udiv64+0xf4>
8000c9c2:	20 1e       	sub	lr,1
8000c9c4:	18 0b       	add	r11,r12
8000c9c6:	18 3b       	cp.w	r11,r12
8000c9c8:	c0 63       	brcs	8000c9d4 <__avr32_udiv64+0xf4>
8000c9ca:	12 3b       	cp.w	r11,r9
8000c9cc:	f7 be 03 01 	sublo	lr,1
8000c9d0:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c9d4:	12 1b       	sub	r11,r9
8000c9d6:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
8000c9da:	f6 03 0d 02 	divu	r2,r11,r3
8000c9de:	f1 e3 11 08 	or	r8,r8,r3<<0x10
8000c9e2:	04 99       	mov	r9,r2
8000c9e4:	e4 05 02 4b 	mul	r11,r2,r5
8000c9e8:	16 38       	cp.w	r8,r11
8000c9ea:	c0 a2       	brcc	8000c9fe <__avr32_udiv64+0x11e>
8000c9ec:	20 19       	sub	r9,1
8000c9ee:	18 08       	add	r8,r12
8000c9f0:	18 38       	cp.w	r8,r12
8000c9f2:	c0 63       	brcs	8000c9fe <__avr32_udiv64+0x11e>
8000c9f4:	16 38       	cp.w	r8,r11
8000c9f6:	f7 b9 03 01 	sublo	r9,1
8000c9fa:	f1 dc e3 08 	addcs	r8,r8,r12
8000c9fe:	f4 06 09 43 	lsl	r3,r10,r6
8000ca02:	f0 0b 01 0b 	sub	r11,r8,r11
8000ca06:	f3 ee 11 09 	or	r9,r9,lr<<0x10
8000ca0a:	f8 06 16 10 	lsr	r6,r12,0x10
8000ca0e:	fd dc c0 10 	bfextu	lr,r12,0x0,0x10
8000ca12:	f6 06 0d 00 	divu	r0,r11,r6
8000ca16:	e6 0b 16 10 	lsr	r11,r3,0x10
8000ca1a:	00 9a       	mov	r10,r0
8000ca1c:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000ca20:	e0 0e 02 48 	mul	r8,r0,lr
8000ca24:	10 3b       	cp.w	r11,r8
8000ca26:	c0 a2       	brcc	8000ca3a <__avr32_udiv64+0x15a>
8000ca28:	20 1a       	sub	r10,1
8000ca2a:	18 0b       	add	r11,r12
8000ca2c:	18 3b       	cp.w	r11,r12
8000ca2e:	c0 63       	brcs	8000ca3a <__avr32_udiv64+0x15a>
8000ca30:	10 3b       	cp.w	r11,r8
8000ca32:	f7 ba 03 01 	sublo	r10,1
8000ca36:	f7 dc e3 0b 	addcs	r11,r11,r12
8000ca3a:	f6 08 01 01 	sub	r1,r11,r8
8000ca3e:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000ca42:	e2 06 0d 00 	divu	r0,r1,r6
8000ca46:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000ca4a:	00 98       	mov	r8,r0
8000ca4c:	e0 0e 02 4b 	mul	r11,r0,lr
8000ca50:	16 33       	cp.w	r3,r11
8000ca52:	c0 82       	brcc	8000ca62 <__avr32_udiv64+0x182>
8000ca54:	20 18       	sub	r8,1
8000ca56:	18 03       	add	r3,r12
8000ca58:	18 33       	cp.w	r3,r12
8000ca5a:	c0 43       	brcs	8000ca62 <__avr32_udiv64+0x182>
8000ca5c:	16 33       	cp.w	r3,r11
8000ca5e:	f7 b8 03 01 	sublo	r8,1
8000ca62:	f1 ea 11 08 	or	r8,r8,r10<<0x10
8000ca66:	c6 98       	rjmp	8000cb38 <__avr32_udiv64+0x258>
8000ca68:	16 39       	cp.w	r9,r11
8000ca6a:	e0 8b 00 65 	brhi	8000cb34 <__avr32_udiv64+0x254>
8000ca6e:	f2 09 12 00 	clz	r9,r9
8000ca72:	c0 b1       	brne	8000ca88 <__avr32_udiv64+0x1a8>
8000ca74:	10 3a       	cp.w	r10,r8
8000ca76:	5f 2a       	srhs	r10
8000ca78:	1c 3b       	cp.w	r11,lr
8000ca7a:	5f b8       	srhi	r8
8000ca7c:	10 4a       	or	r10,r8
8000ca7e:	f2 0a 18 00 	cp.b	r10,r9
8000ca82:	c5 90       	breq	8000cb34 <__avr32_udiv64+0x254>
8000ca84:	30 18       	mov	r8,1
8000ca86:	c5 98       	rjmp	8000cb38 <__avr32_udiv64+0x258>
8000ca88:	f0 09 09 46 	lsl	r6,r8,r9
8000ca8c:	f2 03 11 20 	rsub	r3,r9,32
8000ca90:	fc 09 09 4e 	lsl	lr,lr,r9
8000ca94:	f0 03 0a 48 	lsr	r8,r8,r3
8000ca98:	f6 09 09 4c 	lsl	r12,r11,r9
8000ca9c:	f4 03 0a 42 	lsr	r2,r10,r3
8000caa0:	ef 46 ff f4 	st.w	r7[-12],r6
8000caa4:	f6 03 0a 43 	lsr	r3,r11,r3
8000caa8:	18 42       	or	r2,r12
8000caaa:	f1 ee 10 0c 	or	r12,r8,lr
8000caae:	f8 01 16 10 	lsr	r1,r12,0x10
8000cab2:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000cab6:	e6 01 0d 04 	divu	r4,r3,r1
8000caba:	e4 03 16 10 	lsr	r3,r2,0x10
8000cabe:	08 9e       	mov	lr,r4
8000cac0:	e7 e5 11 03 	or	r3,r3,r5<<0x10
8000cac4:	e8 06 02 48 	mul	r8,r4,r6
8000cac8:	10 33       	cp.w	r3,r8
8000caca:	c0 a2       	brcc	8000cade <__avr32_udiv64+0x1fe>
8000cacc:	20 1e       	sub	lr,1
8000cace:	18 03       	add	r3,r12
8000cad0:	18 33       	cp.w	r3,r12
8000cad2:	c0 63       	brcs	8000cade <__avr32_udiv64+0x1fe>
8000cad4:	10 33       	cp.w	r3,r8
8000cad6:	f7 be 03 01 	sublo	lr,1
8000cada:	e7 dc e3 03 	addcs	r3,r3,r12
8000cade:	10 13       	sub	r3,r8
8000cae0:	f7 d2 c0 10 	bfextu	r11,r2,0x0,0x10
8000cae4:	e6 01 0d 00 	divu	r0,r3,r1
8000cae8:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000caec:	00 98       	mov	r8,r0
8000caee:	e0 06 02 46 	mul	r6,r0,r6
8000caf2:	0c 3b       	cp.w	r11,r6
8000caf4:	c0 a2       	brcc	8000cb08 <__avr32_udiv64+0x228>
8000caf6:	20 18       	sub	r8,1
8000caf8:	18 0b       	add	r11,r12
8000cafa:	18 3b       	cp.w	r11,r12
8000cafc:	c0 63       	brcs	8000cb08 <__avr32_udiv64+0x228>
8000cafe:	0c 3b       	cp.w	r11,r6
8000cb00:	f7 dc e3 0b 	addcs	r11,r11,r12
8000cb04:	f7 b8 03 01 	sublo	r8,1
8000cb08:	f1 ee 11 08 	or	r8,r8,lr<<0x10
8000cb0c:	ee f4 ff f4 	ld.w	r4,r7[-12]
8000cb10:	0c 1b       	sub	r11,r6
8000cb12:	f0 04 06 42 	mulu.d	r2,r8,r4
8000cb16:	06 95       	mov	r5,r3
8000cb18:	16 35       	cp.w	r5,r11
8000cb1a:	e0 8b 00 0a 	brhi	8000cb2e <__avr32_udiv64+0x24e>
8000cb1e:	5f 0b       	sreq	r11
8000cb20:	f4 09 09 49 	lsl	r9,r10,r9
8000cb24:	12 32       	cp.w	r2,r9
8000cb26:	5f b9       	srhi	r9
8000cb28:	f7 e9 00 09 	and	r9,r11,r9
8000cb2c:	c0 60       	breq	8000cb38 <__avr32_udiv64+0x258>
8000cb2e:	20 18       	sub	r8,1
8000cb30:	30 09       	mov	r9,0
8000cb32:	c0 38       	rjmp	8000cb38 <__avr32_udiv64+0x258>
8000cb34:	30 09       	mov	r9,0
8000cb36:	12 98       	mov	r8,r9
8000cb38:	10 9a       	mov	r10,r8
8000cb3a:	12 93       	mov	r3,r9
8000cb3c:	10 92       	mov	r2,r8
8000cb3e:	12 9b       	mov	r11,r9
8000cb40:	2f dd       	sub	sp,-12
8000cb42:	d8 32       	popm	r0-r7,pc

8000cb44 <__avr32_umod64>:
8000cb44:	d4 31       	pushm	r0-r7,lr
8000cb46:	1a 97       	mov	r7,sp
8000cb48:	20 3d       	sub	sp,12
8000cb4a:	10 9c       	mov	r12,r8
8000cb4c:	12 95       	mov	r5,r9
8000cb4e:	14 9e       	mov	lr,r10
8000cb50:	16 91       	mov	r1,r11
8000cb52:	16 96       	mov	r6,r11
8000cb54:	58 09       	cp.w	r9,0
8000cb56:	e0 81 00 81 	brne	8000cc58 <__avr32_umod64+0x114>
8000cb5a:	16 38       	cp.w	r8,r11
8000cb5c:	e0 88 00 12 	brls	8000cb80 <__avr32_umod64+0x3c>
8000cb60:	f0 08 12 00 	clz	r8,r8
8000cb64:	c4 e0       	breq	8000cc00 <__avr32_umod64+0xbc>
8000cb66:	f6 08 09 46 	lsl	r6,r11,r8
8000cb6a:	f8 08 09 4c 	lsl	r12,r12,r8
8000cb6e:	f0 0b 11 20 	rsub	r11,r8,32
8000cb72:	f4 08 09 4e 	lsl	lr,r10,r8
8000cb76:	f4 0b 0a 4b 	lsr	r11,r10,r11
8000cb7a:	f7 e6 10 06 	or	r6,r11,r6
8000cb7e:	c4 18       	rjmp	8000cc00 <__avr32_umod64+0xbc>
8000cb80:	58 08       	cp.w	r8,0
8000cb82:	c0 51       	brne	8000cb8c <__avr32_umod64+0x48>
8000cb84:	30 19       	mov	r9,1
8000cb86:	f2 08 0d 08 	divu	r8,r9,r8
8000cb8a:	10 9c       	mov	r12,r8
8000cb8c:	f8 08 12 00 	clz	r8,r12
8000cb90:	c0 31       	brne	8000cb96 <__avr32_umod64+0x52>
8000cb92:	18 16       	sub	r6,r12
8000cb94:	c3 68       	rjmp	8000cc00 <__avr32_umod64+0xbc>
8000cb96:	f0 03 11 20 	rsub	r3,r8,32
8000cb9a:	f4 03 0a 4b 	lsr	r11,r10,r3
8000cb9e:	f8 08 09 4c 	lsl	r12,r12,r8
8000cba2:	ec 08 09 49 	lsl	r9,r6,r8
8000cba6:	ec 03 0a 43 	lsr	r3,r6,r3
8000cbaa:	f7 e9 10 09 	or	r9,r11,r9
8000cbae:	f8 05 16 10 	lsr	r5,r12,0x10
8000cbb2:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000cbb6:	e6 05 0d 02 	divu	r2,r3,r5
8000cbba:	f2 0e 16 10 	lsr	lr,r9,0x10
8000cbbe:	ec 02 02 4b 	mul	r11,r6,r2
8000cbc2:	fd e3 11 0e 	or	lr,lr,r3<<0x10
8000cbc6:	16 3e       	cp.w	lr,r11
8000cbc8:	c0 72       	brcc	8000cbd6 <__avr32_umod64+0x92>
8000cbca:	18 0e       	add	lr,r12
8000cbcc:	18 3e       	cp.w	lr,r12
8000cbce:	c0 43       	brcs	8000cbd6 <__avr32_umod64+0x92>
8000cbd0:	16 3e       	cp.w	lr,r11
8000cbd2:	fd dc e3 0e 	addcs	lr,lr,r12
8000cbd6:	fc 0b 01 03 	sub	r3,lr,r11
8000cbda:	f3 d9 c0 10 	bfextu	r9,r9,0x0,0x10
8000cbde:	e6 05 0d 02 	divu	r2,r3,r5
8000cbe2:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000cbe6:	a5 36       	mul	r6,r2
8000cbe8:	0c 39       	cp.w	r9,r6
8000cbea:	c0 72       	brcc	8000cbf8 <__avr32_umod64+0xb4>
8000cbec:	18 09       	add	r9,r12
8000cbee:	18 39       	cp.w	r9,r12
8000cbf0:	c0 43       	brcs	8000cbf8 <__avr32_umod64+0xb4>
8000cbf2:	0c 39       	cp.w	r9,r6
8000cbf4:	f3 dc e3 09 	addcs	r9,r9,r12
8000cbf8:	f2 06 01 06 	sub	r6,r9,r6
8000cbfc:	f4 08 09 4e 	lsl	lr,r10,r8
8000cc00:	f8 0a 16 10 	lsr	r10,r12,0x10
8000cc04:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000cc08:	ec 0a 0d 02 	divu	r2,r6,r10
8000cc0c:	fc 09 16 10 	lsr	r9,lr,0x10
8000cc10:	ea 02 02 4b 	mul	r11,r5,r2
8000cc14:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000cc18:	16 39       	cp.w	r9,r11
8000cc1a:	c0 72       	brcc	8000cc28 <__avr32_umod64+0xe4>
8000cc1c:	18 09       	add	r9,r12
8000cc1e:	18 39       	cp.w	r9,r12
8000cc20:	c0 43       	brcs	8000cc28 <__avr32_umod64+0xe4>
8000cc22:	16 39       	cp.w	r9,r11
8000cc24:	f3 dc e3 09 	addcs	r9,r9,r12
8000cc28:	f2 0b 01 0b 	sub	r11,r9,r11
8000cc2c:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000cc30:	f6 0a 0d 0a 	divu	r10,r11,r10
8000cc34:	fd eb 11 0e 	or	lr,lr,r11<<0x10
8000cc38:	ea 0a 02 4a 	mul	r10,r5,r10
8000cc3c:	14 3e       	cp.w	lr,r10
8000cc3e:	c0 72       	brcc	8000cc4c <__avr32_umod64+0x108>
8000cc40:	18 0e       	add	lr,r12
8000cc42:	18 3e       	cp.w	lr,r12
8000cc44:	c0 43       	brcs	8000cc4c <__avr32_umod64+0x108>
8000cc46:	14 3e       	cp.w	lr,r10
8000cc48:	fd dc e3 0e 	addcs	lr,lr,r12
8000cc4c:	fc 0a 01 0a 	sub	r10,lr,r10
8000cc50:	30 0b       	mov	r11,0
8000cc52:	f4 08 0a 4a 	lsr	r10,r10,r8
8000cc56:	c7 b8       	rjmp	8000cd4c <__avr32_umod64+0x208>
8000cc58:	16 39       	cp.w	r9,r11
8000cc5a:	e0 8b 00 79 	brhi	8000cd4c <__avr32_umod64+0x208>
8000cc5e:	f2 09 12 00 	clz	r9,r9
8000cc62:	c1 21       	brne	8000cc86 <__avr32_umod64+0x142>
8000cc64:	10 3a       	cp.w	r10,r8
8000cc66:	5f 2b       	srhs	r11
8000cc68:	0a 31       	cp.w	r1,r5
8000cc6a:	5f ba       	srhi	r10
8000cc6c:	f7 ea 10 0a 	or	r10,r11,r10
8000cc70:	f2 0a 18 00 	cp.b	r10,r9
8000cc74:	c0 60       	breq	8000cc80 <__avr32_umod64+0x13c>
8000cc76:	fc 08 01 0c 	sub	r12,lr,r8
8000cc7a:	e2 05 01 46 	sbc	r6,r1,r5
8000cc7e:	18 9e       	mov	lr,r12
8000cc80:	0c 9b       	mov	r11,r6
8000cc82:	1c 9a       	mov	r10,lr
8000cc84:	c6 48       	rjmp	8000cd4c <__avr32_umod64+0x208>
8000cc86:	ea 09 09 4c 	lsl	r12,r5,r9
8000cc8a:	f2 06 11 20 	rsub	r6,r9,32
8000cc8e:	f6 09 09 4b 	lsl	r11,r11,r9
8000cc92:	f0 09 09 42 	lsl	r2,r8,r9
8000cc96:	ef 46 ff f4 	st.w	r7[-12],r6
8000cc9a:	f0 06 0a 48 	lsr	r8,r8,r6
8000cc9e:	18 48       	or	r8,r12
8000cca0:	e2 06 0a 4c 	lsr	r12,r1,r6
8000cca4:	f4 09 09 43 	lsl	r3,r10,r9
8000cca8:	fd d8 c0 10 	bfextu	lr,r8,0x0,0x10
8000ccac:	f4 06 0a 4a 	lsr	r10,r10,r6
8000ccb0:	16 4a       	or	r10,r11
8000ccb2:	f0 0b 16 10 	lsr	r11,r8,0x10
8000ccb6:	f8 0b 0d 04 	divu	r4,r12,r11
8000ccba:	f4 0c 16 10 	lsr	r12,r10,0x10
8000ccbe:	08 91       	mov	r1,r4
8000ccc0:	f9 e5 11 0c 	or	r12,r12,r5<<0x10
8000ccc4:	e8 0e 02 46 	mul	r6,r4,lr
8000ccc8:	0c 3c       	cp.w	r12,r6
8000ccca:	c0 a2       	brcc	8000ccde <__avr32_umod64+0x19a>
8000cccc:	20 11       	sub	r1,1
8000ccce:	10 0c       	add	r12,r8
8000ccd0:	10 3c       	cp.w	r12,r8
8000ccd2:	c0 63       	brcs	8000ccde <__avr32_umod64+0x19a>
8000ccd4:	0c 3c       	cp.w	r12,r6
8000ccd6:	f7 b1 03 01 	sublo	r1,1
8000ccda:	f9 d8 e3 0c 	addcs	r12,r12,r8
8000ccde:	0c 1c       	sub	r12,r6
8000cce0:	f5 da c0 10 	bfextu	r10,r10,0x0,0x10
8000cce4:	f8 0b 0d 04 	divu	r4,r12,r11
8000cce8:	f5 e5 11 0b 	or	r11,r10,r5<<0x10
8000ccec:	08 96       	mov	r6,r4
8000ccee:	e8 0e 02 4e 	mul	lr,r4,lr
8000ccf2:	1c 3b       	cp.w	r11,lr
8000ccf4:	c0 a2       	brcc	8000cd08 <__avr32_umod64+0x1c4>
8000ccf6:	20 16       	sub	r6,1
8000ccf8:	10 0b       	add	r11,r8
8000ccfa:	10 3b       	cp.w	r11,r8
8000ccfc:	c0 63       	brcs	8000cd08 <__avr32_umod64+0x1c4>
8000ccfe:	1c 3b       	cp.w	r11,lr
8000cd00:	f7 b6 03 01 	sublo	r6,1
8000cd04:	f7 d8 e3 0b 	addcs	r11,r11,r8
8000cd08:	ed e1 11 01 	or	r1,r6,r1<<0x10
8000cd0c:	1c 1b       	sub	r11,lr
8000cd0e:	e2 02 06 40 	mulu.d	r0,r1,r2
8000cd12:	00 9e       	mov	lr,r0
8000cd14:	02 9c       	mov	r12,r1
8000cd16:	16 3c       	cp.w	r12,r11
8000cd18:	e0 8b 00 08 	brhi	8000cd28 <__avr32_umod64+0x1e4>
8000cd1c:	5f 06       	sreq	r6
8000cd1e:	06 30       	cp.w	r0,r3
8000cd20:	5f ba       	srhi	r10
8000cd22:	ed ea 00 0a 	and	r10,r6,r10
8000cd26:	c0 60       	breq	8000cd32 <__avr32_umod64+0x1ee>
8000cd28:	fc 02 01 04 	sub	r4,lr,r2
8000cd2c:	f8 08 01 4c 	sbc	r12,r12,r8
8000cd30:	08 9e       	mov	lr,r4
8000cd32:	e6 0e 01 0a 	sub	r10,r3,lr
8000cd36:	f6 0c 01 4c 	sbc	r12,r11,r12
8000cd3a:	ee f1 ff f4 	ld.w	r1,r7[-12]
8000cd3e:	f8 09 0a 4b 	lsr	r11,r12,r9
8000cd42:	f4 09 0a 4a 	lsr	r10,r10,r9
8000cd46:	f8 01 09 4c 	lsl	r12,r12,r1
8000cd4a:	18 4a       	or	r10,r12
8000cd4c:	2f dd       	sub	sp,-12
8000cd4e:	d8 32       	popm	r0-r7,pc

Disassembly of section .exception:

8000ce00 <_evba>:
_evba:

        .org  0x000
        // Unrecoverable Exception.
_handle_Unrecoverable_Exception:
        rjmp $
8000ce00:	c0 08       	rjmp	8000ce00 <_evba>
	...

8000ce04 <_handle_TLB_Multiple_Hit>:

        .org  0x004
        // TLB Multiple Hit: UNUSED IN AVR32UC.
_handle_TLB_Multiple_Hit:
        rjmp $
8000ce04:	c0 08       	rjmp	8000ce04 <_handle_TLB_Multiple_Hit>
	...

8000ce08 <_handle_Bus_Error_Data_Fetch>:

        .org  0x008
        // Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
        rjmp $
8000ce08:	c0 08       	rjmp	8000ce08 <_handle_Bus_Error_Data_Fetch>
	...

8000ce0c <_handle_Bus_Error_Instruction_Fetch>:

        .org  0x00C
         // Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
        rjmp $
8000ce0c:	c0 08       	rjmp	8000ce0c <_handle_Bus_Error_Instruction_Fetch>
	...

8000ce10 <_handle_NMI>:

        .org  0x010
        // NMI.
_handle_NMI:
        rjmp $
8000ce10:	c0 08       	rjmp	8000ce10 <_handle_NMI>
	...

8000ce14 <_handle_Instruction_Address>:

        .org  0x014
        // Instruction Address.
_handle_Instruction_Address:
        rjmp $
8000ce14:	c0 08       	rjmp	8000ce14 <_handle_Instruction_Address>
	...

8000ce18 <_handle_ITLB_Protection>:

        .org  0x018
        // ITLB Protection.
_handle_ITLB_Protection:
        rjmp $
8000ce18:	c0 08       	rjmp	8000ce18 <_handle_ITLB_Protection>
	...

8000ce1c <_handle_Breakpoint>:

        .org  0x01C
        // Breakpoint.
_handle_Breakpoint:
        rjmp $
8000ce1c:	c0 08       	rjmp	8000ce1c <_handle_Breakpoint>
	...

8000ce20 <_handle_Illegal_Opcode>:

        .org  0x020
        // Illegal Opcode.
_handle_Illegal_Opcode:
        rjmp $
8000ce20:	c0 08       	rjmp	8000ce20 <_handle_Illegal_Opcode>
	...

8000ce24 <_handle_Unimplemented_Instruction>:

        .org  0x024
        // Unimplemented Instruction.
_handle_Unimplemented_Instruction:
        rjmp $
8000ce24:	c0 08       	rjmp	8000ce24 <_handle_Unimplemented_Instruction>
	...

8000ce28 <_handle_Privilege_Violation>:

        .org  0x028
        // Privilege Violation.
_handle_Privilege_Violation:
        rjmp $
8000ce28:	c0 08       	rjmp	8000ce28 <_handle_Privilege_Violation>
	...

8000ce2c <_handle_Floating_Point>:

        .org  0x02C
        // Floating-Point: UNUSED IN AVR32UC.
_handle_Floating_Point:
        rjmp $
8000ce2c:	c0 08       	rjmp	8000ce2c <_handle_Floating_Point>
	...

8000ce30 <_handle_Coprocessor_Absent>:

        .org  0x030
        // Coprocessor Absent: UNUSED IN AVR32UC.
_handle_Coprocessor_Absent:
        rjmp $
8000ce30:	c0 08       	rjmp	8000ce30 <_handle_Coprocessor_Absent>
	...

8000ce34 <_handle_Data_Address_Read>:

        .org  0x034
        // Data Address (Read).
_handle_Data_Address_Read:
        rjmp $
8000ce34:	c0 08       	rjmp	8000ce34 <_handle_Data_Address_Read>
	...

8000ce38 <_handle_Data_Address_Write>:

        .org  0x038
        // Data Address (Write).
_handle_Data_Address_Write:
        rjmp $
8000ce38:	c0 08       	rjmp	8000ce38 <_handle_Data_Address_Write>
	...

8000ce3c <_handle_DTLB_Protection_Read>:

        .org  0x03C
        // DTLB Protection (Read).
_handle_DTLB_Protection_Read:
        rjmp $
8000ce3c:	c0 08       	rjmp	8000ce3c <_handle_DTLB_Protection_Read>
	...

8000ce40 <_handle_DTLB_Protection_Write>:

        .org  0x040
        // DTLB Protection (Write).
_handle_DTLB_Protection_Write:
        rjmp $
8000ce40:	c0 08       	rjmp	8000ce40 <_handle_DTLB_Protection_Write>
	...

8000ce44 <_handle_DTLB_Modified>:

        .org  0x044
        // DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
        rjmp $
8000ce44:	c0 08       	rjmp	8000ce44 <_handle_DTLB_Modified>
	...

8000ce50 <_handle_ITLB_Miss>:

        .org  0x050
        // ITLB Miss: UNUSED IN AVR32UC.
_handle_ITLB_Miss:
        rjmp $
8000ce50:	c0 08       	rjmp	8000ce50 <_handle_ITLB_Miss>
	...

8000ce60 <_handle_DTLB_Miss_Read>:

        .org  0x060
        // DTLB Miss (Read): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Read:
        rjmp $
8000ce60:	c0 08       	rjmp	8000ce60 <_handle_DTLB_Miss_Read>
	...

8000ce70 <_handle_DTLB_Miss_Write>:

        .org  0x070
        // DTLB Miss (Write): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Write:
        rjmp $
8000ce70:	c0 08       	rjmp	8000ce70 <_handle_DTLB_Miss_Write>
	...

8000cf00 <_handle_Supervisor_Call>:

        .org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	lda.w   pc, SCALLYield
8000cf00:	fe cf 70 48 	sub	pc,pc,28744

8000cf04 <_int0>:
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
	rete
.endr
8000cf04:	30 0c       	mov	r12,0
8000cf06:	fe b0 c3 f7 	rcall	800056f4 <_get_interrupt_handler>
8000cf0a:	58 0c       	cp.w	r12,0
8000cf0c:	f8 0f 17 10 	movne	pc,r12
8000cf10:	d6 03       	rete

8000cf12 <_int1>:
8000cf12:	30 1c       	mov	r12,1
8000cf14:	fe b0 c3 f0 	rcall	800056f4 <_get_interrupt_handler>
8000cf18:	58 0c       	cp.w	r12,0
8000cf1a:	f8 0f 17 10 	movne	pc,r12
8000cf1e:	d6 03       	rete

8000cf20 <_int2>:
8000cf20:	30 2c       	mov	r12,2
8000cf22:	fe b0 c3 e9 	rcall	800056f4 <_get_interrupt_handler>
8000cf26:	58 0c       	cp.w	r12,0
8000cf28:	f8 0f 17 10 	movne	pc,r12
8000cf2c:	d6 03       	rete

8000cf2e <_int3>:
8000cf2e:	30 3c       	mov	r12,3
8000cf30:	fe b0 c3 e2 	rcall	800056f4 <_get_interrupt_handler>
8000cf34:	58 0c       	cp.w	r12,0
8000cf36:	f8 0f 17 10 	movne	pc,r12
8000cf3a:	d6 03       	rete

8000cf3c <ipr_val>:
8000cf3c:	00 00 01 04 40 00 01 12 80 00 01 20 c0 00 01 2e     ....@...... ....
8000cf4c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cf5c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cf6c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cf7c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cf8c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cf9c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cfac:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cfbc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cfcc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cfdc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cfec:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cffc:	d7 03 d7 03                                         ....
