
moto_xg_project.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00002004  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         0000a438  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .exception    00000200  8000c600  8000c600  0000ca00  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       0000116c  8000c800  8000c800  0000cc00  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .dalign       00000004  8000d96c  8000d96c  0000dd6c  2**0
                  ALLOC
  6 .data         00000a38  00000004  8000d970  0000e004  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .balign       00000004  00000a3c  8000e3a8  0000ea3c  2**0
                  ALLOC
  8 .bss          00005960  00000a40  8000e3a8  0000ea40  2**2
                  ALLOC
  9 .comment      00000030  00000000  00000000  0000ea3c  2**0
                  CONTENTS, READONLY
 10 .debug_aranges 000011d8  00000000  00000000  0000ea70  2**3
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_pubnames 00002719  00000000  00000000  0000fc48  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_info   00028df9  00000000  00000000  00012361  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_abbrev 00006b09  00000000  00000000  0003b15a  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_line   0000c45c  00000000  00000000  00041c63  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_frame  00002f30  00000000  00000000  0004e0c0  2**2
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_str    00007397  00000000  00000000  00050ff0  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_loc    0000d19a  00000000  00000000  00058387  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .stack        00001000  00017000  00017000  00000400  2**0
                  ALLOC
 19 .debug_ranges 000012b0  00000000  00000000  00065528  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_trampoline>:

  .global _trampoline
  .type _trampoline, @function
_trampoline:
  // Jump to program start.
  rjmp    program_start
80000000:	e0 8f 10 00 	bral	80002000 <program_start>
	...

80002000 <program_start>:

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002000:	fe cf cb a8 	sub	pc,pc,-13400

Disassembly of section .text:

80002004 <DeviceManagement_brdcst_func>:
80002004:	19 a9       	ld.ub	r9,r12[0x2]
80002006:	30 18       	mov	r8,1
		U8 temp = 0;
		temp  = xcmp->u8[1] << 8;
		temp |= xcmp->u8[2];
		//if (temp == theXNL_Ctrlr.XNL_DeviceLogicalAddress)
		{
			if (xcmp->u8[0] == 0x01)
80002008:	f0 09 18 00 	cp.b	r9,r8
8000200c:	c0 61       	brne	80002018 <DeviceManagement_brdcst_func+0x14>
			{
				bunchofrandomstatusflags |= 0x00000002;
8000200e:	48 68       	lddpc	r8,80002024 <DeviceManagement_brdcst_func+0x20>
80002010:	70 09       	ld.w	r9,r8[0x0]
80002012:	a1 b9       	sbr	r9,0x1
80002014:	91 09       	st.w	r8[0x0],r9
80002016:	5e fc       	retal	r12
			}
			else
			{
				bunchofrandomstatusflags &= 0xFFFFFFFD;
80002018:	48 38       	lddpc	r8,80002024 <DeviceManagement_brdcst_func+0x20>
8000201a:	70 09       	ld.w	r9,r8[0x0]
8000201c:	a1 d9       	cbr	r9,0x1
8000201e:	91 09       	st.w	r8[0x0],r9
80002020:	5e fc       	retal	r12
80002022:	00 00       	add	r0,r0
80002024:	00 00       	add	r0,r0
80002026:	0d 84       	ld.ub	r4,r6[0x0]

80002028 <Volume_brdcst_func>:
	//log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
	
	//log("\n\r Audio_Parameter: %x \n\r", ptr->Audio_Parameter);
	
	
}
80002028:	5e fc       	retal	r12

8000202a <AudioRoutingControl_brdcst_func>:
	//
	//log("\n\r Audio-Function: %x \n\r", xcmp->u8[3+j*2-1]);
	
	
	
}
8000202a:	5e fc       	retal	r12

8000202c <vApplicationIdleHook>:
}

void vApplicationIdleHook( void )
{
	/* This hook function does nothing but increment a counter. */
	ulIdleCycleCount++;
8000202c:	48 38       	lddpc	r8,80002038 <vApplicationIdleHook+0xc>
8000202e:	70 09       	ld.w	r9,r8[0x0]
80002030:	2f f9       	sub	r9,-1
80002032:	91 09       	st.w	r8[0x0],r9
	
}
80002034:	5e fc       	retal	r12
80002036:	00 00       	add	r0,r0
80002038:	00 00       	add	r0,r0
8000203a:	0a 58       	eor	r8,r5

8000203c <app_init>:
	//0x00,0x39


};
void app_init(void)
{	
8000203c:	d4 01       	pushm	lr
	xcmp_register_app_list(the_app_list);
8000203e:	48 cc       	lddpc	r12,8000206c <app_init+0x30>
80002040:	f0 1f 00 0c 	mcall	80002070 <app_init+0x34>
	
	//将app_payload_rx_proc更改为PCM加密功能
	payload_init( app_payload_rx_proc , app_payload_tx_proc );
80002044:	48 cb       	lddpc	r11,80002074 <app_init+0x38>
80002046:	48 dc       	lddpc	r12,80002078 <app_init+0x3c>
80002048:	f0 1f 00 0d 	mcall	8000207c <app_init+0x40>
	
	static portBASE_TYPE res = 0;
	 res = xTaskCreate(
8000204c:	30 09       	mov	r9,0
8000204e:	1a d9       	st.w	--sp,r9
80002050:	1a d9       	st.w	--sp,r9
80002052:	1a d9       	st.w	--sp,r9
80002054:	30 18       	mov	r8,1
80002056:	e0 6a 01 80 	mov	r10,384
8000205a:	48 ab       	lddpc	r11,80002080 <app_init+0x44>
8000205c:	48 ac       	lddpc	r12,80002084 <app_init+0x48>
8000205e:	f0 1f 00 0b 	mcall	80002088 <app_init+0x4c>
80002062:	48 b8       	lddpc	r8,8000208c <app_init+0x50>
80002064:	91 0c       	st.w	r8[0x0],r12
80002066:	2f dd       	sub	sp,-12
	,  384
	,  NULL
	,  1
	,  NULL );
	
}
80002068:	d8 02       	popm	pc
8000206a:	00 00       	add	r0,r0
8000206c:	00 00       	add	r0,r0
8000206e:	00 04       	add	r4,r0
80002070:	80 00       	ld.sh	r0,r0[0x0]
80002072:	42 f8       	lddsp	r8,sp[0xbc]
80002074:	80 00       	ld.sh	r0,r0[0x0]
80002076:	20 e8       	sub	r8,14
80002078:	80 00       	ld.sh	r0,r0[0x0]
8000207a:	20 fc       	sub	r12,15
8000207c:	80 00       	ld.sh	r0,r0[0x0]
8000207e:	2e f8       	sub	r8,-17
80002080:	80 00       	ld.sh	r0,r0[0x0]
80002082:	c8 00       	breq	80001f82 <_trampoline+0x1f82>
80002084:	80 00       	ld.sh	r0,r0[0x0]
80002086:	20 90       	sub	r0,9
80002088:	80 00       	ld.sh	r0,r0[0x0]
8000208a:	63 50       	ld.w	r0,r1[0x54]
8000208c:	00 00       	add	r0,r0
8000208e:	0a 50       	eor	r0,r5

80002090 <app_cfg>:

extern  char AudioData[];
extern U32 tc_tick;

static __app_Thread_(app_cfg)
{
80002090:	eb cd 40 f8 	pushm	r3-r7,lr
	static  portTickType xLastWakeTime;
	const portTickType xFrequency = 4000;//2s,定时问题已经修正。2s x  2000hz = 4000
	U8 Burst_ID = 0;
	char card_id[4]={0};
	
	 xLastWakeTime = xTaskGetTickCount();
80002094:	f0 1f 00 10 	mcall	800020d4 <app_cfg+0x44>
80002098:	49 08       	lddpc	r8,800020d8 <app_cfg+0x48>
8000209a:	91 0c       	st.w	r8[0x0],r12
		
	for(;;)
	{
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
8000209c:	49 06       	lddpc	r6,800020dc <app_cfg+0x4c>
		{	
			connect_flag=1;	
		}
		else if(connect_flag)
8000209e:	49 17       	lddpc	r7,800020e0 <app_cfg+0x50>
		
	for(;;)
	{
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
		{	
			connect_flag=1;	
800020a0:	30 13       	mov	r3,1
			
		//}
		//vTaskDelay(300*2 / portTICK_RATE_MS);//延迟300ms
		//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
		
		vTaskDelayUntil( &xLastWakeTime, (2000*2) / portTICK_RATE_MS  );//精确的以1000ms为周期执行。
800020a2:	10 95       	mov	r5,r8
800020a4:	e0 64 0f a0 	mov	r4,4000
	
	 xLastWakeTime = xTaskGetTickCount();
		
	for(;;)
	{
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
800020a8:	6c 08       	ld.w	r8,r6[0x0]
800020aa:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
800020ae:	58 38       	cp.w	r8,3
800020b0:	c0 61       	brne	800020bc <app_cfg+0x2c>
800020b2:	0f 88       	ld.ub	r8,r7[0x0]
800020b4:	58 08       	cp.w	r8,0
800020b6:	c0 31       	brne	800020bc <app_cfg+0x2c>
		{	
			connect_flag=1;	
800020b8:	ae 83       	st.b	r7[0x0],r3
	
	 xLastWakeTime = xTaskGetTickCount();
		
	for(;;)
	{
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
800020ba:	c0 78       	rjmp	800020c8 <app_cfg+0x38>
		{	
			connect_flag=1;	
		}
		else if(connect_flag)
800020bc:	0f 88       	ld.ub	r8,r7[0x0]
800020be:	58 08       	cp.w	r8,0
800020c0:	c0 41       	brne	800020c8 <app_cfg+0x38>
				//}
				
		}
		else
		{
			nop();
800020c2:	d7 03       	nop
			nop();
800020c4:	d7 03       	nop
			nop();
800020c6:	d7 03       	nop
			
		//}
		//vTaskDelay(300*2 / portTICK_RATE_MS);//延迟300ms
		//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
		
		vTaskDelayUntil( &xLastWakeTime, (2000*2) / portTICK_RATE_MS  );//精确的以1000ms为周期执行。
800020c8:	08 9b       	mov	r11,r4
800020ca:	0a 9c       	mov	r12,r5
800020cc:	f0 1f 00 06 	mcall	800020e4 <app_cfg+0x54>
	}
800020d0:	ce cb       	rjmp	800020a8 <app_cfg+0x18>
800020d2:	00 00       	add	r0,r0
800020d4:	80 00       	ld.sh	r0,r0[0x0]
800020d6:	60 88       	ld.w	r8,r0[0x20]
800020d8:	00 00       	add	r0,r0
800020da:	0a 44       	or	r4,r5
800020dc:	00 00       	add	r0,r0
800020de:	0d 84       	ld.ub	r4,r6[0x0]
800020e0:	00 00       	add	r0,r0
800020e2:	0a 4b       	or	r11,r5
800020e4:	80 00       	ld.sh	r0,r0[0x0]
800020e6:	61 f0       	ld.w	r0,r0[0x7c]

800020e8 <app_payload_tx_proc>:

}


static void app_payload_tx_proc(void  * payload)
{
800020e8:	d4 01       	pushm	lr
  log("R");
800020ea:	48 3c       	lddpc	r12,800020f4 <app_payload_tx_proc+0xc>
800020ec:	f0 1f 00 03 	mcall	800020f8 <app_payload_tx_proc+0x10>
  //
  //
  //set_payload_idle(payload);


}
800020f0:	d8 02       	popm	pc
800020f2:	00 00       	add	r0,r0
800020f4:	80 00       	ld.sh	r0,r0[0x0]
800020f6:	c8 08       	rjmp	800021f6 <SingleDetection_brdcst_func+0x6>
800020f8:	80 00       	ld.sh	r0,r0[0x0]
800020fa:	67 14       	ld.w	r4,r3[0x44]

800020fc <app_payload_rx_proc>:
	}
}


static void app_payload_rx_proc(void  * payload)
{
800020fc:	d4 01       	pushm	lr
	static  U8 times_counter = 0;
	
	times_counter++;
800020fe:	48 99       	lddpc	r9,80002120 <app_payload_rx_proc+0x24>
80002100:	13 88       	ld.ub	r8,r9[0x0]
80002102:	2f f8       	sub	r8,-1
80002104:	b2 88       	st.b	r9[0x0],r8
	if (times_counter == 3)
80002106:	30 39       	mov	r9,3
80002108:	f2 08 18 00 	cp.b	r8,r9
8000210c:	c0 71       	brne	8000211a <app_payload_rx_proc+0x1e>
	{
		times_counter = 0 ;
8000210e:	30 09       	mov	r9,0
80002110:	48 48       	lddpc	r8,80002120 <app_payload_rx_proc+0x24>
80002112:	b0 89       	st.b	r8[0x0],r9
		log("\n\r w: \n\r");
80002114:	48 4c       	lddpc	r12,80002124 <app_payload_rx_proc+0x28>
80002116:	f0 1f 00 05 	mcall	80002128 <app_payload_rx_proc+0x2c>
	}
	//log("\n\r w: \n\r");
	if (AMBE_tx_flag)//本地发送方的mic录音
8000211a:	48 58       	lddpc	r8,8000212c <app_payload_rx_proc+0x30>
8000211c:	11 88       	ld.ub	r8,r8[0x0]
	}
	
	//payload_fragment_t * ptr = (payload_fragment_t *)payload;
	//set_payload_idle(payload);

}
8000211e:	d8 02       	popm	pc
80002120:	00 00       	add	r0,r0
80002122:	0a 4e       	or	lr,r5
80002124:	80 00       	ld.sh	r0,r0[0x0]
80002126:	c8 0c       	rcall	80002226 <ButtonConfig_brdcst_func+0x1a>
80002128:	80 00       	ld.sh	r0,r0[0x0]
8000212a:	67 14       	ld.w	r4,r3[0x44]
8000212c:	00 00       	add	r0,r0
8000212e:	0a 4d       	or	sp,r5

80002130 <FD_brdcst_func>:
	
	
}

void FD_brdcst_func(xcmp_fragment_t * xcmp)
{
80002130:	d4 01       	pushm	lr
	
	
	log("\n\r Forward Data Broadcast \n\r");
80002132:	48 3c       	lddpc	r12,8000213c <FD_brdcst_func+0xc>
80002134:	f0 1f 00 03 	mcall	80002140 <FD_brdcst_func+0x10>
	
}
80002138:	d8 02       	popm	pc
8000213a:	00 00       	add	r0,r0
8000213c:	80 00       	ld.sh	r0,r0[0x0]
8000213e:	c8 18       	rjmp	80002240 <ButtonConfig_brdcst_func+0x34>
80002140:	80 00       	ld.sh	r0,r0[0x0]
80002142:	67 14       	ld.w	r4,r3[0x44]

80002144 <FD_reply_func>:
	
	
}

void FD_reply_func(xcmp_fragment_t * xcmp)
{
80002144:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Reply \n\r");
80002146:	48 3c       	lddpc	r12,80002150 <FD_reply_func+0xc>
80002148:	f0 1f 00 03 	mcall	80002154 <FD_reply_func+0x10>
	
	
}
8000214c:	d8 02       	popm	pc
8000214e:	00 00       	add	r0,r0
80002150:	80 00       	ld.sh	r0,r0[0x0]
80002152:	c8 38       	rjmp	80002258 <ButtonConfig_brdcst_func+0x4c>
80002154:	80 00       	ld.sh	r0,r0[0x0]
80002156:	67 14       	ld.w	r4,r3[0x44]

80002158 <FD_request_func>:
}



void FD_request_func(xcmp_fragment_t * xcmp)
{
80002158:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Request \n\r");
8000215a:	48 3c       	lddpc	r12,80002164 <FD_request_func+0xc>
8000215c:	f0 1f 00 03 	mcall	80002168 <FD_request_func+0x10>
	
	
}
80002160:	d8 02       	popm	pc
80002162:	00 00       	add	r0,r0
80002164:	80 00       	ld.sh	r0,r0[0x0]
80002166:	c8 54       	brge	80002070 <app_init+0x34>
80002168:	80 00       	ld.sh	r0,r0[0x0]
8000216a:	67 14       	ld.w	r4,r3[0x44]

8000216c <EnOB_brdcst_func>:
	
	
}

void EnOB_brdcst_func(xcmp_fragment_t * xcmp)
{
8000216c:	d4 01       	pushm	lr
	
	
	log("\n\r En_OB Broadcast \n\r");
8000216e:	48 3c       	lddpc	r12,80002178 <EnOB_brdcst_func+0xc>
80002170:	f0 1f 00 03 	mcall	8000217c <EnOB_brdcst_func+0x10>
}
80002174:	d8 02       	popm	pc
80002176:	00 00       	add	r0,r0
80002178:	80 00       	ld.sh	r0,r0[0x0]
8000217a:	c8 70       	breq	80002088 <app_init+0x4c>
8000217c:	80 00       	ld.sh	r0,r0[0x0]
8000217e:	67 14       	ld.w	r4,r3[0x44]

80002180 <EnOB_reply_func>:
}



void EnOB_reply_func(xcmp_fragment_t * xcmp)
{
80002180:	eb cd 40 80 	pushm	r7,lr
80002184:	18 97       	mov	r7,r12
		/*point to xcmp payload*/
	//En_OB_Control_reply_t *ptr = (En_OB_Control_reply_t* )xcmp->u8;
	//log("\n\r Xcmp_opcode: %x \n\r", xcmp->xcmp_opcode);
	
	if (xcmp->u8[0]== xcmp_Res_Success)
80002186:	19 a9       	ld.ub	r9,r12[0x2]
80002188:	30 08       	mov	r8,0
8000218a:	f0 09 18 00 	cp.b	r9,r8
8000218e:	c1 91       	brne	800021c0 <EnOB_reply_func+0x40>
	{
		if (xcmp->u8[1] == EN_OB_Enter)
80002190:	19 b8       	ld.ub	r8,r12[0x3]
80002192:	30 19       	mov	r9,1
80002194:	f2 08 18 00 	cp.b	r8,r9
80002198:	c0 61       	brne	800021a4 <EnOB_reply_func+0x24>
		{
		
			log("\n\r En_OB_Enter OK \n\r");
8000219a:	49 0c       	lddpc	r12,800021d8 <EnOB_reply_func+0x58>
8000219c:	f0 1f 00 10 	mcall	800021dc <EnOB_reply_func+0x5c>
800021a0:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else if (xcmp->u8[1] == EN_OB_Exit )
800021a4:	58 08       	cp.w	r8,0
800021a6:	c0 61       	brne	800021b2 <EnOB_reply_func+0x32>
		{
			log("\n\r En_OB_Exit OK \n\r");
800021a8:	48 ec       	lddpc	r12,800021e0 <EnOB_reply_func+0x60>
800021aa:	f0 1f 00 0d 	mcall	800021dc <EnOB_reply_func+0x5c>
800021ae:	e3 cd 80 80 	ldm	sp++,r7,pc
		}
		else
		{
			
			log("\n\r En_OB_Control: %x \n\r", xcmp->u8[1]);
800021b2:	1a d8       	st.w	--sp,r8
800021b4:	48 cc       	lddpc	r12,800021e4 <EnOB_reply_func+0x64>
800021b6:	f0 1f 00 0a 	mcall	800021dc <EnOB_reply_func+0x5c>
800021ba:	2f fd       	sub	sp,-4
800021bc:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r En_OB_Control error \n\r");
800021c0:	48 ac       	lddpc	r12,800021e8 <EnOB_reply_func+0x68>
800021c2:	f0 1f 00 07 	mcall	800021dc <EnOB_reply_func+0x5c>
		log("\n\r En_OB_result: %x \n\r", xcmp->u8[0]);
800021c6:	0f a8       	ld.ub	r8,r7[0x2]
800021c8:	1a d8       	st.w	--sp,r8
800021ca:	48 9c       	lddpc	r12,800021ec <EnOB_reply_func+0x6c>
800021cc:	f0 1f 00 04 	mcall	800021dc <EnOB_reply_func+0x5c>
800021d0:	2f fd       	sub	sp,-4
800021d2:	e3 cd 80 80 	ldm	sp++,r7,pc
800021d6:	00 00       	add	r0,r0
800021d8:	80 00       	ld.sh	r0,r0[0x0]
800021da:	c8 88       	rjmp	800022ea <Phyuserinput_brdcst_func+0x2>
800021dc:	80 00       	ld.sh	r0,r0[0x0]
800021de:	67 14       	ld.w	r4,r3[0x44]
800021e0:	80 00       	ld.sh	r0,r0[0x0]
800021e2:	c8 a0       	breq	800020f6 <app_payload_tx_proc+0xe>
800021e4:	80 00       	ld.sh	r0,r0[0x0]
800021e6:	c8 b4       	brge	800020fc <app_payload_rx_proc>
800021e8:	80 00       	ld.sh	r0,r0[0x0]
800021ea:	c8 cc       	rcall	80002302 <Phyuserinput_brdcst_func+0x1a>
800021ec:	80 00       	ld.sh	r0,r0[0x0]
800021ee:	c8 e8       	rjmp	8000230a <Phyuserinput_brdcst_func+0x22>

800021f0 <SingleDetection_brdcst_func>:
	
}


void SingleDetection_brdcst_func(xcmp_fragment_t * xcmp)
{
800021f0:	d4 01       	pushm	lr
	if (xcmp->u8[0] == 0x11)
800021f2:	19 a9       	ld.ub	r9,r12[0x2]
800021f4:	31 18       	mov	r8,17
800021f6:	f0 09 18 00 	cp.b	r9,r8
800021fa:	c0 41       	brne	80002202 <SingleDetection_brdcst_func+0x12>
	{
		log("\n\r DMR_CSBK OK \n\r");
800021fc:	48 2c       	lddpc	r12,80002204 <SingleDetection_brdcst_func+0x14>
800021fe:	f0 1f 00 03 	mcall	80002208 <SingleDetection_brdcst_func+0x18>
80002202:	d8 02       	popm	pc
80002204:	80 00       	ld.sh	r0,r0[0x0]
80002206:	c9 00       	breq	80002126 <app_payload_rx_proc+0x2a>
80002208:	80 00       	ld.sh	r0,r0[0x0]
8000220a:	67 14       	ld.w	r4,r3[0x44]

8000220c <ButtonConfig_brdcst_func>:
	
}


void ButtonConfig_brdcst_func(xcmp_fragment_t * xcmp)
{
8000220c:	d4 31       	pushm	r0-r7,lr
	U8 Num_Button =0;
	U8 i = 0 ;
	/*point to xcmp payload*/
	ButtonConfig_brdcst_t  *ptr = (ButtonConfig_brdcst_t* )xcmp->u8;
8000220e:	f8 c7 ff fe 	sub	r7,r12,-2
	
	Num_Button = ptr->NumOfButtons;
80002212:	0f 95       	ld.ub	r5,r7[0x1]
	
	log("\n\r ButtonConfig_broadcast  \n\r"  );
80002214:	4a bc       	lddpc	r12,800022c0 <ButtonConfig_brdcst_func+0xb4>
80002216:	f0 1f 00 2c 	mcall	800022c4 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r Function: %X \n\r" , ptr->Function );
8000221a:	0f 88       	ld.ub	r8,r7[0x0]
8000221c:	1a d8       	st.w	--sp,r8
8000221e:	4a bc       	lddpc	r12,800022c8 <ButtonConfig_brdcst_func+0xbc>
80002220:	f0 1f 00 29 	mcall	800022c4 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
80002224:	1a d5       	st.w	--sp,r5
80002226:	4a ac       	lddpc	r12,800022cc <ButtonConfig_brdcst_func+0xc0>
80002228:	f0 1f 00 27 	mcall	800022c4 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
8000222c:	0f a8       	ld.ub	r8,r7[0x2]
8000222e:	1a d8       	st.w	--sp,r8
80002230:	4a 8c       	lddpc	r12,800022d0 <ButtonConfig_brdcst_func+0xc4>
80002232:	f0 1f 00 25 	mcall	800022c4 <ButtonConfig_brdcst_func+0xb8>
	
	for (i; i<Num_Button; i++)
80002236:	2f dd       	sub	sp,-12
80002238:	58 05       	cp.w	r5,0
8000223a:	c4 10       	breq	800022bc <ButtonConfig_brdcst_func+0xb0>
8000223c:	30 06       	mov	r6,0
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
8000223e:	4a 64       	lddpc	r4,800022d4 <ButtonConfig_brdcst_func+0xc8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
80002240:	4a 63       	lddpc	r3,800022d8 <ButtonConfig_brdcst_func+0xcc>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
80002242:	4a 72       	lddpc	r2,800022dc <ButtonConfig_brdcst_func+0xd0>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
80002244:	4a 71       	lddpc	r1,800022e0 <ButtonConfig_brdcst_func+0xd4>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
80002246:	4a 80       	lddpc	r0,800022e4 <ButtonConfig_brdcst_func+0xd8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
80002248:	0f b9       	ld.ub	r9,r7[0x3]
8000224a:	0f c8       	ld.ub	r8,r7[0x4]
8000224c:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002250:	1a d8       	st.w	--sp,r8
80002252:	1a d6       	st.w	--sp,r6
80002254:	08 9c       	mov	r12,r4
80002256:	f0 1f 00 1c 	mcall	800022c4 <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
8000225a:	0f d9       	ld.ub	r9,r7[0x5]
8000225c:	0f e8       	ld.ub	r8,r7[0x6]
8000225e:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002262:	1a d8       	st.w	--sp,r8
80002264:	1a d6       	st.w	--sp,r6
80002266:	06 9c       	mov	r12,r3
80002268:	f0 1f 00 17 	mcall	800022c4 <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
8000226c:	0f f9       	ld.ub	r9,r7[0x7]
8000226e:	ef 38 00 08 	ld.ub	r8,r7[8]
80002272:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002276:	1a d8       	st.w	--sp,r8
80002278:	1a d6       	st.w	--sp,r6
8000227a:	04 9c       	mov	r12,r2
8000227c:	f0 1f 00 12 	mcall	800022c4 <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
80002280:	ef 39 00 09 	ld.ub	r9,r7[9]
80002284:	ef 38 00 0a 	ld.ub	r8,r7[10]
80002288:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000228c:	1a d8       	st.w	--sp,r8
8000228e:	1a d6       	st.w	--sp,r6
80002290:	02 9c       	mov	r12,r1
80002292:	f0 1f 00 0d 	mcall	800022c4 <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
80002296:	2f 8d       	sub	sp,-32
80002298:	ef 39 00 0b 	ld.ub	r9,r7[11]
8000229c:	ef 38 00 0c 	ld.ub	r8,r7[12]
800022a0:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800022a4:	1a d8       	st.w	--sp,r8
800022a6:	1a d6       	st.w	--sp,r6
800022a8:	00 9c       	mov	r12,r0
800022aa:	f0 1f 00 07 	mcall	800022c4 <ButtonConfig_brdcst_func+0xb8>
800022ae:	2f f6       	sub	r6,-1
800022b0:	2f 67       	sub	r7,-10
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
800022b2:	2f ed       	sub	sp,-8
800022b4:	ec 05 18 00 	cp.b	r5,r6
800022b8:	fe 9b ff c8 	brhi	80002248 <ButtonConfig_brdcst_func+0x3c>
800022bc:	d8 32       	popm	r0-r7,pc
800022be:	00 00       	add	r0,r0
800022c0:	80 00       	ld.sh	r0,r0[0x0]
800022c2:	c9 14       	brge	800021e4 <EnOB_reply_func+0x64>
800022c4:	80 00       	ld.sh	r0,r0[0x0]
800022c6:	67 14       	ld.w	r4,r3[0x44]
800022c8:	80 00       	ld.sh	r0,r0[0x0]
800022ca:	c9 34       	brge	800021f0 <SingleDetection_brdcst_func>
800022cc:	80 00       	ld.sh	r0,r0[0x0]
800022ce:	c9 48       	rjmp	800023f6 <CallControl_brdcst_func+0xa>
800022d0:	80 00       	ld.sh	r0,r0[0x0]
800022d2:	c9 60       	breq	800021fe <SingleDetection_brdcst_func+0xe>
800022d4:	80 00       	ld.sh	r0,r0[0x0]
800022d6:	c9 80       	breq	80002206 <SingleDetection_brdcst_func+0x16>
800022d8:	80 00       	ld.sh	r0,r0[0x0]
800022da:	c9 a8       	rjmp	8000240e <CallControl_brdcst_func+0x22>
800022dc:	80 00       	ld.sh	r0,r0[0x0]
800022de:	c9 d0       	breq	80002218 <ButtonConfig_brdcst_func+0xc>
800022e0:	80 00       	ld.sh	r0,r0[0x0]
800022e2:	c9 f4       	brge	80002220 <ButtonConfig_brdcst_func+0x14>
800022e4:	80 00       	ld.sh	r0,r0[0x0]
800022e6:	ca 1c       	rcall	80002428 <CallControl_brdcst_func+0x3c>

800022e8 <Phyuserinput_brdcst_func>:
	
}


void Phyuserinput_brdcst_func(xcmp_fragment_t * xcmp)
{
800022e8:	eb cd 40 80 	pushm	r7,lr
	U8 PUI_State_Min_Value =0;
	U8 PUI_State_Max_Value =0;
	
	PUI_Source = xcmp->u8[0];
	PUI_Type = xcmp ->u8[1];
	PUI_ID = ((xcmp->u8[2]<<8) | xcmp->u8[3]);
800022ec:	19 c7       	ld.ub	r7,r12[0x4]
800022ee:	19 d8       	ld.ub	r8,r12[0x5]
800022f0:	f1 e7 10 87 	or	r7,r8,r7<<0x8
800022f4:	5c 87       	casts.h	r7
	PUI_State = xcmp->u8[4];
	PUI_State_Min_Value = xcmp->u8[5];
	PUI_State_Max_Value = xcmp->u8[6];
	
	log("PhysicalUserInput_broadcast  \n\r"  );
800022f6:	48 ac       	lddpc	r12,8000231c <Phyuserinput_brdcst_func+0x34>
800022f8:	f0 1f 00 0a 	mcall	80002320 <Phyuserinput_brdcst_func+0x38>
	
	if((PUI_ID == 0x0060) && (PUI_State = 0x02) && (connect_flag == 1)){
800022fc:	36 08       	mov	r8,96
800022fe:	f0 07 19 00 	cp.h	r7,r8
80002302:	c0 a1       	brne	80002316 <Phyuserinput_brdcst_func+0x2e>
80002304:	48 88       	lddpc	r8,80002324 <Phyuserinput_brdcst_func+0x3c>
80002306:	11 89       	ld.ub	r9,r8[0x0]
80002308:	30 18       	mov	r8,1
8000230a:	f0 09 18 00 	cp.b	r9,r8
8000230e:	c0 41       	brne	80002316 <Phyuserinput_brdcst_func+0x2e>
		log("send message\n");
80002310:	48 6c       	lddpc	r12,80002328 <Phyuserinput_brdcst_func+0x40>
80002312:	f0 1f 00 04 	mcall	80002320 <Phyuserinput_brdcst_func+0x38>
80002316:	e3 cd 80 80 	ldm	sp++,r7,pc
8000231a:	00 00       	add	r0,r0
8000231c:	80 00       	ld.sh	r0,r0[0x0]
8000231e:	ca 40       	breq	80002266 <ButtonConfig_brdcst_func+0x5a>
80002320:	80 00       	ld.sh	r0,r0[0x0]
80002322:	67 14       	ld.w	r4,r3[0x44]
80002324:	00 00       	add	r0,r0
80002326:	0a 4b       	or	r11,r5
80002328:	80 00       	ld.sh	r0,r0[0x0]
8000232a:	ca 60       	breq	80002276 <ButtonConfig_brdcst_func+0x6a>

8000232c <ButtonConfig_reply_func>:
	}
	
}

void ButtonConfig_reply_func(xcmp_fragment_t * xcmp)
{
8000232c:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	ButtonConfig_reply_t *ptr = (ButtonConfig_reply_t* )(xcmp->u8);
80002330:	f8 c7 ff fe 	sub	r7,r12,-2
	if (ptr->Result == xcmp_Res_Success)
80002334:	0f 89       	ld.ub	r9,r7[0x0]
80002336:	30 08       	mov	r8,0
80002338:	f0 09 18 00 	cp.b	r9,r8
8000233c:	c0 c1       	brne	80002354 <ButtonConfig_reply_func+0x28>
	{
		log("\n\r Button_Config OK \n\r");
8000233e:	48 9c       	lddpc	r12,80002360 <ButtonConfig_reply_func+0x34>
80002340:	f0 1f 00 09 	mcall	80002364 <ButtonConfig_reply_func+0x38>
		
		log("\n\r Function: %X \n\r" , ptr->Function );
80002344:	0f 98       	ld.ub	r8,r7[0x1]
80002346:	1a d8       	st.w	--sp,r8
80002348:	48 8c       	lddpc	r12,80002368 <ButtonConfig_reply_func+0x3c>
8000234a:	f0 1f 00 07 	mcall	80002364 <ButtonConfig_reply_func+0x38>
8000234e:	2f fd       	sub	sp,-4
80002350:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r Button_Request error \n\r");
80002354:	48 6c       	lddpc	r12,8000236c <ButtonConfig_reply_func+0x40>
80002356:	f0 1f 00 04 	mcall	80002364 <ButtonConfig_reply_func+0x38>
8000235a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000235e:	00 00       	add	r0,r0
80002360:	80 00       	ld.sh	r0,r0[0x0]
80002362:	ca 70       	breq	800022b0 <ButtonConfig_brdcst_func+0xa4>
80002364:	80 00       	ld.sh	r0,r0[0x0]
80002366:	67 14       	ld.w	r4,r3[0x44]
80002368:	80 00       	ld.sh	r0,r0[0x0]
8000236a:	c9 34       	brge	80002290 <ButtonConfig_brdcst_func+0x84>
8000236c:	80 00       	ld.sh	r0,r0[0x0]
8000236e:	ca 88       	rjmp	800024be <TransmitControl_reply_func+0x46>

80002370 <DataSession_reply_func>:
	
	
}

void DataSession_reply_func(xcmp_fragment_t * xcmp)
{
80002370:	eb cd 40 80 	pushm	r7,lr
80002374:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
80002376:	19 a9       	ld.ub	r9,r12[0x2]
80002378:	30 08       	mov	r8,0
8000237a:	f0 09 18 00 	cp.b	r9,r8
8000237e:	c1 11       	brne	800023a0 <DataSession_reply_func+0x30>
	{
		log("DATArep OK \n");
80002380:	49 3c       	lddpc	r12,800023cc <DataSession_reply_func+0x5c>
80002382:	f0 1f 00 14 	mcall	800023d0 <DataSession_reply_func+0x60>
		log("Func: %X \n", xcmp->u8[1]);
80002386:	0f b8       	ld.ub	r8,r7[0x3]
80002388:	1a d8       	st.w	--sp,r8
8000238a:	49 3c       	lddpc	r12,800023d4 <DataSession_reply_func+0x64>
8000238c:	f0 1f 00 11 	mcall	800023d0 <DataSession_reply_func+0x60>
		log("ID: %X \n", xcmp->u8[2]);
80002390:	0f c8       	ld.ub	r8,r7[0x4]
80002392:	1a d8       	st.w	--sp,r8
80002394:	49 1c       	lddpc	r12,800023d8 <DataSession_reply_func+0x68>
80002396:	f0 1f 00 0f 	mcall	800023d0 <DataSession_reply_func+0x60>
8000239a:	2f ed       	sub	sp,-8
8000239c:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	else
	{	
		log("DATArep error \n");
800023a0:	48 fc       	lddpc	r12,800023dc <DataSession_reply_func+0x6c>
800023a2:	f0 1f 00 0c 	mcall	800023d0 <DataSession_reply_func+0x60>
		log("Result:  %X \n", xcmp->u8[0]);
800023a6:	0f a8       	ld.ub	r8,r7[0x2]
800023a8:	1a d8       	st.w	--sp,r8
800023aa:	48 ec       	lddpc	r12,800023e0 <DataSession_reply_func+0x70>
800023ac:	f0 1f 00 09 	mcall	800023d0 <DataSession_reply_func+0x60>
		log("Func:  %X \n", xcmp->u8[1]);
800023b0:	0f b8       	ld.ub	r8,r7[0x3]
800023b2:	1a d8       	st.w	--sp,r8
800023b4:	48 cc       	lddpc	r12,800023e4 <DataSession_reply_func+0x74>
800023b6:	f0 1f 00 07 	mcall	800023d0 <DataSession_reply_func+0x60>
		log("ID:  %X \n", xcmp->u8[2]);
800023ba:	0f c8       	ld.ub	r8,r7[0x4]
800023bc:	1a d8       	st.w	--sp,r8
800023be:	48 bc       	lddpc	r12,800023e8 <DataSession_reply_func+0x78>
800023c0:	f0 1f 00 04 	mcall	800023d0 <DataSession_reply_func+0x60>
800023c4:	2f dd       	sub	sp,-12
800023c6:	e3 cd 80 80 	ldm	sp++,r7,pc
800023ca:	00 00       	add	r0,r0
800023cc:	80 00       	ld.sh	r0,r0[0x0]
800023ce:	ca a4       	brge	80002322 <Phyuserinput_brdcst_func+0x3a>
800023d0:	80 00       	ld.sh	r0,r0[0x0]
800023d2:	67 14       	ld.w	r4,r3[0x44]
800023d4:	80 00       	ld.sh	r0,r0[0x0]
800023d6:	ca b4       	brge	8000232c <ButtonConfig_reply_func>
800023d8:	80 00       	ld.sh	r0,r0[0x0]
800023da:	ca c0       	breq	80002332 <ButtonConfig_reply_func+0x6>
800023dc:	80 00       	ld.sh	r0,r0[0x0]
800023de:	ca cc       	rcall	80002536 <Volume_reply_func+0x36>
800023e0:	80 00       	ld.sh	r0,r0[0x0]
800023e2:	ca dc       	rcall	8000253c <Volume_reply_func+0x3c>
800023e4:	80 00       	ld.sh	r0,r0[0x0]
800023e6:	ca ec       	rcall	80002542 <Volume_reply_func+0x42>
800023e8:	80 00       	ld.sh	r0,r0[0x0]
800023ea:	ca f8       	rjmp	80002548 <Volume_reply_func+0x48>

800023ec <CallControl_brdcst_func>:
	
}


void CallControl_brdcst_func(xcmp_fragment_t * xcmp)
{
800023ec:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	CallControl_brdcst_t *ptr = (CallControl_brdcst_t* )xcmp->u8;
800023f0:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  CallControl brst \n\r ");
	//log("\n\r  Call_type: %x \n\r ", ptr->Calltype );
	log("\n\r  Call_state: %x \n\r ", ptr->Callstate );
800023f4:	0f 98       	ld.ub	r8,r7[0x1]
800023f6:	1a d8       	st.w	--sp,r8
800023f8:	48 bc       	lddpc	r12,80002424 <CallControl_brdcst_func+0x38>
800023fa:	f0 1f 00 0c 	mcall	80002428 <CallControl_brdcst_func+0x3c>
	if (ptr->Callstate == Call_Ended)//0x03
800023fe:	2f fd       	sub	sp,-4
80002400:	0f 99       	ld.ub	r9,r7[0x1]
80002402:	30 38       	mov	r8,3
80002404:	f0 09 18 00 	cp.b	r9,r8
80002408:	c0 41       	brne	80002410 <CallControl_brdcst_func+0x24>
	{
		//恢复正常语音路径通道
		//xcmp_audio_route_revert();
		Call_Begin = 0;
8000240a:	30 09       	mov	r9,0
8000240c:	48 88       	lddpc	r8,8000242c <CallControl_brdcst_func+0x40>
8000240e:	b0 89       	st.b	r8[0x0],r9
		
	}
	
	if (ptr->Callstate == Call_Initiated)//0x04
80002410:	0f 99       	ld.ub	r9,r7[0x1]
80002412:	30 48       	mov	r8,4
80002414:	f0 09 18 00 	cp.b	r9,r8
80002418:	c0 41       	brne	80002420 <CallControl_brdcst_func+0x34>
	{
		Call_Begin = 1;
8000241a:	30 19       	mov	r9,1
8000241c:	48 48       	lddpc	r8,8000242c <CallControl_brdcst_func+0x40>
8000241e:	b0 89       	st.b	r8[0x0],r9
80002420:	e3 cd 80 80 	ldm	sp++,r7,pc
80002424:	80 00       	ld.sh	r0,r0[0x0]
80002426:	cb 04       	brge	80002386 <DataSession_reply_func+0x16>
80002428:	80 00       	ld.sh	r0,r0[0x0]
8000242a:	67 14       	ld.w	r4,r3[0x44]
8000242c:	00 00       	add	r0,r0
8000242e:	0a 49       	or	r9,r5

80002430 <TransmitControl_brdcst_func>:

}


void TransmitControl_brdcst_func(xcmp_fragment_t * xcmp)
{
80002430:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	TransmitControl_brdcast_t *ptr = (TransmitControl_brdcast_t* )xcmp->u8;
80002434:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  TransmitControl broadcast \n\r ");
	//log("\n\r  Mode_Of_Operation: %x \n\r ", ptr->Mode_Of_Operation );
	if (ptr->State == 0x00)
80002438:	0f 99       	ld.ub	r9,r7[0x1]
8000243a:	30 08       	mov	r8,0
8000243c:	f0 09 18 00 	cp.b	r9,r8
80002440:	c0 71       	brne	8000244e <TransmitControl_brdcst_func+0x1e>
	{
		log("\n\r  Standby-Receive \n\r ");
80002442:	48 ac       	lddpc	r12,80002468 <TransmitControl_brdcst_func+0x38>
80002444:	f0 1f 00 0a 	mcall	8000246c <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 0;
80002448:	30 09       	mov	r9,0
8000244a:	48 a8       	lddpc	r8,80002470 <TransmitControl_brdcst_func+0x40>
8000244c:	b0 89       	st.b	r8[0x0],r9
	}
	if (ptr->State == 0x01)
8000244e:	0f 99       	ld.ub	r9,r7[0x1]
80002450:	30 18       	mov	r8,1
80002452:	f0 09 18 00 	cp.b	r9,r8
80002456:	c0 71       	brne	80002464 <TransmitControl_brdcst_func+0x34>
	{
		log("\n\r  Transmit \n\r ");
80002458:	48 7c       	lddpc	r12,80002474 <TransmitControl_brdcst_func+0x44>
8000245a:	f0 1f 00 05 	mcall	8000246c <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 1;
8000245e:	30 19       	mov	r9,1
80002460:	48 48       	lddpc	r8,80002470 <TransmitControl_brdcst_func+0x40>
80002462:	b0 89       	st.b	r8[0x0],r9
80002464:	e3 cd 80 80 	ldm	sp++,r7,pc
80002468:	80 00       	ld.sh	r0,r0[0x0]
8000246a:	cb 1c       	rcall	800025cc <spk_reply_func+0x30>
8000246c:	80 00       	ld.sh	r0,r0[0x0]
8000246e:	67 14       	ld.w	r4,r3[0x44]
80002470:	00 00       	add	r0,r0
80002472:	0a 48       	or	r8,r5
80002474:	80 00       	ld.sh	r0,r0[0x0]
80002476:	cb 34       	brge	800023dc <DataSession_reply_func+0x6c>

80002478 <TransmitControl_reply_func>:




void TransmitControl_reply_func(xcmp_fragment_t * xcmp)
{
80002478:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	TransmitControl_reply_t *ptr = (TransmitControl_reply_t* )xcmp->u8;
8000247c:	f8 c7 ff fe 	sub	r7,r12,-2
	
	if (ptr->Result == xcmp_Res_Success)
80002480:	0f 89       	ld.ub	r9,r7[0x0]
80002482:	30 08       	mov	r8,0
80002484:	f0 09 18 00 	cp.b	r9,r8
80002488:	c1 61       	brne	800024b4 <TransmitControl_reply_func+0x3c>
	{
		
		log("\n\r  TransmitControl OK \n\r ");
8000248a:	48 ec       	lddpc	r12,800024c0 <TransmitControl_reply_func+0x48>
8000248c:	f0 1f 00 0e 	mcall	800024c4 <TransmitControl_reply_func+0x4c>
		log("\n\r Function: %x \n\r", ptr->Function);
80002490:	0f 98       	ld.ub	r8,r7[0x1]
80002492:	1a d8       	st.w	--sp,r8
80002494:	48 dc       	lddpc	r12,800024c8 <TransmitControl_reply_func+0x50>
80002496:	f0 1f 00 0c 	mcall	800024c4 <TransmitControl_reply_func+0x4c>
		log("\n\r Mode of Operation: %x \n\r", ptr->Mode_Of_Operation);
8000249a:	0f a8       	ld.ub	r8,r7[0x2]
8000249c:	1a d8       	st.w	--sp,r8
8000249e:	48 cc       	lddpc	r12,800024cc <TransmitControl_reply_func+0x54>
800024a0:	f0 1f 00 09 	mcall	800024c4 <TransmitControl_reply_func+0x4c>
		log("\n\r State: %x \n\r", ptr->State);
800024a4:	0f b8       	ld.ub	r8,r7[0x3]
800024a6:	1a d8       	st.w	--sp,r8
800024a8:	48 ac       	lddpc	r12,800024d0 <TransmitControl_reply_func+0x58>
800024aa:	f0 1f 00 07 	mcall	800024c4 <TransmitControl_reply_func+0x4c>
800024ae:	2f dd       	sub	sp,-12
800024b0:	e3 cd 80 80 	ldm	sp++,r7,pc
		
		//Silent_flag = 1;
	}
	else
	{
		log("TransmitControl error");
800024b4:	48 8c       	lddpc	r12,800024d4 <TransmitControl_reply_func+0x5c>
800024b6:	f0 1f 00 04 	mcall	800024c4 <TransmitControl_reply_func+0x4c>
800024ba:	e3 cd 80 80 	ldm	sp++,r7,pc
800024be:	00 00       	add	r0,r0
800024c0:	80 00       	ld.sh	r0,r0[0x0]
800024c2:	cb 48       	rjmp	8000262a <mic_brdcst_func+0x46>
800024c4:	80 00       	ld.sh	r0,r0[0x0]
800024c6:	67 14       	ld.w	r4,r3[0x44]
800024c8:	80 00       	ld.sh	r0,r0[0x0]
800024ca:	cb 64       	brge	80002436 <TransmitControl_brdcst_func+0x6>
800024cc:	80 00       	ld.sh	r0,r0[0x0]
800024ce:	cb 78       	rjmp	8000263c <mic_reply_func>
800024d0:	80 00       	ld.sh	r0,r0[0x0]
800024d2:	cb 94       	brge	80002444 <TransmitControl_brdcst_func+0x14>
800024d4:	80 00       	ld.sh	r0,r0[0x0]
800024d6:	cb a4       	brge	8000244a <TransmitControl_brdcst_func+0x1a>

800024d8 <AudioRoutingControl_reply_func>:
	
}


void AudioRoutingControl_reply_func(xcmp_fragment_t * xcmp)
{
800024d8:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
800024da:	19 a9       	ld.ub	r9,r12[0x2]
800024dc:	30 08       	mov	r8,0
800024de:	f0 09 18 00 	cp.b	r9,r8
800024e2:	c0 51       	brne	800024ec <AudioRoutingControl_reply_func+0x14>
	{
		log("AudioRouting OK");
800024e4:	48 4c       	lddpc	r12,800024f4 <AudioRoutingControl_reply_func+0x1c>
800024e6:	f0 1f 00 05 	mcall	800024f8 <AudioRoutingControl_reply_func+0x20>
800024ea:	d8 02       	popm	pc
		//xcmp_IdleTestTone();
		//Speaker_is_unmute = 1;
	}
	else
	{
		log("AudioRouting error");
800024ec:	48 4c       	lddpc	r12,800024fc <AudioRoutingControl_reply_func+0x24>
800024ee:	f0 1f 00 03 	mcall	800024f8 <AudioRoutingControl_reply_func+0x20>
800024f2:	d8 02       	popm	pc
800024f4:	80 00       	ld.sh	r0,r0[0x0]
800024f6:	cb bc       	rcall	8000266c <mic_reply_func+0x30>
800024f8:	80 00       	ld.sh	r0,r0[0x0]
800024fa:	67 14       	ld.w	r4,r3[0x44]
800024fc:	80 00       	ld.sh	r0,r0[0x0]
800024fe:	cb cc       	rcall	80002676 <mic_reply_func+0x3a>

80002500 <Volume_reply_func>:
	
}


void Volume_reply_func(xcmp_fragment_t * xcmp)
{
80002500:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	VolumeControl_reply_t *ptr = (VolumeControl_reply_t* )xcmp->u8;
80002504:	f8 c7 ff fe 	sub	r7,r12,-2
	
		if (ptr->Result == xcmp_Res_Success)
80002508:	0f 89       	ld.ub	r9,r7[0x0]
8000250a:	30 08       	mov	r8,0
8000250c:	f0 09 18 00 	cp.b	r9,r8
80002510:	c1 b1       	brne	80002546 <Volume_reply_func+0x46>
		{
			if (ptr->Function == Enable_IntelligentAudio)
80002512:	0f b8       	ld.ub	r8,r7[0x3]
80002514:	31 09       	mov	r9,16
80002516:	f2 08 18 00 	cp.b	r8,r9
8000251a:	c0 f1       	brne	80002538 <Volume_reply_func+0x38>
			{
				log("\n\r Enable_IA OK \n\r");
8000251c:	48 dc       	lddpc	r12,80002550 <Volume_reply_func+0x50>
8000251e:	f0 1f 00 0e 	mcall	80002554 <Volume_reply_func+0x54>
				log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
80002522:	0f 99       	ld.ub	r9,r7[0x1]
80002524:	0f a8       	ld.ub	r8,r7[0x2]
80002526:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000252a:	1a d8       	st.w	--sp,r8
8000252c:	48 bc       	lddpc	r12,80002558 <Volume_reply_func+0x58>
8000252e:	f0 1f 00 0a 	mcall	80002554 <Volume_reply_func+0x54>
80002532:	2f fd       	sub	sp,-4
80002534:	e3 cd 80 80 	ldm	sp++,r7,pc
	
			}
			else
			{
				
				log("\n\r VolumeControl: %x \n\r", ptr->Function);
80002538:	1a d8       	st.w	--sp,r8
8000253a:	48 9c       	lddpc	r12,8000255c <Volume_reply_func+0x5c>
8000253c:	f0 1f 00 06 	mcall	80002554 <Volume_reply_func+0x54>
80002540:	2f fd       	sub	sp,-4
80002542:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		
		else
		{
			log("\n\r Enable_IA error \n\r");
80002546:	48 7c       	lddpc	r12,80002560 <Volume_reply_func+0x60>
80002548:	f0 1f 00 03 	mcall	80002554 <Volume_reply_func+0x54>
8000254c:	e3 cd 80 80 	ldm	sp++,r7,pc
80002550:	80 00       	ld.sh	r0,r0[0x0]
80002552:	cb e0       	breq	800024ce <TransmitControl_reply_func+0x56>
80002554:	80 00       	ld.sh	r0,r0[0x0]
80002556:	67 14       	ld.w	r4,r3[0x44]
80002558:	80 00       	ld.sh	r0,r0[0x0]
8000255a:	cb f4       	brge	800024d8 <AudioRoutingControl_reply_func>
8000255c:	80 00       	ld.sh	r0,r0[0x0]
8000255e:	cc 10       	breq	800024e0 <AudioRoutingControl_reply_func+0x8>
80002560:	80 00       	ld.sh	r0,r0[0x0]
80002562:	cc 28       	rjmp	800026e6 <dcm_brdcst_func+0x16>

80002564 <spk_brdcst_func>:
		log("spk error");
	}
}

void spk_brdcst_func(xcmp_fragment_t * xcmp)
{
80002564:	d4 01       	pushm	lr
	if (xcmp->u8[3] == xcmp_Res_Success)//0x0000:mute
80002566:	19 d9       	ld.ub	r9,r12[0x5]
80002568:	30 08       	mov	r8,0
8000256a:	f0 09 18 00 	cp.b	r9,r8
8000256e:	c0 81       	brne	8000257e <spk_brdcst_func+0x1a>
	{
		Speaker_is_unmute =0;
80002570:	10 99       	mov	r9,r8
80002572:	48 78       	lddpc	r8,8000258c <spk_brdcst_func+0x28>
80002574:	b0 89       	st.b	r8[0x0],r9
		//Silent_flag = 0;
		log("spk_s_close ");
80002576:	48 7c       	lddpc	r12,80002590 <spk_brdcst_func+0x2c>
80002578:	f0 1f 00 07 	mcall	80002594 <spk_brdcst_func+0x30>
8000257c:	d8 02       	popm	pc
		
	}
	else
	{
		//Silent_flag = 1;
		Speaker_is_unmute = 1;
8000257e:	30 19       	mov	r9,1
80002580:	48 38       	lddpc	r8,8000258c <spk_brdcst_func+0x28>
80002582:	b0 89       	st.b	r8[0x0],r9
		log("spk_s_open ");	
80002584:	48 5c       	lddpc	r12,80002598 <spk_brdcst_func+0x34>
80002586:	f0 1f 00 04 	mcall	80002594 <spk_brdcst_func+0x30>
8000258a:	d8 02       	popm	pc
8000258c:	00 00       	add	r0,r0
8000258e:	0a 40       	or	r0,r5
80002590:	80 00       	ld.sh	r0,r0[0x0]
80002592:	cc 40       	breq	8000251a <Volume_reply_func+0x1a>
80002594:	80 00       	ld.sh	r0,r0[0x0]
80002596:	67 14       	ld.w	r4,r3[0x44]
80002598:	80 00       	ld.sh	r0,r0[0x0]
8000259a:	cc 50       	breq	80002524 <Volume_reply_func+0x24>

8000259c <spk_reply_func>:
			
	
}

void spk_reply_func(xcmp_fragment_t * xcmp)
{
8000259c:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
8000259e:	19 a9       	ld.ub	r9,r12[0x2]
800025a0:	30 08       	mov	r8,0
800025a2:	f0 09 18 00 	cp.b	r9,r8
800025a6:	c0 f1       	brne	800025c4 <spk_reply_func+0x28>
	{
		
		if(xcmp->u8[4])
800025a8:	19 e9       	ld.ub	r9,r12[0x6]
800025aa:	f0 09 18 00 	cp.b	r9,r8
800025ae:	c0 40       	breq	800025b6 <spk_reply_func+0x1a>
		{
			Speaker_is_unmute = 1;
800025b0:	30 19       	mov	r9,1
800025b2:	48 98       	lddpc	r8,800025d4 <spk_reply_func+0x38>
800025b4:	b0 89       	st.b	r8[0x0],r9
			
			//Silent_flag = 1;
		}
		log("spk OK -st%2x", xcmp->u8[4] );
800025b6:	19 e8       	ld.ub	r8,r12[0x6]
800025b8:	1a d8       	st.w	--sp,r8
800025ba:	48 8c       	lddpc	r12,800025d8 <spk_reply_func+0x3c>
800025bc:	f0 1f 00 08 	mcall	800025dc <spk_reply_func+0x40>
800025c0:	2f fd       	sub	sp,-4
800025c2:	d8 02       	popm	pc
		
	}
	else
	{
		Speaker_is_unmute = 0;
800025c4:	30 09       	mov	r9,0
800025c6:	48 48       	lddpc	r8,800025d4 <spk_reply_func+0x38>
800025c8:	b0 89       	st.b	r8[0x0],r9
		log("spk error");
800025ca:	48 6c       	lddpc	r12,800025e0 <spk_reply_func+0x44>
800025cc:	f0 1f 00 04 	mcall	800025dc <spk_reply_func+0x40>
800025d0:	d8 02       	popm	pc
800025d2:	00 00       	add	r0,r0
800025d4:	00 00       	add	r0,r0
800025d6:	0a 40       	or	r0,r5
800025d8:	80 00       	ld.sh	r0,r0[0x0]
800025da:	cc 5c       	rcall	80002764 <dcm_reply_func+0x4c>
800025dc:	80 00       	ld.sh	r0,r0[0x0]
800025de:	67 14       	ld.w	r4,r3[0x44]
800025e0:	80 00       	ld.sh	r0,r0[0x0]
800025e2:	cc 6c       	rcall	8000276e <dcm_reply_func+0x56>

800025e4 <mic_brdcst_func>:
	
	
}

void mic_brdcst_func(xcmp_fragment_t * xcmp)
{
800025e4:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_brdcast_t *ptr = (MicControl_brdcast_t* )xcmp->u8;
800025e8:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r Mic_brdcst \n\r");		
	//log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
	//log("\n\r Signal_type: %x \n\r " ,  ptr->Signaling_Type);
	if (ptr->Mic_State == 0x00)
800025ec:	0f a9       	ld.ub	r9,r7[0x2]
800025ee:	30 08       	mov	r8,0
800025f0:	f0 09 18 00 	cp.b	r9,r8
800025f4:	c0 71       	brne	80002602 <mic_brdcst_func+0x1e>
	{
		log("\n\r Mic_Disabled \n\r");	
800025f6:	48 dc       	lddpc	r12,80002628 <mic_brdcst_func+0x44>
800025f8:	f0 1f 00 0d 	mcall	8000262c <mic_brdcst_func+0x48>
		Mic_is_Enabled = 0;
800025fc:	30 09       	mov	r9,0
800025fe:	48 d8       	lddpc	r8,80002630 <mic_brdcst_func+0x4c>
80002600:	b0 89       	st.b	r8[0x0],r9
	} 
	if(ptr->Mic_State == 0x11)
80002602:	0f a9       	ld.ub	r9,r7[0x2]
80002604:	31 18       	mov	r8,17
80002606:	f0 09 18 00 	cp.b	r9,r8
8000260a:	c0 d1       	brne	80002624 <mic_brdcst_func+0x40>
	{
		log("\n\r Mic_Enabled \n\r");
8000260c:	48 ac       	lddpc	r12,80002634 <mic_brdcst_func+0x50>
8000260e:	f0 1f 00 08 	mcall	8000262c <mic_brdcst_func+0x48>
		Mic_is_Enabled = 1;
80002612:	48 89       	lddpc	r9,80002630 <mic_brdcst_func+0x4c>
80002614:	30 18       	mov	r8,1
80002616:	b2 88       	st.b	r9[0x0],r8
		
		if ((Mic_is_Enabled == 1) && (Call_Begin == 1))
80002618:	13 89       	ld.ub	r9,r9[0x0]
8000261a:	f0 09 18 00 	cp.b	r9,r8
8000261e:	c0 31       	brne	80002624 <mic_brdcst_func+0x40>
80002620:	48 68       	lddpc	r8,80002638 <mic_brdcst_func+0x54>
80002622:	11 88       	ld.ub	r8,r8[0x0]
80002624:	e3 cd 80 80 	ldm	sp++,r7,pc
80002628:	80 00       	ld.sh	r0,r0[0x0]
8000262a:	cc 78       	rjmp	800027b8 <DataSession_brdcst_func+0x10>
8000262c:	80 00       	ld.sh	r0,r0[0x0]
8000262e:	67 14       	ld.w	r4,r3[0x44]
80002630:	00 00       	add	r0,r0
80002632:	0a 4c       	or	r12,r5
80002634:	80 00       	ld.sh	r0,r0[0x0]
80002636:	cc 8c       	rcall	800027c6 <DataSession_brdcst_func+0x1e>
80002638:	00 00       	add	r0,r0
8000263a:	0a 49       	or	r9,r5

8000263c <mic_reply_func>:
	
	
}

void mic_reply_func(xcmp_fragment_t * xcmp)
{
8000263c:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_reply_t *ptr = (MicControl_reply_t* )xcmp->u8;
80002640:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Mic_reply \n\r");
80002644:	49 ac       	lddpc	r12,800026ac <mic_reply_func+0x70>
80002646:	f0 1f 00 1b 	mcall	800026b0 <mic_reply_func+0x74>
	if (ptr->Result == 0x00)
8000264a:	0f 89       	ld.ub	r9,r7[0x0]
8000264c:	30 08       	mov	r8,0
8000264e:	f0 09 18 00 	cp.b	r9,r8
80002652:	c2 71       	brne	800026a0 <mic_reply_func+0x64>
	{
		
		if (ptr->Function == Mic_Disable)
80002654:	0f 98       	ld.ub	r8,r7[0x1]
80002656:	30 29       	mov	r9,2
80002658:	f2 08 18 00 	cp.b	r8,r9
8000265c:	c1 b1       	brne	80002692 <mic_reply_func+0x56>
		{
		
			log("\n\r Mic_close_ok \n\r " );
8000265e:	49 6c       	lddpc	r12,800026b4 <mic_reply_func+0x78>
80002660:	f0 1f 00 14 	mcall	800026b0 <mic_reply_func+0x74>
			log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
80002664:	0f a8       	ld.ub	r8,r7[0x2]
80002666:	1a d8       	st.w	--sp,r8
80002668:	49 4c       	lddpc	r12,800026b8 <mic_reply_func+0x7c>
8000266a:	f0 1f 00 12 	mcall	800026b0 <mic_reply_func+0x74>
			log("\n\r Signaling_type: %x \n\r " ,  ptr->Signaling_Type);
8000266e:	0f b8       	ld.ub	r8,r7[0x3]
80002670:	1a d8       	st.w	--sp,r8
80002672:	49 3c       	lddpc	r12,800026bc <mic_reply_func+0x80>
80002674:	f0 1f 00 0f 	mcall	800026b0 <mic_reply_func+0x74>
			log("\n\r Mic_state: %x \n\r " ,  ptr->Mic_State);
80002678:	0f c8       	ld.ub	r8,r7[0x4]
8000267a:	1a d8       	st.w	--sp,r8
8000267c:	49 1c       	lddpc	r12,800026c0 <mic_reply_func+0x84>
8000267e:	f0 1f 00 0d 	mcall	800026b0 <mic_reply_func+0x74>
			log("\n\r Gain_offset: %x \n\r " ,  ptr->Gain_Offset);
80002682:	0f d8       	ld.ub	r8,r7[0x5]
80002684:	1a d8       	st.w	--sp,r8
80002686:	49 0c       	lddpc	r12,800026c4 <mic_reply_func+0x88>
80002688:	f0 1f 00 0a 	mcall	800026b0 <mic_reply_func+0x74>
8000268c:	2f cd       	sub	sp,-16
8000268e:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else
		{
			log("\n\r Mic_function: %x \n\r ", ptr->Function );
80002692:	1a d8       	st.w	--sp,r8
80002694:	48 dc       	lddpc	r12,800026c8 <mic_reply_func+0x8c>
80002696:	f0 1f 00 07 	mcall	800026b0 <mic_reply_func+0x74>
8000269a:	2f fd       	sub	sp,-4
8000269c:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else 
	{
		
	
		log("\n\r Mic error \n\r");
800026a0:	48 bc       	lddpc	r12,800026cc <mic_reply_func+0x90>
800026a2:	f0 1f 00 04 	mcall	800026b0 <mic_reply_func+0x74>
800026a6:	e3 cd 80 80 	ldm	sp++,r7,pc
800026aa:	00 00       	add	r0,r0
800026ac:	80 00       	ld.sh	r0,r0[0x0]
800026ae:	cc a0       	breq	80002642 <mic_reply_func+0x6>
800026b0:	80 00       	ld.sh	r0,r0[0x0]
800026b2:	67 14       	ld.w	r4,r3[0x44]
800026b4:	80 00       	ld.sh	r0,r0[0x0]
800026b6:	cc b0       	breq	8000264c <mic_reply_func+0x10>
800026b8:	80 00       	ld.sh	r0,r0[0x0]
800026ba:	cc c4       	brge	80002652 <mic_reply_func+0x16>
800026bc:	80 00       	ld.sh	r0,r0[0x0]
800026be:	cc d8       	rjmp	80002858 <DataSession_brdcst_func+0xb0>
800026c0:	80 00       	ld.sh	r0,r0[0x0]
800026c2:	cc f4       	brge	80002660 <mic_reply_func+0x24>
800026c4:	80 00       	ld.sh	r0,r0[0x0]
800026c6:	cd 0c       	rcall	80002866 <DataSession_brdcst_func+0xbe>
800026c8:	80 00       	ld.sh	r0,r0[0x0]
800026ca:	cd 24       	brge	8000266e <mic_reply_func+0x32>
800026cc:	80 00       	ld.sh	r0,r0[0x0]
800026ce:	cd 3c       	rcall	80002874 <DataSession_brdcst_func+0xcc>

800026d0 <dcm_brdcst_func>:
	}
}


void dcm_brdcst_func(xcmp_fragment_t * xcmp)
{
800026d0:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	DeviceControlMode_brdcst_t *ptr = (DeviceControlMode_brdcst_t* )xcmp->u8;
800026d4:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Dcm_brdcst \n\r");		
800026d8:	48 bc       	lddpc	r12,80002704 <dcm_brdcst_func+0x34>
800026da:	f0 1f 00 0c 	mcall	80002708 <dcm_brdcst_func+0x38>
	log("\n\r Function: %x \n\r " ,  ptr->Function);
800026de:	0f 88       	ld.ub	r8,r7[0x0]
800026e0:	1a d8       	st.w	--sp,r8
800026e2:	48 bc       	lddpc	r12,8000270c <dcm_brdcst_func+0x3c>
800026e4:	f0 1f 00 09 	mcall	80002708 <dcm_brdcst_func+0x38>
	log("\n\r ControlType: %x \n\r " ,  ptr->ControlType);
800026e8:	0f a8       	ld.ub	r8,r7[0x2]
800026ea:	1a d8       	st.w	--sp,r8
800026ec:	48 9c       	lddpc	r12,80002710 <dcm_brdcst_func+0x40>
800026ee:	f0 1f 00 07 	mcall	80002708 <dcm_brdcst_func+0x38>
	log("\n\r ControlTypeSize: %x \n\r " ,  ptr->ControlTypeSize);
800026f2:	0f 98       	ld.ub	r8,r7[0x1]
800026f4:	1a d8       	st.w	--sp,r8
800026f6:	48 8c       	lddpc	r12,80002714 <dcm_brdcst_func+0x44>
800026f8:	f0 1f 00 04 	mcall	80002708 <dcm_brdcst_func+0x38>
800026fc:	2f dd       	sub	sp,-12
	
	
}
800026fe:	e3 cd 80 80 	ldm	sp++,r7,pc
80002702:	00 00       	add	r0,r0
80002704:	80 00       	ld.sh	r0,r0[0x0]
80002706:	cd 4c       	rcall	800028ae <DeviceInitializationStatus_brdcst_func+0x2e>
80002708:	80 00       	ld.sh	r0,r0[0x0]
8000270a:	67 14       	ld.w	r4,r3[0x44]
8000270c:	80 00       	ld.sh	r0,r0[0x0]
8000270e:	cd 60       	breq	800026ba <mic_reply_func+0x7e>
80002710:	80 00       	ld.sh	r0,r0[0x0]
80002712:	cd 74       	brge	800026c0 <mic_reply_func+0x84>
80002714:	80 00       	ld.sh	r0,r0[0x0]
80002716:	cd 8c       	rcall	800028c6 <send_flash_command+0xe>

80002718 <dcm_reply_func>:
		log("Tone error");
	}
}

void dcm_reply_func(xcmp_fragment_t * xcmp)
{
80002718:	eb cd 40 80 	pushm	r7,lr
8000271c:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
8000271e:	19 a9       	ld.ub	r9,r12[0x2]
80002720:	30 08       	mov	r8,0
80002722:	f0 09 18 00 	cp.b	r9,r8
80002726:	c1 b1       	brne	8000275c <dcm_reply_func+0x44>
	{
		if(xcmp->u8[1] == DCM_ENTER)
80002728:	19 b8       	ld.ub	r8,r12[0x3]
8000272a:	30 19       	mov	r9,1
8000272c:	f2 08 18 00 	cp.b	r8,r9
80002730:	c0 51       	brne	8000273a <dcm_reply_func+0x22>
		{
			log("\n\r Dcm-Enter OK \n\r");
80002732:	48 ec       	lddpc	r12,80002768 <dcm_reply_func+0x50>
80002734:	f0 1f 00 0e 	mcall	8000276c <dcm_reply_func+0x54>
80002738:	c0 a8       	rjmp	8000274c <dcm_reply_func+0x34>
			
		}
		else if (xcmp->u8[1] == DCM_EXIT)
8000273a:	58 08       	cp.w	r8,0
8000273c:	c0 51       	brne	80002746 <dcm_reply_func+0x2e>
		{
			log("\n\r Dcm-Exit OK \n\r");
8000273e:	48 dc       	lddpc	r12,80002770 <dcm_reply_func+0x58>
80002740:	f0 1f 00 0b 	mcall	8000276c <dcm_reply_func+0x54>
80002744:	c0 48       	rjmp	8000274c <dcm_reply_func+0x34>
		}
		else
		{
			log("\n\r Dcm-Revoke \n\r");
80002746:	48 cc       	lddpc	r12,80002774 <dcm_reply_func+0x5c>
80002748:	f0 1f 00 09 	mcall	8000276c <dcm_reply_func+0x54>
		}
		
		log("dcm OK-mo%X", xcmp->u8[3]);
8000274c:	0f d8       	ld.ub	r8,r7[0x5]
8000274e:	1a d8       	st.w	--sp,r8
80002750:	48 ac       	lddpc	r12,80002778 <dcm_reply_func+0x60>
80002752:	f0 1f 00 07 	mcall	8000276c <dcm_reply_func+0x54>
80002756:	2f fd       	sub	sp,-4
80002758:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		log("dcm error");
8000275c:	48 8c       	lddpc	r12,8000277c <dcm_reply_func+0x64>
8000275e:	f0 1f 00 04 	mcall	8000276c <dcm_reply_func+0x54>
80002762:	e3 cd 80 80 	ldm	sp++,r7,pc
80002766:	00 00       	add	r0,r0
80002768:	80 00       	ld.sh	r0,r0[0x0]
8000276a:	cd a8       	rjmp	8000291e <send_flash_command+0x66>
8000276c:	80 00       	ld.sh	r0,r0[0x0]
8000276e:	67 14       	ld.w	r4,r3[0x44]
80002770:	80 00       	ld.sh	r0,r0[0x0]
80002772:	cd bc       	rcall	80002928 <send_flash_command+0x70>
80002774:	80 00       	ld.sh	r0,r0[0x0]
80002776:	cd d0       	breq	80002730 <dcm_reply_func+0x18>
80002778:	80 00       	ld.sh	r0,r0[0x0]
8000277a:	cd e4       	brge	80002736 <dcm_reply_func+0x1e>
8000277c:	80 00       	ld.sh	r0,r0[0x0]
8000277e:	cd f0       	breq	8000273c <dcm_reply_func+0x24>

80002780 <ToneControl_reply_func>:
			}
		}
}

void ToneControl_reply_func(xcmp_fragment_t * xcmp)
{
80002780:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
80002782:	19 a9       	ld.ub	r9,r12[0x2]
80002784:	30 08       	mov	r8,0
80002786:	f0 09 18 00 	cp.b	r9,r8
8000278a:	c0 51       	brne	80002794 <ToneControl_reply_func+0x14>
	{		
		log("Tone OK\n");
8000278c:	48 4c       	lddpc	r12,8000279c <ToneControl_reply_func+0x1c>
8000278e:	f0 1f 00 05 	mcall	800027a0 <ToneControl_reply_func+0x20>
80002792:	d8 02       	popm	pc
		//fl_write("/test.txt", FILE_END, (void *)"send tone ok\r\n", sizeof("send tone ok\r\n") - 1);
	}
	else
	{
		log("Tone error");
80002794:	48 4c       	lddpc	r12,800027a4 <ToneControl_reply_func+0x24>
80002796:	f0 1f 00 03 	mcall	800027a0 <ToneControl_reply_func+0x20>
8000279a:	d8 02       	popm	pc
8000279c:	80 00       	ld.sh	r0,r0[0x0]
8000279e:	cd fc       	rcall	8000295c <send_flash_command+0xa4>
800027a0:	80 00       	ld.sh	r0,r0[0x0]
800027a2:	67 14       	ld.w	r4,r3[0x44]
800027a4:	80 00       	ld.sh	r0,r0[0x0]
800027a6:	ce 08       	rjmp	80002966 <send_flash_command+0xae>

800027a8 <DataSession_brdcst_func>:
	}
	
}

void DataSession_brdcst_func(xcmp_fragment_t * xcmp)
{
800027a8:	d4 21       	pushm	r4-r7,lr
	U8 Session_number = 0;
	U16 data_length = 0;
	U8 i = 0;
	/*point to xcmp payload*/
	DataSession_brdcst_t *ptr = (DataSession_brdcst_t* )xcmp->u8;
800027aa:	f8 c6 ff fe 	sub	r6,r12,-2

	if (ptr->State == CSBK_DATA_RX_Suc)
800027ae:	0d 88       	ld.ub	r8,r6[0x0]
800027b0:	32 49       	mov	r9,36
800027b2:	f2 08 18 00 	cp.b	r8,r9
800027b6:	c2 91       	brne	80002808 <DataSession_brdcst_func+0x60>
	{
		
		log("\n\r CSBK_RX OK \n\r");
800027b8:	4a 9c       	lddpc	r12,8000285c <DataSession_brdcst_func+0xb4>
800027ba:	f0 1f 00 2a 	mcall	80002860 <DataSession_brdcst_func+0xb8>
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
800027be:	0d a5       	ld.ub	r5,r6[0x2]
800027c0:	0d b8       	ld.ub	r8,r6[0x3]
800027c2:	f1 e5 10 85 	or	r5,r8,r5<<0x8
800027c6:	5c 85       	casts.h	r5

		log("\n\r Session_ID: %x \n\r",Session_number );
800027c8:	0d 98       	ld.ub	r8,r6[0x1]
800027ca:	1a d8       	st.w	--sp,r8
800027cc:	4a 6c       	lddpc	r12,80002864 <DataSession_brdcst_func+0xbc>
800027ce:	f0 1f 00 25 	mcall	80002860 <DataSession_brdcst_func+0xb8>
		log("\n\r paylaod_length: %d \n\r",data_length );
800027d2:	f1 d5 c0 10 	bfextu	r8,r5,0x0,0x10
800027d6:	1a d8       	st.w	--sp,r8
800027d8:	4a 4c       	lddpc	r12,80002868 <DataSession_brdcst_func+0xc0>
800027da:	f0 1f 00 22 	mcall	80002860 <DataSession_brdcst_func+0xb8>
		for(i=0; i<data_length; i++)
800027de:	2f ed       	sub	sp,-8
800027e0:	58 05       	cp.w	r5,0
800027e2:	c3 b0       	breq	80002858 <DataSession_brdcst_func+0xb0>
800027e4:	30 07       	mov	r7,0
		{
			
			//log("\n\r payload[%d]: %X \n\r", i, xcmp->u8[4+i]);
			log("\n\r payload[%d]: %X \n\r", i, ptr->DataPayload.DataPayload[i]);
800027e6:	4a 24       	lddpc	r4,8000286c <DataSession_brdcst_func+0xc4>
800027e8:	ec 07 00 08 	add	r8,r6,r7
800027ec:	11 c8       	ld.ub	r8,r8[0x4]
800027ee:	1a d8       	st.w	--sp,r8
800027f0:	1a d7       	st.w	--sp,r7
800027f2:	08 9c       	mov	r12,r4
800027f4:	f0 1f 00 1b 	mcall	80002860 <DataSession_brdcst_func+0xb8>
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);

		log("\n\r Session_ID: %x \n\r",Session_number );
		log("\n\r paylaod_length: %d \n\r",data_length );
		for(i=0; i<data_length; i++)
800027f8:	2f f7       	sub	r7,-1
800027fa:	5c 57       	castu.b	r7
800027fc:	2f ed       	sub	sp,-8
800027fe:	ee 05 19 00 	cp.h	r5,r7
80002802:	fe 9b ff f3 	brhi	800027e8 <DataSession_brdcst_func+0x40>
80002806:	d8 22       	popm	r4-r7,pc
		
	}
	else
	{
		//log("\n\r State: 0x %X \n\r", xcmp->u8[0]);
		log("State: %X \n", ptr->State);
80002808:	1a d8       	st.w	--sp,r8
8000280a:	49 ac       	lddpc	r12,80002870 <DataSession_brdcst_func+0xc8>
8000280c:	f0 1f 00 15 	mcall	80002860 <DataSession_brdcst_func+0xb8>
		if (ptr->State == DATA_SESSION_TX_Suc)
80002810:	0d 88       	ld.ub	r8,r6[0x0]
80002812:	2f fd       	sub	sp,-4
80002814:	30 39       	mov	r9,3
80002816:	f2 08 18 00 	cp.b	r8,r9
8000281a:	c0 51       	brne	80002824 <DataSession_brdcst_func+0x7c>
		{
			log("data transmit success\n");
8000281c:	49 6c       	lddpc	r12,80002874 <DataSession_brdcst_func+0xcc>
8000281e:	f0 1f 00 11 	mcall	80002860 <DataSession_brdcst_func+0xb8>
80002822:	c0 c8       	rjmp	8000283a <DataSession_brdcst_func+0x92>
		}
		else if(ptr->State == DATA_SESSION_TX_Fail)
80002824:	30 49       	mov	r9,4
80002826:	f2 08 18 00 	cp.b	r8,r9
8000282a:	c0 81       	brne	8000283a <DataSession_brdcst_func+0x92>
		{
			log("data transmit failure\n");
8000282c:	49 3c       	lddpc	r12,80002878 <DataSession_brdcst_func+0xd0>
8000282e:	f0 1f 00 0d 	mcall	80002860 <DataSession_brdcst_func+0xb8>
			xcmp_IdleTestTone(Tone_Start, BT_Disconnecting_Success_Tone);//set tone to noticy failure!!!
80002832:	37 8b       	mov	r11,120
80002834:	30 1c       	mov	r12,1
80002836:	f0 1f 00 12 	mcall	8000287c <DataSession_brdcst_func+0xd4>
		}
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];
			
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
8000283a:	0d a7       	ld.ub	r7,r6[0x2]
8000283c:	0d b8       	ld.ub	r8,r6[0x3]
8000283e:	f1 e7 10 87 	or	r7,r8,r7<<0x8

		log("\n\r Session_ID: %x \n\r",Session_number );
80002842:	0d 98       	ld.ub	r8,r6[0x1]
80002844:	1a d8       	st.w	--sp,r8
80002846:	48 8c       	lddpc	r12,80002864 <DataSession_brdcst_func+0xbc>
80002848:	f0 1f 00 06 	mcall	80002860 <DataSession_brdcst_func+0xb8>
		log("\n\r paylaod_length: %d \n\r",data_length );
8000284c:	5c 77       	castu.h	r7
8000284e:	1a d7       	st.w	--sp,r7
80002850:	48 6c       	lddpc	r12,80002868 <DataSession_brdcst_func+0xc0>
80002852:	f0 1f 00 04 	mcall	80002860 <DataSession_brdcst_func+0xb8>
80002856:	2f ed       	sub	sp,-8
80002858:	d8 22       	popm	r4-r7,pc
8000285a:	00 00       	add	r0,r0
8000285c:	80 00       	ld.sh	r0,r0[0x0]
8000285e:	ce 14       	brge	80002820 <DataSession_brdcst_func+0x78>
80002860:	80 00       	ld.sh	r0,r0[0x0]
80002862:	67 14       	ld.w	r4,r3[0x44]
80002864:	80 00       	ld.sh	r0,r0[0x0]
80002866:	ce 28       	rjmp	80002a2a <send_flash_command+0x172>
80002868:	80 00       	ld.sh	r0,r0[0x0]
8000286a:	ce 40       	breq	80002832 <DataSession_brdcst_func+0x8a>
8000286c:	80 00       	ld.sh	r0,r0[0x0]
8000286e:	ce 5c       	rcall	80002a38 <send_flash_command+0x180>
80002870:	80 00       	ld.sh	r0,r0[0x0]
80002872:	ce 74       	brge	80002840 <DataSession_brdcst_func+0x98>
80002874:	80 00       	ld.sh	r0,r0[0x0]
80002876:	ce 80       	breq	80002846 <DataSession_brdcst_func+0x9e>
80002878:	80 00       	ld.sh	r0,r0[0x0]
8000287a:	ce 98       	rjmp	80002a4c <send_flash_command+0x194>
8000287c:	80 00       	ld.sh	r0,r0[0x0]
8000287e:	43 f8       	lddsp	r8,sp[0xfc]

80002880 <DeviceInitializationStatus_brdcst_func>:
static void app_payload_tx_proc(void  * payload);

//app func--list

void DeviceInitializationStatus_brdcst_func(xcmp_fragment_t  * xcmp)
{
80002880:	d4 01       	pushm	lr
	if (xcmp->u8[4] == 0x01)
80002882:	19 e8       	ld.ub	r8,r12[0x6]
80002884:	30 19       	mov	r9,1
80002886:	f2 08 18 00 	cp.b	r8,r9
8000288a:	c0 61       	brne	80002896 <DeviceInitializationStatus_brdcst_func+0x16>
	{
		bunchofrandomstatusflags |= 0x01;  //Need do nothing else.
8000288c:	48 98       	lddpc	r8,800028b0 <DeviceInitializationStatus_brdcst_func+0x30>
8000288e:	70 09       	ld.w	r9,r8[0x0]
80002890:	a1 a9       	sbr	r9,0x0
80002892:	91 09       	st.w	r8[0x0],r9
80002894:	d8 02       	popm	pc
	}
	else if(xcmp->u8[4] != 0x02)
80002896:	30 29       	mov	r9,2
80002898:	f2 08 18 00 	cp.b	r8,r9
8000289c:	c0 80       	breq	800028ac <DeviceInitializationStatus_brdcst_func+0x2c>
	{
		bunchofrandomstatusflags  &= 0xFFFFFFFC; //Device Init no longer Complete.
8000289e:	48 58       	lddpc	r8,800028b0 <DeviceInitializationStatus_brdcst_func+0x30>
800028a0:	70 09       	ld.w	r9,r8[0x0]
800028a2:	e0 19 ff fc 	andl	r9,0xfffc
800028a6:	91 09       	st.w	r8[0x0],r9
		xcmp_DeviceInitializationStatus_request();
800028a8:	f0 1f 00 03 	mcall	800028b4 <DeviceInitializationStatus_brdcst_func+0x34>
800028ac:	d8 02       	popm	pc
800028ae:	00 00       	add	r0,r0
800028b0:	00 00       	add	r0,r0
800028b2:	0d 84       	ld.ub	r4,r6[0x0]
800028b4:	80 00       	ld.sh	r0,r0[0x0]
800028b6:	43 4c       	lddsp	r12,sp[0xd0]

800028b8 <send_flash_command>:
* ----------  --------  ----------  --------------------------------------------
* 10-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
U16 send_flash_command(U16 command, U32 address, U8 *data_ptr, U16 length)
{
800028b8:	eb cd 40 fc 	pushm	r2-r7,lr
800028bc:	20 1d       	sub	sp,4
800028be:	18 97       	mov	r7,r12
800028c0:	14 95       	mov	r5,r10
800028c2:	12 96       	mov	r6,r9
	U16 status = 1;
800028c4:	30 18       	mov	r8,1
800028c6:	ba 18       	st.h	sp[0x2],r8
	U16 i = 0;

    /* in order to call spi_write(U16* data), change 3-bytes address to 3-U16 address */
	U16 addr[3];
	addr[2] = (address & 0x00ff0000) >> 16;
800028c8:	e9 db c2 08 	bfextu	r4,r11,0x10,0x8
	addr[1] = (address & 0x0000ff00) >> 8;
800028cc:	e7 db c1 08 	bfextu	r3,r11,0x8,0x8
	addr[0] = (address & 0x000000ff);
800028d0:	e5 db c0 08 	bfextu	r2,r11,0x0,0x8

	U16 data_u16;

	spi_selectChip(spi, DF_SPI_PCS_0);
800028d4:	30 0b       	mov	r11,0
800028d6:	4e 38       	lddpc	r8,80002a60 <send_flash_command+0x1a8>
800028d8:	70 0c       	ld.w	r12,r8[0x0]
800028da:	f0 1f 00 63 	mcall	80002a64 <send_flash_command+0x1ac>

    switch (command)
800028de:	30 58       	mov	r8,5
800028e0:	f0 07 19 00 	cp.h	r7,r8
800028e4:	c3 40       	breq	8000294c <send_flash_command+0x94>
800028e6:	e0 8b 00 18 	brhi	80002916 <send_flash_command+0x5e>
800028ea:	30 28       	mov	r8,2
800028ec:	f0 07 19 00 	cp.h	r7,r8
800028f0:	c5 e0       	breq	800029ac <send_flash_command+0xf4>
800028f2:	e0 8b 00 08 	brhi	80002902 <send_flash_command+0x4a>
800028f6:	30 18       	mov	r8,1
800028f8:	f0 07 19 00 	cp.h	r7,r8
800028fc:	e0 81 00 a9 	brne	80002a4e <send_flash_command+0x196>
80002900:	c9 e8       	rjmp	80002a3c <send_flash_command+0x184>
80002902:	30 38       	mov	r8,3
80002904:	f0 07 19 00 	cp.h	r7,r8
80002908:	c7 20       	breq	800029ec <send_flash_command+0x134>
8000290a:	30 48       	mov	r8,4
8000290c:	f0 07 19 00 	cp.h	r7,r8
80002910:	e0 81 00 9f 	brne	80002a4e <send_flash_command+0x196>
80002914:	c2 c8       	rjmp	8000296c <send_flash_command+0xb4>
80002916:	35 28       	mov	r8,82
80002918:	f0 07 19 00 	cp.h	r7,r8
8000291c:	c2 f0       	breq	8000297a <send_flash_command+0xc2>
8000291e:	e0 8b 00 0c 	brhi	80002936 <send_flash_command+0x7e>
80002922:	30 68       	mov	r8,6
80002924:	f0 07 19 00 	cp.h	r7,r8
80002928:	c2 20       	breq	8000296c <send_flash_command+0xb4>
8000292a:	32 08       	mov	r8,32
8000292c:	f0 07 19 00 	cp.h	r7,r8
80002930:	e0 81 00 8f 	brne	80002a4e <send_flash_command+0x196>
80002934:	c2 38       	rjmp	8000297a <send_flash_command+0xc2>
80002936:	36 08       	mov	r8,96
80002938:	f0 07 19 00 	cp.h	r7,r8
8000293c:	c3 20       	breq	800029a0 <send_flash_command+0xe8>
8000293e:	e0 68 00 d8 	mov	r8,216
80002942:	f0 07 19 00 	cp.h	r7,r8
80002946:	e0 81 00 84 	brne	80002a4e <send_flash_command+0x196>
8000294a:	c1 88       	rjmp	8000297a <send_flash_command+0xc2>
	{
		case READ_STATUS_REG:
			spi_write_byte(command);
8000294c:	4c 57       	lddpc	r7,80002a60 <send_flash_command+0x1a8>
8000294e:	30 5b       	mov	r11,5
80002950:	6e 0c       	ld.w	r12,r7[0x0]
80002952:	f0 1f 00 46 	mcall	80002a68 <send_flash_command+0x1b0>
			spi_write_dummy();
80002956:	e0 6b 00 ff 	mov	r11,255
8000295a:	6e 0c       	ld.w	r12,r7[0x0]
8000295c:	f0 1f 00 43 	mcall	80002a68 <send_flash_command+0x1b0>
			spi_read_byte(&status);
80002960:	fa cb ff fe 	sub	r11,sp,-2
80002964:	6e 0c       	ld.w	r12,r7[0x0]
80002966:	f0 1f 00 42 	mcall	80002a6c <send_flash_command+0x1b4>
			break;
8000296a:	c7 28       	rjmp	80002a4e <send_flash_command+0x196>
		case WRITE_ENABLE:
		case WRITE_DISABLE:
			spi_write_byte(command);
8000296c:	0e 9b       	mov	r11,r7
8000296e:	5c 7b       	castu.h	r11
80002970:	4b c8       	lddpc	r8,80002a60 <send_flash_command+0x1a8>
80002972:	70 0c       	ld.w	r12,r8[0x0]
80002974:	f0 1f 00 3d 	mcall	80002a68 <send_flash_command+0x1b0>
			break;
80002978:	c6 b8       	rjmp	80002a4e <send_flash_command+0x196>
		case BLOCK_ERASE_4KB:
		case BLOCK_ERASE_32KB:
		case BLOCK_ERASE_64KB:
			spi_write_byte(command);
8000297a:	4b a6       	lddpc	r6,80002a60 <send_flash_command+0x1a8>
8000297c:	0e 9b       	mov	r11,r7
8000297e:	5c 7b       	castu.h	r11
80002980:	6c 0c       	ld.w	r12,r6[0x0]
80002982:	f0 1f 00 3a 	mcall	80002a68 <send_flash_command+0x1b0>
			spi_write_byte(addr[2]);
80002986:	08 9b       	mov	r11,r4
80002988:	6c 0c       	ld.w	r12,r6[0x0]
8000298a:	f0 1f 00 38 	mcall	80002a68 <send_flash_command+0x1b0>
			spi_write_byte(addr[1]);
8000298e:	06 9b       	mov	r11,r3
80002990:	6c 0c       	ld.w	r12,r6[0x0]
80002992:	f0 1f 00 36 	mcall	80002a68 <send_flash_command+0x1b0>
			spi_write_byte(addr[0]);
80002996:	04 9b       	mov	r11,r2
80002998:	6c 0c       	ld.w	r12,r6[0x0]
8000299a:	f0 1f 00 34 	mcall	80002a68 <send_flash_command+0x1b0>
			break;
8000299e:	c5 88       	rjmp	80002a4e <send_flash_command+0x196>
		case CHIP_ERASE:
			spi_write_byte(command);
800029a0:	36 0b       	mov	r11,96
800029a2:	4b 08       	lddpc	r8,80002a60 <send_flash_command+0x1a8>
800029a4:	70 0c       	ld.w	r12,r8[0x0]
800029a6:	f0 1f 00 31 	mcall	80002a68 <send_flash_command+0x1b0>
			break;
800029aa:	c5 28       	rjmp	80002a4e <send_flash_command+0x196>
		case BYTE_PROGRAM: /* PAGE_PROGRAM use the same value */
			spi_write_byte(command);
800029ac:	4a d7       	lddpc	r7,80002a60 <send_flash_command+0x1a8>
800029ae:	30 2b       	mov	r11,2
800029b0:	6e 0c       	ld.w	r12,r7[0x0]
800029b2:	f0 1f 00 2e 	mcall	80002a68 <send_flash_command+0x1b0>
			spi_write_byte(addr[2]);
800029b6:	08 9b       	mov	r11,r4
800029b8:	6e 0c       	ld.w	r12,r7[0x0]
800029ba:	f0 1f 00 2c 	mcall	80002a68 <send_flash_command+0x1b0>
			spi_write_byte(addr[1]);
800029be:	06 9b       	mov	r11,r3
800029c0:	6e 0c       	ld.w	r12,r7[0x0]
800029c2:	f0 1f 00 2a 	mcall	80002a68 <send_flash_command+0x1b0>
			spi_write_byte(addr[0]);
800029c6:	04 9b       	mov	r11,r2
800029c8:	6e 0c       	ld.w	r12,r7[0x0]
800029ca:	f0 1f 00 28 	mcall	80002a68 <send_flash_command+0x1b0>
			for (i = 0; i < length; i++)
800029ce:	58 06       	cp.w	r6,0
800029d0:	c3 f0       	breq	80002a4e <send_flash_command+0x196>
800029d2:	0a 97       	mov	r7,r5
			{
				data_u16 = (*data_ptr)&0x00ff;//modified by huayi
				data_ptr++;
				spi_write_byte(data_u16);
800029d4:	4a 34       	lddpc	r4,80002a60 <send_flash_command+0x1a8>
			spi_write_byte(addr[2]);
			spi_write_byte(addr[1]);
			spi_write_byte(addr[0]);
			for (i = 0; i < length; i++)
			{
				data_u16 = (*data_ptr)&0x00ff;//modified by huayi
800029d6:	0f 3b       	ld.ub	r11,r7++
800029d8:	ba 0b       	st.h	sp[0x0],r11
				data_ptr++;
				spi_write_byte(data_u16);
800029da:	68 0c       	ld.w	r12,r4[0x0]
800029dc:	f0 1f 00 23 	mcall	80002a68 <send_flash_command+0x1b0>
		case BYTE_PROGRAM: /* PAGE_PROGRAM use the same value */
			spi_write_byte(command);
			spi_write_byte(addr[2]);
			spi_write_byte(addr[1]);
			spi_write_byte(addr[0]);
			for (i = 0; i < length; i++)
800029e0:	0e 98       	mov	r8,r7
800029e2:	0a 18       	sub	r8,r5
800029e4:	ec 08 19 00 	cp.h	r8,r6
800029e8:	cf 73       	brcs	800029d6 <send_flash_command+0x11e>
800029ea:	c3 28       	rjmp	80002a4e <send_flash_command+0x196>
				data_ptr++;
				spi_write_byte(data_u16);
			}
			break;
		case READ_ARRAY:
			spi_write_byte(command);
800029ec:	49 d7       	lddpc	r7,80002a60 <send_flash_command+0x1a8>
800029ee:	30 3b       	mov	r11,3
800029f0:	6e 0c       	ld.w	r12,r7[0x0]
800029f2:	f0 1f 00 1e 	mcall	80002a68 <send_flash_command+0x1b0>
			spi_write_byte(addr[2]);
800029f6:	08 9b       	mov	r11,r4
800029f8:	6e 0c       	ld.w	r12,r7[0x0]
800029fa:	f0 1f 00 1c 	mcall	80002a68 <send_flash_command+0x1b0>
			spi_write_byte(addr[1]);
800029fe:	06 9b       	mov	r11,r3
80002a00:	6e 0c       	ld.w	r12,r7[0x0]
80002a02:	f0 1f 00 1a 	mcall	80002a68 <send_flash_command+0x1b0>
			spi_write_byte(addr[0]);
80002a06:	04 9b       	mov	r11,r2
80002a08:	6e 0c       	ld.w	r12,r7[0x0]
80002a0a:	f0 1f 00 18 	mcall	80002a68 <send_flash_command+0x1b0>
			for (i = 0; i < length; i++)
80002a0e:	58 06       	cp.w	r6,0
80002a10:	c1 f0       	breq	80002a4e <send_flash_command+0x196>
80002a12:	0a 97       	mov	r7,r5
			{
				spi_write_dummy();
80002a14:	49 34       	lddpc	r4,80002a60 <send_flash_command+0x1a8>
80002a16:	e0 63 00 ff 	mov	r3,255
				spi_read_byte(&data_u16);
80002a1a:	1a 92       	mov	r2,sp
			spi_write_byte(addr[2]);
			spi_write_byte(addr[1]);
			spi_write_byte(addr[0]);
			for (i = 0; i < length; i++)
			{
				spi_write_dummy();
80002a1c:	06 9b       	mov	r11,r3
80002a1e:	68 0c       	ld.w	r12,r4[0x0]
80002a20:	f0 1f 00 12 	mcall	80002a68 <send_flash_command+0x1b0>
				spi_read_byte(&data_u16);
80002a24:	1a 9b       	mov	r11,sp
80002a26:	68 0c       	ld.w	r12,r4[0x0]
80002a28:	f0 1f 00 11 	mcall	80002a6c <send_flash_command+0x1b4>
				*data_ptr = (U8)data_u16;
80002a2c:	9a 08       	ld.sh	r8,sp[0x0]
80002a2e:	0e c8       	st.b	r7++,r8
		case READ_ARRAY:
			spi_write_byte(command);
			spi_write_byte(addr[2]);
			spi_write_byte(addr[1]);
			spi_write_byte(addr[0]);
			for (i = 0; i < length; i++)
80002a30:	0e 98       	mov	r8,r7
80002a32:	0a 18       	sub	r8,r5
80002a34:	ec 08 19 00 	cp.h	r8,r6
80002a38:	cf 23       	brcs	80002a1c <send_flash_command+0x164>
80002a3a:	c0 a8       	rjmp	80002a4e <send_flash_command+0x196>
				*data_ptr = (U8)data_u16;
				data_ptr++;
			}
			break;
		case WRITE_STATUS_REG_BYTE_1:
			spi_write_byte(command);
80002a3c:	48 97       	lddpc	r7,80002a60 <send_flash_command+0x1a8>
80002a3e:	30 1b       	mov	r11,1
80002a40:	6e 0c       	ld.w	r12,r7[0x0]
80002a42:	f0 1f 00 0a 	mcall	80002a68 <send_flash_command+0x1b0>
			spi_write_byte(UNPROTECT_ALL_SECTORS);
80002a46:	30 0b       	mov	r11,0
80002a48:	6e 0c       	ld.w	r12,r7[0x0]
80002a4a:	f0 1f 00 08 	mcall	80002a68 <send_flash_command+0x1b0>
			break;
		default:
			break;
	}

	spi_unselectChip(spi, DF_SPI_PCS_0);
80002a4e:	30 0b       	mov	r11,0
80002a50:	48 48       	lddpc	r8,80002a60 <send_flash_command+0x1a8>
80002a52:	70 0c       	ld.w	r12,r8[0x0]
80002a54:	f0 1f 00 07 	mcall	80002a70 <send_flash_command+0x1b8>

	return status;
}
80002a58:	9a 1c       	ld.sh	r12,sp[0x2]
80002a5a:	2f fd       	sub	sp,-4
80002a5c:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80002a60:	00 00       	add	r0,r0
80002a62:	1d 88       	ld.ub	r8,lr[0x0]
80002a64:	80 00       	ld.sh	r0,r0[0x0]
80002a66:	51 d8       	stdsp	sp[0x74],r8
80002a68:	80 00       	ld.sh	r0,r0[0x0]
80002a6a:	50 72       	stdsp	sp[0x1c],r2
80002a6c:	80 00       	ld.sh	r0,r0[0x0]
80002a6e:	50 8e       	stdsp	sp[0x20],lr
80002a70:	80 00       	ld.sh	r0,r0[0x0]
80002a72:	51 98       	stdsp	sp[0x64],r8

80002a74 <data_flash_read_block>:
* ----------  --------  ----------  --------------------------------------------
* 25-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_read_block(U32 address, U16 length, U8 *data_ptr)
{
80002a74:	d4 01       	pushm	lr
	/* check input parameter */
	if (data_ptr == NULL || address >= DF_MAX_ADDR || length > 0x1000)
80002a76:	58 0a       	cp.w	r10,0
80002a78:	5f 09       	sreq	r9
80002a7a:	e0 68 ff fe 	mov	r8,65534
80002a7e:	ea 18 00 7f 	orh	r8,0x7f
80002a82:	10 3c       	cp.w	r12,r8
80002a84:	5f b8       	srhi	r8
80002a86:	f3 e8 10 08 	or	r8,r9,r8
80002a8a:	c0 e1       	brne	80002aa6 <data_flash_read_block+0x32>
80002a8c:	e0 68 10 00 	mov	r8,4096
80002a90:	f0 0b 19 00 	cp.h	r11,r8
80002a94:	e0 8b 00 09 	brhi	80002aa6 <data_flash_read_block+0x32>
	{
		return DF_INVALID_PARAM;
	}

	send_flash_command(READ_ARRAY, address, data_ptr, length);
80002a98:	f3 db c0 10 	bfextu	r9,r11,0x0,0x10
80002a9c:	18 9b       	mov	r11,r12
80002a9e:	30 3c       	mov	r12,3
80002aa0:	f0 1f 00 02 	mcall	80002aa8 <data_flash_read_block+0x34>
80002aa4:	d8 0a       	popm	pc,r12=0

	return DF_OK;
80002aa6:	da 0a       	popm	pc,r12=1
80002aa8:	80 00       	ld.sh	r0,r0[0x0]
80002aaa:	28 b8       	sub	r8,-117

80002aac <data_flash_write_page>:
* ----------  --------  ----------  --------------------------------------------
* 25-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_write_page(U8 *data_ptr, U32 address, U16 length)
{
80002aac:	eb cd 40 e0 	pushm	r5-r7,lr
80002ab0:	18 96       	mov	r6,r12
80002ab2:	16 97       	mov	r7,r11
80002ab4:	14 95       	mov	r5,r10
	U16 status = 1;
	df_status_t return_code = DF_WRITE_FAIL;
	U16 count = 0; /* to monitor write time consumption */

	/* check input parameter */
	if (data_ptr == NULL || address >= DF_MAX_ADDR || length > DF_PAGE_SIZE)
80002ab6:	58 0c       	cp.w	r12,0
80002ab8:	5f 09       	sreq	r9
80002aba:	e0 68 ff fe 	mov	r8,65534
80002abe:	ea 18 00 7f 	orh	r8,0x7f
80002ac2:	10 3b       	cp.w	r11,r8
80002ac4:	5f b8       	srhi	r8
80002ac6:	f3 e8 10 08 	or	r8,r9,r8
80002aca:	c3 91       	brne	80002b3c <data_flash_write_page+0x90>
80002acc:	e0 68 01 00 	mov	r8,256
80002ad0:	f0 0a 19 00 	cp.h	r10,r8
80002ad4:	e0 8b 00 34 	brhi	80002b3c <data_flash_write_page+0x90>
	{
		return DF_INVALID_PARAM;
	}

	status = send_flash_command(READ_STATUS_REG, 0, NULL, 0);
80002ad8:	30 09       	mov	r9,0
80002ada:	12 9a       	mov	r10,r9
80002adc:	12 9b       	mov	r11,r9
80002ade:	30 5c       	mov	r12,5
80002ae0:	f0 1f 00 19 	mcall	80002b44 <data_flash_write_page+0x98>
	if ((status & STATUS_BUSY) != 0)
80002ae4:	f9 dc c0 01 	bfextu	r12,r12,0x0,0x1
80002ae8:	c0 30       	breq	80002aee <data_flash_write_page+0x42>
80002aea:	30 27       	mov	r7,2
80002aec:	c2 98       	rjmp	80002b3e <data_flash_write_page+0x92>
	{
		return DF_DEVICE_BUSY;
	}

	/* send WRITE_ENABLE command */
	send_flash_command(WRITE_ENABLE, 0, NULL, 0);
80002aee:	30 09       	mov	r9,0
80002af0:	12 9a       	mov	r10,r9
80002af2:	12 9b       	mov	r11,r9
80002af4:	30 6c       	mov	r12,6
80002af6:	f0 1f 00 14 	mcall	80002b44 <data_flash_write_page+0x98>

	/* send PAGE_PROGRAM command */
	send_flash_command(PAGE_PROGRAM, address, data_ptr, length);
80002afa:	f3 d5 c0 10 	bfextu	r9,r5,0x0,0x10
80002afe:	0c 9a       	mov	r10,r6
80002b00:	0e 9b       	mov	r11,r7
80002b02:	30 2c       	mov	r12,2
80002b04:	f0 1f 00 10 	mcall	80002b44 <data_flash_write_page+0x98>
	do {
		status = send_flash_command(READ_STATUS_REG, 0, NULL, 0);
80002b08:	30 05       	mov	r5,0
80002b0a:	30 56       	mov	r6,5
80002b0c:	0a 99       	mov	r9,r5
80002b0e:	0a 9a       	mov	r10,r5
80002b10:	0a 9b       	mov	r11,r5
80002b12:	0c 9c       	mov	r12,r6
80002b14:	f0 1f 00 0c 	mcall	80002b44 <data_flash_write_page+0x98>
		count++;
	} while((status & STATUS_BUSY) != 0);
80002b18:	5c 7c       	castu.h	r12
80002b1a:	f1 dc c0 01 	bfextu	r8,r12,0x0,0x1
80002b1e:	cf 71       	brne	80002b0c <data_flash_write_page+0x60>

	/*  Check Status Register */
	if ((status & STATUS_ERASE_PROG_ERROR) != 0)
80002b20:	18 97       	mov	r7,r12
80002b22:	e2 17 00 20 	andl	r7,0x20,COH
80002b26:	f9 b7 01 06 	movne	r7,6
80002b2a:	f9 b7 00 07 	moveq	r7,7
		/*  Erase Successful.  */
		return_code = DF_WRITE_COMPLETED;
	}

	/* send WRITE_DISABLE command */
	send_flash_command(WRITE_DISABLE, 0, NULL, 0);
80002b2e:	30 09       	mov	r9,0
80002b30:	12 9a       	mov	r10,r9
80002b32:	12 9b       	mov	r11,r9
80002b34:	30 4c       	mov	r12,4
80002b36:	f0 1f 00 04 	mcall	80002b44 <data_flash_write_page+0x98>

	return return_code;
80002b3a:	c0 28       	rjmp	80002b3e <data_flash_write_page+0x92>
80002b3c:	30 17       	mov	r7,1
}
80002b3e:	0e 9c       	mov	r12,r7
80002b40:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80002b44:	80 00       	ld.sh	r0,r0[0x0]
80002b46:	28 b8       	sub	r8,-117

80002b48 <data_flash_write_block>:
* ----------  --------  ----------  --------------------------------------------
* 25-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_write_block(U8 *data_ptr, U32 address, U16 data_length)
{
80002b48:	d4 31       	pushm	r0-r7,lr
80002b4a:	18 94       	mov	r4,r12
80002b4c:	ed da b0 10 	bfexts	r6,r10,0x0,0x10
80002b50:	16 97       	mov	r7,r11
80002b52:	30 7c       	mov	r12,7
	df_status_t return_code = DF_WRITE_COMPLETED;
	U32 write_addr = address;
	U16 bytes_remained = data_length;

	while (bytes_remained >= 1 && return_code == DF_WRITE_COMPLETED)
80002b54:	30 03       	mov	r3,0
80002b56:	06 92       	mov	r2,r3
	{
		if ((write_addr & 0xFF) == 0)
		{
			/* address 256 bytes aligned */

			if (bytes_remained <= DF_PAGE_SIZE)
80002b58:	e0 60 01 00 	mov	r0,256
{
	df_status_t return_code = DF_WRITE_COMPLETED;
	U32 write_addr = address;
	U16 bytes_remained = data_length;

	while (bytes_remained >= 1 && return_code == DF_WRITE_COMPLETED)
80002b5c:	c4 98       	rjmp	80002bee <data_flash_write_block+0xa6>
	{
		if ((write_addr & 0xFF) == 0)
80002b5e:	eb d7 c0 08 	bfextu	r5,r7,0x0,0x8
80002b62:	c1 b1       	brne	80002b98 <data_flash_write_block+0x50>
		{
			/* address 256 bytes aligned */

			if (bytes_remained <= DF_PAGE_SIZE)
80002b64:	e0 06 19 00 	cp.h	r6,r0
80002b68:	e0 8b 00 0a 	brhi	80002b7c <data_flash_write_block+0x34>
			{
				/* bytes remained less than one page */
				return_code = data_flash_write_page(data_ptr, write_addr, bytes_remained);
80002b6c:	f5 d6 c0 10 	bfextu	r10,r6,0x0,0x10
80002b70:	0e 9b       	mov	r11,r7
80002b72:	08 9c       	mov	r12,r4
80002b74:	f0 1f 00 24 	mcall	80002c04 <data_flash_write_block+0xbc>
80002b78:	30 06       	mov	r6,0
80002b7a:	c3 a8       	rjmp	80002bee <data_flash_write_block+0xa6>
				bytes_remained = 0;	/* end while loop */
			}
			else /* (bytes_remained > DF_PAGE_SIZE) */
			{
				/* bytes remained more than one page */
				return_code = data_flash_write_page(data_ptr, write_addr, DF_PAGE_SIZE);
80002b7c:	e0 6a 01 00 	mov	r10,256
80002b80:	0e 9b       	mov	r11,r7
80002b82:	08 9c       	mov	r12,r4
80002b84:	f0 1f 00 20 	mcall	80002c04 <data_flash_write_block+0xbc>
				bytes_remained -= DF_PAGE_SIZE;
80002b88:	ec c6 01 00 	sub	r6,r6,256
80002b8c:	5c 86       	casts.h	r6
				data_ptr += DF_PAGE_SIZE;
80002b8e:	e8 c4 ff 00 	sub	r4,r4,-256
				write_addr += DF_PAGE_SIZE;
80002b92:	ee c7 ff 00 	sub	r7,r7,-256
80002b96:	c2 c8       	rjmp	80002bee <data_flash_write_block+0xa6>
		}
		else
		{
			/*(write_addr & 0xFF != 0), address not 256 bytes aligned */

			if (BEYOND_PAGE_BOUNDARY(write_addr, bytes_remained) == TRUE)
80002b98:	f3 d6 c0 10 	bfextu	r9,r6,0x0,0x10
80002b9c:	0e 09       	add	r9,r7
80002b9e:	0e 98       	mov	r8,r7
80002ba0:	e4 18 00 7f 	andh	r8,0x7f
80002ba4:	e0 18 ff 00 	andl	r8,0xff00
80002ba8:	f0 c8 ff 00 	sub	r8,r8,-256
80002bac:	10 39       	cp.w	r9,r8
80002bae:	e0 88 00 19 	brls	80002be0 <data_flash_write_block+0x98>
			{
				/* bytes remained exceed current page, only write data within current page */
				return_code = data_flash_write_page(data_ptr, write_addr, BYTES_TO_NEXT_PAGE_BOUNDARY(write_addr));
80002bb2:	0e 91       	mov	r1,r7
80002bb4:	5c 51       	castu.b	r1
80002bb6:	e0 6a 01 00 	mov	r10,256
80002bba:	02 1a       	sub	r10,r1
80002bbc:	5c 7a       	castu.h	r10
80002bbe:	0e 9b       	mov	r11,r7
80002bc0:	08 9c       	mov	r12,r4
80002bc2:	f0 1f 00 11 	mcall	80002c04 <data_flash_write_block+0xbc>
				bytes_remained -= BYTES_TO_NEXT_PAGE_BOUNDARY(write_addr);
80002bc6:	ec c6 01 00 	sub	r6,r6,256
80002bca:	02 06       	add	r6,r1
80002bcc:	5c 86       	casts.h	r6
				data_ptr += BYTES_TO_NEXT_PAGE_BOUNDARY(write_addr);
80002bce:	e0 68 01 00 	mov	r8,256
80002bd2:	f0 05 01 05 	sub	r5,r8,r5
80002bd6:	0a 04       	add	r4,r5
				write_addr += BYTES_TO_NEXT_PAGE_BOUNDARY(write_addr); /* now became 256 bytes aligned */
80002bd8:	e0 17 ff 00 	andl	r7,0xff00
80002bdc:	10 07       	add	r7,r8
80002bde:	c0 88       	rjmp	80002bee <data_flash_write_block+0xa6>
			}
			else
			{
				/* bytes remained not exceed current page */
				return_code = data_flash_write_page(data_ptr, write_addr, bytes_remained);
80002be0:	f5 d6 c0 10 	bfextu	r10,r6,0x0,0x10
80002be4:	0e 9b       	mov	r11,r7
80002be6:	08 9c       	mov	r12,r4
80002be8:	f0 1f 00 07 	mcall	80002c04 <data_flash_write_block+0xbc>
80002bec:	30 06       	mov	r6,0
{
	df_status_t return_code = DF_WRITE_COMPLETED;
	U32 write_addr = address;
	U16 bytes_remained = data_length;

	while (bytes_remained >= 1 && return_code == DF_WRITE_COMPLETED)
80002bee:	e6 06 19 00 	cp.h	r6,r3
80002bf2:	5f 19       	srne	r9
80002bf4:	58 7c       	cp.w	r12,7
80002bf6:	5f 08       	sreq	r8
80002bf8:	f3 e8 00 08 	and	r8,r9,r8
80002bfc:	e4 08 18 00 	cp.b	r8,r2
80002c00:	ca f1       	brne	80002b5e <data_flash_write_block+0x16>
			}
		}
	}	/* end of while */

	return return_code;
}
80002c02:	d8 32       	popm	r0-r7,pc
80002c04:	80 00       	ld.sh	r0,r0[0x0]
80002c06:	2a ac       	sub	r12,-86

80002c08 <data_flash_erase_block>:
* ----------  --------  ----------  --------------------------------------------
* 25-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_erase_block(U32 address, df_block_size_t block_size)
{
80002c08:	eb cd 40 c0 	pushm	r6-r7,lr
80002c0c:	18 97       	mov	r7,r12
	U16 erase_commond;
	df_status_t return_code = DF_ERASE_FAIL;
	U16 count = 0; /* to monitor erase time consumption */

	/* check input parameter */
	if (address >= DF_MAX_ADDR)
80002c0e:	e0 68 ff fe 	mov	r8,65534
80002c12:	ea 18 00 7f 	orh	r8,0x7f
80002c16:	10 3c       	cp.w	r12,r8
80002c18:	e0 88 00 04 	brls	80002c20 <data_flash_erase_block+0x18>
80002c1c:	30 17       	mov	r7,1
80002c1e:	c3 e8       	rjmp	80002c9a <data_flash_erase_block+0x92>
	{
		return DF_INVALID_PARAM;
	}

	/* determine erase command to be issued */
	if (block_size == DF_BLOCK_4KB)
80002c20:	58 1b       	cp.w	r11,1
80002c22:	c0 31       	brne	80002c28 <data_flash_erase_block+0x20>
80002c24:	32 06       	mov	r6,32
80002c26:	c0 a8       	rjmp	80002c3a <data_flash_erase_block+0x32>
		erase_commond = BLOCK_ERASE_4KB;
	else if (block_size == DF_BLOCK_32KB)
80002c28:	58 2b       	cp.w	r11,2
80002c2a:	c0 31       	brne	80002c30 <data_flash_erase_block+0x28>
80002c2c:	35 26       	mov	r6,82
80002c2e:	c0 68       	rjmp	80002c3a <data_flash_erase_block+0x32>
		erase_commond = BLOCK_ERASE_32KB;
	else if(block_size == DF_BLOCK_64KB)
80002c30:	e0 66 00 d8 	mov	r6,216
80002c34:	58 3b       	cp.w	r11,3
80002c36:	f9 b6 01 60 	movne	r6,96
		erase_commond = BLOCK_ERASE_64KB;
	else/*(block_size == DF_BLOCK_ALL)*/
		erase_commond = CHIP_ERASE;

	status = send_flash_command(READ_STATUS_REG, 0, NULL, 0);
80002c3a:	30 09       	mov	r9,0
80002c3c:	12 9a       	mov	r10,r9
80002c3e:	12 9b       	mov	r11,r9
80002c40:	30 5c       	mov	r12,5
80002c42:	f0 1f 00 18 	mcall	80002ca0 <data_flash_erase_block+0x98>
	if ((status & STATUS_BUSY) != 0)
80002c46:	f9 dc c0 01 	bfextu	r12,r12,0x0,0x1
80002c4a:	c0 30       	breq	80002c50 <data_flash_erase_block+0x48>
80002c4c:	30 27       	mov	r7,2
80002c4e:	c2 68       	rjmp	80002c9a <data_flash_erase_block+0x92>
	{
		return DF_DEVICE_BUSY;
	}

	/* send WRITE_ENABLE command */
	send_flash_command(WRITE_ENABLE, 0, NULL, 0);
80002c50:	30 09       	mov	r9,0
80002c52:	12 9a       	mov	r10,r9
80002c54:	12 9b       	mov	r11,r9
80002c56:	30 6c       	mov	r12,6
80002c58:	f0 1f 00 12 	mcall	80002ca0 <data_flash_erase_block+0x98>

	/* send BLOCK_ERASE command */
	send_flash_command(erase_commond, address, NULL, 0);
80002c5c:	30 09       	mov	r9,0
80002c5e:	12 9a       	mov	r10,r9
80002c60:	0e 9b       	mov	r11,r7
80002c62:	0c 9c       	mov	r12,r6
80002c64:	f0 1f 00 0f 	mcall	80002ca0 <data_flash_erase_block+0x98>
	do {
		status = send_flash_command(READ_STATUS_REG, 0, NULL, 0);
80002c68:	30 06       	mov	r6,0
80002c6a:	30 57       	mov	r7,5
80002c6c:	0c 99       	mov	r9,r6
80002c6e:	0c 9a       	mov	r10,r6
80002c70:	0c 9b       	mov	r11,r6
80002c72:	0e 9c       	mov	r12,r7
80002c74:	f0 1f 00 0b 	mcall	80002ca0 <data_flash_erase_block+0x98>
		count++;
	} while((status & STATUS_BUSY) != 0);
80002c78:	5c 7c       	castu.h	r12
80002c7a:	f1 dc c0 01 	bfextu	r8,r12,0x0,0x1
80002c7e:	cf 71       	brne	80002c6c <data_flash_erase_block+0x64>

	/*  Check Status Register */
	if ((status & STATUS_ERASE_PROG_ERROR) != 0)
80002c80:	18 97       	mov	r7,r12
80002c82:	e2 17 00 20 	andl	r7,0x20,COH
80002c86:	f9 b7 01 04 	movne	r7,4
80002c8a:	f9 b7 00 05 	moveq	r7,5
		/*  Erase Successful.  */
		return_code = DF_ERASE_COMPLETED;
	}

	/* send WRITE_DISABLE command */
	send_flash_command(WRITE_DISABLE, 0, NULL, 0);
80002c8e:	30 09       	mov	r9,0
80002c90:	12 9a       	mov	r10,r9
80002c92:	12 9b       	mov	r11,r9
80002c94:	30 4c       	mov	r12,4
80002c96:	f0 1f 00 03 	mcall	80002ca0 <data_flash_erase_block+0x98>

	return return_code;
}
80002c9a:	0e 9c       	mov	r12,r7
80002c9c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002ca0:	80 00       	ld.sh	r0,r0[0x0]
80002ca2:	28 b8       	sub	r8,-117

80002ca4 <data_flash_write>:
* ----------  --------  ----------  --------------------------------------------
* 25-Fri-17   Edwards    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_write(U8 *data_ptr, U32 address, U16 data_length)
{
80002ca4:	d4 31       	pushm	r0-r7,lr
80002ca6:	20 3d       	sub	sp,12
80002ca8:	50 0c       	stdsp	sp[0x0],r12
80002caa:	16 91       	mov	r1,r11
80002cac:	14 95       	mov	r5,r10
	U16 secremain;
	U16 i;
	df_status_t return_code = DF_OK;

	secpos	=	address/4096;//扇区地址 0~2047 for AT25DF641 
	secoff	=	address%4096;//在扇区内的偏移
80002cae:	f5 db c0 0c 	bfextu	r10,r11,0x0,0xc
80002cb2:	50 1a       	stdsp	sp[0x4],r10
	secremain	=	4096-secoff;//扇区剩余空间大小
80002cb4:	e0 69 10 00 	mov	r9,4096
80002cb8:	f2 0a 01 07 	sub	r7,r9,r10
80002cbc:	ea 07 19 00 	cp.h	r7,r5
80002cc0:	ea 07 17 b0 	movhi	r7,r5
80002cc4:	5c 87       	casts.h	r7
80002cc6:	16 92       	mov	r2,r11
80002cc8:	e0 12 f0 00 	andl	r2,0xf000
	if(data_length <= secremain)secremain = data_length;//不大于4096个字节
	while(1)
	{
		data_flash_read_block(secpos*4096, 4096, FLASH_BUF);//读出整个扇区的内容
80002ccc:	4a e4       	lddpc	r4,80002d84 <data_flash_write+0xe0>
		for(i=0; i<secremain; i++)//校验数据
		{
			if(FLASH_BUF[secoff+i]!=0XFF)break;//需要擦除
80002cce:	3f f6       	mov	r6,-1
* Date        Name      Prob#       Description
* ----------  --------  ----------  --------------------------------------------
* 25-Fri-17   Edwards    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_write(U8 *data_ptr, U32 address, U16 data_length)
80002cd0:	e8 c8 ff ff 	sub	r8,r4,-1
80002cd4:	50 28       	stdsp	sp[0x8],r8
			secpos++;//扇区地址增1
			secoff=0;//偏移位置为0

			data_ptr+=secremain;  //指针偏移
			address+=secremain;//写地址偏移
			data_length-=secremain;				//字节数递减
80002cd6:	12 90       	mov	r0,r9
	secoff	=	address%4096;//在扇区内的偏移
	secremain	=	4096-secoff;//扇区剩余空间大小
	if(data_length <= secremain)secremain = data_length;//不大于4096个字节
	while(1)
	{
		data_flash_read_block(secpos*4096, 4096, FLASH_BUF);//读出整个扇区的内容
80002cd8:	08 9a       	mov	r10,r4
80002cda:	e0 6b 10 00 	mov	r11,4096
80002cde:	04 9c       	mov	r12,r2
80002ce0:	f0 1f 00 2a 	mcall	80002d88 <data_flash_write+0xe4>
		for(i=0; i<secremain; i++)//校验数据
80002ce4:	58 07       	cp.w	r7,0
80002ce6:	c3 00       	breq	80002d46 <data_flash_write+0xa2>
		{
			if(FLASH_BUF[secoff+i]!=0XFF)break;//需要擦除
80002ce8:	40 13       	lddsp	r3,sp[0x4]
80002cea:	5c 73       	castu.h	r3
80002cec:	e8 03 07 08 	ld.ub	r8,r4[r3]
80002cf0:	ec 08 18 00 	cp.b	r8,r6
80002cf4:	c1 11       	brne	80002d16 <data_flash_write+0x72>
80002cf6:	e6 c9 ff ff 	sub	r9,r3,-1
80002cfa:	08 09       	add	r9,r4
80002cfc:	30 08       	mov	r8,0
80002cfe:	c0 58       	rjmp	80002d08 <data_flash_write+0x64>
80002d00:	13 3a       	ld.ub	r10,r9++
80002d02:	ec 0a 18 00 	cp.b	r10,r6
80002d06:	c0 81       	brne	80002d16 <data_flash_write+0x72>
	secremain	=	4096-secoff;//扇区剩余空间大小
	if(data_length <= secremain)secremain = data_length;//不大于4096个字节
	while(1)
	{
		data_flash_read_block(secpos*4096, 4096, FLASH_BUF);//读出整个扇区的内容
		for(i=0; i<secremain; i++)//校验数据
80002d08:	2f f8       	sub	r8,-1
80002d0a:	5c 88       	casts.h	r8
80002d0c:	f0 07 19 00 	cp.h	r7,r8
80002d10:	fe 9b ff f8 	brhi	80002d00 <data_flash_write+0x5c>
80002d14:	c1 98       	rjmp	80002d46 <data_flash_write+0xa2>
		{
			if(FLASH_BUF[secoff+i]!=0XFF)break;//需要擦除
		}
		if(i < secremain)//需要擦除
		{
			return_code = data_flash_erase_block(secpos*4096, DF_BLOCK_4KB);//擦除这个扇区
80002d16:	30 1b       	mov	r11,1
80002d18:	04 9c       	mov	r12,r2
80002d1a:	f0 1f 00 1d 	mcall	80002d8c <data_flash_write+0xe8>
80002d1e:	40 08       	lddsp	r8,sp[0x0]
80002d20:	08 03       	add	r3,r4
* Date        Name      Prob#       Description
* ----------  --------  ----------  --------------------------------------------
* 25-Fri-17   Edwards    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_write(U8 *data_ptr, U32 address, U16 data_length)
80002d22:	40 2a       	lddsp	r10,sp[0x8]
80002d24:	40 19       	lddsp	r9,sp[0x4]
80002d26:	12 0a       	add	r10,r9
80002d28:	0e 99       	mov	r9,r7
80002d2a:	20 19       	sub	r9,1
80002d2c:	5c 79       	castu.h	r9
80002d2e:	12 0a       	add	r10,r9
		if(i < secremain)//需要擦除
		{
			return_code = data_flash_erase_block(secpos*4096, DF_BLOCK_4KB);//擦除这个扇区
			for(i=0; i<secremain; i++)	   //复制
			{
				FLASH_BUF[i+secoff]=data_ptr[i];
80002d30:	11 39       	ld.ub	r9,r8++
80002d32:	06 c9       	st.b	r3++,r9
			if(FLASH_BUF[secoff+i]!=0XFF)break;//需要擦除
		}
		if(i < secremain)//需要擦除
		{
			return_code = data_flash_erase_block(secpos*4096, DF_BLOCK_4KB);//擦除这个扇区
			for(i=0; i<secremain; i++)	   //复制
80002d34:	14 33       	cp.w	r3,r10
80002d36:	cf d1       	brne	80002d30 <data_flash_write+0x8c>
			{
				FLASH_BUF[i+secoff]=data_ptr[i];
			}
			return_code = data_flash_write_block(FLASH_BUF, secpos*4096, 4096);//写入整个扇区
80002d38:	e0 6a 10 00 	mov	r10,4096
80002d3c:	04 9b       	mov	r11,r2
80002d3e:	08 9c       	mov	r12,r4
80002d40:	f0 1f 00 14 	mcall	80002d90 <data_flash_write+0xec>
80002d44:	c0 78       	rjmp	80002d52 <data_flash_write+0xae>

		}
		else 
		{
			return_code = data_flash_write_block(data_ptr, address, secremain);//写已经擦除了的,直接写入扇区剩余区间.
80002d46:	0e 9a       	mov	r10,r7
80002d48:	5c 7a       	castu.h	r10
80002d4a:	02 9b       	mov	r11,r1
80002d4c:	40 0c       	lddsp	r12,sp[0x0]
80002d4e:	f0 1f 00 11 	mcall	80002d90 <data_flash_write+0xec>
80002d52:	e4 c2 f0 00 	sub	r2,r2,-4096
		}
		if(data_length==secremain)break;//写入结束了
80002d56:	0e 98       	mov	r8,r7
80002d58:	ee 05 19 00 	cp.h	r5,r7
80002d5c:	c1 20       	breq	80002d80 <data_flash_write+0xdc>
		else//写入未结束
		{
			secpos++;//扇区地址增1
			secoff=0;//偏移位置为0

			data_ptr+=secremain;  //指针偏移
80002d5e:	5c 78       	castu.h	r8
80002d60:	40 0a       	lddsp	r10,sp[0x0]
80002d62:	10 0a       	add	r10,r8
80002d64:	50 0a       	stdsp	sp[0x0],r10
			address+=secremain;//写地址偏移
80002d66:	10 01       	add	r1,r8
			data_length-=secremain;				//字节数递减
80002d68:	0e 15       	sub	r5,r7
80002d6a:	5c 85       	casts.h	r5
80002d6c:	e0 05 19 00 	cp.h	r5,r0
80002d70:	ea 07 17 80 	movls	r7,r5
80002d74:	e0 07 17 b0 	movhi	r7,r0
80002d78:	5c 87       	casts.h	r7
80002d7a:	30 09       	mov	r9,0
80002d7c:	50 19       	stdsp	sp[0x4],r9
80002d7e:	ca db       	rjmp	80002cd8 <data_flash_write+0x34>
		}
	}
	
	return return_code;
	
}
80002d80:	2f dd       	sub	sp,-12
80002d82:	d8 32       	popm	r0-r7,pc
80002d84:	00 00       	add	r0,r0
80002d86:	0d 88       	ld.ub	r8,r6[0x0]
80002d88:	80 00       	ld.sh	r0,r0[0x0]
80002d8a:	2a 74       	sub	r4,-89
80002d8c:	80 00       	ld.sh	r0,r0[0x0]
80002d8e:	2c 08       	sub	r8,-64
80002d90:	80 00       	ld.sh	r0,r0[0x0]
80002d92:	2b 48       	sub	r8,-76

80002d94 <data_flash_init>:
* ----------  --------  ----------  --------------------------------------------
* 10-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
void data_flash_init(void)
{
80002d94:	eb cd 40 c0 	pushm	r6-r7,lr
80002d98:	20 5d       	sub	sp,20
		.spck_delay   = 0,
		.trans_delay  = 0,
		.stay_act     = 1,
		.spi_mode     = 0,
		.modfdis      = 1
	};
80002d9a:	4b f8       	lddpc	r8,80002e94 <data_flash_init+0x100>
80002d9c:	fa c6 ff fc 	sub	r6,sp,-4
80002da0:	f0 ea 00 00 	ld.d	r10,r8[0]
80002da4:	ec eb 00 00 	st.d	r6[0],r10
80002da8:	f0 e8 00 08 	ld.d	r8,r8[8]
80002dac:	ec e9 00 08 	st.d	r6[8],r8

	// Assign I/Os to SPI.
	gpio_enable_module(DF_SPI_GPIO_MAP, sizeof(DF_SPI_GPIO_MAP) / sizeof(DF_SPI_GPIO_MAP[0]));
80002db0:	30 4b       	mov	r11,4
80002db2:	4b ac       	lddpc	r12,80002e98 <data_flash_init+0x104>
80002db4:	f0 1f 00 3a 	mcall	80002e9c <data_flash_init+0x108>

	// Configure PA25 as WP pin - 1: deasserted (allow write) always
	gpio_enable_gpio_pin(AVR32_PIN_PA25);
80002db8:	31 9c       	mov	r12,25
80002dba:	f0 1f 00 3a 	mcall	80002ea0 <data_flash_init+0x10c>
 	gpio_set_gpio_pin(AVR32_PIN_PA25);
80002dbe:	31 9c       	mov	r12,25
80002dc0:	f0 1f 00 39 	mcall	80002ea4 <data_flash_init+0x110>

	spi = &AVR32_SPI;
80002dc4:	4b 97       	lddpc	r7,80002ea8 <data_flash_init+0x114>
80002dc6:	fe 7c 24 00 	mov	r12,-56320
80002dca:	8f 0c       	st.w	r7[0x0],r12

	// Initialize as master.
	spi_initMaster(spi, &spiOptions);
80002dcc:	0c 9b       	mov	r11,r6
80002dce:	f0 1f 00 38 	mcall	80002eac <data_flash_init+0x118>

	// Set selection mode: variable_ps, pcs_decode, delay.
	spi_selectionMode(spi, 0, 0, 0);
80002dd2:	30 09       	mov	r9,0
80002dd4:	12 9a       	mov	r10,r9
80002dd6:	12 9b       	mov	r11,r9
80002dd8:	6e 0c       	ld.w	r12,r7[0x0]
80002dda:	f0 1f 00 36 	mcall	80002eb0 <data_flash_init+0x11c>

	// Enable SPI.
	spi_enable(spi);
80002dde:	6e 0c       	ld.w	r12,r7[0x0]
80002de0:	f0 1f 00 35 	mcall	80002eb4 <data_flash_init+0x120>

	// Initialize data flash with SPI clock Osc0.
	if (spi_setupChipReg(spi, &spiOptions, 2*12000000) != SPI_OK)
80002de4:	e0 6a 36 00 	mov	r10,13824
80002de8:	ea 1a 01 6e 	orh	r10,0x16e
80002dec:	0c 9b       	mov	r11,r6
80002dee:	6e 0c       	ld.w	r12,r7[0x0]
80002df0:	f0 1f 00 32 	mcall	80002eb8 <data_flash_init+0x124>
80002df4:	c0 50       	breq	80002dfe <data_flash_init+0x6a>
	{
		//fatal_error(FATAL_ERROR_DATA_FLASH_SPI_INIT);
		data_flash_failure = FATAL_ERROR_DATA_FLASH_SPI_INIT;
80002df6:	30 29       	mov	r9,2
80002df8:	4b 18       	lddpc	r8,80002ebc <data_flash_init+0x128>
80002dfa:	b0 89       	st.b	r8[0x0],r9
		return;
80002dfc:	c4 88       	rjmp	80002e8c <data_flash_init+0xf8>
* 10-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
static Bool data_flash_check_device_id(void)
{
	U16 manufacturer_device_id[2] = {0x5A5A, 0x5A5A};
80002dfe:	1a 96       	mov	r6,sp
80002e00:	30 4a       	mov	r10,4
80002e02:	4b 0b       	lddpc	r11,80002ec0 <data_flash_init+0x12c>
80002e04:	1a 9c       	mov	r12,sp
80002e06:	f0 1f 00 30 	mcall	80002ec4 <data_flash_init+0x130>

	/* DF memory check. */
	/* Select the DF memory to check. */
	spi_selectChip(spi, DF_SPI_PCS_0);
80002e0a:	4a 87       	lddpc	r7,80002ea8 <data_flash_init+0x114>
80002e0c:	30 0b       	mov	r11,0
80002e0e:	6e 0c       	ld.w	r12,r7[0x0]
80002e10:	f0 1f 00 2e 	mcall	80002ec8 <data_flash_init+0x134>

	/* Send the Status Register Read command. */
	spi_write(spi, READ_M_D_ID);
80002e14:	e0 6b 00 9f 	mov	r11,159
80002e18:	6e 0c       	ld.w	r12,r7[0x0]
80002e1a:	f0 1f 00 2d 	mcall	80002ecc <data_flash_init+0x138>

	/* Send 2 dummy byte to read the status register. */
	spi_write_dummy();
80002e1e:	e0 6b 00 ff 	mov	r11,255
80002e22:	6e 0c       	ld.w	r12,r7[0x0]
80002e24:	f0 1f 00 2a 	mcall	80002ecc <data_flash_init+0x138>
	spi_read(spi, &manufacturer_device_id[0]);
80002e28:	1a 9b       	mov	r11,sp
80002e2a:	6e 0c       	ld.w	r12,r7[0x0]
80002e2c:	f0 1f 00 29 	mcall	80002ed0 <data_flash_init+0x13c>
	spi_write_dummy();
80002e30:	e0 6b 00 ff 	mov	r11,255
80002e34:	6e 0c       	ld.w	r12,r7[0x0]
80002e36:	f0 1f 00 26 	mcall	80002ecc <data_flash_init+0x138>
	spi_read(spi, &manufacturer_device_id[1]);
80002e3a:	fa cb ff fe 	sub	r11,sp,-2
80002e3e:	6e 0c       	ld.w	r12,r7[0x0]
80002e40:	f0 1f 00 24 	mcall	80002ed0 <data_flash_init+0x13c>

	/* Unselect the checked DF memory. */
	spi_unselectChip(spi, DF_SPI_PCS_0);
80002e44:	30 0b       	mov	r11,0
80002e46:	6e 0c       	ld.w	r12,r7[0x0]
80002e48:	f0 1f 00 23 	mcall	80002ed4 <data_flash_init+0x140>

	/* Unexpected device ID. */
    if ((manufacturer_device_id[0] != 0x1F) || (manufacturer_device_id[1] != 0x48))
80002e4c:	31 f8       	mov	r8,31
80002e4e:	9a 09       	ld.sh	r9,sp[0x0]
80002e50:	f0 09 19 00 	cp.h	r9,r8
80002e54:	c0 61       	brne	80002e60 <data_flash_init+0xcc>
80002e56:	34 88       	mov	r8,72
80002e58:	9a 19       	ld.sh	r9,sp[0x2]
80002e5a:	f0 09 19 00 	cp.h	r9,r8
80002e5e:	c0 50       	breq	80002e68 <data_flash_init+0xd4>
	}

	if (data_flash_check_device_id() != TRUE)
	{
		//fatal_error(FATAL_ERROR_DATA_FLASH_READ_ID);
		data_flash_failure = FATAL_ERROR_DATA_FLASH_READ_ID;
80002e60:	30 39       	mov	r9,3
80002e62:	49 78       	lddpc	r8,80002ebc <data_flash_init+0x128>
80002e64:	b0 89       	st.b	r8[0x0],r9
		return;
80002e66:	c1 38       	rjmp	80002e8c <data_flash_init+0xf8>
	}

	// Set STATUS reg to unprotect all sect
	send_flash_command(WRITE_ENABLE, 0, NULL, 0);
80002e68:	30 09       	mov	r9,0
80002e6a:	12 9a       	mov	r10,r9
80002e6c:	12 9b       	mov	r11,r9
80002e6e:	30 6c       	mov	r12,6
80002e70:	f0 1f 00 1a 	mcall	80002ed8 <data_flash_init+0x144>
	send_flash_command(WRITE_STATUS_REG_BYTE_1, 0, NULL, 0);
80002e74:	30 09       	mov	r9,0
80002e76:	12 9a       	mov	r10,r9
80002e78:	12 9b       	mov	r11,r9
80002e7a:	30 1c       	mov	r12,1
80002e7c:	f0 1f 00 17 	mcall	80002ed8 <data_flash_init+0x144>
	status = send_flash_command(READ_STATUS_REG, 0, NULL, 0);
80002e80:	30 09       	mov	r9,0
80002e82:	12 9a       	mov	r10,r9
80002e84:	12 9b       	mov	r11,r9
80002e86:	30 5c       	mov	r12,5
80002e88:	f0 1f 00 14 	mcall	80002ed8 <data_flash_init+0x144>
	
	return;
}
80002e8c:	2f bd       	sub	sp,-20
80002e8e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002e92:	00 00       	add	r0,r0
80002e94:	80 00       	ld.sh	r0,r0[0x0]
80002e96:	ce b0       	breq	80002e6c <data_flash_init+0xd8>
80002e98:	80 00       	ld.sh	r0,r0[0x0]
80002e9a:	ce c4       	brge	80002e72 <data_flash_init+0xde>
80002e9c:	80 00       	ld.sh	r0,r0[0x0]
80002e9e:	4e 74       	lddpc	r4,80003038 <phy_tx+0x48>
80002ea0:	80 00       	ld.sh	r0,r0[0x0]
80002ea2:	4e a4       	lddpc	r4,80003048 <phy_tx+0x58>
80002ea4:	80 00       	ld.sh	r0,r0[0x0]
80002ea6:	4e bc       	lddpc	r12,80003050 <get_idle_store_isr+0x4>
80002ea8:	00 00       	add	r0,r0
80002eaa:	1d 88       	ld.ub	r8,lr[0x0]
80002eac:	80 00       	ld.sh	r0,r0[0x0]
80002eae:	50 08       	stdsp	sp[0x0],r8
80002eb0:	80 00       	ld.sh	r0,r0[0x0]
80002eb2:	50 40       	stdsp	sp[0x10],r0
80002eb4:	80 00       	ld.sh	r0,r0[0x0]
80002eb6:	50 6c       	stdsp	sp[0x18],r12
80002eb8:	80 00       	ld.sh	r0,r0[0x0]
80002eba:	50 b0       	stdsp	sp[0x2c],r0
80002ebc:	00 00       	add	r0,r0
80002ebe:	0a 5c       	eor	r12,r5
80002ec0:	80 00       	ld.sh	r0,r0[0x0]
80002ec2:	ce c0       	breq	80002e9a <data_flash_init+0x106>
80002ec4:	80 00       	ld.sh	r0,r0[0x0]
80002ec6:	6f b2       	ld.w	r2,r7[0x6c]
80002ec8:	80 00       	ld.sh	r0,r0[0x0]
80002eca:	51 d8       	stdsp	sp[0x74],r8
80002ecc:	80 00       	ld.sh	r0,r0[0x0]
80002ece:	50 72       	stdsp	sp[0x1c],r2
80002ed0:	80 00       	ld.sh	r0,r0[0x0]
80002ed2:	50 8e       	stdsp	sp[0x20],lr
80002ed4:	80 00       	ld.sh	r0,r0[0x0]
80002ed6:	51 98       	stdsp	sp[0x64],r8
80002ed8:	80 00       	ld.sh	r0,r0[0x0]
80002eda:	28 b8       	sub	r8,-117

80002edc <CalculateBurst>:
Calls:
Called By: phy_payload_rx
*/

volatile RxAMBEBurstType CalculateBurst(U8 vf_sn)
{
80002edc:	20 1c       	sub	r12,1
80002ede:	5c 5c       	castu.b	r12
80002ee0:	31 18       	mov	r8,17
80002ee2:	f0 0c 18 00 	cp.b	r12,r8
80002ee6:	e0 88 00 03 	brls	80002eec <CalculateBurst+0x10>
80002eea:	5e fd       	retal	0
80002eec:	48 28       	lddpc	r8,80002ef4 <CalculateBurst+0x18>
80002eee:	f0 0c 03 2c 	ld.w	r12,r8[r12<<0x2]
			Burst_ID = 0x00;
			return VOICE_WATING;
		
	}
	
}
80002ef2:	5e fc       	retal	r12
80002ef4:	80 00       	ld.sh	r0,r0[0x0]
80002ef6:	ce e4       	brge	80002ed2 <data_flash_init+0x13e>

80002ef8 <payload_init>:
	Create the corresponding task;
Calls: xTaskCreate--freertos
Called By:app_init -- app.c
*/
void payload_init(void ( *payload_rx_func)(void * ), void ( *payload_tx_func)(void * ) )
{				
80002ef8:	d4 01       	pushm	lr
	payload_rx_exec = payload_rx_func;
80002efa:	48 98       	lddpc	r8,80002f1c <payload_init+0x24>
80002efc:	91 0c       	st.w	r8[0x0],r12
	payload_tx_exec = payload_tx_func;
80002efe:	48 98       	lddpc	r8,80002f20 <payload_init+0x28>
80002f00:	91 0b       	st.w	r8[0x0],r11
	
	
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
80002f02:	30 09       	mov	r9,0
80002f04:	1a d9       	st.w	--sp,r9
80002f06:	1a d9       	st.w	--sp,r9
80002f08:	1a d9       	st.w	--sp,r9
80002f0a:	30 28       	mov	r8,2
80002f0c:	e0 6a 04 00 	mov	r10,1024
80002f10:	48 5b       	lddpc	r11,80002f24 <payload_init+0x2c>
80002f12:	48 6c       	lddpc	r12,80002f28 <payload_init+0x30>
80002f14:	f0 1f 00 06 	mcall	80002f2c <payload_init+0x34>
80002f18:	2f dd       	sub	sp,-12
	//,  2
	//,  NULL
	//);
	//
	
}
80002f1a:	d8 02       	popm	pc
80002f1c:	00 00       	add	r0,r0
80002f1e:	0a 60       	and	r0,r5
80002f20:	00 00       	add	r0,r0
80002f22:	0a 64       	and	r4,r5
80002f24:	80 00       	ld.sh	r0,r0[0x0]
80002f26:	cf 2c       	rcall	8000310a <phy_tx_func+0x96>
80002f28:	80 00       	ld.sh	r0,r0[0x0]
80002f2a:	2f 30       	sub	r0,-13
80002f2c:	80 00       	ld.sh	r0,r0[0x0]
80002f2e:	63 50       	ld.w	r0,r1[0x54]

80002f30 <payload_rx_process>:
Description: Receive the payload
Calls:
Called By:task
*/
static void payload_rx_process(void * pvParameters)
{
80002f30:	eb cd 40 f8 	pushm	r3-r7,lr
80002f34:	20 1d       	sub	sp,4
	/*To store the elements in the queue*/
	U16  * payload_ptr;
		
	if(NULL ==   phy_payload_frame_rx)
80002f36:	48 e8       	lddpc	r8,80002f6c <payload_rx_process+0x3c>
80002f38:	70 08       	ld.w	r8,r8[0x0]
80002f3a:	58 08       	cp.w	r8,0
80002f3c:	c0 71       	brne	80002f4a <payload_rx_process+0x1a>
	{
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
80002f3e:	30 4b       	mov	r11,4
80002f40:	30 5c       	mov	r12,5
80002f42:	f0 1f 00 0c 	mcall	80002f70 <payload_rx_process+0x40>
80002f46:	48 a8       	lddpc	r8,80002f6c <payload_rx_process+0x3c>
80002f48:	91 0c       	st.w	r8[0x0],r12
	}
	
	for(;;)
	{
		if(pdTRUE == xQueueReceive( phy_payload_frame_rx, &payload_ptr,portMAX_DELAY ))
80002f4a:	48 96       	lddpc	r6,80002f6c <payload_rx_process+0x3c>
80002f4c:	30 05       	mov	r5,0
80002f4e:	3f f4       	mov	r4,-1
		{			
			payload_rx_exec(payload_ptr);//app_payload_rx_proc();
80002f50:	48 93       	lddpc	r3,80002f74 <payload_rx_process+0x44>
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
	}
	
	for(;;)
	{
		if(pdTRUE == xQueueReceive( phy_payload_frame_rx, &payload_ptr,portMAX_DELAY ))
80002f52:	6c 0c       	ld.w	r12,r6[0x0]
80002f54:	0a 99       	mov	r9,r5
80002f56:	08 9a       	mov	r10,r4
80002f58:	1a 9b       	mov	r11,sp
80002f5a:	f0 1f 00 08 	mcall	80002f78 <payload_rx_process+0x48>
80002f5e:	58 1c       	cp.w	r12,1
80002f60:	cf 91       	brne	80002f52 <payload_rx_process+0x22>
		{			
			payload_rx_exec(payload_ptr);//app_payload_rx_proc();
80002f62:	66 08       	ld.w	r8,r3[0x0]
80002f64:	40 0c       	lddsp	r12,sp[0x0]
80002f66:	5d 18       	icall	r8
80002f68:	cf 5b       	rjmp	80002f52 <payload_rx_process+0x22>
80002f6a:	00 00       	add	r0,r0
80002f6c:	00 00       	add	r0,r0
80002f6e:	0a 90       	mov	r0,r5
80002f70:	80 00       	ld.sh	r0,r0[0x0]
80002f72:	5c 7c       	castu.h	r12
80002f74:	00 00       	add	r0,r0
80002f76:	0a 60       	and	r0,r5
80002f78:	80 00       	ld.sh	r0,r0[0x0]
80002f7a:	59 70       	cp.w	r0,23

80002f7c <set_idle_store_isr>:
{
	xQueueSend(store, &ptr, 0);
}

void set_idle_store_isr(xQueueHandle store, void * ptr)
{
80002f7c:	d4 01       	pushm	lr
80002f7e:	20 2d       	sub	sp,8
80002f80:	50 0b       	stdsp	sp[0x0],r11
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002f82:	30 09       	mov	r9,0
80002f84:	fa ca ff f8 	sub	r10,sp,-8
80002f88:	14 d9       	st.w	--r10,r9
	xQueueSendFromISR(store, &ptr, &xHigherPriorityTaskWoken);
80002f8a:	1a 9b       	mov	r11,sp
80002f8c:	f0 1f 00 02 	mcall	80002f94 <set_idle_store_isr+0x18>
}
80002f90:	2f ed       	sub	sp,-8
80002f92:	d8 02       	popm	pc
80002f94:	80 00       	ld.sh	r0,r0[0x0]
80002f96:	5b 2c       	cp.w	r12,-14

80002f98 <phy_rx>:
	xQueueSendFromISR -- freertos
Called By: phy_xnl_rx
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
80002f98:	d4 01       	pushm	lr
80002f9a:	20 2d       	sub	sp,8
80002f9c:	50 0c       	stdsp	sp[0x0],r12
	//memcpy(xx, phy_ptr, sizeof(phy_fragment_t));
	//set_phy_idle_isr(&phy_ptr, &xHigherPriorityTaskWoken);
	
	Bool res = FALSE;
	
	if(NULL == phy_ptr)
80002f9e:	58 0c       	cp.w	r12,0
80002fa0:	c1 10       	breq	80002fc2 <phy_rx+0x2a>
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
    /*variables are used to store the push result in interrupt*/
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002fa2:	30 08       	mov	r8,0
80002fa4:	50 18       	stdsp	sp[0x4],r8
	if(NULL == phy_ptr)
	{
		return;
	}
	
    U16 phy_ctrl = phy_ptr->xnl_fragment.phy_header.phy_control;
80002fa6:	98 88       	ld.uh	r8,r12[0x0]
80002fa8:	e2 18 f0 00 	andl	r8,0xf000,COH
80002fac:	e0 48 40 00 	cp.w	r8,16384
80002fb0:	c0 91       	brne	80002fc2 <phy_rx+0x2a>

    if (XCMPXNL_DATA == (phy_ctrl & 0xF000))
    {
        /*push the xnl packet to queue*/
        if( pdTRUE == xQueueSendFromISR(
80002fb2:	48 68       	lddpc	r8,80002fc8 <phy_rx+0x30>
80002fb4:	70 0c       	ld.w	r12,r8[0x0]
80002fb6:	30 09       	mov	r9,0
80002fb8:	fa ca ff fc 	sub	r10,sp,-4
80002fbc:	1a 9b       	mov	r11,sp
80002fbe:	f0 1f 00 04 	mcall	80002fcc <phy_rx+0x34>
		}	

    }
		
 
}
80002fc2:	2f ed       	sub	sp,-8
80002fc4:	d8 02       	popm	pc
80002fc6:	00 00       	add	r0,r0
80002fc8:	00 00       	add	r0,r0
80002fca:	0a bc       	st.h	r5++,r12
80002fcc:	80 00       	ld.sh	r0,r0[0x0]
80002fce:	5b 2c       	cp.w	r12,-14

80002fd0 <set_idle_store>:
	}
}


void set_idle_store(xQueueHandle store, void * ptr)
{
80002fd0:	eb cd 40 80 	pushm	r7,lr
80002fd4:	20 1d       	sub	sp,4
80002fd6:	fa c7 ff fc 	sub	r7,sp,-4
80002fda:	0e db       	st.w	--r7,r11
	xQueueSend(store, &ptr, 0);
80002fdc:	30 09       	mov	r9,0
80002fde:	12 9a       	mov	r10,r9
80002fe0:	1a 9b       	mov	r11,sp
80002fe2:	f0 1f 00 03 	mcall	80002fec <set_idle_store+0x1c>
}
80002fe6:	2f fd       	sub	sp,-4
80002fe8:	e3 cd 80 80 	ldm	sp++,r7,pc
80002fec:	80 00       	ld.sh	r0,r0[0x0]
80002fee:	5b 7c       	cp.w	r12,-9

80002ff0 <phy_tx>:
Calls:   
	xQueueSend -- freertos
Called By: xnl_tx -- xnl.c
*/
void phy_tx(phy_fragment_t * phy)
{	
80002ff0:	d4 01       	pushm	lr
80002ff2:	20 1d       	sub	sp,4
80002ff4:	50 0c       	stdsp	sp[0x0],r12
	
	//phy_fragment_t * phy_ptr = malloc(sizeof(phy_fragment_t));
	//memcpy(phy_ptr, phy, sizeof(phy_fragment_t));
	//log("\n\r T_xcmp:%4x \n\r", phy->xnl_fragment.xnl_payload.xnl_content_data_msg.xcmp_opcode);
	//log("T_xnl-opcode:%4x", xnl->xnl_header.opcode);//log:R_xnl指令	
	if(XCMPXNL_DATA == (phy_ctrl & 0xF000))
80002ff6:	98 88       	ld.uh	r8,r12[0x0]
80002ff8:	e2 18 f0 00 	andl	r8,0xf000,COH
80002ffc:	e0 48 40 00 	cp.w	r8,16384
80003000:	c0 d1       	brne	8000301a <phy_tx+0x2a>
	{
		/*push the xnl packet to queue to send */
		if(NULL != phy_xnl_frame_tx)
80003002:	49 08       	lddpc	r8,80003040 <phy_tx+0x50>
80003004:	70 08       	ld.w	r8,r8[0x0]
80003006:	58 08       	cp.w	r8,0
80003008:	c1 a0       	breq	8000303c <phy_tx+0x4c>
		{
			if( pdTRUE == xQueueSend(phy_xnl_frame_tx, &phy, 0))
8000300a:	48 e8       	lddpc	r8,80003040 <phy_tx+0x50>
8000300c:	70 0c       	ld.w	r12,r8[0x0]
8000300e:	30 09       	mov	r9,0
80003010:	12 9a       	mov	r10,r9
80003012:	1a 9b       	mov	r11,sp
80003014:	f0 1f 00 0c 	mcall	80003044 <phy_tx+0x54>
80003018:	c1 28       	rjmp	8000303c <phy_tx+0x4c>
		}
	}
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE		
	else if((SPEAKER_DATA == (phy_ctrl & 0xF000))
8000301a:	e0 48 10 00 	cp.w	r8,4096
8000301e:	5f 0a       	sreq	r10
80003020:	e0 48 20 00 	cp.w	r8,8192
80003024:	5f 09       	sreq	r9
80003026:	f5 e9 10 09 	or	r9,r10,r9
8000302a:	c0 71       	brne	80003038 <phy_tx+0x48>
8000302c:	e0 48 50 00 	cp.w	r8,20480
80003030:	c0 40       	breq	80003038 <phy_tx+0x48>
80003032:	e0 48 60 00 	cp.w	r8,24576
80003036:	c0 31       	brne	8000303c <phy_tx+0x4c>
	    || (MIC_DATA  == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_RX == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_TX == (phy_ctrl & 0xF000))
	)
	{		
		if(NULL == phy_payload_frame_tx)
80003038:	48 48       	lddpc	r8,80003048 <phy_tx+0x58>
8000303a:	70 08       	ld.w	r8,r8[0x0]
	
	if(res != TRUE)
	{
		//vPortFree(phy_ptr);
	}
}
8000303c:	2f fd       	sub	sp,-4
8000303e:	d8 02       	popm	pc
80003040:	00 00       	add	r0,r0
80003042:	0a c8       	st.b	r5++,r8
80003044:	80 00       	ld.sh	r0,r0[0x0]
80003046:	5b 7c       	cp.w	r12,-9
80003048:	00 00       	add	r0,r0
8000304a:	0a b0       	st.h	r5++,r0

8000304c <get_idle_store_isr>:
		return NULL;
	}
}

void * get_idle_store_isr(xQueueHandle store)
{
8000304c:	d4 01       	pushm	lr
8000304e:	20 2d       	sub	sp,8
	void * ptr = NULL;
80003050:	30 08       	mov	r8,0
80003052:	50 18       	stdsp	sp[0x4],r8
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80003054:	50 08       	stdsp	sp[0x0],r8
	
	if(pdTRUE == xQueueReceiveFromISR(store, &ptr, &xHigherPriorityTaskWoken))
80003056:	1a 9a       	mov	r10,sp
80003058:	fa cb ff fc 	sub	r11,sp,-4
8000305c:	f0 1f 00 05 	mcall	80003070 <get_idle_store_isr+0x24>
80003060:	58 1c       	cp.w	r12,1
80003062:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80003066:	fb fc 00 01 	ld.weq	r12,sp[0x4]
	}
	else
	{
		return NULL;
	}
}
8000306a:	2f ed       	sub	sp,-8
8000306c:	d8 02       	popm	pc
8000306e:	00 00       	add	r0,r0
80003070:	80 00       	ld.sh	r0,r0[0x0]
80003072:	58 80       	cp.w	r0,8

80003074 <phy_tx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_tx_func( void * ssc)
{
80003074:	eb cd 40 c0 	pushm	r6-r7,lr
80003078:	20 1d       	sub	sp,4
8000307a:	18 97       	mov	r7,r12
    if(NULL != phy_xnl_frame_tx)
8000307c:	4b a8       	lddpc	r8,80003164 <phy_tx_func+0xf0>
8000307e:	70 08       	ld.w	r8,r8[0x0]
80003080:	58 08       	cp.w	r8,0
80003082:	c6 60       	breq	8000314e <phy_tx_func+0xda>
    {
  	  	/*send ssc data in xnl frame*/
  	  	phy_xnl_tx(&(((ssc_fragment_t * )ssc)->xnl_channel));		
80003084:	18 96       	mov	r6,r12
Called By:phy_tx_func
*/
static void phy_xnl_tx(xnl_channel_t * xnl_tx_channel)
{
	/*variables are used to store the push result in interrupt*/
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80003086:	30 08       	mov	r8,0
80003088:	50 08       	stdsp	sp[0x0],r8
	
	static S16 phy_tx_expexted_length = 0;
	static U8 phy_tx_index = 0;
	
	/*his is the code for handling any outgoing XNL Phy message*/
	switch(phy_tx_state)
8000308a:	4b 88       	lddpc	r8,80003168 <phy_tx_func+0xf4>
8000308c:	70 08       	ld.w	r8,r8[0x0]
8000308e:	58 18       	cp.w	r8,1
80003090:	c2 60       	breq	800030dc <phy_tx_func+0x68>
80003092:	c0 43       	brcs	8000309a <phy_tx_func+0x26>
80003094:	58 28       	cp.w	r8,2
80003096:	c5 c1       	brne	8000314e <phy_tx_func+0xda>
80003098:	c5 58       	rjmp	80003142 <phy_tx_func+0xce>
	{
		/*Waiting for the send xnl packet*/
		case WAITING_FOR_PHY_TX:			
			if( pdTRUE == xQueueReceiveFromISR(
8000309a:	4b 38       	lddpc	r8,80003164 <phy_tx_func+0xf0>
8000309c:	70 0c       	ld.w	r12,r8[0x0]
8000309e:	1a 9a       	mov	r10,sp
800030a0:	4b 3b       	lddpc	r11,8000316c <phy_tx_func+0xf8>
800030a2:	f0 1f 00 34 	mcall	80003170 <phy_tx_func+0xfc>
800030a6:	58 1c       	cp.w	r12,1
800030a8:	c1 41       	brne	800030d0 <phy_tx_func+0x5c>
				  phy_xnl_frame_tx
				, &phy_ptr
				, &xHigherPriorityTaskWoken 
			))
			{								
				phy_tx_expexted_length = 
800030aa:	4b 18       	lddpc	r8,8000316c <phy_tx_func+0xf8>
800030ac:	70 08       	ld.w	r8,r8[0x0]
800030ae:	90 08       	ld.sh	r8,r8[0x0]
800030b0:	10 9a       	mov	r10,r8
800030b2:	f5 da c0 08 	bfextu	r10,r10,0x0,0x8
800030b6:	4b 09       	lddpc	r9,80003174 <phy_tx_func+0x100>
800030b8:	b2 0a       	st.h	r9[0x0],r10
				*/
				xnl_tx_channel->dword = 
				                   phy_ptr->xnl_fragment.phy_header.phy_control;
				
				/*Transmit 0xABCD0000 | Type/Length.*/
				xnl_tx_channel->dword |= PHYHEADER32;
800030ba:	5c 78       	castu.h	r8
800030bc:	ea 18 ab cd 	orh	r8,0xabcd
800030c0:	8f 18       	st.w	r7[0x4],r8
				
				phy_tx_index = 1;
800030c2:	30 19       	mov	r9,1
800030c4:	4a d8       	lddpc	r8,80003178 <phy_tx_func+0x104>
800030c6:	b0 89       	st.b	r8[0x0],r9
				phy_tx_state = WRITE_NEXT_DWORD;	
800030c8:	30 19       	mov	r9,1
800030ca:	4a 88       	lddpc	r8,80003168 <phy_tx_func+0xf4>
800030cc:	91 09       	st.w	r8[0x0],r9
800030ce:	c4 08       	rjmp	8000314e <phy_tx_func+0xda>
				/*The new transmission has started.*/
			}
			else
			{
				/*Nothing new to transmit, send an idle frame*/
				xnl_tx_channel->dword = XNL_IDLE;
800030d0:	e0 68 5a 5a 	mov	r8,23130
800030d4:	ea 18 ab cd 	orh	r8,0xabcd
800030d8:	8f 18       	st.w	r7[0x4],r8
800030da:	c3 a8       	rjmp	8000314e <phy_tx_func+0xda>
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
800030dc:	4a 7a       	lddpc	r10,80003178 <phy_tx_func+0x104>
800030de:	15 88       	ld.ub	r8,r10[0x0]
				xnl_tx_channel->dword = XNL_IDLE;
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
800030e0:	4a 39       	lddpc	r9,8000316c <phy_tx_func+0xf8>
800030e2:	72 09       	ld.w	r9,r9[0x0]
800030e4:	f2 08 05 19 	ld.uh	r9,r9[r8<<0x1]
800030e8:	b1 69       	lsl	r9,0x10
800030ea:	99 19       	st.w	r12[0x4],r9
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
800030ec:	2f f8       	sub	r8,-1
800030ee:	5c 58       	castu.b	r8
800030f0:	b4 88       	st.b	r10[0x0],r8

			phy_tx_expexted_length -= 2;
800030f2:	4a 1b       	lddpc	r11,80003174 <phy_tx_func+0x100>
800030f4:	96 0c       	ld.sh	r12,r11[0x0]
800030f6:	20 2c       	sub	r12,2
800030f8:	5c 8c       	casts.h	r12
800030fa:	f5 dc b0 10 	bfexts	r10,r12,0x0,0x10
800030fe:	b6 0a       	st.h	r11[0x0],r10
			
			/*have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80003100:	30 0b       	mov	r11,0
80003102:	f6 0a 19 00 	cp.h	r10,r11
80003106:	e0 89 00 09 	brgt	80003118 <phy_tx_func+0xa4>
			{
				/*Must immediately send 0x00BA in Slot 4.*/
				xnl_tx_channel->dword |= PHYTERMRIGHT;
8000310a:	e8 19 00 ba 	orl	r9,0xba
8000310e:	8f 19       	st.w	r7[0x4],r9
				
				/*Go back to waiting.*/
				phy_tx_state = WAITING_FOR_PHY_TX;
80003110:	30 09       	mov	r9,0
80003112:	49 68       	lddpc	r8,80003168 <phy_tx_func+0xf4>
80003114:	91 09       	st.w	r8[0x0],r9
80003116:	c1 c8       	rjmp	8000314e <phy_tx_func+0xda>
				break;
			}

			/*Have not broken. Transmit 2nd hWord.*/
			xnl_tx_channel->dword |=  phy_ptr->fragment_element[phy_tx_index++];
80003118:	49 5a       	lddpc	r10,8000316c <phy_tx_func+0xf8>
8000311a:	74 0a       	ld.w	r10,r10[0x0]
8000311c:	f4 08 05 1a 	ld.uh	r10,r10[r8<<0x1]
80003120:	14 49       	or	r9,r10
80003122:	8f 19       	st.w	r7[0x4],r9
80003124:	2f f8       	sub	r8,-1
80003126:	49 59       	lddpc	r9,80003178 <phy_tx_func+0x104>
80003128:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
8000312a:	20 2c       	sub	r12,2
8000312c:	49 28       	lddpc	r8,80003174 <phy_tx_func+0x100>
8000312e:	b0 0c       	st.h	r8[0x0],r12
			
			/*Have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80003130:	30 08       	mov	r8,0
80003132:	f0 0c 19 00 	cp.h	r12,r8
80003136:	e0 89 00 0c 	brgt	8000314e <phy_tx_func+0xda>
			{
				/*Must send 0x00BA0000 next interrupt in Slot 3&4*/
				phy_tx_state = SEND_TAILED;
8000313a:	30 29       	mov	r9,2
8000313c:	48 b8       	lddpc	r8,80003168 <phy_tx_func+0xf4>
8000313e:	91 09       	st.w	r8[0x0],r9
80003140:	c0 78       	rjmp	8000314e <phy_tx_func+0xda>
			}
			break;

		case SEND_TAILED:
			/*send 0x00BA0000*/
			xnl_tx_channel->dword = PHYTERMLEFT;
80003142:	fc 18 00 ba 	movh	r8,0xba
80003146:	99 18       	st.w	r12[0x4],r8
			
			/*Go back to waiting.*/		
			phy_tx_state = WAITING_FOR_PHY_TX;		
80003148:	30 09       	mov	r9,0
8000314a:	48 88       	lddpc	r8,80003168 <phy_tx_func+0xf4>
8000314c:	91 09       	st.w	r8[0x0],r9
	//#else
	///*send idle frame*/	
	//((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
	//((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
	//#endif /*end if*/
	((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
8000314e:	e0 68 5a 5a 	mov	r8,23130
80003152:	ea 18 ab cd 	orh	r8,0xabcd
80003156:	8f 28       	st.w	r7[0x8],r8
	((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
80003158:	30 08       	mov	r8,0
8000315a:	8f 38       	st.w	r7[0xc],r8
}
8000315c:	2f fd       	sub	sp,-4
8000315e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80003162:	00 00       	add	r0,r0
80003164:	00 00       	add	r0,r0
80003166:	0a c8       	st.b	r5++,r8
80003168:	00 00       	add	r0,r0
8000316a:	0a 84       	andn	r4,r5
8000316c:	00 00       	add	r0,r0
8000316e:	0a d0       	st.w	--r5,r0
80003170:	80 00       	ld.sh	r0,r0[0x0]
80003172:	58 80       	cp.w	r0,8
80003174:	00 00       	add	r0,r0
80003176:	0a ac       	st.w	r5++,r12
80003178:	00 00       	add	r0,r0
8000317a:	0a 68       	and	r8,r5

8000317c <get_idle_store>:
	}//End of RxMedia Phy Handler.
}
#endif /*end if*/

void * get_idle_store(xQueueHandle store)
{
8000317c:	d4 01       	pushm	lr
8000317e:	20 1d       	sub	sp,4
	void * ptr = NULL;
80003180:	30 0a       	mov	r10,0
80003182:	fa cb ff fc 	sub	r11,sp,-4
80003186:	16 da       	st.w	--r11,r10

	if(pdTRUE == xQueueReceive(store, &ptr, 0))
80003188:	14 99       	mov	r9,r10
8000318a:	1a 9b       	mov	r11,sp
8000318c:	f0 1f 00 05 	mcall	800031a0 <get_idle_store+0x24>
80003190:	58 1c       	cp.w	r12,1
80003192:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80003196:	fb fc 00 00 	ld.weq	r12,sp[0x0]
	}
	else
	{
		return NULL;
	}
}
8000319a:	2f fd       	sub	sp,-4
8000319c:	d8 02       	popm	pc
8000319e:	00 00       	add	r0,r0
800031a0:	80 00       	ld.sh	r0,r0[0x0]
800031a2:	59 70       	cp.w	r0,23

800031a4 <phy_init>:
    register_rx_tx_func -- ssc.c
	xQueueCreate -- freertos
Called By: xnl_init -- xnl.c
*/
void phy_init( void )
{
800031a4:	d4 01       	pushm	lr
    /*register the func to send/receive ssc packet*/
    register_rx_tx_func(phy_rx_func, phy_tx_func);	
800031a6:	48 5b       	lddpc	r11,800031b8 <phy_init+0x14>
800031a8:	48 5c       	lddpc	r12,800031bc <phy_init+0x18>
800031aa:	f0 1f 00 06 	mcall	800031c0 <phy_init+0x1c>
	
	/*initialize the SSC*/
	ssc_init();
800031ae:	f0 1f 00 06 	mcall	800031c4 <phy_init+0x20>
	
	/*send device_master_query to connect radio*/
	xnl_send_device_master_query();
800031b2:	f0 1f 00 06 	mcall	800031c8 <phy_init+0x24>
	
}
800031b6:	d8 02       	popm	pc
800031b8:	80 00       	ld.sh	r0,r0[0x0]
800031ba:	30 74       	mov	r4,7
800031bc:	80 00       	ld.sh	r0,r0[0x0]
800031be:	32 2c       	mov	r12,34
800031c0:	80 00       	ld.sh	r0,r0[0x0]
800031c2:	42 74       	lddsp	r4,sp[0x9c]
800031c4:	80 00       	ld.sh	r0,r0[0x0]
800031c6:	42 88       	lddsp	r8,sp[0xa0]
800031c8:	80 00       	ld.sh	r0,r0[0x0]
800031ca:	4b a4       	lddpc	r4,800032b0 <phy_rx_func+0x84>

800031cc <payload_rx>:
		//logFromISR("ss");
	}
}

static void payload_rx(void * payload)
{
800031cc:	d4 01       	pushm	lr
800031ce:	20 2d       	sub	sp,8
800031d0:	50 0c       	stdsp	sp[0x0],r12
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
800031d2:	30 08       	mov	r8,0
800031d4:	50 18       	stdsp	sp[0x4],r8
	
	if(NULL == phy_payload_frame_rx)
800031d6:	48 f8       	lddpc	r8,80003210 <payload_rx+0x44>
800031d8:	70 08       	ld.w	r8,r8[0x0]
800031da:	58 08       	cp.w	r8,0
800031dc:	c0 71       	brne	800031ea <payload_rx+0x1e>
	{
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));		
800031de:	30 4b       	mov	r11,4
800031e0:	30 5c       	mov	r12,5
800031e2:	f0 1f 00 0d 	mcall	80003214 <payload_rx+0x48>
800031e6:	48 b8       	lddpc	r8,80003210 <payload_rx+0x44>
800031e8:	91 0c       	st.w	r8[0x0],r12
	}

	if(errQUEUE_FULL == xQueueSendFromISR(phy_payload_frame_rx, &payload, &xHigherPriorityTaskWoken))
800031ea:	48 a8       	lddpc	r8,80003210 <payload_rx+0x44>
800031ec:	70 0c       	ld.w	r12,r8[0x0]
800031ee:	30 09       	mov	r9,0
800031f0:	fa ca ff fc 	sub	r10,sp,-4
800031f4:	1a 9b       	mov	r11,sp
800031f6:	f0 1f 00 09 	mcall	80003218 <payload_rx+0x4c>
800031fa:	c0 91       	brne	8000320c <payload_rx+0x40>
	{
		
		set_payload_idle_isr(payload);
800031fc:	48 88       	lddpc	r8,8000321c <payload_rx+0x50>
800031fe:	70 0c       	ld.w	r12,r8[0x0]
80003200:	40 0b       	lddsp	r11,sp[0x0]
80003202:	f0 1f 00 08 	mcall	80003220 <payload_rx+0x54>
		logFromISR("mm");
80003206:	48 8c       	lddpc	r12,80003224 <payload_rx+0x58>
80003208:	f0 1f 00 08 	mcall	80003228 <payload_rx+0x5c>
	}
	else
	{
		//logFromISR("ss");
	}
}
8000320c:	2f ed       	sub	sp,-8
8000320e:	d8 02       	popm	pc
80003210:	00 00       	add	r0,r0
80003212:	0a 90       	mov	r0,r5
80003214:	80 00       	ld.sh	r0,r0[0x0]
80003216:	5c 7c       	castu.h	r12
80003218:	80 00       	ld.sh	r0,r0[0x0]
8000321a:	5b 2c       	cp.w	r12,-14
8000321c:	00 00       	add	r0,r0
8000321e:	0a 74       	tst	r4,r5
80003220:	80 00       	ld.sh	r0,r0[0x0]
80003222:	2f 7c       	sub	r12,-9
80003224:	80 00       	ld.sh	r0,r0[0x0]
80003226:	cf 38       	rjmp	8000340c <phy_rx_func+0x1e0>
80003228:	80 00       	ld.sh	r0,r0[0x0]
8000322a:	68 a0       	ld.w	r0,r4[0x28]

8000322c <phy_rx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_rx_func( void * ssc)
{    
8000322c:	eb cd 40 e0 	pushm	r5-r7,lr
80003230:	18 97       	mov	r7,r12
		
	if(NULL != phy_xnl_frame_rx)
80003232:	fe f8 0e 7a 	ld.w	r8,pc[3706]
80003236:	70 08       	ld.w	r8,r8[0x0]
80003238:	58 08       	cp.w	r8,0
8000323a:	e0 80 01 08 	breq	8000344a <phy_rx_func+0x21e>
	static U16 phy_check_sum = 0;

	static phy_rx_state_t  phy_rx_state = WAITING_FOR_HEADER;
	static U32 phy_rx_count = 0;

	U32 phy_dword = xnl_rx_channel->dword;	
8000323e:	78 16       	ld.w	r6,r12[0x4]

	phy_rx_count++;
80003240:	fe f8 0e 70 	ld.w	r8,pc[3696]
80003244:	70 09       	ld.w	r9,r8[0x0]
80003246:	2f f9       	sub	r9,-1
80003248:	91 09       	st.w	r8[0x0],r9
	
	/*This is the code for parsing the incoming physical message.*/
	switch (phy_rx_state)
8000324a:	fe f8 0e 6a 	ld.w	r8,pc[3690]
8000324e:	70 08       	ld.w	r8,r8[0x0]
80003250:	58 18       	cp.w	r8,1
80003252:	e0 80 00 85 	breq	8000335c <phy_rx_func+0x130>
80003256:	c0 73       	brcs	80003264 <phy_rx_func+0x38>
80003258:	58 28       	cp.w	r8,2
8000325a:	c5 c0       	breq	80003312 <phy_rx_func+0xe6>
8000325c:	58 38       	cp.w	r8,3
8000325e:	e0 81 00 f6 	brne	8000344a <phy_rx_func+0x21e>
80003262:	cd 58       	rjmp	8000340c <phy_rx_func+0x1e0>

        /*Waiting for something. Most frequent visit.*/		
		case WAITING_FOR_HEADER:
		
			/*Ignore Idles.*/
			if (0xABCD5A5A == phy_dword)
80003264:	e0 6a 5a 5a 	mov	r10,23130
80003268:	ea 1a ab cd 	orh	r10,0xabcd
8000326c:	14 36       	cp.w	r6,r10
8000326e:	e0 80 00 ee 	breq	8000344a <phy_rx_func+0x21e>
			{
				break;
			}	

			/*Skip until Header.*/		
			if (0xABCD != (phy_dword >> 16))
80003272:	ec 08 16 10 	lsr	r8,r6,0x10
80003276:	e0 48 ab cd 	cp.w	r8,43981
8000327a:	e0 81 00 e8 	brne	8000344a <phy_rx_func+0x21e>
			{			
				break;
			}
		
			/*Length excluding CSUM.*/
			phy_rx_expexted_length = (phy_dword & 0x000000FF) - 2;
8000327e:	eb d6 b0 10 	bfexts	r5,r6,0x0,0x10
80003282:	f1 d5 c0 08 	bfextu	r8,r5,0x0,0x8
80003286:	20 28       	sub	r8,2
80003288:	fe f9 0e 30 	ld.w	r9,pc[3632]
8000328c:	b2 08       	st.h	r9[0x0],r8
			
			/*Discard degenerate message.*/
			if (phy_rx_expexted_length <= 0)
8000328e:	30 09       	mov	r9,0
80003290:	f2 08 19 00 	cp.h	r8,r9
80003294:	e0 8a 00 db 	brle	8000344a <phy_rx_func+0x21e>
			{
				break;
			}
		
			phy_rx_length = 0;
80003298:	fe f8 0e 24 	ld.w	r8,pc[3620]
8000329c:	b0 09       	st.h	r8[0x0],r9

			phy_frame_ptr = get_xnl_idle_isr();
8000329e:	fe f8 0e 22 	ld.w	r8,pc[3618]
800032a2:	70 0c       	ld.w	r12,r8[0x0]
800032a4:	f0 1f 03 88 	mcall	800040c4 <phy_rx_func+0xe98>
800032a8:	fe f8 0e 20 	ld.w	r8,pc[3616]
800032ac:	91 0c       	st.w	r8[0x0],r12
			if(NULL == phy_frame_ptr)
800032ae:	58 0c       	cp.w	r12,0
800032b0:	e0 80 00 cd 	breq	8000344a <phy_rx_func+0x21e>
			{
				break;
			}
					
			phy_frame_ptr->fragment_element[phy_rx_length++] = phy_dword;
800032b4:	fe f8 0e 08 	ld.w	r8,pc[3592]
800032b8:	90 09       	ld.sh	r9,r8[0x0]
800032ba:	f8 09 0a 15 	st.h	r12[r9<<0x1],r5
800032be:	2f f9       	sub	r9,-1
800032c0:	5c 89       	casts.h	r9
			
			/*time stamp*/
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
800032c2:	fe fa 0e 06 	ld.w	r10,pc[3590]
800032c6:	74 0a       	ld.w	r10,r10[0x0]
800032c8:	fe fb 0d e8 	ld.w	r11,pc[3560]
800032cc:	76 0b       	ld.w	r11,r11[0x0]
800032ce:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
800032d2:	2f f9       	sub	r9,-1
800032d4:	b0 09       	st.h	r8[0x0],r9
													(phy_rx_count) & 0x0000FFFF;
			
			/*This switch tests the fragment type, and adjusts receiver state
			accordingly.*/
			/*Check frag type*/
			switch (phy_dword & 0x00000F00)
800032d6:	e2 16 0f 00 	andl	r6,0xf00,COH
800032da:	e0 46 01 00 	cp.w	r6,256
800032de:	c0 c0       	breq	800032f6 <phy_rx_func+0xca>
800032e0:	e0 8b 00 05 	brhi	800032ea <phy_rx_func+0xbe>
800032e4:	58 06       	cp.w	r6,0
800032e6:	c0 80       	breq	800032f6 <phy_rx_func+0xca>
800032e8:	c0 c8       	rjmp	80003300 <phy_rx_func+0xd4>
800032ea:	e0 46 02 00 	cp.w	r6,512
800032ee:	c0 40       	breq	800032f6 <phy_rx_func+0xca>
800032f0:	e0 46 03 00 	cp.w	r6,768
800032f4:	c0 61       	brne	80003300 <phy_rx_func+0xd4>
			{
				case SINGLE_FRAGMENT:  //Only Fragment.
				case FIRST_FRAGMENT:   //First of Multi-fragment.
				case MIDDLE_FRAGMENT:  //Continuing Multi-fragment.
				case LAST_FRAGMENT:    //Last Multi-fragment.
					phy_rx_state = WAITING_CHECK_SUM;
800032f6:	30 29       	mov	r9,2
800032f8:	fe f8 0d bc 	ld.w	r8,pc[3516]
800032fc:	91 09       	st.w	r8[0x0],r9
800032fe:	ca 68       	rjmp	8000344a <phy_rx_func+0x21e>
				break;
				default:
					set_xnl_idle_isr(phy_frame_ptr);			
80003300:	fe f8 0d c0 	ld.w	r8,pc[3520]
80003304:	70 0c       	ld.w	r12,r8[0x0]
80003306:	fe f8 0d c2 	ld.w	r8,pc[3522]
8000330a:	70 0b       	ld.w	r11,r8[0x0]
8000330c:	f0 1f 03 70 	mcall	800040cc <phy_rx_func+0xea0>
80003310:	c9 d8       	rjmp	8000344a <phy_rx_func+0x21e>
		
			/*Stores CSUM*/
			phy_check_sum  = (phy_dword & 0xFFFF0000) >> 16;
			
			/*sums in first hWord*/
			phy_check_sum += (phy_dword & 0x0000FFFF);		
80003312:	f5 d6 b0 10 	bfexts	r10,r6,0x0,0x10
80003316:	b1 86       	lsr	r6,0x10
80003318:	14 06       	add	r6,r10
8000331a:	fe f8 0d b6 	ld.w	r8,pc[3510]
8000331e:	b0 06       	st.h	r8[0x0],r6
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
80003320:	fe f8 0d 9c 	ld.w	r8,pc[3484]
80003324:	90 09       	ld.sh	r9,r8[0x0]
80003326:	fe fb 0d a2 	ld.w	r11,pc[3490]
8000332a:	76 0b       	ld.w	r11,r11[0x0]
8000332c:	f6 09 0a 1a 	st.h	r11[r9<<0x1],r10
80003330:	2f f9       	sub	r9,-1
80003332:	b0 09       	st.h	r8[0x0],r9
														 phy_dword & 0x0000FFFF;
					
			phy_rx_expexted_length -= 2;
80003334:	fe f9 0d 84 	ld.w	r9,pc[3460]
80003338:	92 08       	ld.sh	r8,r9[0x0]
8000333a:	20 28       	sub	r8,2
8000333c:	b2 08       	st.h	r9[0x0],r8
			
			/*Normal case for greater than one byte payloads.*/
			if (phy_rx_expexted_length > 0)
8000333e:	30 09       	mov	r9,0
80003340:	f2 08 19 00 	cp.h	r8,r9
80003344:	e0 8a 00 07 	brle	80003352 <phy_rx_func+0x126>
			{					  
				phy_rx_state = READING_FRAGMENT;
80003348:	30 19       	mov	r9,1
8000334a:	fe f8 0d 6a 	ld.w	r8,pc[3434]
8000334e:	91 09       	st.w	r8[0x0],r9
80003350:	c7 d8       	rjmp	8000344a <phy_rx_func+0x21e>
	    		Note that all segments must align with a 32-bit boundary and
				beginning of each XCMP/XNL payload frame must start on slot 3
				Thus, segments of odd length must append a 0x0000 at the end
				(slot 4) to ensure alignment. [9.1.3]
				*/
				phy_rx_state = WAITING_LAST_TERM;
80003352:	30 39       	mov	r9,3
80003354:	fe f8 0d 60 	ld.w	r8,pc[3424]
80003358:	91 09       	st.w	r8[0x0],r9
8000335a:	c7 88       	rjmp	8000344a <phy_rx_func+0x21e>
			}			
		
			break;

		case READING_FRAGMENT:
			phy_check_sum += (phy_dword & 0xFFFF0000) >> 16;
8000335c:	ec 0a 14 10 	asr	r10,r6,0x10
80003360:	fe f8 0d 70 	ld.w	r8,pc[3440]
80003364:	90 09       	ld.sh	r9,r8[0x0]
80003366:	14 09       	add	r9,r10
80003368:	b0 09       	st.h	r8[0x0],r9
	
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
8000336a:	fe f9 0d 52 	ld.w	r9,pc[3410]
8000336e:	92 08       	ld.sh	r8,r9[0x0]
80003370:	fe fb 0d 58 	ld.w	r11,pc[3416]
80003374:	76 0b       	ld.w	r11,r11[0x0]
80003376:	f6 08 0a 1a 	st.h	r11[r8<<0x1],r10
8000337a:	2f f8       	sub	r8,-1
8000337c:	5c 88       	casts.h	r8
8000337e:	b2 08       	st.h	r9[0x0],r8
												 (phy_dword & 0xFFFF0000) >> 16;
	
			phy_rx_expexted_length -= 2;
80003380:	fe fa 0d 38 	ld.w	r10,pc[3384]
80003384:	94 09       	ld.sh	r9,r10[0x0]
80003386:	20 29       	sub	r9,2
80003388:	b4 09       	st.h	r10[0x0],r9
			if (phy_rx_expexted_length <= 0)
8000338a:	30 0a       	mov	r10,0
8000338c:	f4 09 19 00 	cp.h	r9,r10
80003390:	e0 89 00 20 	brgt	800033d0 <phy_rx_func+0x1a4>
				Terminator should be in 2nd hWord.
				Shaoqun says useful bits not used. The packet will always end
				with $00BA. [9.1.2.8]	
				*/
				
				if ((0x000000BA == (phy_dword  & 0x0000FFFF)) 
80003394:	ed d6 c0 10 	bfextu	r6,r6,0x0,0x10
80003398:	e0 46 00 ba 	cp.w	r6,186
8000339c:	c0 d1       	brne	800033b6 <phy_rx_func+0x18a>
8000339e:	fe f8 0d 32 	ld.w	r8,pc[3378]
800033a2:	90 09       	ld.sh	r9,r8[0x0]
800033a4:	f4 09 19 00 	cp.h	r9,r10
800033a8:	c0 71       	brne	800033b6 <phy_rx_func+0x18a>
					&& (phy_check_sum == 0))
				{
					phy_rx(phy_frame_ptr);
800033aa:	fe f8 0d 1e 	ld.w	r8,pc[3358]
800033ae:	70 0c       	ld.w	r12,r8[0x0]
800033b0:	f0 1f 03 49 	mcall	800040d4 <phy_rx_func+0xea8>
800033b4:	c0 98       	rjmp	800033c6 <phy_rx_func+0x19a>
				}
				else
				{
					set_xnl_idle_isr(phy_frame_ptr);
800033b6:	fe f8 0d 0a 	ld.w	r8,pc[3338]
800033ba:	70 0c       	ld.w	r12,r8[0x0]
800033bc:	fe f8 0d 0c 	ld.w	r8,pc[3340]
800033c0:	70 0b       	ld.w	r11,r8[0x0]
800033c2:	f0 1f 03 43 	mcall	800040cc <phy_rx_func+0xea0>
				}

				phy_rx_state = WAITING_FOR_HEADER;
800033c6:	30 09       	mov	r9,0
800033c8:	fe f8 0c ec 	ld.w	r8,pc[3308]
800033cc:	91 09       	st.w	r8[0x0],r9
800033ce:	c3 e8       	rjmp	8000344a <phy_rx_func+0x21e>
				break;
			}
		
			/*Have not broken. 2nd hWord contains payload.*/
			phy_check_sum += (phy_dword & 0x0000FFFF);
800033d0:	5c 86       	casts.h	r6
800033d2:	fe f9 0c fe 	ld.w	r9,pc[3326]
800033d6:	92 0a       	ld.sh	r10,r9[0x0]
800033d8:	0c 0a       	add	r10,r6
800033da:	b2 0a       	st.h	r9[0x0],r10
		
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
800033dc:	fe f9 0c ec 	ld.w	r9,pc[3308]
800033e0:	72 09       	ld.w	r9,r9[0x0]
800033e2:	f2 08 0a 16 	st.h	r9[r8<<0x1],r6
800033e6:	2f f8       	sub	r8,-1
800033e8:	fe f9 0c d4 	ld.w	r9,pc[3284]
800033ec:	b2 08       	st.h	r9[0x0],r8
													   (phy_dword & 0x0000FFFF);
		
			phy_rx_expexted_length -= 2;
800033ee:	fe f9 0c ca 	ld.w	r9,pc[3274]
800033f2:	92 08       	ld.sh	r8,r9[0x0]
800033f4:	20 28       	sub	r8,2
800033f6:	b2 08       	st.h	r9[0x0],r8
			if (phy_rx_expexted_length <= 0)
800033f8:	30 09       	mov	r9,0
800033fa:	f2 08 19 00 	cp.h	r8,r9
800033fe:	e0 89 00 26 	brgt	8000344a <phy_rx_func+0x21e>
			{
				/*All read in. Next Word should be 0x00BA0000.*/
				phy_rx_state = WAITING_LAST_TERM;
80003402:	30 39       	mov	r9,3
80003404:	fe f8 0c b0 	ld.w	r8,pc[3248]
80003408:	91 09       	st.w	r8[0x0],r9
8000340a:	c2 08       	rjmp	8000344a <phy_rx_func+0x21e>
			}/*else, next Word contains more payload.*/
			break;

		/*Expecting last terminator 0x00BA0000.*/	
		case WAITING_LAST_TERM:			
			if ((0x00BA0000 == (phy_dword  & 0x00FF0000)) /*Expected found.*/
8000340c:	e6 16 00 ff 	andh	r6,0xff,COH
80003410:	fc 19 00 ba 	movh	r9,0xba
80003414:	12 36       	cp.w	r6,r9
80003416:	c0 e1       	brne	80003432 <phy_rx_func+0x206>
80003418:	fe f8 0c b8 	ld.w	r8,pc[3256]
8000341c:	90 09       	ld.sh	r9,r8[0x0]
8000341e:	30 08       	mov	r8,0
80003420:	f0 09 19 00 	cp.h	r9,r8
80003424:	c0 71       	brne	80003432 <phy_rx_func+0x206>
				&& (phy_check_sum == 0))/*Good checksum*/
			{
				phy_rx(phy_frame_ptr);
80003426:	fe f8 0c a2 	ld.w	r8,pc[3234]
8000342a:	70 0c       	ld.w	r12,r8[0x0]
8000342c:	f0 1f 03 2a 	mcall	800040d4 <phy_rx_func+0xea8>
80003430:	c0 98       	rjmp	80003442 <phy_rx_func+0x216>

			}
			else
			{
				set_xnl_idle_isr(phy_frame_ptr);
80003432:	fe f8 0c 8e 	ld.w	r8,pc[3214]
80003436:	70 0c       	ld.w	r12,r8[0x0]
80003438:	fe f8 0c 90 	ld.w	r8,pc[3216]
8000343c:	70 0b       	ld.w	r11,r8[0x0]
8000343e:	f0 1f 03 24 	mcall	800040cc <phy_rx_func+0xea0>
			}
				
			phy_rx_state = WAITING_FOR_HEADER;
80003442:	30 09       	mov	r9,0
80003444:	fe f8 0c 70 	ld.w	r8,pc[3184]
80003448:	91 09       	st.w	r8[0x0],r9
	static U8 _flag = 1;//0xABCDC014时，_flag为0；
						//0xABCDC010时，_flag为1；
			
	//payload_ptr_t *AMBE_payload_ptr;		
	
	if(is_first == FALSE)
8000344a:	fe f8 0c 8e 	ld.w	r8,pc[3214]
8000344e:	11 89       	ld.ub	r9,r8[0x0]
80003450:	30 08       	mov	r8,0
80003452:	f0 09 18 00 	cp.b	r9,r8
80003456:	c1 31       	brne	8000347c <phy_rx_func+0x250>
	{
		payload_ptr = get_payload_idle_isr();
80003458:	fe f6 0c 84 	ld.w	r6,pc[3204]
8000345c:	6c 0c       	ld.w	r12,r6[0x0]
8000345e:	f0 1f 03 1a 	mcall	800040c4 <phy_rx_func+0xe98>
80003462:	fe f8 0c 7e 	ld.w	r8,pc[3198]
80003466:	91 0c       	st.w	r8[0x0],r12
		AMBE_payload_ptr = get_payload_idle_isr();
80003468:	6c 0c       	ld.w	r12,r6[0x0]
8000346a:	f0 1f 03 17 	mcall	800040c4 <phy_rx_func+0xe98>
8000346e:	fe f8 0c 76 	ld.w	r8,pc[3190]
80003472:	91 0c       	st.w	r8[0x0],r12
		is_first = TRUE;
80003474:	30 19       	mov	r9,1
80003476:	fe f8 0c 62 	ld.w	r8,pc[3170]
8000347a:	b0 89       	st.b	r8[0x0],r9
	}	
	
	//This is the RxMedia Phy Handler.
	switch (RxMediaState)
8000347c:	fe f8 0c 6c 	ld.w	r8,pc[3180]
80003480:	70 08       	ld.w	r8,r8[0x0]
80003482:	58 28       	cp.w	r8,2
80003484:	e0 80 01 98 	breq	800037b4 <phy_rx_func+0x588>
80003488:	e0 8b 00 06 	brhi	80003494 <phy_rx_func+0x268>
8000348c:	58 08       	cp.w	r8,0
8000348e:	c0 b0       	breq	800034a4 <phy_rx_func+0x278>
80003490:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80003494:	58 38       	cp.w	r8,3
80003496:	e0 80 05 c5 	breq	80004020 <phy_rx_func+0xdf4>
8000349a:	58 48       	cp.w	r8,4
8000349c:	e0 81 06 05 	brne	800040a6 <phy_rx_func+0xe7a>
800034a0:	e0 8f 02 4b 	bral	80003936 <phy_rx_func+0x70a>
	{
		case WAITINGABAB:

			
			if (payload_rx_channel->dword[0] == 0xABCD5A5A)//Ignore Idles.
800034a4:	6e 28       	ld.w	r8,r7[0x8]
800034a6:	e0 6a 5a 5a 	mov	r10,23130
800034aa:	ea 1a ab cd 	orh	r10,0xabcd
800034ae:	14 38       	cp.w	r8,r10
800034b0:	c0 71       	brne	800034be <phy_rx_func+0x292>
			{
				m_RxBurstType = VOICE_WATING;
800034b2:	30 09       	mov	r9,0
800034b4:	fe f8 0c 38 	ld.w	r8,pc[3128]
800034b8:	91 09       	st.w	r8[0x0],r9
800034ba:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
				//Upon receiving the idle frame, the m Rx Burst Type into an idle state in order to transmit the synchronization wait
				 break; 
			}
            
			if ((payload_rx_channel->dword[0]  & 0xFFFF0000) != 0xABCD0000)break; //Skip until Header. 
800034be:	10 99       	mov	r9,r8
800034c0:	e0 19 00 00 	andl	r9,0x0
800034c4:	fc 1a ab cd 	movh	r10,0xabcd
800034c8:	14 39       	cp.w	r9,r10
800034ca:	e0 81 05 ee 	brne	800040a6 <phy_rx_func+0xe7a>
			}
			//logFromISR("\n\r P: %X \n\r", payload_rx_channel->word[1]);//测试收到的数据
			
#endif
			
			RxBytesWaiting = payload_rx_channel->dword[0] & 0x000000FF;
800034ce:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
800034d2:	fe f9 0c 1e 	ld.w	r9,pc[3102]
800034d6:	93 08       	st.w	r9[0x0],r8
			/****Note AMBE stream protocol frame structure and the PCM frame structure is different*****/
					
			if ((payload_rx_channel->dword[0] & 0x0000F000 ) == PAYLOAD_DATA_ENH )//PAYLOAD_DATA_ENH (0x0c))
800034d8:	6e 29       	ld.w	r9,r7[0x8]
800034da:	e2 19 f0 00 	andl	r9,0xf000,COH
800034de:	e0 49 c0 00 	cp.w	r9,49152
800034e2:	e0 81 00 ce 	brne	8000367e <phy_rx_func+0x452>
			{
				AMBE_Media = 1;	
800034e6:	30 1a       	mov	r10,1
800034e8:	fe f9 0c 0c 	ld.w	r9,pc[3084]
800034ec:	b2 8a       	st.b	r9[0x0],r10
				
				if (NULL== AMBE_payload_ptr){
800034ee:	fe f9 0b f6 	ld.w	r9,pc[3062]
800034f2:	72 09       	ld.w	r9,r9[0x0]
800034f4:	58 09       	cp.w	r9,0
800034f6:	c0 71       	brne	80003504 <phy_rx_func+0x2d8>
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//测试是否有这种情况出现
800034f8:	fe fc 0c 00 	ld.w	r12,pc[3072]
800034fc:	f0 1f 03 00 	mcall	800040fc <phy_rx_func+0xed0>
80003500:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
																	
				Item_ID = payload_rx_channel->byte[5];
80003504:	ef 3a 00 0d 	ld.ub	r10,r7[13]
80003508:	fe f9 0b f8 	ld.w	r9,pc[3064]
8000350c:	b2 8a       	st.b	r9[0x0],r10
				
				Item_Length = (payload_rx_channel->byte[4] & 0x7F);//7bits
8000350e:	ef 3b 00 0c 	ld.ub	r11,r7[12]
80003512:	f7 db c0 07 	bfextu	r11,r11,0x0,0x7
80003516:	fe fa 0b ee 	ld.w	r10,pc[3054]
8000351a:	95 0b       	st.w	r10[0x0],r11
								
				switch(Item_ID)
8000351c:	13 89       	ld.ub	r9,r9[0x0]
8000351e:	37 fa       	mov	r10,127
80003520:	f4 09 18 00 	cp.b	r9,r10
80003524:	c6 d0       	breq	800035fe <phy_rx_func+0x3d2>
80003526:	e0 8b 00 0c 	brhi	8000353e <phy_rx_func+0x312>
8000352a:	31 2a       	mov	r10,18
8000352c:	f4 09 18 00 	cp.b	r9,r10
80003530:	c4 20       	breq	800035b4 <phy_rx_func+0x388>
80003532:	31 3a       	mov	r10,19
80003534:	f4 09 18 00 	cp.b	r9,r10
80003538:	e0 81 00 83 	brne	8000363e <phy_rx_func+0x412>
8000353c:	c5 b8       	rjmp	800035f2 <phy_rx_func+0x3c6>
8000353e:	2f 09       	sub	r9,-16
80003540:	30 1a       	mov	r10,1
80003542:	f4 09 18 00 	cp.b	r9,r10
80003546:	e0 8b 00 7c 	brhi	8000363e <phy_rx_func+0x412>
					//The OB know the Call begin and discard the Voice Header
					//The OB know the Call end and discard the Voice  Terminator
					case Raw_Tx_Data_HT://0xF0
					case Raw_Rx_Data_HT://0xF1
					
							if ((payload_rx_channel->byte[6] & 0xF0 )== 0x10)//header
8000354a:	ef 38 00 0e 	ld.ub	r8,r7[14]
8000354e:	e2 18 00 f0 	andl	r8,0xf0,COH
80003552:	59 08       	cp.w	r8,16
80003554:	c0 71       	brne	80003562 <phy_rx_func+0x336>
							{
								m_RxBurstType = VOICEHEADER;
80003556:	30 19       	mov	r9,1
80003558:	fe f8 0b 94 	ld.w	r8,pc[2964]
8000355c:	91 09       	st.w	r8[0x0],r9
8000355e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

							}
							else if ((payload_rx_channel->byte[6] & 0xF0) == 0x20)//Terminator
80003562:	e0 48 00 20 	cp.w	r8,32
80003566:	c2 11       	brne	800035a8 <phy_rx_func+0x37c>
							{
								m_RxBurstType = VOICETERMINATOR;
80003568:	30 a9       	mov	r9,10
8000356a:	fe f8 0b 82 	ld.w	r8,pc[2946]
8000356e:	91 09       	st.w	r8[0x0],r9
								//AMBE-data and PCM-data is not the same. AMBE is compressed data,
								//if there was a missing portion, a clear voice is difficult to extract the data.
								//It must ensure that all the data received AMBE.
								
								//注意！！！考虑是否需要把剩余的空间置0。
								memset((AMBE_payload_ptr+ (RxAMBE_IsFillingNext8 +1)), 0x00, (512-(RxAMBE_IsFillingNext8 + 1)));
80003570:	fe f6 0b 98 	ld.w	r6,pc[2968]
80003574:	6c 08       	ld.w	r8,r6[0x0]
80003576:	f0 0a 11 ff 	rsub	r10,r8,-1
8000357a:	fe f7 0b 6a 	ld.w	r7,pc[2922]
8000357e:	2f f8       	sub	r8,-1
80003580:	6e 0c       	ld.w	r12,r7[0x0]
80003582:	f4 ca fe 00 	sub	r10,r10,-512
80003586:	30 0b       	mov	r11,0
80003588:	10 0c       	add	r12,r8
8000358a:	f0 1f 02 e1 	mcall	8000410c <phy_rx_func+0xee0>
								
								RxAMBE_IsFillingNext8 = 0;
8000358e:	30 08       	mov	r8,0
80003590:	8d 08       	st.w	r6[0x0],r8
								payload_rx(AMBE_payload_ptr);
80003592:	6e 0c       	ld.w	r12,r7[0x0]
80003594:	f0 1f 02 df 	mcall	80004110 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003598:	fe f8 0b 44 	ld.w	r8,pc[2884]
8000359c:	70 0c       	ld.w	r12,r8[0x0]
8000359e:	f0 1f 02 ca 	mcall	800040c4 <phy_rx_func+0xe98>
800035a2:	8f 0c       	st.w	r7[0x0],r12
800035a4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								//logFromISR("\n\r QQ1 \n\r");
								
							}
							else//error voice
							{
								m_RxBurstType = VOICE_WATING;
800035a8:	30 09       	mov	r9,0
800035aa:	fe f8 0b 42 	ld.w	r8,pc[2882]
800035ae:	91 09       	st.w	r8[0x0],r9
800035b0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;//WAITINGABAB.
					
		
					case Vocoder_Bit_Stream_Parameter://0x12
							
							if ((RxBytesWaiting -= 4) <= 0) break;
800035b4:	20 48       	sub	r8,4
800035b6:	fe f9 0b 3a 	ld.w	r9,pc[2874]
800035ba:	93 08       	st.w	r9[0x0],r8
800035bc:	58 08       	cp.w	r8,0
800035be:	e0 80 05 74 	breq	800040a6 <phy_rx_func+0xe7a>
					
							//Vocoder Bits Stream Parameter
							VF_SN = (payload_rx_channel->byte[7] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
800035c2:	ef 3c 00 0f 	ld.ub	r12,r7[15]
800035c6:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
800035ca:	fe f8 0b 4a 	ld.w	r8,pc[2890]
800035ce:	b0 8c       	st.b	r8[0x0],r12
							
							VBSP_data[0] = payload_rx_channel->word[2];
800035d0:	8e 69       	ld.sh	r9,r7[0xc]
800035d2:	fe f8 0b 46 	ld.w	r8,pc[2886]
800035d6:	b0 09       	st.h	r8[0x0],r9
							VBSP_data[1] = payload_rx_channel->word[3];
800035d8:	8e 79       	ld.sh	r9,r7[0xe]
800035da:	b0 19       	st.h	r8[0x2],r9
							
							m_RxBurstType = CalculateBurst(VF_SN);
800035dc:	f0 1f 02 d0 	mcall	8000411c <phy_rx_func+0xef0>
800035e0:	fe f8 0b 0c 	ld.w	r8,pc[2828]
800035e4:	91 0c       	st.w	r8[0x0],r12
							
							RxMediaState = READING_AMBE_MEDIA;//Jump
800035e6:	30 49       	mov	r9,4
800035e8:	fe f8 0b 00 	ld.w	r8,pc[2816]
800035ec:	91 09       	st.w	r8[0x0],r9
800035ee:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							
					//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
					// or discard it to reduce payload size.	
					//This shouldn't happen, but must check.	
					case Soft_Decision_Value://0x13
						m_RxBurstType = VOICE_WATING;
800035f2:	30 09       	mov	r9,0
800035f4:	fe f8 0a f8 	ld.w	r8,pc[2808]
800035f8:	91 09       	st.w	r8[0x0],r9
800035fa:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
					case Radio_Internal_Parameter://0x7F
							
							//logFromISR("\n\r Item_Length:%d\n\r", Item_Length);
							
							if ((RxBytesWaiting -= 4) <= 0) break;
800035fe:	20 48       	sub	r8,4
80003600:	fe f9 0a f0 	ld.w	r9,pc[2800]
80003604:	93 08       	st.w	r9[0x0],r8
80003606:	58 08       	cp.w	r8,0
80003608:	e0 80 05 4f 	breq	800040a6 <phy_rx_func+0xe7a>
							//Radio Internal Parameter
							Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[3];
8000360c:	fe f8 0b 14 	ld.w	r8,pc[2836]
80003610:	70 09       	ld.w	r9,r8[0x0]
80003612:	8e 7b       	ld.sh	r11,r7[0xe]
80003614:	fe fa 0b 10 	ld.w	r10,pc[2832]
80003618:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
							RxData_IsFillingNext16 += 1; 
8000361c:	2f f9       	sub	r9,-1
8000361e:	91 09       	st.w	r8[0x0],r9
							Item_Length -= 2 ;
80003620:	fe f8 0a e4 	ld.w	r8,pc[2788]
80003624:	70 09       	ld.w	r9,r8[0x0]
80003626:	20 29       	sub	r9,2
80003628:	91 09       	st.w	r8[0x0],r9
							//....................................................
							m_RxBurstType = RADIOINTERNAL;
8000362a:	30 29       	mov	r9,2
8000362c:	fe f8 0a c0 	ld.w	r8,pc[2752]
80003630:	91 09       	st.w	r8[0x0],r9

							RxMediaState = READING_AMBE_AUX;//Jump
80003632:	30 39       	mov	r9,3
80003634:	fe f8 0a b4 	ld.w	r8,pc[2740]
80003638:	91 09       	st.w	r8[0x0],r9
8000363a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									
					default://0x03,0x04
						
						//((Item_ID == 0x04) || (Item_ID == 0x03) )//Unknown type data directly back hair
							//break;
							m_RxBurstType = UNSUREDATA;
8000363e:	30 3a       	mov	r10,3
80003640:	fe f9 0a ac 	ld.w	r9,pc[2732]
80003644:	93 0a       	st.w	r9[0x0],r10
							AMBE_HT[0] = payload_rx_channel->dword[0];
80003646:	6e 2a       	ld.w	r10,r7[0x8]
80003648:	fe f9 0a e0 	ld.w	r9,pc[2784]
8000364c:	93 0a       	st.w	r9[0x0],r10
							AMBE_HT[1] = payload_rx_channel->dword[1];
8000364e:	6e 3a       	ld.w	r10,r7[0xc]
80003650:	93 1a       	st.w	r9[0x4],r10
							
							if (RxBytesWaiting == 0x00000014)
80003652:	59 48       	cp.w	r8,20
80003654:	c0 61       	brne	80003660 <phy_rx_func+0x434>
							{
								RxBytesWaiting = 0x18;//24 Reassigned
80003656:	31 89       	mov	r9,24
80003658:	fe f8 0a 98 	ld.w	r8,pc[2712]
8000365c:	91 09       	st.w	r8[0x0],r9
8000365e:	c0 a8       	rjmp	80003672 <phy_rx_func+0x446>
								//_flag =0;
								
							}
							if (RxBytesWaiting == 0x00000010)
80003660:	fe f8 0a 90 	ld.w	r8,pc[2704]
80003664:	70 08       	ld.w	r8,r8[0x0]
80003666:	59 08       	cp.w	r8,16
80003668:	c0 51       	brne	80003672 <phy_rx_func+0x446>
							{
								RxBytesWaiting = 0x10;//16 Reassigned
8000366a:	31 09       	mov	r9,16
8000366c:	fe f8 0a 84 	ld.w	r8,pc[2692]
80003670:	91 09       	st.w	r8[0x0],r9
								//_flag =1;
							}
					
							RxMediaState = READING_AMBE_MEDIA;//Jump
80003672:	30 49       	mov	r9,4
80003674:	fe f8 0a 74 	ld.w	r8,pc[2676]
80003678:	91 09       	st.w	r8[0x0],r9
8000367a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
//#if 0
			else//PCM-media-data
			{	
				//logFromISR("\n\r RX:%x \n\r", payload_rx_channel->dword[0]);
				//SPEAKER_DATA or  //MIC_DATA
				if (((payload_rx_channel->dword[0] & 0x0000F000 ) != SPEAKER_DATA ) 
8000367e:	e0 49 10 00 	cp.w	r9,4096
80003682:	5f 1a       	srne	r10
80003684:	e0 49 20 00 	cp.w	r9,8192
80003688:	5f 19       	srne	r9
8000368a:	f5 e9 00 09 	and	r9,r10,r9
8000368e:	e0 81 05 0c 	brne	800040a6 <phy_rx_func+0xe7a>
					&& ((payload_rx_channel->dword[0] & 0x0000F000 ) != MIC_DATA ))break;
				
				AMBE_tx_flag = 0;
80003692:	fe fa 0a 9a 	ld.w	r10,pc[2714]
80003696:	b4 89       	st.b	r10[0x0],r9
				AMBE_rx_flag = 0;
80003698:	fe fa 0a 98 	ld.w	r10,pc[2712]
8000369c:	b4 89       	st.b	r10[0x0],r9
				
				Item_ID = 0;//To make sure your save PCM data.
8000369e:	fe fa 0a 62 	ld.w	r10,pc[2658]
800036a2:	b4 89       	st.b	r10[0x0],r9
			
				if (NULL== payload_ptr){
800036a4:	fe f9 0a 3c 	ld.w	r9,pc[2620]
800036a8:	72 09       	ld.w	r9,r9[0x0]
800036aa:	58 09       	cp.w	r9,0
800036ac:	c0 71       	brne	800036ba <phy_rx_func+0x48e>
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//测试是否有这种情况出现
800036ae:	fe fc 0a 4a 	ld.w	r12,pc[2634]
800036b2:	f0 1f 02 93 	mcall	800040fc <phy_rx_func+0xed0>
800036b6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
800036ba:	6e 2a       	ld.w	r10,r7[0x8]
800036bc:	e2 1a 0f 00 	andl	r10,0xf00,COH
800036c0:	58 1a       	cp.w	r10,1
800036c2:	e0 8b 00 4d 	brhi	8000375c <phy_rx_func+0x530>
				
				if ((payload_rx_channel->dword[0]  & 0x00000F00) <= 1){  //Flag type must process Array Descriptor.
				//The first word of the media access payload must be the Array descriptor length. And the
				//unit of the length is in word (16-bit). The length field itself does not count into the length.
				//When there is no array descriptor, the length must be set to zero.[9.1.4.1]
					if ((RxBytesWaiting -= 4) <= 0) break;          //Nothing beyond this Phy buffer. Keep looking for Header
800036c6:	20 48       	sub	r8,4
800036c8:	fe f9 0a 28 	ld.w	r9,pc[2600]
800036cc:	93 08       	st.w	r9[0x0],r8
800036ce:	58 08       	cp.w	r8,0
800036d0:	e0 80 04 eb 	breq	800040a6 <phy_rx_func+0xe7a>
					ArrayDiscLength = payload_rx_channel->word[2];
800036d4:	8e 68       	ld.sh	r8,r7[0xc]
800036d6:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
800036da:	fe f9 0a 5a 	ld.w	r9,pc[2650]
800036de:	93 0a       	st.w	r9[0x0],r10
					switch (ArrayDiscLength){
800036e0:	30 09       	mov	r9,0
800036e2:	f2 08 19 00 	cp.h	r8,r9
800036e6:	c0 70       	breq	800036f4 <phy_rx_func+0x4c8>
800036e8:	30 19       	mov	r9,1
800036ea:	f2 08 19 00 	cp.h	r8,r9
800036ee:	e0 81 04 dc 	brne	800040a6 <phy_rx_func+0xe7a>
800036f2:	c2 68       	rjmp	8000373e <phy_rx_func+0x512>
						case 0:          //The usual case. Remaining word in Phy buffer is Audio.
								
							payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
800036f4:	fe f8 0a 44 	ld.w	r8,pc[2628]
800036f8:	70 0a       	ld.w	r10,r8[0x0]
800036fa:	fe f9 09 e6 	ld.w	r9,pc[2534]
800036fe:	72 09       	ld.w	r9,r9[0x0]
80003700:	8e 7b       	ld.sh	r11,r7[0xe]
80003702:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
							RxMedia_IsFillingNext16 += 1;
80003706:	70 09       	ld.w	r9,r8[0x0]
80003708:	2f f9       	sub	r9,-1
8000370a:	91 09       	st.w	r8[0x0],r9
							if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
8000370c:	e0 49 00 ff 	cp.w	r9,255
80003710:	e0 88 00 11 	brls	80003732 <phy_rx_func+0x506>
							{
								RxMedia_IsFillingNext16 = 0;	
80003714:	30 09       	mov	r9,0
80003716:	91 09       	st.w	r8[0x0],r9
								payload_rx(payload_ptr);	
80003718:	fe f7 09 c8 	ld.w	r7,pc[2504]
8000371c:	6e 0c       	ld.w	r12,r7[0x0]
8000371e:	f0 1f 02 7d 	mcall	80004110 <phy_rx_func+0xee4>
								payload_ptr = get_payload_idle_isr();
80003722:	fe f8 09 ba 	ld.w	r8,pc[2490]
80003726:	70 0c       	ld.w	r12,r8[0x0]
80003728:	f0 1f 02 67 	mcall	800040c4 <phy_rx_func+0xe98>
8000372c:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == payload_ptr){
8000372e:	e0 80 04 bc 	breq	800040a6 <phy_rx_func+0xe7a>
									break;
								}				
							}
							RxMediaState = READINGMEDIA;
80003732:	30 29       	mov	r9,2
80003734:	fe f8 09 b4 	ld.w	r8,pc[2484]
80003738:	91 09       	st.w	r8[0x0],r9
8000373a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
8000373e:	8e 79       	ld.sh	r9,r7[0xe]
80003740:	30 38       	mov	r8,3
80003742:	f0 09 19 00 	cp.h	r9,r8
80003746:	c0 51       	brne	80003750 <phy_rx_func+0x524>
				
						case 1: //The next usual case.
								//In general case, add code to process single word Array descriptor.
								if (payload_rx_channel->word[3] == 0x0003)//Stream Terminator
								{
									Terminator_Flag = 1;
80003748:	30 19       	mov	r9,1
8000374a:	fe f8 09 f2 	ld.w	r8,pc[2546]
8000374e:	b0 89       	st.b	r8[0x0],r9
								else
								{
									//Terminator_Flag = 0;
								}
								
								RxMediaState = READINGMEDIA;
80003750:	30 29       	mov	r9,2
80003752:	fe f8 09 96 	ld.w	r8,pc[2454]
80003756:	91 09       	st.w	r8[0x0],r9
80003758:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
				break;
			}
		
				//Code gets here on Middle or last Fragment. No Array descriptor.
				if (RxBytesWaiting < 2) break;//This shouldn't happen, but must check.
8000375c:	58 18       	cp.w	r8,1
8000375e:	e0 88 04 a4 	brls	800040a6 <phy_rx_func+0xe7a>
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->dword[1] & 0x0000FFFF;
80003762:	fe f8 09 d6 	ld.w	r8,pc[2518]
80003766:	70 0a       	ld.w	r10,r8[0x0]
80003768:	6e 3b       	ld.w	r11,r7[0xc]
8000376a:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
8000376e:	70 09       	ld.w	r9,r8[0x0]
80003770:	2f f9       	sub	r9,-1
80003772:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003774:	e0 49 00 ff 	cp.w	r9,255
80003778:	e0 88 00 11 	brls	8000379a <phy_rx_func+0x56e>
				{
					RxMedia_IsFillingNext16 = 0;
8000377c:	30 09       	mov	r9,0
8000377e:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003780:	fe f7 09 60 	ld.w	r7,pc[2400]
80003784:	6e 0c       	ld.w	r12,r7[0x0]
80003786:	f0 1f 02 63 	mcall	80004110 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
8000378a:	fe f8 09 52 	ld.w	r8,pc[2386]
8000378e:	70 0c       	ld.w	r12,r8[0x0]
80003790:	f0 1f 02 4d 	mcall	800040c4 <phy_rx_func+0xe98>
80003794:	8f 0c       	st.w	r7[0x0],r12
					if(NULL == payload_ptr)
80003796:	e0 80 04 88 	breq	800040a6 <phy_rx_func+0xe7a>
					{
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0) break;  //This shouldn't happen, but must check;
8000379a:	fe f9 09 56 	ld.w	r9,pc[2390]
8000379e:	72 08       	ld.w	r8,r9[0x0]
800037a0:	20 28       	sub	r8,2
800037a2:	93 08       	st.w	r9[0x0],r8
800037a4:	e0 80 04 81 	breq	800040a6 <phy_rx_func+0xe7a>
				RxMediaState = READINGMEDIA;
800037a8:	30 29       	mov	r9,2
800037aa:	fe f8 09 3e 	ld.w	r8,pc[2366]
800037ae:	91 09       	st.w	r8[0x0],r9
800037b0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
		case READINGMEDIA:
				
			/***PCM-media-data ****/
			{
				
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[0];
800037b4:	fe f8 09 84 	ld.w	r8,pc[2436]
800037b8:	70 0a       	ld.w	r10,r8[0x0]
800037ba:	fe f9 09 26 	ld.w	r9,pc[2342]
800037be:	72 09       	ld.w	r9,r9[0x0]
800037c0:	8e 4b       	ld.sh	r11,r7[0x8]
800037c2:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;	
800037c6:	70 09       	ld.w	r9,r8[0x0]
800037c8:	2f f9       	sub	r9,-1
800037ca:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800037cc:	e0 49 00 ff 	cp.w	r9,255
800037d0:	e0 88 00 16 	brls	800037fc <phy_rx_func+0x5d0>
				{
					RxMedia_IsFillingNext16 = 0;
800037d4:	30 09       	mov	r9,0
800037d6:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
800037d8:	fe f6 09 08 	ld.w	r6,pc[2312]
800037dc:	6c 0c       	ld.w	r12,r6[0x0]
800037de:	f0 1f 02 4d 	mcall	80004110 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
800037e2:	fe f8 08 fa 	ld.w	r8,pc[2298]
800037e6:	70 0c       	ld.w	r12,r8[0x0]
800037e8:	f0 1f 02 37 	mcall	800040c4 <phy_rx_func+0xe98>
800037ec:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
800037ee:	c0 71       	brne	800037fc <phy_rx_func+0x5d0>
					{
						RxMediaState = WAITINGABAB;
800037f0:	30 09       	mov	r9,0
800037f2:	fe f8 08 f6 	ld.w	r8,pc[2294]
800037f6:	91 09       	st.w	r8[0x0],r9
800037f8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0)
800037fc:	fe f9 08 f4 	ld.w	r9,pc[2292]
80003800:	72 08       	ld.w	r8,r9[0x0]
80003802:	20 28       	sub	r8,2
80003804:	93 08       	st.w	r9[0x0],r8
80003806:	c0 71       	brne	80003814 <phy_rx_func+0x5e8>
				{
					RxMediaState = WAITINGABAB;
80003808:	30 09       	mov	r9,0
8000380a:	fe f8 08 de 	ld.w	r8,pc[2270]
8000380e:	91 09       	st.w	r8[0x0],r9
80003810:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[1];
80003814:	fe f8 09 24 	ld.w	r8,pc[2340]
80003818:	70 0a       	ld.w	r10,r8[0x0]
8000381a:	fe f9 08 c6 	ld.w	r9,pc[2246]
8000381e:	72 09       	ld.w	r9,r9[0x0]
80003820:	8e 5b       	ld.sh	r11,r7[0xa]
80003822:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80003826:	70 09       	ld.w	r9,r8[0x0]
80003828:	2f f9       	sub	r9,-1
8000382a:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
8000382c:	e0 49 00 ff 	cp.w	r9,255
80003830:	e0 88 00 16 	brls	8000385c <phy_rx_func+0x630>
				{
					RxMedia_IsFillingNext16 = 0;
80003834:	30 09       	mov	r9,0
80003836:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003838:	fe f6 08 a8 	ld.w	r6,pc[2216]
8000383c:	6c 0c       	ld.w	r12,r6[0x0]
8000383e:	f0 1f 02 35 	mcall	80004110 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
80003842:	fe f8 08 9a 	ld.w	r8,pc[2202]
80003846:	70 0c       	ld.w	r12,r8[0x0]
80003848:	f0 1f 02 1f 	mcall	800040c4 <phy_rx_func+0xe98>
8000384c:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
8000384e:	c0 71       	brne	8000385c <phy_rx_func+0x630>
					{
						RxMediaState = WAITINGABAB;
80003850:	30 09       	mov	r9,0
80003852:	fe f8 08 96 	ld.w	r8,pc[2198]
80003856:	91 09       	st.w	r8[0x0],r9
80003858:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
8000385c:	fe f9 08 94 	ld.w	r9,pc[2196]
80003860:	72 08       	ld.w	r8,r9[0x0]
80003862:	20 28       	sub	r8,2
80003864:	93 08       	st.w	r9[0x0],r8
80003866:	c0 71       	brne	80003874 <phy_rx_func+0x648>
					RxMediaState = WAITINGABAB;
80003868:	30 09       	mov	r9,0
8000386a:	fe f8 08 7e 	ld.w	r8,pc[2174]
8000386e:	91 09       	st.w	r8[0x0],r9
80003870:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}

				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[2];
80003874:	fe f8 08 c4 	ld.w	r8,pc[2244]
80003878:	70 0a       	ld.w	r10,r8[0x0]
8000387a:	fe f9 08 66 	ld.w	r9,pc[2150]
8000387e:	72 09       	ld.w	r9,r9[0x0]
80003880:	8e 6b       	ld.sh	r11,r7[0xc]
80003882:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80003886:	70 09       	ld.w	r9,r8[0x0]
80003888:	2f f9       	sub	r9,-1
8000388a:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
8000388c:	e0 49 00 ff 	cp.w	r9,255
80003890:	e0 88 00 16 	brls	800038bc <phy_rx_func+0x690>
				{
					RxMedia_IsFillingNext16 = 0;
80003894:	30 09       	mov	r9,0
80003896:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003898:	fe f6 08 48 	ld.w	r6,pc[2120]
8000389c:	6c 0c       	ld.w	r12,r6[0x0]
8000389e:	f0 1f 02 1d 	mcall	80004110 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
800038a2:	fe f8 08 3a 	ld.w	r8,pc[2106]
800038a6:	70 0c       	ld.w	r12,r8[0x0]
800038a8:	f0 1f 02 07 	mcall	800040c4 <phy_rx_func+0xe98>
800038ac:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
800038ae:	c0 71       	brne	800038bc <phy_rx_func+0x690>
					{
						RxMediaState = WAITINGABAB;
800038b0:	30 09       	mov	r9,0
800038b2:	fe f8 08 36 	ld.w	r8,pc[2102]
800038b6:	91 09       	st.w	r8[0x0],r9
800038b8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
800038bc:	fe f9 08 34 	ld.w	r9,pc[2100]
800038c0:	72 08       	ld.w	r8,r9[0x0]
800038c2:	20 28       	sub	r8,2
800038c4:	93 08       	st.w	r9[0x0],r8
800038c6:	c0 71       	brne	800038d4 <phy_rx_func+0x6a8>
					RxMediaState = WAITINGABAB;
800038c8:	30 09       	mov	r9,0
800038ca:	fe f8 08 1e 	ld.w	r8,pc[2078]
800038ce:	91 09       	st.w	r8[0x0],r9
800038d0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
800038d4:	fe f8 08 64 	ld.w	r8,pc[2148]
800038d8:	70 0a       	ld.w	r10,r8[0x0]
800038da:	fe f9 08 06 	ld.w	r9,pc[2054]
800038de:	72 09       	ld.w	r9,r9[0x0]
800038e0:	8e 7b       	ld.sh	r11,r7[0xe]
800038e2:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
800038e6:	70 09       	ld.w	r9,r8[0x0]
800038e8:	2f f9       	sub	r9,-1
800038ea:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800038ec:	e0 49 00 ff 	cp.w	r9,255
800038f0:	e0 88 00 16 	brls	8000391c <phy_rx_func+0x6f0>
				{
					RxMedia_IsFillingNext16 = 0;
800038f4:	30 09       	mov	r9,0
800038f6:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
800038f8:	fe f7 07 e8 	ld.w	r7,pc[2024]
800038fc:	6e 0c       	ld.w	r12,r7[0x0]
800038fe:	f0 1f 02 05 	mcall	80004110 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
80003902:	fe f8 07 da 	ld.w	r8,pc[2010]
80003906:	70 0c       	ld.w	r12,r8[0x0]
80003908:	f0 1f 01 ef 	mcall	800040c4 <phy_rx_func+0xe98>
8000390c:	8f 0c       	st.w	r7[0x0],r12
					if(NULL == payload_ptr)
8000390e:	c0 71       	brne	8000391c <phy_rx_func+0x6f0>
					{
						RxMediaState = WAITINGABAB;
80003910:	30 09       	mov	r9,0
80003912:	fe f8 07 d6 	ld.w	r8,pc[2006]
80003916:	91 09       	st.w	r8[0x0],r9
80003918:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
8000391c:	fe f9 07 d4 	ld.w	r9,pc[2004]
80003920:	72 08       	ld.w	r8,r9[0x0]
80003922:	20 28       	sub	r8,2
80003924:	93 08       	st.w	r9[0x0],r8
80003926:	e0 81 03 c0 	brne	800040a6 <phy_rx_func+0xe7a>
					RxMediaState = WAITINGABAB;
8000392a:	30 09       	mov	r9,0
8000392c:	fe f8 07 bc 	ld.w	r8,pc[1980]
80003930:	91 09       	st.w	r8[0x0],r9
80003932:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

		case READING_AMBE_MEDIA:
		
			/****AMBE-media-data ****/
		
					if ((Item_ID == Vocoder_Bit_Stream_Parameter))//PAYLOAD_DATA_ENH (0x0c))
80003936:	fe f8 07 ca 	ld.w	r8,pc[1994]
8000393a:	11 89       	ld.ub	r9,r8[0x0]
8000393c:	31 28       	mov	r8,18
8000393e:	f0 09 18 00 	cp.b	r9,r8
80003942:	e0 81 01 4c 	brne	80003bda <phy_rx_func+0x9ae>
					{
						Item_ID = payload_rx_channel->byte[1];
80003946:	ef 39 00 09 	ld.ub	r9,r7[9]
8000394a:	fe f8 07 b6 	ld.w	r8,pc[1974]
8000394e:	b0 89       	st.b	r8[0x0],r9
						if (Item_ID == Post_Voice_Encoder_Data)//发送方的压缩类型数据
80003950:	11 89       	ld.ub	r9,r8[0x0]
80003952:	3f 28       	mov	r8,-14
80003954:	f0 09 18 00 	cp.b	r9,r8
80003958:	e0 81 01 3b 	brne	80003bce <phy_rx_func+0x9a2>
						{
							AMBE_tx_flag = 1;
8000395c:	30 19       	mov	r9,1
8000395e:	fe f8 07 ce 	ld.w	r8,pc[1998]
80003962:	b0 89       	st.b	r8[0x0],r9
							
							RxBytesWaiting = ((payload_rx_channel->dword[0] & 0x7F000000) >>24);//Test calculations are correct; 8
80003964:	6e 29       	ld.w	r9,r7[0x8]
80003966:	f3 d9 c3 07 	bfextu	r9,r9,0x18,0x7
8000396a:	fe f8 07 86 	ld.w	r8,pc[1926]
8000396e:	91 09       	st.w	r8[0x0],r9
							
							//For looping back to Radio
							AMBEBurst_rawdata[0] = payload_rx_channel->word[1];
80003970:	8e 59       	ld.sh	r9,r7[0xa]
80003972:	fe f8 07 ce 	ld.w	r8,pc[1998]
80003976:	b0 09       	st.h	r8[0x0],r9
							AMBEBurst_rawdata[1] = payload_rx_channel->word[2];
80003978:	8e 69       	ld.sh	r9,r7[0xc]
8000397a:	b0 19       	st.h	r8[0x2],r9
							AMBEBurst_rawdata[2] = payload_rx_channel->word[3];
8000397c:	8e 79       	ld.sh	r9,r7[0xe]
8000397e:	b0 29       	st.h	r8[0x4],r9
							
							//To be tested. Also locally stored RAW-AMBER-DATA
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//1
80003980:	fe f8 07 88 	ld.w	r8,pc[1928]
80003984:	fe f9 07 60 	ld.w	r9,pc[1888]
80003988:	72 0a       	ld.w	r10,r9[0x0]
8000398a:	70 09       	ld.w	r9,r8[0x0]
8000398c:	ef 3b 00 0a 	ld.ub	r11,r7[10]
80003990:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003994:	70 09       	ld.w	r9,r8[0x0]
80003996:	2f f9       	sub	r9,-1
80003998:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000399a:	e0 49 01 ff 	cp.w	r9,511
8000399e:	e0 88 00 16 	brls	800039ca <phy_rx_func+0x79e>
							{
								RxAMBE_IsFillingNext8 = 0;
800039a2:	30 09       	mov	r9,0
800039a4:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
800039a6:	fe f6 07 3e 	ld.w	r6,pc[1854]
800039aa:	6c 0c       	ld.w	r12,r6[0x0]
800039ac:	f0 1f 01 d9 	mcall	80004110 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
800039b0:	fe f8 07 2c 	ld.w	r8,pc[1836]
800039b4:	70 0c       	ld.w	r12,r8[0x0]
800039b6:	f0 1f 01 c4 	mcall	800040c4 <phy_rx_func+0xe98>
800039ba:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
800039bc:	c0 71       	brne	800039ca <phy_rx_func+0x79e>
								{
									RxMediaState = WAITINGABAB;
800039be:	30 09       	mov	r9,0
800039c0:	fe f8 07 28 	ld.w	r8,pc[1832]
800039c4:	91 09       	st.w	r8[0x0],r9
800039c6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800039ca:	fe f9 07 26 	ld.w	r9,pc[1830]
800039ce:	72 08       	ld.w	r8,r9[0x0]
800039d0:	20 18       	sub	r8,1
800039d2:	93 08       	st.w	r9[0x0],r8
800039d4:	c0 71       	brne	800039e2 <phy_rx_func+0x7b6>
								RxMediaState = WAITINGABAB;
800039d6:	30 09       	mov	r9,0
800039d8:	fe f8 07 10 	ld.w	r8,pc[1808]
800039dc:	91 09       	st.w	r8[0x0],r9
800039de:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}			
							
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//2
800039e2:	fe f8 07 26 	ld.w	r8,pc[1830]
800039e6:	fe f9 06 fe 	ld.w	r9,pc[1790]
800039ea:	72 0a       	ld.w	r10,r9[0x0]
800039ec:	70 09       	ld.w	r9,r8[0x0]
800039ee:	ef 3b 00 0b 	ld.ub	r11,r7[11]
800039f2:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
800039f6:	70 09       	ld.w	r9,r8[0x0]
800039f8:	2f f9       	sub	r9,-1
800039fa:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800039fc:	e0 49 01 ff 	cp.w	r9,511
80003a00:	e0 88 00 16 	brls	80003a2c <phy_rx_func+0x800>
							{
								RxAMBE_IsFillingNext8 = 0;
80003a04:	30 09       	mov	r9,0
80003a06:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003a08:	fe f6 06 dc 	ld.w	r6,pc[1756]
80003a0c:	6c 0c       	ld.w	r12,r6[0x0]
80003a0e:	f0 1f 01 c1 	mcall	80004110 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003a12:	fe f8 06 ca 	ld.w	r8,pc[1738]
80003a16:	70 0c       	ld.w	r12,r8[0x0]
80003a18:	f0 1f 01 ab 	mcall	800040c4 <phy_rx_func+0xe98>
80003a1c:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003a1e:	c0 71       	brne	80003a2c <phy_rx_func+0x800>
								{
									RxMediaState = WAITINGABAB;
80003a20:	30 09       	mov	r9,0
80003a22:	fe f8 06 c6 	ld.w	r8,pc[1734]
80003a26:	91 09       	st.w	r8[0x0],r9
80003a28:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003a2c:	fe f9 06 c4 	ld.w	r9,pc[1732]
80003a30:	72 08       	ld.w	r8,r9[0x0]
80003a32:	20 18       	sub	r8,1
80003a34:	93 08       	st.w	r9[0x0],r8
80003a36:	c0 71       	brne	80003a44 <phy_rx_func+0x818>
								RxMediaState = WAITINGABAB;
80003a38:	30 09       	mov	r9,0
80003a3a:	fe f8 06 ae 	ld.w	r8,pc[1710]
80003a3e:	91 09       	st.w	r8[0x0],r9
80003a40:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}		
						
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//3
80003a44:	fe f8 06 c4 	ld.w	r8,pc[1732]
80003a48:	fe f9 06 9c 	ld.w	r9,pc[1692]
80003a4c:	72 0a       	ld.w	r10,r9[0x0]
80003a4e:	70 09       	ld.w	r9,r8[0x0]
80003a50:	ef 3b 00 0c 	ld.ub	r11,r7[12]
80003a54:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003a58:	70 09       	ld.w	r9,r8[0x0]
80003a5a:	2f f9       	sub	r9,-1
80003a5c:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003a5e:	e0 49 01 ff 	cp.w	r9,511
80003a62:	e0 88 00 16 	brls	80003a8e <phy_rx_func+0x862>
							{
								RxAMBE_IsFillingNext8 = 0;
80003a66:	30 09       	mov	r9,0
80003a68:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003a6a:	fe f6 06 7a 	ld.w	r6,pc[1658]
80003a6e:	6c 0c       	ld.w	r12,r6[0x0]
80003a70:	f0 1f 01 a8 	mcall	80004110 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003a74:	fe f8 06 68 	ld.w	r8,pc[1640]
80003a78:	70 0c       	ld.w	r12,r8[0x0]
80003a7a:	f0 1f 01 93 	mcall	800040c4 <phy_rx_func+0xe98>
80003a7e:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003a80:	c0 71       	brne	80003a8e <phy_rx_func+0x862>
								{
									RxMediaState = WAITINGABAB;
80003a82:	30 09       	mov	r9,0
80003a84:	fe f8 06 64 	ld.w	r8,pc[1636]
80003a88:	91 09       	st.w	r8[0x0],r9
80003a8a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003a8e:	fe f9 06 62 	ld.w	r9,pc[1634]
80003a92:	72 08       	ld.w	r8,r9[0x0]
80003a94:	20 18       	sub	r8,1
80003a96:	93 08       	st.w	r9[0x0],r8
80003a98:	c0 71       	brne	80003aa6 <phy_rx_func+0x87a>
								RxMediaState = WAITINGABAB;
80003a9a:	30 09       	mov	r9,0
80003a9c:	fe f8 06 4c 	ld.w	r8,pc[1612]
80003aa0:	91 09       	st.w	r8[0x0],r9
80003aa2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[5];//4
80003aa6:	fe f8 06 62 	ld.w	r8,pc[1634]
80003aaa:	fe f9 06 3a 	ld.w	r9,pc[1594]
80003aae:	72 0a       	ld.w	r10,r9[0x0]
80003ab0:	70 09       	ld.w	r9,r8[0x0]
80003ab2:	ef 3b 00 0d 	ld.ub	r11,r7[13]
80003ab6:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003aba:	70 09       	ld.w	r9,r8[0x0]
80003abc:	2f f9       	sub	r9,-1
80003abe:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003ac0:	e0 49 01 ff 	cp.w	r9,511
80003ac4:	e0 88 00 16 	brls	80003af0 <phy_rx_func+0x8c4>
							{
								RxAMBE_IsFillingNext8 = 0;
80003ac8:	30 09       	mov	r9,0
80003aca:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003acc:	fe f6 06 18 	ld.w	r6,pc[1560]
80003ad0:	6c 0c       	ld.w	r12,r6[0x0]
80003ad2:	f0 1f 01 90 	mcall	80004110 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003ad6:	fe f8 06 06 	ld.w	r8,pc[1542]
80003ada:	70 0c       	ld.w	r12,r8[0x0]
80003adc:	f0 1f 01 7a 	mcall	800040c4 <phy_rx_func+0xe98>
80003ae0:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003ae2:	c0 71       	brne	80003af0 <phy_rx_func+0x8c4>
								{
									RxMediaState = WAITINGABAB;
80003ae4:	30 09       	mov	r9,0
80003ae6:	fe f8 06 02 	ld.w	r8,pc[1538]
80003aea:	91 09       	st.w	r8[0x0],r9
80003aec:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003af0:	fe f9 06 00 	ld.w	r9,pc[1536]
80003af4:	72 08       	ld.w	r8,r9[0x0]
80003af6:	20 18       	sub	r8,1
80003af8:	93 08       	st.w	r9[0x0],r8
80003afa:	c0 71       	brne	80003b08 <phy_rx_func+0x8dc>
								RxMediaState = WAITINGABAB;
80003afc:	30 09       	mov	r9,0
80003afe:	fe f8 05 ea 	ld.w	r8,pc[1514]
80003b02:	91 09       	st.w	r8[0x0],r9
80003b04:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//5
80003b08:	fe f8 06 00 	ld.w	r8,pc[1536]
80003b0c:	fe f9 05 d8 	ld.w	r9,pc[1496]
80003b10:	72 0a       	ld.w	r10,r9[0x0]
80003b12:	70 09       	ld.w	r9,r8[0x0]
80003b14:	ef 3b 00 0e 	ld.ub	r11,r7[14]
80003b18:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003b1c:	70 09       	ld.w	r9,r8[0x0]
80003b1e:	2f f9       	sub	r9,-1
80003b20:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003b22:	e0 49 01 ff 	cp.w	r9,511
80003b26:	e0 88 00 16 	brls	80003b52 <phy_rx_func+0x926>
							{
								RxAMBE_IsFillingNext8 = 0;
80003b2a:	30 09       	mov	r9,0
80003b2c:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003b2e:	fe f6 05 b6 	ld.w	r6,pc[1462]
80003b32:	6c 0c       	ld.w	r12,r6[0x0]
80003b34:	f0 1f 01 77 	mcall	80004110 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003b38:	fe f8 05 a4 	ld.w	r8,pc[1444]
80003b3c:	70 0c       	ld.w	r12,r8[0x0]
80003b3e:	f0 1f 01 62 	mcall	800040c4 <phy_rx_func+0xe98>
80003b42:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003b44:	c0 71       	brne	80003b52 <phy_rx_func+0x926>
								{
									RxMediaState = WAITINGABAB;
80003b46:	30 09       	mov	r9,0
80003b48:	fe f8 05 a0 	ld.w	r8,pc[1440]
80003b4c:	91 09       	st.w	r8[0x0],r9
80003b4e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003b52:	fe f9 05 9e 	ld.w	r9,pc[1438]
80003b56:	72 08       	ld.w	r8,r9[0x0]
80003b58:	20 18       	sub	r8,1
80003b5a:	93 08       	st.w	r9[0x0],r8
80003b5c:	c0 71       	brne	80003b6a <phy_rx_func+0x93e>
								RxMediaState = WAITINGABAB;
80003b5e:	30 09       	mov	r9,0
80003b60:	fe f8 05 88 	ld.w	r8,pc[1416]
80003b64:	91 09       	st.w	r8[0x0],r9
80003b66:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//6
80003b6a:	fe f8 05 9e 	ld.w	r8,pc[1438]
80003b6e:	fe f9 05 76 	ld.w	r9,pc[1398]
80003b72:	72 0a       	ld.w	r10,r9[0x0]
80003b74:	70 09       	ld.w	r9,r8[0x0]
80003b76:	ef 3b 00 0f 	ld.ub	r11,r7[15]
80003b7a:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003b7e:	70 09       	ld.w	r9,r8[0x0]
80003b80:	2f f9       	sub	r9,-1
80003b82:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003b84:	e0 49 01 ff 	cp.w	r9,511
80003b88:	e0 88 00 16 	brls	80003bb4 <phy_rx_func+0x988>
							{
								RxAMBE_IsFillingNext8 = 0;
80003b8c:	30 09       	mov	r9,0
80003b8e:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003b90:	fe f7 05 54 	ld.w	r7,pc[1364]
80003b94:	6e 0c       	ld.w	r12,r7[0x0]
80003b96:	f0 1f 01 5f 	mcall	80004110 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003b9a:	fe f8 05 42 	ld.w	r8,pc[1346]
80003b9e:	70 0c       	ld.w	r12,r8[0x0]
80003ba0:	f0 1f 01 49 	mcall	800040c4 <phy_rx_func+0xe98>
80003ba4:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003ba6:	c0 71       	brne	80003bb4 <phy_rx_func+0x988>
								{
									RxMediaState = WAITINGABAB;
80003ba8:	30 09       	mov	r9,0
80003baa:	fe f8 05 3e 	ld.w	r8,pc[1342]
80003bae:	91 09       	st.w	r8[0x0],r9
80003bb0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003bb4:	fe f9 05 3c 	ld.w	r9,pc[1340]
80003bb8:	72 08       	ld.w	r8,r9[0x0]
80003bba:	20 18       	sub	r8,1
80003bbc:	93 08       	st.w	r9[0x0],r8
80003bbe:	e0 81 02 74 	brne	800040a6 <phy_rx_func+0xe7a>
								RxMediaState = WAITINGABAB;
80003bc2:	30 09       	mov	r9,0
80003bc4:	fe f8 05 24 	ld.w	r8,pc[1316]
80003bc8:	91 09       	st.w	r8[0x0],r9
80003bca:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							//}
							
						}
						else//error
						{
							RxMediaState = WAITINGABAB;
80003bce:	30 09       	mov	r9,0
80003bd0:	fe f8 05 18 	ld.w	r8,pc[1304]
80003bd4:	91 09       	st.w	r8[0x0],r9
80003bd6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
					}
					else if (Item_ID == Post_Voice_Encoder_Data)//(bit48~Pad-bits)
80003bda:	fe f8 05 26 	ld.w	r8,pc[1318]
80003bde:	11 89       	ld.ub	r9,r8[0x0]
80003be0:	3f 28       	mov	r8,-14
80003be2:	f0 09 18 00 	cp.b	r9,r8
80003be6:	c4 31       	brne	80003c6c <phy_rx_func+0xa40>
					{
					
						AMBEBurst_rawdata[3] = payload_rx_channel->word[0];//(bit48~Pad-bits)
80003be8:	8e 49       	ld.sh	r9,r7[0x8]
80003bea:	fe f8 05 56 	ld.w	r8,pc[1366]
80003bee:	b0 39       	st.h	r8[0x6],r9
						//AMBE_Per_Burst_Flag = 1;
						
						//根据MOTO.bit文件数据分布，建议测试pad-bits的最后一个字节不保存。
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//7
80003bf0:	fe f8 05 18 	ld.w	r8,pc[1304]
80003bf4:	fe f9 04 f0 	ld.w	r9,pc[1264]
80003bf8:	72 0a       	ld.w	r10,r9[0x0]
80003bfa:	70 09       	ld.w	r9,r8[0x0]
80003bfc:	ef 3b 00 08 	ld.ub	r11,r7[8]
80003c00:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003c04:	70 09       	ld.w	r9,r8[0x0]
80003c06:	2f f9       	sub	r9,-1
80003c08:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003c0a:	e0 49 01 ff 	cp.w	r9,511
80003c0e:	e0 88 00 16 	brls	80003c3a <phy_rx_func+0xa0e>
						{
							RxAMBE_IsFillingNext8 = 0;
80003c12:	30 09       	mov	r9,0
80003c14:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003c16:	fe f7 04 ce 	ld.w	r7,pc[1230]
80003c1a:	6e 0c       	ld.w	r12,r7[0x0]
80003c1c:	f0 1f 01 3d 	mcall	80004110 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003c20:	fe f8 04 bc 	ld.w	r8,pc[1212]
80003c24:	70 0c       	ld.w	r12,r8[0x0]
80003c26:	f0 1f 01 28 	mcall	800040c4 <phy_rx_func+0xe98>
80003c2a:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003c2c:	c0 71       	brne	80003c3a <phy_rx_func+0xa0e>
							{
								RxMediaState = WAITINGABAB;
80003c2e:	30 09       	mov	r9,0
80003c30:	fe f8 04 b8 	ld.w	r8,pc[1208]
80003c34:	91 09       	st.w	r8[0x0],r9
80003c36:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003c3a:	fe f9 04 b6 	ld.w	r9,pc[1206]
80003c3e:	72 08       	ld.w	r8,r9[0x0]
80003c40:	20 18       	sub	r8,1
80003c42:	93 08       	st.w	r9[0x0],r8
80003c44:	c0 71       	brne	80003c52 <phy_rx_func+0xa26>
							RxMediaState = WAITINGABAB;
80003c46:	30 09       	mov	r9,0
80003c48:	fe f8 04 a0 	ld.w	r8,pc[1184]
80003c4c:	91 09       	st.w	r8[0x0],r9
80003c4e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
						if ((RxBytesWaiting -= 1) <= 0){//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
80003c52:	20 18       	sub	r8,1
80003c54:	fe f9 04 9c 	ld.w	r9,pc[1180]
80003c58:	93 08       	st.w	r9[0x0],r8
80003c5a:	58 08       	cp.w	r8,0
80003c5c:	e0 81 02 25 	brne	800040a6 <phy_rx_func+0xe7a>
							RxMediaState = WAITINGABAB;
80003c60:	30 09       	mov	r9,0
80003c62:	fe f8 04 86 	ld.w	r8,pc[1158]
80003c66:	91 09       	st.w	r8[0x0],r9
80003c68:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
								
					}
					else if (Item_ID == Pre_Voice_Decoder_Data)//bit16~bit63
80003c6c:	fe f8 04 94 	ld.w	r8,pc[1172]
80003c70:	11 89       	ld.ub	r9,r8[0x0]
80003c72:	3f 38       	mov	r8,-13
80003c74:	f0 09 18 00 	cp.b	r9,r8
80003c78:	e0 81 01 0c 	brne	80003e90 <phy_rx_func+0xc64>
					{
						//接收方的解压类型数据
						//For looping back to Radio
						AMBEBurst_rawdata[1] = payload_rx_channel->word[0];
80003c7c:	8e 49       	ld.sh	r9,r7[0x8]
80003c7e:	fe f8 04 c2 	ld.w	r8,pc[1218]
80003c82:	b0 19       	st.h	r8[0x2],r9
						AMBEBurst_rawdata[2] = payload_rx_channel->word[1];
80003c84:	8e 59       	ld.sh	r9,r7[0xa]
80003c86:	b0 29       	st.h	r8[0x4],r9
						AMBEBurst_rawdata[3] = payload_rx_channel->word[2];
80003c88:	8e 69       	ld.sh	r9,r7[0xc]
80003c8a:	b0 39       	st.h	r8[0x6],r9
						//if((m_RxBurstType == VOICEBURST_A) && (VF_SN == 1))
						//logFromISR("\n\r Pre_rx:%X\n\r", payload_rx_channel->word[2]);
						
						//To be tested. Also locally stored RAW-AMBER-DATA
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//3
80003c8c:	fe f8 04 7c 	ld.w	r8,pc[1148]
80003c90:	fe f9 04 54 	ld.w	r9,pc[1108]
80003c94:	72 0a       	ld.w	r10,r9[0x0]
80003c96:	70 09       	ld.w	r9,r8[0x0]
80003c98:	ef 3b 00 08 	ld.ub	r11,r7[8]
80003c9c:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003ca0:	70 09       	ld.w	r9,r8[0x0]
80003ca2:	2f f9       	sub	r9,-1
80003ca4:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003ca6:	e0 49 01 ff 	cp.w	r9,511
80003caa:	e0 88 00 16 	brls	80003cd6 <phy_rx_func+0xaaa>
						{
							RxAMBE_IsFillingNext8 = 0;
80003cae:	30 09       	mov	r9,0
80003cb0:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003cb2:	fe f6 04 32 	ld.w	r6,pc[1074]
80003cb6:	6c 0c       	ld.w	r12,r6[0x0]
80003cb8:	f0 1f 01 16 	mcall	80004110 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003cbc:	fe f8 04 20 	ld.w	r8,pc[1056]
80003cc0:	70 0c       	ld.w	r12,r8[0x0]
80003cc2:	f0 1f 01 01 	mcall	800040c4 <phy_rx_func+0xe98>
80003cc6:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003cc8:	c0 71       	brne	80003cd6 <phy_rx_func+0xaaa>
							{
								RxMediaState = WAITINGABAB;
80003cca:	30 09       	mov	r9,0
80003ccc:	fe f8 04 1c 	ld.w	r8,pc[1052]
80003cd0:	91 09       	st.w	r8[0x0],r9
80003cd2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003cd6:	fe f9 04 1a 	ld.w	r9,pc[1050]
80003cda:	72 08       	ld.w	r8,r9[0x0]
80003cdc:	20 18       	sub	r8,1
80003cde:	93 08       	st.w	r9[0x0],r8
80003ce0:	c0 71       	brne	80003cee <phy_rx_func+0xac2>
							RxMediaState = WAITINGABAB;
80003ce2:	30 09       	mov	r9,0
80003ce4:	fe f8 04 04 	ld.w	r8,pc[1028]
80003ce8:	91 09       	st.w	r8[0x0],r9
80003cea:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[1];//4
80003cee:	fe f8 04 1a 	ld.w	r8,pc[1050]
80003cf2:	fe f9 03 f2 	ld.w	r9,pc[1010]
80003cf6:	72 0a       	ld.w	r10,r9[0x0]
80003cf8:	70 09       	ld.w	r9,r8[0x0]
80003cfa:	ef 3b 00 09 	ld.ub	r11,r7[9]
80003cfe:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003d02:	70 09       	ld.w	r9,r8[0x0]
80003d04:	2f f9       	sub	r9,-1
80003d06:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003d08:	e0 49 01 ff 	cp.w	r9,511
80003d0c:	e0 88 00 16 	brls	80003d38 <phy_rx_func+0xb0c>
						{
							RxAMBE_IsFillingNext8 = 0;
80003d10:	30 09       	mov	r9,0
80003d12:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003d14:	fe f6 03 d0 	ld.w	r6,pc[976]
80003d18:	6c 0c       	ld.w	r12,r6[0x0]
80003d1a:	f0 1f 00 fe 	mcall	80004110 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003d1e:	fe f8 03 be 	ld.w	r8,pc[958]
80003d22:	70 0c       	ld.w	r12,r8[0x0]
80003d24:	f0 1f 00 e8 	mcall	800040c4 <phy_rx_func+0xe98>
80003d28:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003d2a:	c0 71       	brne	80003d38 <phy_rx_func+0xb0c>
							{
								RxMediaState = WAITINGABAB;
80003d2c:	30 09       	mov	r9,0
80003d2e:	fe f8 03 ba 	ld.w	r8,pc[954]
80003d32:	91 09       	st.w	r8[0x0],r9
80003d34:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003d38:	fe f9 03 b8 	ld.w	r9,pc[952]
80003d3c:	72 08       	ld.w	r8,r9[0x0]
80003d3e:	20 18       	sub	r8,1
80003d40:	93 08       	st.w	r9[0x0],r8
80003d42:	c0 71       	brne	80003d50 <phy_rx_func+0xb24>
							RxMediaState = WAITINGABAB;
80003d44:	30 09       	mov	r9,0
80003d46:	fe f8 03 a2 	ld.w	r8,pc[930]
80003d4a:	91 09       	st.w	r8[0x0],r9
80003d4c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//5
80003d50:	fe f8 03 b8 	ld.w	r8,pc[952]
80003d54:	fe f9 03 90 	ld.w	r9,pc[912]
80003d58:	72 0a       	ld.w	r10,r9[0x0]
80003d5a:	70 09       	ld.w	r9,r8[0x0]
80003d5c:	ef 3b 00 0a 	ld.ub	r11,r7[10]
80003d60:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003d64:	70 09       	ld.w	r9,r8[0x0]
80003d66:	2f f9       	sub	r9,-1
80003d68:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003d6a:	e0 49 01 ff 	cp.w	r9,511
80003d6e:	e0 88 00 16 	brls	80003d9a <phy_rx_func+0xb6e>
						{
							RxAMBE_IsFillingNext8 = 0;
80003d72:	30 09       	mov	r9,0
80003d74:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003d76:	fe f6 03 6e 	ld.w	r6,pc[878]
80003d7a:	6c 0c       	ld.w	r12,r6[0x0]
80003d7c:	f0 1f 00 e5 	mcall	80004110 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003d80:	fe f8 03 5c 	ld.w	r8,pc[860]
80003d84:	70 0c       	ld.w	r12,r8[0x0]
80003d86:	f0 1f 00 d0 	mcall	800040c4 <phy_rx_func+0xe98>
80003d8a:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003d8c:	c0 71       	brne	80003d9a <phy_rx_func+0xb6e>
							{
								RxMediaState = WAITINGABAB;
80003d8e:	30 09       	mov	r9,0
80003d90:	fe f8 03 58 	ld.w	r8,pc[856]
80003d94:	91 09       	st.w	r8[0x0],r9
80003d96:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003d9a:	fe f9 03 56 	ld.w	r9,pc[854]
80003d9e:	72 08       	ld.w	r8,r9[0x0]
80003da0:	20 18       	sub	r8,1
80003da2:	93 08       	st.w	r9[0x0],r8
80003da4:	c0 71       	brne	80003db2 <phy_rx_func+0xb86>
							RxMediaState = WAITINGABAB;
80003da6:	30 09       	mov	r9,0
80003da8:	fe f8 03 40 	ld.w	r8,pc[832]
80003dac:	91 09       	st.w	r8[0x0],r9
80003dae:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//6
80003db2:	fe f8 03 56 	ld.w	r8,pc[854]
80003db6:	fe f9 03 2e 	ld.w	r9,pc[814]
80003dba:	72 0a       	ld.w	r10,r9[0x0]
80003dbc:	70 09       	ld.w	r9,r8[0x0]
80003dbe:	ef 3b 00 0b 	ld.ub	r11,r7[11]
80003dc2:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003dc6:	70 09       	ld.w	r9,r8[0x0]
80003dc8:	2f f9       	sub	r9,-1
80003dca:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003dcc:	e0 49 01 ff 	cp.w	r9,511
80003dd0:	e0 88 00 16 	brls	80003dfc <phy_rx_func+0xbd0>
						{
							RxAMBE_IsFillingNext8 = 0;
80003dd4:	30 09       	mov	r9,0
80003dd6:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003dd8:	fe f6 03 0c 	ld.w	r6,pc[780]
80003ddc:	6c 0c       	ld.w	r12,r6[0x0]
80003dde:	f0 1f 00 cd 	mcall	80004110 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003de2:	fe f8 02 fa 	ld.w	r8,pc[762]
80003de6:	70 0c       	ld.w	r12,r8[0x0]
80003de8:	f0 1f 00 b7 	mcall	800040c4 <phy_rx_func+0xe98>
80003dec:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003dee:	c0 71       	brne	80003dfc <phy_rx_func+0xbd0>
							{
								RxMediaState = WAITINGABAB;
80003df0:	30 09       	mov	r9,0
80003df2:	fe f8 02 f6 	ld.w	r8,pc[758]
80003df6:	91 09       	st.w	r8[0x0],r9
80003df8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003dfc:	fe f9 02 f4 	ld.w	r9,pc[756]
80003e00:	72 08       	ld.w	r8,r9[0x0]
80003e02:	20 18       	sub	r8,1
80003e04:	93 08       	st.w	r9[0x0],r8
80003e06:	c0 71       	brne	80003e14 <phy_rx_func+0xbe8>
							RxMediaState = WAITINGABAB;
80003e08:	30 09       	mov	r9,0
80003e0a:	fe f8 02 de 	ld.w	r8,pc[734]
80003e0e:	91 09       	st.w	r8[0x0],r9
80003e10:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//7
80003e14:	fe f8 02 f4 	ld.w	r8,pc[756]
80003e18:	fe f9 02 cc 	ld.w	r9,pc[716]
80003e1c:	72 0a       	ld.w	r10,r9[0x0]
80003e1e:	70 09       	ld.w	r9,r8[0x0]
80003e20:	ef 3b 00 0c 	ld.ub	r11,r7[12]
80003e24:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003e28:	70 09       	ld.w	r9,r8[0x0]
80003e2a:	2f f9       	sub	r9,-1
80003e2c:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003e2e:	e0 49 01 ff 	cp.w	r9,511
80003e32:	e0 88 00 16 	brls	80003e5e <phy_rx_func+0xc32>
						{
							RxAMBE_IsFillingNext8 = 0;
80003e36:	30 09       	mov	r9,0
80003e38:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003e3a:	fe f7 02 aa 	ld.w	r7,pc[682]
80003e3e:	6e 0c       	ld.w	r12,r7[0x0]
80003e40:	f0 1f 00 b4 	mcall	80004110 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003e44:	fe f8 02 98 	ld.w	r8,pc[664]
80003e48:	70 0c       	ld.w	r12,r8[0x0]
80003e4a:	f0 1f 00 9f 	mcall	800040c4 <phy_rx_func+0xe98>
80003e4e:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003e50:	c0 71       	brne	80003e5e <phy_rx_func+0xc32>
							{
								RxMediaState = WAITINGABAB;
80003e52:	30 09       	mov	r9,0
80003e54:	fe f8 02 94 	ld.w	r8,pc[660]
80003e58:	91 09       	st.w	r8[0x0],r9
80003e5a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003e5e:	fe f9 02 92 	ld.w	r9,pc[658]
80003e62:	72 08       	ld.w	r8,r9[0x0]
80003e64:	20 18       	sub	r8,1
80003e66:	93 08       	st.w	r9[0x0],r8
80003e68:	c0 71       	brne	80003e76 <phy_rx_func+0xc4a>
							RxMediaState = WAITINGABAB;
80003e6a:	30 09       	mov	r9,0
80003e6c:	fe f8 02 7c 	ld.w	r8,pc[636]
80003e70:	91 09       	st.w	r8[0x0],r9
80003e72:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
						if ((RxBytesWaiting -= 1) <= 0){
80003e76:	20 18       	sub	r8,1
80003e78:	fe f9 02 78 	ld.w	r9,pc[632]
80003e7c:	93 08       	st.w	r9[0x0],r8
80003e7e:	58 08       	cp.w	r8,0
80003e80:	e0 81 01 13 	brne	800040a6 <phy_rx_func+0xe7a>
							
							//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
							//or discard it to reduce payload size.
							
							RxMediaState = WAITINGABAB;
80003e84:	30 09       	mov	r9,0
80003e86:	fe f8 02 62 	ld.w	r8,pc[610]
80003e8a:	91 09       	st.w	r8[0x0],r9
80003e8c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
					}
					else if ((Item_ID == 0x04)  ||  (Item_ID == 0x03))//Unknown type data directly back hair
80003e90:	fe f8 02 70 	ld.w	r8,pc[624]
80003e94:	11 89       	ld.ub	r9,r8[0x0]
80003e96:	30 48       	mov	r8,4
80003e98:	f0 09 18 00 	cp.b	r9,r8
80003e9c:	c0 80       	breq	80003eac <phy_rx_func+0xc80>
80003e9e:	fe f8 02 62 	ld.w	r8,pc[610]
80003ea2:	11 89       	ld.ub	r9,r8[0x0]
80003ea4:	30 38       	mov	r8,3
80003ea6:	f0 09 18 00 	cp.b	r9,r8
80003eaa:	c1 41       	brne	80003ed2 <phy_rx_func+0xca6>
					{
						AMBE_HT[0] = payload_rx_channel->dword[0];
80003eac:	6e 29       	ld.w	r9,r7[0x8]
80003eae:	fe f8 02 7a 	ld.w	r8,pc[634]
80003eb2:	91 09       	st.w	r8[0x0],r9
						AMBE_HT[1] = payload_rx_channel->dword[1];				
80003eb4:	6e 39       	ld.w	r9,r7[0xc]
80003eb6:	91 19       	st.w	r8[0x4],r9
						
						if ((RxBytesWaiting -= 8) <= 0)//Consider two cases 0xABCDC014 and 0xABCDC010
80003eb8:	fe f9 02 38 	ld.w	r9,pc[568]
80003ebc:	72 08       	ld.w	r8,r9[0x0]
80003ebe:	20 88       	sub	r8,8
80003ec0:	93 08       	st.w	r9[0x0],r8
80003ec2:	e0 81 00 f2 	brne	800040a6 <phy_rx_func+0xe7a>
						{
					
							RxBytesWaiting = 0;
80003ec6:	93 08       	st.w	r9[0x0],r8
							RxMediaState = WAITINGABAB;
80003ec8:	fe f9 02 20 	ld.w	r9,pc[544]
80003ecc:	93 08       	st.w	r9[0x0],r8
80003ece:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
						}
						break;

					}
					else if (Item_ID == Soft_Decision_Value)
80003ed2:	fe f8 02 2e 	ld.w	r8,pc[558]
80003ed6:	11 89       	ld.ub	r9,r8[0x0]
80003ed8:	31 38       	mov	r8,19
80003eda:	f0 09 18 00 	cp.b	r9,r8
80003ede:	e0 81 00 9c 	brne	80004016 <phy_rx_func+0xdea>
					{							
						if (SDV_Index == 12)
80003ee2:	fe f8 02 62 	ld.w	r8,pc[610]
80003ee6:	11 88       	ld.ub	r8,r8[0x0]
80003ee8:	30 c9       	mov	r9,12
80003eea:	f2 08 18 00 	cp.b	r8,r9
80003eee:	e0 81 00 7b 	brne	80003fe4 <phy_rx_func+0xdb8>
						{
							Soft_Decision_Data[SDV_Index]= payload_rx_channel->word[0];
80003ef2:	8e 49       	ld.sh	r9,r7[0x8]
80003ef4:	fe f8 02 54 	ld.w	r8,pc[596]
80003ef8:	f1 59 00 18 	st.h	r8[24],r9
							
							SDV_Index = 0;
80003efc:	30 09       	mov	r9,0
80003efe:	fe f8 02 46 	ld.w	r8,pc[582]
80003f02:	b0 89       	st.b	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003f04:	ef 39 00 0d 	ld.ub	r9,r7[13]
80003f08:	3f 38       	mov	r8,-13
80003f0a:	f0 09 18 00 	cp.b	r9,r8
80003f0e:	c6 61       	brne	80003fda <phy_rx_func+0xdae>
							
							SDV_Index = 0;
								
							if (payload_rx_channel->byte[5] == Pre_Voice_Decoder_Data )//0xF3
							{
									Item_ID = Pre_Voice_Decoder_Data;
80003f10:	10 99       	mov	r9,r8
80003f12:	4f c8       	lddpc	r8,80004100 <phy_rx_func+0xed4>
80003f14:	b0 89       	st.b	r8[0x0],r9
									RxBytesWaiting = (payload_rx_channel->byte[4] & 0x7F);//Test calculations are correct; 8
80003f16:	ef 39 00 0c 	ld.ub	r9,r7[12]
80003f1a:	f3 d9 c0 07 	bfextu	r9,r9,0x0,0x7
80003f1e:	4f 58       	lddpc	r8,800040f0 <phy_rx_func+0xec4>
80003f20:	91 09       	st.w	r8[0x0],r9
									AMBE_rx_flag = 1;//本地作为AMBE数据的解密方
80003f22:	30 19       	mov	r9,1
80003f24:	fe f8 02 0c 	ld.w	r8,pc[524]
80003f28:	b0 89       	st.b	r8[0x0],r9
		
									AMBEBurst_rawdata[0] = payload_rx_channel->word[3];//用于解密的中间数据变量
80003f2a:	8e 79       	ld.sh	r9,r7[0xe]
80003f2c:	fe f8 02 14 	ld.w	r8,pc[532]
80003f30:	b0 09       	st.h	r8[0x0],r9
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//1
80003f32:	4f 68       	lddpc	r8,80004108 <phy_rx_func+0xedc>
80003f34:	4e c9       	lddpc	r9,800040e4 <phy_rx_func+0xeb8>
80003f36:	72 0a       	ld.w	r10,r9[0x0]
80003f38:	70 09       	ld.w	r9,r8[0x0]
80003f3a:	ef 3b 00 0e 	ld.ub	r11,r7[14]
80003f3e:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
80003f42:	70 09       	ld.w	r9,r8[0x0]
80003f44:	2f f9       	sub	r9,-1
80003f46:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003f48:	e0 49 01 ff 	cp.w	r9,511
80003f4c:	e0 88 00 13 	brls	80003f72 <phy_rx_func+0xd46>
									{
										RxAMBE_IsFillingNext8 = 0;
80003f50:	30 09       	mov	r9,0
80003f52:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
80003f54:	4e 46       	lddpc	r6,800040e4 <phy_rx_func+0xeb8>
80003f56:	6c 0c       	ld.w	r12,r6[0x0]
80003f58:	f0 1f 00 6e 	mcall	80004110 <phy_rx_func+0xee4>
										AMBE_payload_ptr = get_payload_idle_isr();
80003f5c:	4e 08       	lddpc	r8,800040dc <phy_rx_func+0xeb0>
80003f5e:	70 0c       	ld.w	r12,r8[0x0]
80003f60:	f0 1f 00 59 	mcall	800040c4 <phy_rx_func+0xe98>
80003f64:	8d 0c       	st.w	r6[0x0],r12
										if(NULL == AMBE_payload_ptr)
80003f66:	c0 61       	brne	80003f72 <phy_rx_func+0xd46>
										{
											RxMediaState = WAITINGABAB;
80003f68:	30 09       	mov	r9,0
80003f6a:	4e 08       	lddpc	r8,800040e8 <phy_rx_func+0xebc>
80003f6c:	91 09       	st.w	r8[0x0],r9
80003f6e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
80003f72:	4e 09       	lddpc	r9,800040f0 <phy_rx_func+0xec4>
80003f74:	72 08       	ld.w	r8,r9[0x0]
80003f76:	20 18       	sub	r8,1
80003f78:	93 08       	st.w	r9[0x0],r8
80003f7a:	c0 61       	brne	80003f86 <phy_rx_func+0xd5a>
										RxMediaState = WAITINGABAB;
80003f7c:	30 09       	mov	r9,0
80003f7e:	4d b8       	lddpc	r8,800040e8 <phy_rx_func+0xebc>
80003f80:	91 09       	st.w	r8[0x0],r9
80003f82:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//2
80003f86:	4e 18       	lddpc	r8,80004108 <phy_rx_func+0xedc>
80003f88:	4d 79       	lddpc	r9,800040e4 <phy_rx_func+0xeb8>
80003f8a:	72 0a       	ld.w	r10,r9[0x0]
80003f8c:	70 09       	ld.w	r9,r8[0x0]
80003f8e:	ef 3b 00 0f 	ld.ub	r11,r7[15]
80003f92:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
80003f96:	70 09       	ld.w	r9,r8[0x0]
80003f98:	2f f9       	sub	r9,-1
80003f9a:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003f9c:	e0 49 01 ff 	cp.w	r9,511
80003fa0:	e0 88 00 13 	brls	80003fc6 <phy_rx_func+0xd9a>
									{
										RxAMBE_IsFillingNext8 = 0;
80003fa4:	30 09       	mov	r9,0
80003fa6:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
80003fa8:	4c f7       	lddpc	r7,800040e4 <phy_rx_func+0xeb8>
80003faa:	6e 0c       	ld.w	r12,r7[0x0]
80003fac:	f0 1f 00 59 	mcall	80004110 <phy_rx_func+0xee4>
										AMBE_payload_ptr = get_payload_idle_isr();
80003fb0:	4c b8       	lddpc	r8,800040dc <phy_rx_func+0xeb0>
80003fb2:	70 0c       	ld.w	r12,r8[0x0]
80003fb4:	f0 1f 00 44 	mcall	800040c4 <phy_rx_func+0xe98>
80003fb8:	8f 0c       	st.w	r7[0x0],r12
										if(NULL == AMBE_payload_ptr)
80003fba:	c0 61       	brne	80003fc6 <phy_rx_func+0xd9a>
										{
											RxMediaState = WAITINGABAB;
80003fbc:	30 09       	mov	r9,0
80003fbe:	4c b8       	lddpc	r8,800040e8 <phy_rx_func+0xebc>
80003fc0:	91 09       	st.w	r8[0x0],r9
80003fc2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
80003fc6:	4c b9       	lddpc	r9,800040f0 <phy_rx_func+0xec4>
80003fc8:	72 08       	ld.w	r8,r9[0x0]
80003fca:	20 18       	sub	r8,1
80003fcc:	93 08       	st.w	r9[0x0],r8
80003fce:	c6 c1       	brne	800040a6 <phy_rx_func+0xe7a>
										RxMediaState = WAITINGABAB;
80003fd0:	30 09       	mov	r9,0
80003fd2:	4c 68       	lddpc	r8,800040e8 <phy_rx_func+0xebc>
80003fd4:	91 09       	st.w	r8[0x0],r9
80003fd6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
							}
							else
							RxMediaState = WAITINGABAB;
80003fda:	30 09       	mov	r9,0
80003fdc:	4c 38       	lddpc	r8,800040e8 <phy_rx_func+0xebc>
80003fde:	91 09       	st.w	r8[0x0],r9
80003fe0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
						}
						else
						{
									
							Soft_Decision_Data[SDV_Index]	  = payload_rx_channel->word[0];
80003fe4:	8e 4a       	ld.sh	r10,r7[0x8]
80003fe6:	4d 99       	lddpc	r9,80004148 <phy_rx_func+0xf1c>
80003fe8:	f2 08 0a 1a 	st.h	r9[r8<<0x1],r10
							Soft_Decision_Data[SDV_Index+1]	  = payload_rx_channel->word[1];
80003fec:	4d 6a       	lddpc	r10,80004144 <phy_rx_func+0xf18>
80003fee:	15 88       	ld.ub	r8,r10[0x0]
80003ff0:	f0 cb ff ff 	sub	r11,r8,-1
80003ff4:	8e 5c       	ld.sh	r12,r7[0xa]
80003ff6:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+2]	  = payload_rx_channel->word[2];
80003ffa:	f0 cb ff fe 	sub	r11,r8,-2
80003ffe:	8e 6c       	ld.sh	r12,r7[0xc]
80004000:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+3]	  = payload_rx_channel->word[3];
80004004:	f0 cb ff fd 	sub	r11,r8,-3
80004008:	8e 7c       	ld.sh	r12,r7[0xe]
8000400a:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							SDV_Index +=4;
8000400e:	2f c8       	sub	r8,-4
80004010:	b4 88       	st.b	r10[0x0],r8
80004012:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					
					else
					{
						
						RxMediaState  = WAITINGABAB;
80004016:	30 09       	mov	r9,0
80004018:	4b 48       	lddpc	r8,800040e8 <phy_rx_func+0xebc>
8000401a:	91 09       	st.w	r8[0x0],r9
8000401c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
		break;//End of READING_AMBE_MEDIA.

        case READING_AMBE_AUX:
			
				Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[0];
80004020:	4c 08       	lddpc	r8,80004120 <phy_rx_func+0xef4>
80004022:	70 09       	ld.w	r9,r8[0x0]
80004024:	8e 4b       	ld.sh	r11,r7[0x8]
80004026:	4c 0a       	lddpc	r10,80004124 <phy_rx_func+0xef8>
80004028:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
				RxData_IsFillingNext16 += 1;
8000402c:	2f f9       	sub	r9,-1
8000402e:	91 09       	st.w	r8[0x0],r9
			
				if ((Item_Length -= 2) <= 0)
80004030:	4b 58       	lddpc	r8,80004104 <phy_rx_func+0xed8>
80004032:	70 09       	ld.w	r9,r8[0x0]
80004034:	20 29       	sub	r9,2
80004036:	91 09       	st.w	r8[0x0],r9
80004038:	70 08       	ld.w	r8,r8[0x0]
8000403a:	58 08       	cp.w	r8,0
8000403c:	c2 f1       	brne	8000409a <phy_rx_func+0xe6e>
				{
					RxData_IsFillingNext16 = 0;
8000403e:	30 09       	mov	r9,0
80004040:	4b 88       	lddpc	r8,80004120 <phy_rx_func+0xef4>
80004042:	91 09       	st.w	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80004044:	8e 59       	ld.sh	r9,r7[0xa]
80004046:	fe 78 82 12 	mov	r8,-32238
8000404a:	f0 09 19 00 	cp.h	r9,r8
8000404e:	c2 11       	brne	80004090 <phy_rx_func+0xe64>
					{
						//Item_ID = Vocoder_Bit_Stream_Parameter;
						//Vocoder Bits Stream Parameter
						//Its value ranges from 1 to 18 for one voice superframe contains 6 voice bursts
						// and each burst contains 3 VFs.
						VF_SN = (payload_rx_channel->byte[5] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
80004050:	ef 3c 00 0d 	ld.ub	r12,r7[13]
80004054:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
80004058:	4a f8       	lddpc	r8,80004114 <phy_rx_func+0xee8>
8000405a:	b0 8c       	st.b	r8[0x0],r12
							
						VBSP_data[0] = payload_rx_channel->word[1];
8000405c:	8e 59       	ld.sh	r9,r7[0xa]
8000405e:	4a f8       	lddpc	r8,80004118 <phy_rx_func+0xeec>
80004060:	b0 09       	st.h	r8[0x0],r9
						VBSP_data[1] = payload_rx_channel->word[2];
80004062:	8e 69       	ld.sh	r9,r7[0xc]
80004064:	b0 19       	st.h	r8[0x2],r9
							
						m_RxBurstType = CalculateBurst(VF_SN);
80004066:	f0 1f 00 2e 	mcall	8000411c <phy_rx_func+0xef0>
8000406a:	4a 18       	lddpc	r8,800040ec <phy_rx_func+0xec0>
8000406c:	91 0c       	st.w	r8[0x0],r12
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
8000406e:	ef 39 00 0f 	ld.ub	r9,r7[15]
80004072:	31 38       	mov	r8,19
80004074:	f0 09 18 00 	cp.b	r9,r8
80004078:	c0 71       	brne	80004086 <phy_rx_func+0xe5a>
							
						m_RxBurstType = CalculateBurst(VF_SN);
						
						if (payload_rx_channel->byte[7] == Soft_Decision_Value)//0x13
						{
							Item_ID = Soft_Decision_Value;	
8000407a:	10 99       	mov	r9,r8
8000407c:	4a 18       	lddpc	r8,80004100 <phy_rx_func+0xed4>
8000407e:	b0 89       	st.b	r8[0x0],r9
							RxBytesWaiting = ((payload_rx_channel->dword[1] & 0x00007F00) >>24);//Test calculations are correct; 26
80004080:	30 09       	mov	r9,0
80004082:	49 c8       	lddpc	r8,800040f0 <phy_rx_func+0xec4>
80004084:	91 09       	st.w	r8[0x0],r9
						else
						{//error
								RxMediaState = WAITINGABAB;//Jump
						}
							
						RxMediaState = READING_AMBE_MEDIA;//Jump
80004086:	30 49       	mov	r9,4
80004088:	49 88       	lddpc	r8,800040e8 <phy_rx_func+0xebc>
8000408a:	91 09       	st.w	r8[0x0],r9
8000408c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					else
					{
						RxMediaState = WAITINGABAB;//Jump
80004090:	30 09       	mov	r9,0
80004092:	49 68       	lddpc	r8,800040e8 <phy_rx_func+0xebc>
80004094:	91 09       	st.w	r8[0x0],r9
80004096:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}

				}
				else
				{//测试看看是几个字节数据
					logFromISR("\n\r Radio Internal parameter length error \n\r");
8000409a:	4a dc       	lddpc	r12,8000414c <phy_rx_func+0xf20>
8000409c:	f0 1f 00 18 	mcall	800040fc <phy_rx_func+0xed0>
					RxMediaState = WAITINGABAB;//Jump
800040a0:	30 09       	mov	r9,0
800040a2:	49 28       	lddpc	r8,800040e8 <phy_rx_func+0xebc>
800040a4:	91 09       	st.w	r8[0x0],r9
800040a6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800040aa:	00 00       	add	r0,r0
800040ac:	00 00       	add	r0,r0
800040ae:	0a bc       	st.h	r5++,r12
800040b0:	00 00       	add	r0,r0
800040b2:	0a c0       	st.b	r5++,r0
800040b4:	00 00       	add	r0,r0
800040b6:	0a a4       	st.w	r5++,r4
800040b8:	00 00       	add	r0,r0
800040ba:	0a 80       	andn	r0,r5
800040bc:	00 00       	add	r0,r0
800040be:	0a 78       	tst	r8,r5
800040c0:	00 00       	add	r0,r0
800040c2:	0a b8       	st.h	r5++,r8
800040c4:	80 00       	ld.sh	r0,r0[0x0]
800040c6:	30 4c       	mov	r12,4
800040c8:	00 00       	add	r0,r0
800040ca:	0a 8c       	andn	r12,r5
800040cc:	80 00       	ld.sh	r0,r0[0x0]
800040ce:	2f 7c       	sub	r12,-9
800040d0:	00 00       	add	r0,r0
800040d2:	0a 70       	tst	r0,r5
800040d4:	80 00       	ld.sh	r0,r0[0x0]
800040d6:	2f 98       	sub	r8,-7
800040d8:	00 00       	add	r0,r0
800040da:	0a 89       	andn	r9,r5
800040dc:	00 00       	add	r0,r0
800040de:	0a 74       	tst	r4,r5
800040e0:	00 00       	add	r0,r0
800040e2:	0a a0       	st.w	r5++,r0
800040e4:	00 00       	add	r0,r0
800040e6:	0a 98       	mov	r8,r5
800040e8:	00 00       	add	r0,r0
800040ea:	0a d4       	st.w	--r5,r4
800040ec:	00 00       	add	r0,r0
800040ee:	0a 6c       	and	r12,r5
800040f0:	00 00       	add	r0,r0
800040f2:	0a 7c       	tst	r12,r5
800040f4:	00 00       	add	r0,r0
800040f6:	0a 4a       	or	r10,r5
800040f8:	80 00       	ld.sh	r0,r0[0x0]
800040fa:	cf 3c       	rcall	800042e0 <ssc_init+0x58>
800040fc:	80 00       	ld.sh	r0,r0[0x0]
800040fe:	68 a0       	ld.w	r0,r4[0x28]
80004100:	00 00       	add	r0,r0
80004102:	0a 88       	andn	r8,r5
80004104:	00 00       	add	r0,r0
80004106:	0a 94       	mov	r4,r5
80004108:	00 00       	add	r0,r0
8000410a:	0a a8       	st.w	r5++,r8
8000410c:	80 00       	ld.sh	r0,r0[0x0]
8000410e:	70 fa       	ld.w	r10,r8[0x3c]
80004110:	80 00       	ld.sh	r0,r0[0x0]
80004112:	31 cc       	mov	r12,28
80004114:	00 00       	add	r0,r0
80004116:	0a 42       	or	r2,r5
80004118:	00 00       	add	r0,r0
8000411a:	1e 90       	mov	r0,pc
8000411c:	80 00       	ld.sh	r0,r0[0x0]
8000411e:	2e dc       	sub	r12,-19
80004120:	00 00       	add	r0,r0
80004122:	0a c4       	st.b	r5++,r4
80004124:	00 00       	add	r0,r0
80004126:	1d 94       	ld.ub	r4,lr[0x1]
80004128:	00 00       	add	r0,r0
8000412a:	0a d8       	st.w	--r5,r8
8000412c:	00 00       	add	r0,r0
8000412e:	0a 4d       	or	sp,r5
80004130:	00 00       	add	r0,r0
80004132:	0a 41       	or	r1,r5
80004134:	00 00       	add	r0,r0
80004136:	0a b4       	st.h	r5++,r4
80004138:	00 00       	add	r0,r0
8000413a:	0a 9c       	mov	r12,r5
8000413c:	00 00       	add	r0,r0
8000413e:	0a 54       	eor	r4,r5
80004140:	00 00       	add	r0,r0
80004142:	1d 8c       	ld.ub	r12,lr[0x0]
80004144:	00 00       	add	r0,r0
80004146:	0a cc       	st.b	r5++,r12
80004148:	00 00       	add	r0,r0
8000414a:	1e 94       	mov	r4,pc
8000414c:	80 00       	ld.sh	r0,r0[0x0]
8000414e:	cf 54       	brge	80004138 <phy_rx_func+0xf0c>

80004150 <pdca_int_handler>:
    void (*phy_rx_exec)(void *)--callback function for receive SSC data 
Called By: interrupt
*/
__attribute__((__interrupt__))
static void pdca_int_handler(void)
{
80004150:	d4 01       	pushm	lr
    
	//intStartCount = Get_system_register(AVR32_COUNT);
	
	/*Toggle Index*/
    BufferIndex ^= 0x01;
80004152:	49 88       	lddpc	r8,800041b0 <pdca_int_handler+0x60>
80004154:	11 89       	ld.ub	r9,r8[0x0]
80004156:	ec 19 00 01 	eorl	r9,0x1
8000415a:	b0 89       	st.b	r8[0x0],r9
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);
8000415c:	11 89       	ld.ub	r9,r8[0x0]
8000415e:	a5 69       	lsl	r9,0x4
80004160:	2f c9       	sub	r9,-4
80004162:	49 5a       	lddpc	r10,800041b4 <pdca_int_handler+0x64>
80004164:	14 09       	add	r9,r10
	
	/*Toggle Index*/
    BufferIndex ^= 0x01;
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
80004166:	fe 7a 00 40 	mov	r10,-65472
8000416a:	95 39       	st.w	r10[0xc],r9
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
8000416c:	30 39       	mov	r9,3
8000416e:	95 49       	st.w	r10[0x10],r9

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);
80004170:	11 8a       	ld.ub	r10,r8[0x0]
80004172:	a5 6a       	lsl	r10,0x4
80004174:	2f ca       	sub	r10,-4
80004176:	49 18       	lddpc	r8,800041b8 <pdca_int_handler+0x68>
80004178:	10 0a       	add	r10,r8
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
8000417a:	fe 78 00 00 	mov	r8,-65536
8000417e:	91 3a       	st.w	r8[0xc],r10
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80004180:	91 49       	st.w	r8[0x10],r9
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr;
80004182:	70 b8       	ld.w	r8,r8[0x2c]
	
	/*receive SSC data*/
    if(phy_rx_exec != NULL)phy_rx_exec((void *)&RxBuffer[BufferIndex]);
80004184:	48 e8       	lddpc	r8,800041bc <pdca_int_handler+0x6c>
80004186:	70 08       	ld.w	r8,r8[0x0]
80004188:	58 08       	cp.w	r8,0
8000418a:	c0 70       	breq	80004198 <pdca_int_handler+0x48>
8000418c:	48 99       	lddpc	r9,800041b0 <pdca_int_handler+0x60>
8000418e:	13 89       	ld.ub	r9,r9[0x0]
80004190:	a5 69       	lsl	r9,0x4
80004192:	48 ac       	lddpc	r12,800041b8 <pdca_int_handler+0x68>
80004194:	12 0c       	add	r12,r9
80004196:	5d 18       	icall	r8

    /*transmit SSC data*/

	if(phy_tx_exec != NULL)phy_tx_exec((void *)&TxBuffer[BufferIndex]);//phy_tx_func, phy_rx_func
80004198:	48 a8       	lddpc	r8,800041c0 <pdca_int_handler+0x70>
8000419a:	70 08       	ld.w	r8,r8[0x0]
8000419c:	58 08       	cp.w	r8,0
8000419e:	c0 70       	breq	800041ac <pdca_int_handler+0x5c>
800041a0:	48 49       	lddpc	r9,800041b0 <pdca_int_handler+0x60>
800041a2:	13 89       	ld.ub	r9,r9[0x0]
800041a4:	a5 69       	lsl	r9,0x4
800041a6:	48 4c       	lddpc	r12,800041b4 <pdca_int_handler+0x64>
800041a8:	12 0c       	add	r12,r9
800041aa:	5d 18       	icall	r8

	
	//intDuration = Get_system_register(AVR32_COUNT) - intStartCount;
	
	
}/*End of pdca_int_handler.*/
800041ac:	d4 02       	popm	lr
800041ae:	d6 03       	rete
800041b0:	00 00       	add	r0,r0
800041b2:	50 b4       	stdsp	sp[0x2c],r4
800041b4:	00 00       	add	r0,r0
800041b6:	50 dc       	stdsp	sp[0x34],r12
800041b8:	00 00       	add	r0,r0
800041ba:	50 bc       	stdsp	sp[0x2c],r12
800041bc:	00 00       	add	r0,r0
800041be:	0a e0       	st.h	--r5,r0
800041c0:	00 00       	add	r0,r0
800041c2:	0a e4       	st.h	--r5,r4

800041c4 <local_start_SSC>:
void local_start_SSC(void)
{
    /*Assign GPIO to SSC.
    gpio_enable_module
    gpio_enable_module_pin*/
    AVR32_GPIO.port[1].pmr0c = 0x00000DC0;
800041c4:	fe 78 10 00 	mov	r8,-61440
800041c8:	e0 69 0d c0 	mov	r9,3520
800041cc:	f1 49 01 18 	st.w	r8[280],r9
    AVR32_GPIO.port[1].pmr1c = 0x00000DC0;
800041d0:	f1 49 01 28 	st.w	r8[296],r9
    AVR32_GPIO.port[1].gperc = 0x00000DC0;
800041d4:	f1 49 01 08 	st.w	r8[264],r9

    /*Software reset SSC*/
    (&AVR32_SSC)->cr = AVR32_SSC_CR_SWRST_MASK;
800041d8:	fe 78 34 00 	mov	r8,-52224
800041dc:	e0 69 80 00 	mov	r9,32768
800041e0:	91 09       	st.w	r8[0x0],r9
    (&AVR32_SSC)->cmr 
800041e2:	30 09       	mov	r9,0
800041e4:	91 19       	st.w	r8[0x4],r9
                     = AVR32_SSC_CMR_DIV_NOT_ACTIVE << AVR32_SSC_CMR_DIV_OFFSET;

    /*For Slave*/
    (&AVR32_SSC)->tcmr =
800041e6:	e0 69 04 21 	mov	r9,1057
800041ea:	ea 19 3f 20 	orh	r9,0x3f20
800041ee:	91 69       	st.w	r8[0x18],r9
	      32								<< AVR32_SSC_TCMR_STTDLY_OFFSET	|
	      63								<< AVR32_SSC_TCMR_PERIOD_OFFSET;


    /*For Slave*/
    (&AVR32_SSC)->tfmr = 
800041f0:	e0 69 02 9f 	mov	r9,671
800041f4:	ea 19 01 00 	orh	r9,0x100
800041f8:	91 79       	st.w	r8[0x1c],r9
	     0									<< AVR32_SSC_TFMR_FSDEN_OFFSET	|
	     1									<< AVR32_SSC_TFMR_FSEDGE_OFFSET;

	/*For Slave*/

	(&AVR32_SSC)->rcmr = 
800041fa:	e0 6a 04 02 	mov	r10,1026
800041fe:	ea 1a 3f 20 	orh	r10,0x3f20
80004202:	91 4a       	st.w	r8[0x10],r10
	     0									<< AVR32_SSC_RCMR_STOP_OFFSET	|
	     32									<< AVR32_SSC_RCMR_STTDLY_OFFSET	|
	     63									<< AVR32_SSC_RCMR_PERIOD_OFFSET;

	/*For Slave*/
	(&AVR32_SSC)->rfmr = 
80004204:	91 59       	st.w	r8[0x14],r9
	    1									<< AVR32_SSC_RFMR_MSBF_OFFSET	|
	    2									<< AVR32_SSC_RFMR_DATNB_OFFSET	|
	    0									<< AVR32_SSC_RFMR_FSLEN_OFFSET	|
	    AVR32_SSC_RFMR_FSOS_INPUT_ONLY		<< AVR32_SSC_RFMR_FSOS_OFFSET	|
	    1									<< AVR32_SSC_RFMR_FSEDGE_OFFSET;
}/*End of local_start_SSC.*/
80004206:	5e fc       	retal	r12

80004208 <local_start_PDC>:
Function: local_start_PDC
Description: none
Called By: void ssc_init(void) -- ssc.c
*/
void local_start_PDC(void)
{
80004208:	d4 01       	pushm	lr
    /*Toggle Index*/	
    BufferIndex = 1;
8000420a:	30 19       	mov	r9,1
8000420c:	49 78       	lddpc	r8,80004268 <local_start_PDC+0x60>
8000420e:	b0 89       	st.b	r8[0x0],r9
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
80004210:	fe 78 00 00 	mov	r8,-65536
80004214:	30 7b       	mov	r11,7
80004216:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
80004218:	70 b9       	ld.w	r9,r8[0x2c]
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
8000421a:	49 59       	lddpc	r9,8000426c <local_start_PDC+0x64>
8000421c:	f2 ca ff fc 	sub	r10,r9,-4
    BufferIndex = 1;
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
80004220:	91 0a       	st.w	r8[0x0],r10
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
80004222:	30 3a       	mov	r10,3
80004224:	91 2a       	st.w	r8[0x8],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
80004226:	30 1c       	mov	r12,1
80004228:	91 1c       	st.w	r8[0x4],r12
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
8000422a:	2e c9       	sub	r9,-20
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
8000422c:	91 39       	st.w	r8[0xc],r9
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
8000422e:	91 4a       	st.w	r8[0x10],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80004230:	30 2c       	mov	r12,2
80004232:	91 6c       	st.w	r8[0x18],r12

	TxBuffer[0].xnl_channel.dword = XNL_IDLE;
80004234:	48 f9       	lddpc	r9,80004270 <local_start_PDC+0x68>
80004236:	e0 68 5a 5a 	mov	r8,23130
8000423a:	ea 18 ab cd 	orh	r8,0xabcd
8000423e:	93 18       	st.w	r9[0x4],r8
	TxBuffer[0].payload_channel.dword[0] = PAYLOADIDLE0;
80004240:	93 28       	st.w	r9[0x8],r8
	TxBuffer[0].payload_channel.dword[1] = PAYLOADIDLE1;
80004242:	30 0e       	mov	lr,0
80004244:	93 3e       	st.w	r9[0xc],lr
	TxBuffer[1].xnl_channel.dword = XNL_IDLE;
80004246:	93 58       	st.w	r9[0x14],r8
	TxBuffer[1].payload_channel.dword[0] = PAYLOADIDLE0;
80004248:	93 68       	st.w	r9[0x18],r8
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;
8000424a:	93 7e       	st.w	r9[0x1c],lr

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
8000424c:	fe 78 00 40 	mov	r8,-65472
80004250:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
80004252:	70 be       	ld.w	lr,r8[0x2c]
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
80004254:	f2 ce ff fc 	sub	lr,r9,-4
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
80004258:	91 0e       	st.w	r8[0x0],lr
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
8000425a:	91 2a       	st.w	r8[0x8],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
8000425c:	91 1b       	st.w	r8[0x4],r11
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
8000425e:	2e c9       	sub	r9,-20
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
80004260:	91 39       	st.w	r8[0xc],r9
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80004262:	91 4a       	st.w	r8[0x10],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80004264:	91 6c       	st.w	r8[0x18],r12
}/*End of local_start_PDC.*/
80004266:	d8 02       	popm	pc
80004268:	00 00       	add	r0,r0
8000426a:	50 b4       	stdsp	sp[0x2c],r4
8000426c:	00 00       	add	r0,r0
8000426e:	50 bc       	stdsp	sp[0x2c],r12
80004270:	00 00       	add	r0,r0
80004272:	50 dc       	stdsp	sp[0x34],r12

80004274 <register_rx_tx_func>:
Description: register the rx function(callback function)
Called By: phy_init -- physical.c
*/
void register_rx_tx_func(void (*rx_exec)(void *),  void ( *tx_exec)(void *))
{
	 phy_rx_exec = rx_exec;
80004274:	48 38       	lddpc	r8,80004280 <register_rx_tx_func+0xc>
80004276:	91 0c       	st.w	r8[0x0],r12
	 phy_tx_exec = tx_exec;//phy_tx_func, phy_rx_func
80004278:	48 38       	lddpc	r8,80004284 <register_rx_tx_func+0x10>
8000427a:	91 0b       	st.w	r8[0x0],r11
	 
}/*End of register_tx_rx_func.*/
8000427c:	5e fc       	retal	r12
8000427e:	00 00       	add	r0,r0
80004280:	00 00       	add	r0,r0
80004282:	0a e0       	st.h	--r5,r0
80004284:	00 00       	add	r0,r0
80004286:	0a e4       	st.h	--r5,r4

80004288 <ssc_init>:
    local_start_SSC -- ssc.c
    local_start_PDC -- ssc.c
Called By: phy_init -- physical.c
*/
void ssc_init(void)
{		
80004288:	d4 01       	pushm	lr
    /*Set up PB01 to watch FS.*/
    AVR32_GPIO.port[1].oderc = 0x00000002;
8000428a:	fe 78 10 00 	mov	r8,-61440
8000428e:	30 29       	mov	r9,2
80004290:	f1 49 01 48 	st.w	r8[328],r9
    AVR32_GPIO.port[1].gpers = 0x00000002;
80004294:	f1 49 01 04 	st.w	r8[260],r9
	
	INTC_register_interrupt (
80004298:	30 3a       	mov	r10,3
8000429a:	36 0b       	mov	r11,96
8000429c:	49 3c       	lddpc	r12,800042e8 <ssc_init+0x60>
8000429e:	f0 1f 00 14 	mcall	800042ec <ssc_init+0x64>
	&pdca_int_handler
	, AVR32_PDCA_IRQ_0
	, AVR32_INTC_INT3
	);
	
	Enable_global_interrupt();
800042a2:	d5 03       	csrf	0x10
	
    /*Waits for radio to start making FSYNC.*/
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
800042a4:	fe 79 10 00 	mov	r9,-61440
800042a8:	f2 f8 01 60 	ld.w	r8,r9[352]
800042ac:	e2 18 00 02 	andl	r8,0x2,COH
800042b0:	cf c0       	breq	800042a8 <ssc_init+0x20>
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
800042b2:	fe 79 10 00 	mov	r9,-61440
800042b6:	f2 f8 01 60 	ld.w	r8,r9[352]
800042ba:	e2 18 00 02 	andl	r8,0x2,COH
800042be:	cf c1       	brne	800042b6 <ssc_init+0x2e>
			
	Disable_global_interrupt(); // resume to before
800042c0:	d3 03       	ssrf	0x10
				
    /*config the SSC*/
    local_start_SSC();
800042c2:	f0 1f 00 0c 	mcall	800042f0 <ssc_init+0x68>

    /*config the PDCA*/
    local_start_PDC();
800042c6:	f0 1f 00 0c 	mcall	800042f4 <ssc_init+0x6c>
		
    /*Start the SSC Physical Layer.*/

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
800042ca:	fe 79 00 00 	mov	r9,-65536
800042ce:	30 18       	mov	r8,1
800042d0:	93 58       	st.w	r9[0x14],r8
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
800042d2:	fe 7a 00 40 	mov	r10,-65472
800042d6:	95 58       	st.w	r10[0x14],r8
    (&AVR32_SSC)->cr = AVR32_SSC_CR_RXEN_MASK | AVR32_SSC_CR_TXEN_MASK;
800042d8:	e0 6b 01 01 	mov	r11,257
800042dc:	fe 7a 34 00 	mov	r10,-52224
800042e0:	95 0b       	st.w	r10[0x0],r11
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->ier = AVR32_PDCA_RCZ_MASK;
800042e2:	93 88       	st.w	r9[0x20],r8
															
	Enable_global_interrupt();
800042e4:	d5 03       	csrf	0x10
															
}/*End of ssc_init.*/
800042e6:	d8 02       	popm	pc
800042e8:	80 00       	ld.sh	r0,r0[0x0]
800042ea:	41 50       	lddsp	r0,sp[0x54]
800042ec:	80 00       	ld.sh	r0,r0[0x0]
800042ee:	4e dc       	lddpc	r12,800044a0 <xcmp_init+0x48>
800042f0:	80 00       	ld.sh	r0,r0[0x0]
800042f2:	41 c4       	lddsp	r4,sp[0x70]
800042f4:	80 00       	ld.sh	r0,r0[0x0]
800042f6:	42 08       	lddsp	r8,sp[0x80]

800042f8 <xcmp_register_app_list>:
Calls: 
Called By: app_init -- app.c
*/
void xcmp_register_app_list(void * list)
{
	app_list = (app_exec_t *)list;
800042f8:	48 28       	lddpc	r8,80004300 <xcmp_register_app_list+0x8>
800042fa:	91 0c       	st.w	r8[0x0],r12
}
800042fc:	5e fc       	retal	r12
800042fe:	00 00       	add	r0,r0
80004300:	00 00       	add	r0,r0
80004302:	50 fc       	stdsp	sp[0x3c],r12

80004304 <xcmp_tx>:
Calls:   
	xnl_tx -- xnl.c
Called By: ...
*/
static void xcmp_tx( xcmp_fragment_t * xcmp, U8 payload_len)
{
80004304:	eb cd 40 80 	pushm	r7,lr
80004308:	fa cd 01 00 	sub	sp,sp,256
8000430c:	16 97       	mov	r7,r11
	Length :xnl length + checksum
	= checksum + xnl header + xcmp opcode + xcmp payload
	= 0x02 + 0x0C + 0x02 + xcmp payload
	= 0x10 + xcmp payload
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | ( 0x10 + payload_len);
8000430e:	16 98       	mov	r8,r11
80004310:	2f 08       	sub	r8,-16
80004312:	af a8       	sbr	r8,0xe
80004314:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE; 
80004316:	3f f8       	mov	r8,-1
80004318:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG;
8000431a:	30 b9       	mov	r9,11
8000431c:	ba 29       	st.h	sp[0x4],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;	
8000431e:	ba 38       	st.h	sp[0x6],r8
	xnl_frame.xnl_header.destination = DEFAULT_VALUE;
80004320:	ba 48       	st.h	sp[0x8],r8
	xnl_frame.xnl_header.source = DEFAULT_VALUE;	
80004322:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80004324:	ba 68       	st.h	sp[0xc],r8
	
	/*insert xcmp frame data*/
	memcpy(&xnl_frame.xnl_payload.xnl_content_data_msg, xcmp, payload_len + 2);
80004326:	f6 ca ff fe 	sub	r10,r11,-2
8000432a:	18 9b       	mov	r11,r12
8000432c:	fa cc ff f0 	sub	r12,sp,-16
80004330:	f0 1f 00 05 	mcall	80004344 <xcmp_tx+0x40>
	xnl_frame.xnl_header.payload_length = payload_len + 2;	
80004334:	2f e7       	sub	r7,-2
80004336:	ba 77       	st.h	sp[0xe],r7
	
	/* send xnl frame*/	
	xnl_tx(&xnl_frame);
80004338:	1a 9c       	mov	r12,sp
8000433a:	f0 1f 00 04 	mcall	80004348 <xcmp_tx+0x44>
}
8000433e:	2c 0d       	sub	sp,-256
80004340:	e3 cd 80 80 	ldm	sp++,r7,pc
80004344:	80 00       	ld.sh	r0,r0[0x0]
80004346:	6f b2       	ld.w	r2,r7[0x6c]
80004348:	80 00       	ld.sh	r0,r0[0x0]
8000434a:	48 84       	lddpc	r4,80004368 <xcmp_DeviceInitializationStatus_request+0x1c>

8000434c <xcmp_DeviceInitializationStatus_request>:
Description: send device initialization status request
Calls: xcmp_tx
Called By:...
*/
void xcmp_DeviceInitializationStatus_request(void)
{
8000434c:	d4 01       	pushm	lr
8000434e:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
		
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_BRDCAST | DEVICE_INITIALIZATION_STATUS;
80004352:	fe 78 b4 00 	mov	r8,-19456
80004356:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	DeviceInitializationStatus_brdcst_t * ptr 
						 = (DeviceInitializationStatus_brdcst_t *)xcmp_farme.u8;
80004358:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*xcmp version 8.1.0.5*///版本号未正确填写，纠正
	ptr->XCMPVersion[0] = 0x08;
8000435c:	30 89       	mov	r9,8
8000435e:	b0 89       	st.b	r8[0x0],r9
	ptr->XCMPVersion[1] = 0x01;
80004360:	30 19       	mov	r9,1
80004362:	b0 99       	st.b	r8[0x1],r9
	ptr->XCMPVersion[2] = 0x00;
80004364:	30 09       	mov	r9,0
80004366:	b0 a9       	st.b	r8[0x2],r9
	ptr->XCMPVersion[3] = 0x05;
80004368:	30 5a       	mov	r10,5
8000436a:	b0 ba       	st.b	r8[0x3],r10
	/*
	0x00:
	This is the message that the device sends at power up or after a reset. It 
	will give the initial status and capabilities for the device.
	*/
	ptr->DeviceInitType = 0x00;
8000436c:	b0 c9       	st.b	r8[0x4],r9
	types of devices may provide a set of services to the radio system, but do 
	not have the ability to be the master.
	
	0x07:OptionBoard,3rd party Option Board-based application.
	*/
	ptr->DeviceStatusInfo.DeviceType = 0x07;
8000436e:	30 7a       	mov	r10,7
80004370:	b0 da       	st.b	r8[0x5],r10
	
	/*Power Up Success, Device has powered up with no errors*/
	ptr->DeviceStatusInfo.DeviceStatus[0] = 0x00;
80004372:	b0 e9       	st.b	r8[0x6],r9
	ptr->DeviceStatusInfo.DeviceStatus[1] = 0x00;
80004374:	b0 f9       	st.b	r8[0x7],r9
	
	/*
	This number is the size of the Device Descriptor data structure with a 
	maximum size not exceeding 255 bytes.
	*/
	ptr->DeviceStatusInfo.DeviceDescriptorSize = 0x00;
80004376:	f1 69 00 08 	st.b	r8[8],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme
8000437a:	30 9b       	mov	r11,9
8000437c:	fa cc ff fe 	sub	r12,sp,-2
80004380:	f0 1f 00 02 	mcall	80004388 <xcmp_DeviceInitializationStatus_request+0x3c>
		, sizeof(DeviceInitializationStatus_brdcst_t) - MAX_DEVICE_DESC_SIZE);
}
80004384:	2c dd       	sub	sp,-204
80004386:	d8 02       	popm	pc
80004388:	80 00       	ld.sh	r0,r0[0x0]
8000438a:	43 04       	lddsp	r4,sp[0xc0]

8000438c <xcmp_opcode_not_supported>:
Description: register the app list
Calls: xcmp_tx
Called By:...
*/
void xcmp_opcode_not_supported( void )
{
8000438c:	d4 01       	pushm	lr
8000438e:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REPLY;
80004392:	fe 78 80 00 	mov	r8,-32768
80004396:	ba 18       	st.h	sp[0x2],r8
	
	/*The radio does not support this opcode.*/
	xcmp_farme.u8[0] = xcmp_Res_Opcode_Not_Supported;
80004398:	30 38       	mov	r8,3
8000439a:	ba c8       	st.b	sp[0x4],r8
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, 1);
8000439c:	30 1b       	mov	r11,1
8000439e:	fa cc ff fe 	sub	r12,sp,-2
800043a2:	f0 1f 00 03 	mcall	800043ac <xcmp_opcode_not_supported+0x20>
}
800043a6:	2c dd       	sub	sp,-204
800043a8:	d8 02       	popm	pc
800043aa:	00 00       	add	r0,r0
800043ac:	80 00       	ld.sh	r0,r0[0x0]
800043ae:	43 04       	lddsp	r4,sp[0xc0]

800043b0 <xcmp_exec_func>:
Description: Perform XCMP corresponding functions
Calls:   
Called By: xcmp_rx_process--task
*/
static void xcmp_exec_func(app_exec_t * exec, xcmp_fragment_t * xcmp)
{
800043b0:	d4 01       	pushm	lr
	/*The message types*/
	switch(xcmp->xcmp_opcode & 0xF000)
800043b2:	96 88       	ld.uh	r8,r11[0x0]
800043b4:	e2 18 f0 00 	andl	r8,0xf000,COH
800043b8:	e0 48 80 00 	cp.w	r8,32768
800043bc:	c0 f0       	breq	800043da <xcmp_exec_func+0x2a>
800043be:	e0 48 b0 00 	cp.w	r8,45056
800043c2:	c1 20       	breq	800043e6 <xcmp_exec_func+0x36>
800043c4:	58 08       	cp.w	r8,0
800043c6:	c1 51       	brne	800043f0 <xcmp_exec_func+0x40>
	{
		case XCMP_REQUEST:
			if(NULL != exec->xcmp_rx_req)
800043c8:	78 08       	ld.w	r8,r12[0x0]
800043ca:	58 08       	cp.w	r8,0
800043cc:	c0 40       	breq	800043d4 <xcmp_exec_func+0x24>
			{
				exec->xcmp_rx_req(xcmp);
800043ce:	16 9c       	mov	r12,r11
800043d0:	5d 18       	icall	r8
800043d2:	d8 02       	popm	pc
			}
			else 
			{
				/*No function to register the request message*/
				/*send not supported opcode to raido */
				xcmp_opcode_not_supported();
800043d4:	f0 1f 00 08 	mcall	800043f4 <xcmp_exec_func+0x44>
800043d8:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_REPLY:		
			if(NULL != exec->xcmp_rx_reply)
800043da:	78 18       	ld.w	r8,r12[0x4]
800043dc:	58 08       	cp.w	r8,0
800043de:	c0 90       	breq	800043f0 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_reply(xcmp);
800043e0:	16 9c       	mov	r12,r11
800043e2:	5d 18       	icall	r8
800043e4:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_BRDCAST:	
			if(NULL != exec->xcmp_rx_brdcst)
800043e6:	78 28       	ld.w	r8,r12[0x8]
800043e8:	58 08       	cp.w	r8,0
800043ea:	c0 30       	breq	800043f0 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_brdcst(xcmp);
800043ec:	16 9c       	mov	r12,r11
800043ee:	5d 18       	icall	r8
800043f0:	d8 02       	popm	pc
800043f2:	00 00       	add	r0,r0
800043f4:	80 00       	ld.sh	r0,r0[0x0]
800043f6:	43 8c       	lddsp	r12,sp[0xe0]

800043f8 <xcmp_IdleTestTone>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_IdleTestTone(U8 type, U16 toneID)
{
800043f8:	d4 01       	pushm	lr
800043fa:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | TONE_CONTROL;
800043fe:	e0 68 04 09 	mov	r8,1033
80004402:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	ToneControl_req_t * ptr = (ToneControl_req_t *)xcmp_farme.u8;
80004404:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*Starts the specific tone*/	
	ptr->Function = type;
80004408:	b0 8c       	st.b	r8[0x0],r12
	
	/*This tone shall be sounded when radio landed on a priority channel*/
	//ptr->ToneIdentifier[0] = (Priority_Beep >> 8) & 0xFF;
	//ptr->ToneIdentifier[1] = Priority_Beep & 0xFF;
	
	ptr->ToneIdentifier[0] = (toneID >> 8) & 0xFF;
8000440a:	f3 db c1 08 	bfextu	r9,r11,0x8,0x8
8000440e:	b0 99       	st.b	r8[0x1],r9
	ptr->ToneIdentifier[1] = toneID & 0xFF;	
80004410:	b0 ab       	st.b	r8[0x2],r11
	
	/*
	The alert tone is played according to any rules for alert tones, given the 
	current volume setting. Settings for this field are 8 to 255 (0x08 ?0xFF).
	*/
	ptr->ToneVolumeControl = Current_Volume;
80004412:	30 09       	mov	r9,0
80004414:	b0 b9       	st.b	r8[0x3],r9
	
	/*clear reserved*/
	memset(ptr->Reserved, 0, 8);
80004416:	fb 69 00 08 	st.b	sp[8],r9
8000441a:	fa c8 ff f7 	sub	r8,sp,-9
8000441e:	b0 89       	st.b	r8[0x0],r9
80004420:	fa c8 ff f6 	sub	r8,sp,-10
80004424:	b0 89       	st.b	r8[0x0],r9
80004426:	fa c8 ff f5 	sub	r8,sp,-11
8000442a:	b0 89       	st.b	r8[0x0],r9
8000442c:	fa c8 ff f4 	sub	r8,sp,-12
80004430:	b0 89       	st.b	r8[0x0],r9
80004432:	fa c8 ff f3 	sub	r8,sp,-13
80004436:	b0 89       	st.b	r8[0x0],r9
80004438:	fa c8 ff f2 	sub	r8,sp,-14
8000443c:	b0 89       	st.b	r8[0x0],r9
8000443e:	fa c8 ff f1 	sub	r8,sp,-15
80004442:	b0 89       	st.b	r8[0x0],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(ToneControl_req_t));
80004444:	30 cb       	mov	r11,12
80004446:	fa cc ff fe 	sub	r12,sp,-2
8000444a:	f0 1f 00 03 	mcall	80004454 <xcmp_IdleTestTone+0x5c>
}
8000444e:	2c dd       	sub	sp,-204
80004450:	d8 02       	popm	pc
80004452:	00 00       	add	r0,r0
80004454:	80 00       	ld.sh	r0,r0[0x0]
80004456:	43 04       	lddsp	r4,sp[0xc0]

80004458 <xcmp_init>:
	xQueueCreate -- freertos
	xTaskCreate -- freertos
Called By: main -- main.c
*/
void xcmp_init(void)
{
80004458:	d4 01       	pushm	lr
	/*register the xcmp function(callback function)*/
	xnl_register_xcmp_func( xcmp_rx );
8000445a:	48 dc       	lddpc	r12,8000448c <xcmp_init+0x34>
8000445c:	f0 1f 00 0d 	mcall	80004490 <xcmp_init+0x38>
	
	/*initialize the queue*/
	xcmp_frame_rx = xQueueCreate(20, sizeof(xcmp_fragment_t *));
80004460:	30 4b       	mov	r11,4
80004462:	31 4c       	mov	r12,20
80004464:	f0 1f 00 0c 	mcall	80004494 <xcmp_init+0x3c>
80004468:	48 c8       	lddpc	r8,80004498 <xcmp_init+0x40>
8000446a:	91 0c       	st.w	r8[0x0],r12
	/*create task*/	
	/*this task is used to execute xcmp message*/
	xTaskCreate(
8000446c:	30 09       	mov	r9,0
8000446e:	1a d9       	st.w	--sp,r9
80004470:	1a d9       	st.w	--sp,r9
80004472:	1a d9       	st.w	--sp,r9
80004474:	30 38       	mov	r8,3
80004476:	e0 6a 01 80 	mov	r10,384
8000447a:	48 9b       	lddpc	r11,8000449c <xcmp_init+0x44>
8000447c:	48 9c       	lddpc	r12,800044a0 <xcmp_init+0x48>
8000447e:	f0 1f 00 0a 	mcall	800044a4 <xcmp_init+0x4c>
	,  tskXCMP_PRIORITY
	,  NULL
	);
	
	/*initialize the xnl*/
	xnl_init();
80004482:	f0 1f 00 0a 	mcall	800044a8 <xcmp_init+0x50>
80004486:	2f dd       	sub	sp,-12
	
}
80004488:	d8 02       	popm	pc
8000448a:	00 00       	add	r0,r0
8000448c:	80 00       	ld.sh	r0,r0[0x0]
8000448e:	45 a8       	lddsp	r8,sp[0x168]
80004490:	80 00       	ld.sh	r0,r0[0x0]
80004492:	45 f4       	lddsp	r4,sp[0x17c]
80004494:	80 00       	ld.sh	r0,r0[0x0]
80004496:	5c 7c       	castu.h	r12
80004498:	00 00       	add	r0,r0
8000449a:	0b 00       	ld.w	r0,r5++
8000449c:	80 00       	ld.sh	r0,r0[0x0]
8000449e:	cf 80       	breq	8000448e <xcmp_init+0x36>
800044a0:	80 00       	ld.sh	r0,r0[0x0]
800044a2:	44 ac       	lddsp	r12,sp[0x128]
800044a4:	80 00       	ld.sh	r0,r0[0x0]
800044a6:	63 50       	ld.w	r0,r1[0x54]
800044a8:	80 00       	ld.sh	r0,r0[0x0]
800044aa:	46 2c       	lddsp	r12,sp[0x188]

800044ac <xcmp_rx_process>:
Calls: xQueueReceive -- freerots
	xcmp_exec_func
Called By: task
*/
static void xcmp_rx_process(void * pvParameters)
{
800044ac:	d4 31       	pushm	r0-r7,lr
800044ae:	20 1d       	sub	sp,4
	xcmp_fragment_t xcmp;
	xcmp_fragment_t * ptr;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
800044b0:	4b 16       	lddpc	r6,80004574 <xcmp_rx_process+0xc8>
800044b2:	30 05       	mov	r5,0
800044b4:	31 44       	mov	r4,20
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
800044b6:	4b 13       	lddpc	r3,80004578 <xcmp_rx_process+0xcc>
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
					break;
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
800044b8:	4b 12       	lddpc	r2,8000457c <xcmp_rx_process+0xd0>
						, ptr);
					break;
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
800044ba:	4b 21       	lddpc	r1,80004580 <xcmp_rx_process+0xd4>
					break;
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
800044bc:	4b 20       	lddpc	r0,80004584 <xcmp_rx_process+0xd8>
	xcmp_fragment_t xcmp;
	xcmp_fragment_t * ptr;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
800044be:	6c 0c       	ld.w	r12,r6[0x0]
800044c0:	0a 99       	mov	r9,r5
800044c2:	08 9a       	mov	r10,r4
800044c4:	1a 9b       	mov	r11,sp
800044c6:	f0 1f 00 31 	mcall	80004588 <xcmp_rx_process+0xdc>
800044ca:	58 1c       	cp.w	r12,1
800044cc:	cf 91       	brne	800044be <xcmp_rx_process+0x12>
		{									
			if(NULL == ptr)
800044ce:	40 0b       	lddsp	r11,sp[0x0]
800044d0:	58 0b       	cp.w	r11,0
800044d2:	cf 60       	breq	800044be <xcmp_rx_process+0x12>
				continue;
			}
			
			//log("\n\r R_xcmp : %4x \n\r",ptr->xcmp_opcode);//log:R_xcmp指令	
						
			switch(ptr->xcmp_opcode & 0x0FFF)
800044d4:	96 0a       	ld.sh	r10,r11[0x0]
800044d6:	f3 da c0 10 	bfextu	r9,r10,0x0,0x10
800044da:	f1 d9 c0 0c 	bfextu	r8,r9,0x0,0xc
800044de:	59 c8       	cp.w	r8,28
800044e0:	c1 e0       	breq	8000451c <xcmp_rx_process+0x70>
800044e2:	e0 89 00 07 	brgt	800044f0 <xcmp_rx_process+0x44>
800044e6:	58 e8       	cp.w	r8,14
800044e8:	c0 e0       	breq	80004504 <xcmp_rx_process+0x58>
800044ea:	58 f8       	cp.w	r8,15
800044ec:	c2 41       	brne	80004534 <xcmp_rx_process+0x88>
800044ee:	c0 f8       	rjmp	8000450c <xcmp_rx_process+0x60>
800044f0:	e0 48 01 09 	cp.w	r8,265
800044f4:	c1 80       	breq	80004524 <xcmp_rx_process+0x78>
800044f6:	e0 48 01 0a 	cp.w	r8,266
800044fa:	c1 90       	breq	8000452c <xcmp_rx_process+0x80>
800044fc:	e0 48 00 2c 	cp.w	r8,44
80004500:	c1 a1       	brne	80004534 <xcmp_rx_process+0x88>
80004502:	c0 98       	rjmp	80004514 <xcmp_rx_process+0x68>
			{
				case RADIO_STATUS:				
					xcmp_exec_func(&radio_status, ptr);
80004504:	4a 2c       	lddpc	r12,8000458c <xcmp_rx_process+0xe0>
80004506:	f0 1f 00 23 	mcall	80004590 <xcmp_rx_process+0xe4>
					break;
8000450a:	c2 f8       	rjmp	80004568 <xcmp_rx_process+0xbc>
					
				case VERSION_INFORMATION:
					xcmp_exec_func(&version_information, ptr);
8000450c:	4a 2c       	lddpc	r12,80004594 <xcmp_rx_process+0xe8>
8000450e:	f0 1f 00 21 	mcall	80004590 <xcmp_rx_process+0xe4>
					break;
80004512:	c2 b8       	rjmp	80004568 <xcmp_rx_process+0xbc>
					
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
80004514:	4a 1c       	lddpc	r12,80004598 <xcmp_rx_process+0xec>
80004516:	f0 1f 00 1f 	mcall	80004590 <xcmp_rx_process+0xe4>
					break;
8000451a:	c2 78       	rjmp	80004568 <xcmp_rx_process+0xbc>
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
8000451c:	04 9c       	mov	r12,r2
8000451e:	f0 1f 00 1d 	mcall	80004590 <xcmp_rx_process+0xe4>
						, ptr);
					break;
80004522:	c2 38       	rjmp	80004568 <xcmp_rx_process+0xbc>
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
80004524:	02 9c       	mov	r12,r1
80004526:	f0 1f 00 1b 	mcall	80004590 <xcmp_rx_process+0xe4>
					break;
8000452a:	c1 f8       	rjmp	80004568 <xcmp_rx_process+0xbc>
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
8000452c:	00 9c       	mov	r12,r0
8000452e:	f0 1f 00 19 	mcall	80004590 <xcmp_rx_process+0xe4>
					break;
80004532:	c1 b8       	rjmp	80004568 <xcmp_rx_process+0xbc>
					
				default:
				
					/*the xcmp message not in order list*/
					/*over the length of the list*/
					if((0x0400 != (ptr->xcmp_opcode & 0x0400)) 
80004534:	12 98       	mov	r8,r9
80004536:	e2 18 04 00 	andl	r8,0x400,COH
8000453a:	c0 70       	breq	80004548 <xcmp_rx_process+0x9c>
8000453c:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
80004540:	e0 48 00 68 	cp.w	r8,104
80004544:	e0 8a 00 08 	brle	80004554 <xcmp_rx_process+0xa8>
						|| (MAX_APP_FUNC <= (ptr->xcmp_opcode & 0x00FF))
					)
					{
						/*xcmp request*/
						if( XCMP_REQUEST == (ptr->xcmp_opcode & 0xF000))
80004548:	e2 19 f0 00 	andl	r9,0xf000,COH
8000454c:	c0 e1       	brne	80004568 <xcmp_rx_process+0xbc>
						{
							/*send not supported opcode to raido */
							xcmp_opcode_not_supported();
8000454e:	f0 1f 00 14 	mcall	8000459c <xcmp_rx_process+0xf0>
80004552:	c0 b8       	rjmp	80004568 <xcmp_rx_process+0xbc>
						}
					}
					else
					{					
						xcmp_exec_func( &app_list[ptr->xcmp_opcode & 0x00FF]
80004554:	f9 da c0 08 	bfextu	r12,r10,0x0,0x8
80004558:	f8 0c 00 1c 	add	r12,r12,r12<<0x1
8000455c:	49 19       	lddpc	r9,800045a0 <xcmp_rx_process+0xf4>
8000455e:	72 08       	ld.w	r8,r9[0x0]
80004560:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80004564:	f0 1f 00 0b 	mcall	80004590 <xcmp_rx_process+0xe4>
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
80004568:	66 0c       	ld.w	r12,r3[0x0]
8000456a:	40 0b       	lddsp	r11,sp[0x0]
8000456c:	f0 1f 00 0e 	mcall	800045a4 <xcmp_rx_process+0xf8>
80004570:	ca 7b       	rjmp	800044be <xcmp_rx_process+0x12>
80004572:	00 00       	add	r0,r0
80004574:	00 00       	add	r0,r0
80004576:	0b 00       	ld.w	r0,r5++
80004578:	00 00       	add	r0,r0
8000457a:	0a b8       	st.h	r5++,r8
8000457c:	00 00       	add	r0,r0
8000457e:	0b 10       	ld.sh	r0,r5++
80004580:	00 00       	add	r0,r0
80004582:	0b 04       	ld.w	r4,r5++
80004584:	00 00       	add	r0,r0
80004586:	0a f4       	st.b	--r5,r4
80004588:	80 00       	ld.sh	r0,r0[0x0]
8000458a:	59 70       	cp.w	r0,23
8000458c:	00 00       	add	r0,r0
8000458e:	0b 28       	ld.uh	r8,r5++
80004590:	80 00       	ld.sh	r0,r0[0x0]
80004592:	43 b0       	lddsp	r0,sp[0xec]
80004594:	00 00       	add	r0,r0
80004596:	0a e8       	st.h	--r5,r8
80004598:	00 00       	add	r0,r0
8000459a:	0b 1c       	ld.sh	r12,r5++
8000459c:	80 00       	ld.sh	r0,r0[0x0]
8000459e:	43 8c       	lddsp	r12,sp[0xe0]
800045a0:	00 00       	add	r0,r0
800045a2:	50 fc       	stdsp	sp[0x3c],r12
800045a4:	80 00       	ld.sh	r0,r0[0x0]
800045a6:	2f d0       	sub	r0,-3

800045a8 <xcmp_rx>:
Calls:   
	xQueueSend -- xnl.c
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
800045a8:	eb cd 40 90 	pushm	r4,r7,lr
800045ac:	20 1d       	sub	sp,4
800045ae:	fa c4 ff f0 	sub	r4,sp,-16
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
800045b2:	48 c8       	lddpc	r8,800045e0 <xcmp_rx+0x38>
800045b4:	70 0c       	ld.w	r12,r8[0x0]
800045b6:	f0 1f 00 0c 	mcall	800045e4 <xcmp_rx+0x3c>
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
800045ba:	c1 00       	breq	800045da <xcmp_rx+0x32>
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
800045bc:	fa c7 ff fc 	sub	r7,sp,-4
800045c0:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
	{
		memcpy(xcmp_ptr, &xcmp, sizeof(xcmp_fragment_t));				
800045c2:	e0 6a 00 ca 	mov	r10,202
800045c6:	08 9b       	mov	r11,r4
800045c8:	f0 1f 00 08 	mcall	800045e8 <xcmp_rx+0x40>
		xQueueSend(xcmp_frame_rx, &xcmp_ptr, 0);	
800045cc:	48 88       	lddpc	r8,800045ec <xcmp_rx+0x44>
800045ce:	70 0c       	ld.w	r12,r8[0x0]
800045d0:	30 09       	mov	r9,0
800045d2:	12 9a       	mov	r10,r9
800045d4:	1a 9b       	mov	r11,sp
800045d6:	f0 1f 00 07 	mcall	800045f0 <xcmp_rx+0x48>
	}	
}
800045da:	2f fd       	sub	sp,-4
800045dc:	e3 cd 80 90 	ldm	sp++,r4,r7,pc
800045e0:	00 00       	add	r0,r0
800045e2:	0a b8       	st.h	r5++,r8
800045e4:	80 00       	ld.sh	r0,r0[0x0]
800045e6:	31 7c       	mov	r12,23
800045e8:	80 00       	ld.sh	r0,r0[0x0]
800045ea:	6f b2       	ld.w	r2,r7[0x6c]
800045ec:	00 00       	add	r0,r0
800045ee:	0b 00       	ld.w	r0,r5++
800045f0:	80 00       	ld.sh	r0,r0[0x0]
800045f2:	5b 7c       	cp.w	r12,-9

800045f4 <xnl_register_xcmp_func>:
Function: xnl_register_xcmp_func
Description: register the xcmp function(callback function)
*/
void xnl_register_xcmp_func( void ( *func)(xnl_content_data_msg_t))
{
	 xcmp_exec = func;
800045f4:	48 28       	lddpc	r8,800045fc <xnl_register_xcmp_func+0x8>
800045f6:	91 0c       	st.w	r8[0x0],r12
}
800045f8:	5e fc       	retal	r12
800045fa:	00 00       	add	r0,r0
800045fc:	00 00       	add	r0,r0
800045fe:	0b 58       	ld.sh	r8,--r5

80004600 <xnl_get_msg_ack_func>:
Description: process while receive msg ack.
Calls:xSemaphoreGive--freertos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
80004600:	d4 01       	pushm	lr
	
	DestinationAddress = xnl->xnl_header.destination;
	/*No timeout*/		
	 //One relationship is controlled by a state machine, only the current MSG received the ACK, 
	//then the program will clear the current MSG sending address and out of standby and will jump to the sending state.
	if (DestinationAddress == xnl_information.device_address )
80004602:	48 88       	lddpc	r8,80004620 <xnl_get_msg_ack_func+0x20>
80004604:	90 28       	ld.sh	r8,r8[0x4]
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
	U16 DestinationAddress;
	U16 TransactionID;
	
	DestinationAddress = xnl->xnl_header.destination;
80004606:	98 49       	ld.sh	r9,r12[0x8]
80004608:	f0 09 19 00 	cp.h	r9,r8
8000460c:	c0 81       	brne	8000461c <xnl_get_msg_ack_func+0x1c>
	if (DestinationAddress == xnl_information.device_address )
	{
		//The ack is for me.
		
		TransactionID = xnl->xnl_header.transaction_id;
		xSemaphoreGive(xnl_timeout_semphr);	
8000460e:	48 68       	lddpc	r8,80004624 <xnl_get_msg_ack_func+0x24>
80004610:	70 0c       	ld.w	r12,r8[0x0]
80004612:	30 09       	mov	r9,0
80004614:	12 9a       	mov	r10,r9
80004616:	12 9b       	mov	r11,r9
80004618:	f0 1f 00 04 	mcall	80004628 <xnl_get_msg_ack_func+0x28>
8000461c:	d8 02       	popm	pc
8000461e:	00 00       	add	r0,r0
80004620:	00 00       	add	r0,r0
80004622:	0b 38       	ld.ub	r8,r5++
80004624:	00 00       	add	r0,r0
80004626:	0b 34       	ld.ub	r4,r5++
80004628:	80 00       	ld.sh	r0,r0[0x0]
8000462a:	5b 7c       	cp.w	r12,-9

8000462c <xnl_init>:
	xTaskCreate--freertos
	xnl_send_device_master_query
Called By:xcmp_init -- xcmp.c
*/
void xnl_init(void)
{
8000462c:	eb cd 40 e0 	pushm	r5-r7,lr
	
	xnl_information.is_connected = FALSE;
80004630:	30 09       	mov	r9,0
80004632:	4b 78       	lddpc	r8,8000470c <xnl_init+0xe0>
80004634:	b0 89       	st.b	r8[0x0],r9

	/*initialize the semaphore and queue*/
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
80004636:	30 0b       	mov	r11,0
80004638:	30 1c       	mov	r12,1
8000463a:	f0 1f 00 36 	mcall	80004710 <xnl_init+0xe4>
8000463e:	4b 68       	lddpc	r8,80004714 <xnl_init+0xe8>
80004640:	91 0c       	st.w	r8[0x0],r12
80004642:	70 08       	ld.w	r8,r8[0x0]
80004644:	58 08       	cp.w	r8,0
80004646:	c0 80       	breq	80004656 <xnl_init+0x2a>
80004648:	4b 38       	lddpc	r8,80004714 <xnl_init+0xe8>
8000464a:	70 0c       	ld.w	r12,r8[0x0]
8000464c:	30 09       	mov	r9,0
8000464e:	12 9a       	mov	r10,r9
80004650:	12 9b       	mov	r11,r9
80004652:	f0 1f 00 32 	mcall	80004718 <xnl_init+0xec>
	
	xnl_frame_tx = xQueueCreate(20, sizeof(xnl_fragment_t *)); //扩大xnl_frame_tx的队列深度
80004656:	30 4b       	mov	r11,4
80004658:	31 4c       	mov	r12,20
8000465a:	f0 1f 00 2e 	mcall	80004710 <xnl_init+0xe4>
8000465e:	4b 08       	lddpc	r8,8000471c <xnl_init+0xf0>
80004660:	91 0c       	st.w	r8[0x0],r12
		
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
80004662:	30 4b       	mov	r11,4
80004664:	31 ec       	mov	r12,30
80004666:	f0 1f 00 2b 	mcall	80004710 <xnl_init+0xe4>
8000466a:	4a e8       	lddpc	r8,80004720 <xnl_init+0xf4>
8000466c:	91 0c       	st.w	r8[0x0],r12
8000466e:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_XNL_STORE; i++ )
	{
		set_xnl_idle(&xnl_store[i]);
80004670:	10 96       	mov	r6,r8
80004672:	4a d5       	lddpc	r5,80004724 <xnl_init+0xf8>
80004674:	6c 0c       	ld.w	r12,r6[0x0]
80004676:	ea 07 00 0b 	add	r11,r5,r7
8000467a:	f0 1f 00 2c 	mcall	80004728 <xnl_init+0xfc>
8000467e:	ee c7 ff 00 	sub	r7,r7,-256
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
	
	xnl_frame_tx = xQueueCreate(20, sizeof(xnl_fragment_t *)); //扩大xnl_frame_tx的队列深度
		
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
	for(int i= 0; i < MAX_XNL_STORE; i++ )
80004682:	e0 47 1e 00 	cp.w	r7,7680
80004686:	cf 71       	brne	80004674 <xnl_init+0x48>
	{
		set_xnl_idle(&xnl_store[i]);
	}
	
	/*initialize the queue to send/receive xnl packet */
	phy_xnl_frame_tx = xQueueCreate(TX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
80004688:	30 4b       	mov	r11,4
8000468a:	31 4c       	mov	r12,20
8000468c:	f0 1f 00 21 	mcall	80004710 <xnl_init+0xe4>
80004690:	4a 78       	lddpc	r8,8000472c <xnl_init+0x100>
80004692:	91 0c       	st.w	r8[0x0],r12
	phy_xnl_frame_rx = xQueueCreate(RX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
80004694:	30 4b       	mov	r11,4
80004696:	30 ac       	mov	r12,10
80004698:	f0 1f 00 1e 	mcall	80004710 <xnl_init+0xe4>
8000469c:	4a 58       	lddpc	r8,80004730 <xnl_init+0x104>
8000469e:	91 0c       	st.w	r8[0x0],r12
	
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
800046a0:	30 4b       	mov	r11,4
800046a2:	30 ac       	mov	r12,10
800046a4:	f0 1f 00 1b 	mcall	80004710 <xnl_init+0xe4>
800046a8:	4a 38       	lddpc	r8,80004734 <xnl_init+0x108>
800046aa:	91 0c       	st.w	r8[0x0],r12
800046ac:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
	{
		set_payload_idle(payload_store[i]);
800046ae:	10 96       	mov	r6,r8
800046b0:	4a 25       	lddpc	r5,80004738 <xnl_init+0x10c>
800046b2:	6c 0c       	ld.w	r12,r6[0x0]
800046b4:	ea 07 00 0b 	add	r11,r5,r7
800046b8:	f0 1f 00 1c 	mcall	80004728 <xnl_init+0xfc>
800046bc:	ee c7 fe 00 	sub	r7,r7,-512
	
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
800046c0:	e0 47 14 00 	cp.w	r7,5120
800046c4:	cf 71       	brne	800046b2 <xnl_init+0x86>
	
	/*initialize the queue to send/receive payload packet */
	//phy_payload_frame_tx =
	//xQueueCreate(TX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t));
	
	phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
800046c6:	30 4b       	mov	r11,4
800046c8:	30 5c       	mov	r12,5
800046ca:	f0 1f 00 12 	mcall	80004710 <xnl_init+0xe4>
800046ce:	49 c8       	lddpc	r8,8000473c <xnl_init+0x110>
800046d0:	91 0c       	st.w	r8[0x0],r12
	
	#endif /*end if*/
		
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
800046d2:	30 07       	mov	r7,0
800046d4:	1a d7       	st.w	--sp,r7
800046d6:	1a d7       	st.w	--sp,r7
800046d8:	1a d7       	st.w	--sp,r7
800046da:	30 38       	mov	r8,3
800046dc:	0e 99       	mov	r9,r7
800046de:	e0 6a 02 00 	mov	r10,512
800046e2:	49 8b       	lddpc	r11,80004740 <xnl_init+0x114>
800046e4:	49 8c       	lddpc	r12,80004744 <xnl_init+0x118>
800046e6:	f0 1f 00 19 	mcall	80004748 <xnl_init+0x11c>
	,  tskXNL_PRIORITY //+ 1
	,  NULL
	);
	
	/*this task is used to send xnl message*/
	xTaskCreate(
800046ea:	1a d7       	st.w	--sp,r7
800046ec:	1a d7       	st.w	--sp,r7
800046ee:	1a d7       	st.w	--sp,r7
800046f0:	30 38       	mov	r8,3
800046f2:	0e 99       	mov	r9,r7
800046f4:	e0 6a 03 20 	mov	r10,800
800046f8:	49 5b       	lddpc	r11,8000474c <xnl_init+0x120>
800046fa:	49 6c       	lddpc	r12,80004750 <xnl_init+0x124>
800046fc:	f0 1f 00 13 	mcall	80004748 <xnl_init+0x11c>
	,  tskXNL_PRIORITY//+1
	,  NULL
	);
	
	/*initialize the physical layer*/
	phy_init();
80004700:	f0 1f 00 15 	mcall	80004754 <xnl_init+0x128>
80004704:	2f ad       	sub	sp,-24
}
80004706:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000470a:	00 00       	add	r0,r0
8000470c:	00 00       	add	r0,r0
8000470e:	0b 38       	ld.ub	r8,r5++
80004710:	80 00       	ld.sh	r0,r0[0x0]
80004712:	5c 7c       	castu.h	r12
80004714:	00 00       	add	r0,r0
80004716:	0b 34       	ld.ub	r4,r5++
80004718:	80 00       	ld.sh	r0,r0[0x0]
8000471a:	5b 7c       	cp.w	r12,-9
8000471c:	00 00       	add	r0,r0
8000471e:	0b 44       	ld.w	r4,--r5
80004720:	00 00       	add	r0,r0
80004722:	0a b8       	st.h	r5++,r8
80004724:	00 00       	add	r0,r0
80004726:	32 ae       	mov	lr,42
80004728:	80 00       	ld.sh	r0,r0[0x0]
8000472a:	2f d0       	sub	r0,-3
8000472c:	00 00       	add	r0,r0
8000472e:	0a c8       	st.b	r5++,r8
80004730:	00 00       	add	r0,r0
80004732:	0a bc       	st.h	r5++,r12
80004734:	00 00       	add	r0,r0
80004736:	0a 74       	tst	r4,r5
80004738:	00 00       	add	r0,r0
8000473a:	1e ae       	st.w	pc++,lr
8000473c:	00 00       	add	r0,r0
8000473e:	0a 90       	mov	r0,r5
80004740:	80 00       	ld.sh	r0,r0[0x0]
80004742:	cf 88       	rjmp	80004932 <xnl_tx+0xae>
80004744:	80 00       	ld.sh	r0,r0[0x0]
80004746:	47 58       	lddsp	r8,sp[0x1d4]
80004748:	80 00       	ld.sh	r0,r0[0x0]
8000474a:	63 50       	ld.w	r0,r1[0x54]
8000474c:	80 00       	ld.sh	r0,r0[0x0]
8000474e:	c8 00       	breq	8000464e <xnl_init+0x22>
80004750:	80 00       	ld.sh	r0,r0[0x0]
80004752:	47 b8       	lddsp	r8,sp[0x1ec]
80004754:	80 00       	ld.sh	r0,r0[0x0]
80004756:	31 a4       	mov	r4,26

80004758 <xnl_rx_process>:
Description: Receive the XNL
Calls: 
Called By:task
*/
static void xnl_rx_process(void * pvParameters)
{
80004758:	eb cd 40 fe 	pushm	r1-r7,lr
8000475c:	20 1d       	sub	sp,4
	/*To ptr the elements in the queue*/
	xnl_fragment_t * xnl_ptr;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
8000475e:	49 26       	lddpc	r6,800047a4 <xnl_rx_process+0x4c>
80004760:	30 05       	mov	r5,0
80004762:	3f f4       	mov	r4,-1
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
80004764:	30 c3       	mov	r3,12
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
80004766:	49 11       	lddpc	r1,800047a8 <xnl_rx_process+0x50>
	if(xnl->xnl_header.opcode > 0x0C)	
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
80004768:	49 12       	lddpc	r2,800047ac <xnl_rx_process+0x54>
	/*To ptr the elements in the queue*/
	xnl_fragment_t * xnl_ptr;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
8000476a:	6c 0c       	ld.w	r12,r6[0x0]
8000476c:	0a 99       	mov	r9,r5
8000476e:	08 9a       	mov	r10,r4
80004770:	1a 9b       	mov	r11,sp
80004772:	f0 1f 00 10 	mcall	800047b0 <xnl_rx_process+0x58>
80004776:	58 1c       	cp.w	r12,1
80004778:	cf 91       	brne	8000476a <xnl_rx_process+0x12>
		, portMAX_DELAY ))
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
8000477a:	40 0c       	lddsp	r12,sp[0x0]
8000477c:	58 0c       	cp.w	r12,0
8000477e:	cf 60       	breq	8000476a <xnl_rx_process+0x12>
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
80004780:	98 28       	ld.sh	r8,r12[0x4]
80004782:	e6 08 19 00 	cp.h	r8,r3
80004786:	e0 8b 00 0a 	brhi	8000479a <xnl_rx_process+0x42>
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
8000478a:	5c 78       	castu.h	r8
8000478c:	e4 08 03 29 	ld.w	r9,r2[r8<<0x2]
80004790:	58 09       	cp.w	r9,0
80004792:	c0 40       	breq	8000479a <xnl_rx_process+0x42>
	{
		//log("\n\r R_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:R_xnl指令
		/*execute the function in list*/
		xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec(xnl);
80004794:	e4 08 03 28 	ld.w	r8,r2[r8<<0x2]
80004798:	5d 18       	icall	r8
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
8000479a:	62 0c       	ld.w	r12,r1[0x0]
8000479c:	40 0b       	lddsp	r11,sp[0x0]
8000479e:	f0 1f 00 06 	mcall	800047b4 <xnl_rx_process+0x5c>
800047a2:	ce 4b       	rjmp	8000476a <xnl_rx_process+0x12>
800047a4:	00 00       	add	r0,r0
800047a6:	0a bc       	st.h	r5++,r12
800047a8:	00 00       	add	r0,r0
800047aa:	0a b8       	st.h	r5++,r8
800047ac:	00 00       	add	r0,r0
800047ae:	04 f0       	st.b	--r2,r0
800047b0:	80 00       	ld.sh	r0,r0[0x0]
800047b2:	59 70       	cp.w	r0,23
800047b4:	80 00       	ld.sh	r0,r0[0x0]
800047b6:	2f d0       	sub	r0,-3

800047b8 <xnl_tx_process>:
	xSemaphoreTake--freertos 
	phy_tx -- physical.c
Called By: task
*/
static void xnl_tx_process(void * pvParameters)
{
800047b8:	d4 31       	pushm	r0-r7,lr
	static  xnl_fragment_t * ptr;//是否可以修缮为静态变量？请关注
	
	
	for(;;)
	{		
		switch(xnl_tx_state)
800047ba:	4a a6       	lddpc	r6,80004860 <xnl_tx_process+0xa8>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
800047bc:	4a a2       	lddpc	r2,80004864 <xnl_tx_process+0xac>
800047be:	4a b4       	lddpc	r4,80004868 <xnl_tx_process+0xb0>
800047c0:	30 07       	mov	r7,0
800047c2:	3f f1       	mov	r1,-1
					if(NULL == ptr)
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
800047c4:	30 00       	mov	r0,0
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;				
800047c6:	4a a5       	lddpc	r5,8000486c <xnl_tx_process+0xb4>
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
800047c8:	4a a3       	lddpc	r3,80004870 <xnl_tx_process+0xb8>
	static  xnl_fragment_t * ptr;//是否可以修缮为静态变量？请关注
	
	
	for(;;)
	{		
		switch(xnl_tx_state)
800047ca:	6c 08       	ld.w	r8,r6[0x0]
800047cc:	58 08       	cp.w	r8,0
800047ce:	c0 40       	breq	800047d6 <xnl_tx_process+0x1e>
800047d0:	58 18       	cp.w	r8,1
800047d2:	cf d1       	brne	800047cc <xnl_tx_process+0x14>
800047d4:	c2 48       	rjmp	8000481c <xnl_tx_process+0x64>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
800047d6:	64 0c       	ld.w	r12,r2[0x0]
800047d8:	0e 99       	mov	r9,r7
800047da:	02 9a       	mov	r10,r1
800047dc:	08 9b       	mov	r11,r4
800047de:	f0 1f 00 26 	mcall	80004874 <xnl_tx_process+0xbc>
800047e2:	58 1c       	cp.w	r12,1
800047e4:	cf 31       	brne	800047ca <xnl_tx_process+0x12>
					, portMAX_DELAY ))
				{				
					if(NULL == ptr)
800047e6:	68 0b       	ld.w	r11,r4[0x0]
800047e8:	58 0b       	cp.w	r11,0
800047ea:	cf 00       	breq	800047ca <xnl_tx_process+0x12>
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
800047ec:	96 28       	ld.sh	r8,r11[0x4]
800047ee:	e0 08 19 00 	cp.h	r8,r0
800047f2:	c0 71       	brne	80004800 <xnl_tx_process+0x48>
					{
						/*invalid XNL opcode*/
						set_xnl_idle(ptr);
800047f4:	4a 18       	lddpc	r8,80004878 <xnl_tx_process+0xc0>
800047f6:	70 08       	ld.w	r8,r8[0x0]
800047f8:	10 9c       	mov	r12,r8
800047fa:	f0 1f 00 21 	mcall	8000487c <xnl_tx_process+0xc4>
						break;
800047fe:	ce 6b       	rjmp	800047ca <xnl_tx_process+0x12>
					}
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
80004800:	16 9c       	mov	r12,r11
80004802:	f0 1f 00 20 	mcall	80004880 <xnl_tx_process+0xc8>
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;				
80004806:	30 18       	mov	r8,1
80004808:	8b 08       	st.w	r5[0x0],r8
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
8000480a:	66 0c       	ld.w	r12,r3[0x0]
8000480c:	0e 99       	mov	r9,r7
8000480e:	0e 9a       	mov	r10,r7
80004810:	0e 9b       	mov	r11,r7
80004812:	f0 1f 00 19 	mcall	80004874 <xnl_tx_process+0xbc>
					xnl_tx_state = WAITING_FOR_REPLY;
80004816:	30 18       	mov	r8,1
80004818:	8d 08       	st.w	r6[0x0],r8
8000481a:	cd 8b       	rjmp	800047ca <xnl_tx_process+0x12>
				}
				break;
			
			/*wait XNL reply*/			
			case WAITING_FOR_REPLY://直到回答ACK才再发送下一条data/control
				if(pdTRUE == xSemaphoreTake( xnl_timeout_semphr
8000481c:	66 0c       	ld.w	r12,r3[0x0]
8000481e:	0e 99       	mov	r9,r7
80004820:	36 4a       	mov	r10,100
80004822:	0e 9b       	mov	r11,r7
80004824:	f0 1f 00 14 	mcall	80004874 <xnl_tx_process+0xbc>
80004828:	58 1c       	cp.w	r12,1
8000482a:	c0 81       	brne	8000483a <xnl_tx_process+0x82>
					, ( portTickType )50*2/ portTICK_RATE_MS))//按ADK文档中提示500ms一次超时,但是实际情况下程序中启用freertos的任务延时不够精准。因此根据经验需要降低延时等待的时间
				{
					/*No timeout*/
					set_xnl_idle(ptr);			
8000482c:	49 38       	lddpc	r8,80004878 <xnl_tx_process+0xc0>
8000482e:	70 0c       	ld.w	r12,r8[0x0]
80004830:	68 0b       	ld.w	r11,r4[0x0]
80004832:	f0 1f 00 13 	mcall	8000487c <xnl_tx_process+0xc4>
					xnl_tx_state = WAITING_FOR_TX;
80004836:	8d 07       	st.w	r6[0x0],r7
80004838:	cc 9b       	rjmp	800047ca <xnl_tx_process+0x12>
				}
				else
				{
					/*time out*/
					if(xnl_send_times <= MIN_RESEND_TIMES)
8000483a:	6a 08       	ld.w	r8,r5[0x0]
8000483c:	58 38       	cp.w	r8,3
8000483e:	e0 89 00 09 	brgt	80004850 <xnl_tx_process+0x98>
					{
						/*If times smaller than A supermarket, then resend the 
						instructions*/
						phy_tx((phy_fragment_t *)ptr);
80004842:	68 0c       	ld.w	r12,r4[0x0]
80004844:	f0 1f 00 0f 	mcall	80004880 <xnl_tx_process+0xc8>
						xnl_send_times++;
80004848:	6a 08       	ld.w	r8,r5[0x0]
8000484a:	2f f8       	sub	r8,-1
8000484c:	8b 08       	st.w	r5[0x0],r8
8000484e:	cb eb       	rjmp	800047ca <xnl_tx_process+0x12>
					}
					else
					{
						//can not send data, disconnected						
						//vPortFree(ptr);	
						set_xnl_idle(ptr);									
80004850:	48 a8       	lddpc	r8,80004878 <xnl_tx_process+0xc0>
80004852:	70 0c       	ld.w	r12,r8[0x0]
80004854:	68 0b       	ld.w	r11,r4[0x0]
80004856:	f0 1f 00 0a 	mcall	8000487c <xnl_tx_process+0xc4>
						xnl_tx_state = WAITING_FOR_TX;
8000485a:	8d 07       	st.w	r6[0x0],r7
8000485c:	cb 7b       	rjmp	800047ca <xnl_tx_process+0x12>
8000485e:	00 00       	add	r0,r0
80004860:	00 00       	add	r0,r0
80004862:	0b 54       	ld.sh	r4,--r5
80004864:	00 00       	add	r0,r0
80004866:	0b 44       	ld.w	r4,--r5
80004868:	00 00       	add	r0,r0
8000486a:	0b 4c       	ld.w	r12,--r5
8000486c:	00 00       	add	r0,r0
8000486e:	0b 48       	ld.w	r8,--r5
80004870:	00 00       	add	r0,r0
80004872:	0b 34       	ld.ub	r4,r5++
80004874:	80 00       	ld.sh	r0,r0[0x0]
80004876:	59 70       	cp.w	r0,23
80004878:	00 00       	add	r0,r0
8000487a:	0a b8       	st.h	r5++,r8
8000487c:	80 00       	ld.sh	r0,r0[0x0]
8000487e:	2f d0       	sub	r0,-3
80004880:	80 00       	ld.sh	r0,r0[0x0]
80004882:	2f f0       	sub	r0,-1

80004884 <xnl_tx>:
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
{
80004884:	eb cd 40 c0 	pushm	r6-r7,lr
80004888:	20 1d       	sub	sp,4
8000488a:	18 96       	mov	r6,r12
	message that is sent. The same value should be used for all retries.
	*/
	static U8 flags = 0;
	
	/*If the value is DEFAULT_VALUE, the value will be modified*/
	if(DEFAULT_VALUE == xnl->xnl_header.flags)
8000488c:	98 39       	ld.sh	r9,r12[0x6]
8000488e:	3f f8       	mov	r8,-1
80004890:	f0 09 19 00 	cp.h	r9,r8
80004894:	c0 a1       	brne	800048a8 <xnl_tx+0x24>
	{
		xnl->xnl_header.flags =  0x0100 | ((++flags) & 0x07);
80004896:	4a e9       	lddpc	r9,8000494c <xnl_tx+0xc8>
80004898:	13 88       	ld.ub	r8,r9[0x0]
8000489a:	2f f8       	sub	r8,-1
8000489c:	5c 58       	castu.b	r8
8000489e:	b2 88       	st.b	r9[0x0],r8
800048a0:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
800048a4:	a9 a8       	sbr	r8,0x8
800048a6:	b8 38       	st.h	r12[0x6],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.destination)
800048a8:	8c 49       	ld.sh	r9,r6[0x8]
800048aa:	3f f8       	mov	r8,-1
800048ac:	f0 09 19 00 	cp.h	r9,r8
800048b0:	c0 41       	brne	800048b8 <xnl_tx+0x34>
	{		
		/*Use actual Master address.*/
		xnl->xnl_header.destination = xnl_information.master_address;
800048b2:	4a 88       	lddpc	r8,80004950 <xnl_tx+0xcc>
800048b4:	90 18       	ld.sh	r8,r8[0x2]
800048b6:	ac 48       	st.h	r6[0x8],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.source)
800048b8:	8c 59       	ld.sh	r9,r6[0xa]
800048ba:	3f f8       	mov	r8,-1
800048bc:	f0 09 19 00 	cp.h	r9,r8
800048c0:	c0 41       	brne	800048c8 <xnl_tx+0x44>
	{
		/*Use Temporary address.*/	
		xnl->xnl_header.source = xnl_information.device_address;
800048c2:	4a 48       	lddpc	r8,80004950 <xnl_tx+0xcc>
800048c4:	90 28       	ld.sh	r8,r8[0x4]
800048c6:	ac 58       	st.h	r6[0xa],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
800048c8:	8c 69       	ld.sh	r9,r6[0xc]
800048ca:	3f f8       	mov	r8,-1
800048cc:	f0 09 19 00 	cp.h	r9,r8
800048d0:	c0 e1       	brne	800048ec <xnl_tx+0x68>
	{		
		xnl->xnl_header.transaction_id = 
		  ((++xnl_information.transaction_id) & 0xFF) 
800048d2:	4a 08       	lddpc	r8,80004950 <xnl_tx+0xcc>
800048d4:	90 49       	ld.sh	r9,r8[0x8]
800048d6:	2f f9       	sub	r9,-1
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
800048d8:	b0 49       	st.h	r8[0x8],r9
		  ((++xnl_information.transaction_id) & 0xFF) 
800048da:	90 4a       	ld.sh	r10,r8[0x8]
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
800048dc:	90 49       	ld.sh	r9,r8[0x8]
800048de:	e0 19 ff 00 	andl	r9,0xff00
800048e2:	f1 da c0 08 	bfextu	r8,r10,0x0,0x8
800048e6:	f3 e8 10 08 	or	r8,r9,r8
800048ea:	ac 68       	st.h	r6[0xc],r8
	U16  sumScratch;
	U32  indextohWord;
	S32  hWordswithinFrag;
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
800048ec:	0d 98       	ld.ub	r8,r6[0x1]
800048ee:	20 28       	sub	r8,2
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
800048f0:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
800048f4:	10 0c       	add	r12,r8
800048f6:	a1 5c       	asr	r12,0x1
	indextohWord = 2;
	while (hWordswithinFrag > 0)
800048f8:	58 0c       	cp.w	r12,0
800048fa:	e0 89 00 04 	brgt	80004902 <xnl_tx+0x7e>
800048fe:	30 09       	mov	r9,0
80004900:	c0 d8       	rjmp	8000491a <xnl_tx+0x96>
80004902:	ec ca ff fc 	sub	r10,r6,-4
Parameters: xnl_fragment_t * 
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
80004906:	2f ec       	sub	r12,-2
80004908:	30 09       	mov	r9,0
8000490a:	30 28       	mov	r8,2
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
	{
		sumScratch += *((U16*)xnl + indextohWord);
8000490c:	15 1b       	ld.sh	r11,r10++
8000490e:	f6 09 00 09 	add	r9,r11,r9
80004912:	5c 89       	casts.h	r9
		indextohWord     += 1;
80004914:	2f f8       	sub	r8,-1
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
80004916:	18 38       	cp.w	r8,r12
80004918:	cf a1       	brne	8000490c <xnl_tx+0x88>
		  ((++xnl_information.transaction_id) & 0xFF) 
		| (xnl_information.transaction_id & 0xFF00);
	}
	
	/*count check sum */
	xnl->phy_header.check_sum = check_sum( xnl );
8000491a:	5c 39       	neg	r9
8000491c:	ac 19       	st.h	r6[0x2],r9
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
8000491e:	48 e8       	lddpc	r8,80004954 <xnl_tx+0xd0>
80004920:	70 0c       	ld.w	r12,r8[0x0]
80004922:	f0 1f 00 0e 	mcall	80004958 <xnl_tx+0xd4>
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
80004926:	c1 00       	breq	80004946 <xnl_tx+0xc2>
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
80004928:	fa c7 ff fc 	sub	r7,sp,-4
8000492c:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
	{
		memcpy(ptr, xnl, sizeof(xnl_fragment_t));
8000492e:	e0 6a 01 00 	mov	r10,256
80004932:	0c 9b       	mov	r11,r6
80004934:	f0 1f 00 0a 	mcall	8000495c <xnl_tx+0xd8>
	
		/*push to queue and send*/
		
		//log("ptr -%8x", ptr);
		
		xQueueSend(xnl_frame_tx, &ptr, 0);
80004938:	48 a8       	lddpc	r8,80004960 <xnl_tx+0xdc>
8000493a:	70 0c       	ld.w	r12,r8[0x0]
8000493c:	30 09       	mov	r9,0
8000493e:	12 9a       	mov	r10,r9
80004940:	1a 9b       	mov	r11,sp
80004942:	f0 1f 00 09 	mcall	80004964 <xnl_tx+0xe0>
		//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
		
		//vPortFree(ptr);
	}
}
80004946:	2f fd       	sub	sp,-4
80004948:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000494c:	00 00       	add	r0,r0
8000494e:	0b 50       	ld.sh	r0,--r5
80004950:	00 00       	add	r0,r0
80004952:	0b 38       	ld.ub	r8,r5++
80004954:	00 00       	add	r0,r0
80004956:	0a b8       	st.h	r5++,r8
80004958:	80 00       	ld.sh	r0,r0[0x0]
8000495a:	31 7c       	mov	r12,23
8000495c:	80 00       	ld.sh	r0,r0[0x0]
8000495e:	6f b2       	ld.w	r2,r7[0x6c]
80004960:	00 00       	add	r0,r0
80004962:	0b 44       	ld.w	r4,--r5
80004964:	80 00       	ld.sh	r0,r0[0x0]
80004966:	5b 7c       	cp.w	r12,-9

80004968 <xnl_data_msg_func>:
Description: process while receive data message.
Calls:xnl_send_msg_ack, xcmp_exec(function in xcmp)
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_data_msg_func(xnl_fragment_t * xnl)
{
80004968:	eb cd 40 80 	pushm	r7,lr
8000496c:	fa cd 01 00 	sub	sp,sp,256
80004970:	18 97       	mov	r7,r12
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80004972:	e0 68 40 0e 	mov	r8,16398
80004976:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004978:	3f f8       	mov	r8,-1
8000497a:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG_ACK;
8000497c:	30 c8       	mov	r8,12
8000497e:	ba 28       	st.h	sp[0x4],r8
	
	/*Turn around Flags.*/	
	xnl_frame.xnl_header.flags = hdr->flags;
80004980:	98 38       	ld.sh	r8,r12[0x6]
80004982:	ba 38       	st.h	sp[0x6],r8
	
	/*ACK Destination Address is Source of XNL_Message.*/
	xnl_frame.xnl_header.destination = hdr->source;
80004984:	98 58       	ld.sh	r8,r12[0xa]
80004986:	ba 48       	st.h	sp[0x8],r8
	
	/*ACK Source Address is my address.*/
	xnl_frame.xnl_header.source = hdr->destination;
80004988:	98 48       	ld.sh	r8,r12[0x8]
8000498a:	ba 58       	st.h	sp[0xa],r8
	
	/*Turn around Transaction ID.*/
	xnl_frame.xnl_header.transaction_id = hdr->transaction_id;
8000498c:	98 68       	ld.sh	r8,r12[0xc]
8000498e:	ba 68       	st.h	sp[0xc],r8
	xnl_frame.xnl_header.payload_length = 0;
80004990:	30 08       	mov	r8,0
80004992:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004994:	1a 9c       	mov	r12,sp
80004996:	f0 1f 00 0a 	mcall	800049bc <xnl_data_msg_func+0x54>
	transmitter, but possibly is waiting in Queue with immediate timeout.
	 */
	xnl_send_msg_ack(&xnl->xnl_header);
	
	/*exec xcmp function*/
	xcmp_exec(xnl->xnl_payload.xnl_content_data_msg);//xcmp_rx
8000499a:	fa cd 00 cc 	sub	sp,sp,204
8000499e:	e0 6a 00 ca 	mov	r10,202
800049a2:	ee cb ff f0 	sub	r11,r7,-16
800049a6:	1a 9c       	mov	r12,sp
800049a8:	f0 1f 00 06 	mcall	800049c0 <xnl_data_msg_func+0x58>
800049ac:	48 68       	lddpc	r8,800049c4 <xnl_data_msg_func+0x5c>
800049ae:	70 08       	ld.w	r8,r8[0x0]
800049b0:	5d 18       	icall	r8
800049b2:	fa cd ff 34 	sub	sp,sp,-204
}
800049b6:	2c 0d       	sub	sp,-256
800049b8:	e3 cd 80 80 	ldm	sp++,r7,pc
800049bc:	80 00       	ld.sh	r0,r0[0x0]
800049be:	48 84       	lddpc	r4,800049dc <xnl_device_auth_reply_func+0x14>
800049c0:	80 00       	ld.sh	r0,r0[0x0]
800049c2:	6f b2       	ld.w	r2,r7[0x6c]
800049c4:	00 00       	add	r0,r0
800049c6:	0b 58       	ld.sh	r8,--r5

800049c8 <xnl_device_auth_reply_func>:
Description: process while receive device auth reply.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_auth_reply_func(xnl_fragment_t * xnl)
{
800049c8:	d4 21       	pushm	r4-r7,lr
800049ca:	fa cd 01 00 	sub	sp,sp,256
800049ce:	18 97       	mov	r7,r12
	the receiving device and will be used to authenticate the connection 
	request. 5.4.4
	*/
	//log("R_xnl-opcode:%4x", xnl->xnl_header.opcode);
	
	if(xnl_information.is_connected)
800049d0:	4c 28       	lddpc	r8,80004ad8 <xnl_device_auth_reply_func+0x110>
800049d2:	11 88       	ld.ub	r8,r8[0x0]
800049d4:	58 08       	cp.w	r8,0
800049d6:	e0 81 00 7f 	brne	80004ad4 <xnl_device_auth_reply_func+0x10c>
	{
		return;		
	}
	
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);
800049da:	4c 18       	lddpc	r8,80004adc <xnl_device_auth_reply_func+0x114>
800049dc:	70 0c       	ld.w	r12,r8[0x0]
800049de:	30 09       	mov	r9,0
800049e0:	12 9a       	mov	r10,r9
800049e2:	12 9b       	mov	r11,r9
800049e4:	f0 1f 00 3f 	mcall	80004ae0 <xnl_device_auth_reply_func+0x118>

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
800049e8:	ef 09 00 10 	ld.sh	r9,r7[16]
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
800049ec:	4b b8       	lddpc	r8,80004ad8 <xnl_device_auth_reply_func+0x110>
800049ee:	b0 29       	st.h	r8[0x4],r9
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
	
	/*Get Array of values to be encrypted into an aligned 2X32bits.*/
	v_vector[0] =
800049f0:	ef 39 00 12 	ld.ub	r9,r7[18]
800049f4:	ef 38 00 13 	ld.ub	r8,r7[19]
800049f8:	b1 68       	lsl	r8,0x10
800049fa:	f1 e9 11 89 	or	r9,r8,r9<<0x18
800049fe:	ef 38 00 15 	ld.ub	r8,r7[21]
80004a02:	f3 e8 10 08 	or	r8,r9,r8
80004a06:	ef 39 00 14 	ld.ub	r9,r7[20]
80004a0a:	f1 e9 10 89 	or	r9,r8,r9<<0x8
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[2])<<8	  
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[3]);
	
	v_vector[1] =
80004a0e:	ef 3a 00 16 	ld.ub	r10,r7[22]
80004a12:	ef 38 00 17 	ld.ub	r8,r7[23]
80004a16:	b1 68       	lsl	r8,0x10
80004a18:	f1 ea 11 8a 	or	r10,r8,r10<<0x18
80004a1c:	ef 38 00 19 	ld.ub	r8,r7[25]
80004a20:	f5 e8 10 08 	or	r8,r10,r8
80004a24:	ef 3a 00 18 	ld.ub	r10,r7[24]
80004a28:	f1 ea 10 88 	or	r8,r8,r10<<0x8
80004a2c:	30 0a       	mov	r10,0
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
80004a2e:	e0 64 79 b9 	mov	r4,31161
80004a32:	ea 14 9e 37 	orh	r4,0x9e37
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
80004a36:	e0 65 45 07 	mov	r5,17671
80004a3a:	ea 15 8a bd 	orh	r5,0x8abd
80004a3e:	e0 66 f9 3d 	mov	r6,63805
80004a42:	ea 16 99 68 	orh	r6,0x9968
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
80004a46:	e0 6e b8 cf 	mov	lr,47311
80004a4a:	ea 1e 36 83 	orh	lr,0x3683
80004a4e:	e0 67 aa 1c 	mov	r7,43548
80004a52:	ea 17 9c 36 	orh	r7,0x9c36
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
80004a56:	08 0a       	add	r10,r4
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
80004a58:	f4 08 00 0c 	add	r12,r10,r8
80004a5c:	f0 0b 15 04 	lsl	r11,r8,0x4
80004a60:	0a 0b       	add	r11,r5
80004a62:	f9 eb 20 0b 	eor	r11,r12,r11
80004a66:	f0 0c 16 05 	lsr	r12,r8,0x5
80004a6a:	0c 0c       	add	r12,r6
80004a6c:	18 5b       	eor	r11,r12
80004a6e:	16 09       	add	r9,r11
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
80004a70:	f2 0c 15 04 	lsl	r12,r9,0x4
80004a74:	1c 0c       	add	r12,lr
80004a76:	f2 0b 16 05 	lsr	r11,r9,0x5
80004a7a:	0e 0b       	add	r11,r7
80004a7c:	f9 eb 20 0b 	eor	r11,r12,r11
80004a80:	f2 0a 00 0c 	add	r12,r9,r10
80004a84:	18 5b       	eor	r11,r12
80004a86:	16 08       	add	r8,r11
{
	register U32 y=v[0], z=v[1], sum=0;
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
80004a88:	e0 6b 37 20 	mov	r11,14112
80004a8c:	ea 1b c6 ef 	orh	r11,0xc6ef
80004a90:	16 3a       	cp.w	r10,r11
80004a92:	ce 21       	brne	80004a56 <xnl_device_auth_reply_func+0x8e>
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :24 + 2(xnl length(24) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 24 + 2;
80004a94:	e0 6a 40 1a 	mov	r10,16410
80004a98:	ba 0a       	st.h	sp[0x0],r10
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004a9a:	3f fa       	mov	r10,-1
80004a9c:	ba 1a       	st.h	sp[0x2],r10
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_CONN_REQUEST;
80004a9e:	30 6b       	mov	r11,6
80004aa0:	ba 2b       	st.h	sp[0x4],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
80004aa2:	ba 3a       	st.h	sp[0x6],r10
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
80004aa4:	48 db       	lddpc	r11,80004ad8 <xnl_device_auth_reply_func+0x110>
80004aa6:	96 1c       	ld.sh	r12,r11[0x2]
80004aa8:	ba 4c       	st.h	sp[0x8],r12
	message here, and all will receive the same DEVICE_CONN_REPLY. Not real 
	sure what's going to happen with multiple conrol heads, etc. One suspects 
	the Rocket Scientists will eventually figure this out, and demand a 
	transaction ID based on Device Type in the XNL_DEVICE_AUTH_KEY_REQUEST.
	*/
	xnl_frame.xnl_header.source = xnl_information.device_address;
80004aaa:	96 2b       	ld.sh	r11,r11[0x4]
80004aac:	ba 5b       	st.h	sp[0xa],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80004aae:	ba 6a       	st.h	sp[0xc],r10
	
    /*his message contains 12 payload bytes*/	
	xnl_frame.xnl_header.payload_length = 0x000C;
80004ab0:	30 ca       	mov	r10,12
80004ab2:	ba 7a       	st.h	sp[0xe],r10
	
	/*No Preferred XNL Address*/
	xnl_frame.xnl_payload.xnl_content_device_conn_req.preferred_xnl_address = 
80004ab4:	30 0a       	mov	r10,0
80004ab6:	fb 5a 00 10 	st.h	sp[16],r10
	XCMP/XNL Development Specification Section 4.5.3.2.1.
	Same as in MOTOTRBO?XCMP/XNL Development Specification?
	evice_type--Option Board(0x07)
	authentication_index--Option Board(0x02)
	*/	
	xnl_frame.xnl_payload.xnl_content_device_conn_req.device_type = 0x07;
80004aba:	30 7a       	mov	r10,7
80004abc:	fb 6a 00 12 	st.b	sp[18],r10
	xnl_frame.xnl_payload.xnl_content_device_conn_req.authentication_index =
80004ac0:	30 2a       	mov	r10,2
80004ac2:	fb 6a 00 13 	st.b	sp[19],r10
	                                                                       0x02;
		
	//We know encrypted array happens to be aligned to 32-bit boundary.
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
80004ac6:	fa ca ff ec 	sub	r10,sp,-20
80004aca:	95 09       	st.w	r10[0x0],r9
	                         .encrypted_authentication_value[0])) = w_vector[0];
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
80004acc:	95 18       	st.w	r10[0x4],r8
	                         .encrypted_authentication_value[4])) = w_vector[1];
	
	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004ace:	1a 9c       	mov	r12,sp
80004ad0:	f0 1f 00 05 	mcall	80004ae4 <xnl_device_auth_reply_func+0x11c>
}
80004ad4:	2c 0d       	sub	sp,-256
80004ad6:	d8 22       	popm	r4-r7,pc
80004ad8:	00 00       	add	r0,r0
80004ada:	0b 38       	ld.ub	r8,r5++
80004adc:	00 00       	add	r0,r0
80004ade:	0b 34       	ld.ub	r4,r5++
80004ae0:	80 00       	ld.sh	r0,r0[0x0]
80004ae2:	5b 7c       	cp.w	r12,-9
80004ae4:	80 00       	ld.sh	r0,r0[0x0]
80004ae6:	48 84       	lddpc	r4,80004b04 <xnl_master_status_brdcst_func+0x1c>

80004ae8 <xnl_master_status_brdcst_func>:
Description: process while receive master status boardcast.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_master_status_brdcst_func(xnl_fragment_t * xnl)
{	
80004ae8:	eb cd 40 80 	pushm	r7,lr
80004aec:	fa cd 01 00 	sub	sp,sp,256
80004af0:	18 97       	mov	r7,r12
	not an XNL_DATA_MSG has been sent out. This will indicate to a connecting 
	device that it has missed messages. The XNL header will contain the 
	master?XNL address. 5.4.1
	*/
	
	if(xnl_information.is_connected)
80004af2:	49 28       	lddpc	r8,80004b38 <xnl_master_status_brdcst_func+0x50>
80004af4:	11 88       	ld.ub	r8,r8[0x0]
80004af6:	58 08       	cp.w	r8,0
80004af8:	c1 c1       	brne	80004b30 <xnl_master_status_brdcst_func+0x48>
	{
		return;	
	}
		
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);	
80004afa:	49 18       	lddpc	r8,80004b3c <xnl_master_status_brdcst_func+0x54>
80004afc:	70 0c       	ld.w	r12,r8[0x0]
80004afe:	30 09       	mov	r9,0
80004b00:	12 9a       	mov	r10,r9
80004b02:	12 9b       	mov	r11,r9
80004b04:	f0 1f 00 0f 	mcall	80004b40 <xnl_master_status_brdcst_func+0x58>

	//log("xnl-ma:%4x", xnl->xnl_header.source);
	/*get the master adderss from this message*/	
	xnl_information.master_address = xnl->xnl_header.source;	
80004b08:	8e 58       	ld.sh	r8,r7[0xa]
80004b0a:	48 c9       	lddpc	r9,80004b38 <xnl_master_status_brdcst_func+0x50>
80004b0c:	b2 18       	st.h	r9[0x2],r8
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80004b0e:	e0 68 40 0e 	mov	r8,16398
80004b12:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004b14:	3f f8       	mov	r8,-1
80004b16:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_AUTH_KEY_REQUEST;
80004b18:	30 4a       	mov	r10,4
80004b1a:	ba 2a       	st.h	sp[0x4],r10
		
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/	
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
80004b1c:	ba 38       	st.h	sp[0x6],r8
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
80004b1e:	92 19       	ld.sh	r9,r9[0x2]
80004b20:	ba 49       	st.h	sp[0x8],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.source = DEFAULT_VALUE;
80004b22:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80004b24:	ba 68       	st.h	sp[0xc],r8
		
	xnl_frame.xnl_header.payload_length = 0;
80004b26:	30 08       	mov	r8,0
80004b28:	ba 78       	st.h	sp[0xe],r8
	
	/*send XNL message*/	
	xnl_tx(&xnl_frame);
80004b2a:	1a 9c       	mov	r12,sp
80004b2c:	f0 1f 00 06 	mcall	80004b44 <xnl_master_status_brdcst_func+0x5c>
}
80004b30:	2c 0d       	sub	sp,-256
80004b32:	e3 cd 80 80 	ldm	sp++,r7,pc
80004b36:	00 00       	add	r0,r0
80004b38:	00 00       	add	r0,r0
80004b3a:	0b 38       	ld.ub	r8,r5++
80004b3c:	00 00       	add	r0,r0
80004b3e:	0b 34       	ld.ub	r4,r5++
80004b40:	80 00       	ld.sh	r0,r0[0x0]
80004b42:	5b 7c       	cp.w	r12,-9
80004b44:	80 00       	ld.sh	r0,r0[0x0]
80004b46:	48 84       	lddpc	r4,80004b64 <xnl_device_conn_reply_func+0x1c>

80004b48 <xnl_device_conn_reply_func>:
Description: process while receive device conn reply.
Calls:xSemaphoreGive--freestos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_conn_reply_func(xnl_fragment_t * xnl)
{
80004b48:	eb cd 40 80 	pushm	r7,lr
80004b4c:	18 97       	mov	r7,r12
	transaction ID and an 8-byte encrypted value that the device can use to 
	authenticate the master. XCMP/XNL Development Guide 5.4.6
	*/
	
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);
80004b4e:	49 28       	lddpc	r8,80004b94 <xnl_device_conn_reply_func+0x4c>
80004b50:	70 0c       	ld.w	r12,r8[0x0]
80004b52:	30 09       	mov	r9,0
80004b54:	12 9a       	mov	r10,r9
80004b56:	12 9b       	mov	r11,r9
80004b58:	f0 1f 00 10 	mcall	80004b98 <xnl_device_conn_reply_func+0x50>

	/*Test result code*/
	if((xnl->xnl_payload.xnl_content_device_conn_reply.result_base & 0x0000FF00)
80004b5c:	ef 18 00 10 	ld.uh	r8,r7[16]
80004b60:	10 99       	mov	r9,r8
80004b62:	e2 19 ff 00 	andl	r9,0xff00,COH
80004b66:	e0 49 01 00 	cp.w	r9,256
80004b6a:	c0 60       	breq	80004b76 <xnl_device_conn_reply_func+0x2e>
		/*
		Rejected. The device must retry the authentication process at this 
		point by sending out a new AUTH_KEY_REQUEST message. XCMP/XNL 
		Development Guide Section 5.2.3
		*/
		xnl_master_status_brdcst_func(xnl);			
80004b6c:	0e 9c       	mov	r12,r7
80004b6e:	f0 1f 00 0c 	mcall	80004b9c <xnl_device_conn_reply_func+0x54>
80004b72:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/*connection accepted*/		
		/*Record Transaction ID Base*/
		xnl_information.transaction_id =  
80004b76:	a9 68       	lsl	r8,0x8
80004b78:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
80004b7c:	48 98       	lddpc	r8,80004ba0 <xnl_device_conn_reply_func+0x58>
80004b7e:	b0 49       	st.h	r8[0x8],r9
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
80004b80:	ef 09 00 14 	ld.sh	r9,r7[20]
		xnl_information.transaction_id =  
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
80004b84:	b0 39       	st.h	r8[0x6],r9
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
80004b86:	ef 09 00 12 	ld.sh	r9,r7[18]
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
80004b8a:	b0 29       	st.h	r8[0x4],r9
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
		
		/*connect finish*/
		xnl_information.is_connected = TRUE;
80004b8c:	30 19       	mov	r9,1
80004b8e:	b0 89       	st.b	r8[0x0],r9
80004b90:	e3 cd 80 80 	ldm	sp++,r7,pc
80004b94:	00 00       	add	r0,r0
80004b96:	0b 34       	ld.ub	r4,r5++
80004b98:	80 00       	ld.sh	r0,r0[0x0]
80004b9a:	5b 7c       	cp.w	r12,-9
80004b9c:	80 00       	ld.sh	r0,r0[0x0]
80004b9e:	4a e8       	lddpc	r8,80004c54 <voc_init+0x4>
80004ba0:	00 00       	add	r0,r0
80004ba2:	0b 38       	ld.ub	r8,r5++

80004ba4 <xnl_send_device_master_query>:
Description: send device_master_query to connect radio.
Calls:xnl_tx
Call By:xnl_init
*/
void xnl_send_device_master_query(void)
{
80004ba4:	d4 01       	pushm	lr
80004ba6:	fa cd 01 00 	sub	sp,sp,256
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80004baa:	e0 68 40 0e 	mov	r8,16398
80004bae:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004bb0:	3f f8       	mov	r8,-1
80004bb2:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_MASTER_QUERY;
80004bb4:	30 38       	mov	r8,3
80004bb6:	ba 28       	st.h	sp[0x4],r8
	
	/*The initial value*/
	xnl_frame.xnl_header.flags = 0;
80004bb8:	30 08       	mov	r8,0
80004bba:	ba 38       	st.h	sp[0x6],r8
	
	/*XNL address of the master device, if known;otherwise 0x0000*/
	xnl_frame.xnl_header.destination = 0;
80004bbc:	ba 48       	st.h	sp[0x8],r8
	
	/*XNL address, if assigned; otherwise 0x0000*/
	xnl_frame.xnl_header.source = 0;
80004bbe:	ba 58       	st.h	sp[0xa],r8
	
	/*No transaction ID required for this message*/
	xnl_frame.xnl_header.transaction_id = 0;
80004bc0:	ba 68       	st.h	sp[0xc],r8
	
	/*This message contains no payload*/
	xnl_frame.xnl_header.payload_length = 0;
80004bc2:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004bc4:	1a 9c       	mov	r12,sp
80004bc6:	f0 1f 00 03 	mcall	80004bd0 <xnl_send_device_master_query+0x2c>
}
80004bca:	2c 0d       	sub	sp,-256
80004bcc:	d8 02       	popm	pc
80004bce:	00 00       	add	r0,r0
80004bd0:	80 00       	ld.sh	r0,r0[0x0]
80004bd2:	48 84       	lddpc	r4,80004bf0 <local_start_pll0+0x1c>

80004bd4 <local_start_pll0>:
	//pm_switch_to_osc0(pm, 12000000, 3);
	//    pm_enable_osc0_crystal(pm, 12000000);
	//         pm_set_osc0_mode(pm,AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);  0x00000007
	//    pm_enable_clk0(pm, 3);
	//         pm_enable_clk0_no_wait(pm, 3);
	(&AVR32_PM)->oscctrl0 = 0x00000307;
80004bd4:	fe 78 0c 00 	mov	r8,-62464
80004bd8:	e0 69 03 07 	mov	r9,775
80004bdc:	91 a9       	st.w	r8[0x28],r9
	(&AVR32_PM)->mcctrl   = 0x00000004;
80004bde:	30 49       	mov	r9,4
80004be0:	91 09       	st.w	r8[0x0],r9
	//         pm_wait_for_clk0_ready(pm);
	while (!((&AVR32_PM)->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
80004be2:	71 59       	ld.w	r9,r8[0x54]
80004be4:	e2 19 00 80 	andl	r9,0x80,COH
80004be8:	cf d0       	breq	80004be2 <local_start_pll0+0xe>
	//    pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);
	(&AVR32_PM)->mcctrl   = 0x00000005;
80004bea:	fe 78 0c 00 	mov	r8,-62464
80004bee:	30 59       	mov	r9,5
80004bf0:	91 09       	st.w	r8[0x0],r9
	//pm_pll_set_option(pm, 0, //PLL number 0
	//                        1, //freq Set to 1 for VCO frequency range 80-180MHz
	//                        1, //div2 Divide the PLL output frequency by 2
	//                        0);//0 to enable the Wide-Bandith Mode
	//pm_pll_enable(pm,0);
	(&AVR32_PM)->pll[0] = 0x1007010D;
80004bf2:	e0 69 01 0d 	mov	r9,269
80004bf6:	ea 19 10 07 	orh	r9,0x1007
80004bfa:	91 89       	st.w	r8[0x20],r9


	//pm_wait_for_pll0_locked(pm);
	while (!((&AVR32_PM)->poscsr & AVR32_PM_POSCSR_LOCK0_MASK));
80004bfc:	71 59       	ld.w	r9,r8[0x54]
80004bfe:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
80004c02:	cf d0       	breq	80004bfc <local_start_pll0+0x28>
	//             0,  //Bus A select = 0 (PBA clock = 48MHz/2 = 24MHz).
	//             0,  //B clock divisor enable = 0
	//             0,  //Bus B select = 0
	//             0,  //HS Bus clock divisor enable = 0
	//             0); //HS Bus select = 0
	(&AVR32_PM)->cksel = 0x00800000;
80004c04:	fe 78 0c 00 	mov	r8,-62464
80004c08:	fc 19 00 80 	movh	r9,0x80
80004c0c:	91 19       	st.w	r8[0x4],r9

	//flashc_set_wait_state(1);
	AVR32_FLASHC.fcr = 0x00000040;
80004c0e:	34 0a       	mov	r10,64
80004c10:	fe 69 14 00 	mov	r9,-125952
80004c14:	93 0a       	st.w	r9[0x0],r10

	//pm_switch_to_clock(pm, AVR32_PM_MCSEL_PLL0);
	(&AVR32_PM)->mcctrl   = 0x00000006;
80004c16:	30 69       	mov	r9,6
80004c18:	91 09       	st.w	r8[0x0],r9


	AVR32_HMATRIX.mcfg[AVR32_HMATRIX_MASTER_CPU_INSTRUCTION] = 0x1;
80004c1a:	30 19       	mov	r9,1
80004c1c:	fe 68 10 00 	mov	r8,-126976
80004c20:	91 19       	st.w	r8[0x4],r9
	flashc_set_wait_state(1);
	//AVR32_FLASHC.fcr = 0x00000040;

	pm_switch_to_clock(&AVR32_PM, AVR32_PM_MCSEL_PLL0);
****/
}
80004c22:	5e fc       	retal	r12

80004c24 <local_start_timer>:
//	SSC_TX_DATA_ENABLE		AVR32_TC_A0_0_0_PIN					[32 PortB Pin  0 00000001 Func 0]
//	MAKO_TX					AVR32_SSC_TX_DATA_0_PIN				[42 PortB Pin 10 00000400 Func 0]
//	MAKO_RX					AVR32_SSC_RX_DATA_0_PIN				[39 PortB Pin  7 00000080 Func 0]
//
void local_start_timer(void)
{
80004c24:	d4 01       	pushm	lr
	{
		{TIMER_TC_CLK_PIN,      TIMER_TC_CLK_FUNCTION     },
		{TIMER_TC_FS_PIN,       TIMER_TC_FS_FUNCTION      },
		{TIMER_EN_CLK_PIN,      TIMER_EN_CLK_FUNCTION     }
	};
	gpio_enable_module(TC_GPIO_MAP, sizeof(TC_GPIO_MAP) / sizeof(TC_GPIO_MAP[0]));
80004c26:	30 3b       	mov	r11,3
80004c28:	48 8c       	lddpc	r12,80004c48 <local_start_timer+0x24>
80004c2a:	f0 1f 00 09 	mcall	80004c4c <local_start_timer+0x28>

	(&AVR32_TC)->channel[0].cmr =
80004c2e:	fe 78 38 00 	mov	r8,-51200
80004c32:	e0 69 91 0d 	mov	r9,37133
80004c36:	ea 19 00 52 	orh	r9,0x52
80004c3a:	91 19       	st.w	r8[0x4],r9
	1                          << AVR32_TC_CLKI_OFFSET     |
	AVR32_TC_TCCLKS_XC0        << AVR32_TC_TCCLKS_OFFSET;



	(&AVR32_TC)->channel[0].ra = 32;
80004c3c:	32 09       	mov	r9,32
80004c3e:	91 59       	st.w	r8[0x14],r9
	(&AVR32_TC)->channel[0].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
80004c40:	30 59       	mov	r9,5
80004c42:	91 09       	st.w	r8[0x0],r9
}
80004c44:	d8 02       	popm	pc
80004c46:	00 00       	add	r0,r0
80004c48:	80 00       	ld.sh	r0,r0[0x0]
80004c4a:	cf 90       	breq	80004c3c <local_start_timer+0x18>
80004c4c:	80 00       	ld.sh	r0,r0[0x0]
80004c4e:	4e 74       	lddpc	r4,80004de8 <voc_init+0x198>

80004c50 <voc_init>:
	
}

U8 Current_total_voice[2] = {0};
void voc_init(void)
{
80004c50:	d4 31       	pushm	r0-r7,lr
80004c52:	21 4d       	sub	sp,80
	data_flash_init();
80004c54:	f0 1f 00 63 	mcall	80004de0 <voc_init+0x190>
{
	df_status_t return_code = DF_OK;
	unsigned int i = 0;
	unsigned int address =0x00000000;
	char str[80];
	memset(str, 0x00, sizeof(str));
80004c58:	30 08       	mov	r8,0
80004c5a:	30 09       	mov	r9,0
80004c5c:	fa e9 00 00 	st.d	sp[0],r8
80004c60:	fa e9 00 08 	st.d	sp[8],r8
80004c64:	fa e9 00 10 	st.d	sp[16],r8
80004c68:	fa e9 00 18 	st.d	sp[24],r8
80004c6c:	fa e9 00 20 	st.d	sp[32],r8
80004c70:	fa e9 00 28 	st.d	sp[40],r8
80004c74:	fa e9 00 30 	st.d	sp[48],r8
80004c78:	fa e9 00 38 	st.d	sp[56],r8
80004c7c:	fa e9 00 40 	st.d	sp[64],r8
80004c80:	fa e9 00 48 	st.d	sp[72],r8
80004c84:	30 05       	mov	r5,0
	
	start:

	/* bytes remained less than one page */
	return_code = data_flash_read_block(LABEL_ADDRESS, LABEL_LENGTH, str);
80004c86:	1a 97       	mov	r7,sp
80004c88:	30 73       	mov	r3,7
80004c8a:	0a 94       	mov	r4,r5
	if(return_code == DF_OK)
	{
		if(memcmp(FlashLabel, str, sizeof(FlashLabel)-1) != 0)//compare label
80004c8c:	4d 62       	lddpc	r2,80004de4 <voc_init+0x194>
			log("\r\n----create voice info okay!----\r\n");
		}
		else//success
		{
			//Get the current voice index
			return_code = data_flash_read_block(VOICE_NUMBERS_ADDRESS, VOICE_NUMBERS_LENGTH, &current_voice_index);
80004c8e:	4d 76       	lddpc	r6,80004de8 <voc_init+0x198>
80004c90:	30 21       	mov	r1,2
80004c92:	30 a0       	mov	r0,10
	memset(str, 0x00, sizeof(str));
	
	start:

	/* bytes remained less than one page */
	return_code = data_flash_read_block(LABEL_ADDRESS, LABEL_LENGTH, str);
80004c94:	1a 9a       	mov	r10,sp
80004c96:	06 9b       	mov	r11,r3
80004c98:	08 9c       	mov	r12,r4
80004c9a:	f0 1f 00 55 	mcall	80004dec <voc_init+0x19c>
	if(return_code == DF_OK)
80004c9e:	e0 81 00 9f 	brne	80004ddc <voc_init+0x18c>
	{
		if(memcmp(FlashLabel, str, sizeof(FlashLabel)-1) != 0)//compare label
80004ca2:	06 9a       	mov	r10,r3
80004ca4:	1a 9b       	mov	r11,sp
80004ca6:	04 9c       	mov	r12,r2
80004ca8:	f0 1f 00 52 	mcall	80004df0 <voc_init+0x1a0>
80004cac:	c3 60       	breq	80004d18 <voc_init+0xc8>
80004cae:	c8 78       	rjmp	80004dbc <voc_init+0x16c>
				return_code = data_flash_erase_block(address, DF_BLOCK_64KB);
				if(return_code != DF_ERASE_COMPLETED)
				{
					return FALSE;
				}
				address+=65536;//64k*1024=65536bytes
80004cb0:	fe 35 00 00 	sub	r5,-65536
		{
			ERASE:
			//erase
			for(i; i < (VOICE_LIST_BOUNDARY/(64*1024)); i++)//8*64k
			{
				return_code = data_flash_erase_block(address, DF_BLOCK_64KB);
80004cb4:	0e 9b       	mov	r11,r7
80004cb6:	0a 9c       	mov	r12,r5
80004cb8:	f0 1f 00 4f 	mcall	80004df4 <voc_init+0x1a4>
				if(return_code != DF_ERASE_COMPLETED)
80004cbc:	58 5c       	cp.w	r12,5
80004cbe:	e0 81 00 8f 	brne	80004ddc <voc_init+0x18c>
	{
		if(memcmp(FlashLabel, str, sizeof(FlashLabel)-1) != 0)//compare label
		{
			ERASE:
			//erase
			for(i; i < (VOICE_LIST_BOUNDARY/(64*1024)); i++)//8*64k
80004cc2:	0c 35       	cp.w	r5,r6
80004cc4:	cf 61       	brne	80004cb0 <voc_init+0x60>
					return FALSE;
				}
				address+=65536;//64k*1024=65536bytes
			}
			//set label
			return_code = data_flash_write(FlashLabel, LABEL_ADDRESS, LABEL_LENGTH);
80004cc6:	30 7a       	mov	r10,7
80004cc8:	30 0b       	mov	r11,0
80004cca:	4c 7c       	lddpc	r12,80004de4 <voc_init+0x194>
80004ccc:	f0 1f 00 4b 	mcall	80004df8 <voc_init+0x1a8>
			//set current_voice_index
			memset(str, 0x00, sizeof(str));
80004cd0:	1a 9c       	mov	r12,sp
80004cd2:	30 08       	mov	r8,0
80004cd4:	30 09       	mov	r9,0
80004cd6:	fa e9 00 00 	st.d	sp[0],r8
80004cda:	fa e9 00 08 	st.d	sp[8],r8
80004cde:	fa e9 00 10 	st.d	sp[16],r8
80004ce2:	fa e9 00 18 	st.d	sp[24],r8
80004ce6:	fa e9 00 20 	st.d	sp[32],r8
80004cea:	fa e9 00 28 	st.d	sp[40],r8
80004cee:	fa e9 00 30 	st.d	sp[48],r8
80004cf2:	fa e9 00 38 	st.d	sp[56],r8
80004cf6:	fa e9 00 40 	st.d	sp[64],r8
80004cfa:	fa e9 00 48 	st.d	sp[72],r8
			return_code = data_flash_write(str, VOICE_NUMBERS_ADDRESS, VOICE_NUMBERS_LENGTH);
80004cfe:	30 2a       	mov	r10,2
80004d00:	30 ab       	mov	r11,10
80004d02:	f0 1f 00 3e 	mcall	80004df8 <voc_init+0x1a8>
			if(return_code != DF_WRITE_COMPLETED)
80004d06:	58 7c       	cp.w	r12,7
80004d08:	c6 a1       	brne	80004ddc <voc_init+0x18c>
			{
				return FALSE;
			}
			current_voice_index = 0;
80004d0a:	30 09       	mov	r9,0
80004d0c:	4b 78       	lddpc	r8,80004de8 <voc_init+0x198>
80004d0e:	b0 09       	st.h	r8[0x0],r9
			log("\r\n----create voice info okay!----\r\n");
80004d10:	4b bc       	lddpc	r12,80004dfc <voc_init+0x1ac>
80004d12:	f0 1f 00 3c 	mcall	80004e00 <voc_init+0x1b0>
80004d16:	c5 c8       	rjmp	80004dce <voc_init+0x17e>
		}
		else//success
		{
			//Get the current voice index
			return_code = data_flash_read_block(VOICE_NUMBERS_ADDRESS, VOICE_NUMBERS_LENGTH, &current_voice_index);
80004d18:	0c 9a       	mov	r10,r6
80004d1a:	02 9b       	mov	r11,r1
80004d1c:	00 9c       	mov	r12,r0
80004d1e:	f0 1f 00 34 	mcall	80004dec <voc_init+0x19c>
			if(return_code == DF_OK)
80004d22:	c5 d1       	brne	80004ddc <voc_init+0x18c>
			{
				//Calculates the offset address of the current stored voice
				if(current_voice_index != 0){
80004d24:	8c 08       	ld.sh	r8,r6[0x0]
80004d26:	58 08       	cp.w	r8,0
80004d28:	c5 00       	breq	80004dc8 <voc_init+0x178>
					
					address = START_ADDRESS_OF_VOICE_INFO + ((current_voice_index -1)*VOICE_INFO_LENGTH);
80004d2a:	5c 78       	castu.h	r8
80004d2c:	20 18       	sub	r8,1
80004d2e:	f0 08 00 38 	add	r8,r8,r8<<0x3
80004d32:	f0 05 15 03 	lsl	r5,r8,0x3
80004d36:	2f 05       	sub	r5,-16
					return_code = data_flash_read_block(address, VOICE_INFO_LENGTH, (U8 *)str);
80004d38:	1a 9a       	mov	r10,sp
80004d3a:	34 8b       	mov	r11,72
80004d3c:	0a 9c       	mov	r12,r5
80004d3e:	f0 1f 00 2c 	mcall	80004dec <voc_init+0x19c>
					return_code = data_flash_read_block(LABEL_ADDRESS, 512, (U8 *)TEMP_BUF);
80004d42:	4b 1a       	lddpc	r10,80004e04 <voc_init+0x1b4>
80004d44:	e0 6b 02 00 	mov	r11,512
80004d48:	08 9c       	mov	r12,r4
80004d4a:	f0 1f 00 29 	mcall	80004dec <voc_init+0x19c>
					if(return_code == DF_OK)
80004d4e:	c3 d1       	brne	80004dc8 <voc_init+0x178>
					{
						VoiceList_Info_t *ptr = (VoiceList_Info_t *)str;
						if(ptr->numb == current_voice_index)
80004d50:	0f 89       	ld.ub	r9,r7[0x0]
80004d52:	0f 98       	ld.ub	r8,r7[0x1]
80004d54:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80004d58:	8c 09       	ld.sh	r9,r6[0x0]
80004d5a:	f0 09 19 00 	cp.h	r9,r8
80004d5e:	c2 c1       	brne	80004db6 <voc_init+0x166>
						{
							current_save_voice_offset = ptr->address + ptr->offset;
80004d60:	ef 39 00 46 	ld.ub	r9,r7[70]
80004d64:	ef 38 00 47 	ld.ub	r8,r7[71]
80004d68:	f1 e9 10 89 	or	r9,r8,r9<<0x8
80004d6c:	ef 3a 00 42 	ld.ub	r10,r7[66]
80004d70:	ef 38 00 43 	ld.ub	r8,r7[67]
80004d74:	b1 68       	lsl	r8,0x10
80004d76:	f1 ea 11 88 	or	r8,r8,r10<<0x18
80004d7a:	ef 3a 00 44 	ld.ub	r10,r7[68]
80004d7e:	f1 ea 10 88 	or	r8,r8,r10<<0x8
80004d82:	ef 3a 00 45 	ld.ub	r10,r7[69]
80004d86:	f5 e8 10 08 	or	r8,r10,r8
80004d8a:	f2 08 00 08 	add	r8,r9,r8
80004d8e:	49 f9       	lddpc	r9,80004e08 <voc_init+0x1b8>
80004d90:	93 08       	st.w	r9[0x0],r8
							if(current_save_voice_offset > 0x7bc000){
80004d92:	e0 69 c0 00 	mov	r9,49152
80004d96:	ea 19 00 7b 	orh	r9,0x7b
80004d9a:	12 38       	cp.w	r8,r9
80004d9c:	e0 88 00 16 	brls	80004dc8 <voc_init+0x178>
								
								log("\r\n----voice storage is full!!!----\r\n");
80004da0:	49 bc       	lddpc	r12,80004e0c <voc_init+0x1bc>
80004da2:	f0 1f 00 18 	mcall	80004e00 <voc_init+0x1b0>
								//chip erase
								return_code = data_flash_erase_block(0, DF_BLOCK_ALL);
80004da6:	30 4b       	mov	r11,4
80004da8:	08 9c       	mov	r12,r4
80004daa:	f0 1f 00 13 	mcall	80004df4 <voc_init+0x1a4>
								if(return_code == DF_ERASE_COMPLETED)goto start;
80004dae:	58 5c       	cp.w	r12,5
80004db0:	fe 90 ff 72 	breq	80004c94 <voc_init+0x44>
80004db4:	c1 48       	rjmp	80004ddc <voc_init+0x18c>
								return FALSE;
							}
						}
						else
						{
							log("\r\n----voice storage is err!!!----\r\n");
80004db6:	49 7c       	lddpc	r12,80004e10 <voc_init+0x1c0>
80004db8:	f0 1f 00 12 	mcall	80004e00 <voc_init+0x1b0>
	
	
}

U8 Current_total_voice[2] = {0};
void voc_init(void)
80004dbc:	e6 78 00 00 	mov	r8,458752
80004dc0:	ea 08 00 06 	add	r6,r5,r8
		{
			ERASE:
			//erase
			for(i; i < (VOICE_LIST_BOUNDARY/(64*1024)); i++)//8*64k
			{
				return_code = data_flash_erase_block(address, DF_BLOCK_64KB);
80004dc4:	30 37       	mov	r7,3
80004dc6:	c7 7b       	rjmp	80004cb4 <voc_init+0x64>
							goto ERASE;
							//return FALSE;
						}
					}
				}
				log("\r\n----read voice info okay!----\r\n");
80004dc8:	49 3c       	lddpc	r12,80004e14 <voc_init+0x1c4>
80004dca:	f0 1f 00 0e 	mcall	80004e00 <voc_init+0x1b0>
			}
			else
			return FALSE;
		}
		
		memcpy(voice_count_ptr, &current_voice_index, sizeof(current_voice_index));
80004dce:	48 78       	lddpc	r8,80004de8 <voc_init+0x198>
80004dd0:	90 09       	ld.sh	r9,r8[0x0]
80004dd2:	49 28       	lddpc	r8,80004e18 <voc_init+0x1c8>
80004dd4:	b0 09       	st.h	r8[0x0],r9
		list_init_success_flag = 1;
80004dd6:	30 19       	mov	r9,1
80004dd8:	49 18       	lddpc	r8,80004e1c <voc_init+0x1cc>
80004dda:	b0 89       	st.b	r8[0x0],r9
	//create_data_flash_test_task();
	voice_list_info_init(Current_total_voice);
	
	//voc_read_write_test();

80004ddc:	2e cd       	sub	sp,-80
80004dde:	d8 32       	popm	r0-r7,pc
80004de0:	80 00       	ld.sh	r0,r0[0x0]
80004de2:	2d 94       	sub	r4,-39
80004de4:	00 00       	add	r0,r0
80004de6:	05 24       	ld.uh	r4,r2++
80004de8:	00 00       	add	r0,r0
80004dea:	0b 5c       	ld.sh	r12,--r5
80004dec:	80 00       	ld.sh	r0,r0[0x0]
80004dee:	2a 74       	sub	r4,-89
80004df0:	80 00       	ld.sh	r0,r0[0x0]
80004df2:	6f 8c       	ld.w	r12,r7[0x60]
80004df4:	80 00       	ld.sh	r0,r0[0x0]
80004df6:	2c 08       	sub	r8,-64
80004df8:	80 00       	ld.sh	r0,r0[0x0]
80004dfa:	2c a4       	sub	r4,-54
80004dfc:	80 00       	ld.sh	r0,r0[0x0]
80004dfe:	cf a8       	rjmp	80004ff2 <getBaudDiv+0xa>
80004e00:	80 00       	ld.sh	r0,r0[0x0]
80004e02:	67 14       	ld.w	r4,r3[0x44]
80004e04:	00 00       	add	r0,r0
80004e06:	51 00       	stdsp	sp[0x40],r0
80004e08:	00 00       	add	r0,r0
80004e0a:	05 2c       	ld.uh	r12,r2++
80004e0c:	80 00       	ld.sh	r0,r0[0x0]
80004e0e:	cf cc       	rcall	80005006 <getBaudDiv+0x1e>
80004e10:	80 00       	ld.sh	r0,r0[0x0]
80004e12:	cf f4       	brge	80004e10 <voc_init+0x1c0>
80004e14:	80 00       	ld.sh	r0,r0[0x0]
80004e16:	d0 18       	*unknown*
80004e18:	00 00       	add	r0,r0
80004e1a:	0b 60       	ld.uh	r0,--r5
80004e1c:	00 00       	add	r0,r0
80004e1e:	0b 5e       	ld.sh	lr,--r5

80004e20 <gpio_enable_module_pin>:
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80004e20:	f8 08 16 05 	lsr	r8,r12,0x5
80004e24:	a9 68       	lsl	r8,0x8
80004e26:	e0 28 f0 00 	sub	r8,61440

	/* Enable the correct function. */
	switch (function) {
80004e2a:	58 1b       	cp.w	r11,1
80004e2c:	c0 d0       	breq	80004e46 <gpio_enable_module_pin+0x26>
80004e2e:	c0 63       	brcs	80004e3a <gpio_enable_module_pin+0x1a>
80004e30:	58 2b       	cp.w	r11,2
80004e32:	c1 00       	breq	80004e52 <gpio_enable_module_pin+0x32>
80004e34:	58 3b       	cp.w	r11,3
80004e36:	c1 40       	breq	80004e5e <gpio_enable_module_pin+0x3e>
80004e38:	5e ff       	retal	1
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80004e3a:	30 19       	mov	r9,1
80004e3c:	f2 0c 09 49 	lsl	r9,r9,r12
80004e40:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80004e42:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80004e44:	c1 28       	rjmp	80004e68 <gpio_enable_module_pin+0x48>

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80004e46:	30 19       	mov	r9,1
80004e48:	f2 0c 09 49 	lsl	r9,r9,r12
80004e4c:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80004e4e:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80004e50:	c0 c8       	rjmp	80004e68 <gpio_enable_module_pin+0x48>

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80004e52:	30 19       	mov	r9,1
80004e54:	f2 0c 09 49 	lsl	r9,r9,r12
80004e58:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80004e5a:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80004e5c:	c0 68       	rjmp	80004e68 <gpio_enable_module_pin+0x48>

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80004e5e:	30 19       	mov	r9,1
80004e60:	f2 0c 09 49 	lsl	r9,r9,r12
80004e64:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80004e66:	91 99       	st.w	r8[0x24],r9
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
80004e68:	30 19       	mov	r9,1
80004e6a:	f2 0c 09 4c 	lsl	r12,r9,r12
80004e6e:	91 2c       	st.w	r8[0x8],r12
80004e70:	5e fd       	retal	0
80004e72:	d7 03       	nop

80004e74 <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
80004e74:	d4 21       	pushm	r4-r7,lr
80004e76:	18 97       	mov	r7,r12
80004e78:	16 94       	mov	r4,r11
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
80004e7a:	58 0b       	cp.w	r11,0
80004e7c:	c0 31       	brne	80004e82 <gpio_enable_module+0xe>
80004e7e:	30 05       	mov	r5,0
80004e80:	c0 d8       	rjmp	80004e9a <gpio_enable_module+0x26>
80004e82:	30 06       	mov	r6,0
80004e84:	0c 95       	mov	r5,r6
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
80004e86:	6e 1b       	ld.w	r11,r7[0x4]
80004e88:	6e 0c       	ld.w	r12,r7[0x0]
80004e8a:	f0 1f 00 06 	mcall	80004ea0 <gpio_enable_module+0x2c>
80004e8e:	18 45       	or	r5,r12
		gpiomap++;
80004e90:	2f 87       	sub	r7,-8
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
80004e92:	2f f6       	sub	r6,-1
80004e94:	0c 34       	cp.w	r4,r6
80004e96:	fe 9b ff f8 	brhi	80004e86 <gpio_enable_module+0x12>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
}
80004e9a:	0a 9c       	mov	r12,r5
80004e9c:	d8 22       	popm	r4-r7,pc
80004e9e:	00 00       	add	r0,r0
80004ea0:	80 00       	ld.sh	r0,r0[0x0]
80004ea2:	4e 20       	lddpc	r0,80005028 <spi_initMaster+0x20>

80004ea4 <gpio_enable_gpio_pin>:
 *            AVR32_PWM_3_PIN for PWM channel 3 can also be used to release
 *            module pins for GPIO.
 */
void gpio_enable_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80004ea4:	f8 08 16 05 	lsr	r8,r12,0x5
80004ea8:	a9 68       	lsl	r8,0x8
80004eaa:	e0 28 f0 00 	sub	r8,61440
	
	gpio_port->oderc = 1 << (pin & 0x1F);
80004eae:	30 19       	mov	r9,1
80004eb0:	f2 0c 09 4c 	lsl	r12,r9,r12
80004eb4:	f1 4c 00 48 	st.w	r8[72],r12
	gpio_port->gpers = 1 << (pin & 0x1F);
80004eb8:	91 1c       	st.w	r8[0x4],r12
}
80004eba:	5e fc       	retal	r12

80004ebc <gpio_set_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_set_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80004ebc:	f8 08 16 05 	lsr	r8,r12,0x5
80004ec0:	a9 68       	lsl	r8,0x8
80004ec2:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 1. */
	gpio_port->ovrs  = 1 << (pin & 0x1F);
80004ec6:	30 19       	mov	r9,1
80004ec8:	f2 0c 09 4c 	lsl	r12,r9,r12
80004ecc:	f1 4c 00 54 	st.w	r8[84],r12
	/* The GPIO output driver is enabled for that pin. */ 
	gpio_port->oders = 1 << (pin & 0x1F);
80004ed0:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
80004ed4:	91 1c       	st.w	r8[0x4],r12
}
80004ed6:	5e fc       	retal	r12

80004ed8 <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
80004ed8:	c0 08       	rjmp	80004ed8 <_unhandled_interrupt>
80004eda:	d7 03       	nop

80004edc <INTC_register_interrupt>:
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
80004edc:	f6 08 16 05 	lsr	r8,r11,0x5

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
80004ee0:	49 99       	lddpc	r9,80004f44 <INTC_register_interrupt+0x68>
80004ee2:	f2 08 00 39 	add	r9,r9,r8<<0x3
80004ee6:	f7 db c0 05 	bfextu	r11,r11,0x0,0x5
80004eea:	72 19       	ld.w	r9,r9[0x4]
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
80004eec:	f2 0b 09 2c 	st.w	r9[r11<<0x2],r12
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
80004ef0:	58 0a       	cp.w	r10,0
80004ef2:	c0 91       	brne	80004f04 <INTC_register_interrupt+0x28>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80004ef4:	49 59       	lddpc	r9,80004f48 <INTC_register_interrupt+0x6c>
80004ef6:	49 6a       	lddpc	r10,80004f4c <INTC_register_interrupt+0x70>
80004ef8:	12 1a       	sub	r10,r9
80004efa:	fe 79 08 00 	mov	r9,-63488
80004efe:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80004f02:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT1) {
80004f04:	58 1a       	cp.w	r10,1
80004f06:	c0 a1       	brne	80004f1a <INTC_register_interrupt+0x3e>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
80004f08:	49 09       	lddpc	r9,80004f48 <INTC_register_interrupt+0x6c>
80004f0a:	49 2a       	lddpc	r10,80004f50 <INTC_register_interrupt+0x74>
80004f0c:	12 1a       	sub	r10,r9
80004f0e:	bf aa       	sbr	r10,0x1e
80004f10:	fe 79 08 00 	mov	r9,-63488
80004f14:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80004f18:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT2) {
80004f1a:	58 2a       	cp.w	r10,2
80004f1c:	c0 a1       	brne	80004f30 <INTC_register_interrupt+0x54>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
80004f1e:	48 b9       	lddpc	r9,80004f48 <INTC_register_interrupt+0x6c>
80004f20:	48 da       	lddpc	r10,80004f54 <INTC_register_interrupt+0x78>
80004f22:	12 1a       	sub	r10,r9
80004f24:	bf ba       	sbr	r10,0x1f
80004f26:	fe 79 08 00 	mov	r9,-63488
80004f2a:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80004f2e:	5e fc       	retal	r12
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
80004f30:	48 69       	lddpc	r9,80004f48 <INTC_register_interrupt+0x6c>
80004f32:	48 aa       	lddpc	r10,80004f58 <INTC_register_interrupt+0x7c>
80004f34:	12 1a       	sub	r10,r9
80004f36:	ea 1a c0 00 	orh	r10,0xc000
80004f3a:	fe 79 08 00 	mov	r9,-63488
80004f3e:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80004f42:	5e fc       	retal	r12
80004f44:	80 00       	ld.sh	r0,r0[0x0]
80004f46:	d0 3c       	*unknown*
80004f48:	80 00       	ld.sh	r0,r0[0x0]
80004f4a:	c6 00       	breq	8000500a <spi_initMaster+0x2>
80004f4c:	80 00       	ld.sh	r0,r0[0x0]
80004f4e:	c7 04       	brge	8000502e <spi_initMaster+0x26>
80004f50:	80 00       	ld.sh	r0,r0[0x0]
80004f52:	c7 12       	brcc	80005034 <spi_initMaster+0x2c>
80004f54:	80 00       	ld.sh	r0,r0[0x0]
80004f56:	c7 20       	breq	8000503a <spi_initMaster+0x32>
80004f58:	80 00       	ld.sh	r0,r0[0x0]
80004f5a:	c7 2e       	rcall	80004c3e <local_start_timer+0x1a>

80004f5c <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
80004f5c:	d4 21       	pushm	r4-r7,lr
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
80004f5e:	49 18       	lddpc	r8,80004fa0 <INTC_init_interrupts+0x44>
80004f60:	e3 b8 00 01 	mtsr	0x4,r8
80004f64:	49 0e       	lddpc	lr,80004fa4 <INTC_init_interrupts+0x48>
80004f66:	30 07       	mov	r7,0
80004f68:	0e 94       	mov	r4,r7
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
80004f6a:	49 0c       	lddpc	r12,80004fa8 <INTC_init_interrupts+0x4c>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80004f6c:	49 05       	lddpc	r5,80004fac <INTC_init_interrupts+0x50>
80004f6e:	10 15       	sub	r5,r8
80004f70:	fe 76 08 00 	mov	r6,-63488
80004f74:	c1 08       	rjmp	80004f94 <INTC_init_interrupts+0x38>
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
80004f76:	08 98       	mov	r8,r4
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
				._int_line_handler_table[int_req]
80004f78:	7c 1b       	ld.w	r11,lr[0x4]

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80004f7a:	7c 0a       	ld.w	r10,lr[0x0]
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
80004f7c:	f6 08 09 2c 	st.w	r11[r8<<0x2],r12
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
80004f80:	2f f8       	sub	r8,-1

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80004f82:	10 3a       	cp.w	r10,r8
80004f84:	fe 9b ff fc 	brhi	80004f7c <INTC_init_interrupts+0x20>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80004f88:	ec 07 09 25 	st.w	r6[r7<<0x2],r5
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
80004f8c:	2f f7       	sub	r7,-1
80004f8e:	2f 8e       	sub	lr,-8
80004f90:	59 37       	cp.w	r7,19
80004f92:	c0 50       	breq	80004f9c <INTC_init_interrupts+0x40>
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80004f94:	7c 08       	ld.w	r8,lr[0x0]
80004f96:	58 08       	cp.w	r8,0
80004f98:	ce f1       	brne	80004f76 <INTC_init_interrupts+0x1a>
80004f9a:	cf 7b       	rjmp	80004f88 <INTC_init_interrupts+0x2c>
80004f9c:	d8 22       	popm	r4-r7,pc
80004f9e:	00 00       	add	r0,r0
80004fa0:	80 00       	ld.sh	r0,r0[0x0]
80004fa2:	c6 00       	breq	80005062 <spi_selectionMode+0x22>
80004fa4:	80 00       	ld.sh	r0,r0[0x0]
80004fa6:	d0 3c       	*unknown*
80004fa8:	80 00       	ld.sh	r0,r0[0x0]
80004faa:	4e d8       	lddpc	r8,8000515c <spi_setupChipReg+0xac>
80004fac:	80 00       	ld.sh	r0,r0[0x0]
80004fae:	c7 04       	brge	8000508e <spi_read>

80004fb0 <_get_interrupt_handler>:
__int_handler _get_interrupt_handler(uint32_t int_level)
{
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
80004fb0:	fe 78 08 00 	mov	r8,-63488
80004fb4:	e0 69 00 83 	mov	r9,131
80004fb8:	f2 0c 01 0c 	sub	r12,r9,r12
80004fbc:	f0 0c 03 29 	ld.w	r9,r8[r12<<0x2]
	uint32_t int_req = AVR32_INTC.irr[int_grp];
80004fc0:	f2 ca ff c0 	sub	r10,r9,-64
80004fc4:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
80004fc8:	58 08       	cp.w	r8,0
80004fca:	c0 21       	brne	80004fce <_get_interrupt_handler+0x1e>
80004fcc:	5e fd       	retal	0
		? _int_handler_table[int_grp]._int_line_handler_table[32
80004fce:	f0 08 12 00 	clz	r8,r8
80004fd2:	48 5a       	lddpc	r10,80004fe4 <_get_interrupt_handler+0x34>
80004fd4:	f4 09 00 39 	add	r9,r10,r9<<0x3
80004fd8:	f0 08 11 1f 	rsub	r8,r8,31
80004fdc:	72 19       	ld.w	r9,r9[0x4]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
80004fde:	f2 08 03 2c 	ld.w	r12,r9[r8<<0x2]
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
80004fe2:	5e fc       	retal	r12
80004fe4:	80 00       	ld.sh	r0,r0[0x0]
80004fe6:	d0 3c       	*unknown*

80004fe8 <getBaudDiv>:
xSemaphoreHandle xSPIMutex;
#endif

int16_t getBaudDiv(const uint32_t baudrate, uint32_t pb_hz)
{
	uint32_t baudDiv = div_ceil(pb_hz, baudrate);
80004fe8:	f8 c8 00 01 	sub	r8,r12,1
80004fec:	f0 0b 00 0b 	add	r11,r8,r11
80004ff0:	f6 0c 0d 0a 	divu	r10,r11,r12
80004ff4:	14 9c       	mov	r12,r10

	if (baudDiv <= 0 || baudDiv > 255) {
80004ff6:	f4 c8 00 01 	sub	r8,r10,1
80004ffa:	e0 48 00 fe 	cp.w	r8,254
80004ffe:	e0 88 00 03 	brls	80005004 <getBaudDiv+0x1c>
80005002:	5e fe       	retal	-1
		return -1;
	}

	return baudDiv;
80005004:	5c 8c       	casts.h	r12
}
80005006:	5e fc       	retal	r12

80005008 <spi_initMaster>:
spi_status_t spi_initMaster(volatile avr32_spi_t *spi,
		const spi_options_t *options)
{
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (options->modfdis > 1) {
80005008:	f7 39 00 0d 	ld.ub	r9,r11[13]
8000500c:	30 18       	mov	r8,1
8000500e:	f0 09 18 00 	cp.b	r9,r8
80005012:	e0 88 00 04 	brls	8000501a <spi_initMaster+0x12>
80005016:	30 2c       	mov	r12,2
80005018:	5e fc       	retal	r12
		return SPI_ERROR_ARGUMENT;
	}

	/* Reset. */
	spi->cr = AVR32_SPI_CR_SWRST_MASK;
8000501a:	e0 68 00 80 	mov	r8,128
8000501e:	99 08       	st.w	r12[0x0],r8

	/* Master Mode. */
	u_avr32_spi_mr.mr = spi->mr;
80005020:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.mstr = 1;
80005022:	30 19       	mov	r9,1
80005024:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_mr.MR.modfdis = options->modfdis;
80005028:	f7 39 00 0d 	ld.ub	r9,r11[13]
8000502c:	f1 d9 d0 81 	bfins	r8,r9,0x4,0x1
	u_avr32_spi_mr.MR.llb = 0;
80005030:	30 09       	mov	r9,0
80005032:	f1 d9 d0 e1 	bfins	r8,r9,0x7,0x1
	u_avr32_spi_mr.MR.pcs = (1 << AVR32_SPI_MR_PCS_SIZE) - 1;
80005036:	30 fa       	mov	r10,15
80005038:	f1 da d2 04 	bfins	r8,r10,0x10,0x4
	spi->mr = u_avr32_spi_mr.mr;
8000503c:	99 18       	st.w	r12[0x4],r8
8000503e:	5e f9       	retal	r9

80005040 <spi_selectionMode>:

spi_status_t spi_selectionMode(volatile avr32_spi_t *spi,
		uint8_t variable_ps,
		uint8_t pcs_decode,
		uint8_t delay)
{
80005040:	d4 01       	pushm	lr
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (variable_ps > 1 ||
80005042:	30 18       	mov	r8,1
80005044:	f0 0b 18 00 	cp.b	r11,r8
80005048:	5f be       	srhi	lr
8000504a:	f0 0a 18 00 	cp.b	r10,r8
8000504e:	5f b8       	srhi	r8
80005050:	fd e8 10 08 	or	r8,lr,r8
80005054:	c0 30       	breq	8000505a <spi_selectionMode+0x1a>
80005056:	30 2c       	mov	r12,2
80005058:	d8 02       	popm	pc
			pcs_decode > 1) {
		return SPI_ERROR_ARGUMENT;
	}

	u_avr32_spi_mr.mr = spi->mr;
8000505a:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.ps = variable_ps;
8000505c:	f1 db d0 21 	bfins	r8,r11,0x1,0x1
	u_avr32_spi_mr.MR.pcsdec = pcs_decode;
80005060:	f1 da d0 41 	bfins	r8,r10,0x2,0x1
	u_avr32_spi_mr.MR.dlybcs = delay;
80005064:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8
	spi->mr = u_avr32_spi_mr.mr;
80005068:	99 18       	st.w	r12[0x4],r8
8000506a:	d8 0a       	popm	pc,r12=0

8000506c <spi_enable>:
	return SPI_OK;
}

void spi_enable(volatile avr32_spi_t *spi)
{
	spi->cr = AVR32_SPI_CR_SPIEN_MASK;
8000506c:	30 18       	mov	r8,1
8000506e:	99 08       	st.w	r12[0x0],r8
}
80005070:	5e fc       	retal	r12

80005072 <spi_write>:
{
	return ((spi->sr & AVR32_SPI_SR_TDRE_MASK) != 0);
}

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
80005072:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
80005076:	c0 58       	rjmp	80005080 <spi_write+0xe>
		if (!timeout--) {
80005078:	58 08       	cp.w	r8,0
8000507a:	c0 21       	brne	8000507e <spi_write+0xc>
8000507c:	5e ff       	retal	1
8000507e:	20 18       	sub	r8,1

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
80005080:	78 49       	ld.w	r9,r12[0x10]
80005082:	e2 19 00 02 	andl	r9,0x2,COH
80005086:	cf 90       	breq	80005078 <spi_write+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	spi->tdr = data << AVR32_SPI_TDR_TD_OFFSET;
80005088:	5c 7b       	castu.h	r11
8000508a:	99 3b       	st.w	r12[0xc],r11
8000508c:	5e fd       	retal	0

8000508e <spi_read>:
{
	return ((spi->sr & AVR32_SPI_SR_RDRF_MASK) != 0);
}

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
8000508e:	e0 68 3a 98 	mov	r8,15000
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
80005092:	c0 58       	rjmp	8000509c <spi_read+0xe>
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) !=
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) {
		if (!timeout--) {
80005094:	58 08       	cp.w	r8,0
80005096:	c0 21       	brne	8000509a <spi_read+0xc>
80005098:	5e ff       	retal	1
8000509a:	20 18       	sub	r8,1

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
8000509c:	78 49       	ld.w	r9,r12[0x10]
8000509e:	e2 19 02 01 	andl	r9,0x201,COH
800050a2:	e0 49 02 01 	cp.w	r9,513
800050a6:	cf 71       	brne	80005094 <spi_read+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	*data = spi->rdr >> AVR32_SPI_RDR_RD_OFFSET;
800050a8:	78 28       	ld.w	r8,r12[0x8]
800050aa:	b6 08       	st.h	r11[0x0],r8
800050ac:	5e fd       	retal	0
800050ae:	d7 03       	nop

800050b0 <spi_setupChipReg>:
}

spi_status_t spi_setupChipReg(volatile avr32_spi_t *spi,
		const spi_options_t *options,
		uint32_t pb_hz)
{
800050b0:	eb cd 40 f8 	pushm	r3-r7,lr
800050b4:	18 95       	mov	r5,r12
800050b6:	16 97       	mov	r7,r11
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
800050b8:	f7 36 00 0c 	ld.ub	r6,r11[12]
800050bc:	30 38       	mov	r8,3
800050be:	f0 06 18 00 	cp.b	r6,r8
800050c2:	e0 8b 00 5e 	brhi	8000517e <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
800050c6:	f7 34 00 0b 	ld.ub	r4,r11[11]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
800050ca:	30 18       	mov	r8,1
800050cc:	f0 04 18 00 	cp.b	r4,r8
800050d0:	e0 8b 00 57 	brhi	8000517e <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
800050d4:	f7 33 00 08 	ld.ub	r3,r11[8]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
800050d8:	30 78       	mov	r8,7
800050da:	f0 03 18 00 	cp.b	r3,r8
800050de:	e0 88 00 50 	brls	8000517e <spi_setupChipReg+0xce>
800050e2:	31 08       	mov	r8,16
800050e4:	f0 03 18 00 	cp.b	r3,r8
800050e8:	e0 8b 00 4b 	brhi	8000517e <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
		return SPI_ERROR_ARGUMENT;
	}

	int baudDiv = getBaudDiv(options->baudrate, pb_hz);
800050ec:	14 9b       	mov	r11,r10
800050ee:	6e 1c       	ld.w	r12,r7[0x4]
800050f0:	f0 1f 00 26 	mcall	80005188 <spi_setupChipReg+0xd8>

	if (baudDiv < 0) {
800050f4:	c4 55       	brlt	8000517e <spi_setupChipReg+0xce>
		return SPI_ERROR_ARGUMENT;
	}

	/* Will use CSR0 offsets; these are the same for CSR0 to CSR3. */
	u_avr32_spi_csr.csr = 0;
800050f6:	30 08       	mov	r8,0
	u_avr32_spi_csr.CSR.cpol   = options->spi_mode >> 1;
800050f8:	ec 09 16 01 	lsr	r9,r6,0x1
800050fc:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_csr.CSR.ncpha  = (options->spi_mode & 0x1) ^ 0x1;
80005100:	ec 16 00 01 	eorl	r6,0x1
80005104:	f1 d6 d0 21 	bfins	r8,r6,0x1,0x1
	u_avr32_spi_csr.CSR.csaat  = options->stay_act;
80005108:	f1 d4 d0 61 	bfins	r8,r4,0x3,0x1
	u_avr32_spi_csr.CSR.bits   = options->bits - 8;
8000510c:	20 83       	sub	r3,8
8000510e:	f1 d3 d0 84 	bfins	r8,r3,0x4,0x4
	u_avr32_spi_csr.CSR.scbr   = baudDiv;
80005112:	f1 dc d1 08 	bfins	r8,r12,0x8,0x8
	u_avr32_spi_csr.CSR.dlybs  = options->spck_delay;
80005116:	ef 39 00 09 	ld.ub	r9,r7[9]
8000511a:	f1 d9 d2 08 	bfins	r8,r9,0x10,0x8
	u_avr32_spi_csr.CSR.dlybct = options->trans_delay;
8000511e:	ef 39 00 0a 	ld.ub	r9,r7[10]
80005122:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8

	switch (options->reg) {
80005126:	0f 89       	ld.ub	r9,r7[0x0]
80005128:	30 1a       	mov	r10,1
8000512a:	f4 09 18 00 	cp.b	r9,r10
8000512e:	c0 d0       	breq	80005148 <spi_setupChipReg+0x98>
80005130:	c0 a3       	brcs	80005144 <spi_setupChipReg+0x94>
80005132:	30 2a       	mov	r10,2
80005134:	f4 09 18 00 	cp.b	r9,r10
80005138:	c0 a0       	breq	8000514c <spi_setupChipReg+0x9c>
8000513a:	30 3a       	mov	r10,3
8000513c:	f4 09 18 00 	cp.b	r9,r10
80005140:	c1 f1       	brne	8000517e <spi_setupChipReg+0xce>
80005142:	c0 78       	rjmp	80005150 <spi_setupChipReg+0xa0>
	case 0:
		spi->csr0 = u_avr32_spi_csr.csr;
80005144:	8b c8       	st.w	r5[0x30],r8
		break;
80005146:	c0 68       	rjmp	80005152 <spi_setupChipReg+0xa2>

	case 1:
		spi->csr1 = u_avr32_spi_csr.csr;
80005148:	8b d8       	st.w	r5[0x34],r8
		break;
8000514a:	c0 48       	rjmp	80005152 <spi_setupChipReg+0xa2>

	case 2:
		spi->csr2 = u_avr32_spi_csr.csr;
8000514c:	8b e8       	st.w	r5[0x38],r8
		break;
8000514e:	c0 28       	rjmp	80005152 <spi_setupChipReg+0xa2>

	case 3:
		spi->csr3 = u_avr32_spi_csr.csr;
80005150:	8b f8       	st.w	r5[0x3c],r8
	default:
		return SPI_ERROR_ARGUMENT;
	}

#ifdef FREERTOS_USED
	if (!xSPIMutex) {
80005152:	48 f8       	lddpc	r8,8000518c <spi_setupChipReg+0xdc>
80005154:	70 08       	ld.w	r8,r8[0x0]
80005156:	58 08       	cp.w	r8,0
80005158:	c1 61       	brne	80005184 <spi_setupChipReg+0xd4>
		/* Create the SPI mutex. */
		vSemaphoreCreateBinary(xSPIMutex);
8000515a:	30 0b       	mov	r11,0
8000515c:	30 1c       	mov	r12,1
8000515e:	f0 1f 00 0d 	mcall	80005190 <spi_setupChipReg+0xe0>
80005162:	48 b8       	lddpc	r8,8000518c <spi_setupChipReg+0xdc>
80005164:	91 0c       	st.w	r8[0x0],r12
80005166:	58 0c       	cp.w	r12,0
80005168:	c0 a0       	breq	8000517c <spi_setupChipReg+0xcc>
8000516a:	30 09       	mov	r9,0
8000516c:	12 9a       	mov	r10,r9
8000516e:	12 9b       	mov	r11,r9
80005170:	f0 1f 00 09 	mcall	80005194 <spi_setupChipReg+0xe4>
		if (!xSPIMutex) {
80005174:	48 68       	lddpc	r8,8000518c <spi_setupChipReg+0xdc>
80005176:	70 08       	ld.w	r8,r8[0x0]
80005178:	58 08       	cp.w	r8,0
8000517a:	c0 51       	brne	80005184 <spi_setupChipReg+0xd4>
8000517c:	c0 08       	rjmp	8000517c <spi_setupChipReg+0xcc>
8000517e:	30 2c       	mov	r12,2
80005180:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80005184:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
80005188:	80 00       	ld.sh	r0,r0[0x0]
8000518a:	4f e8       	lddpc	r8,80005380 <usart_reset+0x20>
8000518c:	00 00       	add	r0,r0
8000518e:	63 90       	ld.w	r0,r1[0x64]
80005190:	80 00       	ld.sh	r0,r0[0x0]
80005192:	5c 7c       	castu.h	r12
80005194:	80 00       	ld.sh	r0,r0[0x0]
80005196:	5b 7c       	cp.w	r12,-9

80005198 <spi_unselectChip>:

	return SPI_OK;
}

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
80005198:	d4 01       	pushm	lr
8000519a:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
8000519e:	c0 58       	rjmp	800051a8 <spi_unselectChip+0x10>
		if (!timeout--) {
800051a0:	58 08       	cp.w	r8,0
800051a2:	c0 21       	brne	800051a6 <spi_unselectChip+0xe>
800051a4:	da 0a       	popm	pc,r12=1
800051a6:	20 18       	sub	r8,1

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
800051a8:	78 49       	ld.w	r9,r12[0x10]
800051aa:	e2 19 02 00 	andl	r9,0x200,COH
800051ae:	cf 90       	breq	800051a0 <spi_unselectChip+0x8>
			return SPI_ERROR_TIMEOUT;
		}
	}

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
800051b0:	78 18       	ld.w	r8,r12[0x4]
800051b2:	ea 18 00 0f 	orh	r8,0xf
800051b6:	99 18       	st.w	r12[0x4],r8

	/* Last transfer, so de-assert the current NPCS if CSAAT is set. */
	spi->cr = AVR32_SPI_CR_LASTXFER_MASK;
800051b8:	fc 18 01 00 	movh	r8,0x100
800051bc:	99 08       	st.w	r12[0x0],r8

#ifdef FREERTOS_USED
	xSemaphoreGive(xSPIMutex);
800051be:	30 09       	mov	r9,0
800051c0:	12 9a       	mov	r10,r9
800051c2:	12 9b       	mov	r11,r9
800051c4:	48 38       	lddpc	r8,800051d0 <spi_unselectChip+0x38>
800051c6:	70 0c       	ld.w	r12,r8[0x0]
800051c8:	f0 1f 00 03 	mcall	800051d4 <spi_unselectChip+0x3c>
800051cc:	d8 0a       	popm	pc,r12=0
800051ce:	00 00       	add	r0,r0
800051d0:	00 00       	add	r0,r0
800051d2:	63 90       	ld.w	r0,r1[0x64]
800051d4:	80 00       	ld.sh	r0,r0[0x0]
800051d6:	5b 7c       	cp.w	r12,-9

800051d8 <spi_selectChip>:

	return SPI_OK;
}

spi_status_t spi_selectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
800051d8:	eb cd 40 f8 	pushm	r3-r7,lr
800051dc:	18 94       	mov	r4,r12
800051de:	16 93       	mov	r3,r11
#ifdef FREERTOS_USED
	while (pdFALSE == xSemaphoreTake(xSPIMutex, 20)) {
800051e0:	49 a6       	lddpc	r6,80005248 <spi_selectChip+0x70>
800051e2:	30 07       	mov	r7,0
800051e4:	31 45       	mov	r5,20
800051e6:	0e 99       	mov	r9,r7
800051e8:	0a 9a       	mov	r10,r5
800051ea:	0e 9b       	mov	r11,r7
800051ec:	6c 0c       	ld.w	r12,r6[0x0]
800051ee:	f0 1f 00 18 	mcall	8000524c <spi_selectChip+0x74>
800051f2:	cf a0       	breq	800051e6 <spi_selectChip+0xe>
	}
#endif

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
800051f4:	68 18       	ld.w	r8,r4[0x4]
800051f6:	ea 18 00 0f 	orh	r8,0xf
800051fa:	89 18       	st.w	r4[0x4],r8

	if (spi->mr & AVR32_SPI_MR_PCSDEC_MASK) {
800051fc:	68 18       	ld.w	r8,r4[0x4]
800051fe:	e2 18 00 04 	andl	r8,0x4,COH
80005202:	c1 10       	breq	80005224 <spi_selectChip+0x4c>
		/* The signal is decoded; allow up to 15 chips. */
		if (chip > 14) {
80005204:	30 e8       	mov	r8,14
80005206:	f0 03 18 00 	cp.b	r3,r8
8000520a:	e0 8b 00 1c 	brhi	80005242 <spi_selectChip+0x6a>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~AVR32_SPI_MR_PCS_MASK |
8000520e:	68 19       	ld.w	r9,r4[0x4]
80005210:	e6 08 15 10 	lsl	r8,r3,0x10
80005214:	ea 18 ff f0 	orh	r8,0xfff0
80005218:	e8 18 ff ff 	orl	r8,0xffff
8000521c:	12 68       	and	r8,r9
8000521e:	89 18       	st.w	r4[0x4],r8
80005220:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
				(chip << AVR32_SPI_MR_PCS_OFFSET);
	} else {
		if (chip > 3) {
80005224:	30 38       	mov	r8,3
80005226:	f0 03 18 00 	cp.b	r3,r8
8000522a:	e0 8b 00 0c 	brhi	80005242 <spi_selectChip+0x6a>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~(1 << (AVR32_SPI_MR_PCS_OFFSET + chip));
8000522e:	68 19       	ld.w	r9,r4[0x4]
80005230:	2f 03       	sub	r3,-16
80005232:	30 18       	mov	r8,1
80005234:	f0 03 09 48 	lsl	r8,r8,r3
80005238:	5c d8       	com	r8
8000523a:	12 68       	and	r8,r9
8000523c:	89 18       	st.w	r4[0x4],r8
8000523e:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
80005242:	30 2c       	mov	r12,2
	}

	return SPI_OK;
}
80005244:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80005248:	00 00       	add	r0,r0
8000524a:	63 90       	ld.w	r0,r1[0x64]
8000524c:	80 00       	ld.sh	r0,r0[0x0]
8000524e:	59 70       	cp.w	r0,23

80005250 <usart_set_async_baudrate>:
 *
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
80005250:	d4 01       	pushm	lr
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
80005252:	f6 08 15 04 	lsl	r8,r11,0x4
80005256:	14 38       	cp.w	r8,r10
80005258:	f9 b8 08 10 	movls	r8,16
8000525c:	f9 b8 0b 08 	movhi	r8,8
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
80005260:	f0 0b 02 4b 	mul	r11,r8,r11
80005264:	f6 09 16 01 	lsr	r9,r11,0x1
80005268:	f2 0a 00 3a 	add	r10,r9,r10<<0x3
8000526c:	f4 0b 0d 0a 	divu	r10,r10,r11
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
80005270:	f4 09 16 03 	lsr	r9,r10,0x3
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
80005274:	f2 cb 00 01 	sub	r11,r9,1
80005278:	e0 4b ff fe 	cp.w	r11,65534
8000527c:	e0 88 00 03 	brls	80005282 <usart_set_async_baudrate+0x32>
80005280:	da 0a       	popm	pc,r12=1
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
80005282:	78 1b       	ld.w	r11,r12[0x4]
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
80005284:	e8 6e 00 00 	mov	lr,524288
80005288:	59 08       	cp.w	r8,16
8000528a:	fc 08 17 10 	movne	r8,lr
8000528e:	f9 b8 00 00 	moveq	r8,0
80005292:	e4 1b ff f7 	andh	r11,0xfff7
80005296:	e0 1b fe cf 	andl	r11,0xfecf
8000529a:	16 48       	or	r8,r11
8000529c:	99 18       	st.w	r12[0x4],r8
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
8000529e:	f5 da c0 03 	bfextu	r10,r10,0x0,0x3
800052a2:	f3 ea 11 09 	or	r9,r9,r10<<0x10
800052a6:	99 89       	st.w	r12[0x20],r9
800052a8:	d8 0a       	popm	pc,r12=0

800052aa <usart_write_char>:
 *
 * \return \c 1 if the USART Transmit Holding Register is free, otherwise \c 0.
 */
__always_inline static int usart_tx_ready(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_TXRDY_MASK) != 0;
800052aa:	78 58       	ld.w	r8,r12[0x14]
}


int usart_write_char(volatile avr32_usart_t *usart, int c)
{
  if (usart_tx_ready(usart))
800052ac:	e2 18 00 02 	andl	r8,0x2,COH
800052b0:	c0 31       	brne	800052b6 <usart_write_char+0xc>
800052b2:	30 2c       	mov	r12,2
800052b4:	5e fc       	retal	r12
  {
    usart->thr = (c << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
800052b6:	f7 db c0 09 	bfextu	r11,r11,0x0,0x9
800052ba:	99 7b       	st.w	r12[0x1c],r11
800052bc:	5e fd       	retal	0
800052be:	d7 03       	nop

800052c0 <usart_putchar>:
    return USART_TX_BUSY;
}


int usart_putchar(volatile avr32_usart_t *usart, int c)
{
800052c0:	eb cd 40 e0 	pushm	r5-r7,lr
800052c4:	18 96       	mov	r6,r12
800052c6:	16 95       	mov	r5,r11
800052c8:	e0 67 27 0f 	mov	r7,9999
800052cc:	c0 68       	rjmp	800052d8 <usart_putchar+0x18>
  int timeout = USART_DEFAULT_TIMEOUT;

  do
  {
    if (!timeout--) return USART_FAILURE;
800052ce:	58 07       	cp.w	r7,0
800052d0:	c0 31       	brne	800052d6 <usart_putchar+0x16>
800052d2:	e3 cf c0 e0 	ldm	sp++,r5-r7,pc,r12=-1
800052d6:	20 17       	sub	r7,1
  } while (usart_write_char(usart, c) != USART_SUCCESS);
800052d8:	0a 9b       	mov	r11,r5
800052da:	0c 9c       	mov	r12,r6
800052dc:	f0 1f 00 03 	mcall	800052e8 <usart_putchar+0x28>
800052e0:	cf 71       	brne	800052ce <usart_putchar+0xe>

  return USART_SUCCESS;
}
800052e2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800052e6:	00 00       	add	r0,r0
800052e8:	80 00       	ld.sh	r0,r0[0x0]
800052ea:	52 aa       	stdsp	sp[0xa8],r10

800052ec <usart_read_char>:

int usart_read_char(volatile avr32_usart_t *usart, int *c)
{
  // Check for errors: frame, parity and overrun. In RS485 mode, a parity error
  // would mean that an address char has been received.
  if (usart->csr & (AVR32_USART_CSR_OVRE_MASK |
800052ec:	78 58       	ld.w	r8,r12[0x14]
800052ee:	e2 18 00 e0 	andl	r8,0xe0,COH
800052f2:	c0 30       	breq	800052f8 <usart_read_char+0xc>
800052f4:	30 4c       	mov	r12,4
800052f6:	5e fc       	retal	r12
 *
 * \return \c 1 if the USART Receive Holding Register is full, otherwise \c 0.
 */
__always_inline static int usart_test_hit(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_RXRDY_MASK) != 0;
800052f8:	78 58       	ld.w	r8,r12[0x14]
                    AVR32_USART_CSR_FRAME_MASK |
                    AVR32_USART_CSR_PARE_MASK))
    return USART_RX_ERROR;

  // No error; if we really did receive a char, read it and return SUCCESS.
  if (usart_test_hit(usart))
800052fa:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800052fe:	c0 31       	brne	80005304 <usart_read_char+0x18>
80005300:	30 3c       	mov	r12,3
80005302:	5e fc       	retal	r12
  {
    *c = (usart->rhr & AVR32_USART_RHR_RXCHR_MASK) >> AVR32_USART_RHR_RXCHR_OFFSET;
80005304:	78 68       	ld.w	r8,r12[0x18]
80005306:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
8000530a:	97 08       	st.w	r11[0x0],r8
8000530c:	5e fd       	retal	0
8000530e:	d7 03       	nop

80005310 <usart_getchar>:
    return USART_RX_EMPTY;
}


int usart_getchar(volatile avr32_usart_t *usart)
{
80005310:	eb cd 40 c0 	pushm	r6-r7,lr
80005314:	20 1d       	sub	sp,4
80005316:	18 96       	mov	r6,r12
  int c, ret;

  while ((ret = usart_read_char(usart, &c)) == USART_RX_EMPTY);
80005318:	1a 97       	mov	r7,sp
8000531a:	1a 9b       	mov	r11,sp
8000531c:	0c 9c       	mov	r12,r6
8000531e:	f0 1f 00 07 	mcall	80005338 <usart_getchar+0x28>
80005322:	58 3c       	cp.w	r12,3
80005324:	cf b0       	breq	8000531a <usart_getchar+0xa>

  if (ret == USART_RX_ERROR)
80005326:	58 4c       	cp.w	r12,4
80005328:	f9 bc 00 ff 	moveq	r12,-1
    return USART_FAILURE;

  return c;
8000532c:	fb fc 10 00 	ld.wne	r12,sp[0x0]
}
80005330:	2f fd       	sub	sp,-4
80005332:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005336:	00 00       	add	r0,r0
80005338:	80 00       	ld.sh	r0,r0[0x0]
8000533a:	52 ec       	stdsp	sp[0xb8],r12

8000533c <usart_write_line>:


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
8000533c:	eb cd 40 c0 	pushm	r6-r7,lr
80005340:	18 96       	mov	r6,r12
80005342:	16 97       	mov	r7,r11
  while (*string != '\0')
80005344:	17 8b       	ld.ub	r11,r11[0x0]
80005346:	58 0b       	cp.w	r11,0
80005348:	c0 80       	breq	80005358 <usart_write_line+0x1c>
    usart_putchar(usart, *string++);
8000534a:	2f f7       	sub	r7,-1
8000534c:	0c 9c       	mov	r12,r6
8000534e:	f0 1f 00 04 	mcall	8000535c <usart_write_line+0x20>
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
80005352:	0f 8b       	ld.ub	r11,r7[0x0]
80005354:	58 0b       	cp.w	r11,0
80005356:	cf a1       	brne	8000534a <usart_write_line+0xe>
80005358:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000535c:	80 00       	ld.sh	r0,r0[0x0]
8000535e:	52 c0       	stdsp	sp[0xb0],r0

80005360 <usart_reset>:
//! @{


void usart_reset(volatile avr32_usart_t *usart)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
80005360:	e1 b8 00 00 	mfsr	r8,0x0

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
80005364:	e6 18 00 01 	andh	r8,0x1,COH
80005368:	c0 71       	brne	80005376 <usart_reset+0x16>
8000536a:	d3 03       	ssrf	0x10
  usart->idr = 0xFFFFFFFF;
8000536c:	3f f8       	mov	r8,-1
8000536e:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80005370:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();
80005372:	d5 03       	csrf	0x10
80005374:	c0 48       	rjmp	8000537c <usart_reset+0x1c>
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
  usart->idr = 0xFFFFFFFF;
80005376:	3f f8       	mov	r8,-1
80005378:	99 38       	st.w	r12[0xc],r8
  usart->csr;
8000537a:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();

  // Reset mode and other registers that could cause unpredictable behavior after reset.
  usart->mr = 0;
8000537c:	30 08       	mov	r8,0
8000537e:	99 18       	st.w	r12[0x4],r8
  usart->rtor = 0;
80005380:	99 98       	st.w	r12[0x24],r8
  usart->ttgr = 0;
80005382:	99 a8       	st.w	r12[0x28],r8

  // Shutdown TX and RX (will be re-enabled when setup has successfully completed),
  // reset status bits and turn off DTR and RTS.
  usart->cr = AVR32_USART_CR_RSTRX_MASK   |
80005384:	ea 68 61 0c 	mov	r8,680204
80005388:	99 08       	st.w	r12[0x0],r8
#ifndef AVR32_USART_440_H_INCLUDED
// Note: Modem Signal Management DTR-DSR-DCD-RI are not included in USART rev.440.
              AVR32_USART_CR_DTRDIS_MASK  |
#endif
              AVR32_USART_CR_RTSDIS_MASK;
}
8000538a:	5e fc       	retal	r12

8000538c <usart_init_rs232>:


int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
{
8000538c:	eb cd 40 e0 	pushm	r5-r7,lr
80005390:	18 96       	mov	r6,r12
80005392:	16 97       	mov	r7,r11
80005394:	14 95       	mov	r5,r10
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);
80005396:	f0 1f 00 2f 	mcall	80005450 <usart_init_rs232+0xc4>

  // Check input values.
  if (!opt || // Null pointer.
8000539a:	58 07       	cp.w	r7,0
8000539c:	c5 80       	breq	8000544c <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
8000539e:	0f c8       	ld.ub	r8,r7[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
800053a0:	30 49       	mov	r9,4
800053a2:	f2 08 18 00 	cp.b	r8,r9
800053a6:	e0 88 00 53 	brls	8000544c <usart_init_rs232+0xc0>
800053aa:	30 99       	mov	r9,9
800053ac:	f2 08 18 00 	cp.b	r8,r9
800053b0:	e0 8b 00 4e 	brhi	8000544c <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
800053b4:	0f d9       	ld.ub	r9,r7[0x5]
800053b6:	30 78       	mov	r8,7
800053b8:	f0 09 18 00 	cp.b	r9,r8
800053bc:	e0 8b 00 48 	brhi	8000544c <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
800053c0:	8e 39       	ld.sh	r9,r7[0x6]
800053c2:	e0 68 01 01 	mov	r8,257
800053c6:	f0 09 19 00 	cp.h	r9,r8
800053ca:	e0 8b 00 41 	brhi	8000544c <usart_init_rs232+0xc0>
      opt->channelmode > 3 ||
800053ce:	ef 39 00 08 	ld.ub	r9,r7[8]
800053d2:	30 38       	mov	r8,3
800053d4:	f0 09 18 00 	cp.b	r9,r8
800053d8:	e0 8b 00 3a 	brhi	8000544c <usart_init_rs232+0xc0>
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
800053dc:	0a 9a       	mov	r10,r5
800053de:	6e 0b       	ld.w	r11,r7[0x0]
800053e0:	0c 9c       	mov	r12,r6
800053e2:	f0 1f 00 1d 	mcall	80005454 <usart_init_rs232+0xc8>
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
800053e6:	58 1c       	cp.w	r12,1
800053e8:	c3 20       	breq	8000544c <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
    return USART_INVALID_INPUT;

  if (opt->charlength == 9)
800053ea:	0f c8       	ld.ub	r8,r7[0x4]
800053ec:	30 99       	mov	r9,9
800053ee:	f2 08 18 00 	cp.b	r8,r9
800053f2:	c0 51       	brne	800053fc <usart_init_rs232+0x70>
  {
    // Character length set to 9 bits. MODE9 dominates CHRL.
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
800053f4:	6c 18       	ld.w	r8,r6[0x4]
800053f6:	b1 b8       	sbr	r8,0x11
800053f8:	8d 18       	st.w	r6[0x4],r8
800053fa:	c0 68       	rjmp	80005406 <usart_init_rs232+0x7a>
  }
  else
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
800053fc:	6c 19       	ld.w	r9,r6[0x4]
800053fe:	20 58       	sub	r8,5
80005400:	f3 e8 10 68 	or	r8,r9,r8<<0x6
80005404:	8d 18       	st.w	r6[0x4],r8
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
80005406:	6c 19       	ld.w	r9,r6[0x4]
80005408:	ef 3a 00 08 	ld.ub	r10,r7[8]
8000540c:	0f d8       	ld.ub	r8,r7[0x5]
8000540e:	a9 78       	lsl	r8,0x9
80005410:	f1 ea 10 e8 	or	r8,r8,r10<<0xe
80005414:	12 48       	or	r8,r9
80005416:	8d 18       	st.w	r6[0x4],r8
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;

  if (opt->stopbits > USART_2_STOPBITS)
80005418:	8e 38       	ld.sh	r8,r7[0x6]
8000541a:	30 29       	mov	r9,2
8000541c:	f2 08 19 00 	cp.h	r8,r9
80005420:	e0 88 00 09 	brls	80005432 <usart_init_rs232+0xa6>
  {
    // Set two stop bits
    usart->mr |= AVR32_USART_MR_NBSTOP_2 << AVR32_USART_MR_NBSTOP_OFFSET;
80005424:	6c 18       	ld.w	r8,r6[0x4]
80005426:	ad b8       	sbr	r8,0xd
80005428:	8d 18       	st.w	r6[0x4],r8
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
8000542a:	8e b8       	ld.uh	r8,r7[0x6]
8000542c:	20 28       	sub	r8,2
8000542e:	8d a8       	st.w	r6[0x28],r8
80005430:	c0 68       	rjmp	8000543c <usart_init_rs232+0xb0>
  }
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;
80005432:	6c 19       	ld.w	r9,r6[0x4]
80005434:	5c 78       	castu.h	r8
80005436:	f3 e8 10 c8 	or	r8,r9,r8<<0xc
8000543a:	8d 18       	st.w	r6[0x4],r8

  // Set normal mode.
  usart->mr = (usart->mr & ~AVR32_USART_MR_MODE_MASK) |
8000543c:	6c 18       	ld.w	r8,r6[0x4]
8000543e:	e0 18 ff f0 	andl	r8,0xfff0
80005442:	8d 18       	st.w	r6[0x4],r8
              AVR32_USART_MR_MODE_NORMAL << AVR32_USART_MR_MODE_OFFSET;

  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
80005444:	35 08       	mov	r8,80
80005446:	8d 08       	st.w	r6[0x0],r8
80005448:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
8000544c:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
80005450:	80 00       	ld.sh	r0,r0[0x0]
80005452:	53 60       	stdsp	sp[0xd8],r0
80005454:	80 00       	ld.sh	r0,r0[0x0]
80005456:	52 50       	stdsp	sp[0x94],r0

80005458 <_stext>:

  .global _stext
  .type _stext, @function
_stext:
  // Set initial stack pointer.
  lda.w   sp, _estack
80005458:	e0 7d 80 00 	mov	sp,98304

  // Set up EVBA so interrupts can be enabled.
  lda.w   r0, _evba
  mtsr    AVR32_EVBA, r0
8000545c:	fe c0 8e 5c 	sub	r0,pc,-29092

  // Enable the exception processing.
  csrf    AVR32_SR_EM_OFFSET
80005460:	e3 b0 00 01 	mtsr	0x4,r0

  // Load initialized data having a global lifetime from the data LMA.
  lda.w   r0, _data
  lda.w   r1, _edata
80005464:	d5 53       	csrf	0x15
  cp      r0, r1
80005466:	30 40       	mov	r0,4
  brhs    idata_load_loop_end
80005468:	e0 61 0a 40 	mov	r1,2624
  lda.w   r2, _data_lma
idata_load_loop:
  ld.d    r4, r2++
8000546c:	02 30       	cp.w	r0,r1
  st.d    r0++, r4
8000546e:	c0 62       	brcc	8000547a <idata_load_loop_end>
  cp      r0, r1
80005470:	48 92       	lddpc	r2,80005494 <udata_clear_loop_end+0x4>

80005472 <idata_load_loop>:
  brlo    idata_load_loop
80005472:	a5 05       	ld.d	r4,r2++
idata_load_loop_end:

  // Clear uninitialized data having a global lifetime in the blank static storage section.
  lda.w   r0, __bss_start
80005474:	a1 24       	st.d	r0++,r4
  lda.w   r1, _end
80005476:	02 30       	cp.w	r0,r1
  cp      r0, r1
80005478:	cf d3       	brcs	80005472 <idata_load_loop>

8000547a <idata_load_loop_end>:
  brhs    udata_clear_loop_end
8000547a:	e0 60 0a 40 	mov	r0,2624
  mov     r2, 0
  mov     r3, 0
8000547e:	e0 61 63 a0 	mov	r1,25504
udata_clear_loop:
  st.d    r0++, r2
  cp      r0, r1
80005482:	02 30       	cp.w	r0,r1
  brlo    udata_clear_loop
80005484:	c0 62       	brcc	80005490 <udata_clear_loop_end>
  // Safety: Set the default "return" @ to the exit routine address.
  lda.w   lr, exit
#endif

  // Start the show.
  lda.w   pc, main
80005486:	30 02       	mov	r2,0
80005488:	30 03       	mov	r3,0

8000548a <udata_clear_loop>:
8000548a:	a1 22       	st.d	r0++,r2
8000548c:	02 30       	cp.w	r0,r1
8000548e:	cf e3       	brcs	8000548a <udata_clear_loop>

80005490 <udata_clear_loop_end>:
80005490:	fe cf e9 c4 	sub	pc,pc,-5692
80005494:	80 00       	ld.sh	r0,r0[0x0]
80005496:	d9 70       	acall	0x97

80005498 <vListInitialise>:
void vListInitialise( xList *pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
80005498:	f8 c8 ff f8 	sub	r8,r12,-8
8000549c:	99 18       	st.w	r12[0x4],r8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
8000549e:	3f f9       	mov	r9,-1
800054a0:	99 29       	st.w	r12[0x8],r9

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
800054a2:	99 38       	st.w	r12[0xc],r8
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
800054a4:	99 48       	st.w	r12[0x10],r8

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
800054a6:	30 08       	mov	r8,0
800054a8:	99 08       	st.w	r12[0x0],r8
}
800054aa:	5e fc       	retal	r12

800054ac <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
800054ac:	30 08       	mov	r8,0
800054ae:	99 48       	st.w	r12[0x10],r8
}
800054b0:	5e fc       	retal	r12

800054b2 <vListInsertEnd>:

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
800054b2:	78 18       	ld.w	r8,r12[0x4]

	pxNewListItem->pxNext = pxIndex->pxNext;
800054b4:	70 19       	ld.w	r9,r8[0x4]
800054b6:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxPrevious = pxList->pxIndex;
800054b8:	78 19       	ld.w	r9,r12[0x4]
800054ba:	97 29       	st.w	r11[0x8],r9
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
800054bc:	70 19       	ld.w	r9,r8[0x4]
800054be:	93 2b       	st.w	r9[0x8],r11
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
800054c0:	91 1b       	st.w	r8[0x4],r11
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
800054c2:	99 1b       	st.w	r12[0x4],r11

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
800054c4:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
800054c6:	78 08       	ld.w	r8,r12[0x0]
800054c8:	2f f8       	sub	r8,-1
800054ca:	99 08       	st.w	r12[0x0],r8
}
800054cc:	5e fc       	retal	r12

800054ce <vListInsert>:
{
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
800054ce:	76 0a       	ld.w	r10,r11[0x0]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
800054d0:	5b fa       	cp.w	r10,-1
800054d2:	c0 31       	brne	800054d8 <vListInsert+0xa>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
800054d4:	78 48       	ld.w	r8,r12[0x10]
800054d6:	c0 c8       	rjmp	800054ee <vListInsert+0x20>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
800054d8:	f8 c8 ff f8 	sub	r8,r12,-8
800054dc:	70 19       	ld.w	r9,r8[0x4]
800054de:	72 09       	ld.w	r9,r9[0x0]
800054e0:	12 3a       	cp.w	r10,r9
800054e2:	c0 63       	brcs	800054ee <vListInsert+0x20>
800054e4:	70 18       	ld.w	r8,r8[0x4]
800054e6:	70 19       	ld.w	r9,r8[0x4]
800054e8:	72 09       	ld.w	r9,r9[0x0]
800054ea:	12 3a       	cp.w	r10,r9
800054ec:	cf c2       	brcc	800054e4 <vListInsert+0x16>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
800054ee:	70 19       	ld.w	r9,r8[0x4]
800054f0:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
800054f2:	93 2b       	st.w	r9[0x8],r11
	pxNewListItem->pxPrevious = pxIterator;
800054f4:	97 28       	st.w	r11[0x8],r8
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
800054f6:	91 1b       	st.w	r8[0x4],r11

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
800054f8:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
800054fa:	78 08       	ld.w	r8,r12[0x0]
800054fc:	2f f8       	sub	r8,-1
800054fe:	99 08       	st.w	r12[0x0],r8
}
80005500:	5e fc       	retal	r12

80005502 <vListRemove>:

void vListRemove( xListItem *pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
80005502:	78 18       	ld.w	r8,r12[0x4]
80005504:	78 29       	ld.w	r9,r12[0x8]
80005506:	91 29       	st.w	r8[0x8],r9
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
80005508:	78 28       	ld.w	r8,r12[0x8]
8000550a:	78 19       	ld.w	r9,r12[0x4]
8000550c:	91 19       	st.w	r8[0x4],r9

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
8000550e:	78 48       	ld.w	r8,r12[0x10]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
80005510:	70 19       	ld.w	r9,r8[0x4]
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
80005512:	18 39       	cp.w	r9,r12
80005514:	f9 f9 00 02 	ld.weq	r9,r12[0x8]
80005518:	f1 f9 0a 01 	st.weq	r8[0x4],r9
	}

	pxItemToRemove->pvContainer = NULL;
8000551c:	30 09       	mov	r9,0
8000551e:	99 49       	st.w	r12[0x10],r9
	( pxList->uxNumberOfItems )--;
80005520:	70 09       	ld.w	r9,r8[0x0]
80005522:	20 19       	sub	r9,1
80005524:	91 09       	st.w	r8[0x0],r9
}
80005526:	5e fc       	retal	r12

80005528 <pxPortInitialiseStack>:
	/* Setup the initial stack of the task.  The stack is set exactly as
	expected by the portRESTORE_CONTEXT() macro. */

	/* When the task starts, it will expect to find the function parameter in R12. */
	pxTopOfStack--;
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x08080808;					/* R8 */
80005528:	e0 68 08 08 	mov	r8,2056
8000552c:	ea 18 08 08 	orh	r8,0x808
80005530:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x09090909;					/* R9 */
80005532:	e0 68 09 09 	mov	r8,2313
80005536:	ea 18 09 09 	orh	r8,0x909
8000553a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0A0A0A0A;					/* R10 */
8000553c:	e0 68 0a 0a 	mov	r8,2570
80005540:	ea 18 0a 0a 	orh	r8,0xa0a
80005544:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0B0B0B0B;					/* R11 */
80005546:	e0 68 0b 0b 	mov	r8,2827
8000554a:	ea 18 0b 0b 	orh	r8,0xb0b
8000554e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pvParameters;					/* R12 */
80005550:	18 da       	st.w	--r12,r10
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xDEADBEEF;					/* R14/LR */
80005552:	e0 68 be ef 	mov	r8,48879
80005556:	ea 18 de ad 	orh	r8,0xdead
8000555a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pxCode + portINSTRUCTION_SIZE; /* R15/PC */
8000555c:	18 db       	st.w	--r12,r11
	*pxTopOfStack-- = ( portSTACK_TYPE ) portINITIAL_SR;				/* SR */
8000555e:	fc 18 00 40 	movh	r8,0x40
80005562:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xFF0000FF;					/* R0 */
80005564:	e0 68 00 ff 	mov	r8,255
80005568:	ea 18 ff 00 	orh	r8,0xff00
8000556c:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x01010101;					/* R1 */
8000556e:	e0 68 01 01 	mov	r8,257
80005572:	ea 18 01 01 	orh	r8,0x101
80005576:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x02020202;					/* R2 */
80005578:	e0 68 02 02 	mov	r8,514
8000557c:	ea 18 02 02 	orh	r8,0x202
80005580:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x03030303;					/* R3 */
80005582:	e0 68 03 03 	mov	r8,771
80005586:	ea 18 03 03 	orh	r8,0x303
8000558a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x04040404;					/* R4 */
8000558c:	e0 68 04 04 	mov	r8,1028
80005590:	ea 18 04 04 	orh	r8,0x404
80005594:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x05050505;					/* R5 */
80005596:	e0 68 05 05 	mov	r8,1285
8000559a:	ea 18 05 05 	orh	r8,0x505
8000559e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x06060606;					/* R6 */
800055a0:	e0 68 06 06 	mov	r8,1542
800055a4:	ea 18 06 06 	orh	r8,0x606
800055a8:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x07070707;					/* R7 */
800055aa:	e0 68 07 07 	mov	r8,1799
800055ae:	ea 18 07 07 	orh	r8,0x707
800055b2:	18 d8       	st.w	--r12,r8
	*pxTopOfStack = ( portSTACK_TYPE ) portNO_CRITICAL_NESTING;			/* ulCriticalNesting */
800055b4:	30 08       	mov	r8,0
800055b6:	18 d8       	st.w	--r12,r8

	return pxTopOfStack;
}
800055b8:	5e fc       	retal	r12
800055ba:	d7 03       	nop

800055bc <vPortEnterCritical>:
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
__attribute__((__noinline__)) void vPortEnterCritical( void )
{
	/* Disable interrupts */
	portDISABLE_INTERRUPTS();
800055bc:	d3 03       	ssrf	0x10

	/* Now interrupts are disabled ulCriticalNesting can be accessed
	 directly.  Increment ulCriticalNesting to keep a count of how many times
	 portENTER_CRITICAL() has been called. */
	ulCriticalNesting++;
800055be:	48 38       	lddpc	r8,800055c8 <vPortEnterCritical+0xc>
800055c0:	70 09       	ld.w	r9,r8[0x0]
800055c2:	2f f9       	sub	r9,-1
800055c4:	91 09       	st.w	r8[0x0],r9
}
800055c6:	5e fc       	retal	r12
800055c8:	00 00       	add	r0,r0
800055ca:	05 30       	ld.ub	r0,r2++

800055cc <xPortStartScheduler>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
800055cc:	d4 01       	pushm	lr
	};

#endif

	/* Disable all interrupt/exception. */
	portDISABLE_INTERRUPTS();
800055ce:	d3 03       	ssrf	0x10
		/* Start the timer/counter. */
		tc_start(tc, configTICK_TC_CHANNEL);
	}
	#else
	{
		INTC_register_interrupt(&vTick, AVR32_CORE_COMPARE_IRQ, AVR32_INTC_INT0);
800055d0:	30 0a       	mov	r10,0
800055d2:	14 9b       	mov	r11,r10
800055d4:	49 2c       	lddpc	r12,8000561c <xPortStartScheduler+0x50>
800055d6:	f0 1f 00 13 	mcall	80005620 <xPortStartScheduler+0x54>
/* Schedule the COUNT&COMPARE match interrupt in (configCPU_CLOCK_HZ/configTICK_RATE_HZ)
clock cycles from now. */
#if( configTICK_USE_TC==0 )
	static void prvScheduleFirstTick(void)
	{
		Set_system_register(AVR32_COMPARE, configCPU_CLOCK_HZ/configTICK_RATE_HZ);//cause!!!
800055da:	e0 68 5d c0 	mov	r8,24000
800055de:	e3 b8 00 43 	mtsr	0x10c,r8
		Set_system_register(AVR32_COUNT, 0);
800055e2:	30 08       	mov	r8,0
800055e4:	e3 b8 00 42 	mtsr	0x108,r8
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();

	/* Start the first task. */
	portRESTORE_CONTEXT();
800055e8:	e0 68 0c dc 	mov	r8,3292
800055ec:	ea 18 00 00 	orh	r8,0x0
800055f0:	70 00       	ld.w	r0,r8[0x0]
800055f2:	60 0d       	ld.w	sp,r0[0x0]
800055f4:	1b 00       	ld.w	r0,sp++
800055f6:	e0 68 05 30 	mov	r8,1328
800055fa:	ea 18 00 00 	orh	r8,0x0
800055fe:	91 00       	st.w	r8[0x0],r0
80005600:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005604:	2f ed       	sub	sp,-8
80005606:	e3 cd 5f 00 	ldm	sp++,r8-r12,lr
8000560a:	fa f0 ff e0 	ld.w	r0,sp[-32]
8000560e:	e3 b0 00 00 	mtsr	0x0,r0
80005612:	fa f0 ff dc 	ld.w	r0,sp[-36]
80005616:	fa ff ff e4 	ld.w	pc,sp[-28]

	/* Should not get here! */
	return 0;
}
8000561a:	d8 0a       	popm	pc,r12=0
8000561c:	80 00       	ld.sh	r0,r0[0x0]
8000561e:	56 e8       	stdsp	sp[0x1b8],r8
80005620:	80 00       	ld.sh	r0,r0[0x0]
80005622:	4e dc       	lddpc	r12,800057d4 <_write+0x10>

80005624 <SCALLYield>:
/*-----------------------------------------------------------*/
__attribute__((__naked__)) void SCALLYield( void );
__attribute__((__naked__)) void SCALLYield( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_SCALL();
80005624:	20 6d       	sub	sp,24
80005626:	eb cd 00 ff 	pushm	r0-r7
8000562a:	fa c7 ff c0 	sub	r7,sp,-64
8000562e:	ee f0 ff f8 	ld.w	r0,r7[-8]
80005632:	ef 40 ff e0 	st.w	r7[-32],r0
80005636:	ee f0 ff fc 	ld.w	r0,r7[-4]
8000563a:	ef 40 ff e4 	st.w	r7[-28],r0
8000563e:	eb c7 5f 00 	stm	--r7,r8-r12,lr
80005642:	e0 68 05 30 	mov	r8,1328
80005646:	ea 18 00 00 	orh	r8,0x0
8000564a:	70 00       	ld.w	r0,r8[0x0]
8000564c:	1a d0       	st.w	--sp,r0
8000564e:	f0 1f 00 1a 	mcall	800056b4 <LABEL_RET_SCALL_263+0x14>
80005652:	e0 68 0c dc 	mov	r8,3292
80005656:	ea 18 00 00 	orh	r8,0x0
8000565a:	70 00       	ld.w	r0,r8[0x0]
8000565c:	81 0d       	st.w	r0[0x0],sp
	vTaskSwitchContext();
8000565e:	f0 1f 00 17 	mcall	800056b8 <LABEL_RET_SCALL_263+0x18>
	portRESTORE_CONTEXT_SCALL();
80005662:	e0 68 0c dc 	mov	r8,3292
80005666:	ea 18 00 00 	orh	r8,0x0
8000566a:	70 00       	ld.w	r0,r8[0x0]
8000566c:	60 0d       	ld.w	sp,r0[0x0]
8000566e:	1b 00       	ld.w	r0,sp++
80005670:	e0 68 05 30 	mov	r8,1328
80005674:	ea 18 00 00 	orh	r8,0x0
80005678:	91 00       	st.w	r8[0x0],r0
8000567a:	fa c7 ff d8 	sub	r7,sp,-40
8000567e:	e3 c7 5f 00 	ldm	r7++,r8-r12,lr
80005682:	ee f0 ff e0 	ld.w	r0,r7[-32]
80005686:	e0 61 05 30 	mov	r1,1328
8000568a:	ea 11 00 00 	orh	r1,0x0
8000568e:	62 02       	ld.w	r2,r1[0x0]
80005690:	58 02       	cp.w	r2,0
80005692:	c0 70       	breq	800056a0 <LABEL_RET_SCALL_263>
80005694:	e4 c2 00 01 	sub	r2,r2,1
80005698:	83 02       	st.w	r1[0x0],r2
8000569a:	58 02       	cp.w	r2,0
8000569c:	c0 21       	brne	800056a0 <LABEL_RET_SCALL_263>
8000569e:	b1 c0       	cbr	r0,0x10

800056a0 <LABEL_RET_SCALL_263>:
800056a0:	ef 40 ff f8 	st.w	r7[-8],r0
800056a4:	ee f0 ff e4 	ld.w	r0,r7[-28]
800056a8:	ef 40 ff fc 	st.w	r7[-4],r0
800056ac:	e3 cd 00 ff 	ldm	sp++,r0-r7
800056b0:	2f ad       	sub	sp,-24
800056b2:	d6 13       	rets
800056b4:	80 00       	ld.sh	r0,r0[0x0]
800056b6:	55 bc       	stdsp	sp[0x16c],r12
800056b8:	80 00       	ld.sh	r0,r0[0x0]
800056ba:	5d 00       	ror	r0

800056bc <prvClearCcInt>:
		Set_system_register(AVR32_COUNT, 0);
	}

	__attribute__((__noinline__)) static void prvClearCcInt(void)
	{
		Set_system_register(AVR32_COMPARE, Get_system_register(AVR32_COMPARE));
800056bc:	e1 b8 00 43 	mfsr	r8,0x10c
800056c0:	e3 b8 00 43 	mtsr	0x10c,r8
	}
800056c4:	5e fc       	retal	r12
800056c6:	d7 03       	nop

800056c8 <vPortExitCritical>:
}
/*-----------------------------------------------------------*/

__attribute__((__noinline__)) void vPortExitCritical( void )
{
	if(ulCriticalNesting > portNO_CRITICAL_NESTING)
800056c8:	48 78       	lddpc	r8,800056e4 <vPortExitCritical+0x1c>
800056ca:	70 08       	ld.w	r8,r8[0x0]
800056cc:	58 08       	cp.w	r8,0
800056ce:	5e 0c       	reteq	r12
	{
		ulCriticalNesting--;
800056d0:	48 58       	lddpc	r8,800056e4 <vPortExitCritical+0x1c>
800056d2:	70 09       	ld.w	r9,r8[0x0]
800056d4:	20 19       	sub	r9,1
800056d6:	91 09       	st.w	r8[0x0],r9
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
800056d8:	70 08       	ld.w	r8,r8[0x0]
800056da:	58 08       	cp.w	r8,0
800056dc:	5e 1c       	retne	r12
		{
			/* Enable all interrupt/exception. */
			portENABLE_INTERRUPTS();
800056de:	d5 03       	csrf	0x10
800056e0:	5e fc       	retal	r12
800056e2:	00 00       	add	r0,r0
800056e4:	00 00       	add	r0,r0
800056e6:	05 30       	ld.ub	r0,r2++

800056e8 <vTick>:
/* The preemptive scheduler is defined as "naked" as the full context is saved
on entry as part of the context switch. */
__attribute__((__naked__)) static void vTick( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_OS_INT();
800056e8:	eb cd 00 ff 	pushm	r0-r7
800056ec:	e0 68 05 30 	mov	r8,1328
800056f0:	ea 18 00 00 	orh	r8,0x0
800056f4:	70 00       	ld.w	r0,r8[0x0]
800056f6:	1a d0       	st.w	--sp,r0
800056f8:	7a 90       	ld.w	r0,sp[0x24]
800056fa:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
800056fe:	58 10       	cp.w	r0,1
80005700:	e0 8b 00 08 	brhi	80005710 <LABEL_INT_SKIP_SAVE_CONTEXT_237>
80005704:	e0 68 0c dc 	mov	r8,3292
80005708:	ea 18 00 00 	orh	r8,0x0
8000570c:	70 00       	ld.w	r0,r8[0x0]
8000570e:	81 0d       	st.w	r0[0x0],sp

80005710 <LABEL_INT_SKIP_SAVE_CONTEXT_237>:
	#if( configTICK_USE_TC==1 )
		/* Clear the interrupt flag. */
		prvClearTcInt();
	#else
		/* Clear the interrupt flag. */
		prvClearCcInt();
80005710:	f0 1f 00 12 	mcall	80005758 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x14>
	#endif

	/* Because FreeRTOS is not supposed to run with nested interrupts, put all OS
	calls in a critical section . */
	portENTER_CRITICAL();
80005714:	f0 1f 00 12 	mcall	8000575c <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
		vTaskIncrementTick();
80005718:	f0 1f 00 12 	mcall	80005760 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x1c>
	portEXIT_CRITICAL();
8000571c:	f0 1f 00 12 	mcall	80005764 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>

	/* Restore the context of the "elected task". */
	portRESTORE_CONTEXT_OS_INT();
80005720:	7a 90       	ld.w	r0,sp[0x24]
80005722:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80005726:	58 10       	cp.w	r0,1
80005728:	e0 8b 00 0e 	brhi	80005744 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>
8000572c:	f0 1f 00 0c 	mcall	8000575c <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
80005730:	f0 1f 00 0e 	mcall	80005768 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x24>
80005734:	f0 1f 00 0c 	mcall	80005764 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>
80005738:	e0 68 0c dc 	mov	r8,3292
8000573c:	ea 18 00 00 	orh	r8,0x0
80005740:	70 00       	ld.w	r0,r8[0x0]
80005742:	60 0d       	ld.w	sp,r0[0x0]

80005744 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>:
80005744:	1b 00       	ld.w	r0,sp++
80005746:	e0 68 05 30 	mov	r8,1328
8000574a:	ea 18 00 00 	orh	r8,0x0
8000574e:	91 00       	st.w	r8[0x0],r0
80005750:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005754:	d6 03       	rete
80005756:	00 00       	add	r0,r0
80005758:	80 00       	ld.sh	r0,r0[0x0]
8000575a:	56 bc       	stdsp	sp[0x1ac],r12
8000575c:	80 00       	ld.sh	r0,r0[0x0]
8000575e:	55 bc       	stdsp	sp[0x16c],r12
80005760:	80 00       	ld.sh	r0,r0[0x0]
80005762:	5f 04       	sreq	r4
80005764:	80 00       	ld.sh	r0,r0[0x0]
80005766:	56 c8       	stdsp	sp[0x1b0],r8
80005768:	80 00       	ld.sh	r0,r0[0x0]
8000576a:	5d 00       	ror	r0

8000576c <__malloc_lock>:
 * safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_lock(struct _reent *ptr);
void __malloc_lock(struct _reent *ptr)
{
8000576c:	d4 01       	pushm	lr
	vTaskSuspendAll();
8000576e:	f0 1f 00 02 	mcall	80005774 <__malloc_lock+0x8>
}
80005772:	d8 02       	popm	pc
80005774:	80 00       	ld.sh	r0,r0[0x0]
80005776:	5c f0       	rol	r0

80005778 <__malloc_unlock>:
 * a safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_unlock(struct _reent *ptr);
void __malloc_unlock(struct _reent *ptr)
{
80005778:	d4 01       	pushm	lr
	xTaskResumeAll();
8000577a:	f0 1f 00 02 	mcall	80005780 <__malloc_unlock+0x8>
}
8000577e:	d8 02       	popm	pc
80005780:	80 00       	ld.sh	r0,r0[0x0]
80005782:	60 ac       	ld.w	r12,r0[0x28]

80005784 <_read>:
/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
{
80005784:	d4 21       	pushm	r4-r7,lr
80005786:	16 95       	mov	r5,r11
80005788:	14 96       	mov	r6,r10
  int nChars = 0;

  if (file != 0)
8000578a:	58 0c       	cp.w	r12,0
8000578c:	c0 30       	breq	80005792 <_read+0xe>
8000578e:	3f f7       	mov	r7,-1
80005790:	c1 48       	rjmp	800057b8 <_read+0x34>
    return -1;

  for (; len > 0; --len)
80005792:	58 0a       	cp.w	r10,0
80005794:	e0 89 00 04 	brgt	8000579c <_read+0x18>
80005798:	30 07       	mov	r7,0
8000579a:	c0 f8       	rjmp	800057b8 <_read+0x34>
8000579c:	30 07       	mov	r7,0
  {
    int c = usart_getchar(stdio_usart_base);
8000579e:	48 84       	lddpc	r4,800057bc <_read+0x38>
800057a0:	68 0c       	ld.w	r12,r4[0x0]
800057a2:	f0 1f 00 08 	mcall	800057c0 <_read+0x3c>
    if (c < 0)
800057a6:	c0 95       	brlt	800057b8 <_read+0x34>
      break;

    *ptr++ = c;
800057a8:	ea 07 0b 0c 	st.b	r5[r7],r12
    ++nChars;
800057ac:	2f f7       	sub	r7,-1

/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
800057ae:	ec 07 01 08 	sub	r8,r6,r7
  int nChars = 0;

  if (file != 0)
    return -1;

  for (; len > 0; --len)
800057b2:	58 08       	cp.w	r8,0
800057b4:	fe 99 ff f6 	brgt	800057a0 <_read+0x1c>
    *ptr++ = c;
    ++nChars;
  }

  return nChars;
}
800057b8:	0e 9c       	mov	r12,r7
800057ba:	d8 22       	popm	r4-r7,pc
800057bc:	00 00       	add	r0,r0
800057be:	63 94       	ld.w	r4,r1[0x64]
800057c0:	80 00       	ld.sh	r0,r0[0x0]
800057c2:	53 10       	stdsp	sp[0xc4],r0

800057c4 <_write>:
 * 1 and 2 is stdout and stderr which goes to usart
 * 3 is framebuffer
 */
int __attribute__((weak))
_write (int file, char * ptr, int len)
{
800057c4:	d4 21       	pushm	r4-r7,lr
800057c6:	16 95       	mov	r5,r11
800057c8:	14 96       	mov	r6,r10
  int nChars = 0;

  if ( (file != 1)
800057ca:	20 1c       	sub	r12,1
800057cc:	58 2c       	cp.w	r12,2
800057ce:	e0 8b 00 12 	brhi	800057f2 <_write+0x2e>
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
800057d2:	58 0a       	cp.w	r10,0
800057d4:	c0 31       	brne	800057da <_write+0x16>
800057d6:	30 07       	mov	r7,0
800057d8:	c0 e8       	rjmp	800057f4 <_write+0x30>
800057da:	30 07       	mov	r7,0
  {
    if (usart_putchar(stdio_usart_base, *ptr++) < 0)
800057dc:	48 74       	lddpc	r4,800057f8 <_write+0x34>
800057de:	68 0c       	ld.w	r12,r4[0x0]
800057e0:	ea 07 07 0b 	ld.ub	r11,r5[r7]
800057e4:	f0 1f 00 06 	mcall	800057fc <_write+0x38>
800057e8:	c0 55       	brlt	800057f2 <_write+0x2e>
    {
      return -1;
    }

    ++nChars;
800057ea:	2f f7       	sub	r7,-1

  if ( (file != 1)
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
800057ec:	0e 36       	cp.w	r6,r7
800057ee:	cf 81       	brne	800057de <_write+0x1a>
800057f0:	c0 28       	rjmp	800057f4 <_write+0x30>
800057f2:	3f f7       	mov	r7,-1

    ++nChars;
  }

  return nChars;
}
800057f4:	0e 9c       	mov	r12,r7
800057f6:	d8 22       	popm	r4-r7,pc
800057f8:	00 00       	add	r0,r0
800057fa:	63 94       	ld.w	r4,r1[0x64]
800057fc:	80 00       	ld.sh	r0,r0[0x0]
800057fe:	52 c0       	stdsp	sp[0xb0],r0

80005800 <vPortFree>:
	return pvReturn;
}
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
80005800:	eb cd 40 80 	pushm	r7,lr
80005804:	18 97       	mov	r7,r12
	if( pv )
80005806:	58 0c       	cp.w	r12,0
80005808:	c0 80       	breq	80005818 <vPortFree+0x18>
	{
		vTaskSuspendAll();
8000580a:	f0 1f 00 05 	mcall	8000581c <vPortFree+0x1c>
		{
			free( pv );
8000580e:	0e 9c       	mov	r12,r7
80005810:	f0 1f 00 04 	mcall	80005820 <vPortFree+0x20>
		}
		xTaskResumeAll();
80005814:	f0 1f 00 04 	mcall	80005824 <vPortFree+0x24>
80005818:	e3 cd 80 80 	ldm	sp++,r7,pc
8000581c:	80 00       	ld.sh	r0,r0[0x0]
8000581e:	5c f0       	rol	r0
80005820:	80 00       	ld.sh	r0,r0[0x0]
80005822:	6b 34       	ld.w	r4,r5[0x4c]
80005824:	80 00       	ld.sh	r0,r0[0x0]
80005826:	60 ac       	ld.w	r12,r0[0x28]

80005828 <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
80005828:	eb cd 40 80 	pushm	r7,lr
8000582c:	18 97       	mov	r7,r12
void *pvReturn;

	vTaskSuspendAll();
8000582e:	f0 1f 00 06 	mcall	80005844 <pvPortMalloc+0x1c>
	{
		pvReturn = malloc( xWantedSize );
80005832:	0e 9c       	mov	r12,r7
80005834:	f0 1f 00 05 	mcall	80005848 <pvPortMalloc+0x20>
80005838:	18 97       	mov	r7,r12
	}
	xTaskResumeAll();
8000583a:	f0 1f 00 05 	mcall	8000584c <pvPortMalloc+0x24>
		}
	}
	#endif

	return pvReturn;
}
8000583e:	0e 9c       	mov	r12,r7
80005840:	e3 cd 80 80 	ldm	sp++,r7,pc
80005844:	80 00       	ld.sh	r0,r0[0x0]
80005846:	5c f0       	rol	r0
80005848:	80 00       	ld.sh	r0,r0[0x0]
8000584a:	6b 44       	ld.w	r4,r5[0x50]
8000584c:	80 00       	ld.sh	r0,r0[0x0]
8000584e:	60 ac       	ld.w	r12,r0[0x28]

80005850 <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
80005850:	d4 01       	pushm	lr
80005852:	16 98       	mov	r8,r11
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
80005854:	78 09       	ld.w	r9,r12[0x0]
80005856:	58 09       	cp.w	r9,0
80005858:	c1 10       	breq	8000587a <prvCopyDataFromQueue+0x2a>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
8000585a:	78 3a       	ld.w	r10,r12[0xc]
8000585c:	79 09       	ld.w	r9,r12[0x40]
8000585e:	f4 09 00 09 	add	r9,r10,r9
80005862:	99 39       	st.w	r12[0xc],r9
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
80005864:	78 1a       	ld.w	r10,r12[0x4]
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
80005866:	14 39       	cp.w	r9,r10
80005868:	f9 f9 20 00 	ld.wcc	r9,r12[0x0]
8000586c:	f9 f9 2a 03 	st.wcc	r12[0xc],r9
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
80005870:	79 0a       	ld.w	r10,r12[0x40]
80005872:	78 3b       	ld.w	r11,r12[0xc]
80005874:	10 9c       	mov	r12,r8
80005876:	f0 1f 00 02 	mcall	8000587c <prvCopyDataFromQueue+0x2c>
8000587a:	d8 02       	popm	pc
8000587c:	80 00       	ld.sh	r0,r0[0x0]
8000587e:	6f b2       	ld.w	r2,r7[0x6c]

80005880 <xQueueReceiveFromISR>:
	}
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
80005880:	eb cd 40 c0 	pushm	r6-r7,lr
80005884:	18 97       	mov	r7,r12
80005886:	14 96       	mov	r6,r10
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80005888:	78 e8       	ld.w	r8,r12[0x38]
8000588a:	58 08       	cp.w	r8,0
8000588c:	c0 31       	brne	80005892 <xQueueReceiveFromISR+0x12>
8000588e:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
80005892:	f0 1f 00 0e 	mcall	800058c8 <xQueueReceiveFromISR+0x48>
			--( pxQueue->uxMessagesWaiting );
80005896:	6e e8       	ld.w	r8,r7[0x38]
80005898:	20 18       	sub	r8,1
8000589a:	8f e8       	st.w	r7[0x38],r8

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
8000589c:	6f 18       	ld.w	r8,r7[0x44]
8000589e:	5b f8       	cp.w	r8,-1
800058a0:	c0 d1       	brne	800058ba <xQueueReceiveFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
800058a2:	6e 48       	ld.w	r8,r7[0x10]
800058a4:	58 08       	cp.w	r8,0
800058a6:	c0 f0       	breq	800058c4 <xQueueReceiveFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
800058a8:	ee cc ff f0 	sub	r12,r7,-16
800058ac:	f0 1f 00 08 	mcall	800058cc <xQueueReceiveFromISR+0x4c>
800058b0:	c0 a0       	breq	800058c4 <xQueueReceiveFromISR+0x44>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
800058b2:	30 1c       	mov	r12,1
800058b4:	8d 0c       	st.w	r6[0x0],r12
800058b6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
800058ba:	2f f8       	sub	r8,-1
800058bc:	ef 48 00 44 	st.w	r7[68],r8
800058c0:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
800058c4:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
800058c8:	80 00       	ld.sh	r0,r0[0x0]
800058ca:	58 50       	cp.w	r0,5
800058cc:	80 00       	ld.sh	r0,r0[0x0]
800058ce:	5e 88       	retls	r8

800058d0 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
800058d0:	eb cd 40 c0 	pushm	r6-r7,lr
800058d4:	18 97       	mov	r7,r12

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
800058d6:	f0 1f 00 23 	mcall	80005960 <prvUnlockQueue+0x90>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
800058da:	6f 28       	ld.w	r8,r7[0x48]
800058dc:	58 08       	cp.w	r8,0
800058de:	e0 8a 00 18 	brle	8000590e <prvUnlockQueue+0x3e>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
800058e2:	6e 98       	ld.w	r8,r7[0x24]
800058e4:	58 08       	cp.w	r8,0
800058e6:	c1 40       	breq	8000590e <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
800058e8:	ee c6 ff dc 	sub	r6,r7,-36
800058ec:	c0 48       	rjmp	800058f4 <prvUnlockQueue+0x24>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
800058ee:	6e 98       	ld.w	r8,r7[0x24]
800058f0:	58 08       	cp.w	r8,0
800058f2:	c0 e0       	breq	8000590e <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
800058f4:	0c 9c       	mov	r12,r6
800058f6:	f0 1f 00 1c 	mcall	80005964 <prvUnlockQueue+0x94>
800058fa:	c0 30       	breq	80005900 <prvUnlockQueue+0x30>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
800058fc:	f0 1f 00 1b 	mcall	80005968 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xTxLock );
80005900:	6f 28       	ld.w	r8,r7[0x48]
80005902:	20 18       	sub	r8,1
80005904:	ef 48 00 48 	st.w	r7[72],r8
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80005908:	58 08       	cp.w	r8,0
8000590a:	fe 99 ff f2 	brgt	800058ee <prvUnlockQueue+0x1e>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
8000590e:	3f f8       	mov	r8,-1
80005910:	ef 48 00 48 	st.w	r7[72],r8
	}
	taskEXIT_CRITICAL();
80005914:	f0 1f 00 16 	mcall	8000596c <prvUnlockQueue+0x9c>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
80005918:	f0 1f 00 12 	mcall	80005960 <prvUnlockQueue+0x90>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
8000591c:	6f 18       	ld.w	r8,r7[0x44]
8000591e:	58 08       	cp.w	r8,0
80005920:	e0 8a 00 18 	brle	80005950 <prvUnlockQueue+0x80>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80005924:	6e 48       	ld.w	r8,r7[0x10]
80005926:	58 08       	cp.w	r8,0
80005928:	c1 40       	breq	80005950 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
8000592a:	ee c6 ff f0 	sub	r6,r7,-16
8000592e:	c0 48       	rjmp	80005936 <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80005930:	6e 48       	ld.w	r8,r7[0x10]
80005932:	58 08       	cp.w	r8,0
80005934:	c0 e0       	breq	80005950 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80005936:	0c 9c       	mov	r12,r6
80005938:	f0 1f 00 0b 	mcall	80005964 <prvUnlockQueue+0x94>
8000593c:	c0 30       	breq	80005942 <prvUnlockQueue+0x72>
				{
					vTaskMissedYield();
8000593e:	f0 1f 00 0b 	mcall	80005968 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xRxLock );
80005942:	6f 18       	ld.w	r8,r7[0x44]
80005944:	20 18       	sub	r8,1
80005946:	ef 48 00 44 	st.w	r7[68],r8
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
8000594a:	58 08       	cp.w	r8,0
8000594c:	fe 99 ff f2 	brgt	80005930 <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
80005950:	3f f8       	mov	r8,-1
80005952:	ef 48 00 44 	st.w	r7[68],r8
	}
	taskEXIT_CRITICAL();
80005956:	f0 1f 00 06 	mcall	8000596c <prvUnlockQueue+0x9c>
}
8000595a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000595e:	00 00       	add	r0,r0
80005960:	80 00       	ld.sh	r0,r0[0x0]
80005962:	55 bc       	stdsp	sp[0x16c],r12
80005964:	80 00       	ld.sh	r0,r0[0x0]
80005966:	5e 88       	retls	r8
80005968:	80 00       	ld.sh	r0,r0[0x0]
8000596a:	5d 94       	*unknown*
8000596c:	80 00       	ld.sh	r0,r0[0x0]
8000596e:	56 c8       	stdsp	sp[0x1b0],r8

80005970 <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
80005970:	d4 31       	pushm	r0-r7,lr
80005972:	20 5d       	sub	sp,20
80005974:	18 97       	mov	r7,r12
80005976:	50 0b       	stdsp	sp[0x0],r11
80005978:	50 2a       	stdsp	sp[0x8],r10
8000597a:	50 19       	stdsp	sp[0x4],r9
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
8000597c:	f8 c2 ff dc 	sub	r2,r12,-36
80005980:	30 05       	mov	r5,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80005982:	fa c4 ff f4 	sub	r4,sp,-12
80005986:	30 10       	mov	r0,1

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
80005988:	0a 91       	mov	r1,r5

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
8000598a:	fa c3 ff f8 	sub	r3,sp,-8
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
8000598e:	f0 1f 00 3e 	mcall	80005a84 <xQueueGenericReceive+0x114>
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80005992:	6e e8       	ld.w	r8,r7[0x38]
80005994:	58 08       	cp.w	r8,0
80005996:	c2 a0       	breq	800059ea <xQueueGenericReceive+0x7a>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
80005998:	6e 36       	ld.w	r6,r7[0xc]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
8000599a:	40 0b       	lddsp	r11,sp[0x0]
8000599c:	0e 9c       	mov	r12,r7
8000599e:	f0 1f 00 3b 	mcall	80005a88 <xQueueGenericReceive+0x118>

				if( xJustPeeking == pdFALSE )
800059a2:	40 18       	lddsp	r8,sp[0x4]
800059a4:	58 08       	cp.w	r8,0
800059a6:	c1 51       	brne	800059d0 <xQueueGenericReceive+0x60>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
800059a8:	6e e8       	ld.w	r8,r7[0x38]
800059aa:	20 18       	sub	r8,1
800059ac:	8f e8       	st.w	r7[0x38],r8

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
800059ae:	6e 08       	ld.w	r8,r7[0x0]
800059b0:	58 08       	cp.w	r8,0
800059b2:	c0 41       	brne	800059ba <xQueueGenericReceive+0x4a>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
800059b4:	f0 1f 00 36 	mcall	80005a8c <xQueueGenericReceive+0x11c>
800059b8:	8f 1c       	st.w	r7[0x4],r12
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
800059ba:	6e 48       	ld.w	r8,r7[0x10]
800059bc:	58 08       	cp.w	r8,0
800059be:	c1 20       	breq	800059e2 <xQueueGenericReceive+0x72>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
800059c0:	ee cc ff f0 	sub	r12,r7,-16
800059c4:	f0 1f 00 33 	mcall	80005a90 <xQueueGenericReceive+0x120>
800059c8:	58 1c       	cp.w	r12,1
800059ca:	c0 c1       	brne	800059e2 <xQueueGenericReceive+0x72>
						{
							portYIELD_WITHIN_API();
800059cc:	d7 33       	scall
800059ce:	c0 a8       	rjmp	800059e2 <xQueueGenericReceive+0x72>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
800059d0:	8f 36       	st.w	r7[0xc],r6

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
800059d2:	6e 98       	ld.w	r8,r7[0x24]
800059d4:	58 08       	cp.w	r8,0
800059d6:	c0 60       	breq	800059e2 <xQueueGenericReceive+0x72>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
800059d8:	04 9c       	mov	r12,r2
800059da:	f0 1f 00 2e 	mcall	80005a90 <xQueueGenericReceive+0x120>
800059de:	c0 20       	breq	800059e2 <xQueueGenericReceive+0x72>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
800059e0:	d7 33       	scall
						}
					}

				}

				taskEXIT_CRITICAL();
800059e2:	f0 1f 00 2d 	mcall	80005a94 <xQueueGenericReceive+0x124>
800059e6:	30 1c       	mov	r12,1
				return pdPASS;
800059e8:	c4 c8       	rjmp	80005a80 <xQueueGenericReceive+0x110>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
800059ea:	40 28       	lddsp	r8,sp[0x8]
800059ec:	58 08       	cp.w	r8,0
800059ee:	c0 51       	brne	800059f8 <xQueueGenericReceive+0x88>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
800059f0:	f0 1f 00 29 	mcall	80005a94 <xQueueGenericReceive+0x124>
800059f4:	30 0c       	mov	r12,0
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
800059f6:	c4 58       	rjmp	80005a80 <xQueueGenericReceive+0x110>
				}
				else if( xEntryTimeSet == pdFALSE )
800059f8:	58 05       	cp.w	r5,0
800059fa:	c0 51       	brne	80005a04 <xQueueGenericReceive+0x94>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
800059fc:	08 9c       	mov	r12,r4
800059fe:	f0 1f 00 27 	mcall	80005a98 <xQueueGenericReceive+0x128>
80005a02:	00 95       	mov	r5,r0
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80005a04:	f0 1f 00 24 	mcall	80005a94 <xQueueGenericReceive+0x124>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80005a08:	f0 1f 00 25 	mcall	80005a9c <xQueueGenericReceive+0x12c>
		prvLockQueue( pxQueue );
80005a0c:	f0 1f 00 1e 	mcall	80005a84 <xQueueGenericReceive+0x114>
80005a10:	6f 18       	ld.w	r8,r7[0x44]
80005a12:	5b f8       	cp.w	r8,-1
80005a14:	ef f1 0a 11 	st.weq	r7[0x44],r1
80005a18:	6f 28       	ld.w	r8,r7[0x48]
80005a1a:	5b f8       	cp.w	r8,-1
80005a1c:	ef f1 0a 12 	st.weq	r7[0x48],r1
80005a20:	f0 1f 00 1d 	mcall	80005a94 <xQueueGenericReceive+0x124>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80005a24:	06 9b       	mov	r11,r3
80005a26:	08 9c       	mov	r12,r4
80005a28:	f0 1f 00 1e 	mcall	80005aa0 <xQueueGenericReceive+0x130>
80005a2c:	c2 41       	brne	80005a74 <xQueueGenericReceive+0x104>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
80005a2e:	f0 1f 00 16 	mcall	80005a84 <xQueueGenericReceive+0x114>
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
80005a32:	6e e6       	ld.w	r6,r7[0x38]
	taskEXIT_CRITICAL();
80005a34:	f0 1f 00 18 	mcall	80005a94 <xQueueGenericReceive+0x124>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) )
80005a38:	58 06       	cp.w	r6,0
80005a3a:	c1 71       	brne	80005a68 <xQueueGenericReceive+0xf8>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80005a3c:	6e 08       	ld.w	r8,r7[0x0]
80005a3e:	58 08       	cp.w	r8,0
80005a40:	c0 81       	brne	80005a50 <xQueueGenericReceive+0xe0>
					{
						portENTER_CRITICAL();
80005a42:	f0 1f 00 11 	mcall	80005a84 <xQueueGenericReceive+0x114>
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
80005a46:	6e 1c       	ld.w	r12,r7[0x4]
80005a48:	f0 1f 00 17 	mcall	80005aa4 <xQueueGenericReceive+0x134>
						}
						portEXIT_CRITICAL();
80005a4c:	f0 1f 00 12 	mcall	80005a94 <xQueueGenericReceive+0x124>
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80005a50:	40 2b       	lddsp	r11,sp[0x8]
80005a52:	04 9c       	mov	r12,r2
80005a54:	f0 1f 00 15 	mcall	80005aa8 <xQueueGenericReceive+0x138>
				prvUnlockQueue( pxQueue );
80005a58:	0e 9c       	mov	r12,r7
80005a5a:	f0 1f 00 15 	mcall	80005aac <xQueueGenericReceive+0x13c>
				if( !xTaskResumeAll() )
80005a5e:	f0 1f 00 15 	mcall	80005ab0 <xQueueGenericReceive+0x140>
80005a62:	c9 61       	brne	8000598e <xQueueGenericReceive+0x1e>
				{
					portYIELD_WITHIN_API();
80005a64:	d7 33       	scall
80005a66:	c9 4b       	rjmp	8000598e <xQueueGenericReceive+0x1e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
80005a68:	0e 9c       	mov	r12,r7
80005a6a:	f0 1f 00 11 	mcall	80005aac <xQueueGenericReceive+0x13c>
				( void ) xTaskResumeAll();
80005a6e:	f0 1f 00 11 	mcall	80005ab0 <xQueueGenericReceive+0x140>
80005a72:	c8 eb       	rjmp	8000598e <xQueueGenericReceive+0x1e>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
80005a74:	0e 9c       	mov	r12,r7
80005a76:	f0 1f 00 0e 	mcall	80005aac <xQueueGenericReceive+0x13c>
			( void ) xTaskResumeAll();
80005a7a:	f0 1f 00 0e 	mcall	80005ab0 <xQueueGenericReceive+0x140>
80005a7e:	30 0c       	mov	r12,0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
80005a80:	2f bd       	sub	sp,-20
80005a82:	d8 32       	popm	r0-r7,pc
80005a84:	80 00       	ld.sh	r0,r0[0x0]
80005a86:	55 bc       	stdsp	sp[0x16c],r12
80005a88:	80 00       	ld.sh	r0,r0[0x0]
80005a8a:	58 50       	cp.w	r0,5
80005a8c:	80 00       	ld.sh	r0,r0[0x0]
80005a8e:	5d a0       	*unknown*
80005a90:	80 00       	ld.sh	r0,r0[0x0]
80005a92:	5e 88       	retls	r8
80005a94:	80 00       	ld.sh	r0,r0[0x0]
80005a96:	56 c8       	stdsp	sp[0x1b0],r8
80005a98:	80 00       	ld.sh	r0,r0[0x0]
80005a9a:	5d 7c       	*unknown*
80005a9c:	80 00       	ld.sh	r0,r0[0x0]
80005a9e:	5c f0       	rol	r0
80005aa0:	80 00       	ld.sh	r0,r0[0x0]
80005aa2:	60 18       	ld.w	r8,r0[0x4]
80005aa4:	80 00       	ld.sh	r0,r0[0x0]
80005aa6:	5e 04       	reteq	r4
80005aa8:	80 00       	ld.sh	r0,r0[0x0]
80005aaa:	62 70       	ld.w	r0,r1[0x1c]
80005aac:	80 00       	ld.sh	r0,r0[0x0]
80005aae:	58 d0       	cp.w	r0,13
80005ab0:	80 00       	ld.sh	r0,r0[0x0]
80005ab2:	60 ac       	ld.w	r12,r0[0x28]

80005ab4 <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
80005ab4:	eb cd 40 80 	pushm	r7,lr
80005ab8:	18 97       	mov	r7,r12
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
80005aba:	79 08       	ld.w	r8,r12[0x40]
80005abc:	58 08       	cp.w	r8,0
80005abe:	c0 a1       	brne	80005ad2 <prvCopyDataToQueue+0x1e>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80005ac0:	78 08       	ld.w	r8,r12[0x0]
80005ac2:	58 08       	cp.w	r8,0
80005ac4:	c2 b1       	brne	80005b1a <prvCopyDataToQueue+0x66>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
80005ac6:	78 1c       	ld.w	r12,r12[0x4]
80005ac8:	f0 1f 00 17 	mcall	80005b24 <prvCopyDataToQueue+0x70>
				pxQueue->pxMutexHolder = NULL;
80005acc:	30 08       	mov	r8,0
80005ace:	8f 18       	st.w	r7[0x4],r8
80005ad0:	c2 58       	rjmp	80005b1a <prvCopyDataToQueue+0x66>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
80005ad2:	58 0a       	cp.w	r10,0
80005ad4:	c1 01       	brne	80005af4 <prvCopyDataToQueue+0x40>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80005ad6:	10 9a       	mov	r10,r8
80005ad8:	78 2c       	ld.w	r12,r12[0x8]
80005ada:	f0 1f 00 14 	mcall	80005b28 <prvCopyDataToQueue+0x74>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
80005ade:	6e 29       	ld.w	r9,r7[0x8]
80005ae0:	6f 08       	ld.w	r8,r7[0x40]
80005ae2:	f2 08 00 08 	add	r8,r9,r8
80005ae6:	8f 28       	st.w	r7[0x8],r8
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
80005ae8:	6e 19       	ld.w	r9,r7[0x4]
80005aea:	12 38       	cp.w	r8,r9
80005aec:	c1 73       	brcs	80005b1a <prvCopyDataToQueue+0x66>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
80005aee:	6e 08       	ld.w	r8,r7[0x0]
80005af0:	8f 28       	st.w	r7[0x8],r8
80005af2:	c1 48       	rjmp	80005b1a <prvCopyDataToQueue+0x66>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80005af4:	10 9a       	mov	r10,r8
80005af6:	78 3c       	ld.w	r12,r12[0xc]
80005af8:	f0 1f 00 0c 	mcall	80005b28 <prvCopyDataToQueue+0x74>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
80005afc:	6f 08       	ld.w	r8,r7[0x40]
80005afe:	6e 39       	ld.w	r9,r7[0xc]
80005b00:	f2 08 01 08 	sub	r8,r9,r8
80005b04:	8f 38       	st.w	r7[0xc],r8
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
80005b06:	6e 09       	ld.w	r9,r7[0x0]
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
80005b08:	12 38       	cp.w	r8,r9
80005b0a:	ef f8 30 10 	ld.wcs	r8,r7[0x40]
80005b0e:	ef f9 30 01 	ld.wcs	r9,r7[0x4]
80005b12:	f3 d8 e3 19 	subcs	r9,r9,r8
80005b16:	ef f9 3a 03 	st.wcs	r7[0xc],r9
		}
	}

	++( pxQueue->uxMessagesWaiting );
80005b1a:	6e e8       	ld.w	r8,r7[0x38]
80005b1c:	2f f8       	sub	r8,-1
80005b1e:	8f e8       	st.w	r7[0x38],r8
}
80005b20:	e3 cd 80 80 	ldm	sp++,r7,pc
80005b24:	80 00       	ld.sh	r0,r0[0x0]
80005b26:	5d ac       	*unknown*
80005b28:	80 00       	ld.sh	r0,r0[0x0]
80005b2a:	6f b2       	ld.w	r2,r7[0x6c]

80005b2c <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
80005b2c:	eb cd 40 c0 	pushm	r6-r7,lr
80005b30:	18 97       	mov	r7,r12
80005b32:	14 96       	mov	r6,r10
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
80005b34:	78 ec       	ld.w	r12,r12[0x38]
80005b36:	6e f8       	ld.w	r8,r7[0x3c]
80005b38:	10 3c       	cp.w	r12,r8
80005b3a:	c0 33       	brcs	80005b40 <xQueueGenericSendFromISR+0x14>
80005b3c:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80005b40:	12 9a       	mov	r10,r9
80005b42:	0e 9c       	mov	r12,r7
80005b44:	f0 1f 00 0c 	mcall	80005b74 <xQueueGenericSendFromISR+0x48>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
80005b48:	6f 28       	ld.w	r8,r7[0x48]
80005b4a:	5b f8       	cp.w	r8,-1
80005b4c:	c0 d1       	brne	80005b66 <xQueueGenericSendFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005b4e:	6e 98       	ld.w	r8,r7[0x24]
80005b50:	58 08       	cp.w	r8,0
80005b52:	c0 f0       	breq	80005b70 <xQueueGenericSendFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80005b54:	ee cc ff dc 	sub	r12,r7,-36
80005b58:	f0 1f 00 08 	mcall	80005b78 <xQueueGenericSendFromISR+0x4c>
80005b5c:	c0 a0       	breq	80005b70 <xQueueGenericSendFromISR+0x44>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
80005b5e:	30 1c       	mov	r12,1
80005b60:	8d 0c       	st.w	r6[0x0],r12
80005b62:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
80005b66:	2f f8       	sub	r8,-1
80005b68:	ef 48 00 48 	st.w	r7[72],r8
80005b6c:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80005b70:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80005b74:	80 00       	ld.sh	r0,r0[0x0]
80005b76:	5a b4       	cp.w	r4,-21
80005b78:	80 00       	ld.sh	r0,r0[0x0]
80005b7a:	5e 88       	retls	r8

80005b7c <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
80005b7c:	d4 31       	pushm	r0-r7,lr
80005b7e:	20 5d       	sub	sp,20
80005b80:	18 97       	mov	r7,r12
80005b82:	50 0b       	stdsp	sp[0x0],r11
80005b84:	50 2a       	stdsp	sp[0x8],r10
80005b86:	50 19       	stdsp	sp[0x4],r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
80005b88:	f8 c0 ff f0 	sub	r0,r12,-16
80005b8c:	30 04       	mov	r4,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80005b8e:	fa c3 ff f4 	sub	r3,sp,-12

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
80005b92:	08 91       	mov	r1,r4

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80005b94:	fa c2 ff f8 	sub	r2,sp,-8
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
80005b98:	f0 1f 00 2f 	mcall	80005c54 <xQueueGenericSend+0xd8>
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
80005b9c:	6e e9       	ld.w	r9,r7[0x38]
80005b9e:	6e f8       	ld.w	r8,r7[0x3c]
80005ba0:	10 39       	cp.w	r9,r8
80005ba2:	c1 42       	brcc	80005bca <xQueueGenericSend+0x4e>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80005ba4:	40 1a       	lddsp	r10,sp[0x4]
80005ba6:	40 0b       	lddsp	r11,sp[0x0]
80005ba8:	0e 9c       	mov	r12,r7
80005baa:	f0 1f 00 2c 	mcall	80005c58 <xQueueGenericSend+0xdc>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005bae:	6e 98       	ld.w	r8,r7[0x24]
80005bb0:	58 08       	cp.w	r8,0
80005bb2:	c0 80       	breq	80005bc2 <xQueueGenericSend+0x46>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
80005bb4:	ee cc ff dc 	sub	r12,r7,-36
80005bb8:	f0 1f 00 29 	mcall	80005c5c <xQueueGenericSend+0xe0>
80005bbc:	58 1c       	cp.w	r12,1
80005bbe:	c0 21       	brne	80005bc2 <xQueueGenericSend+0x46>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
80005bc0:	d7 33       	scall
					}
				}

				taskEXIT_CRITICAL();
80005bc2:	f0 1f 00 28 	mcall	80005c60 <xQueueGenericSend+0xe4>
80005bc6:	30 1c       	mov	r12,1

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
80005bc8:	c4 38       	rjmp	80005c4e <xQueueGenericSend+0xd2>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
80005bca:	40 28       	lddsp	r8,sp[0x8]
80005bcc:	58 08       	cp.w	r8,0
80005bce:	c0 51       	brne	80005bd8 <xQueueGenericSend+0x5c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80005bd0:	f0 1f 00 24 	mcall	80005c60 <xQueueGenericSend+0xe4>
80005bd4:	30 0c       	mov	r12,0

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
80005bd6:	c3 c8       	rjmp	80005c4e <xQueueGenericSend+0xd2>
				}
				else if( xEntryTimeSet == pdFALSE )
80005bd8:	58 04       	cp.w	r4,0
80005bda:	c0 51       	brne	80005be4 <xQueueGenericSend+0x68>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80005bdc:	06 9c       	mov	r12,r3
80005bde:	f0 1f 00 22 	mcall	80005c64 <xQueueGenericSend+0xe8>
80005be2:	30 14       	mov	r4,1
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80005be4:	f0 1f 00 1f 	mcall	80005c60 <xQueueGenericSend+0xe4>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80005be8:	f0 1f 00 20 	mcall	80005c68 <xQueueGenericSend+0xec>
		prvLockQueue( pxQueue );
80005bec:	f0 1f 00 1a 	mcall	80005c54 <xQueueGenericSend+0xd8>
80005bf0:	6f 18       	ld.w	r8,r7[0x44]
80005bf2:	5b f8       	cp.w	r8,-1
80005bf4:	ef f1 0a 11 	st.weq	r7[0x44],r1
80005bf8:	6f 28       	ld.w	r8,r7[0x48]
80005bfa:	5b f8       	cp.w	r8,-1
80005bfc:	ef f1 0a 12 	st.weq	r7[0x48],r1
80005c00:	f0 1f 00 18 	mcall	80005c60 <xQueueGenericSend+0xe4>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80005c04:	04 9b       	mov	r11,r2
80005c06:	06 9c       	mov	r12,r3
80005c08:	f0 1f 00 19 	mcall	80005c6c <xQueueGenericSend+0xf0>
80005c0c:	c1 b1       	brne	80005c42 <xQueueGenericSend+0xc6>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
80005c0e:	f0 1f 00 12 	mcall	80005c54 <xQueueGenericSend+0xd8>
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
80005c12:	6e e5       	ld.w	r5,r7[0x38]
80005c14:	6e f6       	ld.w	r6,r7[0x3c]
	taskEXIT_CRITICAL();
80005c16:	f0 1f 00 13 	mcall	80005c60 <xQueueGenericSend+0xe4>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
80005c1a:	0c 35       	cp.w	r5,r6
80005c1c:	c0 d1       	brne	80005c36 <xQueueGenericSend+0xba>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
80005c1e:	40 2b       	lddsp	r11,sp[0x8]
80005c20:	00 9c       	mov	r12,r0
80005c22:	f0 1f 00 14 	mcall	80005c70 <xQueueGenericSend+0xf4>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
80005c26:	0e 9c       	mov	r12,r7
80005c28:	f0 1f 00 13 	mcall	80005c74 <xQueueGenericSend+0xf8>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
80005c2c:	f0 1f 00 13 	mcall	80005c78 <xQueueGenericSend+0xfc>
80005c30:	cb 41       	brne	80005b98 <xQueueGenericSend+0x1c>
				{
					portYIELD_WITHIN_API();
80005c32:	d7 33       	scall
80005c34:	cb 2b       	rjmp	80005b98 <xQueueGenericSend+0x1c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
80005c36:	0e 9c       	mov	r12,r7
80005c38:	f0 1f 00 0f 	mcall	80005c74 <xQueueGenericSend+0xf8>
				( void ) xTaskResumeAll();
80005c3c:	f0 1f 00 0f 	mcall	80005c78 <xQueueGenericSend+0xfc>
80005c40:	ca cb       	rjmp	80005b98 <xQueueGenericSend+0x1c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
80005c42:	0e 9c       	mov	r12,r7
80005c44:	f0 1f 00 0c 	mcall	80005c74 <xQueueGenericSend+0xf8>
			( void ) xTaskResumeAll();
80005c48:	f0 1f 00 0c 	mcall	80005c78 <xQueueGenericSend+0xfc>
80005c4c:	30 0c       	mov	r12,0
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
80005c4e:	2f bd       	sub	sp,-20
80005c50:	d8 32       	popm	r0-r7,pc
80005c52:	00 00       	add	r0,r0
80005c54:	80 00       	ld.sh	r0,r0[0x0]
80005c56:	55 bc       	stdsp	sp[0x16c],r12
80005c58:	80 00       	ld.sh	r0,r0[0x0]
80005c5a:	5a b4       	cp.w	r4,-21
80005c5c:	80 00       	ld.sh	r0,r0[0x0]
80005c5e:	5e 88       	retls	r8
80005c60:	80 00       	ld.sh	r0,r0[0x0]
80005c62:	56 c8       	stdsp	sp[0x1b0],r8
80005c64:	80 00       	ld.sh	r0,r0[0x0]
80005c66:	5d 7c       	*unknown*
80005c68:	80 00       	ld.sh	r0,r0[0x0]
80005c6a:	5c f0       	rol	r0
80005c6c:	80 00       	ld.sh	r0,r0[0x0]
80005c6e:	60 18       	ld.w	r8,r0[0x4]
80005c70:	80 00       	ld.sh	r0,r0[0x0]
80005c72:	62 70       	ld.w	r0,r1[0x1c]
80005c74:	80 00       	ld.sh	r0,r0[0x0]
80005c76:	58 d0       	cp.w	r0,13
80005c78:	80 00       	ld.sh	r0,r0[0x0]
80005c7a:	60 ac       	ld.w	r12,r0[0x28]

80005c7c <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
80005c7c:	d4 21       	pushm	r4-r7,lr
80005c7e:	18 97       	mov	r7,r12
80005c80:	16 96       	mov	r6,r11
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
80005c82:	58 0c       	cp.w	r12,0
80005c84:	c2 f0       	breq	80005ce2 <xQueueCreate+0x66>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
80005c86:	34 cc       	mov	r12,76
80005c88:	f0 1f 00 17 	mcall	80005ce4 <xQueueCreate+0x68>
80005c8c:	18 95       	mov	r5,r12
		if( pxNewQueue != NULL )
80005c8e:	c2 a0       	breq	80005ce2 <xQueueCreate+0x66>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
80005c90:	ec 07 02 44 	mul	r4,r6,r7

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
80005c94:	e8 cc ff ff 	sub	r12,r4,-1
80005c98:	f0 1f 00 13 	mcall	80005ce4 <xQueueCreate+0x68>
80005c9c:	8b 0c       	st.w	r5[0x0],r12
			if( pxNewQueue->pcHead != NULL )
80005c9e:	c1 e0       	breq	80005cda <xQueueCreate+0x5e>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
80005ca0:	f8 04 00 04 	add	r4,r12,r4
80005ca4:	8b 14       	st.w	r5[0x4],r4
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
80005ca6:	30 08       	mov	r8,0
80005ca8:	8b e8       	st.w	r5[0x38],r8
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
80005caa:	8b 2c       	st.w	r5[0x8],r12
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
80005cac:	ee c8 00 01 	sub	r8,r7,1
80005cb0:	ad 38       	mul	r8,r6
80005cb2:	10 0c       	add	r12,r8
80005cb4:	8b 3c       	st.w	r5[0xc],r12
				pxNewQueue->uxLength = uxQueueLength;
80005cb6:	8b f7       	st.w	r5[0x3c],r7
				pxNewQueue->uxItemSize = uxItemSize;
80005cb8:	eb 46 00 40 	st.w	r5[64],r6
				pxNewQueue->xRxLock = queueUNLOCKED;
80005cbc:	3f f8       	mov	r8,-1
80005cbe:	eb 48 00 44 	st.w	r5[68],r8
				pxNewQueue->xTxLock = queueUNLOCKED;
80005cc2:	eb 48 00 48 	st.w	r5[72],r8

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
80005cc6:	ea cc ff f0 	sub	r12,r5,-16
80005cca:	f0 1f 00 08 	mcall	80005ce8 <xQueueCreate+0x6c>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
80005cce:	ea cc ff dc 	sub	r12,r5,-36
80005cd2:	f0 1f 00 06 	mcall	80005ce8 <xQueueCreate+0x6c>
80005cd6:	0a 9c       	mov	r12,r5
80005cd8:	d8 22       	popm	r4-r7,pc
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
80005cda:	0a 9c       	mov	r12,r5
80005cdc:	f0 1f 00 04 	mcall	80005cec <xQueueCreate+0x70>
80005ce0:	d8 2a       	popm	r4-r7,pc,r12=0
80005ce2:	d8 2a       	popm	r4-r7,pc,r12=0
80005ce4:	80 00       	ld.sh	r0,r0[0x0]
80005ce6:	58 28       	cp.w	r8,2
80005ce8:	80 00       	ld.sh	r0,r0[0x0]
80005cea:	54 98       	stdsp	sp[0x124],r8
80005cec:	80 00       	ld.sh	r0,r0[0x0]
80005cee:	58 00       	cp.w	r0,0

80005cf0 <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
80005cf0:	48 38       	lddpc	r8,80005cfc <vTaskSuspendAll+0xc>
80005cf2:	70 09       	ld.w	r9,r8[0x0]
80005cf4:	2f f9       	sub	r9,-1
80005cf6:	91 09       	st.w	r8[0x0],r9
}
80005cf8:	5e fc       	retal	r12
80005cfa:	00 00       	add	r0,r0
80005cfc:	00 00       	add	r0,r0
80005cfe:	0d 0c       	ld.w	r12,r6++

80005d00 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
80005d00:	49 a8       	lddpc	r8,80005d68 <vTaskSwitchContext+0x68>
80005d02:	70 08       	ld.w	r8,r8[0x0]
80005d04:	58 08       	cp.w	r8,0
80005d06:	c0 b1       	brne	80005d1c <vTaskSwitchContext+0x1c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80005d08:	49 98       	lddpc	r8,80005d6c <vTaskSwitchContext+0x6c>
80005d0a:	70 08       	ld.w	r8,r8[0x0]
80005d0c:	f0 08 00 28 	add	r8,r8,r8<<0x2
80005d10:	49 89       	lddpc	r9,80005d70 <vTaskSwitchContext+0x70>
80005d12:	f2 08 03 28 	ld.w	r8,r9[r8<<0x2]
80005d16:	58 08       	cp.w	r8,0
80005d18:	c0 60       	breq	80005d24 <vTaskSwitchContext+0x24>
80005d1a:	c1 18       	rjmp	80005d3c <vTaskSwitchContext+0x3c>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
80005d1c:	30 19       	mov	r9,1
80005d1e:	49 68       	lddpc	r8,80005d74 <vTaskSwitchContext+0x74>
80005d20:	91 09       	st.w	r8[0x0],r9
80005d22:	5e fc       	retal	r12

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
80005d24:	49 28       	lddpc	r8,80005d6c <vTaskSwitchContext+0x6c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80005d26:	49 3a       	lddpc	r10,80005d70 <vTaskSwitchContext+0x70>
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
80005d28:	70 09       	ld.w	r9,r8[0x0]
80005d2a:	20 19       	sub	r9,1
80005d2c:	91 09       	st.w	r8[0x0],r9

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80005d2e:	70 09       	ld.w	r9,r8[0x0]
80005d30:	f2 09 00 29 	add	r9,r9,r9<<0x2
80005d34:	f4 09 03 29 	ld.w	r9,r10[r9<<0x2]
80005d38:	58 09       	cp.w	r9,0
80005d3a:	cf 70       	breq	80005d28 <vTaskSwitchContext+0x28>
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
80005d3c:	48 c8       	lddpc	r8,80005d6c <vTaskSwitchContext+0x6c>
80005d3e:	70 08       	ld.w	r8,r8[0x0]
80005d40:	f0 08 00 28 	add	r8,r8,r8<<0x2
80005d44:	48 b9       	lddpc	r9,80005d70 <vTaskSwitchContext+0x70>
80005d46:	f2 08 00 28 	add	r8,r9,r8<<0x2
80005d4a:	70 19       	ld.w	r9,r8[0x4]
80005d4c:	72 19       	ld.w	r9,r9[0x4]
80005d4e:	91 19       	st.w	r8[0x4],r9
80005d50:	f0 ca ff f8 	sub	r10,r8,-8
80005d54:	14 39       	cp.w	r9,r10
80005d56:	f3 f9 00 01 	ld.weq	r9,r9[0x4]
80005d5a:	f1 f9 0a 01 	st.weq	r8[0x4],r9
80005d5e:	70 18       	ld.w	r8,r8[0x4]
80005d60:	70 39       	ld.w	r9,r8[0xc]
80005d62:	48 68       	lddpc	r8,80005d78 <vTaskSwitchContext+0x78>
80005d64:	91 09       	st.w	r8[0x0],r9
80005d66:	5e fc       	retal	r12
80005d68:	00 00       	add	r0,r0
80005d6a:	0d 0c       	ld.w	r12,r6++
80005d6c:	00 00       	add	r0,r0
80005d6e:	0d 44       	ld.w	r4,--r6
80005d70:	00 00       	add	r0,r0
80005d72:	0c 28       	rsub	r8,r6
80005d74:	00 00       	add	r0,r0
80005d76:	0d 2c       	ld.uh	r12,r6++
80005d78:	00 00       	add	r0,r0
80005d7a:	0c dc       	st.w	--r6,r12

80005d7c <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
80005d7c:	48 48       	lddpc	r8,80005d8c <vTaskSetTimeOutState+0x10>
80005d7e:	70 08       	ld.w	r8,r8[0x0]
80005d80:	99 08       	st.w	r12[0x0],r8
	pxTimeOut->xTimeOnEntering = xTickCount;
80005d82:	48 48       	lddpc	r8,80005d90 <vTaskSetTimeOutState+0x14>
80005d84:	70 08       	ld.w	r8,r8[0x0]
80005d86:	99 18       	st.w	r12[0x4],r8
}
80005d88:	5e fc       	retal	r12
80005d8a:	00 00       	add	r0,r0
80005d8c:	00 00       	add	r0,r0
80005d8e:	0c 20       	rsub	r0,r6
80005d90:	00 00       	add	r0,r0
80005d92:	0d 08       	ld.w	r8,r6++

80005d94 <vTaskMissedYield>:
}
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
80005d94:	30 19       	mov	r9,1
80005d96:	48 28       	lddpc	r8,80005d9c <vTaskMissedYield+0x8>
80005d98:	91 09       	st.w	r8[0x0],r9
}
80005d9a:	5e fc       	retal	r12
80005d9c:	00 00       	add	r0,r0
80005d9e:	0d 2c       	ld.uh	r12,r6++

80005da0 <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
80005da0:	48 28       	lddpc	r8,80005da8 <xTaskGetCurrentTaskHandle+0x8>
80005da2:	70 0c       	ld.w	r12,r8[0x0]

		return xReturn;
	}
80005da4:	5e fc       	retal	r12
80005da6:	00 00       	add	r0,r0
80005da8:	00 00       	add	r0,r0
80005daa:	0c dc       	st.w	--r6,r12

80005dac <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
80005dac:	eb cd 40 c0 	pushm	r6-r7,lr
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
80005db0:	58 0c       	cp.w	r12,0
80005db2:	c1 f0       	breq	80005df0 <vTaskPriorityDisinherit+0x44>

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
80005db4:	18 97       	mov	r7,r12

		if( pxMutexHolder != NULL )
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
80005db6:	78 b9       	ld.w	r9,r12[0x2c]
80005db8:	79 18       	ld.w	r8,r12[0x44]
80005dba:	10 39       	cp.w	r9,r8
80005dbc:	c1 a0       	breq	80005df0 <vTaskPriorityDisinherit+0x44>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
80005dbe:	f8 c6 ff fc 	sub	r6,r12,-4
80005dc2:	0c 9c       	mov	r12,r6
80005dc4:	f0 1f 00 0c 	mcall	80005df4 <vTaskPriorityDisinherit+0x48>

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
80005dc8:	6f 1c       	ld.w	r12,r7[0x44]
80005dca:	8f bc       	st.w	r7[0x2c],r12
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
80005dcc:	f8 08 11 08 	rsub	r8,r12,8
80005dd0:	8f 68       	st.w	r7[0x18],r8
				prvAddTaskToReadyQueue( pxTCB );
80005dd2:	48 a8       	lddpc	r8,80005df8 <vTaskPriorityDisinherit+0x4c>
80005dd4:	70 08       	ld.w	r8,r8[0x0]
80005dd6:	10 3c       	cp.w	r12,r8
80005dd8:	e0 88 00 04 	brls	80005de0 <vTaskPriorityDisinherit+0x34>
80005ddc:	48 78       	lddpc	r8,80005df8 <vTaskPriorityDisinherit+0x4c>
80005dde:	91 0c       	st.w	r8[0x0],r12
80005de0:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80005de4:	0c 9b       	mov	r11,r6
80005de6:	48 68       	lddpc	r8,80005dfc <vTaskPriorityDisinherit+0x50>
80005de8:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80005dec:	f0 1f 00 05 	mcall	80005e00 <vTaskPriorityDisinherit+0x54>
80005df0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005df4:	80 00       	ld.sh	r0,r0[0x0]
80005df6:	55 02       	stdsp	sp[0x140],r2
80005df8:	00 00       	add	r0,r0
80005dfa:	0d 44       	ld.w	r4,--r6
80005dfc:	00 00       	add	r0,r0
80005dfe:	0c 28       	rsub	r8,r6
80005e00:	80 00       	ld.sh	r0,r0[0x0]
80005e02:	54 b2       	stdsp	sp[0x12c],r2

80005e04 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
80005e04:	eb cd 40 c0 	pushm	r6-r7,lr
80005e08:	18 97       	mov	r7,r12
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
80005e0a:	49 b8       	lddpc	r8,80005e74 <vTaskPriorityInherit+0x70>
80005e0c:	70 08       	ld.w	r8,r8[0x0]
80005e0e:	78 b9       	ld.w	r9,r12[0x2c]
80005e10:	70 b8       	ld.w	r8,r8[0x2c]
80005e12:	10 39       	cp.w	r9,r8
80005e14:	c2 d2       	brcc	80005e6e <vTaskPriorityInherit+0x6a>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
80005e16:	49 88       	lddpc	r8,80005e74 <vTaskPriorityInherit+0x70>
80005e18:	70 08       	ld.w	r8,r8[0x0]
80005e1a:	70 b8       	ld.w	r8,r8[0x2c]
80005e1c:	f0 08 11 08 	rsub	r8,r8,8
80005e20:	99 68       	st.w	r12[0x18],r8

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
80005e22:	f2 09 00 28 	add	r8,r9,r9<<0x2
80005e26:	49 59       	lddpc	r9,80005e78 <vTaskPriorityInherit+0x74>
80005e28:	f2 08 00 28 	add	r8,r9,r8<<0x2
80005e2c:	78 59       	ld.w	r9,r12[0x14]
80005e2e:	10 39       	cp.w	r9,r8
80005e30:	c1 b1       	brne	80005e66 <vTaskPriorityInherit+0x62>
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
80005e32:	f8 c6 ff fc 	sub	r6,r12,-4
80005e36:	0c 9c       	mov	r12,r6
80005e38:	f0 1f 00 11 	mcall	80005e7c <vTaskPriorityInherit+0x78>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
80005e3c:	48 e8       	lddpc	r8,80005e74 <vTaskPriorityInherit+0x70>
80005e3e:	70 08       	ld.w	r8,r8[0x0]
80005e40:	70 bc       	ld.w	r12,r8[0x2c]
80005e42:	8f bc       	st.w	r7[0x2c],r12
				prvAddTaskToReadyQueue( pxTCB );
80005e44:	48 f8       	lddpc	r8,80005e80 <vTaskPriorityInherit+0x7c>
80005e46:	70 08       	ld.w	r8,r8[0x0]
80005e48:	10 3c       	cp.w	r12,r8
80005e4a:	e0 88 00 04 	brls	80005e52 <vTaskPriorityInherit+0x4e>
80005e4e:	48 d8       	lddpc	r8,80005e80 <vTaskPriorityInherit+0x7c>
80005e50:	91 0c       	st.w	r8[0x0],r12
80005e52:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80005e56:	0c 9b       	mov	r11,r6
80005e58:	48 88       	lddpc	r8,80005e78 <vTaskPriorityInherit+0x74>
80005e5a:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80005e5e:	f0 1f 00 0a 	mcall	80005e84 <vTaskPriorityInherit+0x80>
80005e62:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
80005e66:	48 48       	lddpc	r8,80005e74 <vTaskPriorityInherit+0x70>
80005e68:	70 08       	ld.w	r8,r8[0x0]
80005e6a:	70 b8       	ld.w	r8,r8[0x2c]
80005e6c:	99 b8       	st.w	r12[0x2c],r8
80005e6e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005e72:	00 00       	add	r0,r0
80005e74:	00 00       	add	r0,r0
80005e76:	0c dc       	st.w	--r6,r12
80005e78:	00 00       	add	r0,r0
80005e7a:	0c 28       	rsub	r8,r6
80005e7c:	80 00       	ld.sh	r0,r0[0x0]
80005e7e:	55 02       	stdsp	sp[0x140],r2
80005e80:	00 00       	add	r0,r0
80005e82:	0d 44       	ld.w	r4,--r6
80005e84:	80 00       	ld.sh	r0,r0[0x0]
80005e86:	54 b2       	stdsp	sp[0x12c],r2

80005e88 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
80005e88:	eb cd 40 c0 	pushm	r6-r7,lr
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
80005e8c:	78 38       	ld.w	r8,r12[0xc]
80005e8e:	70 37       	ld.w	r7,r8[0xc]
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
80005e90:	ee c6 ff e8 	sub	r6,r7,-24
80005e94:	0c 9c       	mov	r12,r6
80005e96:	f0 1f 00 15 	mcall	80005ee8 <xTaskRemoveFromEventList+0x60>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80005e9a:	49 58       	lddpc	r8,80005eec <xTaskRemoveFromEventList+0x64>
80005e9c:	70 08       	ld.w	r8,r8[0x0]
80005e9e:	58 08       	cp.w	r8,0
80005ea0:	c1 71       	brne	80005ece <xTaskRemoveFromEventList+0x46>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
80005ea2:	ee c6 ff fc 	sub	r6,r7,-4
80005ea6:	0c 9c       	mov	r12,r6
80005ea8:	f0 1f 00 10 	mcall	80005ee8 <xTaskRemoveFromEventList+0x60>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
80005eac:	6e bc       	ld.w	r12,r7[0x2c]
80005eae:	49 18       	lddpc	r8,80005ef0 <xTaskRemoveFromEventList+0x68>
80005eb0:	70 08       	ld.w	r8,r8[0x0]
80005eb2:	10 3c       	cp.w	r12,r8
80005eb4:	e0 88 00 04 	brls	80005ebc <xTaskRemoveFromEventList+0x34>
80005eb8:	48 e8       	lddpc	r8,80005ef0 <xTaskRemoveFromEventList+0x68>
80005eba:	91 0c       	st.w	r8[0x0],r12
80005ebc:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80005ec0:	0c 9b       	mov	r11,r6
80005ec2:	48 d8       	lddpc	r8,80005ef4 <xTaskRemoveFromEventList+0x6c>
80005ec4:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80005ec8:	f0 1f 00 0c 	mcall	80005ef8 <xTaskRemoveFromEventList+0x70>
80005ecc:	c0 58       	rjmp	80005ed6 <xTaskRemoveFromEventList+0x4e>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
80005ece:	0c 9b       	mov	r11,r6
80005ed0:	48 bc       	lddpc	r12,80005efc <xTaskRemoveFromEventList+0x74>
80005ed2:	f0 1f 00 0a 	mcall	80005ef8 <xTaskRemoveFromEventList+0x70>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
80005ed6:	48 b8       	lddpc	r8,80005f00 <xTaskRemoveFromEventList+0x78>
80005ed8:	70 08       	ld.w	r8,r8[0x0]
80005eda:	6e b9       	ld.w	r9,r7[0x2c]
80005edc:	70 b8       	ld.w	r8,r8[0x2c]
80005ede:	10 39       	cp.w	r9,r8
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
80005ee0:	5f 2c       	srhs	r12
80005ee2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005ee6:	00 00       	add	r0,r0
80005ee8:	80 00       	ld.sh	r0,r0[0x0]
80005eea:	55 02       	stdsp	sp[0x140],r2
80005eec:	00 00       	add	r0,r0
80005eee:	0d 0c       	ld.w	r12,r6++
80005ef0:	00 00       	add	r0,r0
80005ef2:	0d 44       	ld.w	r4,--r6
80005ef4:	00 00       	add	r0,r0
80005ef6:	0c 28       	rsub	r8,r6
80005ef8:	80 00       	ld.sh	r0,r0[0x0]
80005efa:	54 b2       	stdsp	sp[0x12c],r2
80005efc:	00 00       	add	r0,r0
80005efe:	0c e0       	st.h	--r6,r0
80005f00:	00 00       	add	r0,r0
80005f02:	0c dc       	st.w	--r6,r12

80005f04 <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
80005f04:	eb cd 40 fc 	pushm	r2-r7,lr
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80005f08:	4b 98       	lddpc	r8,80005fec <vTaskIncrementTick+0xe8>
80005f0a:	70 08       	ld.w	r8,r8[0x0]
80005f0c:	58 08       	cp.w	r8,0
80005f0e:	c6 91       	brne	80005fe0 <vTaskIncrementTick+0xdc>
	{
		++xTickCount;
80005f10:	4b 88       	lddpc	r8,80005ff0 <vTaskIncrementTick+0xec>
80005f12:	70 09       	ld.w	r9,r8[0x0]
80005f14:	2f f9       	sub	r9,-1
80005f16:	91 09       	st.w	r8[0x0],r9
		if( xTickCount == ( portTickType ) 0 )
80005f18:	70 08       	ld.w	r8,r8[0x0]
80005f1a:	58 08       	cp.w	r8,0
80005f1c:	c1 a1       	brne	80005f50 <vTaskIncrementTick+0x4c>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
80005f1e:	4b 68       	lddpc	r8,80005ff4 <vTaskIncrementTick+0xf0>
80005f20:	70 0a       	ld.w	r10,r8[0x0]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
80005f22:	4b 69       	lddpc	r9,80005ff8 <vTaskIncrementTick+0xf4>
80005f24:	72 0b       	ld.w	r11,r9[0x0]
80005f26:	91 0b       	st.w	r8[0x0],r11
			pxOverflowDelayedTaskList = pxTemp;
80005f28:	93 0a       	st.w	r9[0x0],r10
			xNumOfOverflows++;
80005f2a:	4b 59       	lddpc	r9,80005ffc <vTaskIncrementTick+0xf8>
80005f2c:	72 0a       	ld.w	r10,r9[0x0]
80005f2e:	2f fa       	sub	r10,-1
80005f30:	93 0a       	st.w	r9[0x0],r10

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
80005f32:	70 08       	ld.w	r8,r8[0x0]
80005f34:	70 08       	ld.w	r8,r8[0x0]
80005f36:	58 08       	cp.w	r8,0
80005f38:	c0 51       	brne	80005f42 <vTaskIncrementTick+0x3e>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
80005f3a:	3f f9       	mov	r9,-1
80005f3c:	4b 18       	lddpc	r8,80006000 <vTaskIncrementTick+0xfc>
80005f3e:	91 09       	st.w	r8[0x0],r9
80005f40:	c0 88       	rjmp	80005f50 <vTaskIncrementTick+0x4c>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
80005f42:	4a d8       	lddpc	r8,80005ff4 <vTaskIncrementTick+0xf0>
80005f44:	70 08       	ld.w	r8,r8[0x0]
80005f46:	70 38       	ld.w	r8,r8[0xc]
80005f48:	70 38       	ld.w	r8,r8[0xc]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
80005f4a:	70 19       	ld.w	r9,r8[0x4]
80005f4c:	4a d8       	lddpc	r8,80006000 <vTaskIncrementTick+0xfc>
80005f4e:	91 09       	st.w	r8[0x0],r9
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
80005f50:	4a 88       	lddpc	r8,80005ff0 <vTaskIncrementTick+0xec>
80005f52:	70 09       	ld.w	r9,r8[0x0]
80005f54:	4a b8       	lddpc	r8,80006000 <vTaskIncrementTick+0xfc>
80005f56:	70 08       	ld.w	r8,r8[0x0]
80005f58:	10 39       	cp.w	r9,r8
80005f5a:	c4 73       	brcs	80005fe8 <vTaskIncrementTick+0xe4>
80005f5c:	4a 68       	lddpc	r8,80005ff4 <vTaskIncrementTick+0xf0>
80005f5e:	70 08       	ld.w	r8,r8[0x0]
80005f60:	70 08       	ld.w	r8,r8[0x0]
80005f62:	58 08       	cp.w	r8,0
80005f64:	c0 c0       	breq	80005f7c <vTaskIncrementTick+0x78>
80005f66:	4a 48       	lddpc	r8,80005ff4 <vTaskIncrementTick+0xf0>
80005f68:	70 08       	ld.w	r8,r8[0x0]
80005f6a:	70 38       	ld.w	r8,r8[0xc]
80005f6c:	70 37       	ld.w	r7,r8[0xc]
80005f6e:	6e 18       	ld.w	r8,r7[0x4]
80005f70:	4a 09       	lddpc	r9,80005ff0 <vTaskIncrementTick+0xec>
80005f72:	72 09       	ld.w	r9,r9[0x0]
80005f74:	12 38       	cp.w	r8,r9
80005f76:	e0 88 00 14 	brls	80005f9e <vTaskIncrementTick+0x9a>
80005f7a:	c0 e8       	rjmp	80005f96 <vTaskIncrementTick+0x92>
80005f7c:	3f f9       	mov	r9,-1
80005f7e:	4a 18       	lddpc	r8,80006000 <vTaskIncrementTick+0xfc>
80005f80:	91 09       	st.w	r8[0x0],r9
80005f82:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80005f86:	6a 08       	ld.w	r8,r5[0x0]
80005f88:	70 38       	ld.w	r8,r8[0xc]
80005f8a:	70 37       	ld.w	r7,r8[0xc]
80005f8c:	6e 18       	ld.w	r8,r7[0x4]
80005f8e:	64 09       	ld.w	r9,r2[0x0]
80005f90:	12 38       	cp.w	r8,r9
80005f92:	e0 88 00 0a 	brls	80005fa6 <vTaskIncrementTick+0xa2>
80005f96:	49 b9       	lddpc	r9,80006000 <vTaskIncrementTick+0xfc>
80005f98:	93 08       	st.w	r9[0x0],r8
80005f9a:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80005f9e:	49 a4       	lddpc	r4,80006004 <vTaskIncrementTick+0x100>
80005fa0:	49 a3       	lddpc	r3,80006008 <vTaskIncrementTick+0x104>
80005fa2:	49 55       	lddpc	r5,80005ff4 <vTaskIncrementTick+0xf0>
80005fa4:	49 32       	lddpc	r2,80005ff0 <vTaskIncrementTick+0xec>
80005fa6:	ee c6 ff fc 	sub	r6,r7,-4
80005faa:	0c 9c       	mov	r12,r6
80005fac:	f0 1f 00 18 	mcall	8000600c <vTaskIncrementTick+0x108>
80005fb0:	6e a8       	ld.w	r8,r7[0x28]
80005fb2:	58 08       	cp.w	r8,0
80005fb4:	c0 50       	breq	80005fbe <vTaskIncrementTick+0xba>
80005fb6:	ee cc ff e8 	sub	r12,r7,-24
80005fba:	f0 1f 00 15 	mcall	8000600c <vTaskIncrementTick+0x108>
80005fbe:	6e bc       	ld.w	r12,r7[0x2c]
80005fc0:	68 08       	ld.w	r8,r4[0x0]
80005fc2:	10 3c       	cp.w	r12,r8
80005fc4:	e9 fc ba 00 	st.whi	r4[0x0],r12
80005fc8:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80005fcc:	0c 9b       	mov	r11,r6
80005fce:	e6 0c 00 2c 	add	r12,r3,r12<<0x2
80005fd2:	f0 1f 00 10 	mcall	80006010 <vTaskIncrementTick+0x10c>
80005fd6:	6a 08       	ld.w	r8,r5[0x0]
80005fd8:	70 08       	ld.w	r8,r8[0x0]
80005fda:	58 08       	cp.w	r8,0
80005fdc:	cd 51       	brne	80005f86 <vTaskIncrementTick+0x82>
80005fde:	cc fb       	rjmp	80005f7c <vTaskIncrementTick+0x78>
	}
	else
	{
		++uxMissedTicks;
80005fe0:	48 d8       	lddpc	r8,80006014 <vTaskIncrementTick+0x110>
80005fe2:	70 09       	ld.w	r9,r8[0x0]
80005fe4:	2f f9       	sub	r9,-1
80005fe6:	91 09       	st.w	r8[0x0],r9
80005fe8:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80005fec:	00 00       	add	r0,r0
80005fee:	0d 0c       	ld.w	r12,r6++
80005ff0:	00 00       	add	r0,r0
80005ff2:	0d 08       	ld.w	r8,r6++
80005ff4:	00 00       	add	r0,r0
80005ff6:	0c 14       	sub	r4,r6
80005ff8:	00 00       	add	r0,r0
80005ffa:	0c 24       	rsub	r4,r6
80005ffc:	00 00       	add	r0,r0
80005ffe:	0c 20       	rsub	r0,r6
80006000:	00 00       	add	r0,r0
80006002:	05 34       	ld.ub	r4,r2++
80006004:	00 00       	add	r0,r0
80006006:	0d 44       	ld.w	r4,--r6
80006008:	00 00       	add	r0,r0
8000600a:	0c 28       	rsub	r8,r6
8000600c:	80 00       	ld.sh	r0,r0[0x0]
8000600e:	55 02       	stdsp	sp[0x140],r2
80006010:	80 00       	ld.sh	r0,r0[0x0]
80006012:	54 b2       	stdsp	sp[0x12c],r2
80006014:	00 00       	add	r0,r0
80006016:	0c 0c       	add	r12,r6

80006018 <xTaskCheckForTimeOut>:
	pxTimeOut->xTimeOnEntering = xTickCount;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
80006018:	eb cd 40 c0 	pushm	r6-r7,lr
8000601c:	18 97       	mov	r7,r12
8000601e:	16 96       	mov	r6,r11
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
80006020:	f0 1f 00 15 	mcall	80006074 <xTaskCheckForTimeOut+0x5c>
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
80006024:	6c 08       	ld.w	r8,r6[0x0]
80006026:	5b f8       	cp.w	r8,-1
80006028:	c0 31       	brne	8000602e <xTaskCheckForTimeOut+0x16>
8000602a:	30 07       	mov	r7,0
8000602c:	c1 f8       	rjmp	8000606a <xTaskCheckForTimeOut+0x52>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
8000602e:	49 39       	lddpc	r9,80006078 <xTaskCheckForTimeOut+0x60>
80006030:	72 09       	ld.w	r9,r9[0x0]
80006032:	6e 0a       	ld.w	r10,r7[0x0]
80006034:	12 3a       	cp.w	r10,r9
80006036:	c0 70       	breq	80006044 <xTaskCheckForTimeOut+0x2c>
80006038:	49 19       	lddpc	r9,8000607c <xTaskCheckForTimeOut+0x64>
8000603a:	72 09       	ld.w	r9,r9[0x0]
8000603c:	6e 1a       	ld.w	r10,r7[0x4]
8000603e:	12 3a       	cp.w	r10,r9
80006040:	e0 88 00 14 	brls	80006068 <xTaskCheckForTimeOut+0x50>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
80006044:	48 e9       	lddpc	r9,8000607c <xTaskCheckForTimeOut+0x64>
80006046:	72 0a       	ld.w	r10,r9[0x0]
80006048:	6e 19       	ld.w	r9,r7[0x4]
8000604a:	12 1a       	sub	r10,r9
8000604c:	14 38       	cp.w	r8,r10
8000604e:	e0 88 00 0d 	brls	80006068 <xTaskCheckForTimeOut+0x50>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
80006052:	48 ba       	lddpc	r10,8000607c <xTaskCheckForTimeOut+0x64>
80006054:	74 0a       	ld.w	r10,r10[0x0]
80006056:	14 19       	sub	r9,r10
80006058:	f2 08 00 08 	add	r8,r9,r8
8000605c:	8d 08       	st.w	r6[0x0],r8
			vTaskSetTimeOutState( pxTimeOut );
8000605e:	0e 9c       	mov	r12,r7
80006060:	f0 1f 00 08 	mcall	80006080 <xTaskCheckForTimeOut+0x68>
80006064:	30 07       	mov	r7,0
80006066:	c0 28       	rjmp	8000606a <xTaskCheckForTimeOut+0x52>
80006068:	30 17       	mov	r7,1
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
8000606a:	f0 1f 00 07 	mcall	80006084 <xTaskCheckForTimeOut+0x6c>

	return xReturn;
}
8000606e:	0e 9c       	mov	r12,r7
80006070:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006074:	80 00       	ld.sh	r0,r0[0x0]
80006076:	55 bc       	stdsp	sp[0x16c],r12
80006078:	00 00       	add	r0,r0
8000607a:	0c 20       	rsub	r0,r6
8000607c:	00 00       	add	r0,r0
8000607e:	0d 08       	ld.w	r8,r6++
80006080:	80 00       	ld.sh	r0,r0[0x0]
80006082:	5d 7c       	*unknown*
80006084:	80 00       	ld.sh	r0,r0[0x0]
80006086:	56 c8       	stdsp	sp[0x1b0],r8

80006088 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
80006088:	eb cd 40 80 	pushm	r7,lr
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
8000608c:	f0 1f 00 05 	mcall	800060a0 <xTaskGetTickCount+0x18>
	{
		xTicks = xTickCount;
80006090:	48 58       	lddpc	r8,800060a4 <xTaskGetTickCount+0x1c>
80006092:	70 07       	ld.w	r7,r8[0x0]
	}
	taskEXIT_CRITICAL();
80006094:	f0 1f 00 05 	mcall	800060a8 <xTaskGetTickCount+0x20>

	return xTicks;
}
80006098:	0e 9c       	mov	r12,r7
8000609a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000609e:	00 00       	add	r0,r0
800060a0:	80 00       	ld.sh	r0,r0[0x0]
800060a2:	55 bc       	stdsp	sp[0x16c],r12
800060a4:	00 00       	add	r0,r0
800060a6:	0d 08       	ld.w	r8,r6++
800060a8:	80 00       	ld.sh	r0,r0[0x0]
800060aa:	56 c8       	stdsp	sp[0x1b0],r8

800060ac <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
800060ac:	eb cd 40 fe 	pushm	r1-r7,lr
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
800060b0:	f0 1f 00 2c 	mcall	80006160 <xTaskResumeAll+0xb4>
	{
		--uxSchedulerSuspended;
800060b4:	4a c8       	lddpc	r8,80006164 <xTaskResumeAll+0xb8>
800060b6:	70 09       	ld.w	r9,r8[0x0]
800060b8:	20 19       	sub	r9,1
800060ba:	91 09       	st.w	r8[0x0],r9

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
800060bc:	70 08       	ld.w	r8,r8[0x0]
800060be:	58 08       	cp.w	r8,0
800060c0:	c4 91       	brne	80006152 <xTaskResumeAll+0xa6>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
800060c2:	4a a8       	lddpc	r8,80006168 <xTaskResumeAll+0xbc>
800060c4:	70 08       	ld.w	r8,r8[0x0]
800060c6:	58 08       	cp.w	r8,0
800060c8:	c4 50       	breq	80006152 <xTaskResumeAll+0xa6>
800060ca:	30 04       	mov	r4,0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
800060cc:	4a 85       	lddpc	r5,8000616c <xTaskResumeAll+0xc0>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
800060ce:	4a 93       	lddpc	r3,80006170 <xTaskResumeAll+0xc4>
800060d0:	4a 92       	lddpc	r2,80006174 <xTaskResumeAll+0xc8>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
800060d2:	4a a1       	lddpc	r1,80006178 <xTaskResumeAll+0xcc>
800060d4:	c1 e8       	rjmp	80006110 <xTaskResumeAll+0x64>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
800060d6:	6a 38       	ld.w	r8,r5[0xc]
800060d8:	70 37       	ld.w	r7,r8[0xc]
					vListRemove( &( pxTCB->xEventListItem ) );
800060da:	ee cc ff e8 	sub	r12,r7,-24
800060de:	f0 1f 00 28 	mcall	8000617c <xTaskResumeAll+0xd0>
					vListRemove( &( pxTCB->xGenericListItem ) );
800060e2:	ee c6 ff fc 	sub	r6,r7,-4
800060e6:	0c 9c       	mov	r12,r6
800060e8:	f0 1f 00 25 	mcall	8000617c <xTaskResumeAll+0xd0>
					prvAddTaskToReadyQueue( pxTCB );
800060ec:	6e bc       	ld.w	r12,r7[0x2c]
800060ee:	66 08       	ld.w	r8,r3[0x0]
800060f0:	10 3c       	cp.w	r12,r8
800060f2:	e7 fc ba 00 	st.whi	r3[0x0],r12
800060f6:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800060fa:	0c 9b       	mov	r11,r6
800060fc:	e4 0c 00 2c 	add	r12,r2,r12<<0x2
80006100:	f0 1f 00 20 	mcall	80006180 <xTaskResumeAll+0xd4>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80006104:	62 08       	ld.w	r8,r1[0x0]
80006106:	6e b9       	ld.w	r9,r7[0x2c]
80006108:	70 b8       	ld.w	r8,r8[0x2c]
8000610a:	10 39       	cp.w	r9,r8
8000610c:	f9 b4 02 01 	movhs	r4,1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80006110:	6a 08       	ld.w	r8,r5[0x0]
80006112:	58 08       	cp.w	r8,0
80006114:	ce 11       	brne	800060d6 <xTaskResumeAll+0x2a>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80006116:	49 c8       	lddpc	r8,80006184 <xTaskResumeAll+0xd8>
80006118:	70 08       	ld.w	r8,r8[0x0]
8000611a:	58 08       	cp.w	r8,0
8000611c:	c0 f0       	breq	8000613a <xTaskResumeAll+0x8e>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
8000611e:	49 a8       	lddpc	r8,80006184 <xTaskResumeAll+0xd8>
80006120:	70 08       	ld.w	r8,r8[0x0]
80006122:	58 08       	cp.w	r8,0
80006124:	c1 10       	breq	80006146 <xTaskResumeAll+0x9a>
					{
						vTaskIncrementTick();
						--uxMissedTicks;
80006126:	49 87       	lddpc	r7,80006184 <xTaskResumeAll+0xd8>
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
80006128:	f0 1f 00 18 	mcall	80006188 <xTaskResumeAll+0xdc>
						--uxMissedTicks;
8000612c:	6e 08       	ld.w	r8,r7[0x0]
8000612e:	20 18       	sub	r8,1
80006130:	8f 08       	st.w	r7[0x0],r8
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80006132:	6e 08       	ld.w	r8,r7[0x0]
80006134:	58 08       	cp.w	r8,0
80006136:	cf 91       	brne	80006128 <xTaskResumeAll+0x7c>
80006138:	c0 78       	rjmp	80006146 <xTaskResumeAll+0x9a>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
8000613a:	58 14       	cp.w	r4,1
8000613c:	c0 50       	breq	80006146 <xTaskResumeAll+0x9a>
8000613e:	49 48       	lddpc	r8,8000618c <xTaskResumeAll+0xe0>
80006140:	70 08       	ld.w	r8,r8[0x0]
80006142:	58 18       	cp.w	r8,1
80006144:	c0 71       	brne	80006152 <xTaskResumeAll+0xa6>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
80006146:	30 09       	mov	r9,0
80006148:	49 18       	lddpc	r8,8000618c <xTaskResumeAll+0xe0>
8000614a:	91 09       	st.w	r8[0x0],r9
					portYIELD_WITHIN_API();
8000614c:	d7 33       	scall
8000614e:	30 17       	mov	r7,1
80006150:	c0 28       	rjmp	80006154 <xTaskResumeAll+0xa8>
80006152:	30 07       	mov	r7,0
				}
			}
		}
	}
	taskEXIT_CRITICAL();
80006154:	f0 1f 00 0f 	mcall	80006190 <xTaskResumeAll+0xe4>

	return xAlreadyYielded;
}
80006158:	0e 9c       	mov	r12,r7
8000615a:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
8000615e:	00 00       	add	r0,r0
80006160:	80 00       	ld.sh	r0,r0[0x0]
80006162:	55 bc       	stdsp	sp[0x16c],r12
80006164:	00 00       	add	r0,r0
80006166:	0d 0c       	ld.w	r12,r6++
80006168:	00 00       	add	r0,r0
8000616a:	0d 28       	ld.uh	r8,r6++
8000616c:	00 00       	add	r0,r0
8000616e:	0c e0       	st.h	--r6,r0
80006170:	00 00       	add	r0,r0
80006172:	0d 44       	ld.w	r4,--r6
80006174:	00 00       	add	r0,r0
80006176:	0c 28       	rsub	r8,r6
80006178:	00 00       	add	r0,r0
8000617a:	0c dc       	st.w	--r6,r12
8000617c:	80 00       	ld.sh	r0,r0[0x0]
8000617e:	55 02       	stdsp	sp[0x140],r2
80006180:	80 00       	ld.sh	r0,r0[0x0]
80006182:	54 b2       	stdsp	sp[0x12c],r2
80006184:	00 00       	add	r0,r0
80006186:	0c 0c       	add	r12,r6
80006188:	80 00       	ld.sh	r0,r0[0x0]
8000618a:	5f 04       	sreq	r4
8000618c:	00 00       	add	r0,r0
8000618e:	0d 2c       	ld.uh	r12,r6++
80006190:	80 00       	ld.sh	r0,r0[0x0]
80006192:	56 c8       	stdsp	sp[0x1b0],r8

80006194 <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
80006194:	eb cd 40 80 	pushm	r7,lr
80006198:	18 97       	mov	r7,r12
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
8000619a:	49 08       	lddpc	r8,800061d8 <prvAddCurrentTaskToDelayedList+0x44>
8000619c:	70 08       	ld.w	r8,r8[0x0]
8000619e:	91 1c       	st.w	r8[0x4],r12

	if( xTimeToWake < xTickCount )
800061a0:	48 f8       	lddpc	r8,800061dc <prvAddCurrentTaskToDelayedList+0x48>
800061a2:	70 08       	ld.w	r8,r8[0x0]
800061a4:	10 3c       	cp.w	r12,r8
800061a6:	c0 a2       	brcc	800061ba <prvAddCurrentTaskToDelayedList+0x26>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800061a8:	48 c8       	lddpc	r8,800061d8 <prvAddCurrentTaskToDelayedList+0x44>
800061aa:	70 0b       	ld.w	r11,r8[0x0]
800061ac:	48 d8       	lddpc	r8,800061e0 <prvAddCurrentTaskToDelayedList+0x4c>
800061ae:	70 0c       	ld.w	r12,r8[0x0]
800061b0:	2f cb       	sub	r11,-4
800061b2:	f0 1f 00 0d 	mcall	800061e4 <prvAddCurrentTaskToDelayedList+0x50>
800061b6:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800061ba:	48 88       	lddpc	r8,800061d8 <prvAddCurrentTaskToDelayedList+0x44>
800061bc:	70 0b       	ld.w	r11,r8[0x0]
800061be:	48 b8       	lddpc	r8,800061e8 <prvAddCurrentTaskToDelayedList+0x54>
800061c0:	70 0c       	ld.w	r12,r8[0x0]
800061c2:	2f cb       	sub	r11,-4
800061c4:	f0 1f 00 08 	mcall	800061e4 <prvAddCurrentTaskToDelayedList+0x50>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
800061c8:	48 98       	lddpc	r8,800061ec <prvAddCurrentTaskToDelayedList+0x58>
800061ca:	70 08       	ld.w	r8,r8[0x0]
800061cc:	10 37       	cp.w	r7,r8
800061ce:	c0 32       	brcc	800061d4 <prvAddCurrentTaskToDelayedList+0x40>
		{
			xNextTaskUnblockTime = xTimeToWake;
800061d0:	48 78       	lddpc	r8,800061ec <prvAddCurrentTaskToDelayedList+0x58>
800061d2:	91 07       	st.w	r8[0x0],r7
800061d4:	e3 cd 80 80 	ldm	sp++,r7,pc
800061d8:	00 00       	add	r0,r0
800061da:	0c dc       	st.w	--r6,r12
800061dc:	00 00       	add	r0,r0
800061de:	0d 08       	ld.w	r8,r6++
800061e0:	00 00       	add	r0,r0
800061e2:	0c 24       	rsub	r4,r6
800061e4:	80 00       	ld.sh	r0,r0[0x0]
800061e6:	54 ce       	stdsp	sp[0x130],lr
800061e8:	00 00       	add	r0,r0
800061ea:	0c 14       	sub	r4,r6
800061ec:	00 00       	add	r0,r0
800061ee:	05 34       	ld.ub	r4,r2++

800061f0 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
800061f0:	eb cd 40 c0 	pushm	r6-r7,lr
800061f4:	18 96       	mov	r6,r12
800061f6:	16 97       	mov	r7,r11
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0 ) );

		vTaskSuspendAll();
800061f8:	f0 1f 00 18 	mcall	80006258 <vTaskDelayUntil+0x68>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
800061fc:	6c 08       	ld.w	r8,r6[0x0]
800061fe:	10 07       	add	r7,r8

			if( xTickCount < *pxPreviousWakeTime )
80006200:	49 79       	lddpc	r9,8000625c <vTaskDelayUntil+0x6c>
80006202:	72 09       	ld.w	r9,r9[0x0]
80006204:	12 38       	cp.w	r8,r9
80006206:	e0 88 00 0c 	brls	8000621e <vTaskDelayUntil+0x2e>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
8000620a:	0e 38       	cp.w	r8,r7
8000620c:	e0 88 00 22 	brls	80006250 <vTaskDelayUntil+0x60>
80006210:	49 38       	lddpc	r8,8000625c <vTaskDelayUntil+0x6c>
80006212:	70 08       	ld.w	r8,r8[0x0]
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80006214:	8d 07       	st.w	r6[0x0],r7

			if( xShouldDelay != pdFALSE )
80006216:	10 37       	cp.w	r7,r8
80006218:	e0 88 00 14 	brls	80006240 <vTaskDelayUntil+0x50>
8000621c:	c0 a8       	rjmp	80006230 <vTaskDelayUntil+0x40>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
8000621e:	0e 38       	cp.w	r8,r7
80006220:	e0 8b 00 16 	brhi	8000624c <vTaskDelayUntil+0x5c>
80006224:	48 e8       	lddpc	r8,8000625c <vTaskDelayUntil+0x6c>
80006226:	70 08       	ld.w	r8,r8[0x0]
80006228:	10 37       	cp.w	r7,r8
8000622a:	e0 8b 00 11 	brhi	8000624c <vTaskDelayUntil+0x5c>
8000622e:	c1 18       	rjmp	80006250 <vTaskDelayUntil+0x60>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006230:	48 c8       	lddpc	r8,80006260 <vTaskDelayUntil+0x70>
80006232:	70 0c       	ld.w	r12,r8[0x0]
80006234:	2f cc       	sub	r12,-4
80006236:	f0 1f 00 0c 	mcall	80006264 <vTaskDelayUntil+0x74>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
8000623a:	0e 9c       	mov	r12,r7
8000623c:	f0 1f 00 0b 	mcall	80006268 <vTaskDelayUntil+0x78>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
80006240:	f0 1f 00 0b 	mcall	8000626c <vTaskDelayUntil+0x7c>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
80006244:	c0 81       	brne	80006254 <vTaskDelayUntil+0x64>
		{
			portYIELD_WITHIN_API();
80006246:	d7 33       	scall
80006248:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
8000624c:	8d 07       	st.w	r6[0x0],r7
8000624e:	cf 1b       	rjmp	80006230 <vTaskDelayUntil+0x40>
80006250:	8d 07       	st.w	r6[0x0],r7
80006252:	cf 7b       	rjmp	80006240 <vTaskDelayUntil+0x50>
80006254:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006258:	80 00       	ld.sh	r0,r0[0x0]
8000625a:	5c f0       	rol	r0
8000625c:	00 00       	add	r0,r0
8000625e:	0d 08       	ld.w	r8,r6++
80006260:	00 00       	add	r0,r0
80006262:	0c dc       	st.w	--r6,r12
80006264:	80 00       	ld.sh	r0,r0[0x0]
80006266:	55 02       	stdsp	sp[0x140],r2
80006268:	80 00       	ld.sh	r0,r0[0x0]
8000626a:	61 94       	ld.w	r4,r0[0x64]
8000626c:	80 00       	ld.sh	r0,r0[0x0]
8000626e:	60 ac       	ld.w	r12,r0[0x28]

80006270 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
80006270:	eb cd 40 c0 	pushm	r6-r7,lr
80006274:	16 96       	mov	r6,r11
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
80006276:	48 e7       	lddpc	r7,800062ac <vTaskPlaceOnEventList+0x3c>
80006278:	6e 0b       	ld.w	r11,r7[0x0]
8000627a:	2e 8b       	sub	r11,-24
8000627c:	f0 1f 00 0d 	mcall	800062b0 <vTaskPlaceOnEventList+0x40>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006280:	6e 0c       	ld.w	r12,r7[0x0]
80006282:	2f cc       	sub	r12,-4
80006284:	f0 1f 00 0c 	mcall	800062b4 <vTaskPlaceOnEventList+0x44>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
80006288:	5b f6       	cp.w	r6,-1
8000628a:	c0 81       	brne	8000629a <vTaskPlaceOnEventList+0x2a>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
8000628c:	6e 0b       	ld.w	r11,r7[0x0]
8000628e:	2f cb       	sub	r11,-4
80006290:	48 ac       	lddpc	r12,800062b8 <vTaskPlaceOnEventList+0x48>
80006292:	f0 1f 00 0b 	mcall	800062bc <vTaskPlaceOnEventList+0x4c>
80006296:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
8000629a:	48 a8       	lddpc	r8,800062c0 <vTaskPlaceOnEventList+0x50>
8000629c:	70 0c       	ld.w	r12,r8[0x0]
			prvAddCurrentTaskToDelayedList( xTimeToWake );
8000629e:	ec 0c 00 0c 	add	r12,r6,r12
800062a2:	f0 1f 00 09 	mcall	800062c4 <vTaskPlaceOnEventList+0x54>
800062a6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800062aa:	00 00       	add	r0,r0
800062ac:	00 00       	add	r0,r0
800062ae:	0c dc       	st.w	--r6,r12
800062b0:	80 00       	ld.sh	r0,r0[0x0]
800062b2:	54 ce       	stdsp	sp[0x130],lr
800062b4:	80 00       	ld.sh	r0,r0[0x0]
800062b6:	55 02       	stdsp	sp[0x140],r2
800062b8:	00 00       	add	r0,r0
800062ba:	0d 30       	ld.ub	r0,r6++
800062bc:	80 00       	ld.sh	r0,r0[0x0]
800062be:	54 b2       	stdsp	sp[0x12c],r2
800062c0:	00 00       	add	r0,r0
800062c2:	0d 08       	ld.w	r8,r6++
800062c4:	80 00       	ld.sh	r0,r0[0x0]
800062c6:	61 94       	ld.w	r4,r0[0x64]

800062c8 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
800062c8:	eb cd 40 f8 	pushm	r3-r7,lr
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
800062cc:	49 67       	lddpc	r7,80006324 <prvIdleTask+0x5c>
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
800062ce:	49 74       	lddpc	r4,80006328 <prvIdleTask+0x60>

				taskENTER_CRITICAL();
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					--uxCurrentNumberOfTasks;
800062d0:	49 73       	lddpc	r3,8000632c <prvIdleTask+0x64>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
800062d2:	49 85       	lddpc	r5,80006330 <prvIdleTask+0x68>
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
800062d4:	6e 08       	ld.w	r8,r7[0x0]
800062d6:	58 08       	cp.w	r8,0
800062d8:	c1 e0       	breq	80006314 <prvIdleTask+0x4c>
		{
			vTaskSuspendAll();
800062da:	f0 1f 00 17 	mcall	80006334 <prvIdleTask+0x6c>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
800062de:	68 06       	ld.w	r6,r4[0x0]
			xTaskResumeAll();
800062e0:	f0 1f 00 16 	mcall	80006338 <prvIdleTask+0x70>

			if( xListIsEmpty == pdFALSE )
800062e4:	58 06       	cp.w	r6,0
800062e6:	c1 70       	breq	80006314 <prvIdleTask+0x4c>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
800062e8:	f0 1f 00 15 	mcall	8000633c <prvIdleTask+0x74>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
800062ec:	68 38       	ld.w	r8,r4[0xc]
800062ee:	70 36       	ld.w	r6,r8[0xc]
					vListRemove( &( pxTCB->xGenericListItem ) );
800062f0:	ec cc ff fc 	sub	r12,r6,-4
800062f4:	f0 1f 00 13 	mcall	80006340 <prvIdleTask+0x78>
					--uxCurrentNumberOfTasks;
800062f8:	66 08       	ld.w	r8,r3[0x0]
800062fa:	20 18       	sub	r8,1
800062fc:	87 08       	st.w	r3[0x0],r8
					--uxTasksDeleted;
800062fe:	6e 08       	ld.w	r8,r7[0x0]
80006300:	20 18       	sub	r8,1
80006302:	8f 08       	st.w	r7[0x0],r8
				}
				taskEXIT_CRITICAL();
80006304:	f0 1f 00 10 	mcall	80006344 <prvIdleTask+0x7c>

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
80006308:	6c cc       	ld.w	r12,r6[0x30]
8000630a:	f0 1f 00 10 	mcall	80006348 <prvIdleTask+0x80>
		vPortFree( pxTCB );
8000630e:	0c 9c       	mov	r12,r6
80006310:	f0 1f 00 0e 	mcall	80006348 <prvIdleTask+0x80>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80006314:	6a 08       	ld.w	r8,r5[0x0]
80006316:	58 18       	cp.w	r8,1
80006318:	e0 88 00 03 	brls	8000631e <prvIdleTask+0x56>
			{
				taskYIELD();
8000631c:	d7 33       	scall
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
8000631e:	f0 1f 00 0c 	mcall	8000634c <prvIdleTask+0x84>
		}
		#endif
	}
80006322:	cd 9b       	rjmp	800062d4 <prvIdleTask+0xc>
80006324:	00 00       	add	r0,r0
80006326:	0c 1c       	sub	r12,r6
80006328:	00 00       	add	r0,r0
8000632a:	0c c8       	st.b	r6++,r8
8000632c:	00 00       	add	r0,r0
8000632e:	0d 28       	ld.uh	r8,r6++
80006330:	00 00       	add	r0,r0
80006332:	0c 28       	rsub	r8,r6
80006334:	80 00       	ld.sh	r0,r0[0x0]
80006336:	5c f0       	rol	r0
80006338:	80 00       	ld.sh	r0,r0[0x0]
8000633a:	60 ac       	ld.w	r12,r0[0x28]
8000633c:	80 00       	ld.sh	r0,r0[0x0]
8000633e:	55 bc       	stdsp	sp[0x16c],r12
80006340:	80 00       	ld.sh	r0,r0[0x0]
80006342:	55 02       	stdsp	sp[0x140],r2
80006344:	80 00       	ld.sh	r0,r0[0x0]
80006346:	56 c8       	stdsp	sp[0x1b0],r8
80006348:	80 00       	ld.sh	r0,r0[0x0]
8000634a:	58 00       	cp.w	r0,0
8000634c:	80 00       	ld.sh	r0,r0[0x0]
8000634e:	20 2c       	sub	r12,2

80006350 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
80006350:	d4 31       	pushm	r0-r7,lr
80006352:	20 1d       	sub	sp,4
80006354:	fa c4 ff d8 	sub	r4,sp,-40
80006358:	50 0c       	stdsp	sp[0x0],r12
8000635a:	16 91       	mov	r1,r11
8000635c:	14 97       	mov	r7,r10
8000635e:	12 90       	mov	r0,r9
80006360:	10 93       	mov	r3,r8
80006362:	68 02       	ld.w	r2,r4[0x0]
80006364:	68 16       	ld.w	r6,r4[0x4]
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
80006366:	34 8c       	mov	r12,72
80006368:	f0 1f 00 5c 	mcall	800064d8 <xTaskGenericCreate+0x188>
8000636c:	18 95       	mov	r5,r12

	if( pxNewTCB != NULL )
8000636e:	c0 31       	brne	80006374 <xTaskGenericCreate+0x24>
80006370:	3f fc       	mov	r12,-1
80006372:	ca f8       	rjmp	800064d0 <xTaskGenericCreate+0x180>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80006374:	58 06       	cp.w	r6,0
80006376:	e0 81 00 af 	brne	800064d4 <xTaskGenericCreate+0x184>
8000637a:	0e 9c       	mov	r12,r7
8000637c:	5c 7c       	castu.h	r12
8000637e:	a3 6c       	lsl	r12,0x2
80006380:	f0 1f 00 56 	mcall	800064d8 <xTaskGenericCreate+0x188>
80006384:	18 96       	mov	r6,r12
80006386:	8b cc       	st.w	r5[0x30],r12

		if( pxNewTCB->pxStack == NULL )
80006388:	c0 61       	brne	80006394 <xTaskGenericCreate+0x44>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
8000638a:	0a 9c       	mov	r12,r5
8000638c:	f0 1f 00 54 	mcall	800064dc <xTaskGenericCreate+0x18c>
80006390:	3f fc       	mov	r12,-1
80006392:	c9 f8       	rjmp	800064d0 <xTaskGenericCreate+0x180>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
80006394:	5c 77       	castu.h	r7
80006396:	ee 0a 15 02 	lsl	r10,r7,0x2
8000639a:	e0 6b 00 a5 	mov	r11,165
8000639e:	0c 9c       	mov	r12,r6
800063a0:	f0 1f 00 50 	mcall	800064e0 <xTaskGenericCreate+0x190>
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~portBYTE_ALIGNMENT_MASK  ) );
800063a4:	ee c6 00 01 	sub	r6,r7,1
800063a8:	6a c8       	ld.w	r8,r5[0x30]
800063aa:	f0 06 00 26 	add	r6,r8,r6<<0x2
800063ae:	e0 16 ff fc 	andl	r6,0xfffc
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
800063b2:	31 0a       	mov	r10,16
800063b4:	02 9b       	mov	r11,r1
800063b6:	ea cc ff cc 	sub	r12,r5,-52
800063ba:	f0 1f 00 4b 	mcall	800064e4 <xTaskGenericCreate+0x194>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
800063be:	30 08       	mov	r8,0
800063c0:	eb 68 00 43 	st.b	r5[67],r8
800063c4:	58 73       	cp.w	r3,7
800063c6:	e6 07 17 80 	movls	r7,r3
800063ca:	f9 b7 0b 07 	movhi	r7,7
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
800063ce:	8b b7       	st.w	r5[0x2c],r7
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
800063d0:	eb 47 00 44 	st.w	r5[68],r7
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
800063d4:	ea c4 ff fc 	sub	r4,r5,-4
800063d8:	08 9c       	mov	r12,r4
800063da:	f0 1f 00 44 	mcall	800064e8 <xTaskGenericCreate+0x198>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
800063de:	ea cc ff e8 	sub	r12,r5,-24
800063e2:	f0 1f 00 42 	mcall	800064e8 <xTaskGenericCreate+0x198>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
800063e6:	8b 45       	st.w	r5[0x10],r5

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
800063e8:	ee 07 11 08 	rsub	r7,r7,8
800063ec:	8b 67       	st.w	r5[0x18],r7
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
800063ee:	8b 95       	st.w	r5[0x24],r5
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
800063f0:	00 9a       	mov	r10,r0
800063f2:	40 0b       	lddsp	r11,sp[0x0]
800063f4:	0c 9c       	mov	r12,r6
800063f6:	f0 1f 00 3e 	mcall	800064ec <xTaskGenericCreate+0x19c>
800063fa:	8b 0c       	st.w	r5[0x0],r12
		if( ( void * ) pxCreatedTask != NULL )
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
800063fc:	58 02       	cp.w	r2,0
800063fe:	e5 f5 1a 00 	st.wne	r2[0x0],r5
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
80006402:	f0 1f 00 3c 	mcall	800064f0 <xTaskGenericCreate+0x1a0>
		{
			uxCurrentNumberOfTasks++;
80006406:	4b c8       	lddpc	r8,800064f4 <xTaskGenericCreate+0x1a4>
80006408:	70 09       	ld.w	r9,r8[0x0]
8000640a:	2f f9       	sub	r9,-1
8000640c:	91 09       	st.w	r8[0x0],r9
			if( pxCurrentTCB == NULL )
8000640e:	4b b8       	lddpc	r8,800064f8 <xTaskGenericCreate+0x1a8>
80006410:	70 08       	ld.w	r8,r8[0x0]
80006412:	58 08       	cp.w	r8,0
80006414:	c2 61       	brne	80006460 <xTaskGenericCreate+0x110>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
80006416:	4b 98       	lddpc	r8,800064f8 <xTaskGenericCreate+0x1a8>
80006418:	91 05       	st.w	r8[0x0],r5

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
8000641a:	4b 78       	lddpc	r8,800064f4 <xTaskGenericCreate+0x1a4>
8000641c:	70 08       	ld.w	r8,r8[0x0]
8000641e:	58 18       	cp.w	r8,1
80006420:	c2 b1       	brne	80006476 <xTaskGenericCreate+0x126>
80006422:	4b 77       	lddpc	r7,800064fc <xTaskGenericCreate+0x1ac>

/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
80006424:	ee c6 ff 60 	sub	r6,r7,-160
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
80006428:	0e 9c       	mov	r12,r7
8000642a:	f0 1f 00 36 	mcall	80006500 <xTaskGenericCreate+0x1b0>
8000642e:	2e c7       	sub	r7,-20

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
80006430:	0c 37       	cp.w	r7,r6
80006432:	cf b1       	brne	80006428 <xTaskGenericCreate+0xd8>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
80006434:	4b 47       	lddpc	r7,80006504 <xTaskGenericCreate+0x1b4>
80006436:	0e 9c       	mov	r12,r7
80006438:	f0 1f 00 32 	mcall	80006500 <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
8000643c:	4b 36       	lddpc	r6,80006508 <xTaskGenericCreate+0x1b8>
8000643e:	0c 9c       	mov	r12,r6
80006440:	f0 1f 00 30 	mcall	80006500 <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xPendingReadyList );
80006444:	4b 2c       	lddpc	r12,8000650c <xTaskGenericCreate+0x1bc>
80006446:	f0 1f 00 2f 	mcall	80006500 <xTaskGenericCreate+0x1b0>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
8000644a:	4b 2c       	lddpc	r12,80006510 <xTaskGenericCreate+0x1c0>
8000644c:	f0 1f 00 2d 	mcall	80006500 <xTaskGenericCreate+0x1b0>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
80006450:	4b 1c       	lddpc	r12,80006514 <xTaskGenericCreate+0x1c4>
80006452:	f0 1f 00 2c 	mcall	80006500 <xTaskGenericCreate+0x1b0>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
80006456:	4b 18       	lddpc	r8,80006518 <xTaskGenericCreate+0x1c8>
80006458:	91 07       	st.w	r8[0x0],r7
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
8000645a:	4b 18       	lddpc	r8,8000651c <xTaskGenericCreate+0x1cc>
8000645c:	91 06       	st.w	r8[0x0],r6
8000645e:	c0 c8       	rjmp	80006476 <xTaskGenericCreate+0x126>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
80006460:	4b 08       	lddpc	r8,80006520 <xTaskGenericCreate+0x1d0>
80006462:	70 08       	ld.w	r8,r8[0x0]
80006464:	58 08       	cp.w	r8,0
80006466:	c0 81       	brne	80006476 <xTaskGenericCreate+0x126>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
80006468:	4a 48       	lddpc	r8,800064f8 <xTaskGenericCreate+0x1a8>
8000646a:	70 08       	ld.w	r8,r8[0x0]
8000646c:	70 b8       	ld.w	r8,r8[0x2c]
8000646e:	10 33       	cp.w	r3,r8
80006470:	c0 33       	brcs	80006476 <xTaskGenericCreate+0x126>
					{
						pxCurrentTCB = pxNewTCB;
80006472:	4a 28       	lddpc	r8,800064f8 <xTaskGenericCreate+0x1a8>
80006474:	91 05       	st.w	r8[0x0],r5
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
80006476:	6a b8       	ld.w	r8,r5[0x2c]
80006478:	4a b9       	lddpc	r9,80006524 <xTaskGenericCreate+0x1d4>
8000647a:	72 09       	ld.w	r9,r9[0x0]
8000647c:	12 38       	cp.w	r8,r9
8000647e:	e0 88 00 04 	brls	80006486 <xTaskGenericCreate+0x136>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
80006482:	4a 99       	lddpc	r9,80006524 <xTaskGenericCreate+0x1d4>
80006484:	93 08       	st.w	r9[0x0],r8
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
80006486:	4a 98       	lddpc	r8,80006528 <xTaskGenericCreate+0x1d8>
80006488:	70 09       	ld.w	r9,r8[0x0]
8000648a:	2f f9       	sub	r9,-1
8000648c:	91 09       	st.w	r8[0x0],r9

			prvAddTaskToReadyQueue( pxNewTCB );
8000648e:	6a b8       	ld.w	r8,r5[0x2c]
80006490:	4a 79       	lddpc	r9,8000652c <xTaskGenericCreate+0x1dc>
80006492:	72 09       	ld.w	r9,r9[0x0]
80006494:	12 38       	cp.w	r8,r9
80006496:	e0 88 00 04 	brls	8000649e <xTaskGenericCreate+0x14e>
8000649a:	4a 59       	lddpc	r9,8000652c <xTaskGenericCreate+0x1dc>
8000649c:	93 08       	st.w	r9[0x0],r8
8000649e:	6a bc       	ld.w	r12,r5[0x2c]
800064a0:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800064a4:	08 9b       	mov	r11,r4
800064a6:	49 68       	lddpc	r8,800064fc <xTaskGenericCreate+0x1ac>
800064a8:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800064ac:	f0 1f 00 21 	mcall	80006530 <xTaskGenericCreate+0x1e0>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
800064b0:	f0 1f 00 21 	mcall	80006534 <xTaskGenericCreate+0x1e4>
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
800064b4:	49 b8       	lddpc	r8,80006520 <xTaskGenericCreate+0x1d0>
800064b6:	70 08       	ld.w	r8,r8[0x0]
800064b8:	58 08       	cp.w	r8,0
800064ba:	c0 a0       	breq	800064ce <xTaskGenericCreate+0x17e>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
800064bc:	48 f8       	lddpc	r8,800064f8 <xTaskGenericCreate+0x1a8>
800064be:	70 08       	ld.w	r8,r8[0x0]
800064c0:	70 b8       	ld.w	r8,r8[0x2c]
800064c2:	10 33       	cp.w	r3,r8
800064c4:	e0 88 00 05 	brls	800064ce <xTaskGenericCreate+0x17e>
			{
				portYIELD_WITHIN_API();
800064c8:	d7 33       	scall
800064ca:	30 1c       	mov	r12,1
800064cc:	c0 28       	rjmp	800064d0 <xTaskGenericCreate+0x180>
800064ce:	30 1c       	mov	r12,1
			}
		}
	}

	return xReturn;
}
800064d0:	2f fd       	sub	sp,-4
800064d2:	d8 32       	popm	r0-r7,pc
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
800064d4:	99 c6       	st.w	r12[0x30],r6
800064d6:	c5 fb       	rjmp	80006394 <xTaskGenericCreate+0x44>
800064d8:	80 00       	ld.sh	r0,r0[0x0]
800064da:	58 28       	cp.w	r8,2
800064dc:	80 00       	ld.sh	r0,r0[0x0]
800064de:	58 00       	cp.w	r0,0
800064e0:	80 00       	ld.sh	r0,r0[0x0]
800064e2:	70 fa       	ld.w	r10,r8[0x3c]
800064e4:	80 00       	ld.sh	r0,r0[0x0]
800064e6:	74 24       	ld.w	r4,r10[0x8]
800064e8:	80 00       	ld.sh	r0,r0[0x0]
800064ea:	54 ac       	stdsp	sp[0x128],r12
800064ec:	80 00       	ld.sh	r0,r0[0x0]
800064ee:	55 28       	stdsp	sp[0x148],r8
800064f0:	80 00       	ld.sh	r0,r0[0x0]
800064f2:	55 bc       	stdsp	sp[0x16c],r12
800064f4:	00 00       	add	r0,r0
800064f6:	0d 28       	ld.uh	r8,r6++
800064f8:	00 00       	add	r0,r0
800064fa:	0c dc       	st.w	--r6,r12
800064fc:	00 00       	add	r0,r0
800064fe:	0c 28       	rsub	r8,r6
80006500:	80 00       	ld.sh	r0,r0[0x0]
80006502:	54 98       	stdsp	sp[0x124],r8
80006504:	00 00       	add	r0,r0
80006506:	0c f4       	st.b	--r6,r4
80006508:	00 00       	add	r0,r0
8000650a:	0d 10       	ld.sh	r0,r6++
8000650c:	00 00       	add	r0,r0
8000650e:	0c e0       	st.h	--r6,r0
80006510:	00 00       	add	r0,r0
80006512:	0c c8       	st.b	r6++,r8
80006514:	00 00       	add	r0,r0
80006516:	0d 30       	ld.ub	r0,r6++
80006518:	00 00       	add	r0,r0
8000651a:	0c 14       	sub	r4,r6
8000651c:	00 00       	add	r0,r0
8000651e:	0c 24       	rsub	r4,r6
80006520:	00 00       	add	r0,r0
80006522:	0c 18       	sub	r8,r6
80006524:	00 00       	add	r0,r0
80006526:	0c 10       	sub	r0,r6
80006528:	00 00       	add	r0,r0
8000652a:	0d 24       	ld.uh	r4,r6++
8000652c:	00 00       	add	r0,r0
8000652e:	0d 44       	ld.w	r4,--r6
80006530:	80 00       	ld.sh	r0,r0[0x0]
80006532:	54 b2       	stdsp	sp[0x12c],r2
80006534:	80 00       	ld.sh	r0,r0[0x0]
80006536:	56 c8       	stdsp	sp[0x1b0],r8

80006538 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
80006538:	d4 01       	pushm	lr
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
8000653a:	30 09       	mov	r9,0
8000653c:	1a d9       	st.w	--sp,r9
8000653e:	1a d9       	st.w	--sp,r9
80006540:	1a d9       	st.w	--sp,r9
80006542:	12 98       	mov	r8,r9
80006544:	e0 6a 01 00 	mov	r10,256
80006548:	48 9b       	lddpc	r11,8000656c <vTaskStartScheduler+0x34>
8000654a:	48 ac       	lddpc	r12,80006570 <vTaskStartScheduler+0x38>
8000654c:	f0 1f 00 0a 	mcall	80006574 <vTaskStartScheduler+0x3c>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
80006550:	2f dd       	sub	sp,-12
80006552:	58 1c       	cp.w	r12,1
80006554:	c0 a1       	brne	80006568 <vTaskStartScheduler+0x30>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
80006556:	d3 03       	ssrf	0x10

		xSchedulerRunning = pdTRUE;
80006558:	30 19       	mov	r9,1
8000655a:	48 88       	lddpc	r8,80006578 <vTaskStartScheduler+0x40>
8000655c:	91 09       	st.w	r8[0x0],r9
		xTickCount = ( portTickType ) 0;
8000655e:	30 09       	mov	r9,0
80006560:	48 78       	lddpc	r8,8000657c <vTaskStartScheduler+0x44>
80006562:	91 09       	st.w	r8[0x0],r9
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
80006564:	f0 1f 00 07 	mcall	80006580 <vTaskStartScheduler+0x48>
80006568:	d8 02       	popm	pc
8000656a:	00 00       	add	r0,r0
8000656c:	80 00       	ld.sh	r0,r0[0x0]
8000656e:	d0 d4       	*unknown*
80006570:	80 00       	ld.sh	r0,r0[0x0]
80006572:	62 c8       	ld.w	r8,r1[0x30]
80006574:	80 00       	ld.sh	r0,r0[0x0]
80006576:	63 50       	ld.w	r0,r1[0x54]
80006578:	00 00       	add	r0,r0
8000657a:	0c 18       	sub	r8,r6
8000657c:	00 00       	add	r0,r0
8000657e:	0d 08       	ld.w	r8,r6++
80006580:	80 00       	ld.sh	r0,r0[0x0]
80006582:	55 cc       	stdsp	sp[0x170],r12

80006584 <PrintChar>:
	
static void task_log(void * pvParameters);

char *  PrintChar(char c, char * str)
{
	*str++ = c;
80006584:	16 cc       	st.b	r11++,r12
	return str;
}
80006586:	5e fb       	retal	r11

80006588 <PrintHex>:
	
	return str;
}

char * PrintHex(int i,char len, char * str)
{
80006588:	eb cd 40 c0 	pushm	r6-r7,lr
8000658c:	20 3d       	sub	sp,12
8000658e:	18 98       	mov	r8,r12
	char * p = str;
	char s[12];
	memset(s, 0 , 12);
80006590:	30 06       	mov	r6,0
80006592:	30 07       	mov	r7,0
80006594:	fa e7 00 00 	st.d	sp[0],r6
80006598:	30 0c       	mov	r12,0
8000659a:	50 2c       	stdsp	sp[0x8],r12
	int cnt=0;
	
	if(i)
8000659c:	58 08       	cp.w	r8,0
8000659e:	c1 30       	breq	800065c4 <PrintHex+0x3c>
800065a0:	18 99       	mov	r9,r12
	while(i)
	{
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
800065a2:	1a 9c       	mov	r12,sp
800065a4:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
800065a8:	58 9e       	cp.w	lr,9
800065aa:	e0 8a 00 04 	brle	800065b2 <PrintHex+0x2a>
800065ae:	2c 9e       	sub	lr,-55
800065b0:	c0 48       	rjmp	800065b8 <PrintHex+0x30>
800065b2:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
800065b6:	2d 0e       	sub	lr,-48
800065b8:	f8 09 0b 0e 	st.b	r12[r9],lr
800065bc:	2f f9       	sub	r9,-1
		i = (i >> 4 ) & 0x0FFFFFFF;
800065be:	a5 88       	lsr	r8,0x4
	char s[12];
	memset(s, 0 , 12);
	int cnt=0;
	
	if(i)
	while(i)
800065c0:	cf 21       	brne	800065a4 <PrintHex+0x1c>
800065c2:	c0 48       	rjmp	800065ca <PrintHex+0x42>
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
		i = (i >> 4 ) & 0x0FFFFFFF;
		//i >>= 4
	}
	else
	s[cnt++] = '0';
800065c4:	33 08       	mov	r8,48
800065c6:	ba 88       	st.b	sp[0x0],r8
800065c8:	30 19       	mov	r9,1
	
	if(len - cnt > 0 )
800065ca:	f6 09 01 08 	sub	r8,r11,r9
800065ce:	58 08       	cp.w	r8,0
800065d0:	e0 8a 00 13 	brle	800065f6 <PrintHex+0x6e>
	{
		char num = len - cnt;
800065d4:	12 1b       	sub	r11,r9
800065d6:	f9 db c0 08 	bfextu	r12,r11,0x0,0x8
		for(int i = 0; i < num; i++)
800065da:	18 9e       	mov	lr,r12
800065dc:	58 0c       	cp.w	r12,0
800065de:	e0 8a 00 0c 	brle	800065f6 <PrintHex+0x6e>
800065e2:	1a 9b       	mov	r11,sp
800065e4:	12 0b       	add	r11,r9
800065e6:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
800065e8:	33 07       	mov	r7,48
800065ea:	16 c7       	st.b	r11++,r7
	s[cnt++] = '0';
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
800065ec:	2f f8       	sub	r8,-1
800065ee:	1c 38       	cp.w	r8,lr
800065f0:	cf d5       	brlt	800065ea <PrintHex+0x62>
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
800065f2:	f8 09 00 09 	add	r9,r12,r9
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
800065f6:	f2 c8 ff ff 	sub	r8,r9,-1
	s[cnt++] = '0';
	
	while(cnt>0)
800065fa:	f0 cb ff ff 	sub	r11,r8,-1
800065fe:	58 0b       	cp.w	r11,0
80006600:	e0 8a 00 19 	brle	80006632 <PrintHex+0xaa>
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80006604:	fa cb ff f4 	sub	r11,sp,-12
80006608:	f6 09 00 09 	add	r9,r11,r9
8000660c:	37 8b       	mov	r11,120
8000660e:	f3 6b ff f4 	st.b	r9[-12],r11
	s[cnt++] = '0';
80006612:	fa c9 ff f4 	sub	r9,sp,-12
80006616:	10 09       	add	r9,r8
80006618:	33 0b       	mov	r11,48
8000661a:	f3 6b ff f4 	st.b	r9[-12],r11
8000661e:	fa 08 00 08 	add	r8,sp,r8
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
80006622:	fa ce 00 01 	sub	lr,sp,1
80006626:	14 99       	mov	r9,r10
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
	*p++ = s[--cnt];
80006628:	11 8b       	ld.ub	r11,r8[0x0]
8000662a:	12 cb       	st.b	r9++,r11
8000662c:	20 18       	sub	r8,1
	}
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
8000662e:	1c 38       	cp.w	r8,lr
80006630:	cf c1       	brne	80006628 <PrintHex+0xa0>
	*p++ = s[--cnt];
		
	return str;
}
80006632:	14 9c       	mov	r12,r10
80006634:	2f dd       	sub	sp,-12
80006636:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

8000663a <PrintDec>:
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
{
8000663a:	d4 21       	pushm	r4-r7,lr
8000663c:	20 3d       	sub	sp,12
8000663e:	18 98       	mov	r8,r12
	char * p = str;
	
	int sign = i>=0 ? 0 : 1;
	char s[10];
	memset(s, 0 , 10);
80006640:	30 06       	mov	r6,0
80006642:	30 07       	mov	r7,0
80006644:	fa e7 00 00 	st.d	sp[0],r6
80006648:	30 0c       	mov	r12,0
8000664a:	ba 4c       	st.h	sp[0x8],r12
	int cnt=0;
	if(sign)
8000664c:	58 08       	cp.w	r8,0
8000664e:	c0 35       	brlt	80006654 <PrintDec+0x1a>
80006650:	14 97       	mov	r7,r10
80006652:	c0 58       	rjmp	8000665c <PrintDec+0x22>
	{
		*p++ = '-';
80006654:	14 97       	mov	r7,r10
80006656:	32 d9       	mov	r9,45
80006658:	0e c9       	st.b	r7++,r9
		i = -i;
8000665a:	5c 38       	neg	r8
	}
	
	if(i == 0 )s[cnt++] = '0';
8000665c:	58 08       	cp.w	r8,0
8000665e:	c0 51       	brne	80006668 <PrintDec+0x2e>
80006660:	33 08       	mov	r8,48
80006662:	ba 88       	st.b	sp[0x0],r8
80006664:	30 1e       	mov	lr,1
80006666:	c2 f8       	rjmp	800066c4 <PrintDec+0x8a>
	
	int ten = i%10;
80006668:	e0 65 66 67 	mov	r5,26215
8000666c:	ea 15 66 66 	orh	r5,0x6666
80006670:	f0 05 04 44 	muls.d	r4,r8,r5
80006674:	ea 0c 14 02 	asr	r12,r5,0x2
80006678:	f0 09 14 1f 	asr	r9,r8,0x1f
8000667c:	f8 09 01 09 	sub	r9,r12,r9
80006680:	f2 09 00 29 	add	r9,r9,r9<<0x2
80006684:	f0 09 01 19 	sub	r9,r8,r9<<0x1
80006688:	30 0e       	mov	lr,0
	while(i)
	{
		s[cnt] = ten+'0';
8000668a:	1a 9c       	mov	r12,sp
		cnt++;
		i /= 10;
8000668c:	e0 66 66 67 	mov	r6,26215
80006690:	ea 16 66 66 	orh	r6,0x6666
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
	{
		s[cnt] = ten+'0';
80006694:	2d 09       	sub	r9,-48
80006696:	f8 0e 0b 09 	st.b	r12[lr],r9
		cnt++;
8000669a:	2f fe       	sub	lr,-1
		i /= 10;
8000669c:	f0 06 04 44 	muls.d	r4,r8,r6
800066a0:	ea 09 14 02 	asr	r9,r5,0x2
800066a4:	bf 58       	asr	r8,0x1f
800066a6:	f2 08 01 08 	sub	r8,r9,r8
		ten = i%10;
800066aa:	f0 06 04 44 	muls.d	r4,r8,r6
800066ae:	ea 09 14 02 	asr	r9,r5,0x2
800066b2:	f0 05 14 1f 	asr	r5,r8,0x1f
800066b6:	0a 19       	sub	r9,r5
800066b8:	f2 09 00 29 	add	r9,r9,r9<<0x2
800066bc:	f0 09 01 19 	sub	r9,r8,r9<<0x1
	}
	
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
800066c0:	58 08       	cp.w	r8,0
800066c2:	ce 91       	brne	80006694 <PrintDec+0x5a>
		cnt++;
		i /= 10;
		ten = i%10;
	}
	
	if(len - cnt > 0 )
800066c4:	f6 0e 01 08 	sub	r8,r11,lr
800066c8:	58 08       	cp.w	r8,0
800066ca:	e0 89 00 06 	brgt	800066d6 <PrintDec+0x9c>
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
800066ce:	58 0e       	cp.w	lr,0
800066d0:	e0 89 00 14 	brgt	800066f8 <PrintDec+0xbe>
800066d4:	c1 d8       	rjmp	8000670e <PrintDec+0xd4>
		ten = i%10;
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
800066d6:	1c 1b       	sub	r11,lr
800066d8:	5c 5b       	castu.b	r11
		for(int i = 0; i < num; i++)
800066da:	16 9c       	mov	r12,r11
800066dc:	58 0b       	cp.w	r11,0
800066de:	fe 9a ff f8 	brle	800066ce <PrintDec+0x94>
800066e2:	1a 99       	mov	r9,sp
800066e4:	1c 09       	add	r9,lr
800066e6:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
800066e8:	33 06       	mov	r6,48
800066ea:	12 c6       	st.b	r9++,r6
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
800066ec:	2f f8       	sub	r8,-1
800066ee:	18 38       	cp.w	r8,r12
800066f0:	cf d5       	brlt	800066ea <PrintDec+0xb0>
{
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
800066f2:	f6 0e 00 0e 	add	lr,r11,lr
800066f6:	ce cb       	rjmp	800066ce <PrintDec+0x94>
800066f8:	fa c8 ff f4 	sub	r8,sp,-12
800066fc:	1c 08       	add	r8,lr
800066fe:	20 d8       	sub	r8,13
80006700:	fa cb 00 01 	sub	r11,sp,1
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
	*p++ = s[--cnt];
80006704:	11 89       	ld.ub	r9,r8[0x0]
80006706:	0e c9       	st.b	r7++,r9
80006708:	20 18       	sub	r8,1
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
8000670a:	16 38       	cp.w	r8,r11
8000670c:	cf c1       	brne	80006704 <PrintDec+0xca>
	*p++ = s[--cnt];
	
	return str;
}
8000670e:	14 9c       	mov	r12,r10
80006710:	2f dd       	sub	sp,-12
80006712:	d8 22       	popm	r4-r7,pc

80006714 <log>:
	,  NULL );
	
}

int log(char * content, ...)
{
80006714:	d4 31       	pushm	r0-r7,lr
80006716:	fa cd 02 08 	sub	sp,sp,520
8000671a:	18 97       	mov	r7,r12
	
	
	char logTmp[MAX_LOG_LINE_SIZE];
	memset(logTmp, '\0', MAX_LOG_LINE_SIZE);	
8000671c:	e0 6a 01 00 	mov	r10,256
80006720:	30 0b       	mov	r11,0
80006722:	fa cc fe f8 	sub	r12,sp,-264
80006726:	f0 1f 00 4e 	mcall	8000685c <log+0x148>
	,  tskLOG_PRIORITY
	,  NULL );
	
}

int log(char * content, ...)
8000672a:	fa c4 fd d4 	sub	r4,sp,-556
8000672e:	30 0a       	mov	r10,0
80006730:	50 0a       	stdsp	sp[0x0],r10
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80006732:	fa c3 ff fc 	sub	r3,sp,-4
80006736:	e0 61 01 00 	mov	r1,256
8000673a:	14 90       	mov	r0,r10
			
					if(*str == '%')
8000673c:	32 52       	mov	r2,37
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
8000673e:	fa c6 fe f8 	sub	r6,sp,-264
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80006742:	02 9a       	mov	r10,r1
80006744:	00 9b       	mov	r11,r0
80006746:	06 9c       	mov	r12,r3
80006748:	f0 1f 00 45 	mcall	8000685c <log+0x148>
			
					if(*str == '%')
8000674c:	0f 88       	ld.ub	r8,r7[0x0]
8000674e:	e4 08 18 00 	cp.b	r8,r2
80006752:	c5 71       	brne	80006800 <log+0xec>
					{
						static char lench = 0;
						lench =*(str + 1);
80006754:	ee c8 ff ff 	sub	r8,r7,-1
80006758:	11 89       	ld.ub	r9,r8[0x0]
8000675a:	4c 2a       	lddpc	r10,80006860 <log+0x14c>
8000675c:	b4 89       	st.b	r10[0x0],r9
						if((lench >= '0') &&  (lench <= '9'))
8000675e:	23 09       	sub	r9,48
80006760:	30 9a       	mov	r10,9
80006762:	f4 09 18 00 	cp.b	r9,r10
80006766:	ee 08 17 b0 	movhi	r8,r7
						{
							len = *(++str) - '0';
8000676a:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
8000676e:	f7 b9 08 30 	subls	r9,48
80006772:	fb f9 8a 00 	st.wls	sp[0x0],r9
						}
						
						str++;
80006776:	f0 c7 ff ff 	sub	r7,r8,-1
						
						switch(*(str))
8000677a:	0f 88       	ld.ub	r8,r7[0x0]
8000677c:	22 58       	sub	r8,37
8000677e:	e0 48 00 53 	cp.w	r8,83
80006782:	e0 8b 00 31 	brhi	800067e4 <log+0xd0>
80006786:	4b 89       	lddpc	r9,80006864 <log+0x150>
80006788:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
						{
							case('i'):
							case('I'):
							case('d'):
							case('D'):
							x = va_arg(arg_ptr,int);
8000678c:	e8 c5 ff fc 	sub	r5,r4,-4
							strTmp = PrintDec(x, len, strTmp);
80006790:	06 9a       	mov	r10,r3
80006792:	40 0b       	lddsp	r11,sp[0x0]
80006794:	5c 5b       	castu.b	r11
80006796:	68 0c       	ld.w	r12,r4[0x0]
80006798:	f0 1f 00 34 	mcall	80006868 <log+0x154>
							break;
8000679c:	c2 98       	rjmp	800067ee <log+0xda>
							
							case('f')://浮点数输出
							case('F'):
							//f = va_arg(arg_ptr,int);
							//strTmp = PrintDec(x, len, strTmp);
							log("I need float.");
8000679e:	4b 4c       	lddpc	r12,8000686c <log+0x158>
800067a0:	f0 1f 00 34 	mcall	80006870 <log+0x15c>
800067a4:	08 95       	mov	r5,r4
800067a6:	06 9c       	mov	r12,r3
							break;
800067a8:	c2 38       	rjmp	800067ee <log+0xda>
							
							
							case('x'):
							case('X'):
							x = va_arg(arg_ptr,int);
800067aa:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintHex(x,len, strTmp);
800067ae:	06 9a       	mov	r10,r3
800067b0:	40 0b       	lddsp	r11,sp[0x0]
800067b2:	5c 5b       	castu.b	r11
800067b4:	68 0c       	ld.w	r12,r4[0x0]
800067b6:	f0 1f 00 30 	mcall	80006874 <log+0x160>
800067ba:	06 9c       	mov	r12,r3
							break;
800067bc:	c1 98       	rjmp	800067ee <log+0xda>
							
							case('c'):
							case('C'):
							y = va_arg(arg_ptr,int);
800067be:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintChar(y, strTmp);
800067c2:	06 9b       	mov	r11,r3
800067c4:	09 bc       	ld.ub	r12,r4[0x3]
800067c6:	f0 1f 00 2d 	mcall	80006878 <log+0x164>
800067ca:	06 9c       	mov	r12,r3
							break;
800067cc:	c1 18       	rjmp	800067ee <log+0xda>
							
							case('s'):
							case('S'):
							strTmp = va_arg(arg_ptr,char*);
800067ce:	e8 c5 ff fc 	sub	r5,r4,-4
800067d2:	68 0c       	ld.w	r12,r4[0x0]
							//PrintStr(s);
							break;
800067d4:	c0 d8       	rjmp	800067ee <log+0xda>
							
							case('%'):
							PrintChar('%', strTmp);
800067d6:	06 9b       	mov	r11,r3
800067d8:	32 5c       	mov	r12,37
800067da:	f0 1f 00 28 	mcall	80006878 <log+0x164>
800067de:	08 95       	mov	r5,r4
800067e0:	06 9c       	mov	r12,r3
							//PrintChar('%');
							break;
800067e2:	c0 68       	rjmp	800067ee <log+0xda>
							
							default:
							log("I need relax.");
800067e4:	4a 6c       	lddpc	r12,8000687c <log+0x168>
800067e6:	f0 1f 00 23 	mcall	80006870 <log+0x15c>
800067ea:	08 95       	mov	r5,r4
800067ec:	06 9c       	mov	r12,r3
						}
						str++;
800067ee:	2f f7       	sub	r7,-1
						
						length = sprintf(logTmp,"%s%s",logTmp,strTmp );
800067f0:	1a dc       	st.w	--sp,r12
800067f2:	1a d6       	st.w	--sp,r6
800067f4:	4a 3b       	lddpc	r11,80006880 <log+0x16c>
800067f6:	0c 9c       	mov	r12,r6
800067f8:	f0 1f 00 23 	mcall	80006884 <log+0x170>
800067fc:	2f ed       	sub	sp,-8
800067fe:	c0 a8       	rjmp	80006812 <log+0xfe>
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
80006800:	2f f7       	sub	r7,-1
80006802:	1a d8       	st.w	--sp,r8
80006804:	1a d6       	st.w	--sp,r6
80006806:	4a 1b       	lddpc	r11,80006888 <log+0x174>
80006808:	0c 9c       	mov	r12,r6
8000680a:	f0 1f 00 1f 	mcall	80006884 <log+0x170>
8000680e:	08 95       	mov	r5,r4
80006810:	2f ed       	sub	sp,-8
			
			
			
	}while(*str != '\0');
80006812:	0f 89       	ld.ub	r9,r7[0x0]
80006814:	30 08       	mov	r8,0
80006816:	f0 09 18 00 	cp.b	r9,r8
8000681a:	c0 30       	breq	80006820 <log+0x10c>
8000681c:	0a 94       	mov	r4,r5
8000681e:	c9 2b       	rjmp	80006742 <log+0x2e>
		
		
				
	va_end(arg_ptr);
	//while(1)		
	length = sprintf(logTmp,"%s\r\n",logTmp);
80006820:	fa c7 fe f8 	sub	r7,sp,-264
80006824:	1a d7       	st.w	--sp,r7
80006826:	49 ab       	lddpc	r11,8000688c <log+0x178>
80006828:	0e 9c       	mov	r12,r7
8000682a:	f0 1f 00 17 	mcall	80006884 <log+0x170>
	
	char * p = pvPortMalloc(length+1);
8000682e:	5c 5c       	castu.b	r12
80006830:	f8 c6 ff ff 	sub	r6,r12,-1
80006834:	0c 9c       	mov	r12,r6
80006836:	f0 1f 00 17 	mcall	80006890 <log+0x17c>
8000683a:	54 2c       	stdsp	sp[0x108],r12
	memcpy(p, logTmp, length+1);
8000683c:	0c 9a       	mov	r10,r6
8000683e:	0e 9b       	mov	r11,r7
80006840:	f0 1f 00 15 	mcall	80006894 <log+0x180>
	//
	//usart_write_line(EXAMPLE_USART, logTmp)
	
	xQueueSend( logQueue, &p, 5);
80006844:	30 09       	mov	r9,0
80006846:	30 5a       	mov	r10,5
80006848:	fa cb fe f8 	sub	r11,sp,-264
8000684c:	49 38       	lddpc	r8,80006898 <log+0x184>
8000684e:	70 0c       	ld.w	r12,r8[0x0]
80006850:	f0 1f 00 13 	mcall	8000689c <log+0x188>
80006854:	2f fd       	sub	sp,-4
	
	
}
80006856:	fe 3d fd f8 	sub	sp,-520
8000685a:	d8 32       	popm	r0-r7,pc
8000685c:	80 00       	ld.sh	r0,r0[0x0]
8000685e:	70 fa       	ld.w	r10,r8[0x3c]
80006860:	00 00       	add	r0,r0
80006862:	0d 48       	ld.w	r8,--r6
80006864:	80 00       	ld.sh	r0,r0[0x0]
80006866:	d0 dc       	*unknown*
80006868:	80 00       	ld.sh	r0,r0[0x0]
8000686a:	66 3a       	ld.w	r10,r3[0xc]
8000686c:	80 00       	ld.sh	r0,r0[0x0]
8000686e:	d3 88       	*unknown*
80006870:	80 00       	ld.sh	r0,r0[0x0]
80006872:	67 14       	ld.w	r4,r3[0x44]
80006874:	80 00       	ld.sh	r0,r0[0x0]
80006876:	65 88       	ld.w	r8,r2[0x60]
80006878:	80 00       	ld.sh	r0,r0[0x0]
8000687a:	65 84       	ld.w	r4,r2[0x60]
8000687c:	80 00       	ld.sh	r0,r0[0x0]
8000687e:	d3 98       	*unknown*
80006880:	80 00       	ld.sh	r0,r0[0x0]
80006882:	d3 a8       	*unknown*
80006884:	80 00       	ld.sh	r0,r0[0x0]
80006886:	73 e8       	ld.w	r8,r9[0x78]
80006888:	80 00       	ld.sh	r0,r0[0x0]
8000688a:	d3 b0       	acall	0x3b
8000688c:	80 00       	ld.sh	r0,r0[0x0]
8000688e:	d3 b8       	*unknown*
80006890:	80 00       	ld.sh	r0,r0[0x0]
80006892:	58 28       	cp.w	r8,2
80006894:	80 00       	ld.sh	r0,r0[0x0]
80006896:	6f b2       	ld.w	r2,r7[0x6c]
80006898:	00 00       	add	r0,r0
8000689a:	63 98       	ld.w	r8,r1[0x64]
8000689c:	80 00       	ld.sh	r0,r0[0x0]
8000689e:	5b 7c       	cp.w	r12,-9

800068a0 <logFromISR>:
	
	
int logFromISR(char * content, ...)
	{
800068a0:	d4 31       	pushm	r0-r7,lr
800068a2:	fa cd 02 0c 	sub	sp,sp,524
800068a6:	18 97       	mov	r7,r12
		
		
		char logTmp[MAX_LOG_LINE_SIZE];
		memset(logTmp, '\0', MAX_LOG_LINE_SIZE);
800068a8:	e0 6a 01 00 	mov	r10,256
800068ac:	30 0b       	mov	r11,0
800068ae:	fa cc fe f4 	sub	r12,sp,-268
800068b2:	f0 1f 00 4c 	mcall	800069e0 <logFromISR+0x140>
	
	
}
	
	
int logFromISR(char * content, ...)
800068b6:	fa c4 fd d0 	sub	r4,sp,-560
800068ba:	30 0a       	mov	r10,0
800068bc:	50 0a       	stdsp	sp[0x0],r10
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
800068be:	fa c3 ff fc 	sub	r3,sp,-4
800068c2:	e0 61 01 00 	mov	r1,256
800068c6:	14 90       	mov	r0,r10
			
			if(*str == '%')
800068c8:	32 52       	mov	r2,37
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
800068ca:	fa c6 fe f4 	sub	r6,sp,-268
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
800068ce:	02 9a       	mov	r10,r1
800068d0:	00 9b       	mov	r11,r0
800068d2:	06 9c       	mov	r12,r3
800068d4:	f0 1f 00 43 	mcall	800069e0 <logFromISR+0x140>
			
			if(*str == '%')
800068d8:	0f 88       	ld.ub	r8,r7[0x0]
800068da:	e4 08 18 00 	cp.b	r8,r2
800068de:	c5 11       	brne	80006980 <logFromISR+0xe0>
			{
				static char lench = 0;
				lench =*(str + 1);
800068e0:	ee c8 ff ff 	sub	r8,r7,-1
800068e4:	11 89       	ld.ub	r9,r8[0x0]
800068e6:	4c 0a       	lddpc	r10,800069e4 <logFromISR+0x144>
800068e8:	b4 89       	st.b	r10[0x0],r9
				if((lench >= '0') &&  (lench <= '9'))
800068ea:	23 09       	sub	r9,48
800068ec:	30 9a       	mov	r10,9
800068ee:	f4 09 18 00 	cp.b	r9,r10
800068f2:	ee 08 17 b0 	movhi	r8,r7
				{
					len = *(++str) - '0';
800068f6:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
800068fa:	f7 b9 08 30 	subls	r9,48
800068fe:	fb f9 8a 00 	st.wls	sp[0x0],r9
				}
				
				str++;
80006902:	f0 c7 ff ff 	sub	r7,r8,-1
				
				switch(*(str))
80006906:	0f 88       	ld.ub	r8,r7[0x0]
80006908:	22 58       	sub	r8,37
8000690a:	e0 48 00 53 	cp.w	r8,83
8000690e:	e0 8b 00 2b 	brhi	80006964 <logFromISR+0xc4>
80006912:	4b 69       	lddpc	r9,800069e8 <logFromISR+0x148>
80006914:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
				{
					case('d'):
					case('D'):
					x = va_arg(arg_ptr,int);
80006918:	e8 c5 ff fc 	sub	r5,r4,-4
					strTmp = PrintDec(x, len, strTmp);
8000691c:	06 9a       	mov	r10,r3
8000691e:	40 0b       	lddsp	r11,sp[0x0]
80006920:	5c 5b       	castu.b	r11
80006922:	68 0c       	ld.w	r12,r4[0x0]
80006924:	f0 1f 00 32 	mcall	800069ec <logFromISR+0x14c>
					break;
80006928:	c2 38       	rjmp	8000696e <logFromISR+0xce>
					case('x'):
					case('X'):
					x = va_arg(arg_ptr,int);
8000692a:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintHex(x,len, strTmp);
8000692e:	06 9a       	mov	r10,r3
80006930:	40 0b       	lddsp	r11,sp[0x0]
80006932:	5c 5b       	castu.b	r11
80006934:	68 0c       	ld.w	r12,r4[0x0]
80006936:	f0 1f 00 2f 	mcall	800069f0 <logFromISR+0x150>
8000693a:	06 9c       	mov	r12,r3
					break;
8000693c:	c1 98       	rjmp	8000696e <logFromISR+0xce>
					case('c'):
					case('C'):
					y = va_arg(arg_ptr,int);
8000693e:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintChar(y, strTmp);
80006942:	06 9b       	mov	r11,r3
80006944:	09 bc       	ld.ub	r12,r4[0x3]
80006946:	f0 1f 00 2c 	mcall	800069f4 <logFromISR+0x154>
8000694a:	06 9c       	mov	r12,r3
					break;
8000694c:	c1 18       	rjmp	8000696e <logFromISR+0xce>
					case('s'):
					case('S'):
					strTmp = va_arg(arg_ptr,char*);
8000694e:	e8 c5 ff fc 	sub	r5,r4,-4
80006952:	68 0c       	ld.w	r12,r4[0x0]
					//PrintStr(s);
					break;
80006954:	c0 d8       	rjmp	8000696e <logFromISR+0xce>
					case('%'):
					PrintChar('%', strTmp);
80006956:	06 9b       	mov	r11,r3
80006958:	32 5c       	mov	r12,37
8000695a:	f0 1f 00 27 	mcall	800069f4 <logFromISR+0x154>
8000695e:	08 95       	mov	r5,r4
80006960:	06 9c       	mov	r12,r3
					//PrintChar('%');
					break;
80006962:	c0 68       	rjmp	8000696e <logFromISR+0xce>
					default:
					log("I need relax.");
80006964:	4a 5c       	lddpc	r12,800069f8 <logFromISR+0x158>
80006966:	f0 1f 00 26 	mcall	800069fc <logFromISR+0x15c>
8000696a:	08 95       	mov	r5,r4
8000696c:	06 9c       	mov	r12,r3
				}
				str++;
8000696e:	2f f7       	sub	r7,-1
				
				length = sprintf(logTmp,"%s%s",logTmp,strTmp );
80006970:	1a dc       	st.w	--sp,r12
80006972:	1a d6       	st.w	--sp,r6
80006974:	4a 3b       	lddpc	r11,80006a00 <logFromISR+0x160>
80006976:	0c 9c       	mov	r12,r6
80006978:	f0 1f 00 23 	mcall	80006a04 <logFromISR+0x164>
8000697c:	2f ed       	sub	sp,-8
8000697e:	c0 a8       	rjmp	80006992 <logFromISR+0xf2>
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
80006980:	2f f7       	sub	r7,-1
80006982:	1a d8       	st.w	--sp,r8
80006984:	1a d6       	st.w	--sp,r6
80006986:	4a 1b       	lddpc	r11,80006a08 <logFromISR+0x168>
80006988:	0c 9c       	mov	r12,r6
8000698a:	f0 1f 00 1f 	mcall	80006a04 <logFromISR+0x164>
8000698e:	08 95       	mov	r5,r4
80006990:	2f ed       	sub	sp,-8
			
			
			
		}while(*str != '\0');
80006992:	0f 89       	ld.ub	r9,r7[0x0]
80006994:	30 08       	mov	r8,0
80006996:	f0 09 18 00 	cp.b	r9,r8
8000699a:	c0 30       	breq	800069a0 <logFromISR+0x100>
8000699c:	0a 94       	mov	r4,r5
8000699e:	c9 8b       	rjmp	800068ce <logFromISR+0x2e>
		
		
		
		va_end(arg_ptr);
		//while(1)
		length = sprintf(logTmp,"%s\r\n",logTmp);
800069a0:	fa c7 fe f4 	sub	r7,sp,-268
800069a4:	1a d7       	st.w	--sp,r7
800069a6:	49 ab       	lddpc	r11,80006a0c <logFromISR+0x16c>
800069a8:	0e 9c       	mov	r12,r7
800069aa:	f0 1f 00 17 	mcall	80006a04 <logFromISR+0x164>
		
		char * p = pvPortMalloc(length+1);
800069ae:	5c 5c       	castu.b	r12
800069b0:	f8 c6 ff ff 	sub	r6,r12,-1
800069b4:	0c 9c       	mov	r12,r6
800069b6:	f0 1f 00 17 	mcall	80006a10 <logFromISR+0x170>
800069ba:	54 3c       	stdsp	sp[0x10c],r12
		memcpy(p, logTmp, length+1);
800069bc:	0c 9a       	mov	r10,r6
800069be:	0e 9b       	mov	r11,r7
800069c0:	f0 1f 00 15 	mcall	80006a14 <logFromISR+0x174>
		//
		portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
800069c4:	30 09       	mov	r9,0
800069c6:	54 29       	stdsp	sp[0x108],r9
		
		//usart_write_line(EXAMPLE_USART, p);
		//vPortFree(p);
		xQueueSendFromISR( logQueue, &p, &xHigherPriorityTaskWoken );
800069c8:	fa ca fe f8 	sub	r10,sp,-264
800069cc:	fa cb fe f4 	sub	r11,sp,-268
800069d0:	49 28       	lddpc	r8,80006a18 <logFromISR+0x178>
800069d2:	70 0c       	ld.w	r12,r8[0x0]
800069d4:	f0 1f 00 12 	mcall	80006a1c <logFromISR+0x17c>
800069d8:	2f fd       	sub	sp,-4
		
		//if (xHigherPriorityTaskWoken == pdTRUE)
		//{
			////taskYIELD();
		//}
	}
800069da:	fe 3d fd f4 	sub	sp,-524
800069de:	d8 32       	popm	r0-r7,pc
800069e0:	80 00       	ld.sh	r0,r0[0x0]
800069e2:	70 fa       	ld.w	r10,r8[0x3c]
800069e4:	00 00       	add	r0,r0
800069e6:	0d 49       	ld.w	r9,--r6
800069e8:	80 00       	ld.sh	r0,r0[0x0]
800069ea:	d2 2c       	*unknown*
800069ec:	80 00       	ld.sh	r0,r0[0x0]
800069ee:	66 3a       	ld.w	r10,r3[0xc]
800069f0:	80 00       	ld.sh	r0,r0[0x0]
800069f2:	65 88       	ld.w	r8,r2[0x60]
800069f4:	80 00       	ld.sh	r0,r0[0x0]
800069f6:	65 84       	ld.w	r4,r2[0x60]
800069f8:	80 00       	ld.sh	r0,r0[0x0]
800069fa:	d3 98       	*unknown*
800069fc:	80 00       	ld.sh	r0,r0[0x0]
800069fe:	67 14       	ld.w	r4,r3[0x44]
80006a00:	80 00       	ld.sh	r0,r0[0x0]
80006a02:	d3 a8       	*unknown*
80006a04:	80 00       	ld.sh	r0,r0[0x0]
80006a06:	73 e8       	ld.w	r8,r9[0x78]
80006a08:	80 00       	ld.sh	r0,r0[0x0]
80006a0a:	d3 b0       	acall	0x3b
80006a0c:	80 00       	ld.sh	r0,r0[0x0]
80006a0e:	d3 b8       	*unknown*
80006a10:	80 00       	ld.sh	r0,r0[0x0]
80006a12:	58 28       	cp.w	r8,2
80006a14:	80 00       	ld.sh	r0,r0[0x0]
80006a16:	6f b2       	ld.w	r2,r7[0x6c]
80006a18:	00 00       	add	r0,r0
80006a1a:	63 98       	ld.w	r8,r1[0x64]
80006a1c:	80 00       	ld.sh	r0,r0[0x0]
80006a1e:	5b 2c       	cp.w	r12,-14

80006a20 <log_init>:
		
	return str;
}

void log_init(void)
{
80006a20:	d4 01       	pushm	lr
		.stopbits     = USART_1_STOPBIT,
		.channelmode  = USART_NORMAL_CHMODE
	};

	// Assign GPIO to USART.
	gpio_enable_module(USART_GPIO_MAP,
80006a22:	30 2b       	mov	r11,2
80006a24:	49 0c       	lddpc	r12,80006a64 <log_init+0x44>
80006a26:	f0 1f 00 11 	mcall	80006a68 <log_init+0x48>
	sizeof(USART_GPIO_MAP) / sizeof(USART_GPIO_MAP[0]));

	// Initialize USART in RS232 mode.
	usart_init_rs232(EXAMPLE_USART, &USART_OPTIONS, EXAMPLE_TARGET_PBACLK_FREQ_HZ);			
80006a2a:	e0 6a 36 00 	mov	r10,13824
80006a2e:	ea 1a 01 6e 	orh	r10,0x16e
80006a32:	48 fb       	lddpc	r11,80006a6c <log_init+0x4c>
80006a34:	fe 7c 18 00 	mov	r12,-59392
80006a38:	f0 1f 00 0e 	mcall	80006a70 <log_init+0x50>
			
	logQueue  = xQueueCreate(50, sizeof(char *));
80006a3c:	30 4b       	mov	r11,4
80006a3e:	33 2c       	mov	r12,50
80006a40:	f0 1f 00 0d 	mcall	80006a74 <log_init+0x54>
80006a44:	48 d8       	lddpc	r8,80006a78 <log_init+0x58>
80006a46:	91 0c       	st.w	r8[0x0],r12
	
	xTaskCreate(
80006a48:	30 09       	mov	r9,0
80006a4a:	1a d9       	st.w	--sp,r9
80006a4c:	1a d9       	st.w	--sp,r9
80006a4e:	1a d9       	st.w	--sp,r9
80006a50:	30 28       	mov	r8,2
80006a52:	e0 6a 01 80 	mov	r10,384
80006a56:	48 ab       	lddpc	r11,80006a7c <log_init+0x5c>
80006a58:	48 ac       	lddpc	r12,80006a80 <log_init+0x60>
80006a5a:	f0 1f 00 0b 	mcall	80006a84 <log_init+0x64>
80006a5e:	2f dd       	sub	sp,-12
	,  384
	,  NULL
	,  tskLOG_PRIORITY
	,  NULL );
	
}
80006a60:	d8 02       	popm	pc
80006a62:	00 00       	add	r0,r0
80006a64:	80 00       	ld.sh	r0,r0[0x0]
80006a66:	d3 c4       	*unknown*
80006a68:	80 00       	ld.sh	r0,r0[0x0]
80006a6a:	4e 74       	lddpc	r4,80006c04 <_malloc_r+0xb0>
80006a6c:	80 00       	ld.sh	r0,r0[0x0]
80006a6e:	d3 7c       	*unknown*
80006a70:	80 00       	ld.sh	r0,r0[0x0]
80006a72:	53 8c       	stdsp	sp[0xe0],r12
80006a74:	80 00       	ld.sh	r0,r0[0x0]
80006a76:	5c 7c       	castu.h	r12
80006a78:	00 00       	add	r0,r0
80006a7a:	63 98       	ld.w	r8,r1[0x64]
80006a7c:	80 00       	ld.sh	r0,r0[0x0]
80006a7e:	d3 c0       	acall	0x3c
80006a80:	80 00       	ld.sh	r0,r0[0x0]
80006a82:	6a 88       	ld.w	r8,r5[0x20]
80006a84:	80 00       	ld.sh	r0,r0[0x0]
80006a86:	63 50       	ld.w	r0,r1[0x54]

80006a88 <task_log>:
			////taskYIELD();
		//}
	}
	
static void task_log(void * pvParameters)
{
80006a88:	eb cd 40 f8 	pushm	r3-r7,lr
80006a8c:	20 1d       	sub	sp,4
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
80006a8e:	48 c7       	lddpc	r7,80006abc <task_log+0x34>
80006a90:	30 05       	mov	r5,0
80006a92:	3f f4       	mov	r4,-1
		{
			if( NULL != str)
			{
				usart_write_line(EXAMPLE_USART, str);
80006a94:	fe 73 18 00 	mov	r3,-59392
{
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
80006a98:	0a 99       	mov	r9,r5
80006a9a:	08 9a       	mov	r10,r4
80006a9c:	1a 9b       	mov	r11,sp
80006a9e:	6e 0c       	ld.w	r12,r7[0x0]
80006aa0:	f0 1f 00 08 	mcall	80006ac0 <task_log+0x38>
80006aa4:	58 1c       	cp.w	r12,1
80006aa6:	cf 91       	brne	80006a98 <task_log+0x10>
		{
			if( NULL != str)
80006aa8:	40 0b       	lddsp	r11,sp[0x0]
80006aaa:	58 0b       	cp.w	r11,0
80006aac:	cf 60       	breq	80006a98 <task_log+0x10>
			{
				usart_write_line(EXAMPLE_USART, str);
80006aae:	06 9c       	mov	r12,r3
80006ab0:	f0 1f 00 05 	mcall	80006ac4 <task_log+0x3c>
				vPortFree(str);
80006ab4:	40 0c       	lddsp	r12,sp[0x0]
80006ab6:	f0 1f 00 05 	mcall	80006ac8 <task_log+0x40>
80006aba:	ce fb       	rjmp	80006a98 <task_log+0x10>
80006abc:	00 00       	add	r0,r0
80006abe:	63 98       	ld.w	r8,r1[0x64]
80006ac0:	80 00       	ld.sh	r0,r0[0x0]
80006ac2:	59 70       	cp.w	r0,23
80006ac4:	80 00       	ld.sh	r0,r0[0x0]
80006ac6:	53 3c       	stdsp	sp[0xcc],r12
80006ac8:	80 00       	ld.sh	r0,r0[0x0]
80006aca:	58 00       	cp.w	r0,0

80006acc <main>:
#include "rtc.h"
#include "app.h"


int main (void)
{
80006acc:	d4 01       	pushm	lr
	
	//Force SSC_TX_DATA_ENABLE Disabled as soon as possible.
	AVR32_GPIO.port[1].ovrs  =  0x00000001;  //Value will be high.
80006ace:	fe 78 10 00 	mov	r8,-61440
80006ad2:	30 19       	mov	r9,1
80006ad4:	f1 49 01 54 	st.w	r8[340],r9
	AVR32_GPIO.port[1].oders =  0x00000001;  //Output Driver will be Enabled.
80006ad8:	f1 49 01 44 	st.w	r8[324],r9
	AVR32_GPIO.port[1].gpers =  0x00000001;  //Enable as GPIO.
80006adc:	f1 49 01 04 	st.w	r8[260],r9
		
	Disable_global_interrupt();
80006ae0:	d3 03       	ssrf	0x10
	local_start_pll0();
80006ae2:	f0 1f 00 0b 	mcall	80006b0c <main+0x40>
		
	INTC_init_interrupts();
80006ae6:	f0 1f 00 0b 	mcall	80006b10 <main+0x44>
		
	log_init();
80006aea:	f0 1f 00 0b 	mcall	80006b14 <main+0x48>
	log("----start debug----");
80006aee:	48 bc       	lddpc	r12,80006b18 <main+0x4c>
80006af0:	f0 1f 00 0b 	mcall	80006b1c <main+0x50>
		
	voc_init();
80006af4:	f0 1f 00 0b 	mcall	80006b20 <main+0x54>

	//tc_init();
	
	//rfid_init();
		
	app_init();
80006af8:	f0 1f 00 0b 	mcall	80006b24 <main+0x58>
		
	xcmp_init();
80006afc:	f0 1f 00 0b 	mcall	80006b28 <main+0x5c>
	
	//while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
	//while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
	local_start_timer();
80006b00:	f0 1f 00 0b 	mcall	80006b2c <main+0x60>
		
	//Enable_global_interrupt();
		
	vTaskStartScheduler();
80006b04:	f0 1f 00 0b 	mcall	80006b30 <main+0x64>
	return 0;
	
}
80006b08:	d8 0a       	popm	pc,r12=0
80006b0a:	00 00       	add	r0,r0
80006b0c:	80 00       	ld.sh	r0,r0[0x0]
80006b0e:	4b d4       	lddpc	r4,80006c00 <_malloc_r+0xac>
80006b10:	80 00       	ld.sh	r0,r0[0x0]
80006b12:	4f 5c       	lddpc	r12,80006ce4 <_malloc_r+0x190>
80006b14:	80 00       	ld.sh	r0,r0[0x0]
80006b16:	6a 20       	ld.w	r0,r5[0x8]
80006b18:	80 00       	ld.sh	r0,r0[0x0]
80006b1a:	d3 d4       	*unknown*
80006b1c:	80 00       	ld.sh	r0,r0[0x0]
80006b1e:	67 14       	ld.w	r4,r3[0x44]
80006b20:	80 00       	ld.sh	r0,r0[0x0]
80006b22:	4c 50       	lddpc	r0,80006c34 <_malloc_r+0xe0>
80006b24:	80 00       	ld.sh	r0,r0[0x0]
80006b26:	20 3c       	sub	r12,3
80006b28:	80 00       	ld.sh	r0,r0[0x0]
80006b2a:	44 58       	lddsp	r8,sp[0x114]
80006b2c:	80 00       	ld.sh	r0,r0[0x0]
80006b2e:	4c 24       	lddpc	r4,80006c34 <_malloc_r+0xe0>
80006b30:	80 00       	ld.sh	r0,r0[0x0]
80006b32:	65 38       	ld.w	r8,r2[0x4c]

80006b34 <free>:
80006b34:	d4 01       	pushm	lr
80006b36:	e0 68 0a 38 	mov	r8,2616
80006b3a:	18 9b       	mov	r11,r12
80006b3c:	70 0c       	ld.w	r12,r8[0x0]
80006b3e:	e0 a0 1e 73 	rcall	8000a824 <_free_r>
80006b42:	d8 02       	popm	pc

80006b44 <malloc>:
80006b44:	d4 01       	pushm	lr
80006b46:	e0 68 0a 38 	mov	r8,2616
80006b4a:	18 9b       	mov	r11,r12
80006b4c:	70 0c       	ld.w	r12,r8[0x0]
80006b4e:	c0 3c       	rcall	80006b54 <_malloc_r>
80006b50:	d8 02       	popm	pc
80006b52:	d7 03       	nop

80006b54 <_malloc_r>:
80006b54:	d4 31       	pushm	r0-r7,lr
80006b56:	f6 c8 ff f5 	sub	r8,r11,-11
80006b5a:	18 95       	mov	r5,r12
80006b5c:	10 97       	mov	r7,r8
80006b5e:	e0 17 ff f8 	andl	r7,0xfff8
80006b62:	59 68       	cp.w	r8,22
80006b64:	f9 b7 08 10 	movls	r7,16
80006b68:	16 37       	cp.w	r7,r11
80006b6a:	5f 38       	srlo	r8
80006b6c:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
80006b70:	c0 50       	breq	80006b7a <_malloc_r+0x26>
80006b72:	30 c8       	mov	r8,12
80006b74:	99 38       	st.w	r12[0xc],r8
80006b76:	e0 8f 01 fa 	bral	80006f6a <_malloc_r+0x416>
80006b7a:	fe b0 f5 f9 	rcall	8000576c <__malloc_lock>
80006b7e:	e0 47 01 f7 	cp.w	r7,503
80006b82:	e0 8b 00 1d 	brhi	80006bbc <_malloc_r+0x68>
80006b86:	ee 03 16 03 	lsr	r3,r7,0x3
80006b8a:	e0 68 05 38 	mov	r8,1336
80006b8e:	f0 03 00 38 	add	r8,r8,r3<<0x3
80006b92:	70 36       	ld.w	r6,r8[0xc]
80006b94:	10 36       	cp.w	r6,r8
80006b96:	c0 61       	brne	80006ba2 <_malloc_r+0x4e>
80006b98:	ec c8 ff f8 	sub	r8,r6,-8
80006b9c:	70 36       	ld.w	r6,r8[0xc]
80006b9e:	10 36       	cp.w	r6,r8
80006ba0:	c0 c0       	breq	80006bb8 <_malloc_r+0x64>
80006ba2:	6c 18       	ld.w	r8,r6[0x4]
80006ba4:	e0 18 ff fc 	andl	r8,0xfffc
80006ba8:	6c 3a       	ld.w	r10,r6[0xc]
80006baa:	ec 08 00 09 	add	r9,r6,r8
80006bae:	0a 9c       	mov	r12,r5
80006bb0:	6c 28       	ld.w	r8,r6[0x8]
80006bb2:	95 28       	st.w	r10[0x8],r8
80006bb4:	91 3a       	st.w	r8[0xc],r10
80006bb6:	c4 78       	rjmp	80006c44 <_malloc_r+0xf0>
80006bb8:	2f e3       	sub	r3,-2
80006bba:	c4 d8       	rjmp	80006c54 <_malloc_r+0x100>
80006bbc:	ee 03 16 09 	lsr	r3,r7,0x9
80006bc0:	c0 41       	brne	80006bc8 <_malloc_r+0x74>
80006bc2:	ee 03 16 03 	lsr	r3,r7,0x3
80006bc6:	c2 68       	rjmp	80006c12 <_malloc_r+0xbe>
80006bc8:	58 43       	cp.w	r3,4
80006bca:	e0 8b 00 06 	brhi	80006bd6 <_malloc_r+0x82>
80006bce:	ee 03 16 06 	lsr	r3,r7,0x6
80006bd2:	2c 83       	sub	r3,-56
80006bd4:	c1 f8       	rjmp	80006c12 <_malloc_r+0xbe>
80006bd6:	59 43       	cp.w	r3,20
80006bd8:	e0 8b 00 04 	brhi	80006be0 <_malloc_r+0x8c>
80006bdc:	2a 53       	sub	r3,-91
80006bde:	c1 a8       	rjmp	80006c12 <_malloc_r+0xbe>
80006be0:	e0 43 00 54 	cp.w	r3,84
80006be4:	e0 8b 00 06 	brhi	80006bf0 <_malloc_r+0x9c>
80006be8:	ee 03 16 0c 	lsr	r3,r7,0xc
80006bec:	29 23       	sub	r3,-110
80006bee:	c1 28       	rjmp	80006c12 <_malloc_r+0xbe>
80006bf0:	e0 43 01 54 	cp.w	r3,340
80006bf4:	e0 8b 00 06 	brhi	80006c00 <_malloc_r+0xac>
80006bf8:	ee 03 16 0f 	lsr	r3,r7,0xf
80006bfc:	28 93       	sub	r3,-119
80006bfe:	c0 a8       	rjmp	80006c12 <_malloc_r+0xbe>
80006c00:	e0 43 05 54 	cp.w	r3,1364
80006c04:	e0 88 00 04 	brls	80006c0c <_malloc_r+0xb8>
80006c08:	37 e3       	mov	r3,126
80006c0a:	c0 48       	rjmp	80006c12 <_malloc_r+0xbe>
80006c0c:	ee 03 16 12 	lsr	r3,r7,0x12
80006c10:	28 43       	sub	r3,-124
80006c12:	e0 6a 05 38 	mov	r10,1336
80006c16:	f4 03 00 3a 	add	r10,r10,r3<<0x3
80006c1a:	74 36       	ld.w	r6,r10[0xc]
80006c1c:	c1 98       	rjmp	80006c4e <_malloc_r+0xfa>
80006c1e:	6c 19       	ld.w	r9,r6[0x4]
80006c20:	e0 19 ff fc 	andl	r9,0xfffc
80006c24:	f2 07 01 0b 	sub	r11,r9,r7
80006c28:	58 fb       	cp.w	r11,15
80006c2a:	e0 8a 00 04 	brle	80006c32 <_malloc_r+0xde>
80006c2e:	20 13       	sub	r3,1
80006c30:	c1 18       	rjmp	80006c52 <_malloc_r+0xfe>
80006c32:	6c 38       	ld.w	r8,r6[0xc]
80006c34:	58 0b       	cp.w	r11,0
80006c36:	c0 b5       	brlt	80006c4c <_malloc_r+0xf8>
80006c38:	6c 2a       	ld.w	r10,r6[0x8]
80006c3a:	ec 09 00 09 	add	r9,r6,r9
80006c3e:	0a 9c       	mov	r12,r5
80006c40:	91 2a       	st.w	r8[0x8],r10
80006c42:	95 38       	st.w	r10[0xc],r8
80006c44:	72 18       	ld.w	r8,r9[0x4]
80006c46:	a1 a8       	sbr	r8,0x0
80006c48:	93 18       	st.w	r9[0x4],r8
80006c4a:	cb c8       	rjmp	80006dc2 <_malloc_r+0x26e>
80006c4c:	10 96       	mov	r6,r8
80006c4e:	14 36       	cp.w	r6,r10
80006c50:	ce 71       	brne	80006c1e <_malloc_r+0xca>
80006c52:	2f f3       	sub	r3,-1
80006c54:	e0 6a 05 38 	mov	r10,1336
80006c58:	f4 cc ff f8 	sub	r12,r10,-8
80006c5c:	78 26       	ld.w	r6,r12[0x8]
80006c5e:	18 36       	cp.w	r6,r12
80006c60:	c6 c0       	breq	80006d38 <_malloc_r+0x1e4>
80006c62:	6c 19       	ld.w	r9,r6[0x4]
80006c64:	e0 19 ff fc 	andl	r9,0xfffc
80006c68:	f2 07 01 08 	sub	r8,r9,r7
80006c6c:	58 f8       	cp.w	r8,15
80006c6e:	e0 89 00 8f 	brgt	80006d8c <_malloc_r+0x238>
80006c72:	99 3c       	st.w	r12[0xc],r12
80006c74:	99 2c       	st.w	r12[0x8],r12
80006c76:	58 08       	cp.w	r8,0
80006c78:	c0 55       	brlt	80006c82 <_malloc_r+0x12e>
80006c7a:	ec 09 00 09 	add	r9,r6,r9
80006c7e:	0a 9c       	mov	r12,r5
80006c80:	ce 2b       	rjmp	80006c44 <_malloc_r+0xf0>
80006c82:	e0 49 01 ff 	cp.w	r9,511
80006c86:	e0 8b 00 13 	brhi	80006cac <_malloc_r+0x158>
80006c8a:	a3 99       	lsr	r9,0x3
80006c8c:	f4 09 00 38 	add	r8,r10,r9<<0x3
80006c90:	70 2b       	ld.w	r11,r8[0x8]
80006c92:	8d 38       	st.w	r6[0xc],r8
80006c94:	8d 2b       	st.w	r6[0x8],r11
80006c96:	97 36       	st.w	r11[0xc],r6
80006c98:	91 26       	st.w	r8[0x8],r6
80006c9a:	a3 49       	asr	r9,0x2
80006c9c:	74 18       	ld.w	r8,r10[0x4]
80006c9e:	30 1b       	mov	r11,1
80006ca0:	f6 09 09 49 	lsl	r9,r11,r9
80006ca4:	f1 e9 10 09 	or	r9,r8,r9
80006ca8:	95 19       	st.w	r10[0x4],r9
80006caa:	c4 78       	rjmp	80006d38 <_malloc_r+0x1e4>
80006cac:	f2 0a 16 09 	lsr	r10,r9,0x9
80006cb0:	58 4a       	cp.w	r10,4
80006cb2:	e0 8b 00 07 	brhi	80006cc0 <_malloc_r+0x16c>
80006cb6:	f2 0a 16 06 	lsr	r10,r9,0x6
80006cba:	2c 8a       	sub	r10,-56
80006cbc:	c2 08       	rjmp	80006cfc <_malloc_r+0x1a8>
80006cbe:	d7 03       	nop
80006cc0:	59 4a       	cp.w	r10,20
80006cc2:	e0 8b 00 04 	brhi	80006cca <_malloc_r+0x176>
80006cc6:	2a 5a       	sub	r10,-91
80006cc8:	c1 a8       	rjmp	80006cfc <_malloc_r+0x1a8>
80006cca:	e0 4a 00 54 	cp.w	r10,84
80006cce:	e0 8b 00 06 	brhi	80006cda <_malloc_r+0x186>
80006cd2:	f2 0a 16 0c 	lsr	r10,r9,0xc
80006cd6:	29 2a       	sub	r10,-110
80006cd8:	c1 28       	rjmp	80006cfc <_malloc_r+0x1a8>
80006cda:	e0 4a 01 54 	cp.w	r10,340
80006cde:	e0 8b 00 06 	brhi	80006cea <_malloc_r+0x196>
80006ce2:	f2 0a 16 0f 	lsr	r10,r9,0xf
80006ce6:	28 9a       	sub	r10,-119
80006ce8:	c0 a8       	rjmp	80006cfc <_malloc_r+0x1a8>
80006cea:	e0 4a 05 54 	cp.w	r10,1364
80006cee:	e0 88 00 04 	brls	80006cf6 <_malloc_r+0x1a2>
80006cf2:	37 ea       	mov	r10,126
80006cf4:	c0 48       	rjmp	80006cfc <_malloc_r+0x1a8>
80006cf6:	f2 0a 16 12 	lsr	r10,r9,0x12
80006cfa:	28 4a       	sub	r10,-124
80006cfc:	e0 6b 05 38 	mov	r11,1336
80006d00:	f6 0a 00 34 	add	r4,r11,r10<<0x3
80006d04:	68 28       	ld.w	r8,r4[0x8]
80006d06:	08 38       	cp.w	r8,r4
80006d08:	c0 e1       	brne	80006d24 <_malloc_r+0x1d0>
80006d0a:	76 19       	ld.w	r9,r11[0x4]
80006d0c:	a3 4a       	asr	r10,0x2
80006d0e:	30 1e       	mov	lr,1
80006d10:	fc 0a 09 4a 	lsl	r10,lr,r10
80006d14:	f3 ea 10 0a 	or	r10,r9,r10
80006d18:	10 99       	mov	r9,r8
80006d1a:	97 1a       	st.w	r11[0x4],r10
80006d1c:	c0 a8       	rjmp	80006d30 <_malloc_r+0x1dc>
80006d1e:	70 28       	ld.w	r8,r8[0x8]
80006d20:	08 38       	cp.w	r8,r4
80006d22:	c0 60       	breq	80006d2e <_malloc_r+0x1da>
80006d24:	70 1a       	ld.w	r10,r8[0x4]
80006d26:	e0 1a ff fc 	andl	r10,0xfffc
80006d2a:	14 39       	cp.w	r9,r10
80006d2c:	cf 93       	brcs	80006d1e <_malloc_r+0x1ca>
80006d2e:	70 39       	ld.w	r9,r8[0xc]
80006d30:	8d 39       	st.w	r6[0xc],r9
80006d32:	8d 28       	st.w	r6[0x8],r8
80006d34:	91 36       	st.w	r8[0xc],r6
80006d36:	93 26       	st.w	r9[0x8],r6
80006d38:	e6 08 14 02 	asr	r8,r3,0x2
80006d3c:	30 1b       	mov	r11,1
80006d3e:	e0 64 05 38 	mov	r4,1336
80006d42:	f6 08 09 4b 	lsl	r11,r11,r8
80006d46:	68 18       	ld.w	r8,r4[0x4]
80006d48:	10 3b       	cp.w	r11,r8
80006d4a:	e0 8b 00 6b 	brhi	80006e20 <_malloc_r+0x2cc>
80006d4e:	f7 e8 00 09 	and	r9,r11,r8
80006d52:	c0 b1       	brne	80006d68 <_malloc_r+0x214>
80006d54:	e0 13 ff fc 	andl	r3,0xfffc
80006d58:	a1 7b       	lsl	r11,0x1
80006d5a:	2f c3       	sub	r3,-4
80006d5c:	c0 38       	rjmp	80006d62 <_malloc_r+0x20e>
80006d5e:	2f c3       	sub	r3,-4
80006d60:	a1 7b       	lsl	r11,0x1
80006d62:	f7 e8 00 09 	and	r9,r11,r8
80006d66:	cf c0       	breq	80006d5e <_malloc_r+0x20a>
80006d68:	e8 03 00 3e 	add	lr,r4,r3<<0x3
80006d6c:	06 92       	mov	r2,r3
80006d6e:	1c 91       	mov	r1,lr
80006d70:	62 36       	ld.w	r6,r1[0xc]
80006d72:	c2 e8       	rjmp	80006dce <_malloc_r+0x27a>
80006d74:	6c 1a       	ld.w	r10,r6[0x4]
80006d76:	e0 1a ff fc 	andl	r10,0xfffc
80006d7a:	f4 07 01 08 	sub	r8,r10,r7
80006d7e:	58 f8       	cp.w	r8,15
80006d80:	e0 8a 00 15 	brle	80006daa <_malloc_r+0x256>
80006d84:	6c 3a       	ld.w	r10,r6[0xc]
80006d86:	6c 29       	ld.w	r9,r6[0x8]
80006d88:	95 29       	st.w	r10[0x8],r9
80006d8a:	93 3a       	st.w	r9[0xc],r10
80006d8c:	0e 99       	mov	r9,r7
80006d8e:	ec 07 00 07 	add	r7,r6,r7
80006d92:	a1 a9       	sbr	r9,0x0
80006d94:	99 37       	st.w	r12[0xc],r7
80006d96:	99 27       	st.w	r12[0x8],r7
80006d98:	8d 19       	st.w	r6[0x4],r9
80006d9a:	ee 08 09 08 	st.w	r7[r8],r8
80006d9e:	8f 2c       	st.w	r7[0x8],r12
80006da0:	8f 3c       	st.w	r7[0xc],r12
80006da2:	a1 a8       	sbr	r8,0x0
80006da4:	0a 9c       	mov	r12,r5
80006da6:	8f 18       	st.w	r7[0x4],r8
80006da8:	c0 d8       	rjmp	80006dc2 <_malloc_r+0x26e>
80006daa:	6c 39       	ld.w	r9,r6[0xc]
80006dac:	58 08       	cp.w	r8,0
80006dae:	c0 f5       	brlt	80006dcc <_malloc_r+0x278>
80006db0:	ec 0a 00 0a 	add	r10,r6,r10
80006db4:	74 18       	ld.w	r8,r10[0x4]
80006db6:	a1 a8       	sbr	r8,0x0
80006db8:	0a 9c       	mov	r12,r5
80006dba:	95 18       	st.w	r10[0x4],r8
80006dbc:	6c 28       	ld.w	r8,r6[0x8]
80006dbe:	93 28       	st.w	r9[0x8],r8
80006dc0:	91 39       	st.w	r8[0xc],r9
80006dc2:	fe b0 f4 db 	rcall	80005778 <__malloc_unlock>
80006dc6:	ec cc ff f8 	sub	r12,r6,-8
80006dca:	d8 32       	popm	r0-r7,pc
80006dcc:	12 96       	mov	r6,r9
80006dce:	02 36       	cp.w	r6,r1
80006dd0:	cd 21       	brne	80006d74 <_malloc_r+0x220>
80006dd2:	2f f2       	sub	r2,-1
80006dd4:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
80006dd8:	c0 30       	breq	80006dde <_malloc_r+0x28a>
80006dda:	2f 81       	sub	r1,-8
80006ddc:	cc ab       	rjmp	80006d70 <_malloc_r+0x21c>
80006dde:	1c 98       	mov	r8,lr
80006de0:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
80006de4:	c0 81       	brne	80006df4 <_malloc_r+0x2a0>
80006de6:	68 19       	ld.w	r9,r4[0x4]
80006de8:	f6 08 11 ff 	rsub	r8,r11,-1
80006dec:	f3 e8 00 08 	and	r8,r9,r8
80006df0:	89 18       	st.w	r4[0x4],r8
80006df2:	c0 78       	rjmp	80006e00 <_malloc_r+0x2ac>
80006df4:	f0 c9 00 08 	sub	r9,r8,8
80006df8:	20 13       	sub	r3,1
80006dfa:	70 08       	ld.w	r8,r8[0x0]
80006dfc:	12 38       	cp.w	r8,r9
80006dfe:	cf 10       	breq	80006de0 <_malloc_r+0x28c>
80006e00:	a1 7b       	lsl	r11,0x1
80006e02:	68 18       	ld.w	r8,r4[0x4]
80006e04:	10 3b       	cp.w	r11,r8
80006e06:	e0 8b 00 0d 	brhi	80006e20 <_malloc_r+0x2cc>
80006e0a:	58 0b       	cp.w	r11,0
80006e0c:	c0 a0       	breq	80006e20 <_malloc_r+0x2cc>
80006e0e:	04 93       	mov	r3,r2
80006e10:	c0 38       	rjmp	80006e16 <_malloc_r+0x2c2>
80006e12:	2f c3       	sub	r3,-4
80006e14:	a1 7b       	lsl	r11,0x1
80006e16:	f7 e8 00 09 	and	r9,r11,r8
80006e1a:	ca 71       	brne	80006d68 <_malloc_r+0x214>
80006e1c:	cf bb       	rjmp	80006e12 <_malloc_r+0x2be>
80006e1e:	d7 03       	nop
80006e20:	68 23       	ld.w	r3,r4[0x8]
80006e22:	66 12       	ld.w	r2,r3[0x4]
80006e24:	e0 12 ff fc 	andl	r2,0xfffc
80006e28:	0e 32       	cp.w	r2,r7
80006e2a:	5f 39       	srlo	r9
80006e2c:	e4 07 01 08 	sub	r8,r2,r7
80006e30:	58 f8       	cp.w	r8,15
80006e32:	5f aa       	srle	r10
80006e34:	f5 e9 10 09 	or	r9,r10,r9
80006e38:	e0 80 00 9a 	breq	80006f6c <_malloc_r+0x418>
80006e3c:	e0 68 0d 54 	mov	r8,3412
80006e40:	70 01       	ld.w	r1,r8[0x0]
80006e42:	e0 68 09 44 	mov	r8,2372
80006e46:	2f 01       	sub	r1,-16
80006e48:	70 08       	ld.w	r8,r8[0x0]
80006e4a:	0e 01       	add	r1,r7
80006e4c:	5b f8       	cp.w	r8,-1
80006e4e:	c0 40       	breq	80006e56 <_malloc_r+0x302>
80006e50:	28 11       	sub	r1,-127
80006e52:	e0 11 ff 80 	andl	r1,0xff80
80006e56:	02 9b       	mov	r11,r1
80006e58:	0a 9c       	mov	r12,r5
80006e5a:	e0 a0 02 b7 	rcall	800073c8 <_sbrk_r>
80006e5e:	18 96       	mov	r6,r12
80006e60:	5b fc       	cp.w	r12,-1
80006e62:	c7 50       	breq	80006f4c <_malloc_r+0x3f8>
80006e64:	e6 02 00 08 	add	r8,r3,r2
80006e68:	10 3c       	cp.w	r12,r8
80006e6a:	c0 32       	brcc	80006e70 <_malloc_r+0x31c>
80006e6c:	08 33       	cp.w	r3,r4
80006e6e:	c6 f1       	brne	80006f4c <_malloc_r+0x3f8>
80006e70:	e0 6a 0d 58 	mov	r10,3416
80006e74:	74 09       	ld.w	r9,r10[0x0]
80006e76:	e2 09 00 09 	add	r9,r1,r9
80006e7a:	95 09       	st.w	r10[0x0],r9
80006e7c:	10 36       	cp.w	r6,r8
80006e7e:	c0 a1       	brne	80006e92 <_malloc_r+0x33e>
80006e80:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
80006e84:	c0 71       	brne	80006e92 <_malloc_r+0x33e>
80006e86:	e2 02 00 02 	add	r2,r1,r2
80006e8a:	68 28       	ld.w	r8,r4[0x8]
80006e8c:	a1 a2       	sbr	r2,0x0
80006e8e:	91 12       	st.w	r8[0x4],r2
80006e90:	c4 f8       	rjmp	80006f2e <_malloc_r+0x3da>
80006e92:	e0 6a 09 44 	mov	r10,2372
80006e96:	74 0b       	ld.w	r11,r10[0x0]
80006e98:	5b fb       	cp.w	r11,-1
80006e9a:	c0 31       	brne	80006ea0 <_malloc_r+0x34c>
80006e9c:	95 06       	st.w	r10[0x0],r6
80006e9e:	c0 78       	rjmp	80006eac <_malloc_r+0x358>
80006ea0:	ec 09 00 09 	add	r9,r6,r9
80006ea4:	e0 6a 0d 58 	mov	r10,3416
80006ea8:	10 19       	sub	r9,r8
80006eaa:	95 09       	st.w	r10[0x0],r9
80006eac:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
80006eb0:	f0 09 11 08 	rsub	r9,r8,8
80006eb4:	58 08       	cp.w	r8,0
80006eb6:	f2 08 17 10 	movne	r8,r9
80006eba:	ed d8 e1 06 	addne	r6,r6,r8
80006ebe:	28 08       	sub	r8,-128
80006ec0:	ec 01 00 01 	add	r1,r6,r1
80006ec4:	0a 9c       	mov	r12,r5
80006ec6:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
80006eca:	f0 01 01 01 	sub	r1,r8,r1
80006ece:	02 9b       	mov	r11,r1
80006ed0:	e0 a0 02 7c 	rcall	800073c8 <_sbrk_r>
80006ed4:	e0 68 0d 58 	mov	r8,3416
80006ed8:	5b fc       	cp.w	r12,-1
80006eda:	ec 0c 17 00 	moveq	r12,r6
80006ede:	f9 b1 00 00 	moveq	r1,0
80006ee2:	70 09       	ld.w	r9,r8[0x0]
80006ee4:	0c 1c       	sub	r12,r6
80006ee6:	89 26       	st.w	r4[0x8],r6
80006ee8:	02 0c       	add	r12,r1
80006eea:	12 01       	add	r1,r9
80006eec:	a1 ac       	sbr	r12,0x0
80006eee:	91 01       	st.w	r8[0x0],r1
80006ef0:	8d 1c       	st.w	r6[0x4],r12
80006ef2:	08 33       	cp.w	r3,r4
80006ef4:	c1 d0       	breq	80006f2e <_malloc_r+0x3da>
80006ef6:	58 f2       	cp.w	r2,15
80006ef8:	e0 8b 00 05 	brhi	80006f02 <_malloc_r+0x3ae>
80006efc:	30 18       	mov	r8,1
80006efe:	8d 18       	st.w	r6[0x4],r8
80006f00:	c2 68       	rjmp	80006f4c <_malloc_r+0x3f8>
80006f02:	30 59       	mov	r9,5
80006f04:	20 c2       	sub	r2,12
80006f06:	e0 12 ff f8 	andl	r2,0xfff8
80006f0a:	e6 02 00 08 	add	r8,r3,r2
80006f0e:	91 29       	st.w	r8[0x8],r9
80006f10:	91 19       	st.w	r8[0x4],r9
80006f12:	66 18       	ld.w	r8,r3[0x4]
80006f14:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80006f18:	e5 e8 10 08 	or	r8,r2,r8
80006f1c:	87 18       	st.w	r3[0x4],r8
80006f1e:	58 f2       	cp.w	r2,15
80006f20:	e0 88 00 07 	brls	80006f2e <_malloc_r+0x3da>
80006f24:	e6 cb ff f8 	sub	r11,r3,-8
80006f28:	0a 9c       	mov	r12,r5
80006f2a:	e0 a0 1c 7d 	rcall	8000a824 <_free_r>
80006f2e:	e0 69 0d 50 	mov	r9,3408
80006f32:	72 0a       	ld.w	r10,r9[0x0]
80006f34:	e0 68 0d 58 	mov	r8,3416
80006f38:	70 08       	ld.w	r8,r8[0x0]
80006f3a:	14 38       	cp.w	r8,r10
80006f3c:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80006f40:	e0 69 0d 4c 	mov	r9,3404
80006f44:	72 0a       	ld.w	r10,r9[0x0]
80006f46:	14 38       	cp.w	r8,r10
80006f48:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80006f4c:	68 28       	ld.w	r8,r4[0x8]
80006f4e:	70 18       	ld.w	r8,r8[0x4]
80006f50:	e0 18 ff fc 	andl	r8,0xfffc
80006f54:	0e 38       	cp.w	r8,r7
80006f56:	5f 39       	srlo	r9
80006f58:	0e 18       	sub	r8,r7
80006f5a:	58 f8       	cp.w	r8,15
80006f5c:	5f aa       	srle	r10
80006f5e:	f5 e9 10 09 	or	r9,r10,r9
80006f62:	c0 50       	breq	80006f6c <_malloc_r+0x418>
80006f64:	0a 9c       	mov	r12,r5
80006f66:	fe b0 f4 09 	rcall	80005778 <__malloc_unlock>
80006f6a:	d8 3a       	popm	r0-r7,pc,r12=0
80006f6c:	68 26       	ld.w	r6,r4[0x8]
80006f6e:	a1 a8       	sbr	r8,0x0
80006f70:	0e 99       	mov	r9,r7
80006f72:	a1 a9       	sbr	r9,0x0
80006f74:	8d 19       	st.w	r6[0x4],r9
80006f76:	ec 07 00 07 	add	r7,r6,r7
80006f7a:	0a 9c       	mov	r12,r5
80006f7c:	89 27       	st.w	r4[0x8],r7
80006f7e:	8f 18       	st.w	r7[0x4],r8
80006f80:	fe b0 f3 fc 	rcall	80005778 <__malloc_unlock>
80006f84:	ec cc ff f8 	sub	r12,r6,-8
80006f88:	d8 32       	popm	r0-r7,pc
80006f8a:	d7 03       	nop

80006f8c <memcmp>:
80006f8c:	d4 01       	pushm	lr
80006f8e:	30 08       	mov	r8,0
80006f90:	c0 d8       	rjmp	80006faa <memcmp+0x1e>
80006f92:	f8 08 07 0e 	ld.ub	lr,r12[r8]
80006f96:	f6 08 07 09 	ld.ub	r9,r11[r8]
80006f9a:	20 1a       	sub	r10,1
80006f9c:	2f f8       	sub	r8,-1
80006f9e:	f2 0e 18 00 	cp.b	lr,r9
80006fa2:	c0 40       	breq	80006faa <memcmp+0x1e>
80006fa4:	fc 09 01 0c 	sub	r12,lr,r9
80006fa8:	d8 02       	popm	pc
80006faa:	58 0a       	cp.w	r10,0
80006fac:	cf 31       	brne	80006f92 <memcmp+0x6>
80006fae:	14 9c       	mov	r12,r10
80006fb0:	d8 02       	popm	pc

80006fb2 <memcpy>:
80006fb2:	58 8a       	cp.w	r10,8
80006fb4:	c2 f5       	brlt	80007012 <memcpy+0x60>
80006fb6:	f9 eb 10 09 	or	r9,r12,r11
80006fba:	e2 19 00 03 	andl	r9,0x3,COH
80006fbe:	e0 81 00 97 	brne	800070ec <memcpy+0x13a>
80006fc2:	e0 4a 00 20 	cp.w	r10,32
80006fc6:	c3 b4       	brge	8000703c <memcpy+0x8a>
80006fc8:	f4 08 14 02 	asr	r8,r10,0x2
80006fcc:	f0 09 11 08 	rsub	r9,r8,8
80006fd0:	fe 09 00 2f 	add	pc,pc,r9<<0x2
80006fd4:	76 69       	ld.w	r9,r11[0x18]
80006fd6:	99 69       	st.w	r12[0x18],r9
80006fd8:	76 59       	ld.w	r9,r11[0x14]
80006fda:	99 59       	st.w	r12[0x14],r9
80006fdc:	76 49       	ld.w	r9,r11[0x10]
80006fde:	99 49       	st.w	r12[0x10],r9
80006fe0:	76 39       	ld.w	r9,r11[0xc]
80006fe2:	99 39       	st.w	r12[0xc],r9
80006fe4:	76 29       	ld.w	r9,r11[0x8]
80006fe6:	99 29       	st.w	r12[0x8],r9
80006fe8:	76 19       	ld.w	r9,r11[0x4]
80006fea:	99 19       	st.w	r12[0x4],r9
80006fec:	76 09       	ld.w	r9,r11[0x0]
80006fee:	99 09       	st.w	r12[0x0],r9
80006ff0:	f6 08 00 2b 	add	r11,r11,r8<<0x2
80006ff4:	f8 08 00 28 	add	r8,r12,r8<<0x2
80006ff8:	e0 1a 00 03 	andl	r10,0x3
80006ffc:	f4 0a 11 04 	rsub	r10,r10,4
80007000:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
80007004:	17 a9       	ld.ub	r9,r11[0x2]
80007006:	b0 a9       	st.b	r8[0x2],r9
80007008:	17 99       	ld.ub	r9,r11[0x1]
8000700a:	b0 99       	st.b	r8[0x1],r9
8000700c:	17 89       	ld.ub	r9,r11[0x0]
8000700e:	b0 89       	st.b	r8[0x0],r9
80007010:	5e fc       	retal	r12
80007012:	f4 0a 11 09 	rsub	r10,r10,9
80007016:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
8000701a:	17 f9       	ld.ub	r9,r11[0x7]
8000701c:	b8 f9       	st.b	r12[0x7],r9
8000701e:	17 e9       	ld.ub	r9,r11[0x6]
80007020:	b8 e9       	st.b	r12[0x6],r9
80007022:	17 d9       	ld.ub	r9,r11[0x5]
80007024:	b8 d9       	st.b	r12[0x5],r9
80007026:	17 c9       	ld.ub	r9,r11[0x4]
80007028:	b8 c9       	st.b	r12[0x4],r9
8000702a:	17 b9       	ld.ub	r9,r11[0x3]
8000702c:	b8 b9       	st.b	r12[0x3],r9
8000702e:	17 a9       	ld.ub	r9,r11[0x2]
80007030:	b8 a9       	st.b	r12[0x2],r9
80007032:	17 99       	ld.ub	r9,r11[0x1]
80007034:	b8 99       	st.b	r12[0x1],r9
80007036:	17 89       	ld.ub	r9,r11[0x0]
80007038:	b8 89       	st.b	r12[0x0],r9
8000703a:	5e fc       	retal	r12
8000703c:	eb cd 40 c0 	pushm	r6-r7,lr
80007040:	18 99       	mov	r9,r12
80007042:	22 0a       	sub	r10,32
80007044:	b7 07       	ld.d	r6,r11++
80007046:	b3 26       	st.d	r9++,r6
80007048:	b7 07       	ld.d	r6,r11++
8000704a:	b3 26       	st.d	r9++,r6
8000704c:	b7 07       	ld.d	r6,r11++
8000704e:	b3 26       	st.d	r9++,r6
80007050:	b7 07       	ld.d	r6,r11++
80007052:	b3 26       	st.d	r9++,r6
80007054:	22 0a       	sub	r10,32
80007056:	cf 74       	brge	80007044 <memcpy+0x92>
80007058:	2f 0a       	sub	r10,-16
8000705a:	c0 65       	brlt	80007066 <memcpy+0xb4>
8000705c:	b7 07       	ld.d	r6,r11++
8000705e:	b3 26       	st.d	r9++,r6
80007060:	b7 07       	ld.d	r6,r11++
80007062:	b3 26       	st.d	r9++,r6
80007064:	21 0a       	sub	r10,16
80007066:	5c 3a       	neg	r10
80007068:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
8000706c:	d7 03       	nop
8000706e:	d7 03       	nop
80007070:	f7 36 00 0e 	ld.ub	r6,r11[14]
80007074:	f3 66 00 0e 	st.b	r9[14],r6
80007078:	f7 36 00 0d 	ld.ub	r6,r11[13]
8000707c:	f3 66 00 0d 	st.b	r9[13],r6
80007080:	f7 36 00 0c 	ld.ub	r6,r11[12]
80007084:	f3 66 00 0c 	st.b	r9[12],r6
80007088:	f7 36 00 0b 	ld.ub	r6,r11[11]
8000708c:	f3 66 00 0b 	st.b	r9[11],r6
80007090:	f7 36 00 0a 	ld.ub	r6,r11[10]
80007094:	f3 66 00 0a 	st.b	r9[10],r6
80007098:	f7 36 00 09 	ld.ub	r6,r11[9]
8000709c:	f3 66 00 09 	st.b	r9[9],r6
800070a0:	f7 36 00 08 	ld.ub	r6,r11[8]
800070a4:	f3 66 00 08 	st.b	r9[8],r6
800070a8:	f7 36 00 07 	ld.ub	r6,r11[7]
800070ac:	f3 66 00 07 	st.b	r9[7],r6
800070b0:	f7 36 00 06 	ld.ub	r6,r11[6]
800070b4:	f3 66 00 06 	st.b	r9[6],r6
800070b8:	f7 36 00 05 	ld.ub	r6,r11[5]
800070bc:	f3 66 00 05 	st.b	r9[5],r6
800070c0:	f7 36 00 04 	ld.ub	r6,r11[4]
800070c4:	f3 66 00 04 	st.b	r9[4],r6
800070c8:	f7 36 00 03 	ld.ub	r6,r11[3]
800070cc:	f3 66 00 03 	st.b	r9[3],r6
800070d0:	f7 36 00 02 	ld.ub	r6,r11[2]
800070d4:	f3 66 00 02 	st.b	r9[2],r6
800070d8:	f7 36 00 01 	ld.ub	r6,r11[1]
800070dc:	f3 66 00 01 	st.b	r9[1],r6
800070e0:	f7 36 00 00 	ld.ub	r6,r11[0]
800070e4:	f3 66 00 00 	st.b	r9[0],r6
800070e8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800070ec:	20 1a       	sub	r10,1
800070ee:	f6 0a 07 09 	ld.ub	r9,r11[r10]
800070f2:	f8 0a 0b 09 	st.b	r12[r10],r9
800070f6:	cf b1       	brne	800070ec <memcpy+0x13a>
800070f8:	5e fc       	retal	r12

800070fa <memset>:
800070fa:	18 98       	mov	r8,r12
800070fc:	c0 38       	rjmp	80007102 <memset+0x8>
800070fe:	10 cb       	st.b	r8++,r11
80007100:	20 1a       	sub	r10,1
80007102:	58 0a       	cp.w	r10,0
80007104:	cf d1       	brne	800070fe <memset+0x4>
80007106:	5e fc       	retal	r12

80007108 <_realloc_r>:
80007108:	d4 31       	pushm	r0-r7,lr
8000710a:	20 1d       	sub	sp,4
8000710c:	16 94       	mov	r4,r11
8000710e:	18 92       	mov	r2,r12
80007110:	14 9b       	mov	r11,r10
80007112:	58 04       	cp.w	r4,0
80007114:	c0 51       	brne	8000711e <_realloc_r+0x16>
80007116:	fe b0 fd 1f 	rcall	80006b54 <_malloc_r>
8000711a:	18 95       	mov	r5,r12
8000711c:	c5 39       	rjmp	800073c2 <_realloc_r+0x2ba>
8000711e:	50 0a       	stdsp	sp[0x0],r10
80007120:	fe b0 f3 26 	rcall	8000576c <__malloc_lock>
80007124:	40 0b       	lddsp	r11,sp[0x0]
80007126:	f6 c8 ff f5 	sub	r8,r11,-11
8000712a:	e8 c1 00 08 	sub	r1,r4,8
8000712e:	10 96       	mov	r6,r8
80007130:	62 1c       	ld.w	r12,r1[0x4]
80007132:	e0 16 ff f8 	andl	r6,0xfff8
80007136:	59 68       	cp.w	r8,22
80007138:	f9 b6 08 10 	movls	r6,16
8000713c:	16 36       	cp.w	r6,r11
8000713e:	5f 38       	srlo	r8
80007140:	f1 e6 13 f8 	or	r8,r8,r6>>0x1f
80007144:	c0 50       	breq	8000714e <_realloc_r+0x46>
80007146:	30 c8       	mov	r8,12
80007148:	30 05       	mov	r5,0
8000714a:	85 38       	st.w	r2[0xc],r8
8000714c:	c3 b9       	rjmp	800073c2 <_realloc_r+0x2ba>
8000714e:	18 90       	mov	r0,r12
80007150:	e0 10 ff fc 	andl	r0,0xfffc
80007154:	0c 30       	cp.w	r0,r6
80007156:	e0 84 01 0b 	brge	8000736c <_realloc_r+0x264>
8000715a:	e0 68 05 38 	mov	r8,1336
8000715e:	e2 00 00 09 	add	r9,r1,r0
80007162:	70 25       	ld.w	r5,r8[0x8]
80007164:	0a 39       	cp.w	r9,r5
80007166:	c0 90       	breq	80007178 <_realloc_r+0x70>
80007168:	72 1a       	ld.w	r10,r9[0x4]
8000716a:	a1 ca       	cbr	r10,0x0
8000716c:	f2 0a 00 0a 	add	r10,r9,r10
80007170:	74 1a       	ld.w	r10,r10[0x4]
80007172:	ed ba 00 00 	bld	r10,0x0
80007176:	c2 20       	breq	800071ba <_realloc_r+0xb2>
80007178:	72 1a       	ld.w	r10,r9[0x4]
8000717a:	e0 1a ff fc 	andl	r10,0xfffc
8000717e:	f4 00 00 03 	add	r3,r10,r0
80007182:	0a 39       	cp.w	r9,r5
80007184:	c1 31       	brne	800071aa <_realloc_r+0xa2>
80007186:	ec c7 ff f0 	sub	r7,r6,-16
8000718a:	0e 33       	cp.w	r3,r7
8000718c:	c1 95       	brlt	800071be <_realloc_r+0xb6>
8000718e:	e2 06 00 09 	add	r9,r1,r6
80007192:	0c 13       	sub	r3,r6
80007194:	a1 a3       	sbr	r3,0x0
80007196:	93 13       	st.w	r9[0x4],r3
80007198:	91 29       	st.w	r8[0x8],r9
8000719a:	04 9c       	mov	r12,r2
8000719c:	62 18       	ld.w	r8,r1[0x4]
8000719e:	08 95       	mov	r5,r4
800071a0:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800071a4:	10 46       	or	r6,r8
800071a6:	83 16       	st.w	r1[0x4],r6
800071a8:	c0 b9       	rjmp	800073be <_realloc_r+0x2b6>
800071aa:	0c 33       	cp.w	r3,r6
800071ac:	c0 95       	brlt	800071be <_realloc_r+0xb6>
800071ae:	72 28       	ld.w	r8,r9[0x8]
800071b0:	02 97       	mov	r7,r1
800071b2:	72 39       	ld.w	r9,r9[0xc]
800071b4:	93 28       	st.w	r9[0x8],r8
800071b6:	91 39       	st.w	r8[0xc],r9
800071b8:	cd c8       	rjmp	80007370 <_realloc_r+0x268>
800071ba:	30 0a       	mov	r10,0
800071bc:	14 99       	mov	r9,r10
800071be:	ed bc 00 00 	bld	r12,0x0
800071c2:	e0 80 00 95 	breq	800072ec <_realloc_r+0x1e4>
800071c6:	62 07       	ld.w	r7,r1[0x0]
800071c8:	e2 07 01 07 	sub	r7,r1,r7
800071cc:	6e 1c       	ld.w	r12,r7[0x4]
800071ce:	e0 1c ff fc 	andl	r12,0xfffc
800071d2:	58 09       	cp.w	r9,0
800071d4:	c5 60       	breq	80007280 <_realloc_r+0x178>
800071d6:	f8 00 00 03 	add	r3,r12,r0
800071da:	0a 39       	cp.w	r9,r5
800071dc:	c4 81       	brne	8000726c <_realloc_r+0x164>
800071de:	14 03       	add	r3,r10
800071e0:	ec c9 ff f0 	sub	r9,r6,-16
800071e4:	12 33       	cp.w	r3,r9
800071e6:	c4 d5       	brlt	80007280 <_realloc_r+0x178>
800071e8:	6e 3a       	ld.w	r10,r7[0xc]
800071ea:	6e 29       	ld.w	r9,r7[0x8]
800071ec:	95 29       	st.w	r10[0x8],r9
800071ee:	93 3a       	st.w	r9[0xc],r10
800071f0:	ee c5 ff f8 	sub	r5,r7,-8
800071f4:	e0 ca 00 04 	sub	r10,r0,4
800071f8:	e0 4a 00 24 	cp.w	r10,36
800071fc:	e0 8b 00 25 	brhi	80007246 <_realloc_r+0x13e>
80007200:	0a 99       	mov	r9,r5
80007202:	59 3a       	cp.w	r10,19
80007204:	e0 88 00 1a 	brls	80007238 <_realloc_r+0x130>
80007208:	09 09       	ld.w	r9,r4++
8000720a:	8b 09       	st.w	r5[0x0],r9
8000720c:	09 09       	ld.w	r9,r4++
8000720e:	8f 39       	st.w	r7[0xc],r9
80007210:	ee c9 ff f0 	sub	r9,r7,-16
80007214:	59 ba       	cp.w	r10,27
80007216:	e0 88 00 11 	brls	80007238 <_realloc_r+0x130>
8000721a:	09 0b       	ld.w	r11,r4++
8000721c:	93 0b       	st.w	r9[0x0],r11
8000721e:	09 09       	ld.w	r9,r4++
80007220:	8f 59       	st.w	r7[0x14],r9
80007222:	ee c9 ff e8 	sub	r9,r7,-24
80007226:	e0 4a 00 24 	cp.w	r10,36
8000722a:	c0 71       	brne	80007238 <_realloc_r+0x130>
8000722c:	09 0a       	ld.w	r10,r4++
8000722e:	93 0a       	st.w	r9[0x0],r10
80007230:	ee c9 ff e0 	sub	r9,r7,-32
80007234:	09 0a       	ld.w	r10,r4++
80007236:	8f 7a       	st.w	r7[0x1c],r10
80007238:	09 0a       	ld.w	r10,r4++
8000723a:	12 aa       	st.w	r9++,r10
8000723c:	68 0a       	ld.w	r10,r4[0x0]
8000723e:	93 0a       	st.w	r9[0x0],r10
80007240:	68 1a       	ld.w	r10,r4[0x4]
80007242:	93 1a       	st.w	r9[0x4],r10
80007244:	c0 78       	rjmp	80007252 <_realloc_r+0x14a>
80007246:	50 08       	stdsp	sp[0x0],r8
80007248:	08 9b       	mov	r11,r4
8000724a:	0a 9c       	mov	r12,r5
8000724c:	e0 a0 1d 8f 	rcall	8000ad6a <memmove>
80007250:	40 08       	lddsp	r8,sp[0x0]
80007252:	ee 06 00 09 	add	r9,r7,r6
80007256:	0c 13       	sub	r3,r6
80007258:	a1 a3       	sbr	r3,0x0
8000725a:	93 13       	st.w	r9[0x4],r3
8000725c:	91 29       	st.w	r8[0x8],r9
8000725e:	04 9c       	mov	r12,r2
80007260:	6e 18       	ld.w	r8,r7[0x4]
80007262:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007266:	10 46       	or	r6,r8
80007268:	8f 16       	st.w	r7[0x4],r6
8000726a:	ca a8       	rjmp	800073be <_realloc_r+0x2b6>
8000726c:	14 03       	add	r3,r10
8000726e:	0c 33       	cp.w	r3,r6
80007270:	c0 85       	brlt	80007280 <_realloc_r+0x178>
80007272:	72 28       	ld.w	r8,r9[0x8]
80007274:	72 39       	ld.w	r9,r9[0xc]
80007276:	93 28       	st.w	r9[0x8],r8
80007278:	91 39       	st.w	r8[0xc],r9
8000727a:	6e 28       	ld.w	r8,r7[0x8]
8000727c:	6e 39       	ld.w	r9,r7[0xc]
8000727e:	c0 78       	rjmp	8000728c <_realloc_r+0x184>
80007280:	f8 00 00 03 	add	r3,r12,r0
80007284:	0c 33       	cp.w	r3,r6
80007286:	c3 35       	brlt	800072ec <_realloc_r+0x1e4>
80007288:	6e 39       	ld.w	r9,r7[0xc]
8000728a:	6e 28       	ld.w	r8,r7[0x8]
8000728c:	93 28       	st.w	r9[0x8],r8
8000728e:	91 39       	st.w	r8[0xc],r9
80007290:	e0 ca 00 04 	sub	r10,r0,4
80007294:	ee cc ff f8 	sub	r12,r7,-8
80007298:	e0 4a 00 24 	cp.w	r10,36
8000729c:	e0 8b 00 24 	brhi	800072e4 <_realloc_r+0x1dc>
800072a0:	59 3a       	cp.w	r10,19
800072a2:	e0 88 00 1a 	brls	800072d6 <_realloc_r+0x1ce>
800072a6:	09 08       	ld.w	r8,r4++
800072a8:	99 08       	st.w	r12[0x0],r8
800072aa:	09 08       	ld.w	r8,r4++
800072ac:	8f 38       	st.w	r7[0xc],r8
800072ae:	ee cc ff f0 	sub	r12,r7,-16
800072b2:	59 ba       	cp.w	r10,27
800072b4:	e0 88 00 11 	brls	800072d6 <_realloc_r+0x1ce>
800072b8:	09 08       	ld.w	r8,r4++
800072ba:	99 08       	st.w	r12[0x0],r8
800072bc:	09 08       	ld.w	r8,r4++
800072be:	8f 58       	st.w	r7[0x14],r8
800072c0:	ee cc ff e8 	sub	r12,r7,-24
800072c4:	e0 4a 00 24 	cp.w	r10,36
800072c8:	c0 71       	brne	800072d6 <_realloc_r+0x1ce>
800072ca:	09 08       	ld.w	r8,r4++
800072cc:	99 08       	st.w	r12[0x0],r8
800072ce:	ee cc ff e0 	sub	r12,r7,-32
800072d2:	09 08       	ld.w	r8,r4++
800072d4:	8f 78       	st.w	r7[0x1c],r8
800072d6:	09 08       	ld.w	r8,r4++
800072d8:	18 a8       	st.w	r12++,r8
800072da:	68 08       	ld.w	r8,r4[0x0]
800072dc:	99 08       	st.w	r12[0x0],r8
800072de:	68 18       	ld.w	r8,r4[0x4]
800072e0:	99 18       	st.w	r12[0x4],r8
800072e2:	c4 78       	rjmp	80007370 <_realloc_r+0x268>
800072e4:	08 9b       	mov	r11,r4
800072e6:	e0 a0 1d 42 	rcall	8000ad6a <memmove>
800072ea:	c4 38       	rjmp	80007370 <_realloc_r+0x268>
800072ec:	04 9c       	mov	r12,r2
800072ee:	fe b0 fc 33 	rcall	80006b54 <_malloc_r>
800072f2:	18 95       	mov	r5,r12
800072f4:	c3 a0       	breq	80007368 <_realloc_r+0x260>
800072f6:	62 18       	ld.w	r8,r1[0x4]
800072f8:	f8 c9 00 08 	sub	r9,r12,8
800072fc:	a1 c8       	cbr	r8,0x0
800072fe:	e2 08 00 08 	add	r8,r1,r8
80007302:	10 39       	cp.w	r9,r8
80007304:	c0 71       	brne	80007312 <_realloc_r+0x20a>
80007306:	72 13       	ld.w	r3,r9[0x4]
80007308:	02 97       	mov	r7,r1
8000730a:	e0 13 ff fc 	andl	r3,0xfffc
8000730e:	00 03       	add	r3,r0
80007310:	c3 08       	rjmp	80007370 <_realloc_r+0x268>
80007312:	e0 ca 00 04 	sub	r10,r0,4
80007316:	e0 4a 00 24 	cp.w	r10,36
8000731a:	e0 8b 00 20 	brhi	8000735a <_realloc_r+0x252>
8000731e:	08 99       	mov	r9,r4
80007320:	18 98       	mov	r8,r12
80007322:	59 3a       	cp.w	r10,19
80007324:	e0 88 00 14 	brls	8000734c <_realloc_r+0x244>
80007328:	13 0b       	ld.w	r11,r9++
8000732a:	10 ab       	st.w	r8++,r11
8000732c:	13 0b       	ld.w	r11,r9++
8000732e:	10 ab       	st.w	r8++,r11
80007330:	59 ba       	cp.w	r10,27
80007332:	e0 88 00 0d 	brls	8000734c <_realloc_r+0x244>
80007336:	13 0b       	ld.w	r11,r9++
80007338:	10 ab       	st.w	r8++,r11
8000733a:	13 0b       	ld.w	r11,r9++
8000733c:	10 ab       	st.w	r8++,r11
8000733e:	e0 4a 00 24 	cp.w	r10,36
80007342:	c0 51       	brne	8000734c <_realloc_r+0x244>
80007344:	13 0a       	ld.w	r10,r9++
80007346:	10 aa       	st.w	r8++,r10
80007348:	13 0a       	ld.w	r10,r9++
8000734a:	10 aa       	st.w	r8++,r10
8000734c:	13 0a       	ld.w	r10,r9++
8000734e:	10 aa       	st.w	r8++,r10
80007350:	72 0a       	ld.w	r10,r9[0x0]
80007352:	91 0a       	st.w	r8[0x0],r10
80007354:	72 19       	ld.w	r9,r9[0x4]
80007356:	91 19       	st.w	r8[0x4],r9
80007358:	c0 48       	rjmp	80007360 <_realloc_r+0x258>
8000735a:	08 9b       	mov	r11,r4
8000735c:	e0 a0 1d 07 	rcall	8000ad6a <memmove>
80007360:	08 9b       	mov	r11,r4
80007362:	04 9c       	mov	r12,r2
80007364:	e0 a0 1a 60 	rcall	8000a824 <_free_r>
80007368:	04 9c       	mov	r12,r2
8000736a:	c2 a8       	rjmp	800073be <_realloc_r+0x2b6>
8000736c:	00 93       	mov	r3,r0
8000736e:	02 97       	mov	r7,r1
80007370:	e6 06 01 09 	sub	r9,r3,r6
80007374:	6e 18       	ld.w	r8,r7[0x4]
80007376:	58 f9       	cp.w	r9,15
80007378:	e0 88 00 16 	brls	800073a4 <_realloc_r+0x29c>
8000737c:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007380:	ed e8 10 08 	or	r8,r6,r8
80007384:	8f 18       	st.w	r7[0x4],r8
80007386:	12 98       	mov	r8,r9
80007388:	a1 a8       	sbr	r8,0x0
8000738a:	ee 06 00 0b 	add	r11,r7,r6
8000738e:	f6 09 00 09 	add	r9,r11,r9
80007392:	97 18       	st.w	r11[0x4],r8
80007394:	72 18       	ld.w	r8,r9[0x4]
80007396:	a1 a8       	sbr	r8,0x0
80007398:	2f 8b       	sub	r11,-8
8000739a:	93 18       	st.w	r9[0x4],r8
8000739c:	04 9c       	mov	r12,r2
8000739e:	e0 a0 1a 43 	rcall	8000a824 <_free_r>
800073a2:	c0 b8       	rjmp	800073b8 <_realloc_r+0x2b0>
800073a4:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800073a8:	e7 e8 10 08 	or	r8,r3,r8
800073ac:	8f 18       	st.w	r7[0x4],r8
800073ae:	ee 03 00 03 	add	r3,r7,r3
800073b2:	66 18       	ld.w	r8,r3[0x4]
800073b4:	a1 a8       	sbr	r8,0x0
800073b6:	87 18       	st.w	r3[0x4],r8
800073b8:	04 9c       	mov	r12,r2
800073ba:	ee c5 ff f8 	sub	r5,r7,-8
800073be:	fe b0 f1 dd 	rcall	80005778 <__malloc_unlock>
800073c2:	0a 9c       	mov	r12,r5
800073c4:	2f fd       	sub	sp,-4
800073c6:	d8 32       	popm	r0-r7,pc

800073c8 <_sbrk_r>:
800073c8:	d4 21       	pushm	r4-r7,lr
800073ca:	30 08       	mov	r8,0
800073cc:	18 97       	mov	r7,r12
800073ce:	e0 66 63 9c 	mov	r6,25500
800073d2:	16 9c       	mov	r12,r11
800073d4:	8d 08       	st.w	r6[0x0],r8
800073d6:	c8 5c       	rcall	800074e0 <_sbrk>
800073d8:	5b fc       	cp.w	r12,-1
800073da:	c0 51       	brne	800073e4 <_sbrk_r+0x1c>
800073dc:	6c 08       	ld.w	r8,r6[0x0]
800073de:	58 08       	cp.w	r8,0
800073e0:	ef f8 1a 03 	st.wne	r7[0xc],r8
800073e4:	d8 22       	popm	r4-r7,pc
800073e6:	d7 03       	nop

800073e8 <sprintf>:
800073e8:	d4 01       	pushm	lr
800073ea:	21 7d       	sub	sp,92
800073ec:	e0 68 ff ff 	mov	r8,65535
800073f0:	ea 18 7f ff 	orh	r8,0x7fff
800073f4:	50 58       	stdsp	sp[0x14],r8
800073f6:	50 28       	stdsp	sp[0x8],r8
800073f8:	e0 68 02 08 	mov	r8,520
800073fc:	ba 68       	st.h	sp[0xc],r8
800073fe:	3f f8       	mov	r8,-1
80007400:	ba 78       	st.h	sp[0xe],r8
80007402:	e0 68 0a 38 	mov	r8,2616
80007406:	50 4c       	stdsp	sp[0x10],r12
80007408:	16 9a       	mov	r10,r11
8000740a:	50 0c       	stdsp	sp[0x0],r12
8000740c:	fa c9 ff a0 	sub	r9,sp,-96
80007410:	70 0c       	ld.w	r12,r8[0x0]
80007412:	1a 9b       	mov	r11,sp
80007414:	e0 a0 02 1a 	rcall	80007848 <_vfprintf_r>
80007418:	30 09       	mov	r9,0
8000741a:	40 08       	lddsp	r8,sp[0x0]
8000741c:	b0 89       	st.b	r8[0x0],r9
8000741e:	2e 9d       	sub	sp,-92
80007420:	d8 02       	popm	pc
80007422:	d7 03       	nop

80007424 <strncpy>:
80007424:	30 08       	mov	r8,0
80007426:	10 3a       	cp.w	r10,r8
80007428:	5e 0c       	reteq	r12
8000742a:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000742e:	f8 08 0b 09 	st.b	r12[r8],r9
80007432:	2f f8       	sub	r8,-1
80007434:	58 09       	cp.w	r9,0
80007436:	cf 81       	brne	80007426 <strncpy+0x2>
80007438:	10 3a       	cp.w	r10,r8
8000743a:	5e 0c       	reteq	r12
8000743c:	f8 08 0b 09 	st.b	r12[r8],r9
80007440:	2f f8       	sub	r8,-1
80007442:	cf bb       	rjmp	80007438 <strncpy+0x14>

80007444 <_close>:
80007444:	30 28       	mov	r8,2
80007446:	d6 73       	breakpoint
80007448:	3f fc       	mov	r12,-1
8000744a:	35 8b       	mov	r11,88
8000744c:	58 0c       	cp.w	r12,0
8000744e:	5e 4c       	retge	r12
80007450:	e0 6a 63 9c 	mov	r10,25500
80007454:	95 0b       	st.w	r10[0x0],r11
80007456:	5e fc       	retal	r12

80007458 <_lseek>:
80007458:	30 58       	mov	r8,5
8000745a:	d6 73       	breakpoint
8000745c:	3f fc       	mov	r12,-1
8000745e:	35 8b       	mov	r11,88
80007460:	58 0c       	cp.w	r12,0
80007462:	5e 4c       	retge	r12
80007464:	e0 6a 63 9c 	mov	r10,25500
80007468:	95 0b       	st.w	r10[0x0],r11
8000746a:	5e fc       	retal	r12

8000746c <isatty>:
8000746c:	30 b8       	mov	r8,11
8000746e:	d6 73       	breakpoint
80007470:	3f fc       	mov	r12,-1
80007472:	35 8b       	mov	r11,88
80007474:	58 0c       	cp.w	r12,0
80007476:	5e 4c       	retge	r12
80007478:	e0 6a 63 9c 	mov	r10,25500
8000747c:	95 0b       	st.w	r10[0x0],r11
8000747e:	5e fc       	retal	r12

80007480 <_fstat_host>:
80007480:	30 98       	mov	r8,9
80007482:	d6 73       	breakpoint
80007484:	3f fc       	mov	r12,-1
80007486:	35 8b       	mov	r11,88
80007488:	58 0c       	cp.w	r12,0
8000748a:	5e 4c       	retge	r12
8000748c:	e0 6a 63 9c 	mov	r10,25500
80007490:	95 0b       	st.w	r10[0x0],r11
80007492:	5e fc       	retal	r12

80007494 <_fstat>:
80007494:	d4 21       	pushm	r4-r7,lr
80007496:	21 0d       	sub	sp,64
80007498:	16 97       	mov	r7,r11
8000749a:	1a 9b       	mov	r11,sp
8000749c:	cf 2f       	rcall	80007480 <_fstat_host>
8000749e:	c0 34       	brge	800074a4 <_fstat+0x10>
800074a0:	3f fc       	mov	r12,-1
800074a2:	c1 c8       	rjmp	800074da <_fstat+0x46>
800074a4:	40 08       	lddsp	r8,sp[0x0]
800074a6:	ae 08       	st.h	r7[0x0],r8
800074a8:	40 18       	lddsp	r8,sp[0x4]
800074aa:	ae 18       	st.h	r7[0x2],r8
800074ac:	40 28       	lddsp	r8,sp[0x8]
800074ae:	8f 18       	st.w	r7[0x4],r8
800074b0:	40 38       	lddsp	r8,sp[0xc]
800074b2:	ae 48       	st.h	r7[0x8],r8
800074b4:	40 48       	lddsp	r8,sp[0x10]
800074b6:	ae 58       	st.h	r7[0xa],r8
800074b8:	40 58       	lddsp	r8,sp[0x14]
800074ba:	ae 68       	st.h	r7[0xc],r8
800074bc:	40 68       	lddsp	r8,sp[0x18]
800074be:	ae 78       	st.h	r7[0xe],r8
800074c0:	40 88       	lddsp	r8,sp[0x20]
800074c2:	8f 48       	st.w	r7[0x10],r8
800074c4:	40 a8       	lddsp	r8,sp[0x28]
800074c6:	8f b8       	st.w	r7[0x2c],r8
800074c8:	40 c8       	lddsp	r8,sp[0x30]
800074ca:	8f c8       	st.w	r7[0x30],r8
800074cc:	40 d8       	lddsp	r8,sp[0x34]
800074ce:	8f 58       	st.w	r7[0x14],r8
800074d0:	40 e8       	lddsp	r8,sp[0x38]
800074d2:	30 0c       	mov	r12,0
800074d4:	8f 78       	st.w	r7[0x1c],r8
800074d6:	40 f8       	lddsp	r8,sp[0x3c]
800074d8:	8f 98       	st.w	r7[0x24],r8
800074da:	2f 0d       	sub	sp,-64
800074dc:	d8 22       	popm	r4-r7,pc
800074de:	d7 03       	nop

800074e0 <_sbrk>:
800074e0:	d4 01       	pushm	lr
800074e2:	e0 68 0d 80 	mov	r8,3456
800074e6:	70 09       	ld.w	r9,r8[0x0]
800074e8:	58 09       	cp.w	r9,0
800074ea:	c0 41       	brne	800074f2 <_sbrk+0x12>
800074ec:	e0 69 63 a0 	mov	r9,25504
800074f0:	91 09       	st.w	r8[0x0],r9
800074f2:	e0 69 0d 80 	mov	r9,3456
800074f6:	e0 7a 70 00 	mov	r10,94208
800074fa:	72 08       	ld.w	r8,r9[0x0]
800074fc:	f0 0c 00 0c 	add	r12,r8,r12
80007500:	14 3c       	cp.w	r12,r10
80007502:	e0 8b 00 04 	brhi	8000750a <_sbrk+0x2a>
80007506:	93 0c       	st.w	r9[0x0],r12
80007508:	c0 68       	rjmp	80007514 <_sbrk+0x34>
8000750a:	e0 a0 18 15 	rcall	8000a534 <__errno>
8000750e:	30 c8       	mov	r8,12
80007510:	99 08       	st.w	r12[0x0],r8
80007512:	3f f8       	mov	r8,-1
80007514:	10 9c       	mov	r12,r8
80007516:	d8 02       	popm	pc

80007518 <get_arg>:
80007518:	d4 31       	pushm	r0-r7,lr
8000751a:	20 8d       	sub	sp,32
8000751c:	fa c4 ff bc 	sub	r4,sp,-68
80007520:	50 4b       	stdsp	sp[0x10],r11
80007522:	68 2e       	ld.w	lr,r4[0x8]
80007524:	50 58       	stdsp	sp[0x14],r8
80007526:	12 96       	mov	r6,r9
80007528:	7c 0b       	ld.w	r11,lr[0x0]
8000752a:	70 05       	ld.w	r5,r8[0x0]
8000752c:	50 6e       	stdsp	sp[0x18],lr
8000752e:	58 0b       	cp.w	r11,0
80007530:	f4 0b 17 00 	moveq	r11,r10
80007534:	68 03       	ld.w	r3,r4[0x0]
80007536:	68 11       	ld.w	r1,r4[0x4]
80007538:	40 49       	lddsp	r9,sp[0x10]
8000753a:	30 08       	mov	r8,0
8000753c:	c2 89       	rjmp	8000778c <get_arg+0x274>
8000753e:	2f fb       	sub	r11,-1
80007540:	32 5c       	mov	r12,37
80007542:	17 8a       	ld.ub	r10,r11[0x0]
80007544:	f8 0a 18 00 	cp.b	r10,r12
80007548:	5f 1e       	srne	lr
8000754a:	f0 0a 18 00 	cp.b	r10,r8
8000754e:	5f 1c       	srne	r12
80007550:	fd ec 00 0c 	and	r12,lr,r12
80007554:	f0 0c 18 00 	cp.b	r12,r8
80007558:	cf 31       	brne	8000753e <get_arg+0x26>
8000755a:	58 0a       	cp.w	r10,0
8000755c:	e0 80 01 25 	breq	800077a6 <get_arg+0x28e>
80007560:	30 0c       	mov	r12,0
80007562:	3f fa       	mov	r10,-1
80007564:	18 90       	mov	r0,r12
80007566:	50 3a       	stdsp	sp[0xc],r10
80007568:	18 94       	mov	r4,r12
8000756a:	18 92       	mov	r2,r12
8000756c:	f8 0c 00 3c 	add	r12,r12,r12<<0x3
80007570:	16 97       	mov	r7,r11
80007572:	50 7c       	stdsp	sp[0x1c],r12
80007574:	fe cc 9e b8 	sub	r12,pc,-24904
80007578:	0f 3a       	ld.ub	r10,r7++
8000757a:	f8 0a 07 0e 	ld.ub	lr,r12[r10]
8000757e:	40 7c       	lddsp	r12,sp[0x1c]
80007580:	1c 0c       	add	r12,lr
80007582:	fe ce 9f 8e 	sub	lr,pc,-24690
80007586:	fc 0c 07 0e 	ld.ub	lr,lr[r12]
8000758a:	20 1e       	sub	lr,1
8000758c:	50 0e       	stdsp	sp[0x0],lr
8000758e:	fe ce a0 06 	sub	lr,pc,-24570
80007592:	fc 0c 07 0c 	ld.ub	r12,lr[r12]
80007596:	50 7c       	stdsp	sp[0x1c],r12
80007598:	40 0c       	lddsp	r12,sp[0x0]
8000759a:	58 7c       	cp.w	r12,7
8000759c:	e0 8b 00 f1 	brhi	8000777e <get_arg+0x266>
800075a0:	fe ce a1 b8 	sub	lr,pc,-24136
800075a4:	fc 0c 03 2f 	ld.w	pc,lr[r12<<0x2]
800075a8:	36 8b       	mov	r11,104
800075aa:	f6 0a 18 00 	cp.b	r10,r11
800075ae:	e0 80 00 e8 	breq	8000777e <get_arg+0x266>
800075b2:	37 1b       	mov	r11,113
800075b4:	f6 0a 18 00 	cp.b	r10,r11
800075b8:	c0 70       	breq	800075c6 <get_arg+0xae>
800075ba:	34 cb       	mov	r11,76
800075bc:	f6 0a 18 00 	cp.b	r10,r11
800075c0:	c0 51       	brne	800075ca <get_arg+0xb2>
800075c2:	a3 b4       	sbr	r4,0x3
800075c4:	cd d8       	rjmp	8000777e <get_arg+0x266>
800075c6:	a5 b4       	sbr	r4,0x5
800075c8:	cd b8       	rjmp	8000777e <get_arg+0x266>
800075ca:	08 9a       	mov	r10,r4
800075cc:	0e 9b       	mov	r11,r7
800075ce:	a5 aa       	sbr	r10,0x4
800075d0:	17 3c       	ld.ub	r12,r11++
800075d2:	a5 b4       	sbr	r4,0x5
800075d4:	36 ce       	mov	lr,108
800075d6:	fc 0c 18 00 	cp.b	r12,lr
800075da:	e0 80 00 d3 	breq	80007780 <get_arg+0x268>
800075de:	14 94       	mov	r4,r10
800075e0:	cc f8       	rjmp	8000777e <get_arg+0x266>
800075e2:	eb d5 c0 05 	bfextu	r5,r5,0x0,0x5
800075e6:	36 7c       	mov	r12,103
800075e8:	f8 0a 18 00 	cp.b	r10,r12
800075ec:	e0 8b 00 27 	brhi	8000763a <get_arg+0x122>
800075f0:	36 5b       	mov	r11,101
800075f2:	f6 0a 18 00 	cp.b	r10,r11
800075f6:	c4 82       	brcc	80007686 <get_arg+0x16e>
800075f8:	34 fb       	mov	r11,79
800075fa:	f6 0a 18 00 	cp.b	r10,r11
800075fe:	c4 80       	breq	8000768e <get_arg+0x176>
80007600:	e0 8b 00 0c 	brhi	80007618 <get_arg+0x100>
80007604:	34 5b       	mov	r11,69
80007606:	f6 0a 18 00 	cp.b	r10,r11
8000760a:	c3 e0       	breq	80007686 <get_arg+0x16e>
8000760c:	34 7b       	mov	r11,71
8000760e:	f6 0a 18 00 	cp.b	r10,r11
80007612:	c3 a0       	breq	80007686 <get_arg+0x16e>
80007614:	34 4b       	mov	r11,68
80007616:	c0 88       	rjmp	80007626 <get_arg+0x10e>
80007618:	35 8b       	mov	r11,88
8000761a:	f6 0a 18 00 	cp.b	r10,r11
8000761e:	c2 c0       	breq	80007676 <get_arg+0x15e>
80007620:	e0 8b 00 07 	brhi	8000762e <get_arg+0x116>
80007624:	35 5b       	mov	r11,85
80007626:	f6 0a 18 00 	cp.b	r10,r11
8000762a:	c3 51       	brne	80007694 <get_arg+0x17c>
8000762c:	c3 18       	rjmp	8000768e <get_arg+0x176>
8000762e:	36 3b       	mov	r11,99
80007630:	f6 0a 18 00 	cp.b	r10,r11
80007634:	c2 f0       	breq	80007692 <get_arg+0x17a>
80007636:	36 4b       	mov	r11,100
80007638:	c0 e8       	rjmp	80007654 <get_arg+0x13c>
8000763a:	37 0b       	mov	r11,112
8000763c:	f6 0a 18 00 	cp.b	r10,r11
80007640:	c2 50       	breq	8000768a <get_arg+0x172>
80007642:	e0 8b 00 0d 	brhi	8000765c <get_arg+0x144>
80007646:	36 eb       	mov	r11,110
80007648:	f6 0a 18 00 	cp.b	r10,r11
8000764c:	c1 f0       	breq	8000768a <get_arg+0x172>
8000764e:	e0 8b 00 14 	brhi	80007676 <get_arg+0x15e>
80007652:	36 9b       	mov	r11,105
80007654:	f6 0a 18 00 	cp.b	r10,r11
80007658:	c1 e1       	brne	80007694 <get_arg+0x17c>
8000765a:	c0 e8       	rjmp	80007676 <get_arg+0x15e>
8000765c:	37 5b       	mov	r11,117
8000765e:	f6 0a 18 00 	cp.b	r10,r11
80007662:	c0 a0       	breq	80007676 <get_arg+0x15e>
80007664:	37 8b       	mov	r11,120
80007666:	f6 0a 18 00 	cp.b	r10,r11
8000766a:	c0 60       	breq	80007676 <get_arg+0x15e>
8000766c:	37 3b       	mov	r11,115
8000766e:	f6 0a 18 00 	cp.b	r10,r11
80007672:	c1 11       	brne	80007694 <get_arg+0x17c>
80007674:	c0 b8       	rjmp	8000768a <get_arg+0x172>
80007676:	ed b4 00 04 	bld	r4,0x4
8000767a:	c0 a0       	breq	8000768e <get_arg+0x176>
8000767c:	ed b4 00 05 	bld	r4,0x5
80007680:	c0 91       	brne	80007692 <get_arg+0x17a>
80007682:	30 20       	mov	r0,2
80007684:	c0 88       	rjmp	80007694 <get_arg+0x17c>
80007686:	30 40       	mov	r0,4
80007688:	c0 68       	rjmp	80007694 <get_arg+0x17c>
8000768a:	30 30       	mov	r0,3
8000768c:	c0 48       	rjmp	80007694 <get_arg+0x17c>
8000768e:	30 10       	mov	r0,1
80007690:	c0 28       	rjmp	80007694 <get_arg+0x17c>
80007692:	30 00       	mov	r0,0
80007694:	40 3b       	lddsp	r11,sp[0xc]
80007696:	5b fb       	cp.w	r11,-1
80007698:	c0 40       	breq	800076a0 <get_arg+0x188>
8000769a:	e2 0b 09 20 	st.w	r1[r11<<0x2],r0
8000769e:	c7 08       	rjmp	8000777e <get_arg+0x266>
800076a0:	58 60       	cp.w	r0,6
800076a2:	e0 8b 00 6e 	brhi	8000777e <get_arg+0x266>
800076a6:	6c 0a       	ld.w	r10,r6[0x0]
800076a8:	ea cc ff ff 	sub	r12,r5,-1
800076ac:	fe ce a2 a4 	sub	lr,pc,-23900
800076b0:	fc 00 03 2f 	ld.w	pc,lr[r0<<0x2]
800076b4:	f4 cb ff f8 	sub	r11,r10,-8
800076b8:	8d 0b       	st.w	r6[0x0],r11
800076ba:	f4 ea 00 00 	ld.d	r10,r10[0]
800076be:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
800076c2:	c0 f8       	rjmp	800076e0 <get_arg+0x1c8>
800076c4:	f4 cb ff fc 	sub	r11,r10,-4
800076c8:	8d 0b       	st.w	r6[0x0],r11
800076ca:	74 0a       	ld.w	r10,r10[0x0]
800076cc:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
800076d0:	c0 88       	rjmp	800076e0 <get_arg+0x1c8>
800076d2:	f4 cb ff f8 	sub	r11,r10,-8
800076d6:	8d 0b       	st.w	r6[0x0],r11
800076d8:	f4 ea 00 00 	ld.d	r10,r10[0]
800076dc:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
800076e0:	0e 9b       	mov	r11,r7
800076e2:	18 95       	mov	r5,r12
800076e4:	c4 e8       	rjmp	80007780 <get_arg+0x268>
800076e6:	62 0a       	ld.w	r10,r1[0x0]
800076e8:	5b fa       	cp.w	r10,-1
800076ea:	c0 b1       	brne	80007700 <get_arg+0x1e8>
800076ec:	50 19       	stdsp	sp[0x4],r9
800076ee:	50 28       	stdsp	sp[0x8],r8
800076f0:	e0 6a 00 80 	mov	r10,128
800076f4:	30 0b       	mov	r11,0
800076f6:	02 9c       	mov	r12,r1
800076f8:	fe b0 fd 01 	rcall	800070fa <memset>
800076fc:	40 28       	lddsp	r8,sp[0x8]
800076fe:	40 19       	lddsp	r9,sp[0x4]
80007700:	e4 cc 00 01 	sub	r12,r2,1
80007704:	0e 9b       	mov	r11,r7
80007706:	50 3c       	stdsp	sp[0xc],r12
80007708:	f2 0c 0c 49 	max	r9,r9,r12
8000770c:	c3 a8       	rjmp	80007780 <get_arg+0x268>
8000770e:	62 0a       	ld.w	r10,r1[0x0]
80007710:	5b fa       	cp.w	r10,-1
80007712:	c0 b1       	brne	80007728 <get_arg+0x210>
80007714:	50 19       	stdsp	sp[0x4],r9
80007716:	50 28       	stdsp	sp[0x8],r8
80007718:	e0 6a 00 80 	mov	r10,128
8000771c:	30 0b       	mov	r11,0
8000771e:	02 9c       	mov	r12,r1
80007720:	fe b0 fc ed 	rcall	800070fa <memset>
80007724:	40 28       	lddsp	r8,sp[0x8]
80007726:	40 19       	lddsp	r9,sp[0x4]
80007728:	20 12       	sub	r2,1
8000772a:	30 0a       	mov	r10,0
8000772c:	0e 9b       	mov	r11,r7
8000772e:	e2 02 09 2a 	st.w	r1[r2<<0x2],r10
80007732:	f2 02 0c 49 	max	r9,r9,r2
80007736:	c2 58       	rjmp	80007780 <get_arg+0x268>
80007738:	16 97       	mov	r7,r11
8000773a:	6c 0a       	ld.w	r10,r6[0x0]
8000773c:	f4 cb ff fc 	sub	r11,r10,-4
80007740:	8d 0b       	st.w	r6[0x0],r11
80007742:	74 0a       	ld.w	r10,r10[0x0]
80007744:	0e 9b       	mov	r11,r7
80007746:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
8000774a:	2f f5       	sub	r5,-1
8000774c:	c1 a8       	rjmp	80007780 <get_arg+0x268>
8000774e:	f4 c2 00 30 	sub	r2,r10,48
80007752:	c0 68       	rjmp	8000775e <get_arg+0x246>
80007754:	e4 02 00 22 	add	r2,r2,r2<<0x2
80007758:	2f f7       	sub	r7,-1
8000775a:	f4 02 00 12 	add	r2,r10,r2<<0x1
8000775e:	0f 8a       	ld.ub	r10,r7[0x0]
80007760:	58 0a       	cp.w	r10,0
80007762:	c0 e0       	breq	8000777e <get_arg+0x266>
80007764:	23 0a       	sub	r10,48
80007766:	58 9a       	cp.w	r10,9
80007768:	fe 98 ff f6 	brls	80007754 <get_arg+0x23c>
8000776c:	c0 98       	rjmp	8000777e <get_arg+0x266>
8000776e:	2f f7       	sub	r7,-1
80007770:	0f 8a       	ld.ub	r10,r7[0x0]
80007772:	58 0a       	cp.w	r10,0
80007774:	c0 50       	breq	8000777e <get_arg+0x266>
80007776:	23 0a       	sub	r10,48
80007778:	58 9a       	cp.w	r10,9
8000777a:	fe 98 ff fa 	brls	8000776e <get_arg+0x256>
8000777e:	0e 9b       	mov	r11,r7
80007780:	40 7c       	lddsp	r12,sp[0x1c]
80007782:	30 ba       	mov	r10,11
80007784:	f4 0c 18 00 	cp.b	r12,r10
80007788:	fe 91 fe f2 	brne	8000756c <get_arg+0x54>
8000778c:	40 42       	lddsp	r2,sp[0x10]
8000778e:	17 8c       	ld.ub	r12,r11[0x0]
80007790:	0a 32       	cp.w	r2,r5
80007792:	5f 4a       	srge	r10
80007794:	f0 0c 18 00 	cp.b	r12,r8
80007798:	5f 1c       	srne	r12
8000779a:	f9 ea 00 0a 	and	r10,r12,r10
8000779e:	f0 0a 18 00 	cp.b	r10,r8
800077a2:	fe 91 fe cf 	brne	80007540 <get_arg+0x28>
800077a6:	30 08       	mov	r8,0
800077a8:	40 4e       	lddsp	lr,sp[0x10]
800077aa:	17 8a       	ld.ub	r10,r11[0x0]
800077ac:	e2 05 00 21 	add	r1,r1,r5<<0x2
800077b0:	f0 0a 18 00 	cp.b	r10,r8
800077b4:	fc 09 17 10 	movne	r9,lr
800077b8:	e6 05 00 38 	add	r8,r3,r5<<0x3
800077bc:	06 9e       	mov	lr,r3
800077be:	c2 a8       	rjmp	80007812 <get_arg+0x2fa>
800077c0:	62 0a       	ld.w	r10,r1[0x0]
800077c2:	58 3a       	cp.w	r10,3
800077c4:	c1 e0       	breq	80007800 <get_arg+0x2e8>
800077c6:	e0 89 00 07 	brgt	800077d4 <get_arg+0x2bc>
800077ca:	58 1a       	cp.w	r10,1
800077cc:	c1 a0       	breq	80007800 <get_arg+0x2e8>
800077ce:	58 2a       	cp.w	r10,2
800077d0:	c1 81       	brne	80007800 <get_arg+0x2e8>
800077d2:	c0 58       	rjmp	800077dc <get_arg+0x2c4>
800077d4:	58 5a       	cp.w	r10,5
800077d6:	c0 c0       	breq	800077ee <get_arg+0x2d6>
800077d8:	c0 b5       	brlt	800077ee <get_arg+0x2d6>
800077da:	c1 38       	rjmp	80007800 <get_arg+0x2e8>
800077dc:	6c 0a       	ld.w	r10,r6[0x0]
800077de:	f4 cc ff f8 	sub	r12,r10,-8
800077e2:	8d 0c       	st.w	r6[0x0],r12
800077e4:	f4 e2 00 00 	ld.d	r2,r10[0]
800077e8:	f0 e3 00 00 	st.d	r8[0],r2
800077ec:	c1 08       	rjmp	8000780c <get_arg+0x2f4>
800077ee:	6c 0a       	ld.w	r10,r6[0x0]
800077f0:	f4 cc ff f8 	sub	r12,r10,-8
800077f4:	8d 0c       	st.w	r6[0x0],r12
800077f6:	f4 e2 00 00 	ld.d	r2,r10[0]
800077fa:	f0 e3 00 00 	st.d	r8[0],r2
800077fe:	c0 78       	rjmp	8000780c <get_arg+0x2f4>
80007800:	6c 0a       	ld.w	r10,r6[0x0]
80007802:	f4 cc ff fc 	sub	r12,r10,-4
80007806:	8d 0c       	st.w	r6[0x0],r12
80007808:	74 0a       	ld.w	r10,r10[0x0]
8000780a:	91 0a       	st.w	r8[0x0],r10
8000780c:	2f f5       	sub	r5,-1
8000780e:	2f 88       	sub	r8,-8
80007810:	2f c1       	sub	r1,-4
80007812:	12 35       	cp.w	r5,r9
80007814:	fe 9a ff d6 	brle	800077c0 <get_arg+0x2a8>
80007818:	1c 93       	mov	r3,lr
8000781a:	40 52       	lddsp	r2,sp[0x14]
8000781c:	40 6e       	lddsp	lr,sp[0x18]
8000781e:	85 05       	st.w	r2[0x0],r5
80007820:	9d 0b       	st.w	lr[0x0],r11
80007822:	40 4b       	lddsp	r11,sp[0x10]
80007824:	e6 0b 00 3c 	add	r12,r3,r11<<0x3
80007828:	2f 8d       	sub	sp,-32
8000782a:	d8 32       	popm	r0-r7,pc

8000782c <__sprint_r>:
8000782c:	d4 21       	pushm	r4-r7,lr
8000782e:	14 97       	mov	r7,r10
80007830:	74 28       	ld.w	r8,r10[0x8]
80007832:	58 08       	cp.w	r8,0
80007834:	c0 41       	brne	8000783c <__sprint_r+0x10>
80007836:	95 18       	st.w	r10[0x4],r8
80007838:	10 9c       	mov	r12,r8
8000783a:	d8 22       	popm	r4-r7,pc
8000783c:	e0 a0 18 ba 	rcall	8000a9b0 <__sfvwrite_r>
80007840:	30 08       	mov	r8,0
80007842:	8f 18       	st.w	r7[0x4],r8
80007844:	8f 28       	st.w	r7[0x8],r8
80007846:	d8 22       	popm	r4-r7,pc

80007848 <_vfprintf_r>:
80007848:	d4 31       	pushm	r0-r7,lr
8000784a:	fa cd 06 bc 	sub	sp,sp,1724
8000784e:	51 09       	stdsp	sp[0x40],r9
80007850:	16 91       	mov	r1,r11
80007852:	14 97       	mov	r7,r10
80007854:	18 95       	mov	r5,r12
80007856:	e0 a0 1a 1d 	rcall	8000ac90 <_localeconv_r>
8000785a:	78 0c       	ld.w	r12,r12[0x0]
8000785c:	50 cc       	stdsp	sp[0x30],r12
8000785e:	58 05       	cp.w	r5,0
80007860:	c0 70       	breq	8000786e <_vfprintf_r+0x26>
80007862:	6a 68       	ld.w	r8,r5[0x18]
80007864:	58 08       	cp.w	r8,0
80007866:	c0 41       	brne	8000786e <_vfprintf_r+0x26>
80007868:	0a 9c       	mov	r12,r5
8000786a:	e0 a0 17 43 	rcall	8000a6f0 <__sinit>
8000786e:	fe c8 a0 a2 	sub	r8,pc,-24414
80007872:	10 31       	cp.w	r1,r8
80007874:	c0 31       	brne	8000787a <_vfprintf_r+0x32>
80007876:	6a 01       	ld.w	r1,r5[0x0]
80007878:	c0 c8       	rjmp	80007890 <_vfprintf_r+0x48>
8000787a:	fe c8 a0 8e 	sub	r8,pc,-24434
8000787e:	10 31       	cp.w	r1,r8
80007880:	c0 31       	brne	80007886 <_vfprintf_r+0x3e>
80007882:	6a 11       	ld.w	r1,r5[0x4]
80007884:	c0 68       	rjmp	80007890 <_vfprintf_r+0x48>
80007886:	fe c8 a0 7a 	sub	r8,pc,-24454
8000788a:	10 31       	cp.w	r1,r8
8000788c:	eb f1 00 02 	ld.weq	r1,r5[0x8]
80007890:	82 68       	ld.sh	r8,r1[0xc]
80007892:	ed b8 00 03 	bld	r8,0x3
80007896:	c0 41       	brne	8000789e <_vfprintf_r+0x56>
80007898:	62 48       	ld.w	r8,r1[0x10]
8000789a:	58 08       	cp.w	r8,0
8000789c:	c0 71       	brne	800078aa <_vfprintf_r+0x62>
8000789e:	02 9b       	mov	r11,r1
800078a0:	0a 9c       	mov	r12,r5
800078a2:	e0 a0 0f 5d 	rcall	8000975c <__swsetup_r>
800078a6:	e0 81 0f 54 	brne	8000974e <_vfprintf_r+0x1f06>
800078aa:	82 68       	ld.sh	r8,r1[0xc]
800078ac:	10 99       	mov	r9,r8
800078ae:	e2 19 00 1a 	andl	r9,0x1a,COH
800078b2:	58 a9       	cp.w	r9,10
800078b4:	c3 c1       	brne	8000792c <_vfprintf_r+0xe4>
800078b6:	82 79       	ld.sh	r9,r1[0xe]
800078b8:	30 0a       	mov	r10,0
800078ba:	f4 09 19 00 	cp.h	r9,r10
800078be:	c3 75       	brlt	8000792c <_vfprintf_r+0xe4>
800078c0:	a1 d8       	cbr	r8,0x1
800078c2:	fb 58 05 d0 	st.h	sp[1488],r8
800078c6:	62 88       	ld.w	r8,r1[0x20]
800078c8:	fb 48 05 e4 	st.w	sp[1508],r8
800078cc:	62 a8       	ld.w	r8,r1[0x28]
800078ce:	fb 48 05 ec 	st.w	sp[1516],r8
800078d2:	fa c8 ff bc 	sub	r8,sp,-68
800078d6:	fb 48 05 d4 	st.w	sp[1492],r8
800078da:	fb 48 05 c4 	st.w	sp[1476],r8
800078de:	e0 68 04 00 	mov	r8,1024
800078e2:	fb 48 05 d8 	st.w	sp[1496],r8
800078e6:	fb 48 05 cc 	st.w	sp[1484],r8
800078ea:	30 08       	mov	r8,0
800078ec:	fb 59 05 d2 	st.h	sp[1490],r9
800078f0:	0e 9a       	mov	r10,r7
800078f2:	41 09       	lddsp	r9,sp[0x40]
800078f4:	fa c7 fa 3c 	sub	r7,sp,-1476
800078f8:	fb 48 05 dc 	st.w	sp[1500],r8
800078fc:	0a 9c       	mov	r12,r5
800078fe:	0e 9b       	mov	r11,r7
80007900:	ca 4f       	rcall	80007848 <_vfprintf_r>
80007902:	50 bc       	stdsp	sp[0x2c],r12
80007904:	c0 95       	brlt	80007916 <_vfprintf_r+0xce>
80007906:	0e 9b       	mov	r11,r7
80007908:	0a 9c       	mov	r12,r5
8000790a:	e0 a0 16 1b 	rcall	8000a540 <_fflush_r>
8000790e:	40 be       	lddsp	lr,sp[0x2c]
80007910:	f9 be 01 ff 	movne	lr,-1
80007914:	50 be       	stdsp	sp[0x2c],lr
80007916:	fb 08 05 d0 	ld.sh	r8,sp[1488]
8000791a:	ed b8 00 06 	bld	r8,0x6
8000791e:	e0 81 0f 1a 	brne	80009752 <_vfprintf_r+0x1f0a>
80007922:	82 68       	ld.sh	r8,r1[0xc]
80007924:	a7 a8       	sbr	r8,0x6
80007926:	a2 68       	st.h	r1[0xc],r8
80007928:	e0 8f 0f 15 	bral	80009752 <_vfprintf_r+0x1f0a>
8000792c:	30 08       	mov	r8,0
8000792e:	fb 48 06 b4 	st.w	sp[1716],r8
80007932:	fb 48 06 90 	st.w	sp[1680],r8
80007936:	fb 48 06 8c 	st.w	sp[1676],r8
8000793a:	fb 48 06 b0 	st.w	sp[1712],r8
8000793e:	30 08       	mov	r8,0
80007940:	30 09       	mov	r9,0
80007942:	50 a7       	stdsp	sp[0x28],r7
80007944:	50 78       	stdsp	sp[0x1c],r8
80007946:	fa c3 f9 e0 	sub	r3,sp,-1568
8000794a:	3f f8       	mov	r8,-1
8000794c:	50 59       	stdsp	sp[0x14],r9
8000794e:	fb 43 06 88 	st.w	sp[1672],r3
80007952:	fb 48 05 44 	st.w	sp[1348],r8
80007956:	12 9c       	mov	r12,r9
80007958:	50 69       	stdsp	sp[0x18],r9
8000795a:	50 d9       	stdsp	sp[0x34],r9
8000795c:	50 e9       	stdsp	sp[0x38],r9
8000795e:	50 b9       	stdsp	sp[0x2c],r9
80007960:	12 97       	mov	r7,r9
80007962:	0a 94       	mov	r4,r5
80007964:	40 a2       	lddsp	r2,sp[0x28]
80007966:	32 5a       	mov	r10,37
80007968:	30 08       	mov	r8,0
8000796a:	c0 28       	rjmp	8000796e <_vfprintf_r+0x126>
8000796c:	2f f2       	sub	r2,-1
8000796e:	05 89       	ld.ub	r9,r2[0x0]
80007970:	f0 09 18 00 	cp.b	r9,r8
80007974:	5f 1b       	srne	r11
80007976:	f4 09 18 00 	cp.b	r9,r10
8000797a:	5f 19       	srne	r9
8000797c:	f3 eb 00 0b 	and	r11,r9,r11
80007980:	f0 0b 18 00 	cp.b	r11,r8
80007984:	cf 41       	brne	8000796c <_vfprintf_r+0x124>
80007986:	40 ab       	lddsp	r11,sp[0x28]
80007988:	e4 0b 01 06 	sub	r6,r2,r11
8000798c:	c1 e0       	breq	800079c8 <_vfprintf_r+0x180>
8000798e:	fa f8 06 90 	ld.w	r8,sp[1680]
80007992:	0c 08       	add	r8,r6
80007994:	87 0b       	st.w	r3[0x0],r11
80007996:	fb 48 06 90 	st.w	sp[1680],r8
8000799a:	87 16       	st.w	r3[0x4],r6
8000799c:	fa f8 06 8c 	ld.w	r8,sp[1676]
800079a0:	2f f8       	sub	r8,-1
800079a2:	fb 48 06 8c 	st.w	sp[1676],r8
800079a6:	58 78       	cp.w	r8,7
800079a8:	e0 89 00 04 	brgt	800079b0 <_vfprintf_r+0x168>
800079ac:	2f 83       	sub	r3,-8
800079ae:	c0 a8       	rjmp	800079c2 <_vfprintf_r+0x17a>
800079b0:	fa ca f9 78 	sub	r10,sp,-1672
800079b4:	02 9b       	mov	r11,r1
800079b6:	08 9c       	mov	r12,r4
800079b8:	c3 af       	rcall	8000782c <__sprint_r>
800079ba:	e0 81 0e c6 	brne	80009746 <_vfprintf_r+0x1efe>
800079be:	fa c3 f9 e0 	sub	r3,sp,-1568
800079c2:	40 ba       	lddsp	r10,sp[0x2c]
800079c4:	0c 0a       	add	r10,r6
800079c6:	50 ba       	stdsp	sp[0x2c],r10
800079c8:	05 89       	ld.ub	r9,r2[0x0]
800079ca:	30 08       	mov	r8,0
800079cc:	f0 09 18 00 	cp.b	r9,r8
800079d0:	e0 80 0e aa 	breq	80009724 <_vfprintf_r+0x1edc>
800079d4:	30 09       	mov	r9,0
800079d6:	fb 68 06 bb 	st.b	sp[1723],r8
800079da:	0e 96       	mov	r6,r7
800079dc:	e4 c8 ff ff 	sub	r8,r2,-1
800079e0:	3f fe       	mov	lr,-1
800079e2:	50 93       	stdsp	sp[0x24],r3
800079e4:	50 41       	stdsp	sp[0x10],r1
800079e6:	0e 93       	mov	r3,r7
800079e8:	04 91       	mov	r1,r2
800079ea:	50 89       	stdsp	sp[0x20],r9
800079ec:	50 a8       	stdsp	sp[0x28],r8
800079ee:	50 2e       	stdsp	sp[0x8],lr
800079f0:	50 39       	stdsp	sp[0xc],r9
800079f2:	12 95       	mov	r5,r9
800079f4:	12 90       	mov	r0,r9
800079f6:	10 97       	mov	r7,r8
800079f8:	08 92       	mov	r2,r4
800079fa:	c0 78       	rjmp	80007a08 <_vfprintf_r+0x1c0>
800079fc:	3f fc       	mov	r12,-1
800079fe:	08 97       	mov	r7,r4
80007a00:	50 2c       	stdsp	sp[0x8],r12
80007a02:	c0 38       	rjmp	80007a08 <_vfprintf_r+0x1c0>
80007a04:	30 0b       	mov	r11,0
80007a06:	50 3b       	stdsp	sp[0xc],r11
80007a08:	0f 38       	ld.ub	r8,r7++
80007a0a:	c0 28       	rjmp	80007a0e <_vfprintf_r+0x1c6>
80007a0c:	12 90       	mov	r0,r9
80007a0e:	f0 c9 00 20 	sub	r9,r8,32
80007a12:	e0 49 00 58 	cp.w	r9,88
80007a16:	e0 8b 0a 30 	brhi	80008e76 <_vfprintf_r+0x162e>
80007a1a:	fe ca a5 f6 	sub	r10,pc,-23050
80007a1e:	f4 09 03 2f 	ld.w	pc,r10[r9<<0x2]
80007a22:	50 a7       	stdsp	sp[0x28],r7
80007a24:	50 80       	stdsp	sp[0x20],r0
80007a26:	0c 97       	mov	r7,r6
80007a28:	04 94       	mov	r4,r2
80007a2a:	06 96       	mov	r6,r3
80007a2c:	02 92       	mov	r2,r1
80007a2e:	fe c9 a3 ce 	sub	r9,pc,-23602
80007a32:	40 93       	lddsp	r3,sp[0x24]
80007a34:	10 90       	mov	r0,r8
80007a36:	40 41       	lddsp	r1,sp[0x10]
80007a38:	50 d9       	stdsp	sp[0x34],r9
80007a3a:	e0 8f 08 8e 	bral	80008b56 <_vfprintf_r+0x130e>
80007a3e:	30 08       	mov	r8,0
80007a40:	fb 39 06 bb 	ld.ub	r9,sp[1723]
80007a44:	f0 09 18 00 	cp.b	r9,r8
80007a48:	ce 01       	brne	80007a08 <_vfprintf_r+0x1c0>
80007a4a:	32 08       	mov	r8,32
80007a4c:	c6 e8       	rjmp	80007b28 <_vfprintf_r+0x2e0>
80007a4e:	a1 a5       	sbr	r5,0x0
80007a50:	cd cb       	rjmp	80007a08 <_vfprintf_r+0x1c0>
80007a52:	0f 89       	ld.ub	r9,r7[0x0]
80007a54:	f2 c8 00 30 	sub	r8,r9,48
80007a58:	58 98       	cp.w	r8,9
80007a5a:	e0 8b 00 1d 	brhi	80007a94 <_vfprintf_r+0x24c>
80007a5e:	ee c8 ff ff 	sub	r8,r7,-1
80007a62:	30 0b       	mov	r11,0
80007a64:	23 09       	sub	r9,48
80007a66:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
80007a6a:	f2 0b 00 1b 	add	r11,r9,r11<<0x1
80007a6e:	11 39       	ld.ub	r9,r8++
80007a70:	f2 ca 00 30 	sub	r10,r9,48
80007a74:	58 9a       	cp.w	r10,9
80007a76:	fe 98 ff f7 	brls	80007a64 <_vfprintf_r+0x21c>
80007a7a:	e0 49 00 24 	cp.w	r9,36
80007a7e:	cc 31       	brne	80007a04 <_vfprintf_r+0x1bc>
80007a80:	e0 4b 00 20 	cp.w	r11,32
80007a84:	e0 89 0e 60 	brgt	80009744 <_vfprintf_r+0x1efc>
80007a88:	20 1b       	sub	r11,1
80007a8a:	fa f9 06 b4 	ld.w	r9,sp[1716]
80007a8e:	12 3b       	cp.w	r11,r9
80007a90:	c0 95       	brlt	80007aa2 <_vfprintf_r+0x25a>
80007a92:	c1 08       	rjmp	80007ab2 <_vfprintf_r+0x26a>
80007a94:	fa f9 06 b4 	ld.w	r9,sp[1716]
80007a98:	ec ca ff ff 	sub	r10,r6,-1
80007a9c:	12 36       	cp.w	r6,r9
80007a9e:	c1 f5       	brlt	80007adc <_vfprintf_r+0x294>
80007aa0:	c2 68       	rjmp	80007aec <_vfprintf_r+0x2a4>
80007aa2:	fa ce f9 44 	sub	lr,sp,-1724
80007aa6:	10 97       	mov	r7,r8
80007aa8:	fc 0b 00 3b 	add	r11,lr,r11<<0x3
80007aac:	f6 f0 fd 88 	ld.w	r0,r11[-632]
80007ab0:	c3 58       	rjmp	80007b1a <_vfprintf_r+0x2d2>
80007ab2:	10 97       	mov	r7,r8
80007ab4:	fa c8 f9 50 	sub	r8,sp,-1712
80007ab8:	1a d8       	st.w	--sp,r8
80007aba:	fa c8 fa b8 	sub	r8,sp,-1352
80007abe:	1a d8       	st.w	--sp,r8
80007ac0:	fa c8 fb b4 	sub	r8,sp,-1100
80007ac4:	02 9a       	mov	r10,r1
80007ac6:	1a d8       	st.w	--sp,r8
80007ac8:	04 9c       	mov	r12,r2
80007aca:	fa c8 f9 40 	sub	r8,sp,-1728
80007ace:	fa c9 ff b4 	sub	r9,sp,-76
80007ad2:	fe b0 fd 23 	rcall	80007518 <get_arg>
80007ad6:	2f dd       	sub	sp,-12
80007ad8:	78 00       	ld.w	r0,r12[0x0]
80007ada:	c2 08       	rjmp	80007b1a <_vfprintf_r+0x2d2>
80007adc:	fa cc f9 44 	sub	r12,sp,-1724
80007ae0:	14 96       	mov	r6,r10
80007ae2:	f8 03 00 38 	add	r8,r12,r3<<0x3
80007ae6:	f0 f0 fd 88 	ld.w	r0,r8[-632]
80007aea:	c1 88       	rjmp	80007b1a <_vfprintf_r+0x2d2>
80007aec:	41 08       	lddsp	r8,sp[0x40]
80007aee:	59 f9       	cp.w	r9,31
80007af0:	e0 89 00 11 	brgt	80007b12 <_vfprintf_r+0x2ca>
80007af4:	f0 cb ff fc 	sub	r11,r8,-4
80007af8:	51 0b       	stdsp	sp[0x40],r11
80007afa:	70 00       	ld.w	r0,r8[0x0]
80007afc:	fa cb f9 44 	sub	r11,sp,-1724
80007b00:	f6 09 00 38 	add	r8,r11,r9<<0x3
80007b04:	f1 40 fd 88 	st.w	r8[-632],r0
80007b08:	2f f9       	sub	r9,-1
80007b0a:	14 96       	mov	r6,r10
80007b0c:	fb 49 06 b4 	st.w	sp[1716],r9
80007b10:	c0 58       	rjmp	80007b1a <_vfprintf_r+0x2d2>
80007b12:	70 00       	ld.w	r0,r8[0x0]
80007b14:	14 96       	mov	r6,r10
80007b16:	2f c8       	sub	r8,-4
80007b18:	51 08       	stdsp	sp[0x40],r8
80007b1a:	58 00       	cp.w	r0,0
80007b1c:	fe 94 ff 76 	brge	80007a08 <_vfprintf_r+0x1c0>
80007b20:	5c 30       	neg	r0
80007b22:	a3 a5       	sbr	r5,0x2
80007b24:	c7 2b       	rjmp	80007a08 <_vfprintf_r+0x1c0>
80007b26:	32 b8       	mov	r8,43
80007b28:	fb 68 06 bb 	st.b	sp[1723],r8
80007b2c:	c6 eb       	rjmp	80007a08 <_vfprintf_r+0x1c0>
80007b2e:	0f 38       	ld.ub	r8,r7++
80007b30:	e0 48 00 2a 	cp.w	r8,42
80007b34:	c0 30       	breq	80007b3a <_vfprintf_r+0x2f2>
80007b36:	30 09       	mov	r9,0
80007b38:	c7 98       	rjmp	80007c2a <_vfprintf_r+0x3e2>
80007b3a:	0f 88       	ld.ub	r8,r7[0x0]
80007b3c:	f0 c9 00 30 	sub	r9,r8,48
80007b40:	58 99       	cp.w	r9,9
80007b42:	e0 8b 00 1f 	brhi	80007b80 <_vfprintf_r+0x338>
80007b46:	ee c4 ff ff 	sub	r4,r7,-1
80007b4a:	30 0b       	mov	r11,0
80007b4c:	23 08       	sub	r8,48
80007b4e:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
80007b52:	f0 0b 00 1b 	add	r11,r8,r11<<0x1
80007b56:	09 38       	ld.ub	r8,r4++
80007b58:	f0 c9 00 30 	sub	r9,r8,48
80007b5c:	58 99       	cp.w	r9,9
80007b5e:	fe 98 ff f7 	brls	80007b4c <_vfprintf_r+0x304>
80007b62:	e0 48 00 24 	cp.w	r8,36
80007b66:	fe 91 ff 4f 	brne	80007a04 <_vfprintf_r+0x1bc>
80007b6a:	e0 4b 00 20 	cp.w	r11,32
80007b6e:	e0 89 0d eb 	brgt	80009744 <_vfprintf_r+0x1efc>
80007b72:	20 1b       	sub	r11,1
80007b74:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007b78:	10 3b       	cp.w	r11,r8
80007b7a:	c0 a5       	brlt	80007b8e <_vfprintf_r+0x346>
80007b7c:	c1 18       	rjmp	80007b9e <_vfprintf_r+0x356>
80007b7e:	d7 03       	nop
80007b80:	fa fa 06 b4 	ld.w	r10,sp[1716]
80007b84:	ec c9 ff ff 	sub	r9,r6,-1
80007b88:	14 36       	cp.w	r6,r10
80007b8a:	c1 f5       	brlt	80007bc8 <_vfprintf_r+0x380>
80007b8c:	c2 88       	rjmp	80007bdc <_vfprintf_r+0x394>
80007b8e:	fa ca f9 44 	sub	r10,sp,-1724
80007b92:	f4 0b 00 3b 	add	r11,r10,r11<<0x3
80007b96:	f6 fb fd 88 	ld.w	r11,r11[-632]
80007b9a:	50 2b       	stdsp	sp[0x8],r11
80007b9c:	c3 c8       	rjmp	80007c14 <_vfprintf_r+0x3cc>
80007b9e:	fa c8 f9 50 	sub	r8,sp,-1712
80007ba2:	1a d8       	st.w	--sp,r8
80007ba4:	fa c8 fa b8 	sub	r8,sp,-1352
80007ba8:	1a d8       	st.w	--sp,r8
80007baa:	fa c8 fb b4 	sub	r8,sp,-1100
80007bae:	02 9a       	mov	r10,r1
80007bb0:	1a d8       	st.w	--sp,r8
80007bb2:	04 9c       	mov	r12,r2
80007bb4:	fa c8 f9 40 	sub	r8,sp,-1728
80007bb8:	fa c9 ff b4 	sub	r9,sp,-76
80007bbc:	fe b0 fc ae 	rcall	80007518 <get_arg>
80007bc0:	2f dd       	sub	sp,-12
80007bc2:	78 0c       	ld.w	r12,r12[0x0]
80007bc4:	50 2c       	stdsp	sp[0x8],r12
80007bc6:	c2 78       	rjmp	80007c14 <_vfprintf_r+0x3cc>
80007bc8:	12 96       	mov	r6,r9
80007bca:	0e 94       	mov	r4,r7
80007bcc:	fa c9 f9 44 	sub	r9,sp,-1724
80007bd0:	f2 03 00 38 	add	r8,r9,r3<<0x3
80007bd4:	f0 f8 fd 88 	ld.w	r8,r8[-632]
80007bd8:	50 28       	stdsp	sp[0x8],r8
80007bda:	c1 d8       	rjmp	80007c14 <_vfprintf_r+0x3cc>
80007bdc:	41 08       	lddsp	r8,sp[0x40]
80007bde:	59 fa       	cp.w	r10,31
80007be0:	e0 89 00 14 	brgt	80007c08 <_vfprintf_r+0x3c0>
80007be4:	f0 cb ff fc 	sub	r11,r8,-4
80007be8:	70 08       	ld.w	r8,r8[0x0]
80007bea:	51 0b       	stdsp	sp[0x40],r11
80007bec:	50 28       	stdsp	sp[0x8],r8
80007bee:	fa c6 f9 44 	sub	r6,sp,-1724
80007bf2:	40 2e       	lddsp	lr,sp[0x8]
80007bf4:	ec 0a 00 38 	add	r8,r6,r10<<0x3
80007bf8:	f1 4e fd 88 	st.w	r8[-632],lr
80007bfc:	2f fa       	sub	r10,-1
80007bfe:	0e 94       	mov	r4,r7
80007c00:	fb 4a 06 b4 	st.w	sp[1716],r10
80007c04:	12 96       	mov	r6,r9
80007c06:	c0 78       	rjmp	80007c14 <_vfprintf_r+0x3cc>
80007c08:	70 0c       	ld.w	r12,r8[0x0]
80007c0a:	0e 94       	mov	r4,r7
80007c0c:	2f c8       	sub	r8,-4
80007c0e:	50 2c       	stdsp	sp[0x8],r12
80007c10:	12 96       	mov	r6,r9
80007c12:	51 08       	stdsp	sp[0x40],r8
80007c14:	40 2b       	lddsp	r11,sp[0x8]
80007c16:	58 0b       	cp.w	r11,0
80007c18:	fe 95 fe f2 	brlt	800079fc <_vfprintf_r+0x1b4>
80007c1c:	08 97       	mov	r7,r4
80007c1e:	cf 5a       	rjmp	80007a08 <_vfprintf_r+0x1c0>
80007c20:	f2 09 00 29 	add	r9,r9,r9<<0x2
80007c24:	0f 38       	ld.ub	r8,r7++
80007c26:	f4 09 00 19 	add	r9,r10,r9<<0x1
80007c2a:	f0 ca 00 30 	sub	r10,r8,48
80007c2e:	58 9a       	cp.w	r10,9
80007c30:	fe 98 ff f8 	brls	80007c20 <_vfprintf_r+0x3d8>
80007c34:	3f fa       	mov	r10,-1
80007c36:	f2 0a 0c 49 	max	r9,r9,r10
80007c3a:	50 29       	stdsp	sp[0x8],r9
80007c3c:	ce 9a       	rjmp	80007a0e <_vfprintf_r+0x1c6>
80007c3e:	a7 b5       	sbr	r5,0x7
80007c40:	ce 4a       	rjmp	80007a08 <_vfprintf_r+0x1c0>
80007c42:	30 09       	mov	r9,0
80007c44:	23 08       	sub	r8,48
80007c46:	f2 09 00 29 	add	r9,r9,r9<<0x2
80007c4a:	f0 09 00 19 	add	r9,r8,r9<<0x1
80007c4e:	0f 38       	ld.ub	r8,r7++
80007c50:	f0 ca 00 30 	sub	r10,r8,48
80007c54:	58 9a       	cp.w	r10,9
80007c56:	fe 98 ff f7 	brls	80007c44 <_vfprintf_r+0x3fc>
80007c5a:	e0 48 00 24 	cp.w	r8,36
80007c5e:	fe 91 fe d7 	brne	80007a0c <_vfprintf_r+0x1c4>
80007c62:	e0 49 00 20 	cp.w	r9,32
80007c66:	e0 89 0d 6f 	brgt	80009744 <_vfprintf_r+0x1efc>
80007c6a:	f2 c3 00 01 	sub	r3,r9,1
80007c6e:	30 19       	mov	r9,1
80007c70:	50 39       	stdsp	sp[0xc],r9
80007c72:	cc ba       	rjmp	80007a08 <_vfprintf_r+0x1c0>
80007c74:	a3 b5       	sbr	r5,0x3
80007c76:	cc 9a       	rjmp	80007a08 <_vfprintf_r+0x1c0>
80007c78:	a7 a5       	sbr	r5,0x6
80007c7a:	cc 7a       	rjmp	80007a08 <_vfprintf_r+0x1c0>
80007c7c:	0a 98       	mov	r8,r5
80007c7e:	a5 b5       	sbr	r5,0x5
80007c80:	a5 a8       	sbr	r8,0x4
80007c82:	0f 89       	ld.ub	r9,r7[0x0]
80007c84:	36 ce       	mov	lr,108
80007c86:	fc 09 18 00 	cp.b	r9,lr
80007c8a:	f7 b7 00 ff 	subeq	r7,-1
80007c8e:	f0 05 17 10 	movne	r5,r8
80007c92:	cb ba       	rjmp	80007a08 <_vfprintf_r+0x1c0>
80007c94:	a5 b5       	sbr	r5,0x5
80007c96:	cb 9a       	rjmp	80007a08 <_vfprintf_r+0x1c0>
80007c98:	50 a7       	stdsp	sp[0x28],r7
80007c9a:	50 80       	stdsp	sp[0x20],r0
80007c9c:	0c 97       	mov	r7,r6
80007c9e:	10 90       	mov	r0,r8
80007ca0:	06 96       	mov	r6,r3
80007ca2:	04 94       	mov	r4,r2
80007ca4:	40 93       	lddsp	r3,sp[0x24]
80007ca6:	02 92       	mov	r2,r1
80007ca8:	0e 99       	mov	r9,r7
80007caa:	40 41       	lddsp	r1,sp[0x10]
80007cac:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007cb0:	40 3c       	lddsp	r12,sp[0xc]
80007cb2:	58 0c       	cp.w	r12,0
80007cb4:	c1 d0       	breq	80007cee <_vfprintf_r+0x4a6>
80007cb6:	10 36       	cp.w	r6,r8
80007cb8:	c0 64       	brge	80007cc4 <_vfprintf_r+0x47c>
80007cba:	fa cb f9 44 	sub	r11,sp,-1724
80007cbe:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007cc2:	c1 d8       	rjmp	80007cfc <_vfprintf_r+0x4b4>
80007cc4:	fa c8 f9 50 	sub	r8,sp,-1712
80007cc8:	1a d8       	st.w	--sp,r8
80007cca:	fa c8 fa b8 	sub	r8,sp,-1352
80007cce:	1a d8       	st.w	--sp,r8
80007cd0:	fa c8 fb b4 	sub	r8,sp,-1100
80007cd4:	1a d8       	st.w	--sp,r8
80007cd6:	fa c8 f9 40 	sub	r8,sp,-1728
80007cda:	fa c9 ff b4 	sub	r9,sp,-76
80007cde:	04 9a       	mov	r10,r2
80007ce0:	0c 9b       	mov	r11,r6
80007ce2:	08 9c       	mov	r12,r4
80007ce4:	fe b0 fc 1a 	rcall	80007518 <get_arg>
80007ce8:	2f dd       	sub	sp,-12
80007cea:	19 b8       	ld.ub	r8,r12[0x3]
80007cec:	c2 28       	rjmp	80007d30 <_vfprintf_r+0x4e8>
80007cee:	2f f7       	sub	r7,-1
80007cf0:	10 39       	cp.w	r9,r8
80007cf2:	c0 84       	brge	80007d02 <_vfprintf_r+0x4ba>
80007cf4:	fa ca f9 44 	sub	r10,sp,-1724
80007cf8:	f4 06 00 36 	add	r6,r10,r6<<0x3
80007cfc:	ed 38 fd 8b 	ld.ub	r8,r6[-629]
80007d00:	c1 88       	rjmp	80007d30 <_vfprintf_r+0x4e8>
80007d02:	41 09       	lddsp	r9,sp[0x40]
80007d04:	59 f8       	cp.w	r8,31
80007d06:	e0 89 00 12 	brgt	80007d2a <_vfprintf_r+0x4e2>
80007d0a:	f2 ca ff fc 	sub	r10,r9,-4
80007d0e:	51 0a       	stdsp	sp[0x40],r10
80007d10:	72 09       	ld.w	r9,r9[0x0]
80007d12:	fa c6 f9 44 	sub	r6,sp,-1724
80007d16:	ec 08 00 3a 	add	r10,r6,r8<<0x3
80007d1a:	2f f8       	sub	r8,-1
80007d1c:	f5 49 fd 88 	st.w	r10[-632],r9
80007d20:	fb 48 06 b4 	st.w	sp[1716],r8
80007d24:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
80007d28:	c0 48       	rjmp	80007d30 <_vfprintf_r+0x4e8>
80007d2a:	13 b8       	ld.ub	r8,r9[0x3]
80007d2c:	2f c9       	sub	r9,-4
80007d2e:	51 09       	stdsp	sp[0x40],r9
80007d30:	fb 68 06 60 	st.b	sp[1632],r8
80007d34:	30 0e       	mov	lr,0
80007d36:	30 08       	mov	r8,0
80007d38:	30 12       	mov	r2,1
80007d3a:	fb 68 06 bb 	st.b	sp[1723],r8
80007d3e:	50 2e       	stdsp	sp[0x8],lr
80007d40:	e0 8f 08 ad 	bral	80008e9a <_vfprintf_r+0x1652>
80007d44:	50 a7       	stdsp	sp[0x28],r7
80007d46:	50 80       	stdsp	sp[0x20],r0
80007d48:	0c 97       	mov	r7,r6
80007d4a:	04 94       	mov	r4,r2
80007d4c:	06 96       	mov	r6,r3
80007d4e:	02 92       	mov	r2,r1
80007d50:	40 93       	lddsp	r3,sp[0x24]
80007d52:	10 90       	mov	r0,r8
80007d54:	40 41       	lddsp	r1,sp[0x10]
80007d56:	a5 a5       	sbr	r5,0x4
80007d58:	c0 a8       	rjmp	80007d6c <_vfprintf_r+0x524>
80007d5a:	50 a7       	stdsp	sp[0x28],r7
80007d5c:	50 80       	stdsp	sp[0x20],r0
80007d5e:	0c 97       	mov	r7,r6
80007d60:	04 94       	mov	r4,r2
80007d62:	06 96       	mov	r6,r3
80007d64:	02 92       	mov	r2,r1
80007d66:	40 93       	lddsp	r3,sp[0x24]
80007d68:	10 90       	mov	r0,r8
80007d6a:	40 41       	lddsp	r1,sp[0x10]
80007d6c:	ed b5 00 05 	bld	r5,0x5
80007d70:	c5 11       	brne	80007e12 <_vfprintf_r+0x5ca>
80007d72:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007d76:	40 3c       	lddsp	r12,sp[0xc]
80007d78:	58 0c       	cp.w	r12,0
80007d7a:	c1 e0       	breq	80007db6 <_vfprintf_r+0x56e>
80007d7c:	10 36       	cp.w	r6,r8
80007d7e:	c0 64       	brge	80007d8a <_vfprintf_r+0x542>
80007d80:	fa cb f9 44 	sub	r11,sp,-1724
80007d84:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007d88:	c2 08       	rjmp	80007dc8 <_vfprintf_r+0x580>
80007d8a:	fa c8 f9 50 	sub	r8,sp,-1712
80007d8e:	1a d8       	st.w	--sp,r8
80007d90:	fa c8 fa b8 	sub	r8,sp,-1352
80007d94:	0c 9b       	mov	r11,r6
80007d96:	1a d8       	st.w	--sp,r8
80007d98:	fa c8 fb b4 	sub	r8,sp,-1100
80007d9c:	1a d8       	st.w	--sp,r8
80007d9e:	fa c9 ff b4 	sub	r9,sp,-76
80007da2:	fa c8 f9 40 	sub	r8,sp,-1728
80007da6:	04 9a       	mov	r10,r2
80007da8:	08 9c       	mov	r12,r4
80007daa:	fe b0 fb b7 	rcall	80007518 <get_arg>
80007dae:	2f dd       	sub	sp,-12
80007db0:	78 1b       	ld.w	r11,r12[0x4]
80007db2:	78 09       	ld.w	r9,r12[0x0]
80007db4:	c2 b8       	rjmp	80007e0a <_vfprintf_r+0x5c2>
80007db6:	ee ca ff ff 	sub	r10,r7,-1
80007dba:	10 37       	cp.w	r7,r8
80007dbc:	c0 b4       	brge	80007dd2 <_vfprintf_r+0x58a>
80007dbe:	fa c9 f9 44 	sub	r9,sp,-1724
80007dc2:	14 97       	mov	r7,r10
80007dc4:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007dc8:	ec fb fd 8c 	ld.w	r11,r6[-628]
80007dcc:	ec f9 fd 88 	ld.w	r9,r6[-632]
80007dd0:	c1 d8       	rjmp	80007e0a <_vfprintf_r+0x5c2>
80007dd2:	41 09       	lddsp	r9,sp[0x40]
80007dd4:	59 f8       	cp.w	r8,31
80007dd6:	e0 89 00 14 	brgt	80007dfe <_vfprintf_r+0x5b6>
80007dda:	f2 cb ff f8 	sub	r11,r9,-8
80007dde:	51 0b       	stdsp	sp[0x40],r11
80007de0:	fa c6 f9 44 	sub	r6,sp,-1724
80007de4:	72 1b       	ld.w	r11,r9[0x4]
80007de6:	ec 08 00 3c 	add	r12,r6,r8<<0x3
80007dea:	72 09       	ld.w	r9,r9[0x0]
80007dec:	f9 4b fd 8c 	st.w	r12[-628],r11
80007df0:	f9 49 fd 88 	st.w	r12[-632],r9
80007df4:	2f f8       	sub	r8,-1
80007df6:	14 97       	mov	r7,r10
80007df8:	fb 48 06 b4 	st.w	sp[1716],r8
80007dfc:	c0 78       	rjmp	80007e0a <_vfprintf_r+0x5c2>
80007dfe:	f2 c8 ff f8 	sub	r8,r9,-8
80007e02:	72 1b       	ld.w	r11,r9[0x4]
80007e04:	14 97       	mov	r7,r10
80007e06:	51 08       	stdsp	sp[0x40],r8
80007e08:	72 09       	ld.w	r9,r9[0x0]
80007e0a:	16 98       	mov	r8,r11
80007e0c:	fa e9 00 00 	st.d	sp[0],r8
80007e10:	ca e8       	rjmp	80007f6c <_vfprintf_r+0x724>
80007e12:	ed b5 00 04 	bld	r5,0x4
80007e16:	c1 71       	brne	80007e44 <_vfprintf_r+0x5fc>
80007e18:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007e1c:	40 3e       	lddsp	lr,sp[0xc]
80007e1e:	58 0e       	cp.w	lr,0
80007e20:	c0 80       	breq	80007e30 <_vfprintf_r+0x5e8>
80007e22:	10 36       	cp.w	r6,r8
80007e24:	c6 94       	brge	80007ef6 <_vfprintf_r+0x6ae>
80007e26:	fa cc f9 44 	sub	r12,sp,-1724
80007e2a:	f8 06 00 36 	add	r6,r12,r6<<0x3
80007e2e:	c8 28       	rjmp	80007f32 <_vfprintf_r+0x6ea>
80007e30:	ee ca ff ff 	sub	r10,r7,-1
80007e34:	10 37       	cp.w	r7,r8
80007e36:	e0 84 00 81 	brge	80007f38 <_vfprintf_r+0x6f0>
80007e3a:	fa cb f9 44 	sub	r11,sp,-1724
80007e3e:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007e42:	c7 78       	rjmp	80007f30 <_vfprintf_r+0x6e8>
80007e44:	ed b5 00 06 	bld	r5,0x6
80007e48:	c4 b1       	brne	80007ede <_vfprintf_r+0x696>
80007e4a:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007e4e:	40 3c       	lddsp	r12,sp[0xc]
80007e50:	58 0c       	cp.w	r12,0
80007e52:	c1 d0       	breq	80007e8c <_vfprintf_r+0x644>
80007e54:	10 36       	cp.w	r6,r8
80007e56:	c0 64       	brge	80007e62 <_vfprintf_r+0x61a>
80007e58:	fa cb f9 44 	sub	r11,sp,-1724
80007e5c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007e60:	c1 f8       	rjmp	80007e9e <_vfprintf_r+0x656>
80007e62:	fa c8 f9 50 	sub	r8,sp,-1712
80007e66:	1a d8       	st.w	--sp,r8
80007e68:	fa c8 fa b8 	sub	r8,sp,-1352
80007e6c:	1a d8       	st.w	--sp,r8
80007e6e:	fa c8 fb b4 	sub	r8,sp,-1100
80007e72:	1a d8       	st.w	--sp,r8
80007e74:	fa c8 f9 40 	sub	r8,sp,-1728
80007e78:	fa c9 ff b4 	sub	r9,sp,-76
80007e7c:	04 9a       	mov	r10,r2
80007e7e:	0c 9b       	mov	r11,r6
80007e80:	08 9c       	mov	r12,r4
80007e82:	fe b0 fb 4b 	rcall	80007518 <get_arg>
80007e86:	2f dd       	sub	sp,-12
80007e88:	98 18       	ld.sh	r8,r12[0x2]
80007e8a:	c2 68       	rjmp	80007ed6 <_vfprintf_r+0x68e>
80007e8c:	ee ca ff ff 	sub	r10,r7,-1
80007e90:	10 37       	cp.w	r7,r8
80007e92:	c0 94       	brge	80007ea4 <_vfprintf_r+0x65c>
80007e94:	fa c9 f9 44 	sub	r9,sp,-1724
80007e98:	14 97       	mov	r7,r10
80007e9a:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007e9e:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80007ea2:	c1 a8       	rjmp	80007ed6 <_vfprintf_r+0x68e>
80007ea4:	41 09       	lddsp	r9,sp[0x40]
80007ea6:	59 f8       	cp.w	r8,31
80007ea8:	e0 89 00 13 	brgt	80007ece <_vfprintf_r+0x686>
80007eac:	f2 cb ff fc 	sub	r11,r9,-4
80007eb0:	51 0b       	stdsp	sp[0x40],r11
80007eb2:	72 09       	ld.w	r9,r9[0x0]
80007eb4:	fa c6 f9 44 	sub	r6,sp,-1724
80007eb8:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80007ebc:	2f f8       	sub	r8,-1
80007ebe:	f7 49 fd 88 	st.w	r11[-632],r9
80007ec2:	fb 48 06 b4 	st.w	sp[1716],r8
80007ec6:	14 97       	mov	r7,r10
80007ec8:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80007ecc:	c0 58       	rjmp	80007ed6 <_vfprintf_r+0x68e>
80007ece:	92 18       	ld.sh	r8,r9[0x2]
80007ed0:	14 97       	mov	r7,r10
80007ed2:	2f c9       	sub	r9,-4
80007ed4:	51 09       	stdsp	sp[0x40],r9
80007ed6:	50 18       	stdsp	sp[0x4],r8
80007ed8:	bf 58       	asr	r8,0x1f
80007eda:	50 08       	stdsp	sp[0x0],r8
80007edc:	c4 88       	rjmp	80007f6c <_vfprintf_r+0x724>
80007ede:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007ee2:	40 3c       	lddsp	r12,sp[0xc]
80007ee4:	58 0c       	cp.w	r12,0
80007ee6:	c1 d0       	breq	80007f20 <_vfprintf_r+0x6d8>
80007ee8:	10 36       	cp.w	r6,r8
80007eea:	c0 64       	brge	80007ef6 <_vfprintf_r+0x6ae>
80007eec:	fa cb f9 44 	sub	r11,sp,-1724
80007ef0:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007ef4:	c1 f8       	rjmp	80007f32 <_vfprintf_r+0x6ea>
80007ef6:	fa c8 f9 50 	sub	r8,sp,-1712
80007efa:	1a d8       	st.w	--sp,r8
80007efc:	fa c8 fa b8 	sub	r8,sp,-1352
80007f00:	0c 9b       	mov	r11,r6
80007f02:	1a d8       	st.w	--sp,r8
80007f04:	fa c8 fb b4 	sub	r8,sp,-1100
80007f08:	04 9a       	mov	r10,r2
80007f0a:	1a d8       	st.w	--sp,r8
80007f0c:	08 9c       	mov	r12,r4
80007f0e:	fa c8 f9 40 	sub	r8,sp,-1728
80007f12:	fa c9 ff b4 	sub	r9,sp,-76
80007f16:	fe b0 fb 01 	rcall	80007518 <get_arg>
80007f1a:	2f dd       	sub	sp,-12
80007f1c:	78 0b       	ld.w	r11,r12[0x0]
80007f1e:	c2 48       	rjmp	80007f66 <_vfprintf_r+0x71e>
80007f20:	ee ca ff ff 	sub	r10,r7,-1
80007f24:	10 37       	cp.w	r7,r8
80007f26:	c0 94       	brge	80007f38 <_vfprintf_r+0x6f0>
80007f28:	fa c9 f9 44 	sub	r9,sp,-1724
80007f2c:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007f30:	14 97       	mov	r7,r10
80007f32:	ec fb fd 88 	ld.w	r11,r6[-632]
80007f36:	c1 88       	rjmp	80007f66 <_vfprintf_r+0x71e>
80007f38:	41 09       	lddsp	r9,sp[0x40]
80007f3a:	59 f8       	cp.w	r8,31
80007f3c:	e0 89 00 11 	brgt	80007f5e <_vfprintf_r+0x716>
80007f40:	f2 cb ff fc 	sub	r11,r9,-4
80007f44:	51 0b       	stdsp	sp[0x40],r11
80007f46:	fa c6 f9 44 	sub	r6,sp,-1724
80007f4a:	72 0b       	ld.w	r11,r9[0x0]
80007f4c:	ec 08 00 39 	add	r9,r6,r8<<0x3
80007f50:	f3 4b fd 88 	st.w	r9[-632],r11
80007f54:	2f f8       	sub	r8,-1
80007f56:	14 97       	mov	r7,r10
80007f58:	fb 48 06 b4 	st.w	sp[1716],r8
80007f5c:	c0 58       	rjmp	80007f66 <_vfprintf_r+0x71e>
80007f5e:	72 0b       	ld.w	r11,r9[0x0]
80007f60:	14 97       	mov	r7,r10
80007f62:	2f c9       	sub	r9,-4
80007f64:	51 09       	stdsp	sp[0x40],r9
80007f66:	50 1b       	stdsp	sp[0x4],r11
80007f68:	bf 5b       	asr	r11,0x1f
80007f6a:	50 0b       	stdsp	sp[0x0],r11
80007f6c:	fa ea 00 00 	ld.d	r10,sp[0]
80007f70:	58 0a       	cp.w	r10,0
80007f72:	5c 2b       	cpc	r11
80007f74:	c0 e4       	brge	80007f90 <_vfprintf_r+0x748>
80007f76:	30 08       	mov	r8,0
80007f78:	fa ea 00 00 	ld.d	r10,sp[0]
80007f7c:	30 09       	mov	r9,0
80007f7e:	f0 0a 01 0a 	sub	r10,r8,r10
80007f82:	f2 0b 01 4b 	sbc	r11,r9,r11
80007f86:	32 d8       	mov	r8,45
80007f88:	fa eb 00 00 	st.d	sp[0],r10
80007f8c:	fb 68 06 bb 	st.b	sp[1723],r8
80007f90:	30 18       	mov	r8,1
80007f92:	e0 8f 06 fa 	bral	80008d86 <_vfprintf_r+0x153e>
80007f96:	50 a7       	stdsp	sp[0x28],r7
80007f98:	50 80       	stdsp	sp[0x20],r0
80007f9a:	0c 97       	mov	r7,r6
80007f9c:	04 94       	mov	r4,r2
80007f9e:	06 96       	mov	r6,r3
80007fa0:	02 92       	mov	r2,r1
80007fa2:	40 93       	lddsp	r3,sp[0x24]
80007fa4:	10 90       	mov	r0,r8
80007fa6:	40 41       	lddsp	r1,sp[0x10]
80007fa8:	0e 99       	mov	r9,r7
80007faa:	ed b5 00 03 	bld	r5,0x3
80007fae:	c4 11       	brne	80008030 <_vfprintf_r+0x7e8>
80007fb0:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007fb4:	40 3a       	lddsp	r10,sp[0xc]
80007fb6:	58 0a       	cp.w	r10,0
80007fb8:	c1 90       	breq	80007fea <_vfprintf_r+0x7a2>
80007fba:	10 36       	cp.w	r6,r8
80007fbc:	c6 45       	brlt	80008084 <_vfprintf_r+0x83c>
80007fbe:	fa c8 f9 50 	sub	r8,sp,-1712
80007fc2:	1a d8       	st.w	--sp,r8
80007fc4:	fa c8 fa b8 	sub	r8,sp,-1352
80007fc8:	1a d8       	st.w	--sp,r8
80007fca:	fa c8 fb b4 	sub	r8,sp,-1100
80007fce:	0c 9b       	mov	r11,r6
80007fd0:	1a d8       	st.w	--sp,r8
80007fd2:	04 9a       	mov	r10,r2
80007fd4:	fa c8 f9 40 	sub	r8,sp,-1728
80007fd8:	fa c9 ff b4 	sub	r9,sp,-76
80007fdc:	08 9c       	mov	r12,r4
80007fde:	fe b0 fa 9d 	rcall	80007518 <get_arg>
80007fe2:	2f dd       	sub	sp,-12
80007fe4:	78 16       	ld.w	r6,r12[0x4]
80007fe6:	50 76       	stdsp	sp[0x1c],r6
80007fe8:	c4 88       	rjmp	80008078 <_vfprintf_r+0x830>
80007fea:	2f f7       	sub	r7,-1
80007fec:	10 39       	cp.w	r9,r8
80007fee:	c0 c4       	brge	80008006 <_vfprintf_r+0x7be>
80007ff0:	fa ce f9 44 	sub	lr,sp,-1724
80007ff4:	fc 06 00 36 	add	r6,lr,r6<<0x3
80007ff8:	ec fc fd 8c 	ld.w	r12,r6[-628]
80007ffc:	50 7c       	stdsp	sp[0x1c],r12
80007ffe:	ec f6 fd 88 	ld.w	r6,r6[-632]
80008002:	50 56       	stdsp	sp[0x14],r6
80008004:	c6 68       	rjmp	800080d0 <_vfprintf_r+0x888>
80008006:	41 09       	lddsp	r9,sp[0x40]
80008008:	59 f8       	cp.w	r8,31
8000800a:	e0 89 00 10 	brgt	8000802a <_vfprintf_r+0x7e2>
8000800e:	f2 ca ff f8 	sub	r10,r9,-8
80008012:	72 1b       	ld.w	r11,r9[0x4]
80008014:	51 0a       	stdsp	sp[0x40],r10
80008016:	72 09       	ld.w	r9,r9[0x0]
80008018:	fa ca f9 44 	sub	r10,sp,-1724
8000801c:	50 7b       	stdsp	sp[0x1c],r11
8000801e:	50 59       	stdsp	sp[0x14],r9
80008020:	f4 08 00 39 	add	r9,r10,r8<<0x3
80008024:	40 5b       	lddsp	r11,sp[0x14]
80008026:	40 7a       	lddsp	r10,sp[0x1c]
80008028:	c4 78       	rjmp	800080b6 <_vfprintf_r+0x86e>
8000802a:	72 18       	ld.w	r8,r9[0x4]
8000802c:	50 78       	stdsp	sp[0x1c],r8
8000802e:	c4 c8       	rjmp	800080c6 <_vfprintf_r+0x87e>
80008030:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008034:	40 3e       	lddsp	lr,sp[0xc]
80008036:	58 0e       	cp.w	lr,0
80008038:	c2 30       	breq	8000807e <_vfprintf_r+0x836>
8000803a:	10 36       	cp.w	r6,r8
8000803c:	c0 94       	brge	8000804e <_vfprintf_r+0x806>
8000803e:	fa cc f9 44 	sub	r12,sp,-1724
80008042:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008046:	ec fb fd 8c 	ld.w	r11,r6[-628]
8000804a:	50 7b       	stdsp	sp[0x1c],r11
8000804c:	cd 9b       	rjmp	80007ffe <_vfprintf_r+0x7b6>
8000804e:	fa c8 f9 50 	sub	r8,sp,-1712
80008052:	1a d8       	st.w	--sp,r8
80008054:	fa c8 fa b8 	sub	r8,sp,-1352
80008058:	04 9a       	mov	r10,r2
8000805a:	1a d8       	st.w	--sp,r8
8000805c:	fa c8 fb b4 	sub	r8,sp,-1100
80008060:	0c 9b       	mov	r11,r6
80008062:	1a d8       	st.w	--sp,r8
80008064:	08 9c       	mov	r12,r4
80008066:	fa c8 f9 40 	sub	r8,sp,-1728
8000806a:	fa c9 ff b4 	sub	r9,sp,-76
8000806e:	fe b0 fa 55 	rcall	80007518 <get_arg>
80008072:	2f dd       	sub	sp,-12
80008074:	78 1a       	ld.w	r10,r12[0x4]
80008076:	50 7a       	stdsp	sp[0x1c],r10
80008078:	78 0c       	ld.w	r12,r12[0x0]
8000807a:	50 5c       	stdsp	sp[0x14],r12
8000807c:	c2 a8       	rjmp	800080d0 <_vfprintf_r+0x888>
8000807e:	2f f7       	sub	r7,-1
80008080:	10 39       	cp.w	r9,r8
80008082:	c0 94       	brge	80008094 <_vfprintf_r+0x84c>
80008084:	fa c9 f9 44 	sub	r9,sp,-1724
80008088:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000808c:	ec f8 fd 8c 	ld.w	r8,r6[-628]
80008090:	50 78       	stdsp	sp[0x1c],r8
80008092:	cb 6b       	rjmp	80007ffe <_vfprintf_r+0x7b6>
80008094:	41 09       	lddsp	r9,sp[0x40]
80008096:	59 f8       	cp.w	r8,31
80008098:	e0 89 00 15 	brgt	800080c2 <_vfprintf_r+0x87a>
8000809c:	f2 ca ff f8 	sub	r10,r9,-8
800080a0:	72 16       	ld.w	r6,r9[0x4]
800080a2:	72 09       	ld.w	r9,r9[0x0]
800080a4:	51 0a       	stdsp	sp[0x40],r10
800080a6:	50 59       	stdsp	sp[0x14],r9
800080a8:	fa ce f9 44 	sub	lr,sp,-1724
800080ac:	50 76       	stdsp	sp[0x1c],r6
800080ae:	fc 08 00 39 	add	r9,lr,r8<<0x3
800080b2:	40 5b       	lddsp	r11,sp[0x14]
800080b4:	0c 9a       	mov	r10,r6
800080b6:	f2 eb fd 88 	st.d	r9[-632],r10
800080ba:	2f f8       	sub	r8,-1
800080bc:	fb 48 06 b4 	st.w	sp[1716],r8
800080c0:	c0 88       	rjmp	800080d0 <_vfprintf_r+0x888>
800080c2:	72 1c       	ld.w	r12,r9[0x4]
800080c4:	50 7c       	stdsp	sp[0x1c],r12
800080c6:	f2 c8 ff f8 	sub	r8,r9,-8
800080ca:	51 08       	stdsp	sp[0x40],r8
800080cc:	72 09       	ld.w	r9,r9[0x0]
800080ce:	50 59       	stdsp	sp[0x14],r9
800080d0:	40 5b       	lddsp	r11,sp[0x14]
800080d2:	40 7a       	lddsp	r10,sp[0x1c]
800080d4:	e0 a0 19 54 	rcall	8000b37c <__isinfd>
800080d8:	18 96       	mov	r6,r12
800080da:	c1 70       	breq	80008108 <_vfprintf_r+0x8c0>
800080dc:	30 08       	mov	r8,0
800080de:	30 09       	mov	r9,0
800080e0:	40 5b       	lddsp	r11,sp[0x14]
800080e2:	40 7a       	lddsp	r10,sp[0x1c]
800080e4:	e0 a0 1d b4 	rcall	8000bc4c <__avr32_f64_cmp_lt>
800080e8:	c0 40       	breq	800080f0 <_vfprintf_r+0x8a8>
800080ea:	32 d8       	mov	r8,45
800080ec:	fb 68 06 bb 	st.b	sp[1723],r8
800080f0:	fe c8 aa 7c 	sub	r8,pc,-21892
800080f4:	fe c6 aa 7c 	sub	r6,pc,-21892
800080f8:	a7 d5       	cbr	r5,0x7
800080fa:	e0 40 00 47 	cp.w	r0,71
800080fe:	f0 06 17 a0 	movle	r6,r8
80008102:	30 32       	mov	r2,3
80008104:	e0 8f 06 ce 	bral	80008ea0 <_vfprintf_r+0x1658>
80008108:	40 5b       	lddsp	r11,sp[0x14]
8000810a:	40 7a       	lddsp	r10,sp[0x1c]
8000810c:	e0 a0 19 4d 	rcall	8000b3a6 <__isnand>
80008110:	c0 e0       	breq	8000812c <_vfprintf_r+0x8e4>
80008112:	50 26       	stdsp	sp[0x8],r6
80008114:	fe c8 aa 98 	sub	r8,pc,-21864
80008118:	fe c6 aa 98 	sub	r6,pc,-21864
8000811c:	a7 d5       	cbr	r5,0x7
8000811e:	e0 40 00 47 	cp.w	r0,71
80008122:	f0 06 17 a0 	movle	r6,r8
80008126:	30 32       	mov	r2,3
80008128:	e0 8f 06 c2 	bral	80008eac <_vfprintf_r+0x1664>
8000812c:	40 2a       	lddsp	r10,sp[0x8]
8000812e:	5b fa       	cp.w	r10,-1
80008130:	c0 41       	brne	80008138 <_vfprintf_r+0x8f0>
80008132:	30 69       	mov	r9,6
80008134:	50 29       	stdsp	sp[0x8],r9
80008136:	c1 18       	rjmp	80008158 <_vfprintf_r+0x910>
80008138:	e0 40 00 47 	cp.w	r0,71
8000813c:	5f 09       	sreq	r9
8000813e:	e0 40 00 67 	cp.w	r0,103
80008142:	5f 08       	sreq	r8
80008144:	f3 e8 10 08 	or	r8,r9,r8
80008148:	f8 08 18 00 	cp.b	r8,r12
8000814c:	c0 60       	breq	80008158 <_vfprintf_r+0x910>
8000814e:	40 28       	lddsp	r8,sp[0x8]
80008150:	58 08       	cp.w	r8,0
80008152:	f9 b8 00 01 	moveq	r8,1
80008156:	50 28       	stdsp	sp[0x8],r8
80008158:	40 78       	lddsp	r8,sp[0x1c]
8000815a:	40 59       	lddsp	r9,sp[0x14]
8000815c:	fa e9 06 94 	st.d	sp[1684],r8
80008160:	a9 a5       	sbr	r5,0x8
80008162:	fa f8 06 94 	ld.w	r8,sp[1684]
80008166:	58 08       	cp.w	r8,0
80008168:	c0 65       	brlt	80008174 <_vfprintf_r+0x92c>
8000816a:	40 5e       	lddsp	lr,sp[0x14]
8000816c:	30 0c       	mov	r12,0
8000816e:	50 6e       	stdsp	sp[0x18],lr
80008170:	50 9c       	stdsp	sp[0x24],r12
80008172:	c0 78       	rjmp	80008180 <_vfprintf_r+0x938>
80008174:	40 5b       	lddsp	r11,sp[0x14]
80008176:	32 da       	mov	r10,45
80008178:	ee 1b 80 00 	eorh	r11,0x8000
8000817c:	50 9a       	stdsp	sp[0x24],r10
8000817e:	50 6b       	stdsp	sp[0x18],r11
80008180:	e0 40 00 46 	cp.w	r0,70
80008184:	5f 09       	sreq	r9
80008186:	e0 40 00 66 	cp.w	r0,102
8000818a:	5f 08       	sreq	r8
8000818c:	f3 e8 10 08 	or	r8,r9,r8
80008190:	50 48       	stdsp	sp[0x10],r8
80008192:	c0 40       	breq	8000819a <_vfprintf_r+0x952>
80008194:	40 22       	lddsp	r2,sp[0x8]
80008196:	30 39       	mov	r9,3
80008198:	c1 08       	rjmp	800081b8 <_vfprintf_r+0x970>
8000819a:	e0 40 00 45 	cp.w	r0,69
8000819e:	5f 09       	sreq	r9
800081a0:	e0 40 00 65 	cp.w	r0,101
800081a4:	5f 08       	sreq	r8
800081a6:	40 22       	lddsp	r2,sp[0x8]
800081a8:	10 49       	or	r9,r8
800081aa:	2f f2       	sub	r2,-1
800081ac:	40 46       	lddsp	r6,sp[0x10]
800081ae:	ec 09 18 00 	cp.b	r9,r6
800081b2:	fb f2 00 02 	ld.weq	r2,sp[0x8]
800081b6:	30 29       	mov	r9,2
800081b8:	fa c8 f9 5c 	sub	r8,sp,-1700
800081bc:	1a d8       	st.w	--sp,r8
800081be:	fa c8 f9 54 	sub	r8,sp,-1708
800081c2:	1a d8       	st.w	--sp,r8
800081c4:	fa c8 f9 4c 	sub	r8,sp,-1716
800081c8:	08 9c       	mov	r12,r4
800081ca:	1a d8       	st.w	--sp,r8
800081cc:	04 98       	mov	r8,r2
800081ce:	40 9b       	lddsp	r11,sp[0x24]
800081d0:	40 aa       	lddsp	r10,sp[0x28]
800081d2:	e0 a0 0b c3 	rcall	80009958 <_dtoa_r>
800081d6:	e0 40 00 47 	cp.w	r0,71
800081da:	5f 19       	srne	r9
800081dc:	e0 40 00 67 	cp.w	r0,103
800081e0:	5f 18       	srne	r8
800081e2:	18 96       	mov	r6,r12
800081e4:	2f dd       	sub	sp,-12
800081e6:	f3 e8 00 08 	and	r8,r9,r8
800081ea:	c0 41       	brne	800081f2 <_vfprintf_r+0x9aa>
800081ec:	ed b5 00 00 	bld	r5,0x0
800081f0:	c3 01       	brne	80008250 <_vfprintf_r+0xa08>
800081f2:	ec 02 00 0e 	add	lr,r6,r2
800081f6:	50 3e       	stdsp	sp[0xc],lr
800081f8:	40 4c       	lddsp	r12,sp[0x10]
800081fa:	58 0c       	cp.w	r12,0
800081fc:	c1 50       	breq	80008226 <_vfprintf_r+0x9de>
800081fe:	0d 89       	ld.ub	r9,r6[0x0]
80008200:	33 08       	mov	r8,48
80008202:	f0 09 18 00 	cp.b	r9,r8
80008206:	c0 b1       	brne	8000821c <_vfprintf_r+0x9d4>
80008208:	30 08       	mov	r8,0
8000820a:	30 09       	mov	r9,0
8000820c:	40 6b       	lddsp	r11,sp[0x18]
8000820e:	40 7a       	lddsp	r10,sp[0x1c]
80008210:	e0 a0 1c d7 	rcall	8000bbbe <__avr32_f64_cmp_eq>
80008214:	fb b2 00 01 	rsubeq	r2,1
80008218:	fb f2 0b ab 	st.weq	sp[0x6ac],r2
8000821c:	40 3b       	lddsp	r11,sp[0xc]
8000821e:	fa f8 06 ac 	ld.w	r8,sp[1708]
80008222:	10 0b       	add	r11,r8
80008224:	50 3b       	stdsp	sp[0xc],r11
80008226:	40 6b       	lddsp	r11,sp[0x18]
80008228:	30 08       	mov	r8,0
8000822a:	30 09       	mov	r9,0
8000822c:	40 7a       	lddsp	r10,sp[0x1c]
8000822e:	e0 a0 1c c8 	rcall	8000bbbe <__avr32_f64_cmp_eq>
80008232:	c0 90       	breq	80008244 <_vfprintf_r+0x9fc>
80008234:	40 3a       	lddsp	r10,sp[0xc]
80008236:	fb 4a 06 a4 	st.w	sp[1700],r10
8000823a:	c0 58       	rjmp	80008244 <_vfprintf_r+0x9fc>
8000823c:	10 c9       	st.b	r8++,r9
8000823e:	fb 48 06 a4 	st.w	sp[1700],r8
80008242:	c0 28       	rjmp	80008246 <_vfprintf_r+0x9fe>
80008244:	33 09       	mov	r9,48
80008246:	fa f8 06 a4 	ld.w	r8,sp[1700]
8000824a:	40 3e       	lddsp	lr,sp[0xc]
8000824c:	1c 38       	cp.w	r8,lr
8000824e:	cf 73       	brcs	8000823c <_vfprintf_r+0x9f4>
80008250:	e0 40 00 47 	cp.w	r0,71
80008254:	5f 09       	sreq	r9
80008256:	e0 40 00 67 	cp.w	r0,103
8000825a:	5f 08       	sreq	r8
8000825c:	f3 e8 10 08 	or	r8,r9,r8
80008260:	fa f9 06 a4 	ld.w	r9,sp[1700]
80008264:	0c 19       	sub	r9,r6
80008266:	50 69       	stdsp	sp[0x18],r9
80008268:	58 08       	cp.w	r8,0
8000826a:	c0 b0       	breq	80008280 <_vfprintf_r+0xa38>
8000826c:	fa f8 06 ac 	ld.w	r8,sp[1708]
80008270:	5b d8       	cp.w	r8,-3
80008272:	c0 55       	brlt	8000827c <_vfprintf_r+0xa34>
80008274:	40 2c       	lddsp	r12,sp[0x8]
80008276:	18 38       	cp.w	r8,r12
80008278:	e0 8a 00 6a 	brle	8000834c <_vfprintf_r+0xb04>
8000827c:	20 20       	sub	r0,2
8000827e:	c0 58       	rjmp	80008288 <_vfprintf_r+0xa40>
80008280:	e0 40 00 65 	cp.w	r0,101
80008284:	e0 89 00 46 	brgt	80008310 <_vfprintf_r+0xac8>
80008288:	fa fb 06 ac 	ld.w	r11,sp[1708]
8000828c:	fb 60 06 9c 	st.b	sp[1692],r0
80008290:	20 1b       	sub	r11,1
80008292:	fb 4b 06 ac 	st.w	sp[1708],r11
80008296:	c0 47       	brpl	8000829e <_vfprintf_r+0xa56>
80008298:	5c 3b       	neg	r11
8000829a:	32 d8       	mov	r8,45
8000829c:	c0 28       	rjmp	800082a0 <_vfprintf_r+0xa58>
8000829e:	32 b8       	mov	r8,43
800082a0:	fb 68 06 9d 	st.b	sp[1693],r8
800082a4:	58 9b       	cp.w	r11,9
800082a6:	e0 8a 00 1d 	brle	800082e0 <_vfprintf_r+0xa98>
800082aa:	fa c9 fa 35 	sub	r9,sp,-1483
800082ae:	30 aa       	mov	r10,10
800082b0:	12 98       	mov	r8,r9
800082b2:	0e 9c       	mov	r12,r7
800082b4:	0c 92       	mov	r2,r6
800082b6:	f6 0a 0c 06 	divs	r6,r11,r10
800082ba:	0e 9b       	mov	r11,r7
800082bc:	2d 0b       	sub	r11,-48
800082be:	10 fb       	st.b	--r8,r11
800082c0:	0c 9b       	mov	r11,r6
800082c2:	58 96       	cp.w	r6,9
800082c4:	fe 99 ff f9 	brgt	800082b6 <_vfprintf_r+0xa6e>
800082c8:	2d 0b       	sub	r11,-48
800082ca:	18 97       	mov	r7,r12
800082cc:	04 96       	mov	r6,r2
800082ce:	10 fb       	st.b	--r8,r11
800082d0:	fa ca f9 62 	sub	r10,sp,-1694
800082d4:	c0 38       	rjmp	800082da <_vfprintf_r+0xa92>
800082d6:	11 3b       	ld.ub	r11,r8++
800082d8:	14 cb       	st.b	r10++,r11
800082da:	12 38       	cp.w	r8,r9
800082dc:	cf d3       	brcs	800082d6 <_vfprintf_r+0xa8e>
800082de:	c0 98       	rjmp	800082f0 <_vfprintf_r+0xaa8>
800082e0:	2d 0b       	sub	r11,-48
800082e2:	33 08       	mov	r8,48
800082e4:	fb 6b 06 9f 	st.b	sp[1695],r11
800082e8:	fb 68 06 9e 	st.b	sp[1694],r8
800082ec:	fa ca f9 60 	sub	r10,sp,-1696
800082f0:	fa c8 f9 64 	sub	r8,sp,-1692
800082f4:	f4 08 01 08 	sub	r8,r10,r8
800082f8:	50 e8       	stdsp	sp[0x38],r8
800082fa:	10 92       	mov	r2,r8
800082fc:	40 6b       	lddsp	r11,sp[0x18]
800082fe:	16 02       	add	r2,r11
80008300:	58 1b       	cp.w	r11,1
80008302:	e0 89 00 05 	brgt	8000830c <_vfprintf_r+0xac4>
80008306:	ed b5 00 00 	bld	r5,0x0
8000830a:	c3 51       	brne	80008374 <_vfprintf_r+0xb2c>
8000830c:	2f f2       	sub	r2,-1
8000830e:	c3 38       	rjmp	80008374 <_vfprintf_r+0xb2c>
80008310:	e0 40 00 66 	cp.w	r0,102
80008314:	c1 c1       	brne	8000834c <_vfprintf_r+0xb04>
80008316:	fa f2 06 ac 	ld.w	r2,sp[1708]
8000831a:	58 02       	cp.w	r2,0
8000831c:	e0 8a 00 0c 	brle	80008334 <_vfprintf_r+0xaec>
80008320:	40 2a       	lddsp	r10,sp[0x8]
80008322:	58 0a       	cp.w	r10,0
80008324:	c0 41       	brne	8000832c <_vfprintf_r+0xae4>
80008326:	ed b5 00 00 	bld	r5,0x0
8000832a:	c2 51       	brne	80008374 <_vfprintf_r+0xb2c>
8000832c:	2f f2       	sub	r2,-1
8000832e:	40 29       	lddsp	r9,sp[0x8]
80008330:	12 02       	add	r2,r9
80008332:	c0 b8       	rjmp	80008348 <_vfprintf_r+0xb00>
80008334:	40 28       	lddsp	r8,sp[0x8]
80008336:	58 08       	cp.w	r8,0
80008338:	c0 61       	brne	80008344 <_vfprintf_r+0xafc>
8000833a:	ed b5 00 00 	bld	r5,0x0
8000833e:	c0 30       	breq	80008344 <_vfprintf_r+0xafc>
80008340:	30 12       	mov	r2,1
80008342:	c1 98       	rjmp	80008374 <_vfprintf_r+0xb2c>
80008344:	40 22       	lddsp	r2,sp[0x8]
80008346:	2f e2       	sub	r2,-2
80008348:	36 60       	mov	r0,102
8000834a:	c1 58       	rjmp	80008374 <_vfprintf_r+0xb2c>
8000834c:	fa f2 06 ac 	ld.w	r2,sp[1708]
80008350:	40 6e       	lddsp	lr,sp[0x18]
80008352:	1c 32       	cp.w	r2,lr
80008354:	c0 65       	brlt	80008360 <_vfprintf_r+0xb18>
80008356:	ed b5 00 00 	bld	r5,0x0
8000835a:	f7 b2 00 ff 	subeq	r2,-1
8000835e:	c0 a8       	rjmp	80008372 <_vfprintf_r+0xb2a>
80008360:	e4 08 11 02 	rsub	r8,r2,2
80008364:	40 6c       	lddsp	r12,sp[0x18]
80008366:	58 02       	cp.w	r2,0
80008368:	f0 02 17 a0 	movle	r2,r8
8000836c:	f9 b2 09 01 	movgt	r2,1
80008370:	18 02       	add	r2,r12
80008372:	36 70       	mov	r0,103
80008374:	40 9b       	lddsp	r11,sp[0x24]
80008376:	58 0b       	cp.w	r11,0
80008378:	e0 80 05 94 	breq	80008ea0 <_vfprintf_r+0x1658>
8000837c:	32 d8       	mov	r8,45
8000837e:	fb 68 06 bb 	st.b	sp[1723],r8
80008382:	e0 8f 05 93 	bral	80008ea8 <_vfprintf_r+0x1660>
80008386:	50 a7       	stdsp	sp[0x28],r7
80008388:	04 94       	mov	r4,r2
8000838a:	0c 97       	mov	r7,r6
8000838c:	02 92       	mov	r2,r1
8000838e:	06 96       	mov	r6,r3
80008390:	40 41       	lddsp	r1,sp[0x10]
80008392:	40 93       	lddsp	r3,sp[0x24]
80008394:	0e 99       	mov	r9,r7
80008396:	ed b5 00 05 	bld	r5,0x5
8000839a:	c4 81       	brne	8000842a <_vfprintf_r+0xbe2>
8000839c:	fa f8 06 b4 	ld.w	r8,sp[1716]
800083a0:	40 3e       	lddsp	lr,sp[0xc]
800083a2:	58 0e       	cp.w	lr,0
800083a4:	c1 d0       	breq	800083de <_vfprintf_r+0xb96>
800083a6:	10 36       	cp.w	r6,r8
800083a8:	c0 64       	brge	800083b4 <_vfprintf_r+0xb6c>
800083aa:	fa cc f9 44 	sub	r12,sp,-1724
800083ae:	f8 06 00 36 	add	r6,r12,r6<<0x3
800083b2:	c1 d8       	rjmp	800083ec <_vfprintf_r+0xba4>
800083b4:	fa c8 f9 50 	sub	r8,sp,-1712
800083b8:	1a d8       	st.w	--sp,r8
800083ba:	fa c8 fa b8 	sub	r8,sp,-1352
800083be:	04 9a       	mov	r10,r2
800083c0:	1a d8       	st.w	--sp,r8
800083c2:	fa c8 fb b4 	sub	r8,sp,-1100
800083c6:	0c 9b       	mov	r11,r6
800083c8:	1a d8       	st.w	--sp,r8
800083ca:	08 9c       	mov	r12,r4
800083cc:	fa c8 f9 40 	sub	r8,sp,-1728
800083d0:	fa c9 ff b4 	sub	r9,sp,-76
800083d4:	fe b0 f8 a2 	rcall	80007518 <get_arg>
800083d8:	2f dd       	sub	sp,-12
800083da:	78 0a       	ld.w	r10,r12[0x0]
800083dc:	c2 08       	rjmp	8000841c <_vfprintf_r+0xbd4>
800083de:	2f f7       	sub	r7,-1
800083e0:	10 39       	cp.w	r9,r8
800083e2:	c0 84       	brge	800083f2 <_vfprintf_r+0xbaa>
800083e4:	fa cb f9 44 	sub	r11,sp,-1724
800083e8:	f6 06 00 36 	add	r6,r11,r6<<0x3
800083ec:	ec fa fd 88 	ld.w	r10,r6[-632]
800083f0:	c1 68       	rjmp	8000841c <_vfprintf_r+0xbd4>
800083f2:	41 09       	lddsp	r9,sp[0x40]
800083f4:	59 f8       	cp.w	r8,31
800083f6:	e0 89 00 10 	brgt	80008416 <_vfprintf_r+0xbce>
800083fa:	f2 ca ff fc 	sub	r10,r9,-4
800083fe:	51 0a       	stdsp	sp[0x40],r10
80008400:	fa c6 f9 44 	sub	r6,sp,-1724
80008404:	72 0a       	ld.w	r10,r9[0x0]
80008406:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000840a:	f3 4a fd 88 	st.w	r9[-632],r10
8000840e:	2f f8       	sub	r8,-1
80008410:	fb 48 06 b4 	st.w	sp[1716],r8
80008414:	c0 48       	rjmp	8000841c <_vfprintf_r+0xbd4>
80008416:	72 0a       	ld.w	r10,r9[0x0]
80008418:	2f c9       	sub	r9,-4
8000841a:	51 09       	stdsp	sp[0x40],r9
8000841c:	40 be       	lddsp	lr,sp[0x2c]
8000841e:	1c 98       	mov	r8,lr
80008420:	95 1e       	st.w	r10[0x4],lr
80008422:	bf 58       	asr	r8,0x1f
80008424:	95 08       	st.w	r10[0x0],r8
80008426:	fe 9f fa 9f 	bral	80007964 <_vfprintf_r+0x11c>
8000842a:	ed b5 00 04 	bld	r5,0x4
8000842e:	c4 80       	breq	800084be <_vfprintf_r+0xc76>
80008430:	e2 15 00 40 	andl	r5,0x40,COH
80008434:	c4 50       	breq	800084be <_vfprintf_r+0xc76>
80008436:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000843a:	40 3c       	lddsp	r12,sp[0xc]
8000843c:	58 0c       	cp.w	r12,0
8000843e:	c1 d0       	breq	80008478 <_vfprintf_r+0xc30>
80008440:	10 36       	cp.w	r6,r8
80008442:	c0 64       	brge	8000844e <_vfprintf_r+0xc06>
80008444:	fa cb f9 44 	sub	r11,sp,-1724
80008448:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000844c:	c1 d8       	rjmp	80008486 <_vfprintf_r+0xc3e>
8000844e:	fa c8 f9 50 	sub	r8,sp,-1712
80008452:	1a d8       	st.w	--sp,r8
80008454:	fa c8 fa b8 	sub	r8,sp,-1352
80008458:	04 9a       	mov	r10,r2
8000845a:	1a d8       	st.w	--sp,r8
8000845c:	fa c8 fb b4 	sub	r8,sp,-1100
80008460:	0c 9b       	mov	r11,r6
80008462:	1a d8       	st.w	--sp,r8
80008464:	08 9c       	mov	r12,r4
80008466:	fa c8 f9 40 	sub	r8,sp,-1728
8000846a:	fa c9 ff b4 	sub	r9,sp,-76
8000846e:	fe b0 f8 55 	rcall	80007518 <get_arg>
80008472:	2f dd       	sub	sp,-12
80008474:	78 0a       	ld.w	r10,r12[0x0]
80008476:	c2 08       	rjmp	800084b6 <_vfprintf_r+0xc6e>
80008478:	2f f7       	sub	r7,-1
8000847a:	10 39       	cp.w	r9,r8
8000847c:	c0 84       	brge	8000848c <_vfprintf_r+0xc44>
8000847e:	fa ca f9 44 	sub	r10,sp,-1724
80008482:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008486:	ec fa fd 88 	ld.w	r10,r6[-632]
8000848a:	c1 68       	rjmp	800084b6 <_vfprintf_r+0xc6e>
8000848c:	41 09       	lddsp	r9,sp[0x40]
8000848e:	59 f8       	cp.w	r8,31
80008490:	e0 89 00 10 	brgt	800084b0 <_vfprintf_r+0xc68>
80008494:	f2 ca ff fc 	sub	r10,r9,-4
80008498:	51 0a       	stdsp	sp[0x40],r10
8000849a:	fa c6 f9 44 	sub	r6,sp,-1724
8000849e:	72 0a       	ld.w	r10,r9[0x0]
800084a0:	ec 08 00 39 	add	r9,r6,r8<<0x3
800084a4:	f3 4a fd 88 	st.w	r9[-632],r10
800084a8:	2f f8       	sub	r8,-1
800084aa:	fb 48 06 b4 	st.w	sp[1716],r8
800084ae:	c0 48       	rjmp	800084b6 <_vfprintf_r+0xc6e>
800084b0:	72 0a       	ld.w	r10,r9[0x0]
800084b2:	2f c9       	sub	r9,-4
800084b4:	51 09       	stdsp	sp[0x40],r9
800084b6:	40 be       	lddsp	lr,sp[0x2c]
800084b8:	b4 0e       	st.h	r10[0x0],lr
800084ba:	fe 9f fa 55 	bral	80007964 <_vfprintf_r+0x11c>
800084be:	fa f8 06 b4 	ld.w	r8,sp[1716]
800084c2:	40 3c       	lddsp	r12,sp[0xc]
800084c4:	58 0c       	cp.w	r12,0
800084c6:	c1 d0       	breq	80008500 <_vfprintf_r+0xcb8>
800084c8:	10 36       	cp.w	r6,r8
800084ca:	c0 64       	brge	800084d6 <_vfprintf_r+0xc8e>
800084cc:	fa cb f9 44 	sub	r11,sp,-1724
800084d0:	f6 06 00 36 	add	r6,r11,r6<<0x3
800084d4:	c1 d8       	rjmp	8000850e <_vfprintf_r+0xcc6>
800084d6:	fa c8 f9 50 	sub	r8,sp,-1712
800084da:	1a d8       	st.w	--sp,r8
800084dc:	fa c8 fa b8 	sub	r8,sp,-1352
800084e0:	04 9a       	mov	r10,r2
800084e2:	1a d8       	st.w	--sp,r8
800084e4:	fa c8 fb b4 	sub	r8,sp,-1100
800084e8:	0c 9b       	mov	r11,r6
800084ea:	1a d8       	st.w	--sp,r8
800084ec:	08 9c       	mov	r12,r4
800084ee:	fa c8 f9 40 	sub	r8,sp,-1728
800084f2:	fa c9 ff b4 	sub	r9,sp,-76
800084f6:	fe b0 f8 11 	rcall	80007518 <get_arg>
800084fa:	2f dd       	sub	sp,-12
800084fc:	78 0a       	ld.w	r10,r12[0x0]
800084fe:	c2 08       	rjmp	8000853e <_vfprintf_r+0xcf6>
80008500:	2f f7       	sub	r7,-1
80008502:	10 39       	cp.w	r9,r8
80008504:	c0 84       	brge	80008514 <_vfprintf_r+0xccc>
80008506:	fa ca f9 44 	sub	r10,sp,-1724
8000850a:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000850e:	ec fa fd 88 	ld.w	r10,r6[-632]
80008512:	c1 68       	rjmp	8000853e <_vfprintf_r+0xcf6>
80008514:	41 09       	lddsp	r9,sp[0x40]
80008516:	59 f8       	cp.w	r8,31
80008518:	e0 89 00 10 	brgt	80008538 <_vfprintf_r+0xcf0>
8000851c:	f2 ca ff fc 	sub	r10,r9,-4
80008520:	51 0a       	stdsp	sp[0x40],r10
80008522:	fa c6 f9 44 	sub	r6,sp,-1724
80008526:	72 0a       	ld.w	r10,r9[0x0]
80008528:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000852c:	f3 4a fd 88 	st.w	r9[-632],r10
80008530:	2f f8       	sub	r8,-1
80008532:	fb 48 06 b4 	st.w	sp[1716],r8
80008536:	c0 48       	rjmp	8000853e <_vfprintf_r+0xcf6>
80008538:	72 0a       	ld.w	r10,r9[0x0]
8000853a:	2f c9       	sub	r9,-4
8000853c:	51 09       	stdsp	sp[0x40],r9
8000853e:	40 be       	lddsp	lr,sp[0x2c]
80008540:	95 0e       	st.w	r10[0x0],lr
80008542:	fe 9f fa 11 	bral	80007964 <_vfprintf_r+0x11c>
80008546:	50 a7       	stdsp	sp[0x28],r7
80008548:	50 80       	stdsp	sp[0x20],r0
8000854a:	0c 97       	mov	r7,r6
8000854c:	04 94       	mov	r4,r2
8000854e:	06 96       	mov	r6,r3
80008550:	02 92       	mov	r2,r1
80008552:	40 93       	lddsp	r3,sp[0x24]
80008554:	10 90       	mov	r0,r8
80008556:	40 41       	lddsp	r1,sp[0x10]
80008558:	a5 a5       	sbr	r5,0x4
8000855a:	c0 a8       	rjmp	8000856e <_vfprintf_r+0xd26>
8000855c:	50 a7       	stdsp	sp[0x28],r7
8000855e:	50 80       	stdsp	sp[0x20],r0
80008560:	0c 97       	mov	r7,r6
80008562:	04 94       	mov	r4,r2
80008564:	06 96       	mov	r6,r3
80008566:	02 92       	mov	r2,r1
80008568:	40 93       	lddsp	r3,sp[0x24]
8000856a:	10 90       	mov	r0,r8
8000856c:	40 41       	lddsp	r1,sp[0x10]
8000856e:	ed b5 00 05 	bld	r5,0x5
80008572:	c5 d1       	brne	8000862c <_vfprintf_r+0xde4>
80008574:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008578:	40 3c       	lddsp	r12,sp[0xc]
8000857a:	58 0c       	cp.w	r12,0
8000857c:	c2 60       	breq	800085c8 <_vfprintf_r+0xd80>
8000857e:	10 36       	cp.w	r6,r8
80008580:	c0 a4       	brge	80008594 <_vfprintf_r+0xd4c>
80008582:	fa cb f9 44 	sub	r11,sp,-1724
80008586:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000858a:	ec e8 fd 88 	ld.d	r8,r6[-632]
8000858e:	fa e9 00 00 	st.d	sp[0],r8
80008592:	c1 88       	rjmp	800085c2 <_vfprintf_r+0xd7a>
80008594:	fa c8 f9 50 	sub	r8,sp,-1712
80008598:	1a d8       	st.w	--sp,r8
8000859a:	fa c8 fa b8 	sub	r8,sp,-1352
8000859e:	04 9a       	mov	r10,r2
800085a0:	1a d8       	st.w	--sp,r8
800085a2:	0c 9b       	mov	r11,r6
800085a4:	fa c8 fb b4 	sub	r8,sp,-1100
800085a8:	08 9c       	mov	r12,r4
800085aa:	1a d8       	st.w	--sp,r8
800085ac:	fa c8 f9 40 	sub	r8,sp,-1728
800085b0:	fa c9 ff b4 	sub	r9,sp,-76
800085b4:	fe b0 f7 b2 	rcall	80007518 <get_arg>
800085b8:	2f dd       	sub	sp,-12
800085ba:	f8 ea 00 00 	ld.d	r10,r12[0]
800085be:	fa eb 00 00 	st.d	sp[0],r10
800085c2:	30 08       	mov	r8,0
800085c4:	e0 8f 03 de 	bral	80008d80 <_vfprintf_r+0x1538>
800085c8:	ee ca ff ff 	sub	r10,r7,-1
800085cc:	10 37       	cp.w	r7,r8
800085ce:	c0 b4       	brge	800085e4 <_vfprintf_r+0xd9c>
800085d0:	fa c9 f9 44 	sub	r9,sp,-1724
800085d4:	14 97       	mov	r7,r10
800085d6:	f2 06 00 36 	add	r6,r9,r6<<0x3
800085da:	ec ea fd 88 	ld.d	r10,r6[-632]
800085de:	fa eb 00 00 	st.d	sp[0],r10
800085e2:	c1 88       	rjmp	80008612 <_vfprintf_r+0xdca>
800085e4:	41 09       	lddsp	r9,sp[0x40]
800085e6:	59 f8       	cp.w	r8,31
800085e8:	e0 89 00 18 	brgt	80008618 <_vfprintf_r+0xdd0>
800085ec:	f2 e6 00 00 	ld.d	r6,r9[0]
800085f0:	f2 cb ff f8 	sub	r11,r9,-8
800085f4:	fa e7 00 00 	st.d	sp[0],r6
800085f8:	51 0b       	stdsp	sp[0x40],r11
800085fa:	fa c6 f9 44 	sub	r6,sp,-1724
800085fe:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008602:	fa e6 00 00 	ld.d	r6,sp[0]
80008606:	f2 e7 fd 88 	st.d	r9[-632],r6
8000860a:	2f f8       	sub	r8,-1
8000860c:	14 97       	mov	r7,r10
8000860e:	fb 48 06 b4 	st.w	sp[1716],r8
80008612:	40 38       	lddsp	r8,sp[0xc]
80008614:	e0 8f 03 b6 	bral	80008d80 <_vfprintf_r+0x1538>
80008618:	f2 e6 00 00 	ld.d	r6,r9[0]
8000861c:	40 38       	lddsp	r8,sp[0xc]
8000861e:	fa e7 00 00 	st.d	sp[0],r6
80008622:	2f 89       	sub	r9,-8
80008624:	14 97       	mov	r7,r10
80008626:	51 09       	stdsp	sp[0x40],r9
80008628:	e0 8f 03 ac 	bral	80008d80 <_vfprintf_r+0x1538>
8000862c:	ed b5 00 04 	bld	r5,0x4
80008630:	c1 61       	brne	8000865c <_vfprintf_r+0xe14>
80008632:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008636:	40 3e       	lddsp	lr,sp[0xc]
80008638:	58 0e       	cp.w	lr,0
8000863a:	c0 80       	breq	8000864a <_vfprintf_r+0xe02>
8000863c:	10 36       	cp.w	r6,r8
8000863e:	c6 74       	brge	8000870c <_vfprintf_r+0xec4>
80008640:	fa cc f9 44 	sub	r12,sp,-1724
80008644:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008648:	c8 08       	rjmp	80008748 <_vfprintf_r+0xf00>
8000864a:	ee ca ff ff 	sub	r10,r7,-1
8000864e:	10 37       	cp.w	r7,r8
80008650:	c7 f4       	brge	8000874e <_vfprintf_r+0xf06>
80008652:	fa cb f9 44 	sub	r11,sp,-1724
80008656:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000865a:	c7 68       	rjmp	80008746 <_vfprintf_r+0xefe>
8000865c:	ed b5 00 06 	bld	r5,0x6
80008660:	c4 a1       	brne	800086f4 <_vfprintf_r+0xeac>
80008662:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008666:	40 3c       	lddsp	r12,sp[0xc]
80008668:	58 0c       	cp.w	r12,0
8000866a:	c1 d0       	breq	800086a4 <_vfprintf_r+0xe5c>
8000866c:	10 36       	cp.w	r6,r8
8000866e:	c0 64       	brge	8000867a <_vfprintf_r+0xe32>
80008670:	fa cb f9 44 	sub	r11,sp,-1724
80008674:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008678:	c1 f8       	rjmp	800086b6 <_vfprintf_r+0xe6e>
8000867a:	fa c8 f9 50 	sub	r8,sp,-1712
8000867e:	1a d8       	st.w	--sp,r8
80008680:	fa c8 fa b8 	sub	r8,sp,-1352
80008684:	1a d8       	st.w	--sp,r8
80008686:	fa c8 fb b4 	sub	r8,sp,-1100
8000868a:	1a d8       	st.w	--sp,r8
8000868c:	fa c8 f9 40 	sub	r8,sp,-1728
80008690:	fa c9 ff b4 	sub	r9,sp,-76
80008694:	04 9a       	mov	r10,r2
80008696:	0c 9b       	mov	r11,r6
80008698:	08 9c       	mov	r12,r4
8000869a:	fe b0 f7 3f 	rcall	80007518 <get_arg>
8000869e:	2f dd       	sub	sp,-12
800086a0:	98 18       	ld.sh	r8,r12[0x2]
800086a2:	c2 68       	rjmp	800086ee <_vfprintf_r+0xea6>
800086a4:	ee ca ff ff 	sub	r10,r7,-1
800086a8:	10 37       	cp.w	r7,r8
800086aa:	c0 94       	brge	800086bc <_vfprintf_r+0xe74>
800086ac:	fa c9 f9 44 	sub	r9,sp,-1724
800086b0:	14 97       	mov	r7,r10
800086b2:	f2 06 00 36 	add	r6,r9,r6<<0x3
800086b6:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
800086ba:	c1 a8       	rjmp	800086ee <_vfprintf_r+0xea6>
800086bc:	41 09       	lddsp	r9,sp[0x40]
800086be:	59 f8       	cp.w	r8,31
800086c0:	e0 89 00 13 	brgt	800086e6 <_vfprintf_r+0xe9e>
800086c4:	f2 cb ff fc 	sub	r11,r9,-4
800086c8:	51 0b       	stdsp	sp[0x40],r11
800086ca:	72 09       	ld.w	r9,r9[0x0]
800086cc:	fa c6 f9 44 	sub	r6,sp,-1724
800086d0:	ec 08 00 3b 	add	r11,r6,r8<<0x3
800086d4:	2f f8       	sub	r8,-1
800086d6:	f7 49 fd 88 	st.w	r11[-632],r9
800086da:	fb 48 06 b4 	st.w	sp[1716],r8
800086de:	14 97       	mov	r7,r10
800086e0:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
800086e4:	c0 58       	rjmp	800086ee <_vfprintf_r+0xea6>
800086e6:	92 18       	ld.sh	r8,r9[0x2]
800086e8:	14 97       	mov	r7,r10
800086ea:	2f c9       	sub	r9,-4
800086ec:	51 09       	stdsp	sp[0x40],r9
800086ee:	5c 78       	castu.h	r8
800086f0:	50 18       	stdsp	sp[0x4],r8
800086f2:	c4 68       	rjmp	8000877e <_vfprintf_r+0xf36>
800086f4:	fa f8 06 b4 	ld.w	r8,sp[1716]
800086f8:	40 3c       	lddsp	r12,sp[0xc]
800086fa:	58 0c       	cp.w	r12,0
800086fc:	c1 d0       	breq	80008736 <_vfprintf_r+0xeee>
800086fe:	10 36       	cp.w	r6,r8
80008700:	c0 64       	brge	8000870c <_vfprintf_r+0xec4>
80008702:	fa cb f9 44 	sub	r11,sp,-1724
80008706:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000870a:	c1 f8       	rjmp	80008748 <_vfprintf_r+0xf00>
8000870c:	fa c8 f9 50 	sub	r8,sp,-1712
80008710:	1a d8       	st.w	--sp,r8
80008712:	fa c8 fa b8 	sub	r8,sp,-1352
80008716:	0c 9b       	mov	r11,r6
80008718:	1a d8       	st.w	--sp,r8
8000871a:	fa c8 fb b4 	sub	r8,sp,-1100
8000871e:	04 9a       	mov	r10,r2
80008720:	1a d8       	st.w	--sp,r8
80008722:	08 9c       	mov	r12,r4
80008724:	fa c8 f9 40 	sub	r8,sp,-1728
80008728:	fa c9 ff b4 	sub	r9,sp,-76
8000872c:	fe b0 f6 f6 	rcall	80007518 <get_arg>
80008730:	2f dd       	sub	sp,-12
80008732:	78 0b       	ld.w	r11,r12[0x0]
80008734:	c2 48       	rjmp	8000877c <_vfprintf_r+0xf34>
80008736:	ee ca ff ff 	sub	r10,r7,-1
8000873a:	10 37       	cp.w	r7,r8
8000873c:	c0 94       	brge	8000874e <_vfprintf_r+0xf06>
8000873e:	fa c9 f9 44 	sub	r9,sp,-1724
80008742:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008746:	14 97       	mov	r7,r10
80008748:	ec fb fd 88 	ld.w	r11,r6[-632]
8000874c:	c1 88       	rjmp	8000877c <_vfprintf_r+0xf34>
8000874e:	41 09       	lddsp	r9,sp[0x40]
80008750:	59 f8       	cp.w	r8,31
80008752:	e0 89 00 11 	brgt	80008774 <_vfprintf_r+0xf2c>
80008756:	f2 cb ff fc 	sub	r11,r9,-4
8000875a:	51 0b       	stdsp	sp[0x40],r11
8000875c:	fa c6 f9 44 	sub	r6,sp,-1724
80008760:	72 0b       	ld.w	r11,r9[0x0]
80008762:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008766:	f3 4b fd 88 	st.w	r9[-632],r11
8000876a:	2f f8       	sub	r8,-1
8000876c:	14 97       	mov	r7,r10
8000876e:	fb 48 06 b4 	st.w	sp[1716],r8
80008772:	c0 58       	rjmp	8000877c <_vfprintf_r+0xf34>
80008774:	72 0b       	ld.w	r11,r9[0x0]
80008776:	14 97       	mov	r7,r10
80008778:	2f c9       	sub	r9,-4
8000877a:	51 09       	stdsp	sp[0x40],r9
8000877c:	50 1b       	stdsp	sp[0x4],r11
8000877e:	30 0e       	mov	lr,0
80008780:	50 0e       	stdsp	sp[0x0],lr
80008782:	1c 98       	mov	r8,lr
80008784:	e0 8f 02 fe 	bral	80008d80 <_vfprintf_r+0x1538>
80008788:	50 a7       	stdsp	sp[0x28],r7
8000878a:	50 80       	stdsp	sp[0x20],r0
8000878c:	0c 97       	mov	r7,r6
8000878e:	04 94       	mov	r4,r2
80008790:	06 96       	mov	r6,r3
80008792:	02 92       	mov	r2,r1
80008794:	40 93       	lddsp	r3,sp[0x24]
80008796:	40 41       	lddsp	r1,sp[0x10]
80008798:	0e 99       	mov	r9,r7
8000879a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000879e:	40 3c       	lddsp	r12,sp[0xc]
800087a0:	58 0c       	cp.w	r12,0
800087a2:	c1 d0       	breq	800087dc <_vfprintf_r+0xf94>
800087a4:	10 36       	cp.w	r6,r8
800087a6:	c0 64       	brge	800087b2 <_vfprintf_r+0xf6a>
800087a8:	fa cb f9 44 	sub	r11,sp,-1724
800087ac:	f6 06 00 36 	add	r6,r11,r6<<0x3
800087b0:	c1 d8       	rjmp	800087ea <_vfprintf_r+0xfa2>
800087b2:	fa c8 f9 50 	sub	r8,sp,-1712
800087b6:	1a d8       	st.w	--sp,r8
800087b8:	fa c8 fa b8 	sub	r8,sp,-1352
800087bc:	1a d8       	st.w	--sp,r8
800087be:	fa c8 fb b4 	sub	r8,sp,-1100
800087c2:	1a d8       	st.w	--sp,r8
800087c4:	fa c9 ff b4 	sub	r9,sp,-76
800087c8:	fa c8 f9 40 	sub	r8,sp,-1728
800087cc:	04 9a       	mov	r10,r2
800087ce:	0c 9b       	mov	r11,r6
800087d0:	08 9c       	mov	r12,r4
800087d2:	fe b0 f6 a3 	rcall	80007518 <get_arg>
800087d6:	2f dd       	sub	sp,-12
800087d8:	78 09       	ld.w	r9,r12[0x0]
800087da:	c2 18       	rjmp	8000881c <_vfprintf_r+0xfd4>
800087dc:	2f f7       	sub	r7,-1
800087de:	10 39       	cp.w	r9,r8
800087e0:	c0 84       	brge	800087f0 <_vfprintf_r+0xfa8>
800087e2:	fa ca f9 44 	sub	r10,sp,-1724
800087e6:	f4 06 00 36 	add	r6,r10,r6<<0x3
800087ea:	ec f9 fd 88 	ld.w	r9,r6[-632]
800087ee:	c1 78       	rjmp	8000881c <_vfprintf_r+0xfd4>
800087f0:	41 09       	lddsp	r9,sp[0x40]
800087f2:	59 f8       	cp.w	r8,31
800087f4:	e0 89 00 10 	brgt	80008814 <_vfprintf_r+0xfcc>
800087f8:	f2 ca ff fc 	sub	r10,r9,-4
800087fc:	51 0a       	stdsp	sp[0x40],r10
800087fe:	fa c6 f9 44 	sub	r6,sp,-1724
80008802:	72 09       	ld.w	r9,r9[0x0]
80008804:	ec 08 00 3a 	add	r10,r6,r8<<0x3
80008808:	f5 49 fd 88 	st.w	r10[-632],r9
8000880c:	2f f8       	sub	r8,-1
8000880e:	fb 48 06 b4 	st.w	sp[1716],r8
80008812:	c0 58       	rjmp	8000881c <_vfprintf_r+0xfd4>
80008814:	f2 c8 ff fc 	sub	r8,r9,-4
80008818:	51 08       	stdsp	sp[0x40],r8
8000881a:	72 09       	ld.w	r9,r9[0x0]
8000881c:	33 08       	mov	r8,48
8000881e:	fb 68 06 b8 	st.b	sp[1720],r8
80008822:	37 88       	mov	r8,120
80008824:	30 0e       	mov	lr,0
80008826:	fb 68 06 b9 	st.b	sp[1721],r8
8000882a:	fe cc b1 a6 	sub	r12,pc,-20058
8000882e:	50 19       	stdsp	sp[0x4],r9
80008830:	a1 b5       	sbr	r5,0x1
80008832:	50 0e       	stdsp	sp[0x0],lr
80008834:	50 dc       	stdsp	sp[0x34],r12
80008836:	30 28       	mov	r8,2
80008838:	37 80       	mov	r0,120
8000883a:	e0 8f 02 a3 	bral	80008d80 <_vfprintf_r+0x1538>
8000883e:	50 a7       	stdsp	sp[0x28],r7
80008840:	50 80       	stdsp	sp[0x20],r0
80008842:	10 90       	mov	r0,r8
80008844:	30 08       	mov	r8,0
80008846:	fb 68 06 bb 	st.b	sp[1723],r8
8000884a:	0c 97       	mov	r7,r6
8000884c:	04 94       	mov	r4,r2
8000884e:	06 96       	mov	r6,r3
80008850:	02 92       	mov	r2,r1
80008852:	40 93       	lddsp	r3,sp[0x24]
80008854:	40 41       	lddsp	r1,sp[0x10]
80008856:	0e 99       	mov	r9,r7
80008858:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000885c:	40 3b       	lddsp	r11,sp[0xc]
8000885e:	58 0b       	cp.w	r11,0
80008860:	c1 d0       	breq	8000889a <_vfprintf_r+0x1052>
80008862:	10 36       	cp.w	r6,r8
80008864:	c0 64       	brge	80008870 <_vfprintf_r+0x1028>
80008866:	fa ca f9 44 	sub	r10,sp,-1724
8000886a:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000886e:	c1 d8       	rjmp	800088a8 <_vfprintf_r+0x1060>
80008870:	fa c8 f9 50 	sub	r8,sp,-1712
80008874:	1a d8       	st.w	--sp,r8
80008876:	fa c8 fa b8 	sub	r8,sp,-1352
8000887a:	1a d8       	st.w	--sp,r8
8000887c:	fa c8 fb b4 	sub	r8,sp,-1100
80008880:	0c 9b       	mov	r11,r6
80008882:	1a d8       	st.w	--sp,r8
80008884:	04 9a       	mov	r10,r2
80008886:	fa c8 f9 40 	sub	r8,sp,-1728
8000888a:	fa c9 ff b4 	sub	r9,sp,-76
8000888e:	08 9c       	mov	r12,r4
80008890:	fe b0 f6 44 	rcall	80007518 <get_arg>
80008894:	2f dd       	sub	sp,-12
80008896:	78 06       	ld.w	r6,r12[0x0]
80008898:	c2 08       	rjmp	800088d8 <_vfprintf_r+0x1090>
8000889a:	2f f7       	sub	r7,-1
8000889c:	10 39       	cp.w	r9,r8
8000889e:	c0 84       	brge	800088ae <_vfprintf_r+0x1066>
800088a0:	fa c9 f9 44 	sub	r9,sp,-1724
800088a4:	f2 06 00 36 	add	r6,r9,r6<<0x3
800088a8:	ec f6 fd 88 	ld.w	r6,r6[-632]
800088ac:	c1 68       	rjmp	800088d8 <_vfprintf_r+0x1090>
800088ae:	41 09       	lddsp	r9,sp[0x40]
800088b0:	59 f8       	cp.w	r8,31
800088b2:	e0 89 00 10 	brgt	800088d2 <_vfprintf_r+0x108a>
800088b6:	f2 ca ff fc 	sub	r10,r9,-4
800088ba:	51 0a       	stdsp	sp[0x40],r10
800088bc:	72 06       	ld.w	r6,r9[0x0]
800088be:	fa ce f9 44 	sub	lr,sp,-1724
800088c2:	fc 08 00 39 	add	r9,lr,r8<<0x3
800088c6:	f3 46 fd 88 	st.w	r9[-632],r6
800088ca:	2f f8       	sub	r8,-1
800088cc:	fb 48 06 b4 	st.w	sp[1716],r8
800088d0:	c0 48       	rjmp	800088d8 <_vfprintf_r+0x1090>
800088d2:	72 06       	ld.w	r6,r9[0x0]
800088d4:	2f c9       	sub	r9,-4
800088d6:	51 09       	stdsp	sp[0x40],r9
800088d8:	40 2c       	lddsp	r12,sp[0x8]
800088da:	58 0c       	cp.w	r12,0
800088dc:	c1 05       	brlt	800088fc <_vfprintf_r+0x10b4>
800088de:	18 9a       	mov	r10,r12
800088e0:	30 0b       	mov	r11,0
800088e2:	0c 9c       	mov	r12,r6
800088e4:	e0 a0 12 38 	rcall	8000ad54 <memchr>
800088e8:	e0 80 02 df 	breq	80008ea6 <_vfprintf_r+0x165e>
800088ec:	f8 06 01 02 	sub	r2,r12,r6
800088f0:	40 2b       	lddsp	r11,sp[0x8]
800088f2:	16 32       	cp.w	r2,r11
800088f4:	e0 89 02 d9 	brgt	80008ea6 <_vfprintf_r+0x165e>
800088f8:	e0 8f 02 d4 	bral	80008ea0 <_vfprintf_r+0x1658>
800088fc:	30 0a       	mov	r10,0
800088fe:	0c 9c       	mov	r12,r6
80008900:	50 2a       	stdsp	sp[0x8],r10
80008902:	e0 a0 15 99 	rcall	8000b434 <strlen>
80008906:	18 92       	mov	r2,r12
80008908:	e0 8f 02 d2 	bral	80008eac <_vfprintf_r+0x1664>
8000890c:	50 a7       	stdsp	sp[0x28],r7
8000890e:	50 80       	stdsp	sp[0x20],r0
80008910:	0c 97       	mov	r7,r6
80008912:	04 94       	mov	r4,r2
80008914:	06 96       	mov	r6,r3
80008916:	02 92       	mov	r2,r1
80008918:	40 93       	lddsp	r3,sp[0x24]
8000891a:	10 90       	mov	r0,r8
8000891c:	40 41       	lddsp	r1,sp[0x10]
8000891e:	a5 a5       	sbr	r5,0x4
80008920:	c0 a8       	rjmp	80008934 <_vfprintf_r+0x10ec>
80008922:	50 a7       	stdsp	sp[0x28],r7
80008924:	50 80       	stdsp	sp[0x20],r0
80008926:	0c 97       	mov	r7,r6
80008928:	04 94       	mov	r4,r2
8000892a:	06 96       	mov	r6,r3
8000892c:	02 92       	mov	r2,r1
8000892e:	40 93       	lddsp	r3,sp[0x24]
80008930:	10 90       	mov	r0,r8
80008932:	40 41       	lddsp	r1,sp[0x10]
80008934:	ed b5 00 05 	bld	r5,0x5
80008938:	c5 61       	brne	800089e4 <_vfprintf_r+0x119c>
8000893a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000893e:	40 39       	lddsp	r9,sp[0xc]
80008940:	58 09       	cp.w	r9,0
80008942:	c2 10       	breq	80008984 <_vfprintf_r+0x113c>
80008944:	10 36       	cp.w	r6,r8
80008946:	c0 74       	brge	80008954 <_vfprintf_r+0x110c>
80008948:	fa c8 f9 44 	sub	r8,sp,-1724
8000894c:	f0 06 00 36 	add	r6,r8,r6<<0x3
80008950:	c2 38       	rjmp	80008996 <_vfprintf_r+0x114e>
80008952:	d7 03       	nop
80008954:	fa c8 f9 50 	sub	r8,sp,-1712
80008958:	1a d8       	st.w	--sp,r8
8000895a:	fa c8 fa b8 	sub	r8,sp,-1352
8000895e:	1a d8       	st.w	--sp,r8
80008960:	fa c8 fb b4 	sub	r8,sp,-1100
80008964:	1a d8       	st.w	--sp,r8
80008966:	fa c8 f9 40 	sub	r8,sp,-1728
8000896a:	fa c9 ff b4 	sub	r9,sp,-76
8000896e:	04 9a       	mov	r10,r2
80008970:	0c 9b       	mov	r11,r6
80008972:	08 9c       	mov	r12,r4
80008974:	fe b0 f5 d2 	rcall	80007518 <get_arg>
80008978:	2f dd       	sub	sp,-12
8000897a:	f8 e8 00 00 	ld.d	r8,r12[0]
8000897e:	fa e9 00 00 	st.d	sp[0],r8
80008982:	c2 e8       	rjmp	800089de <_vfprintf_r+0x1196>
80008984:	ee ca ff ff 	sub	r10,r7,-1
80008988:	10 37       	cp.w	r7,r8
8000898a:	c0 b4       	brge	800089a0 <_vfprintf_r+0x1158>
8000898c:	fa c8 f9 44 	sub	r8,sp,-1724
80008990:	14 97       	mov	r7,r10
80008992:	f0 06 00 36 	add	r6,r8,r6<<0x3
80008996:	ec ea fd 88 	ld.d	r10,r6[-632]
8000899a:	fa eb 00 00 	st.d	sp[0],r10
8000899e:	c2 08       	rjmp	800089de <_vfprintf_r+0x1196>
800089a0:	41 09       	lddsp	r9,sp[0x40]
800089a2:	59 f8       	cp.w	r8,31
800089a4:	e0 89 00 16 	brgt	800089d0 <_vfprintf_r+0x1188>
800089a8:	f2 e6 00 00 	ld.d	r6,r9[0]
800089ac:	f2 cb ff f8 	sub	r11,r9,-8
800089b0:	fa e7 00 00 	st.d	sp[0],r6
800089b4:	51 0b       	stdsp	sp[0x40],r11
800089b6:	fa c6 f9 44 	sub	r6,sp,-1724
800089ba:	ec 08 00 39 	add	r9,r6,r8<<0x3
800089be:	fa e6 00 00 	ld.d	r6,sp[0]
800089c2:	f2 e7 fd 88 	st.d	r9[-632],r6
800089c6:	2f f8       	sub	r8,-1
800089c8:	14 97       	mov	r7,r10
800089ca:	fb 48 06 b4 	st.w	sp[1716],r8
800089ce:	c0 88       	rjmp	800089de <_vfprintf_r+0x1196>
800089d0:	f2 e6 00 00 	ld.d	r6,r9[0]
800089d4:	2f 89       	sub	r9,-8
800089d6:	fa e7 00 00 	st.d	sp[0],r6
800089da:	51 09       	stdsp	sp[0x40],r9
800089dc:	14 97       	mov	r7,r10
800089de:	30 18       	mov	r8,1
800089e0:	e0 8f 01 d0 	bral	80008d80 <_vfprintf_r+0x1538>
800089e4:	ed b5 00 04 	bld	r5,0x4
800089e8:	c1 61       	brne	80008a14 <_vfprintf_r+0x11cc>
800089ea:	fa f8 06 b4 	ld.w	r8,sp[1716]
800089ee:	40 3e       	lddsp	lr,sp[0xc]
800089f0:	58 0e       	cp.w	lr,0
800089f2:	c0 80       	breq	80008a02 <_vfprintf_r+0x11ba>
800089f4:	10 36       	cp.w	r6,r8
800089f6:	c6 74       	brge	80008ac4 <_vfprintf_r+0x127c>
800089f8:	fa cc f9 44 	sub	r12,sp,-1724
800089fc:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008a00:	c8 08       	rjmp	80008b00 <_vfprintf_r+0x12b8>
80008a02:	ee ca ff ff 	sub	r10,r7,-1
80008a06:	10 37       	cp.w	r7,r8
80008a08:	c7 f4       	brge	80008b06 <_vfprintf_r+0x12be>
80008a0a:	fa cb f9 44 	sub	r11,sp,-1724
80008a0e:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008a12:	c7 68       	rjmp	80008afe <_vfprintf_r+0x12b6>
80008a14:	ed b5 00 06 	bld	r5,0x6
80008a18:	c4 a1       	brne	80008aac <_vfprintf_r+0x1264>
80008a1a:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008a1e:	40 3c       	lddsp	r12,sp[0xc]
80008a20:	58 0c       	cp.w	r12,0
80008a22:	c1 d0       	breq	80008a5c <_vfprintf_r+0x1214>
80008a24:	10 36       	cp.w	r6,r8
80008a26:	c0 64       	brge	80008a32 <_vfprintf_r+0x11ea>
80008a28:	fa cb f9 44 	sub	r11,sp,-1724
80008a2c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008a30:	c1 f8       	rjmp	80008a6e <_vfprintf_r+0x1226>
80008a32:	fa c8 f9 50 	sub	r8,sp,-1712
80008a36:	1a d8       	st.w	--sp,r8
80008a38:	fa c8 fa b8 	sub	r8,sp,-1352
80008a3c:	1a d8       	st.w	--sp,r8
80008a3e:	fa c8 fb b4 	sub	r8,sp,-1100
80008a42:	1a d8       	st.w	--sp,r8
80008a44:	fa c8 f9 40 	sub	r8,sp,-1728
80008a48:	fa c9 ff b4 	sub	r9,sp,-76
80008a4c:	04 9a       	mov	r10,r2
80008a4e:	0c 9b       	mov	r11,r6
80008a50:	08 9c       	mov	r12,r4
80008a52:	fe b0 f5 63 	rcall	80007518 <get_arg>
80008a56:	2f dd       	sub	sp,-12
80008a58:	98 18       	ld.sh	r8,r12[0x2]
80008a5a:	c2 68       	rjmp	80008aa6 <_vfprintf_r+0x125e>
80008a5c:	ee ca ff ff 	sub	r10,r7,-1
80008a60:	10 37       	cp.w	r7,r8
80008a62:	c0 94       	brge	80008a74 <_vfprintf_r+0x122c>
80008a64:	fa c9 f9 44 	sub	r9,sp,-1724
80008a68:	14 97       	mov	r7,r10
80008a6a:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008a6e:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80008a72:	c1 a8       	rjmp	80008aa6 <_vfprintf_r+0x125e>
80008a74:	41 09       	lddsp	r9,sp[0x40]
80008a76:	59 f8       	cp.w	r8,31
80008a78:	e0 89 00 13 	brgt	80008a9e <_vfprintf_r+0x1256>
80008a7c:	f2 cb ff fc 	sub	r11,r9,-4
80008a80:	51 0b       	stdsp	sp[0x40],r11
80008a82:	72 09       	ld.w	r9,r9[0x0]
80008a84:	fa c6 f9 44 	sub	r6,sp,-1724
80008a88:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80008a8c:	2f f8       	sub	r8,-1
80008a8e:	f7 49 fd 88 	st.w	r11[-632],r9
80008a92:	fb 48 06 b4 	st.w	sp[1716],r8
80008a96:	14 97       	mov	r7,r10
80008a98:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80008a9c:	c0 58       	rjmp	80008aa6 <_vfprintf_r+0x125e>
80008a9e:	92 18       	ld.sh	r8,r9[0x2]
80008aa0:	14 97       	mov	r7,r10
80008aa2:	2f c9       	sub	r9,-4
80008aa4:	51 09       	stdsp	sp[0x40],r9
80008aa6:	5c 78       	castu.h	r8
80008aa8:	50 18       	stdsp	sp[0x4],r8
80008aaa:	c4 68       	rjmp	80008b36 <_vfprintf_r+0x12ee>
80008aac:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008ab0:	40 3c       	lddsp	r12,sp[0xc]
80008ab2:	58 0c       	cp.w	r12,0
80008ab4:	c1 d0       	breq	80008aee <_vfprintf_r+0x12a6>
80008ab6:	10 36       	cp.w	r6,r8
80008ab8:	c0 64       	brge	80008ac4 <_vfprintf_r+0x127c>
80008aba:	fa cb f9 44 	sub	r11,sp,-1724
80008abe:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008ac2:	c1 f8       	rjmp	80008b00 <_vfprintf_r+0x12b8>
80008ac4:	fa c8 f9 50 	sub	r8,sp,-1712
80008ac8:	1a d8       	st.w	--sp,r8
80008aca:	fa c8 fa b8 	sub	r8,sp,-1352
80008ace:	0c 9b       	mov	r11,r6
80008ad0:	1a d8       	st.w	--sp,r8
80008ad2:	fa c8 fb b4 	sub	r8,sp,-1100
80008ad6:	04 9a       	mov	r10,r2
80008ad8:	1a d8       	st.w	--sp,r8
80008ada:	08 9c       	mov	r12,r4
80008adc:	fa c8 f9 40 	sub	r8,sp,-1728
80008ae0:	fa c9 ff b4 	sub	r9,sp,-76
80008ae4:	fe b0 f5 1a 	rcall	80007518 <get_arg>
80008ae8:	2f dd       	sub	sp,-12
80008aea:	78 0b       	ld.w	r11,r12[0x0]
80008aec:	c2 48       	rjmp	80008b34 <_vfprintf_r+0x12ec>
80008aee:	ee ca ff ff 	sub	r10,r7,-1
80008af2:	10 37       	cp.w	r7,r8
80008af4:	c0 94       	brge	80008b06 <_vfprintf_r+0x12be>
80008af6:	fa c9 f9 44 	sub	r9,sp,-1724
80008afa:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008afe:	14 97       	mov	r7,r10
80008b00:	ec fb fd 88 	ld.w	r11,r6[-632]
80008b04:	c1 88       	rjmp	80008b34 <_vfprintf_r+0x12ec>
80008b06:	41 09       	lddsp	r9,sp[0x40]
80008b08:	59 f8       	cp.w	r8,31
80008b0a:	e0 89 00 11 	brgt	80008b2c <_vfprintf_r+0x12e4>
80008b0e:	f2 cb ff fc 	sub	r11,r9,-4
80008b12:	51 0b       	stdsp	sp[0x40],r11
80008b14:	fa c6 f9 44 	sub	r6,sp,-1724
80008b18:	72 0b       	ld.w	r11,r9[0x0]
80008b1a:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008b1e:	f3 4b fd 88 	st.w	r9[-632],r11
80008b22:	2f f8       	sub	r8,-1
80008b24:	14 97       	mov	r7,r10
80008b26:	fb 48 06 b4 	st.w	sp[1716],r8
80008b2a:	c0 58       	rjmp	80008b34 <_vfprintf_r+0x12ec>
80008b2c:	72 0b       	ld.w	r11,r9[0x0]
80008b2e:	14 97       	mov	r7,r10
80008b30:	2f c9       	sub	r9,-4
80008b32:	51 09       	stdsp	sp[0x40],r9
80008b34:	50 1b       	stdsp	sp[0x4],r11
80008b36:	30 0e       	mov	lr,0
80008b38:	30 18       	mov	r8,1
80008b3a:	50 0e       	stdsp	sp[0x0],lr
80008b3c:	c2 29       	rjmp	80008d80 <_vfprintf_r+0x1538>
80008b3e:	50 a7       	stdsp	sp[0x28],r7
80008b40:	50 80       	stdsp	sp[0x20],r0
80008b42:	0c 97       	mov	r7,r6
80008b44:	04 94       	mov	r4,r2
80008b46:	06 96       	mov	r6,r3
80008b48:	02 92       	mov	r2,r1
80008b4a:	fe cc b4 c6 	sub	r12,pc,-19258
80008b4e:	40 93       	lddsp	r3,sp[0x24]
80008b50:	10 90       	mov	r0,r8
80008b52:	40 41       	lddsp	r1,sp[0x10]
80008b54:	50 dc       	stdsp	sp[0x34],r12
80008b56:	ed b5 00 05 	bld	r5,0x5
80008b5a:	c5 51       	brne	80008c04 <_vfprintf_r+0x13bc>
80008b5c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008b60:	40 3b       	lddsp	r11,sp[0xc]
80008b62:	58 0b       	cp.w	r11,0
80008b64:	c2 20       	breq	80008ba8 <_vfprintf_r+0x1360>
80008b66:	10 36       	cp.w	r6,r8
80008b68:	c0 a4       	brge	80008b7c <_vfprintf_r+0x1334>
80008b6a:	fa ca f9 44 	sub	r10,sp,-1724
80008b6e:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008b72:	ec e8 fd 88 	ld.d	r8,r6[-632]
80008b76:	fa e9 00 00 	st.d	sp[0],r8
80008b7a:	cf 28       	rjmp	80008d5e <_vfprintf_r+0x1516>
80008b7c:	fa c8 f9 50 	sub	r8,sp,-1712
80008b80:	1a d8       	st.w	--sp,r8
80008b82:	fa c8 fa b8 	sub	r8,sp,-1352
80008b86:	04 9a       	mov	r10,r2
80008b88:	1a d8       	st.w	--sp,r8
80008b8a:	0c 9b       	mov	r11,r6
80008b8c:	fa c8 fb b4 	sub	r8,sp,-1100
80008b90:	08 9c       	mov	r12,r4
80008b92:	1a d8       	st.w	--sp,r8
80008b94:	fa c8 f9 40 	sub	r8,sp,-1728
80008b98:	fa c9 ff b4 	sub	r9,sp,-76
80008b9c:	fe b0 f4 be 	rcall	80007518 <get_arg>
80008ba0:	2f dd       	sub	sp,-12
80008ba2:	f8 ea 00 00 	ld.d	r10,r12[0]
80008ba6:	c0 c8       	rjmp	80008bbe <_vfprintf_r+0x1376>
80008ba8:	ee ca ff ff 	sub	r10,r7,-1
80008bac:	10 37       	cp.w	r7,r8
80008bae:	c0 b4       	brge	80008bc4 <_vfprintf_r+0x137c>
80008bb0:	fa c9 f9 44 	sub	r9,sp,-1724
80008bb4:	14 97       	mov	r7,r10
80008bb6:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008bba:	ec ea fd 88 	ld.d	r10,r6[-632]
80008bbe:	fa eb 00 00 	st.d	sp[0],r10
80008bc2:	cc e8       	rjmp	80008d5e <_vfprintf_r+0x1516>
80008bc4:	41 09       	lddsp	r9,sp[0x40]
80008bc6:	59 f8       	cp.w	r8,31
80008bc8:	e0 89 00 16 	brgt	80008bf4 <_vfprintf_r+0x13ac>
80008bcc:	f2 e6 00 00 	ld.d	r6,r9[0]
80008bd0:	f2 cb ff f8 	sub	r11,r9,-8
80008bd4:	fa e7 00 00 	st.d	sp[0],r6
80008bd8:	51 0b       	stdsp	sp[0x40],r11
80008bda:	fa c6 f9 44 	sub	r6,sp,-1724
80008bde:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008be2:	fa e6 00 00 	ld.d	r6,sp[0]
80008be6:	f2 e7 fd 88 	st.d	r9[-632],r6
80008bea:	2f f8       	sub	r8,-1
80008bec:	14 97       	mov	r7,r10
80008bee:	fb 48 06 b4 	st.w	sp[1716],r8
80008bf2:	cb 68       	rjmp	80008d5e <_vfprintf_r+0x1516>
80008bf4:	f2 e6 00 00 	ld.d	r6,r9[0]
80008bf8:	2f 89       	sub	r9,-8
80008bfa:	fa e7 00 00 	st.d	sp[0],r6
80008bfe:	51 09       	stdsp	sp[0x40],r9
80008c00:	14 97       	mov	r7,r10
80008c02:	ca e8       	rjmp	80008d5e <_vfprintf_r+0x1516>
80008c04:	ed b5 00 04 	bld	r5,0x4
80008c08:	c1 71       	brne	80008c36 <_vfprintf_r+0x13ee>
80008c0a:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008c0e:	40 3e       	lddsp	lr,sp[0xc]
80008c10:	58 0e       	cp.w	lr,0
80008c12:	c0 80       	breq	80008c22 <_vfprintf_r+0x13da>
80008c14:	10 36       	cp.w	r6,r8
80008c16:	c6 94       	brge	80008ce8 <_vfprintf_r+0x14a0>
80008c18:	fa cc f9 44 	sub	r12,sp,-1724
80008c1c:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008c20:	c8 28       	rjmp	80008d24 <_vfprintf_r+0x14dc>
80008c22:	ee ca ff ff 	sub	r10,r7,-1
80008c26:	10 37       	cp.w	r7,r8
80008c28:	e0 84 00 81 	brge	80008d2a <_vfprintf_r+0x14e2>
80008c2c:	fa cb f9 44 	sub	r11,sp,-1724
80008c30:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008c34:	c7 78       	rjmp	80008d22 <_vfprintf_r+0x14da>
80008c36:	ed b5 00 06 	bld	r5,0x6
80008c3a:	c4 b1       	brne	80008cd0 <_vfprintf_r+0x1488>
80008c3c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008c40:	40 3c       	lddsp	r12,sp[0xc]
80008c42:	58 0c       	cp.w	r12,0
80008c44:	c1 d0       	breq	80008c7e <_vfprintf_r+0x1436>
80008c46:	10 36       	cp.w	r6,r8
80008c48:	c0 64       	brge	80008c54 <_vfprintf_r+0x140c>
80008c4a:	fa cb f9 44 	sub	r11,sp,-1724
80008c4e:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008c52:	c1 f8       	rjmp	80008c90 <_vfprintf_r+0x1448>
80008c54:	fa c8 f9 50 	sub	r8,sp,-1712
80008c58:	1a d8       	st.w	--sp,r8
80008c5a:	fa c8 fa b8 	sub	r8,sp,-1352
80008c5e:	1a d8       	st.w	--sp,r8
80008c60:	fa c8 fb b4 	sub	r8,sp,-1100
80008c64:	1a d8       	st.w	--sp,r8
80008c66:	fa c8 f9 40 	sub	r8,sp,-1728
80008c6a:	fa c9 ff b4 	sub	r9,sp,-76
80008c6e:	04 9a       	mov	r10,r2
80008c70:	0c 9b       	mov	r11,r6
80008c72:	08 9c       	mov	r12,r4
80008c74:	fe b0 f4 52 	rcall	80007518 <get_arg>
80008c78:	2f dd       	sub	sp,-12
80008c7a:	98 18       	ld.sh	r8,r12[0x2]
80008c7c:	c2 78       	rjmp	80008cca <_vfprintf_r+0x1482>
80008c7e:	ee ca ff ff 	sub	r10,r7,-1
80008c82:	10 37       	cp.w	r7,r8
80008c84:	c0 a4       	brge	80008c98 <_vfprintf_r+0x1450>
80008c86:	fa c9 f9 44 	sub	r9,sp,-1724
80008c8a:	14 97       	mov	r7,r10
80008c8c:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008c90:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80008c94:	c1 b8       	rjmp	80008cca <_vfprintf_r+0x1482>
80008c96:	d7 03       	nop
80008c98:	41 09       	lddsp	r9,sp[0x40]
80008c9a:	59 f8       	cp.w	r8,31
80008c9c:	e0 89 00 13 	brgt	80008cc2 <_vfprintf_r+0x147a>
80008ca0:	f2 cb ff fc 	sub	r11,r9,-4
80008ca4:	51 0b       	stdsp	sp[0x40],r11
80008ca6:	72 09       	ld.w	r9,r9[0x0]
80008ca8:	fa c6 f9 44 	sub	r6,sp,-1724
80008cac:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80008cb0:	2f f8       	sub	r8,-1
80008cb2:	f7 49 fd 88 	st.w	r11[-632],r9
80008cb6:	fb 48 06 b4 	st.w	sp[1716],r8
80008cba:	14 97       	mov	r7,r10
80008cbc:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80008cc0:	c0 58       	rjmp	80008cca <_vfprintf_r+0x1482>
80008cc2:	92 18       	ld.sh	r8,r9[0x2]
80008cc4:	14 97       	mov	r7,r10
80008cc6:	2f c9       	sub	r9,-4
80008cc8:	51 09       	stdsp	sp[0x40],r9
80008cca:	5c 78       	castu.h	r8
80008ccc:	50 18       	stdsp	sp[0x4],r8
80008cce:	c4 68       	rjmp	80008d5a <_vfprintf_r+0x1512>
80008cd0:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008cd4:	40 3c       	lddsp	r12,sp[0xc]
80008cd6:	58 0c       	cp.w	r12,0
80008cd8:	c1 d0       	breq	80008d12 <_vfprintf_r+0x14ca>
80008cda:	10 36       	cp.w	r6,r8
80008cdc:	c0 64       	brge	80008ce8 <_vfprintf_r+0x14a0>
80008cde:	fa cb f9 44 	sub	r11,sp,-1724
80008ce2:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008ce6:	c1 f8       	rjmp	80008d24 <_vfprintf_r+0x14dc>
80008ce8:	fa c8 f9 50 	sub	r8,sp,-1712
80008cec:	1a d8       	st.w	--sp,r8
80008cee:	fa c8 fa b8 	sub	r8,sp,-1352
80008cf2:	0c 9b       	mov	r11,r6
80008cf4:	1a d8       	st.w	--sp,r8
80008cf6:	fa c8 fb b4 	sub	r8,sp,-1100
80008cfa:	04 9a       	mov	r10,r2
80008cfc:	1a d8       	st.w	--sp,r8
80008cfe:	08 9c       	mov	r12,r4
80008d00:	fa c8 f9 40 	sub	r8,sp,-1728
80008d04:	fa c9 ff b4 	sub	r9,sp,-76
80008d08:	fe b0 f4 08 	rcall	80007518 <get_arg>
80008d0c:	2f dd       	sub	sp,-12
80008d0e:	78 0b       	ld.w	r11,r12[0x0]
80008d10:	c2 48       	rjmp	80008d58 <_vfprintf_r+0x1510>
80008d12:	ee ca ff ff 	sub	r10,r7,-1
80008d16:	10 37       	cp.w	r7,r8
80008d18:	c0 94       	brge	80008d2a <_vfprintf_r+0x14e2>
80008d1a:	fa c9 f9 44 	sub	r9,sp,-1724
80008d1e:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008d22:	14 97       	mov	r7,r10
80008d24:	ec fb fd 88 	ld.w	r11,r6[-632]
80008d28:	c1 88       	rjmp	80008d58 <_vfprintf_r+0x1510>
80008d2a:	41 09       	lddsp	r9,sp[0x40]
80008d2c:	59 f8       	cp.w	r8,31
80008d2e:	e0 89 00 11 	brgt	80008d50 <_vfprintf_r+0x1508>
80008d32:	f2 cb ff fc 	sub	r11,r9,-4
80008d36:	51 0b       	stdsp	sp[0x40],r11
80008d38:	fa c6 f9 44 	sub	r6,sp,-1724
80008d3c:	72 0b       	ld.w	r11,r9[0x0]
80008d3e:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008d42:	f3 4b fd 88 	st.w	r9[-632],r11
80008d46:	2f f8       	sub	r8,-1
80008d48:	14 97       	mov	r7,r10
80008d4a:	fb 48 06 b4 	st.w	sp[1716],r8
80008d4e:	c0 58       	rjmp	80008d58 <_vfprintf_r+0x1510>
80008d50:	72 0b       	ld.w	r11,r9[0x0]
80008d52:	14 97       	mov	r7,r10
80008d54:	2f c9       	sub	r9,-4
80008d56:	51 09       	stdsp	sp[0x40],r9
80008d58:	50 1b       	stdsp	sp[0x4],r11
80008d5a:	30 0e       	mov	lr,0
80008d5c:	50 0e       	stdsp	sp[0x0],lr
80008d5e:	40 08       	lddsp	r8,sp[0x0]
80008d60:	40 1c       	lddsp	r12,sp[0x4]
80008d62:	18 48       	or	r8,r12
80008d64:	5f 19       	srne	r9
80008d66:	0a 98       	mov	r8,r5
80008d68:	eb e9 00 09 	and	r9,r5,r9
80008d6c:	a1 b8       	sbr	r8,0x1
80008d6e:	58 09       	cp.w	r9,0
80008d70:	c0 70       	breq	80008d7e <_vfprintf_r+0x1536>
80008d72:	10 95       	mov	r5,r8
80008d74:	fb 60 06 b9 	st.b	sp[1721],r0
80008d78:	33 08       	mov	r8,48
80008d7a:	fb 68 06 b8 	st.b	sp[1720],r8
80008d7e:	30 28       	mov	r8,2
80008d80:	30 09       	mov	r9,0
80008d82:	fb 69 06 bb 	st.b	sp[1723],r9
80008d86:	0a 99       	mov	r9,r5
80008d88:	a7 d9       	cbr	r9,0x7
80008d8a:	40 2b       	lddsp	r11,sp[0x8]
80008d8c:	40 16       	lddsp	r6,sp[0x4]
80008d8e:	58 0b       	cp.w	r11,0
80008d90:	5f 1a       	srne	r10
80008d92:	f2 05 17 40 	movge	r5,r9
80008d96:	fa c2 f9 78 	sub	r2,sp,-1672
80008d9a:	40 09       	lddsp	r9,sp[0x0]
80008d9c:	0c 49       	or	r9,r6
80008d9e:	5f 19       	srne	r9
80008da0:	f5 e9 10 09 	or	r9,r10,r9
80008da4:	c5 c0       	breq	80008e5c <_vfprintf_r+0x1614>
80008da6:	30 19       	mov	r9,1
80008da8:	f2 08 18 00 	cp.b	r8,r9
80008dac:	c0 60       	breq	80008db8 <_vfprintf_r+0x1570>
80008dae:	30 29       	mov	r9,2
80008db0:	f2 08 18 00 	cp.b	r8,r9
80008db4:	c0 41       	brne	80008dbc <_vfprintf_r+0x1574>
80008db6:	c3 c8       	rjmp	80008e2e <_vfprintf_r+0x15e6>
80008db8:	04 96       	mov	r6,r2
80008dba:	c3 08       	rjmp	80008e1a <_vfprintf_r+0x15d2>
80008dbc:	04 96       	mov	r6,r2
80008dbe:	fa e8 00 00 	ld.d	r8,sp[0]
80008dc2:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
80008dc6:	2d 0a       	sub	r10,-48
80008dc8:	0c fa       	st.b	--r6,r10
80008dca:	f0 0b 16 03 	lsr	r11,r8,0x3
80008dce:	f2 0c 16 03 	lsr	r12,r9,0x3
80008dd2:	f7 e9 11 db 	or	r11,r11,r9<<0x1d
80008dd6:	18 99       	mov	r9,r12
80008dd8:	16 98       	mov	r8,r11
80008dda:	58 08       	cp.w	r8,0
80008ddc:	5c 29       	cpc	r9
80008dde:	cf 21       	brne	80008dc2 <_vfprintf_r+0x157a>
80008de0:	fa e9 00 00 	st.d	sp[0],r8
80008de4:	ed b5 00 00 	bld	r5,0x0
80008de8:	c4 51       	brne	80008e72 <_vfprintf_r+0x162a>
80008dea:	33 09       	mov	r9,48
80008dec:	f2 0a 18 00 	cp.b	r10,r9
80008df0:	c4 10       	breq	80008e72 <_vfprintf_r+0x162a>
80008df2:	0c f9       	st.b	--r6,r9
80008df4:	c3 f8       	rjmp	80008e72 <_vfprintf_r+0x162a>
80008df6:	fa ea 00 00 	ld.d	r10,sp[0]
80008dfa:	30 a8       	mov	r8,10
80008dfc:	30 09       	mov	r9,0
80008dfe:	e0 a0 1a 19 	rcall	8000c230 <__avr32_umod64>
80008e02:	30 a8       	mov	r8,10
80008e04:	2d 0a       	sub	r10,-48
80008e06:	30 09       	mov	r9,0
80008e08:	ac 8a       	st.b	r6[0x0],r10
80008e0a:	fa ea 00 00 	ld.d	r10,sp[0]
80008e0e:	e0 a0 18 df 	rcall	8000bfcc <__avr32_udiv64>
80008e12:	16 99       	mov	r9,r11
80008e14:	14 98       	mov	r8,r10
80008e16:	fa e9 00 00 	st.d	sp[0],r8
80008e1a:	20 16       	sub	r6,1
80008e1c:	fa ea 00 00 	ld.d	r10,sp[0]
80008e20:	58 9a       	cp.w	r10,9
80008e22:	5c 2b       	cpc	r11
80008e24:	fe 9b ff e9 	brhi	80008df6 <_vfprintf_r+0x15ae>
80008e28:	1b f8       	ld.ub	r8,sp[0x7]
80008e2a:	2d 08       	sub	r8,-48
80008e2c:	c2 08       	rjmp	80008e6c <_vfprintf_r+0x1624>
80008e2e:	04 96       	mov	r6,r2
80008e30:	fa e8 00 00 	ld.d	r8,sp[0]
80008e34:	f5 d8 c0 04 	bfextu	r10,r8,0x0,0x4
80008e38:	40 de       	lddsp	lr,sp[0x34]
80008e3a:	fc 0a 07 0a 	ld.ub	r10,lr[r10]
80008e3e:	0c fa       	st.b	--r6,r10
80008e40:	f2 0b 16 04 	lsr	r11,r9,0x4
80008e44:	f0 0a 16 04 	lsr	r10,r8,0x4
80008e48:	f5 e9 11 ca 	or	r10,r10,r9<<0x1c
80008e4c:	16 99       	mov	r9,r11
80008e4e:	14 98       	mov	r8,r10
80008e50:	58 08       	cp.w	r8,0
80008e52:	5c 29       	cpc	r9
80008e54:	cf 01       	brne	80008e34 <_vfprintf_r+0x15ec>
80008e56:	fa e9 00 00 	st.d	sp[0],r8
80008e5a:	c0 c8       	rjmp	80008e72 <_vfprintf_r+0x162a>
80008e5c:	58 08       	cp.w	r8,0
80008e5e:	c0 91       	brne	80008e70 <_vfprintf_r+0x1628>
80008e60:	ed b5 00 00 	bld	r5,0x0
80008e64:	c0 61       	brne	80008e70 <_vfprintf_r+0x1628>
80008e66:	fa c6 f9 79 	sub	r6,sp,-1671
80008e6a:	33 08       	mov	r8,48
80008e6c:	ac 88       	st.b	r6[0x0],r8
80008e6e:	c0 28       	rjmp	80008e72 <_vfprintf_r+0x162a>
80008e70:	04 96       	mov	r6,r2
80008e72:	0c 12       	sub	r2,r6
80008e74:	c1 c8       	rjmp	80008eac <_vfprintf_r+0x1664>
80008e76:	50 a7       	stdsp	sp[0x28],r7
80008e78:	50 80       	stdsp	sp[0x20],r0
80008e7a:	40 93       	lddsp	r3,sp[0x24]
80008e7c:	0c 97       	mov	r7,r6
80008e7e:	10 90       	mov	r0,r8
80008e80:	04 94       	mov	r4,r2
80008e82:	40 41       	lddsp	r1,sp[0x10]
80008e84:	58 08       	cp.w	r8,0
80008e86:	e0 80 04 4f 	breq	80009724 <_vfprintf_r+0x1edc>
80008e8a:	fb 68 06 60 	st.b	sp[1632],r8
80008e8e:	30 0c       	mov	r12,0
80008e90:	30 08       	mov	r8,0
80008e92:	30 12       	mov	r2,1
80008e94:	fb 68 06 bb 	st.b	sp[1723],r8
80008e98:	50 2c       	stdsp	sp[0x8],r12
80008e9a:	fa c6 f9 a0 	sub	r6,sp,-1632
80008e9e:	c0 78       	rjmp	80008eac <_vfprintf_r+0x1664>
80008ea0:	30 0b       	mov	r11,0
80008ea2:	50 2b       	stdsp	sp[0x8],r11
80008ea4:	c0 48       	rjmp	80008eac <_vfprintf_r+0x1664>
80008ea6:	40 22       	lddsp	r2,sp[0x8]
80008ea8:	30 0a       	mov	r10,0
80008eaa:	50 2a       	stdsp	sp[0x8],r10
80008eac:	40 29       	lddsp	r9,sp[0x8]
80008eae:	e4 09 0c 49 	max	r9,r2,r9
80008eb2:	fb 38 06 bb 	ld.ub	r8,sp[1723]
80008eb6:	50 39       	stdsp	sp[0xc],r9
80008eb8:	0a 9e       	mov	lr,r5
80008eba:	30 09       	mov	r9,0
80008ebc:	e2 1e 00 02 	andl	lr,0x2,COH
80008ec0:	f2 08 18 00 	cp.b	r8,r9
80008ec4:	fb f8 10 03 	ld.wne	r8,sp[0xc]
80008ec8:	f7 b8 01 ff 	subne	r8,-1
80008ecc:	fb f8 1a 03 	st.wne	sp[0xc],r8
80008ed0:	0a 9b       	mov	r11,r5
80008ed2:	58 0e       	cp.w	lr,0
80008ed4:	fb fc 10 03 	ld.wne	r12,sp[0xc]
80008ed8:	f7 bc 01 fe 	subne	r12,-2
80008edc:	fb fc 1a 03 	st.wne	sp[0xc],r12
80008ee0:	e2 1b 00 84 	andl	r11,0x84,COH
80008ee4:	50 fe       	stdsp	sp[0x3c],lr
80008ee6:	50 9b       	stdsp	sp[0x24],r11
80008ee8:	c4 71       	brne	80008f76 <_vfprintf_r+0x172e>
80008eea:	40 8a       	lddsp	r10,sp[0x20]
80008eec:	40 39       	lddsp	r9,sp[0xc]
80008eee:	12 1a       	sub	r10,r9
80008ef0:	50 4a       	stdsp	sp[0x10],r10
80008ef2:	58 0a       	cp.w	r10,0
80008ef4:	e0 89 00 20 	brgt	80008f34 <_vfprintf_r+0x16ec>
80008ef8:	c3 f8       	rjmp	80008f76 <_vfprintf_r+0x172e>
80008efa:	2f 09       	sub	r9,-16
80008efc:	2f f8       	sub	r8,-1
80008efe:	fe ce b8 62 	sub	lr,pc,-18334
80008f02:	31 0c       	mov	r12,16
80008f04:	fb 49 06 90 	st.w	sp[1680],r9
80008f08:	87 0e       	st.w	r3[0x0],lr
80008f0a:	87 1c       	st.w	r3[0x4],r12
80008f0c:	fb 48 06 8c 	st.w	sp[1676],r8
80008f10:	58 78       	cp.w	r8,7
80008f12:	e0 89 00 04 	brgt	80008f1a <_vfprintf_r+0x16d2>
80008f16:	2f 83       	sub	r3,-8
80008f18:	c0 b8       	rjmp	80008f2e <_vfprintf_r+0x16e6>
80008f1a:	fa ca f9 78 	sub	r10,sp,-1672
80008f1e:	02 9b       	mov	r11,r1
80008f20:	08 9c       	mov	r12,r4
80008f22:	fe b0 f4 85 	rcall	8000782c <__sprint_r>
80008f26:	e0 81 04 10 	brne	80009746 <_vfprintf_r+0x1efe>
80008f2a:	fa c3 f9 e0 	sub	r3,sp,-1568
80008f2e:	40 4b       	lddsp	r11,sp[0x10]
80008f30:	21 0b       	sub	r11,16
80008f32:	50 4b       	stdsp	sp[0x10],r11
80008f34:	fa f9 06 90 	ld.w	r9,sp[1680]
80008f38:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008f3c:	fe ca b8 a0 	sub	r10,pc,-18272
80008f40:	40 4e       	lddsp	lr,sp[0x10]
80008f42:	59 0e       	cp.w	lr,16
80008f44:	fe 99 ff db 	brgt	80008efa <_vfprintf_r+0x16b2>
80008f48:	1c 09       	add	r9,lr
80008f4a:	2f f8       	sub	r8,-1
80008f4c:	87 0a       	st.w	r3[0x0],r10
80008f4e:	fb 49 06 90 	st.w	sp[1680],r9
80008f52:	87 1e       	st.w	r3[0x4],lr
80008f54:	fb 48 06 8c 	st.w	sp[1676],r8
80008f58:	58 78       	cp.w	r8,7
80008f5a:	e0 89 00 04 	brgt	80008f62 <_vfprintf_r+0x171a>
80008f5e:	2f 83       	sub	r3,-8
80008f60:	c0 b8       	rjmp	80008f76 <_vfprintf_r+0x172e>
80008f62:	fa ca f9 78 	sub	r10,sp,-1672
80008f66:	02 9b       	mov	r11,r1
80008f68:	08 9c       	mov	r12,r4
80008f6a:	fe b0 f4 61 	rcall	8000782c <__sprint_r>
80008f6e:	e0 81 03 ec 	brne	80009746 <_vfprintf_r+0x1efe>
80008f72:	fa c3 f9 e0 	sub	r3,sp,-1568
80008f76:	30 09       	mov	r9,0
80008f78:	fb 38 06 bb 	ld.ub	r8,sp[1723]
80008f7c:	f2 08 18 00 	cp.b	r8,r9
80008f80:	c1 f0       	breq	80008fbe <_vfprintf_r+0x1776>
80008f82:	fa f8 06 90 	ld.w	r8,sp[1680]
80008f86:	fa c9 f9 45 	sub	r9,sp,-1723
80008f8a:	2f f8       	sub	r8,-1
80008f8c:	87 09       	st.w	r3[0x0],r9
80008f8e:	fb 48 06 90 	st.w	sp[1680],r8
80008f92:	30 19       	mov	r9,1
80008f94:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008f98:	87 19       	st.w	r3[0x4],r9
80008f9a:	2f f8       	sub	r8,-1
80008f9c:	fb 48 06 8c 	st.w	sp[1676],r8
80008fa0:	58 78       	cp.w	r8,7
80008fa2:	e0 89 00 04 	brgt	80008faa <_vfprintf_r+0x1762>
80008fa6:	2f 83       	sub	r3,-8
80008fa8:	c0 b8       	rjmp	80008fbe <_vfprintf_r+0x1776>
80008faa:	fa ca f9 78 	sub	r10,sp,-1672
80008fae:	02 9b       	mov	r11,r1
80008fb0:	08 9c       	mov	r12,r4
80008fb2:	fe b0 f4 3d 	rcall	8000782c <__sprint_r>
80008fb6:	e0 81 03 c8 	brne	80009746 <_vfprintf_r+0x1efe>
80008fba:	fa c3 f9 e0 	sub	r3,sp,-1568
80008fbe:	40 fc       	lddsp	r12,sp[0x3c]
80008fc0:	58 0c       	cp.w	r12,0
80008fc2:	c1 f0       	breq	80009000 <_vfprintf_r+0x17b8>
80008fc4:	fa f8 06 90 	ld.w	r8,sp[1680]
80008fc8:	fa c9 f9 48 	sub	r9,sp,-1720
80008fcc:	2f e8       	sub	r8,-2
80008fce:	87 09       	st.w	r3[0x0],r9
80008fd0:	fb 48 06 90 	st.w	sp[1680],r8
80008fd4:	30 29       	mov	r9,2
80008fd6:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008fda:	87 19       	st.w	r3[0x4],r9
80008fdc:	2f f8       	sub	r8,-1
80008fde:	fb 48 06 8c 	st.w	sp[1676],r8
80008fe2:	58 78       	cp.w	r8,7
80008fe4:	e0 89 00 04 	brgt	80008fec <_vfprintf_r+0x17a4>
80008fe8:	2f 83       	sub	r3,-8
80008fea:	c0 b8       	rjmp	80009000 <_vfprintf_r+0x17b8>
80008fec:	fa ca f9 78 	sub	r10,sp,-1672
80008ff0:	02 9b       	mov	r11,r1
80008ff2:	08 9c       	mov	r12,r4
80008ff4:	fe b0 f4 1c 	rcall	8000782c <__sprint_r>
80008ff8:	e0 81 03 a7 	brne	80009746 <_vfprintf_r+0x1efe>
80008ffc:	fa c3 f9 e0 	sub	r3,sp,-1568
80009000:	40 9b       	lddsp	r11,sp[0x24]
80009002:	e0 4b 00 80 	cp.w	r11,128
80009006:	c4 71       	brne	80009094 <_vfprintf_r+0x184c>
80009008:	40 8a       	lddsp	r10,sp[0x20]
8000900a:	40 39       	lddsp	r9,sp[0xc]
8000900c:	12 1a       	sub	r10,r9
8000900e:	50 4a       	stdsp	sp[0x10],r10
80009010:	58 0a       	cp.w	r10,0
80009012:	e0 89 00 20 	brgt	80009052 <_vfprintf_r+0x180a>
80009016:	c3 f8       	rjmp	80009094 <_vfprintf_r+0x184c>
80009018:	2f 09       	sub	r9,-16
8000901a:	2f f8       	sub	r8,-1
8000901c:	fe ce b9 70 	sub	lr,pc,-18064
80009020:	31 0c       	mov	r12,16
80009022:	fb 49 06 90 	st.w	sp[1680],r9
80009026:	87 0e       	st.w	r3[0x0],lr
80009028:	87 1c       	st.w	r3[0x4],r12
8000902a:	fb 48 06 8c 	st.w	sp[1676],r8
8000902e:	58 78       	cp.w	r8,7
80009030:	e0 89 00 04 	brgt	80009038 <_vfprintf_r+0x17f0>
80009034:	2f 83       	sub	r3,-8
80009036:	c0 b8       	rjmp	8000904c <_vfprintf_r+0x1804>
80009038:	fa ca f9 78 	sub	r10,sp,-1672
8000903c:	02 9b       	mov	r11,r1
8000903e:	08 9c       	mov	r12,r4
80009040:	fe b0 f3 f6 	rcall	8000782c <__sprint_r>
80009044:	e0 81 03 81 	brne	80009746 <_vfprintf_r+0x1efe>
80009048:	fa c3 f9 e0 	sub	r3,sp,-1568
8000904c:	40 4b       	lddsp	r11,sp[0x10]
8000904e:	21 0b       	sub	r11,16
80009050:	50 4b       	stdsp	sp[0x10],r11
80009052:	fa f9 06 90 	ld.w	r9,sp[1680]
80009056:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000905a:	fe ca b9 ae 	sub	r10,pc,-18002
8000905e:	40 4e       	lddsp	lr,sp[0x10]
80009060:	59 0e       	cp.w	lr,16
80009062:	fe 99 ff db 	brgt	80009018 <_vfprintf_r+0x17d0>
80009066:	1c 09       	add	r9,lr
80009068:	2f f8       	sub	r8,-1
8000906a:	87 0a       	st.w	r3[0x0],r10
8000906c:	fb 49 06 90 	st.w	sp[1680],r9
80009070:	87 1e       	st.w	r3[0x4],lr
80009072:	fb 48 06 8c 	st.w	sp[1676],r8
80009076:	58 78       	cp.w	r8,7
80009078:	e0 89 00 04 	brgt	80009080 <_vfprintf_r+0x1838>
8000907c:	2f 83       	sub	r3,-8
8000907e:	c0 b8       	rjmp	80009094 <_vfprintf_r+0x184c>
80009080:	fa ca f9 78 	sub	r10,sp,-1672
80009084:	02 9b       	mov	r11,r1
80009086:	08 9c       	mov	r12,r4
80009088:	fe b0 f3 d2 	rcall	8000782c <__sprint_r>
8000908c:	e0 81 03 5d 	brne	80009746 <_vfprintf_r+0x1efe>
80009090:	fa c3 f9 e0 	sub	r3,sp,-1568
80009094:	40 2c       	lddsp	r12,sp[0x8]
80009096:	04 1c       	sub	r12,r2
80009098:	50 2c       	stdsp	sp[0x8],r12
8000909a:	58 0c       	cp.w	r12,0
8000909c:	e0 89 00 20 	brgt	800090dc <_vfprintf_r+0x1894>
800090a0:	c3 f8       	rjmp	8000911e <_vfprintf_r+0x18d6>
800090a2:	2f 09       	sub	r9,-16
800090a4:	2f f8       	sub	r8,-1
800090a6:	fe cb b9 fa 	sub	r11,pc,-17926
800090aa:	31 0a       	mov	r10,16
800090ac:	fb 49 06 90 	st.w	sp[1680],r9
800090b0:	87 0b       	st.w	r3[0x0],r11
800090b2:	87 1a       	st.w	r3[0x4],r10
800090b4:	fb 48 06 8c 	st.w	sp[1676],r8
800090b8:	58 78       	cp.w	r8,7
800090ba:	e0 89 00 04 	brgt	800090c2 <_vfprintf_r+0x187a>
800090be:	2f 83       	sub	r3,-8
800090c0:	c0 b8       	rjmp	800090d6 <_vfprintf_r+0x188e>
800090c2:	fa ca f9 78 	sub	r10,sp,-1672
800090c6:	02 9b       	mov	r11,r1
800090c8:	08 9c       	mov	r12,r4
800090ca:	fe b0 f3 b1 	rcall	8000782c <__sprint_r>
800090ce:	e0 81 03 3c 	brne	80009746 <_vfprintf_r+0x1efe>
800090d2:	fa c3 f9 e0 	sub	r3,sp,-1568
800090d6:	40 29       	lddsp	r9,sp[0x8]
800090d8:	21 09       	sub	r9,16
800090da:	50 29       	stdsp	sp[0x8],r9
800090dc:	fa f9 06 90 	ld.w	r9,sp[1680]
800090e0:	fa f8 06 8c 	ld.w	r8,sp[1676]
800090e4:	fe ca ba 38 	sub	r10,pc,-17864
800090e8:	40 2e       	lddsp	lr,sp[0x8]
800090ea:	59 0e       	cp.w	lr,16
800090ec:	fe 99 ff db 	brgt	800090a2 <_vfprintf_r+0x185a>
800090f0:	1c 09       	add	r9,lr
800090f2:	2f f8       	sub	r8,-1
800090f4:	87 0a       	st.w	r3[0x0],r10
800090f6:	fb 49 06 90 	st.w	sp[1680],r9
800090fa:	87 1e       	st.w	r3[0x4],lr
800090fc:	fb 48 06 8c 	st.w	sp[1676],r8
80009100:	58 78       	cp.w	r8,7
80009102:	e0 89 00 04 	brgt	8000910a <_vfprintf_r+0x18c2>
80009106:	2f 83       	sub	r3,-8
80009108:	c0 b8       	rjmp	8000911e <_vfprintf_r+0x18d6>
8000910a:	fa ca f9 78 	sub	r10,sp,-1672
8000910e:	02 9b       	mov	r11,r1
80009110:	08 9c       	mov	r12,r4
80009112:	fe b0 f3 8d 	rcall	8000782c <__sprint_r>
80009116:	e0 81 03 18 	brne	80009746 <_vfprintf_r+0x1efe>
8000911a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000911e:	ed b5 00 08 	bld	r5,0x8
80009122:	c0 b0       	breq	80009138 <_vfprintf_r+0x18f0>
80009124:	fa f8 06 90 	ld.w	r8,sp[1680]
80009128:	87 12       	st.w	r3[0x4],r2
8000912a:	87 06       	st.w	r3[0x0],r6
8000912c:	f0 02 00 02 	add	r2,r8,r2
80009130:	fb 42 06 90 	st.w	sp[1680],r2
80009134:	e0 8f 01 d4 	bral	800094dc <_vfprintf_r+0x1c94>
80009138:	e0 40 00 65 	cp.w	r0,101
8000913c:	e0 8a 01 d6 	brle	800094e8 <_vfprintf_r+0x1ca0>
80009140:	30 08       	mov	r8,0
80009142:	30 09       	mov	r9,0
80009144:	40 5b       	lddsp	r11,sp[0x14]
80009146:	40 7a       	lddsp	r10,sp[0x1c]
80009148:	e0 a0 15 3b 	rcall	8000bbbe <__avr32_f64_cmp_eq>
8000914c:	c7 90       	breq	8000923e <_vfprintf_r+0x19f6>
8000914e:	fa f8 06 90 	ld.w	r8,sp[1680]
80009152:	fe c9 ba ba 	sub	r9,pc,-17734
80009156:	2f f8       	sub	r8,-1
80009158:	87 09       	st.w	r3[0x0],r9
8000915a:	fb 48 06 90 	st.w	sp[1680],r8
8000915e:	30 19       	mov	r9,1
80009160:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009164:	87 19       	st.w	r3[0x4],r9
80009166:	2f f8       	sub	r8,-1
80009168:	fb 48 06 8c 	st.w	sp[1676],r8
8000916c:	58 78       	cp.w	r8,7
8000916e:	e0 89 00 05 	brgt	80009178 <_vfprintf_r+0x1930>
80009172:	2f 83       	sub	r3,-8
80009174:	c0 c8       	rjmp	8000918c <_vfprintf_r+0x1944>
80009176:	d7 03       	nop
80009178:	fa ca f9 78 	sub	r10,sp,-1672
8000917c:	02 9b       	mov	r11,r1
8000917e:	08 9c       	mov	r12,r4
80009180:	fe b0 f3 56 	rcall	8000782c <__sprint_r>
80009184:	e0 81 02 e1 	brne	80009746 <_vfprintf_r+0x1efe>
80009188:	fa c3 f9 e0 	sub	r3,sp,-1568
8000918c:	fa f8 06 ac 	ld.w	r8,sp[1708]
80009190:	40 6c       	lddsp	r12,sp[0x18]
80009192:	18 38       	cp.w	r8,r12
80009194:	c0 55       	brlt	8000919e <_vfprintf_r+0x1956>
80009196:	ed b5 00 00 	bld	r5,0x0
8000919a:	e0 81 02 6b 	brne	80009670 <_vfprintf_r+0x1e28>
8000919e:	fa f8 06 90 	ld.w	r8,sp[1680]
800091a2:	2f f8       	sub	r8,-1
800091a4:	40 cb       	lddsp	r11,sp[0x30]
800091a6:	fb 48 06 90 	st.w	sp[1680],r8
800091aa:	30 19       	mov	r9,1
800091ac:	fa f8 06 8c 	ld.w	r8,sp[1676]
800091b0:	87 0b       	st.w	r3[0x0],r11
800091b2:	2f f8       	sub	r8,-1
800091b4:	87 19       	st.w	r3[0x4],r9
800091b6:	fb 48 06 8c 	st.w	sp[1676],r8
800091ba:	58 78       	cp.w	r8,7
800091bc:	e0 89 00 04 	brgt	800091c4 <_vfprintf_r+0x197c>
800091c0:	2f 83       	sub	r3,-8
800091c2:	c0 b8       	rjmp	800091d8 <_vfprintf_r+0x1990>
800091c4:	fa ca f9 78 	sub	r10,sp,-1672
800091c8:	02 9b       	mov	r11,r1
800091ca:	08 9c       	mov	r12,r4
800091cc:	fe b0 f3 30 	rcall	8000782c <__sprint_r>
800091d0:	e0 81 02 bb 	brne	80009746 <_vfprintf_r+0x1efe>
800091d4:	fa c3 f9 e0 	sub	r3,sp,-1568
800091d8:	40 66       	lddsp	r6,sp[0x18]
800091da:	20 16       	sub	r6,1
800091dc:	58 06       	cp.w	r6,0
800091de:	e0 89 00 1d 	brgt	80009218 <_vfprintf_r+0x19d0>
800091e2:	e0 8f 02 47 	bral	80009670 <_vfprintf_r+0x1e28>
800091e6:	2f 09       	sub	r9,-16
800091e8:	2f f8       	sub	r8,-1
800091ea:	fb 49 06 90 	st.w	sp[1680],r9
800091ee:	87 02       	st.w	r3[0x0],r2
800091f0:	87 10       	st.w	r3[0x4],r0
800091f2:	fb 48 06 8c 	st.w	sp[1676],r8
800091f6:	58 78       	cp.w	r8,7
800091f8:	e0 89 00 04 	brgt	80009200 <_vfprintf_r+0x19b8>
800091fc:	2f 83       	sub	r3,-8
800091fe:	c0 b8       	rjmp	80009214 <_vfprintf_r+0x19cc>
80009200:	fa ca f9 78 	sub	r10,sp,-1672
80009204:	02 9b       	mov	r11,r1
80009206:	08 9c       	mov	r12,r4
80009208:	fe b0 f3 12 	rcall	8000782c <__sprint_r>
8000920c:	e0 81 02 9d 	brne	80009746 <_vfprintf_r+0x1efe>
80009210:	fa c3 f9 e0 	sub	r3,sp,-1568
80009214:	21 06       	sub	r6,16
80009216:	c0 48       	rjmp	8000921e <_vfprintf_r+0x19d6>
80009218:	fe c2 bb 6c 	sub	r2,pc,-17556
8000921c:	31 00       	mov	r0,16
8000921e:	fa f9 06 90 	ld.w	r9,sp[1680]
80009222:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009226:	fe ca bb 7a 	sub	r10,pc,-17542
8000922a:	59 06       	cp.w	r6,16
8000922c:	fe 99 ff dd 	brgt	800091e6 <_vfprintf_r+0x199e>
80009230:	0c 09       	add	r9,r6
80009232:	87 0a       	st.w	r3[0x0],r10
80009234:	fb 49 06 90 	st.w	sp[1680],r9
80009238:	2f f8       	sub	r8,-1
8000923a:	87 16       	st.w	r3[0x4],r6
8000923c:	c5 39       	rjmp	800094e2 <_vfprintf_r+0x1c9a>
8000923e:	fa fa 06 ac 	ld.w	r10,sp[1708]
80009242:	58 0a       	cp.w	r10,0
80009244:	e0 89 00 92 	brgt	80009368 <_vfprintf_r+0x1b20>
80009248:	fa f8 06 90 	ld.w	r8,sp[1680]
8000924c:	fe c9 bb b4 	sub	r9,pc,-17484
80009250:	2f f8       	sub	r8,-1
80009252:	87 09       	st.w	r3[0x0],r9
80009254:	fb 48 06 90 	st.w	sp[1680],r8
80009258:	30 19       	mov	r9,1
8000925a:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000925e:	87 19       	st.w	r3[0x4],r9
80009260:	2f f8       	sub	r8,-1
80009262:	fb 48 06 8c 	st.w	sp[1676],r8
80009266:	58 78       	cp.w	r8,7
80009268:	e0 89 00 04 	brgt	80009270 <_vfprintf_r+0x1a28>
8000926c:	2f 83       	sub	r3,-8
8000926e:	c0 b8       	rjmp	80009284 <_vfprintf_r+0x1a3c>
80009270:	fa ca f9 78 	sub	r10,sp,-1672
80009274:	02 9b       	mov	r11,r1
80009276:	08 9c       	mov	r12,r4
80009278:	fe b0 f2 da 	rcall	8000782c <__sprint_r>
8000927c:	e0 81 02 65 	brne	80009746 <_vfprintf_r+0x1efe>
80009280:	fa c3 f9 e0 	sub	r3,sp,-1568
80009284:	fa f8 06 ac 	ld.w	r8,sp[1708]
80009288:	58 08       	cp.w	r8,0
8000928a:	c0 81       	brne	8000929a <_vfprintf_r+0x1a52>
8000928c:	40 6a       	lddsp	r10,sp[0x18]
8000928e:	58 0a       	cp.w	r10,0
80009290:	c0 51       	brne	8000929a <_vfprintf_r+0x1a52>
80009292:	ed b5 00 00 	bld	r5,0x0
80009296:	e0 81 01 ed 	brne	80009670 <_vfprintf_r+0x1e28>
8000929a:	40 c9       	lddsp	r9,sp[0x30]
8000929c:	fa f8 06 90 	ld.w	r8,sp[1680]
800092a0:	2f f8       	sub	r8,-1
800092a2:	87 09       	st.w	r3[0x0],r9
800092a4:	fb 48 06 90 	st.w	sp[1680],r8
800092a8:	30 19       	mov	r9,1
800092aa:	fa f8 06 8c 	ld.w	r8,sp[1676]
800092ae:	87 19       	st.w	r3[0x4],r9
800092b0:	2f f8       	sub	r8,-1
800092b2:	fb 48 06 8c 	st.w	sp[1676],r8
800092b6:	58 78       	cp.w	r8,7
800092b8:	e0 89 00 04 	brgt	800092c0 <_vfprintf_r+0x1a78>
800092bc:	2f 83       	sub	r3,-8
800092be:	c0 b8       	rjmp	800092d4 <_vfprintf_r+0x1a8c>
800092c0:	fa ca f9 78 	sub	r10,sp,-1672
800092c4:	02 9b       	mov	r11,r1
800092c6:	08 9c       	mov	r12,r4
800092c8:	fe b0 f2 b2 	rcall	8000782c <__sprint_r>
800092cc:	e0 81 02 3d 	brne	80009746 <_vfprintf_r+0x1efe>
800092d0:	fa c3 f9 e0 	sub	r3,sp,-1568
800092d4:	fa f2 06 ac 	ld.w	r2,sp[1708]
800092d8:	5c 32       	neg	r2
800092da:	58 02       	cp.w	r2,0
800092dc:	e0 89 00 1d 	brgt	80009316 <_vfprintf_r+0x1ace>
800092e0:	c3 d8       	rjmp	8000935a <_vfprintf_r+0x1b12>
800092e2:	2f 09       	sub	r9,-16
800092e4:	2f f8       	sub	r8,-1
800092e6:	31 0e       	mov	lr,16
800092e8:	fb 49 06 90 	st.w	sp[1680],r9
800092ec:	87 00       	st.w	r3[0x0],r0
800092ee:	87 1e       	st.w	r3[0x4],lr
800092f0:	fb 48 06 8c 	st.w	sp[1676],r8
800092f4:	58 78       	cp.w	r8,7
800092f6:	e0 89 00 04 	brgt	800092fe <_vfprintf_r+0x1ab6>
800092fa:	2f 83       	sub	r3,-8
800092fc:	c0 b8       	rjmp	80009312 <_vfprintf_r+0x1aca>
800092fe:	fa ca f9 78 	sub	r10,sp,-1672
80009302:	02 9b       	mov	r11,r1
80009304:	08 9c       	mov	r12,r4
80009306:	fe b0 f2 93 	rcall	8000782c <__sprint_r>
8000930a:	e0 81 02 1e 	brne	80009746 <_vfprintf_r+0x1efe>
8000930e:	fa c3 f9 e0 	sub	r3,sp,-1568
80009312:	21 02       	sub	r2,16
80009314:	c0 38       	rjmp	8000931a <_vfprintf_r+0x1ad2>
80009316:	fe c0 bc 6a 	sub	r0,pc,-17302
8000931a:	fa f9 06 90 	ld.w	r9,sp[1680]
8000931e:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009322:	fe ca bc 76 	sub	r10,pc,-17290
80009326:	59 02       	cp.w	r2,16
80009328:	fe 99 ff dd 	brgt	800092e2 <_vfprintf_r+0x1a9a>
8000932c:	04 09       	add	r9,r2
8000932e:	2f f8       	sub	r8,-1
80009330:	87 0a       	st.w	r3[0x0],r10
80009332:	fb 49 06 90 	st.w	sp[1680],r9
80009336:	87 12       	st.w	r3[0x4],r2
80009338:	fb 48 06 8c 	st.w	sp[1676],r8
8000933c:	58 78       	cp.w	r8,7
8000933e:	e0 89 00 04 	brgt	80009346 <_vfprintf_r+0x1afe>
80009342:	2f 83       	sub	r3,-8
80009344:	c0 b8       	rjmp	8000935a <_vfprintf_r+0x1b12>
80009346:	fa ca f9 78 	sub	r10,sp,-1672
8000934a:	02 9b       	mov	r11,r1
8000934c:	08 9c       	mov	r12,r4
8000934e:	fe b0 f2 6f 	rcall	8000782c <__sprint_r>
80009352:	e0 81 01 fa 	brne	80009746 <_vfprintf_r+0x1efe>
80009356:	fa c3 f9 e0 	sub	r3,sp,-1568
8000935a:	40 6c       	lddsp	r12,sp[0x18]
8000935c:	fa f8 06 90 	ld.w	r8,sp[1680]
80009360:	87 06       	st.w	r3[0x0],r6
80009362:	87 1c       	st.w	r3[0x4],r12
80009364:	18 08       	add	r8,r12
80009366:	cb 98       	rjmp	800094d8 <_vfprintf_r+0x1c90>
80009368:	fa f9 06 90 	ld.w	r9,sp[1680]
8000936c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009370:	40 6b       	lddsp	r11,sp[0x18]
80009372:	16 3a       	cp.w	r10,r11
80009374:	c6 f5       	brlt	80009452 <_vfprintf_r+0x1c0a>
80009376:	16 09       	add	r9,r11
80009378:	2f f8       	sub	r8,-1
8000937a:	87 06       	st.w	r3[0x0],r6
8000937c:	fb 49 06 90 	st.w	sp[1680],r9
80009380:	87 1b       	st.w	r3[0x4],r11
80009382:	fb 48 06 8c 	st.w	sp[1676],r8
80009386:	58 78       	cp.w	r8,7
80009388:	e0 89 00 04 	brgt	80009390 <_vfprintf_r+0x1b48>
8000938c:	2f 83       	sub	r3,-8
8000938e:	c0 b8       	rjmp	800093a4 <_vfprintf_r+0x1b5c>
80009390:	fa ca f9 78 	sub	r10,sp,-1672
80009394:	02 9b       	mov	r11,r1
80009396:	08 9c       	mov	r12,r4
80009398:	fe b0 f2 4a 	rcall	8000782c <__sprint_r>
8000939c:	e0 81 01 d5 	brne	80009746 <_vfprintf_r+0x1efe>
800093a0:	fa c3 f9 e0 	sub	r3,sp,-1568
800093a4:	fa f6 06 ac 	ld.w	r6,sp[1708]
800093a8:	40 6a       	lddsp	r10,sp[0x18]
800093aa:	14 16       	sub	r6,r10
800093ac:	58 06       	cp.w	r6,0
800093ae:	e0 89 00 1c 	brgt	800093e6 <_vfprintf_r+0x1b9e>
800093b2:	c3 d8       	rjmp	8000942c <_vfprintf_r+0x1be4>
800093b4:	2f 09       	sub	r9,-16
800093b6:	2f f8       	sub	r8,-1
800093b8:	fb 49 06 90 	st.w	sp[1680],r9
800093bc:	87 02       	st.w	r3[0x0],r2
800093be:	87 10       	st.w	r3[0x4],r0
800093c0:	fb 48 06 8c 	st.w	sp[1676],r8
800093c4:	58 78       	cp.w	r8,7
800093c6:	e0 89 00 04 	brgt	800093ce <_vfprintf_r+0x1b86>
800093ca:	2f 83       	sub	r3,-8
800093cc:	c0 b8       	rjmp	800093e2 <_vfprintf_r+0x1b9a>
800093ce:	fa ca f9 78 	sub	r10,sp,-1672
800093d2:	02 9b       	mov	r11,r1
800093d4:	08 9c       	mov	r12,r4
800093d6:	fe b0 f2 2b 	rcall	8000782c <__sprint_r>
800093da:	e0 81 01 b6 	brne	80009746 <_vfprintf_r+0x1efe>
800093de:	fa c3 f9 e0 	sub	r3,sp,-1568
800093e2:	21 06       	sub	r6,16
800093e4:	c0 48       	rjmp	800093ec <_vfprintf_r+0x1ba4>
800093e6:	fe c2 bd 3a 	sub	r2,pc,-17094
800093ea:	31 00       	mov	r0,16
800093ec:	fa f9 06 90 	ld.w	r9,sp[1680]
800093f0:	fa f8 06 8c 	ld.w	r8,sp[1676]
800093f4:	fe ca bd 48 	sub	r10,pc,-17080
800093f8:	59 06       	cp.w	r6,16
800093fa:	fe 99 ff dd 	brgt	800093b4 <_vfprintf_r+0x1b6c>
800093fe:	0c 09       	add	r9,r6
80009400:	2f f8       	sub	r8,-1
80009402:	87 0a       	st.w	r3[0x0],r10
80009404:	fb 49 06 90 	st.w	sp[1680],r9
80009408:	87 16       	st.w	r3[0x4],r6
8000940a:	fb 48 06 8c 	st.w	sp[1676],r8
8000940e:	58 78       	cp.w	r8,7
80009410:	e0 89 00 04 	brgt	80009418 <_vfprintf_r+0x1bd0>
80009414:	2f 83       	sub	r3,-8
80009416:	c0 b8       	rjmp	8000942c <_vfprintf_r+0x1be4>
80009418:	fa ca f9 78 	sub	r10,sp,-1672
8000941c:	02 9b       	mov	r11,r1
8000941e:	08 9c       	mov	r12,r4
80009420:	fe b0 f2 06 	rcall	8000782c <__sprint_r>
80009424:	e0 81 01 91 	brne	80009746 <_vfprintf_r+0x1efe>
80009428:	fa c3 f9 e0 	sub	r3,sp,-1568
8000942c:	ed b5 00 00 	bld	r5,0x0
80009430:	e0 81 01 20 	brne	80009670 <_vfprintf_r+0x1e28>
80009434:	40 c9       	lddsp	r9,sp[0x30]
80009436:	fa f8 06 90 	ld.w	r8,sp[1680]
8000943a:	2f f8       	sub	r8,-1
8000943c:	87 09       	st.w	r3[0x0],r9
8000943e:	fb 48 06 90 	st.w	sp[1680],r8
80009442:	30 19       	mov	r9,1
80009444:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009448:	87 19       	st.w	r3[0x4],r9
8000944a:	2f f8       	sub	r8,-1
8000944c:	fb 48 06 8c 	st.w	sp[1676],r8
80009450:	c0 29       	rjmp	80009654 <_vfprintf_r+0x1e0c>
80009452:	14 09       	add	r9,r10
80009454:	2f f8       	sub	r8,-1
80009456:	fb 49 06 90 	st.w	sp[1680],r9
8000945a:	87 06       	st.w	r3[0x0],r6
8000945c:	87 1a       	st.w	r3[0x4],r10
8000945e:	fb 48 06 8c 	st.w	sp[1676],r8
80009462:	58 78       	cp.w	r8,7
80009464:	e0 89 00 04 	brgt	8000946c <_vfprintf_r+0x1c24>
80009468:	2f 83       	sub	r3,-8
8000946a:	c0 b8       	rjmp	80009480 <_vfprintf_r+0x1c38>
8000946c:	fa ca f9 78 	sub	r10,sp,-1672
80009470:	02 9b       	mov	r11,r1
80009472:	08 9c       	mov	r12,r4
80009474:	fe b0 f1 dc 	rcall	8000782c <__sprint_r>
80009478:	e0 81 01 67 	brne	80009746 <_vfprintf_r+0x1efe>
8000947c:	fa c3 f9 e0 	sub	r3,sp,-1568
80009480:	40 c8       	lddsp	r8,sp[0x30]
80009482:	87 08       	st.w	r3[0x0],r8
80009484:	fa f8 06 90 	ld.w	r8,sp[1680]
80009488:	2f f8       	sub	r8,-1
8000948a:	30 19       	mov	r9,1
8000948c:	fb 48 06 90 	st.w	sp[1680],r8
80009490:	87 19       	st.w	r3[0x4],r9
80009492:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009496:	2f f8       	sub	r8,-1
80009498:	fb 48 06 8c 	st.w	sp[1676],r8
8000949c:	fa f2 06 ac 	ld.w	r2,sp[1708]
800094a0:	58 78       	cp.w	r8,7
800094a2:	e0 89 00 04 	brgt	800094aa <_vfprintf_r+0x1c62>
800094a6:	2f 83       	sub	r3,-8
800094a8:	c0 b8       	rjmp	800094be <_vfprintf_r+0x1c76>
800094aa:	fa ca f9 78 	sub	r10,sp,-1672
800094ae:	02 9b       	mov	r11,r1
800094b0:	08 9c       	mov	r12,r4
800094b2:	fe b0 f1 bd 	rcall	8000782c <__sprint_r>
800094b6:	e0 81 01 48 	brne	80009746 <_vfprintf_r+0x1efe>
800094ba:	fa c3 f9 e0 	sub	r3,sp,-1568
800094be:	04 06       	add	r6,r2
800094c0:	fa f8 06 ac 	ld.w	r8,sp[1708]
800094c4:	87 06       	st.w	r3[0x0],r6
800094c6:	fa f9 06 90 	ld.w	r9,sp[1680]
800094ca:	40 66       	lddsp	r6,sp[0x18]
800094cc:	40 6e       	lddsp	lr,sp[0x18]
800094ce:	10 16       	sub	r6,r8
800094d0:	f2 08 01 08 	sub	r8,r9,r8
800094d4:	87 16       	st.w	r3[0x4],r6
800094d6:	1c 08       	add	r8,lr
800094d8:	fb 48 06 90 	st.w	sp[1680],r8
800094dc:	fa f8 06 8c 	ld.w	r8,sp[1676]
800094e0:	2f f8       	sub	r8,-1
800094e2:	fb 48 06 8c 	st.w	sp[1676],r8
800094e6:	cb 78       	rjmp	80009654 <_vfprintf_r+0x1e0c>
800094e8:	40 6c       	lddsp	r12,sp[0x18]
800094ea:	58 1c       	cp.w	r12,1
800094ec:	e0 89 00 06 	brgt	800094f8 <_vfprintf_r+0x1cb0>
800094f0:	ed b5 00 00 	bld	r5,0x0
800094f4:	e0 81 00 85 	brne	800095fe <_vfprintf_r+0x1db6>
800094f8:	fa f8 06 90 	ld.w	r8,sp[1680]
800094fc:	2f f8       	sub	r8,-1
800094fe:	30 19       	mov	r9,1
80009500:	fb 48 06 90 	st.w	sp[1680],r8
80009504:	87 06       	st.w	r3[0x0],r6
80009506:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000950a:	87 19       	st.w	r3[0x4],r9
8000950c:	2f f8       	sub	r8,-1
8000950e:	fb 48 06 8c 	st.w	sp[1676],r8
80009512:	58 78       	cp.w	r8,7
80009514:	e0 89 00 04 	brgt	8000951c <_vfprintf_r+0x1cd4>
80009518:	2f 83       	sub	r3,-8
8000951a:	c0 b8       	rjmp	80009530 <_vfprintf_r+0x1ce8>
8000951c:	fa ca f9 78 	sub	r10,sp,-1672
80009520:	02 9b       	mov	r11,r1
80009522:	08 9c       	mov	r12,r4
80009524:	fe b0 f1 84 	rcall	8000782c <__sprint_r>
80009528:	e0 81 01 0f 	brne	80009746 <_vfprintf_r+0x1efe>
8000952c:	fa c3 f9 e0 	sub	r3,sp,-1568
80009530:	fa f8 06 90 	ld.w	r8,sp[1680]
80009534:	2f f8       	sub	r8,-1
80009536:	40 cb       	lddsp	r11,sp[0x30]
80009538:	fb 48 06 90 	st.w	sp[1680],r8
8000953c:	30 19       	mov	r9,1
8000953e:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009542:	87 0b       	st.w	r3[0x0],r11
80009544:	2f f8       	sub	r8,-1
80009546:	87 19       	st.w	r3[0x4],r9
80009548:	fb 48 06 8c 	st.w	sp[1676],r8
8000954c:	58 78       	cp.w	r8,7
8000954e:	e0 89 00 05 	brgt	80009558 <_vfprintf_r+0x1d10>
80009552:	2f 83       	sub	r3,-8
80009554:	c0 c8       	rjmp	8000956c <_vfprintf_r+0x1d24>
80009556:	d7 03       	nop
80009558:	fa ca f9 78 	sub	r10,sp,-1672
8000955c:	02 9b       	mov	r11,r1
8000955e:	08 9c       	mov	r12,r4
80009560:	fe b0 f1 66 	rcall	8000782c <__sprint_r>
80009564:	e0 81 00 f1 	brne	80009746 <_vfprintf_r+0x1efe>
80009568:	fa c3 f9 e0 	sub	r3,sp,-1568
8000956c:	30 08       	mov	r8,0
8000956e:	30 09       	mov	r9,0
80009570:	40 5b       	lddsp	r11,sp[0x14]
80009572:	40 7a       	lddsp	r10,sp[0x1c]
80009574:	e0 a0 13 25 	rcall	8000bbbe <__avr32_f64_cmp_eq>
80009578:	40 68       	lddsp	r8,sp[0x18]
8000957a:	20 18       	sub	r8,1
8000957c:	58 0c       	cp.w	r12,0
8000957e:	c0 d1       	brne	80009598 <_vfprintf_r+0x1d50>
80009580:	2f f6       	sub	r6,-1
80009582:	87 18       	st.w	r3[0x4],r8
80009584:	87 06       	st.w	r3[0x0],r6
80009586:	fa f6 06 90 	ld.w	r6,sp[1680]
8000958a:	10 06       	add	r6,r8
8000958c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009590:	fb 46 06 90 	st.w	sp[1680],r6
80009594:	2f f8       	sub	r8,-1
80009596:	c3 18       	rjmp	800095f8 <_vfprintf_r+0x1db0>
80009598:	10 96       	mov	r6,r8
8000959a:	58 08       	cp.w	r8,0
8000959c:	e0 89 00 1c 	brgt	800095d4 <_vfprintf_r+0x1d8c>
800095a0:	c4 b8       	rjmp	80009636 <_vfprintf_r+0x1dee>
800095a2:	2f 09       	sub	r9,-16
800095a4:	2f f8       	sub	r8,-1
800095a6:	fb 49 06 90 	st.w	sp[1680],r9
800095aa:	87 02       	st.w	r3[0x0],r2
800095ac:	87 10       	st.w	r3[0x4],r0
800095ae:	fb 48 06 8c 	st.w	sp[1676],r8
800095b2:	58 78       	cp.w	r8,7
800095b4:	e0 89 00 04 	brgt	800095bc <_vfprintf_r+0x1d74>
800095b8:	2f 83       	sub	r3,-8
800095ba:	c0 b8       	rjmp	800095d0 <_vfprintf_r+0x1d88>
800095bc:	fa ca f9 78 	sub	r10,sp,-1672
800095c0:	02 9b       	mov	r11,r1
800095c2:	08 9c       	mov	r12,r4
800095c4:	fe b0 f1 34 	rcall	8000782c <__sprint_r>
800095c8:	e0 81 00 bf 	brne	80009746 <_vfprintf_r+0x1efe>
800095cc:	fa c3 f9 e0 	sub	r3,sp,-1568
800095d0:	21 06       	sub	r6,16
800095d2:	c0 48       	rjmp	800095da <_vfprintf_r+0x1d92>
800095d4:	fe c2 bf 28 	sub	r2,pc,-16600
800095d8:	31 00       	mov	r0,16
800095da:	fa f9 06 90 	ld.w	r9,sp[1680]
800095de:	fa f8 06 8c 	ld.w	r8,sp[1676]
800095e2:	fe ca bf 36 	sub	r10,pc,-16586
800095e6:	59 06       	cp.w	r6,16
800095e8:	fe 99 ff dd 	brgt	800095a2 <_vfprintf_r+0x1d5a>
800095ec:	0c 09       	add	r9,r6
800095ee:	87 0a       	st.w	r3[0x0],r10
800095f0:	fb 49 06 90 	st.w	sp[1680],r9
800095f4:	2f f8       	sub	r8,-1
800095f6:	87 16       	st.w	r3[0x4],r6
800095f8:	fb 48 06 8c 	st.w	sp[1676],r8
800095fc:	c0 e8       	rjmp	80009618 <_vfprintf_r+0x1dd0>
800095fe:	fa f8 06 90 	ld.w	r8,sp[1680]
80009602:	2f f8       	sub	r8,-1
80009604:	30 19       	mov	r9,1
80009606:	fb 48 06 90 	st.w	sp[1680],r8
8000960a:	87 06       	st.w	r3[0x0],r6
8000960c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009610:	87 19       	st.w	r3[0x4],r9
80009612:	2f f8       	sub	r8,-1
80009614:	fb 48 06 8c 	st.w	sp[1676],r8
80009618:	58 78       	cp.w	r8,7
8000961a:	e0 89 00 04 	brgt	80009622 <_vfprintf_r+0x1dda>
8000961e:	2f 83       	sub	r3,-8
80009620:	c0 b8       	rjmp	80009636 <_vfprintf_r+0x1dee>
80009622:	fa ca f9 78 	sub	r10,sp,-1672
80009626:	02 9b       	mov	r11,r1
80009628:	08 9c       	mov	r12,r4
8000962a:	fe b0 f1 01 	rcall	8000782c <__sprint_r>
8000962e:	e0 81 00 8c 	brne	80009746 <_vfprintf_r+0x1efe>
80009632:	fa c3 f9 e0 	sub	r3,sp,-1568
80009636:	40 ea       	lddsp	r10,sp[0x38]
80009638:	fa f8 06 90 	ld.w	r8,sp[1680]
8000963c:	14 08       	add	r8,r10
8000963e:	fa c9 f9 64 	sub	r9,sp,-1692
80009642:	fb 48 06 90 	st.w	sp[1680],r8
80009646:	87 1a       	st.w	r3[0x4],r10
80009648:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000964c:	87 09       	st.w	r3[0x0],r9
8000964e:	2f f8       	sub	r8,-1
80009650:	fb 48 06 8c 	st.w	sp[1676],r8
80009654:	58 78       	cp.w	r8,7
80009656:	e0 89 00 04 	brgt	8000965e <_vfprintf_r+0x1e16>
8000965a:	2f 83       	sub	r3,-8
8000965c:	c0 a8       	rjmp	80009670 <_vfprintf_r+0x1e28>
8000965e:	fa ca f9 78 	sub	r10,sp,-1672
80009662:	02 9b       	mov	r11,r1
80009664:	08 9c       	mov	r12,r4
80009666:	fe b0 f0 e3 	rcall	8000782c <__sprint_r>
8000966a:	c6 e1       	brne	80009746 <_vfprintf_r+0x1efe>
8000966c:	fa c3 f9 e0 	sub	r3,sp,-1568
80009670:	e2 15 00 04 	andl	r5,0x4,COH
80009674:	c3 f0       	breq	800096f2 <_vfprintf_r+0x1eaa>
80009676:	40 86       	lddsp	r6,sp[0x20]
80009678:	40 39       	lddsp	r9,sp[0xc]
8000967a:	12 16       	sub	r6,r9
8000967c:	58 06       	cp.w	r6,0
8000967e:	e0 89 00 1a 	brgt	800096b2 <_vfprintf_r+0x1e6a>
80009682:	c3 88       	rjmp	800096f2 <_vfprintf_r+0x1eaa>
80009684:	2f 09       	sub	r9,-16
80009686:	2f f8       	sub	r8,-1
80009688:	fb 49 06 90 	st.w	sp[1680],r9
8000968c:	87 05       	st.w	r3[0x0],r5
8000968e:	87 12       	st.w	r3[0x4],r2
80009690:	fb 48 06 8c 	st.w	sp[1676],r8
80009694:	58 78       	cp.w	r8,7
80009696:	e0 89 00 04 	brgt	8000969e <_vfprintf_r+0x1e56>
8000969a:	2f 83       	sub	r3,-8
8000969c:	c0 98       	rjmp	800096ae <_vfprintf_r+0x1e66>
8000969e:	00 9a       	mov	r10,r0
800096a0:	02 9b       	mov	r11,r1
800096a2:	08 9c       	mov	r12,r4
800096a4:	fe b0 f0 c4 	rcall	8000782c <__sprint_r>
800096a8:	c4 f1       	brne	80009746 <_vfprintf_r+0x1efe>
800096aa:	fa c3 f9 e0 	sub	r3,sp,-1568
800096ae:	21 06       	sub	r6,16
800096b0:	c0 68       	rjmp	800096bc <_vfprintf_r+0x1e74>
800096b2:	fe c5 c0 16 	sub	r5,pc,-16362
800096b6:	31 02       	mov	r2,16
800096b8:	fa c0 f9 78 	sub	r0,sp,-1672
800096bc:	fa f9 06 90 	ld.w	r9,sp[1680]
800096c0:	fa f8 06 8c 	ld.w	r8,sp[1676]
800096c4:	fe ca c0 28 	sub	r10,pc,-16344
800096c8:	59 06       	cp.w	r6,16
800096ca:	fe 99 ff dd 	brgt	80009684 <_vfprintf_r+0x1e3c>
800096ce:	0c 09       	add	r9,r6
800096d0:	2f f8       	sub	r8,-1
800096d2:	87 0a       	st.w	r3[0x0],r10
800096d4:	87 16       	st.w	r3[0x4],r6
800096d6:	fb 49 06 90 	st.w	sp[1680],r9
800096da:	fb 48 06 8c 	st.w	sp[1676],r8
800096de:	58 78       	cp.w	r8,7
800096e0:	e0 8a 00 09 	brle	800096f2 <_vfprintf_r+0x1eaa>
800096e4:	fa ca f9 78 	sub	r10,sp,-1672
800096e8:	02 9b       	mov	r11,r1
800096ea:	08 9c       	mov	r12,r4
800096ec:	fe b0 f0 a0 	rcall	8000782c <__sprint_r>
800096f0:	c2 b1       	brne	80009746 <_vfprintf_r+0x1efe>
800096f2:	40 bc       	lddsp	r12,sp[0x2c]
800096f4:	40 36       	lddsp	r6,sp[0xc]
800096f6:	40 8e       	lddsp	lr,sp[0x20]
800096f8:	ec 0e 0c 48 	max	r8,r6,lr
800096fc:	10 0c       	add	r12,r8
800096fe:	50 bc       	stdsp	sp[0x2c],r12
80009700:	fa f8 06 90 	ld.w	r8,sp[1680]
80009704:	58 08       	cp.w	r8,0
80009706:	c0 80       	breq	80009716 <_vfprintf_r+0x1ece>
80009708:	fa ca f9 78 	sub	r10,sp,-1672
8000970c:	02 9b       	mov	r11,r1
8000970e:	08 9c       	mov	r12,r4
80009710:	fe b0 f0 8e 	rcall	8000782c <__sprint_r>
80009714:	c1 91       	brne	80009746 <_vfprintf_r+0x1efe>
80009716:	30 0b       	mov	r11,0
80009718:	fa c3 f9 e0 	sub	r3,sp,-1568
8000971c:	fb 4b 06 8c 	st.w	sp[1676],r11
80009720:	fe 9f f1 22 	bral	80007964 <_vfprintf_r+0x11c>
80009724:	08 95       	mov	r5,r4
80009726:	fa f8 06 90 	ld.w	r8,sp[1680]
8000972a:	58 08       	cp.w	r8,0
8000972c:	c0 80       	breq	8000973c <_vfprintf_r+0x1ef4>
8000972e:	08 9c       	mov	r12,r4
80009730:	fa ca f9 78 	sub	r10,sp,-1672
80009734:	02 9b       	mov	r11,r1
80009736:	fe b0 f0 7b 	rcall	8000782c <__sprint_r>
8000973a:	c0 61       	brne	80009746 <_vfprintf_r+0x1efe>
8000973c:	30 08       	mov	r8,0
8000973e:	fb 48 06 8c 	st.w	sp[1676],r8
80009742:	c0 28       	rjmp	80009746 <_vfprintf_r+0x1efe>
80009744:	40 41       	lddsp	r1,sp[0x10]
80009746:	82 68       	ld.sh	r8,r1[0xc]
80009748:	ed b8 00 06 	bld	r8,0x6
8000974c:	c0 31       	brne	80009752 <_vfprintf_r+0x1f0a>
8000974e:	3f fa       	mov	r10,-1
80009750:	50 ba       	stdsp	sp[0x2c],r10
80009752:	40 bc       	lddsp	r12,sp[0x2c]
80009754:	fe 3d f9 44 	sub	sp,-1724
80009758:	d8 32       	popm	r0-r7,pc
8000975a:	d7 03       	nop

8000975c <__swsetup_r>:
8000975c:	d4 21       	pushm	r4-r7,lr
8000975e:	e0 68 0a 38 	mov	r8,2616
80009762:	18 96       	mov	r6,r12
80009764:	16 97       	mov	r7,r11
80009766:	70 0c       	ld.w	r12,r8[0x0]
80009768:	58 0c       	cp.w	r12,0
8000976a:	c0 60       	breq	80009776 <__swsetup_r+0x1a>
8000976c:	78 68       	ld.w	r8,r12[0x18]
8000976e:	58 08       	cp.w	r8,0
80009770:	c0 31       	brne	80009776 <__swsetup_r+0x1a>
80009772:	e0 a0 07 bf 	rcall	8000a6f0 <__sinit>
80009776:	fe c8 bf aa 	sub	r8,pc,-16470
8000977a:	10 37       	cp.w	r7,r8
8000977c:	c0 61       	brne	80009788 <__swsetup_r+0x2c>
8000977e:	e0 68 0a 38 	mov	r8,2616
80009782:	70 08       	ld.w	r8,r8[0x0]
80009784:	70 07       	ld.w	r7,r8[0x0]
80009786:	c1 28       	rjmp	800097aa <__swsetup_r+0x4e>
80009788:	fe c8 bf 9c 	sub	r8,pc,-16484
8000978c:	10 37       	cp.w	r7,r8
8000978e:	c0 61       	brne	8000979a <__swsetup_r+0x3e>
80009790:	e0 68 0a 38 	mov	r8,2616
80009794:	70 08       	ld.w	r8,r8[0x0]
80009796:	70 17       	ld.w	r7,r8[0x4]
80009798:	c0 98       	rjmp	800097aa <__swsetup_r+0x4e>
8000979a:	fe c8 bf 8e 	sub	r8,pc,-16498
8000979e:	10 37       	cp.w	r7,r8
800097a0:	c0 51       	brne	800097aa <__swsetup_r+0x4e>
800097a2:	e0 68 0a 38 	mov	r8,2616
800097a6:	70 08       	ld.w	r8,r8[0x0]
800097a8:	70 27       	ld.w	r7,r8[0x8]
800097aa:	8e 68       	ld.sh	r8,r7[0xc]
800097ac:	ed b8 00 03 	bld	r8,0x3
800097b0:	c1 e0       	breq	800097ec <__swsetup_r+0x90>
800097b2:	ed b8 00 04 	bld	r8,0x4
800097b6:	c3 e1       	brne	80009832 <__swsetup_r+0xd6>
800097b8:	ed b8 00 02 	bld	r8,0x2
800097bc:	c1 51       	brne	800097e6 <__swsetup_r+0x8a>
800097be:	6e db       	ld.w	r11,r7[0x34]
800097c0:	58 0b       	cp.w	r11,0
800097c2:	c0 a0       	breq	800097d6 <__swsetup_r+0x7a>
800097c4:	ee c8 ff bc 	sub	r8,r7,-68
800097c8:	10 3b       	cp.w	r11,r8
800097ca:	c0 40       	breq	800097d2 <__swsetup_r+0x76>
800097cc:	0c 9c       	mov	r12,r6
800097ce:	e0 a0 08 2b 	rcall	8000a824 <_free_r>
800097d2:	30 08       	mov	r8,0
800097d4:	8f d8       	st.w	r7[0x34],r8
800097d6:	8e 68       	ld.sh	r8,r7[0xc]
800097d8:	e0 18 ff db 	andl	r8,0xffdb
800097dc:	ae 68       	st.h	r7[0xc],r8
800097de:	30 08       	mov	r8,0
800097e0:	8f 18       	st.w	r7[0x4],r8
800097e2:	6e 48       	ld.w	r8,r7[0x10]
800097e4:	8f 08       	st.w	r7[0x0],r8
800097e6:	8e 68       	ld.sh	r8,r7[0xc]
800097e8:	a3 b8       	sbr	r8,0x3
800097ea:	ae 68       	st.h	r7[0xc],r8
800097ec:	6e 48       	ld.w	r8,r7[0x10]
800097ee:	58 08       	cp.w	r8,0
800097f0:	c0 b1       	brne	80009806 <__swsetup_r+0xaa>
800097f2:	8e 68       	ld.sh	r8,r7[0xc]
800097f4:	e2 18 02 80 	andl	r8,0x280,COH
800097f8:	e0 48 02 00 	cp.w	r8,512
800097fc:	c0 50       	breq	80009806 <__swsetup_r+0xaa>
800097fe:	0c 9c       	mov	r12,r6
80009800:	0e 9b       	mov	r11,r7
80009802:	e0 a0 0a 4b 	rcall	8000ac98 <__smakebuf_r>
80009806:	8e 69       	ld.sh	r9,r7[0xc]
80009808:	f1 d9 c0 01 	bfextu	r8,r9,0x0,0x1
8000980c:	c0 70       	breq	8000981a <__swsetup_r+0xbe>
8000980e:	30 08       	mov	r8,0
80009810:	8f 28       	st.w	r7[0x8],r8
80009812:	6e 58       	ld.w	r8,r7[0x14]
80009814:	5c 38       	neg	r8
80009816:	8f 68       	st.w	r7[0x18],r8
80009818:	c0 68       	rjmp	80009824 <__swsetup_r+0xc8>
8000981a:	ed b9 00 01 	bld	r9,0x1
8000981e:	ef f8 10 05 	ld.wne	r8,r7[0x14]
80009822:	8f 28       	st.w	r7[0x8],r8
80009824:	6e 48       	ld.w	r8,r7[0x10]
80009826:	58 08       	cp.w	r8,0
80009828:	c0 61       	brne	80009834 <__swsetup_r+0xd8>
8000982a:	8e 68       	ld.sh	r8,r7[0xc]
8000982c:	ed b8 00 07 	bld	r8,0x7
80009830:	c0 21       	brne	80009834 <__swsetup_r+0xd8>
80009832:	dc 2a       	popm	r4-r7,pc,r12=-1
80009834:	d8 2a       	popm	r4-r7,pc,r12=0
80009836:	d7 03       	nop

80009838 <quorem>:
80009838:	d4 31       	pushm	r0-r7,lr
8000983a:	20 2d       	sub	sp,8
8000983c:	18 97       	mov	r7,r12
8000983e:	78 48       	ld.w	r8,r12[0x10]
80009840:	76 46       	ld.w	r6,r11[0x10]
80009842:	0c 38       	cp.w	r8,r6
80009844:	c0 34       	brge	8000984a <quorem+0x12>
80009846:	30 0c       	mov	r12,0
80009848:	c8 58       	rjmp	80009952 <quorem+0x11a>
8000984a:	ec c2 ff fc 	sub	r2,r6,-4
8000984e:	f6 c3 ff ec 	sub	r3,r11,-20
80009852:	f6 02 03 29 	ld.w	r9,r11[r2<<0x2]
80009856:	f8 02 03 2c 	ld.w	r12,r12[r2<<0x2]
8000985a:	2f f9       	sub	r9,-1
8000985c:	20 16       	sub	r6,1
8000985e:	f8 09 0d 08 	divu	r8,r12,r9
80009862:	f6 02 00 22 	add	r2,r11,r2<<0x2
80009866:	ee c4 ff ec 	sub	r4,r7,-20
8000986a:	10 95       	mov	r5,r8
8000986c:	58 08       	cp.w	r8,0
8000986e:	c4 10       	breq	800098f0 <quorem+0xb8>
80009870:	30 09       	mov	r9,0
80009872:	06 9a       	mov	r10,r3
80009874:	08 98       	mov	r8,r4
80009876:	12 91       	mov	r1,r9
80009878:	50 0b       	stdsp	sp[0x0],r11
8000987a:	70 0e       	ld.w	lr,r8[0x0]
8000987c:	b1 8e       	lsr	lr,0x10
8000987e:	50 1e       	stdsp	sp[0x4],lr
80009880:	15 0e       	ld.w	lr,r10++
80009882:	fc 00 16 10 	lsr	r0,lr,0x10
80009886:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000988a:	ea 0e 03 41 	mac	r1,r5,lr
8000988e:	fd d1 c0 10 	bfextu	lr,r1,0x0,0x10
80009892:	b1 81       	lsr	r1,0x10
80009894:	40 1b       	lddsp	r11,sp[0x4]
80009896:	ea 00 02 40 	mul	r0,r5,r0
8000989a:	e2 00 00 00 	add	r0,r1,r0
8000989e:	e3 d0 c0 10 	bfextu	r1,r0,0x0,0x10
800098a2:	02 1b       	sub	r11,r1
800098a4:	50 1b       	stdsp	sp[0x4],r11
800098a6:	70 0b       	ld.w	r11,r8[0x0]
800098a8:	e3 db c0 10 	bfextu	r1,r11,0x0,0x10
800098ac:	02 09       	add	r9,r1
800098ae:	f2 0e 01 0e 	sub	lr,r9,lr
800098b2:	b0 1e       	st.h	r8[0x2],lr
800098b4:	fc 09 14 10 	asr	r9,lr,0x10
800098b8:	40 1e       	lddsp	lr,sp[0x4]
800098ba:	fc 09 00 09 	add	r9,lr,r9
800098be:	b0 09       	st.h	r8[0x0],r9
800098c0:	e0 01 16 10 	lsr	r1,r0,0x10
800098c4:	2f c8       	sub	r8,-4
800098c6:	b1 49       	asr	r9,0x10
800098c8:	04 3a       	cp.w	r10,r2
800098ca:	fe 98 ff d8 	brls	8000987a <quorem+0x42>
800098ce:	40 0b       	lddsp	r11,sp[0x0]
800098d0:	58 0c       	cp.w	r12,0
800098d2:	c0 f1       	brne	800098f0 <quorem+0xb8>
800098d4:	ec c8 ff fb 	sub	r8,r6,-5
800098d8:	ee 08 00 28 	add	r8,r7,r8<<0x2
800098dc:	c0 28       	rjmp	800098e0 <quorem+0xa8>
800098de:	20 16       	sub	r6,1
800098e0:	20 48       	sub	r8,4
800098e2:	08 38       	cp.w	r8,r4
800098e4:	e0 88 00 05 	brls	800098ee <quorem+0xb6>
800098e8:	70 09       	ld.w	r9,r8[0x0]
800098ea:	58 09       	cp.w	r9,0
800098ec:	cf 90       	breq	800098de <quorem+0xa6>
800098ee:	8f 46       	st.w	r7[0x10],r6
800098f0:	0e 9c       	mov	r12,r7
800098f2:	e0 a0 0a d2 	rcall	8000ae96 <__mcmp>
800098f6:	c2 d5       	brlt	80009950 <quorem+0x118>
800098f8:	2f f5       	sub	r5,-1
800098fa:	08 98       	mov	r8,r4
800098fc:	30 09       	mov	r9,0
800098fe:	07 0b       	ld.w	r11,r3++
80009900:	f6 0a 16 10 	lsr	r10,r11,0x10
80009904:	70 0c       	ld.w	r12,r8[0x0]
80009906:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000990a:	f8 0e 16 10 	lsr	lr,r12,0x10
8000990e:	14 1e       	sub	lr,r10
80009910:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
80009914:	16 1a       	sub	r10,r11
80009916:	12 0a       	add	r10,r9
80009918:	b0 1a       	st.h	r8[0x2],r10
8000991a:	b1 4a       	asr	r10,0x10
8000991c:	fc 0a 00 09 	add	r9,lr,r10
80009920:	b0 09       	st.h	r8[0x0],r9
80009922:	2f c8       	sub	r8,-4
80009924:	b1 49       	asr	r9,0x10
80009926:	04 33       	cp.w	r3,r2
80009928:	fe 98 ff eb 	brls	800098fe <quorem+0xc6>
8000992c:	ec c8 ff fb 	sub	r8,r6,-5
80009930:	ee 08 03 29 	ld.w	r9,r7[r8<<0x2]
80009934:	58 09       	cp.w	r9,0
80009936:	c0 d1       	brne	80009950 <quorem+0x118>
80009938:	ee 08 00 28 	add	r8,r7,r8<<0x2
8000993c:	c0 28       	rjmp	80009940 <quorem+0x108>
8000993e:	20 16       	sub	r6,1
80009940:	20 48       	sub	r8,4
80009942:	08 38       	cp.w	r8,r4
80009944:	e0 88 00 05 	brls	8000994e <quorem+0x116>
80009948:	70 09       	ld.w	r9,r8[0x0]
8000994a:	58 09       	cp.w	r9,0
8000994c:	cf 90       	breq	8000993e <quorem+0x106>
8000994e:	8f 46       	st.w	r7[0x10],r6
80009950:	0a 9c       	mov	r12,r5
80009952:	2f ed       	sub	sp,-8
80009954:	d8 32       	popm	r0-r7,pc
80009956:	d7 03       	nop

80009958 <_dtoa_r>:
80009958:	d4 31       	pushm	r0-r7,lr
8000995a:	21 ad       	sub	sp,104
8000995c:	fa c4 ff 74 	sub	r4,sp,-140
80009960:	18 97       	mov	r7,r12
80009962:	16 95       	mov	r5,r11
80009964:	68 2c       	ld.w	r12,r4[0x8]
80009966:	50 c9       	stdsp	sp[0x30],r9
80009968:	68 16       	ld.w	r6,r4[0x4]
8000996a:	68 09       	ld.w	r9,r4[0x0]
8000996c:	50 e8       	stdsp	sp[0x38],r8
8000996e:	14 94       	mov	r4,r10
80009970:	51 2c       	stdsp	sp[0x48],r12
80009972:	fa e5 00 08 	st.d	sp[8],r4
80009976:	51 59       	stdsp	sp[0x54],r9
80009978:	6e 95       	ld.w	r5,r7[0x24]
8000997a:	58 05       	cp.w	r5,0
8000997c:	c0 91       	brne	8000998e <_dtoa_r+0x36>
8000997e:	31 0c       	mov	r12,16
80009980:	fe b0 e8 e2 	rcall	80006b44 <malloc>
80009984:	99 35       	st.w	r12[0xc],r5
80009986:	8f 9c       	st.w	r7[0x24],r12
80009988:	99 15       	st.w	r12[0x4],r5
8000998a:	99 25       	st.w	r12[0x8],r5
8000998c:	99 05       	st.w	r12[0x0],r5
8000998e:	6e 99       	ld.w	r9,r7[0x24]
80009990:	72 08       	ld.w	r8,r9[0x0]
80009992:	58 08       	cp.w	r8,0
80009994:	c0 f0       	breq	800099b2 <_dtoa_r+0x5a>
80009996:	72 1a       	ld.w	r10,r9[0x4]
80009998:	91 1a       	st.w	r8[0x4],r10
8000999a:	30 1a       	mov	r10,1
8000999c:	72 19       	ld.w	r9,r9[0x4]
8000999e:	f4 09 09 49 	lsl	r9,r10,r9
800099a2:	10 9b       	mov	r11,r8
800099a4:	91 29       	st.w	r8[0x8],r9
800099a6:	0e 9c       	mov	r12,r7
800099a8:	e0 a0 0a 90 	rcall	8000aec8 <_Bfree>
800099ac:	6e 98       	ld.w	r8,r7[0x24]
800099ae:	30 09       	mov	r9,0
800099b0:	91 09       	st.w	r8[0x0],r9
800099b2:	40 28       	lddsp	r8,sp[0x8]
800099b4:	10 94       	mov	r4,r8
800099b6:	58 08       	cp.w	r8,0
800099b8:	c0 64       	brge	800099c4 <_dtoa_r+0x6c>
800099ba:	f1 d8 c0 1f 	bfextu	r8,r8,0x0,0x1f
800099be:	50 28       	stdsp	sp[0x8],r8
800099c0:	30 18       	mov	r8,1
800099c2:	c0 28       	rjmp	800099c6 <_dtoa_r+0x6e>
800099c4:	30 08       	mov	r8,0
800099c6:	8d 08       	st.w	r6[0x0],r8
800099c8:	fc 1c 7f f0 	movh	r12,0x7ff0
800099cc:	40 26       	lddsp	r6,sp[0x8]
800099ce:	0c 98       	mov	r8,r6
800099d0:	e6 18 7f f0 	andh	r8,0x7ff0,COH
800099d4:	18 38       	cp.w	r8,r12
800099d6:	c2 01       	brne	80009a16 <_dtoa_r+0xbe>
800099d8:	e0 68 27 0f 	mov	r8,9999
800099dc:	41 5b       	lddsp	r11,sp[0x54]
800099de:	97 08       	st.w	r11[0x0],r8
800099e0:	40 3a       	lddsp	r10,sp[0xc]
800099e2:	58 0a       	cp.w	r10,0
800099e4:	c0 71       	brne	800099f2 <_dtoa_r+0x9a>
800099e6:	ed d6 c0 14 	bfextu	r6,r6,0x0,0x14
800099ea:	c0 41       	brne	800099f2 <_dtoa_r+0x9a>
800099ec:	fe cc c2 30 	sub	r12,pc,-15824
800099f0:	c0 38       	rjmp	800099f6 <_dtoa_r+0x9e>
800099f2:	fe cc c2 2a 	sub	r12,pc,-15830
800099f6:	41 29       	lddsp	r9,sp[0x48]
800099f8:	58 09       	cp.w	r9,0
800099fa:	e0 80 05 9a 	breq	8000a52e <_dtoa_r+0xbd6>
800099fe:	f8 c8 ff fd 	sub	r8,r12,-3
80009a02:	f8 c9 ff f8 	sub	r9,r12,-8
80009a06:	11 8b       	ld.ub	r11,r8[0x0]
80009a08:	30 0a       	mov	r10,0
80009a0a:	41 25       	lddsp	r5,sp[0x48]
80009a0c:	f4 0b 18 00 	cp.b	r11,r10
80009a10:	f2 08 17 10 	movne	r8,r9
80009a14:	c1 68       	rjmp	80009a40 <_dtoa_r+0xe8>
80009a16:	fa ea 00 08 	ld.d	r10,sp[8]
80009a1a:	30 08       	mov	r8,0
80009a1c:	fa eb 00 3c 	st.d	sp[60],r10
80009a20:	30 09       	mov	r9,0
80009a22:	e0 a0 10 ce 	rcall	8000bbbe <__avr32_f64_cmp_eq>
80009a26:	c1 00       	breq	80009a46 <_dtoa_r+0xee>
80009a28:	30 18       	mov	r8,1
80009a2a:	41 5a       	lddsp	r10,sp[0x54]
80009a2c:	95 08       	st.w	r10[0x0],r8
80009a2e:	fe cc c3 96 	sub	r12,pc,-15466
80009a32:	41 29       	lddsp	r9,sp[0x48]
80009a34:	f8 08 00 08 	add	r8,r12,r8
80009a38:	58 09       	cp.w	r9,0
80009a3a:	e0 80 05 7a 	breq	8000a52e <_dtoa_r+0xbd6>
80009a3e:	12 95       	mov	r5,r9
80009a40:	8b 08       	st.w	r5[0x0],r8
80009a42:	e0 8f 05 76 	bral	8000a52e <_dtoa_r+0xbd6>
80009a46:	fa c8 ff 9c 	sub	r8,sp,-100
80009a4a:	fa c9 ff a0 	sub	r9,sp,-96
80009a4e:	fa ea 00 3c 	ld.d	r10,sp[60]
80009a52:	0e 9c       	mov	r12,r7
80009a54:	eb d6 c2 8b 	bfextu	r5,r6,0x14,0xb
80009a58:	e0 a0 0a 8a 	rcall	8000af6c <__d2b>
80009a5c:	18 93       	mov	r3,r12
80009a5e:	58 05       	cp.w	r5,0
80009a60:	c0 d0       	breq	80009a7a <_dtoa_r+0x122>
80009a62:	fa ea 00 3c 	ld.d	r10,sp[60]
80009a66:	30 04       	mov	r4,0
80009a68:	f1 db c0 14 	bfextu	r8,r11,0x0,0x14
80009a6c:	ea c5 03 ff 	sub	r5,r5,1023
80009a70:	10 9b       	mov	r11,r8
80009a72:	51 74       	stdsp	sp[0x5c],r4
80009a74:	ea 1b 3f f0 	orh	r11,0x3ff0
80009a78:	c2 58       	rjmp	80009ac2 <_dtoa_r+0x16a>
80009a7a:	41 88       	lddsp	r8,sp[0x60]
80009a7c:	41 9c       	lddsp	r12,sp[0x64]
80009a7e:	10 0c       	add	r12,r8
80009a80:	f8 c5 fb ce 	sub	r5,r12,-1074
80009a84:	e0 45 00 20 	cp.w	r5,32
80009a88:	e0 8a 00 0e 	brle	80009aa4 <_dtoa_r+0x14c>
80009a8c:	f8 cc fb ee 	sub	r12,r12,-1042
80009a90:	40 3b       	lddsp	r11,sp[0xc]
80009a92:	ea 08 11 40 	rsub	r8,r5,64
80009a96:	f6 0c 0a 4c 	lsr	r12,r11,r12
80009a9a:	ec 08 09 46 	lsl	r6,r6,r8
80009a9e:	0c 4c       	or	r12,r6
80009aa0:	c0 78       	rjmp	80009aae <_dtoa_r+0x156>
80009aa2:	d7 03       	nop
80009aa4:	ea 0c 11 20 	rsub	r12,r5,32
80009aa8:	40 3a       	lddsp	r10,sp[0xc]
80009aaa:	f4 0c 09 4c 	lsl	r12,r10,r12
80009aae:	e0 a0 10 14 	rcall	8000bad6 <__avr32_u32_to_f64>
80009ab2:	fc 18 fe 10 	movh	r8,0xfe10
80009ab6:	30 19       	mov	r9,1
80009ab8:	ea c5 04 33 	sub	r5,r5,1075
80009abc:	f0 0b 00 0b 	add	r11,r8,r11
80009ac0:	51 79       	stdsp	sp[0x5c],r9
80009ac2:	30 08       	mov	r8,0
80009ac4:	fc 19 3f f8 	movh	r9,0x3ff8
80009ac8:	e0 a0 0e 9c 	rcall	8000b800 <__avr32_f64_sub>
80009acc:	e0 68 43 61 	mov	r8,17249
80009ad0:	ea 18 63 6f 	orh	r8,0x636f
80009ad4:	e0 69 87 a7 	mov	r9,34727
80009ad8:	ea 19 3f d2 	orh	r9,0x3fd2
80009adc:	e0 a0 0d a6 	rcall	8000b628 <__avr32_f64_mul>
80009ae0:	e0 68 c8 b3 	mov	r8,51379
80009ae4:	ea 18 8b 60 	orh	r8,0x8b60
80009ae8:	e0 69 8a 28 	mov	r9,35368
80009aec:	ea 19 3f c6 	orh	r9,0x3fc6
80009af0:	e0 a0 0f 56 	rcall	8000b99c <__avr32_f64_add>
80009af4:	0a 9c       	mov	r12,r5
80009af6:	14 90       	mov	r0,r10
80009af8:	16 91       	mov	r1,r11
80009afa:	e0 a0 0f f2 	rcall	8000bade <__avr32_s32_to_f64>
80009afe:	e0 68 79 fb 	mov	r8,31227
80009b02:	ea 18 50 9f 	orh	r8,0x509f
80009b06:	e0 69 44 13 	mov	r9,17427
80009b0a:	ea 19 3f d3 	orh	r9,0x3fd3
80009b0e:	e0 a0 0d 8d 	rcall	8000b628 <__avr32_f64_mul>
80009b12:	14 98       	mov	r8,r10
80009b14:	16 99       	mov	r9,r11
80009b16:	00 9a       	mov	r10,r0
80009b18:	02 9b       	mov	r11,r1
80009b1a:	e0 a0 0f 41 	rcall	8000b99c <__avr32_f64_add>
80009b1e:	14 90       	mov	r0,r10
80009b20:	16 91       	mov	r1,r11
80009b22:	e0 a0 0f c7 	rcall	8000bab0 <__avr32_f64_to_s32>
80009b26:	30 08       	mov	r8,0
80009b28:	18 96       	mov	r6,r12
80009b2a:	30 09       	mov	r9,0
80009b2c:	00 9a       	mov	r10,r0
80009b2e:	02 9b       	mov	r11,r1
80009b30:	e0 a0 10 8e 	rcall	8000bc4c <__avr32_f64_cmp_lt>
80009b34:	c0 c0       	breq	80009b4c <_dtoa_r+0x1f4>
80009b36:	0c 9c       	mov	r12,r6
80009b38:	e0 a0 0f d3 	rcall	8000bade <__avr32_s32_to_f64>
80009b3c:	14 98       	mov	r8,r10
80009b3e:	16 99       	mov	r9,r11
80009b40:	00 9a       	mov	r10,r0
80009b42:	02 9b       	mov	r11,r1
80009b44:	e0 a0 10 3d 	rcall	8000bbbe <__avr32_f64_cmp_eq>
80009b48:	f7 b6 00 01 	subeq	r6,1
80009b4c:	59 66       	cp.w	r6,22
80009b4e:	e0 88 00 05 	brls	80009b58 <_dtoa_r+0x200>
80009b52:	30 18       	mov	r8,1
80009b54:	51 48       	stdsp	sp[0x50],r8
80009b56:	c1 38       	rjmp	80009b7c <_dtoa_r+0x224>
80009b58:	fe c8 c2 dc 	sub	r8,pc,-15652
80009b5c:	fa ea 00 3c 	ld.d	r10,sp[60]
80009b60:	f0 06 02 38 	ld.d	r8,r8[r6<<0x3]
80009b64:	e0 a0 10 74 	rcall	8000bc4c <__avr32_f64_cmp_lt>
80009b68:	f9 b4 00 00 	moveq	r4,0
80009b6c:	fb f4 0a 14 	st.weq	sp[0x50],r4
80009b70:	f7 b6 01 01 	subne	r6,1
80009b74:	f9 bc 01 00 	movne	r12,0
80009b78:	fb fc 1a 14 	st.wne	sp[0x50],r12
80009b7c:	41 90       	lddsp	r0,sp[0x64]
80009b7e:	20 10       	sub	r0,1
80009b80:	0a 10       	sub	r0,r5
80009b82:	c0 46       	brmi	80009b8a <_dtoa_r+0x232>
80009b84:	50 40       	stdsp	sp[0x10],r0
80009b86:	30 00       	mov	r0,0
80009b88:	c0 48       	rjmp	80009b90 <_dtoa_r+0x238>
80009b8a:	30 0b       	mov	r11,0
80009b8c:	5c 30       	neg	r0
80009b8e:	50 4b       	stdsp	sp[0x10],r11
80009b90:	ec 02 11 00 	rsub	r2,r6,0
80009b94:	58 06       	cp.w	r6,0
80009b96:	fb fa 40 04 	ld.wge	r10,sp[0x10]
80009b9a:	f5 d6 e4 0a 	addge	r10,r10,r6
80009b9e:	fb fa 4a 04 	st.wge	sp[0x10],r10
80009ba2:	fb f6 4a 11 	st.wge	sp[0x44],r6
80009ba6:	f9 b2 04 00 	movge	r2,0
80009baa:	e1 d6 e5 10 	sublt	r0,r0,r6
80009bae:	f9 b9 05 00 	movlt	r9,0
80009bb2:	fb f9 5a 11 	st.wlt	sp[0x44],r9
80009bb6:	40 c8       	lddsp	r8,sp[0x30]
80009bb8:	58 98       	cp.w	r8,9
80009bba:	e0 8b 00 20 	brhi	80009bfa <_dtoa_r+0x2a2>
80009bbe:	58 58       	cp.w	r8,5
80009bc0:	f9 b4 0a 01 	movle	r4,1
80009bc4:	fb f5 90 0c 	ld.wgt	r5,sp[0x30]
80009bc8:	f7 b5 09 04 	subgt	r5,4
80009bcc:	fb f5 9a 0c 	st.wgt	sp[0x30],r5
80009bd0:	f9 b4 09 00 	movgt	r4,0
80009bd4:	40 cc       	lddsp	r12,sp[0x30]
80009bd6:	58 3c       	cp.w	r12,3
80009bd8:	c2 d0       	breq	80009c32 <_dtoa_r+0x2da>
80009bda:	e0 89 00 05 	brgt	80009be4 <_dtoa_r+0x28c>
80009bde:	58 2c       	cp.w	r12,2
80009be0:	c1 01       	brne	80009c00 <_dtoa_r+0x2a8>
80009be2:	c1 88       	rjmp	80009c12 <_dtoa_r+0x2ba>
80009be4:	40 cb       	lddsp	r11,sp[0x30]
80009be6:	58 4b       	cp.w	r11,4
80009be8:	c0 60       	breq	80009bf4 <_dtoa_r+0x29c>
80009bea:	58 5b       	cp.w	r11,5
80009bec:	c0 a1       	brne	80009c00 <_dtoa_r+0x2a8>
80009bee:	30 1a       	mov	r10,1
80009bf0:	50 da       	stdsp	sp[0x34],r10
80009bf2:	c2 28       	rjmp	80009c36 <_dtoa_r+0x2de>
80009bf4:	30 19       	mov	r9,1
80009bf6:	50 d9       	stdsp	sp[0x34],r9
80009bf8:	c0 f8       	rjmp	80009c16 <_dtoa_r+0x2be>
80009bfa:	30 08       	mov	r8,0
80009bfc:	30 14       	mov	r4,1
80009bfe:	50 c8       	stdsp	sp[0x30],r8
80009c00:	3f f5       	mov	r5,-1
80009c02:	30 1c       	mov	r12,1
80009c04:	30 0b       	mov	r11,0
80009c06:	50 95       	stdsp	sp[0x24],r5
80009c08:	50 dc       	stdsp	sp[0x34],r12
80009c0a:	0a 91       	mov	r1,r5
80009c0c:	31 28       	mov	r8,18
80009c0e:	50 eb       	stdsp	sp[0x38],r11
80009c10:	c2 08       	rjmp	80009c50 <_dtoa_r+0x2f8>
80009c12:	30 0a       	mov	r10,0
80009c14:	50 da       	stdsp	sp[0x34],r10
80009c16:	40 e9       	lddsp	r9,sp[0x38]
80009c18:	58 09       	cp.w	r9,0
80009c1a:	e0 89 00 07 	brgt	80009c28 <_dtoa_r+0x2d0>
80009c1e:	30 18       	mov	r8,1
80009c20:	50 98       	stdsp	sp[0x24],r8
80009c22:	10 91       	mov	r1,r8
80009c24:	50 e8       	stdsp	sp[0x38],r8
80009c26:	c1 58       	rjmp	80009c50 <_dtoa_r+0x2f8>
80009c28:	40 e5       	lddsp	r5,sp[0x38]
80009c2a:	50 95       	stdsp	sp[0x24],r5
80009c2c:	0a 91       	mov	r1,r5
80009c2e:	0a 98       	mov	r8,r5
80009c30:	c1 08       	rjmp	80009c50 <_dtoa_r+0x2f8>
80009c32:	30 0c       	mov	r12,0
80009c34:	50 dc       	stdsp	sp[0x34],r12
80009c36:	40 eb       	lddsp	r11,sp[0x38]
80009c38:	ec 0b 00 0b 	add	r11,r6,r11
80009c3c:	50 9b       	stdsp	sp[0x24],r11
80009c3e:	16 98       	mov	r8,r11
80009c40:	2f f8       	sub	r8,-1
80009c42:	58 08       	cp.w	r8,0
80009c44:	e0 89 00 05 	brgt	80009c4e <_dtoa_r+0x2f6>
80009c48:	10 91       	mov	r1,r8
80009c4a:	30 18       	mov	r8,1
80009c4c:	c0 28       	rjmp	80009c50 <_dtoa_r+0x2f8>
80009c4e:	10 91       	mov	r1,r8
80009c50:	30 09       	mov	r9,0
80009c52:	6e 9a       	ld.w	r10,r7[0x24]
80009c54:	95 19       	st.w	r10[0x4],r9
80009c56:	30 49       	mov	r9,4
80009c58:	c0 68       	rjmp	80009c64 <_dtoa_r+0x30c>
80009c5a:	d7 03       	nop
80009c5c:	6a 1a       	ld.w	r10,r5[0x4]
80009c5e:	a1 79       	lsl	r9,0x1
80009c60:	2f fa       	sub	r10,-1
80009c62:	8b 1a       	st.w	r5[0x4],r10
80009c64:	6e 95       	ld.w	r5,r7[0x24]
80009c66:	f2 ca ff ec 	sub	r10,r9,-20
80009c6a:	10 3a       	cp.w	r10,r8
80009c6c:	fe 98 ff f8 	brls	80009c5c <_dtoa_r+0x304>
80009c70:	6a 1b       	ld.w	r11,r5[0x4]
80009c72:	0e 9c       	mov	r12,r7
80009c74:	e0 a0 09 44 	rcall	8000aefc <_Balloc>
80009c78:	58 e1       	cp.w	r1,14
80009c7a:	5f 88       	srls	r8
80009c7c:	8b 0c       	st.w	r5[0x0],r12
80009c7e:	f1 e4 00 04 	and	r4,r8,r4
80009c82:	6e 98       	ld.w	r8,r7[0x24]
80009c84:	70 08       	ld.w	r8,r8[0x0]
80009c86:	50 88       	stdsp	sp[0x20],r8
80009c88:	e0 80 01 82 	breq	80009f8c <_dtoa_r+0x634>
80009c8c:	58 06       	cp.w	r6,0
80009c8e:	e0 8a 00 43 	brle	80009d14 <_dtoa_r+0x3bc>
80009c92:	f3 d6 c0 04 	bfextu	r9,r6,0x0,0x4
80009c96:	fe c8 c4 1a 	sub	r8,pc,-15334
80009c9a:	f0 09 02 34 	ld.d	r4,r8[r9<<0x3]
80009c9e:	fa e5 00 18 	st.d	sp[24],r4
80009ca2:	ec 04 14 04 	asr	r4,r6,0x4
80009ca6:	ed b4 00 04 	bld	r4,0x4
80009caa:	c0 30       	breq	80009cb0 <_dtoa_r+0x358>
80009cac:	30 25       	mov	r5,2
80009cae:	c1 08       	rjmp	80009cce <_dtoa_r+0x376>
80009cb0:	fe c8 c3 6c 	sub	r8,pc,-15508
80009cb4:	f0 e8 00 20 	ld.d	r8,r8[32]
80009cb8:	fa ea 00 3c 	ld.d	r10,sp[60]
80009cbc:	e9 d4 c0 04 	bfextu	r4,r4,0x0,0x4
80009cc0:	e0 a0 0f fa 	rcall	8000bcb4 <__avr32_f64_div>
80009cc4:	30 35       	mov	r5,3
80009cc6:	14 98       	mov	r8,r10
80009cc8:	16 99       	mov	r9,r11
80009cca:	fa e9 00 08 	st.d	sp[8],r8
80009cce:	fe cc c3 8a 	sub	r12,pc,-15478
80009cd2:	50 a3       	stdsp	sp[0x28],r3
80009cd4:	0c 93       	mov	r3,r6
80009cd6:	18 96       	mov	r6,r12
80009cd8:	c0 f8       	rjmp	80009cf6 <_dtoa_r+0x39e>
80009cda:	fa ea 00 18 	ld.d	r10,sp[24]
80009cde:	ed b4 00 00 	bld	r4,0x0
80009ce2:	c0 81       	brne	80009cf2 <_dtoa_r+0x39a>
80009ce4:	ec e8 00 00 	ld.d	r8,r6[0]
80009ce8:	2f f5       	sub	r5,-1
80009cea:	e0 a0 0c 9f 	rcall	8000b628 <__avr32_f64_mul>
80009cee:	fa eb 00 18 	st.d	sp[24],r10
80009cf2:	a1 54       	asr	r4,0x1
80009cf4:	2f 86       	sub	r6,-8
80009cf6:	58 04       	cp.w	r4,0
80009cf8:	cf 11       	brne	80009cda <_dtoa_r+0x382>
80009cfa:	fa e8 00 18 	ld.d	r8,sp[24]
80009cfe:	fa ea 00 08 	ld.d	r10,sp[8]
80009d02:	06 96       	mov	r6,r3
80009d04:	e0 a0 0f d8 	rcall	8000bcb4 <__avr32_f64_div>
80009d08:	40 a3       	lddsp	r3,sp[0x28]
80009d0a:	14 98       	mov	r8,r10
80009d0c:	16 99       	mov	r9,r11
80009d0e:	fa e9 00 08 	st.d	sp[8],r8
80009d12:	c2 f8       	rjmp	80009d70 <_dtoa_r+0x418>
80009d14:	ec 08 11 00 	rsub	r8,r6,0
80009d18:	c0 31       	brne	80009d1e <_dtoa_r+0x3c6>
80009d1a:	30 25       	mov	r5,2
80009d1c:	c2 a8       	rjmp	80009d70 <_dtoa_r+0x418>
80009d1e:	fe cc c3 da 	sub	r12,pc,-15398
80009d22:	f0 04 14 04 	asr	r4,r8,0x4
80009d26:	50 1c       	stdsp	sp[0x4],r12
80009d28:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
80009d2c:	fe c9 c4 b0 	sub	r9,pc,-15184
80009d30:	fa ea 00 3c 	ld.d	r10,sp[60]
80009d34:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
80009d38:	e0 a0 0c 78 	rcall	8000b628 <__avr32_f64_mul>
80009d3c:	40 1c       	lddsp	r12,sp[0x4]
80009d3e:	50 63       	stdsp	sp[0x18],r3
80009d40:	30 25       	mov	r5,2
80009d42:	0c 93       	mov	r3,r6
80009d44:	fa eb 00 08 	st.d	sp[8],r10
80009d48:	18 96       	mov	r6,r12
80009d4a:	c0 f8       	rjmp	80009d68 <_dtoa_r+0x410>
80009d4c:	fa ea 00 08 	ld.d	r10,sp[8]
80009d50:	ed b4 00 00 	bld	r4,0x0
80009d54:	c0 81       	brne	80009d64 <_dtoa_r+0x40c>
80009d56:	ec e8 00 00 	ld.d	r8,r6[0]
80009d5a:	2f f5       	sub	r5,-1
80009d5c:	e0 a0 0c 66 	rcall	8000b628 <__avr32_f64_mul>
80009d60:	fa eb 00 08 	st.d	sp[8],r10
80009d64:	a1 54       	asr	r4,0x1
80009d66:	2f 86       	sub	r6,-8
80009d68:	58 04       	cp.w	r4,0
80009d6a:	cf 11       	brne	80009d4c <_dtoa_r+0x3f4>
80009d6c:	06 96       	mov	r6,r3
80009d6e:	40 63       	lddsp	r3,sp[0x18]
80009d70:	41 4a       	lddsp	r10,sp[0x50]
80009d72:	58 0a       	cp.w	r10,0
80009d74:	c2 a0       	breq	80009dc8 <_dtoa_r+0x470>
80009d76:	fa e8 00 08 	ld.d	r8,sp[8]
80009d7a:	58 01       	cp.w	r1,0
80009d7c:	5f 94       	srgt	r4
80009d7e:	fa e9 00 18 	st.d	sp[24],r8
80009d82:	30 08       	mov	r8,0
80009d84:	fc 19 3f f0 	movh	r9,0x3ff0
80009d88:	fa ea 00 18 	ld.d	r10,sp[24]
80009d8c:	e0 a0 0f 60 	rcall	8000bc4c <__avr32_f64_cmp_lt>
80009d90:	f9 bc 00 00 	moveq	r12,0
80009d94:	f9 bc 01 01 	movne	r12,1
80009d98:	e9 ec 00 0c 	and	r12,r4,r12
80009d9c:	c1 60       	breq	80009dc8 <_dtoa_r+0x470>
80009d9e:	40 98       	lddsp	r8,sp[0x24]
80009da0:	58 08       	cp.w	r8,0
80009da2:	e0 8a 00 f1 	brle	80009f84 <_dtoa_r+0x62c>
80009da6:	30 08       	mov	r8,0
80009da8:	fc 19 40 24 	movh	r9,0x4024
80009dac:	ec c4 00 01 	sub	r4,r6,1
80009db0:	fa ea 00 18 	ld.d	r10,sp[24]
80009db4:	2f f5       	sub	r5,-1
80009db6:	50 64       	stdsp	sp[0x18],r4
80009db8:	e0 a0 0c 38 	rcall	8000b628 <__avr32_f64_mul>
80009dbc:	40 94       	lddsp	r4,sp[0x24]
80009dbe:	14 98       	mov	r8,r10
80009dc0:	16 99       	mov	r9,r11
80009dc2:	fa e9 00 08 	st.d	sp[8],r8
80009dc6:	c0 38       	rjmp	80009dcc <_dtoa_r+0x474>
80009dc8:	50 66       	stdsp	sp[0x18],r6
80009dca:	02 94       	mov	r4,r1
80009dcc:	0a 9c       	mov	r12,r5
80009dce:	e0 a0 0e 88 	rcall	8000bade <__avr32_s32_to_f64>
80009dd2:	fa e8 00 08 	ld.d	r8,sp[8]
80009dd6:	e0 a0 0c 29 	rcall	8000b628 <__avr32_f64_mul>
80009dda:	30 08       	mov	r8,0
80009ddc:	fc 19 40 1c 	movh	r9,0x401c
80009de0:	e0 a0 0d de 	rcall	8000b99c <__avr32_f64_add>
80009de4:	14 98       	mov	r8,r10
80009de6:	16 99       	mov	r9,r11
80009de8:	fa e9 00 28 	st.d	sp[40],r8
80009dec:	fc 18 fc c0 	movh	r8,0xfcc0
80009df0:	40 a5       	lddsp	r5,sp[0x28]
80009df2:	10 05       	add	r5,r8
80009df4:	50 a5       	stdsp	sp[0x28],r5
80009df6:	58 04       	cp.w	r4,0
80009df8:	c2 11       	brne	80009e3a <_dtoa_r+0x4e2>
80009dfa:	fa ea 00 08 	ld.d	r10,sp[8]
80009dfe:	30 08       	mov	r8,0
80009e00:	fc 19 40 14 	movh	r9,0x4014
80009e04:	e0 a0 0c fe 	rcall	8000b800 <__avr32_f64_sub>
80009e08:	40 bc       	lddsp	r12,sp[0x2c]
80009e0a:	fa eb 00 08 	st.d	sp[8],r10
80009e0e:	14 98       	mov	r8,r10
80009e10:	16 99       	mov	r9,r11
80009e12:	18 9a       	mov	r10,r12
80009e14:	0a 9b       	mov	r11,r5
80009e16:	e0 a0 0f 1b 	rcall	8000bc4c <__avr32_f64_cmp_lt>
80009e1a:	e0 81 02 54 	brne	8000a2c2 <_dtoa_r+0x96a>
80009e1e:	0a 98       	mov	r8,r5
80009e20:	40 b9       	lddsp	r9,sp[0x2c]
80009e22:	ee 18 80 00 	eorh	r8,0x8000
80009e26:	fa ea 00 08 	ld.d	r10,sp[8]
80009e2a:	10 95       	mov	r5,r8
80009e2c:	12 98       	mov	r8,r9
80009e2e:	0a 99       	mov	r9,r5
80009e30:	e0 a0 0f 0e 	rcall	8000bc4c <__avr32_f64_cmp_lt>
80009e34:	e0 81 02 3e 	brne	8000a2b0 <_dtoa_r+0x958>
80009e38:	ca 68       	rjmp	80009f84 <_dtoa_r+0x62c>
80009e3a:	fe c9 c5 be 	sub	r9,pc,-14914
80009e3e:	e8 c8 00 01 	sub	r8,r4,1
80009e42:	40 d5       	lddsp	r5,sp[0x34]
80009e44:	58 05       	cp.w	r5,0
80009e46:	c4 f0       	breq	80009ee4 <_dtoa_r+0x58c>
80009e48:	30 0c       	mov	r12,0
80009e4a:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
80009e4e:	51 3c       	stdsp	sp[0x4c],r12
80009e50:	30 0a       	mov	r10,0
80009e52:	fc 1b 3f e0 	movh	r11,0x3fe0
80009e56:	e0 a0 0f 2f 	rcall	8000bcb4 <__avr32_f64_div>
80009e5a:	fa e8 00 28 	ld.d	r8,sp[40]
80009e5e:	40 85       	lddsp	r5,sp[0x20]
80009e60:	e0 a0 0c d0 	rcall	8000b800 <__avr32_f64_sub>
80009e64:	fa eb 00 28 	st.d	sp[40],r10
80009e68:	fa ea 00 08 	ld.d	r10,sp[8]
80009e6c:	e0 a0 0e 22 	rcall	8000bab0 <__avr32_f64_to_s32>
80009e70:	51 6c       	stdsp	sp[0x58],r12
80009e72:	e0 a0 0e 36 	rcall	8000bade <__avr32_s32_to_f64>
80009e76:	14 98       	mov	r8,r10
80009e78:	16 99       	mov	r9,r11
80009e7a:	fa ea 00 08 	ld.d	r10,sp[8]
80009e7e:	e0 a0 0c c1 	rcall	8000b800 <__avr32_f64_sub>
80009e82:	fa eb 00 08 	st.d	sp[8],r10
80009e86:	41 68       	lddsp	r8,sp[0x58]
80009e88:	2d 08       	sub	r8,-48
80009e8a:	0a c8       	st.b	r5++,r8
80009e8c:	41 39       	lddsp	r9,sp[0x4c]
80009e8e:	2f f9       	sub	r9,-1
80009e90:	51 39       	stdsp	sp[0x4c],r9
80009e92:	fa e8 00 28 	ld.d	r8,sp[40]
80009e96:	e0 a0 0e db 	rcall	8000bc4c <__avr32_f64_cmp_lt>
80009e9a:	e0 81 03 39 	brne	8000a50c <_dtoa_r+0xbb4>
80009e9e:	fa e8 00 08 	ld.d	r8,sp[8]
80009ea2:	30 0a       	mov	r10,0
80009ea4:	fc 1b 3f f0 	movh	r11,0x3ff0
80009ea8:	e0 a0 0c ac 	rcall	8000b800 <__avr32_f64_sub>
80009eac:	fa e8 00 28 	ld.d	r8,sp[40]
80009eb0:	e0 a0 0e ce 	rcall	8000bc4c <__avr32_f64_cmp_lt>
80009eb4:	fa ea 00 28 	ld.d	r10,sp[40]
80009eb8:	30 08       	mov	r8,0
80009eba:	fc 19 40 24 	movh	r9,0x4024
80009ebe:	e0 81 00 da 	brne	8000a072 <_dtoa_r+0x71a>
80009ec2:	41 3c       	lddsp	r12,sp[0x4c]
80009ec4:	08 3c       	cp.w	r12,r4
80009ec6:	c5 f4       	brge	80009f84 <_dtoa_r+0x62c>
80009ec8:	e0 a0 0b b0 	rcall	8000b628 <__avr32_f64_mul>
80009ecc:	30 08       	mov	r8,0
80009ece:	fa eb 00 28 	st.d	sp[40],r10
80009ed2:	fc 19 40 24 	movh	r9,0x4024
80009ed6:	fa ea 00 08 	ld.d	r10,sp[8]
80009eda:	e0 a0 0b a7 	rcall	8000b628 <__avr32_f64_mul>
80009ede:	fa eb 00 08 	st.d	sp[8],r10
80009ee2:	cc 3b       	rjmp	80009e68 <_dtoa_r+0x510>
80009ee4:	40 85       	lddsp	r5,sp[0x20]
80009ee6:	08 05       	add	r5,r4
80009ee8:	f2 08 02 3a 	ld.d	r10,r9[r8<<0x3]
80009eec:	51 35       	stdsp	sp[0x4c],r5
80009eee:	fa e8 00 28 	ld.d	r8,sp[40]
80009ef2:	40 85       	lddsp	r5,sp[0x20]
80009ef4:	e0 a0 0b 9a 	rcall	8000b628 <__avr32_f64_mul>
80009ef8:	fa eb 00 28 	st.d	sp[40],r10
80009efc:	fa ea 00 08 	ld.d	r10,sp[8]
80009f00:	e0 a0 0d d8 	rcall	8000bab0 <__avr32_f64_to_s32>
80009f04:	51 6c       	stdsp	sp[0x58],r12
80009f06:	e0 a0 0d ec 	rcall	8000bade <__avr32_s32_to_f64>
80009f0a:	14 98       	mov	r8,r10
80009f0c:	16 99       	mov	r9,r11
80009f0e:	fa ea 00 08 	ld.d	r10,sp[8]
80009f12:	e0 a0 0c 77 	rcall	8000b800 <__avr32_f64_sub>
80009f16:	fa eb 00 08 	st.d	sp[8],r10
80009f1a:	41 68       	lddsp	r8,sp[0x58]
80009f1c:	2d 08       	sub	r8,-48
80009f1e:	0a c8       	st.b	r5++,r8
80009f20:	41 3c       	lddsp	r12,sp[0x4c]
80009f22:	18 35       	cp.w	r5,r12
80009f24:	c2 81       	brne	80009f74 <_dtoa_r+0x61c>
80009f26:	30 08       	mov	r8,0
80009f28:	fc 19 3f e0 	movh	r9,0x3fe0
80009f2c:	fa ea 00 28 	ld.d	r10,sp[40]
80009f30:	e0 a0 0d 36 	rcall	8000b99c <__avr32_f64_add>
80009f34:	40 85       	lddsp	r5,sp[0x20]
80009f36:	fa e8 00 08 	ld.d	r8,sp[8]
80009f3a:	08 05       	add	r5,r4
80009f3c:	e0 a0 0e 88 	rcall	8000bc4c <__avr32_f64_cmp_lt>
80009f40:	e0 81 00 99 	brne	8000a072 <_dtoa_r+0x71a>
80009f44:	fa e8 00 28 	ld.d	r8,sp[40]
80009f48:	30 0a       	mov	r10,0
80009f4a:	fc 1b 3f e0 	movh	r11,0x3fe0
80009f4e:	e0 a0 0c 59 	rcall	8000b800 <__avr32_f64_sub>
80009f52:	14 98       	mov	r8,r10
80009f54:	16 99       	mov	r9,r11
80009f56:	fa ea 00 08 	ld.d	r10,sp[8]
80009f5a:	e0 a0 0e 79 	rcall	8000bc4c <__avr32_f64_cmp_lt>
80009f5e:	c1 30       	breq	80009f84 <_dtoa_r+0x62c>
80009f60:	33 09       	mov	r9,48
80009f62:	0a 98       	mov	r8,r5
80009f64:	11 7a       	ld.ub	r10,--r8
80009f66:	f2 0a 18 00 	cp.b	r10,r9
80009f6a:	e0 81 02 d1 	brne	8000a50c <_dtoa_r+0xbb4>
80009f6e:	10 95       	mov	r5,r8
80009f70:	cf 9b       	rjmp	80009f62 <_dtoa_r+0x60a>
80009f72:	d7 03       	nop
80009f74:	30 08       	mov	r8,0
80009f76:	fc 19 40 24 	movh	r9,0x4024
80009f7a:	e0 a0 0b 57 	rcall	8000b628 <__avr32_f64_mul>
80009f7e:	fa eb 00 08 	st.d	sp[8],r10
80009f82:	cb db       	rjmp	80009efc <_dtoa_r+0x5a4>
80009f84:	fa ea 00 3c 	ld.d	r10,sp[60]
80009f88:	fa eb 00 08 	st.d	sp[8],r10
80009f8c:	58 e6       	cp.w	r6,14
80009f8e:	5f ab       	srle	r11
80009f90:	41 8a       	lddsp	r10,sp[0x60]
80009f92:	30 08       	mov	r8,0
80009f94:	f4 09 11 ff 	rsub	r9,r10,-1
80009f98:	f7 e9 03 f9 	and	r9,r11,r9>>0x1f
80009f9c:	f0 09 18 00 	cp.b	r9,r8
80009fa0:	e0 80 00 82 	breq	8000a0a4 <_dtoa_r+0x74c>
80009fa4:	40 ea       	lddsp	r10,sp[0x38]
80009fa6:	58 01       	cp.w	r1,0
80009fa8:	5f a9       	srle	r9
80009faa:	f3 ea 03 f9 	and	r9,r9,r10>>0x1f
80009fae:	fe ca c7 32 	sub	r10,pc,-14542
80009fb2:	f4 06 02 34 	ld.d	r4,r10[r6<<0x3]
80009fb6:	fa e5 00 10 	st.d	sp[16],r4
80009fba:	f0 09 18 00 	cp.b	r9,r8
80009fbe:	c1 40       	breq	80009fe6 <_dtoa_r+0x68e>
80009fc0:	58 01       	cp.w	r1,0
80009fc2:	e0 81 01 77 	brne	8000a2b0 <_dtoa_r+0x958>
80009fc6:	30 08       	mov	r8,0
80009fc8:	fc 19 40 14 	movh	r9,0x4014
80009fcc:	08 9a       	mov	r10,r4
80009fce:	0a 9b       	mov	r11,r5
80009fd0:	e0 a0 0b 2c 	rcall	8000b628 <__avr32_f64_mul>
80009fd4:	fa e8 00 08 	ld.d	r8,sp[8]
80009fd8:	e0 a0 0e 06 	rcall	8000bbe4 <__avr32_f64_cmp_ge>
80009fdc:	e0 81 01 6a 	brne	8000a2b0 <_dtoa_r+0x958>
80009fe0:	02 92       	mov	r2,r1
80009fe2:	e0 8f 01 72 	bral	8000a2c6 <_dtoa_r+0x96e>
80009fe6:	40 85       	lddsp	r5,sp[0x20]
80009fe8:	30 14       	mov	r4,1
80009fea:	fa e8 00 10 	ld.d	r8,sp[16]
80009fee:	fa ea 00 08 	ld.d	r10,sp[8]
80009ff2:	e0 a0 0e 61 	rcall	8000bcb4 <__avr32_f64_div>
80009ff6:	e0 a0 0d 5d 	rcall	8000bab0 <__avr32_f64_to_s32>
80009ffa:	18 92       	mov	r2,r12
80009ffc:	e0 a0 0d 71 	rcall	8000bade <__avr32_s32_to_f64>
8000a000:	fa e8 00 10 	ld.d	r8,sp[16]
8000a004:	e0 a0 0b 12 	rcall	8000b628 <__avr32_f64_mul>
8000a008:	14 98       	mov	r8,r10
8000a00a:	16 99       	mov	r9,r11
8000a00c:	fa ea 00 08 	ld.d	r10,sp[8]
8000a010:	e0 a0 0b f8 	rcall	8000b800 <__avr32_f64_sub>
8000a014:	fa eb 00 08 	st.d	sp[8],r10
8000a018:	e4 c8 ff d0 	sub	r8,r2,-48
8000a01c:	0a c8       	st.b	r5++,r8
8000a01e:	fc 19 40 24 	movh	r9,0x4024
8000a022:	30 08       	mov	r8,0
8000a024:	02 34       	cp.w	r4,r1
8000a026:	c3 31       	brne	8000a08c <_dtoa_r+0x734>
8000a028:	fa e8 00 08 	ld.d	r8,sp[8]
8000a02c:	e0 a0 0c b8 	rcall	8000b99c <__avr32_f64_add>
8000a030:	16 91       	mov	r1,r11
8000a032:	14 90       	mov	r0,r10
8000a034:	14 98       	mov	r8,r10
8000a036:	02 99       	mov	r9,r1
8000a038:	fa ea 00 10 	ld.d	r10,sp[16]
8000a03c:	e0 a0 0e 08 	rcall	8000bc4c <__avr32_f64_cmp_lt>
8000a040:	c1 a1       	brne	8000a074 <_dtoa_r+0x71c>
8000a042:	fa e8 00 10 	ld.d	r8,sp[16]
8000a046:	00 9a       	mov	r10,r0
8000a048:	02 9b       	mov	r11,r1
8000a04a:	e0 a0 0d ba 	rcall	8000bbbe <__avr32_f64_cmp_eq>
8000a04e:	e0 80 02 5e 	breq	8000a50a <_dtoa_r+0xbb2>
8000a052:	e5 d2 c0 01 	bfextu	r2,r2,0x0,0x1
8000a056:	c0 f1       	brne	8000a074 <_dtoa_r+0x71c>
8000a058:	e0 8f 02 59 	bral	8000a50a <_dtoa_r+0xbb2>
8000a05c:	40 8a       	lddsp	r10,sp[0x20]
8000a05e:	14 38       	cp.w	r8,r10
8000a060:	c0 30       	breq	8000a066 <_dtoa_r+0x70e>
8000a062:	10 95       	mov	r5,r8
8000a064:	c0 98       	rjmp	8000a076 <_dtoa_r+0x71e>
8000a066:	33 08       	mov	r8,48
8000a068:	40 89       	lddsp	r9,sp[0x20]
8000a06a:	2f f6       	sub	r6,-1
8000a06c:	b2 88       	st.b	r9[0x0],r8
8000a06e:	40 88       	lddsp	r8,sp[0x20]
8000a070:	c0 88       	rjmp	8000a080 <_dtoa_r+0x728>
8000a072:	40 66       	lddsp	r6,sp[0x18]
8000a074:	33 99       	mov	r9,57
8000a076:	0a 98       	mov	r8,r5
8000a078:	11 7a       	ld.ub	r10,--r8
8000a07a:	f2 0a 18 00 	cp.b	r10,r9
8000a07e:	ce f0       	breq	8000a05c <_dtoa_r+0x704>
8000a080:	50 66       	stdsp	sp[0x18],r6
8000a082:	11 89       	ld.ub	r9,r8[0x0]
8000a084:	2f f9       	sub	r9,-1
8000a086:	b0 89       	st.b	r8[0x0],r9
8000a088:	e0 8f 02 42 	bral	8000a50c <_dtoa_r+0xbb4>
8000a08c:	e0 a0 0a ce 	rcall	8000b628 <__avr32_f64_mul>
8000a090:	2f f4       	sub	r4,-1
8000a092:	fa eb 00 08 	st.d	sp[8],r10
8000a096:	30 08       	mov	r8,0
8000a098:	30 09       	mov	r9,0
8000a09a:	e0 a0 0d 92 	rcall	8000bbbe <__avr32_f64_cmp_eq>
8000a09e:	ca 60       	breq	80009fea <_dtoa_r+0x692>
8000a0a0:	e0 8f 02 35 	bral	8000a50a <_dtoa_r+0xbb2>
8000a0a4:	40 d8       	lddsp	r8,sp[0x34]
8000a0a6:	58 08       	cp.w	r8,0
8000a0a8:	c0 51       	brne	8000a0b2 <_dtoa_r+0x75a>
8000a0aa:	04 98       	mov	r8,r2
8000a0ac:	00 95       	mov	r5,r0
8000a0ae:	40 d4       	lddsp	r4,sp[0x34]
8000a0b0:	c3 78       	rjmp	8000a11e <_dtoa_r+0x7c6>
8000a0b2:	40 c5       	lddsp	r5,sp[0x30]
8000a0b4:	58 15       	cp.w	r5,1
8000a0b6:	e0 89 00 0f 	brgt	8000a0d4 <_dtoa_r+0x77c>
8000a0ba:	41 74       	lddsp	r4,sp[0x5c]
8000a0bc:	58 04       	cp.w	r4,0
8000a0be:	c0 40       	breq	8000a0c6 <_dtoa_r+0x76e>
8000a0c0:	f4 c9 fb cd 	sub	r9,r10,-1075
8000a0c4:	c0 48       	rjmp	8000a0cc <_dtoa_r+0x774>
8000a0c6:	41 99       	lddsp	r9,sp[0x64]
8000a0c8:	f2 09 11 36 	rsub	r9,r9,54
8000a0cc:	04 98       	mov	r8,r2
8000a0ce:	00 95       	mov	r5,r0
8000a0d0:	c1 c8       	rjmp	8000a108 <_dtoa_r+0x7b0>
8000a0d2:	d7 03       	nop
8000a0d4:	e2 c8 00 01 	sub	r8,r1,1
8000a0d8:	58 01       	cp.w	r1,0
8000a0da:	e0 05 17 40 	movge	r5,r0
8000a0de:	e2 09 17 40 	movge	r9,r1
8000a0e2:	e1 d1 e5 15 	sublt	r5,r0,r1
8000a0e6:	f9 b9 05 00 	movlt	r9,0
8000a0ea:	10 32       	cp.w	r2,r8
8000a0ec:	e5 d8 e4 18 	subge	r8,r2,r8
8000a0f0:	f1 d2 e5 18 	sublt	r8,r8,r2
8000a0f4:	e5 d8 e5 02 	addlt	r2,r2,r8
8000a0f8:	fb fc 50 11 	ld.wlt	r12,sp[0x44]
8000a0fc:	f9 d8 e5 0c 	addlt	r12,r12,r8
8000a100:	fb fc 5a 11 	st.wlt	sp[0x44],r12
8000a104:	f9 b8 05 00 	movlt	r8,0
8000a108:	40 4b       	lddsp	r11,sp[0x10]
8000a10a:	12 0b       	add	r11,r9
8000a10c:	50 08       	stdsp	sp[0x0],r8
8000a10e:	50 4b       	stdsp	sp[0x10],r11
8000a110:	12 00       	add	r0,r9
8000a112:	30 1b       	mov	r11,1
8000a114:	0e 9c       	mov	r12,r7
8000a116:	e0 a0 08 a7 	rcall	8000b264 <__i2b>
8000a11a:	40 08       	lddsp	r8,sp[0x0]
8000a11c:	18 94       	mov	r4,r12
8000a11e:	40 4a       	lddsp	r10,sp[0x10]
8000a120:	58 05       	cp.w	r5,0
8000a122:	5f 99       	srgt	r9
8000a124:	58 0a       	cp.w	r10,0
8000a126:	5f 9a       	srgt	r10
8000a128:	f5 e9 00 09 	and	r9,r10,r9
8000a12c:	c0 80       	breq	8000a13c <_dtoa_r+0x7e4>
8000a12e:	40 4c       	lddsp	r12,sp[0x10]
8000a130:	f8 05 0d 49 	min	r9,r12,r5
8000a134:	12 1c       	sub	r12,r9
8000a136:	12 10       	sub	r0,r9
8000a138:	50 4c       	stdsp	sp[0x10],r12
8000a13a:	12 15       	sub	r5,r9
8000a13c:	58 02       	cp.w	r2,0
8000a13e:	e0 8a 00 27 	brle	8000a18c <_dtoa_r+0x834>
8000a142:	40 db       	lddsp	r11,sp[0x34]
8000a144:	58 0b       	cp.w	r11,0
8000a146:	c1 d0       	breq	8000a180 <_dtoa_r+0x828>
8000a148:	58 08       	cp.w	r8,0
8000a14a:	e0 8a 00 17 	brle	8000a178 <_dtoa_r+0x820>
8000a14e:	10 9a       	mov	r10,r8
8000a150:	50 08       	stdsp	sp[0x0],r8
8000a152:	08 9b       	mov	r11,r4
8000a154:	0e 9c       	mov	r12,r7
8000a156:	e0 a0 08 cd 	rcall	8000b2f0 <__pow5mult>
8000a15a:	06 9a       	mov	r10,r3
8000a15c:	18 9b       	mov	r11,r12
8000a15e:	18 94       	mov	r4,r12
8000a160:	0e 9c       	mov	r12,r7
8000a162:	e0 a0 08 01 	rcall	8000b164 <__multiply>
8000a166:	18 99       	mov	r9,r12
8000a168:	06 9b       	mov	r11,r3
8000a16a:	50 19       	stdsp	sp[0x4],r9
8000a16c:	0e 9c       	mov	r12,r7
8000a16e:	e0 a0 06 ad 	rcall	8000aec8 <_Bfree>
8000a172:	40 19       	lddsp	r9,sp[0x4]
8000a174:	40 08       	lddsp	r8,sp[0x0]
8000a176:	12 93       	mov	r3,r9
8000a178:	e4 08 01 0a 	sub	r10,r2,r8
8000a17c:	c0 80       	breq	8000a18c <_dtoa_r+0x834>
8000a17e:	c0 28       	rjmp	8000a182 <_dtoa_r+0x82a>
8000a180:	04 9a       	mov	r10,r2
8000a182:	06 9b       	mov	r11,r3
8000a184:	0e 9c       	mov	r12,r7
8000a186:	e0 a0 08 b5 	rcall	8000b2f0 <__pow5mult>
8000a18a:	18 93       	mov	r3,r12
8000a18c:	30 1b       	mov	r11,1
8000a18e:	0e 9c       	mov	r12,r7
8000a190:	e0 a0 08 6a 	rcall	8000b264 <__i2b>
8000a194:	41 1a       	lddsp	r10,sp[0x44]
8000a196:	18 92       	mov	r2,r12
8000a198:	58 0a       	cp.w	r10,0
8000a19a:	e0 8a 00 07 	brle	8000a1a8 <_dtoa_r+0x850>
8000a19e:	18 9b       	mov	r11,r12
8000a1a0:	0e 9c       	mov	r12,r7
8000a1a2:	e0 a0 08 a7 	rcall	8000b2f0 <__pow5mult>
8000a1a6:	18 92       	mov	r2,r12
8000a1a8:	40 c9       	lddsp	r9,sp[0x30]
8000a1aa:	58 19       	cp.w	r9,1
8000a1ac:	e0 89 00 14 	brgt	8000a1d4 <_dtoa_r+0x87c>
8000a1b0:	40 38       	lddsp	r8,sp[0xc]
8000a1b2:	58 08       	cp.w	r8,0
8000a1b4:	c1 01       	brne	8000a1d4 <_dtoa_r+0x87c>
8000a1b6:	40 29       	lddsp	r9,sp[0x8]
8000a1b8:	f1 d9 c0 14 	bfextu	r8,r9,0x0,0x14
8000a1bc:	c0 c1       	brne	8000a1d4 <_dtoa_r+0x87c>
8000a1be:	12 98       	mov	r8,r9
8000a1c0:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000a1c4:	c0 80       	breq	8000a1d4 <_dtoa_r+0x87c>
8000a1c6:	40 4c       	lddsp	r12,sp[0x10]
8000a1c8:	30 1b       	mov	r11,1
8000a1ca:	2f fc       	sub	r12,-1
8000a1cc:	2f f0       	sub	r0,-1
8000a1ce:	50 4c       	stdsp	sp[0x10],r12
8000a1d0:	50 6b       	stdsp	sp[0x18],r11
8000a1d2:	c0 38       	rjmp	8000a1d8 <_dtoa_r+0x880>
8000a1d4:	30 0a       	mov	r10,0
8000a1d6:	50 6a       	stdsp	sp[0x18],r10
8000a1d8:	41 19       	lddsp	r9,sp[0x44]
8000a1da:	58 09       	cp.w	r9,0
8000a1dc:	c0 31       	brne	8000a1e2 <_dtoa_r+0x88a>
8000a1de:	30 1c       	mov	r12,1
8000a1e0:	c0 98       	rjmp	8000a1f2 <_dtoa_r+0x89a>
8000a1e2:	64 48       	ld.w	r8,r2[0x10]
8000a1e4:	2f c8       	sub	r8,-4
8000a1e6:	e4 08 03 2c 	ld.w	r12,r2[r8<<0x2]
8000a1ea:	e0 a0 05 df 	rcall	8000ada8 <__hi0bits>
8000a1ee:	f8 0c 11 20 	rsub	r12,r12,32
8000a1f2:	40 4b       	lddsp	r11,sp[0x10]
8000a1f4:	f8 0b 00 08 	add	r8,r12,r11
8000a1f8:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000a1fc:	c0 c0       	breq	8000a214 <_dtoa_r+0x8bc>
8000a1fe:	f0 08 11 20 	rsub	r8,r8,32
8000a202:	58 48       	cp.w	r8,4
8000a204:	e0 8a 00 06 	brle	8000a210 <_dtoa_r+0x8b8>
8000a208:	20 48       	sub	r8,4
8000a20a:	10 0b       	add	r11,r8
8000a20c:	50 4b       	stdsp	sp[0x10],r11
8000a20e:	c0 78       	rjmp	8000a21c <_dtoa_r+0x8c4>
8000a210:	58 48       	cp.w	r8,4
8000a212:	c0 70       	breq	8000a220 <_dtoa_r+0x8c8>
8000a214:	40 4a       	lddsp	r10,sp[0x10]
8000a216:	2e 48       	sub	r8,-28
8000a218:	10 0a       	add	r10,r8
8000a21a:	50 4a       	stdsp	sp[0x10],r10
8000a21c:	10 00       	add	r0,r8
8000a21e:	10 05       	add	r5,r8
8000a220:	58 00       	cp.w	r0,0
8000a222:	e0 8a 00 08 	brle	8000a232 <_dtoa_r+0x8da>
8000a226:	06 9b       	mov	r11,r3
8000a228:	00 9a       	mov	r10,r0
8000a22a:	0e 9c       	mov	r12,r7
8000a22c:	e0 a0 07 58 	rcall	8000b0dc <__lshift>
8000a230:	18 93       	mov	r3,r12
8000a232:	40 49       	lddsp	r9,sp[0x10]
8000a234:	58 09       	cp.w	r9,0
8000a236:	e0 8a 00 08 	brle	8000a246 <_dtoa_r+0x8ee>
8000a23a:	04 9b       	mov	r11,r2
8000a23c:	12 9a       	mov	r10,r9
8000a23e:	0e 9c       	mov	r12,r7
8000a240:	e0 a0 07 4e 	rcall	8000b0dc <__lshift>
8000a244:	18 92       	mov	r2,r12
8000a246:	41 48       	lddsp	r8,sp[0x50]
8000a248:	58 08       	cp.w	r8,0
8000a24a:	c1 b0       	breq	8000a280 <_dtoa_r+0x928>
8000a24c:	04 9b       	mov	r11,r2
8000a24e:	06 9c       	mov	r12,r3
8000a250:	e0 a0 06 23 	rcall	8000ae96 <__mcmp>
8000a254:	c1 64       	brge	8000a280 <_dtoa_r+0x928>
8000a256:	06 9b       	mov	r11,r3
8000a258:	30 09       	mov	r9,0
8000a25a:	30 aa       	mov	r10,10
8000a25c:	0e 9c       	mov	r12,r7
8000a25e:	e0 a0 08 0b 	rcall	8000b274 <__multadd>
8000a262:	20 16       	sub	r6,1
8000a264:	18 93       	mov	r3,r12
8000a266:	40 dc       	lddsp	r12,sp[0x34]
8000a268:	58 0c       	cp.w	r12,0
8000a26a:	c0 31       	brne	8000a270 <_dtoa_r+0x918>
8000a26c:	40 91       	lddsp	r1,sp[0x24]
8000a26e:	c0 98       	rjmp	8000a280 <_dtoa_r+0x928>
8000a270:	08 9b       	mov	r11,r4
8000a272:	40 91       	lddsp	r1,sp[0x24]
8000a274:	30 09       	mov	r9,0
8000a276:	30 aa       	mov	r10,10
8000a278:	0e 9c       	mov	r12,r7
8000a27a:	e0 a0 07 fd 	rcall	8000b274 <__multadd>
8000a27e:	18 94       	mov	r4,r12
8000a280:	58 01       	cp.w	r1,0
8000a282:	5f a9       	srle	r9
8000a284:	40 cb       	lddsp	r11,sp[0x30]
8000a286:	58 2b       	cp.w	r11,2
8000a288:	5f 98       	srgt	r8
8000a28a:	f3 e8 00 08 	and	r8,r9,r8
8000a28e:	c2 50       	breq	8000a2d8 <_dtoa_r+0x980>
8000a290:	58 01       	cp.w	r1,0
8000a292:	c1 11       	brne	8000a2b4 <_dtoa_r+0x95c>
8000a294:	04 9b       	mov	r11,r2
8000a296:	02 99       	mov	r9,r1
8000a298:	30 5a       	mov	r10,5
8000a29a:	0e 9c       	mov	r12,r7
8000a29c:	e0 a0 07 ec 	rcall	8000b274 <__multadd>
8000a2a0:	18 92       	mov	r2,r12
8000a2a2:	18 9b       	mov	r11,r12
8000a2a4:	06 9c       	mov	r12,r3
8000a2a6:	e0 a0 05 f8 	rcall	8000ae96 <__mcmp>
8000a2aa:	e0 89 00 0f 	brgt	8000a2c8 <_dtoa_r+0x970>
8000a2ae:	c0 38       	rjmp	8000a2b4 <_dtoa_r+0x95c>
8000a2b0:	30 02       	mov	r2,0
8000a2b2:	04 94       	mov	r4,r2
8000a2b4:	40 ea       	lddsp	r10,sp[0x38]
8000a2b6:	30 09       	mov	r9,0
8000a2b8:	5c da       	com	r10
8000a2ba:	40 85       	lddsp	r5,sp[0x20]
8000a2bc:	50 6a       	stdsp	sp[0x18],r10
8000a2be:	50 49       	stdsp	sp[0x10],r9
8000a2c0:	c0 f9       	rjmp	8000a4de <_dtoa_r+0xb86>
8000a2c2:	08 92       	mov	r2,r4
8000a2c4:	40 66       	lddsp	r6,sp[0x18]
8000a2c6:	04 94       	mov	r4,r2
8000a2c8:	2f f6       	sub	r6,-1
8000a2ca:	50 66       	stdsp	sp[0x18],r6
8000a2cc:	33 18       	mov	r8,49
8000a2ce:	40 85       	lddsp	r5,sp[0x20]
8000a2d0:	0a c8       	st.b	r5++,r8
8000a2d2:	30 08       	mov	r8,0
8000a2d4:	50 48       	stdsp	sp[0x10],r8
8000a2d6:	c0 49       	rjmp	8000a4de <_dtoa_r+0xb86>
8000a2d8:	40 dc       	lddsp	r12,sp[0x34]
8000a2da:	58 0c       	cp.w	r12,0
8000a2dc:	e0 80 00 b5 	breq	8000a446 <_dtoa_r+0xaee>
8000a2e0:	58 05       	cp.w	r5,0
8000a2e2:	e0 8a 00 08 	brle	8000a2f2 <_dtoa_r+0x99a>
8000a2e6:	08 9b       	mov	r11,r4
8000a2e8:	0a 9a       	mov	r10,r5
8000a2ea:	0e 9c       	mov	r12,r7
8000a2ec:	e0 a0 06 f8 	rcall	8000b0dc <__lshift>
8000a2f0:	18 94       	mov	r4,r12
8000a2f2:	40 6b       	lddsp	r11,sp[0x18]
8000a2f4:	58 0b       	cp.w	r11,0
8000a2f6:	c0 31       	brne	8000a2fc <_dtoa_r+0x9a4>
8000a2f8:	08 9c       	mov	r12,r4
8000a2fa:	c1 38       	rjmp	8000a320 <_dtoa_r+0x9c8>
8000a2fc:	68 1b       	ld.w	r11,r4[0x4]
8000a2fe:	0e 9c       	mov	r12,r7
8000a300:	e0 a0 05 fe 	rcall	8000aefc <_Balloc>
8000a304:	68 4a       	ld.w	r10,r4[0x10]
8000a306:	18 95       	mov	r5,r12
8000a308:	e8 cb ff f4 	sub	r11,r4,-12
8000a30c:	2f ea       	sub	r10,-2
8000a30e:	2f 4c       	sub	r12,-12
8000a310:	a3 6a       	lsl	r10,0x2
8000a312:	fe b0 e6 50 	rcall	80006fb2 <memcpy>
8000a316:	0a 9b       	mov	r11,r5
8000a318:	30 1a       	mov	r10,1
8000a31a:	0e 9c       	mov	r12,r7
8000a31c:	e0 a0 06 e0 	rcall	8000b0dc <__lshift>
8000a320:	50 44       	stdsp	sp[0x10],r4
8000a322:	40 3a       	lddsp	r10,sp[0xc]
8000a324:	30 19       	mov	r9,1
8000a326:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
8000a32a:	18 94       	mov	r4,r12
8000a32c:	50 da       	stdsp	sp[0x34],r10
8000a32e:	40 85       	lddsp	r5,sp[0x20]
8000a330:	50 99       	stdsp	sp[0x24],r9
8000a332:	50 26       	stdsp	sp[0x8],r6
8000a334:	50 e1       	stdsp	sp[0x38],r1
8000a336:	04 9b       	mov	r11,r2
8000a338:	06 9c       	mov	r12,r3
8000a33a:	fe b0 fa 7f 	rcall	80009838 <quorem>
8000a33e:	40 4b       	lddsp	r11,sp[0x10]
8000a340:	f8 c0 ff d0 	sub	r0,r12,-48
8000a344:	06 9c       	mov	r12,r3
8000a346:	e0 a0 05 a8 	rcall	8000ae96 <__mcmp>
8000a34a:	08 9a       	mov	r10,r4
8000a34c:	50 6c       	stdsp	sp[0x18],r12
8000a34e:	04 9b       	mov	r11,r2
8000a350:	0e 9c       	mov	r12,r7
8000a352:	e0 a0 06 5d 	rcall	8000b00c <__mdiff>
8000a356:	18 91       	mov	r1,r12
8000a358:	78 38       	ld.w	r8,r12[0xc]
8000a35a:	58 08       	cp.w	r8,0
8000a35c:	c0 30       	breq	8000a362 <_dtoa_r+0xa0a>
8000a35e:	30 16       	mov	r6,1
8000a360:	c0 68       	rjmp	8000a36c <_dtoa_r+0xa14>
8000a362:	18 9b       	mov	r11,r12
8000a364:	06 9c       	mov	r12,r3
8000a366:	e0 a0 05 98 	rcall	8000ae96 <__mcmp>
8000a36a:	18 96       	mov	r6,r12
8000a36c:	0e 9c       	mov	r12,r7
8000a36e:	02 9b       	mov	r11,r1
8000a370:	e0 a0 05 ac 	rcall	8000aec8 <_Bfree>
8000a374:	40 cc       	lddsp	r12,sp[0x30]
8000a376:	ed ec 10 08 	or	r8,r6,r12
8000a37a:	c0 d1       	brne	8000a394 <_dtoa_r+0xa3c>
8000a37c:	40 db       	lddsp	r11,sp[0x34]
8000a37e:	58 0b       	cp.w	r11,0
8000a380:	c0 a1       	brne	8000a394 <_dtoa_r+0xa3c>
8000a382:	40 26       	lddsp	r6,sp[0x8]
8000a384:	e0 40 00 39 	cp.w	r0,57
8000a388:	c3 00       	breq	8000a3e8 <_dtoa_r+0xa90>
8000a38a:	40 6a       	lddsp	r10,sp[0x18]
8000a38c:	58 0a       	cp.w	r10,0
8000a38e:	e0 89 00 24 	brgt	8000a3d6 <_dtoa_r+0xa7e>
8000a392:	c2 f8       	rjmp	8000a3f0 <_dtoa_r+0xa98>
8000a394:	40 69       	lddsp	r9,sp[0x18]
8000a396:	58 09       	cp.w	r9,0
8000a398:	c0 85       	brlt	8000a3a8 <_dtoa_r+0xa50>
8000a39a:	12 98       	mov	r8,r9
8000a39c:	40 cc       	lddsp	r12,sp[0x30]
8000a39e:	18 48       	or	r8,r12
8000a3a0:	c1 d1       	brne	8000a3da <_dtoa_r+0xa82>
8000a3a2:	40 db       	lddsp	r11,sp[0x34]
8000a3a4:	58 0b       	cp.w	r11,0
8000a3a6:	c1 a1       	brne	8000a3da <_dtoa_r+0xa82>
8000a3a8:	0c 99       	mov	r9,r6
8000a3aa:	40 26       	lddsp	r6,sp[0x8]
8000a3ac:	58 09       	cp.w	r9,0
8000a3ae:	e0 8a 00 21 	brle	8000a3f0 <_dtoa_r+0xa98>
8000a3b2:	06 9b       	mov	r11,r3
8000a3b4:	30 1a       	mov	r10,1
8000a3b6:	0e 9c       	mov	r12,r7
8000a3b8:	e0 a0 06 92 	rcall	8000b0dc <__lshift>
8000a3bc:	04 9b       	mov	r11,r2
8000a3be:	18 93       	mov	r3,r12
8000a3c0:	e0 a0 05 6b 	rcall	8000ae96 <__mcmp>
8000a3c4:	e0 89 00 06 	brgt	8000a3d0 <_dtoa_r+0xa78>
8000a3c8:	c1 41       	brne	8000a3f0 <_dtoa_r+0xa98>
8000a3ca:	ed b0 00 00 	bld	r0,0x0
8000a3ce:	c1 11       	brne	8000a3f0 <_dtoa_r+0xa98>
8000a3d0:	e0 40 00 39 	cp.w	r0,57
8000a3d4:	c0 a0       	breq	8000a3e8 <_dtoa_r+0xa90>
8000a3d6:	2f f0       	sub	r0,-1
8000a3d8:	c0 c8       	rjmp	8000a3f0 <_dtoa_r+0xa98>
8000a3da:	58 06       	cp.w	r6,0
8000a3dc:	e0 8a 00 0c 	brle	8000a3f4 <_dtoa_r+0xa9c>
8000a3e0:	40 26       	lddsp	r6,sp[0x8]
8000a3e2:	e0 40 00 39 	cp.w	r0,57
8000a3e6:	c0 41       	brne	8000a3ee <_dtoa_r+0xa96>
8000a3e8:	33 98       	mov	r8,57
8000a3ea:	0a c8       	st.b	r5++,r8
8000a3ec:	c6 78       	rjmp	8000a4ba <_dtoa_r+0xb62>
8000a3ee:	2f f0       	sub	r0,-1
8000a3f0:	0a c0       	st.b	r5++,r0
8000a3f2:	c7 58       	rjmp	8000a4dc <_dtoa_r+0xb84>
8000a3f4:	0a c0       	st.b	r5++,r0
8000a3f6:	40 9a       	lddsp	r10,sp[0x24]
8000a3f8:	40 e9       	lddsp	r9,sp[0x38]
8000a3fa:	12 3a       	cp.w	r10,r9
8000a3fc:	c4 30       	breq	8000a482 <_dtoa_r+0xb2a>
8000a3fe:	06 9b       	mov	r11,r3
8000a400:	30 09       	mov	r9,0
8000a402:	30 aa       	mov	r10,10
8000a404:	0e 9c       	mov	r12,r7
8000a406:	e0 a0 07 37 	rcall	8000b274 <__multadd>
8000a40a:	40 48       	lddsp	r8,sp[0x10]
8000a40c:	18 93       	mov	r3,r12
8000a40e:	08 38       	cp.w	r8,r4
8000a410:	c0 91       	brne	8000a422 <_dtoa_r+0xaca>
8000a412:	10 9b       	mov	r11,r8
8000a414:	30 09       	mov	r9,0
8000a416:	30 aa       	mov	r10,10
8000a418:	0e 9c       	mov	r12,r7
8000a41a:	e0 a0 07 2d 	rcall	8000b274 <__multadd>
8000a41e:	50 4c       	stdsp	sp[0x10],r12
8000a420:	c0 e8       	rjmp	8000a43c <_dtoa_r+0xae4>
8000a422:	40 4b       	lddsp	r11,sp[0x10]
8000a424:	30 09       	mov	r9,0
8000a426:	30 aa       	mov	r10,10
8000a428:	0e 9c       	mov	r12,r7
8000a42a:	e0 a0 07 25 	rcall	8000b274 <__multadd>
8000a42e:	08 9b       	mov	r11,r4
8000a430:	50 4c       	stdsp	sp[0x10],r12
8000a432:	30 09       	mov	r9,0
8000a434:	30 aa       	mov	r10,10
8000a436:	0e 9c       	mov	r12,r7
8000a438:	e0 a0 07 1e 	rcall	8000b274 <__multadd>
8000a43c:	18 94       	mov	r4,r12
8000a43e:	40 9c       	lddsp	r12,sp[0x24]
8000a440:	2f fc       	sub	r12,-1
8000a442:	50 9c       	stdsp	sp[0x24],r12
8000a444:	c7 9b       	rjmp	8000a336 <_dtoa_r+0x9de>
8000a446:	30 18       	mov	r8,1
8000a448:	06 90       	mov	r0,r3
8000a44a:	40 85       	lddsp	r5,sp[0x20]
8000a44c:	08 93       	mov	r3,r4
8000a44e:	0c 94       	mov	r4,r6
8000a450:	10 96       	mov	r6,r8
8000a452:	04 9b       	mov	r11,r2
8000a454:	00 9c       	mov	r12,r0
8000a456:	fe b0 f9 f1 	rcall	80009838 <quorem>
8000a45a:	2d 0c       	sub	r12,-48
8000a45c:	0a cc       	st.b	r5++,r12
8000a45e:	02 36       	cp.w	r6,r1
8000a460:	c0 a4       	brge	8000a474 <_dtoa_r+0xb1c>
8000a462:	00 9b       	mov	r11,r0
8000a464:	30 09       	mov	r9,0
8000a466:	30 aa       	mov	r10,10
8000a468:	0e 9c       	mov	r12,r7
8000a46a:	2f f6       	sub	r6,-1
8000a46c:	e0 a0 07 04 	rcall	8000b274 <__multadd>
8000a470:	18 90       	mov	r0,r12
8000a472:	cf 0b       	rjmp	8000a452 <_dtoa_r+0xafa>
8000a474:	08 96       	mov	r6,r4
8000a476:	30 0b       	mov	r11,0
8000a478:	06 94       	mov	r4,r3
8000a47a:	50 4b       	stdsp	sp[0x10],r11
8000a47c:	00 93       	mov	r3,r0
8000a47e:	18 90       	mov	r0,r12
8000a480:	c0 28       	rjmp	8000a484 <_dtoa_r+0xb2c>
8000a482:	40 26       	lddsp	r6,sp[0x8]
8000a484:	06 9b       	mov	r11,r3
8000a486:	30 1a       	mov	r10,1
8000a488:	0e 9c       	mov	r12,r7
8000a48a:	e0 a0 06 29 	rcall	8000b0dc <__lshift>
8000a48e:	04 9b       	mov	r11,r2
8000a490:	18 93       	mov	r3,r12
8000a492:	e0 a0 05 02 	rcall	8000ae96 <__mcmp>
8000a496:	e0 89 00 12 	brgt	8000a4ba <_dtoa_r+0xb62>
8000a49a:	c1 b1       	brne	8000a4d0 <_dtoa_r+0xb78>
8000a49c:	e1 d0 c0 01 	bfextu	r0,r0,0x0,0x1
8000a4a0:	c0 d1       	brne	8000a4ba <_dtoa_r+0xb62>
8000a4a2:	c1 78       	rjmp	8000a4d0 <_dtoa_r+0xb78>
8000a4a4:	40 89       	lddsp	r9,sp[0x20]
8000a4a6:	12 38       	cp.w	r8,r9
8000a4a8:	c0 30       	breq	8000a4ae <_dtoa_r+0xb56>
8000a4aa:	10 95       	mov	r5,r8
8000a4ac:	c0 88       	rjmp	8000a4bc <_dtoa_r+0xb64>
8000a4ae:	2f f6       	sub	r6,-1
8000a4b0:	50 66       	stdsp	sp[0x18],r6
8000a4b2:	33 18       	mov	r8,49
8000a4b4:	40 8c       	lddsp	r12,sp[0x20]
8000a4b6:	b8 88       	st.b	r12[0x0],r8
8000a4b8:	c1 38       	rjmp	8000a4de <_dtoa_r+0xb86>
8000a4ba:	33 9a       	mov	r10,57
8000a4bc:	0a 98       	mov	r8,r5
8000a4be:	11 79       	ld.ub	r9,--r8
8000a4c0:	f4 09 18 00 	cp.b	r9,r10
8000a4c4:	cf 00       	breq	8000a4a4 <_dtoa_r+0xb4c>
8000a4c6:	2f f9       	sub	r9,-1
8000a4c8:	b0 89       	st.b	r8[0x0],r9
8000a4ca:	c0 98       	rjmp	8000a4dc <_dtoa_r+0xb84>
8000a4cc:	10 95       	mov	r5,r8
8000a4ce:	c0 28       	rjmp	8000a4d2 <_dtoa_r+0xb7a>
8000a4d0:	33 09       	mov	r9,48
8000a4d2:	0a 98       	mov	r8,r5
8000a4d4:	11 7a       	ld.ub	r10,--r8
8000a4d6:	f2 0a 18 00 	cp.b	r10,r9
8000a4da:	cf 90       	breq	8000a4cc <_dtoa_r+0xb74>
8000a4dc:	50 66       	stdsp	sp[0x18],r6
8000a4de:	04 9b       	mov	r11,r2
8000a4e0:	0e 9c       	mov	r12,r7
8000a4e2:	e0 a0 04 f3 	rcall	8000aec8 <_Bfree>
8000a4e6:	58 04       	cp.w	r4,0
8000a4e8:	c1 20       	breq	8000a50c <_dtoa_r+0xbb4>
8000a4ea:	40 4b       	lddsp	r11,sp[0x10]
8000a4ec:	08 3b       	cp.w	r11,r4
8000a4ee:	5f 19       	srne	r9
8000a4f0:	58 0b       	cp.w	r11,0
8000a4f2:	5f 18       	srne	r8
8000a4f4:	f3 e8 00 08 	and	r8,r9,r8
8000a4f8:	c0 40       	breq	8000a500 <_dtoa_r+0xba8>
8000a4fa:	0e 9c       	mov	r12,r7
8000a4fc:	e0 a0 04 e6 	rcall	8000aec8 <_Bfree>
8000a500:	08 9b       	mov	r11,r4
8000a502:	0e 9c       	mov	r12,r7
8000a504:	e0 a0 04 e2 	rcall	8000aec8 <_Bfree>
8000a508:	c0 28       	rjmp	8000a50c <_dtoa_r+0xbb4>
8000a50a:	50 66       	stdsp	sp[0x18],r6
8000a50c:	0e 9c       	mov	r12,r7
8000a50e:	06 9b       	mov	r11,r3
8000a510:	e0 a0 04 dc 	rcall	8000aec8 <_Bfree>
8000a514:	30 08       	mov	r8,0
8000a516:	aa 88       	st.b	r5[0x0],r8
8000a518:	40 68       	lddsp	r8,sp[0x18]
8000a51a:	41 5a       	lddsp	r10,sp[0x54]
8000a51c:	2f f8       	sub	r8,-1
8000a51e:	41 29       	lddsp	r9,sp[0x48]
8000a520:	95 08       	st.w	r10[0x0],r8
8000a522:	40 8c       	lddsp	r12,sp[0x20]
8000a524:	58 09       	cp.w	r9,0
8000a526:	fb f8 10 12 	ld.wne	r8,sp[0x48]
8000a52a:	f1 f5 1a 00 	st.wne	r8[0x0],r5
8000a52e:	2e 6d       	sub	sp,-104
8000a530:	d8 32       	popm	r0-r7,pc
8000a532:	d7 03       	nop

8000a534 <__errno>:
8000a534:	e0 68 0a 38 	mov	r8,2616
8000a538:	70 0c       	ld.w	r12,r8[0x0]
8000a53a:	2f 4c       	sub	r12,-12
8000a53c:	5e fc       	retal	r12
8000a53e:	d7 03       	nop

8000a540 <_fflush_r>:
8000a540:	d4 21       	pushm	r4-r7,lr
8000a542:	16 97       	mov	r7,r11
8000a544:	18 96       	mov	r6,r12
8000a546:	76 48       	ld.w	r8,r11[0x10]
8000a548:	58 08       	cp.w	r8,0
8000a54a:	c7 f0       	breq	8000a648 <_fflush_r+0x108>
8000a54c:	58 0c       	cp.w	r12,0
8000a54e:	c0 50       	breq	8000a558 <_fflush_r+0x18>
8000a550:	78 68       	ld.w	r8,r12[0x18]
8000a552:	58 08       	cp.w	r8,0
8000a554:	c0 21       	brne	8000a558 <_fflush_r+0x18>
8000a556:	cc dc       	rcall	8000a6f0 <__sinit>
8000a558:	fe c8 cd 8c 	sub	r8,pc,-12916
8000a55c:	10 37       	cp.w	r7,r8
8000a55e:	c0 31       	brne	8000a564 <_fflush_r+0x24>
8000a560:	6c 07       	ld.w	r7,r6[0x0]
8000a562:	c0 c8       	rjmp	8000a57a <_fflush_r+0x3a>
8000a564:	fe c8 cd 78 	sub	r8,pc,-12936
8000a568:	10 37       	cp.w	r7,r8
8000a56a:	c0 31       	brne	8000a570 <_fflush_r+0x30>
8000a56c:	6c 17       	ld.w	r7,r6[0x4]
8000a56e:	c0 68       	rjmp	8000a57a <_fflush_r+0x3a>
8000a570:	fe c8 cd 64 	sub	r8,pc,-12956
8000a574:	10 37       	cp.w	r7,r8
8000a576:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000a57a:	8e 6a       	ld.sh	r10,r7[0xc]
8000a57c:	14 98       	mov	r8,r10
8000a57e:	ed ba 00 03 	bld	r10,0x3
8000a582:	c4 20       	breq	8000a606 <_fflush_r+0xc6>
8000a584:	ab ba       	sbr	r10,0xb
8000a586:	ae 6a       	st.h	r7[0xc],r10
8000a588:	6e 18       	ld.w	r8,r7[0x4]
8000a58a:	58 08       	cp.w	r8,0
8000a58c:	e0 89 00 06 	brgt	8000a598 <_fflush_r+0x58>
8000a590:	6f 08       	ld.w	r8,r7[0x40]
8000a592:	58 08       	cp.w	r8,0
8000a594:	e0 8a 00 5a 	brle	8000a648 <_fflush_r+0x108>
8000a598:	6e b8       	ld.w	r8,r7[0x2c]
8000a59a:	58 08       	cp.w	r8,0
8000a59c:	c5 60       	breq	8000a648 <_fflush_r+0x108>
8000a59e:	e2 1a 10 00 	andl	r10,0x1000,COH
8000a5a2:	c0 30       	breq	8000a5a8 <_fflush_r+0x68>
8000a5a4:	6f 55       	ld.w	r5,r7[0x54]
8000a5a6:	c0 f8       	rjmp	8000a5c4 <_fflush_r+0x84>
8000a5a8:	30 19       	mov	r9,1
8000a5aa:	6e 8b       	ld.w	r11,r7[0x20]
8000a5ac:	0c 9c       	mov	r12,r6
8000a5ae:	5d 18       	icall	r8
8000a5b0:	18 95       	mov	r5,r12
8000a5b2:	5b fc       	cp.w	r12,-1
8000a5b4:	c0 81       	brne	8000a5c4 <_fflush_r+0x84>
8000a5b6:	6c 38       	ld.w	r8,r6[0xc]
8000a5b8:	59 d8       	cp.w	r8,29
8000a5ba:	c4 70       	breq	8000a648 <_fflush_r+0x108>
8000a5bc:	8e 68       	ld.sh	r8,r7[0xc]
8000a5be:	a7 a8       	sbr	r8,0x6
8000a5c0:	ae 68       	st.h	r7[0xc],r8
8000a5c2:	d8 22       	popm	r4-r7,pc
8000a5c4:	8e 68       	ld.sh	r8,r7[0xc]
8000a5c6:	ed b8 00 02 	bld	r8,0x2
8000a5ca:	c0 91       	brne	8000a5dc <_fflush_r+0x9c>
8000a5cc:	6e 18       	ld.w	r8,r7[0x4]
8000a5ce:	10 15       	sub	r5,r8
8000a5d0:	6e d8       	ld.w	r8,r7[0x34]
8000a5d2:	58 08       	cp.w	r8,0
8000a5d4:	ef f8 10 10 	ld.wne	r8,r7[0x40]
8000a5d8:	eb d8 e1 15 	subne	r5,r5,r8
8000a5dc:	6e b8       	ld.w	r8,r7[0x2c]
8000a5de:	0c 9c       	mov	r12,r6
8000a5e0:	30 09       	mov	r9,0
8000a5e2:	0a 9a       	mov	r10,r5
8000a5e4:	6e 8b       	ld.w	r11,r7[0x20]
8000a5e6:	5d 18       	icall	r8
8000a5e8:	8e 68       	ld.sh	r8,r7[0xc]
8000a5ea:	0a 3c       	cp.w	r12,r5
8000a5ec:	c2 61       	brne	8000a638 <_fflush_r+0xf8>
8000a5ee:	ab d8       	cbr	r8,0xb
8000a5f0:	30 0c       	mov	r12,0
8000a5f2:	6e 49       	ld.w	r9,r7[0x10]
8000a5f4:	ae 68       	st.h	r7[0xc],r8
8000a5f6:	8f 1c       	st.w	r7[0x4],r12
8000a5f8:	8f 09       	st.w	r7[0x0],r9
8000a5fa:	ed b8 00 0c 	bld	r8,0xc
8000a5fe:	c2 51       	brne	8000a648 <_fflush_r+0x108>
8000a600:	ef 45 00 54 	st.w	r7[84],r5
8000a604:	d8 22       	popm	r4-r7,pc
8000a606:	6e 45       	ld.w	r5,r7[0x10]
8000a608:	58 05       	cp.w	r5,0
8000a60a:	c1 f0       	breq	8000a648 <_fflush_r+0x108>
8000a60c:	6e 04       	ld.w	r4,r7[0x0]
8000a60e:	f5 da c0 02 	bfextu	r10,r10,0x0,0x2
8000a612:	8f 05       	st.w	r7[0x0],r5
8000a614:	f9 b8 01 00 	movne	r8,0
8000a618:	ef f8 00 05 	ld.weq	r8,r7[0x14]
8000a61c:	0a 14       	sub	r4,r5
8000a61e:	8f 28       	st.w	r7[0x8],r8
8000a620:	c1 18       	rjmp	8000a642 <_fflush_r+0x102>
8000a622:	08 99       	mov	r9,r4
8000a624:	0a 9a       	mov	r10,r5
8000a626:	6e a8       	ld.w	r8,r7[0x28]
8000a628:	6e 8b       	ld.w	r11,r7[0x20]
8000a62a:	0c 9c       	mov	r12,r6
8000a62c:	5d 18       	icall	r8
8000a62e:	18 14       	sub	r4,r12
8000a630:	58 0c       	cp.w	r12,0
8000a632:	e0 89 00 07 	brgt	8000a640 <_fflush_r+0x100>
8000a636:	8e 68       	ld.sh	r8,r7[0xc]
8000a638:	a7 a8       	sbr	r8,0x6
8000a63a:	3f fc       	mov	r12,-1
8000a63c:	ae 68       	st.h	r7[0xc],r8
8000a63e:	d8 22       	popm	r4-r7,pc
8000a640:	18 05       	add	r5,r12
8000a642:	58 04       	cp.w	r4,0
8000a644:	fe 99 ff ef 	brgt	8000a622 <_fflush_r+0xe2>
8000a648:	d8 2a       	popm	r4-r7,pc,r12=0
8000a64a:	d7 03       	nop

8000a64c <__sfp_lock_acquire>:
8000a64c:	5e fc       	retal	r12

8000a64e <__sfp_lock_release>:
8000a64e:	5e fc       	retal	r12

8000a650 <_cleanup_r>:
8000a650:	d4 01       	pushm	lr
8000a652:	fe cb f0 ae 	sub	r11,pc,-3922
8000a656:	e0 a0 02 f7 	rcall	8000ac44 <_fwalk>
8000a65a:	d8 02       	popm	pc

8000a65c <__sfmoreglue>:
8000a65c:	d4 21       	pushm	r4-r7,lr
8000a65e:	16 95       	mov	r5,r11
8000a660:	f6 06 10 5c 	mul	r6,r11,92
8000a664:	ec cb ff f4 	sub	r11,r6,-12
8000a668:	fe b0 e2 76 	rcall	80006b54 <_malloc_r>
8000a66c:	18 97       	mov	r7,r12
8000a66e:	c0 90       	breq	8000a680 <__sfmoreglue+0x24>
8000a670:	99 15       	st.w	r12[0x4],r5
8000a672:	30 0b       	mov	r11,0
8000a674:	2f 4c       	sub	r12,-12
8000a676:	0c 9a       	mov	r10,r6
8000a678:	8f 2c       	st.w	r7[0x8],r12
8000a67a:	8f 0b       	st.w	r7[0x0],r11
8000a67c:	fe b0 e5 3f 	rcall	800070fa <memset>
8000a680:	0e 9c       	mov	r12,r7
8000a682:	d8 22       	popm	r4-r7,pc

8000a684 <__sfp>:
8000a684:	d4 21       	pushm	r4-r7,lr
8000a686:	fe c8 ce 56 	sub	r8,pc,-12714
8000a68a:	18 96       	mov	r6,r12
8000a68c:	70 07       	ld.w	r7,r8[0x0]
8000a68e:	6e 68       	ld.w	r8,r7[0x18]
8000a690:	58 08       	cp.w	r8,0
8000a692:	c0 31       	brne	8000a698 <__sfp+0x14>
8000a694:	0e 9c       	mov	r12,r7
8000a696:	c2 dc       	rcall	8000a6f0 <__sinit>
8000a698:	ee c7 ff 28 	sub	r7,r7,-216
8000a69c:	30 05       	mov	r5,0
8000a69e:	6e 2c       	ld.w	r12,r7[0x8]
8000a6a0:	6e 18       	ld.w	r8,r7[0x4]
8000a6a2:	c0 68       	rjmp	8000a6ae <__sfp+0x2a>
8000a6a4:	98 69       	ld.sh	r9,r12[0xc]
8000a6a6:	ea 09 19 00 	cp.h	r9,r5
8000a6aa:	c1 10       	breq	8000a6cc <__sfp+0x48>
8000a6ac:	2a 4c       	sub	r12,-92
8000a6ae:	20 18       	sub	r8,1
8000a6b0:	cf a7       	brpl	8000a6a4 <__sfp+0x20>
8000a6b2:	6e 08       	ld.w	r8,r7[0x0]
8000a6b4:	58 08       	cp.w	r8,0
8000a6b6:	c0 61       	brne	8000a6c2 <__sfp+0x3e>
8000a6b8:	30 4b       	mov	r11,4
8000a6ba:	0c 9c       	mov	r12,r6
8000a6bc:	cd 0f       	rcall	8000a65c <__sfmoreglue>
8000a6be:	8f 0c       	st.w	r7[0x0],r12
8000a6c0:	c0 30       	breq	8000a6c6 <__sfp+0x42>
8000a6c2:	6e 07       	ld.w	r7,r7[0x0]
8000a6c4:	ce db       	rjmp	8000a69e <__sfp+0x1a>
8000a6c6:	30 c8       	mov	r8,12
8000a6c8:	8d 38       	st.w	r6[0xc],r8
8000a6ca:	d8 22       	popm	r4-r7,pc
8000a6cc:	30 08       	mov	r8,0
8000a6ce:	f9 48 00 4c 	st.w	r12[76],r8
8000a6d2:	99 08       	st.w	r12[0x0],r8
8000a6d4:	99 28       	st.w	r12[0x8],r8
8000a6d6:	99 18       	st.w	r12[0x4],r8
8000a6d8:	99 48       	st.w	r12[0x10],r8
8000a6da:	99 58       	st.w	r12[0x14],r8
8000a6dc:	99 68       	st.w	r12[0x18],r8
8000a6de:	99 d8       	st.w	r12[0x34],r8
8000a6e0:	99 e8       	st.w	r12[0x38],r8
8000a6e2:	f9 48 00 48 	st.w	r12[72],r8
8000a6e6:	3f f8       	mov	r8,-1
8000a6e8:	b8 78       	st.h	r12[0xe],r8
8000a6ea:	30 18       	mov	r8,1
8000a6ec:	b8 68       	st.h	r12[0xc],r8
8000a6ee:	d8 22       	popm	r4-r7,pc

8000a6f0 <__sinit>:
8000a6f0:	d4 21       	pushm	r4-r7,lr
8000a6f2:	18 96       	mov	r6,r12
8000a6f4:	78 67       	ld.w	r7,r12[0x18]
8000a6f6:	58 07       	cp.w	r7,0
8000a6f8:	c4 91       	brne	8000a78a <__sinit+0x9a>
8000a6fa:	fe c8 00 aa 	sub	r8,pc,170
8000a6fe:	30 15       	mov	r5,1
8000a700:	99 a8       	st.w	r12[0x28],r8
8000a702:	f9 47 00 d8 	st.w	r12[216],r7
8000a706:	f9 47 00 dc 	st.w	r12[220],r7
8000a70a:	f9 47 00 e0 	st.w	r12[224],r7
8000a70e:	99 65       	st.w	r12[0x18],r5
8000a710:	cb af       	rcall	8000a684 <__sfp>
8000a712:	8d 0c       	st.w	r6[0x0],r12
8000a714:	0c 9c       	mov	r12,r6
8000a716:	cb 7f       	rcall	8000a684 <__sfp>
8000a718:	8d 1c       	st.w	r6[0x4],r12
8000a71a:	0c 9c       	mov	r12,r6
8000a71c:	cb 4f       	rcall	8000a684 <__sfp>
8000a71e:	6c 09       	ld.w	r9,r6[0x0]
8000a720:	30 48       	mov	r8,4
8000a722:	93 07       	st.w	r9[0x0],r7
8000a724:	b2 68       	st.h	r9[0xc],r8
8000a726:	93 17       	st.w	r9[0x4],r7
8000a728:	93 27       	st.w	r9[0x8],r7
8000a72a:	6c 18       	ld.w	r8,r6[0x4]
8000a72c:	b2 77       	st.h	r9[0xe],r7
8000a72e:	93 47       	st.w	r9[0x10],r7
8000a730:	93 57       	st.w	r9[0x14],r7
8000a732:	93 67       	st.w	r9[0x18],r7
8000a734:	93 89       	st.w	r9[0x20],r9
8000a736:	91 07       	st.w	r8[0x0],r7
8000a738:	91 17       	st.w	r8[0x4],r7
8000a73a:	91 27       	st.w	r8[0x8],r7
8000a73c:	fe ce f3 24 	sub	lr,pc,-3292
8000a740:	fe cb f3 54 	sub	r11,pc,-3244
8000a744:	93 9e       	st.w	r9[0x24],lr
8000a746:	93 ab       	st.w	r9[0x28],r11
8000a748:	fe ca f3 7c 	sub	r10,pc,-3204
8000a74c:	fe c4 f3 88 	sub	r4,pc,-3192
8000a750:	93 ba       	st.w	r9[0x2c],r10
8000a752:	93 c4       	st.w	r9[0x30],r4
8000a754:	30 99       	mov	r9,9
8000a756:	b0 69       	st.h	r8[0xc],r9
8000a758:	b0 75       	st.h	r8[0xe],r5
8000a75a:	91 c4       	st.w	r8[0x30],r4
8000a75c:	91 47       	st.w	r8[0x10],r7
8000a75e:	91 57       	st.w	r8[0x14],r7
8000a760:	91 67       	st.w	r8[0x18],r7
8000a762:	91 88       	st.w	r8[0x20],r8
8000a764:	91 9e       	st.w	r8[0x24],lr
8000a766:	91 ab       	st.w	r8[0x28],r11
8000a768:	91 ba       	st.w	r8[0x2c],r10
8000a76a:	8d 2c       	st.w	r6[0x8],r12
8000a76c:	31 28       	mov	r8,18
8000a76e:	99 07       	st.w	r12[0x0],r7
8000a770:	b8 68       	st.h	r12[0xc],r8
8000a772:	99 17       	st.w	r12[0x4],r7
8000a774:	99 27       	st.w	r12[0x8],r7
8000a776:	30 28       	mov	r8,2
8000a778:	b8 78       	st.h	r12[0xe],r8
8000a77a:	99 c4       	st.w	r12[0x30],r4
8000a77c:	99 67       	st.w	r12[0x18],r7
8000a77e:	99 9e       	st.w	r12[0x24],lr
8000a780:	99 ab       	st.w	r12[0x28],r11
8000a782:	99 ba       	st.w	r12[0x2c],r10
8000a784:	99 47       	st.w	r12[0x10],r7
8000a786:	99 57       	st.w	r12[0x14],r7
8000a788:	99 8c       	st.w	r12[0x20],r12
8000a78a:	d8 22       	popm	r4-r7,pc

8000a78c <_malloc_trim_r>:
8000a78c:	d4 21       	pushm	r4-r7,lr
8000a78e:	16 95       	mov	r5,r11
8000a790:	18 97       	mov	r7,r12
8000a792:	fe b0 d7 ed 	rcall	8000576c <__malloc_lock>
8000a796:	e0 64 05 38 	mov	r4,1336
8000a79a:	68 28       	ld.w	r8,r4[0x8]
8000a79c:	70 16       	ld.w	r6,r8[0x4]
8000a79e:	e0 16 ff fc 	andl	r6,0xfffc
8000a7a2:	ec c8 ff 91 	sub	r8,r6,-111
8000a7a6:	f0 05 01 05 	sub	r5,r8,r5
8000a7aa:	e0 15 ff 80 	andl	r5,0xff80
8000a7ae:	ea c5 00 80 	sub	r5,r5,128
8000a7b2:	e0 45 00 7f 	cp.w	r5,127
8000a7b6:	e0 8a 00 25 	brle	8000a800 <_malloc_trim_r+0x74>
8000a7ba:	30 0b       	mov	r11,0
8000a7bc:	0e 9c       	mov	r12,r7
8000a7be:	fe b0 e6 05 	rcall	800073c8 <_sbrk_r>
8000a7c2:	68 28       	ld.w	r8,r4[0x8]
8000a7c4:	0c 08       	add	r8,r6
8000a7c6:	10 3c       	cp.w	r12,r8
8000a7c8:	c1 c1       	brne	8000a800 <_malloc_trim_r+0x74>
8000a7ca:	ea 0b 11 00 	rsub	r11,r5,0
8000a7ce:	0e 9c       	mov	r12,r7
8000a7d0:	fe b0 e5 fc 	rcall	800073c8 <_sbrk_r>
8000a7d4:	5b fc       	cp.w	r12,-1
8000a7d6:	c1 91       	brne	8000a808 <_malloc_trim_r+0x7c>
8000a7d8:	30 0b       	mov	r11,0
8000a7da:	0e 9c       	mov	r12,r7
8000a7dc:	fe b0 e5 f6 	rcall	800073c8 <_sbrk_r>
8000a7e0:	68 28       	ld.w	r8,r4[0x8]
8000a7e2:	f8 08 01 09 	sub	r9,r12,r8
8000a7e6:	58 f9       	cp.w	r9,15
8000a7e8:	e0 8a 00 0c 	brle	8000a800 <_malloc_trim_r+0x74>
8000a7ec:	a1 a9       	sbr	r9,0x0
8000a7ee:	91 19       	st.w	r8[0x4],r9
8000a7f0:	e0 68 09 44 	mov	r8,2372
8000a7f4:	70 09       	ld.w	r9,r8[0x0]
8000a7f6:	e0 68 0d 58 	mov	r8,3416
8000a7fa:	f8 09 01 09 	sub	r9,r12,r9
8000a7fe:	91 09       	st.w	r8[0x0],r9
8000a800:	0e 9c       	mov	r12,r7
8000a802:	fe b0 d7 bb 	rcall	80005778 <__malloc_unlock>
8000a806:	d8 2a       	popm	r4-r7,pc,r12=0
8000a808:	68 28       	ld.w	r8,r4[0x8]
8000a80a:	0a 16       	sub	r6,r5
8000a80c:	a1 a6       	sbr	r6,0x0
8000a80e:	91 16       	st.w	r8[0x4],r6
8000a810:	e0 68 0d 58 	mov	r8,3416
8000a814:	70 09       	ld.w	r9,r8[0x0]
8000a816:	0a 19       	sub	r9,r5
8000a818:	0e 9c       	mov	r12,r7
8000a81a:	91 09       	st.w	r8[0x0],r9
8000a81c:	fe b0 d7 ae 	rcall	80005778 <__malloc_unlock>
8000a820:	da 2a       	popm	r4-r7,pc,r12=1
8000a822:	d7 03       	nop

8000a824 <_free_r>:
8000a824:	d4 21       	pushm	r4-r7,lr
8000a826:	16 96       	mov	r6,r11
8000a828:	18 97       	mov	r7,r12
8000a82a:	58 0b       	cp.w	r11,0
8000a82c:	e0 80 00 c0 	breq	8000a9ac <_free_r+0x188>
8000a830:	fe b0 d7 9e 	rcall	8000576c <__malloc_lock>
8000a834:	20 86       	sub	r6,8
8000a836:	e0 6a 05 38 	mov	r10,1336
8000a83a:	6c 18       	ld.w	r8,r6[0x4]
8000a83c:	74 2e       	ld.w	lr,r10[0x8]
8000a83e:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
8000a842:	a1 c8       	cbr	r8,0x0
8000a844:	ec 08 00 09 	add	r9,r6,r8
8000a848:	72 1b       	ld.w	r11,r9[0x4]
8000a84a:	e0 1b ff fc 	andl	r11,0xfffc
8000a84e:	1c 39       	cp.w	r9,lr
8000a850:	c1 e1       	brne	8000a88c <_free_r+0x68>
8000a852:	f6 08 00 08 	add	r8,r11,r8
8000a856:	58 0c       	cp.w	r12,0
8000a858:	c0 81       	brne	8000a868 <_free_r+0x44>
8000a85a:	6c 09       	ld.w	r9,r6[0x0]
8000a85c:	12 16       	sub	r6,r9
8000a85e:	12 08       	add	r8,r9
8000a860:	6c 3b       	ld.w	r11,r6[0xc]
8000a862:	6c 29       	ld.w	r9,r6[0x8]
8000a864:	97 29       	st.w	r11[0x8],r9
8000a866:	93 3b       	st.w	r9[0xc],r11
8000a868:	10 99       	mov	r9,r8
8000a86a:	95 26       	st.w	r10[0x8],r6
8000a86c:	a1 a9       	sbr	r9,0x0
8000a86e:	8d 19       	st.w	r6[0x4],r9
8000a870:	e0 69 09 40 	mov	r9,2368
8000a874:	72 09       	ld.w	r9,r9[0x0]
8000a876:	12 38       	cp.w	r8,r9
8000a878:	c0 63       	brcs	8000a884 <_free_r+0x60>
8000a87a:	e0 68 0d 54 	mov	r8,3412
8000a87e:	0e 9c       	mov	r12,r7
8000a880:	70 0b       	ld.w	r11,r8[0x0]
8000a882:	c8 5f       	rcall	8000a78c <_malloc_trim_r>
8000a884:	0e 9c       	mov	r12,r7
8000a886:	fe b0 d7 79 	rcall	80005778 <__malloc_unlock>
8000a88a:	d8 22       	popm	r4-r7,pc
8000a88c:	93 1b       	st.w	r9[0x4],r11
8000a88e:	58 0c       	cp.w	r12,0
8000a890:	c0 30       	breq	8000a896 <_free_r+0x72>
8000a892:	30 0c       	mov	r12,0
8000a894:	c1 08       	rjmp	8000a8b4 <_free_r+0x90>
8000a896:	6c 0e       	ld.w	lr,r6[0x0]
8000a898:	f4 c5 ff f8 	sub	r5,r10,-8
8000a89c:	1c 16       	sub	r6,lr
8000a89e:	1c 08       	add	r8,lr
8000a8a0:	6c 2e       	ld.w	lr,r6[0x8]
8000a8a2:	0a 3e       	cp.w	lr,r5
8000a8a4:	f9 bc 00 01 	moveq	r12,1
8000a8a8:	ed f5 10 03 	ld.wne	r5,r6[0xc]
8000a8ac:	eb fe 1a 02 	st.wne	r5[0x8],lr
8000a8b0:	fd f5 1a 03 	st.wne	lr[0xc],r5
8000a8b4:	f2 0b 00 0e 	add	lr,r9,r11
8000a8b8:	7c 1e       	ld.w	lr,lr[0x4]
8000a8ba:	ed be 00 00 	bld	lr,0x0
8000a8be:	c1 40       	breq	8000a8e6 <_free_r+0xc2>
8000a8c0:	16 08       	add	r8,r11
8000a8c2:	58 0c       	cp.w	r12,0
8000a8c4:	c0 d1       	brne	8000a8de <_free_r+0xba>
8000a8c6:	e0 6e 05 38 	mov	lr,1336
8000a8ca:	72 2b       	ld.w	r11,r9[0x8]
8000a8cc:	2f 8e       	sub	lr,-8
8000a8ce:	1c 3b       	cp.w	r11,lr
8000a8d0:	c0 71       	brne	8000a8de <_free_r+0xba>
8000a8d2:	97 36       	st.w	r11[0xc],r6
8000a8d4:	97 26       	st.w	r11[0x8],r6
8000a8d6:	8d 2b       	st.w	r6[0x8],r11
8000a8d8:	8d 3b       	st.w	r6[0xc],r11
8000a8da:	30 1c       	mov	r12,1
8000a8dc:	c0 58       	rjmp	8000a8e6 <_free_r+0xc2>
8000a8de:	72 2b       	ld.w	r11,r9[0x8]
8000a8e0:	72 39       	ld.w	r9,r9[0xc]
8000a8e2:	93 2b       	st.w	r9[0x8],r11
8000a8e4:	97 39       	st.w	r11[0xc],r9
8000a8e6:	10 99       	mov	r9,r8
8000a8e8:	ec 08 09 08 	st.w	r6[r8],r8
8000a8ec:	a1 a9       	sbr	r9,0x0
8000a8ee:	8d 19       	st.w	r6[0x4],r9
8000a8f0:	58 0c       	cp.w	r12,0
8000a8f2:	c5 a1       	brne	8000a9a6 <_free_r+0x182>
8000a8f4:	e0 48 01 ff 	cp.w	r8,511
8000a8f8:	e0 8b 00 13 	brhi	8000a91e <_free_r+0xfa>
8000a8fc:	a3 98       	lsr	r8,0x3
8000a8fe:	f4 08 00 39 	add	r9,r10,r8<<0x3
8000a902:	72 2b       	ld.w	r11,r9[0x8]
8000a904:	8d 39       	st.w	r6[0xc],r9
8000a906:	8d 2b       	st.w	r6[0x8],r11
8000a908:	97 36       	st.w	r11[0xc],r6
8000a90a:	93 26       	st.w	r9[0x8],r6
8000a90c:	a3 48       	asr	r8,0x2
8000a90e:	74 19       	ld.w	r9,r10[0x4]
8000a910:	30 1b       	mov	r11,1
8000a912:	f6 08 09 48 	lsl	r8,r11,r8
8000a916:	f3 e8 10 08 	or	r8,r9,r8
8000a91a:	95 18       	st.w	r10[0x4],r8
8000a91c:	c4 58       	rjmp	8000a9a6 <_free_r+0x182>
8000a91e:	f0 0b 16 09 	lsr	r11,r8,0x9
8000a922:	58 4b       	cp.w	r11,4
8000a924:	e0 8b 00 06 	brhi	8000a930 <_free_r+0x10c>
8000a928:	f0 0b 16 06 	lsr	r11,r8,0x6
8000a92c:	2c 8b       	sub	r11,-56
8000a92e:	c2 08       	rjmp	8000a96e <_free_r+0x14a>
8000a930:	59 4b       	cp.w	r11,20
8000a932:	e0 8b 00 04 	brhi	8000a93a <_free_r+0x116>
8000a936:	2a 5b       	sub	r11,-91
8000a938:	c1 b8       	rjmp	8000a96e <_free_r+0x14a>
8000a93a:	e0 4b 00 54 	cp.w	r11,84
8000a93e:	e0 8b 00 06 	brhi	8000a94a <_free_r+0x126>
8000a942:	f0 0b 16 0c 	lsr	r11,r8,0xc
8000a946:	29 2b       	sub	r11,-110
8000a948:	c1 38       	rjmp	8000a96e <_free_r+0x14a>
8000a94a:	e0 4b 01 54 	cp.w	r11,340
8000a94e:	e0 8b 00 06 	brhi	8000a95a <_free_r+0x136>
8000a952:	f0 0b 16 0f 	lsr	r11,r8,0xf
8000a956:	28 9b       	sub	r11,-119
8000a958:	c0 b8       	rjmp	8000a96e <_free_r+0x14a>
8000a95a:	e0 4b 05 54 	cp.w	r11,1364
8000a95e:	e0 88 00 05 	brls	8000a968 <_free_r+0x144>
8000a962:	37 eb       	mov	r11,126
8000a964:	c0 58       	rjmp	8000a96e <_free_r+0x14a>
8000a966:	d7 03       	nop
8000a968:	f0 0b 16 12 	lsr	r11,r8,0x12
8000a96c:	28 4b       	sub	r11,-124
8000a96e:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
8000a972:	78 29       	ld.w	r9,r12[0x8]
8000a974:	18 39       	cp.w	r9,r12
8000a976:	c0 e1       	brne	8000a992 <_free_r+0x16e>
8000a978:	74 18       	ld.w	r8,r10[0x4]
8000a97a:	a3 4b       	asr	r11,0x2
8000a97c:	30 1c       	mov	r12,1
8000a97e:	f8 0b 09 4b 	lsl	r11,r12,r11
8000a982:	f1 eb 10 0b 	or	r11,r8,r11
8000a986:	12 98       	mov	r8,r9
8000a988:	95 1b       	st.w	r10[0x4],r11
8000a98a:	c0 a8       	rjmp	8000a99e <_free_r+0x17a>
8000a98c:	72 29       	ld.w	r9,r9[0x8]
8000a98e:	18 39       	cp.w	r9,r12
8000a990:	c0 60       	breq	8000a99c <_free_r+0x178>
8000a992:	72 1a       	ld.w	r10,r9[0x4]
8000a994:	e0 1a ff fc 	andl	r10,0xfffc
8000a998:	14 38       	cp.w	r8,r10
8000a99a:	cf 93       	brcs	8000a98c <_free_r+0x168>
8000a99c:	72 38       	ld.w	r8,r9[0xc]
8000a99e:	8d 38       	st.w	r6[0xc],r8
8000a9a0:	8d 29       	st.w	r6[0x8],r9
8000a9a2:	93 36       	st.w	r9[0xc],r6
8000a9a4:	91 26       	st.w	r8[0x8],r6
8000a9a6:	0e 9c       	mov	r12,r7
8000a9a8:	fe b0 d6 e8 	rcall	80005778 <__malloc_unlock>
8000a9ac:	d8 22       	popm	r4-r7,pc
8000a9ae:	d7 03       	nop

8000a9b0 <__sfvwrite_r>:
8000a9b0:	d4 31       	pushm	r0-r7,lr
8000a9b2:	20 3d       	sub	sp,12
8000a9b4:	14 94       	mov	r4,r10
8000a9b6:	18 95       	mov	r5,r12
8000a9b8:	16 97       	mov	r7,r11
8000a9ba:	74 28       	ld.w	r8,r10[0x8]
8000a9bc:	58 08       	cp.w	r8,0
8000a9be:	e0 80 01 40 	breq	8000ac3e <__sfvwrite_r+0x28e>
8000a9c2:	96 68       	ld.sh	r8,r11[0xc]
8000a9c4:	ed b8 00 03 	bld	r8,0x3
8000a9c8:	c0 41       	brne	8000a9d0 <__sfvwrite_r+0x20>
8000a9ca:	76 48       	ld.w	r8,r11[0x10]
8000a9cc:	58 08       	cp.w	r8,0
8000a9ce:	c0 c1       	brne	8000a9e6 <__sfvwrite_r+0x36>
8000a9d0:	0e 9b       	mov	r11,r7
8000a9d2:	0a 9c       	mov	r12,r5
8000a9d4:	fe b0 f6 c4 	rcall	8000975c <__swsetup_r>
8000a9d8:	c0 70       	breq	8000a9e6 <__sfvwrite_r+0x36>
8000a9da:	8e 68       	ld.sh	r8,r7[0xc]
8000a9dc:	a7 a8       	sbr	r8,0x6
8000a9de:	ae 68       	st.h	r7[0xc],r8
8000a9e0:	30 98       	mov	r8,9
8000a9e2:	8b 38       	st.w	r5[0xc],r8
8000a9e4:	c2 b9       	rjmp	8000ac3a <__sfvwrite_r+0x28a>
8000a9e6:	8e 63       	ld.sh	r3,r7[0xc]
8000a9e8:	68 00       	ld.w	r0,r4[0x0]
8000a9ea:	06 96       	mov	r6,r3
8000a9ec:	e2 16 00 02 	andl	r6,0x2,COH
8000a9f0:	c2 10       	breq	8000aa32 <__sfvwrite_r+0x82>
8000a9f2:	30 03       	mov	r3,0
8000a9f4:	e0 62 04 00 	mov	r2,1024
8000a9f8:	06 96       	mov	r6,r3
8000a9fa:	c0 48       	rjmp	8000aa02 <__sfvwrite_r+0x52>
8000a9fc:	60 03       	ld.w	r3,r0[0x0]
8000a9fe:	60 16       	ld.w	r6,r0[0x4]
8000aa00:	2f 80       	sub	r0,-8
8000aa02:	58 06       	cp.w	r6,0
8000aa04:	cf c0       	breq	8000a9fc <__sfvwrite_r+0x4c>
8000aa06:	e0 46 04 00 	cp.w	r6,1024
8000aa0a:	ec 09 17 80 	movls	r9,r6
8000aa0e:	e4 09 17 b0 	movhi	r9,r2
8000aa12:	06 9a       	mov	r10,r3
8000aa14:	6e a8       	ld.w	r8,r7[0x28]
8000aa16:	6e 8b       	ld.w	r11,r7[0x20]
8000aa18:	0a 9c       	mov	r12,r5
8000aa1a:	5d 18       	icall	r8
8000aa1c:	18 16       	sub	r6,r12
8000aa1e:	58 0c       	cp.w	r12,0
8000aa20:	e0 8a 01 0a 	brle	8000ac34 <__sfvwrite_r+0x284>
8000aa24:	68 28       	ld.w	r8,r4[0x8]
8000aa26:	18 18       	sub	r8,r12
8000aa28:	89 28       	st.w	r4[0x8],r8
8000aa2a:	e0 80 01 0a 	breq	8000ac3e <__sfvwrite_r+0x28e>
8000aa2e:	18 03       	add	r3,r12
8000aa30:	ce 9b       	rjmp	8000aa02 <__sfvwrite_r+0x52>
8000aa32:	e7 d3 c0 01 	bfextu	r3,r3,0x0,0x1
8000aa36:	c0 70       	breq	8000aa44 <__sfvwrite_r+0x94>
8000aa38:	50 06       	stdsp	sp[0x0],r6
8000aa3a:	0c 93       	mov	r3,r6
8000aa3c:	0c 91       	mov	r1,r6
8000aa3e:	50 15       	stdsp	sp[0x4],r5
8000aa40:	08 92       	mov	r2,r4
8000aa42:	c9 c8       	rjmp	8000ab7a <__sfvwrite_r+0x1ca>
8000aa44:	06 96       	mov	r6,r3
8000aa46:	08 91       	mov	r1,r4
8000aa48:	c0 48       	rjmp	8000aa50 <__sfvwrite_r+0xa0>
8000aa4a:	60 03       	ld.w	r3,r0[0x0]
8000aa4c:	60 16       	ld.w	r6,r0[0x4]
8000aa4e:	2f 80       	sub	r0,-8
8000aa50:	58 06       	cp.w	r6,0
8000aa52:	cf c0       	breq	8000aa4a <__sfvwrite_r+0x9a>
8000aa54:	8e 68       	ld.sh	r8,r7[0xc]
8000aa56:	6e 24       	ld.w	r4,r7[0x8]
8000aa58:	10 99       	mov	r9,r8
8000aa5a:	e2 19 02 00 	andl	r9,0x200,COH
8000aa5e:	c5 50       	breq	8000ab08 <__sfvwrite_r+0x158>
8000aa60:	08 36       	cp.w	r6,r4
8000aa62:	c4 43       	brcs	8000aaea <__sfvwrite_r+0x13a>
8000aa64:	10 99       	mov	r9,r8
8000aa66:	e2 19 04 80 	andl	r9,0x480,COH
8000aa6a:	c4 00       	breq	8000aaea <__sfvwrite_r+0x13a>
8000aa6c:	6e 4b       	ld.w	r11,r7[0x10]
8000aa6e:	6e 09       	ld.w	r9,r7[0x0]
8000aa70:	16 19       	sub	r9,r11
8000aa72:	50 09       	stdsp	sp[0x0],r9
8000aa74:	6e 59       	ld.w	r9,r7[0x14]
8000aa76:	10 9c       	mov	r12,r8
8000aa78:	f2 09 00 1a 	add	r10,r9,r9<<0x1
8000aa7c:	30 28       	mov	r8,2
8000aa7e:	f4 08 0c 08 	divs	r8,r10,r8
8000aa82:	fa e9 00 04 	st.d	sp[4],r8
8000aa86:	10 94       	mov	r4,r8
8000aa88:	40 09       	lddsp	r9,sp[0x0]
8000aa8a:	e2 1c 04 00 	andl	r12,0x400,COH
8000aa8e:	2f f9       	sub	r9,-1
8000aa90:	0c 09       	add	r9,r6
8000aa92:	12 38       	cp.w	r8,r9
8000aa94:	f2 04 17 30 	movlo	r4,r9
8000aa98:	58 0c       	cp.w	r12,0
8000aa9a:	c1 10       	breq	8000aabc <__sfvwrite_r+0x10c>
8000aa9c:	08 9b       	mov	r11,r4
8000aa9e:	0a 9c       	mov	r12,r5
8000aaa0:	fe b0 e0 5a 	rcall	80006b54 <_malloc_r>
8000aaa4:	18 92       	mov	r2,r12
8000aaa6:	c1 40       	breq	8000aace <__sfvwrite_r+0x11e>
8000aaa8:	40 0a       	lddsp	r10,sp[0x0]
8000aaaa:	6e 4b       	ld.w	r11,r7[0x10]
8000aaac:	fe b0 e2 83 	rcall	80006fb2 <memcpy>
8000aab0:	8e 68       	ld.sh	r8,r7[0xc]
8000aab2:	e0 18 fb 7f 	andl	r8,0xfb7f
8000aab6:	a7 b8       	sbr	r8,0x7
8000aab8:	ae 68       	st.h	r7[0xc],r8
8000aaba:	c0 d8       	rjmp	8000aad4 <__sfvwrite_r+0x124>
8000aabc:	08 9a       	mov	r10,r4
8000aabe:	0a 9c       	mov	r12,r5
8000aac0:	fe b0 e3 24 	rcall	80007108 <_realloc_r>
8000aac4:	18 92       	mov	r2,r12
8000aac6:	c0 71       	brne	8000aad4 <__sfvwrite_r+0x124>
8000aac8:	6e 4b       	ld.w	r11,r7[0x10]
8000aaca:	0a 9c       	mov	r12,r5
8000aacc:	ca ce       	rcall	8000a824 <_free_r>
8000aace:	30 c8       	mov	r8,12
8000aad0:	8b 38       	st.w	r5[0xc],r8
8000aad2:	cb 18       	rjmp	8000ac34 <__sfvwrite_r+0x284>
8000aad4:	40 0a       	lddsp	r10,sp[0x0]
8000aad6:	40 09       	lddsp	r9,sp[0x0]
8000aad8:	e8 0a 01 0a 	sub	r10,r4,r10
8000aadc:	e4 09 00 08 	add	r8,r2,r9
8000aae0:	8f 54       	st.w	r7[0x14],r4
8000aae2:	8f 2a       	st.w	r7[0x8],r10
8000aae4:	8f 08       	st.w	r7[0x0],r8
8000aae6:	8f 42       	st.w	r7[0x10],r2
8000aae8:	0c 94       	mov	r4,r6
8000aaea:	08 36       	cp.w	r6,r4
8000aaec:	ec 04 17 30 	movlo	r4,r6
8000aaf0:	06 9b       	mov	r11,r3
8000aaf2:	08 9a       	mov	r10,r4
8000aaf4:	6e 0c       	ld.w	r12,r7[0x0]
8000aaf6:	c3 ad       	rcall	8000ad6a <memmove>
8000aaf8:	6e 08       	ld.w	r8,r7[0x0]
8000aafa:	08 08       	add	r8,r4
8000aafc:	8f 08       	st.w	r7[0x0],r8
8000aafe:	6e 28       	ld.w	r8,r7[0x8]
8000ab00:	08 18       	sub	r8,r4
8000ab02:	0c 94       	mov	r4,r6
8000ab04:	8f 28       	st.w	r7[0x8],r8
8000ab06:	c2 e8       	rjmp	8000ab62 <__sfvwrite_r+0x1b2>
8000ab08:	08 36       	cp.w	r6,r4
8000ab0a:	5f ba       	srhi	r10
8000ab0c:	6e 0c       	ld.w	r12,r7[0x0]
8000ab0e:	6e 48       	ld.w	r8,r7[0x10]
8000ab10:	10 3c       	cp.w	r12,r8
8000ab12:	5f b8       	srhi	r8
8000ab14:	f5 e8 00 08 	and	r8,r10,r8
8000ab18:	f2 08 18 00 	cp.b	r8,r9
8000ab1c:	c0 d0       	breq	8000ab36 <__sfvwrite_r+0x186>
8000ab1e:	06 9b       	mov	r11,r3
8000ab20:	08 9a       	mov	r10,r4
8000ab22:	c2 4d       	rcall	8000ad6a <memmove>
8000ab24:	6e 08       	ld.w	r8,r7[0x0]
8000ab26:	08 08       	add	r8,r4
8000ab28:	0e 9b       	mov	r11,r7
8000ab2a:	8f 08       	st.w	r7[0x0],r8
8000ab2c:	0a 9c       	mov	r12,r5
8000ab2e:	fe b0 fd 09 	rcall	8000a540 <_fflush_r>
8000ab32:	c1 80       	breq	8000ab62 <__sfvwrite_r+0x1b2>
8000ab34:	c8 08       	rjmp	8000ac34 <__sfvwrite_r+0x284>
8000ab36:	6e 59       	ld.w	r9,r7[0x14]
8000ab38:	12 36       	cp.w	r6,r9
8000ab3a:	c0 a3       	brcs	8000ab4e <__sfvwrite_r+0x19e>
8000ab3c:	6e a8       	ld.w	r8,r7[0x28]
8000ab3e:	06 9a       	mov	r10,r3
8000ab40:	6e 8b       	ld.w	r11,r7[0x20]
8000ab42:	0a 9c       	mov	r12,r5
8000ab44:	5d 18       	icall	r8
8000ab46:	18 94       	mov	r4,r12
8000ab48:	e0 89 00 0d 	brgt	8000ab62 <__sfvwrite_r+0x1b2>
8000ab4c:	c7 48       	rjmp	8000ac34 <__sfvwrite_r+0x284>
8000ab4e:	0c 9a       	mov	r10,r6
8000ab50:	06 9b       	mov	r11,r3
8000ab52:	c0 cd       	rcall	8000ad6a <memmove>
8000ab54:	6e 08       	ld.w	r8,r7[0x0]
8000ab56:	0c 08       	add	r8,r6
8000ab58:	0c 94       	mov	r4,r6
8000ab5a:	8f 08       	st.w	r7[0x0],r8
8000ab5c:	6e 28       	ld.w	r8,r7[0x8]
8000ab5e:	0c 18       	sub	r8,r6
8000ab60:	8f 28       	st.w	r7[0x8],r8
8000ab62:	62 28       	ld.w	r8,r1[0x8]
8000ab64:	08 18       	sub	r8,r4
8000ab66:	83 28       	st.w	r1[0x8],r8
8000ab68:	c6 b0       	breq	8000ac3e <__sfvwrite_r+0x28e>
8000ab6a:	08 16       	sub	r6,r4
8000ab6c:	08 03       	add	r3,r4
8000ab6e:	c7 1b       	rjmp	8000aa50 <__sfvwrite_r+0xa0>
8000ab70:	60 03       	ld.w	r3,r0[0x0]
8000ab72:	60 11       	ld.w	r1,r0[0x4]
8000ab74:	30 08       	mov	r8,0
8000ab76:	2f 80       	sub	r0,-8
8000ab78:	50 08       	stdsp	sp[0x0],r8
8000ab7a:	58 01       	cp.w	r1,0
8000ab7c:	cf a0       	breq	8000ab70 <__sfvwrite_r+0x1c0>
8000ab7e:	40 0a       	lddsp	r10,sp[0x0]
8000ab80:	58 0a       	cp.w	r10,0
8000ab82:	c1 41       	brne	8000abaa <__sfvwrite_r+0x1fa>
8000ab84:	e2 c6 ff ff 	sub	r6,r1,-1
8000ab88:	02 9a       	mov	r10,r1
8000ab8a:	30 ab       	mov	r11,10
8000ab8c:	06 9c       	mov	r12,r3
8000ab8e:	ce 3c       	rcall	8000ad54 <memchr>
8000ab90:	f8 c8 ff ff 	sub	r8,r12,-1
8000ab94:	58 0c       	cp.w	r12,0
8000ab96:	f1 d3 e1 16 	subne	r6,r8,r3
8000ab9a:	f9 b9 01 01 	movne	r9,1
8000ab9e:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000aba2:	f9 b8 00 01 	moveq	r8,1
8000aba6:	fb f8 0a 00 	st.weq	sp[0x0],r8
8000abaa:	02 36       	cp.w	r6,r1
8000abac:	ec 04 17 80 	movls	r4,r6
8000abb0:	e2 04 17 b0 	movhi	r4,r1
8000abb4:	6e 59       	ld.w	r9,r7[0x14]
8000abb6:	6e 25       	ld.w	r5,r7[0x8]
8000abb8:	f2 05 00 05 	add	r5,r9,r5
8000abbc:	0a 34       	cp.w	r4,r5
8000abbe:	5f 9a       	srgt	r10
8000abc0:	6e 0c       	ld.w	r12,r7[0x0]
8000abc2:	6e 48       	ld.w	r8,r7[0x10]
8000abc4:	10 3c       	cp.w	r12,r8
8000abc6:	5f b8       	srhi	r8
8000abc8:	f5 e8 00 08 	and	r8,r10,r8
8000abcc:	30 0a       	mov	r10,0
8000abce:	f4 08 18 00 	cp.b	r8,r10
8000abd2:	c0 d0       	breq	8000abec <__sfvwrite_r+0x23c>
8000abd4:	06 9b       	mov	r11,r3
8000abd6:	0a 9a       	mov	r10,r5
8000abd8:	cc 9c       	rcall	8000ad6a <memmove>
8000abda:	6e 08       	ld.w	r8,r7[0x0]
8000abdc:	0a 08       	add	r8,r5
8000abde:	0e 9b       	mov	r11,r7
8000abe0:	8f 08       	st.w	r7[0x0],r8
8000abe2:	40 1c       	lddsp	r12,sp[0x4]
8000abe4:	fe b0 fc ae 	rcall	8000a540 <_fflush_r>
8000abe8:	c1 70       	breq	8000ac16 <__sfvwrite_r+0x266>
8000abea:	c2 58       	rjmp	8000ac34 <__sfvwrite_r+0x284>
8000abec:	12 34       	cp.w	r4,r9
8000abee:	c0 a5       	brlt	8000ac02 <__sfvwrite_r+0x252>
8000abf0:	6e a8       	ld.w	r8,r7[0x28]
8000abf2:	06 9a       	mov	r10,r3
8000abf4:	6e 8b       	ld.w	r11,r7[0x20]
8000abf6:	40 1c       	lddsp	r12,sp[0x4]
8000abf8:	5d 18       	icall	r8
8000abfa:	18 95       	mov	r5,r12
8000abfc:	e0 89 00 0d 	brgt	8000ac16 <__sfvwrite_r+0x266>
8000ac00:	c1 a8       	rjmp	8000ac34 <__sfvwrite_r+0x284>
8000ac02:	08 9a       	mov	r10,r4
8000ac04:	06 9b       	mov	r11,r3
8000ac06:	cb 2c       	rcall	8000ad6a <memmove>
8000ac08:	6e 08       	ld.w	r8,r7[0x0]
8000ac0a:	08 08       	add	r8,r4
8000ac0c:	08 95       	mov	r5,r4
8000ac0e:	8f 08       	st.w	r7[0x0],r8
8000ac10:	6e 28       	ld.w	r8,r7[0x8]
8000ac12:	08 18       	sub	r8,r4
8000ac14:	8f 28       	st.w	r7[0x8],r8
8000ac16:	0a 16       	sub	r6,r5
8000ac18:	c0 71       	brne	8000ac26 <__sfvwrite_r+0x276>
8000ac1a:	0e 9b       	mov	r11,r7
8000ac1c:	40 1c       	lddsp	r12,sp[0x4]
8000ac1e:	fe b0 fc 91 	rcall	8000a540 <_fflush_r>
8000ac22:	c0 91       	brne	8000ac34 <__sfvwrite_r+0x284>
8000ac24:	50 06       	stdsp	sp[0x0],r6
8000ac26:	64 28       	ld.w	r8,r2[0x8]
8000ac28:	0a 18       	sub	r8,r5
8000ac2a:	85 28       	st.w	r2[0x8],r8
8000ac2c:	c0 90       	breq	8000ac3e <__sfvwrite_r+0x28e>
8000ac2e:	0a 11       	sub	r1,r5
8000ac30:	0a 03       	add	r3,r5
8000ac32:	ca 4b       	rjmp	8000ab7a <__sfvwrite_r+0x1ca>
8000ac34:	8e 68       	ld.sh	r8,r7[0xc]
8000ac36:	a7 a8       	sbr	r8,0x6
8000ac38:	ae 68       	st.h	r7[0xc],r8
8000ac3a:	3f fc       	mov	r12,-1
8000ac3c:	c0 28       	rjmp	8000ac40 <__sfvwrite_r+0x290>
8000ac3e:	30 0c       	mov	r12,0
8000ac40:	2f dd       	sub	sp,-12
8000ac42:	d8 32       	popm	r0-r7,pc

8000ac44 <_fwalk>:
8000ac44:	d4 31       	pushm	r0-r7,lr
8000ac46:	30 05       	mov	r5,0
8000ac48:	16 91       	mov	r1,r11
8000ac4a:	f8 c7 ff 28 	sub	r7,r12,-216
8000ac4e:	0a 92       	mov	r2,r5
8000ac50:	fe b0 fc fe 	rcall	8000a64c <__sfp_lock_acquire>
8000ac54:	3f f3       	mov	r3,-1
8000ac56:	c1 68       	rjmp	8000ac82 <_fwalk+0x3e>
8000ac58:	6e 26       	ld.w	r6,r7[0x8]
8000ac5a:	6e 14       	ld.w	r4,r7[0x4]
8000ac5c:	2f 46       	sub	r6,-12
8000ac5e:	c0 c8       	rjmp	8000ac76 <_fwalk+0x32>
8000ac60:	8c 08       	ld.sh	r8,r6[0x0]
8000ac62:	e4 08 19 00 	cp.h	r8,r2
8000ac66:	c0 70       	breq	8000ac74 <_fwalk+0x30>
8000ac68:	8c 18       	ld.sh	r8,r6[0x2]
8000ac6a:	e6 08 19 00 	cp.h	r8,r3
8000ac6e:	c0 30       	breq	8000ac74 <_fwalk+0x30>
8000ac70:	5d 11       	icall	r1
8000ac72:	18 45       	or	r5,r12
8000ac74:	2a 46       	sub	r6,-92
8000ac76:	20 14       	sub	r4,1
8000ac78:	ec cc 00 0c 	sub	r12,r6,12
8000ac7c:	58 04       	cp.w	r4,0
8000ac7e:	cf 14       	brge	8000ac60 <_fwalk+0x1c>
8000ac80:	6e 07       	ld.w	r7,r7[0x0]
8000ac82:	58 07       	cp.w	r7,0
8000ac84:	ce a1       	brne	8000ac58 <_fwalk+0x14>
8000ac86:	fe b0 fc e4 	rcall	8000a64e <__sfp_lock_release>
8000ac8a:	0a 9c       	mov	r12,r5
8000ac8c:	d8 32       	popm	r0-r7,pc
8000ac8e:	d7 03       	nop

8000ac90 <_localeconv_r>:
8000ac90:	fe cc d4 5c 	sub	r12,pc,-11172
8000ac94:	5e fc       	retal	r12
8000ac96:	d7 03       	nop

8000ac98 <__smakebuf_r>:
8000ac98:	d4 21       	pushm	r4-r7,lr
8000ac9a:	20 fd       	sub	sp,60
8000ac9c:	96 68       	ld.sh	r8,r11[0xc]
8000ac9e:	16 97       	mov	r7,r11
8000aca0:	18 96       	mov	r6,r12
8000aca2:	e2 18 00 02 	andl	r8,0x2,COH
8000aca6:	c3 d1       	brne	8000ad20 <__smakebuf_r+0x88>
8000aca8:	96 7b       	ld.sh	r11,r11[0xe]
8000acaa:	f0 0b 19 00 	cp.h	r11,r8
8000acae:	c0 55       	brlt	8000acb8 <__smakebuf_r+0x20>
8000acb0:	1a 9a       	mov	r10,sp
8000acb2:	e0 a0 04 81 	rcall	8000b5b4 <_fstat_r>
8000acb6:	c0 f4       	brge	8000acd4 <__smakebuf_r+0x3c>
8000acb8:	8e 65       	ld.sh	r5,r7[0xc]
8000acba:	0a 98       	mov	r8,r5
8000acbc:	ab b8       	sbr	r8,0xb
8000acbe:	e2 15 00 80 	andl	r5,0x80,COH
8000acc2:	ae 68       	st.h	r7[0xc],r8
8000acc4:	30 04       	mov	r4,0
8000acc6:	e0 68 04 00 	mov	r8,1024
8000acca:	f9 b5 01 40 	movne	r5,64
8000acce:	f0 05 17 00 	moveq	r5,r8
8000acd2:	c1 c8       	rjmp	8000ad0a <__smakebuf_r+0x72>
8000acd4:	40 18       	lddsp	r8,sp[0x4]
8000acd6:	e2 18 f0 00 	andl	r8,0xf000,COH
8000acda:	e0 48 20 00 	cp.w	r8,8192
8000acde:	5f 04       	sreq	r4
8000ace0:	e0 48 80 00 	cp.w	r8,32768
8000ace4:	c0 e1       	brne	8000ad00 <__smakebuf_r+0x68>
8000ace6:	6e b9       	ld.w	r9,r7[0x2c]
8000ace8:	fe c8 f9 1c 	sub	r8,pc,-1764
8000acec:	10 39       	cp.w	r9,r8
8000acee:	c0 91       	brne	8000ad00 <__smakebuf_r+0x68>
8000acf0:	8e 68       	ld.sh	r8,r7[0xc]
8000acf2:	e0 65 04 00 	mov	r5,1024
8000acf6:	ab a8       	sbr	r8,0xa
8000acf8:	ef 45 00 50 	st.w	r7[80],r5
8000acfc:	ae 68       	st.h	r7[0xc],r8
8000acfe:	c0 68       	rjmp	8000ad0a <__smakebuf_r+0x72>
8000ad00:	8e 68       	ld.sh	r8,r7[0xc]
8000ad02:	e0 65 04 00 	mov	r5,1024
8000ad06:	ab b8       	sbr	r8,0xb
8000ad08:	ae 68       	st.h	r7[0xc],r8
8000ad0a:	0a 9b       	mov	r11,r5
8000ad0c:	0c 9c       	mov	r12,r6
8000ad0e:	fe b0 df 23 	rcall	80006b54 <_malloc_r>
8000ad12:	8e 68       	ld.sh	r8,r7[0xc]
8000ad14:	c0 d1       	brne	8000ad2e <__smakebuf_r+0x96>
8000ad16:	ed b8 00 09 	bld	r8,0x9
8000ad1a:	c1 b0       	breq	8000ad50 <__smakebuf_r+0xb8>
8000ad1c:	a1 b8       	sbr	r8,0x1
8000ad1e:	ae 68       	st.h	r7[0xc],r8
8000ad20:	ee c8 ff b9 	sub	r8,r7,-71
8000ad24:	8f 48       	st.w	r7[0x10],r8
8000ad26:	8f 08       	st.w	r7[0x0],r8
8000ad28:	30 18       	mov	r8,1
8000ad2a:	8f 58       	st.w	r7[0x14],r8
8000ad2c:	c1 28       	rjmp	8000ad50 <__smakebuf_r+0xb8>
8000ad2e:	a7 b8       	sbr	r8,0x7
8000ad30:	8f 4c       	st.w	r7[0x10],r12
8000ad32:	ae 68       	st.h	r7[0xc],r8
8000ad34:	8f 55       	st.w	r7[0x14],r5
8000ad36:	fe c8 06 e6 	sub	r8,pc,1766
8000ad3a:	8f 0c       	st.w	r7[0x0],r12
8000ad3c:	8d a8       	st.w	r6[0x28],r8
8000ad3e:	58 04       	cp.w	r4,0
8000ad40:	c0 80       	breq	8000ad50 <__smakebuf_r+0xb8>
8000ad42:	8e 7c       	ld.sh	r12,r7[0xe]
8000ad44:	fe b0 e3 94 	rcall	8000746c <isatty>
8000ad48:	c0 40       	breq	8000ad50 <__smakebuf_r+0xb8>
8000ad4a:	8e 68       	ld.sh	r8,r7[0xc]
8000ad4c:	a1 a8       	sbr	r8,0x0
8000ad4e:	ae 68       	st.h	r7[0xc],r8
8000ad50:	2f 1d       	sub	sp,-60
8000ad52:	d8 22       	popm	r4-r7,pc

8000ad54 <memchr>:
8000ad54:	f7 db c0 08 	bfextu	r11,r11,0x0,0x8
8000ad58:	c0 68       	rjmp	8000ad64 <memchr+0x10>
8000ad5a:	20 1a       	sub	r10,1
8000ad5c:	19 88       	ld.ub	r8,r12[0x0]
8000ad5e:	16 38       	cp.w	r8,r11
8000ad60:	5e 0c       	reteq	r12
8000ad62:	2f fc       	sub	r12,-1
8000ad64:	58 0a       	cp.w	r10,0
8000ad66:	cf a1       	brne	8000ad5a <memchr+0x6>
8000ad68:	5e fa       	retal	r10

8000ad6a <memmove>:
8000ad6a:	d4 01       	pushm	lr
8000ad6c:	18 3b       	cp.w	r11,r12
8000ad6e:	c1 92       	brcc	8000ada0 <memmove+0x36>
8000ad70:	f6 0a 00 09 	add	r9,r11,r10
8000ad74:	12 3c       	cp.w	r12,r9
8000ad76:	c1 52       	brcc	8000ada0 <memmove+0x36>
8000ad78:	f8 0a 00 0b 	add	r11,r12,r10
8000ad7c:	30 08       	mov	r8,0
8000ad7e:	c0 68       	rjmp	8000ad8a <memmove+0x20>
8000ad80:	f2 08 07 0e 	ld.ub	lr,r9[r8]
8000ad84:	20 1a       	sub	r10,1
8000ad86:	f6 08 0b 0e 	st.b	r11[r8],lr
8000ad8a:	20 18       	sub	r8,1
8000ad8c:	58 0a       	cp.w	r10,0
8000ad8e:	cf 91       	brne	8000ad80 <memmove+0x16>
8000ad90:	d8 02       	popm	pc
8000ad92:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000ad96:	20 1a       	sub	r10,1
8000ad98:	f8 08 0b 09 	st.b	r12[r8],r9
8000ad9c:	2f f8       	sub	r8,-1
8000ad9e:	c0 28       	rjmp	8000ada2 <memmove+0x38>
8000ada0:	30 08       	mov	r8,0
8000ada2:	58 0a       	cp.w	r10,0
8000ada4:	cf 71       	brne	8000ad92 <memmove+0x28>
8000ada6:	d8 02       	popm	pc

8000ada8 <__hi0bits>:
8000ada8:	18 98       	mov	r8,r12
8000adaa:	e0 1c 00 00 	andl	r12,0x0
8000adae:	f0 09 15 10 	lsl	r9,r8,0x10
8000adb2:	58 0c       	cp.w	r12,0
8000adb4:	f2 08 17 00 	moveq	r8,r9
8000adb8:	f9 bc 00 10 	moveq	r12,16
8000adbc:	f9 bc 01 00 	movne	r12,0
8000adc0:	10 9a       	mov	r10,r8
8000adc2:	f0 09 15 08 	lsl	r9,r8,0x8
8000adc6:	e6 1a ff 00 	andh	r10,0xff00,COH
8000adca:	f7 bc 00 f8 	subeq	r12,-8
8000adce:	f2 08 17 00 	moveq	r8,r9
8000add2:	10 9a       	mov	r10,r8
8000add4:	f0 09 15 04 	lsl	r9,r8,0x4
8000add8:	e6 1a f0 00 	andh	r10,0xf000,COH
8000addc:	f7 bc 00 fc 	subeq	r12,-4
8000ade0:	f2 08 17 00 	moveq	r8,r9
8000ade4:	10 9a       	mov	r10,r8
8000ade6:	f0 09 15 02 	lsl	r9,r8,0x2
8000adea:	e6 1a c0 00 	andh	r10,0xc000,COH
8000adee:	f7 bc 00 fe 	subeq	r12,-2
8000adf2:	f2 08 17 00 	moveq	r8,r9
8000adf6:	58 08       	cp.w	r8,0
8000adf8:	5e 5c       	retlt	r12
8000adfa:	ed b8 00 1e 	bld	r8,0x1e
8000adfe:	f9 bc 01 20 	movne	r12,32
8000ae02:	f7 bc 00 ff 	subeq	r12,-1
8000ae06:	5e fc       	retal	r12

8000ae08 <__lo0bits>:
8000ae08:	18 99       	mov	r9,r12
8000ae0a:	78 08       	ld.w	r8,r12[0x0]
8000ae0c:	f9 d8 c0 03 	bfextu	r12,r8,0x0,0x3
8000ae10:	c1 50       	breq	8000ae3a <__lo0bits+0x32>
8000ae12:	ed b8 00 00 	bld	r8,0x0
8000ae16:	c0 21       	brne	8000ae1a <__lo0bits+0x12>
8000ae18:	5e fd       	retal	0
8000ae1a:	10 9b       	mov	r11,r8
8000ae1c:	f0 0a 16 01 	lsr	r10,r8,0x1
8000ae20:	e2 1b 00 02 	andl	r11,0x2,COH
8000ae24:	a3 88       	lsr	r8,0x2
8000ae26:	58 0b       	cp.w	r11,0
8000ae28:	f3 fa 1a 00 	st.wne	r9[0x0],r10
8000ae2c:	f9 bc 01 01 	movne	r12,1
8000ae30:	f3 f8 0a 00 	st.weq	r9[0x0],r8
8000ae34:	f9 bc 00 02 	moveq	r12,2
8000ae38:	5e fc       	retal	r12
8000ae3a:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
8000ae3e:	f0 0b 16 10 	lsr	r11,r8,0x10
8000ae42:	58 0a       	cp.w	r10,0
8000ae44:	f6 08 17 00 	moveq	r8,r11
8000ae48:	f9 bc 00 10 	moveq	r12,16
8000ae4c:	f7 d8 c0 08 	bfextu	r11,r8,0x0,0x8
8000ae50:	f0 0a 16 08 	lsr	r10,r8,0x8
8000ae54:	58 0b       	cp.w	r11,0
8000ae56:	f7 bc 00 f8 	subeq	r12,-8
8000ae5a:	f4 08 17 00 	moveq	r8,r10
8000ae5e:	f7 d8 c0 04 	bfextu	r11,r8,0x0,0x4
8000ae62:	f0 0a 16 04 	lsr	r10,r8,0x4
8000ae66:	58 0b       	cp.w	r11,0
8000ae68:	f7 bc 00 fc 	subeq	r12,-4
8000ae6c:	f4 08 17 00 	moveq	r8,r10
8000ae70:	f7 d8 c0 02 	bfextu	r11,r8,0x0,0x2
8000ae74:	f0 0a 16 02 	lsr	r10,r8,0x2
8000ae78:	58 0b       	cp.w	r11,0
8000ae7a:	f7 bc 00 fe 	subeq	r12,-2
8000ae7e:	f4 08 17 00 	moveq	r8,r10
8000ae82:	ed b8 00 00 	bld	r8,0x0
8000ae86:	c0 60       	breq	8000ae92 <__lo0bits+0x8a>
8000ae88:	a1 98       	lsr	r8,0x1
8000ae8a:	c0 31       	brne	8000ae90 <__lo0bits+0x88>
8000ae8c:	32 0c       	mov	r12,32
8000ae8e:	5e fc       	retal	r12
8000ae90:	2f fc       	sub	r12,-1
8000ae92:	93 08       	st.w	r9[0x0],r8
8000ae94:	5e fc       	retal	r12

8000ae96 <__mcmp>:
8000ae96:	d4 01       	pushm	lr
8000ae98:	18 98       	mov	r8,r12
8000ae9a:	76 49       	ld.w	r9,r11[0x10]
8000ae9c:	78 4c       	ld.w	r12,r12[0x10]
8000ae9e:	12 1c       	sub	r12,r9
8000aea0:	c1 31       	brne	8000aec6 <__mcmp+0x30>
8000aea2:	2f b9       	sub	r9,-5
8000aea4:	a3 69       	lsl	r9,0x2
8000aea6:	12 0b       	add	r11,r9
8000aea8:	f0 09 00 09 	add	r9,r8,r9
8000aeac:	2e c8       	sub	r8,-20
8000aeae:	13 4e       	ld.w	lr,--r9
8000aeb0:	17 4a       	ld.w	r10,--r11
8000aeb2:	14 3e       	cp.w	lr,r10
8000aeb4:	c0 60       	breq	8000aec0 <__mcmp+0x2a>
8000aeb6:	f9 bc 03 ff 	movlo	r12,-1
8000aeba:	f9 bc 02 01 	movhs	r12,1
8000aebe:	d8 02       	popm	pc
8000aec0:	10 39       	cp.w	r9,r8
8000aec2:	fe 9b ff f6 	brhi	8000aeae <__mcmp+0x18>
8000aec6:	d8 02       	popm	pc

8000aec8 <_Bfree>:
8000aec8:	d4 21       	pushm	r4-r7,lr
8000aeca:	18 97       	mov	r7,r12
8000aecc:	16 95       	mov	r5,r11
8000aece:	78 96       	ld.w	r6,r12[0x24]
8000aed0:	58 06       	cp.w	r6,0
8000aed2:	c0 91       	brne	8000aee4 <_Bfree+0x1c>
8000aed4:	31 0c       	mov	r12,16
8000aed6:	fe b0 de 37 	rcall	80006b44 <malloc>
8000aeda:	99 36       	st.w	r12[0xc],r6
8000aedc:	8f 9c       	st.w	r7[0x24],r12
8000aede:	99 16       	st.w	r12[0x4],r6
8000aee0:	99 26       	st.w	r12[0x8],r6
8000aee2:	99 06       	st.w	r12[0x0],r6
8000aee4:	58 05       	cp.w	r5,0
8000aee6:	c0 90       	breq	8000aef8 <_Bfree+0x30>
8000aee8:	6a 19       	ld.w	r9,r5[0x4]
8000aeea:	6e 98       	ld.w	r8,r7[0x24]
8000aeec:	70 38       	ld.w	r8,r8[0xc]
8000aeee:	f0 09 03 2a 	ld.w	r10,r8[r9<<0x2]
8000aef2:	8b 0a       	st.w	r5[0x0],r10
8000aef4:	f0 09 09 25 	st.w	r8[r9<<0x2],r5
8000aef8:	d8 22       	popm	r4-r7,pc
8000aefa:	d7 03       	nop

8000aefc <_Balloc>:
8000aefc:	d4 21       	pushm	r4-r7,lr
8000aefe:	18 97       	mov	r7,r12
8000af00:	16 96       	mov	r6,r11
8000af02:	78 95       	ld.w	r5,r12[0x24]
8000af04:	58 05       	cp.w	r5,0
8000af06:	c0 91       	brne	8000af18 <_Balloc+0x1c>
8000af08:	31 0c       	mov	r12,16
8000af0a:	fe b0 de 1d 	rcall	80006b44 <malloc>
8000af0e:	99 35       	st.w	r12[0xc],r5
8000af10:	8f 9c       	st.w	r7[0x24],r12
8000af12:	99 15       	st.w	r12[0x4],r5
8000af14:	99 25       	st.w	r12[0x8],r5
8000af16:	99 05       	st.w	r12[0x0],r5
8000af18:	6e 95       	ld.w	r5,r7[0x24]
8000af1a:	6a 38       	ld.w	r8,r5[0xc]
8000af1c:	58 08       	cp.w	r8,0
8000af1e:	c0 b1       	brne	8000af34 <_Balloc+0x38>
8000af20:	31 0a       	mov	r10,16
8000af22:	30 4b       	mov	r11,4
8000af24:	0e 9c       	mov	r12,r7
8000af26:	e0 a0 02 a7 	rcall	8000b474 <_calloc_r>
8000af2a:	8b 3c       	st.w	r5[0xc],r12
8000af2c:	6e 98       	ld.w	r8,r7[0x24]
8000af2e:	70 3c       	ld.w	r12,r8[0xc]
8000af30:	58 0c       	cp.w	r12,0
8000af32:	c1 b0       	breq	8000af68 <_Balloc+0x6c>
8000af34:	6e 98       	ld.w	r8,r7[0x24]
8000af36:	70 38       	ld.w	r8,r8[0xc]
8000af38:	f0 06 00 28 	add	r8,r8,r6<<0x2
8000af3c:	70 0c       	ld.w	r12,r8[0x0]
8000af3e:	58 0c       	cp.w	r12,0
8000af40:	c0 40       	breq	8000af48 <_Balloc+0x4c>
8000af42:	78 09       	ld.w	r9,r12[0x0]
8000af44:	91 09       	st.w	r8[0x0],r9
8000af46:	c0 e8       	rjmp	8000af62 <_Balloc+0x66>
8000af48:	0e 9c       	mov	r12,r7
8000af4a:	30 17       	mov	r7,1
8000af4c:	0e 9b       	mov	r11,r7
8000af4e:	ee 06 09 47 	lsl	r7,r7,r6
8000af52:	ee ca ff fb 	sub	r10,r7,-5
8000af56:	a3 6a       	lsl	r10,0x2
8000af58:	e0 a0 02 8e 	rcall	8000b474 <_calloc_r>
8000af5c:	c0 60       	breq	8000af68 <_Balloc+0x6c>
8000af5e:	99 16       	st.w	r12[0x4],r6
8000af60:	99 27       	st.w	r12[0x8],r7
8000af62:	30 08       	mov	r8,0
8000af64:	99 38       	st.w	r12[0xc],r8
8000af66:	99 48       	st.w	r12[0x10],r8
8000af68:	d8 22       	popm	r4-r7,pc
8000af6a:	d7 03       	nop

8000af6c <__d2b>:
8000af6c:	d4 31       	pushm	r0-r7,lr
8000af6e:	20 2d       	sub	sp,8
8000af70:	16 93       	mov	r3,r11
8000af72:	12 96       	mov	r6,r9
8000af74:	10 95       	mov	r5,r8
8000af76:	14 92       	mov	r2,r10
8000af78:	30 1b       	mov	r11,1
8000af7a:	cc 1f       	rcall	8000aefc <_Balloc>
8000af7c:	f3 d3 c0 14 	bfextu	r9,r3,0x0,0x14
8000af80:	50 09       	stdsp	sp[0x0],r9
8000af82:	f1 d3 c0 1f 	bfextu	r8,r3,0x0,0x1f
8000af86:	b5 a9       	sbr	r9,0x14
8000af88:	f0 01 16 14 	lsr	r1,r8,0x14
8000af8c:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000af90:	18 94       	mov	r4,r12
8000af92:	58 02       	cp.w	r2,0
8000af94:	c1 d0       	breq	8000afce <__d2b+0x62>
8000af96:	fa cc ff f8 	sub	r12,sp,-8
8000af9a:	18 d2       	st.w	--r12,r2
8000af9c:	c3 6f       	rcall	8000ae08 <__lo0bits>
8000af9e:	40 18       	lddsp	r8,sp[0x4]
8000afa0:	c0 d0       	breq	8000afba <__d2b+0x4e>
8000afa2:	40 09       	lddsp	r9,sp[0x0]
8000afa4:	f8 0a 11 20 	rsub	r10,r12,32
8000afa8:	f2 0a 09 4a 	lsl	r10,r9,r10
8000afac:	f5 e8 10 08 	or	r8,r10,r8
8000afb0:	89 58       	st.w	r4[0x14],r8
8000afb2:	f2 0c 0a 49 	lsr	r9,r9,r12
8000afb6:	50 09       	stdsp	sp[0x0],r9
8000afb8:	c0 28       	rjmp	8000afbc <__d2b+0x50>
8000afba:	89 58       	st.w	r4[0x14],r8
8000afbc:	40 08       	lddsp	r8,sp[0x0]
8000afbe:	58 08       	cp.w	r8,0
8000afc0:	f9 b3 01 02 	movne	r3,2
8000afc4:	f9 b3 00 01 	moveq	r3,1
8000afc8:	89 68       	st.w	r4[0x18],r8
8000afca:	89 43       	st.w	r4[0x10],r3
8000afcc:	c0 88       	rjmp	8000afdc <__d2b+0x70>
8000afce:	1a 9c       	mov	r12,sp
8000afd0:	c1 cf       	rcall	8000ae08 <__lo0bits>
8000afd2:	30 13       	mov	r3,1
8000afd4:	40 08       	lddsp	r8,sp[0x0]
8000afd6:	2e 0c       	sub	r12,-32
8000afd8:	89 43       	st.w	r4[0x10],r3
8000afda:	89 58       	st.w	r4[0x14],r8
8000afdc:	58 01       	cp.w	r1,0
8000afde:	c0 90       	breq	8000aff0 <__d2b+0x84>
8000afe0:	e2 c1 04 33 	sub	r1,r1,1075
8000afe4:	18 01       	add	r1,r12
8000afe6:	8d 01       	st.w	r6[0x0],r1
8000afe8:	f8 0c 11 35 	rsub	r12,r12,53
8000afec:	8b 0c       	st.w	r5[0x0],r12
8000afee:	c0 c8       	rjmp	8000b006 <__d2b+0x9a>
8000aff0:	e6 c8 ff fc 	sub	r8,r3,-4
8000aff4:	f8 cc 04 32 	sub	r12,r12,1074
8000aff8:	a5 73       	lsl	r3,0x5
8000affa:	8d 0c       	st.w	r6[0x0],r12
8000affc:	e8 08 03 2c 	ld.w	r12,r4[r8<<0x2]
8000b000:	cd 4e       	rcall	8000ada8 <__hi0bits>
8000b002:	18 13       	sub	r3,r12
8000b004:	8b 03       	st.w	r5[0x0],r3
8000b006:	08 9c       	mov	r12,r4
8000b008:	2f ed       	sub	sp,-8
8000b00a:	d8 32       	popm	r0-r7,pc

8000b00c <__mdiff>:
8000b00c:	d4 31       	pushm	r0-r7,lr
8000b00e:	74 48       	ld.w	r8,r10[0x10]
8000b010:	76 45       	ld.w	r5,r11[0x10]
8000b012:	16 97       	mov	r7,r11
8000b014:	14 96       	mov	r6,r10
8000b016:	10 15       	sub	r5,r8
8000b018:	c1 31       	brne	8000b03e <__mdiff+0x32>
8000b01a:	2f b8       	sub	r8,-5
8000b01c:	ee ce ff ec 	sub	lr,r7,-20
8000b020:	a3 68       	lsl	r8,0x2
8000b022:	f4 08 00 0b 	add	r11,r10,r8
8000b026:	ee 08 00 08 	add	r8,r7,r8
8000b02a:	11 4a       	ld.w	r10,--r8
8000b02c:	17 49       	ld.w	r9,--r11
8000b02e:	12 3a       	cp.w	r10,r9
8000b030:	c0 30       	breq	8000b036 <__mdiff+0x2a>
8000b032:	c0 e2       	brcc	8000b04e <__mdiff+0x42>
8000b034:	c0 78       	rjmp	8000b042 <__mdiff+0x36>
8000b036:	1c 38       	cp.w	r8,lr
8000b038:	fe 9b ff f9 	brhi	8000b02a <__mdiff+0x1e>
8000b03c:	c4 98       	rjmp	8000b0ce <__mdiff+0xc2>
8000b03e:	58 05       	cp.w	r5,0
8000b040:	c0 64       	brge	8000b04c <__mdiff+0x40>
8000b042:	0e 98       	mov	r8,r7
8000b044:	30 15       	mov	r5,1
8000b046:	0c 97       	mov	r7,r6
8000b048:	10 96       	mov	r6,r8
8000b04a:	c0 28       	rjmp	8000b04e <__mdiff+0x42>
8000b04c:	30 05       	mov	r5,0
8000b04e:	6e 1b       	ld.w	r11,r7[0x4]
8000b050:	c5 6f       	rcall	8000aefc <_Balloc>
8000b052:	6e 49       	ld.w	r9,r7[0x10]
8000b054:	6c 44       	ld.w	r4,r6[0x10]
8000b056:	99 35       	st.w	r12[0xc],r5
8000b058:	2f b4       	sub	r4,-5
8000b05a:	f2 c5 ff fb 	sub	r5,r9,-5
8000b05e:	ec 04 00 24 	add	r4,r6,r4<<0x2
8000b062:	ee 05 00 25 	add	r5,r7,r5<<0x2
8000b066:	2e c6       	sub	r6,-20
8000b068:	2e c7       	sub	r7,-20
8000b06a:	f8 c8 ff ec 	sub	r8,r12,-20
8000b06e:	30 0a       	mov	r10,0
8000b070:	0f 0e       	ld.w	lr,r7++
8000b072:	0d 0b       	ld.w	r11,r6++
8000b074:	fc 02 16 10 	lsr	r2,lr,0x10
8000b078:	f6 03 16 10 	lsr	r3,r11,0x10
8000b07c:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000b080:	e4 03 01 03 	sub	r3,r2,r3
8000b084:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000b088:	fc 0b 01 0b 	sub	r11,lr,r11
8000b08c:	f6 0a 00 0a 	add	r10,r11,r10
8000b090:	b0 1a       	st.h	r8[0x2],r10
8000b092:	b1 4a       	asr	r10,0x10
8000b094:	e6 0a 00 0a 	add	r10,r3,r10
8000b098:	b0 0a       	st.h	r8[0x0],r10
8000b09a:	2f c8       	sub	r8,-4
8000b09c:	b1 4a       	asr	r10,0x10
8000b09e:	08 36       	cp.w	r6,r4
8000b0a0:	ce 83       	brcs	8000b070 <__mdiff+0x64>
8000b0a2:	c0 d8       	rjmp	8000b0bc <__mdiff+0xb0>
8000b0a4:	0f 0b       	ld.w	r11,r7++
8000b0a6:	f6 0e 16 10 	lsr	lr,r11,0x10
8000b0aa:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000b0ae:	16 0a       	add	r10,r11
8000b0b0:	b0 1a       	st.h	r8[0x2],r10
8000b0b2:	b1 4a       	asr	r10,0x10
8000b0b4:	1c 0a       	add	r10,lr
8000b0b6:	b0 0a       	st.h	r8[0x0],r10
8000b0b8:	2f c8       	sub	r8,-4
8000b0ba:	b1 4a       	asr	r10,0x10
8000b0bc:	0a 37       	cp.w	r7,r5
8000b0be:	cf 33       	brcs	8000b0a4 <__mdiff+0x98>
8000b0c0:	c0 28       	rjmp	8000b0c4 <__mdiff+0xb8>
8000b0c2:	20 19       	sub	r9,1
8000b0c4:	11 4a       	ld.w	r10,--r8
8000b0c6:	58 0a       	cp.w	r10,0
8000b0c8:	cf d0       	breq	8000b0c2 <__mdiff+0xb6>
8000b0ca:	99 49       	st.w	r12[0x10],r9
8000b0cc:	d8 32       	popm	r0-r7,pc
8000b0ce:	30 0b       	mov	r11,0
8000b0d0:	c1 6f       	rcall	8000aefc <_Balloc>
8000b0d2:	30 18       	mov	r8,1
8000b0d4:	99 48       	st.w	r12[0x10],r8
8000b0d6:	30 08       	mov	r8,0
8000b0d8:	99 58       	st.w	r12[0x14],r8
8000b0da:	d8 32       	popm	r0-r7,pc

8000b0dc <__lshift>:
8000b0dc:	d4 31       	pushm	r0-r7,lr
8000b0de:	16 97       	mov	r7,r11
8000b0e0:	76 46       	ld.w	r6,r11[0x10]
8000b0e2:	f4 02 14 05 	asr	r2,r10,0x5
8000b0e6:	2f f6       	sub	r6,-1
8000b0e8:	14 93       	mov	r3,r10
8000b0ea:	18 94       	mov	r4,r12
8000b0ec:	04 06       	add	r6,r2
8000b0ee:	76 1b       	ld.w	r11,r11[0x4]
8000b0f0:	6e 28       	ld.w	r8,r7[0x8]
8000b0f2:	c0 38       	rjmp	8000b0f8 <__lshift+0x1c>
8000b0f4:	2f fb       	sub	r11,-1
8000b0f6:	a1 78       	lsl	r8,0x1
8000b0f8:	10 36       	cp.w	r6,r8
8000b0fa:	fe 99 ff fd 	brgt	8000b0f4 <__lshift+0x18>
8000b0fe:	08 9c       	mov	r12,r4
8000b100:	cf ee       	rcall	8000aefc <_Balloc>
8000b102:	30 09       	mov	r9,0
8000b104:	18 95       	mov	r5,r12
8000b106:	f8 c8 ff ec 	sub	r8,r12,-20
8000b10a:	12 9a       	mov	r10,r9
8000b10c:	c0 38       	rjmp	8000b112 <__lshift+0x36>
8000b10e:	10 aa       	st.w	r8++,r10
8000b110:	2f f9       	sub	r9,-1
8000b112:	04 39       	cp.w	r9,r2
8000b114:	cf d5       	brlt	8000b10e <__lshift+0x32>
8000b116:	6e 4b       	ld.w	r11,r7[0x10]
8000b118:	e7 d3 c0 05 	bfextu	r3,r3,0x0,0x5
8000b11c:	2f bb       	sub	r11,-5
8000b11e:	ee c9 ff ec 	sub	r9,r7,-20
8000b122:	ee 0b 00 2b 	add	r11,r7,r11<<0x2
8000b126:	58 03       	cp.w	r3,0
8000b128:	c1 30       	breq	8000b14e <__lshift+0x72>
8000b12a:	e6 0c 11 20 	rsub	r12,r3,32
8000b12e:	30 0a       	mov	r10,0
8000b130:	72 02       	ld.w	r2,r9[0x0]
8000b132:	e4 03 09 42 	lsl	r2,r2,r3
8000b136:	04 4a       	or	r10,r2
8000b138:	10 aa       	st.w	r8++,r10
8000b13a:	13 0a       	ld.w	r10,r9++
8000b13c:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000b140:	16 39       	cp.w	r9,r11
8000b142:	cf 73       	brcs	8000b130 <__lshift+0x54>
8000b144:	91 0a       	st.w	r8[0x0],r10
8000b146:	58 0a       	cp.w	r10,0
8000b148:	c0 70       	breq	8000b156 <__lshift+0x7a>
8000b14a:	2f f6       	sub	r6,-1
8000b14c:	c0 58       	rjmp	8000b156 <__lshift+0x7a>
8000b14e:	13 0a       	ld.w	r10,r9++
8000b150:	10 aa       	st.w	r8++,r10
8000b152:	16 39       	cp.w	r9,r11
8000b154:	cf d3       	brcs	8000b14e <__lshift+0x72>
8000b156:	08 9c       	mov	r12,r4
8000b158:	20 16       	sub	r6,1
8000b15a:	0e 9b       	mov	r11,r7
8000b15c:	8b 46       	st.w	r5[0x10],r6
8000b15e:	cb 5e       	rcall	8000aec8 <_Bfree>
8000b160:	0a 9c       	mov	r12,r5
8000b162:	d8 32       	popm	r0-r7,pc

8000b164 <__multiply>:
8000b164:	d4 31       	pushm	r0-r7,lr
8000b166:	20 2d       	sub	sp,8
8000b168:	76 49       	ld.w	r9,r11[0x10]
8000b16a:	74 48       	ld.w	r8,r10[0x10]
8000b16c:	16 96       	mov	r6,r11
8000b16e:	14 95       	mov	r5,r10
8000b170:	10 39       	cp.w	r9,r8
8000b172:	ec 08 17 50 	movlt	r8,r6
8000b176:	ea 06 17 50 	movlt	r6,r5
8000b17a:	f0 05 17 50 	movlt	r5,r8
8000b17e:	6c 28       	ld.w	r8,r6[0x8]
8000b180:	76 43       	ld.w	r3,r11[0x10]
8000b182:	74 42       	ld.w	r2,r10[0x10]
8000b184:	76 1b       	ld.w	r11,r11[0x4]
8000b186:	e4 03 00 07 	add	r7,r2,r3
8000b18a:	10 37       	cp.w	r7,r8
8000b18c:	f7 bb 09 ff 	subgt	r11,-1
8000b190:	cb 6e       	rcall	8000aefc <_Balloc>
8000b192:	ee c4 ff fb 	sub	r4,r7,-5
8000b196:	f8 c9 ff ec 	sub	r9,r12,-20
8000b19a:	f8 04 00 24 	add	r4,r12,r4<<0x2
8000b19e:	30 0a       	mov	r10,0
8000b1a0:	12 98       	mov	r8,r9
8000b1a2:	c0 28       	rjmp	8000b1a6 <__multiply+0x42>
8000b1a4:	10 aa       	st.w	r8++,r10
8000b1a6:	08 38       	cp.w	r8,r4
8000b1a8:	cf e3       	brcs	8000b1a4 <__multiply+0x40>
8000b1aa:	2f b3       	sub	r3,-5
8000b1ac:	2f b2       	sub	r2,-5
8000b1ae:	ec 03 00 23 	add	r3,r6,r3<<0x2
8000b1b2:	ea 02 00 22 	add	r2,r5,r2<<0x2
8000b1b6:	ec cb ff ec 	sub	r11,r6,-20
8000b1ba:	50 12       	stdsp	sp[0x4],r2
8000b1bc:	ea ca ff ec 	sub	r10,r5,-20
8000b1c0:	c4 48       	rjmp	8000b248 <__multiply+0xe4>
8000b1c2:	94 95       	ld.uh	r5,r10[0x2]
8000b1c4:	58 05       	cp.w	r5,0
8000b1c6:	c2 00       	breq	8000b206 <__multiply+0xa2>
8000b1c8:	12 98       	mov	r8,r9
8000b1ca:	16 96       	mov	r6,r11
8000b1cc:	30 0e       	mov	lr,0
8000b1ce:	50 09       	stdsp	sp[0x0],r9
8000b1d0:	0d 02       	ld.w	r2,r6++
8000b1d2:	e4 00 16 10 	lsr	r0,r2,0x10
8000b1d6:	70 01       	ld.w	r1,r8[0x0]
8000b1d8:	70 09       	ld.w	r9,r8[0x0]
8000b1da:	b1 81       	lsr	r1,0x10
8000b1dc:	e5 d2 c0 10 	bfextu	r2,r2,0x0,0x10
8000b1e0:	e0 05 03 41 	mac	r1,r0,r5
8000b1e4:	ab 32       	mul	r2,r5
8000b1e6:	e1 d9 c0 10 	bfextu	r0,r9,0x0,0x10
8000b1ea:	00 02       	add	r2,r0
8000b1ec:	e4 0e 00 0e 	add	lr,r2,lr
8000b1f0:	b0 1e       	st.h	r8[0x2],lr
8000b1f2:	b1 8e       	lsr	lr,0x10
8000b1f4:	1c 01       	add	r1,lr
8000b1f6:	b0 01       	st.h	r8[0x0],r1
8000b1f8:	e2 0e 16 10 	lsr	lr,r1,0x10
8000b1fc:	2f c8       	sub	r8,-4
8000b1fe:	06 36       	cp.w	r6,r3
8000b200:	ce 83       	brcs	8000b1d0 <__multiply+0x6c>
8000b202:	40 09       	lddsp	r9,sp[0x0]
8000b204:	91 0e       	st.w	r8[0x0],lr
8000b206:	94 86       	ld.uh	r6,r10[0x0]
8000b208:	58 06       	cp.w	r6,0
8000b20a:	c1 d0       	breq	8000b244 <__multiply+0xe0>
8000b20c:	72 02       	ld.w	r2,r9[0x0]
8000b20e:	12 98       	mov	r8,r9
8000b210:	16 9e       	mov	lr,r11
8000b212:	30 05       	mov	r5,0
8000b214:	b0 12       	st.h	r8[0x2],r2
8000b216:	1d 01       	ld.w	r1,lr++
8000b218:	90 82       	ld.uh	r2,r8[0x0]
8000b21a:	e1 d1 c0 10 	bfextu	r0,r1,0x0,0x10
8000b21e:	ad 30       	mul	r0,r6
8000b220:	e0 02 00 02 	add	r2,r0,r2
8000b224:	e4 05 00 05 	add	r5,r2,r5
8000b228:	b0 05       	st.h	r8[0x0],r5
8000b22a:	b1 85       	lsr	r5,0x10
8000b22c:	b1 81       	lsr	r1,0x10
8000b22e:	2f c8       	sub	r8,-4
8000b230:	ad 31       	mul	r1,r6
8000b232:	90 92       	ld.uh	r2,r8[0x2]
8000b234:	e2 02 00 02 	add	r2,r1,r2
8000b238:	0a 02       	add	r2,r5
8000b23a:	e4 05 16 10 	lsr	r5,r2,0x10
8000b23e:	06 3e       	cp.w	lr,r3
8000b240:	ce a3       	brcs	8000b214 <__multiply+0xb0>
8000b242:	91 02       	st.w	r8[0x0],r2
8000b244:	2f ca       	sub	r10,-4
8000b246:	2f c9       	sub	r9,-4
8000b248:	40 18       	lddsp	r8,sp[0x4]
8000b24a:	10 3a       	cp.w	r10,r8
8000b24c:	cb b3       	brcs	8000b1c2 <__multiply+0x5e>
8000b24e:	c0 28       	rjmp	8000b252 <__multiply+0xee>
8000b250:	20 17       	sub	r7,1
8000b252:	58 07       	cp.w	r7,0
8000b254:	e0 8a 00 05 	brle	8000b25e <__multiply+0xfa>
8000b258:	09 48       	ld.w	r8,--r4
8000b25a:	58 08       	cp.w	r8,0
8000b25c:	cf a0       	breq	8000b250 <__multiply+0xec>
8000b25e:	99 47       	st.w	r12[0x10],r7
8000b260:	2f ed       	sub	sp,-8
8000b262:	d8 32       	popm	r0-r7,pc

8000b264 <__i2b>:
8000b264:	d4 21       	pushm	r4-r7,lr
8000b266:	16 97       	mov	r7,r11
8000b268:	30 1b       	mov	r11,1
8000b26a:	c4 9e       	rcall	8000aefc <_Balloc>
8000b26c:	30 19       	mov	r9,1
8000b26e:	99 57       	st.w	r12[0x14],r7
8000b270:	99 49       	st.w	r12[0x10],r9
8000b272:	d8 22       	popm	r4-r7,pc

8000b274 <__multadd>:
8000b274:	d4 31       	pushm	r0-r7,lr
8000b276:	30 08       	mov	r8,0
8000b278:	12 95       	mov	r5,r9
8000b27a:	16 97       	mov	r7,r11
8000b27c:	18 96       	mov	r6,r12
8000b27e:	76 44       	ld.w	r4,r11[0x10]
8000b280:	f6 c9 ff ec 	sub	r9,r11,-20
8000b284:	72 0b       	ld.w	r11,r9[0x0]
8000b286:	f6 0c 16 10 	lsr	r12,r11,0x10
8000b28a:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000b28e:	f4 0c 02 4c 	mul	r12,r10,r12
8000b292:	f4 0b 03 45 	mac	r5,r10,r11
8000b296:	f7 d5 c0 10 	bfextu	r11,r5,0x0,0x10
8000b29a:	b1 85       	lsr	r5,0x10
8000b29c:	18 05       	add	r5,r12
8000b29e:	ea 0c 15 10 	lsl	r12,r5,0x10
8000b2a2:	f8 0b 00 0b 	add	r11,r12,r11
8000b2a6:	12 ab       	st.w	r9++,r11
8000b2a8:	2f f8       	sub	r8,-1
8000b2aa:	b1 85       	lsr	r5,0x10
8000b2ac:	08 38       	cp.w	r8,r4
8000b2ae:	ce b5       	brlt	8000b284 <__multadd+0x10>
8000b2b0:	58 05       	cp.w	r5,0
8000b2b2:	c1 c0       	breq	8000b2ea <__multadd+0x76>
8000b2b4:	6e 28       	ld.w	r8,r7[0x8]
8000b2b6:	10 34       	cp.w	r4,r8
8000b2b8:	c1 35       	brlt	8000b2de <__multadd+0x6a>
8000b2ba:	6e 1b       	ld.w	r11,r7[0x4]
8000b2bc:	0c 9c       	mov	r12,r6
8000b2be:	2f fb       	sub	r11,-1
8000b2c0:	c1 ee       	rcall	8000aefc <_Balloc>
8000b2c2:	6e 4a       	ld.w	r10,r7[0x10]
8000b2c4:	ee cb ff f4 	sub	r11,r7,-12
8000b2c8:	18 93       	mov	r3,r12
8000b2ca:	2f ea       	sub	r10,-2
8000b2cc:	2f 4c       	sub	r12,-12
8000b2ce:	a3 6a       	lsl	r10,0x2
8000b2d0:	fe b0 de 71 	rcall	80006fb2 <memcpy>
8000b2d4:	0e 9b       	mov	r11,r7
8000b2d6:	0c 9c       	mov	r12,r6
8000b2d8:	fe b0 fd f8 	rcall	8000aec8 <_Bfree>
8000b2dc:	06 97       	mov	r7,r3
8000b2de:	e8 c8 ff ff 	sub	r8,r4,-1
8000b2e2:	2f b4       	sub	r4,-5
8000b2e4:	8f 48       	st.w	r7[0x10],r8
8000b2e6:	ee 04 09 25 	st.w	r7[r4<<0x2],r5
8000b2ea:	0e 9c       	mov	r12,r7
8000b2ec:	d8 32       	popm	r0-r7,pc
8000b2ee:	d7 03       	nop

8000b2f0 <__pow5mult>:
8000b2f0:	d4 31       	pushm	r0-r7,lr
8000b2f2:	14 96       	mov	r6,r10
8000b2f4:	18 97       	mov	r7,r12
8000b2f6:	16 94       	mov	r4,r11
8000b2f8:	f1 da c0 02 	bfextu	r8,r10,0x0,0x2
8000b2fc:	c0 90       	breq	8000b30e <__pow5mult+0x1e>
8000b2fe:	20 18       	sub	r8,1
8000b300:	fe c9 da 90 	sub	r9,pc,-9584
8000b304:	f2 08 03 2a 	ld.w	r10,r9[r8<<0x2]
8000b308:	30 09       	mov	r9,0
8000b30a:	cb 5f       	rcall	8000b274 <__multadd>
8000b30c:	18 94       	mov	r4,r12
8000b30e:	a3 46       	asr	r6,0x2
8000b310:	c3 40       	breq	8000b378 <__pow5mult+0x88>
8000b312:	6e 95       	ld.w	r5,r7[0x24]
8000b314:	58 05       	cp.w	r5,0
8000b316:	c0 91       	brne	8000b328 <__pow5mult+0x38>
8000b318:	31 0c       	mov	r12,16
8000b31a:	fe b0 dc 15 	rcall	80006b44 <malloc>
8000b31e:	99 35       	st.w	r12[0xc],r5
8000b320:	8f 9c       	st.w	r7[0x24],r12
8000b322:	99 15       	st.w	r12[0x4],r5
8000b324:	99 25       	st.w	r12[0x8],r5
8000b326:	99 05       	st.w	r12[0x0],r5
8000b328:	6e 93       	ld.w	r3,r7[0x24]
8000b32a:	66 25       	ld.w	r5,r3[0x8]
8000b32c:	58 05       	cp.w	r5,0
8000b32e:	c0 c1       	brne	8000b346 <__pow5mult+0x56>
8000b330:	e0 6b 02 71 	mov	r11,625
8000b334:	0e 9c       	mov	r12,r7
8000b336:	c9 7f       	rcall	8000b264 <__i2b>
8000b338:	87 2c       	st.w	r3[0x8],r12
8000b33a:	30 08       	mov	r8,0
8000b33c:	18 95       	mov	r5,r12
8000b33e:	99 08       	st.w	r12[0x0],r8
8000b340:	c0 38       	rjmp	8000b346 <__pow5mult+0x56>
8000b342:	06 9c       	mov	r12,r3
8000b344:	18 95       	mov	r5,r12
8000b346:	ed b6 00 00 	bld	r6,0x0
8000b34a:	c0 b1       	brne	8000b360 <__pow5mult+0x70>
8000b34c:	08 9b       	mov	r11,r4
8000b34e:	0a 9a       	mov	r10,r5
8000b350:	0e 9c       	mov	r12,r7
8000b352:	c0 9f       	rcall	8000b164 <__multiply>
8000b354:	08 9b       	mov	r11,r4
8000b356:	18 93       	mov	r3,r12
8000b358:	0e 9c       	mov	r12,r7
8000b35a:	06 94       	mov	r4,r3
8000b35c:	fe b0 fd b6 	rcall	8000aec8 <_Bfree>
8000b360:	a1 56       	asr	r6,0x1
8000b362:	c0 b0       	breq	8000b378 <__pow5mult+0x88>
8000b364:	6a 03       	ld.w	r3,r5[0x0]
8000b366:	58 03       	cp.w	r3,0
8000b368:	ce d1       	brne	8000b342 <__pow5mult+0x52>
8000b36a:	0a 9a       	mov	r10,r5
8000b36c:	0a 9b       	mov	r11,r5
8000b36e:	0e 9c       	mov	r12,r7
8000b370:	cf ae       	rcall	8000b164 <__multiply>
8000b372:	8b 0c       	st.w	r5[0x0],r12
8000b374:	99 03       	st.w	r12[0x0],r3
8000b376:	ce 7b       	rjmp	8000b344 <__pow5mult+0x54>
8000b378:	08 9c       	mov	r12,r4
8000b37a:	d8 32       	popm	r0-r7,pc

8000b37c <__isinfd>:
8000b37c:	14 98       	mov	r8,r10
8000b37e:	fc 19 7f f0 	movh	r9,0x7ff0
8000b382:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000b386:	f0 0b 11 00 	rsub	r11,r8,0
8000b38a:	f7 e8 10 08 	or	r8,r11,r8
8000b38e:	f5 e8 13 f8 	or	r8,r10,r8>>0x1f
8000b392:	f2 08 01 08 	sub	r8,r9,r8
8000b396:	f0 0c 11 00 	rsub	r12,r8,0
8000b39a:	f9 e8 10 08 	or	r8,r12,r8
8000b39e:	f0 0c 14 1f 	asr	r12,r8,0x1f
8000b3a2:	2f fc       	sub	r12,-1
8000b3a4:	5e fc       	retal	r12

8000b3a6 <__isnand>:
8000b3a6:	14 98       	mov	r8,r10
8000b3a8:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000b3ac:	f0 0c 11 00 	rsub	r12,r8,0
8000b3b0:	10 4c       	or	r12,r8
8000b3b2:	fc 18 7f f0 	movh	r8,0x7ff0
8000b3b6:	f5 ec 13 fc 	or	r12,r10,r12>>0x1f
8000b3ba:	f0 0c 01 0c 	sub	r12,r8,r12
8000b3be:	bf 9c       	lsr	r12,0x1f
8000b3c0:	5e fc       	retal	r12
8000b3c2:	d7 03       	nop

8000b3c4 <__sclose>:
8000b3c4:	d4 01       	pushm	lr
8000b3c6:	96 7b       	ld.sh	r11,r11[0xe]
8000b3c8:	c8 2c       	rcall	8000b4cc <_close_r>
8000b3ca:	d8 02       	popm	pc

8000b3cc <__sseek>:
8000b3cc:	d4 21       	pushm	r4-r7,lr
8000b3ce:	16 97       	mov	r7,r11
8000b3d0:	96 7b       	ld.sh	r11,r11[0xe]
8000b3d2:	c0 3d       	rcall	8000b5d8 <_lseek_r>
8000b3d4:	8e 68       	ld.sh	r8,r7[0xc]
8000b3d6:	10 99       	mov	r9,r8
8000b3d8:	ad c8       	cbr	r8,0xc
8000b3da:	ad a9       	sbr	r9,0xc
8000b3dc:	5b fc       	cp.w	r12,-1
8000b3de:	ef f8 0c 06 	st.heq	r7[0xc],r8
8000b3e2:	ef f9 1c 06 	st.hne	r7[0xc],r9
8000b3e6:	ef fc 1a 15 	st.wne	r7[0x54],r12
8000b3ea:	d8 22       	popm	r4-r7,pc

8000b3ec <__swrite>:
8000b3ec:	d4 21       	pushm	r4-r7,lr
8000b3ee:	96 68       	ld.sh	r8,r11[0xc]
8000b3f0:	16 97       	mov	r7,r11
8000b3f2:	14 95       	mov	r5,r10
8000b3f4:	12 94       	mov	r4,r9
8000b3f6:	e2 18 01 00 	andl	r8,0x100,COH
8000b3fa:	18 96       	mov	r6,r12
8000b3fc:	c0 50       	breq	8000b406 <__swrite+0x1a>
8000b3fe:	30 29       	mov	r9,2
8000b400:	30 0a       	mov	r10,0
8000b402:	96 7b       	ld.sh	r11,r11[0xe]
8000b404:	ce ac       	rcall	8000b5d8 <_lseek_r>
8000b406:	8e 68       	ld.sh	r8,r7[0xc]
8000b408:	ad c8       	cbr	r8,0xc
8000b40a:	08 99       	mov	r9,r4
8000b40c:	0a 9a       	mov	r10,r5
8000b40e:	8e 7b       	ld.sh	r11,r7[0xe]
8000b410:	0c 9c       	mov	r12,r6
8000b412:	ae 68       	st.h	r7[0xc],r8
8000b414:	c1 cc       	rcall	8000b44c <_write_r>
8000b416:	d8 22       	popm	r4-r7,pc

8000b418 <__sread>:
8000b418:	d4 21       	pushm	r4-r7,lr
8000b41a:	16 97       	mov	r7,r11
8000b41c:	96 7b       	ld.sh	r11,r11[0xe]
8000b41e:	cf 1c       	rcall	8000b600 <_read_r>
8000b420:	c0 65       	brlt	8000b42c <__sread+0x14>
8000b422:	6f 58       	ld.w	r8,r7[0x54]
8000b424:	18 08       	add	r8,r12
8000b426:	ef 48 00 54 	st.w	r7[84],r8
8000b42a:	d8 22       	popm	r4-r7,pc
8000b42c:	8e 68       	ld.sh	r8,r7[0xc]
8000b42e:	ad c8       	cbr	r8,0xc
8000b430:	ae 68       	st.h	r7[0xc],r8
8000b432:	d8 22       	popm	r4-r7,pc

8000b434 <strlen>:
8000b434:	30 09       	mov	r9,0
8000b436:	18 98       	mov	r8,r12
8000b438:	c0 28       	rjmp	8000b43c <strlen+0x8>
8000b43a:	2f f8       	sub	r8,-1
8000b43c:	11 8a       	ld.ub	r10,r8[0x0]
8000b43e:	f2 0a 18 00 	cp.b	r10,r9
8000b442:	cf c1       	brne	8000b43a <strlen+0x6>
8000b444:	f0 0c 01 0c 	sub	r12,r8,r12
8000b448:	5e fc       	retal	r12
8000b44a:	d7 03       	nop

8000b44c <_write_r>:
8000b44c:	d4 21       	pushm	r4-r7,lr
8000b44e:	16 98       	mov	r8,r11
8000b450:	18 97       	mov	r7,r12
8000b452:	10 9c       	mov	r12,r8
8000b454:	30 08       	mov	r8,0
8000b456:	14 9b       	mov	r11,r10
8000b458:	e0 66 63 9c 	mov	r6,25500
8000b45c:	12 9a       	mov	r10,r9
8000b45e:	8d 08       	st.w	r6[0x0],r8
8000b460:	fe b0 d1 b2 	rcall	800057c4 <_write>
8000b464:	5b fc       	cp.w	r12,-1
8000b466:	c0 51       	brne	8000b470 <_write_r+0x24>
8000b468:	6c 08       	ld.w	r8,r6[0x0]
8000b46a:	58 08       	cp.w	r8,0
8000b46c:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b470:	d8 22       	popm	r4-r7,pc
8000b472:	d7 03       	nop

8000b474 <_calloc_r>:
8000b474:	d4 21       	pushm	r4-r7,lr
8000b476:	f4 0b 02 4b 	mul	r11,r10,r11
8000b47a:	fe b0 db 6d 	rcall	80006b54 <_malloc_r>
8000b47e:	18 97       	mov	r7,r12
8000b480:	c2 30       	breq	8000b4c6 <_calloc_r+0x52>
8000b482:	f8 fa ff fc 	ld.w	r10,r12[-4]
8000b486:	e0 1a ff fc 	andl	r10,0xfffc
8000b48a:	20 4a       	sub	r10,4
8000b48c:	e0 4a 00 24 	cp.w	r10,36
8000b490:	e0 8b 00 18 	brhi	8000b4c0 <_calloc_r+0x4c>
8000b494:	18 98       	mov	r8,r12
8000b496:	59 3a       	cp.w	r10,19
8000b498:	e0 88 00 0f 	brls	8000b4b6 <_calloc_r+0x42>
8000b49c:	30 09       	mov	r9,0
8000b49e:	10 a9       	st.w	r8++,r9
8000b4a0:	10 a9       	st.w	r8++,r9
8000b4a2:	59 ba       	cp.w	r10,27
8000b4a4:	e0 88 00 09 	brls	8000b4b6 <_calloc_r+0x42>
8000b4a8:	10 a9       	st.w	r8++,r9
8000b4aa:	10 a9       	st.w	r8++,r9
8000b4ac:	e0 4a 00 24 	cp.w	r10,36
8000b4b0:	c0 31       	brne	8000b4b6 <_calloc_r+0x42>
8000b4b2:	10 a9       	st.w	r8++,r9
8000b4b4:	10 a9       	st.w	r8++,r9
8000b4b6:	30 09       	mov	r9,0
8000b4b8:	10 a9       	st.w	r8++,r9
8000b4ba:	91 19       	st.w	r8[0x4],r9
8000b4bc:	91 09       	st.w	r8[0x0],r9
8000b4be:	c0 48       	rjmp	8000b4c6 <_calloc_r+0x52>
8000b4c0:	30 0b       	mov	r11,0
8000b4c2:	fe b0 de 1c 	rcall	800070fa <memset>
8000b4c6:	0e 9c       	mov	r12,r7
8000b4c8:	d8 22       	popm	r4-r7,pc
8000b4ca:	d7 03       	nop

8000b4cc <_close_r>:
8000b4cc:	d4 21       	pushm	r4-r7,lr
8000b4ce:	30 08       	mov	r8,0
8000b4d0:	18 97       	mov	r7,r12
8000b4d2:	e0 66 63 9c 	mov	r6,25500
8000b4d6:	16 9c       	mov	r12,r11
8000b4d8:	8d 08       	st.w	r6[0x0],r8
8000b4da:	fe b0 df b5 	rcall	80007444 <_close>
8000b4de:	5b fc       	cp.w	r12,-1
8000b4e0:	c0 51       	brne	8000b4ea <_close_r+0x1e>
8000b4e2:	6c 08       	ld.w	r8,r6[0x0]
8000b4e4:	58 08       	cp.w	r8,0
8000b4e6:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b4ea:	d8 22       	popm	r4-r7,pc

8000b4ec <_fclose_r>:
8000b4ec:	d4 21       	pushm	r4-r7,lr
8000b4ee:	18 96       	mov	r6,r12
8000b4f0:	16 97       	mov	r7,r11
8000b4f2:	58 0b       	cp.w	r11,0
8000b4f4:	c0 31       	brne	8000b4fa <_fclose_r+0xe>
8000b4f6:	16 95       	mov	r5,r11
8000b4f8:	c5 38       	rjmp	8000b59e <_fclose_r+0xb2>
8000b4fa:	fe b0 f8 a9 	rcall	8000a64c <__sfp_lock_acquire>
8000b4fe:	58 06       	cp.w	r6,0
8000b500:	c0 70       	breq	8000b50e <_fclose_r+0x22>
8000b502:	6c 68       	ld.w	r8,r6[0x18]
8000b504:	58 08       	cp.w	r8,0
8000b506:	c0 41       	brne	8000b50e <_fclose_r+0x22>
8000b508:	0c 9c       	mov	r12,r6
8000b50a:	fe b0 f8 f3 	rcall	8000a6f0 <__sinit>
8000b50e:	fe c8 dd 42 	sub	r8,pc,-8894
8000b512:	10 37       	cp.w	r7,r8
8000b514:	c0 31       	brne	8000b51a <_fclose_r+0x2e>
8000b516:	6c 07       	ld.w	r7,r6[0x0]
8000b518:	c0 c8       	rjmp	8000b530 <_fclose_r+0x44>
8000b51a:	fe c8 dd 2e 	sub	r8,pc,-8914
8000b51e:	10 37       	cp.w	r7,r8
8000b520:	c0 31       	brne	8000b526 <_fclose_r+0x3a>
8000b522:	6c 17       	ld.w	r7,r6[0x4]
8000b524:	c0 68       	rjmp	8000b530 <_fclose_r+0x44>
8000b526:	fe c8 dd 1a 	sub	r8,pc,-8934
8000b52a:	10 37       	cp.w	r7,r8
8000b52c:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000b530:	8e 69       	ld.sh	r9,r7[0xc]
8000b532:	30 08       	mov	r8,0
8000b534:	f0 09 19 00 	cp.h	r9,r8
8000b538:	c0 51       	brne	8000b542 <_fclose_r+0x56>
8000b53a:	fe b0 f8 8a 	rcall	8000a64e <__sfp_lock_release>
8000b53e:	30 05       	mov	r5,0
8000b540:	c2 f8       	rjmp	8000b59e <_fclose_r+0xb2>
8000b542:	0e 9b       	mov	r11,r7
8000b544:	0c 9c       	mov	r12,r6
8000b546:	fe b0 f7 fd 	rcall	8000a540 <_fflush_r>
8000b54a:	6e c8       	ld.w	r8,r7[0x30]
8000b54c:	18 95       	mov	r5,r12
8000b54e:	58 08       	cp.w	r8,0
8000b550:	c0 60       	breq	8000b55c <_fclose_r+0x70>
8000b552:	6e 8b       	ld.w	r11,r7[0x20]
8000b554:	0c 9c       	mov	r12,r6
8000b556:	5d 18       	icall	r8
8000b558:	f9 b5 05 ff 	movlt	r5,-1
8000b55c:	8e 68       	ld.sh	r8,r7[0xc]
8000b55e:	ed b8 00 07 	bld	r8,0x7
8000b562:	c0 51       	brne	8000b56c <_fclose_r+0x80>
8000b564:	6e 4b       	ld.w	r11,r7[0x10]
8000b566:	0c 9c       	mov	r12,r6
8000b568:	fe b0 f9 5e 	rcall	8000a824 <_free_r>
8000b56c:	6e db       	ld.w	r11,r7[0x34]
8000b56e:	58 0b       	cp.w	r11,0
8000b570:	c0 a0       	breq	8000b584 <_fclose_r+0x98>
8000b572:	ee c8 ff bc 	sub	r8,r7,-68
8000b576:	10 3b       	cp.w	r11,r8
8000b578:	c0 40       	breq	8000b580 <_fclose_r+0x94>
8000b57a:	0c 9c       	mov	r12,r6
8000b57c:	fe b0 f9 54 	rcall	8000a824 <_free_r>
8000b580:	30 08       	mov	r8,0
8000b582:	8f d8       	st.w	r7[0x34],r8
8000b584:	6f 2b       	ld.w	r11,r7[0x48]
8000b586:	58 0b       	cp.w	r11,0
8000b588:	c0 70       	breq	8000b596 <_fclose_r+0xaa>
8000b58a:	0c 9c       	mov	r12,r6
8000b58c:	fe b0 f9 4c 	rcall	8000a824 <_free_r>
8000b590:	30 08       	mov	r8,0
8000b592:	ef 48 00 48 	st.w	r7[72],r8
8000b596:	30 08       	mov	r8,0
8000b598:	ae 68       	st.h	r7[0xc],r8
8000b59a:	fe b0 f8 5a 	rcall	8000a64e <__sfp_lock_release>
8000b59e:	0a 9c       	mov	r12,r5
8000b5a0:	d8 22       	popm	r4-r7,pc
8000b5a2:	d7 03       	nop

8000b5a4 <fclose>:
8000b5a4:	d4 01       	pushm	lr
8000b5a6:	e0 68 0a 38 	mov	r8,2616
8000b5aa:	18 9b       	mov	r11,r12
8000b5ac:	70 0c       	ld.w	r12,r8[0x0]
8000b5ae:	c9 ff       	rcall	8000b4ec <_fclose_r>
8000b5b0:	d8 02       	popm	pc
8000b5b2:	d7 03       	nop

8000b5b4 <_fstat_r>:
8000b5b4:	d4 21       	pushm	r4-r7,lr
8000b5b6:	16 98       	mov	r8,r11
8000b5b8:	18 97       	mov	r7,r12
8000b5ba:	10 9c       	mov	r12,r8
8000b5bc:	30 08       	mov	r8,0
8000b5be:	e0 66 63 9c 	mov	r6,25500
8000b5c2:	14 9b       	mov	r11,r10
8000b5c4:	8d 08       	st.w	r6[0x0],r8
8000b5c6:	fe b0 df 67 	rcall	80007494 <_fstat>
8000b5ca:	5b fc       	cp.w	r12,-1
8000b5cc:	c0 51       	brne	8000b5d6 <_fstat_r+0x22>
8000b5ce:	6c 08       	ld.w	r8,r6[0x0]
8000b5d0:	58 08       	cp.w	r8,0
8000b5d2:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b5d6:	d8 22       	popm	r4-r7,pc

8000b5d8 <_lseek_r>:
8000b5d8:	d4 21       	pushm	r4-r7,lr
8000b5da:	16 98       	mov	r8,r11
8000b5dc:	18 97       	mov	r7,r12
8000b5de:	10 9c       	mov	r12,r8
8000b5e0:	30 08       	mov	r8,0
8000b5e2:	14 9b       	mov	r11,r10
8000b5e4:	e0 66 63 9c 	mov	r6,25500
8000b5e8:	12 9a       	mov	r10,r9
8000b5ea:	8d 08       	st.w	r6[0x0],r8
8000b5ec:	fe b0 df 36 	rcall	80007458 <_lseek>
8000b5f0:	5b fc       	cp.w	r12,-1
8000b5f2:	c0 51       	brne	8000b5fc <_lseek_r+0x24>
8000b5f4:	6c 08       	ld.w	r8,r6[0x0]
8000b5f6:	58 08       	cp.w	r8,0
8000b5f8:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b5fc:	d8 22       	popm	r4-r7,pc
8000b5fe:	d7 03       	nop

8000b600 <_read_r>:
8000b600:	d4 21       	pushm	r4-r7,lr
8000b602:	16 98       	mov	r8,r11
8000b604:	18 97       	mov	r7,r12
8000b606:	10 9c       	mov	r12,r8
8000b608:	30 08       	mov	r8,0
8000b60a:	14 9b       	mov	r11,r10
8000b60c:	e0 66 63 9c 	mov	r6,25500
8000b610:	12 9a       	mov	r10,r9
8000b612:	8d 08       	st.w	r6[0x0],r8
8000b614:	fe b0 d0 b8 	rcall	80005784 <_read>
8000b618:	5b fc       	cp.w	r12,-1
8000b61a:	c0 51       	brne	8000b624 <_read_r+0x24>
8000b61c:	6c 08       	ld.w	r8,r6[0x0]
8000b61e:	58 08       	cp.w	r8,0
8000b620:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b624:	d8 22       	popm	r4-r7,pc
8000b626:	d7 03       	nop

8000b628 <__avr32_f64_mul>:
8000b628:	f5 eb 10 1c 	or	r12,r10,r11<<0x1
8000b62c:	e0 80 00 dc 	breq	8000b7e4 <__avr32_f64_mul_op1_zero>
8000b630:	d4 21       	pushm	r4-r7,lr
8000b632:	f7 e9 20 0e 	eor	lr,r11,r9
8000b636:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000b63a:	30 15       	mov	r5,1
8000b63c:	c4 30       	breq	8000b6c2 <__avr32_f64_mul_op1_subnormal>
8000b63e:	ab 6b       	lsl	r11,0xa
8000b640:	f7 ea 13 6b 	or	r11,r11,r10>>0x16
8000b644:	ab 6a       	lsl	r10,0xa
8000b646:	f7 d5 d3 c2 	bfins	r11,r5,0x1e,0x2
8000b64a:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000b64e:	c5 c0       	breq	8000b706 <__avr32_f64_mul_op2_subnormal>
8000b650:	a1 78       	lsl	r8,0x1
8000b652:	5c f9       	rol	r9
8000b654:	f3 d5 d2 ab 	bfins	r9,r5,0x15,0xb
8000b658:	e0 47 07 ff 	cp.w	r7,2047
8000b65c:	c7 70       	breq	8000b74a <__avr32_f64_mul_op_nan_or_inf>
8000b65e:	e0 46 07 ff 	cp.w	r6,2047
8000b662:	c7 40       	breq	8000b74a <__avr32_f64_mul_op_nan_or_inf>
8000b664:	ee 06 00 0c 	add	r12,r7,r6
8000b668:	e0 2c 03 fe 	sub	r12,1022
8000b66c:	f6 08 06 44 	mulu.d	r4,r11,r8
8000b670:	f4 09 07 44 	macu.d	r4,r10,r9
8000b674:	f4 08 06 46 	mulu.d	r6,r10,r8
8000b678:	f6 09 06 4a 	mulu.d	r10,r11,r9
8000b67c:	08 07       	add	r7,r4
8000b67e:	f4 05 00 4a 	adc	r10,r10,r5
8000b682:	5c 0b       	acr	r11
8000b684:	ed bb 00 14 	bld	r11,0x14
8000b688:	c0 50       	breq	8000b692 <__avr32_f64_mul+0x6a>
8000b68a:	a1 77       	lsl	r7,0x1
8000b68c:	5c fa       	rol	r10
8000b68e:	5c fb       	rol	r11
8000b690:	20 1c       	sub	r12,1
8000b692:	58 0c       	cp.w	r12,0
8000b694:	e0 8a 00 6f 	brle	8000b772 <__avr32_f64_mul_res_subnormal>
8000b698:	e0 4c 07 ff 	cp.w	r12,2047
8000b69c:	e0 84 00 9c 	brge	8000b7d4 <__avr32_f64_mul_res_inf>
8000b6a0:	f7 dc d2 8b 	bfins	r11,r12,0x14,0xb
8000b6a4:	ed ea 11 f6 	or	r6,r6,r10<<0x1f
8000b6a8:	ef e6 12 17 	or	r7,r7,r6>>0x1
8000b6ac:	ee 17 80 00 	eorh	r7,0x8000
8000b6b0:	f1 b7 04 20 	satu	r7,0x1
8000b6b4:	0e 0a       	add	r10,r7
8000b6b6:	5c 0b       	acr	r11
8000b6b8:	ed be 00 1f 	bld	lr,0x1f
8000b6bc:	ef bb 00 1f 	bst	r11,0x1f
8000b6c0:	d8 22       	popm	r4-r7,pc

8000b6c2 <__avr32_f64_mul_op1_subnormal>:
8000b6c2:	e4 1b 00 0f 	andh	r11,0xf
8000b6c6:	f4 0c 12 00 	clz	r12,r10
8000b6ca:	f6 06 12 00 	clz	r6,r11
8000b6ce:	f7 bc 03 e1 	sublo	r12,-31
8000b6d2:	f8 06 17 30 	movlo	r6,r12
8000b6d6:	f7 b6 02 01 	subhs	r6,1
8000b6da:	e0 46 00 20 	cp.w	r6,32
8000b6de:	c0 d4       	brge	8000b6f8 <__avr32_f64_mul_op1_subnormal+0x36>
8000b6e0:	ec 0c 11 20 	rsub	r12,r6,32
8000b6e4:	f6 06 09 4b 	lsl	r11,r11,r6
8000b6e8:	f4 0c 0a 4c 	lsr	r12,r10,r12
8000b6ec:	18 4b       	or	r11,r12
8000b6ee:	f4 06 09 4a 	lsl	r10,r10,r6
8000b6f2:	20 b6       	sub	r6,11
8000b6f4:	0c 17       	sub	r7,r6
8000b6f6:	ca ab       	rjmp	8000b64a <__avr32_f64_mul+0x22>
8000b6f8:	f4 06 09 4b 	lsl	r11,r10,r6
8000b6fc:	c6 40       	breq	8000b7c4 <__avr32_f64_mul_res_zero>
8000b6fe:	30 0a       	mov	r10,0
8000b700:	20 b6       	sub	r6,11
8000b702:	0c 17       	sub	r7,r6
8000b704:	ca 3b       	rjmp	8000b64a <__avr32_f64_mul+0x22>

8000b706 <__avr32_f64_mul_op2_subnormal>:
8000b706:	e4 19 00 0f 	andh	r9,0xf
8000b70a:	f0 0c 12 00 	clz	r12,r8
8000b70e:	f2 05 12 00 	clz	r5,r9
8000b712:	f7 bc 03 ea 	sublo	r12,-22
8000b716:	f8 05 17 30 	movlo	r5,r12
8000b71a:	f7 b5 02 0a 	subhs	r5,10
8000b71e:	e0 45 00 20 	cp.w	r5,32
8000b722:	c0 d4       	brge	8000b73c <__avr32_f64_mul_op2_subnormal+0x36>
8000b724:	ea 0c 11 20 	rsub	r12,r5,32
8000b728:	f2 05 09 49 	lsl	r9,r9,r5
8000b72c:	f0 0c 0a 4c 	lsr	r12,r8,r12
8000b730:	18 49       	or	r9,r12
8000b732:	f0 05 09 48 	lsl	r8,r8,r5
8000b736:	20 25       	sub	r5,2
8000b738:	0a 16       	sub	r6,r5
8000b73a:	c8 fb       	rjmp	8000b658 <__avr32_f64_mul+0x30>
8000b73c:	f0 05 09 49 	lsl	r9,r8,r5
8000b740:	c4 20       	breq	8000b7c4 <__avr32_f64_mul_res_zero>
8000b742:	30 08       	mov	r8,0
8000b744:	20 25       	sub	r5,2
8000b746:	0a 16       	sub	r6,r5
8000b748:	c8 8b       	rjmp	8000b658 <__avr32_f64_mul+0x30>

8000b74a <__avr32_f64_mul_op_nan_or_inf>:
8000b74a:	e4 19 00 0f 	andh	r9,0xf
8000b74e:	e4 1b 00 0f 	andh	r11,0xf
8000b752:	14 4b       	or	r11,r10
8000b754:	10 49       	or	r9,r8
8000b756:	e0 47 07 ff 	cp.w	r7,2047
8000b75a:	c0 91       	brne	8000b76c <__avr32_f64_mul_op1_not_naninf>
8000b75c:	58 0b       	cp.w	r11,0
8000b75e:	c3 81       	brne	8000b7ce <__avr32_f64_mul_res_nan>
8000b760:	e0 46 07 ff 	cp.w	r6,2047
8000b764:	c3 81       	brne	8000b7d4 <__avr32_f64_mul_res_inf>
8000b766:	58 09       	cp.w	r9,0
8000b768:	c3 60       	breq	8000b7d4 <__avr32_f64_mul_res_inf>
8000b76a:	c3 28       	rjmp	8000b7ce <__avr32_f64_mul_res_nan>

8000b76c <__avr32_f64_mul_op1_not_naninf>:
8000b76c:	58 09       	cp.w	r9,0
8000b76e:	c3 30       	breq	8000b7d4 <__avr32_f64_mul_res_inf>
8000b770:	c2 f8       	rjmp	8000b7ce <__avr32_f64_mul_res_nan>

8000b772 <__avr32_f64_mul_res_subnormal>:
8000b772:	5c 3c       	neg	r12
8000b774:	2f fc       	sub	r12,-1
8000b776:	f1 bc 04 c0 	satu	r12,0x6
8000b77a:	e0 4c 00 20 	cp.w	r12,32
8000b77e:	c1 14       	brge	8000b7a0 <__avr32_f64_mul_res_subnormal+0x2e>
8000b780:	f8 08 11 20 	rsub	r8,r12,32
8000b784:	0e 46       	or	r6,r7
8000b786:	ee 0c 0a 47 	lsr	r7,r7,r12
8000b78a:	f4 08 09 49 	lsl	r9,r10,r8
8000b78e:	12 47       	or	r7,r9
8000b790:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000b794:	f6 08 09 49 	lsl	r9,r11,r8
8000b798:	12 4a       	or	r10,r9
8000b79a:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000b79e:	c8 3b       	rjmp	8000b6a4 <__avr32_f64_mul+0x7c>
8000b7a0:	f8 08 11 20 	rsub	r8,r12,32
8000b7a4:	f9 b9 00 00 	moveq	r9,0
8000b7a8:	c0 30       	breq	8000b7ae <__avr32_f64_mul_res_subnormal+0x3c>
8000b7aa:	f6 08 09 49 	lsl	r9,r11,r8
8000b7ae:	0e 46       	or	r6,r7
8000b7b0:	ed ea 10 16 	or	r6,r6,r10<<0x1
8000b7b4:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000b7b8:	f3 ea 10 07 	or	r7,r9,r10
8000b7bc:	f6 0c 0a 4a 	lsr	r10,r11,r12
8000b7c0:	30 0b       	mov	r11,0
8000b7c2:	c7 1b       	rjmp	8000b6a4 <__avr32_f64_mul+0x7c>

8000b7c4 <__avr32_f64_mul_res_zero>:
8000b7c4:	1c 9b       	mov	r11,lr
8000b7c6:	e6 1b 80 00 	andh	r11,0x8000,COH
8000b7ca:	30 0a       	mov	r10,0
8000b7cc:	d8 22       	popm	r4-r7,pc

8000b7ce <__avr32_f64_mul_res_nan>:
8000b7ce:	3f fb       	mov	r11,-1
8000b7d0:	3f fa       	mov	r10,-1
8000b7d2:	d8 22       	popm	r4-r7,pc

8000b7d4 <__avr32_f64_mul_res_inf>:
8000b7d4:	f0 6b 00 00 	mov	r11,-1048576
8000b7d8:	ed be 00 1f 	bld	lr,0x1f
8000b7dc:	ef bb 00 1f 	bst	r11,0x1f
8000b7e0:	30 0a       	mov	r10,0
8000b7e2:	d8 22       	popm	r4-r7,pc

8000b7e4 <__avr32_f64_mul_op1_zero>:
8000b7e4:	f7 e9 20 0b 	eor	r11,r11,r9
8000b7e8:	e6 1b 80 00 	andh	r11,0x8000,COH
8000b7ec:	f9 d9 c2 8b 	bfextu	r12,r9,0x14,0xb
8000b7f0:	e0 4c 07 ff 	cp.w	r12,2047
8000b7f4:	5e 1c       	retne	r12
8000b7f6:	3f fa       	mov	r10,-1
8000b7f8:	3f fb       	mov	r11,-1
8000b7fa:	5e fc       	retal	r12

8000b7fc <__avr32_f64_sub_from_add>:
8000b7fc:	ee 19 80 00 	eorh	r9,0x8000

8000b800 <__avr32_f64_sub>:
8000b800:	f7 e9 20 0c 	eor	r12,r11,r9
8000b804:	e0 86 00 ca 	brmi	8000b998 <__avr32_f64_add_from_sub>
8000b808:	eb cd 40 e0 	pushm	r5-r7,lr
8000b80c:	16 9c       	mov	r12,r11
8000b80e:	e6 1c 80 00 	andh	r12,0x8000,COH
8000b812:	bf db       	cbr	r11,0x1f
8000b814:	bf d9       	cbr	r9,0x1f
8000b816:	10 3a       	cp.w	r10,r8
8000b818:	f2 0b 13 00 	cpc	r11,r9
8000b81c:	c0 92       	brcc	8000b82e <__avr32_f64_sub+0x2e>
8000b81e:	16 97       	mov	r7,r11
8000b820:	12 9b       	mov	r11,r9
8000b822:	0e 99       	mov	r9,r7
8000b824:	14 97       	mov	r7,r10
8000b826:	10 9a       	mov	r10,r8
8000b828:	0e 98       	mov	r8,r7
8000b82a:	ee 1c 80 00 	eorh	r12,0x8000
8000b82e:	f6 07 16 14 	lsr	r7,r11,0x14
8000b832:	ab 7b       	lsl	r11,0xb
8000b834:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000b838:	ab 7a       	lsl	r10,0xb
8000b83a:	bf bb       	sbr	r11,0x1f
8000b83c:	f2 06 16 14 	lsr	r6,r9,0x14
8000b840:	c4 40       	breq	8000b8c8 <__avr32_f64_sub_opL_subnormal>
8000b842:	ab 79       	lsl	r9,0xb
8000b844:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000b848:	ab 78       	lsl	r8,0xb
8000b84a:	bf b9       	sbr	r9,0x1f

8000b84c <__avr32_f64_sub_opL_subnormal_done>:
8000b84c:	e0 47 07 ff 	cp.w	r7,2047
8000b850:	c4 f0       	breq	8000b8ee <__avr32_f64_sub_opH_nan_or_inf>
8000b852:	0e 26       	rsub	r6,r7
8000b854:	c1 20       	breq	8000b878 <__avr32_f64_sub_shift_done>
8000b856:	ec 05 11 20 	rsub	r5,r6,32
8000b85a:	e0 46 00 20 	cp.w	r6,32
8000b85e:	c7 c2       	brcc	8000b956 <__avr32_f64_sub_longshift>
8000b860:	f0 05 09 4e 	lsl	lr,r8,r5
8000b864:	f2 05 09 45 	lsl	r5,r9,r5
8000b868:	f0 06 0a 48 	lsr	r8,r8,r6
8000b86c:	f2 06 0a 49 	lsr	r9,r9,r6
8000b870:	0a 48       	or	r8,r5
8000b872:	58 0e       	cp.w	lr,0
8000b874:	5f 1e       	srne	lr
8000b876:	1c 48       	or	r8,lr

8000b878 <__avr32_f64_sub_shift_done>:
8000b878:	10 1a       	sub	r10,r8
8000b87a:	f6 09 01 4b 	sbc	r11,r11,r9
8000b87e:	f6 06 12 00 	clz	r6,r11
8000b882:	c0 e0       	breq	8000b89e <__avr32_f64_sub_longnormalize_done>
8000b884:	c7 83       	brcs	8000b974 <__avr32_f64_sub_longnormalize>
8000b886:	ec 0e 11 20 	rsub	lr,r6,32
8000b88a:	f6 06 09 4b 	lsl	r11,r11,r6
8000b88e:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000b892:	1c 4b       	or	r11,lr
8000b894:	f4 06 09 4a 	lsl	r10,r10,r6
8000b898:	0c 17       	sub	r7,r6
8000b89a:	e0 8a 00 39 	brle	8000b90c <__avr32_f64_sub_subnormal_result>

8000b89e <__avr32_f64_sub_longnormalize_done>:
8000b89e:	f4 09 15 15 	lsl	r9,r10,0x15
8000b8a2:	ab 9a       	lsr	r10,0xb
8000b8a4:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000b8a8:	ab 9b       	lsr	r11,0xb
8000b8aa:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000b8ae:	18 4b       	or	r11,r12

8000b8b0 <__avr32_f64_sub_round>:
8000b8b0:	fc 17 80 00 	movh	r7,0x8000
8000b8b4:	ed ba 00 00 	bld	r10,0x0
8000b8b8:	f7 b7 01 ff 	subne	r7,-1
8000b8bc:	0e 39       	cp.w	r9,r7
8000b8be:	5f 29       	srhs	r9
8000b8c0:	12 0a       	add	r10,r9
8000b8c2:	5c 0b       	acr	r11
8000b8c4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b8c8 <__avr32_f64_sub_opL_subnormal>:
8000b8c8:	ab 79       	lsl	r9,0xb
8000b8ca:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000b8ce:	ab 78       	lsl	r8,0xb
8000b8d0:	f3 e8 10 0e 	or	lr,r9,r8
8000b8d4:	f9 b6 01 01 	movne	r6,1
8000b8d8:	ee 0e 11 00 	rsub	lr,r7,0
8000b8dc:	f9 b7 00 01 	moveq	r7,1
8000b8e0:	ef bb 00 1f 	bst	r11,0x1f
8000b8e4:	f7 ea 10 0e 	or	lr,r11,r10
8000b8e8:	f9 b7 00 00 	moveq	r7,0
8000b8ec:	cb 0b       	rjmp	8000b84c <__avr32_f64_sub_opL_subnormal_done>

8000b8ee <__avr32_f64_sub_opH_nan_or_inf>:
8000b8ee:	bf db       	cbr	r11,0x1f
8000b8f0:	f7 ea 10 0e 	or	lr,r11,r10
8000b8f4:	c0 81       	brne	8000b904 <__avr32_f64_sub_return_nan>
8000b8f6:	e0 46 07 ff 	cp.w	r6,2047
8000b8fa:	c0 50       	breq	8000b904 <__avr32_f64_sub_return_nan>
8000b8fc:	f9 e7 11 4b 	or	r11,r12,r7<<0x14
8000b900:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b904 <__avr32_f64_sub_return_nan>:
8000b904:	3f fa       	mov	r10,-1
8000b906:	3f fb       	mov	r11,-1
8000b908:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b90c <__avr32_f64_sub_subnormal_result>:
8000b90c:	5c 37       	neg	r7
8000b90e:	2f f7       	sub	r7,-1
8000b910:	f1 b7 04 c0 	satu	r7,0x6
8000b914:	e0 47 00 20 	cp.w	r7,32
8000b918:	c1 14       	brge	8000b93a <__avr32_f64_sub_subnormal_result+0x2e>
8000b91a:	ee 08 11 20 	rsub	r8,r7,32
8000b91e:	f4 08 09 49 	lsl	r9,r10,r8
8000b922:	5f 16       	srne	r6
8000b924:	f4 07 0a 4a 	lsr	r10,r10,r7
8000b928:	0c 4a       	or	r10,r6
8000b92a:	f6 08 09 49 	lsl	r9,r11,r8
8000b92e:	f5 e9 10 0a 	or	r10,r10,r9
8000b932:	f4 07 0a 4b 	lsr	r11,r10,r7
8000b936:	30 07       	mov	r7,0
8000b938:	cb 3b       	rjmp	8000b89e <__avr32_f64_sub_longnormalize_done>
8000b93a:	ee 08 11 40 	rsub	r8,r7,64
8000b93e:	f6 08 09 49 	lsl	r9,r11,r8
8000b942:	14 49       	or	r9,r10
8000b944:	5f 16       	srne	r6
8000b946:	f6 07 0a 4a 	lsr	r10,r11,r7
8000b94a:	0c 4a       	or	r10,r6
8000b94c:	30 0b       	mov	r11,0
8000b94e:	30 07       	mov	r7,0
8000b950:	ca 7b       	rjmp	8000b89e <__avr32_f64_sub_longnormalize_done>
8000b952:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b956 <__avr32_f64_sub_longshift>:
8000b956:	f1 b6 04 c0 	satu	r6,0x6
8000b95a:	f0 0e 17 00 	moveq	lr,r8
8000b95e:	c0 40       	breq	8000b966 <__avr32_f64_sub_longshift+0x10>
8000b960:	f2 05 09 4e 	lsl	lr,r9,r5
8000b964:	10 4e       	or	lr,r8
8000b966:	f2 06 0a 48 	lsr	r8,r9,r6
8000b96a:	30 09       	mov	r9,0
8000b96c:	58 0e       	cp.w	lr,0
8000b96e:	5f 1e       	srne	lr
8000b970:	1c 48       	or	r8,lr
8000b972:	c8 3b       	rjmp	8000b878 <__avr32_f64_sub_shift_done>

8000b974 <__avr32_f64_sub_longnormalize>:
8000b974:	f4 06 12 00 	clz	r6,r10
8000b978:	f9 b7 03 00 	movlo	r7,0
8000b97c:	f9 b6 03 00 	movlo	r6,0
8000b980:	f9 bc 03 00 	movlo	r12,0
8000b984:	f7 b6 02 e0 	subhs	r6,-32
8000b988:	f4 06 09 4b 	lsl	r11,r10,r6
8000b98c:	30 0a       	mov	r10,0
8000b98e:	0c 17       	sub	r7,r6
8000b990:	fe 9a ff be 	brle	8000b90c <__avr32_f64_sub_subnormal_result>
8000b994:	c8 5b       	rjmp	8000b89e <__avr32_f64_sub_longnormalize_done>
8000b996:	d7 03       	nop

8000b998 <__avr32_f64_add_from_sub>:
8000b998:	ee 19 80 00 	eorh	r9,0x8000

8000b99c <__avr32_f64_add>:
8000b99c:	f7 e9 20 0c 	eor	r12,r11,r9
8000b9a0:	fe 96 ff 2e 	brmi	8000b7fc <__avr32_f64_sub_from_add>
8000b9a4:	eb cd 40 e0 	pushm	r5-r7,lr
8000b9a8:	16 9c       	mov	r12,r11
8000b9aa:	e6 1c 80 00 	andh	r12,0x8000,COH
8000b9ae:	bf db       	cbr	r11,0x1f
8000b9b0:	bf d9       	cbr	r9,0x1f
8000b9b2:	12 3b       	cp.w	r11,r9
8000b9b4:	c0 72       	brcc	8000b9c2 <__avr32_f64_add+0x26>
8000b9b6:	16 97       	mov	r7,r11
8000b9b8:	12 9b       	mov	r11,r9
8000b9ba:	0e 99       	mov	r9,r7
8000b9bc:	14 97       	mov	r7,r10
8000b9be:	10 9a       	mov	r10,r8
8000b9c0:	0e 98       	mov	r8,r7
8000b9c2:	30 0e       	mov	lr,0
8000b9c4:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000b9c8:	f7 db c0 14 	bfextu	r11,r11,0x0,0x14
8000b9cc:	b5 ab       	sbr	r11,0x14
8000b9ce:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000b9d2:	c6 20       	breq	8000ba96 <__avr32_f64_add_op2_subnormal>
8000b9d4:	f3 d9 c0 14 	bfextu	r9,r9,0x0,0x14
8000b9d8:	b5 a9       	sbr	r9,0x14
8000b9da:	e0 47 07 ff 	cp.w	r7,2047
8000b9de:	c2 80       	breq	8000ba2e <__avr32_f64_add_opH_nan_or_inf>
8000b9e0:	0e 26       	rsub	r6,r7
8000b9e2:	c1 20       	breq	8000ba06 <__avr32_f64_add_shift_done>
8000b9e4:	e0 46 00 36 	cp.w	r6,54
8000b9e8:	c1 52       	brcc	8000ba12 <__avr32_f64_add_res_of_done>
8000b9ea:	ec 05 11 20 	rsub	r5,r6,32
8000b9ee:	e0 46 00 20 	cp.w	r6,32
8000b9f2:	c3 52       	brcc	8000ba5c <__avr32_f64_add_longshift>
8000b9f4:	f0 05 09 4e 	lsl	lr,r8,r5
8000b9f8:	f2 05 09 45 	lsl	r5,r9,r5
8000b9fc:	f0 06 0a 48 	lsr	r8,r8,r6
8000ba00:	f2 06 0a 49 	lsr	r9,r9,r6
8000ba04:	0a 48       	or	r8,r5

8000ba06 <__avr32_f64_add_shift_done>:
8000ba06:	10 0a       	add	r10,r8
8000ba08:	f6 09 00 4b 	adc	r11,r11,r9
8000ba0c:	ed bb 00 15 	bld	r11,0x15
8000ba10:	c3 40       	breq	8000ba78 <__avr32_f64_add_res_of>

8000ba12 <__avr32_f64_add_res_of_done>:
8000ba12:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000ba16:	18 4b       	or	r11,r12

8000ba18 <__avr32_f64_add_round>:
8000ba18:	f9 da c0 01 	bfextu	r12,r10,0x0,0x1
8000ba1c:	18 4e       	or	lr,r12
8000ba1e:	ee 1e 80 00 	eorh	lr,0x8000
8000ba22:	f1 be 04 20 	satu	lr,0x1
8000ba26:	1c 0a       	add	r10,lr
8000ba28:	5c 0b       	acr	r11
8000ba2a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000ba2e <__avr32_f64_add_opH_nan_or_inf>:
8000ba2e:	b5 cb       	cbr	r11,0x14
8000ba30:	f7 ea 10 0e 	or	lr,r11,r10
8000ba34:	c1 01       	brne	8000ba54 <__avr32_f64_add_return_nan>
8000ba36:	e0 46 07 ff 	cp.w	r6,2047
8000ba3a:	c0 30       	breq	8000ba40 <__avr32_f64_add_opL_nan_or_inf>
8000ba3c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000ba40 <__avr32_f64_add_opL_nan_or_inf>:
8000ba40:	b5 c9       	cbr	r9,0x14
8000ba42:	f3 e8 10 0e 	or	lr,r9,r8
8000ba46:	c0 71       	brne	8000ba54 <__avr32_f64_add_return_nan>
8000ba48:	30 0a       	mov	r10,0
8000ba4a:	fc 1b 7f f0 	movh	r11,0x7ff0
8000ba4e:	18 4b       	or	r11,r12
8000ba50:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000ba54 <__avr32_f64_add_return_nan>:
8000ba54:	3f fa       	mov	r10,-1
8000ba56:	3f fb       	mov	r11,-1
8000ba58:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000ba5c <__avr32_f64_add_longshift>:
8000ba5c:	f1 b6 04 c0 	satu	r6,0x6
8000ba60:	f0 0e 17 00 	moveq	lr,r8
8000ba64:	c0 60       	breq	8000ba70 <__avr32_f64_add_longshift+0x14>
8000ba66:	f2 05 09 4e 	lsl	lr,r9,r5
8000ba6a:	58 08       	cp.w	r8,0
8000ba6c:	5f 18       	srne	r8
8000ba6e:	10 4e       	or	lr,r8
8000ba70:	f2 06 0a 48 	lsr	r8,r9,r6
8000ba74:	30 09       	mov	r9,0
8000ba76:	cc 8b       	rjmp	8000ba06 <__avr32_f64_add_shift_done>

8000ba78 <__avr32_f64_add_res_of>:
8000ba78:	fd ee 10 1e 	or	lr,lr,lr<<0x1
8000ba7c:	a1 9b       	lsr	r11,0x1
8000ba7e:	5d 0a       	ror	r10
8000ba80:	5d 0e       	ror	lr
8000ba82:	2f f7       	sub	r7,-1
8000ba84:	e0 47 07 ff 	cp.w	r7,2047
8000ba88:	f9 ba 00 00 	moveq	r10,0
8000ba8c:	f9 bb 00 00 	moveq	r11,0
8000ba90:	f9 be 00 00 	moveq	lr,0
8000ba94:	cb fb       	rjmp	8000ba12 <__avr32_f64_add_res_of_done>

8000ba96 <__avr32_f64_add_op2_subnormal>:
8000ba96:	30 16       	mov	r6,1
8000ba98:	58 07       	cp.w	r7,0
8000ba9a:	ca 01       	brne	8000b9da <__avr32_f64_add+0x3e>
8000ba9c:	b5 cb       	cbr	r11,0x14
8000ba9e:	10 0a       	add	r10,r8
8000baa0:	f6 09 00 4b 	adc	r11,r11,r9
8000baa4:	18 4b       	or	r11,r12
8000baa6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000baaa:	d7 03       	nop

8000baac <__avr32_f64_to_u32>:
8000baac:	58 0b       	cp.w	r11,0
8000baae:	5e 6d       	retmi	0

8000bab0 <__avr32_f64_to_s32>:
8000bab0:	f6 0c 15 01 	lsl	r12,r11,0x1
8000bab4:	b5 9c       	lsr	r12,0x15
8000bab6:	e0 2c 03 ff 	sub	r12,1023
8000baba:	5e 3d       	retlo	0
8000babc:	f8 0c 11 1f 	rsub	r12,r12,31
8000bac0:	16 99       	mov	r9,r11
8000bac2:	ab 7b       	lsl	r11,0xb
8000bac4:	bf bb       	sbr	r11,0x1f
8000bac6:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000baca:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000bace:	a1 79       	lsl	r9,0x1
8000bad0:	5e 2b       	reths	r11
8000bad2:	5c 3b       	neg	r11
8000bad4:	5e fb       	retal	r11

8000bad6 <__avr32_u32_to_f64>:
8000bad6:	f8 cb 00 00 	sub	r11,r12,0
8000bada:	30 0c       	mov	r12,0
8000badc:	c0 38       	rjmp	8000bae2 <__avr32_s32_to_f64+0x4>

8000bade <__avr32_s32_to_f64>:
8000bade:	18 9b       	mov	r11,r12
8000bae0:	5c 4b       	abs	r11
8000bae2:	30 0a       	mov	r10,0
8000bae4:	5e 0b       	reteq	r11
8000bae6:	d4 01       	pushm	lr
8000bae8:	e0 69 04 1e 	mov	r9,1054
8000baec:	f6 08 12 00 	clz	r8,r11
8000baf0:	c1 70       	breq	8000bb1e <__avr32_s32_to_f64+0x40>
8000baf2:	c0 c3       	brcs	8000bb0a <__avr32_s32_to_f64+0x2c>
8000baf4:	f0 0e 11 20 	rsub	lr,r8,32
8000baf8:	f6 08 09 4b 	lsl	r11,r11,r8
8000bafc:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000bb00:	1c 4b       	or	r11,lr
8000bb02:	f4 08 09 4a 	lsl	r10,r10,r8
8000bb06:	10 19       	sub	r9,r8
8000bb08:	c0 b8       	rjmp	8000bb1e <__avr32_s32_to_f64+0x40>
8000bb0a:	f4 08 12 00 	clz	r8,r10
8000bb0e:	f9 b8 03 00 	movlo	r8,0
8000bb12:	f7 b8 02 e0 	subhs	r8,-32
8000bb16:	f4 08 09 4b 	lsl	r11,r10,r8
8000bb1a:	30 0a       	mov	r10,0
8000bb1c:	10 19       	sub	r9,r8
8000bb1e:	58 09       	cp.w	r9,0
8000bb20:	e0 89 00 30 	brgt	8000bb80 <__avr32_s32_to_f64+0xa2>
8000bb24:	5c 39       	neg	r9
8000bb26:	2f f9       	sub	r9,-1
8000bb28:	e0 49 00 36 	cp.w	r9,54
8000bb2c:	c0 43       	brcs	8000bb34 <__avr32_s32_to_f64+0x56>
8000bb2e:	30 0b       	mov	r11,0
8000bb30:	30 0a       	mov	r10,0
8000bb32:	c2 68       	rjmp	8000bb7e <__avr32_s32_to_f64+0xa0>
8000bb34:	2f 69       	sub	r9,-10
8000bb36:	f2 08 11 20 	rsub	r8,r9,32
8000bb3a:	e0 49 00 20 	cp.w	r9,32
8000bb3e:	c0 b2       	brcc	8000bb54 <__avr32_s32_to_f64+0x76>
8000bb40:	f4 08 09 4e 	lsl	lr,r10,r8
8000bb44:	f6 08 09 48 	lsl	r8,r11,r8
8000bb48:	f4 09 0a 4a 	lsr	r10,r10,r9
8000bb4c:	f6 09 0a 4b 	lsr	r11,r11,r9
8000bb50:	10 4b       	or	r11,r8
8000bb52:	c0 88       	rjmp	8000bb62 <__avr32_s32_to_f64+0x84>
8000bb54:	f6 08 09 4e 	lsl	lr,r11,r8
8000bb58:	14 4e       	or	lr,r10
8000bb5a:	16 9a       	mov	r10,r11
8000bb5c:	30 0b       	mov	r11,0
8000bb5e:	f4 09 0a 4a 	lsr	r10,r10,r9
8000bb62:	ed ba 00 00 	bld	r10,0x0
8000bb66:	c0 92       	brcc	8000bb78 <__avr32_s32_to_f64+0x9a>
8000bb68:	1c 7e       	tst	lr,lr
8000bb6a:	c0 41       	brne	8000bb72 <__avr32_s32_to_f64+0x94>
8000bb6c:	ed ba 00 01 	bld	r10,0x1
8000bb70:	c0 42       	brcc	8000bb78 <__avr32_s32_to_f64+0x9a>
8000bb72:	2f fa       	sub	r10,-1
8000bb74:	f7 bb 02 ff 	subhs	r11,-1
8000bb78:	5c fc       	rol	r12
8000bb7a:	5d 0b       	ror	r11
8000bb7c:	5d 0a       	ror	r10
8000bb7e:	d8 02       	popm	pc
8000bb80:	e0 68 03 ff 	mov	r8,1023
8000bb84:	ed ba 00 0b 	bld	r10,0xb
8000bb88:	f7 b8 00 ff 	subeq	r8,-1
8000bb8c:	10 0a       	add	r10,r8
8000bb8e:	5c 0b       	acr	r11
8000bb90:	f7 b9 03 fe 	sublo	r9,-2
8000bb94:	e0 49 07 ff 	cp.w	r9,2047
8000bb98:	c0 55       	brlt	8000bba2 <__avr32_s32_to_f64+0xc4>
8000bb9a:	30 0a       	mov	r10,0
8000bb9c:	fc 1b ff e0 	movh	r11,0xffe0
8000bba0:	c0 c8       	rjmp	8000bbb8 <__floatsidf_return_op1>
8000bba2:	ed bb 00 1f 	bld	r11,0x1f
8000bba6:	f7 b9 01 01 	subne	r9,1
8000bbaa:	ab 9a       	lsr	r10,0xb
8000bbac:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000bbb0:	a1 7b       	lsl	r11,0x1
8000bbb2:	ab 9b       	lsr	r11,0xb
8000bbb4:	f7 e9 11 5b 	or	r11,r11,r9<<0x15

8000bbb8 <__floatsidf_return_op1>:
8000bbb8:	a1 7c       	lsl	r12,0x1
8000bbba:	5d 0b       	ror	r11
8000bbbc:	d8 02       	popm	pc

8000bbbe <__avr32_f64_cmp_eq>:
8000bbbe:	10 3a       	cp.w	r10,r8
8000bbc0:	f2 0b 13 00 	cpc	r11,r9
8000bbc4:	c0 80       	breq	8000bbd4 <__avr32_f64_cmp_eq+0x16>
8000bbc6:	a1 7b       	lsl	r11,0x1
8000bbc8:	a1 79       	lsl	r9,0x1
8000bbca:	14 4b       	or	r11,r10
8000bbcc:	12 4b       	or	r11,r9
8000bbce:	10 4b       	or	r11,r8
8000bbd0:	5e 0f       	reteq	1
8000bbd2:	5e fd       	retal	0
8000bbd4:	a1 7b       	lsl	r11,0x1
8000bbd6:	fc 1c ff e0 	movh	r12,0xffe0
8000bbda:	58 0a       	cp.w	r10,0
8000bbdc:	f8 0b 13 00 	cpc	r11,r12
8000bbe0:	5e 8f       	retls	1
8000bbe2:	5e fd       	retal	0

8000bbe4 <__avr32_f64_cmp_ge>:
8000bbe4:	1a de       	st.w	--sp,lr
8000bbe6:	1a d7       	st.w	--sp,r7
8000bbe8:	a1 7b       	lsl	r11,0x1
8000bbea:	5f 3c       	srlo	r12
8000bbec:	a1 79       	lsl	r9,0x1
8000bbee:	5f 37       	srlo	r7
8000bbf0:	5c fc       	rol	r12
8000bbf2:	fc 1e ff e0 	movh	lr,0xffe0
8000bbf6:	58 0a       	cp.w	r10,0
8000bbf8:	fc 0b 13 00 	cpc	r11,lr
8000bbfc:	e0 8b 00 1d 	brhi	8000bc36 <__avr32_f64_cmp_ge+0x52>
8000bc00:	58 08       	cp.w	r8,0
8000bc02:	fc 09 13 00 	cpc	r9,lr
8000bc06:	e0 8b 00 18 	brhi	8000bc36 <__avr32_f64_cmp_ge+0x52>
8000bc0a:	58 0b       	cp.w	r11,0
8000bc0c:	f5 ba 00 00 	subfeq	r10,0
8000bc10:	c1 50       	breq	8000bc3a <__avr32_f64_cmp_ge+0x56>
8000bc12:	1b 07       	ld.w	r7,sp++
8000bc14:	1b 0e       	ld.w	lr,sp++
8000bc16:	58 3c       	cp.w	r12,3
8000bc18:	c0 a0       	breq	8000bc2c <__avr32_f64_cmp_ge+0x48>
8000bc1a:	58 1c       	cp.w	r12,1
8000bc1c:	c0 33       	brcs	8000bc22 <__avr32_f64_cmp_ge+0x3e>
8000bc1e:	5e 0f       	reteq	1
8000bc20:	5e 1d       	retne	0
8000bc22:	10 3a       	cp.w	r10,r8
8000bc24:	f2 0b 13 00 	cpc	r11,r9
8000bc28:	5e 2f       	reths	1
8000bc2a:	5e 3d       	retlo	0
8000bc2c:	14 38       	cp.w	r8,r10
8000bc2e:	f6 09 13 00 	cpc	r9,r11
8000bc32:	5e 2f       	reths	1
8000bc34:	5e 3d       	retlo	0
8000bc36:	1b 07       	ld.w	r7,sp++
8000bc38:	d8 0a       	popm	pc,r12=0
8000bc3a:	58 17       	cp.w	r7,1
8000bc3c:	5f 0c       	sreq	r12
8000bc3e:	58 09       	cp.w	r9,0
8000bc40:	f5 b8 00 00 	subfeq	r8,0
8000bc44:	1b 07       	ld.w	r7,sp++
8000bc46:	1b 0e       	ld.w	lr,sp++
8000bc48:	5e 0f       	reteq	1
8000bc4a:	5e fc       	retal	r12

8000bc4c <__avr32_f64_cmp_lt>:
8000bc4c:	1a de       	st.w	--sp,lr
8000bc4e:	1a d7       	st.w	--sp,r7
8000bc50:	a1 7b       	lsl	r11,0x1
8000bc52:	5f 3c       	srlo	r12
8000bc54:	a1 79       	lsl	r9,0x1
8000bc56:	5f 37       	srlo	r7
8000bc58:	5c fc       	rol	r12
8000bc5a:	fc 1e ff e0 	movh	lr,0xffe0
8000bc5e:	58 0a       	cp.w	r10,0
8000bc60:	fc 0b 13 00 	cpc	r11,lr
8000bc64:	e0 8b 00 1d 	brhi	8000bc9e <__avr32_f64_cmp_lt+0x52>
8000bc68:	58 08       	cp.w	r8,0
8000bc6a:	fc 09 13 00 	cpc	r9,lr
8000bc6e:	e0 8b 00 18 	brhi	8000bc9e <__avr32_f64_cmp_lt+0x52>
8000bc72:	58 0b       	cp.w	r11,0
8000bc74:	f5 ba 00 00 	subfeq	r10,0
8000bc78:	c1 50       	breq	8000bca2 <__avr32_f64_cmp_lt+0x56>
8000bc7a:	1b 07       	ld.w	r7,sp++
8000bc7c:	1b 0e       	ld.w	lr,sp++
8000bc7e:	58 3c       	cp.w	r12,3
8000bc80:	c0 a0       	breq	8000bc94 <__avr32_f64_cmp_lt+0x48>
8000bc82:	58 1c       	cp.w	r12,1
8000bc84:	c0 33       	brcs	8000bc8a <__avr32_f64_cmp_lt+0x3e>
8000bc86:	5e 0d       	reteq	0
8000bc88:	5e 1f       	retne	1
8000bc8a:	10 3a       	cp.w	r10,r8
8000bc8c:	f2 0b 13 00 	cpc	r11,r9
8000bc90:	5e 2d       	reths	0
8000bc92:	5e 3f       	retlo	1
8000bc94:	14 38       	cp.w	r8,r10
8000bc96:	f6 09 13 00 	cpc	r9,r11
8000bc9a:	5e 2d       	reths	0
8000bc9c:	5e 3f       	retlo	1
8000bc9e:	1b 07       	ld.w	r7,sp++
8000bca0:	d8 0a       	popm	pc,r12=0
8000bca2:	58 17       	cp.w	r7,1
8000bca4:	5f 1c       	srne	r12
8000bca6:	58 09       	cp.w	r9,0
8000bca8:	f5 b8 00 00 	subfeq	r8,0
8000bcac:	1b 07       	ld.w	r7,sp++
8000bcae:	1b 0e       	ld.w	lr,sp++
8000bcb0:	5e 0d       	reteq	0
8000bcb2:	5e fc       	retal	r12

8000bcb4 <__avr32_f64_div>:
8000bcb4:	eb cd 40 ff 	pushm	r0-r7,lr
8000bcb8:	f7 e9 20 0e 	eor	lr,r11,r9
8000bcbc:	f6 07 16 14 	lsr	r7,r11,0x14
8000bcc0:	a9 7b       	lsl	r11,0x9
8000bcc2:	f7 ea 13 7b 	or	r11,r11,r10>>0x17
8000bcc6:	a9 7a       	lsl	r10,0x9
8000bcc8:	bd bb       	sbr	r11,0x1d
8000bcca:	e4 1b 3f ff 	andh	r11,0x3fff
8000bcce:	ab d7       	cbr	r7,0xb
8000bcd0:	e0 80 00 cc 	breq	8000be68 <__avr32_f64_div_round_subnormal+0x54>
8000bcd4:	e0 47 07 ff 	cp.w	r7,2047
8000bcd8:	e0 84 00 b5 	brge	8000be42 <__avr32_f64_div_round_subnormal+0x2e>
8000bcdc:	f2 06 16 14 	lsr	r6,r9,0x14
8000bce0:	a9 79       	lsl	r9,0x9
8000bce2:	f3 e8 13 79 	or	r9,r9,r8>>0x17
8000bce6:	a9 78       	lsl	r8,0x9
8000bce8:	bd b9       	sbr	r9,0x1d
8000bcea:	e4 19 3f ff 	andh	r9,0x3fff
8000bcee:	ab d6       	cbr	r6,0xb
8000bcf0:	e0 80 00 e2 	breq	8000beb4 <__avr32_f64_div_round_subnormal+0xa0>
8000bcf4:	e0 46 07 ff 	cp.w	r6,2047
8000bcf8:	e0 84 00 b2 	brge	8000be5c <__avr32_f64_div_round_subnormal+0x48>
8000bcfc:	0c 17       	sub	r7,r6
8000bcfe:	fe 37 fc 01 	sub	r7,-1023
8000bd02:	fc 1c 80 00 	movh	r12,0x8000
8000bd06:	f8 03 16 01 	lsr	r3,r12,0x1
8000bd0a:	e9 d9 c3 62 	bfextu	r4,r9,0x1b,0x2
8000bd0e:	5c d4       	com	r4
8000bd10:	e7 d4 d3 82 	bfins	r3,r4,0x1c,0x2
8000bd14:	e6 09 06 44 	mulu.d	r4,r3,r9
8000bd18:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000bd1c:	e6 05 06 44 	mulu.d	r4,r3,r5
8000bd20:	ea 03 15 02 	lsl	r3,r5,0x2
8000bd24:	e6 09 06 44 	mulu.d	r4,r3,r9
8000bd28:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000bd2c:	e6 05 06 44 	mulu.d	r4,r3,r5
8000bd30:	ea 03 15 02 	lsl	r3,r5,0x2
8000bd34:	e6 09 06 44 	mulu.d	r4,r3,r9
8000bd38:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000bd3c:	e6 05 06 44 	mulu.d	r4,r3,r5
8000bd40:	ea 03 15 02 	lsl	r3,r5,0x2
8000bd44:	e6 08 06 40 	mulu.d	r0,r3,r8
8000bd48:	e4 09 07 40 	macu.d	r0,r2,r9
8000bd4c:	e6 09 06 44 	mulu.d	r4,r3,r9
8000bd50:	02 04       	add	r4,r1
8000bd52:	5c 05       	acr	r5
8000bd54:	a3 65       	lsl	r5,0x2
8000bd56:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000bd5a:	a3 64       	lsl	r4,0x2
8000bd5c:	5c 34       	neg	r4
8000bd5e:	f8 05 01 45 	sbc	r5,r12,r5
8000bd62:	e6 04 06 40 	mulu.d	r0,r3,r4
8000bd66:	e4 05 07 40 	macu.d	r0,r2,r5
8000bd6a:	e6 05 06 44 	mulu.d	r4,r3,r5
8000bd6e:	02 04       	add	r4,r1
8000bd70:	5c 05       	acr	r5
8000bd72:	ea 03 15 02 	lsl	r3,r5,0x2
8000bd76:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000bd7a:	e8 02 15 02 	lsl	r2,r4,0x2
8000bd7e:	e6 08 06 40 	mulu.d	r0,r3,r8
8000bd82:	e4 09 07 40 	macu.d	r0,r2,r9
8000bd86:	e6 09 06 44 	mulu.d	r4,r3,r9
8000bd8a:	02 04       	add	r4,r1
8000bd8c:	5c 05       	acr	r5
8000bd8e:	a3 65       	lsl	r5,0x2
8000bd90:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000bd94:	a3 64       	lsl	r4,0x2
8000bd96:	5c 34       	neg	r4
8000bd98:	f8 05 01 45 	sbc	r5,r12,r5
8000bd9c:	e6 04 06 40 	mulu.d	r0,r3,r4
8000bda0:	e4 05 07 40 	macu.d	r0,r2,r5
8000bda4:	e6 05 06 44 	mulu.d	r4,r3,r5
8000bda8:	02 04       	add	r4,r1
8000bdaa:	5c 05       	acr	r5
8000bdac:	ea 03 15 02 	lsl	r3,r5,0x2
8000bdb0:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000bdb4:	e8 02 15 02 	lsl	r2,r4,0x2
8000bdb8:	e6 0a 06 40 	mulu.d	r0,r3,r10
8000bdbc:	e4 0b 07 40 	macu.d	r0,r2,r11
8000bdc0:	e6 0b 06 42 	mulu.d	r2,r3,r11
8000bdc4:	02 02       	add	r2,r1
8000bdc6:	5c 03       	acr	r3
8000bdc8:	ed b3 00 1c 	bld	r3,0x1c
8000bdcc:	c0 90       	breq	8000bdde <__avr32_f64_div+0x12a>
8000bdce:	a1 72       	lsl	r2,0x1
8000bdd0:	5c f3       	rol	r3
8000bdd2:	20 17       	sub	r7,1
8000bdd4:	a3 9a       	lsr	r10,0x3
8000bdd6:	f5 eb 11 da 	or	r10,r10,r11<<0x1d
8000bdda:	a3 9b       	lsr	r11,0x3
8000bddc:	c0 58       	rjmp	8000bde6 <__avr32_f64_div+0x132>
8000bdde:	a5 8a       	lsr	r10,0x4
8000bde0:	f5 eb 11 ca 	or	r10,r10,r11<<0x1c
8000bde4:	a5 8b       	lsr	r11,0x4
8000bde6:	58 07       	cp.w	r7,0
8000bde8:	e0 8a 00 8b 	brle	8000befe <__avr32_f64_div_res_subnormal>
8000bdec:	e0 12 ff 00 	andl	r2,0xff00
8000bdf0:	e8 12 00 80 	orl	r2,0x80
8000bdf4:	e6 08 06 40 	mulu.d	r0,r3,r8
8000bdf8:	e4 09 07 40 	macu.d	r0,r2,r9
8000bdfc:	e4 08 06 44 	mulu.d	r4,r2,r8
8000be00:	e6 09 06 48 	mulu.d	r8,r3,r9
8000be04:	00 05       	add	r5,r0
8000be06:	f0 01 00 48 	adc	r8,r8,r1
8000be0a:	5c 09       	acr	r9
8000be0c:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000be10:	58 04       	cp.w	r4,0
8000be12:	5c 25       	cpc	r5

8000be14 <__avr32_f64_div_round_subnormal>:
8000be14:	f4 08 13 00 	cpc	r8,r10
8000be18:	f6 09 13 00 	cpc	r9,r11
8000be1c:	5f 36       	srlo	r6
8000be1e:	f8 06 17 00 	moveq	r6,r12
8000be22:	e4 0a 16 08 	lsr	r10,r2,0x8
8000be26:	f5 e3 11 8a 	or	r10,r10,r3<<0x18
8000be2a:	e6 0b 16 08 	lsr	r11,r3,0x8
8000be2e:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000be32:	ed be 00 1f 	bld	lr,0x1f
8000be36:	ef bb 00 1f 	bst	r11,0x1f
8000be3a:	0c 0a       	add	r10,r6
8000be3c:	5c 0b       	acr	r11
8000be3e:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000be42:	e4 1b 00 0f 	andh	r11,0xf
8000be46:	14 4b       	or	r11,r10
8000be48:	e0 81 00 a7 	brne	8000bf96 <__avr32_f64_div_res_subnormal+0x98>
8000be4c:	f2 06 16 14 	lsr	r6,r9,0x14
8000be50:	ab d6       	cbr	r6,0xb
8000be52:	e0 46 07 ff 	cp.w	r6,2047
8000be56:	e0 81 00 a4 	brne	8000bf9e <__avr32_f64_div_res_subnormal+0xa0>
8000be5a:	c9 e8       	rjmp	8000bf96 <__avr32_f64_div_res_subnormal+0x98>
8000be5c:	e4 19 00 0f 	andh	r9,0xf
8000be60:	10 49       	or	r9,r8
8000be62:	e0 81 00 9a 	brne	8000bf96 <__avr32_f64_div_res_subnormal+0x98>
8000be66:	c9 28       	rjmp	8000bf8a <__avr32_f64_div_res_subnormal+0x8c>
8000be68:	a3 7b       	lsl	r11,0x3
8000be6a:	f7 ea 13 db 	or	r11,r11,r10>>0x1d
8000be6e:	a3 7a       	lsl	r10,0x3
8000be70:	f5 eb 10 04 	or	r4,r10,r11
8000be74:	e0 80 00 a0 	breq	8000bfb4 <__avr32_f64_div_op1_zero>
8000be78:	f6 04 12 00 	clz	r4,r11
8000be7c:	c1 70       	breq	8000beaa <__avr32_f64_div_round_subnormal+0x96>
8000be7e:	c0 c3       	brcs	8000be96 <__avr32_f64_div_round_subnormal+0x82>
8000be80:	e8 05 11 20 	rsub	r5,r4,32
8000be84:	f6 04 09 4b 	lsl	r11,r11,r4
8000be88:	f4 05 0a 45 	lsr	r5,r10,r5
8000be8c:	0a 4b       	or	r11,r5
8000be8e:	f4 04 09 4a 	lsl	r10,r10,r4
8000be92:	08 17       	sub	r7,r4
8000be94:	c0 b8       	rjmp	8000beaa <__avr32_f64_div_round_subnormal+0x96>
8000be96:	f4 04 12 00 	clz	r4,r10
8000be9a:	f9 b4 03 00 	movlo	r4,0
8000be9e:	f7 b4 02 e0 	subhs	r4,-32
8000bea2:	f4 04 09 4b 	lsl	r11,r10,r4
8000bea6:	30 0a       	mov	r10,0
8000bea8:	08 17       	sub	r7,r4
8000beaa:	a3 8a       	lsr	r10,0x2
8000beac:	f5 eb 11 ea 	or	r10,r10,r11<<0x1e
8000beb0:	a3 8b       	lsr	r11,0x2
8000beb2:	c1 1b       	rjmp	8000bcd4 <__avr32_f64_div+0x20>
8000beb4:	a3 79       	lsl	r9,0x3
8000beb6:	f3 e8 13 d9 	or	r9,r9,r8>>0x1d
8000beba:	a3 78       	lsl	r8,0x3
8000bebc:	f3 e8 10 04 	or	r4,r9,r8
8000bec0:	c6 f0       	breq	8000bf9e <__avr32_f64_div_res_subnormal+0xa0>
8000bec2:	f2 04 12 00 	clz	r4,r9
8000bec6:	c1 70       	breq	8000bef4 <__avr32_f64_div_round_subnormal+0xe0>
8000bec8:	c0 c3       	brcs	8000bee0 <__avr32_f64_div_round_subnormal+0xcc>
8000beca:	e8 05 11 20 	rsub	r5,r4,32
8000bece:	f2 04 09 49 	lsl	r9,r9,r4
8000bed2:	f0 05 0a 45 	lsr	r5,r8,r5
8000bed6:	0a 49       	or	r9,r5
8000bed8:	f0 04 09 48 	lsl	r8,r8,r4
8000bedc:	08 16       	sub	r6,r4
8000bede:	c0 b8       	rjmp	8000bef4 <__avr32_f64_div_round_subnormal+0xe0>
8000bee0:	f0 04 12 00 	clz	r4,r8
8000bee4:	f9 b4 03 00 	movlo	r4,0
8000bee8:	f7 b4 02 e0 	subhs	r4,-32
8000beec:	f0 04 09 49 	lsl	r9,r8,r4
8000bef0:	30 08       	mov	r8,0
8000bef2:	08 16       	sub	r6,r4
8000bef4:	a3 88       	lsr	r8,0x2
8000bef6:	f1 e9 11 e8 	or	r8,r8,r9<<0x1e
8000befa:	a3 89       	lsr	r9,0x2
8000befc:	cf ca       	rjmp	8000bcf4 <__avr32_f64_div+0x40>

8000befe <__avr32_f64_div_res_subnormal>:
8000befe:	5c 37       	neg	r7
8000bf00:	2f f7       	sub	r7,-1
8000bf02:	f1 b7 04 c0 	satu	r7,0x6
8000bf06:	e0 47 00 20 	cp.w	r7,32
8000bf0a:	c1 54       	brge	8000bf34 <__avr32_f64_div_res_subnormal+0x36>
8000bf0c:	ee 06 11 20 	rsub	r6,r7,32
8000bf10:	e4 07 0a 42 	lsr	r2,r2,r7
8000bf14:	e6 06 09 4c 	lsl	r12,r3,r6
8000bf18:	18 42       	or	r2,r12
8000bf1a:	e6 07 0a 43 	lsr	r3,r3,r7
8000bf1e:	f4 06 09 41 	lsl	r1,r10,r6
8000bf22:	f4 07 0a 4a 	lsr	r10,r10,r7
8000bf26:	f6 06 09 4c 	lsl	r12,r11,r6
8000bf2a:	18 4a       	or	r10,r12
8000bf2c:	f6 07 0a 4b 	lsr	r11,r11,r7
8000bf30:	30 00       	mov	r0,0
8000bf32:	c1 58       	rjmp	8000bf5c <__avr32_f64_div_res_subnormal+0x5e>
8000bf34:	ee 06 11 20 	rsub	r6,r7,32
8000bf38:	f9 b0 00 00 	moveq	r0,0
8000bf3c:	f9 bc 00 00 	moveq	r12,0
8000bf40:	c0 50       	breq	8000bf4a <__avr32_f64_div_res_subnormal+0x4c>
8000bf42:	f4 06 09 40 	lsl	r0,r10,r6
8000bf46:	f6 06 09 4c 	lsl	r12,r11,r6
8000bf4a:	e6 07 0a 42 	lsr	r2,r3,r7
8000bf4e:	30 03       	mov	r3,0
8000bf50:	f4 07 0a 41 	lsr	r1,r10,r7
8000bf54:	18 41       	or	r1,r12
8000bf56:	f6 07 0a 4a 	lsr	r10,r11,r7
8000bf5a:	30 0b       	mov	r11,0
8000bf5c:	e0 12 ff 00 	andl	r2,0xff00
8000bf60:	e8 12 00 80 	orl	r2,0x80
8000bf64:	e6 08 06 46 	mulu.d	r6,r3,r8
8000bf68:	e4 09 07 46 	macu.d	r6,r2,r9
8000bf6c:	e4 08 06 44 	mulu.d	r4,r2,r8
8000bf70:	e6 09 06 48 	mulu.d	r8,r3,r9
8000bf74:	0c 05       	add	r5,r6
8000bf76:	f0 07 00 48 	adc	r8,r8,r7
8000bf7a:	5c 09       	acr	r9
8000bf7c:	30 07       	mov	r7,0
8000bf7e:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000bf82:	00 34       	cp.w	r4,r0
8000bf84:	e2 05 13 00 	cpc	r5,r1
8000bf88:	c4 6b       	rjmp	8000be14 <__avr32_f64_div_round_subnormal>
8000bf8a:	1c 9b       	mov	r11,lr
8000bf8c:	e6 1b 80 00 	andh	r11,0x8000,COH
8000bf90:	30 0a       	mov	r10,0
8000bf92:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000bf96:	3f fb       	mov	r11,-1
8000bf98:	30 0a       	mov	r10,0
8000bf9a:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000bf9e:	f5 eb 10 04 	or	r4,r10,r11
8000bfa2:	c0 90       	breq	8000bfb4 <__avr32_f64_div_op1_zero>
8000bfa4:	1c 9b       	mov	r11,lr
8000bfa6:	e6 1b 80 00 	andh	r11,0x8000,COH
8000bfaa:	ea 1b 7f f0 	orh	r11,0x7ff0
8000bfae:	30 0a       	mov	r10,0
8000bfb0:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc

8000bfb4 <__avr32_f64_div_op1_zero>:
8000bfb4:	f1 e9 10 15 	or	r5,r8,r9<<0x1
8000bfb8:	ce f0       	breq	8000bf96 <__avr32_f64_div_res_subnormal+0x98>
8000bfba:	e9 d9 c2 8b 	bfextu	r4,r9,0x14,0xb
8000bfbe:	e0 44 07 ff 	cp.w	r4,2047
8000bfc2:	ce 41       	brne	8000bf8a <__avr32_f64_div_res_subnormal+0x8c>
8000bfc4:	f1 e9 10 c5 	or	r5,r8,r9<<0xc
8000bfc8:	ce 10       	breq	8000bf8a <__avr32_f64_div_res_subnormal+0x8c>
8000bfca:	ce 6b       	rjmp	8000bf96 <__avr32_f64_div_res_subnormal+0x98>

8000bfcc <__avr32_udiv64>:
8000bfcc:	d4 31       	pushm	r0-r7,lr
8000bfce:	1a 97       	mov	r7,sp
8000bfd0:	20 3d       	sub	sp,12
8000bfd2:	10 9c       	mov	r12,r8
8000bfd4:	12 9e       	mov	lr,r9
8000bfd6:	14 93       	mov	r3,r10
8000bfd8:	58 09       	cp.w	r9,0
8000bfda:	e0 81 00 bd 	brne	8000c154 <__avr32_udiv64+0x188>
8000bfde:	16 38       	cp.w	r8,r11
8000bfe0:	e0 88 00 40 	brls	8000c060 <__avr32_udiv64+0x94>
8000bfe4:	f0 08 12 00 	clz	r8,r8
8000bfe8:	c0 d0       	breq	8000c002 <__avr32_udiv64+0x36>
8000bfea:	f6 08 09 4b 	lsl	r11,r11,r8
8000bfee:	f0 09 11 20 	rsub	r9,r8,32
8000bff2:	f8 08 09 4c 	lsl	r12,r12,r8
8000bff6:	f4 09 0a 49 	lsr	r9,r10,r9
8000bffa:	f4 08 09 43 	lsl	r3,r10,r8
8000bffe:	f3 eb 10 0b 	or	r11,r9,r11
8000c002:	f8 0e 16 10 	lsr	lr,r12,0x10
8000c006:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000c00a:	f6 0e 0d 00 	divu	r0,r11,lr
8000c00e:	e6 0b 16 10 	lsr	r11,r3,0x10
8000c012:	00 99       	mov	r9,r0
8000c014:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c018:	e0 0a 02 48 	mul	r8,r0,r10
8000c01c:	10 3b       	cp.w	r11,r8
8000c01e:	c0 a2       	brcc	8000c032 <__avr32_udiv64+0x66>
8000c020:	20 19       	sub	r9,1
8000c022:	18 0b       	add	r11,r12
8000c024:	18 3b       	cp.w	r11,r12
8000c026:	c0 63       	brcs	8000c032 <__avr32_udiv64+0x66>
8000c028:	10 3b       	cp.w	r11,r8
8000c02a:	f7 b9 03 01 	sublo	r9,1
8000c02e:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c032:	f6 08 01 01 	sub	r1,r11,r8
8000c036:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000c03a:	e2 0e 0d 00 	divu	r0,r1,lr
8000c03e:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000c042:	00 98       	mov	r8,r0
8000c044:	e0 0a 02 4a 	mul	r10,r0,r10
8000c048:	14 33       	cp.w	r3,r10
8000c04a:	c0 82       	brcc	8000c05a <__avr32_udiv64+0x8e>
8000c04c:	20 18       	sub	r8,1
8000c04e:	18 03       	add	r3,r12
8000c050:	18 33       	cp.w	r3,r12
8000c052:	c0 43       	brcs	8000c05a <__avr32_udiv64+0x8e>
8000c054:	14 33       	cp.w	r3,r10
8000c056:	f7 b8 03 01 	sublo	r8,1
8000c05a:	f1 e9 11 08 	or	r8,r8,r9<<0x10
8000c05e:	cd f8       	rjmp	8000c21c <__avr32_udiv64+0x250>
8000c060:	58 08       	cp.w	r8,0
8000c062:	c0 51       	brne	8000c06c <__avr32_udiv64+0xa0>
8000c064:	30 19       	mov	r9,1
8000c066:	f2 08 0d 08 	divu	r8,r9,r8
8000c06a:	10 9c       	mov	r12,r8
8000c06c:	f8 06 12 00 	clz	r6,r12
8000c070:	c0 41       	brne	8000c078 <__avr32_udiv64+0xac>
8000c072:	18 1b       	sub	r11,r12
8000c074:	30 19       	mov	r9,1
8000c076:	c4 08       	rjmp	8000c0f6 <__avr32_udiv64+0x12a>
8000c078:	ec 01 11 20 	rsub	r1,r6,32
8000c07c:	f4 01 0a 49 	lsr	r9,r10,r1
8000c080:	f8 06 09 4c 	lsl	r12,r12,r6
8000c084:	f6 06 09 48 	lsl	r8,r11,r6
8000c088:	f6 01 0a 41 	lsr	r1,r11,r1
8000c08c:	f3 e8 10 08 	or	r8,r9,r8
8000c090:	f8 03 16 10 	lsr	r3,r12,0x10
8000c094:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000c098:	e2 03 0d 00 	divu	r0,r1,r3
8000c09c:	f0 0b 16 10 	lsr	r11,r8,0x10
8000c0a0:	00 9e       	mov	lr,r0
8000c0a2:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c0a6:	e0 05 02 49 	mul	r9,r0,r5
8000c0aa:	12 3b       	cp.w	r11,r9
8000c0ac:	c0 a2       	brcc	8000c0c0 <__avr32_udiv64+0xf4>
8000c0ae:	20 1e       	sub	lr,1
8000c0b0:	18 0b       	add	r11,r12
8000c0b2:	18 3b       	cp.w	r11,r12
8000c0b4:	c0 63       	brcs	8000c0c0 <__avr32_udiv64+0xf4>
8000c0b6:	12 3b       	cp.w	r11,r9
8000c0b8:	f7 be 03 01 	sublo	lr,1
8000c0bc:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c0c0:	12 1b       	sub	r11,r9
8000c0c2:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
8000c0c6:	f6 03 0d 02 	divu	r2,r11,r3
8000c0ca:	f1 e3 11 08 	or	r8,r8,r3<<0x10
8000c0ce:	04 99       	mov	r9,r2
8000c0d0:	e4 05 02 4b 	mul	r11,r2,r5
8000c0d4:	16 38       	cp.w	r8,r11
8000c0d6:	c0 a2       	brcc	8000c0ea <__avr32_udiv64+0x11e>
8000c0d8:	20 19       	sub	r9,1
8000c0da:	18 08       	add	r8,r12
8000c0dc:	18 38       	cp.w	r8,r12
8000c0de:	c0 63       	brcs	8000c0ea <__avr32_udiv64+0x11e>
8000c0e0:	16 38       	cp.w	r8,r11
8000c0e2:	f7 b9 03 01 	sublo	r9,1
8000c0e6:	f1 dc e3 08 	addcs	r8,r8,r12
8000c0ea:	f4 06 09 43 	lsl	r3,r10,r6
8000c0ee:	f0 0b 01 0b 	sub	r11,r8,r11
8000c0f2:	f3 ee 11 09 	or	r9,r9,lr<<0x10
8000c0f6:	f8 06 16 10 	lsr	r6,r12,0x10
8000c0fa:	fd dc c0 10 	bfextu	lr,r12,0x0,0x10
8000c0fe:	f6 06 0d 00 	divu	r0,r11,r6
8000c102:	e6 0b 16 10 	lsr	r11,r3,0x10
8000c106:	00 9a       	mov	r10,r0
8000c108:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c10c:	e0 0e 02 48 	mul	r8,r0,lr
8000c110:	10 3b       	cp.w	r11,r8
8000c112:	c0 a2       	brcc	8000c126 <__avr32_udiv64+0x15a>
8000c114:	20 1a       	sub	r10,1
8000c116:	18 0b       	add	r11,r12
8000c118:	18 3b       	cp.w	r11,r12
8000c11a:	c0 63       	brcs	8000c126 <__avr32_udiv64+0x15a>
8000c11c:	10 3b       	cp.w	r11,r8
8000c11e:	f7 ba 03 01 	sublo	r10,1
8000c122:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c126:	f6 08 01 01 	sub	r1,r11,r8
8000c12a:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000c12e:	e2 06 0d 00 	divu	r0,r1,r6
8000c132:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000c136:	00 98       	mov	r8,r0
8000c138:	e0 0e 02 4b 	mul	r11,r0,lr
8000c13c:	16 33       	cp.w	r3,r11
8000c13e:	c0 82       	brcc	8000c14e <__avr32_udiv64+0x182>
8000c140:	20 18       	sub	r8,1
8000c142:	18 03       	add	r3,r12
8000c144:	18 33       	cp.w	r3,r12
8000c146:	c0 43       	brcs	8000c14e <__avr32_udiv64+0x182>
8000c148:	16 33       	cp.w	r3,r11
8000c14a:	f7 b8 03 01 	sublo	r8,1
8000c14e:	f1 ea 11 08 	or	r8,r8,r10<<0x10
8000c152:	c6 98       	rjmp	8000c224 <__avr32_udiv64+0x258>
8000c154:	16 39       	cp.w	r9,r11
8000c156:	e0 8b 00 65 	brhi	8000c220 <__avr32_udiv64+0x254>
8000c15a:	f2 09 12 00 	clz	r9,r9
8000c15e:	c0 b1       	brne	8000c174 <__avr32_udiv64+0x1a8>
8000c160:	10 3a       	cp.w	r10,r8
8000c162:	5f 2a       	srhs	r10
8000c164:	1c 3b       	cp.w	r11,lr
8000c166:	5f b8       	srhi	r8
8000c168:	10 4a       	or	r10,r8
8000c16a:	f2 0a 18 00 	cp.b	r10,r9
8000c16e:	c5 90       	breq	8000c220 <__avr32_udiv64+0x254>
8000c170:	30 18       	mov	r8,1
8000c172:	c5 98       	rjmp	8000c224 <__avr32_udiv64+0x258>
8000c174:	f0 09 09 46 	lsl	r6,r8,r9
8000c178:	f2 03 11 20 	rsub	r3,r9,32
8000c17c:	fc 09 09 4e 	lsl	lr,lr,r9
8000c180:	f0 03 0a 48 	lsr	r8,r8,r3
8000c184:	f6 09 09 4c 	lsl	r12,r11,r9
8000c188:	f4 03 0a 42 	lsr	r2,r10,r3
8000c18c:	ef 46 ff f4 	st.w	r7[-12],r6
8000c190:	f6 03 0a 43 	lsr	r3,r11,r3
8000c194:	18 42       	or	r2,r12
8000c196:	f1 ee 10 0c 	or	r12,r8,lr
8000c19a:	f8 01 16 10 	lsr	r1,r12,0x10
8000c19e:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000c1a2:	e6 01 0d 04 	divu	r4,r3,r1
8000c1a6:	e4 03 16 10 	lsr	r3,r2,0x10
8000c1aa:	08 9e       	mov	lr,r4
8000c1ac:	e7 e5 11 03 	or	r3,r3,r5<<0x10
8000c1b0:	e8 06 02 48 	mul	r8,r4,r6
8000c1b4:	10 33       	cp.w	r3,r8
8000c1b6:	c0 a2       	brcc	8000c1ca <__avr32_udiv64+0x1fe>
8000c1b8:	20 1e       	sub	lr,1
8000c1ba:	18 03       	add	r3,r12
8000c1bc:	18 33       	cp.w	r3,r12
8000c1be:	c0 63       	brcs	8000c1ca <__avr32_udiv64+0x1fe>
8000c1c0:	10 33       	cp.w	r3,r8
8000c1c2:	f7 be 03 01 	sublo	lr,1
8000c1c6:	e7 dc e3 03 	addcs	r3,r3,r12
8000c1ca:	10 13       	sub	r3,r8
8000c1cc:	f7 d2 c0 10 	bfextu	r11,r2,0x0,0x10
8000c1d0:	e6 01 0d 00 	divu	r0,r3,r1
8000c1d4:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c1d8:	00 98       	mov	r8,r0
8000c1da:	e0 06 02 46 	mul	r6,r0,r6
8000c1de:	0c 3b       	cp.w	r11,r6
8000c1e0:	c0 a2       	brcc	8000c1f4 <__avr32_udiv64+0x228>
8000c1e2:	20 18       	sub	r8,1
8000c1e4:	18 0b       	add	r11,r12
8000c1e6:	18 3b       	cp.w	r11,r12
8000c1e8:	c0 63       	brcs	8000c1f4 <__avr32_udiv64+0x228>
8000c1ea:	0c 3b       	cp.w	r11,r6
8000c1ec:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c1f0:	f7 b8 03 01 	sublo	r8,1
8000c1f4:	f1 ee 11 08 	or	r8,r8,lr<<0x10
8000c1f8:	ee f4 ff f4 	ld.w	r4,r7[-12]
8000c1fc:	0c 1b       	sub	r11,r6
8000c1fe:	f0 04 06 42 	mulu.d	r2,r8,r4
8000c202:	06 95       	mov	r5,r3
8000c204:	16 35       	cp.w	r5,r11
8000c206:	e0 8b 00 0a 	brhi	8000c21a <__avr32_udiv64+0x24e>
8000c20a:	5f 0b       	sreq	r11
8000c20c:	f4 09 09 49 	lsl	r9,r10,r9
8000c210:	12 32       	cp.w	r2,r9
8000c212:	5f b9       	srhi	r9
8000c214:	f7 e9 00 09 	and	r9,r11,r9
8000c218:	c0 60       	breq	8000c224 <__avr32_udiv64+0x258>
8000c21a:	20 18       	sub	r8,1
8000c21c:	30 09       	mov	r9,0
8000c21e:	c0 38       	rjmp	8000c224 <__avr32_udiv64+0x258>
8000c220:	30 09       	mov	r9,0
8000c222:	12 98       	mov	r8,r9
8000c224:	10 9a       	mov	r10,r8
8000c226:	12 93       	mov	r3,r9
8000c228:	10 92       	mov	r2,r8
8000c22a:	12 9b       	mov	r11,r9
8000c22c:	2f dd       	sub	sp,-12
8000c22e:	d8 32       	popm	r0-r7,pc

8000c230 <__avr32_umod64>:
8000c230:	d4 31       	pushm	r0-r7,lr
8000c232:	1a 97       	mov	r7,sp
8000c234:	20 3d       	sub	sp,12
8000c236:	10 9c       	mov	r12,r8
8000c238:	12 95       	mov	r5,r9
8000c23a:	14 9e       	mov	lr,r10
8000c23c:	16 91       	mov	r1,r11
8000c23e:	16 96       	mov	r6,r11
8000c240:	58 09       	cp.w	r9,0
8000c242:	e0 81 00 81 	brne	8000c344 <__avr32_umod64+0x114>
8000c246:	16 38       	cp.w	r8,r11
8000c248:	e0 88 00 12 	brls	8000c26c <__avr32_umod64+0x3c>
8000c24c:	f0 08 12 00 	clz	r8,r8
8000c250:	c4 e0       	breq	8000c2ec <__avr32_umod64+0xbc>
8000c252:	f6 08 09 46 	lsl	r6,r11,r8
8000c256:	f8 08 09 4c 	lsl	r12,r12,r8
8000c25a:	f0 0b 11 20 	rsub	r11,r8,32
8000c25e:	f4 08 09 4e 	lsl	lr,r10,r8
8000c262:	f4 0b 0a 4b 	lsr	r11,r10,r11
8000c266:	f7 e6 10 06 	or	r6,r11,r6
8000c26a:	c4 18       	rjmp	8000c2ec <__avr32_umod64+0xbc>
8000c26c:	58 08       	cp.w	r8,0
8000c26e:	c0 51       	brne	8000c278 <__avr32_umod64+0x48>
8000c270:	30 19       	mov	r9,1
8000c272:	f2 08 0d 08 	divu	r8,r9,r8
8000c276:	10 9c       	mov	r12,r8
8000c278:	f8 08 12 00 	clz	r8,r12
8000c27c:	c0 31       	brne	8000c282 <__avr32_umod64+0x52>
8000c27e:	18 16       	sub	r6,r12
8000c280:	c3 68       	rjmp	8000c2ec <__avr32_umod64+0xbc>
8000c282:	f0 03 11 20 	rsub	r3,r8,32
8000c286:	f4 03 0a 4b 	lsr	r11,r10,r3
8000c28a:	f8 08 09 4c 	lsl	r12,r12,r8
8000c28e:	ec 08 09 49 	lsl	r9,r6,r8
8000c292:	ec 03 0a 43 	lsr	r3,r6,r3
8000c296:	f7 e9 10 09 	or	r9,r11,r9
8000c29a:	f8 05 16 10 	lsr	r5,r12,0x10
8000c29e:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000c2a2:	e6 05 0d 02 	divu	r2,r3,r5
8000c2a6:	f2 0e 16 10 	lsr	lr,r9,0x10
8000c2aa:	ec 02 02 4b 	mul	r11,r6,r2
8000c2ae:	fd e3 11 0e 	or	lr,lr,r3<<0x10
8000c2b2:	16 3e       	cp.w	lr,r11
8000c2b4:	c0 72       	brcc	8000c2c2 <__avr32_umod64+0x92>
8000c2b6:	18 0e       	add	lr,r12
8000c2b8:	18 3e       	cp.w	lr,r12
8000c2ba:	c0 43       	brcs	8000c2c2 <__avr32_umod64+0x92>
8000c2bc:	16 3e       	cp.w	lr,r11
8000c2be:	fd dc e3 0e 	addcs	lr,lr,r12
8000c2c2:	fc 0b 01 03 	sub	r3,lr,r11
8000c2c6:	f3 d9 c0 10 	bfextu	r9,r9,0x0,0x10
8000c2ca:	e6 05 0d 02 	divu	r2,r3,r5
8000c2ce:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000c2d2:	a5 36       	mul	r6,r2
8000c2d4:	0c 39       	cp.w	r9,r6
8000c2d6:	c0 72       	brcc	8000c2e4 <__avr32_umod64+0xb4>
8000c2d8:	18 09       	add	r9,r12
8000c2da:	18 39       	cp.w	r9,r12
8000c2dc:	c0 43       	brcs	8000c2e4 <__avr32_umod64+0xb4>
8000c2de:	0c 39       	cp.w	r9,r6
8000c2e0:	f3 dc e3 09 	addcs	r9,r9,r12
8000c2e4:	f2 06 01 06 	sub	r6,r9,r6
8000c2e8:	f4 08 09 4e 	lsl	lr,r10,r8
8000c2ec:	f8 0a 16 10 	lsr	r10,r12,0x10
8000c2f0:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000c2f4:	ec 0a 0d 02 	divu	r2,r6,r10
8000c2f8:	fc 09 16 10 	lsr	r9,lr,0x10
8000c2fc:	ea 02 02 4b 	mul	r11,r5,r2
8000c300:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000c304:	16 39       	cp.w	r9,r11
8000c306:	c0 72       	brcc	8000c314 <__avr32_umod64+0xe4>
8000c308:	18 09       	add	r9,r12
8000c30a:	18 39       	cp.w	r9,r12
8000c30c:	c0 43       	brcs	8000c314 <__avr32_umod64+0xe4>
8000c30e:	16 39       	cp.w	r9,r11
8000c310:	f3 dc e3 09 	addcs	r9,r9,r12
8000c314:	f2 0b 01 0b 	sub	r11,r9,r11
8000c318:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000c31c:	f6 0a 0d 0a 	divu	r10,r11,r10
8000c320:	fd eb 11 0e 	or	lr,lr,r11<<0x10
8000c324:	ea 0a 02 4a 	mul	r10,r5,r10
8000c328:	14 3e       	cp.w	lr,r10
8000c32a:	c0 72       	brcc	8000c338 <__avr32_umod64+0x108>
8000c32c:	18 0e       	add	lr,r12
8000c32e:	18 3e       	cp.w	lr,r12
8000c330:	c0 43       	brcs	8000c338 <__avr32_umod64+0x108>
8000c332:	14 3e       	cp.w	lr,r10
8000c334:	fd dc e3 0e 	addcs	lr,lr,r12
8000c338:	fc 0a 01 0a 	sub	r10,lr,r10
8000c33c:	30 0b       	mov	r11,0
8000c33e:	f4 08 0a 4a 	lsr	r10,r10,r8
8000c342:	c7 b8       	rjmp	8000c438 <__avr32_umod64+0x208>
8000c344:	16 39       	cp.w	r9,r11
8000c346:	e0 8b 00 79 	brhi	8000c438 <__avr32_umod64+0x208>
8000c34a:	f2 09 12 00 	clz	r9,r9
8000c34e:	c1 21       	brne	8000c372 <__avr32_umod64+0x142>
8000c350:	10 3a       	cp.w	r10,r8
8000c352:	5f 2b       	srhs	r11
8000c354:	0a 31       	cp.w	r1,r5
8000c356:	5f ba       	srhi	r10
8000c358:	f7 ea 10 0a 	or	r10,r11,r10
8000c35c:	f2 0a 18 00 	cp.b	r10,r9
8000c360:	c0 60       	breq	8000c36c <__avr32_umod64+0x13c>
8000c362:	fc 08 01 0c 	sub	r12,lr,r8
8000c366:	e2 05 01 46 	sbc	r6,r1,r5
8000c36a:	18 9e       	mov	lr,r12
8000c36c:	0c 9b       	mov	r11,r6
8000c36e:	1c 9a       	mov	r10,lr
8000c370:	c6 48       	rjmp	8000c438 <__avr32_umod64+0x208>
8000c372:	ea 09 09 4c 	lsl	r12,r5,r9
8000c376:	f2 06 11 20 	rsub	r6,r9,32
8000c37a:	f6 09 09 4b 	lsl	r11,r11,r9
8000c37e:	f0 09 09 42 	lsl	r2,r8,r9
8000c382:	ef 46 ff f4 	st.w	r7[-12],r6
8000c386:	f0 06 0a 48 	lsr	r8,r8,r6
8000c38a:	18 48       	or	r8,r12
8000c38c:	e2 06 0a 4c 	lsr	r12,r1,r6
8000c390:	f4 09 09 43 	lsl	r3,r10,r9
8000c394:	fd d8 c0 10 	bfextu	lr,r8,0x0,0x10
8000c398:	f4 06 0a 4a 	lsr	r10,r10,r6
8000c39c:	16 4a       	or	r10,r11
8000c39e:	f0 0b 16 10 	lsr	r11,r8,0x10
8000c3a2:	f8 0b 0d 04 	divu	r4,r12,r11
8000c3a6:	f4 0c 16 10 	lsr	r12,r10,0x10
8000c3aa:	08 91       	mov	r1,r4
8000c3ac:	f9 e5 11 0c 	or	r12,r12,r5<<0x10
8000c3b0:	e8 0e 02 46 	mul	r6,r4,lr
8000c3b4:	0c 3c       	cp.w	r12,r6
8000c3b6:	c0 a2       	brcc	8000c3ca <__avr32_umod64+0x19a>
8000c3b8:	20 11       	sub	r1,1
8000c3ba:	10 0c       	add	r12,r8
8000c3bc:	10 3c       	cp.w	r12,r8
8000c3be:	c0 63       	brcs	8000c3ca <__avr32_umod64+0x19a>
8000c3c0:	0c 3c       	cp.w	r12,r6
8000c3c2:	f7 b1 03 01 	sublo	r1,1
8000c3c6:	f9 d8 e3 0c 	addcs	r12,r12,r8
8000c3ca:	0c 1c       	sub	r12,r6
8000c3cc:	f5 da c0 10 	bfextu	r10,r10,0x0,0x10
8000c3d0:	f8 0b 0d 04 	divu	r4,r12,r11
8000c3d4:	f5 e5 11 0b 	or	r11,r10,r5<<0x10
8000c3d8:	08 96       	mov	r6,r4
8000c3da:	e8 0e 02 4e 	mul	lr,r4,lr
8000c3de:	1c 3b       	cp.w	r11,lr
8000c3e0:	c0 a2       	brcc	8000c3f4 <__avr32_umod64+0x1c4>
8000c3e2:	20 16       	sub	r6,1
8000c3e4:	10 0b       	add	r11,r8
8000c3e6:	10 3b       	cp.w	r11,r8
8000c3e8:	c0 63       	brcs	8000c3f4 <__avr32_umod64+0x1c4>
8000c3ea:	1c 3b       	cp.w	r11,lr
8000c3ec:	f7 b6 03 01 	sublo	r6,1
8000c3f0:	f7 d8 e3 0b 	addcs	r11,r11,r8
8000c3f4:	ed e1 11 01 	or	r1,r6,r1<<0x10
8000c3f8:	1c 1b       	sub	r11,lr
8000c3fa:	e2 02 06 40 	mulu.d	r0,r1,r2
8000c3fe:	00 9e       	mov	lr,r0
8000c400:	02 9c       	mov	r12,r1
8000c402:	16 3c       	cp.w	r12,r11
8000c404:	e0 8b 00 08 	brhi	8000c414 <__avr32_umod64+0x1e4>
8000c408:	5f 06       	sreq	r6
8000c40a:	06 30       	cp.w	r0,r3
8000c40c:	5f ba       	srhi	r10
8000c40e:	ed ea 00 0a 	and	r10,r6,r10
8000c412:	c0 60       	breq	8000c41e <__avr32_umod64+0x1ee>
8000c414:	fc 02 01 04 	sub	r4,lr,r2
8000c418:	f8 08 01 4c 	sbc	r12,r12,r8
8000c41c:	08 9e       	mov	lr,r4
8000c41e:	e6 0e 01 0a 	sub	r10,r3,lr
8000c422:	f6 0c 01 4c 	sbc	r12,r11,r12
8000c426:	ee f1 ff f4 	ld.w	r1,r7[-12]
8000c42a:	f8 09 0a 4b 	lsr	r11,r12,r9
8000c42e:	f4 09 0a 4a 	lsr	r10,r10,r9
8000c432:	f8 01 09 4c 	lsl	r12,r12,r1
8000c436:	18 4a       	or	r10,r12
8000c438:	2f dd       	sub	sp,-12
8000c43a:	d8 32       	popm	r0-r7,pc

Disassembly of section .exception:

8000c600 <_evba>:
_evba:

        .org  0x000
        // Unrecoverable Exception.
_handle_Unrecoverable_Exception:
        rjmp $
8000c600:	c0 08       	rjmp	8000c600 <_evba>
	...

8000c604 <_handle_TLB_Multiple_Hit>:

        .org  0x004
        // TLB Multiple Hit: UNUSED IN AVR32UC.
_handle_TLB_Multiple_Hit:
        rjmp $
8000c604:	c0 08       	rjmp	8000c604 <_handle_TLB_Multiple_Hit>
	...

8000c608 <_handle_Bus_Error_Data_Fetch>:

        .org  0x008
        // Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
        rjmp $
8000c608:	c0 08       	rjmp	8000c608 <_handle_Bus_Error_Data_Fetch>
	...

8000c60c <_handle_Bus_Error_Instruction_Fetch>:

        .org  0x00C
         // Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
        rjmp $
8000c60c:	c0 08       	rjmp	8000c60c <_handle_Bus_Error_Instruction_Fetch>
	...

8000c610 <_handle_NMI>:

        .org  0x010
        // NMI.
_handle_NMI:
        rjmp $
8000c610:	c0 08       	rjmp	8000c610 <_handle_NMI>
	...

8000c614 <_handle_Instruction_Address>:

        .org  0x014
        // Instruction Address.
_handle_Instruction_Address:
        rjmp $
8000c614:	c0 08       	rjmp	8000c614 <_handle_Instruction_Address>
	...

8000c618 <_handle_ITLB_Protection>:

        .org  0x018
        // ITLB Protection.
_handle_ITLB_Protection:
        rjmp $
8000c618:	c0 08       	rjmp	8000c618 <_handle_ITLB_Protection>
	...

8000c61c <_handle_Breakpoint>:

        .org  0x01C
        // Breakpoint.
_handle_Breakpoint:
        rjmp $
8000c61c:	c0 08       	rjmp	8000c61c <_handle_Breakpoint>
	...

8000c620 <_handle_Illegal_Opcode>:

        .org  0x020
        // Illegal Opcode.
_handle_Illegal_Opcode:
        rjmp $
8000c620:	c0 08       	rjmp	8000c620 <_handle_Illegal_Opcode>
	...

8000c624 <_handle_Unimplemented_Instruction>:

        .org  0x024
        // Unimplemented Instruction.
_handle_Unimplemented_Instruction:
        rjmp $
8000c624:	c0 08       	rjmp	8000c624 <_handle_Unimplemented_Instruction>
	...

8000c628 <_handle_Privilege_Violation>:

        .org  0x028
        // Privilege Violation.
_handle_Privilege_Violation:
        rjmp $
8000c628:	c0 08       	rjmp	8000c628 <_handle_Privilege_Violation>
	...

8000c62c <_handle_Floating_Point>:

        .org  0x02C
        // Floating-Point: UNUSED IN AVR32UC.
_handle_Floating_Point:
        rjmp $
8000c62c:	c0 08       	rjmp	8000c62c <_handle_Floating_Point>
	...

8000c630 <_handle_Coprocessor_Absent>:

        .org  0x030
        // Coprocessor Absent: UNUSED IN AVR32UC.
_handle_Coprocessor_Absent:
        rjmp $
8000c630:	c0 08       	rjmp	8000c630 <_handle_Coprocessor_Absent>
	...

8000c634 <_handle_Data_Address_Read>:

        .org  0x034
        // Data Address (Read).
_handle_Data_Address_Read:
        rjmp $
8000c634:	c0 08       	rjmp	8000c634 <_handle_Data_Address_Read>
	...

8000c638 <_handle_Data_Address_Write>:

        .org  0x038
        // Data Address (Write).
_handle_Data_Address_Write:
        rjmp $
8000c638:	c0 08       	rjmp	8000c638 <_handle_Data_Address_Write>
	...

8000c63c <_handle_DTLB_Protection_Read>:

        .org  0x03C
        // DTLB Protection (Read).
_handle_DTLB_Protection_Read:
        rjmp $
8000c63c:	c0 08       	rjmp	8000c63c <_handle_DTLB_Protection_Read>
	...

8000c640 <_handle_DTLB_Protection_Write>:

        .org  0x040
        // DTLB Protection (Write).
_handle_DTLB_Protection_Write:
        rjmp $
8000c640:	c0 08       	rjmp	8000c640 <_handle_DTLB_Protection_Write>
	...

8000c644 <_handle_DTLB_Modified>:

        .org  0x044
        // DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
        rjmp $
8000c644:	c0 08       	rjmp	8000c644 <_handle_DTLB_Modified>
	...

8000c650 <_handle_ITLB_Miss>:

        .org  0x050
        // ITLB Miss: UNUSED IN AVR32UC.
_handle_ITLB_Miss:
        rjmp $
8000c650:	c0 08       	rjmp	8000c650 <_handle_ITLB_Miss>
	...

8000c660 <_handle_DTLB_Miss_Read>:

        .org  0x060
        // DTLB Miss (Read): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Read:
        rjmp $
8000c660:	c0 08       	rjmp	8000c660 <_handle_DTLB_Miss_Read>
	...

8000c670 <_handle_DTLB_Miss_Write>:

        .org  0x070
        // DTLB Miss (Write): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Write:
        rjmp $
8000c670:	c0 08       	rjmp	8000c670 <_handle_DTLB_Miss_Write>
	...

8000c700 <_handle_Supervisor_Call>:

        .org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	lda.w   pc, SCALLYield
8000c700:	fe cf 70 dc 	sub	pc,pc,28892

8000c704 <_int0>:
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
	rete
.endr
8000c704:	30 0c       	mov	r12,0
8000c706:	fe b0 c4 55 	rcall	80004fb0 <_get_interrupt_handler>
8000c70a:	58 0c       	cp.w	r12,0
8000c70c:	f8 0f 17 10 	movne	pc,r12
8000c710:	d6 03       	rete

8000c712 <_int1>:
8000c712:	30 1c       	mov	r12,1
8000c714:	fe b0 c4 4e 	rcall	80004fb0 <_get_interrupt_handler>
8000c718:	58 0c       	cp.w	r12,0
8000c71a:	f8 0f 17 10 	movne	pc,r12
8000c71e:	d6 03       	rete

8000c720 <_int2>:
8000c720:	30 2c       	mov	r12,2
8000c722:	fe b0 c4 47 	rcall	80004fb0 <_get_interrupt_handler>
8000c726:	58 0c       	cp.w	r12,0
8000c728:	f8 0f 17 10 	movne	pc,r12
8000c72c:	d6 03       	rete

8000c72e <_int3>:
8000c72e:	30 3c       	mov	r12,3
8000c730:	fe b0 c4 40 	rcall	80004fb0 <_get_interrupt_handler>
8000c734:	58 0c       	cp.w	r12,0
8000c736:	f8 0f 17 10 	movne	pc,r12
8000c73a:	d6 03       	rete

8000c73c <ipr_val>:
8000c73c:	00 00 01 04 40 00 01 12 80 00 01 20 c0 00 01 2e     ....@...... ....
8000c74c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c75c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c76c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c77c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c78c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c79c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c7ac:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c7bc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c7cc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c7dc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c7ec:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c7fc:	d7 03 d7 03                                         ....
