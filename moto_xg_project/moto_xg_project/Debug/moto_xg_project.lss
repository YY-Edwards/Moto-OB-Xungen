
moto_xg_project.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00002004  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         0000bb14  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .exception    00000200  8000dc00  8000dc00  0000e000  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       0000164c  8000de00  8000de00  0000e200  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .dalign       00000004  8000f44c  8000f44c  0000f84c  2**0
                  ALLOC
  6 .data         00000a54  00000004  8000f450  0000fc04  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .bss          0000b2f8  00000a58  8000fea4  00010658  2**2
                  ALLOC
  8 .comment      00000030  00000000  00000000  00010658  2**0
                  CONTENTS, READONLY
  9 .debug_aranges 00001798  00000000  00000000  00010688  2**3
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_pubnames 0000387d  00000000  00000000  00011e20  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_info   0002e47a  00000000  00000000  0001569d  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_abbrev 00007859  00000000  00000000  00043b17  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_line   0000dcca  00000000  00000000  0004b370  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_frame  00004114  00000000  00000000  0005903c  2**2
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_str    0000834f  00000000  00000000  0005d150  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_loc    0000fff3  00000000  00000000  0006549f  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .stack        00001000  00017000  00017000  00000400  2**0
                  ALLOC
 18 .debug_ranges 00001848  00000000  00000000  00075498  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_trampoline>:

  .global _trampoline
  .type _trampoline, @function
_trampoline:
  // Jump to program start.
  rjmp    program_start
80000000:	e0 8f 10 00 	bral	80002000 <program_start>
	...

80002000 <program_start>:
	   // rjmp    program_start

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002000:	fe cf b5 70 	sub	pc,pc,-19088

Disassembly of section .text:

80002004 <DeviceManagement_brdcst_func>:
80002004:	f8 c8 ff fe 	sub	r8,r12,-2
void DeviceManagement_brdcst_func(xcmp_fragment_t * xcmp)
{
		U16 temp = 0;
		/*point to xcmp payload*/
		DeviceManagement_brdcast_t *ptr = (DeviceManagement_brdcast_t* )xcmp->u8;
		temp  = ptr->Device_Type << 8;
80002008:	f1 2a 00 01 	ld.sb	r10,r8[1]
		temp |= ptr->XCMP_Device_ID;
			
		//log("DeviceManagement_brdcst...\n");
		//log("temp: %x\n", temp);
		//log("xnl_information.logical_address: %x\n", xnl_information.logical_address);
		if (temp == xnl_information.logical_address)
8000200c:	48 c9       	lddpc	r9,8000203c <DeviceManagement_brdcst_func+0x38>
8000200e:	92 39       	ld.sh	r9,r9[0x6]
{
		U16 temp = 0;
		/*point to xcmp payload*/
		DeviceManagement_brdcast_t *ptr = (DeviceManagement_brdcast_t* )xcmp->u8;
		temp  = ptr->Device_Type << 8;
		temp |= ptr->XCMP_Device_ID;
80002010:	11 a8       	ld.ub	r8,r8[0x2]
80002012:	f1 ea 10 88 	or	r8,r8,r10<<0x8
80002016:	f0 09 19 00 	cp.h	r9,r8
8000201a:	5e 1c       	retne	r12
		//log("DeviceManagement_brdcst...\n");
		//log("temp: %x\n", temp);
		//log("xnl_information.logical_address: %x\n", xnl_information.logical_address);
		if (temp == xnl_information.logical_address)
		{
			if (xcmp->u8[0] == 0x01)
8000201c:	19 a9       	ld.ub	r9,r12[0x2]
8000201e:	30 18       	mov	r8,1
80002020:	f0 09 18 00 	cp.b	r9,r8
80002024:	c0 61       	brne	80002030 <DeviceManagement_brdcst_func+0x2c>
			{
				//Enable Option Board
				bunchofrandomstatusflags |= 0x00000002;
80002026:	48 78       	lddpc	r8,80002040 <DeviceManagement_brdcst_func+0x3c>
80002028:	70 09       	ld.w	r9,r8[0x0]
8000202a:	a1 b9       	sbr	r9,0x1
8000202c:	91 09       	st.w	r8[0x0],r9
8000202e:	5e fc       	retal	r12
			}
			else
			{
				//Disable Option Board.
				//log("Device State : %d\n", );
				bunchofrandomstatusflags &= 0xFFFFFFFD;
80002030:	48 48       	lddpc	r8,80002040 <DeviceManagement_brdcst_func+0x3c>
80002032:	70 09       	ld.w	r9,r8[0x0]
80002034:	a1 d9       	cbr	r9,0x1
80002036:	91 09       	st.w	r8[0x0],r9
80002038:	5e fc       	retal	r12
8000203a:	00 00       	add	r0,r0
8000203c:	00 00       	add	r0,r0
8000203e:	0e 22       	rsub	r2,r7
80002040:	00 00       	add	r0,r0
80002042:	0e 18       	sub	r8,r7

80002044 <Volume_brdcst_func>:
	//log("Attenuator_Number: %x \n",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
	
	//log("Audio_Parameter: %x \n", ptr->Audio_Parameter);
	
	
}
80002044:	5e fc       	retal	r12

80002046 <AudioRoutingControl_brdcst_func>:
	//
	//log("\n\r Audio-Function: %x \n\r", xcmp->u8[3+j*2-1]);
	
	
	
}
80002046:	5e fc       	retal	r12

80002048 <vApplicationIdleHook>:
}

void vApplicationIdleHook( void )
{
	/* This hook function does nothing but increment a counter. */
	ulIdleCycleCount++;
80002048:	48 38       	lddpc	r8,80002054 <vApplicationIdleHook+0xc>
8000204a:	70 09       	ld.w	r9,r8[0x0]
8000204c:	2f f9       	sub	r9,-1
8000204e:	91 09       	st.w	r8[0x0],r9
	
}
80002050:	5e fc       	retal	r12
80002052:	00 00       	add	r0,r0
80002054:	00 00       	add	r0,r0
80002056:	0a 70       	tst	r0,r5

80002058 <app_payload_tx_proc>:

}


static void app_payload_tx_proc(void  * payload)
{
80002058:	d4 01       	pushm	lr
  log("R");
8000205a:	48 3c       	lddpc	r12,80002064 <app_payload_tx_proc+0xc>
8000205c:	f0 1f 00 03 	mcall	80002068 <app_payload_tx_proc+0x10>
  //
  //
  //set_payload_idle(payload);


}
80002060:	d8 02       	popm	pc
80002062:	00 00       	add	r0,r0
80002064:	80 00       	ld.sh	r0,r0[0x0]
80002066:	de 00       	acall	0xe0
80002068:	80 00       	ld.sh	r0,r0[0x0]
8000206a:	7d ec       	ld.w	r12,lr[0x78]

8000206c <app_payload_rx_proc>:
}



static void app_payload_rx_proc(void  * payload)
{
8000206c:	d4 01       	pushm	lr
	static  U8 times_counter = 0;
	
	times_counter++;
8000206e:	48 99       	lddpc	r9,80002090 <app_payload_rx_proc+0x24>
80002070:	13 88       	ld.ub	r8,r9[0x0]
80002072:	2f f8       	sub	r8,-1
80002074:	b2 88       	st.b	r9[0x0],r8
	if (times_counter == 3)
80002076:	30 39       	mov	r9,3
80002078:	f2 08 18 00 	cp.b	r8,r9
8000207c:	c0 71       	brne	8000208a <app_payload_rx_proc+0x1e>
	{
		times_counter = 0 ;
8000207e:	30 09       	mov	r9,0
80002080:	48 48       	lddpc	r8,80002090 <app_payload_rx_proc+0x24>
80002082:	b0 89       	st.b	r8[0x0],r9
		log("\n\r w: \n\r");
80002084:	48 4c       	lddpc	r12,80002094 <app_payload_rx_proc+0x28>
80002086:	f0 1f 00 05 	mcall	80002098 <app_payload_rx_proc+0x2c>
	}
	//log("\n\r w: \n\r");
	if (AMBE_tx_flag)//本地发送方的mic录音
8000208a:	48 58       	lddpc	r8,8000209c <app_payload_rx_proc+0x30>
8000208c:	11 88       	ld.ub	r8,r8[0x0]
	}
	
	//payload_fragment_t * ptr = (payload_fragment_t *)payload;
	//set_payload_idle(payload);

}
8000208e:	d8 02       	popm	pc
80002090:	00 00       	add	r0,r0
80002092:	0a 68       	and	r8,r5
80002094:	80 00       	ld.sh	r0,r0[0x0]
80002096:	de 04       	*unknown*
80002098:	80 00       	ld.sh	r0,r0[0x0]
8000209a:	7d ec       	ld.w	r12,lr[0x78]
8000209c:	00 00       	add	r0,r0
8000209e:	0a 62       	and	r2,r5

800020a0 <FD_brdcst_func>:
	
	
}

void FD_brdcst_func(xcmp_fragment_t * xcmp)
{
800020a0:	d4 01       	pushm	lr
	
	
	log("\n\r Forward Data Broadcast \n\r");
800020a2:	48 3c       	lddpc	r12,800020ac <FD_brdcst_func+0xc>
800020a4:	f0 1f 00 03 	mcall	800020b0 <FD_brdcst_func+0x10>
	
}
800020a8:	d8 02       	popm	pc
800020aa:	00 00       	add	r0,r0
800020ac:	80 00       	ld.sh	r0,r0[0x0]
800020ae:	de 10       	acall	0xe1
800020b0:	80 00       	ld.sh	r0,r0[0x0]
800020b2:	7d ec       	ld.w	r12,lr[0x78]

800020b4 <FD_reply_func>:
	
	
}

void FD_reply_func(xcmp_fragment_t * xcmp)
{
800020b4:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Reply \n\r");
800020b6:	48 3c       	lddpc	r12,800020c0 <FD_reply_func+0xc>
800020b8:	f0 1f 00 03 	mcall	800020c4 <FD_reply_func+0x10>
	
	
}
800020bc:	d8 02       	popm	pc
800020be:	00 00       	add	r0,r0
800020c0:	80 00       	ld.sh	r0,r0[0x0]
800020c2:	de 30       	acall	0xe3
800020c4:	80 00       	ld.sh	r0,r0[0x0]
800020c6:	7d ec       	ld.w	r12,lr[0x78]

800020c8 <FD_request_func>:
}



void FD_request_func(xcmp_fragment_t * xcmp)
{
800020c8:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Request \n\r");
800020ca:	48 3c       	lddpc	r12,800020d4 <FD_request_func+0xc>
800020cc:	f0 1f 00 03 	mcall	800020d8 <FD_request_func+0x10>
	
	
}
800020d0:	d8 02       	popm	pc
800020d2:	00 00       	add	r0,r0
800020d4:	80 00       	ld.sh	r0,r0[0x0]
800020d6:	de 4c       	*unknown*
800020d8:	80 00       	ld.sh	r0,r0[0x0]
800020da:	7d ec       	ld.w	r12,lr[0x78]

800020dc <EnOB_brdcst_func>:
	
	
}

void EnOB_brdcst_func(xcmp_fragment_t * xcmp)
{
800020dc:	d4 01       	pushm	lr
	
	
	log("\n\r En_OB Broadcast \n\r");
800020de:	48 3c       	lddpc	r12,800020e8 <EnOB_brdcst_func+0xc>
800020e0:	f0 1f 00 03 	mcall	800020ec <EnOB_brdcst_func+0x10>
}
800020e4:	d8 02       	popm	pc
800020e6:	00 00       	add	r0,r0
800020e8:	80 00       	ld.sh	r0,r0[0x0]
800020ea:	de 68       	*unknown*
800020ec:	80 00       	ld.sh	r0,r0[0x0]
800020ee:	7d ec       	ld.w	r12,lr[0x78]

800020f0 <EnOB_reply_func>:
}



void EnOB_reply_func(xcmp_fragment_t * xcmp)
{
800020f0:	eb cd 40 80 	pushm	r7,lr
800020f4:	18 97       	mov	r7,r12
		/*point to xcmp payload*/
	//En_OB_Control_reply_t *ptr = (En_OB_Control_reply_t* )xcmp->u8;
	//log("\n\r Xcmp_opcode: %x \n\r", xcmp->xcmp_opcode);
	
	if (xcmp->u8[0]== xcmp_Res_Success)
800020f6:	19 a9       	ld.ub	r9,r12[0x2]
800020f8:	30 08       	mov	r8,0
800020fa:	f0 09 18 00 	cp.b	r9,r8
800020fe:	c1 91       	brne	80002130 <EnOB_reply_func+0x40>
	{
		if (xcmp->u8[1] == EN_OB_Enter)
80002100:	19 b8       	ld.ub	r8,r12[0x3]
80002102:	30 19       	mov	r9,1
80002104:	f2 08 18 00 	cp.b	r8,r9
80002108:	c0 61       	brne	80002114 <EnOB_reply_func+0x24>
		{
		
			log("\n\r En_OB_Enter OK \n\r");
8000210a:	49 0c       	lddpc	r12,80002148 <EnOB_reply_func+0x58>
8000210c:	f0 1f 00 10 	mcall	8000214c <EnOB_reply_func+0x5c>
80002110:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else if (xcmp->u8[1] == EN_OB_Exit )
80002114:	58 08       	cp.w	r8,0
80002116:	c0 61       	brne	80002122 <EnOB_reply_func+0x32>
		{
			log("\n\r En_OB_Exit OK \n\r");
80002118:	48 ec       	lddpc	r12,80002150 <EnOB_reply_func+0x60>
8000211a:	f0 1f 00 0d 	mcall	8000214c <EnOB_reply_func+0x5c>
8000211e:	e3 cd 80 80 	ldm	sp++,r7,pc
		}
		else
		{
			
			log("\n\r En_OB_Control: %x \n\r", xcmp->u8[1]);
80002122:	1a d8       	st.w	--sp,r8
80002124:	48 cc       	lddpc	r12,80002154 <EnOB_reply_func+0x64>
80002126:	f0 1f 00 0a 	mcall	8000214c <EnOB_reply_func+0x5c>
8000212a:	2f fd       	sub	sp,-4
8000212c:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r En_OB_Control error \n\r");
80002130:	48 ac       	lddpc	r12,80002158 <EnOB_reply_func+0x68>
80002132:	f0 1f 00 07 	mcall	8000214c <EnOB_reply_func+0x5c>
		log("\n\r En_OB_result: %x \n\r", xcmp->u8[0]);
80002136:	0f a8       	ld.ub	r8,r7[0x2]
80002138:	1a d8       	st.w	--sp,r8
8000213a:	48 9c       	lddpc	r12,8000215c <EnOB_reply_func+0x6c>
8000213c:	f0 1f 00 04 	mcall	8000214c <EnOB_reply_func+0x5c>
80002140:	2f fd       	sub	sp,-4
80002142:	e3 cd 80 80 	ldm	sp++,r7,pc
80002146:	00 00       	add	r0,r0
80002148:	80 00       	ld.sh	r0,r0[0x0]
8000214a:	de 80       	acall	0xe8
8000214c:	80 00       	ld.sh	r0,r0[0x0]
8000214e:	7d ec       	ld.w	r12,lr[0x78]
80002150:	80 00       	ld.sh	r0,r0[0x0]
80002152:	de 98       	*unknown*
80002154:	80 00       	ld.sh	r0,r0[0x0]
80002156:	de ac       	*unknown*
80002158:	80 00       	ld.sh	r0,r0[0x0]
8000215a:	de c4       	*unknown*
8000215c:	80 00       	ld.sh	r0,r0[0x0]
8000215e:	de e0       	acall	0xee

80002160 <SingleDetection_brdcst_func>:
	
}


void SingleDetection_brdcst_func(xcmp_fragment_t * xcmp)
{
80002160:	eb cd 40 80 	pushm	r7,lr
80002164:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == 0x11)
80002166:	19 a9       	ld.ub	r9,r12[0x2]
80002168:	31 18       	mov	r8,17
8000216a:	f0 09 18 00 	cp.b	r9,r8
8000216e:	c0 91       	brne	80002180 <SingleDetection_brdcst_func+0x20>
	{
		log("\n\r DMR_CSBK OK \n\r");
80002170:	48 ac       	lddpc	r12,80002198 <SingleDetection_brdcst_func+0x38>
80002172:	f0 1f 00 0b 	mcall	8000219c <SingleDetection_brdcst_func+0x3c>
		get_time_okay = TRUE;
80002176:	30 19       	mov	r9,1
80002178:	48 a8       	lddpc	r8,800021a0 <SingleDetection_brdcst_func+0x40>
8000217a:	b0 89       	st.b	r8[0x0],r9
8000217c:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	//if(xcmp->u8[1] == 0x11)
	else
	{
		log("SIGBRCST error\n");
80002180:	48 9c       	lddpc	r12,800021a4 <SingleDetection_brdcst_func+0x44>
80002182:	f0 1f 00 07 	mcall	8000219c <SingleDetection_brdcst_func+0x3c>
		log("\Signal_type: %X \n\r", xcmp->u8[0] );
80002186:	0f a8       	ld.ub	r8,r7[0x2]
80002188:	1a d8       	st.w	--sp,r8
8000218a:	48 8c       	lddpc	r12,800021a8 <SingleDetection_brdcst_func+0x48>
8000218c:	f0 1f 00 04 	mcall	8000219c <SingleDetection_brdcst_func+0x3c>
80002190:	2f fd       	sub	sp,-4
80002192:	e3 cd 80 80 	ldm	sp++,r7,pc
80002196:	00 00       	add	r0,r0
80002198:	80 00       	ld.sh	r0,r0[0x0]
8000219a:	de f8       	*unknown*
8000219c:	80 00       	ld.sh	r0,r0[0x0]
8000219e:	7d ec       	ld.w	r12,lr[0x78]
800021a0:	00 00       	add	r0,r0
800021a2:	00 08       	add	r8,r0
800021a4:	80 00       	ld.sh	r0,r0[0x0]
800021a6:	df 0c       	*unknown*
800021a8:	80 00       	ld.sh	r0,r0[0x0]
800021aa:	df 1c       	*unknown*

800021ac <ButtonConfig_brdcst_func>:
	
}


void ButtonConfig_brdcst_func(xcmp_fragment_t * xcmp)
{
800021ac:	d4 31       	pushm	r0-r7,lr
	U8 Num_Button =0;
	U8 i = 0 ;
	/*point to xcmp payload*/
	ButtonConfig_brdcst_t  *ptr = (ButtonConfig_brdcst_t* )xcmp->u8;
800021ae:	f8 c7 ff fe 	sub	r7,r12,-2
	
	Num_Button = ptr->NumOfButtons;
800021b2:	0f 95       	ld.ub	r5,r7[0x1]
	
	log("\n\r ButtonConfig_broadcast  \n\r"  );
800021b4:	4a bc       	lddpc	r12,80002260 <ButtonConfig_brdcst_func+0xb4>
800021b6:	f0 1f 00 2c 	mcall	80002264 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r Function: %X \n\r" , ptr->Function );
800021ba:	0f 88       	ld.ub	r8,r7[0x0]
800021bc:	1a d8       	st.w	--sp,r8
800021be:	4a bc       	lddpc	r12,80002268 <ButtonConfig_brdcst_func+0xbc>
800021c0:	f0 1f 00 29 	mcall	80002264 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
800021c4:	1a d5       	st.w	--sp,r5
800021c6:	4a ac       	lddpc	r12,8000226c <ButtonConfig_brdcst_func+0xc0>
800021c8:	f0 1f 00 27 	mcall	80002264 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
800021cc:	0f a8       	ld.ub	r8,r7[0x2]
800021ce:	1a d8       	st.w	--sp,r8
800021d0:	4a 8c       	lddpc	r12,80002270 <ButtonConfig_brdcst_func+0xc4>
800021d2:	f0 1f 00 25 	mcall	80002264 <ButtonConfig_brdcst_func+0xb8>
	
	for (i; i<Num_Button; i++)
800021d6:	2f dd       	sub	sp,-12
800021d8:	58 05       	cp.w	r5,0
800021da:	c4 10       	breq	8000225c <ButtonConfig_brdcst_func+0xb0>
800021dc:	30 06       	mov	r6,0
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
800021de:	4a 64       	lddpc	r4,80002274 <ButtonConfig_brdcst_func+0xc8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
800021e0:	4a 63       	lddpc	r3,80002278 <ButtonConfig_brdcst_func+0xcc>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
800021e2:	4a 72       	lddpc	r2,8000227c <ButtonConfig_brdcst_func+0xd0>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
800021e4:	4a 71       	lddpc	r1,80002280 <ButtonConfig_brdcst_func+0xd4>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
800021e6:	4a 80       	lddpc	r0,80002284 <ButtonConfig_brdcst_func+0xd8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
800021e8:	0f b9       	ld.ub	r9,r7[0x3]
800021ea:	0f c8       	ld.ub	r8,r7[0x4]
800021ec:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800021f0:	1a d8       	st.w	--sp,r8
800021f2:	1a d6       	st.w	--sp,r6
800021f4:	08 9c       	mov	r12,r4
800021f6:	f0 1f 00 1c 	mcall	80002264 <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
800021fa:	0f d9       	ld.ub	r9,r7[0x5]
800021fc:	0f e8       	ld.ub	r8,r7[0x6]
800021fe:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002202:	1a d8       	st.w	--sp,r8
80002204:	1a d6       	st.w	--sp,r6
80002206:	06 9c       	mov	r12,r3
80002208:	f0 1f 00 17 	mcall	80002264 <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
8000220c:	0f f9       	ld.ub	r9,r7[0x7]
8000220e:	ef 38 00 08 	ld.ub	r8,r7[8]
80002212:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002216:	1a d8       	st.w	--sp,r8
80002218:	1a d6       	st.w	--sp,r6
8000221a:	04 9c       	mov	r12,r2
8000221c:	f0 1f 00 12 	mcall	80002264 <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
80002220:	ef 39 00 09 	ld.ub	r9,r7[9]
80002224:	ef 38 00 0a 	ld.ub	r8,r7[10]
80002228:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000222c:	1a d8       	st.w	--sp,r8
8000222e:	1a d6       	st.w	--sp,r6
80002230:	02 9c       	mov	r12,r1
80002232:	f0 1f 00 0d 	mcall	80002264 <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
80002236:	2f 8d       	sub	sp,-32
80002238:	ef 39 00 0b 	ld.ub	r9,r7[11]
8000223c:	ef 38 00 0c 	ld.ub	r8,r7[12]
80002240:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002244:	1a d8       	st.w	--sp,r8
80002246:	1a d6       	st.w	--sp,r6
80002248:	00 9c       	mov	r12,r0
8000224a:	f0 1f 00 07 	mcall	80002264 <ButtonConfig_brdcst_func+0xb8>
8000224e:	2f f6       	sub	r6,-1
80002250:	2f 67       	sub	r7,-10
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
80002252:	2f ed       	sub	sp,-8
80002254:	ec 05 18 00 	cp.b	r5,r6
80002258:	fe 9b ff c8 	brhi	800021e8 <ButtonConfig_brdcst_func+0x3c>
8000225c:	d8 32       	popm	r0-r7,pc
8000225e:	00 00       	add	r0,r0
80002260:	80 00       	ld.sh	r0,r0[0x0]
80002262:	df 30       	acall	0xf3
80002264:	80 00       	ld.sh	r0,r0[0x0]
80002266:	7d ec       	ld.w	r12,lr[0x78]
80002268:	80 00       	ld.sh	r0,r0[0x0]
8000226a:	df 50       	acall	0xf5
8000226c:	80 00       	ld.sh	r0,r0[0x0]
8000226e:	df 64       	*unknown*
80002270:	80 00       	ld.sh	r0,r0[0x0]
80002272:	df 7c       	*unknown*
80002274:	80 00       	ld.sh	r0,r0[0x0]
80002276:	df 9c       	*unknown*
80002278:	80 00       	ld.sh	r0,r0[0x0]
8000227a:	df c4       	*unknown*
8000227c:	80 00       	ld.sh	r0,r0[0x0]
8000227e:	df ec       	*unknown*
80002280:	80 00       	ld.sh	r0,r0[0x0]
80002282:	e0 10 80 00 	andl	r0,0x8000
80002286:	e0 38 eb cd 	sub	r8,125901

80002288 <ButtonConfig_reply_func>:
	}
	
}

void ButtonConfig_reply_func(xcmp_fragment_t * xcmp)
{
80002288:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	ButtonConfig_reply_t *ptr = (ButtonConfig_reply_t* )(xcmp->u8);
8000228c:	f8 c7 ff fe 	sub	r7,r12,-2
	if (ptr->Result == xcmp_Res_Success)
80002290:	0f 89       	ld.ub	r9,r7[0x0]
80002292:	30 08       	mov	r8,0
80002294:	f0 09 18 00 	cp.b	r9,r8
80002298:	c0 c1       	brne	800022b0 <ButtonConfig_reply_func+0x28>
	{
		log("\n\r Button_Config OK \n\r");
8000229a:	48 9c       	lddpc	r12,800022bc <ButtonConfig_reply_func+0x34>
8000229c:	f0 1f 00 09 	mcall	800022c0 <ButtonConfig_reply_func+0x38>
		
		log("\n\r Function: %X \n\r" , ptr->Function );
800022a0:	0f 98       	ld.ub	r8,r7[0x1]
800022a2:	1a d8       	st.w	--sp,r8
800022a4:	48 8c       	lddpc	r12,800022c4 <ButtonConfig_reply_func+0x3c>
800022a6:	f0 1f 00 07 	mcall	800022c0 <ButtonConfig_reply_func+0x38>
800022aa:	2f fd       	sub	sp,-4
800022ac:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r Button_Request error \n\r");
800022b0:	48 6c       	lddpc	r12,800022c8 <ButtonConfig_reply_func+0x40>
800022b2:	f0 1f 00 04 	mcall	800022c0 <ButtonConfig_reply_func+0x38>
800022b6:	e3 cd 80 80 	ldm	sp++,r7,pc
800022ba:	00 00       	add	r0,r0
800022bc:	80 00       	ld.sh	r0,r0[0x0]
800022be:	e0 5c 80 00 	cp.w	r12,98304
800022c2:	7d ec       	ld.w	r12,lr[0x78]
800022c4:	80 00       	ld.sh	r0,r0[0x0]
800022c6:	df 50       	acall	0xf5
800022c8:	80 00       	ld.sh	r0,r0[0x0]
800022ca:	e0 74 eb cd 	mov	r4,125901

800022cc <BatteryLevel_brdcst_func>:
	
}


void BatteryLevel_brdcst_func(xcmp_fragment_t * xcmp)
{
800022cc:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	BatteryLevel_brdcast_t *ptr = (BatteryLevel_brdcast_t* )(xcmp->u8);
800022d0:	f8 c7 ff fe 	sub	r7,r12,-2
	if(ptr->State == Battery_Okay)
800022d4:	0f 89       	ld.ub	r9,r7[0x0]
800022d6:	30 08       	mov	r8,0
800022d8:	f0 09 18 00 	cp.b	r9,r8
800022dc:	c0 40       	breq	800022e4 <BatteryLevel_brdcst_func+0x18>
		;//log("\n Battery Okay\n");
	else
		log("\n Battery Low !!!\n");
800022de:	48 5c       	lddpc	r12,800022f0 <BatteryLevel_brdcst_func+0x24>
800022e0:	f0 1f 00 05 	mcall	800022f4 <BatteryLevel_brdcst_func+0x28>
		
	//log("\n Battery charge: %X \n" , ptr->Charge);
	//log("\n Battery voltage: %X \n" , ptr->Voltage);
	
	Battery_Flag = ptr->State;
800022e4:	0f 89       	ld.ub	r9,r7[0x0]
800022e6:	48 58       	lddpc	r8,800022f8 <BatteryLevel_brdcst_func+0x2c>
800022e8:	b0 89       	st.b	r8[0x0],r9

}
800022ea:	e3 cd 80 80 	ldm	sp++,r7,pc
800022ee:	00 00       	add	r0,r0
800022f0:	80 00       	ld.sh	r0,r0[0x0]
800022f2:	e0 90 80 00 	breq	800322f2 <_data_lma+0x22ea2>
800022f6:	7d ec       	ld.w	r12,lr[0x78]
800022f8:	00 00       	add	r0,r0
800022fa:	0a 88       	andn	r8,r5

800022fc <ShutDown_brdcst_func>:
		log("ID:  %X \n", xcmp->u8[2]);
	}
	
}
void ShutDown_brdcst_func(xcmp_fragment_t * xcmp)
{
800022fc:	d4 01       	pushm	lr
	if (xcmp->u8[0] == Shut_Down_Device)
800022fe:	19 a8       	ld.ub	r8,r12[0x2]
80002300:	30 19       	mov	r9,1
80002302:	f2 08 18 00 	cp.b	r8,r9
80002306:	c0 51       	brne	80002310 <ShutDown_brdcst_func+0x14>
	{
		log("Shut_Down_Device \n");
80002308:	48 6c       	lddpc	r12,80002320 <ShutDown_brdcst_func+0x24>
8000230a:	f0 1f 00 07 	mcall	80002324 <ShutDown_brdcst_func+0x28>
8000230e:	d8 02       	popm	pc
		
	}
	else if(xcmp->u8[0] == Reset_Device)
80002310:	30 29       	mov	r9,2
80002312:	f2 08 18 00 	cp.b	r8,r9
80002316:	c0 41       	brne	8000231e <ShutDown_brdcst_func+0x22>
	{
		log("Reset_Device \n");
80002318:	48 4c       	lddpc	r12,80002328 <ShutDown_brdcst_func+0x2c>
8000231a:	f0 1f 00 03 	mcall	80002324 <ShutDown_brdcst_func+0x28>
8000231e:	d8 02       	popm	pc
80002320:	80 00       	ld.sh	r0,r0[0x0]
80002322:	e0 a4       	*unknown*
80002324:	80 00       	ld.sh	r0,r0[0x0]
80002326:	7d ec       	ld.w	r12,lr[0x78]
80002328:	80 00       	ld.sh	r0,r0[0x0]
8000232a:	e0 b8       	*unknown*

8000232c <DataSession_reply_func>:
	
	
}

void DataSession_reply_func(xcmp_fragment_t * xcmp)
{
8000232c:	eb cd 40 80 	pushm	r7,lr
80002330:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
80002332:	19 a9       	ld.ub	r9,r12[0x2]
80002334:	30 08       	mov	r8,0
80002336:	f0 09 18 00 	cp.b	r9,r8
8000233a:	c0 61       	brne	80002346 <DataSession_reply_func+0x1a>
	{
		log("DATArep OK \n");
8000233c:	48 dc       	lddpc	r12,80002370 <DataSession_reply_func+0x44>
8000233e:	f0 1f 00 0e 	mcall	80002374 <DataSession_reply_func+0x48>
80002342:	e3 cd 80 80 	ldm	sp++,r7,pc
		//log("ID: %X \n", xcmp->u8[2]);
		
	}
	else
	{	
		log("DATArep error \n");
80002346:	48 dc       	lddpc	r12,80002378 <DataSession_reply_func+0x4c>
80002348:	f0 1f 00 0b 	mcall	80002374 <DataSession_reply_func+0x48>
		log("Result:  %X \n", xcmp->u8[0]);
8000234c:	0f a8       	ld.ub	r8,r7[0x2]
8000234e:	1a d8       	st.w	--sp,r8
80002350:	48 bc       	lddpc	r12,8000237c <DataSession_reply_func+0x50>
80002352:	f0 1f 00 09 	mcall	80002374 <DataSession_reply_func+0x48>
		log("Func:  %X \n", xcmp->u8[1]);
80002356:	0f b8       	ld.ub	r8,r7[0x3]
80002358:	1a d8       	st.w	--sp,r8
8000235a:	48 ac       	lddpc	r12,80002380 <DataSession_reply_func+0x54>
8000235c:	f0 1f 00 06 	mcall	80002374 <DataSession_reply_func+0x48>
		log("ID:  %X \n", xcmp->u8[2]);
80002360:	0f c8       	ld.ub	r8,r7[0x4]
80002362:	1a d8       	st.w	--sp,r8
80002364:	48 8c       	lddpc	r12,80002384 <DataSession_reply_func+0x58>
80002366:	f0 1f 00 04 	mcall	80002374 <DataSession_reply_func+0x48>
8000236a:	2f dd       	sub	sp,-12
8000236c:	e3 cd 80 80 	ldm	sp++,r7,pc
80002370:	80 00       	ld.sh	r0,r0[0x0]
80002372:	e0 c8 80 00 	sub	r8,r0,-32768
80002376:	7d ec       	ld.w	r12,lr[0x78]
80002378:	80 00       	ld.sh	r0,r0[0x0]
8000237a:	e0 d8 80 00 	satsub.w	r8,r0,-32768
8000237e:	e0 e8 80 00 	ld.d	r8,r0[-32768]
80002382:	e0 f8 80 00 	ld.w	r8,r0[-32768]
80002386:	e1 04 eb cd 	ld.sh	r4,r0[-5171]

80002388 <CallControl_brdcst_func>:
	
}


void CallControl_brdcst_func(xcmp_fragment_t * xcmp)
{
80002388:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	CallControl_brdcst_t *ptr = (CallControl_brdcst_t* )xcmp->u8;
8000238c:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  CallControl brst \n\r ");
	//log("\n\r  Call_type: %x \n\r ", ptr->Calltype );
	log("\n\r  Call_state: %x \n\r ", ptr->Callstate );
80002390:	0f 98       	ld.ub	r8,r7[0x1]
80002392:	1a d8       	st.w	--sp,r8
80002394:	48 bc       	lddpc	r12,800023c0 <CallControl_brdcst_func+0x38>
80002396:	f0 1f 00 0c 	mcall	800023c4 <CallControl_brdcst_func+0x3c>
	if (ptr->Callstate == Call_Ended)//0x03
8000239a:	2f fd       	sub	sp,-4
8000239c:	0f 99       	ld.ub	r9,r7[0x1]
8000239e:	30 38       	mov	r8,3
800023a0:	f0 09 18 00 	cp.b	r9,r8
800023a4:	c0 41       	brne	800023ac <CallControl_brdcst_func+0x24>
	{
		//恢复正常语音路径通道
		//xcmp_audio_route_revert();
		Call_Begin = 0;
800023a6:	30 09       	mov	r9,0
800023a8:	48 88       	lddpc	r8,800023c8 <CallControl_brdcst_func+0x40>
800023aa:	b0 89       	st.b	r8[0x0],r9
		
	}
	
	if (ptr->Callstate == Call_Initiated)//0x04
800023ac:	0f 99       	ld.ub	r9,r7[0x1]
800023ae:	30 48       	mov	r8,4
800023b0:	f0 09 18 00 	cp.b	r9,r8
800023b4:	c0 41       	brne	800023bc <CallControl_brdcst_func+0x34>
	{
		Call_Begin = 1;
800023b6:	30 19       	mov	r9,1
800023b8:	48 48       	lddpc	r8,800023c8 <CallControl_brdcst_func+0x40>
800023ba:	b0 89       	st.b	r8[0x0],r9
800023bc:	e3 cd 80 80 	ldm	sp++,r7,pc
800023c0:	80 00       	ld.sh	r0,r0[0x0]
800023c2:	e1 10 80 00 	ld.uh	r0,r0[-32768]
800023c6:	7d ec       	ld.w	r12,lr[0x78]
800023c8:	00 00       	add	r0,r0
800023ca:	0a 8a       	andn	r10,r5

800023cc <TransmitControl_brdcst_func>:

}


void TransmitControl_brdcst_func(xcmp_fragment_t * xcmp)
{
800023cc:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	TransmitControl_brdcast_t *ptr = (TransmitControl_brdcast_t* )xcmp->u8;
800023d0:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  TransmitControl broadcast \n\r ");
	//log("\n\r  Mode_Of_Operation: %x \n\r ", ptr->Mode_Of_Operation );
	if (ptr->State == 0x00)
800023d4:	0f 99       	ld.ub	r9,r7[0x1]
800023d6:	30 08       	mov	r8,0
800023d8:	f0 09 18 00 	cp.b	r9,r8
800023dc:	c0 71       	brne	800023ea <TransmitControl_brdcst_func+0x1e>
	{
		log("\n\r  Standby-Receive \n\r ");
800023de:	48 ac       	lddpc	r12,80002404 <TransmitControl_brdcst_func+0x38>
800023e0:	f0 1f 00 0a 	mcall	80002408 <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 0;
800023e4:	30 09       	mov	r9,0
800023e6:	48 a8       	lddpc	r8,8000240c <TransmitControl_brdcst_func+0x40>
800023e8:	b0 89       	st.b	r8[0x0],r9
	}
	if (ptr->State == 0x01)
800023ea:	0f 99       	ld.ub	r9,r7[0x1]
800023ec:	30 18       	mov	r8,1
800023ee:	f0 09 18 00 	cp.b	r9,r8
800023f2:	c0 71       	brne	80002400 <TransmitControl_brdcst_func+0x34>
	{
		log("\n\r  Transmit \n\r ");
800023f4:	48 7c       	lddpc	r12,80002410 <TransmitControl_brdcst_func+0x44>
800023f6:	f0 1f 00 05 	mcall	80002408 <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 1;
800023fa:	30 19       	mov	r9,1
800023fc:	48 48       	lddpc	r8,8000240c <TransmitControl_brdcst_func+0x40>
800023fe:	b0 89       	st.b	r8[0x0],r9
80002400:	e3 cd 80 80 	ldm	sp++,r7,pc
80002404:	80 00       	ld.sh	r0,r0[0x0]
80002406:	e1 28 80 00 	ld.sb	r8,r0[-32768]
8000240a:	7d ec       	ld.w	r12,lr[0x78]
8000240c:	00 00       	add	r0,r0
8000240e:	0a 60       	and	r0,r5
80002410:	80 00       	ld.sh	r0,r0[0x0]
80002412:	e1 40 eb cd 	st.w	r0[-5171],r0

80002414 <TransmitControl_reply_func>:




void TransmitControl_reply_func(xcmp_fragment_t * xcmp)
{
80002414:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	TransmitControl_reply_t *ptr = (TransmitControl_reply_t* )xcmp->u8;
80002418:	f8 c7 ff fe 	sub	r7,r12,-2
	
	if (ptr->Result == xcmp_Res_Success)
8000241c:	0f 89       	ld.ub	r9,r7[0x0]
8000241e:	30 08       	mov	r8,0
80002420:	f0 09 18 00 	cp.b	r9,r8
80002424:	c1 61       	brne	80002450 <TransmitControl_reply_func+0x3c>
	{
		
		log("\n\r  TransmitControl OK \n\r ");
80002426:	48 ec       	lddpc	r12,8000245c <TransmitControl_reply_func+0x48>
80002428:	f0 1f 00 0e 	mcall	80002460 <TransmitControl_reply_func+0x4c>
		log("\n\r Function: %x \n\r", ptr->Function);
8000242c:	0f 98       	ld.ub	r8,r7[0x1]
8000242e:	1a d8       	st.w	--sp,r8
80002430:	48 dc       	lddpc	r12,80002464 <TransmitControl_reply_func+0x50>
80002432:	f0 1f 00 0c 	mcall	80002460 <TransmitControl_reply_func+0x4c>
		log("\n\r Mode of Operation: %x \n\r", ptr->Mode_Of_Operation);
80002436:	0f a8       	ld.ub	r8,r7[0x2]
80002438:	1a d8       	st.w	--sp,r8
8000243a:	48 cc       	lddpc	r12,80002468 <TransmitControl_reply_func+0x54>
8000243c:	f0 1f 00 09 	mcall	80002460 <TransmitControl_reply_func+0x4c>
		log("\n\r State: %x \n\r", ptr->State);
80002440:	0f b8       	ld.ub	r8,r7[0x3]
80002442:	1a d8       	st.w	--sp,r8
80002444:	48 ac       	lddpc	r12,8000246c <TransmitControl_reply_func+0x58>
80002446:	f0 1f 00 07 	mcall	80002460 <TransmitControl_reply_func+0x4c>
8000244a:	2f dd       	sub	sp,-12
8000244c:	e3 cd 80 80 	ldm	sp++,r7,pc
		
		//Silent_flag = 1;
	}
	else
	{
		log("TransmitControl error");
80002450:	48 8c       	lddpc	r12,80002470 <TransmitControl_reply_func+0x5c>
80002452:	f0 1f 00 04 	mcall	80002460 <TransmitControl_reply_func+0x4c>
80002456:	e3 cd 80 80 	ldm	sp++,r7,pc
8000245a:	00 00       	add	r0,r0
8000245c:	80 00       	ld.sh	r0,r0[0x0]
8000245e:	e1 54 80 00 	st.h	r0[-32768],r4
80002462:	7d ec       	ld.w	r12,lr[0x78]
80002464:	80 00       	ld.sh	r0,r0[0x0]
80002466:	e1 70 80 00 	stcond	r0[-32768],r0
8000246a:	e1 84       	*unknown*
8000246c:	80 00       	ld.sh	r0,r0[0x0]
8000246e:	e1 a0 80 00 	cop	cp4,cr0,cr0,cr0,0x0
80002472:	e1 b0       	*unknown*

80002474 <AudioRoutingControl_reply_func>:
	
}


void AudioRoutingControl_reply_func(xcmp_fragment_t * xcmp)
{
80002474:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
80002476:	19 a9       	ld.ub	r9,r12[0x2]
80002478:	30 08       	mov	r8,0
8000247a:	f0 09 18 00 	cp.b	r9,r8
8000247e:	c0 51       	brne	80002488 <AudioRoutingControl_reply_func+0x14>
	{
		log("AudioRouting OK");
80002480:	48 4c       	lddpc	r12,80002490 <AudioRoutingControl_reply_func+0x1c>
80002482:	f0 1f 00 05 	mcall	80002494 <AudioRoutingControl_reply_func+0x20>
80002486:	d8 02       	popm	pc
		//xcmp_IdleTestTone();
		//Speaker_is_unmute = 1;
	}
	else
	{
		log("AudioRouting error");
80002488:	48 4c       	lddpc	r12,80002498 <AudioRoutingControl_reply_func+0x24>
8000248a:	f0 1f 00 03 	mcall	80002494 <AudioRoutingControl_reply_func+0x20>
8000248e:	d8 02       	popm	pc
80002490:	80 00       	ld.sh	r0,r0[0x0]
80002492:	e1 c8 80 00 	ldm	r8,pc
80002496:	7d ec       	ld.w	r12,lr[0x78]
80002498:	80 00       	ld.sh	r0,r0[0x0]
8000249a:	e1 d8       	*unknown*

8000249c <Volume_reply_func>:
	
}


void Volume_reply_func(xcmp_fragment_t * xcmp)
{
8000249c:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	VolumeControl_reply_t *ptr = (VolumeControl_reply_t* )xcmp->u8;
800024a0:	f8 c7 ff fe 	sub	r7,r12,-2
	
		if (ptr->Result == xcmp_Res_Success)
800024a4:	0f 89       	ld.ub	r9,r7[0x0]
800024a6:	30 08       	mov	r8,0
800024a8:	f0 09 18 00 	cp.b	r9,r8
800024ac:	c1 b1       	brne	800024e2 <Volume_reply_func+0x46>
		{
			if (ptr->Function == Enable_IntelligentAudio)
800024ae:	0f b8       	ld.ub	r8,r7[0x3]
800024b0:	31 09       	mov	r9,16
800024b2:	f2 08 18 00 	cp.b	r8,r9
800024b6:	c0 f1       	brne	800024d4 <Volume_reply_func+0x38>
			{
				log("\n\r Enable_IA OK \n\r");
800024b8:	48 dc       	lddpc	r12,800024ec <Volume_reply_func+0x50>
800024ba:	f0 1f 00 0e 	mcall	800024f0 <Volume_reply_func+0x54>
				log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
800024be:	0f 99       	ld.ub	r9,r7[0x1]
800024c0:	0f a8       	ld.ub	r8,r7[0x2]
800024c2:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800024c6:	1a d8       	st.w	--sp,r8
800024c8:	48 bc       	lddpc	r12,800024f4 <Volume_reply_func+0x58>
800024ca:	f0 1f 00 0a 	mcall	800024f0 <Volume_reply_func+0x54>
800024ce:	2f fd       	sub	sp,-4
800024d0:	e3 cd 80 80 	ldm	sp++,r7,pc
	
			}
			else
			{
				
				log("\n\r VolumeControl: %x \n\r", ptr->Function);
800024d4:	1a d8       	st.w	--sp,r8
800024d6:	48 9c       	lddpc	r12,800024f8 <Volume_reply_func+0x5c>
800024d8:	f0 1f 00 06 	mcall	800024f0 <Volume_reply_func+0x54>
800024dc:	2f fd       	sub	sp,-4
800024de:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		
		else
		{
			log("\n\r Enable_IA error \n\r");
800024e2:	48 7c       	lddpc	r12,800024fc <Volume_reply_func+0x60>
800024e4:	f0 1f 00 03 	mcall	800024f0 <Volume_reply_func+0x54>
800024e8:	e3 cd 80 80 	ldm	sp++,r7,pc
800024ec:	80 00       	ld.sh	r0,r0[0x0]
800024ee:	e1 ec 80 00 	sthh.w	r0[r0],r0:b,r12:b
800024f2:	7d ec       	ld.w	r12,lr[0x78]
800024f4:	80 00       	ld.sh	r0,r0[0x0]
800024f6:	e2 00       	*unknown*
800024f8:	80 00       	ld.sh	r0,r0[0x0]
800024fa:	e2 1c 80 00 	andl	r12,0x8000,COH
800024fe:	e2 34 d4 01 	sub	r4,250881

80002500 <spk_brdcst_func>:
		log("spk error");
	}
}

void spk_brdcst_func(xcmp_fragment_t * xcmp)
{
80002500:	d4 01       	pushm	lr
	if (xcmp->u8[3] == xcmp_Res_Success)//0x0000:mute
80002502:	19 d9       	ld.ub	r9,r12[0x5]
80002504:	30 08       	mov	r8,0
80002506:	f0 09 18 00 	cp.b	r9,r8
8000250a:	c0 81       	brne	8000251a <spk_brdcst_func+0x1a>
	{
		Speaker_is_unmute =0;
8000250c:	10 99       	mov	r9,r8
8000250e:	48 78       	lddpc	r8,80002528 <spk_brdcst_func+0x28>
80002510:	b0 89       	st.b	r8[0x0],r9
		//Silent_flag = 0;
		log("spk_s_close ");
80002512:	48 7c       	lddpc	r12,8000252c <spk_brdcst_func+0x2c>
80002514:	f0 1f 00 07 	mcall	80002530 <spk_brdcst_func+0x30>
80002518:	d8 02       	popm	pc
		
	}
	else
	{
		//Silent_flag = 1;
		Speaker_is_unmute = 1;
8000251a:	30 19       	mov	r9,1
8000251c:	48 38       	lddpc	r8,80002528 <spk_brdcst_func+0x28>
8000251e:	b0 89       	st.b	r8[0x0],r9
		log("spk_s_open ");	
80002520:	48 5c       	lddpc	r12,80002534 <spk_brdcst_func+0x34>
80002522:	f0 1f 00 04 	mcall	80002530 <spk_brdcst_func+0x30>
80002526:	d8 02       	popm	pc
80002528:	00 00       	add	r0,r0
8000252a:	0a 7d       	tst	sp,r5
8000252c:	80 00       	ld.sh	r0,r0[0x0]
8000252e:	e2 4c 80 00 	cp.w	r12,163840
80002532:	7d ec       	ld.w	r12,lr[0x78]
80002534:	80 00       	ld.sh	r0,r0[0x0]
80002536:	e2 5c d4 01 	cp.w	r12,250881

80002538 <spk_reply_func>:
			
	
}

void spk_reply_func(xcmp_fragment_t * xcmp)
{
80002538:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
8000253a:	19 a9       	ld.ub	r9,r12[0x2]
8000253c:	30 08       	mov	r8,0
8000253e:	f0 09 18 00 	cp.b	r9,r8
80002542:	c0 f1       	brne	80002560 <spk_reply_func+0x28>
	{
		
		if(xcmp->u8[4])
80002544:	19 e9       	ld.ub	r9,r12[0x6]
80002546:	f0 09 18 00 	cp.b	r9,r8
8000254a:	c0 40       	breq	80002552 <spk_reply_func+0x1a>
		{
			Speaker_is_unmute = 1;
8000254c:	30 19       	mov	r9,1
8000254e:	48 98       	lddpc	r8,80002570 <spk_reply_func+0x38>
80002550:	b0 89       	st.b	r8[0x0],r9
			
			//Silent_flag = 1;
		}
		log("spk OK -st%2x", xcmp->u8[4] );
80002552:	19 e8       	ld.ub	r8,r12[0x6]
80002554:	1a d8       	st.w	--sp,r8
80002556:	48 8c       	lddpc	r12,80002574 <spk_reply_func+0x3c>
80002558:	f0 1f 00 08 	mcall	80002578 <spk_reply_func+0x40>
8000255c:	2f fd       	sub	sp,-4
8000255e:	d8 02       	popm	pc
		
	}
	else
	{
		Speaker_is_unmute = 0;
80002560:	30 09       	mov	r9,0
80002562:	48 48       	lddpc	r8,80002570 <spk_reply_func+0x38>
80002564:	b0 89       	st.b	r8[0x0],r9
		log("spk error");
80002566:	48 6c       	lddpc	r12,8000257c <spk_reply_func+0x44>
80002568:	f0 1f 00 04 	mcall	80002578 <spk_reply_func+0x40>
8000256c:	d8 02       	popm	pc
8000256e:	00 00       	add	r0,r0
80002570:	00 00       	add	r0,r0
80002572:	0a 7d       	tst	sp,r5
80002574:	80 00       	ld.sh	r0,r0[0x0]
80002576:	e2 68 80 00 	mov	r8,163840
8000257a:	7d ec       	ld.w	r12,lr[0x78]
8000257c:	80 00       	ld.sh	r0,r0[0x0]
8000257e:	e2 78 eb cd 	mov	r8,256973

80002580 <mic_brdcst_func>:
	
	
}

void mic_brdcst_func(xcmp_fragment_t * xcmp)
{
80002580:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_brdcast_t *ptr = (MicControl_brdcast_t* )xcmp->u8;
80002584:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r Mic_brdcst \n\r");		
	//log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
	//log("\n\r Signal_type: %x \n\r " ,  ptr->Signaling_Type);
	if (ptr->Mic_State == 0x00)
80002588:	0f a9       	ld.ub	r9,r7[0x2]
8000258a:	30 08       	mov	r8,0
8000258c:	f0 09 18 00 	cp.b	r9,r8
80002590:	c0 71       	brne	8000259e <mic_brdcst_func+0x1e>
	{
		log("\n\r Mic_Disabled \n\r");	
80002592:	48 dc       	lddpc	r12,800025c4 <mic_brdcst_func+0x44>
80002594:	f0 1f 00 0d 	mcall	800025c8 <mic_brdcst_func+0x48>
		Mic_is_Enabled = 0;
80002598:	30 09       	mov	r9,0
8000259a:	48 d8       	lddpc	r8,800025cc <mic_brdcst_func+0x4c>
8000259c:	b0 89       	st.b	r8[0x0],r9
	} 
	if(ptr->Mic_State == 0x11)
8000259e:	0f a9       	ld.ub	r9,r7[0x2]
800025a0:	31 18       	mov	r8,17
800025a2:	f0 09 18 00 	cp.b	r9,r8
800025a6:	c0 d1       	brne	800025c0 <mic_brdcst_func+0x40>
	{
		log("\n\r Mic_Enabled \n\r");
800025a8:	48 ac       	lddpc	r12,800025d0 <mic_brdcst_func+0x50>
800025aa:	f0 1f 00 08 	mcall	800025c8 <mic_brdcst_func+0x48>
		Mic_is_Enabled = 1;
800025ae:	48 89       	lddpc	r9,800025cc <mic_brdcst_func+0x4c>
800025b0:	30 18       	mov	r8,1
800025b2:	b2 88       	st.b	r9[0x0],r8
		
		if ((Mic_is_Enabled == 1) && (Call_Begin == 1))
800025b4:	13 89       	ld.ub	r9,r9[0x0]
800025b6:	f0 09 18 00 	cp.b	r9,r8
800025ba:	c0 31       	brne	800025c0 <mic_brdcst_func+0x40>
800025bc:	48 68       	lddpc	r8,800025d4 <mic_brdcst_func+0x54>
800025be:	11 88       	ld.ub	r8,r8[0x0]
800025c0:	e3 cd 80 80 	ldm	sp++,r7,pc
800025c4:	80 00       	ld.sh	r0,r0[0x0]
800025c6:	e2 84 80 00 	brge	800525c6 <_data_lma+0x43176>
800025ca:	7d ec       	ld.w	r12,lr[0x78]
800025cc:	00 00       	add	r0,r0
800025ce:	0a 7c       	tst	r12,r5
800025d0:	80 00       	ld.sh	r0,r0[0x0]
800025d2:	e2 98 00 00 	brls	800625d2 <_data_lma+0x53182>
800025d6:	0a 8a       	andn	r10,r5

800025d8 <mic_reply_func>:
	
	
}

void mic_reply_func(xcmp_fragment_t * xcmp)
{
800025d8:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_reply_t *ptr = (MicControl_reply_t* )xcmp->u8;
800025dc:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Mic_reply \n\r");
800025e0:	49 ac       	lddpc	r12,80002648 <mic_reply_func+0x70>
800025e2:	f0 1f 00 1b 	mcall	8000264c <mic_reply_func+0x74>
	if (ptr->Result == 0x00)
800025e6:	0f 89       	ld.ub	r9,r7[0x0]
800025e8:	30 08       	mov	r8,0
800025ea:	f0 09 18 00 	cp.b	r9,r8
800025ee:	c2 71       	brne	8000263c <mic_reply_func+0x64>
	{
		
		if (ptr->Function == Mic_Disable)
800025f0:	0f 98       	ld.ub	r8,r7[0x1]
800025f2:	30 29       	mov	r9,2
800025f4:	f2 08 18 00 	cp.b	r8,r9
800025f8:	c1 b1       	brne	8000262e <mic_reply_func+0x56>
		{
		
			log("\n\r Mic_close_ok \n\r " );
800025fa:	49 6c       	lddpc	r12,80002650 <mic_reply_func+0x78>
800025fc:	f0 1f 00 14 	mcall	8000264c <mic_reply_func+0x74>
			log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
80002600:	0f a8       	ld.ub	r8,r7[0x2]
80002602:	1a d8       	st.w	--sp,r8
80002604:	49 4c       	lddpc	r12,80002654 <mic_reply_func+0x7c>
80002606:	f0 1f 00 12 	mcall	8000264c <mic_reply_func+0x74>
			log("\n\r Signaling_type: %x \n\r " ,  ptr->Signaling_Type);
8000260a:	0f b8       	ld.ub	r8,r7[0x3]
8000260c:	1a d8       	st.w	--sp,r8
8000260e:	49 3c       	lddpc	r12,80002658 <mic_reply_func+0x80>
80002610:	f0 1f 00 0f 	mcall	8000264c <mic_reply_func+0x74>
			log("\n\r Mic_state: %x \n\r " ,  ptr->Mic_State);
80002614:	0f c8       	ld.ub	r8,r7[0x4]
80002616:	1a d8       	st.w	--sp,r8
80002618:	49 1c       	lddpc	r12,8000265c <mic_reply_func+0x84>
8000261a:	f0 1f 00 0d 	mcall	8000264c <mic_reply_func+0x74>
			log("\n\r Gain_offset: %x \n\r " ,  ptr->Gain_Offset);
8000261e:	0f d8       	ld.ub	r8,r7[0x5]
80002620:	1a d8       	st.w	--sp,r8
80002622:	49 0c       	lddpc	r12,80002660 <mic_reply_func+0x88>
80002624:	f0 1f 00 0a 	mcall	8000264c <mic_reply_func+0x74>
80002628:	2f cd       	sub	sp,-16
8000262a:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else
		{
			log("\n\r Mic_function: %x \n\r ", ptr->Function );
8000262e:	1a d8       	st.w	--sp,r8
80002630:	48 dc       	lddpc	r12,80002664 <mic_reply_func+0x8c>
80002632:	f0 1f 00 07 	mcall	8000264c <mic_reply_func+0x74>
80002636:	2f fd       	sub	sp,-4
80002638:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else 
	{
		
	
		log("\n\r Mic error \n\r");
8000263c:	48 bc       	lddpc	r12,80002668 <mic_reply_func+0x90>
8000263e:	f0 1f 00 04 	mcall	8000264c <mic_reply_func+0x74>
80002642:	e3 cd 80 80 	ldm	sp++,r7,pc
80002646:	00 00       	add	r0,r0
80002648:	80 00       	ld.sh	r0,r0[0x0]
8000264a:	e2 ac       	*unknown*
8000264c:	80 00       	ld.sh	r0,r0[0x0]
8000264e:	7d ec       	ld.w	r12,lr[0x78]
80002650:	80 00       	ld.sh	r0,r0[0x0]
80002652:	e2 bc       	*unknown*
80002654:	80 00       	ld.sh	r0,r0[0x0]
80002656:	e2 d0 80 00 	satsub.w	r0,r1,-32768
8000265a:	e2 e4 80 00 	ld.d	r4,r1[-32768]
8000265e:	e3 00 80 00 	ld.sh	r0,r1[-32768]
80002662:	e3 18 80 00 	ld.uh	r8,r1[-32768]
80002666:	e3 30 80 00 	ld.ub	r0,r1[-32768]
8000266a:	e3 48 eb cd 	st.w	r1[-5171],r8

8000266c <dcm_brdcst_func>:
	}
}


void dcm_brdcst_func(xcmp_fragment_t * xcmp)
{
8000266c:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	DeviceControlMode_brdcst_t *ptr = (DeviceControlMode_brdcst_t* )xcmp->u8;
80002670:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Dcm_brdcst \n\r");		
80002674:	48 bc       	lddpc	r12,800026a0 <dcm_brdcst_func+0x34>
80002676:	f0 1f 00 0c 	mcall	800026a4 <dcm_brdcst_func+0x38>
	log("\n\r Function: %x \n\r " ,  ptr->Function);
8000267a:	0f 88       	ld.ub	r8,r7[0x0]
8000267c:	1a d8       	st.w	--sp,r8
8000267e:	48 bc       	lddpc	r12,800026a8 <dcm_brdcst_func+0x3c>
80002680:	f0 1f 00 09 	mcall	800026a4 <dcm_brdcst_func+0x38>
	log("\n\r ControlType: %x \n\r " ,  ptr->ControlType);
80002684:	0f a8       	ld.ub	r8,r7[0x2]
80002686:	1a d8       	st.w	--sp,r8
80002688:	48 9c       	lddpc	r12,800026ac <dcm_brdcst_func+0x40>
8000268a:	f0 1f 00 07 	mcall	800026a4 <dcm_brdcst_func+0x38>
	log("\n\r ControlTypeSize: %x \n\r " ,  ptr->ControlTypeSize);
8000268e:	0f 98       	ld.ub	r8,r7[0x1]
80002690:	1a d8       	st.w	--sp,r8
80002692:	48 8c       	lddpc	r12,800026b0 <dcm_brdcst_func+0x44>
80002694:	f0 1f 00 04 	mcall	800026a4 <dcm_brdcst_func+0x38>
80002698:	2f dd       	sub	sp,-12
	
	
}
8000269a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000269e:	00 00       	add	r0,r0
800026a0:	80 00       	ld.sh	r0,r0[0x0]
800026a2:	e3 58 80 00 	st.h	r1[-32768],r8
800026a6:	7d ec       	ld.w	r12,lr[0x78]
800026a8:	80 00       	ld.sh	r0,r0[0x0]
800026aa:	e3 6c 80 00 	st.b	r1[-32768],r12
800026ae:	e3 80       	*unknown*
800026b0:	80 00       	ld.sh	r0,r0[0x0]
800026b2:	e3 98       	*unknown*

800026b4 <dcm_reply_func>:
		log("Tone error");
	}
}

void dcm_reply_func(xcmp_fragment_t * xcmp)
{
800026b4:	eb cd 40 80 	pushm	r7,lr
800026b8:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
800026ba:	19 a9       	ld.ub	r9,r12[0x2]
800026bc:	30 08       	mov	r8,0
800026be:	f0 09 18 00 	cp.b	r9,r8
800026c2:	c1 b1       	brne	800026f8 <dcm_reply_func+0x44>
	{
		if(xcmp->u8[1] == DCM_ENTER)
800026c4:	19 b8       	ld.ub	r8,r12[0x3]
800026c6:	30 19       	mov	r9,1
800026c8:	f2 08 18 00 	cp.b	r8,r9
800026cc:	c0 51       	brne	800026d6 <dcm_reply_func+0x22>
		{
			log("\n\r Dcm-Enter OK \n\r");
800026ce:	48 ec       	lddpc	r12,80002704 <dcm_reply_func+0x50>
800026d0:	f0 1f 00 0e 	mcall	80002708 <dcm_reply_func+0x54>
800026d4:	c0 a8       	rjmp	800026e8 <dcm_reply_func+0x34>
			
		}
		else if (xcmp->u8[1] == DCM_EXIT)
800026d6:	58 08       	cp.w	r8,0
800026d8:	c0 51       	brne	800026e2 <dcm_reply_func+0x2e>
		{
			log("\n\r Dcm-Exit OK \n\r");
800026da:	48 dc       	lddpc	r12,8000270c <dcm_reply_func+0x58>
800026dc:	f0 1f 00 0b 	mcall	80002708 <dcm_reply_func+0x54>
800026e0:	c0 48       	rjmp	800026e8 <dcm_reply_func+0x34>
		}
		else
		{
			log("\n\r Dcm-Revoke \n\r");
800026e2:	48 cc       	lddpc	r12,80002710 <dcm_reply_func+0x5c>
800026e4:	f0 1f 00 09 	mcall	80002708 <dcm_reply_func+0x54>
		}
		
		log("dcm OK-mo%X", xcmp->u8[3]);
800026e8:	0f d8       	ld.ub	r8,r7[0x5]
800026ea:	1a d8       	st.w	--sp,r8
800026ec:	48 ac       	lddpc	r12,80002714 <dcm_reply_func+0x60>
800026ee:	f0 1f 00 07 	mcall	80002708 <dcm_reply_func+0x54>
800026f2:	2f fd       	sub	sp,-4
800026f4:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		log("dcm error");
800026f8:	48 8c       	lddpc	r12,80002718 <dcm_reply_func+0x64>
800026fa:	f0 1f 00 04 	mcall	80002708 <dcm_reply_func+0x54>
800026fe:	e3 cd 80 80 	ldm	sp++,r7,pc
80002702:	00 00       	add	r0,r0
80002704:	80 00       	ld.sh	r0,r0[0x0]
80002706:	e3 b4       	*unknown*
80002708:	80 00       	ld.sh	r0,r0[0x0]
8000270a:	7d ec       	ld.w	r12,lr[0x78]
8000270c:	80 00       	ld.sh	r0,r0[0x0]
8000270e:	e3 c8 80 00 	ldm	r8++,pc
80002712:	e3 dc 80 00 	ldswp.w	r12,r1[0]
80002716:	e3 f0 80 00 	ld.wls	r0,r1[0x0]
8000271a:	e3 fc d4 01 	ld.shvc	r12,r1[0x2]

8000271c <ToneControl_reply_func>:
			//}
		//}
}

void ToneControl_reply_func(xcmp_fragment_t * xcmp)
{
8000271c:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
8000271e:	19 a9       	ld.ub	r9,r12[0x2]
80002720:	30 08       	mov	r8,0
80002722:	f0 09 18 00 	cp.b	r9,r8
80002726:	c0 51       	brne	80002730 <ToneControl_reply_func+0x14>
	{		
		log("Tone OK\n");
80002728:	48 4c       	lddpc	r12,80002738 <ToneControl_reply_func+0x1c>
8000272a:	f0 1f 00 05 	mcall	8000273c <ToneControl_reply_func+0x20>
8000272e:	d8 02       	popm	pc
		//fl_write("/test.txt", FILE_END, (void *)"send tone ok\r\n", sizeof("send tone ok\r\n") - 1);
	}
	else
	{
		log("Tone error");
80002730:	48 4c       	lddpc	r12,80002740 <ToneControl_reply_func+0x24>
80002732:	f0 1f 00 03 	mcall	8000273c <ToneControl_reply_func+0x20>
80002736:	d8 02       	popm	pc
80002738:	80 00       	ld.sh	r0,r0[0x0]
8000273a:	e4 08       	*unknown*
8000273c:	80 00       	ld.sh	r0,r0[0x0]
8000273e:	7d ec       	ld.w	r12,lr[0x78]
80002740:	80 00       	ld.sh	r0,r0[0x0]
80002742:	e4 14 eb cd 	andh	r4,0xebcd

80002744 <app_init>:
	//0x00,0x39


};
void app_init(void)
{	
80002744:	eb cd 40 c0 	pushm	r6-r7,lr
	xcmp_register_app_list(the_app_list);
80002748:	49 7c       	lddpc	r12,800027a4 <app_init+0x60>
8000274a:	f0 1f 00 18 	mcall	800027a8 <app_init+0x64>
	
	//将app_payload_rx_proc更改为PCM加密功能
	payload_init( app_payload_rx_proc , app_payload_tx_proc );
8000274e:	49 8b       	lddpc	r11,800027ac <app_init+0x68>
80002750:	49 8c       	lddpc	r12,800027b0 <app_init+0x6c>
80002752:	f0 1f 00 19 	mcall	800027b4 <app_init+0x70>
	
	/* Create the mutex semaphore to guard a shared global_count.*/
	count_mutex = xSemaphoreCreateMutex();
80002756:	f0 1f 00 19 	mcall	800027b8 <app_init+0x74>
8000275a:	49 98       	lddpc	r8,800027bc <app_init+0x78>
8000275c:	91 0c       	st.w	r8[0x0],r12
	if (count_mutex == NULL)
8000275e:	70 08       	ld.w	r8,r8[0x0]
80002760:	58 08       	cp.w	r8,0
80002762:	c0 41       	brne	8000276a <app_init+0x26>
	{
		log("Create the count_mutex semaphore failure\n");
80002764:	49 7c       	lddpc	r12,800027c0 <app_init+0x7c>
80002766:	f0 1f 00 18 	mcall	800027c4 <app_init+0x80>
	}
	
	static portBASE_TYPE res = 0;
	 res = xTaskCreate(
8000276a:	30 07       	mov	r7,0
8000276c:	1a d7       	st.w	--sp,r7
8000276e:	1a d7       	st.w	--sp,r7
80002770:	1a d7       	st.w	--sp,r7
80002772:	30 28       	mov	r8,2
80002774:	0e 99       	mov	r9,r7
80002776:	e0 6a 02 ee 	mov	r10,750
8000277a:	49 4b       	lddpc	r11,800027c8 <app_init+0x84>
8000277c:	49 4c       	lddpc	r12,800027cc <app_init+0x88>
8000277e:	f0 1f 00 15 	mcall	800027d0 <app_init+0x8c>
80002782:	49 56       	lddpc	r6,800027d4 <app_init+0x90>
80002784:	8d 0c       	st.w	r6[0x0],r12
	,  750//1024//800//384
	,  NULL
	,  2
	,  NULL );
	
	 res = xTaskCreate(
80002786:	1a d7       	st.w	--sp,r7
80002788:	1a d7       	st.w	--sp,r7
8000278a:	1a d7       	st.w	--sp,r7
8000278c:	30 18       	mov	r8,1
8000278e:	0e 99       	mov	r9,r7
80002790:	e0 6a 03 20 	mov	r10,800
80002794:	49 1b       	lddpc	r11,800027d8 <app_init+0x94>
80002796:	49 2c       	lddpc	r12,800027dc <app_init+0x98>
80002798:	f0 1f 00 0e 	mcall	800027d0 <app_init+0x8c>
8000279c:	8d 0c       	st.w	r6[0x0],r12
8000279e:	2f ad       	sub	sp,-24
	 ,  800
	 ,  NULL
	 ,  1
	 ,  NULL );
	
}
800027a0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800027a4:	00 00       	add	r0,r0
800027a6:	00 10       	sub	r0,r0
800027a8:	80 00       	ld.sh	r0,r0[0x0]
800027aa:	48 98       	lddpc	r8,800027cc <app_init+0x88>
800027ac:	80 00       	ld.sh	r0,r0[0x0]
800027ae:	20 58       	sub	r8,5
800027b0:	80 00       	ld.sh	r0,r0[0x0]
800027b2:	20 6c       	sub	r12,6
800027b4:	80 00       	ld.sh	r0,r0[0x0]
800027b6:	35 40       	mov	r0,84
800027b8:	80 00       	ld.sh	r0,r0[0x0]
800027ba:	72 b4       	ld.w	r4,r9[0x2c]
800027bc:	00 00       	add	r0,r0
800027be:	0a 78       	tst	r8,r5
800027c0:	80 00       	ld.sh	r0,r0[0x0]
800027c2:	e4 20 80 00 	sub	r0,294912
800027c6:	7d ec       	ld.w	r12,lr[0x78]
800027c8:	80 00       	ld.sh	r0,r0[0x0]
800027ca:	e4 4c 80 00 	cp.w	r12,294912
800027ce:	29 2c       	sub	r12,-110
800027d0:	80 00       	ld.sh	r0,r0[0x0]
800027d2:	7a 28       	ld.w	r8,sp[0x8]
800027d4:	00 00       	add	r0,r0
800027d6:	0a 64       	and	r4,r5
800027d8:	80 00       	ld.sh	r0,r0[0x0]
800027da:	e4 54 80 00 	cp.w	r4,360448
800027de:	27 e0       	sub	r0,126

800027e0 <send_message>:
extern volatile  xTaskHandle save_handle; 
//extern portTickType water_value;
//extern portTickType tx_water_value;
//extern portTickType log_water_value;
static void send_message(void * pvParameters)
{
800027e0:	d4 31       	pushm	r0-r7,lr
	static U16 message_count =0;
	U32 destination = DEST;
	static  portTickType xLastWakeTime;
	const portTickType xFrequency = 4000;//2s,定时问题已经修正。2s x  2000hz = 4000
	U16  * data_ptr;
	Message_Protocol_t *m_buff = (Message_Protocol_t *) pvPortMalloc(sizeof(Message_Protocol_t));
800027e2:	32 0c       	mov	r12,32
800027e4:	f0 1f 00 3a 	mcall	800028cc <send_message+0xec>
800027e8:	18 94       	mov	r4,r12
	static xgflash_status_t status = XG_ERROR;
	
	xLastWakeTime = xTaskGetTickCount();
800027ea:	f0 1f 00 3a 	mcall	800028d0 <send_message+0xf0>
800027ee:	4b a8       	lddpc	r8,800028d4 <send_message+0xf4>
800027f0:	91 0c       	st.w	r8[0x0],r12
	static  portTickType water_value;
	/*clear xBinarySemaphore and wait Datasession broadcast reply*/
	xSemaphoreTake(xBinarySemaphore, portMAX_DELAY);
800027f2:	4b a8       	lddpc	r8,800028d8 <send_message+0xf8>
800027f4:	70 0c       	ld.w	r12,r8[0x0]
800027f6:	30 09       	mov	r9,0
800027f8:	3f fa       	mov	r10,-1
800027fa:	12 9b       	mov	r11,r9
800027fc:	f0 1f 00 38 	mcall	800028dc <send_message+0xfc>
	
	for (;;)
	{
	
		message_count = xgflash_get_message_count();
80002800:	4b 85       	lddpc	r5,800028e0 <send_message+0x100>
			{
				log("get message err : %d\n", status);
			}
		
		}
		else if (Battery_Flag == Battery_Low)
80002802:	4b 97       	lddpc	r7,800028e4 <send_message+0x104>
80002804:	30 16       	mov	r6,1
	
	for (;;)
	{
	
		message_count = xgflash_get_message_count();
		if( (message_count!=0) && (Battery_Flag == Battery_Okay) && (connect_flag))//有缓存且电量充足，需发送短信
80002806:	4b 93       	lddpc	r3,800028e8 <send_message+0x108>
		{
			log("Current_total_message_count: %d\n", message_count);
80002808:	4b 90       	lddpc	r0,800028ec <send_message+0x10c>
			if(m_buff==NULL)break;
			status = xgflash_get_message_data(message_count, m_buff, TRUE);
8000280a:	30 12       	mov	r2,1
8000280c:	4b 91       	lddpc	r1,800028f0 <send_message+0x110>
	xSemaphoreTake(xBinarySemaphore, portMAX_DELAY);
	
	for (;;)
	{
	
		message_count = xgflash_get_message_count();
8000280e:	f0 1f 00 3a 	mcall	800028f4 <send_message+0x114>
80002812:	5c 8c       	casts.h	r12
80002814:	aa 0c       	st.h	r5[0x0],r12
		if( (message_count!=0) && (Battery_Flag == Battery_Okay) && (connect_flag))//有缓存且电量充足，需发送短信
80002816:	c4 c0       	breq	800028ae <send_message+0xce>
80002818:	0f 88       	ld.ub	r8,r7[0x0]
8000281a:	58 08       	cp.w	r8,0
8000281c:	c4 91       	brne	800028ae <send_message+0xce>
8000281e:	07 88       	ld.ub	r8,r3[0x0]
80002820:	58 08       	cp.w	r8,0
80002822:	c4 60       	breq	800028ae <send_message+0xce>
		{
			log("Current_total_message_count: %d\n", message_count);
80002824:	5c 7c       	castu.h	r12
80002826:	1a dc       	st.w	--sp,r12
80002828:	00 9c       	mov	r12,r0
8000282a:	f0 1f 00 34 	mcall	800028f8 <send_message+0x118>
			if(m_buff==NULL)break;
8000282e:	2f fd       	sub	sp,-4
80002830:	58 04       	cp.w	r4,0
80002832:	c4 b0       	breq	800028c8 <send_message+0xe8>
			status = xgflash_get_message_data(message_count, m_buff, TRUE);
80002834:	04 9a       	mov	r10,r2
80002836:	08 9b       	mov	r11,r4
80002838:	8a 8c       	ld.uh	r12,r5[0x0]
8000283a:	f0 1f 00 31 	mcall	800028fc <send_message+0x11c>
8000283e:	83 0c       	st.w	r1[0x0],r12
			if(status == XG_OK)
80002840:	c3 11       	brne	800028a2 <send_message+0xc2>
			{
				xcmp_data_session_req(m_buff, (sizeof(Message_Protocol_t)), destination);//send message
80002842:	36 4a       	mov	r10,100
80002844:	32 0b       	mov	r11,32
80002846:	08 9c       	mov	r12,r4
80002848:	f0 1f 00 2e 	mcall	80002900 <send_message+0x120>
				
				//if(xSemaphoreTake(SendM_CountingSemaphore, (20000*2) / portTICK_RATE_MS) == pdTRUE)
				if(xSemaphoreTake(xBinarySemaphore, (20000*2) / portTICK_RATE_MS) == pdTRUE)
8000284c:	4a 38       	lddpc	r8,800028d8 <send_message+0xf8>
8000284e:	70 0c       	ld.w	r12,r8[0x0]
80002850:	30 09       	mov	r9,0
80002852:	e0 6a 9c 40 	mov	r10,40000
80002856:	12 9b       	mov	r11,r9
80002858:	f0 1f 00 21 	mcall	800028dc <send_message+0xfc>
8000285c:	58 1c       	cp.w	r12,1
8000285e:	c0 91       	brne	80002870 <send_message+0x90>
				{
					log("xSemaphoreTake okay!\n");
80002860:	4a 9c       	lddpc	r12,80002904 <send_message+0x124>
80002862:	f0 1f 00 26 	mcall	800028f8 <send_message+0x118>
					vTaskDelay((2000*2) / portTICK_RATE_MS);
80002866:	e0 6c 0f a0 	mov	r12,4000
8000286a:	f0 1f 00 28 	mcall	80002908 <send_message+0x128>
8000286e:	c2 78       	rjmp	800028bc <send_message+0xdc>
				}
				else//短信丢失，手台未响应，超时后默认再次重发
				{
					log("xSemaphoreTake failure!\n");
80002870:	4a 7c       	lddpc	r12,8000290c <send_message+0x12c>
80002872:	f0 1f 00 22 	mcall	800028f8 <send_message+0x118>
					xcmp_IdleTestTone(Tone_Start, MANDOWN_DISABLE_TONE);//set tone to indicate send-failure!!!
80002876:	e0 6b 00 b7 	mov	r11,183
8000287a:	04 9c       	mov	r12,r2
8000287c:	f0 1f 00 25 	mcall	80002910 <send_message+0x130>
					status = xgflash_message_save(m_buff, sizeof(Message_Protocol_t), TRUE);
80002880:	04 9a       	mov	r10,r2
80002882:	32 0b       	mov	r11,32
80002884:	08 9c       	mov	r12,r4
80002886:	f0 1f 00 24 	mcall	80002914 <send_message+0x134>
8000288a:	83 0c       	st.w	r1[0x0],r12
					if(status == XG_OK)
8000288c:	c0 51       	brne	80002896 <send_message+0xb6>
					{
						log("save message-2 okay\n");
8000288e:	4a 3c       	lddpc	r12,80002918 <send_message+0x138>
80002890:	f0 1f 00 1a 	mcall	800028f8 <send_message+0x118>
80002894:	c1 48       	rjmp	800028bc <send_message+0xdc>
					}
					else
					{
						log("!!!save message err : %d\n", status);
80002896:	1a dc       	st.w	--sp,r12
80002898:	4a 1c       	lddpc	r12,8000291c <send_message+0x13c>
8000289a:	f0 1f 00 18 	mcall	800028f8 <send_message+0x118>
8000289e:	2f fd       	sub	sp,-4
800028a0:	c0 e8       	rjmp	800028bc <send_message+0xdc>
				
				}
			}
			else
			{
				log("get message err : %d\n", status);
800028a2:	1a dc       	st.w	--sp,r12
800028a4:	49 fc       	lddpc	r12,80002920 <send_message+0x140>
800028a6:	f0 1f 00 15 	mcall	800028f8 <send_message+0x118>
800028aa:	2f fd       	sub	sp,-4
800028ac:	c0 88       	rjmp	800028bc <send_message+0xdc>
			}
		
		}
		else if (Battery_Flag == Battery_Low)
800028ae:	0f 88       	ld.ub	r8,r7[0x0]
800028b0:	ec 08 18 00 	cp.b	r8,r6
800028b4:	c0 41       	brne	800028bc <send_message+0xdc>
		{
			log("The device battery level is low !\n");
800028b6:	49 cc       	lddpc	r12,80002924 <send_message+0x144>
800028b8:	f0 1f 00 10 	mcall	800028f8 <send_message+0x118>
		}
		
		//water_value = uxTaskGetStackHighWaterMark(NULL);
		//log("send-thread water_value: %d\n", water_value);
		vTaskDelayUntil(&xLastWakeTime, (5000*2) / portTICK_RATE_MS  );//精确的以1000ms为周期执行。
800028bc:	e0 6b 27 10 	mov	r11,10000
800028c0:	48 5c       	lddpc	r12,800028d4 <send_message+0xf4>
800028c2:	f0 1f 00 1a 	mcall	80002928 <send_message+0x148>
	
	}
800028c6:	ca 4b       	rjmp	8000280e <send_message+0x2e>
800028c8:	d8 32       	popm	r0-r7,pc
800028ca:	00 00       	add	r0,r0
800028cc:	80 00       	ld.sh	r0,r0[0x0]
800028ce:	6e 60       	ld.w	r0,r7[0x18]
800028d0:	80 00       	ld.sh	r0,r0[0x0]
800028d2:	77 18       	ld.w	r8,r11[0x44]
800028d4:	00 00       	add	r0,r0
800028d6:	0a 6c       	and	r12,r5
800028d8:	00 00       	add	r0,r0
800028da:	0b 9c       	ld.ub	r12,r5[0x1]
800028dc:	80 00       	ld.sh	r0,r0[0x0]
800028de:	6f a8       	ld.w	r8,r7[0x68]
800028e0:	00 00       	add	r0,r0
800028e2:	0a 6a       	and	r10,r5
800028e4:	00 00       	add	r0,r0
800028e6:	0a 88       	andn	r8,r5
800028e8:	00 00       	add	r0,r0
800028ea:	0a 63       	and	r3,r5
800028ec:	80 00       	ld.sh	r0,r0[0x0]
800028ee:	e4 5c 00 00 	cp.w	r12,327680
800028f2:	00 04       	add	r4,r0
800028f4:	80 00       	ld.sh	r0,r0[0x0]
800028f6:	61 3c       	ld.w	r12,r0[0x4c]
800028f8:	80 00       	ld.sh	r0,r0[0x0]
800028fa:	7d ec       	ld.w	r12,lr[0x78]
800028fc:	80 00       	ld.sh	r0,r0[0x0]
800028fe:	5e 5c       	retlt	r12
80002900:	80 00       	ld.sh	r0,r0[0x0]
80002902:	48 ec       	lddpc	r12,80002938 <app_cfg+0xc>
80002904:	80 00       	ld.sh	r0,r0[0x0]
80002906:	e4 80 80 00 	breq	80092906 <_data_lma+0x834b6>
8000290a:	78 80       	ld.w	r0,r12[0x20]
8000290c:	80 00       	ld.sh	r0,r0[0x0]
8000290e:	e4 98 80 00 	brls	800b290e <_data_lma+0xa34be>
80002912:	4a 30       	lddpc	r0,8000299c <app_cfg+0x70>
80002914:	80 00       	ld.sh	r0,r0[0x0]
80002916:	5f ac       	srle	r12
80002918:	80 00       	ld.sh	r0,r0[0x0]
8000291a:	e4 b4       	*unknown*
8000291c:	80 00       	ld.sh	r0,r0[0x0]
8000291e:	e4 cc 80 00 	sub	r12,r2,-32768
80002922:	e4 e8 80 00 	ld.d	r8,r2[-32768]
80002926:	e5 00 80 00 	ld.sh	r0,r2[-32768]
8000292a:	78 c8       	ld.w	r8,r12[0x30]

8000292c <app_cfg>:
}

static __app_Thread_(app_cfg)
{
8000292c:	d4 31       	pushm	r0-r7,lr
8000292e:	20 1d       	sub	sp,4
	U8 Burst_ID = 0;
	char card_id[4]={0};
	U16  * data_ptr;
	static	OB_States OB_State = OB_UNCONNECTEDWAITINGSTATUS;
	static xgflash_status_t status = XG_ERROR;
	xLastWakeTime = xTaskGetTickCount();
80002930:	f0 1f 00 5b 	mcall	80002a9c <app_cfg+0x170>
80002934:	4d b8       	lddpc	r8,80002aa0 <app_cfg+0x174>
80002936:	91 0c       	st.w	r8[0x0],r12
	static  portTickType water_value;
		
	for(;;)
	{
		switch(OB_State)
80002938:	4d b7       	lddpc	r7,80002aa4 <app_cfg+0x178>
				}
								
			break;
			case OB_CONNECTEDWAITTINGSYNTIME:
			
						if(get_time_okay){
8000293a:	4d c3       	lddpc	r3,80002aa8 <app_cfg+0x17c>
							log("get time okay!\n");
							//vTaskResume(save_handle);
						}
						else
						{						
							xcmp_data_session_req(0x00, sizeof(Message_Protocol_t), DEST);//request to get system time						
8000293c:	32 00       	mov	r0,32
8000293e:	30 06       	mov	r6,0
						}
			break;
			case OB_WAITINGAPPTASK:
			
					//if(pdPASS == xQueueReceive(xg_resend_queue, &data_ptr, (2000*2) / portTICK_RATE_MS))
					if(pdPASS == xQueueReceive(xg_resend_queue, &data_ptr, 0))
80002940:	4d b2       	lddpc	r2,80002aac <app_cfg+0x180>
	xLastWakeTime = xTaskGetTickCount();
	static  portTickType water_value;
		
	for(;;)
	{
		switch(OB_State)
80002942:	6e 08       	ld.w	r8,r7[0x0]
80002944:	58 28       	cp.w	r8,2
80002946:	c4 e0       	breq	800029e2 <app_cfg+0xb6>
80002948:	58 38       	cp.w	r8,3
8000294a:	c5 b0       	breq	80002a00 <app_cfg+0xd4>
8000294c:	58 08       	cp.w	r8,0
8000294e:	e0 81 00 a0 	brne	80002a8e <app_cfg+0x162>
		{
			case OB_UNCONNECTEDWAITINGSTATUS:
			
				if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
80002952:	4d 88       	lddpc	r8,80002ab0 <app_cfg+0x184>
80002954:	70 08       	ld.w	r8,r8[0x0]
80002956:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
8000295a:	58 38       	cp.w	r8,3
8000295c:	c2 b1       	brne	800029b2 <app_cfg+0x86>
8000295e:	4d 68       	lddpc	r8,80002ab4 <app_cfg+0x188>
80002960:	11 88       	ld.ub	r8,r8[0x0]
80002962:	58 08       	cp.w	r8,0
80002964:	c2 71       	brne	800029b2 <app_cfg+0x86>
				{
					connect_flag=1;
80002966:	30 19       	mov	r9,1
80002968:	4d 38       	lddpc	r8,80002ab4 <app_cfg+0x188>
8000296a:	b0 89       	st.b	r8[0x0],r9
					xcmp_IdleTestTone(Tone_Start, Priority_Beep);//set tone to indicate connection success!!!
8000296c:	30 cb       	mov	r11,12
8000296e:	30 1c       	mov	r12,1
80002970:	f0 1f 00 52 	mcall	80002ab8 <app_cfg+0x18c>
					xcmp_IdleTestTone(Tone_Start, Priority_Beep);//set tone to indicate connection success!!!
80002974:	30 cb       	mov	r11,12
80002976:	30 1c       	mov	r12,1
80002978:	f0 1f 00 50 	mcall	80002ab8 <app_cfg+0x18c>
					OB_State = OB_CONNECTEDWAITTINGSYNTIME;
8000297c:	30 28       	mov	r8,2
8000297e:	8f 08       	st.w	r7[0x0],r8
					log("connect OB okay!\n");
80002980:	4c fc       	lddpc	r12,80002abc <app_cfg+0x190>
80002982:	f0 1f 00 50 	mcall	80002ac0 <app_cfg+0x194>
					log("XCMP_Version: %d.%d.%d.%d\n", XCMP_Version[0],  XCMP_Version[1],
					XCMP_Version[2],  XCMP_Version[3]);
80002986:	4d 08       	lddpc	r8,80002ac4 <app_cfg+0x198>
80002988:	11 bb       	ld.ub	r11,r8[0x3]
8000298a:	11 aa       	ld.ub	r10,r8[0x2]
					connect_flag=1;
					xcmp_IdleTestTone(Tone_Start, Priority_Beep);//set tone to indicate connection success!!!
					xcmp_IdleTestTone(Tone_Start, Priority_Beep);//set tone to indicate connection success!!!
					OB_State = OB_CONNECTEDWAITTINGSYNTIME;
					log("connect OB okay!\n");
					log("XCMP_Version: %d.%d.%d.%d\n", XCMP_Version[0],  XCMP_Version[1],
8000298c:	11 99       	ld.ub	r9,r8[0x1]
8000298e:	11 88       	ld.ub	r8,r8[0x0]
80002990:	1a db       	st.w	--sp,r11
80002992:	1a da       	st.w	--sp,r10
80002994:	1a d9       	st.w	--sp,r9
80002996:	1a d8       	st.w	--sp,r8
80002998:	4c cc       	lddpc	r12,80002ac8 <app_cfg+0x19c>
8000299a:	f0 1f 00 4a 	mcall	80002ac0 <app_cfg+0x194>
					XCMP_Version[2],  XCMP_Version[3]);
					log("OB_Firmware_Version: %d.%d.%d\n", OB_Firmware_Version[0],  OB_Firmware_Version[1], OB_Firmware_Version[2]);
8000299e:	30 38       	mov	r8,3
800029a0:	1a d8       	st.w	--sp,r8
800029a2:	1a d6       	st.w	--sp,r6
800029a4:	30 18       	mov	r8,1
800029a6:	1a d8       	st.w	--sp,r8
800029a8:	4c 9c       	lddpc	r12,80002acc <app_cfg+0x1a0>
800029aa:	f0 1f 00 46 	mcall	80002ac0 <app_cfg+0x194>
	{
		switch(OB_State)
		{
			case OB_UNCONNECTEDWAITINGSTATUS:
			
				if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
800029ae:	2f 9d       	sub	sp,-28
800029b0:	c6 f8       	rjmp	80002a8e <app_cfg+0x162>

					
				}
				else
				{
					nop();
800029b2:	d7 03       	nop
					nop();
800029b4:	d7 03       	nop
					nop();
800029b6:	d7 03       	nop
					//xcmp_IdleTestTone(Tone_Start, Bad_Key_Chirp);//set tone to indicate connection failure!!!
					log("connecting...\n");
800029b8:	4c 6c       	lddpc	r12,80002ad0 <app_cfg+0x1a4>
800029ba:	f0 1f 00 42 	mcall	80002ac0 <app_cfg+0x194>
					log("Current time is :20%d:%2d:%2d, %2d:%2d:%2d\n",
					Current_time.Year, Current_time.Month, Current_time.Day,
					Current_time.Hour, Current_time.Minute, Current_time.Second);
800029be:	4c 68       	lddpc	r8,80002ad4 <app_cfg+0x1a8>
800029c0:	11 d5       	ld.ub	r5,r8[0x5]
800029c2:	11 cc       	ld.ub	r12,r8[0x4]
800029c4:	11 bb       	ld.ub	r11,r8[0x3]
					nop();
					nop();
					//xcmp_IdleTestTone(Tone_Start, Bad_Key_Chirp);//set tone to indicate connection failure!!!
					log("connecting...\n");
					log("Current time is :20%d:%2d:%2d, %2d:%2d:%2d\n",
					Current_time.Year, Current_time.Month, Current_time.Day,
800029c6:	11 aa       	ld.ub	r10,r8[0x2]
800029c8:	11 99       	ld.ub	r9,r8[0x1]
800029ca:	11 88       	ld.ub	r8,r8[0x0]
					nop();
					nop();
					nop();
					//xcmp_IdleTestTone(Tone_Start, Bad_Key_Chirp);//set tone to indicate connection failure!!!
					log("connecting...\n");
					log("Current time is :20%d:%2d:%2d, %2d:%2d:%2d\n",
800029cc:	1a d5       	st.w	--sp,r5
800029ce:	1a dc       	st.w	--sp,r12
800029d0:	1a db       	st.w	--sp,r11
800029d2:	1a da       	st.w	--sp,r10
800029d4:	1a d9       	st.w	--sp,r9
800029d6:	1a d8       	st.w	--sp,r8
800029d8:	4c 0c       	lddpc	r12,80002ad8 <app_cfg+0x1ac>
800029da:	f0 1f 00 3a 	mcall	80002ac0 <app_cfg+0x194>
800029de:	2f ad       	sub	sp,-24
800029e0:	c5 78       	rjmp	80002a8e <app_cfg+0x162>
				}
								
			break;
			case OB_CONNECTEDWAITTINGSYNTIME:
			
						if(get_time_okay){
800029e2:	07 88       	ld.ub	r8,r3[0x0]
800029e4:	58 08       	cp.w	r8,0
800029e6:	c0 70       	breq	800029f4 <app_cfg+0xc8>
							
							OB_State = OB_WAITINGAPPTASK;
800029e8:	30 38       	mov	r8,3
800029ea:	8f 08       	st.w	r7[0x0],r8
							log("get time okay!\n");
800029ec:	4b cc       	lddpc	r12,80002adc <app_cfg+0x1b0>
800029ee:	f0 1f 00 35 	mcall	80002ac0 <app_cfg+0x194>
800029f2:	c4 e8       	rjmp	80002a8e <app_cfg+0x162>
							//vTaskResume(save_handle);
						}
						else
						{						
							xcmp_data_session_req(0x00, sizeof(Message_Protocol_t), DEST);//request to get system time						
800029f4:	36 4a       	mov	r10,100
800029f6:	00 9b       	mov	r11,r0
800029f8:	0c 9c       	mov	r12,r6
800029fa:	f0 1f 00 3a 	mcall	80002ae0 <app_cfg+0x1b4>
800029fe:	c4 88       	rjmp	80002a8e <app_cfg+0x162>
						}
			break;
			case OB_WAITINGAPPTASK:
			
					//if(pdPASS == xQueueReceive(xg_resend_queue, &data_ptr, (2000*2) / portTICK_RATE_MS))
					if(pdPASS == xQueueReceive(xg_resend_queue, &data_ptr, 0))
80002a00:	64 0c       	ld.w	r12,r2[0x0]
80002a02:	0c 99       	mov	r9,r6
80002a04:	0c 9a       	mov	r10,r6
80002a06:	1a 9b       	mov	r11,sp
80002a08:	f0 1f 00 37 	mcall	80002ae4 <app_cfg+0x1b8>
80002a0c:	58 1c       	cp.w	r12,1
80002a0e:	c3 61       	brne	80002a7a <app_cfg+0x14e>
					{
						if(data_ptr!=NULL){//save message
80002a10:	40 08       	lddsp	r8,sp[0x0]
80002a12:	58 08       	cp.w	r8,0
80002a14:	c3 d0       	breq	80002a8e <app_cfg+0x162>
							
							log("receive okay!\n");
80002a16:	4b 5c       	lddpc	r12,80002ae8 <app_cfg+0x1bc>
80002a18:	f0 1f 00 2a 	mcall	80002ac0 <app_cfg+0x194>
							xSemaphoreTake(count_mutex, portMAX_DELAY);
80002a1c:	4b 44       	lddpc	r4,80002aec <app_cfg+0x1c0>
80002a1e:	68 0c       	ld.w	r12,r4[0x0]
80002a20:	0c 99       	mov	r9,r6
80002a22:	3f fa       	mov	r10,-1
80002a24:	0c 9b       	mov	r11,r6
80002a26:	f0 1f 00 30 	mcall	80002ae4 <app_cfg+0x1b8>
							global_count--;
80002a2a:	4b 25       	lddpc	r5,80002af0 <app_cfg+0x1c4>
80002a2c:	6a 08       	ld.w	r8,r5[0x0]
80002a2e:	20 18       	sub	r8,1
80002a30:	8b 08       	st.w	r5[0x0],r8
							xSemaphoreGive(count_mutex);
80002a32:	68 0c       	ld.w	r12,r4[0x0]
80002a34:	0c 99       	mov	r9,r6
80002a36:	0c 9a       	mov	r10,r6
80002a38:	0c 9b       	mov	r11,r6
80002a3a:	f0 1f 00 2f 	mcall	80002af4 <app_cfg+0x1c8>
							log("global_count:%d\n", global_count);
80002a3e:	6a 08       	ld.w	r8,r5[0x0]
80002a40:	1a d8       	st.w	--sp,r8
80002a42:	4a ec       	lddpc	r12,80002af8 <app_cfg+0x1cc>
80002a44:	f0 1f 00 1f 	mcall	80002ac0 <app_cfg+0x194>
							//Message_Protocol_t *ptr = (Message_Protocol_t* )data_ptr;
							status = xgflash_message_save(data_ptr, sizeof(Message_Protocol_t), TRUE);
80002a48:	30 1a       	mov	r10,1
80002a4a:	00 9b       	mov	r11,r0
80002a4c:	40 1c       	lddsp	r12,sp[0x4]
80002a4e:	f0 1f 00 2c 	mcall	80002afc <app_cfg+0x1d0>
80002a52:	4a c8       	lddpc	r8,80002b00 <app_cfg+0x1d4>
80002a54:	91 0c       	st.w	r8[0x0],r12
							//log("receive data : %d", ptr->data.XG_Time.Second);
							//xcmp_data_session_req(data_ptr, sizeof(Message_Protocol_t), DEST);								
							if(status == XG_OK)
80002a56:	2f fd       	sub	sp,-4
80002a58:	58 0c       	cp.w	r12,0
80002a5a:	c0 51       	brne	80002a64 <app_cfg+0x138>
							{
								log("save message okay\n");
80002a5c:	4a ac       	lddpc	r12,80002b04 <app_cfg+0x1d8>
80002a5e:	f0 1f 00 19 	mcall	80002ac0 <app_cfg+0x194>
80002a62:	c0 68       	rjmp	80002a6e <app_cfg+0x142>
							}
							else
							{
								log("!!! save message err : %d\n", status);
80002a64:	1a dc       	st.w	--sp,r12
80002a66:	4a 9c       	lddpc	r12,80002b08 <app_cfg+0x1dc>
80002a68:	f0 1f 00 16 	mcall	80002ac0 <app_cfg+0x194>
80002a6c:	2f fd       	sub	sp,-4
									
							}
							set_message_store(data_ptr);
80002a6e:	4a 88       	lddpc	r8,80002b0c <app_cfg+0x1e0>
80002a70:	70 0c       	ld.w	r12,r8[0x0]
80002a72:	40 0b       	lddsp	r11,sp[0x0]
80002a74:	f0 1f 00 27 	mcall	80002b10 <app_cfg+0x1e4>
80002a78:	c0 b8       	rjmp	80002a8e <app_cfg+0x162>
						}
						
					}
					else
					{						
						run_counter++;			
80002a7a:	4a 79       	lddpc	r9,80002b14 <app_cfg+0x1e8>
80002a7c:	72 08       	ld.w	r8,r9[0x0]
80002a7e:	2f f8       	sub	r8,-1
80002a80:	93 08       	st.w	r9[0x0],r8
						nop();
80002a82:	d7 03       	nop
						//water_value = uxTaskGetStackHighWaterMark(NULL);
						//log("app-thread water_value: %d\n", water_value);
						log("app task run:%d\n", run_counter);
80002a84:	1a d8       	st.w	--sp,r8
80002a86:	4a 5c       	lddpc	r12,80002b18 <app_cfg+0x1ec>
80002a88:	f0 1f 00 0e 	mcall	80002ac0 <app_cfg+0x194>
80002a8c:	2f fd       	sub	sp,-4
			break;
				
		} //End of switch on OB_State.
		//vTaskDelay(300*2 / portTICK_RATE_MS);//延迟300ms
		//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
		vTaskDelayUntil( &xLastWakeTime, (5000*2) / portTICK_RATE_MS  );//精确的以1000ms为周期执行。
80002a8e:	e0 6b 27 10 	mov	r11,10000
80002a92:	48 4c       	lddpc	r12,80002aa0 <app_cfg+0x174>
80002a94:	f0 1f 00 22 	mcall	80002b1c <app_cfg+0x1f0>
	}
80002a98:	c5 5b       	rjmp	80002942 <app_cfg+0x16>
80002a9a:	00 00       	add	r0,r0
80002a9c:	80 00       	ld.sh	r0,r0[0x0]
80002a9e:	77 18       	ld.w	r8,r11[0x44]
80002aa0:	00 00       	add	r0,r0
80002aa2:	0a 58       	eor	r8,r5
80002aa4:	00 00       	add	r0,r0
80002aa6:	0a 5c       	eor	r12,r5
80002aa8:	00 00       	add	r0,r0
80002aaa:	00 08       	add	r8,r0
80002aac:	00 00       	add	r0,r0
80002aae:	0b 88       	ld.ub	r8,r5[0x0]
80002ab0:	00 00       	add	r0,r0
80002ab2:	0e 18       	sub	r8,r7
80002ab4:	00 00       	add	r0,r0
80002ab6:	0a 63       	and	r3,r5
80002ab8:	80 00       	ld.sh	r0,r0[0x0]
80002aba:	4a 30       	lddpc	r0,80002b44 <Phyuserinput_brdcst_func+0x24>
80002abc:	80 00       	ld.sh	r0,r0[0x0]
80002abe:	e5 24 80 00 	ld.sb	r4,r2[-32768]
80002ac2:	7d ec       	ld.w	r12,lr[0x78]
80002ac4:	00 00       	add	r0,r0
80002ac6:	0e 14       	sub	r4,r7
80002ac8:	80 00       	ld.sh	r0,r0[0x0]
80002aca:	e5 38 80 00 	ld.ub	r8,r2[-32768]
80002ace:	e5 54 80 00 	st.h	r2[-32768],r4
80002ad2:	e5 74 00 00 	stcond	r2[0],r4
80002ad6:	0e 1c       	sub	r12,r7
80002ad8:	80 00       	ld.sh	r0,r0[0x0]
80002ada:	e5 84       	*unknown*
80002adc:	80 00       	ld.sh	r0,r0[0x0]
80002ade:	e5 b0       	*unknown*
80002ae0:	80 00       	ld.sh	r0,r0[0x0]
80002ae2:	48 ec       	lddpc	r12,80002b18 <app_cfg+0x1ec>
80002ae4:	80 00       	ld.sh	r0,r0[0x0]
80002ae6:	6f a8       	ld.w	r8,r7[0x68]
80002ae8:	80 00       	ld.sh	r0,r0[0x0]
80002aea:	e5 c0 00 00 	ldmts	r0,
80002aee:	0a 78       	tst	r8,r5
80002af0:	00 00       	add	r0,r0
80002af2:	0a 80       	andn	r0,r5
80002af4:	80 00       	ld.sh	r0,r0[0x0]
80002af6:	71 b4       	ld.w	r4,r8[0x6c]
80002af8:	80 00       	ld.sh	r0,r0[0x0]
80002afa:	e5 d0 80 00 	ldswp.w	r0,r2[0]
80002afe:	5f ac       	srle	r12
80002b00:	00 00       	add	r0,r0
80002b02:	00 0c       	add	r12,r0
80002b04:	80 00       	ld.sh	r0,r0[0x0]
80002b06:	e5 e4 80 00 	sthh.w	r0[r0],r2:b,r4:b
80002b0a:	e5 f8 00 00 	ld.weq	r8,r2[0x0]
80002b0e:	0b 98       	ld.ub	r8,r5[0x1]
80002b10:	80 00       	ld.sh	r0,r0[0x0]
80002b12:	35 c0       	mov	r0,92
80002b14:	00 00       	add	r0,r0
80002b16:	0a 84       	andn	r4,r5
80002b18:	80 00       	ld.sh	r0,r0[0x0]
80002b1a:	e6 14 80 00 	andh	r4,0x8000,COH
80002b1e:	78 c8       	ld.w	r8,r12[0x30]

80002b20 <Phyuserinput_brdcst_func>:
	
}


void Phyuserinput_brdcst_func(xcmp_fragment_t * xcmp)
{
80002b20:	eb cd 40 80 	pushm	r7,lr
	U8 PUI_State_Min_Value =0;
	U8 PUI_State_Max_Value =0;
	
	PUI_Source = xcmp->u8[0];
	PUI_Type = xcmp ->u8[1];
	PUI_ID = ((xcmp->u8[2]<<8) | xcmp->u8[3]);
80002b24:	19 c7       	ld.ub	r7,r12[0x4]
80002b26:	19 d8       	ld.ub	r8,r12[0x5]
80002b28:	f1 e7 10 87 	or	r7,r8,r7<<0x8
80002b2c:	5c 87       	casts.h	r7
	PUI_State = xcmp->u8[4];
	PUI_State_Min_Value = xcmp->u8[5];
	PUI_State_Max_Value = xcmp->u8[6];
	
	log("PhysicalUserInput_broadcast  \n\r"  );
80002b2e:	48 dc       	lddpc	r12,80002b60 <Phyuserinput_brdcst_func+0x40>
80002b30:	f0 1f 00 0d 	mcall	80002b64 <Phyuserinput_brdcst_func+0x44>
	
	if((PUI_ID == 0x0060) && (PUI_State = 0x02) && (connect_flag == 1)){
80002b34:	36 08       	mov	r8,96
80002b36:	f0 07 19 00 	cp.h	r7,r8
80002b3a:	c1 11       	brne	80002b5c <Phyuserinput_brdcst_func+0x3c>
80002b3c:	48 b8       	lddpc	r8,80002b68 <Phyuserinput_brdcst_func+0x48>
80002b3e:	11 89       	ld.ub	r9,r8[0x0]
80002b40:	30 18       	mov	r8,1
80002b42:	f0 09 18 00 	cp.b	r9,r8
80002b46:	c0 b1       	brne	80002b5c <Phyuserinput_brdcst_func+0x3c>
		//log("send message\n");
		xcmp_IdleTestTone(Tone_Start, Ring_Style_Tone_9);//set tone to indicate the scan!!!
80002b48:	34 5b       	mov	r11,69
80002b4a:	30 1c       	mov	r12,1
80002b4c:	f0 1f 00 08 	mcall	80002b6c <Phyuserinput_brdcst_func+0x4c>
			
		vTaskDelay(1000*2 / portTICK_RATE_MS);//延迟1000ms
80002b50:	e0 6c 07 d0 	mov	r12,2000
80002b54:	f0 1f 00 07 	mcall	80002b70 <Phyuserinput_brdcst_func+0x50>
		//delay_ms(200);
		//rfid_sendID_message();//send message		
		scan_rfid_save_message();
80002b58:	f0 1f 00 07 	mcall	80002b74 <Phyuserinput_brdcst_func+0x54>
80002b5c:	e3 cd 80 80 	ldm	sp++,r7,pc
80002b60:	80 00       	ld.sh	r0,r0[0x0]
80002b62:	e6 28 80 00 	sub	r8,425984
80002b66:	7d ec       	ld.w	r12,lr[0x78]
80002b68:	00 00       	add	r0,r0
80002b6a:	0a 63       	and	r3,r5
80002b6c:	80 00       	ld.sh	r0,r0[0x0]
80002b6e:	4a 30       	lddpc	r0,80002bf8 <DataSession_brdcst_func+0x80>
80002b70:	80 00       	ld.sh	r0,r0[0x0]
80002b72:	78 80       	ld.w	r0,r12[0x20]
80002b74:	80 00       	ld.sh	r0,r0[0x0]
80002b76:	58 e8       	cp.w	r8,14

80002b78 <DataSession_brdcst_func>:
	Battery_Flag = ptr->State;

}

void DataSession_brdcst_func(xcmp_fragment_t * xcmp)
{
80002b78:	d4 21       	pushm	r4-r7,lr
80002b7a:	20 9d       	sub	sp,36
	U32 card_id =0;
	U8 i = 0;
	xgflash_status_t return_value = XG_ERROR;
	
	/*point to xcmp payload*/
	DataSession_brdcst_t *ptr = (DataSession_brdcst_t* )xcmp->u8;
80002b7c:	f8 c6 ff fe 	sub	r6,r12,-2
	
	if (ptr->State == CSBK_DATA_RX_Suc)
80002b80:	0d 88       	ld.ub	r8,r6[0x0]
80002b82:	32 49       	mov	r9,36
80002b84:	f2 08 18 00 	cp.b	r8,r9
80002b88:	c2 a1       	brne	80002bdc <DataSession_brdcst_func+0x64>
	{
		
		log("\n\r CSBK_RX OK \n\r");
80002b8a:	4c fc       	lddpc	r12,80002cc4 <DataSession_brdcst_func+0x14c>
80002b8c:	f0 1f 00 4f 	mcall	80002cc8 <DataSession_brdcst_func+0x150>
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
80002b90:	0d a5       	ld.ub	r5,r6[0x2]
80002b92:	0d b8       	ld.ub	r8,r6[0x3]
80002b94:	f1 e5 10 85 	or	r5,r8,r5<<0x8
80002b98:	5c 85       	casts.h	r5

		log("\n\r Session_ID: %x \n\r",Session_number );
80002b9a:	0d 98       	ld.ub	r8,r6[0x1]
80002b9c:	1a d8       	st.w	--sp,r8
80002b9e:	4c cc       	lddpc	r12,80002ccc <DataSession_brdcst_func+0x154>
80002ba0:	f0 1f 00 4a 	mcall	80002cc8 <DataSession_brdcst_func+0x150>
		log("\n\r paylaod_length: %d \n\r",data_length );
80002ba4:	f1 d5 c0 10 	bfextu	r8,r5,0x0,0x10
80002ba8:	1a d8       	st.w	--sp,r8
80002baa:	4c ac       	lddpc	r12,80002cd0 <DataSession_brdcst_func+0x158>
80002bac:	f0 1f 00 47 	mcall	80002cc8 <DataSession_brdcst_func+0x150>
		for(i=0; i<data_length; i++)
80002bb0:	2f ed       	sub	sp,-8
80002bb2:	58 05       	cp.w	r5,0
80002bb4:	e0 80 00 85 	breq	80002cbe <DataSession_brdcst_func+0x146>
80002bb8:	30 07       	mov	r7,0
		{
			
			//log("\n\r payload[%d]: %X \n\r", i, xcmp->u8[4+i]);
			log("\n\r payload[%d]: %X \n\r", i, ptr->DataPayload.DataPayload[i]);
80002bba:	4c 74       	lddpc	r4,80002cd4 <DataSession_brdcst_func+0x15c>
80002bbc:	ec 07 00 08 	add	r8,r6,r7
80002bc0:	11 c8       	ld.ub	r8,r8[0x4]
80002bc2:	1a d8       	st.w	--sp,r8
80002bc4:	1a d7       	st.w	--sp,r7
80002bc6:	08 9c       	mov	r12,r4
80002bc8:	f0 1f 00 40 	mcall	80002cc8 <DataSession_brdcst_func+0x150>
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);

		log("\n\r Session_ID: %x \n\r",Session_number );
		log("\n\r paylaod_length: %d \n\r",data_length );
		for(i=0; i<data_length; i++)
80002bcc:	2f f7       	sub	r7,-1
80002bce:	5c 57       	castu.b	r7
80002bd0:	2f ed       	sub	sp,-8
80002bd2:	ee 05 19 00 	cp.h	r5,r7
80002bd6:	fe 9b ff f3 	brhi	80002bbc <DataSession_brdcst_func+0x44>
80002bda:	c7 28       	rjmp	80002cbe <DataSession_brdcst_func+0x146>
	else
	{
		//log("\n\r State: 0x %X \n\r", xcmp->u8[0]);
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];				
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
		log("State: %X \n", ptr->State);
80002bdc:	1a d8       	st.w	--sp,r8
80002bde:	4b fc       	lddpc	r12,80002cd8 <DataSession_brdcst_func+0x160>
80002be0:	f0 1f 00 3a 	mcall	80002cc8 <DataSession_brdcst_func+0x150>
		if (ptr->State == DATA_SESSION_TX_Suc)
80002be4:	0d 88       	ld.ub	r8,r6[0x0]
80002be6:	2f fd       	sub	sp,-4
80002be8:	30 39       	mov	r9,3
80002bea:	f2 08 18 00 	cp.b	r8,r9
80002bee:	c0 d1       	brne	80002c08 <DataSession_brdcst_func+0x90>
		{
			log("data transmit success\n");
80002bf0:	4b bc       	lddpc	r12,80002cdc <DataSession_brdcst_func+0x164>
80002bf2:	f0 1f 00 36 	mcall	80002cc8 <DataSession_brdcst_func+0x150>
			vTaskDelay(1000*2 / portTICK_RATE_MS);//延迟1000ms
80002bf6:	e0 6c 07 d0 	mov	r12,2000
80002bfa:	f0 1f 00 3a 	mcall	80002ce0 <DataSession_brdcst_func+0x168>
			xcmp_IdleTestTone(Tone_Start, BT_Connection_Success_Tone);//set tone to indicate connection success!!!
80002bfe:	37 7b       	mov	r11,119
80002c00:	30 1c       	mov	r12,1
80002c02:	f0 1f 00 39 	mcall	80002ce4 <DataSession_brdcst_func+0x16c>
80002c06:	c4 98       	rjmp	80002c98 <DataSession_brdcst_func+0x120>

		}
		else if(ptr->State == DATA_SESSION_TX_Fail)
80002c08:	30 49       	mov	r9,4
80002c0a:	f2 08 18 00 	cp.b	r8,r9
80002c0e:	c4 51       	brne	80002c98 <DataSession_brdcst_func+0x120>
		{
			//Message_Protocol_t  *xgmessage = (Message_Protocol_t  *)ptr->DataPayload.DataPayload;
			Message_Protocol_t  xgmessage;
			memcpy(&xgmessage, ptr->DataPayload.DataPayload, sizeof(Message_Protocol_t));
80002c10:	32 0a       	mov	r10,32
80002c12:	ec cb ff fc 	sub	r11,r6,-4
80002c16:	1a 9c       	mov	r12,sp
80002c18:	f0 1f 00 34 	mcall	80002ce8 <DataSession_brdcst_func+0x170>
			//log("data transmit failure\n");
			//log("xgmessage.XG_Time is :20%d:%2d:%2d, %2d:%2d:%2d\n",
			//xgmessage.data.XG_Time.Year, xgmessage.data.XG_Time.Month, xgmessage.data.XG_Time.Day,
			//xgmessage.data.XG_Time.Hour, xgmessage.data.XG_Time.Minute, xgmessage.data.XG_Time.Second);

			Message_Protocol_t * myptr = get_message_store();	
80002c1c:	4b 48       	lddpc	r8,80002cec <DataSession_brdcst_func+0x174>
80002c1e:	70 0c       	ld.w	r12,r8[0x0]
80002c20:	f0 1f 00 34 	mcall	80002cf0 <DataSession_brdcst_func+0x178>
80002c24:	50 8c       	stdsp	sp[0x20],r12
			if(NULL != myptr)
80002c26:	c3 10       	breq	80002c88 <DataSession_brdcst_func+0x110>
			{
				memcpy(myptr, &xgmessage, sizeof(Message_Protocol_t));			
80002c28:	32 0a       	mov	r10,32
80002c2a:	1a 9b       	mov	r11,sp
80002c2c:	f0 1f 00 2f 	mcall	80002ce8 <DataSession_brdcst_func+0x170>
				//xQueueSend(xg_resend_queue, &myptr, 0);
				if (xQueueSend(xg_resend_queue, &myptr, 0) != pdPASS)
80002c30:	4b 18       	lddpc	r8,80002cf4 <DataSession_brdcst_func+0x17c>
80002c32:	70 0c       	ld.w	r12,r8[0x0]
80002c34:	30 09       	mov	r9,0
80002c36:	12 9a       	mov	r10,r9
80002c38:	fa cb ff e0 	sub	r11,sp,-32
80002c3c:	f0 1f 00 2f 	mcall	80002cf8 <DataSession_brdcst_func+0x180>
80002c40:	58 1c       	cp.w	r12,1
80002c42:	c1 10       	breq	80002c64 <DataSession_brdcst_func+0xec>
				{
					log("xg_resend_queue: full\n" );
80002c44:	4a ec       	lddpc	r12,80002cfc <DataSession_brdcst_func+0x184>
80002c46:	f0 1f 00 21 	mcall	80002cc8 <DataSession_brdcst_func+0x150>
					xcmp_IdleTestTone(Tone_Start, Dispatch_Busy);//set tone to indicate queue full!!!
80002c4a:	32 3b       	mov	r11,35
80002c4c:	30 1c       	mov	r12,1
80002c4e:	f0 1f 00 26 	mcall	80002ce4 <DataSession_brdcst_func+0x16c>
					vTaskDelay(3000*2 / portTICK_RATE_MS);//延迟3000ms
80002c52:	e0 6c 17 70 	mov	r12,6000
80002c56:	f0 1f 00 23 	mcall	80002ce0 <DataSession_brdcst_func+0x168>
					xcmp_IdleTestTone(Tone_Stop, Dispatch_Busy);//set tone to indicate queue full!!!
80002c5a:	32 3b       	mov	r11,35
80002c5c:	30 0c       	mov	r12,0
80002c5e:	f0 1f 00 22 	mcall	80002ce4 <DataSession_brdcst_func+0x16c>
80002c62:	c1 68       	rjmp	80002c8e <DataSession_brdcst_func+0x116>
				}
				else
				{
					xSemaphoreTake(count_mutex, portMAX_DELAY);
80002c64:	4a 77       	lddpc	r7,80002d00 <DataSession_brdcst_func+0x188>
80002c66:	6e 0c       	ld.w	r12,r7[0x0]
80002c68:	30 09       	mov	r9,0
80002c6a:	3f fa       	mov	r10,-1
80002c6c:	12 9b       	mov	r11,r9
80002c6e:	f0 1f 00 26 	mcall	80002d04 <DataSession_brdcst_func+0x18c>
					global_count++;
80002c72:	4a 68       	lddpc	r8,80002d08 <DataSession_brdcst_func+0x190>
80002c74:	70 09       	ld.w	r9,r8[0x0]
80002c76:	2f f9       	sub	r9,-1
80002c78:	91 09       	st.w	r8[0x0],r9
					xSemaphoreGive(count_mutex);
80002c7a:	6e 0c       	ld.w	r12,r7[0x0]
80002c7c:	30 09       	mov	r9,0
80002c7e:	12 9a       	mov	r10,r9
80002c80:	12 9b       	mov	r11,r9
80002c82:	f0 1f 00 1e 	mcall	80002cf8 <DataSession_brdcst_func+0x180>
80002c86:	c0 48       	rjmp	80002c8e <DataSession_brdcst_func+0x116>
				}
			}
			else
			{
				log("myptr: err\n\r" );
80002c88:	4a 1c       	lddpc	r12,80002d0c <DataSession_brdcst_func+0x194>
80002c8a:	f0 1f 00 10 	mcall	80002cc8 <DataSession_brdcst_func+0x150>
			}
			xcmp_IdleTestTone(Tone_Start, MANDOWN_DISABLE_TONE);//set tone to indicate send-failure!!!
80002c8e:	e0 6b 00 b7 	mov	r11,183
80002c92:	30 1c       	mov	r12,1
80002c94:	f0 1f 00 14 	mcall	80002ce4 <DataSession_brdcst_func+0x16c>
			
		}
		
		if((ptr->State == DATA_SESSION_TX_Fail) || (ptr->State == DATA_SESSION_TX_Suc))
80002c98:	0d 89       	ld.ub	r9,r6[0x0]
80002c9a:	20 39       	sub	r9,3
80002c9c:	30 18       	mov	r8,1
80002c9e:	f0 09 18 00 	cp.b	r9,r8
80002ca2:	e0 8b 00 0e 	brhi	80002cbe <DataSession_brdcst_func+0x146>
		{		
			//if( xSemaphoreGive( SendM_CountingSemaphore ) != pdTRUE )
			if( xSemaphoreGive( xBinarySemaphore ) != pdTRUE )
80002ca6:	49 b8       	lddpc	r8,80002d10 <DataSession_brdcst_func+0x198>
80002ca8:	70 0c       	ld.w	r12,r8[0x0]
80002caa:	30 09       	mov	r9,0
80002cac:	12 9a       	mov	r10,r9
80002cae:	12 9b       	mov	r11,r9
80002cb0:	f0 1f 00 12 	mcall	80002cf8 <DataSession_brdcst_func+0x180>
80002cb4:	58 1c       	cp.w	r12,1
80002cb6:	c0 40       	breq	80002cbe <DataSession_brdcst_func+0x146>
			{
				log("xSemaphoreGive: err\n\r" );
80002cb8:	49 7c       	lddpc	r12,80002d14 <DataSession_brdcst_func+0x19c>
80002cba:	f0 1f 00 04 	mcall	80002cc8 <DataSession_brdcst_func+0x150>
				//
		//}
		
	}
	
}
80002cbe:	2f 7d       	sub	sp,-36
80002cc0:	d8 22       	popm	r4-r7,pc
80002cc2:	00 00       	add	r0,r0
80002cc4:	80 00       	ld.sh	r0,r0[0x0]
80002cc6:	e6 48 80 00 	cp.w	r8,425984
80002cca:	7d ec       	ld.w	r12,lr[0x78]
80002ccc:	80 00       	ld.sh	r0,r0[0x0]
80002cce:	e6 5c 80 00 	cp.w	r12,491520
80002cd2:	e6 74 80 00 	mov	r4,491520
80002cd6:	e6 90 80 00 	breq	800f2cd6 <_data_lma+0xe3886>
80002cda:	e6 a8       	*unknown*
80002cdc:	80 00       	ld.sh	r0,r0[0x0]
80002cde:	e6 b4       	*unknown*
80002ce0:	80 00       	ld.sh	r0,r0[0x0]
80002ce2:	78 80       	ld.w	r0,r12[0x20]
80002ce4:	80 00       	ld.sh	r0,r0[0x0]
80002ce6:	4a 30       	lddpc	r0,80002d70 <send_flash_command+0x8>
80002ce8:	80 00       	ld.sh	r0,r0[0x0]
80002cea:	86 8e       	ld.uh	lr,r3[0x0]
80002cec:	00 00       	add	r0,r0
80002cee:	0b 98       	ld.ub	r8,r5[0x1]
80002cf0:	80 00       	ld.sh	r0,r0[0x0]
80002cf2:	37 6c       	mov	r12,118
80002cf4:	00 00       	add	r0,r0
80002cf6:	0b 88       	ld.ub	r8,r5[0x0]
80002cf8:	80 00       	ld.sh	r0,r0[0x0]
80002cfa:	71 b4       	ld.w	r4,r8[0x6c]
80002cfc:	80 00       	ld.sh	r0,r0[0x0]
80002cfe:	e6 cc 00 00 	sub	r12,r3,0
80002d02:	0a 78       	tst	r8,r5
80002d04:	80 00       	ld.sh	r0,r0[0x0]
80002d06:	6f a8       	ld.w	r8,r7[0x68]
80002d08:	00 00       	add	r0,r0
80002d0a:	0a 80       	andn	r0,r5
80002d0c:	80 00       	ld.sh	r0,r0[0x0]
80002d0e:	e6 e4 00 00 	ld.d	r4,r3[0]
80002d12:	0b 9c       	ld.ub	r12,r5[0x1]
80002d14:	80 00       	ld.sh	r0,r0[0x0]
80002d16:	e6 f4 eb cd 	ld.w	r4,r3[-5171]

80002d18 <DeviceInitializationStatus_brdcst_func>:


//app func--list

void DeviceInitializationStatus_brdcst_func(xcmp_fragment_t  * xcmp)
{
80002d18:	eb cd 40 80 	pushm	r7,lr
		/*point to xcmp payload*/
		DeviceInitializationStatus_brdcst_t *ptr = (DeviceInitializationStatus_brdcst_t* )xcmp->u8;
80002d1c:	f8 c7 ff fe 	sub	r7,r12,-2
		
		//log("DeviceInitializationStatus_brdcst...\n");
		
		memcpy(XCMP_Version, &(ptr->XCMPVersion[0]), sizeof(XCMP_Version));
80002d20:	30 4a       	mov	r10,4
80002d22:	0e 9b       	mov	r11,r7
80002d24:	48 dc       	lddpc	r12,80002d58 <DeviceInitializationStatus_brdcst_func+0x40>
80002d26:	f0 1f 00 0e 	mcall	80002d5c <DeviceInitializationStatus_brdcst_func+0x44>
		
		if (ptr->DeviceInitType == Device_Init_Complete)
80002d2a:	0f c8       	ld.ub	r8,r7[0x4]
80002d2c:	30 19       	mov	r9,1
80002d2e:	f2 08 18 00 	cp.b	r8,r9
80002d32:	c0 71       	brne	80002d40 <DeviceInitializationStatus_brdcst_func+0x28>
		{
			bunchofrandomstatusflags |= 0x01;  //Need do nothing else.
80002d34:	48 b8       	lddpc	r8,80002d60 <DeviceInitializationStatus_brdcst_func+0x48>
80002d36:	70 09       	ld.w	r9,r8[0x0]
80002d38:	a1 a9       	sbr	r9,0x0
80002d3a:	91 09       	st.w	r8[0x0],r9
80002d3c:	e3 cd 80 80 	ldm	sp++,r7,pc
		}
		else if(ptr->DeviceInitType  == Device_Init_Status)
80002d40:	58 08       	cp.w	r8,0
80002d42:	c0 81       	brne	80002d52 <DeviceInitializationStatus_brdcst_func+0x3a>
		{
			bunchofrandomstatusflags  &= 0xFFFFFFFC; //Device Init no longer Complete.
80002d44:	48 78       	lddpc	r8,80002d60 <DeviceInitializationStatus_brdcst_func+0x48>
80002d46:	70 09       	ld.w	r9,r8[0x0]
80002d48:	e0 19 ff fc 	andl	r9,0xfffc
80002d4c:	91 09       	st.w	r8[0x0],r9
			xcmp_DeviceInitializationStatus_request();
80002d4e:	f0 1f 00 06 	mcall	80002d64 <DeviceInitializationStatus_brdcst_func+0x4c>
80002d52:	e3 cd 80 80 	ldm	sp++,r7,pc
80002d56:	00 00       	add	r0,r0
80002d58:	00 00       	add	r0,r0
80002d5a:	0e 14       	sub	r4,r7
80002d5c:	80 00       	ld.sh	r0,r0[0x0]
80002d5e:	86 8e       	ld.uh	lr,r3[0x0]
80002d60:	00 00       	add	r0,r0
80002d62:	0e 18       	sub	r8,r7
80002d64:	80 00       	ld.sh	r0,r0[0x0]
80002d66:	49 7c       	lddpc	r12,80002dc0 <send_flash_command+0x58>

80002d68 <send_flash_command>:
* ----------  --------  ----------  --------------------------------------------
* 10-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
U16 send_flash_command(U16 command, U32 address, U8 *data_ptr, U16 length)
{
80002d68:	eb cd 40 fc 	pushm	r2-r7,lr
80002d6c:	20 1d       	sub	sp,4
80002d6e:	18 97       	mov	r7,r12
80002d70:	14 95       	mov	r5,r10
80002d72:	12 96       	mov	r6,r9
	U16 status = 1;
80002d74:	30 18       	mov	r8,1
80002d76:	ba 18       	st.h	sp[0x2],r8
	U16 i = 0;

    /* in order to call spi_write(U16* data), change 3-bytes address to 3-U16 address */
	U16 addr[3];
	addr[2] = (address & 0x00ff0000) >> 16;
80002d78:	e9 db c2 08 	bfextu	r4,r11,0x10,0x8
	addr[1] = (address & 0x0000ff00) >> 8;
80002d7c:	e7 db c1 08 	bfextu	r3,r11,0x8,0x8
	addr[0] = (address & 0x000000ff);
80002d80:	e5 db c0 08 	bfextu	r2,r11,0x0,0x8

	U16 data_u16;

	spi_selectChip(spi, DF_SPI_PCS_1);
80002d84:	30 1b       	mov	r11,1
80002d86:	4e 58       	lddpc	r8,80002f18 <send_flash_command+0x1b0>
80002d88:	70 0c       	ld.w	r12,r8[0x0]
80002d8a:	f0 1f 00 65 	mcall	80002f1c <send_flash_command+0x1b4>

    switch (command)
80002d8e:	30 58       	mov	r8,5
80002d90:	f0 07 19 00 	cp.h	r7,r8
80002d94:	c3 40       	breq	80002dfc <send_flash_command+0x94>
80002d96:	e0 8b 00 18 	brhi	80002dc6 <send_flash_command+0x5e>
80002d9a:	30 28       	mov	r8,2
80002d9c:	f0 07 19 00 	cp.h	r7,r8
80002da0:	c5 e0       	breq	80002e5c <send_flash_command+0xf4>
80002da2:	e0 8b 00 08 	brhi	80002db2 <send_flash_command+0x4a>
80002da6:	30 18       	mov	r8,1
80002da8:	f0 07 19 00 	cp.h	r7,r8
80002dac:	e0 81 00 ad 	brne	80002f06 <send_flash_command+0x19e>
80002db0:	c9 e8       	rjmp	80002eec <send_flash_command+0x184>
80002db2:	30 38       	mov	r8,3
80002db4:	f0 07 19 00 	cp.h	r7,r8
80002db8:	c7 20       	breq	80002e9c <send_flash_command+0x134>
80002dba:	30 48       	mov	r8,4
80002dbc:	f0 07 19 00 	cp.h	r7,r8
80002dc0:	e0 81 00 a3 	brne	80002f06 <send_flash_command+0x19e>
80002dc4:	c2 c8       	rjmp	80002e1c <send_flash_command+0xb4>
80002dc6:	35 28       	mov	r8,82
80002dc8:	f0 07 19 00 	cp.h	r7,r8
80002dcc:	c2 f0       	breq	80002e2a <send_flash_command+0xc2>
80002dce:	e0 8b 00 0c 	brhi	80002de6 <send_flash_command+0x7e>
80002dd2:	30 68       	mov	r8,6
80002dd4:	f0 07 19 00 	cp.h	r7,r8
80002dd8:	c2 20       	breq	80002e1c <send_flash_command+0xb4>
80002dda:	32 08       	mov	r8,32
80002ddc:	f0 07 19 00 	cp.h	r7,r8
80002de0:	e0 81 00 93 	brne	80002f06 <send_flash_command+0x19e>
80002de4:	c2 38       	rjmp	80002e2a <send_flash_command+0xc2>
80002de6:	36 08       	mov	r8,96
80002de8:	f0 07 19 00 	cp.h	r7,r8
80002dec:	c3 20       	breq	80002e50 <send_flash_command+0xe8>
80002dee:	e0 68 00 d8 	mov	r8,216
80002df2:	f0 07 19 00 	cp.h	r7,r8
80002df6:	e0 81 00 88 	brne	80002f06 <send_flash_command+0x19e>
80002dfa:	c1 88       	rjmp	80002e2a <send_flash_command+0xc2>
	{
		case READ_STATUS_REG:
			spi_write_byte(command);
80002dfc:	4c 77       	lddpc	r7,80002f18 <send_flash_command+0x1b0>
80002dfe:	30 5b       	mov	r11,5
80002e00:	6e 0c       	ld.w	r12,r7[0x0]
80002e02:	f0 1f 00 48 	mcall	80002f20 <send_flash_command+0x1b8>
			spi_write_dummy();
80002e06:	e0 6b 00 ff 	mov	r11,255
80002e0a:	6e 0c       	ld.w	r12,r7[0x0]
80002e0c:	f0 1f 00 45 	mcall	80002f20 <send_flash_command+0x1b8>
			spi_read_byte(&status);
80002e10:	fa cb ff fe 	sub	r11,sp,-2
80002e14:	6e 0c       	ld.w	r12,r7[0x0]
80002e16:	f0 1f 00 44 	mcall	80002f24 <send_flash_command+0x1bc>
			break;
80002e1a:	c7 68       	rjmp	80002f06 <send_flash_command+0x19e>
		case WRITE_ENABLE:
		case WRITE_DISABLE:
			spi_write_byte(command);
80002e1c:	0e 9b       	mov	r11,r7
80002e1e:	5c 7b       	castu.h	r11
80002e20:	4b e8       	lddpc	r8,80002f18 <send_flash_command+0x1b0>
80002e22:	70 0c       	ld.w	r12,r8[0x0]
80002e24:	f0 1f 00 3f 	mcall	80002f20 <send_flash_command+0x1b8>
			break;
80002e28:	c6 f8       	rjmp	80002f06 <send_flash_command+0x19e>
		case BLOCK_ERASE_4KB:
		case BLOCK_ERASE_32KB:
		case BLOCK_ERASE_64KB:
			spi_write_byte(command);
80002e2a:	4b c6       	lddpc	r6,80002f18 <send_flash_command+0x1b0>
80002e2c:	0e 9b       	mov	r11,r7
80002e2e:	5c 7b       	castu.h	r11
80002e30:	6c 0c       	ld.w	r12,r6[0x0]
80002e32:	f0 1f 00 3c 	mcall	80002f20 <send_flash_command+0x1b8>
			spi_write_byte(addr[2]);
80002e36:	08 9b       	mov	r11,r4
80002e38:	6c 0c       	ld.w	r12,r6[0x0]
80002e3a:	f0 1f 00 3a 	mcall	80002f20 <send_flash_command+0x1b8>
			spi_write_byte(addr[1]);
80002e3e:	06 9b       	mov	r11,r3
80002e40:	6c 0c       	ld.w	r12,r6[0x0]
80002e42:	f0 1f 00 38 	mcall	80002f20 <send_flash_command+0x1b8>
			spi_write_byte(addr[0]);
80002e46:	04 9b       	mov	r11,r2
80002e48:	6c 0c       	ld.w	r12,r6[0x0]
80002e4a:	f0 1f 00 36 	mcall	80002f20 <send_flash_command+0x1b8>
			break;
80002e4e:	c5 c8       	rjmp	80002f06 <send_flash_command+0x19e>
		case CHIP_ERASE:
			spi_write_byte(command);
80002e50:	36 0b       	mov	r11,96
80002e52:	4b 28       	lddpc	r8,80002f18 <send_flash_command+0x1b0>
80002e54:	70 0c       	ld.w	r12,r8[0x0]
80002e56:	f0 1f 00 33 	mcall	80002f20 <send_flash_command+0x1b8>
			break;
80002e5a:	c5 68       	rjmp	80002f06 <send_flash_command+0x19e>
		case BYTE_PROGRAM: /* PAGE_PROGRAM use the same value */
			spi_write_byte(command);
80002e5c:	4a f7       	lddpc	r7,80002f18 <send_flash_command+0x1b0>
80002e5e:	30 2b       	mov	r11,2
80002e60:	6e 0c       	ld.w	r12,r7[0x0]
80002e62:	f0 1f 00 30 	mcall	80002f20 <send_flash_command+0x1b8>
			spi_write_byte(addr[2]);
80002e66:	08 9b       	mov	r11,r4
80002e68:	6e 0c       	ld.w	r12,r7[0x0]
80002e6a:	f0 1f 00 2e 	mcall	80002f20 <send_flash_command+0x1b8>
			spi_write_byte(addr[1]);
80002e6e:	06 9b       	mov	r11,r3
80002e70:	6e 0c       	ld.w	r12,r7[0x0]
80002e72:	f0 1f 00 2c 	mcall	80002f20 <send_flash_command+0x1b8>
			spi_write_byte(addr[0]);
80002e76:	04 9b       	mov	r11,r2
80002e78:	6e 0c       	ld.w	r12,r7[0x0]
80002e7a:	f0 1f 00 2a 	mcall	80002f20 <send_flash_command+0x1b8>
			for (i = 0; i < length; i++)
80002e7e:	58 06       	cp.w	r6,0
80002e80:	c4 30       	breq	80002f06 <send_flash_command+0x19e>
80002e82:	0a 97       	mov	r7,r5
			{
				data_u16 = (*data_ptr)&0x00ff;//modified by huayi
				data_ptr++;
				spi_write_byte(data_u16);
80002e84:	4a 54       	lddpc	r4,80002f18 <send_flash_command+0x1b0>
			spi_write_byte(addr[2]);
			spi_write_byte(addr[1]);
			spi_write_byte(addr[0]);
			for (i = 0; i < length; i++)
			{
				data_u16 = (*data_ptr)&0x00ff;//modified by huayi
80002e86:	0f 3b       	ld.ub	r11,r7++
80002e88:	ba 0b       	st.h	sp[0x0],r11
				data_ptr++;
				spi_write_byte(data_u16);
80002e8a:	68 0c       	ld.w	r12,r4[0x0]
80002e8c:	f0 1f 00 25 	mcall	80002f20 <send_flash_command+0x1b8>
		case BYTE_PROGRAM: /* PAGE_PROGRAM use the same value */
			spi_write_byte(command);
			spi_write_byte(addr[2]);
			spi_write_byte(addr[1]);
			spi_write_byte(addr[0]);
			for (i = 0; i < length; i++)
80002e90:	0e 98       	mov	r8,r7
80002e92:	0a 18       	sub	r8,r5
80002e94:	ec 08 19 00 	cp.h	r8,r6
80002e98:	cf 73       	brcs	80002e86 <send_flash_command+0x11e>
80002e9a:	c3 68       	rjmp	80002f06 <send_flash_command+0x19e>
				data_ptr++;
				spi_write_byte(data_u16);
			}
			break;
		case READ_ARRAY:
			spi_write_byte(command);
80002e9c:	49 f7       	lddpc	r7,80002f18 <send_flash_command+0x1b0>
80002e9e:	30 3b       	mov	r11,3
80002ea0:	6e 0c       	ld.w	r12,r7[0x0]
80002ea2:	f0 1f 00 20 	mcall	80002f20 <send_flash_command+0x1b8>
			spi_write_byte(addr[2]);
80002ea6:	08 9b       	mov	r11,r4
80002ea8:	6e 0c       	ld.w	r12,r7[0x0]
80002eaa:	f0 1f 00 1e 	mcall	80002f20 <send_flash_command+0x1b8>
			spi_write_byte(addr[1]);
80002eae:	06 9b       	mov	r11,r3
80002eb0:	6e 0c       	ld.w	r12,r7[0x0]
80002eb2:	f0 1f 00 1c 	mcall	80002f20 <send_flash_command+0x1b8>
			spi_write_byte(addr[0]);
80002eb6:	04 9b       	mov	r11,r2
80002eb8:	6e 0c       	ld.w	r12,r7[0x0]
80002eba:	f0 1f 00 1a 	mcall	80002f20 <send_flash_command+0x1b8>
			for (i = 0; i < length; i++)
80002ebe:	58 06       	cp.w	r6,0
80002ec0:	c2 30       	breq	80002f06 <send_flash_command+0x19e>
80002ec2:	0a 97       	mov	r7,r5
			{
				spi_write_dummy();
80002ec4:	49 54       	lddpc	r4,80002f18 <send_flash_command+0x1b0>
80002ec6:	e0 63 00 ff 	mov	r3,255
				spi_read_byte(&data_u16);
80002eca:	1a 92       	mov	r2,sp
			spi_write_byte(addr[2]);
			spi_write_byte(addr[1]);
			spi_write_byte(addr[0]);
			for (i = 0; i < length; i++)
			{
				spi_write_dummy();
80002ecc:	06 9b       	mov	r11,r3
80002ece:	68 0c       	ld.w	r12,r4[0x0]
80002ed0:	f0 1f 00 14 	mcall	80002f20 <send_flash_command+0x1b8>
				spi_read_byte(&data_u16);
80002ed4:	1a 9b       	mov	r11,sp
80002ed6:	68 0c       	ld.w	r12,r4[0x0]
80002ed8:	f0 1f 00 13 	mcall	80002f24 <send_flash_command+0x1bc>
				*data_ptr = (U8)data_u16;
80002edc:	9a 08       	ld.sh	r8,sp[0x0]
80002ede:	0e c8       	st.b	r7++,r8
		case READ_ARRAY:
			spi_write_byte(command);
			spi_write_byte(addr[2]);
			spi_write_byte(addr[1]);
			spi_write_byte(addr[0]);
			for (i = 0; i < length; i++)
80002ee0:	0e 98       	mov	r8,r7
80002ee2:	0a 18       	sub	r8,r5
80002ee4:	ec 08 19 00 	cp.h	r8,r6
80002ee8:	cf 23       	brcs	80002ecc <send_flash_command+0x164>
80002eea:	c0 e8       	rjmp	80002f06 <send_flash_command+0x19e>
				*data_ptr = (U8)data_u16;
				data_ptr++;
			}
			break;
		case WRITE_STATUS_REG_BYTE_1:
			spi_write_byte(command);
80002eec:	48 b7       	lddpc	r7,80002f18 <send_flash_command+0x1b0>
80002eee:	30 1b       	mov	r11,1
80002ef0:	6e 0c       	ld.w	r12,r7[0x0]
80002ef2:	f0 1f 00 0c 	mcall	80002f20 <send_flash_command+0x1b8>
			spi_write_byte(UNPROTECT_ALL_SECTORS);
80002ef6:	30 0b       	mov	r11,0
80002ef8:	6e 0c       	ld.w	r12,r7[0x0]
80002efa:	f0 1f 00 0a 	mcall	80002f20 <send_flash_command+0x1b8>
			spi_write_byte(UNPROTECT_ALL_SECTORS);
80002efe:	30 0b       	mov	r11,0
80002f00:	6e 0c       	ld.w	r12,r7[0x0]
80002f02:	f0 1f 00 08 	mcall	80002f20 <send_flash_command+0x1b8>
			break;
		default:
			break;
	}

	spi_unselectChip(spi, DF_SPI_PCS_1);
80002f06:	30 1b       	mov	r11,1
80002f08:	48 48       	lddpc	r8,80002f18 <send_flash_command+0x1b0>
80002f0a:	70 0c       	ld.w	r12,r8[0x0]
80002f0c:	f0 1f 00 07 	mcall	80002f28 <send_flash_command+0x1c0>

	return status;
}
80002f10:	9a 1c       	ld.sh	r12,sp[0x2]
80002f12:	2f fd       	sub	sp,-4
80002f14:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80002f18:	00 00       	add	r0,r0
80002f1a:	1e 2c       	rsub	r12,pc
80002f1c:	80 00       	ld.sh	r0,r0[0x0]
80002f1e:	68 10       	ld.w	r0,r4[0x4]
80002f20:	80 00       	ld.sh	r0,r0[0x0]
80002f22:	66 aa       	ld.w	r10,r3[0x28]
80002f24:	80 00       	ld.sh	r0,r0[0x0]
80002f26:	66 c6       	ld.w	r6,r3[0x30]
80002f28:	80 00       	ld.sh	r0,r0[0x0]
80002f2a:	67 d0       	ld.w	r0,r3[0x74]

80002f2c <data_flash_read_block>:
* ----------  --------  ----------  --------------------------------------------
* 25-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_read_block(U32 address, U16 length, U8 *data_ptr)
{
80002f2c:	d4 01       	pushm	lr
	/* check input parameter */
	if (data_ptr == NULL || address >= DF_MAX_ADDR || length > 0x1000)
80002f2e:	58 0a       	cp.w	r10,0
80002f30:	5f 09       	sreq	r9
80002f32:	e0 68 ff fe 	mov	r8,65534
80002f36:	ea 18 00 7f 	orh	r8,0x7f
80002f3a:	10 3c       	cp.w	r12,r8
80002f3c:	5f b8       	srhi	r8
80002f3e:	f3 e8 10 08 	or	r8,r9,r8
80002f42:	c0 e1       	brne	80002f5e <data_flash_read_block+0x32>
80002f44:	e0 68 10 00 	mov	r8,4096
80002f48:	f0 0b 19 00 	cp.h	r11,r8
80002f4c:	e0 8b 00 09 	brhi	80002f5e <data_flash_read_block+0x32>
	{
		return DF_INVALID_PARAM;
	}

	send_flash_command(READ_ARRAY, address, data_ptr, length);
80002f50:	f3 db c0 10 	bfextu	r9,r11,0x0,0x10
80002f54:	18 9b       	mov	r11,r12
80002f56:	30 3c       	mov	r12,3
80002f58:	f0 1f 00 02 	mcall	80002f60 <data_flash_read_block+0x34>
80002f5c:	d8 0a       	popm	pc,r12=0

	return DF_OK;
80002f5e:	da 0a       	popm	pc,r12=1
80002f60:	80 00       	ld.sh	r0,r0[0x0]
80002f62:	2d 68       	sub	r8,-42

80002f64 <data_flash_write_page>:
* ----------  --------  ----------  --------------------------------------------
* 25-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_write_page(U8 *data_ptr, U32 address, U16 length)
{
80002f64:	eb cd 40 fc 	pushm	r2-r7,lr
80002f68:	18 94       	mov	r4,r12
80002f6a:	16 93       	mov	r3,r11
80002f6c:	14 92       	mov	r2,r10
	U16 status = 1;
	df_status_t return_code = DF_WRITE_FAIL;
	U16 count = 0; /* to monitor write time consumption */

	/* check input parameter */
	if (data_ptr == NULL || address >= DF_MAX_ADDR || length > DF_PAGE_SIZE)
80002f6e:	58 0c       	cp.w	r12,0
80002f70:	5f 09       	sreq	r9
80002f72:	e0 68 ff fe 	mov	r8,65534
80002f76:	ea 18 00 7f 	orh	r8,0x7f
80002f7a:	10 3b       	cp.w	r11,r8
80002f7c:	5f b8       	srhi	r8
80002f7e:	f3 e8 10 08 	or	r8,r9,r8
80002f82:	c3 a1       	brne	80002ff6 <data_flash_write_page+0x92>
80002f84:	e0 68 01 00 	mov	r8,256
80002f88:	f0 0a 19 00 	cp.h	r10,r8
80002f8c:	e0 8b 00 35 	brhi	80002ff6 <data_flash_write_page+0x92>
	{
		return DF_INVALID_PARAM;
	}

	while(status = send_flash_command(READ_STATUS_REG, 0, NULL, 0) == STATUS_BUSY);
80002f90:	30 06       	mov	r6,0
80002f92:	30 55       	mov	r5,5
80002f94:	30 17       	mov	r7,1
80002f96:	0c 99       	mov	r9,r6
80002f98:	0c 9a       	mov	r10,r6
80002f9a:	0c 9b       	mov	r11,r6
80002f9c:	0a 9c       	mov	r12,r5
80002f9e:	f0 1f 00 19 	mcall	80003000 <data_flash_write_page+0x9c>
80002fa2:	ee 0c 19 00 	cp.h	r12,r7
80002fa6:	cf 80       	breq	80002f96 <data_flash_write_page+0x32>
	//{
		//return DF_DEVICE_BUSY;
	//}

	/* send WRITE_ENABLE command */
	send_flash_command(WRITE_ENABLE, 0, NULL, 0);
80002fa8:	30 09       	mov	r9,0
80002faa:	12 9a       	mov	r10,r9
80002fac:	12 9b       	mov	r11,r9
80002fae:	30 6c       	mov	r12,6
80002fb0:	f0 1f 00 14 	mcall	80003000 <data_flash_write_page+0x9c>

	/* send PAGE_PROGRAM command */
	send_flash_command(PAGE_PROGRAM, address, data_ptr, length);
80002fb4:	f3 d2 c0 10 	bfextu	r9,r2,0x0,0x10
80002fb8:	08 9a       	mov	r10,r4
80002fba:	06 9b       	mov	r11,r3
80002fbc:	30 2c       	mov	r12,2
80002fbe:	f0 1f 00 11 	mcall	80003000 <data_flash_write_page+0x9c>
	do {
		status = send_flash_command(READ_STATUS_REG, 0, NULL, 0);
80002fc2:	30 06       	mov	r6,0
80002fc4:	30 57       	mov	r7,5
80002fc6:	0c 99       	mov	r9,r6
80002fc8:	0c 9a       	mov	r10,r6
80002fca:	0c 9b       	mov	r11,r6
80002fcc:	0e 9c       	mov	r12,r7
80002fce:	f0 1f 00 0d 	mcall	80003000 <data_flash_write_page+0x9c>
		count++;
	} while((status & STATUS_BUSY) != 0);
80002fd2:	5c 7c       	castu.h	r12
80002fd4:	f1 dc c0 01 	bfextu	r8,r12,0x0,0x1
80002fd8:	cf 71       	brne	80002fc6 <data_flash_write_page+0x62>

	/*  Check Status Register */
	if ((status & STATUS_ERASE_PROG_ERROR) != 0)
80002fda:	18 97       	mov	r7,r12
80002fdc:	e2 17 00 20 	andl	r7,0x20,COH
80002fe0:	f9 b7 01 06 	movne	r7,6
80002fe4:	f9 b7 00 07 	moveq	r7,7
		/*  Erase Successful.  */
		return_code = DF_WRITE_COMPLETED;
	}

	/* send WRITE_DISABLE command */
	send_flash_command(WRITE_DISABLE, 0, NULL, 0);
80002fe8:	30 09       	mov	r9,0
80002fea:	12 9a       	mov	r10,r9
80002fec:	12 9b       	mov	r11,r9
80002fee:	30 4c       	mov	r12,4
80002ff0:	f0 1f 00 04 	mcall	80003000 <data_flash_write_page+0x9c>

	return return_code;
80002ff4:	c0 28       	rjmp	80002ff8 <data_flash_write_page+0x94>
80002ff6:	30 17       	mov	r7,1
}
80002ff8:	0e 9c       	mov	r12,r7
80002ffa:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80002ffe:	00 00       	add	r0,r0
80003000:	80 00       	ld.sh	r0,r0[0x0]
80003002:	2d 68       	sub	r8,-42

80003004 <data_flash_write_block>:
* ----------  --------  ----------  --------------------------------------------
* 25-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_write_block(U8 *data_ptr, U32 address, U16 data_length)
{
80003004:	d4 31       	pushm	r0-r7,lr
80003006:	18 94       	mov	r4,r12
80003008:	ed da b0 10 	bfexts	r6,r10,0x0,0x10
8000300c:	16 97       	mov	r7,r11
8000300e:	30 7c       	mov	r12,7
	df_status_t return_code = DF_WRITE_COMPLETED;
	U32 write_addr = address;
	U16 bytes_remained = data_length;

	while (bytes_remained >= 1 && return_code == DF_WRITE_COMPLETED)
80003010:	30 03       	mov	r3,0
80003012:	06 92       	mov	r2,r3
	{
		if ((write_addr & 0xFF) == 0)
		{
			/* address 256 bytes aligned */

			if (bytes_remained <= DF_PAGE_SIZE)
80003014:	e0 60 01 00 	mov	r0,256
{
	df_status_t return_code = DF_WRITE_COMPLETED;
	U32 write_addr = address;
	U16 bytes_remained = data_length;

	while (bytes_remained >= 1 && return_code == DF_WRITE_COMPLETED)
80003018:	c4 98       	rjmp	800030aa <data_flash_write_block+0xa6>
	{
		if ((write_addr & 0xFF) == 0)
8000301a:	eb d7 c0 08 	bfextu	r5,r7,0x0,0x8
8000301e:	c1 b1       	brne	80003054 <data_flash_write_block+0x50>
		{
			/* address 256 bytes aligned */

			if (bytes_remained <= DF_PAGE_SIZE)
80003020:	e0 06 19 00 	cp.h	r6,r0
80003024:	e0 8b 00 0a 	brhi	80003038 <data_flash_write_block+0x34>
			{
				/* bytes remained less than one page */
				return_code = data_flash_write_page(data_ptr, write_addr, bytes_remained);
80003028:	f5 d6 c0 10 	bfextu	r10,r6,0x0,0x10
8000302c:	0e 9b       	mov	r11,r7
8000302e:	08 9c       	mov	r12,r4
80003030:	f0 1f 00 24 	mcall	800030c0 <data_flash_write_block+0xbc>
80003034:	30 06       	mov	r6,0
80003036:	c3 a8       	rjmp	800030aa <data_flash_write_block+0xa6>
				bytes_remained = 0;	/* end while loop */
			}
			else /* (bytes_remained > DF_PAGE_SIZE) */
			{
				/* bytes remained more than one page */
				return_code = data_flash_write_page(data_ptr, write_addr, DF_PAGE_SIZE);
80003038:	e0 6a 01 00 	mov	r10,256
8000303c:	0e 9b       	mov	r11,r7
8000303e:	08 9c       	mov	r12,r4
80003040:	f0 1f 00 20 	mcall	800030c0 <data_flash_write_block+0xbc>
				bytes_remained -= DF_PAGE_SIZE;
80003044:	ec c6 01 00 	sub	r6,r6,256
80003048:	5c 86       	casts.h	r6
				data_ptr += DF_PAGE_SIZE;
8000304a:	e8 c4 ff 00 	sub	r4,r4,-256
				write_addr += DF_PAGE_SIZE;
8000304e:	ee c7 ff 00 	sub	r7,r7,-256
80003052:	c2 c8       	rjmp	800030aa <data_flash_write_block+0xa6>
		}
		else
		{
			/*(write_addr & 0xFF != 0), address not 256 bytes aligned */

			if (BEYOND_PAGE_BOUNDARY(write_addr, bytes_remained) == TRUE)
80003054:	f3 d6 c0 10 	bfextu	r9,r6,0x0,0x10
80003058:	0e 09       	add	r9,r7
8000305a:	0e 98       	mov	r8,r7
8000305c:	e4 18 00 7f 	andh	r8,0x7f
80003060:	e0 18 ff 00 	andl	r8,0xff00
80003064:	f0 c8 ff 00 	sub	r8,r8,-256
80003068:	10 39       	cp.w	r9,r8
8000306a:	e0 88 00 19 	brls	8000309c <data_flash_write_block+0x98>
			{
				/* bytes remained exceed current page, only write data within current page */
				return_code = data_flash_write_page(data_ptr, write_addr, BYTES_TO_NEXT_PAGE_BOUNDARY(write_addr));
8000306e:	0e 91       	mov	r1,r7
80003070:	5c 51       	castu.b	r1
80003072:	e0 6a 01 00 	mov	r10,256
80003076:	02 1a       	sub	r10,r1
80003078:	5c 7a       	castu.h	r10
8000307a:	0e 9b       	mov	r11,r7
8000307c:	08 9c       	mov	r12,r4
8000307e:	f0 1f 00 11 	mcall	800030c0 <data_flash_write_block+0xbc>
				bytes_remained -= BYTES_TO_NEXT_PAGE_BOUNDARY(write_addr);
80003082:	ec c6 01 00 	sub	r6,r6,256
80003086:	02 06       	add	r6,r1
80003088:	5c 86       	casts.h	r6
				data_ptr += BYTES_TO_NEXT_PAGE_BOUNDARY(write_addr);
8000308a:	e0 68 01 00 	mov	r8,256
8000308e:	f0 05 01 05 	sub	r5,r8,r5
80003092:	0a 04       	add	r4,r5
				write_addr += BYTES_TO_NEXT_PAGE_BOUNDARY(write_addr); /* now became 256 bytes aligned */
80003094:	e0 17 ff 00 	andl	r7,0xff00
80003098:	10 07       	add	r7,r8
8000309a:	c0 88       	rjmp	800030aa <data_flash_write_block+0xa6>
			}
			else
			{
				/* bytes remained not exceed current page */
				return_code = data_flash_write_page(data_ptr, write_addr, bytes_remained);
8000309c:	f5 d6 c0 10 	bfextu	r10,r6,0x0,0x10
800030a0:	0e 9b       	mov	r11,r7
800030a2:	08 9c       	mov	r12,r4
800030a4:	f0 1f 00 07 	mcall	800030c0 <data_flash_write_block+0xbc>
800030a8:	30 06       	mov	r6,0
{
	df_status_t return_code = DF_WRITE_COMPLETED;
	U32 write_addr = address;
	U16 bytes_remained = data_length;

	while (bytes_remained >= 1 && return_code == DF_WRITE_COMPLETED)
800030aa:	e6 06 19 00 	cp.h	r6,r3
800030ae:	5f 19       	srne	r9
800030b0:	58 7c       	cp.w	r12,7
800030b2:	5f 08       	sreq	r8
800030b4:	f3 e8 00 08 	and	r8,r9,r8
800030b8:	e4 08 18 00 	cp.b	r8,r2
800030bc:	ca f1       	brne	8000301a <data_flash_write_block+0x16>
			}
		}
	}	/* end of while */

	return return_code;
}
800030be:	d8 32       	popm	r0-r7,pc
800030c0:	80 00       	ld.sh	r0,r0[0x0]
800030c2:	2f 64       	sub	r4,-10

800030c4 <data_flash_erase_block>:
* ----------  --------  ----------  --------------------------------------------
* 25-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_erase_block(U32 address, df_block_size_t block_size)
{
800030c4:	eb cd 40 f8 	pushm	r3-r7,lr
800030c8:	18 94       	mov	r4,r12
	U16 erase_commond;
	df_status_t return_code = DF_ERASE_FAIL;
	U16 count = 0; /* to monitor erase time consumption */

	/* check input parameter */
	if (address >= DF_MAX_ADDR)
800030ca:	e0 68 ff fe 	mov	r8,65534
800030ce:	ea 18 00 7f 	orh	r8,0x7f
800030d2:	10 3c       	cp.w	r12,r8
800030d4:	e0 88 00 04 	brls	800030dc <data_flash_erase_block+0x18>
800030d8:	30 17       	mov	r7,1
800030da:	c3 f8       	rjmp	80003158 <data_flash_erase_block+0x94>
	{
		return DF_INVALID_PARAM;
	}

	/* determine erase command to be issued */
	if (block_size == DF_BLOCK_4KB)
800030dc:	58 1b       	cp.w	r11,1
800030de:	c0 31       	brne	800030e4 <data_flash_erase_block+0x20>
800030e0:	32 03       	mov	r3,32
800030e2:	c0 a8       	rjmp	800030f6 <data_flash_erase_block+0x32>
		erase_commond = BLOCK_ERASE_4KB;
	else if (block_size == DF_BLOCK_32KB)
800030e4:	58 2b       	cp.w	r11,2
800030e6:	c0 31       	brne	800030ec <data_flash_erase_block+0x28>
800030e8:	35 23       	mov	r3,82
800030ea:	c0 68       	rjmp	800030f6 <data_flash_erase_block+0x32>
		erase_commond = BLOCK_ERASE_32KB;
	else if(block_size == DF_BLOCK_64KB)
800030ec:	e0 63 00 d8 	mov	r3,216
800030f0:	58 3b       	cp.w	r11,3
800030f2:	f9 b3 01 60 	movne	r3,96
		erase_commond = BLOCK_ERASE_64KB;
	else/*(block_size == DF_BLOCK_ALL)*/
		erase_commond = CHIP_ERASE;

	while(status = send_flash_command(READ_STATUS_REG, 0, NULL, 0) == STATUS_BUSY);
800030f6:	30 06       	mov	r6,0
800030f8:	30 55       	mov	r5,5
800030fa:	30 17       	mov	r7,1
800030fc:	0c 99       	mov	r9,r6
800030fe:	0c 9a       	mov	r10,r6
80003100:	0c 9b       	mov	r11,r6
80003102:	0a 9c       	mov	r12,r5
80003104:	f0 1f 00 17 	mcall	80003160 <data_flash_erase_block+0x9c>
80003108:	ee 0c 19 00 	cp.h	r12,r7
8000310c:	cf 80       	breq	800030fc <data_flash_erase_block+0x38>
	//{
		//return DF_DEVICE_BUSY;
	//}

	/* send WRITE_ENABLE command */
	send_flash_command(WRITE_ENABLE, 0, NULL, 0);
8000310e:	30 09       	mov	r9,0
80003110:	12 9a       	mov	r10,r9
80003112:	12 9b       	mov	r11,r9
80003114:	30 6c       	mov	r12,6
80003116:	f0 1f 00 13 	mcall	80003160 <data_flash_erase_block+0x9c>

	/* send BLOCK_ERASE command */
	send_flash_command(erase_commond, address, NULL, 0);
8000311a:	30 09       	mov	r9,0
8000311c:	12 9a       	mov	r10,r9
8000311e:	08 9b       	mov	r11,r4
80003120:	06 9c       	mov	r12,r3
80003122:	f0 1f 00 10 	mcall	80003160 <data_flash_erase_block+0x9c>
	do {
		status = send_flash_command(READ_STATUS_REG, 0, NULL, 0);
80003126:	30 06       	mov	r6,0
80003128:	30 57       	mov	r7,5
8000312a:	0c 99       	mov	r9,r6
8000312c:	0c 9a       	mov	r10,r6
8000312e:	0c 9b       	mov	r11,r6
80003130:	0e 9c       	mov	r12,r7
80003132:	f0 1f 00 0c 	mcall	80003160 <data_flash_erase_block+0x9c>
		count++;
	} while((status & STATUS_BUSY) != 0);
80003136:	5c 7c       	castu.h	r12
80003138:	f1 dc c0 01 	bfextu	r8,r12,0x0,0x1
8000313c:	cf 71       	brne	8000312a <data_flash_erase_block+0x66>

	/*  Check Status Register */
	if ((status & STATUS_ERASE_PROG_ERROR) != 0)
8000313e:	18 97       	mov	r7,r12
80003140:	e2 17 00 20 	andl	r7,0x20,COH
80003144:	f9 b7 01 04 	movne	r7,4
80003148:	f9 b7 00 05 	moveq	r7,5
		/*  Erase Successful.  */
		return_code = DF_ERASE_COMPLETED;
	}

	/* send WRITE_DISABLE command */
	send_flash_command(WRITE_DISABLE, 0, NULL, 0);
8000314c:	30 09       	mov	r9,0
8000314e:	12 9a       	mov	r10,r9
80003150:	12 9b       	mov	r11,r9
80003152:	30 4c       	mov	r12,4
80003154:	f0 1f 00 03 	mcall	80003160 <data_flash_erase_block+0x9c>

	return return_code;
}
80003158:	0e 9c       	mov	r12,r7
8000315a:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
8000315e:	00 00       	add	r0,r0
80003160:	80 00       	ld.sh	r0,r0[0x0]
80003162:	2d 68       	sub	r8,-42

80003164 <data_flash_write>:
* ----------  --------  ----------  --------------------------------------------
* 25-Fri-17   Edwards    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_write(U8 *data_ptr, U32 address, U16 data_length)
{
80003164:	d4 31       	pushm	r0-r7,lr
80003166:	20 3d       	sub	sp,12
80003168:	50 0c       	stdsp	sp[0x0],r12
8000316a:	16 91       	mov	r1,r11
8000316c:	14 95       	mov	r5,r10
	U16 secremain;
	U16 i;
	df_status_t return_code = DF_OK;

	secpos	=	address/4096;//扇区地址 0~2047 for AT25DF641 
	secoff	=	address%4096;//在扇区内的偏移
8000316e:	f5 db c0 0c 	bfextu	r10,r11,0x0,0xc
80003172:	50 1a       	stdsp	sp[0x4],r10
	secremain	=	4096-secoff;//扇区剩余空间大小
80003174:	e0 69 10 00 	mov	r9,4096
80003178:	f2 0a 01 07 	sub	r7,r9,r10
8000317c:	ea 07 19 00 	cp.h	r7,r5
80003180:	ea 07 17 b0 	movhi	r7,r5
80003184:	5c 87       	casts.h	r7
80003186:	16 92       	mov	r2,r11
80003188:	e0 12 f0 00 	andl	r2,0xf000
	if(data_length <= secremain)secremain = data_length;//不大于4096个字节
	while(1)
	{
		data_flash_read_block(secpos*4096, 4096, FLASH_BUF);//读出整个扇区的内容
8000318c:	4a e4       	lddpc	r4,80003244 <data_flash_write+0xe0>
		for(i=0; i<secremain; i++)//校验数据
		{
			if(FLASH_BUF[secoff+i]!=0XFF)break;//需要擦除
8000318e:	3f f6       	mov	r6,-1
* Date        Name      Prob#       Description
* ----------  --------  ----------  --------------------------------------------
* 25-Fri-17   Edwards    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_write(U8 *data_ptr, U32 address, U16 data_length)
80003190:	e8 c8 ff ff 	sub	r8,r4,-1
80003194:	50 28       	stdsp	sp[0x8],r8
			secpos++;//扇区地址增1
			secoff=0;//偏移位置为0

			data_ptr+=secremain;  //指针偏移
			address+=secremain;//写地址偏移
			data_length-=secremain;				//字节数递减
80003196:	12 90       	mov	r0,r9
	secoff	=	address%4096;//在扇区内的偏移
	secremain	=	4096-secoff;//扇区剩余空间大小
	if(data_length <= secremain)secremain = data_length;//不大于4096个字节
	while(1)
	{
		data_flash_read_block(secpos*4096, 4096, FLASH_BUF);//读出整个扇区的内容
80003198:	08 9a       	mov	r10,r4
8000319a:	e0 6b 10 00 	mov	r11,4096
8000319e:	04 9c       	mov	r12,r2
800031a0:	f0 1f 00 2a 	mcall	80003248 <data_flash_write+0xe4>
		for(i=0; i<secremain; i++)//校验数据
800031a4:	58 07       	cp.w	r7,0
800031a6:	c3 00       	breq	80003206 <data_flash_write+0xa2>
		{
			if(FLASH_BUF[secoff+i]!=0XFF)break;//需要擦除
800031a8:	40 13       	lddsp	r3,sp[0x4]
800031aa:	5c 73       	castu.h	r3
800031ac:	e8 03 07 08 	ld.ub	r8,r4[r3]
800031b0:	ec 08 18 00 	cp.b	r8,r6
800031b4:	c1 11       	brne	800031d6 <data_flash_write+0x72>
800031b6:	e6 c9 ff ff 	sub	r9,r3,-1
800031ba:	08 09       	add	r9,r4
800031bc:	30 08       	mov	r8,0
800031be:	c0 58       	rjmp	800031c8 <data_flash_write+0x64>
800031c0:	13 3a       	ld.ub	r10,r9++
800031c2:	ec 0a 18 00 	cp.b	r10,r6
800031c6:	c0 81       	brne	800031d6 <data_flash_write+0x72>
	secremain	=	4096-secoff;//扇区剩余空间大小
	if(data_length <= secremain)secremain = data_length;//不大于4096个字节
	while(1)
	{
		data_flash_read_block(secpos*4096, 4096, FLASH_BUF);//读出整个扇区的内容
		for(i=0; i<secremain; i++)//校验数据
800031c8:	2f f8       	sub	r8,-1
800031ca:	5c 88       	casts.h	r8
800031cc:	f0 07 19 00 	cp.h	r7,r8
800031d0:	fe 9b ff f8 	brhi	800031c0 <data_flash_write+0x5c>
800031d4:	c1 98       	rjmp	80003206 <data_flash_write+0xa2>
		{
			if(FLASH_BUF[secoff+i]!=0XFF)break;//需要擦除
		}
		if(i < secremain)//需要擦除
		{
			return_code = data_flash_erase_block(secpos*4096, DF_BLOCK_4KB);//擦除这个扇区
800031d6:	30 1b       	mov	r11,1
800031d8:	04 9c       	mov	r12,r2
800031da:	f0 1f 00 1d 	mcall	8000324c <data_flash_write+0xe8>
800031de:	40 08       	lddsp	r8,sp[0x0]
800031e0:	08 03       	add	r3,r4
* Date        Name      Prob#       Description
* ----------  --------  ----------  --------------------------------------------
* 25-Fri-17   Edwards    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_write(U8 *data_ptr, U32 address, U16 data_length)
800031e2:	40 2a       	lddsp	r10,sp[0x8]
800031e4:	40 19       	lddsp	r9,sp[0x4]
800031e6:	12 0a       	add	r10,r9
800031e8:	0e 99       	mov	r9,r7
800031ea:	20 19       	sub	r9,1
800031ec:	5c 79       	castu.h	r9
800031ee:	12 0a       	add	r10,r9
		if(i < secremain)//需要擦除
		{
			return_code = data_flash_erase_block(secpos*4096, DF_BLOCK_4KB);//擦除这个扇区
			for(i=0; i<secremain; i++)	   //复制
			{
				FLASH_BUF[i+secoff]=data_ptr[i];
800031f0:	11 39       	ld.ub	r9,r8++
800031f2:	06 c9       	st.b	r3++,r9
			if(FLASH_BUF[secoff+i]!=0XFF)break;//需要擦除
		}
		if(i < secremain)//需要擦除
		{
			return_code = data_flash_erase_block(secpos*4096, DF_BLOCK_4KB);//擦除这个扇区
			for(i=0; i<secremain; i++)	   //复制
800031f4:	14 33       	cp.w	r3,r10
800031f6:	cf d1       	brne	800031f0 <data_flash_write+0x8c>
			{
				FLASH_BUF[i+secoff]=data_ptr[i];
			}
			return_code = data_flash_write_block(FLASH_BUF, secpos*4096, 4096);//写入整个扇区
800031f8:	e0 6a 10 00 	mov	r10,4096
800031fc:	04 9b       	mov	r11,r2
800031fe:	08 9c       	mov	r12,r4
80003200:	f0 1f 00 14 	mcall	80003250 <data_flash_write+0xec>
80003204:	c0 78       	rjmp	80003212 <data_flash_write+0xae>

		}
		else 
		{
			return_code = data_flash_write_block(data_ptr, address, secremain);//写已经擦除了的,直接写入扇区剩余区间.
80003206:	0e 9a       	mov	r10,r7
80003208:	5c 7a       	castu.h	r10
8000320a:	02 9b       	mov	r11,r1
8000320c:	40 0c       	lddsp	r12,sp[0x0]
8000320e:	f0 1f 00 11 	mcall	80003250 <data_flash_write+0xec>
80003212:	e4 c2 f0 00 	sub	r2,r2,-4096
		}
		if(data_length==secremain)break;//写入结束了
80003216:	0e 98       	mov	r8,r7
80003218:	ee 05 19 00 	cp.h	r5,r7
8000321c:	c1 20       	breq	80003240 <data_flash_write+0xdc>
		else//写入未结束
		{
			secpos++;//扇区地址增1
			secoff=0;//偏移位置为0

			data_ptr+=secremain;  //指针偏移
8000321e:	5c 78       	castu.h	r8
80003220:	40 0a       	lddsp	r10,sp[0x0]
80003222:	10 0a       	add	r10,r8
80003224:	50 0a       	stdsp	sp[0x0],r10
			address+=secremain;//写地址偏移
80003226:	10 01       	add	r1,r8
			data_length-=secremain;				//字节数递减
80003228:	0e 15       	sub	r5,r7
8000322a:	5c 85       	casts.h	r5
8000322c:	e0 05 19 00 	cp.h	r5,r0
80003230:	ea 07 17 80 	movls	r7,r5
80003234:	e0 07 17 b0 	movhi	r7,r0
80003238:	5c 87       	casts.h	r7
8000323a:	30 09       	mov	r9,0
8000323c:	50 19       	stdsp	sp[0x4],r9
8000323e:	ca db       	rjmp	80003198 <data_flash_write+0x34>
		}
	}
	
	return return_code;
	
}
80003240:	2f dd       	sub	sp,-12
80003242:	d8 32       	popm	r0-r7,pc
80003244:	00 00       	add	r0,r0
80003246:	0e 2c       	rsub	r12,r7
80003248:	80 00       	ld.sh	r0,r0[0x0]
8000324a:	2f 2c       	sub	r12,-14
8000324c:	80 00       	ld.sh	r0,r0[0x0]
8000324e:	30 c4       	mov	r4,12
80003250:	80 00       	ld.sh	r0,r0[0x0]
80003252:	30 04       	mov	r4,0

80003254 <W25Q64_SPI_SetSpeed>:




void W25Q64_SPI_SetSpeed(U16 SPI_BaudRatePrescaler)
{
80003254:	d4 01       	pushm	lr
	spi->csr1 = (spi->csr1 & (U16)0x00FF) |SPI_BaudRatePrescaler;
80003256:	48 78       	lddpc	r8,80003270 <W25Q64_SPI_SetSpeed+0x1c>
80003258:	70 09       	ld.w	r9,r8[0x0]
8000325a:	72 da       	ld.w	r10,r9[0x34]
8000325c:	5c 7c       	castu.h	r12
8000325e:	f5 da c0 08 	bfextu	r10,r10,0x0,0x8
80003262:	f9 ea 10 0a 	or	r10,r12,r10
80003266:	93 da       	st.w	r9[0x34],r10

	spi_enable(spi); /*!< W25Q64_SPI enable */
80003268:	70 0c       	ld.w	r12,r8[0x0]
8000326a:	f0 1f 00 03 	mcall	80003274 <W25Q64_SPI_SetSpeed+0x20>
	
	
}
8000326e:	d8 02       	popm	pc
80003270:	00 00       	add	r0,r0
80003272:	1e 2c       	rsub	r12,pc
80003274:	80 00       	ld.sh	r0,r0[0x0]
80003276:	66 a4       	ld.w	r4,r3[0x28]

80003278 <W25Q64_SPI_SetSpeedLow>:
void W25Q64_SPI_SetSpeedLow(void)
{
80003278:	d4 01       	pushm	lr
	W25Q64_SPI_SetSpeed(0x0200);//baudDiv=4
8000327a:	e0 6c 02 00 	mov	r12,512
8000327e:	f0 1f 00 02 	mcall	80003284 <W25Q64_SPI_SetSpeedLow+0xc>
	
}
80003282:	d8 02       	popm	pc
80003284:	80 00       	ld.sh	r0,r0[0x0]
80003286:	32 54       	mov	r4,37

80003288 <data_flash_init>:
* ----------  --------  ----------  --------------------------------------------
* 10-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
void data_flash_init(void)
{
80003288:	eb cd 40 c0 	pushm	r6-r7,lr
8000328c:	20 5d       	sub	sp,20
		.spck_delay   = 0,
		.trans_delay  = 0,
		.stay_act     = 1,
		.spi_mode     = 1,//0,0 针对不同的存储芯片，注意模式
		.modfdis      = 1
	};
8000328e:	4b a8       	lddpc	r8,80003374 <data_flash_init+0xec>
80003290:	fa c6 ff fc 	sub	r6,sp,-4
80003294:	f0 ea 00 00 	ld.d	r10,r8[0]
80003298:	ec eb 00 00 	st.d	r6[0],r10
8000329c:	f0 e8 00 08 	ld.d	r8,r8[8]
800032a0:	ec e9 00 08 	st.d	r6[8],r8

	// Assign I/Os to SPI.
	gpio_enable_module(DF_SPI_GPIO_MAP, sizeof(DF_SPI_GPIO_MAP) / sizeof(DF_SPI_GPIO_MAP[0]));
800032a4:	30 4b       	mov	r11,4
800032a6:	4b 5c       	lddpc	r12,80003378 <data_flash_init+0xf0>
800032a8:	f0 1f 00 35 	mcall	8000337c <data_flash_init+0xf4>

	spi = &AVR32_SPI;
800032ac:	4b 57       	lddpc	r7,80003380 <data_flash_init+0xf8>
800032ae:	fe 7c 24 00 	mov	r12,-56320
800032b2:	8f 0c       	st.w	r7[0x0],r12

	// Initialize as master.
	spi_initMaster(spi, &spiOptions);
800032b4:	0c 9b       	mov	r11,r6
800032b6:	f0 1f 00 34 	mcall	80003384 <data_flash_init+0xfc>

	// Set selection mode: variable_ps, pcs_decode, delay.
	spi_selectionMode(spi, 0, 0, 0);
800032ba:	30 09       	mov	r9,0
800032bc:	12 9a       	mov	r10,r9
800032be:	12 9b       	mov	r11,r9
800032c0:	6e 0c       	ld.w	r12,r7[0x0]
800032c2:	f0 1f 00 32 	mcall	80003388 <data_flash_init+0x100>

	// Enable SPI.
	spi_enable(spi);
800032c6:	6e 0c       	ld.w	r12,r7[0x0]
800032c8:	f0 1f 00 31 	mcall	8000338c <data_flash_init+0x104>

	W25Q64_SPI_SetSpeedLow();
800032cc:	f0 1f 00 31 	mcall	80003390 <data_flash_init+0x108>

	// Initialize data flash with SPI clock PBA.
	if (spi_setupChipReg(spi, &spiOptions, 2*12000000) != SPI_OK)
800032d0:	e0 6a 36 00 	mov	r10,13824
800032d4:	ea 1a 01 6e 	orh	r10,0x16e
800032d8:	0c 9b       	mov	r11,r6
800032da:	6e 0c       	ld.w	r12,r7[0x0]
800032dc:	f0 1f 00 2e 	mcall	80003394 <data_flash_init+0x10c>
800032e0:	c0 50       	breq	800032ea <data_flash_init+0x62>
	{
		data_flash_failure = FATAL_ERROR_DATA_FLASH_SPI_INIT;
800032e2:	30 29       	mov	r9,2
800032e4:	4a d8       	lddpc	r8,80003398 <data_flash_init+0x110>
800032e6:	b0 89       	st.b	r8[0x0],r9
		return;
800032e8:	c4 28       	rjmp	8000336c <data_flash_init+0xe4>
* 10-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
static Bool data_flash_check_device_id(void)
{
	U16 manufacturer_device_id[2] = {0x5A5A, 0x5A5A};
800032ea:	1a 96       	mov	r6,sp
800032ec:	30 4a       	mov	r10,4
800032ee:	4a cb       	lddpc	r11,8000339c <data_flash_init+0x114>
800032f0:	1a 9c       	mov	r12,sp
800032f2:	f0 1f 00 2c 	mcall	800033a0 <data_flash_init+0x118>

	/* DF memory check. */
	/* Select the DF memory to check. */
	spi_selectChip(spi, DF_SPI_PCS_1);
800032f6:	4a 37       	lddpc	r7,80003380 <data_flash_init+0xf8>
800032f8:	30 1b       	mov	r11,1
800032fa:	6e 0c       	ld.w	r12,r7[0x0]
800032fc:	f0 1f 00 2a 	mcall	800033a4 <data_flash_init+0x11c>

	/* Send the Manufacturer/Device ID Read command. */
	spi_write(spi, READ_M_D_ID);	
80003300:	e0 6b 00 90 	mov	r11,144
80003304:	6e 0c       	ld.w	r12,r7[0x0]
80003306:	f0 1f 00 29 	mcall	800033a8 <data_flash_init+0x120>
	spi_write_zero();
8000330a:	30 0b       	mov	r11,0
8000330c:	6e 0c       	ld.w	r12,r7[0x0]
8000330e:	f0 1f 00 27 	mcall	800033a8 <data_flash_init+0x120>
	spi_write_zero();
80003312:	30 0b       	mov	r11,0
80003314:	6e 0c       	ld.w	r12,r7[0x0]
80003316:	f0 1f 00 25 	mcall	800033a8 <data_flash_init+0x120>
	spi_write_zero();
8000331a:	30 0b       	mov	r11,0
8000331c:	6e 0c       	ld.w	r12,r7[0x0]
8000331e:	f0 1f 00 23 	mcall	800033a8 <data_flash_init+0x120>

	/* Send 2 dummy byte to read the status register. */
	
	spi_write_dummy();
80003322:	e0 6b 00 ff 	mov	r11,255
80003326:	6e 0c       	ld.w	r12,r7[0x0]
80003328:	f0 1f 00 20 	mcall	800033a8 <data_flash_init+0x120>
	spi_read(spi, &manufacturer_device_id[0]);
8000332c:	1a 9b       	mov	r11,sp
8000332e:	6e 0c       	ld.w	r12,r7[0x0]
80003330:	f0 1f 00 1f 	mcall	800033ac <data_flash_init+0x124>
	
	spi_write_dummy();
80003334:	e0 6b 00 ff 	mov	r11,255
80003338:	6e 0c       	ld.w	r12,r7[0x0]
8000333a:	f0 1f 00 1c 	mcall	800033a8 <data_flash_init+0x120>
	spi_read(spi, &manufacturer_device_id[1]);
8000333e:	fa cb ff fe 	sub	r11,sp,-2
80003342:	6e 0c       	ld.w	r12,r7[0x0]
80003344:	f0 1f 00 1a 	mcall	800033ac <data_flash_init+0x124>

	/* Unselect the checked DF memory. */
	spi_unselectChip(spi, DF_SPI_PCS_1);
80003348:	30 1b       	mov	r11,1
8000334a:	6e 0c       	ld.w	r12,r7[0x0]
8000334c:	f0 1f 00 19 	mcall	800033b0 <data_flash_init+0x128>

	/* Unexpected device ID. */
    if ((manufacturer_device_id[0] != 0xEF) || (manufacturer_device_id[1] != 0x16))
80003350:	e0 68 00 ef 	mov	r8,239
80003354:	9a 09       	ld.sh	r9,sp[0x0]
80003356:	f0 09 19 00 	cp.h	r9,r8
8000335a:	c0 61       	brne	80003366 <data_flash_init+0xde>
8000335c:	31 68       	mov	r8,22
8000335e:	9a 19       	ld.sh	r9,sp[0x2]
80003360:	f0 09 19 00 	cp.h	r9,r8
80003364:	c0 40       	breq	8000336c <data_flash_init+0xe4>
		return;
	}
	 
	if (data_flash_check_device_id() != TRUE)//check W25Q64 ID
	{
		data_flash_failure = FATAL_ERROR_DATA_FLASH_READ_ID;
80003366:	30 39       	mov	r9,3
80003368:	48 c8       	lddpc	r8,80003398 <data_flash_init+0x110>
8000336a:	b0 89       	st.b	r8[0x0],r9
	//send_flash_command(WRITE_ENABLE, 0, NULL, 0);
	//send_flash_command(WRITE_STATUS_REG_BYTE_1, 0, NULL, 0);
	//status = send_flash_command(READ_STATUS_REG, 0, NULL, 0);
	
	return;
}
8000336c:	2f bd       	sub	sp,-20
8000336e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80003372:	00 00       	add	r0,r0
80003374:	80 00       	ld.sh	r0,r0[0x0]
80003376:	e7 30 80 00 	ld.ub	r0,r3[-32768]
8000337a:	e7 0c 80 00 	ld.sh	r12,r3[-32768]
8000337e:	61 e8       	ld.w	r8,r0[0x78]
80003380:	00 00       	add	r0,r0
80003382:	1e 2c       	rsub	r12,pc
80003384:	80 00       	ld.sh	r0,r0[0x0]
80003386:	66 40       	ld.w	r0,r3[0x10]
80003388:	80 00       	ld.sh	r0,r0[0x0]
8000338a:	66 78       	ld.w	r8,r3[0x1c]
8000338c:	80 00       	ld.sh	r0,r0[0x0]
8000338e:	66 a4       	ld.w	r4,r3[0x28]
80003390:	80 00       	ld.sh	r0,r0[0x0]
80003392:	32 78       	mov	r8,39
80003394:	80 00       	ld.sh	r0,r0[0x0]
80003396:	66 e8       	ld.w	r8,r3[0x38]
80003398:	00 00       	add	r0,r0
8000339a:	0a 8b       	andn	r11,r5
8000339c:	80 00       	ld.sh	r0,r0[0x0]
8000339e:	e7 2c 80 00 	ld.sb	r12,r3[-32768]
800033a2:	86 8e       	ld.uh	lr,r3[0x0]
800033a4:	80 00       	ld.sh	r0,r0[0x0]
800033a6:	68 10       	ld.w	r0,r4[0x4]
800033a8:	80 00       	ld.sh	r0,r0[0x0]
800033aa:	66 aa       	ld.w	r10,r3[0x28]
800033ac:	80 00       	ld.sh	r0,r0[0x0]
800033ae:	66 c6       	ld.w	r6,r3[0x30]
800033b0:	80 00       	ld.sh	r0,r0[0x0]
800033b2:	67 d0       	ld.w	r0,r3[0x74]

800033b4 <xg_rtc_init>:
}



void xg_rtc_init(void)
{
800033b4:	d4 01       	pushm	lr
	
	// Disable all interrupts. */
	Disable_global_interrupt();
800033b6:	d3 03       	ssrf	0x10
	  
	// Register the RTC interrupt handler to the interrupt controller.
	INTC_register_interrupt(&rtc_irq, AVR32_RTC_IRQ, AVR32_INTC_INT0);
800033b8:	30 0a       	mov	r10,0
800033ba:	32 8b       	mov	r11,40
800033bc:	49 5c       	lddpc	r12,80003410 <xg_rtc_init+0x5c>
800033be:	f0 1f 00 16 	mcall	80003414 <xg_rtc_init+0x60>

	// Initialize the RTC
	//if (!rtc_init(&AVR32_RTC, RTC_OSC_RC, RTC_PSEL_RC_1_76HZ))
	if (!rtc_init(&AVR32_RTC, RTC_OSC_32KHZ, RTC_PSEL_32KHZ_1HZ))
800033c2:	30 ea       	mov	r10,14
800033c4:	30 1b       	mov	r11,1
800033c6:	fe 7c 0d 00 	mov	r12,-62208
800033ca:	f0 1f 00 14 	mcall	80003418 <xg_rtc_init+0x64>
800033ce:	c0 41       	brne	800033d6 <xg_rtc_init+0x22>
	{
		log("Error initializing the RTC\r\n");
800033d0:	49 3c       	lddpc	r12,8000341c <xg_rtc_init+0x68>
800033d2:	f0 1f 00 14 	mcall	80003420 <xg_rtc_init+0x6c>
	}
	// Set top value to 0 to generate an interrupt every seconds */
	rtc_set_top_value(&AVR32_RTC, 0);
800033d6:	30 0b       	mov	r11,0
800033d8:	fe 7c 0d 00 	mov	r12,-62208
800033dc:	f0 1f 00 12 	mcall	80003424 <xg_rtc_init+0x70>
	// Enable the interrupts
	rtc_enable_interrupt(&AVR32_RTC);
800033e0:	fe 7c 0d 00 	mov	r12,-62208
800033e4:	f0 1f 00 11 	mcall	80003428 <xg_rtc_init+0x74>
	// Enable the RTC
	rtc_enable(&AVR32_RTC);
800033e8:	fe 7c 0d 00 	mov	r12,-62208
800033ec:	f0 1f 00 10 	mcall	8000342c <xg_rtc_init+0x78>

	Current_time.Year		= 16;
800033f0:	49 08       	lddpc	r8,80003430 <xg_rtc_init+0x7c>
800033f2:	31 09       	mov	r9,16
800033f4:	b0 89       	st.b	r8[0x0],r9
	Current_time.Month		= 2;
800033f6:	30 29       	mov	r9,2
800033f8:	b0 99       	st.b	r8[0x1],r9
	Current_time.Day		= 29;
800033fa:	31 d9       	mov	r9,29
800033fc:	b0 a9       	st.b	r8[0x2],r9
	Current_time.Hour		= 23;
800033fe:	31 79       	mov	r9,23
80003400:	b0 b9       	st.b	r8[0x3],r9
	Current_time.Minute		= 59;
80003402:	33 b9       	mov	r9,59
80003404:	b0 c9       	st.b	r8[0x4],r9
	Current_time.Second		= 40;
80003406:	32 89       	mov	r9,40
80003408:	b0 d9       	st.b	r8[0x5],r9
	
	// Enable global interrupts
	Enable_global_interrupt();
8000340a:	d5 03       	csrf	0x10
	  
	//RTC_Test();	

}
8000340c:	d8 02       	popm	pc
8000340e:	00 00       	add	r0,r0
80003410:	80 00       	ld.sh	r0,r0[0x0]
80003412:	34 34       	mov	r4,67
80003414:	80 00       	ld.sh	r0,r0[0x0]
80003416:	62 54       	ld.w	r4,r1[0x14]
80003418:	80 00       	ld.sh	r0,r0[0x0]
8000341a:	65 a0       	ld.w	r0,r2[0x68]
8000341c:	80 00       	ld.sh	r0,r0[0x0]
8000341e:	e7 40 80 00 	st.w	r3[-32768],r0
80003422:	7d ec       	ld.w	r12,lr[0x78]
80003424:	80 00       	ld.sh	r0,r0[0x0]
80003426:	65 5c       	ld.w	r12,r2[0x54]
80003428:	80 00       	ld.sh	r0,r0[0x0]
8000342a:	65 54       	ld.w	r4,r2[0x54]
8000342c:	80 00       	ld.sh	r0,r0[0x0]
8000342e:	65 30       	ld.w	r0,r2[0x4c]
80003430:	00 00       	add	r0,r0
80003432:	0e 1c       	sub	r12,r7

80003434 <rtc_irq>:
/* RTC Interrupt  */
#pragma handler = AVR32_RTC_IRQ_GROUP, 1
__interrupt
#endif
void rtc_irq(void)
{
80003434:	d4 01       	pushm	lr
	U8 T,K;
	U32 T16,K16;
	// Increment the minutes counter
	//sec++;
	
	Current_time.Second++;
80003436:	4b 98       	lddpc	r8,80003518 <rtc_irq+0xe4>
80003438:	11 d9       	ld.ub	r9,r8[0x5]
8000343a:	2f f9       	sub	r9,-1
8000343c:	b0 d9       	st.b	r8[0x5],r9
	if(Current_time.Second>=60)
8000343e:	11 d9       	ld.ub	r9,r8[0x5]
80003440:	33 b8       	mov	r8,59
80003442:	f0 09 18 00 	cp.b	r9,r8
80003446:	e0 88 00 5f 	brls	80003504 <rtc_irq+0xd0>
	{
		Current_time.Second =0;
8000344a:	4b 48       	lddpc	r8,80003518 <rtc_irq+0xe4>
8000344c:	30 09       	mov	r9,0
8000344e:	b0 d9       	st.b	r8[0x5],r9
		Current_time.Minute++;
80003450:	11 c9       	ld.ub	r9,r8[0x4]
80003452:	2f f9       	sub	r9,-1
80003454:	b0 c9       	st.b	r8[0x4],r9
		if(Current_time.Minute>=60)
80003456:	11 c9       	ld.ub	r9,r8[0x4]
80003458:	33 b8       	mov	r8,59
8000345a:	f0 09 18 00 	cp.b	r9,r8
8000345e:	e0 88 00 53 	brls	80003504 <rtc_irq+0xd0>
		{
			Current_time.Minute=0;
80003462:	4a e8       	lddpc	r8,80003518 <rtc_irq+0xe4>
80003464:	30 09       	mov	r9,0
80003466:	b0 c9       	st.b	r8[0x4],r9
			Current_time.Hour++;
80003468:	11 b9       	ld.ub	r9,r8[0x3]
8000346a:	2f f9       	sub	r9,-1
8000346c:	b0 b9       	st.b	r8[0x3],r9
			if (Current_time.Hour>=24)
8000346e:	11 b9       	ld.ub	r9,r8[0x3]
80003470:	31 78       	mov	r8,23
80003472:	f0 09 18 00 	cp.b	r9,r8
80003476:	e0 88 00 47 	brls	80003504 <rtc_irq+0xd0>
			{
				Current_time.Hour=0;
8000347a:	4a 88       	lddpc	r8,80003518 <rtc_irq+0xe4>
8000347c:	30 09       	mov	r9,0
8000347e:	b0 b9       	st.b	r8[0x3],r9
				K16=(Current_time.Year&0x03)?365:366;				//判断当年是否为闰年,并获取当年的总天数（此算法时间起点为2000年）
80003480:	11 88       	ld.ub	r8,r8[0x0]
80003482:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
80003486:	e0 69 01 6e 	mov	r9,366
8000348a:	e0 6a 01 6d 	mov	r10,365
8000348e:	f4 08 17 10 	movne	r8,r10
80003492:	f2 08 17 00 	moveq	r8,r9
				K16-=337;											//计算当年二月份天数
				//统计当月天数				
				K=(Current_time.Month==2)?K16:(((Current_time.Month+(Current_time.Month>>3))&0x01)+30);			
80003496:	4a 19       	lddpc	r9,80003518 <rtc_irq+0xe4>
80003498:	13 9a       	ld.ub	r10,r9[0x1]
8000349a:	30 29       	mov	r9,2
8000349c:	f2 0a 18 00 	cp.b	r10,r9
800034a0:	c0 b0       	breq	800034b6 <rtc_irq+0x82>
800034a2:	49 e8       	lddpc	r8,80003518 <rtc_irq+0xe4>
800034a4:	11 99       	ld.ub	r9,r8[0x1]
800034a6:	11 9a       	ld.ub	r10,r8[0x1]
800034a8:	a3 9a       	lsr	r10,0x3
800034aa:	12 0a       	add	r10,r9
800034ac:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
800034b0:	2e 2a       	sub	r10,-30
800034b2:	5c 5a       	castu.b	r10
800034b4:	c0 58       	rjmp	800034be <rtc_irq+0x8a>
800034b6:	f0 c8 01 51 	sub	r8,r8,337
800034ba:	f5 d8 c0 08 	bfextu	r10,r8,0x0,0x8
				Current_time.Day++;
800034be:	49 78       	lddpc	r8,80003518 <rtc_irq+0xe4>
800034c0:	11 a9       	ld.ub	r9,r8[0x2]
800034c2:	2f f9       	sub	r9,-1
800034c4:	b0 a9       	st.b	r8[0x2],r9
				if(Current_time.Day>K)
800034c6:	11 a8       	ld.ub	r8,r8[0x2]
800034c8:	f0 0a 18 00 	cp.b	r10,r8
800034cc:	c1 c2       	brcc	80003504 <rtc_irq+0xd0>
				{	
					Current_time.Day = 1;//重置到下月1号
800034ce:	49 38       	lddpc	r8,80003518 <rtc_irq+0xe4>
800034d0:	30 19       	mov	r9,1
800034d2:	b0 a9       	st.b	r8[0x2],r9
					Current_time.Month++;
800034d4:	11 99       	ld.ub	r9,r8[0x1]
800034d6:	2f f9       	sub	r9,-1
800034d8:	b0 99       	st.b	r8[0x1],r9
					if(Current_time.Month>12)
800034da:	11 99       	ld.ub	r9,r8[0x1]
800034dc:	30 c8       	mov	r8,12
800034de:	f0 09 18 00 	cp.b	r9,r8
800034e2:	e0 88 00 11 	brls	80003504 <rtc_irq+0xd0>
					{
						Current_time.Month = 1;//重置到下一年的第一个月
800034e6:	48 d8       	lddpc	r8,80003518 <rtc_irq+0xe4>
800034e8:	30 19       	mov	r9,1
800034ea:	b0 99       	st.b	r8[0x1],r9
						Current_time.Year++;
800034ec:	11 89       	ld.ub	r9,r8[0x0]
800034ee:	2f f9       	sub	r9,-1
800034f0:	b0 89       	st.b	r8[0x0],r9
						if (Current_time.Year>150)Current_time.Year=0;//重置年份											
800034f2:	11 89       	ld.ub	r9,r8[0x0]
800034f4:	39 68       	mov	r8,-106
800034f6:	f0 09 18 00 	cp.b	r9,r8
800034fa:	e0 88 00 05 	brls	80003504 <rtc_irq+0xd0>
800034fe:	30 09       	mov	r9,0
80003500:	48 68       	lddpc	r8,80003518 <rtc_irq+0xe4>
80003502:	b0 89       	st.b	r8[0x0],r9
	}
	
	//Time_scale++;

	// clear the interrupt flag
	rtc_clear_interrupt(&AVR32_RTC);
80003504:	fe 7c 0d 00 	mov	r12,-62208
80003508:	f0 1f 00 05 	mcall	8000351c <rtc_irq+0xe8>

	// specify that an interrupt has been raised
	print_sec = 1;
8000350c:	30 19       	mov	r9,1
8000350e:	48 58       	lddpc	r8,80003520 <rtc_irq+0xec>
80003510:	91 09       	st.w	r8[0x0],r9
}
80003512:	d4 02       	popm	lr
80003514:	d6 03       	rete
80003516:	00 00       	add	r0,r0
80003518:	00 00       	add	r0,r0
8000351a:	0e 1c       	sub	r12,r7
8000351c:	80 00       	ld.sh	r0,r0[0x0]
8000351e:	65 80       	ld.w	r0,r2[0x60]
80003520:	00 00       	add	r0,r0
80003522:	04 fc       	st.b	--r2,r12

80003524 <CalculateBurst>:
Calls:
Called By: phy_payload_rx
*/

volatile RxAMBEBurstType CalculateBurst(U8 vf_sn)
{
80003524:	20 1c       	sub	r12,1
80003526:	5c 5c       	castu.b	r12
80003528:	31 18       	mov	r8,17
8000352a:	f0 0c 18 00 	cp.b	r12,r8
8000352e:	e0 88 00 03 	brls	80003534 <CalculateBurst+0x10>
80003532:	5e fd       	retal	0
80003534:	48 28       	lddpc	r8,8000353c <CalculateBurst+0x18>
80003536:	f0 0c 03 2c 	ld.w	r12,r8[r12<<0x2]
			Burst_ID = 0x00;
			return VOICE_WATING;
		
	}
	
}
8000353a:	5e fc       	retal	r12
8000353c:	80 00       	ld.sh	r0,r0[0x0]
8000353e:	e7 60 48 38 	st.b	r3[18488],r0

80003540 <payload_init>:
Calls: xTaskCreate--freertos
Called By:app_init -- app.c
*/
void payload_init(void ( *payload_rx_func)(void * ), void ( *payload_tx_func)(void * ) )
{				
	payload_rx_exec = payload_rx_func;
80003540:	48 38       	lddpc	r8,8000354c <payload_init+0xc>
80003542:	91 0c       	st.w	r8[0x0],r12
	payload_tx_exec = payload_tx_func;
80003544:	48 38       	lddpc	r8,80003550 <payload_init+0x10>
80003546:	91 0b       	st.w	r8[0x0],r11
	//,  2
	//,  NULL
	//);
	//
	
}
80003548:	5e fc       	retal	r12
8000354a:	00 00       	add	r0,r0
8000354c:	00 00       	add	r0,r0
8000354e:	0a 8c       	andn	r12,r5
80003550:	00 00       	add	r0,r0
80003552:	0a 90       	mov	r0,r5

80003554 <set_idle_store_isr>:
{
	xQueueSend(store, &ptr, 0);
}

void set_idle_store_isr(xQueueHandle store, void * ptr)
{
80003554:	d4 01       	pushm	lr
80003556:	20 2d       	sub	sp,8
80003558:	50 0b       	stdsp	sp[0x0],r11
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
8000355a:	30 09       	mov	r9,0
8000355c:	fa ca ff f8 	sub	r10,sp,-8
80003560:	14 d9       	st.w	--r10,r9
	xQueueSendFromISR(store, &ptr, &xHigherPriorityTaskWoken);
80003562:	1a 9b       	mov	r11,sp
80003564:	f0 1f 00 02 	mcall	8000356c <set_idle_store_isr+0x18>
}
80003568:	2f ed       	sub	sp,-8
8000356a:	d8 02       	popm	pc
8000356c:	80 00       	ld.sh	r0,r0[0x0]
8000356e:	71 64       	ld.w	r4,r8[0x58]

80003570 <payload_rx>:
		//logFromISR("ss");
	}
}

static void payload_rx(void * payload)
{
80003570:	d4 01       	pushm	lr
    set_payload_idle_isr(payload);
80003572:	48 48       	lddpc	r8,80003580 <payload_rx+0x10>
80003574:	70 08       	ld.w	r8,r8[0x0]
80003576:	18 9b       	mov	r11,r12
80003578:	10 9c       	mov	r12,r8
8000357a:	f0 1f 00 03 	mcall	80003584 <payload_rx+0x14>
	else
	{
		//logFromISR("ss");
	}
	#endif
}
8000357e:	d8 02       	popm	pc
80003580:	00 00       	add	r0,r0
80003582:	0a c8       	st.b	r5++,r8
80003584:	80 00       	ld.sh	r0,r0[0x0]
80003586:	35 54       	mov	r4,85

80003588 <phy_rx>:
	xQueueSendFromISR -- freertos
Called By: phy_xnl_rx
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
80003588:	d4 01       	pushm	lr
8000358a:	20 2d       	sub	sp,8
8000358c:	50 0c       	stdsp	sp[0x0],r12
	//memcpy(xx, phy_ptr, sizeof(phy_fragment_t));
	//set_phy_idle_isr(&phy_ptr, &xHigherPriorityTaskWoken);
	
	Bool res = FALSE;
	
	if(NULL == phy_ptr)
8000358e:	58 0c       	cp.w	r12,0
80003590:	c1 10       	breq	800035b2 <phy_rx+0x2a>
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
    /*variables are used to store the push result in interrupt*/
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80003592:	30 08       	mov	r8,0
80003594:	50 18       	stdsp	sp[0x4],r8
	if(NULL == phy_ptr)
	{
		return;
	}
	
    U16 phy_ctrl = phy_ptr->xnl_fragment.phy_header.phy_control;
80003596:	98 88       	ld.uh	r8,r12[0x0]
80003598:	e2 18 f0 00 	andl	r8,0xf000,COH
8000359c:	e0 48 40 00 	cp.w	r8,16384
800035a0:	c0 91       	brne	800035b2 <phy_rx+0x2a>

    if (XCMPXNL_DATA == (phy_ctrl & 0xF000))
    {
        /*push the xnl packet to queue*/
        if( pdTRUE == xQueueSendFromISR(
800035a2:	48 68       	lddpc	r8,800035b8 <phy_rx+0x30>
800035a4:	70 0c       	ld.w	r12,r8[0x0]
800035a6:	30 09       	mov	r9,0
800035a8:	fa ca ff fc 	sub	r10,sp,-4
800035ac:	1a 9b       	mov	r11,sp
800035ae:	f0 1f 00 04 	mcall	800035bc <phy_rx+0x34>
		}	

    }
		
 
}
800035b2:	2f ed       	sub	sp,-8
800035b4:	d8 02       	popm	pc
800035b6:	00 00       	add	r0,r0
800035b8:	00 00       	add	r0,r0
800035ba:	0a d4       	st.w	--r5,r4
800035bc:	80 00       	ld.sh	r0,r0[0x0]
800035be:	71 64       	ld.w	r4,r8[0x58]

800035c0 <set_idle_store>:
	}
}


void set_idle_store(xQueueHandle store, void * ptr)
{
800035c0:	eb cd 40 80 	pushm	r7,lr
800035c4:	20 1d       	sub	sp,4
800035c6:	fa c7 ff fc 	sub	r7,sp,-4
800035ca:	0e db       	st.w	--r7,r11
	xQueueSend(store, &ptr, 0);
800035cc:	30 09       	mov	r9,0
800035ce:	12 9a       	mov	r10,r9
800035d0:	1a 9b       	mov	r11,sp
800035d2:	f0 1f 00 03 	mcall	800035dc <set_idle_store+0x1c>
}
800035d6:	2f fd       	sub	sp,-4
800035d8:	e3 cd 80 80 	ldm	sp++,r7,pc
800035dc:	80 00       	ld.sh	r0,r0[0x0]
800035de:	71 b4       	ld.w	r4,r8[0x6c]

800035e0 <phy_tx>:
Calls:   
	xQueueSend -- freertos
Called By: xnl_tx -- xnl.c
*/
void phy_tx(phy_fragment_t * phy)
{	
800035e0:	d4 01       	pushm	lr
800035e2:	20 1d       	sub	sp,4
800035e4:	50 0c       	stdsp	sp[0x0],r12
	
	//phy_fragment_t * phy_ptr = malloc(sizeof(phy_fragment_t));
	//memcpy(phy_ptr, phy, sizeof(phy_fragment_t));
	//log("\n\r T_xcmp:%4x \n\r", phy->xnl_fragment.xnl_payload.xnl_content_data_msg.xcmp_opcode);
	//log("T_xnl-opcode:%4x", xnl->xnl_header.opcode);//log:R_xnl指令	
	if(XCMPXNL_DATA == (phy_ctrl & 0xF000))
800035e6:	98 88       	ld.uh	r8,r12[0x0]
800035e8:	e2 18 f0 00 	andl	r8,0xf000,COH
800035ec:	e0 48 40 00 	cp.w	r8,16384
800035f0:	c0 d1       	brne	8000360a <phy_tx+0x2a>
	{
		/*push the xnl packet to queue to send */
		if(NULL != phy_xnl_frame_tx)
800035f2:	49 08       	lddpc	r8,80003630 <phy_tx+0x50>
800035f4:	70 08       	ld.w	r8,r8[0x0]
800035f6:	58 08       	cp.w	r8,0
800035f8:	c1 a0       	breq	8000362c <phy_tx+0x4c>
		{
			if( pdTRUE == xQueueSend(phy_xnl_frame_tx, &phy, 0))
800035fa:	48 e8       	lddpc	r8,80003630 <phy_tx+0x50>
800035fc:	70 0c       	ld.w	r12,r8[0x0]
800035fe:	30 09       	mov	r9,0
80003600:	12 9a       	mov	r10,r9
80003602:	1a 9b       	mov	r11,sp
80003604:	f0 1f 00 0c 	mcall	80003634 <phy_tx+0x54>
80003608:	c1 28       	rjmp	8000362c <phy_tx+0x4c>
		}
	}
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE		
	else if((SPEAKER_DATA == (phy_ctrl & 0xF000))
8000360a:	e0 48 10 00 	cp.w	r8,4096
8000360e:	5f 0a       	sreq	r10
80003610:	e0 48 20 00 	cp.w	r8,8192
80003614:	5f 09       	sreq	r9
80003616:	f5 e9 10 09 	or	r9,r10,r9
8000361a:	c0 71       	brne	80003628 <phy_tx+0x48>
8000361c:	e0 48 50 00 	cp.w	r8,20480
80003620:	c0 40       	breq	80003628 <phy_tx+0x48>
80003622:	e0 48 60 00 	cp.w	r8,24576
80003626:	c0 31       	brne	8000362c <phy_tx+0x4c>
	    || (MIC_DATA  == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_RX == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_TX == (phy_ctrl & 0xF000))
	)
	{		
		if(NULL == phy_payload_frame_tx)
80003628:	48 48       	lddpc	r8,80003638 <phy_tx+0x58>
8000362a:	70 08       	ld.w	r8,r8[0x0]
	
	if(res != TRUE)
	{
		//vPortFree(phy_ptr);
	}
}
8000362c:	2f fd       	sub	sp,-4
8000362e:	d8 02       	popm	pc
80003630:	00 00       	add	r0,r0
80003632:	0a f4       	st.b	--r5,r4
80003634:	80 00       	ld.sh	r0,r0[0x0]
80003636:	71 b4       	ld.w	r4,r8[0x6c]
80003638:	00 00       	add	r0,r0
8000363a:	0a e8       	st.h	--r5,r8

8000363c <get_idle_store_isr>:
		return NULL;
	}
}

void * get_idle_store_isr(xQueueHandle store)
{
8000363c:	d4 01       	pushm	lr
8000363e:	20 2d       	sub	sp,8
	void * ptr = NULL;
80003640:	30 08       	mov	r8,0
80003642:	50 18       	stdsp	sp[0x4],r8
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80003644:	50 08       	stdsp	sp[0x0],r8
	
	if(pdTRUE == xQueueReceiveFromISR(store, &ptr, &xHigherPriorityTaskWoken))
80003646:	1a 9a       	mov	r10,sp
80003648:	fa cb ff fc 	sub	r11,sp,-4
8000364c:	f0 1f 00 05 	mcall	80003660 <get_idle_store_isr+0x24>
80003650:	58 1c       	cp.w	r12,1
80003652:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80003656:	fb fc 00 01 	ld.weq	r12,sp[0x4]
	}
	else
	{
		return NULL;
	}
}
8000365a:	2f ed       	sub	sp,-8
8000365c:	d8 02       	popm	pc
8000365e:	00 00       	add	r0,r0
80003660:	80 00       	ld.sh	r0,r0[0x0]
80003662:	6e b8       	ld.w	r8,r7[0x2c]

80003664 <phy_tx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_tx_func( void * ssc)
{
80003664:	eb cd 40 c0 	pushm	r6-r7,lr
80003668:	20 1d       	sub	sp,4
8000366a:	18 97       	mov	r7,r12
    if(NULL != phy_xnl_frame_tx)
8000366c:	4b a8       	lddpc	r8,80003754 <phy_tx_func+0xf0>
8000366e:	70 08       	ld.w	r8,r8[0x0]
80003670:	58 08       	cp.w	r8,0
80003672:	c6 60       	breq	8000373e <phy_tx_func+0xda>
    {
  	  	/*send ssc data in xnl frame*/
  	  	phy_xnl_tx(&(((ssc_fragment_t * )ssc)->xnl_channel));		
80003674:	18 96       	mov	r6,r12
Called By:phy_tx_func
*/
static void phy_xnl_tx(xnl_channel_t * xnl_tx_channel)
{
	/*variables are used to store the push result in interrupt*/
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80003676:	30 08       	mov	r8,0
80003678:	50 08       	stdsp	sp[0x0],r8
	
	static S16 phy_tx_expexted_length = 0;
	static U8 phy_tx_index = 0;
	
	/*his is the code for handling any outgoing XNL Phy message*/
	switch(phy_tx_state)
8000367a:	4b 88       	lddpc	r8,80003758 <phy_tx_func+0xf4>
8000367c:	70 08       	ld.w	r8,r8[0x0]
8000367e:	58 18       	cp.w	r8,1
80003680:	c2 60       	breq	800036cc <phy_tx_func+0x68>
80003682:	c0 43       	brcs	8000368a <phy_tx_func+0x26>
80003684:	58 28       	cp.w	r8,2
80003686:	c5 c1       	brne	8000373e <phy_tx_func+0xda>
80003688:	c5 58       	rjmp	80003732 <phy_tx_func+0xce>
	{
		/*Waiting for the send xnl packet*/
		case WAITING_FOR_PHY_TX:			
			if( pdTRUE == xQueueReceiveFromISR(
8000368a:	4b 38       	lddpc	r8,80003754 <phy_tx_func+0xf0>
8000368c:	70 0c       	ld.w	r12,r8[0x0]
8000368e:	1a 9a       	mov	r10,sp
80003690:	4b 3b       	lddpc	r11,8000375c <phy_tx_func+0xf8>
80003692:	f0 1f 00 34 	mcall	80003760 <phy_tx_func+0xfc>
80003696:	58 1c       	cp.w	r12,1
80003698:	c1 41       	brne	800036c0 <phy_tx_func+0x5c>
				  phy_xnl_frame_tx
				, &phy_ptr
				, &xHigherPriorityTaskWoken 
			))
			{								
				phy_tx_expexted_length = 
8000369a:	4b 18       	lddpc	r8,8000375c <phy_tx_func+0xf8>
8000369c:	70 08       	ld.w	r8,r8[0x0]
8000369e:	90 08       	ld.sh	r8,r8[0x0]
800036a0:	10 9a       	mov	r10,r8
800036a2:	f5 da c0 08 	bfextu	r10,r10,0x0,0x8
800036a6:	4b 09       	lddpc	r9,80003764 <phy_tx_func+0x100>
800036a8:	b2 0a       	st.h	r9[0x0],r10
				*/
				xnl_tx_channel->dword = 
				                   phy_ptr->xnl_fragment.phy_header.phy_control;
				
				/*Transmit 0xABCD0000 | Type/Length.*/
				xnl_tx_channel->dword |= PHYHEADER32;
800036aa:	5c 78       	castu.h	r8
800036ac:	ea 18 ab cd 	orh	r8,0xabcd
800036b0:	8f 18       	st.w	r7[0x4],r8
				
				phy_tx_index = 1;
800036b2:	30 19       	mov	r9,1
800036b4:	4a d8       	lddpc	r8,80003768 <phy_tx_func+0x104>
800036b6:	b0 89       	st.b	r8[0x0],r9
				phy_tx_state = WRITE_NEXT_DWORD;	
800036b8:	30 19       	mov	r9,1
800036ba:	4a 88       	lddpc	r8,80003758 <phy_tx_func+0xf4>
800036bc:	91 09       	st.w	r8[0x0],r9
800036be:	c4 08       	rjmp	8000373e <phy_tx_func+0xda>
				/*The new transmission has started.*/
			}
			else
			{
				/*Nothing new to transmit, send an idle frame*/
				xnl_tx_channel->dword = XNL_IDLE;
800036c0:	e0 68 5a 5a 	mov	r8,23130
800036c4:	ea 18 ab cd 	orh	r8,0xabcd
800036c8:	8f 18       	st.w	r7[0x4],r8
800036ca:	c3 a8       	rjmp	8000373e <phy_tx_func+0xda>
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
800036cc:	4a 7a       	lddpc	r10,80003768 <phy_tx_func+0x104>
800036ce:	15 88       	ld.ub	r8,r10[0x0]
				xnl_tx_channel->dword = XNL_IDLE;
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
800036d0:	4a 39       	lddpc	r9,8000375c <phy_tx_func+0xf8>
800036d2:	72 09       	ld.w	r9,r9[0x0]
800036d4:	f2 08 05 19 	ld.uh	r9,r9[r8<<0x1]
800036d8:	b1 69       	lsl	r9,0x10
800036da:	99 19       	st.w	r12[0x4],r9
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
800036dc:	2f f8       	sub	r8,-1
800036de:	5c 58       	castu.b	r8
800036e0:	b4 88       	st.b	r10[0x0],r8

			phy_tx_expexted_length -= 2;
800036e2:	4a 1b       	lddpc	r11,80003764 <phy_tx_func+0x100>
800036e4:	96 0c       	ld.sh	r12,r11[0x0]
800036e6:	20 2c       	sub	r12,2
800036e8:	5c 8c       	casts.h	r12
800036ea:	f5 dc b0 10 	bfexts	r10,r12,0x0,0x10
800036ee:	b6 0a       	st.h	r11[0x0],r10
			
			/*have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
800036f0:	30 0b       	mov	r11,0
800036f2:	f6 0a 19 00 	cp.h	r10,r11
800036f6:	e0 89 00 09 	brgt	80003708 <phy_tx_func+0xa4>
			{
				/*Must immediately send 0x00BA in Slot 4.*/
				xnl_tx_channel->dword |= PHYTERMRIGHT;
800036fa:	e8 19 00 ba 	orl	r9,0xba
800036fe:	8f 19       	st.w	r7[0x4],r9
				
				/*Go back to waiting.*/
				phy_tx_state = WAITING_FOR_PHY_TX;
80003700:	30 09       	mov	r9,0
80003702:	49 68       	lddpc	r8,80003758 <phy_tx_func+0xf4>
80003704:	91 09       	st.w	r8[0x0],r9
80003706:	c1 c8       	rjmp	8000373e <phy_tx_func+0xda>
				break;
			}

			/*Have not broken. Transmit 2nd hWord.*/
			xnl_tx_channel->dword |=  phy_ptr->fragment_element[phy_tx_index++];
80003708:	49 5a       	lddpc	r10,8000375c <phy_tx_func+0xf8>
8000370a:	74 0a       	ld.w	r10,r10[0x0]
8000370c:	f4 08 05 1a 	ld.uh	r10,r10[r8<<0x1]
80003710:	14 49       	or	r9,r10
80003712:	8f 19       	st.w	r7[0x4],r9
80003714:	2f f8       	sub	r8,-1
80003716:	49 59       	lddpc	r9,80003768 <phy_tx_func+0x104>
80003718:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
8000371a:	20 2c       	sub	r12,2
8000371c:	49 28       	lddpc	r8,80003764 <phy_tx_func+0x100>
8000371e:	b0 0c       	st.h	r8[0x0],r12
			
			/*Have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80003720:	30 08       	mov	r8,0
80003722:	f0 0c 19 00 	cp.h	r12,r8
80003726:	e0 89 00 0c 	brgt	8000373e <phy_tx_func+0xda>
			{
				/*Must send 0x00BA0000 next interrupt in Slot 3&4*/
				phy_tx_state = SEND_TAILED;
8000372a:	30 29       	mov	r9,2
8000372c:	48 b8       	lddpc	r8,80003758 <phy_tx_func+0xf4>
8000372e:	91 09       	st.w	r8[0x0],r9
80003730:	c0 78       	rjmp	8000373e <phy_tx_func+0xda>
			}
			break;

		case SEND_TAILED:
			/*send 0x00BA0000*/
			xnl_tx_channel->dword = PHYTERMLEFT;
80003732:	fc 18 00 ba 	movh	r8,0xba
80003736:	99 18       	st.w	r12[0x4],r8
			
			/*Go back to waiting.*/		
			phy_tx_state = WAITING_FOR_PHY_TX;		
80003738:	30 09       	mov	r9,0
8000373a:	48 88       	lddpc	r8,80003758 <phy_tx_func+0xf4>
8000373c:	91 09       	st.w	r8[0x0],r9
	//#else
	///*send idle frame*/	
	//((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
	//((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
	//#endif /*end if*/
	((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
8000373e:	e0 68 5a 5a 	mov	r8,23130
80003742:	ea 18 ab cd 	orh	r8,0xabcd
80003746:	8f 28       	st.w	r7[0x8],r8
	((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
80003748:	30 08       	mov	r8,0
8000374a:	8f 38       	st.w	r7[0xc],r8
}
8000374c:	2f fd       	sub	sp,-4
8000374e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80003752:	00 00       	add	r0,r0
80003754:	00 00       	add	r0,r0
80003756:	0a f4       	st.b	--r5,r4
80003758:	00 00       	add	r0,r0
8000375a:	0a b4       	st.h	r5++,r4
8000375c:	00 00       	add	r0,r0
8000375e:	0a c0       	st.b	r5++,r0
80003760:	80 00       	ld.sh	r0,r0[0x0]
80003762:	6e b8       	ld.w	r8,r7[0x2c]
80003764:	00 00       	add	r0,r0
80003766:	0a dc       	st.w	--r5,r12
80003768:	00 00       	add	r0,r0
8000376a:	0a 94       	mov	r4,r5

8000376c <get_idle_store>:
	}//End of RxMedia Phy Handler.
}
#endif /*end if*/

void * get_idle_store(xQueueHandle store)
{
8000376c:	d4 01       	pushm	lr
8000376e:	20 1d       	sub	sp,4
	void * ptr = NULL;
80003770:	30 0a       	mov	r10,0
80003772:	fa cb ff fc 	sub	r11,sp,-4
80003776:	16 da       	st.w	--r11,r10

	if(pdTRUE == xQueueReceive(store, &ptr, 0))
80003778:	14 99       	mov	r9,r10
8000377a:	1a 9b       	mov	r11,sp
8000377c:	f0 1f 00 05 	mcall	80003790 <get_idle_store+0x24>
80003780:	58 1c       	cp.w	r12,1
80003782:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80003786:	fb fc 00 00 	ld.weq	r12,sp[0x0]
	}
	else
	{
		return NULL;
	}
}
8000378a:	2f fd       	sub	sp,-4
8000378c:	d8 02       	popm	pc
8000378e:	00 00       	add	r0,r0
80003790:	80 00       	ld.sh	r0,r0[0x0]
80003792:	6f a8       	ld.w	r8,r7[0x68]

80003794 <phy_init>:
    register_rx_tx_func -- ssc.c
	xQueueCreate -- freertos
Called By: xnl_init -- xnl.c
*/
void phy_init( void )
{
80003794:	d4 01       	pushm	lr
    /*register the func to send/receive ssc packet*/
    register_rx_tx_func(phy_rx_func, phy_tx_func);	
80003796:	48 5b       	lddpc	r11,800037a8 <phy_init+0x14>
80003798:	48 5c       	lddpc	r12,800037ac <phy_init+0x18>
8000379a:	f0 1f 00 06 	mcall	800037b0 <phy_init+0x1c>
	
	/*initialize the SSC*/
	ssc_init();
8000379e:	f0 1f 00 06 	mcall	800037b4 <phy_init+0x20>
	
	/*send device_master_query to connect radio*/
	xnl_send_device_master_query();
800037a2:	f0 1f 00 06 	mcall	800037b8 <phy_init+0x24>
	
}
800037a6:	d8 02       	popm	pc
800037a8:	80 00       	ld.sh	r0,r0[0x0]
800037aa:	36 64       	mov	r4,102
800037ac:	80 00       	ld.sh	r0,r0[0x0]
800037ae:	37 bc       	mov	r12,123
800037b0:	80 00       	ld.sh	r0,r0[0x0]
800037b2:	48 10       	lddpc	r0,800037b4 <phy_init+0x20>
800037b4:	80 00       	ld.sh	r0,r0[0x0]
800037b6:	48 24       	lddpc	r4,800037bc <phy_rx_func>
800037b8:	80 00       	ld.sh	r0,r0[0x0]
800037ba:	51 dc       	stdsp	sp[0x74],r12

800037bc <phy_rx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_rx_func( void * ssc)
{    
800037bc:	eb cd 40 e0 	pushm	r5-r7,lr
800037c0:	18 97       	mov	r7,r12
		
	if(NULL != phy_xnl_frame_rx)
800037c2:	fe f8 0e 7a 	ld.w	r8,pc[3706]
800037c6:	70 08       	ld.w	r8,r8[0x0]
800037c8:	58 08       	cp.w	r8,0
800037ca:	e0 80 01 08 	breq	800039da <phy_rx_func+0x21e>
	static U16 phy_check_sum = 0;

	static phy_rx_state_t  phy_rx_state = WAITING_FOR_HEADER;
	static U32 phy_rx_count = 0;

	U32 phy_dword = xnl_rx_channel->dword;	
800037ce:	78 16       	ld.w	r6,r12[0x4]

	phy_rx_count++;
800037d0:	fe f8 0e 70 	ld.w	r8,pc[3696]
800037d4:	70 09       	ld.w	r9,r8[0x0]
800037d6:	2f f9       	sub	r9,-1
800037d8:	91 09       	st.w	r8[0x0],r9
	
	/*This is the code for parsing the incoming physical message.*/
	switch (phy_rx_state)
800037da:	fe f8 0e 6a 	ld.w	r8,pc[3690]
800037de:	70 08       	ld.w	r8,r8[0x0]
800037e0:	58 18       	cp.w	r8,1
800037e2:	e0 80 00 85 	breq	800038ec <phy_rx_func+0x130>
800037e6:	c0 73       	brcs	800037f4 <phy_rx_func+0x38>
800037e8:	58 28       	cp.w	r8,2
800037ea:	c5 c0       	breq	800038a2 <phy_rx_func+0xe6>
800037ec:	58 38       	cp.w	r8,3
800037ee:	e0 81 00 f6 	brne	800039da <phy_rx_func+0x21e>
800037f2:	cd 58       	rjmp	8000399c <phy_rx_func+0x1e0>

        /*Waiting for something. Most frequent visit.*/		
		case WAITING_FOR_HEADER:
		
			/*Ignore Idles.*/
			if (0xABCD5A5A == phy_dword)
800037f4:	e0 6a 5a 5a 	mov	r10,23130
800037f8:	ea 1a ab cd 	orh	r10,0xabcd
800037fc:	14 36       	cp.w	r6,r10
800037fe:	e0 80 00 ee 	breq	800039da <phy_rx_func+0x21e>
			{
				break;
			}	

			/*Skip until Header.*/		
			if (0xABCD != (phy_dword >> 16))
80003802:	ec 08 16 10 	lsr	r8,r6,0x10
80003806:	e0 48 ab cd 	cp.w	r8,43981
8000380a:	e0 81 00 e8 	brne	800039da <phy_rx_func+0x21e>
			{			
				break;
			}
		
			/*Length excluding CSUM.*/
			phy_rx_expexted_length = (phy_dword & 0x000000FF) - 2;
8000380e:	eb d6 b0 10 	bfexts	r5,r6,0x0,0x10
80003812:	f1 d5 c0 08 	bfextu	r8,r5,0x0,0x8
80003816:	20 28       	sub	r8,2
80003818:	fe f9 0e 30 	ld.w	r9,pc[3632]
8000381c:	b2 08       	st.h	r9[0x0],r8
			
			/*Discard degenerate message.*/
			if (phy_rx_expexted_length <= 0)
8000381e:	30 09       	mov	r9,0
80003820:	f2 08 19 00 	cp.h	r8,r9
80003824:	e0 8a 00 db 	brle	800039da <phy_rx_func+0x21e>
			{
				break;
			}
		
			phy_rx_length = 0;
80003828:	fe f8 0e 24 	ld.w	r8,pc[3620]
8000382c:	b0 09       	st.h	r8[0x0],r9

			phy_frame_ptr = get_xnl_idle_isr();
8000382e:	fe f8 0e 22 	ld.w	r8,pc[3618]
80003832:	70 0c       	ld.w	r12,r8[0x0]
80003834:	f0 1f 03 88 	mcall	80004654 <phy_rx_func+0xe98>
80003838:	fe f8 0e 20 	ld.w	r8,pc[3616]
8000383c:	91 0c       	st.w	r8[0x0],r12
			if(NULL == phy_frame_ptr)
8000383e:	58 0c       	cp.w	r12,0
80003840:	e0 80 00 cd 	breq	800039da <phy_rx_func+0x21e>
			{
				break;
			}
					
			phy_frame_ptr->fragment_element[phy_rx_length++] = phy_dword;
80003844:	fe f8 0e 08 	ld.w	r8,pc[3592]
80003848:	90 09       	ld.sh	r9,r8[0x0]
8000384a:	f8 09 0a 15 	st.h	r12[r9<<0x1],r5
8000384e:	2f f9       	sub	r9,-1
80003850:	5c 89       	casts.h	r9
			
			/*time stamp*/
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
80003852:	fe fa 0e 06 	ld.w	r10,pc[3590]
80003856:	74 0a       	ld.w	r10,r10[0x0]
80003858:	fe fb 0d e8 	ld.w	r11,pc[3560]
8000385c:	76 0b       	ld.w	r11,r11[0x0]
8000385e:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
80003862:	2f f9       	sub	r9,-1
80003864:	b0 09       	st.h	r8[0x0],r9
													(phy_rx_count) & 0x0000FFFF;
			
			/*This switch tests the fragment type, and adjusts receiver state
			accordingly.*/
			/*Check frag type*/
			switch (phy_dword & 0x00000F00)
80003866:	e2 16 0f 00 	andl	r6,0xf00,COH
8000386a:	e0 46 01 00 	cp.w	r6,256
8000386e:	c0 c0       	breq	80003886 <phy_rx_func+0xca>
80003870:	e0 8b 00 05 	brhi	8000387a <phy_rx_func+0xbe>
80003874:	58 06       	cp.w	r6,0
80003876:	c0 80       	breq	80003886 <phy_rx_func+0xca>
80003878:	c0 c8       	rjmp	80003890 <phy_rx_func+0xd4>
8000387a:	e0 46 02 00 	cp.w	r6,512
8000387e:	c0 40       	breq	80003886 <phy_rx_func+0xca>
80003880:	e0 46 03 00 	cp.w	r6,768
80003884:	c0 61       	brne	80003890 <phy_rx_func+0xd4>
			{
				case SINGLE_FRAGMENT:  //Only Fragment.
				case FIRST_FRAGMENT:   //First of Multi-fragment.
				case MIDDLE_FRAGMENT:  //Continuing Multi-fragment.
				case LAST_FRAGMENT:    //Last Multi-fragment.
					phy_rx_state = WAITING_CHECK_SUM;
80003886:	30 29       	mov	r9,2
80003888:	fe f8 0d bc 	ld.w	r8,pc[3516]
8000388c:	91 09       	st.w	r8[0x0],r9
8000388e:	ca 68       	rjmp	800039da <phy_rx_func+0x21e>
				break;
				default:
					set_xnl_idle_isr(phy_frame_ptr);			
80003890:	fe f8 0d c0 	ld.w	r8,pc[3520]
80003894:	70 0c       	ld.w	r12,r8[0x0]
80003896:	fe f8 0d c2 	ld.w	r8,pc[3522]
8000389a:	70 0b       	ld.w	r11,r8[0x0]
8000389c:	f0 1f 03 70 	mcall	8000465c <phy_rx_func+0xea0>
800038a0:	c9 d8       	rjmp	800039da <phy_rx_func+0x21e>
		
			/*Stores CSUM*/
			phy_check_sum  = (phy_dword & 0xFFFF0000) >> 16;
			
			/*sums in first hWord*/
			phy_check_sum += (phy_dword & 0x0000FFFF);		
800038a2:	f5 d6 b0 10 	bfexts	r10,r6,0x0,0x10
800038a6:	b1 86       	lsr	r6,0x10
800038a8:	14 06       	add	r6,r10
800038aa:	fe f8 0d b6 	ld.w	r8,pc[3510]
800038ae:	b0 06       	st.h	r8[0x0],r6
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
800038b0:	fe f8 0d 9c 	ld.w	r8,pc[3484]
800038b4:	90 09       	ld.sh	r9,r8[0x0]
800038b6:	fe fb 0d a2 	ld.w	r11,pc[3490]
800038ba:	76 0b       	ld.w	r11,r11[0x0]
800038bc:	f6 09 0a 1a 	st.h	r11[r9<<0x1],r10
800038c0:	2f f9       	sub	r9,-1
800038c2:	b0 09       	st.h	r8[0x0],r9
														 phy_dword & 0x0000FFFF;
					
			phy_rx_expexted_length -= 2;
800038c4:	fe f9 0d 84 	ld.w	r9,pc[3460]
800038c8:	92 08       	ld.sh	r8,r9[0x0]
800038ca:	20 28       	sub	r8,2
800038cc:	b2 08       	st.h	r9[0x0],r8
			
			/*Normal case for greater than one byte payloads.*/
			if (phy_rx_expexted_length > 0)
800038ce:	30 09       	mov	r9,0
800038d0:	f2 08 19 00 	cp.h	r8,r9
800038d4:	e0 8a 00 07 	brle	800038e2 <phy_rx_func+0x126>
			{					  
				phy_rx_state = READING_FRAGMENT;
800038d8:	30 19       	mov	r9,1
800038da:	fe f8 0d 6a 	ld.w	r8,pc[3434]
800038de:	91 09       	st.w	r8[0x0],r9
800038e0:	c7 d8       	rjmp	800039da <phy_rx_func+0x21e>
	    		Note that all segments must align with a 32-bit boundary and
				beginning of each XCMP/XNL payload frame must start on slot 3
				Thus, segments of odd length must append a 0x0000 at the end
				(slot 4) to ensure alignment. [9.1.3]
				*/
				phy_rx_state = WAITING_LAST_TERM;
800038e2:	30 39       	mov	r9,3
800038e4:	fe f8 0d 60 	ld.w	r8,pc[3424]
800038e8:	91 09       	st.w	r8[0x0],r9
800038ea:	c7 88       	rjmp	800039da <phy_rx_func+0x21e>
			}			
		
			break;

		case READING_FRAGMENT:
			phy_check_sum += (phy_dword & 0xFFFF0000) >> 16;
800038ec:	ec 0a 14 10 	asr	r10,r6,0x10
800038f0:	fe f8 0d 70 	ld.w	r8,pc[3440]
800038f4:	90 09       	ld.sh	r9,r8[0x0]
800038f6:	14 09       	add	r9,r10
800038f8:	b0 09       	st.h	r8[0x0],r9
	
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
800038fa:	fe f9 0d 52 	ld.w	r9,pc[3410]
800038fe:	92 08       	ld.sh	r8,r9[0x0]
80003900:	fe fb 0d 58 	ld.w	r11,pc[3416]
80003904:	76 0b       	ld.w	r11,r11[0x0]
80003906:	f6 08 0a 1a 	st.h	r11[r8<<0x1],r10
8000390a:	2f f8       	sub	r8,-1
8000390c:	5c 88       	casts.h	r8
8000390e:	b2 08       	st.h	r9[0x0],r8
												 (phy_dword & 0xFFFF0000) >> 16;
	
			phy_rx_expexted_length -= 2;
80003910:	fe fa 0d 38 	ld.w	r10,pc[3384]
80003914:	94 09       	ld.sh	r9,r10[0x0]
80003916:	20 29       	sub	r9,2
80003918:	b4 09       	st.h	r10[0x0],r9
			if (phy_rx_expexted_length <= 0)
8000391a:	30 0a       	mov	r10,0
8000391c:	f4 09 19 00 	cp.h	r9,r10
80003920:	e0 89 00 20 	brgt	80003960 <phy_rx_func+0x1a4>
				Terminator should be in 2nd hWord.
				Shaoqun says useful bits not used. The packet will always end
				with $00BA. [9.1.2.8]	
				*/
				
				if ((0x000000BA == (phy_dword  & 0x0000FFFF)) 
80003924:	ed d6 c0 10 	bfextu	r6,r6,0x0,0x10
80003928:	e0 46 00 ba 	cp.w	r6,186
8000392c:	c0 d1       	brne	80003946 <phy_rx_func+0x18a>
8000392e:	fe f8 0d 32 	ld.w	r8,pc[3378]
80003932:	90 09       	ld.sh	r9,r8[0x0]
80003934:	f4 09 19 00 	cp.h	r9,r10
80003938:	c0 71       	brne	80003946 <phy_rx_func+0x18a>
					&& (phy_check_sum == 0))
				{
					phy_rx(phy_frame_ptr);
8000393a:	fe f8 0d 1e 	ld.w	r8,pc[3358]
8000393e:	70 0c       	ld.w	r12,r8[0x0]
80003940:	f0 1f 03 49 	mcall	80004664 <phy_rx_func+0xea8>
80003944:	c0 98       	rjmp	80003956 <phy_rx_func+0x19a>
				}
				else
				{
					set_xnl_idle_isr(phy_frame_ptr);
80003946:	fe f8 0d 0a 	ld.w	r8,pc[3338]
8000394a:	70 0c       	ld.w	r12,r8[0x0]
8000394c:	fe f8 0d 0c 	ld.w	r8,pc[3340]
80003950:	70 0b       	ld.w	r11,r8[0x0]
80003952:	f0 1f 03 43 	mcall	8000465c <phy_rx_func+0xea0>
				}

				phy_rx_state = WAITING_FOR_HEADER;
80003956:	30 09       	mov	r9,0
80003958:	fe f8 0c ec 	ld.w	r8,pc[3308]
8000395c:	91 09       	st.w	r8[0x0],r9
8000395e:	c3 e8       	rjmp	800039da <phy_rx_func+0x21e>
				break;
			}
		
			/*Have not broken. 2nd hWord contains payload.*/
			phy_check_sum += (phy_dword & 0x0000FFFF);
80003960:	5c 86       	casts.h	r6
80003962:	fe f9 0c fe 	ld.w	r9,pc[3326]
80003966:	92 0a       	ld.sh	r10,r9[0x0]
80003968:	0c 0a       	add	r10,r6
8000396a:	b2 0a       	st.h	r9[0x0],r10
		
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
8000396c:	fe f9 0c ec 	ld.w	r9,pc[3308]
80003970:	72 09       	ld.w	r9,r9[0x0]
80003972:	f2 08 0a 16 	st.h	r9[r8<<0x1],r6
80003976:	2f f8       	sub	r8,-1
80003978:	fe f9 0c d4 	ld.w	r9,pc[3284]
8000397c:	b2 08       	st.h	r9[0x0],r8
													   (phy_dword & 0x0000FFFF);
		
			phy_rx_expexted_length -= 2;
8000397e:	fe f9 0c ca 	ld.w	r9,pc[3274]
80003982:	92 08       	ld.sh	r8,r9[0x0]
80003984:	20 28       	sub	r8,2
80003986:	b2 08       	st.h	r9[0x0],r8
			if (phy_rx_expexted_length <= 0)
80003988:	30 09       	mov	r9,0
8000398a:	f2 08 19 00 	cp.h	r8,r9
8000398e:	e0 89 00 26 	brgt	800039da <phy_rx_func+0x21e>
			{
				/*All read in. Next Word should be 0x00BA0000.*/
				phy_rx_state = WAITING_LAST_TERM;
80003992:	30 39       	mov	r9,3
80003994:	fe f8 0c b0 	ld.w	r8,pc[3248]
80003998:	91 09       	st.w	r8[0x0],r9
8000399a:	c2 08       	rjmp	800039da <phy_rx_func+0x21e>
			}/*else, next Word contains more payload.*/
			break;

		/*Expecting last terminator 0x00BA0000.*/	
		case WAITING_LAST_TERM:			
			if ((0x00BA0000 == (phy_dword  & 0x00FF0000)) /*Expected found.*/
8000399c:	e6 16 00 ff 	andh	r6,0xff,COH
800039a0:	fc 19 00 ba 	movh	r9,0xba
800039a4:	12 36       	cp.w	r6,r9
800039a6:	c0 e1       	brne	800039c2 <phy_rx_func+0x206>
800039a8:	fe f8 0c b8 	ld.w	r8,pc[3256]
800039ac:	90 09       	ld.sh	r9,r8[0x0]
800039ae:	30 08       	mov	r8,0
800039b0:	f0 09 19 00 	cp.h	r9,r8
800039b4:	c0 71       	brne	800039c2 <phy_rx_func+0x206>
				&& (phy_check_sum == 0))/*Good checksum*/
			{
				phy_rx(phy_frame_ptr);
800039b6:	fe f8 0c a2 	ld.w	r8,pc[3234]
800039ba:	70 0c       	ld.w	r12,r8[0x0]
800039bc:	f0 1f 03 2a 	mcall	80004664 <phy_rx_func+0xea8>
800039c0:	c0 98       	rjmp	800039d2 <phy_rx_func+0x216>

			}
			else
			{
				set_xnl_idle_isr(phy_frame_ptr);
800039c2:	fe f8 0c 8e 	ld.w	r8,pc[3214]
800039c6:	70 0c       	ld.w	r12,r8[0x0]
800039c8:	fe f8 0c 90 	ld.w	r8,pc[3216]
800039cc:	70 0b       	ld.w	r11,r8[0x0]
800039ce:	f0 1f 03 24 	mcall	8000465c <phy_rx_func+0xea0>
			}
				
			phy_rx_state = WAITING_FOR_HEADER;
800039d2:	30 09       	mov	r9,0
800039d4:	fe f8 0c 70 	ld.w	r8,pc[3184]
800039d8:	91 09       	st.w	r8[0x0],r9
	static U8 _flag = 1;//0xABCDC014时，_flag为0；
						//0xABCDC010时，_flag为1；
			
	//payload_ptr_t *AMBE_payload_ptr;		
	
	if(is_first == FALSE)
800039da:	fe f8 0c 8e 	ld.w	r8,pc[3214]
800039de:	11 89       	ld.ub	r9,r8[0x0]
800039e0:	30 08       	mov	r8,0
800039e2:	f0 09 18 00 	cp.b	r9,r8
800039e6:	c1 31       	brne	80003a0c <phy_rx_func+0x250>
	{
		payload_ptr = get_payload_idle_isr();
800039e8:	fe f6 0c 84 	ld.w	r6,pc[3204]
800039ec:	6c 0c       	ld.w	r12,r6[0x0]
800039ee:	f0 1f 03 1a 	mcall	80004654 <phy_rx_func+0xe98>
800039f2:	fe f8 0c 7e 	ld.w	r8,pc[3198]
800039f6:	91 0c       	st.w	r8[0x0],r12
		AMBE_payload_ptr = get_payload_idle_isr();
800039f8:	6c 0c       	ld.w	r12,r6[0x0]
800039fa:	f0 1f 03 17 	mcall	80004654 <phy_rx_func+0xe98>
800039fe:	fe f8 0c 76 	ld.w	r8,pc[3190]
80003a02:	91 0c       	st.w	r8[0x0],r12
		is_first = TRUE;
80003a04:	30 19       	mov	r9,1
80003a06:	fe f8 0c 62 	ld.w	r8,pc[3170]
80003a0a:	b0 89       	st.b	r8[0x0],r9
	}	
	
	//This is the RxMedia Phy Handler.
	switch (RxMediaState)
80003a0c:	fe f8 0c 6c 	ld.w	r8,pc[3180]
80003a10:	70 08       	ld.w	r8,r8[0x0]
80003a12:	58 28       	cp.w	r8,2
80003a14:	e0 80 01 98 	breq	80003d44 <phy_rx_func+0x588>
80003a18:	e0 8b 00 06 	brhi	80003a24 <phy_rx_func+0x268>
80003a1c:	58 08       	cp.w	r8,0
80003a1e:	c0 b0       	breq	80003a34 <phy_rx_func+0x278>
80003a20:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80003a24:	58 38       	cp.w	r8,3
80003a26:	e0 80 05 c5 	breq	800045b0 <phy_rx_func+0xdf4>
80003a2a:	58 48       	cp.w	r8,4
80003a2c:	e0 81 06 05 	brne	80004636 <phy_rx_func+0xe7a>
80003a30:	e0 8f 02 4b 	bral	80003ec6 <phy_rx_func+0x70a>
	{
		case WAITINGABAB:

			
			if (payload_rx_channel->dword[0] == 0xABCD5A5A)//Ignore Idles.
80003a34:	6e 28       	ld.w	r8,r7[0x8]
80003a36:	e0 6a 5a 5a 	mov	r10,23130
80003a3a:	ea 1a ab cd 	orh	r10,0xabcd
80003a3e:	14 38       	cp.w	r8,r10
80003a40:	c0 71       	brne	80003a4e <phy_rx_func+0x292>
			{
				m_RxBurstType = VOICE_WATING;
80003a42:	30 09       	mov	r9,0
80003a44:	fe f8 0c 38 	ld.w	r8,pc[3128]
80003a48:	91 09       	st.w	r8[0x0],r9
80003a4a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
				//Upon receiving the idle frame, the m Rx Burst Type into an idle state in order to transmit the synchronization wait
				 break; 
			}
            
			if ((payload_rx_channel->dword[0]  & 0xFFFF0000) != 0xABCD0000)break; //Skip until Header. 
80003a4e:	10 99       	mov	r9,r8
80003a50:	e0 19 00 00 	andl	r9,0x0
80003a54:	fc 1a ab cd 	movh	r10,0xabcd
80003a58:	14 39       	cp.w	r9,r10
80003a5a:	e0 81 05 ee 	brne	80004636 <phy_rx_func+0xe7a>
			}
			//logFromISR("\n\r P: %X \n\r", payload_rx_channel->word[1]);//测试收到的数据
			
#endif
			
			RxBytesWaiting = payload_rx_channel->dword[0] & 0x000000FF;
80003a5e:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
80003a62:	fe f9 0c 1e 	ld.w	r9,pc[3102]
80003a66:	93 08       	st.w	r9[0x0],r8
			/****Note AMBE stream protocol frame structure and the PCM frame structure is different*****/
					
			if ((payload_rx_channel->dword[0] & 0x0000F000 ) == PAYLOAD_DATA_ENH )//PAYLOAD_DATA_ENH (0x0c))
80003a68:	6e 29       	ld.w	r9,r7[0x8]
80003a6a:	e2 19 f0 00 	andl	r9,0xf000,COH
80003a6e:	e0 49 c0 00 	cp.w	r9,49152
80003a72:	e0 81 00 ce 	brne	80003c0e <phy_rx_func+0x452>
			{
				AMBE_Media = 1;	
80003a76:	30 1a       	mov	r10,1
80003a78:	fe f9 0c 0c 	ld.w	r9,pc[3084]
80003a7c:	b2 8a       	st.b	r9[0x0],r10
				
				if (NULL== AMBE_payload_ptr){
80003a7e:	fe f9 0b f6 	ld.w	r9,pc[3062]
80003a82:	72 09       	ld.w	r9,r9[0x0]
80003a84:	58 09       	cp.w	r9,0
80003a86:	c0 71       	brne	80003a94 <phy_rx_func+0x2d8>
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//测试是否有这种情况出现
80003a88:	fe fc 0c 00 	ld.w	r12,pc[3072]
80003a8c:	f0 1f 03 00 	mcall	8000468c <phy_rx_func+0xed0>
80003a90:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
																	
				Item_ID = payload_rx_channel->byte[5];
80003a94:	ef 3a 00 0d 	ld.ub	r10,r7[13]
80003a98:	fe f9 0b f8 	ld.w	r9,pc[3064]
80003a9c:	b2 8a       	st.b	r9[0x0],r10
				
				Item_Length = (payload_rx_channel->byte[4] & 0x7F);//7bits
80003a9e:	ef 3b 00 0c 	ld.ub	r11,r7[12]
80003aa2:	f7 db c0 07 	bfextu	r11,r11,0x0,0x7
80003aa6:	fe fa 0b ee 	ld.w	r10,pc[3054]
80003aaa:	95 0b       	st.w	r10[0x0],r11
								
				switch(Item_ID)
80003aac:	13 89       	ld.ub	r9,r9[0x0]
80003aae:	37 fa       	mov	r10,127
80003ab0:	f4 09 18 00 	cp.b	r9,r10
80003ab4:	c6 d0       	breq	80003b8e <phy_rx_func+0x3d2>
80003ab6:	e0 8b 00 0c 	brhi	80003ace <phy_rx_func+0x312>
80003aba:	31 2a       	mov	r10,18
80003abc:	f4 09 18 00 	cp.b	r9,r10
80003ac0:	c4 20       	breq	80003b44 <phy_rx_func+0x388>
80003ac2:	31 3a       	mov	r10,19
80003ac4:	f4 09 18 00 	cp.b	r9,r10
80003ac8:	e0 81 00 83 	brne	80003bce <phy_rx_func+0x412>
80003acc:	c5 b8       	rjmp	80003b82 <phy_rx_func+0x3c6>
80003ace:	2f 09       	sub	r9,-16
80003ad0:	30 1a       	mov	r10,1
80003ad2:	f4 09 18 00 	cp.b	r9,r10
80003ad6:	e0 8b 00 7c 	brhi	80003bce <phy_rx_func+0x412>
					//The OB know the Call begin and discard the Voice Header
					//The OB know the Call end and discard the Voice  Terminator
					case Raw_Tx_Data_HT://0xF0
					case Raw_Rx_Data_HT://0xF1
					
							if ((payload_rx_channel->byte[6] & 0xF0 )== 0x10)//header
80003ada:	ef 38 00 0e 	ld.ub	r8,r7[14]
80003ade:	e2 18 00 f0 	andl	r8,0xf0,COH
80003ae2:	59 08       	cp.w	r8,16
80003ae4:	c0 71       	brne	80003af2 <phy_rx_func+0x336>
							{
								m_RxBurstType = VOICEHEADER;
80003ae6:	30 19       	mov	r9,1
80003ae8:	fe f8 0b 94 	ld.w	r8,pc[2964]
80003aec:	91 09       	st.w	r8[0x0],r9
80003aee:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

							}
							else if ((payload_rx_channel->byte[6] & 0xF0) == 0x20)//Terminator
80003af2:	e0 48 00 20 	cp.w	r8,32
80003af6:	c2 11       	brne	80003b38 <phy_rx_func+0x37c>
							{
								m_RxBurstType = VOICETERMINATOR;
80003af8:	30 a9       	mov	r9,10
80003afa:	fe f8 0b 82 	ld.w	r8,pc[2946]
80003afe:	91 09       	st.w	r8[0x0],r9
								//AMBE-data and PCM-data is not the same. AMBE is compressed data,
								//if there was a missing portion, a clear voice is difficult to extract the data.
								//It must ensure that all the data received AMBE.
								
								//注意！！！考虑是否需要把剩余的空间置0。
								memset((AMBE_payload_ptr+ (RxAMBE_IsFillingNext8 +1)), 0x00, (512-(RxAMBE_IsFillingNext8 + 1)));
80003b00:	fe f6 0b 98 	ld.w	r6,pc[2968]
80003b04:	6c 08       	ld.w	r8,r6[0x0]
80003b06:	f0 0a 11 ff 	rsub	r10,r8,-1
80003b0a:	fe f7 0b 6a 	ld.w	r7,pc[2922]
80003b0e:	2f f8       	sub	r8,-1
80003b10:	6e 0c       	ld.w	r12,r7[0x0]
80003b12:	f4 ca fe 00 	sub	r10,r10,-512
80003b16:	30 0b       	mov	r11,0
80003b18:	10 0c       	add	r12,r8
80003b1a:	f0 1f 02 e1 	mcall	8000469c <phy_rx_func+0xee0>
								
								RxAMBE_IsFillingNext8 = 0;
80003b1e:	30 08       	mov	r8,0
80003b20:	8d 08       	st.w	r6[0x0],r8
								payload_rx(AMBE_payload_ptr);
80003b22:	6e 0c       	ld.w	r12,r7[0x0]
80003b24:	f0 1f 02 df 	mcall	800046a0 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003b28:	fe f8 0b 44 	ld.w	r8,pc[2884]
80003b2c:	70 0c       	ld.w	r12,r8[0x0]
80003b2e:	f0 1f 02 ca 	mcall	80004654 <phy_rx_func+0xe98>
80003b32:	8f 0c       	st.w	r7[0x0],r12
80003b34:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								//logFromISR("\n\r QQ1 \n\r");
								
							}
							else//error voice
							{
								m_RxBurstType = VOICE_WATING;
80003b38:	30 09       	mov	r9,0
80003b3a:	fe f8 0b 42 	ld.w	r8,pc[2882]
80003b3e:	91 09       	st.w	r8[0x0],r9
80003b40:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;//WAITINGABAB.
					
		
					case Vocoder_Bit_Stream_Parameter://0x12
							
							if ((RxBytesWaiting -= 4) <= 0) break;
80003b44:	20 48       	sub	r8,4
80003b46:	fe f9 0b 3a 	ld.w	r9,pc[2874]
80003b4a:	93 08       	st.w	r9[0x0],r8
80003b4c:	58 08       	cp.w	r8,0
80003b4e:	e0 80 05 74 	breq	80004636 <phy_rx_func+0xe7a>
					
							//Vocoder Bits Stream Parameter
							VF_SN = (payload_rx_channel->byte[7] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
80003b52:	ef 3c 00 0f 	ld.ub	r12,r7[15]
80003b56:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
80003b5a:	fe f8 0b 4a 	ld.w	r8,pc[2890]
80003b5e:	b0 8c       	st.b	r8[0x0],r12
							
							VBSP_data[0] = payload_rx_channel->word[2];
80003b60:	8e 69       	ld.sh	r9,r7[0xc]
80003b62:	fe f8 0b 46 	ld.w	r8,pc[2886]
80003b66:	b0 09       	st.h	r8[0x0],r9
							VBSP_data[1] = payload_rx_channel->word[3];
80003b68:	8e 79       	ld.sh	r9,r7[0xe]
80003b6a:	b0 19       	st.h	r8[0x2],r9
							
							m_RxBurstType = CalculateBurst(VF_SN);
80003b6c:	f0 1f 02 d0 	mcall	800046ac <phy_rx_func+0xef0>
80003b70:	fe f8 0b 0c 	ld.w	r8,pc[2828]
80003b74:	91 0c       	st.w	r8[0x0],r12
							
							RxMediaState = READING_AMBE_MEDIA;//Jump
80003b76:	30 49       	mov	r9,4
80003b78:	fe f8 0b 00 	ld.w	r8,pc[2816]
80003b7c:	91 09       	st.w	r8[0x0],r9
80003b7e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							
					//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
					// or discard it to reduce payload size.	
					//This shouldn't happen, but must check.	
					case Soft_Decision_Value://0x13
						m_RxBurstType = VOICE_WATING;
80003b82:	30 09       	mov	r9,0
80003b84:	fe f8 0a f8 	ld.w	r8,pc[2808]
80003b88:	91 09       	st.w	r8[0x0],r9
80003b8a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
					case Radio_Internal_Parameter://0x7F
							
							//logFromISR("\n\r Item_Length:%d\n\r", Item_Length);
							
							if ((RxBytesWaiting -= 4) <= 0) break;
80003b8e:	20 48       	sub	r8,4
80003b90:	fe f9 0a f0 	ld.w	r9,pc[2800]
80003b94:	93 08       	st.w	r9[0x0],r8
80003b96:	58 08       	cp.w	r8,0
80003b98:	e0 80 05 4f 	breq	80004636 <phy_rx_func+0xe7a>
							//Radio Internal Parameter
							Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[3];
80003b9c:	fe f8 0b 14 	ld.w	r8,pc[2836]
80003ba0:	70 09       	ld.w	r9,r8[0x0]
80003ba2:	8e 7b       	ld.sh	r11,r7[0xe]
80003ba4:	fe fa 0b 10 	ld.w	r10,pc[2832]
80003ba8:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
							RxData_IsFillingNext16 += 1; 
80003bac:	2f f9       	sub	r9,-1
80003bae:	91 09       	st.w	r8[0x0],r9
							Item_Length -= 2 ;
80003bb0:	fe f8 0a e4 	ld.w	r8,pc[2788]
80003bb4:	70 09       	ld.w	r9,r8[0x0]
80003bb6:	20 29       	sub	r9,2
80003bb8:	91 09       	st.w	r8[0x0],r9
							//....................................................
							m_RxBurstType = RADIOINTERNAL;
80003bba:	30 29       	mov	r9,2
80003bbc:	fe f8 0a c0 	ld.w	r8,pc[2752]
80003bc0:	91 09       	st.w	r8[0x0],r9

							RxMediaState = READING_AMBE_AUX;//Jump
80003bc2:	30 39       	mov	r9,3
80003bc4:	fe f8 0a b4 	ld.w	r8,pc[2740]
80003bc8:	91 09       	st.w	r8[0x0],r9
80003bca:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									
					default://0x03,0x04
						
						//((Item_ID == 0x04) || (Item_ID == 0x03) )//Unknown type data directly back hair
							//break;
							m_RxBurstType = UNSUREDATA;
80003bce:	30 3a       	mov	r10,3
80003bd0:	fe f9 0a ac 	ld.w	r9,pc[2732]
80003bd4:	93 0a       	st.w	r9[0x0],r10
							AMBE_HT[0] = payload_rx_channel->dword[0];
80003bd6:	6e 2a       	ld.w	r10,r7[0x8]
80003bd8:	fe f9 0a e0 	ld.w	r9,pc[2784]
80003bdc:	93 0a       	st.w	r9[0x0],r10
							AMBE_HT[1] = payload_rx_channel->dword[1];
80003bde:	6e 3a       	ld.w	r10,r7[0xc]
80003be0:	93 1a       	st.w	r9[0x4],r10
							
							if (RxBytesWaiting == 0x00000014)
80003be2:	59 48       	cp.w	r8,20
80003be4:	c0 61       	brne	80003bf0 <phy_rx_func+0x434>
							{
								RxBytesWaiting = 0x18;//24 Reassigned
80003be6:	31 89       	mov	r9,24
80003be8:	fe f8 0a 98 	ld.w	r8,pc[2712]
80003bec:	91 09       	st.w	r8[0x0],r9
80003bee:	c0 a8       	rjmp	80003c02 <phy_rx_func+0x446>
								//_flag =0;
								
							}
							if (RxBytesWaiting == 0x00000010)
80003bf0:	fe f8 0a 90 	ld.w	r8,pc[2704]
80003bf4:	70 08       	ld.w	r8,r8[0x0]
80003bf6:	59 08       	cp.w	r8,16
80003bf8:	c0 51       	brne	80003c02 <phy_rx_func+0x446>
							{
								RxBytesWaiting = 0x10;//16 Reassigned
80003bfa:	31 09       	mov	r9,16
80003bfc:	fe f8 0a 84 	ld.w	r8,pc[2692]
80003c00:	91 09       	st.w	r8[0x0],r9
								//_flag =1;
							}
					
							RxMediaState = READING_AMBE_MEDIA;//Jump
80003c02:	30 49       	mov	r9,4
80003c04:	fe f8 0a 74 	ld.w	r8,pc[2676]
80003c08:	91 09       	st.w	r8[0x0],r9
80003c0a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
//#if 0
			else//PCM-media-data
			{	
				//logFromISR("\n\r RX:%x \n\r", payload_rx_channel->dword[0]);
				//SPEAKER_DATA or  //MIC_DATA
				if (((payload_rx_channel->dword[0] & 0x0000F000 ) != SPEAKER_DATA ) 
80003c0e:	e0 49 10 00 	cp.w	r9,4096
80003c12:	5f 1a       	srne	r10
80003c14:	e0 49 20 00 	cp.w	r9,8192
80003c18:	5f 19       	srne	r9
80003c1a:	f5 e9 00 09 	and	r9,r10,r9
80003c1e:	e0 81 05 0c 	brne	80004636 <phy_rx_func+0xe7a>
					&& ((payload_rx_channel->dword[0] & 0x0000F000 ) != MIC_DATA ))break;
				
				AMBE_tx_flag = 0;
80003c22:	fe fa 0a 9a 	ld.w	r10,pc[2714]
80003c26:	b4 89       	st.b	r10[0x0],r9
				AMBE_rx_flag = 0;
80003c28:	fe fa 0a 98 	ld.w	r10,pc[2712]
80003c2c:	b4 89       	st.b	r10[0x0],r9
				
				Item_ID = 0;//To make sure your save PCM data.
80003c2e:	fe fa 0a 62 	ld.w	r10,pc[2658]
80003c32:	b4 89       	st.b	r10[0x0],r9
			
				if (NULL== payload_ptr){
80003c34:	fe f9 0a 3c 	ld.w	r9,pc[2620]
80003c38:	72 09       	ld.w	r9,r9[0x0]
80003c3a:	58 09       	cp.w	r9,0
80003c3c:	c0 71       	brne	80003c4a <phy_rx_func+0x48e>
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//测试是否有这种情况出现
80003c3e:	fe fc 0a 4a 	ld.w	r12,pc[2634]
80003c42:	f0 1f 02 93 	mcall	8000468c <phy_rx_func+0xed0>
80003c46:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003c4a:	6e 2a       	ld.w	r10,r7[0x8]
80003c4c:	e2 1a 0f 00 	andl	r10,0xf00,COH
80003c50:	58 1a       	cp.w	r10,1
80003c52:	e0 8b 00 4d 	brhi	80003cec <phy_rx_func+0x530>
				
				if ((payload_rx_channel->dword[0]  & 0x00000F00) <= 1){  //Flag type must process Array Descriptor.
				//The first word of the media access payload must be the Array descriptor length. And the
				//unit of the length is in word (16-bit). The length field itself does not count into the length.
				//When there is no array descriptor, the length must be set to zero.[9.1.4.1]
					if ((RxBytesWaiting -= 4) <= 0) break;          //Nothing beyond this Phy buffer. Keep looking for Header
80003c56:	20 48       	sub	r8,4
80003c58:	fe f9 0a 28 	ld.w	r9,pc[2600]
80003c5c:	93 08       	st.w	r9[0x0],r8
80003c5e:	58 08       	cp.w	r8,0
80003c60:	e0 80 04 eb 	breq	80004636 <phy_rx_func+0xe7a>
					ArrayDiscLength = payload_rx_channel->word[2];
80003c64:	8e 68       	ld.sh	r8,r7[0xc]
80003c66:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
80003c6a:	fe f9 0a 5a 	ld.w	r9,pc[2650]
80003c6e:	93 0a       	st.w	r9[0x0],r10
					switch (ArrayDiscLength){
80003c70:	30 09       	mov	r9,0
80003c72:	f2 08 19 00 	cp.h	r8,r9
80003c76:	c0 70       	breq	80003c84 <phy_rx_func+0x4c8>
80003c78:	30 19       	mov	r9,1
80003c7a:	f2 08 19 00 	cp.h	r8,r9
80003c7e:	e0 81 04 dc 	brne	80004636 <phy_rx_func+0xe7a>
80003c82:	c2 68       	rjmp	80003cce <phy_rx_func+0x512>
						case 0:          //The usual case. Remaining word in Phy buffer is Audio.
								
							payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
80003c84:	fe f8 0a 44 	ld.w	r8,pc[2628]
80003c88:	70 0a       	ld.w	r10,r8[0x0]
80003c8a:	fe f9 09 e6 	ld.w	r9,pc[2534]
80003c8e:	72 09       	ld.w	r9,r9[0x0]
80003c90:	8e 7b       	ld.sh	r11,r7[0xe]
80003c92:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
							RxMedia_IsFillingNext16 += 1;
80003c96:	70 09       	ld.w	r9,r8[0x0]
80003c98:	2f f9       	sub	r9,-1
80003c9a:	91 09       	st.w	r8[0x0],r9
							if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003c9c:	e0 49 00 ff 	cp.w	r9,255
80003ca0:	e0 88 00 11 	brls	80003cc2 <phy_rx_func+0x506>
							{
								RxMedia_IsFillingNext16 = 0;	
80003ca4:	30 09       	mov	r9,0
80003ca6:	91 09       	st.w	r8[0x0],r9
								payload_rx(payload_ptr);	
80003ca8:	fe f7 09 c8 	ld.w	r7,pc[2504]
80003cac:	6e 0c       	ld.w	r12,r7[0x0]
80003cae:	f0 1f 02 7d 	mcall	800046a0 <phy_rx_func+0xee4>
								payload_ptr = get_payload_idle_isr();
80003cb2:	fe f8 09 ba 	ld.w	r8,pc[2490]
80003cb6:	70 0c       	ld.w	r12,r8[0x0]
80003cb8:	f0 1f 02 67 	mcall	80004654 <phy_rx_func+0xe98>
80003cbc:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == payload_ptr){
80003cbe:	e0 80 04 bc 	breq	80004636 <phy_rx_func+0xe7a>
									break;
								}				
							}
							RxMediaState = READINGMEDIA;
80003cc2:	30 29       	mov	r9,2
80003cc4:	fe f8 09 b4 	ld.w	r8,pc[2484]
80003cc8:	91 09       	st.w	r8[0x0],r9
80003cca:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003cce:	8e 79       	ld.sh	r9,r7[0xe]
80003cd0:	30 38       	mov	r8,3
80003cd2:	f0 09 19 00 	cp.h	r9,r8
80003cd6:	c0 51       	brne	80003ce0 <phy_rx_func+0x524>
				
						case 1: //The next usual case.
								//In general case, add code to process single word Array descriptor.
								if (payload_rx_channel->word[3] == 0x0003)//Stream Terminator
								{
									Terminator_Flag = 1;
80003cd8:	30 19       	mov	r9,1
80003cda:	fe f8 09 f2 	ld.w	r8,pc[2546]
80003cde:	b0 89       	st.b	r8[0x0],r9
								else
								{
									//Terminator_Flag = 0;
								}
								
								RxMediaState = READINGMEDIA;
80003ce0:	30 29       	mov	r9,2
80003ce2:	fe f8 09 96 	ld.w	r8,pc[2454]
80003ce6:	91 09       	st.w	r8[0x0],r9
80003ce8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
				break;
			}
		
				//Code gets here on Middle or last Fragment. No Array descriptor.
				if (RxBytesWaiting < 2) break;//This shouldn't happen, but must check.
80003cec:	58 18       	cp.w	r8,1
80003cee:	e0 88 04 a4 	brls	80004636 <phy_rx_func+0xe7a>
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->dword[1] & 0x0000FFFF;
80003cf2:	fe f8 09 d6 	ld.w	r8,pc[2518]
80003cf6:	70 0a       	ld.w	r10,r8[0x0]
80003cf8:	6e 3b       	ld.w	r11,r7[0xc]
80003cfa:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80003cfe:	70 09       	ld.w	r9,r8[0x0]
80003d00:	2f f9       	sub	r9,-1
80003d02:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003d04:	e0 49 00 ff 	cp.w	r9,255
80003d08:	e0 88 00 11 	brls	80003d2a <phy_rx_func+0x56e>
				{
					RxMedia_IsFillingNext16 = 0;
80003d0c:	30 09       	mov	r9,0
80003d0e:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003d10:	fe f7 09 60 	ld.w	r7,pc[2400]
80003d14:	6e 0c       	ld.w	r12,r7[0x0]
80003d16:	f0 1f 02 63 	mcall	800046a0 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
80003d1a:	fe f8 09 52 	ld.w	r8,pc[2386]
80003d1e:	70 0c       	ld.w	r12,r8[0x0]
80003d20:	f0 1f 02 4d 	mcall	80004654 <phy_rx_func+0xe98>
80003d24:	8f 0c       	st.w	r7[0x0],r12
					if(NULL == payload_ptr)
80003d26:	e0 80 04 88 	breq	80004636 <phy_rx_func+0xe7a>
					{
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0) break;  //This shouldn't happen, but must check;
80003d2a:	fe f9 09 56 	ld.w	r9,pc[2390]
80003d2e:	72 08       	ld.w	r8,r9[0x0]
80003d30:	20 28       	sub	r8,2
80003d32:	93 08       	st.w	r9[0x0],r8
80003d34:	e0 80 04 81 	breq	80004636 <phy_rx_func+0xe7a>
				RxMediaState = READINGMEDIA;
80003d38:	30 29       	mov	r9,2
80003d3a:	fe f8 09 3e 	ld.w	r8,pc[2366]
80003d3e:	91 09       	st.w	r8[0x0],r9
80003d40:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
		case READINGMEDIA:
				
			/***PCM-media-data ****/
			{
				
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[0];
80003d44:	fe f8 09 84 	ld.w	r8,pc[2436]
80003d48:	70 0a       	ld.w	r10,r8[0x0]
80003d4a:	fe f9 09 26 	ld.w	r9,pc[2342]
80003d4e:	72 09       	ld.w	r9,r9[0x0]
80003d50:	8e 4b       	ld.sh	r11,r7[0x8]
80003d52:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;	
80003d56:	70 09       	ld.w	r9,r8[0x0]
80003d58:	2f f9       	sub	r9,-1
80003d5a:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003d5c:	e0 49 00 ff 	cp.w	r9,255
80003d60:	e0 88 00 16 	brls	80003d8c <phy_rx_func+0x5d0>
				{
					RxMedia_IsFillingNext16 = 0;
80003d64:	30 09       	mov	r9,0
80003d66:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003d68:	fe f6 09 08 	ld.w	r6,pc[2312]
80003d6c:	6c 0c       	ld.w	r12,r6[0x0]
80003d6e:	f0 1f 02 4d 	mcall	800046a0 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
80003d72:	fe f8 08 fa 	ld.w	r8,pc[2298]
80003d76:	70 0c       	ld.w	r12,r8[0x0]
80003d78:	f0 1f 02 37 	mcall	80004654 <phy_rx_func+0xe98>
80003d7c:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
80003d7e:	c0 71       	brne	80003d8c <phy_rx_func+0x5d0>
					{
						RxMediaState = WAITINGABAB;
80003d80:	30 09       	mov	r9,0
80003d82:	fe f8 08 f6 	ld.w	r8,pc[2294]
80003d86:	91 09       	st.w	r8[0x0],r9
80003d88:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0)
80003d8c:	fe f9 08 f4 	ld.w	r9,pc[2292]
80003d90:	72 08       	ld.w	r8,r9[0x0]
80003d92:	20 28       	sub	r8,2
80003d94:	93 08       	st.w	r9[0x0],r8
80003d96:	c0 71       	brne	80003da4 <phy_rx_func+0x5e8>
				{
					RxMediaState = WAITINGABAB;
80003d98:	30 09       	mov	r9,0
80003d9a:	fe f8 08 de 	ld.w	r8,pc[2270]
80003d9e:	91 09       	st.w	r8[0x0],r9
80003da0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[1];
80003da4:	fe f8 09 24 	ld.w	r8,pc[2340]
80003da8:	70 0a       	ld.w	r10,r8[0x0]
80003daa:	fe f9 08 c6 	ld.w	r9,pc[2246]
80003dae:	72 09       	ld.w	r9,r9[0x0]
80003db0:	8e 5b       	ld.sh	r11,r7[0xa]
80003db2:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80003db6:	70 09       	ld.w	r9,r8[0x0]
80003db8:	2f f9       	sub	r9,-1
80003dba:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003dbc:	e0 49 00 ff 	cp.w	r9,255
80003dc0:	e0 88 00 16 	brls	80003dec <phy_rx_func+0x630>
				{
					RxMedia_IsFillingNext16 = 0;
80003dc4:	30 09       	mov	r9,0
80003dc6:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003dc8:	fe f6 08 a8 	ld.w	r6,pc[2216]
80003dcc:	6c 0c       	ld.w	r12,r6[0x0]
80003dce:	f0 1f 02 35 	mcall	800046a0 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
80003dd2:	fe f8 08 9a 	ld.w	r8,pc[2202]
80003dd6:	70 0c       	ld.w	r12,r8[0x0]
80003dd8:	f0 1f 02 1f 	mcall	80004654 <phy_rx_func+0xe98>
80003ddc:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
80003dde:	c0 71       	brne	80003dec <phy_rx_func+0x630>
					{
						RxMediaState = WAITINGABAB;
80003de0:	30 09       	mov	r9,0
80003de2:	fe f8 08 96 	ld.w	r8,pc[2198]
80003de6:	91 09       	st.w	r8[0x0],r9
80003de8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
80003dec:	fe f9 08 94 	ld.w	r9,pc[2196]
80003df0:	72 08       	ld.w	r8,r9[0x0]
80003df2:	20 28       	sub	r8,2
80003df4:	93 08       	st.w	r9[0x0],r8
80003df6:	c0 71       	brne	80003e04 <phy_rx_func+0x648>
					RxMediaState = WAITINGABAB;
80003df8:	30 09       	mov	r9,0
80003dfa:	fe f8 08 7e 	ld.w	r8,pc[2174]
80003dfe:	91 09       	st.w	r8[0x0],r9
80003e00:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}

				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[2];
80003e04:	fe f8 08 c4 	ld.w	r8,pc[2244]
80003e08:	70 0a       	ld.w	r10,r8[0x0]
80003e0a:	fe f9 08 66 	ld.w	r9,pc[2150]
80003e0e:	72 09       	ld.w	r9,r9[0x0]
80003e10:	8e 6b       	ld.sh	r11,r7[0xc]
80003e12:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80003e16:	70 09       	ld.w	r9,r8[0x0]
80003e18:	2f f9       	sub	r9,-1
80003e1a:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003e1c:	e0 49 00 ff 	cp.w	r9,255
80003e20:	e0 88 00 16 	brls	80003e4c <phy_rx_func+0x690>
				{
					RxMedia_IsFillingNext16 = 0;
80003e24:	30 09       	mov	r9,0
80003e26:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003e28:	fe f6 08 48 	ld.w	r6,pc[2120]
80003e2c:	6c 0c       	ld.w	r12,r6[0x0]
80003e2e:	f0 1f 02 1d 	mcall	800046a0 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
80003e32:	fe f8 08 3a 	ld.w	r8,pc[2106]
80003e36:	70 0c       	ld.w	r12,r8[0x0]
80003e38:	f0 1f 02 07 	mcall	80004654 <phy_rx_func+0xe98>
80003e3c:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
80003e3e:	c0 71       	brne	80003e4c <phy_rx_func+0x690>
					{
						RxMediaState = WAITINGABAB;
80003e40:	30 09       	mov	r9,0
80003e42:	fe f8 08 36 	ld.w	r8,pc[2102]
80003e46:	91 09       	st.w	r8[0x0],r9
80003e48:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
80003e4c:	fe f9 08 34 	ld.w	r9,pc[2100]
80003e50:	72 08       	ld.w	r8,r9[0x0]
80003e52:	20 28       	sub	r8,2
80003e54:	93 08       	st.w	r9[0x0],r8
80003e56:	c0 71       	brne	80003e64 <phy_rx_func+0x6a8>
					RxMediaState = WAITINGABAB;
80003e58:	30 09       	mov	r9,0
80003e5a:	fe f8 08 1e 	ld.w	r8,pc[2078]
80003e5e:	91 09       	st.w	r8[0x0],r9
80003e60:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
80003e64:	fe f8 08 64 	ld.w	r8,pc[2148]
80003e68:	70 0a       	ld.w	r10,r8[0x0]
80003e6a:	fe f9 08 06 	ld.w	r9,pc[2054]
80003e6e:	72 09       	ld.w	r9,r9[0x0]
80003e70:	8e 7b       	ld.sh	r11,r7[0xe]
80003e72:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80003e76:	70 09       	ld.w	r9,r8[0x0]
80003e78:	2f f9       	sub	r9,-1
80003e7a:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003e7c:	e0 49 00 ff 	cp.w	r9,255
80003e80:	e0 88 00 16 	brls	80003eac <phy_rx_func+0x6f0>
				{
					RxMedia_IsFillingNext16 = 0;
80003e84:	30 09       	mov	r9,0
80003e86:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003e88:	fe f7 07 e8 	ld.w	r7,pc[2024]
80003e8c:	6e 0c       	ld.w	r12,r7[0x0]
80003e8e:	f0 1f 02 05 	mcall	800046a0 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
80003e92:	fe f8 07 da 	ld.w	r8,pc[2010]
80003e96:	70 0c       	ld.w	r12,r8[0x0]
80003e98:	f0 1f 01 ef 	mcall	80004654 <phy_rx_func+0xe98>
80003e9c:	8f 0c       	st.w	r7[0x0],r12
					if(NULL == payload_ptr)
80003e9e:	c0 71       	brne	80003eac <phy_rx_func+0x6f0>
					{
						RxMediaState = WAITINGABAB;
80003ea0:	30 09       	mov	r9,0
80003ea2:	fe f8 07 d6 	ld.w	r8,pc[2006]
80003ea6:	91 09       	st.w	r8[0x0],r9
80003ea8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
80003eac:	fe f9 07 d4 	ld.w	r9,pc[2004]
80003eb0:	72 08       	ld.w	r8,r9[0x0]
80003eb2:	20 28       	sub	r8,2
80003eb4:	93 08       	st.w	r9[0x0],r8
80003eb6:	e0 81 03 c0 	brne	80004636 <phy_rx_func+0xe7a>
					RxMediaState = WAITINGABAB;
80003eba:	30 09       	mov	r9,0
80003ebc:	fe f8 07 bc 	ld.w	r8,pc[1980]
80003ec0:	91 09       	st.w	r8[0x0],r9
80003ec2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

		case READING_AMBE_MEDIA:
		
			/****AMBE-media-data ****/
		
					if ((Item_ID == Vocoder_Bit_Stream_Parameter))//PAYLOAD_DATA_ENH (0x0c))
80003ec6:	fe f8 07 ca 	ld.w	r8,pc[1994]
80003eca:	11 89       	ld.ub	r9,r8[0x0]
80003ecc:	31 28       	mov	r8,18
80003ece:	f0 09 18 00 	cp.b	r9,r8
80003ed2:	e0 81 01 4c 	brne	8000416a <phy_rx_func+0x9ae>
					{
						Item_ID = payload_rx_channel->byte[1];
80003ed6:	ef 39 00 09 	ld.ub	r9,r7[9]
80003eda:	fe f8 07 b6 	ld.w	r8,pc[1974]
80003ede:	b0 89       	st.b	r8[0x0],r9
						if (Item_ID == Post_Voice_Encoder_Data)//发送方的压缩类型数据
80003ee0:	11 89       	ld.ub	r9,r8[0x0]
80003ee2:	3f 28       	mov	r8,-14
80003ee4:	f0 09 18 00 	cp.b	r9,r8
80003ee8:	e0 81 01 3b 	brne	8000415e <phy_rx_func+0x9a2>
						{
							AMBE_tx_flag = 1;
80003eec:	30 19       	mov	r9,1
80003eee:	fe f8 07 ce 	ld.w	r8,pc[1998]
80003ef2:	b0 89       	st.b	r8[0x0],r9
							
							RxBytesWaiting = ((payload_rx_channel->dword[0] & 0x7F000000) >>24);//Test calculations are correct; 8
80003ef4:	6e 29       	ld.w	r9,r7[0x8]
80003ef6:	f3 d9 c3 07 	bfextu	r9,r9,0x18,0x7
80003efa:	fe f8 07 86 	ld.w	r8,pc[1926]
80003efe:	91 09       	st.w	r8[0x0],r9
							
							//For looping back to Radio
							AMBEBurst_rawdata[0] = payload_rx_channel->word[1];
80003f00:	8e 59       	ld.sh	r9,r7[0xa]
80003f02:	fe f8 07 ce 	ld.w	r8,pc[1998]
80003f06:	b0 09       	st.h	r8[0x0],r9
							AMBEBurst_rawdata[1] = payload_rx_channel->word[2];
80003f08:	8e 69       	ld.sh	r9,r7[0xc]
80003f0a:	b0 19       	st.h	r8[0x2],r9
							AMBEBurst_rawdata[2] = payload_rx_channel->word[3];
80003f0c:	8e 79       	ld.sh	r9,r7[0xe]
80003f0e:	b0 29       	st.h	r8[0x4],r9
							
							//To be tested. Also locally stored RAW-AMBER-DATA
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//1
80003f10:	fe f8 07 88 	ld.w	r8,pc[1928]
80003f14:	fe f9 07 60 	ld.w	r9,pc[1888]
80003f18:	72 0a       	ld.w	r10,r9[0x0]
80003f1a:	70 09       	ld.w	r9,r8[0x0]
80003f1c:	ef 3b 00 0a 	ld.ub	r11,r7[10]
80003f20:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003f24:	70 09       	ld.w	r9,r8[0x0]
80003f26:	2f f9       	sub	r9,-1
80003f28:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003f2a:	e0 49 01 ff 	cp.w	r9,511
80003f2e:	e0 88 00 16 	brls	80003f5a <phy_rx_func+0x79e>
							{
								RxAMBE_IsFillingNext8 = 0;
80003f32:	30 09       	mov	r9,0
80003f34:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003f36:	fe f6 07 3e 	ld.w	r6,pc[1854]
80003f3a:	6c 0c       	ld.w	r12,r6[0x0]
80003f3c:	f0 1f 01 d9 	mcall	800046a0 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003f40:	fe f8 07 2c 	ld.w	r8,pc[1836]
80003f44:	70 0c       	ld.w	r12,r8[0x0]
80003f46:	f0 1f 01 c4 	mcall	80004654 <phy_rx_func+0xe98>
80003f4a:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003f4c:	c0 71       	brne	80003f5a <phy_rx_func+0x79e>
								{
									RxMediaState = WAITINGABAB;
80003f4e:	30 09       	mov	r9,0
80003f50:	fe f8 07 28 	ld.w	r8,pc[1832]
80003f54:	91 09       	st.w	r8[0x0],r9
80003f56:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003f5a:	fe f9 07 26 	ld.w	r9,pc[1830]
80003f5e:	72 08       	ld.w	r8,r9[0x0]
80003f60:	20 18       	sub	r8,1
80003f62:	93 08       	st.w	r9[0x0],r8
80003f64:	c0 71       	brne	80003f72 <phy_rx_func+0x7b6>
								RxMediaState = WAITINGABAB;
80003f66:	30 09       	mov	r9,0
80003f68:	fe f8 07 10 	ld.w	r8,pc[1808]
80003f6c:	91 09       	st.w	r8[0x0],r9
80003f6e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}			
							
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//2
80003f72:	fe f8 07 26 	ld.w	r8,pc[1830]
80003f76:	fe f9 06 fe 	ld.w	r9,pc[1790]
80003f7a:	72 0a       	ld.w	r10,r9[0x0]
80003f7c:	70 09       	ld.w	r9,r8[0x0]
80003f7e:	ef 3b 00 0b 	ld.ub	r11,r7[11]
80003f82:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003f86:	70 09       	ld.w	r9,r8[0x0]
80003f88:	2f f9       	sub	r9,-1
80003f8a:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003f8c:	e0 49 01 ff 	cp.w	r9,511
80003f90:	e0 88 00 16 	brls	80003fbc <phy_rx_func+0x800>
							{
								RxAMBE_IsFillingNext8 = 0;
80003f94:	30 09       	mov	r9,0
80003f96:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003f98:	fe f6 06 dc 	ld.w	r6,pc[1756]
80003f9c:	6c 0c       	ld.w	r12,r6[0x0]
80003f9e:	f0 1f 01 c1 	mcall	800046a0 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003fa2:	fe f8 06 ca 	ld.w	r8,pc[1738]
80003fa6:	70 0c       	ld.w	r12,r8[0x0]
80003fa8:	f0 1f 01 ab 	mcall	80004654 <phy_rx_func+0xe98>
80003fac:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003fae:	c0 71       	brne	80003fbc <phy_rx_func+0x800>
								{
									RxMediaState = WAITINGABAB;
80003fb0:	30 09       	mov	r9,0
80003fb2:	fe f8 06 c6 	ld.w	r8,pc[1734]
80003fb6:	91 09       	st.w	r8[0x0],r9
80003fb8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003fbc:	fe f9 06 c4 	ld.w	r9,pc[1732]
80003fc0:	72 08       	ld.w	r8,r9[0x0]
80003fc2:	20 18       	sub	r8,1
80003fc4:	93 08       	st.w	r9[0x0],r8
80003fc6:	c0 71       	brne	80003fd4 <phy_rx_func+0x818>
								RxMediaState = WAITINGABAB;
80003fc8:	30 09       	mov	r9,0
80003fca:	fe f8 06 ae 	ld.w	r8,pc[1710]
80003fce:	91 09       	st.w	r8[0x0],r9
80003fd0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}		
						
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//3
80003fd4:	fe f8 06 c4 	ld.w	r8,pc[1732]
80003fd8:	fe f9 06 9c 	ld.w	r9,pc[1692]
80003fdc:	72 0a       	ld.w	r10,r9[0x0]
80003fde:	70 09       	ld.w	r9,r8[0x0]
80003fe0:	ef 3b 00 0c 	ld.ub	r11,r7[12]
80003fe4:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003fe8:	70 09       	ld.w	r9,r8[0x0]
80003fea:	2f f9       	sub	r9,-1
80003fec:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003fee:	e0 49 01 ff 	cp.w	r9,511
80003ff2:	e0 88 00 16 	brls	8000401e <phy_rx_func+0x862>
							{
								RxAMBE_IsFillingNext8 = 0;
80003ff6:	30 09       	mov	r9,0
80003ff8:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003ffa:	fe f6 06 7a 	ld.w	r6,pc[1658]
80003ffe:	6c 0c       	ld.w	r12,r6[0x0]
80004000:	f0 1f 01 a8 	mcall	800046a0 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80004004:	fe f8 06 68 	ld.w	r8,pc[1640]
80004008:	70 0c       	ld.w	r12,r8[0x0]
8000400a:	f0 1f 01 93 	mcall	80004654 <phy_rx_func+0xe98>
8000400e:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80004010:	c0 71       	brne	8000401e <phy_rx_func+0x862>
								{
									RxMediaState = WAITINGABAB;
80004012:	30 09       	mov	r9,0
80004014:	fe f8 06 64 	ld.w	r8,pc[1636]
80004018:	91 09       	st.w	r8[0x0],r9
8000401a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
8000401e:	fe f9 06 62 	ld.w	r9,pc[1634]
80004022:	72 08       	ld.w	r8,r9[0x0]
80004024:	20 18       	sub	r8,1
80004026:	93 08       	st.w	r9[0x0],r8
80004028:	c0 71       	brne	80004036 <phy_rx_func+0x87a>
								RxMediaState = WAITINGABAB;
8000402a:	30 09       	mov	r9,0
8000402c:	fe f8 06 4c 	ld.w	r8,pc[1612]
80004030:	91 09       	st.w	r8[0x0],r9
80004032:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[5];//4
80004036:	fe f8 06 62 	ld.w	r8,pc[1634]
8000403a:	fe f9 06 3a 	ld.w	r9,pc[1594]
8000403e:	72 0a       	ld.w	r10,r9[0x0]
80004040:	70 09       	ld.w	r9,r8[0x0]
80004042:	ef 3b 00 0d 	ld.ub	r11,r7[13]
80004046:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
8000404a:	70 09       	ld.w	r9,r8[0x0]
8000404c:	2f f9       	sub	r9,-1
8000404e:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80004050:	e0 49 01 ff 	cp.w	r9,511
80004054:	e0 88 00 16 	brls	80004080 <phy_rx_func+0x8c4>
							{
								RxAMBE_IsFillingNext8 = 0;
80004058:	30 09       	mov	r9,0
8000405a:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
8000405c:	fe f6 06 18 	ld.w	r6,pc[1560]
80004060:	6c 0c       	ld.w	r12,r6[0x0]
80004062:	f0 1f 01 90 	mcall	800046a0 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80004066:	fe f8 06 06 	ld.w	r8,pc[1542]
8000406a:	70 0c       	ld.w	r12,r8[0x0]
8000406c:	f0 1f 01 7a 	mcall	80004654 <phy_rx_func+0xe98>
80004070:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80004072:	c0 71       	brne	80004080 <phy_rx_func+0x8c4>
								{
									RxMediaState = WAITINGABAB;
80004074:	30 09       	mov	r9,0
80004076:	fe f8 06 02 	ld.w	r8,pc[1538]
8000407a:	91 09       	st.w	r8[0x0],r9
8000407c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80004080:	fe f9 06 00 	ld.w	r9,pc[1536]
80004084:	72 08       	ld.w	r8,r9[0x0]
80004086:	20 18       	sub	r8,1
80004088:	93 08       	st.w	r9[0x0],r8
8000408a:	c0 71       	brne	80004098 <phy_rx_func+0x8dc>
								RxMediaState = WAITINGABAB;
8000408c:	30 09       	mov	r9,0
8000408e:	fe f8 05 ea 	ld.w	r8,pc[1514]
80004092:	91 09       	st.w	r8[0x0],r9
80004094:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//5
80004098:	fe f8 06 00 	ld.w	r8,pc[1536]
8000409c:	fe f9 05 d8 	ld.w	r9,pc[1496]
800040a0:	72 0a       	ld.w	r10,r9[0x0]
800040a2:	70 09       	ld.w	r9,r8[0x0]
800040a4:	ef 3b 00 0e 	ld.ub	r11,r7[14]
800040a8:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
800040ac:	70 09       	ld.w	r9,r8[0x0]
800040ae:	2f f9       	sub	r9,-1
800040b0:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800040b2:	e0 49 01 ff 	cp.w	r9,511
800040b6:	e0 88 00 16 	brls	800040e2 <phy_rx_func+0x926>
							{
								RxAMBE_IsFillingNext8 = 0;
800040ba:	30 09       	mov	r9,0
800040bc:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
800040be:	fe f6 05 b6 	ld.w	r6,pc[1462]
800040c2:	6c 0c       	ld.w	r12,r6[0x0]
800040c4:	f0 1f 01 77 	mcall	800046a0 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
800040c8:	fe f8 05 a4 	ld.w	r8,pc[1444]
800040cc:	70 0c       	ld.w	r12,r8[0x0]
800040ce:	f0 1f 01 62 	mcall	80004654 <phy_rx_func+0xe98>
800040d2:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
800040d4:	c0 71       	brne	800040e2 <phy_rx_func+0x926>
								{
									RxMediaState = WAITINGABAB;
800040d6:	30 09       	mov	r9,0
800040d8:	fe f8 05 a0 	ld.w	r8,pc[1440]
800040dc:	91 09       	st.w	r8[0x0],r9
800040de:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800040e2:	fe f9 05 9e 	ld.w	r9,pc[1438]
800040e6:	72 08       	ld.w	r8,r9[0x0]
800040e8:	20 18       	sub	r8,1
800040ea:	93 08       	st.w	r9[0x0],r8
800040ec:	c0 71       	brne	800040fa <phy_rx_func+0x93e>
								RxMediaState = WAITINGABAB;
800040ee:	30 09       	mov	r9,0
800040f0:	fe f8 05 88 	ld.w	r8,pc[1416]
800040f4:	91 09       	st.w	r8[0x0],r9
800040f6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//6
800040fa:	fe f8 05 9e 	ld.w	r8,pc[1438]
800040fe:	fe f9 05 76 	ld.w	r9,pc[1398]
80004102:	72 0a       	ld.w	r10,r9[0x0]
80004104:	70 09       	ld.w	r9,r8[0x0]
80004106:	ef 3b 00 0f 	ld.ub	r11,r7[15]
8000410a:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
8000410e:	70 09       	ld.w	r9,r8[0x0]
80004110:	2f f9       	sub	r9,-1
80004112:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80004114:	e0 49 01 ff 	cp.w	r9,511
80004118:	e0 88 00 16 	brls	80004144 <phy_rx_func+0x988>
							{
								RxAMBE_IsFillingNext8 = 0;
8000411c:	30 09       	mov	r9,0
8000411e:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80004120:	fe f7 05 54 	ld.w	r7,pc[1364]
80004124:	6e 0c       	ld.w	r12,r7[0x0]
80004126:	f0 1f 01 5f 	mcall	800046a0 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
8000412a:	fe f8 05 42 	ld.w	r8,pc[1346]
8000412e:	70 0c       	ld.w	r12,r8[0x0]
80004130:	f0 1f 01 49 	mcall	80004654 <phy_rx_func+0xe98>
80004134:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == AMBE_payload_ptr)
80004136:	c0 71       	brne	80004144 <phy_rx_func+0x988>
								{
									RxMediaState = WAITINGABAB;
80004138:	30 09       	mov	r9,0
8000413a:	fe f8 05 3e 	ld.w	r8,pc[1342]
8000413e:	91 09       	st.w	r8[0x0],r9
80004140:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80004144:	fe f9 05 3c 	ld.w	r9,pc[1340]
80004148:	72 08       	ld.w	r8,r9[0x0]
8000414a:	20 18       	sub	r8,1
8000414c:	93 08       	st.w	r9[0x0],r8
8000414e:	e0 81 02 74 	brne	80004636 <phy_rx_func+0xe7a>
								RxMediaState = WAITINGABAB;
80004152:	30 09       	mov	r9,0
80004154:	fe f8 05 24 	ld.w	r8,pc[1316]
80004158:	91 09       	st.w	r8[0x0],r9
8000415a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							//}
							
						}
						else//error
						{
							RxMediaState = WAITINGABAB;
8000415e:	30 09       	mov	r9,0
80004160:	fe f8 05 18 	ld.w	r8,pc[1304]
80004164:	91 09       	st.w	r8[0x0],r9
80004166:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
					}
					else if (Item_ID == Post_Voice_Encoder_Data)//(bit48~Pad-bits)
8000416a:	fe f8 05 26 	ld.w	r8,pc[1318]
8000416e:	11 89       	ld.ub	r9,r8[0x0]
80004170:	3f 28       	mov	r8,-14
80004172:	f0 09 18 00 	cp.b	r9,r8
80004176:	c4 31       	brne	800041fc <phy_rx_func+0xa40>
					{
					
						AMBEBurst_rawdata[3] = payload_rx_channel->word[0];//(bit48~Pad-bits)
80004178:	8e 49       	ld.sh	r9,r7[0x8]
8000417a:	fe f8 05 56 	ld.w	r8,pc[1366]
8000417e:	b0 39       	st.h	r8[0x6],r9
						//AMBE_Per_Burst_Flag = 1;
						
						//根据MOTO.bit文件数据分布，建议测试pad-bits的最后一个字节不保存。
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//7
80004180:	fe f8 05 18 	ld.w	r8,pc[1304]
80004184:	fe f9 04 f0 	ld.w	r9,pc[1264]
80004188:	72 0a       	ld.w	r10,r9[0x0]
8000418a:	70 09       	ld.w	r9,r8[0x0]
8000418c:	ef 3b 00 08 	ld.ub	r11,r7[8]
80004190:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80004194:	70 09       	ld.w	r9,r8[0x0]
80004196:	2f f9       	sub	r9,-1
80004198:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000419a:	e0 49 01 ff 	cp.w	r9,511
8000419e:	e0 88 00 16 	brls	800041ca <phy_rx_func+0xa0e>
						{
							RxAMBE_IsFillingNext8 = 0;
800041a2:	30 09       	mov	r9,0
800041a4:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
800041a6:	fe f7 04 ce 	ld.w	r7,pc[1230]
800041aa:	6e 0c       	ld.w	r12,r7[0x0]
800041ac:	f0 1f 01 3d 	mcall	800046a0 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
800041b0:	fe f8 04 bc 	ld.w	r8,pc[1212]
800041b4:	70 0c       	ld.w	r12,r8[0x0]
800041b6:	f0 1f 01 28 	mcall	80004654 <phy_rx_func+0xe98>
800041ba:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
800041bc:	c0 71       	brne	800041ca <phy_rx_func+0xa0e>
							{
								RxMediaState = WAITINGABAB;
800041be:	30 09       	mov	r9,0
800041c0:	fe f8 04 b8 	ld.w	r8,pc[1208]
800041c4:	91 09       	st.w	r8[0x0],r9
800041c6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
800041ca:	fe f9 04 b6 	ld.w	r9,pc[1206]
800041ce:	72 08       	ld.w	r8,r9[0x0]
800041d0:	20 18       	sub	r8,1
800041d2:	93 08       	st.w	r9[0x0],r8
800041d4:	c0 71       	brne	800041e2 <phy_rx_func+0xa26>
							RxMediaState = WAITINGABAB;
800041d6:	30 09       	mov	r9,0
800041d8:	fe f8 04 a0 	ld.w	r8,pc[1184]
800041dc:	91 09       	st.w	r8[0x0],r9
800041de:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
						if ((RxBytesWaiting -= 1) <= 0){//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
800041e2:	20 18       	sub	r8,1
800041e4:	fe f9 04 9c 	ld.w	r9,pc[1180]
800041e8:	93 08       	st.w	r9[0x0],r8
800041ea:	58 08       	cp.w	r8,0
800041ec:	e0 81 02 25 	brne	80004636 <phy_rx_func+0xe7a>
							RxMediaState = WAITINGABAB;
800041f0:	30 09       	mov	r9,0
800041f2:	fe f8 04 86 	ld.w	r8,pc[1158]
800041f6:	91 09       	st.w	r8[0x0],r9
800041f8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
								
					}
					else if (Item_ID == Pre_Voice_Decoder_Data)//bit16~bit63
800041fc:	fe f8 04 94 	ld.w	r8,pc[1172]
80004200:	11 89       	ld.ub	r9,r8[0x0]
80004202:	3f 38       	mov	r8,-13
80004204:	f0 09 18 00 	cp.b	r9,r8
80004208:	e0 81 01 0c 	brne	80004420 <phy_rx_func+0xc64>
					{
						//接收方的解压类型数据
						//For looping back to Radio
						AMBEBurst_rawdata[1] = payload_rx_channel->word[0];
8000420c:	8e 49       	ld.sh	r9,r7[0x8]
8000420e:	fe f8 04 c2 	ld.w	r8,pc[1218]
80004212:	b0 19       	st.h	r8[0x2],r9
						AMBEBurst_rawdata[2] = payload_rx_channel->word[1];
80004214:	8e 59       	ld.sh	r9,r7[0xa]
80004216:	b0 29       	st.h	r8[0x4],r9
						AMBEBurst_rawdata[3] = payload_rx_channel->word[2];
80004218:	8e 69       	ld.sh	r9,r7[0xc]
8000421a:	b0 39       	st.h	r8[0x6],r9
						//if((m_RxBurstType == VOICEBURST_A) && (VF_SN == 1))
						//logFromISR("\n\r Pre_rx:%X\n\r", payload_rx_channel->word[2]);
						
						//To be tested. Also locally stored RAW-AMBER-DATA
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//3
8000421c:	fe f8 04 7c 	ld.w	r8,pc[1148]
80004220:	fe f9 04 54 	ld.w	r9,pc[1108]
80004224:	72 0a       	ld.w	r10,r9[0x0]
80004226:	70 09       	ld.w	r9,r8[0x0]
80004228:	ef 3b 00 08 	ld.ub	r11,r7[8]
8000422c:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80004230:	70 09       	ld.w	r9,r8[0x0]
80004232:	2f f9       	sub	r9,-1
80004234:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80004236:	e0 49 01 ff 	cp.w	r9,511
8000423a:	e0 88 00 16 	brls	80004266 <phy_rx_func+0xaaa>
						{
							RxAMBE_IsFillingNext8 = 0;
8000423e:	30 09       	mov	r9,0
80004240:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80004242:	fe f6 04 32 	ld.w	r6,pc[1074]
80004246:	6c 0c       	ld.w	r12,r6[0x0]
80004248:	f0 1f 01 16 	mcall	800046a0 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
8000424c:	fe f8 04 20 	ld.w	r8,pc[1056]
80004250:	70 0c       	ld.w	r12,r8[0x0]
80004252:	f0 1f 01 01 	mcall	80004654 <phy_rx_func+0xe98>
80004256:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80004258:	c0 71       	brne	80004266 <phy_rx_func+0xaaa>
							{
								RxMediaState = WAITINGABAB;
8000425a:	30 09       	mov	r9,0
8000425c:	fe f8 04 1c 	ld.w	r8,pc[1052]
80004260:	91 09       	st.w	r8[0x0],r9
80004262:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80004266:	fe f9 04 1a 	ld.w	r9,pc[1050]
8000426a:	72 08       	ld.w	r8,r9[0x0]
8000426c:	20 18       	sub	r8,1
8000426e:	93 08       	st.w	r9[0x0],r8
80004270:	c0 71       	brne	8000427e <phy_rx_func+0xac2>
							RxMediaState = WAITINGABAB;
80004272:	30 09       	mov	r9,0
80004274:	fe f8 04 04 	ld.w	r8,pc[1028]
80004278:	91 09       	st.w	r8[0x0],r9
8000427a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[1];//4
8000427e:	fe f8 04 1a 	ld.w	r8,pc[1050]
80004282:	fe f9 03 f2 	ld.w	r9,pc[1010]
80004286:	72 0a       	ld.w	r10,r9[0x0]
80004288:	70 09       	ld.w	r9,r8[0x0]
8000428a:	ef 3b 00 09 	ld.ub	r11,r7[9]
8000428e:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80004292:	70 09       	ld.w	r9,r8[0x0]
80004294:	2f f9       	sub	r9,-1
80004296:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80004298:	e0 49 01 ff 	cp.w	r9,511
8000429c:	e0 88 00 16 	brls	800042c8 <phy_rx_func+0xb0c>
						{
							RxAMBE_IsFillingNext8 = 0;
800042a0:	30 09       	mov	r9,0
800042a2:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
800042a4:	fe f6 03 d0 	ld.w	r6,pc[976]
800042a8:	6c 0c       	ld.w	r12,r6[0x0]
800042aa:	f0 1f 00 fe 	mcall	800046a0 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
800042ae:	fe f8 03 be 	ld.w	r8,pc[958]
800042b2:	70 0c       	ld.w	r12,r8[0x0]
800042b4:	f0 1f 00 e8 	mcall	80004654 <phy_rx_func+0xe98>
800042b8:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
800042ba:	c0 71       	brne	800042c8 <phy_rx_func+0xb0c>
							{
								RxMediaState = WAITINGABAB;
800042bc:	30 09       	mov	r9,0
800042be:	fe f8 03 ba 	ld.w	r8,pc[954]
800042c2:	91 09       	st.w	r8[0x0],r9
800042c4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
800042c8:	fe f9 03 b8 	ld.w	r9,pc[952]
800042cc:	72 08       	ld.w	r8,r9[0x0]
800042ce:	20 18       	sub	r8,1
800042d0:	93 08       	st.w	r9[0x0],r8
800042d2:	c0 71       	brne	800042e0 <phy_rx_func+0xb24>
							RxMediaState = WAITINGABAB;
800042d4:	30 09       	mov	r9,0
800042d6:	fe f8 03 a2 	ld.w	r8,pc[930]
800042da:	91 09       	st.w	r8[0x0],r9
800042dc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//5
800042e0:	fe f8 03 b8 	ld.w	r8,pc[952]
800042e4:	fe f9 03 90 	ld.w	r9,pc[912]
800042e8:	72 0a       	ld.w	r10,r9[0x0]
800042ea:	70 09       	ld.w	r9,r8[0x0]
800042ec:	ef 3b 00 0a 	ld.ub	r11,r7[10]
800042f0:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
800042f4:	70 09       	ld.w	r9,r8[0x0]
800042f6:	2f f9       	sub	r9,-1
800042f8:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800042fa:	e0 49 01 ff 	cp.w	r9,511
800042fe:	e0 88 00 16 	brls	8000432a <phy_rx_func+0xb6e>
						{
							RxAMBE_IsFillingNext8 = 0;
80004302:	30 09       	mov	r9,0
80004304:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80004306:	fe f6 03 6e 	ld.w	r6,pc[878]
8000430a:	6c 0c       	ld.w	r12,r6[0x0]
8000430c:	f0 1f 00 e5 	mcall	800046a0 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80004310:	fe f8 03 5c 	ld.w	r8,pc[860]
80004314:	70 0c       	ld.w	r12,r8[0x0]
80004316:	f0 1f 00 d0 	mcall	80004654 <phy_rx_func+0xe98>
8000431a:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
8000431c:	c0 71       	brne	8000432a <phy_rx_func+0xb6e>
							{
								RxMediaState = WAITINGABAB;
8000431e:	30 09       	mov	r9,0
80004320:	fe f8 03 58 	ld.w	r8,pc[856]
80004324:	91 09       	st.w	r8[0x0],r9
80004326:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
8000432a:	fe f9 03 56 	ld.w	r9,pc[854]
8000432e:	72 08       	ld.w	r8,r9[0x0]
80004330:	20 18       	sub	r8,1
80004332:	93 08       	st.w	r9[0x0],r8
80004334:	c0 71       	brne	80004342 <phy_rx_func+0xb86>
							RxMediaState = WAITINGABAB;
80004336:	30 09       	mov	r9,0
80004338:	fe f8 03 40 	ld.w	r8,pc[832]
8000433c:	91 09       	st.w	r8[0x0],r9
8000433e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//6
80004342:	fe f8 03 56 	ld.w	r8,pc[854]
80004346:	fe f9 03 2e 	ld.w	r9,pc[814]
8000434a:	72 0a       	ld.w	r10,r9[0x0]
8000434c:	70 09       	ld.w	r9,r8[0x0]
8000434e:	ef 3b 00 0b 	ld.ub	r11,r7[11]
80004352:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80004356:	70 09       	ld.w	r9,r8[0x0]
80004358:	2f f9       	sub	r9,-1
8000435a:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000435c:	e0 49 01 ff 	cp.w	r9,511
80004360:	e0 88 00 16 	brls	8000438c <phy_rx_func+0xbd0>
						{
							RxAMBE_IsFillingNext8 = 0;
80004364:	30 09       	mov	r9,0
80004366:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80004368:	fe f6 03 0c 	ld.w	r6,pc[780]
8000436c:	6c 0c       	ld.w	r12,r6[0x0]
8000436e:	f0 1f 00 cd 	mcall	800046a0 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80004372:	fe f8 02 fa 	ld.w	r8,pc[762]
80004376:	70 0c       	ld.w	r12,r8[0x0]
80004378:	f0 1f 00 b7 	mcall	80004654 <phy_rx_func+0xe98>
8000437c:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
8000437e:	c0 71       	brne	8000438c <phy_rx_func+0xbd0>
							{
								RxMediaState = WAITINGABAB;
80004380:	30 09       	mov	r9,0
80004382:	fe f8 02 f6 	ld.w	r8,pc[758]
80004386:	91 09       	st.w	r8[0x0],r9
80004388:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
8000438c:	fe f9 02 f4 	ld.w	r9,pc[756]
80004390:	72 08       	ld.w	r8,r9[0x0]
80004392:	20 18       	sub	r8,1
80004394:	93 08       	st.w	r9[0x0],r8
80004396:	c0 71       	brne	800043a4 <phy_rx_func+0xbe8>
							RxMediaState = WAITINGABAB;
80004398:	30 09       	mov	r9,0
8000439a:	fe f8 02 de 	ld.w	r8,pc[734]
8000439e:	91 09       	st.w	r8[0x0],r9
800043a0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//7
800043a4:	fe f8 02 f4 	ld.w	r8,pc[756]
800043a8:	fe f9 02 cc 	ld.w	r9,pc[716]
800043ac:	72 0a       	ld.w	r10,r9[0x0]
800043ae:	70 09       	ld.w	r9,r8[0x0]
800043b0:	ef 3b 00 0c 	ld.ub	r11,r7[12]
800043b4:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
800043b8:	70 09       	ld.w	r9,r8[0x0]
800043ba:	2f f9       	sub	r9,-1
800043bc:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800043be:	e0 49 01 ff 	cp.w	r9,511
800043c2:	e0 88 00 16 	brls	800043ee <phy_rx_func+0xc32>
						{
							RxAMBE_IsFillingNext8 = 0;
800043c6:	30 09       	mov	r9,0
800043c8:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
800043ca:	fe f7 02 aa 	ld.w	r7,pc[682]
800043ce:	6e 0c       	ld.w	r12,r7[0x0]
800043d0:	f0 1f 00 b4 	mcall	800046a0 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
800043d4:	fe f8 02 98 	ld.w	r8,pc[664]
800043d8:	70 0c       	ld.w	r12,r8[0x0]
800043da:	f0 1f 00 9f 	mcall	80004654 <phy_rx_func+0xe98>
800043de:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
800043e0:	c0 71       	brne	800043ee <phy_rx_func+0xc32>
							{
								RxMediaState = WAITINGABAB;
800043e2:	30 09       	mov	r9,0
800043e4:	fe f8 02 94 	ld.w	r8,pc[660]
800043e8:	91 09       	st.w	r8[0x0],r9
800043ea:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
800043ee:	fe f9 02 92 	ld.w	r9,pc[658]
800043f2:	72 08       	ld.w	r8,r9[0x0]
800043f4:	20 18       	sub	r8,1
800043f6:	93 08       	st.w	r9[0x0],r8
800043f8:	c0 71       	brne	80004406 <phy_rx_func+0xc4a>
							RxMediaState = WAITINGABAB;
800043fa:	30 09       	mov	r9,0
800043fc:	fe f8 02 7c 	ld.w	r8,pc[636]
80004400:	91 09       	st.w	r8[0x0],r9
80004402:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
						if ((RxBytesWaiting -= 1) <= 0){
80004406:	20 18       	sub	r8,1
80004408:	fe f9 02 78 	ld.w	r9,pc[632]
8000440c:	93 08       	st.w	r9[0x0],r8
8000440e:	58 08       	cp.w	r8,0
80004410:	e0 81 01 13 	brne	80004636 <phy_rx_func+0xe7a>
							
							//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
							//or discard it to reduce payload size.
							
							RxMediaState = WAITINGABAB;
80004414:	30 09       	mov	r9,0
80004416:	fe f8 02 62 	ld.w	r8,pc[610]
8000441a:	91 09       	st.w	r8[0x0],r9
8000441c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
					}
					else if ((Item_ID == 0x04)  ||  (Item_ID == 0x03))//Unknown type data directly back hair
80004420:	fe f8 02 70 	ld.w	r8,pc[624]
80004424:	11 89       	ld.ub	r9,r8[0x0]
80004426:	30 48       	mov	r8,4
80004428:	f0 09 18 00 	cp.b	r9,r8
8000442c:	c0 80       	breq	8000443c <phy_rx_func+0xc80>
8000442e:	fe f8 02 62 	ld.w	r8,pc[610]
80004432:	11 89       	ld.ub	r9,r8[0x0]
80004434:	30 38       	mov	r8,3
80004436:	f0 09 18 00 	cp.b	r9,r8
8000443a:	c1 41       	brne	80004462 <phy_rx_func+0xca6>
					{
						AMBE_HT[0] = payload_rx_channel->dword[0];
8000443c:	6e 29       	ld.w	r9,r7[0x8]
8000443e:	fe f8 02 7a 	ld.w	r8,pc[634]
80004442:	91 09       	st.w	r8[0x0],r9
						AMBE_HT[1] = payload_rx_channel->dword[1];				
80004444:	6e 39       	ld.w	r9,r7[0xc]
80004446:	91 19       	st.w	r8[0x4],r9
						
						if ((RxBytesWaiting -= 8) <= 0)//Consider two cases 0xABCDC014 and 0xABCDC010
80004448:	fe f9 02 38 	ld.w	r9,pc[568]
8000444c:	72 08       	ld.w	r8,r9[0x0]
8000444e:	20 88       	sub	r8,8
80004450:	93 08       	st.w	r9[0x0],r8
80004452:	e0 81 00 f2 	brne	80004636 <phy_rx_func+0xe7a>
						{
					
							RxBytesWaiting = 0;
80004456:	93 08       	st.w	r9[0x0],r8
							RxMediaState = WAITINGABAB;
80004458:	fe f9 02 20 	ld.w	r9,pc[544]
8000445c:	93 08       	st.w	r9[0x0],r8
8000445e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
						}
						break;

					}
					else if (Item_ID == Soft_Decision_Value)
80004462:	fe f8 02 2e 	ld.w	r8,pc[558]
80004466:	11 89       	ld.ub	r9,r8[0x0]
80004468:	31 38       	mov	r8,19
8000446a:	f0 09 18 00 	cp.b	r9,r8
8000446e:	e0 81 00 9c 	brne	800045a6 <phy_rx_func+0xdea>
					{							
						if (SDV_Index == 12)
80004472:	fe f8 02 62 	ld.w	r8,pc[610]
80004476:	11 88       	ld.ub	r8,r8[0x0]
80004478:	30 c9       	mov	r9,12
8000447a:	f2 08 18 00 	cp.b	r8,r9
8000447e:	e0 81 00 7b 	brne	80004574 <phy_rx_func+0xdb8>
						{
							Soft_Decision_Data[SDV_Index]= payload_rx_channel->word[0];
80004482:	8e 49       	ld.sh	r9,r7[0x8]
80004484:	fe f8 02 54 	ld.w	r8,pc[596]
80004488:	f1 59 00 18 	st.h	r8[24],r9
							
							SDV_Index = 0;
8000448c:	30 09       	mov	r9,0
8000448e:	fe f8 02 46 	ld.w	r8,pc[582]
80004492:	b0 89       	st.b	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80004494:	ef 39 00 0d 	ld.ub	r9,r7[13]
80004498:	3f 38       	mov	r8,-13
8000449a:	f0 09 18 00 	cp.b	r9,r8
8000449e:	c6 61       	brne	8000456a <phy_rx_func+0xdae>
							
							SDV_Index = 0;
								
							if (payload_rx_channel->byte[5] == Pre_Voice_Decoder_Data )//0xF3
							{
									Item_ID = Pre_Voice_Decoder_Data;
800044a0:	10 99       	mov	r9,r8
800044a2:	4f c8       	lddpc	r8,80004690 <phy_rx_func+0xed4>
800044a4:	b0 89       	st.b	r8[0x0],r9
									RxBytesWaiting = (payload_rx_channel->byte[4] & 0x7F);//Test calculations are correct; 8
800044a6:	ef 39 00 0c 	ld.ub	r9,r7[12]
800044aa:	f3 d9 c0 07 	bfextu	r9,r9,0x0,0x7
800044ae:	4f 58       	lddpc	r8,80004680 <phy_rx_func+0xec4>
800044b0:	91 09       	st.w	r8[0x0],r9
									AMBE_rx_flag = 1;//本地作为AMBE数据的解密方
800044b2:	30 19       	mov	r9,1
800044b4:	fe f8 02 0c 	ld.w	r8,pc[524]
800044b8:	b0 89       	st.b	r8[0x0],r9
		
									AMBEBurst_rawdata[0] = payload_rx_channel->word[3];//用于解密的中间数据变量
800044ba:	8e 79       	ld.sh	r9,r7[0xe]
800044bc:	fe f8 02 14 	ld.w	r8,pc[532]
800044c0:	b0 09       	st.h	r8[0x0],r9
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//1
800044c2:	4f 68       	lddpc	r8,80004698 <phy_rx_func+0xedc>
800044c4:	4e c9       	lddpc	r9,80004674 <phy_rx_func+0xeb8>
800044c6:	72 0a       	ld.w	r10,r9[0x0]
800044c8:	70 09       	ld.w	r9,r8[0x0]
800044ca:	ef 3b 00 0e 	ld.ub	r11,r7[14]
800044ce:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
800044d2:	70 09       	ld.w	r9,r8[0x0]
800044d4:	2f f9       	sub	r9,-1
800044d6:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800044d8:	e0 49 01 ff 	cp.w	r9,511
800044dc:	e0 88 00 13 	brls	80004502 <phy_rx_func+0xd46>
									{
										RxAMBE_IsFillingNext8 = 0;
800044e0:	30 09       	mov	r9,0
800044e2:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
800044e4:	4e 46       	lddpc	r6,80004674 <phy_rx_func+0xeb8>
800044e6:	6c 0c       	ld.w	r12,r6[0x0]
800044e8:	f0 1f 00 6e 	mcall	800046a0 <phy_rx_func+0xee4>
										AMBE_payload_ptr = get_payload_idle_isr();
800044ec:	4e 08       	lddpc	r8,8000466c <phy_rx_func+0xeb0>
800044ee:	70 0c       	ld.w	r12,r8[0x0]
800044f0:	f0 1f 00 59 	mcall	80004654 <phy_rx_func+0xe98>
800044f4:	8d 0c       	st.w	r6[0x0],r12
										if(NULL == AMBE_payload_ptr)
800044f6:	c0 61       	brne	80004502 <phy_rx_func+0xd46>
										{
											RxMediaState = WAITINGABAB;
800044f8:	30 09       	mov	r9,0
800044fa:	4e 08       	lddpc	r8,80004678 <phy_rx_func+0xebc>
800044fc:	91 09       	st.w	r8[0x0],r9
800044fe:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
80004502:	4e 09       	lddpc	r9,80004680 <phy_rx_func+0xec4>
80004504:	72 08       	ld.w	r8,r9[0x0]
80004506:	20 18       	sub	r8,1
80004508:	93 08       	st.w	r9[0x0],r8
8000450a:	c0 61       	brne	80004516 <phy_rx_func+0xd5a>
										RxMediaState = WAITINGABAB;
8000450c:	30 09       	mov	r9,0
8000450e:	4d b8       	lddpc	r8,80004678 <phy_rx_func+0xebc>
80004510:	91 09       	st.w	r8[0x0],r9
80004512:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//2
80004516:	4e 18       	lddpc	r8,80004698 <phy_rx_func+0xedc>
80004518:	4d 79       	lddpc	r9,80004674 <phy_rx_func+0xeb8>
8000451a:	72 0a       	ld.w	r10,r9[0x0]
8000451c:	70 09       	ld.w	r9,r8[0x0]
8000451e:	ef 3b 00 0f 	ld.ub	r11,r7[15]
80004522:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
80004526:	70 09       	ld.w	r9,r8[0x0]
80004528:	2f f9       	sub	r9,-1
8000452a:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000452c:	e0 49 01 ff 	cp.w	r9,511
80004530:	e0 88 00 13 	brls	80004556 <phy_rx_func+0xd9a>
									{
										RxAMBE_IsFillingNext8 = 0;
80004534:	30 09       	mov	r9,0
80004536:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
80004538:	4c f7       	lddpc	r7,80004674 <phy_rx_func+0xeb8>
8000453a:	6e 0c       	ld.w	r12,r7[0x0]
8000453c:	f0 1f 00 59 	mcall	800046a0 <phy_rx_func+0xee4>
										AMBE_payload_ptr = get_payload_idle_isr();
80004540:	4c b8       	lddpc	r8,8000466c <phy_rx_func+0xeb0>
80004542:	70 0c       	ld.w	r12,r8[0x0]
80004544:	f0 1f 00 44 	mcall	80004654 <phy_rx_func+0xe98>
80004548:	8f 0c       	st.w	r7[0x0],r12
										if(NULL == AMBE_payload_ptr)
8000454a:	c0 61       	brne	80004556 <phy_rx_func+0xd9a>
										{
											RxMediaState = WAITINGABAB;
8000454c:	30 09       	mov	r9,0
8000454e:	4c b8       	lddpc	r8,80004678 <phy_rx_func+0xebc>
80004550:	91 09       	st.w	r8[0x0],r9
80004552:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
80004556:	4c b9       	lddpc	r9,80004680 <phy_rx_func+0xec4>
80004558:	72 08       	ld.w	r8,r9[0x0]
8000455a:	20 18       	sub	r8,1
8000455c:	93 08       	st.w	r9[0x0],r8
8000455e:	c6 c1       	brne	80004636 <phy_rx_func+0xe7a>
										RxMediaState = WAITINGABAB;
80004560:	30 09       	mov	r9,0
80004562:	4c 68       	lddpc	r8,80004678 <phy_rx_func+0xebc>
80004564:	91 09       	st.w	r8[0x0],r9
80004566:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
							}
							else
							RxMediaState = WAITINGABAB;
8000456a:	30 09       	mov	r9,0
8000456c:	4c 38       	lddpc	r8,80004678 <phy_rx_func+0xebc>
8000456e:	91 09       	st.w	r8[0x0],r9
80004570:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
						}
						else
						{
									
							Soft_Decision_Data[SDV_Index]	  = payload_rx_channel->word[0];
80004574:	8e 4a       	ld.sh	r10,r7[0x8]
80004576:	4d 99       	lddpc	r9,800046d8 <phy_rx_func+0xf1c>
80004578:	f2 08 0a 1a 	st.h	r9[r8<<0x1],r10
							Soft_Decision_Data[SDV_Index+1]	  = payload_rx_channel->word[1];
8000457c:	4d 6a       	lddpc	r10,800046d4 <phy_rx_func+0xf18>
8000457e:	15 88       	ld.ub	r8,r10[0x0]
80004580:	f0 cb ff ff 	sub	r11,r8,-1
80004584:	8e 5c       	ld.sh	r12,r7[0xa]
80004586:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+2]	  = payload_rx_channel->word[2];
8000458a:	f0 cb ff fe 	sub	r11,r8,-2
8000458e:	8e 6c       	ld.sh	r12,r7[0xc]
80004590:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+3]	  = payload_rx_channel->word[3];
80004594:	f0 cb ff fd 	sub	r11,r8,-3
80004598:	8e 7c       	ld.sh	r12,r7[0xe]
8000459a:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							SDV_Index +=4;
8000459e:	2f c8       	sub	r8,-4
800045a0:	b4 88       	st.b	r10[0x0],r8
800045a2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					
					else
					{
						
						RxMediaState  = WAITINGABAB;
800045a6:	30 09       	mov	r9,0
800045a8:	4b 48       	lddpc	r8,80004678 <phy_rx_func+0xebc>
800045aa:	91 09       	st.w	r8[0x0],r9
800045ac:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
		break;//End of READING_AMBE_MEDIA.

        case READING_AMBE_AUX:
			
				Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[0];
800045b0:	4c 08       	lddpc	r8,800046b0 <phy_rx_func+0xef4>
800045b2:	70 09       	ld.w	r9,r8[0x0]
800045b4:	8e 4b       	ld.sh	r11,r7[0x8]
800045b6:	4c 0a       	lddpc	r10,800046b4 <phy_rx_func+0xef8>
800045b8:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
				RxData_IsFillingNext16 += 1;
800045bc:	2f f9       	sub	r9,-1
800045be:	91 09       	st.w	r8[0x0],r9
			
				if ((Item_Length -= 2) <= 0)
800045c0:	4b 58       	lddpc	r8,80004694 <phy_rx_func+0xed8>
800045c2:	70 09       	ld.w	r9,r8[0x0]
800045c4:	20 29       	sub	r9,2
800045c6:	91 09       	st.w	r8[0x0],r9
800045c8:	70 08       	ld.w	r8,r8[0x0]
800045ca:	58 08       	cp.w	r8,0
800045cc:	c2 f1       	brne	8000462a <phy_rx_func+0xe6e>
				{
					RxData_IsFillingNext16 = 0;
800045ce:	30 09       	mov	r9,0
800045d0:	4b 88       	lddpc	r8,800046b0 <phy_rx_func+0xef4>
800045d2:	91 09       	st.w	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
800045d4:	8e 59       	ld.sh	r9,r7[0xa]
800045d6:	fe 78 82 12 	mov	r8,-32238
800045da:	f0 09 19 00 	cp.h	r9,r8
800045de:	c2 11       	brne	80004620 <phy_rx_func+0xe64>
					{
						//Item_ID = Vocoder_Bit_Stream_Parameter;
						//Vocoder Bits Stream Parameter
						//Its value ranges from 1 to 18 for one voice superframe contains 6 voice bursts
						// and each burst contains 3 VFs.
						VF_SN = (payload_rx_channel->byte[5] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
800045e0:	ef 3c 00 0d 	ld.ub	r12,r7[13]
800045e4:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
800045e8:	4a f8       	lddpc	r8,800046a4 <phy_rx_func+0xee8>
800045ea:	b0 8c       	st.b	r8[0x0],r12
							
						VBSP_data[0] = payload_rx_channel->word[1];
800045ec:	8e 59       	ld.sh	r9,r7[0xa]
800045ee:	4a f8       	lddpc	r8,800046a8 <phy_rx_func+0xeec>
800045f0:	b0 09       	st.h	r8[0x0],r9
						VBSP_data[1] = payload_rx_channel->word[2];
800045f2:	8e 69       	ld.sh	r9,r7[0xc]
800045f4:	b0 19       	st.h	r8[0x2],r9
							
						m_RxBurstType = CalculateBurst(VF_SN);
800045f6:	f0 1f 00 2e 	mcall	800046ac <phy_rx_func+0xef0>
800045fa:	4a 18       	lddpc	r8,8000467c <phy_rx_func+0xec0>
800045fc:	91 0c       	st.w	r8[0x0],r12
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
800045fe:	ef 39 00 0f 	ld.ub	r9,r7[15]
80004602:	31 38       	mov	r8,19
80004604:	f0 09 18 00 	cp.b	r9,r8
80004608:	c0 71       	brne	80004616 <phy_rx_func+0xe5a>
							
						m_RxBurstType = CalculateBurst(VF_SN);
						
						if (payload_rx_channel->byte[7] == Soft_Decision_Value)//0x13
						{
							Item_ID = Soft_Decision_Value;	
8000460a:	10 99       	mov	r9,r8
8000460c:	4a 18       	lddpc	r8,80004690 <phy_rx_func+0xed4>
8000460e:	b0 89       	st.b	r8[0x0],r9
							RxBytesWaiting = ((payload_rx_channel->dword[1] & 0x00007F00) >>24);//Test calculations are correct; 26
80004610:	30 09       	mov	r9,0
80004612:	49 c8       	lddpc	r8,80004680 <phy_rx_func+0xec4>
80004614:	91 09       	st.w	r8[0x0],r9
						else
						{//error
								RxMediaState = WAITINGABAB;//Jump
						}
							
						RxMediaState = READING_AMBE_MEDIA;//Jump
80004616:	30 49       	mov	r9,4
80004618:	49 88       	lddpc	r8,80004678 <phy_rx_func+0xebc>
8000461a:	91 09       	st.w	r8[0x0],r9
8000461c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					else
					{
						RxMediaState = WAITINGABAB;//Jump
80004620:	30 09       	mov	r9,0
80004622:	49 68       	lddpc	r8,80004678 <phy_rx_func+0xebc>
80004624:	91 09       	st.w	r8[0x0],r9
80004626:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}

				}
				else
				{//测试看看是几个字节数据
					logFromISR("\n\r Radio Internal parameter length error \n\r");
8000462a:	4a dc       	lddpc	r12,800046dc <phy_rx_func+0xf20>
8000462c:	f0 1f 00 18 	mcall	8000468c <phy_rx_func+0xed0>
					RxMediaState = WAITINGABAB;//Jump
80004630:	30 09       	mov	r9,0
80004632:	49 28       	lddpc	r8,80004678 <phy_rx_func+0xebc>
80004634:	91 09       	st.w	r8[0x0],r9
80004636:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000463a:	00 00       	add	r0,r0
8000463c:	00 00       	add	r0,r0
8000463e:	0a d4       	st.w	--r5,r4
80004640:	00 00       	add	r0,r0
80004642:	0a ec       	st.h	--r5,r12
80004644:	00 00       	add	r0,r0
80004646:	0a cc       	st.b	r5++,r12
80004648:	00 00       	add	r0,r0
8000464a:	0a ae       	st.w	r5++,lr
8000464c:	00 00       	add	r0,r0
8000464e:	0a 9c       	mov	r12,r5
80004650:	00 00       	add	r0,r0
80004652:	0a c4       	st.b	r5++,r4
80004654:	80 00       	ld.sh	r0,r0[0x0]
80004656:	36 3c       	mov	r12,99
80004658:	00 00       	add	r0,r0
8000465a:	0a bc       	st.h	r5++,r12
8000465c:	80 00       	ld.sh	r0,r0[0x0]
8000465e:	35 54       	mov	r4,85
80004660:	00 00       	add	r0,r0
80004662:	0a d0       	st.w	--r5,r0
80004664:	80 00       	ld.sh	r0,r0[0x0]
80004666:	35 88       	mov	r8,88
80004668:	00 00       	add	r0,r0
8000466a:	0a ad       	st.w	r5++,sp
8000466c:	00 00       	add	r0,r0
8000466e:	0a c8       	st.b	r5++,r8
80004670:	00 00       	add	r0,r0
80004672:	0a d8       	st.w	--r5,r8
80004674:	00 00       	add	r0,r0
80004676:	0a b0       	st.h	r5++,r0
80004678:	00 00       	add	r0,r0
8000467a:	0a f8       	st.b	--r5,r8
8000467c:	00 00       	add	r0,r0
8000467e:	0a e0       	st.h	--r5,r0
80004680:	00 00       	add	r0,r0
80004682:	0a 98       	mov	r8,r5
80004684:	00 00       	add	r0,r0
80004686:	0a 61       	and	r1,r5
80004688:	80 00       	ld.sh	r0,r0[0x0]
8000468a:	e7 a8 80 00 	cop	cp4,cr0,cr0,cr0,0x70
8000468e:	7f 78       	ld.w	r8,pc[0x5c]
80004690:	00 00       	add	r0,r0
80004692:	0a ac       	st.w	r5++,r12
80004694:	00 00       	add	r0,r0
80004696:	0b 04       	ld.w	r4,r5++
80004698:	00 00       	add	r0,r0
8000469a:	0a e4       	st.h	--r5,r4
8000469c:	80 00       	ld.sh	r0,r0[0x0]
8000469e:	87 d6       	st.w	r3[0x34],r6
800046a0:	80 00       	ld.sh	r0,r0[0x0]
800046a2:	35 70       	mov	r0,87
800046a4:	00 00       	add	r0,r0
800046a6:	0a 74       	tst	r4,r5
800046a8:	00 00       	add	r0,r0
800046aa:	1f 34       	ld.ub	r4,pc++
800046ac:	80 00       	ld.sh	r0,r0[0x0]
800046ae:	35 24       	mov	r4,82
800046b0:	00 00       	add	r0,r0
800046b2:	0a a0       	st.w	r5++,r0
800046b4:	00 00       	add	r0,r0
800046b6:	1e 38       	cp.w	r8,pc
800046b8:	00 00       	add	r0,r0
800046ba:	0a a4       	st.w	r5++,r4
800046bc:	00 00       	add	r0,r0
800046be:	0a 62       	and	r2,r5
800046c0:	00 00       	add	r0,r0
800046c2:	0a 7e       	tst	lr,r5
800046c4:	00 00       	add	r0,r0
800046c6:	0a fc       	st.b	--r5,r12
800046c8:	00 00       	add	r0,r0
800046ca:	0a b8       	st.h	r5++,r8
800046cc:	00 00       	add	r0,r0
800046ce:	0a 89       	andn	r9,r5
800046d0:	00 00       	add	r0,r0
800046d2:	1e 30       	cp.w	r0,pc
800046d4:	00 00       	add	r0,r0
800046d6:	0a f0       	st.b	--r5,r0
800046d8:	00 00       	add	r0,r0
800046da:	1f 38       	ld.ub	r8,pc++
800046dc:	80 00       	ld.sh	r0,r0[0x0]
800046de:	e7 c0 d4 01 	ldmts	r0++,r0,r10,r12,lr-pc

800046e0 <pdca_int_handler>:
    void (*phy_rx_exec)(void *)--callback function for receive SSC data 
Called By: interrupt
*/
__attribute__((__interrupt__))
static void pdca_int_handler(void)
{
800046e0:	d4 01       	pushm	lr
	//xHigherPriorityTaskWoken = pdFALSE;
	
	static U32 count=0;
	//intStartCount = Get_system_register(AVR32_COUNT);
	
	count++;
800046e2:	49 a8       	lddpc	r8,80004748 <pdca_int_handler+0x68>
800046e4:	70 09       	ld.w	r9,r8[0x0]
800046e6:	2f f9       	sub	r9,-1
800046e8:	91 09       	st.w	r8[0x0],r9
	/*Toggle Index*/
    BufferIndex ^= 0x01;
800046ea:	49 98       	lddpc	r8,8000474c <pdca_int_handler+0x6c>
800046ec:	11 89       	ld.ub	r9,r8[0x0]
800046ee:	ec 19 00 01 	eorl	r9,0x1
800046f2:	b0 89       	st.b	r8[0x0],r9
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);
800046f4:	11 89       	ld.ub	r9,r8[0x0]
800046f6:	a5 69       	lsl	r9,0x4
800046f8:	2f c9       	sub	r9,-4
800046fa:	49 6a       	lddpc	r10,80004750 <pdca_int_handler+0x70>
800046fc:	14 09       	add	r9,r10
	count++;
	/*Toggle Index*/
    BufferIndex ^= 0x01;
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
800046fe:	fe 7a 00 40 	mov	r10,-65472
80004702:	95 39       	st.w	r10[0xc],r9
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80004704:	30 39       	mov	r9,3
80004706:	95 49       	st.w	r10[0x10],r9

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);
80004708:	11 8a       	ld.ub	r10,r8[0x0]
8000470a:	a5 6a       	lsl	r10,0x4
8000470c:	2f ca       	sub	r10,-4
8000470e:	49 28       	lddpc	r8,80004754 <pdca_int_handler+0x74>
80004710:	10 0a       	add	r10,r8
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
80004712:	fe 78 00 00 	mov	r8,-65536
80004716:	91 3a       	st.w	r8[0xc],r10
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80004718:	91 49       	st.w	r8[0x10],r9
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr;
8000471a:	70 b8       	ld.w	r8,r8[0x2c]
	
	/*receive SSC data*/
    if(phy_rx_exec != NULL)phy_rx_exec((void *)&RxBuffer[BufferIndex]);
8000471c:	48 f8       	lddpc	r8,80004758 <pdca_int_handler+0x78>
8000471e:	70 08       	ld.w	r8,r8[0x0]
80004720:	58 08       	cp.w	r8,0
80004722:	c0 70       	breq	80004730 <pdca_int_handler+0x50>
80004724:	48 a9       	lddpc	r9,8000474c <pdca_int_handler+0x6c>
80004726:	13 89       	ld.ub	r9,r9[0x0]
80004728:	a5 69       	lsl	r9,0x4
8000472a:	48 bc       	lddpc	r12,80004754 <pdca_int_handler+0x74>
8000472c:	12 0c       	add	r12,r9
8000472e:	5d 18       	icall	r8

    /*transmit SSC data*/

	if(phy_tx_exec != NULL)phy_tx_exec((void *)&TxBuffer[BufferIndex]);//phy_tx_func, phy_rx_func
80004730:	48 b8       	lddpc	r8,8000475c <pdca_int_handler+0x7c>
80004732:	70 08       	ld.w	r8,r8[0x0]
80004734:	58 08       	cp.w	r8,0
80004736:	c0 70       	breq	80004744 <pdca_int_handler+0x64>
80004738:	48 59       	lddpc	r9,8000474c <pdca_int_handler+0x6c>
8000473a:	13 89       	ld.ub	r9,r9[0x0]
8000473c:	a5 69       	lsl	r9,0x4
8000473e:	48 5c       	lddpc	r12,80004750 <pdca_int_handler+0x70>
80004740:	12 0c       	add	r12,r9
80004742:	5d 18       	icall	r8

	
	//intDuration = Get_system_register(AVR32_COUNT) - intStartCount;
	
	
}/*End of pdca_int_handler.*/
80004744:	d4 02       	popm	lr
80004746:	d6 03       	rete
80004748:	00 00       	add	r0,r0
8000474a:	0b 0c       	ld.w	r12,r5++
8000474c:	00 00       	add	r0,r0
8000474e:	97 58       	st.w	r11[0x14],r8
80004750:	00 00       	add	r0,r0
80004752:	97 80       	st.w	r11[0x20],r0
80004754:	00 00       	add	r0,r0
80004756:	97 60       	st.w	r11[0x18],r0
80004758:	00 00       	add	r0,r0
8000475a:	0b 08       	ld.w	r8,r5++
8000475c:	00 00       	add	r0,r0
8000475e:	0b 10       	ld.sh	r0,r5++

80004760 <local_start_SSC>:
void local_start_SSC(void)
{
    /*Assign GPIO to SSC.
    gpio_enable_module
    gpio_enable_module_pin*/
    AVR32_GPIO.port[1].pmr0c = 0x00000DC0;
80004760:	fe 78 10 00 	mov	r8,-61440
80004764:	e0 69 0d c0 	mov	r9,3520
80004768:	f1 49 01 18 	st.w	r8[280],r9
    AVR32_GPIO.port[1].pmr1c = 0x00000DC0;
8000476c:	f1 49 01 28 	st.w	r8[296],r9
    AVR32_GPIO.port[1].gperc = 0x00000DC0;
80004770:	f1 49 01 08 	st.w	r8[264],r9

    /*Software reset SSC*/
    (&AVR32_SSC)->cr = AVR32_SSC_CR_SWRST_MASK;
80004774:	fe 78 34 00 	mov	r8,-52224
80004778:	e0 69 80 00 	mov	r9,32768
8000477c:	91 09       	st.w	r8[0x0],r9
    (&AVR32_SSC)->cmr 
8000477e:	30 09       	mov	r9,0
80004780:	91 19       	st.w	r8[0x4],r9
                     = AVR32_SSC_CMR_DIV_NOT_ACTIVE << AVR32_SSC_CMR_DIV_OFFSET;

    /*For Slave*/
    (&AVR32_SSC)->tcmr =
80004782:	e0 69 04 21 	mov	r9,1057
80004786:	ea 19 3f 20 	orh	r9,0x3f20
8000478a:	91 69       	st.w	r8[0x18],r9
	      32								<< AVR32_SSC_TCMR_STTDLY_OFFSET	|
	      63								<< AVR32_SSC_TCMR_PERIOD_OFFSET;


    /*For Slave*/
    (&AVR32_SSC)->tfmr = 
8000478c:	e0 69 02 9f 	mov	r9,671
80004790:	ea 19 01 00 	orh	r9,0x100
80004794:	91 79       	st.w	r8[0x1c],r9
	     0									<< AVR32_SSC_TFMR_FSDEN_OFFSET	|
	     1									<< AVR32_SSC_TFMR_FSEDGE_OFFSET;

	/*For Slave*/

	(&AVR32_SSC)->rcmr = 
80004796:	e0 6a 04 02 	mov	r10,1026
8000479a:	ea 1a 3f 20 	orh	r10,0x3f20
8000479e:	91 4a       	st.w	r8[0x10],r10
	     0									<< AVR32_SSC_RCMR_STOP_OFFSET	|
	     32									<< AVR32_SSC_RCMR_STTDLY_OFFSET	|
	     63									<< AVR32_SSC_RCMR_PERIOD_OFFSET;

	/*For Slave*/
	(&AVR32_SSC)->rfmr = 
800047a0:	91 59       	st.w	r8[0x14],r9
	    1									<< AVR32_SSC_RFMR_MSBF_OFFSET	|
	    2									<< AVR32_SSC_RFMR_DATNB_OFFSET	|
	    0									<< AVR32_SSC_RFMR_FSLEN_OFFSET	|
	    AVR32_SSC_RFMR_FSOS_INPUT_ONLY		<< AVR32_SSC_RFMR_FSOS_OFFSET	|
	    1									<< AVR32_SSC_RFMR_FSEDGE_OFFSET;
}/*End of local_start_SSC.*/
800047a2:	5e fc       	retal	r12

800047a4 <local_start_PDC>:
Function: local_start_PDC
Description: none
Called By: void ssc_init(void) -- ssc.c
*/
void local_start_PDC(void)
{
800047a4:	d4 01       	pushm	lr
    /*Toggle Index*/	
    BufferIndex = 1;
800047a6:	30 19       	mov	r9,1
800047a8:	49 78       	lddpc	r8,80004804 <local_start_PDC+0x60>
800047aa:	b0 89       	st.b	r8[0x0],r9
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
800047ac:	fe 78 00 00 	mov	r8,-65536
800047b0:	30 7b       	mov	r11,7
800047b2:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
800047b4:	70 b9       	ld.w	r9,r8[0x2c]
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
800047b6:	49 59       	lddpc	r9,80004808 <local_start_PDC+0x64>
800047b8:	f2 ca ff fc 	sub	r10,r9,-4
    BufferIndex = 1;
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
800047bc:	91 0a       	st.w	r8[0x0],r10
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
800047be:	30 3a       	mov	r10,3
800047c0:	91 2a       	st.w	r8[0x8],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
800047c2:	30 1c       	mov	r12,1
800047c4:	91 1c       	st.w	r8[0x4],r12
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
800047c6:	2e c9       	sub	r9,-20
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
800047c8:	91 39       	st.w	r8[0xc],r9
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
800047ca:	91 4a       	st.w	r8[0x10],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mr = AVR32_PDCA_WORD;
800047cc:	30 2c       	mov	r12,2
800047ce:	91 6c       	st.w	r8[0x18],r12

	TxBuffer[0].xnl_channel.dword = XNL_IDLE;
800047d0:	48 f9       	lddpc	r9,8000480c <local_start_PDC+0x68>
800047d2:	e0 68 5a 5a 	mov	r8,23130
800047d6:	ea 18 ab cd 	orh	r8,0xabcd
800047da:	93 18       	st.w	r9[0x4],r8
	TxBuffer[0].payload_channel.dword[0] = PAYLOADIDLE0;
800047dc:	93 28       	st.w	r9[0x8],r8
	TxBuffer[0].payload_channel.dword[1] = PAYLOADIDLE1;
800047de:	30 0e       	mov	lr,0
800047e0:	93 3e       	st.w	r9[0xc],lr
	TxBuffer[1].xnl_channel.dword = XNL_IDLE;
800047e2:	93 58       	st.w	r9[0x14],r8
	TxBuffer[1].payload_channel.dword[0] = PAYLOADIDLE0;
800047e4:	93 68       	st.w	r9[0x18],r8
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;
800047e6:	93 7e       	st.w	r9[0x1c],lr

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
800047e8:	fe 78 00 40 	mov	r8,-65472
800047ec:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
800047ee:	70 be       	ld.w	lr,r8[0x2c]
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
800047f0:	f2 ce ff fc 	sub	lr,r9,-4
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
800047f4:	91 0e       	st.w	r8[0x0],lr
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
800047f6:	91 2a       	st.w	r8[0x8],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
800047f8:	91 1b       	st.w	r8[0x4],r11
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
800047fa:	2e c9       	sub	r9,-20
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
800047fc:	91 39       	st.w	r8[0xc],r9
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
800047fe:	91 4a       	st.w	r8[0x10],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80004800:	91 6c       	st.w	r8[0x18],r12
}/*End of local_start_PDC.*/
80004802:	d8 02       	popm	pc
80004804:	00 00       	add	r0,r0
80004806:	97 58       	st.w	r11[0x14],r8
80004808:	00 00       	add	r0,r0
8000480a:	97 60       	st.w	r11[0x18],r0
8000480c:	00 00       	add	r0,r0
8000480e:	97 80       	st.w	r11[0x20],r0

80004810 <register_rx_tx_func>:
Description: register the rx function(callback function)
Called By: phy_init -- physical.c
*/
void register_rx_tx_func(void (*rx_exec)(void *),  void ( *tx_exec)(void *))
{
	 phy_rx_exec = rx_exec;
80004810:	48 38       	lddpc	r8,8000481c <register_rx_tx_func+0xc>
80004812:	91 0c       	st.w	r8[0x0],r12
	 phy_tx_exec = tx_exec;//phy_tx_func, phy_rx_func
80004814:	48 38       	lddpc	r8,80004820 <register_rx_tx_func+0x10>
80004816:	91 0b       	st.w	r8[0x0],r11
	 
}/*End of register_tx_rx_func.*/
80004818:	5e fc       	retal	r12
8000481a:	00 00       	add	r0,r0
8000481c:	00 00       	add	r0,r0
8000481e:	0b 08       	ld.w	r8,r5++
80004820:	00 00       	add	r0,r0
80004822:	0b 10       	ld.sh	r0,r5++

80004824 <ssc_init>:
    local_start_SSC -- ssc.c
    local_start_PDC -- ssc.c
Called By: phy_init -- physical.c
*/
void ssc_init(void)
{		
80004824:	d4 01       	pushm	lr
    /*Set up PB01 to watch FS.*/
    AVR32_GPIO.port[1].oderc = 0x00000002;
80004826:	fe 78 10 00 	mov	r8,-61440
8000482a:	30 29       	mov	r9,2
8000482c:	f1 49 01 48 	st.w	r8[328],r9
    AVR32_GPIO.port[1].gpers = 0x00000002;
80004830:	f1 49 01 04 	st.w	r8[260],r9
	
	Disable_global_interrupt();
80004834:	d3 03       	ssrf	0x10
	
	INTC_register_interrupt (
80004836:	30 3a       	mov	r10,3
80004838:	36 0b       	mov	r11,96
8000483a:	49 4c       	lddpc	r12,80004888 <ssc_init+0x64>
8000483c:	f0 1f 00 14 	mcall	8000488c <ssc_init+0x68>
	&pdca_int_handler
	, AVR32_PDCA_IRQ_0 //PDCA_CHANNEL_SSCRX_EXAMPLE = 0
	, AVR32_INTC_INT3 //highest priority.
	);
	
	Enable_global_interrupt();
80004840:	d5 03       	csrf	0x10
	
    /*Waits for radio to start making FSYNC.*/
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
80004842:	fe 79 10 00 	mov	r9,-61440
80004846:	f2 f8 01 60 	ld.w	r8,r9[352]
8000484a:	e2 18 00 02 	andl	r8,0x2,COH
8000484e:	cf c0       	breq	80004846 <ssc_init+0x22>
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
80004850:	fe 79 10 00 	mov	r9,-61440
80004854:	f2 f8 01 60 	ld.w	r8,r9[352]
80004858:	e2 18 00 02 	andl	r8,0x2,COH
8000485c:	cf c1       	brne	80004854 <ssc_init+0x30>
			
	Disable_global_interrupt(); // resume to before
8000485e:	d3 03       	ssrf	0x10
				
    /*config the SSC*/
    local_start_SSC();
80004860:	f0 1f 00 0c 	mcall	80004890 <ssc_init+0x6c>

    /*config the PDCA*/
    local_start_PDC();
80004864:	f0 1f 00 0c 	mcall	80004894 <ssc_init+0x70>
		
    /*Start the SSC Physical Layer.*/

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80004868:	fe 79 00 00 	mov	r9,-65536
8000486c:	30 18       	mov	r8,1
8000486e:	93 58       	st.w	r9[0x14],r8
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80004870:	fe 7a 00 40 	mov	r10,-65472
80004874:	95 58       	st.w	r10[0x14],r8
    (&AVR32_SSC)->cr = AVR32_SSC_CR_RXEN_MASK | AVR32_SSC_CR_TXEN_MASK;
80004876:	e0 6b 01 01 	mov	r11,257
8000487a:	fe 7a 34 00 	mov	r10,-52224
8000487e:	95 0b       	st.w	r10[0x0],r11
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->ier = AVR32_PDCA_RCZ_MASK;
80004880:	93 88       	st.w	r9[0x20],r8
															
	Enable_global_interrupt();
80004882:	d5 03       	csrf	0x10
															
}/*End of ssc_init.*/
80004884:	d8 02       	popm	pc
80004886:	00 00       	add	r0,r0
80004888:	80 00       	ld.sh	r0,r0[0x0]
8000488a:	46 e0       	lddsp	r0,sp[0x1b8]
8000488c:	80 00       	ld.sh	r0,r0[0x0]
8000488e:	62 54       	ld.w	r4,r1[0x14]
80004890:	80 00       	ld.sh	r0,r0[0x0]
80004892:	47 60       	lddsp	r0,sp[0x1d8]
80004894:	80 00       	ld.sh	r0,r0[0x0]
80004896:	47 a4       	lddsp	r4,sp[0x1e8]

80004898 <xcmp_register_app_list>:
Calls: 
Called By: app_init -- app.c
*/
void xcmp_register_app_list(void * list)
{
	app_list = (app_exec_t *)list;
80004898:	48 28       	lddpc	r8,800048a0 <xcmp_register_app_list+0x8>
8000489a:	91 0c       	st.w	r8[0x0],r12
}
8000489c:	5e fc       	retal	r12
8000489e:	00 00       	add	r0,r0
800048a0:	00 00       	add	r0,r0
800048a2:	97 a0       	st.w	r11[0x28],r0

800048a4 <xcmp_tx>:
Calls:   
	xnl_tx -- xnl.c
Called By: ...
*/
static void xcmp_tx( xcmp_fragment_t * xcmp, U8 payload_len)
{
800048a4:	eb cd 40 80 	pushm	r7,lr
800048a8:	fa cd 01 00 	sub	sp,sp,256
800048ac:	16 97       	mov	r7,r11
	Length :xnl length + checksum
	= checksum + xnl header + xcmp opcode + xcmp payload
	= 0x02 + 0x0C + 0x02 + xcmp payload
	= 0x10 + xcmp payload
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | ( 0x10 + payload_len);
800048ae:	16 98       	mov	r8,r11
800048b0:	2f 08       	sub	r8,-16
800048b2:	af a8       	sbr	r8,0xe
800048b4:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE; 
800048b6:	3f f8       	mov	r8,-1
800048b8:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG;
800048ba:	30 b9       	mov	r9,11
800048bc:	ba 29       	st.h	sp[0x4],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;	
800048be:	ba 38       	st.h	sp[0x6],r8
	xnl_frame.xnl_header.destination = DEFAULT_VALUE;
800048c0:	ba 48       	st.h	sp[0x8],r8
	xnl_frame.xnl_header.source = DEFAULT_VALUE;	
800048c2:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
800048c4:	ba 68       	st.h	sp[0xc],r8
	
	/*insert xcmp frame data*/
	memcpy(&xnl_frame.xnl_payload.xnl_content_data_msg, xcmp, payload_len + 2);
800048c6:	f6 ca ff fe 	sub	r10,r11,-2
800048ca:	18 9b       	mov	r11,r12
800048cc:	fa cc ff f0 	sub	r12,sp,-16
800048d0:	f0 1f 00 05 	mcall	800048e4 <xcmp_tx+0x40>
	xnl_frame.xnl_header.payload_length = payload_len + 2;	
800048d4:	2f e7       	sub	r7,-2
800048d6:	ba 77       	st.h	sp[0xe],r7
	
	/* send xnl frame*/	
	xnl_tx(&xnl_frame);
800048d8:	1a 9c       	mov	r12,sp
800048da:	f0 1f 00 04 	mcall	800048e8 <xcmp_tx+0x44>
}
800048de:	2c 0d       	sub	sp,-256
800048e0:	e3 cd 80 80 	ldm	sp++,r7,pc
800048e4:	80 00       	ld.sh	r0,r0[0x0]
800048e6:	86 8e       	ld.uh	lr,r3[0x0]
800048e8:	80 00       	ld.sh	r0,r0[0x0]
800048ea:	4e bc       	lddpc	r12,80004a94 <xcmp_init+0x4>

800048ec <xcmp_data_session_req>:
Description: send data-session request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_data_session_req(void *message, U16 length, U32 dest)
{
800048ec:	d4 21       	pushm	r4-r7,lr
800048ee:	fa cd 00 d0 	sub	sp,sp,208
800048f2:	18 94       	mov	r4,r12
800048f4:	16 97       	mov	r7,r11
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
	
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
	
	if (length > 256)return -1;
800048f6:	e0 68 01 00 	mov	r8,256
800048fa:	f0 0b 19 00 	cp.h	r11,r8
800048fe:	e0 8b 00 38 	brhi	8000496e <xcmp_data_session_req+0x82>
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
	
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
80004902:	fa c5 ff f8 	sub	r5,sp,-8
	//U8 SizeofAddress = Remote_Mototrbo_Address_Size;// 3;//可能会变化
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
80004906:	e0 68 04 1d 	mov	r8,1053
8000490a:	ba 38       	st.h	sp[0x6],r8
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
	
	if (length > 256)return -1;
	
	ptr->Function = Single_Data_Uint;
8000490c:	30 18       	mov	r8,1
8000490e:	aa 88       	st.b	r5[0x0],r8
	
	ptr->DataDefinition.Data_Protocol_Version = TMP_Ver_1_1;//0x20
80004910:	32 08       	mov	r8,32
80004912:	aa 98       	st.b	r5[0x1],r8
	
	ptr->DataDefinition.Dest_Address.Remote_Address_Type = Remote_IPV4_Address;//0x02
80004914:	30 28       	mov	r8,2
80004916:	aa a8       	st.b	r5[0x2],r8
	
	ptr->DataDefinition.Dest_Address.Remote_Address_Size = Remote_IPV4_Address_Size;//0x04
80004918:	30 48       	mov	r8,4
8000491a:	aa b8       	st.b	r5[0x3],r8
	
	unsigned int addr = 0x0C000000 | (dest & 0x00FFFFFF);
8000491c:	f5 da c0 18 	bfextu	r10,r10,0x0,0x18
80004920:	ea 1a 0c 00 	orh	r10,0xc00
80004924:	50 0a       	stdsp	sp[0x0],r10
	memcpy(ptr->DataDefinition.Dest_Address.Remote_Address, &addr, Remote_IPV4_Address_Size);
80004926:	30 4a       	mov	r10,4
80004928:	1a 9b       	mov	r11,sp
8000492a:	fa cc ff f4 	sub	r12,sp,-12
8000492e:	f0 1f 00 12 	mcall	80004974 <xcmp_data_session_req+0x88>
	//ptr->DataDefinition.Dest_Address.Remote_Address[0] = 0x0C;//12
	//ptr->DataDefinition.Dest_Address.Remote_Address[1] = 0x00;//0
	//ptr->DataDefinition.Dest_Address.Remote_Address[2] = 0x00;//0
	//ptr->DataDefinition.Dest_Address.Remote_Address[3] = 0x02;//2
	
	ptr->DataDefinition.Dest_Address.Remote_Port_Com[0] = (Remote_Port >>8) & 0xFF;//4007
80004932:	30 f8       	mov	r8,15
80004934:	eb 68 00 08 	st.b	r5[8],r8
	ptr->DataDefinition.Dest_Address.Remote_Port_Com[1] = Remote_Port & 0xFF;//
80004938:	3a 78       	mov	r8,-89
8000493a:	eb 68 00 09 	st.b	r5[9],r8
	
    
	ptr->DataPayload.Session_ID_Number = Session_ID;//0x00
8000493e:	30 08       	mov	r8,0
80004940:	eb 68 00 0a 	st.b	r5[10],r8
	
	ptr->DataPayload.DataPayload_Length[0] =(length >> 8) & 0xFF ;//可能会变化
80004944:	0e 9a       	mov	r10,r7
80004946:	5c 7a       	castu.h	r10
80004948:	f4 08 16 08 	lsr	r8,r10,0x8
8000494c:	eb 68 00 0b 	st.b	r5[11],r8
	ptr->DataPayload.DataPayload_Length[1] =length & 0xFF  ;//可能会变化
80004950:	0e 96       	mov	r6,r7
80004952:	eb 67 00 0c 	st.b	r5[12],r7
	
	memcpy(&(ptr->DataPayload.DataPayload[0]), message, length);
80004956:	08 9b       	mov	r11,r4
80004958:	fa cc ff eb 	sub	r12,sp,-21
8000495c:	f0 1f 00 06 	mcall	80004974 <xcmp_data_session_req+0x88>
	
	xcmp_tx(&xcmp_farme, sizeof(DataSession_req_t) - (256 - length));
80004960:	ee cb ff f3 	sub	r11,r7,-13
80004964:	5c 5b       	castu.b	r11
80004966:	fa cc ff fa 	sub	r12,sp,-6
8000496a:	f0 1f 00 04 	mcall	80004978 <xcmp_data_session_req+0x8c>
}
8000496e:	2c cd       	sub	sp,-208
80004970:	d8 22       	popm	r4-r7,pc
80004972:	00 00       	add	r0,r0
80004974:	80 00       	ld.sh	r0,r0[0x0]
80004976:	86 8e       	ld.uh	lr,r3[0x0]
80004978:	80 00       	ld.sh	r0,r0[0x0]
8000497a:	48 a4       	lddpc	r4,800049a0 <xcmp_DeviceInitializationStatus_request+0x24>

8000497c <xcmp_DeviceInitializationStatus_request>:
Description: send device initialization status request
Calls: xcmp_tx
Called By:...
*/
void xcmp_DeviceInitializationStatus_request(void)
{
8000497c:	d4 01       	pushm	lr
8000497e:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
		
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_BRDCAST | DEVICE_INITIALIZATION_STATUS;
80004982:	fe 78 b4 00 	mov	r8,-19456
80004986:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	DeviceInitializationStatus_brdcst_t * ptr 
						 = (DeviceInitializationStatus_brdcst_t *)xcmp_farme.u8;
80004988:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*xcmp version 8.1.0.5*///版本号未正确填写，纠正
	ptr->XCMPVersion[0] = XCMP_Version[0];
8000498c:	48 c9       	lddpc	r9,800049bc <xcmp_DeviceInitializationStatus_request+0x40>
8000498e:	13 8a       	ld.ub	r10,r9[0x0]
80004990:	b0 8a       	st.b	r8[0x0],r10
	ptr->XCMPVersion[1] = XCMP_Version[1];
80004992:	13 9a       	ld.ub	r10,r9[0x1]
80004994:	b0 9a       	st.b	r8[0x1],r10
	ptr->XCMPVersion[2] = XCMP_Version[2];
80004996:	13 aa       	ld.ub	r10,r9[0x2]
80004998:	b0 aa       	st.b	r8[0x2],r10
	ptr->XCMPVersion[3] = XCMP_Version[3];
8000499a:	13 b9       	ld.ub	r9,r9[0x3]
8000499c:	b0 b9       	st.b	r8[0x3],r9
	/*
	0x00:
	This is the message that the device sends at power up or after a reset. It 
	will give the initial status and capabilities for the device.
	*/
	ptr->DeviceInitType = 0x00;
8000499e:	30 09       	mov	r9,0
800049a0:	b0 c9       	st.b	r8[0x4],r9
	types of devices may provide a set of services to the radio system, but do 
	not have the ability to be the master.
	
	0x07:OptionBoard,3rd party Option Board-based application.
	*/
	ptr->DeviceStatusInfo.DeviceType = 0x07;
800049a2:	30 7a       	mov	r10,7
800049a4:	b0 da       	st.b	r8[0x5],r10
	
	/*Power Up Success, Device has powered up with no errors*/
	ptr->DeviceStatusInfo.DeviceStatus[0] = 0x00;
800049a6:	b0 e9       	st.b	r8[0x6],r9
	ptr->DeviceStatusInfo.DeviceStatus[1] = 0x00;
800049a8:	b0 f9       	st.b	r8[0x7],r9
	
	/*
	This number is the size of the Device Descriptor data structure with a 
	maximum size not exceeding 255 bytes.
	*/
	ptr->DeviceStatusInfo.DeviceDescriptorSize = 0x00;
800049aa:	f1 69 00 08 	st.b	r8[8],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme
800049ae:	30 9b       	mov	r11,9
800049b0:	fa cc ff fe 	sub	r12,sp,-2
800049b4:	f0 1f 00 03 	mcall	800049c0 <xcmp_DeviceInitializationStatus_request+0x44>
		, sizeof(DeviceInitializationStatus_brdcst_t) - MAX_DEVICE_DESC_SIZE);
}
800049b8:	2c dd       	sub	sp,-204
800049ba:	d8 02       	popm	pc
800049bc:	00 00       	add	r0,r0
800049be:	0e 14       	sub	r4,r7
800049c0:	80 00       	ld.sh	r0,r0[0x0]
800049c2:	48 a4       	lddpc	r4,800049e8 <xcmp_exec_func>

800049c4 <xcmp_opcode_not_supported>:
Description: register the app list
Calls: xcmp_tx
Called By:...
*/
void xcmp_opcode_not_supported( void )
{
800049c4:	d4 01       	pushm	lr
800049c6:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REPLY;
800049ca:	fe 78 80 00 	mov	r8,-32768
800049ce:	ba 18       	st.h	sp[0x2],r8
	
	/*The radio does not support this opcode.*/
	xcmp_farme.u8[0] = xcmp_Res_Opcode_Not_Supported;
800049d0:	30 38       	mov	r8,3
800049d2:	ba c8       	st.b	sp[0x4],r8
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, 1);
800049d4:	30 1b       	mov	r11,1
800049d6:	fa cc ff fe 	sub	r12,sp,-2
800049da:	f0 1f 00 03 	mcall	800049e4 <xcmp_opcode_not_supported+0x20>
}
800049de:	2c dd       	sub	sp,-204
800049e0:	d8 02       	popm	pc
800049e2:	00 00       	add	r0,r0
800049e4:	80 00       	ld.sh	r0,r0[0x0]
800049e6:	48 a4       	lddpc	r4,80004a0c <xcmp_exec_func+0x24>

800049e8 <xcmp_exec_func>:
Description: Perform XCMP corresponding functions
Calls:   
Called By: xcmp_rx_process--task
*/
static void xcmp_exec_func(app_exec_t * exec, xcmp_fragment_t * xcmp)
{
800049e8:	d4 01       	pushm	lr
	/*The message types*/
	switch(xcmp->xcmp_opcode & 0xF000)
800049ea:	96 88       	ld.uh	r8,r11[0x0]
800049ec:	e2 18 f0 00 	andl	r8,0xf000,COH
800049f0:	e0 48 80 00 	cp.w	r8,32768
800049f4:	c0 f0       	breq	80004a12 <xcmp_exec_func+0x2a>
800049f6:	e0 48 b0 00 	cp.w	r8,45056
800049fa:	c1 20       	breq	80004a1e <xcmp_exec_func+0x36>
800049fc:	58 08       	cp.w	r8,0
800049fe:	c1 51       	brne	80004a28 <xcmp_exec_func+0x40>
	{
		case XCMP_REQUEST:
			if(NULL != exec->xcmp_rx_req)
80004a00:	78 08       	ld.w	r8,r12[0x0]
80004a02:	58 08       	cp.w	r8,0
80004a04:	c0 40       	breq	80004a0c <xcmp_exec_func+0x24>
			{
				exec->xcmp_rx_req(xcmp);
80004a06:	16 9c       	mov	r12,r11
80004a08:	5d 18       	icall	r8
80004a0a:	d8 02       	popm	pc
			}
			else 
			{
				/*No function to register the request message*/
				/*send not supported opcode to raido */
				xcmp_opcode_not_supported();
80004a0c:	f0 1f 00 08 	mcall	80004a2c <xcmp_exec_func+0x44>
80004a10:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_REPLY:		
			if(NULL != exec->xcmp_rx_reply)
80004a12:	78 18       	ld.w	r8,r12[0x4]
80004a14:	58 08       	cp.w	r8,0
80004a16:	c0 90       	breq	80004a28 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_reply(xcmp);
80004a18:	16 9c       	mov	r12,r11
80004a1a:	5d 18       	icall	r8
80004a1c:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_BRDCAST:	
			if(NULL != exec->xcmp_rx_brdcst)
80004a1e:	78 28       	ld.w	r8,r12[0x8]
80004a20:	58 08       	cp.w	r8,0
80004a22:	c0 30       	breq	80004a28 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_brdcst(xcmp);
80004a24:	16 9c       	mov	r12,r11
80004a26:	5d 18       	icall	r8
80004a28:	d8 02       	popm	pc
80004a2a:	00 00       	add	r0,r0
80004a2c:	80 00       	ld.sh	r0,r0[0x0]
80004a2e:	49 c4       	lddpc	r4,80004a9c <xcmp_init+0xc>

80004a30 <xcmp_IdleTestTone>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_IdleTestTone(U8 type, U16 toneID)
{
80004a30:	d4 01       	pushm	lr
80004a32:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | TONE_CONTROL;
80004a36:	e0 68 04 09 	mov	r8,1033
80004a3a:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	ToneControl_req_t * ptr = (ToneControl_req_t *)xcmp_farme.u8;
80004a3c:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*Starts the specific tone*/	
	ptr->Function = type;
80004a40:	b0 8c       	st.b	r8[0x0],r12
	
	/*This tone shall be sounded when radio landed on a priority channel*/
	//ptr->ToneIdentifier[0] = (Priority_Beep >> 8) & 0xFF;
	//ptr->ToneIdentifier[1] = Priority_Beep & 0xFF;
	
	ptr->ToneIdentifier[0] = (toneID >> 8) & 0xFF;
80004a42:	f3 db c1 08 	bfextu	r9,r11,0x8,0x8
80004a46:	b0 99       	st.b	r8[0x1],r9
	ptr->ToneIdentifier[1] = toneID & 0xFF;	
80004a48:	b0 ab       	st.b	r8[0x2],r11
	
	/*
	The alert tone is played according to any rules for alert tones, given the 
	current volume setting. Settings for this field are 8 to 255 (0x08 ?0xFF).
	*/
	ptr->ToneVolumeControl = Current_Volume;
80004a4a:	30 09       	mov	r9,0
80004a4c:	b0 b9       	st.b	r8[0x3],r9
	
	/*clear reserved*/
	memset(ptr->Reserved, 0, 8);
80004a4e:	fb 69 00 08 	st.b	sp[8],r9
80004a52:	fa c8 ff f7 	sub	r8,sp,-9
80004a56:	b0 89       	st.b	r8[0x0],r9
80004a58:	fa c8 ff f6 	sub	r8,sp,-10
80004a5c:	b0 89       	st.b	r8[0x0],r9
80004a5e:	fa c8 ff f5 	sub	r8,sp,-11
80004a62:	b0 89       	st.b	r8[0x0],r9
80004a64:	fa c8 ff f4 	sub	r8,sp,-12
80004a68:	b0 89       	st.b	r8[0x0],r9
80004a6a:	fa c8 ff f3 	sub	r8,sp,-13
80004a6e:	b0 89       	st.b	r8[0x0],r9
80004a70:	fa c8 ff f2 	sub	r8,sp,-14
80004a74:	b0 89       	st.b	r8[0x0],r9
80004a76:	fa c8 ff f1 	sub	r8,sp,-15
80004a7a:	b0 89       	st.b	r8[0x0],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(ToneControl_req_t));
80004a7c:	30 cb       	mov	r11,12
80004a7e:	fa cc ff fe 	sub	r12,sp,-2
80004a82:	f0 1f 00 03 	mcall	80004a8c <xcmp_IdleTestTone+0x5c>
}
80004a86:	2c dd       	sub	sp,-204
80004a88:	d8 02       	popm	pc
80004a8a:	00 00       	add	r0,r0
80004a8c:	80 00       	ld.sh	r0,r0[0x0]
80004a8e:	48 a4       	lddpc	r4,80004ab4 <xcmp_init+0x24>

80004a90 <xcmp_init>:
	xQueueCreate -- freertos
	xTaskCreate -- freertos
Called By: main -- main.c
*/
void xcmp_init(void)
{
80004a90:	d4 01       	pushm	lr
	/*register the xcmp function(callback function)*/
	xnl_register_xcmp_func( xcmp_rx );
80004a92:	48 dc       	lddpc	r12,80004ac4 <xcmp_init+0x34>
80004a94:	f0 1f 00 0d 	mcall	80004ac8 <xcmp_init+0x38>
	
	/*initialize the queue*/
	xcmp_frame_rx = xQueueCreate(20, sizeof(xcmp_fragment_t *));
80004a98:	30 4b       	mov	r11,4
80004a9a:	31 4c       	mov	r12,20
80004a9c:	f0 1f 00 0c 	mcall	80004acc <xcmp_init+0x3c>
80004aa0:	48 c8       	lddpc	r8,80004ad0 <xcmp_init+0x40>
80004aa2:	91 0c       	st.w	r8[0x0],r12
	/*create task*/	
	/*this task is used to execute xcmp message*/
	xTaskCreate(
80004aa4:	30 09       	mov	r9,0
80004aa6:	1a d9       	st.w	--sp,r9
80004aa8:	1a d9       	st.w	--sp,r9
80004aaa:	1a d9       	st.w	--sp,r9
80004aac:	30 38       	mov	r8,3
80004aae:	e0 6a 04 00 	mov	r10,1024
80004ab2:	48 9b       	lddpc	r11,80004ad4 <xcmp_init+0x44>
80004ab4:	48 9c       	lddpc	r12,80004ad8 <xcmp_init+0x48>
80004ab6:	f0 1f 00 0a 	mcall	80004adc <xcmp_init+0x4c>
	,  tskXCMP_PRIORITY
	,  NULL
	);
	
	/*initialize the xnl*/
	xnl_init();
80004aba:	f0 1f 00 0a 	mcall	80004ae0 <xcmp_init+0x50>
80004abe:	2f dd       	sub	sp,-12
	
}
80004ac0:	d8 02       	popm	pc
80004ac2:	00 00       	add	r0,r0
80004ac4:	80 00       	ld.sh	r0,r0[0x0]
80004ac6:	4b e0       	lddpc	r0,80004bbc <xcmp_rx_process+0xd8>
80004ac8:	80 00       	ld.sh	r0,r0[0x0]
80004aca:	4c 2c       	lddpc	r12,80004bd0 <xcmp_rx_process+0xec>
80004acc:	80 00       	ld.sh	r0,r0[0x0]
80004ace:	73 0c       	ld.w	r12,r9[0x40]
80004ad0:	00 00       	add	r0,r0
80004ad2:	0b 2c       	ld.uh	r12,r5++
80004ad4:	80 00       	ld.sh	r0,r0[0x0]
80004ad6:	e7 ec 80 00 	sthh.w	r0[r0],r3:b,r12:b
80004ada:	4a e4       	lddpc	r4,80004b90 <xcmp_rx_process+0xac>
80004adc:	80 00       	ld.sh	r0,r0[0x0]
80004ade:	7a 28       	ld.w	r8,sp[0x8]
80004ae0:	80 00       	ld.sh	r0,r0[0x0]
80004ae2:	4c 64       	lddpc	r4,80004bf8 <xcmp_rx+0x18>

80004ae4 <xcmp_rx_process>:
Calls: xQueueReceive -- freerots
	xcmp_exec_func
Called By: task
*/
static void xcmp_rx_process(void * pvParameters)
{
80004ae4:	d4 31       	pushm	r0-r7,lr
80004ae6:	20 1d       	sub	sp,4
	xcmp_fragment_t * ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
80004ae8:	4b 16       	lddpc	r6,80004bac <xcmp_rx_process+0xc8>
80004aea:	30 05       	mov	r5,0
80004aec:	31 44       	mov	r4,20
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
80004aee:	4b 13       	lddpc	r3,80004bb0 <xcmp_rx_process+0xcc>
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
					break;
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
80004af0:	4b 12       	lddpc	r2,80004bb4 <xcmp_rx_process+0xd0>
						, ptr);
					break;
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
80004af2:	4b 21       	lddpc	r1,80004bb8 <xcmp_rx_process+0xd4>
					break;
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
80004af4:	4b 20       	lddpc	r0,80004bbc <xcmp_rx_process+0xd8>
	xcmp_fragment_t * ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
80004af6:	6c 0c       	ld.w	r12,r6[0x0]
80004af8:	0a 99       	mov	r9,r5
80004afa:	08 9a       	mov	r10,r4
80004afc:	1a 9b       	mov	r11,sp
80004afe:	f0 1f 00 31 	mcall	80004bc0 <xcmp_rx_process+0xdc>
80004b02:	58 1c       	cp.w	r12,1
80004b04:	cf 91       	brne	80004af6 <xcmp_rx_process+0x12>
		{									
			if(NULL == ptr)
80004b06:	40 0b       	lddsp	r11,sp[0x0]
80004b08:	58 0b       	cp.w	r11,0
80004b0a:	cf 60       	breq	80004af6 <xcmp_rx_process+0x12>
			
			//log("\n\r R_xcmp : %4x \n\r",ptr->xcmp_opcode);//log:R_xcmp指令	
			//static  portTickType water_value;
			//water_value = uxTaskGetStackHighWaterMark(NULL);
			//log("water_value: %d\n", water_value);			
			switch(ptr->xcmp_opcode & 0x0FFF)
80004b0c:	96 0a       	ld.sh	r10,r11[0x0]
80004b0e:	f3 da c0 10 	bfextu	r9,r10,0x0,0x10
80004b12:	f1 d9 c0 0c 	bfextu	r8,r9,0x0,0xc
80004b16:	59 c8       	cp.w	r8,28
80004b18:	c1 e0       	breq	80004b54 <xcmp_rx_process+0x70>
80004b1a:	e0 89 00 07 	brgt	80004b28 <xcmp_rx_process+0x44>
80004b1e:	58 e8       	cp.w	r8,14
80004b20:	c0 e0       	breq	80004b3c <xcmp_rx_process+0x58>
80004b22:	58 f8       	cp.w	r8,15
80004b24:	c2 41       	brne	80004b6c <xcmp_rx_process+0x88>
80004b26:	c0 f8       	rjmp	80004b44 <xcmp_rx_process+0x60>
80004b28:	e0 48 01 09 	cp.w	r8,265
80004b2c:	c1 80       	breq	80004b5c <xcmp_rx_process+0x78>
80004b2e:	e0 48 01 0a 	cp.w	r8,266
80004b32:	c1 90       	breq	80004b64 <xcmp_rx_process+0x80>
80004b34:	e0 48 00 2c 	cp.w	r8,44
80004b38:	c1 a1       	brne	80004b6c <xcmp_rx_process+0x88>
80004b3a:	c0 98       	rjmp	80004b4c <xcmp_rx_process+0x68>
			{
				case RADIO_STATUS:				
					xcmp_exec_func(&radio_status, ptr);
80004b3c:	4a 2c       	lddpc	r12,80004bc4 <xcmp_rx_process+0xe0>
80004b3e:	f0 1f 00 23 	mcall	80004bc8 <xcmp_rx_process+0xe4>
					break;
80004b42:	c2 f8       	rjmp	80004ba0 <xcmp_rx_process+0xbc>
					
				case VERSION_INFORMATION:
					xcmp_exec_func(&version_information, ptr);
80004b44:	4a 2c       	lddpc	r12,80004bcc <xcmp_rx_process+0xe8>
80004b46:	f0 1f 00 21 	mcall	80004bc8 <xcmp_rx_process+0xe4>
					break;
80004b4a:	c2 b8       	rjmp	80004ba0 <xcmp_rx_process+0xbc>
					
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
80004b4c:	4a 1c       	lddpc	r12,80004bd0 <xcmp_rx_process+0xec>
80004b4e:	f0 1f 00 1f 	mcall	80004bc8 <xcmp_rx_process+0xe4>
					break;
80004b52:	c2 78       	rjmp	80004ba0 <xcmp_rx_process+0xbc>
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
80004b54:	04 9c       	mov	r12,r2
80004b56:	f0 1f 00 1d 	mcall	80004bc8 <xcmp_rx_process+0xe4>
						, ptr);
					break;
80004b5a:	c2 38       	rjmp	80004ba0 <xcmp_rx_process+0xbc>
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
80004b5c:	02 9c       	mov	r12,r1
80004b5e:	f0 1f 00 1b 	mcall	80004bc8 <xcmp_rx_process+0xe4>
					break;
80004b62:	c1 f8       	rjmp	80004ba0 <xcmp_rx_process+0xbc>
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
80004b64:	00 9c       	mov	r12,r0
80004b66:	f0 1f 00 19 	mcall	80004bc8 <xcmp_rx_process+0xe4>
					break;
80004b6a:	c1 b8       	rjmp	80004ba0 <xcmp_rx_process+0xbc>
					
				default:
				
					/*the xcmp message not in order list*/
					/*over the length of the list*/
					if((0x0400 != (ptr->xcmp_opcode & 0x0400)) 
80004b6c:	12 98       	mov	r8,r9
80004b6e:	e2 18 04 00 	andl	r8,0x400,COH
80004b72:	c0 70       	breq	80004b80 <xcmp_rx_process+0x9c>
80004b74:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
80004b78:	e0 48 00 68 	cp.w	r8,104
80004b7c:	e0 8a 00 08 	brle	80004b8c <xcmp_rx_process+0xa8>
						|| (MAX_APP_FUNC <= (ptr->xcmp_opcode & 0x00FF))
					)
					{
						/*xcmp request*/
						if( XCMP_REQUEST == (ptr->xcmp_opcode & 0xF000))
80004b80:	e2 19 f0 00 	andl	r9,0xf000,COH
80004b84:	c0 e1       	brne	80004ba0 <xcmp_rx_process+0xbc>
						{
							/*send not supported opcode to raido */
							xcmp_opcode_not_supported();
80004b86:	f0 1f 00 14 	mcall	80004bd4 <xcmp_rx_process+0xf0>
80004b8a:	c0 b8       	rjmp	80004ba0 <xcmp_rx_process+0xbc>
						}
					}
					else
					{					
						xcmp_exec_func( &app_list[ptr->xcmp_opcode & 0x00FF]
80004b8c:	f9 da c0 08 	bfextu	r12,r10,0x0,0x8
80004b90:	f8 0c 00 1c 	add	r12,r12,r12<<0x1
80004b94:	49 19       	lddpc	r9,80004bd8 <xcmp_rx_process+0xf4>
80004b96:	72 08       	ld.w	r8,r9[0x0]
80004b98:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80004b9c:	f0 1f 00 0b 	mcall	80004bc8 <xcmp_rx_process+0xe4>
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
80004ba0:	66 0c       	ld.w	r12,r3[0x0]
80004ba2:	40 0b       	lddsp	r11,sp[0x0]
80004ba4:	f0 1f 00 0e 	mcall	80004bdc <xcmp_rx_process+0xf8>
80004ba8:	ca 7b       	rjmp	80004af6 <xcmp_rx_process+0x12>
80004baa:	00 00       	add	r0,r0
80004bac:	00 00       	add	r0,r0
80004bae:	0b 2c       	ld.uh	r12,r5++
80004bb0:	00 00       	add	r0,r0
80004bb2:	0a c4       	st.b	r5++,r4
80004bb4:	00 00       	add	r0,r0
80004bb6:	0b 3c       	ld.ub	r12,r5++
80004bb8:	00 00       	add	r0,r0
80004bba:	0b 30       	ld.ub	r0,r5++
80004bbc:	00 00       	add	r0,r0
80004bbe:	0b 20       	ld.uh	r0,r5++
80004bc0:	80 00       	ld.sh	r0,r0[0x0]
80004bc2:	6f a8       	ld.w	r8,r7[0x68]
80004bc4:	00 00       	add	r0,r0
80004bc6:	0b 54       	ld.sh	r4,--r5
80004bc8:	80 00       	ld.sh	r0,r0[0x0]
80004bca:	49 e8       	lddpc	r8,80004c40 <xnl_get_msg_ack_func+0x8>
80004bcc:	00 00       	add	r0,r0
80004bce:	0b 14       	ld.sh	r4,r5++
80004bd0:	00 00       	add	r0,r0
80004bd2:	0b 48       	ld.w	r8,--r5
80004bd4:	80 00       	ld.sh	r0,r0[0x0]
80004bd6:	49 c4       	lddpc	r4,80004c44 <xnl_get_msg_ack_func+0xc>
80004bd8:	00 00       	add	r0,r0
80004bda:	97 a0       	st.w	r11[0x28],r0
80004bdc:	80 00       	ld.sh	r0,r0[0x0]
80004bde:	35 c0       	mov	r0,92

80004be0 <xcmp_rx>:
Calls:   
	xQueueSend -- xnl.c
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
80004be0:	eb cd 40 90 	pushm	r4,r7,lr
80004be4:	20 1d       	sub	sp,4
80004be6:	fa c4 ff f0 	sub	r4,sp,-16
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
80004bea:	48 c8       	lddpc	r8,80004c18 <xcmp_rx+0x38>
80004bec:	70 0c       	ld.w	r12,r8[0x0]
80004bee:	f0 1f 00 0c 	mcall	80004c1c <xcmp_rx+0x3c>
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
80004bf2:	c1 00       	breq	80004c12 <xcmp_rx+0x32>
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
80004bf4:	fa c7 ff fc 	sub	r7,sp,-4
80004bf8:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
	{
		memcpy(xcmp_ptr, &xcmp, sizeof(xcmp_fragment_t));				
80004bfa:	e0 6a 00 ca 	mov	r10,202
80004bfe:	08 9b       	mov	r11,r4
80004c00:	f0 1f 00 08 	mcall	80004c20 <xcmp_rx+0x40>
		xQueueSend(xcmp_frame_rx, &xcmp_ptr, 0);	
80004c04:	48 88       	lddpc	r8,80004c24 <xcmp_rx+0x44>
80004c06:	70 0c       	ld.w	r12,r8[0x0]
80004c08:	30 09       	mov	r9,0
80004c0a:	12 9a       	mov	r10,r9
80004c0c:	1a 9b       	mov	r11,sp
80004c0e:	f0 1f 00 07 	mcall	80004c28 <xcmp_rx+0x48>
	}	
}
80004c12:	2f fd       	sub	sp,-4
80004c14:	e3 cd 80 90 	ldm	sp++,r4,r7,pc
80004c18:	00 00       	add	r0,r0
80004c1a:	0a c4       	st.b	r5++,r4
80004c1c:	80 00       	ld.sh	r0,r0[0x0]
80004c1e:	37 6c       	mov	r12,118
80004c20:	80 00       	ld.sh	r0,r0[0x0]
80004c22:	86 8e       	ld.uh	lr,r3[0x0]
80004c24:	00 00       	add	r0,r0
80004c26:	0b 2c       	ld.uh	r12,r5++
80004c28:	80 00       	ld.sh	r0,r0[0x0]
80004c2a:	71 b4       	ld.w	r4,r8[0x6c]

80004c2c <xnl_register_xcmp_func>:
Function: xnl_register_xcmp_func
Description: register the xcmp function(callback function)
*/
void xnl_register_xcmp_func( void ( *func)(xnl_content_data_msg_t))
{
	 xcmp_exec = func;
80004c2c:	48 28       	lddpc	r8,80004c34 <xnl_register_xcmp_func+0x8>
80004c2e:	91 0c       	st.w	r8[0x0],r12
}
80004c30:	5e fc       	retal	r12
80004c32:	00 00       	add	r0,r0
80004c34:	00 00       	add	r0,r0
80004c36:	0b 78       	ld.ub	r8,--r5

80004c38 <xnl_get_msg_ack_func>:
Description: process while receive msg ack.
Calls:xSemaphoreGive--freertos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
80004c38:	d4 01       	pushm	lr
	
	DestinationAddress = xnl->xnl_header.destination;
	/*No timeout*/		
	 //One relationship is controlled by a state machine, only the current MSG received the ACK, 
	//then the program will clear the current MSG sending address and out of standby and will jump to the sending state.
	if (DestinationAddress == xnl_information.device_address )
80004c3a:	48 88       	lddpc	r8,80004c58 <xnl_get_msg_ack_func+0x20>
80004c3c:	90 28       	ld.sh	r8,r8[0x4]
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
	U16 DestinationAddress;
	U16 TransactionID;
	
	DestinationAddress = xnl->xnl_header.destination;
80004c3e:	98 49       	ld.sh	r9,r12[0x8]
80004c40:	f0 09 19 00 	cp.h	r9,r8
80004c44:	c0 81       	brne	80004c54 <xnl_get_msg_ack_func+0x1c>
	if (DestinationAddress == xnl_information.device_address )
	{
		//The ack is for me.
		
		TransactionID = xnl->xnl_header.transaction_id;
		xSemaphoreGive(xnl_timeout_semphr);	
80004c46:	48 68       	lddpc	r8,80004c5c <xnl_get_msg_ack_func+0x24>
80004c48:	70 0c       	ld.w	r12,r8[0x0]
80004c4a:	30 09       	mov	r9,0
80004c4c:	12 9a       	mov	r10,r9
80004c4e:	12 9b       	mov	r11,r9
80004c50:	f0 1f 00 04 	mcall	80004c60 <xnl_get_msg_ack_func+0x28>
80004c54:	d8 02       	popm	pc
80004c56:	00 00       	add	r0,r0
80004c58:	00 00       	add	r0,r0
80004c5a:	0e 22       	rsub	r2,r7
80004c5c:	00 00       	add	r0,r0
80004c5e:	0b 60       	ld.uh	r0,--r5
80004c60:	80 00       	ld.sh	r0,r0[0x0]
80004c62:	71 b4       	ld.w	r4,r8[0x6c]

80004c64 <xnl_init>:
	xTaskCreate--freertos
	xnl_send_device_master_query
Called By:xcmp_init -- xcmp.c
*/
void xnl_init(void)
{
80004c64:	eb cd 40 e0 	pushm	r5-r7,lr
	
	xnl_information.is_connected = FALSE;
80004c68:	30 09       	mov	r9,0
80004c6a:	4b 78       	lddpc	r8,80004d44 <xnl_init+0xe0>
80004c6c:	b0 89       	st.b	r8[0x0],r9

	/*initialize the semaphore and queue*/
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
80004c6e:	30 0b       	mov	r11,0
80004c70:	30 1c       	mov	r12,1
80004c72:	f0 1f 00 36 	mcall	80004d48 <xnl_init+0xe4>
80004c76:	4b 68       	lddpc	r8,80004d4c <xnl_init+0xe8>
80004c78:	91 0c       	st.w	r8[0x0],r12
80004c7a:	70 08       	ld.w	r8,r8[0x0]
80004c7c:	58 08       	cp.w	r8,0
80004c7e:	c0 80       	breq	80004c8e <xnl_init+0x2a>
80004c80:	4b 38       	lddpc	r8,80004d4c <xnl_init+0xe8>
80004c82:	70 0c       	ld.w	r12,r8[0x0]
80004c84:	30 09       	mov	r9,0
80004c86:	12 9a       	mov	r10,r9
80004c88:	12 9b       	mov	r11,r9
80004c8a:	f0 1f 00 32 	mcall	80004d50 <xnl_init+0xec>
	
	xnl_frame_tx = xQueueCreate(60, sizeof(xnl_fragment_t *)); //扩大xnl_frame_tx的队列深度
80004c8e:	30 4b       	mov	r11,4
80004c90:	33 cc       	mov	r12,60
80004c92:	f0 1f 00 2e 	mcall	80004d48 <xnl_init+0xe4>
80004c96:	4b 08       	lddpc	r8,80004d54 <xnl_init+0xf0>
80004c98:	91 0c       	st.w	r8[0x0],r12
		
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
80004c9a:	30 4b       	mov	r11,4
80004c9c:	36 4c       	mov	r12,100
80004c9e:	f0 1f 00 2b 	mcall	80004d48 <xnl_init+0xe4>
80004ca2:	4a e8       	lddpc	r8,80004d58 <xnl_init+0xf4>
80004ca4:	91 0c       	st.w	r8[0x0],r12
80004ca6:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_XNL_STORE; i++ )
	{
		set_xnl_idle(&xnl_store[i]);
80004ca8:	10 96       	mov	r6,r8
80004caa:	4a d5       	lddpc	r5,80004d5c <xnl_init+0xf8>
80004cac:	6c 0c       	ld.w	r12,r6[0x0]
80004cae:	ea 07 00 0b 	add	r11,r5,r7
80004cb2:	f0 1f 00 2c 	mcall	80004d60 <xnl_init+0xfc>
80004cb6:	ee c7 ff 00 	sub	r7,r7,-256
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
	
	xnl_frame_tx = xQueueCreate(60, sizeof(xnl_fragment_t *)); //扩大xnl_frame_tx的队列深度
		
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
	for(int i= 0; i < MAX_XNL_STORE; i++ )
80004cba:	e0 47 64 00 	cp.w	r7,25600
80004cbe:	cf 71       	brne	80004cac <xnl_init+0x48>
	{
		set_xnl_idle(&xnl_store[i]);
	}
	
	/*initialize the queue to send/receive xnl packet */
	phy_xnl_frame_tx = xQueueCreate(TX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
80004cc0:	30 4b       	mov	r11,4
80004cc2:	33 2c       	mov	r12,50
80004cc4:	f0 1f 00 21 	mcall	80004d48 <xnl_init+0xe4>
80004cc8:	4a 78       	lddpc	r8,80004d64 <xnl_init+0x100>
80004cca:	91 0c       	st.w	r8[0x0],r12
	phy_xnl_frame_rx = xQueueCreate(RX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
80004ccc:	30 4b       	mov	r11,4
80004cce:	32 8c       	mov	r12,40
80004cd0:	f0 1f 00 1e 	mcall	80004d48 <xnl_init+0xe4>
80004cd4:	4a 58       	lddpc	r8,80004d68 <xnl_init+0x104>
80004cd6:	91 0c       	st.w	r8[0x0],r12
	
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
80004cd8:	30 4b       	mov	r11,4
80004cda:	30 ac       	mov	r12,10
80004cdc:	f0 1f 00 1b 	mcall	80004d48 <xnl_init+0xe4>
80004ce0:	4a 38       	lddpc	r8,80004d6c <xnl_init+0x108>
80004ce2:	91 0c       	st.w	r8[0x0],r12
80004ce4:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
	{
		set_payload_idle(payload_store[i]);
80004ce6:	10 96       	mov	r6,r8
80004ce8:	4a 25       	lddpc	r5,80004d70 <xnl_init+0x10c>
80004cea:	6c 0c       	ld.w	r12,r6[0x0]
80004cec:	ea 07 00 0b 	add	r11,r5,r7
80004cf0:	f0 1f 00 1c 	mcall	80004d60 <xnl_init+0xfc>
80004cf4:	ee c7 fe 00 	sub	r7,r7,-512
	
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
80004cf8:	e0 47 14 00 	cp.w	r7,5120
80004cfc:	cf 71       	brne	80004cea <xnl_init+0x86>
	
	/*initialize the queue to send/receive payload packet */
	//phy_payload_frame_tx =
	//xQueueCreate(TX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t));
	
	phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
80004cfe:	30 4b       	mov	r11,4
80004d00:	30 5c       	mov	r12,5
80004d02:	f0 1f 00 12 	mcall	80004d48 <xnl_init+0xe4>
80004d06:	49 c8       	lddpc	r8,80004d74 <xnl_init+0x110>
80004d08:	91 0c       	st.w	r8[0x0],r12
	
	#endif /*end if*/
		
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
80004d0a:	30 07       	mov	r7,0
80004d0c:	1a d7       	st.w	--sp,r7
80004d0e:	1a d7       	st.w	--sp,r7
80004d10:	1a d7       	st.w	--sp,r7
80004d12:	30 38       	mov	r8,3
80004d14:	0e 99       	mov	r9,r7
80004d16:	e0 6a 00 dc 	mov	r10,220
80004d1a:	49 8b       	lddpc	r11,80004d78 <xnl_init+0x114>
80004d1c:	49 8c       	lddpc	r12,80004d7c <xnl_init+0x118>
80004d1e:	f0 1f 00 19 	mcall	80004d80 <xnl_init+0x11c>
	,  tskXNL_PRIORITY //+ 1
	,  NULL
	);
	
	/*this task is used to send xnl message*/
	xTaskCreate(
80004d22:	1a d7       	st.w	--sp,r7
80004d24:	1a d7       	st.w	--sp,r7
80004d26:	1a d7       	st.w	--sp,r7
80004d28:	30 38       	mov	r8,3
80004d2a:	0e 99       	mov	r9,r7
80004d2c:	e0 6a 00 82 	mov	r10,130
80004d30:	49 5b       	lddpc	r11,80004d84 <xnl_init+0x120>
80004d32:	49 6c       	lddpc	r12,80004d88 <xnl_init+0x124>
80004d34:	f0 1f 00 13 	mcall	80004d80 <xnl_init+0x11c>
	,  tskXNL_PRIORITY//+1
	,  NULL
	);
	
	/*initialize the physical layer*/
	phy_init();
80004d38:	f0 1f 00 15 	mcall	80004d8c <xnl_init+0x128>
80004d3c:	2f ad       	sub	sp,-24
}
80004d3e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80004d42:	00 00       	add	r0,r0
80004d44:	00 00       	add	r0,r0
80004d46:	0e 22       	rsub	r2,r7
80004d48:	80 00       	ld.sh	r0,r0[0x0]
80004d4a:	73 0c       	ld.w	r12,r9[0x40]
80004d4c:	00 00       	add	r0,r0
80004d4e:	0b 60       	ld.uh	r0,--r5
80004d50:	80 00       	ld.sh	r0,r0[0x0]
80004d52:	71 b4       	ld.w	r4,r8[0x6c]
80004d54:	00 00       	add	r0,r0
80004d56:	0b 6c       	ld.uh	r12,--r5
80004d58:	00 00       	add	r0,r0
80004d5a:	0a c4       	st.b	r5++,r4
80004d5c:	00 00       	add	r0,r0
80004d5e:	33 52       	mov	r2,53
80004d60:	80 00       	ld.sh	r0,r0[0x0]
80004d62:	35 c0       	mov	r0,92
80004d64:	00 00       	add	r0,r0
80004d66:	0a f4       	st.b	--r5,r4
80004d68:	00 00       	add	r0,r0
80004d6a:	0a d4       	st.w	--r5,r4
80004d6c:	00 00       	add	r0,r0
80004d6e:	0a c8       	st.b	r5++,r8
80004d70:	00 00       	add	r0,r0
80004d72:	1f 52       	ld.sh	r2,--pc
80004d74:	00 00       	add	r0,r0
80004d76:	0b 00       	ld.w	r0,r5++
80004d78:	80 00       	ld.sh	r0,r0[0x0]
80004d7a:	e7 f4 80 00 	ld.wls	r4,r3[0x0]
80004d7e:	4d 90       	lddpc	r0,80004ee0 <xnl_tx+0x24>
80004d80:	80 00       	ld.sh	r0,r0[0x0]
80004d82:	7a 28       	ld.w	r8,sp[0x8]
80004d84:	80 00       	ld.sh	r0,r0[0x0]
80004d86:	e7 fc 80 00 	ld.wls	r12,r3[0x0]
80004d8a:	4d f0       	lddpc	r0,80004f04 <xnl_tx+0x48>
80004d8c:	80 00       	ld.sh	r0,r0[0x0]
80004d8e:	37 94       	mov	r4,121

80004d90 <xnl_rx_process>:
Calls: 
Called By:task
*/
//portTickType water_value =0;
static void xnl_rx_process(void * pvParameters)
{
80004d90:	eb cd 40 fe 	pushm	r1-r7,lr
80004d94:	20 1d       	sub	sp,4
	xnl_fragment_t * xnl_ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
80004d96:	49 26       	lddpc	r6,80004ddc <xnl_rx_process+0x4c>
80004d98:	30 05       	mov	r5,0
80004d9a:	3f f4       	mov	r4,-1
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
80004d9c:	30 c3       	mov	r3,12
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
80004d9e:	49 11       	lddpc	r1,80004de0 <xnl_rx_process+0x50>
	if(xnl->xnl_header.opcode > 0x0C)	
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
80004da0:	49 12       	lddpc	r2,80004de4 <xnl_rx_process+0x54>
	xnl_fragment_t * xnl_ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
80004da2:	6c 0c       	ld.w	r12,r6[0x0]
80004da4:	0a 99       	mov	r9,r5
80004da6:	08 9a       	mov	r10,r4
80004da8:	1a 9b       	mov	r11,sp
80004daa:	f0 1f 00 10 	mcall	80004de8 <xnl_rx_process+0x58>
80004dae:	58 1c       	cp.w	r12,1
80004db0:	cf 91       	brne	80004da2 <xnl_rx_process+0x12>
		, portMAX_DELAY ))
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
80004db2:	40 0c       	lddsp	r12,sp[0x0]
80004db4:	58 0c       	cp.w	r12,0
80004db6:	cf 60       	breq	80004da2 <xnl_rx_process+0x12>
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
80004db8:	98 28       	ld.sh	r8,r12[0x4]
80004dba:	e6 08 19 00 	cp.h	r8,r3
80004dbe:	e0 8b 00 0a 	brhi	80004dd2 <xnl_rx_process+0x42>
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
80004dc2:	5c 78       	castu.h	r8
80004dc4:	e4 08 03 29 	ld.w	r9,r2[r8<<0x2]
80004dc8:	58 09       	cp.w	r9,0
80004dca:	c0 40       	breq	80004dd2 <xnl_rx_process+0x42>
	{
		//log("\n\r R_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:R_xnl指令
		/*execute the function in list*/
		xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec(xnl);
80004dcc:	e4 08 03 28 	ld.w	r8,r2[r8<<0x2]
80004dd0:	5d 18       	icall	r8
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
80004dd2:	62 0c       	ld.w	r12,r1[0x0]
80004dd4:	40 0b       	lddsp	r11,sp[0x0]
80004dd6:	f0 1f 00 06 	mcall	80004dec <xnl_rx_process+0x5c>
80004dda:	ce 4b       	rjmp	80004da2 <xnl_rx_process+0x12>
80004ddc:	00 00       	add	r0,r0
80004dde:	0a d4       	st.w	--r5,r4
80004de0:	00 00       	add	r0,r0
80004de2:	0a c4       	st.b	r5++,r4
80004de4:	00 00       	add	r0,r0
80004de6:	05 00       	ld.w	r0,r2++
80004de8:	80 00       	ld.sh	r0,r0[0x0]
80004dea:	6f a8       	ld.w	r8,r7[0x68]
80004dec:	80 00       	ld.sh	r0,r0[0x0]
80004dee:	35 c0       	mov	r0,92

80004df0 <xnl_tx_process>:
	phy_tx -- physical.c
Called By: task
*/
//portTickType tx_water_value =0;
static void xnl_tx_process(void * pvParameters)
{
80004df0:	d4 31       	pushm	r0-r7,lr
	
	
	for(;;)
	{		
		//tx_water_value = uxTaskGetStackHighWaterMark(NULL);
		switch(xnl_tx_state)
80004df2:	4a a6       	lddpc	r6,80004e98 <xnl_tx_process+0xa8>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
80004df4:	4a a2       	lddpc	r2,80004e9c <xnl_tx_process+0xac>
80004df6:	4a b4       	lddpc	r4,80004ea0 <xnl_tx_process+0xb0>
80004df8:	30 07       	mov	r7,0
80004dfa:	3f f1       	mov	r1,-1
					if(NULL == ptr)
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
80004dfc:	30 00       	mov	r0,0
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;				
80004dfe:	4a a5       	lddpc	r5,80004ea4 <xnl_tx_process+0xb4>
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
80004e00:	4a a3       	lddpc	r3,80004ea8 <xnl_tx_process+0xb8>
	
	
	for(;;)
	{		
		//tx_water_value = uxTaskGetStackHighWaterMark(NULL);
		switch(xnl_tx_state)
80004e02:	6c 08       	ld.w	r8,r6[0x0]
80004e04:	58 08       	cp.w	r8,0
80004e06:	c0 40       	breq	80004e0e <xnl_tx_process+0x1e>
80004e08:	58 18       	cp.w	r8,1
80004e0a:	cf d1       	brne	80004e04 <xnl_tx_process+0x14>
80004e0c:	c2 48       	rjmp	80004e54 <xnl_tx_process+0x64>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
80004e0e:	64 0c       	ld.w	r12,r2[0x0]
80004e10:	0e 99       	mov	r9,r7
80004e12:	02 9a       	mov	r10,r1
80004e14:	08 9b       	mov	r11,r4
80004e16:	f0 1f 00 26 	mcall	80004eac <xnl_tx_process+0xbc>
80004e1a:	58 1c       	cp.w	r12,1
80004e1c:	cf 31       	brne	80004e02 <xnl_tx_process+0x12>
					, portMAX_DELAY ))
				{				
					if(NULL == ptr)
80004e1e:	68 0b       	ld.w	r11,r4[0x0]
80004e20:	58 0b       	cp.w	r11,0
80004e22:	cf 00       	breq	80004e02 <xnl_tx_process+0x12>
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
80004e24:	96 28       	ld.sh	r8,r11[0x4]
80004e26:	e0 08 19 00 	cp.h	r8,r0
80004e2a:	c0 71       	brne	80004e38 <xnl_tx_process+0x48>
					{
						/*invalid XNL opcode*/
						set_xnl_idle(ptr);
80004e2c:	4a 18       	lddpc	r8,80004eb0 <xnl_tx_process+0xc0>
80004e2e:	70 08       	ld.w	r8,r8[0x0]
80004e30:	10 9c       	mov	r12,r8
80004e32:	f0 1f 00 21 	mcall	80004eb4 <xnl_tx_process+0xc4>
						break;
80004e36:	ce 6b       	rjmp	80004e02 <xnl_tx_process+0x12>
					}
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
80004e38:	16 9c       	mov	r12,r11
80004e3a:	f0 1f 00 20 	mcall	80004eb8 <xnl_tx_process+0xc8>
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;				
80004e3e:	30 18       	mov	r8,1
80004e40:	8b 08       	st.w	r5[0x0],r8
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
80004e42:	66 0c       	ld.w	r12,r3[0x0]
80004e44:	0e 99       	mov	r9,r7
80004e46:	0e 9a       	mov	r10,r7
80004e48:	0e 9b       	mov	r11,r7
80004e4a:	f0 1f 00 19 	mcall	80004eac <xnl_tx_process+0xbc>
					xnl_tx_state = WAITING_FOR_REPLY;
80004e4e:	30 18       	mov	r8,1
80004e50:	8d 08       	st.w	r6[0x0],r8
80004e52:	cd 8b       	rjmp	80004e02 <xnl_tx_process+0x12>
				}
				break;
			
			/*wait XNL reply*/			
			case WAITING_FOR_REPLY://直到回答ACK才再发送下一条data/control
				if(pdTRUE == xSemaphoreTake( xnl_timeout_semphr
80004e54:	66 0c       	ld.w	r12,r3[0x0]
80004e56:	0e 99       	mov	r9,r7
80004e58:	36 4a       	mov	r10,100
80004e5a:	0e 9b       	mov	r11,r7
80004e5c:	f0 1f 00 14 	mcall	80004eac <xnl_tx_process+0xbc>
80004e60:	58 1c       	cp.w	r12,1
80004e62:	c0 81       	brne	80004e72 <xnl_tx_process+0x82>
					, ( portTickType )50*2/ portTICK_RATE_MS))//按ADK文档中提示500ms一次超时,但是实际情况下程序中启用freertos的任务延时不够精准。因此根据经验需要降低延时等待的时间
				{
					/*No timeout*/
					set_xnl_idle(ptr);			
80004e64:	49 38       	lddpc	r8,80004eb0 <xnl_tx_process+0xc0>
80004e66:	70 0c       	ld.w	r12,r8[0x0]
80004e68:	68 0b       	ld.w	r11,r4[0x0]
80004e6a:	f0 1f 00 13 	mcall	80004eb4 <xnl_tx_process+0xc4>
					xnl_tx_state = WAITING_FOR_TX;
80004e6e:	8d 07       	st.w	r6[0x0],r7
80004e70:	cc 9b       	rjmp	80004e02 <xnl_tx_process+0x12>
				}
				else
				{
					/*time out*/
					if(xnl_send_times <= MIN_RESEND_TIMES)
80004e72:	6a 08       	ld.w	r8,r5[0x0]
80004e74:	58 38       	cp.w	r8,3
80004e76:	e0 89 00 09 	brgt	80004e88 <xnl_tx_process+0x98>
					{
						/*If times smaller than A supermarket, then resend the 
						instructions*/
						phy_tx((phy_fragment_t *)ptr);
80004e7a:	68 0c       	ld.w	r12,r4[0x0]
80004e7c:	f0 1f 00 0f 	mcall	80004eb8 <xnl_tx_process+0xc8>
						xnl_send_times++;
80004e80:	6a 08       	ld.w	r8,r5[0x0]
80004e82:	2f f8       	sub	r8,-1
80004e84:	8b 08       	st.w	r5[0x0],r8
80004e86:	cb eb       	rjmp	80004e02 <xnl_tx_process+0x12>
					}
					else
					{
						//can not send data, disconnected						
						//vPortFree(ptr);	
						set_xnl_idle(ptr);									
80004e88:	48 a8       	lddpc	r8,80004eb0 <xnl_tx_process+0xc0>
80004e8a:	70 0c       	ld.w	r12,r8[0x0]
80004e8c:	68 0b       	ld.w	r11,r4[0x0]
80004e8e:	f0 1f 00 0a 	mcall	80004eb4 <xnl_tx_process+0xc4>
						xnl_tx_state = WAITING_FOR_TX;
80004e92:	8d 07       	st.w	r6[0x0],r7
80004e94:	cb 7b       	rjmp	80004e02 <xnl_tx_process+0x12>
80004e96:	00 00       	add	r0,r0
80004e98:	00 00       	add	r0,r0
80004e9a:	0b 68       	ld.uh	r8,--r5
80004e9c:	00 00       	add	r0,r0
80004e9e:	0b 6c       	ld.uh	r12,--r5
80004ea0:	00 00       	add	r0,r0
80004ea2:	0b 74       	ld.ub	r4,--r5
80004ea4:	00 00       	add	r0,r0
80004ea6:	0b 70       	ld.ub	r0,--r5
80004ea8:	00 00       	add	r0,r0
80004eaa:	0b 60       	ld.uh	r0,--r5
80004eac:	80 00       	ld.sh	r0,r0[0x0]
80004eae:	6f a8       	ld.w	r8,r7[0x68]
80004eb0:	00 00       	add	r0,r0
80004eb2:	0a c4       	st.b	r5++,r4
80004eb4:	80 00       	ld.sh	r0,r0[0x0]
80004eb6:	35 c0       	mov	r0,92
80004eb8:	80 00       	ld.sh	r0,r0[0x0]
80004eba:	35 e0       	mov	r0,94

80004ebc <xnl_tx>:
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
{
80004ebc:	eb cd 40 c0 	pushm	r6-r7,lr
80004ec0:	20 1d       	sub	sp,4
80004ec2:	18 96       	mov	r6,r12
	message that is sent. The same value should be used for all retries.
	*/
	static U8 flags = 0;
	
	/*If the value is DEFAULT_VALUE, the value will be modified*/
	if(DEFAULT_VALUE == xnl->xnl_header.flags)
80004ec4:	98 39       	ld.sh	r9,r12[0x6]
80004ec6:	3f f8       	mov	r8,-1
80004ec8:	f0 09 19 00 	cp.h	r9,r8
80004ecc:	c0 a1       	brne	80004ee0 <xnl_tx+0x24>
	{
		xnl->xnl_header.flags =  0x0100 | ((++flags) & 0x07);
80004ece:	4a e9       	lddpc	r9,80004f84 <xnl_tx+0xc8>
80004ed0:	13 88       	ld.ub	r8,r9[0x0]
80004ed2:	2f f8       	sub	r8,-1
80004ed4:	5c 58       	castu.b	r8
80004ed6:	b2 88       	st.b	r9[0x0],r8
80004ed8:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
80004edc:	a9 a8       	sbr	r8,0x8
80004ede:	b8 38       	st.h	r12[0x6],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.destination)
80004ee0:	8c 49       	ld.sh	r9,r6[0x8]
80004ee2:	3f f8       	mov	r8,-1
80004ee4:	f0 09 19 00 	cp.h	r9,r8
80004ee8:	c0 41       	brne	80004ef0 <xnl_tx+0x34>
	{		
		/*Use actual Master address.*/
		xnl->xnl_header.destination = xnl_information.master_address;
80004eea:	4a 88       	lddpc	r8,80004f88 <xnl_tx+0xcc>
80004eec:	90 18       	ld.sh	r8,r8[0x2]
80004eee:	ac 48       	st.h	r6[0x8],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.source)
80004ef0:	8c 59       	ld.sh	r9,r6[0xa]
80004ef2:	3f f8       	mov	r8,-1
80004ef4:	f0 09 19 00 	cp.h	r9,r8
80004ef8:	c0 41       	brne	80004f00 <xnl_tx+0x44>
	{
		/*Use Temporary address.*/	
		xnl->xnl_header.source = xnl_information.device_address;
80004efa:	4a 48       	lddpc	r8,80004f88 <xnl_tx+0xcc>
80004efc:	90 28       	ld.sh	r8,r8[0x4]
80004efe:	ac 58       	st.h	r6[0xa],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
80004f00:	8c 69       	ld.sh	r9,r6[0xc]
80004f02:	3f f8       	mov	r8,-1
80004f04:	f0 09 19 00 	cp.h	r9,r8
80004f08:	c0 e1       	brne	80004f24 <xnl_tx+0x68>
	{		
		xnl->xnl_header.transaction_id = 
		  ((++xnl_information.transaction_id) & 0xFF) 
80004f0a:	4a 08       	lddpc	r8,80004f88 <xnl_tx+0xcc>
80004f0c:	90 49       	ld.sh	r9,r8[0x8]
80004f0e:	2f f9       	sub	r9,-1
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
80004f10:	b0 49       	st.h	r8[0x8],r9
		  ((++xnl_information.transaction_id) & 0xFF) 
80004f12:	90 4a       	ld.sh	r10,r8[0x8]
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
80004f14:	90 49       	ld.sh	r9,r8[0x8]
80004f16:	e0 19 ff 00 	andl	r9,0xff00
80004f1a:	f1 da c0 08 	bfextu	r8,r10,0x0,0x8
80004f1e:	f3 e8 10 08 	or	r8,r9,r8
80004f22:	ac 68       	st.h	r6[0xc],r8
	U16  sumScratch;
	U32  indextohWord;
	S32  hWordswithinFrag;
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
80004f24:	0d 98       	ld.ub	r8,r6[0x1]
80004f26:	20 28       	sub	r8,2
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
80004f28:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
80004f2c:	10 0c       	add	r12,r8
80004f2e:	a1 5c       	asr	r12,0x1
	indextohWord = 2;
	while (hWordswithinFrag > 0)
80004f30:	58 0c       	cp.w	r12,0
80004f32:	e0 89 00 04 	brgt	80004f3a <xnl_tx+0x7e>
80004f36:	30 09       	mov	r9,0
80004f38:	c0 d8       	rjmp	80004f52 <xnl_tx+0x96>
80004f3a:	ec ca ff fc 	sub	r10,r6,-4
Parameters: xnl_fragment_t * 
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
80004f3e:	2f ec       	sub	r12,-2
80004f40:	30 09       	mov	r9,0
80004f42:	30 28       	mov	r8,2
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
	{
		sumScratch += *((U16*)xnl + indextohWord);
80004f44:	15 1b       	ld.sh	r11,r10++
80004f46:	f6 09 00 09 	add	r9,r11,r9
80004f4a:	5c 89       	casts.h	r9
		indextohWord     += 1;
80004f4c:	2f f8       	sub	r8,-1
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
80004f4e:	18 38       	cp.w	r8,r12
80004f50:	cf a1       	brne	80004f44 <xnl_tx+0x88>
		  ((++xnl_information.transaction_id) & 0xFF) 
		| (xnl_information.transaction_id & 0xFF00);
	}
	
	/*count check sum */
	xnl->phy_header.check_sum = check_sum( xnl );
80004f52:	5c 39       	neg	r9
80004f54:	ac 19       	st.h	r6[0x2],r9
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
80004f56:	48 e8       	lddpc	r8,80004f8c <xnl_tx+0xd0>
80004f58:	70 0c       	ld.w	r12,r8[0x0]
80004f5a:	f0 1f 00 0e 	mcall	80004f90 <xnl_tx+0xd4>
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
80004f5e:	c1 00       	breq	80004f7e <xnl_tx+0xc2>
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
80004f60:	fa c7 ff fc 	sub	r7,sp,-4
80004f64:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
	{
		memcpy(ptr, xnl, sizeof(xnl_fragment_t));
80004f66:	e0 6a 01 00 	mov	r10,256
80004f6a:	0c 9b       	mov	r11,r6
80004f6c:	f0 1f 00 0a 	mcall	80004f94 <xnl_tx+0xd8>
	
		/*push to queue and send*/
		
		//log("ptr -%8x", ptr);
		
		xQueueSend(xnl_frame_tx, &ptr, 0);
80004f70:	48 a8       	lddpc	r8,80004f98 <xnl_tx+0xdc>
80004f72:	70 0c       	ld.w	r12,r8[0x0]
80004f74:	30 09       	mov	r9,0
80004f76:	12 9a       	mov	r10,r9
80004f78:	1a 9b       	mov	r11,sp
80004f7a:	f0 1f 00 09 	mcall	80004f9c <xnl_tx+0xe0>
		//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
		
		//vPortFree(ptr);
	}
}
80004f7e:	2f fd       	sub	sp,-4
80004f80:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004f84:	00 00       	add	r0,r0
80004f86:	0b 64       	ld.uh	r4,--r5
80004f88:	00 00       	add	r0,r0
80004f8a:	0e 22       	rsub	r2,r7
80004f8c:	00 00       	add	r0,r0
80004f8e:	0a c4       	st.b	r5++,r4
80004f90:	80 00       	ld.sh	r0,r0[0x0]
80004f92:	37 6c       	mov	r12,118
80004f94:	80 00       	ld.sh	r0,r0[0x0]
80004f96:	86 8e       	ld.uh	lr,r3[0x0]
80004f98:	00 00       	add	r0,r0
80004f9a:	0b 6c       	ld.uh	r12,--r5
80004f9c:	80 00       	ld.sh	r0,r0[0x0]
80004f9e:	71 b4       	ld.w	r4,r8[0x6c]

80004fa0 <xnl_data_msg_func>:
Description: process while receive data message.
Calls:xnl_send_msg_ack, xcmp_exec(function in xcmp)
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_data_msg_func(xnl_fragment_t * xnl)
{
80004fa0:	eb cd 40 80 	pushm	r7,lr
80004fa4:	fa cd 01 00 	sub	sp,sp,256
80004fa8:	18 97       	mov	r7,r12
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80004faa:	e0 68 40 0e 	mov	r8,16398
80004fae:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004fb0:	3f f8       	mov	r8,-1
80004fb2:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG_ACK;
80004fb4:	30 c8       	mov	r8,12
80004fb6:	ba 28       	st.h	sp[0x4],r8
	
	/*Turn around Flags.*/	
	xnl_frame.xnl_header.flags = hdr->flags;
80004fb8:	98 38       	ld.sh	r8,r12[0x6]
80004fba:	ba 38       	st.h	sp[0x6],r8
	
	/*ACK Destination Address is Source of XNL_Message.*/
	xnl_frame.xnl_header.destination = hdr->source;
80004fbc:	98 58       	ld.sh	r8,r12[0xa]
80004fbe:	ba 48       	st.h	sp[0x8],r8
	
	/*ACK Source Address is my address.*/
	xnl_frame.xnl_header.source = hdr->destination;
80004fc0:	98 48       	ld.sh	r8,r12[0x8]
80004fc2:	ba 58       	st.h	sp[0xa],r8
	
	/*Turn around Transaction ID.*/
	xnl_frame.xnl_header.transaction_id = hdr->transaction_id;
80004fc4:	98 68       	ld.sh	r8,r12[0xc]
80004fc6:	ba 68       	st.h	sp[0xc],r8
	xnl_frame.xnl_header.payload_length = 0;
80004fc8:	30 08       	mov	r8,0
80004fca:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004fcc:	1a 9c       	mov	r12,sp
80004fce:	f0 1f 00 0a 	mcall	80004ff4 <xnl_data_msg_func+0x54>
	transmitter, but possibly is waiting in Queue with immediate timeout.
	 */
	xnl_send_msg_ack(&xnl->xnl_header);
	
	/*exec xcmp function*/
	xcmp_exec(xnl->xnl_payload.xnl_content_data_msg);//xcmp_rx
80004fd2:	fa cd 00 cc 	sub	sp,sp,204
80004fd6:	e0 6a 00 ca 	mov	r10,202
80004fda:	ee cb ff f0 	sub	r11,r7,-16
80004fde:	1a 9c       	mov	r12,sp
80004fe0:	f0 1f 00 06 	mcall	80004ff8 <xnl_data_msg_func+0x58>
80004fe4:	48 68       	lddpc	r8,80004ffc <xnl_data_msg_func+0x5c>
80004fe6:	70 08       	ld.w	r8,r8[0x0]
80004fe8:	5d 18       	icall	r8
80004fea:	fa cd ff 34 	sub	sp,sp,-204
}
80004fee:	2c 0d       	sub	sp,-256
80004ff0:	e3 cd 80 80 	ldm	sp++,r7,pc
80004ff4:	80 00       	ld.sh	r0,r0[0x0]
80004ff6:	4e bc       	lddpc	r12,800051a0 <xnl_device_conn_reply_func+0x20>
80004ff8:	80 00       	ld.sh	r0,r0[0x0]
80004ffa:	86 8e       	ld.uh	lr,r3[0x0]
80004ffc:	00 00       	add	r0,r0
80004ffe:	0b 78       	ld.ub	r8,--r5

80005000 <xnl_device_auth_reply_func>:
Description: process while receive device auth reply.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_auth_reply_func(xnl_fragment_t * xnl)
{
80005000:	d4 21       	pushm	r4-r7,lr
80005002:	fa cd 01 00 	sub	sp,sp,256
80005006:	18 97       	mov	r7,r12
	the receiving device and will be used to authenticate the connection 
	request. 5.4.4
	*/
	//log("R_xnl-opcode:%4x", xnl->xnl_header.opcode);
	
	if(xnl_information.is_connected)
80005008:	4c 28       	lddpc	r8,80005110 <xnl_device_auth_reply_func+0x110>
8000500a:	11 88       	ld.ub	r8,r8[0x0]
8000500c:	58 08       	cp.w	r8,0
8000500e:	e0 81 00 7f 	brne	8000510c <xnl_device_auth_reply_func+0x10c>
	{
		return;		
	}
	
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);
80005012:	4c 18       	lddpc	r8,80005114 <xnl_device_auth_reply_func+0x114>
80005014:	70 0c       	ld.w	r12,r8[0x0]
80005016:	30 09       	mov	r9,0
80005018:	12 9a       	mov	r10,r9
8000501a:	12 9b       	mov	r11,r9
8000501c:	f0 1f 00 3f 	mcall	80005118 <xnl_device_auth_reply_func+0x118>

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
80005020:	ef 09 00 10 	ld.sh	r9,r7[16]
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
80005024:	4b b8       	lddpc	r8,80005110 <xnl_device_auth_reply_func+0x110>
80005026:	b0 29       	st.h	r8[0x4],r9
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
	
	/*Get Array of values to be encrypted into an aligned 2X32bits.*/
	v_vector[0] =
80005028:	ef 39 00 12 	ld.ub	r9,r7[18]
8000502c:	ef 38 00 13 	ld.ub	r8,r7[19]
80005030:	b1 68       	lsl	r8,0x10
80005032:	f1 e9 11 89 	or	r9,r8,r9<<0x18
80005036:	ef 38 00 15 	ld.ub	r8,r7[21]
8000503a:	f3 e8 10 08 	or	r8,r9,r8
8000503e:	ef 39 00 14 	ld.ub	r9,r7[20]
80005042:	f1 e9 10 89 	or	r9,r8,r9<<0x8
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[2])<<8	  
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[3]);
	
	v_vector[1] =
80005046:	ef 3a 00 16 	ld.ub	r10,r7[22]
8000504a:	ef 38 00 17 	ld.ub	r8,r7[23]
8000504e:	b1 68       	lsl	r8,0x10
80005050:	f1 ea 11 8a 	or	r10,r8,r10<<0x18
80005054:	ef 38 00 19 	ld.ub	r8,r7[25]
80005058:	f5 e8 10 08 	or	r8,r10,r8
8000505c:	ef 3a 00 18 	ld.ub	r10,r7[24]
80005060:	f1 ea 10 88 	or	r8,r8,r10<<0x8
80005064:	30 0a       	mov	r10,0
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
80005066:	e0 64 79 b9 	mov	r4,31161
8000506a:	ea 14 9e 37 	orh	r4,0x9e37
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
8000506e:	e0 65 45 07 	mov	r5,17671
80005072:	ea 15 8a bd 	orh	r5,0x8abd
80005076:	e0 66 f9 3d 	mov	r6,63805
8000507a:	ea 16 99 68 	orh	r6,0x9968
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
8000507e:	e0 6e b8 cf 	mov	lr,47311
80005082:	ea 1e 36 83 	orh	lr,0x3683
80005086:	e0 67 aa 1c 	mov	r7,43548
8000508a:	ea 17 9c 36 	orh	r7,0x9c36
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
8000508e:	08 0a       	add	r10,r4
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
80005090:	f4 08 00 0c 	add	r12,r10,r8
80005094:	f0 0b 15 04 	lsl	r11,r8,0x4
80005098:	0a 0b       	add	r11,r5
8000509a:	f9 eb 20 0b 	eor	r11,r12,r11
8000509e:	f0 0c 16 05 	lsr	r12,r8,0x5
800050a2:	0c 0c       	add	r12,r6
800050a4:	18 5b       	eor	r11,r12
800050a6:	16 09       	add	r9,r11
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
800050a8:	f2 0c 15 04 	lsl	r12,r9,0x4
800050ac:	1c 0c       	add	r12,lr
800050ae:	f2 0b 16 05 	lsr	r11,r9,0x5
800050b2:	0e 0b       	add	r11,r7
800050b4:	f9 eb 20 0b 	eor	r11,r12,r11
800050b8:	f2 0a 00 0c 	add	r12,r9,r10
800050bc:	18 5b       	eor	r11,r12
800050be:	16 08       	add	r8,r11
{
	register U32 y=v[0], z=v[1], sum=0;
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
800050c0:	e0 6b 37 20 	mov	r11,14112
800050c4:	ea 1b c6 ef 	orh	r11,0xc6ef
800050c8:	16 3a       	cp.w	r10,r11
800050ca:	ce 21       	brne	8000508e <xnl_device_auth_reply_func+0x8e>
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :24 + 2(xnl length(24) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 24 + 2;
800050cc:	e0 6a 40 1a 	mov	r10,16410
800050d0:	ba 0a       	st.h	sp[0x0],r10
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
800050d2:	3f fa       	mov	r10,-1
800050d4:	ba 1a       	st.h	sp[0x2],r10
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_CONN_REQUEST;
800050d6:	30 6b       	mov	r11,6
800050d8:	ba 2b       	st.h	sp[0x4],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
800050da:	ba 3a       	st.h	sp[0x6],r10
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
800050dc:	48 db       	lddpc	r11,80005110 <xnl_device_auth_reply_func+0x110>
800050de:	96 1c       	ld.sh	r12,r11[0x2]
800050e0:	ba 4c       	st.h	sp[0x8],r12
	message here, and all will receive the same DEVICE_CONN_REPLY. Not real 
	sure what's going to happen with multiple conrol heads, etc. One suspects 
	the Rocket Scientists will eventually figure this out, and demand a 
	transaction ID based on Device Type in the XNL_DEVICE_AUTH_KEY_REQUEST.
	*/
	xnl_frame.xnl_header.source = xnl_information.device_address;
800050e2:	96 2b       	ld.sh	r11,r11[0x4]
800050e4:	ba 5b       	st.h	sp[0xa],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
800050e6:	ba 6a       	st.h	sp[0xc],r10
	
    /*his message contains 12 payload bytes*/	
	xnl_frame.xnl_header.payload_length = 0x000C;
800050e8:	30 ca       	mov	r10,12
800050ea:	ba 7a       	st.h	sp[0xe],r10
	
	/*No Preferred XNL Address*/
	xnl_frame.xnl_payload.xnl_content_device_conn_req.preferred_xnl_address = 
800050ec:	30 0a       	mov	r10,0
800050ee:	fb 5a 00 10 	st.h	sp[16],r10
	XCMP/XNL Development Specification Section 4.5.3.2.1.
	Same as in MOTOTRBO?XCMP/XNL Development Specification?
	evice_type--Option Board(0x07)
	authentication_index--Option Board(0x02)
	*/	
	xnl_frame.xnl_payload.xnl_content_device_conn_req.device_type = 0x07;
800050f2:	30 7a       	mov	r10,7
800050f4:	fb 6a 00 12 	st.b	sp[18],r10
	xnl_frame.xnl_payload.xnl_content_device_conn_req.authentication_index =
800050f8:	30 2a       	mov	r10,2
800050fa:	fb 6a 00 13 	st.b	sp[19],r10
	                                                                       0x02;
		
	//We know encrypted array happens to be aligned to 32-bit boundary.
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
800050fe:	fa ca ff ec 	sub	r10,sp,-20
80005102:	95 09       	st.w	r10[0x0],r9
	                         .encrypted_authentication_value[0])) = w_vector[0];
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
80005104:	95 18       	st.w	r10[0x4],r8
	                         .encrypted_authentication_value[4])) = w_vector[1];
	
	/*send XNL message*/
	xnl_tx(&xnl_frame);
80005106:	1a 9c       	mov	r12,sp
80005108:	f0 1f 00 05 	mcall	8000511c <xnl_device_auth_reply_func+0x11c>
}
8000510c:	2c 0d       	sub	sp,-256
8000510e:	d8 22       	popm	r4-r7,pc
80005110:	00 00       	add	r0,r0
80005112:	0e 22       	rsub	r2,r7
80005114:	00 00       	add	r0,r0
80005116:	0b 60       	ld.uh	r0,--r5
80005118:	80 00       	ld.sh	r0,r0[0x0]
8000511a:	71 b4       	ld.w	r4,r8[0x6c]
8000511c:	80 00       	ld.sh	r0,r0[0x0]
8000511e:	4e bc       	lddpc	r12,800052c8 <PcdReset+0x20>

80005120 <xnl_master_status_brdcst_func>:
Description: process while receive master status boardcast.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_master_status_brdcst_func(xnl_fragment_t * xnl)
{	
80005120:	eb cd 40 80 	pushm	r7,lr
80005124:	fa cd 01 00 	sub	sp,sp,256
80005128:	18 97       	mov	r7,r12
	not an XNL_DATA_MSG has been sent out. This will indicate to a connecting 
	device that it has missed messages. The XNL header will contain the 
	master?XNL address. 5.4.1
	*/
	
	if(xnl_information.is_connected)
8000512a:	49 28       	lddpc	r8,80005170 <xnl_master_status_brdcst_func+0x50>
8000512c:	11 88       	ld.ub	r8,r8[0x0]
8000512e:	58 08       	cp.w	r8,0
80005130:	c1 c1       	brne	80005168 <xnl_master_status_brdcst_func+0x48>
	{
		return;	
	}
		
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);	
80005132:	49 18       	lddpc	r8,80005174 <xnl_master_status_brdcst_func+0x54>
80005134:	70 0c       	ld.w	r12,r8[0x0]
80005136:	30 09       	mov	r9,0
80005138:	12 9a       	mov	r10,r9
8000513a:	12 9b       	mov	r11,r9
8000513c:	f0 1f 00 0f 	mcall	80005178 <xnl_master_status_brdcst_func+0x58>

	//log("xnl-ma:%4x", xnl->xnl_header.source);
	/*get the master adderss from this message*/	
	xnl_information.master_address = xnl->xnl_header.source;	
80005140:	8e 58       	ld.sh	r8,r7[0xa]
80005142:	48 c9       	lddpc	r9,80005170 <xnl_master_status_brdcst_func+0x50>
80005144:	b2 18       	st.h	r9[0x2],r8
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80005146:	e0 68 40 0e 	mov	r8,16398
8000514a:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
8000514c:	3f f8       	mov	r8,-1
8000514e:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_AUTH_KEY_REQUEST;
80005150:	30 4a       	mov	r10,4
80005152:	ba 2a       	st.h	sp[0x4],r10
		
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/	
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
80005154:	ba 38       	st.h	sp[0x6],r8
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
80005156:	92 19       	ld.sh	r9,r9[0x2]
80005158:	ba 49       	st.h	sp[0x8],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.source = DEFAULT_VALUE;
8000515a:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
8000515c:	ba 68       	st.h	sp[0xc],r8
		
	xnl_frame.xnl_header.payload_length = 0;
8000515e:	30 08       	mov	r8,0
80005160:	ba 78       	st.h	sp[0xe],r8
	
	/*send XNL message*/	
	xnl_tx(&xnl_frame);
80005162:	1a 9c       	mov	r12,sp
80005164:	f0 1f 00 06 	mcall	8000517c <xnl_master_status_brdcst_func+0x5c>
}
80005168:	2c 0d       	sub	sp,-256
8000516a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000516e:	00 00       	add	r0,r0
80005170:	00 00       	add	r0,r0
80005172:	0e 22       	rsub	r2,r7
80005174:	00 00       	add	r0,r0
80005176:	0b 60       	ld.uh	r0,--r5
80005178:	80 00       	ld.sh	r0,r0[0x0]
8000517a:	71 b4       	ld.w	r4,r8[0x6c]
8000517c:	80 00       	ld.sh	r0,r0[0x0]
8000517e:	4e bc       	lddpc	r12,80005328 <ReadRawRC>

80005180 <xnl_device_conn_reply_func>:
Description: process while receive device conn reply.
Calls:xSemaphoreGive--freestos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_conn_reply_func(xnl_fragment_t * xnl)
{
80005180:	eb cd 40 80 	pushm	r7,lr
80005184:	18 97       	mov	r7,r12
	transaction ID and an 8-byte encrypted value that the device can use to 
	authenticate the master. XCMP/XNL Development Guide 5.4.6
	*/
	
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);
80005186:	49 28       	lddpc	r8,800051cc <xnl_device_conn_reply_func+0x4c>
80005188:	70 0c       	ld.w	r12,r8[0x0]
8000518a:	30 09       	mov	r9,0
8000518c:	12 9a       	mov	r10,r9
8000518e:	12 9b       	mov	r11,r9
80005190:	f0 1f 00 10 	mcall	800051d0 <xnl_device_conn_reply_func+0x50>

	/*Test result code*/
	if((xnl->xnl_payload.xnl_content_device_conn_reply.result_base & 0x0000FF00)
80005194:	ef 18 00 10 	ld.uh	r8,r7[16]
80005198:	10 99       	mov	r9,r8
8000519a:	e2 19 ff 00 	andl	r9,0xff00,COH
8000519e:	e0 49 01 00 	cp.w	r9,256
800051a2:	c0 60       	breq	800051ae <xnl_device_conn_reply_func+0x2e>
		/*
		Rejected. The device must retry the authentication process at this 
		point by sending out a new AUTH_KEY_REQUEST message. XCMP/XNL 
		Development Guide Section 5.2.3
		*/
		xnl_master_status_brdcst_func(xnl);			
800051a4:	0e 9c       	mov	r12,r7
800051a6:	f0 1f 00 0c 	mcall	800051d4 <xnl_device_conn_reply_func+0x54>
800051aa:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/*connection accepted*/		
		/*Record Transaction ID Base*/
		xnl_information.transaction_id =  
800051ae:	a9 68       	lsl	r8,0x8
800051b0:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
800051b4:	48 98       	lddpc	r8,800051d8 <xnl_device_conn_reply_func+0x58>
800051b6:	b0 49       	st.h	r8[0x8],r9
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
800051b8:	ef 09 00 14 	ld.sh	r9,r7[20]
		xnl_information.transaction_id =  
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
800051bc:	b0 39       	st.h	r8[0x6],r9
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
800051be:	ef 09 00 12 	ld.sh	r9,r7[18]
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
800051c2:	b0 29       	st.h	r8[0x4],r9
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
		
		/*connect finish*/
		xnl_information.is_connected = TRUE;
800051c4:	30 19       	mov	r9,1
800051c6:	b0 89       	st.b	r8[0x0],r9
800051c8:	e3 cd 80 80 	ldm	sp++,r7,pc
800051cc:	00 00       	add	r0,r0
800051ce:	0b 60       	ld.uh	r0,--r5
800051d0:	80 00       	ld.sh	r0,r0[0x0]
800051d2:	71 b4       	ld.w	r4,r8[0x6c]
800051d4:	80 00       	ld.sh	r0,r0[0x0]
800051d6:	51 20       	stdsp	sp[0x48],r0
800051d8:	00 00       	add	r0,r0
800051da:	0e 22       	rsub	r2,r7

800051dc <xnl_send_device_master_query>:
Description: send device_master_query to connect radio.
Calls:xnl_tx
Call By:xnl_init
*/
void xnl_send_device_master_query(void)
{
800051dc:	d4 01       	pushm	lr
800051de:	fa cd 01 00 	sub	sp,sp,256
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
800051e2:	e0 68 40 0e 	mov	r8,16398
800051e6:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
800051e8:	3f f8       	mov	r8,-1
800051ea:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_MASTER_QUERY;
800051ec:	30 38       	mov	r8,3
800051ee:	ba 28       	st.h	sp[0x4],r8
	
	/*The initial value*/
	xnl_frame.xnl_header.flags = 0;
800051f0:	30 08       	mov	r8,0
800051f2:	ba 38       	st.h	sp[0x6],r8
	
	/*XNL address of the master device, if known;otherwise 0x0000*/
	xnl_frame.xnl_header.destination = 0;
800051f4:	ba 48       	st.h	sp[0x8],r8
	
	/*XNL address, if assigned; otherwise 0x0000*/
	xnl_frame.xnl_header.source = 0;
800051f6:	ba 58       	st.h	sp[0xa],r8
	
	/*No transaction ID required for this message*/
	xnl_frame.xnl_header.transaction_id = 0;
800051f8:	ba 68       	st.h	sp[0xc],r8
	
	/*This message contains no payload*/
	xnl_frame.xnl_header.payload_length = 0;
800051fa:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
800051fc:	1a 9c       	mov	r12,sp
800051fe:	f0 1f 00 03 	mcall	80005208 <xnl_send_device_master_query+0x2c>
}
80005202:	2c 0d       	sub	sp,-256
80005204:	d8 02       	popm	pc
80005206:	00 00       	add	r0,r0
80005208:	80 00       	ld.sh	r0,r0[0x0]
8000520a:	4e bc       	lddpc	r12,800053b4 <Powerdown_RC522+0x34>

8000520c <RC522_ReadByte>:
	/*!< Return the byte read from the SPI bus */
	return  temp;

}
U8 RC522_ReadByte(void)
{
8000520c:	eb cd 40 c0 	pushm	r6-r7,lr
	//蹇椤昏锋芥ｅ父璇诲
	//spi_selectChip(spi, DF_SPI_PCS_0);
	
	/*!< Send the byte */

	spi_write(spi,  0xFF);
80005210:	48 76       	lddpc	r6,8000522c <RC522_ReadByte+0x20>
80005212:	e0 6b 00 ff 	mov	r11,255
80005216:	6c 0c       	ld.w	r12,r6[0x0]
80005218:	f0 1f 00 06 	mcall	80005230 <RC522_ReadByte+0x24>
	
	/*!< Return the byte read from the SPI bus */

	spi_read(spi, Data);
8000521c:	30 07       	mov	r7,0
8000521e:	0e 9b       	mov	r11,r7
80005220:	6c 0c       	ld.w	r12,r6[0x0]
80005222:	f0 1f 00 05 	mcall	80005234 <RC522_ReadByte+0x28>
	
	//spi_unselectChip(spi, DF_SPI_PCS_0);
	
	return (U8)(*Data);
	
}
80005226:	0f 9c       	ld.ub	r12,r7[0x1]
80005228:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000522c:	00 00       	add	r0,r0
8000522e:	1e 2c       	rsub	r12,pc
80005230:	80 00       	ld.sh	r0,r0[0x0]
80005232:	66 aa       	ld.w	r10,r3[0x28]
80005234:	80 00       	ld.sh	r0,r0[0x0]
80005236:	66 c6       	ld.w	r6,r3[0x30]

80005238 <RC522_WriteByte>:


U8 rc522_init_failure =0;

U8 RC522_WriteByte(U8 Data)
{
80005238:	eb cd 40 80 	pushm	r7,lr
8000523c:	20 1d       	sub	sp,4
8000523e:	ba 8c       	st.b	sp[0x0],r12
	U8 temp =0;
	
	//spi_selectChip(spi, DF_SPI_PCS_0);
	
	/*!< Send the byte */
	spi_write(spi,  (U16)Data);
80005240:	48 77       	lddpc	r7,8000525c <RC522_WriteByte+0x24>
80005242:	f7 dc c0 08 	bfextu	r11,r12,0x0,0x8
80005246:	6e 0c       	ld.w	r12,r7[0x0]
80005248:	f0 1f 00 06 	mcall	80005260 <RC522_WriteByte+0x28>
	
	/*!< Wait to receive a byte*/

	temp = spi_read(spi, (U16*)&Data);
8000524c:	1a 9b       	mov	r11,sp
8000524e:	6e 0c       	ld.w	r12,r7[0x0]
80005250:	f0 1f 00 05 	mcall	80005264 <RC522_WriteByte+0x2c>
	//spi_unselectChip(spi, DF_SPI_PCS_0);
	
	/*!< Return the byte read from the SPI bus */
	return  temp;

}
80005254:	5c 5c       	castu.b	r12
80005256:	2f fd       	sub	sp,-4
80005258:	e3 cd 80 80 	ldm	sp++,r7,pc
8000525c:	00 00       	add	r0,r0
8000525e:	1e 2c       	rsub	r12,pc
80005260:	80 00       	ld.sh	r0,r0[0x0]
80005262:	66 aa       	ld.w	r10,r3[0x28]
80005264:	80 00       	ld.sh	r0,r0[0x0]
80005266:	66 c6       	ld.w	r6,r3[0x30]

80005268 <WriteRawRC>:
//    斤RC632瀵瀛
//拌存锛Address[IN]:瀵瀛ㄥ板
//          value[IN]:ョ
/////////////////////////////////////////////////////////////////////
void WriteRawRC(U8   Address, U8   value)
{
80005268:	eb cd 40 e0 	pushm	r5-r7,lr
8000526c:	18 96       	mov	r6,r12
8000526e:	16 95       	mov	r5,r11
	U8   ucAddr;

	//CLR_SPI_CS;	
	spi_selectChip(spi, DF_SPI_PCS_0);
80005270:	48 a7       	lddpc	r7,80005298 <WriteRawRC+0x30>
80005272:	30 0b       	mov	r11,0
80005274:	6e 0c       	ld.w	r12,r7[0x0]
80005276:	f0 1f 00 0a 	mcall	8000529c <WriteRawRC+0x34>
	
	ucAddr = ((Address<<1)&0x7E);
	RC522_WriteByte(ucAddr);
8000527a:	ec 0c 15 01 	lsl	r12,r6,0x1
8000527e:	e2 1c 00 7e 	andl	r12,0x7e,COH
80005282:	f0 1f 00 08 	mcall	800052a0 <WriteRawRC+0x38>
	RC522_WriteByte(value);
80005286:	0a 9c       	mov	r12,r5
80005288:	f0 1f 00 06 	mcall	800052a0 <WriteRawRC+0x38>
	
	spi_unselectChip(spi, DF_SPI_PCS_0);
8000528c:	30 0b       	mov	r11,0
8000528e:	6e 0c       	ld.w	r12,r7[0x0]
80005290:	f0 1f 00 05 	mcall	800052a4 <WriteRawRC+0x3c>
	
	//SET_SPI_CS;

}
80005294:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80005298:	00 00       	add	r0,r0
8000529a:	1e 2c       	rsub	r12,pc
8000529c:	80 00       	ld.sh	r0,r0[0x0]
8000529e:	68 10       	ld.w	r0,r4[0x4]
800052a0:	80 00       	ld.sh	r0,r0[0x0]
800052a2:	52 38       	stdsp	sp[0x8c],r8
800052a4:	80 00       	ld.sh	r0,r0[0x0]
800052a6:	67 d0       	ld.w	r0,r3[0x74]

800052a8 <PcdReset>:
/////////////////////////////////////////////////////////////////////
//    斤澶浣RC522
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdReset(void)
{
800052a8:	d4 01       	pushm	lr

	SET_RC522RST;
800052aa:	31 9c       	mov	r12,25
800052ac:	f0 1f 00 1b 	mcall	80005318 <PcdReset+0x70>
	delay_ns(10);
800052b0:	30 ac       	mov	r12,10
800052b2:	f0 1f 00 1b 	mcall	8000531c <PcdReset+0x74>

	CLR_RC522RST;
800052b6:	31 9c       	mov	r12,25
800052b8:	f0 1f 00 1a 	mcall	80005320 <PcdReset+0x78>
	delay_ns(10);
800052bc:	30 ac       	mov	r12,10
800052be:	f0 1f 00 18 	mcall	8000531c <PcdReset+0x74>

	SET_RC522RST;
800052c2:	31 9c       	mov	r12,25
800052c4:	f0 1f 00 15 	mcall	80005318 <PcdReset+0x70>
	delay_ns(10);
800052c8:	30 ac       	mov	r12,10
800052ca:	f0 1f 00 15 	mcall	8000531c <PcdReset+0x74>
	WriteRawRC(CommandReg,PCD_RESETPHASE);
800052ce:	30 fb       	mov	r11,15
800052d0:	30 1c       	mov	r12,1
800052d2:	f0 1f 00 15 	mcall	80005324 <PcdReset+0x7c>
	WriteRawRC(CommandReg,PCD_RESETPHASE);
800052d6:	30 fb       	mov	r11,15
800052d8:	30 1c       	mov	r12,1
800052da:	f0 1f 00 13 	mcall	80005324 <PcdReset+0x7c>
	delay_ns(10);
800052de:	30 ac       	mov	r12,10
800052e0:	f0 1f 00 0f 	mcall	8000531c <PcdReset+0x74>
	
	WriteRawRC(ModeReg,0x3D);            //Mifare￠璁锛CRC濮0x6363
800052e4:	33 db       	mov	r11,61
800052e6:	31 1c       	mov	r12,17
800052e8:	f0 1f 00 0f 	mcall	80005324 <PcdReset+0x7c>
	WriteRawRC(TReloadRegL,30);
800052ec:	31 eb       	mov	r11,30
800052ee:	32 dc       	mov	r12,45
800052f0:	f0 1f 00 0d 	mcall	80005324 <PcdReset+0x7c>
	WriteRawRC(TReloadRegH,0);
800052f4:	30 0b       	mov	r11,0
800052f6:	32 cc       	mov	r12,44
800052f8:	f0 1f 00 0b 	mcall	80005324 <PcdReset+0x7c>
	WriteRawRC(TModeReg,0x8D);
800052fc:	e0 6b 00 8d 	mov	r11,141
80005300:	32 ac       	mov	r12,42
80005302:	f0 1f 00 09 	mcall	80005324 <PcdReset+0x7c>
	WriteRawRC(TPrescalerReg,0x3E);
80005306:	33 eb       	mov	r11,62
80005308:	32 bc       	mov	r12,43
8000530a:	f0 1f 00 07 	mcall	80005324 <PcdReset+0x7c>
	
	WriteRawRC(TxAutoReg,0x40);//蹇椤昏
8000530e:	34 0b       	mov	r11,64
80005310:	31 5c       	mov	r12,21
80005312:	f0 1f 00 05 	mcall	80005324 <PcdReset+0x7c>
	
	return MI_OK;
}
80005316:	d8 0a       	popm	pc,r12=0
80005318:	80 00       	ld.sh	r0,r0[0x0]
8000531a:	62 18       	ld.w	r8,r1[0x4]
8000531c:	80 00       	ld.sh	r0,r0[0x0]
8000531e:	5a e0       	cp.w	r0,-18
80005320:	80 00       	ld.sh	r0,r0[0x0]
80005322:	62 34       	ld.w	r4,r1[0xc]
80005324:	80 00       	ld.sh	r0,r0[0x0]
80005326:	52 68       	stdsp	sp[0x98],r8

80005328 <ReadRawRC>:
//    斤璇RC632瀵瀛
//拌存锛Address[IN]:瀵瀛ㄥ板
//杩    锛璇诲虹
/////////////////////////////////////////////////////////////////////
U8 ReadRawRC(U8   Address)
{
80005328:	eb cd 40 c0 	pushm	r6-r7,lr
8000532c:	18 96       	mov	r6,r12
	U8   ucAddr;
	U8   ucResult=0;
	//CLR_SPI_CS;	
	spi_selectChip(spi, DF_SPI_PCS_0);
8000532e:	48 c7       	lddpc	r7,8000535c <ReadRawRC+0x34>
80005330:	30 0b       	mov	r11,0
80005332:	6e 0c       	ld.w	r12,r7[0x0]
80005334:	f0 1f 00 0b 	mcall	80005360 <ReadRawRC+0x38>
	 
	ucAddr = ((Address<<1)&0x7E)|0x80;
	
	RC522_WriteByte(ucAddr);
80005338:	a1 76       	lsl	r6,0x1
8000533a:	0c 9c       	mov	r12,r6
8000533c:	e2 1c 00 7e 	andl	r12,0x7e,COH
80005340:	a7 bc       	sbr	r12,0x7
80005342:	f0 1f 00 09 	mcall	80005364 <ReadRawRC+0x3c>
	ucResult = RC522_ReadByte();
80005346:	f0 1f 00 09 	mcall	80005368 <ReadRawRC+0x40>
8000534a:	18 96       	mov	r6,r12
	
	spi_unselectChip(spi, DF_SPI_PCS_0);
8000534c:	30 0b       	mov	r11,0
8000534e:	6e 0c       	ld.w	r12,r7[0x0]
80005350:	f0 1f 00 07 	mcall	8000536c <ReadRawRC+0x44>
	//SET_SPI_CS;
	return ucResult;
}
80005354:	0c 9c       	mov	r12,r6
80005356:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000535a:	00 00       	add	r0,r0
8000535c:	00 00       	add	r0,r0
8000535e:	1e 2c       	rsub	r12,pc
80005360:	80 00       	ld.sh	r0,r0[0x0]
80005362:	68 10       	ld.w	r0,r4[0x4]
80005364:	80 00       	ld.sh	r0,r0[0x0]
80005366:	52 38       	stdsp	sp[0x8c],r8
80005368:	80 00       	ld.sh	r0,r0[0x0]
8000536a:	52 0c       	stdsp	sp[0x80],r12
8000536c:	80 00       	ld.sh	r0,r0[0x0]
8000536e:	67 d0       	ld.w	r0,r3[0x74]

80005370 <Wait_Wakeup_RC522>:

/////////////////////////////////////////////////////////////////////
//    斤绛寰RC522
/////////////////////////////////////////////////////////////////////
void Wait_Wakeup_RC522(void)
{
80005370:	d4 01       	pushm	lr
	char   tmp = 0x0;
	char   reg = CommandReg;
	
	do 
	{
		tmp = ReadRawRC(reg);
80005372:	30 1c       	mov	r12,1
80005374:	f0 1f 00 02 	mcall	8000537c <Wait_Wakeup_RC522+0xc>
			
	//tmp = ReadRawRC(reg);
	//if((tmp & 0x10) == 0)
	//WriteRawRC(reg,tmp | PCD_POWERDOWN);  // set bit powerdown
	
}
80005378:	d8 02       	popm	pc
8000537a:	00 00       	add	r0,r0
8000537c:	80 00       	ld.sh	r0,r0[0x0]
8000537e:	53 28       	stdsp	sp[0xc8],r8

80005380 <Powerdown_RC522>:
/////////////////////////////////////////////////////////////////////
//    斤浣RC522杩ヨ蒋垫ā寮
//
/////////////////////////////////////////////////////////////////////
void Powerdown_RC522(U8 act)
{
80005380:	eb cd 40 80 	pushm	r7,lr
80005384:	18 97       	mov	r7,r12
	char   tmp = 0x0;
	char   reg = CommandReg;
	
	tmp = ReadRawRC(reg);
80005386:	30 1c       	mov	r12,1
80005388:	f0 1f 00 0d 	mcall	800053bc <Powerdown_RC522+0x3c>
	if(act == ENTER_POWERDOWN)//1
8000538c:	30 18       	mov	r8,1
8000538e:	f0 07 18 00 	cp.b	r7,r8
80005392:	c0 91       	brne	800053a4 <Powerdown_RC522+0x24>
		WriteRawRC(reg,tmp | PCD_POWERDOWN);  // set bit powerdown
80005394:	18 9b       	mov	r11,r12
80005396:	a5 ab       	sbr	r11,0x4
80005398:	5c 5b       	castu.b	r11
8000539a:	30 1c       	mov	r12,1
8000539c:	f0 1f 00 09 	mcall	800053c0 <Powerdown_RC522+0x40>
800053a0:	e3 cd 80 80 	ldm	sp++,r7,pc
	else
	{
		WriteRawRC(reg,tmp | PCD_IDLE);  // wake up rc522
800053a4:	18 9b       	mov	r11,r12
800053a6:	30 1c       	mov	r12,1
800053a8:	f0 1f 00 06 	mcall	800053c0 <Powerdown_RC522+0x40>
		delay_ns(2);
800053ac:	30 2c       	mov	r12,2
800053ae:	f0 1f 00 06 	mcall	800053c4 <Powerdown_RC522+0x44>
		Wait_Wakeup_RC522();
800053b2:	f0 1f 00 06 	mcall	800053c8 <Powerdown_RC522+0x48>
800053b6:	e3 cd 80 80 	ldm	sp++,r7,pc
800053ba:	00 00       	add	r0,r0
800053bc:	80 00       	ld.sh	r0,r0[0x0]
800053be:	53 28       	stdsp	sp[0xc8],r8
800053c0:	80 00       	ld.sh	r0,r0[0x0]
800053c2:	52 68       	stdsp	sp[0x98],r8
800053c4:	80 00       	ld.sh	r0,r0[0x0]
800053c6:	5a e0       	cp.w	r0,-18
800053c8:	80 00       	ld.sh	r0,r0[0x0]
800053ca:	53 70       	stdsp	sp[0xdc],r0

800053cc <SetBitMask>:
//    斤缃RC522瀵瀛ㄤ
//拌存锛reg[IN]:瀵瀛ㄥ板
//          mask[IN]:缃浣
/////////////////////////////////////////////////////////////////////
void SetBitMask(U8   reg,U8   mask)
{
800053cc:	eb cd 40 c0 	pushm	r6-r7,lr
800053d0:	18 97       	mov	r7,r12
800053d2:	16 96       	mov	r6,r11
	char   tmp = 0x0;
	tmp = ReadRawRC(reg);
800053d4:	f0 1f 00 05 	mcall	800053e8 <SetBitMask+0x1c>
	WriteRawRC(reg,tmp | mask);  // set bit mask
800053d8:	f9 e6 10 0b 	or	r11,r12,r6
800053dc:	5c 5b       	castu.b	r11
800053de:	0e 9c       	mov	r12,r7
800053e0:	f0 1f 00 03 	mcall	800053ec <SetBitMask+0x20>
}
800053e4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800053e8:	80 00       	ld.sh	r0,r0[0x0]
800053ea:	53 28       	stdsp	sp[0xc8],r8
800053ec:	80 00       	ld.sh	r0,r0[0x0]
800053ee:	52 68       	stdsp	sp[0x98],r8

800053f0 <ClearBitMask>:
//    斤娓RC522瀵瀛ㄤ
//拌存锛reg[IN]:瀵瀛ㄥ板
//         mask[IN]:娓浣
/////////////////////////////////////////////////////////////////////
void ClearBitMask(U8   reg,U8   mask)
{
800053f0:	eb cd 40 c0 	pushm	r6-r7,lr
800053f4:	18 97       	mov	r7,r12
800053f6:	16 96       	mov	r6,r11
	  char   tmp = 0x0;
	  tmp = ReadRawRC(reg);
800053f8:	f0 1f 00 06 	mcall	80005410 <ClearBitMask+0x20>
	  WriteRawRC(reg, tmp & ~mask);  // clear bit mask
800053fc:	5c d6       	com	r6
800053fe:	f9 e6 00 06 	and	r6,r12,r6
80005402:	f7 d6 c0 08 	bfextu	r11,r6,0x0,0x8
80005406:	0e 9c       	mov	r12,r7
80005408:	f0 1f 00 03 	mcall	80005414 <ClearBitMask+0x24>
	
}
8000540c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005410:	80 00       	ld.sh	r0,r0[0x0]
80005412:	53 28       	stdsp	sp[0xc8],r8
80005414:	80 00       	ld.sh	r0,r0[0x0]
80005416:	52 68       	stdsp	sp[0x98],r8

80005418 <PcdComMF522>:
char PcdComMF522(U8  Command,
				 U8 *pIn ,
				 U8  InLenByte,
				 U8 *pOut ,
				 U8 *pOutLenBit)
{
80005418:	d4 31       	pushm	r0-r7,lr
8000541a:	20 1d       	sub	sp,4
8000541c:	18 92       	mov	r2,r12
8000541e:	16 95       	mov	r5,r11
80005420:	14 96       	mov	r6,r10
80005422:	50 09       	stdsp	sp[0x0],r9
80005424:	10 90       	mov	r0,r8
80005426:	f8 c8 00 0c 	sub	r8,r12,12
8000542a:	5c 58       	castu.b	r8
8000542c:	30 29       	mov	r9,2
8000542e:	f2 08 18 00 	cp.b	r8,r9
80005432:	e0 88 00 05 	brls	8000543c <PcdComMF522+0x24>
80005436:	30 03       	mov	r3,0
80005438:	06 91       	mov	r1,r3
8000543a:	c0 78       	rjmp	80005448 <PcdComMF522+0x30>
8000543c:	4c f9       	lddpc	r9,80005578 <PcdComMF522+0x160>
8000543e:	f2 08 07 01 	ld.ub	r1,r9[r8]
80005442:	4c f9       	lddpc	r9,8000557c <PcdComMF522+0x164>
80005444:	f2 08 07 03 	ld.ub	r3,r9[r8]
		break;
		default:
		break;
	}
	
	WriteRawRC(ComIEnReg,irqEn|0x80);
80005448:	02 9b       	mov	r11,r1
8000544a:	a7 bb       	sbr	r11,0x7
8000544c:	30 2c       	mov	r12,2
8000544e:	f0 1f 00 4d 	mcall	80005580 <PcdComMF522+0x168>
	ClearBitMask(ComIrqReg,0x80);	//娓涓浣
80005452:	e0 6b 00 80 	mov	r11,128
80005456:	30 4c       	mov	r12,4
80005458:	f0 1f 00 4b 	mcall	80005584 <PcdComMF522+0x16c>
	WriteRawRC(CommandReg,PCD_IDLE);
8000545c:	30 0b       	mov	r11,0
8000545e:	30 1c       	mov	r12,1
80005460:	f0 1f 00 48 	mcall	80005580 <PcdComMF522+0x168>
	SetBitMask(FIFOLevelReg,0x80);	 	//娓FIFO缂瀛
80005464:	e0 6b 00 80 	mov	r11,128
80005468:	30 ac       	mov	r12,10
8000546a:	f0 1f 00 48 	mcall	80005588 <PcdComMF522+0x170>
	
	for (i=0; i<InLenByte; i++)
8000546e:	58 06       	cp.w	r6,0
80005470:	c0 c0       	breq	80005488 <PcdComMF522+0x70>
80005472:	0a 97       	mov	r7,r5
	{   
		WriteRawRC(FIFODataReg, pIn [i]);
80005474:	30 94       	mov	r4,9
80005476:	0f 3b       	ld.ub	r11,r7++
80005478:	08 9c       	mov	r12,r4
8000547a:	f0 1f 00 42 	mcall	80005580 <PcdComMF522+0x168>
	WriteRawRC(ComIEnReg,irqEn|0x80);
	ClearBitMask(ComIrqReg,0x80);	//娓涓浣
	WriteRawRC(CommandReg,PCD_IDLE);
	SetBitMask(FIFOLevelReg,0x80);	 	//娓FIFO缂瀛
	
	for (i=0; i<InLenByte; i++)
8000547e:	0e 98       	mov	r8,r7
80005480:	0a 18       	sub	r8,r5
80005482:	ec 08 19 00 	cp.h	r8,r6
80005486:	cf 83       	brcs	80005476 <PcdComMF522+0x5e>
	{   
		WriteRawRC(FIFODataReg, pIn [i]);
	}
	WriteRawRC(CommandReg, Command);
80005488:	04 9b       	mov	r11,r2
8000548a:	30 1c       	mov	r12,1
8000548c:	f0 1f 00 3d 	mcall	80005580 <PcdComMF522+0x168>
	
	if (Command == PCD_TRANSCEIVE)
80005490:	30 c8       	mov	r8,12
80005492:	f0 02 18 00 	cp.b	r2,r8
80005496:	c0 61       	brne	800054a2 <PcdComMF522+0x8a>
	{    
		SetBitMask(BitFramingReg,0x80);  
80005498:	e0 6b 00 80 	mov	r11,128
8000549c:	30 dc       	mov	r12,13
8000549e:	f0 1f 00 3b 	mcall	80005588 <PcdComMF522+0x170>
	
	//i = 600;//规堕棰璋达浣M1℃澶х寰堕25ms
	i = 2000;
	do
	{
		n = ReadRawRC(ComIrqReg);
800054a2:	30 4c       	mov	r12,4
800054a4:	f0 1f 00 3a 	mcall	8000558c <PcdComMF522+0x174>
800054a8:	18 97       	mov	r7,r12
800054aa:	e0 66 07 cf 	mov	r6,1999
		i--;
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
800054ae:	30 05       	mov	r5,0
	
	//i = 600;//规堕棰璋达浣M1℃澶х寰堕25ms
	i = 2000;
	do
	{
		n = ReadRawRC(ComIrqReg);
800054b0:	30 44       	mov	r4,4
800054b2:	c0 88       	rjmp	800054c2 <PcdComMF522+0xaa>
800054b4:	08 9c       	mov	r12,r4
800054b6:	f0 1f 00 36 	mcall	8000558c <PcdComMF522+0x174>
800054ba:	18 97       	mov	r7,r12
		i--;
800054bc:	20 16       	sub	r6,1
800054be:	5c 86       	casts.h	r6
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
800054c0:	c0 a0       	breq	800054d4 <PcdComMF522+0xbc>
800054c2:	f1 d7 c0 01 	bfextu	r8,r7,0x0,0x1
800054c6:	c4 c1       	brne	8000555e <PcdComMF522+0x146>
800054c8:	ef e3 00 08 	and	r8,r7,r3
800054cc:	ea 08 18 00 	cp.b	r8,r5
800054d0:	cf 20       	breq	800054b4 <PcdComMF522+0x9c>
800054d2:	c4 68       	rjmp	8000555e <PcdComMF522+0x146>
	ClearBitMask(BitFramingReg,0x80);
800054d4:	e0 6b 00 80 	mov	r11,128
800054d8:	30 dc       	mov	r12,13
800054da:	f0 1f 00 2b 	mcall	80005584 <PcdComMF522+0x16c>
800054de:	30 27       	mov	r7,2
800054e0:	c3 38       	rjmp	80005546 <PcdComMF522+0x12e>
800054e2:	02 67       	and	r7,r1
800054e4:	ef d7 c0 01 	bfextu	r7,r7,0x0,0x1
		if(!(ReadRawRC(ErrorReg)&0x1B))
		{
			status = MI_OK;
			if (n & irqEn & 0x01)
			{   status = MI_NOTAGERR;   }
			if (Command == PCD_TRANSCEIVE)
800054e8:	30 c8       	mov	r8,12
800054ea:	f0 02 18 00 	cp.b	r2,r8
800054ee:	c2 c1       	brne	80005546 <PcdComMF522+0x12e>
			{
				n = ReadRawRC(FIFOLevelReg);
800054f0:	30 ac       	mov	r12,10
800054f2:	f0 1f 00 27 	mcall	8000558c <PcdComMF522+0x174>
800054f6:	18 94       	mov	r4,r12
				lastBits = ReadRawRC(ControlReg) & 0x07;
800054f8:	30 cc       	mov	r12,12
800054fa:	f0 1f 00 25 	mcall	8000558c <PcdComMF522+0x174>
800054fe:	f9 dc c0 03 	bfextu	r12,r12,0x0,0x3
				if (lastBits)
80005502:	c0 70       	breq	80005510 <PcdComMF522+0xf8>
				{   *pOutLenBit = (n-1)*8 + lastBits;   }
80005504:	08 98       	mov	r8,r4
80005506:	20 18       	sub	r8,1
80005508:	f8 08 00 3c 	add	r12,r12,r8<<0x3
8000550c:	a0 8c       	st.b	r0[0x0],r12
8000550e:	c0 48       	rjmp	80005516 <PcdComMF522+0xfe>
				else
				{   *pOutLenBit = n*8;   }
80005510:	e8 08 15 03 	lsl	r8,r4,0x3
80005514:	a0 88       	st.b	r0[0x0],r8
				if (n == 0)
80005516:	58 04       	cp.w	r4,0
80005518:	c0 61       	brne	80005524 <PcdComMF522+0x10c>
8000551a:	30 14       	mov	r4,1
8000551c:	40 05       	lddsp	r5,sp[0x0]
8000551e:	0a 96       	mov	r6,r5
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
				{   pOut [i] = ReadRawRC(FIFODataReg);    }
80005520:	30 93       	mov	r3,9
80005522:	c0 98       	rjmp	80005534 <PcdComMF522+0x11c>
				{   *pOutLenBit = n*8;   }
				if (n == 0)
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
80005524:	31 28       	mov	r8,18
80005526:	f0 04 18 00 	cp.b	r4,r8
8000552a:	f9 b4 0b 12 	movhi	r4,18
8000552e:	58 04       	cp.w	r4,0
80005530:	cf 61       	brne	8000551c <PcdComMF522+0x104>
80005532:	c0 a8       	rjmp	80005546 <PcdComMF522+0x12e>
				{   pOut [i] = ReadRawRC(FIFODataReg);    }
80005534:	06 9c       	mov	r12,r3
80005536:	f0 1f 00 16 	mcall	8000558c <PcdComMF522+0x174>
8000553a:	0c cc       	st.b	r6++,r12
				{   *pOutLenBit = n*8;   }
				if (n == 0)
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
8000553c:	ec 05 01 08 	sub	r8,r6,r5
80005540:	e8 08 19 00 	cp.h	r8,r4
80005544:	cf 83       	brcs	80005534 <PcdComMF522+0x11c>
		{   status = MI_ERR;   }
		
	}
	

	SetBitMask(ControlReg,0x80);           // stop timer now
80005546:	e0 6b 00 80 	mov	r11,128
8000554a:	30 cc       	mov	r12,12
8000554c:	f0 1f 00 0f 	mcall	80005588 <PcdComMF522+0x170>
	WriteRawRC(CommandReg,PCD_IDLE);
80005550:	30 0b       	mov	r11,0
80005552:	30 1c       	mov	r12,1
80005554:	f0 1f 00 0b 	mcall	80005580 <PcdComMF522+0x168>
	return status;
}
80005558:	0e 9c       	mov	r12,r7
8000555a:	2f fd       	sub	sp,-4
8000555c:	d8 32       	popm	r0-r7,pc
	{
		n = ReadRawRC(ComIrqReg);
		i--;
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
	ClearBitMask(BitFramingReg,0x80);
8000555e:	e0 6b 00 80 	mov	r11,128
80005562:	30 dc       	mov	r12,13
80005564:	f0 1f 00 08 	mcall	80005584 <PcdComMF522+0x16c>

	if (i!=0)
	{
		if(!(ReadRawRC(ErrorReg)&0x1B))
80005568:	30 6c       	mov	r12,6
8000556a:	f0 1f 00 09 	mcall	8000558c <PcdComMF522+0x174>
8000556e:	e2 1c 00 1b 	andl	r12,0x1b,COH
80005572:	cb 80       	breq	800054e2 <PcdComMF522+0xca>
80005574:	30 27       	mov	r7,2
80005576:	ce 8b       	rjmp	80005546 <PcdComMF522+0x12e>
80005578:	80 00       	ld.sh	r0,r0[0x0]
8000557a:	e8 04       	*unknown*
8000557c:	80 00       	ld.sh	r0,r0[0x0]
8000557e:	e8 08       	*unknown*
80005580:	80 00       	ld.sh	r0,r0[0x0]
80005582:	52 68       	stdsp	sp[0x98],r8
80005584:	80 00       	ld.sh	r0,r0[0x0]
80005586:	53 f0       	stdsp	sp[0xfc],r0
80005588:	80 00       	ld.sh	r0,r0[0x0]
8000558a:	53 cc       	stdsp	sp[0xf0],r12
8000558c:	80 00       	ld.sh	r0,r0[0x0]
8000558e:	53 28       	stdsp	sp[0xc8],r8

80005590 <PcdAnticoll>:
//    斤插叉
//拌存: pSnr[OUT]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdAnticoll(U8 *pSnr)
{
80005590:	eb cd 40 c0 	pushm	r6-r7,lr
80005594:	20 5d       	sub	sp,20
80005596:	18 96       	mov	r6,r12
	U8   i,snr_check=0;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];
	

	ClearBitMask(Status2Reg,0x08);
80005598:	30 8b       	mov	r11,8
8000559a:	16 9c       	mov	r12,r11
8000559c:	f0 1f 00 1a 	mcall	80005604 <PcdAnticoll+0x74>
	WriteRawRC(BitFramingReg,0x00);
800055a0:	30 0b       	mov	r11,0
800055a2:	30 dc       	mov	r12,13
800055a4:	f0 1f 00 19 	mcall	80005608 <PcdAnticoll+0x78>
	ClearBitMask(CollReg,0x80);
800055a8:	e0 6b 00 80 	mov	r11,128
800055ac:	30 ec       	mov	r12,14
800055ae:	f0 1f 00 16 	mcall	80005604 <PcdAnticoll+0x74>
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
800055b2:	39 38       	mov	r8,-109
800055b4:	ba 88       	st.b	sp[0x0],r8
	ucComMF522Buf[1] = 0x20;
800055b6:	32 08       	mov	r8,32
800055b8:	ba 98       	st.b	sp[0x1],r8

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,2,ucComMF522Buf,&unLen);
800055ba:	1a 9b       	mov	r11,sp
800055bc:	fa c8 ff ed 	sub	r8,sp,-19
800055c0:	1a 99       	mov	r9,sp
800055c2:	30 2a       	mov	r10,2
800055c4:	30 cc       	mov	r12,12
800055c6:	f0 1f 00 12 	mcall	8000560c <PcdAnticoll+0x7c>
800055ca:	18 97       	mov	r7,r12

	if (status == MI_OK)
800055cc:	c1 21       	brne	800055f0 <PcdAnticoll+0x60>
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
800055ce:	1b 89       	ld.ub	r9,sp[0x0]
800055d0:	ac 89       	st.b	r6[0x0],r9
800055d2:	1b 98       	ld.ub	r8,sp[0x1]
800055d4:	ac 98       	st.b	r6[0x1],r8
			snr_check ^= ucComMF522Buf[i];
800055d6:	10 59       	eor	r9,r8

	if (status == MI_OK)
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
800055d8:	1b a8       	ld.ub	r8,sp[0x2]
800055da:	ac a8       	st.b	r6[0x2],r8
			snr_check ^= ucComMF522Buf[i];
800055dc:	f3 e8 20 08 	eor	r8,r9,r8

	if (status == MI_OK)
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
800055e0:	1b b9       	ld.ub	r9,sp[0x3]
800055e2:	ac b9       	st.b	r6[0x3],r9
			snr_check ^= ucComMF522Buf[i];
800055e4:	12 58       	eor	r8,r9
		}
		if (snr_check != ucComMF522Buf[i])
800055e6:	1b c9       	ld.ub	r9,sp[0x4]
800055e8:	f0 09 18 00 	cp.b	r9,r8
800055ec:	f9 b7 01 02 	movne	r7,2
		{   status = MI_ERR;    }
	}
	
	SetBitMask(CollReg,0x80);
800055f0:	e0 6b 00 80 	mov	r11,128
800055f4:	30 ec       	mov	r12,14
800055f6:	f0 1f 00 07 	mcall	80005610 <PcdAnticoll+0x80>
	return status;
}
800055fa:	0e 9c       	mov	r12,r7
800055fc:	2f bd       	sub	sp,-20
800055fe:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005602:	00 00       	add	r0,r0
80005604:	80 00       	ld.sh	r0,r0[0x0]
80005606:	53 f0       	stdsp	sp[0xfc],r0
80005608:	80 00       	ld.sh	r0,r0[0x0]
8000560a:	52 68       	stdsp	sp[0x98],r8
8000560c:	80 00       	ld.sh	r0,r0[0x0]
8000560e:	54 18       	stdsp	sp[0x104],r8
80005610:	80 00       	ld.sh	r0,r0[0x0]
80005612:	53 cc       	stdsp	sp[0xf0],r12

80005614 <PcdRequest>:
//                0x0800 = Mifare_Pro(X)
//                0x4403 = Mifare_DESFire
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdRequest(U8   req_code,U8 *pTagType)
{
80005614:	eb cd 40 c0 	pushm	r6-r7,lr
80005618:	20 5d       	sub	sp,20
8000561a:	18 97       	mov	r7,r12
8000561c:	16 96       	mov	r6,r11
	char   status;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];

	ClearBitMask(Status2Reg,0x08);
8000561e:	30 8b       	mov	r11,8
80005620:	16 9c       	mov	r12,r11
80005622:	f0 1f 00 12 	mcall	80005668 <PcdRequest+0x54>
	WriteRawRC(BitFramingReg,0x07);
80005626:	30 7b       	mov	r11,7
80005628:	30 dc       	mov	r12,13
8000562a:	f0 1f 00 11 	mcall	8000566c <PcdRequest+0x58>
	SetBitMask(TxControlReg,0x03);
8000562e:	30 3b       	mov	r11,3
80005630:	31 4c       	mov	r12,20
80005632:	f0 1f 00 10 	mcall	80005670 <PcdRequest+0x5c>
	
	ucComMF522Buf[0] = req_code;
80005636:	ba 87       	st.b	sp[0x0],r7

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,1,ucComMF522Buf,&unLen);
80005638:	1a 9b       	mov	r11,sp
8000563a:	fa c8 ff ed 	sub	r8,sp,-19
8000563e:	1a 99       	mov	r9,sp
80005640:	30 1a       	mov	r10,1
80005642:	30 cc       	mov	r12,12
80005644:	f0 1f 00 0c 	mcall	80005674 <PcdRequest+0x60>

	if ((status == MI_OK) && (unLen == 0x10))
80005648:	c0 c1       	brne	80005660 <PcdRequest+0x4c>
8000564a:	31 08       	mov	r8,16
8000564c:	fb 39 00 13 	ld.ub	r9,sp[19]
80005650:	f0 09 18 00 	cp.b	r9,r8
80005654:	c0 61       	brne	80005660 <PcdRequest+0x4c>
	{
		*pTagType     = ucComMF522Buf[0];
80005656:	1b 88       	ld.ub	r8,sp[0x0]
80005658:	ac 88       	st.b	r6[0x0],r8
		*(pTagType+1) = ucComMF522Buf[1];
8000565a:	1b 98       	ld.ub	r8,sp[0x1]
8000565c:	ac 98       	st.b	r6[0x1],r8
	
	ucComMF522Buf[0] = req_code;

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,1,ucComMF522Buf,&unLen);

	if ((status == MI_OK) && (unLen == 0x10))
8000565e:	c0 28       	rjmp	80005662 <PcdRequest+0x4e>
80005660:	30 2c       	mov	r12,2
	}
	else
	{   status = MI_ERR;   }
	
	return status;
}
80005662:	2f bd       	sub	sp,-20
80005664:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005668:	80 00       	ld.sh	r0,r0[0x0]
8000566a:	53 f0       	stdsp	sp[0xfc],r0
8000566c:	80 00       	ld.sh	r0,r0[0x0]
8000566e:	52 68       	stdsp	sp[0x98],r8
80005670:	80 00       	ld.sh	r0,r0[0x0]
80005672:	53 cc       	stdsp	sp[0xf0],r12
80005674:	80 00       	ld.sh	r0,r0[0x0]
80005676:	54 18       	stdsp	sp[0x104],r8

80005678 <CalulateCRC>:

/////////////////////////////////////////////////////////////////////
//MF522璁＄CRC16芥
/////////////////////////////////////////////////////////////////////
void CalulateCRC(U8 *pIn ,U8   len,U8 *pOut )
{
80005678:	eb cd 40 f8 	pushm	r3-r7,lr
8000567c:	18 95       	mov	r5,r12
8000567e:	16 96       	mov	r6,r11
80005680:	14 93       	mov	r3,r10
	U8   i,n;
	ClearBitMask(DivIrqReg,0x04);
80005682:	30 4b       	mov	r11,4
80005684:	30 5c       	mov	r12,5
80005686:	f0 1f 00 1c 	mcall	800056f4 <CalulateCRC+0x7c>
	WriteRawRC(CommandReg,PCD_IDLE);
8000568a:	30 0b       	mov	r11,0
8000568c:	30 1c       	mov	r12,1
8000568e:	f0 1f 00 1b 	mcall	800056f8 <CalulateCRC+0x80>
	SetBitMask(FIFOLevelReg,0x80);
80005692:	e0 6b 00 80 	mov	r11,128
80005696:	30 ac       	mov	r12,10
80005698:	f0 1f 00 19 	mcall	800056fc <CalulateCRC+0x84>
	for (i=0; i<len; i++)
8000569c:	58 06       	cp.w	r6,0
8000569e:	c0 c0       	breq	800056b6 <CalulateCRC+0x3e>
800056a0:	0a 97       	mov	r7,r5
	{   WriteRawRC(FIFODataReg, *(pIn +i));   }
800056a2:	30 94       	mov	r4,9
800056a4:	0f 3b       	ld.ub	r11,r7++
800056a6:	08 9c       	mov	r12,r4
800056a8:	f0 1f 00 14 	mcall	800056f8 <CalulateCRC+0x80>
{
	U8   i,n;
	ClearBitMask(DivIrqReg,0x04);
	WriteRawRC(CommandReg,PCD_IDLE);
	SetBitMask(FIFOLevelReg,0x80);
	for (i=0; i<len; i++)
800056ac:	0e 98       	mov	r8,r7
800056ae:	0a 18       	sub	r8,r5
800056b0:	ec 08 18 00 	cp.b	r8,r6
800056b4:	cf 83       	brcs	800056a4 <CalulateCRC+0x2c>
	{   WriteRawRC(FIFODataReg, *(pIn +i));   }
	WriteRawRC(CommandReg, PCD_CALCCRC);
800056b6:	30 3b       	mov	r11,3
800056b8:	30 1c       	mov	r12,1
800056ba:	f0 1f 00 10 	mcall	800056f8 <CalulateCRC+0x80>
	i = 0xFF;
	do
	{
		n = ReadRawRC(DivIrqReg);
800056be:	30 5c       	mov	r12,5
800056c0:	f0 1f 00 10 	mcall	80005700 <CalulateCRC+0x88>
800056c4:	e0 67 00 fe 	mov	r7,254
800056c8:	30 56       	mov	r6,5
800056ca:	c0 78       	rjmp	800056d8 <CalulateCRC+0x60>
800056cc:	0c 9c       	mov	r12,r6
800056ce:	f0 1f 00 0d 	mcall	80005700 <CalulateCRC+0x88>
		i--;
800056d2:	20 17       	sub	r7,1
800056d4:	5c 57       	castu.b	r7
	}
	while ((i!=0) && !(n&0x04));
800056d6:	c0 40       	breq	800056de <CalulateCRC+0x66>
800056d8:	e2 1c 00 04 	andl	r12,0x4,COH
800056dc:	cf 80       	breq	800056cc <CalulateCRC+0x54>
	pOut [0] = ReadRawRC(CRCResultRegL);
800056de:	32 2c       	mov	r12,34
800056e0:	f0 1f 00 08 	mcall	80005700 <CalulateCRC+0x88>
800056e4:	a6 8c       	st.b	r3[0x0],r12
	pOut [1] = ReadRawRC(CRCResultRegM);
800056e6:	32 1c       	mov	r12,33
800056e8:	f0 1f 00 06 	mcall	80005700 <CalulateCRC+0x88>
800056ec:	a6 9c       	st.b	r3[0x1],r12
}
800056ee:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
800056f2:	00 00       	add	r0,r0
800056f4:	80 00       	ld.sh	r0,r0[0x0]
800056f6:	53 f0       	stdsp	sp[0xfc],r0
800056f8:	80 00       	ld.sh	r0,r0[0x0]
800056fa:	52 68       	stdsp	sp[0x98],r8
800056fc:	80 00       	ld.sh	r0,r0[0x0]
800056fe:	53 cc       	stdsp	sp[0xf0],r12
80005700:	80 00       	ld.sh	r0,r0[0x0]
80005702:	53 28       	stdsp	sp[0xc8],r8

80005704 <PcdSelect>:
//    斤瀹＄
//拌存: pSnr[IN]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdSelect(U8 *pSnr)
{
80005704:	eb cd 40 80 	pushm	r7,lr
80005708:	20 5d       	sub	sp,20
	char   status;
	U8   i;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
8000570a:	39 38       	mov	r8,-109
8000570c:	ba 88       	st.b	sp[0x0],r8
	ucComMF522Buf[1] = 0x70;
8000570e:	37 08       	mov	r8,112
80005710:	ba 98       	st.b	sp[0x1],r8
	ucComMF522Buf[6] = 0;
80005712:	30 08       	mov	r8,0
80005714:	ba e8       	st.b	sp[0x6],r8
80005716:	fa c8 ff fe 	sub	r8,sp,-2
/////////////////////////////////////////////////////////////////////
//    斤瀹＄
//拌存: pSnr[IN]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdSelect(U8 *pSnr)
8000571a:	fa cb ff fa 	sub	r11,sp,-6
	ucComMF522Buf[0] = PICC_ANTICOLL1;
	ucComMF522Buf[1] = 0x70;
	ucComMF522Buf[6] = 0;
	for (i=0; i<4; i++)
	{
		ucComMF522Buf[i+2] = *(pSnr+i);
8000571e:	19 89       	ld.ub	r9,r12[0x0]
80005720:	10 c9       	st.b	r8++,r9
		ucComMF522Buf[6]  ^= *(pSnr+i);
80005722:	19 3a       	ld.ub	r10,r12++
80005724:	1b e9       	ld.ub	r9,sp[0x6]
80005726:	f5 e9 20 09 	eor	r9,r10,r9
8000572a:	ba e9       	st.b	sp[0x6],r9
	U8   ucComMF522Buf[MAXRLEN];
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
	ucComMF522Buf[1] = 0x70;
	ucComMF522Buf[6] = 0;
	for (i=0; i<4; i++)
8000572c:	16 38       	cp.w	r8,r11
8000572e:	cf 81       	brne	8000571e <PcdSelect+0x1a>
	{
		ucComMF522Buf[i+2] = *(pSnr+i);
		ucComMF522Buf[6]  ^= *(pSnr+i);
	}
	CalulateCRC(ucComMF522Buf,7,&ucComMF522Buf[7]);
80005730:	1a 97       	mov	r7,sp
80005732:	fa ca ff f9 	sub	r10,sp,-7
80005736:	30 7b       	mov	r11,7
80005738:	1a 9c       	mov	r12,sp
8000573a:	f0 1f 00 0d 	mcall	8000576c <PcdSelect+0x68>
	
	ClearBitMask(Status2Reg,0x08);
8000573e:	30 8b       	mov	r11,8
80005740:	16 9c       	mov	r12,r11
80005742:	f0 1f 00 0c 	mcall	80005770 <PcdSelect+0x6c>

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,9,ucComMF522Buf,&unLen);
80005746:	fa c8 ff ed 	sub	r8,sp,-19
8000574a:	1a 99       	mov	r9,sp
8000574c:	30 9a       	mov	r10,9
8000574e:	1a 9b       	mov	r11,sp
80005750:	30 cc       	mov	r12,12
80005752:	f0 1f 00 09 	mcall	80005774 <PcdSelect+0x70>
	
	if ((status == MI_OK) && (unLen == 0x18))
80005756:	c0 71       	brne	80005764 <PcdSelect+0x60>
80005758:	31 88       	mov	r8,24
8000575a:	fb 39 00 13 	ld.ub	r9,sp[19]
8000575e:	f0 09 18 00 	cp.b	r9,r8
80005762:	c0 20       	breq	80005766 <PcdSelect+0x62>
80005764:	30 2c       	mov	r12,2
	{   status = MI_OK;  }
	else
	{   status = MI_ERR;    }

	return status;
}
80005766:	2f bd       	sub	sp,-20
80005768:	e3 cd 80 80 	ldm	sp++,r7,pc
8000576c:	80 00       	ld.sh	r0,r0[0x0]
8000576e:	56 78       	stdsp	sp[0x19c],r8
80005770:	80 00       	ld.sh	r0,r0[0x0]
80005772:	53 f0       	stdsp	sp[0xfc],r0
80005774:	80 00       	ld.sh	r0,r0[0x0]
80005776:	54 18       	stdsp	sp[0x104],r8

80005778 <rfid_auto_reader>:
		//
}

//娴绋锛瀵诲->插叉->->″
U8 rfid_auto_reader(void *card_id)
{
80005778:	eb cd 40 c0 	pushm	r6-r7,lr
8000577c:	18 96       	mov	r6,r12
	U8 status = MI_ERR;
	
	PcdReset();
8000577e:	f0 1f 00 37 	mcall	80005858 <rfid_auto_reader+0xe0>
//while(1){
	status=PcdRequest(PICC_REQALL,	CT);//瀵诲ぉ绾垮哄ㄩㄧ★杩＄绫诲 2瀛
80005782:	4b 7b       	lddpc	r11,8000585c <rfid_auto_reader+0xe4>
80005784:	35 2c       	mov	r12,82
80005786:	f0 1f 00 37 	mcall	80005860 <rfid_auto_reader+0xe8>
8000578a:	18 97       	mov	r7,r12
	if(status!=MI_OK) return status;
8000578c:	c6 31       	brne	80005852 <rfid_auto_reader+0xda>
	//continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
8000578e:	4b 48       	lddpc	r8,8000585c <rfid_auto_reader+0xe4>
80005790:	11 88       	ld.ub	r8,r8[0x0]
80005792:	30 49       	mov	r9,4
80005794:	f2 08 18 00 	cp.b	r8,r9
80005798:	c0 b1       	brne	800057ae <rfid_auto_reader+0x36>
8000579a:	4b 19       	lddpc	r9,8000585c <rfid_auto_reader+0xe4>
8000579c:	13 9a       	ld.ub	r10,r9[0x1]
8000579e:	30 09       	mov	r9,0
800057a0:	f2 0a 18 00 	cp.b	r10,r9
800057a4:	c0 51       	brne	800057ae <rfid_auto_reader+0x36>
		log("MFOne-S50\n");
800057a6:	4b 0c       	lddpc	r12,80005864 <rfid_auto_reader+0xec>
800057a8:	f0 1f 00 30 	mcall	80005868 <rfid_auto_reader+0xf0>
//while(1){
	status=PcdRequest(PICC_REQALL,	CT);//瀵诲ぉ绾垮哄ㄩㄧ★杩＄绫诲 2瀛
	if(status!=MI_OK) return status;
	//continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
800057ac:	c3 c8       	rjmp	80005824 <rfid_auto_reader+0xac>
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
800057ae:	30 29       	mov	r9,2
800057b0:	f2 08 18 00 	cp.b	r8,r9
800057b4:	c0 b1       	brne	800057ca <rfid_auto_reader+0x52>
800057b6:	4a a9       	lddpc	r9,8000585c <rfid_auto_reader+0xe4>
800057b8:	13 9a       	ld.ub	r10,r9[0x1]
800057ba:	30 09       	mov	r9,0
800057bc:	f2 0a 18 00 	cp.b	r10,r9
800057c0:	c0 51       	brne	800057ca <rfid_auto_reader+0x52>
		log("MFOne-S70\n");
800057c2:	4a bc       	lddpc	r12,8000586c <rfid_auto_reader+0xf4>
800057c4:	f0 1f 00 29 	mcall	80005868 <rfid_auto_reader+0xf0>
	if(status!=MI_OK) return status;
	//continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
800057c8:	c2 e8       	rjmp	80005824 <rfid_auto_reader+0xac>
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
800057ca:	34 49       	mov	r9,68
800057cc:	f2 08 18 00 	cp.b	r8,r9
800057d0:	c0 b1       	brne	800057e6 <rfid_auto_reader+0x6e>
800057d2:	4a 39       	lddpc	r9,8000585c <rfid_auto_reader+0xe4>
800057d4:	13 9a       	ld.ub	r10,r9[0x1]
800057d6:	30 09       	mov	r9,0
800057d8:	f2 0a 18 00 	cp.b	r10,r9
800057dc:	c0 51       	brne	800057e6 <rfid_auto_reader+0x6e>
		log("MF-UltraLight\n");
800057de:	4a 5c       	lddpc	r12,80005870 <rfid_auto_reader+0xf8>
800057e0:	f0 1f 00 22 	mcall	80005868 <rfid_auto_reader+0xf0>
	
	if(CT[0]==0x04&&CT[1]==0x00)
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
800057e4:	c2 08       	rjmp	80005824 <rfid_auto_reader+0xac>
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
800057e6:	30 89       	mov	r9,8
800057e8:	f2 08 18 00 	cp.b	r8,r9
800057ec:	c0 b1       	brne	80005802 <rfid_auto_reader+0x8a>
800057ee:	49 c9       	lddpc	r9,8000585c <rfid_auto_reader+0xe4>
800057f0:	13 9a       	ld.ub	r10,r9[0x1]
800057f2:	30 09       	mov	r9,0
800057f4:	f2 0a 18 00 	cp.b	r10,r9
800057f8:	c0 51       	brne	80005802 <rfid_auto_reader+0x8a>
		log("MF-Pro\n");
800057fa:	49 fc       	lddpc	r12,80005874 <rfid_auto_reader+0xfc>
800057fc:	f0 1f 00 1b 	mcall	80005868 <rfid_auto_reader+0xf0>
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
80005800:	c1 28       	rjmp	80005824 <rfid_auto_reader+0xac>
		log("MF-Pro\n");
	else if(CT[0]==0x44&&CT[1]==0x03)
80005802:	34 49       	mov	r9,68
80005804:	f2 08 18 00 	cp.b	r8,r9
80005808:	c0 b1       	brne	8000581e <rfid_auto_reader+0xa6>
8000580a:	49 58       	lddpc	r8,8000585c <rfid_auto_reader+0xe4>
8000580c:	11 99       	ld.ub	r9,r8[0x1]
8000580e:	30 38       	mov	r8,3
80005810:	f0 09 18 00 	cp.b	r9,r8
80005814:	c0 51       	brne	8000581e <rfid_auto_reader+0xa6>
		log("MF Desire\n");
80005816:	49 9c       	lddpc	r12,80005878 <rfid_auto_reader+0x100>
80005818:	f0 1f 00 14 	mcall	80005868 <rfid_auto_reader+0xf0>
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
		log("MF-Pro\n");
	else if(CT[0]==0x44&&CT[1]==0x03)
8000581c:	c0 48       	rjmp	80005824 <rfid_auto_reader+0xac>
		log("MF Desire\n");
	else
		log("Unknown\n");
8000581e:	49 8c       	lddpc	r12,8000587c <rfid_auto_reader+0x104>
80005820:	f0 1f 00 12 	mcall	80005868 <rfid_auto_reader+0xf0>
		
	status=PcdAnticoll(SN);//插叉锛杩＄搴 4瀛
80005824:	49 7c       	lddpc	r12,80005880 <rfid_auto_reader+0x108>
80005826:	f0 1f 00 18 	mcall	80005884 <rfid_auto_reader+0x10c>
8000582a:	18 97       	mov	r7,r12
	if(status!=MI_OK)
8000582c:	c0 60       	breq	80005838 <rfid_auto_reader+0xc0>
	{
		xcmp_IdleTestTone(Tone_Start, Low_Battery_3);//set tone to noticy failure!!!
8000582e:	34 fb       	mov	r11,79
80005830:	30 1c       	mov	r12,1
80005832:	f0 1f 00 16 	mcall	80005888 <rfid_auto_reader+0x110>
		return status;
80005836:	c0 e8       	rjmp	80005852 <rfid_auto_reader+0xda>
		//continue;
	}
	
	//memcpy(MLastSelectedSnr,&RevBuffer[2],4);
	status=PcdSelect(SN);//
80005838:	49 2c       	lddpc	r12,80005880 <rfid_auto_reader+0x108>
8000583a:	f0 1f 00 15 	mcall	8000588c <rfid_auto_reader+0x114>
8000583e:	18 97       	mov	r7,r12
	if(status!=MI_OK)return status;
80005840:	c0 91       	brne	80005852 <rfid_auto_reader+0xda>
	//continue;
	else{//℃
			
		memcpy(card_id, SN, 4);
80005842:	30 4a       	mov	r10,4
80005844:	48 fb       	lddpc	r11,80005880 <rfid_auto_reader+0x108>
80005846:	0c 9c       	mov	r12,r6
80005848:	f0 1f 00 12 	mcall	80005890 <rfid_auto_reader+0x118>
		log("select okay\n");
8000584c:	49 2c       	lddpc	r12,80005894 <rfid_auto_reader+0x11c>
8000584e:	f0 1f 00 07 	mcall	80005868 <rfid_auto_reader+0xf0>
		return status;	
	}
	
//}
	
}
80005852:	0e 9c       	mov	r12,r7
80005854:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005858:	80 00       	ld.sh	r0,r0[0x0]
8000585a:	52 a8       	stdsp	sp[0xa8],r8
8000585c:	00 00       	add	r0,r0
8000585e:	97 b4       	st.w	r11[0x2c],r4
80005860:	80 00       	ld.sh	r0,r0[0x0]
80005862:	56 14       	stdsp	sp[0x184],r4
80005864:	80 00       	ld.sh	r0,r0[0x0]
80005866:	e8 0c       	*unknown*
80005868:	80 00       	ld.sh	r0,r0[0x0]
8000586a:	7d ec       	ld.w	r12,lr[0x78]
8000586c:	80 00       	ld.sh	r0,r0[0x0]
8000586e:	e8 18 80 00 	orl	r8,0x8000
80005872:	e8 24 80 00 	sub	r4,557056
80005876:	e8 34 80 00 	sub	r4,622592
8000587a:	e8 3c 80 00 	sub	r12,622592
8000587e:	e8 48 00 00 	cp.w	r8,524288
80005882:	97 b8       	st.w	r11[0x2c],r8
80005884:	80 00       	ld.sh	r0,r0[0x0]
80005886:	55 90       	stdsp	sp[0x164],r0
80005888:	80 00       	ld.sh	r0,r0[0x0]
8000588a:	4a 30       	lddpc	r0,80005914 <scan_rfid_save_message+0x2c>
8000588c:	80 00       	ld.sh	r0,r0[0x0]
8000588e:	57 04       	stdsp	sp[0x1c0],r4
80005890:	80 00       	ld.sh	r0,r0[0x0]
80005892:	86 8e       	ld.uh	lr,r3[0x0]
80005894:	80 00       	ld.sh	r0,r0[0x0]
80005896:	e8 54 eb cd 	cp.w	r4,650189

80005898 <scan_patrol>:
	return return_err;
	
}

U8 scan_patrol(char* SN)
{
80005898:	eb cd 40 80 	pushm	r7,lr
8000589c:	18 97       	mov	r7,r12
	U8 return_err = MI_ERR;
	
	PcdReset();
8000589e:	f0 1f 00 0d 	mcall	800058d0 <scan_patrol+0x38>
	Powerdown_RC522(WAKEUP_RC522);
800058a2:	30 0c       	mov	r12,0
800058a4:	f0 1f 00 0c 	mcall	800058d4 <scan_patrol+0x3c>
	return_err = rfid_auto_reader(SN);
800058a8:	0e 9c       	mov	r12,r7
800058aa:	f0 1f 00 0c 	mcall	800058d8 <scan_patrol+0x40>
800058ae:	18 97       	mov	r7,r12
	Powerdown_RC522(ENTER_POWERDOWN);
800058b0:	30 1c       	mov	r12,1
800058b2:	f0 1f 00 09 	mcall	800058d4 <scan_patrol+0x3c>
	if(return_err == 0)
800058b6:	58 07       	cp.w	r7,0
800058b8:	c0 51       	brne	800058c2 <scan_patrol+0x2a>
		log("scan_patrol okay!\n");
800058ba:	48 9c       	lddpc	r12,800058dc <scan_patrol+0x44>
800058bc:	f0 1f 00 09 	mcall	800058e0 <scan_patrol+0x48>
800058c0:	c0 48       	rjmp	800058c8 <scan_patrol+0x30>
	else
		log("scan_patrol err!\n");
800058c2:	48 9c       	lddpc	r12,800058e4 <scan_patrol+0x4c>
800058c4:	f0 1f 00 07 	mcall	800058e0 <scan_patrol+0x48>
		
	return return_err;

}
800058c8:	0e 9c       	mov	r12,r7
800058ca:	e3 cd 80 80 	ldm	sp++,r7,pc
800058ce:	00 00       	add	r0,r0
800058d0:	80 00       	ld.sh	r0,r0[0x0]
800058d2:	52 a8       	stdsp	sp[0xa8],r8
800058d4:	80 00       	ld.sh	r0,r0[0x0]
800058d6:	53 80       	stdsp	sp[0xe0],r0
800058d8:	80 00       	ld.sh	r0,r0[0x0]
800058da:	57 78       	stdsp	sp[0x1dc],r8
800058dc:	80 00       	ld.sh	r0,r0[0x0]
800058de:	e8 64 80 00 	mov	r4,557056
800058e2:	7d ec       	ld.w	r12,lr[0x78]
800058e4:	80 00       	ld.sh	r0,r0[0x0]
800058e6:	e8 78 eb cd 	mov	r8,650189

800058e8 <scan_rfid_save_message>:

extern volatile DateTime_t Current_time;
/*the queue is used to receive failure-send message*/

U8 scan_rfid_save_message()
{
800058e8:	eb cd 40 e0 	pushm	r5-r7,lr
800058ec:	21 dd       	sub	sp,116
	static U8 start_session = 0x80;
	Message_Header_t header;
	Message_Data_t data_buffer;//22bytes
	
	//memset(data_buffer, 0x00, 16);
	memset(SN, 0x00, 10);
800058ee:	4e 9c       	lddpc	r12,80005a90 <scan_rfid_save_message+0x1a8>
800058f0:	30 08       	mov	r8,0
800058f2:	30 09       	mov	r9,0
800058f4:	f8 e9 00 00 	st.d	r12[0],r8
800058f8:	30 0a       	mov	r10,0
800058fa:	b8 4a       	st.h	r12[0x8],r10
	memset(message, 0x00, 80);
800058fc:	fa e9 00 24 	st.d	sp[36],r8
80005900:	fa e9 00 2c 	st.d	sp[44],r8
80005904:	fa e9 00 34 	st.d	sp[52],r8
80005908:	fa e9 00 3c 	st.d	sp[60],r8
8000590c:	fa e9 00 44 	st.d	sp[68],r8
80005910:	fa e9 00 4c 	st.d	sp[76],r8
80005914:	fa e9 00 54 	st.d	sp[84],r8
80005918:	fa e9 00 5c 	st.d	sp[92],r8
8000591c:	fa e9 00 64 	st.d	sp[100],r8
80005920:	fa e9 00 6c 	st.d	sp[108],r8
	
	return_err = scan_patrol(SN);
80005924:	f0 1f 00 5c 	mcall	80005a94 <scan_rfid_save_message+0x1ac>
80005928:	18 97       	mov	r7,r12
	
	if(return_err == 0){
8000592a:	e0 81 00 a7 	brne	80005a78 <scan_rfid_save_message+0x190>
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
8000592e:	4d 96       	lddpc	r6,80005a90 <scan_rfid_save_message+0x1a8>
80005930:	0d b8       	ld.ub	r8,r6[0x3]
80005932:	1a d8       	st.w	--sp,r8
80005934:	0d a8       	ld.ub	r8,r6[0x2]
80005936:	1a d8       	st.w	--sp,r8
80005938:	0d 98       	ld.ub	r8,r6[0x1]
8000593a:	1a d8       	st.w	--sp,r8
8000593c:	0d 88       	ld.ub	r8,r6[0x0]
8000593e:	1a d8       	st.w	--sp,r8
80005940:	4d 6c       	lddpc	r12,80005a98 <scan_rfid_save_message+0x1b0>
80005942:	f0 1f 00 57 	mcall	80005a9c <scan_rfid_save_message+0x1b4>
		xcmp_IdleTestTone(Tone_Start, Ring_Style_Tone_8);//set tone to indicate scan rfid success!!!
80005946:	34 4b       	mov	r11,68
80005948:	30 1c       	mov	r12,1
8000594a:	f0 1f 00 56 	mcall	80005aa0 <scan_rfid_save_message+0x1b8>
8000594e:	fa c8 ff ec 	sub	r8,sp,-20
80005952:	fa c9 ff ea 	sub	r9,sp,-22
}

extern volatile DateTime_t Current_time;
/*the queue is used to receive failure-send message*/

U8 scan_rfid_save_message()
80005956:	ec c5 ff fc 	sub	r5,r6,-4
8000595a:	2f cd       	sub	sp,-16
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, Ring_Style_Tone_8);//set tone to indicate scan rfid success!!!
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″
			
			temp = ((SN[i] & 0xF0) >> 4);//瀛楂浣
			if((temp >= 0) && (temp <= 9))data_buffer.RFID_ID[i*4] = temp+0x30;
8000595c:	30 9e       	mov	lr,9
			else
			data_buffer.RFID_ID[i*4] = ((temp - 0x0a)+0x61);
			
			data_buffer.RFID_ID[i*4+1] = 0x00;
8000595e:	30 0c       	mov	r12,0
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, Ring_Style_Tone_8);//set tone to indicate scan rfid success!!!
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″
			
			temp = ((SN[i] & 0xF0) >> 4);//瀛楂浣
80005960:	0d 8a       	ld.ub	r10,r6[0x0]
80005962:	f4 0b 16 04 	lsr	r11,r10,0x4
			if((temp >= 0) && (temp <= 9))data_buffer.RFID_ID[i*4] = temp+0x30;
80005966:	fc 0b 18 00 	cp.b	r11,lr
8000596a:	f7 bb 08 d0 	subls	r11,-48
8000596e:	f1 fb 8e 00 	st.bls	r8[0x0],r11
			else
			data_buffer.RFID_ID[i*4] = ((temp - 0x0a)+0x61);
80005972:	f7 bb 0b a9 	subhi	r11,-87
80005976:	f1 fb be 00 	st.bhi	r8[0x0],r11
			
			data_buffer.RFID_ID[i*4+1] = 0x00;
8000597a:	b0 9c       	st.b	r8[0x1],r12
			
			temp = (SN[i] & 0x0F);//瀛浣浣
8000597c:	f5 da c0 04 	bfextu	r10,r10,0x0,0x4
			if((temp >= 0) && (temp <= 9))data_buffer.RFID_ID[i*4+2] = temp+0x30;
80005980:	fc 0a 18 00 	cp.b	r10,lr
80005984:	f7 ba 08 d0 	subls	r10,-48
80005988:	f3 fa 8e 00 	st.bls	r9[0x0],r10
			else
			data_buffer.RFID_ID[i*4+2] = ((temp - 0x0a)+0x61);
8000598c:	f7 ba 0b a9 	subhi	r10,-87
80005990:	f3 fa be 00 	st.bhi	r9[0x0],r10

			data_buffer.RFID_ID[i*4+3] = 0x00;
80005994:	b0 bc       	st.b	r8[0x3],r12
80005996:	2f f6       	sub	r6,-1
80005998:	2f c8       	sub	r8,-4
8000599a:	2f c9       	sub	r9,-4
	
	if(return_err == 0){
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, Ring_Style_Tone_8);//set tone to indicate scan rfid success!!!
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″
8000599c:	0a 36       	cp.w	r6,r5
8000599e:	ce 11       	brne	80005960 <scan_rfid_save_message+0x78>
			data_buffer.RFID_ID[i*4+2] = ((temp - 0x0a)+0x61);

			data_buffer.RFID_ID[i*4+3] = 0x00;
		}
		
		memcpy(&data_buffer.XG_Time.Year, &Current_time.Year, sizeof(DateTime_t))	;
800059a0:	30 6a       	mov	r10,6
800059a2:	4c 1b       	lddpc	r11,80005aa4 <scan_rfid_save_message+0x1bc>
800059a4:	fa cc ff ec 	sub	r12,sp,-20
800059a8:	f0 1f 00 40 	mcall	80005aa8 <scan_rfid_save_message+0x1c0>
		
		header.length = (0x0008 + sizeof(Message_Data_t));
		
		if(start_session > 0x9f)start_session = 0x80;
800059ac:	4c 08       	lddpc	r8,80005aac <scan_rfid_save_message+0x1c4>
800059ae:	11 89       	ld.ub	r9,r8[0x0]
800059b0:	39 f8       	mov	r8,-97
800059b2:	f0 09 18 00 	cp.b	r9,r8
800059b6:	e0 88 00 05 	brls	800059c0 <scan_rfid_save_message+0xd8>
800059ba:	38 09       	mov	r9,-128
800059bc:	4b c8       	lddpc	r8,80005aac <scan_rfid_save_message+0x1c4>
800059be:	b0 89       	st.b	r8[0x0],r9
		
		header.session_id = (++start_session);
800059c0:	4b b8       	lddpc	r8,80005aac <scan_rfid_save_message+0x1c4>
800059c2:	11 86       	ld.ub	r6,r8[0x0]
800059c4:	2f f6       	sub	r6,-1
800059c6:	5c 56       	castu.b	r6
800059c8:	b0 86       	st.b	r8[0x0],r6
		
		memcpy(&header.fixed_data[0], unsure_data, sizeof(unsure_data));
800059ca:	30 5a       	mov	r10,5
800059cc:	4b 9b       	lddpc	r11,80005ab0 <scan_rfid_save_message+0x1c8>
800059ce:	fa cc ff e1 	sub	r12,sp,-31
800059d2:	f0 1f 00 36 	mcall	80005aa8 <scan_rfid_save_message+0x1c0>
		header.type = 0xe000;
		
		memcpy(message, &header, sizeof(Message_Header_t));//疯header版
800059d6:	31 e8       	mov	r8,30
800059d8:	fb 58 00 1a 	st.h	sp[26],r8
800059dc:	fb 66 00 1e 	st.b	sp[30],r6
800059e0:	fe 78 e0 00 	mov	r8,-8192
800059e4:	fb 58 00 1c 	st.h	sp[28],r8
800059e8:	30 aa       	mov	r10,10
800059ea:	fa cb ff e6 	sub	r11,sp,-26
800059ee:	fa cc ff dc 	sub	r12,sp,-36
800059f2:	f0 1f 00 2e 	mcall	80005aa8 <scan_rfid_save_message+0x1c0>
		memcpy(&message[sizeof(Message_Header_t)], &data_buffer, sizeof(Message_Data_t));//疯淇″瀹规版
800059f6:	31 6a       	mov	r10,22
800059f8:	fa cb ff fc 	sub	r11,sp,-4
800059fc:	fa cc ff d2 	sub	r12,sp,-46
80005a00:	f0 1f 00 2a 	mcall	80005aa8 <scan_rfid_save_message+0x1c0>
		
		//xgflash_message_save(message, (sizeof(Message_Header_t)+sizeof(Message_Data_t)), TRUE);
		//xcmp_data_session_req(message, (sizeof(Message_Header_t)+sizeof(Message_Data_t)), destination);
		Message_Protocol_t * myptr = get_message_store();
80005a04:	4a c8       	lddpc	r8,80005ab4 <scan_rfid_save_message+0x1cc>
80005a06:	70 0c       	ld.w	r12,r8[0x0]
80005a08:	f0 1f 00 2c 	mcall	80005ab8 <scan_rfid_save_message+0x1d0>
80005a0c:	50 0c       	stdsp	sp[0x0],r12
		if(NULL != myptr)
80005a0e:	c3 10       	breq	80005a70 <scan_rfid_save_message+0x188>
		{
			memcpy(myptr, message, sizeof(Message_Protocol_t));
80005a10:	32 0a       	mov	r10,32
80005a12:	fa cb ff dc 	sub	r11,sp,-36
80005a16:	f0 1f 00 25 	mcall	80005aa8 <scan_rfid_save_message+0x1c0>
			//xQueueSend(xg_resend_queue, &myptr, 0);
			if (xQueueSend(xg_resend_queue, &myptr, 0) != pdPASS)
80005a1a:	4a 98       	lddpc	r8,80005abc <scan_rfid_save_message+0x1d4>
80005a1c:	70 0c       	ld.w	r12,r8[0x0]
80005a1e:	30 09       	mov	r9,0
80005a20:	12 9a       	mov	r10,r9
80005a22:	1a 9b       	mov	r11,sp
80005a24:	f0 1f 00 27 	mcall	80005ac0 <scan_rfid_save_message+0x1d8>
80005a28:	58 1c       	cp.w	r12,1
80005a2a:	c1 10       	breq	80005a4c <scan_rfid_save_message+0x164>
			{
				log("xg_resend_queue: full\n" );
80005a2c:	4a 6c       	lddpc	r12,80005ac4 <scan_rfid_save_message+0x1dc>
80005a2e:	f0 1f 00 1c 	mcall	80005a9c <scan_rfid_save_message+0x1b4>
				xcmp_IdleTestTone(Tone_Start, Dispatch_Busy);//set tone to indicate queue full!!!
80005a32:	32 3b       	mov	r11,35
80005a34:	30 1c       	mov	r12,1
80005a36:	f0 1f 00 1b 	mcall	80005aa0 <scan_rfid_save_message+0x1b8>
				vTaskDelay(3000*2 / portTICK_RATE_MS);//寤惰3000ms
80005a3a:	e0 6c 17 70 	mov	r12,6000
80005a3e:	f0 1f 00 23 	mcall	80005ac8 <scan_rfid_save_message+0x1e0>
				xcmp_IdleTestTone(Tone_Stop, Dispatch_Busy);//set tone to indicate queue full!!!
80005a42:	32 3b       	mov	r11,35
80005a44:	30 0c       	mov	r12,0
80005a46:	f0 1f 00 17 	mcall	80005aa0 <scan_rfid_save_message+0x1b8>
80005a4a:	c1 e8       	rjmp	80005a86 <scan_rfid_save_message+0x19e>
			}
			else
			{
				xSemaphoreTake(count_mutex, portMAX_DELAY);
80005a4c:	4a 06       	lddpc	r6,80005acc <scan_rfid_save_message+0x1e4>
80005a4e:	6c 0c       	ld.w	r12,r6[0x0]
80005a50:	30 09       	mov	r9,0
80005a52:	3f fa       	mov	r10,-1
80005a54:	12 9b       	mov	r11,r9
80005a56:	f0 1f 00 1f 	mcall	80005ad0 <scan_rfid_save_message+0x1e8>
				global_count++;
80005a5a:	49 f8       	lddpc	r8,80005ad4 <scan_rfid_save_message+0x1ec>
80005a5c:	70 09       	ld.w	r9,r8[0x0]
80005a5e:	2f f9       	sub	r9,-1
80005a60:	91 09       	st.w	r8[0x0],r9
				xSemaphoreGive(count_mutex);
80005a62:	6c 0c       	ld.w	r12,r6[0x0]
80005a64:	30 09       	mov	r9,0
80005a66:	12 9a       	mov	r10,r9
80005a68:	12 9b       	mov	r11,r9
80005a6a:	f0 1f 00 16 	mcall	80005ac0 <scan_rfid_save_message+0x1d8>
80005a6e:	c0 c8       	rjmp	80005a86 <scan_rfid_save_message+0x19e>
			}
		}
		else
		{
			log("myptr: err\n\r" );
80005a70:	49 ac       	lddpc	r12,80005ad8 <scan_rfid_save_message+0x1f0>
80005a72:	f0 1f 00 0b 	mcall	80005a9c <scan_rfid_save_message+0x1b4>
80005a76:	c0 88       	rjmp	80005a86 <scan_rfid_save_message+0x19e>
		
		
	}
	else
	{
		xcmp_IdleTestTone(Tone_Start, Low_Battery_3);//set tone to indicate scan rfid failure!!!
80005a78:	34 fb       	mov	r11,79
80005a7a:	30 1c       	mov	r12,1
80005a7c:	f0 1f 00 09 	mcall	80005aa0 <scan_rfid_save_message+0x1b8>
		log("no card find...\n");
80005a80:	49 7c       	lddpc	r12,80005adc <scan_rfid_save_message+0x1f4>
80005a82:	f0 1f 00 07 	mcall	80005a9c <scan_rfid_save_message+0x1b4>
	}
	
	return return_err;
	

}
80005a86:	0e 9c       	mov	r12,r7
80005a88:	2e 3d       	sub	sp,-116
80005a8a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80005a8e:	00 00       	add	r0,r0
80005a90:	00 00       	add	r0,r0
80005a92:	0b 7c       	ld.ub	r12,--r5
80005a94:	80 00       	ld.sh	r0,r0[0x0]
80005a96:	58 98       	cp.w	r8,9
80005a98:	80 00       	ld.sh	r0,r0[0x0]
80005a9a:	e8 8c 80 00 	brvs	80115a9a <_data_lma+0x10664a>
80005a9e:	7d ec       	ld.w	r12,lr[0x78]
80005aa0:	80 00       	ld.sh	r0,r0[0x0]
80005aa2:	4a 30       	lddpc	r0,80005b2c <local_start_pll0+0x8>
80005aa4:	00 00       	add	r0,r0
80005aa6:	0e 1c       	sub	r12,r7
80005aa8:	80 00       	ld.sh	r0,r0[0x0]
80005aaa:	86 8e       	ld.uh	lr,r3[0x0]
80005aac:	00 00       	add	r0,r0
80005aae:	05 3c       	ld.ub	r12,r2++
80005ab0:	00 00       	add	r0,r0
80005ab2:	05 34       	ld.ub	r4,r2++
80005ab4:	00 00       	add	r0,r0
80005ab6:	0b 98       	ld.ub	r8,r5[0x1]
80005ab8:	80 00       	ld.sh	r0,r0[0x0]
80005aba:	37 6c       	mov	r12,118
80005abc:	00 00       	add	r0,r0
80005abe:	0b 88       	ld.ub	r8,r5[0x0]
80005ac0:	80 00       	ld.sh	r0,r0[0x0]
80005ac2:	71 b4       	ld.w	r4,r8[0x6c]
80005ac4:	80 00       	ld.sh	r0,r0[0x0]
80005ac6:	e6 cc 80 00 	sub	r12,r3,-32768
80005aca:	78 80       	ld.w	r0,r12[0x20]
80005acc:	00 00       	add	r0,r0
80005ace:	0a 78       	tst	r8,r5
80005ad0:	80 00       	ld.sh	r0,r0[0x0]
80005ad2:	6f a8       	ld.w	r8,r7[0x68]
80005ad4:	00 00       	add	r0,r0
80005ad6:	0a 80       	andn	r0,r5
80005ad8:	80 00       	ld.sh	r0,r0[0x0]
80005ada:	e6 e4 80 00 	ld.d	r4,r3[-32768]
80005ade:	e8 a8       	*unknown*

80005ae0 <delay_ns>:
}

void delay_ns(U32 ns)
{
	U32 i;
	for(i=0;i<ns;i++)
80005ae0:	58 0c       	cp.w	r12,0
80005ae2:	5e 0c       	reteq	r12
80005ae4:	30 08       	mov	r8,0
	{
		nop();
80005ae6:	d7 03       	nop
		nop();
80005ae8:	d7 03       	nop
		nop();
80005aea:	d7 03       	nop
}

void delay_ns(U32 ns)
{
	U32 i;
	for(i=0;i<ns;i++)
80005aec:	2f f8       	sub	r8,-1
80005aee:	10 3c       	cp.w	r12,r8
80005af0:	fe 9b ff fb 	brhi	80005ae6 <delay_ns+0x6>
80005af4:	5e fc       	retal	r12
80005af6:	d7 03       	nop

80005af8 <local_start_timer>:
//	SSC_TX_DATA_ENABLE		AVR32_TC_A0_0_0_PIN					[32 PortB Pin  0 00000001 Func 0]
//	MAKO_TX					AVR32_SSC_TX_DATA_0_PIN				[42 PortB Pin 10 00000400 Func 0]
//	MAKO_RX					AVR32_SSC_RX_DATA_0_PIN				[39 PortB Pin  7 00000080 Func 0]
//
void local_start_timer(void)
{
80005af8:	d4 01       	pushm	lr
	{
		{TIMER_TC_CLK_PIN,      TIMER_TC_CLK_FUNCTION     },
		{TIMER_TC_FS_PIN,       TIMER_TC_FS_FUNCTION      },
		{TIMER_EN_CLK_PIN,      TIMER_EN_CLK_FUNCTION     }
	};
	gpio_enable_module(TC_GPIO_MAP, sizeof(TC_GPIO_MAP) / sizeof(TC_GPIO_MAP[0]));
80005afa:	30 3b       	mov	r11,3
80005afc:	48 8c       	lddpc	r12,80005b1c <local_start_timer+0x24>
80005afe:	f0 1f 00 09 	mcall	80005b20 <local_start_timer+0x28>

	(&AVR32_TC)->channel[0].cmr =
80005b02:	fe 78 38 00 	mov	r8,-51200
80005b06:	e0 69 91 0d 	mov	r9,37133
80005b0a:	ea 19 00 52 	orh	r9,0x52
80005b0e:	91 19       	st.w	r8[0x4],r9
	1                          << AVR32_TC_CLKI_OFFSET     |
	AVR32_TC_TCCLKS_XC0        << AVR32_TC_TCCLKS_OFFSET;



	(&AVR32_TC)->channel[0].ra = 32;
80005b10:	32 09       	mov	r9,32
80005b12:	91 59       	st.w	r8[0x14],r9
	(&AVR32_TC)->channel[0].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
80005b14:	30 59       	mov	r9,5
80005b16:	91 09       	st.w	r8[0x0],r9
}
80005b18:	d8 02       	popm	pc
80005b1a:	00 00       	add	r0,r0
80005b1c:	80 00       	ld.sh	r0,r0[0x0]
80005b1e:	e8 bc       	*unknown*
80005b20:	80 00       	ld.sh	r0,r0[0x0]
80005b22:	61 e8       	ld.w	r8,r0[0x78]

80005b24 <local_start_pll0>:
//In the SSC description, Master Clock (MCK) is the bus clock of the peripheral bus to which the
//SSC is connected. [23.6.2]
//Switch to clock Osc0 (crystal)
//start PLL0 and switch main clock to PLL0 output
void local_start_pll0(void)
{
80005b24:	d4 01       	pushm	lr
	AVR32_HMATRIX.mcfg[AVR32_HMATRIX_MASTER_CPU_INSTRUCTION] = 0x1;
	
***/
	
/*****/
	pm_switch_to_osc0(&AVR32_PM, 12000000, OSC0_STARTUP);
80005b26:	30 3a       	mov	r10,3
80005b28:	e0 6b 1b 00 	mov	r11,6912
80005b2c:	ea 1b 00 b7 	orh	r11,0xb7
80005b30:	fe 7c 0c 00 	mov	r12,-62464
80005b34:	f0 1f 00 19 	mcall	80005b98 <local_start_pll0+0x74>

	pm_pll_setup(&AVR32_PM,
80005b38:	31 08       	mov	r8,16
80005b3a:	1a d8       	st.w	--sp,r8
80005b3c:	30 08       	mov	r8,0
80005b3e:	30 19       	mov	r9,1
80005b40:	30 7a       	mov	r10,7
80005b42:	10 9b       	mov	r11,r8
80005b44:	fe 7c 0c 00 	mov	r12,-62464
80005b48:	f0 1f 00 15 	mcall	80005b9c <local_start_pll0+0x78>
	               0,   // use PLL0
	               7,   // MUL=7 in the formula
	               1,   // DIV=1 in the formula
	               0,   // Sel Osc0/PLL0 or Osc1/PLL1
	               16); // lockcount in main clock for the PLL wait lock
	pm_pll_set_option(&AVR32_PM, 0, //PLL number 0
80005b4c:	30 08       	mov	r8,0
80005b4e:	30 19       	mov	r9,1
80005b50:	12 9a       	mov	r10,r9
80005b52:	10 9b       	mov	r11,r8
80005b54:	fe 7c 0c 00 	mov	r12,-62464
80005b58:	f0 1f 00 12 	mcall	80005ba0 <local_start_pll0+0x7c>
	                        1, //freq Set to 1 for VCO frequency range 80-180MHz
	                        1, //div2 Divide the PLL output frequency by 2
	                        0);//0 to enable the Wide-Bandith Mode
	pm_pll_enable(&AVR32_PM,0);
80005b5c:	30 0b       	mov	r11,0
80005b5e:	fe 7c 0c 00 	mov	r12,-62464
80005b62:	f0 1f 00 11 	mcall	80005ba4 <local_start_pll0+0x80>


	pm_wait_for_pll0_locked(&AVR32_PM);
80005b66:	fe 7c 0c 00 	mov	r12,-62464
80005b6a:	f0 1f 00 10 	mcall	80005ba8 <local_start_pll0+0x84>


	pm_cksel(&AVR32_PM, 1,  //Bus A clock divisor enable = 1
80005b6e:	30 0a       	mov	r10,0
80005b70:	1a da       	st.w	--sp,r10
80005b72:	1a da       	st.w	--sp,r10
80005b74:	14 98       	mov	r8,r10
80005b76:	14 99       	mov	r9,r10
80005b78:	30 1b       	mov	r11,1
80005b7a:	fe 7c 0c 00 	mov	r12,-62464
80005b7e:	f0 1f 00 0c 	mcall	80005bac <local_start_pll0+0x88>
	             0,  //B clock divisor enable = 0
	             0,  //Bus B select = 0
	             0,  //HS Bus clock divisor enable = 0
	             0); //HS Bus select = 0
				 
	flashc_set_wait_state(1);
80005b82:	30 1c       	mov	r12,1
80005b84:	f0 1f 00 0b 	mcall	80005bb0 <local_start_pll0+0x8c>
	//AVR32_FLASHC.fcr = 0x00000040;

	pm_switch_to_clock(&AVR32_PM, AVR32_PM_MCSEL_PLL0);
80005b88:	30 2b       	mov	r11,2
80005b8a:	fe 7c 0c 00 	mov	r12,-62464
80005b8e:	f0 1f 00 0a 	mcall	80005bb4 <local_start_pll0+0x90>
80005b92:	2f dd       	sub	sp,-12
/****/
}
80005b94:	d8 02       	popm	pc
80005b96:	00 00       	add	r0,r0
80005b98:	80 00       	ld.sh	r0,r0[0x0]
80005b9a:	64 d8       	ld.w	r8,r2[0x34]
80005b9c:	80 00       	ld.sh	r0,r0[0x0]
80005b9e:	64 7a       	ld.w	r10,r2[0x1c]
80005ba0:	80 00       	ld.sh	r0,r0[0x0]
80005ba2:	64 9c       	ld.w	r12,r2[0x24]
80005ba4:	80 00       	ld.sh	r0,r0[0x0]
80005ba6:	64 b6       	ld.w	r6,r2[0x2c]
80005ba8:	80 00       	ld.sh	r0,r0[0x0]
80005baa:	64 c4       	ld.w	r4,r2[0x30]
80005bac:	80 00       	ld.sh	r0,r0[0x0]
80005bae:	64 34       	ld.w	r4,r2[0xc]
80005bb0:	80 00       	ld.sh	r0,r0[0x0]
80005bb2:	61 88       	ld.w	r8,r0[0x60]
80005bb4:	80 00       	ld.sh	r0,r0[0x0]
80005bb6:	64 ce       	ld.w	lr,r2[0x30]

80005bb8 <xg_flashc_init>:
}


//U16	Current_total_message_count=0;
void xg_flashc_init(void)
{
80005bb8:	d4 31       	pushm	r0-r7,lr
80005bba:	20 3d       	sub	sp,12
	
	/* Create the mutex semaphore to guard a shared xgflash.*/
	xgflash_mutex = xSemaphoreCreateMutex();
80005bbc:	f0 1f 00 8a 	mcall	80005de4 <xg_flashc_init+0x22c>
80005bc0:	fe f8 02 28 	ld.w	r8,pc[552]
80005bc4:	91 0c       	st.w	r8[0x0],r12
	if (xgflash_mutex == NULL)
80005bc6:	70 08       	ld.w	r8,r8[0x0]
80005bc8:	58 08       	cp.w	r8,0
80005bca:	c0 51       	brne	80005bd4 <xg_flashc_init+0x1c>
	{
		log("Create the xgflash_mutex semaphore failure\n");
80005bcc:	fe fc 02 20 	ld.w	r12,pc[544]
80005bd0:	f0 1f 00 88 	mcall	80005df0 <xg_flashc_init+0x238>
	}
	
	/* Create the binary semaphore to Synchronize other threads.*/
	vSemaphoreCreateBinary(xBinarySemaphore);
80005bd4:	30 0b       	mov	r11,0
80005bd6:	30 1c       	mov	r12,1
80005bd8:	f0 1f 00 87 	mcall	80005df4 <xg_flashc_init+0x23c>
80005bdc:	fe f8 02 1c 	ld.w	r8,pc[540]
80005be0:	91 0c       	st.w	r8[0x0],r12
80005be2:	70 08       	ld.w	r8,r8[0x0]
80005be4:	58 08       	cp.w	r8,0
80005be6:	c0 90       	breq	80005bf8 <xg_flashc_init+0x40>
80005be8:	fe f8 02 10 	ld.w	r8,pc[528]
80005bec:	70 0c       	ld.w	r12,r8[0x0]
80005bee:	30 09       	mov	r9,0
80005bf0:	12 9a       	mov	r10,r9
80005bf2:	12 9b       	mov	r11,r9
80005bf4:	f0 1f 00 82 	mcall	80005dfc <xg_flashc_init+0x244>
	if (xBinarySemaphore == NULL)
80005bf8:	fe f8 02 00 	ld.w	r8,pc[512]
80005bfc:	70 08       	ld.w	r8,r8[0x0]
80005bfe:	58 08       	cp.w	r8,0
80005c00:	c0 51       	brne	80005c0a <xg_flashc_init+0x52>
	{
		log("Create the xBinarySemaphore semaphore failure\n");
80005c02:	fe fc 01 fe 	ld.w	r12,pc[510]
80005c06:	f0 1f 00 7b 	mcall	80005df0 <xg_flashc_init+0x238>
	//if (SendM_CountingSemaphore == NULL)
	//{
		//log("Create the SendM_Counting semaphore failure\n");
	//}
	
	xg_resend_queue = xQueueCreate(270, sizeof(U32));
80005c0a:	30 4b       	mov	r11,4
80005c0c:	e0 6c 01 0e 	mov	r12,270
80005c10:	f0 1f 00 79 	mcall	80005df4 <xg_flashc_init+0x23c>
80005c14:	4f c8       	lddpc	r8,80005e04 <xg_flashc_init+0x24c>
80005c16:	91 0c       	st.w	r8[0x0],r12
	/*initialize the queue*/
	message_storage_queue = xQueueCreate(MAX_MESSAGE_STORE, sizeof(U32));
80005c18:	30 4b       	mov	r11,4
80005c1a:	e0 6c 01 2c 	mov	r12,300
80005c1e:	f0 1f 00 76 	mcall	80005df4 <xg_flashc_init+0x23c>
80005c22:	4f a8       	lddpc	r8,80005e08 <xg_flashc_init+0x250>
80005c24:	91 0c       	st.w	r8[0x0],r12
80005c26:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_MESSAGE_STORE; i++ )
	{
		set_message_store(&message_store[i]);//push <message_store> address to the message_storage_queue;
80005c28:	10 96       	mov	r6,r8
80005c2a:	4f 95       	lddpc	r5,80005e0c <xg_flashc_init+0x254>
80005c2c:	6c 0c       	ld.w	r12,r6[0x0]
80005c2e:	ea 07 00 0b 	add	r11,r5,r7
80005c32:	f0 1f 00 78 	mcall	80005e10 <xg_flashc_init+0x258>
80005c36:	2e 07       	sub	r7,-32
	//}
	
	xg_resend_queue = xQueueCreate(270, sizeof(U32));
	/*initialize the queue*/
	message_storage_queue = xQueueCreate(MAX_MESSAGE_STORE, sizeof(U32));
	for(int i= 0; i < MAX_MESSAGE_STORE; i++ )
80005c38:	e0 47 25 80 	cp.w	r7,9600
80005c3c:	cf 81       	brne	80005c2c <xg_flashc_init+0x74>
	{
		set_message_store(&message_store[i]);//push <message_store> address to the message_storage_queue;
	}
	
	
	data_flash_init();//interface
80005c3e:	f0 1f 00 76 	mcall	80005e14 <xg_flashc_init+0x25c>
	df_status_t return_code = DF_OK;
	static U32 current_page_number =0;
	unsigned int i = 0;
	unsigned int address =0x00000000;
	static char str[80];
	memset(str, 0x00, sizeof(str));
80005c42:	30 0a       	mov	r10,0
80005c44:	30 0b       	mov	r11,0
80005c46:	4f 58       	lddpc	r8,80005e18 <xg_flashc_init+0x260>
80005c48:	b1 2a       	st.d	r8++,r10
80005c4a:	b1 2a       	st.d	r8++,r10
80005c4c:	b1 2a       	st.d	r8++,r10
80005c4e:	b1 2a       	st.d	r8++,r10
80005c50:	b1 2a       	st.d	r8++,r10
80005c52:	b1 2a       	st.d	r8++,r10
80005c54:	b1 2a       	st.d	r8++,r10
80005c56:	b1 2a       	st.d	r8++,r10
80005c58:	b1 2a       	st.d	r8++,r10
80005c5a:	f0 eb 00 00 	st.d	r8[0],r10
80005c5e:	30 05       	mov	r5,0
	
start:
	
	 //bytes remained less than one page 
	return_code = data_flash_read_block(LABEL_ADDRESS, LABEL_LENGTH, str);
80005c60:	4e e7       	lddpc	r7,80005e18 <xg_flashc_init+0x260>
			{
				//Calculates the offset address of the current stored message
				if(current_message_index != 0){
					
					log("current_message_index: %d\n", current_message_index);
					memset(str, 0x00, sizeof(str));	
80005c62:	ee c4 ff f8 	sub	r4,r7,-8
80005c66:	e8 c3 ff f8 	sub	r3,r4,-8
80005c6a:	e6 c2 ff f8 	sub	r2,r3,-8
80005c6e:	e4 c1 ff f8 	sub	r1,r2,-8
80005c72:	e2 c0 ff f8 	sub	r0,r1,-8
80005c76:	e0 ca ff f8 	sub	r10,r0,-8
80005c7a:	50 0a       	stdsp	sp[0x0],r10
80005c7c:	2f 8a       	sub	r10,-8
80005c7e:	50 1a       	stdsp	sp[0x4],r10
80005c80:	2f 8a       	sub	r10,-8
80005c82:	50 2a       	stdsp	sp[0x8],r10
	memset(str, 0x00, sizeof(str));
	
start:
	
	 //bytes remained less than one page 
	return_code = data_flash_read_block(LABEL_ADDRESS, LABEL_LENGTH, str);
80005c84:	0e 9a       	mov	r10,r7
80005c86:	30 6b       	mov	r11,6
80005c88:	30 0c       	mov	r12,0
80005c8a:	f0 1f 00 65 	mcall	80005e1c <xg_flashc_init+0x264>
	{
		if(memcmp(XGFlashLabel, str, sizeof(XGFlashLabel)-1) != 0)//compare label
80005c8e:	30 4a       	mov	r10,4
80005c90:	0e 9b       	mov	r11,r7
80005c92:	4e 4c       	lddpc	r12,80005e20 <xg_flashc_init+0x268>
80005c94:	f0 1f 00 64 	mcall	80005e24 <xg_flashc_init+0x26c>
80005c98:	c1 c0       	breq	80005cd0 <xg_flashc_init+0x118>
80005c9a:	c8 b8       	rjmp	80005db0 <xg_flashc_init+0x1f8>
					return FALSE;
				}
				address+=65536;//64k*1024=65536bytes
			}
			//set label
			return_code = data_flash_write(XGFlashLabel, LABEL_ADDRESS, LABEL_LENGTH);
80005c9c:	30 6a       	mov	r10,6
80005c9e:	30 0b       	mov	r11,0
80005ca0:	4e 0c       	lddpc	r12,80005e20 <xg_flashc_init+0x268>
80005ca2:	f0 1f 00 62 	mcall	80005e28 <xg_flashc_init+0x270>
			
			//set current_voice_index
			memset(str, 0x00, sizeof(str));
80005ca6:	4d d7       	lddpc	r7,80005e18 <xg_flashc_init+0x260>
80005ca8:	35 0a       	mov	r10,80
80005caa:	30 0b       	mov	r11,0
80005cac:	0e 9c       	mov	r12,r7
80005cae:	f0 1f 00 60 	mcall	80005e2c <xg_flashc_init+0x274>
			return_code = data_flash_write(str, MESSAGE_NUMBERS_ADD, MESSAGE_NUMBERS_LENGTH);
80005cb2:	30 2a       	mov	r10,2
80005cb4:	30 6b       	mov	r11,6
80005cb6:	0e 9c       	mov	r12,r7
80005cb8:	f0 1f 00 5c 	mcall	80005e28 <xg_flashc_init+0x270>
			if(return_code != DF_WRITE_COMPLETED)
80005cbc:	58 7c       	cp.w	r12,7
80005cbe:	e0 81 00 90 	brne	80005dde <xg_flashc_init+0x226>
			{
				return FALSE;
			}
			current_message_index = 0;
80005cc2:	30 09       	mov	r9,0
80005cc4:	4d b8       	lddpc	r8,80005e30 <xg_flashc_init+0x278>
80005cc6:	b0 09       	st.h	r8[0x0],r9
			log("\r\n----create csbk message info okay!----\r\n");
80005cc8:	4d bc       	lddpc	r12,80005e34 <xg_flashc_init+0x27c>
80005cca:	f0 1f 00 4a 	mcall	80005df0 <xg_flashc_init+0x238>
80005cce:	c8 58       	rjmp	80005dd8 <xg_flashc_init+0x220>
		}
		else//success
		{
			log("\nLABEL: %s\n", str);
80005cd0:	1a d7       	st.w	--sp,r7
80005cd2:	4d ac       	lddpc	r12,80005e38 <xg_flashc_init+0x280>
80005cd4:	f0 1f 00 47 	mcall	80005df0 <xg_flashc_init+0x238>
			//Get the current voice index
			return_code = data_flash_read_block(MESSAGE_NUMBERS_ADD, MESSAGE_NUMBERS_LENGTH, &current_message_index);								
80005cd8:	4d 6a       	lddpc	r10,80005e30 <xg_flashc_init+0x278>
80005cda:	30 2b       	mov	r11,2
80005cdc:	30 6c       	mov	r12,6
80005cde:	f0 1f 00 50 	mcall	80005e1c <xg_flashc_init+0x264>
			if(return_code == DF_OK)
80005ce2:	2f fd       	sub	sp,-4
80005ce4:	58 0c       	cp.w	r12,0
80005ce6:	e0 81 00 7c 	brne	80005dde <xg_flashc_init+0x226>
			{
				//Calculates the offset address of the current stored message
				if(current_message_index != 0){
80005cea:	4d 28       	lddpc	r8,80005e30 <xg_flashc_init+0x278>
80005cec:	90 08       	ld.sh	r8,r8[0x0]
80005cee:	58 08       	cp.w	r8,0
80005cf0:	c7 10       	breq	80005dd2 <xg_flashc_init+0x21a>
					
					log("current_message_index: %d\n", current_message_index);
80005cf2:	5c 78       	castu.h	r8
80005cf4:	1a d8       	st.w	--sp,r8
80005cf6:	4d 2c       	lddpc	r12,80005e3c <xg_flashc_init+0x284>
80005cf8:	f0 1f 00 3e 	mcall	80005df0 <xg_flashc_init+0x238>
					memset(str, 0x00, sizeof(str));	
80005cfc:	30 08       	mov	r8,0
80005cfe:	30 09       	mov	r9,0
80005d00:	ee e9 00 00 	st.d	r7[0],r8
80005d04:	e8 e9 00 00 	st.d	r4[0],r8
80005d08:	e6 e9 00 00 	st.d	r3[0],r8
80005d0c:	e4 e9 00 00 	st.d	r2[0],r8
80005d10:	e2 e9 00 00 	st.d	r1[0],r8
80005d14:	e0 e9 00 00 	st.d	r0[0],r8
80005d18:	40 1a       	lddsp	r10,sp[0x4]
80005d1a:	f4 e9 00 00 	st.d	r10[0],r8
80005d1e:	40 2a       	lddsp	r10,sp[0x8]
80005d20:	f4 e9 00 00 	st.d	r10[0],r8
80005d24:	40 3a       	lddsp	r10,sp[0xc]
80005d26:	b5 28       	st.d	r10++,r8
80005d28:	f4 e9 00 00 	st.d	r10[0],r8
					address = XG_MESSAGE_INFO_HEADER_START_ADD + ((current_message_index -1)*XG_MESSAGE_INFO_HEADER_LENGTH);
80005d2c:	4c 18       	lddpc	r8,80005e30 <xg_flashc_init+0x278>
80005d2e:	90 85       	ld.uh	r5,r8[0x0]
80005d30:	a3 75       	lsl	r5,0x3
					return_code = data_flash_read_block(address, XG_MESSAGE_INFO_HEADER_LENGTH, (U8 *)str);			
80005d32:	0e 9a       	mov	r10,r7
80005d34:	30 8b       	mov	r11,8
80005d36:	0a 9c       	mov	r12,r5
80005d38:	f0 1f 00 39 	mcall	80005e1c <xg_flashc_init+0x264>
					if(return_code == DF_OK)
80005d3c:	2f fd       	sub	sp,-4
80005d3e:	58 0c       	cp.w	r12,0
80005d40:	c4 91       	brne	80005dd2 <xg_flashc_init+0x21a>
					{
						MessageList_Info_t *ptr = (MessageList_Info_t *)str;
						if(ptr->numb == current_message_index)
80005d42:	0f 89       	ld.ub	r9,r7[0x0]
80005d44:	0f 98       	ld.ub	r8,r7[0x1]
80005d46:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80005d4a:	4b a9       	lddpc	r9,80005e30 <xg_flashc_init+0x278>
80005d4c:	92 09       	ld.sh	r9,r9[0x0]
80005d4e:	f0 09 19 00 	cp.h	r9,r8
80005d52:	c2 c1       	brne	80005daa <xg_flashc_init+0x1f2>
						{
							current_save_message_offset = ptr->address + ptr->offset;
80005d54:	0f e9       	ld.ub	r9,r7[0x6]
80005d56:	0f f8       	ld.ub	r8,r7[0x7]
80005d58:	f1 e9 10 89 	or	r9,r8,r9<<0x8
80005d5c:	0f aa       	ld.ub	r10,r7[0x2]
80005d5e:	0f b8       	ld.ub	r8,r7[0x3]
80005d60:	b1 68       	lsl	r8,0x10
80005d62:	f1 ea 11 88 	or	r8,r8,r10<<0x18
80005d66:	0f ca       	ld.ub	r10,r7[0x4]
80005d68:	f1 ea 10 88 	or	r8,r8,r10<<0x8
80005d6c:	0f da       	ld.ub	r10,r7[0x5]
80005d6e:	f5 e8 10 08 	or	r8,r10,r8
80005d72:	f2 08 00 08 	add	r8,r9,r8
80005d76:	4b 36       	lddpc	r6,80005e40 <xg_flashc_init+0x288>
80005d78:	8d 08       	st.w	r6[0x0],r8
							log("current_save_message_offset : %X\n", current_save_message_offset);
80005d7a:	1a d8       	st.w	--sp,r8
80005d7c:	4b 2c       	lddpc	r12,80005e44 <xg_flashc_init+0x28c>
80005d7e:	f0 1f 00 1d 	mcall	80005df0 <xg_flashc_init+0x238>
							if(current_save_message_offset > XG_MESSAGE_DATA_BOUNDARY_ADD){
80005d82:	2f fd       	sub	sp,-4
80005d84:	6c 08       	ld.w	r8,r6[0x0]
80005d86:	e0 69 ff ff 	mov	r9,65535
80005d8a:	ea 19 00 7f 	orh	r9,0x7f
80005d8e:	12 38       	cp.w	r8,r9
80005d90:	e0 88 00 21 	brls	80005dd2 <xg_flashc_init+0x21a>
										
								log("\r\n----message storage is full!!!----\r\n");
80005d94:	4a dc       	lddpc	r12,80005e48 <xg_flashc_init+0x290>
80005d96:	f0 1f 00 17 	mcall	80005df0 <xg_flashc_init+0x238>
								//xgflash erase

								return_code = data_flash_erase_block(0, DF_BLOCK_ALL);
80005d9a:	30 4b       	mov	r11,4
80005d9c:	30 0c       	mov	r12,0
80005d9e:	f0 1f 00 2c 	mcall	80005e4c <xg_flashc_init+0x294>
								if(return_code == DF_ERASE_COMPLETED)goto start;
80005da2:	58 5c       	cp.w	r12,5
80005da4:	fe 90 ff 70 	breq	80005c84 <xg_flashc_init+0xcc>
80005da8:	c1 b8       	rjmp	80005dde <xg_flashc_init+0x226>

							}
						}
						else
						{
							log("\r\n----message storage is err!!!----\r\n");
80005daa:	4a ac       	lddpc	r12,80005e50 <xg_flashc_init+0x298>
80005dac:	f0 1f 00 11 	mcall	80005df0 <xg_flashc_init+0x238>
		{
			ERASE:
			//erase list
			for(i; i < (XG_MESSAGE_LISTINFO_BOUNDARY_ADD/(64*1024)); i++)//2*64k
			{
				return_code = data_flash_erase_block(address, DF_BLOCK_64KB);
80005db0:	30 3b       	mov	r11,3
80005db2:	0a 9c       	mov	r12,r5
80005db4:	f0 1f 00 26 	mcall	80005e4c <xg_flashc_init+0x294>
				if(return_code != DF_ERASE_COMPLETED)
80005db8:	58 5c       	cp.w	r12,5
80005dba:	c1 21       	brne	80005dde <xg_flashc_init+0x226>
		{
			ERASE:
			//erase list
			for(i; i < (XG_MESSAGE_LISTINFO_BOUNDARY_ADD/(64*1024)); i++)//2*64k
			{
				return_code = data_flash_erase_block(address, DF_BLOCK_64KB);
80005dbc:	30 3b       	mov	r11,3
80005dbe:	e0 78 00 00 	mov	r8,65536
80005dc2:	ea 08 00 0c 	add	r12,r5,r8
80005dc6:	f0 1f 00 22 	mcall	80005e4c <xg_flashc_init+0x294>
				if(return_code != DF_ERASE_COMPLETED)
80005dca:	58 5c       	cp.w	r12,5
80005dcc:	fe 90 ff 68 	breq	80005c9c <xg_flashc_init+0xe4>
80005dd0:	c0 78       	rjmp	80005dde <xg_flashc_init+0x226>
							log("\r\n----message storage is err!!!----\r\n");
							goto ERASE;
						}
					}
				}
				log("\r\n----xoxo read message info okay!----\r\n");
80005dd2:	4a 1c       	lddpc	r12,80005e54 <xg_flashc_init+0x29c>
80005dd4:	f0 1f 00 07 	mcall	80005df0 <xg_flashc_init+0x238>
			else
				return FALSE;
			
		}
				
		list_init_success_flag = 1;
80005dd8:	30 19       	mov	r9,1
80005dda:	4a 08       	lddpc	r8,80005e58 <xg_flashc_init+0x2a0>
80005ddc:	b0 89       	st.b	r8[0x0],r9
	
	xgflash_list_info_init();
	
	
	//create_xg_flash_test_task();
}
80005dde:	2f dd       	sub	sp,-12
80005de0:	d8 32       	popm	r0-r7,pc
80005de2:	00 00       	add	r0,r0
80005de4:	80 00       	ld.sh	r0,r0[0x0]
80005de6:	72 b4       	ld.w	r4,r9[0x2c]
80005de8:	00 00       	add	r0,r0
80005dea:	0b 90       	ld.ub	r0,r5[0x1]
80005dec:	80 00       	ld.sh	r0,r0[0x0]
80005dee:	e8 d4 80 00 	satsub.w	r4,r4,-32768
80005df2:	7d ec       	ld.w	r12,lr[0x78]
80005df4:	80 00       	ld.sh	r0,r0[0x0]
80005df6:	73 0c       	ld.w	r12,r9[0x40]
80005df8:	00 00       	add	r0,r0
80005dfa:	0b 9c       	ld.ub	r12,r5[0x1]
80005dfc:	80 00       	ld.sh	r0,r0[0x0]
80005dfe:	71 b4       	ld.w	r4,r8[0x6c]
80005e00:	80 00       	ld.sh	r0,r0[0x0]
80005e02:	e9 00 00 00 	ld.sh	r0,r4[0]
80005e06:	0b 88       	ld.ub	r8,r5[0x0]
80005e08:	00 00       	add	r0,r0
80005e0a:	0b 98       	ld.ub	r8,r5[0x1]
80005e0c:	00 00       	add	r0,r0
80005e0e:	97 bc       	st.w	r11[0x2c],r12
80005e10:	80 00       	ld.sh	r0,r0[0x0]
80005e12:	35 c0       	mov	r0,92
80005e14:	80 00       	ld.sh	r0,r0[0x0]
80005e16:	32 88       	mov	r8,40
80005e18:	00 00       	add	r0,r0
80005e1a:	0b a4       	ld.ub	r4,r5[0x2]
80005e1c:	80 00       	ld.sh	r0,r0[0x0]
80005e1e:	2f 2c       	sub	r12,-14
80005e20:	00 00       	add	r0,r0
80005e22:	05 40       	ld.w	r0,--r2
80005e24:	80 00       	ld.sh	r0,r0[0x0]
80005e26:	86 68       	ld.sh	r8,r3[0xc]
80005e28:	80 00       	ld.sh	r0,r0[0x0]
80005e2a:	31 64       	mov	r4,22
80005e2c:	80 00       	ld.sh	r0,r0[0x0]
80005e2e:	87 d6       	st.w	r3[0x34],r6
80005e30:	00 00       	add	r0,r0
80005e32:	0b a0       	ld.ub	r0,r5[0x2]
80005e34:	80 00       	ld.sh	r0,r0[0x0]
80005e36:	e9 30 80 00 	ld.ub	r0,r4[-32768]
80005e3a:	e9 5c 80 00 	st.h	r4[-32768],r12
80005e3e:	e9 68 00 00 	st.b	r4[0],r8
80005e42:	05 48       	ld.w	r8,--r2
80005e44:	80 00       	ld.sh	r0,r0[0x0]
80005e46:	e9 84       	*unknown*
80005e48:	80 00       	ld.sh	r0,r0[0x0]
80005e4a:	e9 a8 80 00 	ldc.w	cp4,cr0,r8[0x0]
80005e4e:	30 c4       	mov	r4,12
80005e50:	80 00       	ld.sh	r0,r0[0x0]
80005e52:	e9 d0 80 00 	ldswp.w	r0,r4[0]
80005e56:	e9 f8 00 00 	ld.weq	r8,r4[0x0]
80005e5a:	0b 8c       	ld.ub	r12,r5[0x0]

80005e5c <xgflash_get_message_data>:
	return XG_OK;

}

xgflash_status_t xgflash_get_message_data(U32 message_index, void *buff_ptr, bool erase)
{
80005e5c:	d4 31       	pushm	r0-r7,lr
80005e5e:	20 2d       	sub	sp,8
80005e60:	18 95       	mov	r5,r12
80005e62:	16 96       	mov	r6,r11
80005e64:	14 93       	mov	r3,r10
	xgflash_status_t status = XG_ERROR;
	
	if(!list_init_success_flag)return XG_ERROR;
80005e66:	4c 78       	lddpc	r8,80005f80 <xgflash_get_message_data+0x124>
80005e68:	11 89       	ld.ub	r9,r8[0x0]
80005e6a:	30 08       	mov	r8,0
80005e6c:	f0 09 18 00 	cp.b	r9,r8
80005e70:	c0 31       	brne	80005e76 <xgflash_get_message_data+0x1a>
80005e72:	3f f7       	mov	r7,-1
80005e74:	c8 28       	rjmp	80005f78 <xgflash_get_message_data+0x11c>
	
	xSemaphoreTake(xgflash_mutex, portMAX_DELAY);//lock
80005e76:	4c 48       	lddpc	r8,80005f84 <xgflash_get_message_data+0x128>
80005e78:	70 0c       	ld.w	r12,r8[0x0]
80005e7a:	30 09       	mov	r9,0
80005e7c:	3f fa       	mov	r10,-1
80005e7e:	12 9b       	mov	r11,r9
80005e80:	f0 1f 00 42 	mcall	80005f88 <xgflash_get_message_data+0x12c>
	/* check input parameter */
	if (message_index > current_message_index)
80005e84:	4c 28       	lddpc	r8,80005f8c <xgflash_get_message_data+0x130>
80005e86:	90 88       	ld.uh	r8,r8[0x0]
80005e88:	0a 38       	cp.w	r8,r5
80005e8a:	c0 a2       	brcc	80005e9e <xgflash_get_message_data+0x42>
	{
		xSemaphoreGive(xgflash_mutex);//unlock
80005e8c:	4b e8       	lddpc	r8,80005f84 <xgflash_get_message_data+0x128>
80005e8e:	70 0c       	ld.w	r12,r8[0x0]
80005e90:	30 09       	mov	r9,0
80005e92:	12 9a       	mov	r10,r9
80005e94:	12 9b       	mov	r11,r9
80005e96:	f0 1f 00 3f 	mcall	80005f90 <xgflash_get_message_data+0x134>
80005e9a:	30 17       	mov	r7,1
		return XG_INVALID_PARAM;
80005e9c:	c6 e8       	rjmp	80005f78 <xgflash_get_message_data+0x11c>
	U32 data_address =0x00000000;
	U32 erase_address =0x00;
	U32 erase_length =0x00;
	
	char str[XG_MESSAGE_INFO_HEADER_LENGTH];
	memset(str, 0x00, sizeof(str));
80005e9e:	fa ca ff f8 	sub	r10,sp,-8
80005ea2:	30 08       	mov	r8,0
80005ea4:	30 09       	mov	r9,0
80005ea6:	b5 29       	st.d	--r10,r8
	
	//find the message storage info by message_index
	info_address = XG_MESSAGE_INFO_HEADER_START_ADD + ((message_index -1)*XG_MESSAGE_INFO_HEADER_LENGTH);
	//flashc_memcpy((void *)str, (void *)info_address, XG_MESSAGE_INFO_HEADER_LENGTH,  false);
	return_code = data_flash_read_block(info_address, XG_MESSAGE_INFO_HEADER_LENGTH, (U8 *)str);
80005ea8:	1a 9a       	mov	r10,sp
80005eaa:	30 8b       	mov	r11,8
80005eac:	ea 0c 15 03 	lsl	r12,r5,0x3
80005eb0:	f0 1f 00 39 	mcall	80005f94 <xgflash_get_message_data+0x138>
	if (return_code == DF_OK)
80005eb4:	c5 a1       	brne	80005f68 <xgflash_get_message_data+0x10c>
	{
		U16 bytes_remained;
		MessageList_Info_t *ptr = (MessageList_Info_t *)str;
		if(ptr->numb == message_index)
80005eb6:	9a 88       	ld.uh	r8,sp[0x0]
80005eb8:	0a 38       	cp.w	r8,r5
80005eba:	c3 31       	brne	80005f20 <xgflash_get_message_data+0xc4>
		{
			bytes_remained = ptr->offset;
80005ebc:	40 18       	lddsp	r8,sp[0x4]
80005ebe:	ef d8 b0 10 	bfexts	r7,r8,0x0,0x10
			erase_length = ptr->offset;
			
			data_address = ptr->address;
80005ec2:	9a 95       	ld.uh	r5,sp[0x2]
80005ec4:	b1 88       	lsr	r8,0x10
80005ec6:	f1 e5 11 05 	or	r5,r8,r5<<0x10
			erase_address = ptr->address;
			
			while (bytes_remained >= 1 && return_code == DF_OK)
80005eca:	30 04       	mov	r4,0
80005ecc:	08 92       	mov	r2,r4
			{
				if(bytes_remained < DF_DATA_SPACE_SIZE)//< 512bytes
80005ece:	e0 61 01 ff 	mov	r1,511
					bytes_remained = 0;	/* end while loop */

				}
				else//bytes_remained > DF_DATA_SPACE_SIZE
				{
					return_code = data_flash_read_block(data_address, DF_DATA_SPACE_SIZE, buff_ptr);
80005ed2:	e0 60 02 00 	mov	r0,512
			erase_length = ptr->offset;
			
			data_address = ptr->address;
			erase_address = ptr->address;
			
			while (bytes_remained >= 1 && return_code == DF_OK)
80005ed6:	c1 98       	rjmp	80005f08 <xgflash_get_message_data+0xac>
			{
				if(bytes_remained < DF_DATA_SPACE_SIZE)//< 512bytes
80005ed8:	e2 07 19 00 	cp.h	r7,r1
80005edc:	e0 8b 00 0a 	brhi	80005ef0 <xgflash_get_message_data+0x94>
				{
					return_code = data_flash_read_block(data_address, bytes_remained, buff_ptr);
80005ee0:	0c 9a       	mov	r10,r6
80005ee2:	0e 9b       	mov	r11,r7
80005ee4:	5c 7b       	castu.h	r11
80005ee6:	0a 9c       	mov	r12,r5
80005ee8:	f0 1f 00 2b 	mcall	80005f94 <xgflash_get_message_data+0x138>
80005eec:	30 07       	mov	r7,0
80005eee:	c0 d8       	rjmp	80005f08 <xgflash_get_message_data+0xac>
					bytes_remained = 0;	/* end while loop */

				}
				else//bytes_remained > DF_DATA_SPACE_SIZE
				{
					return_code = data_flash_read_block(data_address, DF_DATA_SPACE_SIZE, buff_ptr);
80005ef0:	0c 9a       	mov	r10,r6
80005ef2:	00 9b       	mov	r11,r0
80005ef4:	0a 9c       	mov	r12,r5
80005ef6:	f0 1f 00 28 	mcall	80005f94 <xgflash_get_message_data+0x138>
					bytes_remained-=DF_DATA_SPACE_SIZE;
80005efa:	ee c7 02 00 	sub	r7,r7,512
80005efe:	5c 87       	casts.h	r7
					data_address+=DF_DATA_SPACE_SIZE;
80005f00:	ea c5 fe 00 	sub	r5,r5,-512
					buff_ptr+=DF_DATA_SPACE_SIZE;
80005f04:	ec c6 fe 00 	sub	r6,r6,-512
			erase_length = ptr->offset;
			
			data_address = ptr->address;
			erase_address = ptr->address;
			
			while (bytes_remained >= 1 && return_code == DF_OK)
80005f08:	e8 07 19 00 	cp.h	r7,r4
80005f0c:	5f 19       	srne	r9
80005f0e:	58 0c       	cp.w	r12,0
80005f10:	5f 08       	sreq	r8
80005f12:	f3 e8 00 08 	and	r8,r9,r8
80005f16:	e4 08 18 00 	cp.b	r8,r2
80005f1a:	cd f1       	brne	80005ed8 <xgflash_get_message_data+0x7c>
80005f1c:	30 07       	mov	r7,0
80005f1e:	c0 58       	rjmp	80005f28 <xgflash_get_message_data+0xcc>
			}
			status = XG_OK;
		}
		else
		{
			log("Err flash data\n");
80005f20:	49 ec       	lddpc	r12,80005f98 <xgflash_get_message_data+0x13c>
80005f22:	f0 1f 00 1f 	mcall	80005f9c <xgflash_get_message_data+0x140>
80005f26:	30 87       	mov	r7,8
			
			//xSemaphoreGive(xgflash_mutex);//unlock
			status = 8;
			//return 7;
		}
		if(erase)//erase the message
80005f28:	58 03       	cp.w	r3,0
80005f2a:	c1 70       	breq	80005f58 <xgflash_get_message_data+0xfc>
		{
			memset(str, 0x00, sizeof(str));
80005f2c:	30 08       	mov	r8,0
80005f2e:	30 09       	mov	r9,0
80005f30:	fa e9 00 00 	st.d	sp[0],r8
			//reset:current_message_index and erase info
			current_message_index-=1;
80005f34:	49 6c       	lddpc	r12,80005f8c <xgflash_get_message_data+0x130>
80005f36:	98 08       	ld.sh	r8,r12[0x0]
80005f38:	20 18       	sub	r8,1
80005f3a:	b8 08       	st.h	r12[0x0],r8
			return_code = data_flash_write((U8 *)&current_message_index, MESSAGE_NUMBERS_ADD, MESSAGE_NUMBERS_LENGTH);
80005f3c:	30 2a       	mov	r10,2
80005f3e:	30 6b       	mov	r11,6
80005f40:	f0 1f 00 18 	mcall	80005fa0 <xgflash_get_message_data+0x144>
			if (return_code != DF_WRITE_COMPLETED)
80005f44:	58 7c       	cp.w	r12,7
80005f46:	c0 50       	breq	80005f50 <xgflash_get_message_data+0xf4>
			{
				log("data_flash_write 1...\n");
80005f48:	49 7c       	lddpc	r12,80005fa4 <xgflash_get_message_data+0x148>
80005f4a:	f0 1f 00 15 	mcall	80005f9c <xgflash_get_message_data+0x140>
80005f4e:	30 77       	mov	r7,7
				//status = XG_FLASH_WRITE_FAIL;
			//}
					//
			////erase data and reset:current_save_message_offset
			//return_code = data_flash_write((U8 *)str, erase_address, sizeof(str));
			current_save_message_offset-=32;//出错在这...如果掉线，未执行，则会出现存储碎片
80005f50:	49 68       	lddpc	r8,80005fa8 <xgflash_get_message_data+0x14c>
80005f52:	70 09       	ld.w	r9,r8[0x0]
80005f54:	22 09       	sub	r9,32
80005f56:	91 09       	st.w	r8[0x0],r9
				//status = XG_FLASH_WRITE_FAIL;
			//}
					
		}
				
		xSemaphoreGive(xgflash_mutex);//unlock
80005f58:	48 b8       	lddpc	r8,80005f84 <xgflash_get_message_data+0x128>
80005f5a:	70 0c       	ld.w	r12,r8[0x0]
80005f5c:	30 09       	mov	r9,0
80005f5e:	12 9a       	mov	r10,r9
80005f60:	12 9b       	mov	r11,r9
80005f62:	f0 1f 00 0c 	mcall	80005f90 <xgflash_get_message_data+0x134>
		//status = XG_OK;
		return status;
80005f66:	c0 98       	rjmp	80005f78 <xgflash_get_message_data+0x11c>
	}
	
	xSemaphoreGive(xgflash_mutex);//unlock
80005f68:	48 78       	lddpc	r8,80005f84 <xgflash_get_message_data+0x128>
80005f6a:	70 0c       	ld.w	r12,r8[0x0]
80005f6c:	30 09       	mov	r9,0
80005f6e:	12 9a       	mov	r10,r9
80005f70:	12 9b       	mov	r11,r9
80005f72:	f0 1f 00 08 	mcall	80005f90 <xgflash_get_message_data+0x134>
80005f76:	30 67       	mov	r7,6
	return XG_FLASH_READ_FAIL;
		
}
80005f78:	0e 9c       	mov	r12,r7
80005f7a:	2f ed       	sub	sp,-8
80005f7c:	d8 32       	popm	r0-r7,pc
80005f7e:	00 00       	add	r0,r0
80005f80:	00 00       	add	r0,r0
80005f82:	0b 8c       	ld.ub	r12,r5[0x0]
80005f84:	00 00       	add	r0,r0
80005f86:	0b 90       	ld.ub	r0,r5[0x1]
80005f88:	80 00       	ld.sh	r0,r0[0x0]
80005f8a:	6f a8       	ld.w	r8,r7[0x68]
80005f8c:	00 00       	add	r0,r0
80005f8e:	0b a0       	ld.ub	r0,r5[0x2]
80005f90:	80 00       	ld.sh	r0,r0[0x0]
80005f92:	71 b4       	ld.w	r4,r8[0x6c]
80005f94:	80 00       	ld.sh	r0,r0[0x0]
80005f96:	2f 2c       	sub	r12,-14
80005f98:	80 00       	ld.sh	r0,r0[0x0]
80005f9a:	ea 34 80 00 	sub	r4,753664
80005f9e:	7d ec       	ld.w	r12,lr[0x78]
80005fa0:	80 00       	ld.sh	r0,r0[0x0]
80005fa2:	31 64       	mov	r4,22
80005fa4:	80 00       	ld.sh	r0,r0[0x0]
80005fa6:	ea 44 00 00 	cp.w	r4,655360
80005faa:	05 48       	ld.w	r8,--r2

80005fac <xgflash_message_save>:
	
}

//static U32 current_bytes_remained = 0;
xgflash_status_t xgflash_message_save(U8 *data_ptr, U16 data_len, U8 data_end_flag)
{
80005fac:	d4 21       	pushm	r4-r7,lr
80005fae:	20 2d       	sub	sp,8
80005fb0:	18 96       	mov	r6,r12
80005fb2:	16 97       	mov	r7,r11
80005fb4:	14 95       	mov	r5,r10

	if(!list_init_success_flag)return XG_ERROR;
80005fb6:	4d 68       	lddpc	r8,8000610c <xgflash_message_save+0x160>
80005fb8:	11 89       	ld.ub	r9,r8[0x0]
80005fba:	30 08       	mov	r8,0
80005fbc:	f0 09 18 00 	cp.b	r9,r8
80005fc0:	c0 31       	brne	80005fc6 <xgflash_message_save+0x1a>
80005fc2:	3f fc       	mov	r12,-1
80005fc4:	ca 28       	rjmp	80006108 <xgflash_message_save+0x15c>
	U32 address = 0;
	static U32 bytes_remained = 0;
	static U32 current_bytes_remained = 0;
	df_status_t return_code = DF_WRITE_COMPLETED;
	
	xSemaphoreTake(xgflash_mutex, portMAX_DELAY) ;//lock	
80005fc6:	4d 38       	lddpc	r8,80006110 <xgflash_message_save+0x164>
80005fc8:	70 0c       	ld.w	r12,r8[0x0]
80005fca:	30 09       	mov	r9,0
80005fcc:	3f fa       	mov	r10,-1
80005fce:	12 9b       	mov	r11,r9
80005fd0:	f0 1f 00 51 	mcall	80006114 <xgflash_message_save+0x168>
	
	/* check input parameter */
	if (data_ptr == NULL || data_len > 0x0200)//512bytes
80005fd4:	58 06       	cp.w	r6,0
80005fd6:	5f 09       	sreq	r9
80005fd8:	e0 68 02 00 	mov	r8,512
80005fdc:	f0 07 19 00 	cp.h	r7,r8
80005fe0:	5f b8       	srhi	r8
80005fe2:	f3 e8 10 08 	or	r8,r9,r8
80005fe6:	c0 30       	breq	80005fec <xgflash_message_save+0x40>
80005fe8:	30 1c       	mov	r12,1
80005fea:	c8 f8       	rjmp	80006108 <xgflash_message_save+0x15c>
	{
		return XG_INVALID_PARAM;
	}
	
	current_bytes_remained+=data_len;//accumulate
80005fec:	0e 94       	mov	r4,r7
80005fee:	5c 74       	castu.h	r4
80005ff0:	4c a9       	lddpc	r9,80006118 <xgflash_message_save+0x16c>
80005ff2:	72 08       	ld.w	r8,r9[0x0]
80005ff4:	e8 08 00 08 	add	r8,r4,r8
80005ff8:	93 08       	st.w	r9[0x0],r8
	
	if(current_bytes_remained > 0xF000)//data size > 60k,overout
80005ffa:	e0 48 f0 00 	cp.w	r8,61440
80005ffe:	e0 88 00 07 	brls	8000600c <xgflash_message_save+0x60>
	{
		current_bytes_remained = 0;
80006002:	30 09       	mov	r9,0
80006004:	4c 58       	lddpc	r8,80006118 <xgflash_message_save+0x16c>
80006006:	91 09       	st.w	r8[0x0],r9
80006008:	30 1c       	mov	r12,1
		return XG_INVALID_PARAM;
8000600a:	c7 f8       	rjmp	80006108 <xgflash_message_save+0x15c>
	}
	
	//save data
	if(current_save_message_offset > XG_MESSAGE_DATA_BOUNDARY_ADD)//The message data is out of boundary
8000600c:	4c 48       	lddpc	r8,8000611c <xgflash_message_save+0x170>
8000600e:	70 0b       	ld.w	r11,r8[0x0]
80006010:	e0 68 ff ff 	mov	r8,65535
80006014:	ea 18 00 7f 	orh	r8,0x7f
80006018:	10 3b       	cp.w	r11,r8
8000601a:	e0 88 00 10 	brls	8000603a <xgflash_message_save+0x8e>
	{
		log("\r\n----message data is Out of bounds!!!\r\n----");
8000601e:	4c 1c       	lddpc	r12,80006120 <xgflash_message_save+0x174>
80006020:	f0 1f 00 41 	mcall	80006124 <xgflash_message_save+0x178>
		current_bytes_remained = 0;
80006024:	30 0b       	mov	r11,0
80006026:	4b d8       	lddpc	r8,80006118 <xgflash_message_save+0x16c>
80006028:	91 0b       	st.w	r8[0x0],r11
		xSemaphoreGive(xgflash_mutex );//unlock
8000602a:	4b a8       	lddpc	r8,80006110 <xgflash_message_save+0x164>
8000602c:	70 0c       	ld.w	r12,r8[0x0]
8000602e:	16 99       	mov	r9,r11
80006030:	16 9a       	mov	r10,r11
80006032:	f0 1f 00 3e 	mcall	80006128 <xgflash_message_save+0x17c>
80006036:	30 3c       	mov	r12,3
		return XG_OUT_BOUNDARY;
80006038:	c6 88       	rjmp	80006108 <xgflash_message_save+0x15c>
	}
	
	
	return_code = data_flash_write((U8 *)data_ptr, current_save_message_offset, data_len);
8000603a:	0e 9a       	mov	r10,r7
8000603c:	5c 7a       	castu.h	r10
8000603e:	0c 9c       	mov	r12,r6
80006040:	f0 1f 00 3b 	mcall	8000612c <xgflash_message_save+0x180>
	if(return_code != DF_WRITE_COMPLETED)
80006044:	58 7c       	cp.w	r12,7
80006046:	c0 c0       	breq	8000605e <xgflash_message_save+0xb2>
	{
		current_bytes_remained = 0;
80006048:	30 0b       	mov	r11,0
8000604a:	4b 48       	lddpc	r8,80006118 <xgflash_message_save+0x16c>
8000604c:	91 0b       	st.w	r8[0x0],r11
		xSemaphoreGive(xgflash_mutex );//unlock
8000604e:	4b 18       	lddpc	r8,80006110 <xgflash_message_save+0x164>
80006050:	70 0c       	ld.w	r12,r8[0x0]
80006052:	16 99       	mov	r9,r11
80006054:	16 9a       	mov	r10,r11
80006056:	f0 1f 00 35 	mcall	80006128 <xgflash_message_save+0x17c>
8000605a:	30 7c       	mov	r12,7
		return XG_FLASH_WRITE_FAIL;
8000605c:	c5 68       	rjmp	80006108 <xgflash_message_save+0x15c>
	}
	
	current_save_message_offset+=data_len;
8000605e:	4b 08       	lddpc	r8,8000611c <xgflash_message_save+0x170>
80006060:	70 09       	ld.w	r9,r8[0x0]
80006062:	12 04       	add	r4,r9
80006064:	91 04       	st.w	r8[0x0],r4
	log("current_save_message_offset : %X\n", current_save_message_offset);
80006066:	1a d4       	st.w	--sp,r4
80006068:	4b 2c       	lddpc	r12,80006130 <xgflash_message_save+0x184>
8000606a:	f0 1f 00 2f 	mcall	80006124 <xgflash_message_save+0x178>
		
	MessageList_Info_t ptr;
		
	if(data_end_flag == TRUE)//save a message-info into list at the end of the resend-event
8000606e:	2f fd       	sub	sp,-4
80006070:	30 18       	mov	r8,1
80006072:	f0 05 18 00 	cp.b	r5,r8
80006076:	c4 11       	brne	800060f8 <xgflash_message_save+0x14c>
	{
		current_message_index++;
80006078:	4a f9       	lddpc	r9,80006134 <xgflash_message_save+0x188>
8000607a:	92 08       	ld.sh	r8,r9[0x0]
8000607c:	2f f8       	sub	r8,-1
8000607e:	b2 08       	st.h	r9[0x0],r8
		ptr.numb		= current_message_index;
80006080:	ba 08       	st.h	sp[0x0],r8
		ptr.address		= (current_save_message_offset - current_bytes_remained);
80006082:	4a 69       	lddpc	r9,80006118 <xgflash_message_save+0x16c>
80006084:	72 09       	ld.w	r9,r9[0x0]
80006086:	4a 6a       	lddpc	r10,8000611c <xgflash_message_save+0x170>
80006088:	74 0a       	ld.w	r10,r10[0x0]
8000608a:	12 1a       	sub	r10,r9
8000608c:	40 0b       	lddsp	r11,sp[0x0]
8000608e:	e0 1b 00 00 	andl	r11,0x0
80006092:	f7 ea 13 0b 	or	r11,r11,r10>>0x10
80006096:	50 0b       	stdsp	sp[0x0],r11
80006098:	ba 2a       	st.h	sp[0x4],r10
		ptr.offset		= current_bytes_remained;
8000609a:	ba 39       	st.h	sp[0x6],r9
		
		address = XG_MESSAGE_INFO_HEADER_START_ADD + ((current_message_index -1)*XG_MESSAGE_INFO_HEADER_LENGTH);
8000609c:	5c 78       	castu.h	r8
8000609e:	f0 0b 15 03 	lsl	r11,r8,0x3
		if(address > XG_MESSAGE_LISTINFO_BOUNDARY_ADD)//The number of messages is out of bounds
800060a2:	e2 4b 00 00 	cp.w	r11,131072
800060a6:	e0 88 00 10 	brls	800060c6 <xgflash_message_save+0x11a>
		{
			log("\r\n----info list is Out of bounds!!!\r\n----");
800060aa:	4a 4c       	lddpc	r12,80006138 <xgflash_message_save+0x18c>
800060ac:	f0 1f 00 1e 	mcall	80006124 <xgflash_message_save+0x178>
			current_bytes_remained = 0;
800060b0:	30 0b       	mov	r11,0
800060b2:	49 a8       	lddpc	r8,80006118 <xgflash_message_save+0x16c>
800060b4:	91 0b       	st.w	r8[0x0],r11
			xSemaphoreGive(xgflash_mutex );//unlock
800060b6:	49 78       	lddpc	r8,80006110 <xgflash_message_save+0x164>
800060b8:	70 0c       	ld.w	r12,r8[0x0]
800060ba:	16 99       	mov	r9,r11
800060bc:	16 9a       	mov	r10,r11
800060be:	f0 1f 00 1b 	mcall	80006128 <xgflash_message_save+0x17c>
800060c2:	30 3c       	mov	r12,3
			return XG_OUT_BOUNDARY;
800060c4:	c2 28       	rjmp	80006108 <xgflash_message_save+0x15c>
		}
		
		
		//set a message info by current_message_index	
		return_code = data_flash_write((U8 *)&ptr, address, XG_MESSAGE_INFO_HEADER_LENGTH);
800060c6:	30 8a       	mov	r10,8
800060c8:	1a 9c       	mov	r12,sp
800060ca:	f0 1f 00 19 	mcall	8000612c <xgflash_message_save+0x180>
		//set message numbers
		return_code = data_flash_write(&current_message_index, MESSAGE_NUMBERS_ADD, MESSAGE_NUMBERS_LENGTH);
800060ce:	30 2a       	mov	r10,2
800060d0:	30 6b       	mov	r11,6
800060d2:	49 9c       	lddpc	r12,80006134 <xgflash_message_save+0x188>
800060d4:	f0 1f 00 16 	mcall	8000612c <xgflash_message_save+0x180>
		if(return_code != DF_WRITE_COMPLETED)
800060d8:	58 7c       	cp.w	r12,7
800060da:	c0 c0       	breq	800060f2 <xgflash_message_save+0x146>
		{
			current_bytes_remained = 0;
800060dc:	30 0b       	mov	r11,0
800060de:	48 f8       	lddpc	r8,80006118 <xgflash_message_save+0x16c>
800060e0:	91 0b       	st.w	r8[0x0],r11
			xSemaphoreGive(xgflash_mutex );//unlock
800060e2:	48 c8       	lddpc	r8,80006110 <xgflash_message_save+0x164>
800060e4:	70 0c       	ld.w	r12,r8[0x0]
800060e6:	16 99       	mov	r9,r11
800060e8:	16 9a       	mov	r10,r11
800060ea:	f0 1f 00 10 	mcall	80006128 <xgflash_message_save+0x17c>
800060ee:	30 7c       	mov	r12,7
			return XG_FLASH_WRITE_FAIL;
800060f0:	c0 c8       	rjmp	80006108 <xgflash_message_save+0x15c>
		}
		
		current_bytes_remained = 0;//reset 0
800060f2:	30 09       	mov	r9,0
800060f4:	48 98       	lddpc	r8,80006118 <xgflash_message_save+0x16c>
800060f6:	91 09       	st.w	r8[0x0],r9
	}
	
	xSemaphoreGive(xgflash_mutex );//unlock
800060f8:	48 68       	lddpc	r8,80006110 <xgflash_message_save+0x164>
800060fa:	70 0c       	ld.w	r12,r8[0x0]
800060fc:	30 09       	mov	r9,0
800060fe:	12 9a       	mov	r10,r9
80006100:	12 9b       	mov	r11,r9
80006102:	f0 1f 00 0a 	mcall	80006128 <xgflash_message_save+0x17c>
80006106:	30 0c       	mov	r12,0
	return XG_OK;

}
80006108:	2f ed       	sub	sp,-8
8000610a:	d8 22       	popm	r4-r7,pc
8000610c:	00 00       	add	r0,r0
8000610e:	0b 8c       	ld.ub	r12,r5[0x0]
80006110:	00 00       	add	r0,r0
80006112:	0b 90       	ld.ub	r0,r5[0x1]
80006114:	80 00       	ld.sh	r0,r0[0x0]
80006116:	6f a8       	ld.w	r8,r7[0x68]
80006118:	00 00       	add	r0,r0
8000611a:	0b 94       	ld.ub	r4,r5[0x1]
8000611c:	00 00       	add	r0,r0
8000611e:	05 48       	ld.w	r8,--r2
80006120:	80 00       	ld.sh	r0,r0[0x0]
80006122:	ea 5c 80 00 	cp.w	r12,753664
80006126:	7d ec       	ld.w	r12,lr[0x78]
80006128:	80 00       	ld.sh	r0,r0[0x0]
8000612a:	71 b4       	ld.w	r4,r8[0x6c]
8000612c:	80 00       	ld.sh	r0,r0[0x0]
8000612e:	31 64       	mov	r4,22
80006130:	80 00       	ld.sh	r0,r0[0x0]
80006132:	e9 84       	*unknown*
80006134:	00 00       	add	r0,r0
80006136:	0b a0       	ld.ub	r0,r5[0x2]
80006138:	80 00       	ld.sh	r0,r0[0x0]
8000613a:	ea 8c eb cd 	brvs	801638d4 <_data_lma+0x154484>

8000613c <xgflash_get_message_count>:
	}
	return XG_ERROR;
	
}
U16 xgflash_get_message_count(void)
{
8000613c:	eb cd 40 c0 	pushm	r6-r7,lr
	if(!list_init_success_flag)return 0xFFFF;
80006140:	48 d8       	lddpc	r8,80006174 <xgflash_get_message_count+0x38>
80006142:	11 89       	ld.ub	r9,r8[0x0]
80006144:	30 08       	mov	r8,0
80006146:	f0 09 18 00 	cp.b	r9,r8
8000614a:	c0 31       	brne	80006150 <xgflash_get_message_count+0x14>
8000614c:	3f f7       	mov	r7,-1
8000614e:	c1 08       	rjmp	8000616e <xgflash_get_message_count+0x32>
	
	xSemaphoreTake(xgflash_mutex, portMAX_DELAY);
80006150:	48 a6       	lddpc	r6,80006178 <xgflash_get_message_count+0x3c>
80006152:	6c 0c       	ld.w	r12,r6[0x0]
80006154:	30 09       	mov	r9,0
80006156:	3f fa       	mov	r10,-1
80006158:	12 9b       	mov	r11,r9
8000615a:	f0 1f 00 09 	mcall	8000617c <xgflash_get_message_count+0x40>
	U16 return_value = current_message_index;
8000615e:	48 98       	lddpc	r8,80006180 <xgflash_get_message_count+0x44>
80006160:	90 07       	ld.sh	r7,r8[0x0]
	xSemaphoreGive(xgflash_mutex );
80006162:	6c 0c       	ld.w	r12,r6[0x0]
80006164:	30 09       	mov	r9,0
80006166:	12 9a       	mov	r10,r9
80006168:	12 9b       	mov	r11,r9
8000616a:	f0 1f 00 07 	mcall	80006184 <xgflash_get_message_count+0x48>

	return return_value;
	
}
8000616e:	0e 9c       	mov	r12,r7
80006170:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006174:	00 00       	add	r0,r0
80006176:	0b 8c       	ld.ub	r12,r5[0x0]
80006178:	00 00       	add	r0,r0
8000617a:	0b 90       	ld.ub	r0,r5[0x1]
8000617c:	80 00       	ld.sh	r0,r0[0x0]
8000617e:	6f a8       	ld.w	r8,r7[0x68]
80006180:	00 00       	add	r0,r0
80006182:	0b a0       	ld.ub	r0,r5[0x2]
80006184:	80 00       	ld.sh	r0,r0[0x0]
80006186:	71 b4       	ld.w	r4,r8[0x6c]

80006188 <flashc_set_wait_state>:
}


void flashc_set_wait_state(unsigned int wait_state)
{
	u_avr32_flashc_fcr_t u_avr32_flashc_fcr = {AVR32_FLASHC.fcr};
80006188:	fe 68 14 00 	mov	r8,-125952
8000618c:	70 09       	ld.w	r9,r8[0x0]
	u_avr32_flashc_fcr.FCR.fws = wait_state;
8000618e:	f3 dc d0 c1 	bfins	r9,r12,0x6,0x1
	AVR32_FLASHC.fcr = u_avr32_flashc_fcr.fcr;
80006192:	91 09       	st.w	r8[0x0],r9
}
80006194:	5e fc       	retal	r12

80006196 <gpio_enable_module_pin>:
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80006196:	f8 08 16 05 	lsr	r8,r12,0x5
8000619a:	a9 68       	lsl	r8,0x8
8000619c:	e0 28 f0 00 	sub	r8,61440

	/* Enable the correct function. */
	switch (function) {
800061a0:	58 1b       	cp.w	r11,1
800061a2:	c0 d0       	breq	800061bc <gpio_enable_module_pin+0x26>
800061a4:	c0 63       	brcs	800061b0 <gpio_enable_module_pin+0x1a>
800061a6:	58 2b       	cp.w	r11,2
800061a8:	c1 00       	breq	800061c8 <gpio_enable_module_pin+0x32>
800061aa:	58 3b       	cp.w	r11,3
800061ac:	c1 40       	breq	800061d4 <gpio_enable_module_pin+0x3e>
800061ae:	5e ff       	retal	1
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
800061b0:	30 19       	mov	r9,1
800061b2:	f2 0c 09 49 	lsl	r9,r9,r12
800061b6:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
800061b8:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
800061ba:	c1 28       	rjmp	800061de <gpio_enable_module_pin+0x48>

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
800061bc:	30 19       	mov	r9,1
800061be:	f2 0c 09 49 	lsl	r9,r9,r12
800061c2:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
800061c4:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
800061c6:	c0 c8       	rjmp	800061de <gpio_enable_module_pin+0x48>

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
800061c8:	30 19       	mov	r9,1
800061ca:	f2 0c 09 49 	lsl	r9,r9,r12
800061ce:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
800061d0:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
800061d2:	c0 68       	rjmp	800061de <gpio_enable_module_pin+0x48>

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
800061d4:	30 19       	mov	r9,1
800061d6:	f2 0c 09 49 	lsl	r9,r9,r12
800061da:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
800061dc:	91 99       	st.w	r8[0x24],r9
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
800061de:	30 19       	mov	r9,1
800061e0:	f2 0c 09 4c 	lsl	r12,r9,r12
800061e4:	91 2c       	st.w	r8[0x8],r12
800061e6:	5e fd       	retal	0

800061e8 <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
800061e8:	d4 21       	pushm	r4-r7,lr
800061ea:	18 97       	mov	r7,r12
800061ec:	16 94       	mov	r4,r11
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
800061ee:	58 0b       	cp.w	r11,0
800061f0:	c0 31       	brne	800061f6 <gpio_enable_module+0xe>
800061f2:	30 05       	mov	r5,0
800061f4:	c0 d8       	rjmp	8000620e <gpio_enable_module+0x26>
800061f6:	30 06       	mov	r6,0
800061f8:	0c 95       	mov	r5,r6
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
800061fa:	6e 1b       	ld.w	r11,r7[0x4]
800061fc:	6e 0c       	ld.w	r12,r7[0x0]
800061fe:	f0 1f 00 06 	mcall	80006214 <gpio_enable_module+0x2c>
80006202:	18 45       	or	r5,r12
		gpiomap++;
80006204:	2f 87       	sub	r7,-8
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
80006206:	2f f6       	sub	r6,-1
80006208:	0c 34       	cp.w	r4,r6
8000620a:	fe 9b ff f8 	brhi	800061fa <gpio_enable_module+0x12>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
}
8000620e:	0a 9c       	mov	r12,r5
80006210:	d8 22       	popm	r4-r7,pc
80006212:	00 00       	add	r0,r0
80006214:	80 00       	ld.sh	r0,r0[0x0]
80006216:	61 96       	ld.w	r6,r0[0x64]

80006218 <gpio_set_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_set_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80006218:	f8 08 16 05 	lsr	r8,r12,0x5
8000621c:	a9 68       	lsl	r8,0x8
8000621e:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 1. */
	gpio_port->ovrs  = 1 << (pin & 0x1F);
80006222:	30 19       	mov	r9,1
80006224:	f2 0c 09 4c 	lsl	r12,r9,r12
80006228:	f1 4c 00 54 	st.w	r8[84],r12
	/* The GPIO output driver is enabled for that pin. */ 
	gpio_port->oders = 1 << (pin & 0x1F);
8000622c:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
80006230:	91 1c       	st.w	r8[0x4],r12
}
80006232:	5e fc       	retal	r12

80006234 <gpio_clr_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_clr_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80006234:	f8 08 16 05 	lsr	r8,r12,0x5
80006238:	a9 68       	lsl	r8,0x8
8000623a:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 0. */
	gpio_port->ovrc  = 1 << (pin & 0x1F);
8000623e:	30 19       	mov	r9,1
80006240:	f2 0c 09 4c 	lsl	r12,r9,r12
80006244:	f1 4c 00 58 	st.w	r8[88],r12
	/* The GPIO output driver is enabled for that pin. */
	gpio_port->oders = 1 << (pin & 0x1F);
80006248:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
8000624c:	91 1c       	st.w	r8[0x4],r12
}
8000624e:	5e fc       	retal	r12

80006250 <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
80006250:	c0 08       	rjmp	80006250 <_unhandled_interrupt>
80006252:	d7 03       	nop

80006254 <INTC_register_interrupt>:
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
80006254:	f6 08 16 05 	lsr	r8,r11,0x5

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
80006258:	49 99       	lddpc	r9,800062bc <INTC_register_interrupt+0x68>
8000625a:	f2 08 00 39 	add	r9,r9,r8<<0x3
8000625e:	f7 db c0 05 	bfextu	r11,r11,0x0,0x5
80006262:	72 19       	ld.w	r9,r9[0x4]
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
80006264:	f2 0b 09 2c 	st.w	r9[r11<<0x2],r12
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
80006268:	58 0a       	cp.w	r10,0
8000626a:	c0 91       	brne	8000627c <INTC_register_interrupt+0x28>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
8000626c:	49 59       	lddpc	r9,800062c0 <INTC_register_interrupt+0x6c>
8000626e:	49 6a       	lddpc	r10,800062c4 <INTC_register_interrupt+0x70>
80006270:	12 1a       	sub	r10,r9
80006272:	fe 79 08 00 	mov	r9,-63488
80006276:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
8000627a:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT1) {
8000627c:	58 1a       	cp.w	r10,1
8000627e:	c0 a1       	brne	80006292 <INTC_register_interrupt+0x3e>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
80006280:	49 09       	lddpc	r9,800062c0 <INTC_register_interrupt+0x6c>
80006282:	49 2a       	lddpc	r10,800062c8 <INTC_register_interrupt+0x74>
80006284:	12 1a       	sub	r10,r9
80006286:	bf aa       	sbr	r10,0x1e
80006288:	fe 79 08 00 	mov	r9,-63488
8000628c:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80006290:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT2) {
80006292:	58 2a       	cp.w	r10,2
80006294:	c0 a1       	brne	800062a8 <INTC_register_interrupt+0x54>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
80006296:	48 b9       	lddpc	r9,800062c0 <INTC_register_interrupt+0x6c>
80006298:	48 da       	lddpc	r10,800062cc <INTC_register_interrupt+0x78>
8000629a:	12 1a       	sub	r10,r9
8000629c:	bf ba       	sbr	r10,0x1f
8000629e:	fe 79 08 00 	mov	r9,-63488
800062a2:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800062a6:	5e fc       	retal	r12
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
800062a8:	48 69       	lddpc	r9,800062c0 <INTC_register_interrupt+0x6c>
800062aa:	48 aa       	lddpc	r10,800062d0 <INTC_register_interrupt+0x7c>
800062ac:	12 1a       	sub	r10,r9
800062ae:	ea 1a c0 00 	orh	r10,0xc000
800062b2:	fe 79 08 00 	mov	r9,-63488
800062b6:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800062ba:	5e fc       	retal	r12
800062bc:	80 00       	ld.sh	r0,r0[0x0]
800062be:	eb 1c 80 00 	ld.uh	r12,r5[-32768]
800062c2:	dc 00       	acall	0xc0
800062c4:	80 00       	ld.sh	r0,r0[0x0]
800062c6:	dd 04       	*unknown*
800062c8:	80 00       	ld.sh	r0,r0[0x0]
800062ca:	dd 12       	popm	r0-r3,r11,lr-pc
800062cc:	80 00       	ld.sh	r0,r0[0x0]
800062ce:	dd 20       	acall	0xd2
800062d0:	80 00       	ld.sh	r0,r0[0x0]
800062d2:	dd 2e       	*unknown*

800062d4 <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
800062d4:	d4 21       	pushm	r4-r7,lr
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
800062d6:	49 18       	lddpc	r8,80006318 <INTC_init_interrupts+0x44>
800062d8:	e3 b8 00 01 	mtsr	0x4,r8
800062dc:	49 0e       	lddpc	lr,8000631c <INTC_init_interrupts+0x48>
800062de:	30 07       	mov	r7,0
800062e0:	0e 94       	mov	r4,r7
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
800062e2:	49 0c       	lddpc	r12,80006320 <INTC_init_interrupts+0x4c>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
800062e4:	49 05       	lddpc	r5,80006324 <INTC_init_interrupts+0x50>
800062e6:	10 15       	sub	r5,r8
800062e8:	fe 76 08 00 	mov	r6,-63488
800062ec:	c1 08       	rjmp	8000630c <INTC_init_interrupts+0x38>
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
800062ee:	08 98       	mov	r8,r4
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
				._int_line_handler_table[int_req]
800062f0:	7c 1b       	ld.w	r11,lr[0x4]

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
800062f2:	7c 0a       	ld.w	r10,lr[0x0]
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
800062f4:	f6 08 09 2c 	st.w	r11[r8<<0x2],r12
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
800062f8:	2f f8       	sub	r8,-1

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
800062fa:	10 3a       	cp.w	r10,r8
800062fc:	fe 9b ff fc 	brhi	800062f4 <INTC_init_interrupts+0x20>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80006300:	ec 07 09 25 	st.w	r6[r7<<0x2],r5
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
80006304:	2f f7       	sub	r7,-1
80006306:	2f 8e       	sub	lr,-8
80006308:	59 37       	cp.w	r7,19
8000630a:	c0 50       	breq	80006314 <INTC_init_interrupts+0x40>
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
8000630c:	7c 08       	ld.w	r8,lr[0x0]
8000630e:	58 08       	cp.w	r8,0
80006310:	ce f1       	brne	800062ee <INTC_init_interrupts+0x1a>
80006312:	cf 7b       	rjmp	80006300 <INTC_init_interrupts+0x2c>
80006314:	d8 22       	popm	r4-r7,pc
80006316:	00 00       	add	r0,r0
80006318:	80 00       	ld.sh	r0,r0[0x0]
8000631a:	dc 00       	acall	0xc0
8000631c:	80 00       	ld.sh	r0,r0[0x0]
8000631e:	eb 1c 80 00 	ld.uh	r12,r5[-32768]
80006322:	62 50       	ld.w	r0,r1[0x14]
80006324:	80 00       	ld.sh	r0,r0[0x0]
80006326:	dd 04       	*unknown*

80006328 <_get_interrupt_handler>:
__int_handler _get_interrupt_handler(uint32_t int_level)
{
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
80006328:	fe 78 08 00 	mov	r8,-63488
8000632c:	e0 69 00 83 	mov	r9,131
80006330:	f2 0c 01 0c 	sub	r12,r9,r12
80006334:	f0 0c 03 29 	ld.w	r9,r8[r12<<0x2]
	uint32_t int_req = AVR32_INTC.irr[int_grp];
80006338:	f2 ca ff c0 	sub	r10,r9,-64
8000633c:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
80006340:	58 08       	cp.w	r8,0
80006342:	c0 21       	brne	80006346 <_get_interrupt_handler+0x1e>
80006344:	5e fd       	retal	0
		? _int_handler_table[int_grp]._int_line_handler_table[32
80006346:	f0 08 12 00 	clz	r8,r8
8000634a:	48 5a       	lddpc	r10,8000635c <_get_interrupt_handler+0x34>
8000634c:	f4 09 00 39 	add	r9,r10,r9<<0x3
80006350:	f0 08 11 1f 	rsub	r8,r8,31
80006354:	72 19       	ld.w	r9,r9[0x4]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
80006356:	f2 08 03 2c 	ld.w	r12,r9[r8<<0x2]
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
8000635a:	5e fc       	retal	r12
8000635c:	80 00       	ld.sh	r0,r0[0x0]
8000635e:	eb 1c 78 a8 	ld.uh	r12,r5[30888]

80006360 <pm_set_osc0_mode>:
 * \param mode Oscillator 0 mode (i.e. AVR32_PM_OSCCTRL0_MODE_x).
 */
static void pm_set_osc0_mode(volatile avr32_pm_t *pm, unsigned int mode)
{
  // Read
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
80006360:	78 a8       	ld.w	r8,r12[0x28]
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.mode = mode;
80006362:	f1 db d0 03 	bfins	r8,r11,0x0,0x3
  // Write
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
80006366:	99 a8       	st.w	r12[0x28],r8
}
80006368:	5e fc       	retal	r12
8000636a:	d7 03       	nop

8000636c <pm_enable_osc0_crystal>:
  pm_set_osc0_mode(pm, AVR32_PM_OSCCTRL0_MODE_EXT_CLOCK);
}


void pm_enable_osc0_crystal(volatile avr32_pm_t *pm, unsigned int fosc0)
{
8000636c:	d4 01       	pushm	lr
  pm_set_osc0_mode(pm, (fosc0 <  900000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G0 :
8000636e:	ec 5b bb 9f 	cp.w	r11,899999
80006372:	e0 8b 00 04 	brhi	8000637a <pm_enable_osc0_crystal+0xe>
80006376:	30 4b       	mov	r11,4
80006378:	c1 38       	rjmp	8000639e <pm_enable_osc0_crystal+0x32>
8000637a:	e0 68 c6 bf 	mov	r8,50879
8000637e:	ea 18 00 2d 	orh	r8,0x2d
80006382:	10 3b       	cp.w	r11,r8
80006384:	e0 8b 00 04 	brhi	8000638c <pm_enable_osc0_crystal+0x20>
80006388:	30 5b       	mov	r11,5
8000638a:	c0 a8       	rjmp	8000639e <pm_enable_osc0_crystal+0x32>
8000638c:	e0 68 12 00 	mov	r8,4608
80006390:	ea 18 00 7a 	orh	r8,0x7a
80006394:	10 3b       	cp.w	r11,r8
80006396:	f9 bb 03 06 	movlo	r11,6
8000639a:	f9 bb 02 07 	movhs	r11,7
8000639e:	f0 1f 00 02 	mcall	800063a4 <pm_enable_osc0_crystal+0x38>
                       (fosc0 < 3000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G1 :
                       (fosc0 < 8000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G2 :
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}
800063a2:	d8 02       	popm	pc
800063a4:	80 00       	ld.sh	r0,r0[0x0]
800063a6:	63 60       	ld.w	r0,r1[0x58]

800063a8 <pm_enable_clk0_no_wait>:


void pm_enable_clk0_no_wait(volatile avr32_pm_t *pm, unsigned int startup)
{
  // Read register
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
800063a8:	78 a8       	ld.w	r8,r12[0x28]
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.startup = startup;
800063aa:	f1 db d1 03 	bfins	r8,r11,0x8,0x3
  // Write back
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
800063ae:	99 a8       	st.w	r12[0x28],r8

  pm->mcctrl |= AVR32_PM_MCCTRL_OSC0EN_MASK;
800063b0:	78 08       	ld.w	r8,r12[0x0]
800063b2:	a3 a8       	sbr	r8,0x2
800063b4:	99 08       	st.w	r12[0x0],r8
}
800063b6:	5e fc       	retal	r12

800063b8 <pm_wait_for_clk0_ready>:


void pm_wait_for_clk0_ready(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
800063b8:	79 58       	ld.w	r8,r12[0x54]
800063ba:	e2 18 00 80 	andl	r8,0x80,COH
800063be:	cf d0       	breq	800063b8 <pm_wait_for_clk0_ready>
}
800063c0:	5e fc       	retal	r12
800063c2:	d7 03       	nop

800063c4 <pm_enable_clk0>:
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}


void pm_enable_clk0(volatile avr32_pm_t *pm, unsigned int startup)
{
800063c4:	eb cd 40 80 	pushm	r7,lr
800063c8:	18 97       	mov	r7,r12
  pm_enable_clk0_no_wait(pm, startup);
800063ca:	f0 1f 00 04 	mcall	800063d8 <pm_enable_clk0+0x14>
  pm_wait_for_clk0_ready(pm);
800063ce:	0e 9c       	mov	r12,r7
800063d0:	f0 1f 00 03 	mcall	800063dc <pm_enable_clk0+0x18>
}
800063d4:	e3 cd 80 80 	ldm	sp++,r7,pc
800063d8:	80 00       	ld.sh	r0,r0[0x0]
800063da:	63 a8       	ld.w	r8,r1[0x68]
800063dc:	80 00       	ld.sh	r0,r0[0x0]
800063de:	63 b8       	ld.w	r8,r1[0x6c]

800063e0 <pm_set_osc32_mode>:
 * \param mode 32-kHz oscillator mode (i.e. AVR32_PM_OSCCTRL32_MODE_x).
 */
static void pm_set_osc32_mode(volatile avr32_pm_t *pm, unsigned int mode)
{
  // Read
  u_avr32_pm_oscctrl32_t u_avr32_pm_oscctrl32 = {pm->oscctrl32};
800063e0:	78 c8       	ld.w	r8,r12[0x30]
  // Modify
  u_avr32_pm_oscctrl32.OSCCTRL32.mode = mode;
800063e2:	f1 db d1 03 	bfins	r8,r11,0x8,0x3
  // Write
  pm->oscctrl32 = u_avr32_pm_oscctrl32.oscctrl32;
800063e6:	99 c8       	st.w	r12[0x30],r8
}
800063e8:	5e fc       	retal	r12
800063ea:	d7 03       	nop

800063ec <pm_enable_osc32_crystal>:
  pm_set_osc32_mode(pm, AVR32_PM_OSCCTRL32_MODE_EXT_CLOCK);
}


void pm_enable_osc32_crystal(volatile avr32_pm_t *pm)
{
800063ec:	d4 01       	pushm	lr
  pm_set_osc32_mode(pm, AVR32_PM_OSCCTRL32_MODE_CRYSTAL);
800063ee:	30 1b       	mov	r11,1
800063f0:	f0 1f 00 02 	mcall	800063f8 <pm_enable_osc32_crystal+0xc>
}
800063f4:	d8 02       	popm	pc
800063f6:	00 00       	add	r0,r0
800063f8:	80 00       	ld.sh	r0,r0[0x0]
800063fa:	63 e0       	ld.w	r0,r1[0x78]

800063fc <pm_enable_clk32_no_wait>:


void pm_enable_clk32_no_wait(volatile avr32_pm_t *pm, unsigned int startup)
{
  // Read register
  u_avr32_pm_oscctrl32_t u_avr32_pm_oscctrl32 = {pm->oscctrl32};
800063fc:	78 c8       	ld.w	r8,r12[0x30]
  // Modify
  u_avr32_pm_oscctrl32.OSCCTRL32.osc32en = 1;
800063fe:	30 19       	mov	r9,1
80006400:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
  u_avr32_pm_oscctrl32.OSCCTRL32.startup = startup;
80006404:	f1 db d2 03 	bfins	r8,r11,0x10,0x3
  // Write back
  pm->oscctrl32 = u_avr32_pm_oscctrl32.oscctrl32;
80006408:	99 c8       	st.w	r12[0x30],r8
}
8000640a:	5e fc       	retal	r12

8000640c <pm_wait_for_clk32_ready>:


void pm_wait_for_clk32_ready(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_OSC32RDY_MASK));
8000640c:	79 58       	ld.w	r8,r12[0x54]
8000640e:	e2 18 02 00 	andl	r8,0x200,COH
80006412:	cf d0       	breq	8000640c <pm_wait_for_clk32_ready>
}
80006414:	5e fc       	retal	r12
80006416:	d7 03       	nop

80006418 <pm_enable_clk32>:
  pm_set_osc32_mode(pm, AVR32_PM_OSCCTRL32_MODE_CRYSTAL);
}


void pm_enable_clk32(volatile avr32_pm_t *pm, unsigned int startup)
{
80006418:	eb cd 40 80 	pushm	r7,lr
8000641c:	18 97       	mov	r7,r12
  pm_enable_clk32_no_wait(pm, startup);
8000641e:	f0 1f 00 04 	mcall	8000642c <pm_enable_clk32+0x14>
  pm_wait_for_clk32_ready(pm);
80006422:	0e 9c       	mov	r12,r7
80006424:	f0 1f 00 03 	mcall	80006430 <pm_enable_clk32+0x18>
}
80006428:	e3 cd 80 80 	ldm	sp++,r7,pc
8000642c:	80 00       	ld.sh	r0,r0[0x0]
8000642e:	63 fc       	ld.w	r12,r1[0x7c]
80006430:	80 00       	ld.sh	r0,r0[0x0]
80006432:	64 0c       	ld.w	r12,r2[0x0]

80006434 <pm_cksel>:
              unsigned int pbasel,
              unsigned int pbbdiv,
              unsigned int pbbsel,
              unsigned int hsbdiv,
              unsigned int hsbsel)
{
80006434:	eb cd 40 d0 	pushm	r4,r6-r7,lr
80006438:	fa c4 ff f0 	sub	r4,sp,-16
  u_avr32_pm_cksel_t u_avr32_pm_cksel = {0};
8000643c:	30 0e       	mov	lr,0

  u_avr32_pm_cksel.CKSEL.cpusel = hsbsel;
8000643e:	09 f7       	ld.ub	r7,r4[0x7]
80006440:	ef d7 c0 03 	bfextu	r7,r7,0x0,0x3
80006444:	fd d7 d0 03 	bfins	lr,r7,0x0,0x3
  u_avr32_pm_cksel.CKSEL.cpudiv = hsbdiv;
80006448:	09 b4       	ld.ub	r4,r4[0x3]
8000644a:	08 96       	mov	r6,r4
8000644c:	e9 d4 c0 01 	bfextu	r4,r4,0x0,0x1
80006450:	fd d4 d0 e1 	bfins	lr,r4,0x7,0x1
  u_avr32_pm_cksel.CKSEL.hsbsel = hsbsel;
80006454:	fd d7 d1 03 	bfins	lr,r7,0x8,0x3
  u_avr32_pm_cksel.CKSEL.hsbdiv = hsbdiv;
80006458:	fd d4 d1 e1 	bfins	lr,r4,0xf,0x1
  u_avr32_pm_cksel.CKSEL.pbasel = pbasel;
8000645c:	fd da d2 03 	bfins	lr,r10,0x10,0x3
  u_avr32_pm_cksel.CKSEL.pbadiv = pbadiv;
80006460:	fd db d2 e1 	bfins	lr,r11,0x17,0x1
  u_avr32_pm_cksel.CKSEL.pbbsel = pbbsel;
80006464:	fd d8 d3 03 	bfins	lr,r8,0x18,0x3
  u_avr32_pm_cksel.CKSEL.pbbdiv = pbbdiv;
80006468:	fd d9 d3 e1 	bfins	lr,r9,0x1f,0x1

  pm->cksel = u_avr32_pm_cksel.cksel;
8000646c:	99 1e       	st.w	r12[0x4],lr

  // Wait for ckrdy bit and then clear it
  while (!(pm->poscsr & AVR32_PM_POSCSR_CKRDY_MASK));
8000646e:	79 58       	ld.w	r8,r12[0x54]
80006470:	e2 18 00 20 	andl	r8,0x20,COH
80006474:	cf d0       	breq	8000646e <pm_cksel+0x3a>
}
80006476:	e3 cd 80 d0 	ldm	sp++,r4,r6-r7,pc

8000647a <pm_pll_setup>:
                  unsigned int pll,
                  unsigned int mul,
                  unsigned int div,
                  unsigned int osc,
                  unsigned int lockcount)
{
8000647a:	eb cd 40 80 	pushm	r7,lr
8000647e:	40 27       	lddsp	r7,sp[0x8]
  u_avr32_pm_pll_t u_avr32_pm_pll = {0};
80006480:	30 0e       	mov	lr,0

  u_avr32_pm_pll.PLL.pllosc   = osc;
80006482:	fd d8 d0 21 	bfins	lr,r8,0x1,0x1
  u_avr32_pm_pll.PLL.plldiv   = div;
80006486:	fd d9 d1 04 	bfins	lr,r9,0x8,0x4
  u_avr32_pm_pll.PLL.pllmul   = mul;
8000648a:	fd da d2 04 	bfins	lr,r10,0x10,0x4
  u_avr32_pm_pll.PLL.pllcount = lockcount;
8000648e:	fd d7 d3 06 	bfins	lr,r7,0x18,0x6

  pm->pll[pll] = u_avr32_pm_pll.pll;
80006492:	2f 8b       	sub	r11,-8
80006494:	f8 0b 09 2e 	st.w	r12[r11<<0x2],lr
}
80006498:	e3 cd 80 80 	ldm	sp++,r7,pc

8000649c <pm_pll_set_option>:
void pm_pll_set_option(volatile avr32_pm_t *pm,
                       unsigned int pll,
                       unsigned int pll_freq,
                       unsigned int pll_div2,
                       unsigned int pll_wbwdisable)
{
8000649c:	d4 01       	pushm	lr
  u_avr32_pm_pll_t u_avr32_pm_pll = {pm->pll[pll]};
8000649e:	2f 8b       	sub	r11,-8
800064a0:	f8 0b 03 2e 	ld.w	lr,r12[r11<<0x2]
  u_avr32_pm_pll.PLL.pllopt = pll_freq | (pll_div2 << 1) | (pll_wbwdisable << 2);
800064a4:	f5 e9 10 19 	or	r9,r10,r9<<0x1
800064a8:	f3 e8 10 28 	or	r8,r9,r8<<0x2
800064ac:	fd d8 d0 43 	bfins	lr,r8,0x2,0x3
  pm->pll[pll] = u_avr32_pm_pll.pll;
800064b0:	f8 0b 09 2e 	st.w	r12[r11<<0x2],lr
}
800064b4:	d8 02       	popm	pc

800064b6 <pm_pll_enable>:


void pm_pll_enable(volatile avr32_pm_t *pm,
                  unsigned int pll)
{
  pm->pll[pll] |= AVR32_PM_PLLEN_MASK;
800064b6:	2f 8b       	sub	r11,-8
800064b8:	f8 0b 03 28 	ld.w	r8,r12[r11<<0x2]
800064bc:	a1 a8       	sbr	r8,0x0
800064be:	f8 0b 09 28 	st.w	r12[r11<<0x2],r8
}
800064c2:	5e fc       	retal	r12

800064c4 <pm_wait_for_pll0_locked>:
}


void pm_wait_for_pll0_locked(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_LOCK0_MASK));
800064c4:	79 58       	ld.w	r8,r12[0x54]
800064c6:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800064ca:	cf d0       	breq	800064c4 <pm_wait_for_pll0_locked>
}
800064cc:	5e fc       	retal	r12

800064ce <pm_switch_to_clock>:


void pm_switch_to_clock(volatile avr32_pm_t *pm, unsigned long clock)
{
  // Read
  u_avr32_pm_mcctrl_t u_avr32_pm_mcctrl = {pm->mcctrl};
800064ce:	78 08       	ld.w	r8,r12[0x0]
  // Modify
  u_avr32_pm_mcctrl.MCCTRL.mcsel = clock;
800064d0:	f1 db d0 02 	bfins	r8,r11,0x0,0x2
  // Write back
  pm->mcctrl = u_avr32_pm_mcctrl.mcctrl;
800064d4:	99 08       	st.w	r12[0x0],r8
}
800064d6:	5e fc       	retal	r12

800064d8 <pm_switch_to_osc0>:


void pm_switch_to_osc0(volatile avr32_pm_t *pm, unsigned int fosc0, unsigned int startup)
{
800064d8:	eb cd 40 c0 	pushm	r6-r7,lr
800064dc:	18 97       	mov	r7,r12
800064de:	14 96       	mov	r6,r10
  pm_enable_osc0_crystal(pm, fosc0);            // Enable the Osc0 in crystal mode
800064e0:	f0 1f 00 06 	mcall	800064f8 <pm_switch_to_osc0+0x20>
  pm_enable_clk0(pm, startup);                  // Crystal startup time - This parameter is critical and depends on the characteristics of the crystal
800064e4:	0c 9b       	mov	r11,r6
800064e6:	0e 9c       	mov	r12,r7
800064e8:	f0 1f 00 05 	mcall	800064fc <pm_switch_to_osc0+0x24>
  pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);  // Then switch main clock to Osc0
800064ec:	30 1b       	mov	r11,1
800064ee:	0e 9c       	mov	r12,r7
800064f0:	f0 1f 00 04 	mcall	80006500 <pm_switch_to_osc0+0x28>
}
800064f4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800064f8:	80 00       	ld.sh	r0,r0[0x0]
800064fa:	63 6c       	ld.w	r12,r1[0x58]
800064fc:	80 00       	ld.sh	r0,r0[0x0]
800064fe:	63 c4       	ld.w	r4,r1[0x70]
80006500:	80 00       	ld.sh	r0,r0[0x0]
80006502:	64 ce       	ld.w	lr,r2[0x30]

80006504 <rtc_is_busy>:
#include "rtc.h"


int rtc_is_busy(volatile avr32_rtc_t *rtc)
{
  return (rtc->ctrl & AVR32_RTC_CTRL_BUSY_MASK) != 0;
80006504:	78 0c       	ld.w	r12,r12[0x0]
}
80006506:	f9 dc c0 81 	bfextu	r12,r12,0x4,0x1
8000650a:	5e fc       	retal	r12

8000650c <rtc_set_value>:
  return 1;
}


void rtc_set_value(volatile avr32_rtc_t *rtc, unsigned long val)
{
8000650c:	eb cd 40 c0 	pushm	r6-r7,lr
80006510:	18 97       	mov	r7,r12
80006512:	16 96       	mov	r6,r11
  // Wait until we can write into the VAL register
  while (rtc_is_busy(rtc));
80006514:	0e 9c       	mov	r12,r7
80006516:	f0 1f 00 06 	mcall	8000652c <rtc_set_value+0x20>
8000651a:	cf d1       	brne	80006514 <rtc_set_value+0x8>
  // Set the new val value
  rtc->val = val;
8000651c:	8f 16       	st.w	r7[0x4],r6
  // Wait until write is done
  while (rtc_is_busy(rtc));
8000651e:	0e 9c       	mov	r12,r7
80006520:	f0 1f 00 03 	mcall	8000652c <rtc_set_value+0x20>
80006524:	cf d1       	brne	8000651e <rtc_set_value+0x12>
}
80006526:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000652a:	00 00       	add	r0,r0
8000652c:	80 00       	ld.sh	r0,r0[0x0]
8000652e:	65 04       	ld.w	r4,r2[0x40]

80006530 <rtc_enable>:
  while (rtc_is_busy(rtc));
}


void rtc_enable(volatile avr32_rtc_t *rtc)
{
80006530:	eb cd 40 80 	pushm	r7,lr
80006534:	18 97       	mov	r7,r12
  // Wait until the rtc CTRL register is up-to-date
  while (rtc_is_busy(rtc));
80006536:	0e 9c       	mov	r12,r7
80006538:	f0 1f 00 06 	mcall	80006550 <rtc_enable+0x20>
8000653c:	cf d1       	brne	80006536 <rtc_enable+0x6>
  // Enable the RTC
  rtc->ctrl |= AVR32_RTC_CTRL_EN_MASK;
8000653e:	6e 08       	ld.w	r8,r7[0x0]
80006540:	a1 a8       	sbr	r8,0x0
80006542:	8f 08       	st.w	r7[0x0],r8
  // Wait until write is done
  while (rtc_is_busy(rtc));
80006544:	0e 9c       	mov	r12,r7
80006546:	f0 1f 00 03 	mcall	80006550 <rtc_enable+0x20>
8000654a:	cf d1       	brne	80006544 <rtc_enable+0x14>
}
8000654c:	e3 cd 80 80 	ldm	sp++,r7,pc
80006550:	80 00       	ld.sh	r0,r0[0x0]
80006552:	65 04       	ld.w	r4,r2[0x40]

80006554 <rtc_enable_interrupt>:
}


void rtc_enable_interrupt(volatile avr32_rtc_t *rtc)
{
  rtc->ier = AVR32_RTC_IER_TOPI_MASK;
80006554:	30 18       	mov	r8,1
80006556:	99 48       	st.w	r12[0x10],r8
}
80006558:	5e fc       	retal	r12
8000655a:	d7 03       	nop

8000655c <rtc_set_top_value>:
  if (global_interrupt_enabled) cpu_irq_enable();
}


void rtc_set_top_value(volatile avr32_rtc_t *rtc, unsigned long top)
{
8000655c:	eb cd 40 c0 	pushm	r6-r7,lr
80006560:	18 97       	mov	r7,r12
80006562:	16 96       	mov	r6,r11
  // Wait until we can write into the VAL register
  while (rtc_is_busy(rtc));
80006564:	0e 9c       	mov	r12,r7
80006566:	f0 1f 00 06 	mcall	8000657c <rtc_set_top_value+0x20>
8000656a:	cf d1       	brne	80006564 <rtc_set_top_value+0x8>
  // Set the new val value
  rtc->top = top;
8000656c:	8f 26       	st.w	r7[0x8],r6
  // Wait until write is done
  while (rtc_is_busy(rtc));
8000656e:	0e 9c       	mov	r12,r7
80006570:	f0 1f 00 03 	mcall	8000657c <rtc_set_top_value+0x20>
80006574:	cf d1       	brne	8000656e <rtc_set_top_value+0x12>
}
80006576:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000657a:	00 00       	add	r0,r0
8000657c:	80 00       	ld.sh	r0,r0[0x0]
8000657e:	65 04       	ld.w	r4,r2[0x40]

80006580 <rtc_clear_interrupt>:
}


void rtc_clear_interrupt(volatile avr32_rtc_t *rtc)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
80006580:	e1 b8 00 00 	mfsr	r8,0x0

  if (global_interrupt_enabled) cpu_irq_disable();
80006584:	e6 18 00 01 	andh	r8,0x1,COH
80006588:	c0 71       	brne	80006596 <rtc_clear_interrupt+0x16>
8000658a:	d3 03       	ssrf	0x10
  rtc->icr = AVR32_RTC_ICR_TOPI_MASK;
8000658c:	30 18       	mov	r8,1
8000658e:	99 88       	st.w	r12[0x20],r8
  rtc->isr;
80006590:	78 78       	ld.w	r8,r12[0x1c]
  if (global_interrupt_enabled) cpu_irq_enable();
80006592:	d5 03       	csrf	0x10
80006594:	5e fc       	retal	r12
void rtc_clear_interrupt(volatile avr32_rtc_t *rtc)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  if (global_interrupt_enabled) cpu_irq_disable();
  rtc->icr = AVR32_RTC_ICR_TOPI_MASK;
80006596:	30 18       	mov	r8,1
80006598:	99 88       	st.w	r12[0x20],r8
  rtc->isr;
8000659a:	78 78       	ld.w	r8,r12[0x1c]
8000659c:	5e fc       	retal	r12
8000659e:	d7 03       	nop

800065a0 <rtc_init>:
  return (rtc->ctrl & AVR32_RTC_CTRL_BUSY_MASK) != 0;
}


int rtc_init(volatile avr32_rtc_t *rtc, unsigned char osc_type, unsigned char psel)
{
800065a0:	eb cd 40 e0 	pushm	r5-r7,lr
800065a4:	18 97       	mov	r7,r12
800065a6:	16 96       	mov	r6,r11
800065a8:	14 95       	mov	r5,r10
  // If exit, it means that the configuration has not been set correctly
  if (osc_type > (1 << AVR32_RTC_CTRL_CLK32_SIZE) - 1 ||
800065aa:	30 18       	mov	r8,1
800065ac:	f0 0b 18 00 	cp.b	r11,r8
800065b0:	5f b9       	srhi	r9
800065b2:	30 f8       	mov	r8,15
800065b4:	f0 0a 18 00 	cp.b	r10,r8
800065b8:	5f b8       	srhi	r8
800065ba:	f3 e8 10 08 	or	r8,r9,r8
800065be:	c0 30       	breq	800065c4 <rtc_init+0x24>
800065c0:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
      psel > (1 << AVR32_RTC_CTRL_PSEL_SIZE) - 1)
    return 0;

  // If we use the 32-kHz oscillator, we have to enable it first
  if (osc_type == RTC_OSC_32KHZ)
800065c4:	30 18       	mov	r8,1
800065c6:	f0 0b 18 00 	cp.b	r11,r8
800065ca:	c0 a1       	brne	800065de <rtc_init+0x3e>
  {
    // Select the 32-kHz oscillator crystal
    pm_enable_osc32_crystal(&AVR32_PM);
800065cc:	fe 7c 0c 00 	mov	r12,-62464
800065d0:	f0 1f 00 0f 	mcall	8000660c <rtc_init+0x6c>
    // Enable the 32-kHz clock and wait until the osc32 clock is ready.
    pm_enable_clk32(&AVR32_PM, AVR32_PM_OSCCTRL32_STARTUP_0_RCOSC);
800065d4:	30 0b       	mov	r11,0
800065d6:	fe 7c 0c 00 	mov	r12,-62464
800065da:	f0 1f 00 0e 	mcall	80006610 <rtc_init+0x70>
  }

  // Wait until the rtc accepts writes to the CTRL register
  while (rtc_is_busy(rtc));
800065de:	0e 9c       	mov	r12,r7
800065e0:	f0 1f 00 0d 	mcall	80006614 <rtc_init+0x74>
800065e4:	cf d1       	brne	800065de <rtc_init+0x3e>

  // Set the new RTC configuration
  rtc->ctrl = osc_type << AVR32_RTC_CTRL_CLK32_OFFSET |
800065e6:	a3 76       	lsl	r6,0x3
800065e8:	b1 a6       	sbr	r6,0x10
800065ea:	ed e5 10 85 	or	r5,r6,r5<<0x8
800065ee:	8f 05       	st.w	r7[0x0],r5
              psel << AVR32_RTC_CTRL_PSEL_OFFSET |
              AVR32_RTC_CTRL_CLKEN_MASK;

  // Wait until write is done
  while (rtc_is_busy(rtc));
800065f0:	0e 9c       	mov	r12,r7
800065f2:	f0 1f 00 09 	mcall	80006614 <rtc_init+0x74>
800065f6:	cf d1       	brne	800065f0 <rtc_init+0x50>

  // Set the counter value to 0
  rtc_set_value(rtc, 0x00000000);
800065f8:	30 0b       	mov	r11,0
800065fa:	0e 9c       	mov	r12,r7
800065fc:	f0 1f 00 07 	mcall	80006618 <rtc_init+0x78>
  // Set the top value to 0xFFFFFFFF
  rtc_set_top_value(rtc, 0xFFFFFFFF);
80006600:	3f fb       	mov	r11,-1
80006602:	0e 9c       	mov	r12,r7
80006604:	f0 1f 00 06 	mcall	8000661c <rtc_init+0x7c>
80006608:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
8000660c:	80 00       	ld.sh	r0,r0[0x0]
8000660e:	63 ec       	ld.w	r12,r1[0x78]
80006610:	80 00       	ld.sh	r0,r0[0x0]
80006612:	64 18       	ld.w	r8,r2[0x4]
80006614:	80 00       	ld.sh	r0,r0[0x0]
80006616:	65 04       	ld.w	r4,r2[0x40]
80006618:	80 00       	ld.sh	r0,r0[0x0]
8000661a:	65 0c       	ld.w	r12,r2[0x40]
8000661c:	80 00       	ld.sh	r0,r0[0x0]
8000661e:	65 5c       	ld.w	r12,r2[0x54]

80006620 <getBaudDiv>:
xSemaphoreHandle xSPIMutex;
#endif

int16_t getBaudDiv(const uint32_t baudrate, uint32_t pb_hz)
{
	uint32_t baudDiv = div_ceil(pb_hz, baudrate);
80006620:	f8 c8 00 01 	sub	r8,r12,1
80006624:	f0 0b 00 0b 	add	r11,r8,r11
80006628:	f6 0c 0d 0a 	divu	r10,r11,r12
8000662c:	14 9c       	mov	r12,r10

	if (baudDiv <= 0 || baudDiv > 255) {
8000662e:	f4 c8 00 01 	sub	r8,r10,1
80006632:	e0 48 00 fe 	cp.w	r8,254
80006636:	e0 88 00 03 	brls	8000663c <getBaudDiv+0x1c>
8000663a:	5e fe       	retal	-1
		return -1;
	}

	return baudDiv;
8000663c:	5c 8c       	casts.h	r12
}
8000663e:	5e fc       	retal	r12

80006640 <spi_initMaster>:
spi_status_t spi_initMaster(volatile avr32_spi_t *spi,
		const spi_options_t *options)
{
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (options->modfdis > 1) {
80006640:	f7 39 00 0d 	ld.ub	r9,r11[13]
80006644:	30 18       	mov	r8,1
80006646:	f0 09 18 00 	cp.b	r9,r8
8000664a:	e0 88 00 04 	brls	80006652 <spi_initMaster+0x12>
8000664e:	30 2c       	mov	r12,2
80006650:	5e fc       	retal	r12
		return SPI_ERROR_ARGUMENT;
	}

	/* Reset. */
	spi->cr = AVR32_SPI_CR_SWRST_MASK;
80006652:	e0 68 00 80 	mov	r8,128
80006656:	99 08       	st.w	r12[0x0],r8

	/* Master Mode. */
	u_avr32_spi_mr.mr = spi->mr;
80006658:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.mstr = 1;
8000665a:	30 19       	mov	r9,1
8000665c:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_mr.MR.modfdis = options->modfdis;
80006660:	f7 39 00 0d 	ld.ub	r9,r11[13]
80006664:	f1 d9 d0 81 	bfins	r8,r9,0x4,0x1
	u_avr32_spi_mr.MR.llb = 0;
80006668:	30 09       	mov	r9,0
8000666a:	f1 d9 d0 e1 	bfins	r8,r9,0x7,0x1
	u_avr32_spi_mr.MR.pcs = (1 << AVR32_SPI_MR_PCS_SIZE) - 1;
8000666e:	30 fa       	mov	r10,15
80006670:	f1 da d2 04 	bfins	r8,r10,0x10,0x4
	spi->mr = u_avr32_spi_mr.mr;
80006674:	99 18       	st.w	r12[0x4],r8
80006676:	5e f9       	retal	r9

80006678 <spi_selectionMode>:

spi_status_t spi_selectionMode(volatile avr32_spi_t *spi,
		uint8_t variable_ps,
		uint8_t pcs_decode,
		uint8_t delay)
{
80006678:	d4 01       	pushm	lr
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (variable_ps > 1 ||
8000667a:	30 18       	mov	r8,1
8000667c:	f0 0b 18 00 	cp.b	r11,r8
80006680:	5f be       	srhi	lr
80006682:	f0 0a 18 00 	cp.b	r10,r8
80006686:	5f b8       	srhi	r8
80006688:	fd e8 10 08 	or	r8,lr,r8
8000668c:	c0 30       	breq	80006692 <spi_selectionMode+0x1a>
8000668e:	30 2c       	mov	r12,2
80006690:	d8 02       	popm	pc
			pcs_decode > 1) {
		return SPI_ERROR_ARGUMENT;
	}

	u_avr32_spi_mr.mr = spi->mr;
80006692:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.ps = variable_ps;
80006694:	f1 db d0 21 	bfins	r8,r11,0x1,0x1
	u_avr32_spi_mr.MR.pcsdec = pcs_decode;
80006698:	f1 da d0 41 	bfins	r8,r10,0x2,0x1
	u_avr32_spi_mr.MR.dlybcs = delay;
8000669c:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8
	spi->mr = u_avr32_spi_mr.mr;
800066a0:	99 18       	st.w	r12[0x4],r8
800066a2:	d8 0a       	popm	pc,r12=0

800066a4 <spi_enable>:
	return SPI_OK;
}

void spi_enable(volatile avr32_spi_t *spi)
{
	spi->cr = AVR32_SPI_CR_SPIEN_MASK;
800066a4:	30 18       	mov	r8,1
800066a6:	99 08       	st.w	r12[0x0],r8
}
800066a8:	5e fc       	retal	r12

800066aa <spi_write>:
{
	return ((spi->sr & AVR32_SPI_SR_TDRE_MASK) != 0);
}

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
800066aa:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
800066ae:	c0 58       	rjmp	800066b8 <spi_write+0xe>
		if (!timeout--) {
800066b0:	58 08       	cp.w	r8,0
800066b2:	c0 21       	brne	800066b6 <spi_write+0xc>
800066b4:	5e ff       	retal	1
800066b6:	20 18       	sub	r8,1

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
800066b8:	78 49       	ld.w	r9,r12[0x10]
800066ba:	e2 19 00 02 	andl	r9,0x2,COH
800066be:	cf 90       	breq	800066b0 <spi_write+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	spi->tdr = data << AVR32_SPI_TDR_TD_OFFSET;
800066c0:	5c 7b       	castu.h	r11
800066c2:	99 3b       	st.w	r12[0xc],r11
800066c4:	5e fd       	retal	0

800066c6 <spi_read>:
{
	return ((spi->sr & AVR32_SPI_SR_RDRF_MASK) != 0);
}

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
800066c6:	e0 68 3a 98 	mov	r8,15000
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
800066ca:	c0 58       	rjmp	800066d4 <spi_read+0xe>
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) !=
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) {
		if (!timeout--) {
800066cc:	58 08       	cp.w	r8,0
800066ce:	c0 21       	brne	800066d2 <spi_read+0xc>
800066d0:	5e ff       	retal	1
800066d2:	20 18       	sub	r8,1

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
800066d4:	78 49       	ld.w	r9,r12[0x10]
800066d6:	e2 19 02 01 	andl	r9,0x201,COH
800066da:	e0 49 02 01 	cp.w	r9,513
800066de:	cf 71       	brne	800066cc <spi_read+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	*data = spi->rdr >> AVR32_SPI_RDR_RD_OFFSET;
800066e0:	78 28       	ld.w	r8,r12[0x8]
800066e2:	b6 08       	st.h	r11[0x0],r8
800066e4:	5e fd       	retal	0
800066e6:	d7 03       	nop

800066e8 <spi_setupChipReg>:
}

spi_status_t spi_setupChipReg(volatile avr32_spi_t *spi,
		const spi_options_t *options,
		uint32_t pb_hz)
{
800066e8:	eb cd 40 f8 	pushm	r3-r7,lr
800066ec:	18 95       	mov	r5,r12
800066ee:	16 97       	mov	r7,r11
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
800066f0:	f7 36 00 0c 	ld.ub	r6,r11[12]
800066f4:	30 38       	mov	r8,3
800066f6:	f0 06 18 00 	cp.b	r6,r8
800066fa:	e0 8b 00 5e 	brhi	800067b6 <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
800066fe:	f7 34 00 0b 	ld.ub	r4,r11[11]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
80006702:	30 18       	mov	r8,1
80006704:	f0 04 18 00 	cp.b	r4,r8
80006708:	e0 8b 00 57 	brhi	800067b6 <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
8000670c:	f7 33 00 08 	ld.ub	r3,r11[8]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
80006710:	30 78       	mov	r8,7
80006712:	f0 03 18 00 	cp.b	r3,r8
80006716:	e0 88 00 50 	brls	800067b6 <spi_setupChipReg+0xce>
8000671a:	31 08       	mov	r8,16
8000671c:	f0 03 18 00 	cp.b	r3,r8
80006720:	e0 8b 00 4b 	brhi	800067b6 <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
		return SPI_ERROR_ARGUMENT;
	}

	int baudDiv = getBaudDiv(options->baudrate, pb_hz);
80006724:	14 9b       	mov	r11,r10
80006726:	6e 1c       	ld.w	r12,r7[0x4]
80006728:	f0 1f 00 26 	mcall	800067c0 <spi_setupChipReg+0xd8>

	if (baudDiv < 0) {
8000672c:	c4 55       	brlt	800067b6 <spi_setupChipReg+0xce>
		return SPI_ERROR_ARGUMENT;
	}

	/* Will use CSR0 offsets; these are the same for CSR0 to CSR3. */
	u_avr32_spi_csr.csr = 0;
8000672e:	30 08       	mov	r8,0
	u_avr32_spi_csr.CSR.cpol   = options->spi_mode >> 1;
80006730:	ec 09 16 01 	lsr	r9,r6,0x1
80006734:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_csr.CSR.ncpha  = (options->spi_mode & 0x1) ^ 0x1;
80006738:	ec 16 00 01 	eorl	r6,0x1
8000673c:	f1 d6 d0 21 	bfins	r8,r6,0x1,0x1
	u_avr32_spi_csr.CSR.csaat  = options->stay_act;
80006740:	f1 d4 d0 61 	bfins	r8,r4,0x3,0x1
	u_avr32_spi_csr.CSR.bits   = options->bits - 8;
80006744:	20 83       	sub	r3,8
80006746:	f1 d3 d0 84 	bfins	r8,r3,0x4,0x4
	u_avr32_spi_csr.CSR.scbr   = baudDiv;
8000674a:	f1 dc d1 08 	bfins	r8,r12,0x8,0x8
	u_avr32_spi_csr.CSR.dlybs  = options->spck_delay;
8000674e:	ef 39 00 09 	ld.ub	r9,r7[9]
80006752:	f1 d9 d2 08 	bfins	r8,r9,0x10,0x8
	u_avr32_spi_csr.CSR.dlybct = options->trans_delay;
80006756:	ef 39 00 0a 	ld.ub	r9,r7[10]
8000675a:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8

	switch (options->reg) {
8000675e:	0f 89       	ld.ub	r9,r7[0x0]
80006760:	30 1a       	mov	r10,1
80006762:	f4 09 18 00 	cp.b	r9,r10
80006766:	c0 d0       	breq	80006780 <spi_setupChipReg+0x98>
80006768:	c0 a3       	brcs	8000677c <spi_setupChipReg+0x94>
8000676a:	30 2a       	mov	r10,2
8000676c:	f4 09 18 00 	cp.b	r9,r10
80006770:	c0 a0       	breq	80006784 <spi_setupChipReg+0x9c>
80006772:	30 3a       	mov	r10,3
80006774:	f4 09 18 00 	cp.b	r9,r10
80006778:	c1 f1       	brne	800067b6 <spi_setupChipReg+0xce>
8000677a:	c0 78       	rjmp	80006788 <spi_setupChipReg+0xa0>
	case 0:
		spi->csr0 = u_avr32_spi_csr.csr;
8000677c:	8b c8       	st.w	r5[0x30],r8
		break;
8000677e:	c0 68       	rjmp	8000678a <spi_setupChipReg+0xa2>

	case 1:
		spi->csr1 = u_avr32_spi_csr.csr;
80006780:	8b d8       	st.w	r5[0x34],r8
		break;
80006782:	c0 48       	rjmp	8000678a <spi_setupChipReg+0xa2>

	case 2:
		spi->csr2 = u_avr32_spi_csr.csr;
80006784:	8b e8       	st.w	r5[0x38],r8
		break;
80006786:	c0 28       	rjmp	8000678a <spi_setupChipReg+0xa2>

	case 3:
		spi->csr3 = u_avr32_spi_csr.csr;
80006788:	8b f8       	st.w	r5[0x3c],r8
	default:
		return SPI_ERROR_ARGUMENT;
	}

#ifdef FREERTOS_USED
	if (!xSPIMutex) {
8000678a:	48 f8       	lddpc	r8,800067c4 <spi_setupChipReg+0xdc>
8000678c:	70 08       	ld.w	r8,r8[0x0]
8000678e:	58 08       	cp.w	r8,0
80006790:	c1 61       	brne	800067bc <spi_setupChipReg+0xd4>
		/* Create the SPI mutex. */
		vSemaphoreCreateBinary(xSPIMutex);
80006792:	30 0b       	mov	r11,0
80006794:	30 1c       	mov	r12,1
80006796:	f0 1f 00 0d 	mcall	800067c8 <spi_setupChipReg+0xe0>
8000679a:	48 b8       	lddpc	r8,800067c4 <spi_setupChipReg+0xdc>
8000679c:	91 0c       	st.w	r8[0x0],r12
8000679e:	58 0c       	cp.w	r12,0
800067a0:	c0 a0       	breq	800067b4 <spi_setupChipReg+0xcc>
800067a2:	30 09       	mov	r9,0
800067a4:	12 9a       	mov	r10,r9
800067a6:	12 9b       	mov	r11,r9
800067a8:	f0 1f 00 09 	mcall	800067cc <spi_setupChipReg+0xe4>
		if (!xSPIMutex) {
800067ac:	48 68       	lddpc	r8,800067c4 <spi_setupChipReg+0xdc>
800067ae:	70 08       	ld.w	r8,r8[0x0]
800067b0:	58 08       	cp.w	r8,0
800067b2:	c0 51       	brne	800067bc <spi_setupChipReg+0xd4>
800067b4:	c0 08       	rjmp	800067b4 <spi_setupChipReg+0xcc>
800067b6:	30 2c       	mov	r12,2
800067b8:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
800067bc:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
800067c0:	80 00       	ld.sh	r0,r0[0x0]
800067c2:	66 20       	ld.w	r0,r3[0x8]
800067c4:	00 00       	add	r0,r0
800067c6:	bd 40       	asr	r0,0x1c
800067c8:	80 00       	ld.sh	r0,r0[0x0]
800067ca:	73 0c       	ld.w	r12,r9[0x40]
800067cc:	80 00       	ld.sh	r0,r0[0x0]
800067ce:	71 b4       	ld.w	r4,r8[0x6c]

800067d0 <spi_unselectChip>:

	return SPI_OK;
}

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
800067d0:	d4 01       	pushm	lr
800067d2:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
800067d6:	c0 58       	rjmp	800067e0 <spi_unselectChip+0x10>
		if (!timeout--) {
800067d8:	58 08       	cp.w	r8,0
800067da:	c0 21       	brne	800067de <spi_unselectChip+0xe>
800067dc:	da 0a       	popm	pc,r12=1
800067de:	20 18       	sub	r8,1

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
800067e0:	78 49       	ld.w	r9,r12[0x10]
800067e2:	e2 19 02 00 	andl	r9,0x200,COH
800067e6:	cf 90       	breq	800067d8 <spi_unselectChip+0x8>
			return SPI_ERROR_TIMEOUT;
		}
	}

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
800067e8:	78 18       	ld.w	r8,r12[0x4]
800067ea:	ea 18 00 0f 	orh	r8,0xf
800067ee:	99 18       	st.w	r12[0x4],r8

	/* Last transfer, so de-assert the current NPCS if CSAAT is set. */
	spi->cr = AVR32_SPI_CR_LASTXFER_MASK;
800067f0:	fc 18 01 00 	movh	r8,0x100
800067f4:	99 08       	st.w	r12[0x0],r8

#ifdef FREERTOS_USED
	xSemaphoreGive(xSPIMutex);
800067f6:	30 09       	mov	r9,0
800067f8:	12 9a       	mov	r10,r9
800067fa:	12 9b       	mov	r11,r9
800067fc:	48 38       	lddpc	r8,80006808 <spi_unselectChip+0x38>
800067fe:	70 0c       	ld.w	r12,r8[0x0]
80006800:	f0 1f 00 03 	mcall	8000680c <spi_unselectChip+0x3c>
80006804:	d8 0a       	popm	pc,r12=0
80006806:	00 00       	add	r0,r0
80006808:	00 00       	add	r0,r0
8000680a:	bd 40       	asr	r0,0x1c
8000680c:	80 00       	ld.sh	r0,r0[0x0]
8000680e:	71 b4       	ld.w	r4,r8[0x6c]

80006810 <spi_selectChip>:

	return SPI_OK;
}

spi_status_t spi_selectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
80006810:	eb cd 40 f8 	pushm	r3-r7,lr
80006814:	18 94       	mov	r4,r12
80006816:	16 93       	mov	r3,r11
#ifdef FREERTOS_USED
	while (pdFALSE == xSemaphoreTake(xSPIMutex, 20)) {
80006818:	49 a6       	lddpc	r6,80006880 <spi_selectChip+0x70>
8000681a:	30 07       	mov	r7,0
8000681c:	31 45       	mov	r5,20
8000681e:	0e 99       	mov	r9,r7
80006820:	0a 9a       	mov	r10,r5
80006822:	0e 9b       	mov	r11,r7
80006824:	6c 0c       	ld.w	r12,r6[0x0]
80006826:	f0 1f 00 18 	mcall	80006884 <spi_selectChip+0x74>
8000682a:	cf a0       	breq	8000681e <spi_selectChip+0xe>
	}
#endif

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
8000682c:	68 18       	ld.w	r8,r4[0x4]
8000682e:	ea 18 00 0f 	orh	r8,0xf
80006832:	89 18       	st.w	r4[0x4],r8

	if (spi->mr & AVR32_SPI_MR_PCSDEC_MASK) {
80006834:	68 18       	ld.w	r8,r4[0x4]
80006836:	e2 18 00 04 	andl	r8,0x4,COH
8000683a:	c1 10       	breq	8000685c <spi_selectChip+0x4c>
		/* The signal is decoded; allow up to 15 chips. */
		if (chip > 14) {
8000683c:	30 e8       	mov	r8,14
8000683e:	f0 03 18 00 	cp.b	r3,r8
80006842:	e0 8b 00 1c 	brhi	8000687a <spi_selectChip+0x6a>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~AVR32_SPI_MR_PCS_MASK |
80006846:	68 19       	ld.w	r9,r4[0x4]
80006848:	e6 08 15 10 	lsl	r8,r3,0x10
8000684c:	ea 18 ff f0 	orh	r8,0xfff0
80006850:	e8 18 ff ff 	orl	r8,0xffff
80006854:	12 68       	and	r8,r9
80006856:	89 18       	st.w	r4[0x4],r8
80006858:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
				(chip << AVR32_SPI_MR_PCS_OFFSET);
	} else {
		if (chip > 3) {
8000685c:	30 38       	mov	r8,3
8000685e:	f0 03 18 00 	cp.b	r3,r8
80006862:	e0 8b 00 0c 	brhi	8000687a <spi_selectChip+0x6a>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~(1 << (AVR32_SPI_MR_PCS_OFFSET + chip));
80006866:	68 19       	ld.w	r9,r4[0x4]
80006868:	2f 03       	sub	r3,-16
8000686a:	30 18       	mov	r8,1
8000686c:	f0 03 09 48 	lsl	r8,r8,r3
80006870:	5c d8       	com	r8
80006872:	12 68       	and	r8,r9
80006874:	89 18       	st.w	r4[0x4],r8
80006876:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
8000687a:	30 2c       	mov	r12,2
	}

	return SPI_OK;
}
8000687c:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80006880:	00 00       	add	r0,r0
80006882:	bd 40       	asr	r0,0x1c
80006884:	80 00       	ld.sh	r0,r0[0x0]
80006886:	6f a8       	ld.w	r8,r7[0x68]

80006888 <usart_set_async_baudrate>:
 *
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
80006888:	d4 01       	pushm	lr
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
8000688a:	f6 08 15 04 	lsl	r8,r11,0x4
8000688e:	14 38       	cp.w	r8,r10
80006890:	f9 b8 08 10 	movls	r8,16
80006894:	f9 b8 0b 08 	movhi	r8,8
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
80006898:	f0 0b 02 4b 	mul	r11,r8,r11
8000689c:	f6 09 16 01 	lsr	r9,r11,0x1
800068a0:	f2 0a 00 3a 	add	r10,r9,r10<<0x3
800068a4:	f4 0b 0d 0a 	divu	r10,r10,r11
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
800068a8:	f4 09 16 03 	lsr	r9,r10,0x3
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
800068ac:	f2 cb 00 01 	sub	r11,r9,1
800068b0:	e0 4b ff fe 	cp.w	r11,65534
800068b4:	e0 88 00 03 	brls	800068ba <usart_set_async_baudrate+0x32>
800068b8:	da 0a       	popm	pc,r12=1
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
800068ba:	78 1b       	ld.w	r11,r12[0x4]
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
800068bc:	e8 6e 00 00 	mov	lr,524288
800068c0:	59 08       	cp.w	r8,16
800068c2:	fc 08 17 10 	movne	r8,lr
800068c6:	f9 b8 00 00 	moveq	r8,0
800068ca:	e4 1b ff f7 	andh	r11,0xfff7
800068ce:	e0 1b fe cf 	andl	r11,0xfecf
800068d2:	16 48       	or	r8,r11
800068d4:	99 18       	st.w	r12[0x4],r8
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
800068d6:	f5 da c0 03 	bfextu	r10,r10,0x0,0x3
800068da:	f3 ea 11 09 	or	r9,r9,r10<<0x10
800068de:	99 89       	st.w	r12[0x20],r9
800068e0:	d8 0a       	popm	pc,r12=0

800068e2 <usart_write_char>:
 *
 * \return \c 1 if the USART Transmit Holding Register is free, otherwise \c 0.
 */
__always_inline static int usart_tx_ready(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_TXRDY_MASK) != 0;
800068e2:	78 58       	ld.w	r8,r12[0x14]
}


int usart_write_char(volatile avr32_usart_t *usart, int c)
{
  if (usart_tx_ready(usart))
800068e4:	e2 18 00 02 	andl	r8,0x2,COH
800068e8:	c0 31       	brne	800068ee <usart_write_char+0xc>
800068ea:	30 2c       	mov	r12,2
800068ec:	5e fc       	retal	r12
  {
    usart->thr = (c << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
800068ee:	f7 db c0 09 	bfextu	r11,r11,0x0,0x9
800068f2:	99 7b       	st.w	r12[0x1c],r11
800068f4:	5e fd       	retal	0
800068f6:	d7 03       	nop

800068f8 <usart_putchar>:
    return USART_TX_BUSY;
}


int usart_putchar(volatile avr32_usart_t *usart, int c)
{
800068f8:	eb cd 40 e0 	pushm	r5-r7,lr
800068fc:	18 96       	mov	r6,r12
800068fe:	16 95       	mov	r5,r11
80006900:	e0 67 27 0f 	mov	r7,9999
80006904:	c0 68       	rjmp	80006910 <usart_putchar+0x18>
  int timeout = USART_DEFAULT_TIMEOUT;

  do
  {
    if (!timeout--) return USART_FAILURE;
80006906:	58 07       	cp.w	r7,0
80006908:	c0 31       	brne	8000690e <usart_putchar+0x16>
8000690a:	e3 cf c0 e0 	ldm	sp++,r5-r7,pc,r12=-1
8000690e:	20 17       	sub	r7,1
  } while (usart_write_char(usart, c) != USART_SUCCESS);
80006910:	0a 9b       	mov	r11,r5
80006912:	0c 9c       	mov	r12,r6
80006914:	f0 1f 00 03 	mcall	80006920 <usart_putchar+0x28>
80006918:	cf 71       	brne	80006906 <usart_putchar+0xe>

  return USART_SUCCESS;
}
8000691a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000691e:	00 00       	add	r0,r0
80006920:	80 00       	ld.sh	r0,r0[0x0]
80006922:	68 e2       	ld.w	r2,r4[0x38]

80006924 <usart_read_char>:

int usart_read_char(volatile avr32_usart_t *usart, int *c)
{
  // Check for errors: frame, parity and overrun. In RS485 mode, a parity error
  // would mean that an address char has been received.
  if (usart->csr & (AVR32_USART_CSR_OVRE_MASK |
80006924:	78 58       	ld.w	r8,r12[0x14]
80006926:	e2 18 00 e0 	andl	r8,0xe0,COH
8000692a:	c0 30       	breq	80006930 <usart_read_char+0xc>
8000692c:	30 4c       	mov	r12,4
8000692e:	5e fc       	retal	r12
 *
 * \return \c 1 if the USART Receive Holding Register is full, otherwise \c 0.
 */
__always_inline static int usart_test_hit(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_RXRDY_MASK) != 0;
80006930:	78 58       	ld.w	r8,r12[0x14]
                    AVR32_USART_CSR_FRAME_MASK |
                    AVR32_USART_CSR_PARE_MASK))
    return USART_RX_ERROR;

  // No error; if we really did receive a char, read it and return SUCCESS.
  if (usart_test_hit(usart))
80006932:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80006936:	c0 31       	brne	8000693c <usart_read_char+0x18>
80006938:	30 3c       	mov	r12,3
8000693a:	5e fc       	retal	r12
  {
    *c = (usart->rhr & AVR32_USART_RHR_RXCHR_MASK) >> AVR32_USART_RHR_RXCHR_OFFSET;
8000693c:	78 68       	ld.w	r8,r12[0x18]
8000693e:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
80006942:	97 08       	st.w	r11[0x0],r8
80006944:	5e fd       	retal	0
80006946:	d7 03       	nop

80006948 <usart_getchar>:
    return USART_RX_EMPTY;
}


int usart_getchar(volatile avr32_usart_t *usart)
{
80006948:	eb cd 40 c0 	pushm	r6-r7,lr
8000694c:	20 1d       	sub	sp,4
8000694e:	18 96       	mov	r6,r12
  int c, ret;

  while ((ret = usart_read_char(usart, &c)) == USART_RX_EMPTY);
80006950:	1a 97       	mov	r7,sp
80006952:	1a 9b       	mov	r11,sp
80006954:	0c 9c       	mov	r12,r6
80006956:	f0 1f 00 07 	mcall	80006970 <usart_getchar+0x28>
8000695a:	58 3c       	cp.w	r12,3
8000695c:	cf b0       	breq	80006952 <usart_getchar+0xa>

  if (ret == USART_RX_ERROR)
8000695e:	58 4c       	cp.w	r12,4
80006960:	f9 bc 00 ff 	moveq	r12,-1
    return USART_FAILURE;

  return c;
80006964:	fb fc 10 00 	ld.wne	r12,sp[0x0]
}
80006968:	2f fd       	sub	sp,-4
8000696a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000696e:	00 00       	add	r0,r0
80006970:	80 00       	ld.sh	r0,r0[0x0]
80006972:	69 24       	ld.w	r4,r4[0x48]

80006974 <usart_write_line>:


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
80006974:	eb cd 40 c0 	pushm	r6-r7,lr
80006978:	18 96       	mov	r6,r12
8000697a:	16 97       	mov	r7,r11
  while (*string != '\0')
8000697c:	17 8b       	ld.ub	r11,r11[0x0]
8000697e:	58 0b       	cp.w	r11,0
80006980:	c0 80       	breq	80006990 <usart_write_line+0x1c>
    usart_putchar(usart, *string++);
80006982:	2f f7       	sub	r7,-1
80006984:	0c 9c       	mov	r12,r6
80006986:	f0 1f 00 04 	mcall	80006994 <usart_write_line+0x20>
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
8000698a:	0f 8b       	ld.ub	r11,r7[0x0]
8000698c:	58 0b       	cp.w	r11,0
8000698e:	cf a1       	brne	80006982 <usart_write_line+0xe>
80006990:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006994:	80 00       	ld.sh	r0,r0[0x0]
80006996:	68 f8       	ld.w	r8,r4[0x3c]

80006998 <usart_reset>:
//! @{


void usart_reset(volatile avr32_usart_t *usart)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
80006998:	e1 b8 00 00 	mfsr	r8,0x0

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
8000699c:	e6 18 00 01 	andh	r8,0x1,COH
800069a0:	c0 71       	brne	800069ae <usart_reset+0x16>
800069a2:	d3 03       	ssrf	0x10
  usart->idr = 0xFFFFFFFF;
800069a4:	3f f8       	mov	r8,-1
800069a6:	99 38       	st.w	r12[0xc],r8
  usart->csr;
800069a8:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();
800069aa:	d5 03       	csrf	0x10
800069ac:	c0 48       	rjmp	800069b4 <usart_reset+0x1c>
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
  usart->idr = 0xFFFFFFFF;
800069ae:	3f f8       	mov	r8,-1
800069b0:	99 38       	st.w	r12[0xc],r8
  usart->csr;
800069b2:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();

  // Reset mode and other registers that could cause unpredictable behavior after reset.
  usart->mr = 0;
800069b4:	30 08       	mov	r8,0
800069b6:	99 18       	st.w	r12[0x4],r8
  usart->rtor = 0;
800069b8:	99 98       	st.w	r12[0x24],r8
  usart->ttgr = 0;
800069ba:	99 a8       	st.w	r12[0x28],r8

  // Shutdown TX and RX (will be re-enabled when setup has successfully completed),
  // reset status bits and turn off DTR and RTS.
  usart->cr = AVR32_USART_CR_RSTRX_MASK   |
800069bc:	ea 68 61 0c 	mov	r8,680204
800069c0:	99 08       	st.w	r12[0x0],r8
#ifndef AVR32_USART_440_H_INCLUDED
// Note: Modem Signal Management DTR-DSR-DCD-RI are not included in USART rev.440.
              AVR32_USART_CR_DTRDIS_MASK  |
#endif
              AVR32_USART_CR_RTSDIS_MASK;
}
800069c2:	5e fc       	retal	r12

800069c4 <usart_init_rs232>:


int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
{
800069c4:	eb cd 40 e0 	pushm	r5-r7,lr
800069c8:	18 96       	mov	r6,r12
800069ca:	16 97       	mov	r7,r11
800069cc:	14 95       	mov	r5,r10
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);
800069ce:	f0 1f 00 2f 	mcall	80006a88 <usart_init_rs232+0xc4>

  // Check input values.
  if (!opt || // Null pointer.
800069d2:	58 07       	cp.w	r7,0
800069d4:	c5 80       	breq	80006a84 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
800069d6:	0f c8       	ld.ub	r8,r7[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
800069d8:	30 49       	mov	r9,4
800069da:	f2 08 18 00 	cp.b	r8,r9
800069de:	e0 88 00 53 	brls	80006a84 <usart_init_rs232+0xc0>
800069e2:	30 99       	mov	r9,9
800069e4:	f2 08 18 00 	cp.b	r8,r9
800069e8:	e0 8b 00 4e 	brhi	80006a84 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
800069ec:	0f d9       	ld.ub	r9,r7[0x5]
800069ee:	30 78       	mov	r8,7
800069f0:	f0 09 18 00 	cp.b	r9,r8
800069f4:	e0 8b 00 48 	brhi	80006a84 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
800069f8:	8e 39       	ld.sh	r9,r7[0x6]
800069fa:	e0 68 01 01 	mov	r8,257
800069fe:	f0 09 19 00 	cp.h	r9,r8
80006a02:	e0 8b 00 41 	brhi	80006a84 <usart_init_rs232+0xc0>
      opt->channelmode > 3 ||
80006a06:	ef 39 00 08 	ld.ub	r9,r7[8]
80006a0a:	30 38       	mov	r8,3
80006a0c:	f0 09 18 00 	cp.b	r9,r8
80006a10:	e0 8b 00 3a 	brhi	80006a84 <usart_init_rs232+0xc0>
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
80006a14:	0a 9a       	mov	r10,r5
80006a16:	6e 0b       	ld.w	r11,r7[0x0]
80006a18:	0c 9c       	mov	r12,r6
80006a1a:	f0 1f 00 1d 	mcall	80006a8c <usart_init_rs232+0xc8>
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80006a1e:	58 1c       	cp.w	r12,1
80006a20:	c3 20       	breq	80006a84 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
    return USART_INVALID_INPUT;

  if (opt->charlength == 9)
80006a22:	0f c8       	ld.ub	r8,r7[0x4]
80006a24:	30 99       	mov	r9,9
80006a26:	f2 08 18 00 	cp.b	r8,r9
80006a2a:	c0 51       	brne	80006a34 <usart_init_rs232+0x70>
  {
    // Character length set to 9 bits. MODE9 dominates CHRL.
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
80006a2c:	6c 18       	ld.w	r8,r6[0x4]
80006a2e:	b1 b8       	sbr	r8,0x11
80006a30:	8d 18       	st.w	r6[0x4],r8
80006a32:	c0 68       	rjmp	80006a3e <usart_init_rs232+0x7a>
  }
  else
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
80006a34:	6c 19       	ld.w	r9,r6[0x4]
80006a36:	20 58       	sub	r8,5
80006a38:	f3 e8 10 68 	or	r8,r9,r8<<0x6
80006a3c:	8d 18       	st.w	r6[0x4],r8
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
80006a3e:	6c 19       	ld.w	r9,r6[0x4]
80006a40:	ef 3a 00 08 	ld.ub	r10,r7[8]
80006a44:	0f d8       	ld.ub	r8,r7[0x5]
80006a46:	a9 78       	lsl	r8,0x9
80006a48:	f1 ea 10 e8 	or	r8,r8,r10<<0xe
80006a4c:	12 48       	or	r8,r9
80006a4e:	8d 18       	st.w	r6[0x4],r8
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;

  if (opt->stopbits > USART_2_STOPBITS)
80006a50:	8e 38       	ld.sh	r8,r7[0x6]
80006a52:	30 29       	mov	r9,2
80006a54:	f2 08 19 00 	cp.h	r8,r9
80006a58:	e0 88 00 09 	brls	80006a6a <usart_init_rs232+0xa6>
  {
    // Set two stop bits
    usart->mr |= AVR32_USART_MR_NBSTOP_2 << AVR32_USART_MR_NBSTOP_OFFSET;
80006a5c:	6c 18       	ld.w	r8,r6[0x4]
80006a5e:	ad b8       	sbr	r8,0xd
80006a60:	8d 18       	st.w	r6[0x4],r8
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
80006a62:	8e b8       	ld.uh	r8,r7[0x6]
80006a64:	20 28       	sub	r8,2
80006a66:	8d a8       	st.w	r6[0x28],r8
80006a68:	c0 68       	rjmp	80006a74 <usart_init_rs232+0xb0>
  }
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;
80006a6a:	6c 19       	ld.w	r9,r6[0x4]
80006a6c:	5c 78       	castu.h	r8
80006a6e:	f3 e8 10 c8 	or	r8,r9,r8<<0xc
80006a72:	8d 18       	st.w	r6[0x4],r8

  // Set normal mode.
  usart->mr = (usart->mr & ~AVR32_USART_MR_MODE_MASK) |
80006a74:	6c 18       	ld.w	r8,r6[0x4]
80006a76:	e0 18 ff f0 	andl	r8,0xfff0
80006a7a:	8d 18       	st.w	r6[0x4],r8
              AVR32_USART_MR_MODE_NORMAL << AVR32_USART_MR_MODE_OFFSET;

  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
80006a7c:	35 08       	mov	r8,80
80006a7e:	8d 08       	st.w	r6[0x0],r8
80006a80:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
80006a84:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
80006a88:	80 00       	ld.sh	r0,r0[0x0]
80006a8a:	69 98       	ld.w	r8,r4[0x64]
80006a8c:	80 00       	ld.sh	r0,r0[0x0]
80006a8e:	68 88       	ld.w	r8,r4[0x20]

80006a90 <_stext>:

  .global _stext
  .type _stext, @function
_stext:
  // Set initial stack pointer.
  lda.w   sp, _estack
80006a90:	e0 7d 80 00 	mov	sp,98304

  // Set up EVBA so interrupts can be enabled.
  lda.w   r0, _evba
  mtsr    AVR32_EVBA, r0
80006a94:	fe c0 8e 94 	sub	r0,pc,-29036

  // Enable the exception processing.
  csrf    AVR32_SR_EM_OFFSET
80006a98:	e3 b0 00 01 	mtsr	0x4,r0

  // Load initialized data having a global lifetime from the data LMA.
  lda.w   r0, _data
  lda.w   r1, _edata
80006a9c:	d5 53       	csrf	0x15
  cp      r0, r1
80006a9e:	30 40       	mov	r0,4
  brhs    idata_load_loop_end
80006aa0:	e0 61 0a 58 	mov	r1,2648
  lda.w   r2, _data_lma
idata_load_loop:
  ld.d    r4, r2++
80006aa4:	02 30       	cp.w	r0,r1
  st.d    r0++, r4
80006aa6:	c0 62       	brcc	80006ab2 <idata_load_loop_end>
  cp      r0, r1
80006aa8:	48 92       	lddpc	r2,80006acc <udata_clear_loop_end+0x4>

80006aaa <idata_load_loop>:
  brlo    idata_load_loop
80006aaa:	a5 05       	ld.d	r4,r2++
idata_load_loop_end:

  // Clear uninitialized data having a global lifetime in the blank static storage section.
  lda.w   r0, __bss_start
80006aac:	a1 24       	st.d	r0++,r4
  lda.w   r1, _end
80006aae:	02 30       	cp.w	r0,r1
  cp      r0, r1
80006ab0:	cf d3       	brcs	80006aaa <idata_load_loop>

80006ab2 <idata_load_loop_end>:
  brhs    udata_clear_loop_end
80006ab2:	e0 60 0a 58 	mov	r0,2648
  mov     r2, 0
  mov     r3, 0
80006ab6:	e0 61 bd 50 	mov	r1,48464
udata_clear_loop:
  st.d    r0++, r2
  cp      r0, r1
80006aba:	02 30       	cp.w	r0,r1
  brlo    udata_clear_loop
80006abc:	c0 62       	brcc	80006ac8 <udata_clear_loop_end>
  // Safety: Set the default "return" @ to the exit routine address.
  lda.w   lr, exit
#endif

  // Start the show.
  lda.w   pc, main
80006abe:	30 02       	mov	r2,0
80006ac0:	30 03       	mov	r3,0

80006ac2 <udata_clear_loop>:
80006ac2:	a1 22       	st.d	r0++,r2
80006ac4:	02 30       	cp.w	r0,r1
80006ac6:	cf e3       	brcs	80006ac2 <udata_clear_loop>

80006ac8 <udata_clear_loop_end>:
80006ac8:	fe cf e9 28 	sub	pc,pc,-5848
80006acc:	80 00       	ld.sh	r0,r0[0x0]
80006ace:	f4 50 f8 c8 	cp.w	r0,-657208

80006ad0 <vListInitialise>:
void vListInitialise( xList *pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
80006ad0:	f8 c8 ff f8 	sub	r8,r12,-8
80006ad4:	99 18       	st.w	r12[0x4],r8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
80006ad6:	3f f9       	mov	r9,-1
80006ad8:	99 29       	st.w	r12[0x8],r9

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
80006ada:	99 38       	st.w	r12[0xc],r8
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
80006adc:	99 48       	st.w	r12[0x10],r8

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
80006ade:	30 08       	mov	r8,0
80006ae0:	99 08       	st.w	r12[0x0],r8
}
80006ae2:	5e fc       	retal	r12

80006ae4 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
80006ae4:	30 08       	mov	r8,0
80006ae6:	99 48       	st.w	r12[0x10],r8
}
80006ae8:	5e fc       	retal	r12

80006aea <vListInsertEnd>:

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
80006aea:	78 18       	ld.w	r8,r12[0x4]

	pxNewListItem->pxNext = pxIndex->pxNext;
80006aec:	70 19       	ld.w	r9,r8[0x4]
80006aee:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxPrevious = pxList->pxIndex;
80006af0:	78 19       	ld.w	r9,r12[0x4]
80006af2:	97 29       	st.w	r11[0x8],r9
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80006af4:	70 19       	ld.w	r9,r8[0x4]
80006af6:	93 2b       	st.w	r9[0x8],r11
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
80006af8:	91 1b       	st.w	r8[0x4],r11
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
80006afa:	99 1b       	st.w	r12[0x4],r11

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80006afc:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80006afe:	78 08       	ld.w	r8,r12[0x0]
80006b00:	2f f8       	sub	r8,-1
80006b02:	99 08       	st.w	r12[0x0],r8
}
80006b04:	5e fc       	retal	r12

80006b06 <vListInsert>:
{
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
80006b06:	76 0a       	ld.w	r10,r11[0x0]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
80006b08:	5b fa       	cp.w	r10,-1
80006b0a:	c0 31       	brne	80006b10 <vListInsert+0xa>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
80006b0c:	78 48       	ld.w	r8,r12[0x10]
80006b0e:	c0 c8       	rjmp	80006b26 <vListInsert+0x20>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
80006b10:	f8 c8 ff f8 	sub	r8,r12,-8
80006b14:	70 19       	ld.w	r9,r8[0x4]
80006b16:	72 09       	ld.w	r9,r9[0x0]
80006b18:	12 3a       	cp.w	r10,r9
80006b1a:	c0 63       	brcs	80006b26 <vListInsert+0x20>
80006b1c:	70 18       	ld.w	r8,r8[0x4]
80006b1e:	70 19       	ld.w	r9,r8[0x4]
80006b20:	72 09       	ld.w	r9,r9[0x0]
80006b22:	12 3a       	cp.w	r10,r9
80006b24:	cf c2       	brcc	80006b1c <vListInsert+0x16>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
80006b26:	70 19       	ld.w	r9,r8[0x4]
80006b28:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80006b2a:	93 2b       	st.w	r9[0x8],r11
	pxNewListItem->pxPrevious = pxIterator;
80006b2c:	97 28       	st.w	r11[0x8],r8
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
80006b2e:	91 1b       	st.w	r8[0x4],r11

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80006b30:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80006b32:	78 08       	ld.w	r8,r12[0x0]
80006b34:	2f f8       	sub	r8,-1
80006b36:	99 08       	st.w	r12[0x0],r8
}
80006b38:	5e fc       	retal	r12

80006b3a <vListRemove>:

void vListRemove( xListItem *pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
80006b3a:	78 18       	ld.w	r8,r12[0x4]
80006b3c:	78 29       	ld.w	r9,r12[0x8]
80006b3e:	91 29       	st.w	r8[0x8],r9
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
80006b40:	78 28       	ld.w	r8,r12[0x8]
80006b42:	78 19       	ld.w	r9,r12[0x4]
80006b44:	91 19       	st.w	r8[0x4],r9

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
80006b46:	78 48       	ld.w	r8,r12[0x10]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
80006b48:	70 19       	ld.w	r9,r8[0x4]
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
80006b4a:	18 39       	cp.w	r9,r12
80006b4c:	f9 f9 00 02 	ld.weq	r9,r12[0x8]
80006b50:	f1 f9 0a 01 	st.weq	r8[0x4],r9
	}

	pxItemToRemove->pvContainer = NULL;
80006b54:	30 09       	mov	r9,0
80006b56:	99 49       	st.w	r12[0x10],r9
	( pxList->uxNumberOfItems )--;
80006b58:	70 09       	ld.w	r9,r8[0x0]
80006b5a:	20 19       	sub	r9,1
80006b5c:	91 09       	st.w	r8[0x0],r9
}
80006b5e:	5e fc       	retal	r12

80006b60 <pxPortInitialiseStack>:
	/* Setup the initial stack of the task.  The stack is set exactly as
	expected by the portRESTORE_CONTEXT() macro. */

	/* When the task starts, it will expect to find the function parameter in R12. */
	pxTopOfStack--;
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x08080808;					/* R8 */
80006b60:	e0 68 08 08 	mov	r8,2056
80006b64:	ea 18 08 08 	orh	r8,0x808
80006b68:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x09090909;					/* R9 */
80006b6a:	e0 68 09 09 	mov	r8,2313
80006b6e:	ea 18 09 09 	orh	r8,0x909
80006b72:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0A0A0A0A;					/* R10 */
80006b74:	e0 68 0a 0a 	mov	r8,2570
80006b78:	ea 18 0a 0a 	orh	r8,0xa0a
80006b7c:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0B0B0B0B;					/* R11 */
80006b7e:	e0 68 0b 0b 	mov	r8,2827
80006b82:	ea 18 0b 0b 	orh	r8,0xb0b
80006b86:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pvParameters;					/* R12 */
80006b88:	18 da       	st.w	--r12,r10
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xDEADBEEF;					/* R14/LR */
80006b8a:	e0 68 be ef 	mov	r8,48879
80006b8e:	ea 18 de ad 	orh	r8,0xdead
80006b92:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pxCode + portINSTRUCTION_SIZE; /* R15/PC */
80006b94:	18 db       	st.w	--r12,r11
	*pxTopOfStack-- = ( portSTACK_TYPE ) portINITIAL_SR;				/* SR */
80006b96:	fc 18 00 40 	movh	r8,0x40
80006b9a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xFF0000FF;					/* R0 */
80006b9c:	e0 68 00 ff 	mov	r8,255
80006ba0:	ea 18 ff 00 	orh	r8,0xff00
80006ba4:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x01010101;					/* R1 */
80006ba6:	e0 68 01 01 	mov	r8,257
80006baa:	ea 18 01 01 	orh	r8,0x101
80006bae:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x02020202;					/* R2 */
80006bb0:	e0 68 02 02 	mov	r8,514
80006bb4:	ea 18 02 02 	orh	r8,0x202
80006bb8:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x03030303;					/* R3 */
80006bba:	e0 68 03 03 	mov	r8,771
80006bbe:	ea 18 03 03 	orh	r8,0x303
80006bc2:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x04040404;					/* R4 */
80006bc4:	e0 68 04 04 	mov	r8,1028
80006bc8:	ea 18 04 04 	orh	r8,0x404
80006bcc:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x05050505;					/* R5 */
80006bce:	e0 68 05 05 	mov	r8,1285
80006bd2:	ea 18 05 05 	orh	r8,0x505
80006bd6:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x06060606;					/* R6 */
80006bd8:	e0 68 06 06 	mov	r8,1542
80006bdc:	ea 18 06 06 	orh	r8,0x606
80006be0:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x07070707;					/* R7 */
80006be2:	e0 68 07 07 	mov	r8,1799
80006be6:	ea 18 07 07 	orh	r8,0x707
80006bea:	18 d8       	st.w	--r12,r8
	*pxTopOfStack = ( portSTACK_TYPE ) portNO_CRITICAL_NESTING;			/* ulCriticalNesting */
80006bec:	30 08       	mov	r8,0
80006bee:	18 d8       	st.w	--r12,r8

	return pxTopOfStack;
}
80006bf0:	5e fc       	retal	r12
80006bf2:	d7 03       	nop

80006bf4 <vPortEnterCritical>:
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
__attribute__((__noinline__)) void vPortEnterCritical( void )
{
	/* Disable interrupts */
	portDISABLE_INTERRUPTS();
80006bf4:	d3 03       	ssrf	0x10

	/* Now interrupts are disabled ulCriticalNesting can be accessed
	 directly.  Increment ulCriticalNesting to keep a count of how many times
	 portENTER_CRITICAL() has been called. */
	ulCriticalNesting++;
80006bf6:	48 38       	lddpc	r8,80006c00 <vPortEnterCritical+0xc>
80006bf8:	70 09       	ld.w	r9,r8[0x0]
80006bfa:	2f f9       	sub	r9,-1
80006bfc:	91 09       	st.w	r8[0x0],r9
}
80006bfe:	5e fc       	retal	r12
80006c00:	00 00       	add	r0,r0
80006c02:	05 4c       	ld.w	r12,--r2

80006c04 <xPortStartScheduler>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
80006c04:	d4 01       	pushm	lr
	};

#endif

	/* Disable all interrupt/exception. */
	portDISABLE_INTERRUPTS();
80006c06:	d3 03       	ssrf	0x10
		/* Start the timer/counter. */
		tc_start(tc, configTICK_TC_CHANNEL);
	}
	#else
	{
		INTC_register_interrupt(&vTick, AVR32_CORE_COMPARE_IRQ, AVR32_INTC_INT0);
80006c08:	30 0a       	mov	r10,0
80006c0a:	14 9b       	mov	r11,r10
80006c0c:	49 2c       	lddpc	r12,80006c54 <xPortStartScheduler+0x50>
80006c0e:	f0 1f 00 13 	mcall	80006c58 <xPortStartScheduler+0x54>
/* Schedule the COUNT&COMPARE match interrupt in (configCPU_CLOCK_HZ/configTICK_RATE_HZ)
clock cycles from now. */
#if( configTICK_USE_TC==0 )
	static void prvScheduleFirstTick(void)
	{
		Set_system_register(AVR32_COMPARE, configCPU_CLOCK_HZ/configTICK_RATE_HZ);//cause!!!
80006c12:	e0 68 5d c0 	mov	r8,24000
80006c16:	e3 b8 00 43 	mtsr	0x10c,r8
		Set_system_register(AVR32_COUNT, 0);
80006c1a:	30 08       	mov	r8,0
80006c1c:	e3 b8 00 42 	mtsr	0x108,r8
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();

	/* Start the first task. */
	portRESTORE_CONTEXT();
80006c20:	e0 68 0d 6c 	mov	r8,3436
80006c24:	ea 18 00 00 	orh	r8,0x0
80006c28:	70 00       	ld.w	r0,r8[0x0]
80006c2a:	60 0d       	ld.w	sp,r0[0x0]
80006c2c:	1b 00       	ld.w	r0,sp++
80006c2e:	e0 68 05 4c 	mov	r8,1356
80006c32:	ea 18 00 00 	orh	r8,0x0
80006c36:	91 00       	st.w	r8[0x0],r0
80006c38:	e3 cd 00 ff 	ldm	sp++,r0-r7
80006c3c:	2f ed       	sub	sp,-8
80006c3e:	e3 cd 5f 00 	ldm	sp++,r8-r12,lr
80006c42:	fa f0 ff e0 	ld.w	r0,sp[-32]
80006c46:	e3 b0 00 00 	mtsr	0x0,r0
80006c4a:	fa f0 ff dc 	ld.w	r0,sp[-36]
80006c4e:	fa ff ff e4 	ld.w	pc,sp[-28]

	/* Should not get here! */
	return 0;
}
80006c52:	d8 0a       	popm	pc,r12=0
80006c54:	80 00       	ld.sh	r0,r0[0x0]
80006c56:	6d 20       	ld.w	r0,r6[0x48]
80006c58:	80 00       	ld.sh	r0,r0[0x0]
80006c5a:	62 54       	ld.w	r4,r1[0x14]

80006c5c <SCALLYield>:
/*-----------------------------------------------------------*/
__attribute__((__naked__)) void SCALLYield( void );
__attribute__((__naked__)) void SCALLYield( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_SCALL();
80006c5c:	20 6d       	sub	sp,24
80006c5e:	eb cd 00 ff 	pushm	r0-r7
80006c62:	fa c7 ff c0 	sub	r7,sp,-64
80006c66:	ee f0 ff f8 	ld.w	r0,r7[-8]
80006c6a:	ef 40 ff e0 	st.w	r7[-32],r0
80006c6e:	ee f0 ff fc 	ld.w	r0,r7[-4]
80006c72:	ef 40 ff e4 	st.w	r7[-28],r0
80006c76:	eb c7 5f 00 	stm	--r7,r8-r12,lr
80006c7a:	e0 68 05 4c 	mov	r8,1356
80006c7e:	ea 18 00 00 	orh	r8,0x0
80006c82:	70 00       	ld.w	r0,r8[0x0]
80006c84:	1a d0       	st.w	--sp,r0
80006c86:	f0 1f 00 1a 	mcall	80006cec <LABEL_RET_SCALL_263+0x14>
80006c8a:	e0 68 0d 6c 	mov	r8,3436
80006c8e:	ea 18 00 00 	orh	r8,0x0
80006c92:	70 00       	ld.w	r0,r8[0x0]
80006c94:	81 0d       	st.w	r0[0x0],sp
	vTaskSwitchContext();
80006c96:	f0 1f 00 17 	mcall	80006cf0 <LABEL_RET_SCALL_263+0x18>
	portRESTORE_CONTEXT_SCALL();
80006c9a:	e0 68 0d 6c 	mov	r8,3436
80006c9e:	ea 18 00 00 	orh	r8,0x0
80006ca2:	70 00       	ld.w	r0,r8[0x0]
80006ca4:	60 0d       	ld.w	sp,r0[0x0]
80006ca6:	1b 00       	ld.w	r0,sp++
80006ca8:	e0 68 05 4c 	mov	r8,1356
80006cac:	ea 18 00 00 	orh	r8,0x0
80006cb0:	91 00       	st.w	r8[0x0],r0
80006cb2:	fa c7 ff d8 	sub	r7,sp,-40
80006cb6:	e3 c7 5f 00 	ldm	r7++,r8-r12,lr
80006cba:	ee f0 ff e0 	ld.w	r0,r7[-32]
80006cbe:	e0 61 05 4c 	mov	r1,1356
80006cc2:	ea 11 00 00 	orh	r1,0x0
80006cc6:	62 02       	ld.w	r2,r1[0x0]
80006cc8:	58 02       	cp.w	r2,0
80006cca:	c0 70       	breq	80006cd8 <LABEL_RET_SCALL_263>
80006ccc:	e4 c2 00 01 	sub	r2,r2,1
80006cd0:	83 02       	st.w	r1[0x0],r2
80006cd2:	58 02       	cp.w	r2,0
80006cd4:	c0 21       	brne	80006cd8 <LABEL_RET_SCALL_263>
80006cd6:	b1 c0       	cbr	r0,0x10

80006cd8 <LABEL_RET_SCALL_263>:
80006cd8:	ef 40 ff f8 	st.w	r7[-8],r0
80006cdc:	ee f0 ff e4 	ld.w	r0,r7[-28]
80006ce0:	ef 40 ff fc 	st.w	r7[-4],r0
80006ce4:	e3 cd 00 ff 	ldm	sp++,r0-r7
80006ce8:	2f ad       	sub	sp,-24
80006cea:	d6 13       	rets
80006cec:	80 00       	ld.sh	r0,r0[0x0]
80006cee:	6b f4       	ld.w	r4,r5[0x7c]
80006cf0:	80 00       	ld.sh	r0,r0[0x0]
80006cf2:	73 90       	ld.w	r0,r9[0x64]

80006cf4 <prvClearCcInt>:
		Set_system_register(AVR32_COUNT, 0);
	}

	__attribute__((__noinline__)) static void prvClearCcInt(void)
	{
		Set_system_register(AVR32_COMPARE, Get_system_register(AVR32_COMPARE));
80006cf4:	e1 b8 00 43 	mfsr	r8,0x10c
80006cf8:	e3 b8 00 43 	mtsr	0x10c,r8
	}
80006cfc:	5e fc       	retal	r12
80006cfe:	d7 03       	nop

80006d00 <vPortExitCritical>:
}
/*-----------------------------------------------------------*/

__attribute__((__noinline__)) void vPortExitCritical( void )
{
	if(ulCriticalNesting > portNO_CRITICAL_NESTING)
80006d00:	48 78       	lddpc	r8,80006d1c <vPortExitCritical+0x1c>
80006d02:	70 08       	ld.w	r8,r8[0x0]
80006d04:	58 08       	cp.w	r8,0
80006d06:	5e 0c       	reteq	r12
	{
		ulCriticalNesting--;
80006d08:	48 58       	lddpc	r8,80006d1c <vPortExitCritical+0x1c>
80006d0a:	70 09       	ld.w	r9,r8[0x0]
80006d0c:	20 19       	sub	r9,1
80006d0e:	91 09       	st.w	r8[0x0],r9
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
80006d10:	70 08       	ld.w	r8,r8[0x0]
80006d12:	58 08       	cp.w	r8,0
80006d14:	5e 1c       	retne	r12
		{
			/* Enable all interrupt/exception. */
			portENABLE_INTERRUPTS();
80006d16:	d5 03       	csrf	0x10
80006d18:	5e fc       	retal	r12
80006d1a:	00 00       	add	r0,r0
80006d1c:	00 00       	add	r0,r0
80006d1e:	05 4c       	ld.w	r12,--r2

80006d20 <vTick>:
/* The preemptive scheduler is defined as "naked" as the full context is saved
on entry as part of the context switch. */
__attribute__((__naked__)) static void vTick( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_OS_INT();
80006d20:	eb cd 00 ff 	pushm	r0-r7
80006d24:	e0 68 05 4c 	mov	r8,1356
80006d28:	ea 18 00 00 	orh	r8,0x0
80006d2c:	70 00       	ld.w	r0,r8[0x0]
80006d2e:	1a d0       	st.w	--sp,r0
80006d30:	7a 90       	ld.w	r0,sp[0x24]
80006d32:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80006d36:	58 10       	cp.w	r0,1
80006d38:	e0 8b 00 08 	brhi	80006d48 <LABEL_INT_SKIP_SAVE_CONTEXT_237>
80006d3c:	e0 68 0d 6c 	mov	r8,3436
80006d40:	ea 18 00 00 	orh	r8,0x0
80006d44:	70 00       	ld.w	r0,r8[0x0]
80006d46:	81 0d       	st.w	r0[0x0],sp

80006d48 <LABEL_INT_SKIP_SAVE_CONTEXT_237>:
	#if( configTICK_USE_TC==1 )
		/* Clear the interrupt flag. */
		prvClearTcInt();
	#else
		/* Clear the interrupt flag. */
		prvClearCcInt();
80006d48:	f0 1f 00 12 	mcall	80006d90 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x14>
	#endif

	/* Because FreeRTOS is not supposed to run with nested interrupts, put all OS
	calls in a critical section . */
	portENTER_CRITICAL();
80006d4c:	f0 1f 00 12 	mcall	80006d94 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
		vTaskIncrementTick();
80006d50:	f0 1f 00 12 	mcall	80006d98 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x1c>
	portEXIT_CRITICAL();
80006d54:	f0 1f 00 12 	mcall	80006d9c <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>

	/* Restore the context of the "elected task". */
	portRESTORE_CONTEXT_OS_INT();
80006d58:	7a 90       	ld.w	r0,sp[0x24]
80006d5a:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80006d5e:	58 10       	cp.w	r0,1
80006d60:	e0 8b 00 0e 	brhi	80006d7c <LABEL_INT_SKIP_RESTORE_CONTEXT_254>
80006d64:	f0 1f 00 0c 	mcall	80006d94 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
80006d68:	f0 1f 00 0e 	mcall	80006da0 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x24>
80006d6c:	f0 1f 00 0c 	mcall	80006d9c <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>
80006d70:	e0 68 0d 6c 	mov	r8,3436
80006d74:	ea 18 00 00 	orh	r8,0x0
80006d78:	70 00       	ld.w	r0,r8[0x0]
80006d7a:	60 0d       	ld.w	sp,r0[0x0]

80006d7c <LABEL_INT_SKIP_RESTORE_CONTEXT_254>:
80006d7c:	1b 00       	ld.w	r0,sp++
80006d7e:	e0 68 05 4c 	mov	r8,1356
80006d82:	ea 18 00 00 	orh	r8,0x0
80006d86:	91 00       	st.w	r8[0x0],r0
80006d88:	e3 cd 00 ff 	ldm	sp++,r0-r7
80006d8c:	d6 03       	rete
80006d8e:	00 00       	add	r0,r0
80006d90:	80 00       	ld.sh	r0,r0[0x0]
80006d92:	6c f4       	ld.w	r4,r6[0x3c]
80006d94:	80 00       	ld.sh	r0,r0[0x0]
80006d96:	6b f4       	ld.w	r4,r5[0x7c]
80006d98:	80 00       	ld.sh	r0,r0[0x0]
80006d9a:	75 94       	ld.w	r4,r10[0x64]
80006d9c:	80 00       	ld.sh	r0,r0[0x0]
80006d9e:	6d 00       	ld.w	r0,r6[0x40]
80006da0:	80 00       	ld.sh	r0,r0[0x0]
80006da2:	73 90       	ld.w	r0,r9[0x64]

80006da4 <__malloc_lock>:
 * safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_lock(struct _reent *ptr);
void __malloc_lock(struct _reent *ptr)
{
80006da4:	d4 01       	pushm	lr
	vTaskSuspendAll();
80006da6:	f0 1f 00 02 	mcall	80006dac <__malloc_lock+0x8>
}
80006daa:	d8 02       	popm	pc
80006dac:	80 00       	ld.sh	r0,r0[0x0]
80006dae:	73 80       	ld.w	r0,r9[0x60]

80006db0 <__malloc_unlock>:
 * a safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_unlock(struct _reent *ptr);
void __malloc_unlock(struct _reent *ptr)
{
80006db0:	d4 01       	pushm	lr
	xTaskResumeAll();
80006db2:	f0 1f 00 02 	mcall	80006db8 <__malloc_unlock+0x8>
}
80006db6:	d8 02       	popm	pc
80006db8:	80 00       	ld.sh	r0,r0[0x0]
80006dba:	77 3c       	ld.w	r12,r11[0x4c]

80006dbc <_read>:
/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
{
80006dbc:	d4 21       	pushm	r4-r7,lr
80006dbe:	16 95       	mov	r5,r11
80006dc0:	14 96       	mov	r6,r10
  int nChars = 0;

  if (file != 0)
80006dc2:	58 0c       	cp.w	r12,0
80006dc4:	c0 30       	breq	80006dca <_read+0xe>
80006dc6:	3f f7       	mov	r7,-1
80006dc8:	c1 48       	rjmp	80006df0 <_read+0x34>
    return -1;

  for (; len > 0; --len)
80006dca:	58 0a       	cp.w	r10,0
80006dcc:	e0 89 00 04 	brgt	80006dd4 <_read+0x18>
80006dd0:	30 07       	mov	r7,0
80006dd2:	c0 f8       	rjmp	80006df0 <_read+0x34>
80006dd4:	30 07       	mov	r7,0
  {
    int c = usart_getchar(stdio_usart_base);
80006dd6:	48 84       	lddpc	r4,80006df4 <_read+0x38>
80006dd8:	68 0c       	ld.w	r12,r4[0x0]
80006dda:	f0 1f 00 08 	mcall	80006df8 <_read+0x3c>
    if (c < 0)
80006dde:	c0 95       	brlt	80006df0 <_read+0x34>
      break;

    *ptr++ = c;
80006de0:	ea 07 0b 0c 	st.b	r5[r7],r12
    ++nChars;
80006de4:	2f f7       	sub	r7,-1

/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
80006de6:	ec 07 01 08 	sub	r8,r6,r7
  int nChars = 0;

  if (file != 0)
    return -1;

  for (; len > 0; --len)
80006dea:	58 08       	cp.w	r8,0
80006dec:	fe 99 ff f6 	brgt	80006dd8 <_read+0x1c>
    *ptr++ = c;
    ++nChars;
  }

  return nChars;
}
80006df0:	0e 9c       	mov	r12,r7
80006df2:	d8 22       	popm	r4-r7,pc
80006df4:	00 00       	add	r0,r0
80006df6:	bd 44       	asr	r4,0x1c
80006df8:	80 00       	ld.sh	r0,r0[0x0]
80006dfa:	69 48       	ld.w	r8,r4[0x50]

80006dfc <_write>:
 * 1 and 2 is stdout and stderr which goes to usart
 * 3 is framebuffer
 */
int __attribute__((weak))
_write (int file, char * ptr, int len)
{
80006dfc:	d4 21       	pushm	r4-r7,lr
80006dfe:	16 95       	mov	r5,r11
80006e00:	14 96       	mov	r6,r10
  int nChars = 0;

  if ( (file != 1)
80006e02:	20 1c       	sub	r12,1
80006e04:	58 2c       	cp.w	r12,2
80006e06:	e0 8b 00 12 	brhi	80006e2a <_write+0x2e>
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80006e0a:	58 0a       	cp.w	r10,0
80006e0c:	c0 31       	brne	80006e12 <_write+0x16>
80006e0e:	30 07       	mov	r7,0
80006e10:	c0 e8       	rjmp	80006e2c <_write+0x30>
80006e12:	30 07       	mov	r7,0
  {
    if (usart_putchar(stdio_usart_base, *ptr++) < 0)
80006e14:	48 74       	lddpc	r4,80006e30 <_write+0x34>
80006e16:	68 0c       	ld.w	r12,r4[0x0]
80006e18:	ea 07 07 0b 	ld.ub	r11,r5[r7]
80006e1c:	f0 1f 00 06 	mcall	80006e34 <_write+0x38>
80006e20:	c0 55       	brlt	80006e2a <_write+0x2e>
    {
      return -1;
    }

    ++nChars;
80006e22:	2f f7       	sub	r7,-1

  if ( (file != 1)
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80006e24:	0e 36       	cp.w	r6,r7
80006e26:	cf 81       	brne	80006e16 <_write+0x1a>
80006e28:	c0 28       	rjmp	80006e2c <_write+0x30>
80006e2a:	3f f7       	mov	r7,-1

    ++nChars;
  }

  return nChars;
}
80006e2c:	0e 9c       	mov	r12,r7
80006e2e:	d8 22       	popm	r4-r7,pc
80006e30:	00 00       	add	r0,r0
80006e32:	bd 44       	asr	r4,0x1c
80006e34:	80 00       	ld.sh	r0,r0[0x0]
80006e36:	68 f8       	ld.w	r8,r4[0x3c]

80006e38 <vPortFree>:
	return pvReturn;
}
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
80006e38:	eb cd 40 80 	pushm	r7,lr
80006e3c:	18 97       	mov	r7,r12
	if( pv )
80006e3e:	58 0c       	cp.w	r12,0
80006e40:	c0 80       	breq	80006e50 <vPortFree+0x18>
	{
		vTaskSuspendAll();
80006e42:	f0 1f 00 05 	mcall	80006e54 <vPortFree+0x1c>
		{
			free( pv );
80006e46:	0e 9c       	mov	r12,r7
80006e48:	f0 1f 00 04 	mcall	80006e58 <vPortFree+0x20>
		}
		xTaskResumeAll();
80006e4c:	f0 1f 00 04 	mcall	80006e5c <vPortFree+0x24>
80006e50:	e3 cd 80 80 	ldm	sp++,r7,pc
80006e54:	80 00       	ld.sh	r0,r0[0x0]
80006e56:	73 80       	ld.w	r0,r9[0x60]
80006e58:	80 00       	ld.sh	r0,r0[0x0]
80006e5a:	82 10       	ld.sh	r0,r1[0x2]
80006e5c:	80 00       	ld.sh	r0,r0[0x0]
80006e5e:	77 3c       	ld.w	r12,r11[0x4c]

80006e60 <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
80006e60:	eb cd 40 80 	pushm	r7,lr
80006e64:	18 97       	mov	r7,r12
void *pvReturn;

	vTaskSuspendAll();
80006e66:	f0 1f 00 06 	mcall	80006e7c <pvPortMalloc+0x1c>
	{
		pvReturn = malloc( xWantedSize );
80006e6a:	0e 9c       	mov	r12,r7
80006e6c:	f0 1f 00 05 	mcall	80006e80 <pvPortMalloc+0x20>
80006e70:	18 97       	mov	r7,r12
	}
	xTaskResumeAll();
80006e72:	f0 1f 00 05 	mcall	80006e84 <pvPortMalloc+0x24>
		}
	}
	#endif

	return pvReturn;
}
80006e76:	0e 9c       	mov	r12,r7
80006e78:	e3 cd 80 80 	ldm	sp++,r7,pc
80006e7c:	80 00       	ld.sh	r0,r0[0x0]
80006e7e:	73 80       	ld.w	r0,r9[0x60]
80006e80:	80 00       	ld.sh	r0,r0[0x0]
80006e82:	82 20       	ld.sh	r0,r1[0x4]
80006e84:	80 00       	ld.sh	r0,r0[0x0]
80006e86:	77 3c       	ld.w	r12,r11[0x4c]

80006e88 <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
80006e88:	d4 01       	pushm	lr
80006e8a:	16 98       	mov	r8,r11
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
80006e8c:	78 09       	ld.w	r9,r12[0x0]
80006e8e:	58 09       	cp.w	r9,0
80006e90:	c1 10       	breq	80006eb2 <prvCopyDataFromQueue+0x2a>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
80006e92:	78 3a       	ld.w	r10,r12[0xc]
80006e94:	79 09       	ld.w	r9,r12[0x40]
80006e96:	f4 09 00 09 	add	r9,r10,r9
80006e9a:	99 39       	st.w	r12[0xc],r9
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
80006e9c:	78 1a       	ld.w	r10,r12[0x4]
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
80006e9e:	14 39       	cp.w	r9,r10
80006ea0:	f9 f9 20 00 	ld.wcc	r9,r12[0x0]
80006ea4:	f9 f9 2a 03 	st.wcc	r12[0xc],r9
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
80006ea8:	79 0a       	ld.w	r10,r12[0x40]
80006eaa:	78 3b       	ld.w	r11,r12[0xc]
80006eac:	10 9c       	mov	r12,r8
80006eae:	f0 1f 00 02 	mcall	80006eb4 <prvCopyDataFromQueue+0x2c>
80006eb2:	d8 02       	popm	pc
80006eb4:	80 00       	ld.sh	r0,r0[0x0]
80006eb6:	86 8e       	ld.uh	lr,r3[0x0]

80006eb8 <xQueueReceiveFromISR>:
	}
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
80006eb8:	eb cd 40 c0 	pushm	r6-r7,lr
80006ebc:	18 97       	mov	r7,r12
80006ebe:	14 96       	mov	r6,r10
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80006ec0:	78 e8       	ld.w	r8,r12[0x38]
80006ec2:	58 08       	cp.w	r8,0
80006ec4:	c0 31       	brne	80006eca <xQueueReceiveFromISR+0x12>
80006ec6:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
80006eca:	f0 1f 00 0e 	mcall	80006f00 <xQueueReceiveFromISR+0x48>
			--( pxQueue->uxMessagesWaiting );
80006ece:	6e e8       	ld.w	r8,r7[0x38]
80006ed0:	20 18       	sub	r8,1
80006ed2:	8f e8       	st.w	r7[0x38],r8

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
80006ed4:	6f 18       	ld.w	r8,r7[0x44]
80006ed6:	5b f8       	cp.w	r8,-1
80006ed8:	c0 d1       	brne	80006ef2 <xQueueReceiveFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80006eda:	6e 48       	ld.w	r8,r7[0x10]
80006edc:	58 08       	cp.w	r8,0
80006ede:	c0 f0       	breq	80006efc <xQueueReceiveFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80006ee0:	ee cc ff f0 	sub	r12,r7,-16
80006ee4:	f0 1f 00 08 	mcall	80006f04 <xQueueReceiveFromISR+0x4c>
80006ee8:	c0 a0       	breq	80006efc <xQueueReceiveFromISR+0x44>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
80006eea:	30 1c       	mov	r12,1
80006eec:	8d 0c       	st.w	r6[0x0],r12
80006eee:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
80006ef2:	2f f8       	sub	r8,-1
80006ef4:	ef 48 00 44 	st.w	r7[68],r8
80006ef8:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80006efc:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80006f00:	80 00       	ld.sh	r0,r0[0x0]
80006f02:	6e 88       	ld.w	r8,r7[0x20]
80006f04:	80 00       	ld.sh	r0,r0[0x0]
80006f06:	75 18       	ld.w	r8,r10[0x44]

80006f08 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
80006f08:	eb cd 40 c0 	pushm	r6-r7,lr
80006f0c:	18 97       	mov	r7,r12

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
80006f0e:	f0 1f 00 23 	mcall	80006f98 <prvUnlockQueue+0x90>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80006f12:	6f 28       	ld.w	r8,r7[0x48]
80006f14:	58 08       	cp.w	r8,0
80006f16:	e0 8a 00 18 	brle	80006f46 <prvUnlockQueue+0x3e>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80006f1a:	6e 98       	ld.w	r8,r7[0x24]
80006f1c:	58 08       	cp.w	r8,0
80006f1e:	c1 40       	breq	80006f46 <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80006f20:	ee c6 ff dc 	sub	r6,r7,-36
80006f24:	c0 48       	rjmp	80006f2c <prvUnlockQueue+0x24>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80006f26:	6e 98       	ld.w	r8,r7[0x24]
80006f28:	58 08       	cp.w	r8,0
80006f2a:	c0 e0       	breq	80006f46 <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80006f2c:	0c 9c       	mov	r12,r6
80006f2e:	f0 1f 00 1c 	mcall	80006f9c <prvUnlockQueue+0x94>
80006f32:	c0 30       	breq	80006f38 <prvUnlockQueue+0x30>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
80006f34:	f0 1f 00 1b 	mcall	80006fa0 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xTxLock );
80006f38:	6f 28       	ld.w	r8,r7[0x48]
80006f3a:	20 18       	sub	r8,1
80006f3c:	ef 48 00 48 	st.w	r7[72],r8
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80006f40:	58 08       	cp.w	r8,0
80006f42:	fe 99 ff f2 	brgt	80006f26 <prvUnlockQueue+0x1e>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
80006f46:	3f f8       	mov	r8,-1
80006f48:	ef 48 00 48 	st.w	r7[72],r8
	}
	taskEXIT_CRITICAL();
80006f4c:	f0 1f 00 16 	mcall	80006fa4 <prvUnlockQueue+0x9c>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
80006f50:	f0 1f 00 12 	mcall	80006f98 <prvUnlockQueue+0x90>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
80006f54:	6f 18       	ld.w	r8,r7[0x44]
80006f56:	58 08       	cp.w	r8,0
80006f58:	e0 8a 00 18 	brle	80006f88 <prvUnlockQueue+0x80>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80006f5c:	6e 48       	ld.w	r8,r7[0x10]
80006f5e:	58 08       	cp.w	r8,0
80006f60:	c1 40       	breq	80006f88 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80006f62:	ee c6 ff f0 	sub	r6,r7,-16
80006f66:	c0 48       	rjmp	80006f6e <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80006f68:	6e 48       	ld.w	r8,r7[0x10]
80006f6a:	58 08       	cp.w	r8,0
80006f6c:	c0 e0       	breq	80006f88 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80006f6e:	0c 9c       	mov	r12,r6
80006f70:	f0 1f 00 0b 	mcall	80006f9c <prvUnlockQueue+0x94>
80006f74:	c0 30       	breq	80006f7a <prvUnlockQueue+0x72>
				{
					vTaskMissedYield();
80006f76:	f0 1f 00 0b 	mcall	80006fa0 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xRxLock );
80006f7a:	6f 18       	ld.w	r8,r7[0x44]
80006f7c:	20 18       	sub	r8,1
80006f7e:	ef 48 00 44 	st.w	r7[68],r8
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
80006f82:	58 08       	cp.w	r8,0
80006f84:	fe 99 ff f2 	brgt	80006f68 <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
80006f88:	3f f8       	mov	r8,-1
80006f8a:	ef 48 00 44 	st.w	r7[68],r8
	}
	taskEXIT_CRITICAL();
80006f8e:	f0 1f 00 06 	mcall	80006fa4 <prvUnlockQueue+0x9c>
}
80006f92:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006f96:	00 00       	add	r0,r0
80006f98:	80 00       	ld.sh	r0,r0[0x0]
80006f9a:	6b f4       	ld.w	r4,r5[0x7c]
80006f9c:	80 00       	ld.sh	r0,r0[0x0]
80006f9e:	75 18       	ld.w	r8,r10[0x44]
80006fa0:	80 00       	ld.sh	r0,r0[0x0]
80006fa2:	74 24       	ld.w	r4,r10[0x8]
80006fa4:	80 00       	ld.sh	r0,r0[0x0]
80006fa6:	6d 00       	ld.w	r0,r6[0x40]

80006fa8 <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
80006fa8:	d4 31       	pushm	r0-r7,lr
80006faa:	20 5d       	sub	sp,20
80006fac:	18 97       	mov	r7,r12
80006fae:	50 0b       	stdsp	sp[0x0],r11
80006fb0:	50 2a       	stdsp	sp[0x8],r10
80006fb2:	50 19       	stdsp	sp[0x4],r9
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80006fb4:	f8 c2 ff dc 	sub	r2,r12,-36
80006fb8:	30 05       	mov	r5,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80006fba:	fa c4 ff f4 	sub	r4,sp,-12
80006fbe:	30 10       	mov	r0,1

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
80006fc0:	0a 91       	mov	r1,r5

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80006fc2:	fa c3 ff f8 	sub	r3,sp,-8
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
80006fc6:	f0 1f 00 3e 	mcall	800070bc <xQueueGenericReceive+0x114>
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80006fca:	6e e8       	ld.w	r8,r7[0x38]
80006fcc:	58 08       	cp.w	r8,0
80006fce:	c2 a0       	breq	80007022 <xQueueGenericReceive+0x7a>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
80006fd0:	6e 36       	ld.w	r6,r7[0xc]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
80006fd2:	40 0b       	lddsp	r11,sp[0x0]
80006fd4:	0e 9c       	mov	r12,r7
80006fd6:	f0 1f 00 3b 	mcall	800070c0 <xQueueGenericReceive+0x118>

				if( xJustPeeking == pdFALSE )
80006fda:	40 18       	lddsp	r8,sp[0x4]
80006fdc:	58 08       	cp.w	r8,0
80006fde:	c1 51       	brne	80007008 <xQueueGenericReceive+0x60>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
80006fe0:	6e e8       	ld.w	r8,r7[0x38]
80006fe2:	20 18       	sub	r8,1
80006fe4:	8f e8       	st.w	r7[0x38],r8

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80006fe6:	6e 08       	ld.w	r8,r7[0x0]
80006fe8:	58 08       	cp.w	r8,0
80006fea:	c0 41       	brne	80006ff2 <xQueueGenericReceive+0x4a>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
80006fec:	f0 1f 00 36 	mcall	800070c4 <xQueueGenericReceive+0x11c>
80006ff0:	8f 1c       	st.w	r7[0x4],r12
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80006ff2:	6e 48       	ld.w	r8,r7[0x10]
80006ff4:	58 08       	cp.w	r8,0
80006ff6:	c1 20       	breq	8000701a <xQueueGenericReceive+0x72>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
80006ff8:	ee cc ff f0 	sub	r12,r7,-16
80006ffc:	f0 1f 00 33 	mcall	800070c8 <xQueueGenericReceive+0x120>
80007000:	58 1c       	cp.w	r12,1
80007002:	c0 c1       	brne	8000701a <xQueueGenericReceive+0x72>
						{
							portYIELD_WITHIN_API();
80007004:	d7 33       	scall
80007006:	c0 a8       	rjmp	8000701a <xQueueGenericReceive+0x72>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
80007008:	8f 36       	st.w	r7[0xc],r6

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
8000700a:	6e 98       	ld.w	r8,r7[0x24]
8000700c:	58 08       	cp.w	r8,0
8000700e:	c0 60       	breq	8000701a <xQueueGenericReceive+0x72>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80007010:	04 9c       	mov	r12,r2
80007012:	f0 1f 00 2e 	mcall	800070c8 <xQueueGenericReceive+0x120>
80007016:	c0 20       	breq	8000701a <xQueueGenericReceive+0x72>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
80007018:	d7 33       	scall
						}
					}

				}

				taskEXIT_CRITICAL();
8000701a:	f0 1f 00 2d 	mcall	800070cc <xQueueGenericReceive+0x124>
8000701e:	30 1c       	mov	r12,1
				return pdPASS;
80007020:	c4 c8       	rjmp	800070b8 <xQueueGenericReceive+0x110>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
80007022:	40 28       	lddsp	r8,sp[0x8]
80007024:	58 08       	cp.w	r8,0
80007026:	c0 51       	brne	80007030 <xQueueGenericReceive+0x88>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80007028:	f0 1f 00 29 	mcall	800070cc <xQueueGenericReceive+0x124>
8000702c:	30 0c       	mov	r12,0
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
8000702e:	c4 58       	rjmp	800070b8 <xQueueGenericReceive+0x110>
				}
				else if( xEntryTimeSet == pdFALSE )
80007030:	58 05       	cp.w	r5,0
80007032:	c0 51       	brne	8000703c <xQueueGenericReceive+0x94>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80007034:	08 9c       	mov	r12,r4
80007036:	f0 1f 00 27 	mcall	800070d0 <xQueueGenericReceive+0x128>
8000703a:	00 95       	mov	r5,r0
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
8000703c:	f0 1f 00 24 	mcall	800070cc <xQueueGenericReceive+0x124>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80007040:	f0 1f 00 25 	mcall	800070d4 <xQueueGenericReceive+0x12c>
		prvLockQueue( pxQueue );
80007044:	f0 1f 00 1e 	mcall	800070bc <xQueueGenericReceive+0x114>
80007048:	6f 18       	ld.w	r8,r7[0x44]
8000704a:	5b f8       	cp.w	r8,-1
8000704c:	ef f1 0a 11 	st.weq	r7[0x44],r1
80007050:	6f 28       	ld.w	r8,r7[0x48]
80007052:	5b f8       	cp.w	r8,-1
80007054:	ef f1 0a 12 	st.weq	r7[0x48],r1
80007058:	f0 1f 00 1d 	mcall	800070cc <xQueueGenericReceive+0x124>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
8000705c:	06 9b       	mov	r11,r3
8000705e:	08 9c       	mov	r12,r4
80007060:	f0 1f 00 1e 	mcall	800070d8 <xQueueGenericReceive+0x130>
80007064:	c2 41       	brne	800070ac <xQueueGenericReceive+0x104>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
80007066:	f0 1f 00 16 	mcall	800070bc <xQueueGenericReceive+0x114>
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
8000706a:	6e e6       	ld.w	r6,r7[0x38]
	taskEXIT_CRITICAL();
8000706c:	f0 1f 00 18 	mcall	800070cc <xQueueGenericReceive+0x124>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) )
80007070:	58 06       	cp.w	r6,0
80007072:	c1 71       	brne	800070a0 <xQueueGenericReceive+0xf8>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80007074:	6e 08       	ld.w	r8,r7[0x0]
80007076:	58 08       	cp.w	r8,0
80007078:	c0 81       	brne	80007088 <xQueueGenericReceive+0xe0>
					{
						portENTER_CRITICAL();
8000707a:	f0 1f 00 11 	mcall	800070bc <xQueueGenericReceive+0x114>
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
8000707e:	6e 1c       	ld.w	r12,r7[0x4]
80007080:	f0 1f 00 17 	mcall	800070dc <xQueueGenericReceive+0x134>
						}
						portEXIT_CRITICAL();
80007084:	f0 1f 00 12 	mcall	800070cc <xQueueGenericReceive+0x124>
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80007088:	40 2b       	lddsp	r11,sp[0x8]
8000708a:	04 9c       	mov	r12,r2
8000708c:	f0 1f 00 15 	mcall	800070e0 <xQueueGenericReceive+0x138>
				prvUnlockQueue( pxQueue );
80007090:	0e 9c       	mov	r12,r7
80007092:	f0 1f 00 15 	mcall	800070e4 <xQueueGenericReceive+0x13c>
				if( !xTaskResumeAll() )
80007096:	f0 1f 00 15 	mcall	800070e8 <xQueueGenericReceive+0x140>
8000709a:	c9 61       	brne	80006fc6 <xQueueGenericReceive+0x1e>
				{
					portYIELD_WITHIN_API();
8000709c:	d7 33       	scall
8000709e:	c9 4b       	rjmp	80006fc6 <xQueueGenericReceive+0x1e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
800070a0:	0e 9c       	mov	r12,r7
800070a2:	f0 1f 00 11 	mcall	800070e4 <xQueueGenericReceive+0x13c>
				( void ) xTaskResumeAll();
800070a6:	f0 1f 00 11 	mcall	800070e8 <xQueueGenericReceive+0x140>
800070aa:	c8 eb       	rjmp	80006fc6 <xQueueGenericReceive+0x1e>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
800070ac:	0e 9c       	mov	r12,r7
800070ae:	f0 1f 00 0e 	mcall	800070e4 <xQueueGenericReceive+0x13c>
			( void ) xTaskResumeAll();
800070b2:	f0 1f 00 0e 	mcall	800070e8 <xQueueGenericReceive+0x140>
800070b6:	30 0c       	mov	r12,0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
800070b8:	2f bd       	sub	sp,-20
800070ba:	d8 32       	popm	r0-r7,pc
800070bc:	80 00       	ld.sh	r0,r0[0x0]
800070be:	6b f4       	ld.w	r4,r5[0x7c]
800070c0:	80 00       	ld.sh	r0,r0[0x0]
800070c2:	6e 88       	ld.w	r8,r7[0x20]
800070c4:	80 00       	ld.sh	r0,r0[0x0]
800070c6:	74 30       	ld.w	r0,r10[0xc]
800070c8:	80 00       	ld.sh	r0,r0[0x0]
800070ca:	75 18       	ld.w	r8,r10[0x44]
800070cc:	80 00       	ld.sh	r0,r0[0x0]
800070ce:	6d 00       	ld.w	r0,r6[0x40]
800070d0:	80 00       	ld.sh	r0,r0[0x0]
800070d2:	74 0c       	ld.w	r12,r10[0x0]
800070d4:	80 00       	ld.sh	r0,r0[0x0]
800070d6:	73 80       	ld.w	r0,r9[0x60]
800070d8:	80 00       	ld.sh	r0,r0[0x0]
800070da:	76 a8       	ld.w	r8,r11[0x28]
800070dc:	80 00       	ld.sh	r0,r0[0x0]
800070de:	74 94       	ld.w	r4,r10[0x24]
800070e0:	80 00       	ld.sh	r0,r0[0x0]
800070e2:	79 48       	ld.w	r8,r12[0x50]
800070e4:	80 00       	ld.sh	r0,r0[0x0]
800070e6:	6f 08       	ld.w	r8,r7[0x40]
800070e8:	80 00       	ld.sh	r0,r0[0x0]
800070ea:	77 3c       	ld.w	r12,r11[0x4c]

800070ec <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
800070ec:	eb cd 40 80 	pushm	r7,lr
800070f0:	18 97       	mov	r7,r12
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
800070f2:	79 08       	ld.w	r8,r12[0x40]
800070f4:	58 08       	cp.w	r8,0
800070f6:	c0 a1       	brne	8000710a <prvCopyDataToQueue+0x1e>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
800070f8:	78 08       	ld.w	r8,r12[0x0]
800070fa:	58 08       	cp.w	r8,0
800070fc:	c2 b1       	brne	80007152 <prvCopyDataToQueue+0x66>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
800070fe:	78 1c       	ld.w	r12,r12[0x4]
80007100:	f0 1f 00 17 	mcall	8000715c <prvCopyDataToQueue+0x70>
				pxQueue->pxMutexHolder = NULL;
80007104:	30 08       	mov	r8,0
80007106:	8f 18       	st.w	r7[0x4],r8
80007108:	c2 58       	rjmp	80007152 <prvCopyDataToQueue+0x66>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
8000710a:	58 0a       	cp.w	r10,0
8000710c:	c1 01       	brne	8000712c <prvCopyDataToQueue+0x40>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
8000710e:	10 9a       	mov	r10,r8
80007110:	78 2c       	ld.w	r12,r12[0x8]
80007112:	f0 1f 00 14 	mcall	80007160 <prvCopyDataToQueue+0x74>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
80007116:	6e 29       	ld.w	r9,r7[0x8]
80007118:	6f 08       	ld.w	r8,r7[0x40]
8000711a:	f2 08 00 08 	add	r8,r9,r8
8000711e:	8f 28       	st.w	r7[0x8],r8
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
80007120:	6e 19       	ld.w	r9,r7[0x4]
80007122:	12 38       	cp.w	r8,r9
80007124:	c1 73       	brcs	80007152 <prvCopyDataToQueue+0x66>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
80007126:	6e 08       	ld.w	r8,r7[0x0]
80007128:	8f 28       	st.w	r7[0x8],r8
8000712a:	c1 48       	rjmp	80007152 <prvCopyDataToQueue+0x66>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
8000712c:	10 9a       	mov	r10,r8
8000712e:	78 3c       	ld.w	r12,r12[0xc]
80007130:	f0 1f 00 0c 	mcall	80007160 <prvCopyDataToQueue+0x74>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
80007134:	6f 08       	ld.w	r8,r7[0x40]
80007136:	6e 39       	ld.w	r9,r7[0xc]
80007138:	f2 08 01 08 	sub	r8,r9,r8
8000713c:	8f 38       	st.w	r7[0xc],r8
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
8000713e:	6e 09       	ld.w	r9,r7[0x0]
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
80007140:	12 38       	cp.w	r8,r9
80007142:	ef f8 30 10 	ld.wcs	r8,r7[0x40]
80007146:	ef f9 30 01 	ld.wcs	r9,r7[0x4]
8000714a:	f3 d8 e3 19 	subcs	r9,r9,r8
8000714e:	ef f9 3a 03 	st.wcs	r7[0xc],r9
		}
	}

	++( pxQueue->uxMessagesWaiting );
80007152:	6e e8       	ld.w	r8,r7[0x38]
80007154:	2f f8       	sub	r8,-1
80007156:	8f e8       	st.w	r7[0x38],r8
}
80007158:	e3 cd 80 80 	ldm	sp++,r7,pc
8000715c:	80 00       	ld.sh	r0,r0[0x0]
8000715e:	74 3c       	ld.w	r12,r10[0xc]
80007160:	80 00       	ld.sh	r0,r0[0x0]
80007162:	86 8e       	ld.uh	lr,r3[0x0]

80007164 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
80007164:	eb cd 40 c0 	pushm	r6-r7,lr
80007168:	18 97       	mov	r7,r12
8000716a:	14 96       	mov	r6,r10
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
8000716c:	78 ec       	ld.w	r12,r12[0x38]
8000716e:	6e f8       	ld.w	r8,r7[0x3c]
80007170:	10 3c       	cp.w	r12,r8
80007172:	c0 33       	brcs	80007178 <xQueueGenericSendFromISR+0x14>
80007174:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80007178:	12 9a       	mov	r10,r9
8000717a:	0e 9c       	mov	r12,r7
8000717c:	f0 1f 00 0c 	mcall	800071ac <xQueueGenericSendFromISR+0x48>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
80007180:	6f 28       	ld.w	r8,r7[0x48]
80007182:	5b f8       	cp.w	r8,-1
80007184:	c0 d1       	brne	8000719e <xQueueGenericSendFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80007186:	6e 98       	ld.w	r8,r7[0x24]
80007188:	58 08       	cp.w	r8,0
8000718a:	c0 f0       	breq	800071a8 <xQueueGenericSendFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
8000718c:	ee cc ff dc 	sub	r12,r7,-36
80007190:	f0 1f 00 08 	mcall	800071b0 <xQueueGenericSendFromISR+0x4c>
80007194:	c0 a0       	breq	800071a8 <xQueueGenericSendFromISR+0x44>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
80007196:	30 1c       	mov	r12,1
80007198:	8d 0c       	st.w	r6[0x0],r12
8000719a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
8000719e:	2f f8       	sub	r8,-1
800071a0:	ef 48 00 48 	st.w	r7[72],r8
800071a4:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
800071a8:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
800071ac:	80 00       	ld.sh	r0,r0[0x0]
800071ae:	70 ec       	ld.w	r12,r8[0x38]
800071b0:	80 00       	ld.sh	r0,r0[0x0]
800071b2:	75 18       	ld.w	r8,r10[0x44]

800071b4 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
800071b4:	d4 31       	pushm	r0-r7,lr
800071b6:	20 5d       	sub	sp,20
800071b8:	18 97       	mov	r7,r12
800071ba:	50 0b       	stdsp	sp[0x0],r11
800071bc:	50 2a       	stdsp	sp[0x8],r10
800071be:	50 19       	stdsp	sp[0x4],r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
800071c0:	f8 c0 ff f0 	sub	r0,r12,-16
800071c4:	30 04       	mov	r4,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
800071c6:	fa c3 ff f4 	sub	r3,sp,-12

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
800071ca:	08 91       	mov	r1,r4

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
800071cc:	fa c2 ff f8 	sub	r2,sp,-8
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
800071d0:	f0 1f 00 2f 	mcall	8000728c <xQueueGenericSend+0xd8>
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
800071d4:	6e e9       	ld.w	r9,r7[0x38]
800071d6:	6e f8       	ld.w	r8,r7[0x3c]
800071d8:	10 39       	cp.w	r9,r8
800071da:	c1 42       	brcc	80007202 <xQueueGenericSend+0x4e>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
800071dc:	40 1a       	lddsp	r10,sp[0x4]
800071de:	40 0b       	lddsp	r11,sp[0x0]
800071e0:	0e 9c       	mov	r12,r7
800071e2:	f0 1f 00 2c 	mcall	80007290 <xQueueGenericSend+0xdc>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
800071e6:	6e 98       	ld.w	r8,r7[0x24]
800071e8:	58 08       	cp.w	r8,0
800071ea:	c0 80       	breq	800071fa <xQueueGenericSend+0x46>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
800071ec:	ee cc ff dc 	sub	r12,r7,-36
800071f0:	f0 1f 00 29 	mcall	80007294 <xQueueGenericSend+0xe0>
800071f4:	58 1c       	cp.w	r12,1
800071f6:	c0 21       	brne	800071fa <xQueueGenericSend+0x46>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
800071f8:	d7 33       	scall
					}
				}

				taskEXIT_CRITICAL();
800071fa:	f0 1f 00 28 	mcall	80007298 <xQueueGenericSend+0xe4>
800071fe:	30 1c       	mov	r12,1

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
80007200:	c4 38       	rjmp	80007286 <xQueueGenericSend+0xd2>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
80007202:	40 28       	lddsp	r8,sp[0x8]
80007204:	58 08       	cp.w	r8,0
80007206:	c0 51       	brne	80007210 <xQueueGenericSend+0x5c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80007208:	f0 1f 00 24 	mcall	80007298 <xQueueGenericSend+0xe4>
8000720c:	30 0c       	mov	r12,0

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
8000720e:	c3 c8       	rjmp	80007286 <xQueueGenericSend+0xd2>
				}
				else if( xEntryTimeSet == pdFALSE )
80007210:	58 04       	cp.w	r4,0
80007212:	c0 51       	brne	8000721c <xQueueGenericSend+0x68>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80007214:	06 9c       	mov	r12,r3
80007216:	f0 1f 00 22 	mcall	8000729c <xQueueGenericSend+0xe8>
8000721a:	30 14       	mov	r4,1
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
8000721c:	f0 1f 00 1f 	mcall	80007298 <xQueueGenericSend+0xe4>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80007220:	f0 1f 00 20 	mcall	800072a0 <xQueueGenericSend+0xec>
		prvLockQueue( pxQueue );
80007224:	f0 1f 00 1a 	mcall	8000728c <xQueueGenericSend+0xd8>
80007228:	6f 18       	ld.w	r8,r7[0x44]
8000722a:	5b f8       	cp.w	r8,-1
8000722c:	ef f1 0a 11 	st.weq	r7[0x44],r1
80007230:	6f 28       	ld.w	r8,r7[0x48]
80007232:	5b f8       	cp.w	r8,-1
80007234:	ef f1 0a 12 	st.weq	r7[0x48],r1
80007238:	f0 1f 00 18 	mcall	80007298 <xQueueGenericSend+0xe4>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
8000723c:	04 9b       	mov	r11,r2
8000723e:	06 9c       	mov	r12,r3
80007240:	f0 1f 00 19 	mcall	800072a4 <xQueueGenericSend+0xf0>
80007244:	c1 b1       	brne	8000727a <xQueueGenericSend+0xc6>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
80007246:	f0 1f 00 12 	mcall	8000728c <xQueueGenericSend+0xd8>
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
8000724a:	6e e5       	ld.w	r5,r7[0x38]
8000724c:	6e f6       	ld.w	r6,r7[0x3c]
	taskEXIT_CRITICAL();
8000724e:	f0 1f 00 13 	mcall	80007298 <xQueueGenericSend+0xe4>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
80007252:	0c 35       	cp.w	r5,r6
80007254:	c0 d1       	brne	8000726e <xQueueGenericSend+0xba>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
80007256:	40 2b       	lddsp	r11,sp[0x8]
80007258:	00 9c       	mov	r12,r0
8000725a:	f0 1f 00 14 	mcall	800072a8 <xQueueGenericSend+0xf4>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
8000725e:	0e 9c       	mov	r12,r7
80007260:	f0 1f 00 13 	mcall	800072ac <xQueueGenericSend+0xf8>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
80007264:	f0 1f 00 13 	mcall	800072b0 <xQueueGenericSend+0xfc>
80007268:	cb 41       	brne	800071d0 <xQueueGenericSend+0x1c>
				{
					portYIELD_WITHIN_API();
8000726a:	d7 33       	scall
8000726c:	cb 2b       	rjmp	800071d0 <xQueueGenericSend+0x1c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
8000726e:	0e 9c       	mov	r12,r7
80007270:	f0 1f 00 0f 	mcall	800072ac <xQueueGenericSend+0xf8>
				( void ) xTaskResumeAll();
80007274:	f0 1f 00 0f 	mcall	800072b0 <xQueueGenericSend+0xfc>
80007278:	ca cb       	rjmp	800071d0 <xQueueGenericSend+0x1c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
8000727a:	0e 9c       	mov	r12,r7
8000727c:	f0 1f 00 0c 	mcall	800072ac <xQueueGenericSend+0xf8>
			( void ) xTaskResumeAll();
80007280:	f0 1f 00 0c 	mcall	800072b0 <xQueueGenericSend+0xfc>
80007284:	30 0c       	mov	r12,0
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
80007286:	2f bd       	sub	sp,-20
80007288:	d8 32       	popm	r0-r7,pc
8000728a:	00 00       	add	r0,r0
8000728c:	80 00       	ld.sh	r0,r0[0x0]
8000728e:	6b f4       	ld.w	r4,r5[0x7c]
80007290:	80 00       	ld.sh	r0,r0[0x0]
80007292:	70 ec       	ld.w	r12,r8[0x38]
80007294:	80 00       	ld.sh	r0,r0[0x0]
80007296:	75 18       	ld.w	r8,r10[0x44]
80007298:	80 00       	ld.sh	r0,r0[0x0]
8000729a:	6d 00       	ld.w	r0,r6[0x40]
8000729c:	80 00       	ld.sh	r0,r0[0x0]
8000729e:	74 0c       	ld.w	r12,r10[0x0]
800072a0:	80 00       	ld.sh	r0,r0[0x0]
800072a2:	73 80       	ld.w	r0,r9[0x60]
800072a4:	80 00       	ld.sh	r0,r0[0x0]
800072a6:	76 a8       	ld.w	r8,r11[0x28]
800072a8:	80 00       	ld.sh	r0,r0[0x0]
800072aa:	79 48       	ld.w	r8,r12[0x50]
800072ac:	80 00       	ld.sh	r0,r0[0x0]
800072ae:	6f 08       	ld.w	r8,r7[0x40]
800072b0:	80 00       	ld.sh	r0,r0[0x0]
800072b2:	77 3c       	ld.w	r12,r11[0x4c]

800072b4 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	xQueueHandle xQueueCreateMutex( void )
	{
800072b4:	eb cd 40 c0 	pushm	r6-r7,lr
	xQUEUE *pxNewQueue;

		/* Allocate the new queue structure. */
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
800072b8:	34 cc       	mov	r12,76
800072ba:	f0 1f 00 12 	mcall	80007300 <xQueueCreateMutex+0x4c>
800072be:	18 97       	mov	r7,r12
		if( pxNewQueue != NULL )
800072c0:	c1 d0       	breq	800072fa <xQueueCreateMutex+0x46>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
800072c2:	30 06       	mov	r6,0
800072c4:	99 16       	st.w	r12[0x4],r6
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
800072c6:	99 06       	st.w	r12[0x0],r6

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
800072c8:	99 26       	st.w	r12[0x8],r6
			pxNewQueue->pcReadFrom = NULL;
800072ca:	99 36       	st.w	r12[0xc],r6

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
800072cc:	99 e6       	st.w	r12[0x38],r6
			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
800072ce:	30 18       	mov	r8,1
800072d0:	99 f8       	st.w	r12[0x3c],r8
			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
800072d2:	f9 46 00 40 	st.w	r12[64],r6
			pxNewQueue->xRxLock = queueUNLOCKED;
800072d6:	3f f8       	mov	r8,-1
800072d8:	f9 48 00 44 	st.w	r12[68],r8
			pxNewQueue->xTxLock = queueUNLOCKED;
800072dc:	f9 48 00 48 	st.w	r12[72],r8

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
800072e0:	2f 0c       	sub	r12,-16
800072e2:	f0 1f 00 09 	mcall	80007304 <xQueueCreateMutex+0x50>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
800072e6:	ee cc ff dc 	sub	r12,r7,-36
800072ea:	f0 1f 00 07 	mcall	80007304 <xQueueCreateMutex+0x50>

			/* Start with the semaphore in the expected state. */
			xQueueGenericSend( pxNewQueue, NULL, ( portTickType ) 0U, queueSEND_TO_BACK );
800072ee:	0c 99       	mov	r9,r6
800072f0:	0c 9a       	mov	r10,r6
800072f2:	0c 9b       	mov	r11,r6
800072f4:	0e 9c       	mov	r12,r7
800072f6:	f0 1f 00 05 	mcall	80007308 <xQueueCreateMutex+0x54>
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
800072fa:	0e 9c       	mov	r12,r7
800072fc:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80007300:	80 00       	ld.sh	r0,r0[0x0]
80007302:	6e 60       	ld.w	r0,r7[0x18]
80007304:	80 00       	ld.sh	r0,r0[0x0]
80007306:	6a d0       	ld.w	r0,r5[0x34]
80007308:	80 00       	ld.sh	r0,r0[0x0]
8000730a:	71 b4       	ld.w	r4,r8[0x6c]

8000730c <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
8000730c:	d4 21       	pushm	r4-r7,lr
8000730e:	18 97       	mov	r7,r12
80007310:	16 96       	mov	r6,r11
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
80007312:	58 0c       	cp.w	r12,0
80007314:	c2 f0       	breq	80007372 <xQueueCreate+0x66>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
80007316:	34 cc       	mov	r12,76
80007318:	f0 1f 00 17 	mcall	80007374 <xQueueCreate+0x68>
8000731c:	18 95       	mov	r5,r12
		if( pxNewQueue != NULL )
8000731e:	c2 a0       	breq	80007372 <xQueueCreate+0x66>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
80007320:	ec 07 02 44 	mul	r4,r6,r7

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
80007324:	e8 cc ff ff 	sub	r12,r4,-1
80007328:	f0 1f 00 13 	mcall	80007374 <xQueueCreate+0x68>
8000732c:	8b 0c       	st.w	r5[0x0],r12
			if( pxNewQueue->pcHead != NULL )
8000732e:	c1 e0       	breq	8000736a <xQueueCreate+0x5e>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
80007330:	f8 04 00 04 	add	r4,r12,r4
80007334:	8b 14       	st.w	r5[0x4],r4
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
80007336:	30 08       	mov	r8,0
80007338:	8b e8       	st.w	r5[0x38],r8
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
8000733a:	8b 2c       	st.w	r5[0x8],r12
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
8000733c:	ee c8 00 01 	sub	r8,r7,1
80007340:	ad 38       	mul	r8,r6
80007342:	10 0c       	add	r12,r8
80007344:	8b 3c       	st.w	r5[0xc],r12
				pxNewQueue->uxLength = uxQueueLength;
80007346:	8b f7       	st.w	r5[0x3c],r7
				pxNewQueue->uxItemSize = uxItemSize;
80007348:	eb 46 00 40 	st.w	r5[64],r6
				pxNewQueue->xRxLock = queueUNLOCKED;
8000734c:	3f f8       	mov	r8,-1
8000734e:	eb 48 00 44 	st.w	r5[68],r8
				pxNewQueue->xTxLock = queueUNLOCKED;
80007352:	eb 48 00 48 	st.w	r5[72],r8

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
80007356:	ea cc ff f0 	sub	r12,r5,-16
8000735a:	f0 1f 00 08 	mcall	80007378 <xQueueCreate+0x6c>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
8000735e:	ea cc ff dc 	sub	r12,r5,-36
80007362:	f0 1f 00 06 	mcall	80007378 <xQueueCreate+0x6c>
80007366:	0a 9c       	mov	r12,r5
80007368:	d8 22       	popm	r4-r7,pc
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
8000736a:	0a 9c       	mov	r12,r5
8000736c:	f0 1f 00 04 	mcall	8000737c <xQueueCreate+0x70>
80007370:	d8 2a       	popm	r4-r7,pc,r12=0
80007372:	d8 2a       	popm	r4-r7,pc,r12=0
80007374:	80 00       	ld.sh	r0,r0[0x0]
80007376:	6e 60       	ld.w	r0,r7[0x18]
80007378:	80 00       	ld.sh	r0,r0[0x0]
8000737a:	6a d0       	ld.w	r0,r5[0x34]
8000737c:	80 00       	ld.sh	r0,r0[0x0]
8000737e:	6e 38       	ld.w	r8,r7[0xc]

80007380 <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
80007380:	48 38       	lddpc	r8,8000738c <vTaskSuspendAll+0xc>
80007382:	70 09       	ld.w	r9,r8[0x0]
80007384:	2f f9       	sub	r9,-1
80007386:	91 09       	st.w	r8[0x0],r9
}
80007388:	5e fc       	retal	r12
8000738a:	00 00       	add	r0,r0
8000738c:	00 00       	add	r0,r0
8000738e:	0d 9c       	ld.ub	r12,r6[0x1]

80007390 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
80007390:	49 a8       	lddpc	r8,800073f8 <vTaskSwitchContext+0x68>
80007392:	70 08       	ld.w	r8,r8[0x0]
80007394:	58 08       	cp.w	r8,0
80007396:	c0 b1       	brne	800073ac <vTaskSwitchContext+0x1c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80007398:	49 98       	lddpc	r8,800073fc <vTaskSwitchContext+0x6c>
8000739a:	70 08       	ld.w	r8,r8[0x0]
8000739c:	f0 08 00 28 	add	r8,r8,r8<<0x2
800073a0:	49 89       	lddpc	r9,80007400 <vTaskSwitchContext+0x70>
800073a2:	f2 08 03 28 	ld.w	r8,r9[r8<<0x2]
800073a6:	58 08       	cp.w	r8,0
800073a8:	c0 60       	breq	800073b4 <vTaskSwitchContext+0x24>
800073aa:	c1 18       	rjmp	800073cc <vTaskSwitchContext+0x3c>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
800073ac:	30 19       	mov	r9,1
800073ae:	49 68       	lddpc	r8,80007404 <vTaskSwitchContext+0x74>
800073b0:	91 09       	st.w	r8[0x0],r9
800073b2:	5e fc       	retal	r12

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
800073b4:	49 28       	lddpc	r8,800073fc <vTaskSwitchContext+0x6c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
800073b6:	49 3a       	lddpc	r10,80007400 <vTaskSwitchContext+0x70>
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
800073b8:	70 09       	ld.w	r9,r8[0x0]
800073ba:	20 19       	sub	r9,1
800073bc:	91 09       	st.w	r8[0x0],r9

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
800073be:	70 09       	ld.w	r9,r8[0x0]
800073c0:	f2 09 00 29 	add	r9,r9,r9<<0x2
800073c4:	f4 09 03 29 	ld.w	r9,r10[r9<<0x2]
800073c8:	58 09       	cp.w	r9,0
800073ca:	cf 70       	breq	800073b8 <vTaskSwitchContext+0x28>
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
800073cc:	48 c8       	lddpc	r8,800073fc <vTaskSwitchContext+0x6c>
800073ce:	70 08       	ld.w	r8,r8[0x0]
800073d0:	f0 08 00 28 	add	r8,r8,r8<<0x2
800073d4:	48 b9       	lddpc	r9,80007400 <vTaskSwitchContext+0x70>
800073d6:	f2 08 00 28 	add	r8,r9,r8<<0x2
800073da:	70 19       	ld.w	r9,r8[0x4]
800073dc:	72 19       	ld.w	r9,r9[0x4]
800073de:	91 19       	st.w	r8[0x4],r9
800073e0:	f0 ca ff f8 	sub	r10,r8,-8
800073e4:	14 39       	cp.w	r9,r10
800073e6:	f3 f9 00 01 	ld.weq	r9,r9[0x4]
800073ea:	f1 f9 0a 01 	st.weq	r8[0x4],r9
800073ee:	70 18       	ld.w	r8,r8[0x4]
800073f0:	70 39       	ld.w	r9,r8[0xc]
800073f2:	48 68       	lddpc	r8,80007408 <vTaskSwitchContext+0x78>
800073f4:	91 09       	st.w	r8[0x0],r9
800073f6:	5e fc       	retal	r12
800073f8:	00 00       	add	r0,r0
800073fa:	0d 9c       	ld.ub	r12,r6[0x1]
800073fc:	00 00       	add	r0,r0
800073fe:	0d d4       	ld.ub	r4,r6[0x5]
80007400:	00 00       	add	r0,r0
80007402:	0c b8       	st.h	r6++,r8
80007404:	00 00       	add	r0,r0
80007406:	0d bc       	ld.ub	r12,r6[0x3]
80007408:	00 00       	add	r0,r0
8000740a:	0d 6c       	ld.uh	r12,--r6

8000740c <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
8000740c:	48 48       	lddpc	r8,8000741c <vTaskSetTimeOutState+0x10>
8000740e:	70 08       	ld.w	r8,r8[0x0]
80007410:	99 08       	st.w	r12[0x0],r8
	pxTimeOut->xTimeOnEntering = xTickCount;
80007412:	48 48       	lddpc	r8,80007420 <vTaskSetTimeOutState+0x14>
80007414:	70 08       	ld.w	r8,r8[0x0]
80007416:	99 18       	st.w	r12[0x4],r8
}
80007418:	5e fc       	retal	r12
8000741a:	00 00       	add	r0,r0
8000741c:	00 00       	add	r0,r0
8000741e:	0c b0       	st.h	r6++,r0
80007420:	00 00       	add	r0,r0
80007422:	0d 98       	ld.ub	r8,r6[0x1]

80007424 <vTaskMissedYield>:
}
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
80007424:	30 19       	mov	r9,1
80007426:	48 28       	lddpc	r8,8000742c <vTaskMissedYield+0x8>
80007428:	91 09       	st.w	r8[0x0],r9
}
8000742a:	5e fc       	retal	r12
8000742c:	00 00       	add	r0,r0
8000742e:	0d bc       	ld.ub	r12,r6[0x3]

80007430 <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
80007430:	48 28       	lddpc	r8,80007438 <xTaskGetCurrentTaskHandle+0x8>
80007432:	70 0c       	ld.w	r12,r8[0x0]

		return xReturn;
	}
80007434:	5e fc       	retal	r12
80007436:	00 00       	add	r0,r0
80007438:	00 00       	add	r0,r0
8000743a:	0d 6c       	ld.uh	r12,--r6

8000743c <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
8000743c:	eb cd 40 c0 	pushm	r6-r7,lr
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
80007440:	58 0c       	cp.w	r12,0
80007442:	c1 f0       	breq	80007480 <vTaskPriorityDisinherit+0x44>

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
80007444:	18 97       	mov	r7,r12

		if( pxMutexHolder != NULL )
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
80007446:	78 b9       	ld.w	r9,r12[0x2c]
80007448:	79 18       	ld.w	r8,r12[0x44]
8000744a:	10 39       	cp.w	r9,r8
8000744c:	c1 a0       	breq	80007480 <vTaskPriorityDisinherit+0x44>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
8000744e:	f8 c6 ff fc 	sub	r6,r12,-4
80007452:	0c 9c       	mov	r12,r6
80007454:	f0 1f 00 0c 	mcall	80007484 <vTaskPriorityDisinherit+0x48>

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
80007458:	6f 1c       	ld.w	r12,r7[0x44]
8000745a:	8f bc       	st.w	r7[0x2c],r12
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
8000745c:	f8 08 11 08 	rsub	r8,r12,8
80007460:	8f 68       	st.w	r7[0x18],r8
				prvAddTaskToReadyQueue( pxTCB );
80007462:	48 a8       	lddpc	r8,80007488 <vTaskPriorityDisinherit+0x4c>
80007464:	70 08       	ld.w	r8,r8[0x0]
80007466:	10 3c       	cp.w	r12,r8
80007468:	e0 88 00 04 	brls	80007470 <vTaskPriorityDisinherit+0x34>
8000746c:	48 78       	lddpc	r8,80007488 <vTaskPriorityDisinherit+0x4c>
8000746e:	91 0c       	st.w	r8[0x0],r12
80007470:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80007474:	0c 9b       	mov	r11,r6
80007476:	48 68       	lddpc	r8,8000748c <vTaskPriorityDisinherit+0x50>
80007478:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
8000747c:	f0 1f 00 05 	mcall	80007490 <vTaskPriorityDisinherit+0x54>
80007480:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80007484:	80 00       	ld.sh	r0,r0[0x0]
80007486:	6b 3a       	ld.w	r10,r5[0x4c]
80007488:	00 00       	add	r0,r0
8000748a:	0d d4       	ld.ub	r4,r6[0x5]
8000748c:	00 00       	add	r0,r0
8000748e:	0c b8       	st.h	r6++,r8
80007490:	80 00       	ld.sh	r0,r0[0x0]
80007492:	6a ea       	ld.w	r10,r5[0x38]

80007494 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
80007494:	eb cd 40 c0 	pushm	r6-r7,lr
80007498:	18 97       	mov	r7,r12
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
8000749a:	49 b8       	lddpc	r8,80007504 <vTaskPriorityInherit+0x70>
8000749c:	70 08       	ld.w	r8,r8[0x0]
8000749e:	78 b9       	ld.w	r9,r12[0x2c]
800074a0:	70 b8       	ld.w	r8,r8[0x2c]
800074a2:	10 39       	cp.w	r9,r8
800074a4:	c2 d2       	brcc	800074fe <vTaskPriorityInherit+0x6a>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
800074a6:	49 88       	lddpc	r8,80007504 <vTaskPriorityInherit+0x70>
800074a8:	70 08       	ld.w	r8,r8[0x0]
800074aa:	70 b8       	ld.w	r8,r8[0x2c]
800074ac:	f0 08 11 08 	rsub	r8,r8,8
800074b0:	99 68       	st.w	r12[0x18],r8

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
800074b2:	f2 09 00 28 	add	r8,r9,r9<<0x2
800074b6:	49 59       	lddpc	r9,80007508 <vTaskPriorityInherit+0x74>
800074b8:	f2 08 00 28 	add	r8,r9,r8<<0x2
800074bc:	78 59       	ld.w	r9,r12[0x14]
800074be:	10 39       	cp.w	r9,r8
800074c0:	c1 b1       	brne	800074f6 <vTaskPriorityInherit+0x62>
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
800074c2:	f8 c6 ff fc 	sub	r6,r12,-4
800074c6:	0c 9c       	mov	r12,r6
800074c8:	f0 1f 00 11 	mcall	8000750c <vTaskPriorityInherit+0x78>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
800074cc:	48 e8       	lddpc	r8,80007504 <vTaskPriorityInherit+0x70>
800074ce:	70 08       	ld.w	r8,r8[0x0]
800074d0:	70 bc       	ld.w	r12,r8[0x2c]
800074d2:	8f bc       	st.w	r7[0x2c],r12
				prvAddTaskToReadyQueue( pxTCB );
800074d4:	48 f8       	lddpc	r8,80007510 <vTaskPriorityInherit+0x7c>
800074d6:	70 08       	ld.w	r8,r8[0x0]
800074d8:	10 3c       	cp.w	r12,r8
800074da:	e0 88 00 04 	brls	800074e2 <vTaskPriorityInherit+0x4e>
800074de:	48 d8       	lddpc	r8,80007510 <vTaskPriorityInherit+0x7c>
800074e0:	91 0c       	st.w	r8[0x0],r12
800074e2:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800074e6:	0c 9b       	mov	r11,r6
800074e8:	48 88       	lddpc	r8,80007508 <vTaskPriorityInherit+0x74>
800074ea:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800074ee:	f0 1f 00 0a 	mcall	80007514 <vTaskPriorityInherit+0x80>
800074f2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
800074f6:	48 48       	lddpc	r8,80007504 <vTaskPriorityInherit+0x70>
800074f8:	70 08       	ld.w	r8,r8[0x0]
800074fa:	70 b8       	ld.w	r8,r8[0x2c]
800074fc:	99 b8       	st.w	r12[0x2c],r8
800074fe:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80007502:	00 00       	add	r0,r0
80007504:	00 00       	add	r0,r0
80007506:	0d 6c       	ld.uh	r12,--r6
80007508:	00 00       	add	r0,r0
8000750a:	0c b8       	st.h	r6++,r8
8000750c:	80 00       	ld.sh	r0,r0[0x0]
8000750e:	6b 3a       	ld.w	r10,r5[0x4c]
80007510:	00 00       	add	r0,r0
80007512:	0d d4       	ld.ub	r4,r6[0x5]
80007514:	80 00       	ld.sh	r0,r0[0x0]
80007516:	6a ea       	ld.w	r10,r5[0x38]

80007518 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
80007518:	eb cd 40 c0 	pushm	r6-r7,lr
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
8000751c:	78 38       	ld.w	r8,r12[0xc]
8000751e:	70 37       	ld.w	r7,r8[0xc]
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
80007520:	ee c6 ff e8 	sub	r6,r7,-24
80007524:	0c 9c       	mov	r12,r6
80007526:	f0 1f 00 15 	mcall	80007578 <xTaskRemoveFromEventList+0x60>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
8000752a:	49 58       	lddpc	r8,8000757c <xTaskRemoveFromEventList+0x64>
8000752c:	70 08       	ld.w	r8,r8[0x0]
8000752e:	58 08       	cp.w	r8,0
80007530:	c1 71       	brne	8000755e <xTaskRemoveFromEventList+0x46>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
80007532:	ee c6 ff fc 	sub	r6,r7,-4
80007536:	0c 9c       	mov	r12,r6
80007538:	f0 1f 00 10 	mcall	80007578 <xTaskRemoveFromEventList+0x60>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
8000753c:	6e bc       	ld.w	r12,r7[0x2c]
8000753e:	49 18       	lddpc	r8,80007580 <xTaskRemoveFromEventList+0x68>
80007540:	70 08       	ld.w	r8,r8[0x0]
80007542:	10 3c       	cp.w	r12,r8
80007544:	e0 88 00 04 	brls	8000754c <xTaskRemoveFromEventList+0x34>
80007548:	48 e8       	lddpc	r8,80007580 <xTaskRemoveFromEventList+0x68>
8000754a:	91 0c       	st.w	r8[0x0],r12
8000754c:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80007550:	0c 9b       	mov	r11,r6
80007552:	48 d8       	lddpc	r8,80007584 <xTaskRemoveFromEventList+0x6c>
80007554:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80007558:	f0 1f 00 0c 	mcall	80007588 <xTaskRemoveFromEventList+0x70>
8000755c:	c0 58       	rjmp	80007566 <xTaskRemoveFromEventList+0x4e>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
8000755e:	0c 9b       	mov	r11,r6
80007560:	48 bc       	lddpc	r12,8000758c <xTaskRemoveFromEventList+0x74>
80007562:	f0 1f 00 0a 	mcall	80007588 <xTaskRemoveFromEventList+0x70>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
80007566:	48 b8       	lddpc	r8,80007590 <xTaskRemoveFromEventList+0x78>
80007568:	70 08       	ld.w	r8,r8[0x0]
8000756a:	6e b9       	ld.w	r9,r7[0x2c]
8000756c:	70 b8       	ld.w	r8,r8[0x2c]
8000756e:	10 39       	cp.w	r9,r8
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
80007570:	5f 2c       	srhs	r12
80007572:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80007576:	00 00       	add	r0,r0
80007578:	80 00       	ld.sh	r0,r0[0x0]
8000757a:	6b 3a       	ld.w	r10,r5[0x4c]
8000757c:	00 00       	add	r0,r0
8000757e:	0d 9c       	ld.ub	r12,r6[0x1]
80007580:	00 00       	add	r0,r0
80007582:	0d d4       	ld.ub	r4,r6[0x5]
80007584:	00 00       	add	r0,r0
80007586:	0c b8       	st.h	r6++,r8
80007588:	80 00       	ld.sh	r0,r0[0x0]
8000758a:	6a ea       	ld.w	r10,r5[0x38]
8000758c:	00 00       	add	r0,r0
8000758e:	0d 70       	ld.ub	r0,--r6
80007590:	00 00       	add	r0,r0
80007592:	0d 6c       	ld.uh	r12,--r6

80007594 <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
80007594:	eb cd 40 fc 	pushm	r2-r7,lr
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80007598:	4b 98       	lddpc	r8,8000767c <vTaskIncrementTick+0xe8>
8000759a:	70 08       	ld.w	r8,r8[0x0]
8000759c:	58 08       	cp.w	r8,0
8000759e:	c6 91       	brne	80007670 <vTaskIncrementTick+0xdc>
	{
		++xTickCount;
800075a0:	4b 88       	lddpc	r8,80007680 <vTaskIncrementTick+0xec>
800075a2:	70 09       	ld.w	r9,r8[0x0]
800075a4:	2f f9       	sub	r9,-1
800075a6:	91 09       	st.w	r8[0x0],r9
		if( xTickCount == ( portTickType ) 0 )
800075a8:	70 08       	ld.w	r8,r8[0x0]
800075aa:	58 08       	cp.w	r8,0
800075ac:	c1 a1       	brne	800075e0 <vTaskIncrementTick+0x4c>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
800075ae:	4b 68       	lddpc	r8,80007684 <vTaskIncrementTick+0xf0>
800075b0:	70 0a       	ld.w	r10,r8[0x0]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
800075b2:	4b 69       	lddpc	r9,80007688 <vTaskIncrementTick+0xf4>
800075b4:	72 0b       	ld.w	r11,r9[0x0]
800075b6:	91 0b       	st.w	r8[0x0],r11
			pxOverflowDelayedTaskList = pxTemp;
800075b8:	93 0a       	st.w	r9[0x0],r10
			xNumOfOverflows++;
800075ba:	4b 59       	lddpc	r9,8000768c <vTaskIncrementTick+0xf8>
800075bc:	72 0a       	ld.w	r10,r9[0x0]
800075be:	2f fa       	sub	r10,-1
800075c0:	93 0a       	st.w	r9[0x0],r10

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
800075c2:	70 08       	ld.w	r8,r8[0x0]
800075c4:	70 08       	ld.w	r8,r8[0x0]
800075c6:	58 08       	cp.w	r8,0
800075c8:	c0 51       	brne	800075d2 <vTaskIncrementTick+0x3e>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
800075ca:	3f f9       	mov	r9,-1
800075cc:	4b 18       	lddpc	r8,80007690 <vTaskIncrementTick+0xfc>
800075ce:	91 09       	st.w	r8[0x0],r9
800075d0:	c0 88       	rjmp	800075e0 <vTaskIncrementTick+0x4c>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
800075d2:	4a d8       	lddpc	r8,80007684 <vTaskIncrementTick+0xf0>
800075d4:	70 08       	ld.w	r8,r8[0x0]
800075d6:	70 38       	ld.w	r8,r8[0xc]
800075d8:	70 38       	ld.w	r8,r8[0xc]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
800075da:	70 19       	ld.w	r9,r8[0x4]
800075dc:	4a d8       	lddpc	r8,80007690 <vTaskIncrementTick+0xfc>
800075de:	91 09       	st.w	r8[0x0],r9
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
800075e0:	4a 88       	lddpc	r8,80007680 <vTaskIncrementTick+0xec>
800075e2:	70 09       	ld.w	r9,r8[0x0]
800075e4:	4a b8       	lddpc	r8,80007690 <vTaskIncrementTick+0xfc>
800075e6:	70 08       	ld.w	r8,r8[0x0]
800075e8:	10 39       	cp.w	r9,r8
800075ea:	c4 73       	brcs	80007678 <vTaskIncrementTick+0xe4>
800075ec:	4a 68       	lddpc	r8,80007684 <vTaskIncrementTick+0xf0>
800075ee:	70 08       	ld.w	r8,r8[0x0]
800075f0:	70 08       	ld.w	r8,r8[0x0]
800075f2:	58 08       	cp.w	r8,0
800075f4:	c0 c0       	breq	8000760c <vTaskIncrementTick+0x78>
800075f6:	4a 48       	lddpc	r8,80007684 <vTaskIncrementTick+0xf0>
800075f8:	70 08       	ld.w	r8,r8[0x0]
800075fa:	70 38       	ld.w	r8,r8[0xc]
800075fc:	70 37       	ld.w	r7,r8[0xc]
800075fe:	6e 18       	ld.w	r8,r7[0x4]
80007600:	4a 09       	lddpc	r9,80007680 <vTaskIncrementTick+0xec>
80007602:	72 09       	ld.w	r9,r9[0x0]
80007604:	12 38       	cp.w	r8,r9
80007606:	e0 88 00 14 	brls	8000762e <vTaskIncrementTick+0x9a>
8000760a:	c0 e8       	rjmp	80007626 <vTaskIncrementTick+0x92>
8000760c:	3f f9       	mov	r9,-1
8000760e:	4a 18       	lddpc	r8,80007690 <vTaskIncrementTick+0xfc>
80007610:	91 09       	st.w	r8[0x0],r9
80007612:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80007616:	6a 08       	ld.w	r8,r5[0x0]
80007618:	70 38       	ld.w	r8,r8[0xc]
8000761a:	70 37       	ld.w	r7,r8[0xc]
8000761c:	6e 18       	ld.w	r8,r7[0x4]
8000761e:	64 09       	ld.w	r9,r2[0x0]
80007620:	12 38       	cp.w	r8,r9
80007622:	e0 88 00 0a 	brls	80007636 <vTaskIncrementTick+0xa2>
80007626:	49 b9       	lddpc	r9,80007690 <vTaskIncrementTick+0xfc>
80007628:	93 08       	st.w	r9[0x0],r8
8000762a:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
8000762e:	49 a4       	lddpc	r4,80007694 <vTaskIncrementTick+0x100>
80007630:	49 a3       	lddpc	r3,80007698 <vTaskIncrementTick+0x104>
80007632:	49 55       	lddpc	r5,80007684 <vTaskIncrementTick+0xf0>
80007634:	49 32       	lddpc	r2,80007680 <vTaskIncrementTick+0xec>
80007636:	ee c6 ff fc 	sub	r6,r7,-4
8000763a:	0c 9c       	mov	r12,r6
8000763c:	f0 1f 00 18 	mcall	8000769c <vTaskIncrementTick+0x108>
80007640:	6e a8       	ld.w	r8,r7[0x28]
80007642:	58 08       	cp.w	r8,0
80007644:	c0 50       	breq	8000764e <vTaskIncrementTick+0xba>
80007646:	ee cc ff e8 	sub	r12,r7,-24
8000764a:	f0 1f 00 15 	mcall	8000769c <vTaskIncrementTick+0x108>
8000764e:	6e bc       	ld.w	r12,r7[0x2c]
80007650:	68 08       	ld.w	r8,r4[0x0]
80007652:	10 3c       	cp.w	r12,r8
80007654:	e9 fc ba 00 	st.whi	r4[0x0],r12
80007658:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
8000765c:	0c 9b       	mov	r11,r6
8000765e:	e6 0c 00 2c 	add	r12,r3,r12<<0x2
80007662:	f0 1f 00 10 	mcall	800076a0 <vTaskIncrementTick+0x10c>
80007666:	6a 08       	ld.w	r8,r5[0x0]
80007668:	70 08       	ld.w	r8,r8[0x0]
8000766a:	58 08       	cp.w	r8,0
8000766c:	cd 51       	brne	80007616 <vTaskIncrementTick+0x82>
8000766e:	cc fb       	rjmp	8000760c <vTaskIncrementTick+0x78>
	}
	else
	{
		++uxMissedTicks;
80007670:	48 d8       	lddpc	r8,800076a4 <vTaskIncrementTick+0x110>
80007672:	70 09       	ld.w	r9,r8[0x0]
80007674:	2f f9       	sub	r9,-1
80007676:	91 09       	st.w	r8[0x0],r9
80007678:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
8000767c:	00 00       	add	r0,r0
8000767e:	0d 9c       	ld.ub	r12,r6[0x1]
80007680:	00 00       	add	r0,r0
80007682:	0d 98       	ld.ub	r8,r6[0x1]
80007684:	00 00       	add	r0,r0
80007686:	0c a4       	st.w	r6++,r4
80007688:	00 00       	add	r0,r0
8000768a:	0c b4       	st.h	r6++,r4
8000768c:	00 00       	add	r0,r0
8000768e:	0c b0       	st.h	r6++,r0
80007690:	00 00       	add	r0,r0
80007692:	05 50       	ld.sh	r0,--r2
80007694:	00 00       	add	r0,r0
80007696:	0d d4       	ld.ub	r4,r6[0x5]
80007698:	00 00       	add	r0,r0
8000769a:	0c b8       	st.h	r6++,r8
8000769c:	80 00       	ld.sh	r0,r0[0x0]
8000769e:	6b 3a       	ld.w	r10,r5[0x4c]
800076a0:	80 00       	ld.sh	r0,r0[0x0]
800076a2:	6a ea       	ld.w	r10,r5[0x38]
800076a4:	00 00       	add	r0,r0
800076a6:	0c 9c       	mov	r12,r6

800076a8 <xTaskCheckForTimeOut>:
	pxTimeOut->xTimeOnEntering = xTickCount;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
800076a8:	eb cd 40 c0 	pushm	r6-r7,lr
800076ac:	18 97       	mov	r7,r12
800076ae:	16 96       	mov	r6,r11
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
800076b0:	f0 1f 00 15 	mcall	80007704 <xTaskCheckForTimeOut+0x5c>
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
800076b4:	6c 08       	ld.w	r8,r6[0x0]
800076b6:	5b f8       	cp.w	r8,-1
800076b8:	c0 31       	brne	800076be <xTaskCheckForTimeOut+0x16>
800076ba:	30 07       	mov	r7,0
800076bc:	c1 f8       	rjmp	800076fa <xTaskCheckForTimeOut+0x52>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
800076be:	49 39       	lddpc	r9,80007708 <xTaskCheckForTimeOut+0x60>
800076c0:	72 09       	ld.w	r9,r9[0x0]
800076c2:	6e 0a       	ld.w	r10,r7[0x0]
800076c4:	12 3a       	cp.w	r10,r9
800076c6:	c0 70       	breq	800076d4 <xTaskCheckForTimeOut+0x2c>
800076c8:	49 19       	lddpc	r9,8000770c <xTaskCheckForTimeOut+0x64>
800076ca:	72 09       	ld.w	r9,r9[0x0]
800076cc:	6e 1a       	ld.w	r10,r7[0x4]
800076ce:	12 3a       	cp.w	r10,r9
800076d0:	e0 88 00 14 	brls	800076f8 <xTaskCheckForTimeOut+0x50>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
800076d4:	48 e9       	lddpc	r9,8000770c <xTaskCheckForTimeOut+0x64>
800076d6:	72 0a       	ld.w	r10,r9[0x0]
800076d8:	6e 19       	ld.w	r9,r7[0x4]
800076da:	12 1a       	sub	r10,r9
800076dc:	14 38       	cp.w	r8,r10
800076de:	e0 88 00 0d 	brls	800076f8 <xTaskCheckForTimeOut+0x50>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
800076e2:	48 ba       	lddpc	r10,8000770c <xTaskCheckForTimeOut+0x64>
800076e4:	74 0a       	ld.w	r10,r10[0x0]
800076e6:	14 19       	sub	r9,r10
800076e8:	f2 08 00 08 	add	r8,r9,r8
800076ec:	8d 08       	st.w	r6[0x0],r8
			vTaskSetTimeOutState( pxTimeOut );
800076ee:	0e 9c       	mov	r12,r7
800076f0:	f0 1f 00 08 	mcall	80007710 <xTaskCheckForTimeOut+0x68>
800076f4:	30 07       	mov	r7,0
800076f6:	c0 28       	rjmp	800076fa <xTaskCheckForTimeOut+0x52>
800076f8:	30 17       	mov	r7,1
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
800076fa:	f0 1f 00 07 	mcall	80007714 <xTaskCheckForTimeOut+0x6c>

	return xReturn;
}
800076fe:	0e 9c       	mov	r12,r7
80007700:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80007704:	80 00       	ld.sh	r0,r0[0x0]
80007706:	6b f4       	ld.w	r4,r5[0x7c]
80007708:	00 00       	add	r0,r0
8000770a:	0c b0       	st.h	r6++,r0
8000770c:	00 00       	add	r0,r0
8000770e:	0d 98       	ld.ub	r8,r6[0x1]
80007710:	80 00       	ld.sh	r0,r0[0x0]
80007712:	74 0c       	ld.w	r12,r10[0x0]
80007714:	80 00       	ld.sh	r0,r0[0x0]
80007716:	6d 00       	ld.w	r0,r6[0x40]

80007718 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
80007718:	eb cd 40 80 	pushm	r7,lr
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
8000771c:	f0 1f 00 05 	mcall	80007730 <xTaskGetTickCount+0x18>
	{
		xTicks = xTickCount;
80007720:	48 58       	lddpc	r8,80007734 <xTaskGetTickCount+0x1c>
80007722:	70 07       	ld.w	r7,r8[0x0]
	}
	taskEXIT_CRITICAL();
80007724:	f0 1f 00 05 	mcall	80007738 <xTaskGetTickCount+0x20>

	return xTicks;
}
80007728:	0e 9c       	mov	r12,r7
8000772a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000772e:	00 00       	add	r0,r0
80007730:	80 00       	ld.sh	r0,r0[0x0]
80007732:	6b f4       	ld.w	r4,r5[0x7c]
80007734:	00 00       	add	r0,r0
80007736:	0d 98       	ld.ub	r8,r6[0x1]
80007738:	80 00       	ld.sh	r0,r0[0x0]
8000773a:	6d 00       	ld.w	r0,r6[0x40]

8000773c <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
8000773c:	eb cd 40 fe 	pushm	r1-r7,lr
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
80007740:	f0 1f 00 2c 	mcall	800077f0 <xTaskResumeAll+0xb4>
	{
		--uxSchedulerSuspended;
80007744:	4a c8       	lddpc	r8,800077f4 <xTaskResumeAll+0xb8>
80007746:	70 09       	ld.w	r9,r8[0x0]
80007748:	20 19       	sub	r9,1
8000774a:	91 09       	st.w	r8[0x0],r9

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
8000774c:	70 08       	ld.w	r8,r8[0x0]
8000774e:	58 08       	cp.w	r8,0
80007750:	c4 91       	brne	800077e2 <xTaskResumeAll+0xa6>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
80007752:	4a a8       	lddpc	r8,800077f8 <xTaskResumeAll+0xbc>
80007754:	70 08       	ld.w	r8,r8[0x0]
80007756:	58 08       	cp.w	r8,0
80007758:	c4 50       	breq	800077e2 <xTaskResumeAll+0xa6>
8000775a:	30 04       	mov	r4,0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
8000775c:	4a 85       	lddpc	r5,800077fc <xTaskResumeAll+0xc0>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
8000775e:	4a 93       	lddpc	r3,80007800 <xTaskResumeAll+0xc4>
80007760:	4a 92       	lddpc	r2,80007804 <xTaskResumeAll+0xc8>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80007762:	4a a1       	lddpc	r1,80007808 <xTaskResumeAll+0xcc>
80007764:	c1 e8       	rjmp	800077a0 <xTaskResumeAll+0x64>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
80007766:	6a 38       	ld.w	r8,r5[0xc]
80007768:	70 37       	ld.w	r7,r8[0xc]
					vListRemove( &( pxTCB->xEventListItem ) );
8000776a:	ee cc ff e8 	sub	r12,r7,-24
8000776e:	f0 1f 00 28 	mcall	8000780c <xTaskResumeAll+0xd0>
					vListRemove( &( pxTCB->xGenericListItem ) );
80007772:	ee c6 ff fc 	sub	r6,r7,-4
80007776:	0c 9c       	mov	r12,r6
80007778:	f0 1f 00 25 	mcall	8000780c <xTaskResumeAll+0xd0>
					prvAddTaskToReadyQueue( pxTCB );
8000777c:	6e bc       	ld.w	r12,r7[0x2c]
8000777e:	66 08       	ld.w	r8,r3[0x0]
80007780:	10 3c       	cp.w	r12,r8
80007782:	e7 fc ba 00 	st.whi	r3[0x0],r12
80007786:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
8000778a:	0c 9b       	mov	r11,r6
8000778c:	e4 0c 00 2c 	add	r12,r2,r12<<0x2
80007790:	f0 1f 00 20 	mcall	80007810 <xTaskResumeAll+0xd4>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80007794:	62 08       	ld.w	r8,r1[0x0]
80007796:	6e b9       	ld.w	r9,r7[0x2c]
80007798:	70 b8       	ld.w	r8,r8[0x2c]
8000779a:	10 39       	cp.w	r9,r8
8000779c:	f9 b4 02 01 	movhs	r4,1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
800077a0:	6a 08       	ld.w	r8,r5[0x0]
800077a2:	58 08       	cp.w	r8,0
800077a4:	ce 11       	brne	80007766 <xTaskResumeAll+0x2a>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
800077a6:	49 c8       	lddpc	r8,80007814 <xTaskResumeAll+0xd8>
800077a8:	70 08       	ld.w	r8,r8[0x0]
800077aa:	58 08       	cp.w	r8,0
800077ac:	c0 f0       	breq	800077ca <xTaskResumeAll+0x8e>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
800077ae:	49 a8       	lddpc	r8,80007814 <xTaskResumeAll+0xd8>
800077b0:	70 08       	ld.w	r8,r8[0x0]
800077b2:	58 08       	cp.w	r8,0
800077b4:	c1 10       	breq	800077d6 <xTaskResumeAll+0x9a>
					{
						vTaskIncrementTick();
						--uxMissedTicks;
800077b6:	49 87       	lddpc	r7,80007814 <xTaskResumeAll+0xd8>
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
800077b8:	f0 1f 00 18 	mcall	80007818 <xTaskResumeAll+0xdc>
						--uxMissedTicks;
800077bc:	6e 08       	ld.w	r8,r7[0x0]
800077be:	20 18       	sub	r8,1
800077c0:	8f 08       	st.w	r7[0x0],r8
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
800077c2:	6e 08       	ld.w	r8,r7[0x0]
800077c4:	58 08       	cp.w	r8,0
800077c6:	cf 91       	brne	800077b8 <xTaskResumeAll+0x7c>
800077c8:	c0 78       	rjmp	800077d6 <xTaskResumeAll+0x9a>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
800077ca:	58 14       	cp.w	r4,1
800077cc:	c0 50       	breq	800077d6 <xTaskResumeAll+0x9a>
800077ce:	49 48       	lddpc	r8,8000781c <xTaskResumeAll+0xe0>
800077d0:	70 08       	ld.w	r8,r8[0x0]
800077d2:	58 18       	cp.w	r8,1
800077d4:	c0 71       	brne	800077e2 <xTaskResumeAll+0xa6>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
800077d6:	30 09       	mov	r9,0
800077d8:	49 18       	lddpc	r8,8000781c <xTaskResumeAll+0xe0>
800077da:	91 09       	st.w	r8[0x0],r9
					portYIELD_WITHIN_API();
800077dc:	d7 33       	scall
800077de:	30 17       	mov	r7,1
800077e0:	c0 28       	rjmp	800077e4 <xTaskResumeAll+0xa8>
800077e2:	30 07       	mov	r7,0
				}
			}
		}
	}
	taskEXIT_CRITICAL();
800077e4:	f0 1f 00 0f 	mcall	80007820 <xTaskResumeAll+0xe4>

	return xAlreadyYielded;
}
800077e8:	0e 9c       	mov	r12,r7
800077ea:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
800077ee:	00 00       	add	r0,r0
800077f0:	80 00       	ld.sh	r0,r0[0x0]
800077f2:	6b f4       	ld.w	r4,r5[0x7c]
800077f4:	00 00       	add	r0,r0
800077f6:	0d 9c       	ld.ub	r12,r6[0x1]
800077f8:	00 00       	add	r0,r0
800077fa:	0d b8       	ld.ub	r8,r6[0x3]
800077fc:	00 00       	add	r0,r0
800077fe:	0d 70       	ld.ub	r0,--r6
80007800:	00 00       	add	r0,r0
80007802:	0d d4       	ld.ub	r4,r6[0x5]
80007804:	00 00       	add	r0,r0
80007806:	0c b8       	st.h	r6++,r8
80007808:	00 00       	add	r0,r0
8000780a:	0d 6c       	ld.uh	r12,--r6
8000780c:	80 00       	ld.sh	r0,r0[0x0]
8000780e:	6b 3a       	ld.w	r10,r5[0x4c]
80007810:	80 00       	ld.sh	r0,r0[0x0]
80007812:	6a ea       	ld.w	r10,r5[0x38]
80007814:	00 00       	add	r0,r0
80007816:	0c 9c       	mov	r12,r6
80007818:	80 00       	ld.sh	r0,r0[0x0]
8000781a:	75 94       	ld.w	r4,r10[0x64]
8000781c:	00 00       	add	r0,r0
8000781e:	0d bc       	ld.ub	r12,r6[0x3]
80007820:	80 00       	ld.sh	r0,r0[0x0]
80007822:	6d 00       	ld.w	r0,r6[0x40]

80007824 <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
80007824:	eb cd 40 80 	pushm	r7,lr
80007828:	18 97       	mov	r7,r12
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
8000782a:	49 08       	lddpc	r8,80007868 <prvAddCurrentTaskToDelayedList+0x44>
8000782c:	70 08       	ld.w	r8,r8[0x0]
8000782e:	91 1c       	st.w	r8[0x4],r12

	if( xTimeToWake < xTickCount )
80007830:	48 f8       	lddpc	r8,8000786c <prvAddCurrentTaskToDelayedList+0x48>
80007832:	70 08       	ld.w	r8,r8[0x0]
80007834:	10 3c       	cp.w	r12,r8
80007836:	c0 a2       	brcc	8000784a <prvAddCurrentTaskToDelayedList+0x26>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80007838:	48 c8       	lddpc	r8,80007868 <prvAddCurrentTaskToDelayedList+0x44>
8000783a:	70 0b       	ld.w	r11,r8[0x0]
8000783c:	48 d8       	lddpc	r8,80007870 <prvAddCurrentTaskToDelayedList+0x4c>
8000783e:	70 0c       	ld.w	r12,r8[0x0]
80007840:	2f cb       	sub	r11,-4
80007842:	f0 1f 00 0d 	mcall	80007874 <prvAddCurrentTaskToDelayedList+0x50>
80007846:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
8000784a:	48 88       	lddpc	r8,80007868 <prvAddCurrentTaskToDelayedList+0x44>
8000784c:	70 0b       	ld.w	r11,r8[0x0]
8000784e:	48 b8       	lddpc	r8,80007878 <prvAddCurrentTaskToDelayedList+0x54>
80007850:	70 0c       	ld.w	r12,r8[0x0]
80007852:	2f cb       	sub	r11,-4
80007854:	f0 1f 00 08 	mcall	80007874 <prvAddCurrentTaskToDelayedList+0x50>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
80007858:	48 98       	lddpc	r8,8000787c <prvAddCurrentTaskToDelayedList+0x58>
8000785a:	70 08       	ld.w	r8,r8[0x0]
8000785c:	10 37       	cp.w	r7,r8
8000785e:	c0 32       	brcc	80007864 <prvAddCurrentTaskToDelayedList+0x40>
		{
			xNextTaskUnblockTime = xTimeToWake;
80007860:	48 78       	lddpc	r8,8000787c <prvAddCurrentTaskToDelayedList+0x58>
80007862:	91 07       	st.w	r8[0x0],r7
80007864:	e3 cd 80 80 	ldm	sp++,r7,pc
80007868:	00 00       	add	r0,r0
8000786a:	0d 6c       	ld.uh	r12,--r6
8000786c:	00 00       	add	r0,r0
8000786e:	0d 98       	ld.ub	r8,r6[0x1]
80007870:	00 00       	add	r0,r0
80007872:	0c b4       	st.h	r6++,r4
80007874:	80 00       	ld.sh	r0,r0[0x0]
80007876:	6b 06       	ld.w	r6,r5[0x40]
80007878:	00 00       	add	r0,r0
8000787a:	0c a4       	st.w	r6++,r4
8000787c:	00 00       	add	r0,r0
8000787e:	05 50       	ld.sh	r0,--r2

80007880 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
80007880:	eb cd 40 c0 	pushm	r6-r7,lr
80007884:	18 97       	mov	r7,r12
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0 )
80007886:	58 0c       	cp.w	r12,0
80007888:	c1 10       	breq	800078aa <vTaskDelay+0x2a>
		{
			vTaskSuspendAll();
8000788a:	f0 1f 00 0a 	mcall	800078b0 <vTaskDelay+0x30>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
8000788e:	48 a8       	lddpc	r8,800078b4 <vTaskDelay+0x34>
80007890:	70 06       	ld.w	r6,r8[0x0]

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80007892:	48 a8       	lddpc	r8,800078b8 <vTaskDelay+0x38>
80007894:	70 0c       	ld.w	r12,r8[0x0]
80007896:	2f cc       	sub	r12,-4
80007898:	f0 1f 00 09 	mcall	800078bc <vTaskDelay+0x3c>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
8000789c:	ee 06 00 0c 	add	r12,r7,r6
800078a0:	f0 1f 00 08 	mcall	800078c0 <vTaskDelay+0x40>
			}
			xAlreadyYielded = xTaskResumeAll();
800078a4:	f0 1f 00 08 	mcall	800078c4 <vTaskDelay+0x44>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
800078a8:	c0 21       	brne	800078ac <vTaskDelay+0x2c>
		{
			portYIELD_WITHIN_API();
800078aa:	d7 33       	scall
800078ac:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800078b0:	80 00       	ld.sh	r0,r0[0x0]
800078b2:	73 80       	ld.w	r0,r9[0x60]
800078b4:	00 00       	add	r0,r0
800078b6:	0d 98       	ld.ub	r8,r6[0x1]
800078b8:	00 00       	add	r0,r0
800078ba:	0d 6c       	ld.uh	r12,--r6
800078bc:	80 00       	ld.sh	r0,r0[0x0]
800078be:	6b 3a       	ld.w	r10,r5[0x4c]
800078c0:	80 00       	ld.sh	r0,r0[0x0]
800078c2:	78 24       	ld.w	r4,r12[0x8]
800078c4:	80 00       	ld.sh	r0,r0[0x0]
800078c6:	77 3c       	ld.w	r12,r11[0x4c]

800078c8 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
800078c8:	eb cd 40 c0 	pushm	r6-r7,lr
800078cc:	18 96       	mov	r6,r12
800078ce:	16 97       	mov	r7,r11
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0 ) );

		vTaskSuspendAll();
800078d0:	f0 1f 00 18 	mcall	80007930 <vTaskDelayUntil+0x68>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
800078d4:	6c 08       	ld.w	r8,r6[0x0]
800078d6:	10 07       	add	r7,r8

			if( xTickCount < *pxPreviousWakeTime )
800078d8:	49 79       	lddpc	r9,80007934 <vTaskDelayUntil+0x6c>
800078da:	72 09       	ld.w	r9,r9[0x0]
800078dc:	12 38       	cp.w	r8,r9
800078de:	e0 88 00 0c 	brls	800078f6 <vTaskDelayUntil+0x2e>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
800078e2:	0e 38       	cp.w	r8,r7
800078e4:	e0 88 00 22 	brls	80007928 <vTaskDelayUntil+0x60>
800078e8:	49 38       	lddpc	r8,80007934 <vTaskDelayUntil+0x6c>
800078ea:	70 08       	ld.w	r8,r8[0x0]
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
800078ec:	8d 07       	st.w	r6[0x0],r7

			if( xShouldDelay != pdFALSE )
800078ee:	10 37       	cp.w	r7,r8
800078f0:	e0 88 00 14 	brls	80007918 <vTaskDelayUntil+0x50>
800078f4:	c0 a8       	rjmp	80007908 <vTaskDelayUntil+0x40>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
800078f6:	0e 38       	cp.w	r8,r7
800078f8:	e0 8b 00 16 	brhi	80007924 <vTaskDelayUntil+0x5c>
800078fc:	48 e8       	lddpc	r8,80007934 <vTaskDelayUntil+0x6c>
800078fe:	70 08       	ld.w	r8,r8[0x0]
80007900:	10 37       	cp.w	r7,r8
80007902:	e0 8b 00 11 	brhi	80007924 <vTaskDelayUntil+0x5c>
80007906:	c1 18       	rjmp	80007928 <vTaskDelayUntil+0x60>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80007908:	48 c8       	lddpc	r8,80007938 <vTaskDelayUntil+0x70>
8000790a:	70 0c       	ld.w	r12,r8[0x0]
8000790c:	2f cc       	sub	r12,-4
8000790e:	f0 1f 00 0c 	mcall	8000793c <vTaskDelayUntil+0x74>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
80007912:	0e 9c       	mov	r12,r7
80007914:	f0 1f 00 0b 	mcall	80007940 <vTaskDelayUntil+0x78>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
80007918:	f0 1f 00 0b 	mcall	80007944 <vTaskDelayUntil+0x7c>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
8000791c:	c0 81       	brne	8000792c <vTaskDelayUntil+0x64>
		{
			portYIELD_WITHIN_API();
8000791e:	d7 33       	scall
80007920:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80007924:	8d 07       	st.w	r6[0x0],r7
80007926:	cf 1b       	rjmp	80007908 <vTaskDelayUntil+0x40>
80007928:	8d 07       	st.w	r6[0x0],r7
8000792a:	cf 7b       	rjmp	80007918 <vTaskDelayUntil+0x50>
8000792c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80007930:	80 00       	ld.sh	r0,r0[0x0]
80007932:	73 80       	ld.w	r0,r9[0x60]
80007934:	00 00       	add	r0,r0
80007936:	0d 98       	ld.ub	r8,r6[0x1]
80007938:	00 00       	add	r0,r0
8000793a:	0d 6c       	ld.uh	r12,--r6
8000793c:	80 00       	ld.sh	r0,r0[0x0]
8000793e:	6b 3a       	ld.w	r10,r5[0x4c]
80007940:	80 00       	ld.sh	r0,r0[0x0]
80007942:	78 24       	ld.w	r4,r12[0x8]
80007944:	80 00       	ld.sh	r0,r0[0x0]
80007946:	77 3c       	ld.w	r12,r11[0x4c]

80007948 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
80007948:	eb cd 40 c0 	pushm	r6-r7,lr
8000794c:	16 96       	mov	r6,r11
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
8000794e:	48 e7       	lddpc	r7,80007984 <vTaskPlaceOnEventList+0x3c>
80007950:	6e 0b       	ld.w	r11,r7[0x0]
80007952:	2e 8b       	sub	r11,-24
80007954:	f0 1f 00 0d 	mcall	80007988 <vTaskPlaceOnEventList+0x40>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80007958:	6e 0c       	ld.w	r12,r7[0x0]
8000795a:	2f cc       	sub	r12,-4
8000795c:	f0 1f 00 0c 	mcall	8000798c <vTaskPlaceOnEventList+0x44>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
80007960:	5b f6       	cp.w	r6,-1
80007962:	c0 81       	brne	80007972 <vTaskPlaceOnEventList+0x2a>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80007964:	6e 0b       	ld.w	r11,r7[0x0]
80007966:	2f cb       	sub	r11,-4
80007968:	48 ac       	lddpc	r12,80007990 <vTaskPlaceOnEventList+0x48>
8000796a:	f0 1f 00 0b 	mcall	80007994 <vTaskPlaceOnEventList+0x4c>
8000796e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
80007972:	48 a8       	lddpc	r8,80007998 <vTaskPlaceOnEventList+0x50>
80007974:	70 0c       	ld.w	r12,r8[0x0]
			prvAddCurrentTaskToDelayedList( xTimeToWake );
80007976:	ec 0c 00 0c 	add	r12,r6,r12
8000797a:	f0 1f 00 09 	mcall	8000799c <vTaskPlaceOnEventList+0x54>
8000797e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80007982:	00 00       	add	r0,r0
80007984:	00 00       	add	r0,r0
80007986:	0d 6c       	ld.uh	r12,--r6
80007988:	80 00       	ld.sh	r0,r0[0x0]
8000798a:	6b 06       	ld.w	r6,r5[0x40]
8000798c:	80 00       	ld.sh	r0,r0[0x0]
8000798e:	6b 3a       	ld.w	r10,r5[0x4c]
80007990:	00 00       	add	r0,r0
80007992:	0d c0       	ld.ub	r0,r6[0x4]
80007994:	80 00       	ld.sh	r0,r0[0x0]
80007996:	6a ea       	ld.w	r10,r5[0x38]
80007998:	00 00       	add	r0,r0
8000799a:	0d 98       	ld.ub	r8,r6[0x1]
8000799c:	80 00       	ld.sh	r0,r0[0x0]
8000799e:	78 24       	ld.w	r4,r12[0x8]

800079a0 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
800079a0:	eb cd 40 f8 	pushm	r3-r7,lr
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
800079a4:	49 67       	lddpc	r7,800079fc <prvIdleTask+0x5c>
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
800079a6:	49 74       	lddpc	r4,80007a00 <prvIdleTask+0x60>

				taskENTER_CRITICAL();
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					--uxCurrentNumberOfTasks;
800079a8:	49 73       	lddpc	r3,80007a04 <prvIdleTask+0x64>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
800079aa:	49 85       	lddpc	r5,80007a08 <prvIdleTask+0x68>
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
800079ac:	6e 08       	ld.w	r8,r7[0x0]
800079ae:	58 08       	cp.w	r8,0
800079b0:	c1 e0       	breq	800079ec <prvIdleTask+0x4c>
		{
			vTaskSuspendAll();
800079b2:	f0 1f 00 17 	mcall	80007a0c <prvIdleTask+0x6c>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
800079b6:	68 06       	ld.w	r6,r4[0x0]
			xTaskResumeAll();
800079b8:	f0 1f 00 16 	mcall	80007a10 <prvIdleTask+0x70>

			if( xListIsEmpty == pdFALSE )
800079bc:	58 06       	cp.w	r6,0
800079be:	c1 70       	breq	800079ec <prvIdleTask+0x4c>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
800079c0:	f0 1f 00 15 	mcall	80007a14 <prvIdleTask+0x74>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
800079c4:	68 38       	ld.w	r8,r4[0xc]
800079c6:	70 36       	ld.w	r6,r8[0xc]
					vListRemove( &( pxTCB->xGenericListItem ) );
800079c8:	ec cc ff fc 	sub	r12,r6,-4
800079cc:	f0 1f 00 13 	mcall	80007a18 <prvIdleTask+0x78>
					--uxCurrentNumberOfTasks;
800079d0:	66 08       	ld.w	r8,r3[0x0]
800079d2:	20 18       	sub	r8,1
800079d4:	87 08       	st.w	r3[0x0],r8
					--uxTasksDeleted;
800079d6:	6e 08       	ld.w	r8,r7[0x0]
800079d8:	20 18       	sub	r8,1
800079da:	8f 08       	st.w	r7[0x0],r8
				}
				taskEXIT_CRITICAL();
800079dc:	f0 1f 00 10 	mcall	80007a1c <prvIdleTask+0x7c>

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
800079e0:	6c cc       	ld.w	r12,r6[0x30]
800079e2:	f0 1f 00 10 	mcall	80007a20 <prvIdleTask+0x80>
		vPortFree( pxTCB );
800079e6:	0c 9c       	mov	r12,r6
800079e8:	f0 1f 00 0e 	mcall	80007a20 <prvIdleTask+0x80>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
800079ec:	6a 08       	ld.w	r8,r5[0x0]
800079ee:	58 18       	cp.w	r8,1
800079f0:	e0 88 00 03 	brls	800079f6 <prvIdleTask+0x56>
			{
				taskYIELD();
800079f4:	d7 33       	scall
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
800079f6:	f0 1f 00 0c 	mcall	80007a24 <prvIdleTask+0x84>
		}
		#endif
	}
800079fa:	cd 9b       	rjmp	800079ac <prvIdleTask+0xc>
800079fc:	00 00       	add	r0,r0
800079fe:	0c ac       	st.w	r6++,r12
80007a00:	00 00       	add	r0,r0
80007a02:	0d 58       	ld.sh	r8,--r6
80007a04:	00 00       	add	r0,r0
80007a06:	0d b8       	ld.ub	r8,r6[0x3]
80007a08:	00 00       	add	r0,r0
80007a0a:	0c b8       	st.h	r6++,r8
80007a0c:	80 00       	ld.sh	r0,r0[0x0]
80007a0e:	73 80       	ld.w	r0,r9[0x60]
80007a10:	80 00       	ld.sh	r0,r0[0x0]
80007a12:	77 3c       	ld.w	r12,r11[0x4c]
80007a14:	80 00       	ld.sh	r0,r0[0x0]
80007a16:	6b f4       	ld.w	r4,r5[0x7c]
80007a18:	80 00       	ld.sh	r0,r0[0x0]
80007a1a:	6b 3a       	ld.w	r10,r5[0x4c]
80007a1c:	80 00       	ld.sh	r0,r0[0x0]
80007a1e:	6d 00       	ld.w	r0,r6[0x40]
80007a20:	80 00       	ld.sh	r0,r0[0x0]
80007a22:	6e 38       	ld.w	r8,r7[0xc]
80007a24:	80 00       	ld.sh	r0,r0[0x0]
80007a26:	20 48       	sub	r8,4

80007a28 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
80007a28:	d4 31       	pushm	r0-r7,lr
80007a2a:	20 1d       	sub	sp,4
80007a2c:	fa c4 ff d8 	sub	r4,sp,-40
80007a30:	50 0c       	stdsp	sp[0x0],r12
80007a32:	16 91       	mov	r1,r11
80007a34:	14 97       	mov	r7,r10
80007a36:	12 90       	mov	r0,r9
80007a38:	10 93       	mov	r3,r8
80007a3a:	68 02       	ld.w	r2,r4[0x0]
80007a3c:	68 16       	ld.w	r6,r4[0x4]
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
80007a3e:	34 8c       	mov	r12,72
80007a40:	f0 1f 00 5c 	mcall	80007bb0 <xTaskGenericCreate+0x188>
80007a44:	18 95       	mov	r5,r12

	if( pxNewTCB != NULL )
80007a46:	c0 31       	brne	80007a4c <xTaskGenericCreate+0x24>
80007a48:	3f fc       	mov	r12,-1
80007a4a:	ca f8       	rjmp	80007ba8 <xTaskGenericCreate+0x180>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80007a4c:	58 06       	cp.w	r6,0
80007a4e:	e0 81 00 af 	brne	80007bac <xTaskGenericCreate+0x184>
80007a52:	0e 9c       	mov	r12,r7
80007a54:	5c 7c       	castu.h	r12
80007a56:	a3 6c       	lsl	r12,0x2
80007a58:	f0 1f 00 56 	mcall	80007bb0 <xTaskGenericCreate+0x188>
80007a5c:	18 96       	mov	r6,r12
80007a5e:	8b cc       	st.w	r5[0x30],r12

		if( pxNewTCB->pxStack == NULL )
80007a60:	c0 61       	brne	80007a6c <xTaskGenericCreate+0x44>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
80007a62:	0a 9c       	mov	r12,r5
80007a64:	f0 1f 00 54 	mcall	80007bb4 <xTaskGenericCreate+0x18c>
80007a68:	3f fc       	mov	r12,-1
80007a6a:	c9 f8       	rjmp	80007ba8 <xTaskGenericCreate+0x180>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
80007a6c:	5c 77       	castu.h	r7
80007a6e:	ee 0a 15 02 	lsl	r10,r7,0x2
80007a72:	e0 6b 00 a5 	mov	r11,165
80007a76:	0c 9c       	mov	r12,r6
80007a78:	f0 1f 00 50 	mcall	80007bb8 <xTaskGenericCreate+0x190>
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~portBYTE_ALIGNMENT_MASK  ) );
80007a7c:	ee c6 00 01 	sub	r6,r7,1
80007a80:	6a c8       	ld.w	r8,r5[0x30]
80007a82:	f0 06 00 26 	add	r6,r8,r6<<0x2
80007a86:	e0 16 ff fc 	andl	r6,0xfffc
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
80007a8a:	31 0a       	mov	r10,16
80007a8c:	02 9b       	mov	r11,r1
80007a8e:	ea cc ff cc 	sub	r12,r5,-52
80007a92:	f0 1f 00 4b 	mcall	80007bbc <xTaskGenericCreate+0x194>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
80007a96:	30 08       	mov	r8,0
80007a98:	eb 68 00 43 	st.b	r5[67],r8
80007a9c:	58 73       	cp.w	r3,7
80007a9e:	e6 07 17 80 	movls	r7,r3
80007aa2:	f9 b7 0b 07 	movhi	r7,7
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
80007aa6:	8b b7       	st.w	r5[0x2c],r7
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
80007aa8:	eb 47 00 44 	st.w	r5[68],r7
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
80007aac:	ea c4 ff fc 	sub	r4,r5,-4
80007ab0:	08 9c       	mov	r12,r4
80007ab2:	f0 1f 00 44 	mcall	80007bc0 <xTaskGenericCreate+0x198>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
80007ab6:	ea cc ff e8 	sub	r12,r5,-24
80007aba:	f0 1f 00 42 	mcall	80007bc0 <xTaskGenericCreate+0x198>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
80007abe:	8b 45       	st.w	r5[0x10],r5

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
80007ac0:	ee 07 11 08 	rsub	r7,r7,8
80007ac4:	8b 67       	st.w	r5[0x18],r7
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
80007ac6:	8b 95       	st.w	r5[0x24],r5
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
80007ac8:	00 9a       	mov	r10,r0
80007aca:	40 0b       	lddsp	r11,sp[0x0]
80007acc:	0c 9c       	mov	r12,r6
80007ace:	f0 1f 00 3e 	mcall	80007bc4 <xTaskGenericCreate+0x19c>
80007ad2:	8b 0c       	st.w	r5[0x0],r12
		if( ( void * ) pxCreatedTask != NULL )
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
80007ad4:	58 02       	cp.w	r2,0
80007ad6:	e5 f5 1a 00 	st.wne	r2[0x0],r5
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
80007ada:	f0 1f 00 3c 	mcall	80007bc8 <xTaskGenericCreate+0x1a0>
		{
			uxCurrentNumberOfTasks++;
80007ade:	4b c8       	lddpc	r8,80007bcc <xTaskGenericCreate+0x1a4>
80007ae0:	70 09       	ld.w	r9,r8[0x0]
80007ae2:	2f f9       	sub	r9,-1
80007ae4:	91 09       	st.w	r8[0x0],r9
			if( pxCurrentTCB == NULL )
80007ae6:	4b b8       	lddpc	r8,80007bd0 <xTaskGenericCreate+0x1a8>
80007ae8:	70 08       	ld.w	r8,r8[0x0]
80007aea:	58 08       	cp.w	r8,0
80007aec:	c2 61       	brne	80007b38 <xTaskGenericCreate+0x110>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
80007aee:	4b 98       	lddpc	r8,80007bd0 <xTaskGenericCreate+0x1a8>
80007af0:	91 05       	st.w	r8[0x0],r5

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
80007af2:	4b 78       	lddpc	r8,80007bcc <xTaskGenericCreate+0x1a4>
80007af4:	70 08       	ld.w	r8,r8[0x0]
80007af6:	58 18       	cp.w	r8,1
80007af8:	c2 b1       	brne	80007b4e <xTaskGenericCreate+0x126>
80007afa:	4b 77       	lddpc	r7,80007bd4 <xTaskGenericCreate+0x1ac>

/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
80007afc:	ee c6 ff 60 	sub	r6,r7,-160
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
80007b00:	0e 9c       	mov	r12,r7
80007b02:	f0 1f 00 36 	mcall	80007bd8 <xTaskGenericCreate+0x1b0>
80007b06:	2e c7       	sub	r7,-20

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
80007b08:	0c 37       	cp.w	r7,r6
80007b0a:	cf b1       	brne	80007b00 <xTaskGenericCreate+0xd8>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
80007b0c:	4b 47       	lddpc	r7,80007bdc <xTaskGenericCreate+0x1b4>
80007b0e:	0e 9c       	mov	r12,r7
80007b10:	f0 1f 00 32 	mcall	80007bd8 <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
80007b14:	4b 36       	lddpc	r6,80007be0 <xTaskGenericCreate+0x1b8>
80007b16:	0c 9c       	mov	r12,r6
80007b18:	f0 1f 00 30 	mcall	80007bd8 <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xPendingReadyList );
80007b1c:	4b 2c       	lddpc	r12,80007be4 <xTaskGenericCreate+0x1bc>
80007b1e:	f0 1f 00 2f 	mcall	80007bd8 <xTaskGenericCreate+0x1b0>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
80007b22:	4b 2c       	lddpc	r12,80007be8 <xTaskGenericCreate+0x1c0>
80007b24:	f0 1f 00 2d 	mcall	80007bd8 <xTaskGenericCreate+0x1b0>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
80007b28:	4b 1c       	lddpc	r12,80007bec <xTaskGenericCreate+0x1c4>
80007b2a:	f0 1f 00 2c 	mcall	80007bd8 <xTaskGenericCreate+0x1b0>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
80007b2e:	4b 18       	lddpc	r8,80007bf0 <xTaskGenericCreate+0x1c8>
80007b30:	91 07       	st.w	r8[0x0],r7
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
80007b32:	4b 18       	lddpc	r8,80007bf4 <xTaskGenericCreate+0x1cc>
80007b34:	91 06       	st.w	r8[0x0],r6
80007b36:	c0 c8       	rjmp	80007b4e <xTaskGenericCreate+0x126>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
80007b38:	4b 08       	lddpc	r8,80007bf8 <xTaskGenericCreate+0x1d0>
80007b3a:	70 08       	ld.w	r8,r8[0x0]
80007b3c:	58 08       	cp.w	r8,0
80007b3e:	c0 81       	brne	80007b4e <xTaskGenericCreate+0x126>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
80007b40:	4a 48       	lddpc	r8,80007bd0 <xTaskGenericCreate+0x1a8>
80007b42:	70 08       	ld.w	r8,r8[0x0]
80007b44:	70 b8       	ld.w	r8,r8[0x2c]
80007b46:	10 33       	cp.w	r3,r8
80007b48:	c0 33       	brcs	80007b4e <xTaskGenericCreate+0x126>
					{
						pxCurrentTCB = pxNewTCB;
80007b4a:	4a 28       	lddpc	r8,80007bd0 <xTaskGenericCreate+0x1a8>
80007b4c:	91 05       	st.w	r8[0x0],r5
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
80007b4e:	6a b8       	ld.w	r8,r5[0x2c]
80007b50:	4a b9       	lddpc	r9,80007bfc <xTaskGenericCreate+0x1d4>
80007b52:	72 09       	ld.w	r9,r9[0x0]
80007b54:	12 38       	cp.w	r8,r9
80007b56:	e0 88 00 04 	brls	80007b5e <xTaskGenericCreate+0x136>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
80007b5a:	4a 99       	lddpc	r9,80007bfc <xTaskGenericCreate+0x1d4>
80007b5c:	93 08       	st.w	r9[0x0],r8
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
80007b5e:	4a 98       	lddpc	r8,80007c00 <xTaskGenericCreate+0x1d8>
80007b60:	70 09       	ld.w	r9,r8[0x0]
80007b62:	2f f9       	sub	r9,-1
80007b64:	91 09       	st.w	r8[0x0],r9

			prvAddTaskToReadyQueue( pxNewTCB );
80007b66:	6a b8       	ld.w	r8,r5[0x2c]
80007b68:	4a 79       	lddpc	r9,80007c04 <xTaskGenericCreate+0x1dc>
80007b6a:	72 09       	ld.w	r9,r9[0x0]
80007b6c:	12 38       	cp.w	r8,r9
80007b6e:	e0 88 00 04 	brls	80007b76 <xTaskGenericCreate+0x14e>
80007b72:	4a 59       	lddpc	r9,80007c04 <xTaskGenericCreate+0x1dc>
80007b74:	93 08       	st.w	r9[0x0],r8
80007b76:	6a bc       	ld.w	r12,r5[0x2c]
80007b78:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80007b7c:	08 9b       	mov	r11,r4
80007b7e:	49 68       	lddpc	r8,80007bd4 <xTaskGenericCreate+0x1ac>
80007b80:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80007b84:	f0 1f 00 21 	mcall	80007c08 <xTaskGenericCreate+0x1e0>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
80007b88:	f0 1f 00 21 	mcall	80007c0c <xTaskGenericCreate+0x1e4>
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
80007b8c:	49 b8       	lddpc	r8,80007bf8 <xTaskGenericCreate+0x1d0>
80007b8e:	70 08       	ld.w	r8,r8[0x0]
80007b90:	58 08       	cp.w	r8,0
80007b92:	c0 a0       	breq	80007ba6 <xTaskGenericCreate+0x17e>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
80007b94:	48 f8       	lddpc	r8,80007bd0 <xTaskGenericCreate+0x1a8>
80007b96:	70 08       	ld.w	r8,r8[0x0]
80007b98:	70 b8       	ld.w	r8,r8[0x2c]
80007b9a:	10 33       	cp.w	r3,r8
80007b9c:	e0 88 00 05 	brls	80007ba6 <xTaskGenericCreate+0x17e>
			{
				portYIELD_WITHIN_API();
80007ba0:	d7 33       	scall
80007ba2:	30 1c       	mov	r12,1
80007ba4:	c0 28       	rjmp	80007ba8 <xTaskGenericCreate+0x180>
80007ba6:	30 1c       	mov	r12,1
			}
		}
	}

	return xReturn;
}
80007ba8:	2f fd       	sub	sp,-4
80007baa:	d8 32       	popm	r0-r7,pc
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80007bac:	99 c6       	st.w	r12[0x30],r6
80007bae:	c5 fb       	rjmp	80007a6c <xTaskGenericCreate+0x44>
80007bb0:	80 00       	ld.sh	r0,r0[0x0]
80007bb2:	6e 60       	ld.w	r0,r7[0x18]
80007bb4:	80 00       	ld.sh	r0,r0[0x0]
80007bb6:	6e 38       	ld.w	r8,r7[0xc]
80007bb8:	80 00       	ld.sh	r0,r0[0x0]
80007bba:	87 d6       	st.w	r3[0x34],r6
80007bbc:	80 00       	ld.sh	r0,r0[0x0]
80007bbe:	8b 00       	st.w	r5[0x0],r0
80007bc0:	80 00       	ld.sh	r0,r0[0x0]
80007bc2:	6a e4       	ld.w	r4,r5[0x38]
80007bc4:	80 00       	ld.sh	r0,r0[0x0]
80007bc6:	6b 60       	ld.w	r0,r5[0x58]
80007bc8:	80 00       	ld.sh	r0,r0[0x0]
80007bca:	6b f4       	ld.w	r4,r5[0x7c]
80007bcc:	00 00       	add	r0,r0
80007bce:	0d b8       	ld.ub	r8,r6[0x3]
80007bd0:	00 00       	add	r0,r0
80007bd2:	0d 6c       	ld.uh	r12,--r6
80007bd4:	00 00       	add	r0,r0
80007bd6:	0c b8       	st.h	r6++,r8
80007bd8:	80 00       	ld.sh	r0,r0[0x0]
80007bda:	6a d0       	ld.w	r0,r5[0x34]
80007bdc:	00 00       	add	r0,r0
80007bde:	0d 84       	ld.ub	r4,r6[0x0]
80007be0:	00 00       	add	r0,r0
80007be2:	0d a0       	ld.ub	r0,r6[0x2]
80007be4:	00 00       	add	r0,r0
80007be6:	0d 70       	ld.ub	r0,--r6
80007be8:	00 00       	add	r0,r0
80007bea:	0d 58       	ld.sh	r8,--r6
80007bec:	00 00       	add	r0,r0
80007bee:	0d c0       	ld.ub	r0,r6[0x4]
80007bf0:	00 00       	add	r0,r0
80007bf2:	0c a4       	st.w	r6++,r4
80007bf4:	00 00       	add	r0,r0
80007bf6:	0c b4       	st.h	r6++,r4
80007bf8:	00 00       	add	r0,r0
80007bfa:	0c a8       	st.w	r6++,r8
80007bfc:	00 00       	add	r0,r0
80007bfe:	0c a0       	st.w	r6++,r0
80007c00:	00 00       	add	r0,r0
80007c02:	0d b4       	ld.ub	r4,r6[0x3]
80007c04:	00 00       	add	r0,r0
80007c06:	0d d4       	ld.ub	r4,r6[0x5]
80007c08:	80 00       	ld.sh	r0,r0[0x0]
80007c0a:	6a ea       	ld.w	r10,r5[0x38]
80007c0c:	80 00       	ld.sh	r0,r0[0x0]
80007c0e:	6d 00       	ld.w	r0,r6[0x40]

80007c10 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
80007c10:	d4 01       	pushm	lr
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
80007c12:	30 09       	mov	r9,0
80007c14:	1a d9       	st.w	--sp,r9
80007c16:	1a d9       	st.w	--sp,r9
80007c18:	1a d9       	st.w	--sp,r9
80007c1a:	12 98       	mov	r8,r9
80007c1c:	e0 6a 01 00 	mov	r10,256
80007c20:	48 9b       	lddpc	r11,80007c44 <vTaskStartScheduler+0x34>
80007c22:	48 ac       	lddpc	r12,80007c48 <vTaskStartScheduler+0x38>
80007c24:	f0 1f 00 0a 	mcall	80007c4c <vTaskStartScheduler+0x3c>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
80007c28:	2f dd       	sub	sp,-12
80007c2a:	58 1c       	cp.w	r12,1
80007c2c:	c0 a1       	brne	80007c40 <vTaskStartScheduler+0x30>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
80007c2e:	d3 03       	ssrf	0x10

		xSchedulerRunning = pdTRUE;
80007c30:	30 19       	mov	r9,1
80007c32:	48 88       	lddpc	r8,80007c50 <vTaskStartScheduler+0x40>
80007c34:	91 09       	st.w	r8[0x0],r9
		xTickCount = ( portTickType ) 0;
80007c36:	30 09       	mov	r9,0
80007c38:	48 78       	lddpc	r8,80007c54 <vTaskStartScheduler+0x44>
80007c3a:	91 09       	st.w	r8[0x0],r9
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
80007c3c:	f0 1f 00 07 	mcall	80007c58 <vTaskStartScheduler+0x48>
80007c40:	d8 02       	popm	pc
80007c42:	00 00       	add	r0,r0
80007c44:	80 00       	ld.sh	r0,r0[0x0]
80007c46:	eb b4       	*unknown*
80007c48:	80 00       	ld.sh	r0,r0[0x0]
80007c4a:	79 a0       	ld.w	r0,r12[0x68]
80007c4c:	80 00       	ld.sh	r0,r0[0x0]
80007c4e:	7a 28       	ld.w	r8,sp[0x8]
80007c50:	00 00       	add	r0,r0
80007c52:	0c a8       	st.w	r6++,r8
80007c54:	00 00       	add	r0,r0
80007c56:	0d 98       	ld.ub	r8,r6[0x1]
80007c58:	80 00       	ld.sh	r0,r0[0x0]
80007c5a:	6c 04       	ld.w	r4,r6[0x0]

80007c5c <PrintChar>:
	
static void task_log(void * pvParameters);

char *  PrintChar(char c, char * str)
{
	*str++ = c;
80007c5c:	16 cc       	st.b	r11++,r12
	return str;
}
80007c5e:	5e fb       	retal	r11

80007c60 <PrintHex>:
	
	return str;
}

char * PrintHex(int i,char len, char * str)
{
80007c60:	eb cd 40 c0 	pushm	r6-r7,lr
80007c64:	20 3d       	sub	sp,12
80007c66:	18 98       	mov	r8,r12
	char * p = str;
	char s[12];
	memset(s, 0 , 12);
80007c68:	30 06       	mov	r6,0
80007c6a:	30 07       	mov	r7,0
80007c6c:	fa e7 00 00 	st.d	sp[0],r6
80007c70:	30 0c       	mov	r12,0
80007c72:	50 2c       	stdsp	sp[0x8],r12
	int cnt=0;
	
	if(i)
80007c74:	58 08       	cp.w	r8,0
80007c76:	c1 30       	breq	80007c9c <PrintHex+0x3c>
80007c78:	18 99       	mov	r9,r12
	while(i)
	{
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
80007c7a:	1a 9c       	mov	r12,sp
80007c7c:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80007c80:	58 9e       	cp.w	lr,9
80007c82:	e0 8a 00 04 	brle	80007c8a <PrintHex+0x2a>
80007c86:	2c 9e       	sub	lr,-55
80007c88:	c0 48       	rjmp	80007c90 <PrintHex+0x30>
80007c8a:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80007c8e:	2d 0e       	sub	lr,-48
80007c90:	f8 09 0b 0e 	st.b	r12[r9],lr
80007c94:	2f f9       	sub	r9,-1
		i = (i >> 4 ) & 0x0FFFFFFF;
80007c96:	a5 88       	lsr	r8,0x4
	char s[12];
	memset(s, 0 , 12);
	int cnt=0;
	
	if(i)
	while(i)
80007c98:	cf 21       	brne	80007c7c <PrintHex+0x1c>
80007c9a:	c0 48       	rjmp	80007ca2 <PrintHex+0x42>
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
		i = (i >> 4 ) & 0x0FFFFFFF;
		//i >>= 4
	}
	else
	s[cnt++] = '0';
80007c9c:	33 08       	mov	r8,48
80007c9e:	ba 88       	st.b	sp[0x0],r8
80007ca0:	30 19       	mov	r9,1
	
	if(len - cnt > 0 )
80007ca2:	f6 09 01 08 	sub	r8,r11,r9
80007ca6:	58 08       	cp.w	r8,0
80007ca8:	e0 8a 00 13 	brle	80007cce <PrintHex+0x6e>
	{
		char num = len - cnt;
80007cac:	12 1b       	sub	r11,r9
80007cae:	f9 db c0 08 	bfextu	r12,r11,0x0,0x8
		for(int i = 0; i < num; i++)
80007cb2:	18 9e       	mov	lr,r12
80007cb4:	58 0c       	cp.w	r12,0
80007cb6:	e0 8a 00 0c 	brle	80007cce <PrintHex+0x6e>
80007cba:	1a 9b       	mov	r11,sp
80007cbc:	12 0b       	add	r11,r9
80007cbe:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80007cc0:	33 07       	mov	r7,48
80007cc2:	16 c7       	st.b	r11++,r7
	s[cnt++] = '0';
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80007cc4:	2f f8       	sub	r8,-1
80007cc6:	1c 38       	cp.w	r8,lr
80007cc8:	cf d5       	brlt	80007cc2 <PrintHex+0x62>
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
80007cca:	f8 09 00 09 	add	r9,r12,r9
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80007cce:	f2 c8 ff ff 	sub	r8,r9,-1
	s[cnt++] = '0';
	
	while(cnt>0)
80007cd2:	f0 cb ff ff 	sub	r11,r8,-1
80007cd6:	58 0b       	cp.w	r11,0
80007cd8:	e0 8a 00 19 	brle	80007d0a <PrintHex+0xaa>
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80007cdc:	fa cb ff f4 	sub	r11,sp,-12
80007ce0:	f6 09 00 09 	add	r9,r11,r9
80007ce4:	37 8b       	mov	r11,120
80007ce6:	f3 6b ff f4 	st.b	r9[-12],r11
	s[cnt++] = '0';
80007cea:	fa c9 ff f4 	sub	r9,sp,-12
80007cee:	10 09       	add	r9,r8
80007cf0:	33 0b       	mov	r11,48
80007cf2:	f3 6b ff f4 	st.b	r9[-12],r11
80007cf6:	fa 08 00 08 	add	r8,sp,r8
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
80007cfa:	fa ce 00 01 	sub	lr,sp,1
80007cfe:	14 99       	mov	r9,r10
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
	*p++ = s[--cnt];
80007d00:	11 8b       	ld.ub	r11,r8[0x0]
80007d02:	12 cb       	st.b	r9++,r11
80007d04:	20 18       	sub	r8,1
	}
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
80007d06:	1c 38       	cp.w	r8,lr
80007d08:	cf c1       	brne	80007d00 <PrintHex+0xa0>
	*p++ = s[--cnt];
		
	return str;
}
80007d0a:	14 9c       	mov	r12,r10
80007d0c:	2f dd       	sub	sp,-12
80007d0e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

80007d12 <PrintDec>:
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
{
80007d12:	d4 21       	pushm	r4-r7,lr
80007d14:	20 3d       	sub	sp,12
80007d16:	18 98       	mov	r8,r12
	char * p = str;
	
	int sign = i>=0 ? 0 : 1;
	char s[10];
	memset(s, 0 , 10);
80007d18:	30 06       	mov	r6,0
80007d1a:	30 07       	mov	r7,0
80007d1c:	fa e7 00 00 	st.d	sp[0],r6
80007d20:	30 0c       	mov	r12,0
80007d22:	ba 4c       	st.h	sp[0x8],r12
	int cnt=0;
	if(sign)
80007d24:	58 08       	cp.w	r8,0
80007d26:	c0 35       	brlt	80007d2c <PrintDec+0x1a>
80007d28:	14 97       	mov	r7,r10
80007d2a:	c0 58       	rjmp	80007d34 <PrintDec+0x22>
	{
		*p++ = '-';
80007d2c:	14 97       	mov	r7,r10
80007d2e:	32 d9       	mov	r9,45
80007d30:	0e c9       	st.b	r7++,r9
		i = -i;
80007d32:	5c 38       	neg	r8
	}
	
	if(i == 0 )s[cnt++] = '0';
80007d34:	58 08       	cp.w	r8,0
80007d36:	c0 51       	brne	80007d40 <PrintDec+0x2e>
80007d38:	33 08       	mov	r8,48
80007d3a:	ba 88       	st.b	sp[0x0],r8
80007d3c:	30 1e       	mov	lr,1
80007d3e:	c2 f8       	rjmp	80007d9c <PrintDec+0x8a>
	
	int ten = i%10;
80007d40:	e0 65 66 67 	mov	r5,26215
80007d44:	ea 15 66 66 	orh	r5,0x6666
80007d48:	f0 05 04 44 	muls.d	r4,r8,r5
80007d4c:	ea 0c 14 02 	asr	r12,r5,0x2
80007d50:	f0 09 14 1f 	asr	r9,r8,0x1f
80007d54:	f8 09 01 09 	sub	r9,r12,r9
80007d58:	f2 09 00 29 	add	r9,r9,r9<<0x2
80007d5c:	f0 09 01 19 	sub	r9,r8,r9<<0x1
80007d60:	30 0e       	mov	lr,0
	while(i)
	{
		s[cnt] = ten+'0';
80007d62:	1a 9c       	mov	r12,sp
		cnt++;
		i /= 10;
80007d64:	e0 66 66 67 	mov	r6,26215
80007d68:	ea 16 66 66 	orh	r6,0x6666
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
	{
		s[cnt] = ten+'0';
80007d6c:	2d 09       	sub	r9,-48
80007d6e:	f8 0e 0b 09 	st.b	r12[lr],r9
		cnt++;
80007d72:	2f fe       	sub	lr,-1
		i /= 10;
80007d74:	f0 06 04 44 	muls.d	r4,r8,r6
80007d78:	ea 09 14 02 	asr	r9,r5,0x2
80007d7c:	bf 58       	asr	r8,0x1f
80007d7e:	f2 08 01 08 	sub	r8,r9,r8
		ten = i%10;
80007d82:	f0 06 04 44 	muls.d	r4,r8,r6
80007d86:	ea 09 14 02 	asr	r9,r5,0x2
80007d8a:	f0 05 14 1f 	asr	r5,r8,0x1f
80007d8e:	0a 19       	sub	r9,r5
80007d90:	f2 09 00 29 	add	r9,r9,r9<<0x2
80007d94:	f0 09 01 19 	sub	r9,r8,r9<<0x1
	}
	
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
80007d98:	58 08       	cp.w	r8,0
80007d9a:	ce 91       	brne	80007d6c <PrintDec+0x5a>
		cnt++;
		i /= 10;
		ten = i%10;
	}
	
	if(len - cnt > 0 )
80007d9c:	f6 0e 01 08 	sub	r8,r11,lr
80007da0:	58 08       	cp.w	r8,0
80007da2:	e0 89 00 06 	brgt	80007dae <PrintDec+0x9c>
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80007da6:	58 0e       	cp.w	lr,0
80007da8:	e0 89 00 14 	brgt	80007dd0 <PrintDec+0xbe>
80007dac:	c1 d8       	rjmp	80007de6 <PrintDec+0xd4>
		ten = i%10;
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
80007dae:	1c 1b       	sub	r11,lr
80007db0:	5c 5b       	castu.b	r11
		for(int i = 0; i < num; i++)
80007db2:	16 9c       	mov	r12,r11
80007db4:	58 0b       	cp.w	r11,0
80007db6:	fe 9a ff f8 	brle	80007da6 <PrintDec+0x94>
80007dba:	1a 99       	mov	r9,sp
80007dbc:	1c 09       	add	r9,lr
80007dbe:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80007dc0:	33 06       	mov	r6,48
80007dc2:	12 c6       	st.b	r9++,r6
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80007dc4:	2f f8       	sub	r8,-1
80007dc6:	18 38       	cp.w	r8,r12
80007dc8:	cf d5       	brlt	80007dc2 <PrintDec+0xb0>
{
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
80007dca:	f6 0e 00 0e 	add	lr,r11,lr
80007dce:	ce cb       	rjmp	80007da6 <PrintDec+0x94>
80007dd0:	fa c8 ff f4 	sub	r8,sp,-12
80007dd4:	1c 08       	add	r8,lr
80007dd6:	20 d8       	sub	r8,13
80007dd8:	fa cb 00 01 	sub	r11,sp,1
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
	*p++ = s[--cnt];
80007ddc:	11 89       	ld.ub	r9,r8[0x0]
80007dde:	0e c9       	st.b	r7++,r9
80007de0:	20 18       	sub	r8,1
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80007de2:	16 38       	cp.w	r8,r11
80007de4:	cf c1       	brne	80007ddc <PrintDec+0xca>
	*p++ = s[--cnt];
	
	return str;
}
80007de6:	14 9c       	mov	r12,r10
80007de8:	2f dd       	sub	sp,-12
80007dea:	d8 22       	popm	r4-r7,pc

80007dec <log>:
	,  NULL );
	
}

int log(char * content, ...)
{
80007dec:	d4 31       	pushm	r0-r7,lr
80007dee:	fa cd 02 08 	sub	sp,sp,520
80007df2:	18 97       	mov	r7,r12
	
	
	char logTmp[MAX_LOG_LINE_SIZE];
	memset(logTmp, '\0', MAX_LOG_LINE_SIZE);	
80007df4:	e0 6a 01 00 	mov	r10,256
80007df8:	30 0b       	mov	r11,0
80007dfa:	fa cc fe f8 	sub	r12,sp,-264
80007dfe:	f0 1f 00 4e 	mcall	80007f34 <log+0x148>
	,  tskLOG_PRIORITY
	,  NULL );
	
}

int log(char * content, ...)
80007e02:	fa c4 fd d4 	sub	r4,sp,-556
80007e06:	30 0a       	mov	r10,0
80007e08:	50 0a       	stdsp	sp[0x0],r10
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80007e0a:	fa c3 ff fc 	sub	r3,sp,-4
80007e0e:	e0 61 01 00 	mov	r1,256
80007e12:	14 90       	mov	r0,r10
			
					if(*str == '%')
80007e14:	32 52       	mov	r2,37
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
80007e16:	fa c6 fe f8 	sub	r6,sp,-264
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80007e1a:	02 9a       	mov	r10,r1
80007e1c:	00 9b       	mov	r11,r0
80007e1e:	06 9c       	mov	r12,r3
80007e20:	f0 1f 00 45 	mcall	80007f34 <log+0x148>
			
					if(*str == '%')
80007e24:	0f 88       	ld.ub	r8,r7[0x0]
80007e26:	e4 08 18 00 	cp.b	r8,r2
80007e2a:	c5 71       	brne	80007ed8 <log+0xec>
					{
						static char lench = 0;
						lench =*(str + 1);
80007e2c:	ee c8 ff ff 	sub	r8,r7,-1
80007e30:	11 89       	ld.ub	r9,r8[0x0]
80007e32:	4c 2a       	lddpc	r10,80007f38 <log+0x14c>
80007e34:	b4 89       	st.b	r10[0x0],r9
						if((lench >= '0') &&  (lench <= '9'))
80007e36:	23 09       	sub	r9,48
80007e38:	30 9a       	mov	r10,9
80007e3a:	f4 09 18 00 	cp.b	r9,r10
80007e3e:	ee 08 17 b0 	movhi	r8,r7
						{
							len = *(++str) - '0';
80007e42:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
80007e46:	f7 b9 08 30 	subls	r9,48
80007e4a:	fb f9 8a 00 	st.wls	sp[0x0],r9
						}
						
						str++;
80007e4e:	f0 c7 ff ff 	sub	r7,r8,-1
						
						switch(*(str))
80007e52:	0f 88       	ld.ub	r8,r7[0x0]
80007e54:	22 58       	sub	r8,37
80007e56:	e0 48 00 53 	cp.w	r8,83
80007e5a:	e0 8b 00 31 	brhi	80007ebc <log+0xd0>
80007e5e:	4b 89       	lddpc	r9,80007f3c <log+0x150>
80007e60:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
						{
							case('i'):
							case('I'):
							case('d'):
							case('D'):
							x = va_arg(arg_ptr,int);
80007e64:	e8 c5 ff fc 	sub	r5,r4,-4
							strTmp = PrintDec(x, len, strTmp);
80007e68:	06 9a       	mov	r10,r3
80007e6a:	40 0b       	lddsp	r11,sp[0x0]
80007e6c:	5c 5b       	castu.b	r11
80007e6e:	68 0c       	ld.w	r12,r4[0x0]
80007e70:	f0 1f 00 34 	mcall	80007f40 <log+0x154>
							break;
80007e74:	c2 98       	rjmp	80007ec6 <log+0xda>
							
							case('f')://浮点数输出
							case('F'):
							//f = va_arg(arg_ptr,int);
							//strTmp = PrintDec(x, len, strTmp);
							log("I need float.");
80007e76:	4b 4c       	lddpc	r12,80007f44 <log+0x158>
80007e78:	f0 1f 00 34 	mcall	80007f48 <log+0x15c>
80007e7c:	08 95       	mov	r5,r4
80007e7e:	06 9c       	mov	r12,r3
							break;
80007e80:	c2 38       	rjmp	80007ec6 <log+0xda>
							
							
							case('x'):
							case('X'):
							x = va_arg(arg_ptr,int);
80007e82:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintHex(x,len, strTmp);
80007e86:	06 9a       	mov	r10,r3
80007e88:	40 0b       	lddsp	r11,sp[0x0]
80007e8a:	5c 5b       	castu.b	r11
80007e8c:	68 0c       	ld.w	r12,r4[0x0]
80007e8e:	f0 1f 00 30 	mcall	80007f4c <log+0x160>
80007e92:	06 9c       	mov	r12,r3
							break;
80007e94:	c1 98       	rjmp	80007ec6 <log+0xda>
							
							case('c'):
							case('C'):
							y = va_arg(arg_ptr,int);
80007e96:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintChar(y, strTmp);
80007e9a:	06 9b       	mov	r11,r3
80007e9c:	09 bc       	ld.ub	r12,r4[0x3]
80007e9e:	f0 1f 00 2d 	mcall	80007f50 <log+0x164>
80007ea2:	06 9c       	mov	r12,r3
							break;
80007ea4:	c1 18       	rjmp	80007ec6 <log+0xda>
							
							case('s'):
							case('S'):
							strTmp = va_arg(arg_ptr,char*);
80007ea6:	e8 c5 ff fc 	sub	r5,r4,-4
80007eaa:	68 0c       	ld.w	r12,r4[0x0]
							//PrintStr(s);
							break;
80007eac:	c0 d8       	rjmp	80007ec6 <log+0xda>
							
							case('%'):
							PrintChar('%', strTmp);
80007eae:	06 9b       	mov	r11,r3
80007eb0:	32 5c       	mov	r12,37
80007eb2:	f0 1f 00 28 	mcall	80007f50 <log+0x164>
80007eb6:	08 95       	mov	r5,r4
80007eb8:	06 9c       	mov	r12,r3
							//PrintChar('%');
							break;
80007eba:	c0 68       	rjmp	80007ec6 <log+0xda>
							
							default:
							log("I need relax.");
80007ebc:	4a 6c       	lddpc	r12,80007f54 <log+0x168>
80007ebe:	f0 1f 00 23 	mcall	80007f48 <log+0x15c>
80007ec2:	08 95       	mov	r5,r4
80007ec4:	06 9c       	mov	r12,r3
						}
						str++;
80007ec6:	2f f7       	sub	r7,-1
						
						length = sprintf(logTmp,"%s%s",logTmp,strTmp );
80007ec8:	1a dc       	st.w	--sp,r12
80007eca:	1a d6       	st.w	--sp,r6
80007ecc:	4a 3b       	lddpc	r11,80007f58 <log+0x16c>
80007ece:	0c 9c       	mov	r12,r6
80007ed0:	f0 1f 00 23 	mcall	80007f5c <log+0x170>
80007ed4:	2f ed       	sub	sp,-8
80007ed6:	c0 a8       	rjmp	80007eea <log+0xfe>
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
80007ed8:	2f f7       	sub	r7,-1
80007eda:	1a d8       	st.w	--sp,r8
80007edc:	1a d6       	st.w	--sp,r6
80007ede:	4a 1b       	lddpc	r11,80007f60 <log+0x174>
80007ee0:	0c 9c       	mov	r12,r6
80007ee2:	f0 1f 00 1f 	mcall	80007f5c <log+0x170>
80007ee6:	08 95       	mov	r5,r4
80007ee8:	2f ed       	sub	sp,-8
			
			
			
	}while(*str != '\0');
80007eea:	0f 89       	ld.ub	r9,r7[0x0]
80007eec:	30 08       	mov	r8,0
80007eee:	f0 09 18 00 	cp.b	r9,r8
80007ef2:	c0 30       	breq	80007ef8 <log+0x10c>
80007ef4:	0a 94       	mov	r4,r5
80007ef6:	c9 2b       	rjmp	80007e1a <log+0x2e>
		
		
				
	va_end(arg_ptr);
	//while(1)		
	length = sprintf(logTmp,"%s\r\n",logTmp);
80007ef8:	fa c7 fe f8 	sub	r7,sp,-264
80007efc:	1a d7       	st.w	--sp,r7
80007efe:	49 ab       	lddpc	r11,80007f64 <log+0x178>
80007f00:	0e 9c       	mov	r12,r7
80007f02:	f0 1f 00 17 	mcall	80007f5c <log+0x170>
	
	char * p = pvPortMalloc(length+1);
80007f06:	5c 5c       	castu.b	r12
80007f08:	f8 c6 ff ff 	sub	r6,r12,-1
80007f0c:	0c 9c       	mov	r12,r6
80007f0e:	f0 1f 00 17 	mcall	80007f68 <log+0x17c>
80007f12:	54 2c       	stdsp	sp[0x108],r12
	memcpy(p, logTmp, length+1);
80007f14:	0c 9a       	mov	r10,r6
80007f16:	0e 9b       	mov	r11,r7
80007f18:	f0 1f 00 15 	mcall	80007f6c <log+0x180>
	//
	//usart_write_line(EXAMPLE_USART, logTmp)
	
	xQueueSend( logQueue, &p, 5);
80007f1c:	30 09       	mov	r9,0
80007f1e:	30 5a       	mov	r10,5
80007f20:	fa cb fe f8 	sub	r11,sp,-264
80007f24:	49 38       	lddpc	r8,80007f70 <log+0x184>
80007f26:	70 0c       	ld.w	r12,r8[0x0]
80007f28:	f0 1f 00 13 	mcall	80007f74 <log+0x188>
80007f2c:	2f fd       	sub	sp,-4
	
	
}
80007f2e:	fe 3d fd f8 	sub	sp,-520
80007f32:	d8 32       	popm	r0-r7,pc
80007f34:	80 00       	ld.sh	r0,r0[0x0]
80007f36:	87 d6       	st.w	r3[0x34],r6
80007f38:	00 00       	add	r0,r0
80007f3a:	0d d8       	ld.ub	r8,r6[0x5]
80007f3c:	80 00       	ld.sh	r0,r0[0x0]
80007f3e:	eb bc       	*unknown*
80007f40:	80 00       	ld.sh	r0,r0[0x0]
80007f42:	7d 12       	ld.w	r2,lr[0x44]
80007f44:	80 00       	ld.sh	r0,r0[0x0]
80007f46:	ee 68 80 00 	mov	r8,950272
80007f4a:	7d ec       	ld.w	r12,lr[0x78]
80007f4c:	80 00       	ld.sh	r0,r0[0x0]
80007f4e:	7c 60       	ld.w	r0,lr[0x18]
80007f50:	80 00       	ld.sh	r0,r0[0x0]
80007f52:	7c 5c       	ld.w	r12,lr[0x14]
80007f54:	80 00       	ld.sh	r0,r0[0x0]
80007f56:	ee 78 80 00 	mov	r8,1015808
80007f5a:	ee 88 80 00 	brls	801d7f5a <_data_lma+0x1c8b0a>
80007f5e:	8a c4       	ld.uh	r4,r5[0x8]
80007f60:	80 00       	ld.sh	r0,r0[0x0]
80007f62:	ee 90 80 00 	breq	801f7f62 <_data_lma+0x1e8b12>
80007f66:	ee 98 80 00 	brls	801f7f66 <_data_lma+0x1e8b16>
80007f6a:	6e 60       	ld.w	r0,r7[0x18]
80007f6c:	80 00       	ld.sh	r0,r0[0x0]
80007f6e:	86 8e       	ld.uh	lr,r3[0x0]
80007f70:	00 00       	add	r0,r0
80007f72:	bd 48       	asr	r8,0x1c
80007f74:	80 00       	ld.sh	r0,r0[0x0]
80007f76:	71 b4       	ld.w	r4,r8[0x6c]

80007f78 <logFromISR>:
	
	
int logFromISR(char * content, ...)
	{
80007f78:	d4 31       	pushm	r0-r7,lr
80007f7a:	fa cd 02 0c 	sub	sp,sp,524
80007f7e:	18 97       	mov	r7,r12
		
		
		char logTmp[MAX_LOG_LINE_SIZE];
		memset(logTmp, '\0', MAX_LOG_LINE_SIZE);
80007f80:	e0 6a 01 00 	mov	r10,256
80007f84:	30 0b       	mov	r11,0
80007f86:	fa cc fe f4 	sub	r12,sp,-268
80007f8a:	f0 1f 00 4c 	mcall	800080b8 <logFromISR+0x140>
	
	
}
	
	
int logFromISR(char * content, ...)
80007f8e:	fa c4 fd d0 	sub	r4,sp,-560
80007f92:	30 0a       	mov	r10,0
80007f94:	50 0a       	stdsp	sp[0x0],r10
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80007f96:	fa c3 ff fc 	sub	r3,sp,-4
80007f9a:	e0 61 01 00 	mov	r1,256
80007f9e:	14 90       	mov	r0,r10
			
			if(*str == '%')
80007fa0:	32 52       	mov	r2,37
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
80007fa2:	fa c6 fe f4 	sub	r6,sp,-268
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80007fa6:	02 9a       	mov	r10,r1
80007fa8:	00 9b       	mov	r11,r0
80007faa:	06 9c       	mov	r12,r3
80007fac:	f0 1f 00 43 	mcall	800080b8 <logFromISR+0x140>
			
			if(*str == '%')
80007fb0:	0f 88       	ld.ub	r8,r7[0x0]
80007fb2:	e4 08 18 00 	cp.b	r8,r2
80007fb6:	c5 11       	brne	80008058 <logFromISR+0xe0>
			{
				static char lench = 0;
				lench =*(str + 1);
80007fb8:	ee c8 ff ff 	sub	r8,r7,-1
80007fbc:	11 89       	ld.ub	r9,r8[0x0]
80007fbe:	4c 0a       	lddpc	r10,800080bc <logFromISR+0x144>
80007fc0:	b4 89       	st.b	r10[0x0],r9
				if((lench >= '0') &&  (lench <= '9'))
80007fc2:	23 09       	sub	r9,48
80007fc4:	30 9a       	mov	r10,9
80007fc6:	f4 09 18 00 	cp.b	r9,r10
80007fca:	ee 08 17 b0 	movhi	r8,r7
				{
					len = *(++str) - '0';
80007fce:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
80007fd2:	f7 b9 08 30 	subls	r9,48
80007fd6:	fb f9 8a 00 	st.wls	sp[0x0],r9
				}
				
				str++;
80007fda:	f0 c7 ff ff 	sub	r7,r8,-1
				
				switch(*(str))
80007fde:	0f 88       	ld.ub	r8,r7[0x0]
80007fe0:	22 58       	sub	r8,37
80007fe2:	e0 48 00 53 	cp.w	r8,83
80007fe6:	e0 8b 00 2b 	brhi	8000803c <logFromISR+0xc4>
80007fea:	4b 69       	lddpc	r9,800080c0 <logFromISR+0x148>
80007fec:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
				{
					case('d'):
					case('D'):
					x = va_arg(arg_ptr,int);
80007ff0:	e8 c5 ff fc 	sub	r5,r4,-4
					strTmp = PrintDec(x, len, strTmp);
80007ff4:	06 9a       	mov	r10,r3
80007ff6:	40 0b       	lddsp	r11,sp[0x0]
80007ff8:	5c 5b       	castu.b	r11
80007ffa:	68 0c       	ld.w	r12,r4[0x0]
80007ffc:	f0 1f 00 32 	mcall	800080c4 <logFromISR+0x14c>
					break;
80008000:	c2 38       	rjmp	80008046 <logFromISR+0xce>
					case('x'):
					case('X'):
					x = va_arg(arg_ptr,int);
80008002:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintHex(x,len, strTmp);
80008006:	06 9a       	mov	r10,r3
80008008:	40 0b       	lddsp	r11,sp[0x0]
8000800a:	5c 5b       	castu.b	r11
8000800c:	68 0c       	ld.w	r12,r4[0x0]
8000800e:	f0 1f 00 2f 	mcall	800080c8 <logFromISR+0x150>
80008012:	06 9c       	mov	r12,r3
					break;
80008014:	c1 98       	rjmp	80008046 <logFromISR+0xce>
					case('c'):
					case('C'):
					y = va_arg(arg_ptr,int);
80008016:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintChar(y, strTmp);
8000801a:	06 9b       	mov	r11,r3
8000801c:	09 bc       	ld.ub	r12,r4[0x3]
8000801e:	f0 1f 00 2c 	mcall	800080cc <logFromISR+0x154>
80008022:	06 9c       	mov	r12,r3
					break;
80008024:	c1 18       	rjmp	80008046 <logFromISR+0xce>
					case('s'):
					case('S'):
					strTmp = va_arg(arg_ptr,char*);
80008026:	e8 c5 ff fc 	sub	r5,r4,-4
8000802a:	68 0c       	ld.w	r12,r4[0x0]
					//PrintStr(s);
					break;
8000802c:	c0 d8       	rjmp	80008046 <logFromISR+0xce>
					case('%'):
					PrintChar('%', strTmp);
8000802e:	06 9b       	mov	r11,r3
80008030:	32 5c       	mov	r12,37
80008032:	f0 1f 00 27 	mcall	800080cc <logFromISR+0x154>
80008036:	08 95       	mov	r5,r4
80008038:	06 9c       	mov	r12,r3
					//PrintChar('%');
					break;
8000803a:	c0 68       	rjmp	80008046 <logFromISR+0xce>
					default:
					log("I need relax.");
8000803c:	4a 5c       	lddpc	r12,800080d0 <logFromISR+0x158>
8000803e:	f0 1f 00 26 	mcall	800080d4 <logFromISR+0x15c>
80008042:	08 95       	mov	r5,r4
80008044:	06 9c       	mov	r12,r3
				}
				str++;
80008046:	2f f7       	sub	r7,-1
				
				length = sprintf(logTmp,"%s%s",logTmp,strTmp );
80008048:	1a dc       	st.w	--sp,r12
8000804a:	1a d6       	st.w	--sp,r6
8000804c:	4a 3b       	lddpc	r11,800080d8 <logFromISR+0x160>
8000804e:	0c 9c       	mov	r12,r6
80008050:	f0 1f 00 23 	mcall	800080dc <logFromISR+0x164>
80008054:	2f ed       	sub	sp,-8
80008056:	c0 a8       	rjmp	8000806a <logFromISR+0xf2>
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
80008058:	2f f7       	sub	r7,-1
8000805a:	1a d8       	st.w	--sp,r8
8000805c:	1a d6       	st.w	--sp,r6
8000805e:	4a 1b       	lddpc	r11,800080e0 <logFromISR+0x168>
80008060:	0c 9c       	mov	r12,r6
80008062:	f0 1f 00 1f 	mcall	800080dc <logFromISR+0x164>
80008066:	08 95       	mov	r5,r4
80008068:	2f ed       	sub	sp,-8
			
			
			
		}while(*str != '\0');
8000806a:	0f 89       	ld.ub	r9,r7[0x0]
8000806c:	30 08       	mov	r8,0
8000806e:	f0 09 18 00 	cp.b	r9,r8
80008072:	c0 30       	breq	80008078 <logFromISR+0x100>
80008074:	0a 94       	mov	r4,r5
80008076:	c9 8b       	rjmp	80007fa6 <logFromISR+0x2e>
		
		
		
		va_end(arg_ptr);
		//while(1)
		length = sprintf(logTmp,"%s\r\n",logTmp);
80008078:	fa c7 fe f4 	sub	r7,sp,-268
8000807c:	1a d7       	st.w	--sp,r7
8000807e:	49 ab       	lddpc	r11,800080e4 <logFromISR+0x16c>
80008080:	0e 9c       	mov	r12,r7
80008082:	f0 1f 00 17 	mcall	800080dc <logFromISR+0x164>
		
		char * p = pvPortMalloc(length+1);
80008086:	5c 5c       	castu.b	r12
80008088:	f8 c6 ff ff 	sub	r6,r12,-1
8000808c:	0c 9c       	mov	r12,r6
8000808e:	f0 1f 00 17 	mcall	800080e8 <logFromISR+0x170>
80008092:	54 3c       	stdsp	sp[0x10c],r12
		memcpy(p, logTmp, length+1);
80008094:	0c 9a       	mov	r10,r6
80008096:	0e 9b       	mov	r11,r7
80008098:	f0 1f 00 15 	mcall	800080ec <logFromISR+0x174>
		//
		portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
8000809c:	30 09       	mov	r9,0
8000809e:	54 29       	stdsp	sp[0x108],r9
		
		//usart_write_line(EXAMPLE_USART, p);
		//vPortFree(p);
		xQueueSendFromISR( logQueue, &p, &xHigherPriorityTaskWoken );
800080a0:	fa ca fe f8 	sub	r10,sp,-264
800080a4:	fa cb fe f4 	sub	r11,sp,-268
800080a8:	49 28       	lddpc	r8,800080f0 <logFromISR+0x178>
800080aa:	70 0c       	ld.w	r12,r8[0x0]
800080ac:	f0 1f 00 12 	mcall	800080f4 <logFromISR+0x17c>
800080b0:	2f fd       	sub	sp,-4
		
		//if (xHigherPriorityTaskWoken == pdTRUE)
		//{
			////taskYIELD();
		//}
	}
800080b2:	fe 3d fd f4 	sub	sp,-524
800080b6:	d8 32       	popm	r0-r7,pc
800080b8:	80 00       	ld.sh	r0,r0[0x0]
800080ba:	87 d6       	st.w	r3[0x34],r6
800080bc:	00 00       	add	r0,r0
800080be:	0d d9       	ld.ub	r9,r6[0x5]
800080c0:	80 00       	ld.sh	r0,r0[0x0]
800080c2:	ed 0c 80 00 	ld.sh	r12,r6[-32768]
800080c6:	7d 12       	ld.w	r2,lr[0x44]
800080c8:	80 00       	ld.sh	r0,r0[0x0]
800080ca:	7c 60       	ld.w	r0,lr[0x18]
800080cc:	80 00       	ld.sh	r0,r0[0x0]
800080ce:	7c 5c       	ld.w	r12,lr[0x14]
800080d0:	80 00       	ld.sh	r0,r0[0x0]
800080d2:	ee 78 80 00 	mov	r8,1015808
800080d6:	7d ec       	ld.w	r12,lr[0x78]
800080d8:	80 00       	ld.sh	r0,r0[0x0]
800080da:	ee 88 80 00 	brls	801d80da <_data_lma+0x1c8c8a>
800080de:	8a c4       	ld.uh	r4,r5[0x8]
800080e0:	80 00       	ld.sh	r0,r0[0x0]
800080e2:	ee 90 80 00 	breq	801f80e2 <_data_lma+0x1e8c92>
800080e6:	ee 98 80 00 	brls	801f80e6 <_data_lma+0x1e8c96>
800080ea:	6e 60       	ld.w	r0,r7[0x18]
800080ec:	80 00       	ld.sh	r0,r0[0x0]
800080ee:	86 8e       	ld.uh	lr,r3[0x0]
800080f0:	00 00       	add	r0,r0
800080f2:	bd 48       	asr	r8,0x1c
800080f4:	80 00       	ld.sh	r0,r0[0x0]
800080f6:	71 64       	ld.w	r4,r8[0x58]

800080f8 <log_init>:
		
	return str;
}

void log_init(void)
{
800080f8:	d4 01       	pushm	lr
		.stopbits     = USART_1_STOPBIT,
		.channelmode  = USART_NORMAL_CHMODE
	};

	// Assign GPIO to USART.
	gpio_enable_module(USART_GPIO_MAP,
800080fa:	30 2b       	mov	r11,2
800080fc:	48 fc       	lddpc	r12,80008138 <log_init+0x40>
800080fe:	f0 1f 00 10 	mcall	8000813c <log_init+0x44>
	sizeof(USART_GPIO_MAP) / sizeof(USART_GPIO_MAP[0]));

	// Initialize USART in RS232 mode.
	usart_init_rs232(EXAMPLE_USART, &USART_OPTIONS, EXAMPLE_TARGET_PBACLK_FREQ_HZ);			
80008102:	e0 6a 36 00 	mov	r10,13824
80008106:	ea 1a 01 6e 	orh	r10,0x16e
8000810a:	48 eb       	lddpc	r11,80008140 <log_init+0x48>
8000810c:	fe 7c 1c 00 	mov	r12,-58368
80008110:	f0 1f 00 0d 	mcall	80008144 <log_init+0x4c>
			
	logQueue  = xQueueCreate(50, sizeof(char *));
80008114:	30 4b       	mov	r11,4
80008116:	33 2c       	mov	r12,50
80008118:	f0 1f 00 0c 	mcall	80008148 <log_init+0x50>
8000811c:	48 c8       	lddpc	r8,8000814c <log_init+0x54>
8000811e:	91 0c       	st.w	r8[0x0],r12
	
	xTaskCreate(
80008120:	30 09       	mov	r9,0
80008122:	1a d9       	st.w	--sp,r9
80008124:	1a d9       	st.w	--sp,r9
80008126:	1a d9       	st.w	--sp,r9
80008128:	30 28       	mov	r8,2
8000812a:	36 4a       	mov	r10,100
8000812c:	48 9b       	lddpc	r11,80008150 <log_init+0x58>
8000812e:	48 ac       	lddpc	r12,80008154 <log_init+0x5c>
80008130:	f0 1f 00 0a 	mcall	80008158 <log_init+0x60>
80008134:	2f dd       	sub	sp,-12
	,  100//384
	,  NULL
	,  tskLOG_PRIORITY
	,  NULL );
	
}
80008136:	d8 02       	popm	pc
80008138:	80 00       	ld.sh	r0,r0[0x0]
8000813a:	ee a4       	*unknown*
8000813c:	80 00       	ld.sh	r0,r0[0x0]
8000813e:	61 e8       	ld.w	r8,r0[0x78]
80008140:	80 00       	ld.sh	r0,r0[0x0]
80008142:	ee 5c 80 00 	cp.w	r12,1015808
80008146:	69 c4       	ld.w	r4,r4[0x70]
80008148:	80 00       	ld.sh	r0,r0[0x0]
8000814a:	73 0c       	ld.w	r12,r9[0x40]
8000814c:	00 00       	add	r0,r0
8000814e:	bd 48       	asr	r8,0x1c
80008150:	80 00       	ld.sh	r0,r0[0x0]
80008152:	ee a0 80 00 	rcall	801d8152 <_data_lma+0x1c8d02>
80008156:	81 5c       	st.w	r0[0x14],r12
80008158:	80 00       	ld.sh	r0,r0[0x0]
8000815a:	7a 28       	ld.w	r8,sp[0x8]

8000815c <task_log>:
			////taskYIELD();
		//}
	}
//portTickType log_water_value =0;	
static void task_log(void * pvParameters)
{
8000815c:	eb cd 40 f8 	pushm	r3-r7,lr
80008160:	20 1d       	sub	sp,4
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		//log_water_value = uxTaskGetStackHighWaterMark(NULL);
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
80008162:	48 c7       	lddpc	r7,80008190 <task_log+0x34>
80008164:	30 05       	mov	r5,0
80008166:	3f f4       	mov	r4,-1
		{
			if( NULL != str)
			{
				usart_write_line(EXAMPLE_USART, str);
80008168:	fe 73 1c 00 	mov	r3,-58368
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		//log_water_value = uxTaskGetStackHighWaterMark(NULL);
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
8000816c:	0a 99       	mov	r9,r5
8000816e:	08 9a       	mov	r10,r4
80008170:	1a 9b       	mov	r11,sp
80008172:	6e 0c       	ld.w	r12,r7[0x0]
80008174:	f0 1f 00 08 	mcall	80008194 <task_log+0x38>
80008178:	58 1c       	cp.w	r12,1
8000817a:	cf 91       	brne	8000816c <task_log+0x10>
		{
			if( NULL != str)
8000817c:	40 0b       	lddsp	r11,sp[0x0]
8000817e:	58 0b       	cp.w	r11,0
80008180:	cf 60       	breq	8000816c <task_log+0x10>
			{
				usart_write_line(EXAMPLE_USART, str);
80008182:	06 9c       	mov	r12,r3
80008184:	f0 1f 00 05 	mcall	80008198 <task_log+0x3c>
				vPortFree(str);
80008188:	40 0c       	lddsp	r12,sp[0x0]
8000818a:	f0 1f 00 05 	mcall	8000819c <task_log+0x40>
8000818e:	ce fb       	rjmp	8000816c <task_log+0x10>
80008190:	00 00       	add	r0,r0
80008192:	bd 48       	asr	r8,0x1c
80008194:	80 00       	ld.sh	r0,r0[0x0]
80008196:	6f a8       	ld.w	r8,r7[0x68]
80008198:	80 00       	ld.sh	r0,r0[0x0]
8000819a:	69 74       	ld.w	r4,r4[0x5c]
8000819c:	80 00       	ld.sh	r0,r0[0x0]
8000819e:	6e 38       	ld.w	r8,r7[0xc]

800081a0 <main>:
#include "xgflash.h"
#include "app.h"


int main (void)
{
800081a0:	d4 01       	pushm	lr
	
	//Force SSC_TX_DATA_ENABLE Disabled as soon as possible.
	AVR32_GPIO.port[1].ovrs  =  0x00000001;  //Value will be high.
800081a2:	fe 78 10 00 	mov	r8,-61440
800081a6:	30 19       	mov	r9,1
800081a8:	f1 49 01 54 	st.w	r8[340],r9
	AVR32_GPIO.port[1].oders =  0x00000001;  //Output Driver will be Enabled.
800081ac:	f1 49 01 44 	st.w	r8[324],r9
	AVR32_GPIO.port[1].gpers =  0x00000001;  //Enable as GPIO.
800081b0:	f1 49 01 04 	st.w	r8[260],r9
		
	Disable_global_interrupt();
800081b4:	d3 03       	ssrf	0x10
	local_start_pll0();
800081b6:	f0 1f 00 0c 	mcall	800081e4 <main+0x44>
		
	INTC_init_interrupts();
800081ba:	f0 1f 00 0c 	mcall	800081e8 <main+0x48>
		
	log_init();//usart2
800081be:	f0 1f 00 0c 	mcall	800081ec <main+0x4c>
	log("----start debug----");
800081c2:	48 cc       	lddpc	r12,800081f0 <main+0x50>
800081c4:	f0 1f 00 0c 	mcall	800081f4 <main+0x54>
	
	xg_flashc_init();
800081c8:	f0 1f 00 0c 	mcall	800081f8 <main+0x58>

	//tc_init();
	
	//rfid_init();csbk-ob：无此硬件接口
		
	app_init();
800081cc:	f0 1f 00 0c 	mcall	800081fc <main+0x5c>
	
	xg_rtc_init();
800081d0:	f0 1f 00 0c 	mcall	80008200 <main+0x60>
		
	xcmp_init();
800081d4:	f0 1f 00 0c 	mcall	80008204 <main+0x64>

	local_start_timer();
800081d8:	f0 1f 00 0c 	mcall	80008208 <main+0x68>
		
	vTaskStartScheduler();
800081dc:	f0 1f 00 0c 	mcall	8000820c <main+0x6c>
	return 0;
	
}
800081e0:	d8 0a       	popm	pc,r12=0
800081e2:	00 00       	add	r0,r0
800081e4:	80 00       	ld.sh	r0,r0[0x0]
800081e6:	5b 24       	cp.w	r4,-14
800081e8:	80 00       	ld.sh	r0,r0[0x0]
800081ea:	62 d4       	ld.w	r4,r1[0x34]
800081ec:	80 00       	ld.sh	r0,r0[0x0]
800081ee:	80 f8       	ld.uh	r8,r0[0xe]
800081f0:	80 00       	ld.sh	r0,r0[0x0]
800081f2:	ee b4       	*unknown*
800081f4:	80 00       	ld.sh	r0,r0[0x0]
800081f6:	7d ec       	ld.w	r12,lr[0x78]
800081f8:	80 00       	ld.sh	r0,r0[0x0]
800081fa:	5b b8       	cp.w	r8,-5
800081fc:	80 00       	ld.sh	r0,r0[0x0]
800081fe:	27 44       	sub	r4,116
80008200:	80 00       	ld.sh	r0,r0[0x0]
80008202:	33 b4       	mov	r4,59
80008204:	80 00       	ld.sh	r0,r0[0x0]
80008206:	4a 90       	lddpc	r0,800082a8 <_malloc_r+0x78>
80008208:	80 00       	ld.sh	r0,r0[0x0]
8000820a:	5a f8       	cp.w	r8,-17
8000820c:	80 00       	ld.sh	r0,r0[0x0]
8000820e:	7c 10       	ld.w	r0,lr[0x4]

80008210 <free>:
80008210:	d4 01       	pushm	lr
80008212:	e0 68 0a 54 	mov	r8,2644
80008216:	18 9b       	mov	r11,r12
80008218:	70 0c       	ld.w	r12,r8[0x0]
8000821a:	e0 a0 1e 73 	rcall	8000bf00 <_free_r>
8000821e:	d8 02       	popm	pc

80008220 <malloc>:
80008220:	d4 01       	pushm	lr
80008222:	e0 68 0a 54 	mov	r8,2644
80008226:	18 9b       	mov	r11,r12
80008228:	70 0c       	ld.w	r12,r8[0x0]
8000822a:	c0 3c       	rcall	80008230 <_malloc_r>
8000822c:	d8 02       	popm	pc
8000822e:	d7 03       	nop

80008230 <_malloc_r>:
80008230:	d4 31       	pushm	r0-r7,lr
80008232:	f6 c8 ff f5 	sub	r8,r11,-11
80008236:	18 95       	mov	r5,r12
80008238:	10 97       	mov	r7,r8
8000823a:	e0 17 ff f8 	andl	r7,0xfff8
8000823e:	59 68       	cp.w	r8,22
80008240:	f9 b7 08 10 	movls	r7,16
80008244:	16 37       	cp.w	r7,r11
80008246:	5f 38       	srlo	r8
80008248:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
8000824c:	c0 50       	breq	80008256 <_malloc_r+0x26>
8000824e:	30 c8       	mov	r8,12
80008250:	99 38       	st.w	r12[0xc],r8
80008252:	e0 8f 01 fa 	bral	80008646 <_malloc_r+0x416>
80008256:	fe b0 f5 a7 	rcall	80006da4 <__malloc_lock>
8000825a:	e0 47 01 f7 	cp.w	r7,503
8000825e:	e0 8b 00 1d 	brhi	80008298 <_malloc_r+0x68>
80008262:	ee 03 16 03 	lsr	r3,r7,0x3
80008266:	e0 68 05 54 	mov	r8,1364
8000826a:	f0 03 00 38 	add	r8,r8,r3<<0x3
8000826e:	70 36       	ld.w	r6,r8[0xc]
80008270:	10 36       	cp.w	r6,r8
80008272:	c0 61       	brne	8000827e <_malloc_r+0x4e>
80008274:	ec c8 ff f8 	sub	r8,r6,-8
80008278:	70 36       	ld.w	r6,r8[0xc]
8000827a:	10 36       	cp.w	r6,r8
8000827c:	c0 c0       	breq	80008294 <_malloc_r+0x64>
8000827e:	6c 18       	ld.w	r8,r6[0x4]
80008280:	e0 18 ff fc 	andl	r8,0xfffc
80008284:	6c 3a       	ld.w	r10,r6[0xc]
80008286:	ec 08 00 09 	add	r9,r6,r8
8000828a:	0a 9c       	mov	r12,r5
8000828c:	6c 28       	ld.w	r8,r6[0x8]
8000828e:	95 28       	st.w	r10[0x8],r8
80008290:	91 3a       	st.w	r8[0xc],r10
80008292:	c4 78       	rjmp	80008320 <_malloc_r+0xf0>
80008294:	2f e3       	sub	r3,-2
80008296:	c4 d8       	rjmp	80008330 <_malloc_r+0x100>
80008298:	ee 03 16 09 	lsr	r3,r7,0x9
8000829c:	c0 41       	brne	800082a4 <_malloc_r+0x74>
8000829e:	ee 03 16 03 	lsr	r3,r7,0x3
800082a2:	c2 68       	rjmp	800082ee <_malloc_r+0xbe>
800082a4:	58 43       	cp.w	r3,4
800082a6:	e0 8b 00 06 	brhi	800082b2 <_malloc_r+0x82>
800082aa:	ee 03 16 06 	lsr	r3,r7,0x6
800082ae:	2c 83       	sub	r3,-56
800082b0:	c1 f8       	rjmp	800082ee <_malloc_r+0xbe>
800082b2:	59 43       	cp.w	r3,20
800082b4:	e0 8b 00 04 	brhi	800082bc <_malloc_r+0x8c>
800082b8:	2a 53       	sub	r3,-91
800082ba:	c1 a8       	rjmp	800082ee <_malloc_r+0xbe>
800082bc:	e0 43 00 54 	cp.w	r3,84
800082c0:	e0 8b 00 06 	brhi	800082cc <_malloc_r+0x9c>
800082c4:	ee 03 16 0c 	lsr	r3,r7,0xc
800082c8:	29 23       	sub	r3,-110
800082ca:	c1 28       	rjmp	800082ee <_malloc_r+0xbe>
800082cc:	e0 43 01 54 	cp.w	r3,340
800082d0:	e0 8b 00 06 	brhi	800082dc <_malloc_r+0xac>
800082d4:	ee 03 16 0f 	lsr	r3,r7,0xf
800082d8:	28 93       	sub	r3,-119
800082da:	c0 a8       	rjmp	800082ee <_malloc_r+0xbe>
800082dc:	e0 43 05 54 	cp.w	r3,1364
800082e0:	e0 88 00 04 	brls	800082e8 <_malloc_r+0xb8>
800082e4:	37 e3       	mov	r3,126
800082e6:	c0 48       	rjmp	800082ee <_malloc_r+0xbe>
800082e8:	ee 03 16 12 	lsr	r3,r7,0x12
800082ec:	28 43       	sub	r3,-124
800082ee:	e0 6a 05 54 	mov	r10,1364
800082f2:	f4 03 00 3a 	add	r10,r10,r3<<0x3
800082f6:	74 36       	ld.w	r6,r10[0xc]
800082f8:	c1 98       	rjmp	8000832a <_malloc_r+0xfa>
800082fa:	6c 19       	ld.w	r9,r6[0x4]
800082fc:	e0 19 ff fc 	andl	r9,0xfffc
80008300:	f2 07 01 0b 	sub	r11,r9,r7
80008304:	58 fb       	cp.w	r11,15
80008306:	e0 8a 00 04 	brle	8000830e <_malloc_r+0xde>
8000830a:	20 13       	sub	r3,1
8000830c:	c1 18       	rjmp	8000832e <_malloc_r+0xfe>
8000830e:	6c 38       	ld.w	r8,r6[0xc]
80008310:	58 0b       	cp.w	r11,0
80008312:	c0 b5       	brlt	80008328 <_malloc_r+0xf8>
80008314:	6c 2a       	ld.w	r10,r6[0x8]
80008316:	ec 09 00 09 	add	r9,r6,r9
8000831a:	0a 9c       	mov	r12,r5
8000831c:	91 2a       	st.w	r8[0x8],r10
8000831e:	95 38       	st.w	r10[0xc],r8
80008320:	72 18       	ld.w	r8,r9[0x4]
80008322:	a1 a8       	sbr	r8,0x0
80008324:	93 18       	st.w	r9[0x4],r8
80008326:	cb c8       	rjmp	8000849e <_malloc_r+0x26e>
80008328:	10 96       	mov	r6,r8
8000832a:	14 36       	cp.w	r6,r10
8000832c:	ce 71       	brne	800082fa <_malloc_r+0xca>
8000832e:	2f f3       	sub	r3,-1
80008330:	e0 6a 05 54 	mov	r10,1364
80008334:	f4 cc ff f8 	sub	r12,r10,-8
80008338:	78 26       	ld.w	r6,r12[0x8]
8000833a:	18 36       	cp.w	r6,r12
8000833c:	c6 c0       	breq	80008414 <_malloc_r+0x1e4>
8000833e:	6c 19       	ld.w	r9,r6[0x4]
80008340:	e0 19 ff fc 	andl	r9,0xfffc
80008344:	f2 07 01 08 	sub	r8,r9,r7
80008348:	58 f8       	cp.w	r8,15
8000834a:	e0 89 00 8f 	brgt	80008468 <_malloc_r+0x238>
8000834e:	99 3c       	st.w	r12[0xc],r12
80008350:	99 2c       	st.w	r12[0x8],r12
80008352:	58 08       	cp.w	r8,0
80008354:	c0 55       	brlt	8000835e <_malloc_r+0x12e>
80008356:	ec 09 00 09 	add	r9,r6,r9
8000835a:	0a 9c       	mov	r12,r5
8000835c:	ce 2b       	rjmp	80008320 <_malloc_r+0xf0>
8000835e:	e0 49 01 ff 	cp.w	r9,511
80008362:	e0 8b 00 13 	brhi	80008388 <_malloc_r+0x158>
80008366:	a3 99       	lsr	r9,0x3
80008368:	f4 09 00 38 	add	r8,r10,r9<<0x3
8000836c:	70 2b       	ld.w	r11,r8[0x8]
8000836e:	8d 38       	st.w	r6[0xc],r8
80008370:	8d 2b       	st.w	r6[0x8],r11
80008372:	97 36       	st.w	r11[0xc],r6
80008374:	91 26       	st.w	r8[0x8],r6
80008376:	a3 49       	asr	r9,0x2
80008378:	74 18       	ld.w	r8,r10[0x4]
8000837a:	30 1b       	mov	r11,1
8000837c:	f6 09 09 49 	lsl	r9,r11,r9
80008380:	f1 e9 10 09 	or	r9,r8,r9
80008384:	95 19       	st.w	r10[0x4],r9
80008386:	c4 78       	rjmp	80008414 <_malloc_r+0x1e4>
80008388:	f2 0a 16 09 	lsr	r10,r9,0x9
8000838c:	58 4a       	cp.w	r10,4
8000838e:	e0 8b 00 07 	brhi	8000839c <_malloc_r+0x16c>
80008392:	f2 0a 16 06 	lsr	r10,r9,0x6
80008396:	2c 8a       	sub	r10,-56
80008398:	c2 08       	rjmp	800083d8 <_malloc_r+0x1a8>
8000839a:	d7 03       	nop
8000839c:	59 4a       	cp.w	r10,20
8000839e:	e0 8b 00 04 	brhi	800083a6 <_malloc_r+0x176>
800083a2:	2a 5a       	sub	r10,-91
800083a4:	c1 a8       	rjmp	800083d8 <_malloc_r+0x1a8>
800083a6:	e0 4a 00 54 	cp.w	r10,84
800083aa:	e0 8b 00 06 	brhi	800083b6 <_malloc_r+0x186>
800083ae:	f2 0a 16 0c 	lsr	r10,r9,0xc
800083b2:	29 2a       	sub	r10,-110
800083b4:	c1 28       	rjmp	800083d8 <_malloc_r+0x1a8>
800083b6:	e0 4a 01 54 	cp.w	r10,340
800083ba:	e0 8b 00 06 	brhi	800083c6 <_malloc_r+0x196>
800083be:	f2 0a 16 0f 	lsr	r10,r9,0xf
800083c2:	28 9a       	sub	r10,-119
800083c4:	c0 a8       	rjmp	800083d8 <_malloc_r+0x1a8>
800083c6:	e0 4a 05 54 	cp.w	r10,1364
800083ca:	e0 88 00 04 	brls	800083d2 <_malloc_r+0x1a2>
800083ce:	37 ea       	mov	r10,126
800083d0:	c0 48       	rjmp	800083d8 <_malloc_r+0x1a8>
800083d2:	f2 0a 16 12 	lsr	r10,r9,0x12
800083d6:	28 4a       	sub	r10,-124
800083d8:	e0 6b 05 54 	mov	r11,1364
800083dc:	f6 0a 00 34 	add	r4,r11,r10<<0x3
800083e0:	68 28       	ld.w	r8,r4[0x8]
800083e2:	08 38       	cp.w	r8,r4
800083e4:	c0 e1       	brne	80008400 <_malloc_r+0x1d0>
800083e6:	76 19       	ld.w	r9,r11[0x4]
800083e8:	a3 4a       	asr	r10,0x2
800083ea:	30 1e       	mov	lr,1
800083ec:	fc 0a 09 4a 	lsl	r10,lr,r10
800083f0:	f3 ea 10 0a 	or	r10,r9,r10
800083f4:	10 99       	mov	r9,r8
800083f6:	97 1a       	st.w	r11[0x4],r10
800083f8:	c0 a8       	rjmp	8000840c <_malloc_r+0x1dc>
800083fa:	70 28       	ld.w	r8,r8[0x8]
800083fc:	08 38       	cp.w	r8,r4
800083fe:	c0 60       	breq	8000840a <_malloc_r+0x1da>
80008400:	70 1a       	ld.w	r10,r8[0x4]
80008402:	e0 1a ff fc 	andl	r10,0xfffc
80008406:	14 39       	cp.w	r9,r10
80008408:	cf 93       	brcs	800083fa <_malloc_r+0x1ca>
8000840a:	70 39       	ld.w	r9,r8[0xc]
8000840c:	8d 39       	st.w	r6[0xc],r9
8000840e:	8d 28       	st.w	r6[0x8],r8
80008410:	91 36       	st.w	r8[0xc],r6
80008412:	93 26       	st.w	r9[0x8],r6
80008414:	e6 08 14 02 	asr	r8,r3,0x2
80008418:	30 1b       	mov	r11,1
8000841a:	e0 64 05 54 	mov	r4,1364
8000841e:	f6 08 09 4b 	lsl	r11,r11,r8
80008422:	68 18       	ld.w	r8,r4[0x4]
80008424:	10 3b       	cp.w	r11,r8
80008426:	e0 8b 00 6b 	brhi	800084fc <_malloc_r+0x2cc>
8000842a:	f7 e8 00 09 	and	r9,r11,r8
8000842e:	c0 b1       	brne	80008444 <_malloc_r+0x214>
80008430:	e0 13 ff fc 	andl	r3,0xfffc
80008434:	a1 7b       	lsl	r11,0x1
80008436:	2f c3       	sub	r3,-4
80008438:	c0 38       	rjmp	8000843e <_malloc_r+0x20e>
8000843a:	2f c3       	sub	r3,-4
8000843c:	a1 7b       	lsl	r11,0x1
8000843e:	f7 e8 00 09 	and	r9,r11,r8
80008442:	cf c0       	breq	8000843a <_malloc_r+0x20a>
80008444:	e8 03 00 3e 	add	lr,r4,r3<<0x3
80008448:	06 92       	mov	r2,r3
8000844a:	1c 91       	mov	r1,lr
8000844c:	62 36       	ld.w	r6,r1[0xc]
8000844e:	c2 e8       	rjmp	800084aa <_malloc_r+0x27a>
80008450:	6c 1a       	ld.w	r10,r6[0x4]
80008452:	e0 1a ff fc 	andl	r10,0xfffc
80008456:	f4 07 01 08 	sub	r8,r10,r7
8000845a:	58 f8       	cp.w	r8,15
8000845c:	e0 8a 00 15 	brle	80008486 <_malloc_r+0x256>
80008460:	6c 3a       	ld.w	r10,r6[0xc]
80008462:	6c 29       	ld.w	r9,r6[0x8]
80008464:	95 29       	st.w	r10[0x8],r9
80008466:	93 3a       	st.w	r9[0xc],r10
80008468:	0e 99       	mov	r9,r7
8000846a:	ec 07 00 07 	add	r7,r6,r7
8000846e:	a1 a9       	sbr	r9,0x0
80008470:	99 37       	st.w	r12[0xc],r7
80008472:	99 27       	st.w	r12[0x8],r7
80008474:	8d 19       	st.w	r6[0x4],r9
80008476:	ee 08 09 08 	st.w	r7[r8],r8
8000847a:	8f 2c       	st.w	r7[0x8],r12
8000847c:	8f 3c       	st.w	r7[0xc],r12
8000847e:	a1 a8       	sbr	r8,0x0
80008480:	0a 9c       	mov	r12,r5
80008482:	8f 18       	st.w	r7[0x4],r8
80008484:	c0 d8       	rjmp	8000849e <_malloc_r+0x26e>
80008486:	6c 39       	ld.w	r9,r6[0xc]
80008488:	58 08       	cp.w	r8,0
8000848a:	c0 f5       	brlt	800084a8 <_malloc_r+0x278>
8000848c:	ec 0a 00 0a 	add	r10,r6,r10
80008490:	74 18       	ld.w	r8,r10[0x4]
80008492:	a1 a8       	sbr	r8,0x0
80008494:	0a 9c       	mov	r12,r5
80008496:	95 18       	st.w	r10[0x4],r8
80008498:	6c 28       	ld.w	r8,r6[0x8]
8000849a:	93 28       	st.w	r9[0x8],r8
8000849c:	91 39       	st.w	r8[0xc],r9
8000849e:	fe b0 f4 89 	rcall	80006db0 <__malloc_unlock>
800084a2:	ec cc ff f8 	sub	r12,r6,-8
800084a6:	d8 32       	popm	r0-r7,pc
800084a8:	12 96       	mov	r6,r9
800084aa:	02 36       	cp.w	r6,r1
800084ac:	cd 21       	brne	80008450 <_malloc_r+0x220>
800084ae:	2f f2       	sub	r2,-1
800084b0:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
800084b4:	c0 30       	breq	800084ba <_malloc_r+0x28a>
800084b6:	2f 81       	sub	r1,-8
800084b8:	cc ab       	rjmp	8000844c <_malloc_r+0x21c>
800084ba:	1c 98       	mov	r8,lr
800084bc:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
800084c0:	c0 81       	brne	800084d0 <_malloc_r+0x2a0>
800084c2:	68 19       	ld.w	r9,r4[0x4]
800084c4:	f6 08 11 ff 	rsub	r8,r11,-1
800084c8:	f3 e8 00 08 	and	r8,r9,r8
800084cc:	89 18       	st.w	r4[0x4],r8
800084ce:	c0 78       	rjmp	800084dc <_malloc_r+0x2ac>
800084d0:	f0 c9 00 08 	sub	r9,r8,8
800084d4:	20 13       	sub	r3,1
800084d6:	70 08       	ld.w	r8,r8[0x0]
800084d8:	12 38       	cp.w	r8,r9
800084da:	cf 10       	breq	800084bc <_malloc_r+0x28c>
800084dc:	a1 7b       	lsl	r11,0x1
800084de:	68 18       	ld.w	r8,r4[0x4]
800084e0:	10 3b       	cp.w	r11,r8
800084e2:	e0 8b 00 0d 	brhi	800084fc <_malloc_r+0x2cc>
800084e6:	58 0b       	cp.w	r11,0
800084e8:	c0 a0       	breq	800084fc <_malloc_r+0x2cc>
800084ea:	04 93       	mov	r3,r2
800084ec:	c0 38       	rjmp	800084f2 <_malloc_r+0x2c2>
800084ee:	2f c3       	sub	r3,-4
800084f0:	a1 7b       	lsl	r11,0x1
800084f2:	f7 e8 00 09 	and	r9,r11,r8
800084f6:	ca 71       	brne	80008444 <_malloc_r+0x214>
800084f8:	cf bb       	rjmp	800084ee <_malloc_r+0x2be>
800084fa:	d7 03       	nop
800084fc:	68 23       	ld.w	r3,r4[0x8]
800084fe:	66 12       	ld.w	r2,r3[0x4]
80008500:	e0 12 ff fc 	andl	r2,0xfffc
80008504:	0e 32       	cp.w	r2,r7
80008506:	5f 39       	srlo	r9
80008508:	e4 07 01 08 	sub	r8,r2,r7
8000850c:	58 f8       	cp.w	r8,15
8000850e:	5f aa       	srle	r10
80008510:	f5 e9 10 09 	or	r9,r10,r9
80008514:	e0 80 00 9a 	breq	80008648 <_malloc_r+0x418>
80008518:	e0 68 0d e4 	mov	r8,3556
8000851c:	70 01       	ld.w	r1,r8[0x0]
8000851e:	e0 68 09 60 	mov	r8,2400
80008522:	2f 01       	sub	r1,-16
80008524:	70 08       	ld.w	r8,r8[0x0]
80008526:	0e 01       	add	r1,r7
80008528:	5b f8       	cp.w	r8,-1
8000852a:	c0 40       	breq	80008532 <_malloc_r+0x302>
8000852c:	28 11       	sub	r1,-127
8000852e:	e0 11 ff 80 	andl	r1,0xff80
80008532:	02 9b       	mov	r11,r1
80008534:	0a 9c       	mov	r12,r5
80008536:	e0 a0 02 b7 	rcall	80008aa4 <_sbrk_r>
8000853a:	18 96       	mov	r6,r12
8000853c:	5b fc       	cp.w	r12,-1
8000853e:	c7 50       	breq	80008628 <_malloc_r+0x3f8>
80008540:	e6 02 00 08 	add	r8,r3,r2
80008544:	10 3c       	cp.w	r12,r8
80008546:	c0 32       	brcc	8000854c <_malloc_r+0x31c>
80008548:	08 33       	cp.w	r3,r4
8000854a:	c6 f1       	brne	80008628 <_malloc_r+0x3f8>
8000854c:	e0 6a 0d e8 	mov	r10,3560
80008550:	74 09       	ld.w	r9,r10[0x0]
80008552:	e2 09 00 09 	add	r9,r1,r9
80008556:	95 09       	st.w	r10[0x0],r9
80008558:	10 36       	cp.w	r6,r8
8000855a:	c0 a1       	brne	8000856e <_malloc_r+0x33e>
8000855c:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
80008560:	c0 71       	brne	8000856e <_malloc_r+0x33e>
80008562:	e2 02 00 02 	add	r2,r1,r2
80008566:	68 28       	ld.w	r8,r4[0x8]
80008568:	a1 a2       	sbr	r2,0x0
8000856a:	91 12       	st.w	r8[0x4],r2
8000856c:	c4 f8       	rjmp	8000860a <_malloc_r+0x3da>
8000856e:	e0 6a 09 60 	mov	r10,2400
80008572:	74 0b       	ld.w	r11,r10[0x0]
80008574:	5b fb       	cp.w	r11,-1
80008576:	c0 31       	brne	8000857c <_malloc_r+0x34c>
80008578:	95 06       	st.w	r10[0x0],r6
8000857a:	c0 78       	rjmp	80008588 <_malloc_r+0x358>
8000857c:	ec 09 00 09 	add	r9,r6,r9
80008580:	e0 6a 0d e8 	mov	r10,3560
80008584:	10 19       	sub	r9,r8
80008586:	95 09       	st.w	r10[0x0],r9
80008588:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
8000858c:	f0 09 11 08 	rsub	r9,r8,8
80008590:	58 08       	cp.w	r8,0
80008592:	f2 08 17 10 	movne	r8,r9
80008596:	ed d8 e1 06 	addne	r6,r6,r8
8000859a:	28 08       	sub	r8,-128
8000859c:	ec 01 00 01 	add	r1,r6,r1
800085a0:	0a 9c       	mov	r12,r5
800085a2:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
800085a6:	f0 01 01 01 	sub	r1,r8,r1
800085aa:	02 9b       	mov	r11,r1
800085ac:	e0 a0 02 7c 	rcall	80008aa4 <_sbrk_r>
800085b0:	e0 68 0d e8 	mov	r8,3560
800085b4:	5b fc       	cp.w	r12,-1
800085b6:	ec 0c 17 00 	moveq	r12,r6
800085ba:	f9 b1 00 00 	moveq	r1,0
800085be:	70 09       	ld.w	r9,r8[0x0]
800085c0:	0c 1c       	sub	r12,r6
800085c2:	89 26       	st.w	r4[0x8],r6
800085c4:	02 0c       	add	r12,r1
800085c6:	12 01       	add	r1,r9
800085c8:	a1 ac       	sbr	r12,0x0
800085ca:	91 01       	st.w	r8[0x0],r1
800085cc:	8d 1c       	st.w	r6[0x4],r12
800085ce:	08 33       	cp.w	r3,r4
800085d0:	c1 d0       	breq	8000860a <_malloc_r+0x3da>
800085d2:	58 f2       	cp.w	r2,15
800085d4:	e0 8b 00 05 	brhi	800085de <_malloc_r+0x3ae>
800085d8:	30 18       	mov	r8,1
800085da:	8d 18       	st.w	r6[0x4],r8
800085dc:	c2 68       	rjmp	80008628 <_malloc_r+0x3f8>
800085de:	30 59       	mov	r9,5
800085e0:	20 c2       	sub	r2,12
800085e2:	e0 12 ff f8 	andl	r2,0xfff8
800085e6:	e6 02 00 08 	add	r8,r3,r2
800085ea:	91 29       	st.w	r8[0x8],r9
800085ec:	91 19       	st.w	r8[0x4],r9
800085ee:	66 18       	ld.w	r8,r3[0x4]
800085f0:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800085f4:	e5 e8 10 08 	or	r8,r2,r8
800085f8:	87 18       	st.w	r3[0x4],r8
800085fa:	58 f2       	cp.w	r2,15
800085fc:	e0 88 00 07 	brls	8000860a <_malloc_r+0x3da>
80008600:	e6 cb ff f8 	sub	r11,r3,-8
80008604:	0a 9c       	mov	r12,r5
80008606:	e0 a0 1c 7d 	rcall	8000bf00 <_free_r>
8000860a:	e0 69 0d e0 	mov	r9,3552
8000860e:	72 0a       	ld.w	r10,r9[0x0]
80008610:	e0 68 0d e8 	mov	r8,3560
80008614:	70 08       	ld.w	r8,r8[0x0]
80008616:	14 38       	cp.w	r8,r10
80008618:	f3 f8 ba 00 	st.whi	r9[0x0],r8
8000861c:	e0 69 0d dc 	mov	r9,3548
80008620:	72 0a       	ld.w	r10,r9[0x0]
80008622:	14 38       	cp.w	r8,r10
80008624:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80008628:	68 28       	ld.w	r8,r4[0x8]
8000862a:	70 18       	ld.w	r8,r8[0x4]
8000862c:	e0 18 ff fc 	andl	r8,0xfffc
80008630:	0e 38       	cp.w	r8,r7
80008632:	5f 39       	srlo	r9
80008634:	0e 18       	sub	r8,r7
80008636:	58 f8       	cp.w	r8,15
80008638:	5f aa       	srle	r10
8000863a:	f5 e9 10 09 	or	r9,r10,r9
8000863e:	c0 50       	breq	80008648 <_malloc_r+0x418>
80008640:	0a 9c       	mov	r12,r5
80008642:	fe b0 f3 b7 	rcall	80006db0 <__malloc_unlock>
80008646:	d8 3a       	popm	r0-r7,pc,r12=0
80008648:	68 26       	ld.w	r6,r4[0x8]
8000864a:	a1 a8       	sbr	r8,0x0
8000864c:	0e 99       	mov	r9,r7
8000864e:	a1 a9       	sbr	r9,0x0
80008650:	8d 19       	st.w	r6[0x4],r9
80008652:	ec 07 00 07 	add	r7,r6,r7
80008656:	0a 9c       	mov	r12,r5
80008658:	89 27       	st.w	r4[0x8],r7
8000865a:	8f 18       	st.w	r7[0x4],r8
8000865c:	fe b0 f3 aa 	rcall	80006db0 <__malloc_unlock>
80008660:	ec cc ff f8 	sub	r12,r6,-8
80008664:	d8 32       	popm	r0-r7,pc
80008666:	d7 03       	nop

80008668 <memcmp>:
80008668:	d4 01       	pushm	lr
8000866a:	30 08       	mov	r8,0
8000866c:	c0 d8       	rjmp	80008686 <memcmp+0x1e>
8000866e:	f8 08 07 0e 	ld.ub	lr,r12[r8]
80008672:	f6 08 07 09 	ld.ub	r9,r11[r8]
80008676:	20 1a       	sub	r10,1
80008678:	2f f8       	sub	r8,-1
8000867a:	f2 0e 18 00 	cp.b	lr,r9
8000867e:	c0 40       	breq	80008686 <memcmp+0x1e>
80008680:	fc 09 01 0c 	sub	r12,lr,r9
80008684:	d8 02       	popm	pc
80008686:	58 0a       	cp.w	r10,0
80008688:	cf 31       	brne	8000866e <memcmp+0x6>
8000868a:	14 9c       	mov	r12,r10
8000868c:	d8 02       	popm	pc

8000868e <memcpy>:
8000868e:	58 8a       	cp.w	r10,8
80008690:	c2 f5       	brlt	800086ee <memcpy+0x60>
80008692:	f9 eb 10 09 	or	r9,r12,r11
80008696:	e2 19 00 03 	andl	r9,0x3,COH
8000869a:	e0 81 00 97 	brne	800087c8 <memcpy+0x13a>
8000869e:	e0 4a 00 20 	cp.w	r10,32
800086a2:	c3 b4       	brge	80008718 <memcpy+0x8a>
800086a4:	f4 08 14 02 	asr	r8,r10,0x2
800086a8:	f0 09 11 08 	rsub	r9,r8,8
800086ac:	fe 09 00 2f 	add	pc,pc,r9<<0x2
800086b0:	76 69       	ld.w	r9,r11[0x18]
800086b2:	99 69       	st.w	r12[0x18],r9
800086b4:	76 59       	ld.w	r9,r11[0x14]
800086b6:	99 59       	st.w	r12[0x14],r9
800086b8:	76 49       	ld.w	r9,r11[0x10]
800086ba:	99 49       	st.w	r12[0x10],r9
800086bc:	76 39       	ld.w	r9,r11[0xc]
800086be:	99 39       	st.w	r12[0xc],r9
800086c0:	76 29       	ld.w	r9,r11[0x8]
800086c2:	99 29       	st.w	r12[0x8],r9
800086c4:	76 19       	ld.w	r9,r11[0x4]
800086c6:	99 19       	st.w	r12[0x4],r9
800086c8:	76 09       	ld.w	r9,r11[0x0]
800086ca:	99 09       	st.w	r12[0x0],r9
800086cc:	f6 08 00 2b 	add	r11,r11,r8<<0x2
800086d0:	f8 08 00 28 	add	r8,r12,r8<<0x2
800086d4:	e0 1a 00 03 	andl	r10,0x3
800086d8:	f4 0a 11 04 	rsub	r10,r10,4
800086dc:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
800086e0:	17 a9       	ld.ub	r9,r11[0x2]
800086e2:	b0 a9       	st.b	r8[0x2],r9
800086e4:	17 99       	ld.ub	r9,r11[0x1]
800086e6:	b0 99       	st.b	r8[0x1],r9
800086e8:	17 89       	ld.ub	r9,r11[0x0]
800086ea:	b0 89       	st.b	r8[0x0],r9
800086ec:	5e fc       	retal	r12
800086ee:	f4 0a 11 09 	rsub	r10,r10,9
800086f2:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
800086f6:	17 f9       	ld.ub	r9,r11[0x7]
800086f8:	b8 f9       	st.b	r12[0x7],r9
800086fa:	17 e9       	ld.ub	r9,r11[0x6]
800086fc:	b8 e9       	st.b	r12[0x6],r9
800086fe:	17 d9       	ld.ub	r9,r11[0x5]
80008700:	b8 d9       	st.b	r12[0x5],r9
80008702:	17 c9       	ld.ub	r9,r11[0x4]
80008704:	b8 c9       	st.b	r12[0x4],r9
80008706:	17 b9       	ld.ub	r9,r11[0x3]
80008708:	b8 b9       	st.b	r12[0x3],r9
8000870a:	17 a9       	ld.ub	r9,r11[0x2]
8000870c:	b8 a9       	st.b	r12[0x2],r9
8000870e:	17 99       	ld.ub	r9,r11[0x1]
80008710:	b8 99       	st.b	r12[0x1],r9
80008712:	17 89       	ld.ub	r9,r11[0x0]
80008714:	b8 89       	st.b	r12[0x0],r9
80008716:	5e fc       	retal	r12
80008718:	eb cd 40 c0 	pushm	r6-r7,lr
8000871c:	18 99       	mov	r9,r12
8000871e:	22 0a       	sub	r10,32
80008720:	b7 07       	ld.d	r6,r11++
80008722:	b3 26       	st.d	r9++,r6
80008724:	b7 07       	ld.d	r6,r11++
80008726:	b3 26       	st.d	r9++,r6
80008728:	b7 07       	ld.d	r6,r11++
8000872a:	b3 26       	st.d	r9++,r6
8000872c:	b7 07       	ld.d	r6,r11++
8000872e:	b3 26       	st.d	r9++,r6
80008730:	22 0a       	sub	r10,32
80008732:	cf 74       	brge	80008720 <memcpy+0x92>
80008734:	2f 0a       	sub	r10,-16
80008736:	c0 65       	brlt	80008742 <memcpy+0xb4>
80008738:	b7 07       	ld.d	r6,r11++
8000873a:	b3 26       	st.d	r9++,r6
8000873c:	b7 07       	ld.d	r6,r11++
8000873e:	b3 26       	st.d	r9++,r6
80008740:	21 0a       	sub	r10,16
80008742:	5c 3a       	neg	r10
80008744:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
80008748:	d7 03       	nop
8000874a:	d7 03       	nop
8000874c:	f7 36 00 0e 	ld.ub	r6,r11[14]
80008750:	f3 66 00 0e 	st.b	r9[14],r6
80008754:	f7 36 00 0d 	ld.ub	r6,r11[13]
80008758:	f3 66 00 0d 	st.b	r9[13],r6
8000875c:	f7 36 00 0c 	ld.ub	r6,r11[12]
80008760:	f3 66 00 0c 	st.b	r9[12],r6
80008764:	f7 36 00 0b 	ld.ub	r6,r11[11]
80008768:	f3 66 00 0b 	st.b	r9[11],r6
8000876c:	f7 36 00 0a 	ld.ub	r6,r11[10]
80008770:	f3 66 00 0a 	st.b	r9[10],r6
80008774:	f7 36 00 09 	ld.ub	r6,r11[9]
80008778:	f3 66 00 09 	st.b	r9[9],r6
8000877c:	f7 36 00 08 	ld.ub	r6,r11[8]
80008780:	f3 66 00 08 	st.b	r9[8],r6
80008784:	f7 36 00 07 	ld.ub	r6,r11[7]
80008788:	f3 66 00 07 	st.b	r9[7],r6
8000878c:	f7 36 00 06 	ld.ub	r6,r11[6]
80008790:	f3 66 00 06 	st.b	r9[6],r6
80008794:	f7 36 00 05 	ld.ub	r6,r11[5]
80008798:	f3 66 00 05 	st.b	r9[5],r6
8000879c:	f7 36 00 04 	ld.ub	r6,r11[4]
800087a0:	f3 66 00 04 	st.b	r9[4],r6
800087a4:	f7 36 00 03 	ld.ub	r6,r11[3]
800087a8:	f3 66 00 03 	st.b	r9[3],r6
800087ac:	f7 36 00 02 	ld.ub	r6,r11[2]
800087b0:	f3 66 00 02 	st.b	r9[2],r6
800087b4:	f7 36 00 01 	ld.ub	r6,r11[1]
800087b8:	f3 66 00 01 	st.b	r9[1],r6
800087bc:	f7 36 00 00 	ld.ub	r6,r11[0]
800087c0:	f3 66 00 00 	st.b	r9[0],r6
800087c4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800087c8:	20 1a       	sub	r10,1
800087ca:	f6 0a 07 09 	ld.ub	r9,r11[r10]
800087ce:	f8 0a 0b 09 	st.b	r12[r10],r9
800087d2:	cf b1       	brne	800087c8 <memcpy+0x13a>
800087d4:	5e fc       	retal	r12

800087d6 <memset>:
800087d6:	18 98       	mov	r8,r12
800087d8:	c0 38       	rjmp	800087de <memset+0x8>
800087da:	10 cb       	st.b	r8++,r11
800087dc:	20 1a       	sub	r10,1
800087de:	58 0a       	cp.w	r10,0
800087e0:	cf d1       	brne	800087da <memset+0x4>
800087e2:	5e fc       	retal	r12

800087e4 <_realloc_r>:
800087e4:	d4 31       	pushm	r0-r7,lr
800087e6:	20 1d       	sub	sp,4
800087e8:	16 94       	mov	r4,r11
800087ea:	18 92       	mov	r2,r12
800087ec:	14 9b       	mov	r11,r10
800087ee:	58 04       	cp.w	r4,0
800087f0:	c0 51       	brne	800087fa <_realloc_r+0x16>
800087f2:	fe b0 fd 1f 	rcall	80008230 <_malloc_r>
800087f6:	18 95       	mov	r5,r12
800087f8:	c5 39       	rjmp	80008a9e <_realloc_r+0x2ba>
800087fa:	50 0a       	stdsp	sp[0x0],r10
800087fc:	fe b0 f2 d4 	rcall	80006da4 <__malloc_lock>
80008800:	40 0b       	lddsp	r11,sp[0x0]
80008802:	f6 c8 ff f5 	sub	r8,r11,-11
80008806:	e8 c1 00 08 	sub	r1,r4,8
8000880a:	10 96       	mov	r6,r8
8000880c:	62 1c       	ld.w	r12,r1[0x4]
8000880e:	e0 16 ff f8 	andl	r6,0xfff8
80008812:	59 68       	cp.w	r8,22
80008814:	f9 b6 08 10 	movls	r6,16
80008818:	16 36       	cp.w	r6,r11
8000881a:	5f 38       	srlo	r8
8000881c:	f1 e6 13 f8 	or	r8,r8,r6>>0x1f
80008820:	c0 50       	breq	8000882a <_realloc_r+0x46>
80008822:	30 c8       	mov	r8,12
80008824:	30 05       	mov	r5,0
80008826:	85 38       	st.w	r2[0xc],r8
80008828:	c3 b9       	rjmp	80008a9e <_realloc_r+0x2ba>
8000882a:	18 90       	mov	r0,r12
8000882c:	e0 10 ff fc 	andl	r0,0xfffc
80008830:	0c 30       	cp.w	r0,r6
80008832:	e0 84 01 0b 	brge	80008a48 <_realloc_r+0x264>
80008836:	e0 68 05 54 	mov	r8,1364
8000883a:	e2 00 00 09 	add	r9,r1,r0
8000883e:	70 25       	ld.w	r5,r8[0x8]
80008840:	0a 39       	cp.w	r9,r5
80008842:	c0 90       	breq	80008854 <_realloc_r+0x70>
80008844:	72 1a       	ld.w	r10,r9[0x4]
80008846:	a1 ca       	cbr	r10,0x0
80008848:	f2 0a 00 0a 	add	r10,r9,r10
8000884c:	74 1a       	ld.w	r10,r10[0x4]
8000884e:	ed ba 00 00 	bld	r10,0x0
80008852:	c2 20       	breq	80008896 <_realloc_r+0xb2>
80008854:	72 1a       	ld.w	r10,r9[0x4]
80008856:	e0 1a ff fc 	andl	r10,0xfffc
8000885a:	f4 00 00 03 	add	r3,r10,r0
8000885e:	0a 39       	cp.w	r9,r5
80008860:	c1 31       	brne	80008886 <_realloc_r+0xa2>
80008862:	ec c7 ff f0 	sub	r7,r6,-16
80008866:	0e 33       	cp.w	r3,r7
80008868:	c1 95       	brlt	8000889a <_realloc_r+0xb6>
8000886a:	e2 06 00 09 	add	r9,r1,r6
8000886e:	0c 13       	sub	r3,r6
80008870:	a1 a3       	sbr	r3,0x0
80008872:	93 13       	st.w	r9[0x4],r3
80008874:	91 29       	st.w	r8[0x8],r9
80008876:	04 9c       	mov	r12,r2
80008878:	62 18       	ld.w	r8,r1[0x4]
8000887a:	08 95       	mov	r5,r4
8000887c:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80008880:	10 46       	or	r6,r8
80008882:	83 16       	st.w	r1[0x4],r6
80008884:	c0 b9       	rjmp	80008a9a <_realloc_r+0x2b6>
80008886:	0c 33       	cp.w	r3,r6
80008888:	c0 95       	brlt	8000889a <_realloc_r+0xb6>
8000888a:	72 28       	ld.w	r8,r9[0x8]
8000888c:	02 97       	mov	r7,r1
8000888e:	72 39       	ld.w	r9,r9[0xc]
80008890:	93 28       	st.w	r9[0x8],r8
80008892:	91 39       	st.w	r8[0xc],r9
80008894:	cd c8       	rjmp	80008a4c <_realloc_r+0x268>
80008896:	30 0a       	mov	r10,0
80008898:	14 99       	mov	r9,r10
8000889a:	ed bc 00 00 	bld	r12,0x0
8000889e:	e0 80 00 95 	breq	800089c8 <_realloc_r+0x1e4>
800088a2:	62 07       	ld.w	r7,r1[0x0]
800088a4:	e2 07 01 07 	sub	r7,r1,r7
800088a8:	6e 1c       	ld.w	r12,r7[0x4]
800088aa:	e0 1c ff fc 	andl	r12,0xfffc
800088ae:	58 09       	cp.w	r9,0
800088b0:	c5 60       	breq	8000895c <_realloc_r+0x178>
800088b2:	f8 00 00 03 	add	r3,r12,r0
800088b6:	0a 39       	cp.w	r9,r5
800088b8:	c4 81       	brne	80008948 <_realloc_r+0x164>
800088ba:	14 03       	add	r3,r10
800088bc:	ec c9 ff f0 	sub	r9,r6,-16
800088c0:	12 33       	cp.w	r3,r9
800088c2:	c4 d5       	brlt	8000895c <_realloc_r+0x178>
800088c4:	6e 3a       	ld.w	r10,r7[0xc]
800088c6:	6e 29       	ld.w	r9,r7[0x8]
800088c8:	95 29       	st.w	r10[0x8],r9
800088ca:	93 3a       	st.w	r9[0xc],r10
800088cc:	ee c5 ff f8 	sub	r5,r7,-8
800088d0:	e0 ca 00 04 	sub	r10,r0,4
800088d4:	e0 4a 00 24 	cp.w	r10,36
800088d8:	e0 8b 00 25 	brhi	80008922 <_realloc_r+0x13e>
800088dc:	0a 99       	mov	r9,r5
800088de:	59 3a       	cp.w	r10,19
800088e0:	e0 88 00 1a 	brls	80008914 <_realloc_r+0x130>
800088e4:	09 09       	ld.w	r9,r4++
800088e6:	8b 09       	st.w	r5[0x0],r9
800088e8:	09 09       	ld.w	r9,r4++
800088ea:	8f 39       	st.w	r7[0xc],r9
800088ec:	ee c9 ff f0 	sub	r9,r7,-16
800088f0:	59 ba       	cp.w	r10,27
800088f2:	e0 88 00 11 	brls	80008914 <_realloc_r+0x130>
800088f6:	09 0b       	ld.w	r11,r4++
800088f8:	93 0b       	st.w	r9[0x0],r11
800088fa:	09 09       	ld.w	r9,r4++
800088fc:	8f 59       	st.w	r7[0x14],r9
800088fe:	ee c9 ff e8 	sub	r9,r7,-24
80008902:	e0 4a 00 24 	cp.w	r10,36
80008906:	c0 71       	brne	80008914 <_realloc_r+0x130>
80008908:	09 0a       	ld.w	r10,r4++
8000890a:	93 0a       	st.w	r9[0x0],r10
8000890c:	ee c9 ff e0 	sub	r9,r7,-32
80008910:	09 0a       	ld.w	r10,r4++
80008912:	8f 7a       	st.w	r7[0x1c],r10
80008914:	09 0a       	ld.w	r10,r4++
80008916:	12 aa       	st.w	r9++,r10
80008918:	68 0a       	ld.w	r10,r4[0x0]
8000891a:	93 0a       	st.w	r9[0x0],r10
8000891c:	68 1a       	ld.w	r10,r4[0x4]
8000891e:	93 1a       	st.w	r9[0x4],r10
80008920:	c0 78       	rjmp	8000892e <_realloc_r+0x14a>
80008922:	50 08       	stdsp	sp[0x0],r8
80008924:	08 9b       	mov	r11,r4
80008926:	0a 9c       	mov	r12,r5
80008928:	e0 a0 1d 8f 	rcall	8000c446 <memmove>
8000892c:	40 08       	lddsp	r8,sp[0x0]
8000892e:	ee 06 00 09 	add	r9,r7,r6
80008932:	0c 13       	sub	r3,r6
80008934:	a1 a3       	sbr	r3,0x0
80008936:	93 13       	st.w	r9[0x4],r3
80008938:	91 29       	st.w	r8[0x8],r9
8000893a:	04 9c       	mov	r12,r2
8000893c:	6e 18       	ld.w	r8,r7[0x4]
8000893e:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80008942:	10 46       	or	r6,r8
80008944:	8f 16       	st.w	r7[0x4],r6
80008946:	ca a8       	rjmp	80008a9a <_realloc_r+0x2b6>
80008948:	14 03       	add	r3,r10
8000894a:	0c 33       	cp.w	r3,r6
8000894c:	c0 85       	brlt	8000895c <_realloc_r+0x178>
8000894e:	72 28       	ld.w	r8,r9[0x8]
80008950:	72 39       	ld.w	r9,r9[0xc]
80008952:	93 28       	st.w	r9[0x8],r8
80008954:	91 39       	st.w	r8[0xc],r9
80008956:	6e 28       	ld.w	r8,r7[0x8]
80008958:	6e 39       	ld.w	r9,r7[0xc]
8000895a:	c0 78       	rjmp	80008968 <_realloc_r+0x184>
8000895c:	f8 00 00 03 	add	r3,r12,r0
80008960:	0c 33       	cp.w	r3,r6
80008962:	c3 35       	brlt	800089c8 <_realloc_r+0x1e4>
80008964:	6e 39       	ld.w	r9,r7[0xc]
80008966:	6e 28       	ld.w	r8,r7[0x8]
80008968:	93 28       	st.w	r9[0x8],r8
8000896a:	91 39       	st.w	r8[0xc],r9
8000896c:	e0 ca 00 04 	sub	r10,r0,4
80008970:	ee cc ff f8 	sub	r12,r7,-8
80008974:	e0 4a 00 24 	cp.w	r10,36
80008978:	e0 8b 00 24 	brhi	800089c0 <_realloc_r+0x1dc>
8000897c:	59 3a       	cp.w	r10,19
8000897e:	e0 88 00 1a 	brls	800089b2 <_realloc_r+0x1ce>
80008982:	09 08       	ld.w	r8,r4++
80008984:	99 08       	st.w	r12[0x0],r8
80008986:	09 08       	ld.w	r8,r4++
80008988:	8f 38       	st.w	r7[0xc],r8
8000898a:	ee cc ff f0 	sub	r12,r7,-16
8000898e:	59 ba       	cp.w	r10,27
80008990:	e0 88 00 11 	brls	800089b2 <_realloc_r+0x1ce>
80008994:	09 08       	ld.w	r8,r4++
80008996:	99 08       	st.w	r12[0x0],r8
80008998:	09 08       	ld.w	r8,r4++
8000899a:	8f 58       	st.w	r7[0x14],r8
8000899c:	ee cc ff e8 	sub	r12,r7,-24
800089a0:	e0 4a 00 24 	cp.w	r10,36
800089a4:	c0 71       	brne	800089b2 <_realloc_r+0x1ce>
800089a6:	09 08       	ld.w	r8,r4++
800089a8:	99 08       	st.w	r12[0x0],r8
800089aa:	ee cc ff e0 	sub	r12,r7,-32
800089ae:	09 08       	ld.w	r8,r4++
800089b0:	8f 78       	st.w	r7[0x1c],r8
800089b2:	09 08       	ld.w	r8,r4++
800089b4:	18 a8       	st.w	r12++,r8
800089b6:	68 08       	ld.w	r8,r4[0x0]
800089b8:	99 08       	st.w	r12[0x0],r8
800089ba:	68 18       	ld.w	r8,r4[0x4]
800089bc:	99 18       	st.w	r12[0x4],r8
800089be:	c4 78       	rjmp	80008a4c <_realloc_r+0x268>
800089c0:	08 9b       	mov	r11,r4
800089c2:	e0 a0 1d 42 	rcall	8000c446 <memmove>
800089c6:	c4 38       	rjmp	80008a4c <_realloc_r+0x268>
800089c8:	04 9c       	mov	r12,r2
800089ca:	fe b0 fc 33 	rcall	80008230 <_malloc_r>
800089ce:	18 95       	mov	r5,r12
800089d0:	c3 a0       	breq	80008a44 <_realloc_r+0x260>
800089d2:	62 18       	ld.w	r8,r1[0x4]
800089d4:	f8 c9 00 08 	sub	r9,r12,8
800089d8:	a1 c8       	cbr	r8,0x0
800089da:	e2 08 00 08 	add	r8,r1,r8
800089de:	10 39       	cp.w	r9,r8
800089e0:	c0 71       	brne	800089ee <_realloc_r+0x20a>
800089e2:	72 13       	ld.w	r3,r9[0x4]
800089e4:	02 97       	mov	r7,r1
800089e6:	e0 13 ff fc 	andl	r3,0xfffc
800089ea:	00 03       	add	r3,r0
800089ec:	c3 08       	rjmp	80008a4c <_realloc_r+0x268>
800089ee:	e0 ca 00 04 	sub	r10,r0,4
800089f2:	e0 4a 00 24 	cp.w	r10,36
800089f6:	e0 8b 00 20 	brhi	80008a36 <_realloc_r+0x252>
800089fa:	08 99       	mov	r9,r4
800089fc:	18 98       	mov	r8,r12
800089fe:	59 3a       	cp.w	r10,19
80008a00:	e0 88 00 14 	brls	80008a28 <_realloc_r+0x244>
80008a04:	13 0b       	ld.w	r11,r9++
80008a06:	10 ab       	st.w	r8++,r11
80008a08:	13 0b       	ld.w	r11,r9++
80008a0a:	10 ab       	st.w	r8++,r11
80008a0c:	59 ba       	cp.w	r10,27
80008a0e:	e0 88 00 0d 	brls	80008a28 <_realloc_r+0x244>
80008a12:	13 0b       	ld.w	r11,r9++
80008a14:	10 ab       	st.w	r8++,r11
80008a16:	13 0b       	ld.w	r11,r9++
80008a18:	10 ab       	st.w	r8++,r11
80008a1a:	e0 4a 00 24 	cp.w	r10,36
80008a1e:	c0 51       	brne	80008a28 <_realloc_r+0x244>
80008a20:	13 0a       	ld.w	r10,r9++
80008a22:	10 aa       	st.w	r8++,r10
80008a24:	13 0a       	ld.w	r10,r9++
80008a26:	10 aa       	st.w	r8++,r10
80008a28:	13 0a       	ld.w	r10,r9++
80008a2a:	10 aa       	st.w	r8++,r10
80008a2c:	72 0a       	ld.w	r10,r9[0x0]
80008a2e:	91 0a       	st.w	r8[0x0],r10
80008a30:	72 19       	ld.w	r9,r9[0x4]
80008a32:	91 19       	st.w	r8[0x4],r9
80008a34:	c0 48       	rjmp	80008a3c <_realloc_r+0x258>
80008a36:	08 9b       	mov	r11,r4
80008a38:	e0 a0 1d 07 	rcall	8000c446 <memmove>
80008a3c:	08 9b       	mov	r11,r4
80008a3e:	04 9c       	mov	r12,r2
80008a40:	e0 a0 1a 60 	rcall	8000bf00 <_free_r>
80008a44:	04 9c       	mov	r12,r2
80008a46:	c2 a8       	rjmp	80008a9a <_realloc_r+0x2b6>
80008a48:	00 93       	mov	r3,r0
80008a4a:	02 97       	mov	r7,r1
80008a4c:	e6 06 01 09 	sub	r9,r3,r6
80008a50:	6e 18       	ld.w	r8,r7[0x4]
80008a52:	58 f9       	cp.w	r9,15
80008a54:	e0 88 00 16 	brls	80008a80 <_realloc_r+0x29c>
80008a58:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80008a5c:	ed e8 10 08 	or	r8,r6,r8
80008a60:	8f 18       	st.w	r7[0x4],r8
80008a62:	12 98       	mov	r8,r9
80008a64:	a1 a8       	sbr	r8,0x0
80008a66:	ee 06 00 0b 	add	r11,r7,r6
80008a6a:	f6 09 00 09 	add	r9,r11,r9
80008a6e:	97 18       	st.w	r11[0x4],r8
80008a70:	72 18       	ld.w	r8,r9[0x4]
80008a72:	a1 a8       	sbr	r8,0x0
80008a74:	2f 8b       	sub	r11,-8
80008a76:	93 18       	st.w	r9[0x4],r8
80008a78:	04 9c       	mov	r12,r2
80008a7a:	e0 a0 1a 43 	rcall	8000bf00 <_free_r>
80008a7e:	c0 b8       	rjmp	80008a94 <_realloc_r+0x2b0>
80008a80:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80008a84:	e7 e8 10 08 	or	r8,r3,r8
80008a88:	8f 18       	st.w	r7[0x4],r8
80008a8a:	ee 03 00 03 	add	r3,r7,r3
80008a8e:	66 18       	ld.w	r8,r3[0x4]
80008a90:	a1 a8       	sbr	r8,0x0
80008a92:	87 18       	st.w	r3[0x4],r8
80008a94:	04 9c       	mov	r12,r2
80008a96:	ee c5 ff f8 	sub	r5,r7,-8
80008a9a:	fe b0 f1 8b 	rcall	80006db0 <__malloc_unlock>
80008a9e:	0a 9c       	mov	r12,r5
80008aa0:	2f fd       	sub	sp,-4
80008aa2:	d8 32       	popm	r0-r7,pc

80008aa4 <_sbrk_r>:
80008aa4:	d4 21       	pushm	r4-r7,lr
80008aa6:	30 08       	mov	r8,0
80008aa8:	18 97       	mov	r7,r12
80008aaa:	e0 66 bd 4c 	mov	r6,48460
80008aae:	16 9c       	mov	r12,r11
80008ab0:	8d 08       	st.w	r6[0x0],r8
80008ab2:	c8 5c       	rcall	80008bbc <_sbrk>
80008ab4:	5b fc       	cp.w	r12,-1
80008ab6:	c0 51       	brne	80008ac0 <_sbrk_r+0x1c>
80008ab8:	6c 08       	ld.w	r8,r6[0x0]
80008aba:	58 08       	cp.w	r8,0
80008abc:	ef f8 1a 03 	st.wne	r7[0xc],r8
80008ac0:	d8 22       	popm	r4-r7,pc
80008ac2:	d7 03       	nop

80008ac4 <sprintf>:
80008ac4:	d4 01       	pushm	lr
80008ac6:	21 7d       	sub	sp,92
80008ac8:	e0 68 ff ff 	mov	r8,65535
80008acc:	ea 18 7f ff 	orh	r8,0x7fff
80008ad0:	50 58       	stdsp	sp[0x14],r8
80008ad2:	50 28       	stdsp	sp[0x8],r8
80008ad4:	e0 68 02 08 	mov	r8,520
80008ad8:	ba 68       	st.h	sp[0xc],r8
80008ada:	3f f8       	mov	r8,-1
80008adc:	ba 78       	st.h	sp[0xe],r8
80008ade:	e0 68 0a 54 	mov	r8,2644
80008ae2:	50 4c       	stdsp	sp[0x10],r12
80008ae4:	16 9a       	mov	r10,r11
80008ae6:	50 0c       	stdsp	sp[0x0],r12
80008ae8:	fa c9 ff a0 	sub	r9,sp,-96
80008aec:	70 0c       	ld.w	r12,r8[0x0]
80008aee:	1a 9b       	mov	r11,sp
80008af0:	e0 a0 02 1a 	rcall	80008f24 <_vfprintf_r>
80008af4:	30 09       	mov	r9,0
80008af6:	40 08       	lddsp	r8,sp[0x0]
80008af8:	b0 89       	st.b	r8[0x0],r9
80008afa:	2e 9d       	sub	sp,-92
80008afc:	d8 02       	popm	pc
80008afe:	d7 03       	nop

80008b00 <strncpy>:
80008b00:	30 08       	mov	r8,0
80008b02:	10 3a       	cp.w	r10,r8
80008b04:	5e 0c       	reteq	r12
80008b06:	f6 08 07 09 	ld.ub	r9,r11[r8]
80008b0a:	f8 08 0b 09 	st.b	r12[r8],r9
80008b0e:	2f f8       	sub	r8,-1
80008b10:	58 09       	cp.w	r9,0
80008b12:	cf 81       	brne	80008b02 <strncpy+0x2>
80008b14:	10 3a       	cp.w	r10,r8
80008b16:	5e 0c       	reteq	r12
80008b18:	f8 08 0b 09 	st.b	r12[r8],r9
80008b1c:	2f f8       	sub	r8,-1
80008b1e:	cf bb       	rjmp	80008b14 <strncpy+0x14>

80008b20 <_close>:
80008b20:	30 28       	mov	r8,2
80008b22:	d6 73       	breakpoint
80008b24:	3f fc       	mov	r12,-1
80008b26:	35 8b       	mov	r11,88
80008b28:	58 0c       	cp.w	r12,0
80008b2a:	5e 4c       	retge	r12
80008b2c:	e0 6a bd 4c 	mov	r10,48460
80008b30:	95 0b       	st.w	r10[0x0],r11
80008b32:	5e fc       	retal	r12

80008b34 <_lseek>:
80008b34:	30 58       	mov	r8,5
80008b36:	d6 73       	breakpoint
80008b38:	3f fc       	mov	r12,-1
80008b3a:	35 8b       	mov	r11,88
80008b3c:	58 0c       	cp.w	r12,0
80008b3e:	5e 4c       	retge	r12
80008b40:	e0 6a bd 4c 	mov	r10,48460
80008b44:	95 0b       	st.w	r10[0x0],r11
80008b46:	5e fc       	retal	r12

80008b48 <isatty>:
80008b48:	30 b8       	mov	r8,11
80008b4a:	d6 73       	breakpoint
80008b4c:	3f fc       	mov	r12,-1
80008b4e:	35 8b       	mov	r11,88
80008b50:	58 0c       	cp.w	r12,0
80008b52:	5e 4c       	retge	r12
80008b54:	e0 6a bd 4c 	mov	r10,48460
80008b58:	95 0b       	st.w	r10[0x0],r11
80008b5a:	5e fc       	retal	r12

80008b5c <_fstat_host>:
80008b5c:	30 98       	mov	r8,9
80008b5e:	d6 73       	breakpoint
80008b60:	3f fc       	mov	r12,-1
80008b62:	35 8b       	mov	r11,88
80008b64:	58 0c       	cp.w	r12,0
80008b66:	5e 4c       	retge	r12
80008b68:	e0 6a bd 4c 	mov	r10,48460
80008b6c:	95 0b       	st.w	r10[0x0],r11
80008b6e:	5e fc       	retal	r12

80008b70 <_fstat>:
80008b70:	d4 21       	pushm	r4-r7,lr
80008b72:	21 0d       	sub	sp,64
80008b74:	16 97       	mov	r7,r11
80008b76:	1a 9b       	mov	r11,sp
80008b78:	cf 2f       	rcall	80008b5c <_fstat_host>
80008b7a:	c0 34       	brge	80008b80 <_fstat+0x10>
80008b7c:	3f fc       	mov	r12,-1
80008b7e:	c1 c8       	rjmp	80008bb6 <_fstat+0x46>
80008b80:	40 08       	lddsp	r8,sp[0x0]
80008b82:	ae 08       	st.h	r7[0x0],r8
80008b84:	40 18       	lddsp	r8,sp[0x4]
80008b86:	ae 18       	st.h	r7[0x2],r8
80008b88:	40 28       	lddsp	r8,sp[0x8]
80008b8a:	8f 18       	st.w	r7[0x4],r8
80008b8c:	40 38       	lddsp	r8,sp[0xc]
80008b8e:	ae 48       	st.h	r7[0x8],r8
80008b90:	40 48       	lddsp	r8,sp[0x10]
80008b92:	ae 58       	st.h	r7[0xa],r8
80008b94:	40 58       	lddsp	r8,sp[0x14]
80008b96:	ae 68       	st.h	r7[0xc],r8
80008b98:	40 68       	lddsp	r8,sp[0x18]
80008b9a:	ae 78       	st.h	r7[0xe],r8
80008b9c:	40 88       	lddsp	r8,sp[0x20]
80008b9e:	8f 48       	st.w	r7[0x10],r8
80008ba0:	40 a8       	lddsp	r8,sp[0x28]
80008ba2:	8f b8       	st.w	r7[0x2c],r8
80008ba4:	40 c8       	lddsp	r8,sp[0x30]
80008ba6:	8f c8       	st.w	r7[0x30],r8
80008ba8:	40 d8       	lddsp	r8,sp[0x34]
80008baa:	8f 58       	st.w	r7[0x14],r8
80008bac:	40 e8       	lddsp	r8,sp[0x38]
80008bae:	30 0c       	mov	r12,0
80008bb0:	8f 78       	st.w	r7[0x1c],r8
80008bb2:	40 f8       	lddsp	r8,sp[0x3c]
80008bb4:	8f 98       	st.w	r7[0x24],r8
80008bb6:	2f 0d       	sub	sp,-64
80008bb8:	d8 22       	popm	r4-r7,pc
80008bba:	d7 03       	nop

80008bbc <_sbrk>:
80008bbc:	d4 01       	pushm	lr
80008bbe:	e0 68 0e 10 	mov	r8,3600
80008bc2:	70 09       	ld.w	r9,r8[0x0]
80008bc4:	58 09       	cp.w	r9,0
80008bc6:	c0 41       	brne	80008bce <_sbrk+0x12>
80008bc8:	e0 69 bd 50 	mov	r9,48464
80008bcc:	91 09       	st.w	r8[0x0],r9
80008bce:	e0 69 0e 10 	mov	r9,3600
80008bd2:	e0 7a 70 00 	mov	r10,94208
80008bd6:	72 08       	ld.w	r8,r9[0x0]
80008bd8:	f0 0c 00 0c 	add	r12,r8,r12
80008bdc:	14 3c       	cp.w	r12,r10
80008bde:	e0 8b 00 04 	brhi	80008be6 <_sbrk+0x2a>
80008be2:	93 0c       	st.w	r9[0x0],r12
80008be4:	c0 68       	rjmp	80008bf0 <_sbrk+0x34>
80008be6:	e0 a0 18 15 	rcall	8000bc10 <__errno>
80008bea:	30 c8       	mov	r8,12
80008bec:	99 08       	st.w	r12[0x0],r8
80008bee:	3f f8       	mov	r8,-1
80008bf0:	10 9c       	mov	r12,r8
80008bf2:	d8 02       	popm	pc

80008bf4 <get_arg>:
80008bf4:	d4 31       	pushm	r0-r7,lr
80008bf6:	20 8d       	sub	sp,32
80008bf8:	fa c4 ff bc 	sub	r4,sp,-68
80008bfc:	50 4b       	stdsp	sp[0x10],r11
80008bfe:	68 2e       	ld.w	lr,r4[0x8]
80008c00:	50 58       	stdsp	sp[0x14],r8
80008c02:	12 96       	mov	r6,r9
80008c04:	7c 0b       	ld.w	r11,lr[0x0]
80008c06:	70 05       	ld.w	r5,r8[0x0]
80008c08:	50 6e       	stdsp	sp[0x18],lr
80008c0a:	58 0b       	cp.w	r11,0
80008c0c:	f4 0b 17 00 	moveq	r11,r10
80008c10:	68 03       	ld.w	r3,r4[0x0]
80008c12:	68 11       	ld.w	r1,r4[0x4]
80008c14:	40 49       	lddsp	r9,sp[0x10]
80008c16:	30 08       	mov	r8,0
80008c18:	c2 89       	rjmp	80008e68 <get_arg+0x274>
80008c1a:	2f fb       	sub	r11,-1
80008c1c:	32 5c       	mov	r12,37
80008c1e:	17 8a       	ld.ub	r10,r11[0x0]
80008c20:	f8 0a 18 00 	cp.b	r10,r12
80008c24:	5f 1e       	srne	lr
80008c26:	f0 0a 18 00 	cp.b	r10,r8
80008c2a:	5f 1c       	srne	r12
80008c2c:	fd ec 00 0c 	and	r12,lr,r12
80008c30:	f0 0c 18 00 	cp.b	r12,r8
80008c34:	cf 31       	brne	80008c1a <get_arg+0x26>
80008c36:	58 0a       	cp.w	r10,0
80008c38:	e0 80 01 25 	breq	80008e82 <get_arg+0x28e>
80008c3c:	30 0c       	mov	r12,0
80008c3e:	3f fa       	mov	r10,-1
80008c40:	18 90       	mov	r0,r12
80008c42:	50 3a       	stdsp	sp[0xc],r10
80008c44:	18 94       	mov	r4,r12
80008c46:	18 92       	mov	r2,r12
80008c48:	f8 0c 00 3c 	add	r12,r12,r12<<0x3
80008c4c:	16 97       	mov	r7,r11
80008c4e:	50 7c       	stdsp	sp[0x1c],r12
80008c50:	fe cc 9a b4 	sub	r12,pc,-25932
80008c54:	0f 3a       	ld.ub	r10,r7++
80008c56:	f8 0a 07 0e 	ld.ub	lr,r12[r10]
80008c5a:	40 7c       	lddsp	r12,sp[0x1c]
80008c5c:	1c 0c       	add	r12,lr
80008c5e:	fe ce 9b 8a 	sub	lr,pc,-25718
80008c62:	fc 0c 07 0e 	ld.ub	lr,lr[r12]
80008c66:	20 1e       	sub	lr,1
80008c68:	50 0e       	stdsp	sp[0x0],lr
80008c6a:	fe ce 9c 02 	sub	lr,pc,-25598
80008c6e:	fc 0c 07 0c 	ld.ub	r12,lr[r12]
80008c72:	50 7c       	stdsp	sp[0x1c],r12
80008c74:	40 0c       	lddsp	r12,sp[0x0]
80008c76:	58 7c       	cp.w	r12,7
80008c78:	e0 8b 00 f1 	brhi	80008e5a <get_arg+0x266>
80008c7c:	fe ce 9d b4 	sub	lr,pc,-25164
80008c80:	fc 0c 03 2f 	ld.w	pc,lr[r12<<0x2]
80008c84:	36 8b       	mov	r11,104
80008c86:	f6 0a 18 00 	cp.b	r10,r11
80008c8a:	e0 80 00 e8 	breq	80008e5a <get_arg+0x266>
80008c8e:	37 1b       	mov	r11,113
80008c90:	f6 0a 18 00 	cp.b	r10,r11
80008c94:	c0 70       	breq	80008ca2 <get_arg+0xae>
80008c96:	34 cb       	mov	r11,76
80008c98:	f6 0a 18 00 	cp.b	r10,r11
80008c9c:	c0 51       	brne	80008ca6 <get_arg+0xb2>
80008c9e:	a3 b4       	sbr	r4,0x3
80008ca0:	cd d8       	rjmp	80008e5a <get_arg+0x266>
80008ca2:	a5 b4       	sbr	r4,0x5
80008ca4:	cd b8       	rjmp	80008e5a <get_arg+0x266>
80008ca6:	08 9a       	mov	r10,r4
80008ca8:	0e 9b       	mov	r11,r7
80008caa:	a5 aa       	sbr	r10,0x4
80008cac:	17 3c       	ld.ub	r12,r11++
80008cae:	a5 b4       	sbr	r4,0x5
80008cb0:	36 ce       	mov	lr,108
80008cb2:	fc 0c 18 00 	cp.b	r12,lr
80008cb6:	e0 80 00 d3 	breq	80008e5c <get_arg+0x268>
80008cba:	14 94       	mov	r4,r10
80008cbc:	cc f8       	rjmp	80008e5a <get_arg+0x266>
80008cbe:	eb d5 c0 05 	bfextu	r5,r5,0x0,0x5
80008cc2:	36 7c       	mov	r12,103
80008cc4:	f8 0a 18 00 	cp.b	r10,r12
80008cc8:	e0 8b 00 27 	brhi	80008d16 <get_arg+0x122>
80008ccc:	36 5b       	mov	r11,101
80008cce:	f6 0a 18 00 	cp.b	r10,r11
80008cd2:	c4 82       	brcc	80008d62 <get_arg+0x16e>
80008cd4:	34 fb       	mov	r11,79
80008cd6:	f6 0a 18 00 	cp.b	r10,r11
80008cda:	c4 80       	breq	80008d6a <get_arg+0x176>
80008cdc:	e0 8b 00 0c 	brhi	80008cf4 <get_arg+0x100>
80008ce0:	34 5b       	mov	r11,69
80008ce2:	f6 0a 18 00 	cp.b	r10,r11
80008ce6:	c3 e0       	breq	80008d62 <get_arg+0x16e>
80008ce8:	34 7b       	mov	r11,71
80008cea:	f6 0a 18 00 	cp.b	r10,r11
80008cee:	c3 a0       	breq	80008d62 <get_arg+0x16e>
80008cf0:	34 4b       	mov	r11,68
80008cf2:	c0 88       	rjmp	80008d02 <get_arg+0x10e>
80008cf4:	35 8b       	mov	r11,88
80008cf6:	f6 0a 18 00 	cp.b	r10,r11
80008cfa:	c2 c0       	breq	80008d52 <get_arg+0x15e>
80008cfc:	e0 8b 00 07 	brhi	80008d0a <get_arg+0x116>
80008d00:	35 5b       	mov	r11,85
80008d02:	f6 0a 18 00 	cp.b	r10,r11
80008d06:	c3 51       	brne	80008d70 <get_arg+0x17c>
80008d08:	c3 18       	rjmp	80008d6a <get_arg+0x176>
80008d0a:	36 3b       	mov	r11,99
80008d0c:	f6 0a 18 00 	cp.b	r10,r11
80008d10:	c2 f0       	breq	80008d6e <get_arg+0x17a>
80008d12:	36 4b       	mov	r11,100
80008d14:	c0 e8       	rjmp	80008d30 <get_arg+0x13c>
80008d16:	37 0b       	mov	r11,112
80008d18:	f6 0a 18 00 	cp.b	r10,r11
80008d1c:	c2 50       	breq	80008d66 <get_arg+0x172>
80008d1e:	e0 8b 00 0d 	brhi	80008d38 <get_arg+0x144>
80008d22:	36 eb       	mov	r11,110
80008d24:	f6 0a 18 00 	cp.b	r10,r11
80008d28:	c1 f0       	breq	80008d66 <get_arg+0x172>
80008d2a:	e0 8b 00 14 	brhi	80008d52 <get_arg+0x15e>
80008d2e:	36 9b       	mov	r11,105
80008d30:	f6 0a 18 00 	cp.b	r10,r11
80008d34:	c1 e1       	brne	80008d70 <get_arg+0x17c>
80008d36:	c0 e8       	rjmp	80008d52 <get_arg+0x15e>
80008d38:	37 5b       	mov	r11,117
80008d3a:	f6 0a 18 00 	cp.b	r10,r11
80008d3e:	c0 a0       	breq	80008d52 <get_arg+0x15e>
80008d40:	37 8b       	mov	r11,120
80008d42:	f6 0a 18 00 	cp.b	r10,r11
80008d46:	c0 60       	breq	80008d52 <get_arg+0x15e>
80008d48:	37 3b       	mov	r11,115
80008d4a:	f6 0a 18 00 	cp.b	r10,r11
80008d4e:	c1 11       	brne	80008d70 <get_arg+0x17c>
80008d50:	c0 b8       	rjmp	80008d66 <get_arg+0x172>
80008d52:	ed b4 00 04 	bld	r4,0x4
80008d56:	c0 a0       	breq	80008d6a <get_arg+0x176>
80008d58:	ed b4 00 05 	bld	r4,0x5
80008d5c:	c0 91       	brne	80008d6e <get_arg+0x17a>
80008d5e:	30 20       	mov	r0,2
80008d60:	c0 88       	rjmp	80008d70 <get_arg+0x17c>
80008d62:	30 40       	mov	r0,4
80008d64:	c0 68       	rjmp	80008d70 <get_arg+0x17c>
80008d66:	30 30       	mov	r0,3
80008d68:	c0 48       	rjmp	80008d70 <get_arg+0x17c>
80008d6a:	30 10       	mov	r0,1
80008d6c:	c0 28       	rjmp	80008d70 <get_arg+0x17c>
80008d6e:	30 00       	mov	r0,0
80008d70:	40 3b       	lddsp	r11,sp[0xc]
80008d72:	5b fb       	cp.w	r11,-1
80008d74:	c0 40       	breq	80008d7c <get_arg+0x188>
80008d76:	e2 0b 09 20 	st.w	r1[r11<<0x2],r0
80008d7a:	c7 08       	rjmp	80008e5a <get_arg+0x266>
80008d7c:	58 60       	cp.w	r0,6
80008d7e:	e0 8b 00 6e 	brhi	80008e5a <get_arg+0x266>
80008d82:	6c 0a       	ld.w	r10,r6[0x0]
80008d84:	ea cc ff ff 	sub	r12,r5,-1
80008d88:	fe ce 9e a0 	sub	lr,pc,-24928
80008d8c:	fc 00 03 2f 	ld.w	pc,lr[r0<<0x2]
80008d90:	f4 cb ff f8 	sub	r11,r10,-8
80008d94:	8d 0b       	st.w	r6[0x0],r11
80008d96:	f4 ea 00 00 	ld.d	r10,r10[0]
80008d9a:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80008d9e:	c0 f8       	rjmp	80008dbc <get_arg+0x1c8>
80008da0:	f4 cb ff fc 	sub	r11,r10,-4
80008da4:	8d 0b       	st.w	r6[0x0],r11
80008da6:	74 0a       	ld.w	r10,r10[0x0]
80008da8:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80008dac:	c0 88       	rjmp	80008dbc <get_arg+0x1c8>
80008dae:	f4 cb ff f8 	sub	r11,r10,-8
80008db2:	8d 0b       	st.w	r6[0x0],r11
80008db4:	f4 ea 00 00 	ld.d	r10,r10[0]
80008db8:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80008dbc:	0e 9b       	mov	r11,r7
80008dbe:	18 95       	mov	r5,r12
80008dc0:	c4 e8       	rjmp	80008e5c <get_arg+0x268>
80008dc2:	62 0a       	ld.w	r10,r1[0x0]
80008dc4:	5b fa       	cp.w	r10,-1
80008dc6:	c0 b1       	brne	80008ddc <get_arg+0x1e8>
80008dc8:	50 19       	stdsp	sp[0x4],r9
80008dca:	50 28       	stdsp	sp[0x8],r8
80008dcc:	e0 6a 00 80 	mov	r10,128
80008dd0:	30 0b       	mov	r11,0
80008dd2:	02 9c       	mov	r12,r1
80008dd4:	fe b0 fd 01 	rcall	800087d6 <memset>
80008dd8:	40 28       	lddsp	r8,sp[0x8]
80008dda:	40 19       	lddsp	r9,sp[0x4]
80008ddc:	e4 cc 00 01 	sub	r12,r2,1
80008de0:	0e 9b       	mov	r11,r7
80008de2:	50 3c       	stdsp	sp[0xc],r12
80008de4:	f2 0c 0c 49 	max	r9,r9,r12
80008de8:	c3 a8       	rjmp	80008e5c <get_arg+0x268>
80008dea:	62 0a       	ld.w	r10,r1[0x0]
80008dec:	5b fa       	cp.w	r10,-1
80008dee:	c0 b1       	brne	80008e04 <get_arg+0x210>
80008df0:	50 19       	stdsp	sp[0x4],r9
80008df2:	50 28       	stdsp	sp[0x8],r8
80008df4:	e0 6a 00 80 	mov	r10,128
80008df8:	30 0b       	mov	r11,0
80008dfa:	02 9c       	mov	r12,r1
80008dfc:	fe b0 fc ed 	rcall	800087d6 <memset>
80008e00:	40 28       	lddsp	r8,sp[0x8]
80008e02:	40 19       	lddsp	r9,sp[0x4]
80008e04:	20 12       	sub	r2,1
80008e06:	30 0a       	mov	r10,0
80008e08:	0e 9b       	mov	r11,r7
80008e0a:	e2 02 09 2a 	st.w	r1[r2<<0x2],r10
80008e0e:	f2 02 0c 49 	max	r9,r9,r2
80008e12:	c2 58       	rjmp	80008e5c <get_arg+0x268>
80008e14:	16 97       	mov	r7,r11
80008e16:	6c 0a       	ld.w	r10,r6[0x0]
80008e18:	f4 cb ff fc 	sub	r11,r10,-4
80008e1c:	8d 0b       	st.w	r6[0x0],r11
80008e1e:	74 0a       	ld.w	r10,r10[0x0]
80008e20:	0e 9b       	mov	r11,r7
80008e22:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80008e26:	2f f5       	sub	r5,-1
80008e28:	c1 a8       	rjmp	80008e5c <get_arg+0x268>
80008e2a:	f4 c2 00 30 	sub	r2,r10,48
80008e2e:	c0 68       	rjmp	80008e3a <get_arg+0x246>
80008e30:	e4 02 00 22 	add	r2,r2,r2<<0x2
80008e34:	2f f7       	sub	r7,-1
80008e36:	f4 02 00 12 	add	r2,r10,r2<<0x1
80008e3a:	0f 8a       	ld.ub	r10,r7[0x0]
80008e3c:	58 0a       	cp.w	r10,0
80008e3e:	c0 e0       	breq	80008e5a <get_arg+0x266>
80008e40:	23 0a       	sub	r10,48
80008e42:	58 9a       	cp.w	r10,9
80008e44:	fe 98 ff f6 	brls	80008e30 <get_arg+0x23c>
80008e48:	c0 98       	rjmp	80008e5a <get_arg+0x266>
80008e4a:	2f f7       	sub	r7,-1
80008e4c:	0f 8a       	ld.ub	r10,r7[0x0]
80008e4e:	58 0a       	cp.w	r10,0
80008e50:	c0 50       	breq	80008e5a <get_arg+0x266>
80008e52:	23 0a       	sub	r10,48
80008e54:	58 9a       	cp.w	r10,9
80008e56:	fe 98 ff fa 	brls	80008e4a <get_arg+0x256>
80008e5a:	0e 9b       	mov	r11,r7
80008e5c:	40 7c       	lddsp	r12,sp[0x1c]
80008e5e:	30 ba       	mov	r10,11
80008e60:	f4 0c 18 00 	cp.b	r12,r10
80008e64:	fe 91 fe f2 	brne	80008c48 <get_arg+0x54>
80008e68:	40 42       	lddsp	r2,sp[0x10]
80008e6a:	17 8c       	ld.ub	r12,r11[0x0]
80008e6c:	0a 32       	cp.w	r2,r5
80008e6e:	5f 4a       	srge	r10
80008e70:	f0 0c 18 00 	cp.b	r12,r8
80008e74:	5f 1c       	srne	r12
80008e76:	f9 ea 00 0a 	and	r10,r12,r10
80008e7a:	f0 0a 18 00 	cp.b	r10,r8
80008e7e:	fe 91 fe cf 	brne	80008c1c <get_arg+0x28>
80008e82:	30 08       	mov	r8,0
80008e84:	40 4e       	lddsp	lr,sp[0x10]
80008e86:	17 8a       	ld.ub	r10,r11[0x0]
80008e88:	e2 05 00 21 	add	r1,r1,r5<<0x2
80008e8c:	f0 0a 18 00 	cp.b	r10,r8
80008e90:	fc 09 17 10 	movne	r9,lr
80008e94:	e6 05 00 38 	add	r8,r3,r5<<0x3
80008e98:	06 9e       	mov	lr,r3
80008e9a:	c2 a8       	rjmp	80008eee <get_arg+0x2fa>
80008e9c:	62 0a       	ld.w	r10,r1[0x0]
80008e9e:	58 3a       	cp.w	r10,3
80008ea0:	c1 e0       	breq	80008edc <get_arg+0x2e8>
80008ea2:	e0 89 00 07 	brgt	80008eb0 <get_arg+0x2bc>
80008ea6:	58 1a       	cp.w	r10,1
80008ea8:	c1 a0       	breq	80008edc <get_arg+0x2e8>
80008eaa:	58 2a       	cp.w	r10,2
80008eac:	c1 81       	brne	80008edc <get_arg+0x2e8>
80008eae:	c0 58       	rjmp	80008eb8 <get_arg+0x2c4>
80008eb0:	58 5a       	cp.w	r10,5
80008eb2:	c0 c0       	breq	80008eca <get_arg+0x2d6>
80008eb4:	c0 b5       	brlt	80008eca <get_arg+0x2d6>
80008eb6:	c1 38       	rjmp	80008edc <get_arg+0x2e8>
80008eb8:	6c 0a       	ld.w	r10,r6[0x0]
80008eba:	f4 cc ff f8 	sub	r12,r10,-8
80008ebe:	8d 0c       	st.w	r6[0x0],r12
80008ec0:	f4 e2 00 00 	ld.d	r2,r10[0]
80008ec4:	f0 e3 00 00 	st.d	r8[0],r2
80008ec8:	c1 08       	rjmp	80008ee8 <get_arg+0x2f4>
80008eca:	6c 0a       	ld.w	r10,r6[0x0]
80008ecc:	f4 cc ff f8 	sub	r12,r10,-8
80008ed0:	8d 0c       	st.w	r6[0x0],r12
80008ed2:	f4 e2 00 00 	ld.d	r2,r10[0]
80008ed6:	f0 e3 00 00 	st.d	r8[0],r2
80008eda:	c0 78       	rjmp	80008ee8 <get_arg+0x2f4>
80008edc:	6c 0a       	ld.w	r10,r6[0x0]
80008ede:	f4 cc ff fc 	sub	r12,r10,-4
80008ee2:	8d 0c       	st.w	r6[0x0],r12
80008ee4:	74 0a       	ld.w	r10,r10[0x0]
80008ee6:	91 0a       	st.w	r8[0x0],r10
80008ee8:	2f f5       	sub	r5,-1
80008eea:	2f 88       	sub	r8,-8
80008eec:	2f c1       	sub	r1,-4
80008eee:	12 35       	cp.w	r5,r9
80008ef0:	fe 9a ff d6 	brle	80008e9c <get_arg+0x2a8>
80008ef4:	1c 93       	mov	r3,lr
80008ef6:	40 52       	lddsp	r2,sp[0x14]
80008ef8:	40 6e       	lddsp	lr,sp[0x18]
80008efa:	85 05       	st.w	r2[0x0],r5
80008efc:	9d 0b       	st.w	lr[0x0],r11
80008efe:	40 4b       	lddsp	r11,sp[0x10]
80008f00:	e6 0b 00 3c 	add	r12,r3,r11<<0x3
80008f04:	2f 8d       	sub	sp,-32
80008f06:	d8 32       	popm	r0-r7,pc

80008f08 <__sprint_r>:
80008f08:	d4 21       	pushm	r4-r7,lr
80008f0a:	14 97       	mov	r7,r10
80008f0c:	74 28       	ld.w	r8,r10[0x8]
80008f0e:	58 08       	cp.w	r8,0
80008f10:	c0 41       	brne	80008f18 <__sprint_r+0x10>
80008f12:	95 18       	st.w	r10[0x4],r8
80008f14:	10 9c       	mov	r12,r8
80008f16:	d8 22       	popm	r4-r7,pc
80008f18:	e0 a0 18 ba 	rcall	8000c08c <__sfvwrite_r>
80008f1c:	30 08       	mov	r8,0
80008f1e:	8f 18       	st.w	r7[0x4],r8
80008f20:	8f 28       	st.w	r7[0x8],r8
80008f22:	d8 22       	popm	r4-r7,pc

80008f24 <_vfprintf_r>:
80008f24:	d4 31       	pushm	r0-r7,lr
80008f26:	fa cd 06 bc 	sub	sp,sp,1724
80008f2a:	51 09       	stdsp	sp[0x40],r9
80008f2c:	16 91       	mov	r1,r11
80008f2e:	14 97       	mov	r7,r10
80008f30:	18 95       	mov	r5,r12
80008f32:	e0 a0 1a 1d 	rcall	8000c36c <_localeconv_r>
80008f36:	78 0c       	ld.w	r12,r12[0x0]
80008f38:	50 cc       	stdsp	sp[0x30],r12
80008f3a:	58 05       	cp.w	r5,0
80008f3c:	c0 70       	breq	80008f4a <_vfprintf_r+0x26>
80008f3e:	6a 68       	ld.w	r8,r5[0x18]
80008f40:	58 08       	cp.w	r8,0
80008f42:	c0 41       	brne	80008f4a <_vfprintf_r+0x26>
80008f44:	0a 9c       	mov	r12,r5
80008f46:	e0 a0 17 43 	rcall	8000bdcc <__sinit>
80008f4a:	fe c8 9c 9e 	sub	r8,pc,-25442
80008f4e:	10 31       	cp.w	r1,r8
80008f50:	c0 31       	brne	80008f56 <_vfprintf_r+0x32>
80008f52:	6a 01       	ld.w	r1,r5[0x0]
80008f54:	c0 c8       	rjmp	80008f6c <_vfprintf_r+0x48>
80008f56:	fe c8 9c 8a 	sub	r8,pc,-25462
80008f5a:	10 31       	cp.w	r1,r8
80008f5c:	c0 31       	brne	80008f62 <_vfprintf_r+0x3e>
80008f5e:	6a 11       	ld.w	r1,r5[0x4]
80008f60:	c0 68       	rjmp	80008f6c <_vfprintf_r+0x48>
80008f62:	fe c8 9c 76 	sub	r8,pc,-25482
80008f66:	10 31       	cp.w	r1,r8
80008f68:	eb f1 00 02 	ld.weq	r1,r5[0x8]
80008f6c:	82 68       	ld.sh	r8,r1[0xc]
80008f6e:	ed b8 00 03 	bld	r8,0x3
80008f72:	c0 41       	brne	80008f7a <_vfprintf_r+0x56>
80008f74:	62 48       	ld.w	r8,r1[0x10]
80008f76:	58 08       	cp.w	r8,0
80008f78:	c0 71       	brne	80008f86 <_vfprintf_r+0x62>
80008f7a:	02 9b       	mov	r11,r1
80008f7c:	0a 9c       	mov	r12,r5
80008f7e:	e0 a0 0f 5d 	rcall	8000ae38 <__swsetup_r>
80008f82:	e0 81 0f 54 	brne	8000ae2a <_vfprintf_r+0x1f06>
80008f86:	82 68       	ld.sh	r8,r1[0xc]
80008f88:	10 99       	mov	r9,r8
80008f8a:	e2 19 00 1a 	andl	r9,0x1a,COH
80008f8e:	58 a9       	cp.w	r9,10
80008f90:	c3 c1       	brne	80009008 <_vfprintf_r+0xe4>
80008f92:	82 79       	ld.sh	r9,r1[0xe]
80008f94:	30 0a       	mov	r10,0
80008f96:	f4 09 19 00 	cp.h	r9,r10
80008f9a:	c3 75       	brlt	80009008 <_vfprintf_r+0xe4>
80008f9c:	a1 d8       	cbr	r8,0x1
80008f9e:	fb 58 05 d0 	st.h	sp[1488],r8
80008fa2:	62 88       	ld.w	r8,r1[0x20]
80008fa4:	fb 48 05 e4 	st.w	sp[1508],r8
80008fa8:	62 a8       	ld.w	r8,r1[0x28]
80008faa:	fb 48 05 ec 	st.w	sp[1516],r8
80008fae:	fa c8 ff bc 	sub	r8,sp,-68
80008fb2:	fb 48 05 d4 	st.w	sp[1492],r8
80008fb6:	fb 48 05 c4 	st.w	sp[1476],r8
80008fba:	e0 68 04 00 	mov	r8,1024
80008fbe:	fb 48 05 d8 	st.w	sp[1496],r8
80008fc2:	fb 48 05 cc 	st.w	sp[1484],r8
80008fc6:	30 08       	mov	r8,0
80008fc8:	fb 59 05 d2 	st.h	sp[1490],r9
80008fcc:	0e 9a       	mov	r10,r7
80008fce:	41 09       	lddsp	r9,sp[0x40]
80008fd0:	fa c7 fa 3c 	sub	r7,sp,-1476
80008fd4:	fb 48 05 dc 	st.w	sp[1500],r8
80008fd8:	0a 9c       	mov	r12,r5
80008fda:	0e 9b       	mov	r11,r7
80008fdc:	ca 4f       	rcall	80008f24 <_vfprintf_r>
80008fde:	50 bc       	stdsp	sp[0x2c],r12
80008fe0:	c0 95       	brlt	80008ff2 <_vfprintf_r+0xce>
80008fe2:	0e 9b       	mov	r11,r7
80008fe4:	0a 9c       	mov	r12,r5
80008fe6:	e0 a0 16 1b 	rcall	8000bc1c <_fflush_r>
80008fea:	40 be       	lddsp	lr,sp[0x2c]
80008fec:	f9 be 01 ff 	movne	lr,-1
80008ff0:	50 be       	stdsp	sp[0x2c],lr
80008ff2:	fb 08 05 d0 	ld.sh	r8,sp[1488]
80008ff6:	ed b8 00 06 	bld	r8,0x6
80008ffa:	e0 81 0f 1a 	brne	8000ae2e <_vfprintf_r+0x1f0a>
80008ffe:	82 68       	ld.sh	r8,r1[0xc]
80009000:	a7 a8       	sbr	r8,0x6
80009002:	a2 68       	st.h	r1[0xc],r8
80009004:	e0 8f 0f 15 	bral	8000ae2e <_vfprintf_r+0x1f0a>
80009008:	30 08       	mov	r8,0
8000900a:	fb 48 06 b4 	st.w	sp[1716],r8
8000900e:	fb 48 06 90 	st.w	sp[1680],r8
80009012:	fb 48 06 8c 	st.w	sp[1676],r8
80009016:	fb 48 06 b0 	st.w	sp[1712],r8
8000901a:	30 08       	mov	r8,0
8000901c:	30 09       	mov	r9,0
8000901e:	50 a7       	stdsp	sp[0x28],r7
80009020:	50 78       	stdsp	sp[0x1c],r8
80009022:	fa c3 f9 e0 	sub	r3,sp,-1568
80009026:	3f f8       	mov	r8,-1
80009028:	50 59       	stdsp	sp[0x14],r9
8000902a:	fb 43 06 88 	st.w	sp[1672],r3
8000902e:	fb 48 05 44 	st.w	sp[1348],r8
80009032:	12 9c       	mov	r12,r9
80009034:	50 69       	stdsp	sp[0x18],r9
80009036:	50 d9       	stdsp	sp[0x34],r9
80009038:	50 e9       	stdsp	sp[0x38],r9
8000903a:	50 b9       	stdsp	sp[0x2c],r9
8000903c:	12 97       	mov	r7,r9
8000903e:	0a 94       	mov	r4,r5
80009040:	40 a2       	lddsp	r2,sp[0x28]
80009042:	32 5a       	mov	r10,37
80009044:	30 08       	mov	r8,0
80009046:	c0 28       	rjmp	8000904a <_vfprintf_r+0x126>
80009048:	2f f2       	sub	r2,-1
8000904a:	05 89       	ld.ub	r9,r2[0x0]
8000904c:	f0 09 18 00 	cp.b	r9,r8
80009050:	5f 1b       	srne	r11
80009052:	f4 09 18 00 	cp.b	r9,r10
80009056:	5f 19       	srne	r9
80009058:	f3 eb 00 0b 	and	r11,r9,r11
8000905c:	f0 0b 18 00 	cp.b	r11,r8
80009060:	cf 41       	brne	80009048 <_vfprintf_r+0x124>
80009062:	40 ab       	lddsp	r11,sp[0x28]
80009064:	e4 0b 01 06 	sub	r6,r2,r11
80009068:	c1 e0       	breq	800090a4 <_vfprintf_r+0x180>
8000906a:	fa f8 06 90 	ld.w	r8,sp[1680]
8000906e:	0c 08       	add	r8,r6
80009070:	87 0b       	st.w	r3[0x0],r11
80009072:	fb 48 06 90 	st.w	sp[1680],r8
80009076:	87 16       	st.w	r3[0x4],r6
80009078:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000907c:	2f f8       	sub	r8,-1
8000907e:	fb 48 06 8c 	st.w	sp[1676],r8
80009082:	58 78       	cp.w	r8,7
80009084:	e0 89 00 04 	brgt	8000908c <_vfprintf_r+0x168>
80009088:	2f 83       	sub	r3,-8
8000908a:	c0 a8       	rjmp	8000909e <_vfprintf_r+0x17a>
8000908c:	fa ca f9 78 	sub	r10,sp,-1672
80009090:	02 9b       	mov	r11,r1
80009092:	08 9c       	mov	r12,r4
80009094:	c3 af       	rcall	80008f08 <__sprint_r>
80009096:	e0 81 0e c6 	brne	8000ae22 <_vfprintf_r+0x1efe>
8000909a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000909e:	40 ba       	lddsp	r10,sp[0x2c]
800090a0:	0c 0a       	add	r10,r6
800090a2:	50 ba       	stdsp	sp[0x2c],r10
800090a4:	05 89       	ld.ub	r9,r2[0x0]
800090a6:	30 08       	mov	r8,0
800090a8:	f0 09 18 00 	cp.b	r9,r8
800090ac:	e0 80 0e aa 	breq	8000ae00 <_vfprintf_r+0x1edc>
800090b0:	30 09       	mov	r9,0
800090b2:	fb 68 06 bb 	st.b	sp[1723],r8
800090b6:	0e 96       	mov	r6,r7
800090b8:	e4 c8 ff ff 	sub	r8,r2,-1
800090bc:	3f fe       	mov	lr,-1
800090be:	50 93       	stdsp	sp[0x24],r3
800090c0:	50 41       	stdsp	sp[0x10],r1
800090c2:	0e 93       	mov	r3,r7
800090c4:	04 91       	mov	r1,r2
800090c6:	50 89       	stdsp	sp[0x20],r9
800090c8:	50 a8       	stdsp	sp[0x28],r8
800090ca:	50 2e       	stdsp	sp[0x8],lr
800090cc:	50 39       	stdsp	sp[0xc],r9
800090ce:	12 95       	mov	r5,r9
800090d0:	12 90       	mov	r0,r9
800090d2:	10 97       	mov	r7,r8
800090d4:	08 92       	mov	r2,r4
800090d6:	c0 78       	rjmp	800090e4 <_vfprintf_r+0x1c0>
800090d8:	3f fc       	mov	r12,-1
800090da:	08 97       	mov	r7,r4
800090dc:	50 2c       	stdsp	sp[0x8],r12
800090de:	c0 38       	rjmp	800090e4 <_vfprintf_r+0x1c0>
800090e0:	30 0b       	mov	r11,0
800090e2:	50 3b       	stdsp	sp[0xc],r11
800090e4:	0f 38       	ld.ub	r8,r7++
800090e6:	c0 28       	rjmp	800090ea <_vfprintf_r+0x1c6>
800090e8:	12 90       	mov	r0,r9
800090ea:	f0 c9 00 20 	sub	r9,r8,32
800090ee:	e0 49 00 58 	cp.w	r9,88
800090f2:	e0 8b 0a 30 	brhi	8000a552 <_vfprintf_r+0x162e>
800090f6:	fe ca a1 f2 	sub	r10,pc,-24078
800090fa:	f4 09 03 2f 	ld.w	pc,r10[r9<<0x2]
800090fe:	50 a7       	stdsp	sp[0x28],r7
80009100:	50 80       	stdsp	sp[0x20],r0
80009102:	0c 97       	mov	r7,r6
80009104:	04 94       	mov	r4,r2
80009106:	06 96       	mov	r6,r3
80009108:	02 92       	mov	r2,r1
8000910a:	fe c9 9f ca 	sub	r9,pc,-24630
8000910e:	40 93       	lddsp	r3,sp[0x24]
80009110:	10 90       	mov	r0,r8
80009112:	40 41       	lddsp	r1,sp[0x10]
80009114:	50 d9       	stdsp	sp[0x34],r9
80009116:	e0 8f 08 8e 	bral	8000a232 <_vfprintf_r+0x130e>
8000911a:	30 08       	mov	r8,0
8000911c:	fb 39 06 bb 	ld.ub	r9,sp[1723]
80009120:	f0 09 18 00 	cp.b	r9,r8
80009124:	ce 01       	brne	800090e4 <_vfprintf_r+0x1c0>
80009126:	32 08       	mov	r8,32
80009128:	c6 e8       	rjmp	80009204 <_vfprintf_r+0x2e0>
8000912a:	a1 a5       	sbr	r5,0x0
8000912c:	cd cb       	rjmp	800090e4 <_vfprintf_r+0x1c0>
8000912e:	0f 89       	ld.ub	r9,r7[0x0]
80009130:	f2 c8 00 30 	sub	r8,r9,48
80009134:	58 98       	cp.w	r8,9
80009136:	e0 8b 00 1d 	brhi	80009170 <_vfprintf_r+0x24c>
8000913a:	ee c8 ff ff 	sub	r8,r7,-1
8000913e:	30 0b       	mov	r11,0
80009140:	23 09       	sub	r9,48
80009142:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
80009146:	f2 0b 00 1b 	add	r11,r9,r11<<0x1
8000914a:	11 39       	ld.ub	r9,r8++
8000914c:	f2 ca 00 30 	sub	r10,r9,48
80009150:	58 9a       	cp.w	r10,9
80009152:	fe 98 ff f7 	brls	80009140 <_vfprintf_r+0x21c>
80009156:	e0 49 00 24 	cp.w	r9,36
8000915a:	cc 31       	brne	800090e0 <_vfprintf_r+0x1bc>
8000915c:	e0 4b 00 20 	cp.w	r11,32
80009160:	e0 89 0e 60 	brgt	8000ae20 <_vfprintf_r+0x1efc>
80009164:	20 1b       	sub	r11,1
80009166:	fa f9 06 b4 	ld.w	r9,sp[1716]
8000916a:	12 3b       	cp.w	r11,r9
8000916c:	c0 95       	brlt	8000917e <_vfprintf_r+0x25a>
8000916e:	c1 08       	rjmp	8000918e <_vfprintf_r+0x26a>
80009170:	fa f9 06 b4 	ld.w	r9,sp[1716]
80009174:	ec ca ff ff 	sub	r10,r6,-1
80009178:	12 36       	cp.w	r6,r9
8000917a:	c1 f5       	brlt	800091b8 <_vfprintf_r+0x294>
8000917c:	c2 68       	rjmp	800091c8 <_vfprintf_r+0x2a4>
8000917e:	fa ce f9 44 	sub	lr,sp,-1724
80009182:	10 97       	mov	r7,r8
80009184:	fc 0b 00 3b 	add	r11,lr,r11<<0x3
80009188:	f6 f0 fd 88 	ld.w	r0,r11[-632]
8000918c:	c3 58       	rjmp	800091f6 <_vfprintf_r+0x2d2>
8000918e:	10 97       	mov	r7,r8
80009190:	fa c8 f9 50 	sub	r8,sp,-1712
80009194:	1a d8       	st.w	--sp,r8
80009196:	fa c8 fa b8 	sub	r8,sp,-1352
8000919a:	1a d8       	st.w	--sp,r8
8000919c:	fa c8 fb b4 	sub	r8,sp,-1100
800091a0:	02 9a       	mov	r10,r1
800091a2:	1a d8       	st.w	--sp,r8
800091a4:	04 9c       	mov	r12,r2
800091a6:	fa c8 f9 40 	sub	r8,sp,-1728
800091aa:	fa c9 ff b4 	sub	r9,sp,-76
800091ae:	fe b0 fd 23 	rcall	80008bf4 <get_arg>
800091b2:	2f dd       	sub	sp,-12
800091b4:	78 00       	ld.w	r0,r12[0x0]
800091b6:	c2 08       	rjmp	800091f6 <_vfprintf_r+0x2d2>
800091b8:	fa cc f9 44 	sub	r12,sp,-1724
800091bc:	14 96       	mov	r6,r10
800091be:	f8 03 00 38 	add	r8,r12,r3<<0x3
800091c2:	f0 f0 fd 88 	ld.w	r0,r8[-632]
800091c6:	c1 88       	rjmp	800091f6 <_vfprintf_r+0x2d2>
800091c8:	41 08       	lddsp	r8,sp[0x40]
800091ca:	59 f9       	cp.w	r9,31
800091cc:	e0 89 00 11 	brgt	800091ee <_vfprintf_r+0x2ca>
800091d0:	f0 cb ff fc 	sub	r11,r8,-4
800091d4:	51 0b       	stdsp	sp[0x40],r11
800091d6:	70 00       	ld.w	r0,r8[0x0]
800091d8:	fa cb f9 44 	sub	r11,sp,-1724
800091dc:	f6 09 00 38 	add	r8,r11,r9<<0x3
800091e0:	f1 40 fd 88 	st.w	r8[-632],r0
800091e4:	2f f9       	sub	r9,-1
800091e6:	14 96       	mov	r6,r10
800091e8:	fb 49 06 b4 	st.w	sp[1716],r9
800091ec:	c0 58       	rjmp	800091f6 <_vfprintf_r+0x2d2>
800091ee:	70 00       	ld.w	r0,r8[0x0]
800091f0:	14 96       	mov	r6,r10
800091f2:	2f c8       	sub	r8,-4
800091f4:	51 08       	stdsp	sp[0x40],r8
800091f6:	58 00       	cp.w	r0,0
800091f8:	fe 94 ff 76 	brge	800090e4 <_vfprintf_r+0x1c0>
800091fc:	5c 30       	neg	r0
800091fe:	a3 a5       	sbr	r5,0x2
80009200:	c7 2b       	rjmp	800090e4 <_vfprintf_r+0x1c0>
80009202:	32 b8       	mov	r8,43
80009204:	fb 68 06 bb 	st.b	sp[1723],r8
80009208:	c6 eb       	rjmp	800090e4 <_vfprintf_r+0x1c0>
8000920a:	0f 38       	ld.ub	r8,r7++
8000920c:	e0 48 00 2a 	cp.w	r8,42
80009210:	c0 30       	breq	80009216 <_vfprintf_r+0x2f2>
80009212:	30 09       	mov	r9,0
80009214:	c7 98       	rjmp	80009306 <_vfprintf_r+0x3e2>
80009216:	0f 88       	ld.ub	r8,r7[0x0]
80009218:	f0 c9 00 30 	sub	r9,r8,48
8000921c:	58 99       	cp.w	r9,9
8000921e:	e0 8b 00 1f 	brhi	8000925c <_vfprintf_r+0x338>
80009222:	ee c4 ff ff 	sub	r4,r7,-1
80009226:	30 0b       	mov	r11,0
80009228:	23 08       	sub	r8,48
8000922a:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
8000922e:	f0 0b 00 1b 	add	r11,r8,r11<<0x1
80009232:	09 38       	ld.ub	r8,r4++
80009234:	f0 c9 00 30 	sub	r9,r8,48
80009238:	58 99       	cp.w	r9,9
8000923a:	fe 98 ff f7 	brls	80009228 <_vfprintf_r+0x304>
8000923e:	e0 48 00 24 	cp.w	r8,36
80009242:	fe 91 ff 4f 	brne	800090e0 <_vfprintf_r+0x1bc>
80009246:	e0 4b 00 20 	cp.w	r11,32
8000924a:	e0 89 0d eb 	brgt	8000ae20 <_vfprintf_r+0x1efc>
8000924e:	20 1b       	sub	r11,1
80009250:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009254:	10 3b       	cp.w	r11,r8
80009256:	c0 a5       	brlt	8000926a <_vfprintf_r+0x346>
80009258:	c1 18       	rjmp	8000927a <_vfprintf_r+0x356>
8000925a:	d7 03       	nop
8000925c:	fa fa 06 b4 	ld.w	r10,sp[1716]
80009260:	ec c9 ff ff 	sub	r9,r6,-1
80009264:	14 36       	cp.w	r6,r10
80009266:	c1 f5       	brlt	800092a4 <_vfprintf_r+0x380>
80009268:	c2 88       	rjmp	800092b8 <_vfprintf_r+0x394>
8000926a:	fa ca f9 44 	sub	r10,sp,-1724
8000926e:	f4 0b 00 3b 	add	r11,r10,r11<<0x3
80009272:	f6 fb fd 88 	ld.w	r11,r11[-632]
80009276:	50 2b       	stdsp	sp[0x8],r11
80009278:	c3 c8       	rjmp	800092f0 <_vfprintf_r+0x3cc>
8000927a:	fa c8 f9 50 	sub	r8,sp,-1712
8000927e:	1a d8       	st.w	--sp,r8
80009280:	fa c8 fa b8 	sub	r8,sp,-1352
80009284:	1a d8       	st.w	--sp,r8
80009286:	fa c8 fb b4 	sub	r8,sp,-1100
8000928a:	02 9a       	mov	r10,r1
8000928c:	1a d8       	st.w	--sp,r8
8000928e:	04 9c       	mov	r12,r2
80009290:	fa c8 f9 40 	sub	r8,sp,-1728
80009294:	fa c9 ff b4 	sub	r9,sp,-76
80009298:	fe b0 fc ae 	rcall	80008bf4 <get_arg>
8000929c:	2f dd       	sub	sp,-12
8000929e:	78 0c       	ld.w	r12,r12[0x0]
800092a0:	50 2c       	stdsp	sp[0x8],r12
800092a2:	c2 78       	rjmp	800092f0 <_vfprintf_r+0x3cc>
800092a4:	12 96       	mov	r6,r9
800092a6:	0e 94       	mov	r4,r7
800092a8:	fa c9 f9 44 	sub	r9,sp,-1724
800092ac:	f2 03 00 38 	add	r8,r9,r3<<0x3
800092b0:	f0 f8 fd 88 	ld.w	r8,r8[-632]
800092b4:	50 28       	stdsp	sp[0x8],r8
800092b6:	c1 d8       	rjmp	800092f0 <_vfprintf_r+0x3cc>
800092b8:	41 08       	lddsp	r8,sp[0x40]
800092ba:	59 fa       	cp.w	r10,31
800092bc:	e0 89 00 14 	brgt	800092e4 <_vfprintf_r+0x3c0>
800092c0:	f0 cb ff fc 	sub	r11,r8,-4
800092c4:	70 08       	ld.w	r8,r8[0x0]
800092c6:	51 0b       	stdsp	sp[0x40],r11
800092c8:	50 28       	stdsp	sp[0x8],r8
800092ca:	fa c6 f9 44 	sub	r6,sp,-1724
800092ce:	40 2e       	lddsp	lr,sp[0x8]
800092d0:	ec 0a 00 38 	add	r8,r6,r10<<0x3
800092d4:	f1 4e fd 88 	st.w	r8[-632],lr
800092d8:	2f fa       	sub	r10,-1
800092da:	0e 94       	mov	r4,r7
800092dc:	fb 4a 06 b4 	st.w	sp[1716],r10
800092e0:	12 96       	mov	r6,r9
800092e2:	c0 78       	rjmp	800092f0 <_vfprintf_r+0x3cc>
800092e4:	70 0c       	ld.w	r12,r8[0x0]
800092e6:	0e 94       	mov	r4,r7
800092e8:	2f c8       	sub	r8,-4
800092ea:	50 2c       	stdsp	sp[0x8],r12
800092ec:	12 96       	mov	r6,r9
800092ee:	51 08       	stdsp	sp[0x40],r8
800092f0:	40 2b       	lddsp	r11,sp[0x8]
800092f2:	58 0b       	cp.w	r11,0
800092f4:	fe 95 fe f2 	brlt	800090d8 <_vfprintf_r+0x1b4>
800092f8:	08 97       	mov	r7,r4
800092fa:	cf 5a       	rjmp	800090e4 <_vfprintf_r+0x1c0>
800092fc:	f2 09 00 29 	add	r9,r9,r9<<0x2
80009300:	0f 38       	ld.ub	r8,r7++
80009302:	f4 09 00 19 	add	r9,r10,r9<<0x1
80009306:	f0 ca 00 30 	sub	r10,r8,48
8000930a:	58 9a       	cp.w	r10,9
8000930c:	fe 98 ff f8 	brls	800092fc <_vfprintf_r+0x3d8>
80009310:	3f fa       	mov	r10,-1
80009312:	f2 0a 0c 49 	max	r9,r9,r10
80009316:	50 29       	stdsp	sp[0x8],r9
80009318:	ce 9a       	rjmp	800090ea <_vfprintf_r+0x1c6>
8000931a:	a7 b5       	sbr	r5,0x7
8000931c:	ce 4a       	rjmp	800090e4 <_vfprintf_r+0x1c0>
8000931e:	30 09       	mov	r9,0
80009320:	23 08       	sub	r8,48
80009322:	f2 09 00 29 	add	r9,r9,r9<<0x2
80009326:	f0 09 00 19 	add	r9,r8,r9<<0x1
8000932a:	0f 38       	ld.ub	r8,r7++
8000932c:	f0 ca 00 30 	sub	r10,r8,48
80009330:	58 9a       	cp.w	r10,9
80009332:	fe 98 ff f7 	brls	80009320 <_vfprintf_r+0x3fc>
80009336:	e0 48 00 24 	cp.w	r8,36
8000933a:	fe 91 fe d7 	brne	800090e8 <_vfprintf_r+0x1c4>
8000933e:	e0 49 00 20 	cp.w	r9,32
80009342:	e0 89 0d 6f 	brgt	8000ae20 <_vfprintf_r+0x1efc>
80009346:	f2 c3 00 01 	sub	r3,r9,1
8000934a:	30 19       	mov	r9,1
8000934c:	50 39       	stdsp	sp[0xc],r9
8000934e:	cc ba       	rjmp	800090e4 <_vfprintf_r+0x1c0>
80009350:	a3 b5       	sbr	r5,0x3
80009352:	cc 9a       	rjmp	800090e4 <_vfprintf_r+0x1c0>
80009354:	a7 a5       	sbr	r5,0x6
80009356:	cc 7a       	rjmp	800090e4 <_vfprintf_r+0x1c0>
80009358:	0a 98       	mov	r8,r5
8000935a:	a5 b5       	sbr	r5,0x5
8000935c:	a5 a8       	sbr	r8,0x4
8000935e:	0f 89       	ld.ub	r9,r7[0x0]
80009360:	36 ce       	mov	lr,108
80009362:	fc 09 18 00 	cp.b	r9,lr
80009366:	f7 b7 00 ff 	subeq	r7,-1
8000936a:	f0 05 17 10 	movne	r5,r8
8000936e:	cb ba       	rjmp	800090e4 <_vfprintf_r+0x1c0>
80009370:	a5 b5       	sbr	r5,0x5
80009372:	cb 9a       	rjmp	800090e4 <_vfprintf_r+0x1c0>
80009374:	50 a7       	stdsp	sp[0x28],r7
80009376:	50 80       	stdsp	sp[0x20],r0
80009378:	0c 97       	mov	r7,r6
8000937a:	10 90       	mov	r0,r8
8000937c:	06 96       	mov	r6,r3
8000937e:	04 94       	mov	r4,r2
80009380:	40 93       	lddsp	r3,sp[0x24]
80009382:	02 92       	mov	r2,r1
80009384:	0e 99       	mov	r9,r7
80009386:	40 41       	lddsp	r1,sp[0x10]
80009388:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000938c:	40 3c       	lddsp	r12,sp[0xc]
8000938e:	58 0c       	cp.w	r12,0
80009390:	c1 d0       	breq	800093ca <_vfprintf_r+0x4a6>
80009392:	10 36       	cp.w	r6,r8
80009394:	c0 64       	brge	800093a0 <_vfprintf_r+0x47c>
80009396:	fa cb f9 44 	sub	r11,sp,-1724
8000939a:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000939e:	c1 d8       	rjmp	800093d8 <_vfprintf_r+0x4b4>
800093a0:	fa c8 f9 50 	sub	r8,sp,-1712
800093a4:	1a d8       	st.w	--sp,r8
800093a6:	fa c8 fa b8 	sub	r8,sp,-1352
800093aa:	1a d8       	st.w	--sp,r8
800093ac:	fa c8 fb b4 	sub	r8,sp,-1100
800093b0:	1a d8       	st.w	--sp,r8
800093b2:	fa c8 f9 40 	sub	r8,sp,-1728
800093b6:	fa c9 ff b4 	sub	r9,sp,-76
800093ba:	04 9a       	mov	r10,r2
800093bc:	0c 9b       	mov	r11,r6
800093be:	08 9c       	mov	r12,r4
800093c0:	fe b0 fc 1a 	rcall	80008bf4 <get_arg>
800093c4:	2f dd       	sub	sp,-12
800093c6:	19 b8       	ld.ub	r8,r12[0x3]
800093c8:	c2 28       	rjmp	8000940c <_vfprintf_r+0x4e8>
800093ca:	2f f7       	sub	r7,-1
800093cc:	10 39       	cp.w	r9,r8
800093ce:	c0 84       	brge	800093de <_vfprintf_r+0x4ba>
800093d0:	fa ca f9 44 	sub	r10,sp,-1724
800093d4:	f4 06 00 36 	add	r6,r10,r6<<0x3
800093d8:	ed 38 fd 8b 	ld.ub	r8,r6[-629]
800093dc:	c1 88       	rjmp	8000940c <_vfprintf_r+0x4e8>
800093de:	41 09       	lddsp	r9,sp[0x40]
800093e0:	59 f8       	cp.w	r8,31
800093e2:	e0 89 00 12 	brgt	80009406 <_vfprintf_r+0x4e2>
800093e6:	f2 ca ff fc 	sub	r10,r9,-4
800093ea:	51 0a       	stdsp	sp[0x40],r10
800093ec:	72 09       	ld.w	r9,r9[0x0]
800093ee:	fa c6 f9 44 	sub	r6,sp,-1724
800093f2:	ec 08 00 3a 	add	r10,r6,r8<<0x3
800093f6:	2f f8       	sub	r8,-1
800093f8:	f5 49 fd 88 	st.w	r10[-632],r9
800093fc:	fb 48 06 b4 	st.w	sp[1716],r8
80009400:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
80009404:	c0 48       	rjmp	8000940c <_vfprintf_r+0x4e8>
80009406:	13 b8       	ld.ub	r8,r9[0x3]
80009408:	2f c9       	sub	r9,-4
8000940a:	51 09       	stdsp	sp[0x40],r9
8000940c:	fb 68 06 60 	st.b	sp[1632],r8
80009410:	30 0e       	mov	lr,0
80009412:	30 08       	mov	r8,0
80009414:	30 12       	mov	r2,1
80009416:	fb 68 06 bb 	st.b	sp[1723],r8
8000941a:	50 2e       	stdsp	sp[0x8],lr
8000941c:	e0 8f 08 ad 	bral	8000a576 <_vfprintf_r+0x1652>
80009420:	50 a7       	stdsp	sp[0x28],r7
80009422:	50 80       	stdsp	sp[0x20],r0
80009424:	0c 97       	mov	r7,r6
80009426:	04 94       	mov	r4,r2
80009428:	06 96       	mov	r6,r3
8000942a:	02 92       	mov	r2,r1
8000942c:	40 93       	lddsp	r3,sp[0x24]
8000942e:	10 90       	mov	r0,r8
80009430:	40 41       	lddsp	r1,sp[0x10]
80009432:	a5 a5       	sbr	r5,0x4
80009434:	c0 a8       	rjmp	80009448 <_vfprintf_r+0x524>
80009436:	50 a7       	stdsp	sp[0x28],r7
80009438:	50 80       	stdsp	sp[0x20],r0
8000943a:	0c 97       	mov	r7,r6
8000943c:	04 94       	mov	r4,r2
8000943e:	06 96       	mov	r6,r3
80009440:	02 92       	mov	r2,r1
80009442:	40 93       	lddsp	r3,sp[0x24]
80009444:	10 90       	mov	r0,r8
80009446:	40 41       	lddsp	r1,sp[0x10]
80009448:	ed b5 00 05 	bld	r5,0x5
8000944c:	c5 11       	brne	800094ee <_vfprintf_r+0x5ca>
8000944e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009452:	40 3c       	lddsp	r12,sp[0xc]
80009454:	58 0c       	cp.w	r12,0
80009456:	c1 e0       	breq	80009492 <_vfprintf_r+0x56e>
80009458:	10 36       	cp.w	r6,r8
8000945a:	c0 64       	brge	80009466 <_vfprintf_r+0x542>
8000945c:	fa cb f9 44 	sub	r11,sp,-1724
80009460:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009464:	c2 08       	rjmp	800094a4 <_vfprintf_r+0x580>
80009466:	fa c8 f9 50 	sub	r8,sp,-1712
8000946a:	1a d8       	st.w	--sp,r8
8000946c:	fa c8 fa b8 	sub	r8,sp,-1352
80009470:	0c 9b       	mov	r11,r6
80009472:	1a d8       	st.w	--sp,r8
80009474:	fa c8 fb b4 	sub	r8,sp,-1100
80009478:	1a d8       	st.w	--sp,r8
8000947a:	fa c9 ff b4 	sub	r9,sp,-76
8000947e:	fa c8 f9 40 	sub	r8,sp,-1728
80009482:	04 9a       	mov	r10,r2
80009484:	08 9c       	mov	r12,r4
80009486:	fe b0 fb b7 	rcall	80008bf4 <get_arg>
8000948a:	2f dd       	sub	sp,-12
8000948c:	78 1b       	ld.w	r11,r12[0x4]
8000948e:	78 09       	ld.w	r9,r12[0x0]
80009490:	c2 b8       	rjmp	800094e6 <_vfprintf_r+0x5c2>
80009492:	ee ca ff ff 	sub	r10,r7,-1
80009496:	10 37       	cp.w	r7,r8
80009498:	c0 b4       	brge	800094ae <_vfprintf_r+0x58a>
8000949a:	fa c9 f9 44 	sub	r9,sp,-1724
8000949e:	14 97       	mov	r7,r10
800094a0:	f2 06 00 36 	add	r6,r9,r6<<0x3
800094a4:	ec fb fd 8c 	ld.w	r11,r6[-628]
800094a8:	ec f9 fd 88 	ld.w	r9,r6[-632]
800094ac:	c1 d8       	rjmp	800094e6 <_vfprintf_r+0x5c2>
800094ae:	41 09       	lddsp	r9,sp[0x40]
800094b0:	59 f8       	cp.w	r8,31
800094b2:	e0 89 00 14 	brgt	800094da <_vfprintf_r+0x5b6>
800094b6:	f2 cb ff f8 	sub	r11,r9,-8
800094ba:	51 0b       	stdsp	sp[0x40],r11
800094bc:	fa c6 f9 44 	sub	r6,sp,-1724
800094c0:	72 1b       	ld.w	r11,r9[0x4]
800094c2:	ec 08 00 3c 	add	r12,r6,r8<<0x3
800094c6:	72 09       	ld.w	r9,r9[0x0]
800094c8:	f9 4b fd 8c 	st.w	r12[-628],r11
800094cc:	f9 49 fd 88 	st.w	r12[-632],r9
800094d0:	2f f8       	sub	r8,-1
800094d2:	14 97       	mov	r7,r10
800094d4:	fb 48 06 b4 	st.w	sp[1716],r8
800094d8:	c0 78       	rjmp	800094e6 <_vfprintf_r+0x5c2>
800094da:	f2 c8 ff f8 	sub	r8,r9,-8
800094de:	72 1b       	ld.w	r11,r9[0x4]
800094e0:	14 97       	mov	r7,r10
800094e2:	51 08       	stdsp	sp[0x40],r8
800094e4:	72 09       	ld.w	r9,r9[0x0]
800094e6:	16 98       	mov	r8,r11
800094e8:	fa e9 00 00 	st.d	sp[0],r8
800094ec:	ca e8       	rjmp	80009648 <_vfprintf_r+0x724>
800094ee:	ed b5 00 04 	bld	r5,0x4
800094f2:	c1 71       	brne	80009520 <_vfprintf_r+0x5fc>
800094f4:	fa f8 06 b4 	ld.w	r8,sp[1716]
800094f8:	40 3e       	lddsp	lr,sp[0xc]
800094fa:	58 0e       	cp.w	lr,0
800094fc:	c0 80       	breq	8000950c <_vfprintf_r+0x5e8>
800094fe:	10 36       	cp.w	r6,r8
80009500:	c6 94       	brge	800095d2 <_vfprintf_r+0x6ae>
80009502:	fa cc f9 44 	sub	r12,sp,-1724
80009506:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000950a:	c8 28       	rjmp	8000960e <_vfprintf_r+0x6ea>
8000950c:	ee ca ff ff 	sub	r10,r7,-1
80009510:	10 37       	cp.w	r7,r8
80009512:	e0 84 00 81 	brge	80009614 <_vfprintf_r+0x6f0>
80009516:	fa cb f9 44 	sub	r11,sp,-1724
8000951a:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000951e:	c7 78       	rjmp	8000960c <_vfprintf_r+0x6e8>
80009520:	ed b5 00 06 	bld	r5,0x6
80009524:	c4 b1       	brne	800095ba <_vfprintf_r+0x696>
80009526:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000952a:	40 3c       	lddsp	r12,sp[0xc]
8000952c:	58 0c       	cp.w	r12,0
8000952e:	c1 d0       	breq	80009568 <_vfprintf_r+0x644>
80009530:	10 36       	cp.w	r6,r8
80009532:	c0 64       	brge	8000953e <_vfprintf_r+0x61a>
80009534:	fa cb f9 44 	sub	r11,sp,-1724
80009538:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000953c:	c1 f8       	rjmp	8000957a <_vfprintf_r+0x656>
8000953e:	fa c8 f9 50 	sub	r8,sp,-1712
80009542:	1a d8       	st.w	--sp,r8
80009544:	fa c8 fa b8 	sub	r8,sp,-1352
80009548:	1a d8       	st.w	--sp,r8
8000954a:	fa c8 fb b4 	sub	r8,sp,-1100
8000954e:	1a d8       	st.w	--sp,r8
80009550:	fa c8 f9 40 	sub	r8,sp,-1728
80009554:	fa c9 ff b4 	sub	r9,sp,-76
80009558:	04 9a       	mov	r10,r2
8000955a:	0c 9b       	mov	r11,r6
8000955c:	08 9c       	mov	r12,r4
8000955e:	fe b0 fb 4b 	rcall	80008bf4 <get_arg>
80009562:	2f dd       	sub	sp,-12
80009564:	98 18       	ld.sh	r8,r12[0x2]
80009566:	c2 68       	rjmp	800095b2 <_vfprintf_r+0x68e>
80009568:	ee ca ff ff 	sub	r10,r7,-1
8000956c:	10 37       	cp.w	r7,r8
8000956e:	c0 94       	brge	80009580 <_vfprintf_r+0x65c>
80009570:	fa c9 f9 44 	sub	r9,sp,-1724
80009574:	14 97       	mov	r7,r10
80009576:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000957a:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000957e:	c1 a8       	rjmp	800095b2 <_vfprintf_r+0x68e>
80009580:	41 09       	lddsp	r9,sp[0x40]
80009582:	59 f8       	cp.w	r8,31
80009584:	e0 89 00 13 	brgt	800095aa <_vfprintf_r+0x686>
80009588:	f2 cb ff fc 	sub	r11,r9,-4
8000958c:	51 0b       	stdsp	sp[0x40],r11
8000958e:	72 09       	ld.w	r9,r9[0x0]
80009590:	fa c6 f9 44 	sub	r6,sp,-1724
80009594:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80009598:	2f f8       	sub	r8,-1
8000959a:	f7 49 fd 88 	st.w	r11[-632],r9
8000959e:	fb 48 06 b4 	st.w	sp[1716],r8
800095a2:	14 97       	mov	r7,r10
800095a4:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
800095a8:	c0 58       	rjmp	800095b2 <_vfprintf_r+0x68e>
800095aa:	92 18       	ld.sh	r8,r9[0x2]
800095ac:	14 97       	mov	r7,r10
800095ae:	2f c9       	sub	r9,-4
800095b0:	51 09       	stdsp	sp[0x40],r9
800095b2:	50 18       	stdsp	sp[0x4],r8
800095b4:	bf 58       	asr	r8,0x1f
800095b6:	50 08       	stdsp	sp[0x0],r8
800095b8:	c4 88       	rjmp	80009648 <_vfprintf_r+0x724>
800095ba:	fa f8 06 b4 	ld.w	r8,sp[1716]
800095be:	40 3c       	lddsp	r12,sp[0xc]
800095c0:	58 0c       	cp.w	r12,0
800095c2:	c1 d0       	breq	800095fc <_vfprintf_r+0x6d8>
800095c4:	10 36       	cp.w	r6,r8
800095c6:	c0 64       	brge	800095d2 <_vfprintf_r+0x6ae>
800095c8:	fa cb f9 44 	sub	r11,sp,-1724
800095cc:	f6 06 00 36 	add	r6,r11,r6<<0x3
800095d0:	c1 f8       	rjmp	8000960e <_vfprintf_r+0x6ea>
800095d2:	fa c8 f9 50 	sub	r8,sp,-1712
800095d6:	1a d8       	st.w	--sp,r8
800095d8:	fa c8 fa b8 	sub	r8,sp,-1352
800095dc:	0c 9b       	mov	r11,r6
800095de:	1a d8       	st.w	--sp,r8
800095e0:	fa c8 fb b4 	sub	r8,sp,-1100
800095e4:	04 9a       	mov	r10,r2
800095e6:	1a d8       	st.w	--sp,r8
800095e8:	08 9c       	mov	r12,r4
800095ea:	fa c8 f9 40 	sub	r8,sp,-1728
800095ee:	fa c9 ff b4 	sub	r9,sp,-76
800095f2:	fe b0 fb 01 	rcall	80008bf4 <get_arg>
800095f6:	2f dd       	sub	sp,-12
800095f8:	78 0b       	ld.w	r11,r12[0x0]
800095fa:	c2 48       	rjmp	80009642 <_vfprintf_r+0x71e>
800095fc:	ee ca ff ff 	sub	r10,r7,-1
80009600:	10 37       	cp.w	r7,r8
80009602:	c0 94       	brge	80009614 <_vfprintf_r+0x6f0>
80009604:	fa c9 f9 44 	sub	r9,sp,-1724
80009608:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000960c:	14 97       	mov	r7,r10
8000960e:	ec fb fd 88 	ld.w	r11,r6[-632]
80009612:	c1 88       	rjmp	80009642 <_vfprintf_r+0x71e>
80009614:	41 09       	lddsp	r9,sp[0x40]
80009616:	59 f8       	cp.w	r8,31
80009618:	e0 89 00 11 	brgt	8000963a <_vfprintf_r+0x716>
8000961c:	f2 cb ff fc 	sub	r11,r9,-4
80009620:	51 0b       	stdsp	sp[0x40],r11
80009622:	fa c6 f9 44 	sub	r6,sp,-1724
80009626:	72 0b       	ld.w	r11,r9[0x0]
80009628:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000962c:	f3 4b fd 88 	st.w	r9[-632],r11
80009630:	2f f8       	sub	r8,-1
80009632:	14 97       	mov	r7,r10
80009634:	fb 48 06 b4 	st.w	sp[1716],r8
80009638:	c0 58       	rjmp	80009642 <_vfprintf_r+0x71e>
8000963a:	72 0b       	ld.w	r11,r9[0x0]
8000963c:	14 97       	mov	r7,r10
8000963e:	2f c9       	sub	r9,-4
80009640:	51 09       	stdsp	sp[0x40],r9
80009642:	50 1b       	stdsp	sp[0x4],r11
80009644:	bf 5b       	asr	r11,0x1f
80009646:	50 0b       	stdsp	sp[0x0],r11
80009648:	fa ea 00 00 	ld.d	r10,sp[0]
8000964c:	58 0a       	cp.w	r10,0
8000964e:	5c 2b       	cpc	r11
80009650:	c0 e4       	brge	8000966c <_vfprintf_r+0x748>
80009652:	30 08       	mov	r8,0
80009654:	fa ea 00 00 	ld.d	r10,sp[0]
80009658:	30 09       	mov	r9,0
8000965a:	f0 0a 01 0a 	sub	r10,r8,r10
8000965e:	f2 0b 01 4b 	sbc	r11,r9,r11
80009662:	32 d8       	mov	r8,45
80009664:	fa eb 00 00 	st.d	sp[0],r10
80009668:	fb 68 06 bb 	st.b	sp[1723],r8
8000966c:	30 18       	mov	r8,1
8000966e:	e0 8f 06 fa 	bral	8000a462 <_vfprintf_r+0x153e>
80009672:	50 a7       	stdsp	sp[0x28],r7
80009674:	50 80       	stdsp	sp[0x20],r0
80009676:	0c 97       	mov	r7,r6
80009678:	04 94       	mov	r4,r2
8000967a:	06 96       	mov	r6,r3
8000967c:	02 92       	mov	r2,r1
8000967e:	40 93       	lddsp	r3,sp[0x24]
80009680:	10 90       	mov	r0,r8
80009682:	40 41       	lddsp	r1,sp[0x10]
80009684:	0e 99       	mov	r9,r7
80009686:	ed b5 00 03 	bld	r5,0x3
8000968a:	c4 11       	brne	8000970c <_vfprintf_r+0x7e8>
8000968c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009690:	40 3a       	lddsp	r10,sp[0xc]
80009692:	58 0a       	cp.w	r10,0
80009694:	c1 90       	breq	800096c6 <_vfprintf_r+0x7a2>
80009696:	10 36       	cp.w	r6,r8
80009698:	c6 45       	brlt	80009760 <_vfprintf_r+0x83c>
8000969a:	fa c8 f9 50 	sub	r8,sp,-1712
8000969e:	1a d8       	st.w	--sp,r8
800096a0:	fa c8 fa b8 	sub	r8,sp,-1352
800096a4:	1a d8       	st.w	--sp,r8
800096a6:	fa c8 fb b4 	sub	r8,sp,-1100
800096aa:	0c 9b       	mov	r11,r6
800096ac:	1a d8       	st.w	--sp,r8
800096ae:	04 9a       	mov	r10,r2
800096b0:	fa c8 f9 40 	sub	r8,sp,-1728
800096b4:	fa c9 ff b4 	sub	r9,sp,-76
800096b8:	08 9c       	mov	r12,r4
800096ba:	fe b0 fa 9d 	rcall	80008bf4 <get_arg>
800096be:	2f dd       	sub	sp,-12
800096c0:	78 16       	ld.w	r6,r12[0x4]
800096c2:	50 76       	stdsp	sp[0x1c],r6
800096c4:	c4 88       	rjmp	80009754 <_vfprintf_r+0x830>
800096c6:	2f f7       	sub	r7,-1
800096c8:	10 39       	cp.w	r9,r8
800096ca:	c0 c4       	brge	800096e2 <_vfprintf_r+0x7be>
800096cc:	fa ce f9 44 	sub	lr,sp,-1724
800096d0:	fc 06 00 36 	add	r6,lr,r6<<0x3
800096d4:	ec fc fd 8c 	ld.w	r12,r6[-628]
800096d8:	50 7c       	stdsp	sp[0x1c],r12
800096da:	ec f6 fd 88 	ld.w	r6,r6[-632]
800096de:	50 56       	stdsp	sp[0x14],r6
800096e0:	c6 68       	rjmp	800097ac <_vfprintf_r+0x888>
800096e2:	41 09       	lddsp	r9,sp[0x40]
800096e4:	59 f8       	cp.w	r8,31
800096e6:	e0 89 00 10 	brgt	80009706 <_vfprintf_r+0x7e2>
800096ea:	f2 ca ff f8 	sub	r10,r9,-8
800096ee:	72 1b       	ld.w	r11,r9[0x4]
800096f0:	51 0a       	stdsp	sp[0x40],r10
800096f2:	72 09       	ld.w	r9,r9[0x0]
800096f4:	fa ca f9 44 	sub	r10,sp,-1724
800096f8:	50 7b       	stdsp	sp[0x1c],r11
800096fa:	50 59       	stdsp	sp[0x14],r9
800096fc:	f4 08 00 39 	add	r9,r10,r8<<0x3
80009700:	40 5b       	lddsp	r11,sp[0x14]
80009702:	40 7a       	lddsp	r10,sp[0x1c]
80009704:	c4 78       	rjmp	80009792 <_vfprintf_r+0x86e>
80009706:	72 18       	ld.w	r8,r9[0x4]
80009708:	50 78       	stdsp	sp[0x1c],r8
8000970a:	c4 c8       	rjmp	800097a2 <_vfprintf_r+0x87e>
8000970c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009710:	40 3e       	lddsp	lr,sp[0xc]
80009712:	58 0e       	cp.w	lr,0
80009714:	c2 30       	breq	8000975a <_vfprintf_r+0x836>
80009716:	10 36       	cp.w	r6,r8
80009718:	c0 94       	brge	8000972a <_vfprintf_r+0x806>
8000971a:	fa cc f9 44 	sub	r12,sp,-1724
8000971e:	f8 06 00 36 	add	r6,r12,r6<<0x3
80009722:	ec fb fd 8c 	ld.w	r11,r6[-628]
80009726:	50 7b       	stdsp	sp[0x1c],r11
80009728:	cd 9b       	rjmp	800096da <_vfprintf_r+0x7b6>
8000972a:	fa c8 f9 50 	sub	r8,sp,-1712
8000972e:	1a d8       	st.w	--sp,r8
80009730:	fa c8 fa b8 	sub	r8,sp,-1352
80009734:	04 9a       	mov	r10,r2
80009736:	1a d8       	st.w	--sp,r8
80009738:	fa c8 fb b4 	sub	r8,sp,-1100
8000973c:	0c 9b       	mov	r11,r6
8000973e:	1a d8       	st.w	--sp,r8
80009740:	08 9c       	mov	r12,r4
80009742:	fa c8 f9 40 	sub	r8,sp,-1728
80009746:	fa c9 ff b4 	sub	r9,sp,-76
8000974a:	fe b0 fa 55 	rcall	80008bf4 <get_arg>
8000974e:	2f dd       	sub	sp,-12
80009750:	78 1a       	ld.w	r10,r12[0x4]
80009752:	50 7a       	stdsp	sp[0x1c],r10
80009754:	78 0c       	ld.w	r12,r12[0x0]
80009756:	50 5c       	stdsp	sp[0x14],r12
80009758:	c2 a8       	rjmp	800097ac <_vfprintf_r+0x888>
8000975a:	2f f7       	sub	r7,-1
8000975c:	10 39       	cp.w	r9,r8
8000975e:	c0 94       	brge	80009770 <_vfprintf_r+0x84c>
80009760:	fa c9 f9 44 	sub	r9,sp,-1724
80009764:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009768:	ec f8 fd 8c 	ld.w	r8,r6[-628]
8000976c:	50 78       	stdsp	sp[0x1c],r8
8000976e:	cb 6b       	rjmp	800096da <_vfprintf_r+0x7b6>
80009770:	41 09       	lddsp	r9,sp[0x40]
80009772:	59 f8       	cp.w	r8,31
80009774:	e0 89 00 15 	brgt	8000979e <_vfprintf_r+0x87a>
80009778:	f2 ca ff f8 	sub	r10,r9,-8
8000977c:	72 16       	ld.w	r6,r9[0x4]
8000977e:	72 09       	ld.w	r9,r9[0x0]
80009780:	51 0a       	stdsp	sp[0x40],r10
80009782:	50 59       	stdsp	sp[0x14],r9
80009784:	fa ce f9 44 	sub	lr,sp,-1724
80009788:	50 76       	stdsp	sp[0x1c],r6
8000978a:	fc 08 00 39 	add	r9,lr,r8<<0x3
8000978e:	40 5b       	lddsp	r11,sp[0x14]
80009790:	0c 9a       	mov	r10,r6
80009792:	f2 eb fd 88 	st.d	r9[-632],r10
80009796:	2f f8       	sub	r8,-1
80009798:	fb 48 06 b4 	st.w	sp[1716],r8
8000979c:	c0 88       	rjmp	800097ac <_vfprintf_r+0x888>
8000979e:	72 1c       	ld.w	r12,r9[0x4]
800097a0:	50 7c       	stdsp	sp[0x1c],r12
800097a2:	f2 c8 ff f8 	sub	r8,r9,-8
800097a6:	51 08       	stdsp	sp[0x40],r8
800097a8:	72 09       	ld.w	r9,r9[0x0]
800097aa:	50 59       	stdsp	sp[0x14],r9
800097ac:	40 5b       	lddsp	r11,sp[0x14]
800097ae:	40 7a       	lddsp	r10,sp[0x1c]
800097b0:	e0 a0 19 54 	rcall	8000ca58 <__isinfd>
800097b4:	18 96       	mov	r6,r12
800097b6:	c1 70       	breq	800097e4 <_vfprintf_r+0x8c0>
800097b8:	30 08       	mov	r8,0
800097ba:	30 09       	mov	r9,0
800097bc:	40 5b       	lddsp	r11,sp[0x14]
800097be:	40 7a       	lddsp	r10,sp[0x1c]
800097c0:	e0 a0 1d b4 	rcall	8000d328 <__avr32_f64_cmp_lt>
800097c4:	c0 40       	breq	800097cc <_vfprintf_r+0x8a8>
800097c6:	32 d8       	mov	r8,45
800097c8:	fb 68 06 bb 	st.b	sp[1723],r8
800097cc:	fe c8 a6 78 	sub	r8,pc,-22920
800097d0:	fe c6 a6 78 	sub	r6,pc,-22920
800097d4:	a7 d5       	cbr	r5,0x7
800097d6:	e0 40 00 47 	cp.w	r0,71
800097da:	f0 06 17 a0 	movle	r6,r8
800097de:	30 32       	mov	r2,3
800097e0:	e0 8f 06 ce 	bral	8000a57c <_vfprintf_r+0x1658>
800097e4:	40 5b       	lddsp	r11,sp[0x14]
800097e6:	40 7a       	lddsp	r10,sp[0x1c]
800097e8:	e0 a0 19 4d 	rcall	8000ca82 <__isnand>
800097ec:	c0 e0       	breq	80009808 <_vfprintf_r+0x8e4>
800097ee:	50 26       	stdsp	sp[0x8],r6
800097f0:	fe c8 a6 94 	sub	r8,pc,-22892
800097f4:	fe c6 a6 94 	sub	r6,pc,-22892
800097f8:	a7 d5       	cbr	r5,0x7
800097fa:	e0 40 00 47 	cp.w	r0,71
800097fe:	f0 06 17 a0 	movle	r6,r8
80009802:	30 32       	mov	r2,3
80009804:	e0 8f 06 c2 	bral	8000a588 <_vfprintf_r+0x1664>
80009808:	40 2a       	lddsp	r10,sp[0x8]
8000980a:	5b fa       	cp.w	r10,-1
8000980c:	c0 41       	brne	80009814 <_vfprintf_r+0x8f0>
8000980e:	30 69       	mov	r9,6
80009810:	50 29       	stdsp	sp[0x8],r9
80009812:	c1 18       	rjmp	80009834 <_vfprintf_r+0x910>
80009814:	e0 40 00 47 	cp.w	r0,71
80009818:	5f 09       	sreq	r9
8000981a:	e0 40 00 67 	cp.w	r0,103
8000981e:	5f 08       	sreq	r8
80009820:	f3 e8 10 08 	or	r8,r9,r8
80009824:	f8 08 18 00 	cp.b	r8,r12
80009828:	c0 60       	breq	80009834 <_vfprintf_r+0x910>
8000982a:	40 28       	lddsp	r8,sp[0x8]
8000982c:	58 08       	cp.w	r8,0
8000982e:	f9 b8 00 01 	moveq	r8,1
80009832:	50 28       	stdsp	sp[0x8],r8
80009834:	40 78       	lddsp	r8,sp[0x1c]
80009836:	40 59       	lddsp	r9,sp[0x14]
80009838:	fa e9 06 94 	st.d	sp[1684],r8
8000983c:	a9 a5       	sbr	r5,0x8
8000983e:	fa f8 06 94 	ld.w	r8,sp[1684]
80009842:	58 08       	cp.w	r8,0
80009844:	c0 65       	brlt	80009850 <_vfprintf_r+0x92c>
80009846:	40 5e       	lddsp	lr,sp[0x14]
80009848:	30 0c       	mov	r12,0
8000984a:	50 6e       	stdsp	sp[0x18],lr
8000984c:	50 9c       	stdsp	sp[0x24],r12
8000984e:	c0 78       	rjmp	8000985c <_vfprintf_r+0x938>
80009850:	40 5b       	lddsp	r11,sp[0x14]
80009852:	32 da       	mov	r10,45
80009854:	ee 1b 80 00 	eorh	r11,0x8000
80009858:	50 9a       	stdsp	sp[0x24],r10
8000985a:	50 6b       	stdsp	sp[0x18],r11
8000985c:	e0 40 00 46 	cp.w	r0,70
80009860:	5f 09       	sreq	r9
80009862:	e0 40 00 66 	cp.w	r0,102
80009866:	5f 08       	sreq	r8
80009868:	f3 e8 10 08 	or	r8,r9,r8
8000986c:	50 48       	stdsp	sp[0x10],r8
8000986e:	c0 40       	breq	80009876 <_vfprintf_r+0x952>
80009870:	40 22       	lddsp	r2,sp[0x8]
80009872:	30 39       	mov	r9,3
80009874:	c1 08       	rjmp	80009894 <_vfprintf_r+0x970>
80009876:	e0 40 00 45 	cp.w	r0,69
8000987a:	5f 09       	sreq	r9
8000987c:	e0 40 00 65 	cp.w	r0,101
80009880:	5f 08       	sreq	r8
80009882:	40 22       	lddsp	r2,sp[0x8]
80009884:	10 49       	or	r9,r8
80009886:	2f f2       	sub	r2,-1
80009888:	40 46       	lddsp	r6,sp[0x10]
8000988a:	ec 09 18 00 	cp.b	r9,r6
8000988e:	fb f2 00 02 	ld.weq	r2,sp[0x8]
80009892:	30 29       	mov	r9,2
80009894:	fa c8 f9 5c 	sub	r8,sp,-1700
80009898:	1a d8       	st.w	--sp,r8
8000989a:	fa c8 f9 54 	sub	r8,sp,-1708
8000989e:	1a d8       	st.w	--sp,r8
800098a0:	fa c8 f9 4c 	sub	r8,sp,-1716
800098a4:	08 9c       	mov	r12,r4
800098a6:	1a d8       	st.w	--sp,r8
800098a8:	04 98       	mov	r8,r2
800098aa:	40 9b       	lddsp	r11,sp[0x24]
800098ac:	40 aa       	lddsp	r10,sp[0x28]
800098ae:	e0 a0 0b c3 	rcall	8000b034 <_dtoa_r>
800098b2:	e0 40 00 47 	cp.w	r0,71
800098b6:	5f 19       	srne	r9
800098b8:	e0 40 00 67 	cp.w	r0,103
800098bc:	5f 18       	srne	r8
800098be:	18 96       	mov	r6,r12
800098c0:	2f dd       	sub	sp,-12
800098c2:	f3 e8 00 08 	and	r8,r9,r8
800098c6:	c0 41       	brne	800098ce <_vfprintf_r+0x9aa>
800098c8:	ed b5 00 00 	bld	r5,0x0
800098cc:	c3 01       	brne	8000992c <_vfprintf_r+0xa08>
800098ce:	ec 02 00 0e 	add	lr,r6,r2
800098d2:	50 3e       	stdsp	sp[0xc],lr
800098d4:	40 4c       	lddsp	r12,sp[0x10]
800098d6:	58 0c       	cp.w	r12,0
800098d8:	c1 50       	breq	80009902 <_vfprintf_r+0x9de>
800098da:	0d 89       	ld.ub	r9,r6[0x0]
800098dc:	33 08       	mov	r8,48
800098de:	f0 09 18 00 	cp.b	r9,r8
800098e2:	c0 b1       	brne	800098f8 <_vfprintf_r+0x9d4>
800098e4:	30 08       	mov	r8,0
800098e6:	30 09       	mov	r9,0
800098e8:	40 6b       	lddsp	r11,sp[0x18]
800098ea:	40 7a       	lddsp	r10,sp[0x1c]
800098ec:	e0 a0 1c d7 	rcall	8000d29a <__avr32_f64_cmp_eq>
800098f0:	fb b2 00 01 	rsubeq	r2,1
800098f4:	fb f2 0b ab 	st.weq	sp[0x6ac],r2
800098f8:	40 3b       	lddsp	r11,sp[0xc]
800098fa:	fa f8 06 ac 	ld.w	r8,sp[1708]
800098fe:	10 0b       	add	r11,r8
80009900:	50 3b       	stdsp	sp[0xc],r11
80009902:	40 6b       	lddsp	r11,sp[0x18]
80009904:	30 08       	mov	r8,0
80009906:	30 09       	mov	r9,0
80009908:	40 7a       	lddsp	r10,sp[0x1c]
8000990a:	e0 a0 1c c8 	rcall	8000d29a <__avr32_f64_cmp_eq>
8000990e:	c0 90       	breq	80009920 <_vfprintf_r+0x9fc>
80009910:	40 3a       	lddsp	r10,sp[0xc]
80009912:	fb 4a 06 a4 	st.w	sp[1700],r10
80009916:	c0 58       	rjmp	80009920 <_vfprintf_r+0x9fc>
80009918:	10 c9       	st.b	r8++,r9
8000991a:	fb 48 06 a4 	st.w	sp[1700],r8
8000991e:	c0 28       	rjmp	80009922 <_vfprintf_r+0x9fe>
80009920:	33 09       	mov	r9,48
80009922:	fa f8 06 a4 	ld.w	r8,sp[1700]
80009926:	40 3e       	lddsp	lr,sp[0xc]
80009928:	1c 38       	cp.w	r8,lr
8000992a:	cf 73       	brcs	80009918 <_vfprintf_r+0x9f4>
8000992c:	e0 40 00 47 	cp.w	r0,71
80009930:	5f 09       	sreq	r9
80009932:	e0 40 00 67 	cp.w	r0,103
80009936:	5f 08       	sreq	r8
80009938:	f3 e8 10 08 	or	r8,r9,r8
8000993c:	fa f9 06 a4 	ld.w	r9,sp[1700]
80009940:	0c 19       	sub	r9,r6
80009942:	50 69       	stdsp	sp[0x18],r9
80009944:	58 08       	cp.w	r8,0
80009946:	c0 b0       	breq	8000995c <_vfprintf_r+0xa38>
80009948:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000994c:	5b d8       	cp.w	r8,-3
8000994e:	c0 55       	brlt	80009958 <_vfprintf_r+0xa34>
80009950:	40 2c       	lddsp	r12,sp[0x8]
80009952:	18 38       	cp.w	r8,r12
80009954:	e0 8a 00 6a 	brle	80009a28 <_vfprintf_r+0xb04>
80009958:	20 20       	sub	r0,2
8000995a:	c0 58       	rjmp	80009964 <_vfprintf_r+0xa40>
8000995c:	e0 40 00 65 	cp.w	r0,101
80009960:	e0 89 00 46 	brgt	800099ec <_vfprintf_r+0xac8>
80009964:	fa fb 06 ac 	ld.w	r11,sp[1708]
80009968:	fb 60 06 9c 	st.b	sp[1692],r0
8000996c:	20 1b       	sub	r11,1
8000996e:	fb 4b 06 ac 	st.w	sp[1708],r11
80009972:	c0 47       	brpl	8000997a <_vfprintf_r+0xa56>
80009974:	5c 3b       	neg	r11
80009976:	32 d8       	mov	r8,45
80009978:	c0 28       	rjmp	8000997c <_vfprintf_r+0xa58>
8000997a:	32 b8       	mov	r8,43
8000997c:	fb 68 06 9d 	st.b	sp[1693],r8
80009980:	58 9b       	cp.w	r11,9
80009982:	e0 8a 00 1d 	brle	800099bc <_vfprintf_r+0xa98>
80009986:	fa c9 fa 35 	sub	r9,sp,-1483
8000998a:	30 aa       	mov	r10,10
8000998c:	12 98       	mov	r8,r9
8000998e:	0e 9c       	mov	r12,r7
80009990:	0c 92       	mov	r2,r6
80009992:	f6 0a 0c 06 	divs	r6,r11,r10
80009996:	0e 9b       	mov	r11,r7
80009998:	2d 0b       	sub	r11,-48
8000999a:	10 fb       	st.b	--r8,r11
8000999c:	0c 9b       	mov	r11,r6
8000999e:	58 96       	cp.w	r6,9
800099a0:	fe 99 ff f9 	brgt	80009992 <_vfprintf_r+0xa6e>
800099a4:	2d 0b       	sub	r11,-48
800099a6:	18 97       	mov	r7,r12
800099a8:	04 96       	mov	r6,r2
800099aa:	10 fb       	st.b	--r8,r11
800099ac:	fa ca f9 62 	sub	r10,sp,-1694
800099b0:	c0 38       	rjmp	800099b6 <_vfprintf_r+0xa92>
800099b2:	11 3b       	ld.ub	r11,r8++
800099b4:	14 cb       	st.b	r10++,r11
800099b6:	12 38       	cp.w	r8,r9
800099b8:	cf d3       	brcs	800099b2 <_vfprintf_r+0xa8e>
800099ba:	c0 98       	rjmp	800099cc <_vfprintf_r+0xaa8>
800099bc:	2d 0b       	sub	r11,-48
800099be:	33 08       	mov	r8,48
800099c0:	fb 6b 06 9f 	st.b	sp[1695],r11
800099c4:	fb 68 06 9e 	st.b	sp[1694],r8
800099c8:	fa ca f9 60 	sub	r10,sp,-1696
800099cc:	fa c8 f9 64 	sub	r8,sp,-1692
800099d0:	f4 08 01 08 	sub	r8,r10,r8
800099d4:	50 e8       	stdsp	sp[0x38],r8
800099d6:	10 92       	mov	r2,r8
800099d8:	40 6b       	lddsp	r11,sp[0x18]
800099da:	16 02       	add	r2,r11
800099dc:	58 1b       	cp.w	r11,1
800099de:	e0 89 00 05 	brgt	800099e8 <_vfprintf_r+0xac4>
800099e2:	ed b5 00 00 	bld	r5,0x0
800099e6:	c3 51       	brne	80009a50 <_vfprintf_r+0xb2c>
800099e8:	2f f2       	sub	r2,-1
800099ea:	c3 38       	rjmp	80009a50 <_vfprintf_r+0xb2c>
800099ec:	e0 40 00 66 	cp.w	r0,102
800099f0:	c1 c1       	brne	80009a28 <_vfprintf_r+0xb04>
800099f2:	fa f2 06 ac 	ld.w	r2,sp[1708]
800099f6:	58 02       	cp.w	r2,0
800099f8:	e0 8a 00 0c 	brle	80009a10 <_vfprintf_r+0xaec>
800099fc:	40 2a       	lddsp	r10,sp[0x8]
800099fe:	58 0a       	cp.w	r10,0
80009a00:	c0 41       	brne	80009a08 <_vfprintf_r+0xae4>
80009a02:	ed b5 00 00 	bld	r5,0x0
80009a06:	c2 51       	brne	80009a50 <_vfprintf_r+0xb2c>
80009a08:	2f f2       	sub	r2,-1
80009a0a:	40 29       	lddsp	r9,sp[0x8]
80009a0c:	12 02       	add	r2,r9
80009a0e:	c0 b8       	rjmp	80009a24 <_vfprintf_r+0xb00>
80009a10:	40 28       	lddsp	r8,sp[0x8]
80009a12:	58 08       	cp.w	r8,0
80009a14:	c0 61       	brne	80009a20 <_vfprintf_r+0xafc>
80009a16:	ed b5 00 00 	bld	r5,0x0
80009a1a:	c0 30       	breq	80009a20 <_vfprintf_r+0xafc>
80009a1c:	30 12       	mov	r2,1
80009a1e:	c1 98       	rjmp	80009a50 <_vfprintf_r+0xb2c>
80009a20:	40 22       	lddsp	r2,sp[0x8]
80009a22:	2f e2       	sub	r2,-2
80009a24:	36 60       	mov	r0,102
80009a26:	c1 58       	rjmp	80009a50 <_vfprintf_r+0xb2c>
80009a28:	fa f2 06 ac 	ld.w	r2,sp[1708]
80009a2c:	40 6e       	lddsp	lr,sp[0x18]
80009a2e:	1c 32       	cp.w	r2,lr
80009a30:	c0 65       	brlt	80009a3c <_vfprintf_r+0xb18>
80009a32:	ed b5 00 00 	bld	r5,0x0
80009a36:	f7 b2 00 ff 	subeq	r2,-1
80009a3a:	c0 a8       	rjmp	80009a4e <_vfprintf_r+0xb2a>
80009a3c:	e4 08 11 02 	rsub	r8,r2,2
80009a40:	40 6c       	lddsp	r12,sp[0x18]
80009a42:	58 02       	cp.w	r2,0
80009a44:	f0 02 17 a0 	movle	r2,r8
80009a48:	f9 b2 09 01 	movgt	r2,1
80009a4c:	18 02       	add	r2,r12
80009a4e:	36 70       	mov	r0,103
80009a50:	40 9b       	lddsp	r11,sp[0x24]
80009a52:	58 0b       	cp.w	r11,0
80009a54:	e0 80 05 94 	breq	8000a57c <_vfprintf_r+0x1658>
80009a58:	32 d8       	mov	r8,45
80009a5a:	fb 68 06 bb 	st.b	sp[1723],r8
80009a5e:	e0 8f 05 93 	bral	8000a584 <_vfprintf_r+0x1660>
80009a62:	50 a7       	stdsp	sp[0x28],r7
80009a64:	04 94       	mov	r4,r2
80009a66:	0c 97       	mov	r7,r6
80009a68:	02 92       	mov	r2,r1
80009a6a:	06 96       	mov	r6,r3
80009a6c:	40 41       	lddsp	r1,sp[0x10]
80009a6e:	40 93       	lddsp	r3,sp[0x24]
80009a70:	0e 99       	mov	r9,r7
80009a72:	ed b5 00 05 	bld	r5,0x5
80009a76:	c4 81       	brne	80009b06 <_vfprintf_r+0xbe2>
80009a78:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009a7c:	40 3e       	lddsp	lr,sp[0xc]
80009a7e:	58 0e       	cp.w	lr,0
80009a80:	c1 d0       	breq	80009aba <_vfprintf_r+0xb96>
80009a82:	10 36       	cp.w	r6,r8
80009a84:	c0 64       	brge	80009a90 <_vfprintf_r+0xb6c>
80009a86:	fa cc f9 44 	sub	r12,sp,-1724
80009a8a:	f8 06 00 36 	add	r6,r12,r6<<0x3
80009a8e:	c1 d8       	rjmp	80009ac8 <_vfprintf_r+0xba4>
80009a90:	fa c8 f9 50 	sub	r8,sp,-1712
80009a94:	1a d8       	st.w	--sp,r8
80009a96:	fa c8 fa b8 	sub	r8,sp,-1352
80009a9a:	04 9a       	mov	r10,r2
80009a9c:	1a d8       	st.w	--sp,r8
80009a9e:	fa c8 fb b4 	sub	r8,sp,-1100
80009aa2:	0c 9b       	mov	r11,r6
80009aa4:	1a d8       	st.w	--sp,r8
80009aa6:	08 9c       	mov	r12,r4
80009aa8:	fa c8 f9 40 	sub	r8,sp,-1728
80009aac:	fa c9 ff b4 	sub	r9,sp,-76
80009ab0:	fe b0 f8 a2 	rcall	80008bf4 <get_arg>
80009ab4:	2f dd       	sub	sp,-12
80009ab6:	78 0a       	ld.w	r10,r12[0x0]
80009ab8:	c2 08       	rjmp	80009af8 <_vfprintf_r+0xbd4>
80009aba:	2f f7       	sub	r7,-1
80009abc:	10 39       	cp.w	r9,r8
80009abe:	c0 84       	brge	80009ace <_vfprintf_r+0xbaa>
80009ac0:	fa cb f9 44 	sub	r11,sp,-1724
80009ac4:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009ac8:	ec fa fd 88 	ld.w	r10,r6[-632]
80009acc:	c1 68       	rjmp	80009af8 <_vfprintf_r+0xbd4>
80009ace:	41 09       	lddsp	r9,sp[0x40]
80009ad0:	59 f8       	cp.w	r8,31
80009ad2:	e0 89 00 10 	brgt	80009af2 <_vfprintf_r+0xbce>
80009ad6:	f2 ca ff fc 	sub	r10,r9,-4
80009ada:	51 0a       	stdsp	sp[0x40],r10
80009adc:	fa c6 f9 44 	sub	r6,sp,-1724
80009ae0:	72 0a       	ld.w	r10,r9[0x0]
80009ae2:	ec 08 00 39 	add	r9,r6,r8<<0x3
80009ae6:	f3 4a fd 88 	st.w	r9[-632],r10
80009aea:	2f f8       	sub	r8,-1
80009aec:	fb 48 06 b4 	st.w	sp[1716],r8
80009af0:	c0 48       	rjmp	80009af8 <_vfprintf_r+0xbd4>
80009af2:	72 0a       	ld.w	r10,r9[0x0]
80009af4:	2f c9       	sub	r9,-4
80009af6:	51 09       	stdsp	sp[0x40],r9
80009af8:	40 be       	lddsp	lr,sp[0x2c]
80009afa:	1c 98       	mov	r8,lr
80009afc:	95 1e       	st.w	r10[0x4],lr
80009afe:	bf 58       	asr	r8,0x1f
80009b00:	95 08       	st.w	r10[0x0],r8
80009b02:	fe 9f fa 9f 	bral	80009040 <_vfprintf_r+0x11c>
80009b06:	ed b5 00 04 	bld	r5,0x4
80009b0a:	c4 80       	breq	80009b9a <_vfprintf_r+0xc76>
80009b0c:	e2 15 00 40 	andl	r5,0x40,COH
80009b10:	c4 50       	breq	80009b9a <_vfprintf_r+0xc76>
80009b12:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009b16:	40 3c       	lddsp	r12,sp[0xc]
80009b18:	58 0c       	cp.w	r12,0
80009b1a:	c1 d0       	breq	80009b54 <_vfprintf_r+0xc30>
80009b1c:	10 36       	cp.w	r6,r8
80009b1e:	c0 64       	brge	80009b2a <_vfprintf_r+0xc06>
80009b20:	fa cb f9 44 	sub	r11,sp,-1724
80009b24:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009b28:	c1 d8       	rjmp	80009b62 <_vfprintf_r+0xc3e>
80009b2a:	fa c8 f9 50 	sub	r8,sp,-1712
80009b2e:	1a d8       	st.w	--sp,r8
80009b30:	fa c8 fa b8 	sub	r8,sp,-1352
80009b34:	04 9a       	mov	r10,r2
80009b36:	1a d8       	st.w	--sp,r8
80009b38:	fa c8 fb b4 	sub	r8,sp,-1100
80009b3c:	0c 9b       	mov	r11,r6
80009b3e:	1a d8       	st.w	--sp,r8
80009b40:	08 9c       	mov	r12,r4
80009b42:	fa c8 f9 40 	sub	r8,sp,-1728
80009b46:	fa c9 ff b4 	sub	r9,sp,-76
80009b4a:	fe b0 f8 55 	rcall	80008bf4 <get_arg>
80009b4e:	2f dd       	sub	sp,-12
80009b50:	78 0a       	ld.w	r10,r12[0x0]
80009b52:	c2 08       	rjmp	80009b92 <_vfprintf_r+0xc6e>
80009b54:	2f f7       	sub	r7,-1
80009b56:	10 39       	cp.w	r9,r8
80009b58:	c0 84       	brge	80009b68 <_vfprintf_r+0xc44>
80009b5a:	fa ca f9 44 	sub	r10,sp,-1724
80009b5e:	f4 06 00 36 	add	r6,r10,r6<<0x3
80009b62:	ec fa fd 88 	ld.w	r10,r6[-632]
80009b66:	c1 68       	rjmp	80009b92 <_vfprintf_r+0xc6e>
80009b68:	41 09       	lddsp	r9,sp[0x40]
80009b6a:	59 f8       	cp.w	r8,31
80009b6c:	e0 89 00 10 	brgt	80009b8c <_vfprintf_r+0xc68>
80009b70:	f2 ca ff fc 	sub	r10,r9,-4
80009b74:	51 0a       	stdsp	sp[0x40],r10
80009b76:	fa c6 f9 44 	sub	r6,sp,-1724
80009b7a:	72 0a       	ld.w	r10,r9[0x0]
80009b7c:	ec 08 00 39 	add	r9,r6,r8<<0x3
80009b80:	f3 4a fd 88 	st.w	r9[-632],r10
80009b84:	2f f8       	sub	r8,-1
80009b86:	fb 48 06 b4 	st.w	sp[1716],r8
80009b8a:	c0 48       	rjmp	80009b92 <_vfprintf_r+0xc6e>
80009b8c:	72 0a       	ld.w	r10,r9[0x0]
80009b8e:	2f c9       	sub	r9,-4
80009b90:	51 09       	stdsp	sp[0x40],r9
80009b92:	40 be       	lddsp	lr,sp[0x2c]
80009b94:	b4 0e       	st.h	r10[0x0],lr
80009b96:	fe 9f fa 55 	bral	80009040 <_vfprintf_r+0x11c>
80009b9a:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009b9e:	40 3c       	lddsp	r12,sp[0xc]
80009ba0:	58 0c       	cp.w	r12,0
80009ba2:	c1 d0       	breq	80009bdc <_vfprintf_r+0xcb8>
80009ba4:	10 36       	cp.w	r6,r8
80009ba6:	c0 64       	brge	80009bb2 <_vfprintf_r+0xc8e>
80009ba8:	fa cb f9 44 	sub	r11,sp,-1724
80009bac:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009bb0:	c1 d8       	rjmp	80009bea <_vfprintf_r+0xcc6>
80009bb2:	fa c8 f9 50 	sub	r8,sp,-1712
80009bb6:	1a d8       	st.w	--sp,r8
80009bb8:	fa c8 fa b8 	sub	r8,sp,-1352
80009bbc:	04 9a       	mov	r10,r2
80009bbe:	1a d8       	st.w	--sp,r8
80009bc0:	fa c8 fb b4 	sub	r8,sp,-1100
80009bc4:	0c 9b       	mov	r11,r6
80009bc6:	1a d8       	st.w	--sp,r8
80009bc8:	08 9c       	mov	r12,r4
80009bca:	fa c8 f9 40 	sub	r8,sp,-1728
80009bce:	fa c9 ff b4 	sub	r9,sp,-76
80009bd2:	fe b0 f8 11 	rcall	80008bf4 <get_arg>
80009bd6:	2f dd       	sub	sp,-12
80009bd8:	78 0a       	ld.w	r10,r12[0x0]
80009bda:	c2 08       	rjmp	80009c1a <_vfprintf_r+0xcf6>
80009bdc:	2f f7       	sub	r7,-1
80009bde:	10 39       	cp.w	r9,r8
80009be0:	c0 84       	brge	80009bf0 <_vfprintf_r+0xccc>
80009be2:	fa ca f9 44 	sub	r10,sp,-1724
80009be6:	f4 06 00 36 	add	r6,r10,r6<<0x3
80009bea:	ec fa fd 88 	ld.w	r10,r6[-632]
80009bee:	c1 68       	rjmp	80009c1a <_vfprintf_r+0xcf6>
80009bf0:	41 09       	lddsp	r9,sp[0x40]
80009bf2:	59 f8       	cp.w	r8,31
80009bf4:	e0 89 00 10 	brgt	80009c14 <_vfprintf_r+0xcf0>
80009bf8:	f2 ca ff fc 	sub	r10,r9,-4
80009bfc:	51 0a       	stdsp	sp[0x40],r10
80009bfe:	fa c6 f9 44 	sub	r6,sp,-1724
80009c02:	72 0a       	ld.w	r10,r9[0x0]
80009c04:	ec 08 00 39 	add	r9,r6,r8<<0x3
80009c08:	f3 4a fd 88 	st.w	r9[-632],r10
80009c0c:	2f f8       	sub	r8,-1
80009c0e:	fb 48 06 b4 	st.w	sp[1716],r8
80009c12:	c0 48       	rjmp	80009c1a <_vfprintf_r+0xcf6>
80009c14:	72 0a       	ld.w	r10,r9[0x0]
80009c16:	2f c9       	sub	r9,-4
80009c18:	51 09       	stdsp	sp[0x40],r9
80009c1a:	40 be       	lddsp	lr,sp[0x2c]
80009c1c:	95 0e       	st.w	r10[0x0],lr
80009c1e:	fe 9f fa 11 	bral	80009040 <_vfprintf_r+0x11c>
80009c22:	50 a7       	stdsp	sp[0x28],r7
80009c24:	50 80       	stdsp	sp[0x20],r0
80009c26:	0c 97       	mov	r7,r6
80009c28:	04 94       	mov	r4,r2
80009c2a:	06 96       	mov	r6,r3
80009c2c:	02 92       	mov	r2,r1
80009c2e:	40 93       	lddsp	r3,sp[0x24]
80009c30:	10 90       	mov	r0,r8
80009c32:	40 41       	lddsp	r1,sp[0x10]
80009c34:	a5 a5       	sbr	r5,0x4
80009c36:	c0 a8       	rjmp	80009c4a <_vfprintf_r+0xd26>
80009c38:	50 a7       	stdsp	sp[0x28],r7
80009c3a:	50 80       	stdsp	sp[0x20],r0
80009c3c:	0c 97       	mov	r7,r6
80009c3e:	04 94       	mov	r4,r2
80009c40:	06 96       	mov	r6,r3
80009c42:	02 92       	mov	r2,r1
80009c44:	40 93       	lddsp	r3,sp[0x24]
80009c46:	10 90       	mov	r0,r8
80009c48:	40 41       	lddsp	r1,sp[0x10]
80009c4a:	ed b5 00 05 	bld	r5,0x5
80009c4e:	c5 d1       	brne	80009d08 <_vfprintf_r+0xde4>
80009c50:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009c54:	40 3c       	lddsp	r12,sp[0xc]
80009c56:	58 0c       	cp.w	r12,0
80009c58:	c2 60       	breq	80009ca4 <_vfprintf_r+0xd80>
80009c5a:	10 36       	cp.w	r6,r8
80009c5c:	c0 a4       	brge	80009c70 <_vfprintf_r+0xd4c>
80009c5e:	fa cb f9 44 	sub	r11,sp,-1724
80009c62:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009c66:	ec e8 fd 88 	ld.d	r8,r6[-632]
80009c6a:	fa e9 00 00 	st.d	sp[0],r8
80009c6e:	c1 88       	rjmp	80009c9e <_vfprintf_r+0xd7a>
80009c70:	fa c8 f9 50 	sub	r8,sp,-1712
80009c74:	1a d8       	st.w	--sp,r8
80009c76:	fa c8 fa b8 	sub	r8,sp,-1352
80009c7a:	04 9a       	mov	r10,r2
80009c7c:	1a d8       	st.w	--sp,r8
80009c7e:	0c 9b       	mov	r11,r6
80009c80:	fa c8 fb b4 	sub	r8,sp,-1100
80009c84:	08 9c       	mov	r12,r4
80009c86:	1a d8       	st.w	--sp,r8
80009c88:	fa c8 f9 40 	sub	r8,sp,-1728
80009c8c:	fa c9 ff b4 	sub	r9,sp,-76
80009c90:	fe b0 f7 b2 	rcall	80008bf4 <get_arg>
80009c94:	2f dd       	sub	sp,-12
80009c96:	f8 ea 00 00 	ld.d	r10,r12[0]
80009c9a:	fa eb 00 00 	st.d	sp[0],r10
80009c9e:	30 08       	mov	r8,0
80009ca0:	e0 8f 03 de 	bral	8000a45c <_vfprintf_r+0x1538>
80009ca4:	ee ca ff ff 	sub	r10,r7,-1
80009ca8:	10 37       	cp.w	r7,r8
80009caa:	c0 b4       	brge	80009cc0 <_vfprintf_r+0xd9c>
80009cac:	fa c9 f9 44 	sub	r9,sp,-1724
80009cb0:	14 97       	mov	r7,r10
80009cb2:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009cb6:	ec ea fd 88 	ld.d	r10,r6[-632]
80009cba:	fa eb 00 00 	st.d	sp[0],r10
80009cbe:	c1 88       	rjmp	80009cee <_vfprintf_r+0xdca>
80009cc0:	41 09       	lddsp	r9,sp[0x40]
80009cc2:	59 f8       	cp.w	r8,31
80009cc4:	e0 89 00 18 	brgt	80009cf4 <_vfprintf_r+0xdd0>
80009cc8:	f2 e6 00 00 	ld.d	r6,r9[0]
80009ccc:	f2 cb ff f8 	sub	r11,r9,-8
80009cd0:	fa e7 00 00 	st.d	sp[0],r6
80009cd4:	51 0b       	stdsp	sp[0x40],r11
80009cd6:	fa c6 f9 44 	sub	r6,sp,-1724
80009cda:	ec 08 00 39 	add	r9,r6,r8<<0x3
80009cde:	fa e6 00 00 	ld.d	r6,sp[0]
80009ce2:	f2 e7 fd 88 	st.d	r9[-632],r6
80009ce6:	2f f8       	sub	r8,-1
80009ce8:	14 97       	mov	r7,r10
80009cea:	fb 48 06 b4 	st.w	sp[1716],r8
80009cee:	40 38       	lddsp	r8,sp[0xc]
80009cf0:	e0 8f 03 b6 	bral	8000a45c <_vfprintf_r+0x1538>
80009cf4:	f2 e6 00 00 	ld.d	r6,r9[0]
80009cf8:	40 38       	lddsp	r8,sp[0xc]
80009cfa:	fa e7 00 00 	st.d	sp[0],r6
80009cfe:	2f 89       	sub	r9,-8
80009d00:	14 97       	mov	r7,r10
80009d02:	51 09       	stdsp	sp[0x40],r9
80009d04:	e0 8f 03 ac 	bral	8000a45c <_vfprintf_r+0x1538>
80009d08:	ed b5 00 04 	bld	r5,0x4
80009d0c:	c1 61       	brne	80009d38 <_vfprintf_r+0xe14>
80009d0e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009d12:	40 3e       	lddsp	lr,sp[0xc]
80009d14:	58 0e       	cp.w	lr,0
80009d16:	c0 80       	breq	80009d26 <_vfprintf_r+0xe02>
80009d18:	10 36       	cp.w	r6,r8
80009d1a:	c6 74       	brge	80009de8 <_vfprintf_r+0xec4>
80009d1c:	fa cc f9 44 	sub	r12,sp,-1724
80009d20:	f8 06 00 36 	add	r6,r12,r6<<0x3
80009d24:	c8 08       	rjmp	80009e24 <_vfprintf_r+0xf00>
80009d26:	ee ca ff ff 	sub	r10,r7,-1
80009d2a:	10 37       	cp.w	r7,r8
80009d2c:	c7 f4       	brge	80009e2a <_vfprintf_r+0xf06>
80009d2e:	fa cb f9 44 	sub	r11,sp,-1724
80009d32:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009d36:	c7 68       	rjmp	80009e22 <_vfprintf_r+0xefe>
80009d38:	ed b5 00 06 	bld	r5,0x6
80009d3c:	c4 a1       	brne	80009dd0 <_vfprintf_r+0xeac>
80009d3e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009d42:	40 3c       	lddsp	r12,sp[0xc]
80009d44:	58 0c       	cp.w	r12,0
80009d46:	c1 d0       	breq	80009d80 <_vfprintf_r+0xe5c>
80009d48:	10 36       	cp.w	r6,r8
80009d4a:	c0 64       	brge	80009d56 <_vfprintf_r+0xe32>
80009d4c:	fa cb f9 44 	sub	r11,sp,-1724
80009d50:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009d54:	c1 f8       	rjmp	80009d92 <_vfprintf_r+0xe6e>
80009d56:	fa c8 f9 50 	sub	r8,sp,-1712
80009d5a:	1a d8       	st.w	--sp,r8
80009d5c:	fa c8 fa b8 	sub	r8,sp,-1352
80009d60:	1a d8       	st.w	--sp,r8
80009d62:	fa c8 fb b4 	sub	r8,sp,-1100
80009d66:	1a d8       	st.w	--sp,r8
80009d68:	fa c8 f9 40 	sub	r8,sp,-1728
80009d6c:	fa c9 ff b4 	sub	r9,sp,-76
80009d70:	04 9a       	mov	r10,r2
80009d72:	0c 9b       	mov	r11,r6
80009d74:	08 9c       	mov	r12,r4
80009d76:	fe b0 f7 3f 	rcall	80008bf4 <get_arg>
80009d7a:	2f dd       	sub	sp,-12
80009d7c:	98 18       	ld.sh	r8,r12[0x2]
80009d7e:	c2 68       	rjmp	80009dca <_vfprintf_r+0xea6>
80009d80:	ee ca ff ff 	sub	r10,r7,-1
80009d84:	10 37       	cp.w	r7,r8
80009d86:	c0 94       	brge	80009d98 <_vfprintf_r+0xe74>
80009d88:	fa c9 f9 44 	sub	r9,sp,-1724
80009d8c:	14 97       	mov	r7,r10
80009d8e:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009d92:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80009d96:	c1 a8       	rjmp	80009dca <_vfprintf_r+0xea6>
80009d98:	41 09       	lddsp	r9,sp[0x40]
80009d9a:	59 f8       	cp.w	r8,31
80009d9c:	e0 89 00 13 	brgt	80009dc2 <_vfprintf_r+0xe9e>
80009da0:	f2 cb ff fc 	sub	r11,r9,-4
80009da4:	51 0b       	stdsp	sp[0x40],r11
80009da6:	72 09       	ld.w	r9,r9[0x0]
80009da8:	fa c6 f9 44 	sub	r6,sp,-1724
80009dac:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80009db0:	2f f8       	sub	r8,-1
80009db2:	f7 49 fd 88 	st.w	r11[-632],r9
80009db6:	fb 48 06 b4 	st.w	sp[1716],r8
80009dba:	14 97       	mov	r7,r10
80009dbc:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80009dc0:	c0 58       	rjmp	80009dca <_vfprintf_r+0xea6>
80009dc2:	92 18       	ld.sh	r8,r9[0x2]
80009dc4:	14 97       	mov	r7,r10
80009dc6:	2f c9       	sub	r9,-4
80009dc8:	51 09       	stdsp	sp[0x40],r9
80009dca:	5c 78       	castu.h	r8
80009dcc:	50 18       	stdsp	sp[0x4],r8
80009dce:	c4 68       	rjmp	80009e5a <_vfprintf_r+0xf36>
80009dd0:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009dd4:	40 3c       	lddsp	r12,sp[0xc]
80009dd6:	58 0c       	cp.w	r12,0
80009dd8:	c1 d0       	breq	80009e12 <_vfprintf_r+0xeee>
80009dda:	10 36       	cp.w	r6,r8
80009ddc:	c0 64       	brge	80009de8 <_vfprintf_r+0xec4>
80009dde:	fa cb f9 44 	sub	r11,sp,-1724
80009de2:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009de6:	c1 f8       	rjmp	80009e24 <_vfprintf_r+0xf00>
80009de8:	fa c8 f9 50 	sub	r8,sp,-1712
80009dec:	1a d8       	st.w	--sp,r8
80009dee:	fa c8 fa b8 	sub	r8,sp,-1352
80009df2:	0c 9b       	mov	r11,r6
80009df4:	1a d8       	st.w	--sp,r8
80009df6:	fa c8 fb b4 	sub	r8,sp,-1100
80009dfa:	04 9a       	mov	r10,r2
80009dfc:	1a d8       	st.w	--sp,r8
80009dfe:	08 9c       	mov	r12,r4
80009e00:	fa c8 f9 40 	sub	r8,sp,-1728
80009e04:	fa c9 ff b4 	sub	r9,sp,-76
80009e08:	fe b0 f6 f6 	rcall	80008bf4 <get_arg>
80009e0c:	2f dd       	sub	sp,-12
80009e0e:	78 0b       	ld.w	r11,r12[0x0]
80009e10:	c2 48       	rjmp	80009e58 <_vfprintf_r+0xf34>
80009e12:	ee ca ff ff 	sub	r10,r7,-1
80009e16:	10 37       	cp.w	r7,r8
80009e18:	c0 94       	brge	80009e2a <_vfprintf_r+0xf06>
80009e1a:	fa c9 f9 44 	sub	r9,sp,-1724
80009e1e:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009e22:	14 97       	mov	r7,r10
80009e24:	ec fb fd 88 	ld.w	r11,r6[-632]
80009e28:	c1 88       	rjmp	80009e58 <_vfprintf_r+0xf34>
80009e2a:	41 09       	lddsp	r9,sp[0x40]
80009e2c:	59 f8       	cp.w	r8,31
80009e2e:	e0 89 00 11 	brgt	80009e50 <_vfprintf_r+0xf2c>
80009e32:	f2 cb ff fc 	sub	r11,r9,-4
80009e36:	51 0b       	stdsp	sp[0x40],r11
80009e38:	fa c6 f9 44 	sub	r6,sp,-1724
80009e3c:	72 0b       	ld.w	r11,r9[0x0]
80009e3e:	ec 08 00 39 	add	r9,r6,r8<<0x3
80009e42:	f3 4b fd 88 	st.w	r9[-632],r11
80009e46:	2f f8       	sub	r8,-1
80009e48:	14 97       	mov	r7,r10
80009e4a:	fb 48 06 b4 	st.w	sp[1716],r8
80009e4e:	c0 58       	rjmp	80009e58 <_vfprintf_r+0xf34>
80009e50:	72 0b       	ld.w	r11,r9[0x0]
80009e52:	14 97       	mov	r7,r10
80009e54:	2f c9       	sub	r9,-4
80009e56:	51 09       	stdsp	sp[0x40],r9
80009e58:	50 1b       	stdsp	sp[0x4],r11
80009e5a:	30 0e       	mov	lr,0
80009e5c:	50 0e       	stdsp	sp[0x0],lr
80009e5e:	1c 98       	mov	r8,lr
80009e60:	e0 8f 02 fe 	bral	8000a45c <_vfprintf_r+0x1538>
80009e64:	50 a7       	stdsp	sp[0x28],r7
80009e66:	50 80       	stdsp	sp[0x20],r0
80009e68:	0c 97       	mov	r7,r6
80009e6a:	04 94       	mov	r4,r2
80009e6c:	06 96       	mov	r6,r3
80009e6e:	02 92       	mov	r2,r1
80009e70:	40 93       	lddsp	r3,sp[0x24]
80009e72:	40 41       	lddsp	r1,sp[0x10]
80009e74:	0e 99       	mov	r9,r7
80009e76:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009e7a:	40 3c       	lddsp	r12,sp[0xc]
80009e7c:	58 0c       	cp.w	r12,0
80009e7e:	c1 d0       	breq	80009eb8 <_vfprintf_r+0xf94>
80009e80:	10 36       	cp.w	r6,r8
80009e82:	c0 64       	brge	80009e8e <_vfprintf_r+0xf6a>
80009e84:	fa cb f9 44 	sub	r11,sp,-1724
80009e88:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009e8c:	c1 d8       	rjmp	80009ec6 <_vfprintf_r+0xfa2>
80009e8e:	fa c8 f9 50 	sub	r8,sp,-1712
80009e92:	1a d8       	st.w	--sp,r8
80009e94:	fa c8 fa b8 	sub	r8,sp,-1352
80009e98:	1a d8       	st.w	--sp,r8
80009e9a:	fa c8 fb b4 	sub	r8,sp,-1100
80009e9e:	1a d8       	st.w	--sp,r8
80009ea0:	fa c9 ff b4 	sub	r9,sp,-76
80009ea4:	fa c8 f9 40 	sub	r8,sp,-1728
80009ea8:	04 9a       	mov	r10,r2
80009eaa:	0c 9b       	mov	r11,r6
80009eac:	08 9c       	mov	r12,r4
80009eae:	fe b0 f6 a3 	rcall	80008bf4 <get_arg>
80009eb2:	2f dd       	sub	sp,-12
80009eb4:	78 09       	ld.w	r9,r12[0x0]
80009eb6:	c2 18       	rjmp	80009ef8 <_vfprintf_r+0xfd4>
80009eb8:	2f f7       	sub	r7,-1
80009eba:	10 39       	cp.w	r9,r8
80009ebc:	c0 84       	brge	80009ecc <_vfprintf_r+0xfa8>
80009ebe:	fa ca f9 44 	sub	r10,sp,-1724
80009ec2:	f4 06 00 36 	add	r6,r10,r6<<0x3
80009ec6:	ec f9 fd 88 	ld.w	r9,r6[-632]
80009eca:	c1 78       	rjmp	80009ef8 <_vfprintf_r+0xfd4>
80009ecc:	41 09       	lddsp	r9,sp[0x40]
80009ece:	59 f8       	cp.w	r8,31
80009ed0:	e0 89 00 10 	brgt	80009ef0 <_vfprintf_r+0xfcc>
80009ed4:	f2 ca ff fc 	sub	r10,r9,-4
80009ed8:	51 0a       	stdsp	sp[0x40],r10
80009eda:	fa c6 f9 44 	sub	r6,sp,-1724
80009ede:	72 09       	ld.w	r9,r9[0x0]
80009ee0:	ec 08 00 3a 	add	r10,r6,r8<<0x3
80009ee4:	f5 49 fd 88 	st.w	r10[-632],r9
80009ee8:	2f f8       	sub	r8,-1
80009eea:	fb 48 06 b4 	st.w	sp[1716],r8
80009eee:	c0 58       	rjmp	80009ef8 <_vfprintf_r+0xfd4>
80009ef0:	f2 c8 ff fc 	sub	r8,r9,-4
80009ef4:	51 08       	stdsp	sp[0x40],r8
80009ef6:	72 09       	ld.w	r9,r9[0x0]
80009ef8:	33 08       	mov	r8,48
80009efa:	fb 68 06 b8 	st.b	sp[1720],r8
80009efe:	37 88       	mov	r8,120
80009f00:	30 0e       	mov	lr,0
80009f02:	fb 68 06 b9 	st.b	sp[1721],r8
80009f06:	fe cc ad a2 	sub	r12,pc,-21086
80009f0a:	50 19       	stdsp	sp[0x4],r9
80009f0c:	a1 b5       	sbr	r5,0x1
80009f0e:	50 0e       	stdsp	sp[0x0],lr
80009f10:	50 dc       	stdsp	sp[0x34],r12
80009f12:	30 28       	mov	r8,2
80009f14:	37 80       	mov	r0,120
80009f16:	e0 8f 02 a3 	bral	8000a45c <_vfprintf_r+0x1538>
80009f1a:	50 a7       	stdsp	sp[0x28],r7
80009f1c:	50 80       	stdsp	sp[0x20],r0
80009f1e:	10 90       	mov	r0,r8
80009f20:	30 08       	mov	r8,0
80009f22:	fb 68 06 bb 	st.b	sp[1723],r8
80009f26:	0c 97       	mov	r7,r6
80009f28:	04 94       	mov	r4,r2
80009f2a:	06 96       	mov	r6,r3
80009f2c:	02 92       	mov	r2,r1
80009f2e:	40 93       	lddsp	r3,sp[0x24]
80009f30:	40 41       	lddsp	r1,sp[0x10]
80009f32:	0e 99       	mov	r9,r7
80009f34:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009f38:	40 3b       	lddsp	r11,sp[0xc]
80009f3a:	58 0b       	cp.w	r11,0
80009f3c:	c1 d0       	breq	80009f76 <_vfprintf_r+0x1052>
80009f3e:	10 36       	cp.w	r6,r8
80009f40:	c0 64       	brge	80009f4c <_vfprintf_r+0x1028>
80009f42:	fa ca f9 44 	sub	r10,sp,-1724
80009f46:	f4 06 00 36 	add	r6,r10,r6<<0x3
80009f4a:	c1 d8       	rjmp	80009f84 <_vfprintf_r+0x1060>
80009f4c:	fa c8 f9 50 	sub	r8,sp,-1712
80009f50:	1a d8       	st.w	--sp,r8
80009f52:	fa c8 fa b8 	sub	r8,sp,-1352
80009f56:	1a d8       	st.w	--sp,r8
80009f58:	fa c8 fb b4 	sub	r8,sp,-1100
80009f5c:	0c 9b       	mov	r11,r6
80009f5e:	1a d8       	st.w	--sp,r8
80009f60:	04 9a       	mov	r10,r2
80009f62:	fa c8 f9 40 	sub	r8,sp,-1728
80009f66:	fa c9 ff b4 	sub	r9,sp,-76
80009f6a:	08 9c       	mov	r12,r4
80009f6c:	fe b0 f6 44 	rcall	80008bf4 <get_arg>
80009f70:	2f dd       	sub	sp,-12
80009f72:	78 06       	ld.w	r6,r12[0x0]
80009f74:	c2 08       	rjmp	80009fb4 <_vfprintf_r+0x1090>
80009f76:	2f f7       	sub	r7,-1
80009f78:	10 39       	cp.w	r9,r8
80009f7a:	c0 84       	brge	80009f8a <_vfprintf_r+0x1066>
80009f7c:	fa c9 f9 44 	sub	r9,sp,-1724
80009f80:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009f84:	ec f6 fd 88 	ld.w	r6,r6[-632]
80009f88:	c1 68       	rjmp	80009fb4 <_vfprintf_r+0x1090>
80009f8a:	41 09       	lddsp	r9,sp[0x40]
80009f8c:	59 f8       	cp.w	r8,31
80009f8e:	e0 89 00 10 	brgt	80009fae <_vfprintf_r+0x108a>
80009f92:	f2 ca ff fc 	sub	r10,r9,-4
80009f96:	51 0a       	stdsp	sp[0x40],r10
80009f98:	72 06       	ld.w	r6,r9[0x0]
80009f9a:	fa ce f9 44 	sub	lr,sp,-1724
80009f9e:	fc 08 00 39 	add	r9,lr,r8<<0x3
80009fa2:	f3 46 fd 88 	st.w	r9[-632],r6
80009fa6:	2f f8       	sub	r8,-1
80009fa8:	fb 48 06 b4 	st.w	sp[1716],r8
80009fac:	c0 48       	rjmp	80009fb4 <_vfprintf_r+0x1090>
80009fae:	72 06       	ld.w	r6,r9[0x0]
80009fb0:	2f c9       	sub	r9,-4
80009fb2:	51 09       	stdsp	sp[0x40],r9
80009fb4:	40 2c       	lddsp	r12,sp[0x8]
80009fb6:	58 0c       	cp.w	r12,0
80009fb8:	c1 05       	brlt	80009fd8 <_vfprintf_r+0x10b4>
80009fba:	18 9a       	mov	r10,r12
80009fbc:	30 0b       	mov	r11,0
80009fbe:	0c 9c       	mov	r12,r6
80009fc0:	e0 a0 12 38 	rcall	8000c430 <memchr>
80009fc4:	e0 80 02 df 	breq	8000a582 <_vfprintf_r+0x165e>
80009fc8:	f8 06 01 02 	sub	r2,r12,r6
80009fcc:	40 2b       	lddsp	r11,sp[0x8]
80009fce:	16 32       	cp.w	r2,r11
80009fd0:	e0 89 02 d9 	brgt	8000a582 <_vfprintf_r+0x165e>
80009fd4:	e0 8f 02 d4 	bral	8000a57c <_vfprintf_r+0x1658>
80009fd8:	30 0a       	mov	r10,0
80009fda:	0c 9c       	mov	r12,r6
80009fdc:	50 2a       	stdsp	sp[0x8],r10
80009fde:	e0 a0 15 99 	rcall	8000cb10 <strlen>
80009fe2:	18 92       	mov	r2,r12
80009fe4:	e0 8f 02 d2 	bral	8000a588 <_vfprintf_r+0x1664>
80009fe8:	50 a7       	stdsp	sp[0x28],r7
80009fea:	50 80       	stdsp	sp[0x20],r0
80009fec:	0c 97       	mov	r7,r6
80009fee:	04 94       	mov	r4,r2
80009ff0:	06 96       	mov	r6,r3
80009ff2:	02 92       	mov	r2,r1
80009ff4:	40 93       	lddsp	r3,sp[0x24]
80009ff6:	10 90       	mov	r0,r8
80009ff8:	40 41       	lddsp	r1,sp[0x10]
80009ffa:	a5 a5       	sbr	r5,0x4
80009ffc:	c0 a8       	rjmp	8000a010 <_vfprintf_r+0x10ec>
80009ffe:	50 a7       	stdsp	sp[0x28],r7
8000a000:	50 80       	stdsp	sp[0x20],r0
8000a002:	0c 97       	mov	r7,r6
8000a004:	04 94       	mov	r4,r2
8000a006:	06 96       	mov	r6,r3
8000a008:	02 92       	mov	r2,r1
8000a00a:	40 93       	lddsp	r3,sp[0x24]
8000a00c:	10 90       	mov	r0,r8
8000a00e:	40 41       	lddsp	r1,sp[0x10]
8000a010:	ed b5 00 05 	bld	r5,0x5
8000a014:	c5 61       	brne	8000a0c0 <_vfprintf_r+0x119c>
8000a016:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000a01a:	40 39       	lddsp	r9,sp[0xc]
8000a01c:	58 09       	cp.w	r9,0
8000a01e:	c2 10       	breq	8000a060 <_vfprintf_r+0x113c>
8000a020:	10 36       	cp.w	r6,r8
8000a022:	c0 74       	brge	8000a030 <_vfprintf_r+0x110c>
8000a024:	fa c8 f9 44 	sub	r8,sp,-1724
8000a028:	f0 06 00 36 	add	r6,r8,r6<<0x3
8000a02c:	c2 38       	rjmp	8000a072 <_vfprintf_r+0x114e>
8000a02e:	d7 03       	nop
8000a030:	fa c8 f9 50 	sub	r8,sp,-1712
8000a034:	1a d8       	st.w	--sp,r8
8000a036:	fa c8 fa b8 	sub	r8,sp,-1352
8000a03a:	1a d8       	st.w	--sp,r8
8000a03c:	fa c8 fb b4 	sub	r8,sp,-1100
8000a040:	1a d8       	st.w	--sp,r8
8000a042:	fa c8 f9 40 	sub	r8,sp,-1728
8000a046:	fa c9 ff b4 	sub	r9,sp,-76
8000a04a:	04 9a       	mov	r10,r2
8000a04c:	0c 9b       	mov	r11,r6
8000a04e:	08 9c       	mov	r12,r4
8000a050:	fe b0 f5 d2 	rcall	80008bf4 <get_arg>
8000a054:	2f dd       	sub	sp,-12
8000a056:	f8 e8 00 00 	ld.d	r8,r12[0]
8000a05a:	fa e9 00 00 	st.d	sp[0],r8
8000a05e:	c2 e8       	rjmp	8000a0ba <_vfprintf_r+0x1196>
8000a060:	ee ca ff ff 	sub	r10,r7,-1
8000a064:	10 37       	cp.w	r7,r8
8000a066:	c0 b4       	brge	8000a07c <_vfprintf_r+0x1158>
8000a068:	fa c8 f9 44 	sub	r8,sp,-1724
8000a06c:	14 97       	mov	r7,r10
8000a06e:	f0 06 00 36 	add	r6,r8,r6<<0x3
8000a072:	ec ea fd 88 	ld.d	r10,r6[-632]
8000a076:	fa eb 00 00 	st.d	sp[0],r10
8000a07a:	c2 08       	rjmp	8000a0ba <_vfprintf_r+0x1196>
8000a07c:	41 09       	lddsp	r9,sp[0x40]
8000a07e:	59 f8       	cp.w	r8,31
8000a080:	e0 89 00 16 	brgt	8000a0ac <_vfprintf_r+0x1188>
8000a084:	f2 e6 00 00 	ld.d	r6,r9[0]
8000a088:	f2 cb ff f8 	sub	r11,r9,-8
8000a08c:	fa e7 00 00 	st.d	sp[0],r6
8000a090:	51 0b       	stdsp	sp[0x40],r11
8000a092:	fa c6 f9 44 	sub	r6,sp,-1724
8000a096:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000a09a:	fa e6 00 00 	ld.d	r6,sp[0]
8000a09e:	f2 e7 fd 88 	st.d	r9[-632],r6
8000a0a2:	2f f8       	sub	r8,-1
8000a0a4:	14 97       	mov	r7,r10
8000a0a6:	fb 48 06 b4 	st.w	sp[1716],r8
8000a0aa:	c0 88       	rjmp	8000a0ba <_vfprintf_r+0x1196>
8000a0ac:	f2 e6 00 00 	ld.d	r6,r9[0]
8000a0b0:	2f 89       	sub	r9,-8
8000a0b2:	fa e7 00 00 	st.d	sp[0],r6
8000a0b6:	51 09       	stdsp	sp[0x40],r9
8000a0b8:	14 97       	mov	r7,r10
8000a0ba:	30 18       	mov	r8,1
8000a0bc:	e0 8f 01 d0 	bral	8000a45c <_vfprintf_r+0x1538>
8000a0c0:	ed b5 00 04 	bld	r5,0x4
8000a0c4:	c1 61       	brne	8000a0f0 <_vfprintf_r+0x11cc>
8000a0c6:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000a0ca:	40 3e       	lddsp	lr,sp[0xc]
8000a0cc:	58 0e       	cp.w	lr,0
8000a0ce:	c0 80       	breq	8000a0de <_vfprintf_r+0x11ba>
8000a0d0:	10 36       	cp.w	r6,r8
8000a0d2:	c6 74       	brge	8000a1a0 <_vfprintf_r+0x127c>
8000a0d4:	fa cc f9 44 	sub	r12,sp,-1724
8000a0d8:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000a0dc:	c8 08       	rjmp	8000a1dc <_vfprintf_r+0x12b8>
8000a0de:	ee ca ff ff 	sub	r10,r7,-1
8000a0e2:	10 37       	cp.w	r7,r8
8000a0e4:	c7 f4       	brge	8000a1e2 <_vfprintf_r+0x12be>
8000a0e6:	fa cb f9 44 	sub	r11,sp,-1724
8000a0ea:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000a0ee:	c7 68       	rjmp	8000a1da <_vfprintf_r+0x12b6>
8000a0f0:	ed b5 00 06 	bld	r5,0x6
8000a0f4:	c4 a1       	brne	8000a188 <_vfprintf_r+0x1264>
8000a0f6:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000a0fa:	40 3c       	lddsp	r12,sp[0xc]
8000a0fc:	58 0c       	cp.w	r12,0
8000a0fe:	c1 d0       	breq	8000a138 <_vfprintf_r+0x1214>
8000a100:	10 36       	cp.w	r6,r8
8000a102:	c0 64       	brge	8000a10e <_vfprintf_r+0x11ea>
8000a104:	fa cb f9 44 	sub	r11,sp,-1724
8000a108:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000a10c:	c1 f8       	rjmp	8000a14a <_vfprintf_r+0x1226>
8000a10e:	fa c8 f9 50 	sub	r8,sp,-1712
8000a112:	1a d8       	st.w	--sp,r8
8000a114:	fa c8 fa b8 	sub	r8,sp,-1352
8000a118:	1a d8       	st.w	--sp,r8
8000a11a:	fa c8 fb b4 	sub	r8,sp,-1100
8000a11e:	1a d8       	st.w	--sp,r8
8000a120:	fa c8 f9 40 	sub	r8,sp,-1728
8000a124:	fa c9 ff b4 	sub	r9,sp,-76
8000a128:	04 9a       	mov	r10,r2
8000a12a:	0c 9b       	mov	r11,r6
8000a12c:	08 9c       	mov	r12,r4
8000a12e:	fe b0 f5 63 	rcall	80008bf4 <get_arg>
8000a132:	2f dd       	sub	sp,-12
8000a134:	98 18       	ld.sh	r8,r12[0x2]
8000a136:	c2 68       	rjmp	8000a182 <_vfprintf_r+0x125e>
8000a138:	ee ca ff ff 	sub	r10,r7,-1
8000a13c:	10 37       	cp.w	r7,r8
8000a13e:	c0 94       	brge	8000a150 <_vfprintf_r+0x122c>
8000a140:	fa c9 f9 44 	sub	r9,sp,-1724
8000a144:	14 97       	mov	r7,r10
8000a146:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000a14a:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000a14e:	c1 a8       	rjmp	8000a182 <_vfprintf_r+0x125e>
8000a150:	41 09       	lddsp	r9,sp[0x40]
8000a152:	59 f8       	cp.w	r8,31
8000a154:	e0 89 00 13 	brgt	8000a17a <_vfprintf_r+0x1256>
8000a158:	f2 cb ff fc 	sub	r11,r9,-4
8000a15c:	51 0b       	stdsp	sp[0x40],r11
8000a15e:	72 09       	ld.w	r9,r9[0x0]
8000a160:	fa c6 f9 44 	sub	r6,sp,-1724
8000a164:	ec 08 00 3b 	add	r11,r6,r8<<0x3
8000a168:	2f f8       	sub	r8,-1
8000a16a:	f7 49 fd 88 	st.w	r11[-632],r9
8000a16e:	fb 48 06 b4 	st.w	sp[1716],r8
8000a172:	14 97       	mov	r7,r10
8000a174:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
8000a178:	c0 58       	rjmp	8000a182 <_vfprintf_r+0x125e>
8000a17a:	92 18       	ld.sh	r8,r9[0x2]
8000a17c:	14 97       	mov	r7,r10
8000a17e:	2f c9       	sub	r9,-4
8000a180:	51 09       	stdsp	sp[0x40],r9
8000a182:	5c 78       	castu.h	r8
8000a184:	50 18       	stdsp	sp[0x4],r8
8000a186:	c4 68       	rjmp	8000a212 <_vfprintf_r+0x12ee>
8000a188:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000a18c:	40 3c       	lddsp	r12,sp[0xc]
8000a18e:	58 0c       	cp.w	r12,0
8000a190:	c1 d0       	breq	8000a1ca <_vfprintf_r+0x12a6>
8000a192:	10 36       	cp.w	r6,r8
8000a194:	c0 64       	brge	8000a1a0 <_vfprintf_r+0x127c>
8000a196:	fa cb f9 44 	sub	r11,sp,-1724
8000a19a:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000a19e:	c1 f8       	rjmp	8000a1dc <_vfprintf_r+0x12b8>
8000a1a0:	fa c8 f9 50 	sub	r8,sp,-1712
8000a1a4:	1a d8       	st.w	--sp,r8
8000a1a6:	fa c8 fa b8 	sub	r8,sp,-1352
8000a1aa:	0c 9b       	mov	r11,r6
8000a1ac:	1a d8       	st.w	--sp,r8
8000a1ae:	fa c8 fb b4 	sub	r8,sp,-1100
8000a1b2:	04 9a       	mov	r10,r2
8000a1b4:	1a d8       	st.w	--sp,r8
8000a1b6:	08 9c       	mov	r12,r4
8000a1b8:	fa c8 f9 40 	sub	r8,sp,-1728
8000a1bc:	fa c9 ff b4 	sub	r9,sp,-76
8000a1c0:	fe b0 f5 1a 	rcall	80008bf4 <get_arg>
8000a1c4:	2f dd       	sub	sp,-12
8000a1c6:	78 0b       	ld.w	r11,r12[0x0]
8000a1c8:	c2 48       	rjmp	8000a210 <_vfprintf_r+0x12ec>
8000a1ca:	ee ca ff ff 	sub	r10,r7,-1
8000a1ce:	10 37       	cp.w	r7,r8
8000a1d0:	c0 94       	brge	8000a1e2 <_vfprintf_r+0x12be>
8000a1d2:	fa c9 f9 44 	sub	r9,sp,-1724
8000a1d6:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000a1da:	14 97       	mov	r7,r10
8000a1dc:	ec fb fd 88 	ld.w	r11,r6[-632]
8000a1e0:	c1 88       	rjmp	8000a210 <_vfprintf_r+0x12ec>
8000a1e2:	41 09       	lddsp	r9,sp[0x40]
8000a1e4:	59 f8       	cp.w	r8,31
8000a1e6:	e0 89 00 11 	brgt	8000a208 <_vfprintf_r+0x12e4>
8000a1ea:	f2 cb ff fc 	sub	r11,r9,-4
8000a1ee:	51 0b       	stdsp	sp[0x40],r11
8000a1f0:	fa c6 f9 44 	sub	r6,sp,-1724
8000a1f4:	72 0b       	ld.w	r11,r9[0x0]
8000a1f6:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000a1fa:	f3 4b fd 88 	st.w	r9[-632],r11
8000a1fe:	2f f8       	sub	r8,-1
8000a200:	14 97       	mov	r7,r10
8000a202:	fb 48 06 b4 	st.w	sp[1716],r8
8000a206:	c0 58       	rjmp	8000a210 <_vfprintf_r+0x12ec>
8000a208:	72 0b       	ld.w	r11,r9[0x0]
8000a20a:	14 97       	mov	r7,r10
8000a20c:	2f c9       	sub	r9,-4
8000a20e:	51 09       	stdsp	sp[0x40],r9
8000a210:	50 1b       	stdsp	sp[0x4],r11
8000a212:	30 0e       	mov	lr,0
8000a214:	30 18       	mov	r8,1
8000a216:	50 0e       	stdsp	sp[0x0],lr
8000a218:	c2 29       	rjmp	8000a45c <_vfprintf_r+0x1538>
8000a21a:	50 a7       	stdsp	sp[0x28],r7
8000a21c:	50 80       	stdsp	sp[0x20],r0
8000a21e:	0c 97       	mov	r7,r6
8000a220:	04 94       	mov	r4,r2
8000a222:	06 96       	mov	r6,r3
8000a224:	02 92       	mov	r2,r1
8000a226:	fe cc b0 c2 	sub	r12,pc,-20286
8000a22a:	40 93       	lddsp	r3,sp[0x24]
8000a22c:	10 90       	mov	r0,r8
8000a22e:	40 41       	lddsp	r1,sp[0x10]
8000a230:	50 dc       	stdsp	sp[0x34],r12
8000a232:	ed b5 00 05 	bld	r5,0x5
8000a236:	c5 51       	brne	8000a2e0 <_vfprintf_r+0x13bc>
8000a238:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000a23c:	40 3b       	lddsp	r11,sp[0xc]
8000a23e:	58 0b       	cp.w	r11,0
8000a240:	c2 20       	breq	8000a284 <_vfprintf_r+0x1360>
8000a242:	10 36       	cp.w	r6,r8
8000a244:	c0 a4       	brge	8000a258 <_vfprintf_r+0x1334>
8000a246:	fa ca f9 44 	sub	r10,sp,-1724
8000a24a:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000a24e:	ec e8 fd 88 	ld.d	r8,r6[-632]
8000a252:	fa e9 00 00 	st.d	sp[0],r8
8000a256:	cf 28       	rjmp	8000a43a <_vfprintf_r+0x1516>
8000a258:	fa c8 f9 50 	sub	r8,sp,-1712
8000a25c:	1a d8       	st.w	--sp,r8
8000a25e:	fa c8 fa b8 	sub	r8,sp,-1352
8000a262:	04 9a       	mov	r10,r2
8000a264:	1a d8       	st.w	--sp,r8
8000a266:	0c 9b       	mov	r11,r6
8000a268:	fa c8 fb b4 	sub	r8,sp,-1100
8000a26c:	08 9c       	mov	r12,r4
8000a26e:	1a d8       	st.w	--sp,r8
8000a270:	fa c8 f9 40 	sub	r8,sp,-1728
8000a274:	fa c9 ff b4 	sub	r9,sp,-76
8000a278:	fe b0 f4 be 	rcall	80008bf4 <get_arg>
8000a27c:	2f dd       	sub	sp,-12
8000a27e:	f8 ea 00 00 	ld.d	r10,r12[0]
8000a282:	c0 c8       	rjmp	8000a29a <_vfprintf_r+0x1376>
8000a284:	ee ca ff ff 	sub	r10,r7,-1
8000a288:	10 37       	cp.w	r7,r8
8000a28a:	c0 b4       	brge	8000a2a0 <_vfprintf_r+0x137c>
8000a28c:	fa c9 f9 44 	sub	r9,sp,-1724
8000a290:	14 97       	mov	r7,r10
8000a292:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000a296:	ec ea fd 88 	ld.d	r10,r6[-632]
8000a29a:	fa eb 00 00 	st.d	sp[0],r10
8000a29e:	cc e8       	rjmp	8000a43a <_vfprintf_r+0x1516>
8000a2a0:	41 09       	lddsp	r9,sp[0x40]
8000a2a2:	59 f8       	cp.w	r8,31
8000a2a4:	e0 89 00 16 	brgt	8000a2d0 <_vfprintf_r+0x13ac>
8000a2a8:	f2 e6 00 00 	ld.d	r6,r9[0]
8000a2ac:	f2 cb ff f8 	sub	r11,r9,-8
8000a2b0:	fa e7 00 00 	st.d	sp[0],r6
8000a2b4:	51 0b       	stdsp	sp[0x40],r11
8000a2b6:	fa c6 f9 44 	sub	r6,sp,-1724
8000a2ba:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000a2be:	fa e6 00 00 	ld.d	r6,sp[0]
8000a2c2:	f2 e7 fd 88 	st.d	r9[-632],r6
8000a2c6:	2f f8       	sub	r8,-1
8000a2c8:	14 97       	mov	r7,r10
8000a2ca:	fb 48 06 b4 	st.w	sp[1716],r8
8000a2ce:	cb 68       	rjmp	8000a43a <_vfprintf_r+0x1516>
8000a2d0:	f2 e6 00 00 	ld.d	r6,r9[0]
8000a2d4:	2f 89       	sub	r9,-8
8000a2d6:	fa e7 00 00 	st.d	sp[0],r6
8000a2da:	51 09       	stdsp	sp[0x40],r9
8000a2dc:	14 97       	mov	r7,r10
8000a2de:	ca e8       	rjmp	8000a43a <_vfprintf_r+0x1516>
8000a2e0:	ed b5 00 04 	bld	r5,0x4
8000a2e4:	c1 71       	brne	8000a312 <_vfprintf_r+0x13ee>
8000a2e6:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000a2ea:	40 3e       	lddsp	lr,sp[0xc]
8000a2ec:	58 0e       	cp.w	lr,0
8000a2ee:	c0 80       	breq	8000a2fe <_vfprintf_r+0x13da>
8000a2f0:	10 36       	cp.w	r6,r8
8000a2f2:	c6 94       	brge	8000a3c4 <_vfprintf_r+0x14a0>
8000a2f4:	fa cc f9 44 	sub	r12,sp,-1724
8000a2f8:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000a2fc:	c8 28       	rjmp	8000a400 <_vfprintf_r+0x14dc>
8000a2fe:	ee ca ff ff 	sub	r10,r7,-1
8000a302:	10 37       	cp.w	r7,r8
8000a304:	e0 84 00 81 	brge	8000a406 <_vfprintf_r+0x14e2>
8000a308:	fa cb f9 44 	sub	r11,sp,-1724
8000a30c:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000a310:	c7 78       	rjmp	8000a3fe <_vfprintf_r+0x14da>
8000a312:	ed b5 00 06 	bld	r5,0x6
8000a316:	c4 b1       	brne	8000a3ac <_vfprintf_r+0x1488>
8000a318:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000a31c:	40 3c       	lddsp	r12,sp[0xc]
8000a31e:	58 0c       	cp.w	r12,0
8000a320:	c1 d0       	breq	8000a35a <_vfprintf_r+0x1436>
8000a322:	10 36       	cp.w	r6,r8
8000a324:	c0 64       	brge	8000a330 <_vfprintf_r+0x140c>
8000a326:	fa cb f9 44 	sub	r11,sp,-1724
8000a32a:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000a32e:	c1 f8       	rjmp	8000a36c <_vfprintf_r+0x1448>
8000a330:	fa c8 f9 50 	sub	r8,sp,-1712
8000a334:	1a d8       	st.w	--sp,r8
8000a336:	fa c8 fa b8 	sub	r8,sp,-1352
8000a33a:	1a d8       	st.w	--sp,r8
8000a33c:	fa c8 fb b4 	sub	r8,sp,-1100
8000a340:	1a d8       	st.w	--sp,r8
8000a342:	fa c8 f9 40 	sub	r8,sp,-1728
8000a346:	fa c9 ff b4 	sub	r9,sp,-76
8000a34a:	04 9a       	mov	r10,r2
8000a34c:	0c 9b       	mov	r11,r6
8000a34e:	08 9c       	mov	r12,r4
8000a350:	fe b0 f4 52 	rcall	80008bf4 <get_arg>
8000a354:	2f dd       	sub	sp,-12
8000a356:	98 18       	ld.sh	r8,r12[0x2]
8000a358:	c2 78       	rjmp	8000a3a6 <_vfprintf_r+0x1482>
8000a35a:	ee ca ff ff 	sub	r10,r7,-1
8000a35e:	10 37       	cp.w	r7,r8
8000a360:	c0 a4       	brge	8000a374 <_vfprintf_r+0x1450>
8000a362:	fa c9 f9 44 	sub	r9,sp,-1724
8000a366:	14 97       	mov	r7,r10
8000a368:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000a36c:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000a370:	c1 b8       	rjmp	8000a3a6 <_vfprintf_r+0x1482>
8000a372:	d7 03       	nop
8000a374:	41 09       	lddsp	r9,sp[0x40]
8000a376:	59 f8       	cp.w	r8,31
8000a378:	e0 89 00 13 	brgt	8000a39e <_vfprintf_r+0x147a>
8000a37c:	f2 cb ff fc 	sub	r11,r9,-4
8000a380:	51 0b       	stdsp	sp[0x40],r11
8000a382:	72 09       	ld.w	r9,r9[0x0]
8000a384:	fa c6 f9 44 	sub	r6,sp,-1724
8000a388:	ec 08 00 3b 	add	r11,r6,r8<<0x3
8000a38c:	2f f8       	sub	r8,-1
8000a38e:	f7 49 fd 88 	st.w	r11[-632],r9
8000a392:	fb 48 06 b4 	st.w	sp[1716],r8
8000a396:	14 97       	mov	r7,r10
8000a398:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
8000a39c:	c0 58       	rjmp	8000a3a6 <_vfprintf_r+0x1482>
8000a39e:	92 18       	ld.sh	r8,r9[0x2]
8000a3a0:	14 97       	mov	r7,r10
8000a3a2:	2f c9       	sub	r9,-4
8000a3a4:	51 09       	stdsp	sp[0x40],r9
8000a3a6:	5c 78       	castu.h	r8
8000a3a8:	50 18       	stdsp	sp[0x4],r8
8000a3aa:	c4 68       	rjmp	8000a436 <_vfprintf_r+0x1512>
8000a3ac:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000a3b0:	40 3c       	lddsp	r12,sp[0xc]
8000a3b2:	58 0c       	cp.w	r12,0
8000a3b4:	c1 d0       	breq	8000a3ee <_vfprintf_r+0x14ca>
8000a3b6:	10 36       	cp.w	r6,r8
8000a3b8:	c0 64       	brge	8000a3c4 <_vfprintf_r+0x14a0>
8000a3ba:	fa cb f9 44 	sub	r11,sp,-1724
8000a3be:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000a3c2:	c1 f8       	rjmp	8000a400 <_vfprintf_r+0x14dc>
8000a3c4:	fa c8 f9 50 	sub	r8,sp,-1712
8000a3c8:	1a d8       	st.w	--sp,r8
8000a3ca:	fa c8 fa b8 	sub	r8,sp,-1352
8000a3ce:	0c 9b       	mov	r11,r6
8000a3d0:	1a d8       	st.w	--sp,r8
8000a3d2:	fa c8 fb b4 	sub	r8,sp,-1100
8000a3d6:	04 9a       	mov	r10,r2
8000a3d8:	1a d8       	st.w	--sp,r8
8000a3da:	08 9c       	mov	r12,r4
8000a3dc:	fa c8 f9 40 	sub	r8,sp,-1728
8000a3e0:	fa c9 ff b4 	sub	r9,sp,-76
8000a3e4:	fe b0 f4 08 	rcall	80008bf4 <get_arg>
8000a3e8:	2f dd       	sub	sp,-12
8000a3ea:	78 0b       	ld.w	r11,r12[0x0]
8000a3ec:	c2 48       	rjmp	8000a434 <_vfprintf_r+0x1510>
8000a3ee:	ee ca ff ff 	sub	r10,r7,-1
8000a3f2:	10 37       	cp.w	r7,r8
8000a3f4:	c0 94       	brge	8000a406 <_vfprintf_r+0x14e2>
8000a3f6:	fa c9 f9 44 	sub	r9,sp,-1724
8000a3fa:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000a3fe:	14 97       	mov	r7,r10
8000a400:	ec fb fd 88 	ld.w	r11,r6[-632]
8000a404:	c1 88       	rjmp	8000a434 <_vfprintf_r+0x1510>
8000a406:	41 09       	lddsp	r9,sp[0x40]
8000a408:	59 f8       	cp.w	r8,31
8000a40a:	e0 89 00 11 	brgt	8000a42c <_vfprintf_r+0x1508>
8000a40e:	f2 cb ff fc 	sub	r11,r9,-4
8000a412:	51 0b       	stdsp	sp[0x40],r11
8000a414:	fa c6 f9 44 	sub	r6,sp,-1724
8000a418:	72 0b       	ld.w	r11,r9[0x0]
8000a41a:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000a41e:	f3 4b fd 88 	st.w	r9[-632],r11
8000a422:	2f f8       	sub	r8,-1
8000a424:	14 97       	mov	r7,r10
8000a426:	fb 48 06 b4 	st.w	sp[1716],r8
8000a42a:	c0 58       	rjmp	8000a434 <_vfprintf_r+0x1510>
8000a42c:	72 0b       	ld.w	r11,r9[0x0]
8000a42e:	14 97       	mov	r7,r10
8000a430:	2f c9       	sub	r9,-4
8000a432:	51 09       	stdsp	sp[0x40],r9
8000a434:	50 1b       	stdsp	sp[0x4],r11
8000a436:	30 0e       	mov	lr,0
8000a438:	50 0e       	stdsp	sp[0x0],lr
8000a43a:	40 08       	lddsp	r8,sp[0x0]
8000a43c:	40 1c       	lddsp	r12,sp[0x4]
8000a43e:	18 48       	or	r8,r12
8000a440:	5f 19       	srne	r9
8000a442:	0a 98       	mov	r8,r5
8000a444:	eb e9 00 09 	and	r9,r5,r9
8000a448:	a1 b8       	sbr	r8,0x1
8000a44a:	58 09       	cp.w	r9,0
8000a44c:	c0 70       	breq	8000a45a <_vfprintf_r+0x1536>
8000a44e:	10 95       	mov	r5,r8
8000a450:	fb 60 06 b9 	st.b	sp[1721],r0
8000a454:	33 08       	mov	r8,48
8000a456:	fb 68 06 b8 	st.b	sp[1720],r8
8000a45a:	30 28       	mov	r8,2
8000a45c:	30 09       	mov	r9,0
8000a45e:	fb 69 06 bb 	st.b	sp[1723],r9
8000a462:	0a 99       	mov	r9,r5
8000a464:	a7 d9       	cbr	r9,0x7
8000a466:	40 2b       	lddsp	r11,sp[0x8]
8000a468:	40 16       	lddsp	r6,sp[0x4]
8000a46a:	58 0b       	cp.w	r11,0
8000a46c:	5f 1a       	srne	r10
8000a46e:	f2 05 17 40 	movge	r5,r9
8000a472:	fa c2 f9 78 	sub	r2,sp,-1672
8000a476:	40 09       	lddsp	r9,sp[0x0]
8000a478:	0c 49       	or	r9,r6
8000a47a:	5f 19       	srne	r9
8000a47c:	f5 e9 10 09 	or	r9,r10,r9
8000a480:	c5 c0       	breq	8000a538 <_vfprintf_r+0x1614>
8000a482:	30 19       	mov	r9,1
8000a484:	f2 08 18 00 	cp.b	r8,r9
8000a488:	c0 60       	breq	8000a494 <_vfprintf_r+0x1570>
8000a48a:	30 29       	mov	r9,2
8000a48c:	f2 08 18 00 	cp.b	r8,r9
8000a490:	c0 41       	brne	8000a498 <_vfprintf_r+0x1574>
8000a492:	c3 c8       	rjmp	8000a50a <_vfprintf_r+0x15e6>
8000a494:	04 96       	mov	r6,r2
8000a496:	c3 08       	rjmp	8000a4f6 <_vfprintf_r+0x15d2>
8000a498:	04 96       	mov	r6,r2
8000a49a:	fa e8 00 00 	ld.d	r8,sp[0]
8000a49e:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
8000a4a2:	2d 0a       	sub	r10,-48
8000a4a4:	0c fa       	st.b	--r6,r10
8000a4a6:	f0 0b 16 03 	lsr	r11,r8,0x3
8000a4aa:	f2 0c 16 03 	lsr	r12,r9,0x3
8000a4ae:	f7 e9 11 db 	or	r11,r11,r9<<0x1d
8000a4b2:	18 99       	mov	r9,r12
8000a4b4:	16 98       	mov	r8,r11
8000a4b6:	58 08       	cp.w	r8,0
8000a4b8:	5c 29       	cpc	r9
8000a4ba:	cf 21       	brne	8000a49e <_vfprintf_r+0x157a>
8000a4bc:	fa e9 00 00 	st.d	sp[0],r8
8000a4c0:	ed b5 00 00 	bld	r5,0x0
8000a4c4:	c4 51       	brne	8000a54e <_vfprintf_r+0x162a>
8000a4c6:	33 09       	mov	r9,48
8000a4c8:	f2 0a 18 00 	cp.b	r10,r9
8000a4cc:	c4 10       	breq	8000a54e <_vfprintf_r+0x162a>
8000a4ce:	0c f9       	st.b	--r6,r9
8000a4d0:	c3 f8       	rjmp	8000a54e <_vfprintf_r+0x162a>
8000a4d2:	fa ea 00 00 	ld.d	r10,sp[0]
8000a4d6:	30 a8       	mov	r8,10
8000a4d8:	30 09       	mov	r9,0
8000a4da:	e0 a0 1a 19 	rcall	8000d90c <__avr32_umod64>
8000a4de:	30 a8       	mov	r8,10
8000a4e0:	2d 0a       	sub	r10,-48
8000a4e2:	30 09       	mov	r9,0
8000a4e4:	ac 8a       	st.b	r6[0x0],r10
8000a4e6:	fa ea 00 00 	ld.d	r10,sp[0]
8000a4ea:	e0 a0 18 df 	rcall	8000d6a8 <__avr32_udiv64>
8000a4ee:	16 99       	mov	r9,r11
8000a4f0:	14 98       	mov	r8,r10
8000a4f2:	fa e9 00 00 	st.d	sp[0],r8
8000a4f6:	20 16       	sub	r6,1
8000a4f8:	fa ea 00 00 	ld.d	r10,sp[0]
8000a4fc:	58 9a       	cp.w	r10,9
8000a4fe:	5c 2b       	cpc	r11
8000a500:	fe 9b ff e9 	brhi	8000a4d2 <_vfprintf_r+0x15ae>
8000a504:	1b f8       	ld.ub	r8,sp[0x7]
8000a506:	2d 08       	sub	r8,-48
8000a508:	c2 08       	rjmp	8000a548 <_vfprintf_r+0x1624>
8000a50a:	04 96       	mov	r6,r2
8000a50c:	fa e8 00 00 	ld.d	r8,sp[0]
8000a510:	f5 d8 c0 04 	bfextu	r10,r8,0x0,0x4
8000a514:	40 de       	lddsp	lr,sp[0x34]
8000a516:	fc 0a 07 0a 	ld.ub	r10,lr[r10]
8000a51a:	0c fa       	st.b	--r6,r10
8000a51c:	f2 0b 16 04 	lsr	r11,r9,0x4
8000a520:	f0 0a 16 04 	lsr	r10,r8,0x4
8000a524:	f5 e9 11 ca 	or	r10,r10,r9<<0x1c
8000a528:	16 99       	mov	r9,r11
8000a52a:	14 98       	mov	r8,r10
8000a52c:	58 08       	cp.w	r8,0
8000a52e:	5c 29       	cpc	r9
8000a530:	cf 01       	brne	8000a510 <_vfprintf_r+0x15ec>
8000a532:	fa e9 00 00 	st.d	sp[0],r8
8000a536:	c0 c8       	rjmp	8000a54e <_vfprintf_r+0x162a>
8000a538:	58 08       	cp.w	r8,0
8000a53a:	c0 91       	brne	8000a54c <_vfprintf_r+0x1628>
8000a53c:	ed b5 00 00 	bld	r5,0x0
8000a540:	c0 61       	brne	8000a54c <_vfprintf_r+0x1628>
8000a542:	fa c6 f9 79 	sub	r6,sp,-1671
8000a546:	33 08       	mov	r8,48
8000a548:	ac 88       	st.b	r6[0x0],r8
8000a54a:	c0 28       	rjmp	8000a54e <_vfprintf_r+0x162a>
8000a54c:	04 96       	mov	r6,r2
8000a54e:	0c 12       	sub	r2,r6
8000a550:	c1 c8       	rjmp	8000a588 <_vfprintf_r+0x1664>
8000a552:	50 a7       	stdsp	sp[0x28],r7
8000a554:	50 80       	stdsp	sp[0x20],r0
8000a556:	40 93       	lddsp	r3,sp[0x24]
8000a558:	0c 97       	mov	r7,r6
8000a55a:	10 90       	mov	r0,r8
8000a55c:	04 94       	mov	r4,r2
8000a55e:	40 41       	lddsp	r1,sp[0x10]
8000a560:	58 08       	cp.w	r8,0
8000a562:	e0 80 04 4f 	breq	8000ae00 <_vfprintf_r+0x1edc>
8000a566:	fb 68 06 60 	st.b	sp[1632],r8
8000a56a:	30 0c       	mov	r12,0
8000a56c:	30 08       	mov	r8,0
8000a56e:	30 12       	mov	r2,1
8000a570:	fb 68 06 bb 	st.b	sp[1723],r8
8000a574:	50 2c       	stdsp	sp[0x8],r12
8000a576:	fa c6 f9 a0 	sub	r6,sp,-1632
8000a57a:	c0 78       	rjmp	8000a588 <_vfprintf_r+0x1664>
8000a57c:	30 0b       	mov	r11,0
8000a57e:	50 2b       	stdsp	sp[0x8],r11
8000a580:	c0 48       	rjmp	8000a588 <_vfprintf_r+0x1664>
8000a582:	40 22       	lddsp	r2,sp[0x8]
8000a584:	30 0a       	mov	r10,0
8000a586:	50 2a       	stdsp	sp[0x8],r10
8000a588:	40 29       	lddsp	r9,sp[0x8]
8000a58a:	e4 09 0c 49 	max	r9,r2,r9
8000a58e:	fb 38 06 bb 	ld.ub	r8,sp[1723]
8000a592:	50 39       	stdsp	sp[0xc],r9
8000a594:	0a 9e       	mov	lr,r5
8000a596:	30 09       	mov	r9,0
8000a598:	e2 1e 00 02 	andl	lr,0x2,COH
8000a59c:	f2 08 18 00 	cp.b	r8,r9
8000a5a0:	fb f8 10 03 	ld.wne	r8,sp[0xc]
8000a5a4:	f7 b8 01 ff 	subne	r8,-1
8000a5a8:	fb f8 1a 03 	st.wne	sp[0xc],r8
8000a5ac:	0a 9b       	mov	r11,r5
8000a5ae:	58 0e       	cp.w	lr,0
8000a5b0:	fb fc 10 03 	ld.wne	r12,sp[0xc]
8000a5b4:	f7 bc 01 fe 	subne	r12,-2
8000a5b8:	fb fc 1a 03 	st.wne	sp[0xc],r12
8000a5bc:	e2 1b 00 84 	andl	r11,0x84,COH
8000a5c0:	50 fe       	stdsp	sp[0x3c],lr
8000a5c2:	50 9b       	stdsp	sp[0x24],r11
8000a5c4:	c4 71       	brne	8000a652 <_vfprintf_r+0x172e>
8000a5c6:	40 8a       	lddsp	r10,sp[0x20]
8000a5c8:	40 39       	lddsp	r9,sp[0xc]
8000a5ca:	12 1a       	sub	r10,r9
8000a5cc:	50 4a       	stdsp	sp[0x10],r10
8000a5ce:	58 0a       	cp.w	r10,0
8000a5d0:	e0 89 00 20 	brgt	8000a610 <_vfprintf_r+0x16ec>
8000a5d4:	c3 f8       	rjmp	8000a652 <_vfprintf_r+0x172e>
8000a5d6:	2f 09       	sub	r9,-16
8000a5d8:	2f f8       	sub	r8,-1
8000a5da:	fe ce b4 5e 	sub	lr,pc,-19362
8000a5de:	31 0c       	mov	r12,16
8000a5e0:	fb 49 06 90 	st.w	sp[1680],r9
8000a5e4:	87 0e       	st.w	r3[0x0],lr
8000a5e6:	87 1c       	st.w	r3[0x4],r12
8000a5e8:	fb 48 06 8c 	st.w	sp[1676],r8
8000a5ec:	58 78       	cp.w	r8,7
8000a5ee:	e0 89 00 04 	brgt	8000a5f6 <_vfprintf_r+0x16d2>
8000a5f2:	2f 83       	sub	r3,-8
8000a5f4:	c0 b8       	rjmp	8000a60a <_vfprintf_r+0x16e6>
8000a5f6:	fa ca f9 78 	sub	r10,sp,-1672
8000a5fa:	02 9b       	mov	r11,r1
8000a5fc:	08 9c       	mov	r12,r4
8000a5fe:	fe b0 f4 85 	rcall	80008f08 <__sprint_r>
8000a602:	e0 81 04 10 	brne	8000ae22 <_vfprintf_r+0x1efe>
8000a606:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a60a:	40 4b       	lddsp	r11,sp[0x10]
8000a60c:	21 0b       	sub	r11,16
8000a60e:	50 4b       	stdsp	sp[0x10],r11
8000a610:	fa f9 06 90 	ld.w	r9,sp[1680]
8000a614:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a618:	fe ca b4 9c 	sub	r10,pc,-19300
8000a61c:	40 4e       	lddsp	lr,sp[0x10]
8000a61e:	59 0e       	cp.w	lr,16
8000a620:	fe 99 ff db 	brgt	8000a5d6 <_vfprintf_r+0x16b2>
8000a624:	1c 09       	add	r9,lr
8000a626:	2f f8       	sub	r8,-1
8000a628:	87 0a       	st.w	r3[0x0],r10
8000a62a:	fb 49 06 90 	st.w	sp[1680],r9
8000a62e:	87 1e       	st.w	r3[0x4],lr
8000a630:	fb 48 06 8c 	st.w	sp[1676],r8
8000a634:	58 78       	cp.w	r8,7
8000a636:	e0 89 00 04 	brgt	8000a63e <_vfprintf_r+0x171a>
8000a63a:	2f 83       	sub	r3,-8
8000a63c:	c0 b8       	rjmp	8000a652 <_vfprintf_r+0x172e>
8000a63e:	fa ca f9 78 	sub	r10,sp,-1672
8000a642:	02 9b       	mov	r11,r1
8000a644:	08 9c       	mov	r12,r4
8000a646:	fe b0 f4 61 	rcall	80008f08 <__sprint_r>
8000a64a:	e0 81 03 ec 	brne	8000ae22 <_vfprintf_r+0x1efe>
8000a64e:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a652:	30 09       	mov	r9,0
8000a654:	fb 38 06 bb 	ld.ub	r8,sp[1723]
8000a658:	f2 08 18 00 	cp.b	r8,r9
8000a65c:	c1 f0       	breq	8000a69a <_vfprintf_r+0x1776>
8000a65e:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a662:	fa c9 f9 45 	sub	r9,sp,-1723
8000a666:	2f f8       	sub	r8,-1
8000a668:	87 09       	st.w	r3[0x0],r9
8000a66a:	fb 48 06 90 	st.w	sp[1680],r8
8000a66e:	30 19       	mov	r9,1
8000a670:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a674:	87 19       	st.w	r3[0x4],r9
8000a676:	2f f8       	sub	r8,-1
8000a678:	fb 48 06 8c 	st.w	sp[1676],r8
8000a67c:	58 78       	cp.w	r8,7
8000a67e:	e0 89 00 04 	brgt	8000a686 <_vfprintf_r+0x1762>
8000a682:	2f 83       	sub	r3,-8
8000a684:	c0 b8       	rjmp	8000a69a <_vfprintf_r+0x1776>
8000a686:	fa ca f9 78 	sub	r10,sp,-1672
8000a68a:	02 9b       	mov	r11,r1
8000a68c:	08 9c       	mov	r12,r4
8000a68e:	fe b0 f4 3d 	rcall	80008f08 <__sprint_r>
8000a692:	e0 81 03 c8 	brne	8000ae22 <_vfprintf_r+0x1efe>
8000a696:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a69a:	40 fc       	lddsp	r12,sp[0x3c]
8000a69c:	58 0c       	cp.w	r12,0
8000a69e:	c1 f0       	breq	8000a6dc <_vfprintf_r+0x17b8>
8000a6a0:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a6a4:	fa c9 f9 48 	sub	r9,sp,-1720
8000a6a8:	2f e8       	sub	r8,-2
8000a6aa:	87 09       	st.w	r3[0x0],r9
8000a6ac:	fb 48 06 90 	st.w	sp[1680],r8
8000a6b0:	30 29       	mov	r9,2
8000a6b2:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a6b6:	87 19       	st.w	r3[0x4],r9
8000a6b8:	2f f8       	sub	r8,-1
8000a6ba:	fb 48 06 8c 	st.w	sp[1676],r8
8000a6be:	58 78       	cp.w	r8,7
8000a6c0:	e0 89 00 04 	brgt	8000a6c8 <_vfprintf_r+0x17a4>
8000a6c4:	2f 83       	sub	r3,-8
8000a6c6:	c0 b8       	rjmp	8000a6dc <_vfprintf_r+0x17b8>
8000a6c8:	fa ca f9 78 	sub	r10,sp,-1672
8000a6cc:	02 9b       	mov	r11,r1
8000a6ce:	08 9c       	mov	r12,r4
8000a6d0:	fe b0 f4 1c 	rcall	80008f08 <__sprint_r>
8000a6d4:	e0 81 03 a7 	brne	8000ae22 <_vfprintf_r+0x1efe>
8000a6d8:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a6dc:	40 9b       	lddsp	r11,sp[0x24]
8000a6de:	e0 4b 00 80 	cp.w	r11,128
8000a6e2:	c4 71       	brne	8000a770 <_vfprintf_r+0x184c>
8000a6e4:	40 8a       	lddsp	r10,sp[0x20]
8000a6e6:	40 39       	lddsp	r9,sp[0xc]
8000a6e8:	12 1a       	sub	r10,r9
8000a6ea:	50 4a       	stdsp	sp[0x10],r10
8000a6ec:	58 0a       	cp.w	r10,0
8000a6ee:	e0 89 00 20 	brgt	8000a72e <_vfprintf_r+0x180a>
8000a6f2:	c3 f8       	rjmp	8000a770 <_vfprintf_r+0x184c>
8000a6f4:	2f 09       	sub	r9,-16
8000a6f6:	2f f8       	sub	r8,-1
8000a6f8:	fe ce b5 6c 	sub	lr,pc,-19092
8000a6fc:	31 0c       	mov	r12,16
8000a6fe:	fb 49 06 90 	st.w	sp[1680],r9
8000a702:	87 0e       	st.w	r3[0x0],lr
8000a704:	87 1c       	st.w	r3[0x4],r12
8000a706:	fb 48 06 8c 	st.w	sp[1676],r8
8000a70a:	58 78       	cp.w	r8,7
8000a70c:	e0 89 00 04 	brgt	8000a714 <_vfprintf_r+0x17f0>
8000a710:	2f 83       	sub	r3,-8
8000a712:	c0 b8       	rjmp	8000a728 <_vfprintf_r+0x1804>
8000a714:	fa ca f9 78 	sub	r10,sp,-1672
8000a718:	02 9b       	mov	r11,r1
8000a71a:	08 9c       	mov	r12,r4
8000a71c:	fe b0 f3 f6 	rcall	80008f08 <__sprint_r>
8000a720:	e0 81 03 81 	brne	8000ae22 <_vfprintf_r+0x1efe>
8000a724:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a728:	40 4b       	lddsp	r11,sp[0x10]
8000a72a:	21 0b       	sub	r11,16
8000a72c:	50 4b       	stdsp	sp[0x10],r11
8000a72e:	fa f9 06 90 	ld.w	r9,sp[1680]
8000a732:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a736:	fe ca b5 aa 	sub	r10,pc,-19030
8000a73a:	40 4e       	lddsp	lr,sp[0x10]
8000a73c:	59 0e       	cp.w	lr,16
8000a73e:	fe 99 ff db 	brgt	8000a6f4 <_vfprintf_r+0x17d0>
8000a742:	1c 09       	add	r9,lr
8000a744:	2f f8       	sub	r8,-1
8000a746:	87 0a       	st.w	r3[0x0],r10
8000a748:	fb 49 06 90 	st.w	sp[1680],r9
8000a74c:	87 1e       	st.w	r3[0x4],lr
8000a74e:	fb 48 06 8c 	st.w	sp[1676],r8
8000a752:	58 78       	cp.w	r8,7
8000a754:	e0 89 00 04 	brgt	8000a75c <_vfprintf_r+0x1838>
8000a758:	2f 83       	sub	r3,-8
8000a75a:	c0 b8       	rjmp	8000a770 <_vfprintf_r+0x184c>
8000a75c:	fa ca f9 78 	sub	r10,sp,-1672
8000a760:	02 9b       	mov	r11,r1
8000a762:	08 9c       	mov	r12,r4
8000a764:	fe b0 f3 d2 	rcall	80008f08 <__sprint_r>
8000a768:	e0 81 03 5d 	brne	8000ae22 <_vfprintf_r+0x1efe>
8000a76c:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a770:	40 2c       	lddsp	r12,sp[0x8]
8000a772:	04 1c       	sub	r12,r2
8000a774:	50 2c       	stdsp	sp[0x8],r12
8000a776:	58 0c       	cp.w	r12,0
8000a778:	e0 89 00 20 	brgt	8000a7b8 <_vfprintf_r+0x1894>
8000a77c:	c3 f8       	rjmp	8000a7fa <_vfprintf_r+0x18d6>
8000a77e:	2f 09       	sub	r9,-16
8000a780:	2f f8       	sub	r8,-1
8000a782:	fe cb b5 f6 	sub	r11,pc,-18954
8000a786:	31 0a       	mov	r10,16
8000a788:	fb 49 06 90 	st.w	sp[1680],r9
8000a78c:	87 0b       	st.w	r3[0x0],r11
8000a78e:	87 1a       	st.w	r3[0x4],r10
8000a790:	fb 48 06 8c 	st.w	sp[1676],r8
8000a794:	58 78       	cp.w	r8,7
8000a796:	e0 89 00 04 	brgt	8000a79e <_vfprintf_r+0x187a>
8000a79a:	2f 83       	sub	r3,-8
8000a79c:	c0 b8       	rjmp	8000a7b2 <_vfprintf_r+0x188e>
8000a79e:	fa ca f9 78 	sub	r10,sp,-1672
8000a7a2:	02 9b       	mov	r11,r1
8000a7a4:	08 9c       	mov	r12,r4
8000a7a6:	fe b0 f3 b1 	rcall	80008f08 <__sprint_r>
8000a7aa:	e0 81 03 3c 	brne	8000ae22 <_vfprintf_r+0x1efe>
8000a7ae:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a7b2:	40 29       	lddsp	r9,sp[0x8]
8000a7b4:	21 09       	sub	r9,16
8000a7b6:	50 29       	stdsp	sp[0x8],r9
8000a7b8:	fa f9 06 90 	ld.w	r9,sp[1680]
8000a7bc:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a7c0:	fe ca b6 34 	sub	r10,pc,-18892
8000a7c4:	40 2e       	lddsp	lr,sp[0x8]
8000a7c6:	59 0e       	cp.w	lr,16
8000a7c8:	fe 99 ff db 	brgt	8000a77e <_vfprintf_r+0x185a>
8000a7cc:	1c 09       	add	r9,lr
8000a7ce:	2f f8       	sub	r8,-1
8000a7d0:	87 0a       	st.w	r3[0x0],r10
8000a7d2:	fb 49 06 90 	st.w	sp[1680],r9
8000a7d6:	87 1e       	st.w	r3[0x4],lr
8000a7d8:	fb 48 06 8c 	st.w	sp[1676],r8
8000a7dc:	58 78       	cp.w	r8,7
8000a7de:	e0 89 00 04 	brgt	8000a7e6 <_vfprintf_r+0x18c2>
8000a7e2:	2f 83       	sub	r3,-8
8000a7e4:	c0 b8       	rjmp	8000a7fa <_vfprintf_r+0x18d6>
8000a7e6:	fa ca f9 78 	sub	r10,sp,-1672
8000a7ea:	02 9b       	mov	r11,r1
8000a7ec:	08 9c       	mov	r12,r4
8000a7ee:	fe b0 f3 8d 	rcall	80008f08 <__sprint_r>
8000a7f2:	e0 81 03 18 	brne	8000ae22 <_vfprintf_r+0x1efe>
8000a7f6:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a7fa:	ed b5 00 08 	bld	r5,0x8
8000a7fe:	c0 b0       	breq	8000a814 <_vfprintf_r+0x18f0>
8000a800:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a804:	87 12       	st.w	r3[0x4],r2
8000a806:	87 06       	st.w	r3[0x0],r6
8000a808:	f0 02 00 02 	add	r2,r8,r2
8000a80c:	fb 42 06 90 	st.w	sp[1680],r2
8000a810:	e0 8f 01 d4 	bral	8000abb8 <_vfprintf_r+0x1c94>
8000a814:	e0 40 00 65 	cp.w	r0,101
8000a818:	e0 8a 01 d6 	brle	8000abc4 <_vfprintf_r+0x1ca0>
8000a81c:	30 08       	mov	r8,0
8000a81e:	30 09       	mov	r9,0
8000a820:	40 5b       	lddsp	r11,sp[0x14]
8000a822:	40 7a       	lddsp	r10,sp[0x1c]
8000a824:	e0 a0 15 3b 	rcall	8000d29a <__avr32_f64_cmp_eq>
8000a828:	c7 90       	breq	8000a91a <_vfprintf_r+0x19f6>
8000a82a:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a82e:	fe c9 b6 b6 	sub	r9,pc,-18762
8000a832:	2f f8       	sub	r8,-1
8000a834:	87 09       	st.w	r3[0x0],r9
8000a836:	fb 48 06 90 	st.w	sp[1680],r8
8000a83a:	30 19       	mov	r9,1
8000a83c:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a840:	87 19       	st.w	r3[0x4],r9
8000a842:	2f f8       	sub	r8,-1
8000a844:	fb 48 06 8c 	st.w	sp[1676],r8
8000a848:	58 78       	cp.w	r8,7
8000a84a:	e0 89 00 05 	brgt	8000a854 <_vfprintf_r+0x1930>
8000a84e:	2f 83       	sub	r3,-8
8000a850:	c0 c8       	rjmp	8000a868 <_vfprintf_r+0x1944>
8000a852:	d7 03       	nop
8000a854:	fa ca f9 78 	sub	r10,sp,-1672
8000a858:	02 9b       	mov	r11,r1
8000a85a:	08 9c       	mov	r12,r4
8000a85c:	fe b0 f3 56 	rcall	80008f08 <__sprint_r>
8000a860:	e0 81 02 e1 	brne	8000ae22 <_vfprintf_r+0x1efe>
8000a864:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a868:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000a86c:	40 6c       	lddsp	r12,sp[0x18]
8000a86e:	18 38       	cp.w	r8,r12
8000a870:	c0 55       	brlt	8000a87a <_vfprintf_r+0x1956>
8000a872:	ed b5 00 00 	bld	r5,0x0
8000a876:	e0 81 02 6b 	brne	8000ad4c <_vfprintf_r+0x1e28>
8000a87a:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a87e:	2f f8       	sub	r8,-1
8000a880:	40 cb       	lddsp	r11,sp[0x30]
8000a882:	fb 48 06 90 	st.w	sp[1680],r8
8000a886:	30 19       	mov	r9,1
8000a888:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a88c:	87 0b       	st.w	r3[0x0],r11
8000a88e:	2f f8       	sub	r8,-1
8000a890:	87 19       	st.w	r3[0x4],r9
8000a892:	fb 48 06 8c 	st.w	sp[1676],r8
8000a896:	58 78       	cp.w	r8,7
8000a898:	e0 89 00 04 	brgt	8000a8a0 <_vfprintf_r+0x197c>
8000a89c:	2f 83       	sub	r3,-8
8000a89e:	c0 b8       	rjmp	8000a8b4 <_vfprintf_r+0x1990>
8000a8a0:	fa ca f9 78 	sub	r10,sp,-1672
8000a8a4:	02 9b       	mov	r11,r1
8000a8a6:	08 9c       	mov	r12,r4
8000a8a8:	fe b0 f3 30 	rcall	80008f08 <__sprint_r>
8000a8ac:	e0 81 02 bb 	brne	8000ae22 <_vfprintf_r+0x1efe>
8000a8b0:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a8b4:	40 66       	lddsp	r6,sp[0x18]
8000a8b6:	20 16       	sub	r6,1
8000a8b8:	58 06       	cp.w	r6,0
8000a8ba:	e0 89 00 1d 	brgt	8000a8f4 <_vfprintf_r+0x19d0>
8000a8be:	e0 8f 02 47 	bral	8000ad4c <_vfprintf_r+0x1e28>
8000a8c2:	2f 09       	sub	r9,-16
8000a8c4:	2f f8       	sub	r8,-1
8000a8c6:	fb 49 06 90 	st.w	sp[1680],r9
8000a8ca:	87 02       	st.w	r3[0x0],r2
8000a8cc:	87 10       	st.w	r3[0x4],r0
8000a8ce:	fb 48 06 8c 	st.w	sp[1676],r8
8000a8d2:	58 78       	cp.w	r8,7
8000a8d4:	e0 89 00 04 	brgt	8000a8dc <_vfprintf_r+0x19b8>
8000a8d8:	2f 83       	sub	r3,-8
8000a8da:	c0 b8       	rjmp	8000a8f0 <_vfprintf_r+0x19cc>
8000a8dc:	fa ca f9 78 	sub	r10,sp,-1672
8000a8e0:	02 9b       	mov	r11,r1
8000a8e2:	08 9c       	mov	r12,r4
8000a8e4:	fe b0 f3 12 	rcall	80008f08 <__sprint_r>
8000a8e8:	e0 81 02 9d 	brne	8000ae22 <_vfprintf_r+0x1efe>
8000a8ec:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a8f0:	21 06       	sub	r6,16
8000a8f2:	c0 48       	rjmp	8000a8fa <_vfprintf_r+0x19d6>
8000a8f4:	fe c2 b7 68 	sub	r2,pc,-18584
8000a8f8:	31 00       	mov	r0,16
8000a8fa:	fa f9 06 90 	ld.w	r9,sp[1680]
8000a8fe:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a902:	fe ca b7 76 	sub	r10,pc,-18570
8000a906:	59 06       	cp.w	r6,16
8000a908:	fe 99 ff dd 	brgt	8000a8c2 <_vfprintf_r+0x199e>
8000a90c:	0c 09       	add	r9,r6
8000a90e:	87 0a       	st.w	r3[0x0],r10
8000a910:	fb 49 06 90 	st.w	sp[1680],r9
8000a914:	2f f8       	sub	r8,-1
8000a916:	87 16       	st.w	r3[0x4],r6
8000a918:	c5 39       	rjmp	8000abbe <_vfprintf_r+0x1c9a>
8000a91a:	fa fa 06 ac 	ld.w	r10,sp[1708]
8000a91e:	58 0a       	cp.w	r10,0
8000a920:	e0 89 00 92 	brgt	8000aa44 <_vfprintf_r+0x1b20>
8000a924:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a928:	fe c9 b7 b0 	sub	r9,pc,-18512
8000a92c:	2f f8       	sub	r8,-1
8000a92e:	87 09       	st.w	r3[0x0],r9
8000a930:	fb 48 06 90 	st.w	sp[1680],r8
8000a934:	30 19       	mov	r9,1
8000a936:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a93a:	87 19       	st.w	r3[0x4],r9
8000a93c:	2f f8       	sub	r8,-1
8000a93e:	fb 48 06 8c 	st.w	sp[1676],r8
8000a942:	58 78       	cp.w	r8,7
8000a944:	e0 89 00 04 	brgt	8000a94c <_vfprintf_r+0x1a28>
8000a948:	2f 83       	sub	r3,-8
8000a94a:	c0 b8       	rjmp	8000a960 <_vfprintf_r+0x1a3c>
8000a94c:	fa ca f9 78 	sub	r10,sp,-1672
8000a950:	02 9b       	mov	r11,r1
8000a952:	08 9c       	mov	r12,r4
8000a954:	fe b0 f2 da 	rcall	80008f08 <__sprint_r>
8000a958:	e0 81 02 65 	brne	8000ae22 <_vfprintf_r+0x1efe>
8000a95c:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a960:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000a964:	58 08       	cp.w	r8,0
8000a966:	c0 81       	brne	8000a976 <_vfprintf_r+0x1a52>
8000a968:	40 6a       	lddsp	r10,sp[0x18]
8000a96a:	58 0a       	cp.w	r10,0
8000a96c:	c0 51       	brne	8000a976 <_vfprintf_r+0x1a52>
8000a96e:	ed b5 00 00 	bld	r5,0x0
8000a972:	e0 81 01 ed 	brne	8000ad4c <_vfprintf_r+0x1e28>
8000a976:	40 c9       	lddsp	r9,sp[0x30]
8000a978:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a97c:	2f f8       	sub	r8,-1
8000a97e:	87 09       	st.w	r3[0x0],r9
8000a980:	fb 48 06 90 	st.w	sp[1680],r8
8000a984:	30 19       	mov	r9,1
8000a986:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a98a:	87 19       	st.w	r3[0x4],r9
8000a98c:	2f f8       	sub	r8,-1
8000a98e:	fb 48 06 8c 	st.w	sp[1676],r8
8000a992:	58 78       	cp.w	r8,7
8000a994:	e0 89 00 04 	brgt	8000a99c <_vfprintf_r+0x1a78>
8000a998:	2f 83       	sub	r3,-8
8000a99a:	c0 b8       	rjmp	8000a9b0 <_vfprintf_r+0x1a8c>
8000a99c:	fa ca f9 78 	sub	r10,sp,-1672
8000a9a0:	02 9b       	mov	r11,r1
8000a9a2:	08 9c       	mov	r12,r4
8000a9a4:	fe b0 f2 b2 	rcall	80008f08 <__sprint_r>
8000a9a8:	e0 81 02 3d 	brne	8000ae22 <_vfprintf_r+0x1efe>
8000a9ac:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a9b0:	fa f2 06 ac 	ld.w	r2,sp[1708]
8000a9b4:	5c 32       	neg	r2
8000a9b6:	58 02       	cp.w	r2,0
8000a9b8:	e0 89 00 1d 	brgt	8000a9f2 <_vfprintf_r+0x1ace>
8000a9bc:	c3 d8       	rjmp	8000aa36 <_vfprintf_r+0x1b12>
8000a9be:	2f 09       	sub	r9,-16
8000a9c0:	2f f8       	sub	r8,-1
8000a9c2:	31 0e       	mov	lr,16
8000a9c4:	fb 49 06 90 	st.w	sp[1680],r9
8000a9c8:	87 00       	st.w	r3[0x0],r0
8000a9ca:	87 1e       	st.w	r3[0x4],lr
8000a9cc:	fb 48 06 8c 	st.w	sp[1676],r8
8000a9d0:	58 78       	cp.w	r8,7
8000a9d2:	e0 89 00 04 	brgt	8000a9da <_vfprintf_r+0x1ab6>
8000a9d6:	2f 83       	sub	r3,-8
8000a9d8:	c0 b8       	rjmp	8000a9ee <_vfprintf_r+0x1aca>
8000a9da:	fa ca f9 78 	sub	r10,sp,-1672
8000a9de:	02 9b       	mov	r11,r1
8000a9e0:	08 9c       	mov	r12,r4
8000a9e2:	fe b0 f2 93 	rcall	80008f08 <__sprint_r>
8000a9e6:	e0 81 02 1e 	brne	8000ae22 <_vfprintf_r+0x1efe>
8000a9ea:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a9ee:	21 02       	sub	r2,16
8000a9f0:	c0 38       	rjmp	8000a9f6 <_vfprintf_r+0x1ad2>
8000a9f2:	fe c0 b8 66 	sub	r0,pc,-18330
8000a9f6:	fa f9 06 90 	ld.w	r9,sp[1680]
8000a9fa:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a9fe:	fe ca b8 72 	sub	r10,pc,-18318
8000aa02:	59 02       	cp.w	r2,16
8000aa04:	fe 99 ff dd 	brgt	8000a9be <_vfprintf_r+0x1a9a>
8000aa08:	04 09       	add	r9,r2
8000aa0a:	2f f8       	sub	r8,-1
8000aa0c:	87 0a       	st.w	r3[0x0],r10
8000aa0e:	fb 49 06 90 	st.w	sp[1680],r9
8000aa12:	87 12       	st.w	r3[0x4],r2
8000aa14:	fb 48 06 8c 	st.w	sp[1676],r8
8000aa18:	58 78       	cp.w	r8,7
8000aa1a:	e0 89 00 04 	brgt	8000aa22 <_vfprintf_r+0x1afe>
8000aa1e:	2f 83       	sub	r3,-8
8000aa20:	c0 b8       	rjmp	8000aa36 <_vfprintf_r+0x1b12>
8000aa22:	fa ca f9 78 	sub	r10,sp,-1672
8000aa26:	02 9b       	mov	r11,r1
8000aa28:	08 9c       	mov	r12,r4
8000aa2a:	fe b0 f2 6f 	rcall	80008f08 <__sprint_r>
8000aa2e:	e0 81 01 fa 	brne	8000ae22 <_vfprintf_r+0x1efe>
8000aa32:	fa c3 f9 e0 	sub	r3,sp,-1568
8000aa36:	40 6c       	lddsp	r12,sp[0x18]
8000aa38:	fa f8 06 90 	ld.w	r8,sp[1680]
8000aa3c:	87 06       	st.w	r3[0x0],r6
8000aa3e:	87 1c       	st.w	r3[0x4],r12
8000aa40:	18 08       	add	r8,r12
8000aa42:	cb 98       	rjmp	8000abb4 <_vfprintf_r+0x1c90>
8000aa44:	fa f9 06 90 	ld.w	r9,sp[1680]
8000aa48:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000aa4c:	40 6b       	lddsp	r11,sp[0x18]
8000aa4e:	16 3a       	cp.w	r10,r11
8000aa50:	c6 f5       	brlt	8000ab2e <_vfprintf_r+0x1c0a>
8000aa52:	16 09       	add	r9,r11
8000aa54:	2f f8       	sub	r8,-1
8000aa56:	87 06       	st.w	r3[0x0],r6
8000aa58:	fb 49 06 90 	st.w	sp[1680],r9
8000aa5c:	87 1b       	st.w	r3[0x4],r11
8000aa5e:	fb 48 06 8c 	st.w	sp[1676],r8
8000aa62:	58 78       	cp.w	r8,7
8000aa64:	e0 89 00 04 	brgt	8000aa6c <_vfprintf_r+0x1b48>
8000aa68:	2f 83       	sub	r3,-8
8000aa6a:	c0 b8       	rjmp	8000aa80 <_vfprintf_r+0x1b5c>
8000aa6c:	fa ca f9 78 	sub	r10,sp,-1672
8000aa70:	02 9b       	mov	r11,r1
8000aa72:	08 9c       	mov	r12,r4
8000aa74:	fe b0 f2 4a 	rcall	80008f08 <__sprint_r>
8000aa78:	e0 81 01 d5 	brne	8000ae22 <_vfprintf_r+0x1efe>
8000aa7c:	fa c3 f9 e0 	sub	r3,sp,-1568
8000aa80:	fa f6 06 ac 	ld.w	r6,sp[1708]
8000aa84:	40 6a       	lddsp	r10,sp[0x18]
8000aa86:	14 16       	sub	r6,r10
8000aa88:	58 06       	cp.w	r6,0
8000aa8a:	e0 89 00 1c 	brgt	8000aac2 <_vfprintf_r+0x1b9e>
8000aa8e:	c3 d8       	rjmp	8000ab08 <_vfprintf_r+0x1be4>
8000aa90:	2f 09       	sub	r9,-16
8000aa92:	2f f8       	sub	r8,-1
8000aa94:	fb 49 06 90 	st.w	sp[1680],r9
8000aa98:	87 02       	st.w	r3[0x0],r2
8000aa9a:	87 10       	st.w	r3[0x4],r0
8000aa9c:	fb 48 06 8c 	st.w	sp[1676],r8
8000aaa0:	58 78       	cp.w	r8,7
8000aaa2:	e0 89 00 04 	brgt	8000aaaa <_vfprintf_r+0x1b86>
8000aaa6:	2f 83       	sub	r3,-8
8000aaa8:	c0 b8       	rjmp	8000aabe <_vfprintf_r+0x1b9a>
8000aaaa:	fa ca f9 78 	sub	r10,sp,-1672
8000aaae:	02 9b       	mov	r11,r1
8000aab0:	08 9c       	mov	r12,r4
8000aab2:	fe b0 f2 2b 	rcall	80008f08 <__sprint_r>
8000aab6:	e0 81 01 b6 	brne	8000ae22 <_vfprintf_r+0x1efe>
8000aaba:	fa c3 f9 e0 	sub	r3,sp,-1568
8000aabe:	21 06       	sub	r6,16
8000aac0:	c0 48       	rjmp	8000aac8 <_vfprintf_r+0x1ba4>
8000aac2:	fe c2 b9 36 	sub	r2,pc,-18122
8000aac6:	31 00       	mov	r0,16
8000aac8:	fa f9 06 90 	ld.w	r9,sp[1680]
8000aacc:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000aad0:	fe ca b9 44 	sub	r10,pc,-18108
8000aad4:	59 06       	cp.w	r6,16
8000aad6:	fe 99 ff dd 	brgt	8000aa90 <_vfprintf_r+0x1b6c>
8000aada:	0c 09       	add	r9,r6
8000aadc:	2f f8       	sub	r8,-1
8000aade:	87 0a       	st.w	r3[0x0],r10
8000aae0:	fb 49 06 90 	st.w	sp[1680],r9
8000aae4:	87 16       	st.w	r3[0x4],r6
8000aae6:	fb 48 06 8c 	st.w	sp[1676],r8
8000aaea:	58 78       	cp.w	r8,7
8000aaec:	e0 89 00 04 	brgt	8000aaf4 <_vfprintf_r+0x1bd0>
8000aaf0:	2f 83       	sub	r3,-8
8000aaf2:	c0 b8       	rjmp	8000ab08 <_vfprintf_r+0x1be4>
8000aaf4:	fa ca f9 78 	sub	r10,sp,-1672
8000aaf8:	02 9b       	mov	r11,r1
8000aafa:	08 9c       	mov	r12,r4
8000aafc:	fe b0 f2 06 	rcall	80008f08 <__sprint_r>
8000ab00:	e0 81 01 91 	brne	8000ae22 <_vfprintf_r+0x1efe>
8000ab04:	fa c3 f9 e0 	sub	r3,sp,-1568
8000ab08:	ed b5 00 00 	bld	r5,0x0
8000ab0c:	e0 81 01 20 	brne	8000ad4c <_vfprintf_r+0x1e28>
8000ab10:	40 c9       	lddsp	r9,sp[0x30]
8000ab12:	fa f8 06 90 	ld.w	r8,sp[1680]
8000ab16:	2f f8       	sub	r8,-1
8000ab18:	87 09       	st.w	r3[0x0],r9
8000ab1a:	fb 48 06 90 	st.w	sp[1680],r8
8000ab1e:	30 19       	mov	r9,1
8000ab20:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000ab24:	87 19       	st.w	r3[0x4],r9
8000ab26:	2f f8       	sub	r8,-1
8000ab28:	fb 48 06 8c 	st.w	sp[1676],r8
8000ab2c:	c0 29       	rjmp	8000ad30 <_vfprintf_r+0x1e0c>
8000ab2e:	14 09       	add	r9,r10
8000ab30:	2f f8       	sub	r8,-1
8000ab32:	fb 49 06 90 	st.w	sp[1680],r9
8000ab36:	87 06       	st.w	r3[0x0],r6
8000ab38:	87 1a       	st.w	r3[0x4],r10
8000ab3a:	fb 48 06 8c 	st.w	sp[1676],r8
8000ab3e:	58 78       	cp.w	r8,7
8000ab40:	e0 89 00 04 	brgt	8000ab48 <_vfprintf_r+0x1c24>
8000ab44:	2f 83       	sub	r3,-8
8000ab46:	c0 b8       	rjmp	8000ab5c <_vfprintf_r+0x1c38>
8000ab48:	fa ca f9 78 	sub	r10,sp,-1672
8000ab4c:	02 9b       	mov	r11,r1
8000ab4e:	08 9c       	mov	r12,r4
8000ab50:	fe b0 f1 dc 	rcall	80008f08 <__sprint_r>
8000ab54:	e0 81 01 67 	brne	8000ae22 <_vfprintf_r+0x1efe>
8000ab58:	fa c3 f9 e0 	sub	r3,sp,-1568
8000ab5c:	40 c8       	lddsp	r8,sp[0x30]
8000ab5e:	87 08       	st.w	r3[0x0],r8
8000ab60:	fa f8 06 90 	ld.w	r8,sp[1680]
8000ab64:	2f f8       	sub	r8,-1
8000ab66:	30 19       	mov	r9,1
8000ab68:	fb 48 06 90 	st.w	sp[1680],r8
8000ab6c:	87 19       	st.w	r3[0x4],r9
8000ab6e:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000ab72:	2f f8       	sub	r8,-1
8000ab74:	fb 48 06 8c 	st.w	sp[1676],r8
8000ab78:	fa f2 06 ac 	ld.w	r2,sp[1708]
8000ab7c:	58 78       	cp.w	r8,7
8000ab7e:	e0 89 00 04 	brgt	8000ab86 <_vfprintf_r+0x1c62>
8000ab82:	2f 83       	sub	r3,-8
8000ab84:	c0 b8       	rjmp	8000ab9a <_vfprintf_r+0x1c76>
8000ab86:	fa ca f9 78 	sub	r10,sp,-1672
8000ab8a:	02 9b       	mov	r11,r1
8000ab8c:	08 9c       	mov	r12,r4
8000ab8e:	fe b0 f1 bd 	rcall	80008f08 <__sprint_r>
8000ab92:	e0 81 01 48 	brne	8000ae22 <_vfprintf_r+0x1efe>
8000ab96:	fa c3 f9 e0 	sub	r3,sp,-1568
8000ab9a:	04 06       	add	r6,r2
8000ab9c:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000aba0:	87 06       	st.w	r3[0x0],r6
8000aba2:	fa f9 06 90 	ld.w	r9,sp[1680]
8000aba6:	40 66       	lddsp	r6,sp[0x18]
8000aba8:	40 6e       	lddsp	lr,sp[0x18]
8000abaa:	10 16       	sub	r6,r8
8000abac:	f2 08 01 08 	sub	r8,r9,r8
8000abb0:	87 16       	st.w	r3[0x4],r6
8000abb2:	1c 08       	add	r8,lr
8000abb4:	fb 48 06 90 	st.w	sp[1680],r8
8000abb8:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000abbc:	2f f8       	sub	r8,-1
8000abbe:	fb 48 06 8c 	st.w	sp[1676],r8
8000abc2:	cb 78       	rjmp	8000ad30 <_vfprintf_r+0x1e0c>
8000abc4:	40 6c       	lddsp	r12,sp[0x18]
8000abc6:	58 1c       	cp.w	r12,1
8000abc8:	e0 89 00 06 	brgt	8000abd4 <_vfprintf_r+0x1cb0>
8000abcc:	ed b5 00 00 	bld	r5,0x0
8000abd0:	e0 81 00 85 	brne	8000acda <_vfprintf_r+0x1db6>
8000abd4:	fa f8 06 90 	ld.w	r8,sp[1680]
8000abd8:	2f f8       	sub	r8,-1
8000abda:	30 19       	mov	r9,1
8000abdc:	fb 48 06 90 	st.w	sp[1680],r8
8000abe0:	87 06       	st.w	r3[0x0],r6
8000abe2:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000abe6:	87 19       	st.w	r3[0x4],r9
8000abe8:	2f f8       	sub	r8,-1
8000abea:	fb 48 06 8c 	st.w	sp[1676],r8
8000abee:	58 78       	cp.w	r8,7
8000abf0:	e0 89 00 04 	brgt	8000abf8 <_vfprintf_r+0x1cd4>
8000abf4:	2f 83       	sub	r3,-8
8000abf6:	c0 b8       	rjmp	8000ac0c <_vfprintf_r+0x1ce8>
8000abf8:	fa ca f9 78 	sub	r10,sp,-1672
8000abfc:	02 9b       	mov	r11,r1
8000abfe:	08 9c       	mov	r12,r4
8000ac00:	fe b0 f1 84 	rcall	80008f08 <__sprint_r>
8000ac04:	e0 81 01 0f 	brne	8000ae22 <_vfprintf_r+0x1efe>
8000ac08:	fa c3 f9 e0 	sub	r3,sp,-1568
8000ac0c:	fa f8 06 90 	ld.w	r8,sp[1680]
8000ac10:	2f f8       	sub	r8,-1
8000ac12:	40 cb       	lddsp	r11,sp[0x30]
8000ac14:	fb 48 06 90 	st.w	sp[1680],r8
8000ac18:	30 19       	mov	r9,1
8000ac1a:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000ac1e:	87 0b       	st.w	r3[0x0],r11
8000ac20:	2f f8       	sub	r8,-1
8000ac22:	87 19       	st.w	r3[0x4],r9
8000ac24:	fb 48 06 8c 	st.w	sp[1676],r8
8000ac28:	58 78       	cp.w	r8,7
8000ac2a:	e0 89 00 05 	brgt	8000ac34 <_vfprintf_r+0x1d10>
8000ac2e:	2f 83       	sub	r3,-8
8000ac30:	c0 c8       	rjmp	8000ac48 <_vfprintf_r+0x1d24>
8000ac32:	d7 03       	nop
8000ac34:	fa ca f9 78 	sub	r10,sp,-1672
8000ac38:	02 9b       	mov	r11,r1
8000ac3a:	08 9c       	mov	r12,r4
8000ac3c:	fe b0 f1 66 	rcall	80008f08 <__sprint_r>
8000ac40:	e0 81 00 f1 	brne	8000ae22 <_vfprintf_r+0x1efe>
8000ac44:	fa c3 f9 e0 	sub	r3,sp,-1568
8000ac48:	30 08       	mov	r8,0
8000ac4a:	30 09       	mov	r9,0
8000ac4c:	40 5b       	lddsp	r11,sp[0x14]
8000ac4e:	40 7a       	lddsp	r10,sp[0x1c]
8000ac50:	e0 a0 13 25 	rcall	8000d29a <__avr32_f64_cmp_eq>
8000ac54:	40 68       	lddsp	r8,sp[0x18]
8000ac56:	20 18       	sub	r8,1
8000ac58:	58 0c       	cp.w	r12,0
8000ac5a:	c0 d1       	brne	8000ac74 <_vfprintf_r+0x1d50>
8000ac5c:	2f f6       	sub	r6,-1
8000ac5e:	87 18       	st.w	r3[0x4],r8
8000ac60:	87 06       	st.w	r3[0x0],r6
8000ac62:	fa f6 06 90 	ld.w	r6,sp[1680]
8000ac66:	10 06       	add	r6,r8
8000ac68:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000ac6c:	fb 46 06 90 	st.w	sp[1680],r6
8000ac70:	2f f8       	sub	r8,-1
8000ac72:	c3 18       	rjmp	8000acd4 <_vfprintf_r+0x1db0>
8000ac74:	10 96       	mov	r6,r8
8000ac76:	58 08       	cp.w	r8,0
8000ac78:	e0 89 00 1c 	brgt	8000acb0 <_vfprintf_r+0x1d8c>
8000ac7c:	c4 b8       	rjmp	8000ad12 <_vfprintf_r+0x1dee>
8000ac7e:	2f 09       	sub	r9,-16
8000ac80:	2f f8       	sub	r8,-1
8000ac82:	fb 49 06 90 	st.w	sp[1680],r9
8000ac86:	87 02       	st.w	r3[0x0],r2
8000ac88:	87 10       	st.w	r3[0x4],r0
8000ac8a:	fb 48 06 8c 	st.w	sp[1676],r8
8000ac8e:	58 78       	cp.w	r8,7
8000ac90:	e0 89 00 04 	brgt	8000ac98 <_vfprintf_r+0x1d74>
8000ac94:	2f 83       	sub	r3,-8
8000ac96:	c0 b8       	rjmp	8000acac <_vfprintf_r+0x1d88>
8000ac98:	fa ca f9 78 	sub	r10,sp,-1672
8000ac9c:	02 9b       	mov	r11,r1
8000ac9e:	08 9c       	mov	r12,r4
8000aca0:	fe b0 f1 34 	rcall	80008f08 <__sprint_r>
8000aca4:	e0 81 00 bf 	brne	8000ae22 <_vfprintf_r+0x1efe>
8000aca8:	fa c3 f9 e0 	sub	r3,sp,-1568
8000acac:	21 06       	sub	r6,16
8000acae:	c0 48       	rjmp	8000acb6 <_vfprintf_r+0x1d92>
8000acb0:	fe c2 bb 24 	sub	r2,pc,-17628
8000acb4:	31 00       	mov	r0,16
8000acb6:	fa f9 06 90 	ld.w	r9,sp[1680]
8000acba:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000acbe:	fe ca bb 32 	sub	r10,pc,-17614
8000acc2:	59 06       	cp.w	r6,16
8000acc4:	fe 99 ff dd 	brgt	8000ac7e <_vfprintf_r+0x1d5a>
8000acc8:	0c 09       	add	r9,r6
8000acca:	87 0a       	st.w	r3[0x0],r10
8000accc:	fb 49 06 90 	st.w	sp[1680],r9
8000acd0:	2f f8       	sub	r8,-1
8000acd2:	87 16       	st.w	r3[0x4],r6
8000acd4:	fb 48 06 8c 	st.w	sp[1676],r8
8000acd8:	c0 e8       	rjmp	8000acf4 <_vfprintf_r+0x1dd0>
8000acda:	fa f8 06 90 	ld.w	r8,sp[1680]
8000acde:	2f f8       	sub	r8,-1
8000ace0:	30 19       	mov	r9,1
8000ace2:	fb 48 06 90 	st.w	sp[1680],r8
8000ace6:	87 06       	st.w	r3[0x0],r6
8000ace8:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000acec:	87 19       	st.w	r3[0x4],r9
8000acee:	2f f8       	sub	r8,-1
8000acf0:	fb 48 06 8c 	st.w	sp[1676],r8
8000acf4:	58 78       	cp.w	r8,7
8000acf6:	e0 89 00 04 	brgt	8000acfe <_vfprintf_r+0x1dda>
8000acfa:	2f 83       	sub	r3,-8
8000acfc:	c0 b8       	rjmp	8000ad12 <_vfprintf_r+0x1dee>
8000acfe:	fa ca f9 78 	sub	r10,sp,-1672
8000ad02:	02 9b       	mov	r11,r1
8000ad04:	08 9c       	mov	r12,r4
8000ad06:	fe b0 f1 01 	rcall	80008f08 <__sprint_r>
8000ad0a:	e0 81 00 8c 	brne	8000ae22 <_vfprintf_r+0x1efe>
8000ad0e:	fa c3 f9 e0 	sub	r3,sp,-1568
8000ad12:	40 ea       	lddsp	r10,sp[0x38]
8000ad14:	fa f8 06 90 	ld.w	r8,sp[1680]
8000ad18:	14 08       	add	r8,r10
8000ad1a:	fa c9 f9 64 	sub	r9,sp,-1692
8000ad1e:	fb 48 06 90 	st.w	sp[1680],r8
8000ad22:	87 1a       	st.w	r3[0x4],r10
8000ad24:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000ad28:	87 09       	st.w	r3[0x0],r9
8000ad2a:	2f f8       	sub	r8,-1
8000ad2c:	fb 48 06 8c 	st.w	sp[1676],r8
8000ad30:	58 78       	cp.w	r8,7
8000ad32:	e0 89 00 04 	brgt	8000ad3a <_vfprintf_r+0x1e16>
8000ad36:	2f 83       	sub	r3,-8
8000ad38:	c0 a8       	rjmp	8000ad4c <_vfprintf_r+0x1e28>
8000ad3a:	fa ca f9 78 	sub	r10,sp,-1672
8000ad3e:	02 9b       	mov	r11,r1
8000ad40:	08 9c       	mov	r12,r4
8000ad42:	fe b0 f0 e3 	rcall	80008f08 <__sprint_r>
8000ad46:	c6 e1       	brne	8000ae22 <_vfprintf_r+0x1efe>
8000ad48:	fa c3 f9 e0 	sub	r3,sp,-1568
8000ad4c:	e2 15 00 04 	andl	r5,0x4,COH
8000ad50:	c3 f0       	breq	8000adce <_vfprintf_r+0x1eaa>
8000ad52:	40 86       	lddsp	r6,sp[0x20]
8000ad54:	40 39       	lddsp	r9,sp[0xc]
8000ad56:	12 16       	sub	r6,r9
8000ad58:	58 06       	cp.w	r6,0
8000ad5a:	e0 89 00 1a 	brgt	8000ad8e <_vfprintf_r+0x1e6a>
8000ad5e:	c3 88       	rjmp	8000adce <_vfprintf_r+0x1eaa>
8000ad60:	2f 09       	sub	r9,-16
8000ad62:	2f f8       	sub	r8,-1
8000ad64:	fb 49 06 90 	st.w	sp[1680],r9
8000ad68:	87 05       	st.w	r3[0x0],r5
8000ad6a:	87 12       	st.w	r3[0x4],r2
8000ad6c:	fb 48 06 8c 	st.w	sp[1676],r8
8000ad70:	58 78       	cp.w	r8,7
8000ad72:	e0 89 00 04 	brgt	8000ad7a <_vfprintf_r+0x1e56>
8000ad76:	2f 83       	sub	r3,-8
8000ad78:	c0 98       	rjmp	8000ad8a <_vfprintf_r+0x1e66>
8000ad7a:	00 9a       	mov	r10,r0
8000ad7c:	02 9b       	mov	r11,r1
8000ad7e:	08 9c       	mov	r12,r4
8000ad80:	fe b0 f0 c4 	rcall	80008f08 <__sprint_r>
8000ad84:	c4 f1       	brne	8000ae22 <_vfprintf_r+0x1efe>
8000ad86:	fa c3 f9 e0 	sub	r3,sp,-1568
8000ad8a:	21 06       	sub	r6,16
8000ad8c:	c0 68       	rjmp	8000ad98 <_vfprintf_r+0x1e74>
8000ad8e:	fe c5 bc 12 	sub	r5,pc,-17390
8000ad92:	31 02       	mov	r2,16
8000ad94:	fa c0 f9 78 	sub	r0,sp,-1672
8000ad98:	fa f9 06 90 	ld.w	r9,sp[1680]
8000ad9c:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000ada0:	fe ca bc 24 	sub	r10,pc,-17372
8000ada4:	59 06       	cp.w	r6,16
8000ada6:	fe 99 ff dd 	brgt	8000ad60 <_vfprintf_r+0x1e3c>
8000adaa:	0c 09       	add	r9,r6
8000adac:	2f f8       	sub	r8,-1
8000adae:	87 0a       	st.w	r3[0x0],r10
8000adb0:	87 16       	st.w	r3[0x4],r6
8000adb2:	fb 49 06 90 	st.w	sp[1680],r9
8000adb6:	fb 48 06 8c 	st.w	sp[1676],r8
8000adba:	58 78       	cp.w	r8,7
8000adbc:	e0 8a 00 09 	brle	8000adce <_vfprintf_r+0x1eaa>
8000adc0:	fa ca f9 78 	sub	r10,sp,-1672
8000adc4:	02 9b       	mov	r11,r1
8000adc6:	08 9c       	mov	r12,r4
8000adc8:	fe b0 f0 a0 	rcall	80008f08 <__sprint_r>
8000adcc:	c2 b1       	brne	8000ae22 <_vfprintf_r+0x1efe>
8000adce:	40 bc       	lddsp	r12,sp[0x2c]
8000add0:	40 36       	lddsp	r6,sp[0xc]
8000add2:	40 8e       	lddsp	lr,sp[0x20]
8000add4:	ec 0e 0c 48 	max	r8,r6,lr
8000add8:	10 0c       	add	r12,r8
8000adda:	50 bc       	stdsp	sp[0x2c],r12
8000addc:	fa f8 06 90 	ld.w	r8,sp[1680]
8000ade0:	58 08       	cp.w	r8,0
8000ade2:	c0 80       	breq	8000adf2 <_vfprintf_r+0x1ece>
8000ade4:	fa ca f9 78 	sub	r10,sp,-1672
8000ade8:	02 9b       	mov	r11,r1
8000adea:	08 9c       	mov	r12,r4
8000adec:	fe b0 f0 8e 	rcall	80008f08 <__sprint_r>
8000adf0:	c1 91       	brne	8000ae22 <_vfprintf_r+0x1efe>
8000adf2:	30 0b       	mov	r11,0
8000adf4:	fa c3 f9 e0 	sub	r3,sp,-1568
8000adf8:	fb 4b 06 8c 	st.w	sp[1676],r11
8000adfc:	fe 9f f1 22 	bral	80009040 <_vfprintf_r+0x11c>
8000ae00:	08 95       	mov	r5,r4
8000ae02:	fa f8 06 90 	ld.w	r8,sp[1680]
8000ae06:	58 08       	cp.w	r8,0
8000ae08:	c0 80       	breq	8000ae18 <_vfprintf_r+0x1ef4>
8000ae0a:	08 9c       	mov	r12,r4
8000ae0c:	fa ca f9 78 	sub	r10,sp,-1672
8000ae10:	02 9b       	mov	r11,r1
8000ae12:	fe b0 f0 7b 	rcall	80008f08 <__sprint_r>
8000ae16:	c0 61       	brne	8000ae22 <_vfprintf_r+0x1efe>
8000ae18:	30 08       	mov	r8,0
8000ae1a:	fb 48 06 8c 	st.w	sp[1676],r8
8000ae1e:	c0 28       	rjmp	8000ae22 <_vfprintf_r+0x1efe>
8000ae20:	40 41       	lddsp	r1,sp[0x10]
8000ae22:	82 68       	ld.sh	r8,r1[0xc]
8000ae24:	ed b8 00 06 	bld	r8,0x6
8000ae28:	c0 31       	brne	8000ae2e <_vfprintf_r+0x1f0a>
8000ae2a:	3f fa       	mov	r10,-1
8000ae2c:	50 ba       	stdsp	sp[0x2c],r10
8000ae2e:	40 bc       	lddsp	r12,sp[0x2c]
8000ae30:	fe 3d f9 44 	sub	sp,-1724
8000ae34:	d8 32       	popm	r0-r7,pc
8000ae36:	d7 03       	nop

8000ae38 <__swsetup_r>:
8000ae38:	d4 21       	pushm	r4-r7,lr
8000ae3a:	e0 68 0a 54 	mov	r8,2644
8000ae3e:	18 96       	mov	r6,r12
8000ae40:	16 97       	mov	r7,r11
8000ae42:	70 0c       	ld.w	r12,r8[0x0]
8000ae44:	58 0c       	cp.w	r12,0
8000ae46:	c0 60       	breq	8000ae52 <__swsetup_r+0x1a>
8000ae48:	78 68       	ld.w	r8,r12[0x18]
8000ae4a:	58 08       	cp.w	r8,0
8000ae4c:	c0 31       	brne	8000ae52 <__swsetup_r+0x1a>
8000ae4e:	e0 a0 07 bf 	rcall	8000bdcc <__sinit>
8000ae52:	fe c8 bb a6 	sub	r8,pc,-17498
8000ae56:	10 37       	cp.w	r7,r8
8000ae58:	c0 61       	brne	8000ae64 <__swsetup_r+0x2c>
8000ae5a:	e0 68 0a 54 	mov	r8,2644
8000ae5e:	70 08       	ld.w	r8,r8[0x0]
8000ae60:	70 07       	ld.w	r7,r8[0x0]
8000ae62:	c1 28       	rjmp	8000ae86 <__swsetup_r+0x4e>
8000ae64:	fe c8 bb 98 	sub	r8,pc,-17512
8000ae68:	10 37       	cp.w	r7,r8
8000ae6a:	c0 61       	brne	8000ae76 <__swsetup_r+0x3e>
8000ae6c:	e0 68 0a 54 	mov	r8,2644
8000ae70:	70 08       	ld.w	r8,r8[0x0]
8000ae72:	70 17       	ld.w	r7,r8[0x4]
8000ae74:	c0 98       	rjmp	8000ae86 <__swsetup_r+0x4e>
8000ae76:	fe c8 bb 8a 	sub	r8,pc,-17526
8000ae7a:	10 37       	cp.w	r7,r8
8000ae7c:	c0 51       	brne	8000ae86 <__swsetup_r+0x4e>
8000ae7e:	e0 68 0a 54 	mov	r8,2644
8000ae82:	70 08       	ld.w	r8,r8[0x0]
8000ae84:	70 27       	ld.w	r7,r8[0x8]
8000ae86:	8e 68       	ld.sh	r8,r7[0xc]
8000ae88:	ed b8 00 03 	bld	r8,0x3
8000ae8c:	c1 e0       	breq	8000aec8 <__swsetup_r+0x90>
8000ae8e:	ed b8 00 04 	bld	r8,0x4
8000ae92:	c3 e1       	brne	8000af0e <__swsetup_r+0xd6>
8000ae94:	ed b8 00 02 	bld	r8,0x2
8000ae98:	c1 51       	brne	8000aec2 <__swsetup_r+0x8a>
8000ae9a:	6e db       	ld.w	r11,r7[0x34]
8000ae9c:	58 0b       	cp.w	r11,0
8000ae9e:	c0 a0       	breq	8000aeb2 <__swsetup_r+0x7a>
8000aea0:	ee c8 ff bc 	sub	r8,r7,-68
8000aea4:	10 3b       	cp.w	r11,r8
8000aea6:	c0 40       	breq	8000aeae <__swsetup_r+0x76>
8000aea8:	0c 9c       	mov	r12,r6
8000aeaa:	e0 a0 08 2b 	rcall	8000bf00 <_free_r>
8000aeae:	30 08       	mov	r8,0
8000aeb0:	8f d8       	st.w	r7[0x34],r8
8000aeb2:	8e 68       	ld.sh	r8,r7[0xc]
8000aeb4:	e0 18 ff db 	andl	r8,0xffdb
8000aeb8:	ae 68       	st.h	r7[0xc],r8
8000aeba:	30 08       	mov	r8,0
8000aebc:	8f 18       	st.w	r7[0x4],r8
8000aebe:	6e 48       	ld.w	r8,r7[0x10]
8000aec0:	8f 08       	st.w	r7[0x0],r8
8000aec2:	8e 68       	ld.sh	r8,r7[0xc]
8000aec4:	a3 b8       	sbr	r8,0x3
8000aec6:	ae 68       	st.h	r7[0xc],r8
8000aec8:	6e 48       	ld.w	r8,r7[0x10]
8000aeca:	58 08       	cp.w	r8,0
8000aecc:	c0 b1       	brne	8000aee2 <__swsetup_r+0xaa>
8000aece:	8e 68       	ld.sh	r8,r7[0xc]
8000aed0:	e2 18 02 80 	andl	r8,0x280,COH
8000aed4:	e0 48 02 00 	cp.w	r8,512
8000aed8:	c0 50       	breq	8000aee2 <__swsetup_r+0xaa>
8000aeda:	0c 9c       	mov	r12,r6
8000aedc:	0e 9b       	mov	r11,r7
8000aede:	e0 a0 0a 4b 	rcall	8000c374 <__smakebuf_r>
8000aee2:	8e 69       	ld.sh	r9,r7[0xc]
8000aee4:	f1 d9 c0 01 	bfextu	r8,r9,0x0,0x1
8000aee8:	c0 70       	breq	8000aef6 <__swsetup_r+0xbe>
8000aeea:	30 08       	mov	r8,0
8000aeec:	8f 28       	st.w	r7[0x8],r8
8000aeee:	6e 58       	ld.w	r8,r7[0x14]
8000aef0:	5c 38       	neg	r8
8000aef2:	8f 68       	st.w	r7[0x18],r8
8000aef4:	c0 68       	rjmp	8000af00 <__swsetup_r+0xc8>
8000aef6:	ed b9 00 01 	bld	r9,0x1
8000aefa:	ef f8 10 05 	ld.wne	r8,r7[0x14]
8000aefe:	8f 28       	st.w	r7[0x8],r8
8000af00:	6e 48       	ld.w	r8,r7[0x10]
8000af02:	58 08       	cp.w	r8,0
8000af04:	c0 61       	brne	8000af10 <__swsetup_r+0xd8>
8000af06:	8e 68       	ld.sh	r8,r7[0xc]
8000af08:	ed b8 00 07 	bld	r8,0x7
8000af0c:	c0 21       	brne	8000af10 <__swsetup_r+0xd8>
8000af0e:	dc 2a       	popm	r4-r7,pc,r12=-1
8000af10:	d8 2a       	popm	r4-r7,pc,r12=0
8000af12:	d7 03       	nop

8000af14 <quorem>:
8000af14:	d4 31       	pushm	r0-r7,lr
8000af16:	20 2d       	sub	sp,8
8000af18:	18 97       	mov	r7,r12
8000af1a:	78 48       	ld.w	r8,r12[0x10]
8000af1c:	76 46       	ld.w	r6,r11[0x10]
8000af1e:	0c 38       	cp.w	r8,r6
8000af20:	c0 34       	brge	8000af26 <quorem+0x12>
8000af22:	30 0c       	mov	r12,0
8000af24:	c8 58       	rjmp	8000b02e <quorem+0x11a>
8000af26:	ec c2 ff fc 	sub	r2,r6,-4
8000af2a:	f6 c3 ff ec 	sub	r3,r11,-20
8000af2e:	f6 02 03 29 	ld.w	r9,r11[r2<<0x2]
8000af32:	f8 02 03 2c 	ld.w	r12,r12[r2<<0x2]
8000af36:	2f f9       	sub	r9,-1
8000af38:	20 16       	sub	r6,1
8000af3a:	f8 09 0d 08 	divu	r8,r12,r9
8000af3e:	f6 02 00 22 	add	r2,r11,r2<<0x2
8000af42:	ee c4 ff ec 	sub	r4,r7,-20
8000af46:	10 95       	mov	r5,r8
8000af48:	58 08       	cp.w	r8,0
8000af4a:	c4 10       	breq	8000afcc <quorem+0xb8>
8000af4c:	30 09       	mov	r9,0
8000af4e:	06 9a       	mov	r10,r3
8000af50:	08 98       	mov	r8,r4
8000af52:	12 91       	mov	r1,r9
8000af54:	50 0b       	stdsp	sp[0x0],r11
8000af56:	70 0e       	ld.w	lr,r8[0x0]
8000af58:	b1 8e       	lsr	lr,0x10
8000af5a:	50 1e       	stdsp	sp[0x4],lr
8000af5c:	15 0e       	ld.w	lr,r10++
8000af5e:	fc 00 16 10 	lsr	r0,lr,0x10
8000af62:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000af66:	ea 0e 03 41 	mac	r1,r5,lr
8000af6a:	fd d1 c0 10 	bfextu	lr,r1,0x0,0x10
8000af6e:	b1 81       	lsr	r1,0x10
8000af70:	40 1b       	lddsp	r11,sp[0x4]
8000af72:	ea 00 02 40 	mul	r0,r5,r0
8000af76:	e2 00 00 00 	add	r0,r1,r0
8000af7a:	e3 d0 c0 10 	bfextu	r1,r0,0x0,0x10
8000af7e:	02 1b       	sub	r11,r1
8000af80:	50 1b       	stdsp	sp[0x4],r11
8000af82:	70 0b       	ld.w	r11,r8[0x0]
8000af84:	e3 db c0 10 	bfextu	r1,r11,0x0,0x10
8000af88:	02 09       	add	r9,r1
8000af8a:	f2 0e 01 0e 	sub	lr,r9,lr
8000af8e:	b0 1e       	st.h	r8[0x2],lr
8000af90:	fc 09 14 10 	asr	r9,lr,0x10
8000af94:	40 1e       	lddsp	lr,sp[0x4]
8000af96:	fc 09 00 09 	add	r9,lr,r9
8000af9a:	b0 09       	st.h	r8[0x0],r9
8000af9c:	e0 01 16 10 	lsr	r1,r0,0x10
8000afa0:	2f c8       	sub	r8,-4
8000afa2:	b1 49       	asr	r9,0x10
8000afa4:	04 3a       	cp.w	r10,r2
8000afa6:	fe 98 ff d8 	brls	8000af56 <quorem+0x42>
8000afaa:	40 0b       	lddsp	r11,sp[0x0]
8000afac:	58 0c       	cp.w	r12,0
8000afae:	c0 f1       	brne	8000afcc <quorem+0xb8>
8000afb0:	ec c8 ff fb 	sub	r8,r6,-5
8000afb4:	ee 08 00 28 	add	r8,r7,r8<<0x2
8000afb8:	c0 28       	rjmp	8000afbc <quorem+0xa8>
8000afba:	20 16       	sub	r6,1
8000afbc:	20 48       	sub	r8,4
8000afbe:	08 38       	cp.w	r8,r4
8000afc0:	e0 88 00 05 	brls	8000afca <quorem+0xb6>
8000afc4:	70 09       	ld.w	r9,r8[0x0]
8000afc6:	58 09       	cp.w	r9,0
8000afc8:	cf 90       	breq	8000afba <quorem+0xa6>
8000afca:	8f 46       	st.w	r7[0x10],r6
8000afcc:	0e 9c       	mov	r12,r7
8000afce:	e0 a0 0a d2 	rcall	8000c572 <__mcmp>
8000afd2:	c2 d5       	brlt	8000b02c <quorem+0x118>
8000afd4:	2f f5       	sub	r5,-1
8000afd6:	08 98       	mov	r8,r4
8000afd8:	30 09       	mov	r9,0
8000afda:	07 0b       	ld.w	r11,r3++
8000afdc:	f6 0a 16 10 	lsr	r10,r11,0x10
8000afe0:	70 0c       	ld.w	r12,r8[0x0]
8000afe2:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000afe6:	f8 0e 16 10 	lsr	lr,r12,0x10
8000afea:	14 1e       	sub	lr,r10
8000afec:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000aff0:	16 1a       	sub	r10,r11
8000aff2:	12 0a       	add	r10,r9
8000aff4:	b0 1a       	st.h	r8[0x2],r10
8000aff6:	b1 4a       	asr	r10,0x10
8000aff8:	fc 0a 00 09 	add	r9,lr,r10
8000affc:	b0 09       	st.h	r8[0x0],r9
8000affe:	2f c8       	sub	r8,-4
8000b000:	b1 49       	asr	r9,0x10
8000b002:	04 33       	cp.w	r3,r2
8000b004:	fe 98 ff eb 	brls	8000afda <quorem+0xc6>
8000b008:	ec c8 ff fb 	sub	r8,r6,-5
8000b00c:	ee 08 03 29 	ld.w	r9,r7[r8<<0x2]
8000b010:	58 09       	cp.w	r9,0
8000b012:	c0 d1       	brne	8000b02c <quorem+0x118>
8000b014:	ee 08 00 28 	add	r8,r7,r8<<0x2
8000b018:	c0 28       	rjmp	8000b01c <quorem+0x108>
8000b01a:	20 16       	sub	r6,1
8000b01c:	20 48       	sub	r8,4
8000b01e:	08 38       	cp.w	r8,r4
8000b020:	e0 88 00 05 	brls	8000b02a <quorem+0x116>
8000b024:	70 09       	ld.w	r9,r8[0x0]
8000b026:	58 09       	cp.w	r9,0
8000b028:	cf 90       	breq	8000b01a <quorem+0x106>
8000b02a:	8f 46       	st.w	r7[0x10],r6
8000b02c:	0a 9c       	mov	r12,r5
8000b02e:	2f ed       	sub	sp,-8
8000b030:	d8 32       	popm	r0-r7,pc
8000b032:	d7 03       	nop

8000b034 <_dtoa_r>:
8000b034:	d4 31       	pushm	r0-r7,lr
8000b036:	21 ad       	sub	sp,104
8000b038:	fa c4 ff 74 	sub	r4,sp,-140
8000b03c:	18 97       	mov	r7,r12
8000b03e:	16 95       	mov	r5,r11
8000b040:	68 2c       	ld.w	r12,r4[0x8]
8000b042:	50 c9       	stdsp	sp[0x30],r9
8000b044:	68 16       	ld.w	r6,r4[0x4]
8000b046:	68 09       	ld.w	r9,r4[0x0]
8000b048:	50 e8       	stdsp	sp[0x38],r8
8000b04a:	14 94       	mov	r4,r10
8000b04c:	51 2c       	stdsp	sp[0x48],r12
8000b04e:	fa e5 00 08 	st.d	sp[8],r4
8000b052:	51 59       	stdsp	sp[0x54],r9
8000b054:	6e 95       	ld.w	r5,r7[0x24]
8000b056:	58 05       	cp.w	r5,0
8000b058:	c0 91       	brne	8000b06a <_dtoa_r+0x36>
8000b05a:	31 0c       	mov	r12,16
8000b05c:	fe b0 e8 e2 	rcall	80008220 <malloc>
8000b060:	99 35       	st.w	r12[0xc],r5
8000b062:	8f 9c       	st.w	r7[0x24],r12
8000b064:	99 15       	st.w	r12[0x4],r5
8000b066:	99 25       	st.w	r12[0x8],r5
8000b068:	99 05       	st.w	r12[0x0],r5
8000b06a:	6e 99       	ld.w	r9,r7[0x24]
8000b06c:	72 08       	ld.w	r8,r9[0x0]
8000b06e:	58 08       	cp.w	r8,0
8000b070:	c0 f0       	breq	8000b08e <_dtoa_r+0x5a>
8000b072:	72 1a       	ld.w	r10,r9[0x4]
8000b074:	91 1a       	st.w	r8[0x4],r10
8000b076:	30 1a       	mov	r10,1
8000b078:	72 19       	ld.w	r9,r9[0x4]
8000b07a:	f4 09 09 49 	lsl	r9,r10,r9
8000b07e:	10 9b       	mov	r11,r8
8000b080:	91 29       	st.w	r8[0x8],r9
8000b082:	0e 9c       	mov	r12,r7
8000b084:	e0 a0 0a 90 	rcall	8000c5a4 <_Bfree>
8000b088:	6e 98       	ld.w	r8,r7[0x24]
8000b08a:	30 09       	mov	r9,0
8000b08c:	91 09       	st.w	r8[0x0],r9
8000b08e:	40 28       	lddsp	r8,sp[0x8]
8000b090:	10 94       	mov	r4,r8
8000b092:	58 08       	cp.w	r8,0
8000b094:	c0 64       	brge	8000b0a0 <_dtoa_r+0x6c>
8000b096:	f1 d8 c0 1f 	bfextu	r8,r8,0x0,0x1f
8000b09a:	50 28       	stdsp	sp[0x8],r8
8000b09c:	30 18       	mov	r8,1
8000b09e:	c0 28       	rjmp	8000b0a2 <_dtoa_r+0x6e>
8000b0a0:	30 08       	mov	r8,0
8000b0a2:	8d 08       	st.w	r6[0x0],r8
8000b0a4:	fc 1c 7f f0 	movh	r12,0x7ff0
8000b0a8:	40 26       	lddsp	r6,sp[0x8]
8000b0aa:	0c 98       	mov	r8,r6
8000b0ac:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000b0b0:	18 38       	cp.w	r8,r12
8000b0b2:	c2 01       	brne	8000b0f2 <_dtoa_r+0xbe>
8000b0b4:	e0 68 27 0f 	mov	r8,9999
8000b0b8:	41 5b       	lddsp	r11,sp[0x54]
8000b0ba:	97 08       	st.w	r11[0x0],r8
8000b0bc:	40 3a       	lddsp	r10,sp[0xc]
8000b0be:	58 0a       	cp.w	r10,0
8000b0c0:	c0 71       	brne	8000b0ce <_dtoa_r+0x9a>
8000b0c2:	ed d6 c0 14 	bfextu	r6,r6,0x0,0x14
8000b0c6:	c0 41       	brne	8000b0ce <_dtoa_r+0x9a>
8000b0c8:	fe cc be 2c 	sub	r12,pc,-16852
8000b0cc:	c0 38       	rjmp	8000b0d2 <_dtoa_r+0x9e>
8000b0ce:	fe cc be 26 	sub	r12,pc,-16858
8000b0d2:	41 29       	lddsp	r9,sp[0x48]
8000b0d4:	58 09       	cp.w	r9,0
8000b0d6:	e0 80 05 9a 	breq	8000bc0a <_dtoa_r+0xbd6>
8000b0da:	f8 c8 ff fd 	sub	r8,r12,-3
8000b0de:	f8 c9 ff f8 	sub	r9,r12,-8
8000b0e2:	11 8b       	ld.ub	r11,r8[0x0]
8000b0e4:	30 0a       	mov	r10,0
8000b0e6:	41 25       	lddsp	r5,sp[0x48]
8000b0e8:	f4 0b 18 00 	cp.b	r11,r10
8000b0ec:	f2 08 17 10 	movne	r8,r9
8000b0f0:	c1 68       	rjmp	8000b11c <_dtoa_r+0xe8>
8000b0f2:	fa ea 00 08 	ld.d	r10,sp[8]
8000b0f6:	30 08       	mov	r8,0
8000b0f8:	fa eb 00 3c 	st.d	sp[60],r10
8000b0fc:	30 09       	mov	r9,0
8000b0fe:	e0 a0 10 ce 	rcall	8000d29a <__avr32_f64_cmp_eq>
8000b102:	c1 00       	breq	8000b122 <_dtoa_r+0xee>
8000b104:	30 18       	mov	r8,1
8000b106:	41 5a       	lddsp	r10,sp[0x54]
8000b108:	95 08       	st.w	r10[0x0],r8
8000b10a:	fe cc bf 92 	sub	r12,pc,-16494
8000b10e:	41 29       	lddsp	r9,sp[0x48]
8000b110:	f8 08 00 08 	add	r8,r12,r8
8000b114:	58 09       	cp.w	r9,0
8000b116:	e0 80 05 7a 	breq	8000bc0a <_dtoa_r+0xbd6>
8000b11a:	12 95       	mov	r5,r9
8000b11c:	8b 08       	st.w	r5[0x0],r8
8000b11e:	e0 8f 05 76 	bral	8000bc0a <_dtoa_r+0xbd6>
8000b122:	fa c8 ff 9c 	sub	r8,sp,-100
8000b126:	fa c9 ff a0 	sub	r9,sp,-96
8000b12a:	fa ea 00 3c 	ld.d	r10,sp[60]
8000b12e:	0e 9c       	mov	r12,r7
8000b130:	eb d6 c2 8b 	bfextu	r5,r6,0x14,0xb
8000b134:	e0 a0 0a 8a 	rcall	8000c648 <__d2b>
8000b138:	18 93       	mov	r3,r12
8000b13a:	58 05       	cp.w	r5,0
8000b13c:	c0 d0       	breq	8000b156 <_dtoa_r+0x122>
8000b13e:	fa ea 00 3c 	ld.d	r10,sp[60]
8000b142:	30 04       	mov	r4,0
8000b144:	f1 db c0 14 	bfextu	r8,r11,0x0,0x14
8000b148:	ea c5 03 ff 	sub	r5,r5,1023
8000b14c:	10 9b       	mov	r11,r8
8000b14e:	51 74       	stdsp	sp[0x5c],r4
8000b150:	ea 1b 3f f0 	orh	r11,0x3ff0
8000b154:	c2 58       	rjmp	8000b19e <_dtoa_r+0x16a>
8000b156:	41 88       	lddsp	r8,sp[0x60]
8000b158:	41 9c       	lddsp	r12,sp[0x64]
8000b15a:	10 0c       	add	r12,r8
8000b15c:	f8 c5 fb ce 	sub	r5,r12,-1074
8000b160:	e0 45 00 20 	cp.w	r5,32
8000b164:	e0 8a 00 0e 	brle	8000b180 <_dtoa_r+0x14c>
8000b168:	f8 cc fb ee 	sub	r12,r12,-1042
8000b16c:	40 3b       	lddsp	r11,sp[0xc]
8000b16e:	ea 08 11 40 	rsub	r8,r5,64
8000b172:	f6 0c 0a 4c 	lsr	r12,r11,r12
8000b176:	ec 08 09 46 	lsl	r6,r6,r8
8000b17a:	0c 4c       	or	r12,r6
8000b17c:	c0 78       	rjmp	8000b18a <_dtoa_r+0x156>
8000b17e:	d7 03       	nop
8000b180:	ea 0c 11 20 	rsub	r12,r5,32
8000b184:	40 3a       	lddsp	r10,sp[0xc]
8000b186:	f4 0c 09 4c 	lsl	r12,r10,r12
8000b18a:	e0 a0 10 14 	rcall	8000d1b2 <__avr32_u32_to_f64>
8000b18e:	fc 18 fe 10 	movh	r8,0xfe10
8000b192:	30 19       	mov	r9,1
8000b194:	ea c5 04 33 	sub	r5,r5,1075
8000b198:	f0 0b 00 0b 	add	r11,r8,r11
8000b19c:	51 79       	stdsp	sp[0x5c],r9
8000b19e:	30 08       	mov	r8,0
8000b1a0:	fc 19 3f f8 	movh	r9,0x3ff8
8000b1a4:	e0 a0 0e 9c 	rcall	8000cedc <__avr32_f64_sub>
8000b1a8:	e0 68 43 61 	mov	r8,17249
8000b1ac:	ea 18 63 6f 	orh	r8,0x636f
8000b1b0:	e0 69 87 a7 	mov	r9,34727
8000b1b4:	ea 19 3f d2 	orh	r9,0x3fd2
8000b1b8:	e0 a0 0d a6 	rcall	8000cd04 <__avr32_f64_mul>
8000b1bc:	e0 68 c8 b3 	mov	r8,51379
8000b1c0:	ea 18 8b 60 	orh	r8,0x8b60
8000b1c4:	e0 69 8a 28 	mov	r9,35368
8000b1c8:	ea 19 3f c6 	orh	r9,0x3fc6
8000b1cc:	e0 a0 0f 56 	rcall	8000d078 <__avr32_f64_add>
8000b1d0:	0a 9c       	mov	r12,r5
8000b1d2:	14 90       	mov	r0,r10
8000b1d4:	16 91       	mov	r1,r11
8000b1d6:	e0 a0 0f f2 	rcall	8000d1ba <__avr32_s32_to_f64>
8000b1da:	e0 68 79 fb 	mov	r8,31227
8000b1de:	ea 18 50 9f 	orh	r8,0x509f
8000b1e2:	e0 69 44 13 	mov	r9,17427
8000b1e6:	ea 19 3f d3 	orh	r9,0x3fd3
8000b1ea:	e0 a0 0d 8d 	rcall	8000cd04 <__avr32_f64_mul>
8000b1ee:	14 98       	mov	r8,r10
8000b1f0:	16 99       	mov	r9,r11
8000b1f2:	00 9a       	mov	r10,r0
8000b1f4:	02 9b       	mov	r11,r1
8000b1f6:	e0 a0 0f 41 	rcall	8000d078 <__avr32_f64_add>
8000b1fa:	14 90       	mov	r0,r10
8000b1fc:	16 91       	mov	r1,r11
8000b1fe:	e0 a0 0f c7 	rcall	8000d18c <__avr32_f64_to_s32>
8000b202:	30 08       	mov	r8,0
8000b204:	18 96       	mov	r6,r12
8000b206:	30 09       	mov	r9,0
8000b208:	00 9a       	mov	r10,r0
8000b20a:	02 9b       	mov	r11,r1
8000b20c:	e0 a0 10 8e 	rcall	8000d328 <__avr32_f64_cmp_lt>
8000b210:	c0 c0       	breq	8000b228 <_dtoa_r+0x1f4>
8000b212:	0c 9c       	mov	r12,r6
8000b214:	e0 a0 0f d3 	rcall	8000d1ba <__avr32_s32_to_f64>
8000b218:	14 98       	mov	r8,r10
8000b21a:	16 99       	mov	r9,r11
8000b21c:	00 9a       	mov	r10,r0
8000b21e:	02 9b       	mov	r11,r1
8000b220:	e0 a0 10 3d 	rcall	8000d29a <__avr32_f64_cmp_eq>
8000b224:	f7 b6 00 01 	subeq	r6,1
8000b228:	59 66       	cp.w	r6,22
8000b22a:	e0 88 00 05 	brls	8000b234 <_dtoa_r+0x200>
8000b22e:	30 18       	mov	r8,1
8000b230:	51 48       	stdsp	sp[0x50],r8
8000b232:	c1 38       	rjmp	8000b258 <_dtoa_r+0x224>
8000b234:	fe c8 be d8 	sub	r8,pc,-16680
8000b238:	fa ea 00 3c 	ld.d	r10,sp[60]
8000b23c:	f0 06 02 38 	ld.d	r8,r8[r6<<0x3]
8000b240:	e0 a0 10 74 	rcall	8000d328 <__avr32_f64_cmp_lt>
8000b244:	f9 b4 00 00 	moveq	r4,0
8000b248:	fb f4 0a 14 	st.weq	sp[0x50],r4
8000b24c:	f7 b6 01 01 	subne	r6,1
8000b250:	f9 bc 01 00 	movne	r12,0
8000b254:	fb fc 1a 14 	st.wne	sp[0x50],r12
8000b258:	41 90       	lddsp	r0,sp[0x64]
8000b25a:	20 10       	sub	r0,1
8000b25c:	0a 10       	sub	r0,r5
8000b25e:	c0 46       	brmi	8000b266 <_dtoa_r+0x232>
8000b260:	50 40       	stdsp	sp[0x10],r0
8000b262:	30 00       	mov	r0,0
8000b264:	c0 48       	rjmp	8000b26c <_dtoa_r+0x238>
8000b266:	30 0b       	mov	r11,0
8000b268:	5c 30       	neg	r0
8000b26a:	50 4b       	stdsp	sp[0x10],r11
8000b26c:	ec 02 11 00 	rsub	r2,r6,0
8000b270:	58 06       	cp.w	r6,0
8000b272:	fb fa 40 04 	ld.wge	r10,sp[0x10]
8000b276:	f5 d6 e4 0a 	addge	r10,r10,r6
8000b27a:	fb fa 4a 04 	st.wge	sp[0x10],r10
8000b27e:	fb f6 4a 11 	st.wge	sp[0x44],r6
8000b282:	f9 b2 04 00 	movge	r2,0
8000b286:	e1 d6 e5 10 	sublt	r0,r0,r6
8000b28a:	f9 b9 05 00 	movlt	r9,0
8000b28e:	fb f9 5a 11 	st.wlt	sp[0x44],r9
8000b292:	40 c8       	lddsp	r8,sp[0x30]
8000b294:	58 98       	cp.w	r8,9
8000b296:	e0 8b 00 20 	brhi	8000b2d6 <_dtoa_r+0x2a2>
8000b29a:	58 58       	cp.w	r8,5
8000b29c:	f9 b4 0a 01 	movle	r4,1
8000b2a0:	fb f5 90 0c 	ld.wgt	r5,sp[0x30]
8000b2a4:	f7 b5 09 04 	subgt	r5,4
8000b2a8:	fb f5 9a 0c 	st.wgt	sp[0x30],r5
8000b2ac:	f9 b4 09 00 	movgt	r4,0
8000b2b0:	40 cc       	lddsp	r12,sp[0x30]
8000b2b2:	58 3c       	cp.w	r12,3
8000b2b4:	c2 d0       	breq	8000b30e <_dtoa_r+0x2da>
8000b2b6:	e0 89 00 05 	brgt	8000b2c0 <_dtoa_r+0x28c>
8000b2ba:	58 2c       	cp.w	r12,2
8000b2bc:	c1 01       	brne	8000b2dc <_dtoa_r+0x2a8>
8000b2be:	c1 88       	rjmp	8000b2ee <_dtoa_r+0x2ba>
8000b2c0:	40 cb       	lddsp	r11,sp[0x30]
8000b2c2:	58 4b       	cp.w	r11,4
8000b2c4:	c0 60       	breq	8000b2d0 <_dtoa_r+0x29c>
8000b2c6:	58 5b       	cp.w	r11,5
8000b2c8:	c0 a1       	brne	8000b2dc <_dtoa_r+0x2a8>
8000b2ca:	30 1a       	mov	r10,1
8000b2cc:	50 da       	stdsp	sp[0x34],r10
8000b2ce:	c2 28       	rjmp	8000b312 <_dtoa_r+0x2de>
8000b2d0:	30 19       	mov	r9,1
8000b2d2:	50 d9       	stdsp	sp[0x34],r9
8000b2d4:	c0 f8       	rjmp	8000b2f2 <_dtoa_r+0x2be>
8000b2d6:	30 08       	mov	r8,0
8000b2d8:	30 14       	mov	r4,1
8000b2da:	50 c8       	stdsp	sp[0x30],r8
8000b2dc:	3f f5       	mov	r5,-1
8000b2de:	30 1c       	mov	r12,1
8000b2e0:	30 0b       	mov	r11,0
8000b2e2:	50 95       	stdsp	sp[0x24],r5
8000b2e4:	50 dc       	stdsp	sp[0x34],r12
8000b2e6:	0a 91       	mov	r1,r5
8000b2e8:	31 28       	mov	r8,18
8000b2ea:	50 eb       	stdsp	sp[0x38],r11
8000b2ec:	c2 08       	rjmp	8000b32c <_dtoa_r+0x2f8>
8000b2ee:	30 0a       	mov	r10,0
8000b2f0:	50 da       	stdsp	sp[0x34],r10
8000b2f2:	40 e9       	lddsp	r9,sp[0x38]
8000b2f4:	58 09       	cp.w	r9,0
8000b2f6:	e0 89 00 07 	brgt	8000b304 <_dtoa_r+0x2d0>
8000b2fa:	30 18       	mov	r8,1
8000b2fc:	50 98       	stdsp	sp[0x24],r8
8000b2fe:	10 91       	mov	r1,r8
8000b300:	50 e8       	stdsp	sp[0x38],r8
8000b302:	c1 58       	rjmp	8000b32c <_dtoa_r+0x2f8>
8000b304:	40 e5       	lddsp	r5,sp[0x38]
8000b306:	50 95       	stdsp	sp[0x24],r5
8000b308:	0a 91       	mov	r1,r5
8000b30a:	0a 98       	mov	r8,r5
8000b30c:	c1 08       	rjmp	8000b32c <_dtoa_r+0x2f8>
8000b30e:	30 0c       	mov	r12,0
8000b310:	50 dc       	stdsp	sp[0x34],r12
8000b312:	40 eb       	lddsp	r11,sp[0x38]
8000b314:	ec 0b 00 0b 	add	r11,r6,r11
8000b318:	50 9b       	stdsp	sp[0x24],r11
8000b31a:	16 98       	mov	r8,r11
8000b31c:	2f f8       	sub	r8,-1
8000b31e:	58 08       	cp.w	r8,0
8000b320:	e0 89 00 05 	brgt	8000b32a <_dtoa_r+0x2f6>
8000b324:	10 91       	mov	r1,r8
8000b326:	30 18       	mov	r8,1
8000b328:	c0 28       	rjmp	8000b32c <_dtoa_r+0x2f8>
8000b32a:	10 91       	mov	r1,r8
8000b32c:	30 09       	mov	r9,0
8000b32e:	6e 9a       	ld.w	r10,r7[0x24]
8000b330:	95 19       	st.w	r10[0x4],r9
8000b332:	30 49       	mov	r9,4
8000b334:	c0 68       	rjmp	8000b340 <_dtoa_r+0x30c>
8000b336:	d7 03       	nop
8000b338:	6a 1a       	ld.w	r10,r5[0x4]
8000b33a:	a1 79       	lsl	r9,0x1
8000b33c:	2f fa       	sub	r10,-1
8000b33e:	8b 1a       	st.w	r5[0x4],r10
8000b340:	6e 95       	ld.w	r5,r7[0x24]
8000b342:	f2 ca ff ec 	sub	r10,r9,-20
8000b346:	10 3a       	cp.w	r10,r8
8000b348:	fe 98 ff f8 	brls	8000b338 <_dtoa_r+0x304>
8000b34c:	6a 1b       	ld.w	r11,r5[0x4]
8000b34e:	0e 9c       	mov	r12,r7
8000b350:	e0 a0 09 44 	rcall	8000c5d8 <_Balloc>
8000b354:	58 e1       	cp.w	r1,14
8000b356:	5f 88       	srls	r8
8000b358:	8b 0c       	st.w	r5[0x0],r12
8000b35a:	f1 e4 00 04 	and	r4,r8,r4
8000b35e:	6e 98       	ld.w	r8,r7[0x24]
8000b360:	70 08       	ld.w	r8,r8[0x0]
8000b362:	50 88       	stdsp	sp[0x20],r8
8000b364:	e0 80 01 82 	breq	8000b668 <_dtoa_r+0x634>
8000b368:	58 06       	cp.w	r6,0
8000b36a:	e0 8a 00 43 	brle	8000b3f0 <_dtoa_r+0x3bc>
8000b36e:	f3 d6 c0 04 	bfextu	r9,r6,0x0,0x4
8000b372:	fe c8 c0 16 	sub	r8,pc,-16362
8000b376:	f0 09 02 34 	ld.d	r4,r8[r9<<0x3]
8000b37a:	fa e5 00 18 	st.d	sp[24],r4
8000b37e:	ec 04 14 04 	asr	r4,r6,0x4
8000b382:	ed b4 00 04 	bld	r4,0x4
8000b386:	c0 30       	breq	8000b38c <_dtoa_r+0x358>
8000b388:	30 25       	mov	r5,2
8000b38a:	c1 08       	rjmp	8000b3aa <_dtoa_r+0x376>
8000b38c:	fe c8 bf 68 	sub	r8,pc,-16536
8000b390:	f0 e8 00 20 	ld.d	r8,r8[32]
8000b394:	fa ea 00 3c 	ld.d	r10,sp[60]
8000b398:	e9 d4 c0 04 	bfextu	r4,r4,0x0,0x4
8000b39c:	e0 a0 0f fa 	rcall	8000d390 <__avr32_f64_div>
8000b3a0:	30 35       	mov	r5,3
8000b3a2:	14 98       	mov	r8,r10
8000b3a4:	16 99       	mov	r9,r11
8000b3a6:	fa e9 00 08 	st.d	sp[8],r8
8000b3aa:	fe cc bf 86 	sub	r12,pc,-16506
8000b3ae:	50 a3       	stdsp	sp[0x28],r3
8000b3b0:	0c 93       	mov	r3,r6
8000b3b2:	18 96       	mov	r6,r12
8000b3b4:	c0 f8       	rjmp	8000b3d2 <_dtoa_r+0x39e>
8000b3b6:	fa ea 00 18 	ld.d	r10,sp[24]
8000b3ba:	ed b4 00 00 	bld	r4,0x0
8000b3be:	c0 81       	brne	8000b3ce <_dtoa_r+0x39a>
8000b3c0:	ec e8 00 00 	ld.d	r8,r6[0]
8000b3c4:	2f f5       	sub	r5,-1
8000b3c6:	e0 a0 0c 9f 	rcall	8000cd04 <__avr32_f64_mul>
8000b3ca:	fa eb 00 18 	st.d	sp[24],r10
8000b3ce:	a1 54       	asr	r4,0x1
8000b3d0:	2f 86       	sub	r6,-8
8000b3d2:	58 04       	cp.w	r4,0
8000b3d4:	cf 11       	brne	8000b3b6 <_dtoa_r+0x382>
8000b3d6:	fa e8 00 18 	ld.d	r8,sp[24]
8000b3da:	fa ea 00 08 	ld.d	r10,sp[8]
8000b3de:	06 96       	mov	r6,r3
8000b3e0:	e0 a0 0f d8 	rcall	8000d390 <__avr32_f64_div>
8000b3e4:	40 a3       	lddsp	r3,sp[0x28]
8000b3e6:	14 98       	mov	r8,r10
8000b3e8:	16 99       	mov	r9,r11
8000b3ea:	fa e9 00 08 	st.d	sp[8],r8
8000b3ee:	c2 f8       	rjmp	8000b44c <_dtoa_r+0x418>
8000b3f0:	ec 08 11 00 	rsub	r8,r6,0
8000b3f4:	c0 31       	brne	8000b3fa <_dtoa_r+0x3c6>
8000b3f6:	30 25       	mov	r5,2
8000b3f8:	c2 a8       	rjmp	8000b44c <_dtoa_r+0x418>
8000b3fa:	fe cc bf d6 	sub	r12,pc,-16426
8000b3fe:	f0 04 14 04 	asr	r4,r8,0x4
8000b402:	50 1c       	stdsp	sp[0x4],r12
8000b404:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
8000b408:	fe c9 c0 ac 	sub	r9,pc,-16212
8000b40c:	fa ea 00 3c 	ld.d	r10,sp[60]
8000b410:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000b414:	e0 a0 0c 78 	rcall	8000cd04 <__avr32_f64_mul>
8000b418:	40 1c       	lddsp	r12,sp[0x4]
8000b41a:	50 63       	stdsp	sp[0x18],r3
8000b41c:	30 25       	mov	r5,2
8000b41e:	0c 93       	mov	r3,r6
8000b420:	fa eb 00 08 	st.d	sp[8],r10
8000b424:	18 96       	mov	r6,r12
8000b426:	c0 f8       	rjmp	8000b444 <_dtoa_r+0x410>
8000b428:	fa ea 00 08 	ld.d	r10,sp[8]
8000b42c:	ed b4 00 00 	bld	r4,0x0
8000b430:	c0 81       	brne	8000b440 <_dtoa_r+0x40c>
8000b432:	ec e8 00 00 	ld.d	r8,r6[0]
8000b436:	2f f5       	sub	r5,-1
8000b438:	e0 a0 0c 66 	rcall	8000cd04 <__avr32_f64_mul>
8000b43c:	fa eb 00 08 	st.d	sp[8],r10
8000b440:	a1 54       	asr	r4,0x1
8000b442:	2f 86       	sub	r6,-8
8000b444:	58 04       	cp.w	r4,0
8000b446:	cf 11       	brne	8000b428 <_dtoa_r+0x3f4>
8000b448:	06 96       	mov	r6,r3
8000b44a:	40 63       	lddsp	r3,sp[0x18]
8000b44c:	41 4a       	lddsp	r10,sp[0x50]
8000b44e:	58 0a       	cp.w	r10,0
8000b450:	c2 a0       	breq	8000b4a4 <_dtoa_r+0x470>
8000b452:	fa e8 00 08 	ld.d	r8,sp[8]
8000b456:	58 01       	cp.w	r1,0
8000b458:	5f 94       	srgt	r4
8000b45a:	fa e9 00 18 	st.d	sp[24],r8
8000b45e:	30 08       	mov	r8,0
8000b460:	fc 19 3f f0 	movh	r9,0x3ff0
8000b464:	fa ea 00 18 	ld.d	r10,sp[24]
8000b468:	e0 a0 0f 60 	rcall	8000d328 <__avr32_f64_cmp_lt>
8000b46c:	f9 bc 00 00 	moveq	r12,0
8000b470:	f9 bc 01 01 	movne	r12,1
8000b474:	e9 ec 00 0c 	and	r12,r4,r12
8000b478:	c1 60       	breq	8000b4a4 <_dtoa_r+0x470>
8000b47a:	40 98       	lddsp	r8,sp[0x24]
8000b47c:	58 08       	cp.w	r8,0
8000b47e:	e0 8a 00 f1 	brle	8000b660 <_dtoa_r+0x62c>
8000b482:	30 08       	mov	r8,0
8000b484:	fc 19 40 24 	movh	r9,0x4024
8000b488:	ec c4 00 01 	sub	r4,r6,1
8000b48c:	fa ea 00 18 	ld.d	r10,sp[24]
8000b490:	2f f5       	sub	r5,-1
8000b492:	50 64       	stdsp	sp[0x18],r4
8000b494:	e0 a0 0c 38 	rcall	8000cd04 <__avr32_f64_mul>
8000b498:	40 94       	lddsp	r4,sp[0x24]
8000b49a:	14 98       	mov	r8,r10
8000b49c:	16 99       	mov	r9,r11
8000b49e:	fa e9 00 08 	st.d	sp[8],r8
8000b4a2:	c0 38       	rjmp	8000b4a8 <_dtoa_r+0x474>
8000b4a4:	50 66       	stdsp	sp[0x18],r6
8000b4a6:	02 94       	mov	r4,r1
8000b4a8:	0a 9c       	mov	r12,r5
8000b4aa:	e0 a0 0e 88 	rcall	8000d1ba <__avr32_s32_to_f64>
8000b4ae:	fa e8 00 08 	ld.d	r8,sp[8]
8000b4b2:	e0 a0 0c 29 	rcall	8000cd04 <__avr32_f64_mul>
8000b4b6:	30 08       	mov	r8,0
8000b4b8:	fc 19 40 1c 	movh	r9,0x401c
8000b4bc:	e0 a0 0d de 	rcall	8000d078 <__avr32_f64_add>
8000b4c0:	14 98       	mov	r8,r10
8000b4c2:	16 99       	mov	r9,r11
8000b4c4:	fa e9 00 28 	st.d	sp[40],r8
8000b4c8:	fc 18 fc c0 	movh	r8,0xfcc0
8000b4cc:	40 a5       	lddsp	r5,sp[0x28]
8000b4ce:	10 05       	add	r5,r8
8000b4d0:	50 a5       	stdsp	sp[0x28],r5
8000b4d2:	58 04       	cp.w	r4,0
8000b4d4:	c2 11       	brne	8000b516 <_dtoa_r+0x4e2>
8000b4d6:	fa ea 00 08 	ld.d	r10,sp[8]
8000b4da:	30 08       	mov	r8,0
8000b4dc:	fc 19 40 14 	movh	r9,0x4014
8000b4e0:	e0 a0 0c fe 	rcall	8000cedc <__avr32_f64_sub>
8000b4e4:	40 bc       	lddsp	r12,sp[0x2c]
8000b4e6:	fa eb 00 08 	st.d	sp[8],r10
8000b4ea:	14 98       	mov	r8,r10
8000b4ec:	16 99       	mov	r9,r11
8000b4ee:	18 9a       	mov	r10,r12
8000b4f0:	0a 9b       	mov	r11,r5
8000b4f2:	e0 a0 0f 1b 	rcall	8000d328 <__avr32_f64_cmp_lt>
8000b4f6:	e0 81 02 54 	brne	8000b99e <_dtoa_r+0x96a>
8000b4fa:	0a 98       	mov	r8,r5
8000b4fc:	40 b9       	lddsp	r9,sp[0x2c]
8000b4fe:	ee 18 80 00 	eorh	r8,0x8000
8000b502:	fa ea 00 08 	ld.d	r10,sp[8]
8000b506:	10 95       	mov	r5,r8
8000b508:	12 98       	mov	r8,r9
8000b50a:	0a 99       	mov	r9,r5
8000b50c:	e0 a0 0f 0e 	rcall	8000d328 <__avr32_f64_cmp_lt>
8000b510:	e0 81 02 3e 	brne	8000b98c <_dtoa_r+0x958>
8000b514:	ca 68       	rjmp	8000b660 <_dtoa_r+0x62c>
8000b516:	fe c9 c1 ba 	sub	r9,pc,-15942
8000b51a:	e8 c8 00 01 	sub	r8,r4,1
8000b51e:	40 d5       	lddsp	r5,sp[0x34]
8000b520:	58 05       	cp.w	r5,0
8000b522:	c4 f0       	breq	8000b5c0 <_dtoa_r+0x58c>
8000b524:	30 0c       	mov	r12,0
8000b526:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000b52a:	51 3c       	stdsp	sp[0x4c],r12
8000b52c:	30 0a       	mov	r10,0
8000b52e:	fc 1b 3f e0 	movh	r11,0x3fe0
8000b532:	e0 a0 0f 2f 	rcall	8000d390 <__avr32_f64_div>
8000b536:	fa e8 00 28 	ld.d	r8,sp[40]
8000b53a:	40 85       	lddsp	r5,sp[0x20]
8000b53c:	e0 a0 0c d0 	rcall	8000cedc <__avr32_f64_sub>
8000b540:	fa eb 00 28 	st.d	sp[40],r10
8000b544:	fa ea 00 08 	ld.d	r10,sp[8]
8000b548:	e0 a0 0e 22 	rcall	8000d18c <__avr32_f64_to_s32>
8000b54c:	51 6c       	stdsp	sp[0x58],r12
8000b54e:	e0 a0 0e 36 	rcall	8000d1ba <__avr32_s32_to_f64>
8000b552:	14 98       	mov	r8,r10
8000b554:	16 99       	mov	r9,r11
8000b556:	fa ea 00 08 	ld.d	r10,sp[8]
8000b55a:	e0 a0 0c c1 	rcall	8000cedc <__avr32_f64_sub>
8000b55e:	fa eb 00 08 	st.d	sp[8],r10
8000b562:	41 68       	lddsp	r8,sp[0x58]
8000b564:	2d 08       	sub	r8,-48
8000b566:	0a c8       	st.b	r5++,r8
8000b568:	41 39       	lddsp	r9,sp[0x4c]
8000b56a:	2f f9       	sub	r9,-1
8000b56c:	51 39       	stdsp	sp[0x4c],r9
8000b56e:	fa e8 00 28 	ld.d	r8,sp[40]
8000b572:	e0 a0 0e db 	rcall	8000d328 <__avr32_f64_cmp_lt>
8000b576:	e0 81 03 39 	brne	8000bbe8 <_dtoa_r+0xbb4>
8000b57a:	fa e8 00 08 	ld.d	r8,sp[8]
8000b57e:	30 0a       	mov	r10,0
8000b580:	fc 1b 3f f0 	movh	r11,0x3ff0
8000b584:	e0 a0 0c ac 	rcall	8000cedc <__avr32_f64_sub>
8000b588:	fa e8 00 28 	ld.d	r8,sp[40]
8000b58c:	e0 a0 0e ce 	rcall	8000d328 <__avr32_f64_cmp_lt>
8000b590:	fa ea 00 28 	ld.d	r10,sp[40]
8000b594:	30 08       	mov	r8,0
8000b596:	fc 19 40 24 	movh	r9,0x4024
8000b59a:	e0 81 00 da 	brne	8000b74e <_dtoa_r+0x71a>
8000b59e:	41 3c       	lddsp	r12,sp[0x4c]
8000b5a0:	08 3c       	cp.w	r12,r4
8000b5a2:	c5 f4       	brge	8000b660 <_dtoa_r+0x62c>
8000b5a4:	e0 a0 0b b0 	rcall	8000cd04 <__avr32_f64_mul>
8000b5a8:	30 08       	mov	r8,0
8000b5aa:	fa eb 00 28 	st.d	sp[40],r10
8000b5ae:	fc 19 40 24 	movh	r9,0x4024
8000b5b2:	fa ea 00 08 	ld.d	r10,sp[8]
8000b5b6:	e0 a0 0b a7 	rcall	8000cd04 <__avr32_f64_mul>
8000b5ba:	fa eb 00 08 	st.d	sp[8],r10
8000b5be:	cc 3b       	rjmp	8000b544 <_dtoa_r+0x510>
8000b5c0:	40 85       	lddsp	r5,sp[0x20]
8000b5c2:	08 05       	add	r5,r4
8000b5c4:	f2 08 02 3a 	ld.d	r10,r9[r8<<0x3]
8000b5c8:	51 35       	stdsp	sp[0x4c],r5
8000b5ca:	fa e8 00 28 	ld.d	r8,sp[40]
8000b5ce:	40 85       	lddsp	r5,sp[0x20]
8000b5d0:	e0 a0 0b 9a 	rcall	8000cd04 <__avr32_f64_mul>
8000b5d4:	fa eb 00 28 	st.d	sp[40],r10
8000b5d8:	fa ea 00 08 	ld.d	r10,sp[8]
8000b5dc:	e0 a0 0d d8 	rcall	8000d18c <__avr32_f64_to_s32>
8000b5e0:	51 6c       	stdsp	sp[0x58],r12
8000b5e2:	e0 a0 0d ec 	rcall	8000d1ba <__avr32_s32_to_f64>
8000b5e6:	14 98       	mov	r8,r10
8000b5e8:	16 99       	mov	r9,r11
8000b5ea:	fa ea 00 08 	ld.d	r10,sp[8]
8000b5ee:	e0 a0 0c 77 	rcall	8000cedc <__avr32_f64_sub>
8000b5f2:	fa eb 00 08 	st.d	sp[8],r10
8000b5f6:	41 68       	lddsp	r8,sp[0x58]
8000b5f8:	2d 08       	sub	r8,-48
8000b5fa:	0a c8       	st.b	r5++,r8
8000b5fc:	41 3c       	lddsp	r12,sp[0x4c]
8000b5fe:	18 35       	cp.w	r5,r12
8000b600:	c2 81       	brne	8000b650 <_dtoa_r+0x61c>
8000b602:	30 08       	mov	r8,0
8000b604:	fc 19 3f e0 	movh	r9,0x3fe0
8000b608:	fa ea 00 28 	ld.d	r10,sp[40]
8000b60c:	e0 a0 0d 36 	rcall	8000d078 <__avr32_f64_add>
8000b610:	40 85       	lddsp	r5,sp[0x20]
8000b612:	fa e8 00 08 	ld.d	r8,sp[8]
8000b616:	08 05       	add	r5,r4
8000b618:	e0 a0 0e 88 	rcall	8000d328 <__avr32_f64_cmp_lt>
8000b61c:	e0 81 00 99 	brne	8000b74e <_dtoa_r+0x71a>
8000b620:	fa e8 00 28 	ld.d	r8,sp[40]
8000b624:	30 0a       	mov	r10,0
8000b626:	fc 1b 3f e0 	movh	r11,0x3fe0
8000b62a:	e0 a0 0c 59 	rcall	8000cedc <__avr32_f64_sub>
8000b62e:	14 98       	mov	r8,r10
8000b630:	16 99       	mov	r9,r11
8000b632:	fa ea 00 08 	ld.d	r10,sp[8]
8000b636:	e0 a0 0e 79 	rcall	8000d328 <__avr32_f64_cmp_lt>
8000b63a:	c1 30       	breq	8000b660 <_dtoa_r+0x62c>
8000b63c:	33 09       	mov	r9,48
8000b63e:	0a 98       	mov	r8,r5
8000b640:	11 7a       	ld.ub	r10,--r8
8000b642:	f2 0a 18 00 	cp.b	r10,r9
8000b646:	e0 81 02 d1 	brne	8000bbe8 <_dtoa_r+0xbb4>
8000b64a:	10 95       	mov	r5,r8
8000b64c:	cf 9b       	rjmp	8000b63e <_dtoa_r+0x60a>
8000b64e:	d7 03       	nop
8000b650:	30 08       	mov	r8,0
8000b652:	fc 19 40 24 	movh	r9,0x4024
8000b656:	e0 a0 0b 57 	rcall	8000cd04 <__avr32_f64_mul>
8000b65a:	fa eb 00 08 	st.d	sp[8],r10
8000b65e:	cb db       	rjmp	8000b5d8 <_dtoa_r+0x5a4>
8000b660:	fa ea 00 3c 	ld.d	r10,sp[60]
8000b664:	fa eb 00 08 	st.d	sp[8],r10
8000b668:	58 e6       	cp.w	r6,14
8000b66a:	5f ab       	srle	r11
8000b66c:	41 8a       	lddsp	r10,sp[0x60]
8000b66e:	30 08       	mov	r8,0
8000b670:	f4 09 11 ff 	rsub	r9,r10,-1
8000b674:	f7 e9 03 f9 	and	r9,r11,r9>>0x1f
8000b678:	f0 09 18 00 	cp.b	r9,r8
8000b67c:	e0 80 00 82 	breq	8000b780 <_dtoa_r+0x74c>
8000b680:	40 ea       	lddsp	r10,sp[0x38]
8000b682:	58 01       	cp.w	r1,0
8000b684:	5f a9       	srle	r9
8000b686:	f3 ea 03 f9 	and	r9,r9,r10>>0x1f
8000b68a:	fe ca c3 2e 	sub	r10,pc,-15570
8000b68e:	f4 06 02 34 	ld.d	r4,r10[r6<<0x3]
8000b692:	fa e5 00 10 	st.d	sp[16],r4
8000b696:	f0 09 18 00 	cp.b	r9,r8
8000b69a:	c1 40       	breq	8000b6c2 <_dtoa_r+0x68e>
8000b69c:	58 01       	cp.w	r1,0
8000b69e:	e0 81 01 77 	brne	8000b98c <_dtoa_r+0x958>
8000b6a2:	30 08       	mov	r8,0
8000b6a4:	fc 19 40 14 	movh	r9,0x4014
8000b6a8:	08 9a       	mov	r10,r4
8000b6aa:	0a 9b       	mov	r11,r5
8000b6ac:	e0 a0 0b 2c 	rcall	8000cd04 <__avr32_f64_mul>
8000b6b0:	fa e8 00 08 	ld.d	r8,sp[8]
8000b6b4:	e0 a0 0e 06 	rcall	8000d2c0 <__avr32_f64_cmp_ge>
8000b6b8:	e0 81 01 6a 	brne	8000b98c <_dtoa_r+0x958>
8000b6bc:	02 92       	mov	r2,r1
8000b6be:	e0 8f 01 72 	bral	8000b9a2 <_dtoa_r+0x96e>
8000b6c2:	40 85       	lddsp	r5,sp[0x20]
8000b6c4:	30 14       	mov	r4,1
8000b6c6:	fa e8 00 10 	ld.d	r8,sp[16]
8000b6ca:	fa ea 00 08 	ld.d	r10,sp[8]
8000b6ce:	e0 a0 0e 61 	rcall	8000d390 <__avr32_f64_div>
8000b6d2:	e0 a0 0d 5d 	rcall	8000d18c <__avr32_f64_to_s32>
8000b6d6:	18 92       	mov	r2,r12
8000b6d8:	e0 a0 0d 71 	rcall	8000d1ba <__avr32_s32_to_f64>
8000b6dc:	fa e8 00 10 	ld.d	r8,sp[16]
8000b6e0:	e0 a0 0b 12 	rcall	8000cd04 <__avr32_f64_mul>
8000b6e4:	14 98       	mov	r8,r10
8000b6e6:	16 99       	mov	r9,r11
8000b6e8:	fa ea 00 08 	ld.d	r10,sp[8]
8000b6ec:	e0 a0 0b f8 	rcall	8000cedc <__avr32_f64_sub>
8000b6f0:	fa eb 00 08 	st.d	sp[8],r10
8000b6f4:	e4 c8 ff d0 	sub	r8,r2,-48
8000b6f8:	0a c8       	st.b	r5++,r8
8000b6fa:	fc 19 40 24 	movh	r9,0x4024
8000b6fe:	30 08       	mov	r8,0
8000b700:	02 34       	cp.w	r4,r1
8000b702:	c3 31       	brne	8000b768 <_dtoa_r+0x734>
8000b704:	fa e8 00 08 	ld.d	r8,sp[8]
8000b708:	e0 a0 0c b8 	rcall	8000d078 <__avr32_f64_add>
8000b70c:	16 91       	mov	r1,r11
8000b70e:	14 90       	mov	r0,r10
8000b710:	14 98       	mov	r8,r10
8000b712:	02 99       	mov	r9,r1
8000b714:	fa ea 00 10 	ld.d	r10,sp[16]
8000b718:	e0 a0 0e 08 	rcall	8000d328 <__avr32_f64_cmp_lt>
8000b71c:	c1 a1       	brne	8000b750 <_dtoa_r+0x71c>
8000b71e:	fa e8 00 10 	ld.d	r8,sp[16]
8000b722:	00 9a       	mov	r10,r0
8000b724:	02 9b       	mov	r11,r1
8000b726:	e0 a0 0d ba 	rcall	8000d29a <__avr32_f64_cmp_eq>
8000b72a:	e0 80 02 5e 	breq	8000bbe6 <_dtoa_r+0xbb2>
8000b72e:	e5 d2 c0 01 	bfextu	r2,r2,0x0,0x1
8000b732:	c0 f1       	brne	8000b750 <_dtoa_r+0x71c>
8000b734:	e0 8f 02 59 	bral	8000bbe6 <_dtoa_r+0xbb2>
8000b738:	40 8a       	lddsp	r10,sp[0x20]
8000b73a:	14 38       	cp.w	r8,r10
8000b73c:	c0 30       	breq	8000b742 <_dtoa_r+0x70e>
8000b73e:	10 95       	mov	r5,r8
8000b740:	c0 98       	rjmp	8000b752 <_dtoa_r+0x71e>
8000b742:	33 08       	mov	r8,48
8000b744:	40 89       	lddsp	r9,sp[0x20]
8000b746:	2f f6       	sub	r6,-1
8000b748:	b2 88       	st.b	r9[0x0],r8
8000b74a:	40 88       	lddsp	r8,sp[0x20]
8000b74c:	c0 88       	rjmp	8000b75c <_dtoa_r+0x728>
8000b74e:	40 66       	lddsp	r6,sp[0x18]
8000b750:	33 99       	mov	r9,57
8000b752:	0a 98       	mov	r8,r5
8000b754:	11 7a       	ld.ub	r10,--r8
8000b756:	f2 0a 18 00 	cp.b	r10,r9
8000b75a:	ce f0       	breq	8000b738 <_dtoa_r+0x704>
8000b75c:	50 66       	stdsp	sp[0x18],r6
8000b75e:	11 89       	ld.ub	r9,r8[0x0]
8000b760:	2f f9       	sub	r9,-1
8000b762:	b0 89       	st.b	r8[0x0],r9
8000b764:	e0 8f 02 42 	bral	8000bbe8 <_dtoa_r+0xbb4>
8000b768:	e0 a0 0a ce 	rcall	8000cd04 <__avr32_f64_mul>
8000b76c:	2f f4       	sub	r4,-1
8000b76e:	fa eb 00 08 	st.d	sp[8],r10
8000b772:	30 08       	mov	r8,0
8000b774:	30 09       	mov	r9,0
8000b776:	e0 a0 0d 92 	rcall	8000d29a <__avr32_f64_cmp_eq>
8000b77a:	ca 60       	breq	8000b6c6 <_dtoa_r+0x692>
8000b77c:	e0 8f 02 35 	bral	8000bbe6 <_dtoa_r+0xbb2>
8000b780:	40 d8       	lddsp	r8,sp[0x34]
8000b782:	58 08       	cp.w	r8,0
8000b784:	c0 51       	brne	8000b78e <_dtoa_r+0x75a>
8000b786:	04 98       	mov	r8,r2
8000b788:	00 95       	mov	r5,r0
8000b78a:	40 d4       	lddsp	r4,sp[0x34]
8000b78c:	c3 78       	rjmp	8000b7fa <_dtoa_r+0x7c6>
8000b78e:	40 c5       	lddsp	r5,sp[0x30]
8000b790:	58 15       	cp.w	r5,1
8000b792:	e0 89 00 0f 	brgt	8000b7b0 <_dtoa_r+0x77c>
8000b796:	41 74       	lddsp	r4,sp[0x5c]
8000b798:	58 04       	cp.w	r4,0
8000b79a:	c0 40       	breq	8000b7a2 <_dtoa_r+0x76e>
8000b79c:	f4 c9 fb cd 	sub	r9,r10,-1075
8000b7a0:	c0 48       	rjmp	8000b7a8 <_dtoa_r+0x774>
8000b7a2:	41 99       	lddsp	r9,sp[0x64]
8000b7a4:	f2 09 11 36 	rsub	r9,r9,54
8000b7a8:	04 98       	mov	r8,r2
8000b7aa:	00 95       	mov	r5,r0
8000b7ac:	c1 c8       	rjmp	8000b7e4 <_dtoa_r+0x7b0>
8000b7ae:	d7 03       	nop
8000b7b0:	e2 c8 00 01 	sub	r8,r1,1
8000b7b4:	58 01       	cp.w	r1,0
8000b7b6:	e0 05 17 40 	movge	r5,r0
8000b7ba:	e2 09 17 40 	movge	r9,r1
8000b7be:	e1 d1 e5 15 	sublt	r5,r0,r1
8000b7c2:	f9 b9 05 00 	movlt	r9,0
8000b7c6:	10 32       	cp.w	r2,r8
8000b7c8:	e5 d8 e4 18 	subge	r8,r2,r8
8000b7cc:	f1 d2 e5 18 	sublt	r8,r8,r2
8000b7d0:	e5 d8 e5 02 	addlt	r2,r2,r8
8000b7d4:	fb fc 50 11 	ld.wlt	r12,sp[0x44]
8000b7d8:	f9 d8 e5 0c 	addlt	r12,r12,r8
8000b7dc:	fb fc 5a 11 	st.wlt	sp[0x44],r12
8000b7e0:	f9 b8 05 00 	movlt	r8,0
8000b7e4:	40 4b       	lddsp	r11,sp[0x10]
8000b7e6:	12 0b       	add	r11,r9
8000b7e8:	50 08       	stdsp	sp[0x0],r8
8000b7ea:	50 4b       	stdsp	sp[0x10],r11
8000b7ec:	12 00       	add	r0,r9
8000b7ee:	30 1b       	mov	r11,1
8000b7f0:	0e 9c       	mov	r12,r7
8000b7f2:	e0 a0 08 a7 	rcall	8000c940 <__i2b>
8000b7f6:	40 08       	lddsp	r8,sp[0x0]
8000b7f8:	18 94       	mov	r4,r12
8000b7fa:	40 4a       	lddsp	r10,sp[0x10]
8000b7fc:	58 05       	cp.w	r5,0
8000b7fe:	5f 99       	srgt	r9
8000b800:	58 0a       	cp.w	r10,0
8000b802:	5f 9a       	srgt	r10
8000b804:	f5 e9 00 09 	and	r9,r10,r9
8000b808:	c0 80       	breq	8000b818 <_dtoa_r+0x7e4>
8000b80a:	40 4c       	lddsp	r12,sp[0x10]
8000b80c:	f8 05 0d 49 	min	r9,r12,r5
8000b810:	12 1c       	sub	r12,r9
8000b812:	12 10       	sub	r0,r9
8000b814:	50 4c       	stdsp	sp[0x10],r12
8000b816:	12 15       	sub	r5,r9
8000b818:	58 02       	cp.w	r2,0
8000b81a:	e0 8a 00 27 	brle	8000b868 <_dtoa_r+0x834>
8000b81e:	40 db       	lddsp	r11,sp[0x34]
8000b820:	58 0b       	cp.w	r11,0
8000b822:	c1 d0       	breq	8000b85c <_dtoa_r+0x828>
8000b824:	58 08       	cp.w	r8,0
8000b826:	e0 8a 00 17 	brle	8000b854 <_dtoa_r+0x820>
8000b82a:	10 9a       	mov	r10,r8
8000b82c:	50 08       	stdsp	sp[0x0],r8
8000b82e:	08 9b       	mov	r11,r4
8000b830:	0e 9c       	mov	r12,r7
8000b832:	e0 a0 08 cd 	rcall	8000c9cc <__pow5mult>
8000b836:	06 9a       	mov	r10,r3
8000b838:	18 9b       	mov	r11,r12
8000b83a:	18 94       	mov	r4,r12
8000b83c:	0e 9c       	mov	r12,r7
8000b83e:	e0 a0 08 01 	rcall	8000c840 <__multiply>
8000b842:	18 99       	mov	r9,r12
8000b844:	06 9b       	mov	r11,r3
8000b846:	50 19       	stdsp	sp[0x4],r9
8000b848:	0e 9c       	mov	r12,r7
8000b84a:	e0 a0 06 ad 	rcall	8000c5a4 <_Bfree>
8000b84e:	40 19       	lddsp	r9,sp[0x4]
8000b850:	40 08       	lddsp	r8,sp[0x0]
8000b852:	12 93       	mov	r3,r9
8000b854:	e4 08 01 0a 	sub	r10,r2,r8
8000b858:	c0 80       	breq	8000b868 <_dtoa_r+0x834>
8000b85a:	c0 28       	rjmp	8000b85e <_dtoa_r+0x82a>
8000b85c:	04 9a       	mov	r10,r2
8000b85e:	06 9b       	mov	r11,r3
8000b860:	0e 9c       	mov	r12,r7
8000b862:	e0 a0 08 b5 	rcall	8000c9cc <__pow5mult>
8000b866:	18 93       	mov	r3,r12
8000b868:	30 1b       	mov	r11,1
8000b86a:	0e 9c       	mov	r12,r7
8000b86c:	e0 a0 08 6a 	rcall	8000c940 <__i2b>
8000b870:	41 1a       	lddsp	r10,sp[0x44]
8000b872:	18 92       	mov	r2,r12
8000b874:	58 0a       	cp.w	r10,0
8000b876:	e0 8a 00 07 	brle	8000b884 <_dtoa_r+0x850>
8000b87a:	18 9b       	mov	r11,r12
8000b87c:	0e 9c       	mov	r12,r7
8000b87e:	e0 a0 08 a7 	rcall	8000c9cc <__pow5mult>
8000b882:	18 92       	mov	r2,r12
8000b884:	40 c9       	lddsp	r9,sp[0x30]
8000b886:	58 19       	cp.w	r9,1
8000b888:	e0 89 00 14 	brgt	8000b8b0 <_dtoa_r+0x87c>
8000b88c:	40 38       	lddsp	r8,sp[0xc]
8000b88e:	58 08       	cp.w	r8,0
8000b890:	c1 01       	brne	8000b8b0 <_dtoa_r+0x87c>
8000b892:	40 29       	lddsp	r9,sp[0x8]
8000b894:	f1 d9 c0 14 	bfextu	r8,r9,0x0,0x14
8000b898:	c0 c1       	brne	8000b8b0 <_dtoa_r+0x87c>
8000b89a:	12 98       	mov	r8,r9
8000b89c:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000b8a0:	c0 80       	breq	8000b8b0 <_dtoa_r+0x87c>
8000b8a2:	40 4c       	lddsp	r12,sp[0x10]
8000b8a4:	30 1b       	mov	r11,1
8000b8a6:	2f fc       	sub	r12,-1
8000b8a8:	2f f0       	sub	r0,-1
8000b8aa:	50 4c       	stdsp	sp[0x10],r12
8000b8ac:	50 6b       	stdsp	sp[0x18],r11
8000b8ae:	c0 38       	rjmp	8000b8b4 <_dtoa_r+0x880>
8000b8b0:	30 0a       	mov	r10,0
8000b8b2:	50 6a       	stdsp	sp[0x18],r10
8000b8b4:	41 19       	lddsp	r9,sp[0x44]
8000b8b6:	58 09       	cp.w	r9,0
8000b8b8:	c0 31       	brne	8000b8be <_dtoa_r+0x88a>
8000b8ba:	30 1c       	mov	r12,1
8000b8bc:	c0 98       	rjmp	8000b8ce <_dtoa_r+0x89a>
8000b8be:	64 48       	ld.w	r8,r2[0x10]
8000b8c0:	2f c8       	sub	r8,-4
8000b8c2:	e4 08 03 2c 	ld.w	r12,r2[r8<<0x2]
8000b8c6:	e0 a0 05 df 	rcall	8000c484 <__hi0bits>
8000b8ca:	f8 0c 11 20 	rsub	r12,r12,32
8000b8ce:	40 4b       	lddsp	r11,sp[0x10]
8000b8d0:	f8 0b 00 08 	add	r8,r12,r11
8000b8d4:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000b8d8:	c0 c0       	breq	8000b8f0 <_dtoa_r+0x8bc>
8000b8da:	f0 08 11 20 	rsub	r8,r8,32
8000b8de:	58 48       	cp.w	r8,4
8000b8e0:	e0 8a 00 06 	brle	8000b8ec <_dtoa_r+0x8b8>
8000b8e4:	20 48       	sub	r8,4
8000b8e6:	10 0b       	add	r11,r8
8000b8e8:	50 4b       	stdsp	sp[0x10],r11
8000b8ea:	c0 78       	rjmp	8000b8f8 <_dtoa_r+0x8c4>
8000b8ec:	58 48       	cp.w	r8,4
8000b8ee:	c0 70       	breq	8000b8fc <_dtoa_r+0x8c8>
8000b8f0:	40 4a       	lddsp	r10,sp[0x10]
8000b8f2:	2e 48       	sub	r8,-28
8000b8f4:	10 0a       	add	r10,r8
8000b8f6:	50 4a       	stdsp	sp[0x10],r10
8000b8f8:	10 00       	add	r0,r8
8000b8fa:	10 05       	add	r5,r8
8000b8fc:	58 00       	cp.w	r0,0
8000b8fe:	e0 8a 00 08 	brle	8000b90e <_dtoa_r+0x8da>
8000b902:	06 9b       	mov	r11,r3
8000b904:	00 9a       	mov	r10,r0
8000b906:	0e 9c       	mov	r12,r7
8000b908:	e0 a0 07 58 	rcall	8000c7b8 <__lshift>
8000b90c:	18 93       	mov	r3,r12
8000b90e:	40 49       	lddsp	r9,sp[0x10]
8000b910:	58 09       	cp.w	r9,0
8000b912:	e0 8a 00 08 	brle	8000b922 <_dtoa_r+0x8ee>
8000b916:	04 9b       	mov	r11,r2
8000b918:	12 9a       	mov	r10,r9
8000b91a:	0e 9c       	mov	r12,r7
8000b91c:	e0 a0 07 4e 	rcall	8000c7b8 <__lshift>
8000b920:	18 92       	mov	r2,r12
8000b922:	41 48       	lddsp	r8,sp[0x50]
8000b924:	58 08       	cp.w	r8,0
8000b926:	c1 b0       	breq	8000b95c <_dtoa_r+0x928>
8000b928:	04 9b       	mov	r11,r2
8000b92a:	06 9c       	mov	r12,r3
8000b92c:	e0 a0 06 23 	rcall	8000c572 <__mcmp>
8000b930:	c1 64       	brge	8000b95c <_dtoa_r+0x928>
8000b932:	06 9b       	mov	r11,r3
8000b934:	30 09       	mov	r9,0
8000b936:	30 aa       	mov	r10,10
8000b938:	0e 9c       	mov	r12,r7
8000b93a:	e0 a0 08 0b 	rcall	8000c950 <__multadd>
8000b93e:	20 16       	sub	r6,1
8000b940:	18 93       	mov	r3,r12
8000b942:	40 dc       	lddsp	r12,sp[0x34]
8000b944:	58 0c       	cp.w	r12,0
8000b946:	c0 31       	brne	8000b94c <_dtoa_r+0x918>
8000b948:	40 91       	lddsp	r1,sp[0x24]
8000b94a:	c0 98       	rjmp	8000b95c <_dtoa_r+0x928>
8000b94c:	08 9b       	mov	r11,r4
8000b94e:	40 91       	lddsp	r1,sp[0x24]
8000b950:	30 09       	mov	r9,0
8000b952:	30 aa       	mov	r10,10
8000b954:	0e 9c       	mov	r12,r7
8000b956:	e0 a0 07 fd 	rcall	8000c950 <__multadd>
8000b95a:	18 94       	mov	r4,r12
8000b95c:	58 01       	cp.w	r1,0
8000b95e:	5f a9       	srle	r9
8000b960:	40 cb       	lddsp	r11,sp[0x30]
8000b962:	58 2b       	cp.w	r11,2
8000b964:	5f 98       	srgt	r8
8000b966:	f3 e8 00 08 	and	r8,r9,r8
8000b96a:	c2 50       	breq	8000b9b4 <_dtoa_r+0x980>
8000b96c:	58 01       	cp.w	r1,0
8000b96e:	c1 11       	brne	8000b990 <_dtoa_r+0x95c>
8000b970:	04 9b       	mov	r11,r2
8000b972:	02 99       	mov	r9,r1
8000b974:	30 5a       	mov	r10,5
8000b976:	0e 9c       	mov	r12,r7
8000b978:	e0 a0 07 ec 	rcall	8000c950 <__multadd>
8000b97c:	18 92       	mov	r2,r12
8000b97e:	18 9b       	mov	r11,r12
8000b980:	06 9c       	mov	r12,r3
8000b982:	e0 a0 05 f8 	rcall	8000c572 <__mcmp>
8000b986:	e0 89 00 0f 	brgt	8000b9a4 <_dtoa_r+0x970>
8000b98a:	c0 38       	rjmp	8000b990 <_dtoa_r+0x95c>
8000b98c:	30 02       	mov	r2,0
8000b98e:	04 94       	mov	r4,r2
8000b990:	40 ea       	lddsp	r10,sp[0x38]
8000b992:	30 09       	mov	r9,0
8000b994:	5c da       	com	r10
8000b996:	40 85       	lddsp	r5,sp[0x20]
8000b998:	50 6a       	stdsp	sp[0x18],r10
8000b99a:	50 49       	stdsp	sp[0x10],r9
8000b99c:	c0 f9       	rjmp	8000bbba <_dtoa_r+0xb86>
8000b99e:	08 92       	mov	r2,r4
8000b9a0:	40 66       	lddsp	r6,sp[0x18]
8000b9a2:	04 94       	mov	r4,r2
8000b9a4:	2f f6       	sub	r6,-1
8000b9a6:	50 66       	stdsp	sp[0x18],r6
8000b9a8:	33 18       	mov	r8,49
8000b9aa:	40 85       	lddsp	r5,sp[0x20]
8000b9ac:	0a c8       	st.b	r5++,r8
8000b9ae:	30 08       	mov	r8,0
8000b9b0:	50 48       	stdsp	sp[0x10],r8
8000b9b2:	c0 49       	rjmp	8000bbba <_dtoa_r+0xb86>
8000b9b4:	40 dc       	lddsp	r12,sp[0x34]
8000b9b6:	58 0c       	cp.w	r12,0
8000b9b8:	e0 80 00 b5 	breq	8000bb22 <_dtoa_r+0xaee>
8000b9bc:	58 05       	cp.w	r5,0
8000b9be:	e0 8a 00 08 	brle	8000b9ce <_dtoa_r+0x99a>
8000b9c2:	08 9b       	mov	r11,r4
8000b9c4:	0a 9a       	mov	r10,r5
8000b9c6:	0e 9c       	mov	r12,r7
8000b9c8:	e0 a0 06 f8 	rcall	8000c7b8 <__lshift>
8000b9cc:	18 94       	mov	r4,r12
8000b9ce:	40 6b       	lddsp	r11,sp[0x18]
8000b9d0:	58 0b       	cp.w	r11,0
8000b9d2:	c0 31       	brne	8000b9d8 <_dtoa_r+0x9a4>
8000b9d4:	08 9c       	mov	r12,r4
8000b9d6:	c1 38       	rjmp	8000b9fc <_dtoa_r+0x9c8>
8000b9d8:	68 1b       	ld.w	r11,r4[0x4]
8000b9da:	0e 9c       	mov	r12,r7
8000b9dc:	e0 a0 05 fe 	rcall	8000c5d8 <_Balloc>
8000b9e0:	68 4a       	ld.w	r10,r4[0x10]
8000b9e2:	18 95       	mov	r5,r12
8000b9e4:	e8 cb ff f4 	sub	r11,r4,-12
8000b9e8:	2f ea       	sub	r10,-2
8000b9ea:	2f 4c       	sub	r12,-12
8000b9ec:	a3 6a       	lsl	r10,0x2
8000b9ee:	fe b0 e6 50 	rcall	8000868e <memcpy>
8000b9f2:	0a 9b       	mov	r11,r5
8000b9f4:	30 1a       	mov	r10,1
8000b9f6:	0e 9c       	mov	r12,r7
8000b9f8:	e0 a0 06 e0 	rcall	8000c7b8 <__lshift>
8000b9fc:	50 44       	stdsp	sp[0x10],r4
8000b9fe:	40 3a       	lddsp	r10,sp[0xc]
8000ba00:	30 19       	mov	r9,1
8000ba02:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
8000ba06:	18 94       	mov	r4,r12
8000ba08:	50 da       	stdsp	sp[0x34],r10
8000ba0a:	40 85       	lddsp	r5,sp[0x20]
8000ba0c:	50 99       	stdsp	sp[0x24],r9
8000ba0e:	50 26       	stdsp	sp[0x8],r6
8000ba10:	50 e1       	stdsp	sp[0x38],r1
8000ba12:	04 9b       	mov	r11,r2
8000ba14:	06 9c       	mov	r12,r3
8000ba16:	fe b0 fa 7f 	rcall	8000af14 <quorem>
8000ba1a:	40 4b       	lddsp	r11,sp[0x10]
8000ba1c:	f8 c0 ff d0 	sub	r0,r12,-48
8000ba20:	06 9c       	mov	r12,r3
8000ba22:	e0 a0 05 a8 	rcall	8000c572 <__mcmp>
8000ba26:	08 9a       	mov	r10,r4
8000ba28:	50 6c       	stdsp	sp[0x18],r12
8000ba2a:	04 9b       	mov	r11,r2
8000ba2c:	0e 9c       	mov	r12,r7
8000ba2e:	e0 a0 06 5d 	rcall	8000c6e8 <__mdiff>
8000ba32:	18 91       	mov	r1,r12
8000ba34:	78 38       	ld.w	r8,r12[0xc]
8000ba36:	58 08       	cp.w	r8,0
8000ba38:	c0 30       	breq	8000ba3e <_dtoa_r+0xa0a>
8000ba3a:	30 16       	mov	r6,1
8000ba3c:	c0 68       	rjmp	8000ba48 <_dtoa_r+0xa14>
8000ba3e:	18 9b       	mov	r11,r12
8000ba40:	06 9c       	mov	r12,r3
8000ba42:	e0 a0 05 98 	rcall	8000c572 <__mcmp>
8000ba46:	18 96       	mov	r6,r12
8000ba48:	0e 9c       	mov	r12,r7
8000ba4a:	02 9b       	mov	r11,r1
8000ba4c:	e0 a0 05 ac 	rcall	8000c5a4 <_Bfree>
8000ba50:	40 cc       	lddsp	r12,sp[0x30]
8000ba52:	ed ec 10 08 	or	r8,r6,r12
8000ba56:	c0 d1       	brne	8000ba70 <_dtoa_r+0xa3c>
8000ba58:	40 db       	lddsp	r11,sp[0x34]
8000ba5a:	58 0b       	cp.w	r11,0
8000ba5c:	c0 a1       	brne	8000ba70 <_dtoa_r+0xa3c>
8000ba5e:	40 26       	lddsp	r6,sp[0x8]
8000ba60:	e0 40 00 39 	cp.w	r0,57
8000ba64:	c3 00       	breq	8000bac4 <_dtoa_r+0xa90>
8000ba66:	40 6a       	lddsp	r10,sp[0x18]
8000ba68:	58 0a       	cp.w	r10,0
8000ba6a:	e0 89 00 24 	brgt	8000bab2 <_dtoa_r+0xa7e>
8000ba6e:	c2 f8       	rjmp	8000bacc <_dtoa_r+0xa98>
8000ba70:	40 69       	lddsp	r9,sp[0x18]
8000ba72:	58 09       	cp.w	r9,0
8000ba74:	c0 85       	brlt	8000ba84 <_dtoa_r+0xa50>
8000ba76:	12 98       	mov	r8,r9
8000ba78:	40 cc       	lddsp	r12,sp[0x30]
8000ba7a:	18 48       	or	r8,r12
8000ba7c:	c1 d1       	brne	8000bab6 <_dtoa_r+0xa82>
8000ba7e:	40 db       	lddsp	r11,sp[0x34]
8000ba80:	58 0b       	cp.w	r11,0
8000ba82:	c1 a1       	brne	8000bab6 <_dtoa_r+0xa82>
8000ba84:	0c 99       	mov	r9,r6
8000ba86:	40 26       	lddsp	r6,sp[0x8]
8000ba88:	58 09       	cp.w	r9,0
8000ba8a:	e0 8a 00 21 	brle	8000bacc <_dtoa_r+0xa98>
8000ba8e:	06 9b       	mov	r11,r3
8000ba90:	30 1a       	mov	r10,1
8000ba92:	0e 9c       	mov	r12,r7
8000ba94:	e0 a0 06 92 	rcall	8000c7b8 <__lshift>
8000ba98:	04 9b       	mov	r11,r2
8000ba9a:	18 93       	mov	r3,r12
8000ba9c:	e0 a0 05 6b 	rcall	8000c572 <__mcmp>
8000baa0:	e0 89 00 06 	brgt	8000baac <_dtoa_r+0xa78>
8000baa4:	c1 41       	brne	8000bacc <_dtoa_r+0xa98>
8000baa6:	ed b0 00 00 	bld	r0,0x0
8000baaa:	c1 11       	brne	8000bacc <_dtoa_r+0xa98>
8000baac:	e0 40 00 39 	cp.w	r0,57
8000bab0:	c0 a0       	breq	8000bac4 <_dtoa_r+0xa90>
8000bab2:	2f f0       	sub	r0,-1
8000bab4:	c0 c8       	rjmp	8000bacc <_dtoa_r+0xa98>
8000bab6:	58 06       	cp.w	r6,0
8000bab8:	e0 8a 00 0c 	brle	8000bad0 <_dtoa_r+0xa9c>
8000babc:	40 26       	lddsp	r6,sp[0x8]
8000babe:	e0 40 00 39 	cp.w	r0,57
8000bac2:	c0 41       	brne	8000baca <_dtoa_r+0xa96>
8000bac4:	33 98       	mov	r8,57
8000bac6:	0a c8       	st.b	r5++,r8
8000bac8:	c6 78       	rjmp	8000bb96 <_dtoa_r+0xb62>
8000baca:	2f f0       	sub	r0,-1
8000bacc:	0a c0       	st.b	r5++,r0
8000bace:	c7 58       	rjmp	8000bbb8 <_dtoa_r+0xb84>
8000bad0:	0a c0       	st.b	r5++,r0
8000bad2:	40 9a       	lddsp	r10,sp[0x24]
8000bad4:	40 e9       	lddsp	r9,sp[0x38]
8000bad6:	12 3a       	cp.w	r10,r9
8000bad8:	c4 30       	breq	8000bb5e <_dtoa_r+0xb2a>
8000bada:	06 9b       	mov	r11,r3
8000badc:	30 09       	mov	r9,0
8000bade:	30 aa       	mov	r10,10
8000bae0:	0e 9c       	mov	r12,r7
8000bae2:	e0 a0 07 37 	rcall	8000c950 <__multadd>
8000bae6:	40 48       	lddsp	r8,sp[0x10]
8000bae8:	18 93       	mov	r3,r12
8000baea:	08 38       	cp.w	r8,r4
8000baec:	c0 91       	brne	8000bafe <_dtoa_r+0xaca>
8000baee:	10 9b       	mov	r11,r8
8000baf0:	30 09       	mov	r9,0
8000baf2:	30 aa       	mov	r10,10
8000baf4:	0e 9c       	mov	r12,r7
8000baf6:	e0 a0 07 2d 	rcall	8000c950 <__multadd>
8000bafa:	50 4c       	stdsp	sp[0x10],r12
8000bafc:	c0 e8       	rjmp	8000bb18 <_dtoa_r+0xae4>
8000bafe:	40 4b       	lddsp	r11,sp[0x10]
8000bb00:	30 09       	mov	r9,0
8000bb02:	30 aa       	mov	r10,10
8000bb04:	0e 9c       	mov	r12,r7
8000bb06:	e0 a0 07 25 	rcall	8000c950 <__multadd>
8000bb0a:	08 9b       	mov	r11,r4
8000bb0c:	50 4c       	stdsp	sp[0x10],r12
8000bb0e:	30 09       	mov	r9,0
8000bb10:	30 aa       	mov	r10,10
8000bb12:	0e 9c       	mov	r12,r7
8000bb14:	e0 a0 07 1e 	rcall	8000c950 <__multadd>
8000bb18:	18 94       	mov	r4,r12
8000bb1a:	40 9c       	lddsp	r12,sp[0x24]
8000bb1c:	2f fc       	sub	r12,-1
8000bb1e:	50 9c       	stdsp	sp[0x24],r12
8000bb20:	c7 9b       	rjmp	8000ba12 <_dtoa_r+0x9de>
8000bb22:	30 18       	mov	r8,1
8000bb24:	06 90       	mov	r0,r3
8000bb26:	40 85       	lddsp	r5,sp[0x20]
8000bb28:	08 93       	mov	r3,r4
8000bb2a:	0c 94       	mov	r4,r6
8000bb2c:	10 96       	mov	r6,r8
8000bb2e:	04 9b       	mov	r11,r2
8000bb30:	00 9c       	mov	r12,r0
8000bb32:	fe b0 f9 f1 	rcall	8000af14 <quorem>
8000bb36:	2d 0c       	sub	r12,-48
8000bb38:	0a cc       	st.b	r5++,r12
8000bb3a:	02 36       	cp.w	r6,r1
8000bb3c:	c0 a4       	brge	8000bb50 <_dtoa_r+0xb1c>
8000bb3e:	00 9b       	mov	r11,r0
8000bb40:	30 09       	mov	r9,0
8000bb42:	30 aa       	mov	r10,10
8000bb44:	0e 9c       	mov	r12,r7
8000bb46:	2f f6       	sub	r6,-1
8000bb48:	e0 a0 07 04 	rcall	8000c950 <__multadd>
8000bb4c:	18 90       	mov	r0,r12
8000bb4e:	cf 0b       	rjmp	8000bb2e <_dtoa_r+0xafa>
8000bb50:	08 96       	mov	r6,r4
8000bb52:	30 0b       	mov	r11,0
8000bb54:	06 94       	mov	r4,r3
8000bb56:	50 4b       	stdsp	sp[0x10],r11
8000bb58:	00 93       	mov	r3,r0
8000bb5a:	18 90       	mov	r0,r12
8000bb5c:	c0 28       	rjmp	8000bb60 <_dtoa_r+0xb2c>
8000bb5e:	40 26       	lddsp	r6,sp[0x8]
8000bb60:	06 9b       	mov	r11,r3
8000bb62:	30 1a       	mov	r10,1
8000bb64:	0e 9c       	mov	r12,r7
8000bb66:	e0 a0 06 29 	rcall	8000c7b8 <__lshift>
8000bb6a:	04 9b       	mov	r11,r2
8000bb6c:	18 93       	mov	r3,r12
8000bb6e:	e0 a0 05 02 	rcall	8000c572 <__mcmp>
8000bb72:	e0 89 00 12 	brgt	8000bb96 <_dtoa_r+0xb62>
8000bb76:	c1 b1       	brne	8000bbac <_dtoa_r+0xb78>
8000bb78:	e1 d0 c0 01 	bfextu	r0,r0,0x0,0x1
8000bb7c:	c0 d1       	brne	8000bb96 <_dtoa_r+0xb62>
8000bb7e:	c1 78       	rjmp	8000bbac <_dtoa_r+0xb78>
8000bb80:	40 89       	lddsp	r9,sp[0x20]
8000bb82:	12 38       	cp.w	r8,r9
8000bb84:	c0 30       	breq	8000bb8a <_dtoa_r+0xb56>
8000bb86:	10 95       	mov	r5,r8
8000bb88:	c0 88       	rjmp	8000bb98 <_dtoa_r+0xb64>
8000bb8a:	2f f6       	sub	r6,-1
8000bb8c:	50 66       	stdsp	sp[0x18],r6
8000bb8e:	33 18       	mov	r8,49
8000bb90:	40 8c       	lddsp	r12,sp[0x20]
8000bb92:	b8 88       	st.b	r12[0x0],r8
8000bb94:	c1 38       	rjmp	8000bbba <_dtoa_r+0xb86>
8000bb96:	33 9a       	mov	r10,57
8000bb98:	0a 98       	mov	r8,r5
8000bb9a:	11 79       	ld.ub	r9,--r8
8000bb9c:	f4 09 18 00 	cp.b	r9,r10
8000bba0:	cf 00       	breq	8000bb80 <_dtoa_r+0xb4c>
8000bba2:	2f f9       	sub	r9,-1
8000bba4:	b0 89       	st.b	r8[0x0],r9
8000bba6:	c0 98       	rjmp	8000bbb8 <_dtoa_r+0xb84>
8000bba8:	10 95       	mov	r5,r8
8000bbaa:	c0 28       	rjmp	8000bbae <_dtoa_r+0xb7a>
8000bbac:	33 09       	mov	r9,48
8000bbae:	0a 98       	mov	r8,r5
8000bbb0:	11 7a       	ld.ub	r10,--r8
8000bbb2:	f2 0a 18 00 	cp.b	r10,r9
8000bbb6:	cf 90       	breq	8000bba8 <_dtoa_r+0xb74>
8000bbb8:	50 66       	stdsp	sp[0x18],r6
8000bbba:	04 9b       	mov	r11,r2
8000bbbc:	0e 9c       	mov	r12,r7
8000bbbe:	e0 a0 04 f3 	rcall	8000c5a4 <_Bfree>
8000bbc2:	58 04       	cp.w	r4,0
8000bbc4:	c1 20       	breq	8000bbe8 <_dtoa_r+0xbb4>
8000bbc6:	40 4b       	lddsp	r11,sp[0x10]
8000bbc8:	08 3b       	cp.w	r11,r4
8000bbca:	5f 19       	srne	r9
8000bbcc:	58 0b       	cp.w	r11,0
8000bbce:	5f 18       	srne	r8
8000bbd0:	f3 e8 00 08 	and	r8,r9,r8
8000bbd4:	c0 40       	breq	8000bbdc <_dtoa_r+0xba8>
8000bbd6:	0e 9c       	mov	r12,r7
8000bbd8:	e0 a0 04 e6 	rcall	8000c5a4 <_Bfree>
8000bbdc:	08 9b       	mov	r11,r4
8000bbde:	0e 9c       	mov	r12,r7
8000bbe0:	e0 a0 04 e2 	rcall	8000c5a4 <_Bfree>
8000bbe4:	c0 28       	rjmp	8000bbe8 <_dtoa_r+0xbb4>
8000bbe6:	50 66       	stdsp	sp[0x18],r6
8000bbe8:	0e 9c       	mov	r12,r7
8000bbea:	06 9b       	mov	r11,r3
8000bbec:	e0 a0 04 dc 	rcall	8000c5a4 <_Bfree>
8000bbf0:	30 08       	mov	r8,0
8000bbf2:	aa 88       	st.b	r5[0x0],r8
8000bbf4:	40 68       	lddsp	r8,sp[0x18]
8000bbf6:	41 5a       	lddsp	r10,sp[0x54]
8000bbf8:	2f f8       	sub	r8,-1
8000bbfa:	41 29       	lddsp	r9,sp[0x48]
8000bbfc:	95 08       	st.w	r10[0x0],r8
8000bbfe:	40 8c       	lddsp	r12,sp[0x20]
8000bc00:	58 09       	cp.w	r9,0
8000bc02:	fb f8 10 12 	ld.wne	r8,sp[0x48]
8000bc06:	f1 f5 1a 00 	st.wne	r8[0x0],r5
8000bc0a:	2e 6d       	sub	sp,-104
8000bc0c:	d8 32       	popm	r0-r7,pc
8000bc0e:	d7 03       	nop

8000bc10 <__errno>:
8000bc10:	e0 68 0a 54 	mov	r8,2644
8000bc14:	70 0c       	ld.w	r12,r8[0x0]
8000bc16:	2f 4c       	sub	r12,-12
8000bc18:	5e fc       	retal	r12
8000bc1a:	d7 03       	nop

8000bc1c <_fflush_r>:
8000bc1c:	d4 21       	pushm	r4-r7,lr
8000bc1e:	16 97       	mov	r7,r11
8000bc20:	18 96       	mov	r6,r12
8000bc22:	76 48       	ld.w	r8,r11[0x10]
8000bc24:	58 08       	cp.w	r8,0
8000bc26:	c7 f0       	breq	8000bd24 <_fflush_r+0x108>
8000bc28:	58 0c       	cp.w	r12,0
8000bc2a:	c0 50       	breq	8000bc34 <_fflush_r+0x18>
8000bc2c:	78 68       	ld.w	r8,r12[0x18]
8000bc2e:	58 08       	cp.w	r8,0
8000bc30:	c0 21       	brne	8000bc34 <_fflush_r+0x18>
8000bc32:	cc dc       	rcall	8000bdcc <__sinit>
8000bc34:	fe c8 c9 88 	sub	r8,pc,-13944
8000bc38:	10 37       	cp.w	r7,r8
8000bc3a:	c0 31       	brne	8000bc40 <_fflush_r+0x24>
8000bc3c:	6c 07       	ld.w	r7,r6[0x0]
8000bc3e:	c0 c8       	rjmp	8000bc56 <_fflush_r+0x3a>
8000bc40:	fe c8 c9 74 	sub	r8,pc,-13964
8000bc44:	10 37       	cp.w	r7,r8
8000bc46:	c0 31       	brne	8000bc4c <_fflush_r+0x30>
8000bc48:	6c 17       	ld.w	r7,r6[0x4]
8000bc4a:	c0 68       	rjmp	8000bc56 <_fflush_r+0x3a>
8000bc4c:	fe c8 c9 60 	sub	r8,pc,-13984
8000bc50:	10 37       	cp.w	r7,r8
8000bc52:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000bc56:	8e 6a       	ld.sh	r10,r7[0xc]
8000bc58:	14 98       	mov	r8,r10
8000bc5a:	ed ba 00 03 	bld	r10,0x3
8000bc5e:	c4 20       	breq	8000bce2 <_fflush_r+0xc6>
8000bc60:	ab ba       	sbr	r10,0xb
8000bc62:	ae 6a       	st.h	r7[0xc],r10
8000bc64:	6e 18       	ld.w	r8,r7[0x4]
8000bc66:	58 08       	cp.w	r8,0
8000bc68:	e0 89 00 06 	brgt	8000bc74 <_fflush_r+0x58>
8000bc6c:	6f 08       	ld.w	r8,r7[0x40]
8000bc6e:	58 08       	cp.w	r8,0
8000bc70:	e0 8a 00 5a 	brle	8000bd24 <_fflush_r+0x108>
8000bc74:	6e b8       	ld.w	r8,r7[0x2c]
8000bc76:	58 08       	cp.w	r8,0
8000bc78:	c5 60       	breq	8000bd24 <_fflush_r+0x108>
8000bc7a:	e2 1a 10 00 	andl	r10,0x1000,COH
8000bc7e:	c0 30       	breq	8000bc84 <_fflush_r+0x68>
8000bc80:	6f 55       	ld.w	r5,r7[0x54]
8000bc82:	c0 f8       	rjmp	8000bca0 <_fflush_r+0x84>
8000bc84:	30 19       	mov	r9,1
8000bc86:	6e 8b       	ld.w	r11,r7[0x20]
8000bc88:	0c 9c       	mov	r12,r6
8000bc8a:	5d 18       	icall	r8
8000bc8c:	18 95       	mov	r5,r12
8000bc8e:	5b fc       	cp.w	r12,-1
8000bc90:	c0 81       	brne	8000bca0 <_fflush_r+0x84>
8000bc92:	6c 38       	ld.w	r8,r6[0xc]
8000bc94:	59 d8       	cp.w	r8,29
8000bc96:	c4 70       	breq	8000bd24 <_fflush_r+0x108>
8000bc98:	8e 68       	ld.sh	r8,r7[0xc]
8000bc9a:	a7 a8       	sbr	r8,0x6
8000bc9c:	ae 68       	st.h	r7[0xc],r8
8000bc9e:	d8 22       	popm	r4-r7,pc
8000bca0:	8e 68       	ld.sh	r8,r7[0xc]
8000bca2:	ed b8 00 02 	bld	r8,0x2
8000bca6:	c0 91       	brne	8000bcb8 <_fflush_r+0x9c>
8000bca8:	6e 18       	ld.w	r8,r7[0x4]
8000bcaa:	10 15       	sub	r5,r8
8000bcac:	6e d8       	ld.w	r8,r7[0x34]
8000bcae:	58 08       	cp.w	r8,0
8000bcb0:	ef f8 10 10 	ld.wne	r8,r7[0x40]
8000bcb4:	eb d8 e1 15 	subne	r5,r5,r8
8000bcb8:	6e b8       	ld.w	r8,r7[0x2c]
8000bcba:	0c 9c       	mov	r12,r6
8000bcbc:	30 09       	mov	r9,0
8000bcbe:	0a 9a       	mov	r10,r5
8000bcc0:	6e 8b       	ld.w	r11,r7[0x20]
8000bcc2:	5d 18       	icall	r8
8000bcc4:	8e 68       	ld.sh	r8,r7[0xc]
8000bcc6:	0a 3c       	cp.w	r12,r5
8000bcc8:	c2 61       	brne	8000bd14 <_fflush_r+0xf8>
8000bcca:	ab d8       	cbr	r8,0xb
8000bccc:	30 0c       	mov	r12,0
8000bcce:	6e 49       	ld.w	r9,r7[0x10]
8000bcd0:	ae 68       	st.h	r7[0xc],r8
8000bcd2:	8f 1c       	st.w	r7[0x4],r12
8000bcd4:	8f 09       	st.w	r7[0x0],r9
8000bcd6:	ed b8 00 0c 	bld	r8,0xc
8000bcda:	c2 51       	brne	8000bd24 <_fflush_r+0x108>
8000bcdc:	ef 45 00 54 	st.w	r7[84],r5
8000bce0:	d8 22       	popm	r4-r7,pc
8000bce2:	6e 45       	ld.w	r5,r7[0x10]
8000bce4:	58 05       	cp.w	r5,0
8000bce6:	c1 f0       	breq	8000bd24 <_fflush_r+0x108>
8000bce8:	6e 04       	ld.w	r4,r7[0x0]
8000bcea:	f5 da c0 02 	bfextu	r10,r10,0x0,0x2
8000bcee:	8f 05       	st.w	r7[0x0],r5
8000bcf0:	f9 b8 01 00 	movne	r8,0
8000bcf4:	ef f8 00 05 	ld.weq	r8,r7[0x14]
8000bcf8:	0a 14       	sub	r4,r5
8000bcfa:	8f 28       	st.w	r7[0x8],r8
8000bcfc:	c1 18       	rjmp	8000bd1e <_fflush_r+0x102>
8000bcfe:	08 99       	mov	r9,r4
8000bd00:	0a 9a       	mov	r10,r5
8000bd02:	6e a8       	ld.w	r8,r7[0x28]
8000bd04:	6e 8b       	ld.w	r11,r7[0x20]
8000bd06:	0c 9c       	mov	r12,r6
8000bd08:	5d 18       	icall	r8
8000bd0a:	18 14       	sub	r4,r12
8000bd0c:	58 0c       	cp.w	r12,0
8000bd0e:	e0 89 00 07 	brgt	8000bd1c <_fflush_r+0x100>
8000bd12:	8e 68       	ld.sh	r8,r7[0xc]
8000bd14:	a7 a8       	sbr	r8,0x6
8000bd16:	3f fc       	mov	r12,-1
8000bd18:	ae 68       	st.h	r7[0xc],r8
8000bd1a:	d8 22       	popm	r4-r7,pc
8000bd1c:	18 05       	add	r5,r12
8000bd1e:	58 04       	cp.w	r4,0
8000bd20:	fe 99 ff ef 	brgt	8000bcfe <_fflush_r+0xe2>
8000bd24:	d8 2a       	popm	r4-r7,pc,r12=0
8000bd26:	d7 03       	nop

8000bd28 <__sfp_lock_acquire>:
8000bd28:	5e fc       	retal	r12

8000bd2a <__sfp_lock_release>:
8000bd2a:	5e fc       	retal	r12

8000bd2c <_cleanup_r>:
8000bd2c:	d4 01       	pushm	lr
8000bd2e:	fe cb f0 ae 	sub	r11,pc,-3922
8000bd32:	e0 a0 02 f7 	rcall	8000c320 <_fwalk>
8000bd36:	d8 02       	popm	pc

8000bd38 <__sfmoreglue>:
8000bd38:	d4 21       	pushm	r4-r7,lr
8000bd3a:	16 95       	mov	r5,r11
8000bd3c:	f6 06 10 5c 	mul	r6,r11,92
8000bd40:	ec cb ff f4 	sub	r11,r6,-12
8000bd44:	fe b0 e2 76 	rcall	80008230 <_malloc_r>
8000bd48:	18 97       	mov	r7,r12
8000bd4a:	c0 90       	breq	8000bd5c <__sfmoreglue+0x24>
8000bd4c:	99 15       	st.w	r12[0x4],r5
8000bd4e:	30 0b       	mov	r11,0
8000bd50:	2f 4c       	sub	r12,-12
8000bd52:	0c 9a       	mov	r10,r6
8000bd54:	8f 2c       	st.w	r7[0x8],r12
8000bd56:	8f 0b       	st.w	r7[0x0],r11
8000bd58:	fe b0 e5 3f 	rcall	800087d6 <memset>
8000bd5c:	0e 9c       	mov	r12,r7
8000bd5e:	d8 22       	popm	r4-r7,pc

8000bd60 <__sfp>:
8000bd60:	d4 21       	pushm	r4-r7,lr
8000bd62:	fe c8 ca 52 	sub	r8,pc,-13742
8000bd66:	18 96       	mov	r6,r12
8000bd68:	70 07       	ld.w	r7,r8[0x0]
8000bd6a:	6e 68       	ld.w	r8,r7[0x18]
8000bd6c:	58 08       	cp.w	r8,0
8000bd6e:	c0 31       	brne	8000bd74 <__sfp+0x14>
8000bd70:	0e 9c       	mov	r12,r7
8000bd72:	c2 dc       	rcall	8000bdcc <__sinit>
8000bd74:	ee c7 ff 28 	sub	r7,r7,-216
8000bd78:	30 05       	mov	r5,0
8000bd7a:	6e 2c       	ld.w	r12,r7[0x8]
8000bd7c:	6e 18       	ld.w	r8,r7[0x4]
8000bd7e:	c0 68       	rjmp	8000bd8a <__sfp+0x2a>
8000bd80:	98 69       	ld.sh	r9,r12[0xc]
8000bd82:	ea 09 19 00 	cp.h	r9,r5
8000bd86:	c1 10       	breq	8000bda8 <__sfp+0x48>
8000bd88:	2a 4c       	sub	r12,-92
8000bd8a:	20 18       	sub	r8,1
8000bd8c:	cf a7       	brpl	8000bd80 <__sfp+0x20>
8000bd8e:	6e 08       	ld.w	r8,r7[0x0]
8000bd90:	58 08       	cp.w	r8,0
8000bd92:	c0 61       	brne	8000bd9e <__sfp+0x3e>
8000bd94:	30 4b       	mov	r11,4
8000bd96:	0c 9c       	mov	r12,r6
8000bd98:	cd 0f       	rcall	8000bd38 <__sfmoreglue>
8000bd9a:	8f 0c       	st.w	r7[0x0],r12
8000bd9c:	c0 30       	breq	8000bda2 <__sfp+0x42>
8000bd9e:	6e 07       	ld.w	r7,r7[0x0]
8000bda0:	ce db       	rjmp	8000bd7a <__sfp+0x1a>
8000bda2:	30 c8       	mov	r8,12
8000bda4:	8d 38       	st.w	r6[0xc],r8
8000bda6:	d8 22       	popm	r4-r7,pc
8000bda8:	30 08       	mov	r8,0
8000bdaa:	f9 48 00 4c 	st.w	r12[76],r8
8000bdae:	99 08       	st.w	r12[0x0],r8
8000bdb0:	99 28       	st.w	r12[0x8],r8
8000bdb2:	99 18       	st.w	r12[0x4],r8
8000bdb4:	99 48       	st.w	r12[0x10],r8
8000bdb6:	99 58       	st.w	r12[0x14],r8
8000bdb8:	99 68       	st.w	r12[0x18],r8
8000bdba:	99 d8       	st.w	r12[0x34],r8
8000bdbc:	99 e8       	st.w	r12[0x38],r8
8000bdbe:	f9 48 00 48 	st.w	r12[72],r8
8000bdc2:	3f f8       	mov	r8,-1
8000bdc4:	b8 78       	st.h	r12[0xe],r8
8000bdc6:	30 18       	mov	r8,1
8000bdc8:	b8 68       	st.h	r12[0xc],r8
8000bdca:	d8 22       	popm	r4-r7,pc

8000bdcc <__sinit>:
8000bdcc:	d4 21       	pushm	r4-r7,lr
8000bdce:	18 96       	mov	r6,r12
8000bdd0:	78 67       	ld.w	r7,r12[0x18]
8000bdd2:	58 07       	cp.w	r7,0
8000bdd4:	c4 91       	brne	8000be66 <__sinit+0x9a>
8000bdd6:	fe c8 00 aa 	sub	r8,pc,170
8000bdda:	30 15       	mov	r5,1
8000bddc:	99 a8       	st.w	r12[0x28],r8
8000bdde:	f9 47 00 d8 	st.w	r12[216],r7
8000bde2:	f9 47 00 dc 	st.w	r12[220],r7
8000bde6:	f9 47 00 e0 	st.w	r12[224],r7
8000bdea:	99 65       	st.w	r12[0x18],r5
8000bdec:	cb af       	rcall	8000bd60 <__sfp>
8000bdee:	8d 0c       	st.w	r6[0x0],r12
8000bdf0:	0c 9c       	mov	r12,r6
8000bdf2:	cb 7f       	rcall	8000bd60 <__sfp>
8000bdf4:	8d 1c       	st.w	r6[0x4],r12
8000bdf6:	0c 9c       	mov	r12,r6
8000bdf8:	cb 4f       	rcall	8000bd60 <__sfp>
8000bdfa:	6c 09       	ld.w	r9,r6[0x0]
8000bdfc:	30 48       	mov	r8,4
8000bdfe:	93 07       	st.w	r9[0x0],r7
8000be00:	b2 68       	st.h	r9[0xc],r8
8000be02:	93 17       	st.w	r9[0x4],r7
8000be04:	93 27       	st.w	r9[0x8],r7
8000be06:	6c 18       	ld.w	r8,r6[0x4]
8000be08:	b2 77       	st.h	r9[0xe],r7
8000be0a:	93 47       	st.w	r9[0x10],r7
8000be0c:	93 57       	st.w	r9[0x14],r7
8000be0e:	93 67       	st.w	r9[0x18],r7
8000be10:	93 89       	st.w	r9[0x20],r9
8000be12:	91 07       	st.w	r8[0x0],r7
8000be14:	91 17       	st.w	r8[0x4],r7
8000be16:	91 27       	st.w	r8[0x8],r7
8000be18:	fe ce f3 24 	sub	lr,pc,-3292
8000be1c:	fe cb f3 54 	sub	r11,pc,-3244
8000be20:	93 9e       	st.w	r9[0x24],lr
8000be22:	93 ab       	st.w	r9[0x28],r11
8000be24:	fe ca f3 7c 	sub	r10,pc,-3204
8000be28:	fe c4 f3 88 	sub	r4,pc,-3192
8000be2c:	93 ba       	st.w	r9[0x2c],r10
8000be2e:	93 c4       	st.w	r9[0x30],r4
8000be30:	30 99       	mov	r9,9
8000be32:	b0 69       	st.h	r8[0xc],r9
8000be34:	b0 75       	st.h	r8[0xe],r5
8000be36:	91 c4       	st.w	r8[0x30],r4
8000be38:	91 47       	st.w	r8[0x10],r7
8000be3a:	91 57       	st.w	r8[0x14],r7
8000be3c:	91 67       	st.w	r8[0x18],r7
8000be3e:	91 88       	st.w	r8[0x20],r8
8000be40:	91 9e       	st.w	r8[0x24],lr
8000be42:	91 ab       	st.w	r8[0x28],r11
8000be44:	91 ba       	st.w	r8[0x2c],r10
8000be46:	8d 2c       	st.w	r6[0x8],r12
8000be48:	31 28       	mov	r8,18
8000be4a:	99 07       	st.w	r12[0x0],r7
8000be4c:	b8 68       	st.h	r12[0xc],r8
8000be4e:	99 17       	st.w	r12[0x4],r7
8000be50:	99 27       	st.w	r12[0x8],r7
8000be52:	30 28       	mov	r8,2
8000be54:	b8 78       	st.h	r12[0xe],r8
8000be56:	99 c4       	st.w	r12[0x30],r4
8000be58:	99 67       	st.w	r12[0x18],r7
8000be5a:	99 9e       	st.w	r12[0x24],lr
8000be5c:	99 ab       	st.w	r12[0x28],r11
8000be5e:	99 ba       	st.w	r12[0x2c],r10
8000be60:	99 47       	st.w	r12[0x10],r7
8000be62:	99 57       	st.w	r12[0x14],r7
8000be64:	99 8c       	st.w	r12[0x20],r12
8000be66:	d8 22       	popm	r4-r7,pc

8000be68 <_malloc_trim_r>:
8000be68:	d4 21       	pushm	r4-r7,lr
8000be6a:	16 95       	mov	r5,r11
8000be6c:	18 97       	mov	r7,r12
8000be6e:	fe b0 d7 9b 	rcall	80006da4 <__malloc_lock>
8000be72:	e0 64 05 54 	mov	r4,1364
8000be76:	68 28       	ld.w	r8,r4[0x8]
8000be78:	70 16       	ld.w	r6,r8[0x4]
8000be7a:	e0 16 ff fc 	andl	r6,0xfffc
8000be7e:	ec c8 ff 91 	sub	r8,r6,-111
8000be82:	f0 05 01 05 	sub	r5,r8,r5
8000be86:	e0 15 ff 80 	andl	r5,0xff80
8000be8a:	ea c5 00 80 	sub	r5,r5,128
8000be8e:	e0 45 00 7f 	cp.w	r5,127
8000be92:	e0 8a 00 25 	brle	8000bedc <_malloc_trim_r+0x74>
8000be96:	30 0b       	mov	r11,0
8000be98:	0e 9c       	mov	r12,r7
8000be9a:	fe b0 e6 05 	rcall	80008aa4 <_sbrk_r>
8000be9e:	68 28       	ld.w	r8,r4[0x8]
8000bea0:	0c 08       	add	r8,r6
8000bea2:	10 3c       	cp.w	r12,r8
8000bea4:	c1 c1       	brne	8000bedc <_malloc_trim_r+0x74>
8000bea6:	ea 0b 11 00 	rsub	r11,r5,0
8000beaa:	0e 9c       	mov	r12,r7
8000beac:	fe b0 e5 fc 	rcall	80008aa4 <_sbrk_r>
8000beb0:	5b fc       	cp.w	r12,-1
8000beb2:	c1 91       	brne	8000bee4 <_malloc_trim_r+0x7c>
8000beb4:	30 0b       	mov	r11,0
8000beb6:	0e 9c       	mov	r12,r7
8000beb8:	fe b0 e5 f6 	rcall	80008aa4 <_sbrk_r>
8000bebc:	68 28       	ld.w	r8,r4[0x8]
8000bebe:	f8 08 01 09 	sub	r9,r12,r8
8000bec2:	58 f9       	cp.w	r9,15
8000bec4:	e0 8a 00 0c 	brle	8000bedc <_malloc_trim_r+0x74>
8000bec8:	a1 a9       	sbr	r9,0x0
8000beca:	91 19       	st.w	r8[0x4],r9
8000becc:	e0 68 09 60 	mov	r8,2400
8000bed0:	70 09       	ld.w	r9,r8[0x0]
8000bed2:	e0 68 0d e8 	mov	r8,3560
8000bed6:	f8 09 01 09 	sub	r9,r12,r9
8000beda:	91 09       	st.w	r8[0x0],r9
8000bedc:	0e 9c       	mov	r12,r7
8000bede:	fe b0 d7 69 	rcall	80006db0 <__malloc_unlock>
8000bee2:	d8 2a       	popm	r4-r7,pc,r12=0
8000bee4:	68 28       	ld.w	r8,r4[0x8]
8000bee6:	0a 16       	sub	r6,r5
8000bee8:	a1 a6       	sbr	r6,0x0
8000beea:	91 16       	st.w	r8[0x4],r6
8000beec:	e0 68 0d e8 	mov	r8,3560
8000bef0:	70 09       	ld.w	r9,r8[0x0]
8000bef2:	0a 19       	sub	r9,r5
8000bef4:	0e 9c       	mov	r12,r7
8000bef6:	91 09       	st.w	r8[0x0],r9
8000bef8:	fe b0 d7 5c 	rcall	80006db0 <__malloc_unlock>
8000befc:	da 2a       	popm	r4-r7,pc,r12=1
8000befe:	d7 03       	nop

8000bf00 <_free_r>:
8000bf00:	d4 21       	pushm	r4-r7,lr
8000bf02:	16 96       	mov	r6,r11
8000bf04:	18 97       	mov	r7,r12
8000bf06:	58 0b       	cp.w	r11,0
8000bf08:	e0 80 00 c0 	breq	8000c088 <_free_r+0x188>
8000bf0c:	fe b0 d7 4c 	rcall	80006da4 <__malloc_lock>
8000bf10:	20 86       	sub	r6,8
8000bf12:	e0 6a 05 54 	mov	r10,1364
8000bf16:	6c 18       	ld.w	r8,r6[0x4]
8000bf18:	74 2e       	ld.w	lr,r10[0x8]
8000bf1a:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
8000bf1e:	a1 c8       	cbr	r8,0x0
8000bf20:	ec 08 00 09 	add	r9,r6,r8
8000bf24:	72 1b       	ld.w	r11,r9[0x4]
8000bf26:	e0 1b ff fc 	andl	r11,0xfffc
8000bf2a:	1c 39       	cp.w	r9,lr
8000bf2c:	c1 e1       	brne	8000bf68 <_free_r+0x68>
8000bf2e:	f6 08 00 08 	add	r8,r11,r8
8000bf32:	58 0c       	cp.w	r12,0
8000bf34:	c0 81       	brne	8000bf44 <_free_r+0x44>
8000bf36:	6c 09       	ld.w	r9,r6[0x0]
8000bf38:	12 16       	sub	r6,r9
8000bf3a:	12 08       	add	r8,r9
8000bf3c:	6c 3b       	ld.w	r11,r6[0xc]
8000bf3e:	6c 29       	ld.w	r9,r6[0x8]
8000bf40:	97 29       	st.w	r11[0x8],r9
8000bf42:	93 3b       	st.w	r9[0xc],r11
8000bf44:	10 99       	mov	r9,r8
8000bf46:	95 26       	st.w	r10[0x8],r6
8000bf48:	a1 a9       	sbr	r9,0x0
8000bf4a:	8d 19       	st.w	r6[0x4],r9
8000bf4c:	e0 69 09 5c 	mov	r9,2396
8000bf50:	72 09       	ld.w	r9,r9[0x0]
8000bf52:	12 38       	cp.w	r8,r9
8000bf54:	c0 63       	brcs	8000bf60 <_free_r+0x60>
8000bf56:	e0 68 0d e4 	mov	r8,3556
8000bf5a:	0e 9c       	mov	r12,r7
8000bf5c:	70 0b       	ld.w	r11,r8[0x0]
8000bf5e:	c8 5f       	rcall	8000be68 <_malloc_trim_r>
8000bf60:	0e 9c       	mov	r12,r7
8000bf62:	fe b0 d7 27 	rcall	80006db0 <__malloc_unlock>
8000bf66:	d8 22       	popm	r4-r7,pc
8000bf68:	93 1b       	st.w	r9[0x4],r11
8000bf6a:	58 0c       	cp.w	r12,0
8000bf6c:	c0 30       	breq	8000bf72 <_free_r+0x72>
8000bf6e:	30 0c       	mov	r12,0
8000bf70:	c1 08       	rjmp	8000bf90 <_free_r+0x90>
8000bf72:	6c 0e       	ld.w	lr,r6[0x0]
8000bf74:	f4 c5 ff f8 	sub	r5,r10,-8
8000bf78:	1c 16       	sub	r6,lr
8000bf7a:	1c 08       	add	r8,lr
8000bf7c:	6c 2e       	ld.w	lr,r6[0x8]
8000bf7e:	0a 3e       	cp.w	lr,r5
8000bf80:	f9 bc 00 01 	moveq	r12,1
8000bf84:	ed f5 10 03 	ld.wne	r5,r6[0xc]
8000bf88:	eb fe 1a 02 	st.wne	r5[0x8],lr
8000bf8c:	fd f5 1a 03 	st.wne	lr[0xc],r5
8000bf90:	f2 0b 00 0e 	add	lr,r9,r11
8000bf94:	7c 1e       	ld.w	lr,lr[0x4]
8000bf96:	ed be 00 00 	bld	lr,0x0
8000bf9a:	c1 40       	breq	8000bfc2 <_free_r+0xc2>
8000bf9c:	16 08       	add	r8,r11
8000bf9e:	58 0c       	cp.w	r12,0
8000bfa0:	c0 d1       	brne	8000bfba <_free_r+0xba>
8000bfa2:	e0 6e 05 54 	mov	lr,1364
8000bfa6:	72 2b       	ld.w	r11,r9[0x8]
8000bfa8:	2f 8e       	sub	lr,-8
8000bfaa:	1c 3b       	cp.w	r11,lr
8000bfac:	c0 71       	brne	8000bfba <_free_r+0xba>
8000bfae:	97 36       	st.w	r11[0xc],r6
8000bfb0:	97 26       	st.w	r11[0x8],r6
8000bfb2:	8d 2b       	st.w	r6[0x8],r11
8000bfb4:	8d 3b       	st.w	r6[0xc],r11
8000bfb6:	30 1c       	mov	r12,1
8000bfb8:	c0 58       	rjmp	8000bfc2 <_free_r+0xc2>
8000bfba:	72 2b       	ld.w	r11,r9[0x8]
8000bfbc:	72 39       	ld.w	r9,r9[0xc]
8000bfbe:	93 2b       	st.w	r9[0x8],r11
8000bfc0:	97 39       	st.w	r11[0xc],r9
8000bfc2:	10 99       	mov	r9,r8
8000bfc4:	ec 08 09 08 	st.w	r6[r8],r8
8000bfc8:	a1 a9       	sbr	r9,0x0
8000bfca:	8d 19       	st.w	r6[0x4],r9
8000bfcc:	58 0c       	cp.w	r12,0
8000bfce:	c5 a1       	brne	8000c082 <_free_r+0x182>
8000bfd0:	e0 48 01 ff 	cp.w	r8,511
8000bfd4:	e0 8b 00 13 	brhi	8000bffa <_free_r+0xfa>
8000bfd8:	a3 98       	lsr	r8,0x3
8000bfda:	f4 08 00 39 	add	r9,r10,r8<<0x3
8000bfde:	72 2b       	ld.w	r11,r9[0x8]
8000bfe0:	8d 39       	st.w	r6[0xc],r9
8000bfe2:	8d 2b       	st.w	r6[0x8],r11
8000bfe4:	97 36       	st.w	r11[0xc],r6
8000bfe6:	93 26       	st.w	r9[0x8],r6
8000bfe8:	a3 48       	asr	r8,0x2
8000bfea:	74 19       	ld.w	r9,r10[0x4]
8000bfec:	30 1b       	mov	r11,1
8000bfee:	f6 08 09 48 	lsl	r8,r11,r8
8000bff2:	f3 e8 10 08 	or	r8,r9,r8
8000bff6:	95 18       	st.w	r10[0x4],r8
8000bff8:	c4 58       	rjmp	8000c082 <_free_r+0x182>
8000bffa:	f0 0b 16 09 	lsr	r11,r8,0x9
8000bffe:	58 4b       	cp.w	r11,4
8000c000:	e0 8b 00 06 	brhi	8000c00c <_free_r+0x10c>
8000c004:	f0 0b 16 06 	lsr	r11,r8,0x6
8000c008:	2c 8b       	sub	r11,-56
8000c00a:	c2 08       	rjmp	8000c04a <_free_r+0x14a>
8000c00c:	59 4b       	cp.w	r11,20
8000c00e:	e0 8b 00 04 	brhi	8000c016 <_free_r+0x116>
8000c012:	2a 5b       	sub	r11,-91
8000c014:	c1 b8       	rjmp	8000c04a <_free_r+0x14a>
8000c016:	e0 4b 00 54 	cp.w	r11,84
8000c01a:	e0 8b 00 06 	brhi	8000c026 <_free_r+0x126>
8000c01e:	f0 0b 16 0c 	lsr	r11,r8,0xc
8000c022:	29 2b       	sub	r11,-110
8000c024:	c1 38       	rjmp	8000c04a <_free_r+0x14a>
8000c026:	e0 4b 01 54 	cp.w	r11,340
8000c02a:	e0 8b 00 06 	brhi	8000c036 <_free_r+0x136>
8000c02e:	f0 0b 16 0f 	lsr	r11,r8,0xf
8000c032:	28 9b       	sub	r11,-119
8000c034:	c0 b8       	rjmp	8000c04a <_free_r+0x14a>
8000c036:	e0 4b 05 54 	cp.w	r11,1364
8000c03a:	e0 88 00 05 	brls	8000c044 <_free_r+0x144>
8000c03e:	37 eb       	mov	r11,126
8000c040:	c0 58       	rjmp	8000c04a <_free_r+0x14a>
8000c042:	d7 03       	nop
8000c044:	f0 0b 16 12 	lsr	r11,r8,0x12
8000c048:	28 4b       	sub	r11,-124
8000c04a:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
8000c04e:	78 29       	ld.w	r9,r12[0x8]
8000c050:	18 39       	cp.w	r9,r12
8000c052:	c0 e1       	brne	8000c06e <_free_r+0x16e>
8000c054:	74 18       	ld.w	r8,r10[0x4]
8000c056:	a3 4b       	asr	r11,0x2
8000c058:	30 1c       	mov	r12,1
8000c05a:	f8 0b 09 4b 	lsl	r11,r12,r11
8000c05e:	f1 eb 10 0b 	or	r11,r8,r11
8000c062:	12 98       	mov	r8,r9
8000c064:	95 1b       	st.w	r10[0x4],r11
8000c066:	c0 a8       	rjmp	8000c07a <_free_r+0x17a>
8000c068:	72 29       	ld.w	r9,r9[0x8]
8000c06a:	18 39       	cp.w	r9,r12
8000c06c:	c0 60       	breq	8000c078 <_free_r+0x178>
8000c06e:	72 1a       	ld.w	r10,r9[0x4]
8000c070:	e0 1a ff fc 	andl	r10,0xfffc
8000c074:	14 38       	cp.w	r8,r10
8000c076:	cf 93       	brcs	8000c068 <_free_r+0x168>
8000c078:	72 38       	ld.w	r8,r9[0xc]
8000c07a:	8d 38       	st.w	r6[0xc],r8
8000c07c:	8d 29       	st.w	r6[0x8],r9
8000c07e:	93 36       	st.w	r9[0xc],r6
8000c080:	91 26       	st.w	r8[0x8],r6
8000c082:	0e 9c       	mov	r12,r7
8000c084:	fe b0 d6 96 	rcall	80006db0 <__malloc_unlock>
8000c088:	d8 22       	popm	r4-r7,pc
8000c08a:	d7 03       	nop

8000c08c <__sfvwrite_r>:
8000c08c:	d4 31       	pushm	r0-r7,lr
8000c08e:	20 3d       	sub	sp,12
8000c090:	14 94       	mov	r4,r10
8000c092:	18 95       	mov	r5,r12
8000c094:	16 97       	mov	r7,r11
8000c096:	74 28       	ld.w	r8,r10[0x8]
8000c098:	58 08       	cp.w	r8,0
8000c09a:	e0 80 01 40 	breq	8000c31a <__sfvwrite_r+0x28e>
8000c09e:	96 68       	ld.sh	r8,r11[0xc]
8000c0a0:	ed b8 00 03 	bld	r8,0x3
8000c0a4:	c0 41       	brne	8000c0ac <__sfvwrite_r+0x20>
8000c0a6:	76 48       	ld.w	r8,r11[0x10]
8000c0a8:	58 08       	cp.w	r8,0
8000c0aa:	c0 c1       	brne	8000c0c2 <__sfvwrite_r+0x36>
8000c0ac:	0e 9b       	mov	r11,r7
8000c0ae:	0a 9c       	mov	r12,r5
8000c0b0:	fe b0 f6 c4 	rcall	8000ae38 <__swsetup_r>
8000c0b4:	c0 70       	breq	8000c0c2 <__sfvwrite_r+0x36>
8000c0b6:	8e 68       	ld.sh	r8,r7[0xc]
8000c0b8:	a7 a8       	sbr	r8,0x6
8000c0ba:	ae 68       	st.h	r7[0xc],r8
8000c0bc:	30 98       	mov	r8,9
8000c0be:	8b 38       	st.w	r5[0xc],r8
8000c0c0:	c2 b9       	rjmp	8000c316 <__sfvwrite_r+0x28a>
8000c0c2:	8e 63       	ld.sh	r3,r7[0xc]
8000c0c4:	68 00       	ld.w	r0,r4[0x0]
8000c0c6:	06 96       	mov	r6,r3
8000c0c8:	e2 16 00 02 	andl	r6,0x2,COH
8000c0cc:	c2 10       	breq	8000c10e <__sfvwrite_r+0x82>
8000c0ce:	30 03       	mov	r3,0
8000c0d0:	e0 62 04 00 	mov	r2,1024
8000c0d4:	06 96       	mov	r6,r3
8000c0d6:	c0 48       	rjmp	8000c0de <__sfvwrite_r+0x52>
8000c0d8:	60 03       	ld.w	r3,r0[0x0]
8000c0da:	60 16       	ld.w	r6,r0[0x4]
8000c0dc:	2f 80       	sub	r0,-8
8000c0de:	58 06       	cp.w	r6,0
8000c0e0:	cf c0       	breq	8000c0d8 <__sfvwrite_r+0x4c>
8000c0e2:	e0 46 04 00 	cp.w	r6,1024
8000c0e6:	ec 09 17 80 	movls	r9,r6
8000c0ea:	e4 09 17 b0 	movhi	r9,r2
8000c0ee:	06 9a       	mov	r10,r3
8000c0f0:	6e a8       	ld.w	r8,r7[0x28]
8000c0f2:	6e 8b       	ld.w	r11,r7[0x20]
8000c0f4:	0a 9c       	mov	r12,r5
8000c0f6:	5d 18       	icall	r8
8000c0f8:	18 16       	sub	r6,r12
8000c0fa:	58 0c       	cp.w	r12,0
8000c0fc:	e0 8a 01 0a 	brle	8000c310 <__sfvwrite_r+0x284>
8000c100:	68 28       	ld.w	r8,r4[0x8]
8000c102:	18 18       	sub	r8,r12
8000c104:	89 28       	st.w	r4[0x8],r8
8000c106:	e0 80 01 0a 	breq	8000c31a <__sfvwrite_r+0x28e>
8000c10a:	18 03       	add	r3,r12
8000c10c:	ce 9b       	rjmp	8000c0de <__sfvwrite_r+0x52>
8000c10e:	e7 d3 c0 01 	bfextu	r3,r3,0x0,0x1
8000c112:	c0 70       	breq	8000c120 <__sfvwrite_r+0x94>
8000c114:	50 06       	stdsp	sp[0x0],r6
8000c116:	0c 93       	mov	r3,r6
8000c118:	0c 91       	mov	r1,r6
8000c11a:	50 15       	stdsp	sp[0x4],r5
8000c11c:	08 92       	mov	r2,r4
8000c11e:	c9 c8       	rjmp	8000c256 <__sfvwrite_r+0x1ca>
8000c120:	06 96       	mov	r6,r3
8000c122:	08 91       	mov	r1,r4
8000c124:	c0 48       	rjmp	8000c12c <__sfvwrite_r+0xa0>
8000c126:	60 03       	ld.w	r3,r0[0x0]
8000c128:	60 16       	ld.w	r6,r0[0x4]
8000c12a:	2f 80       	sub	r0,-8
8000c12c:	58 06       	cp.w	r6,0
8000c12e:	cf c0       	breq	8000c126 <__sfvwrite_r+0x9a>
8000c130:	8e 68       	ld.sh	r8,r7[0xc]
8000c132:	6e 24       	ld.w	r4,r7[0x8]
8000c134:	10 99       	mov	r9,r8
8000c136:	e2 19 02 00 	andl	r9,0x200,COH
8000c13a:	c5 50       	breq	8000c1e4 <__sfvwrite_r+0x158>
8000c13c:	08 36       	cp.w	r6,r4
8000c13e:	c4 43       	brcs	8000c1c6 <__sfvwrite_r+0x13a>
8000c140:	10 99       	mov	r9,r8
8000c142:	e2 19 04 80 	andl	r9,0x480,COH
8000c146:	c4 00       	breq	8000c1c6 <__sfvwrite_r+0x13a>
8000c148:	6e 4b       	ld.w	r11,r7[0x10]
8000c14a:	6e 09       	ld.w	r9,r7[0x0]
8000c14c:	16 19       	sub	r9,r11
8000c14e:	50 09       	stdsp	sp[0x0],r9
8000c150:	6e 59       	ld.w	r9,r7[0x14]
8000c152:	10 9c       	mov	r12,r8
8000c154:	f2 09 00 1a 	add	r10,r9,r9<<0x1
8000c158:	30 28       	mov	r8,2
8000c15a:	f4 08 0c 08 	divs	r8,r10,r8
8000c15e:	fa e9 00 04 	st.d	sp[4],r8
8000c162:	10 94       	mov	r4,r8
8000c164:	40 09       	lddsp	r9,sp[0x0]
8000c166:	e2 1c 04 00 	andl	r12,0x400,COH
8000c16a:	2f f9       	sub	r9,-1
8000c16c:	0c 09       	add	r9,r6
8000c16e:	12 38       	cp.w	r8,r9
8000c170:	f2 04 17 30 	movlo	r4,r9
8000c174:	58 0c       	cp.w	r12,0
8000c176:	c1 10       	breq	8000c198 <__sfvwrite_r+0x10c>
8000c178:	08 9b       	mov	r11,r4
8000c17a:	0a 9c       	mov	r12,r5
8000c17c:	fe b0 e0 5a 	rcall	80008230 <_malloc_r>
8000c180:	18 92       	mov	r2,r12
8000c182:	c1 40       	breq	8000c1aa <__sfvwrite_r+0x11e>
8000c184:	40 0a       	lddsp	r10,sp[0x0]
8000c186:	6e 4b       	ld.w	r11,r7[0x10]
8000c188:	fe b0 e2 83 	rcall	8000868e <memcpy>
8000c18c:	8e 68       	ld.sh	r8,r7[0xc]
8000c18e:	e0 18 fb 7f 	andl	r8,0xfb7f
8000c192:	a7 b8       	sbr	r8,0x7
8000c194:	ae 68       	st.h	r7[0xc],r8
8000c196:	c0 d8       	rjmp	8000c1b0 <__sfvwrite_r+0x124>
8000c198:	08 9a       	mov	r10,r4
8000c19a:	0a 9c       	mov	r12,r5
8000c19c:	fe b0 e3 24 	rcall	800087e4 <_realloc_r>
8000c1a0:	18 92       	mov	r2,r12
8000c1a2:	c0 71       	brne	8000c1b0 <__sfvwrite_r+0x124>
8000c1a4:	6e 4b       	ld.w	r11,r7[0x10]
8000c1a6:	0a 9c       	mov	r12,r5
8000c1a8:	ca ce       	rcall	8000bf00 <_free_r>
8000c1aa:	30 c8       	mov	r8,12
8000c1ac:	8b 38       	st.w	r5[0xc],r8
8000c1ae:	cb 18       	rjmp	8000c310 <__sfvwrite_r+0x284>
8000c1b0:	40 0a       	lddsp	r10,sp[0x0]
8000c1b2:	40 09       	lddsp	r9,sp[0x0]
8000c1b4:	e8 0a 01 0a 	sub	r10,r4,r10
8000c1b8:	e4 09 00 08 	add	r8,r2,r9
8000c1bc:	8f 54       	st.w	r7[0x14],r4
8000c1be:	8f 2a       	st.w	r7[0x8],r10
8000c1c0:	8f 08       	st.w	r7[0x0],r8
8000c1c2:	8f 42       	st.w	r7[0x10],r2
8000c1c4:	0c 94       	mov	r4,r6
8000c1c6:	08 36       	cp.w	r6,r4
8000c1c8:	ec 04 17 30 	movlo	r4,r6
8000c1cc:	06 9b       	mov	r11,r3
8000c1ce:	08 9a       	mov	r10,r4
8000c1d0:	6e 0c       	ld.w	r12,r7[0x0]
8000c1d2:	c3 ad       	rcall	8000c446 <memmove>
8000c1d4:	6e 08       	ld.w	r8,r7[0x0]
8000c1d6:	08 08       	add	r8,r4
8000c1d8:	8f 08       	st.w	r7[0x0],r8
8000c1da:	6e 28       	ld.w	r8,r7[0x8]
8000c1dc:	08 18       	sub	r8,r4
8000c1de:	0c 94       	mov	r4,r6
8000c1e0:	8f 28       	st.w	r7[0x8],r8
8000c1e2:	c2 e8       	rjmp	8000c23e <__sfvwrite_r+0x1b2>
8000c1e4:	08 36       	cp.w	r6,r4
8000c1e6:	5f ba       	srhi	r10
8000c1e8:	6e 0c       	ld.w	r12,r7[0x0]
8000c1ea:	6e 48       	ld.w	r8,r7[0x10]
8000c1ec:	10 3c       	cp.w	r12,r8
8000c1ee:	5f b8       	srhi	r8
8000c1f0:	f5 e8 00 08 	and	r8,r10,r8
8000c1f4:	f2 08 18 00 	cp.b	r8,r9
8000c1f8:	c0 d0       	breq	8000c212 <__sfvwrite_r+0x186>
8000c1fa:	06 9b       	mov	r11,r3
8000c1fc:	08 9a       	mov	r10,r4
8000c1fe:	c2 4d       	rcall	8000c446 <memmove>
8000c200:	6e 08       	ld.w	r8,r7[0x0]
8000c202:	08 08       	add	r8,r4
8000c204:	0e 9b       	mov	r11,r7
8000c206:	8f 08       	st.w	r7[0x0],r8
8000c208:	0a 9c       	mov	r12,r5
8000c20a:	fe b0 fd 09 	rcall	8000bc1c <_fflush_r>
8000c20e:	c1 80       	breq	8000c23e <__sfvwrite_r+0x1b2>
8000c210:	c8 08       	rjmp	8000c310 <__sfvwrite_r+0x284>
8000c212:	6e 59       	ld.w	r9,r7[0x14]
8000c214:	12 36       	cp.w	r6,r9
8000c216:	c0 a3       	brcs	8000c22a <__sfvwrite_r+0x19e>
8000c218:	6e a8       	ld.w	r8,r7[0x28]
8000c21a:	06 9a       	mov	r10,r3
8000c21c:	6e 8b       	ld.w	r11,r7[0x20]
8000c21e:	0a 9c       	mov	r12,r5
8000c220:	5d 18       	icall	r8
8000c222:	18 94       	mov	r4,r12
8000c224:	e0 89 00 0d 	brgt	8000c23e <__sfvwrite_r+0x1b2>
8000c228:	c7 48       	rjmp	8000c310 <__sfvwrite_r+0x284>
8000c22a:	0c 9a       	mov	r10,r6
8000c22c:	06 9b       	mov	r11,r3
8000c22e:	c0 cd       	rcall	8000c446 <memmove>
8000c230:	6e 08       	ld.w	r8,r7[0x0]
8000c232:	0c 08       	add	r8,r6
8000c234:	0c 94       	mov	r4,r6
8000c236:	8f 08       	st.w	r7[0x0],r8
8000c238:	6e 28       	ld.w	r8,r7[0x8]
8000c23a:	0c 18       	sub	r8,r6
8000c23c:	8f 28       	st.w	r7[0x8],r8
8000c23e:	62 28       	ld.w	r8,r1[0x8]
8000c240:	08 18       	sub	r8,r4
8000c242:	83 28       	st.w	r1[0x8],r8
8000c244:	c6 b0       	breq	8000c31a <__sfvwrite_r+0x28e>
8000c246:	08 16       	sub	r6,r4
8000c248:	08 03       	add	r3,r4
8000c24a:	c7 1b       	rjmp	8000c12c <__sfvwrite_r+0xa0>
8000c24c:	60 03       	ld.w	r3,r0[0x0]
8000c24e:	60 11       	ld.w	r1,r0[0x4]
8000c250:	30 08       	mov	r8,0
8000c252:	2f 80       	sub	r0,-8
8000c254:	50 08       	stdsp	sp[0x0],r8
8000c256:	58 01       	cp.w	r1,0
8000c258:	cf a0       	breq	8000c24c <__sfvwrite_r+0x1c0>
8000c25a:	40 0a       	lddsp	r10,sp[0x0]
8000c25c:	58 0a       	cp.w	r10,0
8000c25e:	c1 41       	brne	8000c286 <__sfvwrite_r+0x1fa>
8000c260:	e2 c6 ff ff 	sub	r6,r1,-1
8000c264:	02 9a       	mov	r10,r1
8000c266:	30 ab       	mov	r11,10
8000c268:	06 9c       	mov	r12,r3
8000c26a:	ce 3c       	rcall	8000c430 <memchr>
8000c26c:	f8 c8 ff ff 	sub	r8,r12,-1
8000c270:	58 0c       	cp.w	r12,0
8000c272:	f1 d3 e1 16 	subne	r6,r8,r3
8000c276:	f9 b9 01 01 	movne	r9,1
8000c27a:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000c27e:	f9 b8 00 01 	moveq	r8,1
8000c282:	fb f8 0a 00 	st.weq	sp[0x0],r8
8000c286:	02 36       	cp.w	r6,r1
8000c288:	ec 04 17 80 	movls	r4,r6
8000c28c:	e2 04 17 b0 	movhi	r4,r1
8000c290:	6e 59       	ld.w	r9,r7[0x14]
8000c292:	6e 25       	ld.w	r5,r7[0x8]
8000c294:	f2 05 00 05 	add	r5,r9,r5
8000c298:	0a 34       	cp.w	r4,r5
8000c29a:	5f 9a       	srgt	r10
8000c29c:	6e 0c       	ld.w	r12,r7[0x0]
8000c29e:	6e 48       	ld.w	r8,r7[0x10]
8000c2a0:	10 3c       	cp.w	r12,r8
8000c2a2:	5f b8       	srhi	r8
8000c2a4:	f5 e8 00 08 	and	r8,r10,r8
8000c2a8:	30 0a       	mov	r10,0
8000c2aa:	f4 08 18 00 	cp.b	r8,r10
8000c2ae:	c0 d0       	breq	8000c2c8 <__sfvwrite_r+0x23c>
8000c2b0:	06 9b       	mov	r11,r3
8000c2b2:	0a 9a       	mov	r10,r5
8000c2b4:	cc 9c       	rcall	8000c446 <memmove>
8000c2b6:	6e 08       	ld.w	r8,r7[0x0]
8000c2b8:	0a 08       	add	r8,r5
8000c2ba:	0e 9b       	mov	r11,r7
8000c2bc:	8f 08       	st.w	r7[0x0],r8
8000c2be:	40 1c       	lddsp	r12,sp[0x4]
8000c2c0:	fe b0 fc ae 	rcall	8000bc1c <_fflush_r>
8000c2c4:	c1 70       	breq	8000c2f2 <__sfvwrite_r+0x266>
8000c2c6:	c2 58       	rjmp	8000c310 <__sfvwrite_r+0x284>
8000c2c8:	12 34       	cp.w	r4,r9
8000c2ca:	c0 a5       	brlt	8000c2de <__sfvwrite_r+0x252>
8000c2cc:	6e a8       	ld.w	r8,r7[0x28]
8000c2ce:	06 9a       	mov	r10,r3
8000c2d0:	6e 8b       	ld.w	r11,r7[0x20]
8000c2d2:	40 1c       	lddsp	r12,sp[0x4]
8000c2d4:	5d 18       	icall	r8
8000c2d6:	18 95       	mov	r5,r12
8000c2d8:	e0 89 00 0d 	brgt	8000c2f2 <__sfvwrite_r+0x266>
8000c2dc:	c1 a8       	rjmp	8000c310 <__sfvwrite_r+0x284>
8000c2de:	08 9a       	mov	r10,r4
8000c2e0:	06 9b       	mov	r11,r3
8000c2e2:	cb 2c       	rcall	8000c446 <memmove>
8000c2e4:	6e 08       	ld.w	r8,r7[0x0]
8000c2e6:	08 08       	add	r8,r4
8000c2e8:	08 95       	mov	r5,r4
8000c2ea:	8f 08       	st.w	r7[0x0],r8
8000c2ec:	6e 28       	ld.w	r8,r7[0x8]
8000c2ee:	08 18       	sub	r8,r4
8000c2f0:	8f 28       	st.w	r7[0x8],r8
8000c2f2:	0a 16       	sub	r6,r5
8000c2f4:	c0 71       	brne	8000c302 <__sfvwrite_r+0x276>
8000c2f6:	0e 9b       	mov	r11,r7
8000c2f8:	40 1c       	lddsp	r12,sp[0x4]
8000c2fa:	fe b0 fc 91 	rcall	8000bc1c <_fflush_r>
8000c2fe:	c0 91       	brne	8000c310 <__sfvwrite_r+0x284>
8000c300:	50 06       	stdsp	sp[0x0],r6
8000c302:	64 28       	ld.w	r8,r2[0x8]
8000c304:	0a 18       	sub	r8,r5
8000c306:	85 28       	st.w	r2[0x8],r8
8000c308:	c0 90       	breq	8000c31a <__sfvwrite_r+0x28e>
8000c30a:	0a 11       	sub	r1,r5
8000c30c:	0a 03       	add	r3,r5
8000c30e:	ca 4b       	rjmp	8000c256 <__sfvwrite_r+0x1ca>
8000c310:	8e 68       	ld.sh	r8,r7[0xc]
8000c312:	a7 a8       	sbr	r8,0x6
8000c314:	ae 68       	st.h	r7[0xc],r8
8000c316:	3f fc       	mov	r12,-1
8000c318:	c0 28       	rjmp	8000c31c <__sfvwrite_r+0x290>
8000c31a:	30 0c       	mov	r12,0
8000c31c:	2f dd       	sub	sp,-12
8000c31e:	d8 32       	popm	r0-r7,pc

8000c320 <_fwalk>:
8000c320:	d4 31       	pushm	r0-r7,lr
8000c322:	30 05       	mov	r5,0
8000c324:	16 91       	mov	r1,r11
8000c326:	f8 c7 ff 28 	sub	r7,r12,-216
8000c32a:	0a 92       	mov	r2,r5
8000c32c:	fe b0 fc fe 	rcall	8000bd28 <__sfp_lock_acquire>
8000c330:	3f f3       	mov	r3,-1
8000c332:	c1 68       	rjmp	8000c35e <_fwalk+0x3e>
8000c334:	6e 26       	ld.w	r6,r7[0x8]
8000c336:	6e 14       	ld.w	r4,r7[0x4]
8000c338:	2f 46       	sub	r6,-12
8000c33a:	c0 c8       	rjmp	8000c352 <_fwalk+0x32>
8000c33c:	8c 08       	ld.sh	r8,r6[0x0]
8000c33e:	e4 08 19 00 	cp.h	r8,r2
8000c342:	c0 70       	breq	8000c350 <_fwalk+0x30>
8000c344:	8c 18       	ld.sh	r8,r6[0x2]
8000c346:	e6 08 19 00 	cp.h	r8,r3
8000c34a:	c0 30       	breq	8000c350 <_fwalk+0x30>
8000c34c:	5d 11       	icall	r1
8000c34e:	18 45       	or	r5,r12
8000c350:	2a 46       	sub	r6,-92
8000c352:	20 14       	sub	r4,1
8000c354:	ec cc 00 0c 	sub	r12,r6,12
8000c358:	58 04       	cp.w	r4,0
8000c35a:	cf 14       	brge	8000c33c <_fwalk+0x1c>
8000c35c:	6e 07       	ld.w	r7,r7[0x0]
8000c35e:	58 07       	cp.w	r7,0
8000c360:	ce a1       	brne	8000c334 <_fwalk+0x14>
8000c362:	fe b0 fc e4 	rcall	8000bd2a <__sfp_lock_release>
8000c366:	0a 9c       	mov	r12,r5
8000c368:	d8 32       	popm	r0-r7,pc
8000c36a:	d7 03       	nop

8000c36c <_localeconv_r>:
8000c36c:	fe cc d0 58 	sub	r12,pc,-12200
8000c370:	5e fc       	retal	r12
8000c372:	d7 03       	nop

8000c374 <__smakebuf_r>:
8000c374:	d4 21       	pushm	r4-r7,lr
8000c376:	20 fd       	sub	sp,60
8000c378:	96 68       	ld.sh	r8,r11[0xc]
8000c37a:	16 97       	mov	r7,r11
8000c37c:	18 96       	mov	r6,r12
8000c37e:	e2 18 00 02 	andl	r8,0x2,COH
8000c382:	c3 d1       	brne	8000c3fc <__smakebuf_r+0x88>
8000c384:	96 7b       	ld.sh	r11,r11[0xe]
8000c386:	f0 0b 19 00 	cp.h	r11,r8
8000c38a:	c0 55       	brlt	8000c394 <__smakebuf_r+0x20>
8000c38c:	1a 9a       	mov	r10,sp
8000c38e:	e0 a0 04 81 	rcall	8000cc90 <_fstat_r>
8000c392:	c0 f4       	brge	8000c3b0 <__smakebuf_r+0x3c>
8000c394:	8e 65       	ld.sh	r5,r7[0xc]
8000c396:	0a 98       	mov	r8,r5
8000c398:	ab b8       	sbr	r8,0xb
8000c39a:	e2 15 00 80 	andl	r5,0x80,COH
8000c39e:	ae 68       	st.h	r7[0xc],r8
8000c3a0:	30 04       	mov	r4,0
8000c3a2:	e0 68 04 00 	mov	r8,1024
8000c3a6:	f9 b5 01 40 	movne	r5,64
8000c3aa:	f0 05 17 00 	moveq	r5,r8
8000c3ae:	c1 c8       	rjmp	8000c3e6 <__smakebuf_r+0x72>
8000c3b0:	40 18       	lddsp	r8,sp[0x4]
8000c3b2:	e2 18 f0 00 	andl	r8,0xf000,COH
8000c3b6:	e0 48 20 00 	cp.w	r8,8192
8000c3ba:	5f 04       	sreq	r4
8000c3bc:	e0 48 80 00 	cp.w	r8,32768
8000c3c0:	c0 e1       	brne	8000c3dc <__smakebuf_r+0x68>
8000c3c2:	6e b9       	ld.w	r9,r7[0x2c]
8000c3c4:	fe c8 f9 1c 	sub	r8,pc,-1764
8000c3c8:	10 39       	cp.w	r9,r8
8000c3ca:	c0 91       	brne	8000c3dc <__smakebuf_r+0x68>
8000c3cc:	8e 68       	ld.sh	r8,r7[0xc]
8000c3ce:	e0 65 04 00 	mov	r5,1024
8000c3d2:	ab a8       	sbr	r8,0xa
8000c3d4:	ef 45 00 50 	st.w	r7[80],r5
8000c3d8:	ae 68       	st.h	r7[0xc],r8
8000c3da:	c0 68       	rjmp	8000c3e6 <__smakebuf_r+0x72>
8000c3dc:	8e 68       	ld.sh	r8,r7[0xc]
8000c3de:	e0 65 04 00 	mov	r5,1024
8000c3e2:	ab b8       	sbr	r8,0xb
8000c3e4:	ae 68       	st.h	r7[0xc],r8
8000c3e6:	0a 9b       	mov	r11,r5
8000c3e8:	0c 9c       	mov	r12,r6
8000c3ea:	fe b0 df 23 	rcall	80008230 <_malloc_r>
8000c3ee:	8e 68       	ld.sh	r8,r7[0xc]
8000c3f0:	c0 d1       	brne	8000c40a <__smakebuf_r+0x96>
8000c3f2:	ed b8 00 09 	bld	r8,0x9
8000c3f6:	c1 b0       	breq	8000c42c <__smakebuf_r+0xb8>
8000c3f8:	a1 b8       	sbr	r8,0x1
8000c3fa:	ae 68       	st.h	r7[0xc],r8
8000c3fc:	ee c8 ff b9 	sub	r8,r7,-71
8000c400:	8f 48       	st.w	r7[0x10],r8
8000c402:	8f 08       	st.w	r7[0x0],r8
8000c404:	30 18       	mov	r8,1
8000c406:	8f 58       	st.w	r7[0x14],r8
8000c408:	c1 28       	rjmp	8000c42c <__smakebuf_r+0xb8>
8000c40a:	a7 b8       	sbr	r8,0x7
8000c40c:	8f 4c       	st.w	r7[0x10],r12
8000c40e:	ae 68       	st.h	r7[0xc],r8
8000c410:	8f 55       	st.w	r7[0x14],r5
8000c412:	fe c8 06 e6 	sub	r8,pc,1766
8000c416:	8f 0c       	st.w	r7[0x0],r12
8000c418:	8d a8       	st.w	r6[0x28],r8
8000c41a:	58 04       	cp.w	r4,0
8000c41c:	c0 80       	breq	8000c42c <__smakebuf_r+0xb8>
8000c41e:	8e 7c       	ld.sh	r12,r7[0xe]
8000c420:	fe b0 e3 94 	rcall	80008b48 <isatty>
8000c424:	c0 40       	breq	8000c42c <__smakebuf_r+0xb8>
8000c426:	8e 68       	ld.sh	r8,r7[0xc]
8000c428:	a1 a8       	sbr	r8,0x0
8000c42a:	ae 68       	st.h	r7[0xc],r8
8000c42c:	2f 1d       	sub	sp,-60
8000c42e:	d8 22       	popm	r4-r7,pc

8000c430 <memchr>:
8000c430:	f7 db c0 08 	bfextu	r11,r11,0x0,0x8
8000c434:	c0 68       	rjmp	8000c440 <memchr+0x10>
8000c436:	20 1a       	sub	r10,1
8000c438:	19 88       	ld.ub	r8,r12[0x0]
8000c43a:	16 38       	cp.w	r8,r11
8000c43c:	5e 0c       	reteq	r12
8000c43e:	2f fc       	sub	r12,-1
8000c440:	58 0a       	cp.w	r10,0
8000c442:	cf a1       	brne	8000c436 <memchr+0x6>
8000c444:	5e fa       	retal	r10

8000c446 <memmove>:
8000c446:	d4 01       	pushm	lr
8000c448:	18 3b       	cp.w	r11,r12
8000c44a:	c1 92       	brcc	8000c47c <memmove+0x36>
8000c44c:	f6 0a 00 09 	add	r9,r11,r10
8000c450:	12 3c       	cp.w	r12,r9
8000c452:	c1 52       	brcc	8000c47c <memmove+0x36>
8000c454:	f8 0a 00 0b 	add	r11,r12,r10
8000c458:	30 08       	mov	r8,0
8000c45a:	c0 68       	rjmp	8000c466 <memmove+0x20>
8000c45c:	f2 08 07 0e 	ld.ub	lr,r9[r8]
8000c460:	20 1a       	sub	r10,1
8000c462:	f6 08 0b 0e 	st.b	r11[r8],lr
8000c466:	20 18       	sub	r8,1
8000c468:	58 0a       	cp.w	r10,0
8000c46a:	cf 91       	brne	8000c45c <memmove+0x16>
8000c46c:	d8 02       	popm	pc
8000c46e:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000c472:	20 1a       	sub	r10,1
8000c474:	f8 08 0b 09 	st.b	r12[r8],r9
8000c478:	2f f8       	sub	r8,-1
8000c47a:	c0 28       	rjmp	8000c47e <memmove+0x38>
8000c47c:	30 08       	mov	r8,0
8000c47e:	58 0a       	cp.w	r10,0
8000c480:	cf 71       	brne	8000c46e <memmove+0x28>
8000c482:	d8 02       	popm	pc

8000c484 <__hi0bits>:
8000c484:	18 98       	mov	r8,r12
8000c486:	e0 1c 00 00 	andl	r12,0x0
8000c48a:	f0 09 15 10 	lsl	r9,r8,0x10
8000c48e:	58 0c       	cp.w	r12,0
8000c490:	f2 08 17 00 	moveq	r8,r9
8000c494:	f9 bc 00 10 	moveq	r12,16
8000c498:	f9 bc 01 00 	movne	r12,0
8000c49c:	10 9a       	mov	r10,r8
8000c49e:	f0 09 15 08 	lsl	r9,r8,0x8
8000c4a2:	e6 1a ff 00 	andh	r10,0xff00,COH
8000c4a6:	f7 bc 00 f8 	subeq	r12,-8
8000c4aa:	f2 08 17 00 	moveq	r8,r9
8000c4ae:	10 9a       	mov	r10,r8
8000c4b0:	f0 09 15 04 	lsl	r9,r8,0x4
8000c4b4:	e6 1a f0 00 	andh	r10,0xf000,COH
8000c4b8:	f7 bc 00 fc 	subeq	r12,-4
8000c4bc:	f2 08 17 00 	moveq	r8,r9
8000c4c0:	10 9a       	mov	r10,r8
8000c4c2:	f0 09 15 02 	lsl	r9,r8,0x2
8000c4c6:	e6 1a c0 00 	andh	r10,0xc000,COH
8000c4ca:	f7 bc 00 fe 	subeq	r12,-2
8000c4ce:	f2 08 17 00 	moveq	r8,r9
8000c4d2:	58 08       	cp.w	r8,0
8000c4d4:	5e 5c       	retlt	r12
8000c4d6:	ed b8 00 1e 	bld	r8,0x1e
8000c4da:	f9 bc 01 20 	movne	r12,32
8000c4de:	f7 bc 00 ff 	subeq	r12,-1
8000c4e2:	5e fc       	retal	r12

8000c4e4 <__lo0bits>:
8000c4e4:	18 99       	mov	r9,r12
8000c4e6:	78 08       	ld.w	r8,r12[0x0]
8000c4e8:	f9 d8 c0 03 	bfextu	r12,r8,0x0,0x3
8000c4ec:	c1 50       	breq	8000c516 <__lo0bits+0x32>
8000c4ee:	ed b8 00 00 	bld	r8,0x0
8000c4f2:	c0 21       	brne	8000c4f6 <__lo0bits+0x12>
8000c4f4:	5e fd       	retal	0
8000c4f6:	10 9b       	mov	r11,r8
8000c4f8:	f0 0a 16 01 	lsr	r10,r8,0x1
8000c4fc:	e2 1b 00 02 	andl	r11,0x2,COH
8000c500:	a3 88       	lsr	r8,0x2
8000c502:	58 0b       	cp.w	r11,0
8000c504:	f3 fa 1a 00 	st.wne	r9[0x0],r10
8000c508:	f9 bc 01 01 	movne	r12,1
8000c50c:	f3 f8 0a 00 	st.weq	r9[0x0],r8
8000c510:	f9 bc 00 02 	moveq	r12,2
8000c514:	5e fc       	retal	r12
8000c516:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
8000c51a:	f0 0b 16 10 	lsr	r11,r8,0x10
8000c51e:	58 0a       	cp.w	r10,0
8000c520:	f6 08 17 00 	moveq	r8,r11
8000c524:	f9 bc 00 10 	moveq	r12,16
8000c528:	f7 d8 c0 08 	bfextu	r11,r8,0x0,0x8
8000c52c:	f0 0a 16 08 	lsr	r10,r8,0x8
8000c530:	58 0b       	cp.w	r11,0
8000c532:	f7 bc 00 f8 	subeq	r12,-8
8000c536:	f4 08 17 00 	moveq	r8,r10
8000c53a:	f7 d8 c0 04 	bfextu	r11,r8,0x0,0x4
8000c53e:	f0 0a 16 04 	lsr	r10,r8,0x4
8000c542:	58 0b       	cp.w	r11,0
8000c544:	f7 bc 00 fc 	subeq	r12,-4
8000c548:	f4 08 17 00 	moveq	r8,r10
8000c54c:	f7 d8 c0 02 	bfextu	r11,r8,0x0,0x2
8000c550:	f0 0a 16 02 	lsr	r10,r8,0x2
8000c554:	58 0b       	cp.w	r11,0
8000c556:	f7 bc 00 fe 	subeq	r12,-2
8000c55a:	f4 08 17 00 	moveq	r8,r10
8000c55e:	ed b8 00 00 	bld	r8,0x0
8000c562:	c0 60       	breq	8000c56e <__lo0bits+0x8a>
8000c564:	a1 98       	lsr	r8,0x1
8000c566:	c0 31       	brne	8000c56c <__lo0bits+0x88>
8000c568:	32 0c       	mov	r12,32
8000c56a:	5e fc       	retal	r12
8000c56c:	2f fc       	sub	r12,-1
8000c56e:	93 08       	st.w	r9[0x0],r8
8000c570:	5e fc       	retal	r12

8000c572 <__mcmp>:
8000c572:	d4 01       	pushm	lr
8000c574:	18 98       	mov	r8,r12
8000c576:	76 49       	ld.w	r9,r11[0x10]
8000c578:	78 4c       	ld.w	r12,r12[0x10]
8000c57a:	12 1c       	sub	r12,r9
8000c57c:	c1 31       	brne	8000c5a2 <__mcmp+0x30>
8000c57e:	2f b9       	sub	r9,-5
8000c580:	a3 69       	lsl	r9,0x2
8000c582:	12 0b       	add	r11,r9
8000c584:	f0 09 00 09 	add	r9,r8,r9
8000c588:	2e c8       	sub	r8,-20
8000c58a:	13 4e       	ld.w	lr,--r9
8000c58c:	17 4a       	ld.w	r10,--r11
8000c58e:	14 3e       	cp.w	lr,r10
8000c590:	c0 60       	breq	8000c59c <__mcmp+0x2a>
8000c592:	f9 bc 03 ff 	movlo	r12,-1
8000c596:	f9 bc 02 01 	movhs	r12,1
8000c59a:	d8 02       	popm	pc
8000c59c:	10 39       	cp.w	r9,r8
8000c59e:	fe 9b ff f6 	brhi	8000c58a <__mcmp+0x18>
8000c5a2:	d8 02       	popm	pc

8000c5a4 <_Bfree>:
8000c5a4:	d4 21       	pushm	r4-r7,lr
8000c5a6:	18 97       	mov	r7,r12
8000c5a8:	16 95       	mov	r5,r11
8000c5aa:	78 96       	ld.w	r6,r12[0x24]
8000c5ac:	58 06       	cp.w	r6,0
8000c5ae:	c0 91       	brne	8000c5c0 <_Bfree+0x1c>
8000c5b0:	31 0c       	mov	r12,16
8000c5b2:	fe b0 de 37 	rcall	80008220 <malloc>
8000c5b6:	99 36       	st.w	r12[0xc],r6
8000c5b8:	8f 9c       	st.w	r7[0x24],r12
8000c5ba:	99 16       	st.w	r12[0x4],r6
8000c5bc:	99 26       	st.w	r12[0x8],r6
8000c5be:	99 06       	st.w	r12[0x0],r6
8000c5c0:	58 05       	cp.w	r5,0
8000c5c2:	c0 90       	breq	8000c5d4 <_Bfree+0x30>
8000c5c4:	6a 19       	ld.w	r9,r5[0x4]
8000c5c6:	6e 98       	ld.w	r8,r7[0x24]
8000c5c8:	70 38       	ld.w	r8,r8[0xc]
8000c5ca:	f0 09 03 2a 	ld.w	r10,r8[r9<<0x2]
8000c5ce:	8b 0a       	st.w	r5[0x0],r10
8000c5d0:	f0 09 09 25 	st.w	r8[r9<<0x2],r5
8000c5d4:	d8 22       	popm	r4-r7,pc
8000c5d6:	d7 03       	nop

8000c5d8 <_Balloc>:
8000c5d8:	d4 21       	pushm	r4-r7,lr
8000c5da:	18 97       	mov	r7,r12
8000c5dc:	16 96       	mov	r6,r11
8000c5de:	78 95       	ld.w	r5,r12[0x24]
8000c5e0:	58 05       	cp.w	r5,0
8000c5e2:	c0 91       	brne	8000c5f4 <_Balloc+0x1c>
8000c5e4:	31 0c       	mov	r12,16
8000c5e6:	fe b0 de 1d 	rcall	80008220 <malloc>
8000c5ea:	99 35       	st.w	r12[0xc],r5
8000c5ec:	8f 9c       	st.w	r7[0x24],r12
8000c5ee:	99 15       	st.w	r12[0x4],r5
8000c5f0:	99 25       	st.w	r12[0x8],r5
8000c5f2:	99 05       	st.w	r12[0x0],r5
8000c5f4:	6e 95       	ld.w	r5,r7[0x24]
8000c5f6:	6a 38       	ld.w	r8,r5[0xc]
8000c5f8:	58 08       	cp.w	r8,0
8000c5fa:	c0 b1       	brne	8000c610 <_Balloc+0x38>
8000c5fc:	31 0a       	mov	r10,16
8000c5fe:	30 4b       	mov	r11,4
8000c600:	0e 9c       	mov	r12,r7
8000c602:	e0 a0 02 a7 	rcall	8000cb50 <_calloc_r>
8000c606:	8b 3c       	st.w	r5[0xc],r12
8000c608:	6e 98       	ld.w	r8,r7[0x24]
8000c60a:	70 3c       	ld.w	r12,r8[0xc]
8000c60c:	58 0c       	cp.w	r12,0
8000c60e:	c1 b0       	breq	8000c644 <_Balloc+0x6c>
8000c610:	6e 98       	ld.w	r8,r7[0x24]
8000c612:	70 38       	ld.w	r8,r8[0xc]
8000c614:	f0 06 00 28 	add	r8,r8,r6<<0x2
8000c618:	70 0c       	ld.w	r12,r8[0x0]
8000c61a:	58 0c       	cp.w	r12,0
8000c61c:	c0 40       	breq	8000c624 <_Balloc+0x4c>
8000c61e:	78 09       	ld.w	r9,r12[0x0]
8000c620:	91 09       	st.w	r8[0x0],r9
8000c622:	c0 e8       	rjmp	8000c63e <_Balloc+0x66>
8000c624:	0e 9c       	mov	r12,r7
8000c626:	30 17       	mov	r7,1
8000c628:	0e 9b       	mov	r11,r7
8000c62a:	ee 06 09 47 	lsl	r7,r7,r6
8000c62e:	ee ca ff fb 	sub	r10,r7,-5
8000c632:	a3 6a       	lsl	r10,0x2
8000c634:	e0 a0 02 8e 	rcall	8000cb50 <_calloc_r>
8000c638:	c0 60       	breq	8000c644 <_Balloc+0x6c>
8000c63a:	99 16       	st.w	r12[0x4],r6
8000c63c:	99 27       	st.w	r12[0x8],r7
8000c63e:	30 08       	mov	r8,0
8000c640:	99 38       	st.w	r12[0xc],r8
8000c642:	99 48       	st.w	r12[0x10],r8
8000c644:	d8 22       	popm	r4-r7,pc
8000c646:	d7 03       	nop

8000c648 <__d2b>:
8000c648:	d4 31       	pushm	r0-r7,lr
8000c64a:	20 2d       	sub	sp,8
8000c64c:	16 93       	mov	r3,r11
8000c64e:	12 96       	mov	r6,r9
8000c650:	10 95       	mov	r5,r8
8000c652:	14 92       	mov	r2,r10
8000c654:	30 1b       	mov	r11,1
8000c656:	cc 1f       	rcall	8000c5d8 <_Balloc>
8000c658:	f3 d3 c0 14 	bfextu	r9,r3,0x0,0x14
8000c65c:	50 09       	stdsp	sp[0x0],r9
8000c65e:	f1 d3 c0 1f 	bfextu	r8,r3,0x0,0x1f
8000c662:	b5 a9       	sbr	r9,0x14
8000c664:	f0 01 16 14 	lsr	r1,r8,0x14
8000c668:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000c66c:	18 94       	mov	r4,r12
8000c66e:	58 02       	cp.w	r2,0
8000c670:	c1 d0       	breq	8000c6aa <__d2b+0x62>
8000c672:	fa cc ff f8 	sub	r12,sp,-8
8000c676:	18 d2       	st.w	--r12,r2
8000c678:	c3 6f       	rcall	8000c4e4 <__lo0bits>
8000c67a:	40 18       	lddsp	r8,sp[0x4]
8000c67c:	c0 d0       	breq	8000c696 <__d2b+0x4e>
8000c67e:	40 09       	lddsp	r9,sp[0x0]
8000c680:	f8 0a 11 20 	rsub	r10,r12,32
8000c684:	f2 0a 09 4a 	lsl	r10,r9,r10
8000c688:	f5 e8 10 08 	or	r8,r10,r8
8000c68c:	89 58       	st.w	r4[0x14],r8
8000c68e:	f2 0c 0a 49 	lsr	r9,r9,r12
8000c692:	50 09       	stdsp	sp[0x0],r9
8000c694:	c0 28       	rjmp	8000c698 <__d2b+0x50>
8000c696:	89 58       	st.w	r4[0x14],r8
8000c698:	40 08       	lddsp	r8,sp[0x0]
8000c69a:	58 08       	cp.w	r8,0
8000c69c:	f9 b3 01 02 	movne	r3,2
8000c6a0:	f9 b3 00 01 	moveq	r3,1
8000c6a4:	89 68       	st.w	r4[0x18],r8
8000c6a6:	89 43       	st.w	r4[0x10],r3
8000c6a8:	c0 88       	rjmp	8000c6b8 <__d2b+0x70>
8000c6aa:	1a 9c       	mov	r12,sp
8000c6ac:	c1 cf       	rcall	8000c4e4 <__lo0bits>
8000c6ae:	30 13       	mov	r3,1
8000c6b0:	40 08       	lddsp	r8,sp[0x0]
8000c6b2:	2e 0c       	sub	r12,-32
8000c6b4:	89 43       	st.w	r4[0x10],r3
8000c6b6:	89 58       	st.w	r4[0x14],r8
8000c6b8:	58 01       	cp.w	r1,0
8000c6ba:	c0 90       	breq	8000c6cc <__d2b+0x84>
8000c6bc:	e2 c1 04 33 	sub	r1,r1,1075
8000c6c0:	18 01       	add	r1,r12
8000c6c2:	8d 01       	st.w	r6[0x0],r1
8000c6c4:	f8 0c 11 35 	rsub	r12,r12,53
8000c6c8:	8b 0c       	st.w	r5[0x0],r12
8000c6ca:	c0 c8       	rjmp	8000c6e2 <__d2b+0x9a>
8000c6cc:	e6 c8 ff fc 	sub	r8,r3,-4
8000c6d0:	f8 cc 04 32 	sub	r12,r12,1074
8000c6d4:	a5 73       	lsl	r3,0x5
8000c6d6:	8d 0c       	st.w	r6[0x0],r12
8000c6d8:	e8 08 03 2c 	ld.w	r12,r4[r8<<0x2]
8000c6dc:	cd 4e       	rcall	8000c484 <__hi0bits>
8000c6de:	18 13       	sub	r3,r12
8000c6e0:	8b 03       	st.w	r5[0x0],r3
8000c6e2:	08 9c       	mov	r12,r4
8000c6e4:	2f ed       	sub	sp,-8
8000c6e6:	d8 32       	popm	r0-r7,pc

8000c6e8 <__mdiff>:
8000c6e8:	d4 31       	pushm	r0-r7,lr
8000c6ea:	74 48       	ld.w	r8,r10[0x10]
8000c6ec:	76 45       	ld.w	r5,r11[0x10]
8000c6ee:	16 97       	mov	r7,r11
8000c6f0:	14 96       	mov	r6,r10
8000c6f2:	10 15       	sub	r5,r8
8000c6f4:	c1 31       	brne	8000c71a <__mdiff+0x32>
8000c6f6:	2f b8       	sub	r8,-5
8000c6f8:	ee ce ff ec 	sub	lr,r7,-20
8000c6fc:	a3 68       	lsl	r8,0x2
8000c6fe:	f4 08 00 0b 	add	r11,r10,r8
8000c702:	ee 08 00 08 	add	r8,r7,r8
8000c706:	11 4a       	ld.w	r10,--r8
8000c708:	17 49       	ld.w	r9,--r11
8000c70a:	12 3a       	cp.w	r10,r9
8000c70c:	c0 30       	breq	8000c712 <__mdiff+0x2a>
8000c70e:	c0 e2       	brcc	8000c72a <__mdiff+0x42>
8000c710:	c0 78       	rjmp	8000c71e <__mdiff+0x36>
8000c712:	1c 38       	cp.w	r8,lr
8000c714:	fe 9b ff f9 	brhi	8000c706 <__mdiff+0x1e>
8000c718:	c4 98       	rjmp	8000c7aa <__mdiff+0xc2>
8000c71a:	58 05       	cp.w	r5,0
8000c71c:	c0 64       	brge	8000c728 <__mdiff+0x40>
8000c71e:	0e 98       	mov	r8,r7
8000c720:	30 15       	mov	r5,1
8000c722:	0c 97       	mov	r7,r6
8000c724:	10 96       	mov	r6,r8
8000c726:	c0 28       	rjmp	8000c72a <__mdiff+0x42>
8000c728:	30 05       	mov	r5,0
8000c72a:	6e 1b       	ld.w	r11,r7[0x4]
8000c72c:	c5 6f       	rcall	8000c5d8 <_Balloc>
8000c72e:	6e 49       	ld.w	r9,r7[0x10]
8000c730:	6c 44       	ld.w	r4,r6[0x10]
8000c732:	99 35       	st.w	r12[0xc],r5
8000c734:	2f b4       	sub	r4,-5
8000c736:	f2 c5 ff fb 	sub	r5,r9,-5
8000c73a:	ec 04 00 24 	add	r4,r6,r4<<0x2
8000c73e:	ee 05 00 25 	add	r5,r7,r5<<0x2
8000c742:	2e c6       	sub	r6,-20
8000c744:	2e c7       	sub	r7,-20
8000c746:	f8 c8 ff ec 	sub	r8,r12,-20
8000c74a:	30 0a       	mov	r10,0
8000c74c:	0f 0e       	ld.w	lr,r7++
8000c74e:	0d 0b       	ld.w	r11,r6++
8000c750:	fc 02 16 10 	lsr	r2,lr,0x10
8000c754:	f6 03 16 10 	lsr	r3,r11,0x10
8000c758:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000c75c:	e4 03 01 03 	sub	r3,r2,r3
8000c760:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000c764:	fc 0b 01 0b 	sub	r11,lr,r11
8000c768:	f6 0a 00 0a 	add	r10,r11,r10
8000c76c:	b0 1a       	st.h	r8[0x2],r10
8000c76e:	b1 4a       	asr	r10,0x10
8000c770:	e6 0a 00 0a 	add	r10,r3,r10
8000c774:	b0 0a       	st.h	r8[0x0],r10
8000c776:	2f c8       	sub	r8,-4
8000c778:	b1 4a       	asr	r10,0x10
8000c77a:	08 36       	cp.w	r6,r4
8000c77c:	ce 83       	brcs	8000c74c <__mdiff+0x64>
8000c77e:	c0 d8       	rjmp	8000c798 <__mdiff+0xb0>
8000c780:	0f 0b       	ld.w	r11,r7++
8000c782:	f6 0e 16 10 	lsr	lr,r11,0x10
8000c786:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000c78a:	16 0a       	add	r10,r11
8000c78c:	b0 1a       	st.h	r8[0x2],r10
8000c78e:	b1 4a       	asr	r10,0x10
8000c790:	1c 0a       	add	r10,lr
8000c792:	b0 0a       	st.h	r8[0x0],r10
8000c794:	2f c8       	sub	r8,-4
8000c796:	b1 4a       	asr	r10,0x10
8000c798:	0a 37       	cp.w	r7,r5
8000c79a:	cf 33       	brcs	8000c780 <__mdiff+0x98>
8000c79c:	c0 28       	rjmp	8000c7a0 <__mdiff+0xb8>
8000c79e:	20 19       	sub	r9,1
8000c7a0:	11 4a       	ld.w	r10,--r8
8000c7a2:	58 0a       	cp.w	r10,0
8000c7a4:	cf d0       	breq	8000c79e <__mdiff+0xb6>
8000c7a6:	99 49       	st.w	r12[0x10],r9
8000c7a8:	d8 32       	popm	r0-r7,pc
8000c7aa:	30 0b       	mov	r11,0
8000c7ac:	c1 6f       	rcall	8000c5d8 <_Balloc>
8000c7ae:	30 18       	mov	r8,1
8000c7b0:	99 48       	st.w	r12[0x10],r8
8000c7b2:	30 08       	mov	r8,0
8000c7b4:	99 58       	st.w	r12[0x14],r8
8000c7b6:	d8 32       	popm	r0-r7,pc

8000c7b8 <__lshift>:
8000c7b8:	d4 31       	pushm	r0-r7,lr
8000c7ba:	16 97       	mov	r7,r11
8000c7bc:	76 46       	ld.w	r6,r11[0x10]
8000c7be:	f4 02 14 05 	asr	r2,r10,0x5
8000c7c2:	2f f6       	sub	r6,-1
8000c7c4:	14 93       	mov	r3,r10
8000c7c6:	18 94       	mov	r4,r12
8000c7c8:	04 06       	add	r6,r2
8000c7ca:	76 1b       	ld.w	r11,r11[0x4]
8000c7cc:	6e 28       	ld.w	r8,r7[0x8]
8000c7ce:	c0 38       	rjmp	8000c7d4 <__lshift+0x1c>
8000c7d0:	2f fb       	sub	r11,-1
8000c7d2:	a1 78       	lsl	r8,0x1
8000c7d4:	10 36       	cp.w	r6,r8
8000c7d6:	fe 99 ff fd 	brgt	8000c7d0 <__lshift+0x18>
8000c7da:	08 9c       	mov	r12,r4
8000c7dc:	cf ee       	rcall	8000c5d8 <_Balloc>
8000c7de:	30 09       	mov	r9,0
8000c7e0:	18 95       	mov	r5,r12
8000c7e2:	f8 c8 ff ec 	sub	r8,r12,-20
8000c7e6:	12 9a       	mov	r10,r9
8000c7e8:	c0 38       	rjmp	8000c7ee <__lshift+0x36>
8000c7ea:	10 aa       	st.w	r8++,r10
8000c7ec:	2f f9       	sub	r9,-1
8000c7ee:	04 39       	cp.w	r9,r2
8000c7f0:	cf d5       	brlt	8000c7ea <__lshift+0x32>
8000c7f2:	6e 4b       	ld.w	r11,r7[0x10]
8000c7f4:	e7 d3 c0 05 	bfextu	r3,r3,0x0,0x5
8000c7f8:	2f bb       	sub	r11,-5
8000c7fa:	ee c9 ff ec 	sub	r9,r7,-20
8000c7fe:	ee 0b 00 2b 	add	r11,r7,r11<<0x2
8000c802:	58 03       	cp.w	r3,0
8000c804:	c1 30       	breq	8000c82a <__lshift+0x72>
8000c806:	e6 0c 11 20 	rsub	r12,r3,32
8000c80a:	30 0a       	mov	r10,0
8000c80c:	72 02       	ld.w	r2,r9[0x0]
8000c80e:	e4 03 09 42 	lsl	r2,r2,r3
8000c812:	04 4a       	or	r10,r2
8000c814:	10 aa       	st.w	r8++,r10
8000c816:	13 0a       	ld.w	r10,r9++
8000c818:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000c81c:	16 39       	cp.w	r9,r11
8000c81e:	cf 73       	brcs	8000c80c <__lshift+0x54>
8000c820:	91 0a       	st.w	r8[0x0],r10
8000c822:	58 0a       	cp.w	r10,0
8000c824:	c0 70       	breq	8000c832 <__lshift+0x7a>
8000c826:	2f f6       	sub	r6,-1
8000c828:	c0 58       	rjmp	8000c832 <__lshift+0x7a>
8000c82a:	13 0a       	ld.w	r10,r9++
8000c82c:	10 aa       	st.w	r8++,r10
8000c82e:	16 39       	cp.w	r9,r11
8000c830:	cf d3       	brcs	8000c82a <__lshift+0x72>
8000c832:	08 9c       	mov	r12,r4
8000c834:	20 16       	sub	r6,1
8000c836:	0e 9b       	mov	r11,r7
8000c838:	8b 46       	st.w	r5[0x10],r6
8000c83a:	cb 5e       	rcall	8000c5a4 <_Bfree>
8000c83c:	0a 9c       	mov	r12,r5
8000c83e:	d8 32       	popm	r0-r7,pc

8000c840 <__multiply>:
8000c840:	d4 31       	pushm	r0-r7,lr
8000c842:	20 2d       	sub	sp,8
8000c844:	76 49       	ld.w	r9,r11[0x10]
8000c846:	74 48       	ld.w	r8,r10[0x10]
8000c848:	16 96       	mov	r6,r11
8000c84a:	14 95       	mov	r5,r10
8000c84c:	10 39       	cp.w	r9,r8
8000c84e:	ec 08 17 50 	movlt	r8,r6
8000c852:	ea 06 17 50 	movlt	r6,r5
8000c856:	f0 05 17 50 	movlt	r5,r8
8000c85a:	6c 28       	ld.w	r8,r6[0x8]
8000c85c:	76 43       	ld.w	r3,r11[0x10]
8000c85e:	74 42       	ld.w	r2,r10[0x10]
8000c860:	76 1b       	ld.w	r11,r11[0x4]
8000c862:	e4 03 00 07 	add	r7,r2,r3
8000c866:	10 37       	cp.w	r7,r8
8000c868:	f7 bb 09 ff 	subgt	r11,-1
8000c86c:	cb 6e       	rcall	8000c5d8 <_Balloc>
8000c86e:	ee c4 ff fb 	sub	r4,r7,-5
8000c872:	f8 c9 ff ec 	sub	r9,r12,-20
8000c876:	f8 04 00 24 	add	r4,r12,r4<<0x2
8000c87a:	30 0a       	mov	r10,0
8000c87c:	12 98       	mov	r8,r9
8000c87e:	c0 28       	rjmp	8000c882 <__multiply+0x42>
8000c880:	10 aa       	st.w	r8++,r10
8000c882:	08 38       	cp.w	r8,r4
8000c884:	cf e3       	brcs	8000c880 <__multiply+0x40>
8000c886:	2f b3       	sub	r3,-5
8000c888:	2f b2       	sub	r2,-5
8000c88a:	ec 03 00 23 	add	r3,r6,r3<<0x2
8000c88e:	ea 02 00 22 	add	r2,r5,r2<<0x2
8000c892:	ec cb ff ec 	sub	r11,r6,-20
8000c896:	50 12       	stdsp	sp[0x4],r2
8000c898:	ea ca ff ec 	sub	r10,r5,-20
8000c89c:	c4 48       	rjmp	8000c924 <__multiply+0xe4>
8000c89e:	94 95       	ld.uh	r5,r10[0x2]
8000c8a0:	58 05       	cp.w	r5,0
8000c8a2:	c2 00       	breq	8000c8e2 <__multiply+0xa2>
8000c8a4:	12 98       	mov	r8,r9
8000c8a6:	16 96       	mov	r6,r11
8000c8a8:	30 0e       	mov	lr,0
8000c8aa:	50 09       	stdsp	sp[0x0],r9
8000c8ac:	0d 02       	ld.w	r2,r6++
8000c8ae:	e4 00 16 10 	lsr	r0,r2,0x10
8000c8b2:	70 01       	ld.w	r1,r8[0x0]
8000c8b4:	70 09       	ld.w	r9,r8[0x0]
8000c8b6:	b1 81       	lsr	r1,0x10
8000c8b8:	e5 d2 c0 10 	bfextu	r2,r2,0x0,0x10
8000c8bc:	e0 05 03 41 	mac	r1,r0,r5
8000c8c0:	ab 32       	mul	r2,r5
8000c8c2:	e1 d9 c0 10 	bfextu	r0,r9,0x0,0x10
8000c8c6:	00 02       	add	r2,r0
8000c8c8:	e4 0e 00 0e 	add	lr,r2,lr
8000c8cc:	b0 1e       	st.h	r8[0x2],lr
8000c8ce:	b1 8e       	lsr	lr,0x10
8000c8d0:	1c 01       	add	r1,lr
8000c8d2:	b0 01       	st.h	r8[0x0],r1
8000c8d4:	e2 0e 16 10 	lsr	lr,r1,0x10
8000c8d8:	2f c8       	sub	r8,-4
8000c8da:	06 36       	cp.w	r6,r3
8000c8dc:	ce 83       	brcs	8000c8ac <__multiply+0x6c>
8000c8de:	40 09       	lddsp	r9,sp[0x0]
8000c8e0:	91 0e       	st.w	r8[0x0],lr
8000c8e2:	94 86       	ld.uh	r6,r10[0x0]
8000c8e4:	58 06       	cp.w	r6,0
8000c8e6:	c1 d0       	breq	8000c920 <__multiply+0xe0>
8000c8e8:	72 02       	ld.w	r2,r9[0x0]
8000c8ea:	12 98       	mov	r8,r9
8000c8ec:	16 9e       	mov	lr,r11
8000c8ee:	30 05       	mov	r5,0
8000c8f0:	b0 12       	st.h	r8[0x2],r2
8000c8f2:	1d 01       	ld.w	r1,lr++
8000c8f4:	90 82       	ld.uh	r2,r8[0x0]
8000c8f6:	e1 d1 c0 10 	bfextu	r0,r1,0x0,0x10
8000c8fa:	ad 30       	mul	r0,r6
8000c8fc:	e0 02 00 02 	add	r2,r0,r2
8000c900:	e4 05 00 05 	add	r5,r2,r5
8000c904:	b0 05       	st.h	r8[0x0],r5
8000c906:	b1 85       	lsr	r5,0x10
8000c908:	b1 81       	lsr	r1,0x10
8000c90a:	2f c8       	sub	r8,-4
8000c90c:	ad 31       	mul	r1,r6
8000c90e:	90 92       	ld.uh	r2,r8[0x2]
8000c910:	e2 02 00 02 	add	r2,r1,r2
8000c914:	0a 02       	add	r2,r5
8000c916:	e4 05 16 10 	lsr	r5,r2,0x10
8000c91a:	06 3e       	cp.w	lr,r3
8000c91c:	ce a3       	brcs	8000c8f0 <__multiply+0xb0>
8000c91e:	91 02       	st.w	r8[0x0],r2
8000c920:	2f ca       	sub	r10,-4
8000c922:	2f c9       	sub	r9,-4
8000c924:	40 18       	lddsp	r8,sp[0x4]
8000c926:	10 3a       	cp.w	r10,r8
8000c928:	cb b3       	brcs	8000c89e <__multiply+0x5e>
8000c92a:	c0 28       	rjmp	8000c92e <__multiply+0xee>
8000c92c:	20 17       	sub	r7,1
8000c92e:	58 07       	cp.w	r7,0
8000c930:	e0 8a 00 05 	brle	8000c93a <__multiply+0xfa>
8000c934:	09 48       	ld.w	r8,--r4
8000c936:	58 08       	cp.w	r8,0
8000c938:	cf a0       	breq	8000c92c <__multiply+0xec>
8000c93a:	99 47       	st.w	r12[0x10],r7
8000c93c:	2f ed       	sub	sp,-8
8000c93e:	d8 32       	popm	r0-r7,pc

8000c940 <__i2b>:
8000c940:	d4 21       	pushm	r4-r7,lr
8000c942:	16 97       	mov	r7,r11
8000c944:	30 1b       	mov	r11,1
8000c946:	c4 9e       	rcall	8000c5d8 <_Balloc>
8000c948:	30 19       	mov	r9,1
8000c94a:	99 57       	st.w	r12[0x14],r7
8000c94c:	99 49       	st.w	r12[0x10],r9
8000c94e:	d8 22       	popm	r4-r7,pc

8000c950 <__multadd>:
8000c950:	d4 31       	pushm	r0-r7,lr
8000c952:	30 08       	mov	r8,0
8000c954:	12 95       	mov	r5,r9
8000c956:	16 97       	mov	r7,r11
8000c958:	18 96       	mov	r6,r12
8000c95a:	76 44       	ld.w	r4,r11[0x10]
8000c95c:	f6 c9 ff ec 	sub	r9,r11,-20
8000c960:	72 0b       	ld.w	r11,r9[0x0]
8000c962:	f6 0c 16 10 	lsr	r12,r11,0x10
8000c966:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000c96a:	f4 0c 02 4c 	mul	r12,r10,r12
8000c96e:	f4 0b 03 45 	mac	r5,r10,r11
8000c972:	f7 d5 c0 10 	bfextu	r11,r5,0x0,0x10
8000c976:	b1 85       	lsr	r5,0x10
8000c978:	18 05       	add	r5,r12
8000c97a:	ea 0c 15 10 	lsl	r12,r5,0x10
8000c97e:	f8 0b 00 0b 	add	r11,r12,r11
8000c982:	12 ab       	st.w	r9++,r11
8000c984:	2f f8       	sub	r8,-1
8000c986:	b1 85       	lsr	r5,0x10
8000c988:	08 38       	cp.w	r8,r4
8000c98a:	ce b5       	brlt	8000c960 <__multadd+0x10>
8000c98c:	58 05       	cp.w	r5,0
8000c98e:	c1 c0       	breq	8000c9c6 <__multadd+0x76>
8000c990:	6e 28       	ld.w	r8,r7[0x8]
8000c992:	10 34       	cp.w	r4,r8
8000c994:	c1 35       	brlt	8000c9ba <__multadd+0x6a>
8000c996:	6e 1b       	ld.w	r11,r7[0x4]
8000c998:	0c 9c       	mov	r12,r6
8000c99a:	2f fb       	sub	r11,-1
8000c99c:	c1 ee       	rcall	8000c5d8 <_Balloc>
8000c99e:	6e 4a       	ld.w	r10,r7[0x10]
8000c9a0:	ee cb ff f4 	sub	r11,r7,-12
8000c9a4:	18 93       	mov	r3,r12
8000c9a6:	2f ea       	sub	r10,-2
8000c9a8:	2f 4c       	sub	r12,-12
8000c9aa:	a3 6a       	lsl	r10,0x2
8000c9ac:	fe b0 de 71 	rcall	8000868e <memcpy>
8000c9b0:	0e 9b       	mov	r11,r7
8000c9b2:	0c 9c       	mov	r12,r6
8000c9b4:	fe b0 fd f8 	rcall	8000c5a4 <_Bfree>
8000c9b8:	06 97       	mov	r7,r3
8000c9ba:	e8 c8 ff ff 	sub	r8,r4,-1
8000c9be:	2f b4       	sub	r4,-5
8000c9c0:	8f 48       	st.w	r7[0x10],r8
8000c9c2:	ee 04 09 25 	st.w	r7[r4<<0x2],r5
8000c9c6:	0e 9c       	mov	r12,r7
8000c9c8:	d8 32       	popm	r0-r7,pc
8000c9ca:	d7 03       	nop

8000c9cc <__pow5mult>:
8000c9cc:	d4 31       	pushm	r0-r7,lr
8000c9ce:	14 96       	mov	r6,r10
8000c9d0:	18 97       	mov	r7,r12
8000c9d2:	16 94       	mov	r4,r11
8000c9d4:	f1 da c0 02 	bfextu	r8,r10,0x0,0x2
8000c9d8:	c0 90       	breq	8000c9ea <__pow5mult+0x1e>
8000c9da:	20 18       	sub	r8,1
8000c9dc:	fe c9 d6 8c 	sub	r9,pc,-10612
8000c9e0:	f2 08 03 2a 	ld.w	r10,r9[r8<<0x2]
8000c9e4:	30 09       	mov	r9,0
8000c9e6:	cb 5f       	rcall	8000c950 <__multadd>
8000c9e8:	18 94       	mov	r4,r12
8000c9ea:	a3 46       	asr	r6,0x2
8000c9ec:	c3 40       	breq	8000ca54 <__pow5mult+0x88>
8000c9ee:	6e 95       	ld.w	r5,r7[0x24]
8000c9f0:	58 05       	cp.w	r5,0
8000c9f2:	c0 91       	brne	8000ca04 <__pow5mult+0x38>
8000c9f4:	31 0c       	mov	r12,16
8000c9f6:	fe b0 dc 15 	rcall	80008220 <malloc>
8000c9fa:	99 35       	st.w	r12[0xc],r5
8000c9fc:	8f 9c       	st.w	r7[0x24],r12
8000c9fe:	99 15       	st.w	r12[0x4],r5
8000ca00:	99 25       	st.w	r12[0x8],r5
8000ca02:	99 05       	st.w	r12[0x0],r5
8000ca04:	6e 93       	ld.w	r3,r7[0x24]
8000ca06:	66 25       	ld.w	r5,r3[0x8]
8000ca08:	58 05       	cp.w	r5,0
8000ca0a:	c0 c1       	brne	8000ca22 <__pow5mult+0x56>
8000ca0c:	e0 6b 02 71 	mov	r11,625
8000ca10:	0e 9c       	mov	r12,r7
8000ca12:	c9 7f       	rcall	8000c940 <__i2b>
8000ca14:	87 2c       	st.w	r3[0x8],r12
8000ca16:	30 08       	mov	r8,0
8000ca18:	18 95       	mov	r5,r12
8000ca1a:	99 08       	st.w	r12[0x0],r8
8000ca1c:	c0 38       	rjmp	8000ca22 <__pow5mult+0x56>
8000ca1e:	06 9c       	mov	r12,r3
8000ca20:	18 95       	mov	r5,r12
8000ca22:	ed b6 00 00 	bld	r6,0x0
8000ca26:	c0 b1       	brne	8000ca3c <__pow5mult+0x70>
8000ca28:	08 9b       	mov	r11,r4
8000ca2a:	0a 9a       	mov	r10,r5
8000ca2c:	0e 9c       	mov	r12,r7
8000ca2e:	c0 9f       	rcall	8000c840 <__multiply>
8000ca30:	08 9b       	mov	r11,r4
8000ca32:	18 93       	mov	r3,r12
8000ca34:	0e 9c       	mov	r12,r7
8000ca36:	06 94       	mov	r4,r3
8000ca38:	fe b0 fd b6 	rcall	8000c5a4 <_Bfree>
8000ca3c:	a1 56       	asr	r6,0x1
8000ca3e:	c0 b0       	breq	8000ca54 <__pow5mult+0x88>
8000ca40:	6a 03       	ld.w	r3,r5[0x0]
8000ca42:	58 03       	cp.w	r3,0
8000ca44:	ce d1       	brne	8000ca1e <__pow5mult+0x52>
8000ca46:	0a 9a       	mov	r10,r5
8000ca48:	0a 9b       	mov	r11,r5
8000ca4a:	0e 9c       	mov	r12,r7
8000ca4c:	cf ae       	rcall	8000c840 <__multiply>
8000ca4e:	8b 0c       	st.w	r5[0x0],r12
8000ca50:	99 03       	st.w	r12[0x0],r3
8000ca52:	ce 7b       	rjmp	8000ca20 <__pow5mult+0x54>
8000ca54:	08 9c       	mov	r12,r4
8000ca56:	d8 32       	popm	r0-r7,pc

8000ca58 <__isinfd>:
8000ca58:	14 98       	mov	r8,r10
8000ca5a:	fc 19 7f f0 	movh	r9,0x7ff0
8000ca5e:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000ca62:	f0 0b 11 00 	rsub	r11,r8,0
8000ca66:	f7 e8 10 08 	or	r8,r11,r8
8000ca6a:	f5 e8 13 f8 	or	r8,r10,r8>>0x1f
8000ca6e:	f2 08 01 08 	sub	r8,r9,r8
8000ca72:	f0 0c 11 00 	rsub	r12,r8,0
8000ca76:	f9 e8 10 08 	or	r8,r12,r8
8000ca7a:	f0 0c 14 1f 	asr	r12,r8,0x1f
8000ca7e:	2f fc       	sub	r12,-1
8000ca80:	5e fc       	retal	r12

8000ca82 <__isnand>:
8000ca82:	14 98       	mov	r8,r10
8000ca84:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000ca88:	f0 0c 11 00 	rsub	r12,r8,0
8000ca8c:	10 4c       	or	r12,r8
8000ca8e:	fc 18 7f f0 	movh	r8,0x7ff0
8000ca92:	f5 ec 13 fc 	or	r12,r10,r12>>0x1f
8000ca96:	f0 0c 01 0c 	sub	r12,r8,r12
8000ca9a:	bf 9c       	lsr	r12,0x1f
8000ca9c:	5e fc       	retal	r12
8000ca9e:	d7 03       	nop

8000caa0 <__sclose>:
8000caa0:	d4 01       	pushm	lr
8000caa2:	96 7b       	ld.sh	r11,r11[0xe]
8000caa4:	c8 2c       	rcall	8000cba8 <_close_r>
8000caa6:	d8 02       	popm	pc

8000caa8 <__sseek>:
8000caa8:	d4 21       	pushm	r4-r7,lr
8000caaa:	16 97       	mov	r7,r11
8000caac:	96 7b       	ld.sh	r11,r11[0xe]
8000caae:	c0 3d       	rcall	8000ccb4 <_lseek_r>
8000cab0:	8e 68       	ld.sh	r8,r7[0xc]
8000cab2:	10 99       	mov	r9,r8
8000cab4:	ad c8       	cbr	r8,0xc
8000cab6:	ad a9       	sbr	r9,0xc
8000cab8:	5b fc       	cp.w	r12,-1
8000caba:	ef f8 0c 06 	st.heq	r7[0xc],r8
8000cabe:	ef f9 1c 06 	st.hne	r7[0xc],r9
8000cac2:	ef fc 1a 15 	st.wne	r7[0x54],r12
8000cac6:	d8 22       	popm	r4-r7,pc

8000cac8 <__swrite>:
8000cac8:	d4 21       	pushm	r4-r7,lr
8000caca:	96 68       	ld.sh	r8,r11[0xc]
8000cacc:	16 97       	mov	r7,r11
8000cace:	14 95       	mov	r5,r10
8000cad0:	12 94       	mov	r4,r9
8000cad2:	e2 18 01 00 	andl	r8,0x100,COH
8000cad6:	18 96       	mov	r6,r12
8000cad8:	c0 50       	breq	8000cae2 <__swrite+0x1a>
8000cada:	30 29       	mov	r9,2
8000cadc:	30 0a       	mov	r10,0
8000cade:	96 7b       	ld.sh	r11,r11[0xe]
8000cae0:	ce ac       	rcall	8000ccb4 <_lseek_r>
8000cae2:	8e 68       	ld.sh	r8,r7[0xc]
8000cae4:	ad c8       	cbr	r8,0xc
8000cae6:	08 99       	mov	r9,r4
8000cae8:	0a 9a       	mov	r10,r5
8000caea:	8e 7b       	ld.sh	r11,r7[0xe]
8000caec:	0c 9c       	mov	r12,r6
8000caee:	ae 68       	st.h	r7[0xc],r8
8000caf0:	c1 cc       	rcall	8000cb28 <_write_r>
8000caf2:	d8 22       	popm	r4-r7,pc

8000caf4 <__sread>:
8000caf4:	d4 21       	pushm	r4-r7,lr
8000caf6:	16 97       	mov	r7,r11
8000caf8:	96 7b       	ld.sh	r11,r11[0xe]
8000cafa:	cf 1c       	rcall	8000ccdc <_read_r>
8000cafc:	c0 65       	brlt	8000cb08 <__sread+0x14>
8000cafe:	6f 58       	ld.w	r8,r7[0x54]
8000cb00:	18 08       	add	r8,r12
8000cb02:	ef 48 00 54 	st.w	r7[84],r8
8000cb06:	d8 22       	popm	r4-r7,pc
8000cb08:	8e 68       	ld.sh	r8,r7[0xc]
8000cb0a:	ad c8       	cbr	r8,0xc
8000cb0c:	ae 68       	st.h	r7[0xc],r8
8000cb0e:	d8 22       	popm	r4-r7,pc

8000cb10 <strlen>:
8000cb10:	30 09       	mov	r9,0
8000cb12:	18 98       	mov	r8,r12
8000cb14:	c0 28       	rjmp	8000cb18 <strlen+0x8>
8000cb16:	2f f8       	sub	r8,-1
8000cb18:	11 8a       	ld.ub	r10,r8[0x0]
8000cb1a:	f2 0a 18 00 	cp.b	r10,r9
8000cb1e:	cf c1       	brne	8000cb16 <strlen+0x6>
8000cb20:	f0 0c 01 0c 	sub	r12,r8,r12
8000cb24:	5e fc       	retal	r12
8000cb26:	d7 03       	nop

8000cb28 <_write_r>:
8000cb28:	d4 21       	pushm	r4-r7,lr
8000cb2a:	16 98       	mov	r8,r11
8000cb2c:	18 97       	mov	r7,r12
8000cb2e:	10 9c       	mov	r12,r8
8000cb30:	30 08       	mov	r8,0
8000cb32:	14 9b       	mov	r11,r10
8000cb34:	e0 66 bd 4c 	mov	r6,48460
8000cb38:	12 9a       	mov	r10,r9
8000cb3a:	8d 08       	st.w	r6[0x0],r8
8000cb3c:	fe b0 d1 60 	rcall	80006dfc <_write>
8000cb40:	5b fc       	cp.w	r12,-1
8000cb42:	c0 51       	brne	8000cb4c <_write_r+0x24>
8000cb44:	6c 08       	ld.w	r8,r6[0x0]
8000cb46:	58 08       	cp.w	r8,0
8000cb48:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000cb4c:	d8 22       	popm	r4-r7,pc
8000cb4e:	d7 03       	nop

8000cb50 <_calloc_r>:
8000cb50:	d4 21       	pushm	r4-r7,lr
8000cb52:	f4 0b 02 4b 	mul	r11,r10,r11
8000cb56:	fe b0 db 6d 	rcall	80008230 <_malloc_r>
8000cb5a:	18 97       	mov	r7,r12
8000cb5c:	c2 30       	breq	8000cba2 <_calloc_r+0x52>
8000cb5e:	f8 fa ff fc 	ld.w	r10,r12[-4]
8000cb62:	e0 1a ff fc 	andl	r10,0xfffc
8000cb66:	20 4a       	sub	r10,4
8000cb68:	e0 4a 00 24 	cp.w	r10,36
8000cb6c:	e0 8b 00 18 	brhi	8000cb9c <_calloc_r+0x4c>
8000cb70:	18 98       	mov	r8,r12
8000cb72:	59 3a       	cp.w	r10,19
8000cb74:	e0 88 00 0f 	brls	8000cb92 <_calloc_r+0x42>
8000cb78:	30 09       	mov	r9,0
8000cb7a:	10 a9       	st.w	r8++,r9
8000cb7c:	10 a9       	st.w	r8++,r9
8000cb7e:	59 ba       	cp.w	r10,27
8000cb80:	e0 88 00 09 	brls	8000cb92 <_calloc_r+0x42>
8000cb84:	10 a9       	st.w	r8++,r9
8000cb86:	10 a9       	st.w	r8++,r9
8000cb88:	e0 4a 00 24 	cp.w	r10,36
8000cb8c:	c0 31       	brne	8000cb92 <_calloc_r+0x42>
8000cb8e:	10 a9       	st.w	r8++,r9
8000cb90:	10 a9       	st.w	r8++,r9
8000cb92:	30 09       	mov	r9,0
8000cb94:	10 a9       	st.w	r8++,r9
8000cb96:	91 19       	st.w	r8[0x4],r9
8000cb98:	91 09       	st.w	r8[0x0],r9
8000cb9a:	c0 48       	rjmp	8000cba2 <_calloc_r+0x52>
8000cb9c:	30 0b       	mov	r11,0
8000cb9e:	fe b0 de 1c 	rcall	800087d6 <memset>
8000cba2:	0e 9c       	mov	r12,r7
8000cba4:	d8 22       	popm	r4-r7,pc
8000cba6:	d7 03       	nop

8000cba8 <_close_r>:
8000cba8:	d4 21       	pushm	r4-r7,lr
8000cbaa:	30 08       	mov	r8,0
8000cbac:	18 97       	mov	r7,r12
8000cbae:	e0 66 bd 4c 	mov	r6,48460
8000cbb2:	16 9c       	mov	r12,r11
8000cbb4:	8d 08       	st.w	r6[0x0],r8
8000cbb6:	fe b0 df b5 	rcall	80008b20 <_close>
8000cbba:	5b fc       	cp.w	r12,-1
8000cbbc:	c0 51       	brne	8000cbc6 <_close_r+0x1e>
8000cbbe:	6c 08       	ld.w	r8,r6[0x0]
8000cbc0:	58 08       	cp.w	r8,0
8000cbc2:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000cbc6:	d8 22       	popm	r4-r7,pc

8000cbc8 <_fclose_r>:
8000cbc8:	d4 21       	pushm	r4-r7,lr
8000cbca:	18 96       	mov	r6,r12
8000cbcc:	16 97       	mov	r7,r11
8000cbce:	58 0b       	cp.w	r11,0
8000cbd0:	c0 31       	brne	8000cbd6 <_fclose_r+0xe>
8000cbd2:	16 95       	mov	r5,r11
8000cbd4:	c5 38       	rjmp	8000cc7a <_fclose_r+0xb2>
8000cbd6:	fe b0 f8 a9 	rcall	8000bd28 <__sfp_lock_acquire>
8000cbda:	58 06       	cp.w	r6,0
8000cbdc:	c0 70       	breq	8000cbea <_fclose_r+0x22>
8000cbde:	6c 68       	ld.w	r8,r6[0x18]
8000cbe0:	58 08       	cp.w	r8,0
8000cbe2:	c0 41       	brne	8000cbea <_fclose_r+0x22>
8000cbe4:	0c 9c       	mov	r12,r6
8000cbe6:	fe b0 f8 f3 	rcall	8000bdcc <__sinit>
8000cbea:	fe c8 d9 3e 	sub	r8,pc,-9922
8000cbee:	10 37       	cp.w	r7,r8
8000cbf0:	c0 31       	brne	8000cbf6 <_fclose_r+0x2e>
8000cbf2:	6c 07       	ld.w	r7,r6[0x0]
8000cbf4:	c0 c8       	rjmp	8000cc0c <_fclose_r+0x44>
8000cbf6:	fe c8 d9 2a 	sub	r8,pc,-9942
8000cbfa:	10 37       	cp.w	r7,r8
8000cbfc:	c0 31       	brne	8000cc02 <_fclose_r+0x3a>
8000cbfe:	6c 17       	ld.w	r7,r6[0x4]
8000cc00:	c0 68       	rjmp	8000cc0c <_fclose_r+0x44>
8000cc02:	fe c8 d9 16 	sub	r8,pc,-9962
8000cc06:	10 37       	cp.w	r7,r8
8000cc08:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000cc0c:	8e 69       	ld.sh	r9,r7[0xc]
8000cc0e:	30 08       	mov	r8,0
8000cc10:	f0 09 19 00 	cp.h	r9,r8
8000cc14:	c0 51       	brne	8000cc1e <_fclose_r+0x56>
8000cc16:	fe b0 f8 8a 	rcall	8000bd2a <__sfp_lock_release>
8000cc1a:	30 05       	mov	r5,0
8000cc1c:	c2 f8       	rjmp	8000cc7a <_fclose_r+0xb2>
8000cc1e:	0e 9b       	mov	r11,r7
8000cc20:	0c 9c       	mov	r12,r6
8000cc22:	fe b0 f7 fd 	rcall	8000bc1c <_fflush_r>
8000cc26:	6e c8       	ld.w	r8,r7[0x30]
8000cc28:	18 95       	mov	r5,r12
8000cc2a:	58 08       	cp.w	r8,0
8000cc2c:	c0 60       	breq	8000cc38 <_fclose_r+0x70>
8000cc2e:	6e 8b       	ld.w	r11,r7[0x20]
8000cc30:	0c 9c       	mov	r12,r6
8000cc32:	5d 18       	icall	r8
8000cc34:	f9 b5 05 ff 	movlt	r5,-1
8000cc38:	8e 68       	ld.sh	r8,r7[0xc]
8000cc3a:	ed b8 00 07 	bld	r8,0x7
8000cc3e:	c0 51       	brne	8000cc48 <_fclose_r+0x80>
8000cc40:	6e 4b       	ld.w	r11,r7[0x10]
8000cc42:	0c 9c       	mov	r12,r6
8000cc44:	fe b0 f9 5e 	rcall	8000bf00 <_free_r>
8000cc48:	6e db       	ld.w	r11,r7[0x34]
8000cc4a:	58 0b       	cp.w	r11,0
8000cc4c:	c0 a0       	breq	8000cc60 <_fclose_r+0x98>
8000cc4e:	ee c8 ff bc 	sub	r8,r7,-68
8000cc52:	10 3b       	cp.w	r11,r8
8000cc54:	c0 40       	breq	8000cc5c <_fclose_r+0x94>
8000cc56:	0c 9c       	mov	r12,r6
8000cc58:	fe b0 f9 54 	rcall	8000bf00 <_free_r>
8000cc5c:	30 08       	mov	r8,0
8000cc5e:	8f d8       	st.w	r7[0x34],r8
8000cc60:	6f 2b       	ld.w	r11,r7[0x48]
8000cc62:	58 0b       	cp.w	r11,0
8000cc64:	c0 70       	breq	8000cc72 <_fclose_r+0xaa>
8000cc66:	0c 9c       	mov	r12,r6
8000cc68:	fe b0 f9 4c 	rcall	8000bf00 <_free_r>
8000cc6c:	30 08       	mov	r8,0
8000cc6e:	ef 48 00 48 	st.w	r7[72],r8
8000cc72:	30 08       	mov	r8,0
8000cc74:	ae 68       	st.h	r7[0xc],r8
8000cc76:	fe b0 f8 5a 	rcall	8000bd2a <__sfp_lock_release>
8000cc7a:	0a 9c       	mov	r12,r5
8000cc7c:	d8 22       	popm	r4-r7,pc
8000cc7e:	d7 03       	nop

8000cc80 <fclose>:
8000cc80:	d4 01       	pushm	lr
8000cc82:	e0 68 0a 54 	mov	r8,2644
8000cc86:	18 9b       	mov	r11,r12
8000cc88:	70 0c       	ld.w	r12,r8[0x0]
8000cc8a:	c9 ff       	rcall	8000cbc8 <_fclose_r>
8000cc8c:	d8 02       	popm	pc
8000cc8e:	d7 03       	nop

8000cc90 <_fstat_r>:
8000cc90:	d4 21       	pushm	r4-r7,lr
8000cc92:	16 98       	mov	r8,r11
8000cc94:	18 97       	mov	r7,r12
8000cc96:	10 9c       	mov	r12,r8
8000cc98:	30 08       	mov	r8,0
8000cc9a:	e0 66 bd 4c 	mov	r6,48460
8000cc9e:	14 9b       	mov	r11,r10
8000cca0:	8d 08       	st.w	r6[0x0],r8
8000cca2:	fe b0 df 67 	rcall	80008b70 <_fstat>
8000cca6:	5b fc       	cp.w	r12,-1
8000cca8:	c0 51       	brne	8000ccb2 <_fstat_r+0x22>
8000ccaa:	6c 08       	ld.w	r8,r6[0x0]
8000ccac:	58 08       	cp.w	r8,0
8000ccae:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000ccb2:	d8 22       	popm	r4-r7,pc

8000ccb4 <_lseek_r>:
8000ccb4:	d4 21       	pushm	r4-r7,lr
8000ccb6:	16 98       	mov	r8,r11
8000ccb8:	18 97       	mov	r7,r12
8000ccba:	10 9c       	mov	r12,r8
8000ccbc:	30 08       	mov	r8,0
8000ccbe:	14 9b       	mov	r11,r10
8000ccc0:	e0 66 bd 4c 	mov	r6,48460
8000ccc4:	12 9a       	mov	r10,r9
8000ccc6:	8d 08       	st.w	r6[0x0],r8
8000ccc8:	fe b0 df 36 	rcall	80008b34 <_lseek>
8000cccc:	5b fc       	cp.w	r12,-1
8000ccce:	c0 51       	brne	8000ccd8 <_lseek_r+0x24>
8000ccd0:	6c 08       	ld.w	r8,r6[0x0]
8000ccd2:	58 08       	cp.w	r8,0
8000ccd4:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000ccd8:	d8 22       	popm	r4-r7,pc
8000ccda:	d7 03       	nop

8000ccdc <_read_r>:
8000ccdc:	d4 21       	pushm	r4-r7,lr
8000ccde:	16 98       	mov	r8,r11
8000cce0:	18 97       	mov	r7,r12
8000cce2:	10 9c       	mov	r12,r8
8000cce4:	30 08       	mov	r8,0
8000cce6:	14 9b       	mov	r11,r10
8000cce8:	e0 66 bd 4c 	mov	r6,48460
8000ccec:	12 9a       	mov	r10,r9
8000ccee:	8d 08       	st.w	r6[0x0],r8
8000ccf0:	fe b0 d0 66 	rcall	80006dbc <_read>
8000ccf4:	5b fc       	cp.w	r12,-1
8000ccf6:	c0 51       	brne	8000cd00 <_read_r+0x24>
8000ccf8:	6c 08       	ld.w	r8,r6[0x0]
8000ccfa:	58 08       	cp.w	r8,0
8000ccfc:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000cd00:	d8 22       	popm	r4-r7,pc
8000cd02:	d7 03       	nop

8000cd04 <__avr32_f64_mul>:
8000cd04:	f5 eb 10 1c 	or	r12,r10,r11<<0x1
8000cd08:	e0 80 00 dc 	breq	8000cec0 <__avr32_f64_mul_op1_zero>
8000cd0c:	d4 21       	pushm	r4-r7,lr
8000cd0e:	f7 e9 20 0e 	eor	lr,r11,r9
8000cd12:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000cd16:	30 15       	mov	r5,1
8000cd18:	c4 30       	breq	8000cd9e <__avr32_f64_mul_op1_subnormal>
8000cd1a:	ab 6b       	lsl	r11,0xa
8000cd1c:	f7 ea 13 6b 	or	r11,r11,r10>>0x16
8000cd20:	ab 6a       	lsl	r10,0xa
8000cd22:	f7 d5 d3 c2 	bfins	r11,r5,0x1e,0x2
8000cd26:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000cd2a:	c5 c0       	breq	8000cde2 <__avr32_f64_mul_op2_subnormal>
8000cd2c:	a1 78       	lsl	r8,0x1
8000cd2e:	5c f9       	rol	r9
8000cd30:	f3 d5 d2 ab 	bfins	r9,r5,0x15,0xb
8000cd34:	e0 47 07 ff 	cp.w	r7,2047
8000cd38:	c7 70       	breq	8000ce26 <__avr32_f64_mul_op_nan_or_inf>
8000cd3a:	e0 46 07 ff 	cp.w	r6,2047
8000cd3e:	c7 40       	breq	8000ce26 <__avr32_f64_mul_op_nan_or_inf>
8000cd40:	ee 06 00 0c 	add	r12,r7,r6
8000cd44:	e0 2c 03 fe 	sub	r12,1022
8000cd48:	f6 08 06 44 	mulu.d	r4,r11,r8
8000cd4c:	f4 09 07 44 	macu.d	r4,r10,r9
8000cd50:	f4 08 06 46 	mulu.d	r6,r10,r8
8000cd54:	f6 09 06 4a 	mulu.d	r10,r11,r9
8000cd58:	08 07       	add	r7,r4
8000cd5a:	f4 05 00 4a 	adc	r10,r10,r5
8000cd5e:	5c 0b       	acr	r11
8000cd60:	ed bb 00 14 	bld	r11,0x14
8000cd64:	c0 50       	breq	8000cd6e <__avr32_f64_mul+0x6a>
8000cd66:	a1 77       	lsl	r7,0x1
8000cd68:	5c fa       	rol	r10
8000cd6a:	5c fb       	rol	r11
8000cd6c:	20 1c       	sub	r12,1
8000cd6e:	58 0c       	cp.w	r12,0
8000cd70:	e0 8a 00 6f 	brle	8000ce4e <__avr32_f64_mul_res_subnormal>
8000cd74:	e0 4c 07 ff 	cp.w	r12,2047
8000cd78:	e0 84 00 9c 	brge	8000ceb0 <__avr32_f64_mul_res_inf>
8000cd7c:	f7 dc d2 8b 	bfins	r11,r12,0x14,0xb
8000cd80:	ed ea 11 f6 	or	r6,r6,r10<<0x1f
8000cd84:	ef e6 12 17 	or	r7,r7,r6>>0x1
8000cd88:	ee 17 80 00 	eorh	r7,0x8000
8000cd8c:	f1 b7 04 20 	satu	r7,0x1
8000cd90:	0e 0a       	add	r10,r7
8000cd92:	5c 0b       	acr	r11
8000cd94:	ed be 00 1f 	bld	lr,0x1f
8000cd98:	ef bb 00 1f 	bst	r11,0x1f
8000cd9c:	d8 22       	popm	r4-r7,pc

8000cd9e <__avr32_f64_mul_op1_subnormal>:
8000cd9e:	e4 1b 00 0f 	andh	r11,0xf
8000cda2:	f4 0c 12 00 	clz	r12,r10
8000cda6:	f6 06 12 00 	clz	r6,r11
8000cdaa:	f7 bc 03 e1 	sublo	r12,-31
8000cdae:	f8 06 17 30 	movlo	r6,r12
8000cdb2:	f7 b6 02 01 	subhs	r6,1
8000cdb6:	e0 46 00 20 	cp.w	r6,32
8000cdba:	c0 d4       	brge	8000cdd4 <__avr32_f64_mul_op1_subnormal+0x36>
8000cdbc:	ec 0c 11 20 	rsub	r12,r6,32
8000cdc0:	f6 06 09 4b 	lsl	r11,r11,r6
8000cdc4:	f4 0c 0a 4c 	lsr	r12,r10,r12
8000cdc8:	18 4b       	or	r11,r12
8000cdca:	f4 06 09 4a 	lsl	r10,r10,r6
8000cdce:	20 b6       	sub	r6,11
8000cdd0:	0c 17       	sub	r7,r6
8000cdd2:	ca ab       	rjmp	8000cd26 <__avr32_f64_mul+0x22>
8000cdd4:	f4 06 09 4b 	lsl	r11,r10,r6
8000cdd8:	c6 40       	breq	8000cea0 <__avr32_f64_mul_res_zero>
8000cdda:	30 0a       	mov	r10,0
8000cddc:	20 b6       	sub	r6,11
8000cdde:	0c 17       	sub	r7,r6
8000cde0:	ca 3b       	rjmp	8000cd26 <__avr32_f64_mul+0x22>

8000cde2 <__avr32_f64_mul_op2_subnormal>:
8000cde2:	e4 19 00 0f 	andh	r9,0xf
8000cde6:	f0 0c 12 00 	clz	r12,r8
8000cdea:	f2 05 12 00 	clz	r5,r9
8000cdee:	f7 bc 03 ea 	sublo	r12,-22
8000cdf2:	f8 05 17 30 	movlo	r5,r12
8000cdf6:	f7 b5 02 0a 	subhs	r5,10
8000cdfa:	e0 45 00 20 	cp.w	r5,32
8000cdfe:	c0 d4       	brge	8000ce18 <__avr32_f64_mul_op2_subnormal+0x36>
8000ce00:	ea 0c 11 20 	rsub	r12,r5,32
8000ce04:	f2 05 09 49 	lsl	r9,r9,r5
8000ce08:	f0 0c 0a 4c 	lsr	r12,r8,r12
8000ce0c:	18 49       	or	r9,r12
8000ce0e:	f0 05 09 48 	lsl	r8,r8,r5
8000ce12:	20 25       	sub	r5,2
8000ce14:	0a 16       	sub	r6,r5
8000ce16:	c8 fb       	rjmp	8000cd34 <__avr32_f64_mul+0x30>
8000ce18:	f0 05 09 49 	lsl	r9,r8,r5
8000ce1c:	c4 20       	breq	8000cea0 <__avr32_f64_mul_res_zero>
8000ce1e:	30 08       	mov	r8,0
8000ce20:	20 25       	sub	r5,2
8000ce22:	0a 16       	sub	r6,r5
8000ce24:	c8 8b       	rjmp	8000cd34 <__avr32_f64_mul+0x30>

8000ce26 <__avr32_f64_mul_op_nan_or_inf>:
8000ce26:	e4 19 00 0f 	andh	r9,0xf
8000ce2a:	e4 1b 00 0f 	andh	r11,0xf
8000ce2e:	14 4b       	or	r11,r10
8000ce30:	10 49       	or	r9,r8
8000ce32:	e0 47 07 ff 	cp.w	r7,2047
8000ce36:	c0 91       	brne	8000ce48 <__avr32_f64_mul_op1_not_naninf>
8000ce38:	58 0b       	cp.w	r11,0
8000ce3a:	c3 81       	brne	8000ceaa <__avr32_f64_mul_res_nan>
8000ce3c:	e0 46 07 ff 	cp.w	r6,2047
8000ce40:	c3 81       	brne	8000ceb0 <__avr32_f64_mul_res_inf>
8000ce42:	58 09       	cp.w	r9,0
8000ce44:	c3 60       	breq	8000ceb0 <__avr32_f64_mul_res_inf>
8000ce46:	c3 28       	rjmp	8000ceaa <__avr32_f64_mul_res_nan>

8000ce48 <__avr32_f64_mul_op1_not_naninf>:
8000ce48:	58 09       	cp.w	r9,0
8000ce4a:	c3 30       	breq	8000ceb0 <__avr32_f64_mul_res_inf>
8000ce4c:	c2 f8       	rjmp	8000ceaa <__avr32_f64_mul_res_nan>

8000ce4e <__avr32_f64_mul_res_subnormal>:
8000ce4e:	5c 3c       	neg	r12
8000ce50:	2f fc       	sub	r12,-1
8000ce52:	f1 bc 04 c0 	satu	r12,0x6
8000ce56:	e0 4c 00 20 	cp.w	r12,32
8000ce5a:	c1 14       	brge	8000ce7c <__avr32_f64_mul_res_subnormal+0x2e>
8000ce5c:	f8 08 11 20 	rsub	r8,r12,32
8000ce60:	0e 46       	or	r6,r7
8000ce62:	ee 0c 0a 47 	lsr	r7,r7,r12
8000ce66:	f4 08 09 49 	lsl	r9,r10,r8
8000ce6a:	12 47       	or	r7,r9
8000ce6c:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000ce70:	f6 08 09 49 	lsl	r9,r11,r8
8000ce74:	12 4a       	or	r10,r9
8000ce76:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000ce7a:	c8 3b       	rjmp	8000cd80 <__avr32_f64_mul+0x7c>
8000ce7c:	f8 08 11 20 	rsub	r8,r12,32
8000ce80:	f9 b9 00 00 	moveq	r9,0
8000ce84:	c0 30       	breq	8000ce8a <__avr32_f64_mul_res_subnormal+0x3c>
8000ce86:	f6 08 09 49 	lsl	r9,r11,r8
8000ce8a:	0e 46       	or	r6,r7
8000ce8c:	ed ea 10 16 	or	r6,r6,r10<<0x1
8000ce90:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000ce94:	f3 ea 10 07 	or	r7,r9,r10
8000ce98:	f6 0c 0a 4a 	lsr	r10,r11,r12
8000ce9c:	30 0b       	mov	r11,0
8000ce9e:	c7 1b       	rjmp	8000cd80 <__avr32_f64_mul+0x7c>

8000cea0 <__avr32_f64_mul_res_zero>:
8000cea0:	1c 9b       	mov	r11,lr
8000cea2:	e6 1b 80 00 	andh	r11,0x8000,COH
8000cea6:	30 0a       	mov	r10,0
8000cea8:	d8 22       	popm	r4-r7,pc

8000ceaa <__avr32_f64_mul_res_nan>:
8000ceaa:	3f fb       	mov	r11,-1
8000ceac:	3f fa       	mov	r10,-1
8000ceae:	d8 22       	popm	r4-r7,pc

8000ceb0 <__avr32_f64_mul_res_inf>:
8000ceb0:	f0 6b 00 00 	mov	r11,-1048576
8000ceb4:	ed be 00 1f 	bld	lr,0x1f
8000ceb8:	ef bb 00 1f 	bst	r11,0x1f
8000cebc:	30 0a       	mov	r10,0
8000cebe:	d8 22       	popm	r4-r7,pc

8000cec0 <__avr32_f64_mul_op1_zero>:
8000cec0:	f7 e9 20 0b 	eor	r11,r11,r9
8000cec4:	e6 1b 80 00 	andh	r11,0x8000,COH
8000cec8:	f9 d9 c2 8b 	bfextu	r12,r9,0x14,0xb
8000cecc:	e0 4c 07 ff 	cp.w	r12,2047
8000ced0:	5e 1c       	retne	r12
8000ced2:	3f fa       	mov	r10,-1
8000ced4:	3f fb       	mov	r11,-1
8000ced6:	5e fc       	retal	r12

8000ced8 <__avr32_f64_sub_from_add>:
8000ced8:	ee 19 80 00 	eorh	r9,0x8000

8000cedc <__avr32_f64_sub>:
8000cedc:	f7 e9 20 0c 	eor	r12,r11,r9
8000cee0:	e0 86 00 ca 	brmi	8000d074 <__avr32_f64_add_from_sub>
8000cee4:	eb cd 40 e0 	pushm	r5-r7,lr
8000cee8:	16 9c       	mov	r12,r11
8000ceea:	e6 1c 80 00 	andh	r12,0x8000,COH
8000ceee:	bf db       	cbr	r11,0x1f
8000cef0:	bf d9       	cbr	r9,0x1f
8000cef2:	10 3a       	cp.w	r10,r8
8000cef4:	f2 0b 13 00 	cpc	r11,r9
8000cef8:	c0 92       	brcc	8000cf0a <__avr32_f64_sub+0x2e>
8000cefa:	16 97       	mov	r7,r11
8000cefc:	12 9b       	mov	r11,r9
8000cefe:	0e 99       	mov	r9,r7
8000cf00:	14 97       	mov	r7,r10
8000cf02:	10 9a       	mov	r10,r8
8000cf04:	0e 98       	mov	r8,r7
8000cf06:	ee 1c 80 00 	eorh	r12,0x8000
8000cf0a:	f6 07 16 14 	lsr	r7,r11,0x14
8000cf0e:	ab 7b       	lsl	r11,0xb
8000cf10:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000cf14:	ab 7a       	lsl	r10,0xb
8000cf16:	bf bb       	sbr	r11,0x1f
8000cf18:	f2 06 16 14 	lsr	r6,r9,0x14
8000cf1c:	c4 40       	breq	8000cfa4 <__avr32_f64_sub_opL_subnormal>
8000cf1e:	ab 79       	lsl	r9,0xb
8000cf20:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000cf24:	ab 78       	lsl	r8,0xb
8000cf26:	bf b9       	sbr	r9,0x1f

8000cf28 <__avr32_f64_sub_opL_subnormal_done>:
8000cf28:	e0 47 07 ff 	cp.w	r7,2047
8000cf2c:	c4 f0       	breq	8000cfca <__avr32_f64_sub_opH_nan_or_inf>
8000cf2e:	0e 26       	rsub	r6,r7
8000cf30:	c1 20       	breq	8000cf54 <__avr32_f64_sub_shift_done>
8000cf32:	ec 05 11 20 	rsub	r5,r6,32
8000cf36:	e0 46 00 20 	cp.w	r6,32
8000cf3a:	c7 c2       	brcc	8000d032 <__avr32_f64_sub_longshift>
8000cf3c:	f0 05 09 4e 	lsl	lr,r8,r5
8000cf40:	f2 05 09 45 	lsl	r5,r9,r5
8000cf44:	f0 06 0a 48 	lsr	r8,r8,r6
8000cf48:	f2 06 0a 49 	lsr	r9,r9,r6
8000cf4c:	0a 48       	or	r8,r5
8000cf4e:	58 0e       	cp.w	lr,0
8000cf50:	5f 1e       	srne	lr
8000cf52:	1c 48       	or	r8,lr

8000cf54 <__avr32_f64_sub_shift_done>:
8000cf54:	10 1a       	sub	r10,r8
8000cf56:	f6 09 01 4b 	sbc	r11,r11,r9
8000cf5a:	f6 06 12 00 	clz	r6,r11
8000cf5e:	c0 e0       	breq	8000cf7a <__avr32_f64_sub_longnormalize_done>
8000cf60:	c7 83       	brcs	8000d050 <__avr32_f64_sub_longnormalize>
8000cf62:	ec 0e 11 20 	rsub	lr,r6,32
8000cf66:	f6 06 09 4b 	lsl	r11,r11,r6
8000cf6a:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000cf6e:	1c 4b       	or	r11,lr
8000cf70:	f4 06 09 4a 	lsl	r10,r10,r6
8000cf74:	0c 17       	sub	r7,r6
8000cf76:	e0 8a 00 39 	brle	8000cfe8 <__avr32_f64_sub_subnormal_result>

8000cf7a <__avr32_f64_sub_longnormalize_done>:
8000cf7a:	f4 09 15 15 	lsl	r9,r10,0x15
8000cf7e:	ab 9a       	lsr	r10,0xb
8000cf80:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000cf84:	ab 9b       	lsr	r11,0xb
8000cf86:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000cf8a:	18 4b       	or	r11,r12

8000cf8c <__avr32_f64_sub_round>:
8000cf8c:	fc 17 80 00 	movh	r7,0x8000
8000cf90:	ed ba 00 00 	bld	r10,0x0
8000cf94:	f7 b7 01 ff 	subne	r7,-1
8000cf98:	0e 39       	cp.w	r9,r7
8000cf9a:	5f 29       	srhs	r9
8000cf9c:	12 0a       	add	r10,r9
8000cf9e:	5c 0b       	acr	r11
8000cfa0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000cfa4 <__avr32_f64_sub_opL_subnormal>:
8000cfa4:	ab 79       	lsl	r9,0xb
8000cfa6:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000cfaa:	ab 78       	lsl	r8,0xb
8000cfac:	f3 e8 10 0e 	or	lr,r9,r8
8000cfb0:	f9 b6 01 01 	movne	r6,1
8000cfb4:	ee 0e 11 00 	rsub	lr,r7,0
8000cfb8:	f9 b7 00 01 	moveq	r7,1
8000cfbc:	ef bb 00 1f 	bst	r11,0x1f
8000cfc0:	f7 ea 10 0e 	or	lr,r11,r10
8000cfc4:	f9 b7 00 00 	moveq	r7,0
8000cfc8:	cb 0b       	rjmp	8000cf28 <__avr32_f64_sub_opL_subnormal_done>

8000cfca <__avr32_f64_sub_opH_nan_or_inf>:
8000cfca:	bf db       	cbr	r11,0x1f
8000cfcc:	f7 ea 10 0e 	or	lr,r11,r10
8000cfd0:	c0 81       	brne	8000cfe0 <__avr32_f64_sub_return_nan>
8000cfd2:	e0 46 07 ff 	cp.w	r6,2047
8000cfd6:	c0 50       	breq	8000cfe0 <__avr32_f64_sub_return_nan>
8000cfd8:	f9 e7 11 4b 	or	r11,r12,r7<<0x14
8000cfdc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000cfe0 <__avr32_f64_sub_return_nan>:
8000cfe0:	3f fa       	mov	r10,-1
8000cfe2:	3f fb       	mov	r11,-1
8000cfe4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000cfe8 <__avr32_f64_sub_subnormal_result>:
8000cfe8:	5c 37       	neg	r7
8000cfea:	2f f7       	sub	r7,-1
8000cfec:	f1 b7 04 c0 	satu	r7,0x6
8000cff0:	e0 47 00 20 	cp.w	r7,32
8000cff4:	c1 14       	brge	8000d016 <__avr32_f64_sub_subnormal_result+0x2e>
8000cff6:	ee 08 11 20 	rsub	r8,r7,32
8000cffa:	f4 08 09 49 	lsl	r9,r10,r8
8000cffe:	5f 16       	srne	r6
8000d000:	f4 07 0a 4a 	lsr	r10,r10,r7
8000d004:	0c 4a       	or	r10,r6
8000d006:	f6 08 09 49 	lsl	r9,r11,r8
8000d00a:	f5 e9 10 0a 	or	r10,r10,r9
8000d00e:	f4 07 0a 4b 	lsr	r11,r10,r7
8000d012:	30 07       	mov	r7,0
8000d014:	cb 3b       	rjmp	8000cf7a <__avr32_f64_sub_longnormalize_done>
8000d016:	ee 08 11 40 	rsub	r8,r7,64
8000d01a:	f6 08 09 49 	lsl	r9,r11,r8
8000d01e:	14 49       	or	r9,r10
8000d020:	5f 16       	srne	r6
8000d022:	f6 07 0a 4a 	lsr	r10,r11,r7
8000d026:	0c 4a       	or	r10,r6
8000d028:	30 0b       	mov	r11,0
8000d02a:	30 07       	mov	r7,0
8000d02c:	ca 7b       	rjmp	8000cf7a <__avr32_f64_sub_longnormalize_done>
8000d02e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000d032 <__avr32_f64_sub_longshift>:
8000d032:	f1 b6 04 c0 	satu	r6,0x6
8000d036:	f0 0e 17 00 	moveq	lr,r8
8000d03a:	c0 40       	breq	8000d042 <__avr32_f64_sub_longshift+0x10>
8000d03c:	f2 05 09 4e 	lsl	lr,r9,r5
8000d040:	10 4e       	or	lr,r8
8000d042:	f2 06 0a 48 	lsr	r8,r9,r6
8000d046:	30 09       	mov	r9,0
8000d048:	58 0e       	cp.w	lr,0
8000d04a:	5f 1e       	srne	lr
8000d04c:	1c 48       	or	r8,lr
8000d04e:	c8 3b       	rjmp	8000cf54 <__avr32_f64_sub_shift_done>

8000d050 <__avr32_f64_sub_longnormalize>:
8000d050:	f4 06 12 00 	clz	r6,r10
8000d054:	f9 b7 03 00 	movlo	r7,0
8000d058:	f9 b6 03 00 	movlo	r6,0
8000d05c:	f9 bc 03 00 	movlo	r12,0
8000d060:	f7 b6 02 e0 	subhs	r6,-32
8000d064:	f4 06 09 4b 	lsl	r11,r10,r6
8000d068:	30 0a       	mov	r10,0
8000d06a:	0c 17       	sub	r7,r6
8000d06c:	fe 9a ff be 	brle	8000cfe8 <__avr32_f64_sub_subnormal_result>
8000d070:	c8 5b       	rjmp	8000cf7a <__avr32_f64_sub_longnormalize_done>
8000d072:	d7 03       	nop

8000d074 <__avr32_f64_add_from_sub>:
8000d074:	ee 19 80 00 	eorh	r9,0x8000

8000d078 <__avr32_f64_add>:
8000d078:	f7 e9 20 0c 	eor	r12,r11,r9
8000d07c:	fe 96 ff 2e 	brmi	8000ced8 <__avr32_f64_sub_from_add>
8000d080:	eb cd 40 e0 	pushm	r5-r7,lr
8000d084:	16 9c       	mov	r12,r11
8000d086:	e6 1c 80 00 	andh	r12,0x8000,COH
8000d08a:	bf db       	cbr	r11,0x1f
8000d08c:	bf d9       	cbr	r9,0x1f
8000d08e:	12 3b       	cp.w	r11,r9
8000d090:	c0 72       	brcc	8000d09e <__avr32_f64_add+0x26>
8000d092:	16 97       	mov	r7,r11
8000d094:	12 9b       	mov	r11,r9
8000d096:	0e 99       	mov	r9,r7
8000d098:	14 97       	mov	r7,r10
8000d09a:	10 9a       	mov	r10,r8
8000d09c:	0e 98       	mov	r8,r7
8000d09e:	30 0e       	mov	lr,0
8000d0a0:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000d0a4:	f7 db c0 14 	bfextu	r11,r11,0x0,0x14
8000d0a8:	b5 ab       	sbr	r11,0x14
8000d0aa:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000d0ae:	c6 20       	breq	8000d172 <__avr32_f64_add_op2_subnormal>
8000d0b0:	f3 d9 c0 14 	bfextu	r9,r9,0x0,0x14
8000d0b4:	b5 a9       	sbr	r9,0x14
8000d0b6:	e0 47 07 ff 	cp.w	r7,2047
8000d0ba:	c2 80       	breq	8000d10a <__avr32_f64_add_opH_nan_or_inf>
8000d0bc:	0e 26       	rsub	r6,r7
8000d0be:	c1 20       	breq	8000d0e2 <__avr32_f64_add_shift_done>
8000d0c0:	e0 46 00 36 	cp.w	r6,54
8000d0c4:	c1 52       	brcc	8000d0ee <__avr32_f64_add_res_of_done>
8000d0c6:	ec 05 11 20 	rsub	r5,r6,32
8000d0ca:	e0 46 00 20 	cp.w	r6,32
8000d0ce:	c3 52       	brcc	8000d138 <__avr32_f64_add_longshift>
8000d0d0:	f0 05 09 4e 	lsl	lr,r8,r5
8000d0d4:	f2 05 09 45 	lsl	r5,r9,r5
8000d0d8:	f0 06 0a 48 	lsr	r8,r8,r6
8000d0dc:	f2 06 0a 49 	lsr	r9,r9,r6
8000d0e0:	0a 48       	or	r8,r5

8000d0e2 <__avr32_f64_add_shift_done>:
8000d0e2:	10 0a       	add	r10,r8
8000d0e4:	f6 09 00 4b 	adc	r11,r11,r9
8000d0e8:	ed bb 00 15 	bld	r11,0x15
8000d0ec:	c3 40       	breq	8000d154 <__avr32_f64_add_res_of>

8000d0ee <__avr32_f64_add_res_of_done>:
8000d0ee:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000d0f2:	18 4b       	or	r11,r12

8000d0f4 <__avr32_f64_add_round>:
8000d0f4:	f9 da c0 01 	bfextu	r12,r10,0x0,0x1
8000d0f8:	18 4e       	or	lr,r12
8000d0fa:	ee 1e 80 00 	eorh	lr,0x8000
8000d0fe:	f1 be 04 20 	satu	lr,0x1
8000d102:	1c 0a       	add	r10,lr
8000d104:	5c 0b       	acr	r11
8000d106:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000d10a <__avr32_f64_add_opH_nan_or_inf>:
8000d10a:	b5 cb       	cbr	r11,0x14
8000d10c:	f7 ea 10 0e 	or	lr,r11,r10
8000d110:	c1 01       	brne	8000d130 <__avr32_f64_add_return_nan>
8000d112:	e0 46 07 ff 	cp.w	r6,2047
8000d116:	c0 30       	breq	8000d11c <__avr32_f64_add_opL_nan_or_inf>
8000d118:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000d11c <__avr32_f64_add_opL_nan_or_inf>:
8000d11c:	b5 c9       	cbr	r9,0x14
8000d11e:	f3 e8 10 0e 	or	lr,r9,r8
8000d122:	c0 71       	brne	8000d130 <__avr32_f64_add_return_nan>
8000d124:	30 0a       	mov	r10,0
8000d126:	fc 1b 7f f0 	movh	r11,0x7ff0
8000d12a:	18 4b       	or	r11,r12
8000d12c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000d130 <__avr32_f64_add_return_nan>:
8000d130:	3f fa       	mov	r10,-1
8000d132:	3f fb       	mov	r11,-1
8000d134:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000d138 <__avr32_f64_add_longshift>:
8000d138:	f1 b6 04 c0 	satu	r6,0x6
8000d13c:	f0 0e 17 00 	moveq	lr,r8
8000d140:	c0 60       	breq	8000d14c <__avr32_f64_add_longshift+0x14>
8000d142:	f2 05 09 4e 	lsl	lr,r9,r5
8000d146:	58 08       	cp.w	r8,0
8000d148:	5f 18       	srne	r8
8000d14a:	10 4e       	or	lr,r8
8000d14c:	f2 06 0a 48 	lsr	r8,r9,r6
8000d150:	30 09       	mov	r9,0
8000d152:	cc 8b       	rjmp	8000d0e2 <__avr32_f64_add_shift_done>

8000d154 <__avr32_f64_add_res_of>:
8000d154:	fd ee 10 1e 	or	lr,lr,lr<<0x1
8000d158:	a1 9b       	lsr	r11,0x1
8000d15a:	5d 0a       	ror	r10
8000d15c:	5d 0e       	ror	lr
8000d15e:	2f f7       	sub	r7,-1
8000d160:	e0 47 07 ff 	cp.w	r7,2047
8000d164:	f9 ba 00 00 	moveq	r10,0
8000d168:	f9 bb 00 00 	moveq	r11,0
8000d16c:	f9 be 00 00 	moveq	lr,0
8000d170:	cb fb       	rjmp	8000d0ee <__avr32_f64_add_res_of_done>

8000d172 <__avr32_f64_add_op2_subnormal>:
8000d172:	30 16       	mov	r6,1
8000d174:	58 07       	cp.w	r7,0
8000d176:	ca 01       	brne	8000d0b6 <__avr32_f64_add+0x3e>
8000d178:	b5 cb       	cbr	r11,0x14
8000d17a:	10 0a       	add	r10,r8
8000d17c:	f6 09 00 4b 	adc	r11,r11,r9
8000d180:	18 4b       	or	r11,r12
8000d182:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000d186:	d7 03       	nop

8000d188 <__avr32_f64_to_u32>:
8000d188:	58 0b       	cp.w	r11,0
8000d18a:	5e 6d       	retmi	0

8000d18c <__avr32_f64_to_s32>:
8000d18c:	f6 0c 15 01 	lsl	r12,r11,0x1
8000d190:	b5 9c       	lsr	r12,0x15
8000d192:	e0 2c 03 ff 	sub	r12,1023
8000d196:	5e 3d       	retlo	0
8000d198:	f8 0c 11 1f 	rsub	r12,r12,31
8000d19c:	16 99       	mov	r9,r11
8000d19e:	ab 7b       	lsl	r11,0xb
8000d1a0:	bf bb       	sbr	r11,0x1f
8000d1a2:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000d1a6:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000d1aa:	a1 79       	lsl	r9,0x1
8000d1ac:	5e 2b       	reths	r11
8000d1ae:	5c 3b       	neg	r11
8000d1b0:	5e fb       	retal	r11

8000d1b2 <__avr32_u32_to_f64>:
8000d1b2:	f8 cb 00 00 	sub	r11,r12,0
8000d1b6:	30 0c       	mov	r12,0
8000d1b8:	c0 38       	rjmp	8000d1be <__avr32_s32_to_f64+0x4>

8000d1ba <__avr32_s32_to_f64>:
8000d1ba:	18 9b       	mov	r11,r12
8000d1bc:	5c 4b       	abs	r11
8000d1be:	30 0a       	mov	r10,0
8000d1c0:	5e 0b       	reteq	r11
8000d1c2:	d4 01       	pushm	lr
8000d1c4:	e0 69 04 1e 	mov	r9,1054
8000d1c8:	f6 08 12 00 	clz	r8,r11
8000d1cc:	c1 70       	breq	8000d1fa <__avr32_s32_to_f64+0x40>
8000d1ce:	c0 c3       	brcs	8000d1e6 <__avr32_s32_to_f64+0x2c>
8000d1d0:	f0 0e 11 20 	rsub	lr,r8,32
8000d1d4:	f6 08 09 4b 	lsl	r11,r11,r8
8000d1d8:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000d1dc:	1c 4b       	or	r11,lr
8000d1de:	f4 08 09 4a 	lsl	r10,r10,r8
8000d1e2:	10 19       	sub	r9,r8
8000d1e4:	c0 b8       	rjmp	8000d1fa <__avr32_s32_to_f64+0x40>
8000d1e6:	f4 08 12 00 	clz	r8,r10
8000d1ea:	f9 b8 03 00 	movlo	r8,0
8000d1ee:	f7 b8 02 e0 	subhs	r8,-32
8000d1f2:	f4 08 09 4b 	lsl	r11,r10,r8
8000d1f6:	30 0a       	mov	r10,0
8000d1f8:	10 19       	sub	r9,r8
8000d1fa:	58 09       	cp.w	r9,0
8000d1fc:	e0 89 00 30 	brgt	8000d25c <__avr32_s32_to_f64+0xa2>
8000d200:	5c 39       	neg	r9
8000d202:	2f f9       	sub	r9,-1
8000d204:	e0 49 00 36 	cp.w	r9,54
8000d208:	c0 43       	brcs	8000d210 <__avr32_s32_to_f64+0x56>
8000d20a:	30 0b       	mov	r11,0
8000d20c:	30 0a       	mov	r10,0
8000d20e:	c2 68       	rjmp	8000d25a <__avr32_s32_to_f64+0xa0>
8000d210:	2f 69       	sub	r9,-10
8000d212:	f2 08 11 20 	rsub	r8,r9,32
8000d216:	e0 49 00 20 	cp.w	r9,32
8000d21a:	c0 b2       	brcc	8000d230 <__avr32_s32_to_f64+0x76>
8000d21c:	f4 08 09 4e 	lsl	lr,r10,r8
8000d220:	f6 08 09 48 	lsl	r8,r11,r8
8000d224:	f4 09 0a 4a 	lsr	r10,r10,r9
8000d228:	f6 09 0a 4b 	lsr	r11,r11,r9
8000d22c:	10 4b       	or	r11,r8
8000d22e:	c0 88       	rjmp	8000d23e <__avr32_s32_to_f64+0x84>
8000d230:	f6 08 09 4e 	lsl	lr,r11,r8
8000d234:	14 4e       	or	lr,r10
8000d236:	16 9a       	mov	r10,r11
8000d238:	30 0b       	mov	r11,0
8000d23a:	f4 09 0a 4a 	lsr	r10,r10,r9
8000d23e:	ed ba 00 00 	bld	r10,0x0
8000d242:	c0 92       	brcc	8000d254 <__avr32_s32_to_f64+0x9a>
8000d244:	1c 7e       	tst	lr,lr
8000d246:	c0 41       	brne	8000d24e <__avr32_s32_to_f64+0x94>
8000d248:	ed ba 00 01 	bld	r10,0x1
8000d24c:	c0 42       	brcc	8000d254 <__avr32_s32_to_f64+0x9a>
8000d24e:	2f fa       	sub	r10,-1
8000d250:	f7 bb 02 ff 	subhs	r11,-1
8000d254:	5c fc       	rol	r12
8000d256:	5d 0b       	ror	r11
8000d258:	5d 0a       	ror	r10
8000d25a:	d8 02       	popm	pc
8000d25c:	e0 68 03 ff 	mov	r8,1023
8000d260:	ed ba 00 0b 	bld	r10,0xb
8000d264:	f7 b8 00 ff 	subeq	r8,-1
8000d268:	10 0a       	add	r10,r8
8000d26a:	5c 0b       	acr	r11
8000d26c:	f7 b9 03 fe 	sublo	r9,-2
8000d270:	e0 49 07 ff 	cp.w	r9,2047
8000d274:	c0 55       	brlt	8000d27e <__avr32_s32_to_f64+0xc4>
8000d276:	30 0a       	mov	r10,0
8000d278:	fc 1b ff e0 	movh	r11,0xffe0
8000d27c:	c0 c8       	rjmp	8000d294 <__floatsidf_return_op1>
8000d27e:	ed bb 00 1f 	bld	r11,0x1f
8000d282:	f7 b9 01 01 	subne	r9,1
8000d286:	ab 9a       	lsr	r10,0xb
8000d288:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000d28c:	a1 7b       	lsl	r11,0x1
8000d28e:	ab 9b       	lsr	r11,0xb
8000d290:	f7 e9 11 5b 	or	r11,r11,r9<<0x15

8000d294 <__floatsidf_return_op1>:
8000d294:	a1 7c       	lsl	r12,0x1
8000d296:	5d 0b       	ror	r11
8000d298:	d8 02       	popm	pc

8000d29a <__avr32_f64_cmp_eq>:
8000d29a:	10 3a       	cp.w	r10,r8
8000d29c:	f2 0b 13 00 	cpc	r11,r9
8000d2a0:	c0 80       	breq	8000d2b0 <__avr32_f64_cmp_eq+0x16>
8000d2a2:	a1 7b       	lsl	r11,0x1
8000d2a4:	a1 79       	lsl	r9,0x1
8000d2a6:	14 4b       	or	r11,r10
8000d2a8:	12 4b       	or	r11,r9
8000d2aa:	10 4b       	or	r11,r8
8000d2ac:	5e 0f       	reteq	1
8000d2ae:	5e fd       	retal	0
8000d2b0:	a1 7b       	lsl	r11,0x1
8000d2b2:	fc 1c ff e0 	movh	r12,0xffe0
8000d2b6:	58 0a       	cp.w	r10,0
8000d2b8:	f8 0b 13 00 	cpc	r11,r12
8000d2bc:	5e 8f       	retls	1
8000d2be:	5e fd       	retal	0

8000d2c0 <__avr32_f64_cmp_ge>:
8000d2c0:	1a de       	st.w	--sp,lr
8000d2c2:	1a d7       	st.w	--sp,r7
8000d2c4:	a1 7b       	lsl	r11,0x1
8000d2c6:	5f 3c       	srlo	r12
8000d2c8:	a1 79       	lsl	r9,0x1
8000d2ca:	5f 37       	srlo	r7
8000d2cc:	5c fc       	rol	r12
8000d2ce:	fc 1e ff e0 	movh	lr,0xffe0
8000d2d2:	58 0a       	cp.w	r10,0
8000d2d4:	fc 0b 13 00 	cpc	r11,lr
8000d2d8:	e0 8b 00 1d 	brhi	8000d312 <__avr32_f64_cmp_ge+0x52>
8000d2dc:	58 08       	cp.w	r8,0
8000d2de:	fc 09 13 00 	cpc	r9,lr
8000d2e2:	e0 8b 00 18 	brhi	8000d312 <__avr32_f64_cmp_ge+0x52>
8000d2e6:	58 0b       	cp.w	r11,0
8000d2e8:	f5 ba 00 00 	subfeq	r10,0
8000d2ec:	c1 50       	breq	8000d316 <__avr32_f64_cmp_ge+0x56>
8000d2ee:	1b 07       	ld.w	r7,sp++
8000d2f0:	1b 0e       	ld.w	lr,sp++
8000d2f2:	58 3c       	cp.w	r12,3
8000d2f4:	c0 a0       	breq	8000d308 <__avr32_f64_cmp_ge+0x48>
8000d2f6:	58 1c       	cp.w	r12,1
8000d2f8:	c0 33       	brcs	8000d2fe <__avr32_f64_cmp_ge+0x3e>
8000d2fa:	5e 0f       	reteq	1
8000d2fc:	5e 1d       	retne	0
8000d2fe:	10 3a       	cp.w	r10,r8
8000d300:	f2 0b 13 00 	cpc	r11,r9
8000d304:	5e 2f       	reths	1
8000d306:	5e 3d       	retlo	0
8000d308:	14 38       	cp.w	r8,r10
8000d30a:	f6 09 13 00 	cpc	r9,r11
8000d30e:	5e 2f       	reths	1
8000d310:	5e 3d       	retlo	0
8000d312:	1b 07       	ld.w	r7,sp++
8000d314:	d8 0a       	popm	pc,r12=0
8000d316:	58 17       	cp.w	r7,1
8000d318:	5f 0c       	sreq	r12
8000d31a:	58 09       	cp.w	r9,0
8000d31c:	f5 b8 00 00 	subfeq	r8,0
8000d320:	1b 07       	ld.w	r7,sp++
8000d322:	1b 0e       	ld.w	lr,sp++
8000d324:	5e 0f       	reteq	1
8000d326:	5e fc       	retal	r12

8000d328 <__avr32_f64_cmp_lt>:
8000d328:	1a de       	st.w	--sp,lr
8000d32a:	1a d7       	st.w	--sp,r7
8000d32c:	a1 7b       	lsl	r11,0x1
8000d32e:	5f 3c       	srlo	r12
8000d330:	a1 79       	lsl	r9,0x1
8000d332:	5f 37       	srlo	r7
8000d334:	5c fc       	rol	r12
8000d336:	fc 1e ff e0 	movh	lr,0xffe0
8000d33a:	58 0a       	cp.w	r10,0
8000d33c:	fc 0b 13 00 	cpc	r11,lr
8000d340:	e0 8b 00 1d 	brhi	8000d37a <__avr32_f64_cmp_lt+0x52>
8000d344:	58 08       	cp.w	r8,0
8000d346:	fc 09 13 00 	cpc	r9,lr
8000d34a:	e0 8b 00 18 	brhi	8000d37a <__avr32_f64_cmp_lt+0x52>
8000d34e:	58 0b       	cp.w	r11,0
8000d350:	f5 ba 00 00 	subfeq	r10,0
8000d354:	c1 50       	breq	8000d37e <__avr32_f64_cmp_lt+0x56>
8000d356:	1b 07       	ld.w	r7,sp++
8000d358:	1b 0e       	ld.w	lr,sp++
8000d35a:	58 3c       	cp.w	r12,3
8000d35c:	c0 a0       	breq	8000d370 <__avr32_f64_cmp_lt+0x48>
8000d35e:	58 1c       	cp.w	r12,1
8000d360:	c0 33       	brcs	8000d366 <__avr32_f64_cmp_lt+0x3e>
8000d362:	5e 0d       	reteq	0
8000d364:	5e 1f       	retne	1
8000d366:	10 3a       	cp.w	r10,r8
8000d368:	f2 0b 13 00 	cpc	r11,r9
8000d36c:	5e 2d       	reths	0
8000d36e:	5e 3f       	retlo	1
8000d370:	14 38       	cp.w	r8,r10
8000d372:	f6 09 13 00 	cpc	r9,r11
8000d376:	5e 2d       	reths	0
8000d378:	5e 3f       	retlo	1
8000d37a:	1b 07       	ld.w	r7,sp++
8000d37c:	d8 0a       	popm	pc,r12=0
8000d37e:	58 17       	cp.w	r7,1
8000d380:	5f 1c       	srne	r12
8000d382:	58 09       	cp.w	r9,0
8000d384:	f5 b8 00 00 	subfeq	r8,0
8000d388:	1b 07       	ld.w	r7,sp++
8000d38a:	1b 0e       	ld.w	lr,sp++
8000d38c:	5e 0d       	reteq	0
8000d38e:	5e fc       	retal	r12

8000d390 <__avr32_f64_div>:
8000d390:	eb cd 40 ff 	pushm	r0-r7,lr
8000d394:	f7 e9 20 0e 	eor	lr,r11,r9
8000d398:	f6 07 16 14 	lsr	r7,r11,0x14
8000d39c:	a9 7b       	lsl	r11,0x9
8000d39e:	f7 ea 13 7b 	or	r11,r11,r10>>0x17
8000d3a2:	a9 7a       	lsl	r10,0x9
8000d3a4:	bd bb       	sbr	r11,0x1d
8000d3a6:	e4 1b 3f ff 	andh	r11,0x3fff
8000d3aa:	ab d7       	cbr	r7,0xb
8000d3ac:	e0 80 00 cc 	breq	8000d544 <__avr32_f64_div_round_subnormal+0x54>
8000d3b0:	e0 47 07 ff 	cp.w	r7,2047
8000d3b4:	e0 84 00 b5 	brge	8000d51e <__avr32_f64_div_round_subnormal+0x2e>
8000d3b8:	f2 06 16 14 	lsr	r6,r9,0x14
8000d3bc:	a9 79       	lsl	r9,0x9
8000d3be:	f3 e8 13 79 	or	r9,r9,r8>>0x17
8000d3c2:	a9 78       	lsl	r8,0x9
8000d3c4:	bd b9       	sbr	r9,0x1d
8000d3c6:	e4 19 3f ff 	andh	r9,0x3fff
8000d3ca:	ab d6       	cbr	r6,0xb
8000d3cc:	e0 80 00 e2 	breq	8000d590 <__avr32_f64_div_round_subnormal+0xa0>
8000d3d0:	e0 46 07 ff 	cp.w	r6,2047
8000d3d4:	e0 84 00 b2 	brge	8000d538 <__avr32_f64_div_round_subnormal+0x48>
8000d3d8:	0c 17       	sub	r7,r6
8000d3da:	fe 37 fc 01 	sub	r7,-1023
8000d3de:	fc 1c 80 00 	movh	r12,0x8000
8000d3e2:	f8 03 16 01 	lsr	r3,r12,0x1
8000d3e6:	e9 d9 c3 62 	bfextu	r4,r9,0x1b,0x2
8000d3ea:	5c d4       	com	r4
8000d3ec:	e7 d4 d3 82 	bfins	r3,r4,0x1c,0x2
8000d3f0:	e6 09 06 44 	mulu.d	r4,r3,r9
8000d3f4:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000d3f8:	e6 05 06 44 	mulu.d	r4,r3,r5
8000d3fc:	ea 03 15 02 	lsl	r3,r5,0x2
8000d400:	e6 09 06 44 	mulu.d	r4,r3,r9
8000d404:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000d408:	e6 05 06 44 	mulu.d	r4,r3,r5
8000d40c:	ea 03 15 02 	lsl	r3,r5,0x2
8000d410:	e6 09 06 44 	mulu.d	r4,r3,r9
8000d414:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000d418:	e6 05 06 44 	mulu.d	r4,r3,r5
8000d41c:	ea 03 15 02 	lsl	r3,r5,0x2
8000d420:	e6 08 06 40 	mulu.d	r0,r3,r8
8000d424:	e4 09 07 40 	macu.d	r0,r2,r9
8000d428:	e6 09 06 44 	mulu.d	r4,r3,r9
8000d42c:	02 04       	add	r4,r1
8000d42e:	5c 05       	acr	r5
8000d430:	a3 65       	lsl	r5,0x2
8000d432:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000d436:	a3 64       	lsl	r4,0x2
8000d438:	5c 34       	neg	r4
8000d43a:	f8 05 01 45 	sbc	r5,r12,r5
8000d43e:	e6 04 06 40 	mulu.d	r0,r3,r4
8000d442:	e4 05 07 40 	macu.d	r0,r2,r5
8000d446:	e6 05 06 44 	mulu.d	r4,r3,r5
8000d44a:	02 04       	add	r4,r1
8000d44c:	5c 05       	acr	r5
8000d44e:	ea 03 15 02 	lsl	r3,r5,0x2
8000d452:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000d456:	e8 02 15 02 	lsl	r2,r4,0x2
8000d45a:	e6 08 06 40 	mulu.d	r0,r3,r8
8000d45e:	e4 09 07 40 	macu.d	r0,r2,r9
8000d462:	e6 09 06 44 	mulu.d	r4,r3,r9
8000d466:	02 04       	add	r4,r1
8000d468:	5c 05       	acr	r5
8000d46a:	a3 65       	lsl	r5,0x2
8000d46c:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000d470:	a3 64       	lsl	r4,0x2
8000d472:	5c 34       	neg	r4
8000d474:	f8 05 01 45 	sbc	r5,r12,r5
8000d478:	e6 04 06 40 	mulu.d	r0,r3,r4
8000d47c:	e4 05 07 40 	macu.d	r0,r2,r5
8000d480:	e6 05 06 44 	mulu.d	r4,r3,r5
8000d484:	02 04       	add	r4,r1
8000d486:	5c 05       	acr	r5
8000d488:	ea 03 15 02 	lsl	r3,r5,0x2
8000d48c:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000d490:	e8 02 15 02 	lsl	r2,r4,0x2
8000d494:	e6 0a 06 40 	mulu.d	r0,r3,r10
8000d498:	e4 0b 07 40 	macu.d	r0,r2,r11
8000d49c:	e6 0b 06 42 	mulu.d	r2,r3,r11
8000d4a0:	02 02       	add	r2,r1
8000d4a2:	5c 03       	acr	r3
8000d4a4:	ed b3 00 1c 	bld	r3,0x1c
8000d4a8:	c0 90       	breq	8000d4ba <__avr32_f64_div+0x12a>
8000d4aa:	a1 72       	lsl	r2,0x1
8000d4ac:	5c f3       	rol	r3
8000d4ae:	20 17       	sub	r7,1
8000d4b0:	a3 9a       	lsr	r10,0x3
8000d4b2:	f5 eb 11 da 	or	r10,r10,r11<<0x1d
8000d4b6:	a3 9b       	lsr	r11,0x3
8000d4b8:	c0 58       	rjmp	8000d4c2 <__avr32_f64_div+0x132>
8000d4ba:	a5 8a       	lsr	r10,0x4
8000d4bc:	f5 eb 11 ca 	or	r10,r10,r11<<0x1c
8000d4c0:	a5 8b       	lsr	r11,0x4
8000d4c2:	58 07       	cp.w	r7,0
8000d4c4:	e0 8a 00 8b 	brle	8000d5da <__avr32_f64_div_res_subnormal>
8000d4c8:	e0 12 ff 00 	andl	r2,0xff00
8000d4cc:	e8 12 00 80 	orl	r2,0x80
8000d4d0:	e6 08 06 40 	mulu.d	r0,r3,r8
8000d4d4:	e4 09 07 40 	macu.d	r0,r2,r9
8000d4d8:	e4 08 06 44 	mulu.d	r4,r2,r8
8000d4dc:	e6 09 06 48 	mulu.d	r8,r3,r9
8000d4e0:	00 05       	add	r5,r0
8000d4e2:	f0 01 00 48 	adc	r8,r8,r1
8000d4e6:	5c 09       	acr	r9
8000d4e8:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000d4ec:	58 04       	cp.w	r4,0
8000d4ee:	5c 25       	cpc	r5

8000d4f0 <__avr32_f64_div_round_subnormal>:
8000d4f0:	f4 08 13 00 	cpc	r8,r10
8000d4f4:	f6 09 13 00 	cpc	r9,r11
8000d4f8:	5f 36       	srlo	r6
8000d4fa:	f8 06 17 00 	moveq	r6,r12
8000d4fe:	e4 0a 16 08 	lsr	r10,r2,0x8
8000d502:	f5 e3 11 8a 	or	r10,r10,r3<<0x18
8000d506:	e6 0b 16 08 	lsr	r11,r3,0x8
8000d50a:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000d50e:	ed be 00 1f 	bld	lr,0x1f
8000d512:	ef bb 00 1f 	bst	r11,0x1f
8000d516:	0c 0a       	add	r10,r6
8000d518:	5c 0b       	acr	r11
8000d51a:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000d51e:	e4 1b 00 0f 	andh	r11,0xf
8000d522:	14 4b       	or	r11,r10
8000d524:	e0 81 00 a7 	brne	8000d672 <__avr32_f64_div_res_subnormal+0x98>
8000d528:	f2 06 16 14 	lsr	r6,r9,0x14
8000d52c:	ab d6       	cbr	r6,0xb
8000d52e:	e0 46 07 ff 	cp.w	r6,2047
8000d532:	e0 81 00 a4 	brne	8000d67a <__avr32_f64_div_res_subnormal+0xa0>
8000d536:	c9 e8       	rjmp	8000d672 <__avr32_f64_div_res_subnormal+0x98>
8000d538:	e4 19 00 0f 	andh	r9,0xf
8000d53c:	10 49       	or	r9,r8
8000d53e:	e0 81 00 9a 	brne	8000d672 <__avr32_f64_div_res_subnormal+0x98>
8000d542:	c9 28       	rjmp	8000d666 <__avr32_f64_div_res_subnormal+0x8c>
8000d544:	a3 7b       	lsl	r11,0x3
8000d546:	f7 ea 13 db 	or	r11,r11,r10>>0x1d
8000d54a:	a3 7a       	lsl	r10,0x3
8000d54c:	f5 eb 10 04 	or	r4,r10,r11
8000d550:	e0 80 00 a0 	breq	8000d690 <__avr32_f64_div_op1_zero>
8000d554:	f6 04 12 00 	clz	r4,r11
8000d558:	c1 70       	breq	8000d586 <__avr32_f64_div_round_subnormal+0x96>
8000d55a:	c0 c3       	brcs	8000d572 <__avr32_f64_div_round_subnormal+0x82>
8000d55c:	e8 05 11 20 	rsub	r5,r4,32
8000d560:	f6 04 09 4b 	lsl	r11,r11,r4
8000d564:	f4 05 0a 45 	lsr	r5,r10,r5
8000d568:	0a 4b       	or	r11,r5
8000d56a:	f4 04 09 4a 	lsl	r10,r10,r4
8000d56e:	08 17       	sub	r7,r4
8000d570:	c0 b8       	rjmp	8000d586 <__avr32_f64_div_round_subnormal+0x96>
8000d572:	f4 04 12 00 	clz	r4,r10
8000d576:	f9 b4 03 00 	movlo	r4,0
8000d57a:	f7 b4 02 e0 	subhs	r4,-32
8000d57e:	f4 04 09 4b 	lsl	r11,r10,r4
8000d582:	30 0a       	mov	r10,0
8000d584:	08 17       	sub	r7,r4
8000d586:	a3 8a       	lsr	r10,0x2
8000d588:	f5 eb 11 ea 	or	r10,r10,r11<<0x1e
8000d58c:	a3 8b       	lsr	r11,0x2
8000d58e:	c1 1b       	rjmp	8000d3b0 <__avr32_f64_div+0x20>
8000d590:	a3 79       	lsl	r9,0x3
8000d592:	f3 e8 13 d9 	or	r9,r9,r8>>0x1d
8000d596:	a3 78       	lsl	r8,0x3
8000d598:	f3 e8 10 04 	or	r4,r9,r8
8000d59c:	c6 f0       	breq	8000d67a <__avr32_f64_div_res_subnormal+0xa0>
8000d59e:	f2 04 12 00 	clz	r4,r9
8000d5a2:	c1 70       	breq	8000d5d0 <__avr32_f64_div_round_subnormal+0xe0>
8000d5a4:	c0 c3       	brcs	8000d5bc <__avr32_f64_div_round_subnormal+0xcc>
8000d5a6:	e8 05 11 20 	rsub	r5,r4,32
8000d5aa:	f2 04 09 49 	lsl	r9,r9,r4
8000d5ae:	f0 05 0a 45 	lsr	r5,r8,r5
8000d5b2:	0a 49       	or	r9,r5
8000d5b4:	f0 04 09 48 	lsl	r8,r8,r4
8000d5b8:	08 16       	sub	r6,r4
8000d5ba:	c0 b8       	rjmp	8000d5d0 <__avr32_f64_div_round_subnormal+0xe0>
8000d5bc:	f0 04 12 00 	clz	r4,r8
8000d5c0:	f9 b4 03 00 	movlo	r4,0
8000d5c4:	f7 b4 02 e0 	subhs	r4,-32
8000d5c8:	f0 04 09 49 	lsl	r9,r8,r4
8000d5cc:	30 08       	mov	r8,0
8000d5ce:	08 16       	sub	r6,r4
8000d5d0:	a3 88       	lsr	r8,0x2
8000d5d2:	f1 e9 11 e8 	or	r8,r8,r9<<0x1e
8000d5d6:	a3 89       	lsr	r9,0x2
8000d5d8:	cf ca       	rjmp	8000d3d0 <__avr32_f64_div+0x40>

8000d5da <__avr32_f64_div_res_subnormal>:
8000d5da:	5c 37       	neg	r7
8000d5dc:	2f f7       	sub	r7,-1
8000d5de:	f1 b7 04 c0 	satu	r7,0x6
8000d5e2:	e0 47 00 20 	cp.w	r7,32
8000d5e6:	c1 54       	brge	8000d610 <__avr32_f64_div_res_subnormal+0x36>
8000d5e8:	ee 06 11 20 	rsub	r6,r7,32
8000d5ec:	e4 07 0a 42 	lsr	r2,r2,r7
8000d5f0:	e6 06 09 4c 	lsl	r12,r3,r6
8000d5f4:	18 42       	or	r2,r12
8000d5f6:	e6 07 0a 43 	lsr	r3,r3,r7
8000d5fa:	f4 06 09 41 	lsl	r1,r10,r6
8000d5fe:	f4 07 0a 4a 	lsr	r10,r10,r7
8000d602:	f6 06 09 4c 	lsl	r12,r11,r6
8000d606:	18 4a       	or	r10,r12
8000d608:	f6 07 0a 4b 	lsr	r11,r11,r7
8000d60c:	30 00       	mov	r0,0
8000d60e:	c1 58       	rjmp	8000d638 <__avr32_f64_div_res_subnormal+0x5e>
8000d610:	ee 06 11 20 	rsub	r6,r7,32
8000d614:	f9 b0 00 00 	moveq	r0,0
8000d618:	f9 bc 00 00 	moveq	r12,0
8000d61c:	c0 50       	breq	8000d626 <__avr32_f64_div_res_subnormal+0x4c>
8000d61e:	f4 06 09 40 	lsl	r0,r10,r6
8000d622:	f6 06 09 4c 	lsl	r12,r11,r6
8000d626:	e6 07 0a 42 	lsr	r2,r3,r7
8000d62a:	30 03       	mov	r3,0
8000d62c:	f4 07 0a 41 	lsr	r1,r10,r7
8000d630:	18 41       	or	r1,r12
8000d632:	f6 07 0a 4a 	lsr	r10,r11,r7
8000d636:	30 0b       	mov	r11,0
8000d638:	e0 12 ff 00 	andl	r2,0xff00
8000d63c:	e8 12 00 80 	orl	r2,0x80
8000d640:	e6 08 06 46 	mulu.d	r6,r3,r8
8000d644:	e4 09 07 46 	macu.d	r6,r2,r9
8000d648:	e4 08 06 44 	mulu.d	r4,r2,r8
8000d64c:	e6 09 06 48 	mulu.d	r8,r3,r9
8000d650:	0c 05       	add	r5,r6
8000d652:	f0 07 00 48 	adc	r8,r8,r7
8000d656:	5c 09       	acr	r9
8000d658:	30 07       	mov	r7,0
8000d65a:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000d65e:	00 34       	cp.w	r4,r0
8000d660:	e2 05 13 00 	cpc	r5,r1
8000d664:	c4 6b       	rjmp	8000d4f0 <__avr32_f64_div_round_subnormal>
8000d666:	1c 9b       	mov	r11,lr
8000d668:	e6 1b 80 00 	andh	r11,0x8000,COH
8000d66c:	30 0a       	mov	r10,0
8000d66e:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000d672:	3f fb       	mov	r11,-1
8000d674:	30 0a       	mov	r10,0
8000d676:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000d67a:	f5 eb 10 04 	or	r4,r10,r11
8000d67e:	c0 90       	breq	8000d690 <__avr32_f64_div_op1_zero>
8000d680:	1c 9b       	mov	r11,lr
8000d682:	e6 1b 80 00 	andh	r11,0x8000,COH
8000d686:	ea 1b 7f f0 	orh	r11,0x7ff0
8000d68a:	30 0a       	mov	r10,0
8000d68c:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc

8000d690 <__avr32_f64_div_op1_zero>:
8000d690:	f1 e9 10 15 	or	r5,r8,r9<<0x1
8000d694:	ce f0       	breq	8000d672 <__avr32_f64_div_res_subnormal+0x98>
8000d696:	e9 d9 c2 8b 	bfextu	r4,r9,0x14,0xb
8000d69a:	e0 44 07 ff 	cp.w	r4,2047
8000d69e:	ce 41       	brne	8000d666 <__avr32_f64_div_res_subnormal+0x8c>
8000d6a0:	f1 e9 10 c5 	or	r5,r8,r9<<0xc
8000d6a4:	ce 10       	breq	8000d666 <__avr32_f64_div_res_subnormal+0x8c>
8000d6a6:	ce 6b       	rjmp	8000d672 <__avr32_f64_div_res_subnormal+0x98>

8000d6a8 <__avr32_udiv64>:
8000d6a8:	d4 31       	pushm	r0-r7,lr
8000d6aa:	1a 97       	mov	r7,sp
8000d6ac:	20 3d       	sub	sp,12
8000d6ae:	10 9c       	mov	r12,r8
8000d6b0:	12 9e       	mov	lr,r9
8000d6b2:	14 93       	mov	r3,r10
8000d6b4:	58 09       	cp.w	r9,0
8000d6b6:	e0 81 00 bd 	brne	8000d830 <__avr32_udiv64+0x188>
8000d6ba:	16 38       	cp.w	r8,r11
8000d6bc:	e0 88 00 40 	brls	8000d73c <__avr32_udiv64+0x94>
8000d6c0:	f0 08 12 00 	clz	r8,r8
8000d6c4:	c0 d0       	breq	8000d6de <__avr32_udiv64+0x36>
8000d6c6:	f6 08 09 4b 	lsl	r11,r11,r8
8000d6ca:	f0 09 11 20 	rsub	r9,r8,32
8000d6ce:	f8 08 09 4c 	lsl	r12,r12,r8
8000d6d2:	f4 09 0a 49 	lsr	r9,r10,r9
8000d6d6:	f4 08 09 43 	lsl	r3,r10,r8
8000d6da:	f3 eb 10 0b 	or	r11,r9,r11
8000d6de:	f8 0e 16 10 	lsr	lr,r12,0x10
8000d6e2:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000d6e6:	f6 0e 0d 00 	divu	r0,r11,lr
8000d6ea:	e6 0b 16 10 	lsr	r11,r3,0x10
8000d6ee:	00 99       	mov	r9,r0
8000d6f0:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000d6f4:	e0 0a 02 48 	mul	r8,r0,r10
8000d6f8:	10 3b       	cp.w	r11,r8
8000d6fa:	c0 a2       	brcc	8000d70e <__avr32_udiv64+0x66>
8000d6fc:	20 19       	sub	r9,1
8000d6fe:	18 0b       	add	r11,r12
8000d700:	18 3b       	cp.w	r11,r12
8000d702:	c0 63       	brcs	8000d70e <__avr32_udiv64+0x66>
8000d704:	10 3b       	cp.w	r11,r8
8000d706:	f7 b9 03 01 	sublo	r9,1
8000d70a:	f7 dc e3 0b 	addcs	r11,r11,r12
8000d70e:	f6 08 01 01 	sub	r1,r11,r8
8000d712:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000d716:	e2 0e 0d 00 	divu	r0,r1,lr
8000d71a:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000d71e:	00 98       	mov	r8,r0
8000d720:	e0 0a 02 4a 	mul	r10,r0,r10
8000d724:	14 33       	cp.w	r3,r10
8000d726:	c0 82       	brcc	8000d736 <__avr32_udiv64+0x8e>
8000d728:	20 18       	sub	r8,1
8000d72a:	18 03       	add	r3,r12
8000d72c:	18 33       	cp.w	r3,r12
8000d72e:	c0 43       	brcs	8000d736 <__avr32_udiv64+0x8e>
8000d730:	14 33       	cp.w	r3,r10
8000d732:	f7 b8 03 01 	sublo	r8,1
8000d736:	f1 e9 11 08 	or	r8,r8,r9<<0x10
8000d73a:	cd f8       	rjmp	8000d8f8 <__avr32_udiv64+0x250>
8000d73c:	58 08       	cp.w	r8,0
8000d73e:	c0 51       	brne	8000d748 <__avr32_udiv64+0xa0>
8000d740:	30 19       	mov	r9,1
8000d742:	f2 08 0d 08 	divu	r8,r9,r8
8000d746:	10 9c       	mov	r12,r8
8000d748:	f8 06 12 00 	clz	r6,r12
8000d74c:	c0 41       	brne	8000d754 <__avr32_udiv64+0xac>
8000d74e:	18 1b       	sub	r11,r12
8000d750:	30 19       	mov	r9,1
8000d752:	c4 08       	rjmp	8000d7d2 <__avr32_udiv64+0x12a>
8000d754:	ec 01 11 20 	rsub	r1,r6,32
8000d758:	f4 01 0a 49 	lsr	r9,r10,r1
8000d75c:	f8 06 09 4c 	lsl	r12,r12,r6
8000d760:	f6 06 09 48 	lsl	r8,r11,r6
8000d764:	f6 01 0a 41 	lsr	r1,r11,r1
8000d768:	f3 e8 10 08 	or	r8,r9,r8
8000d76c:	f8 03 16 10 	lsr	r3,r12,0x10
8000d770:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000d774:	e2 03 0d 00 	divu	r0,r1,r3
8000d778:	f0 0b 16 10 	lsr	r11,r8,0x10
8000d77c:	00 9e       	mov	lr,r0
8000d77e:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000d782:	e0 05 02 49 	mul	r9,r0,r5
8000d786:	12 3b       	cp.w	r11,r9
8000d788:	c0 a2       	brcc	8000d79c <__avr32_udiv64+0xf4>
8000d78a:	20 1e       	sub	lr,1
8000d78c:	18 0b       	add	r11,r12
8000d78e:	18 3b       	cp.w	r11,r12
8000d790:	c0 63       	brcs	8000d79c <__avr32_udiv64+0xf4>
8000d792:	12 3b       	cp.w	r11,r9
8000d794:	f7 be 03 01 	sublo	lr,1
8000d798:	f7 dc e3 0b 	addcs	r11,r11,r12
8000d79c:	12 1b       	sub	r11,r9
8000d79e:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
8000d7a2:	f6 03 0d 02 	divu	r2,r11,r3
8000d7a6:	f1 e3 11 08 	or	r8,r8,r3<<0x10
8000d7aa:	04 99       	mov	r9,r2
8000d7ac:	e4 05 02 4b 	mul	r11,r2,r5
8000d7b0:	16 38       	cp.w	r8,r11
8000d7b2:	c0 a2       	brcc	8000d7c6 <__avr32_udiv64+0x11e>
8000d7b4:	20 19       	sub	r9,1
8000d7b6:	18 08       	add	r8,r12
8000d7b8:	18 38       	cp.w	r8,r12
8000d7ba:	c0 63       	brcs	8000d7c6 <__avr32_udiv64+0x11e>
8000d7bc:	16 38       	cp.w	r8,r11
8000d7be:	f7 b9 03 01 	sublo	r9,1
8000d7c2:	f1 dc e3 08 	addcs	r8,r8,r12
8000d7c6:	f4 06 09 43 	lsl	r3,r10,r6
8000d7ca:	f0 0b 01 0b 	sub	r11,r8,r11
8000d7ce:	f3 ee 11 09 	or	r9,r9,lr<<0x10
8000d7d2:	f8 06 16 10 	lsr	r6,r12,0x10
8000d7d6:	fd dc c0 10 	bfextu	lr,r12,0x0,0x10
8000d7da:	f6 06 0d 00 	divu	r0,r11,r6
8000d7de:	e6 0b 16 10 	lsr	r11,r3,0x10
8000d7e2:	00 9a       	mov	r10,r0
8000d7e4:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000d7e8:	e0 0e 02 48 	mul	r8,r0,lr
8000d7ec:	10 3b       	cp.w	r11,r8
8000d7ee:	c0 a2       	brcc	8000d802 <__avr32_udiv64+0x15a>
8000d7f0:	20 1a       	sub	r10,1
8000d7f2:	18 0b       	add	r11,r12
8000d7f4:	18 3b       	cp.w	r11,r12
8000d7f6:	c0 63       	brcs	8000d802 <__avr32_udiv64+0x15a>
8000d7f8:	10 3b       	cp.w	r11,r8
8000d7fa:	f7 ba 03 01 	sublo	r10,1
8000d7fe:	f7 dc e3 0b 	addcs	r11,r11,r12
8000d802:	f6 08 01 01 	sub	r1,r11,r8
8000d806:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000d80a:	e2 06 0d 00 	divu	r0,r1,r6
8000d80e:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000d812:	00 98       	mov	r8,r0
8000d814:	e0 0e 02 4b 	mul	r11,r0,lr
8000d818:	16 33       	cp.w	r3,r11
8000d81a:	c0 82       	brcc	8000d82a <__avr32_udiv64+0x182>
8000d81c:	20 18       	sub	r8,1
8000d81e:	18 03       	add	r3,r12
8000d820:	18 33       	cp.w	r3,r12
8000d822:	c0 43       	brcs	8000d82a <__avr32_udiv64+0x182>
8000d824:	16 33       	cp.w	r3,r11
8000d826:	f7 b8 03 01 	sublo	r8,1
8000d82a:	f1 ea 11 08 	or	r8,r8,r10<<0x10
8000d82e:	c6 98       	rjmp	8000d900 <__avr32_udiv64+0x258>
8000d830:	16 39       	cp.w	r9,r11
8000d832:	e0 8b 00 65 	brhi	8000d8fc <__avr32_udiv64+0x254>
8000d836:	f2 09 12 00 	clz	r9,r9
8000d83a:	c0 b1       	brne	8000d850 <__avr32_udiv64+0x1a8>
8000d83c:	10 3a       	cp.w	r10,r8
8000d83e:	5f 2a       	srhs	r10
8000d840:	1c 3b       	cp.w	r11,lr
8000d842:	5f b8       	srhi	r8
8000d844:	10 4a       	or	r10,r8
8000d846:	f2 0a 18 00 	cp.b	r10,r9
8000d84a:	c5 90       	breq	8000d8fc <__avr32_udiv64+0x254>
8000d84c:	30 18       	mov	r8,1
8000d84e:	c5 98       	rjmp	8000d900 <__avr32_udiv64+0x258>
8000d850:	f0 09 09 46 	lsl	r6,r8,r9
8000d854:	f2 03 11 20 	rsub	r3,r9,32
8000d858:	fc 09 09 4e 	lsl	lr,lr,r9
8000d85c:	f0 03 0a 48 	lsr	r8,r8,r3
8000d860:	f6 09 09 4c 	lsl	r12,r11,r9
8000d864:	f4 03 0a 42 	lsr	r2,r10,r3
8000d868:	ef 46 ff f4 	st.w	r7[-12],r6
8000d86c:	f6 03 0a 43 	lsr	r3,r11,r3
8000d870:	18 42       	or	r2,r12
8000d872:	f1 ee 10 0c 	or	r12,r8,lr
8000d876:	f8 01 16 10 	lsr	r1,r12,0x10
8000d87a:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000d87e:	e6 01 0d 04 	divu	r4,r3,r1
8000d882:	e4 03 16 10 	lsr	r3,r2,0x10
8000d886:	08 9e       	mov	lr,r4
8000d888:	e7 e5 11 03 	or	r3,r3,r5<<0x10
8000d88c:	e8 06 02 48 	mul	r8,r4,r6
8000d890:	10 33       	cp.w	r3,r8
8000d892:	c0 a2       	brcc	8000d8a6 <__avr32_udiv64+0x1fe>
8000d894:	20 1e       	sub	lr,1
8000d896:	18 03       	add	r3,r12
8000d898:	18 33       	cp.w	r3,r12
8000d89a:	c0 63       	brcs	8000d8a6 <__avr32_udiv64+0x1fe>
8000d89c:	10 33       	cp.w	r3,r8
8000d89e:	f7 be 03 01 	sublo	lr,1
8000d8a2:	e7 dc e3 03 	addcs	r3,r3,r12
8000d8a6:	10 13       	sub	r3,r8
8000d8a8:	f7 d2 c0 10 	bfextu	r11,r2,0x0,0x10
8000d8ac:	e6 01 0d 00 	divu	r0,r3,r1
8000d8b0:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000d8b4:	00 98       	mov	r8,r0
8000d8b6:	e0 06 02 46 	mul	r6,r0,r6
8000d8ba:	0c 3b       	cp.w	r11,r6
8000d8bc:	c0 a2       	brcc	8000d8d0 <__avr32_udiv64+0x228>
8000d8be:	20 18       	sub	r8,1
8000d8c0:	18 0b       	add	r11,r12
8000d8c2:	18 3b       	cp.w	r11,r12
8000d8c4:	c0 63       	brcs	8000d8d0 <__avr32_udiv64+0x228>
8000d8c6:	0c 3b       	cp.w	r11,r6
8000d8c8:	f7 dc e3 0b 	addcs	r11,r11,r12
8000d8cc:	f7 b8 03 01 	sublo	r8,1
8000d8d0:	f1 ee 11 08 	or	r8,r8,lr<<0x10
8000d8d4:	ee f4 ff f4 	ld.w	r4,r7[-12]
8000d8d8:	0c 1b       	sub	r11,r6
8000d8da:	f0 04 06 42 	mulu.d	r2,r8,r4
8000d8de:	06 95       	mov	r5,r3
8000d8e0:	16 35       	cp.w	r5,r11
8000d8e2:	e0 8b 00 0a 	brhi	8000d8f6 <__avr32_udiv64+0x24e>
8000d8e6:	5f 0b       	sreq	r11
8000d8e8:	f4 09 09 49 	lsl	r9,r10,r9
8000d8ec:	12 32       	cp.w	r2,r9
8000d8ee:	5f b9       	srhi	r9
8000d8f0:	f7 e9 00 09 	and	r9,r11,r9
8000d8f4:	c0 60       	breq	8000d900 <__avr32_udiv64+0x258>
8000d8f6:	20 18       	sub	r8,1
8000d8f8:	30 09       	mov	r9,0
8000d8fa:	c0 38       	rjmp	8000d900 <__avr32_udiv64+0x258>
8000d8fc:	30 09       	mov	r9,0
8000d8fe:	12 98       	mov	r8,r9
8000d900:	10 9a       	mov	r10,r8
8000d902:	12 93       	mov	r3,r9
8000d904:	10 92       	mov	r2,r8
8000d906:	12 9b       	mov	r11,r9
8000d908:	2f dd       	sub	sp,-12
8000d90a:	d8 32       	popm	r0-r7,pc

8000d90c <__avr32_umod64>:
8000d90c:	d4 31       	pushm	r0-r7,lr
8000d90e:	1a 97       	mov	r7,sp
8000d910:	20 3d       	sub	sp,12
8000d912:	10 9c       	mov	r12,r8
8000d914:	12 95       	mov	r5,r9
8000d916:	14 9e       	mov	lr,r10
8000d918:	16 91       	mov	r1,r11
8000d91a:	16 96       	mov	r6,r11
8000d91c:	58 09       	cp.w	r9,0
8000d91e:	e0 81 00 81 	brne	8000da20 <__avr32_umod64+0x114>
8000d922:	16 38       	cp.w	r8,r11
8000d924:	e0 88 00 12 	brls	8000d948 <__avr32_umod64+0x3c>
8000d928:	f0 08 12 00 	clz	r8,r8
8000d92c:	c4 e0       	breq	8000d9c8 <__avr32_umod64+0xbc>
8000d92e:	f6 08 09 46 	lsl	r6,r11,r8
8000d932:	f8 08 09 4c 	lsl	r12,r12,r8
8000d936:	f0 0b 11 20 	rsub	r11,r8,32
8000d93a:	f4 08 09 4e 	lsl	lr,r10,r8
8000d93e:	f4 0b 0a 4b 	lsr	r11,r10,r11
8000d942:	f7 e6 10 06 	or	r6,r11,r6
8000d946:	c4 18       	rjmp	8000d9c8 <__avr32_umod64+0xbc>
8000d948:	58 08       	cp.w	r8,0
8000d94a:	c0 51       	brne	8000d954 <__avr32_umod64+0x48>
8000d94c:	30 19       	mov	r9,1
8000d94e:	f2 08 0d 08 	divu	r8,r9,r8
8000d952:	10 9c       	mov	r12,r8
8000d954:	f8 08 12 00 	clz	r8,r12
8000d958:	c0 31       	brne	8000d95e <__avr32_umod64+0x52>
8000d95a:	18 16       	sub	r6,r12
8000d95c:	c3 68       	rjmp	8000d9c8 <__avr32_umod64+0xbc>
8000d95e:	f0 03 11 20 	rsub	r3,r8,32
8000d962:	f4 03 0a 4b 	lsr	r11,r10,r3
8000d966:	f8 08 09 4c 	lsl	r12,r12,r8
8000d96a:	ec 08 09 49 	lsl	r9,r6,r8
8000d96e:	ec 03 0a 43 	lsr	r3,r6,r3
8000d972:	f7 e9 10 09 	or	r9,r11,r9
8000d976:	f8 05 16 10 	lsr	r5,r12,0x10
8000d97a:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000d97e:	e6 05 0d 02 	divu	r2,r3,r5
8000d982:	f2 0e 16 10 	lsr	lr,r9,0x10
8000d986:	ec 02 02 4b 	mul	r11,r6,r2
8000d98a:	fd e3 11 0e 	or	lr,lr,r3<<0x10
8000d98e:	16 3e       	cp.w	lr,r11
8000d990:	c0 72       	brcc	8000d99e <__avr32_umod64+0x92>
8000d992:	18 0e       	add	lr,r12
8000d994:	18 3e       	cp.w	lr,r12
8000d996:	c0 43       	brcs	8000d99e <__avr32_umod64+0x92>
8000d998:	16 3e       	cp.w	lr,r11
8000d99a:	fd dc e3 0e 	addcs	lr,lr,r12
8000d99e:	fc 0b 01 03 	sub	r3,lr,r11
8000d9a2:	f3 d9 c0 10 	bfextu	r9,r9,0x0,0x10
8000d9a6:	e6 05 0d 02 	divu	r2,r3,r5
8000d9aa:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000d9ae:	a5 36       	mul	r6,r2
8000d9b0:	0c 39       	cp.w	r9,r6
8000d9b2:	c0 72       	brcc	8000d9c0 <__avr32_umod64+0xb4>
8000d9b4:	18 09       	add	r9,r12
8000d9b6:	18 39       	cp.w	r9,r12
8000d9b8:	c0 43       	brcs	8000d9c0 <__avr32_umod64+0xb4>
8000d9ba:	0c 39       	cp.w	r9,r6
8000d9bc:	f3 dc e3 09 	addcs	r9,r9,r12
8000d9c0:	f2 06 01 06 	sub	r6,r9,r6
8000d9c4:	f4 08 09 4e 	lsl	lr,r10,r8
8000d9c8:	f8 0a 16 10 	lsr	r10,r12,0x10
8000d9cc:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000d9d0:	ec 0a 0d 02 	divu	r2,r6,r10
8000d9d4:	fc 09 16 10 	lsr	r9,lr,0x10
8000d9d8:	ea 02 02 4b 	mul	r11,r5,r2
8000d9dc:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000d9e0:	16 39       	cp.w	r9,r11
8000d9e2:	c0 72       	brcc	8000d9f0 <__avr32_umod64+0xe4>
8000d9e4:	18 09       	add	r9,r12
8000d9e6:	18 39       	cp.w	r9,r12
8000d9e8:	c0 43       	brcs	8000d9f0 <__avr32_umod64+0xe4>
8000d9ea:	16 39       	cp.w	r9,r11
8000d9ec:	f3 dc e3 09 	addcs	r9,r9,r12
8000d9f0:	f2 0b 01 0b 	sub	r11,r9,r11
8000d9f4:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000d9f8:	f6 0a 0d 0a 	divu	r10,r11,r10
8000d9fc:	fd eb 11 0e 	or	lr,lr,r11<<0x10
8000da00:	ea 0a 02 4a 	mul	r10,r5,r10
8000da04:	14 3e       	cp.w	lr,r10
8000da06:	c0 72       	brcc	8000da14 <__avr32_umod64+0x108>
8000da08:	18 0e       	add	lr,r12
8000da0a:	18 3e       	cp.w	lr,r12
8000da0c:	c0 43       	brcs	8000da14 <__avr32_umod64+0x108>
8000da0e:	14 3e       	cp.w	lr,r10
8000da10:	fd dc e3 0e 	addcs	lr,lr,r12
8000da14:	fc 0a 01 0a 	sub	r10,lr,r10
8000da18:	30 0b       	mov	r11,0
8000da1a:	f4 08 0a 4a 	lsr	r10,r10,r8
8000da1e:	c7 b8       	rjmp	8000db14 <__avr32_umod64+0x208>
8000da20:	16 39       	cp.w	r9,r11
8000da22:	e0 8b 00 79 	brhi	8000db14 <__avr32_umod64+0x208>
8000da26:	f2 09 12 00 	clz	r9,r9
8000da2a:	c1 21       	brne	8000da4e <__avr32_umod64+0x142>
8000da2c:	10 3a       	cp.w	r10,r8
8000da2e:	5f 2b       	srhs	r11
8000da30:	0a 31       	cp.w	r1,r5
8000da32:	5f ba       	srhi	r10
8000da34:	f7 ea 10 0a 	or	r10,r11,r10
8000da38:	f2 0a 18 00 	cp.b	r10,r9
8000da3c:	c0 60       	breq	8000da48 <__avr32_umod64+0x13c>
8000da3e:	fc 08 01 0c 	sub	r12,lr,r8
8000da42:	e2 05 01 46 	sbc	r6,r1,r5
8000da46:	18 9e       	mov	lr,r12
8000da48:	0c 9b       	mov	r11,r6
8000da4a:	1c 9a       	mov	r10,lr
8000da4c:	c6 48       	rjmp	8000db14 <__avr32_umod64+0x208>
8000da4e:	ea 09 09 4c 	lsl	r12,r5,r9
8000da52:	f2 06 11 20 	rsub	r6,r9,32
8000da56:	f6 09 09 4b 	lsl	r11,r11,r9
8000da5a:	f0 09 09 42 	lsl	r2,r8,r9
8000da5e:	ef 46 ff f4 	st.w	r7[-12],r6
8000da62:	f0 06 0a 48 	lsr	r8,r8,r6
8000da66:	18 48       	or	r8,r12
8000da68:	e2 06 0a 4c 	lsr	r12,r1,r6
8000da6c:	f4 09 09 43 	lsl	r3,r10,r9
8000da70:	fd d8 c0 10 	bfextu	lr,r8,0x0,0x10
8000da74:	f4 06 0a 4a 	lsr	r10,r10,r6
8000da78:	16 4a       	or	r10,r11
8000da7a:	f0 0b 16 10 	lsr	r11,r8,0x10
8000da7e:	f8 0b 0d 04 	divu	r4,r12,r11
8000da82:	f4 0c 16 10 	lsr	r12,r10,0x10
8000da86:	08 91       	mov	r1,r4
8000da88:	f9 e5 11 0c 	or	r12,r12,r5<<0x10
8000da8c:	e8 0e 02 46 	mul	r6,r4,lr
8000da90:	0c 3c       	cp.w	r12,r6
8000da92:	c0 a2       	brcc	8000daa6 <__avr32_umod64+0x19a>
8000da94:	20 11       	sub	r1,1
8000da96:	10 0c       	add	r12,r8
8000da98:	10 3c       	cp.w	r12,r8
8000da9a:	c0 63       	brcs	8000daa6 <__avr32_umod64+0x19a>
8000da9c:	0c 3c       	cp.w	r12,r6
8000da9e:	f7 b1 03 01 	sublo	r1,1
8000daa2:	f9 d8 e3 0c 	addcs	r12,r12,r8
8000daa6:	0c 1c       	sub	r12,r6
8000daa8:	f5 da c0 10 	bfextu	r10,r10,0x0,0x10
8000daac:	f8 0b 0d 04 	divu	r4,r12,r11
8000dab0:	f5 e5 11 0b 	or	r11,r10,r5<<0x10
8000dab4:	08 96       	mov	r6,r4
8000dab6:	e8 0e 02 4e 	mul	lr,r4,lr
8000daba:	1c 3b       	cp.w	r11,lr
8000dabc:	c0 a2       	brcc	8000dad0 <__avr32_umod64+0x1c4>
8000dabe:	20 16       	sub	r6,1
8000dac0:	10 0b       	add	r11,r8
8000dac2:	10 3b       	cp.w	r11,r8
8000dac4:	c0 63       	brcs	8000dad0 <__avr32_umod64+0x1c4>
8000dac6:	1c 3b       	cp.w	r11,lr
8000dac8:	f7 b6 03 01 	sublo	r6,1
8000dacc:	f7 d8 e3 0b 	addcs	r11,r11,r8
8000dad0:	ed e1 11 01 	or	r1,r6,r1<<0x10
8000dad4:	1c 1b       	sub	r11,lr
8000dad6:	e2 02 06 40 	mulu.d	r0,r1,r2
8000dada:	00 9e       	mov	lr,r0
8000dadc:	02 9c       	mov	r12,r1
8000dade:	16 3c       	cp.w	r12,r11
8000dae0:	e0 8b 00 08 	brhi	8000daf0 <__avr32_umod64+0x1e4>
8000dae4:	5f 06       	sreq	r6
8000dae6:	06 30       	cp.w	r0,r3
8000dae8:	5f ba       	srhi	r10
8000daea:	ed ea 00 0a 	and	r10,r6,r10
8000daee:	c0 60       	breq	8000dafa <__avr32_umod64+0x1ee>
8000daf0:	fc 02 01 04 	sub	r4,lr,r2
8000daf4:	f8 08 01 4c 	sbc	r12,r12,r8
8000daf8:	08 9e       	mov	lr,r4
8000dafa:	e6 0e 01 0a 	sub	r10,r3,lr
8000dafe:	f6 0c 01 4c 	sbc	r12,r11,r12
8000db02:	ee f1 ff f4 	ld.w	r1,r7[-12]
8000db06:	f8 09 0a 4b 	lsr	r11,r12,r9
8000db0a:	f4 09 0a 4a 	lsr	r10,r10,r9
8000db0e:	f8 01 09 4c 	lsl	r12,r12,r1
8000db12:	18 4a       	or	r10,r12
8000db14:	2f dd       	sub	sp,-12
8000db16:	d8 32       	popm	r0-r7,pc

Disassembly of section .exception:

8000dc00 <_evba>:
_evba:

        .org  0x000
        // Unrecoverable Exception.
_handle_Unrecoverable_Exception:
        rjmp $
8000dc00:	c0 08       	rjmp	8000dc00 <_evba>
	...

8000dc04 <_handle_TLB_Multiple_Hit>:

        .org  0x004
        // TLB Multiple Hit: UNUSED IN AVR32UC.
_handle_TLB_Multiple_Hit:
        rjmp $
8000dc04:	c0 08       	rjmp	8000dc04 <_handle_TLB_Multiple_Hit>
	...

8000dc08 <_handle_Bus_Error_Data_Fetch>:

        .org  0x008
        // Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
        rjmp $
8000dc08:	c0 08       	rjmp	8000dc08 <_handle_Bus_Error_Data_Fetch>
	...

8000dc0c <_handle_Bus_Error_Instruction_Fetch>:

        .org  0x00C
         // Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
        rjmp $
8000dc0c:	c0 08       	rjmp	8000dc0c <_handle_Bus_Error_Instruction_Fetch>
	...

8000dc10 <_handle_NMI>:

        .org  0x010
        // NMI.
_handle_NMI:
        rjmp $
8000dc10:	c0 08       	rjmp	8000dc10 <_handle_NMI>
	...

8000dc14 <_handle_Instruction_Address>:

        .org  0x014
        // Instruction Address.
_handle_Instruction_Address:
        rjmp $
8000dc14:	c0 08       	rjmp	8000dc14 <_handle_Instruction_Address>
	...

8000dc18 <_handle_ITLB_Protection>:

        .org  0x018
        // ITLB Protection.
_handle_ITLB_Protection:
        rjmp $
8000dc18:	c0 08       	rjmp	8000dc18 <_handle_ITLB_Protection>
	...

8000dc1c <_handle_Breakpoint>:

        .org  0x01C
        // Breakpoint.
_handle_Breakpoint:
        rjmp $
8000dc1c:	c0 08       	rjmp	8000dc1c <_handle_Breakpoint>
	...

8000dc20 <_handle_Illegal_Opcode>:

        .org  0x020
        // Illegal Opcode.
_handle_Illegal_Opcode:
        rjmp $
8000dc20:	c0 08       	rjmp	8000dc20 <_handle_Illegal_Opcode>
	...

8000dc24 <_handle_Unimplemented_Instruction>:

        .org  0x024
        // Unimplemented Instruction.
_handle_Unimplemented_Instruction:
        rjmp $
8000dc24:	c0 08       	rjmp	8000dc24 <_handle_Unimplemented_Instruction>
	...

8000dc28 <_handle_Privilege_Violation>:

        .org  0x028
        // Privilege Violation.
_handle_Privilege_Violation:
        rjmp $
8000dc28:	c0 08       	rjmp	8000dc28 <_handle_Privilege_Violation>
	...

8000dc2c <_handle_Floating_Point>:

        .org  0x02C
        // Floating-Point: UNUSED IN AVR32UC.
_handle_Floating_Point:
        rjmp $
8000dc2c:	c0 08       	rjmp	8000dc2c <_handle_Floating_Point>
	...

8000dc30 <_handle_Coprocessor_Absent>:

        .org  0x030
        // Coprocessor Absent: UNUSED IN AVR32UC.
_handle_Coprocessor_Absent:
        rjmp $
8000dc30:	c0 08       	rjmp	8000dc30 <_handle_Coprocessor_Absent>
	...

8000dc34 <_handle_Data_Address_Read>:

        .org  0x034
        // Data Address (Read).
_handle_Data_Address_Read:
        rjmp $
8000dc34:	c0 08       	rjmp	8000dc34 <_handle_Data_Address_Read>
	...

8000dc38 <_handle_Data_Address_Write>:

        .org  0x038
        // Data Address (Write).
_handle_Data_Address_Write:
        rjmp $
8000dc38:	c0 08       	rjmp	8000dc38 <_handle_Data_Address_Write>
	...

8000dc3c <_handle_DTLB_Protection_Read>:

        .org  0x03C
        // DTLB Protection (Read).
_handle_DTLB_Protection_Read:
        rjmp $
8000dc3c:	c0 08       	rjmp	8000dc3c <_handle_DTLB_Protection_Read>
	...

8000dc40 <_handle_DTLB_Protection_Write>:

        .org  0x040
        // DTLB Protection (Write).
_handle_DTLB_Protection_Write:
        rjmp $
8000dc40:	c0 08       	rjmp	8000dc40 <_handle_DTLB_Protection_Write>
	...

8000dc44 <_handle_DTLB_Modified>:

        .org  0x044
        // DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
        rjmp $
8000dc44:	c0 08       	rjmp	8000dc44 <_handle_DTLB_Modified>
	...

8000dc50 <_handle_ITLB_Miss>:

        .org  0x050
        // ITLB Miss: UNUSED IN AVR32UC.
_handle_ITLB_Miss:
        rjmp $
8000dc50:	c0 08       	rjmp	8000dc50 <_handle_ITLB_Miss>
	...

8000dc60 <_handle_DTLB_Miss_Read>:

        .org  0x060
        // DTLB Miss (Read): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Read:
        rjmp $
8000dc60:	c0 08       	rjmp	8000dc60 <_handle_DTLB_Miss_Read>
	...

8000dc70 <_handle_DTLB_Miss_Write>:

        .org  0x070
        // DTLB Miss (Write): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Write:
        rjmp $
8000dc70:	c0 08       	rjmp	8000dc70 <_handle_DTLB_Miss_Write>
	...

8000dd00 <_handle_Supervisor_Call>:

        .org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	lda.w   pc, SCALLYield
8000dd00:	fe cf 70 a4 	sub	pc,pc,28836

8000dd04 <_int0>:
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
	rete
.endr
8000dd04:	30 0c       	mov	r12,0
8000dd06:	fe b0 c3 11 	rcall	80006328 <_get_interrupt_handler>
8000dd0a:	58 0c       	cp.w	r12,0
8000dd0c:	f8 0f 17 10 	movne	pc,r12
8000dd10:	d6 03       	rete

8000dd12 <_int1>:
8000dd12:	30 1c       	mov	r12,1
8000dd14:	fe b0 c3 0a 	rcall	80006328 <_get_interrupt_handler>
8000dd18:	58 0c       	cp.w	r12,0
8000dd1a:	f8 0f 17 10 	movne	pc,r12
8000dd1e:	d6 03       	rete

8000dd20 <_int2>:
8000dd20:	30 2c       	mov	r12,2
8000dd22:	fe b0 c3 03 	rcall	80006328 <_get_interrupt_handler>
8000dd26:	58 0c       	cp.w	r12,0
8000dd28:	f8 0f 17 10 	movne	pc,r12
8000dd2c:	d6 03       	rete

8000dd2e <_int3>:
8000dd2e:	30 3c       	mov	r12,3
8000dd30:	fe b0 c2 fc 	rcall	80006328 <_get_interrupt_handler>
8000dd34:	58 0c       	cp.w	r12,0
8000dd36:	f8 0f 17 10 	movne	pc,r12
8000dd3a:	d6 03       	rete

8000dd3c <ipr_val>:
8000dd3c:	00 00 01 04 40 00 01 12 80 00 01 20 c0 00 01 2e     ....@...... ....
8000dd4c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000dd5c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000dd6c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000dd7c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000dd8c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000dd9c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000ddac:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000ddbc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000ddcc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000dddc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000ddec:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000ddfc:	d7 03 d7 03                                         ....
